webpackJsonp([0],[
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\n__webpack_require__(1);\n\n__webpack_require__(4);\n\n__webpack_require__(6);\n\n__webpack_require__(8);\n\n__webpack_require__(10);\n\n__webpack_require__(12);\n\n__webpack_require__(14);\n\n__webpack_require__(16);\n\n__webpack_require__(18);\n\n__webpack_require__(20);\n\n__webpack_require__(22);//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9ub2RlX21vZHVsZXMvdmVuaWNlLWpzL21haW5Gcm9hbGEuanM/NWM3MyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENyZWF0ZWQgYnkgYnVyMDEgb24gOS8xMi8xNi5cbiAqL1xuaW1wb3J0ICdzY3JpcHQhZnJvYWxhLWVkaXRvci9qcy9mcm9hbGFfZWRpdG9yLm1pbi5qcyc7XG5pbXBvcnQgJ3NjcmlwdCFjb2RlbWlycm9yL2xpYi9jb2RlbWlycm9yLmpzJztcbmltcG9ydCAnc2NyaXB0IWNvZGVtaXJyb3IvbW9kZS94bWwveG1sLmpzJztcbmltcG9ydCAnc2NyaXB0IWZyb2FsYS1lZGl0b3IvanMvcGx1Z2lucy9hbGlnbi5taW4uanMnO1xuaW1wb3J0ICdzY3JpcHQhZnJvYWxhLWVkaXRvci9qcy9wbHVnaW5zL2NoYXJfY291bnRlci5taW4uanMnO1xuaW1wb3J0ICdzY3JpcHQhZnJvYWxhLWVkaXRvci9qcy9wbHVnaW5zL2NvZGVfdmlldy5taW4uanMnO1xuaW1wb3J0ICdzY3JpcHQhZnJvYWxhLWVkaXRvci9qcy9wbHVnaW5zL2VudGl0aWVzLm1pbi5qcyc7XG5pbXBvcnQgJ3NjcmlwdCFmcm9hbGEtZWRpdG9yL2pzL3BsdWdpbnMvbGluay5taW4uanMnO1xuaW1wb3J0ICdzY3JpcHQhZnJvYWxhLWVkaXRvci9qcy9wbHVnaW5zL3VybC5taW4uanMnO1xuaW1wb3J0ICdzY3JpcHQhZnJvYWxhLWVkaXRvci9qcy9wbHVnaW5zL2ltYWdlLm1pbi5qcyc7XG5pbXBvcnQgJ3NjcmlwdCFmcm9hbGEtZWRpdG9yL2pzL2xhbmd1YWdlcy9lbl9nYi5qcyc7XG5cblxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIG5vZGVfbW9kdWxlcy92ZW5pY2UtanMvbWFpbkZyb2FsYS5qcyJdLCJtYXBwaW5ncyI6Ijs7QUFHQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUEiLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	eval("__webpack_require__(2)(__webpack_require__(3))//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL34vZnJvYWxhLWVkaXRvci9qcy9mcm9hbGFfZWRpdG9yLm1pbi5qcz9hOWQwIl0sInNvdXJjZXNDb250ZW50IjpbInJlcXVpcmUoXCIhIS92YXIvYXBwL3dlYi9qcy9ub2RlX21vZHVsZXMvc2NyaXB0LWxvYWRlci9hZGRTY3JpcHQuanNcIikocmVxdWlyZShcIiEhL3Zhci9hcHAvd2ViL2pzL25vZGVfbW9kdWxlcy9yYXctbG9hZGVyL2luZGV4LmpzIS92YXIvYXBwL3dlYi9qcy9ub2RlX21vZHVsZXMvZnJvYWxhLWVkaXRvci9qcy9mcm9hbGFfZWRpdG9yLm1pbi5qc1wiKSlcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vc2NyaXB0LWxvYWRlciEuL34vZnJvYWxhLWVkaXRvci9qcy9mcm9hbGFfZWRpdG9yLm1pbi5qc1xuLy8gbW9kdWxlIGlkID0gMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 2 */
/***/ function(module, exports) {

	eval("/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\r\nmodule.exports = function(src) {\r\n\tif (typeof execScript !== \"undefined\")\r\n\t\texecScript(src);\r\n\telse\r\n\t\teval.call(null, src);\r\n}\r\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL34vc2NyaXB0LWxvYWRlci9hZGRTY3JpcHQuanM/ODEwNyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxyXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXHJcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxyXG4qL1xyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHNyYykge1xyXG5cdGlmICh0eXBlb2YgZXhlY1NjcmlwdCAhPT0gXCJ1bmRlZmluZWRcIilcclxuXHRcdGV4ZWNTY3JpcHQoc3JjKTtcclxuXHRlbHNlXHJcblx0XHRldmFsLmNhbGwobnVsbCwgc3JjKTtcclxufVxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vc2NyaXB0LWxvYWRlci9hZGRTY3JpcHQuanNcbi8vIG1vZHVsZSBpZCA9IDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 3 */
/***/ function(module, exports) {

	eval("module.exports = \"/*!\\n * froala_editor v2.5.1 (https://www.froala.com/wysiwyg-editor)\\n * License https://froala.com/wysiwyg-editor/terms/\\n * Copyright 2014-2017 Froala Labs\\n */\\n\\n!function(a){\\\"function\\\"==typeof define&&define.amd?define([\\\"jquery\\\"],a):\\\"object\\\"==typeof module&&module.exports?module.exports=function(b,c){return void 0===c&&(c=\\\"undefined\\\"!=typeof window?require(\\\"jquery\\\"):require(\\\"jquery\\\")(b)),a(c)}:a(window.jQuery)}(function(a){var b=function(c,d){this.id=++a.FE.ID,this.opts=a.extend(!0,{},a.extend({},b.DEFAULTS,\\\"object\\\"==typeof d&&d));var e=JSON.stringify(this.opts);a.FE.OPTS_MAPPING[e]=a.FE.OPTS_MAPPING[e]||this.id,this.sid=a.FE.OPTS_MAPPING[e],a.FE.SHARED[this.sid]=a.FE.SHARED[this.sid]||{},this.shared=a.FE.SHARED[this.sid],this.shared.count=(this.shared.count||0)+1,this.$oel=a(c),this.$oel.data(\\\"froala.editor\\\",this),this.o_doc=c.ownerDocument,this.o_win=\\\"defaultView\\\"in this.o_doc?this.o_doc.defaultView:this.o_doc.parentWindow;var f=a(this.o_win).scrollTop();this.$oel.on(\\\"froala.doInit\\\",a.proxy(function(){this.$oel.off(\\\"froala.doInit\\\"),this.doc=this.$el.get(0).ownerDocument,this.win=\\\"defaultView\\\"in this.doc?this.doc.defaultView:this.doc.parentWindow,this.$doc=a(this.doc),this.$win=a(this.win),this.opts.pluginsEnabled||(this.opts.pluginsEnabled=Object.keys(a.FE.PLUGINS)),this.opts.initOnClick?(this.load(a.FE.MODULES),this.$el.on(\\\"touchstart.init\\\",function(){a(this).data(\\\"touched\\\",!0)}),this.$el.on(\\\"touchmove.init\\\",function(){a(this).removeData(\\\"touched\\\")}),this.$el.on(\\\"mousedown.init touchend.init dragenter.init focus.init\\\",a.proxy(function(b){if(\\\"touchend\\\"==b.type&&!this.$el.data(\\\"touched\\\"))return!0;if(1===b.which||!b.which){this.$el.off(\\\"mousedown.init touchstart.init touchmove.init touchend.init dragenter.init focus.init\\\"),this.load(a.FE.MODULES),this.load(a.FE.PLUGINS);var c=b.originalEvent&&b.originalEvent.originalTarget;c&&\\\"IMG\\\"==c.tagName&&a(c).trigger(\\\"mousedown\\\"),\\\"undefined\\\"==typeof this.ul&&this.destroy(),\\\"touchend\\\"==b.type&&this.image&&b.originalEvent&&b.originalEvent.target&&a(b.originalEvent.target).is(\\\"img\\\")&&setTimeout(a.proxy(function(){this.image.edit(a(b.originalEvent.target))},this),100),this.ready=!0,this.events.trigger(\\\"initialized\\\")}},this))):(this.load(a.FE.MODULES),this.load(a.FE.PLUGINS),a(this.o_win).scrollTop(f),\\\"undefined\\\"==typeof this.ul&&this.destroy(),this.ready=!0,this.events.trigger(\\\"initialized\\\"))},this)),this._init()};b.DEFAULTS={initOnClick:!1,pluginsEnabled:null},b.MODULES={},b.PLUGINS={},b.VERSION=\\\"2.5.1\\\",b.INSTANCES=[],b.OPTS_MAPPING={},b.SHARED={},b.ID=0,b.prototype._init=function(){var b=this.$oel.prop(\\\"tagName\\\");this.$oel.closest(\\\"label\\\").length>=1;var c=a.proxy(function(){\\\"TEXTAREA\\\"!=b&&(this._original_html=this._original_html||this.$oel.html()),this.$box=this.$box||this.$oel,this.opts.fullPage&&(this.opts.iframe=!0),this.opts.iframe?(this.$iframe=a('<iframe src=\\\"about:blank\\\" frameBorder=\\\"0\\\">'),this.$wp=a(\\\"<div></div>\\\"),this.$box.html(this.$wp),this.$wp.append(this.$iframe),this.$iframe.get(0).contentWindow.document.open(),this.$iframe.get(0).contentWindow.document.write(\\\"<!DOCTYPE html>\\\"),this.$iframe.get(0).contentWindow.document.write(\\\"<html><head></head><body></body></html>\\\"),this.$iframe.get(0).contentWindow.document.close(),this.$el=this.$iframe.contents().find(\\\"body\\\"),this.el=this.$el.get(0),this.$head=this.$iframe.contents().find(\\\"head\\\"),this.$html=this.$iframe.contents().find(\\\"html\\\"),this.iframe_document=this.$iframe.get(0).contentWindow.document,this.$oel.trigger(\\\"froala.doInit\\\")):(this.$el=a(\\\"<div></div>\\\"),this.el=this.$el.get(0),this.$wp=a(\\\"<div></div>\\\").append(this.$el),this.$box.html(this.$wp),this.$oel.trigger(\\\"froala.doInit\\\"))},this),d=a.proxy(function(){this.$box=a(\\\"<div>\\\"),this.$oel.before(this.$box).hide(),this._original_html=this.$oel.val(),this.$oel.parents(\\\"form\\\").on(\\\"submit.\\\"+this.id,a.proxy(function(){this.events.trigger(\\\"form.submit\\\")},this)),this.$oel.parents(\\\"form\\\").on(\\\"reset.\\\"+this.id,a.proxy(function(){this.events.trigger(\\\"form.reset\\\")},this)),c()},this),e=a.proxy(function(){this.$el=this.$oel,this.el=this.$el.get(0),this.$el.attr(\\\"contenteditable\\\",!0).css(\\\"outline\\\",\\\"none\\\").css(\\\"display\\\",\\\"inline-block\\\"),this.opts.multiLine=!1,this.opts.toolbarInline=!1,this.$oel.trigger(\\\"froala.doInit\\\")},this),f=a.proxy(function(){this.$el=this.$oel,this.el=this.$el.get(0),this.opts.toolbarInline=!1,this.$oel.trigger(\\\"froala.doInit\\\")},this),g=a.proxy(function(){this.$el=this.$oel,this.el=this.$el.get(0),this.opts.toolbarInline=!1,this.$oel.on(\\\"click.popup\\\",function(a){a.preventDefault()}),this.$oel.trigger(\\\"froala.doInit\\\")},this);this.opts.editInPopup?g():\\\"TEXTAREA\\\"==b?d():\\\"A\\\"==b?e():\\\"IMG\\\"==b?f():\\\"BUTTON\\\"==b||\\\"INPUT\\\"==b?(this.opts.editInPopup=!0,this.opts.toolbarInline=!1,g()):c()},b.prototype.load=function(b){for(var c in b)if(b.hasOwnProperty(c)){if(this[c])continue;if(a.FE.PLUGINS[c]&&this.opts.pluginsEnabled.indexOf(c)<0)continue;if(this[c]=new b[c](this),this[c]._init&&(this[c]._init(),this.opts.initOnClick&&\\\"core\\\"==c))return!1}},b.prototype.destroy=function(){this.shared.count--,this.events.$off();var b=this.html.get();if(this.events.trigger(\\\"destroy\\\",[],!0),this.events.trigger(\\\"shared.destroy\\\",void 0,!0),0===this.shared.count){for(var c in this.shared)this.shared.hasOwnProperty(c)&&(null==this.shared[c],a.FE.SHARED[this.sid][c]=null);a.FE.SHARED[this.sid]={}}this.$oel.parents(\\\"form\\\").off(\\\".\\\"+this.id),this.$oel.off(\\\"click.popup\\\"),this.$oel.removeData(\\\"froala.editor\\\"),this.$oel.off(\\\"froalaEditor\\\"),this.core.destroy(b),a.FE.INSTANCES.splice(a.FE.INSTANCES.indexOf(this),1)},a.fn.froalaEditor=function(c){for(var d=[],e=0;e<arguments.length;e++)d.push(arguments[e]);if(\\\"string\\\"==typeof c){var f=[];return this.each(function(){var b=a(this),e=b.data(\\\"froala.editor\\\");if(e){var g,h;if(c.indexOf(\\\".\\\")>0&&e[c.split(\\\".\\\")[0]]?(e[c.split(\\\".\\\")[0]]&&(g=e[c.split(\\\".\\\")[0]]),h=c.split(\\\".\\\")[1]):(g=e,h=c.split(\\\".\\\")[0]),!g[h])return a.error(\\\"Method \\\"+c+\\\" does not exist in Froala Editor.\\\");var i=g[h].apply(e,d.slice(1));void 0===i?f.push(this):0===f.length&&f.push(i)}}),1==f.length?f[0]:f}if(\\\"object\\\"==typeof c||!c)return this.each(function(){var d=a(this).data(\\\"froala.editor\\\");if(!d){var e=this;new b(e,c)}})},a.fn.froalaEditor.Constructor=b,a.FroalaEditor=b,a.FE=b,a.FE.XS=0,a.FE.SM=1,a.FE.MD=2,a.FE.LG=3,a.FE.MODULES.helpers=function(b){function c(){var a,b,c=-1;return\\\"Microsoft Internet Explorer\\\"==navigator.appName?(a=navigator.userAgent,b=new RegExp(\\\"MSIE ([0-9]{1,}[\\\\\\\\.0-9]{0,})\\\"),null!==b.exec(a)&&(c=parseFloat(RegExp.$1))):\\\"Netscape\\\"==navigator.appName&&(a=navigator.userAgent,b=new RegExp(\\\"Trident/.*rv:([0-9]{1,}[\\\\\\\\.0-9]{0,})\\\"),null!==b.exec(a)&&(c=parseFloat(RegExp.$1))),c}function d(){var a={},b=c();if(b>0)a.msie=!0;else{var d=navigator.userAgent.toLowerCase(),e=/(edge)[ \\\\/]([\\\\w.]+)/.exec(d)||/(chrome)[ \\\\/]([\\\\w.]+)/.exec(d)||/(webkit)[ \\\\/]([\\\\w.]+)/.exec(d)||/(opera)(?:.*version|)[ \\\\/]([\\\\w.]+)/.exec(d)||/(msie) ([\\\\w.]+)/.exec(d)||d.indexOf(\\\"compatible\\\")<0&&/(mozilla)(?:.*? rv:([\\\\w.]+)|)/.exec(d)||[],f={browser:e[1]||\\\"\\\",version:e[2]||\\\"0\\\"};e[1]&&(a[f.browser]=!0),a.chrome?a.webkit=!0:a.webkit&&(a.safari=!0)}return a.msie&&(a.version=b),a}function e(){return/(iPad|iPhone|iPod)/g.test(navigator.userAgent)&&!h()}function f(){return/(Android)/g.test(navigator.userAgent)&&!h()}function g(){return/(Blackberry)/g.test(navigator.userAgent)}function h(){return/(Windows Phone)/gi.test(navigator.userAgent)}function i(){return f()||e()||g()}function j(){return window.requestAnimationFrame||window.webkitRequestAnimationFrame||window.mozRequestAnimationFrame||function(a){window.setTimeout(a,1e3/60)}}function k(a){return parseInt(a,10)||0}function l(){var b=a('<div class=\\\"fr-visibility-helper\\\"></div>').appendTo(\\\"body\\\"),c=k(b.css(\\\"margin-left\\\"));return b.remove(),c}function m(){return\\\"ontouchstart\\\"in window||window.DocumentTouch&&document instanceof DocumentTouch}function n(a){if(!/^(https?:|ftps?:|)\\\\/\\\\//i.test(a))return!1;a=String(a).replace(/</g,\\\"%3C\\\").replace(/>/g,\\\"%3E\\\").replace(/\\\"/g,\\\"%22\\\").replace(/ /g,\\\"%20\\\");var b=/(http|ftp|https):\\\\/\\\\/[a-z\\\\u00a1-\\\\uffff0-9{}]+(\\\\.[a-z\\\\u00a1-\\\\uffff0-9{}]*)*([a-z\\\\u00a1-\\\\uffff0-9.,@?^=%&amp;:\\\\/~+#-_{}]*[a-z\\\\u00a1-\\\\uffff0-9@?^=%&amp;\\\\/~+#-_{}])?/gi;return b.test(a)}function o(a){if(/^(https?:|ftps?:|)\\\\/\\\\//i.test(a)){if(!n(a)&&!n(\\\"http:\\\"+a))return\\\"\\\"}else a=encodeURIComponent(a).replace(/%23/g,\\\"#\\\").replace(/%2F/g,\\\"/\\\").replace(/%25/g,\\\"%\\\").replace(/mailto%3A/gi,\\\"mailto:\\\").replace(/file%3A/gi,\\\"file:\\\").replace(/sms%3A/gi,\\\"sms:\\\").replace(/tel%3A/gi,\\\"tel:\\\").replace(/notes%3A/gi,\\\"notes:\\\").replace(/data%3Aimage/gi,\\\"data:image\\\").replace(/blob%3A/gi,\\\"blob:\\\").replace(/webkit-fake-url%3A/gi,\\\"webkit-fake-url:\\\").replace(/%3F/g,\\\"?\\\").replace(/%3D/g,\\\"=\\\").replace(/%26/g,\\\"&\\\").replace(/&amp;/g,\\\"&\\\").replace(/%2C/g,\\\",\\\").replace(/%3B/g,\\\";\\\").replace(/%2B/g,\\\"+\\\").replace(/%40/g,\\\"@\\\").replace(/%5B/g,\\\"[\\\").replace(/%5D/g,\\\"]\\\").replace(/%7B/g,\\\"{\\\").replace(/%7D/g,\\\"}\\\");return a}function p(a){return a&&!a.propertyIsEnumerable(\\\"length\\\")&&\\\"object\\\"==typeof a&&\\\"number\\\"==typeof a.length}function q(a){function b(a){return(\\\"0\\\"+parseInt(a,10).toString(16)).slice(-2)}try{return a&&\\\"transparent\\\"!==a?/^#[0-9A-F]{6}$/i.test(a)?a:(a=a.match(/^rgb\\\\((\\\\d+),\\\\s*(\\\\d+),\\\\s*(\\\\d+)\\\\)$/),(\\\"#\\\"+b(a[1])+b(a[2])+b(a[3])).toUpperCase()):\\\"\\\"}catch(c){return null}}function r(a){var b=/^#?([a-f\\\\d])([a-f\\\\d])([a-f\\\\d])$/i;a=a.replace(b,function(a,b,c,d){return b+b+c+c+d+d});var c=/^#?([a-f\\\\d]{2})([a-f\\\\d]{2})([a-f\\\\d]{2})$/i.exec(a);return c?\\\"rgb(\\\"+parseInt(c[1],16)+\\\", \\\"+parseInt(c[2],16)+\\\", \\\"+parseInt(c[3],16)+\\\")\\\":\\\"\\\"}function s(c){var d=(c.css(\\\"text-align\\\")||\\\"\\\").replace(/-(.*)-/g,\\\"\\\");if([\\\"left\\\",\\\"right\\\",\\\"justify\\\",\\\"center\\\"].indexOf(d)<0){if(!y){var e=a('<div dir=\\\"'+(\\\"rtl\\\"==b.opts.direction?\\\"rtl\\\":\\\"auto\\\")+'\\\" style=\\\"text-align: '+b.$el.css(\\\"text-align\\\")+'; position: fixed; left: -3000px;\\\"><span id=\\\"s1\\\">.</span><span id=\\\"s2\\\">.</span></div>');a(\\\"body\\\").append(e);var f=e.find(\\\"#s1\\\").get(0).getBoundingClientRect().left,g=e.find(\\\"#s2\\\").get(0).getBoundingClientRect().left;e.remove(),y=f<g?\\\"left\\\":\\\"right\\\"}d=y}return d}function t(){return null==z&&(z=navigator.platform.toUpperCase().indexOf(\\\"MAC\\\")>=0),z}function u(){function a(a,b){var d=a[b];a[b]=function(a){var b,f=!1,g=!1;if(a&&a.match(e)){a=a.replace(e,\\\"\\\"),this.parentNode||(c.appendChild(this),g=!0);var h=this.parentNode;return this.id||(this.id=\\\"rootedQuerySelector_id_\\\"+(new Date).getTime(),f=!0),b=d.call(h,\\\"#\\\"+this.id+\\\" \\\"+a),f&&(this.id=\\\"\\\"),g&&c.removeChild(this),b}return d.call(this,a)}}var c=b.o_doc.createElement(\\\"div\\\");try{c.querySelectorAll(\\\":scope *\\\")}catch(d){var e=/^\\\\s*:scope/gi;a(Element.prototype,\\\"querySelector\\\"),a(Element.prototype,\\\"querySelectorAll\\\")}}function v(){return b.o_win.pageYOffset?b.o_win.pageYOffset:b.o_doc.documentElement&&b.o_doc.documentElement.scrollTop?b.o_doc.documentElement.scrollTop:b.o_doc.body.scrollTop?b.o_doc.body.scrollTop:0}function w(){return b.o_win.pageXOffset?b.o_win.pageXOffset:b.o_doc.documentElement&&b.o_doc.documentElement.scrollLeft?b.o_doc.documentElement.scrollLeft:b.o_doc.body.scrollLeft?b.o_doc.body.scrollLeft:0}function x(){b.browser=d(),u()}var y,z=null;return{_init:x,isIOS:e,isMac:t,isAndroid:f,isBlackberry:g,isWindowsPhone:h,isMobile:i,requestAnimationFrame:j,getPX:k,screenSize:l,isTouch:m,sanitizeURL:o,isArray:p,RGBToHex:q,HEXtoRGB:r,isURL:n,getAlignment:s,scrollTop:v,scrollLeft:w}},a.FE.MODULES.events=function(b){function c(a,b,c){s(a,b,c)}function d(){c(b.$el,\\\"cut copy paste beforepaste\\\",function(a){v(a.type,[a])})}function e(){c(b.$el,\\\"click mouseup mousedown touchstart touchend dragenter dragover dragleave dragend drop dragstart\\\",function(a){v(a.type,[a])}),r(\\\"mousedown\\\",function(){for(var c=0;c<a.FE.INSTANCES.length;c++)a.FE.INSTANCES[c]!=b&&a.FE.INSTANCES[c].popups&&a.FE.INSTANCES[c].popups.areVisible()&&a.FE.INSTANCES[c].$el.find(\\\".fr-marker\\\").remove()})}function f(){c(b.$el,\\\"keydown keypress keyup input\\\",function(a){v(a.type,[a])})}function g(){c(b.$win,b._mousedown,function(a){v(\\\"window.mousedown\\\",[a]),n()}),c(b.$win,b._mouseup,function(a){v(\\\"window.mouseup\\\",[a])}),c(b.$win,\\\"cut copy keydown keyup touchmove touchend\\\",function(a){v(\\\"window.\\\"+a.type,[a])})}function h(){c(b.$doc,\\\"dragend drop\\\",function(a){v(\\\"document.\\\"+a.type,[a])})}function i(c){if(\\\"undefined\\\"==typeof c&&(c=!0),!b.$wp)return!1;if(b.helpers.isIOS()&&b.$win.get(0).focus(),!b.core.hasFocus()&&c){var d=b.$win.scrollTop();return b.browser.msie&&b.$box&&b.$box.css(\\\"position\\\",\\\"fixed\\\"),b.$el.focus(),b.browser.msie&&b.$box&&b.$box.css(\\\"position\\\",\\\"\\\"),d!=b.$win.scrollTop()&&b.$win.scrollTop(d),!1}if(!b.core.hasFocus()||b.$el.find(\\\".fr-marker\\\").length>0)return!1;var e=b.selection.info(b.el);if(e.atStart&&b.selection.isCollapsed()&&null!=b.html.defaultTag()){var f=b.markers.insert();if(f&&!b.node.blockParent(f)){a(f).remove();var g=b.$el.find(b.html.blockTagsQuery()).get(0);g&&(a(g).prepend(a.FE.MARKERS),b.selection.restore())}else f&&a(f).remove()}}function j(){c(b.$el,\\\"focus\\\",function(a){p()&&(i(!1),C===!1&&v(a.type,[a]))}),c(b.$el,\\\"blur\\\",function(a){p()&&C===!0&&(v(a.type,[a]),n())}),r(\\\"focus\\\",function(){C=!0}),r(\\\"blur\\\",function(){C=!1})}function k(){b.helpers.isMobile()?(b._mousedown=\\\"touchstart\\\",b._mouseup=\\\"touchend\\\",b._move=\\\"touchmove\\\",b._mousemove=\\\"touchmove\\\"):(b._mousedown=\\\"mousedown\\\",b._mouseup=\\\"mouseup\\\",b._move=\\\"\\\",b._mousemove=\\\"mousemove\\\")}function l(c){var d=a(c.currentTarget);return b.edit.isDisabled()||b.node.hasClass(d.get(0),\\\"fr-disabled\\\")?(c.preventDefault(),!1):\\\"mousedown\\\"===c.type&&1!==c.which||(b.helpers.isMobile()||c.preventDefault(),(b.helpers.isAndroid()||b.helpers.isWindowsPhone())&&0===d.parents(\\\".fr-dropdown-menu\\\").length&&(c.preventDefault(),c.stopPropagation()),d.addClass(\\\"fr-selected\\\"),void b.events.trigger(\\\"commands.mousedown\\\",[d]))}function m(c,d){var e=a(c.currentTarget);if(b.edit.isDisabled()||b.node.hasClass(e.get(0),\\\"fr-disabled\\\"))return c.preventDefault(),!1;if(\\\"mouseup\\\"===c.type&&1!==c.which)return!0;if(!b.node.hasClass(e.get(0),\\\"fr-selected\\\"))return!0;if(\\\"touchmove\\\"!=c.type){if(c.stopPropagation(),c.stopImmediatePropagation(),c.preventDefault(),!b.node.hasClass(e.get(0),\\\"fr-selected\\\"))return b.button.getButtons(\\\".fr-selected\\\",!0).removeClass(\\\"fr-selected\\\"),!1;if(b.button.getButtons(\\\".fr-selected\\\",!0).removeClass(\\\"fr-selected\\\"),e.data(\\\"dragging\\\")||e.attr(\\\"disabled\\\"))return e.removeData(\\\"dragging\\\"),!1;var f=e.data(\\\"timeout\\\");f&&(clearTimeout(f),e.removeData(\\\"timeout\\\")),d.apply(b,[c])}else e.data(\\\"timeout\\\")||e.data(\\\"timeout\\\",setTimeout(function(){e.data(\\\"dragging\\\",!0)},100))}function n(){A=!0}function o(){A=!1}function p(){return A}function q(a,c,d){s(a,b._mousedown,c,function(a){b.edit.isDisabled()||l(a)},!0),s(a,b._mouseup+\\\" \\\"+b._move,c,function(a){b.edit.isDisabled()||m(a,d)},!0),s(a,\\\"mousedown click mouseup\\\",c,function(a){b.edit.isDisabled()||a.stopPropagation()},!0),r(\\\"window.mouseup\\\",function(){b.edit.isDisabled()||(a.find(c).removeClass(\\\"fr-selected\\\"),n())})}function r(a,c,d){var e=a.split(\\\" \\\");if(e.length>1){for(var f=0;f<e.length;f++)r(e[f],c,d);return!0}\\\"undefined\\\"==typeof d&&(d=!1);var g;g=0!==a.indexOf(\\\"shared.\\\")?B[a]=B[a]||[]:b.shared._events[a]=b.shared._events[a]||[],d?g.unshift(c):g.push(c)}function s(a,c,d,e,f){\\\"function\\\"==typeof d&&(f=e,e=d,d=!1);var g=f?b.shared.$_events:D,h=f?b.sid:b.id;d?a.on(c.split(\\\" \\\").join(\\\".ed\\\"+h+\\\" \\\")+\\\".ed\\\"+h,d,e):a.on(c.split(\\\" \\\").join(\\\".ed\\\"+h+\\\" \\\")+\\\".ed\\\"+h,e),g.indexOf(a.get(0))<0&&g.push(a.get(0))}function t(b,c){for(var d=0;d<b.length;d++)a(b[d]).off(\\\".ed\\\"+c)}function u(){t(D,b.id),D=[],0===b.shared.count&&(t(b.shared.$_events,b.sid),b.shared.$_events=null)}function v(c,d,e){if(!b.edit.isDisabled()||e){var f;if(0!==c.indexOf(\\\"shared.\\\"))f=B[c];else{if(b.shared.count>0)return!1;f=b.shared._events[c]}var g;if(f)for(var h=0;h<f.length;h++)if(g=f[h].apply(b,d),g===!1)return!1;return g=b.$oel.triggerHandler(\\\"froalaEditor.\\\"+c,a.merge([b],d||[])),g!==!1&&g}}function w(c,d,e){if(!b.edit.isDisabled()||e){var f;if(0!==c.indexOf(\\\"shared.\\\"))f=B[c];else{if(b.shared.count>0)return!1;f=b.shared._events[c]}var g;if(f)for(var h=0;h<f.length;h++)g=f[h].apply(b,[d]),\\\"undefined\\\"!=typeof g&&(d=g);return g=b.$oel.triggerHandler(\\\"froalaEditor.\\\"+c,a.merge([b],[d])),\\\"undefined\\\"!=typeof g&&(d=g),d}}function x(){for(var a in B)B.hasOwnProperty(a)&&delete B[a]}function y(){for(var a in b.shared._events)b.shared._events.hasOwnProperty(a)&&delete b.shared._events[a]}function z(){b.shared.$_events=b.shared.$_events||[],b.shared._events={},k(),e(),g(),h(),f(),j(),n(),d(),r(\\\"destroy\\\",x),r(\\\"shared.destroy\\\",y)}var A,B={},C=!1,D=[];return{_init:z,on:r,trigger:v,bindClick:q,disableBlur:o,enableBlur:n,blurActive:p,focus:i,chainTrigger:w,$on:s,$off:u}},a.FE.MODULES.node=function(b){function c(a){return a&&\\\"IFRAME\\\"!=a.tagName?Array.prototype.slice.call(a.childNodes||[]):[]}function d(b){return!!b&&(b.nodeType==Node.ELEMENT_NODE&&a.FE.BLOCK_TAGS.indexOf(b.tagName.toLowerCase())>=0)}function e(e,f){if(!e)return!0;if(e.querySelector(\\\"table\\\"))return!1;var g=c(e);1==g.length&&d(g[0])&&(g=c(g[0]));for(var h=!1,i=0;i<g.length;i++){var j=g[i];if(!(f&&b.node.hasClass(j,\\\"fr-marker\\\")||j.nodeType==Node.TEXT_NODE&&0===j.textContent.length)){if(\\\"BR\\\"!=j.tagName&&(j.textContent||\\\"\\\").replace(/\\\\u200B/gi,\\\"\\\").replace(/\\\\n/g,\\\"\\\").length>0)return!1;if(h)return!1;\\\"BR\\\"==j.tagName&&(h=!0)}}return!(e.querySelectorAll(a.FE.VOID_ELEMENTS.join(\\\",\\\")).length-e.querySelectorAll(\\\"br\\\").length)&&(!e.querySelector(b.opts.htmlAllowedEmptyTags.join(\\\":not(.fr-marker),\\\")+\\\":not(.fr-marker)\\\")&&(!(e.querySelectorAll(a.FE.BLOCK_TAGS.join(\\\",\\\")).length>1)&&!e.querySelector(b.opts.htmlDoNotWrapTags.join(\\\":not(.fr-marker),\\\")+\\\":not(.fr-marker)\\\")))}function f(a){for(;a&&a.parentNode!==b.el&&(!a.parentNode||!b.node.hasClass(a.parentNode,\\\"fr-inner\\\"));)if(a=a.parentNode,d(a))return a;return null}function g(c,e,f){if(\\\"undefined\\\"==typeof e&&(e=[]),\\\"undefined\\\"==typeof f&&(f=!0),e.push(b.el),e.indexOf(c.parentNode)>=0||c.parentNode&&b.node.hasClass(c.parentNode,\\\"fr-inner\\\")||c.parentNode&&a.FE.SIMPLE_ENTER_TAGS.indexOf(c.parentNode.tagName)>=0&&f)return null;for(;e.indexOf(c.parentNode)<0&&c.parentNode&&!b.node.hasClass(c.parentNode,\\\"fr-inner\\\")&&(a.FE.SIMPLE_ENTER_TAGS.indexOf(c.parentNode.tagName)<0||!f)&&(!d(c)||!d(c.parentNode)||!f);)c=c.parentNode;return c}function h(a){var b={},c=a.attributes;if(c)for(var d=0;d<c.length;d++){var e=c[d];b[e.nodeName]=e.value}return b}function i(a){for(var b=\\\"\\\",c=h(a),d=Object.keys(c).sort(),e=0;e<d.length;e++){var f=d[e],g=c[f];g.indexOf(\\\"'\\\")<0&&g.indexOf('\\\"')>=0?b+=\\\" \\\"+f+\\\"='\\\"+g+\\\"'\\\":g.indexOf('\\\"')>=0&&g.indexOf(\\\"'\\\")>=0?(g=g.replace(/\\\"/g,\\\"&quot;\\\"),b+=\\\" \\\"+f+'=\\\"'+g+'\\\"'):b+=\\\" \\\"+f+'=\\\"'+g+'\\\"'}return b}function j(a){for(var b=a.attributes,c=b.length-1;c>=0;c--){var d=b[c];a.removeAttribute(d.nodeName)}}function k(a){return\\\"<\\\"+a.tagName.toLowerCase()+i(a)+\\\">\\\"}function l(a){return\\\"</\\\"+a.tagName.toLowerCase()+\\\">\\\"}function m(a,c){\\\"undefined\\\"==typeof c&&(c=!0);for(var d=a.previousSibling;d&&c&&b.node.hasClass(d,\\\"fr-marker\\\");)d=d.previousSibling;return!d||d.nodeType==Node.TEXT_NODE&&\\\"\\\"===d.textContent&&m(d)}function n(a,c){\\\"undefined\\\"==typeof c&&(c=!0);for(var d=a.nextSibling;d&&c&&b.node.hasClass(d,\\\"fr-marker\\\");)d=d.nextSibling;return!d||d.nodeType==Node.TEXT_NODE&&\\\"\\\"===d.textContent&&n(d)}function o(b){return b&&b.nodeType==Node.ELEMENT_NODE&&a.FE.VOID_ELEMENTS.indexOf((b.tagName||\\\"\\\").toLowerCase())>=0}function p(a){return!!a&&[\\\"UL\\\",\\\"OL\\\"].indexOf(a.tagName)>=0}function q(a){return a===b.el}function r(a){return a&&a.nodeType==Node.ELEMENT_NODE&&a.getAttribute(\\\"class\\\")&&(a.getAttribute(\\\"class\\\")||\\\"\\\").indexOf(\\\"fr-deletable\\\")>=0}function s(a){return a===b.doc.activeElement&&(!b.doc.hasFocus||b.doc.hasFocus())&&!!(q(a)||a.type||a.href||~a.tabIndex)}function t(a){return(!a.getAttribute||\\\"false\\\"!=a.getAttribute(\\\"contenteditable\\\"))&&[\\\"STYLE\\\",\\\"SCRIPT\\\"].indexOf(a.tagName)<0}function u(b,c){return b instanceof a&&(b=b.get(0)),b&&b.classList&&b.classList.contains(c)}function v(a){return b.browser.msie?a:{acceptNode:a}}return{isBlock:d,isEmpty:e,blockParent:f,deepestParent:g,rawAttributes:h,attributes:i,clearAttributes:j,openTagString:k,closeTagString:l,isFirstSibling:m,isLastSibling:n,isList:p,isElement:q,contents:c,isVoid:o,hasFocus:s,isEditable:t,isDeletable:r,hasClass:u,filter:v}},a.FE.INVISIBLE_SPACE=\\\"&#8203;\\\",a.FE.START_MARKER='<span class=\\\"fr-marker\\\" data-id=\\\"0\\\" data-type=\\\"true\\\" style=\\\"display: none; line-height: 0;\\\">'+a.FE.INVISIBLE_SPACE+\\\"</span>\\\",a.FE.END_MARKER='<span class=\\\"fr-marker\\\" data-id=\\\"0\\\" data-type=\\\"false\\\" style=\\\"display: none; line-height: 0;\\\">'+a.FE.INVISIBLE_SPACE+\\\"</span>\\\",a.FE.MARKERS=a.FE.START_MARKER+a.FE.END_MARKER,a.FE.MODULES.markers=function(b){function c(c,d){return a('<span class=\\\"fr-marker\\\" data-id=\\\"'+d+'\\\" data-type=\\\"'+c+'\\\" style=\\\"display: '+(b.browser.safari?\\\"none\\\":\\\"inline-block\\\")+'; line-height: 0;\\\">'+a.FE.INVISIBLE_SPACE+\\\"</span>\\\",b.doc)[0]}function d(d,e,f){var g,h,i;try{var j=d.cloneRange();if(j.collapse(e),j.insertNode(c(e,f)),e===!0&&d.collapsed)for(g=b.$el.find('span.fr-marker[data-type=\\\"true\\\"][data-id=\\\"'+f+'\\\"]'),i=g.get(0).nextSibling;i&&i.nodeType===Node.TEXT_NODE&&0===i.textContent.length;)a(i).remove(),i=g.nextSibling;if(e===!0&&!d.collapsed&&(g=b.$el.find('span.fr-marker[data-type=\\\"true\\\"][data-id=\\\"'+f+'\\\"]').get(0),i=g.nextSibling,i&&i.nodeType===Node.ELEMENT_NODE&&b.node.isBlock(i))){h=[i];do i=h[0],h=b.node.contents(i);while(h[0]&&b.node.isBlock(h[0]));a(i).prepend(a(g))}if(e===!1&&!d.collapsed){if(g=b.$el.find('span.fr-marker[data-type=\\\"false\\\"][data-id=\\\"'+f+'\\\"]').get(0),i=g.previousSibling,i&&i.nodeType===Node.ELEMENT_NODE&&b.node.isBlock(i)){h=[i];do i=h[h.length-1],h=b.node.contents(i);while(h[h.length-1]&&b.node.isBlock(h[h.length-1]));a(i).append(a(g))}g.parentNode&&[\\\"TD\\\",\\\"TH\\\"].indexOf(g.parentNode.tagName)>=0&&g.parentNode.previousSibling&&!g.previousSibling&&a(g.parentNode.previousSibling).append(g)}var k=b.$el.find('span.fr-marker[data-type=\\\"'+e+'\\\"][data-id=\\\"'+f+'\\\"]').get(0);return k&&(k.style.display=\\\"none\\\"),k}catch(l){return null}}function e(){if(!b.$wp)return null;try{var c=b.selection.ranges(0),d=c.commonAncestorContainer;if(d!=b.el&&0===b.$el.find(d).length)return null;var e=c.cloneRange(),f=c.cloneRange();e.collapse(!0);var g=a('<span class=\\\"fr-marker\\\" style=\\\"display: none; line-height: 0;\\\">'+a.FE.INVISIBLE_SPACE+\\\"</span>\\\",b.doc)[0];if(e.insertNode(g),g=b.$el.find(\\\"span.fr-marker\\\").get(0)){for(var h=g.nextSibling;h&&h.nodeType===Node.TEXT_NODE&&0===h.textContent.length;)a(h).remove(),h=b.$el.find(\\\"span.fr-marker\\\").get(0).nextSibling;return b.selection.clear(),b.selection.get().addRange(f),g}return null}catch(i){}}function f(){b.selection.isCollapsed()||b.selection.remove();var c=b.$el.find(\\\".fr-marker\\\").get(0);if(null==c&&(c=e()),null==c)return null;var d=b.node.deepestParent(c);if(d||(d=b.node.blockParent(c),d&&\\\"LI\\\"!=d.tagName&&(d=null)),d)if(b.node.isBlock(d)&&b.node.isEmpty(d))\\\"LI\\\"==d.tagName&&d.parentNode.firstElementChild==d?a(d).append('<span class=\\\"fr-marker\\\"></span>'):a(d).replaceWith('<span class=\\\"fr-marker\\\"></span>');else if(b.cursor.isAtStart(c,d))a(d).before('<span class=\\\"fr-marker\\\"></span>'),a(c).remove();else if(b.cursor.isAtEnd(c,d))a(d).after('<span class=\\\"fr-marker\\\"></span>'),a(c).remove();else{var f=c,g=\\\"\\\",h=\\\"\\\";do f=f.parentNode,g+=b.node.closeTagString(f),h=b.node.openTagString(f)+h;while(f!=d);a(c).replaceWith('<span id=\\\"fr-break\\\"></span>');var i=b.node.openTagString(d)+a(d).html()+b.node.closeTagString(d);i=i.replace(/<span id=\\\"fr-break\\\"><\\\\/span>/g,g+'<span class=\\\"fr-marker\\\"></span>'+h),a(d).replaceWith(i)}return b.$el.find(\\\".fr-marker\\\").get(0)}function g(a){var c=a.clientX,d=a.clientY;h();var f,g=null;if(\\\"undefined\\\"!=typeof b.doc.caretPositionFromPoint?(f=b.doc.caretPositionFromPoint(c,d),g=b.doc.createRange(),g.setStart(f.offsetNode,f.offset),g.setEnd(f.offsetNode,f.offset)):\\\"undefined\\\"!=typeof b.doc.caretRangeFromPoint&&(f=b.doc.caretRangeFromPoint(c,d),g=b.doc.createRange(),g.setStart(f.startContainer,f.startOffset),g.setEnd(f.startContainer,f.startOffset)),null!==g&&\\\"undefined\\\"!=typeof b.win.getSelection){var i=b.win.getSelection();i.removeAllRanges(),i.addRange(g)}else if(\\\"undefined\\\"!=typeof b.doc.body.createTextRange)try{g=b.doc.body.createTextRange(),g.moveToPoint(c,d);var j=g.duplicate();j.moveToPoint(c,d),g.setEndPoint(\\\"EndToEnd\\\",j),g.select()}catch(k){return!1}e()}function h(){b.$el.find(\\\".fr-marker\\\").remove()}return{place:d,insert:e,split:f,insertAtPoint:g,remove:h}},a.FE.MODULES.selection=function(b){function c(){var a=\\\"\\\";return b.win.getSelection?a=b.win.getSelection():b.doc.getSelection?a=b.doc.getSelection():b.doc.selection&&(a=b.doc.selection.createRange().text),a.toString()}function d(){var a=\\\"\\\";return a=b.win.getSelection?b.win.getSelection():b.doc.getSelection?b.doc.getSelection():b.doc.selection.createRange()}function e(a){var c=d(),e=[];if(c&&c.getRangeAt&&c.rangeCount){e=[];for(var f=0;f<c.rangeCount;f++)e.push(c.getRangeAt(f))}else e=b.doc.createRange?[b.doc.createRange()]:[];return\\\"undefined\\\"!=typeof a?e[a]:e}function f(){var a=d();try{a.removeAllRanges?a.removeAllRanges():a.empty?a.empty():a.clear&&a.clear()}catch(b){}}function g(){var f=d();try{if(f.rangeCount){var g,h=e(0),i=h.startContainer;if(i.nodeType==Node.TEXT_NODE&&h.startOffset==(i.textContent||\\\"\\\").length&&i.nextSibling&&(i=i.nextSibling),i.nodeType==Node.ELEMENT_NODE){var j=!1;if(i.childNodes.length>0&&i.childNodes[h.startOffset]){for(g=i.childNodes[h.startOffset];g&&g.nodeType==Node.TEXT_NODE&&0===g.textContent.length;)g=g.nextSibling;if(g&&g.textContent.replace(/\\\\u200B/g,\\\"\\\")===c().replace(/\\\\u200B/g,\\\"\\\")&&(i=g,j=!0),!j&&i.childNodes.length>1&&h.startOffset>0&&i.childNodes[h.startOffset-1]){for(g=i.childNodes[h.startOffset-1];g&&g.nodeType==Node.TEXT_NODE&&0===g.textContent.length;)g=g.nextSibling;g&&g.textContent.replace(/\\\\u200B/g,\\\"\\\")===c().replace(/\\\\u200B/g,\\\"\\\")&&(i=g,j=!0)}}else!h.collapsed&&i.nextSibling&&i.nextSibling.nodeType==Node.ELEMENT_NODE&&(g=i.nextSibling,g&&g.textContent.replace(/\\\\u200B/g,\\\"\\\")===c().replace(/\\\\u200B/g,\\\"\\\")&&(i=g,j=!0));!j&&i.childNodes.length>0&&a(i.childNodes[0]).text().replace(/\\\\u200B/g,\\\"\\\")===c().replace(/\\\\u200B/g,\\\"\\\")&&[\\\"BR\\\",\\\"IMG\\\",\\\"HR\\\"].indexOf(i.childNodes[0].tagName)<0&&(i=i.childNodes[0])}for(;i.nodeType!=Node.ELEMENT_NODE&&i.parentNode;)i=i.parentNode;for(var k=i;k&&\\\"HTML\\\"!=k.tagName;){if(k==b.el)return i;k=a(k).parent()[0]}}}catch(l){}return b.el}function h(){var f=d();try{if(f.rangeCount){var g,h=e(0),i=h.endContainer;if(i.nodeType==Node.ELEMENT_NODE){var j=!1;i.childNodes.length>0&&i.childNodes[h.endOffset]&&a(i.childNodes[h.endOffset]).text()===c()?(i=i.childNodes[h.endOffset],j=!0):!h.collapsed&&i.previousSibling&&i.previousSibling.nodeType==Node.ELEMENT_NODE?(g=i.previousSibling,g&&g.textContent.replace(/\\\\u200B/g,\\\"\\\")===c().replace(/\\\\u200B/g,\\\"\\\")&&(i=g,j=!0)):!h.collapsed&&i.childNodes.length>0&&i.childNodes[h.endOffset]&&(g=i.childNodes[h.endOffset].previousSibling,g.nodeType==Node.ELEMENT_NODE&&g&&g.textContent.replace(/\\\\u200B/g,\\\"\\\")===c().replace(/\\\\u200B/g,\\\"\\\")&&(i=g,j=!0)),!j&&i.childNodes.length>0&&a(i.childNodes[i.childNodes.length-1]).text()===c()&&[\\\"BR\\\",\\\"IMG\\\",\\\"HR\\\"].indexOf(i.childNodes[i.childNodes.length-1].tagName)<0&&(i=i.childNodes[i.childNodes.length-1])}for(i.nodeType==Node.TEXT_NODE&&0===h.endOffset&&i.previousSibling&&i.previousSibling.nodeType==Node.ELEMENT_NODE&&(i=i.previousSibling);i.nodeType!=Node.ELEMENT_NODE&&i.parentNode;)i=i.parentNode;for(var k=i;k&&\\\"HTML\\\"!=k.tagName;){if(k==b.el)return i;k=a(k).parent()[0]}}}catch(l){}return b.el}function i(a,b){var c=a;return c.nodeType==Node.ELEMENT_NODE&&c.childNodes.length>0&&c.childNodes[b]&&(c=c.childNodes[b]),c.nodeType==Node.TEXT_NODE&&(c=c.parentNode),c}function j(){var c,f=[],g=d();if(u()&&g.rangeCount){var h=e();for(c=0;c<h.length;c++){var j,k=h[c],l=i(k.startContainer,k.startOffset),m=i(k.endContainer,k.endOffset);b.node.isBlock(l)&&f.indexOf(l)<0&&f.push(l),j=b.node.blockParent(l),j&&f.indexOf(j)<0&&f.push(j);for(var n=[],o=l;o!==m&&o!==b.el;)n.indexOf(o)<0&&o.children&&o.children.length?(n.push(o),o=o.children[0]):o.nextSibling?o=o.nextSibling:o.parentNode&&(o=o.parentNode,n.push(o)),b.node.isBlock(o)&&n.indexOf(o)<0&&f.indexOf(o)<0&&(o!==m||k.endOffset>0)&&f.push(o);b.node.isBlock(m)&&f.indexOf(m)<0&&k.endOffset>0&&f.push(m),j=b.node.blockParent(m),j&&f.indexOf(j)<0&&f.push(j)}}for(c=f.length-1;c>0;c--)a(f[c]).find(f).length&&(\\\"LI\\\"!=f[c].tagName||1==f[c].children.length&&f.indexOf(f[c].children[0])>=0)&&f.splice(c,1);return f}function k(){if(b.$wp){b.markers.remove();var a,c,d=e(),f=[];for(c=0;c<d.length;c++)if(d[c].startContainer!==b.doc){a=d[c];var g=a.collapsed,h=b.markers.place(a,!0,c),i=b.markers.place(a,!1,c);b.el.normalize(),b.browser.safari&&!g&&(a=b.doc.createRange(),a.setStartAfter(h),a.setEndBefore(i),f.push(a))}if(b.browser.safari&&f.length)for(b.selection.clear(),c=0;c<f.length;c++)b.selection.get().addRange(f[c])}}function l(){var c,e=b.el.querySelectorAll('.fr-marker[data-type=\\\"true\\\"]');if(!b.$wp)return b.markers.remove(),!1;if(0===e.length)return!1;if(b.browser.msie||b.browser.edge)for(c=0;c<e.length;c++)e[c].style.display=\\\"inline-block\\\";b.core.hasFocus()||b.browser.msie||b.browser.webkit||b.$el.focus(),f();var g=d();for(c=0;c<e.length;c++){var h=a(e[c]).data(\\\"id\\\"),i=e[c],j=b.doc.createRange(),k=b.$el.find('.fr-marker[data-type=\\\"false\\\"][data-id=\\\"'+h+'\\\"]');(b.browser.msie||b.browser.edge)&&k.css(\\\"display\\\",\\\"inline-block\\\");var l=null;if(k.length>0){k=k[0];try{for(var n,o=!1,p=i.nextSibling;p&&p.nodeType==Node.TEXT_NODE&&0===p.textContent.length;)n=p,p=p.nextSibling,a(n).remove();for(var q=k.nextSibling;q&&q.nodeType==Node.TEXT_NODE&&0===q.textContent.length;)n=q,q=q.nextSibling,a(n).remove();if(i.nextSibling==k||k.nextSibling==i){for(var r=i.nextSibling==k?i:k,s=r==i?k:i,t=r.previousSibling;t&&t.nodeType==Node.TEXT_NODE&&0===t.length;)n=t,t=t.previousSibling,a(n).remove();if(t&&t.nodeType==Node.TEXT_NODE)for(;t&&t.previousSibling&&t.previousSibling.nodeType==Node.TEXT_NODE;)t.previousSibling.textContent=t.previousSibling.textContent+t.textContent,t=t.previousSibling,a(t.nextSibling).remove();for(var u=s.nextSibling;u&&u.nodeType==Node.TEXT_NODE&&0===u.length;)n=u,u=u.nextSibling,a(n).remove();if(u&&u.nodeType==Node.TEXT_NODE)for(;u&&u.nextSibling&&u.nextSibling.nodeType==Node.TEXT_NODE;)u.nextSibling.textContent=u.textContent+u.nextSibling.textContent,u=u.nextSibling,a(u.previousSibling).remove();if(t&&(b.node.isVoid(t)||b.node.isBlock(t))&&(t=null),u&&(b.node.isVoid(u)||b.node.isBlock(u))&&(u=null),t&&u&&t.nodeType==Node.TEXT_NODE&&u.nodeType==Node.TEXT_NODE){a(i).remove(),a(k).remove();var v=t.textContent.length;t.textContent=t.textContent+u.textContent,a(u).remove(),b.spaces.normalize(t),j.setStart(t,v),j.setEnd(t,v),o=!0}else!t&&u&&u.nodeType==Node.TEXT_NODE?(a(i).remove(),a(k).remove(),b.spaces.normalize(u),l=a(b.doc.createTextNode(\\\"\\\\u200b\\\")),a(u).before(l),j.setStart(u,0),j.setEnd(u,0),o=!0):!u&&t&&t.nodeType==Node.TEXT_NODE&&(a(i).remove(),a(k).remove(),b.spaces.normalize(t),l=a(b.doc.createTextNode(\\\"\\\\u200b\\\")),a(t).after(l),j.setStart(t,t.textContent.length),j.setEnd(t,t.textContent.length),o=!0)}if(!o){var w,x;(b.browser.chrome||b.browser.edge)&&i.nextSibling==k?(w=m(k,j,!0)||j.setStartAfter(k),x=m(i,j,!1)||j.setEndBefore(i)):(i.previousSibling==k&&(i=k,k=i.nextSibling),k.nextSibling&&\\\"BR\\\"===k.nextSibling.tagName||!k.nextSibling&&b.node.isBlock(i.previousSibling)||i.previousSibling&&\\\"BR\\\"==i.previousSibling.tagName||(i.style.display=\\\"inline\\\",k.style.display=\\\"inline\\\",l=a(b.doc.createTextNode(\\\"\\\\u200b\\\"))),w=m(i,j,!0)||a(i).before(l)&&j.setStartBefore(i),x=m(k,j,!1)||a(k).after(l)&&j.setEndAfter(k)),\\\"function\\\"==typeof w&&w(),\\\"function\\\"==typeof x&&x()}}catch(y){}}l&&l.remove();try{g.addRange(j)}catch(y){}}b.markers.remove()}function m(c,d,e){var f,g=c.previousSibling,h=c.nextSibling;return g&&h&&g.nodeType==Node.TEXT_NODE&&h.nodeType==Node.TEXT_NODE?(f=g.textContent.length,e?(h.textContent=g.textContent+h.textContent,a(g).remove(),a(c).remove(),b.spaces.normalize(h),function(){d.setStart(h,f)}):(g.textContent=g.textContent+h.textContent,a(h).remove(),a(c).remove(),b.spaces.normalize(g),function(){d.setEnd(g,f)})):g&&!h&&g.nodeType==Node.TEXT_NODE?(f=g.textContent.length,e?(b.spaces.normalize(g),function(){d.setStart(g,f)}):(b.spaces.normalize(g),function(){d.setEnd(g,f)})):!(!h||g||h.nodeType!=Node.TEXT_NODE)&&(e?(b.spaces.normalize(h),\\nfunction(){d.setStart(h,0)}):(b.spaces.normalize(h),function(){d.setEnd(h,0)}))}function n(){return!0}function o(){for(var a=e(),b=0;b<a.length;b++)if(!a[b].collapsed)return!1;return!0}function p(a){var c,d,e=!1,f=!1;if(b.win.getSelection){var g=b.win.getSelection();g.rangeCount&&(c=g.getRangeAt(0),d=c.cloneRange(),d.selectNodeContents(a),d.setEnd(c.startContainer,c.startOffset),e=\\\"\\\"===d.toString(),d.selectNodeContents(a),d.setStart(c.endContainer,c.endOffset),f=\\\"\\\"===d.toString())}else b.doc.selection&&\\\"Control\\\"!=b.doc.selection.type&&(c=b.doc.selection.createRange(),d=c.duplicate(),d.moveToElementText(a),d.setEndPoint(\\\"EndToStart\\\",c),e=\\\"\\\"===d.text,d.moveToElementText(a),d.setEndPoint(\\\"StartToEnd\\\",c),f=\\\"\\\"===d.text);return{atStart:e,atEnd:f}}function q(){if(o())return!1;b.$el.find(\\\"td, th, img, br:not(:last)\\\").prepend('<span class=\\\"fr-mk\\\">'+a.FE.INVISIBLE_SPACE+\\\"</span>\\\");var c=!1,d=p(b.el);return d.atStart&&d.atEnd&&(c=!0),b.$el.find(\\\".fr-mk\\\").remove(),c}function r(c,d){\\\"undefined\\\"==typeof d&&(d=!0);var e=a(c).html();e&&e.replace(/\\\\u200b/g,\\\"\\\").length!=e.length&&a(c).html(e.replace(/\\\\u200b/g,\\\"\\\"));for(var f=b.node.contents(c),g=0;g<f.length;g++)f[g].nodeType!=Node.ELEMENT_NODE?a(f[g]).remove():(r(f[g],0===g),0===g&&(d=!1));c.nodeType==Node.TEXT_NODE?a(c).replaceWith('<span data-first=\\\"true\\\" data-text=\\\"true\\\"></span>'):d&&a(c).attr(\\\"data-first\\\",!0)}function s(){return 0===a(this).find(\\\"fr-inner\\\").length}function t(c,d){var e=b.node.contents(c.get(0));[\\\"TD\\\",\\\"TH\\\"].indexOf(c.get(0).tagName)>=0&&1==c.find(\\\".fr-marker\\\").length&&b.node.hasClass(e[0],\\\"fr-marker\\\")&&c.attr(\\\"data-del-cell\\\",!0);for(var f=0;f<e.length;f++){var g=e[f];b.node.hasClass(g,\\\"fr-marker\\\")?d=(d+1)%2:d?a(g).find(\\\".fr-marker\\\").length>0?d=t(a(g),d):[\\\"TD\\\",\\\"TH\\\"].indexOf(g.tagName)<0&&!b.node.hasClass(g,\\\"fr-inner\\\")?!b.opts.keepFormatOnDelete||b.$el.find(\\\"[data-first]\\\").length>0?a(g).remove():r(g):b.node.hasClass(g,\\\"fr-inner\\\")?0===a(g).find(\\\".fr-inner\\\").length?a(g).html(\\\"<br>\\\"):a(g).find(\\\".fr-inner\\\").filter(s).html(\\\"<br>\\\"):(a(g).empty(),a(g).attr(\\\"data-del-cell\\\",!0)):a(g).find(\\\".fr-marker\\\").length>0&&(d=t(a(g),d))}return d}function u(){try{if(!b.$wp)return!1;for(var a=e(0),c=a.commonAncestorContainer;c&&!b.node.isElement(c);)c=c.parentNode;return!!b.node.isElement(c)}catch(d){return!1}}function v(){if(o())return!0;var c;k();var d=function(b){for(var c=b.previousSibling;c&&c.nodeType==Node.TEXT_NODE&&0===c.textContent.length;){var d=c;c=c.previousSibling,a(d).remove()}return c},e=function(b){for(var c=b.nextSibling;c&&c.nodeType==Node.TEXT_NODE&&0===c.textContent.length;){var d=c;c=c.nextSibling,a(d).remove()}return c},f=b.$el.find('.fr-marker[data-type=\\\"true\\\"]');for(c=0;c<f.length;c++)for(var g=f[c];!d(g)&&!b.node.isBlock(g.parentNode)&&!b.$el.is(g.parentNode);)a(g.parentNode).before(g);var h=b.$el.find('.fr-marker[data-type=\\\"false\\\"]');for(c=0;c<h.length;c++){for(var i=h[c];!e(i)&&!b.node.isBlock(i.parentNode)&&!b.$el.is(i.parentNode);)a(i.parentNode).after(i);i.parentNode&&b.node.isBlock(i.parentNode)&&b.node.isEmpty(i.parentNode)&&!b.$el.is(i.parentNode)&&b.opts.keepFormatOnDelete&&a(i.parentNode).after(i)}if(n()){t(b.$el,0);var j=b.$el.find('[data-first=\\\"true\\\"]');if(j.length)b.$el.find(\\\".fr-marker\\\").remove(),j.append(a.FE.INVISIBLE_SPACE+a.FE.MARKERS).removeAttr(\\\"data-first\\\"),j.attr(\\\"data-text\\\")&&j.replaceWith(j.html());else for(b.$el.find(\\\"table\\\").filter(function(){var b=a(this).find(\\\"[data-del-cell]\\\").length>0&&a(this).find(\\\"[data-del-cell]\\\").length==a(this).find(\\\"td, th\\\").length;return b}).remove(),b.$el.find(\\\"[data-del-cell]\\\").removeAttr(\\\"data-del-cell\\\"),f=b.$el.find('.fr-marker[data-type=\\\"true\\\"]'),c=0;c<f.length;c++){var m=f[c],p=m.nextSibling,q=b.$el.find('.fr-marker[data-type=\\\"false\\\"][data-id=\\\"'+a(m).data(\\\"id\\\")+'\\\"]').get(0);if(q){if(m&&(!p||p!=q)){var r=b.node.blockParent(m),s=b.node.blockParent(q),u=!1,v=!1;if(r&&[\\\"UL\\\",\\\"OL\\\"].indexOf(r.tagName)>=0&&(r=null,u=!0),s&&[\\\"UL\\\",\\\"OL\\\"].indexOf(s.tagName)>=0&&(s=null,v=!0),a(m).after(q),r!=s)if(null!=r||u)if(null!=s||v||0!==a(r).parentsUntil(b.$el,\\\"table\\\").length)r&&s&&0===a(r).parentsUntil(b.$el,\\\"table\\\").length&&0===a(s).parentsUntil(b.$el,\\\"table\\\").length&&(a(r).append(a(s).html()),a(s).remove());else{for(p=r;!p.nextSibling&&p.parentNode!=b.el;)p=p.parentNode;for(p=p.nextSibling;p&&\\\"BR\\\"!=p.tagName;){var w=p.nextSibling;a(r).append(p),p=w}p&&\\\"BR\\\"==p.tagName&&a(p).remove()}else{var x=b.node.deepestParent(m);x?(a(x).after(a(s).html()),a(s).remove()):0===a(s).parentsUntil(b.$el,\\\"table\\\").length&&(a(m).next().after(a(s).html()),a(s).remove())}}}else q=a(m).clone().attr(\\\"data-type\\\",!1),a(m).after(q)}}b.opts.keepFormatOnDelete||b.html.fillEmptyBlocks(),b.html.cleanEmptyTags(!0),b.clean.lists(),b.spaces.normalize();var y=b.$el.find(\\\".fr-marker:last\\\").get(0),z=b.$el.find(\\\".fr-marker:first\\\").get(0);\\\"undefined\\\"!=typeof y&&\\\"undefined\\\"!=typeof z&&!y.nextSibling&&z.previousSibling&&\\\"BR\\\"==z.previousSibling.tagName&&b.node.isElement(y.parentNode)&&b.node.isElement(z.parentNode)&&b.$el.append(\\\"<br>\\\"),l()}function w(c){if(!c||c.getElementsByClassName(\\\"fr-marker\\\").length>0)return!1;for(var d=c.firstChild;d&&b.node.isBlock(d);)c=d,d=d.firstChild;c.innerHTML=a.FE.MARKERS+c.innerHTML}function x(c){if(!c||c.getElementsByClassName(\\\"fr-marker\\\").length>0)return!1;for(var d=c.lastChild;d&&b.node.isBlock(d);)c=d,d=d.lastChild;c.innerHTML=c.innerHTML+a.FE.MARKERS}function y(c,d){\\\"undefined\\\"==typeof d&&(d=!0);for(var e=c.previousSibling;e&&e.nodeType==Node.TEXT_NODE&&0===e.textContent.length;)e=e.previousSibling;return e?(b.node.isBlock(e)?x(e):\\\"BR\\\"==e.tagName?a(e).before(a.FE.MARKERS):a(e).after(a.FE.MARKERS),!0):!!d&&(b.node.isBlock(c)?w(c):a(c).before(a.FE.MARKERS),!0)}function z(c,d){\\\"undefined\\\"==typeof d&&(d=!0);for(var e=c.nextSibling;e&&e.nodeType==Node.TEXT_NODE&&0===e.textContent.length;)e=e.nextSibling;return e?(b.node.isBlock(e)?w(e):a(e).before(a.FE.MARKERS),!0):!!d&&(b.node.isBlock(c)?x(c):a(c).after(a.FE.MARKERS),!0)}return{text:c,get:d,ranges:e,clear:f,element:g,endElement:h,save:k,restore:l,isCollapsed:o,isFull:q,inEditor:u,remove:v,blocks:j,info:p,setAtEnd:x,setAtStart:w,setBefore:y,setAfter:z,rangeElement:i}},a.extend(a.FE.DEFAULTS,{htmlAllowedTags:[\\\"a\\\",\\\"abbr\\\",\\\"address\\\",\\\"area\\\",\\\"article\\\",\\\"aside\\\",\\\"audio\\\",\\\"b\\\",\\\"base\\\",\\\"bdi\\\",\\\"bdo\\\",\\\"blockquote\\\",\\\"br\\\",\\\"button\\\",\\\"canvas\\\",\\\"caption\\\",\\\"cite\\\",\\\"code\\\",\\\"col\\\",\\\"colgroup\\\",\\\"datalist\\\",\\\"dd\\\",\\\"del\\\",\\\"details\\\",\\\"dfn\\\",\\\"dialog\\\",\\\"div\\\",\\\"dl\\\",\\\"dt\\\",\\\"em\\\",\\\"embed\\\",\\\"fieldset\\\",\\\"figcaption\\\",\\\"figure\\\",\\\"footer\\\",\\\"form\\\",\\\"h1\\\",\\\"h2\\\",\\\"h3\\\",\\\"h4\\\",\\\"h5\\\",\\\"h6\\\",\\\"header\\\",\\\"hgroup\\\",\\\"hr\\\",\\\"i\\\",\\\"iframe\\\",\\\"img\\\",\\\"input\\\",\\\"ins\\\",\\\"kbd\\\",\\\"keygen\\\",\\\"label\\\",\\\"legend\\\",\\\"li\\\",\\\"link\\\",\\\"main\\\",\\\"map\\\",\\\"mark\\\",\\\"menu\\\",\\\"menuitem\\\",\\\"meter\\\",\\\"nav\\\",\\\"noscript\\\",\\\"object\\\",\\\"ol\\\",\\\"optgroup\\\",\\\"option\\\",\\\"output\\\",\\\"p\\\",\\\"param\\\",\\\"pre\\\",\\\"progress\\\",\\\"queue\\\",\\\"rp\\\",\\\"rt\\\",\\\"ruby\\\",\\\"s\\\",\\\"samp\\\",\\\"script\\\",\\\"style\\\",\\\"section\\\",\\\"select\\\",\\\"small\\\",\\\"source\\\",\\\"span\\\",\\\"strike\\\",\\\"strong\\\",\\\"sub\\\",\\\"summary\\\",\\\"sup\\\",\\\"table\\\",\\\"tbody\\\",\\\"td\\\",\\\"textarea\\\",\\\"tfoot\\\",\\\"th\\\",\\\"thead\\\",\\\"time\\\",\\\"tr\\\",\\\"track\\\",\\\"u\\\",\\\"ul\\\",\\\"var\\\",\\\"video\\\",\\\"wbr\\\"],htmlRemoveTags:[\\\"script\\\",\\\"style\\\"],htmlAllowedAttrs:[\\\"accept\\\",\\\"accept-charset\\\",\\\"accesskey\\\",\\\"action\\\",\\\"align\\\",\\\"allowfullscreen\\\",\\\"allowtransparency\\\",\\\"alt\\\",\\\"async\\\",\\\"autocomplete\\\",\\\"autofocus\\\",\\\"autoplay\\\",\\\"autosave\\\",\\\"background\\\",\\\"bgcolor\\\",\\\"border\\\",\\\"charset\\\",\\\"cellpadding\\\",\\\"cellspacing\\\",\\\"checked\\\",\\\"cite\\\",\\\"class\\\",\\\"color\\\",\\\"cols\\\",\\\"colspan\\\",\\\"content\\\",\\\"contenteditable\\\",\\\"contextmenu\\\",\\\"controls\\\",\\\"coords\\\",\\\"data\\\",\\\"data-.*\\\",\\\"datetime\\\",\\\"default\\\",\\\"defer\\\",\\\"dir\\\",\\\"dirname\\\",\\\"disabled\\\",\\\"download\\\",\\\"draggable\\\",\\\"dropzone\\\",\\\"enctype\\\",\\\"for\\\",\\\"form\\\",\\\"formaction\\\",\\\"frameborder\\\",\\\"headers\\\",\\\"height\\\",\\\"hidden\\\",\\\"high\\\",\\\"href\\\",\\\"hreflang\\\",\\\"http-equiv\\\",\\\"icon\\\",\\\"id\\\",\\\"ismap\\\",\\\"itemprop\\\",\\\"keytype\\\",\\\"kind\\\",\\\"label\\\",\\\"lang\\\",\\\"language\\\",\\\"list\\\",\\\"loop\\\",\\\"low\\\",\\\"max\\\",\\\"maxlength\\\",\\\"media\\\",\\\"method\\\",\\\"min\\\",\\\"mozallowfullscreen\\\",\\\"multiple\\\",\\\"name\\\",\\\"novalidate\\\",\\\"open\\\",\\\"optimum\\\",\\\"pattern\\\",\\\"ping\\\",\\\"placeholder\\\",\\\"poster\\\",\\\"preload\\\",\\\"pubdate\\\",\\\"radiogroup\\\",\\\"readonly\\\",\\\"rel\\\",\\\"required\\\",\\\"reversed\\\",\\\"rows\\\",\\\"rowspan\\\",\\\"sandbox\\\",\\\"scope\\\",\\\"scoped\\\",\\\"scrolling\\\",\\\"seamless\\\",\\\"selected\\\",\\\"shape\\\",\\\"size\\\",\\\"sizes\\\",\\\"span\\\",\\\"src\\\",\\\"srcdoc\\\",\\\"srclang\\\",\\\"srcset\\\",\\\"start\\\",\\\"step\\\",\\\"summary\\\",\\\"spellcheck\\\",\\\"style\\\",\\\"tabindex\\\",\\\"target\\\",\\\"title\\\",\\\"type\\\",\\\"translate\\\",\\\"usemap\\\",\\\"value\\\",\\\"valign\\\",\\\"webkitallowfullscreen\\\",\\\"width\\\",\\\"wrap\\\"],htmlAllowedStyleProps:[\\\".*\\\"],htmlAllowComments:!0,htmlUntouched:!1,fullPage:!1}),a.FE.HTML5Map={B:\\\"STRONG\\\",I:\\\"EM\\\",STRIKE:\\\"S\\\"},a.FE.MODULES.clean=function(b){function c(a){if(a.nodeType==Node.ELEMENT_NODE&&a.getAttribute(\\\"class\\\")&&a.getAttribute(\\\"class\\\").indexOf(\\\"fr-marker\\\")>=0)return!1;var d,e=b.node.contents(a),f=[];for(d=0;d<e.length;d++)e[d].nodeType!=Node.ELEMENT_NODE||b.node.isVoid(e[d])?e[d].nodeType==Node.TEXT_NODE&&(e[d].textContent=e[d].textContent.replace(/\\\\u200b/g,\\\"\\\").replace(/&/g,\\\"&amp;\\\")):e[d].textContent.replace(/\\\\u200b/g,\\\"\\\").length!=e[d].textContent.length&&c(e[d]);if(a.nodeType==Node.ELEMENT_NODE&&!b.node.isVoid(a)&&(a.normalize(),e=b.node.contents(a),f=a.querySelectorAll(\\\".fr-marker\\\"),e.length-f.length===0)){for(d=0;d<e.length;d++)if((e[d].getAttribute(\\\"class\\\")||\\\"\\\").indexOf(\\\"fr-marker\\\")<0)return!1;for(d=0;d<f.length;d++)a.parentNode.insertBefore(f[d].cloneNode(!0),a);return a.parentNode.removeChild(a),!1}}function d(a,c){if(a.nodeType==Node.COMMENT_NODE)return\\\"<!--\\\"+a.nodeValue+\\\"-->\\\";if(a.nodeType==Node.TEXT_NODE)return c?a.textContent.replace(/\\\\&/g,\\\"&amp;\\\").replace(/</g,\\\"&lt;\\\").replace(/>/g,\\\"&gt;\\\"):a.textContent.replace(/\\\\&/g,\\\"&amp;\\\").replace(/</g,\\\"&lt;\\\").replace(/>/g,\\\"&gt;\\\").replace(/\\\\u00A0/g,\\\"&nbsp;\\\").replace(/\\\\u0009/g,\\\"\\\");if(a.nodeType!=Node.ELEMENT_NODE)return a.outerHTML;if(a.nodeType==Node.ELEMENT_NODE&&[\\\"STYLE\\\",\\\"SCRIPT\\\",\\\"NOSCRIPT\\\"].indexOf(a.tagName)>=0)return a.outerHTML;if(a.nodeType==Node.ELEMENT_NODE&&\\\"svg\\\"==a.tagName){var e=document.createElement(\\\"div\\\"),f=a.cloneNode(!0);return e.appendChild(f),e.innerHTML}if(\\\"IFRAME\\\"==a.tagName)return a.outerHTML;var g=a.childNodes;if(0===g.length)return a.outerHTML;for(var h=\\\"\\\",i=0;i<g.length;i++)\\\"PRE\\\"==a.tagName&&(c=!0),h+=d(g[i],c);return b.node.openTagString(a)+h+b.node.closeTagString(a)}function e(a){return K=[],a=a.replace(/<script\\\\b[^<]*(?:(?!<\\\\/script>)<[^<]*)*<\\\\/script>/gi,function(a){return K.push(a),\\\"[FROALA.EDITOR.SCRIPT \\\"+(K.length-1)+\\\"]\\\"}),a=a.replace(/<noscript\\\\b[^<]*(?:(?!<\\\\/noscript>)<[^<]*)*<\\\\/noscript>/gi,function(a){return K.push(a),\\\"[FROALA.EDITOR.NOSCRIPT \\\"+(K.length-1)+\\\"]\\\"}),a=a.replace(/<img((?:[\\\\w\\\\W]*?)) src=\\\"/g,'<img$1 data-fr-src=\\\"')}function f(a){return a=a.replace(/\\\\[FROALA\\\\.EDITOR\\\\.SCRIPT ([\\\\d]*)\\\\]/gi,function(a,c){return b.opts.htmlRemoveTags.indexOf(\\\"script\\\")>=0?\\\"\\\":K[parseInt(c,10)]}),a=a.replace(/\\\\[FROALA\\\\.EDITOR\\\\.NOSCRIPT ([\\\\d]*)\\\\]/gi,function(a,c){return b.opts.htmlRemoveTags.indexOf(\\\"noscript\\\")>=0?\\\"\\\":K[parseInt(c,10)].replace(/\\\\&lt;/g,\\\"<\\\").replace(/\\\\&gt;/g,\\\">\\\")}),a=a.replace(/<img((?:[\\\\w\\\\W]*?)) data-fr-src=\\\"/g,'<img$1 src=\\\"')}function g(a){var b=a.replace(/;;/gi,\\\";\\\");return b=b.replace(/^;/gi,\\\"\\\"),\\\";\\\"!=b.charAt(b.length)&&(b+=\\\";\\\"),b}function h(a){var c;for(c in a)if(a.hasOwnProperty(c)){var d=c.match(I),e=null;\\\"style\\\"==c&&b.opts.htmlAllowedStyleProps.length&&(e=a[c].match(J)),d&&e?a[c]=g(e.join(\\\";\\\")):d&&(\\\"style\\\"!=c||e)||delete a[c]}for(var f=\\\"\\\",h=Object.keys(a).sort(),i=0;i<h.length;i++)c=h[i],f+=a[c].indexOf('\\\"')<0?\\\" \\\"+c+'=\\\"'+a[c]+'\\\"':\\\" \\\"+c+\\\"='\\\"+a[c]+\\\"'\\\";return f}function i(a,c,d){if(b.opts.fullPage){var e=b.html.extractDoctype(d),f=h(b.html.extractNodeAttrs(d,\\\"html\\\"));c=null==c?b.html.extractNode(d,\\\"head\\\")||\\\"<title></title>\\\":c;var g=h(b.html.extractNodeAttrs(d,\\\"head\\\")),i=h(b.html.extractNodeAttrs(d,\\\"body\\\"));return e+\\\"<html\\\"+f+\\\"><head\\\"+g+\\\">\\\"+c+\\\"</head><body\\\"+i+\\\">\\\"+a+\\\"</body></html>\\\"}return a}function j(c,e){var f,g=a(\\\"<div>\\\"+c+\\\"</div>\\\"),h=\\\"\\\";if(g){var i=b.node.contents(g.get(0));for(f=0;f<i.length;f++)e(i[f]);for(i=b.node.contents(g.get(0)),f=0;f<i.length;f++)h+=d(i[f])}return h}function k(a,c,d){a=e(a);var g=a,h=null;b.opts.fullPage&&(g=b.html.extractNode(a,\\\"body\\\")||(a.indexOf(\\\"<body\\\")>=0?\\\"\\\":a),d&&(h=b.html.extractNode(a,\\\"head\\\")||\\\"\\\")),g=j(g,c),h&&(h=j(h,c));var k=i(g,h,a);return f(k)}function l(a){return a.replace(/\\\\u200b/g,\\\"\\\").length==a.length?a:b.clean.exec(a,c)}function m(){var c=b.el.querySelectorAll(Object.keys(a.FE.HTML5Map).join(\\\",\\\"));if(c.length){var d=!1;b.el.querySelector(\\\".fr-marker\\\")||(b.selection.save(),d=!0);for(var e=0;e<c.length;e++)\\\"\\\"===b.node.attributes(c[e])&&a(c[e]).replaceWith(\\\"<\\\"+a.FE.HTML5Map[c[e].tagName]+\\\">\\\"+c[e].innerHTML+\\\"</\\\"+a.FE.HTML5Map[c[e].tagName]+\\\">\\\");d&&b.selection.restore()}}function n(c){if(\\\"SPAN\\\"==c.tagName&&(c.getAttribute(\\\"class\\\")||\\\"\\\").indexOf(\\\"fr-marker\\\")>=0)return!1;if(\\\"PRE\\\"==c.tagName&&p(c),c.nodeType==Node.ELEMENT_NODE&&(c.getAttribute(\\\"data-fr-src\\\")&&c.setAttribute(\\\"data-fr-src\\\",b.helpers.sanitizeURL(c.getAttribute(\\\"data-fr-src\\\"))),c.getAttribute(\\\"href\\\")&&c.setAttribute(\\\"href\\\",b.helpers.sanitizeURL(c.getAttribute(\\\"href\\\"))),[\\\"TABLE\\\",\\\"TBODY\\\",\\\"TFOOT\\\",\\\"TR\\\"].indexOf(c.tagName)>=0&&(c.innerHTML=c.innerHTML.trim())),!b.opts.pasteAllowLocalImages&&c.nodeType==Node.ELEMENT_NODE&&\\\"IMG\\\"==c.tagName&&c.getAttribute(\\\"data-fr-src\\\")&&0===c.getAttribute(\\\"data-fr-src\\\").indexOf(\\\"file://\\\"))return c.parentNode.removeChild(c),!1;if(c.nodeType==Node.ELEMENT_NODE&&a.FE.HTML5Map[c.tagName]&&\\\"\\\"===b.node.attributes(c)){var d=a.FE.HTML5Map[c.tagName],e=\\\"<\\\"+d+\\\">\\\"+c.innerHTML+\\\"</\\\"+d+\\\">\\\";c.insertAdjacentHTML(\\\"beforebegin\\\",e),c=c.previousSibling,c.parentNode.removeChild(c.nextSibling)}if(b.opts.htmlAllowComments||c.nodeType!=Node.COMMENT_NODE)if(c.tagName&&c.tagName.match(H))c.parentNode.removeChild(c);else if(c.tagName&&!c.tagName.match(G))\\\"svg\\\"===c.tagName?c.parentNode.removeChild(c):b.browser.safari&&\\\"path\\\"==c.tagName&&c.parentNode&&\\\"svg\\\"==c.parentNode.tagName||(c.outerHTML=c.innerHTML);else{var f=c.attributes;if(f)for(var h=f.length-1;h>=0;h--){var i=f[h],j=i.nodeName.match(I),k=null;\\\"style\\\"==i.nodeName&&b.opts.htmlAllowedStyleProps.length&&(k=i.nodeValue.match(J)),j&&k?i.nodeValue=g(k.join(\\\";\\\")):j&&(\\\"style\\\"!=i.nodeName||k)||c.removeAttribute(i.nodeName)}}else 0!==c.data.indexOf(\\\"[FROALA.EDITOR\\\")&&c.parentNode.removeChild(c)}function o(a){for(var c=b.node.contents(a),d=0;d<c.length;d++)c[d].nodeType!=Node.TEXT_NODE&&o(c[d]);n(a)}function p(a){var b=a.innerHTML;b.indexOf(\\\"\\\\n\\\")>=0&&(a.innerHTML=b.replace(/\\\\n/g,\\\"<br>\\\"))}function q(c,d,e,f){\\\"undefined\\\"==typeof d&&(d=[]),\\\"undefined\\\"==typeof e&&(e=[]),\\\"undefined\\\"==typeof f&&(f=!1),c=c.replace(/<br> */g,\\\"<br>\\\");var g,h=a.merge([],b.opts.htmlAllowedTags);for(g=0;g<d.length;g++)h.indexOf(d[g])>=0&&h.splice(h.indexOf(d[g]),1);var i=a.merge([],b.opts.htmlAllowedAttrs);for(g=0;g<e.length;g++)i.indexOf(e[g])>=0&&i.splice(i.indexOf(e[g]),1);return i.push(\\\"data-fr-.*\\\"),i.push(\\\"fr-.*\\\"),G=new RegExp(\\\"^\\\"+h.join(\\\"$|^\\\")+\\\"$\\\",\\\"gi\\\"),I=new RegExp(\\\"^\\\"+i.join(\\\"$|^\\\")+\\\"$\\\",\\\"gi\\\"),H=new RegExp(\\\"^\\\"+b.opts.htmlRemoveTags.join(\\\"$|^\\\")+\\\"$\\\",\\\"gi\\\"),J=b.opts.htmlAllowedStyleProps.length?new RegExp(\\\"((^|;|\\\\\\\\s)\\\"+b.opts.htmlAllowedStyleProps.join(\\\":.+?(?=;|$))|((^|;|\\\\\\\\s)\\\")+\\\":.+?(?=(;|')|$))\\\",\\\"gi\\\"):null,c=k(c,o,!0)}function r(){for(var c=b.el.querySelectorAll(\\\"blockquote + blockquote\\\"),d=0;d<c.length;d++){var e=c[d];b.node.attributes(e)==b.node.attributes(e.previousSibling)&&(a(e).prev().append(a(e).html()),a(e).remove())}}function s(){for(var a=b.el.querySelectorAll(\\\"tr\\\"),c=0;c<a.length;c++){for(var d=a[c].children,e=!0,f=0;f<d.length;f++)if(\\\"TH\\\"!=d[f].tagName){e=!1;break}if(e!==!1&&0!==d.length){for(var g=a[c];g&&\\\"TABLE\\\"!=g.tagName&&\\\"THEAD\\\"!=g.tagName;)g=g.parentNode;var h=g;\\\"THEAD\\\"!=h.tagName&&(h=b.doc.createElement(\\\"THEAD\\\"),g.insertBefore(h,g.firstChild)),h.appendChild(a[c])}}}function t(){var c=b.html.defaultTag();if(c)for(var d=b.el.querySelectorAll(\\\"td > \\\"+c+\\\", th > \\\"+c),e=0;e<d.length;e++)\\\"\\\"===b.node.attributes(d[e])&&a(d[e]).replaceWith(d[e].innerHTML+\\\"<br>\\\")}function u(){s(),t()}function v(){var a=[],c=function(a){return!b.node.isList(a.parentNode)};do{if(a.length){var d=a[0],e=b.doc.createElement(\\\"ul\\\");d.parentNode.insertBefore(e,d);do{var f=d;d=d.nextSibling,e.appendChild(f)}while(d&&\\\"LI\\\"==d.tagName)}a=[];for(var g=b.el.querySelectorAll(\\\"li\\\"),h=0;h<g.length;h++)c(g[h])&&a.push(g[h])}while(a.length>0)}function w(){for(var a=b.el.querySelectorAll(\\\"ol + ol, ul + ul\\\"),c=0;c<a.length;c++){var d=a[c];if(b.node.isList(d.previousSibling)&&b.node.openTagString(d)==b.node.openTagString(d.previousSibling)){for(var e=b.node.contents(d),f=0;f<e.length;f++)d.previousSibling.appendChild(e[f]);d.parentNode.removeChild(d)}}}function x(){var a,c,d=function(a){a.querySelector(\\\"LI\\\")||(c=!0,a.parentNode.removeChild(a))};do{c=!1;var e=b.el.querySelectorAll(\\\"li:empty\\\");for(a=0;a<e.length;a++)e[a].parentNode.removeChild(e[a]);var f=b.el.querySelectorAll(\\\"ul, ol\\\");for(a=0;a<f.length;a++)d(f[a])}while(c===!0)}function y(){for(var c=b.el.querySelectorAll(\\\"ul > ul, ol > ol, ul > ol, ol > ul\\\"),d=0;d<c.length;d++){var e=c[d],f=e.previousSibling;f&&(\\\"LI\\\"==f.tagName?f.appendChild(e):a(e).wrap(\\\"<li></li>\\\"))}}function z(){for(var c=b.el.querySelectorAll(\\\"li > ul, li > ol\\\"),d=0;d<c.length;d++){var e=c[d];if(e.nextSibling){var f=e.nextSibling,g=a(\\\"<li>\\\");a(e.parentNode).after(g);do{var h=f;f=f.nextSibling,g.append(h)}while(f)}}}function A(){for(var c=b.el.querySelectorAll(\\\"li > ul, li > ol\\\"),d=0;d<c.length;d++){var e=c[d];if(b.node.isFirstSibling(e))a(e).before(\\\"<br/>\\\");else if(e.previousSibling&&\\\"BR\\\"==e.previousSibling.tagName){for(var f=e.previousSibling.previousSibling;f&&b.node.hasClass(f,\\\"fr-marker\\\");)f=f.previousSibling;f&&\\\"BR\\\"!=f.tagName&&a(e.previousSibling).remove()}}}function B(){for(var c=b.el.querySelectorAll(\\\"li:empty\\\"),d=0;d<c.length;d++)a(c[d]).remove()}function C(){for(var c=b.el.querySelectorAll(\\\"ul, ol\\\"),d=0;d<c.length;d++)for(var e=b.node.contents(c[d]),f=null,g=e.length-1;g>=0;g--)\\\"LI\\\"!=e[g].tagName?(f||(f=a(\\\"<li>\\\"),f.insertBefore(e[g])),f.prepend(e[g])):f=null}function D(){if(b.html.defaultTag())for(var c=b.el.querySelectorAll(\\\"li > \\\"+b.html.defaultTag()),d=c.length-1;d>=0;d--){var e=c[d];e.previousSibling&&!b.node.isEmpty(e)&&a(\\\"<br>\\\").insertAfter(e.previousSibling),e.outerHTML=e.innerHTML}}function E(){v(),w(),x(),y(),z(),A(),C(),B(),D()}function F(){b.opts.fullPage&&a.merge(b.opts.htmlAllowedTags,[\\\"head\\\",\\\"title\\\",\\\"style\\\",\\\"link\\\",\\\"base\\\",\\\"body\\\",\\\"html\\\",\\\"meta\\\"])}var G,H,I,J,K=[];return{_init:F,html:q,toHTML5:m,tables:u,lists:E,quotes:r,invisibleSpaces:l,exec:k}},a.FE.MODULES.spaces=function(b){function c(c,d){var e=c.previousSibling,f=c.nextSibling,g=c.textContent,h=c.parentNode;if(\\\"PRE\\\"!=h.tagName){d&&(g=g.replace(/[\\\\f\\\\n\\\\r\\\\t\\\\v ]{2,}/g,\\\" \\\"),f&&\\\"BR\\\"!==f.tagName&&!b.node.isBlock(f)||!b.node.isBlock(h)||(g=g.replace(/[\\\\f\\\\n\\\\r\\\\t\\\\v ]{1,}$/g,\\\"\\\")),e&&\\\"BR\\\"!==e.tagName&&!b.node.isBlock(e)||!b.node.isBlock(h)||(g=g.replace(/^[\\\\f\\\\n\\\\r\\\\t\\\\v ]{1,}/g,\\\"\\\")),\\\" \\\"===g&&(e&&e.nodeType!=Node.TEXT_NODE||f&&f.nodeType!=Node.TEXT_NODE)&&(g=\\\"\\\")),g=g.replace(new RegExp(a.FE.UNICODE_NBSP,\\\"g\\\"),\\\" \\\");for(var i=\\\"\\\",j=0;j<g.length;j++)i+=32!=g.charCodeAt(j)||0!==j&&32!=i.charCodeAt(j-1)?g[j]:a.FE.UNICODE_NBSP;(!f||b.node.isBlock(f)||f.nodeType==Node.ELEMENT_NODE&&b.win.getComputedStyle(f)&&\\\"block\\\"==b.win.getComputedStyle(f).display)&&(i=i.replace(/ $/,a.FE.UNICODE_NBSP)),!e||b.node.isVoid(e)||b.node.isBlock(e)||(i=i.replace(/^\\\\u00A0([^ $])/,\\\" $1\\\"),1!==i.length||160!==i.charCodeAt(0)||!f||b.node.isVoid(f)||b.node.isBlock(f)||(i=\\\" \\\")),i=i.replace(/([^ \\\\u00A0])\\\\u00A0([^ \\\\u00A0])/g,\\\"$1 $2\\\"),c.textContent!=i&&(c.textContent=i)}}function d(a,d){if(\\\"undefined\\\"!=typeof a&&a||(a=b.el),\\\"undefined\\\"==typeof d&&(d=!1),b.opts.htmlUntouched)return!1;if(!a.getAttribute||\\\"false\\\"!=a.getAttribute(\\\"contenteditable\\\"))if(a.nodeType==Node.TEXT_NODE)c(a,d);else if(a.nodeType==Node.ELEMENT_NODE)for(var e=b.doc.createTreeWalker(a,NodeFilter.SHOW_TEXT,b.node.filter(function(a){for(var c=a.parentNode;c&&c!==b.el;){if(\\\"PRE\\\"===c.tagName)return!1;c=c.parentNode}return null!=a.textContent.match(/([ \\\\u00A0\\\\f\\\\n\\\\r\\\\t\\\\v]{2,})|(^[ \\\\u00A0\\\\f\\\\n\\\\r\\\\t\\\\v]{1,})|([ \\\\u00A0\\\\f\\\\n\\\\r\\\\t\\\\v]{1,}$)/g)&&!b.node.hasClass(a.parentNode,\\\"fr-marker\\\")}),!1);e.nextNode();)c(e.currentNode,d)}function e(){for(var a=[],c=b.el.querySelectorAll(\\\".fr-marker\\\"),e=0;e<c.length;e++){var f=null,g=b.node.blockParent(c[e]);f=g?g:c[e];for(var h=f.nextSibling,i=f.previousSibling;h&&\\\"BR\\\"==h.tagName;)h=h.nextSibling;for(;i&&\\\"BR\\\"==i.tagName;)i=i.previousSibling;f&&a.indexOf(f)<0&&a.push(f),i&&a.indexOf(i)<0&&a.push(i),h&&a.indexOf(h)<0&&a.push(h)}for(var j=0;j<a.length;j++)d(a[j])}return{normalize:d,normalizeAroundCursor:e}},a.FE.UNICODE_NBSP=String.fromCharCode(160),a.FE.VOID_ELEMENTS=[\\\"area\\\",\\\"base\\\",\\\"br\\\",\\\"col\\\",\\\"embed\\\",\\\"hr\\\",\\\"img\\\",\\\"input\\\",\\\"keygen\\\",\\\"link\\\",\\\"menuitem\\\",\\\"meta\\\",\\\"param\\\",\\\"source\\\",\\\"track\\\",\\\"wbr\\\"],a.FE.BLOCK_TAGS=[\\\"address\\\",\\\"article\\\",\\\"aside\\\",\\\"audio\\\",\\\"blockquote\\\",\\\"canvas\\\",\\\"dd\\\",\\\"div\\\",\\\"dl\\\",\\\"dt\\\",\\\"fieldset\\\",\\\"figcaption\\\",\\\"figure\\\",\\\"footer\\\",\\\"form\\\",\\\"h1\\\",\\\"h2\\\",\\\"h3\\\",\\\"h4\\\",\\\"h5\\\",\\\"h6\\\",\\\"header\\\",\\\"hgroup\\\",\\\"hr\\\",\\\"li\\\",\\\"main\\\",\\\"nav\\\",\\\"noscript\\\",\\\"ol\\\",\\\"output\\\",\\\"p\\\",\\\"pre\\\",\\\"section\\\",\\\"table\\\",\\\"tbody\\\",\\\"td\\\",\\\"tfoot\\\",\\\"th\\\",\\\"thead\\\",\\\"tr\\\",\\\"ul\\\",\\\"video\\\"],a.extend(a.FE.DEFAULTS,{htmlAllowedEmptyTags:[\\\"textarea\\\",\\\"a\\\",\\\"iframe\\\",\\\"object\\\",\\\"video\\\",\\\"style\\\",\\\"script\\\",\\\".fa\\\",\\\".fr-emoticon\\\"],htmlDoNotWrapTags:[\\\"script\\\",\\\"style\\\"],htmlSimpleAmpersand:!1,htmlIgnoreCSSProperties:[]}),a.FE.MODULES.html=function(b){function c(){return b.opts.enter==a.FE.ENTER_P?\\\"p\\\":b.opts.enter==a.FE.ENTER_DIV?\\\"div\\\":b.opts.enter==a.FE.ENTER_BR?null:void 0}function d(c){var d,e=[],g=[];if(c){var h=b.el.querySelectorAll(\\\".fr-marker\\\");for(d=0;d<h.length;d++){var i=b.node.blockParent(h[d])||h[d];if(i){var j=i.nextSibling,k=i.previousSibling;i&&g.indexOf(i)<0&&b.node.isBlock(i)&&g.push(i),k&&b.node.isBlock(k)&&g.indexOf(k)<0&&g.push(k),j&&b.node.isBlock(j)&&g.indexOf(j)<0&&g.push(j)}}}else g=b.el.querySelectorAll(f());var l=f();for(l+=\\\",\\\"+a.FE.VOID_ELEMENTS.join(\\\",\\\"),l+=\\\",\\\"+b.opts.htmlAllowedEmptyTags.join(\\\":not(.fr-marker),\\\")+\\\":not(.fr-marker)\\\",d=g.length-1;d>=0;d--)if(!(g[d].textContent&&g[d].textContent.replace(/\\\\u200B|\\\\n/g,\\\"\\\").length>0||g[d].querySelectorAll(l).length>0)){for(var m=b.node.contents(g[d]),n=!1,o=0;o<m.length;o++)if(m[o].nodeType!=Node.COMMENT_NODE&&m[o].textContent&&m[o].textContent.replace(/\\\\u200B|\\\\n/g,\\\"\\\").length>0){n=!0;break}n||e.push(g[d])}return e}function e(){return a.FE.BLOCK_TAGS.join(\\\":empty, \\\")+\\\":empty\\\"}function f(){return a.FE.BLOCK_TAGS.join(\\\", \\\")}function g(c){var d=a.merge([],a.FE.VOID_ELEMENTS);d=a.merge(d,b.opts.htmlAllowedEmptyTags),\\\"undefined\\\"==typeof c&&(d=a.merge(d,a.FE.BLOCK_TAGS));var e,f;e=b.el.querySelectorAll(\\\"*:empty:not(\\\"+d.join(\\\"):not(\\\")+\\\"):not(.fr-marker)\\\");do{f=!1;for(var g=0;g<e.length;g++)0!==e[g].attributes.length&&\\\"undefined\\\"==typeof e[g].getAttribute(\\\"href\\\")||(e[g].parentNode.removeChild(e[g]),f=!0);e=b.el.querySelectorAll(\\\"*:empty:not(\\\"+d.join(\\\"):not(\\\")+\\\"):not(.fr-marker)\\\")}while(e.length&&f)}function h(a,d){var e=c();if(d&&(e=\\\"div\\\"),e){for(var f=b.doc.createDocumentFragment(),g=null,h=!1,i=a.firstChild;i;){var j=i.nextSibling;if(i.nodeType==Node.ELEMENT_NODE&&(b.node.isBlock(i)||b.opts.htmlDoNotWrapTags.indexOf(i.tagName.toLowerCase())>=0&&!b.node.hasClass(i,\\\"fr-marker\\\")))g=null,f.appendChild(i);else if(i.nodeType!=Node.ELEMENT_NODE&&i.nodeType!=Node.TEXT_NODE)g=null,f.appendChild(i);else if(\\\"BR\\\"==i.tagName)null==g?(g=b.doc.createElement(e),d&&g.setAttribute(\\\"data-empty\\\",!0),g.appendChild(i),f.appendChild(g)):h===!1&&(g.appendChild(b.doc.createElement(\\\"br\\\")),g.setAttribute(\\\"data-empty\\\",!0)),g=null;else{var k=i.textContent;i.nodeType==Node.TEXT_NODE&&0===k.replace(/\\\\n/g,\\\"\\\").replace(/(^ *)|( *$)/g,\\\"\\\").length||(null==g&&(g=b.doc.createElement(e),d&&g.setAttribute(\\\"class\\\",\\\"fr-temp-div\\\"),f.appendChild(g),h=!1),g.appendChild(i),h||b.node.hasClass(i,\\\"fr-marker\\\")||i.nodeType==Node.TEXT_NODE&&0===k.replace(/ /g,\\\"\\\").length||(h=!0))}i=j}a.innerHTML=\\\"\\\",a.appendChild(f)}}function i(a,b){for(var c=0;c<a.length;c++)h(a[c],b)}function j(a,c,d,e){return!!b.$wp&&(\\\"undefined\\\"==typeof a&&(a=!1),\\\"undefined\\\"==typeof c&&(c=!1),\\\"undefined\\\"==typeof d&&(d=!1),\\\"undefined\\\"==typeof e&&(e=!1),h(b.el,a),e&&i(b.el.querySelectorAll(\\\".fr-inner\\\"),a),c&&i(b.el.querySelectorAll(\\\"td, th\\\"),a),void(d&&i(b.el.querySelectorAll(\\\"blockquote\\\"),a)))}function k(){b.$el.find(\\\"div.fr-temp-div\\\").each(function(){a(this).data(\\\"empty\\\")||\\\"LI\\\"==this.parentNode.tagName||b.node.isBlock(this.nextSibling)&&!a(this.nextSibling).hasClass(\\\"fr-temp-div\\\")?a(this).replaceWith(a(this).html()):a(this).replaceWith(a(this).html()+\\\"<br>\\\")}),b.$el.find(\\\".fr-temp-div\\\").removeClass(\\\"fr-temp-div\\\").filter(function(){return\\\"\\\"===a(this).attr(\\\"class\\\")}).removeAttr(\\\"class\\\")}function l(c){for(var e=d(c),f=0;f<e.length;f++){var g=e[f];\\\"false\\\"===g.getAttribute(\\\"contenteditable\\\")||g.querySelector(b.opts.htmlAllowedEmptyTags.join(\\\":not(.fr-marker),\\\")+\\\":not(.fr-marker)\\\")||b.node.isVoid(g)||\\\"TABLE\\\"!=g.tagName&&\\\"TBODY\\\"!=g.tagName&&\\\"TR\\\"!=g.tagName&&g.appendChild(b.doc.createElement(\\\"br\\\"))}if(b.browser.msie&&b.opts.enter==a.FE.ENTER_BR){var h=b.node.contents(b.el);h.length&&h[h.length-1].nodeType==Node.TEXT_NODE&&b.$el.append(\\\"<br>\\\")}}function m(){return b.$el.get(0).querySelectorAll(f())}function n(a){if(\\\"undefined\\\"==typeof a&&(a=b.el),a&&[\\\"SCRIPT\\\",\\\"STYLE\\\",\\\"PRE\\\"].indexOf(a.tagName)>=0)return!1;for(var c=b.doc.createTreeWalker(a,NodeFilter.SHOW_TEXT,b.node.filter(function(a){return null!=a.textContent.match(/([ \\\\n]{2,})|(^[ \\\\n]{1,})|([ \\\\n]{1,}$)/g)}),!1);c.nextNode();){var d=c.currentNode;if(\\\"PRE\\\"!=d.parentNode.tagName){var e=b.node.isBlock(d.parentNode)||b.node.isElement(d.parentNode),f=d.textContent.replace(/(?!^)( ){2,}(?!$)/g,\\\" \\\").replace(/\\\\n/g,\\\" \\\").replace(/^[ ]{2,}/g,\\\" \\\").replace(/[ ]{2,}$/g,\\\" \\\");if(e){var g=d.previousSibling,h=d.nextSibling;g&&h&&\\\" \\\"==f?f=b.node.isBlock(g)&&b.node.isBlock(h)?\\\"\\\":\\\"\\\\n\\\":(g||(f=f.replace(/^ */,\\\"\\\")),h||(f=f.replace(/ *$/,\\\"\\\")))}d.textContent=f}}}function o(a,b,c){var d=new RegExp(b,\\\"gi\\\"),e=d.exec(a);return e?e[c]:null}function p(a,b){var c=a.match(/<!DOCTYPE ?([^ ]*) ?([^ ]*) ?\\\"?([^\\\"]*)\\\"? ?\\\"?([^\\\"]*)\\\"?>/i);return c?b.implementation.createDocumentType(c[1],c[3],c[4]):b.implementation.createDocumentType(\\\"html\\\")}function q(a){var b=a.doctype,c=\\\"<!DOCTYPE html>\\\";return b&&(c=\\\"<!DOCTYPE \\\"+b.name+(b.publicId?' PUBLIC \\\"'+b.publicId+'\\\"':\\\"\\\")+(!b.publicId&&b.systemId?\\\" SYSTEM\\\":\\\"\\\")+(b.systemId?' \\\"'+b.systemId+'\\\"':\\\"\\\")+\\\">\\\"),c}function r(c,d){var e=c.parentNode;if(e&&(b.node.isBlock(e)||b.node.isElement(e))&&[\\\"TD\\\",\\\"TH\\\"].indexOf(e.tagName)<0){for(var f=c.previousSibling,g=c.nextSibling;f&&f.nodeType==Node.TEXT_NODE&&0===f.textContent.replace(/\\\\n|\\\\r/g,\\\"\\\").length;)f=f.previousSibling;f&&e&&\\\"BR\\\"!=f.tagName&&!b.node.isBlock(f)&&!g&&e.textContent.replace(/\\\\u200B/g,\\\"\\\").length>0&&f.textContent.length>0&&!b.node.hasClass(f,\\\"fr-marker\\\")&&(b.el==e&&!g&&b.opts.enter==a.FE.ENTER_BR&&b.browser.msie||(d&&b.selection.save(),c.parentNode.removeChild(c),d&&b.selection.restore()))}}function s(){var a,c,d=b.selection.element();a=b.node.isBlock(d)?d:b.node.blockParent(d);var e=[];if(a){var f=a.nextSibling,g=a.previousSibling;a&&e.indexOf(a)<0&&e.push(a),g&&b.node.isBlock(g)&&e.indexOf(g)<0&&e.push(g),f&&b.node.isBlock(f)&&e.indexOf(f)<0&&e.push(f)}var h=[];for(c=0;c<e.length;c++)for(var i=e[c].querySelectorAll(\\\"br\\\"),j=0;j<i.length;j++)h.indexOf(i[j])<0&&h.push(i[j]);if(d.parentNode==b.el){var k=b.el.children;for(c=0;c<k.length;c++)\\\"BR\\\"==k[c].tagName&&h.indexOf(k[c])<0&&h.push(k[c])}return h}function t(a,c){var d,e=null;if(a)for(e=s(),d=0;d<e.length;d++)r(e[d],c);else for(e=b.el.getElementsByTagName(\\\"br\\\"),d=0;d<e.length;d++)r(e[d],c)}function u(){b.opts.htmlUntouched||(g(),j()),n(),b.opts.htmlUntouched||(b.spaces.normalize(null,!0),b.html.fillEmptyBlocks(),b.clean.quotes(),b.clean.lists(),b.clean.tables(),b.clean.toHTML5(),b.html.cleanBRs()),b.selection.restore(),v(),b.placeholder.refresh()}function v(){b.core.isEmpty()&&(null!=c()?b.el.querySelector(f())||b.el.querySelector(b.opts.htmlDoNotWrapTags.join(\\\":not(.fr-marker),\\\")+\\\":not(.fr-marker)\\\")||(b.core.hasFocus()?(b.$el.html(\\\"<\\\"+c()+\\\">\\\"+a.FE.MARKERS+\\\"<br/></\\\"+c()+\\\">\\\"),b.selection.restore()):b.$el.html(\\\"<\\\"+c()+\\\"><br/></\\\"+c()+\\\">\\\")):b.el.querySelector(\\\"*:not(.fr-marker):not(br)\\\")||(b.core.hasFocus()?(b.$el.html(a.FE.MARKERS+\\\"<br/>\\\"),b.selection.restore()):b.$el.html(\\\"<br/>\\\")))}function w(a,b){return o(a,\\\"<\\\"+b+\\\"[^>]*?>([\\\\\\\\w\\\\\\\\W]*)</\\\"+b+\\\">\\\",1)}function x(c,d){var e=a(\\\"<div \\\"+(o(c,\\\"<\\\"+d+\\\"([^>]*?)>\\\",1)||\\\"\\\")+\\\">\\\");return b.node.rawAttributes(e.get(0))}function y(a){return o(a,\\\"<!DOCTYPE([^>]*?)>\\\",0)||\\\"<!DOCTYPE html>\\\"}function z(c){var d=b.clean.html(c||\\\"\\\",[],[],b.opts.fullPage);if(b.opts.fullPage){var e=w(d,\\\"body\\\")||(d.indexOf(\\\"<body\\\")>=0?\\\"\\\":d),f=x(d,\\\"body\\\"),g=w(d,\\\"head\\\")||\\\"<title></title>\\\",h=x(d,\\\"head\\\"),i=a(\\\"<div>\\\").append(g).contents().each(function(){(this.nodeType==Node.COMMENT_NODE||[\\\"BASE\\\",\\\"LINK\\\",\\\"META\\\",\\\"NOSCRIPT\\\",\\\"SCRIPT\\\",\\\"STYLE\\\",\\\"TEMPLATE\\\",\\\"TITLE\\\"].indexOf(this.tagName)>=0)&&this.parentNode.removeChild(this)}).end().html().trim();g=a(\\\"<div>\\\").append(g).contents().map(function(){return this.nodeType==Node.COMMENT_NODE?\\\"<!--\\\"+this.nodeValue+\\\"-->\\\":[\\\"BASE\\\",\\\"LINK\\\",\\\"META\\\",\\\"NOSCRIPT\\\",\\\"SCRIPT\\\",\\\"STYLE\\\",\\\"TEMPLATE\\\",\\\"TITLE\\\"].indexOf(this.tagName)>=0?this.outerHTML:\\\"\\\"}).toArray().join(\\\"\\\");var j=y(d),k=x(d,\\\"html\\\");b.$el.html(i+\\\"\\\\n\\\"+e),b.node.clearAttributes(b.el),b.$el.attr(f),b.$el.addClass(\\\"fr-view\\\"),b.$el.attr(\\\"spellcheck\\\",b.opts.spellcheck),b.$el.attr(\\\"dir\\\",b.opts.direction),b.$head.html(g),b.node.clearAttributes(b.$head.get(0)),b.$head.attr(h),b.node.clearAttributes(b.$html.get(0)),b.$html.attr(k),b.iframe_document.doctype.parentNode.replaceChild(p(j,b.iframe_document),b.iframe_document.doctype)}else b.$el.html(d);var l=b.edit.isDisabled();b.edit.on(),b.core.injectStyle(b.opts.iframeStyle),u(),b.opts.useClasses||(b.$el.find(\\\"[fr-original-class]\\\").each(function(){this.setAttribute(\\\"class\\\",this.getAttribute(\\\"fr-original-class\\\")),this.removeAttribute(\\\"fr-original-class\\\")}),b.$el.find(\\\"[fr-original-style]\\\").each(function(){this.setAttribute(\\\"style\\\",this.getAttribute(\\\"fr-original-style\\\")),this.removeAttribute(\\\"fr-original-style\\\")})),l&&b.edit.off(),b.events.trigger(\\\"html.set\\\")}function A(a){var b=/(#[^\\\\s\\\\+>~\\\\.\\\\[:]+)/g,c=/(\\\\[[^\\\\]]+\\\\])/g,d=/(\\\\.[^\\\\s\\\\+>~\\\\.\\\\[:]+)/g,e=/(::[^\\\\s\\\\+>~\\\\.\\\\[:]+|:first-line|:first-letter|:before|:after)/gi,f=/(:[\\\\w-]+\\\\([^\\\\)]*\\\\))/gi,g=/(:[^\\\\s\\\\+>~\\\\.\\\\[:]+)/g,h=/([^\\\\s\\\\+>~\\\\.\\\\[:]+)/g;!function(){var b=/:not\\\\(([^\\\\)]*)\\\\)/g;b.test(a)&&(a=a.replace(b,\\\"     $1 \\\"))}();var i=100*(a.match(b)||[]).length+10*(a.match(c)||[]).length+10*(a.match(d)||[]).length+10*(a.match(f)||[]).length+10*(a.match(g)||[]).length+(a.match(e)||[]).length;return a=a.replace(/[\\\\*\\\\s\\\\+>~]/g,\\\" \\\"),a=a.replace(/[#\\\\.]/g,\\\" \\\"),i+=(a.match(h)||[]).length}function B(a){if(b.events.trigger(\\\"html.processGet\\\",[a]),a&&a.getAttribute&&\\\"\\\"===a.getAttribute(\\\"class\\\")&&a.removeAttribute(\\\"class\\\"),a&&a.nodeType==Node.ELEMENT_NODE)for(var c=a.querySelectorAll('[class=\\\"\\\"]'),d=0;d<c.length;d++)c[d].removeAttribute(\\\"class\\\")}function C(a,b){return a[3]-b[3]}function D(a,c){if(!b.$wp)return b.$oel.clone().removeClass(\\\"fr-view\\\").removeAttr(\\\"contenteditable\\\").get(0).outerHTML;var d=\\\"\\\";b.events.trigger(\\\"html.beforeGet\\\");var e,f,g=[],h={},i=[];if(!b.opts.useClasses&&!c){var j=new RegExp(\\\"^\\\"+b.opts.htmlIgnoreCSSProperties.join(\\\"$|^\\\")+\\\"$\\\",\\\"gi\\\");for(e=0;e<b.doc.styleSheets.length;e++){var k,l=0;try{k=b.doc.styleSheets[e].cssRules,b.doc.styleSheets[e].ownerNode&&\\\"STYLE\\\"==b.doc.styleSheets[e].ownerNode.nodeType&&(l=1)}catch(m){}if(k)for(var n=0,o=k.length;n<o;n++)if(k[n].selectorText&&k[n].style.cssText.length>0){var p,r=k[n].selectorText.replace(/body |\\\\.fr-view /g,\\\"\\\").replace(/::/g,\\\":\\\");try{p=b.el.querySelectorAll(r)}catch(m){p=[]}for(f=0;f<p.length;f++){!p[f].getAttribute(\\\"fr-original-style\\\")&&p[f].getAttribute(\\\"style\\\")?(p[f].setAttribute(\\\"fr-original-style\\\",p[f].getAttribute(\\\"style\\\")),g.push(p[f])):p[f].getAttribute(\\\"fr-original-style\\\")||g.push(p[f]),h[p[f]]||(h[p[f]]={});for(var s=1e3*l+A(k[n].selectorText),t=k[n].style.cssText.split(\\\";\\\"),u=0;u<t.length;u++){var v=t[u].trim().split(\\\":\\\")[0];v.match(j)||(h[p[f]][v]||(h[p[f]][v]=0,(p[f].getAttribute(\\\"fr-original-style\\\")||\\\"\\\").indexOf(v+\\\":\\\")>=0&&(h[p[f]][v]=1e4)),s>=h[p[f]][v]&&(h[p[f]][v]=s,t[u].trim().length&&i.push([p[f],v.trim(),t[u].trim().split(\\\":\\\")[1].trim(),s])))}}}}for(i.sort(C),e=0;e<i.length;e++){var w=i[e];w[0].style[w[1]]=w[2]}for(e=0;e<g.length;e++)if(g[e].getAttribute(\\\"class\\\")&&(g[e].setAttribute(\\\"fr-original-class\\\",g[e].getAttribute(\\\"class\\\")),\\ng[e].removeAttribute(\\\"class\\\")),(g[e].getAttribute(\\\"fr-original-style\\\")||\\\"\\\").trim().length>0){var x=g[e].getAttribute(\\\"fr-original-style\\\").split(\\\";\\\");for(f=0;f<x.length;f++)x[f].indexOf(\\\":\\\")>0&&(g[e].style[x[f].split(\\\":\\\")[0].trim()]=x[f].split(\\\":\\\")[1].trim())}}if(b.core.isEmpty()?b.opts.fullPage&&(d=q(b.iframe_document),d+=\\\"<html\\\"+b.node.attributes(b.$html.get(0))+\\\">\\\"+b.$html.find(\\\"head\\\").get(0).outerHTML+\\\"<body></body></html>\\\"):(\\\"undefined\\\"==typeof a&&(a=!1),b.opts.fullPage?(d=q(b.iframe_document),b.$el.removeClass(\\\"fr-view\\\"),d+=\\\"<html\\\"+b.node.attributes(b.$html.get(0))+\\\">\\\"+b.$html.html()+\\\"</html>\\\",b.$el.addClass(\\\"fr-view\\\")):d=b.$el.html()),!b.opts.useClasses&&!c)for(e=0;e<g.length;e++)g[e].getAttribute(\\\"fr-original-class\\\")&&(g[e].setAttribute(\\\"class\\\",g[e].getAttribute(\\\"fr-original-class\\\")),g[e].removeAttribute(\\\"fr-original-class\\\")),g[e].getAttribute(\\\"fr-original-style\\\")?(g[e].setAttribute(\\\"style\\\",g[e].getAttribute(\\\"fr-original-style\\\")),g[e].removeAttribute(\\\"fr-original-style\\\")):g[e].removeAttribute(\\\"style\\\");b.opts.fullPage&&(d=d.replace(/<style data-fr-style=\\\"true\\\">(?:[\\\\w\\\\W]*?)<\\\\/style>/g,\\\"\\\"),d=d.replace(/<link([^>]*)data-fr-style=\\\"true\\\"([^>]*)>/g,\\\"\\\"),d=d.replace(/<style(?:[\\\\w\\\\W]*?)class=\\\"firebugResetStyles\\\"(?:[\\\\w\\\\W]*?)>(?:[\\\\w\\\\W]*?)<\\\\/style>/g,\\\"\\\"),d=d.replace(/<body((?:[\\\\w\\\\W]*?)) spellcheck=\\\"true\\\"((?:[\\\\w\\\\W]*?))>((?:[\\\\w\\\\W]*?))<\\\\/body>/g,\\\"<body$1$2>$3</body>\\\"),d=d.replace(/<body((?:[\\\\w\\\\W]*?)) contenteditable=\\\"(true|false)\\\"((?:[\\\\w\\\\W]*?))>((?:[\\\\w\\\\W]*?))<\\\\/body>/g,\\\"<body$1$3>$4</body>\\\"),d=d.replace(/<body((?:[\\\\w\\\\W]*?)) dir=\\\"([\\\\w]*)\\\"((?:[\\\\w\\\\W]*?))>((?:[\\\\w\\\\W]*?))<\\\\/body>/g,\\\"<body$1$3>$4</body>\\\"),d=d.replace(/<body((?:[\\\\w\\\\W]*?))class=\\\"([\\\\w\\\\W]*?)(fr-rtl|fr-ltr)([\\\\w\\\\W]*?)\\\"((?:[\\\\w\\\\W]*?))>((?:[\\\\w\\\\W]*?))<\\\\/body>/g,'<body$1class=\\\"$2$4\\\"$5>$6</body>'),d=d.replace(/<body((?:[\\\\w\\\\W]*?)) class=\\\"\\\"((?:[\\\\w\\\\W]*?))>((?:[\\\\w\\\\W]*?))<\\\\/body>/g,\\\"<body$1$2>$3</body>\\\")),b.opts.htmlSimpleAmpersand&&(d=d.replace(/\\\\&amp;/gi,\\\"&\\\")),b.events.trigger(\\\"html.afterGet\\\"),a||(d=d.replace(/<span[^>]*? class\\\\s*=\\\\s*[\\\"']?fr-marker[\\\"']?[^>]+>\\\\u200b<\\\\/span>/gi,\\\"\\\")),d=b.clean.invisibleSpaces(d),d=b.clean.exec(d,B);var y=b.events.chainTrigger(\\\"html.get\\\",d);return\\\"string\\\"==typeof y&&(d=y),d=d.replace(/<pre(?:[\\\\w\\\\W]*?)>(?:[\\\\w\\\\W]*?)<\\\\/pre>/g,function(a){return a.replace(/<br>/g,\\\"\\\\n\\\")})}function E(){var c=function(c,d){for(;d&&(d.nodeType==Node.TEXT_NODE||!b.node.isBlock(d))&&!b.node.isElement(d);)d&&d.nodeType!=Node.TEXT_NODE&&a(c).wrapInner(b.node.openTagString(d)+b.node.closeTagString(d)),d=d.parentNode;d&&c.innerHTML==d.innerHTML&&(c.innerHTML=d.outerHTML)},d=function(){var c,d=null;return b.win.getSelection?(c=b.win.getSelection(),c&&c.rangeCount&&(d=c.getRangeAt(0).commonAncestorContainer,d.nodeType!=Node.ELEMENT_NODE&&(d=d.parentNode))):(c=b.doc.selection)&&\\\"Control\\\"!=c.type&&(d=c.createRange().parentElement()),null!=d&&(a.inArray(b.el,a(d).parents())>=0||d==b.el)?d:null},e=\\\"\\\";if(\\\"undefined\\\"!=typeof b.win.getSelection){b.browser.mozilla&&(b.selection.save(),b.$el.find('.fr-marker[data-type=\\\"false\\\"]').length>1&&(b.$el.find('.fr-marker[data-type=\\\"false\\\"][data-id=\\\"0\\\"]').remove(),b.$el.find('.fr-marker[data-type=\\\"false\\\"]:last').attr(\\\"data-id\\\",\\\"0\\\"),b.$el.find(\\\".fr-marker\\\").not('[data-id=\\\"0\\\"]').remove()),b.selection.restore());for(var f=b.selection.ranges(),g=0;g<f.length;g++){var h=document.createElement(\\\"div\\\");h.appendChild(f[g].cloneContents());var i=h.children;if(i.length){var j=i[i.length-1];(\\\"P\\\"==j.tagName&&b.opts.enter==a.FroalaEditor.ENTER_P||\\\"DIV\\\"==j.tagName&&b.opts.enter==a.FroalaEditor.ENTER_DIV)&&b.node.isEmpty(j)&&h.removeChild(j)}c(h,d()),a(h).find(\\\".fr-element\\\").length>0&&(h=b.el),e+=h.innerHTML}}else\\\"undefined\\\"!=typeof b.doc.selection&&\\\"Text\\\"==b.doc.selection.type&&(e=b.doc.selection.createRange().htmlText);return e}function F(a){var c=b.doc.createElement(\\\"div\\\");return c.innerHTML=a,null!==c.querySelector(f())}function G(a){var c=b.doc.createElement(\\\"div\\\");return c.innerHTML=a,b.selection.setAtEnd(c),c.innerHTML}function H(a){return a.replace(/</gi,\\\"&lt;\\\").replace(/>/gi,\\\"&gt;\\\").replace(/\\\"/gi,\\\"&quot;\\\").replace(/'/gi,\\\"&#39;\\\")}function I(c,d,e){b.selection.isCollapsed()||b.selection.remove();var f;if(f=d?c:b.clean.html(c),f=f.replace(/\\\\r|\\\\n/g,\\\" \\\"),c.indexOf('class=\\\"fr-marker\\\"')<0&&(f=G(f)),b.core.isEmpty()&&!b.opts.keepFormatOnDelete)b.el.innerHTML=f;else{var g=b.markers.insert();if(g){b.node.isLastSibling(g)&&a(g).parent().hasClass(\\\"fr-deletable\\\")&&a(g).insertAfter(a(g).parent());var h,i=b.node.blockParent(g);if((F(f)||e)&&(h=b.node.deepestParent(g)||i&&\\\"LI\\\"==i.tagName)){if(g=b.markers.split(),!g)return!1;g.outerHTML=f}else g.outerHTML=f}else b.el.innerHTML=b.el.innerHTML+f}u(),b.events.trigger(\\\"html.inserted\\\")}function J(c){var d=null;if(\\\"undefined\\\"==typeof c&&(d=b.selection.element()),b.opts.keepFormatOnDelete)return!1;var e=d?(d.textContent.match(/\\\\u200B/g)||[]).length-d.querySelectorAll(\\\".fr-marker\\\").length:0,f=(b.el.textContent.match(/\\\\u200B/g)||[]).length-b.el.querySelectorAll(\\\".fr-marker\\\").length;if(f==e)return!1;var g,h;do{h=!1,g=b.el.querySelectorAll(\\\"*:not(.fr-marker)\\\");for(var i=0;i<g.length;i++){var j=g[i];if(d!=j){var k=j.textContent;0===j.children.length&&1===k.length&&8203==k.charCodeAt(0)&&(a(j).remove(),h=!0)}}}while(h)}function K(){var a=function(){J(),b.placeholder&&setTimeout(b.placeholder.refresh,0)};b.events.on(\\\"mouseup\\\",a),b.events.on(\\\"keydown\\\",a),b.events.on(\\\"contentChanged\\\",v)}return{defaultTag:c,emptyBlocks:d,emptyBlockTagsQuery:e,blockTagsQuery:f,fillEmptyBlocks:l,cleanEmptyTags:g,cleanWhiteTags:J,cleanBlankSpaces:n,blocks:m,getDoctype:q,set:z,get:D,getSelected:E,insert:I,wrap:j,unwrap:k,escapeEntities:H,checkIfEmpty:v,extractNode:w,extractNodeAttrs:x,extractDoctype:y,cleanBRs:t,_init:K}},a.extend(a.FE.DEFAULTS,{height:null,heightMax:null,heightMin:null,width:null}),a.FE.MODULES.size=function(a){function b(){c(),a.opts.height&&a.$el.css(\\\"minHeight\\\",a.opts.height-a.helpers.getPX(a.$el.css(\\\"padding-top\\\"))-a.helpers.getPX(a.$el.css(\\\"padding-bottom\\\"))),a.$iframe.height(a.$el.outerHeight(!0))}function c(){a.opts.heightMin?a.$el.css(\\\"minHeight\\\",a.opts.heightMin):a.$el.css(\\\"minHeight\\\",\\\"\\\"),a.opts.heightMax?(a.$wp.css(\\\"maxHeight\\\",a.opts.heightMax),a.$wp.css(\\\"overflow\\\",\\\"auto\\\")):(a.$wp.css(\\\"maxHeight\\\",\\\"\\\"),a.$wp.css(\\\"overflow\\\",\\\"\\\")),a.opts.height?(a.$wp.height(a.opts.height),a.$wp.css(\\\"overflow\\\",\\\"auto\\\"),a.$el.css(\\\"minHeight\\\",a.opts.height-a.helpers.getPX(a.$el.css(\\\"padding-top\\\"))-a.helpers.getPX(a.$el.css(\\\"padding-bottom\\\")))):(a.$wp.css(\\\"height\\\",\\\"\\\"),a.opts.heightMin||a.$el.css(\\\"minHeight\\\",\\\"\\\"),a.opts.heightMax||a.$wp.css(\\\"overflow\\\",\\\"\\\")),a.opts.width&&a.$box.width(a.opts.width)}function d(){return!!a.$wp&&(c(),void(a.$iframe&&(a.events.on(\\\"keyup keydown\\\",function(){setTimeout(b,0)},!0),a.events.on(\\\"commands.after\\\",b),a.events.on(\\\"html.set\\\",b),a.events.on(\\\"init\\\",b),a.events.on(\\\"initialized\\\",b))))}return{_init:d,syncIframe:b,refresh:c}},a.extend(a.FE.DEFAULTS,{language:null}),a.FE.LANGUAGE={},a.FE.MODULES.language=function(b){function c(a){return e&&e.translation[a]?e.translation[a]:a}function d(){a.FE.LANGUAGE&&(e=a.FE.LANGUAGE[b.opts.language]),e&&e.direction&&(b.opts.direction=e.direction)}var e;return{_init:d,translate:c}},a.extend(a.FE.DEFAULTS,{placeholderText:\\\"Type something\\\"}),a.FE.MODULES.placeholder=function(b){function c(){b.$placeholder||g();var c=0,d=0,e=0,f=0,h=0,i=0,j=b.node.contents(b.el),k=a(b.selection.element()).css(\\\"text-align\\\");if(j.length&&j[0].nodeType==Node.ELEMENT_NODE){var l=a(j[0]);!b.opts.toolbarInline&&b.ready&&(c=b.helpers.getPX(l.css(\\\"margin-top\\\")),f=b.helpers.getPX(l.css(\\\"padding-top\\\")),d=b.helpers.getPX(l.css(\\\"margin-left\\\")),e=b.helpers.getPX(l.css(\\\"margin-right\\\")),h=b.helpers.getPX(l.css(\\\"padding-left\\\")),i=b.helpers.getPX(l.css(\\\"padding-right\\\"))),b.$placeholder.css(\\\"font-size\\\",l.css(\\\"font-size\\\")),b.$placeholder.css(\\\"line-height\\\",l.css(\\\"line-height\\\"))}else b.$placeholder.css(\\\"font-size\\\",b.$el.css(\\\"font-size\\\")),b.$placeholder.css(\\\"line-height\\\",b.$el.css(\\\"line-height\\\"));b.$wp.addClass(\\\"show-placeholder\\\"),b.$placeholder.css({marginTop:Math.max(b.helpers.getPX(b.$el.css(\\\"margin-top\\\")),c),paddingTop:Math.max(b.helpers.getPX(b.$el.css(\\\"padding-top\\\")),f),paddingLeft:Math.max(b.helpers.getPX(b.$el.css(\\\"padding-left\\\")),h),marginLeft:Math.max(b.helpers.getPX(b.$el.css(\\\"margin-left\\\")),d),paddingRight:Math.max(b.helpers.getPX(b.$el.css(\\\"padding-right\\\")),i),marginRight:Math.max(b.helpers.getPX(b.$el.css(\\\"margin-right\\\")),e),textAlign:k}).text(b.language.translate(b.opts.placeholderText||b.$oel.attr(\\\"placeholder\\\")||\\\"\\\")),b.$placeholder.html(b.$placeholder.text().replace(/\\\\n/g,\\\"<br>\\\"))}function d(){b.$wp.removeClass(\\\"show-placeholder\\\")}function e(){return!b.$wp||b.node.hasClass(b.$wp.get(0),\\\"show-placeholder\\\")}function f(){return!!b.$wp&&void(b.core.isEmpty()?c():d())}function g(){b.$placeholder=a('<span class=\\\"fr-placeholder\\\"></span>'),b.$wp.append(b.$placeholder)}function h(){return!!b.$wp&&void b.events.on(\\\"init input keydown keyup contentChanged initialized\\\",f)}return{_init:h,show:c,hide:d,refresh:f,isVisible:e}},a.FE.MODULES.edit=function(a){function b(){if(a.browser.mozilla)try{a.doc.execCommand(\\\"enableObjectResizing\\\",!1,\\\"false\\\"),a.doc.execCommand(\\\"enableInlineTableEditing\\\",!1,\\\"false\\\")}catch(b){}if(a.browser.msie)try{a.doc.body.addEventListener(\\\"mscontrolselect\\\",function(a){return a.preventDefault(),!1})}catch(b){}}function c(){a.$wp?(a.$el.attr(\\\"contenteditable\\\",!0),a.$el.removeClass(\\\"fr-disabled\\\").attr(\\\"aria-disabled\\\",!1),a.$tb&&a.$tb.removeClass(\\\"fr-disabled\\\").attr(\\\"aria-disabled\\\",!1),b()):a.$el.is(\\\"a\\\")&&a.$el.attr(\\\"contenteditable\\\",!0),f=!1}function d(){a.$wp?(a.$el.attr(\\\"contenteditable\\\",!1),a.$el.addClass(\\\"fr-disabled\\\").attr(\\\"aria-disabled\\\",!0),a.$tb&&a.$tb.addClass(\\\"fr-disabled\\\").attr(\\\"aria-disabled\\\",!0)):a.$el.is(\\\"a\\\")&&a.$el.attr(\\\"contenteditable\\\",!1),f=!0}function e(){return f}var f=!1;return{on:c,off:d,disableDesign:b,isDisabled:e}},a.extend(a.FE.DEFAULTS,{editorClass:null,typingTimer:500,iframe:!1,requestWithCORS:!0,requestWithCredentials:!1,requestHeaders:{},useClasses:!0,spellcheck:!0,iframeStyle:'html{margin:0px;height:auto;}body{height:auto;padding:10px;background:transparent;color:#000000;position:relative;z-index: 2;-webkit-user-select:auto;margin:0px;overflow:hidden;min-height:20px;}body:after{content:\\\"\\\";display:block;clear:both;}',iframeStyleFiles:[],direction:\\\"auto\\\",zIndex:1,disableRightClick:!1,scrollableContainer:\\\"body\\\",keepFormatOnDelete:!1,theme:null}),a.FE.MODULES.core=function(b){function c(c){if(b.opts.iframe){b.$head.find(\\\"style[data-fr-style], link[data-fr-style]\\\").remove(),b.$head.append('<style data-fr-style=\\\"true\\\">'+c+\\\"</style>\\\");for(var d=0;d<b.opts.iframeStyleFiles.length;d++){var e=a('<link data-fr-style=\\\"true\\\" rel=\\\"stylesheet\\\" href=\\\"'+b.opts.iframeStyleFiles[d]+'\\\">');e.get(0).addEventListener(\\\"load\\\",b.size.syncIframe),b.$head.append(e)}}}function d(){b.opts.iframe||b.$el.addClass(\\\"fr-element fr-view\\\")}function e(){if(b.$box.addClass(\\\"fr-box\\\"+(b.opts.editorClass?\\\" \\\"+b.opts.editorClass:\\\"\\\")),b.$wp.addClass(\\\"fr-wrapper\\\"),d(),b.opts.iframe){b.$iframe.addClass(\\\"fr-iframe\\\"),b.$el.addClass(\\\"fr-view\\\");for(var a=0;a<b.o_doc.styleSheets.length;a++){var c;try{c=b.o_doc.styleSheets[a].cssRules}catch(e){}if(c)for(var f=0,g=c.length;f<g;f++)!c[f].selectorText||0!==c[f].selectorText.indexOf(\\\".fr-view\\\")&&0!==c[f].selectorText.indexOf(\\\".fr-element\\\")||c[f].style.cssText.length>0&&(0===c[f].selectorText.indexOf(\\\".fr-view\\\")?b.opts.iframeStyle+=c[f].selectorText.replace(/\\\\.fr-view/g,\\\"body\\\")+\\\"{\\\"+c[f].style.cssText+\\\"}\\\":b.opts.iframeStyle+=c[f].selectorText.replace(/\\\\.fr-element/g,\\\"body\\\")+\\\"{\\\"+c[f].style.cssText+\\\"}\\\")}}\\\"auto\\\"!=b.opts.direction&&b.$box.removeClass(\\\"fr-ltr fr-rtl\\\").addClass(\\\"fr-\\\"+b.opts.direction),b.$el.attr(\\\"dir\\\",b.opts.direction),b.$wp.attr(\\\"dir\\\",b.opts.direction),b.opts.zIndex>1&&b.$box.css(\\\"z-index\\\",b.opts.zIndex),b.opts.theme&&b.$box.addClass(b.opts.theme+\\\"-theme\\\")}function f(){return b.node.isEmpty(b.el)}function g(){b.drag_support={filereader:\\\"undefined\\\"!=typeof FileReader,formdata:!!b.win.FormData,progress:\\\"upload\\\"in new XMLHttpRequest}}function h(a,c){var d=new XMLHttpRequest;d.open(c,a,!0),b.opts.requestWithCredentials&&(d.withCredentials=!0);for(var e in b.opts.requestHeaders)b.opts.requestHeaders.hasOwnProperty(e)&&d.setRequestHeader(e,b.opts.requestHeaders[e]);return d}function i(a){\\\"TEXTAREA\\\"==b.$oel.get(0).tagName&&b.$oel.val(a),b.$wp&&(\\\"TEXTAREA\\\"==b.$oel.get(0).tagName?(b.$el.html(\\\"\\\"),b.$wp.html(\\\"\\\"),b.$box.replaceWith(b.$oel),b.$oel.show()):(b.$wp.replaceWith(a),b.$el.html(\\\"\\\"),b.$box.removeClass(\\\"fr-view fr-ltr fr-box \\\"+(b.opts.editorClass||\\\"\\\")),b.opts.theme&&b.$box.addClass(b.opts.theme+\\\"-theme\\\"))),this.$wp=null,this.$el=null,this.el=null,this.$box=null}function j(){return b.browser.mozilla&&b.helpers.isMobile()?b.selection.inEditor():b.node.hasFocus(b.el)||b.$el.find(\\\"*:focus\\\").length>0}function k(a){if(!a)return!1;var c=a.data(\\\"instance\\\");return!!c&&c.id==b.id}function l(){if(a.FE.INSTANCES.push(b),g(),b.$wp){e(),b.html.set(b._original_html),b.$el.attr(\\\"spellcheck\\\",b.opts.spellcheck),b.helpers.isMobile()&&(b.$el.attr(\\\"autocomplete\\\",b.opts.spellcheck?\\\"on\\\":\\\"off\\\"),b.$el.attr(\\\"autocorrect\\\",b.opts.spellcheck?\\\"on\\\":\\\"off\\\"),b.$el.attr(\\\"autocapitalize\\\",b.opts.spellcheck?\\\"on\\\":\\\"off\\\")),b.opts.disableRightClick&&b.events.$on(b.$el,\\\"contextmenu\\\",function(a){if(2==a.button)return!1});try{b.doc.execCommand(\\\"styleWithCSS\\\",!1,!1)}catch(c){}}\\\"TEXTAREA\\\"==b.$oel.get(0).tagName&&(b.events.on(\\\"contentChanged\\\",function(){b.$oel.val(b.html.get())}),b.events.on(\\\"form.submit\\\",function(){b.$oel.val(b.html.get())}),b.events.on(\\\"form.reset\\\",function(){b.html.set(b._original_html)}),b.$oel.val(b.html.get())),b.helpers.isIOS()&&b.events.$on(b.$doc,\\\"selectionchange\\\",function(){b.$doc.get(0).hasFocus()||b.$win.get(0).focus()}),b.events.trigger(\\\"init\\\")}return{_init:l,destroy:i,isEmpty:f,getXHR:h,injectStyle:c,hasFocus:j,sameInstance:k}},a.FE.MODULES.cursorLists=function(b){function c(a){for(var b=a;\\\"LI\\\"!=b.tagName;)b=b.parentNode;return b}function d(a){for(var c=a;!b.node.isList(c);)c=c.parentNode;return c}function e(e){var f,g=c(e),h=g.nextSibling,i=g.previousSibling,j=b.html.defaultTag();if(b.node.isEmpty(g,!0)&&h){for(var k=\\\"\\\",l=\\\"\\\",m=e.parentNode;!b.node.isList(m)&&m.parentNode&&\\\"LI\\\"!==m.parentNode.tagName;)k=b.node.openTagString(m)+k,l+=b.node.closeTagString(m),m=m.parentNode;k=b.node.openTagString(m)+k,l+=b.node.closeTagString(m);var n=\\\"\\\";for(n=m.parentNode&&\\\"LI\\\"==m.parentNode.tagName?l+\\\"<li>\\\"+a.FE.MARKERS+\\\"<br>\\\"+k:j?l+\\\"<\\\"+j+\\\">\\\"+a.FE.MARKERS+\\\"<br></\\\"+j+\\\">\\\"+k:l+a.FE.MARKERS+\\\"<br>\\\"+k,a(g).html('<span id=\\\"fr-break\\\"></span>');[\\\"UL\\\",\\\"OL\\\"].indexOf(m.tagName)<0||m.parentNode&&\\\"LI\\\"===m.parentNode.tagName;)m=m.parentNode;var o=b.node.openTagString(m)+a(m).html()+b.node.closeTagString(m);o=o.replace(/<span id=\\\"fr-break\\\"><\\\\/span>/g,n),a(m).replaceWith(o),b.$el.find(\\\"li:empty\\\").remove()}else i&&h||!b.node.isEmpty(g,!0)?(a(g).before(\\\"<li><br></li>\\\"),a(e).remove()):i?(f=d(g),f.parentNode&&\\\"LI\\\"==f.parentNode.tagName?a(f.parentNode).after(\\\"<li>\\\"+a.FE.MARKERS+\\\"<br></li>\\\"):j?a(f).after(\\\"<\\\"+j+\\\">\\\"+a.FE.MARKERS+\\\"<br></\\\"+j+\\\">\\\"):a(f).after(a.FE.MARKERS+\\\"<br>\\\"),a(g).remove()):(f=d(g),f.parentNode&&\\\"LI\\\"==f.parentNode.tagName?h?a(f.parentNode).before(\\\"<li>\\\"+a.FE.MARKERS+\\\"<br></li>\\\"):a(f.parentNode).after(\\\"<li>\\\"+a.FE.MARKERS+\\\"<br></li>\\\"):j?a(f).before(\\\"<\\\"+j+\\\">\\\"+a.FE.MARKERS+\\\"<br></\\\"+j+\\\">\\\"):a(f).before(a.FE.MARKERS+\\\"<br>\\\"),a(g).remove())}function f(d){for(var e=c(d),f=\\\"\\\",g=d,h=\\\"\\\",i=\\\"\\\";g!=e;){g=g.parentNode;var j=\\\"A\\\"==g.tagName&&b.cursor.isAtEnd(d,g)?\\\"fr-to-remove\\\":\\\"\\\";h=b.node.openTagString(a(g).clone().addClass(j).get(0))+h,i=b.node.closeTagString(g)+i}f=i+f+h+a.FE.MARKERS,a(d).replaceWith('<span id=\\\"fr-break\\\"></span>');var k=b.node.openTagString(e)+a(e).html()+b.node.closeTagString(e);k=k.replace(/<span id=\\\"fr-break\\\"><\\\\/span>/g,f),a(e).replaceWith(k)}function g(d){for(var e=c(d),f=a.FE.MARKERS,g=\\\"\\\",h=d,i=!1;h!=e;){h=h.parentNode;var j=\\\"A\\\"==h.tagName&&b.cursor.isAtEnd(d,h)?\\\"fr-to-remove\\\":\\\"\\\";i||h==e||b.node.isBlock(h)||(i=!0,g+=a.FE.INVISIBLE_SPACE),g=b.node.openTagString(a(h).clone().addClass(j).get(0))+g,f+=b.node.closeTagString(h)}var k=g+f;a(d).remove(),a(e).after(k)}function h(e){var f=c(e),g=f.previousSibling;if(g){g=a(g).find(b.html.blockTagsQuery()).get(-1)||g,a(e).replaceWith(a.FE.MARKERS);var h=b.node.contents(g);h.length&&\\\"BR\\\"==h[h.length-1].tagName&&a(h[h.length-1]).remove(),a(f).find(b.html.blockTagsQuery()).not(\\\"ol, ul, table\\\").each(function(){this.parentNode==f&&a(this).replaceWith(a(this).html()+(b.node.isEmpty(this)?\\\"\\\":\\\"<br>\\\"))});for(var i,j=b.node.contents(f)[0];j&&!b.node.isList(j);)i=j.nextSibling,a(g).append(j),j=i;for(g=f.previousSibling;j;)i=j.nextSibling,a(g).append(j),j=i;a(f).remove()}else{var k=d(f);if(a(e).replaceWith(a.FE.MARKERS),k.parentNode&&\\\"LI\\\"==k.parentNode.tagName){var l=k.previousSibling;b.node.isBlock(l)?(a(f).find(b.html.blockTagsQuery()).not(\\\"ol, ul, table\\\").each(function(){this.parentNode==f&&a(this).replaceWith(a(this).html()+(b.node.isEmpty(this)?\\\"\\\":\\\"<br>\\\"))}),a(l).append(a(f).html())):a(k).before(a(f).html())}else{var m=b.html.defaultTag();m&&0===a(f).find(b.html.blockTagsQuery()).length?a(k).before(\\\"<\\\"+m+\\\">\\\"+a(f).html()+\\\"</\\\"+m+\\\">\\\"):(a(k).before(a(f).html()),b.html.wrap())}a(f).remove(),0===a(k).find(\\\"li\\\").length&&a(k).remove()}}function i(d){var e,f=c(d),g=f.nextSibling;if(g){e=b.node.contents(g),e.length&&\\\"BR\\\"==e[0].tagName&&a(e[0]).remove(),a(g).find(b.html.blockTagsQuery()).not(\\\"ol, ul, table\\\").each(function(){this.parentNode==g&&a(this).replaceWith(a(this).html()+(b.node.isEmpty(this)?\\\"\\\":\\\"<br>\\\"))});for(var h,i=d,j=b.node.contents(g)[0];j&&!b.node.isList(j);)h=j.nextSibling,a(i).after(j),i=j,j=h;for(;j;)h=j.nextSibling,a(f).append(j),j=h;a(d).replaceWith(a.FE.MARKERS),a(g).remove()}else{for(var k=f;!k.nextSibling&&k!=b.el;)k=k.parentNode;if(k==b.el)return!1;if(k=k.nextSibling,b.node.isBlock(k))a.FE.NO_DELETE_TAGS.indexOf(k.tagName)<0&&(a(d).replaceWith(a.FE.MARKERS),e=b.node.contents(f),e.length&&\\\"BR\\\"==e[e.length-1].tagName&&a(e[e.length-1]).remove(),a(f).append(a(k).html()),a(k).remove());else for(e=b.node.contents(f),e.length&&\\\"BR\\\"==e[e.length-1].tagName&&a(e[e.length-1]).remove(),a(d).replaceWith(a.FE.MARKERS);k&&!b.node.isBlock(k)&&\\\"BR\\\"!=k.tagName;)a(f).append(a(k)),k=k.nextSibling}}return{_startEnter:e,_middleEnter:f,_endEnter:g,_backspace:h,_del:i}},a.FE.NO_DELETE_TAGS=[\\\"TH\\\",\\\"TD\\\",\\\"TR\\\",\\\"TABLE\\\",\\\"FORM\\\"],a.FE.SIMPLE_ENTER_TAGS=[\\\"TH\\\",\\\"TD\\\",\\\"LI\\\",\\\"DL\\\",\\\"DT\\\",\\\"FORM\\\"],a.FE.MODULES.cursor=function(b){function c(a){return!!a&&(!!b.node.isBlock(a)||(a.nextSibling&&a.nextSibling.nodeType==Node.TEXT_NODE&&0===a.nextSibling.textContent.replace(/\\\\u200b/g,\\\"\\\").length?c(a.nextSibling):!a.nextSibling&&c(a.parentNode)))}function d(a){return!!a&&(!!b.node.isBlock(a)||(a.previousSibling&&a.previousSibling.nodeType==Node.TEXT_NODE&&0===a.previousSibling.textContent.replace(/\\\\u200b/g,\\\"\\\").length?d(a.previousSibling):!a.previousSibling&&d(a.parentNode)))}function e(a,c){return!!a&&(a!=b.$wp.get(0)&&(a.previousSibling&&a.previousSibling.nodeType==Node.TEXT_NODE&&0===a.previousSibling.textContent.replace(/\\\\u200b/g,\\\"\\\").length?e(a.previousSibling,c):!a.previousSibling&&(a.parentNode==c||e(a.parentNode,c))))}function f(a,c){return!!a&&(a!=b.$wp.get(0)&&(a.nextSibling&&a.nextSibling.nodeType==Node.TEXT_NODE&&0===a.nextSibling.textContent.replace(/\\\\u200b/g,\\\"\\\").length?f(a.nextSibling,c):!a.nextSibling&&(a.parentNode==c||f(a.parentNode,c))))}function g(c){return a(c).parentsUntil(b.$el,\\\"LI\\\").length>0&&0===a(c).parentsUntil(\\\"LI\\\",\\\"TABLE\\\").length}function h(c){var d=a(c).parentsUntil(b.$el,\\\"BLOCKQUOTE\\\").length>0,e=b.node.deepestParent(c,[],!d);if(e&&\\\"BLOCKQUOTE\\\"==e.tagName){var f=b.node.deepestParent(c,[a(c).parentsUntil(b.$el,\\\"BLOCKQUOTE\\\").get(0)]);f&&f.previousSibling&&(e=f)}if(null!==e){var g,h=e.previousSibling;if(b.node.isBlock(e)&&b.node.isEditable(e)&&h&&a.FE.NO_DELETE_TAGS.indexOf(h.tagName)<0)if(b.node.isDeletable(h))a(h).remove(),a(c).replaceWith(a.FE.MARKERS);else if(b.node.isEditable(h))if(b.node.isBlock(h))if(b.node.isEmpty(h)&&!b.node.isList(h))a(h).remove();else{if(b.node.isList(h)&&(h=a(h).find(\\\"li:last\\\").get(0)),g=b.node.contents(h),g.length&&\\\"BR\\\"==g[g.length-1].tagName&&a(g[g.length-1]).remove(),\\\"BLOCKQUOTE\\\"==h.tagName&&\\\"BLOCKQUOTE\\\"!=e.tagName)for(g=b.node.contents(h);g.length&&b.node.isBlock(g[g.length-1]);)h=g[g.length-1],g=b.node.contents(h);else if(\\\"BLOCKQUOTE\\\"!=h.tagName&&\\\"BLOCKQUOTE\\\"==e.tagName)for(g=b.node.contents(e);g.length&&b.node.isBlock(g[0]);)e=g[0],g=b.node.contents(e);a(c).replaceWith(a.FE.MARKERS),a(h).append(b.node.isEmpty(e)?a.FE.MARKERS:e.innerHTML),a(e).remove()}else a(c).replaceWith(a.FE.MARKERS),\\\"BLOCKQUOTE\\\"==e.tagName&&h.nodeType==Node.ELEMENT_NODE?a(h).remove():(a(h).after(b.node.isEmpty(e)?\\\"\\\":a(e).html()),a(e).remove(),\\\"BR\\\"==h.tagName&&a(h).remove())}}function i(c){for(var d=c;!d.previousSibling;)if(d=d.parentNode,b.node.isElement(d))return!1;d=d.previousSibling;var e;if(!b.node.isBlock(d)&&b.node.isEditable(d)){for(e=b.node.contents(d);d.nodeType!=Node.TEXT_NODE&&!b.node.isDeletable(d)&&e.length&&b.node.isEditable(d);)d=e[e.length-1],e=b.node.contents(d);if(d.nodeType==Node.TEXT_NODE){if(b.helpers.isIOS())return!0;var f=d.textContent,g=f.length-1;if(b.opts.tabSpaces&&f.length>=b.opts.tabSpaces){var h=f.substr(f.length-b.opts.tabSpaces,f.length-1);0===h.replace(/ /g,\\\"\\\").replace(new RegExp(a.FE.UNICODE_NBSP,\\\"g\\\"),\\\"\\\").length&&(g=f.length-b.opts.tabSpaces)}d.textContent=f.substring(0,g),d.textContent.length&&55357==d.textContent.charCodeAt(d.textContent.length-1)&&(d.textContent=d.textContent.substr(0,d.textContent.length-1));var i=f.length!=d.textContent.length;0===d.textContent.length?i&&b.opts.keepFormatOnDelete?a(d).after(a.FE.INVISIBLE_SPACE+a.FE.MARKERS):2!=d.parentNode.childNodes.length||d.parentNode!=c.parentNode||b.node.isBlock(d.parentNode)||b.node.isElement(d.parentNode)?(a(d).after(a.FE.MARKERS),b.node.isElement(d.parentNode)&&!c.nextSibling&&d.previousSibling&&\\\"BR\\\"==d.previousSibling.tagName&&a(c).after(\\\"<br>\\\"),d.parentNode.removeChild(d)):(a(d.parentNode).after(a.FE.MARKERS),a(d.parentNode).remove()):a(d).after(a.FE.MARKERS)}else b.node.isDeletable(d)?(a(d).after(a.FE.MARKERS),a(d).remove()):c.nextSibling&&\\\"BR\\\"==c.nextSibling.tagName&&b.node.isVoid(d)&&\\\"BR\\\"!=d.tagName?(a(c.nextSibling).remove(),a(c).replaceWith(a.FE.MARKERS)):b.events.trigger(\\\"node.remove\\\",[a(d)])!==!1&&(a(d).after(a.FE.MARKERS),a(d).remove())}else if(a.FE.NO_DELETE_TAGS.indexOf(d.tagName)<0&&(b.node.isEditable(d)||b.node.isDeletable(d)))if(b.node.isDeletable(d))a(c).replaceWith(a.FE.MARKERS),a(d).remove();else if(b.node.isEmpty(d)&&!b.node.isList(d))a(d).remove(),a(c).replaceWith(a.FE.MARKERS);else{for(b.node.isList(d)&&(d=a(d).find(\\\"li:last\\\").get(0)),e=b.node.contents(d),e&&\\\"BR\\\"==e[e.length-1].tagName&&a(e[e.length-1]).remove(),e=b.node.contents(d);e&&b.node.isBlock(e[e.length-1]);)d=e[e.length-1],e=b.node.contents(d);a(d).append(a.FE.MARKERS);for(var j=c;!j.previousSibling;)j=j.parentNode;for(;j&&\\\"BR\\\"!==j.tagName&&!b.node.isBlock(j);){var k=j;j=j.nextSibling,a(d).append(k)}j&&\\\"BR\\\"==j.tagName&&a(j).remove(),a(c).remove()}else c.nextSibling&&\\\"BR\\\"==c.nextSibling.tagName&&a(c.nextSibling).remove()}function j(){var f=!1,j=b.markers.insert();if(!j)return!0;for(var k=j.parentNode;k&&!b.node.isElement(k);){if(\\\"false\\\"===k.getAttribute(\\\"contenteditable\\\"))return a(j).replaceWith(a.FE.MARKERS),b.selection.restore(),!1;if(\\\"true\\\"===k.getAttribute(\\\"contenteditable\\\"))break;k=k.parentNode}b.el.normalize();var l=j.previousSibling;if(l){var m=l.textContent;m&&m.length&&8203==m.charCodeAt(m.length-1)&&(1==m.length?a(l).remove():(l.textContent=l.textContent.substr(0,m.length-1),l.textContent.length&&55357==l.textContent.charCodeAt(l.textContent.length-1)&&(l.textContent=l.textContent.substr(0,l.textContent.length-1))))}return c(j)?f=i(j):d(j)?g(j)&&e(j,a(j).parents(\\\"li:first\\\").get(0))?b.cursorLists._backspace(j):h(j):f=i(j),a(j).remove(),n(),b.html.fillEmptyBlocks(!0),b.opts.htmlUntouched||(b.html.cleanEmptyTags(),b.clean.quotes(),b.clean.lists()),b.spaces.normalizeAroundCursor(),b.selection.restore(),f}function k(c){var d=a(c).parentsUntil(b.$el,\\\"BLOCKQUOTE\\\").length>0,e=b.node.deepestParent(c,[],!d);if(e&&\\\"BLOCKQUOTE\\\"==e.tagName){var f=b.node.deepestParent(c,[a(c).parentsUntil(b.$el,\\\"BLOCKQUOTE\\\").get(0)]);f&&f.nextSibling&&(e=f)}if(null!==e){var g,h=e.nextSibling;if(b.node.isBlock(e)&&(b.node.isEditable(e)||b.node.isDeletable(e))&&h&&a.FE.NO_DELETE_TAGS.indexOf(h.tagName)<0)if(b.node.isDeletable(h))a(h).remove(),a(c).replaceWith(a.FE.MARKERS);else if(b.node.isBlock(h)&&b.node.isEditable(h))if(b.node.isList(h))if(b.node.isEmpty(e,!0))a(e).remove(),a(h).find(\\\"li:first\\\").prepend(a.FE.MARKERS);else{var i=a(h).find(\\\"li:first\\\");\\\"BLOCKQUOTE\\\"==e.tagName&&(g=b.node.contents(e),g.length&&b.node.isBlock(g[g.length-1])&&(e=g[g.length-1])),0===i.find(\\\"ul, ol\\\").length&&(a(c).replaceWith(a.FE.MARKERS),i.find(b.html.blockTagsQuery()).not(\\\"ol, ul, table\\\").each(function(){this.parentNode==i.get(0)&&a(this).replaceWith(a(this).html()+(b.node.isEmpty(this)?\\\"\\\":\\\"<br>\\\"))}),a(e).append(b.node.contents(i.get(0))),i.remove(),0===a(h).find(\\\"li\\\").length&&a(h).remove())}else{if(g=b.node.contents(h),g.length&&\\\"BR\\\"==g[0].tagName&&a(g[0]).remove(),\\\"BLOCKQUOTE\\\"!=h.tagName&&\\\"BLOCKQUOTE\\\"==e.tagName)for(g=b.node.contents(e);g.length&&b.node.isBlock(g[g.length-1]);)e=g[g.length-1],g=b.node.contents(e);else if(\\\"BLOCKQUOTE\\\"==h.tagName&&\\\"BLOCKQUOTE\\\"!=e.tagName)for(g=b.node.contents(h);g.length&&b.node.isBlock(g[0]);)h=g[0],g=b.node.contents(h);a(c).replaceWith(a.FE.MARKERS),a(e).append(h.innerHTML),a(h).remove()}else{for(a(c).replaceWith(a.FE.MARKERS);h&&\\\"BR\\\"!==h.tagName&&!b.node.isBlock(h)&&b.node.isEditable(h);){var j=h;h=h.nextSibling,a(e).append(j)}h&&\\\"BR\\\"==h.tagName&&b.node.isEditable(h)&&a(h).remove()}}}function l(d){for(var e=d;!e.nextSibling;)if(e=e.parentNode,b.node.isElement(e))return!1;if(e=e.nextSibling,\\\"BR\\\"==e.tagName&&b.node.isEditable(e))if(e.nextSibling){if(b.node.isBlock(e.nextSibling)&&b.node.isEditable(e.nextSibling)){if(!(a.FE.NO_DELETE_TAGS.indexOf(e.nextSibling.tagName)<0))return void a(e).remove();e=e.nextSibling,a(e.previousSibling).remove()}}else if(c(e)){if(g(d))b.cursorLists._del(d);else{var f=b.node.deepestParent(e);f&&((!b.node.isEmpty(b.node.blockParent(e))||(b.node.blockParent(e).nextSibling&&a.FE.NO_DELETE_TAGS.indexOf(b.node.blockParent(e).nextSibling.tagName))<0)&&a(e).remove(),k(d))}return}var h;if(!b.node.isBlock(e)&&b.node.isEditable(e)){for(h=b.node.contents(e);e.nodeType!=Node.TEXT_NODE&&h.length&&!b.node.isDeletable(e)&&b.node.isEditable(e);)e=h[0],h=b.node.contents(e);e.nodeType==Node.TEXT_NODE?(a(e).before(a.FE.MARKERS),e.textContent.length&&55357==e.textContent.charCodeAt(0)?e.textContent=e.textContent.substring(2,e.textContent.length):e.textContent=e.textContent.substring(1,e.textContent.length)):b.node.isDeletable(e)?(a(e).before(a.FE.MARKERS),a(e).remove()):b.events.trigger(\\\"node.remove\\\",[a(e)])!==!1&&(a(e).before(a.FE.MARKERS),a(e).remove()),a(d).remove()}else if(a.FE.NO_DELETE_TAGS.indexOf(e.tagName)<0&&(b.node.isEditable(e)||b.node.isDeletable(e)))if(b.node.isDeletable(e))a(d).replaceWith(a.FE.MARKERS),a(e).remove();else if(b.node.isList(e))d.previousSibling?(a(e).find(\\\"li:first\\\").prepend(d),b.cursorLists._backspace(d)):(a(e).find(\\\"li:first\\\").prepend(a.FE.MARKERS),a(d).remove());else if(h=b.node.contents(e),h&&\\\"BR\\\"==h[0].tagName&&a(h[0]).remove(),h&&\\\"BLOCKQUOTE\\\"==e.tagName){var i=h[0];for(a(d).before(a.FE.MARKERS);i&&\\\"BR\\\"!=i.tagName;){var j=i;i=i.nextSibling,a(d).before(j)}i&&\\\"BR\\\"==i.tagName&&a(i).remove()}else a(d).after(a(e).html()).after(a.FE.MARKERS),a(e).remove()}function m(){var e=b.markers.insert();if(!e)return!1;if(b.el.normalize(),c(e))if(g(e))if(0===a(e).parents(\\\"li:first\\\").find(\\\"ul, ol\\\").length)b.cursorLists._del(e);else{var f=a(e).parents(\\\"li:first\\\").find(\\\"ul:first, ol:first\\\").find(\\\"li:first\\\");f=f.find(b.html.blockTagsQuery()).get(-1)||f,f.prepend(e),b.cursorLists._backspace(e)}else k(e);else l(d(e)?e:e);a(e).remove(),n(),b.html.fillEmptyBlocks(!0),b.opts.htmlUntouched||(b.html.cleanEmptyTags(),b.clean.quotes(),b.clean.lists()),b.spaces.normalizeAroundCursor(),b.selection.restore()}function n(){for(var a=b.el.querySelectorAll(\\\"blockquote:empty\\\"),c=0;c<a.length;c++)a[c].parentNode.removeChild(a[c])}function o(){b.$el.find(\\\".fr-to-remove\\\").each(function(){for(var c=b.node.contents(this),d=0;d<c.length;d++)c[d].nodeType==Node.TEXT_NODE&&(c[d].textContent=c[d].textContent.replace(/\\\\u200B/g,\\\"\\\"));a(this).replaceWith(this.innerHTML)})}function p(c,d,e){var g,h=b.node.deepestParent(c,[],!e);if(h&&\\\"BLOCKQUOTE\\\"==h.tagName)return f(c,h)?(g=b.html.defaultTag(),g?a(h).after(\\\"<\\\"+g+\\\">\\\"+a.FE.MARKERS+\\\"<br></\\\"+g+\\\">\\\"):a(h).after(a.FE.MARKERS+\\\"<br>\\\"),a(c).remove(),!1):(r(c,d,e),!1);if(null==h)g=b.html.defaultTag(),g&&b.node.isElement(c.parentNode)?a(c).replaceWith(\\\"<\\\"+g+\\\">\\\"+a.FE.MARKERS+\\\"<br></\\\"+g+\\\">\\\"):a(c).replaceWith((b.node.isEmpty(c.parentNode,!0)?\\\"\\\":\\\"<br/>\\\")+a.FE.MARKERS+\\\"<br/>\\\");else{var i=c,j=\\\"\\\";b.node.isBlock(h)&&!d||(j=\\\"<br/>\\\");var k=\\\"\\\",l=\\\"\\\";g=b.html.defaultTag();var m=\\\"\\\",n=\\\"\\\";g&&b.node.isBlock(h)&&(m=\\\"<\\\"+g+\\\">\\\",n=\\\"</\\\"+g+\\\">\\\",h.tagName==g.toUpperCase()&&(m=b.node.openTagString(a(h).clone().removeAttr(\\\"id\\\").get(0))));do if(i=i.parentNode,!d||i!=h||d&&!b.node.isBlock(h))if(k+=b.node.closeTagString(i),i==h&&b.node.isBlock(h))l=m+l;else{var o=\\\"A\\\"==i.tagName&&f(c,i)?\\\"fr-to-remove\\\":\\\"\\\";l=b.node.openTagString(a(i).clone().addClass(o).get(0))+l}while(i!=h);j=k+j+l+(c.parentNode==h&&b.node.isBlock(h)?\\\"\\\":a.FE.INVISIBLE_SPACE)+a.FE.MARKERS,b.node.isBlock(h)&&!a(h).find(\\\"*:last\\\").is(\\\"br\\\")&&a(h).append(\\\"<br/>\\\"),a(c).after('<span id=\\\"fr-break\\\"></span>'),a(c).remove(),h.nextSibling&&!b.node.isBlock(h.nextSibling)||b.node.isBlock(h)||a(h).after(\\\"<br>\\\");var p;p=!d&&b.node.isBlock(h)?b.node.openTagString(h)+a(h).html()+n:b.node.openTagString(h)+a(h).html()+b.node.closeTagString(h),p=p.replace(/<span id=\\\"fr-break\\\"><\\\\/span>/g,j),a(h).replaceWith(p)}}function q(c,d,g){var h,i=b.node.deepestParent(c,[],!g);if(i&&\\\"TABLE\\\"==i.tagName)return a(i).find(\\\"td:first, th:first\\\").prepend(c),q(c,d,g);if(i&&\\\"BLOCKQUOTE\\\"==i.tagName){if(e(c,i))return h=b.html.defaultTag(),h?a(i).before(\\\"<\\\"+h+\\\">\\\"+a.FE.MARKERS+\\\"<br></\\\"+h+\\\">\\\"):a(i).before(a.FE.MARKERS+\\\"<br>\\\"),a(c).remove(),!1;f(c,i)?p(c,d,!0):r(c,d,!0)}if(null==i)h=b.html.defaultTag(),h&&b.node.isElement(c.parentNode)?a(c).replaceWith(\\\"<\\\"+h+\\\">\\\"+a.FE.MARKERS+\\\"<br></\\\"+h+\\\">\\\"):a(c).replaceWith(\\\"<br>\\\"+a.FE.MARKERS);else{if(b.node.isBlock(i))if(d)a(c).remove(),a(i).prepend(\\\"<br>\\\"+a.FE.MARKERS);else{if(b.node.isEmpty(i,!0))return p(c,d,g);a(i).before(b.node.openTagString(a(i).clone().removeAttr(\\\"id\\\").get(0))+\\\"<br>\\\"+b.node.closeTagString(i))}else a(i).before(\\\"<br>\\\");a(c).remove()}}function r(c,d,g){var h=b.node.deepestParent(c,[],!g);if(null==h)b.html.defaultTag()&&c.parentNode===b.el?a(c).replaceWith(\\\"<\\\"+b.html.defaultTag()+\\\">\\\"+a.FE.MARKERS+\\\"<br></\\\"+b.html.defaultTag()+\\\">\\\"):(c.nextSibling&&!b.node.isBlock(c.nextSibling)||a(c).after(\\\"<br>\\\"),a(c).replaceWith(\\\"<br>\\\"+a.FE.MARKERS));else{var i=c,j=\\\"\\\";\\\"PRE\\\"==h.tagName&&(d=!0),b.node.isBlock(h)&&!d||(j=\\\"<br>\\\");var k=\\\"\\\",l=\\\"\\\";do{var m=i;if(i=i.parentNode,\\\"BLOCKQUOTE\\\"==h.tagName&&b.node.isEmpty(m)&&!b.node.hasClass(m,\\\"fr-marker\\\")&&a(m).find(c).length>0&&a(m).after(c),(\\\"BLOCKQUOTE\\\"!=h.tagName||!f(c,i)&&!e(c,i))&&(!d||i!=h||d&&!b.node.isBlock(h))){k+=b.node.closeTagString(i);var n=\\\"A\\\"==i.tagName&&f(c,i)?\\\"fr-to-remove\\\":\\\"\\\";l=b.node.openTagString(a(i).clone().addClass(n).removeAttr(\\\"id\\\").get(0))+l}}while(i!=h);var o=h==c.parentNode&&b.node.isBlock(h)||c.nextSibling;if(\\\"BLOCKQUOTE\\\"==h.tagName){c.previousSibling&&b.node.isBlock(c.previousSibling)&&c.nextSibling&&\\\"BR\\\"==c.nextSibling.tagName&&(a(c.nextSibling).after(c),c.nextSibling&&\\\"BR\\\"==c.nextSibling.tagName&&a(c.nextSibling).remove());var p=b.html.defaultTag();j=k+j+(p?\\\"<\\\"+p+\\\">\\\":\\\"\\\")+a.FE.MARKERS+\\\"<br>\\\"+(p?\\\"</\\\"+p+\\\">\\\":\\\"\\\")+l}else j=k+j+l+(o?\\\"\\\":a.FE.INVISIBLE_SPACE)+a.FE.MARKERS;a(c).replaceWith('<span id=\\\"fr-break\\\"></span>');var q=b.node.openTagString(h)+a(h).html()+b.node.closeTagString(h);q=q.replace(/<span id=\\\"fr-break\\\"><\\\\/span>/g,j),a(h).replaceWith(q)}}function s(e){var f=b.markers.insert();\\nif(!f)return!0;b.el.normalize();var h=!1;a(f).parentsUntil(b.$el,\\\"BLOCKQUOTE\\\").length>0&&(e=!1,h=!0),a(f).parentsUntil(b.$el,\\\"TD, TH\\\").length&&(h=!1),c(f)?!g(f)||e||h?p(f,e,h):b.cursorLists._endEnter(f):d(f)?!g(f)||e||h?q(f,e,h):b.cursorLists._startEnter(f):!g(f)||e||h?r(f,e,h):b.cursorLists._middleEnter(f),o(),b.opts.htmlUntouched||(b.html.fillEmptyBlocks(!0),b.html.cleanEmptyTags(),b.clean.lists()),b.spaces.normalizeAroundCursor(),b.selection.restore()}return{enter:s,backspace:j,del:m,isAtEnd:f,isAtStart:e}},a.FE.ENTER_P=0,a.FE.ENTER_DIV=1,a.FE.ENTER_BR=2,a.FE.KEYCODE={BACKSPACE:8,TAB:9,ENTER:13,SHIFT:16,CTRL:17,ALT:18,ESC:27,SPACE:32,ARROW_LEFT:37,ARROW_UP:38,ARROW_RIGHT:39,ARROW_DOWN:40,DELETE:46,ZERO:48,ONE:49,TWO:50,THREE:51,FOUR:52,FIVE:53,SIX:54,SEVEN:55,EIGHT:56,NINE:57,FF_SEMICOLON:59,FF_EQUALS:61,QUESTION_MARK:63,A:65,B:66,C:67,D:68,E:69,F:70,G:71,H:72,I:73,J:74,K:75,L:76,M:77,N:78,O:79,P:80,Q:81,R:82,S:83,T:84,U:85,V:86,W:87,X:88,Y:89,Z:90,META:91,NUM_ZERO:96,NUM_ONE:97,NUM_TWO:98,NUM_THREE:99,NUM_FOUR:100,NUM_FIVE:101,NUM_SIX:102,NUM_SEVEN:103,NUM_EIGHT:104,NUM_NINE:105,NUM_MULTIPLY:106,NUM_PLUS:107,NUM_MINUS:109,NUM_PERIOD:110,NUM_DIVISION:111,F1:112,F2:113,F3:114,F4:115,F5:116,F6:117,F7:118,F8:119,F9:120,F10:121,F11:122,F12:123,FF_HYPHEN:173,SEMICOLON:186,DASH:189,EQUALS:187,COMMA:188,HYPHEN:189,PERIOD:190,SLASH:191,APOSTROPHE:192,TILDE:192,SINGLE_QUOTE:222,OPEN_SQUARE_BRACKET:219,BACKSLASH:220,CLOSE_SQUARE_BRACKET:221},a.extend(a.FE.DEFAULTS,{enter:a.FE.ENTER_P,multiLine:!0,tabSpaces:0}),a.FE.MODULES.keys=function(b){function c(a){b.opts.multiLine?b.helpers.isIOS()||(a.preventDefault(),a.stopPropagation(),b.selection.isCollapsed()||b.selection.remove(),b.cursor.enter()):(a.preventDefault(),a.stopPropagation())}function d(a){a.preventDefault(),a.stopPropagation(),b.opts.multiLine&&(b.selection.isCollapsed()||b.selection.remove(),b.cursor.enter(!0))}function e(a){b.selection.isCollapsed()?b.cursor.backspace()||(a.preventDefault(),a.stopPropagation(),z=!1):(a.preventDefault(),a.stopPropagation(),b.selection.remove(),b.html.fillEmptyBlocks(),z=!1),b.placeholder.refresh()}function f(a){a.preventDefault(),a.stopPropagation(),\\\"\\\"===b.selection.text()?b.cursor.del():b.selection.remove(),b.placeholder.refresh()}function g(c){var d=b.selection.element();if(!b.helpers.isMobile()&&(b.browser.mozilla||d&&\\\"A\\\"==d.tagName)){c.preventDefault(),c.stopPropagation(),b.selection.isCollapsed()||b.selection.remove();var e=b.markers.insert();if(e){var f=e.previousSibling,g=e.nextSibling;!g&&e.parentNode&&\\\"A\\\"==e.parentNode.tagName?(e.parentNode.insertAdjacentHTML(\\\"afterend\\\",\\\"&nbsp;\\\"+a.FE.MARKERS),e.parentNode.removeChild(e)):(f&&f.nodeType==Node.TEXT_NODE&&1==f.textContent.length&&160==f.textContent.charCodeAt(0)?f.textContent=f.textContent+\\\" \\\":e.insertAdjacentHTML(\\\"beforebegin\\\",\\\"&nbsp;\\\"),e.outerHTML=a.FE.MARKERS),b.selection.restore()}}}function h(){if(b.browser.mozilla&&b.selection.isCollapsed()&&!C){var a=b.selection.ranges(0),c=a.startContainer,d=a.startOffset;c&&c.nodeType==Node.TEXT_NODE&&d<=c.textContent.length&&d>0&&32==c.textContent.charCodeAt(d-1)&&(b.selection.save(),b.spaces.normalize(),b.selection.restore())}}function i(){b.selection.isFull()&&setTimeout(function(){var c=b.html.defaultTag();c?b.$el.html(\\\"<\\\"+c+\\\">\\\"+a.FE.MARKERS+\\\"<br/></\\\"+c+\\\">\\\"):b.$el.html(a.FE.MARKERS+\\\"<br/>\\\"),b.selection.restore(),b.placeholder.refresh(),b.button.bulkRefresh(),b.undo.saveStep()},0)}function j(a){if(b.opts.tabSpaces>0)if(b.selection.isCollapsed()){b.undo.saveStep(),a.preventDefault(),a.stopPropagation();for(var c=\\\"\\\",d=0;d<b.opts.tabSpaces;d++)c+=\\\"&nbsp;\\\";b.html.insert(c),b.placeholder.refresh(),b.undo.saveStep()}else a.preventDefault(),a.stopPropagation(),a.shiftKey?b.commands.outdent():b.commands.indent()}function k(){C=!1}function l(){return C}function m(h){b.events.disableBlur(),z=!0;var i=h.which;if(16===i)return!0;if(229===i)return C=!0,!0;C=!1;var k=t(i)&&!r(h),l=i==a.FE.KEYCODE.BACKSPACE||i==a.FE.KEYCODE.DELETE;if((b.selection.isFull()&&!b.opts.keepFormatOnDelete&&!b.placeholder.isVisible()||l&&b.placeholder.isVisible()&&b.opts.keepFormatOnDelete)&&(k||l)){var m=b.html.defaultTag();if(m?b.$el.html(\\\"<\\\"+m+\\\">\\\"+a.FE.MARKERS+\\\"<br/></\\\"+m+\\\">\\\"):b.$el.html(a.FE.MARKERS+\\\"<br/>\\\"),b.selection.restore(),!t(i))return h.preventDefault(),!0}i==a.FE.KEYCODE.ENTER?h.shiftKey?d(h):c(h):i!=a.FE.KEYCODE.BACKSPACE||r(h)||h.altKey?i!=a.FE.KEYCODE.DELETE||r(h)||h.altKey?i==a.FE.KEYCODE.SPACE?g(h):i==a.FE.KEYCODE.TAB?j(h):r(h)||!t(h.which)||b.selection.isCollapsed()||h.ctrlKey||b.selection.remove():b.placeholder.isVisible()?(h.preventDefault(),h.stopPropagation()):f(h):b.placeholder.isVisible()?(h.preventDefault(),h.stopPropagation()):e(h),b.events.enableBlur()}function n(a){for(var c=b.doc.createTreeWalker(a,NodeFilter.SHOW_TEXT,b.node.filter(function(a){return/\\\\u200B/gi.test(a.textContent)}),!1);c.nextNode();){var d=c.currentNode;d.textContent=d.textContent.replace(/\\\\u200B/gi,\\\"\\\")}}function o(){if(!b.$wp)return!0;var c;b.opts.height||b.opts.heightMax?(c=b.position.getBoundingRect().top,b.helpers.isIOS()&&(c-=b.helpers.scrollTop()),b.opts.iframe&&(c+=b.$iframe.offset().top),c>b.$wp.offset().top-b.helpers.scrollTop()+b.$wp.height()-20&&b.$wp.scrollTop(c+b.$wp.scrollTop()-(b.$wp.height()+b.$wp.offset().top)+b.helpers.scrollTop()+20)):(c=b.position.getBoundingRect().top,b.opts.toolbarBottom&&(c+=b.opts.toolbarStickyOffset),b.helpers.isIOS()&&(c-=b.helpers.scrollTop()),b.opts.iframe&&(c+=b.$iframe.offset().top,c-=b.helpers.scrollTop()),c+=b.opts.toolbarStickyOffset,c>b.o_win.innerHeight-20&&a(b.o_win).scrollTop(c+b.helpers.scrollTop()-b.o_win.innerHeight+20),c=b.position.getBoundingRect().top,b.opts.toolbarBottom||(c-=b.opts.toolbarStickyOffset),b.helpers.isIOS()&&(c-=b.helpers.scrollTop()),b.opts.iframe&&(c+=b.$iframe.offset().top,c-=b.helpers.scrollTop()),c<b.$tb.height()+20&&c>=0&&a(b.o_win).scrollTop(c+b.helpers.scrollTop()-b.$tb.height()-20))}function p(){var c=b.selection.element(),d=b.node.blockParent(c);if(d&&\\\"DIV\\\"==d.tagName&&b.selection.info(d).atStart){var e=b.html.defaultTag();d.previousSibling&&\\\"DIV\\\"!=d.previousSibling.tagName&&e&&\\\"div\\\"!=e&&(b.selection.save(),a(d).replaceWith(\\\"<\\\"+e+\\\">\\\"+d.innerHTML+\\\"</\\\"+e+\\\">\\\"),b.selection.restore())}}function q(c){if(b.helpers.isAndroid&&b.browser.mozilla)return!0;if(C)return!1;if(!b.selection.isCollapsed())return!0;if(c&&(c.which===a.FE.KEYCODE.META||c.which==a.FE.KEYCODE.CTRL))return!0;if(c&&s(c.which))return!0;c&&c.which==a.FE.KEYCODE.ENTER&&b.helpers.isIOS()&&p(),c&&(c.which==a.FE.KEYCODE.ENTER||c.which==a.FE.KEYCODE.BACKSPACE||c.which>=37&&c.which<=40&&!b.browser.msie)&&(c.which==a.FE.KEYCODE.BACKSPACE&&z||o()),b.html.cleanBRs(!0,!0);var d=function(a){if(!a)return!1;var b=a.innerHTML;return b=b.replace(/<span[^>]*? class\\\\s*=\\\\s*[\\\"']?fr-marker[\\\"']?[^>]+>\\\\u200b<\\\\/span>/gi,\\\"\\\"),!!(b&&/\\\\u200B/.test(b)&&b.replace(/\\\\u200B/gi,\\\"\\\").length>0)},e=function(a){var c=/[\\\\u3041-\\\\u3096\\\\u30A0-\\\\u30FF\\\\u4E00-\\\\u9FFF\\\\u3130-\\\\u318F\\\\uAC00-\\\\uD7AF]/gi;return!b.helpers.isIOS()||0===((a.textContent||\\\"\\\").match(c)||[]).length},f=b.selection.element();d(f)&&!b.node.hasClass(f,\\\"fr-marker\\\")&&\\\"IFRAME\\\"!=f.tagName&&e(f)&&(b.selection.save(),n(f),b.selection.restore())}function r(a){if(navigator.userAgent.indexOf(\\\"Mac OS X\\\")!=-1){if(a.metaKey&&!a.altKey)return!0}else if(a.ctrlKey&&!a.altKey)return!0;return!1}function s(b){if(b>=a.FE.KEYCODE.ARROW_LEFT&&b<=a.FE.KEYCODE.ARROW_DOWN)return!0}function t(c){if(c>=a.FE.KEYCODE.ZERO&&c<=a.FE.KEYCODE.NINE)return!0;if(c>=a.FE.KEYCODE.NUM_ZERO&&c<=a.FE.KEYCODE.NUM_MULTIPLY)return!0;if(c>=a.FE.KEYCODE.A&&c<=a.FE.KEYCODE.Z)return!0;if(b.browser.webkit&&0===c)return!0;switch(c){case a.FE.KEYCODE.SPACE:case a.FE.KEYCODE.QUESTION_MARK:case a.FE.KEYCODE.NUM_PLUS:case a.FE.KEYCODE.NUM_MINUS:case a.FE.KEYCODE.NUM_PERIOD:case a.FE.KEYCODE.NUM_DIVISION:case a.FE.KEYCODE.SEMICOLON:case a.FE.KEYCODE.FF_SEMICOLON:case a.FE.KEYCODE.DASH:case a.FE.KEYCODE.EQUALS:case a.FE.KEYCODE.FF_EQUALS:case a.FE.KEYCODE.COMMA:case a.FE.KEYCODE.PERIOD:case a.FE.KEYCODE.SLASH:case a.FE.KEYCODE.APOSTROPHE:case a.FE.KEYCODE.SINGLE_QUOTE:case a.FE.KEYCODE.OPEN_SQUARE_BRACKET:case a.FE.KEYCODE.BACKSLASH:case a.FE.KEYCODE.CLOSE_SQUARE_BRACKET:return!0;default:return!1}}function u(c){var d=c.which;return!!(r(c)||d>=37&&d<=40||!t(d)&&d!=a.FE.KEYCODE.DELETE&&d!=a.FE.KEYCODE.BACKSPACE&&d!=a.FE.KEYCODE.ENTER&&229!=d)||(A||(B=b.snapshot.get(),b.undo.canDo()||b.undo.saveStep()),clearTimeout(A),void(A=setTimeout(function(){A=null,b.undo.saveStep()},Math.max(250,b.opts.typingTimer))))}function v(a){var c=a.which;return!!(r(a)||c>=37&&c<=40)||void(B&&A&&(b.undo.saveStep(B),B=null))}function w(){A&&(clearTimeout(A),b.undo.saveStep(),B=null)}function x(b){var c=b.which;return r(b)||c==a.FE.KEYCODE.F5}function y(){if(b.events.on(\\\"keydown\\\",u),b.events.on(\\\"input\\\",h),b.events.on(\\\"keyup input\\\",v),b.events.on(\\\"keypress\\\",k),b.events.on(\\\"keydown\\\",m),b.events.on(\\\"keyup\\\",q),b.events.on(\\\"html.inserted\\\",q),b.events.on(\\\"cut\\\",i),!b.browser.edge&&b.el.msGetInputContext)try{b.el.msGetInputContext().addEventListener(\\\"MSCandidateWindowShow\\\",function(){C=!0}),b.el.msGetInputContext().addEventListener(\\\"MSCandidateWindowHide\\\",function(){C=!1,q()})}catch(a){}}var z,A,B,C=!1;return{_init:y,ctrlKey:r,isCharacter:t,isArrow:s,forceUndo:w,isIME:l,isBrowserAction:x}},a.FE.MODULES.accessibility=function(b){function c(a){if(a&&a.length){a.data(\\\"blur-event-set\\\")||a.parents(\\\".fr-popup\\\").length||(b.events.$on(a,\\\"blur\\\",function(){var c=a.parents(\\\".fr-toolbar, .fr-popup\\\").data(\\\"instance\\\")||b;c.events.blurActive()&&c.events.trigger(\\\"blur\\\"),c.events.enableBlur()},!0),a.data(\\\"blur-event-set\\\",!0));var c=a.parents(\\\".fr-toolbar, .fr-popup\\\").data(\\\"instance\\\")||b;c.events.disableBlur(),a.focus(),b.shared.$f_el=a}}function d(a,b){var d=b?\\\"last\\\":\\\"first\\\",e=a.find(\\\"button:visible:not(.fr-disabled), .fr-group span.fr-command:visible\\\")[d]();if(e.length)return c(e),!0}function e(a){return a.is(\\\"input, textarea\\\")&&g(),b.events.disableBlur(),a.focus(),!0}function f(a,c){var d=a.find(\\\"input, textarea, button, select\\\").filter(\\\":visible\\\").not(\\\":disabled\\\").filter(c?\\\":last\\\":\\\":first\\\");if(d.length)return e(d);if(b.shared.with_kb){var f=a.find(\\\".fr-active-item:visible:first\\\");if(f.length)return e(f);var g=a.find(\\\"[tabIndex]:visible:first\\\");if(g.length)return e(g)}}function g(){0===b.$el.find(\\\".fr-marker\\\").length&&b.core.hasFocus()&&b.selection.save()}function h(a){a.$el.find(\\\".fr-marker\\\").length&&(a.events.disableBlur(),a.selection.restore(),a.events.enableBlur())}function i(a){var c=a.children().not(\\\".fr-buttons\\\");c.data(\\\"mouseenter-event-set\\\")||(b.events.$on(c,\\\"mouseenter\\\",\\\"[tabIndex]\\\",function(d){var e=a.data(\\\"instance\\\")||b;if(!F)return d.stopPropagation(),void d.preventDefault();var f=c.find(\\\":focus:first\\\");f.length&&!f.is(\\\"input, button, textarea\\\")&&(e.events.disableBlur(),f.blur(),e.events.disableBlur(),e.events.focus())}),c.data(\\\"mouseenter-event-set\\\",!0)),!f(c)&&b.shared.with_kb&&d(a.find(\\\".fr-buttons\\\"))}function j(a){b.core.hasFocus()||(b.events.disableBlur(),b.events.focus()),b.accessibility.saveSelection(),b.events.disableBlur(),b.$el.blur(),b.selection.clear(),b.events.disableBlur(),b.shared.with_kb?a.find(\\\".fr-command[tabIndex], [tabIndex]\\\").first().focus():a.find(\\\"[tabIndex]:first\\\").focus()}function k(){var a=b.popups.areVisible();if(a){var c=a.find(\\\".fr-buttons\\\");return c.find(\\\"button:focus, .fr-group span:focus\\\").length?!d(a.data(\\\"instance\\\").$tb):!d(c)}return!d(b.$tb)}function l(){var a=null;return b.shared.$f_el.is(\\\".fr-dropdown.fr-active\\\")?a=b.shared.$f_el:b.shared.$f_el.closest(\\\".fr-dropdown-menu\\\").prev().is(\\\".fr-dropdown.fr-active\\\")&&(a=b.shared.$f_el.closest(\\\".fr-dropdown-menu\\\").prev()),a}function m(e,g,h){if(b.shared.$f_el){var i=l();i&&(b.button.click(i),b.shared.$f_el=i);var j=e.find(\\\"button:visible:not(.fr-disabled), .fr-group span.fr-command:visible\\\"),k=j.index(b.shared.$f_el);if(0===k&&!h||k==j.length-1&&h){var m;if(g){if(e.parent().is(\\\".fr-popup\\\")){var n=e.parent().children().not(\\\".fr-buttons\\\");m=!f(n,!h)}m===!1&&(b.shared.$f_el=null)}g&&m===!1||d(e,!h)}else c(a(j.get(k+(h?1:-1))));return!1}}function n(a,b){return m(a,b,!0)}function o(a,b){return m(a,b)}function p(a){if(b.shared.$f_el){var d;if(b.shared.$f_el.is(\\\".fr-dropdown.fr-active\\\"))return d=a?b.shared.$f_el.next().find(\\\".fr-command:not(.fr-disabled)\\\").first():b.shared.$f_el.next().find(\\\".fr-command:not(.fr-disabled)\\\").last(),c(d),!1;if(b.shared.$f_el.is(\\\"a.fr-command\\\"))return d=a?b.shared.$f_el.closest(\\\"li\\\").nextAll(\\\":visible:first\\\").find(\\\".fr-command:not(.fr-disabled)\\\").first():b.shared.$f_el.closest(\\\"li\\\").prevAll(\\\":visible:first\\\").find(\\\".fr-command:not(.fr-disabled)\\\").first(),d.length||(d=a?b.shared.$f_el.closest(\\\".fr-dropdown-menu\\\").find(\\\".fr-command:not(.fr-disabled)\\\").first():b.shared.$f_el.closest(\\\".fr-dropdown-menu\\\").find(\\\".fr-command:not(.fr-disabled)\\\").last()),c(d),!1}}function q(){return b.shared.$f_el&&b.shared.$f_el.is(\\\".fr-dropdown:not(.fr-active)\\\")?s():p(!0)}function r(){return p()}function s(){if(b.shared.$f_el){if(b.shared.$f_el.hasClass(\\\"fr-dropdown\\\"))b.button.click(b.shared.$f_el);else if(b.shared.$f_el.is(\\\"button.fr-back\\\")){b.opts.toolbarInline&&(b.events.disableBlur(),b.events.focus());var a=b.popups.areVisible(b);a&&(b.shared.with_kb=!1),b.button.click(b.shared.$f_el),z(a)}else{if(b.events.disableBlur(),b.button.click(b.shared.$f_el),b.shared.$f_el.attr(\\\"data-popup\\\")){var c=b.popups.areVisible(b);c&&c.data(\\\"popup-button\\\",b.shared.$f_el)}else if(b.shared.$f_el.attr(\\\"data-modal\\\")){var d=b.modals.areVisible(b);d&&d.data(\\\"modal-button\\\",b.shared.$f_el)}b.shared.$f_el=null}return!1}}function t(){b.shared.$f_el&&(b.events.disableBlur(),b.shared.$f_el.blur(),b.shared.$f_el=null),b.events.trigger(\\\"toolbar.focusEditor\\\")!==!1&&(b.events.disableBlur(),b.events.focus())}function u(a){if(b.shared.$f_el){var d=l();return d?(b.button.click(d),c(d)):a.parent().find(\\\".fr-back:visible\\\").length?(b.shared.with_kb=!1,b.opts.toolbarInline&&(b.events.disableBlur(),b.events.focus()),b.button.exec(a.parent().find(\\\".fr-back:visible:first\\\")),z(a.parent())):b.shared.$f_el.is(\\\"button, .fr-group span\\\")&&(a.parent().is(\\\".fr-popup\\\")?(h(b),b.shared.$f_el=null,b.events.trigger(\\\"toolbar.esc\\\")!==!1&&(b.popups.hide(a.parent()),b.opts.toolbarInline&&b.toolbar.showInline(null,!0),z(a.parent()))):t()),!1}}function v(c,d){var e=navigator.userAgent.indexOf(\\\"Mac OS X\\\")!=-1?c.metaKey:c.ctrlKey,f=c.which,g=!1;return f!=a.FE.KEYCODE.TAB||e||c.shiftKey||c.altKey?f!=a.FE.KEYCODE.ARROW_RIGHT||e||c.shiftKey||c.altKey?f!=a.FE.KEYCODE.TAB||e||!c.shiftKey||c.altKey?f!=a.FE.KEYCODE.ARROW_LEFT||e||c.shiftKey||c.altKey?f!=a.FE.KEYCODE.ARROW_UP||e||c.shiftKey||c.altKey?f!=a.FE.KEYCODE.ARROW_DOWN||e||c.shiftKey||c.altKey?f!=a.FE.KEYCODE.ENTER||e||c.shiftKey||c.altKey?f!=a.FE.KEYCODE.ESC||e||c.shiftKey||c.altKey?f!=a.FE.KEYCODE.F10||e||c.shiftKey||!c.altKey||(g=k()):g=u(d):g=s():g=q():g=r():g=o(d):g=o(d,!0):g=n(d):g=n(d,!0),b.shared.$f_el||void 0!==g||(g=!0),!g&&b.keys.isBrowserAction(c)&&(g=!0),!!g||(c.preventDefault(),c.stopPropagation(),!1)}function w(c){c&&c.length&&(b.events.$on(c,\\\"keydown\\\",function(d){if(!a(d.target).is(\\\"a.fr-command, button.fr-command, .fr-group span.fr-command\\\"))return!0;var e=c.parents(\\\".fr-popup\\\").data(\\\"instance\\\")||c.data(\\\"instance\\\")||b;b.shared.with_kb=!0;var f=e.accessibility.exec(d,c);return b.shared.with_kb=!1,f},!0),b.events.$on(c,\\\"mouseenter\\\",\\\"[tabIndex]\\\",function(d){var e=c.parents(\\\".fr-popup\\\").data(\\\"instance\\\")||c.data(\\\"instance\\\")||b;if(!F)return d.stopPropagation(),void d.preventDefault();var f=a(d.currentTarget);e.shared.$f_el&&e.shared.$f_el.not(f)&&e.accessibility.focusEditor()},!0))}function x(a){var c=b.popups.get(a),d=y(a);w(c.find(\\\".fr-buttons\\\")),b.events.$on(c,\\\"mouseenter\\\",\\\"tabIndex\\\",d._tiMouseenter,!0),b.events.$on(c.children().not(\\\".fr-buttons\\\"),\\\"keydown\\\",\\\"[tabIndex]\\\",d._tiKeydown,!0),b.popups.onHide(a,function(){h(c.data(\\\"instance\\\")||b)}),b.popups.onShow(a,function(){F=!1,setTimeout(function(){F=!0},0)})}function y(c){var e=b.popups.get(c);return{_tiKeydown:function(g){var i=e.data(\\\"instance\\\")||b;if(i.events.trigger(\\\"popup.tab\\\",[g])===!1)return!1;var j=g.which,k=e.find(\\\":focus:first\\\");if(a.FE.KEYCODE.TAB==j){g.preventDefault();var l=e.children().not(\\\".fr-buttons\\\"),m=l.find(\\\"input, textarea, button, select\\\").filter(\\\":visible\\\").not(\\\".fr-no-touch input, .fr-no-touch textarea, .fr-no-touch button, .fr-no-touch select, :disabled\\\").toArray(),n=m.indexOf(this)+(g.shiftKey?-1:1);if(0<=n&&n<m.length)return i.events.disableBlur(),a(m[n]).focus(),g.stopPropagation(),!1;var o=e.find(\\\".fr-buttons\\\");if(o.length&&d(o,!!g.shiftKey))return g.stopPropagation(),!1;if(f(l))return g.stopPropagation(),!1}else{if(a.FE.KEYCODE.ENTER!=j)return a.FE.KEYCODE.ESC==j?(g.preventDefault(),g.stopPropagation(),h(i),i.popups.isVisible(c)&&e.find(\\\".fr-back:visible\\\").length?(i.opts.toolbarInline&&(i.events.disableBlur(),i.events.focus()),i.button.exec(e.find(\\\".fr-back:visible:first\\\")),z(e)):i.popups.isVisible(c)&&e.find(\\\".fr-dismiss:visible\\\").length?i.button.exec(e.find(\\\".fr-dismiss:visible:first\\\")):(i.popups.hide(c),i.opts.toolbarInline&&i.toolbar.showInline(null,!0),z(e)),!1):a.FE.KEYCODE.SPACE==j&&(k.is(\\\".fr-submit\\\")||k.is(\\\".fr-dismiss\\\"))?(g.preventDefault(),g.stopPropagation(),i.events.disableBlur(),i.button.exec(k),!0):i.keys.isBrowserAction(g)?void g.stopPropagation():k.is(\\\"input[type=text], textarea\\\")?void g.stopPropagation():a.FE.KEYCODE.SPACE==j&&(k.is(\\\".fr-link-attr\\\")||k.is(\\\"input[type=file]\\\"))?void g.stopPropagation():(g.stopPropagation(),g.preventDefault(),!1);var p=null;e.find(\\\".fr-submit:visible\\\").length>0?p=e.find(\\\".fr-submit:visible:first\\\"):e.find(\\\".fr-dismiss:visible\\\").length&&(p=e.find(\\\".fr-dismiss:visible:first\\\")),p&&(g.preventDefault(),g.stopPropagation(),i.events.disableBlur(),i.button.exec(p))}},_tiMouseenter:function(){var a=e.data(\\\"instance\\\")||b;C(a)}}}function z(a){var b=a.data(\\\"popup-button\\\");b&&setTimeout(function(){c(b),a.data(\\\"popup-button\\\",null)},0)}function A(a){var b=a.data(\\\"modal-button\\\");b&&setTimeout(function(){c(b),a.data(\\\"modal-button\\\",null)},0)}function B(){return null!=b.shared.$f_el}function C(a){var c=b.popups.areVisible(a);c&&c.data(\\\"popup-button\\\",null)}function D(c){var d=navigator.userAgent.indexOf(\\\"Mac OS X\\\")!=-1?c.metaKey:c.ctrlKey,e=c.which;if(e==a.FE.KEYCODE.F10&&!d&&!c.shiftKey&&c.altKey){b.shared.with_kb=!0;var g=b.popups.areVisible(b),h=!1;return g&&(h=f(g.children().not(\\\".fr-buttons\\\"))),h||k(),b.shared.with_kb=!1,c.preventDefault(),c.stopPropagation(),!1}return!0}function E(){b.$wp?b.events.on(\\\"keydown\\\",D,!0):b.events.$on(b.$win,\\\"keydown\\\",D,!0),b.events.on(\\\"mousedown\\\",function(a){C(b),b.shared.$f_el&&(h(b),a.stopPropagation(),b.events.disableBlur(),b.shared.$f_el=null)},!0),b.events.on(\\\"blur\\\",function(){b.shared.$f_el=null,C(b)},!0)}var F=!0;return{_init:E,registerPopup:x,registerToolbar:w,focusToolbarElement:c,focusToolbar:d,focusContent:f,focusPopup:i,focusModal:j,focusEditor:t,focusPopupButton:z,focusModalButton:A,hasFocus:B,exec:v,saveSelection:g,restoreSelection:h}},a.FE.MODULES.format=function(b){function c(a,b){var c=\\\"<\\\"+a;for(var d in b)b.hasOwnProperty(d)&&(c+=\\\" \\\"+d+'=\\\"'+b[d]+'\\\"');return c+=\\\">\\\"}function d(a){return\\\"</\\\"+a+\\\">\\\"}function e(a,b){var c=a;for(var d in b)b.hasOwnProperty(d)&&(c+=\\\"id\\\"==d?\\\"#\\\"+b[d]:\\\"class\\\"==d?\\\".\\\"+b[d]:\\\"[\\\"+d+'=\\\"'+b[d]+'\\\"]');return c}function f(a,b){return!(!a||a.nodeType!=Node.ELEMENT_NODE)&&(a.matches||a.matchesSelector||a.msMatchesSelector||a.mozMatchesSelector||a.webkitMatchesSelector||a.oMatchesSelector).call(a,b)}function g(d,e,f){if(d){if(b.node.isBlock(d))return g(d.firstChild,e,f),!1;for(var h=a(c(e,f)).insertBefore(d),i=d;i&&!a(i).is(\\\".fr-marker\\\")&&0===a(i).find(\\\".fr-marker\\\").length;){var j=i;i=i.nextSibling,h.append(j)}if(i)a(i).find(\\\".fr-marker\\\").length&&g(i.firstChild,e,f);else{for(var k=h.get(0).parentNode;k&&!k.nextSibling&&!b.node.isElement(k);)k=k.parentNode;if(k){var l=k.nextSibling;l&&(b.node.isBlock(l)?g(l.firstChild,e,f):g(l,e,f))}}h.is(\\\":empty\\\")&&h.remove()}}function h(h,i){var j;if(\\\"undefined\\\"==typeof i&&(i={}),i.style&&delete i.style,b.selection.isCollapsed()){b.markers.insert();var k=b.$el.find(\\\".fr-marker\\\");k.replaceWith(c(h,i)+a.FE.INVISIBLE_SPACE+a.FE.MARKERS+d(h)),b.selection.restore()}else{b.selection.save();var l=b.$el.find('.fr-marker[data-type=\\\"true\\\"]').get(0).nextSibling;g(l,h,i);var m;do for(m=b.$el.find(e(h,i)+\\\" > \\\"+e(h,i)),j=0;j<m.length;j++)m[j].outerHTML=m[j].innerHTML;while(m.length);b.el.normalize();var n=b.el.querySelectorAll(\\\".fr-marker\\\");for(j=0;j<n.length;j++){var o=a(n[j]);o.data(\\\"type\\\")===!0?f(o.get(0).nextSibling,e(h,i))&&o.next().prepend(o):f(o.get(0).previousSibling,e(h,i))&&o.prev().append(o)}b.selection.restore()}}function i(a,c,d,g){if(!g){var h=!1;if(a.data(\\\"type\\\")===!0)for(;b.node.isFirstSibling(a.get(0))&&!a.parent().is(b.$el)&&!a.parent().is(\\\"ol\\\")&&!a.parent().is(\\\"ul\\\");)a.parent().before(a),h=!0;else if(a.data(\\\"type\\\")===!1)for(;b.node.isLastSibling(a.get(0))&&!a.parent().is(b.$el)&&!a.parent().is(\\\"ol\\\")&&!a.parent().is(\\\"ul\\\");)a.parent().after(a),h=!0;if(h)return!0}if(a.parents(c).length||\\\"undefined\\\"==typeof c){var i=\\\"\\\",j=\\\"\\\",k=a.parent();if(k.is(b.$el)||b.node.isBlock(k.get(0)))return!1;for(;!b.node.isBlock(k.parent().get(0))&&(\\\"undefined\\\"==typeof c||\\\"undefined\\\"!=typeof c&&!f(k.get(0),e(c,d)));)i+=b.node.closeTagString(k.get(0)),j=b.node.openTagString(k.get(0))+j,k=k.parent();var l=a.get(0).outerHTML;a.replaceWith('<span id=\\\"mark\\\"></span>');var m=k.html().replace(/<span id=\\\"mark\\\"><\\\\/span>/,i+b.node.closeTagString(k.get(0))+j+l+i+b.node.openTagString(k.get(0))+j);return k.replaceWith(b.node.openTagString(k.get(0))+m+b.node.closeTagString(k.get(0))),!0}return!1}function j(c,d,g,h){for(var i=b.node.contents(c.get(0)),k=0;k<i.length;k++){var l=i[k];if(b.node.hasClass(l,\\\"fr-marker\\\"))d=(d+1)%2;else if(d)if(a(l).find(\\\".fr-marker\\\").length>0)d=j(a(l),d,g,h);else{for(var m=a(l).find(g||\\\"*\\\"),n=m.length-1;n>=0;n--){var o=m[n];b.node.isBlock(o)||b.node.isVoid(o)||\\\"undefined\\\"!=typeof g&&!f(o,e(g,h))||(o.outerHTML=o.innerHTML)}\\\"undefined\\\"==typeof g&&l.nodeType==Node.ELEMENT_NODE&&!b.node.isVoid(l)&&!b.node.isBlock(l)||f(l,e(g,h))?a(l).replaceWith(l.innerHTML):\\\"undefined\\\"==typeof g&&l.nodeType==Node.ELEMENT_NODE&&b.node.isBlock(l)&&b.node.clearAttributes(l)}else a(l).find(\\\".fr-marker\\\").length>0&&(d=j(a(l),d,g,h))}return d}function k(c,d){\\\"undefined\\\"==typeof d&&(d={}),d.style&&delete d.style;var e=b.selection.isCollapsed();b.selection.save();for(var f=!0;f;){f=!1;for(var g=b.$el.find(\\\".fr-marker\\\"),h=0;h<g.length;h++)if(i(a(g[h]),c,d,e)){f=!0;break}}j(b.$el,0,c,d),e&&b.$el.find(\\\".fr-marker\\\").before(a.FE.INVISIBLE_SPACE).after(a.FE.INVISIBLE_SPACE),b.html.cleanEmptyTags(),b.el.normalize(),b.selection.restore()}function l(a,b){q(a,b)?k(a,b):h(a,b)}function m(b,c){var d=a(b);d.css(c,\\\"\\\"),\\\"\\\"===d.attr(\\\"style\\\")&&d.replaceWith(d.html())}function n(b,c){return 0===a(b).attr(\\\"style\\\").indexOf(c+\\\":\\\")||a(b).attr(\\\"style\\\").indexOf(\\\";\\\"+c+\\\":\\\")>=0||a(b).attr(\\\"style\\\").indexOf(\\\"; \\\"+c+\\\":\\\")>=0}function o(c,d){var e,f;if(b.selection.isCollapsed()){b.markers.insert(),f=b.$el.find(\\\".fr-marker\\\");var h=f.parent();if(b.node.openTagString(h.get(0))=='<span style=\\\"'+c+\\\": \\\"+h.css(c)+';\\\">'){if(b.node.isEmpty(h.get(0)))h.replaceWith('<span style=\\\"'+c+\\\": \\\"+d+';\\\">'+a.FE.INVISIBLE_SPACE+a.FE.MARKERS+\\\"</span>\\\");else{var j={};j[c]=d,i(f,\\\"span\\\",j,!0),f=b.$el.find(\\\".fr-marker\\\"),f.replaceWith('<span style=\\\"'+c+\\\": \\\"+d+';\\\">'+a.FE.INVISIBLE_SPACE+a.FE.MARKERS+\\\"</span>\\\")}b.html.cleanEmptyTags()}else b.node.isEmpty(h.get(0))&&h.is(\\\"span\\\")?(f.replaceWith(a.FE.MARKERS),h.css(c,d)):f.replaceWith('<span style=\\\"'+c+\\\": \\\"+d+';\\\">'+a.FE.INVISIBLE_SPACE+a.FE.MARKERS+\\\"</span>\\\");b.selection.restore()}else{if(b.selection.save(),null==d||\\\"color\\\"==c&&b.$el.find(\\\".fr-marker\\\").parents(\\\"u, a\\\").length>0){var k=b.$el.find(\\\".fr-marker\\\");for(e=0;e<k.length;e++)if(f=a(k[e]),f.data(\\\"type\\\")===!0)for(;b.node.isFirstSibling(f.get(0))&&!f.parent().is(b.$el)&&!b.node.isElement(f.parent().get(0))&&!b.node.isBlock(f.parent().get(0));)f.parent().before(f);else for(;b.node.isLastSibling(f.get(0))&&!f.parent().is(b.$el)&&!b.node.isElement(f.parent().get(0))&&!b.node.isBlock(f.parent().get(0));)f.parent().after(f)}var l=b.$el.find('.fr-marker[data-type=\\\"true\\\"]').get(0).nextSibling,o={class:\\\"fr-unprocessed\\\"};for(d&&(o.style=c+\\\": \\\"+d+\\\";\\\"),g(l,\\\"span\\\",o),b.$el.find(\\\".fr-marker + .fr-unprocessed\\\").each(function(){a(this).prepend(a(this).prev())}),b.$el.find(\\\".fr-unprocessed + .fr-marker\\\").each(function(){a(this).prev().append(this)});b.$el.find(\\\"span.fr-unprocessed\\\").length>0;){var p=b.$el.find(\\\"span.fr-unprocessed:first\\\").removeClass(\\\"fr-unprocessed\\\");if(p.parent().get(0).normalize(),p.parent().is(\\\"span\\\")&&1==p.parent().get(0).childNodes.length){p.parent().css(c,d);var q=p;p=p.parent(),q.replaceWith(q.html())}var r=p.find(\\\"span\\\");for(e=r.length-1;e>=0;e--)m(r[e],c);var s=p.parentsUntil(b.$el,\\\"span[style]\\\"),t=[];for(e=s.length-1;e>=0;e--)n(s[e],c)||t.push(s[e]);if(s=s.not(t),s.length){var u=\\\"\\\",v=\\\"\\\",w=\\\"\\\",x=\\\"\\\",y=p.get(0);do y=y.parentNode,a(y).addClass(\\\"fr-split\\\"),u+=b.node.closeTagString(y),v=b.node.openTagString(a(y).clone().addClass(\\\"fr-split\\\").get(0))+v,s.get(0)!=y&&(w+=b.node.closeTagString(y),x=b.node.openTagString(a(y).clone().addClass(\\\"fr-split\\\").get(0))+x);while(s.get(0)!=y);var z=u+b.node.openTagString(a(s.get(0)).clone().css(c,d||\\\"\\\").get(0))+x+p.css(c,\\\"\\\").get(0).outerHTML+w+\\\"</span>\\\"+v;p.replaceWith('<span id=\\\"fr-break\\\"></span>');var A=s.get(0).outerHTML;a(s.get(0)).replaceWith(A.replace(/<span id=\\\"fr-break\\\"><\\\\/span>/g,z))}}for(;b.$el.find(\\\".fr-split:empty\\\").length>0;)b.$el.find(\\\".fr-split:empty\\\").remove();b.$el.find(\\\".fr-split\\\").removeClass(\\\"fr-split\\\"),b.$el.find('span[style=\\\"\\\"]').removeAttr(\\\"style\\\"),b.$el.find('span[class=\\\"\\\"]').removeAttr(\\\"class\\\"),b.html.cleanEmptyTags(),a(b.$el.find(\\\"span\\\").get().reverse()).each(function(){this.attributes&&0!==this.attributes.length||a(this).replaceWith(this.innerHTML)}),b.el.normalize();var B=b.$el.find(\\\"span[style] + span[style]\\\");for(e=0;e<B.length;e++){var C=a(B[e]),D=a(B[e]).prev();C.get(0).previousSibling==D.get(0)&&b.node.openTagString(C.get(0))==b.node.openTagString(D.get(0))&&(C.prepend(D.html()),D.remove())}b.$el.find(\\\"span[style] span[style]\\\").each(function(){if(a(this).attr(\\\"style\\\").indexOf(\\\"font-size\\\")>=0){var b=a(this).parents(\\\"span[style]\\\");b.attr(\\\"style\\\").indexOf(\\\"background-color\\\")>=0&&(a(this).attr(\\\"style\\\",a(this).attr(\\\"style\\\")+\\\";\\\"+b.attr(\\\"style\\\")),i(a(this),\\\"span[style]\\\",{},!1))}}),b.el.normalize(),b.selection.restore()}}function p(a){o(a,null)}function q(a,c){\\\"undefined\\\"==typeof c&&(c={}),c.style&&delete c.style;var d=b.selection.ranges(0),g=d.startContainer;g.nodeType==Node.ELEMENT_NODE&&g.childNodes.length>0&&g.childNodes[d.startOffset]&&(g=g.childNodes[d.startOffset]);for(var h=g;h&&h.nodeType==Node.ELEMENT_NODE&&!f(h,e(a,c));)h=h.firstChild;if(h&&h.nodeType==Node.ELEMENT_NODE&&f(h,e(a,c)))return!0;var i=g;for(i&&i.nodeType!=Node.ELEMENT_NODE&&(i=i.parentNode);i&&i.nodeType==Node.ELEMENT_NODE&&i!=b.el&&!f(i,e(a,c));)i=i.parentNode;return!(!i||i.nodeType!=Node.ELEMENT_NODE||i==b.el||!f(i,e(a,c)))}return{is:q,toggle:l,apply:h,remove:k,applyStyle:o,removeStyle:p}},a.FE.COMMANDS={bold:{title:\\\"Bold\\\",toggle:!0,refresh:function(a){var b=this.format.is(\\\"strong\\\");a.toggleClass(\\\"fr-active\\\",b).attr(\\\"aria-pressed\\\",b)}},italic:{title:\\\"Italic\\\",toggle:!0,refresh:function(a){var b=this.format.is(\\\"em\\\");a.toggleClass(\\\"fr-active\\\",b).attr(\\\"aria-pressed\\\",b)}},underline:{title:\\\"Underline\\\",toggle:!0,refresh:function(a){var b=this.format.is(\\\"u\\\");a.toggleClass(\\\"fr-active\\\",b).attr(\\\"aria-pressed\\\",b)}},strikeThrough:{title:\\\"Strikethrough\\\",toggle:!0,refresh:function(a){var b=this.format.is(\\\"s\\\");a.toggleClass(\\\"fr-active\\\",b).attr(\\\"aria-pressed\\\",b)}},subscript:{title:\\\"Subscript\\\",toggle:!0,refresh:function(a){var b=this.format.is(\\\"sub\\\");a.toggleClass(\\\"fr-active\\\",b).attr(\\\"aria-pressed\\\",b)}},superscript:{title:\\\"Superscript\\\",toggle:!0,refresh:function(a){var b=this.format.is(\\\"sup\\\");a.toggleClass(\\\"fr-active\\\",b).attr(\\\"aria-pressed\\\",b)}},outdent:{title:\\\"Decrease Indent\\\"},indent:{title:\\\"Increase Indent\\\"},undo:{title:\\\"Undo\\\",undo:!1,forcedRefresh:!0,disabled:!0},redo:{title:\\\"Redo\\\",undo:!1,forcedRefresh:!0,disabled:!0},insertHR:{title:\\\"Insert Horizontal Line\\\"},clearFormatting:{title:\\\"Clear Formatting\\\"},selectAll:{title:\\\"Select All\\\",undo:!1}},a.FE.RegisterCommand=function(b,c){a.FE.COMMANDS[b]=c},a.FE.MODULES.commands=function(b){function c(a){return b.html.defaultTag()&&(a=\\\"<\\\"+b.html.defaultTag()+\\\">\\\"+a+\\\"</\\\"+b.html.defaultTag()+\\\">\\\"),a}function d(c,d){if(b.events.trigger(\\\"commands.before\\\",a.merge([c],d||[]))!==!1){var e=a.FE.COMMANDS[c]&&a.FE.COMMANDS[c].callback||i[c],f=!0,g=!1;a.FE.COMMANDS[c]&&(\\\"undefined\\\"!=typeof a.FE.COMMANDS[c].focus&&(f=a.FE.COMMANDS[c].focus),\\\"undefined\\\"!=typeof a.FE.COMMANDS[c].accessibilityFocus&&(g=a.FE.COMMANDS[c].accessibilityFocus)),(!b.core.hasFocus()&&f&&!b.popups.areVisible()||!b.core.hasFocus()&&g&&b.accessibility.hasFocus())&&b.events.focus(!0),a.FE.COMMANDS[c]&&a.FE.COMMANDS[c].undo!==!1&&(b.$el.find(\\\".fr-marker\\\").length&&(b.events.disableBlur(),b.selection.restore()),b.undo.saveStep()),e&&e.apply(b,a.merge([c],d||[])),b.events.trigger(\\\"commands.after\\\",a.merge([c],d||[])),a.FE.COMMANDS[c]&&a.FE.COMMANDS[c].undo!==!1&&b.undo.saveStep()}}function e(a,c){b.format.toggle(c)}function f(c){b.selection.save(),b.html.wrap(!0,!0,!0,!0),b.selection.restore();for(var d=b.selection.blocks(),e=0;e<d.length;e++)if(\\\"LI\\\"!=d[e].tagName&&\\\"LI\\\"!=d[e].parentNode.tagName){var f=a(d[e]),g=\\\"rtl\\\"==b.opts.direction||\\\"rtl\\\"==f.css(\\\"direction\\\")?\\\"margin-right\\\":\\\"margin-left\\\",h=b.helpers.getPX(f.css(g));f.css(g,Math.max(h+20*c,0)||\\\"\\\"),f.removeClass(\\\"fr-temp-div\\\")}b.selection.save(),b.html.unwrap(),b.selection.restore()}function g(a){return function(){d(a)}}function h(){b.events.on(\\\"keydown\\\",function(a){var c=b.selection.element();if(c&&\\\"HR\\\"==c.tagName&&!b.keys.isArrow(a.which))return a.preventDefault(),!1}),b.events.on(\\\"keyup\\\",function(c){var d=b.selection.element();if(d&&\\\"HR\\\"==d.tagName)if(c.which==a.FE.KEYCODE.ARROW_LEFT||c.which==a.FE.KEYCODE.ARROW_UP){if(d.previousSibling)return b.node.isBlock(d.previousSibling)?b.selection.setAtEnd(d.previousSibling):a(d).before(a.FE.MARKERS),b.selection.restore(),!1}else if((c.which==a.FE.KEYCODE.ARROW_RIGHT||c.which==a.FE.KEYCODE.ARROW_DOWN)&&d.nextSibling)return b.node.isBlock(d.nextSibling)?b.selection.setAtStart(d.nextSibling):a(d).after(a.FE.MARKERS),b.selection.restore(),!1}),b.events.on(\\\"mousedown\\\",function(a){if(a.target&&\\\"HR\\\"==a.target.tagName)return a.preventDefault(),a.stopPropagation(),!1}),b.events.on(\\\"mouseup\\\",function(){var c=b.selection.element(),d=b.selection.endElement();c==d&&c&&\\\"HR\\\"==c.tagName&&(c.nextSibling&&(b.node.isBlock(c.nextSibling)?b.selection.setAtStart(c.nextSibling):a(c).after(a.FE.MARKERS)),b.selection.restore())})}var i={bold:function(){e(\\\"bold\\\",\\\"strong\\\")},subscript:function(){e(\\\"subscript\\\",\\\"sub\\\")},superscript:function(){e(\\\"superscript\\\",\\\"sup\\\")},italic:function(){e(\\\"italic\\\",\\\"em\\\")},strikeThrough:function(){e(\\\"strikeThrough\\\",\\\"s\\\")},underline:function(){e(\\\"underline\\\",\\\"u\\\")},undo:function(){b.undo.run()},redo:function(){b.undo.redo()},indent:function(){f(1)},outdent:function(){f(-1)},show:function(){b.opts.toolbarInline&&b.toolbar.showInline(null,!0)},insertHR:function(){b.selection.remove();var d=\\\"\\\";b.core.isEmpty()&&(d=\\\"<br>\\\",d=c(d)),b.html.insert('<hr id=\\\"fr-just\\\">'+d);var e=b.$el.find(\\\"hr#fr-just\\\");e.removeAttr(\\\"id\\\");var f;e.prev().is(\\\"hr\\\")?f=b.selection.setAfter(e.get(0),!1):e.next().is(\\\"hr\\\")?f=b.selection.setBefore(e.get(0),!1):b.selection.setAfter(e.get(0),!1)||b.selection.setBefore(e.get(0),!1),f||\\\"undefined\\\"==typeof f||(d=a.FE.MARKERS+\\\"<br>\\\",d=c(d),e.after(d)),b.selection.restore()},clearFormatting:function(){b.format.remove()},selectAll:function(){b.doc.execCommand(\\\"selectAll\\\",!1,!1)}},j={};for(var k in i)i.hasOwnProperty(k)&&(j[k]=g(k));return a.extend(j,{exec:d,_init:h})},a.FE.MODULES.data=function(a){function b(a){return a}function c(a){if(!a)return a;for(var c=\\\"\\\",f=b(\\\"charCodeAt\\\"),g=b(\\\"fromCharCode\\\"),h=l.indexOf(a[0]),i=1;i<a.length-2;i++){for(var j=d(++h),k=a[f](i),m=\\\"\\\";/[0-9-]/.test(a[i+1]);)m+=a[++i];\\nm=parseInt(m,10)||0,k=e(k,j,m),k^=h-1&31,c+=String[g](k)}return c}function d(a){for(var b=a.toString(),c=0,d=0;d<b.length;d++)c+=parseInt(b.charAt(d),10);return c>10?c%9+1:c}function e(a,b,c){for(var d=Math.abs(c);d-- >0;)a-=b;return c<0&&(a+=123),a}function f(a){return!(!a||\\\"none\\\"!=a.css(\\\"display\\\")||(a.remove(),0))}function g(){return f(j)||f(k)}function h(){return!!a.$box&&(a.$box.append(n(b(n(\\\"noLD2laB-7NB1C1ebcvH-9SB3a1C6QC2D4A-9d1E2B2B4xgAE4B2G2I1C3A3B2qMF1DE1fkxfcC-11C-9g1G2E4XC9a1E5A3G-10mvrioCC3AA1KA1qJ-7NB2MA6sxeqVA6TD6e2D4B-9rYA2a1A4bCD3vwC-7EC10D3E2lNC1KD1QB9SB6UE5TE4YF3YA5c1A3d1B3kGE2gFA5A2D2ch1KI1IB1thyH5wvVC11UB6c1F4wwwXA7gmnfB2jgB1A7nd1e1IC2NG4H1A9bjvnbC-8PG3mlazD4dH-9HI2qAA2jGC2IA1dajajFD5SG4J4c1qttyB-9wg1B2b2A6b1C3EG3B2I2rCD4E1B1LG1oaMA3RE7abC-8C-7aVA4C5B5F-11e1D3I3a5A8hmmnogH2IB5A2nhkgiA4TH4VC7yxdblH-8YC6D6C4xC3yqJJ2C-21spB-11fMF1KF1IC2USC4PG4TE3RD6ZF5XE3UE3uefaFE4D2G2AE1HA2JD1zzzQE3SD9vgqF4ua3B13XA4C5gd1E3E2A14ridsldcCA7MC5ghwE-11ZH5f1D3a1D8bwxmkzi1A7IB3KvpB-8rwMD3IE1GG-10bgqwxewvWE4H3VbD-16qC-11qc1E2TwEA6A3aCE4A1A4lOD3JC1iVA3RA13c2D8olqf1G3A32B17==\\\")))),j=a.$box.find(\\\"> div:last\\\"),k=j.find(\\\"> a\\\"),void(\\\"rtl\\\"==a.opts.direction&&j.css(\\\"left\\\",\\\"auto\\\").css(\\\"right\\\",0)))}function i(){var c=localStorage&&localStorage.FEK||a.opts.key||[\\\"\\\"];\\\"string\\\"==typeof c&&(c=[c]),a.ul=!0;for(var d=0;d<c.length;d++){var e=n(c[d])||\\\"\\\";if(!(e!==n(b(n(\\\"mcVRDoB1BGILD7YFe1BTXBA7B6==\\\")))&&e.indexOf(m,e.length-m.length)<0&&[n(\\\"9qqG-7amjlwq==\\\"),n(\\\"KA3B3C2A6D1D5H5H1A3==\\\"),n(\\\"QzbzvxyB2yA-9m==\\\"),n(\\\"naamngiA3dA-16xtE-11C-9B1H-8sc==\\\")].indexOf(m)<0)){a.ul=!1;break}}a.ul===!0&&h(),a.events.on(\\\"contentChanged\\\",function(){a.ul===!0&&g()&&h()}),a.events.on(\\\"destroy\\\",function(){j&&j.length&&j.remove()},!0)}var j,k,l=\\\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\\\",m=function(){for(var a=0,b=document.domain,c=b.split(\\\".\\\"),d=\\\"_gd\\\"+(new Date).getTime();a<c.length-1&&document.cookie.indexOf(d+\\\"=\\\"+d)==-1;)b=c.slice(-1-++a).join(\\\".\\\"),document.cookie=d+\\\"=\\\"+d+\\\";domain=\\\"+b+\\\";\\\";return document.cookie=d+\\\"=;expires=Thu, 01 Jan 1970 00:00:01 GMT;domain=\\\"+b+\\\";\\\",(b||\\\"\\\").replace(/(^\\\\.*)|(\\\\.*$)/g,\\\"\\\")}(),n=b(c);return{_init:i}},a.extend(a.FE.DEFAULTS,{pastePlain:!1,pasteDeniedTags:[\\\"colgroup\\\",\\\"col\\\"],pasteDeniedAttrs:[\\\"class\\\",\\\"id\\\",\\\"style\\\"],pasteAllowedStyleProps:[],pasteAllowLocalImages:!1}),a.FE.MODULES.paste=function(b){function c(a,c){b.win.localStorage.setItem(\\\"fr-copied-html\\\",a),b.win.localStorage.setItem(\\\"fr-copied-text\\\",c)}function d(d){var e=b.html.getSelected();c(e,a(\\\"<div>\\\").html(e).text()),\\\"cut\\\"==d.type&&(b.undo.saveStep(),setTimeout(function(){b.selection.save(),b.html.wrap(),b.selection.restore(),b.events.focus(),b.undo.saveStep()},0))}function e(a){if(s)return!1;if(a.originalEvent&&(a=a.originalEvent),b.events.trigger(\\\"paste.before\\\",[a])===!1)return a.preventDefault(),!1;if(o=b.$win.scrollTop(),a&&a.clipboardData&&a.clipboardData.getData){var c=\\\"\\\",d=a.clipboardData.types;if(b.helpers.isArray(d))for(var e=0;e<d.length;e++)c+=d[e]+\\\";\\\";else c=d;if(p=\\\"\\\",q=a.clipboardData.getData(\\\"text/rtf\\\"),/text\\\\/html/.test(c)?p=a.clipboardData.getData(\\\"text/html\\\"):/text\\\\/rtf/.test(c)&&b.browser.safari?p=q:/text\\\\/plain/.test(c)&&!this.browser.mozilla&&(p=b.html.escapeEntities(a.clipboardData.getData(\\\"text/plain\\\")).replace(/\\\\n/g,\\\"<br>\\\")),\\\"\\\"!==p)return j(),a.preventDefault&&(a.stopPropagation(),a.preventDefault()),!1;p=null}f()}function f(){b.selection.save(),b.events.disableBlur(),p=null,r?r.html(\\\"\\\"):(r=a('<div contenteditable=\\\"true\\\" style=\\\"position: fixed; top: 0; left: -9999px; height: 100%; width: 0; word-break: break-all; overflow:hidden; z-index: 9999; line-height: 140%;\\\" tabIndex=\\\"-1\\\"></div>'),b.$box.after(r),b.events.on(\\\"destroy\\\",function(){r.remove()})),r.focus(),b.win.setTimeout(j,1)}function g(a){var c;a=a.replace(/<p(.*?)class=\\\"?'?MsoListParagraph\\\"?'? ([\\\\s\\\\S]*?)>([\\\\s\\\\S]*?)<\\\\/p>/gi,\\\"<ul><li>$3</li></ul>\\\"),a=a.replace(/<p(.*?)class=\\\"?'?NumberedText\\\"?'? ([\\\\s\\\\S]*?)>([\\\\s\\\\S]*?)<\\\\/p>/gi,\\\"<ol><li>$3</li></ol>\\\"),a=a.replace(/<p(.*?)class=\\\"?'?MsoListParagraphCxSpFirst\\\"?'?([\\\\s\\\\S]*?)(level\\\\d)?([\\\\s\\\\S]*?)>([\\\\s\\\\S]*?)<\\\\/p>/gi,\\\"<ul><li$3>$5</li>\\\"),a=a.replace(/<p(.*?)class=\\\"?'?NumberedTextCxSpFirst\\\"?'?([\\\\s\\\\S]*?)(level\\\\d)?([\\\\s\\\\S]*?)>([\\\\s\\\\S]*?)<\\\\/p>/gi,\\\"<ol><li$3>$5</li>\\\"),a=a.replace(/<p(.*?)class=\\\"?'?MsoListParagraphCxSpMiddle\\\"?'?([\\\\s\\\\S]*?)(level\\\\d)?([\\\\s\\\\S]*?)>([\\\\s\\\\S]*?)<\\\\/p>/gi,\\\"<li$3>$5</li>\\\"),a=a.replace(/<p(.*?)class=\\\"?'?NumberedTextCxSpMiddle\\\"?'?([\\\\s\\\\S]*?)(level\\\\d)?([\\\\s\\\\S]*?)>([\\\\s\\\\S]*?)<\\\\/p>/gi,\\\"<li$3>$5</li>\\\"),a=a.replace(/<p(.*?)class=\\\"?'?MsoListBullet\\\"?'?([\\\\s\\\\S]*?)(level\\\\d)?([\\\\s\\\\S]*?)>([\\\\s\\\\S]*?)<\\\\/p>/gi,\\\"<li$3>$5</li>\\\"),a=a.replace(/<p(.*?)class=\\\"?'?MsoListParagraphCxSpLast\\\"?'?([\\\\s\\\\S]*?)(level\\\\d)?([\\\\s\\\\S]*?)>([\\\\s\\\\S]*?)<\\\\/p>/gi,\\\"<li$3>$5</li></ul>\\\"),a=a.replace(/<p(.*?)class=\\\"?'?NumberedTextCxSpLast\\\"?'?([\\\\s\\\\S]*?)(level\\\\d)?([\\\\s\\\\S]*?)>([\\\\s\\\\S]*?)<\\\\/p>/gi,\\\"<li$3>$5</li></ol>\\\"),a=a.replace(/<span([^<]*?)style=\\\"?'?mso-list:Ignore\\\"?'?([\\\\s\\\\S]*?)>([\\\\s\\\\S]*?)<span/gi,\\\"<span><span\\\"),a=a.replace(/<!--\\\\[if \\\\!supportLists\\\\]-->([\\\\s\\\\S]*?)<!--\\\\[endif\\\\]-->/gi,\\\"\\\"),a=a.replace(/<!\\\\[if \\\\!supportLists\\\\]>([\\\\s\\\\S]*?)<!\\\\[endif\\\\]>/gi,\\\"\\\"),a=a.replace(/(\\\\n|\\\\r| class=(\\\")?Mso[a-zA-Z0-9]+(\\\")?)/gi,\\\" \\\"),a=a.replace(/<!--[\\\\s\\\\S]*?-->/gi,\\\"\\\"),a=a.replace(/<(\\\\/)*(meta|link|span|\\\\\\\\?xml:|st1:|o:|font)(.*?)>/gi,\\\"\\\");var d=[\\\"style\\\",\\\"script\\\",\\\"applet\\\",\\\"embed\\\",\\\"noframes\\\",\\\"noscript\\\"];for(c=0;c<d.length;c++){var e=new RegExp(\\\"<\\\"+d[c]+\\\".*?\\\"+d[c]+\\\"(.*?)>\\\",\\\"gi\\\");a=a.replace(e,\\\"\\\")}a=a.replace(/&nbsp;/gi,\\\" \\\"),a=a.replace(/<td([^>]*)><\\\\/td>/g,\\\"<td$1><br></td>\\\"),a=a.replace(/<th([^>]*)><\\\\/th>/g,\\\"<th$1><br></th>\\\");var f;do f=a,a=a.replace(/<[^\\\\/>][^>]*><\\\\/[^>]+>/gi,\\\"\\\");while(a!=f);a=a.replace(/<lilevel([^1])([^>]*)>/gi,'<li data-indent=\\\"true\\\"$2>'),a=a.replace(/<lilevel1([^>]*)>/gi,\\\"<li$1>\\\"),a=b.clean.html(a,b.opts.pasteDeniedTags,b.opts.pasteDeniedAttrs),a=a.replace(/<a>(.[^<]+)<\\\\/a>/gi,\\\"$1\\\"),a=a.replace(/<br> */g,\\\"<br>\\\");var g=b.o_doc.createElement(\\\"div\\\");g.innerHTML=a;var h=g.querySelectorAll(\\\"li[data-indent]\\\");for(c=0;c<h.length;c++){var i=h[c],j=i.previousElementSibling;if(j&&\\\"LI\\\"==j.tagName){var k=j.querySelector(\\\":scope > ul, :scope > ol\\\");k||(k=document.createElement(\\\"ul\\\"),j.appendChild(k)),k.appendChild(i)}else i.removeAttribute(\\\"data-indent\\\")}return b.html.cleanBlankSpaces(g),a=g.innerHTML}function h(a){var c,d=null,e=b.doc.createElement(\\\"div\\\");e.innerHTML=a;var f=e.querySelectorAll(\\\"p, div, h1, h2, h3, h4, h5, h6, pre, blockquote\\\");for(c=0;c<f.length;c++)d=f[c],d.outerHTML=\\\"<\\\"+(b.html.defaultTag()||\\\"DIV\\\")+\\\">\\\"+d.innerHTML+\\\"</\\\"+(b.html.defaultTag()||\\\"DIV\\\")+\\\">\\\";for(f=e.querySelectorAll(\\\"*:not(\\\"+\\\"p, div, h1, h2, h3, h4, h5, h6, pre, blockquote, ul, ol, li, table, tbody, thead, tr, td, br, img\\\".split(\\\",\\\").join(\\\"):not(\\\")+\\\")\\\"),c=f.length-1;c>=0;c--)d=f[c],d.outerHTML=d.innerHTML;var g=function(a){for(var c=b.node.contents(a),d=0;d<c.length;d++)c[d].nodeType!=Node.TEXT_NODE&&c[d].nodeType!=Node.ELEMENT_NODE?c[d].parentNode.removeChild(c[d]):g(c[d])};return g(e),e.innerHTML}function i(a){return a.match(/(class=\\\\\\\"?Mso|class=\\\\'?Mso|style=\\\\\\\"[^\\\\\\\"]*\\\\bmso\\\\-|style=\\\\'[^\\\\']*\\\\bmso\\\\-|w:WordDocument)/gi)}function j(){var c,d=null,e=null;b.keys.forceUndo();var f=b.snapshot.get();null===p&&(p=r.get(0).innerHTML,b.selection.restore(),b.events.enableBlur());var j=i(p),l=b.events.chainTrigger(\\\"paste.beforeCleanup\\\",p);if(l&&\\\"string\\\"==typeof l&&(p=l),p.toLowerCase().indexOf(\\\"<body\\\")>=0&&(p=p.replace(/[.\\\\s\\\\S\\\\w\\\\W<>]*<body[^>]*>[\\\\s]*([.\\\\s\\\\S\\\\w\\\\W<>]*)[\\\\s]*<\\\\/body>[.\\\\s\\\\S\\\\w\\\\W<>]*/gi,\\\"$1\\\"),p=p.replace(/([^>])\\\\n([^<])/g,\\\"$1 $2\\\")),!j){var n=b.opts.htmlAllowedStyleProps;b.opts.htmlAllowedStyleProps=b.opts.pasteAllowedStyleProps,b.opts.htmlAllowComments=!1,p=b.clean.html(p,b.opts.pasteDeniedTags,b.opts.pasteDeniedAttrs),b.opts.htmlAllowedStyleProps=n,b.opts.htmlAllowComments=!0,p=m(p),p=p.replace(/\\\\r|\\\\n|\\\\t/g,\\\"\\\");var o=b.doc.createElement(\\\"div\\\");o.innerHTML=p;var q=b.win.localStorage.getItem(\\\"fr-copied-html\\\"),s=b.win.localStorage.getItem(\\\"fr-copied-text\\\");s&&o.textContent.replace(/(\\\\u00A0)/gi,\\\" \\\").replace(/\\\\r|\\\\n/gi,\\\"\\\")==s.replace(/(\\\\u00A0)/gi,\\\" \\\").replace(/(\\\\r|\\\\n)+([ ]+[\\\\r\\\\n]+)*/gi,\\\" \\\")&&(p=q),p=p.replace(/^ */g,\\\"\\\").replace(/ *$/g,\\\"\\\")}var t=!1;if(p.indexOf('id=\\\"docs-internal-guid')>=0&&(p=p.replace(/^.* id=\\\"docs-internal-guid[^>]*>(.*)<\\\\/b>.*$/,\\\"$1\\\"),t=!0),j&&!b.wordPaste&&(p=p.replace(/^\\\\n*/g,\\\"\\\").replace(/^ /g,\\\"\\\"),0===p.indexOf(\\\"<colgroup>\\\")&&(p=\\\"<table>\\\"+p+\\\"</table>\\\"),p=g(p),p=m(p)),b.opts.pastePlain&&(p=h(p)),l=b.events.chainTrigger(\\\"paste.afterCleanup\\\",p),\\\"string\\\"==typeof l&&(p=l),\\\"\\\"!==p){var u=b.o_doc.createElement(\\\"div\\\");u.innerHTML=p,b.spaces.normalize(u);var v=u.getElementsByTagName(\\\"span\\\");for(c=v.length-1;c>=0;c--){var w=v[c];0===w.attributes.length&&(w.outerHTML=w.innerHTML)}var x=u.children;if(1==x.length&&[\\\"OL\\\",\\\"UL\\\"].indexOf(x[0].tagName)>=0&&(x[0].outerHTML=x[0].innerHTML),!t){var y=u.getElementsByTagName(\\\"br\\\");for(c=y.length-1;c>=0;c--){var z=y[c];b.node.isBlock(z.previousSibling)&&z.parentNode.removeChild(z)}}if(b.opts.enter==a.FE.ENTER_BR)for(d=u.querySelectorAll(\\\"p, div\\\"),c=d.length-1;c>=0;c--)e=d[c],e.outerHTML=e.innerHTML+(e.nextSibling&&!b.node.isEmpty(e)?\\\"<br>\\\":\\\"\\\");else if(b.opts.enter==a.FE.ENTER_DIV)for(d=u.getElementsByTagName(\\\"p\\\"),c=d.length-1;c>=0;c--)e=d[c],e.outerHTML=\\\"<div>\\\"+e.innerHTML+\\\"</div>\\\";p=u.innerHTML,b.html.insert(p,!0)}k(),b.undo.saveStep(f),b.undo.saveStep()}function k(){b.events.trigger(\\\"paste.after\\\")}function l(){return q}function m(a){var c,d=b.o_doc.createElement(\\\"div\\\");d.innerHTML=a;for(var e=d.querySelectorAll(\\\"*:empty:not(br):not(img):not(td):not(th)\\\");e.length;){for(c=0;c<e.length;c++)e[c].parentNode.removeChild(e[c]);e=d.querySelectorAll(\\\"*:empty:not(br):not(img):not(td):not(th)\\\")}for(var f=d.querySelectorAll(\\\":scope > div:not([style]), td > div:not([style]), th > div:not([style]), li > div:not([style])\\\");f.length;){var g=f[f.length-1];if(b.html.defaultTag()&&\\\"div\\\"!=b.html.defaultTag())g.querySelector(b.html.blockTagsQuery())?g.outerHTML=g.innerHTML:g.outerHTML=\\\"<\\\"+b.html.defaultTag()+\\\">\\\"+g.innerHTML+\\\"</\\\"+b.html.defaultTag()+\\\">\\\";else{var h=g.querySelectorAll(\\\"*\\\");h.length&&\\\"BR\\\"===h[h.length-1].tagName?g.outerHTML=g.innerHTML:g.outerHTML=g.innerHTML+\\\"<br>\\\"}f=d.querySelectorAll(\\\":scope > div:not([style]), td > div:not([style]), th > div:not([style]), li > div:not([style])\\\")}for(f=d.querySelectorAll(\\\"div:not([style])\\\");f.length;){for(c=0;c<f.length;c++){var i=f[c],j=i.innerHTML.replace(/\\\\u0009/gi,\\\"\\\").trim();i.outerHTML=j}f=d.querySelectorAll(\\\"div:not([style])\\\")}return d.innerHTML}function n(){b.events.on(\\\"copy\\\",d),b.events.on(\\\"cut\\\",d),b.events.on(\\\"paste\\\",e),b.browser.msie&&b.browser.version<11&&(b.events.on(\\\"mouseup\\\",function(a){2==a.button&&(setTimeout(function(){s=!1},50),s=!0)},!0),b.events.on(\\\"beforepaste\\\",e))}var o,p,q,r,s=!1;return{_init:n,removeEmptyTags:m,getRtfClipboard:l,isWord:i,saveCopiedText:c}},a.extend(a.FE.DEFAULTS,{shortcutsEnabled:[\\\"show\\\",\\\"bold\\\",\\\"italic\\\",\\\"underline\\\",\\\"strikeThrough\\\",\\\"indent\\\",\\\"outdent\\\",\\\"undo\\\",\\\"redo\\\"],shortcutsHint:!0}),a.FE.SHORTCUTS_MAP={},a.FE.RegisterShortcut=function(b,c,d,e,f,g){a.FE.SHORTCUTS_MAP[(f?\\\"^\\\":\\\"\\\")+(g?\\\"@\\\":\\\"\\\")+b]={cmd:c,val:d,letter:e,shift:f,option:g},a.FE.DEFAULTS.shortcutsEnabled.push(c)},a.FE.RegisterShortcut(a.FE.KEYCODE.E,\\\"show\\\",null,\\\"E\\\",!1,!1),a.FE.RegisterShortcut(a.FE.KEYCODE.B,\\\"bold\\\",null,\\\"B\\\",!1,!1),a.FE.RegisterShortcut(a.FE.KEYCODE.I,\\\"italic\\\",null,\\\"I\\\",!1,!1),a.FE.RegisterShortcut(a.FE.KEYCODE.U,\\\"underline\\\",null,\\\"U\\\",!1,!1),a.FE.RegisterShortcut(a.FE.KEYCODE.S,\\\"strikeThrough\\\",null,\\\"S\\\",!1,!1),a.FE.RegisterShortcut(a.FE.KEYCODE.CLOSE_SQUARE_BRACKET,\\\"indent\\\",null,\\\"]\\\",!1,!1),a.FE.RegisterShortcut(a.FE.KEYCODE.OPEN_SQUARE_BRACKET,\\\"outdent\\\",null,\\\"[\\\",!1,!1),a.FE.RegisterShortcut(a.FE.KEYCODE.Z,\\\"undo\\\",null,\\\"Z\\\",!1,!1),a.FE.RegisterShortcut(a.FE.KEYCODE.Z,\\\"redo\\\",null,\\\"Z\\\",!0,!1),a.FE.MODULES.shortcuts=function(b){function c(c){if(!b.opts.shortcutsHint)return null;if(!f){f={};for(var d in a.FE.SHORTCUTS_MAP)a.FE.SHORTCUTS_MAP.hasOwnProperty(d)&&b.opts.shortcutsEnabled.indexOf(a.FE.SHORTCUTS_MAP[d].cmd)>=0&&(f[a.FE.SHORTCUTS_MAP[d].cmd+\\\".\\\"+(a.FE.SHORTCUTS_MAP[d].val||\\\"\\\")]={shift:a.FE.SHORTCUTS_MAP[d].shift,option:a.FE.SHORTCUTS_MAP[d].option,letter:a.FE.SHORTCUTS_MAP[d].letter})}var e=f[c];return e?(b.helpers.isMac()?String.fromCharCode(8984):\\\"Ctrl+\\\")+(e.shift?b.helpers.isMac()?String.fromCharCode(8679):\\\"Shift+\\\":\\\"\\\")+(e.option?b.helpers.isMac()?String.fromCharCode(8997):\\\"Alt+\\\":\\\"\\\")+e.letter:null}function d(c){if(!b.core.hasFocus())return!0;var d=c.which,e=navigator.userAgent.indexOf(\\\"Mac OS X\\\")!=-1?c.metaKey:c.ctrlKey;if(\\\"keyup\\\"==c.type&&g&&d!=a.FE.KEYCODE.META)return g=!1,!1;\\\"keydown\\\"==c.type&&(g=!1);var f=(c.shiftKey?\\\"^\\\":\\\"\\\")+(c.altKey?\\\"@\\\":\\\"\\\")+d;if(e&&a.FE.SHORTCUTS_MAP[f]){var h=a.FE.SHORTCUTS_MAP[f].cmd;if(h&&b.opts.shortcutsEnabled.indexOf(h)>=0){var i,j=a.FE.SHORTCUTS_MAP[f].val;if(h&&!j?i=b.$tb.find('.fr-command[data-cmd=\\\"'+h+'\\\"]'):h&&j&&(i=b.$tb.find('.fr-command[data-cmd=\\\"'+h+'\\\"][data-param1=\\\"'+j+'\\\"]')),i.length)return c.preventDefault(),c.stopPropagation(),i.parents(\\\".fr-toolbar\\\").data(\\\"instance\\\",b),\\\"keydown\\\"==c.type&&(b.button.exec(i),g=!0),!1;if(h&&b.commands[h])return c.preventDefault(),c.stopPropagation(),\\\"keydown\\\"==c.type&&(b.commands[h](),g=!0),!1}}}function e(){b.events.on(\\\"keydown\\\",d,!0),b.events.on(\\\"keyup\\\",d,!0)}var f=null,g=!1;return{_init:e,get:c}},a.FE.MODULES.snapshot=function(a){function b(a){for(var b=a.parentNode.childNodes,c=0,d=null,e=0;e<b.length;e++){if(d){var f=b[e].nodeType===Node.TEXT_NODE&&\\\"\\\"===b[e].textContent,g=d.nodeType===Node.TEXT_NODE&&b[e].nodeType===Node.TEXT_NODE;f||g||c++}if(b[e]==a)return c;d=b[e]}}function c(c){var d=[];if(!c.parentNode)return[];for(;!a.node.isElement(c);)d.push(b(c)),c=c.parentNode;return d.reverse()}function d(a,b){for(;a&&a.nodeType===Node.TEXT_NODE;){var c=a.previousSibling;c&&c.nodeType==Node.TEXT_NODE&&(b+=c.textContent.length),a=c}return b}function e(a){return{scLoc:c(a.startContainer),scOffset:d(a.startContainer,a.startOffset),ecLoc:c(a.endContainer),ecOffset:d(a.endContainer,a.endOffset)}}function f(){var b={};if(a.events.trigger(\\\"snapshot.before\\\"),b.html=(a.$wp?a.$el.html():a.$oel.get(0).outerHTML).replace(/ style=\\\"\\\"/g,\\\"\\\"),b.ranges=[],a.$wp&&a.selection.inEditor()&&a.core.hasFocus())for(var c=a.selection.ranges(),d=0;d<c.length;d++)b.ranges.push(e(c[d]));return a.events.trigger(\\\"snapshot.after\\\"),b}function g(b){for(var c=a.el,d=0;d<b.length;d++)c=c.childNodes[b[d]];return c}function h(b,c){try{var d=g(c.scLoc),e=c.scOffset,f=g(c.ecLoc),h=c.ecOffset,i=a.doc.createRange();i.setStart(d,e),i.setEnd(f,h),b.addRange(i)}catch(j){}}function i(b){a.$el.html()!=b.html&&a.$el.html(b.html);var c=a.selection.get();a.selection.clear(),a.events.focus(!0);for(var d=0;d<b.ranges.length;d++)h(c,b.ranges[d])}function j(b,c){return b.html==c.html&&(!a.core.hasFocus()||JSON.stringify(b.ranges)==JSON.stringify(c.ranges))}return{get:f,restore:i,equal:j}},a.FE.MODULES.undo=function(a){function b(b){var c=b.which,d=a.keys.ctrlKey(b);d&&(90==c&&b.shiftKey&&b.preventDefault(),90==c&&b.preventDefault())}function c(){return!(0===a.undo_stack.length||a.undo_index<=1)}function d(){return a.undo_index!=a.undo_stack.length}function e(b){return!(!a.undo_stack||a.undoing||a.el.querySelector(\\\".fr-marker\\\"))&&void(\\\"undefined\\\"==typeof b?(b=a.snapshot.get(),a.undo_stack[a.undo_index-1]&&a.snapshot.equal(a.undo_stack[a.undo_index-1],b)||(f(),a.undo_stack.push(b),a.undo_index++,b.html!=l&&(a.events.trigger(\\\"contentChanged\\\"),l=b.html))):(f(),a.undo_index>0?a.undo_stack[a.undo_index-1]=b:(a.undo_stack.push(b),a.undo_index++)))}function f(){if(!a.undo_stack||a.undoing)return!1;for(;a.undo_stack.length>a.undo_index;)a.undo_stack.pop()}function g(){if(a.undo_index>1){a.undoing=!0;var b=a.undo_stack[--a.undo_index-1];clearTimeout(a._content_changed_timer),a.snapshot.restore(b),l=b.html,a.popups.hideAll(),a.toolbar.enable(),a.events.trigger(\\\"contentChanged\\\"),a.events.trigger(\\\"commands.undo\\\"),a.undoing=!1}}function h(){if(a.undo_index<a.undo_stack.length){a.undoing=!0;var b=a.undo_stack[a.undo_index++];clearTimeout(a._content_changed_timer),a.snapshot.restore(b),l=b.html,a.popups.hideAll(),a.toolbar.enable(),a.events.trigger(\\\"contentChanged\\\"),a.events.trigger(\\\"commands.redo\\\"),a.undoing=!1}}function i(){a.undo_index=0,a.undo_stack=[]}function j(){a.undo_stack=[]}function k(){i(),a.events.on(\\\"initialized\\\",function(){l=(a.$wp?a.$el.html():a.$oel.get(0).outerHTML).replace(/ style=\\\"\\\"/g,\\\"\\\")}),a.events.on(\\\"blur\\\",function(){a.el.querySelector(\\\".fr-dragging\\\")||a.undo.saveStep()}),a.events.on(\\\"keydown\\\",b),a.events.on(\\\"destroy\\\",j)}var l=null;return{_init:k,run:g,redo:h,canDo:c,canRedo:d,dropRedo:f,reset:i,saveStep:e}},a.FE.ICON_DEFAULT_TEMPLATE=\\\"font_awesome\\\",a.FE.ICON_TEMPLATES={font_awesome:'<i class=\\\"fa fa-[NAME]\\\" aria-hidden=\\\"true\\\"></i>',text:'<span style=\\\"text-align: center;\\\">[NAME]</span>',image:\\\"<img src=[SRC] alt=[ALT] />\\\",svg:'<svg viewBox=\\\"0 0 32 32\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\">[PATH]</svg>'},a.FE.ICONS={bold:{NAME:\\\"bold\\\"},italic:{NAME:\\\"italic\\\"},underline:{NAME:\\\"underline\\\"},strikeThrough:{NAME:\\\"strikethrough\\\"},subscript:{NAME:\\\"subscript\\\"},superscript:{NAME:\\\"superscript\\\"},color:{NAME:\\\"tint\\\"},outdent:{NAME:\\\"outdent\\\"},indent:{NAME:\\\"indent\\\"},undo:{NAME:\\\"rotate-left\\\"},redo:{NAME:\\\"rotate-right\\\"},insertHR:{NAME:\\\"minus\\\"},clearFormatting:{NAME:\\\"eraser\\\"},selectAll:{NAME:\\\"mouse-pointer\\\"}},a.FE.DefineIconTemplate=function(b,c){a.FE.ICON_TEMPLATES[b]=c},a.FE.DefineIcon=function(b,c){a.FE.ICONS[b]=c},a.FE.MODULES.icon=function(){function b(b){var c=null,d=a.FE.ICONS[b];if(\\\"undefined\\\"!=typeof d){var e=d.template||a.FE.ICON_DEFAULT_TEMPLATE;e&&(e=a.FE.ICON_TEMPLATES[e])&&(c=e.replace(/\\\\[([a-zA-Z]*)\\\\]/g,function(a,c){return\\\"NAME\\\"==c?d[c]||b:d[c]}))}return c||b}function c(b){var c=a.FE.ICONS[b],d=a.FE.ICON_DEFAULT_TEMPLATE;return\\\"undefined\\\"!=typeof c?d=c.template||a.FE.ICON_DEFAULT_TEMPLATE:d}return{create:b,getTemplate:c}},a.extend(a.FE.DEFAULTS,{tooltips:!0}),a.FE.MODULES.tooltip=function(b){function c(){b.$tooltip&&b.$tooltip.removeClass(\\\"fr-visible\\\").css(\\\"left\\\",\\\"-3000px\\\").css(\\\"position\\\",\\\"fixed\\\")}function d(c,d){if(c.data(\\\"title\\\")||c.data(\\\"title\\\",c.attr(\\\"title\\\")),!c.data(\\\"title\\\"))return!1;b.$tooltip||f(),c.removeAttr(\\\"title\\\"),b.$tooltip.text(c.data(\\\"title\\\")),b.$tooltip.addClass(\\\"fr-visible\\\");var e=c.offset().left+(c.outerWidth()-b.$tooltip.outerWidth())/2;e<0&&(e=0),e+b.$tooltip.outerWidth()>a(b.o_win).width()&&(e=a(b.o_win).width()-b.$tooltip.outerWidth()),\\\"undefined\\\"==typeof d&&(d=b.opts.toolbarBottom);var g=d?c.offset().top-b.$tooltip.height():c.offset().top+c.outerHeight();b.$tooltip.css(\\\"position\\\",\\\"\\\"),b.$tooltip.css(\\\"left\\\",e),b.$tooltip.css(\\\"top\\\",Math.ceil(g)),\\\"static\\\"!=a(b.o_doc).find(\\\"body\\\").css(\\\"position\\\")?(b.$tooltip.css(\\\"margin-left\\\",-a(b.o_doc).find(\\\"body\\\").offset().left),b.$tooltip.css(\\\"margin-top\\\",-a(b.o_doc).find(\\\"body\\\").offset().top)):(b.$tooltip.css(\\\"margin-left\\\",\\\"\\\"),b.$tooltip.css(\\\"margin-top\\\",\\\"\\\"))}function e(e,f,g){b.opts.tooltips&&!b.helpers.isMobile()&&(b.events.$on(e,\\\"mouseenter\\\",f,function(c){b.node.hasClass(c.currentTarget,\\\"fr-disabled\\\")||b.edit.isDisabled()||d(a(c.currentTarget),g)},!0),b.events.$on(e,\\\"mouseleave \\\"+b._mousedown+\\\" \\\"+b._mouseup,f,function(){c()},!0))}function f(){b.opts.tooltips&&!b.helpers.isMobile()&&(b.shared.$tooltip?b.$tooltip=b.shared.$tooltip:(b.shared.$tooltip=a('<div class=\\\"fr-tooltip\\\"></div>'),b.$tooltip=b.shared.$tooltip,b.opts.theme&&b.$tooltip.addClass(b.opts.theme+\\\"-theme\\\"),a(b.o_doc).find(\\\"body\\\").append(b.$tooltip)),b.events.on(\\\"shared.destroy\\\",function(){b.$tooltip.html(\\\"\\\").removeData().remove(),b.$tooltip=null},!0))}return{hide:c,to:d,bind:e}},a.FE.MODULES.button=function(b){function c(b,c,d){for(var e=a(),f=0;f<b.length;f++){var g=a(b[f]);if(g.is(c)&&(e=e.add(g)),d&&g.is(\\\".fr-dropdown\\\")){var h=g.next().find(c);e=e.add(h)}}return e}function d(d,e){var f,g=a();if(!d)return g;g=g.add(c(v,d,e)),g=g.add(c(w,d,e));for(f in b.shared.popups)if(b.shared.popups.hasOwnProperty(f)){var h=b.shared.popups[f],i=h.children().not(\\\".fr-buttons\\\").find(d);g=g.add(i)}for(f in b.shared.modals)if(b.shared.modals.hasOwnProperty(f)){var j=b.shared.modals[f],k=j.$modal.find(d);g=g.add(k)}return g}function e(c){var e=c.next(),f=b.node.hasClass(c.get(0),\\\"fr-active\\\"),g=d(\\\".fr-dropdown.fr-active\\\").not(c),h=c.parents(\\\".fr-toolbar, .fr-popup\\\").data(\\\"instance\\\")||b;if(h.helpers.isIOS()&&!h.el.querySelector(\\\".fr-marker\\\")&&(h.selection.save(),h.selection.clear(),h.selection.restore()),!f){var i=c.data(\\\"cmd\\\");e.find(\\\".fr-command\\\").removeClass(\\\"fr-active\\\").attr(\\\"aria-selected\\\",!1),a.FE.COMMANDS[i]&&a.FE.COMMANDS[i].refreshOnShow&&a.FE.COMMANDS[i].refreshOnShow.apply(h,[c,e]),e.css(\\\"left\\\",c.offset().left-c.parent().offset().left-(\\\"rtl\\\"==b.opts.direction?e.width()-c.outerWidth():0)),b.opts.toolbarBottom?e.css(\\\"bottom\\\",b.$tb.height()-c.position().top):e.css(\\\"top\\\",c.position().top+c.outerHeight())}c.addClass(\\\"fr-blink\\\").toggleClass(\\\"fr-active\\\"),c.hasClass(\\\"fr-active\\\")?(e.attr(\\\"aria-hidden\\\",!1),c.attr(\\\"aria-expanded\\\",!0)):(e.attr(\\\"aria-hidden\\\",!0),c.attr(\\\"aria-expanded\\\",!1)),setTimeout(function(){c.removeClass(\\\"fr-blink\\\")},300),e.offset().left+e.outerWidth()>b.$sc.offset().left+b.$sc.outerWidth()&&e.css(\\\"margin-left\\\",-(e.offset().left+e.outerWidth()-b.$sc.offset().left-b.$sc.outerWidth())),g.removeClass(\\\"fr-active\\\").attr(\\\"aria-expanded\\\",!1).next().attr(\\\"aria-hidden\\\",!0),g.parent(\\\".fr-toolbar:not(.fr-inline)\\\").css(\\\"zIndex\\\",\\\"\\\"),0!==c.parents(\\\".fr-popup\\\").length||b.opts.toolbarInline||(b.node.hasClass(c.get(0),\\\"fr-active\\\")?b.$tb.css(\\\"zIndex\\\",(b.opts.zIndex||1)+4):b.$tb.css(\\\"zIndex\\\",\\\"\\\"));var j=e.find(\\\"a.fr-command.fr-active:first\\\");b.helpers.isMobile()||(j.length?b.accessibility.focusToolbarElement(j):b.accessibility.focusToolbarElement(c))}function f(a){a.addClass(\\\"fr-blink\\\"),setTimeout(function(){a.removeClass(\\\"fr-blink\\\")},500);for(var b=a.data(\\\"cmd\\\"),c=[];\\\"undefined\\\"!=typeof a.data(\\\"param\\\"+(c.length+1));)c.push(a.data(\\\"param\\\"+(c.length+1)));var e=d(\\\".fr-dropdown.fr-active\\\");e.length&&(e.removeClass(\\\"fr-active\\\").attr(\\\"aria-expanded\\\",!1).next().attr(\\\"aria-hidden\\\",!0),e.parent(\\\".fr-toolbar:not(.fr-inline)\\\").css(\\\"zIndex\\\",\\\"\\\")),a.parents(\\\".fr-popup, .fr-toolbar\\\").data(\\\"instance\\\").commands.exec(b,c)}function g(a){f(a)}function h(c){var d=c.parents(\\\".fr-popup, .fr-toolbar\\\").data(\\\"instance\\\");if(0!==c.parents(\\\".fr-popup\\\").length||c.data(\\\"popup\\\")||d.popups.hideAll(),d.popups.areVisible()&&!d.popups.areVisible(d)){for(var f=0;f<a.FE.INSTANCES.length;f++)a.FE.INSTANCES[f]!=d&&a.FE.INSTANCES[f].popups&&a.FE.INSTANCES[f].popups.areVisible()&&a.FE.INSTANCES[f].$el.find(\\\".fr-marker\\\").remove();d.popups.hideAll()}b.node.hasClass(c.get(0),\\\"fr-dropdown\\\")?e(c):(g(c),a.FE.COMMANDS[c.data(\\\"cmd\\\")]&&a.FE.COMMANDS[c.data(\\\"cmd\\\")].refreshAfterCallback!==!1&&d.button.bulkRefresh())}function i(b){var c=a(b.currentTarget);h(c)}function j(a){var b=a.find(\\\".fr-dropdown.fr-active\\\");b.length&&(b.removeClass(\\\"fr-active\\\").attr(\\\"aria-expanded\\\",!1).next().attr(\\\"aria-hidden\\\",!0),b.parent(\\\".fr-toolbar:not(.fr-inline)\\\").css(\\\"zIndex\\\",\\\"\\\"))}function k(a){a.preventDefault(),a.stopPropagation()}function l(a){if(a.stopPropagation(),!b.helpers.isMobile())return!1}function m(c,d){b.events.bindClick(c,\\\".fr-command:not(.fr-disabled)\\\",i),b.events.$on(c,b._mousedown+\\\" \\\"+b._mouseup+\\\" \\\"+b._move,\\\".fr-dropdown-menu\\\",k,!0),b.events.$on(c,b._mousedown+\\\" \\\"+b._mouseup+\\\" \\\"+b._move,\\\".fr-dropdown-menu .fr-dropdown-wrapper\\\",l,!0);var e=c.get(0).ownerDocument,f=\\\"defaultView\\\"in e?e.defaultView:e.parentWindow,g=function(d){(!d||d.type==b._mouseup&&d.target!=a(\\\"html\\\").get(0)||\\\"keydown\\\"==d.type&&(b.keys.isCharacter(d.which)&&!b.keys.ctrlKey(d)||d.which==a.FE.KEYCODE.ESC))&&j(c)};b.events.$on(a(f),b._mouseup+\\\" resize keydown\\\",g,!0),b.opts.iframe&&b.events.$on(b.$win,b._mouseup,g,!0),b.node.hasClass(c.get(0),\\\"fr-popup\\\")?a.merge(w,c.find(\\\".fr-btn\\\").toArray()):a.merge(v,c.find(\\\".fr-btn\\\").toArray()),b.tooltip.bind(c,\\\".fr-btn, .fr-title\\\",d)}function n(a,c){var d=\\\"\\\";if(c.html)d+=\\\"function\\\"==typeof c.html?c.html.call(b):c.html;else{var e=c.options;\\\"function\\\"==typeof e&&(e=e()),d+='<ul class=\\\"fr-dropdown-list\\\" role=\\\"presentation\\\">';for(var f in e)if(e.hasOwnProperty(f)){var g=b.shortcuts.get(a+\\\".\\\"+f);g=g?'<span class=\\\"fr-shortcut\\\">'+g+\\\"</span>\\\":\\\"\\\",d+='<li role=\\\"presentation\\\"><a class=\\\"fr-command\\\" tabIndex=\\\"-1\\\" role=\\\"option\\\" data-cmd=\\\"'+a+'\\\" data-param1=\\\"'+f+'\\\" title=\\\"'+e[f]+'\\\">'+b.language.translate(e[f])+\\\"</a></li>\\\"}d+=\\\"</ul>\\\"}return d}function o(a,c,d){if(b.helpers.isMobile()&&c.showOnMobile===!1)return\\\"\\\";var e=c.displaySelection;\\\"function\\\"==typeof e&&(e=e(b));var f;if(e){var g=\\\"function\\\"==typeof c.defaultSelection?c.defaultSelection(b):c.defaultSelection;f='<span style=\\\"width:'+(c.displaySelectionWidth||100)+'px\\\">'+(g||b.language.translate(c.title))+\\\"</span>\\\"}else f=b.icon.create(c.icon||a),f+='<span class=\\\"fr-sr-only\\\">'+(b.language.translate(c.title)||\\\"\\\")+\\\"</span>\\\";var h=c.popup?' data-popup=\\\"true\\\"':\\\"\\\",i=c.modal?' data-modal=\\\"true\\\"':\\\"\\\",j=b.shortcuts.get(a+\\\".\\\");j=j?\\\" (\\\"+j+\\\")\\\":\\\"\\\";var k=a+\\\"-\\\"+b.id,l=\\\"dropdown-menu-\\\"+k,m='<button id=\\\"'+k+'\\\"type=\\\"button\\\" tabIndex=\\\"-1\\\" role=\\\"button\\\"'+(c.toggle?' aria-pressed=\\\"false\\\"':\\\"\\\")+(\\\"dropdown\\\"==c.type?' aria-controls=\\\"'+l+'\\\" aria-expanded=\\\"false\\\" aria-haspopup=\\\"true\\\"':\\\"\\\")+(c.disabled?' aria-disabled=\\\"true\\\"':\\\"\\\")+' title=\\\"'+(b.language.translate(c.title)||\\\"\\\")+j+'\\\" class=\\\"fr-command fr-btn'+(\\\"dropdown\\\"==c.type?\\\" fr-dropdown\\\":\\\"\\\")+(\\\" fr-btn-\\\"+b.icon.getTemplate(c.icon))+(c.displaySelection?\\\" fr-selection\\\":\\\"\\\")+(c.back?\\\" fr-back\\\":\\\"\\\")+(c.disabled?\\\" fr-disabled\\\":\\\"\\\")+(d?\\\"\\\":\\\" fr-hidden\\\")+'\\\" data-cmd=\\\"'+a+'\\\"'+h+i+\\\">\\\"+f+\\\"</button>\\\";if(\\\"dropdown\\\"==c.type){var o='<div id=\\\"'+l+'\\\" class=\\\"fr-dropdown-menu\\\" role=\\\"listbox\\\" aria-labelledby=\\\"'+k+'\\\" aria-hidden=\\\"true\\\"><div class=\\\"fr-dropdown-wrapper\\\" role=\\\"presentation\\\"><div class=\\\"fr-dropdown-content\\\" role=\\\"presentation\\\">';o+=n(a,c),o+=\\\"</div></div></div>\\\",m+=o}return m}function p(c,d){for(var e=\\\"\\\",f=0;f<c.length;f++){var g=c[f],h=a.FE.COMMANDS[g];if(!(h&&\\\"undefined\\\"!=typeof h.plugin&&b.opts.pluginsEnabled.indexOf(h.plugin)<0))if(h){var i=\\\"undefined\\\"==typeof d||d.indexOf(g)>=0;e+=o(g,h,i)}else\\\"|\\\"==g?e+='<div class=\\\"fr-separator fr-vs\\\" role=\\\"separator\\\" aria-orientation=\\\"vertical\\\"></div>':\\\"-\\\"==g&&(e+='<div class=\\\"fr-separator fr-hs\\\" role=\\\"separator\\\" aria-orientation=\\\"horizontal\\\"></div>')}return e}function q(c){var d,e=c.parents(\\\".fr-popup, .fr-toolbar\\\").data(\\\"instance\\\")||b,f=c.data(\\\"cmd\\\");b.node.hasClass(c.get(0),\\\"fr-dropdown\\\")?d=c.next():(c.removeClass(\\\"fr-active\\\"),c.attr(\\\"aria-pressed\\\")&&c.attr(\\\"aria-pressed\\\",!1)),a.FE.COMMANDS[f]&&a.FE.COMMANDS[f].refresh?a.FE.COMMANDS[f].refresh.apply(e,[c,d]):b.refresh[f]&&e.refresh[f](c,d)}function r(c){var d=b.$tb?b.$tb.data(\\\"instance\\\")||b:b;return b.events.trigger(\\\"buttons.refresh\\\")===!1||void setTimeout(function(){for(var e=d.selection.inEditor()&&d.core.hasFocus(),f=0;f<c.length;f++){var g=a(c[f]),h=g.data(\\\"cmd\\\");0===g.parents(\\\".fr-popup\\\").length?e||a.FE.COMMANDS[h]&&a.FE.COMMANDS[h].forcedRefresh?d.button.refresh(g):b.node.hasClass(g.get(0),\\\"fr-dropdown\\\")||(g.removeClass(\\\"fr-active\\\"),g.attr(\\\"aria-pressed\\\")&&g.attr(\\\"aria-pressed\\\",!1)):g.parents(\\\".fr-popup\\\").is(\\\":visible\\\")&&d.button.refresh(g)}},0)}function s(){r(v),r(w)}function t(){v=[],w=[]}function u(){b.opts.toolbarInline?b.events.on(\\\"toolbar.show\\\",s):(b.events.on(\\\"mouseup\\\",s),b.events.on(\\\"keyup\\\",s),b.events.on(\\\"blur\\\",s),b.events.on(\\\"focus\\\",s),b.events.on(\\\"contentChanged\\\",s)),b.events.on(\\\"shared.destroy\\\",t)}var v=[];(b.opts.toolbarInline||b.opts.toolbarContainer)&&(b.shared.buttons||(b.shared.buttons=[]),v=b.shared.buttons);var w=[];return b.shared.popup_buttons||(b.shared.popup_buttons=[]),w=b.shared.popup_buttons,{_init:u,buildList:p,bindCommands:m,refresh:q,bulkRefresh:s,exec:f,click:h,hideActiveDropdowns:j,getButtons:d}},a.FE.MODULES.modals=function(b){function c(a){return n[a]}function d(c,d){var e='<div tabIndex=\\\"-1\\\" class=\\\"fr-modal'+(b.opts.theme?\\\" \\\"+b.opts.theme+\\\"-theme\\\":\\\"\\\")+'\\\"><div class=\\\"fr-modal-wrapper\\\">',f='<i title=\\\"'+b.language.translate(\\\"Cancel\\\")+'\\\" class=\\\"fa fa-times fr-modal-close\\\"></i>';return e+='<div class=\\\"fr-modal-head\\\">'+c+f+\\\"</div>\\\",e+='<div tabIndex=\\\"-1\\\" class=\\\"fr-modal-body\\\">'+d+\\\"</div>\\\",e+=\\\"</div></div>\\\",a(e)}function e(c,e,f){if(b.shared.$overlay||(b.shared.$overlay=a('<div class=\\\"fr-overlay\\\">').appendTo(\\\"body\\\")),m=b.shared.$overlay,b.opts.theme&&m.addClass(b.opts.theme+\\\"-theme\\\"),!n[c]){var g=d(e,f);n[c]={$modal:g,$head:g.find(\\\".fr-modal-head\\\"),$body:g.find(\\\".fr-modal-body\\\")},b.helpers.isMobile()||g.addClass(\\\"fr-desktop\\\"),g.appendTo(\\\"body\\\"),b.events.bindClick(g,\\\"i.fr-modal-close\\\",function(){h(c)}),n[c].$body.css(\\\"margin-top\\\",n[c].$head.outerHeight()),b.events.$on(g,\\\"keydown\\\",function(d){var e=d.which;return e==a.FE.KEYCODE.ESC?(h(c),b.accessibility.focusModalButton(g),!1):!(!a(d.currentTarget).is(\\\"input[type=text], textarea\\\")&&e!=a.FE.KEYCODE.ARROW_UP&&e!=a.FE.KEYCODE.ARROW_DOWN&&!b.keys.isBrowserAction(d))||(d.preventDefault(),d.stopPropagation(),!1)},!0),h(c,!0)}return n[c]}function f(){for(var a in n){var b=n[a];b&&b.$modal&&b.$modal.removeData().remove()}m&&m.removeData().remove(),n={}}function g(c){if(n[c]){var d=n[c].$modal;d.data(\\\"instance\\\",b),d.show(),m.show(),a(b.o_doc).find(\\\"body\\\").addClass(\\\"prevent-scroll\\\"),b.helpers.isMobile()&&a(b.o_doc).find(\\\"body\\\").addClass(\\\"fr-mobile\\\"),d.addClass(\\\"fr-active\\\"),b.accessibility.focusModal(d)}}function h(c,d){if(n[c]){var e=n[c].$modal,f=e.data(\\\"instance\\\")||b;f.events.enableBlur(),e.hide(),m.hide(),a(f.o_doc).find(\\\"body\\\").removeClass(\\\"prevent-scroll fr-mobile\\\"),e.removeClass(\\\"fr-active\\\"),d||(b.accessibility.restoreSelection(f),b.events.trigger(\\\"modals.hide\\\"))}}function i(a){if(n[a]){var c=n[a],d=c.$modal,e=c.$body,f=b.$win.height(),g=d.find(\\\".fr-modal-wrapper\\\"),h=g.outerHeight(!0),i=g.height()-(e.outerHeight(!0)-e.height()),j=f-h+i,k=e.get(0).scrollHeight,l=\\\"auto\\\";k>j&&(l=j),e.height(l)}}function j(a){var c;if(\\\"string\\\"==typeof a){if(!n[a])return;c=n[a].$modal}else c=a;return c&&b.node.hasClass(c,\\\"fr-active\\\")&&b.core.sameInstance(c)||!1}function k(a){for(var b in n)if(n.hasOwnProperty(b)&&j(b)&&(\\\"undefined\\\"==typeof a||n[b].$modal.data(\\\"instance\\\")==a))return n[b].$modal;return!1}function l(){b.events.on(\\\"shared.destroy\\\",f,!0)}b.shared.modals||(b.shared.modals={});var m,n=b.shared.modals;return{_init:l,get:c,create:e,show:g,hide:h,resize:i,isVisible:j,areVisible:k}},a.FE.POPUP_TEMPLATES={\\\"text.edit\\\":\\\"[_EDIT_]\\\"},a.FE.RegisterTemplate=function(b,c){a.FE.POPUP_TEMPLATES[b]=c},a.FE.MODULES.popups=function(b){function c(a,c){c.is(\\\":visible\\\")||(c=b.$sc),c.is(x[a].data(\\\"container\\\"))||(x[a].data(\\\"container\\\",c),c.append(x[a]))}function d(a,d,e,h){if(g()&&b.$el.find(\\\".fr-marker\\\").length>0?(b.events.disableBlur(),b.selection.restore()):(b.events.disableBlur(),b.events.focus(),b.events.enableBlur()),m([a]),!x[a])return!1;var i=b.button.getButtons(\\\".fr-dropdown.fr-active\\\");i.removeClass(\\\"fr-active\\\").attr(\\\"aria-expanded\\\",!1).parent(\\\".fr-toolbar\\\").css(\\\"zIndex\\\",\\\"\\\"),i.next().attr(\\\"aria-hidden\\\",!0),x[a].data(\\\"instance\\\",b),b.$tb&&b.$tb.data(\\\"instance\\\",b);var j=x[a].outerWidth(),k=f(a);x[a].addClass(\\\"fr-active\\\").removeClass(\\\"fr-hidden\\\").find(\\\"input, textarea\\\").removeAttr(\\\"disabled\\\");var l=x[a].data(\\\"container\\\");b.opts.toolbarInline&&l&&b.$tb&&l.get(0)==b.$tb.get(0)&&(c(a,b.$sc),e=b.$tb.offset().top-b.helpers.getPX(b.$tb.css(\\\"margin-top\\\")),d=b.$tb.offset().left+b.$tb.outerWidth()/2+(parseFloat(b.$tb.find(\\\".fr-arrow\\\").css(\\\"margin-left\\\"))||0)+b.$tb.find(\\\".fr-arrow\\\").outerWidth()/2,b.node.hasClass(b.$tb.get(0),\\\"fr-above\\\")&&e&&(e+=b.$tb.outerHeight()),h=0),l=x[a].data(\\\"container\\\"),!b.opts.iframe||h||k||(d&&(d-=b.$iframe.offset().left),e&&(e-=b.$iframe.offset().top)),l.is(b.$tb)?b.$tb.css(\\\"zIndex\\\",(b.opts.zIndex||1)+4):x[a].css(\\\"zIndex\\\",(b.opts.zIndex||1)+4),d&&(d-=j/2),b.opts.toolbarBottom&&l&&b.$tb&&l.get(0)==b.$tb.get(0)&&(x[a].addClass(\\\"fr-above\\\"),e&&(e-=x[a].outerHeight())),x[a].removeClass(\\\"fr-active\\\"),b.position.at(d,e,x[a],h||0),x[a].addClass(\\\"fr-active\\\"),k||b.accessibility.focusPopup(x[a]),b.opts.toolbarInline&&b.toolbar.hide(),b.events.trigger(\\\"popups.show.\\\"+a),s(a)._repositionPopup(),o()}function e(a,c){b.events.on(\\\"popups.show.\\\"+a,c)}function f(a){return x[a]&&b.node.hasClass(x[a],\\\"fr-active\\\")&&b.core.sameInstance(x[a])||!1}function g(a){for(var b in x)if(x.hasOwnProperty(b)&&f(b)&&(\\\"undefined\\\"==typeof a||x[b].data(\\\"instance\\\")==a))return x[b];\\nreturn!1}function h(a){var c=null;c=\\\"string\\\"!=typeof a?a:x[a],c&&b.node.hasClass(c,\\\"fr-active\\\")&&(c.removeClass(\\\"fr-active fr-above\\\"),b.events.trigger(\\\"popups.hide.\\\"+a),b.$tb&&(b.opts.zIndex>1?b.$tb.css(\\\"zIndex\\\",b.opts.zIndex+1):b.$tb.css(\\\"zIndex\\\",\\\"\\\")),b.events.disableBlur(),c.find(\\\"input, textarea, button\\\").filter(\\\":focus\\\").blur(),c.find(\\\"input, textarea\\\").attr(\\\"disabled\\\",\\\"disabled\\\"))}function i(a,c){b.events.on(\\\"popups.hide.\\\"+a,c)}function j(a){var c=x[a];if(c&&!c.data(\\\"inst\\\"+b.id)){var d=s(a);t(d,a)}return c}function k(a,c){b.events.on(\\\"popups.refresh.\\\"+a,c)}function l(c){b.events.trigger(\\\"popups.refresh.\\\"+c);for(var d=x[c].find(\\\".fr-command\\\"),e=0;e<d.length;e++){var f=a(d[e]);0===f.parents(\\\".fr-dropdown-menu\\\").length&&b.button.refresh(f)}}function m(a){\\\"undefined\\\"==typeof a&&(a=[]);for(var b in x)x.hasOwnProperty(b)&&a.indexOf(b)<0&&h(b)}function n(){b.shared.exit_flag=!0}function o(){b.shared.exit_flag=!1}function p(){return b.shared.exit_flag}function q(c,d){var e=a.FE.POPUP_TEMPLATES[c];\\\"function\\\"==typeof e&&(e=e.apply(b));for(var f in d)d.hasOwnProperty(f)&&(e=e.replace(\\\"[_\\\"+f.toUpperCase()+\\\"_]\\\",d[f]));return e}function r(c,d){var e=q(c,d),f=a('<div class=\\\"fr-popup'+(b.helpers.isMobile()?\\\" fr-mobile\\\":\\\" fr-desktop\\\")+(b.opts.toolbarInline?\\\" fr-inline\\\":\\\"\\\")+'\\\"><span class=\\\"fr-arrow\\\"></span>'+e+\\\"</div>\\\");b.opts.theme&&f.addClass(b.opts.theme+\\\"-theme\\\"),b.opts.zIndex>1&&b.$tb.css(\\\"z-index\\\",b.opts.zIndex+2),\\\"auto\\\"!=b.opts.direction&&f.removeClass(\\\"fr-ltr fr-rtl\\\").addClass(\\\"fr-\\\"+b.opts.direction),f.find(\\\"input, textarea\\\").attr(\\\"dir\\\",b.opts.direction).attr(\\\"disabled\\\",\\\"disabled\\\");var g=a(\\\"body\\\");return g.append(f),f.data(\\\"container\\\",g),x[c]=f,b.button.bindCommands(f,!1),f}function s(c){var d=x[c];return{_windowResize:function(){var a=d.data(\\\"instance\\\")||b;!a.helpers.isMobile()&&d.is(\\\":visible\\\")&&(a.events.disableBlur(),a.popups.hide(c),a.events.enableBlur())},_inputFocus:function(c){var e=d.data(\\\"instance\\\")||b,f=a(c.currentTarget);if(f.is(\\\"input:file\\\")&&f.closest(\\\".fr-layer\\\").addClass(\\\"fr-input-focus\\\"),c.preventDefault(),c.stopPropagation(),setTimeout(function(){e.events.enableBlur()},0),e.helpers.isMobile()){var g=a(e.o_win).scrollTop();setTimeout(function(){a(e.o_win).scrollTop(g)},0)}},_inputBlur:function(c){var e=d.data(\\\"instance\\\")||b,f=a(c.currentTarget);f.is(\\\"input:file\\\")&&f.closest(\\\".fr-layer\\\").removeClass(\\\"fr-input-focus\\\"),document.activeElement!=this&&a(this).is(\\\":visible\\\")&&(e.events.blurActive()&&e.events.trigger(\\\"blur\\\"),e.events.enableBlur())},_editorKeydown:function(e){var g=d.data(\\\"instance\\\")||b;g.keys.ctrlKey(e)||e.which==a.FE.KEYCODE.ALT||e.which==a.FE.KEYCODE.ESC||(f(c)&&d.find(\\\".fr-back:visible\\\").length?g.button.exec(d.find(\\\".fr-back:visible:first\\\")):e.which!=a.FE.KEYCODE.ALT&&g.popups.hide(c))},_preventFocus:function(c){var e=d.data(\\\"instance\\\")||b;\\\"mouseup\\\"==c.type&&b.button.hideActiveDropdowns(d);var f=c.originalEvent?c.originalEvent.target||c.originalEvent.originalTarget:null;\\\"mouseup\\\"==c.type||a(f).is(\\\":focus\\\")||e.events.disableBlur(),b.browser.safari&&\\\"mousedown\\\"==c.type&&a(f).is(\\\"input[type=file]\\\")&&e.events.disableBlur();var g=\\\"input, textarea, button, select, label, .fr-command\\\";return f&&!a(f).is(g)&&0===a(f).parents(g).length?(c.stopPropagation(),!1):(f&&a(f).is(g)&&c.stopPropagation(),void o())},_editorMouseup:function(){d.is(\\\":visible\\\")&&p()&&d.find(\\\"input:focus, textarea:focus, button:focus, select:focus\\\").filter(\\\":visible\\\").length>0&&b.events.disableBlur()},_windowMouseup:function(a){if(!b.core.sameInstance(d))return!0;var e=d.data(\\\"instance\\\")||b;d.is(\\\":visible\\\")&&p()&&(a.stopPropagation(),e.markers.remove(),e.popups.hide(c),o())},_windowKeydown:function(e){if(!b.core.sameInstance(d))return!0;var f=d.data(\\\"instance\\\")||b,g=e.which;if(a.FE.KEYCODE.ESC==g){if(f.popups.isVisible(c)&&f.opts.toolbarInline)return e.stopPropagation(),f.popups.isVisible(c)&&(d.find(\\\".fr-back:visible\\\").length?(f.button.exec(d.find(\\\".fr-back:visible:first\\\")),f.accessibility.focusPopupButton(d)):d.find(\\\".fr-dismiss:visible\\\").length?f.button.exec(d.find(\\\".fr-dismiss:visible:first\\\")):(f.popups.hide(c),f.toolbar.showInline(null,!0),f.accessibility.FocusPopupButton(d))),!1;if(f.popups.isVisible(c))return d.find(\\\".fr-back:visible\\\").length?(f.button.exec(d.find(\\\".fr-back:visible:first\\\")),f.accessibility.focusPopupButton(d)):d.find(\\\".fr-dismiss:visible\\\").length?f.button.exec(d.find(\\\".fr-dismiss:visible:first\\\")):(f.popups.hide(c),f.accessibility.focusPopupButton(d)),!1}},_doPlaceholder:function(){var b=a(this).next();0===b.length&&a(this).attr(\\\"placeholder\\\")&&a(this).after('<label for=\\\"'+a(this).attr(\\\"id\\\")+'\\\">'+a(this).attr(\\\"placeholder\\\")+\\\"</label>\\\"),a(this).toggleClass(\\\"fr-not-empty\\\",\\\"\\\"!==a(this).val())},_repositionPopup:function(){if(!b.opts.height&&!b.opts.heightMax||b.opts.toolbarInline)return!0;if(b.$wp&&f(c)&&d.parent().get(0)==b.$sc.get(0)){var a=d.offset().top-b.$wp.offset().top,e=b.$wp.outerHeight();b.node.hasClass(d.get(0),\\\"fr-above\\\")&&(a+=d.outerHeight()),a>e||a<0?d.addClass(\\\"fr-hidden\\\"):d.removeClass(\\\"fr-hidden\\\")}}}}function t(a,c){b.events.on(\\\"mouseup\\\",a._editorMouseup,!0),b.$wp&&b.events.on(\\\"keydown\\\",a._editorKeydown),b.events.on(\\\"blur\\\",function(){g()&&b.markers.remove(),m()}),b.$wp&&!b.helpers.isMobile()&&b.events.$on(b.$wp,\\\"scroll.popup\\\"+c,a._repositionPopup),b.events.on(\\\"window.mouseup\\\",a._windowMouseup,!0),b.events.on(\\\"window.keydown\\\",a._windowKeydown,!0),x[c].data(\\\"inst\\\"+b.id,!0),b.events.on(\\\"destroy\\\",function(){b.core.sameInstance(x[c])&&x[c].removeClass(\\\"fr-active\\\").appendTo(\\\"body\\\")},!0)}function u(c,d){var e=r(c,d),f=s(c);return t(f,c),b.events.$on(e,\\\"mousedown mouseup touchstart touchend touch\\\",\\\"*\\\",f._preventFocus,!0),b.events.$on(e,\\\"focus\\\",\\\"input, textarea, button, select\\\",f._inputFocus,!0),b.events.$on(e,\\\"blur\\\",\\\"input, textarea, button, select\\\",f._inputBlur,!0),b.accessibility.registerPopup(c),b.events.$on(e,\\\"keydown keyup change input\\\",\\\"input, textarea\\\",f._doPlaceholder,!0),b.helpers.isIOS()&&b.events.$on(e,\\\"touchend\\\",\\\"label\\\",function(){a(\\\"#\\\"+a(this).attr(\\\"for\\\")).prop(\\\"checked\\\",function(a,b){return!b})},!0),b.events.$on(a(b.o_win),\\\"resize\\\",f._windowResize,!0),e}function v(){for(var a in x)if(x.hasOwnProperty(a)){var b=x[a];b.html(\\\"\\\").removeData().remove(),x[a]=null}x=[]}function w(){b.events.on(\\\"shared.destroy\\\",v,!0),b.events.on(\\\"window.mousedown\\\",n),b.events.on(\\\"window.touchmove\\\",o),b.events.on(\\\"mousedown\\\",function(a){g()&&(a.stopPropagation(),b.$el.find(\\\".fr-marker\\\").remove(),n(),b.events.disableBlur())})}b.shared.popups||(b.shared.popups={});var x=b.shared.popups;return b.shared.exit_flag=!1,{_init:w,create:u,get:j,show:d,hide:h,onHide:i,hideAll:m,setContainer:c,refresh:l,onRefresh:k,onShow:e,isVisible:f,areVisible:g}},a.FE.MODULES.position=function(b){function c(){var a=b.selection.ranges(0),c=a.getBoundingClientRect();if(0===c.top&&0===c.left&&0===c.width||0===c.height){var d=!1;0===b.$el.find(\\\".fr-marker\\\").length&&(b.selection.save(),d=!0);var e=b.$el.find(\\\".fr-marker:first\\\");e.css(\\\"display\\\",\\\"inline\\\"),e.css(\\\"line-height\\\",\\\"\\\");var f=e.offset(),g=e.outerHeight();e.css(\\\"display\\\",\\\"none\\\"),e.css(\\\"line-height\\\",0),c={},c.left=f.left,c.width=0,c.height=g,c.top=f.top-(b.helpers.isMobile()?0:b.helpers.scrollTop()),c.right=1,c.bottom=1,c.ok=!0,d&&b.selection.restore()}return c}function d(a,c,d){var e=a.get(0).offsetHeight;if(!b.helpers.isMobile()&&b.$tb&&a.parent().get(0)!=b.$tb.get(0)){var f=a.parent().offset().top,g=c-e-(d||0);a.parent().get(0)==b.$sc.get(0)&&(f-=a.parent().position().top);var h=b.$sc.get(0).scrollHeight;f+c+e>b.$sc.offset().top+h&&a.parent().offset().top+g>0?(c=g,a.addClass(\\\"fr-above\\\")):a.removeClass(\\\"fr-above\\\")}return c}function e(a,c){var d=a.get(0).offsetWidth;return c+d>b.$sc.get(0).clientWidth-10&&(c=b.$sc.get(0).clientWidth-d-10),c<0&&(c=10),c}function f(a){var d=c();a.css({top:0,left:0});var e=d.top+d.height,f=d.left+d.width/2-a.get(0).offsetWidth/2+b.helpers.scrollLeft();b.opts.iframe||(e+=b.helpers.scrollTop()),g(f,e,a,d.height)}function g(a,c,f,g){var h=f.data(\\\"container\\\");!h||\\\"BODY\\\"===h.get(0).tagName&&\\\"static\\\"==h.css(\\\"position\\\")||(a&&(a-=h.offset().left),c&&(c-=h.offset().top),\\\"BODY\\\"!=h.get(0).tagName?(a&&(a+=h.get(0).scrollLeft),c&&(c+=h.get(0).scrollTop)):\\\"absolute\\\"==h.css(\\\"position\\\")&&(a&&(a+=h.position().left),c&&(c+=h.position().top))),b.opts.iframe&&h&&b.$tb&&h.get(0)!=b.$tb.get(0)&&(a&&(a+=b.$iframe.offset().left),c&&(c+=b.$iframe.offset().top));var i=e(f,a);if(a){f.css(\\\"left\\\",i);var j=f.data(\\\"fr-arrow\\\");j||(j=f.find(\\\".fr-arrow\\\"),f.data(\\\"fr-arrow\\\",j)),j.data(\\\"margin-left\\\")||j.data(\\\"margin-left\\\",b.helpers.getPX(j.css(\\\"margin-left\\\"))),j.css(\\\"margin-left\\\",a-i+j.data(\\\"margin-left\\\"))}c&&f.css(\\\"top\\\",d(f,c,g))}function h(c){var d=a(c),e=d.is(\\\".fr-sticky-on\\\"),f=d.data(\\\"sticky-top\\\"),g=d.data(\\\"sticky-scheduled\\\");if(\\\"undefined\\\"==typeof f){d.data(\\\"sticky-top\\\",0);var h=a('<div class=\\\"fr-sticky-dummy\\\" style=\\\"height: '+d.outerHeight()+'px;\\\"></div>');b.$box.prepend(h)}else b.$box.find(\\\".fr-sticky-dummy\\\").css(\\\"height\\\",d.outerHeight());if(b.core.hasFocus()||b.$tb.find(\\\"input:visible:focus\\\").length>0){var i=b.helpers.scrollTop(),j=Math.min(Math.max(i-b.$tb.parent().offset().top,0),b.$tb.parent().outerHeight()-d.outerHeight());j!=f&&j!=g&&(clearTimeout(d.data(\\\"sticky-timeout\\\")),d.data(\\\"sticky-scheduled\\\",j),d.outerHeight()<i-b.$tb.parent().offset().top&&d.addClass(\\\"fr-opacity-0\\\"),d.data(\\\"sticky-timeout\\\",setTimeout(function(){var a=b.helpers.scrollTop(),c=Math.min(Math.max(a-b.$tb.parent().offset().top,0),b.$tb.parent().outerHeight()-d.outerHeight());c>0&&\\\"BODY\\\"==b.$tb.parent().get(0).tagName&&(c+=b.$tb.parent().position().top),c!=f&&(d.css(\\\"top\\\",Math.max(c,0)),d.data(\\\"sticky-top\\\",c),d.data(\\\"sticky-scheduled\\\",c)),d.removeClass(\\\"fr-opacity-0\\\")},100))),e||(d.css(\\\"top\\\",\\\"0\\\"),d.width(b.$tb.parent().width()),d.addClass(\\\"fr-sticky-on\\\"),b.$box.addClass(\\\"fr-sticky-box\\\"))}else clearTimeout(a(c).css(\\\"sticky-timeout\\\")),d.css(\\\"top\\\",\\\"0\\\"),d.css(\\\"position\\\",\\\"\\\"),d.width(\\\"\\\"),d.data(\\\"sticky-top\\\",0),d.removeClass(\\\"fr-sticky-on\\\"),b.$box.removeClass(\\\"fr-sticky-box\\\")}function i(c){if(c.offsetWidth){var d,e,f=a(c),g=f.outerHeight(),h=f.data(\\\"sticky-position\\\"),i=a(\\\"body\\\"==b.opts.scrollableContainer?b.o_win:b.opts.scrollableContainer).outerHeight(),j=0,k=0;\\\"body\\\"!==b.opts.scrollableContainer&&(j=b.$sc.offset().top,k=a(b.o_win).outerHeight()-j-i);var l=\\\"body\\\"==b.opts.scrollableContainer?b.helpers.scrollTop():j,m=f.is(\\\".fr-sticky-on\\\");f.data(\\\"sticky-parent\\\")||f.data(\\\"sticky-parent\\\",f.parent());var n=f.data(\\\"sticky-parent\\\"),o=n.offset().top,p=n.outerHeight();if(f.data(\\\"sticky-offset\\\")||(f.data(\\\"sticky-offset\\\",!0),f.after('<div class=\\\"fr-sticky-dummy\\\" style=\\\"height: '+g+'px;\\\"></div>')),!h){var q=\\\"auto\\\"!==f.css(\\\"top\\\")||\\\"auto\\\"!==f.css(\\\"bottom\\\");q||f.css(\\\"position\\\",\\\"fixed\\\"),h={top:b.node.hasClass(f.get(0),\\\"fr-top\\\"),bottom:b.node.hasClass(f.get(0),\\\"fr-bottom\\\")},q||f.css(\\\"position\\\",\\\"\\\"),f.data(\\\"sticky-position\\\",h),f.data(\\\"top\\\",b.node.hasClass(f.get(0),\\\"fr-top\\\")?f.css(\\\"top\\\"):\\\"auto\\\"),f.data(\\\"bottom\\\",b.node.hasClass(f.get(0),\\\"fr-bottom\\\")?f.css(\\\"bottom\\\"):\\\"auto\\\")}var r=function(){return o<l+d&&o+p-g>=l+d},s=function(){return o+g<l+i-e&&o+p>l+i-e};d=b.helpers.getPX(f.data(\\\"top\\\")),e=b.helpers.getPX(f.data(\\\"bottom\\\"));var t=h.top&&r(),u=h.bottom&&s();t||u?(f.css(\\\"width\\\",n.width()+\\\"px\\\"),m||(f.addClass(\\\"fr-sticky-on\\\"),f.removeClass(\\\"fr-sticky-off\\\"),f.css(\\\"top\\\")&&(\\\"auto\\\"!=f.data(\\\"top\\\")?f.css(\\\"top\\\",b.helpers.getPX(f.data(\\\"top\\\"))+j):f.data(\\\"top\\\",\\\"auto\\\")),f.css(\\\"bottom\\\")&&(\\\"auto\\\"!=f.data(\\\"bottom\\\")?f.css(\\\"bottom\\\",b.helpers.getPX(f.data(\\\"bottom\\\"))+k):f.css(\\\"bottom\\\",\\\"auto\\\")))):b.node.hasClass(f.get(0),\\\"fr-sticky-off\\\")||(f.width(\\\"\\\"),f.removeClass(\\\"fr-sticky-on\\\"),f.addClass(\\\"fr-sticky-off\\\"),f.css(\\\"top\\\")&&\\\"auto\\\"!=f.data(\\\"top\\\")&&h.top&&f.css(\\\"top\\\",0),f.css(\\\"bottom\\\")&&\\\"auto\\\"!=f.data(\\\"bottom\\\")&&h.bottom&&f.css(\\\"bottom\\\",0))}}function j(){var a=document.createElement(\\\"test\\\"),c=a.style;return c.cssText=\\\"position:\\\"+[\\\"-webkit-\\\",\\\"-moz-\\\",\\\"-ms-\\\",\\\"-o-\\\",\\\"\\\"].join(\\\"sticky; position:\\\")+\\\" sticky;\\\",c.position.indexOf(\\\"sticky\\\")!==-1&&!b.helpers.isIOS()&&!b.helpers.isAndroid()&&!b.browser.chrome}function k(){if(!j())if(b._stickyElements=[],b.helpers.isIOS()){var c=function(){b.helpers.requestAnimationFrame()(c);for(var a=0;a<b._stickyElements.length;a++)h(b._stickyElements[a])};c(),b.events.$on(a(b.o_win),\\\"scroll\\\",function(){if(b.core.hasFocus())for(var c=0;c<b._stickyElements.length;c++){var d=a(b._stickyElements[c]),e=d.parent(),f=b.helpers.scrollTop();d.outerHeight()<f-e.offset().top&&(d.addClass(\\\"fr-opacity-0\\\"),d.data(\\\"sticky-top\\\",-1),d.data(\\\"sticky-scheduled\\\",-1))}},!0)}else b.events.$on(a(\\\"body\\\"==b.opts.scrollableContainer?b.o_win:b.opts.scrollableContainer),\\\"scroll\\\",l,!0),b.events.$on(a(b.o_win),\\\"resize\\\",l,!0),b.events.on(\\\"initialized\\\",l),b.events.on(\\\"focus\\\",l),b.events.$on(a(b.o_win),\\\"resize\\\",\\\"textarea\\\",l,!0);b.events.on(\\\"destroy\\\",function(){b._stickyElements=[]})}function l(){if(b._stickyElements)for(var a=0;a<b._stickyElements.length;a++)i(b._stickyElements[a])}function m(a){a.addClass(\\\"fr-sticky\\\"),b.helpers.isIOS()&&a.addClass(\\\"fr-sticky-ios\\\"),j()||(a.removeClass(\\\"fr-sticky\\\"),b._stickyElements.push(a.get(0)))}function n(){k()}return{_init:n,forSelection:f,addSticky:m,refresh:l,at:g,getBoundingRect:c}},a.FE.MODULES.refresh=function(b){function c(a){g(a,!b.undo.canDo())}function d(a){g(a,!b.undo.canRedo())}function e(a){if(b.node.hasClass(a.get(0),\\\"fr-no-refresh\\\"))return!1;for(var c=b.selection.blocks(),d=0;d<c.length;d++){for(var e=c[d].previousSibling;e&&e.nodeType==Node.TEXT_NODE&&0===e.textContent.length;)e=e.previousSibling;if(\\\"LI\\\"!=c[d].tagName||e)return g(a,!1),!0;g(a,!0)}}function f(c){if(b.node.hasClass(c.get(0),\\\"fr-no-refresh\\\"))return!1;for(var d=b.selection.blocks(),e=0;e<d.length;e++){var f=\\\"rtl\\\"==b.opts.direction||\\\"rtl\\\"==a(d[e]).css(\\\"direction\\\")?\\\"margin-right\\\":\\\"margin-left\\\";if(\\\"LI\\\"==d[e].tagName||\\\"LI\\\"==d[e].parentNode.tagName)return g(c,!1),!0;if(b.helpers.getPX(a(d[e]).css(f))>0)return g(c,!1),!0}g(c,!0)}function g(a,b){a.toggleClass(\\\"fr-disabled\\\",b).attr(\\\"aria-disabled\\\",b)}return{undo:c,redo:d,outdent:f,indent:e}},a.extend(a.FE.DEFAULTS,{editInPopup:!1}),a.FE.MODULES.textEdit=function(b){function c(){var a='<div id=\\\"fr-text-edit-'+b.id+'\\\" class=\\\"fr-layer fr-text-edit-layer\\\"><div class=\\\"fr-input-line\\\"><input type=\\\"text\\\" placeholder=\\\"'+b.language.translate(\\\"Text\\\")+'\\\" tabIndex=\\\"1\\\"></div><div class=\\\"fr-action-buttons\\\"><button type=\\\"button\\\" class=\\\"fr-command fr-submit\\\" data-cmd=\\\"updateText\\\" tabIndex=\\\"2\\\">'+b.language.translate(\\\"Update\\\")+\\\"</button></div></div>\\\",c={edit:a};b.popups.create(\\\"text.edit\\\",c)}function d(){var c,d=b.popups.get(\\\"text.edit\\\");c=\\\"INPUT\\\"===b.$el.prop(\\\"tagName\\\")?b.$el.attr(\\\"placeholder\\\"):b.$el.text(),d.find(\\\"input\\\").val(c).trigger(\\\"change\\\"),b.popups.setContainer(\\\"text.edit\\\",a(\\\"body\\\")),b.popups.show(\\\"text.edit\\\",b.$el.offset().left+b.$el.outerWidth()/2,b.$el.offset().top+b.$el.outerHeight(),b.$el.outerHeight())}function e(){b.events.$on(b.$el,b._mouseup,function(){setTimeout(function(){d()},10)})}function f(){var a=b.popups.get(\\\"text.edit\\\"),c=a.find(\\\"input\\\").val();0===c.length&&(c=b.opts.placeholderText),\\\"INPUT\\\"===b.$el.prop(\\\"tagName\\\")?b.$el.attr(\\\"placeholder\\\",c):b.$el.text(c),b.events.trigger(\\\"contentChanged\\\"),b.popups.hide(\\\"text.edit\\\")}function g(){b.opts.editInPopup&&(c(),e())}return{_init:g,update:f}},a.FE.RegisterCommand(\\\"updateText\\\",{focus:!1,undo:!1,callback:function(){this.textEdit.update()}}),a.extend(a.FE.DEFAULTS,{toolbarBottom:!1,toolbarButtons:[\\\"fullscreen\\\",\\\"print\\\",\\\"bold\\\",\\\"italic\\\",\\\"underline\\\",\\\"strikeThrough\\\",\\\"subscript\\\",\\\"superscript\\\",\\\"fontFamily\\\",\\\"fontSize\\\",\\\"|\\\",\\\"specialCharacters\\\",\\\"color\\\",\\\"emoticons\\\",\\\"inlineStyle\\\",\\\"paragraphStyle\\\",\\\"|\\\",\\\"paragraphFormat\\\",\\\"align\\\",\\\"formatOL\\\",\\\"formatUL\\\",\\\"outdent\\\",\\\"indent\\\",\\\"quote\\\",\\\"insertHR\\\",\\\"-\\\",\\\"insertLink\\\",\\\"insertImage\\\",\\\"insertVideo\\\",\\\"insertFile\\\",\\\"insertTable\\\",\\\"undo\\\",\\\"redo\\\",\\\"clearFormatting\\\",\\\"selectAll\\\",\\\"html\\\",\\\"applyFormat\\\",\\\"removeFormat\\\",\\\"help\\\"],toolbarButtonsXS:[\\\"bold\\\",\\\"italic\\\",\\\"fontFamily\\\",\\\"fontSize\\\",\\\"|\\\",\\\"undo\\\",\\\"redo\\\"],toolbarButtonsSM:[\\\"bold\\\",\\\"italic\\\",\\\"underline\\\",\\\"|\\\",\\\"fontFamily\\\",\\\"fontSize\\\",\\\"insertLink\\\",\\\"insertImage\\\",\\\"table\\\",\\\"|\\\",\\\"undo\\\",\\\"redo\\\"],toolbarButtonsMD:[\\\"fullscreen\\\",\\\"bold\\\",\\\"italic\\\",\\\"underline\\\",\\\"fontFamily\\\",\\\"fontSize\\\",\\\"color\\\",\\\"paragraphStyle\\\",\\\"paragraphFormat\\\",\\\"align\\\",\\\"formatOL\\\",\\\"formatUL\\\",\\\"outdent\\\",\\\"indent\\\",\\\"quote\\\",\\\"insertHR\\\",\\\"-\\\",\\\"insertLink\\\",\\\"insertImage\\\",\\\"insertVideo\\\",\\\"insertFile\\\",\\\"insertTable\\\",\\\"undo\\\",\\\"redo\\\",\\\"clearFormatting\\\"],toolbarContainer:null,toolbarInline:!1,toolbarSticky:!0,toolbarStickyOffset:0,toolbarVisibleWithoutSelection:!1}),a.FE.MODULES.toolbar=function(b){function c(a,b){for(var c=0;c<b.length;c++)\\\"-\\\"!=b[c]&&\\\"|\\\"!=b[c]&&a.indexOf(b[c])<0&&a.push(b[c])}function d(){var d=a.merge([],e());c(d,b.opts.toolbarButtonsXS||[]),c(d,b.opts.toolbarButtonsSM||[]),c(d,b.opts.toolbarButtonsMD||[]),c(d,b.opts.toolbarButtons);for(var f=d.length-1;f>=0;f--)\\\"-\\\"!=d[f]&&\\\"|\\\"!=d[f]&&d.indexOf(d[f])<f&&d.splice(f,1);var g=b.button.buildList(d,e());b.$tb.append(g),b.button.bindCommands(b.$tb)}function e(){var a=b.helpers.screenSize();return v[a]}function f(){var a=e();b.$tb.find(\\\".fr-separator\\\").remove(),b.$tb.find(\\\"> .fr-command\\\").addClass(\\\"fr-hidden\\\");for(var c=0;c<a.length;c++)if(\\\"|\\\"==a[c]||\\\"-\\\"==a[c])b.$tb.append(b.button.buildList([a[c]]));else{var d=b.$tb.find('> .fr-command[data-cmd=\\\"'+a[c]+'\\\"]'),f=null;b.node.hasClass(d.next().get(0),\\\"fr-dropdown-menu\\\")&&(f=d.next()),d.removeClass(\\\"fr-hidden\\\").appendTo(b.$tb),f&&f.appendTo(b.$tb)}}function g(){b.events.$on(a(b.o_win),\\\"resize\\\",f),b.events.$on(a(b.o_win),\\\"orientationchange\\\",f)}function h(c,d){setTimeout(function(){if((!c||c.which!=a.FE.KEYCODE.ESC)&&b.selection.inEditor()&&b.core.hasFocus()&&!b.popups.areVisible()&&(b.opts.toolbarVisibleWithoutSelection||!b.selection.isCollapsed()&&!b.keys.isIME()||d)){if(b.$tb.data(\\\"instance\\\",b),b.events.trigger(\\\"toolbar.show\\\",[c])===!1)return!1;b.$tb.show(),b.opts.toolbarContainer||b.position.forSelection(b.$tb),b.opts.zIndex>1?b.$tb.css(\\\"z-index\\\",b.opts.zIndex+1):b.$tb.css(\\\"z-index\\\",null)}},0)}function i(){var a=b.button.getButtons(\\\".fr-dropdown.fr-active\\\");return!!a.next().find(b.o_doc.activeElement).length||void(b.events.trigger(\\\"toolbar.hide\\\")!==!1&&b.$tb.hide())}function j(){return b.events.trigger(\\\"toolbar.show\\\")!==!1&&void b.$tb.show()}function k(c){clearTimeout(w),c&&c.which==a.FE.KEYCODE.ESC||(w=setTimeout(h,b.opts.typingTimer))}function l(){b.events.on(\\\"window.mousedown\\\",i),b.events.on(\\\"keydown\\\",i),b.events.on(\\\"blur\\\",i),b.events.on(\\\"window.mouseup\\\",h),b.helpers.isMobile()?b.helpers.isIOS()||(b.events.on(\\\"window.touchend\\\",h),b.browser.mozilla&&setInterval(h,200)):b.events.on(\\\"window.keyup\\\",k),b.events.on(\\\"keydown\\\",function(b){b&&b.which==a.FE.KEYCODE.ESC&&i()}),b.events.on(\\\"keydown\\\",function(b){if(b.which==a.FE.KEYCODE.ALT)return b.stopPropagation(),!1},!0),b.events.$on(b.$wp,\\\"scroll.toolbar\\\",h),b.events.on(\\\"commands.after\\\",h),b.helpers.isMobile()&&(b.events.$on(b.$doc,\\\"selectionchange\\\",k),b.events.$on(b.$doc,\\\"orientationchange\\\",h))}function m(){b.opts.toolbarInline?(b.$sc.append(b.$tb),b.$tb.data(\\\"container\\\",b.$sc),b.$tb.addClass(\\\"fr-inline\\\"),b.$tb.prepend('<span class=\\\"fr-arrow\\\"></span>'),l(),b.opts.toolbarBottom=!1):(b.opts.toolbarBottom&&!b.helpers.isIOS()?(b.$box.append(b.$tb),b.$tb.addClass(\\\"fr-bottom\\\"),b.$box.addClass(\\\"fr-bottom\\\")):(b.opts.toolbarBottom=!1,b.$box.prepend(b.$tb),b.$tb.addClass(\\\"fr-top\\\"),b.$box.addClass(\\\"fr-top\\\")),b.$tb.addClass(\\\"fr-basic\\\"),b.opts.toolbarSticky&&(b.opts.toolbarStickyOffset&&(b.opts.toolbarBottom?b.$tb.css(\\\"bottom\\\",b.opts.toolbarStickyOffset):b.$tb.css(\\\"top\\\",b.opts.toolbarStickyOffset)),b.position.addSticky(b.$tb)))}function n(){b.$tb.html(\\\"\\\").removeData().remove(),b.$tb=null}function o(){b.$box.removeClass(\\\"fr-top fr-bottom fr-inline fr-basic\\\"),b.$box.find(\\\".fr-sticky-dummy\\\").remove()}function p(){b.opts.theme&&b.$tb.addClass(b.opts.theme+\\\"-theme\\\"),b.opts.zIndex>1&&b.$tb.css(\\\"z-index\\\",b.opts.zIndex+1),\\\"auto\\\"!=b.opts.direction&&b.$tb.removeClass(\\\"fr-ltr fr-rtl\\\").addClass(\\\"fr-\\\"+b.opts.direction),b.helpers.isMobile()?b.$tb.addClass(\\\"fr-mobile\\\"):b.$tb.addClass(\\\"fr-desktop\\\"),b.opts.toolbarContainer?(b.opts.toolbarInline&&(l(),i()),b.opts.toolbarBottom?b.$tb.addClass(\\\"fr-bottom\\\"):b.$tb.addClass(\\\"fr-top\\\")):m(),t=b.$tb.get(0).ownerDocument,u=\\\"defaultView\\\"in t?t.defaultView:t.parentWindow,d(),g(),b.accessibility.registerToolbar(b.$tb),b.events.$on(b.$tb,b._mousedown+\\\" \\\"+b._mouseup,function(a){var c=a.originalEvent?a.originalEvent.target||a.originalEvent.originalTarget:null;if(c&&\\\"INPUT\\\"!=c.tagName&&!b.edit.isDisabled())return a.stopPropagation(),a.preventDefault(),!1},!0)}function q(){return b.$sc=a(b.opts.scrollableContainer),!!b.$wp&&(b.opts.toolbarContainer?(b.shared.$tb?(b.$tb=b.shared.$tb,b.opts.toolbarInline&&l()):(b.shared.$tb=a('<div class=\\\"fr-toolbar\\\"></div>'),b.$tb=b.shared.$tb,a(b.opts.toolbarContainer).append(b.$tb),p(),b.$tb.data(\\\"instance\\\",b)),b.opts.toolbarInline?b.$box.addClass(\\\"fr-inline\\\"):b.$box.addClass(\\\"fr-basic\\\"),b.events.on(\\\"focus\\\",function(){b.$tb.data(\\\"instance\\\",b)},!0),b.opts.toolbarInline=!1):b.opts.toolbarInline?(b.$box.addClass(\\\"fr-inline\\\"),b.shared.$tb?(b.$tb=b.shared.$tb,l()):(b.shared.$tb=a('<div class=\\\"fr-toolbar\\\"></div>'),b.$tb=b.shared.$tb,p())):(b.$box.addClass(\\\"fr-basic\\\"),b.$tb=a('<div class=\\\"fr-toolbar\\\"></div>'),p(),b.$tb.data(\\\"instance\\\",b)),b.events.on(\\\"destroy\\\",o,!0),void b.events.on(b.opts.toolbarInline||b.opts.toolbarContainer?\\\"shared.destroy\\\":\\\"destroy\\\",n,!0))}function r(){!x&&b.$tb&&(b.$tb.find(\\\"> .fr-command\\\").addClass(\\\"fr-disabled fr-no-refresh\\\").attr(\\\"aria-disabled\\\",!0),x=!0)}function s(){x&&b.$tb&&(b.$tb.find(\\\"> .fr-command\\\").removeClass(\\\"fr-disabled fr-no-refresh\\\").attr(\\\"aria-disabled\\\",!1),x=!1),b.button.bulkRefresh()}var t,u,v=[];v[a.FE.XS]=b.opts.toolbarButtonsXS||b.opts.toolbarButtons,v[a.FE.SM]=b.opts.toolbarButtonsSM||b.opts.toolbarButtons,v[a.FE.MD]=b.opts.toolbarButtonsMD||b.opts.toolbarButtons,v[a.FE.LG]=b.opts.toolbarButtons;var w=null,x=!1;return{_init:q,hide:i,show:j,showInline:h,disable:r,enable:s}}});\"//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL34vZnJvYWxhLWVkaXRvci9qcy9mcm9hbGFfZWRpdG9yLm1pbi5qcz81NDRiIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gXCIvKiFcXG4gKiBmcm9hbGFfZWRpdG9yIHYyLjUuMSAoaHR0cHM6Ly93d3cuZnJvYWxhLmNvbS93eXNpd3lnLWVkaXRvcilcXG4gKiBMaWNlbnNlIGh0dHBzOi8vZnJvYWxhLmNvbS93eXNpd3lnLWVkaXRvci90ZXJtcy9cXG4gKiBDb3B5cmlnaHQgMjAxNC0yMDE3IEZyb2FsYSBMYWJzXFxuICovXFxuXFxuIWZ1bmN0aW9uKGEpe1xcXCJmdW5jdGlvblxcXCI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQ/ZGVmaW5lKFtcXFwianF1ZXJ5XFxcIl0sYSk6XFxcIm9iamVjdFxcXCI9PXR5cGVvZiBtb2R1bGUmJm1vZHVsZS5leHBvcnRzP21vZHVsZS5leHBvcnRzPWZ1bmN0aW9uKGIsYyl7cmV0dXJuIHZvaWQgMD09PWMmJihjPVxcXCJ1bmRlZmluZWRcXFwiIT10eXBlb2Ygd2luZG93P3JlcXVpcmUoXFxcImpxdWVyeVxcXCIpOnJlcXVpcmUoXFxcImpxdWVyeVxcXCIpKGIpKSxhKGMpfTphKHdpbmRvdy5qUXVlcnkpfShmdW5jdGlvbihhKXt2YXIgYj1mdW5jdGlvbihjLGQpe3RoaXMuaWQ9KythLkZFLklELHRoaXMub3B0cz1hLmV4dGVuZCghMCx7fSxhLmV4dGVuZCh7fSxiLkRFRkFVTFRTLFxcXCJvYmplY3RcXFwiPT10eXBlb2YgZCYmZCkpO3ZhciBlPUpTT04uc3RyaW5naWZ5KHRoaXMub3B0cyk7YS5GRS5PUFRTX01BUFBJTkdbZV09YS5GRS5PUFRTX01BUFBJTkdbZV18fHRoaXMuaWQsdGhpcy5zaWQ9YS5GRS5PUFRTX01BUFBJTkdbZV0sYS5GRS5TSEFSRURbdGhpcy5zaWRdPWEuRkUuU0hBUkVEW3RoaXMuc2lkXXx8e30sdGhpcy5zaGFyZWQ9YS5GRS5TSEFSRURbdGhpcy5zaWRdLHRoaXMuc2hhcmVkLmNvdW50PSh0aGlzLnNoYXJlZC5jb3VudHx8MCkrMSx0aGlzLiRvZWw9YShjKSx0aGlzLiRvZWwuZGF0YShcXFwiZnJvYWxhLmVkaXRvclxcXCIsdGhpcyksdGhpcy5vX2RvYz1jLm93bmVyRG9jdW1lbnQsdGhpcy5vX3dpbj1cXFwiZGVmYXVsdFZpZXdcXFwiaW4gdGhpcy5vX2RvYz90aGlzLm9fZG9jLmRlZmF1bHRWaWV3OnRoaXMub19kb2MucGFyZW50V2luZG93O3ZhciBmPWEodGhpcy5vX3dpbikuc2Nyb2xsVG9wKCk7dGhpcy4kb2VsLm9uKFxcXCJmcm9hbGEuZG9Jbml0XFxcIixhLnByb3h5KGZ1bmN0aW9uKCl7dGhpcy4kb2VsLm9mZihcXFwiZnJvYWxhLmRvSW5pdFxcXCIpLHRoaXMuZG9jPXRoaXMuJGVsLmdldCgwKS5vd25lckRvY3VtZW50LHRoaXMud2luPVxcXCJkZWZhdWx0Vmlld1xcXCJpbiB0aGlzLmRvYz90aGlzLmRvYy5kZWZhdWx0Vmlldzp0aGlzLmRvYy5wYXJlbnRXaW5kb3csdGhpcy4kZG9jPWEodGhpcy5kb2MpLHRoaXMuJHdpbj1hKHRoaXMud2luKSx0aGlzLm9wdHMucGx1Z2luc0VuYWJsZWR8fCh0aGlzLm9wdHMucGx1Z2luc0VuYWJsZWQ9T2JqZWN0LmtleXMoYS5GRS5QTFVHSU5TKSksdGhpcy5vcHRzLmluaXRPbkNsaWNrPyh0aGlzLmxvYWQoYS5GRS5NT0RVTEVTKSx0aGlzLiRlbC5vbihcXFwidG91Y2hzdGFydC5pbml0XFxcIixmdW5jdGlvbigpe2EodGhpcykuZGF0YShcXFwidG91Y2hlZFxcXCIsITApfSksdGhpcy4kZWwub24oXFxcInRvdWNobW92ZS5pbml0XFxcIixmdW5jdGlvbigpe2EodGhpcykucmVtb3ZlRGF0YShcXFwidG91Y2hlZFxcXCIpfSksdGhpcy4kZWwub24oXFxcIm1vdXNlZG93bi5pbml0IHRvdWNoZW5kLmluaXQgZHJhZ2VudGVyLmluaXQgZm9jdXMuaW5pdFxcXCIsYS5wcm94eShmdW5jdGlvbihiKXtpZihcXFwidG91Y2hlbmRcXFwiPT1iLnR5cGUmJiF0aGlzLiRlbC5kYXRhKFxcXCJ0b3VjaGVkXFxcIikpcmV0dXJuITA7aWYoMT09PWIud2hpY2h8fCFiLndoaWNoKXt0aGlzLiRlbC5vZmYoXFxcIm1vdXNlZG93bi5pbml0IHRvdWNoc3RhcnQuaW5pdCB0b3VjaG1vdmUuaW5pdCB0b3VjaGVuZC5pbml0IGRyYWdlbnRlci5pbml0IGZvY3VzLmluaXRcXFwiKSx0aGlzLmxvYWQoYS5GRS5NT0RVTEVTKSx0aGlzLmxvYWQoYS5GRS5QTFVHSU5TKTt2YXIgYz1iLm9yaWdpbmFsRXZlbnQmJmIub3JpZ2luYWxFdmVudC5vcmlnaW5hbFRhcmdldDtjJiZcXFwiSU1HXFxcIj09Yy50YWdOYW1lJiZhKGMpLnRyaWdnZXIoXFxcIm1vdXNlZG93blxcXCIpLFxcXCJ1bmRlZmluZWRcXFwiPT10eXBlb2YgdGhpcy51bCYmdGhpcy5kZXN0cm95KCksXFxcInRvdWNoZW5kXFxcIj09Yi50eXBlJiZ0aGlzLmltYWdlJiZiLm9yaWdpbmFsRXZlbnQmJmIub3JpZ2luYWxFdmVudC50YXJnZXQmJmEoYi5vcmlnaW5hbEV2ZW50LnRhcmdldCkuaXMoXFxcImltZ1xcXCIpJiZzZXRUaW1lb3V0KGEucHJveHkoZnVuY3Rpb24oKXt0aGlzLmltYWdlLmVkaXQoYShiLm9yaWdpbmFsRXZlbnQudGFyZ2V0KSl9LHRoaXMpLDEwMCksdGhpcy5yZWFkeT0hMCx0aGlzLmV2ZW50cy50cmlnZ2VyKFxcXCJpbml0aWFsaXplZFxcXCIpfX0sdGhpcykpKToodGhpcy5sb2FkKGEuRkUuTU9EVUxFUyksdGhpcy5sb2FkKGEuRkUuUExVR0lOUyksYSh0aGlzLm9fd2luKS5zY3JvbGxUb3AoZiksXFxcInVuZGVmaW5lZFxcXCI9PXR5cGVvZiB0aGlzLnVsJiZ0aGlzLmRlc3Ryb3koKSx0aGlzLnJlYWR5PSEwLHRoaXMuZXZlbnRzLnRyaWdnZXIoXFxcImluaXRpYWxpemVkXFxcIikpfSx0aGlzKSksdGhpcy5faW5pdCgpfTtiLkRFRkFVTFRTPXtpbml0T25DbGljazohMSxwbHVnaW5zRW5hYmxlZDpudWxsfSxiLk1PRFVMRVM9e30sYi5QTFVHSU5TPXt9LGIuVkVSU0lPTj1cXFwiMi41LjFcXFwiLGIuSU5TVEFOQ0VTPVtdLGIuT1BUU19NQVBQSU5HPXt9LGIuU0hBUkVEPXt9LGIuSUQ9MCxiLnByb3RvdHlwZS5faW5pdD1mdW5jdGlvbigpe3ZhciBiPXRoaXMuJG9lbC5wcm9wKFxcXCJ0YWdOYW1lXFxcIik7dGhpcy4kb2VsLmNsb3Nlc3QoXFxcImxhYmVsXFxcIikubGVuZ3RoPj0xO3ZhciBjPWEucHJveHkoZnVuY3Rpb24oKXtcXFwiVEVYVEFSRUFcXFwiIT1iJiYodGhpcy5fb3JpZ2luYWxfaHRtbD10aGlzLl9vcmlnaW5hbF9odG1sfHx0aGlzLiRvZWwuaHRtbCgpKSx0aGlzLiRib3g9dGhpcy4kYm94fHx0aGlzLiRvZWwsdGhpcy5vcHRzLmZ1bGxQYWdlJiYodGhpcy5vcHRzLmlmcmFtZT0hMCksdGhpcy5vcHRzLmlmcmFtZT8odGhpcy4kaWZyYW1lPWEoJzxpZnJhbWUgc3JjPVxcXCJhYm91dDpibGFua1xcXCIgZnJhbWVCb3JkZXI9XFxcIjBcXFwiPicpLHRoaXMuJHdwPWEoXFxcIjxkaXY+PC9kaXY+XFxcIiksdGhpcy4kYm94Lmh0bWwodGhpcy4kd3ApLHRoaXMuJHdwLmFwcGVuZCh0aGlzLiRpZnJhbWUpLHRoaXMuJGlmcmFtZS5nZXQoMCkuY29udGVudFdpbmRvdy5kb2N1bWVudC5vcGVuKCksdGhpcy4kaWZyYW1lLmdldCgwKS5jb250ZW50V2luZG93LmRvY3VtZW50LndyaXRlKFxcXCI8IURPQ1RZUEUgaHRtbD5cXFwiKSx0aGlzLiRpZnJhbWUuZ2V0KDApLmNvbnRlbnRXaW5kb3cuZG9jdW1lbnQud3JpdGUoXFxcIjxodG1sPjxoZWFkPjwvaGVhZD48Ym9keT48L2JvZHk+PC9odG1sPlxcXCIpLHRoaXMuJGlmcmFtZS5nZXQoMCkuY29udGVudFdpbmRvdy5kb2N1bWVudC5jbG9zZSgpLHRoaXMuJGVsPXRoaXMuJGlmcmFtZS5jb250ZW50cygpLmZpbmQoXFxcImJvZHlcXFwiKSx0aGlzLmVsPXRoaXMuJGVsLmdldCgwKSx0aGlzLiRoZWFkPXRoaXMuJGlmcmFtZS5jb250ZW50cygpLmZpbmQoXFxcImhlYWRcXFwiKSx0aGlzLiRodG1sPXRoaXMuJGlmcmFtZS5jb250ZW50cygpLmZpbmQoXFxcImh0bWxcXFwiKSx0aGlzLmlmcmFtZV9kb2N1bWVudD10aGlzLiRpZnJhbWUuZ2V0KDApLmNvbnRlbnRXaW5kb3cuZG9jdW1lbnQsdGhpcy4kb2VsLnRyaWdnZXIoXFxcImZyb2FsYS5kb0luaXRcXFwiKSk6KHRoaXMuJGVsPWEoXFxcIjxkaXY+PC9kaXY+XFxcIiksdGhpcy5lbD10aGlzLiRlbC5nZXQoMCksdGhpcy4kd3A9YShcXFwiPGRpdj48L2Rpdj5cXFwiKS5hcHBlbmQodGhpcy4kZWwpLHRoaXMuJGJveC5odG1sKHRoaXMuJHdwKSx0aGlzLiRvZWwudHJpZ2dlcihcXFwiZnJvYWxhLmRvSW5pdFxcXCIpKX0sdGhpcyksZD1hLnByb3h5KGZ1bmN0aW9uKCl7dGhpcy4kYm94PWEoXFxcIjxkaXY+XFxcIiksdGhpcy4kb2VsLmJlZm9yZSh0aGlzLiRib3gpLmhpZGUoKSx0aGlzLl9vcmlnaW5hbF9odG1sPXRoaXMuJG9lbC52YWwoKSx0aGlzLiRvZWwucGFyZW50cyhcXFwiZm9ybVxcXCIpLm9uKFxcXCJzdWJtaXQuXFxcIit0aGlzLmlkLGEucHJveHkoZnVuY3Rpb24oKXt0aGlzLmV2ZW50cy50cmlnZ2VyKFxcXCJmb3JtLnN1Ym1pdFxcXCIpfSx0aGlzKSksdGhpcy4kb2VsLnBhcmVudHMoXFxcImZvcm1cXFwiKS5vbihcXFwicmVzZXQuXFxcIit0aGlzLmlkLGEucHJveHkoZnVuY3Rpb24oKXt0aGlzLmV2ZW50cy50cmlnZ2VyKFxcXCJmb3JtLnJlc2V0XFxcIil9LHRoaXMpKSxjKCl9LHRoaXMpLGU9YS5wcm94eShmdW5jdGlvbigpe3RoaXMuJGVsPXRoaXMuJG9lbCx0aGlzLmVsPXRoaXMuJGVsLmdldCgwKSx0aGlzLiRlbC5hdHRyKFxcXCJjb250ZW50ZWRpdGFibGVcXFwiLCEwKS5jc3MoXFxcIm91dGxpbmVcXFwiLFxcXCJub25lXFxcIikuY3NzKFxcXCJkaXNwbGF5XFxcIixcXFwiaW5saW5lLWJsb2NrXFxcIiksdGhpcy5vcHRzLm11bHRpTGluZT0hMSx0aGlzLm9wdHMudG9vbGJhcklubGluZT0hMSx0aGlzLiRvZWwudHJpZ2dlcihcXFwiZnJvYWxhLmRvSW5pdFxcXCIpfSx0aGlzKSxmPWEucHJveHkoZnVuY3Rpb24oKXt0aGlzLiRlbD10aGlzLiRvZWwsdGhpcy5lbD10aGlzLiRlbC5nZXQoMCksdGhpcy5vcHRzLnRvb2xiYXJJbmxpbmU9ITEsdGhpcy4kb2VsLnRyaWdnZXIoXFxcImZyb2FsYS5kb0luaXRcXFwiKX0sdGhpcyksZz1hLnByb3h5KGZ1bmN0aW9uKCl7dGhpcy4kZWw9dGhpcy4kb2VsLHRoaXMuZWw9dGhpcy4kZWwuZ2V0KDApLHRoaXMub3B0cy50b29sYmFySW5saW5lPSExLHRoaXMuJG9lbC5vbihcXFwiY2xpY2sucG9wdXBcXFwiLGZ1bmN0aW9uKGEpe2EucHJldmVudERlZmF1bHQoKX0pLHRoaXMuJG9lbC50cmlnZ2VyKFxcXCJmcm9hbGEuZG9Jbml0XFxcIil9LHRoaXMpO3RoaXMub3B0cy5lZGl0SW5Qb3B1cD9nKCk6XFxcIlRFWFRBUkVBXFxcIj09Yj9kKCk6XFxcIkFcXFwiPT1iP2UoKTpcXFwiSU1HXFxcIj09Yj9mKCk6XFxcIkJVVFRPTlxcXCI9PWJ8fFxcXCJJTlBVVFxcXCI9PWI/KHRoaXMub3B0cy5lZGl0SW5Qb3B1cD0hMCx0aGlzLm9wdHMudG9vbGJhcklubGluZT0hMSxnKCkpOmMoKX0sYi5wcm90b3R5cGUubG9hZD1mdW5jdGlvbihiKXtmb3IodmFyIGMgaW4gYilpZihiLmhhc093blByb3BlcnR5KGMpKXtpZih0aGlzW2NdKWNvbnRpbnVlO2lmKGEuRkUuUExVR0lOU1tjXSYmdGhpcy5vcHRzLnBsdWdpbnNFbmFibGVkLmluZGV4T2YoYyk8MCljb250aW51ZTtpZih0aGlzW2NdPW5ldyBiW2NdKHRoaXMpLHRoaXNbY10uX2luaXQmJih0aGlzW2NdLl9pbml0KCksdGhpcy5vcHRzLmluaXRPbkNsaWNrJiZcXFwiY29yZVxcXCI9PWMpKXJldHVybiExfX0sYi5wcm90b3R5cGUuZGVzdHJveT1mdW5jdGlvbigpe3RoaXMuc2hhcmVkLmNvdW50LS0sdGhpcy5ldmVudHMuJG9mZigpO3ZhciBiPXRoaXMuaHRtbC5nZXQoKTtpZih0aGlzLmV2ZW50cy50cmlnZ2VyKFxcXCJkZXN0cm95XFxcIixbXSwhMCksdGhpcy5ldmVudHMudHJpZ2dlcihcXFwic2hhcmVkLmRlc3Ryb3lcXFwiLHZvaWQgMCwhMCksMD09PXRoaXMuc2hhcmVkLmNvdW50KXtmb3IodmFyIGMgaW4gdGhpcy5zaGFyZWQpdGhpcy5zaGFyZWQuaGFzT3duUHJvcGVydHkoYykmJihudWxsPT10aGlzLnNoYXJlZFtjXSxhLkZFLlNIQVJFRFt0aGlzLnNpZF1bY109bnVsbCk7YS5GRS5TSEFSRURbdGhpcy5zaWRdPXt9fXRoaXMuJG9lbC5wYXJlbnRzKFxcXCJmb3JtXFxcIikub2ZmKFxcXCIuXFxcIit0aGlzLmlkKSx0aGlzLiRvZWwub2ZmKFxcXCJjbGljay5wb3B1cFxcXCIpLHRoaXMuJG9lbC5yZW1vdmVEYXRhKFxcXCJmcm9hbGEuZWRpdG9yXFxcIiksdGhpcy4kb2VsLm9mZihcXFwiZnJvYWxhRWRpdG9yXFxcIiksdGhpcy5jb3JlLmRlc3Ryb3koYiksYS5GRS5JTlNUQU5DRVMuc3BsaWNlKGEuRkUuSU5TVEFOQ0VTLmluZGV4T2YodGhpcyksMSl9LGEuZm4uZnJvYWxhRWRpdG9yPWZ1bmN0aW9uKGMpe2Zvcih2YXIgZD1bXSxlPTA7ZTxhcmd1bWVudHMubGVuZ3RoO2UrKylkLnB1c2goYXJndW1lbnRzW2VdKTtpZihcXFwic3RyaW5nXFxcIj09dHlwZW9mIGMpe3ZhciBmPVtdO3JldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKXt2YXIgYj1hKHRoaXMpLGU9Yi5kYXRhKFxcXCJmcm9hbGEuZWRpdG9yXFxcIik7aWYoZSl7dmFyIGcsaDtpZihjLmluZGV4T2YoXFxcIi5cXFwiKT4wJiZlW2Muc3BsaXQoXFxcIi5cXFwiKVswXV0/KGVbYy5zcGxpdChcXFwiLlxcXCIpWzBdXSYmKGc9ZVtjLnNwbGl0KFxcXCIuXFxcIilbMF1dKSxoPWMuc3BsaXQoXFxcIi5cXFwiKVsxXSk6KGc9ZSxoPWMuc3BsaXQoXFxcIi5cXFwiKVswXSksIWdbaF0pcmV0dXJuIGEuZXJyb3IoXFxcIk1ldGhvZCBcXFwiK2MrXFxcIiBkb2VzIG5vdCBleGlzdCBpbiBGcm9hbGEgRWRpdG9yLlxcXCIpO3ZhciBpPWdbaF0uYXBwbHkoZSxkLnNsaWNlKDEpKTt2b2lkIDA9PT1pP2YucHVzaCh0aGlzKTowPT09Zi5sZW5ndGgmJmYucHVzaChpKX19KSwxPT1mLmxlbmd0aD9mWzBdOmZ9aWYoXFxcIm9iamVjdFxcXCI9PXR5cGVvZiBjfHwhYylyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCl7dmFyIGQ9YSh0aGlzKS5kYXRhKFxcXCJmcm9hbGEuZWRpdG9yXFxcIik7aWYoIWQpe3ZhciBlPXRoaXM7bmV3IGIoZSxjKX19KX0sYS5mbi5mcm9hbGFFZGl0b3IuQ29uc3RydWN0b3I9YixhLkZyb2FsYUVkaXRvcj1iLGEuRkU9YixhLkZFLlhTPTAsYS5GRS5TTT0xLGEuRkUuTUQ9MixhLkZFLkxHPTMsYS5GRS5NT0RVTEVTLmhlbHBlcnM9ZnVuY3Rpb24oYil7ZnVuY3Rpb24gYygpe3ZhciBhLGIsYz0tMTtyZXR1cm5cXFwiTWljcm9zb2Z0IEludGVybmV0IEV4cGxvcmVyXFxcIj09bmF2aWdhdG9yLmFwcE5hbWU/KGE9bmF2aWdhdG9yLnVzZXJBZ2VudCxiPW5ldyBSZWdFeHAoXFxcIk1TSUUgKFswLTldezEsfVtcXFxcXFxcXC4wLTldezAsfSlcXFwiKSxudWxsIT09Yi5leGVjKGEpJiYoYz1wYXJzZUZsb2F0KFJlZ0V4cC4kMSkpKTpcXFwiTmV0c2NhcGVcXFwiPT1uYXZpZ2F0b3IuYXBwTmFtZSYmKGE9bmF2aWdhdG9yLnVzZXJBZ2VudCxiPW5ldyBSZWdFeHAoXFxcIlRyaWRlbnQvLipydjooWzAtOV17MSx9W1xcXFxcXFxcLjAtOV17MCx9KVxcXCIpLG51bGwhPT1iLmV4ZWMoYSkmJihjPXBhcnNlRmxvYXQoUmVnRXhwLiQxKSkpLGN9ZnVuY3Rpb24gZCgpe3ZhciBhPXt9LGI9YygpO2lmKGI+MClhLm1zaWU9ITA7ZWxzZXt2YXIgZD1uYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCksZT0vKGVkZ2UpWyBcXFxcL10oW1xcXFx3Ll0rKS8uZXhlYyhkKXx8LyhjaHJvbWUpWyBcXFxcL10oW1xcXFx3Ll0rKS8uZXhlYyhkKXx8Lyh3ZWJraXQpWyBcXFxcL10oW1xcXFx3Ll0rKS8uZXhlYyhkKXx8LyhvcGVyYSkoPzouKnZlcnNpb258KVsgXFxcXC9dKFtcXFxcdy5dKykvLmV4ZWMoZCl8fC8obXNpZSkgKFtcXFxcdy5dKykvLmV4ZWMoZCl8fGQuaW5kZXhPZihcXFwiY29tcGF0aWJsZVxcXCIpPDAmJi8obW96aWxsYSkoPzouKj8gcnY6KFtcXFxcdy5dKyl8KS8uZXhlYyhkKXx8W10sZj17YnJvd3NlcjplWzFdfHxcXFwiXFxcIix2ZXJzaW9uOmVbMl18fFxcXCIwXFxcIn07ZVsxXSYmKGFbZi5icm93c2VyXT0hMCksYS5jaHJvbWU/YS53ZWJraXQ9ITA6YS53ZWJraXQmJihhLnNhZmFyaT0hMCl9cmV0dXJuIGEubXNpZSYmKGEudmVyc2lvbj1iKSxhfWZ1bmN0aW9uIGUoKXtyZXR1cm4vKGlQYWR8aVBob25lfGlQb2QpL2cudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSYmIWgoKX1mdW5jdGlvbiBmKCl7cmV0dXJuLyhBbmRyb2lkKS9nLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkmJiFoKCl9ZnVuY3Rpb24gZygpe3JldHVybi8oQmxhY2tiZXJyeSkvZy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpfWZ1bmN0aW9uIGgoKXtyZXR1cm4vKFdpbmRvd3MgUGhvbmUpL2dpLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCl9ZnVuY3Rpb24gaSgpe3JldHVybiBmKCl8fGUoKXx8ZygpfWZ1bmN0aW9uIGooKXtyZXR1cm4gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZXx8d2luZG93LndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZXx8d2luZG93Lm1velJlcXVlc3RBbmltYXRpb25GcmFtZXx8ZnVuY3Rpb24oYSl7d2luZG93LnNldFRpbWVvdXQoYSwxZTMvNjApfX1mdW5jdGlvbiBrKGEpe3JldHVybiBwYXJzZUludChhLDEwKXx8MH1mdW5jdGlvbiBsKCl7dmFyIGI9YSgnPGRpdiBjbGFzcz1cXFwiZnItdmlzaWJpbGl0eS1oZWxwZXJcXFwiPjwvZGl2PicpLmFwcGVuZFRvKFxcXCJib2R5XFxcIiksYz1rKGIuY3NzKFxcXCJtYXJnaW4tbGVmdFxcXCIpKTtyZXR1cm4gYi5yZW1vdmUoKSxjfWZ1bmN0aW9uIG0oKXtyZXR1cm5cXFwib250b3VjaHN0YXJ0XFxcImluIHdpbmRvd3x8d2luZG93LkRvY3VtZW50VG91Y2gmJmRvY3VtZW50IGluc3RhbmNlb2YgRG9jdW1lbnRUb3VjaH1mdW5jdGlvbiBuKGEpe2lmKCEvXihodHRwcz86fGZ0cHM/OnwpXFxcXC9cXFxcLy9pLnRlc3QoYSkpcmV0dXJuITE7YT1TdHJpbmcoYSkucmVwbGFjZSgvPC9nLFxcXCIlM0NcXFwiKS5yZXBsYWNlKC8+L2csXFxcIiUzRVxcXCIpLnJlcGxhY2UoL1xcXCIvZyxcXFwiJTIyXFxcIikucmVwbGFjZSgvIC9nLFxcXCIlMjBcXFwiKTt2YXIgYj0vKGh0dHB8ZnRwfGh0dHBzKTpcXFxcL1xcXFwvW2EtelxcXFx1MDBhMS1cXFxcdWZmZmYwLTl7fV0rKFxcXFwuW2EtelxcXFx1MDBhMS1cXFxcdWZmZmYwLTl7fV0qKSooW2EtelxcXFx1MDBhMS1cXFxcdWZmZmYwLTkuLEA/Xj0lJmFtcDs6XFxcXC9+KyMtX3t9XSpbYS16XFxcXHUwMGExLVxcXFx1ZmZmZjAtOUA/Xj0lJmFtcDtcXFxcL34rIy1fe31dKT8vZ2k7cmV0dXJuIGIudGVzdChhKX1mdW5jdGlvbiBvKGEpe2lmKC9eKGh0dHBzPzp8ZnRwcz86fClcXFxcL1xcXFwvL2kudGVzdChhKSl7aWYoIW4oYSkmJiFuKFxcXCJodHRwOlxcXCIrYSkpcmV0dXJuXFxcIlxcXCJ9ZWxzZSBhPWVuY29kZVVSSUNvbXBvbmVudChhKS5yZXBsYWNlKC8lMjMvZyxcXFwiI1xcXCIpLnJlcGxhY2UoLyUyRi9nLFxcXCIvXFxcIikucmVwbGFjZSgvJTI1L2csXFxcIiVcXFwiKS5yZXBsYWNlKC9tYWlsdG8lM0EvZ2ksXFxcIm1haWx0bzpcXFwiKS5yZXBsYWNlKC9maWxlJTNBL2dpLFxcXCJmaWxlOlxcXCIpLnJlcGxhY2UoL3NtcyUzQS9naSxcXFwic21zOlxcXCIpLnJlcGxhY2UoL3RlbCUzQS9naSxcXFwidGVsOlxcXCIpLnJlcGxhY2UoL25vdGVzJTNBL2dpLFxcXCJub3RlczpcXFwiKS5yZXBsYWNlKC9kYXRhJTNBaW1hZ2UvZ2ksXFxcImRhdGE6aW1hZ2VcXFwiKS5yZXBsYWNlKC9ibG9iJTNBL2dpLFxcXCJibG9iOlxcXCIpLnJlcGxhY2UoL3dlYmtpdC1mYWtlLXVybCUzQS9naSxcXFwid2Via2l0LWZha2UtdXJsOlxcXCIpLnJlcGxhY2UoLyUzRi9nLFxcXCI/XFxcIikucmVwbGFjZSgvJTNEL2csXFxcIj1cXFwiKS5yZXBsYWNlKC8lMjYvZyxcXFwiJlxcXCIpLnJlcGxhY2UoLyZhbXA7L2csXFxcIiZcXFwiKS5yZXBsYWNlKC8lMkMvZyxcXFwiLFxcXCIpLnJlcGxhY2UoLyUzQi9nLFxcXCI7XFxcIikucmVwbGFjZSgvJTJCL2csXFxcIitcXFwiKS5yZXBsYWNlKC8lNDAvZyxcXFwiQFxcXCIpLnJlcGxhY2UoLyU1Qi9nLFxcXCJbXFxcIikucmVwbGFjZSgvJTVEL2csXFxcIl1cXFwiKS5yZXBsYWNlKC8lN0IvZyxcXFwie1xcXCIpLnJlcGxhY2UoLyU3RC9nLFxcXCJ9XFxcIik7cmV0dXJuIGF9ZnVuY3Rpb24gcChhKXtyZXR1cm4gYSYmIWEucHJvcGVydHlJc0VudW1lcmFibGUoXFxcImxlbmd0aFxcXCIpJiZcXFwib2JqZWN0XFxcIj09dHlwZW9mIGEmJlxcXCJudW1iZXJcXFwiPT10eXBlb2YgYS5sZW5ndGh9ZnVuY3Rpb24gcShhKXtmdW5jdGlvbiBiKGEpe3JldHVybihcXFwiMFxcXCIrcGFyc2VJbnQoYSwxMCkudG9TdHJpbmcoMTYpKS5zbGljZSgtMil9dHJ5e3JldHVybiBhJiZcXFwidHJhbnNwYXJlbnRcXFwiIT09YT8vXiNbMC05QS1GXXs2fSQvaS50ZXN0KGEpP2E6KGE9YS5tYXRjaCgvXnJnYlxcXFwoKFxcXFxkKyksXFxcXHMqKFxcXFxkKyksXFxcXHMqKFxcXFxkKylcXFxcKSQvKSwoXFxcIiNcXFwiK2IoYVsxXSkrYihhWzJdKStiKGFbM10pKS50b1VwcGVyQ2FzZSgpKTpcXFwiXFxcIn1jYXRjaChjKXtyZXR1cm4gbnVsbH19ZnVuY3Rpb24gcihhKXt2YXIgYj0vXiM/KFthLWZcXFxcZF0pKFthLWZcXFxcZF0pKFthLWZcXFxcZF0pJC9pO2E9YS5yZXBsYWNlKGIsZnVuY3Rpb24oYSxiLGMsZCl7cmV0dXJuIGIrYitjK2MrZCtkfSk7dmFyIGM9L14jPyhbYS1mXFxcXGRdezJ9KShbYS1mXFxcXGRdezJ9KShbYS1mXFxcXGRdezJ9KSQvaS5leGVjKGEpO3JldHVybiBjP1xcXCJyZ2IoXFxcIitwYXJzZUludChjWzFdLDE2KStcXFwiLCBcXFwiK3BhcnNlSW50KGNbMl0sMTYpK1xcXCIsIFxcXCIrcGFyc2VJbnQoY1szXSwxNikrXFxcIilcXFwiOlxcXCJcXFwifWZ1bmN0aW9uIHMoYyl7dmFyIGQ9KGMuY3NzKFxcXCJ0ZXh0LWFsaWduXFxcIil8fFxcXCJcXFwiKS5yZXBsYWNlKC8tKC4qKS0vZyxcXFwiXFxcIik7aWYoW1xcXCJsZWZ0XFxcIixcXFwicmlnaHRcXFwiLFxcXCJqdXN0aWZ5XFxcIixcXFwiY2VudGVyXFxcIl0uaW5kZXhPZihkKTwwKXtpZigheSl7dmFyIGU9YSgnPGRpdiBkaXI9XFxcIicrKFxcXCJydGxcXFwiPT1iLm9wdHMuZGlyZWN0aW9uP1xcXCJydGxcXFwiOlxcXCJhdXRvXFxcIikrJ1xcXCIgc3R5bGU9XFxcInRleHQtYWxpZ246ICcrYi4kZWwuY3NzKFxcXCJ0ZXh0LWFsaWduXFxcIikrJzsgcG9zaXRpb246IGZpeGVkOyBsZWZ0OiAtMzAwMHB4O1xcXCI+PHNwYW4gaWQ9XFxcInMxXFxcIj4uPC9zcGFuPjxzcGFuIGlkPVxcXCJzMlxcXCI+Ljwvc3Bhbj48L2Rpdj4nKTthKFxcXCJib2R5XFxcIikuYXBwZW5kKGUpO3ZhciBmPWUuZmluZChcXFwiI3MxXFxcIikuZ2V0KDApLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQsZz1lLmZpbmQoXFxcIiNzMlxcXCIpLmdldCgwKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0O2UucmVtb3ZlKCkseT1mPGc/XFxcImxlZnRcXFwiOlxcXCJyaWdodFxcXCJ9ZD15fXJldHVybiBkfWZ1bmN0aW9uIHQoKXtyZXR1cm4gbnVsbD09eiYmKHo9bmF2aWdhdG9yLnBsYXRmb3JtLnRvVXBwZXJDYXNlKCkuaW5kZXhPZihcXFwiTUFDXFxcIik+PTApLHp9ZnVuY3Rpb24gdSgpe2Z1bmN0aW9uIGEoYSxiKXt2YXIgZD1hW2JdO2FbYl09ZnVuY3Rpb24oYSl7dmFyIGIsZj0hMSxnPSExO2lmKGEmJmEubWF0Y2goZSkpe2E9YS5yZXBsYWNlKGUsXFxcIlxcXCIpLHRoaXMucGFyZW50Tm9kZXx8KGMuYXBwZW5kQ2hpbGQodGhpcyksZz0hMCk7dmFyIGg9dGhpcy5wYXJlbnROb2RlO3JldHVybiB0aGlzLmlkfHwodGhpcy5pZD1cXFwicm9vdGVkUXVlcnlTZWxlY3Rvcl9pZF9cXFwiKyhuZXcgRGF0ZSkuZ2V0VGltZSgpLGY9ITApLGI9ZC5jYWxsKGgsXFxcIiNcXFwiK3RoaXMuaWQrXFxcIiBcXFwiK2EpLGYmJih0aGlzLmlkPVxcXCJcXFwiKSxnJiZjLnJlbW92ZUNoaWxkKHRoaXMpLGJ9cmV0dXJuIGQuY2FsbCh0aGlzLGEpfX12YXIgYz1iLm9fZG9jLmNyZWF0ZUVsZW1lbnQoXFxcImRpdlxcXCIpO3RyeXtjLnF1ZXJ5U2VsZWN0b3JBbGwoXFxcIjpzY29wZSAqXFxcIil9Y2F0Y2goZCl7dmFyIGU9L15cXFxccyo6c2NvcGUvZ2k7YShFbGVtZW50LnByb3RvdHlwZSxcXFwicXVlcnlTZWxlY3RvclxcXCIpLGEoRWxlbWVudC5wcm90b3R5cGUsXFxcInF1ZXJ5U2VsZWN0b3JBbGxcXFwiKX19ZnVuY3Rpb24gdigpe3JldHVybiBiLm9fd2luLnBhZ2VZT2Zmc2V0P2Iub193aW4ucGFnZVlPZmZzZXQ6Yi5vX2RvYy5kb2N1bWVudEVsZW1lbnQmJmIub19kb2MuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcD9iLm9fZG9jLmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3A6Yi5vX2RvYy5ib2R5LnNjcm9sbFRvcD9iLm9fZG9jLmJvZHkuc2Nyb2xsVG9wOjB9ZnVuY3Rpb24gdygpe3JldHVybiBiLm9fd2luLnBhZ2VYT2Zmc2V0P2Iub193aW4ucGFnZVhPZmZzZXQ6Yi5vX2RvYy5kb2N1bWVudEVsZW1lbnQmJmIub19kb2MuZG9jdW1lbnRFbGVtZW50LnNjcm9sbExlZnQ/Yi5vX2RvYy5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsTGVmdDpiLm9fZG9jLmJvZHkuc2Nyb2xsTGVmdD9iLm9fZG9jLmJvZHkuc2Nyb2xsTGVmdDowfWZ1bmN0aW9uIHgoKXtiLmJyb3dzZXI9ZCgpLHUoKX12YXIgeSx6PW51bGw7cmV0dXJue19pbml0OngsaXNJT1M6ZSxpc01hYzp0LGlzQW5kcm9pZDpmLGlzQmxhY2tiZXJyeTpnLGlzV2luZG93c1Bob25lOmgsaXNNb2JpbGU6aSxyZXF1ZXN0QW5pbWF0aW9uRnJhbWU6aixnZXRQWDprLHNjcmVlblNpemU6bCxpc1RvdWNoOm0sc2FuaXRpemVVUkw6byxpc0FycmF5OnAsUkdCVG9IZXg6cSxIRVh0b1JHQjpyLGlzVVJMOm4sZ2V0QWxpZ25tZW50OnMsc2Nyb2xsVG9wOnYsc2Nyb2xsTGVmdDp3fX0sYS5GRS5NT0RVTEVTLmV2ZW50cz1mdW5jdGlvbihiKXtmdW5jdGlvbiBjKGEsYixjKXtzKGEsYixjKX1mdW5jdGlvbiBkKCl7YyhiLiRlbCxcXFwiY3V0IGNvcHkgcGFzdGUgYmVmb3JlcGFzdGVcXFwiLGZ1bmN0aW9uKGEpe3YoYS50eXBlLFthXSl9KX1mdW5jdGlvbiBlKCl7YyhiLiRlbCxcXFwiY2xpY2sgbW91c2V1cCBtb3VzZWRvd24gdG91Y2hzdGFydCB0b3VjaGVuZCBkcmFnZW50ZXIgZHJhZ292ZXIgZHJhZ2xlYXZlIGRyYWdlbmQgZHJvcCBkcmFnc3RhcnRcXFwiLGZ1bmN0aW9uKGEpe3YoYS50eXBlLFthXSl9KSxyKFxcXCJtb3VzZWRvd25cXFwiLGZ1bmN0aW9uKCl7Zm9yKHZhciBjPTA7YzxhLkZFLklOU1RBTkNFUy5sZW5ndGg7YysrKWEuRkUuSU5TVEFOQ0VTW2NdIT1iJiZhLkZFLklOU1RBTkNFU1tjXS5wb3B1cHMmJmEuRkUuSU5TVEFOQ0VTW2NdLnBvcHVwcy5hcmVWaXNpYmxlKCkmJmEuRkUuSU5TVEFOQ0VTW2NdLiRlbC5maW5kKFxcXCIuZnItbWFya2VyXFxcIikucmVtb3ZlKCl9KX1mdW5jdGlvbiBmKCl7YyhiLiRlbCxcXFwia2V5ZG93biBrZXlwcmVzcyBrZXl1cCBpbnB1dFxcXCIsZnVuY3Rpb24oYSl7dihhLnR5cGUsW2FdKX0pfWZ1bmN0aW9uIGcoKXtjKGIuJHdpbixiLl9tb3VzZWRvd24sZnVuY3Rpb24oYSl7dihcXFwid2luZG93Lm1vdXNlZG93blxcXCIsW2FdKSxuKCl9KSxjKGIuJHdpbixiLl9tb3VzZXVwLGZ1bmN0aW9uKGEpe3YoXFxcIndpbmRvdy5tb3VzZXVwXFxcIixbYV0pfSksYyhiLiR3aW4sXFxcImN1dCBjb3B5IGtleWRvd24ga2V5dXAgdG91Y2htb3ZlIHRvdWNoZW5kXFxcIixmdW5jdGlvbihhKXt2KFxcXCJ3aW5kb3cuXFxcIithLnR5cGUsW2FdKX0pfWZ1bmN0aW9uIGgoKXtjKGIuJGRvYyxcXFwiZHJhZ2VuZCBkcm9wXFxcIixmdW5jdGlvbihhKXt2KFxcXCJkb2N1bWVudC5cXFwiK2EudHlwZSxbYV0pfSl9ZnVuY3Rpb24gaShjKXtpZihcXFwidW5kZWZpbmVkXFxcIj09dHlwZW9mIGMmJihjPSEwKSwhYi4kd3ApcmV0dXJuITE7aWYoYi5oZWxwZXJzLmlzSU9TKCkmJmIuJHdpbi5nZXQoMCkuZm9jdXMoKSwhYi5jb3JlLmhhc0ZvY3VzKCkmJmMpe3ZhciBkPWIuJHdpbi5zY3JvbGxUb3AoKTtyZXR1cm4gYi5icm93c2VyLm1zaWUmJmIuJGJveCYmYi4kYm94LmNzcyhcXFwicG9zaXRpb25cXFwiLFxcXCJmaXhlZFxcXCIpLGIuJGVsLmZvY3VzKCksYi5icm93c2VyLm1zaWUmJmIuJGJveCYmYi4kYm94LmNzcyhcXFwicG9zaXRpb25cXFwiLFxcXCJcXFwiKSxkIT1iLiR3aW4uc2Nyb2xsVG9wKCkmJmIuJHdpbi5zY3JvbGxUb3AoZCksITF9aWYoIWIuY29yZS5oYXNGb2N1cygpfHxiLiRlbC5maW5kKFxcXCIuZnItbWFya2VyXFxcIikubGVuZ3RoPjApcmV0dXJuITE7dmFyIGU9Yi5zZWxlY3Rpb24uaW5mbyhiLmVsKTtpZihlLmF0U3RhcnQmJmIuc2VsZWN0aW9uLmlzQ29sbGFwc2VkKCkmJm51bGwhPWIuaHRtbC5kZWZhdWx0VGFnKCkpe3ZhciBmPWIubWFya2Vycy5pbnNlcnQoKTtpZihmJiYhYi5ub2RlLmJsb2NrUGFyZW50KGYpKXthKGYpLnJlbW92ZSgpO3ZhciBnPWIuJGVsLmZpbmQoYi5odG1sLmJsb2NrVGFnc1F1ZXJ5KCkpLmdldCgwKTtnJiYoYShnKS5wcmVwZW5kKGEuRkUuTUFSS0VSUyksYi5zZWxlY3Rpb24ucmVzdG9yZSgpKX1lbHNlIGYmJmEoZikucmVtb3ZlKCl9fWZ1bmN0aW9uIGooKXtjKGIuJGVsLFxcXCJmb2N1c1xcXCIsZnVuY3Rpb24oYSl7cCgpJiYoaSghMSksQz09PSExJiZ2KGEudHlwZSxbYV0pKX0pLGMoYi4kZWwsXFxcImJsdXJcXFwiLGZ1bmN0aW9uKGEpe3AoKSYmQz09PSEwJiYodihhLnR5cGUsW2FdKSxuKCkpfSkscihcXFwiZm9jdXNcXFwiLGZ1bmN0aW9uKCl7Qz0hMH0pLHIoXFxcImJsdXJcXFwiLGZ1bmN0aW9uKCl7Qz0hMX0pfWZ1bmN0aW9uIGsoKXtiLmhlbHBlcnMuaXNNb2JpbGUoKT8oYi5fbW91c2Vkb3duPVxcXCJ0b3VjaHN0YXJ0XFxcIixiLl9tb3VzZXVwPVxcXCJ0b3VjaGVuZFxcXCIsYi5fbW92ZT1cXFwidG91Y2htb3ZlXFxcIixiLl9tb3VzZW1vdmU9XFxcInRvdWNobW92ZVxcXCIpOihiLl9tb3VzZWRvd249XFxcIm1vdXNlZG93blxcXCIsYi5fbW91c2V1cD1cXFwibW91c2V1cFxcXCIsYi5fbW92ZT1cXFwiXFxcIixiLl9tb3VzZW1vdmU9XFxcIm1vdXNlbW92ZVxcXCIpfWZ1bmN0aW9uIGwoYyl7dmFyIGQ9YShjLmN1cnJlbnRUYXJnZXQpO3JldHVybiBiLmVkaXQuaXNEaXNhYmxlZCgpfHxiLm5vZGUuaGFzQ2xhc3MoZC5nZXQoMCksXFxcImZyLWRpc2FibGVkXFxcIik/KGMucHJldmVudERlZmF1bHQoKSwhMSk6XFxcIm1vdXNlZG93blxcXCI9PT1jLnR5cGUmJjEhPT1jLndoaWNofHwoYi5oZWxwZXJzLmlzTW9iaWxlKCl8fGMucHJldmVudERlZmF1bHQoKSwoYi5oZWxwZXJzLmlzQW5kcm9pZCgpfHxiLmhlbHBlcnMuaXNXaW5kb3dzUGhvbmUoKSkmJjA9PT1kLnBhcmVudHMoXFxcIi5mci1kcm9wZG93bi1tZW51XFxcIikubGVuZ3RoJiYoYy5wcmV2ZW50RGVmYXVsdCgpLGMuc3RvcFByb3BhZ2F0aW9uKCkpLGQuYWRkQ2xhc3MoXFxcImZyLXNlbGVjdGVkXFxcIiksdm9pZCBiLmV2ZW50cy50cmlnZ2VyKFxcXCJjb21tYW5kcy5tb3VzZWRvd25cXFwiLFtkXSkpfWZ1bmN0aW9uIG0oYyxkKXt2YXIgZT1hKGMuY3VycmVudFRhcmdldCk7aWYoYi5lZGl0LmlzRGlzYWJsZWQoKXx8Yi5ub2RlLmhhc0NsYXNzKGUuZ2V0KDApLFxcXCJmci1kaXNhYmxlZFxcXCIpKXJldHVybiBjLnByZXZlbnREZWZhdWx0KCksITE7aWYoXFxcIm1vdXNldXBcXFwiPT09Yy50eXBlJiYxIT09Yy53aGljaClyZXR1cm4hMDtpZighYi5ub2RlLmhhc0NsYXNzKGUuZ2V0KDApLFxcXCJmci1zZWxlY3RlZFxcXCIpKXJldHVybiEwO2lmKFxcXCJ0b3VjaG1vdmVcXFwiIT1jLnR5cGUpe2lmKGMuc3RvcFByb3BhZ2F0aW9uKCksYy5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKSxjLnByZXZlbnREZWZhdWx0KCksIWIubm9kZS5oYXNDbGFzcyhlLmdldCgwKSxcXFwiZnItc2VsZWN0ZWRcXFwiKSlyZXR1cm4gYi5idXR0b24uZ2V0QnV0dG9ucyhcXFwiLmZyLXNlbGVjdGVkXFxcIiwhMCkucmVtb3ZlQ2xhc3MoXFxcImZyLXNlbGVjdGVkXFxcIiksITE7aWYoYi5idXR0b24uZ2V0QnV0dG9ucyhcXFwiLmZyLXNlbGVjdGVkXFxcIiwhMCkucmVtb3ZlQ2xhc3MoXFxcImZyLXNlbGVjdGVkXFxcIiksZS5kYXRhKFxcXCJkcmFnZ2luZ1xcXCIpfHxlLmF0dHIoXFxcImRpc2FibGVkXFxcIikpcmV0dXJuIGUucmVtb3ZlRGF0YShcXFwiZHJhZ2dpbmdcXFwiKSwhMTt2YXIgZj1lLmRhdGEoXFxcInRpbWVvdXRcXFwiKTtmJiYoY2xlYXJUaW1lb3V0KGYpLGUucmVtb3ZlRGF0YShcXFwidGltZW91dFxcXCIpKSxkLmFwcGx5KGIsW2NdKX1lbHNlIGUuZGF0YShcXFwidGltZW91dFxcXCIpfHxlLmRhdGEoXFxcInRpbWVvdXRcXFwiLHNldFRpbWVvdXQoZnVuY3Rpb24oKXtlLmRhdGEoXFxcImRyYWdnaW5nXFxcIiwhMCl9LDEwMCkpfWZ1bmN0aW9uIG4oKXtBPSEwfWZ1bmN0aW9uIG8oKXtBPSExfWZ1bmN0aW9uIHAoKXtyZXR1cm4gQX1mdW5jdGlvbiBxKGEsYyxkKXtzKGEsYi5fbW91c2Vkb3duLGMsZnVuY3Rpb24oYSl7Yi5lZGl0LmlzRGlzYWJsZWQoKXx8bChhKX0sITApLHMoYSxiLl9tb3VzZXVwK1xcXCIgXFxcIitiLl9tb3ZlLGMsZnVuY3Rpb24oYSl7Yi5lZGl0LmlzRGlzYWJsZWQoKXx8bShhLGQpfSwhMCkscyhhLFxcXCJtb3VzZWRvd24gY2xpY2sgbW91c2V1cFxcXCIsYyxmdW5jdGlvbihhKXtiLmVkaXQuaXNEaXNhYmxlZCgpfHxhLnN0b3BQcm9wYWdhdGlvbigpfSwhMCkscihcXFwid2luZG93Lm1vdXNldXBcXFwiLGZ1bmN0aW9uKCl7Yi5lZGl0LmlzRGlzYWJsZWQoKXx8KGEuZmluZChjKS5yZW1vdmVDbGFzcyhcXFwiZnItc2VsZWN0ZWRcXFwiKSxuKCkpfSl9ZnVuY3Rpb24gcihhLGMsZCl7dmFyIGU9YS5zcGxpdChcXFwiIFxcXCIpO2lmKGUubGVuZ3RoPjEpe2Zvcih2YXIgZj0wO2Y8ZS5sZW5ndGg7ZisrKXIoZVtmXSxjLGQpO3JldHVybiEwfVxcXCJ1bmRlZmluZWRcXFwiPT10eXBlb2YgZCYmKGQ9ITEpO3ZhciBnO2c9MCE9PWEuaW5kZXhPZihcXFwic2hhcmVkLlxcXCIpP0JbYV09QlthXXx8W106Yi5zaGFyZWQuX2V2ZW50c1thXT1iLnNoYXJlZC5fZXZlbnRzW2FdfHxbXSxkP2cudW5zaGlmdChjKTpnLnB1c2goYyl9ZnVuY3Rpb24gcyhhLGMsZCxlLGYpe1xcXCJmdW5jdGlvblxcXCI9PXR5cGVvZiBkJiYoZj1lLGU9ZCxkPSExKTt2YXIgZz1mP2Iuc2hhcmVkLiRfZXZlbnRzOkQsaD1mP2Iuc2lkOmIuaWQ7ZD9hLm9uKGMuc3BsaXQoXFxcIiBcXFwiKS5qb2luKFxcXCIuZWRcXFwiK2grXFxcIiBcXFwiKStcXFwiLmVkXFxcIitoLGQsZSk6YS5vbihjLnNwbGl0KFxcXCIgXFxcIikuam9pbihcXFwiLmVkXFxcIitoK1xcXCIgXFxcIikrXFxcIi5lZFxcXCIraCxlKSxnLmluZGV4T2YoYS5nZXQoMCkpPDAmJmcucHVzaChhLmdldCgwKSl9ZnVuY3Rpb24gdChiLGMpe2Zvcih2YXIgZD0wO2Q8Yi5sZW5ndGg7ZCsrKWEoYltkXSkub2ZmKFxcXCIuZWRcXFwiK2MpfWZ1bmN0aW9uIHUoKXt0KEQsYi5pZCksRD1bXSwwPT09Yi5zaGFyZWQuY291bnQmJih0KGIuc2hhcmVkLiRfZXZlbnRzLGIuc2lkKSxiLnNoYXJlZC4kX2V2ZW50cz1udWxsKX1mdW5jdGlvbiB2KGMsZCxlKXtpZighYi5lZGl0LmlzRGlzYWJsZWQoKXx8ZSl7dmFyIGY7aWYoMCE9PWMuaW5kZXhPZihcXFwic2hhcmVkLlxcXCIpKWY9QltjXTtlbHNle2lmKGIuc2hhcmVkLmNvdW50PjApcmV0dXJuITE7Zj1iLnNoYXJlZC5fZXZlbnRzW2NdfXZhciBnO2lmKGYpZm9yKHZhciBoPTA7aDxmLmxlbmd0aDtoKyspaWYoZz1mW2hdLmFwcGx5KGIsZCksZz09PSExKXJldHVybiExO3JldHVybiBnPWIuJG9lbC50cmlnZ2VySGFuZGxlcihcXFwiZnJvYWxhRWRpdG9yLlxcXCIrYyxhLm1lcmdlKFtiXSxkfHxbXSkpLGchPT0hMSYmZ319ZnVuY3Rpb24gdyhjLGQsZSl7aWYoIWIuZWRpdC5pc0Rpc2FibGVkKCl8fGUpe3ZhciBmO2lmKDAhPT1jLmluZGV4T2YoXFxcInNoYXJlZC5cXFwiKSlmPUJbY107ZWxzZXtpZihiLnNoYXJlZC5jb3VudD4wKXJldHVybiExO2Y9Yi5zaGFyZWQuX2V2ZW50c1tjXX12YXIgZztpZihmKWZvcih2YXIgaD0wO2g8Zi5sZW5ndGg7aCsrKWc9ZltoXS5hcHBseShiLFtkXSksXFxcInVuZGVmaW5lZFxcXCIhPXR5cGVvZiBnJiYoZD1nKTtyZXR1cm4gZz1iLiRvZWwudHJpZ2dlckhhbmRsZXIoXFxcImZyb2FsYUVkaXRvci5cXFwiK2MsYS5tZXJnZShbYl0sW2RdKSksXFxcInVuZGVmaW5lZFxcXCIhPXR5cGVvZiBnJiYoZD1nKSxkfX1mdW5jdGlvbiB4KCl7Zm9yKHZhciBhIGluIEIpQi5oYXNPd25Qcm9wZXJ0eShhKSYmZGVsZXRlIEJbYV19ZnVuY3Rpb24geSgpe2Zvcih2YXIgYSBpbiBiLnNoYXJlZC5fZXZlbnRzKWIuc2hhcmVkLl9ldmVudHMuaGFzT3duUHJvcGVydHkoYSkmJmRlbGV0ZSBiLnNoYXJlZC5fZXZlbnRzW2FdfWZ1bmN0aW9uIHooKXtiLnNoYXJlZC4kX2V2ZW50cz1iLnNoYXJlZC4kX2V2ZW50c3x8W10sYi5zaGFyZWQuX2V2ZW50cz17fSxrKCksZSgpLGcoKSxoKCksZigpLGooKSxuKCksZCgpLHIoXFxcImRlc3Ryb3lcXFwiLHgpLHIoXFxcInNoYXJlZC5kZXN0cm95XFxcIix5KX12YXIgQSxCPXt9LEM9ITEsRD1bXTtyZXR1cm57X2luaXQ6eixvbjpyLHRyaWdnZXI6dixiaW5kQ2xpY2s6cSxkaXNhYmxlQmx1cjpvLGVuYWJsZUJsdXI6bixibHVyQWN0aXZlOnAsZm9jdXM6aSxjaGFpblRyaWdnZXI6dywkb246cywkb2ZmOnV9fSxhLkZFLk1PRFVMRVMubm9kZT1mdW5jdGlvbihiKXtmdW5jdGlvbiBjKGEpe3JldHVybiBhJiZcXFwiSUZSQU1FXFxcIiE9YS50YWdOYW1lP0FycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGEuY2hpbGROb2Rlc3x8W10pOltdfWZ1bmN0aW9uIGQoYil7cmV0dXJuISFiJiYoYi5ub2RlVHlwZT09Tm9kZS5FTEVNRU5UX05PREUmJmEuRkUuQkxPQ0tfVEFHUy5pbmRleE9mKGIudGFnTmFtZS50b0xvd2VyQ2FzZSgpKT49MCl9ZnVuY3Rpb24gZShlLGYpe2lmKCFlKXJldHVybiEwO2lmKGUucXVlcnlTZWxlY3RvcihcXFwidGFibGVcXFwiKSlyZXR1cm4hMTt2YXIgZz1jKGUpOzE9PWcubGVuZ3RoJiZkKGdbMF0pJiYoZz1jKGdbMF0pKTtmb3IodmFyIGg9ITEsaT0wO2k8Zy5sZW5ndGg7aSsrKXt2YXIgaj1nW2ldO2lmKCEoZiYmYi5ub2RlLmhhc0NsYXNzKGosXFxcImZyLW1hcmtlclxcXCIpfHxqLm5vZGVUeXBlPT1Ob2RlLlRFWFRfTk9ERSYmMD09PWoudGV4dENvbnRlbnQubGVuZ3RoKSl7aWYoXFxcIkJSXFxcIiE9ai50YWdOYW1lJiYoai50ZXh0Q29udGVudHx8XFxcIlxcXCIpLnJlcGxhY2UoL1xcXFx1MjAwQi9naSxcXFwiXFxcIikucmVwbGFjZSgvXFxcXG4vZyxcXFwiXFxcIikubGVuZ3RoPjApcmV0dXJuITE7aWYoaClyZXR1cm4hMTtcXFwiQlJcXFwiPT1qLnRhZ05hbWUmJihoPSEwKX19cmV0dXJuIShlLnF1ZXJ5U2VsZWN0b3JBbGwoYS5GRS5WT0lEX0VMRU1FTlRTLmpvaW4oXFxcIixcXFwiKSkubGVuZ3RoLWUucXVlcnlTZWxlY3RvckFsbChcXFwiYnJcXFwiKS5sZW5ndGgpJiYoIWUucXVlcnlTZWxlY3RvcihiLm9wdHMuaHRtbEFsbG93ZWRFbXB0eVRhZ3Muam9pbihcXFwiOm5vdCguZnItbWFya2VyKSxcXFwiKStcXFwiOm5vdCguZnItbWFya2VyKVxcXCIpJiYoIShlLnF1ZXJ5U2VsZWN0b3JBbGwoYS5GRS5CTE9DS19UQUdTLmpvaW4oXFxcIixcXFwiKSkubGVuZ3RoPjEpJiYhZS5xdWVyeVNlbGVjdG9yKGIub3B0cy5odG1sRG9Ob3RXcmFwVGFncy5qb2luKFxcXCI6bm90KC5mci1tYXJrZXIpLFxcXCIpK1xcXCI6bm90KC5mci1tYXJrZXIpXFxcIikpKX1mdW5jdGlvbiBmKGEpe2Zvcig7YSYmYS5wYXJlbnROb2RlIT09Yi5lbCYmKCFhLnBhcmVudE5vZGV8fCFiLm5vZGUuaGFzQ2xhc3MoYS5wYXJlbnROb2RlLFxcXCJmci1pbm5lclxcXCIpKTspaWYoYT1hLnBhcmVudE5vZGUsZChhKSlyZXR1cm4gYTtyZXR1cm4gbnVsbH1mdW5jdGlvbiBnKGMsZSxmKXtpZihcXFwidW5kZWZpbmVkXFxcIj09dHlwZW9mIGUmJihlPVtdKSxcXFwidW5kZWZpbmVkXFxcIj09dHlwZW9mIGYmJihmPSEwKSxlLnB1c2goYi5lbCksZS5pbmRleE9mKGMucGFyZW50Tm9kZSk+PTB8fGMucGFyZW50Tm9kZSYmYi5ub2RlLmhhc0NsYXNzKGMucGFyZW50Tm9kZSxcXFwiZnItaW5uZXJcXFwiKXx8Yy5wYXJlbnROb2RlJiZhLkZFLlNJTVBMRV9FTlRFUl9UQUdTLmluZGV4T2YoYy5wYXJlbnROb2RlLnRhZ05hbWUpPj0wJiZmKXJldHVybiBudWxsO2Zvcig7ZS5pbmRleE9mKGMucGFyZW50Tm9kZSk8MCYmYy5wYXJlbnROb2RlJiYhYi5ub2RlLmhhc0NsYXNzKGMucGFyZW50Tm9kZSxcXFwiZnItaW5uZXJcXFwiKSYmKGEuRkUuU0lNUExFX0VOVEVSX1RBR1MuaW5kZXhPZihjLnBhcmVudE5vZGUudGFnTmFtZSk8MHx8IWYpJiYoIWQoYyl8fCFkKGMucGFyZW50Tm9kZSl8fCFmKTspYz1jLnBhcmVudE5vZGU7cmV0dXJuIGN9ZnVuY3Rpb24gaChhKXt2YXIgYj17fSxjPWEuYXR0cmlidXRlcztpZihjKWZvcih2YXIgZD0wO2Q8Yy5sZW5ndGg7ZCsrKXt2YXIgZT1jW2RdO2JbZS5ub2RlTmFtZV09ZS52YWx1ZX1yZXR1cm4gYn1mdW5jdGlvbiBpKGEpe2Zvcih2YXIgYj1cXFwiXFxcIixjPWgoYSksZD1PYmplY3Qua2V5cyhjKS5zb3J0KCksZT0wO2U8ZC5sZW5ndGg7ZSsrKXt2YXIgZj1kW2VdLGc9Y1tmXTtnLmluZGV4T2YoXFxcIidcXFwiKTwwJiZnLmluZGV4T2YoJ1xcXCInKT49MD9iKz1cXFwiIFxcXCIrZitcXFwiPSdcXFwiK2crXFxcIidcXFwiOmcuaW5kZXhPZignXFxcIicpPj0wJiZnLmluZGV4T2YoXFxcIidcXFwiKT49MD8oZz1nLnJlcGxhY2UoL1xcXCIvZyxcXFwiJnF1b3Q7XFxcIiksYis9XFxcIiBcXFwiK2YrJz1cXFwiJytnKydcXFwiJyk6Yis9XFxcIiBcXFwiK2YrJz1cXFwiJytnKydcXFwiJ31yZXR1cm4gYn1mdW5jdGlvbiBqKGEpe2Zvcih2YXIgYj1hLmF0dHJpYnV0ZXMsYz1iLmxlbmd0aC0xO2M+PTA7Yy0tKXt2YXIgZD1iW2NdO2EucmVtb3ZlQXR0cmlidXRlKGQubm9kZU5hbWUpfX1mdW5jdGlvbiBrKGEpe3JldHVyblxcXCI8XFxcIithLnRhZ05hbWUudG9Mb3dlckNhc2UoKStpKGEpK1xcXCI+XFxcIn1mdW5jdGlvbiBsKGEpe3JldHVyblxcXCI8L1xcXCIrYS50YWdOYW1lLnRvTG93ZXJDYXNlKCkrXFxcIj5cXFwifWZ1bmN0aW9uIG0oYSxjKXtcXFwidW5kZWZpbmVkXFxcIj09dHlwZW9mIGMmJihjPSEwKTtmb3IodmFyIGQ9YS5wcmV2aW91c1NpYmxpbmc7ZCYmYyYmYi5ub2RlLmhhc0NsYXNzKGQsXFxcImZyLW1hcmtlclxcXCIpOylkPWQucHJldmlvdXNTaWJsaW5nO3JldHVybiFkfHxkLm5vZGVUeXBlPT1Ob2RlLlRFWFRfTk9ERSYmXFxcIlxcXCI9PT1kLnRleHRDb250ZW50JiZtKGQpfWZ1bmN0aW9uIG4oYSxjKXtcXFwidW5kZWZpbmVkXFxcIj09dHlwZW9mIGMmJihjPSEwKTtmb3IodmFyIGQ9YS5uZXh0U2libGluZztkJiZjJiZiLm5vZGUuaGFzQ2xhc3MoZCxcXFwiZnItbWFya2VyXFxcIik7KWQ9ZC5uZXh0U2libGluZztyZXR1cm4hZHx8ZC5ub2RlVHlwZT09Tm9kZS5URVhUX05PREUmJlxcXCJcXFwiPT09ZC50ZXh0Q29udGVudCYmbihkKX1mdW5jdGlvbiBvKGIpe3JldHVybiBiJiZiLm5vZGVUeXBlPT1Ob2RlLkVMRU1FTlRfTk9ERSYmYS5GRS5WT0lEX0VMRU1FTlRTLmluZGV4T2YoKGIudGFnTmFtZXx8XFxcIlxcXCIpLnRvTG93ZXJDYXNlKCkpPj0wfWZ1bmN0aW9uIHAoYSl7cmV0dXJuISFhJiZbXFxcIlVMXFxcIixcXFwiT0xcXFwiXS5pbmRleE9mKGEudGFnTmFtZSk+PTB9ZnVuY3Rpb24gcShhKXtyZXR1cm4gYT09PWIuZWx9ZnVuY3Rpb24gcihhKXtyZXR1cm4gYSYmYS5ub2RlVHlwZT09Tm9kZS5FTEVNRU5UX05PREUmJmEuZ2V0QXR0cmlidXRlKFxcXCJjbGFzc1xcXCIpJiYoYS5nZXRBdHRyaWJ1dGUoXFxcImNsYXNzXFxcIil8fFxcXCJcXFwiKS5pbmRleE9mKFxcXCJmci1kZWxldGFibGVcXFwiKT49MH1mdW5jdGlvbiBzKGEpe3JldHVybiBhPT09Yi5kb2MuYWN0aXZlRWxlbWVudCYmKCFiLmRvYy5oYXNGb2N1c3x8Yi5kb2MuaGFzRm9jdXMoKSkmJiEhKHEoYSl8fGEudHlwZXx8YS5ocmVmfHx+YS50YWJJbmRleCl9ZnVuY3Rpb24gdChhKXtyZXR1cm4oIWEuZ2V0QXR0cmlidXRlfHxcXFwiZmFsc2VcXFwiIT1hLmdldEF0dHJpYnV0ZShcXFwiY29udGVudGVkaXRhYmxlXFxcIikpJiZbXFxcIlNUWUxFXFxcIixcXFwiU0NSSVBUXFxcIl0uaW5kZXhPZihhLnRhZ05hbWUpPDB9ZnVuY3Rpb24gdShiLGMpe3JldHVybiBiIGluc3RhbmNlb2YgYSYmKGI9Yi5nZXQoMCkpLGImJmIuY2xhc3NMaXN0JiZiLmNsYXNzTGlzdC5jb250YWlucyhjKX1mdW5jdGlvbiB2KGEpe3JldHVybiBiLmJyb3dzZXIubXNpZT9hOnthY2NlcHROb2RlOmF9fXJldHVybntpc0Jsb2NrOmQsaXNFbXB0eTplLGJsb2NrUGFyZW50OmYsZGVlcGVzdFBhcmVudDpnLHJhd0F0dHJpYnV0ZXM6aCxhdHRyaWJ1dGVzOmksY2xlYXJBdHRyaWJ1dGVzOmosb3BlblRhZ1N0cmluZzprLGNsb3NlVGFnU3RyaW5nOmwsaXNGaXJzdFNpYmxpbmc6bSxpc0xhc3RTaWJsaW5nOm4saXNMaXN0OnAsaXNFbGVtZW50OnEsY29udGVudHM6Yyxpc1ZvaWQ6byxoYXNGb2N1czpzLGlzRWRpdGFibGU6dCxpc0RlbGV0YWJsZTpyLGhhc0NsYXNzOnUsZmlsdGVyOnZ9fSxhLkZFLklOVklTSUJMRV9TUEFDRT1cXFwiJiM4MjAzO1xcXCIsYS5GRS5TVEFSVF9NQVJLRVI9JzxzcGFuIGNsYXNzPVxcXCJmci1tYXJrZXJcXFwiIGRhdGEtaWQ9XFxcIjBcXFwiIGRhdGEtdHlwZT1cXFwidHJ1ZVxcXCIgc3R5bGU9XFxcImRpc3BsYXk6IG5vbmU7IGxpbmUtaGVpZ2h0OiAwO1xcXCI+JythLkZFLklOVklTSUJMRV9TUEFDRStcXFwiPC9zcGFuPlxcXCIsYS5GRS5FTkRfTUFSS0VSPSc8c3BhbiBjbGFzcz1cXFwiZnItbWFya2VyXFxcIiBkYXRhLWlkPVxcXCIwXFxcIiBkYXRhLXR5cGU9XFxcImZhbHNlXFxcIiBzdHlsZT1cXFwiZGlzcGxheTogbm9uZTsgbGluZS1oZWlnaHQ6IDA7XFxcIj4nK2EuRkUuSU5WSVNJQkxFX1NQQUNFK1xcXCI8L3NwYW4+XFxcIixhLkZFLk1BUktFUlM9YS5GRS5TVEFSVF9NQVJLRVIrYS5GRS5FTkRfTUFSS0VSLGEuRkUuTU9EVUxFUy5tYXJrZXJzPWZ1bmN0aW9uKGIpe2Z1bmN0aW9uIGMoYyxkKXtyZXR1cm4gYSgnPHNwYW4gY2xhc3M9XFxcImZyLW1hcmtlclxcXCIgZGF0YS1pZD1cXFwiJytkKydcXFwiIGRhdGEtdHlwZT1cXFwiJytjKydcXFwiIHN0eWxlPVxcXCJkaXNwbGF5OiAnKyhiLmJyb3dzZXIuc2FmYXJpP1xcXCJub25lXFxcIjpcXFwiaW5saW5lLWJsb2NrXFxcIikrJzsgbGluZS1oZWlnaHQ6IDA7XFxcIj4nK2EuRkUuSU5WSVNJQkxFX1NQQUNFK1xcXCI8L3NwYW4+XFxcIixiLmRvYylbMF19ZnVuY3Rpb24gZChkLGUsZil7dmFyIGcsaCxpO3RyeXt2YXIgaj1kLmNsb25lUmFuZ2UoKTtpZihqLmNvbGxhcHNlKGUpLGouaW5zZXJ0Tm9kZShjKGUsZikpLGU9PT0hMCYmZC5jb2xsYXBzZWQpZm9yKGc9Yi4kZWwuZmluZCgnc3Bhbi5mci1tYXJrZXJbZGF0YS10eXBlPVxcXCJ0cnVlXFxcIl1bZGF0YS1pZD1cXFwiJytmKydcXFwiXScpLGk9Zy5nZXQoMCkubmV4dFNpYmxpbmc7aSYmaS5ub2RlVHlwZT09PU5vZGUuVEVYVF9OT0RFJiYwPT09aS50ZXh0Q29udGVudC5sZW5ndGg7KWEoaSkucmVtb3ZlKCksaT1nLm5leHRTaWJsaW5nO2lmKGU9PT0hMCYmIWQuY29sbGFwc2VkJiYoZz1iLiRlbC5maW5kKCdzcGFuLmZyLW1hcmtlcltkYXRhLXR5cGU9XFxcInRydWVcXFwiXVtkYXRhLWlkPVxcXCInK2YrJ1xcXCJdJykuZ2V0KDApLGk9Zy5uZXh0U2libGluZyxpJiZpLm5vZGVUeXBlPT09Tm9kZS5FTEVNRU5UX05PREUmJmIubm9kZS5pc0Jsb2NrKGkpKSl7aD1baV07ZG8gaT1oWzBdLGg9Yi5ub2RlLmNvbnRlbnRzKGkpO3doaWxlKGhbMF0mJmIubm9kZS5pc0Jsb2NrKGhbMF0pKTthKGkpLnByZXBlbmQoYShnKSl9aWYoZT09PSExJiYhZC5jb2xsYXBzZWQpe2lmKGc9Yi4kZWwuZmluZCgnc3Bhbi5mci1tYXJrZXJbZGF0YS10eXBlPVxcXCJmYWxzZVxcXCJdW2RhdGEtaWQ9XFxcIicrZisnXFxcIl0nKS5nZXQoMCksaT1nLnByZXZpb3VzU2libGluZyxpJiZpLm5vZGVUeXBlPT09Tm9kZS5FTEVNRU5UX05PREUmJmIubm9kZS5pc0Jsb2NrKGkpKXtoPVtpXTtkbyBpPWhbaC5sZW5ndGgtMV0saD1iLm5vZGUuY29udGVudHMoaSk7d2hpbGUoaFtoLmxlbmd0aC0xXSYmYi5ub2RlLmlzQmxvY2soaFtoLmxlbmd0aC0xXSkpO2EoaSkuYXBwZW5kKGEoZykpfWcucGFyZW50Tm9kZSYmW1xcXCJURFxcXCIsXFxcIlRIXFxcIl0uaW5kZXhPZihnLnBhcmVudE5vZGUudGFnTmFtZSk+PTAmJmcucGFyZW50Tm9kZS5wcmV2aW91c1NpYmxpbmcmJiFnLnByZXZpb3VzU2libGluZyYmYShnLnBhcmVudE5vZGUucHJldmlvdXNTaWJsaW5nKS5hcHBlbmQoZyl9dmFyIGs9Yi4kZWwuZmluZCgnc3Bhbi5mci1tYXJrZXJbZGF0YS10eXBlPVxcXCInK2UrJ1xcXCJdW2RhdGEtaWQ9XFxcIicrZisnXFxcIl0nKS5nZXQoMCk7cmV0dXJuIGsmJihrLnN0eWxlLmRpc3BsYXk9XFxcIm5vbmVcXFwiKSxrfWNhdGNoKGwpe3JldHVybiBudWxsfX1mdW5jdGlvbiBlKCl7aWYoIWIuJHdwKXJldHVybiBudWxsO3RyeXt2YXIgYz1iLnNlbGVjdGlvbi5yYW5nZXMoMCksZD1jLmNvbW1vbkFuY2VzdG9yQ29udGFpbmVyO2lmKGQhPWIuZWwmJjA9PT1iLiRlbC5maW5kKGQpLmxlbmd0aClyZXR1cm4gbnVsbDt2YXIgZT1jLmNsb25lUmFuZ2UoKSxmPWMuY2xvbmVSYW5nZSgpO2UuY29sbGFwc2UoITApO3ZhciBnPWEoJzxzcGFuIGNsYXNzPVxcXCJmci1tYXJrZXJcXFwiIHN0eWxlPVxcXCJkaXNwbGF5OiBub25lOyBsaW5lLWhlaWdodDogMDtcXFwiPicrYS5GRS5JTlZJU0lCTEVfU1BBQ0UrXFxcIjwvc3Bhbj5cXFwiLGIuZG9jKVswXTtpZihlLmluc2VydE5vZGUoZyksZz1iLiRlbC5maW5kKFxcXCJzcGFuLmZyLW1hcmtlclxcXCIpLmdldCgwKSl7Zm9yKHZhciBoPWcubmV4dFNpYmxpbmc7aCYmaC5ub2RlVHlwZT09PU5vZGUuVEVYVF9OT0RFJiYwPT09aC50ZXh0Q29udGVudC5sZW5ndGg7KWEoaCkucmVtb3ZlKCksaD1iLiRlbC5maW5kKFxcXCJzcGFuLmZyLW1hcmtlclxcXCIpLmdldCgwKS5uZXh0U2libGluZztyZXR1cm4gYi5zZWxlY3Rpb24uY2xlYXIoKSxiLnNlbGVjdGlvbi5nZXQoKS5hZGRSYW5nZShmKSxnfXJldHVybiBudWxsfWNhdGNoKGkpe319ZnVuY3Rpb24gZigpe2Iuc2VsZWN0aW9uLmlzQ29sbGFwc2VkKCl8fGIuc2VsZWN0aW9uLnJlbW92ZSgpO3ZhciBjPWIuJGVsLmZpbmQoXFxcIi5mci1tYXJrZXJcXFwiKS5nZXQoMCk7aWYobnVsbD09YyYmKGM9ZSgpKSxudWxsPT1jKXJldHVybiBudWxsO3ZhciBkPWIubm9kZS5kZWVwZXN0UGFyZW50KGMpO2lmKGR8fChkPWIubm9kZS5ibG9ja1BhcmVudChjKSxkJiZcXFwiTElcXFwiIT1kLnRhZ05hbWUmJihkPW51bGwpKSxkKWlmKGIubm9kZS5pc0Jsb2NrKGQpJiZiLm5vZGUuaXNFbXB0eShkKSlcXFwiTElcXFwiPT1kLnRhZ05hbWUmJmQucGFyZW50Tm9kZS5maXJzdEVsZW1lbnRDaGlsZD09ZD9hKGQpLmFwcGVuZCgnPHNwYW4gY2xhc3M9XFxcImZyLW1hcmtlclxcXCI+PC9zcGFuPicpOmEoZCkucmVwbGFjZVdpdGgoJzxzcGFuIGNsYXNzPVxcXCJmci1tYXJrZXJcXFwiPjwvc3Bhbj4nKTtlbHNlIGlmKGIuY3Vyc29yLmlzQXRTdGFydChjLGQpKWEoZCkuYmVmb3JlKCc8c3BhbiBjbGFzcz1cXFwiZnItbWFya2VyXFxcIj48L3NwYW4+JyksYShjKS5yZW1vdmUoKTtlbHNlIGlmKGIuY3Vyc29yLmlzQXRFbmQoYyxkKSlhKGQpLmFmdGVyKCc8c3BhbiBjbGFzcz1cXFwiZnItbWFya2VyXFxcIj48L3NwYW4+JyksYShjKS5yZW1vdmUoKTtlbHNle3ZhciBmPWMsZz1cXFwiXFxcIixoPVxcXCJcXFwiO2RvIGY9Zi5wYXJlbnROb2RlLGcrPWIubm9kZS5jbG9zZVRhZ1N0cmluZyhmKSxoPWIubm9kZS5vcGVuVGFnU3RyaW5nKGYpK2g7d2hpbGUoZiE9ZCk7YShjKS5yZXBsYWNlV2l0aCgnPHNwYW4gaWQ9XFxcImZyLWJyZWFrXFxcIj48L3NwYW4+Jyk7dmFyIGk9Yi5ub2RlLm9wZW5UYWdTdHJpbmcoZCkrYShkKS5odG1sKCkrYi5ub2RlLmNsb3NlVGFnU3RyaW5nKGQpO2k9aS5yZXBsYWNlKC88c3BhbiBpZD1cXFwiZnItYnJlYWtcXFwiPjxcXFxcL3NwYW4+L2csZysnPHNwYW4gY2xhc3M9XFxcImZyLW1hcmtlclxcXCI+PC9zcGFuPicraCksYShkKS5yZXBsYWNlV2l0aChpKX1yZXR1cm4gYi4kZWwuZmluZChcXFwiLmZyLW1hcmtlclxcXCIpLmdldCgwKX1mdW5jdGlvbiBnKGEpe3ZhciBjPWEuY2xpZW50WCxkPWEuY2xpZW50WTtoKCk7dmFyIGYsZz1udWxsO2lmKFxcXCJ1bmRlZmluZWRcXFwiIT10eXBlb2YgYi5kb2MuY2FyZXRQb3NpdGlvbkZyb21Qb2ludD8oZj1iLmRvYy5jYXJldFBvc2l0aW9uRnJvbVBvaW50KGMsZCksZz1iLmRvYy5jcmVhdGVSYW5nZSgpLGcuc2V0U3RhcnQoZi5vZmZzZXROb2RlLGYub2Zmc2V0KSxnLnNldEVuZChmLm9mZnNldE5vZGUsZi5vZmZzZXQpKTpcXFwidW5kZWZpbmVkXFxcIiE9dHlwZW9mIGIuZG9jLmNhcmV0UmFuZ2VGcm9tUG9pbnQmJihmPWIuZG9jLmNhcmV0UmFuZ2VGcm9tUG9pbnQoYyxkKSxnPWIuZG9jLmNyZWF0ZVJhbmdlKCksZy5zZXRTdGFydChmLnN0YXJ0Q29udGFpbmVyLGYuc3RhcnRPZmZzZXQpLGcuc2V0RW5kKGYuc3RhcnRDb250YWluZXIsZi5zdGFydE9mZnNldCkpLG51bGwhPT1nJiZcXFwidW5kZWZpbmVkXFxcIiE9dHlwZW9mIGIud2luLmdldFNlbGVjdGlvbil7dmFyIGk9Yi53aW4uZ2V0U2VsZWN0aW9uKCk7aS5yZW1vdmVBbGxSYW5nZXMoKSxpLmFkZFJhbmdlKGcpfWVsc2UgaWYoXFxcInVuZGVmaW5lZFxcXCIhPXR5cGVvZiBiLmRvYy5ib2R5LmNyZWF0ZVRleHRSYW5nZSl0cnl7Zz1iLmRvYy5ib2R5LmNyZWF0ZVRleHRSYW5nZSgpLGcubW92ZVRvUG9pbnQoYyxkKTt2YXIgaj1nLmR1cGxpY2F0ZSgpO2oubW92ZVRvUG9pbnQoYyxkKSxnLnNldEVuZFBvaW50KFxcXCJFbmRUb0VuZFxcXCIsaiksZy5zZWxlY3QoKX1jYXRjaChrKXtyZXR1cm4hMX1lKCl9ZnVuY3Rpb24gaCgpe2IuJGVsLmZpbmQoXFxcIi5mci1tYXJrZXJcXFwiKS5yZW1vdmUoKX1yZXR1cm57cGxhY2U6ZCxpbnNlcnQ6ZSxzcGxpdDpmLGluc2VydEF0UG9pbnQ6ZyxyZW1vdmU6aH19LGEuRkUuTU9EVUxFUy5zZWxlY3Rpb249ZnVuY3Rpb24oYil7ZnVuY3Rpb24gYygpe3ZhciBhPVxcXCJcXFwiO3JldHVybiBiLndpbi5nZXRTZWxlY3Rpb24/YT1iLndpbi5nZXRTZWxlY3Rpb24oKTpiLmRvYy5nZXRTZWxlY3Rpb24/YT1iLmRvYy5nZXRTZWxlY3Rpb24oKTpiLmRvYy5zZWxlY3Rpb24mJihhPWIuZG9jLnNlbGVjdGlvbi5jcmVhdGVSYW5nZSgpLnRleHQpLGEudG9TdHJpbmcoKX1mdW5jdGlvbiBkKCl7dmFyIGE9XFxcIlxcXCI7cmV0dXJuIGE9Yi53aW4uZ2V0U2VsZWN0aW9uP2Iud2luLmdldFNlbGVjdGlvbigpOmIuZG9jLmdldFNlbGVjdGlvbj9iLmRvYy5nZXRTZWxlY3Rpb24oKTpiLmRvYy5zZWxlY3Rpb24uY3JlYXRlUmFuZ2UoKX1mdW5jdGlvbiBlKGEpe3ZhciBjPWQoKSxlPVtdO2lmKGMmJmMuZ2V0UmFuZ2VBdCYmYy5yYW5nZUNvdW50KXtlPVtdO2Zvcih2YXIgZj0wO2Y8Yy5yYW5nZUNvdW50O2YrKyllLnB1c2goYy5nZXRSYW5nZUF0KGYpKX1lbHNlIGU9Yi5kb2MuY3JlYXRlUmFuZ2U/W2IuZG9jLmNyZWF0ZVJhbmdlKCldOltdO3JldHVyblxcXCJ1bmRlZmluZWRcXFwiIT10eXBlb2YgYT9lW2FdOmV9ZnVuY3Rpb24gZigpe3ZhciBhPWQoKTt0cnl7YS5yZW1vdmVBbGxSYW5nZXM/YS5yZW1vdmVBbGxSYW5nZXMoKTphLmVtcHR5P2EuZW1wdHkoKTphLmNsZWFyJiZhLmNsZWFyKCl9Y2F0Y2goYil7fX1mdW5jdGlvbiBnKCl7dmFyIGY9ZCgpO3RyeXtpZihmLnJhbmdlQ291bnQpe3ZhciBnLGg9ZSgwKSxpPWguc3RhcnRDb250YWluZXI7aWYoaS5ub2RlVHlwZT09Tm9kZS5URVhUX05PREUmJmguc3RhcnRPZmZzZXQ9PShpLnRleHRDb250ZW50fHxcXFwiXFxcIikubGVuZ3RoJiZpLm5leHRTaWJsaW5nJiYoaT1pLm5leHRTaWJsaW5nKSxpLm5vZGVUeXBlPT1Ob2RlLkVMRU1FTlRfTk9ERSl7dmFyIGo9ITE7aWYoaS5jaGlsZE5vZGVzLmxlbmd0aD4wJiZpLmNoaWxkTm9kZXNbaC5zdGFydE9mZnNldF0pe2ZvcihnPWkuY2hpbGROb2Rlc1toLnN0YXJ0T2Zmc2V0XTtnJiZnLm5vZGVUeXBlPT1Ob2RlLlRFWFRfTk9ERSYmMD09PWcudGV4dENvbnRlbnQubGVuZ3RoOylnPWcubmV4dFNpYmxpbmc7aWYoZyYmZy50ZXh0Q29udGVudC5yZXBsYWNlKC9cXFxcdTIwMEIvZyxcXFwiXFxcIik9PT1jKCkucmVwbGFjZSgvXFxcXHUyMDBCL2csXFxcIlxcXCIpJiYoaT1nLGo9ITApLCFqJiZpLmNoaWxkTm9kZXMubGVuZ3RoPjEmJmguc3RhcnRPZmZzZXQ+MCYmaS5jaGlsZE5vZGVzW2guc3RhcnRPZmZzZXQtMV0pe2ZvcihnPWkuY2hpbGROb2Rlc1toLnN0YXJ0T2Zmc2V0LTFdO2cmJmcubm9kZVR5cGU9PU5vZGUuVEVYVF9OT0RFJiYwPT09Zy50ZXh0Q29udGVudC5sZW5ndGg7KWc9Zy5uZXh0U2libGluZztnJiZnLnRleHRDb250ZW50LnJlcGxhY2UoL1xcXFx1MjAwQi9nLFxcXCJcXFwiKT09PWMoKS5yZXBsYWNlKC9cXFxcdTIwMEIvZyxcXFwiXFxcIikmJihpPWcsaj0hMCl9fWVsc2UhaC5jb2xsYXBzZWQmJmkubmV4dFNpYmxpbmcmJmkubmV4dFNpYmxpbmcubm9kZVR5cGU9PU5vZGUuRUxFTUVOVF9OT0RFJiYoZz1pLm5leHRTaWJsaW5nLGcmJmcudGV4dENvbnRlbnQucmVwbGFjZSgvXFxcXHUyMDBCL2csXFxcIlxcXCIpPT09YygpLnJlcGxhY2UoL1xcXFx1MjAwQi9nLFxcXCJcXFwiKSYmKGk9ZyxqPSEwKSk7IWomJmkuY2hpbGROb2Rlcy5sZW5ndGg+MCYmYShpLmNoaWxkTm9kZXNbMF0pLnRleHQoKS5yZXBsYWNlKC9cXFxcdTIwMEIvZyxcXFwiXFxcIik9PT1jKCkucmVwbGFjZSgvXFxcXHUyMDBCL2csXFxcIlxcXCIpJiZbXFxcIkJSXFxcIixcXFwiSU1HXFxcIixcXFwiSFJcXFwiXS5pbmRleE9mKGkuY2hpbGROb2Rlc1swXS50YWdOYW1lKTwwJiYoaT1pLmNoaWxkTm9kZXNbMF0pfWZvcig7aS5ub2RlVHlwZSE9Tm9kZS5FTEVNRU5UX05PREUmJmkucGFyZW50Tm9kZTspaT1pLnBhcmVudE5vZGU7Zm9yKHZhciBrPWk7ayYmXFxcIkhUTUxcXFwiIT1rLnRhZ05hbWU7KXtpZihrPT1iLmVsKXJldHVybiBpO2s9YShrKS5wYXJlbnQoKVswXX19fWNhdGNoKGwpe31yZXR1cm4gYi5lbH1mdW5jdGlvbiBoKCl7dmFyIGY9ZCgpO3RyeXtpZihmLnJhbmdlQ291bnQpe3ZhciBnLGg9ZSgwKSxpPWguZW5kQ29udGFpbmVyO2lmKGkubm9kZVR5cGU9PU5vZGUuRUxFTUVOVF9OT0RFKXt2YXIgaj0hMTtpLmNoaWxkTm9kZXMubGVuZ3RoPjAmJmkuY2hpbGROb2Rlc1toLmVuZE9mZnNldF0mJmEoaS5jaGlsZE5vZGVzW2guZW5kT2Zmc2V0XSkudGV4dCgpPT09YygpPyhpPWkuY2hpbGROb2Rlc1toLmVuZE9mZnNldF0saj0hMCk6IWguY29sbGFwc2VkJiZpLnByZXZpb3VzU2libGluZyYmaS5wcmV2aW91c1NpYmxpbmcubm9kZVR5cGU9PU5vZGUuRUxFTUVOVF9OT0RFPyhnPWkucHJldmlvdXNTaWJsaW5nLGcmJmcudGV4dENvbnRlbnQucmVwbGFjZSgvXFxcXHUyMDBCL2csXFxcIlxcXCIpPT09YygpLnJlcGxhY2UoL1xcXFx1MjAwQi9nLFxcXCJcXFwiKSYmKGk9ZyxqPSEwKSk6IWguY29sbGFwc2VkJiZpLmNoaWxkTm9kZXMubGVuZ3RoPjAmJmkuY2hpbGROb2Rlc1toLmVuZE9mZnNldF0mJihnPWkuY2hpbGROb2Rlc1toLmVuZE9mZnNldF0ucHJldmlvdXNTaWJsaW5nLGcubm9kZVR5cGU9PU5vZGUuRUxFTUVOVF9OT0RFJiZnJiZnLnRleHRDb250ZW50LnJlcGxhY2UoL1xcXFx1MjAwQi9nLFxcXCJcXFwiKT09PWMoKS5yZXBsYWNlKC9cXFxcdTIwMEIvZyxcXFwiXFxcIikmJihpPWcsaj0hMCkpLCFqJiZpLmNoaWxkTm9kZXMubGVuZ3RoPjAmJmEoaS5jaGlsZE5vZGVzW2kuY2hpbGROb2Rlcy5sZW5ndGgtMV0pLnRleHQoKT09PWMoKSYmW1xcXCJCUlxcXCIsXFxcIklNR1xcXCIsXFxcIkhSXFxcIl0uaW5kZXhPZihpLmNoaWxkTm9kZXNbaS5jaGlsZE5vZGVzLmxlbmd0aC0xXS50YWdOYW1lKTwwJiYoaT1pLmNoaWxkTm9kZXNbaS5jaGlsZE5vZGVzLmxlbmd0aC0xXSl9Zm9yKGkubm9kZVR5cGU9PU5vZGUuVEVYVF9OT0RFJiYwPT09aC5lbmRPZmZzZXQmJmkucHJldmlvdXNTaWJsaW5nJiZpLnByZXZpb3VzU2libGluZy5ub2RlVHlwZT09Tm9kZS5FTEVNRU5UX05PREUmJihpPWkucHJldmlvdXNTaWJsaW5nKTtpLm5vZGVUeXBlIT1Ob2RlLkVMRU1FTlRfTk9ERSYmaS5wYXJlbnROb2RlOylpPWkucGFyZW50Tm9kZTtmb3IodmFyIGs9aTtrJiZcXFwiSFRNTFxcXCIhPWsudGFnTmFtZTspe2lmKGs9PWIuZWwpcmV0dXJuIGk7az1hKGspLnBhcmVudCgpWzBdfX19Y2F0Y2gobCl7fXJldHVybiBiLmVsfWZ1bmN0aW9uIGkoYSxiKXt2YXIgYz1hO3JldHVybiBjLm5vZGVUeXBlPT1Ob2RlLkVMRU1FTlRfTk9ERSYmYy5jaGlsZE5vZGVzLmxlbmd0aD4wJiZjLmNoaWxkTm9kZXNbYl0mJihjPWMuY2hpbGROb2Rlc1tiXSksYy5ub2RlVHlwZT09Tm9kZS5URVhUX05PREUmJihjPWMucGFyZW50Tm9kZSksY31mdW5jdGlvbiBqKCl7dmFyIGMsZj1bXSxnPWQoKTtpZih1KCkmJmcucmFuZ2VDb3VudCl7dmFyIGg9ZSgpO2ZvcihjPTA7YzxoLmxlbmd0aDtjKyspe3ZhciBqLGs9aFtjXSxsPWkoay5zdGFydENvbnRhaW5lcixrLnN0YXJ0T2Zmc2V0KSxtPWkoay5lbmRDb250YWluZXIsay5lbmRPZmZzZXQpO2Iubm9kZS5pc0Jsb2NrKGwpJiZmLmluZGV4T2YobCk8MCYmZi5wdXNoKGwpLGo9Yi5ub2RlLmJsb2NrUGFyZW50KGwpLGomJmYuaW5kZXhPZihqKTwwJiZmLnB1c2goaik7Zm9yKHZhciBuPVtdLG89bDtvIT09bSYmbyE9PWIuZWw7KW4uaW5kZXhPZihvKTwwJiZvLmNoaWxkcmVuJiZvLmNoaWxkcmVuLmxlbmd0aD8obi5wdXNoKG8pLG89by5jaGlsZHJlblswXSk6by5uZXh0U2libGluZz9vPW8ubmV4dFNpYmxpbmc6by5wYXJlbnROb2RlJiYobz1vLnBhcmVudE5vZGUsbi5wdXNoKG8pKSxiLm5vZGUuaXNCbG9jayhvKSYmbi5pbmRleE9mKG8pPDAmJmYuaW5kZXhPZihvKTwwJiYobyE9PW18fGsuZW5kT2Zmc2V0PjApJiZmLnB1c2gobyk7Yi5ub2RlLmlzQmxvY2sobSkmJmYuaW5kZXhPZihtKTwwJiZrLmVuZE9mZnNldD4wJiZmLnB1c2gobSksaj1iLm5vZGUuYmxvY2tQYXJlbnQobSksaiYmZi5pbmRleE9mKGopPDAmJmYucHVzaChqKX19Zm9yKGM9Zi5sZW5ndGgtMTtjPjA7Yy0tKWEoZltjXSkuZmluZChmKS5sZW5ndGgmJihcXFwiTElcXFwiIT1mW2NdLnRhZ05hbWV8fDE9PWZbY10uY2hpbGRyZW4ubGVuZ3RoJiZmLmluZGV4T2YoZltjXS5jaGlsZHJlblswXSk+PTApJiZmLnNwbGljZShjLDEpO3JldHVybiBmfWZ1bmN0aW9uIGsoKXtpZihiLiR3cCl7Yi5tYXJrZXJzLnJlbW92ZSgpO3ZhciBhLGMsZD1lKCksZj1bXTtmb3IoYz0wO2M8ZC5sZW5ndGg7YysrKWlmKGRbY10uc3RhcnRDb250YWluZXIhPT1iLmRvYyl7YT1kW2NdO3ZhciBnPWEuY29sbGFwc2VkLGg9Yi5tYXJrZXJzLnBsYWNlKGEsITAsYyksaT1iLm1hcmtlcnMucGxhY2UoYSwhMSxjKTtiLmVsLm5vcm1hbGl6ZSgpLGIuYnJvd3Nlci5zYWZhcmkmJiFnJiYoYT1iLmRvYy5jcmVhdGVSYW5nZSgpLGEuc2V0U3RhcnRBZnRlcihoKSxhLnNldEVuZEJlZm9yZShpKSxmLnB1c2goYSkpfWlmKGIuYnJvd3Nlci5zYWZhcmkmJmYubGVuZ3RoKWZvcihiLnNlbGVjdGlvbi5jbGVhcigpLGM9MDtjPGYubGVuZ3RoO2MrKyliLnNlbGVjdGlvbi5nZXQoKS5hZGRSYW5nZShmW2NdKX19ZnVuY3Rpb24gbCgpe3ZhciBjLGU9Yi5lbC5xdWVyeVNlbGVjdG9yQWxsKCcuZnItbWFya2VyW2RhdGEtdHlwZT1cXFwidHJ1ZVxcXCJdJyk7aWYoIWIuJHdwKXJldHVybiBiLm1hcmtlcnMucmVtb3ZlKCksITE7aWYoMD09PWUubGVuZ3RoKXJldHVybiExO2lmKGIuYnJvd3Nlci5tc2llfHxiLmJyb3dzZXIuZWRnZSlmb3IoYz0wO2M8ZS5sZW5ndGg7YysrKWVbY10uc3R5bGUuZGlzcGxheT1cXFwiaW5saW5lLWJsb2NrXFxcIjtiLmNvcmUuaGFzRm9jdXMoKXx8Yi5icm93c2VyLm1zaWV8fGIuYnJvd3Nlci53ZWJraXR8fGIuJGVsLmZvY3VzKCksZigpO3ZhciBnPWQoKTtmb3IoYz0wO2M8ZS5sZW5ndGg7YysrKXt2YXIgaD1hKGVbY10pLmRhdGEoXFxcImlkXFxcIiksaT1lW2NdLGo9Yi5kb2MuY3JlYXRlUmFuZ2UoKSxrPWIuJGVsLmZpbmQoJy5mci1tYXJrZXJbZGF0YS10eXBlPVxcXCJmYWxzZVxcXCJdW2RhdGEtaWQ9XFxcIicraCsnXFxcIl0nKTsoYi5icm93c2VyLm1zaWV8fGIuYnJvd3Nlci5lZGdlKSYmay5jc3MoXFxcImRpc3BsYXlcXFwiLFxcXCJpbmxpbmUtYmxvY2tcXFwiKTt2YXIgbD1udWxsO2lmKGsubGVuZ3RoPjApe2s9a1swXTt0cnl7Zm9yKHZhciBuLG89ITEscD1pLm5leHRTaWJsaW5nO3AmJnAubm9kZVR5cGU9PU5vZGUuVEVYVF9OT0RFJiYwPT09cC50ZXh0Q29udGVudC5sZW5ndGg7KW49cCxwPXAubmV4dFNpYmxpbmcsYShuKS5yZW1vdmUoKTtmb3IodmFyIHE9ay5uZXh0U2libGluZztxJiZxLm5vZGVUeXBlPT1Ob2RlLlRFWFRfTk9ERSYmMD09PXEudGV4dENvbnRlbnQubGVuZ3RoOyluPXEscT1xLm5leHRTaWJsaW5nLGEobikucmVtb3ZlKCk7aWYoaS5uZXh0U2libGluZz09a3x8ay5uZXh0U2libGluZz09aSl7Zm9yKHZhciByPWkubmV4dFNpYmxpbmc9PWs/aTprLHM9cj09aT9rOmksdD1yLnByZXZpb3VzU2libGluZzt0JiZ0Lm5vZGVUeXBlPT1Ob2RlLlRFWFRfTk9ERSYmMD09PXQubGVuZ3RoOyluPXQsdD10LnByZXZpb3VzU2libGluZyxhKG4pLnJlbW92ZSgpO2lmKHQmJnQubm9kZVR5cGU9PU5vZGUuVEVYVF9OT0RFKWZvcig7dCYmdC5wcmV2aW91c1NpYmxpbmcmJnQucHJldmlvdXNTaWJsaW5nLm5vZGVUeXBlPT1Ob2RlLlRFWFRfTk9ERTspdC5wcmV2aW91c1NpYmxpbmcudGV4dENvbnRlbnQ9dC5wcmV2aW91c1NpYmxpbmcudGV4dENvbnRlbnQrdC50ZXh0Q29udGVudCx0PXQucHJldmlvdXNTaWJsaW5nLGEodC5uZXh0U2libGluZykucmVtb3ZlKCk7Zm9yKHZhciB1PXMubmV4dFNpYmxpbmc7dSYmdS5ub2RlVHlwZT09Tm9kZS5URVhUX05PREUmJjA9PT11Lmxlbmd0aDspbj11LHU9dS5uZXh0U2libGluZyxhKG4pLnJlbW92ZSgpO2lmKHUmJnUubm9kZVR5cGU9PU5vZGUuVEVYVF9OT0RFKWZvcig7dSYmdS5uZXh0U2libGluZyYmdS5uZXh0U2libGluZy5ub2RlVHlwZT09Tm9kZS5URVhUX05PREU7KXUubmV4dFNpYmxpbmcudGV4dENvbnRlbnQ9dS50ZXh0Q29udGVudCt1Lm5leHRTaWJsaW5nLnRleHRDb250ZW50LHU9dS5uZXh0U2libGluZyxhKHUucHJldmlvdXNTaWJsaW5nKS5yZW1vdmUoKTtpZih0JiYoYi5ub2RlLmlzVm9pZCh0KXx8Yi5ub2RlLmlzQmxvY2sodCkpJiYodD1udWxsKSx1JiYoYi5ub2RlLmlzVm9pZCh1KXx8Yi5ub2RlLmlzQmxvY2sodSkpJiYodT1udWxsKSx0JiZ1JiZ0Lm5vZGVUeXBlPT1Ob2RlLlRFWFRfTk9ERSYmdS5ub2RlVHlwZT09Tm9kZS5URVhUX05PREUpe2EoaSkucmVtb3ZlKCksYShrKS5yZW1vdmUoKTt2YXIgdj10LnRleHRDb250ZW50Lmxlbmd0aDt0LnRleHRDb250ZW50PXQudGV4dENvbnRlbnQrdS50ZXh0Q29udGVudCxhKHUpLnJlbW92ZSgpLGIuc3BhY2VzLm5vcm1hbGl6ZSh0KSxqLnNldFN0YXJ0KHQsdiksai5zZXRFbmQodCx2KSxvPSEwfWVsc2UhdCYmdSYmdS5ub2RlVHlwZT09Tm9kZS5URVhUX05PREU/KGEoaSkucmVtb3ZlKCksYShrKS5yZW1vdmUoKSxiLnNwYWNlcy5ub3JtYWxpemUodSksbD1hKGIuZG9jLmNyZWF0ZVRleHROb2RlKFxcXCJcXFxcdTIwMGJcXFwiKSksYSh1KS5iZWZvcmUobCksai5zZXRTdGFydCh1LDApLGouc2V0RW5kKHUsMCksbz0hMCk6IXUmJnQmJnQubm9kZVR5cGU9PU5vZGUuVEVYVF9OT0RFJiYoYShpKS5yZW1vdmUoKSxhKGspLnJlbW92ZSgpLGIuc3BhY2VzLm5vcm1hbGl6ZSh0KSxsPWEoYi5kb2MuY3JlYXRlVGV4dE5vZGUoXFxcIlxcXFx1MjAwYlxcXCIpKSxhKHQpLmFmdGVyKGwpLGouc2V0U3RhcnQodCx0LnRleHRDb250ZW50Lmxlbmd0aCksai5zZXRFbmQodCx0LnRleHRDb250ZW50Lmxlbmd0aCksbz0hMCl9aWYoIW8pe3ZhciB3LHg7KGIuYnJvd3Nlci5jaHJvbWV8fGIuYnJvd3Nlci5lZGdlKSYmaS5uZXh0U2libGluZz09az8odz1tKGssaiwhMCl8fGouc2V0U3RhcnRBZnRlcihrKSx4PW0oaSxqLCExKXx8ai5zZXRFbmRCZWZvcmUoaSkpOihpLnByZXZpb3VzU2libGluZz09ayYmKGk9ayxrPWkubmV4dFNpYmxpbmcpLGsubmV4dFNpYmxpbmcmJlxcXCJCUlxcXCI9PT1rLm5leHRTaWJsaW5nLnRhZ05hbWV8fCFrLm5leHRTaWJsaW5nJiZiLm5vZGUuaXNCbG9jayhpLnByZXZpb3VzU2libGluZyl8fGkucHJldmlvdXNTaWJsaW5nJiZcXFwiQlJcXFwiPT1pLnByZXZpb3VzU2libGluZy50YWdOYW1lfHwoaS5zdHlsZS5kaXNwbGF5PVxcXCJpbmxpbmVcXFwiLGsuc3R5bGUuZGlzcGxheT1cXFwiaW5saW5lXFxcIixsPWEoYi5kb2MuY3JlYXRlVGV4dE5vZGUoXFxcIlxcXFx1MjAwYlxcXCIpKSksdz1tKGksaiwhMCl8fGEoaSkuYmVmb3JlKGwpJiZqLnNldFN0YXJ0QmVmb3JlKGkpLHg9bShrLGosITEpfHxhKGspLmFmdGVyKGwpJiZqLnNldEVuZEFmdGVyKGspKSxcXFwiZnVuY3Rpb25cXFwiPT10eXBlb2YgdyYmdygpLFxcXCJmdW5jdGlvblxcXCI9PXR5cGVvZiB4JiZ4KCl9fWNhdGNoKHkpe319bCYmbC5yZW1vdmUoKTt0cnl7Zy5hZGRSYW5nZShqKX1jYXRjaCh5KXt9fWIubWFya2Vycy5yZW1vdmUoKX1mdW5jdGlvbiBtKGMsZCxlKXt2YXIgZixnPWMucHJldmlvdXNTaWJsaW5nLGg9Yy5uZXh0U2libGluZztyZXR1cm4gZyYmaCYmZy5ub2RlVHlwZT09Tm9kZS5URVhUX05PREUmJmgubm9kZVR5cGU9PU5vZGUuVEVYVF9OT0RFPyhmPWcudGV4dENvbnRlbnQubGVuZ3RoLGU/KGgudGV4dENvbnRlbnQ9Zy50ZXh0Q29udGVudCtoLnRleHRDb250ZW50LGEoZykucmVtb3ZlKCksYShjKS5yZW1vdmUoKSxiLnNwYWNlcy5ub3JtYWxpemUoaCksZnVuY3Rpb24oKXtkLnNldFN0YXJ0KGgsZil9KTooZy50ZXh0Q29udGVudD1nLnRleHRDb250ZW50K2gudGV4dENvbnRlbnQsYShoKS5yZW1vdmUoKSxhKGMpLnJlbW92ZSgpLGIuc3BhY2VzLm5vcm1hbGl6ZShnKSxmdW5jdGlvbigpe2Quc2V0RW5kKGcsZil9KSk6ZyYmIWgmJmcubm9kZVR5cGU9PU5vZGUuVEVYVF9OT0RFPyhmPWcudGV4dENvbnRlbnQubGVuZ3RoLGU/KGIuc3BhY2VzLm5vcm1hbGl6ZShnKSxmdW5jdGlvbigpe2Quc2V0U3RhcnQoZyxmKX0pOihiLnNwYWNlcy5ub3JtYWxpemUoZyksZnVuY3Rpb24oKXtkLnNldEVuZChnLGYpfSkpOiEoIWh8fGd8fGgubm9kZVR5cGUhPU5vZGUuVEVYVF9OT0RFKSYmKGU/KGIuc3BhY2VzLm5vcm1hbGl6ZShoKSxcXG5mdW5jdGlvbigpe2Quc2V0U3RhcnQoaCwwKX0pOihiLnNwYWNlcy5ub3JtYWxpemUoaCksZnVuY3Rpb24oKXtkLnNldEVuZChoLDApfSkpfWZ1bmN0aW9uIG4oKXtyZXR1cm4hMH1mdW5jdGlvbiBvKCl7Zm9yKHZhciBhPWUoKSxiPTA7YjxhLmxlbmd0aDtiKyspaWYoIWFbYl0uY29sbGFwc2VkKXJldHVybiExO3JldHVybiEwfWZ1bmN0aW9uIHAoYSl7dmFyIGMsZCxlPSExLGY9ITE7aWYoYi53aW4uZ2V0U2VsZWN0aW9uKXt2YXIgZz1iLndpbi5nZXRTZWxlY3Rpb24oKTtnLnJhbmdlQ291bnQmJihjPWcuZ2V0UmFuZ2VBdCgwKSxkPWMuY2xvbmVSYW5nZSgpLGQuc2VsZWN0Tm9kZUNvbnRlbnRzKGEpLGQuc2V0RW5kKGMuc3RhcnRDb250YWluZXIsYy5zdGFydE9mZnNldCksZT1cXFwiXFxcIj09PWQudG9TdHJpbmcoKSxkLnNlbGVjdE5vZGVDb250ZW50cyhhKSxkLnNldFN0YXJ0KGMuZW5kQ29udGFpbmVyLGMuZW5kT2Zmc2V0KSxmPVxcXCJcXFwiPT09ZC50b1N0cmluZygpKX1lbHNlIGIuZG9jLnNlbGVjdGlvbiYmXFxcIkNvbnRyb2xcXFwiIT1iLmRvYy5zZWxlY3Rpb24udHlwZSYmKGM9Yi5kb2Muc2VsZWN0aW9uLmNyZWF0ZVJhbmdlKCksZD1jLmR1cGxpY2F0ZSgpLGQubW92ZVRvRWxlbWVudFRleHQoYSksZC5zZXRFbmRQb2ludChcXFwiRW5kVG9TdGFydFxcXCIsYyksZT1cXFwiXFxcIj09PWQudGV4dCxkLm1vdmVUb0VsZW1lbnRUZXh0KGEpLGQuc2V0RW5kUG9pbnQoXFxcIlN0YXJ0VG9FbmRcXFwiLGMpLGY9XFxcIlxcXCI9PT1kLnRleHQpO3JldHVybnthdFN0YXJ0OmUsYXRFbmQ6Zn19ZnVuY3Rpb24gcSgpe2lmKG8oKSlyZXR1cm4hMTtiLiRlbC5maW5kKFxcXCJ0ZCwgdGgsIGltZywgYnI6bm90KDpsYXN0KVxcXCIpLnByZXBlbmQoJzxzcGFuIGNsYXNzPVxcXCJmci1ta1xcXCI+JythLkZFLklOVklTSUJMRV9TUEFDRStcXFwiPC9zcGFuPlxcXCIpO3ZhciBjPSExLGQ9cChiLmVsKTtyZXR1cm4gZC5hdFN0YXJ0JiZkLmF0RW5kJiYoYz0hMCksYi4kZWwuZmluZChcXFwiLmZyLW1rXFxcIikucmVtb3ZlKCksY31mdW5jdGlvbiByKGMsZCl7XFxcInVuZGVmaW5lZFxcXCI9PXR5cGVvZiBkJiYoZD0hMCk7dmFyIGU9YShjKS5odG1sKCk7ZSYmZS5yZXBsYWNlKC9cXFxcdTIwMGIvZyxcXFwiXFxcIikubGVuZ3RoIT1lLmxlbmd0aCYmYShjKS5odG1sKGUucmVwbGFjZSgvXFxcXHUyMDBiL2csXFxcIlxcXCIpKTtmb3IodmFyIGY9Yi5ub2RlLmNvbnRlbnRzKGMpLGc9MDtnPGYubGVuZ3RoO2crKylmW2ddLm5vZGVUeXBlIT1Ob2RlLkVMRU1FTlRfTk9ERT9hKGZbZ10pLnJlbW92ZSgpOihyKGZbZ10sMD09PWcpLDA9PT1nJiYoZD0hMSkpO2Mubm9kZVR5cGU9PU5vZGUuVEVYVF9OT0RFP2EoYykucmVwbGFjZVdpdGgoJzxzcGFuIGRhdGEtZmlyc3Q9XFxcInRydWVcXFwiIGRhdGEtdGV4dD1cXFwidHJ1ZVxcXCI+PC9zcGFuPicpOmQmJmEoYykuYXR0cihcXFwiZGF0YS1maXJzdFxcXCIsITApfWZ1bmN0aW9uIHMoKXtyZXR1cm4gMD09PWEodGhpcykuZmluZChcXFwiZnItaW5uZXJcXFwiKS5sZW5ndGh9ZnVuY3Rpb24gdChjLGQpe3ZhciBlPWIubm9kZS5jb250ZW50cyhjLmdldCgwKSk7W1xcXCJURFxcXCIsXFxcIlRIXFxcIl0uaW5kZXhPZihjLmdldCgwKS50YWdOYW1lKT49MCYmMT09Yy5maW5kKFxcXCIuZnItbWFya2VyXFxcIikubGVuZ3RoJiZiLm5vZGUuaGFzQ2xhc3MoZVswXSxcXFwiZnItbWFya2VyXFxcIikmJmMuYXR0cihcXFwiZGF0YS1kZWwtY2VsbFxcXCIsITApO2Zvcih2YXIgZj0wO2Y8ZS5sZW5ndGg7ZisrKXt2YXIgZz1lW2ZdO2Iubm9kZS5oYXNDbGFzcyhnLFxcXCJmci1tYXJrZXJcXFwiKT9kPShkKzEpJTI6ZD9hKGcpLmZpbmQoXFxcIi5mci1tYXJrZXJcXFwiKS5sZW5ndGg+MD9kPXQoYShnKSxkKTpbXFxcIlREXFxcIixcXFwiVEhcXFwiXS5pbmRleE9mKGcudGFnTmFtZSk8MCYmIWIubm9kZS5oYXNDbGFzcyhnLFxcXCJmci1pbm5lclxcXCIpPyFiLm9wdHMua2VlcEZvcm1hdE9uRGVsZXRlfHxiLiRlbC5maW5kKFxcXCJbZGF0YS1maXJzdF1cXFwiKS5sZW5ndGg+MD9hKGcpLnJlbW92ZSgpOnIoZyk6Yi5ub2RlLmhhc0NsYXNzKGcsXFxcImZyLWlubmVyXFxcIik/MD09PWEoZykuZmluZChcXFwiLmZyLWlubmVyXFxcIikubGVuZ3RoP2EoZykuaHRtbChcXFwiPGJyPlxcXCIpOmEoZykuZmluZChcXFwiLmZyLWlubmVyXFxcIikuZmlsdGVyKHMpLmh0bWwoXFxcIjxicj5cXFwiKTooYShnKS5lbXB0eSgpLGEoZykuYXR0cihcXFwiZGF0YS1kZWwtY2VsbFxcXCIsITApKTphKGcpLmZpbmQoXFxcIi5mci1tYXJrZXJcXFwiKS5sZW5ndGg+MCYmKGQ9dChhKGcpLGQpKX1yZXR1cm4gZH1mdW5jdGlvbiB1KCl7dHJ5e2lmKCFiLiR3cClyZXR1cm4hMTtmb3IodmFyIGE9ZSgwKSxjPWEuY29tbW9uQW5jZXN0b3JDb250YWluZXI7YyYmIWIubm9kZS5pc0VsZW1lbnQoYyk7KWM9Yy5wYXJlbnROb2RlO3JldHVybiEhYi5ub2RlLmlzRWxlbWVudChjKX1jYXRjaChkKXtyZXR1cm4hMX19ZnVuY3Rpb24gdigpe2lmKG8oKSlyZXR1cm4hMDt2YXIgYztrKCk7dmFyIGQ9ZnVuY3Rpb24oYil7Zm9yKHZhciBjPWIucHJldmlvdXNTaWJsaW5nO2MmJmMubm9kZVR5cGU9PU5vZGUuVEVYVF9OT0RFJiYwPT09Yy50ZXh0Q29udGVudC5sZW5ndGg7KXt2YXIgZD1jO2M9Yy5wcmV2aW91c1NpYmxpbmcsYShkKS5yZW1vdmUoKX1yZXR1cm4gY30sZT1mdW5jdGlvbihiKXtmb3IodmFyIGM9Yi5uZXh0U2libGluZztjJiZjLm5vZGVUeXBlPT1Ob2RlLlRFWFRfTk9ERSYmMD09PWMudGV4dENvbnRlbnQubGVuZ3RoOyl7dmFyIGQ9YztjPWMubmV4dFNpYmxpbmcsYShkKS5yZW1vdmUoKX1yZXR1cm4gY30sZj1iLiRlbC5maW5kKCcuZnItbWFya2VyW2RhdGEtdHlwZT1cXFwidHJ1ZVxcXCJdJyk7Zm9yKGM9MDtjPGYubGVuZ3RoO2MrKylmb3IodmFyIGc9ZltjXTshZChnKSYmIWIubm9kZS5pc0Jsb2NrKGcucGFyZW50Tm9kZSkmJiFiLiRlbC5pcyhnLnBhcmVudE5vZGUpOylhKGcucGFyZW50Tm9kZSkuYmVmb3JlKGcpO3ZhciBoPWIuJGVsLmZpbmQoJy5mci1tYXJrZXJbZGF0YS10eXBlPVxcXCJmYWxzZVxcXCJdJyk7Zm9yKGM9MDtjPGgubGVuZ3RoO2MrKyl7Zm9yKHZhciBpPWhbY107IWUoaSkmJiFiLm5vZGUuaXNCbG9jayhpLnBhcmVudE5vZGUpJiYhYi4kZWwuaXMoaS5wYXJlbnROb2RlKTspYShpLnBhcmVudE5vZGUpLmFmdGVyKGkpO2kucGFyZW50Tm9kZSYmYi5ub2RlLmlzQmxvY2soaS5wYXJlbnROb2RlKSYmYi5ub2RlLmlzRW1wdHkoaS5wYXJlbnROb2RlKSYmIWIuJGVsLmlzKGkucGFyZW50Tm9kZSkmJmIub3B0cy5rZWVwRm9ybWF0T25EZWxldGUmJmEoaS5wYXJlbnROb2RlKS5hZnRlcihpKX1pZihuKCkpe3QoYi4kZWwsMCk7dmFyIGo9Yi4kZWwuZmluZCgnW2RhdGEtZmlyc3Q9XFxcInRydWVcXFwiXScpO2lmKGoubGVuZ3RoKWIuJGVsLmZpbmQoXFxcIi5mci1tYXJrZXJcXFwiKS5yZW1vdmUoKSxqLmFwcGVuZChhLkZFLklOVklTSUJMRV9TUEFDRSthLkZFLk1BUktFUlMpLnJlbW92ZUF0dHIoXFxcImRhdGEtZmlyc3RcXFwiKSxqLmF0dHIoXFxcImRhdGEtdGV4dFxcXCIpJiZqLnJlcGxhY2VXaXRoKGouaHRtbCgpKTtlbHNlIGZvcihiLiRlbC5maW5kKFxcXCJ0YWJsZVxcXCIpLmZpbHRlcihmdW5jdGlvbigpe3ZhciBiPWEodGhpcykuZmluZChcXFwiW2RhdGEtZGVsLWNlbGxdXFxcIikubGVuZ3RoPjAmJmEodGhpcykuZmluZChcXFwiW2RhdGEtZGVsLWNlbGxdXFxcIikubGVuZ3RoPT1hKHRoaXMpLmZpbmQoXFxcInRkLCB0aFxcXCIpLmxlbmd0aDtyZXR1cm4gYn0pLnJlbW92ZSgpLGIuJGVsLmZpbmQoXFxcIltkYXRhLWRlbC1jZWxsXVxcXCIpLnJlbW92ZUF0dHIoXFxcImRhdGEtZGVsLWNlbGxcXFwiKSxmPWIuJGVsLmZpbmQoJy5mci1tYXJrZXJbZGF0YS10eXBlPVxcXCJ0cnVlXFxcIl0nKSxjPTA7YzxmLmxlbmd0aDtjKyspe3ZhciBtPWZbY10scD1tLm5leHRTaWJsaW5nLHE9Yi4kZWwuZmluZCgnLmZyLW1hcmtlcltkYXRhLXR5cGU9XFxcImZhbHNlXFxcIl1bZGF0YS1pZD1cXFwiJythKG0pLmRhdGEoXFxcImlkXFxcIikrJ1xcXCJdJykuZ2V0KDApO2lmKHEpe2lmKG0mJighcHx8cCE9cSkpe3ZhciByPWIubm9kZS5ibG9ja1BhcmVudChtKSxzPWIubm9kZS5ibG9ja1BhcmVudChxKSx1PSExLHY9ITE7aWYociYmW1xcXCJVTFxcXCIsXFxcIk9MXFxcIl0uaW5kZXhPZihyLnRhZ05hbWUpPj0wJiYocj1udWxsLHU9ITApLHMmJltcXFwiVUxcXFwiLFxcXCJPTFxcXCJdLmluZGV4T2Yocy50YWdOYW1lKT49MCYmKHM9bnVsbCx2PSEwKSxhKG0pLmFmdGVyKHEpLHIhPXMpaWYobnVsbCE9cnx8dSlpZihudWxsIT1zfHx2fHwwIT09YShyKS5wYXJlbnRzVW50aWwoYi4kZWwsXFxcInRhYmxlXFxcIikubGVuZ3RoKXImJnMmJjA9PT1hKHIpLnBhcmVudHNVbnRpbChiLiRlbCxcXFwidGFibGVcXFwiKS5sZW5ndGgmJjA9PT1hKHMpLnBhcmVudHNVbnRpbChiLiRlbCxcXFwidGFibGVcXFwiKS5sZW5ndGgmJihhKHIpLmFwcGVuZChhKHMpLmh0bWwoKSksYShzKS5yZW1vdmUoKSk7ZWxzZXtmb3IocD1yOyFwLm5leHRTaWJsaW5nJiZwLnBhcmVudE5vZGUhPWIuZWw7KXA9cC5wYXJlbnROb2RlO2ZvcihwPXAubmV4dFNpYmxpbmc7cCYmXFxcIkJSXFxcIiE9cC50YWdOYW1lOyl7dmFyIHc9cC5uZXh0U2libGluZzthKHIpLmFwcGVuZChwKSxwPXd9cCYmXFxcIkJSXFxcIj09cC50YWdOYW1lJiZhKHApLnJlbW92ZSgpfWVsc2V7dmFyIHg9Yi5ub2RlLmRlZXBlc3RQYXJlbnQobSk7eD8oYSh4KS5hZnRlcihhKHMpLmh0bWwoKSksYShzKS5yZW1vdmUoKSk6MD09PWEocykucGFyZW50c1VudGlsKGIuJGVsLFxcXCJ0YWJsZVxcXCIpLmxlbmd0aCYmKGEobSkubmV4dCgpLmFmdGVyKGEocykuaHRtbCgpKSxhKHMpLnJlbW92ZSgpKX19fWVsc2UgcT1hKG0pLmNsb25lKCkuYXR0cihcXFwiZGF0YS10eXBlXFxcIiwhMSksYShtKS5hZnRlcihxKX19Yi5vcHRzLmtlZXBGb3JtYXRPbkRlbGV0ZXx8Yi5odG1sLmZpbGxFbXB0eUJsb2NrcygpLGIuaHRtbC5jbGVhbkVtcHR5VGFncyghMCksYi5jbGVhbi5saXN0cygpLGIuc3BhY2VzLm5vcm1hbGl6ZSgpO3ZhciB5PWIuJGVsLmZpbmQoXFxcIi5mci1tYXJrZXI6bGFzdFxcXCIpLmdldCgwKSx6PWIuJGVsLmZpbmQoXFxcIi5mci1tYXJrZXI6Zmlyc3RcXFwiKS5nZXQoMCk7XFxcInVuZGVmaW5lZFxcXCIhPXR5cGVvZiB5JiZcXFwidW5kZWZpbmVkXFxcIiE9dHlwZW9mIHomJiF5Lm5leHRTaWJsaW5nJiZ6LnByZXZpb3VzU2libGluZyYmXFxcIkJSXFxcIj09ei5wcmV2aW91c1NpYmxpbmcudGFnTmFtZSYmYi5ub2RlLmlzRWxlbWVudCh5LnBhcmVudE5vZGUpJiZiLm5vZGUuaXNFbGVtZW50KHoucGFyZW50Tm9kZSkmJmIuJGVsLmFwcGVuZChcXFwiPGJyPlxcXCIpLGwoKX1mdW5jdGlvbiB3KGMpe2lmKCFjfHxjLmdldEVsZW1lbnRzQnlDbGFzc05hbWUoXFxcImZyLW1hcmtlclxcXCIpLmxlbmd0aD4wKXJldHVybiExO2Zvcih2YXIgZD1jLmZpcnN0Q2hpbGQ7ZCYmYi5ub2RlLmlzQmxvY2soZCk7KWM9ZCxkPWQuZmlyc3RDaGlsZDtjLmlubmVySFRNTD1hLkZFLk1BUktFUlMrYy5pbm5lckhUTUx9ZnVuY3Rpb24geChjKXtpZighY3x8Yy5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKFxcXCJmci1tYXJrZXJcXFwiKS5sZW5ndGg+MClyZXR1cm4hMTtmb3IodmFyIGQ9Yy5sYXN0Q2hpbGQ7ZCYmYi5ub2RlLmlzQmxvY2soZCk7KWM9ZCxkPWQubGFzdENoaWxkO2MuaW5uZXJIVE1MPWMuaW5uZXJIVE1MK2EuRkUuTUFSS0VSU31mdW5jdGlvbiB5KGMsZCl7XFxcInVuZGVmaW5lZFxcXCI9PXR5cGVvZiBkJiYoZD0hMCk7Zm9yKHZhciBlPWMucHJldmlvdXNTaWJsaW5nO2UmJmUubm9kZVR5cGU9PU5vZGUuVEVYVF9OT0RFJiYwPT09ZS50ZXh0Q29udGVudC5sZW5ndGg7KWU9ZS5wcmV2aW91c1NpYmxpbmc7cmV0dXJuIGU/KGIubm9kZS5pc0Jsb2NrKGUpP3goZSk6XFxcIkJSXFxcIj09ZS50YWdOYW1lP2EoZSkuYmVmb3JlKGEuRkUuTUFSS0VSUyk6YShlKS5hZnRlcihhLkZFLk1BUktFUlMpLCEwKTohIWQmJihiLm5vZGUuaXNCbG9jayhjKT93KGMpOmEoYykuYmVmb3JlKGEuRkUuTUFSS0VSUyksITApfWZ1bmN0aW9uIHooYyxkKXtcXFwidW5kZWZpbmVkXFxcIj09dHlwZW9mIGQmJihkPSEwKTtmb3IodmFyIGU9Yy5uZXh0U2libGluZztlJiZlLm5vZGVUeXBlPT1Ob2RlLlRFWFRfTk9ERSYmMD09PWUudGV4dENvbnRlbnQubGVuZ3RoOyllPWUubmV4dFNpYmxpbmc7cmV0dXJuIGU/KGIubm9kZS5pc0Jsb2NrKGUpP3coZSk6YShlKS5iZWZvcmUoYS5GRS5NQVJLRVJTKSwhMCk6ISFkJiYoYi5ub2RlLmlzQmxvY2soYyk/eChjKTphKGMpLmFmdGVyKGEuRkUuTUFSS0VSUyksITApfXJldHVybnt0ZXh0OmMsZ2V0OmQscmFuZ2VzOmUsY2xlYXI6ZixlbGVtZW50OmcsZW5kRWxlbWVudDpoLHNhdmU6ayxyZXN0b3JlOmwsaXNDb2xsYXBzZWQ6byxpc0Z1bGw6cSxpbkVkaXRvcjp1LHJlbW92ZTp2LGJsb2NrczpqLGluZm86cCxzZXRBdEVuZDp4LHNldEF0U3RhcnQ6dyxzZXRCZWZvcmU6eSxzZXRBZnRlcjp6LHJhbmdlRWxlbWVudDppfX0sYS5leHRlbmQoYS5GRS5ERUZBVUxUUyx7aHRtbEFsbG93ZWRUYWdzOltcXFwiYVxcXCIsXFxcImFiYnJcXFwiLFxcXCJhZGRyZXNzXFxcIixcXFwiYXJlYVxcXCIsXFxcImFydGljbGVcXFwiLFxcXCJhc2lkZVxcXCIsXFxcImF1ZGlvXFxcIixcXFwiYlxcXCIsXFxcImJhc2VcXFwiLFxcXCJiZGlcXFwiLFxcXCJiZG9cXFwiLFxcXCJibG9ja3F1b3RlXFxcIixcXFwiYnJcXFwiLFxcXCJidXR0b25cXFwiLFxcXCJjYW52YXNcXFwiLFxcXCJjYXB0aW9uXFxcIixcXFwiY2l0ZVxcXCIsXFxcImNvZGVcXFwiLFxcXCJjb2xcXFwiLFxcXCJjb2xncm91cFxcXCIsXFxcImRhdGFsaXN0XFxcIixcXFwiZGRcXFwiLFxcXCJkZWxcXFwiLFxcXCJkZXRhaWxzXFxcIixcXFwiZGZuXFxcIixcXFwiZGlhbG9nXFxcIixcXFwiZGl2XFxcIixcXFwiZGxcXFwiLFxcXCJkdFxcXCIsXFxcImVtXFxcIixcXFwiZW1iZWRcXFwiLFxcXCJmaWVsZHNldFxcXCIsXFxcImZpZ2NhcHRpb25cXFwiLFxcXCJmaWd1cmVcXFwiLFxcXCJmb290ZXJcXFwiLFxcXCJmb3JtXFxcIixcXFwiaDFcXFwiLFxcXCJoMlxcXCIsXFxcImgzXFxcIixcXFwiaDRcXFwiLFxcXCJoNVxcXCIsXFxcImg2XFxcIixcXFwiaGVhZGVyXFxcIixcXFwiaGdyb3VwXFxcIixcXFwiaHJcXFwiLFxcXCJpXFxcIixcXFwiaWZyYW1lXFxcIixcXFwiaW1nXFxcIixcXFwiaW5wdXRcXFwiLFxcXCJpbnNcXFwiLFxcXCJrYmRcXFwiLFxcXCJrZXlnZW5cXFwiLFxcXCJsYWJlbFxcXCIsXFxcImxlZ2VuZFxcXCIsXFxcImxpXFxcIixcXFwibGlua1xcXCIsXFxcIm1haW5cXFwiLFxcXCJtYXBcXFwiLFxcXCJtYXJrXFxcIixcXFwibWVudVxcXCIsXFxcIm1lbnVpdGVtXFxcIixcXFwibWV0ZXJcXFwiLFxcXCJuYXZcXFwiLFxcXCJub3NjcmlwdFxcXCIsXFxcIm9iamVjdFxcXCIsXFxcIm9sXFxcIixcXFwib3B0Z3JvdXBcXFwiLFxcXCJvcHRpb25cXFwiLFxcXCJvdXRwdXRcXFwiLFxcXCJwXFxcIixcXFwicGFyYW1cXFwiLFxcXCJwcmVcXFwiLFxcXCJwcm9ncmVzc1xcXCIsXFxcInF1ZXVlXFxcIixcXFwicnBcXFwiLFxcXCJydFxcXCIsXFxcInJ1YnlcXFwiLFxcXCJzXFxcIixcXFwic2FtcFxcXCIsXFxcInNjcmlwdFxcXCIsXFxcInN0eWxlXFxcIixcXFwic2VjdGlvblxcXCIsXFxcInNlbGVjdFxcXCIsXFxcInNtYWxsXFxcIixcXFwic291cmNlXFxcIixcXFwic3BhblxcXCIsXFxcInN0cmlrZVxcXCIsXFxcInN0cm9uZ1xcXCIsXFxcInN1YlxcXCIsXFxcInN1bW1hcnlcXFwiLFxcXCJzdXBcXFwiLFxcXCJ0YWJsZVxcXCIsXFxcInRib2R5XFxcIixcXFwidGRcXFwiLFxcXCJ0ZXh0YXJlYVxcXCIsXFxcInRmb290XFxcIixcXFwidGhcXFwiLFxcXCJ0aGVhZFxcXCIsXFxcInRpbWVcXFwiLFxcXCJ0clxcXCIsXFxcInRyYWNrXFxcIixcXFwidVxcXCIsXFxcInVsXFxcIixcXFwidmFyXFxcIixcXFwidmlkZW9cXFwiLFxcXCJ3YnJcXFwiXSxodG1sUmVtb3ZlVGFnczpbXFxcInNjcmlwdFxcXCIsXFxcInN0eWxlXFxcIl0saHRtbEFsbG93ZWRBdHRyczpbXFxcImFjY2VwdFxcXCIsXFxcImFjY2VwdC1jaGFyc2V0XFxcIixcXFwiYWNjZXNza2V5XFxcIixcXFwiYWN0aW9uXFxcIixcXFwiYWxpZ25cXFwiLFxcXCJhbGxvd2Z1bGxzY3JlZW5cXFwiLFxcXCJhbGxvd3RyYW5zcGFyZW5jeVxcXCIsXFxcImFsdFxcXCIsXFxcImFzeW5jXFxcIixcXFwiYXV0b2NvbXBsZXRlXFxcIixcXFwiYXV0b2ZvY3VzXFxcIixcXFwiYXV0b3BsYXlcXFwiLFxcXCJhdXRvc2F2ZVxcXCIsXFxcImJhY2tncm91bmRcXFwiLFxcXCJiZ2NvbG9yXFxcIixcXFwiYm9yZGVyXFxcIixcXFwiY2hhcnNldFxcXCIsXFxcImNlbGxwYWRkaW5nXFxcIixcXFwiY2VsbHNwYWNpbmdcXFwiLFxcXCJjaGVja2VkXFxcIixcXFwiY2l0ZVxcXCIsXFxcImNsYXNzXFxcIixcXFwiY29sb3JcXFwiLFxcXCJjb2xzXFxcIixcXFwiY29sc3BhblxcXCIsXFxcImNvbnRlbnRcXFwiLFxcXCJjb250ZW50ZWRpdGFibGVcXFwiLFxcXCJjb250ZXh0bWVudVxcXCIsXFxcImNvbnRyb2xzXFxcIixcXFwiY29vcmRzXFxcIixcXFwiZGF0YVxcXCIsXFxcImRhdGEtLipcXFwiLFxcXCJkYXRldGltZVxcXCIsXFxcImRlZmF1bHRcXFwiLFxcXCJkZWZlclxcXCIsXFxcImRpclxcXCIsXFxcImRpcm5hbWVcXFwiLFxcXCJkaXNhYmxlZFxcXCIsXFxcImRvd25sb2FkXFxcIixcXFwiZHJhZ2dhYmxlXFxcIixcXFwiZHJvcHpvbmVcXFwiLFxcXCJlbmN0eXBlXFxcIixcXFwiZm9yXFxcIixcXFwiZm9ybVxcXCIsXFxcImZvcm1hY3Rpb25cXFwiLFxcXCJmcmFtZWJvcmRlclxcXCIsXFxcImhlYWRlcnNcXFwiLFxcXCJoZWlnaHRcXFwiLFxcXCJoaWRkZW5cXFwiLFxcXCJoaWdoXFxcIixcXFwiaHJlZlxcXCIsXFxcImhyZWZsYW5nXFxcIixcXFwiaHR0cC1lcXVpdlxcXCIsXFxcImljb25cXFwiLFxcXCJpZFxcXCIsXFxcImlzbWFwXFxcIixcXFwiaXRlbXByb3BcXFwiLFxcXCJrZXl0eXBlXFxcIixcXFwia2luZFxcXCIsXFxcImxhYmVsXFxcIixcXFwibGFuZ1xcXCIsXFxcImxhbmd1YWdlXFxcIixcXFwibGlzdFxcXCIsXFxcImxvb3BcXFwiLFxcXCJsb3dcXFwiLFxcXCJtYXhcXFwiLFxcXCJtYXhsZW5ndGhcXFwiLFxcXCJtZWRpYVxcXCIsXFxcIm1ldGhvZFxcXCIsXFxcIm1pblxcXCIsXFxcIm1vemFsbG93ZnVsbHNjcmVlblxcXCIsXFxcIm11bHRpcGxlXFxcIixcXFwibmFtZVxcXCIsXFxcIm5vdmFsaWRhdGVcXFwiLFxcXCJvcGVuXFxcIixcXFwib3B0aW11bVxcXCIsXFxcInBhdHRlcm5cXFwiLFxcXCJwaW5nXFxcIixcXFwicGxhY2Vob2xkZXJcXFwiLFxcXCJwb3N0ZXJcXFwiLFxcXCJwcmVsb2FkXFxcIixcXFwicHViZGF0ZVxcXCIsXFxcInJhZGlvZ3JvdXBcXFwiLFxcXCJyZWFkb25seVxcXCIsXFxcInJlbFxcXCIsXFxcInJlcXVpcmVkXFxcIixcXFwicmV2ZXJzZWRcXFwiLFxcXCJyb3dzXFxcIixcXFwicm93c3BhblxcXCIsXFxcInNhbmRib3hcXFwiLFxcXCJzY29wZVxcXCIsXFxcInNjb3BlZFxcXCIsXFxcInNjcm9sbGluZ1xcXCIsXFxcInNlYW1sZXNzXFxcIixcXFwic2VsZWN0ZWRcXFwiLFxcXCJzaGFwZVxcXCIsXFxcInNpemVcXFwiLFxcXCJzaXplc1xcXCIsXFxcInNwYW5cXFwiLFxcXCJzcmNcXFwiLFxcXCJzcmNkb2NcXFwiLFxcXCJzcmNsYW5nXFxcIixcXFwic3Jjc2V0XFxcIixcXFwic3RhcnRcXFwiLFxcXCJzdGVwXFxcIixcXFwic3VtbWFyeVxcXCIsXFxcInNwZWxsY2hlY2tcXFwiLFxcXCJzdHlsZVxcXCIsXFxcInRhYmluZGV4XFxcIixcXFwidGFyZ2V0XFxcIixcXFwidGl0bGVcXFwiLFxcXCJ0eXBlXFxcIixcXFwidHJhbnNsYXRlXFxcIixcXFwidXNlbWFwXFxcIixcXFwidmFsdWVcXFwiLFxcXCJ2YWxpZ25cXFwiLFxcXCJ3ZWJraXRhbGxvd2Z1bGxzY3JlZW5cXFwiLFxcXCJ3aWR0aFxcXCIsXFxcIndyYXBcXFwiXSxodG1sQWxsb3dlZFN0eWxlUHJvcHM6W1xcXCIuKlxcXCJdLGh0bWxBbGxvd0NvbW1lbnRzOiEwLGh0bWxVbnRvdWNoZWQ6ITEsZnVsbFBhZ2U6ITF9KSxhLkZFLkhUTUw1TWFwPXtCOlxcXCJTVFJPTkdcXFwiLEk6XFxcIkVNXFxcIixTVFJJS0U6XFxcIlNcXFwifSxhLkZFLk1PRFVMRVMuY2xlYW49ZnVuY3Rpb24oYil7ZnVuY3Rpb24gYyhhKXtpZihhLm5vZGVUeXBlPT1Ob2RlLkVMRU1FTlRfTk9ERSYmYS5nZXRBdHRyaWJ1dGUoXFxcImNsYXNzXFxcIikmJmEuZ2V0QXR0cmlidXRlKFxcXCJjbGFzc1xcXCIpLmluZGV4T2YoXFxcImZyLW1hcmtlclxcXCIpPj0wKXJldHVybiExO3ZhciBkLGU9Yi5ub2RlLmNvbnRlbnRzKGEpLGY9W107Zm9yKGQ9MDtkPGUubGVuZ3RoO2QrKyllW2RdLm5vZGVUeXBlIT1Ob2RlLkVMRU1FTlRfTk9ERXx8Yi5ub2RlLmlzVm9pZChlW2RdKT9lW2RdLm5vZGVUeXBlPT1Ob2RlLlRFWFRfTk9ERSYmKGVbZF0udGV4dENvbnRlbnQ9ZVtkXS50ZXh0Q29udGVudC5yZXBsYWNlKC9cXFxcdTIwMGIvZyxcXFwiXFxcIikucmVwbGFjZSgvJi9nLFxcXCImYW1wO1xcXCIpKTplW2RdLnRleHRDb250ZW50LnJlcGxhY2UoL1xcXFx1MjAwYi9nLFxcXCJcXFwiKS5sZW5ndGghPWVbZF0udGV4dENvbnRlbnQubGVuZ3RoJiZjKGVbZF0pO2lmKGEubm9kZVR5cGU9PU5vZGUuRUxFTUVOVF9OT0RFJiYhYi5ub2RlLmlzVm9pZChhKSYmKGEubm9ybWFsaXplKCksZT1iLm5vZGUuY29udGVudHMoYSksZj1hLnF1ZXJ5U2VsZWN0b3JBbGwoXFxcIi5mci1tYXJrZXJcXFwiKSxlLmxlbmd0aC1mLmxlbmd0aD09PTApKXtmb3IoZD0wO2Q8ZS5sZW5ndGg7ZCsrKWlmKChlW2RdLmdldEF0dHJpYnV0ZShcXFwiY2xhc3NcXFwiKXx8XFxcIlxcXCIpLmluZGV4T2YoXFxcImZyLW1hcmtlclxcXCIpPDApcmV0dXJuITE7Zm9yKGQ9MDtkPGYubGVuZ3RoO2QrKylhLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGZbZF0uY2xvbmVOb2RlKCEwKSxhKTtyZXR1cm4gYS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGEpLCExfX1mdW5jdGlvbiBkKGEsYyl7aWYoYS5ub2RlVHlwZT09Tm9kZS5DT01NRU5UX05PREUpcmV0dXJuXFxcIjwhLS1cXFwiK2Eubm9kZVZhbHVlK1xcXCItLT5cXFwiO2lmKGEubm9kZVR5cGU9PU5vZGUuVEVYVF9OT0RFKXJldHVybiBjP2EudGV4dENvbnRlbnQucmVwbGFjZSgvXFxcXCYvZyxcXFwiJmFtcDtcXFwiKS5yZXBsYWNlKC88L2csXFxcIiZsdDtcXFwiKS5yZXBsYWNlKC8+L2csXFxcIiZndDtcXFwiKTphLnRleHRDb250ZW50LnJlcGxhY2UoL1xcXFwmL2csXFxcIiZhbXA7XFxcIikucmVwbGFjZSgvPC9nLFxcXCImbHQ7XFxcIikucmVwbGFjZSgvPi9nLFxcXCImZ3Q7XFxcIikucmVwbGFjZSgvXFxcXHUwMEEwL2csXFxcIiZuYnNwO1xcXCIpLnJlcGxhY2UoL1xcXFx1MDAwOS9nLFxcXCJcXFwiKTtpZihhLm5vZGVUeXBlIT1Ob2RlLkVMRU1FTlRfTk9ERSlyZXR1cm4gYS5vdXRlckhUTUw7aWYoYS5ub2RlVHlwZT09Tm9kZS5FTEVNRU5UX05PREUmJltcXFwiU1RZTEVcXFwiLFxcXCJTQ1JJUFRcXFwiLFxcXCJOT1NDUklQVFxcXCJdLmluZGV4T2YoYS50YWdOYW1lKT49MClyZXR1cm4gYS5vdXRlckhUTUw7aWYoYS5ub2RlVHlwZT09Tm9kZS5FTEVNRU5UX05PREUmJlxcXCJzdmdcXFwiPT1hLnRhZ05hbWUpe3ZhciBlPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXFxcImRpdlxcXCIpLGY9YS5jbG9uZU5vZGUoITApO3JldHVybiBlLmFwcGVuZENoaWxkKGYpLGUuaW5uZXJIVE1MfWlmKFxcXCJJRlJBTUVcXFwiPT1hLnRhZ05hbWUpcmV0dXJuIGEub3V0ZXJIVE1MO3ZhciBnPWEuY2hpbGROb2RlcztpZigwPT09Zy5sZW5ndGgpcmV0dXJuIGEub3V0ZXJIVE1MO2Zvcih2YXIgaD1cXFwiXFxcIixpPTA7aTxnLmxlbmd0aDtpKyspXFxcIlBSRVxcXCI9PWEudGFnTmFtZSYmKGM9ITApLGgrPWQoZ1tpXSxjKTtyZXR1cm4gYi5ub2RlLm9wZW5UYWdTdHJpbmcoYSkraCtiLm5vZGUuY2xvc2VUYWdTdHJpbmcoYSl9ZnVuY3Rpb24gZShhKXtyZXR1cm4gSz1bXSxhPWEucmVwbGFjZSgvPHNjcmlwdFxcXFxiW148XSooPzooPyE8XFxcXC9zY3JpcHQ+KTxbXjxdKikqPFxcXFwvc2NyaXB0Pi9naSxmdW5jdGlvbihhKXtyZXR1cm4gSy5wdXNoKGEpLFxcXCJbRlJPQUxBLkVESVRPUi5TQ1JJUFQgXFxcIisoSy5sZW5ndGgtMSkrXFxcIl1cXFwifSksYT1hLnJlcGxhY2UoLzxub3NjcmlwdFxcXFxiW148XSooPzooPyE8XFxcXC9ub3NjcmlwdD4pPFtePF0qKSo8XFxcXC9ub3NjcmlwdD4vZ2ksZnVuY3Rpb24oYSl7cmV0dXJuIEsucHVzaChhKSxcXFwiW0ZST0FMQS5FRElUT1IuTk9TQ1JJUFQgXFxcIisoSy5sZW5ndGgtMSkrXFxcIl1cXFwifSksYT1hLnJlcGxhY2UoLzxpbWcoKD86W1xcXFx3XFxcXFddKj8pKSBzcmM9XFxcIi9nLCc8aW1nJDEgZGF0YS1mci1zcmM9XFxcIicpfWZ1bmN0aW9uIGYoYSl7cmV0dXJuIGE9YS5yZXBsYWNlKC9cXFxcW0ZST0FMQVxcXFwuRURJVE9SXFxcXC5TQ1JJUFQgKFtcXFxcZF0qKVxcXFxdL2dpLGZ1bmN0aW9uKGEsYyl7cmV0dXJuIGIub3B0cy5odG1sUmVtb3ZlVGFncy5pbmRleE9mKFxcXCJzY3JpcHRcXFwiKT49MD9cXFwiXFxcIjpLW3BhcnNlSW50KGMsMTApXX0pLGE9YS5yZXBsYWNlKC9cXFxcW0ZST0FMQVxcXFwuRURJVE9SXFxcXC5OT1NDUklQVCAoW1xcXFxkXSopXFxcXF0vZ2ksZnVuY3Rpb24oYSxjKXtyZXR1cm4gYi5vcHRzLmh0bWxSZW1vdmVUYWdzLmluZGV4T2YoXFxcIm5vc2NyaXB0XFxcIik+PTA/XFxcIlxcXCI6S1twYXJzZUludChjLDEwKV0ucmVwbGFjZSgvXFxcXCZsdDsvZyxcXFwiPFxcXCIpLnJlcGxhY2UoL1xcXFwmZ3Q7L2csXFxcIj5cXFwiKX0pLGE9YS5yZXBsYWNlKC88aW1nKCg/OltcXFxcd1xcXFxXXSo/KSkgZGF0YS1mci1zcmM9XFxcIi9nLCc8aW1nJDEgc3JjPVxcXCInKX1mdW5jdGlvbiBnKGEpe3ZhciBiPWEucmVwbGFjZSgvOzsvZ2ksXFxcIjtcXFwiKTtyZXR1cm4gYj1iLnJlcGxhY2UoL147L2dpLFxcXCJcXFwiKSxcXFwiO1xcXCIhPWIuY2hhckF0KGIubGVuZ3RoKSYmKGIrPVxcXCI7XFxcIiksYn1mdW5jdGlvbiBoKGEpe3ZhciBjO2ZvcihjIGluIGEpaWYoYS5oYXNPd25Qcm9wZXJ0eShjKSl7dmFyIGQ9Yy5tYXRjaChJKSxlPW51bGw7XFxcInN0eWxlXFxcIj09YyYmYi5vcHRzLmh0bWxBbGxvd2VkU3R5bGVQcm9wcy5sZW5ndGgmJihlPWFbY10ubWF0Y2goSikpLGQmJmU/YVtjXT1nKGUuam9pbihcXFwiO1xcXCIpKTpkJiYoXFxcInN0eWxlXFxcIiE9Y3x8ZSl8fGRlbGV0ZSBhW2NdfWZvcih2YXIgZj1cXFwiXFxcIixoPU9iamVjdC5rZXlzKGEpLnNvcnQoKSxpPTA7aTxoLmxlbmd0aDtpKyspYz1oW2ldLGYrPWFbY10uaW5kZXhPZignXFxcIicpPDA/XFxcIiBcXFwiK2MrJz1cXFwiJythW2NdKydcXFwiJzpcXFwiIFxcXCIrYytcXFwiPSdcXFwiK2FbY10rXFxcIidcXFwiO3JldHVybiBmfWZ1bmN0aW9uIGkoYSxjLGQpe2lmKGIub3B0cy5mdWxsUGFnZSl7dmFyIGU9Yi5odG1sLmV4dHJhY3REb2N0eXBlKGQpLGY9aChiLmh0bWwuZXh0cmFjdE5vZGVBdHRycyhkLFxcXCJodG1sXFxcIikpO2M9bnVsbD09Yz9iLmh0bWwuZXh0cmFjdE5vZGUoZCxcXFwiaGVhZFxcXCIpfHxcXFwiPHRpdGxlPjwvdGl0bGU+XFxcIjpjO3ZhciBnPWgoYi5odG1sLmV4dHJhY3ROb2RlQXR0cnMoZCxcXFwiaGVhZFxcXCIpKSxpPWgoYi5odG1sLmV4dHJhY3ROb2RlQXR0cnMoZCxcXFwiYm9keVxcXCIpKTtyZXR1cm4gZStcXFwiPGh0bWxcXFwiK2YrXFxcIj48aGVhZFxcXCIrZytcXFwiPlxcXCIrYytcXFwiPC9oZWFkPjxib2R5XFxcIitpK1xcXCI+XFxcIithK1xcXCI8L2JvZHk+PC9odG1sPlxcXCJ9cmV0dXJuIGF9ZnVuY3Rpb24gaihjLGUpe3ZhciBmLGc9YShcXFwiPGRpdj5cXFwiK2MrXFxcIjwvZGl2PlxcXCIpLGg9XFxcIlxcXCI7aWYoZyl7dmFyIGk9Yi5ub2RlLmNvbnRlbnRzKGcuZ2V0KDApKTtmb3IoZj0wO2Y8aS5sZW5ndGg7ZisrKWUoaVtmXSk7Zm9yKGk9Yi5ub2RlLmNvbnRlbnRzKGcuZ2V0KDApKSxmPTA7ZjxpLmxlbmd0aDtmKyspaCs9ZChpW2ZdKX1yZXR1cm4gaH1mdW5jdGlvbiBrKGEsYyxkKXthPWUoYSk7dmFyIGc9YSxoPW51bGw7Yi5vcHRzLmZ1bGxQYWdlJiYoZz1iLmh0bWwuZXh0cmFjdE5vZGUoYSxcXFwiYm9keVxcXCIpfHwoYS5pbmRleE9mKFxcXCI8Ym9keVxcXCIpPj0wP1xcXCJcXFwiOmEpLGQmJihoPWIuaHRtbC5leHRyYWN0Tm9kZShhLFxcXCJoZWFkXFxcIil8fFxcXCJcXFwiKSksZz1qKGcsYyksaCYmKGg9aihoLGMpKTt2YXIgaz1pKGcsaCxhKTtyZXR1cm4gZihrKX1mdW5jdGlvbiBsKGEpe3JldHVybiBhLnJlcGxhY2UoL1xcXFx1MjAwYi9nLFxcXCJcXFwiKS5sZW5ndGg9PWEubGVuZ3RoP2E6Yi5jbGVhbi5leGVjKGEsYyl9ZnVuY3Rpb24gbSgpe3ZhciBjPWIuZWwucXVlcnlTZWxlY3RvckFsbChPYmplY3Qua2V5cyhhLkZFLkhUTUw1TWFwKS5qb2luKFxcXCIsXFxcIikpO2lmKGMubGVuZ3RoKXt2YXIgZD0hMTtiLmVsLnF1ZXJ5U2VsZWN0b3IoXFxcIi5mci1tYXJrZXJcXFwiKXx8KGIuc2VsZWN0aW9uLnNhdmUoKSxkPSEwKTtmb3IodmFyIGU9MDtlPGMubGVuZ3RoO2UrKylcXFwiXFxcIj09PWIubm9kZS5hdHRyaWJ1dGVzKGNbZV0pJiZhKGNbZV0pLnJlcGxhY2VXaXRoKFxcXCI8XFxcIithLkZFLkhUTUw1TWFwW2NbZV0udGFnTmFtZV0rXFxcIj5cXFwiK2NbZV0uaW5uZXJIVE1MK1xcXCI8L1xcXCIrYS5GRS5IVE1MNU1hcFtjW2VdLnRhZ05hbWVdK1xcXCI+XFxcIik7ZCYmYi5zZWxlY3Rpb24ucmVzdG9yZSgpfX1mdW5jdGlvbiBuKGMpe2lmKFxcXCJTUEFOXFxcIj09Yy50YWdOYW1lJiYoYy5nZXRBdHRyaWJ1dGUoXFxcImNsYXNzXFxcIil8fFxcXCJcXFwiKS5pbmRleE9mKFxcXCJmci1tYXJrZXJcXFwiKT49MClyZXR1cm4hMTtpZihcXFwiUFJFXFxcIj09Yy50YWdOYW1lJiZwKGMpLGMubm9kZVR5cGU9PU5vZGUuRUxFTUVOVF9OT0RFJiYoYy5nZXRBdHRyaWJ1dGUoXFxcImRhdGEtZnItc3JjXFxcIikmJmMuc2V0QXR0cmlidXRlKFxcXCJkYXRhLWZyLXNyY1xcXCIsYi5oZWxwZXJzLnNhbml0aXplVVJMKGMuZ2V0QXR0cmlidXRlKFxcXCJkYXRhLWZyLXNyY1xcXCIpKSksYy5nZXRBdHRyaWJ1dGUoXFxcImhyZWZcXFwiKSYmYy5zZXRBdHRyaWJ1dGUoXFxcImhyZWZcXFwiLGIuaGVscGVycy5zYW5pdGl6ZVVSTChjLmdldEF0dHJpYnV0ZShcXFwiaHJlZlxcXCIpKSksW1xcXCJUQUJMRVxcXCIsXFxcIlRCT0RZXFxcIixcXFwiVEZPT1RcXFwiLFxcXCJUUlxcXCJdLmluZGV4T2YoYy50YWdOYW1lKT49MCYmKGMuaW5uZXJIVE1MPWMuaW5uZXJIVE1MLnRyaW0oKSkpLCFiLm9wdHMucGFzdGVBbGxvd0xvY2FsSW1hZ2VzJiZjLm5vZGVUeXBlPT1Ob2RlLkVMRU1FTlRfTk9ERSYmXFxcIklNR1xcXCI9PWMudGFnTmFtZSYmYy5nZXRBdHRyaWJ1dGUoXFxcImRhdGEtZnItc3JjXFxcIikmJjA9PT1jLmdldEF0dHJpYnV0ZShcXFwiZGF0YS1mci1zcmNcXFwiKS5pbmRleE9mKFxcXCJmaWxlOi8vXFxcIikpcmV0dXJuIGMucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChjKSwhMTtpZihjLm5vZGVUeXBlPT1Ob2RlLkVMRU1FTlRfTk9ERSYmYS5GRS5IVE1MNU1hcFtjLnRhZ05hbWVdJiZcXFwiXFxcIj09PWIubm9kZS5hdHRyaWJ1dGVzKGMpKXt2YXIgZD1hLkZFLkhUTUw1TWFwW2MudGFnTmFtZV0sZT1cXFwiPFxcXCIrZCtcXFwiPlxcXCIrYy5pbm5lckhUTUwrXFxcIjwvXFxcIitkK1xcXCI+XFxcIjtjLmluc2VydEFkamFjZW50SFRNTChcXFwiYmVmb3JlYmVnaW5cXFwiLGUpLGM9Yy5wcmV2aW91c1NpYmxpbmcsYy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGMubmV4dFNpYmxpbmcpfWlmKGIub3B0cy5odG1sQWxsb3dDb21tZW50c3x8Yy5ub2RlVHlwZSE9Tm9kZS5DT01NRU5UX05PREUpaWYoYy50YWdOYW1lJiZjLnRhZ05hbWUubWF0Y2goSCkpYy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGMpO2Vsc2UgaWYoYy50YWdOYW1lJiYhYy50YWdOYW1lLm1hdGNoKEcpKVxcXCJzdmdcXFwiPT09Yy50YWdOYW1lP2MucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChjKTpiLmJyb3dzZXIuc2FmYXJpJiZcXFwicGF0aFxcXCI9PWMudGFnTmFtZSYmYy5wYXJlbnROb2RlJiZcXFwic3ZnXFxcIj09Yy5wYXJlbnROb2RlLnRhZ05hbWV8fChjLm91dGVySFRNTD1jLmlubmVySFRNTCk7ZWxzZXt2YXIgZj1jLmF0dHJpYnV0ZXM7aWYoZilmb3IodmFyIGg9Zi5sZW5ndGgtMTtoPj0wO2gtLSl7dmFyIGk9ZltoXSxqPWkubm9kZU5hbWUubWF0Y2goSSksaz1udWxsO1xcXCJzdHlsZVxcXCI9PWkubm9kZU5hbWUmJmIub3B0cy5odG1sQWxsb3dlZFN0eWxlUHJvcHMubGVuZ3RoJiYoaz1pLm5vZGVWYWx1ZS5tYXRjaChKKSksaiYmaz9pLm5vZGVWYWx1ZT1nKGsuam9pbihcXFwiO1xcXCIpKTpqJiYoXFxcInN0eWxlXFxcIiE9aS5ub2RlTmFtZXx8ayl8fGMucmVtb3ZlQXR0cmlidXRlKGkubm9kZU5hbWUpfX1lbHNlIDAhPT1jLmRhdGEuaW5kZXhPZihcXFwiW0ZST0FMQS5FRElUT1JcXFwiKSYmYy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGMpfWZ1bmN0aW9uIG8oYSl7Zm9yKHZhciBjPWIubm9kZS5jb250ZW50cyhhKSxkPTA7ZDxjLmxlbmd0aDtkKyspY1tkXS5ub2RlVHlwZSE9Tm9kZS5URVhUX05PREUmJm8oY1tkXSk7bihhKX1mdW5jdGlvbiBwKGEpe3ZhciBiPWEuaW5uZXJIVE1MO2IuaW5kZXhPZihcXFwiXFxcXG5cXFwiKT49MCYmKGEuaW5uZXJIVE1MPWIucmVwbGFjZSgvXFxcXG4vZyxcXFwiPGJyPlxcXCIpKX1mdW5jdGlvbiBxKGMsZCxlLGYpe1xcXCJ1bmRlZmluZWRcXFwiPT10eXBlb2YgZCYmKGQ9W10pLFxcXCJ1bmRlZmluZWRcXFwiPT10eXBlb2YgZSYmKGU9W10pLFxcXCJ1bmRlZmluZWRcXFwiPT10eXBlb2YgZiYmKGY9ITEpLGM9Yy5yZXBsYWNlKC88YnI+ICovZyxcXFwiPGJyPlxcXCIpO3ZhciBnLGg9YS5tZXJnZShbXSxiLm9wdHMuaHRtbEFsbG93ZWRUYWdzKTtmb3IoZz0wO2c8ZC5sZW5ndGg7ZysrKWguaW5kZXhPZihkW2ddKT49MCYmaC5zcGxpY2UoaC5pbmRleE9mKGRbZ10pLDEpO3ZhciBpPWEubWVyZ2UoW10sYi5vcHRzLmh0bWxBbGxvd2VkQXR0cnMpO2ZvcihnPTA7ZzxlLmxlbmd0aDtnKyspaS5pbmRleE9mKGVbZ10pPj0wJiZpLnNwbGljZShpLmluZGV4T2YoZVtnXSksMSk7cmV0dXJuIGkucHVzaChcXFwiZGF0YS1mci0uKlxcXCIpLGkucHVzaChcXFwiZnItLipcXFwiKSxHPW5ldyBSZWdFeHAoXFxcIl5cXFwiK2guam9pbihcXFwiJHxeXFxcIikrXFxcIiRcXFwiLFxcXCJnaVxcXCIpLEk9bmV3IFJlZ0V4cChcXFwiXlxcXCIraS5qb2luKFxcXCIkfF5cXFwiKStcXFwiJFxcXCIsXFxcImdpXFxcIiksSD1uZXcgUmVnRXhwKFxcXCJeXFxcIitiLm9wdHMuaHRtbFJlbW92ZVRhZ3Muam9pbihcXFwiJHxeXFxcIikrXFxcIiRcXFwiLFxcXCJnaVxcXCIpLEo9Yi5vcHRzLmh0bWxBbGxvd2VkU3R5bGVQcm9wcy5sZW5ndGg/bmV3IFJlZ0V4cChcXFwiKChefDt8XFxcXFxcXFxzKVxcXCIrYi5vcHRzLmh0bWxBbGxvd2VkU3R5bGVQcm9wcy5qb2luKFxcXCI6Lis/KD89O3wkKSl8KChefDt8XFxcXFxcXFxzKVxcXCIpK1xcXCI6Lis/KD89KDt8Jyl8JCkpXFxcIixcXFwiZ2lcXFwiKTpudWxsLGM9ayhjLG8sITApfWZ1bmN0aW9uIHIoKXtmb3IodmFyIGM9Yi5lbC5xdWVyeVNlbGVjdG9yQWxsKFxcXCJibG9ja3F1b3RlICsgYmxvY2txdW90ZVxcXCIpLGQ9MDtkPGMubGVuZ3RoO2QrKyl7dmFyIGU9Y1tkXTtiLm5vZGUuYXR0cmlidXRlcyhlKT09Yi5ub2RlLmF0dHJpYnV0ZXMoZS5wcmV2aW91c1NpYmxpbmcpJiYoYShlKS5wcmV2KCkuYXBwZW5kKGEoZSkuaHRtbCgpKSxhKGUpLnJlbW92ZSgpKX19ZnVuY3Rpb24gcygpe2Zvcih2YXIgYT1iLmVsLnF1ZXJ5U2VsZWN0b3JBbGwoXFxcInRyXFxcIiksYz0wO2M8YS5sZW5ndGg7YysrKXtmb3IodmFyIGQ9YVtjXS5jaGlsZHJlbixlPSEwLGY9MDtmPGQubGVuZ3RoO2YrKylpZihcXFwiVEhcXFwiIT1kW2ZdLnRhZ05hbWUpe2U9ITE7YnJlYWt9aWYoZSE9PSExJiYwIT09ZC5sZW5ndGgpe2Zvcih2YXIgZz1hW2NdO2cmJlxcXCJUQUJMRVxcXCIhPWcudGFnTmFtZSYmXFxcIlRIRUFEXFxcIiE9Zy50YWdOYW1lOylnPWcucGFyZW50Tm9kZTt2YXIgaD1nO1xcXCJUSEVBRFxcXCIhPWgudGFnTmFtZSYmKGg9Yi5kb2MuY3JlYXRlRWxlbWVudChcXFwiVEhFQURcXFwiKSxnLmluc2VydEJlZm9yZShoLGcuZmlyc3RDaGlsZCkpLGguYXBwZW5kQ2hpbGQoYVtjXSl9fX1mdW5jdGlvbiB0KCl7dmFyIGM9Yi5odG1sLmRlZmF1bHRUYWcoKTtpZihjKWZvcih2YXIgZD1iLmVsLnF1ZXJ5U2VsZWN0b3JBbGwoXFxcInRkID4gXFxcIitjK1xcXCIsIHRoID4gXFxcIitjKSxlPTA7ZTxkLmxlbmd0aDtlKyspXFxcIlxcXCI9PT1iLm5vZGUuYXR0cmlidXRlcyhkW2VdKSYmYShkW2VdKS5yZXBsYWNlV2l0aChkW2VdLmlubmVySFRNTCtcXFwiPGJyPlxcXCIpfWZ1bmN0aW9uIHUoKXtzKCksdCgpfWZ1bmN0aW9uIHYoKXt2YXIgYT1bXSxjPWZ1bmN0aW9uKGEpe3JldHVybiFiLm5vZGUuaXNMaXN0KGEucGFyZW50Tm9kZSl9O2Rve2lmKGEubGVuZ3RoKXt2YXIgZD1hWzBdLGU9Yi5kb2MuY3JlYXRlRWxlbWVudChcXFwidWxcXFwiKTtkLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGUsZCk7ZG97dmFyIGY9ZDtkPWQubmV4dFNpYmxpbmcsZS5hcHBlbmRDaGlsZChmKX13aGlsZShkJiZcXFwiTElcXFwiPT1kLnRhZ05hbWUpfWE9W107Zm9yKHZhciBnPWIuZWwucXVlcnlTZWxlY3RvckFsbChcXFwibGlcXFwiKSxoPTA7aDxnLmxlbmd0aDtoKyspYyhnW2hdKSYmYS5wdXNoKGdbaF0pfXdoaWxlKGEubGVuZ3RoPjApfWZ1bmN0aW9uIHcoKXtmb3IodmFyIGE9Yi5lbC5xdWVyeVNlbGVjdG9yQWxsKFxcXCJvbCArIG9sLCB1bCArIHVsXFxcIiksYz0wO2M8YS5sZW5ndGg7YysrKXt2YXIgZD1hW2NdO2lmKGIubm9kZS5pc0xpc3QoZC5wcmV2aW91c1NpYmxpbmcpJiZiLm5vZGUub3BlblRhZ1N0cmluZyhkKT09Yi5ub2RlLm9wZW5UYWdTdHJpbmcoZC5wcmV2aW91c1NpYmxpbmcpKXtmb3IodmFyIGU9Yi5ub2RlLmNvbnRlbnRzKGQpLGY9MDtmPGUubGVuZ3RoO2YrKylkLnByZXZpb3VzU2libGluZy5hcHBlbmRDaGlsZChlW2ZdKTtkLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZCl9fX1mdW5jdGlvbiB4KCl7dmFyIGEsYyxkPWZ1bmN0aW9uKGEpe2EucXVlcnlTZWxlY3RvcihcXFwiTElcXFwiKXx8KGM9ITAsYS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGEpKX07ZG97Yz0hMTt2YXIgZT1iLmVsLnF1ZXJ5U2VsZWN0b3JBbGwoXFxcImxpOmVtcHR5XFxcIik7Zm9yKGE9MDthPGUubGVuZ3RoO2ErKyllW2FdLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZVthXSk7dmFyIGY9Yi5lbC5xdWVyeVNlbGVjdG9yQWxsKFxcXCJ1bCwgb2xcXFwiKTtmb3IoYT0wO2E8Zi5sZW5ndGg7YSsrKWQoZlthXSl9d2hpbGUoYz09PSEwKX1mdW5jdGlvbiB5KCl7Zm9yKHZhciBjPWIuZWwucXVlcnlTZWxlY3RvckFsbChcXFwidWwgPiB1bCwgb2wgPiBvbCwgdWwgPiBvbCwgb2wgPiB1bFxcXCIpLGQ9MDtkPGMubGVuZ3RoO2QrKyl7dmFyIGU9Y1tkXSxmPWUucHJldmlvdXNTaWJsaW5nO2YmJihcXFwiTElcXFwiPT1mLnRhZ05hbWU/Zi5hcHBlbmRDaGlsZChlKTphKGUpLndyYXAoXFxcIjxsaT48L2xpPlxcXCIpKX19ZnVuY3Rpb24geigpe2Zvcih2YXIgYz1iLmVsLnF1ZXJ5U2VsZWN0b3JBbGwoXFxcImxpID4gdWwsIGxpID4gb2xcXFwiKSxkPTA7ZDxjLmxlbmd0aDtkKyspe3ZhciBlPWNbZF07aWYoZS5uZXh0U2libGluZyl7dmFyIGY9ZS5uZXh0U2libGluZyxnPWEoXFxcIjxsaT5cXFwiKTthKGUucGFyZW50Tm9kZSkuYWZ0ZXIoZyk7ZG97dmFyIGg9ZjtmPWYubmV4dFNpYmxpbmcsZy5hcHBlbmQoaCl9d2hpbGUoZil9fX1mdW5jdGlvbiBBKCl7Zm9yKHZhciBjPWIuZWwucXVlcnlTZWxlY3RvckFsbChcXFwibGkgPiB1bCwgbGkgPiBvbFxcXCIpLGQ9MDtkPGMubGVuZ3RoO2QrKyl7dmFyIGU9Y1tkXTtpZihiLm5vZGUuaXNGaXJzdFNpYmxpbmcoZSkpYShlKS5iZWZvcmUoXFxcIjxici8+XFxcIik7ZWxzZSBpZihlLnByZXZpb3VzU2libGluZyYmXFxcIkJSXFxcIj09ZS5wcmV2aW91c1NpYmxpbmcudGFnTmFtZSl7Zm9yKHZhciBmPWUucHJldmlvdXNTaWJsaW5nLnByZXZpb3VzU2libGluZztmJiZiLm5vZGUuaGFzQ2xhc3MoZixcXFwiZnItbWFya2VyXFxcIik7KWY9Zi5wcmV2aW91c1NpYmxpbmc7ZiYmXFxcIkJSXFxcIiE9Zi50YWdOYW1lJiZhKGUucHJldmlvdXNTaWJsaW5nKS5yZW1vdmUoKX19fWZ1bmN0aW9uIEIoKXtmb3IodmFyIGM9Yi5lbC5xdWVyeVNlbGVjdG9yQWxsKFxcXCJsaTplbXB0eVxcXCIpLGQ9MDtkPGMubGVuZ3RoO2QrKylhKGNbZF0pLnJlbW92ZSgpfWZ1bmN0aW9uIEMoKXtmb3IodmFyIGM9Yi5lbC5xdWVyeVNlbGVjdG9yQWxsKFxcXCJ1bCwgb2xcXFwiKSxkPTA7ZDxjLmxlbmd0aDtkKyspZm9yKHZhciBlPWIubm9kZS5jb250ZW50cyhjW2RdKSxmPW51bGwsZz1lLmxlbmd0aC0xO2c+PTA7Zy0tKVxcXCJMSVxcXCIhPWVbZ10udGFnTmFtZT8oZnx8KGY9YShcXFwiPGxpPlxcXCIpLGYuaW5zZXJ0QmVmb3JlKGVbZ10pKSxmLnByZXBlbmQoZVtnXSkpOmY9bnVsbH1mdW5jdGlvbiBEKCl7aWYoYi5odG1sLmRlZmF1bHRUYWcoKSlmb3IodmFyIGM9Yi5lbC5xdWVyeVNlbGVjdG9yQWxsKFxcXCJsaSA+IFxcXCIrYi5odG1sLmRlZmF1bHRUYWcoKSksZD1jLmxlbmd0aC0xO2Q+PTA7ZC0tKXt2YXIgZT1jW2RdO2UucHJldmlvdXNTaWJsaW5nJiYhYi5ub2RlLmlzRW1wdHkoZSkmJmEoXFxcIjxicj5cXFwiKS5pbnNlcnRBZnRlcihlLnByZXZpb3VzU2libGluZyksZS5vdXRlckhUTUw9ZS5pbm5lckhUTUx9fWZ1bmN0aW9uIEUoKXt2KCksdygpLHgoKSx5KCkseigpLEEoKSxDKCksQigpLEQoKX1mdW5jdGlvbiBGKCl7Yi5vcHRzLmZ1bGxQYWdlJiZhLm1lcmdlKGIub3B0cy5odG1sQWxsb3dlZFRhZ3MsW1xcXCJoZWFkXFxcIixcXFwidGl0bGVcXFwiLFxcXCJzdHlsZVxcXCIsXFxcImxpbmtcXFwiLFxcXCJiYXNlXFxcIixcXFwiYm9keVxcXCIsXFxcImh0bWxcXFwiLFxcXCJtZXRhXFxcIl0pfXZhciBHLEgsSSxKLEs9W107cmV0dXJue19pbml0OkYsaHRtbDpxLHRvSFRNTDU6bSx0YWJsZXM6dSxsaXN0czpFLHF1b3RlczpyLGludmlzaWJsZVNwYWNlczpsLGV4ZWM6a319LGEuRkUuTU9EVUxFUy5zcGFjZXM9ZnVuY3Rpb24oYil7ZnVuY3Rpb24gYyhjLGQpe3ZhciBlPWMucHJldmlvdXNTaWJsaW5nLGY9Yy5uZXh0U2libGluZyxnPWMudGV4dENvbnRlbnQsaD1jLnBhcmVudE5vZGU7aWYoXFxcIlBSRVxcXCIhPWgudGFnTmFtZSl7ZCYmKGc9Zy5yZXBsYWNlKC9bXFxcXGZcXFxcblxcXFxyXFxcXHRcXFxcdiBdezIsfS9nLFxcXCIgXFxcIiksZiYmXFxcIkJSXFxcIiE9PWYudGFnTmFtZSYmIWIubm9kZS5pc0Jsb2NrKGYpfHwhYi5ub2RlLmlzQmxvY2soaCl8fChnPWcucmVwbGFjZSgvW1xcXFxmXFxcXG5cXFxcclxcXFx0XFxcXHYgXXsxLH0kL2csXFxcIlxcXCIpKSxlJiZcXFwiQlJcXFwiIT09ZS50YWdOYW1lJiYhYi5ub2RlLmlzQmxvY2soZSl8fCFiLm5vZGUuaXNCbG9jayhoKXx8KGc9Zy5yZXBsYWNlKC9eW1xcXFxmXFxcXG5cXFxcclxcXFx0XFxcXHYgXXsxLH0vZyxcXFwiXFxcIikpLFxcXCIgXFxcIj09PWcmJihlJiZlLm5vZGVUeXBlIT1Ob2RlLlRFWFRfTk9ERXx8ZiYmZi5ub2RlVHlwZSE9Tm9kZS5URVhUX05PREUpJiYoZz1cXFwiXFxcIikpLGc9Zy5yZXBsYWNlKG5ldyBSZWdFeHAoYS5GRS5VTklDT0RFX05CU1AsXFxcImdcXFwiKSxcXFwiIFxcXCIpO2Zvcih2YXIgaT1cXFwiXFxcIixqPTA7ajxnLmxlbmd0aDtqKyspaSs9MzIhPWcuY2hhckNvZGVBdChqKXx8MCE9PWomJjMyIT1pLmNoYXJDb2RlQXQoai0xKT9nW2pdOmEuRkUuVU5JQ09ERV9OQlNQOyghZnx8Yi5ub2RlLmlzQmxvY2soZil8fGYubm9kZVR5cGU9PU5vZGUuRUxFTUVOVF9OT0RFJiZiLndpbi5nZXRDb21wdXRlZFN0eWxlKGYpJiZcXFwiYmxvY2tcXFwiPT1iLndpbi5nZXRDb21wdXRlZFN0eWxlKGYpLmRpc3BsYXkpJiYoaT1pLnJlcGxhY2UoLyAkLyxhLkZFLlVOSUNPREVfTkJTUCkpLCFlfHxiLm5vZGUuaXNWb2lkKGUpfHxiLm5vZGUuaXNCbG9jayhlKXx8KGk9aS5yZXBsYWNlKC9eXFxcXHUwMEEwKFteICRdKS8sXFxcIiAkMVxcXCIpLDEhPT1pLmxlbmd0aHx8MTYwIT09aS5jaGFyQ29kZUF0KDApfHwhZnx8Yi5ub2RlLmlzVm9pZChmKXx8Yi5ub2RlLmlzQmxvY2soZil8fChpPVxcXCIgXFxcIikpLGk9aS5yZXBsYWNlKC8oW14gXFxcXHUwMEEwXSlcXFxcdTAwQTAoW14gXFxcXHUwMEEwXSkvZyxcXFwiJDEgJDJcXFwiKSxjLnRleHRDb250ZW50IT1pJiYoYy50ZXh0Q29udGVudD1pKX19ZnVuY3Rpb24gZChhLGQpe2lmKFxcXCJ1bmRlZmluZWRcXFwiIT10eXBlb2YgYSYmYXx8KGE9Yi5lbCksXFxcInVuZGVmaW5lZFxcXCI9PXR5cGVvZiBkJiYoZD0hMSksYi5vcHRzLmh0bWxVbnRvdWNoZWQpcmV0dXJuITE7aWYoIWEuZ2V0QXR0cmlidXRlfHxcXFwiZmFsc2VcXFwiIT1hLmdldEF0dHJpYnV0ZShcXFwiY29udGVudGVkaXRhYmxlXFxcIikpaWYoYS5ub2RlVHlwZT09Tm9kZS5URVhUX05PREUpYyhhLGQpO2Vsc2UgaWYoYS5ub2RlVHlwZT09Tm9kZS5FTEVNRU5UX05PREUpZm9yKHZhciBlPWIuZG9jLmNyZWF0ZVRyZWVXYWxrZXIoYSxOb2RlRmlsdGVyLlNIT1dfVEVYVCxiLm5vZGUuZmlsdGVyKGZ1bmN0aW9uKGEpe2Zvcih2YXIgYz1hLnBhcmVudE5vZGU7YyYmYyE9PWIuZWw7KXtpZihcXFwiUFJFXFxcIj09PWMudGFnTmFtZSlyZXR1cm4hMTtjPWMucGFyZW50Tm9kZX1yZXR1cm4gbnVsbCE9YS50ZXh0Q29udGVudC5tYXRjaCgvKFsgXFxcXHUwMEEwXFxcXGZcXFxcblxcXFxyXFxcXHRcXFxcdl17Mix9KXwoXlsgXFxcXHUwMEEwXFxcXGZcXFxcblxcXFxyXFxcXHRcXFxcdl17MSx9KXwoWyBcXFxcdTAwQTBcXFxcZlxcXFxuXFxcXHJcXFxcdFxcXFx2XXsxLH0kKS9nKSYmIWIubm9kZS5oYXNDbGFzcyhhLnBhcmVudE5vZGUsXFxcImZyLW1hcmtlclxcXCIpfSksITEpO2UubmV4dE5vZGUoKTspYyhlLmN1cnJlbnROb2RlLGQpfWZ1bmN0aW9uIGUoKXtmb3IodmFyIGE9W10sYz1iLmVsLnF1ZXJ5U2VsZWN0b3JBbGwoXFxcIi5mci1tYXJrZXJcXFwiKSxlPTA7ZTxjLmxlbmd0aDtlKyspe3ZhciBmPW51bGwsZz1iLm5vZGUuYmxvY2tQYXJlbnQoY1tlXSk7Zj1nP2c6Y1tlXTtmb3IodmFyIGg9Zi5uZXh0U2libGluZyxpPWYucHJldmlvdXNTaWJsaW5nO2gmJlxcXCJCUlxcXCI9PWgudGFnTmFtZTspaD1oLm5leHRTaWJsaW5nO2Zvcig7aSYmXFxcIkJSXFxcIj09aS50YWdOYW1lOylpPWkucHJldmlvdXNTaWJsaW5nO2YmJmEuaW5kZXhPZihmKTwwJiZhLnB1c2goZiksaSYmYS5pbmRleE9mKGkpPDAmJmEucHVzaChpKSxoJiZhLmluZGV4T2YoaCk8MCYmYS5wdXNoKGgpfWZvcih2YXIgaj0wO2o8YS5sZW5ndGg7aisrKWQoYVtqXSl9cmV0dXJue25vcm1hbGl6ZTpkLG5vcm1hbGl6ZUFyb3VuZEN1cnNvcjplfX0sYS5GRS5VTklDT0RFX05CU1A9U3RyaW5nLmZyb21DaGFyQ29kZSgxNjApLGEuRkUuVk9JRF9FTEVNRU5UUz1bXFxcImFyZWFcXFwiLFxcXCJiYXNlXFxcIixcXFwiYnJcXFwiLFxcXCJjb2xcXFwiLFxcXCJlbWJlZFxcXCIsXFxcImhyXFxcIixcXFwiaW1nXFxcIixcXFwiaW5wdXRcXFwiLFxcXCJrZXlnZW5cXFwiLFxcXCJsaW5rXFxcIixcXFwibWVudWl0ZW1cXFwiLFxcXCJtZXRhXFxcIixcXFwicGFyYW1cXFwiLFxcXCJzb3VyY2VcXFwiLFxcXCJ0cmFja1xcXCIsXFxcIndiclxcXCJdLGEuRkUuQkxPQ0tfVEFHUz1bXFxcImFkZHJlc3NcXFwiLFxcXCJhcnRpY2xlXFxcIixcXFwiYXNpZGVcXFwiLFxcXCJhdWRpb1xcXCIsXFxcImJsb2NrcXVvdGVcXFwiLFxcXCJjYW52YXNcXFwiLFxcXCJkZFxcXCIsXFxcImRpdlxcXCIsXFxcImRsXFxcIixcXFwiZHRcXFwiLFxcXCJmaWVsZHNldFxcXCIsXFxcImZpZ2NhcHRpb25cXFwiLFxcXCJmaWd1cmVcXFwiLFxcXCJmb290ZXJcXFwiLFxcXCJmb3JtXFxcIixcXFwiaDFcXFwiLFxcXCJoMlxcXCIsXFxcImgzXFxcIixcXFwiaDRcXFwiLFxcXCJoNVxcXCIsXFxcImg2XFxcIixcXFwiaGVhZGVyXFxcIixcXFwiaGdyb3VwXFxcIixcXFwiaHJcXFwiLFxcXCJsaVxcXCIsXFxcIm1haW5cXFwiLFxcXCJuYXZcXFwiLFxcXCJub3NjcmlwdFxcXCIsXFxcIm9sXFxcIixcXFwib3V0cHV0XFxcIixcXFwicFxcXCIsXFxcInByZVxcXCIsXFxcInNlY3Rpb25cXFwiLFxcXCJ0YWJsZVxcXCIsXFxcInRib2R5XFxcIixcXFwidGRcXFwiLFxcXCJ0Zm9vdFxcXCIsXFxcInRoXFxcIixcXFwidGhlYWRcXFwiLFxcXCJ0clxcXCIsXFxcInVsXFxcIixcXFwidmlkZW9cXFwiXSxhLmV4dGVuZChhLkZFLkRFRkFVTFRTLHtodG1sQWxsb3dlZEVtcHR5VGFnczpbXFxcInRleHRhcmVhXFxcIixcXFwiYVxcXCIsXFxcImlmcmFtZVxcXCIsXFxcIm9iamVjdFxcXCIsXFxcInZpZGVvXFxcIixcXFwic3R5bGVcXFwiLFxcXCJzY3JpcHRcXFwiLFxcXCIuZmFcXFwiLFxcXCIuZnItZW1vdGljb25cXFwiXSxodG1sRG9Ob3RXcmFwVGFnczpbXFxcInNjcmlwdFxcXCIsXFxcInN0eWxlXFxcIl0saHRtbFNpbXBsZUFtcGVyc2FuZDohMSxodG1sSWdub3JlQ1NTUHJvcGVydGllczpbXX0pLGEuRkUuTU9EVUxFUy5odG1sPWZ1bmN0aW9uKGIpe2Z1bmN0aW9uIGMoKXtyZXR1cm4gYi5vcHRzLmVudGVyPT1hLkZFLkVOVEVSX1A/XFxcInBcXFwiOmIub3B0cy5lbnRlcj09YS5GRS5FTlRFUl9ESVY/XFxcImRpdlxcXCI6Yi5vcHRzLmVudGVyPT1hLkZFLkVOVEVSX0JSP251bGw6dm9pZCAwfWZ1bmN0aW9uIGQoYyl7dmFyIGQsZT1bXSxnPVtdO2lmKGMpe3ZhciBoPWIuZWwucXVlcnlTZWxlY3RvckFsbChcXFwiLmZyLW1hcmtlclxcXCIpO2ZvcihkPTA7ZDxoLmxlbmd0aDtkKyspe3ZhciBpPWIubm9kZS5ibG9ja1BhcmVudChoW2RdKXx8aFtkXTtpZihpKXt2YXIgaj1pLm5leHRTaWJsaW5nLGs9aS5wcmV2aW91c1NpYmxpbmc7aSYmZy5pbmRleE9mKGkpPDAmJmIubm9kZS5pc0Jsb2NrKGkpJiZnLnB1c2goaSksayYmYi5ub2RlLmlzQmxvY2soaykmJmcuaW5kZXhPZihrKTwwJiZnLnB1c2goayksaiYmYi5ub2RlLmlzQmxvY2soaikmJmcuaW5kZXhPZihqKTwwJiZnLnB1c2goail9fX1lbHNlIGc9Yi5lbC5xdWVyeVNlbGVjdG9yQWxsKGYoKSk7dmFyIGw9ZigpO2ZvcihsKz1cXFwiLFxcXCIrYS5GRS5WT0lEX0VMRU1FTlRTLmpvaW4oXFxcIixcXFwiKSxsKz1cXFwiLFxcXCIrYi5vcHRzLmh0bWxBbGxvd2VkRW1wdHlUYWdzLmpvaW4oXFxcIjpub3QoLmZyLW1hcmtlciksXFxcIikrXFxcIjpub3QoLmZyLW1hcmtlcilcXFwiLGQ9Zy5sZW5ndGgtMTtkPj0wO2QtLSlpZighKGdbZF0udGV4dENvbnRlbnQmJmdbZF0udGV4dENvbnRlbnQucmVwbGFjZSgvXFxcXHUyMDBCfFxcXFxuL2csXFxcIlxcXCIpLmxlbmd0aD4wfHxnW2RdLnF1ZXJ5U2VsZWN0b3JBbGwobCkubGVuZ3RoPjApKXtmb3IodmFyIG09Yi5ub2RlLmNvbnRlbnRzKGdbZF0pLG49ITEsbz0wO288bS5sZW5ndGg7bysrKWlmKG1bb10ubm9kZVR5cGUhPU5vZGUuQ09NTUVOVF9OT0RFJiZtW29dLnRleHRDb250ZW50JiZtW29dLnRleHRDb250ZW50LnJlcGxhY2UoL1xcXFx1MjAwQnxcXFxcbi9nLFxcXCJcXFwiKS5sZW5ndGg+MCl7bj0hMDticmVha31ufHxlLnB1c2goZ1tkXSl9cmV0dXJuIGV9ZnVuY3Rpb24gZSgpe3JldHVybiBhLkZFLkJMT0NLX1RBR1Muam9pbihcXFwiOmVtcHR5LCBcXFwiKStcXFwiOmVtcHR5XFxcIn1mdW5jdGlvbiBmKCl7cmV0dXJuIGEuRkUuQkxPQ0tfVEFHUy5qb2luKFxcXCIsIFxcXCIpfWZ1bmN0aW9uIGcoYyl7dmFyIGQ9YS5tZXJnZShbXSxhLkZFLlZPSURfRUxFTUVOVFMpO2Q9YS5tZXJnZShkLGIub3B0cy5odG1sQWxsb3dlZEVtcHR5VGFncyksXFxcInVuZGVmaW5lZFxcXCI9PXR5cGVvZiBjJiYoZD1hLm1lcmdlKGQsYS5GRS5CTE9DS19UQUdTKSk7dmFyIGUsZjtlPWIuZWwucXVlcnlTZWxlY3RvckFsbChcXFwiKjplbXB0eTpub3QoXFxcIitkLmpvaW4oXFxcIik6bm90KFxcXCIpK1xcXCIpOm5vdCguZnItbWFya2VyKVxcXCIpO2Rve2Y9ITE7Zm9yKHZhciBnPTA7ZzxlLmxlbmd0aDtnKyspMCE9PWVbZ10uYXR0cmlidXRlcy5sZW5ndGgmJlxcXCJ1bmRlZmluZWRcXFwiPT10eXBlb2YgZVtnXS5nZXRBdHRyaWJ1dGUoXFxcImhyZWZcXFwiKXx8KGVbZ10ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlW2ddKSxmPSEwKTtlPWIuZWwucXVlcnlTZWxlY3RvckFsbChcXFwiKjplbXB0eTpub3QoXFxcIitkLmpvaW4oXFxcIik6bm90KFxcXCIpK1xcXCIpOm5vdCguZnItbWFya2VyKVxcXCIpfXdoaWxlKGUubGVuZ3RoJiZmKX1mdW5jdGlvbiBoKGEsZCl7dmFyIGU9YygpO2lmKGQmJihlPVxcXCJkaXZcXFwiKSxlKXtmb3IodmFyIGY9Yi5kb2MuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpLGc9bnVsbCxoPSExLGk9YS5maXJzdENoaWxkO2k7KXt2YXIgaj1pLm5leHRTaWJsaW5nO2lmKGkubm9kZVR5cGU9PU5vZGUuRUxFTUVOVF9OT0RFJiYoYi5ub2RlLmlzQmxvY2soaSl8fGIub3B0cy5odG1sRG9Ob3RXcmFwVGFncy5pbmRleE9mKGkudGFnTmFtZS50b0xvd2VyQ2FzZSgpKT49MCYmIWIubm9kZS5oYXNDbGFzcyhpLFxcXCJmci1tYXJrZXJcXFwiKSkpZz1udWxsLGYuYXBwZW5kQ2hpbGQoaSk7ZWxzZSBpZihpLm5vZGVUeXBlIT1Ob2RlLkVMRU1FTlRfTk9ERSYmaS5ub2RlVHlwZSE9Tm9kZS5URVhUX05PREUpZz1udWxsLGYuYXBwZW5kQ2hpbGQoaSk7ZWxzZSBpZihcXFwiQlJcXFwiPT1pLnRhZ05hbWUpbnVsbD09Zz8oZz1iLmRvYy5jcmVhdGVFbGVtZW50KGUpLGQmJmcuc2V0QXR0cmlidXRlKFxcXCJkYXRhLWVtcHR5XFxcIiwhMCksZy5hcHBlbmRDaGlsZChpKSxmLmFwcGVuZENoaWxkKGcpKTpoPT09ITEmJihnLmFwcGVuZENoaWxkKGIuZG9jLmNyZWF0ZUVsZW1lbnQoXFxcImJyXFxcIikpLGcuc2V0QXR0cmlidXRlKFxcXCJkYXRhLWVtcHR5XFxcIiwhMCkpLGc9bnVsbDtlbHNle3ZhciBrPWkudGV4dENvbnRlbnQ7aS5ub2RlVHlwZT09Tm9kZS5URVhUX05PREUmJjA9PT1rLnJlcGxhY2UoL1xcXFxuL2csXFxcIlxcXCIpLnJlcGxhY2UoLyheICopfCggKiQpL2csXFxcIlxcXCIpLmxlbmd0aHx8KG51bGw9PWcmJihnPWIuZG9jLmNyZWF0ZUVsZW1lbnQoZSksZCYmZy5zZXRBdHRyaWJ1dGUoXFxcImNsYXNzXFxcIixcXFwiZnItdGVtcC1kaXZcXFwiKSxmLmFwcGVuZENoaWxkKGcpLGg9ITEpLGcuYXBwZW5kQ2hpbGQoaSksaHx8Yi5ub2RlLmhhc0NsYXNzKGksXFxcImZyLW1hcmtlclxcXCIpfHxpLm5vZGVUeXBlPT1Ob2RlLlRFWFRfTk9ERSYmMD09PWsucmVwbGFjZSgvIC9nLFxcXCJcXFwiKS5sZW5ndGh8fChoPSEwKSl9aT1qfWEuaW5uZXJIVE1MPVxcXCJcXFwiLGEuYXBwZW5kQ2hpbGQoZil9fWZ1bmN0aW9uIGkoYSxiKXtmb3IodmFyIGM9MDtjPGEubGVuZ3RoO2MrKyloKGFbY10sYil9ZnVuY3Rpb24gaihhLGMsZCxlKXtyZXR1cm4hIWIuJHdwJiYoXFxcInVuZGVmaW5lZFxcXCI9PXR5cGVvZiBhJiYoYT0hMSksXFxcInVuZGVmaW5lZFxcXCI9PXR5cGVvZiBjJiYoYz0hMSksXFxcInVuZGVmaW5lZFxcXCI9PXR5cGVvZiBkJiYoZD0hMSksXFxcInVuZGVmaW5lZFxcXCI9PXR5cGVvZiBlJiYoZT0hMSksaChiLmVsLGEpLGUmJmkoYi5lbC5xdWVyeVNlbGVjdG9yQWxsKFxcXCIuZnItaW5uZXJcXFwiKSxhKSxjJiZpKGIuZWwucXVlcnlTZWxlY3RvckFsbChcXFwidGQsIHRoXFxcIiksYSksdm9pZChkJiZpKGIuZWwucXVlcnlTZWxlY3RvckFsbChcXFwiYmxvY2txdW90ZVxcXCIpLGEpKSl9ZnVuY3Rpb24gaygpe2IuJGVsLmZpbmQoXFxcImRpdi5mci10ZW1wLWRpdlxcXCIpLmVhY2goZnVuY3Rpb24oKXthKHRoaXMpLmRhdGEoXFxcImVtcHR5XFxcIil8fFxcXCJMSVxcXCI9PXRoaXMucGFyZW50Tm9kZS50YWdOYW1lfHxiLm5vZGUuaXNCbG9jayh0aGlzLm5leHRTaWJsaW5nKSYmIWEodGhpcy5uZXh0U2libGluZykuaGFzQ2xhc3MoXFxcImZyLXRlbXAtZGl2XFxcIik/YSh0aGlzKS5yZXBsYWNlV2l0aChhKHRoaXMpLmh0bWwoKSk6YSh0aGlzKS5yZXBsYWNlV2l0aChhKHRoaXMpLmh0bWwoKStcXFwiPGJyPlxcXCIpfSksYi4kZWwuZmluZChcXFwiLmZyLXRlbXAtZGl2XFxcIikucmVtb3ZlQ2xhc3MoXFxcImZyLXRlbXAtZGl2XFxcIikuZmlsdGVyKGZ1bmN0aW9uKCl7cmV0dXJuXFxcIlxcXCI9PT1hKHRoaXMpLmF0dHIoXFxcImNsYXNzXFxcIil9KS5yZW1vdmVBdHRyKFxcXCJjbGFzc1xcXCIpfWZ1bmN0aW9uIGwoYyl7Zm9yKHZhciBlPWQoYyksZj0wO2Y8ZS5sZW5ndGg7ZisrKXt2YXIgZz1lW2ZdO1xcXCJmYWxzZVxcXCI9PT1nLmdldEF0dHJpYnV0ZShcXFwiY29udGVudGVkaXRhYmxlXFxcIil8fGcucXVlcnlTZWxlY3RvcihiLm9wdHMuaHRtbEFsbG93ZWRFbXB0eVRhZ3Muam9pbihcXFwiOm5vdCguZnItbWFya2VyKSxcXFwiKStcXFwiOm5vdCguZnItbWFya2VyKVxcXCIpfHxiLm5vZGUuaXNWb2lkKGcpfHxcXFwiVEFCTEVcXFwiIT1nLnRhZ05hbWUmJlxcXCJUQk9EWVxcXCIhPWcudGFnTmFtZSYmXFxcIlRSXFxcIiE9Zy50YWdOYW1lJiZnLmFwcGVuZENoaWxkKGIuZG9jLmNyZWF0ZUVsZW1lbnQoXFxcImJyXFxcIikpfWlmKGIuYnJvd3Nlci5tc2llJiZiLm9wdHMuZW50ZXI9PWEuRkUuRU5URVJfQlIpe3ZhciBoPWIubm9kZS5jb250ZW50cyhiLmVsKTtoLmxlbmd0aCYmaFtoLmxlbmd0aC0xXS5ub2RlVHlwZT09Tm9kZS5URVhUX05PREUmJmIuJGVsLmFwcGVuZChcXFwiPGJyPlxcXCIpfX1mdW5jdGlvbiBtKCl7cmV0dXJuIGIuJGVsLmdldCgwKS5xdWVyeVNlbGVjdG9yQWxsKGYoKSl9ZnVuY3Rpb24gbihhKXtpZihcXFwidW5kZWZpbmVkXFxcIj09dHlwZW9mIGEmJihhPWIuZWwpLGEmJltcXFwiU0NSSVBUXFxcIixcXFwiU1RZTEVcXFwiLFxcXCJQUkVcXFwiXS5pbmRleE9mKGEudGFnTmFtZSk+PTApcmV0dXJuITE7Zm9yKHZhciBjPWIuZG9jLmNyZWF0ZVRyZWVXYWxrZXIoYSxOb2RlRmlsdGVyLlNIT1dfVEVYVCxiLm5vZGUuZmlsdGVyKGZ1bmN0aW9uKGEpe3JldHVybiBudWxsIT1hLnRleHRDb250ZW50Lm1hdGNoKC8oWyBcXFxcbl17Mix9KXwoXlsgXFxcXG5dezEsfSl8KFsgXFxcXG5dezEsfSQpL2cpfSksITEpO2MubmV4dE5vZGUoKTspe3ZhciBkPWMuY3VycmVudE5vZGU7aWYoXFxcIlBSRVxcXCIhPWQucGFyZW50Tm9kZS50YWdOYW1lKXt2YXIgZT1iLm5vZGUuaXNCbG9jayhkLnBhcmVudE5vZGUpfHxiLm5vZGUuaXNFbGVtZW50KGQucGFyZW50Tm9kZSksZj1kLnRleHRDb250ZW50LnJlcGxhY2UoLyg/IV4pKCApezIsfSg/ISQpL2csXFxcIiBcXFwiKS5yZXBsYWNlKC9cXFxcbi9nLFxcXCIgXFxcIikucmVwbGFjZSgvXlsgXXsyLH0vZyxcXFwiIFxcXCIpLnJlcGxhY2UoL1sgXXsyLH0kL2csXFxcIiBcXFwiKTtpZihlKXt2YXIgZz1kLnByZXZpb3VzU2libGluZyxoPWQubmV4dFNpYmxpbmc7ZyYmaCYmXFxcIiBcXFwiPT1mP2Y9Yi5ub2RlLmlzQmxvY2soZykmJmIubm9kZS5pc0Jsb2NrKGgpP1xcXCJcXFwiOlxcXCJcXFxcblxcXCI6KGd8fChmPWYucmVwbGFjZSgvXiAqLyxcXFwiXFxcIikpLGh8fChmPWYucmVwbGFjZSgvICokLyxcXFwiXFxcIikpKX1kLnRleHRDb250ZW50PWZ9fX1mdW5jdGlvbiBvKGEsYixjKXt2YXIgZD1uZXcgUmVnRXhwKGIsXFxcImdpXFxcIiksZT1kLmV4ZWMoYSk7cmV0dXJuIGU/ZVtjXTpudWxsfWZ1bmN0aW9uIHAoYSxiKXt2YXIgYz1hLm1hdGNoKC88IURPQ1RZUEUgPyhbXiBdKikgPyhbXiBdKikgP1xcXCI/KFteXFxcIl0qKVxcXCI/ID9cXFwiPyhbXlxcXCJdKilcXFwiPz4vaSk7cmV0dXJuIGM/Yi5pbXBsZW1lbnRhdGlvbi5jcmVhdGVEb2N1bWVudFR5cGUoY1sxXSxjWzNdLGNbNF0pOmIuaW1wbGVtZW50YXRpb24uY3JlYXRlRG9jdW1lbnRUeXBlKFxcXCJodG1sXFxcIil9ZnVuY3Rpb24gcShhKXt2YXIgYj1hLmRvY3R5cGUsYz1cXFwiPCFET0NUWVBFIGh0bWw+XFxcIjtyZXR1cm4gYiYmKGM9XFxcIjwhRE9DVFlQRSBcXFwiK2IubmFtZSsoYi5wdWJsaWNJZD8nIFBVQkxJQyBcXFwiJytiLnB1YmxpY0lkKydcXFwiJzpcXFwiXFxcIikrKCFiLnB1YmxpY0lkJiZiLnN5c3RlbUlkP1xcXCIgU1lTVEVNXFxcIjpcXFwiXFxcIikrKGIuc3lzdGVtSWQ/JyBcXFwiJytiLnN5c3RlbUlkKydcXFwiJzpcXFwiXFxcIikrXFxcIj5cXFwiKSxjfWZ1bmN0aW9uIHIoYyxkKXt2YXIgZT1jLnBhcmVudE5vZGU7aWYoZSYmKGIubm9kZS5pc0Jsb2NrKGUpfHxiLm5vZGUuaXNFbGVtZW50KGUpKSYmW1xcXCJURFxcXCIsXFxcIlRIXFxcIl0uaW5kZXhPZihlLnRhZ05hbWUpPDApe2Zvcih2YXIgZj1jLnByZXZpb3VzU2libGluZyxnPWMubmV4dFNpYmxpbmc7ZiYmZi5ub2RlVHlwZT09Tm9kZS5URVhUX05PREUmJjA9PT1mLnRleHRDb250ZW50LnJlcGxhY2UoL1xcXFxufFxcXFxyL2csXFxcIlxcXCIpLmxlbmd0aDspZj1mLnByZXZpb3VzU2libGluZztmJiZlJiZcXFwiQlJcXFwiIT1mLnRhZ05hbWUmJiFiLm5vZGUuaXNCbG9jayhmKSYmIWcmJmUudGV4dENvbnRlbnQucmVwbGFjZSgvXFxcXHUyMDBCL2csXFxcIlxcXCIpLmxlbmd0aD4wJiZmLnRleHRDb250ZW50Lmxlbmd0aD4wJiYhYi5ub2RlLmhhc0NsYXNzKGYsXFxcImZyLW1hcmtlclxcXCIpJiYoYi5lbD09ZSYmIWcmJmIub3B0cy5lbnRlcj09YS5GRS5FTlRFUl9CUiYmYi5icm93c2VyLm1zaWV8fChkJiZiLnNlbGVjdGlvbi5zYXZlKCksYy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGMpLGQmJmIuc2VsZWN0aW9uLnJlc3RvcmUoKSkpfX1mdW5jdGlvbiBzKCl7dmFyIGEsYyxkPWIuc2VsZWN0aW9uLmVsZW1lbnQoKTthPWIubm9kZS5pc0Jsb2NrKGQpP2Q6Yi5ub2RlLmJsb2NrUGFyZW50KGQpO3ZhciBlPVtdO2lmKGEpe3ZhciBmPWEubmV4dFNpYmxpbmcsZz1hLnByZXZpb3VzU2libGluZzthJiZlLmluZGV4T2YoYSk8MCYmZS5wdXNoKGEpLGcmJmIubm9kZS5pc0Jsb2NrKGcpJiZlLmluZGV4T2YoZyk8MCYmZS5wdXNoKGcpLGYmJmIubm9kZS5pc0Jsb2NrKGYpJiZlLmluZGV4T2YoZik8MCYmZS5wdXNoKGYpfXZhciBoPVtdO2ZvcihjPTA7YzxlLmxlbmd0aDtjKyspZm9yKHZhciBpPWVbY10ucXVlcnlTZWxlY3RvckFsbChcXFwiYnJcXFwiKSxqPTA7ajxpLmxlbmd0aDtqKyspaC5pbmRleE9mKGlbal0pPDAmJmgucHVzaChpW2pdKTtpZihkLnBhcmVudE5vZGU9PWIuZWwpe3ZhciBrPWIuZWwuY2hpbGRyZW47Zm9yKGM9MDtjPGsubGVuZ3RoO2MrKylcXFwiQlJcXFwiPT1rW2NdLnRhZ05hbWUmJmguaW5kZXhPZihrW2NdKTwwJiZoLnB1c2goa1tjXSl9cmV0dXJuIGh9ZnVuY3Rpb24gdChhLGMpe3ZhciBkLGU9bnVsbDtpZihhKWZvcihlPXMoKSxkPTA7ZDxlLmxlbmd0aDtkKyspcihlW2RdLGMpO2Vsc2UgZm9yKGU9Yi5lbC5nZXRFbGVtZW50c0J5VGFnTmFtZShcXFwiYnJcXFwiKSxkPTA7ZDxlLmxlbmd0aDtkKyspcihlW2RdLGMpfWZ1bmN0aW9uIHUoKXtiLm9wdHMuaHRtbFVudG91Y2hlZHx8KGcoKSxqKCkpLG4oKSxiLm9wdHMuaHRtbFVudG91Y2hlZHx8KGIuc3BhY2VzLm5vcm1hbGl6ZShudWxsLCEwKSxiLmh0bWwuZmlsbEVtcHR5QmxvY2tzKCksYi5jbGVhbi5xdW90ZXMoKSxiLmNsZWFuLmxpc3RzKCksYi5jbGVhbi50YWJsZXMoKSxiLmNsZWFuLnRvSFRNTDUoKSxiLmh0bWwuY2xlYW5CUnMoKSksYi5zZWxlY3Rpb24ucmVzdG9yZSgpLHYoKSxiLnBsYWNlaG9sZGVyLnJlZnJlc2goKX1mdW5jdGlvbiB2KCl7Yi5jb3JlLmlzRW1wdHkoKSYmKG51bGwhPWMoKT9iLmVsLnF1ZXJ5U2VsZWN0b3IoZigpKXx8Yi5lbC5xdWVyeVNlbGVjdG9yKGIub3B0cy5odG1sRG9Ob3RXcmFwVGFncy5qb2luKFxcXCI6bm90KC5mci1tYXJrZXIpLFxcXCIpK1xcXCI6bm90KC5mci1tYXJrZXIpXFxcIil8fChiLmNvcmUuaGFzRm9jdXMoKT8oYi4kZWwuaHRtbChcXFwiPFxcXCIrYygpK1xcXCI+XFxcIithLkZFLk1BUktFUlMrXFxcIjxici8+PC9cXFwiK2MoKStcXFwiPlxcXCIpLGIuc2VsZWN0aW9uLnJlc3RvcmUoKSk6Yi4kZWwuaHRtbChcXFwiPFxcXCIrYygpK1xcXCI+PGJyLz48L1xcXCIrYygpK1xcXCI+XFxcIikpOmIuZWwucXVlcnlTZWxlY3RvcihcXFwiKjpub3QoLmZyLW1hcmtlcik6bm90KGJyKVxcXCIpfHwoYi5jb3JlLmhhc0ZvY3VzKCk/KGIuJGVsLmh0bWwoYS5GRS5NQVJLRVJTK1xcXCI8YnIvPlxcXCIpLGIuc2VsZWN0aW9uLnJlc3RvcmUoKSk6Yi4kZWwuaHRtbChcXFwiPGJyLz5cXFwiKSkpfWZ1bmN0aW9uIHcoYSxiKXtyZXR1cm4gbyhhLFxcXCI8XFxcIitiK1xcXCJbXj5dKj8+KFtcXFxcXFxcXHdcXFxcXFxcXFddKik8L1xcXCIrYitcXFwiPlxcXCIsMSl9ZnVuY3Rpb24geChjLGQpe3ZhciBlPWEoXFxcIjxkaXYgXFxcIisobyhjLFxcXCI8XFxcIitkK1xcXCIoW14+XSo/KT5cXFwiLDEpfHxcXFwiXFxcIikrXFxcIj5cXFwiKTtyZXR1cm4gYi5ub2RlLnJhd0F0dHJpYnV0ZXMoZS5nZXQoMCkpfWZ1bmN0aW9uIHkoYSl7cmV0dXJuIG8oYSxcXFwiPCFET0NUWVBFKFtePl0qPyk+XFxcIiwwKXx8XFxcIjwhRE9DVFlQRSBodG1sPlxcXCJ9ZnVuY3Rpb24geihjKXt2YXIgZD1iLmNsZWFuLmh0bWwoY3x8XFxcIlxcXCIsW10sW10sYi5vcHRzLmZ1bGxQYWdlKTtpZihiLm9wdHMuZnVsbFBhZ2Upe3ZhciBlPXcoZCxcXFwiYm9keVxcXCIpfHwoZC5pbmRleE9mKFxcXCI8Ym9keVxcXCIpPj0wP1xcXCJcXFwiOmQpLGY9eChkLFxcXCJib2R5XFxcIiksZz13KGQsXFxcImhlYWRcXFwiKXx8XFxcIjx0aXRsZT48L3RpdGxlPlxcXCIsaD14KGQsXFxcImhlYWRcXFwiKSxpPWEoXFxcIjxkaXY+XFxcIikuYXBwZW5kKGcpLmNvbnRlbnRzKCkuZWFjaChmdW5jdGlvbigpeyh0aGlzLm5vZGVUeXBlPT1Ob2RlLkNPTU1FTlRfTk9ERXx8W1xcXCJCQVNFXFxcIixcXFwiTElOS1xcXCIsXFxcIk1FVEFcXFwiLFxcXCJOT1NDUklQVFxcXCIsXFxcIlNDUklQVFxcXCIsXFxcIlNUWUxFXFxcIixcXFwiVEVNUExBVEVcXFwiLFxcXCJUSVRMRVxcXCJdLmluZGV4T2YodGhpcy50YWdOYW1lKT49MCkmJnRoaXMucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzKX0pLmVuZCgpLmh0bWwoKS50cmltKCk7Zz1hKFxcXCI8ZGl2PlxcXCIpLmFwcGVuZChnKS5jb250ZW50cygpLm1hcChmdW5jdGlvbigpe3JldHVybiB0aGlzLm5vZGVUeXBlPT1Ob2RlLkNPTU1FTlRfTk9ERT9cXFwiPCEtLVxcXCIrdGhpcy5ub2RlVmFsdWUrXFxcIi0tPlxcXCI6W1xcXCJCQVNFXFxcIixcXFwiTElOS1xcXCIsXFxcIk1FVEFcXFwiLFxcXCJOT1NDUklQVFxcXCIsXFxcIlNDUklQVFxcXCIsXFxcIlNUWUxFXFxcIixcXFwiVEVNUExBVEVcXFwiLFxcXCJUSVRMRVxcXCJdLmluZGV4T2YodGhpcy50YWdOYW1lKT49MD90aGlzLm91dGVySFRNTDpcXFwiXFxcIn0pLnRvQXJyYXkoKS5qb2luKFxcXCJcXFwiKTt2YXIgaj15KGQpLGs9eChkLFxcXCJodG1sXFxcIik7Yi4kZWwuaHRtbChpK1xcXCJcXFxcblxcXCIrZSksYi5ub2RlLmNsZWFyQXR0cmlidXRlcyhiLmVsKSxiLiRlbC5hdHRyKGYpLGIuJGVsLmFkZENsYXNzKFxcXCJmci12aWV3XFxcIiksYi4kZWwuYXR0cihcXFwic3BlbGxjaGVja1xcXCIsYi5vcHRzLnNwZWxsY2hlY2spLGIuJGVsLmF0dHIoXFxcImRpclxcXCIsYi5vcHRzLmRpcmVjdGlvbiksYi4kaGVhZC5odG1sKGcpLGIubm9kZS5jbGVhckF0dHJpYnV0ZXMoYi4kaGVhZC5nZXQoMCkpLGIuJGhlYWQuYXR0cihoKSxiLm5vZGUuY2xlYXJBdHRyaWJ1dGVzKGIuJGh0bWwuZ2V0KDApKSxiLiRodG1sLmF0dHIoayksYi5pZnJhbWVfZG9jdW1lbnQuZG9jdHlwZS5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZChwKGosYi5pZnJhbWVfZG9jdW1lbnQpLGIuaWZyYW1lX2RvY3VtZW50LmRvY3R5cGUpfWVsc2UgYi4kZWwuaHRtbChkKTt2YXIgbD1iLmVkaXQuaXNEaXNhYmxlZCgpO2IuZWRpdC5vbigpLGIuY29yZS5pbmplY3RTdHlsZShiLm9wdHMuaWZyYW1lU3R5bGUpLHUoKSxiLm9wdHMudXNlQ2xhc3Nlc3x8KGIuJGVsLmZpbmQoXFxcIltmci1vcmlnaW5hbC1jbGFzc11cXFwiKS5lYWNoKGZ1bmN0aW9uKCl7dGhpcy5zZXRBdHRyaWJ1dGUoXFxcImNsYXNzXFxcIix0aGlzLmdldEF0dHJpYnV0ZShcXFwiZnItb3JpZ2luYWwtY2xhc3NcXFwiKSksdGhpcy5yZW1vdmVBdHRyaWJ1dGUoXFxcImZyLW9yaWdpbmFsLWNsYXNzXFxcIil9KSxiLiRlbC5maW5kKFxcXCJbZnItb3JpZ2luYWwtc3R5bGVdXFxcIikuZWFjaChmdW5jdGlvbigpe3RoaXMuc2V0QXR0cmlidXRlKFxcXCJzdHlsZVxcXCIsdGhpcy5nZXRBdHRyaWJ1dGUoXFxcImZyLW9yaWdpbmFsLXN0eWxlXFxcIikpLHRoaXMucmVtb3ZlQXR0cmlidXRlKFxcXCJmci1vcmlnaW5hbC1zdHlsZVxcXCIpfSkpLGwmJmIuZWRpdC5vZmYoKSxiLmV2ZW50cy50cmlnZ2VyKFxcXCJodG1sLnNldFxcXCIpfWZ1bmN0aW9uIEEoYSl7dmFyIGI9LygjW15cXFxcc1xcXFwrPn5cXFxcLlxcXFxbOl0rKS9nLGM9LyhcXFxcW1teXFxcXF1dK1xcXFxdKS9nLGQ9LyhcXFxcLlteXFxcXHNcXFxcKz5+XFxcXC5cXFxcWzpdKykvZyxlPS8oOjpbXlxcXFxzXFxcXCs+flxcXFwuXFxcXFs6XSt8OmZpcnN0LWxpbmV8OmZpcnN0LWxldHRlcnw6YmVmb3JlfDphZnRlcikvZ2ksZj0vKDpbXFxcXHctXStcXFxcKFteXFxcXCldKlxcXFwpKS9naSxnPS8oOlteXFxcXHNcXFxcKz5+XFxcXC5cXFxcWzpdKykvZyxoPS8oW15cXFxcc1xcXFwrPn5cXFxcLlxcXFxbOl0rKS9nOyFmdW5jdGlvbigpe3ZhciBiPS86bm90XFxcXCgoW15cXFxcKV0qKVxcXFwpL2c7Yi50ZXN0KGEpJiYoYT1hLnJlcGxhY2UoYixcXFwiICAgICAkMSBcXFwiKSl9KCk7dmFyIGk9MTAwKihhLm1hdGNoKGIpfHxbXSkubGVuZ3RoKzEwKihhLm1hdGNoKGMpfHxbXSkubGVuZ3RoKzEwKihhLm1hdGNoKGQpfHxbXSkubGVuZ3RoKzEwKihhLm1hdGNoKGYpfHxbXSkubGVuZ3RoKzEwKihhLm1hdGNoKGcpfHxbXSkubGVuZ3RoKyhhLm1hdGNoKGUpfHxbXSkubGVuZ3RoO3JldHVybiBhPWEucmVwbGFjZSgvW1xcXFwqXFxcXHNcXFxcKz5+XS9nLFxcXCIgXFxcIiksYT1hLnJlcGxhY2UoL1sjXFxcXC5dL2csXFxcIiBcXFwiKSxpKz0oYS5tYXRjaChoKXx8W10pLmxlbmd0aH1mdW5jdGlvbiBCKGEpe2lmKGIuZXZlbnRzLnRyaWdnZXIoXFxcImh0bWwucHJvY2Vzc0dldFxcXCIsW2FdKSxhJiZhLmdldEF0dHJpYnV0ZSYmXFxcIlxcXCI9PT1hLmdldEF0dHJpYnV0ZShcXFwiY2xhc3NcXFwiKSYmYS5yZW1vdmVBdHRyaWJ1dGUoXFxcImNsYXNzXFxcIiksYSYmYS5ub2RlVHlwZT09Tm9kZS5FTEVNRU5UX05PREUpZm9yKHZhciBjPWEucXVlcnlTZWxlY3RvckFsbCgnW2NsYXNzPVxcXCJcXFwiXScpLGQ9MDtkPGMubGVuZ3RoO2QrKyljW2RdLnJlbW92ZUF0dHJpYnV0ZShcXFwiY2xhc3NcXFwiKX1mdW5jdGlvbiBDKGEsYil7cmV0dXJuIGFbM10tYlszXX1mdW5jdGlvbiBEKGEsYyl7aWYoIWIuJHdwKXJldHVybiBiLiRvZWwuY2xvbmUoKS5yZW1vdmVDbGFzcyhcXFwiZnItdmlld1xcXCIpLnJlbW92ZUF0dHIoXFxcImNvbnRlbnRlZGl0YWJsZVxcXCIpLmdldCgwKS5vdXRlckhUTUw7dmFyIGQ9XFxcIlxcXCI7Yi5ldmVudHMudHJpZ2dlcihcXFwiaHRtbC5iZWZvcmVHZXRcXFwiKTt2YXIgZSxmLGc9W10saD17fSxpPVtdO2lmKCFiLm9wdHMudXNlQ2xhc3NlcyYmIWMpe3ZhciBqPW5ldyBSZWdFeHAoXFxcIl5cXFwiK2Iub3B0cy5odG1sSWdub3JlQ1NTUHJvcGVydGllcy5qb2luKFxcXCIkfF5cXFwiKStcXFwiJFxcXCIsXFxcImdpXFxcIik7Zm9yKGU9MDtlPGIuZG9jLnN0eWxlU2hlZXRzLmxlbmd0aDtlKyspe3ZhciBrLGw9MDt0cnl7az1iLmRvYy5zdHlsZVNoZWV0c1tlXS5jc3NSdWxlcyxiLmRvYy5zdHlsZVNoZWV0c1tlXS5vd25lck5vZGUmJlxcXCJTVFlMRVxcXCI9PWIuZG9jLnN0eWxlU2hlZXRzW2VdLm93bmVyTm9kZS5ub2RlVHlwZSYmKGw9MSl9Y2F0Y2gobSl7fWlmKGspZm9yKHZhciBuPTAsbz1rLmxlbmd0aDtuPG87bisrKWlmKGtbbl0uc2VsZWN0b3JUZXh0JiZrW25dLnN0eWxlLmNzc1RleHQubGVuZ3RoPjApe3ZhciBwLHI9a1tuXS5zZWxlY3RvclRleHQucmVwbGFjZSgvYm9keSB8XFxcXC5mci12aWV3IC9nLFxcXCJcXFwiKS5yZXBsYWNlKC86Oi9nLFxcXCI6XFxcIik7dHJ5e3A9Yi5lbC5xdWVyeVNlbGVjdG9yQWxsKHIpfWNhdGNoKG0pe3A9W119Zm9yKGY9MDtmPHAubGVuZ3RoO2YrKyl7IXBbZl0uZ2V0QXR0cmlidXRlKFxcXCJmci1vcmlnaW5hbC1zdHlsZVxcXCIpJiZwW2ZdLmdldEF0dHJpYnV0ZShcXFwic3R5bGVcXFwiKT8ocFtmXS5zZXRBdHRyaWJ1dGUoXFxcImZyLW9yaWdpbmFsLXN0eWxlXFxcIixwW2ZdLmdldEF0dHJpYnV0ZShcXFwic3R5bGVcXFwiKSksZy5wdXNoKHBbZl0pKTpwW2ZdLmdldEF0dHJpYnV0ZShcXFwiZnItb3JpZ2luYWwtc3R5bGVcXFwiKXx8Zy5wdXNoKHBbZl0pLGhbcFtmXV18fChoW3BbZl1dPXt9KTtmb3IodmFyIHM9MWUzKmwrQShrW25dLnNlbGVjdG9yVGV4dCksdD1rW25dLnN0eWxlLmNzc1RleHQuc3BsaXQoXFxcIjtcXFwiKSx1PTA7dTx0Lmxlbmd0aDt1Kyspe3ZhciB2PXRbdV0udHJpbSgpLnNwbGl0KFxcXCI6XFxcIilbMF07di5tYXRjaChqKXx8KGhbcFtmXV1bdl18fChoW3BbZl1dW3ZdPTAsKHBbZl0uZ2V0QXR0cmlidXRlKFxcXCJmci1vcmlnaW5hbC1zdHlsZVxcXCIpfHxcXFwiXFxcIikuaW5kZXhPZih2K1xcXCI6XFxcIik+PTAmJihoW3BbZl1dW3ZdPTFlNCkpLHM+PWhbcFtmXV1bdl0mJihoW3BbZl1dW3ZdPXMsdFt1XS50cmltKCkubGVuZ3RoJiZpLnB1c2goW3BbZl0sdi50cmltKCksdFt1XS50cmltKCkuc3BsaXQoXFxcIjpcXFwiKVsxXS50cmltKCksc10pKSl9fX19Zm9yKGkuc29ydChDKSxlPTA7ZTxpLmxlbmd0aDtlKyspe3ZhciB3PWlbZV07d1swXS5zdHlsZVt3WzFdXT13WzJdfWZvcihlPTA7ZTxnLmxlbmd0aDtlKyspaWYoZ1tlXS5nZXRBdHRyaWJ1dGUoXFxcImNsYXNzXFxcIikmJihnW2VdLnNldEF0dHJpYnV0ZShcXFwiZnItb3JpZ2luYWwtY2xhc3NcXFwiLGdbZV0uZ2V0QXR0cmlidXRlKFxcXCJjbGFzc1xcXCIpKSxcXG5nW2VdLnJlbW92ZUF0dHJpYnV0ZShcXFwiY2xhc3NcXFwiKSksKGdbZV0uZ2V0QXR0cmlidXRlKFxcXCJmci1vcmlnaW5hbC1zdHlsZVxcXCIpfHxcXFwiXFxcIikudHJpbSgpLmxlbmd0aD4wKXt2YXIgeD1nW2VdLmdldEF0dHJpYnV0ZShcXFwiZnItb3JpZ2luYWwtc3R5bGVcXFwiKS5zcGxpdChcXFwiO1xcXCIpO2ZvcihmPTA7Zjx4Lmxlbmd0aDtmKyspeFtmXS5pbmRleE9mKFxcXCI6XFxcIik+MCYmKGdbZV0uc3R5bGVbeFtmXS5zcGxpdChcXFwiOlxcXCIpWzBdLnRyaW0oKV09eFtmXS5zcGxpdChcXFwiOlxcXCIpWzFdLnRyaW0oKSl9fWlmKGIuY29yZS5pc0VtcHR5KCk/Yi5vcHRzLmZ1bGxQYWdlJiYoZD1xKGIuaWZyYW1lX2RvY3VtZW50KSxkKz1cXFwiPGh0bWxcXFwiK2Iubm9kZS5hdHRyaWJ1dGVzKGIuJGh0bWwuZ2V0KDApKStcXFwiPlxcXCIrYi4kaHRtbC5maW5kKFxcXCJoZWFkXFxcIikuZ2V0KDApLm91dGVySFRNTCtcXFwiPGJvZHk+PC9ib2R5PjwvaHRtbD5cXFwiKTooXFxcInVuZGVmaW5lZFxcXCI9PXR5cGVvZiBhJiYoYT0hMSksYi5vcHRzLmZ1bGxQYWdlPyhkPXEoYi5pZnJhbWVfZG9jdW1lbnQpLGIuJGVsLnJlbW92ZUNsYXNzKFxcXCJmci12aWV3XFxcIiksZCs9XFxcIjxodG1sXFxcIitiLm5vZGUuYXR0cmlidXRlcyhiLiRodG1sLmdldCgwKSkrXFxcIj5cXFwiK2IuJGh0bWwuaHRtbCgpK1xcXCI8L2h0bWw+XFxcIixiLiRlbC5hZGRDbGFzcyhcXFwiZnItdmlld1xcXCIpKTpkPWIuJGVsLmh0bWwoKSksIWIub3B0cy51c2VDbGFzc2VzJiYhYylmb3IoZT0wO2U8Zy5sZW5ndGg7ZSsrKWdbZV0uZ2V0QXR0cmlidXRlKFxcXCJmci1vcmlnaW5hbC1jbGFzc1xcXCIpJiYoZ1tlXS5zZXRBdHRyaWJ1dGUoXFxcImNsYXNzXFxcIixnW2VdLmdldEF0dHJpYnV0ZShcXFwiZnItb3JpZ2luYWwtY2xhc3NcXFwiKSksZ1tlXS5yZW1vdmVBdHRyaWJ1dGUoXFxcImZyLW9yaWdpbmFsLWNsYXNzXFxcIikpLGdbZV0uZ2V0QXR0cmlidXRlKFxcXCJmci1vcmlnaW5hbC1zdHlsZVxcXCIpPyhnW2VdLnNldEF0dHJpYnV0ZShcXFwic3R5bGVcXFwiLGdbZV0uZ2V0QXR0cmlidXRlKFxcXCJmci1vcmlnaW5hbC1zdHlsZVxcXCIpKSxnW2VdLnJlbW92ZUF0dHJpYnV0ZShcXFwiZnItb3JpZ2luYWwtc3R5bGVcXFwiKSk6Z1tlXS5yZW1vdmVBdHRyaWJ1dGUoXFxcInN0eWxlXFxcIik7Yi5vcHRzLmZ1bGxQYWdlJiYoZD1kLnJlcGxhY2UoLzxzdHlsZSBkYXRhLWZyLXN0eWxlPVxcXCJ0cnVlXFxcIj4oPzpbXFxcXHdcXFxcV10qPyk8XFxcXC9zdHlsZT4vZyxcXFwiXFxcIiksZD1kLnJlcGxhY2UoLzxsaW5rKFtePl0qKWRhdGEtZnItc3R5bGU9XFxcInRydWVcXFwiKFtePl0qKT4vZyxcXFwiXFxcIiksZD1kLnJlcGxhY2UoLzxzdHlsZSg/OltcXFxcd1xcXFxXXSo/KWNsYXNzPVxcXCJmaXJlYnVnUmVzZXRTdHlsZXNcXFwiKD86W1xcXFx3XFxcXFddKj8pPig/OltcXFxcd1xcXFxXXSo/KTxcXFxcL3N0eWxlPi9nLFxcXCJcXFwiKSxkPWQucmVwbGFjZSgvPGJvZHkoKD86W1xcXFx3XFxcXFddKj8pKSBzcGVsbGNoZWNrPVxcXCJ0cnVlXFxcIigoPzpbXFxcXHdcXFxcV10qPykpPigoPzpbXFxcXHdcXFxcV10qPykpPFxcXFwvYm9keT4vZyxcXFwiPGJvZHkkMSQyPiQzPC9ib2R5PlxcXCIpLGQ9ZC5yZXBsYWNlKC88Ym9keSgoPzpbXFxcXHdcXFxcV10qPykpIGNvbnRlbnRlZGl0YWJsZT1cXFwiKHRydWV8ZmFsc2UpXFxcIigoPzpbXFxcXHdcXFxcV10qPykpPigoPzpbXFxcXHdcXFxcV10qPykpPFxcXFwvYm9keT4vZyxcXFwiPGJvZHkkMSQzPiQ0PC9ib2R5PlxcXCIpLGQ9ZC5yZXBsYWNlKC88Ym9keSgoPzpbXFxcXHdcXFxcV10qPykpIGRpcj1cXFwiKFtcXFxcd10qKVxcXCIoKD86W1xcXFx3XFxcXFddKj8pKT4oKD86W1xcXFx3XFxcXFddKj8pKTxcXFxcL2JvZHk+L2csXFxcIjxib2R5JDEkMz4kNDwvYm9keT5cXFwiKSxkPWQucmVwbGFjZSgvPGJvZHkoKD86W1xcXFx3XFxcXFddKj8pKWNsYXNzPVxcXCIoW1xcXFx3XFxcXFddKj8pKGZyLXJ0bHxmci1sdHIpKFtcXFxcd1xcXFxXXSo/KVxcXCIoKD86W1xcXFx3XFxcXFddKj8pKT4oKD86W1xcXFx3XFxcXFddKj8pKTxcXFxcL2JvZHk+L2csJzxib2R5JDFjbGFzcz1cXFwiJDIkNFxcXCIkNT4kNjwvYm9keT4nKSxkPWQucmVwbGFjZSgvPGJvZHkoKD86W1xcXFx3XFxcXFddKj8pKSBjbGFzcz1cXFwiXFxcIigoPzpbXFxcXHdcXFxcV10qPykpPigoPzpbXFxcXHdcXFxcV10qPykpPFxcXFwvYm9keT4vZyxcXFwiPGJvZHkkMSQyPiQzPC9ib2R5PlxcXCIpKSxiLm9wdHMuaHRtbFNpbXBsZUFtcGVyc2FuZCYmKGQ9ZC5yZXBsYWNlKC9cXFxcJmFtcDsvZ2ksXFxcIiZcXFwiKSksYi5ldmVudHMudHJpZ2dlcihcXFwiaHRtbC5hZnRlckdldFxcXCIpLGF8fChkPWQucmVwbGFjZSgvPHNwYW5bXj5dKj8gY2xhc3NcXFxccyo9XFxcXHMqW1xcXCInXT9mci1tYXJrZXJbXFxcIiddP1tePl0rPlxcXFx1MjAwYjxcXFxcL3NwYW4+L2dpLFxcXCJcXFwiKSksZD1iLmNsZWFuLmludmlzaWJsZVNwYWNlcyhkKSxkPWIuY2xlYW4uZXhlYyhkLEIpO3ZhciB5PWIuZXZlbnRzLmNoYWluVHJpZ2dlcihcXFwiaHRtbC5nZXRcXFwiLGQpO3JldHVyblxcXCJzdHJpbmdcXFwiPT10eXBlb2YgeSYmKGQ9eSksZD1kLnJlcGxhY2UoLzxwcmUoPzpbXFxcXHdcXFxcV10qPyk+KD86W1xcXFx3XFxcXFddKj8pPFxcXFwvcHJlPi9nLGZ1bmN0aW9uKGEpe3JldHVybiBhLnJlcGxhY2UoLzxicj4vZyxcXFwiXFxcXG5cXFwiKX0pfWZ1bmN0aW9uIEUoKXt2YXIgYz1mdW5jdGlvbihjLGQpe2Zvcig7ZCYmKGQubm9kZVR5cGU9PU5vZGUuVEVYVF9OT0RFfHwhYi5ub2RlLmlzQmxvY2soZCkpJiYhYi5ub2RlLmlzRWxlbWVudChkKTspZCYmZC5ub2RlVHlwZSE9Tm9kZS5URVhUX05PREUmJmEoYykud3JhcElubmVyKGIubm9kZS5vcGVuVGFnU3RyaW5nKGQpK2Iubm9kZS5jbG9zZVRhZ1N0cmluZyhkKSksZD1kLnBhcmVudE5vZGU7ZCYmYy5pbm5lckhUTUw9PWQuaW5uZXJIVE1MJiYoYy5pbm5lckhUTUw9ZC5vdXRlckhUTUwpfSxkPWZ1bmN0aW9uKCl7dmFyIGMsZD1udWxsO3JldHVybiBiLndpbi5nZXRTZWxlY3Rpb24/KGM9Yi53aW4uZ2V0U2VsZWN0aW9uKCksYyYmYy5yYW5nZUNvdW50JiYoZD1jLmdldFJhbmdlQXQoMCkuY29tbW9uQW5jZXN0b3JDb250YWluZXIsZC5ub2RlVHlwZSE9Tm9kZS5FTEVNRU5UX05PREUmJihkPWQucGFyZW50Tm9kZSkpKTooYz1iLmRvYy5zZWxlY3Rpb24pJiZcXFwiQ29udHJvbFxcXCIhPWMudHlwZSYmKGQ9Yy5jcmVhdGVSYW5nZSgpLnBhcmVudEVsZW1lbnQoKSksbnVsbCE9ZCYmKGEuaW5BcnJheShiLmVsLGEoZCkucGFyZW50cygpKT49MHx8ZD09Yi5lbCk/ZDpudWxsfSxlPVxcXCJcXFwiO2lmKFxcXCJ1bmRlZmluZWRcXFwiIT10eXBlb2YgYi53aW4uZ2V0U2VsZWN0aW9uKXtiLmJyb3dzZXIubW96aWxsYSYmKGIuc2VsZWN0aW9uLnNhdmUoKSxiLiRlbC5maW5kKCcuZnItbWFya2VyW2RhdGEtdHlwZT1cXFwiZmFsc2VcXFwiXScpLmxlbmd0aD4xJiYoYi4kZWwuZmluZCgnLmZyLW1hcmtlcltkYXRhLXR5cGU9XFxcImZhbHNlXFxcIl1bZGF0YS1pZD1cXFwiMFxcXCJdJykucmVtb3ZlKCksYi4kZWwuZmluZCgnLmZyLW1hcmtlcltkYXRhLXR5cGU9XFxcImZhbHNlXFxcIl06bGFzdCcpLmF0dHIoXFxcImRhdGEtaWRcXFwiLFxcXCIwXFxcIiksYi4kZWwuZmluZChcXFwiLmZyLW1hcmtlclxcXCIpLm5vdCgnW2RhdGEtaWQ9XFxcIjBcXFwiXScpLnJlbW92ZSgpKSxiLnNlbGVjdGlvbi5yZXN0b3JlKCkpO2Zvcih2YXIgZj1iLnNlbGVjdGlvbi5yYW5nZXMoKSxnPTA7ZzxmLmxlbmd0aDtnKyspe3ZhciBoPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXFxcImRpdlxcXCIpO2guYXBwZW5kQ2hpbGQoZltnXS5jbG9uZUNvbnRlbnRzKCkpO3ZhciBpPWguY2hpbGRyZW47aWYoaS5sZW5ndGgpe3ZhciBqPWlbaS5sZW5ndGgtMV07KFxcXCJQXFxcIj09ai50YWdOYW1lJiZiLm9wdHMuZW50ZXI9PWEuRnJvYWxhRWRpdG9yLkVOVEVSX1B8fFxcXCJESVZcXFwiPT1qLnRhZ05hbWUmJmIub3B0cy5lbnRlcj09YS5Gcm9hbGFFZGl0b3IuRU5URVJfRElWKSYmYi5ub2RlLmlzRW1wdHkoaikmJmgucmVtb3ZlQ2hpbGQoail9YyhoLGQoKSksYShoKS5maW5kKFxcXCIuZnItZWxlbWVudFxcXCIpLmxlbmd0aD4wJiYoaD1iLmVsKSxlKz1oLmlubmVySFRNTH19ZWxzZVxcXCJ1bmRlZmluZWRcXFwiIT10eXBlb2YgYi5kb2Muc2VsZWN0aW9uJiZcXFwiVGV4dFxcXCI9PWIuZG9jLnNlbGVjdGlvbi50eXBlJiYoZT1iLmRvYy5zZWxlY3Rpb24uY3JlYXRlUmFuZ2UoKS5odG1sVGV4dCk7cmV0dXJuIGV9ZnVuY3Rpb24gRihhKXt2YXIgYz1iLmRvYy5jcmVhdGVFbGVtZW50KFxcXCJkaXZcXFwiKTtyZXR1cm4gYy5pbm5lckhUTUw9YSxudWxsIT09Yy5xdWVyeVNlbGVjdG9yKGYoKSl9ZnVuY3Rpb24gRyhhKXt2YXIgYz1iLmRvYy5jcmVhdGVFbGVtZW50KFxcXCJkaXZcXFwiKTtyZXR1cm4gYy5pbm5lckhUTUw9YSxiLnNlbGVjdGlvbi5zZXRBdEVuZChjKSxjLmlubmVySFRNTH1mdW5jdGlvbiBIKGEpe3JldHVybiBhLnJlcGxhY2UoLzwvZ2ksXFxcIiZsdDtcXFwiKS5yZXBsYWNlKC8+L2dpLFxcXCImZ3Q7XFxcIikucmVwbGFjZSgvXFxcIi9naSxcXFwiJnF1b3Q7XFxcIikucmVwbGFjZSgvJy9naSxcXFwiJiMzOTtcXFwiKX1mdW5jdGlvbiBJKGMsZCxlKXtiLnNlbGVjdGlvbi5pc0NvbGxhcHNlZCgpfHxiLnNlbGVjdGlvbi5yZW1vdmUoKTt2YXIgZjtpZihmPWQ/YzpiLmNsZWFuLmh0bWwoYyksZj1mLnJlcGxhY2UoL1xcXFxyfFxcXFxuL2csXFxcIiBcXFwiKSxjLmluZGV4T2YoJ2NsYXNzPVxcXCJmci1tYXJrZXJcXFwiJyk8MCYmKGY9RyhmKSksYi5jb3JlLmlzRW1wdHkoKSYmIWIub3B0cy5rZWVwRm9ybWF0T25EZWxldGUpYi5lbC5pbm5lckhUTUw9ZjtlbHNle3ZhciBnPWIubWFya2Vycy5pbnNlcnQoKTtpZihnKXtiLm5vZGUuaXNMYXN0U2libGluZyhnKSYmYShnKS5wYXJlbnQoKS5oYXNDbGFzcyhcXFwiZnItZGVsZXRhYmxlXFxcIikmJmEoZykuaW5zZXJ0QWZ0ZXIoYShnKS5wYXJlbnQoKSk7dmFyIGgsaT1iLm5vZGUuYmxvY2tQYXJlbnQoZyk7aWYoKEYoZil8fGUpJiYoaD1iLm5vZGUuZGVlcGVzdFBhcmVudChnKXx8aSYmXFxcIkxJXFxcIj09aS50YWdOYW1lKSl7aWYoZz1iLm1hcmtlcnMuc3BsaXQoKSwhZylyZXR1cm4hMTtnLm91dGVySFRNTD1mfWVsc2UgZy5vdXRlckhUTUw9Zn1lbHNlIGIuZWwuaW5uZXJIVE1MPWIuZWwuaW5uZXJIVE1MK2Z9dSgpLGIuZXZlbnRzLnRyaWdnZXIoXFxcImh0bWwuaW5zZXJ0ZWRcXFwiKX1mdW5jdGlvbiBKKGMpe3ZhciBkPW51bGw7aWYoXFxcInVuZGVmaW5lZFxcXCI9PXR5cGVvZiBjJiYoZD1iLnNlbGVjdGlvbi5lbGVtZW50KCkpLGIub3B0cy5rZWVwRm9ybWF0T25EZWxldGUpcmV0dXJuITE7dmFyIGU9ZD8oZC50ZXh0Q29udGVudC5tYXRjaCgvXFxcXHUyMDBCL2cpfHxbXSkubGVuZ3RoLWQucXVlcnlTZWxlY3RvckFsbChcXFwiLmZyLW1hcmtlclxcXCIpLmxlbmd0aDowLGY9KGIuZWwudGV4dENvbnRlbnQubWF0Y2goL1xcXFx1MjAwQi9nKXx8W10pLmxlbmd0aC1iLmVsLnF1ZXJ5U2VsZWN0b3JBbGwoXFxcIi5mci1tYXJrZXJcXFwiKS5sZW5ndGg7aWYoZj09ZSlyZXR1cm4hMTt2YXIgZyxoO2Rve2g9ITEsZz1iLmVsLnF1ZXJ5U2VsZWN0b3JBbGwoXFxcIio6bm90KC5mci1tYXJrZXIpXFxcIik7Zm9yKHZhciBpPTA7aTxnLmxlbmd0aDtpKyspe3ZhciBqPWdbaV07aWYoZCE9ail7dmFyIGs9ai50ZXh0Q29udGVudDswPT09ai5jaGlsZHJlbi5sZW5ndGgmJjE9PT1rLmxlbmd0aCYmODIwMz09ay5jaGFyQ29kZUF0KDApJiYoYShqKS5yZW1vdmUoKSxoPSEwKX19fXdoaWxlKGgpfWZ1bmN0aW9uIEsoKXt2YXIgYT1mdW5jdGlvbigpe0ooKSxiLnBsYWNlaG9sZGVyJiZzZXRUaW1lb3V0KGIucGxhY2Vob2xkZXIucmVmcmVzaCwwKX07Yi5ldmVudHMub24oXFxcIm1vdXNldXBcXFwiLGEpLGIuZXZlbnRzLm9uKFxcXCJrZXlkb3duXFxcIixhKSxiLmV2ZW50cy5vbihcXFwiY29udGVudENoYW5nZWRcXFwiLHYpfXJldHVybntkZWZhdWx0VGFnOmMsZW1wdHlCbG9ja3M6ZCxlbXB0eUJsb2NrVGFnc1F1ZXJ5OmUsYmxvY2tUYWdzUXVlcnk6ZixmaWxsRW1wdHlCbG9ja3M6bCxjbGVhbkVtcHR5VGFnczpnLGNsZWFuV2hpdGVUYWdzOkosY2xlYW5CbGFua1NwYWNlczpuLGJsb2NrczptLGdldERvY3R5cGU6cSxzZXQ6eixnZXQ6RCxnZXRTZWxlY3RlZDpFLGluc2VydDpJLHdyYXA6aix1bndyYXA6ayxlc2NhcGVFbnRpdGllczpILGNoZWNrSWZFbXB0eTp2LGV4dHJhY3ROb2RlOncsZXh0cmFjdE5vZGVBdHRyczp4LGV4dHJhY3REb2N0eXBlOnksY2xlYW5CUnM6dCxfaW5pdDpLfX0sYS5leHRlbmQoYS5GRS5ERUZBVUxUUyx7aGVpZ2h0Om51bGwsaGVpZ2h0TWF4Om51bGwsaGVpZ2h0TWluOm51bGwsd2lkdGg6bnVsbH0pLGEuRkUuTU9EVUxFUy5zaXplPWZ1bmN0aW9uKGEpe2Z1bmN0aW9uIGIoKXtjKCksYS5vcHRzLmhlaWdodCYmYS4kZWwuY3NzKFxcXCJtaW5IZWlnaHRcXFwiLGEub3B0cy5oZWlnaHQtYS5oZWxwZXJzLmdldFBYKGEuJGVsLmNzcyhcXFwicGFkZGluZy10b3BcXFwiKSktYS5oZWxwZXJzLmdldFBYKGEuJGVsLmNzcyhcXFwicGFkZGluZy1ib3R0b21cXFwiKSkpLGEuJGlmcmFtZS5oZWlnaHQoYS4kZWwub3V0ZXJIZWlnaHQoITApKX1mdW5jdGlvbiBjKCl7YS5vcHRzLmhlaWdodE1pbj9hLiRlbC5jc3MoXFxcIm1pbkhlaWdodFxcXCIsYS5vcHRzLmhlaWdodE1pbik6YS4kZWwuY3NzKFxcXCJtaW5IZWlnaHRcXFwiLFxcXCJcXFwiKSxhLm9wdHMuaGVpZ2h0TWF4PyhhLiR3cC5jc3MoXFxcIm1heEhlaWdodFxcXCIsYS5vcHRzLmhlaWdodE1heCksYS4kd3AuY3NzKFxcXCJvdmVyZmxvd1xcXCIsXFxcImF1dG9cXFwiKSk6KGEuJHdwLmNzcyhcXFwibWF4SGVpZ2h0XFxcIixcXFwiXFxcIiksYS4kd3AuY3NzKFxcXCJvdmVyZmxvd1xcXCIsXFxcIlxcXCIpKSxhLm9wdHMuaGVpZ2h0PyhhLiR3cC5oZWlnaHQoYS5vcHRzLmhlaWdodCksYS4kd3AuY3NzKFxcXCJvdmVyZmxvd1xcXCIsXFxcImF1dG9cXFwiKSxhLiRlbC5jc3MoXFxcIm1pbkhlaWdodFxcXCIsYS5vcHRzLmhlaWdodC1hLmhlbHBlcnMuZ2V0UFgoYS4kZWwuY3NzKFxcXCJwYWRkaW5nLXRvcFxcXCIpKS1hLmhlbHBlcnMuZ2V0UFgoYS4kZWwuY3NzKFxcXCJwYWRkaW5nLWJvdHRvbVxcXCIpKSkpOihhLiR3cC5jc3MoXFxcImhlaWdodFxcXCIsXFxcIlxcXCIpLGEub3B0cy5oZWlnaHRNaW58fGEuJGVsLmNzcyhcXFwibWluSGVpZ2h0XFxcIixcXFwiXFxcIiksYS5vcHRzLmhlaWdodE1heHx8YS4kd3AuY3NzKFxcXCJvdmVyZmxvd1xcXCIsXFxcIlxcXCIpKSxhLm9wdHMud2lkdGgmJmEuJGJveC53aWR0aChhLm9wdHMud2lkdGgpfWZ1bmN0aW9uIGQoKXtyZXR1cm4hIWEuJHdwJiYoYygpLHZvaWQoYS4kaWZyYW1lJiYoYS5ldmVudHMub24oXFxcImtleXVwIGtleWRvd25cXFwiLGZ1bmN0aW9uKCl7c2V0VGltZW91dChiLDApfSwhMCksYS5ldmVudHMub24oXFxcImNvbW1hbmRzLmFmdGVyXFxcIixiKSxhLmV2ZW50cy5vbihcXFwiaHRtbC5zZXRcXFwiLGIpLGEuZXZlbnRzLm9uKFxcXCJpbml0XFxcIixiKSxhLmV2ZW50cy5vbihcXFwiaW5pdGlhbGl6ZWRcXFwiLGIpKSkpfXJldHVybntfaW5pdDpkLHN5bmNJZnJhbWU6YixyZWZyZXNoOmN9fSxhLmV4dGVuZChhLkZFLkRFRkFVTFRTLHtsYW5ndWFnZTpudWxsfSksYS5GRS5MQU5HVUFHRT17fSxhLkZFLk1PRFVMRVMubGFuZ3VhZ2U9ZnVuY3Rpb24oYil7ZnVuY3Rpb24gYyhhKXtyZXR1cm4gZSYmZS50cmFuc2xhdGlvblthXT9lLnRyYW5zbGF0aW9uW2FdOmF9ZnVuY3Rpb24gZCgpe2EuRkUuTEFOR1VBR0UmJihlPWEuRkUuTEFOR1VBR0VbYi5vcHRzLmxhbmd1YWdlXSksZSYmZS5kaXJlY3Rpb24mJihiLm9wdHMuZGlyZWN0aW9uPWUuZGlyZWN0aW9uKX12YXIgZTtyZXR1cm57X2luaXQ6ZCx0cmFuc2xhdGU6Y319LGEuZXh0ZW5kKGEuRkUuREVGQVVMVFMse3BsYWNlaG9sZGVyVGV4dDpcXFwiVHlwZSBzb21ldGhpbmdcXFwifSksYS5GRS5NT0RVTEVTLnBsYWNlaG9sZGVyPWZ1bmN0aW9uKGIpe2Z1bmN0aW9uIGMoKXtiLiRwbGFjZWhvbGRlcnx8ZygpO3ZhciBjPTAsZD0wLGU9MCxmPTAsaD0wLGk9MCxqPWIubm9kZS5jb250ZW50cyhiLmVsKSxrPWEoYi5zZWxlY3Rpb24uZWxlbWVudCgpKS5jc3MoXFxcInRleHQtYWxpZ25cXFwiKTtpZihqLmxlbmd0aCYmalswXS5ub2RlVHlwZT09Tm9kZS5FTEVNRU5UX05PREUpe3ZhciBsPWEoalswXSk7IWIub3B0cy50b29sYmFySW5saW5lJiZiLnJlYWR5JiYoYz1iLmhlbHBlcnMuZ2V0UFgobC5jc3MoXFxcIm1hcmdpbi10b3BcXFwiKSksZj1iLmhlbHBlcnMuZ2V0UFgobC5jc3MoXFxcInBhZGRpbmctdG9wXFxcIikpLGQ9Yi5oZWxwZXJzLmdldFBYKGwuY3NzKFxcXCJtYXJnaW4tbGVmdFxcXCIpKSxlPWIuaGVscGVycy5nZXRQWChsLmNzcyhcXFwibWFyZ2luLXJpZ2h0XFxcIikpLGg9Yi5oZWxwZXJzLmdldFBYKGwuY3NzKFxcXCJwYWRkaW5nLWxlZnRcXFwiKSksaT1iLmhlbHBlcnMuZ2V0UFgobC5jc3MoXFxcInBhZGRpbmctcmlnaHRcXFwiKSkpLGIuJHBsYWNlaG9sZGVyLmNzcyhcXFwiZm9udC1zaXplXFxcIixsLmNzcyhcXFwiZm9udC1zaXplXFxcIikpLGIuJHBsYWNlaG9sZGVyLmNzcyhcXFwibGluZS1oZWlnaHRcXFwiLGwuY3NzKFxcXCJsaW5lLWhlaWdodFxcXCIpKX1lbHNlIGIuJHBsYWNlaG9sZGVyLmNzcyhcXFwiZm9udC1zaXplXFxcIixiLiRlbC5jc3MoXFxcImZvbnQtc2l6ZVxcXCIpKSxiLiRwbGFjZWhvbGRlci5jc3MoXFxcImxpbmUtaGVpZ2h0XFxcIixiLiRlbC5jc3MoXFxcImxpbmUtaGVpZ2h0XFxcIikpO2IuJHdwLmFkZENsYXNzKFxcXCJzaG93LXBsYWNlaG9sZGVyXFxcIiksYi4kcGxhY2Vob2xkZXIuY3NzKHttYXJnaW5Ub3A6TWF0aC5tYXgoYi5oZWxwZXJzLmdldFBYKGIuJGVsLmNzcyhcXFwibWFyZ2luLXRvcFxcXCIpKSxjKSxwYWRkaW5nVG9wOk1hdGgubWF4KGIuaGVscGVycy5nZXRQWChiLiRlbC5jc3MoXFxcInBhZGRpbmctdG9wXFxcIikpLGYpLHBhZGRpbmdMZWZ0Ok1hdGgubWF4KGIuaGVscGVycy5nZXRQWChiLiRlbC5jc3MoXFxcInBhZGRpbmctbGVmdFxcXCIpKSxoKSxtYXJnaW5MZWZ0Ok1hdGgubWF4KGIuaGVscGVycy5nZXRQWChiLiRlbC5jc3MoXFxcIm1hcmdpbi1sZWZ0XFxcIikpLGQpLHBhZGRpbmdSaWdodDpNYXRoLm1heChiLmhlbHBlcnMuZ2V0UFgoYi4kZWwuY3NzKFxcXCJwYWRkaW5nLXJpZ2h0XFxcIikpLGkpLG1hcmdpblJpZ2h0Ok1hdGgubWF4KGIuaGVscGVycy5nZXRQWChiLiRlbC5jc3MoXFxcIm1hcmdpbi1yaWdodFxcXCIpKSxlKSx0ZXh0QWxpZ246a30pLnRleHQoYi5sYW5ndWFnZS50cmFuc2xhdGUoYi5vcHRzLnBsYWNlaG9sZGVyVGV4dHx8Yi4kb2VsLmF0dHIoXFxcInBsYWNlaG9sZGVyXFxcIil8fFxcXCJcXFwiKSksYi4kcGxhY2Vob2xkZXIuaHRtbChiLiRwbGFjZWhvbGRlci50ZXh0KCkucmVwbGFjZSgvXFxcXG4vZyxcXFwiPGJyPlxcXCIpKX1mdW5jdGlvbiBkKCl7Yi4kd3AucmVtb3ZlQ2xhc3MoXFxcInNob3ctcGxhY2Vob2xkZXJcXFwiKX1mdW5jdGlvbiBlKCl7cmV0dXJuIWIuJHdwfHxiLm5vZGUuaGFzQ2xhc3MoYi4kd3AuZ2V0KDApLFxcXCJzaG93LXBsYWNlaG9sZGVyXFxcIil9ZnVuY3Rpb24gZigpe3JldHVybiEhYi4kd3AmJnZvaWQoYi5jb3JlLmlzRW1wdHkoKT9jKCk6ZCgpKX1mdW5jdGlvbiBnKCl7Yi4kcGxhY2Vob2xkZXI9YSgnPHNwYW4gY2xhc3M9XFxcImZyLXBsYWNlaG9sZGVyXFxcIj48L3NwYW4+JyksYi4kd3AuYXBwZW5kKGIuJHBsYWNlaG9sZGVyKX1mdW5jdGlvbiBoKCl7cmV0dXJuISFiLiR3cCYmdm9pZCBiLmV2ZW50cy5vbihcXFwiaW5pdCBpbnB1dCBrZXlkb3duIGtleXVwIGNvbnRlbnRDaGFuZ2VkIGluaXRpYWxpemVkXFxcIixmKX1yZXR1cm57X2luaXQ6aCxzaG93OmMsaGlkZTpkLHJlZnJlc2g6Zixpc1Zpc2libGU6ZX19LGEuRkUuTU9EVUxFUy5lZGl0PWZ1bmN0aW9uKGEpe2Z1bmN0aW9uIGIoKXtpZihhLmJyb3dzZXIubW96aWxsYSl0cnl7YS5kb2MuZXhlY0NvbW1hbmQoXFxcImVuYWJsZU9iamVjdFJlc2l6aW5nXFxcIiwhMSxcXFwiZmFsc2VcXFwiKSxhLmRvYy5leGVjQ29tbWFuZChcXFwiZW5hYmxlSW5saW5lVGFibGVFZGl0aW5nXFxcIiwhMSxcXFwiZmFsc2VcXFwiKX1jYXRjaChiKXt9aWYoYS5icm93c2VyLm1zaWUpdHJ5e2EuZG9jLmJvZHkuYWRkRXZlbnRMaXN0ZW5lcihcXFwibXNjb250cm9sc2VsZWN0XFxcIixmdW5jdGlvbihhKXtyZXR1cm4gYS5wcmV2ZW50RGVmYXVsdCgpLCExfSl9Y2F0Y2goYil7fX1mdW5jdGlvbiBjKCl7YS4kd3A/KGEuJGVsLmF0dHIoXFxcImNvbnRlbnRlZGl0YWJsZVxcXCIsITApLGEuJGVsLnJlbW92ZUNsYXNzKFxcXCJmci1kaXNhYmxlZFxcXCIpLmF0dHIoXFxcImFyaWEtZGlzYWJsZWRcXFwiLCExKSxhLiR0YiYmYS4kdGIucmVtb3ZlQ2xhc3MoXFxcImZyLWRpc2FibGVkXFxcIikuYXR0cihcXFwiYXJpYS1kaXNhYmxlZFxcXCIsITEpLGIoKSk6YS4kZWwuaXMoXFxcImFcXFwiKSYmYS4kZWwuYXR0cihcXFwiY29udGVudGVkaXRhYmxlXFxcIiwhMCksZj0hMX1mdW5jdGlvbiBkKCl7YS4kd3A/KGEuJGVsLmF0dHIoXFxcImNvbnRlbnRlZGl0YWJsZVxcXCIsITEpLGEuJGVsLmFkZENsYXNzKFxcXCJmci1kaXNhYmxlZFxcXCIpLmF0dHIoXFxcImFyaWEtZGlzYWJsZWRcXFwiLCEwKSxhLiR0YiYmYS4kdGIuYWRkQ2xhc3MoXFxcImZyLWRpc2FibGVkXFxcIikuYXR0cihcXFwiYXJpYS1kaXNhYmxlZFxcXCIsITApKTphLiRlbC5pcyhcXFwiYVxcXCIpJiZhLiRlbC5hdHRyKFxcXCJjb250ZW50ZWRpdGFibGVcXFwiLCExKSxmPSEwfWZ1bmN0aW9uIGUoKXtyZXR1cm4gZn12YXIgZj0hMTtyZXR1cm57b246YyxvZmY6ZCxkaXNhYmxlRGVzaWduOmIsaXNEaXNhYmxlZDplfX0sYS5leHRlbmQoYS5GRS5ERUZBVUxUUyx7ZWRpdG9yQ2xhc3M6bnVsbCx0eXBpbmdUaW1lcjo1MDAsaWZyYW1lOiExLHJlcXVlc3RXaXRoQ09SUzohMCxyZXF1ZXN0V2l0aENyZWRlbnRpYWxzOiExLHJlcXVlc3RIZWFkZXJzOnt9LHVzZUNsYXNzZXM6ITAsc3BlbGxjaGVjazohMCxpZnJhbWVTdHlsZTonaHRtbHttYXJnaW46MHB4O2hlaWdodDphdXRvO31ib2R5e2hlaWdodDphdXRvO3BhZGRpbmc6MTBweDtiYWNrZ3JvdW5kOnRyYW5zcGFyZW50O2NvbG9yOiMwMDAwMDA7cG9zaXRpb246cmVsYXRpdmU7ei1pbmRleDogMjstd2Via2l0LXVzZXItc2VsZWN0OmF1dG87bWFyZ2luOjBweDtvdmVyZmxvdzpoaWRkZW47bWluLWhlaWdodDoyMHB4O31ib2R5OmFmdGVye2NvbnRlbnQ6XFxcIlxcXCI7ZGlzcGxheTpibG9jaztjbGVhcjpib3RoO30nLGlmcmFtZVN0eWxlRmlsZXM6W10sZGlyZWN0aW9uOlxcXCJhdXRvXFxcIix6SW5kZXg6MSxkaXNhYmxlUmlnaHRDbGljazohMSxzY3JvbGxhYmxlQ29udGFpbmVyOlxcXCJib2R5XFxcIixrZWVwRm9ybWF0T25EZWxldGU6ITEsdGhlbWU6bnVsbH0pLGEuRkUuTU9EVUxFUy5jb3JlPWZ1bmN0aW9uKGIpe2Z1bmN0aW9uIGMoYyl7aWYoYi5vcHRzLmlmcmFtZSl7Yi4kaGVhZC5maW5kKFxcXCJzdHlsZVtkYXRhLWZyLXN0eWxlXSwgbGlua1tkYXRhLWZyLXN0eWxlXVxcXCIpLnJlbW92ZSgpLGIuJGhlYWQuYXBwZW5kKCc8c3R5bGUgZGF0YS1mci1zdHlsZT1cXFwidHJ1ZVxcXCI+JytjK1xcXCI8L3N0eWxlPlxcXCIpO2Zvcih2YXIgZD0wO2Q8Yi5vcHRzLmlmcmFtZVN0eWxlRmlsZXMubGVuZ3RoO2QrKyl7dmFyIGU9YSgnPGxpbmsgZGF0YS1mci1zdHlsZT1cXFwidHJ1ZVxcXCIgcmVsPVxcXCJzdHlsZXNoZWV0XFxcIiBocmVmPVxcXCInK2Iub3B0cy5pZnJhbWVTdHlsZUZpbGVzW2RdKydcXFwiPicpO2UuZ2V0KDApLmFkZEV2ZW50TGlzdGVuZXIoXFxcImxvYWRcXFwiLGIuc2l6ZS5zeW5jSWZyYW1lKSxiLiRoZWFkLmFwcGVuZChlKX19fWZ1bmN0aW9uIGQoKXtiLm9wdHMuaWZyYW1lfHxiLiRlbC5hZGRDbGFzcyhcXFwiZnItZWxlbWVudCBmci12aWV3XFxcIil9ZnVuY3Rpb24gZSgpe2lmKGIuJGJveC5hZGRDbGFzcyhcXFwiZnItYm94XFxcIisoYi5vcHRzLmVkaXRvckNsYXNzP1xcXCIgXFxcIitiLm9wdHMuZWRpdG9yQ2xhc3M6XFxcIlxcXCIpKSxiLiR3cC5hZGRDbGFzcyhcXFwiZnItd3JhcHBlclxcXCIpLGQoKSxiLm9wdHMuaWZyYW1lKXtiLiRpZnJhbWUuYWRkQ2xhc3MoXFxcImZyLWlmcmFtZVxcXCIpLGIuJGVsLmFkZENsYXNzKFxcXCJmci12aWV3XFxcIik7Zm9yKHZhciBhPTA7YTxiLm9fZG9jLnN0eWxlU2hlZXRzLmxlbmd0aDthKyspe3ZhciBjO3RyeXtjPWIub19kb2Muc3R5bGVTaGVldHNbYV0uY3NzUnVsZXN9Y2F0Y2goZSl7fWlmKGMpZm9yKHZhciBmPTAsZz1jLmxlbmd0aDtmPGc7ZisrKSFjW2ZdLnNlbGVjdG9yVGV4dHx8MCE9PWNbZl0uc2VsZWN0b3JUZXh0LmluZGV4T2YoXFxcIi5mci12aWV3XFxcIikmJjAhPT1jW2ZdLnNlbGVjdG9yVGV4dC5pbmRleE9mKFxcXCIuZnItZWxlbWVudFxcXCIpfHxjW2ZdLnN0eWxlLmNzc1RleHQubGVuZ3RoPjAmJigwPT09Y1tmXS5zZWxlY3RvclRleHQuaW5kZXhPZihcXFwiLmZyLXZpZXdcXFwiKT9iLm9wdHMuaWZyYW1lU3R5bGUrPWNbZl0uc2VsZWN0b3JUZXh0LnJlcGxhY2UoL1xcXFwuZnItdmlldy9nLFxcXCJib2R5XFxcIikrXFxcIntcXFwiK2NbZl0uc3R5bGUuY3NzVGV4dCtcXFwifVxcXCI6Yi5vcHRzLmlmcmFtZVN0eWxlKz1jW2ZdLnNlbGVjdG9yVGV4dC5yZXBsYWNlKC9cXFxcLmZyLWVsZW1lbnQvZyxcXFwiYm9keVxcXCIpK1xcXCJ7XFxcIitjW2ZdLnN0eWxlLmNzc1RleHQrXFxcIn1cXFwiKX19XFxcImF1dG9cXFwiIT1iLm9wdHMuZGlyZWN0aW9uJiZiLiRib3gucmVtb3ZlQ2xhc3MoXFxcImZyLWx0ciBmci1ydGxcXFwiKS5hZGRDbGFzcyhcXFwiZnItXFxcIitiLm9wdHMuZGlyZWN0aW9uKSxiLiRlbC5hdHRyKFxcXCJkaXJcXFwiLGIub3B0cy5kaXJlY3Rpb24pLGIuJHdwLmF0dHIoXFxcImRpclxcXCIsYi5vcHRzLmRpcmVjdGlvbiksYi5vcHRzLnpJbmRleD4xJiZiLiRib3guY3NzKFxcXCJ6LWluZGV4XFxcIixiLm9wdHMuekluZGV4KSxiLm9wdHMudGhlbWUmJmIuJGJveC5hZGRDbGFzcyhiLm9wdHMudGhlbWUrXFxcIi10aGVtZVxcXCIpfWZ1bmN0aW9uIGYoKXtyZXR1cm4gYi5ub2RlLmlzRW1wdHkoYi5lbCl9ZnVuY3Rpb24gZygpe2IuZHJhZ19zdXBwb3J0PXtmaWxlcmVhZGVyOlxcXCJ1bmRlZmluZWRcXFwiIT10eXBlb2YgRmlsZVJlYWRlcixmb3JtZGF0YTohIWIud2luLkZvcm1EYXRhLHByb2dyZXNzOlxcXCJ1cGxvYWRcXFwiaW4gbmV3IFhNTEh0dHBSZXF1ZXN0fX1mdW5jdGlvbiBoKGEsYyl7dmFyIGQ9bmV3IFhNTEh0dHBSZXF1ZXN0O2Qub3BlbihjLGEsITApLGIub3B0cy5yZXF1ZXN0V2l0aENyZWRlbnRpYWxzJiYoZC53aXRoQ3JlZGVudGlhbHM9ITApO2Zvcih2YXIgZSBpbiBiLm9wdHMucmVxdWVzdEhlYWRlcnMpYi5vcHRzLnJlcXVlc3RIZWFkZXJzLmhhc093blByb3BlcnR5KGUpJiZkLnNldFJlcXVlc3RIZWFkZXIoZSxiLm9wdHMucmVxdWVzdEhlYWRlcnNbZV0pO3JldHVybiBkfWZ1bmN0aW9uIGkoYSl7XFxcIlRFWFRBUkVBXFxcIj09Yi4kb2VsLmdldCgwKS50YWdOYW1lJiZiLiRvZWwudmFsKGEpLGIuJHdwJiYoXFxcIlRFWFRBUkVBXFxcIj09Yi4kb2VsLmdldCgwKS50YWdOYW1lPyhiLiRlbC5odG1sKFxcXCJcXFwiKSxiLiR3cC5odG1sKFxcXCJcXFwiKSxiLiRib3gucmVwbGFjZVdpdGgoYi4kb2VsKSxiLiRvZWwuc2hvdygpKTooYi4kd3AucmVwbGFjZVdpdGgoYSksYi4kZWwuaHRtbChcXFwiXFxcIiksYi4kYm94LnJlbW92ZUNsYXNzKFxcXCJmci12aWV3IGZyLWx0ciBmci1ib3ggXFxcIisoYi5vcHRzLmVkaXRvckNsYXNzfHxcXFwiXFxcIikpLGIub3B0cy50aGVtZSYmYi4kYm94LmFkZENsYXNzKGIub3B0cy50aGVtZStcXFwiLXRoZW1lXFxcIikpKSx0aGlzLiR3cD1udWxsLHRoaXMuJGVsPW51bGwsdGhpcy5lbD1udWxsLHRoaXMuJGJveD1udWxsfWZ1bmN0aW9uIGooKXtyZXR1cm4gYi5icm93c2VyLm1vemlsbGEmJmIuaGVscGVycy5pc01vYmlsZSgpP2Iuc2VsZWN0aW9uLmluRWRpdG9yKCk6Yi5ub2RlLmhhc0ZvY3VzKGIuZWwpfHxiLiRlbC5maW5kKFxcXCIqOmZvY3VzXFxcIikubGVuZ3RoPjB9ZnVuY3Rpb24gayhhKXtpZighYSlyZXR1cm4hMTt2YXIgYz1hLmRhdGEoXFxcImluc3RhbmNlXFxcIik7cmV0dXJuISFjJiZjLmlkPT1iLmlkfWZ1bmN0aW9uIGwoKXtpZihhLkZFLklOU1RBTkNFUy5wdXNoKGIpLGcoKSxiLiR3cCl7ZSgpLGIuaHRtbC5zZXQoYi5fb3JpZ2luYWxfaHRtbCksYi4kZWwuYXR0cihcXFwic3BlbGxjaGVja1xcXCIsYi5vcHRzLnNwZWxsY2hlY2spLGIuaGVscGVycy5pc01vYmlsZSgpJiYoYi4kZWwuYXR0cihcXFwiYXV0b2NvbXBsZXRlXFxcIixiLm9wdHMuc3BlbGxjaGVjaz9cXFwib25cXFwiOlxcXCJvZmZcXFwiKSxiLiRlbC5hdHRyKFxcXCJhdXRvY29ycmVjdFxcXCIsYi5vcHRzLnNwZWxsY2hlY2s/XFxcIm9uXFxcIjpcXFwib2ZmXFxcIiksYi4kZWwuYXR0cihcXFwiYXV0b2NhcGl0YWxpemVcXFwiLGIub3B0cy5zcGVsbGNoZWNrP1xcXCJvblxcXCI6XFxcIm9mZlxcXCIpKSxiLm9wdHMuZGlzYWJsZVJpZ2h0Q2xpY2smJmIuZXZlbnRzLiRvbihiLiRlbCxcXFwiY29udGV4dG1lbnVcXFwiLGZ1bmN0aW9uKGEpe2lmKDI9PWEuYnV0dG9uKXJldHVybiExfSk7dHJ5e2IuZG9jLmV4ZWNDb21tYW5kKFxcXCJzdHlsZVdpdGhDU1NcXFwiLCExLCExKX1jYXRjaChjKXt9fVxcXCJURVhUQVJFQVxcXCI9PWIuJG9lbC5nZXQoMCkudGFnTmFtZSYmKGIuZXZlbnRzLm9uKFxcXCJjb250ZW50Q2hhbmdlZFxcXCIsZnVuY3Rpb24oKXtiLiRvZWwudmFsKGIuaHRtbC5nZXQoKSl9KSxiLmV2ZW50cy5vbihcXFwiZm9ybS5zdWJtaXRcXFwiLGZ1bmN0aW9uKCl7Yi4kb2VsLnZhbChiLmh0bWwuZ2V0KCkpfSksYi5ldmVudHMub24oXFxcImZvcm0ucmVzZXRcXFwiLGZ1bmN0aW9uKCl7Yi5odG1sLnNldChiLl9vcmlnaW5hbF9odG1sKX0pLGIuJG9lbC52YWwoYi5odG1sLmdldCgpKSksYi5oZWxwZXJzLmlzSU9TKCkmJmIuZXZlbnRzLiRvbihiLiRkb2MsXFxcInNlbGVjdGlvbmNoYW5nZVxcXCIsZnVuY3Rpb24oKXtiLiRkb2MuZ2V0KDApLmhhc0ZvY3VzKCl8fGIuJHdpbi5nZXQoMCkuZm9jdXMoKX0pLGIuZXZlbnRzLnRyaWdnZXIoXFxcImluaXRcXFwiKX1yZXR1cm57X2luaXQ6bCxkZXN0cm95OmksaXNFbXB0eTpmLGdldFhIUjpoLGluamVjdFN0eWxlOmMsaGFzRm9jdXM6aixzYW1lSW5zdGFuY2U6a319LGEuRkUuTU9EVUxFUy5jdXJzb3JMaXN0cz1mdW5jdGlvbihiKXtmdW5jdGlvbiBjKGEpe2Zvcih2YXIgYj1hO1xcXCJMSVxcXCIhPWIudGFnTmFtZTspYj1iLnBhcmVudE5vZGU7cmV0dXJuIGJ9ZnVuY3Rpb24gZChhKXtmb3IodmFyIGM9YTshYi5ub2RlLmlzTGlzdChjKTspYz1jLnBhcmVudE5vZGU7cmV0dXJuIGN9ZnVuY3Rpb24gZShlKXt2YXIgZixnPWMoZSksaD1nLm5leHRTaWJsaW5nLGk9Zy5wcmV2aW91c1NpYmxpbmcsaj1iLmh0bWwuZGVmYXVsdFRhZygpO2lmKGIubm9kZS5pc0VtcHR5KGcsITApJiZoKXtmb3IodmFyIGs9XFxcIlxcXCIsbD1cXFwiXFxcIixtPWUucGFyZW50Tm9kZTshYi5ub2RlLmlzTGlzdChtKSYmbS5wYXJlbnROb2RlJiZcXFwiTElcXFwiIT09bS5wYXJlbnROb2RlLnRhZ05hbWU7KWs9Yi5ub2RlLm9wZW5UYWdTdHJpbmcobSkrayxsKz1iLm5vZGUuY2xvc2VUYWdTdHJpbmcobSksbT1tLnBhcmVudE5vZGU7az1iLm5vZGUub3BlblRhZ1N0cmluZyhtKStrLGwrPWIubm9kZS5jbG9zZVRhZ1N0cmluZyhtKTt2YXIgbj1cXFwiXFxcIjtmb3Iobj1tLnBhcmVudE5vZGUmJlxcXCJMSVxcXCI9PW0ucGFyZW50Tm9kZS50YWdOYW1lP2wrXFxcIjxsaT5cXFwiK2EuRkUuTUFSS0VSUytcXFwiPGJyPlxcXCIrazpqP2wrXFxcIjxcXFwiK2orXFxcIj5cXFwiK2EuRkUuTUFSS0VSUytcXFwiPGJyPjwvXFxcIitqK1xcXCI+XFxcIitrOmwrYS5GRS5NQVJLRVJTK1xcXCI8YnI+XFxcIitrLGEoZykuaHRtbCgnPHNwYW4gaWQ9XFxcImZyLWJyZWFrXFxcIj48L3NwYW4+Jyk7W1xcXCJVTFxcXCIsXFxcIk9MXFxcIl0uaW5kZXhPZihtLnRhZ05hbWUpPDB8fG0ucGFyZW50Tm9kZSYmXFxcIkxJXFxcIj09PW0ucGFyZW50Tm9kZS50YWdOYW1lOyltPW0ucGFyZW50Tm9kZTt2YXIgbz1iLm5vZGUub3BlblRhZ1N0cmluZyhtKSthKG0pLmh0bWwoKStiLm5vZGUuY2xvc2VUYWdTdHJpbmcobSk7bz1vLnJlcGxhY2UoLzxzcGFuIGlkPVxcXCJmci1icmVha1xcXCI+PFxcXFwvc3Bhbj4vZyxuKSxhKG0pLnJlcGxhY2VXaXRoKG8pLGIuJGVsLmZpbmQoXFxcImxpOmVtcHR5XFxcIikucmVtb3ZlKCl9ZWxzZSBpJiZofHwhYi5ub2RlLmlzRW1wdHkoZywhMCk/KGEoZykuYmVmb3JlKFxcXCI8bGk+PGJyPjwvbGk+XFxcIiksYShlKS5yZW1vdmUoKSk6aT8oZj1kKGcpLGYucGFyZW50Tm9kZSYmXFxcIkxJXFxcIj09Zi5wYXJlbnROb2RlLnRhZ05hbWU/YShmLnBhcmVudE5vZGUpLmFmdGVyKFxcXCI8bGk+XFxcIithLkZFLk1BUktFUlMrXFxcIjxicj48L2xpPlxcXCIpOmo/YShmKS5hZnRlcihcXFwiPFxcXCIraitcXFwiPlxcXCIrYS5GRS5NQVJLRVJTK1xcXCI8YnI+PC9cXFwiK2orXFxcIj5cXFwiKTphKGYpLmFmdGVyKGEuRkUuTUFSS0VSUytcXFwiPGJyPlxcXCIpLGEoZykucmVtb3ZlKCkpOihmPWQoZyksZi5wYXJlbnROb2RlJiZcXFwiTElcXFwiPT1mLnBhcmVudE5vZGUudGFnTmFtZT9oP2EoZi5wYXJlbnROb2RlKS5iZWZvcmUoXFxcIjxsaT5cXFwiK2EuRkUuTUFSS0VSUytcXFwiPGJyPjwvbGk+XFxcIik6YShmLnBhcmVudE5vZGUpLmFmdGVyKFxcXCI8bGk+XFxcIithLkZFLk1BUktFUlMrXFxcIjxicj48L2xpPlxcXCIpOmo/YShmKS5iZWZvcmUoXFxcIjxcXFwiK2orXFxcIj5cXFwiK2EuRkUuTUFSS0VSUytcXFwiPGJyPjwvXFxcIitqK1xcXCI+XFxcIik6YShmKS5iZWZvcmUoYS5GRS5NQVJLRVJTK1xcXCI8YnI+XFxcIiksYShnKS5yZW1vdmUoKSl9ZnVuY3Rpb24gZihkKXtmb3IodmFyIGU9YyhkKSxmPVxcXCJcXFwiLGc9ZCxoPVxcXCJcXFwiLGk9XFxcIlxcXCI7ZyE9ZTspe2c9Zy5wYXJlbnROb2RlO3ZhciBqPVxcXCJBXFxcIj09Zy50YWdOYW1lJiZiLmN1cnNvci5pc0F0RW5kKGQsZyk/XFxcImZyLXRvLXJlbW92ZVxcXCI6XFxcIlxcXCI7aD1iLm5vZGUub3BlblRhZ1N0cmluZyhhKGcpLmNsb25lKCkuYWRkQ2xhc3MoaikuZ2V0KDApKStoLGk9Yi5ub2RlLmNsb3NlVGFnU3RyaW5nKGcpK2l9Zj1pK2YraCthLkZFLk1BUktFUlMsYShkKS5yZXBsYWNlV2l0aCgnPHNwYW4gaWQ9XFxcImZyLWJyZWFrXFxcIj48L3NwYW4+Jyk7dmFyIGs9Yi5ub2RlLm9wZW5UYWdTdHJpbmcoZSkrYShlKS5odG1sKCkrYi5ub2RlLmNsb3NlVGFnU3RyaW5nKGUpO2s9ay5yZXBsYWNlKC88c3BhbiBpZD1cXFwiZnItYnJlYWtcXFwiPjxcXFxcL3NwYW4+L2csZiksYShlKS5yZXBsYWNlV2l0aChrKX1mdW5jdGlvbiBnKGQpe2Zvcih2YXIgZT1jKGQpLGY9YS5GRS5NQVJLRVJTLGc9XFxcIlxcXCIsaD1kLGk9ITE7aCE9ZTspe2g9aC5wYXJlbnROb2RlO3ZhciBqPVxcXCJBXFxcIj09aC50YWdOYW1lJiZiLmN1cnNvci5pc0F0RW5kKGQsaCk/XFxcImZyLXRvLXJlbW92ZVxcXCI6XFxcIlxcXCI7aXx8aD09ZXx8Yi5ub2RlLmlzQmxvY2soaCl8fChpPSEwLGcrPWEuRkUuSU5WSVNJQkxFX1NQQUNFKSxnPWIubm9kZS5vcGVuVGFnU3RyaW5nKGEoaCkuY2xvbmUoKS5hZGRDbGFzcyhqKS5nZXQoMCkpK2csZis9Yi5ub2RlLmNsb3NlVGFnU3RyaW5nKGgpfXZhciBrPWcrZjthKGQpLnJlbW92ZSgpLGEoZSkuYWZ0ZXIoayl9ZnVuY3Rpb24gaChlKXt2YXIgZj1jKGUpLGc9Zi5wcmV2aW91c1NpYmxpbmc7aWYoZyl7Zz1hKGcpLmZpbmQoYi5odG1sLmJsb2NrVGFnc1F1ZXJ5KCkpLmdldCgtMSl8fGcsYShlKS5yZXBsYWNlV2l0aChhLkZFLk1BUktFUlMpO3ZhciBoPWIubm9kZS5jb250ZW50cyhnKTtoLmxlbmd0aCYmXFxcIkJSXFxcIj09aFtoLmxlbmd0aC0xXS50YWdOYW1lJiZhKGhbaC5sZW5ndGgtMV0pLnJlbW92ZSgpLGEoZikuZmluZChiLmh0bWwuYmxvY2tUYWdzUXVlcnkoKSkubm90KFxcXCJvbCwgdWwsIHRhYmxlXFxcIikuZWFjaChmdW5jdGlvbigpe3RoaXMucGFyZW50Tm9kZT09ZiYmYSh0aGlzKS5yZXBsYWNlV2l0aChhKHRoaXMpLmh0bWwoKSsoYi5ub2RlLmlzRW1wdHkodGhpcyk/XFxcIlxcXCI6XFxcIjxicj5cXFwiKSl9KTtmb3IodmFyIGksaj1iLm5vZGUuY29udGVudHMoZilbMF07aiYmIWIubm9kZS5pc0xpc3Qoaik7KWk9ai5uZXh0U2libGluZyxhKGcpLmFwcGVuZChqKSxqPWk7Zm9yKGc9Zi5wcmV2aW91c1NpYmxpbmc7ajspaT1qLm5leHRTaWJsaW5nLGEoZykuYXBwZW5kKGopLGo9aTthKGYpLnJlbW92ZSgpfWVsc2V7dmFyIGs9ZChmKTtpZihhKGUpLnJlcGxhY2VXaXRoKGEuRkUuTUFSS0VSUyksay5wYXJlbnROb2RlJiZcXFwiTElcXFwiPT1rLnBhcmVudE5vZGUudGFnTmFtZSl7dmFyIGw9ay5wcmV2aW91c1NpYmxpbmc7Yi5ub2RlLmlzQmxvY2sobCk/KGEoZikuZmluZChiLmh0bWwuYmxvY2tUYWdzUXVlcnkoKSkubm90KFxcXCJvbCwgdWwsIHRhYmxlXFxcIikuZWFjaChmdW5jdGlvbigpe3RoaXMucGFyZW50Tm9kZT09ZiYmYSh0aGlzKS5yZXBsYWNlV2l0aChhKHRoaXMpLmh0bWwoKSsoYi5ub2RlLmlzRW1wdHkodGhpcyk/XFxcIlxcXCI6XFxcIjxicj5cXFwiKSl9KSxhKGwpLmFwcGVuZChhKGYpLmh0bWwoKSkpOmEoaykuYmVmb3JlKGEoZikuaHRtbCgpKX1lbHNle3ZhciBtPWIuaHRtbC5kZWZhdWx0VGFnKCk7bSYmMD09PWEoZikuZmluZChiLmh0bWwuYmxvY2tUYWdzUXVlcnkoKSkubGVuZ3RoP2EoaykuYmVmb3JlKFxcXCI8XFxcIittK1xcXCI+XFxcIithKGYpLmh0bWwoKStcXFwiPC9cXFwiK20rXFxcIj5cXFwiKTooYShrKS5iZWZvcmUoYShmKS5odG1sKCkpLGIuaHRtbC53cmFwKCkpfWEoZikucmVtb3ZlKCksMD09PWEoaykuZmluZChcXFwibGlcXFwiKS5sZW5ndGgmJmEoaykucmVtb3ZlKCl9fWZ1bmN0aW9uIGkoZCl7dmFyIGUsZj1jKGQpLGc9Zi5uZXh0U2libGluZztpZihnKXtlPWIubm9kZS5jb250ZW50cyhnKSxlLmxlbmd0aCYmXFxcIkJSXFxcIj09ZVswXS50YWdOYW1lJiZhKGVbMF0pLnJlbW92ZSgpLGEoZykuZmluZChiLmh0bWwuYmxvY2tUYWdzUXVlcnkoKSkubm90KFxcXCJvbCwgdWwsIHRhYmxlXFxcIikuZWFjaChmdW5jdGlvbigpe3RoaXMucGFyZW50Tm9kZT09ZyYmYSh0aGlzKS5yZXBsYWNlV2l0aChhKHRoaXMpLmh0bWwoKSsoYi5ub2RlLmlzRW1wdHkodGhpcyk/XFxcIlxcXCI6XFxcIjxicj5cXFwiKSl9KTtmb3IodmFyIGgsaT1kLGo9Yi5ub2RlLmNvbnRlbnRzKGcpWzBdO2omJiFiLm5vZGUuaXNMaXN0KGopOyloPWoubmV4dFNpYmxpbmcsYShpKS5hZnRlcihqKSxpPWosaj1oO2Zvcig7ajspaD1qLm5leHRTaWJsaW5nLGEoZikuYXBwZW5kKGopLGo9aDthKGQpLnJlcGxhY2VXaXRoKGEuRkUuTUFSS0VSUyksYShnKS5yZW1vdmUoKX1lbHNle2Zvcih2YXIgaz1mOyFrLm5leHRTaWJsaW5nJiZrIT1iLmVsOylrPWsucGFyZW50Tm9kZTtpZihrPT1iLmVsKXJldHVybiExO2lmKGs9ay5uZXh0U2libGluZyxiLm5vZGUuaXNCbG9jayhrKSlhLkZFLk5PX0RFTEVURV9UQUdTLmluZGV4T2Yoay50YWdOYW1lKTwwJiYoYShkKS5yZXBsYWNlV2l0aChhLkZFLk1BUktFUlMpLGU9Yi5ub2RlLmNvbnRlbnRzKGYpLGUubGVuZ3RoJiZcXFwiQlJcXFwiPT1lW2UubGVuZ3RoLTFdLnRhZ05hbWUmJmEoZVtlLmxlbmd0aC0xXSkucmVtb3ZlKCksYShmKS5hcHBlbmQoYShrKS5odG1sKCkpLGEoaykucmVtb3ZlKCkpO2Vsc2UgZm9yKGU9Yi5ub2RlLmNvbnRlbnRzKGYpLGUubGVuZ3RoJiZcXFwiQlJcXFwiPT1lW2UubGVuZ3RoLTFdLnRhZ05hbWUmJmEoZVtlLmxlbmd0aC0xXSkucmVtb3ZlKCksYShkKS5yZXBsYWNlV2l0aChhLkZFLk1BUktFUlMpO2smJiFiLm5vZGUuaXNCbG9jayhrKSYmXFxcIkJSXFxcIiE9ay50YWdOYW1lOylhKGYpLmFwcGVuZChhKGspKSxrPWsubmV4dFNpYmxpbmd9fXJldHVybntfc3RhcnRFbnRlcjplLF9taWRkbGVFbnRlcjpmLF9lbmRFbnRlcjpnLF9iYWNrc3BhY2U6aCxfZGVsOml9fSxhLkZFLk5PX0RFTEVURV9UQUdTPVtcXFwiVEhcXFwiLFxcXCJURFxcXCIsXFxcIlRSXFxcIixcXFwiVEFCTEVcXFwiLFxcXCJGT1JNXFxcIl0sYS5GRS5TSU1QTEVfRU5URVJfVEFHUz1bXFxcIlRIXFxcIixcXFwiVERcXFwiLFxcXCJMSVxcXCIsXFxcIkRMXFxcIixcXFwiRFRcXFwiLFxcXCJGT1JNXFxcIl0sYS5GRS5NT0RVTEVTLmN1cnNvcj1mdW5jdGlvbihiKXtmdW5jdGlvbiBjKGEpe3JldHVybiEhYSYmKCEhYi5ub2RlLmlzQmxvY2soYSl8fChhLm5leHRTaWJsaW5nJiZhLm5leHRTaWJsaW5nLm5vZGVUeXBlPT1Ob2RlLlRFWFRfTk9ERSYmMD09PWEubmV4dFNpYmxpbmcudGV4dENvbnRlbnQucmVwbGFjZSgvXFxcXHUyMDBiL2csXFxcIlxcXCIpLmxlbmd0aD9jKGEubmV4dFNpYmxpbmcpOiFhLm5leHRTaWJsaW5nJiZjKGEucGFyZW50Tm9kZSkpKX1mdW5jdGlvbiBkKGEpe3JldHVybiEhYSYmKCEhYi5ub2RlLmlzQmxvY2soYSl8fChhLnByZXZpb3VzU2libGluZyYmYS5wcmV2aW91c1NpYmxpbmcubm9kZVR5cGU9PU5vZGUuVEVYVF9OT0RFJiYwPT09YS5wcmV2aW91c1NpYmxpbmcudGV4dENvbnRlbnQucmVwbGFjZSgvXFxcXHUyMDBiL2csXFxcIlxcXCIpLmxlbmd0aD9kKGEucHJldmlvdXNTaWJsaW5nKTohYS5wcmV2aW91c1NpYmxpbmcmJmQoYS5wYXJlbnROb2RlKSkpfWZ1bmN0aW9uIGUoYSxjKXtyZXR1cm4hIWEmJihhIT1iLiR3cC5nZXQoMCkmJihhLnByZXZpb3VzU2libGluZyYmYS5wcmV2aW91c1NpYmxpbmcubm9kZVR5cGU9PU5vZGUuVEVYVF9OT0RFJiYwPT09YS5wcmV2aW91c1NpYmxpbmcudGV4dENvbnRlbnQucmVwbGFjZSgvXFxcXHUyMDBiL2csXFxcIlxcXCIpLmxlbmd0aD9lKGEucHJldmlvdXNTaWJsaW5nLGMpOiFhLnByZXZpb3VzU2libGluZyYmKGEucGFyZW50Tm9kZT09Y3x8ZShhLnBhcmVudE5vZGUsYykpKSl9ZnVuY3Rpb24gZihhLGMpe3JldHVybiEhYSYmKGEhPWIuJHdwLmdldCgwKSYmKGEubmV4dFNpYmxpbmcmJmEubmV4dFNpYmxpbmcubm9kZVR5cGU9PU5vZGUuVEVYVF9OT0RFJiYwPT09YS5uZXh0U2libGluZy50ZXh0Q29udGVudC5yZXBsYWNlKC9cXFxcdTIwMGIvZyxcXFwiXFxcIikubGVuZ3RoP2YoYS5uZXh0U2libGluZyxjKTohYS5uZXh0U2libGluZyYmKGEucGFyZW50Tm9kZT09Y3x8ZihhLnBhcmVudE5vZGUsYykpKSl9ZnVuY3Rpb24gZyhjKXtyZXR1cm4gYShjKS5wYXJlbnRzVW50aWwoYi4kZWwsXFxcIkxJXFxcIikubGVuZ3RoPjAmJjA9PT1hKGMpLnBhcmVudHNVbnRpbChcXFwiTElcXFwiLFxcXCJUQUJMRVxcXCIpLmxlbmd0aH1mdW5jdGlvbiBoKGMpe3ZhciBkPWEoYykucGFyZW50c1VudGlsKGIuJGVsLFxcXCJCTE9DS1FVT1RFXFxcIikubGVuZ3RoPjAsZT1iLm5vZGUuZGVlcGVzdFBhcmVudChjLFtdLCFkKTtpZihlJiZcXFwiQkxPQ0tRVU9URVxcXCI9PWUudGFnTmFtZSl7dmFyIGY9Yi5ub2RlLmRlZXBlc3RQYXJlbnQoYyxbYShjKS5wYXJlbnRzVW50aWwoYi4kZWwsXFxcIkJMT0NLUVVPVEVcXFwiKS5nZXQoMCldKTtmJiZmLnByZXZpb3VzU2libGluZyYmKGU9Zil9aWYobnVsbCE9PWUpe3ZhciBnLGg9ZS5wcmV2aW91c1NpYmxpbmc7aWYoYi5ub2RlLmlzQmxvY2soZSkmJmIubm9kZS5pc0VkaXRhYmxlKGUpJiZoJiZhLkZFLk5PX0RFTEVURV9UQUdTLmluZGV4T2YoaC50YWdOYW1lKTwwKWlmKGIubm9kZS5pc0RlbGV0YWJsZShoKSlhKGgpLnJlbW92ZSgpLGEoYykucmVwbGFjZVdpdGgoYS5GRS5NQVJLRVJTKTtlbHNlIGlmKGIubm9kZS5pc0VkaXRhYmxlKGgpKWlmKGIubm9kZS5pc0Jsb2NrKGgpKWlmKGIubm9kZS5pc0VtcHR5KGgpJiYhYi5ub2RlLmlzTGlzdChoKSlhKGgpLnJlbW92ZSgpO2Vsc2V7aWYoYi5ub2RlLmlzTGlzdChoKSYmKGg9YShoKS5maW5kKFxcXCJsaTpsYXN0XFxcIikuZ2V0KDApKSxnPWIubm9kZS5jb250ZW50cyhoKSxnLmxlbmd0aCYmXFxcIkJSXFxcIj09Z1tnLmxlbmd0aC0xXS50YWdOYW1lJiZhKGdbZy5sZW5ndGgtMV0pLnJlbW92ZSgpLFxcXCJCTE9DS1FVT1RFXFxcIj09aC50YWdOYW1lJiZcXFwiQkxPQ0tRVU9URVxcXCIhPWUudGFnTmFtZSlmb3IoZz1iLm5vZGUuY29udGVudHMoaCk7Zy5sZW5ndGgmJmIubm9kZS5pc0Jsb2NrKGdbZy5sZW5ndGgtMV0pOyloPWdbZy5sZW5ndGgtMV0sZz1iLm5vZGUuY29udGVudHMoaCk7ZWxzZSBpZihcXFwiQkxPQ0tRVU9URVxcXCIhPWgudGFnTmFtZSYmXFxcIkJMT0NLUVVPVEVcXFwiPT1lLnRhZ05hbWUpZm9yKGc9Yi5ub2RlLmNvbnRlbnRzKGUpO2cubGVuZ3RoJiZiLm5vZGUuaXNCbG9jayhnWzBdKTspZT1nWzBdLGc9Yi5ub2RlLmNvbnRlbnRzKGUpO2EoYykucmVwbGFjZVdpdGgoYS5GRS5NQVJLRVJTKSxhKGgpLmFwcGVuZChiLm5vZGUuaXNFbXB0eShlKT9hLkZFLk1BUktFUlM6ZS5pbm5lckhUTUwpLGEoZSkucmVtb3ZlKCl9ZWxzZSBhKGMpLnJlcGxhY2VXaXRoKGEuRkUuTUFSS0VSUyksXFxcIkJMT0NLUVVPVEVcXFwiPT1lLnRhZ05hbWUmJmgubm9kZVR5cGU9PU5vZGUuRUxFTUVOVF9OT0RFP2EoaCkucmVtb3ZlKCk6KGEoaCkuYWZ0ZXIoYi5ub2RlLmlzRW1wdHkoZSk/XFxcIlxcXCI6YShlKS5odG1sKCkpLGEoZSkucmVtb3ZlKCksXFxcIkJSXFxcIj09aC50YWdOYW1lJiZhKGgpLnJlbW92ZSgpKX19ZnVuY3Rpb24gaShjKXtmb3IodmFyIGQ9YzshZC5wcmV2aW91c1NpYmxpbmc7KWlmKGQ9ZC5wYXJlbnROb2RlLGIubm9kZS5pc0VsZW1lbnQoZCkpcmV0dXJuITE7ZD1kLnByZXZpb3VzU2libGluZzt2YXIgZTtpZighYi5ub2RlLmlzQmxvY2soZCkmJmIubm9kZS5pc0VkaXRhYmxlKGQpKXtmb3IoZT1iLm5vZGUuY29udGVudHMoZCk7ZC5ub2RlVHlwZSE9Tm9kZS5URVhUX05PREUmJiFiLm5vZGUuaXNEZWxldGFibGUoZCkmJmUubGVuZ3RoJiZiLm5vZGUuaXNFZGl0YWJsZShkKTspZD1lW2UubGVuZ3RoLTFdLGU9Yi5ub2RlLmNvbnRlbnRzKGQpO2lmKGQubm9kZVR5cGU9PU5vZGUuVEVYVF9OT0RFKXtpZihiLmhlbHBlcnMuaXNJT1MoKSlyZXR1cm4hMDt2YXIgZj1kLnRleHRDb250ZW50LGc9Zi5sZW5ndGgtMTtpZihiLm9wdHMudGFiU3BhY2VzJiZmLmxlbmd0aD49Yi5vcHRzLnRhYlNwYWNlcyl7dmFyIGg9Zi5zdWJzdHIoZi5sZW5ndGgtYi5vcHRzLnRhYlNwYWNlcyxmLmxlbmd0aC0xKTswPT09aC5yZXBsYWNlKC8gL2csXFxcIlxcXCIpLnJlcGxhY2UobmV3IFJlZ0V4cChhLkZFLlVOSUNPREVfTkJTUCxcXFwiZ1xcXCIpLFxcXCJcXFwiKS5sZW5ndGgmJihnPWYubGVuZ3RoLWIub3B0cy50YWJTcGFjZXMpfWQudGV4dENvbnRlbnQ9Zi5zdWJzdHJpbmcoMCxnKSxkLnRleHRDb250ZW50Lmxlbmd0aCYmNTUzNTc9PWQudGV4dENvbnRlbnQuY2hhckNvZGVBdChkLnRleHRDb250ZW50Lmxlbmd0aC0xKSYmKGQudGV4dENvbnRlbnQ9ZC50ZXh0Q29udGVudC5zdWJzdHIoMCxkLnRleHRDb250ZW50Lmxlbmd0aC0xKSk7dmFyIGk9Zi5sZW5ndGghPWQudGV4dENvbnRlbnQubGVuZ3RoOzA9PT1kLnRleHRDb250ZW50Lmxlbmd0aD9pJiZiLm9wdHMua2VlcEZvcm1hdE9uRGVsZXRlP2EoZCkuYWZ0ZXIoYS5GRS5JTlZJU0lCTEVfU1BBQ0UrYS5GRS5NQVJLRVJTKToyIT1kLnBhcmVudE5vZGUuY2hpbGROb2Rlcy5sZW5ndGh8fGQucGFyZW50Tm9kZSE9Yy5wYXJlbnROb2RlfHxiLm5vZGUuaXNCbG9jayhkLnBhcmVudE5vZGUpfHxiLm5vZGUuaXNFbGVtZW50KGQucGFyZW50Tm9kZSk/KGEoZCkuYWZ0ZXIoYS5GRS5NQVJLRVJTKSxiLm5vZGUuaXNFbGVtZW50KGQucGFyZW50Tm9kZSkmJiFjLm5leHRTaWJsaW5nJiZkLnByZXZpb3VzU2libGluZyYmXFxcIkJSXFxcIj09ZC5wcmV2aW91c1NpYmxpbmcudGFnTmFtZSYmYShjKS5hZnRlcihcXFwiPGJyPlxcXCIpLGQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChkKSk6KGEoZC5wYXJlbnROb2RlKS5hZnRlcihhLkZFLk1BUktFUlMpLGEoZC5wYXJlbnROb2RlKS5yZW1vdmUoKSk6YShkKS5hZnRlcihhLkZFLk1BUktFUlMpfWVsc2UgYi5ub2RlLmlzRGVsZXRhYmxlKGQpPyhhKGQpLmFmdGVyKGEuRkUuTUFSS0VSUyksYShkKS5yZW1vdmUoKSk6Yy5uZXh0U2libGluZyYmXFxcIkJSXFxcIj09Yy5uZXh0U2libGluZy50YWdOYW1lJiZiLm5vZGUuaXNWb2lkKGQpJiZcXFwiQlJcXFwiIT1kLnRhZ05hbWU/KGEoYy5uZXh0U2libGluZykucmVtb3ZlKCksYShjKS5yZXBsYWNlV2l0aChhLkZFLk1BUktFUlMpKTpiLmV2ZW50cy50cmlnZ2VyKFxcXCJub2RlLnJlbW92ZVxcXCIsW2EoZCldKSE9PSExJiYoYShkKS5hZnRlcihhLkZFLk1BUktFUlMpLGEoZCkucmVtb3ZlKCkpfWVsc2UgaWYoYS5GRS5OT19ERUxFVEVfVEFHUy5pbmRleE9mKGQudGFnTmFtZSk8MCYmKGIubm9kZS5pc0VkaXRhYmxlKGQpfHxiLm5vZGUuaXNEZWxldGFibGUoZCkpKWlmKGIubm9kZS5pc0RlbGV0YWJsZShkKSlhKGMpLnJlcGxhY2VXaXRoKGEuRkUuTUFSS0VSUyksYShkKS5yZW1vdmUoKTtlbHNlIGlmKGIubm9kZS5pc0VtcHR5KGQpJiYhYi5ub2RlLmlzTGlzdChkKSlhKGQpLnJlbW92ZSgpLGEoYykucmVwbGFjZVdpdGgoYS5GRS5NQVJLRVJTKTtlbHNle2ZvcihiLm5vZGUuaXNMaXN0KGQpJiYoZD1hKGQpLmZpbmQoXFxcImxpOmxhc3RcXFwiKS5nZXQoMCkpLGU9Yi5ub2RlLmNvbnRlbnRzKGQpLGUmJlxcXCJCUlxcXCI9PWVbZS5sZW5ndGgtMV0udGFnTmFtZSYmYShlW2UubGVuZ3RoLTFdKS5yZW1vdmUoKSxlPWIubm9kZS5jb250ZW50cyhkKTtlJiZiLm5vZGUuaXNCbG9jayhlW2UubGVuZ3RoLTFdKTspZD1lW2UubGVuZ3RoLTFdLGU9Yi5ub2RlLmNvbnRlbnRzKGQpO2EoZCkuYXBwZW5kKGEuRkUuTUFSS0VSUyk7Zm9yKHZhciBqPWM7IWoucHJldmlvdXNTaWJsaW5nOylqPWoucGFyZW50Tm9kZTtmb3IoO2omJlxcXCJCUlxcXCIhPT1qLnRhZ05hbWUmJiFiLm5vZGUuaXNCbG9jayhqKTspe3ZhciBrPWo7aj1qLm5leHRTaWJsaW5nLGEoZCkuYXBwZW5kKGspfWomJlxcXCJCUlxcXCI9PWoudGFnTmFtZSYmYShqKS5yZW1vdmUoKSxhKGMpLnJlbW92ZSgpfWVsc2UgYy5uZXh0U2libGluZyYmXFxcIkJSXFxcIj09Yy5uZXh0U2libGluZy50YWdOYW1lJiZhKGMubmV4dFNpYmxpbmcpLnJlbW92ZSgpfWZ1bmN0aW9uIGooKXt2YXIgZj0hMSxqPWIubWFya2Vycy5pbnNlcnQoKTtpZighailyZXR1cm4hMDtmb3IodmFyIGs9ai5wYXJlbnROb2RlO2smJiFiLm5vZGUuaXNFbGVtZW50KGspOyl7aWYoXFxcImZhbHNlXFxcIj09PWsuZ2V0QXR0cmlidXRlKFxcXCJjb250ZW50ZWRpdGFibGVcXFwiKSlyZXR1cm4gYShqKS5yZXBsYWNlV2l0aChhLkZFLk1BUktFUlMpLGIuc2VsZWN0aW9uLnJlc3RvcmUoKSwhMTtpZihcXFwidHJ1ZVxcXCI9PT1rLmdldEF0dHJpYnV0ZShcXFwiY29udGVudGVkaXRhYmxlXFxcIikpYnJlYWs7az1rLnBhcmVudE5vZGV9Yi5lbC5ub3JtYWxpemUoKTt2YXIgbD1qLnByZXZpb3VzU2libGluZztpZihsKXt2YXIgbT1sLnRleHRDb250ZW50O20mJm0ubGVuZ3RoJiY4MjAzPT1tLmNoYXJDb2RlQXQobS5sZW5ndGgtMSkmJigxPT1tLmxlbmd0aD9hKGwpLnJlbW92ZSgpOihsLnRleHRDb250ZW50PWwudGV4dENvbnRlbnQuc3Vic3RyKDAsbS5sZW5ndGgtMSksbC50ZXh0Q29udGVudC5sZW5ndGgmJjU1MzU3PT1sLnRleHRDb250ZW50LmNoYXJDb2RlQXQobC50ZXh0Q29udGVudC5sZW5ndGgtMSkmJihsLnRleHRDb250ZW50PWwudGV4dENvbnRlbnQuc3Vic3RyKDAsbC50ZXh0Q29udGVudC5sZW5ndGgtMSkpKSl9cmV0dXJuIGMoaik/Zj1pKGopOmQoaik/ZyhqKSYmZShqLGEoaikucGFyZW50cyhcXFwibGk6Zmlyc3RcXFwiKS5nZXQoMCkpP2IuY3Vyc29yTGlzdHMuX2JhY2tzcGFjZShqKTpoKGopOmY9aShqKSxhKGopLnJlbW92ZSgpLG4oKSxiLmh0bWwuZmlsbEVtcHR5QmxvY2tzKCEwKSxiLm9wdHMuaHRtbFVudG91Y2hlZHx8KGIuaHRtbC5jbGVhbkVtcHR5VGFncygpLGIuY2xlYW4ucXVvdGVzKCksYi5jbGVhbi5saXN0cygpKSxiLnNwYWNlcy5ub3JtYWxpemVBcm91bmRDdXJzb3IoKSxiLnNlbGVjdGlvbi5yZXN0b3JlKCksZn1mdW5jdGlvbiBrKGMpe3ZhciBkPWEoYykucGFyZW50c1VudGlsKGIuJGVsLFxcXCJCTE9DS1FVT1RFXFxcIikubGVuZ3RoPjAsZT1iLm5vZGUuZGVlcGVzdFBhcmVudChjLFtdLCFkKTtpZihlJiZcXFwiQkxPQ0tRVU9URVxcXCI9PWUudGFnTmFtZSl7dmFyIGY9Yi5ub2RlLmRlZXBlc3RQYXJlbnQoYyxbYShjKS5wYXJlbnRzVW50aWwoYi4kZWwsXFxcIkJMT0NLUVVPVEVcXFwiKS5nZXQoMCldKTtmJiZmLm5leHRTaWJsaW5nJiYoZT1mKX1pZihudWxsIT09ZSl7dmFyIGcsaD1lLm5leHRTaWJsaW5nO2lmKGIubm9kZS5pc0Jsb2NrKGUpJiYoYi5ub2RlLmlzRWRpdGFibGUoZSl8fGIubm9kZS5pc0RlbGV0YWJsZShlKSkmJmgmJmEuRkUuTk9fREVMRVRFX1RBR1MuaW5kZXhPZihoLnRhZ05hbWUpPDApaWYoYi5ub2RlLmlzRGVsZXRhYmxlKGgpKWEoaCkucmVtb3ZlKCksYShjKS5yZXBsYWNlV2l0aChhLkZFLk1BUktFUlMpO2Vsc2UgaWYoYi5ub2RlLmlzQmxvY2soaCkmJmIubm9kZS5pc0VkaXRhYmxlKGgpKWlmKGIubm9kZS5pc0xpc3QoaCkpaWYoYi5ub2RlLmlzRW1wdHkoZSwhMCkpYShlKS5yZW1vdmUoKSxhKGgpLmZpbmQoXFxcImxpOmZpcnN0XFxcIikucHJlcGVuZChhLkZFLk1BUktFUlMpO2Vsc2V7dmFyIGk9YShoKS5maW5kKFxcXCJsaTpmaXJzdFxcXCIpO1xcXCJCTE9DS1FVT1RFXFxcIj09ZS50YWdOYW1lJiYoZz1iLm5vZGUuY29udGVudHMoZSksZy5sZW5ndGgmJmIubm9kZS5pc0Jsb2NrKGdbZy5sZW5ndGgtMV0pJiYoZT1nW2cubGVuZ3RoLTFdKSksMD09PWkuZmluZChcXFwidWwsIG9sXFxcIikubGVuZ3RoJiYoYShjKS5yZXBsYWNlV2l0aChhLkZFLk1BUktFUlMpLGkuZmluZChiLmh0bWwuYmxvY2tUYWdzUXVlcnkoKSkubm90KFxcXCJvbCwgdWwsIHRhYmxlXFxcIikuZWFjaChmdW5jdGlvbigpe3RoaXMucGFyZW50Tm9kZT09aS5nZXQoMCkmJmEodGhpcykucmVwbGFjZVdpdGgoYSh0aGlzKS5odG1sKCkrKGIubm9kZS5pc0VtcHR5KHRoaXMpP1xcXCJcXFwiOlxcXCI8YnI+XFxcIikpfSksYShlKS5hcHBlbmQoYi5ub2RlLmNvbnRlbnRzKGkuZ2V0KDApKSksaS5yZW1vdmUoKSwwPT09YShoKS5maW5kKFxcXCJsaVxcXCIpLmxlbmd0aCYmYShoKS5yZW1vdmUoKSl9ZWxzZXtpZihnPWIubm9kZS5jb250ZW50cyhoKSxnLmxlbmd0aCYmXFxcIkJSXFxcIj09Z1swXS50YWdOYW1lJiZhKGdbMF0pLnJlbW92ZSgpLFxcXCJCTE9DS1FVT1RFXFxcIiE9aC50YWdOYW1lJiZcXFwiQkxPQ0tRVU9URVxcXCI9PWUudGFnTmFtZSlmb3IoZz1iLm5vZGUuY29udGVudHMoZSk7Zy5sZW5ndGgmJmIubm9kZS5pc0Jsb2NrKGdbZy5sZW5ndGgtMV0pOyllPWdbZy5sZW5ndGgtMV0sZz1iLm5vZGUuY29udGVudHMoZSk7ZWxzZSBpZihcXFwiQkxPQ0tRVU9URVxcXCI9PWgudGFnTmFtZSYmXFxcIkJMT0NLUVVPVEVcXFwiIT1lLnRhZ05hbWUpZm9yKGc9Yi5ub2RlLmNvbnRlbnRzKGgpO2cubGVuZ3RoJiZiLm5vZGUuaXNCbG9jayhnWzBdKTspaD1nWzBdLGc9Yi5ub2RlLmNvbnRlbnRzKGgpO2EoYykucmVwbGFjZVdpdGgoYS5GRS5NQVJLRVJTKSxhKGUpLmFwcGVuZChoLmlubmVySFRNTCksYShoKS5yZW1vdmUoKX1lbHNle2ZvcihhKGMpLnJlcGxhY2VXaXRoKGEuRkUuTUFSS0VSUyk7aCYmXFxcIkJSXFxcIiE9PWgudGFnTmFtZSYmIWIubm9kZS5pc0Jsb2NrKGgpJiZiLm5vZGUuaXNFZGl0YWJsZShoKTspe3ZhciBqPWg7aD1oLm5leHRTaWJsaW5nLGEoZSkuYXBwZW5kKGopfWgmJlxcXCJCUlxcXCI9PWgudGFnTmFtZSYmYi5ub2RlLmlzRWRpdGFibGUoaCkmJmEoaCkucmVtb3ZlKCl9fX1mdW5jdGlvbiBsKGQpe2Zvcih2YXIgZT1kOyFlLm5leHRTaWJsaW5nOylpZihlPWUucGFyZW50Tm9kZSxiLm5vZGUuaXNFbGVtZW50KGUpKXJldHVybiExO2lmKGU9ZS5uZXh0U2libGluZyxcXFwiQlJcXFwiPT1lLnRhZ05hbWUmJmIubm9kZS5pc0VkaXRhYmxlKGUpKWlmKGUubmV4dFNpYmxpbmcpe2lmKGIubm9kZS5pc0Jsb2NrKGUubmV4dFNpYmxpbmcpJiZiLm5vZGUuaXNFZGl0YWJsZShlLm5leHRTaWJsaW5nKSl7aWYoIShhLkZFLk5PX0RFTEVURV9UQUdTLmluZGV4T2YoZS5uZXh0U2libGluZy50YWdOYW1lKTwwKSlyZXR1cm4gdm9pZCBhKGUpLnJlbW92ZSgpO2U9ZS5uZXh0U2libGluZyxhKGUucHJldmlvdXNTaWJsaW5nKS5yZW1vdmUoKX19ZWxzZSBpZihjKGUpKXtpZihnKGQpKWIuY3Vyc29yTGlzdHMuX2RlbChkKTtlbHNle3ZhciBmPWIubm9kZS5kZWVwZXN0UGFyZW50KGUpO2YmJigoIWIubm9kZS5pc0VtcHR5KGIubm9kZS5ibG9ja1BhcmVudChlKSl8fChiLm5vZGUuYmxvY2tQYXJlbnQoZSkubmV4dFNpYmxpbmcmJmEuRkUuTk9fREVMRVRFX1RBR1MuaW5kZXhPZihiLm5vZGUuYmxvY2tQYXJlbnQoZSkubmV4dFNpYmxpbmcudGFnTmFtZSkpPDApJiZhKGUpLnJlbW92ZSgpLGsoZCkpfXJldHVybn12YXIgaDtpZighYi5ub2RlLmlzQmxvY2soZSkmJmIubm9kZS5pc0VkaXRhYmxlKGUpKXtmb3IoaD1iLm5vZGUuY29udGVudHMoZSk7ZS5ub2RlVHlwZSE9Tm9kZS5URVhUX05PREUmJmgubGVuZ3RoJiYhYi5ub2RlLmlzRGVsZXRhYmxlKGUpJiZiLm5vZGUuaXNFZGl0YWJsZShlKTspZT1oWzBdLGg9Yi5ub2RlLmNvbnRlbnRzKGUpO2Uubm9kZVR5cGU9PU5vZGUuVEVYVF9OT0RFPyhhKGUpLmJlZm9yZShhLkZFLk1BUktFUlMpLGUudGV4dENvbnRlbnQubGVuZ3RoJiY1NTM1Nz09ZS50ZXh0Q29udGVudC5jaGFyQ29kZUF0KDApP2UudGV4dENvbnRlbnQ9ZS50ZXh0Q29udGVudC5zdWJzdHJpbmcoMixlLnRleHRDb250ZW50Lmxlbmd0aCk6ZS50ZXh0Q29udGVudD1lLnRleHRDb250ZW50LnN1YnN0cmluZygxLGUudGV4dENvbnRlbnQubGVuZ3RoKSk6Yi5ub2RlLmlzRGVsZXRhYmxlKGUpPyhhKGUpLmJlZm9yZShhLkZFLk1BUktFUlMpLGEoZSkucmVtb3ZlKCkpOmIuZXZlbnRzLnRyaWdnZXIoXFxcIm5vZGUucmVtb3ZlXFxcIixbYShlKV0pIT09ITEmJihhKGUpLmJlZm9yZShhLkZFLk1BUktFUlMpLGEoZSkucmVtb3ZlKCkpLGEoZCkucmVtb3ZlKCl9ZWxzZSBpZihhLkZFLk5PX0RFTEVURV9UQUdTLmluZGV4T2YoZS50YWdOYW1lKTwwJiYoYi5ub2RlLmlzRWRpdGFibGUoZSl8fGIubm9kZS5pc0RlbGV0YWJsZShlKSkpaWYoYi5ub2RlLmlzRGVsZXRhYmxlKGUpKWEoZCkucmVwbGFjZVdpdGgoYS5GRS5NQVJLRVJTKSxhKGUpLnJlbW92ZSgpO2Vsc2UgaWYoYi5ub2RlLmlzTGlzdChlKSlkLnByZXZpb3VzU2libGluZz8oYShlKS5maW5kKFxcXCJsaTpmaXJzdFxcXCIpLnByZXBlbmQoZCksYi5jdXJzb3JMaXN0cy5fYmFja3NwYWNlKGQpKTooYShlKS5maW5kKFxcXCJsaTpmaXJzdFxcXCIpLnByZXBlbmQoYS5GRS5NQVJLRVJTKSxhKGQpLnJlbW92ZSgpKTtlbHNlIGlmKGg9Yi5ub2RlLmNvbnRlbnRzKGUpLGgmJlxcXCJCUlxcXCI9PWhbMF0udGFnTmFtZSYmYShoWzBdKS5yZW1vdmUoKSxoJiZcXFwiQkxPQ0tRVU9URVxcXCI9PWUudGFnTmFtZSl7dmFyIGk9aFswXTtmb3IoYShkKS5iZWZvcmUoYS5GRS5NQVJLRVJTKTtpJiZcXFwiQlJcXFwiIT1pLnRhZ05hbWU7KXt2YXIgaj1pO2k9aS5uZXh0U2libGluZyxhKGQpLmJlZm9yZShqKX1pJiZcXFwiQlJcXFwiPT1pLnRhZ05hbWUmJmEoaSkucmVtb3ZlKCl9ZWxzZSBhKGQpLmFmdGVyKGEoZSkuaHRtbCgpKS5hZnRlcihhLkZFLk1BUktFUlMpLGEoZSkucmVtb3ZlKCl9ZnVuY3Rpb24gbSgpe3ZhciBlPWIubWFya2Vycy5pbnNlcnQoKTtpZighZSlyZXR1cm4hMTtpZihiLmVsLm5vcm1hbGl6ZSgpLGMoZSkpaWYoZyhlKSlpZigwPT09YShlKS5wYXJlbnRzKFxcXCJsaTpmaXJzdFxcXCIpLmZpbmQoXFxcInVsLCBvbFxcXCIpLmxlbmd0aCliLmN1cnNvckxpc3RzLl9kZWwoZSk7ZWxzZXt2YXIgZj1hKGUpLnBhcmVudHMoXFxcImxpOmZpcnN0XFxcIikuZmluZChcXFwidWw6Zmlyc3QsIG9sOmZpcnN0XFxcIikuZmluZChcXFwibGk6Zmlyc3RcXFwiKTtmPWYuZmluZChiLmh0bWwuYmxvY2tUYWdzUXVlcnkoKSkuZ2V0KC0xKXx8ZixmLnByZXBlbmQoZSksYi5jdXJzb3JMaXN0cy5fYmFja3NwYWNlKGUpfWVsc2UgayhlKTtlbHNlIGwoZChlKT9lOmUpO2EoZSkucmVtb3ZlKCksbigpLGIuaHRtbC5maWxsRW1wdHlCbG9ja3MoITApLGIub3B0cy5odG1sVW50b3VjaGVkfHwoYi5odG1sLmNsZWFuRW1wdHlUYWdzKCksYi5jbGVhbi5xdW90ZXMoKSxiLmNsZWFuLmxpc3RzKCkpLGIuc3BhY2VzLm5vcm1hbGl6ZUFyb3VuZEN1cnNvcigpLGIuc2VsZWN0aW9uLnJlc3RvcmUoKX1mdW5jdGlvbiBuKCl7Zm9yKHZhciBhPWIuZWwucXVlcnlTZWxlY3RvckFsbChcXFwiYmxvY2txdW90ZTplbXB0eVxcXCIpLGM9MDtjPGEubGVuZ3RoO2MrKylhW2NdLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoYVtjXSl9ZnVuY3Rpb24gbygpe2IuJGVsLmZpbmQoXFxcIi5mci10by1yZW1vdmVcXFwiKS5lYWNoKGZ1bmN0aW9uKCl7Zm9yKHZhciBjPWIubm9kZS5jb250ZW50cyh0aGlzKSxkPTA7ZDxjLmxlbmd0aDtkKyspY1tkXS5ub2RlVHlwZT09Tm9kZS5URVhUX05PREUmJihjW2RdLnRleHRDb250ZW50PWNbZF0udGV4dENvbnRlbnQucmVwbGFjZSgvXFxcXHUyMDBCL2csXFxcIlxcXCIpKTthKHRoaXMpLnJlcGxhY2VXaXRoKHRoaXMuaW5uZXJIVE1MKX0pfWZ1bmN0aW9uIHAoYyxkLGUpe3ZhciBnLGg9Yi5ub2RlLmRlZXBlc3RQYXJlbnQoYyxbXSwhZSk7aWYoaCYmXFxcIkJMT0NLUVVPVEVcXFwiPT1oLnRhZ05hbWUpcmV0dXJuIGYoYyxoKT8oZz1iLmh0bWwuZGVmYXVsdFRhZygpLGc/YShoKS5hZnRlcihcXFwiPFxcXCIrZytcXFwiPlxcXCIrYS5GRS5NQVJLRVJTK1xcXCI8YnI+PC9cXFwiK2crXFxcIj5cXFwiKTphKGgpLmFmdGVyKGEuRkUuTUFSS0VSUytcXFwiPGJyPlxcXCIpLGEoYykucmVtb3ZlKCksITEpOihyKGMsZCxlKSwhMSk7aWYobnVsbD09aClnPWIuaHRtbC5kZWZhdWx0VGFnKCksZyYmYi5ub2RlLmlzRWxlbWVudChjLnBhcmVudE5vZGUpP2EoYykucmVwbGFjZVdpdGgoXFxcIjxcXFwiK2crXFxcIj5cXFwiK2EuRkUuTUFSS0VSUytcXFwiPGJyPjwvXFxcIitnK1xcXCI+XFxcIik6YShjKS5yZXBsYWNlV2l0aCgoYi5ub2RlLmlzRW1wdHkoYy5wYXJlbnROb2RlLCEwKT9cXFwiXFxcIjpcXFwiPGJyLz5cXFwiKSthLkZFLk1BUktFUlMrXFxcIjxici8+XFxcIik7ZWxzZXt2YXIgaT1jLGo9XFxcIlxcXCI7Yi5ub2RlLmlzQmxvY2soaCkmJiFkfHwoaj1cXFwiPGJyLz5cXFwiKTt2YXIgaz1cXFwiXFxcIixsPVxcXCJcXFwiO2c9Yi5odG1sLmRlZmF1bHRUYWcoKTt2YXIgbT1cXFwiXFxcIixuPVxcXCJcXFwiO2cmJmIubm9kZS5pc0Jsb2NrKGgpJiYobT1cXFwiPFxcXCIrZytcXFwiPlxcXCIsbj1cXFwiPC9cXFwiK2crXFxcIj5cXFwiLGgudGFnTmFtZT09Zy50b1VwcGVyQ2FzZSgpJiYobT1iLm5vZGUub3BlblRhZ1N0cmluZyhhKGgpLmNsb25lKCkucmVtb3ZlQXR0cihcXFwiaWRcXFwiKS5nZXQoMCkpKSk7ZG8gaWYoaT1pLnBhcmVudE5vZGUsIWR8fGkhPWh8fGQmJiFiLm5vZGUuaXNCbG9jayhoKSlpZihrKz1iLm5vZGUuY2xvc2VUYWdTdHJpbmcoaSksaT09aCYmYi5ub2RlLmlzQmxvY2soaCkpbD1tK2w7ZWxzZXt2YXIgbz1cXFwiQVxcXCI9PWkudGFnTmFtZSYmZihjLGkpP1xcXCJmci10by1yZW1vdmVcXFwiOlxcXCJcXFwiO2w9Yi5ub2RlLm9wZW5UYWdTdHJpbmcoYShpKS5jbG9uZSgpLmFkZENsYXNzKG8pLmdldCgwKSkrbH13aGlsZShpIT1oKTtqPWsraitsKyhjLnBhcmVudE5vZGU9PWgmJmIubm9kZS5pc0Jsb2NrKGgpP1xcXCJcXFwiOmEuRkUuSU5WSVNJQkxFX1NQQUNFKSthLkZFLk1BUktFUlMsYi5ub2RlLmlzQmxvY2soaCkmJiFhKGgpLmZpbmQoXFxcIio6bGFzdFxcXCIpLmlzKFxcXCJiclxcXCIpJiZhKGgpLmFwcGVuZChcXFwiPGJyLz5cXFwiKSxhKGMpLmFmdGVyKCc8c3BhbiBpZD1cXFwiZnItYnJlYWtcXFwiPjwvc3Bhbj4nKSxhKGMpLnJlbW92ZSgpLGgubmV4dFNpYmxpbmcmJiFiLm5vZGUuaXNCbG9jayhoLm5leHRTaWJsaW5nKXx8Yi5ub2RlLmlzQmxvY2soaCl8fGEoaCkuYWZ0ZXIoXFxcIjxicj5cXFwiKTt2YXIgcDtwPSFkJiZiLm5vZGUuaXNCbG9jayhoKT9iLm5vZGUub3BlblRhZ1N0cmluZyhoKSthKGgpLmh0bWwoKStuOmIubm9kZS5vcGVuVGFnU3RyaW5nKGgpK2EoaCkuaHRtbCgpK2Iubm9kZS5jbG9zZVRhZ1N0cmluZyhoKSxwPXAucmVwbGFjZSgvPHNwYW4gaWQ9XFxcImZyLWJyZWFrXFxcIj48XFxcXC9zcGFuPi9nLGopLGEoaCkucmVwbGFjZVdpdGgocCl9fWZ1bmN0aW9uIHEoYyxkLGcpe3ZhciBoLGk9Yi5ub2RlLmRlZXBlc3RQYXJlbnQoYyxbXSwhZyk7aWYoaSYmXFxcIlRBQkxFXFxcIj09aS50YWdOYW1lKXJldHVybiBhKGkpLmZpbmQoXFxcInRkOmZpcnN0LCB0aDpmaXJzdFxcXCIpLnByZXBlbmQoYykscShjLGQsZyk7aWYoaSYmXFxcIkJMT0NLUVVPVEVcXFwiPT1pLnRhZ05hbWUpe2lmKGUoYyxpKSlyZXR1cm4gaD1iLmh0bWwuZGVmYXVsdFRhZygpLGg/YShpKS5iZWZvcmUoXFxcIjxcXFwiK2grXFxcIj5cXFwiK2EuRkUuTUFSS0VSUytcXFwiPGJyPjwvXFxcIitoK1xcXCI+XFxcIik6YShpKS5iZWZvcmUoYS5GRS5NQVJLRVJTK1xcXCI8YnI+XFxcIiksYShjKS5yZW1vdmUoKSwhMTtmKGMsaSk/cChjLGQsITApOnIoYyxkLCEwKX1pZihudWxsPT1pKWg9Yi5odG1sLmRlZmF1bHRUYWcoKSxoJiZiLm5vZGUuaXNFbGVtZW50KGMucGFyZW50Tm9kZSk/YShjKS5yZXBsYWNlV2l0aChcXFwiPFxcXCIraCtcXFwiPlxcXCIrYS5GRS5NQVJLRVJTK1xcXCI8YnI+PC9cXFwiK2grXFxcIj5cXFwiKTphKGMpLnJlcGxhY2VXaXRoKFxcXCI8YnI+XFxcIithLkZFLk1BUktFUlMpO2Vsc2V7aWYoYi5ub2RlLmlzQmxvY2soaSkpaWYoZClhKGMpLnJlbW92ZSgpLGEoaSkucHJlcGVuZChcXFwiPGJyPlxcXCIrYS5GRS5NQVJLRVJTKTtlbHNle2lmKGIubm9kZS5pc0VtcHR5KGksITApKXJldHVybiBwKGMsZCxnKTthKGkpLmJlZm9yZShiLm5vZGUub3BlblRhZ1N0cmluZyhhKGkpLmNsb25lKCkucmVtb3ZlQXR0cihcXFwiaWRcXFwiKS5nZXQoMCkpK1xcXCI8YnI+XFxcIitiLm5vZGUuY2xvc2VUYWdTdHJpbmcoaSkpfWVsc2UgYShpKS5iZWZvcmUoXFxcIjxicj5cXFwiKTthKGMpLnJlbW92ZSgpfX1mdW5jdGlvbiByKGMsZCxnKXt2YXIgaD1iLm5vZGUuZGVlcGVzdFBhcmVudChjLFtdLCFnKTtpZihudWxsPT1oKWIuaHRtbC5kZWZhdWx0VGFnKCkmJmMucGFyZW50Tm9kZT09PWIuZWw/YShjKS5yZXBsYWNlV2l0aChcXFwiPFxcXCIrYi5odG1sLmRlZmF1bHRUYWcoKStcXFwiPlxcXCIrYS5GRS5NQVJLRVJTK1xcXCI8YnI+PC9cXFwiK2IuaHRtbC5kZWZhdWx0VGFnKCkrXFxcIj5cXFwiKTooYy5uZXh0U2libGluZyYmIWIubm9kZS5pc0Jsb2NrKGMubmV4dFNpYmxpbmcpfHxhKGMpLmFmdGVyKFxcXCI8YnI+XFxcIiksYShjKS5yZXBsYWNlV2l0aChcXFwiPGJyPlxcXCIrYS5GRS5NQVJLRVJTKSk7ZWxzZXt2YXIgaT1jLGo9XFxcIlxcXCI7XFxcIlBSRVxcXCI9PWgudGFnTmFtZSYmKGQ9ITApLGIubm9kZS5pc0Jsb2NrKGgpJiYhZHx8KGo9XFxcIjxicj5cXFwiKTt2YXIgaz1cXFwiXFxcIixsPVxcXCJcXFwiO2Rve3ZhciBtPWk7aWYoaT1pLnBhcmVudE5vZGUsXFxcIkJMT0NLUVVPVEVcXFwiPT1oLnRhZ05hbWUmJmIubm9kZS5pc0VtcHR5KG0pJiYhYi5ub2RlLmhhc0NsYXNzKG0sXFxcImZyLW1hcmtlclxcXCIpJiZhKG0pLmZpbmQoYykubGVuZ3RoPjAmJmEobSkuYWZ0ZXIoYyksKFxcXCJCTE9DS1FVT1RFXFxcIiE9aC50YWdOYW1lfHwhZihjLGkpJiYhZShjLGkpKSYmKCFkfHxpIT1ofHxkJiYhYi5ub2RlLmlzQmxvY2soaCkpKXtrKz1iLm5vZGUuY2xvc2VUYWdTdHJpbmcoaSk7dmFyIG49XFxcIkFcXFwiPT1pLnRhZ05hbWUmJmYoYyxpKT9cXFwiZnItdG8tcmVtb3ZlXFxcIjpcXFwiXFxcIjtsPWIubm9kZS5vcGVuVGFnU3RyaW5nKGEoaSkuY2xvbmUoKS5hZGRDbGFzcyhuKS5yZW1vdmVBdHRyKFxcXCJpZFxcXCIpLmdldCgwKSkrbH19d2hpbGUoaSE9aCk7dmFyIG89aD09Yy5wYXJlbnROb2RlJiZiLm5vZGUuaXNCbG9jayhoKXx8Yy5uZXh0U2libGluZztpZihcXFwiQkxPQ0tRVU9URVxcXCI9PWgudGFnTmFtZSl7Yy5wcmV2aW91c1NpYmxpbmcmJmIubm9kZS5pc0Jsb2NrKGMucHJldmlvdXNTaWJsaW5nKSYmYy5uZXh0U2libGluZyYmXFxcIkJSXFxcIj09Yy5uZXh0U2libGluZy50YWdOYW1lJiYoYShjLm5leHRTaWJsaW5nKS5hZnRlcihjKSxjLm5leHRTaWJsaW5nJiZcXFwiQlJcXFwiPT1jLm5leHRTaWJsaW5nLnRhZ05hbWUmJmEoYy5uZXh0U2libGluZykucmVtb3ZlKCkpO3ZhciBwPWIuaHRtbC5kZWZhdWx0VGFnKCk7aj1rK2orKHA/XFxcIjxcXFwiK3ArXFxcIj5cXFwiOlxcXCJcXFwiKSthLkZFLk1BUktFUlMrXFxcIjxicj5cXFwiKyhwP1xcXCI8L1xcXCIrcCtcXFwiPlxcXCI6XFxcIlxcXCIpK2x9ZWxzZSBqPWsraitsKyhvP1xcXCJcXFwiOmEuRkUuSU5WSVNJQkxFX1NQQUNFKSthLkZFLk1BUktFUlM7YShjKS5yZXBsYWNlV2l0aCgnPHNwYW4gaWQ9XFxcImZyLWJyZWFrXFxcIj48L3NwYW4+Jyk7dmFyIHE9Yi5ub2RlLm9wZW5UYWdTdHJpbmcoaCkrYShoKS5odG1sKCkrYi5ub2RlLmNsb3NlVGFnU3RyaW5nKGgpO3E9cS5yZXBsYWNlKC88c3BhbiBpZD1cXFwiZnItYnJlYWtcXFwiPjxcXFxcL3NwYW4+L2csaiksYShoKS5yZXBsYWNlV2l0aChxKX19ZnVuY3Rpb24gcyhlKXt2YXIgZj1iLm1hcmtlcnMuaW5zZXJ0KCk7XFxuaWYoIWYpcmV0dXJuITA7Yi5lbC5ub3JtYWxpemUoKTt2YXIgaD0hMTthKGYpLnBhcmVudHNVbnRpbChiLiRlbCxcXFwiQkxPQ0tRVU9URVxcXCIpLmxlbmd0aD4wJiYoZT0hMSxoPSEwKSxhKGYpLnBhcmVudHNVbnRpbChiLiRlbCxcXFwiVEQsIFRIXFxcIikubGVuZ3RoJiYoaD0hMSksYyhmKT8hZyhmKXx8ZXx8aD9wKGYsZSxoKTpiLmN1cnNvckxpc3RzLl9lbmRFbnRlcihmKTpkKGYpPyFnKGYpfHxlfHxoP3EoZixlLGgpOmIuY3Vyc29yTGlzdHMuX3N0YXJ0RW50ZXIoZik6IWcoZil8fGV8fGg/cihmLGUsaCk6Yi5jdXJzb3JMaXN0cy5fbWlkZGxlRW50ZXIoZiksbygpLGIub3B0cy5odG1sVW50b3VjaGVkfHwoYi5odG1sLmZpbGxFbXB0eUJsb2NrcyghMCksYi5odG1sLmNsZWFuRW1wdHlUYWdzKCksYi5jbGVhbi5saXN0cygpKSxiLnNwYWNlcy5ub3JtYWxpemVBcm91bmRDdXJzb3IoKSxiLnNlbGVjdGlvbi5yZXN0b3JlKCl9cmV0dXJue2VudGVyOnMsYmFja3NwYWNlOmosZGVsOm0saXNBdEVuZDpmLGlzQXRTdGFydDplfX0sYS5GRS5FTlRFUl9QPTAsYS5GRS5FTlRFUl9ESVY9MSxhLkZFLkVOVEVSX0JSPTIsYS5GRS5LRVlDT0RFPXtCQUNLU1BBQ0U6OCxUQUI6OSxFTlRFUjoxMyxTSElGVDoxNixDVFJMOjE3LEFMVDoxOCxFU0M6MjcsU1BBQ0U6MzIsQVJST1dfTEVGVDozNyxBUlJPV19VUDozOCxBUlJPV19SSUdIVDozOSxBUlJPV19ET1dOOjQwLERFTEVURTo0NixaRVJPOjQ4LE9ORTo0OSxUV086NTAsVEhSRUU6NTEsRk9VUjo1MixGSVZFOjUzLFNJWDo1NCxTRVZFTjo1NSxFSUdIVDo1NixOSU5FOjU3LEZGX1NFTUlDT0xPTjo1OSxGRl9FUVVBTFM6NjEsUVVFU1RJT05fTUFSSzo2MyxBOjY1LEI6NjYsQzo2NyxEOjY4LEU6NjksRjo3MCxHOjcxLEg6NzIsSTo3MyxKOjc0LEs6NzUsTDo3NixNOjc3LE46NzgsTzo3OSxQOjgwLFE6ODEsUjo4MixTOjgzLFQ6ODQsVTo4NSxWOjg2LFc6ODcsWDo4OCxZOjg5LFo6OTAsTUVUQTo5MSxOVU1fWkVSTzo5NixOVU1fT05FOjk3LE5VTV9UV086OTgsTlVNX1RIUkVFOjk5LE5VTV9GT1VSOjEwMCxOVU1fRklWRToxMDEsTlVNX1NJWDoxMDIsTlVNX1NFVkVOOjEwMyxOVU1fRUlHSFQ6MTA0LE5VTV9OSU5FOjEwNSxOVU1fTVVMVElQTFk6MTA2LE5VTV9QTFVTOjEwNyxOVU1fTUlOVVM6MTA5LE5VTV9QRVJJT0Q6MTEwLE5VTV9ESVZJU0lPTjoxMTEsRjE6MTEyLEYyOjExMyxGMzoxMTQsRjQ6MTE1LEY1OjExNixGNjoxMTcsRjc6MTE4LEY4OjExOSxGOToxMjAsRjEwOjEyMSxGMTE6MTIyLEYxMjoxMjMsRkZfSFlQSEVOOjE3MyxTRU1JQ09MT046MTg2LERBU0g6MTg5LEVRVUFMUzoxODcsQ09NTUE6MTg4LEhZUEhFTjoxODksUEVSSU9EOjE5MCxTTEFTSDoxOTEsQVBPU1RST1BIRToxOTIsVElMREU6MTkyLFNJTkdMRV9RVU9URToyMjIsT1BFTl9TUVVBUkVfQlJBQ0tFVDoyMTksQkFDS1NMQVNIOjIyMCxDTE9TRV9TUVVBUkVfQlJBQ0tFVDoyMjF9LGEuZXh0ZW5kKGEuRkUuREVGQVVMVFMse2VudGVyOmEuRkUuRU5URVJfUCxtdWx0aUxpbmU6ITAsdGFiU3BhY2VzOjB9KSxhLkZFLk1PRFVMRVMua2V5cz1mdW5jdGlvbihiKXtmdW5jdGlvbiBjKGEpe2Iub3B0cy5tdWx0aUxpbmU/Yi5oZWxwZXJzLmlzSU9TKCl8fChhLnByZXZlbnREZWZhdWx0KCksYS5zdG9wUHJvcGFnYXRpb24oKSxiLnNlbGVjdGlvbi5pc0NvbGxhcHNlZCgpfHxiLnNlbGVjdGlvbi5yZW1vdmUoKSxiLmN1cnNvci5lbnRlcigpKTooYS5wcmV2ZW50RGVmYXVsdCgpLGEuc3RvcFByb3BhZ2F0aW9uKCkpfWZ1bmN0aW9uIGQoYSl7YS5wcmV2ZW50RGVmYXVsdCgpLGEuc3RvcFByb3BhZ2F0aW9uKCksYi5vcHRzLm11bHRpTGluZSYmKGIuc2VsZWN0aW9uLmlzQ29sbGFwc2VkKCl8fGIuc2VsZWN0aW9uLnJlbW92ZSgpLGIuY3Vyc29yLmVudGVyKCEwKSl9ZnVuY3Rpb24gZShhKXtiLnNlbGVjdGlvbi5pc0NvbGxhcHNlZCgpP2IuY3Vyc29yLmJhY2tzcGFjZSgpfHwoYS5wcmV2ZW50RGVmYXVsdCgpLGEuc3RvcFByb3BhZ2F0aW9uKCksej0hMSk6KGEucHJldmVudERlZmF1bHQoKSxhLnN0b3BQcm9wYWdhdGlvbigpLGIuc2VsZWN0aW9uLnJlbW92ZSgpLGIuaHRtbC5maWxsRW1wdHlCbG9ja3MoKSx6PSExKSxiLnBsYWNlaG9sZGVyLnJlZnJlc2goKX1mdW5jdGlvbiBmKGEpe2EucHJldmVudERlZmF1bHQoKSxhLnN0b3BQcm9wYWdhdGlvbigpLFxcXCJcXFwiPT09Yi5zZWxlY3Rpb24udGV4dCgpP2IuY3Vyc29yLmRlbCgpOmIuc2VsZWN0aW9uLnJlbW92ZSgpLGIucGxhY2Vob2xkZXIucmVmcmVzaCgpfWZ1bmN0aW9uIGcoYyl7dmFyIGQ9Yi5zZWxlY3Rpb24uZWxlbWVudCgpO2lmKCFiLmhlbHBlcnMuaXNNb2JpbGUoKSYmKGIuYnJvd3Nlci5tb3ppbGxhfHxkJiZcXFwiQVxcXCI9PWQudGFnTmFtZSkpe2MucHJldmVudERlZmF1bHQoKSxjLnN0b3BQcm9wYWdhdGlvbigpLGIuc2VsZWN0aW9uLmlzQ29sbGFwc2VkKCl8fGIuc2VsZWN0aW9uLnJlbW92ZSgpO3ZhciBlPWIubWFya2Vycy5pbnNlcnQoKTtpZihlKXt2YXIgZj1lLnByZXZpb3VzU2libGluZyxnPWUubmV4dFNpYmxpbmc7IWcmJmUucGFyZW50Tm9kZSYmXFxcIkFcXFwiPT1lLnBhcmVudE5vZGUudGFnTmFtZT8oZS5wYXJlbnROb2RlLmluc2VydEFkamFjZW50SFRNTChcXFwiYWZ0ZXJlbmRcXFwiLFxcXCImbmJzcDtcXFwiK2EuRkUuTUFSS0VSUyksZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGUpKTooZiYmZi5ub2RlVHlwZT09Tm9kZS5URVhUX05PREUmJjE9PWYudGV4dENvbnRlbnQubGVuZ3RoJiYxNjA9PWYudGV4dENvbnRlbnQuY2hhckNvZGVBdCgwKT9mLnRleHRDb250ZW50PWYudGV4dENvbnRlbnQrXFxcIiBcXFwiOmUuaW5zZXJ0QWRqYWNlbnRIVE1MKFxcXCJiZWZvcmViZWdpblxcXCIsXFxcIiZuYnNwO1xcXCIpLGUub3V0ZXJIVE1MPWEuRkUuTUFSS0VSUyksYi5zZWxlY3Rpb24ucmVzdG9yZSgpfX19ZnVuY3Rpb24gaCgpe2lmKGIuYnJvd3Nlci5tb3ppbGxhJiZiLnNlbGVjdGlvbi5pc0NvbGxhcHNlZCgpJiYhQyl7dmFyIGE9Yi5zZWxlY3Rpb24ucmFuZ2VzKDApLGM9YS5zdGFydENvbnRhaW5lcixkPWEuc3RhcnRPZmZzZXQ7YyYmYy5ub2RlVHlwZT09Tm9kZS5URVhUX05PREUmJmQ8PWMudGV4dENvbnRlbnQubGVuZ3RoJiZkPjAmJjMyPT1jLnRleHRDb250ZW50LmNoYXJDb2RlQXQoZC0xKSYmKGIuc2VsZWN0aW9uLnNhdmUoKSxiLnNwYWNlcy5ub3JtYWxpemUoKSxiLnNlbGVjdGlvbi5yZXN0b3JlKCkpfX1mdW5jdGlvbiBpKCl7Yi5zZWxlY3Rpb24uaXNGdWxsKCkmJnNldFRpbWVvdXQoZnVuY3Rpb24oKXt2YXIgYz1iLmh0bWwuZGVmYXVsdFRhZygpO2M/Yi4kZWwuaHRtbChcXFwiPFxcXCIrYytcXFwiPlxcXCIrYS5GRS5NQVJLRVJTK1xcXCI8YnIvPjwvXFxcIitjK1xcXCI+XFxcIik6Yi4kZWwuaHRtbChhLkZFLk1BUktFUlMrXFxcIjxici8+XFxcIiksYi5zZWxlY3Rpb24ucmVzdG9yZSgpLGIucGxhY2Vob2xkZXIucmVmcmVzaCgpLGIuYnV0dG9uLmJ1bGtSZWZyZXNoKCksYi51bmRvLnNhdmVTdGVwKCl9LDApfWZ1bmN0aW9uIGooYSl7aWYoYi5vcHRzLnRhYlNwYWNlcz4wKWlmKGIuc2VsZWN0aW9uLmlzQ29sbGFwc2VkKCkpe2IudW5kby5zYXZlU3RlcCgpLGEucHJldmVudERlZmF1bHQoKSxhLnN0b3BQcm9wYWdhdGlvbigpO2Zvcih2YXIgYz1cXFwiXFxcIixkPTA7ZDxiLm9wdHMudGFiU3BhY2VzO2QrKyljKz1cXFwiJm5ic3A7XFxcIjtiLmh0bWwuaW5zZXJ0KGMpLGIucGxhY2Vob2xkZXIucmVmcmVzaCgpLGIudW5kby5zYXZlU3RlcCgpfWVsc2UgYS5wcmV2ZW50RGVmYXVsdCgpLGEuc3RvcFByb3BhZ2F0aW9uKCksYS5zaGlmdEtleT9iLmNvbW1hbmRzLm91dGRlbnQoKTpiLmNvbW1hbmRzLmluZGVudCgpfWZ1bmN0aW9uIGsoKXtDPSExfWZ1bmN0aW9uIGwoKXtyZXR1cm4gQ31mdW5jdGlvbiBtKGgpe2IuZXZlbnRzLmRpc2FibGVCbHVyKCksej0hMDt2YXIgaT1oLndoaWNoO2lmKDE2PT09aSlyZXR1cm4hMDtpZigyMjk9PT1pKXJldHVybiBDPSEwLCEwO0M9ITE7dmFyIGs9dChpKSYmIXIoaCksbD1pPT1hLkZFLktFWUNPREUuQkFDS1NQQUNFfHxpPT1hLkZFLktFWUNPREUuREVMRVRFO2lmKChiLnNlbGVjdGlvbi5pc0Z1bGwoKSYmIWIub3B0cy5rZWVwRm9ybWF0T25EZWxldGUmJiFiLnBsYWNlaG9sZGVyLmlzVmlzaWJsZSgpfHxsJiZiLnBsYWNlaG9sZGVyLmlzVmlzaWJsZSgpJiZiLm9wdHMua2VlcEZvcm1hdE9uRGVsZXRlKSYmKGt8fGwpKXt2YXIgbT1iLmh0bWwuZGVmYXVsdFRhZygpO2lmKG0/Yi4kZWwuaHRtbChcXFwiPFxcXCIrbStcXFwiPlxcXCIrYS5GRS5NQVJLRVJTK1xcXCI8YnIvPjwvXFxcIittK1xcXCI+XFxcIik6Yi4kZWwuaHRtbChhLkZFLk1BUktFUlMrXFxcIjxici8+XFxcIiksYi5zZWxlY3Rpb24ucmVzdG9yZSgpLCF0KGkpKXJldHVybiBoLnByZXZlbnREZWZhdWx0KCksITB9aT09YS5GRS5LRVlDT0RFLkVOVEVSP2guc2hpZnRLZXk/ZChoKTpjKGgpOmkhPWEuRkUuS0VZQ09ERS5CQUNLU1BBQ0V8fHIoaCl8fGguYWx0S2V5P2khPWEuRkUuS0VZQ09ERS5ERUxFVEV8fHIoaCl8fGguYWx0S2V5P2k9PWEuRkUuS0VZQ09ERS5TUEFDRT9nKGgpOmk9PWEuRkUuS0VZQ09ERS5UQUI/aihoKTpyKGgpfHwhdChoLndoaWNoKXx8Yi5zZWxlY3Rpb24uaXNDb2xsYXBzZWQoKXx8aC5jdHJsS2V5fHxiLnNlbGVjdGlvbi5yZW1vdmUoKTpiLnBsYWNlaG9sZGVyLmlzVmlzaWJsZSgpPyhoLnByZXZlbnREZWZhdWx0KCksaC5zdG9wUHJvcGFnYXRpb24oKSk6ZihoKTpiLnBsYWNlaG9sZGVyLmlzVmlzaWJsZSgpPyhoLnByZXZlbnREZWZhdWx0KCksaC5zdG9wUHJvcGFnYXRpb24oKSk6ZShoKSxiLmV2ZW50cy5lbmFibGVCbHVyKCl9ZnVuY3Rpb24gbihhKXtmb3IodmFyIGM9Yi5kb2MuY3JlYXRlVHJlZVdhbGtlcihhLE5vZGVGaWx0ZXIuU0hPV19URVhULGIubm9kZS5maWx0ZXIoZnVuY3Rpb24oYSl7cmV0dXJuL1xcXFx1MjAwQi9naS50ZXN0KGEudGV4dENvbnRlbnQpfSksITEpO2MubmV4dE5vZGUoKTspe3ZhciBkPWMuY3VycmVudE5vZGU7ZC50ZXh0Q29udGVudD1kLnRleHRDb250ZW50LnJlcGxhY2UoL1xcXFx1MjAwQi9naSxcXFwiXFxcIil9fWZ1bmN0aW9uIG8oKXtpZighYi4kd3ApcmV0dXJuITA7dmFyIGM7Yi5vcHRzLmhlaWdodHx8Yi5vcHRzLmhlaWdodE1heD8oYz1iLnBvc2l0aW9uLmdldEJvdW5kaW5nUmVjdCgpLnRvcCxiLmhlbHBlcnMuaXNJT1MoKSYmKGMtPWIuaGVscGVycy5zY3JvbGxUb3AoKSksYi5vcHRzLmlmcmFtZSYmKGMrPWIuJGlmcmFtZS5vZmZzZXQoKS50b3ApLGM+Yi4kd3Aub2Zmc2V0KCkudG9wLWIuaGVscGVycy5zY3JvbGxUb3AoKStiLiR3cC5oZWlnaHQoKS0yMCYmYi4kd3Auc2Nyb2xsVG9wKGMrYi4kd3Auc2Nyb2xsVG9wKCktKGIuJHdwLmhlaWdodCgpK2IuJHdwLm9mZnNldCgpLnRvcCkrYi5oZWxwZXJzLnNjcm9sbFRvcCgpKzIwKSk6KGM9Yi5wb3NpdGlvbi5nZXRCb3VuZGluZ1JlY3QoKS50b3AsYi5vcHRzLnRvb2xiYXJCb3R0b20mJihjKz1iLm9wdHMudG9vbGJhclN0aWNreU9mZnNldCksYi5oZWxwZXJzLmlzSU9TKCkmJihjLT1iLmhlbHBlcnMuc2Nyb2xsVG9wKCkpLGIub3B0cy5pZnJhbWUmJihjKz1iLiRpZnJhbWUub2Zmc2V0KCkudG9wLGMtPWIuaGVscGVycy5zY3JvbGxUb3AoKSksYys9Yi5vcHRzLnRvb2xiYXJTdGlja3lPZmZzZXQsYz5iLm9fd2luLmlubmVySGVpZ2h0LTIwJiZhKGIub193aW4pLnNjcm9sbFRvcChjK2IuaGVscGVycy5zY3JvbGxUb3AoKS1iLm9fd2luLmlubmVySGVpZ2h0KzIwKSxjPWIucG9zaXRpb24uZ2V0Qm91bmRpbmdSZWN0KCkudG9wLGIub3B0cy50b29sYmFyQm90dG9tfHwoYy09Yi5vcHRzLnRvb2xiYXJTdGlja3lPZmZzZXQpLGIuaGVscGVycy5pc0lPUygpJiYoYy09Yi5oZWxwZXJzLnNjcm9sbFRvcCgpKSxiLm9wdHMuaWZyYW1lJiYoYys9Yi4kaWZyYW1lLm9mZnNldCgpLnRvcCxjLT1iLmhlbHBlcnMuc2Nyb2xsVG9wKCkpLGM8Yi4kdGIuaGVpZ2h0KCkrMjAmJmM+PTAmJmEoYi5vX3dpbikuc2Nyb2xsVG9wKGMrYi5oZWxwZXJzLnNjcm9sbFRvcCgpLWIuJHRiLmhlaWdodCgpLTIwKSl9ZnVuY3Rpb24gcCgpe3ZhciBjPWIuc2VsZWN0aW9uLmVsZW1lbnQoKSxkPWIubm9kZS5ibG9ja1BhcmVudChjKTtpZihkJiZcXFwiRElWXFxcIj09ZC50YWdOYW1lJiZiLnNlbGVjdGlvbi5pbmZvKGQpLmF0U3RhcnQpe3ZhciBlPWIuaHRtbC5kZWZhdWx0VGFnKCk7ZC5wcmV2aW91c1NpYmxpbmcmJlxcXCJESVZcXFwiIT1kLnByZXZpb3VzU2libGluZy50YWdOYW1lJiZlJiZcXFwiZGl2XFxcIiE9ZSYmKGIuc2VsZWN0aW9uLnNhdmUoKSxhKGQpLnJlcGxhY2VXaXRoKFxcXCI8XFxcIitlK1xcXCI+XFxcIitkLmlubmVySFRNTCtcXFwiPC9cXFwiK2UrXFxcIj5cXFwiKSxiLnNlbGVjdGlvbi5yZXN0b3JlKCkpfX1mdW5jdGlvbiBxKGMpe2lmKGIuaGVscGVycy5pc0FuZHJvaWQmJmIuYnJvd3Nlci5tb3ppbGxhKXJldHVybiEwO2lmKEMpcmV0dXJuITE7aWYoIWIuc2VsZWN0aW9uLmlzQ29sbGFwc2VkKCkpcmV0dXJuITA7aWYoYyYmKGMud2hpY2g9PT1hLkZFLktFWUNPREUuTUVUQXx8Yy53aGljaD09YS5GRS5LRVlDT0RFLkNUUkwpKXJldHVybiEwO2lmKGMmJnMoYy53aGljaCkpcmV0dXJuITA7YyYmYy53aGljaD09YS5GRS5LRVlDT0RFLkVOVEVSJiZiLmhlbHBlcnMuaXNJT1MoKSYmcCgpLGMmJihjLndoaWNoPT1hLkZFLktFWUNPREUuRU5URVJ8fGMud2hpY2g9PWEuRkUuS0VZQ09ERS5CQUNLU1BBQ0V8fGMud2hpY2g+PTM3JiZjLndoaWNoPD00MCYmIWIuYnJvd3Nlci5tc2llKSYmKGMud2hpY2g9PWEuRkUuS0VZQ09ERS5CQUNLU1BBQ0UmJnp8fG8oKSksYi5odG1sLmNsZWFuQlJzKCEwLCEwKTt2YXIgZD1mdW5jdGlvbihhKXtpZighYSlyZXR1cm4hMTt2YXIgYj1hLmlubmVySFRNTDtyZXR1cm4gYj1iLnJlcGxhY2UoLzxzcGFuW14+XSo/IGNsYXNzXFxcXHMqPVxcXFxzKltcXFwiJ10/ZnItbWFya2VyW1xcXCInXT9bXj5dKz5cXFxcdTIwMGI8XFxcXC9zcGFuPi9naSxcXFwiXFxcIiksISEoYiYmL1xcXFx1MjAwQi8udGVzdChiKSYmYi5yZXBsYWNlKC9cXFxcdTIwMEIvZ2ksXFxcIlxcXCIpLmxlbmd0aD4wKX0sZT1mdW5jdGlvbihhKXt2YXIgYz0vW1xcXFx1MzA0MS1cXFxcdTMwOTZcXFxcdTMwQTAtXFxcXHUzMEZGXFxcXHU0RTAwLVxcXFx1OUZGRlxcXFx1MzEzMC1cXFxcdTMxOEZcXFxcdUFDMDAtXFxcXHVEN0FGXS9naTtyZXR1cm4hYi5oZWxwZXJzLmlzSU9TKCl8fDA9PT0oKGEudGV4dENvbnRlbnR8fFxcXCJcXFwiKS5tYXRjaChjKXx8W10pLmxlbmd0aH0sZj1iLnNlbGVjdGlvbi5lbGVtZW50KCk7ZChmKSYmIWIubm9kZS5oYXNDbGFzcyhmLFxcXCJmci1tYXJrZXJcXFwiKSYmXFxcIklGUkFNRVxcXCIhPWYudGFnTmFtZSYmZShmKSYmKGIuc2VsZWN0aW9uLnNhdmUoKSxuKGYpLGIuc2VsZWN0aW9uLnJlc3RvcmUoKSl9ZnVuY3Rpb24gcihhKXtpZihuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoXFxcIk1hYyBPUyBYXFxcIikhPS0xKXtpZihhLm1ldGFLZXkmJiFhLmFsdEtleSlyZXR1cm4hMH1lbHNlIGlmKGEuY3RybEtleSYmIWEuYWx0S2V5KXJldHVybiEwO3JldHVybiExfWZ1bmN0aW9uIHMoYil7aWYoYj49YS5GRS5LRVlDT0RFLkFSUk9XX0xFRlQmJmI8PWEuRkUuS0VZQ09ERS5BUlJPV19ET1dOKXJldHVybiEwfWZ1bmN0aW9uIHQoYyl7aWYoYz49YS5GRS5LRVlDT0RFLlpFUk8mJmM8PWEuRkUuS0VZQ09ERS5OSU5FKXJldHVybiEwO2lmKGM+PWEuRkUuS0VZQ09ERS5OVU1fWkVSTyYmYzw9YS5GRS5LRVlDT0RFLk5VTV9NVUxUSVBMWSlyZXR1cm4hMDtpZihjPj1hLkZFLktFWUNPREUuQSYmYzw9YS5GRS5LRVlDT0RFLlopcmV0dXJuITA7aWYoYi5icm93c2VyLndlYmtpdCYmMD09PWMpcmV0dXJuITA7c3dpdGNoKGMpe2Nhc2UgYS5GRS5LRVlDT0RFLlNQQUNFOmNhc2UgYS5GRS5LRVlDT0RFLlFVRVNUSU9OX01BUks6Y2FzZSBhLkZFLktFWUNPREUuTlVNX1BMVVM6Y2FzZSBhLkZFLktFWUNPREUuTlVNX01JTlVTOmNhc2UgYS5GRS5LRVlDT0RFLk5VTV9QRVJJT0Q6Y2FzZSBhLkZFLktFWUNPREUuTlVNX0RJVklTSU9OOmNhc2UgYS5GRS5LRVlDT0RFLlNFTUlDT0xPTjpjYXNlIGEuRkUuS0VZQ09ERS5GRl9TRU1JQ09MT046Y2FzZSBhLkZFLktFWUNPREUuREFTSDpjYXNlIGEuRkUuS0VZQ09ERS5FUVVBTFM6Y2FzZSBhLkZFLktFWUNPREUuRkZfRVFVQUxTOmNhc2UgYS5GRS5LRVlDT0RFLkNPTU1BOmNhc2UgYS5GRS5LRVlDT0RFLlBFUklPRDpjYXNlIGEuRkUuS0VZQ09ERS5TTEFTSDpjYXNlIGEuRkUuS0VZQ09ERS5BUE9TVFJPUEhFOmNhc2UgYS5GRS5LRVlDT0RFLlNJTkdMRV9RVU9URTpjYXNlIGEuRkUuS0VZQ09ERS5PUEVOX1NRVUFSRV9CUkFDS0VUOmNhc2UgYS5GRS5LRVlDT0RFLkJBQ0tTTEFTSDpjYXNlIGEuRkUuS0VZQ09ERS5DTE9TRV9TUVVBUkVfQlJBQ0tFVDpyZXR1cm4hMDtkZWZhdWx0OnJldHVybiExfX1mdW5jdGlvbiB1KGMpe3ZhciBkPWMud2hpY2g7cmV0dXJuISEocihjKXx8ZD49MzcmJmQ8PTQwfHwhdChkKSYmZCE9YS5GRS5LRVlDT0RFLkRFTEVURSYmZCE9YS5GRS5LRVlDT0RFLkJBQ0tTUEFDRSYmZCE9YS5GRS5LRVlDT0RFLkVOVEVSJiYyMjkhPWQpfHwoQXx8KEI9Yi5zbmFwc2hvdC5nZXQoKSxiLnVuZG8uY2FuRG8oKXx8Yi51bmRvLnNhdmVTdGVwKCkpLGNsZWFyVGltZW91dChBKSx2b2lkKEE9c2V0VGltZW91dChmdW5jdGlvbigpe0E9bnVsbCxiLnVuZG8uc2F2ZVN0ZXAoKX0sTWF0aC5tYXgoMjUwLGIub3B0cy50eXBpbmdUaW1lcikpKSl9ZnVuY3Rpb24gdihhKXt2YXIgYz1hLndoaWNoO3JldHVybiEhKHIoYSl8fGM+PTM3JiZjPD00MCl8fHZvaWQoQiYmQSYmKGIudW5kby5zYXZlU3RlcChCKSxCPW51bGwpKX1mdW5jdGlvbiB3KCl7QSYmKGNsZWFyVGltZW91dChBKSxiLnVuZG8uc2F2ZVN0ZXAoKSxCPW51bGwpfWZ1bmN0aW9uIHgoYil7dmFyIGM9Yi53aGljaDtyZXR1cm4gcihiKXx8Yz09YS5GRS5LRVlDT0RFLkY1fWZ1bmN0aW9uIHkoKXtpZihiLmV2ZW50cy5vbihcXFwia2V5ZG93blxcXCIsdSksYi5ldmVudHMub24oXFxcImlucHV0XFxcIixoKSxiLmV2ZW50cy5vbihcXFwia2V5dXAgaW5wdXRcXFwiLHYpLGIuZXZlbnRzLm9uKFxcXCJrZXlwcmVzc1xcXCIsayksYi5ldmVudHMub24oXFxcImtleWRvd25cXFwiLG0pLGIuZXZlbnRzLm9uKFxcXCJrZXl1cFxcXCIscSksYi5ldmVudHMub24oXFxcImh0bWwuaW5zZXJ0ZWRcXFwiLHEpLGIuZXZlbnRzLm9uKFxcXCJjdXRcXFwiLGkpLCFiLmJyb3dzZXIuZWRnZSYmYi5lbC5tc0dldElucHV0Q29udGV4dCl0cnl7Yi5lbC5tc0dldElucHV0Q29udGV4dCgpLmFkZEV2ZW50TGlzdGVuZXIoXFxcIk1TQ2FuZGlkYXRlV2luZG93U2hvd1xcXCIsZnVuY3Rpb24oKXtDPSEwfSksYi5lbC5tc0dldElucHV0Q29udGV4dCgpLmFkZEV2ZW50TGlzdGVuZXIoXFxcIk1TQ2FuZGlkYXRlV2luZG93SGlkZVxcXCIsZnVuY3Rpb24oKXtDPSExLHEoKX0pfWNhdGNoKGEpe319dmFyIHosQSxCLEM9ITE7cmV0dXJue19pbml0OnksY3RybEtleTpyLGlzQ2hhcmFjdGVyOnQsaXNBcnJvdzpzLGZvcmNlVW5kbzp3LGlzSU1FOmwsaXNCcm93c2VyQWN0aW9uOnh9fSxhLkZFLk1PRFVMRVMuYWNjZXNzaWJpbGl0eT1mdW5jdGlvbihiKXtmdW5jdGlvbiBjKGEpe2lmKGEmJmEubGVuZ3RoKXthLmRhdGEoXFxcImJsdXItZXZlbnQtc2V0XFxcIil8fGEucGFyZW50cyhcXFwiLmZyLXBvcHVwXFxcIikubGVuZ3RofHwoYi5ldmVudHMuJG9uKGEsXFxcImJsdXJcXFwiLGZ1bmN0aW9uKCl7dmFyIGM9YS5wYXJlbnRzKFxcXCIuZnItdG9vbGJhciwgLmZyLXBvcHVwXFxcIikuZGF0YShcXFwiaW5zdGFuY2VcXFwiKXx8YjtjLmV2ZW50cy5ibHVyQWN0aXZlKCkmJmMuZXZlbnRzLnRyaWdnZXIoXFxcImJsdXJcXFwiKSxjLmV2ZW50cy5lbmFibGVCbHVyKCl9LCEwKSxhLmRhdGEoXFxcImJsdXItZXZlbnQtc2V0XFxcIiwhMCkpO3ZhciBjPWEucGFyZW50cyhcXFwiLmZyLXRvb2xiYXIsIC5mci1wb3B1cFxcXCIpLmRhdGEoXFxcImluc3RhbmNlXFxcIil8fGI7Yy5ldmVudHMuZGlzYWJsZUJsdXIoKSxhLmZvY3VzKCksYi5zaGFyZWQuJGZfZWw9YX19ZnVuY3Rpb24gZChhLGIpe3ZhciBkPWI/XFxcImxhc3RcXFwiOlxcXCJmaXJzdFxcXCIsZT1hLmZpbmQoXFxcImJ1dHRvbjp2aXNpYmxlOm5vdCguZnItZGlzYWJsZWQpLCAuZnItZ3JvdXAgc3Bhbi5mci1jb21tYW5kOnZpc2libGVcXFwiKVtkXSgpO2lmKGUubGVuZ3RoKXJldHVybiBjKGUpLCEwfWZ1bmN0aW9uIGUoYSl7cmV0dXJuIGEuaXMoXFxcImlucHV0LCB0ZXh0YXJlYVxcXCIpJiZnKCksYi5ldmVudHMuZGlzYWJsZUJsdXIoKSxhLmZvY3VzKCksITB9ZnVuY3Rpb24gZihhLGMpe3ZhciBkPWEuZmluZChcXFwiaW5wdXQsIHRleHRhcmVhLCBidXR0b24sIHNlbGVjdFxcXCIpLmZpbHRlcihcXFwiOnZpc2libGVcXFwiKS5ub3QoXFxcIjpkaXNhYmxlZFxcXCIpLmZpbHRlcihjP1xcXCI6bGFzdFxcXCI6XFxcIjpmaXJzdFxcXCIpO2lmKGQubGVuZ3RoKXJldHVybiBlKGQpO2lmKGIuc2hhcmVkLndpdGhfa2Ipe3ZhciBmPWEuZmluZChcXFwiLmZyLWFjdGl2ZS1pdGVtOnZpc2libGU6Zmlyc3RcXFwiKTtpZihmLmxlbmd0aClyZXR1cm4gZShmKTt2YXIgZz1hLmZpbmQoXFxcIlt0YWJJbmRleF06dmlzaWJsZTpmaXJzdFxcXCIpO2lmKGcubGVuZ3RoKXJldHVybiBlKGcpfX1mdW5jdGlvbiBnKCl7MD09PWIuJGVsLmZpbmQoXFxcIi5mci1tYXJrZXJcXFwiKS5sZW5ndGgmJmIuY29yZS5oYXNGb2N1cygpJiZiLnNlbGVjdGlvbi5zYXZlKCl9ZnVuY3Rpb24gaChhKXthLiRlbC5maW5kKFxcXCIuZnItbWFya2VyXFxcIikubGVuZ3RoJiYoYS5ldmVudHMuZGlzYWJsZUJsdXIoKSxhLnNlbGVjdGlvbi5yZXN0b3JlKCksYS5ldmVudHMuZW5hYmxlQmx1cigpKX1mdW5jdGlvbiBpKGEpe3ZhciBjPWEuY2hpbGRyZW4oKS5ub3QoXFxcIi5mci1idXR0b25zXFxcIik7Yy5kYXRhKFxcXCJtb3VzZWVudGVyLWV2ZW50LXNldFxcXCIpfHwoYi5ldmVudHMuJG9uKGMsXFxcIm1vdXNlZW50ZXJcXFwiLFxcXCJbdGFiSW5kZXhdXFxcIixmdW5jdGlvbihkKXt2YXIgZT1hLmRhdGEoXFxcImluc3RhbmNlXFxcIil8fGI7aWYoIUYpcmV0dXJuIGQuc3RvcFByb3BhZ2F0aW9uKCksdm9pZCBkLnByZXZlbnREZWZhdWx0KCk7dmFyIGY9Yy5maW5kKFxcXCI6Zm9jdXM6Zmlyc3RcXFwiKTtmLmxlbmd0aCYmIWYuaXMoXFxcImlucHV0LCBidXR0b24sIHRleHRhcmVhXFxcIikmJihlLmV2ZW50cy5kaXNhYmxlQmx1cigpLGYuYmx1cigpLGUuZXZlbnRzLmRpc2FibGVCbHVyKCksZS5ldmVudHMuZm9jdXMoKSl9KSxjLmRhdGEoXFxcIm1vdXNlZW50ZXItZXZlbnQtc2V0XFxcIiwhMCkpLCFmKGMpJiZiLnNoYXJlZC53aXRoX2tiJiZkKGEuZmluZChcXFwiLmZyLWJ1dHRvbnNcXFwiKSl9ZnVuY3Rpb24gaihhKXtiLmNvcmUuaGFzRm9jdXMoKXx8KGIuZXZlbnRzLmRpc2FibGVCbHVyKCksYi5ldmVudHMuZm9jdXMoKSksYi5hY2Nlc3NpYmlsaXR5LnNhdmVTZWxlY3Rpb24oKSxiLmV2ZW50cy5kaXNhYmxlQmx1cigpLGIuJGVsLmJsdXIoKSxiLnNlbGVjdGlvbi5jbGVhcigpLGIuZXZlbnRzLmRpc2FibGVCbHVyKCksYi5zaGFyZWQud2l0aF9rYj9hLmZpbmQoXFxcIi5mci1jb21tYW5kW3RhYkluZGV4XSwgW3RhYkluZGV4XVxcXCIpLmZpcnN0KCkuZm9jdXMoKTphLmZpbmQoXFxcIlt0YWJJbmRleF06Zmlyc3RcXFwiKS5mb2N1cygpfWZ1bmN0aW9uIGsoKXt2YXIgYT1iLnBvcHVwcy5hcmVWaXNpYmxlKCk7aWYoYSl7dmFyIGM9YS5maW5kKFxcXCIuZnItYnV0dG9uc1xcXCIpO3JldHVybiBjLmZpbmQoXFxcImJ1dHRvbjpmb2N1cywgLmZyLWdyb3VwIHNwYW46Zm9jdXNcXFwiKS5sZW5ndGg/IWQoYS5kYXRhKFxcXCJpbnN0YW5jZVxcXCIpLiR0Yik6IWQoYyl9cmV0dXJuIWQoYi4kdGIpfWZ1bmN0aW9uIGwoKXt2YXIgYT1udWxsO3JldHVybiBiLnNoYXJlZC4kZl9lbC5pcyhcXFwiLmZyLWRyb3Bkb3duLmZyLWFjdGl2ZVxcXCIpP2E9Yi5zaGFyZWQuJGZfZWw6Yi5zaGFyZWQuJGZfZWwuY2xvc2VzdChcXFwiLmZyLWRyb3Bkb3duLW1lbnVcXFwiKS5wcmV2KCkuaXMoXFxcIi5mci1kcm9wZG93bi5mci1hY3RpdmVcXFwiKSYmKGE9Yi5zaGFyZWQuJGZfZWwuY2xvc2VzdChcXFwiLmZyLWRyb3Bkb3duLW1lbnVcXFwiKS5wcmV2KCkpLGF9ZnVuY3Rpb24gbShlLGcsaCl7aWYoYi5zaGFyZWQuJGZfZWwpe3ZhciBpPWwoKTtpJiYoYi5idXR0b24uY2xpY2soaSksYi5zaGFyZWQuJGZfZWw9aSk7dmFyIGo9ZS5maW5kKFxcXCJidXR0b246dmlzaWJsZTpub3QoLmZyLWRpc2FibGVkKSwgLmZyLWdyb3VwIHNwYW4uZnItY29tbWFuZDp2aXNpYmxlXFxcIiksaz1qLmluZGV4KGIuc2hhcmVkLiRmX2VsKTtpZigwPT09ayYmIWh8fGs9PWoubGVuZ3RoLTEmJmgpe3ZhciBtO2lmKGcpe2lmKGUucGFyZW50KCkuaXMoXFxcIi5mci1wb3B1cFxcXCIpKXt2YXIgbj1lLnBhcmVudCgpLmNoaWxkcmVuKCkubm90KFxcXCIuZnItYnV0dG9uc1xcXCIpO209IWYobiwhaCl9bT09PSExJiYoYi5zaGFyZWQuJGZfZWw9bnVsbCl9ZyYmbT09PSExfHxkKGUsIWgpfWVsc2UgYyhhKGouZ2V0KGsrKGg/MTotMSkpKSk7cmV0dXJuITF9fWZ1bmN0aW9uIG4oYSxiKXtyZXR1cm4gbShhLGIsITApfWZ1bmN0aW9uIG8oYSxiKXtyZXR1cm4gbShhLGIpfWZ1bmN0aW9uIHAoYSl7aWYoYi5zaGFyZWQuJGZfZWwpe3ZhciBkO2lmKGIuc2hhcmVkLiRmX2VsLmlzKFxcXCIuZnItZHJvcGRvd24uZnItYWN0aXZlXFxcIikpcmV0dXJuIGQ9YT9iLnNoYXJlZC4kZl9lbC5uZXh0KCkuZmluZChcXFwiLmZyLWNvbW1hbmQ6bm90KC5mci1kaXNhYmxlZClcXFwiKS5maXJzdCgpOmIuc2hhcmVkLiRmX2VsLm5leHQoKS5maW5kKFxcXCIuZnItY29tbWFuZDpub3QoLmZyLWRpc2FibGVkKVxcXCIpLmxhc3QoKSxjKGQpLCExO2lmKGIuc2hhcmVkLiRmX2VsLmlzKFxcXCJhLmZyLWNvbW1hbmRcXFwiKSlyZXR1cm4gZD1hP2Iuc2hhcmVkLiRmX2VsLmNsb3Nlc3QoXFxcImxpXFxcIikubmV4dEFsbChcXFwiOnZpc2libGU6Zmlyc3RcXFwiKS5maW5kKFxcXCIuZnItY29tbWFuZDpub3QoLmZyLWRpc2FibGVkKVxcXCIpLmZpcnN0KCk6Yi5zaGFyZWQuJGZfZWwuY2xvc2VzdChcXFwibGlcXFwiKS5wcmV2QWxsKFxcXCI6dmlzaWJsZTpmaXJzdFxcXCIpLmZpbmQoXFxcIi5mci1jb21tYW5kOm5vdCguZnItZGlzYWJsZWQpXFxcIikuZmlyc3QoKSxkLmxlbmd0aHx8KGQ9YT9iLnNoYXJlZC4kZl9lbC5jbG9zZXN0KFxcXCIuZnItZHJvcGRvd24tbWVudVxcXCIpLmZpbmQoXFxcIi5mci1jb21tYW5kOm5vdCguZnItZGlzYWJsZWQpXFxcIikuZmlyc3QoKTpiLnNoYXJlZC4kZl9lbC5jbG9zZXN0KFxcXCIuZnItZHJvcGRvd24tbWVudVxcXCIpLmZpbmQoXFxcIi5mci1jb21tYW5kOm5vdCguZnItZGlzYWJsZWQpXFxcIikubGFzdCgpKSxjKGQpLCExfX1mdW5jdGlvbiBxKCl7cmV0dXJuIGIuc2hhcmVkLiRmX2VsJiZiLnNoYXJlZC4kZl9lbC5pcyhcXFwiLmZyLWRyb3Bkb3duOm5vdCguZnItYWN0aXZlKVxcXCIpP3MoKTpwKCEwKX1mdW5jdGlvbiByKCl7cmV0dXJuIHAoKX1mdW5jdGlvbiBzKCl7aWYoYi5zaGFyZWQuJGZfZWwpe2lmKGIuc2hhcmVkLiRmX2VsLmhhc0NsYXNzKFxcXCJmci1kcm9wZG93blxcXCIpKWIuYnV0dG9uLmNsaWNrKGIuc2hhcmVkLiRmX2VsKTtlbHNlIGlmKGIuc2hhcmVkLiRmX2VsLmlzKFxcXCJidXR0b24uZnItYmFja1xcXCIpKXtiLm9wdHMudG9vbGJhcklubGluZSYmKGIuZXZlbnRzLmRpc2FibGVCbHVyKCksYi5ldmVudHMuZm9jdXMoKSk7dmFyIGE9Yi5wb3B1cHMuYXJlVmlzaWJsZShiKTthJiYoYi5zaGFyZWQud2l0aF9rYj0hMSksYi5idXR0b24uY2xpY2soYi5zaGFyZWQuJGZfZWwpLHooYSl9ZWxzZXtpZihiLmV2ZW50cy5kaXNhYmxlQmx1cigpLGIuYnV0dG9uLmNsaWNrKGIuc2hhcmVkLiRmX2VsKSxiLnNoYXJlZC4kZl9lbC5hdHRyKFxcXCJkYXRhLXBvcHVwXFxcIikpe3ZhciBjPWIucG9wdXBzLmFyZVZpc2libGUoYik7YyYmYy5kYXRhKFxcXCJwb3B1cC1idXR0b25cXFwiLGIuc2hhcmVkLiRmX2VsKX1lbHNlIGlmKGIuc2hhcmVkLiRmX2VsLmF0dHIoXFxcImRhdGEtbW9kYWxcXFwiKSl7dmFyIGQ9Yi5tb2RhbHMuYXJlVmlzaWJsZShiKTtkJiZkLmRhdGEoXFxcIm1vZGFsLWJ1dHRvblxcXCIsYi5zaGFyZWQuJGZfZWwpfWIuc2hhcmVkLiRmX2VsPW51bGx9cmV0dXJuITF9fWZ1bmN0aW9uIHQoKXtiLnNoYXJlZC4kZl9lbCYmKGIuZXZlbnRzLmRpc2FibGVCbHVyKCksYi5zaGFyZWQuJGZfZWwuYmx1cigpLGIuc2hhcmVkLiRmX2VsPW51bGwpLGIuZXZlbnRzLnRyaWdnZXIoXFxcInRvb2xiYXIuZm9jdXNFZGl0b3JcXFwiKSE9PSExJiYoYi5ldmVudHMuZGlzYWJsZUJsdXIoKSxiLmV2ZW50cy5mb2N1cygpKX1mdW5jdGlvbiB1KGEpe2lmKGIuc2hhcmVkLiRmX2VsKXt2YXIgZD1sKCk7cmV0dXJuIGQ/KGIuYnV0dG9uLmNsaWNrKGQpLGMoZCkpOmEucGFyZW50KCkuZmluZChcXFwiLmZyLWJhY2s6dmlzaWJsZVxcXCIpLmxlbmd0aD8oYi5zaGFyZWQud2l0aF9rYj0hMSxiLm9wdHMudG9vbGJhcklubGluZSYmKGIuZXZlbnRzLmRpc2FibGVCbHVyKCksYi5ldmVudHMuZm9jdXMoKSksYi5idXR0b24uZXhlYyhhLnBhcmVudCgpLmZpbmQoXFxcIi5mci1iYWNrOnZpc2libGU6Zmlyc3RcXFwiKSkseihhLnBhcmVudCgpKSk6Yi5zaGFyZWQuJGZfZWwuaXMoXFxcImJ1dHRvbiwgLmZyLWdyb3VwIHNwYW5cXFwiKSYmKGEucGFyZW50KCkuaXMoXFxcIi5mci1wb3B1cFxcXCIpPyhoKGIpLGIuc2hhcmVkLiRmX2VsPW51bGwsYi5ldmVudHMudHJpZ2dlcihcXFwidG9vbGJhci5lc2NcXFwiKSE9PSExJiYoYi5wb3B1cHMuaGlkZShhLnBhcmVudCgpKSxiLm9wdHMudG9vbGJhcklubGluZSYmYi50b29sYmFyLnNob3dJbmxpbmUobnVsbCwhMCkseihhLnBhcmVudCgpKSkpOnQoKSksITF9fWZ1bmN0aW9uIHYoYyxkKXt2YXIgZT1uYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoXFxcIk1hYyBPUyBYXFxcIikhPS0xP2MubWV0YUtleTpjLmN0cmxLZXksZj1jLndoaWNoLGc9ITE7cmV0dXJuIGYhPWEuRkUuS0VZQ09ERS5UQUJ8fGV8fGMuc2hpZnRLZXl8fGMuYWx0S2V5P2YhPWEuRkUuS0VZQ09ERS5BUlJPV19SSUdIVHx8ZXx8Yy5zaGlmdEtleXx8Yy5hbHRLZXk/ZiE9YS5GRS5LRVlDT0RFLlRBQnx8ZXx8IWMuc2hpZnRLZXl8fGMuYWx0S2V5P2YhPWEuRkUuS0VZQ09ERS5BUlJPV19MRUZUfHxlfHxjLnNoaWZ0S2V5fHxjLmFsdEtleT9mIT1hLkZFLktFWUNPREUuQVJST1dfVVB8fGV8fGMuc2hpZnRLZXl8fGMuYWx0S2V5P2YhPWEuRkUuS0VZQ09ERS5BUlJPV19ET1dOfHxlfHxjLnNoaWZ0S2V5fHxjLmFsdEtleT9mIT1hLkZFLktFWUNPREUuRU5URVJ8fGV8fGMuc2hpZnRLZXl8fGMuYWx0S2V5P2YhPWEuRkUuS0VZQ09ERS5FU0N8fGV8fGMuc2hpZnRLZXl8fGMuYWx0S2V5P2YhPWEuRkUuS0VZQ09ERS5GMTB8fGV8fGMuc2hpZnRLZXl8fCFjLmFsdEtleXx8KGc9aygpKTpnPXUoZCk6Zz1zKCk6Zz1xKCk6Zz1yKCk6Zz1vKGQpOmc9byhkLCEwKTpnPW4oZCk6Zz1uKGQsITApLGIuc2hhcmVkLiRmX2VsfHx2b2lkIDAhPT1nfHwoZz0hMCksIWcmJmIua2V5cy5pc0Jyb3dzZXJBY3Rpb24oYykmJihnPSEwKSwhIWd8fChjLnByZXZlbnREZWZhdWx0KCksYy5zdG9wUHJvcGFnYXRpb24oKSwhMSl9ZnVuY3Rpb24gdyhjKXtjJiZjLmxlbmd0aCYmKGIuZXZlbnRzLiRvbihjLFxcXCJrZXlkb3duXFxcIixmdW5jdGlvbihkKXtpZighYShkLnRhcmdldCkuaXMoXFxcImEuZnItY29tbWFuZCwgYnV0dG9uLmZyLWNvbW1hbmQsIC5mci1ncm91cCBzcGFuLmZyLWNvbW1hbmRcXFwiKSlyZXR1cm4hMDt2YXIgZT1jLnBhcmVudHMoXFxcIi5mci1wb3B1cFxcXCIpLmRhdGEoXFxcImluc3RhbmNlXFxcIil8fGMuZGF0YShcXFwiaW5zdGFuY2VcXFwiKXx8YjtiLnNoYXJlZC53aXRoX2tiPSEwO3ZhciBmPWUuYWNjZXNzaWJpbGl0eS5leGVjKGQsYyk7cmV0dXJuIGIuc2hhcmVkLndpdGhfa2I9ITEsZn0sITApLGIuZXZlbnRzLiRvbihjLFxcXCJtb3VzZWVudGVyXFxcIixcXFwiW3RhYkluZGV4XVxcXCIsZnVuY3Rpb24oZCl7dmFyIGU9Yy5wYXJlbnRzKFxcXCIuZnItcG9wdXBcXFwiKS5kYXRhKFxcXCJpbnN0YW5jZVxcXCIpfHxjLmRhdGEoXFxcImluc3RhbmNlXFxcIil8fGI7aWYoIUYpcmV0dXJuIGQuc3RvcFByb3BhZ2F0aW9uKCksdm9pZCBkLnByZXZlbnREZWZhdWx0KCk7dmFyIGY9YShkLmN1cnJlbnRUYXJnZXQpO2Uuc2hhcmVkLiRmX2VsJiZlLnNoYXJlZC4kZl9lbC5ub3QoZikmJmUuYWNjZXNzaWJpbGl0eS5mb2N1c0VkaXRvcigpfSwhMCkpfWZ1bmN0aW9uIHgoYSl7dmFyIGM9Yi5wb3B1cHMuZ2V0KGEpLGQ9eShhKTt3KGMuZmluZChcXFwiLmZyLWJ1dHRvbnNcXFwiKSksYi5ldmVudHMuJG9uKGMsXFxcIm1vdXNlZW50ZXJcXFwiLFxcXCJ0YWJJbmRleFxcXCIsZC5fdGlNb3VzZWVudGVyLCEwKSxiLmV2ZW50cy4kb24oYy5jaGlsZHJlbigpLm5vdChcXFwiLmZyLWJ1dHRvbnNcXFwiKSxcXFwia2V5ZG93blxcXCIsXFxcIlt0YWJJbmRleF1cXFwiLGQuX3RpS2V5ZG93biwhMCksYi5wb3B1cHMub25IaWRlKGEsZnVuY3Rpb24oKXtoKGMuZGF0YShcXFwiaW5zdGFuY2VcXFwiKXx8Yil9KSxiLnBvcHVwcy5vblNob3coYSxmdW5jdGlvbigpe0Y9ITEsc2V0VGltZW91dChmdW5jdGlvbigpe0Y9ITB9LDApfSl9ZnVuY3Rpb24geShjKXt2YXIgZT1iLnBvcHVwcy5nZXQoYyk7cmV0dXJue190aUtleWRvd246ZnVuY3Rpb24oZyl7dmFyIGk9ZS5kYXRhKFxcXCJpbnN0YW5jZVxcXCIpfHxiO2lmKGkuZXZlbnRzLnRyaWdnZXIoXFxcInBvcHVwLnRhYlxcXCIsW2ddKT09PSExKXJldHVybiExO3ZhciBqPWcud2hpY2gsaz1lLmZpbmQoXFxcIjpmb2N1czpmaXJzdFxcXCIpO2lmKGEuRkUuS0VZQ09ERS5UQUI9PWope2cucHJldmVudERlZmF1bHQoKTt2YXIgbD1lLmNoaWxkcmVuKCkubm90KFxcXCIuZnItYnV0dG9uc1xcXCIpLG09bC5maW5kKFxcXCJpbnB1dCwgdGV4dGFyZWEsIGJ1dHRvbiwgc2VsZWN0XFxcIikuZmlsdGVyKFxcXCI6dmlzaWJsZVxcXCIpLm5vdChcXFwiLmZyLW5vLXRvdWNoIGlucHV0LCAuZnItbm8tdG91Y2ggdGV4dGFyZWEsIC5mci1uby10b3VjaCBidXR0b24sIC5mci1uby10b3VjaCBzZWxlY3QsIDpkaXNhYmxlZFxcXCIpLnRvQXJyYXkoKSxuPW0uaW5kZXhPZih0aGlzKSsoZy5zaGlmdEtleT8tMToxKTtpZigwPD1uJiZuPG0ubGVuZ3RoKXJldHVybiBpLmV2ZW50cy5kaXNhYmxlQmx1cigpLGEobVtuXSkuZm9jdXMoKSxnLnN0b3BQcm9wYWdhdGlvbigpLCExO3ZhciBvPWUuZmluZChcXFwiLmZyLWJ1dHRvbnNcXFwiKTtpZihvLmxlbmd0aCYmZChvLCEhZy5zaGlmdEtleSkpcmV0dXJuIGcuc3RvcFByb3BhZ2F0aW9uKCksITE7aWYoZihsKSlyZXR1cm4gZy5zdG9wUHJvcGFnYXRpb24oKSwhMX1lbHNle2lmKGEuRkUuS0VZQ09ERS5FTlRFUiE9ailyZXR1cm4gYS5GRS5LRVlDT0RFLkVTQz09aj8oZy5wcmV2ZW50RGVmYXVsdCgpLGcuc3RvcFByb3BhZ2F0aW9uKCksaChpKSxpLnBvcHVwcy5pc1Zpc2libGUoYykmJmUuZmluZChcXFwiLmZyLWJhY2s6dmlzaWJsZVxcXCIpLmxlbmd0aD8oaS5vcHRzLnRvb2xiYXJJbmxpbmUmJihpLmV2ZW50cy5kaXNhYmxlQmx1cigpLGkuZXZlbnRzLmZvY3VzKCkpLGkuYnV0dG9uLmV4ZWMoZS5maW5kKFxcXCIuZnItYmFjazp2aXNpYmxlOmZpcnN0XFxcIikpLHooZSkpOmkucG9wdXBzLmlzVmlzaWJsZShjKSYmZS5maW5kKFxcXCIuZnItZGlzbWlzczp2aXNpYmxlXFxcIikubGVuZ3RoP2kuYnV0dG9uLmV4ZWMoZS5maW5kKFxcXCIuZnItZGlzbWlzczp2aXNpYmxlOmZpcnN0XFxcIikpOihpLnBvcHVwcy5oaWRlKGMpLGkub3B0cy50b29sYmFySW5saW5lJiZpLnRvb2xiYXIuc2hvd0lubGluZShudWxsLCEwKSx6KGUpKSwhMSk6YS5GRS5LRVlDT0RFLlNQQUNFPT1qJiYoay5pcyhcXFwiLmZyLXN1Ym1pdFxcXCIpfHxrLmlzKFxcXCIuZnItZGlzbWlzc1xcXCIpKT8oZy5wcmV2ZW50RGVmYXVsdCgpLGcuc3RvcFByb3BhZ2F0aW9uKCksaS5ldmVudHMuZGlzYWJsZUJsdXIoKSxpLmJ1dHRvbi5leGVjKGspLCEwKTppLmtleXMuaXNCcm93c2VyQWN0aW9uKGcpP3ZvaWQgZy5zdG9wUHJvcGFnYXRpb24oKTprLmlzKFxcXCJpbnB1dFt0eXBlPXRleHRdLCB0ZXh0YXJlYVxcXCIpP3ZvaWQgZy5zdG9wUHJvcGFnYXRpb24oKTphLkZFLktFWUNPREUuU1BBQ0U9PWomJihrLmlzKFxcXCIuZnItbGluay1hdHRyXFxcIil8fGsuaXMoXFxcImlucHV0W3R5cGU9ZmlsZV1cXFwiKSk/dm9pZCBnLnN0b3BQcm9wYWdhdGlvbigpOihnLnN0b3BQcm9wYWdhdGlvbigpLGcucHJldmVudERlZmF1bHQoKSwhMSk7dmFyIHA9bnVsbDtlLmZpbmQoXFxcIi5mci1zdWJtaXQ6dmlzaWJsZVxcXCIpLmxlbmd0aD4wP3A9ZS5maW5kKFxcXCIuZnItc3VibWl0OnZpc2libGU6Zmlyc3RcXFwiKTplLmZpbmQoXFxcIi5mci1kaXNtaXNzOnZpc2libGVcXFwiKS5sZW5ndGgmJihwPWUuZmluZChcXFwiLmZyLWRpc21pc3M6dmlzaWJsZTpmaXJzdFxcXCIpKSxwJiYoZy5wcmV2ZW50RGVmYXVsdCgpLGcuc3RvcFByb3BhZ2F0aW9uKCksaS5ldmVudHMuZGlzYWJsZUJsdXIoKSxpLmJ1dHRvbi5leGVjKHApKX19LF90aU1vdXNlZW50ZXI6ZnVuY3Rpb24oKXt2YXIgYT1lLmRhdGEoXFxcImluc3RhbmNlXFxcIil8fGI7QyhhKX19fWZ1bmN0aW9uIHooYSl7dmFyIGI9YS5kYXRhKFxcXCJwb3B1cC1idXR0b25cXFwiKTtiJiZzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7YyhiKSxhLmRhdGEoXFxcInBvcHVwLWJ1dHRvblxcXCIsbnVsbCl9LDApfWZ1bmN0aW9uIEEoYSl7dmFyIGI9YS5kYXRhKFxcXCJtb2RhbC1idXR0b25cXFwiKTtiJiZzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7YyhiKSxhLmRhdGEoXFxcIm1vZGFsLWJ1dHRvblxcXCIsbnVsbCl9LDApfWZ1bmN0aW9uIEIoKXtyZXR1cm4gbnVsbCE9Yi5zaGFyZWQuJGZfZWx9ZnVuY3Rpb24gQyhhKXt2YXIgYz1iLnBvcHVwcy5hcmVWaXNpYmxlKGEpO2MmJmMuZGF0YShcXFwicG9wdXAtYnV0dG9uXFxcIixudWxsKX1mdW5jdGlvbiBEKGMpe3ZhciBkPW5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZihcXFwiTWFjIE9TIFhcXFwiKSE9LTE/Yy5tZXRhS2V5OmMuY3RybEtleSxlPWMud2hpY2g7aWYoZT09YS5GRS5LRVlDT0RFLkYxMCYmIWQmJiFjLnNoaWZ0S2V5JiZjLmFsdEtleSl7Yi5zaGFyZWQud2l0aF9rYj0hMDt2YXIgZz1iLnBvcHVwcy5hcmVWaXNpYmxlKGIpLGg9ITE7cmV0dXJuIGcmJihoPWYoZy5jaGlsZHJlbigpLm5vdChcXFwiLmZyLWJ1dHRvbnNcXFwiKSkpLGh8fGsoKSxiLnNoYXJlZC53aXRoX2tiPSExLGMucHJldmVudERlZmF1bHQoKSxjLnN0b3BQcm9wYWdhdGlvbigpLCExfXJldHVybiEwfWZ1bmN0aW9uIEUoKXtiLiR3cD9iLmV2ZW50cy5vbihcXFwia2V5ZG93blxcXCIsRCwhMCk6Yi5ldmVudHMuJG9uKGIuJHdpbixcXFwia2V5ZG93blxcXCIsRCwhMCksYi5ldmVudHMub24oXFxcIm1vdXNlZG93blxcXCIsZnVuY3Rpb24oYSl7QyhiKSxiLnNoYXJlZC4kZl9lbCYmKGgoYiksYS5zdG9wUHJvcGFnYXRpb24oKSxiLmV2ZW50cy5kaXNhYmxlQmx1cigpLGIuc2hhcmVkLiRmX2VsPW51bGwpfSwhMCksYi5ldmVudHMub24oXFxcImJsdXJcXFwiLGZ1bmN0aW9uKCl7Yi5zaGFyZWQuJGZfZWw9bnVsbCxDKGIpfSwhMCl9dmFyIEY9ITA7cmV0dXJue19pbml0OkUscmVnaXN0ZXJQb3B1cDp4LHJlZ2lzdGVyVG9vbGJhcjp3LGZvY3VzVG9vbGJhckVsZW1lbnQ6Yyxmb2N1c1Rvb2xiYXI6ZCxmb2N1c0NvbnRlbnQ6Zixmb2N1c1BvcHVwOmksZm9jdXNNb2RhbDpqLGZvY3VzRWRpdG9yOnQsZm9jdXNQb3B1cEJ1dHRvbjp6LGZvY3VzTW9kYWxCdXR0b246QSxoYXNGb2N1czpCLGV4ZWM6dixzYXZlU2VsZWN0aW9uOmcscmVzdG9yZVNlbGVjdGlvbjpofX0sYS5GRS5NT0RVTEVTLmZvcm1hdD1mdW5jdGlvbihiKXtmdW5jdGlvbiBjKGEsYil7dmFyIGM9XFxcIjxcXFwiK2E7Zm9yKHZhciBkIGluIGIpYi5oYXNPd25Qcm9wZXJ0eShkKSYmKGMrPVxcXCIgXFxcIitkKyc9XFxcIicrYltkXSsnXFxcIicpO3JldHVybiBjKz1cXFwiPlxcXCJ9ZnVuY3Rpb24gZChhKXtyZXR1cm5cXFwiPC9cXFwiK2ErXFxcIj5cXFwifWZ1bmN0aW9uIGUoYSxiKXt2YXIgYz1hO2Zvcih2YXIgZCBpbiBiKWIuaGFzT3duUHJvcGVydHkoZCkmJihjKz1cXFwiaWRcXFwiPT1kP1xcXCIjXFxcIitiW2RdOlxcXCJjbGFzc1xcXCI9PWQ/XFxcIi5cXFwiK2JbZF06XFxcIltcXFwiK2QrJz1cXFwiJytiW2RdKydcXFwiXScpO3JldHVybiBjfWZ1bmN0aW9uIGYoYSxiKXtyZXR1cm4hKCFhfHxhLm5vZGVUeXBlIT1Ob2RlLkVMRU1FTlRfTk9ERSkmJihhLm1hdGNoZXN8fGEubWF0Y2hlc1NlbGVjdG9yfHxhLm1zTWF0Y2hlc1NlbGVjdG9yfHxhLm1vek1hdGNoZXNTZWxlY3Rvcnx8YS53ZWJraXRNYXRjaGVzU2VsZWN0b3J8fGEub01hdGNoZXNTZWxlY3RvcikuY2FsbChhLGIpfWZ1bmN0aW9uIGcoZCxlLGYpe2lmKGQpe2lmKGIubm9kZS5pc0Jsb2NrKGQpKXJldHVybiBnKGQuZmlyc3RDaGlsZCxlLGYpLCExO2Zvcih2YXIgaD1hKGMoZSxmKSkuaW5zZXJ0QmVmb3JlKGQpLGk9ZDtpJiYhYShpKS5pcyhcXFwiLmZyLW1hcmtlclxcXCIpJiYwPT09YShpKS5maW5kKFxcXCIuZnItbWFya2VyXFxcIikubGVuZ3RoOyl7dmFyIGo9aTtpPWkubmV4dFNpYmxpbmcsaC5hcHBlbmQoail9aWYoaSlhKGkpLmZpbmQoXFxcIi5mci1tYXJrZXJcXFwiKS5sZW5ndGgmJmcoaS5maXJzdENoaWxkLGUsZik7ZWxzZXtmb3IodmFyIGs9aC5nZXQoMCkucGFyZW50Tm9kZTtrJiYhay5uZXh0U2libGluZyYmIWIubm9kZS5pc0VsZW1lbnQoayk7KWs9ay5wYXJlbnROb2RlO2lmKGspe3ZhciBsPWsubmV4dFNpYmxpbmc7bCYmKGIubm9kZS5pc0Jsb2NrKGwpP2cobC5maXJzdENoaWxkLGUsZik6ZyhsLGUsZikpfX1oLmlzKFxcXCI6ZW1wdHlcXFwiKSYmaC5yZW1vdmUoKX19ZnVuY3Rpb24gaChoLGkpe3ZhciBqO2lmKFxcXCJ1bmRlZmluZWRcXFwiPT10eXBlb2YgaSYmKGk9e30pLGkuc3R5bGUmJmRlbGV0ZSBpLnN0eWxlLGIuc2VsZWN0aW9uLmlzQ29sbGFwc2VkKCkpe2IubWFya2Vycy5pbnNlcnQoKTt2YXIgaz1iLiRlbC5maW5kKFxcXCIuZnItbWFya2VyXFxcIik7ay5yZXBsYWNlV2l0aChjKGgsaSkrYS5GRS5JTlZJU0lCTEVfU1BBQ0UrYS5GRS5NQVJLRVJTK2QoaCkpLGIuc2VsZWN0aW9uLnJlc3RvcmUoKX1lbHNle2Iuc2VsZWN0aW9uLnNhdmUoKTt2YXIgbD1iLiRlbC5maW5kKCcuZnItbWFya2VyW2RhdGEtdHlwZT1cXFwidHJ1ZVxcXCJdJykuZ2V0KDApLm5leHRTaWJsaW5nO2cobCxoLGkpO3ZhciBtO2RvIGZvcihtPWIuJGVsLmZpbmQoZShoLGkpK1xcXCIgPiBcXFwiK2UoaCxpKSksaj0wO2o8bS5sZW5ndGg7aisrKW1bal0ub3V0ZXJIVE1MPW1bal0uaW5uZXJIVE1MO3doaWxlKG0ubGVuZ3RoKTtiLmVsLm5vcm1hbGl6ZSgpO3ZhciBuPWIuZWwucXVlcnlTZWxlY3RvckFsbChcXFwiLmZyLW1hcmtlclxcXCIpO2ZvcihqPTA7ajxuLmxlbmd0aDtqKyspe3ZhciBvPWEobltqXSk7by5kYXRhKFxcXCJ0eXBlXFxcIik9PT0hMD9mKG8uZ2V0KDApLm5leHRTaWJsaW5nLGUoaCxpKSkmJm8ubmV4dCgpLnByZXBlbmQobyk6ZihvLmdldCgwKS5wcmV2aW91c1NpYmxpbmcsZShoLGkpKSYmby5wcmV2KCkuYXBwZW5kKG8pfWIuc2VsZWN0aW9uLnJlc3RvcmUoKX19ZnVuY3Rpb24gaShhLGMsZCxnKXtpZighZyl7dmFyIGg9ITE7aWYoYS5kYXRhKFxcXCJ0eXBlXFxcIik9PT0hMClmb3IoO2Iubm9kZS5pc0ZpcnN0U2libGluZyhhLmdldCgwKSkmJiFhLnBhcmVudCgpLmlzKGIuJGVsKSYmIWEucGFyZW50KCkuaXMoXFxcIm9sXFxcIikmJiFhLnBhcmVudCgpLmlzKFxcXCJ1bFxcXCIpOylhLnBhcmVudCgpLmJlZm9yZShhKSxoPSEwO2Vsc2UgaWYoYS5kYXRhKFxcXCJ0eXBlXFxcIik9PT0hMSlmb3IoO2Iubm9kZS5pc0xhc3RTaWJsaW5nKGEuZ2V0KDApKSYmIWEucGFyZW50KCkuaXMoYi4kZWwpJiYhYS5wYXJlbnQoKS5pcyhcXFwib2xcXFwiKSYmIWEucGFyZW50KCkuaXMoXFxcInVsXFxcIik7KWEucGFyZW50KCkuYWZ0ZXIoYSksaD0hMDtpZihoKXJldHVybiEwfWlmKGEucGFyZW50cyhjKS5sZW5ndGh8fFxcXCJ1bmRlZmluZWRcXFwiPT10eXBlb2YgYyl7dmFyIGk9XFxcIlxcXCIsaj1cXFwiXFxcIixrPWEucGFyZW50KCk7aWYoay5pcyhiLiRlbCl8fGIubm9kZS5pc0Jsb2NrKGsuZ2V0KDApKSlyZXR1cm4hMTtmb3IoOyFiLm5vZGUuaXNCbG9jayhrLnBhcmVudCgpLmdldCgwKSkmJihcXFwidW5kZWZpbmVkXFxcIj09dHlwZW9mIGN8fFxcXCJ1bmRlZmluZWRcXFwiIT10eXBlb2YgYyYmIWYoay5nZXQoMCksZShjLGQpKSk7KWkrPWIubm9kZS5jbG9zZVRhZ1N0cmluZyhrLmdldCgwKSksaj1iLm5vZGUub3BlblRhZ1N0cmluZyhrLmdldCgwKSkraixrPWsucGFyZW50KCk7dmFyIGw9YS5nZXQoMCkub3V0ZXJIVE1MO2EucmVwbGFjZVdpdGgoJzxzcGFuIGlkPVxcXCJtYXJrXFxcIj48L3NwYW4+Jyk7dmFyIG09ay5odG1sKCkucmVwbGFjZSgvPHNwYW4gaWQ9XFxcIm1hcmtcXFwiPjxcXFxcL3NwYW4+LyxpK2Iubm9kZS5jbG9zZVRhZ1N0cmluZyhrLmdldCgwKSkraitsK2krYi5ub2RlLm9wZW5UYWdTdHJpbmcoay5nZXQoMCkpK2opO3JldHVybiBrLnJlcGxhY2VXaXRoKGIubm9kZS5vcGVuVGFnU3RyaW5nKGsuZ2V0KDApKSttK2Iubm9kZS5jbG9zZVRhZ1N0cmluZyhrLmdldCgwKSkpLCEwfXJldHVybiExfWZ1bmN0aW9uIGooYyxkLGcsaCl7Zm9yKHZhciBpPWIubm9kZS5jb250ZW50cyhjLmdldCgwKSksaz0wO2s8aS5sZW5ndGg7aysrKXt2YXIgbD1pW2tdO2lmKGIubm9kZS5oYXNDbGFzcyhsLFxcXCJmci1tYXJrZXJcXFwiKSlkPShkKzEpJTI7ZWxzZSBpZihkKWlmKGEobCkuZmluZChcXFwiLmZyLW1hcmtlclxcXCIpLmxlbmd0aD4wKWQ9aihhKGwpLGQsZyxoKTtlbHNle2Zvcih2YXIgbT1hKGwpLmZpbmQoZ3x8XFxcIipcXFwiKSxuPW0ubGVuZ3RoLTE7bj49MDtuLS0pe3ZhciBvPW1bbl07Yi5ub2RlLmlzQmxvY2sobyl8fGIubm9kZS5pc1ZvaWQobyl8fFxcXCJ1bmRlZmluZWRcXFwiIT10eXBlb2YgZyYmIWYobyxlKGcsaCkpfHwoby5vdXRlckhUTUw9by5pbm5lckhUTUwpfVxcXCJ1bmRlZmluZWRcXFwiPT10eXBlb2YgZyYmbC5ub2RlVHlwZT09Tm9kZS5FTEVNRU5UX05PREUmJiFiLm5vZGUuaXNWb2lkKGwpJiYhYi5ub2RlLmlzQmxvY2sobCl8fGYobCxlKGcsaCkpP2EobCkucmVwbGFjZVdpdGgobC5pbm5lckhUTUwpOlxcXCJ1bmRlZmluZWRcXFwiPT10eXBlb2YgZyYmbC5ub2RlVHlwZT09Tm9kZS5FTEVNRU5UX05PREUmJmIubm9kZS5pc0Jsb2NrKGwpJiZiLm5vZGUuY2xlYXJBdHRyaWJ1dGVzKGwpfWVsc2UgYShsKS5maW5kKFxcXCIuZnItbWFya2VyXFxcIikubGVuZ3RoPjAmJihkPWooYShsKSxkLGcsaCkpfXJldHVybiBkfWZ1bmN0aW9uIGsoYyxkKXtcXFwidW5kZWZpbmVkXFxcIj09dHlwZW9mIGQmJihkPXt9KSxkLnN0eWxlJiZkZWxldGUgZC5zdHlsZTt2YXIgZT1iLnNlbGVjdGlvbi5pc0NvbGxhcHNlZCgpO2Iuc2VsZWN0aW9uLnNhdmUoKTtmb3IodmFyIGY9ITA7Zjspe2Y9ITE7Zm9yKHZhciBnPWIuJGVsLmZpbmQoXFxcIi5mci1tYXJrZXJcXFwiKSxoPTA7aDxnLmxlbmd0aDtoKyspaWYoaShhKGdbaF0pLGMsZCxlKSl7Zj0hMDticmVha319aihiLiRlbCwwLGMsZCksZSYmYi4kZWwuZmluZChcXFwiLmZyLW1hcmtlclxcXCIpLmJlZm9yZShhLkZFLklOVklTSUJMRV9TUEFDRSkuYWZ0ZXIoYS5GRS5JTlZJU0lCTEVfU1BBQ0UpLGIuaHRtbC5jbGVhbkVtcHR5VGFncygpLGIuZWwubm9ybWFsaXplKCksYi5zZWxlY3Rpb24ucmVzdG9yZSgpfWZ1bmN0aW9uIGwoYSxiKXtxKGEsYik/ayhhLGIpOmgoYSxiKX1mdW5jdGlvbiBtKGIsYyl7dmFyIGQ9YShiKTtkLmNzcyhjLFxcXCJcXFwiKSxcXFwiXFxcIj09PWQuYXR0cihcXFwic3R5bGVcXFwiKSYmZC5yZXBsYWNlV2l0aChkLmh0bWwoKSl9ZnVuY3Rpb24gbihiLGMpe3JldHVybiAwPT09YShiKS5hdHRyKFxcXCJzdHlsZVxcXCIpLmluZGV4T2YoYytcXFwiOlxcXCIpfHxhKGIpLmF0dHIoXFxcInN0eWxlXFxcIikuaW5kZXhPZihcXFwiO1xcXCIrYytcXFwiOlxcXCIpPj0wfHxhKGIpLmF0dHIoXFxcInN0eWxlXFxcIikuaW5kZXhPZihcXFwiOyBcXFwiK2MrXFxcIjpcXFwiKT49MH1mdW5jdGlvbiBvKGMsZCl7dmFyIGUsZjtpZihiLnNlbGVjdGlvbi5pc0NvbGxhcHNlZCgpKXtiLm1hcmtlcnMuaW5zZXJ0KCksZj1iLiRlbC5maW5kKFxcXCIuZnItbWFya2VyXFxcIik7dmFyIGg9Zi5wYXJlbnQoKTtpZihiLm5vZGUub3BlblRhZ1N0cmluZyhoLmdldCgwKSk9PSc8c3BhbiBzdHlsZT1cXFwiJytjK1xcXCI6IFxcXCIraC5jc3MoYykrJztcXFwiPicpe2lmKGIubm9kZS5pc0VtcHR5KGguZ2V0KDApKSloLnJlcGxhY2VXaXRoKCc8c3BhbiBzdHlsZT1cXFwiJytjK1xcXCI6IFxcXCIrZCsnO1xcXCI+JythLkZFLklOVklTSUJMRV9TUEFDRSthLkZFLk1BUktFUlMrXFxcIjwvc3Bhbj5cXFwiKTtlbHNle3ZhciBqPXt9O2pbY109ZCxpKGYsXFxcInNwYW5cXFwiLGosITApLGY9Yi4kZWwuZmluZChcXFwiLmZyLW1hcmtlclxcXCIpLGYucmVwbGFjZVdpdGgoJzxzcGFuIHN0eWxlPVxcXCInK2MrXFxcIjogXFxcIitkKyc7XFxcIj4nK2EuRkUuSU5WSVNJQkxFX1NQQUNFK2EuRkUuTUFSS0VSUytcXFwiPC9zcGFuPlxcXCIpfWIuaHRtbC5jbGVhbkVtcHR5VGFncygpfWVsc2UgYi5ub2RlLmlzRW1wdHkoaC5nZXQoMCkpJiZoLmlzKFxcXCJzcGFuXFxcIik/KGYucmVwbGFjZVdpdGgoYS5GRS5NQVJLRVJTKSxoLmNzcyhjLGQpKTpmLnJlcGxhY2VXaXRoKCc8c3BhbiBzdHlsZT1cXFwiJytjK1xcXCI6IFxcXCIrZCsnO1xcXCI+JythLkZFLklOVklTSUJMRV9TUEFDRSthLkZFLk1BUktFUlMrXFxcIjwvc3Bhbj5cXFwiKTtiLnNlbGVjdGlvbi5yZXN0b3JlKCl9ZWxzZXtpZihiLnNlbGVjdGlvbi5zYXZlKCksbnVsbD09ZHx8XFxcImNvbG9yXFxcIj09YyYmYi4kZWwuZmluZChcXFwiLmZyLW1hcmtlclxcXCIpLnBhcmVudHMoXFxcInUsIGFcXFwiKS5sZW5ndGg+MCl7dmFyIGs9Yi4kZWwuZmluZChcXFwiLmZyLW1hcmtlclxcXCIpO2ZvcihlPTA7ZTxrLmxlbmd0aDtlKyspaWYoZj1hKGtbZV0pLGYuZGF0YShcXFwidHlwZVxcXCIpPT09ITApZm9yKDtiLm5vZGUuaXNGaXJzdFNpYmxpbmcoZi5nZXQoMCkpJiYhZi5wYXJlbnQoKS5pcyhiLiRlbCkmJiFiLm5vZGUuaXNFbGVtZW50KGYucGFyZW50KCkuZ2V0KDApKSYmIWIubm9kZS5pc0Jsb2NrKGYucGFyZW50KCkuZ2V0KDApKTspZi5wYXJlbnQoKS5iZWZvcmUoZik7ZWxzZSBmb3IoO2Iubm9kZS5pc0xhc3RTaWJsaW5nKGYuZ2V0KDApKSYmIWYucGFyZW50KCkuaXMoYi4kZWwpJiYhYi5ub2RlLmlzRWxlbWVudChmLnBhcmVudCgpLmdldCgwKSkmJiFiLm5vZGUuaXNCbG9jayhmLnBhcmVudCgpLmdldCgwKSk7KWYucGFyZW50KCkuYWZ0ZXIoZil9dmFyIGw9Yi4kZWwuZmluZCgnLmZyLW1hcmtlcltkYXRhLXR5cGU9XFxcInRydWVcXFwiXScpLmdldCgwKS5uZXh0U2libGluZyxvPXtjbGFzczpcXFwiZnItdW5wcm9jZXNzZWRcXFwifTtmb3IoZCYmKG8uc3R5bGU9YytcXFwiOiBcXFwiK2QrXFxcIjtcXFwiKSxnKGwsXFxcInNwYW5cXFwiLG8pLGIuJGVsLmZpbmQoXFxcIi5mci1tYXJrZXIgKyAuZnItdW5wcm9jZXNzZWRcXFwiKS5lYWNoKGZ1bmN0aW9uKCl7YSh0aGlzKS5wcmVwZW5kKGEodGhpcykucHJldigpKX0pLGIuJGVsLmZpbmQoXFxcIi5mci11bnByb2Nlc3NlZCArIC5mci1tYXJrZXJcXFwiKS5lYWNoKGZ1bmN0aW9uKCl7YSh0aGlzKS5wcmV2KCkuYXBwZW5kKHRoaXMpfSk7Yi4kZWwuZmluZChcXFwic3Bhbi5mci11bnByb2Nlc3NlZFxcXCIpLmxlbmd0aD4wOyl7dmFyIHA9Yi4kZWwuZmluZChcXFwic3Bhbi5mci11bnByb2Nlc3NlZDpmaXJzdFxcXCIpLnJlbW92ZUNsYXNzKFxcXCJmci11bnByb2Nlc3NlZFxcXCIpO2lmKHAucGFyZW50KCkuZ2V0KDApLm5vcm1hbGl6ZSgpLHAucGFyZW50KCkuaXMoXFxcInNwYW5cXFwiKSYmMT09cC5wYXJlbnQoKS5nZXQoMCkuY2hpbGROb2Rlcy5sZW5ndGgpe3AucGFyZW50KCkuY3NzKGMsZCk7dmFyIHE9cDtwPXAucGFyZW50KCkscS5yZXBsYWNlV2l0aChxLmh0bWwoKSl9dmFyIHI9cC5maW5kKFxcXCJzcGFuXFxcIik7Zm9yKGU9ci5sZW5ndGgtMTtlPj0wO2UtLSltKHJbZV0sYyk7dmFyIHM9cC5wYXJlbnRzVW50aWwoYi4kZWwsXFxcInNwYW5bc3R5bGVdXFxcIiksdD1bXTtmb3IoZT1zLmxlbmd0aC0xO2U+PTA7ZS0tKW4oc1tlXSxjKXx8dC5wdXNoKHNbZV0pO2lmKHM9cy5ub3QodCkscy5sZW5ndGgpe3ZhciB1PVxcXCJcXFwiLHY9XFxcIlxcXCIsdz1cXFwiXFxcIix4PVxcXCJcXFwiLHk9cC5nZXQoMCk7ZG8geT15LnBhcmVudE5vZGUsYSh5KS5hZGRDbGFzcyhcXFwiZnItc3BsaXRcXFwiKSx1Kz1iLm5vZGUuY2xvc2VUYWdTdHJpbmcoeSksdj1iLm5vZGUub3BlblRhZ1N0cmluZyhhKHkpLmNsb25lKCkuYWRkQ2xhc3MoXFxcImZyLXNwbGl0XFxcIikuZ2V0KDApKSt2LHMuZ2V0KDApIT15JiYodys9Yi5ub2RlLmNsb3NlVGFnU3RyaW5nKHkpLHg9Yi5ub2RlLm9wZW5UYWdTdHJpbmcoYSh5KS5jbG9uZSgpLmFkZENsYXNzKFxcXCJmci1zcGxpdFxcXCIpLmdldCgwKSkreCk7d2hpbGUocy5nZXQoMCkhPXkpO3ZhciB6PXUrYi5ub2RlLm9wZW5UYWdTdHJpbmcoYShzLmdldCgwKSkuY2xvbmUoKS5jc3MoYyxkfHxcXFwiXFxcIikuZ2V0KDApKSt4K3AuY3NzKGMsXFxcIlxcXCIpLmdldCgwKS5vdXRlckhUTUwrdytcXFwiPC9zcGFuPlxcXCIrdjtwLnJlcGxhY2VXaXRoKCc8c3BhbiBpZD1cXFwiZnItYnJlYWtcXFwiPjwvc3Bhbj4nKTt2YXIgQT1zLmdldCgwKS5vdXRlckhUTUw7YShzLmdldCgwKSkucmVwbGFjZVdpdGgoQS5yZXBsYWNlKC88c3BhbiBpZD1cXFwiZnItYnJlYWtcXFwiPjxcXFxcL3NwYW4+L2cseikpfX1mb3IoO2IuJGVsLmZpbmQoXFxcIi5mci1zcGxpdDplbXB0eVxcXCIpLmxlbmd0aD4wOyliLiRlbC5maW5kKFxcXCIuZnItc3BsaXQ6ZW1wdHlcXFwiKS5yZW1vdmUoKTtiLiRlbC5maW5kKFxcXCIuZnItc3BsaXRcXFwiKS5yZW1vdmVDbGFzcyhcXFwiZnItc3BsaXRcXFwiKSxiLiRlbC5maW5kKCdzcGFuW3N0eWxlPVxcXCJcXFwiXScpLnJlbW92ZUF0dHIoXFxcInN0eWxlXFxcIiksYi4kZWwuZmluZCgnc3BhbltjbGFzcz1cXFwiXFxcIl0nKS5yZW1vdmVBdHRyKFxcXCJjbGFzc1xcXCIpLGIuaHRtbC5jbGVhbkVtcHR5VGFncygpLGEoYi4kZWwuZmluZChcXFwic3BhblxcXCIpLmdldCgpLnJldmVyc2UoKSkuZWFjaChmdW5jdGlvbigpe3RoaXMuYXR0cmlidXRlcyYmMCE9PXRoaXMuYXR0cmlidXRlcy5sZW5ndGh8fGEodGhpcykucmVwbGFjZVdpdGgodGhpcy5pbm5lckhUTUwpfSksYi5lbC5ub3JtYWxpemUoKTt2YXIgQj1iLiRlbC5maW5kKFxcXCJzcGFuW3N0eWxlXSArIHNwYW5bc3R5bGVdXFxcIik7Zm9yKGU9MDtlPEIubGVuZ3RoO2UrKyl7dmFyIEM9YShCW2VdKSxEPWEoQltlXSkucHJldigpO0MuZ2V0KDApLnByZXZpb3VzU2libGluZz09RC5nZXQoMCkmJmIubm9kZS5vcGVuVGFnU3RyaW5nKEMuZ2V0KDApKT09Yi5ub2RlLm9wZW5UYWdTdHJpbmcoRC5nZXQoMCkpJiYoQy5wcmVwZW5kKEQuaHRtbCgpKSxELnJlbW92ZSgpKX1iLiRlbC5maW5kKFxcXCJzcGFuW3N0eWxlXSBzcGFuW3N0eWxlXVxcXCIpLmVhY2goZnVuY3Rpb24oKXtpZihhKHRoaXMpLmF0dHIoXFxcInN0eWxlXFxcIikuaW5kZXhPZihcXFwiZm9udC1zaXplXFxcIik+PTApe3ZhciBiPWEodGhpcykucGFyZW50cyhcXFwic3BhbltzdHlsZV1cXFwiKTtiLmF0dHIoXFxcInN0eWxlXFxcIikuaW5kZXhPZihcXFwiYmFja2dyb3VuZC1jb2xvclxcXCIpPj0wJiYoYSh0aGlzKS5hdHRyKFxcXCJzdHlsZVxcXCIsYSh0aGlzKS5hdHRyKFxcXCJzdHlsZVxcXCIpK1xcXCI7XFxcIitiLmF0dHIoXFxcInN0eWxlXFxcIikpLGkoYSh0aGlzKSxcXFwic3BhbltzdHlsZV1cXFwiLHt9LCExKSl9fSksYi5lbC5ub3JtYWxpemUoKSxiLnNlbGVjdGlvbi5yZXN0b3JlKCl9fWZ1bmN0aW9uIHAoYSl7byhhLG51bGwpfWZ1bmN0aW9uIHEoYSxjKXtcXFwidW5kZWZpbmVkXFxcIj09dHlwZW9mIGMmJihjPXt9KSxjLnN0eWxlJiZkZWxldGUgYy5zdHlsZTt2YXIgZD1iLnNlbGVjdGlvbi5yYW5nZXMoMCksZz1kLnN0YXJ0Q29udGFpbmVyO2cubm9kZVR5cGU9PU5vZGUuRUxFTUVOVF9OT0RFJiZnLmNoaWxkTm9kZXMubGVuZ3RoPjAmJmcuY2hpbGROb2Rlc1tkLnN0YXJ0T2Zmc2V0XSYmKGc9Zy5jaGlsZE5vZGVzW2Quc3RhcnRPZmZzZXRdKTtmb3IodmFyIGg9ZztoJiZoLm5vZGVUeXBlPT1Ob2RlLkVMRU1FTlRfTk9ERSYmIWYoaCxlKGEsYykpOyloPWguZmlyc3RDaGlsZDtpZihoJiZoLm5vZGVUeXBlPT1Ob2RlLkVMRU1FTlRfTk9ERSYmZihoLGUoYSxjKSkpcmV0dXJuITA7dmFyIGk9Zztmb3IoaSYmaS5ub2RlVHlwZSE9Tm9kZS5FTEVNRU5UX05PREUmJihpPWkucGFyZW50Tm9kZSk7aSYmaS5ub2RlVHlwZT09Tm9kZS5FTEVNRU5UX05PREUmJmkhPWIuZWwmJiFmKGksZShhLGMpKTspaT1pLnBhcmVudE5vZGU7cmV0dXJuISghaXx8aS5ub2RlVHlwZSE9Tm9kZS5FTEVNRU5UX05PREV8fGk9PWIuZWx8fCFmKGksZShhLGMpKSl9cmV0dXJue2lzOnEsdG9nZ2xlOmwsYXBwbHk6aCxyZW1vdmU6ayxhcHBseVN0eWxlOm8scmVtb3ZlU3R5bGU6cH19LGEuRkUuQ09NTUFORFM9e2JvbGQ6e3RpdGxlOlxcXCJCb2xkXFxcIix0b2dnbGU6ITAscmVmcmVzaDpmdW5jdGlvbihhKXt2YXIgYj10aGlzLmZvcm1hdC5pcyhcXFwic3Ryb25nXFxcIik7YS50b2dnbGVDbGFzcyhcXFwiZnItYWN0aXZlXFxcIixiKS5hdHRyKFxcXCJhcmlhLXByZXNzZWRcXFwiLGIpfX0saXRhbGljOnt0aXRsZTpcXFwiSXRhbGljXFxcIix0b2dnbGU6ITAscmVmcmVzaDpmdW5jdGlvbihhKXt2YXIgYj10aGlzLmZvcm1hdC5pcyhcXFwiZW1cXFwiKTthLnRvZ2dsZUNsYXNzKFxcXCJmci1hY3RpdmVcXFwiLGIpLmF0dHIoXFxcImFyaWEtcHJlc3NlZFxcXCIsYil9fSx1bmRlcmxpbmU6e3RpdGxlOlxcXCJVbmRlcmxpbmVcXFwiLHRvZ2dsZTohMCxyZWZyZXNoOmZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMuZm9ybWF0LmlzKFxcXCJ1XFxcIik7YS50b2dnbGVDbGFzcyhcXFwiZnItYWN0aXZlXFxcIixiKS5hdHRyKFxcXCJhcmlhLXByZXNzZWRcXFwiLGIpfX0sc3RyaWtlVGhyb3VnaDp7dGl0bGU6XFxcIlN0cmlrZXRocm91Z2hcXFwiLHRvZ2dsZTohMCxyZWZyZXNoOmZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMuZm9ybWF0LmlzKFxcXCJzXFxcIik7YS50b2dnbGVDbGFzcyhcXFwiZnItYWN0aXZlXFxcIixiKS5hdHRyKFxcXCJhcmlhLXByZXNzZWRcXFwiLGIpfX0sc3Vic2NyaXB0Ont0aXRsZTpcXFwiU3Vic2NyaXB0XFxcIix0b2dnbGU6ITAscmVmcmVzaDpmdW5jdGlvbihhKXt2YXIgYj10aGlzLmZvcm1hdC5pcyhcXFwic3ViXFxcIik7YS50b2dnbGVDbGFzcyhcXFwiZnItYWN0aXZlXFxcIixiKS5hdHRyKFxcXCJhcmlhLXByZXNzZWRcXFwiLGIpfX0sc3VwZXJzY3JpcHQ6e3RpdGxlOlxcXCJTdXBlcnNjcmlwdFxcXCIsdG9nZ2xlOiEwLHJlZnJlc2g6ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5mb3JtYXQuaXMoXFxcInN1cFxcXCIpO2EudG9nZ2xlQ2xhc3MoXFxcImZyLWFjdGl2ZVxcXCIsYikuYXR0cihcXFwiYXJpYS1wcmVzc2VkXFxcIixiKX19LG91dGRlbnQ6e3RpdGxlOlxcXCJEZWNyZWFzZSBJbmRlbnRcXFwifSxpbmRlbnQ6e3RpdGxlOlxcXCJJbmNyZWFzZSBJbmRlbnRcXFwifSx1bmRvOnt0aXRsZTpcXFwiVW5kb1xcXCIsdW5kbzohMSxmb3JjZWRSZWZyZXNoOiEwLGRpc2FibGVkOiEwfSxyZWRvOnt0aXRsZTpcXFwiUmVkb1xcXCIsdW5kbzohMSxmb3JjZWRSZWZyZXNoOiEwLGRpc2FibGVkOiEwfSxpbnNlcnRIUjp7dGl0bGU6XFxcIkluc2VydCBIb3Jpem9udGFsIExpbmVcXFwifSxjbGVhckZvcm1hdHRpbmc6e3RpdGxlOlxcXCJDbGVhciBGb3JtYXR0aW5nXFxcIn0sc2VsZWN0QWxsOnt0aXRsZTpcXFwiU2VsZWN0IEFsbFxcXCIsdW5kbzohMX19LGEuRkUuUmVnaXN0ZXJDb21tYW5kPWZ1bmN0aW9uKGIsYyl7YS5GRS5DT01NQU5EU1tiXT1jfSxhLkZFLk1PRFVMRVMuY29tbWFuZHM9ZnVuY3Rpb24oYil7ZnVuY3Rpb24gYyhhKXtyZXR1cm4gYi5odG1sLmRlZmF1bHRUYWcoKSYmKGE9XFxcIjxcXFwiK2IuaHRtbC5kZWZhdWx0VGFnKCkrXFxcIj5cXFwiK2ErXFxcIjwvXFxcIitiLmh0bWwuZGVmYXVsdFRhZygpK1xcXCI+XFxcIiksYX1mdW5jdGlvbiBkKGMsZCl7aWYoYi5ldmVudHMudHJpZ2dlcihcXFwiY29tbWFuZHMuYmVmb3JlXFxcIixhLm1lcmdlKFtjXSxkfHxbXSkpIT09ITEpe3ZhciBlPWEuRkUuQ09NTUFORFNbY10mJmEuRkUuQ09NTUFORFNbY10uY2FsbGJhY2t8fGlbY10sZj0hMCxnPSExO2EuRkUuQ09NTUFORFNbY10mJihcXFwidW5kZWZpbmVkXFxcIiE9dHlwZW9mIGEuRkUuQ09NTUFORFNbY10uZm9jdXMmJihmPWEuRkUuQ09NTUFORFNbY10uZm9jdXMpLFxcXCJ1bmRlZmluZWRcXFwiIT10eXBlb2YgYS5GRS5DT01NQU5EU1tjXS5hY2Nlc3NpYmlsaXR5Rm9jdXMmJihnPWEuRkUuQ09NTUFORFNbY10uYWNjZXNzaWJpbGl0eUZvY3VzKSksKCFiLmNvcmUuaGFzRm9jdXMoKSYmZiYmIWIucG9wdXBzLmFyZVZpc2libGUoKXx8IWIuY29yZS5oYXNGb2N1cygpJiZnJiZiLmFjY2Vzc2liaWxpdHkuaGFzRm9jdXMoKSkmJmIuZXZlbnRzLmZvY3VzKCEwKSxhLkZFLkNPTU1BTkRTW2NdJiZhLkZFLkNPTU1BTkRTW2NdLnVuZG8hPT0hMSYmKGIuJGVsLmZpbmQoXFxcIi5mci1tYXJrZXJcXFwiKS5sZW5ndGgmJihiLmV2ZW50cy5kaXNhYmxlQmx1cigpLGIuc2VsZWN0aW9uLnJlc3RvcmUoKSksYi51bmRvLnNhdmVTdGVwKCkpLGUmJmUuYXBwbHkoYixhLm1lcmdlKFtjXSxkfHxbXSkpLGIuZXZlbnRzLnRyaWdnZXIoXFxcImNvbW1hbmRzLmFmdGVyXFxcIixhLm1lcmdlKFtjXSxkfHxbXSkpLGEuRkUuQ09NTUFORFNbY10mJmEuRkUuQ09NTUFORFNbY10udW5kbyE9PSExJiZiLnVuZG8uc2F2ZVN0ZXAoKX19ZnVuY3Rpb24gZShhLGMpe2IuZm9ybWF0LnRvZ2dsZShjKX1mdW5jdGlvbiBmKGMpe2Iuc2VsZWN0aW9uLnNhdmUoKSxiLmh0bWwud3JhcCghMCwhMCwhMCwhMCksYi5zZWxlY3Rpb24ucmVzdG9yZSgpO2Zvcih2YXIgZD1iLnNlbGVjdGlvbi5ibG9ja3MoKSxlPTA7ZTxkLmxlbmd0aDtlKyspaWYoXFxcIkxJXFxcIiE9ZFtlXS50YWdOYW1lJiZcXFwiTElcXFwiIT1kW2VdLnBhcmVudE5vZGUudGFnTmFtZSl7dmFyIGY9YShkW2VdKSxnPVxcXCJydGxcXFwiPT1iLm9wdHMuZGlyZWN0aW9ufHxcXFwicnRsXFxcIj09Zi5jc3MoXFxcImRpcmVjdGlvblxcXCIpP1xcXCJtYXJnaW4tcmlnaHRcXFwiOlxcXCJtYXJnaW4tbGVmdFxcXCIsaD1iLmhlbHBlcnMuZ2V0UFgoZi5jc3MoZykpO2YuY3NzKGcsTWF0aC5tYXgoaCsyMCpjLDApfHxcXFwiXFxcIiksZi5yZW1vdmVDbGFzcyhcXFwiZnItdGVtcC1kaXZcXFwiKX1iLnNlbGVjdGlvbi5zYXZlKCksYi5odG1sLnVud3JhcCgpLGIuc2VsZWN0aW9uLnJlc3RvcmUoKX1mdW5jdGlvbiBnKGEpe3JldHVybiBmdW5jdGlvbigpe2QoYSl9fWZ1bmN0aW9uIGgoKXtiLmV2ZW50cy5vbihcXFwia2V5ZG93blxcXCIsZnVuY3Rpb24oYSl7dmFyIGM9Yi5zZWxlY3Rpb24uZWxlbWVudCgpO2lmKGMmJlxcXCJIUlxcXCI9PWMudGFnTmFtZSYmIWIua2V5cy5pc0Fycm93KGEud2hpY2gpKXJldHVybiBhLnByZXZlbnREZWZhdWx0KCksITF9KSxiLmV2ZW50cy5vbihcXFwia2V5dXBcXFwiLGZ1bmN0aW9uKGMpe3ZhciBkPWIuc2VsZWN0aW9uLmVsZW1lbnQoKTtpZihkJiZcXFwiSFJcXFwiPT1kLnRhZ05hbWUpaWYoYy53aGljaD09YS5GRS5LRVlDT0RFLkFSUk9XX0xFRlR8fGMud2hpY2g9PWEuRkUuS0VZQ09ERS5BUlJPV19VUCl7aWYoZC5wcmV2aW91c1NpYmxpbmcpcmV0dXJuIGIubm9kZS5pc0Jsb2NrKGQucHJldmlvdXNTaWJsaW5nKT9iLnNlbGVjdGlvbi5zZXRBdEVuZChkLnByZXZpb3VzU2libGluZyk6YShkKS5iZWZvcmUoYS5GRS5NQVJLRVJTKSxiLnNlbGVjdGlvbi5yZXN0b3JlKCksITF9ZWxzZSBpZigoYy53aGljaD09YS5GRS5LRVlDT0RFLkFSUk9XX1JJR0hUfHxjLndoaWNoPT1hLkZFLktFWUNPREUuQVJST1dfRE9XTikmJmQubmV4dFNpYmxpbmcpcmV0dXJuIGIubm9kZS5pc0Jsb2NrKGQubmV4dFNpYmxpbmcpP2Iuc2VsZWN0aW9uLnNldEF0U3RhcnQoZC5uZXh0U2libGluZyk6YShkKS5hZnRlcihhLkZFLk1BUktFUlMpLGIuc2VsZWN0aW9uLnJlc3RvcmUoKSwhMX0pLGIuZXZlbnRzLm9uKFxcXCJtb3VzZWRvd25cXFwiLGZ1bmN0aW9uKGEpe2lmKGEudGFyZ2V0JiZcXFwiSFJcXFwiPT1hLnRhcmdldC50YWdOYW1lKXJldHVybiBhLnByZXZlbnREZWZhdWx0KCksYS5zdG9wUHJvcGFnYXRpb24oKSwhMX0pLGIuZXZlbnRzLm9uKFxcXCJtb3VzZXVwXFxcIixmdW5jdGlvbigpe3ZhciBjPWIuc2VsZWN0aW9uLmVsZW1lbnQoKSxkPWIuc2VsZWN0aW9uLmVuZEVsZW1lbnQoKTtjPT1kJiZjJiZcXFwiSFJcXFwiPT1jLnRhZ05hbWUmJihjLm5leHRTaWJsaW5nJiYoYi5ub2RlLmlzQmxvY2soYy5uZXh0U2libGluZyk/Yi5zZWxlY3Rpb24uc2V0QXRTdGFydChjLm5leHRTaWJsaW5nKTphKGMpLmFmdGVyKGEuRkUuTUFSS0VSUykpLGIuc2VsZWN0aW9uLnJlc3RvcmUoKSl9KX12YXIgaT17Ym9sZDpmdW5jdGlvbigpe2UoXFxcImJvbGRcXFwiLFxcXCJzdHJvbmdcXFwiKX0sc3Vic2NyaXB0OmZ1bmN0aW9uKCl7ZShcXFwic3Vic2NyaXB0XFxcIixcXFwic3ViXFxcIil9LHN1cGVyc2NyaXB0OmZ1bmN0aW9uKCl7ZShcXFwic3VwZXJzY3JpcHRcXFwiLFxcXCJzdXBcXFwiKX0saXRhbGljOmZ1bmN0aW9uKCl7ZShcXFwiaXRhbGljXFxcIixcXFwiZW1cXFwiKX0sc3RyaWtlVGhyb3VnaDpmdW5jdGlvbigpe2UoXFxcInN0cmlrZVRocm91Z2hcXFwiLFxcXCJzXFxcIil9LHVuZGVybGluZTpmdW5jdGlvbigpe2UoXFxcInVuZGVybGluZVxcXCIsXFxcInVcXFwiKX0sdW5kbzpmdW5jdGlvbigpe2IudW5kby5ydW4oKX0scmVkbzpmdW5jdGlvbigpe2IudW5kby5yZWRvKCl9LGluZGVudDpmdW5jdGlvbigpe2YoMSl9LG91dGRlbnQ6ZnVuY3Rpb24oKXtmKC0xKX0sc2hvdzpmdW5jdGlvbigpe2Iub3B0cy50b29sYmFySW5saW5lJiZiLnRvb2xiYXIuc2hvd0lubGluZShudWxsLCEwKX0saW5zZXJ0SFI6ZnVuY3Rpb24oKXtiLnNlbGVjdGlvbi5yZW1vdmUoKTt2YXIgZD1cXFwiXFxcIjtiLmNvcmUuaXNFbXB0eSgpJiYoZD1cXFwiPGJyPlxcXCIsZD1jKGQpKSxiLmh0bWwuaW5zZXJ0KCc8aHIgaWQ9XFxcImZyLWp1c3RcXFwiPicrZCk7dmFyIGU9Yi4kZWwuZmluZChcXFwiaHIjZnItanVzdFxcXCIpO2UucmVtb3ZlQXR0cihcXFwiaWRcXFwiKTt2YXIgZjtlLnByZXYoKS5pcyhcXFwiaHJcXFwiKT9mPWIuc2VsZWN0aW9uLnNldEFmdGVyKGUuZ2V0KDApLCExKTplLm5leHQoKS5pcyhcXFwiaHJcXFwiKT9mPWIuc2VsZWN0aW9uLnNldEJlZm9yZShlLmdldCgwKSwhMSk6Yi5zZWxlY3Rpb24uc2V0QWZ0ZXIoZS5nZXQoMCksITEpfHxiLnNlbGVjdGlvbi5zZXRCZWZvcmUoZS5nZXQoMCksITEpLGZ8fFxcXCJ1bmRlZmluZWRcXFwiPT10eXBlb2YgZnx8KGQ9YS5GRS5NQVJLRVJTK1xcXCI8YnI+XFxcIixkPWMoZCksZS5hZnRlcihkKSksYi5zZWxlY3Rpb24ucmVzdG9yZSgpfSxjbGVhckZvcm1hdHRpbmc6ZnVuY3Rpb24oKXtiLmZvcm1hdC5yZW1vdmUoKX0sc2VsZWN0QWxsOmZ1bmN0aW9uKCl7Yi5kb2MuZXhlY0NvbW1hbmQoXFxcInNlbGVjdEFsbFxcXCIsITEsITEpfX0saj17fTtmb3IodmFyIGsgaW4gaSlpLmhhc093blByb3BlcnR5KGspJiYoaltrXT1nKGspKTtyZXR1cm4gYS5leHRlbmQoaix7ZXhlYzpkLF9pbml0Omh9KX0sYS5GRS5NT0RVTEVTLmRhdGE9ZnVuY3Rpb24oYSl7ZnVuY3Rpb24gYihhKXtyZXR1cm4gYX1mdW5jdGlvbiBjKGEpe2lmKCFhKXJldHVybiBhO2Zvcih2YXIgYz1cXFwiXFxcIixmPWIoXFxcImNoYXJDb2RlQXRcXFwiKSxnPWIoXFxcImZyb21DaGFyQ29kZVxcXCIpLGg9bC5pbmRleE9mKGFbMF0pLGk9MTtpPGEubGVuZ3RoLTI7aSsrKXtmb3IodmFyIGo9ZCgrK2gpLGs9YVtmXShpKSxtPVxcXCJcXFwiOy9bMC05LV0vLnRlc3QoYVtpKzFdKTspbSs9YVsrK2ldO1xcbm09cGFyc2VJbnQobSwxMCl8fDAsaz1lKGssaixtKSxrXj1oLTEmMzEsYys9U3RyaW5nW2ddKGspfXJldHVybiBjfWZ1bmN0aW9uIGQoYSl7Zm9yKHZhciBiPWEudG9TdHJpbmcoKSxjPTAsZD0wO2Q8Yi5sZW5ndGg7ZCsrKWMrPXBhcnNlSW50KGIuY2hhckF0KGQpLDEwKTtyZXR1cm4gYz4xMD9jJTkrMTpjfWZ1bmN0aW9uIGUoYSxiLGMpe2Zvcih2YXIgZD1NYXRoLmFicyhjKTtkLS0gPjA7KWEtPWI7cmV0dXJuIGM8MCYmKGErPTEyMyksYX1mdW5jdGlvbiBmKGEpe3JldHVybiEoIWF8fFxcXCJub25lXFxcIiE9YS5jc3MoXFxcImRpc3BsYXlcXFwiKXx8KGEucmVtb3ZlKCksMCkpfWZ1bmN0aW9uIGcoKXtyZXR1cm4gZihqKXx8ZihrKX1mdW5jdGlvbiBoKCl7cmV0dXJuISFhLiRib3gmJihhLiRib3guYXBwZW5kKG4oYihuKFxcXCJub0xEMmxhQi03TkIxQzFlYmN2SC05U0IzYTFDNlFDMkQ0QS05ZDFFMkIyQjR4Z0FFNEIyRzJJMUMzQTNCMnFNRjFERTFma3hmY0MtMTFDLTlnMUcyRTRYQzlhMUU1QTNHLTEwbXZyaW9DQzNBQTFLQTFxSi03TkIyTUE2c3hlcVZBNlRENmUyRDRCLTlyWUEyYTFBNGJDRDN2d0MtN0VDMTBEM0UybE5DMUtEMVFCOVNCNlVFNVRFNFlGM1lBNWMxQTNkMUIza0dFMmdGQTVBMkQyY2gxS0kxSUIxdGh5SDV3dlZDMTFVQjZjMUY0d3d3WEE3Z21uZkIyamdCMUE3bmQxZTFJQzJORzRIMUE5Ymp2bmJDLThQRzNtbGF6RDRkSC05SEkycUFBMmpHQzJJQTFkYWphakZENVNHNEo0YzFxdHR5Qi05d2cxQjJiMkE2YjFDM0VHM0IySTJyQ0Q0RTFCMUxHMW9hTUEzUkU3YWJDLThDLTdhVkE0QzVCNUYtMTFlMUQzSTNhNUE4aG1tbm9nSDJJQjVBMm5oa2dpQTRUSDRWQzd5eGRibEgtOFlDNkQ2QzR4QzN5cUpKMkMtMjFzcEItMTFmTUYxS0YxSUMyVVNDNFBHNFRFM1JENlpGNVhFM1VFM3VlZmFGRTREMkcyQUUxSEEySkQxenp6UUUzU0Q5dmdxRjR1YTNCMTNYQTRDNWdkMUUzRTJBMTRyaWRzbGRjQ0E3TUM1Z2h3RS0xMVpINWYxRDNhMUQ4Ynd4bWt6aTFBN0lCM0t2cEItOHJ3TUQzSUUxR0ctMTBiZ3F3eGV3dldFNEgzVmJELTE2cUMtMTFxYzFFMlR3RUE2QTNhQ0U0QTFBNGxPRDNKQzFpVkEzUkExM2MyRDhvbHFmMUczQTMyQjE3PT1cXFwiKSkpKSxqPWEuJGJveC5maW5kKFxcXCI+IGRpdjpsYXN0XFxcIiksaz1qLmZpbmQoXFxcIj4gYVxcXCIpLHZvaWQoXFxcInJ0bFxcXCI9PWEub3B0cy5kaXJlY3Rpb24mJmouY3NzKFxcXCJsZWZ0XFxcIixcXFwiYXV0b1xcXCIpLmNzcyhcXFwicmlnaHRcXFwiLDApKSl9ZnVuY3Rpb24gaSgpe3ZhciBjPWxvY2FsU3RvcmFnZSYmbG9jYWxTdG9yYWdlLkZFS3x8YS5vcHRzLmtleXx8W1xcXCJcXFwiXTtcXFwic3RyaW5nXFxcIj09dHlwZW9mIGMmJihjPVtjXSksYS51bD0hMDtmb3IodmFyIGQ9MDtkPGMubGVuZ3RoO2QrKyl7dmFyIGU9bihjW2RdKXx8XFxcIlxcXCI7aWYoIShlIT09bihiKG4oXFxcIm1jVlJEb0IxQkdJTEQ3WUZlMUJUWEJBN0I2PT1cXFwiKSkpJiZlLmluZGV4T2YobSxlLmxlbmd0aC1tLmxlbmd0aCk8MCYmW24oXFxcIjlxcUctN2Ftamx3cT09XFxcIiksbihcXFwiS0EzQjNDMkE2RDFENUg1SDFBMz09XFxcIiksbihcXFwiUXpienZ4eUIyeUEtOW09PVxcXCIpLG4oXFxcIm5hYW1uZ2lBM2RBLTE2eHRFLTExQy05QjFILThzYz09XFxcIildLmluZGV4T2YobSk8MCkpe2EudWw9ITE7YnJlYWt9fWEudWw9PT0hMCYmaCgpLGEuZXZlbnRzLm9uKFxcXCJjb250ZW50Q2hhbmdlZFxcXCIsZnVuY3Rpb24oKXthLnVsPT09ITAmJmcoKSYmaCgpfSksYS5ldmVudHMub24oXFxcImRlc3Ryb3lcXFwiLGZ1bmN0aW9uKCl7aiYmai5sZW5ndGgmJmoucmVtb3ZlKCl9LCEwKX12YXIgaixrLGw9XFxcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5XFxcIixtPWZ1bmN0aW9uKCl7Zm9yKHZhciBhPTAsYj1kb2N1bWVudC5kb21haW4sYz1iLnNwbGl0KFxcXCIuXFxcIiksZD1cXFwiX2dkXFxcIisobmV3IERhdGUpLmdldFRpbWUoKTthPGMubGVuZ3RoLTEmJmRvY3VtZW50LmNvb2tpZS5pbmRleE9mKGQrXFxcIj1cXFwiK2QpPT0tMTspYj1jLnNsaWNlKC0xLSsrYSkuam9pbihcXFwiLlxcXCIpLGRvY3VtZW50LmNvb2tpZT1kK1xcXCI9XFxcIitkK1xcXCI7ZG9tYWluPVxcXCIrYitcXFwiO1xcXCI7cmV0dXJuIGRvY3VtZW50LmNvb2tpZT1kK1xcXCI9O2V4cGlyZXM9VGh1LCAwMSBKYW4gMTk3MCAwMDowMDowMSBHTVQ7ZG9tYWluPVxcXCIrYitcXFwiO1xcXCIsKGJ8fFxcXCJcXFwiKS5yZXBsYWNlKC8oXlxcXFwuKil8KFxcXFwuKiQpL2csXFxcIlxcXCIpfSgpLG49YihjKTtyZXR1cm57X2luaXQ6aX19LGEuZXh0ZW5kKGEuRkUuREVGQVVMVFMse3Bhc3RlUGxhaW46ITEscGFzdGVEZW5pZWRUYWdzOltcXFwiY29sZ3JvdXBcXFwiLFxcXCJjb2xcXFwiXSxwYXN0ZURlbmllZEF0dHJzOltcXFwiY2xhc3NcXFwiLFxcXCJpZFxcXCIsXFxcInN0eWxlXFxcIl0scGFzdGVBbGxvd2VkU3R5bGVQcm9wczpbXSxwYXN0ZUFsbG93TG9jYWxJbWFnZXM6ITF9KSxhLkZFLk1PRFVMRVMucGFzdGU9ZnVuY3Rpb24oYil7ZnVuY3Rpb24gYyhhLGMpe2Iud2luLmxvY2FsU3RvcmFnZS5zZXRJdGVtKFxcXCJmci1jb3BpZWQtaHRtbFxcXCIsYSksYi53aW4ubG9jYWxTdG9yYWdlLnNldEl0ZW0oXFxcImZyLWNvcGllZC10ZXh0XFxcIixjKX1mdW5jdGlvbiBkKGQpe3ZhciBlPWIuaHRtbC5nZXRTZWxlY3RlZCgpO2MoZSxhKFxcXCI8ZGl2PlxcXCIpLmh0bWwoZSkudGV4dCgpKSxcXFwiY3V0XFxcIj09ZC50eXBlJiYoYi51bmRvLnNhdmVTdGVwKCksc2V0VGltZW91dChmdW5jdGlvbigpe2Iuc2VsZWN0aW9uLnNhdmUoKSxiLmh0bWwud3JhcCgpLGIuc2VsZWN0aW9uLnJlc3RvcmUoKSxiLmV2ZW50cy5mb2N1cygpLGIudW5kby5zYXZlU3RlcCgpfSwwKSl9ZnVuY3Rpb24gZShhKXtpZihzKXJldHVybiExO2lmKGEub3JpZ2luYWxFdmVudCYmKGE9YS5vcmlnaW5hbEV2ZW50KSxiLmV2ZW50cy50cmlnZ2VyKFxcXCJwYXN0ZS5iZWZvcmVcXFwiLFthXSk9PT0hMSlyZXR1cm4gYS5wcmV2ZW50RGVmYXVsdCgpLCExO2lmKG89Yi4kd2luLnNjcm9sbFRvcCgpLGEmJmEuY2xpcGJvYXJkRGF0YSYmYS5jbGlwYm9hcmREYXRhLmdldERhdGEpe3ZhciBjPVxcXCJcXFwiLGQ9YS5jbGlwYm9hcmREYXRhLnR5cGVzO2lmKGIuaGVscGVycy5pc0FycmF5KGQpKWZvcih2YXIgZT0wO2U8ZC5sZW5ndGg7ZSsrKWMrPWRbZV0rXFxcIjtcXFwiO2Vsc2UgYz1kO2lmKHA9XFxcIlxcXCIscT1hLmNsaXBib2FyZERhdGEuZ2V0RGF0YShcXFwidGV4dC9ydGZcXFwiKSwvdGV4dFxcXFwvaHRtbC8udGVzdChjKT9wPWEuY2xpcGJvYXJkRGF0YS5nZXREYXRhKFxcXCJ0ZXh0L2h0bWxcXFwiKTovdGV4dFxcXFwvcnRmLy50ZXN0KGMpJiZiLmJyb3dzZXIuc2FmYXJpP3A9cTovdGV4dFxcXFwvcGxhaW4vLnRlc3QoYykmJiF0aGlzLmJyb3dzZXIubW96aWxsYSYmKHA9Yi5odG1sLmVzY2FwZUVudGl0aWVzKGEuY2xpcGJvYXJkRGF0YS5nZXREYXRhKFxcXCJ0ZXh0L3BsYWluXFxcIikpLnJlcGxhY2UoL1xcXFxuL2csXFxcIjxicj5cXFwiKSksXFxcIlxcXCIhPT1wKXJldHVybiBqKCksYS5wcmV2ZW50RGVmYXVsdCYmKGEuc3RvcFByb3BhZ2F0aW9uKCksYS5wcmV2ZW50RGVmYXVsdCgpKSwhMTtwPW51bGx9ZigpfWZ1bmN0aW9uIGYoKXtiLnNlbGVjdGlvbi5zYXZlKCksYi5ldmVudHMuZGlzYWJsZUJsdXIoKSxwPW51bGwscj9yLmh0bWwoXFxcIlxcXCIpOihyPWEoJzxkaXYgY29udGVudGVkaXRhYmxlPVxcXCJ0cnVlXFxcIiBzdHlsZT1cXFwicG9zaXRpb246IGZpeGVkOyB0b3A6IDA7IGxlZnQ6IC05OTk5cHg7IGhlaWdodDogMTAwJTsgd2lkdGg6IDA7IHdvcmQtYnJlYWs6IGJyZWFrLWFsbDsgb3ZlcmZsb3c6aGlkZGVuOyB6LWluZGV4OiA5OTk5OyBsaW5lLWhlaWdodDogMTQwJTtcXFwiIHRhYkluZGV4PVxcXCItMVxcXCI+PC9kaXY+JyksYi4kYm94LmFmdGVyKHIpLGIuZXZlbnRzLm9uKFxcXCJkZXN0cm95XFxcIixmdW5jdGlvbigpe3IucmVtb3ZlKCl9KSksci5mb2N1cygpLGIud2luLnNldFRpbWVvdXQoaiwxKX1mdW5jdGlvbiBnKGEpe3ZhciBjO2E9YS5yZXBsYWNlKC88cCguKj8pY2xhc3M9XFxcIj8nP01zb0xpc3RQYXJhZ3JhcGhcXFwiPyc/IChbXFxcXHNcXFxcU10qPyk+KFtcXFxcc1xcXFxTXSo/KTxcXFxcL3A+L2dpLFxcXCI8dWw+PGxpPiQzPC9saT48L3VsPlxcXCIpLGE9YS5yZXBsYWNlKC88cCguKj8pY2xhc3M9XFxcIj8nP051bWJlcmVkVGV4dFxcXCI/Jz8gKFtcXFxcc1xcXFxTXSo/KT4oW1xcXFxzXFxcXFNdKj8pPFxcXFwvcD4vZ2ksXFxcIjxvbD48bGk+JDM8L2xpPjwvb2w+XFxcIiksYT1hLnJlcGxhY2UoLzxwKC4qPyljbGFzcz1cXFwiPyc/TXNvTGlzdFBhcmFncmFwaEN4U3BGaXJzdFxcXCI/Jz8oW1xcXFxzXFxcXFNdKj8pKGxldmVsXFxcXGQpPyhbXFxcXHNcXFxcU10qPyk+KFtcXFxcc1xcXFxTXSo/KTxcXFxcL3A+L2dpLFxcXCI8dWw+PGxpJDM+JDU8L2xpPlxcXCIpLGE9YS5yZXBsYWNlKC88cCguKj8pY2xhc3M9XFxcIj8nP051bWJlcmVkVGV4dEN4U3BGaXJzdFxcXCI/Jz8oW1xcXFxzXFxcXFNdKj8pKGxldmVsXFxcXGQpPyhbXFxcXHNcXFxcU10qPyk+KFtcXFxcc1xcXFxTXSo/KTxcXFxcL3A+L2dpLFxcXCI8b2w+PGxpJDM+JDU8L2xpPlxcXCIpLGE9YS5yZXBsYWNlKC88cCguKj8pY2xhc3M9XFxcIj8nP01zb0xpc3RQYXJhZ3JhcGhDeFNwTWlkZGxlXFxcIj8nPyhbXFxcXHNcXFxcU10qPykobGV2ZWxcXFxcZCk/KFtcXFxcc1xcXFxTXSo/KT4oW1xcXFxzXFxcXFNdKj8pPFxcXFwvcD4vZ2ksXFxcIjxsaSQzPiQ1PC9saT5cXFwiKSxhPWEucmVwbGFjZSgvPHAoLio/KWNsYXNzPVxcXCI/Jz9OdW1iZXJlZFRleHRDeFNwTWlkZGxlXFxcIj8nPyhbXFxcXHNcXFxcU10qPykobGV2ZWxcXFxcZCk/KFtcXFxcc1xcXFxTXSo/KT4oW1xcXFxzXFxcXFNdKj8pPFxcXFwvcD4vZ2ksXFxcIjxsaSQzPiQ1PC9saT5cXFwiKSxhPWEucmVwbGFjZSgvPHAoLio/KWNsYXNzPVxcXCI/Jz9Nc29MaXN0QnVsbGV0XFxcIj8nPyhbXFxcXHNcXFxcU10qPykobGV2ZWxcXFxcZCk/KFtcXFxcc1xcXFxTXSo/KT4oW1xcXFxzXFxcXFNdKj8pPFxcXFwvcD4vZ2ksXFxcIjxsaSQzPiQ1PC9saT5cXFwiKSxhPWEucmVwbGFjZSgvPHAoLio/KWNsYXNzPVxcXCI/Jz9Nc29MaXN0UGFyYWdyYXBoQ3hTcExhc3RcXFwiPyc/KFtcXFxcc1xcXFxTXSo/KShsZXZlbFxcXFxkKT8oW1xcXFxzXFxcXFNdKj8pPihbXFxcXHNcXFxcU10qPyk8XFxcXC9wPi9naSxcXFwiPGxpJDM+JDU8L2xpPjwvdWw+XFxcIiksYT1hLnJlcGxhY2UoLzxwKC4qPyljbGFzcz1cXFwiPyc/TnVtYmVyZWRUZXh0Q3hTcExhc3RcXFwiPyc/KFtcXFxcc1xcXFxTXSo/KShsZXZlbFxcXFxkKT8oW1xcXFxzXFxcXFNdKj8pPihbXFxcXHNcXFxcU10qPyk8XFxcXC9wPi9naSxcXFwiPGxpJDM+JDU8L2xpPjwvb2w+XFxcIiksYT1hLnJlcGxhY2UoLzxzcGFuKFtePF0qPylzdHlsZT1cXFwiPyc/bXNvLWxpc3Q6SWdub3JlXFxcIj8nPyhbXFxcXHNcXFxcU10qPyk+KFtcXFxcc1xcXFxTXSo/KTxzcGFuL2dpLFxcXCI8c3Bhbj48c3BhblxcXCIpLGE9YS5yZXBsYWNlKC88IS0tXFxcXFtpZiBcXFxcIXN1cHBvcnRMaXN0c1xcXFxdLS0+KFtcXFxcc1xcXFxTXSo/KTwhLS1cXFxcW2VuZGlmXFxcXF0tLT4vZ2ksXFxcIlxcXCIpLGE9YS5yZXBsYWNlKC88IVxcXFxbaWYgXFxcXCFzdXBwb3J0TGlzdHNcXFxcXT4oW1xcXFxzXFxcXFNdKj8pPCFcXFxcW2VuZGlmXFxcXF0+L2dpLFxcXCJcXFwiKSxhPWEucmVwbGFjZSgvKFxcXFxufFxcXFxyfCBjbGFzcz0oXFxcIik/TXNvW2EtekEtWjAtOV0rKFxcXCIpPykvZ2ksXFxcIiBcXFwiKSxhPWEucmVwbGFjZSgvPCEtLVtcXFxcc1xcXFxTXSo/LS0+L2dpLFxcXCJcXFwiKSxhPWEucmVwbGFjZSgvPChcXFxcLykqKG1ldGF8bGlua3xzcGFufFxcXFxcXFxcP3htbDp8c3QxOnxvOnxmb250KSguKj8pPi9naSxcXFwiXFxcIik7dmFyIGQ9W1xcXCJzdHlsZVxcXCIsXFxcInNjcmlwdFxcXCIsXFxcImFwcGxldFxcXCIsXFxcImVtYmVkXFxcIixcXFwibm9mcmFtZXNcXFwiLFxcXCJub3NjcmlwdFxcXCJdO2ZvcihjPTA7YzxkLmxlbmd0aDtjKyspe3ZhciBlPW5ldyBSZWdFeHAoXFxcIjxcXFwiK2RbY10rXFxcIi4qP1xcXCIrZFtjXStcXFwiKC4qPyk+XFxcIixcXFwiZ2lcXFwiKTthPWEucmVwbGFjZShlLFxcXCJcXFwiKX1hPWEucmVwbGFjZSgvJm5ic3A7L2dpLFxcXCIgXFxcIiksYT1hLnJlcGxhY2UoLzx0ZChbXj5dKik+PFxcXFwvdGQ+L2csXFxcIjx0ZCQxPjxicj48L3RkPlxcXCIpLGE9YS5yZXBsYWNlKC88dGgoW14+XSopPjxcXFxcL3RoPi9nLFxcXCI8dGgkMT48YnI+PC90aD5cXFwiKTt2YXIgZjtkbyBmPWEsYT1hLnJlcGxhY2UoLzxbXlxcXFwvPl1bXj5dKj48XFxcXC9bXj5dKz4vZ2ksXFxcIlxcXCIpO3doaWxlKGEhPWYpO2E9YS5yZXBsYWNlKC88bGlsZXZlbChbXjFdKShbXj5dKik+L2dpLCc8bGkgZGF0YS1pbmRlbnQ9XFxcInRydWVcXFwiJDI+JyksYT1hLnJlcGxhY2UoLzxsaWxldmVsMShbXj5dKik+L2dpLFxcXCI8bGkkMT5cXFwiKSxhPWIuY2xlYW4uaHRtbChhLGIub3B0cy5wYXN0ZURlbmllZFRhZ3MsYi5vcHRzLnBhc3RlRGVuaWVkQXR0cnMpLGE9YS5yZXBsYWNlKC88YT4oLltePF0rKTxcXFxcL2E+L2dpLFxcXCIkMVxcXCIpLGE9YS5yZXBsYWNlKC88YnI+ICovZyxcXFwiPGJyPlxcXCIpO3ZhciBnPWIub19kb2MuY3JlYXRlRWxlbWVudChcXFwiZGl2XFxcIik7Zy5pbm5lckhUTUw9YTt2YXIgaD1nLnF1ZXJ5U2VsZWN0b3JBbGwoXFxcImxpW2RhdGEtaW5kZW50XVxcXCIpO2ZvcihjPTA7YzxoLmxlbmd0aDtjKyspe3ZhciBpPWhbY10saj1pLnByZXZpb3VzRWxlbWVudFNpYmxpbmc7aWYoaiYmXFxcIkxJXFxcIj09ai50YWdOYW1lKXt2YXIgaz1qLnF1ZXJ5U2VsZWN0b3IoXFxcIjpzY29wZSA+IHVsLCA6c2NvcGUgPiBvbFxcXCIpO2t8fChrPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXFxcInVsXFxcIiksai5hcHBlbmRDaGlsZChrKSksay5hcHBlbmRDaGlsZChpKX1lbHNlIGkucmVtb3ZlQXR0cmlidXRlKFxcXCJkYXRhLWluZGVudFxcXCIpfXJldHVybiBiLmh0bWwuY2xlYW5CbGFua1NwYWNlcyhnKSxhPWcuaW5uZXJIVE1MfWZ1bmN0aW9uIGgoYSl7dmFyIGMsZD1udWxsLGU9Yi5kb2MuY3JlYXRlRWxlbWVudChcXFwiZGl2XFxcIik7ZS5pbm5lckhUTUw9YTt2YXIgZj1lLnF1ZXJ5U2VsZWN0b3JBbGwoXFxcInAsIGRpdiwgaDEsIGgyLCBoMywgaDQsIGg1LCBoNiwgcHJlLCBibG9ja3F1b3RlXFxcIik7Zm9yKGM9MDtjPGYubGVuZ3RoO2MrKylkPWZbY10sZC5vdXRlckhUTUw9XFxcIjxcXFwiKyhiLmh0bWwuZGVmYXVsdFRhZygpfHxcXFwiRElWXFxcIikrXFxcIj5cXFwiK2QuaW5uZXJIVE1MK1xcXCI8L1xcXCIrKGIuaHRtbC5kZWZhdWx0VGFnKCl8fFxcXCJESVZcXFwiKStcXFwiPlxcXCI7Zm9yKGY9ZS5xdWVyeVNlbGVjdG9yQWxsKFxcXCIqOm5vdChcXFwiK1xcXCJwLCBkaXYsIGgxLCBoMiwgaDMsIGg0LCBoNSwgaDYsIHByZSwgYmxvY2txdW90ZSwgdWwsIG9sLCBsaSwgdGFibGUsIHRib2R5LCB0aGVhZCwgdHIsIHRkLCBiciwgaW1nXFxcIi5zcGxpdChcXFwiLFxcXCIpLmpvaW4oXFxcIik6bm90KFxcXCIpK1xcXCIpXFxcIiksYz1mLmxlbmd0aC0xO2M+PTA7Yy0tKWQ9ZltjXSxkLm91dGVySFRNTD1kLmlubmVySFRNTDt2YXIgZz1mdW5jdGlvbihhKXtmb3IodmFyIGM9Yi5ub2RlLmNvbnRlbnRzKGEpLGQ9MDtkPGMubGVuZ3RoO2QrKyljW2RdLm5vZGVUeXBlIT1Ob2RlLlRFWFRfTk9ERSYmY1tkXS5ub2RlVHlwZSE9Tm9kZS5FTEVNRU5UX05PREU/Y1tkXS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGNbZF0pOmcoY1tkXSl9O3JldHVybiBnKGUpLGUuaW5uZXJIVE1MfWZ1bmN0aW9uIGkoYSl7cmV0dXJuIGEubWF0Y2goLyhjbGFzcz1cXFxcXFxcIj9Nc298Y2xhc3M9XFxcXCc/TXNvfHN0eWxlPVxcXFxcXFwiW15cXFxcXFxcIl0qXFxcXGJtc29cXFxcLXxzdHlsZT1cXFxcJ1teXFxcXCddKlxcXFxibXNvXFxcXC18dzpXb3JkRG9jdW1lbnQpL2dpKX1mdW5jdGlvbiBqKCl7dmFyIGMsZD1udWxsLGU9bnVsbDtiLmtleXMuZm9yY2VVbmRvKCk7dmFyIGY9Yi5zbmFwc2hvdC5nZXQoKTtudWxsPT09cCYmKHA9ci5nZXQoMCkuaW5uZXJIVE1MLGIuc2VsZWN0aW9uLnJlc3RvcmUoKSxiLmV2ZW50cy5lbmFibGVCbHVyKCkpO3ZhciBqPWkocCksbD1iLmV2ZW50cy5jaGFpblRyaWdnZXIoXFxcInBhc3RlLmJlZm9yZUNsZWFudXBcXFwiLHApO2lmKGwmJlxcXCJzdHJpbmdcXFwiPT10eXBlb2YgbCYmKHA9bCkscC50b0xvd2VyQ2FzZSgpLmluZGV4T2YoXFxcIjxib2R5XFxcIik+PTAmJihwPXAucmVwbGFjZSgvWy5cXFxcc1xcXFxTXFxcXHdcXFxcVzw+XSo8Ym9keVtePl0qPltcXFxcc10qKFsuXFxcXHNcXFxcU1xcXFx3XFxcXFc8Pl0qKVtcXFxcc10qPFxcXFwvYm9keT5bLlxcXFxzXFxcXFNcXFxcd1xcXFxXPD5dKi9naSxcXFwiJDFcXFwiKSxwPXAucmVwbGFjZSgvKFtePl0pXFxcXG4oW148XSkvZyxcXFwiJDEgJDJcXFwiKSksIWope3ZhciBuPWIub3B0cy5odG1sQWxsb3dlZFN0eWxlUHJvcHM7Yi5vcHRzLmh0bWxBbGxvd2VkU3R5bGVQcm9wcz1iLm9wdHMucGFzdGVBbGxvd2VkU3R5bGVQcm9wcyxiLm9wdHMuaHRtbEFsbG93Q29tbWVudHM9ITEscD1iLmNsZWFuLmh0bWwocCxiLm9wdHMucGFzdGVEZW5pZWRUYWdzLGIub3B0cy5wYXN0ZURlbmllZEF0dHJzKSxiLm9wdHMuaHRtbEFsbG93ZWRTdHlsZVByb3BzPW4sYi5vcHRzLmh0bWxBbGxvd0NvbW1lbnRzPSEwLHA9bShwKSxwPXAucmVwbGFjZSgvXFxcXHJ8XFxcXG58XFxcXHQvZyxcXFwiXFxcIik7dmFyIG89Yi5kb2MuY3JlYXRlRWxlbWVudChcXFwiZGl2XFxcIik7by5pbm5lckhUTUw9cDt2YXIgcT1iLndpbi5sb2NhbFN0b3JhZ2UuZ2V0SXRlbShcXFwiZnItY29waWVkLWh0bWxcXFwiKSxzPWIud2luLmxvY2FsU3RvcmFnZS5nZXRJdGVtKFxcXCJmci1jb3BpZWQtdGV4dFxcXCIpO3MmJm8udGV4dENvbnRlbnQucmVwbGFjZSgvKFxcXFx1MDBBMCkvZ2ksXFxcIiBcXFwiKS5yZXBsYWNlKC9cXFxccnxcXFxcbi9naSxcXFwiXFxcIik9PXMucmVwbGFjZSgvKFxcXFx1MDBBMCkvZ2ksXFxcIiBcXFwiKS5yZXBsYWNlKC8oXFxcXHJ8XFxcXG4pKyhbIF0rW1xcXFxyXFxcXG5dKykqL2dpLFxcXCIgXFxcIikmJihwPXEpLHA9cC5yZXBsYWNlKC9eICovZyxcXFwiXFxcIikucmVwbGFjZSgvICokL2csXFxcIlxcXCIpfXZhciB0PSExO2lmKHAuaW5kZXhPZignaWQ9XFxcImRvY3MtaW50ZXJuYWwtZ3VpZCcpPj0wJiYocD1wLnJlcGxhY2UoL14uKiBpZD1cXFwiZG9jcy1pbnRlcm5hbC1ndWlkW14+XSo+KC4qKTxcXFxcL2I+LiokLyxcXFwiJDFcXFwiKSx0PSEwKSxqJiYhYi53b3JkUGFzdGUmJihwPXAucmVwbGFjZSgvXlxcXFxuKi9nLFxcXCJcXFwiKS5yZXBsYWNlKC9eIC9nLFxcXCJcXFwiKSwwPT09cC5pbmRleE9mKFxcXCI8Y29sZ3JvdXA+XFxcIikmJihwPVxcXCI8dGFibGU+XFxcIitwK1xcXCI8L3RhYmxlPlxcXCIpLHA9ZyhwKSxwPW0ocCkpLGIub3B0cy5wYXN0ZVBsYWluJiYocD1oKHApKSxsPWIuZXZlbnRzLmNoYWluVHJpZ2dlcihcXFwicGFzdGUuYWZ0ZXJDbGVhbnVwXFxcIixwKSxcXFwic3RyaW5nXFxcIj09dHlwZW9mIGwmJihwPWwpLFxcXCJcXFwiIT09cCl7dmFyIHU9Yi5vX2RvYy5jcmVhdGVFbGVtZW50KFxcXCJkaXZcXFwiKTt1LmlubmVySFRNTD1wLGIuc3BhY2VzLm5vcm1hbGl6ZSh1KTt2YXIgdj11LmdldEVsZW1lbnRzQnlUYWdOYW1lKFxcXCJzcGFuXFxcIik7Zm9yKGM9di5sZW5ndGgtMTtjPj0wO2MtLSl7dmFyIHc9dltjXTswPT09dy5hdHRyaWJ1dGVzLmxlbmd0aCYmKHcub3V0ZXJIVE1MPXcuaW5uZXJIVE1MKX12YXIgeD11LmNoaWxkcmVuO2lmKDE9PXgubGVuZ3RoJiZbXFxcIk9MXFxcIixcXFwiVUxcXFwiXS5pbmRleE9mKHhbMF0udGFnTmFtZSk+PTAmJih4WzBdLm91dGVySFRNTD14WzBdLmlubmVySFRNTCksIXQpe3ZhciB5PXUuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXFxcImJyXFxcIik7Zm9yKGM9eS5sZW5ndGgtMTtjPj0wO2MtLSl7dmFyIHo9eVtjXTtiLm5vZGUuaXNCbG9jayh6LnByZXZpb3VzU2libGluZykmJnoucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh6KX19aWYoYi5vcHRzLmVudGVyPT1hLkZFLkVOVEVSX0JSKWZvcihkPXUucXVlcnlTZWxlY3RvckFsbChcXFwicCwgZGl2XFxcIiksYz1kLmxlbmd0aC0xO2M+PTA7Yy0tKWU9ZFtjXSxlLm91dGVySFRNTD1lLmlubmVySFRNTCsoZS5uZXh0U2libGluZyYmIWIubm9kZS5pc0VtcHR5KGUpP1xcXCI8YnI+XFxcIjpcXFwiXFxcIik7ZWxzZSBpZihiLm9wdHMuZW50ZXI9PWEuRkUuRU5URVJfRElWKWZvcihkPXUuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXFxcInBcXFwiKSxjPWQubGVuZ3RoLTE7Yz49MDtjLS0pZT1kW2NdLGUub3V0ZXJIVE1MPVxcXCI8ZGl2PlxcXCIrZS5pbm5lckhUTUwrXFxcIjwvZGl2PlxcXCI7cD11LmlubmVySFRNTCxiLmh0bWwuaW5zZXJ0KHAsITApfWsoKSxiLnVuZG8uc2F2ZVN0ZXAoZiksYi51bmRvLnNhdmVTdGVwKCl9ZnVuY3Rpb24gaygpe2IuZXZlbnRzLnRyaWdnZXIoXFxcInBhc3RlLmFmdGVyXFxcIil9ZnVuY3Rpb24gbCgpe3JldHVybiBxfWZ1bmN0aW9uIG0oYSl7dmFyIGMsZD1iLm9fZG9jLmNyZWF0ZUVsZW1lbnQoXFxcImRpdlxcXCIpO2QuaW5uZXJIVE1MPWE7Zm9yKHZhciBlPWQucXVlcnlTZWxlY3RvckFsbChcXFwiKjplbXB0eTpub3QoYnIpOm5vdChpbWcpOm5vdCh0ZCk6bm90KHRoKVxcXCIpO2UubGVuZ3RoOyl7Zm9yKGM9MDtjPGUubGVuZ3RoO2MrKyllW2NdLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZVtjXSk7ZT1kLnF1ZXJ5U2VsZWN0b3JBbGwoXFxcIio6ZW1wdHk6bm90KGJyKTpub3QoaW1nKTpub3QodGQpOm5vdCh0aClcXFwiKX1mb3IodmFyIGY9ZC5xdWVyeVNlbGVjdG9yQWxsKFxcXCI6c2NvcGUgPiBkaXY6bm90KFtzdHlsZV0pLCB0ZCA+IGRpdjpub3QoW3N0eWxlXSksIHRoID4gZGl2Om5vdChbc3R5bGVdKSwgbGkgPiBkaXY6bm90KFtzdHlsZV0pXFxcIik7Zi5sZW5ndGg7KXt2YXIgZz1mW2YubGVuZ3RoLTFdO2lmKGIuaHRtbC5kZWZhdWx0VGFnKCkmJlxcXCJkaXZcXFwiIT1iLmh0bWwuZGVmYXVsdFRhZygpKWcucXVlcnlTZWxlY3RvcihiLmh0bWwuYmxvY2tUYWdzUXVlcnkoKSk/Zy5vdXRlckhUTUw9Zy5pbm5lckhUTUw6Zy5vdXRlckhUTUw9XFxcIjxcXFwiK2IuaHRtbC5kZWZhdWx0VGFnKCkrXFxcIj5cXFwiK2cuaW5uZXJIVE1MK1xcXCI8L1xcXCIrYi5odG1sLmRlZmF1bHRUYWcoKStcXFwiPlxcXCI7ZWxzZXt2YXIgaD1nLnF1ZXJ5U2VsZWN0b3JBbGwoXFxcIipcXFwiKTtoLmxlbmd0aCYmXFxcIkJSXFxcIj09PWhbaC5sZW5ndGgtMV0udGFnTmFtZT9nLm91dGVySFRNTD1nLmlubmVySFRNTDpnLm91dGVySFRNTD1nLmlubmVySFRNTCtcXFwiPGJyPlxcXCJ9Zj1kLnF1ZXJ5U2VsZWN0b3JBbGwoXFxcIjpzY29wZSA+IGRpdjpub3QoW3N0eWxlXSksIHRkID4gZGl2Om5vdChbc3R5bGVdKSwgdGggPiBkaXY6bm90KFtzdHlsZV0pLCBsaSA+IGRpdjpub3QoW3N0eWxlXSlcXFwiKX1mb3IoZj1kLnF1ZXJ5U2VsZWN0b3JBbGwoXFxcImRpdjpub3QoW3N0eWxlXSlcXFwiKTtmLmxlbmd0aDspe2ZvcihjPTA7YzxmLmxlbmd0aDtjKyspe3ZhciBpPWZbY10saj1pLmlubmVySFRNTC5yZXBsYWNlKC9cXFxcdTAwMDkvZ2ksXFxcIlxcXCIpLnRyaW0oKTtpLm91dGVySFRNTD1qfWY9ZC5xdWVyeVNlbGVjdG9yQWxsKFxcXCJkaXY6bm90KFtzdHlsZV0pXFxcIil9cmV0dXJuIGQuaW5uZXJIVE1MfWZ1bmN0aW9uIG4oKXtiLmV2ZW50cy5vbihcXFwiY29weVxcXCIsZCksYi5ldmVudHMub24oXFxcImN1dFxcXCIsZCksYi5ldmVudHMub24oXFxcInBhc3RlXFxcIixlKSxiLmJyb3dzZXIubXNpZSYmYi5icm93c2VyLnZlcnNpb248MTEmJihiLmV2ZW50cy5vbihcXFwibW91c2V1cFxcXCIsZnVuY3Rpb24oYSl7Mj09YS5idXR0b24mJihzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7cz0hMX0sNTApLHM9ITApfSwhMCksYi5ldmVudHMub24oXFxcImJlZm9yZXBhc3RlXFxcIixlKSl9dmFyIG8scCxxLHIscz0hMTtyZXR1cm57X2luaXQ6bixyZW1vdmVFbXB0eVRhZ3M6bSxnZXRSdGZDbGlwYm9hcmQ6bCxpc1dvcmQ6aSxzYXZlQ29waWVkVGV4dDpjfX0sYS5leHRlbmQoYS5GRS5ERUZBVUxUUyx7c2hvcnRjdXRzRW5hYmxlZDpbXFxcInNob3dcXFwiLFxcXCJib2xkXFxcIixcXFwiaXRhbGljXFxcIixcXFwidW5kZXJsaW5lXFxcIixcXFwic3RyaWtlVGhyb3VnaFxcXCIsXFxcImluZGVudFxcXCIsXFxcIm91dGRlbnRcXFwiLFxcXCJ1bmRvXFxcIixcXFwicmVkb1xcXCJdLHNob3J0Y3V0c0hpbnQ6ITB9KSxhLkZFLlNIT1JUQ1VUU19NQVA9e30sYS5GRS5SZWdpc3RlclNob3J0Y3V0PWZ1bmN0aW9uKGIsYyxkLGUsZixnKXthLkZFLlNIT1JUQ1VUU19NQVBbKGY/XFxcIl5cXFwiOlxcXCJcXFwiKSsoZz9cXFwiQFxcXCI6XFxcIlxcXCIpK2JdPXtjbWQ6Yyx2YWw6ZCxsZXR0ZXI6ZSxzaGlmdDpmLG9wdGlvbjpnfSxhLkZFLkRFRkFVTFRTLnNob3J0Y3V0c0VuYWJsZWQucHVzaChjKX0sYS5GRS5SZWdpc3RlclNob3J0Y3V0KGEuRkUuS0VZQ09ERS5FLFxcXCJzaG93XFxcIixudWxsLFxcXCJFXFxcIiwhMSwhMSksYS5GRS5SZWdpc3RlclNob3J0Y3V0KGEuRkUuS0VZQ09ERS5CLFxcXCJib2xkXFxcIixudWxsLFxcXCJCXFxcIiwhMSwhMSksYS5GRS5SZWdpc3RlclNob3J0Y3V0KGEuRkUuS0VZQ09ERS5JLFxcXCJpdGFsaWNcXFwiLG51bGwsXFxcIklcXFwiLCExLCExKSxhLkZFLlJlZ2lzdGVyU2hvcnRjdXQoYS5GRS5LRVlDT0RFLlUsXFxcInVuZGVybGluZVxcXCIsbnVsbCxcXFwiVVxcXCIsITEsITEpLGEuRkUuUmVnaXN0ZXJTaG9ydGN1dChhLkZFLktFWUNPREUuUyxcXFwic3RyaWtlVGhyb3VnaFxcXCIsbnVsbCxcXFwiU1xcXCIsITEsITEpLGEuRkUuUmVnaXN0ZXJTaG9ydGN1dChhLkZFLktFWUNPREUuQ0xPU0VfU1FVQVJFX0JSQUNLRVQsXFxcImluZGVudFxcXCIsbnVsbCxcXFwiXVxcXCIsITEsITEpLGEuRkUuUmVnaXN0ZXJTaG9ydGN1dChhLkZFLktFWUNPREUuT1BFTl9TUVVBUkVfQlJBQ0tFVCxcXFwib3V0ZGVudFxcXCIsbnVsbCxcXFwiW1xcXCIsITEsITEpLGEuRkUuUmVnaXN0ZXJTaG9ydGN1dChhLkZFLktFWUNPREUuWixcXFwidW5kb1xcXCIsbnVsbCxcXFwiWlxcXCIsITEsITEpLGEuRkUuUmVnaXN0ZXJTaG9ydGN1dChhLkZFLktFWUNPREUuWixcXFwicmVkb1xcXCIsbnVsbCxcXFwiWlxcXCIsITAsITEpLGEuRkUuTU9EVUxFUy5zaG9ydGN1dHM9ZnVuY3Rpb24oYil7ZnVuY3Rpb24gYyhjKXtpZighYi5vcHRzLnNob3J0Y3V0c0hpbnQpcmV0dXJuIG51bGw7aWYoIWYpe2Y9e307Zm9yKHZhciBkIGluIGEuRkUuU0hPUlRDVVRTX01BUClhLkZFLlNIT1JUQ1VUU19NQVAuaGFzT3duUHJvcGVydHkoZCkmJmIub3B0cy5zaG9ydGN1dHNFbmFibGVkLmluZGV4T2YoYS5GRS5TSE9SVENVVFNfTUFQW2RdLmNtZCk+PTAmJihmW2EuRkUuU0hPUlRDVVRTX01BUFtkXS5jbWQrXFxcIi5cXFwiKyhhLkZFLlNIT1JUQ1VUU19NQVBbZF0udmFsfHxcXFwiXFxcIildPXtzaGlmdDphLkZFLlNIT1JUQ1VUU19NQVBbZF0uc2hpZnQsb3B0aW9uOmEuRkUuU0hPUlRDVVRTX01BUFtkXS5vcHRpb24sbGV0dGVyOmEuRkUuU0hPUlRDVVRTX01BUFtkXS5sZXR0ZXJ9KX12YXIgZT1mW2NdO3JldHVybiBlPyhiLmhlbHBlcnMuaXNNYWMoKT9TdHJpbmcuZnJvbUNoYXJDb2RlKDg5ODQpOlxcXCJDdHJsK1xcXCIpKyhlLnNoaWZ0P2IuaGVscGVycy5pc01hYygpP1N0cmluZy5mcm9tQ2hhckNvZGUoODY3OSk6XFxcIlNoaWZ0K1xcXCI6XFxcIlxcXCIpKyhlLm9wdGlvbj9iLmhlbHBlcnMuaXNNYWMoKT9TdHJpbmcuZnJvbUNoYXJDb2RlKDg5OTcpOlxcXCJBbHQrXFxcIjpcXFwiXFxcIikrZS5sZXR0ZXI6bnVsbH1mdW5jdGlvbiBkKGMpe2lmKCFiLmNvcmUuaGFzRm9jdXMoKSlyZXR1cm4hMDt2YXIgZD1jLndoaWNoLGU9bmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKFxcXCJNYWMgT1MgWFxcXCIpIT0tMT9jLm1ldGFLZXk6Yy5jdHJsS2V5O2lmKFxcXCJrZXl1cFxcXCI9PWMudHlwZSYmZyYmZCE9YS5GRS5LRVlDT0RFLk1FVEEpcmV0dXJuIGc9ITEsITE7XFxcImtleWRvd25cXFwiPT1jLnR5cGUmJihnPSExKTt2YXIgZj0oYy5zaGlmdEtleT9cXFwiXlxcXCI6XFxcIlxcXCIpKyhjLmFsdEtleT9cXFwiQFxcXCI6XFxcIlxcXCIpK2Q7aWYoZSYmYS5GRS5TSE9SVENVVFNfTUFQW2ZdKXt2YXIgaD1hLkZFLlNIT1JUQ1VUU19NQVBbZl0uY21kO2lmKGgmJmIub3B0cy5zaG9ydGN1dHNFbmFibGVkLmluZGV4T2YoaCk+PTApe3ZhciBpLGo9YS5GRS5TSE9SVENVVFNfTUFQW2ZdLnZhbDtpZihoJiYhaj9pPWIuJHRiLmZpbmQoJy5mci1jb21tYW5kW2RhdGEtY21kPVxcXCInK2grJ1xcXCJdJyk6aCYmaiYmKGk9Yi4kdGIuZmluZCgnLmZyLWNvbW1hbmRbZGF0YS1jbWQ9XFxcIicraCsnXFxcIl1bZGF0YS1wYXJhbTE9XFxcIicraisnXFxcIl0nKSksaS5sZW5ndGgpcmV0dXJuIGMucHJldmVudERlZmF1bHQoKSxjLnN0b3BQcm9wYWdhdGlvbigpLGkucGFyZW50cyhcXFwiLmZyLXRvb2xiYXJcXFwiKS5kYXRhKFxcXCJpbnN0YW5jZVxcXCIsYiksXFxcImtleWRvd25cXFwiPT1jLnR5cGUmJihiLmJ1dHRvbi5leGVjKGkpLGc9ITApLCExO2lmKGgmJmIuY29tbWFuZHNbaF0pcmV0dXJuIGMucHJldmVudERlZmF1bHQoKSxjLnN0b3BQcm9wYWdhdGlvbigpLFxcXCJrZXlkb3duXFxcIj09Yy50eXBlJiYoYi5jb21tYW5kc1toXSgpLGc9ITApLCExfX19ZnVuY3Rpb24gZSgpe2IuZXZlbnRzLm9uKFxcXCJrZXlkb3duXFxcIixkLCEwKSxiLmV2ZW50cy5vbihcXFwia2V5dXBcXFwiLGQsITApfXZhciBmPW51bGwsZz0hMTtyZXR1cm57X2luaXQ6ZSxnZXQ6Y319LGEuRkUuTU9EVUxFUy5zbmFwc2hvdD1mdW5jdGlvbihhKXtmdW5jdGlvbiBiKGEpe2Zvcih2YXIgYj1hLnBhcmVudE5vZGUuY2hpbGROb2RlcyxjPTAsZD1udWxsLGU9MDtlPGIubGVuZ3RoO2UrKyl7aWYoZCl7dmFyIGY9YltlXS5ub2RlVHlwZT09PU5vZGUuVEVYVF9OT0RFJiZcXFwiXFxcIj09PWJbZV0udGV4dENvbnRlbnQsZz1kLm5vZGVUeXBlPT09Tm9kZS5URVhUX05PREUmJmJbZV0ubm9kZVR5cGU9PT1Ob2RlLlRFWFRfTk9ERTtmfHxnfHxjKyt9aWYoYltlXT09YSlyZXR1cm4gYztkPWJbZV19fWZ1bmN0aW9uIGMoYyl7dmFyIGQ9W107aWYoIWMucGFyZW50Tm9kZSlyZXR1cm5bXTtmb3IoOyFhLm5vZGUuaXNFbGVtZW50KGMpOylkLnB1c2goYihjKSksYz1jLnBhcmVudE5vZGU7cmV0dXJuIGQucmV2ZXJzZSgpfWZ1bmN0aW9uIGQoYSxiKXtmb3IoO2EmJmEubm9kZVR5cGU9PT1Ob2RlLlRFWFRfTk9ERTspe3ZhciBjPWEucHJldmlvdXNTaWJsaW5nO2MmJmMubm9kZVR5cGU9PU5vZGUuVEVYVF9OT0RFJiYoYis9Yy50ZXh0Q29udGVudC5sZW5ndGgpLGE9Y31yZXR1cm4gYn1mdW5jdGlvbiBlKGEpe3JldHVybntzY0xvYzpjKGEuc3RhcnRDb250YWluZXIpLHNjT2Zmc2V0OmQoYS5zdGFydENvbnRhaW5lcixhLnN0YXJ0T2Zmc2V0KSxlY0xvYzpjKGEuZW5kQ29udGFpbmVyKSxlY09mZnNldDpkKGEuZW5kQ29udGFpbmVyLGEuZW5kT2Zmc2V0KX19ZnVuY3Rpb24gZigpe3ZhciBiPXt9O2lmKGEuZXZlbnRzLnRyaWdnZXIoXFxcInNuYXBzaG90LmJlZm9yZVxcXCIpLGIuaHRtbD0oYS4kd3A/YS4kZWwuaHRtbCgpOmEuJG9lbC5nZXQoMCkub3V0ZXJIVE1MKS5yZXBsYWNlKC8gc3R5bGU9XFxcIlxcXCIvZyxcXFwiXFxcIiksYi5yYW5nZXM9W10sYS4kd3AmJmEuc2VsZWN0aW9uLmluRWRpdG9yKCkmJmEuY29yZS5oYXNGb2N1cygpKWZvcih2YXIgYz1hLnNlbGVjdGlvbi5yYW5nZXMoKSxkPTA7ZDxjLmxlbmd0aDtkKyspYi5yYW5nZXMucHVzaChlKGNbZF0pKTtyZXR1cm4gYS5ldmVudHMudHJpZ2dlcihcXFwic25hcHNob3QuYWZ0ZXJcXFwiKSxifWZ1bmN0aW9uIGcoYil7Zm9yKHZhciBjPWEuZWwsZD0wO2Q8Yi5sZW5ndGg7ZCsrKWM9Yy5jaGlsZE5vZGVzW2JbZF1dO3JldHVybiBjfWZ1bmN0aW9uIGgoYixjKXt0cnl7dmFyIGQ9ZyhjLnNjTG9jKSxlPWMuc2NPZmZzZXQsZj1nKGMuZWNMb2MpLGg9Yy5lY09mZnNldCxpPWEuZG9jLmNyZWF0ZVJhbmdlKCk7aS5zZXRTdGFydChkLGUpLGkuc2V0RW5kKGYsaCksYi5hZGRSYW5nZShpKX1jYXRjaChqKXt9fWZ1bmN0aW9uIGkoYil7YS4kZWwuaHRtbCgpIT1iLmh0bWwmJmEuJGVsLmh0bWwoYi5odG1sKTt2YXIgYz1hLnNlbGVjdGlvbi5nZXQoKTthLnNlbGVjdGlvbi5jbGVhcigpLGEuZXZlbnRzLmZvY3VzKCEwKTtmb3IodmFyIGQ9MDtkPGIucmFuZ2VzLmxlbmd0aDtkKyspaChjLGIucmFuZ2VzW2RdKX1mdW5jdGlvbiBqKGIsYyl7cmV0dXJuIGIuaHRtbD09Yy5odG1sJiYoIWEuY29yZS5oYXNGb2N1cygpfHxKU09OLnN0cmluZ2lmeShiLnJhbmdlcyk9PUpTT04uc3RyaW5naWZ5KGMucmFuZ2VzKSl9cmV0dXJue2dldDpmLHJlc3RvcmU6aSxlcXVhbDpqfX0sYS5GRS5NT0RVTEVTLnVuZG89ZnVuY3Rpb24oYSl7ZnVuY3Rpb24gYihiKXt2YXIgYz1iLndoaWNoLGQ9YS5rZXlzLmN0cmxLZXkoYik7ZCYmKDkwPT1jJiZiLnNoaWZ0S2V5JiZiLnByZXZlbnREZWZhdWx0KCksOTA9PWMmJmIucHJldmVudERlZmF1bHQoKSl9ZnVuY3Rpb24gYygpe3JldHVybiEoMD09PWEudW5kb19zdGFjay5sZW5ndGh8fGEudW5kb19pbmRleDw9MSl9ZnVuY3Rpb24gZCgpe3JldHVybiBhLnVuZG9faW5kZXghPWEudW5kb19zdGFjay5sZW5ndGh9ZnVuY3Rpb24gZShiKXtyZXR1cm4hKCFhLnVuZG9fc3RhY2t8fGEudW5kb2luZ3x8YS5lbC5xdWVyeVNlbGVjdG9yKFxcXCIuZnItbWFya2VyXFxcIikpJiZ2b2lkKFxcXCJ1bmRlZmluZWRcXFwiPT10eXBlb2YgYj8oYj1hLnNuYXBzaG90LmdldCgpLGEudW5kb19zdGFja1thLnVuZG9faW5kZXgtMV0mJmEuc25hcHNob3QuZXF1YWwoYS51bmRvX3N0YWNrW2EudW5kb19pbmRleC0xXSxiKXx8KGYoKSxhLnVuZG9fc3RhY2sucHVzaChiKSxhLnVuZG9faW5kZXgrKyxiLmh0bWwhPWwmJihhLmV2ZW50cy50cmlnZ2VyKFxcXCJjb250ZW50Q2hhbmdlZFxcXCIpLGw9Yi5odG1sKSkpOihmKCksYS51bmRvX2luZGV4PjA/YS51bmRvX3N0YWNrW2EudW5kb19pbmRleC0xXT1iOihhLnVuZG9fc3RhY2sucHVzaChiKSxhLnVuZG9faW5kZXgrKykpKX1mdW5jdGlvbiBmKCl7aWYoIWEudW5kb19zdGFja3x8YS51bmRvaW5nKXJldHVybiExO2Zvcig7YS51bmRvX3N0YWNrLmxlbmd0aD5hLnVuZG9faW5kZXg7KWEudW5kb19zdGFjay5wb3AoKX1mdW5jdGlvbiBnKCl7aWYoYS51bmRvX2luZGV4PjEpe2EudW5kb2luZz0hMDt2YXIgYj1hLnVuZG9fc3RhY2tbLS1hLnVuZG9faW5kZXgtMV07Y2xlYXJUaW1lb3V0KGEuX2NvbnRlbnRfY2hhbmdlZF90aW1lciksYS5zbmFwc2hvdC5yZXN0b3JlKGIpLGw9Yi5odG1sLGEucG9wdXBzLmhpZGVBbGwoKSxhLnRvb2xiYXIuZW5hYmxlKCksYS5ldmVudHMudHJpZ2dlcihcXFwiY29udGVudENoYW5nZWRcXFwiKSxhLmV2ZW50cy50cmlnZ2VyKFxcXCJjb21tYW5kcy51bmRvXFxcIiksYS51bmRvaW5nPSExfX1mdW5jdGlvbiBoKCl7aWYoYS51bmRvX2luZGV4PGEudW5kb19zdGFjay5sZW5ndGgpe2EudW5kb2luZz0hMDt2YXIgYj1hLnVuZG9fc3RhY2tbYS51bmRvX2luZGV4KytdO2NsZWFyVGltZW91dChhLl9jb250ZW50X2NoYW5nZWRfdGltZXIpLGEuc25hcHNob3QucmVzdG9yZShiKSxsPWIuaHRtbCxhLnBvcHVwcy5oaWRlQWxsKCksYS50b29sYmFyLmVuYWJsZSgpLGEuZXZlbnRzLnRyaWdnZXIoXFxcImNvbnRlbnRDaGFuZ2VkXFxcIiksYS5ldmVudHMudHJpZ2dlcihcXFwiY29tbWFuZHMucmVkb1xcXCIpLGEudW5kb2luZz0hMX19ZnVuY3Rpb24gaSgpe2EudW5kb19pbmRleD0wLGEudW5kb19zdGFjaz1bXX1mdW5jdGlvbiBqKCl7YS51bmRvX3N0YWNrPVtdfWZ1bmN0aW9uIGsoKXtpKCksYS5ldmVudHMub24oXFxcImluaXRpYWxpemVkXFxcIixmdW5jdGlvbigpe2w9KGEuJHdwP2EuJGVsLmh0bWwoKTphLiRvZWwuZ2V0KDApLm91dGVySFRNTCkucmVwbGFjZSgvIHN0eWxlPVxcXCJcXFwiL2csXFxcIlxcXCIpfSksYS5ldmVudHMub24oXFxcImJsdXJcXFwiLGZ1bmN0aW9uKCl7YS5lbC5xdWVyeVNlbGVjdG9yKFxcXCIuZnItZHJhZ2dpbmdcXFwiKXx8YS51bmRvLnNhdmVTdGVwKCl9KSxhLmV2ZW50cy5vbihcXFwia2V5ZG93blxcXCIsYiksYS5ldmVudHMub24oXFxcImRlc3Ryb3lcXFwiLGopfXZhciBsPW51bGw7cmV0dXJue19pbml0OmsscnVuOmcscmVkbzpoLGNhbkRvOmMsY2FuUmVkbzpkLGRyb3BSZWRvOmYscmVzZXQ6aSxzYXZlU3RlcDplfX0sYS5GRS5JQ09OX0RFRkFVTFRfVEVNUExBVEU9XFxcImZvbnRfYXdlc29tZVxcXCIsYS5GRS5JQ09OX1RFTVBMQVRFUz17Zm9udF9hd2Vzb21lOic8aSBjbGFzcz1cXFwiZmEgZmEtW05BTUVdXFxcIiBhcmlhLWhpZGRlbj1cXFwidHJ1ZVxcXCI+PC9pPicsdGV4dDonPHNwYW4gc3R5bGU9XFxcInRleHQtYWxpZ246IGNlbnRlcjtcXFwiPltOQU1FXTwvc3Bhbj4nLGltYWdlOlxcXCI8aW1nIHNyYz1bU1JDXSBhbHQ9W0FMVF0gLz5cXFwiLHN2ZzonPHN2ZyB2aWV3Qm94PVxcXCIwIDAgMzIgMzJcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+W1BBVEhdPC9zdmc+J30sYS5GRS5JQ09OUz17Ym9sZDp7TkFNRTpcXFwiYm9sZFxcXCJ9LGl0YWxpYzp7TkFNRTpcXFwiaXRhbGljXFxcIn0sdW5kZXJsaW5lOntOQU1FOlxcXCJ1bmRlcmxpbmVcXFwifSxzdHJpa2VUaHJvdWdoOntOQU1FOlxcXCJzdHJpa2V0aHJvdWdoXFxcIn0sc3Vic2NyaXB0OntOQU1FOlxcXCJzdWJzY3JpcHRcXFwifSxzdXBlcnNjcmlwdDp7TkFNRTpcXFwic3VwZXJzY3JpcHRcXFwifSxjb2xvcjp7TkFNRTpcXFwidGludFxcXCJ9LG91dGRlbnQ6e05BTUU6XFxcIm91dGRlbnRcXFwifSxpbmRlbnQ6e05BTUU6XFxcImluZGVudFxcXCJ9LHVuZG86e05BTUU6XFxcInJvdGF0ZS1sZWZ0XFxcIn0scmVkbzp7TkFNRTpcXFwicm90YXRlLXJpZ2h0XFxcIn0saW5zZXJ0SFI6e05BTUU6XFxcIm1pbnVzXFxcIn0sY2xlYXJGb3JtYXR0aW5nOntOQU1FOlxcXCJlcmFzZXJcXFwifSxzZWxlY3RBbGw6e05BTUU6XFxcIm1vdXNlLXBvaW50ZXJcXFwifX0sYS5GRS5EZWZpbmVJY29uVGVtcGxhdGU9ZnVuY3Rpb24oYixjKXthLkZFLklDT05fVEVNUExBVEVTW2JdPWN9LGEuRkUuRGVmaW5lSWNvbj1mdW5jdGlvbihiLGMpe2EuRkUuSUNPTlNbYl09Y30sYS5GRS5NT0RVTEVTLmljb249ZnVuY3Rpb24oKXtmdW5jdGlvbiBiKGIpe3ZhciBjPW51bGwsZD1hLkZFLklDT05TW2JdO2lmKFxcXCJ1bmRlZmluZWRcXFwiIT10eXBlb2YgZCl7dmFyIGU9ZC50ZW1wbGF0ZXx8YS5GRS5JQ09OX0RFRkFVTFRfVEVNUExBVEU7ZSYmKGU9YS5GRS5JQ09OX1RFTVBMQVRFU1tlXSkmJihjPWUucmVwbGFjZSgvXFxcXFsoW2EtekEtWl0qKVxcXFxdL2csZnVuY3Rpb24oYSxjKXtyZXR1cm5cXFwiTkFNRVxcXCI9PWM/ZFtjXXx8YjpkW2NdfSkpfXJldHVybiBjfHxifWZ1bmN0aW9uIGMoYil7dmFyIGM9YS5GRS5JQ09OU1tiXSxkPWEuRkUuSUNPTl9ERUZBVUxUX1RFTVBMQVRFO3JldHVyblxcXCJ1bmRlZmluZWRcXFwiIT10eXBlb2YgYz9kPWMudGVtcGxhdGV8fGEuRkUuSUNPTl9ERUZBVUxUX1RFTVBMQVRFOmR9cmV0dXJue2NyZWF0ZTpiLGdldFRlbXBsYXRlOmN9fSxhLmV4dGVuZChhLkZFLkRFRkFVTFRTLHt0b29sdGlwczohMH0pLGEuRkUuTU9EVUxFUy50b29sdGlwPWZ1bmN0aW9uKGIpe2Z1bmN0aW9uIGMoKXtiLiR0b29sdGlwJiZiLiR0b29sdGlwLnJlbW92ZUNsYXNzKFxcXCJmci12aXNpYmxlXFxcIikuY3NzKFxcXCJsZWZ0XFxcIixcXFwiLTMwMDBweFxcXCIpLmNzcyhcXFwicG9zaXRpb25cXFwiLFxcXCJmaXhlZFxcXCIpfWZ1bmN0aW9uIGQoYyxkKXtpZihjLmRhdGEoXFxcInRpdGxlXFxcIil8fGMuZGF0YShcXFwidGl0bGVcXFwiLGMuYXR0cihcXFwidGl0bGVcXFwiKSksIWMuZGF0YShcXFwidGl0bGVcXFwiKSlyZXR1cm4hMTtiLiR0b29sdGlwfHxmKCksYy5yZW1vdmVBdHRyKFxcXCJ0aXRsZVxcXCIpLGIuJHRvb2x0aXAudGV4dChjLmRhdGEoXFxcInRpdGxlXFxcIikpLGIuJHRvb2x0aXAuYWRkQ2xhc3MoXFxcImZyLXZpc2libGVcXFwiKTt2YXIgZT1jLm9mZnNldCgpLmxlZnQrKGMub3V0ZXJXaWR0aCgpLWIuJHRvb2x0aXAub3V0ZXJXaWR0aCgpKS8yO2U8MCYmKGU9MCksZStiLiR0b29sdGlwLm91dGVyV2lkdGgoKT5hKGIub193aW4pLndpZHRoKCkmJihlPWEoYi5vX3dpbikud2lkdGgoKS1iLiR0b29sdGlwLm91dGVyV2lkdGgoKSksXFxcInVuZGVmaW5lZFxcXCI9PXR5cGVvZiBkJiYoZD1iLm9wdHMudG9vbGJhckJvdHRvbSk7dmFyIGc9ZD9jLm9mZnNldCgpLnRvcC1iLiR0b29sdGlwLmhlaWdodCgpOmMub2Zmc2V0KCkudG9wK2Mub3V0ZXJIZWlnaHQoKTtiLiR0b29sdGlwLmNzcyhcXFwicG9zaXRpb25cXFwiLFxcXCJcXFwiKSxiLiR0b29sdGlwLmNzcyhcXFwibGVmdFxcXCIsZSksYi4kdG9vbHRpcC5jc3MoXFxcInRvcFxcXCIsTWF0aC5jZWlsKGcpKSxcXFwic3RhdGljXFxcIiE9YShiLm9fZG9jKS5maW5kKFxcXCJib2R5XFxcIikuY3NzKFxcXCJwb3NpdGlvblxcXCIpPyhiLiR0b29sdGlwLmNzcyhcXFwibWFyZ2luLWxlZnRcXFwiLC1hKGIub19kb2MpLmZpbmQoXFxcImJvZHlcXFwiKS5vZmZzZXQoKS5sZWZ0KSxiLiR0b29sdGlwLmNzcyhcXFwibWFyZ2luLXRvcFxcXCIsLWEoYi5vX2RvYykuZmluZChcXFwiYm9keVxcXCIpLm9mZnNldCgpLnRvcCkpOihiLiR0b29sdGlwLmNzcyhcXFwibWFyZ2luLWxlZnRcXFwiLFxcXCJcXFwiKSxiLiR0b29sdGlwLmNzcyhcXFwibWFyZ2luLXRvcFxcXCIsXFxcIlxcXCIpKX1mdW5jdGlvbiBlKGUsZixnKXtiLm9wdHMudG9vbHRpcHMmJiFiLmhlbHBlcnMuaXNNb2JpbGUoKSYmKGIuZXZlbnRzLiRvbihlLFxcXCJtb3VzZWVudGVyXFxcIixmLGZ1bmN0aW9uKGMpe2Iubm9kZS5oYXNDbGFzcyhjLmN1cnJlbnRUYXJnZXQsXFxcImZyLWRpc2FibGVkXFxcIil8fGIuZWRpdC5pc0Rpc2FibGVkKCl8fGQoYShjLmN1cnJlbnRUYXJnZXQpLGcpfSwhMCksYi5ldmVudHMuJG9uKGUsXFxcIm1vdXNlbGVhdmUgXFxcIitiLl9tb3VzZWRvd24rXFxcIiBcXFwiK2IuX21vdXNldXAsZixmdW5jdGlvbigpe2MoKX0sITApKX1mdW5jdGlvbiBmKCl7Yi5vcHRzLnRvb2x0aXBzJiYhYi5oZWxwZXJzLmlzTW9iaWxlKCkmJihiLnNoYXJlZC4kdG9vbHRpcD9iLiR0b29sdGlwPWIuc2hhcmVkLiR0b29sdGlwOihiLnNoYXJlZC4kdG9vbHRpcD1hKCc8ZGl2IGNsYXNzPVxcXCJmci10b29sdGlwXFxcIj48L2Rpdj4nKSxiLiR0b29sdGlwPWIuc2hhcmVkLiR0b29sdGlwLGIub3B0cy50aGVtZSYmYi4kdG9vbHRpcC5hZGRDbGFzcyhiLm9wdHMudGhlbWUrXFxcIi10aGVtZVxcXCIpLGEoYi5vX2RvYykuZmluZChcXFwiYm9keVxcXCIpLmFwcGVuZChiLiR0b29sdGlwKSksYi5ldmVudHMub24oXFxcInNoYXJlZC5kZXN0cm95XFxcIixmdW5jdGlvbigpe2IuJHRvb2x0aXAuaHRtbChcXFwiXFxcIikucmVtb3ZlRGF0YSgpLnJlbW92ZSgpLGIuJHRvb2x0aXA9bnVsbH0sITApKX1yZXR1cm57aGlkZTpjLHRvOmQsYmluZDplfX0sYS5GRS5NT0RVTEVTLmJ1dHRvbj1mdW5jdGlvbihiKXtmdW5jdGlvbiBjKGIsYyxkKXtmb3IodmFyIGU9YSgpLGY9MDtmPGIubGVuZ3RoO2YrKyl7dmFyIGc9YShiW2ZdKTtpZihnLmlzKGMpJiYoZT1lLmFkZChnKSksZCYmZy5pcyhcXFwiLmZyLWRyb3Bkb3duXFxcIikpe3ZhciBoPWcubmV4dCgpLmZpbmQoYyk7ZT1lLmFkZChoKX19cmV0dXJuIGV9ZnVuY3Rpb24gZChkLGUpe3ZhciBmLGc9YSgpO2lmKCFkKXJldHVybiBnO2c9Zy5hZGQoYyh2LGQsZSkpLGc9Zy5hZGQoYyh3LGQsZSkpO2ZvcihmIGluIGIuc2hhcmVkLnBvcHVwcylpZihiLnNoYXJlZC5wb3B1cHMuaGFzT3duUHJvcGVydHkoZikpe3ZhciBoPWIuc2hhcmVkLnBvcHVwc1tmXSxpPWguY2hpbGRyZW4oKS5ub3QoXFxcIi5mci1idXR0b25zXFxcIikuZmluZChkKTtnPWcuYWRkKGkpfWZvcihmIGluIGIuc2hhcmVkLm1vZGFscylpZihiLnNoYXJlZC5tb2RhbHMuaGFzT3duUHJvcGVydHkoZikpe3ZhciBqPWIuc2hhcmVkLm1vZGFsc1tmXSxrPWouJG1vZGFsLmZpbmQoZCk7Zz1nLmFkZChrKX1yZXR1cm4gZ31mdW5jdGlvbiBlKGMpe3ZhciBlPWMubmV4dCgpLGY9Yi5ub2RlLmhhc0NsYXNzKGMuZ2V0KDApLFxcXCJmci1hY3RpdmVcXFwiKSxnPWQoXFxcIi5mci1kcm9wZG93bi5mci1hY3RpdmVcXFwiKS5ub3QoYyksaD1jLnBhcmVudHMoXFxcIi5mci10b29sYmFyLCAuZnItcG9wdXBcXFwiKS5kYXRhKFxcXCJpbnN0YW5jZVxcXCIpfHxiO2lmKGguaGVscGVycy5pc0lPUygpJiYhaC5lbC5xdWVyeVNlbGVjdG9yKFxcXCIuZnItbWFya2VyXFxcIikmJihoLnNlbGVjdGlvbi5zYXZlKCksaC5zZWxlY3Rpb24uY2xlYXIoKSxoLnNlbGVjdGlvbi5yZXN0b3JlKCkpLCFmKXt2YXIgaT1jLmRhdGEoXFxcImNtZFxcXCIpO2UuZmluZChcXFwiLmZyLWNvbW1hbmRcXFwiKS5yZW1vdmVDbGFzcyhcXFwiZnItYWN0aXZlXFxcIikuYXR0cihcXFwiYXJpYS1zZWxlY3RlZFxcXCIsITEpLGEuRkUuQ09NTUFORFNbaV0mJmEuRkUuQ09NTUFORFNbaV0ucmVmcmVzaE9uU2hvdyYmYS5GRS5DT01NQU5EU1tpXS5yZWZyZXNoT25TaG93LmFwcGx5KGgsW2MsZV0pLGUuY3NzKFxcXCJsZWZ0XFxcIixjLm9mZnNldCgpLmxlZnQtYy5wYXJlbnQoKS5vZmZzZXQoKS5sZWZ0LShcXFwicnRsXFxcIj09Yi5vcHRzLmRpcmVjdGlvbj9lLndpZHRoKCktYy5vdXRlcldpZHRoKCk6MCkpLGIub3B0cy50b29sYmFyQm90dG9tP2UuY3NzKFxcXCJib3R0b21cXFwiLGIuJHRiLmhlaWdodCgpLWMucG9zaXRpb24oKS50b3ApOmUuY3NzKFxcXCJ0b3BcXFwiLGMucG9zaXRpb24oKS50b3ArYy5vdXRlckhlaWdodCgpKX1jLmFkZENsYXNzKFxcXCJmci1ibGlua1xcXCIpLnRvZ2dsZUNsYXNzKFxcXCJmci1hY3RpdmVcXFwiKSxjLmhhc0NsYXNzKFxcXCJmci1hY3RpdmVcXFwiKT8oZS5hdHRyKFxcXCJhcmlhLWhpZGRlblxcXCIsITEpLGMuYXR0cihcXFwiYXJpYS1leHBhbmRlZFxcXCIsITApKTooZS5hdHRyKFxcXCJhcmlhLWhpZGRlblxcXCIsITApLGMuYXR0cihcXFwiYXJpYS1leHBhbmRlZFxcXCIsITEpKSxzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7Yy5yZW1vdmVDbGFzcyhcXFwiZnItYmxpbmtcXFwiKX0sMzAwKSxlLm9mZnNldCgpLmxlZnQrZS5vdXRlcldpZHRoKCk+Yi4kc2Mub2Zmc2V0KCkubGVmdCtiLiRzYy5vdXRlcldpZHRoKCkmJmUuY3NzKFxcXCJtYXJnaW4tbGVmdFxcXCIsLShlLm9mZnNldCgpLmxlZnQrZS5vdXRlcldpZHRoKCktYi4kc2Mub2Zmc2V0KCkubGVmdC1iLiRzYy5vdXRlcldpZHRoKCkpKSxnLnJlbW92ZUNsYXNzKFxcXCJmci1hY3RpdmVcXFwiKS5hdHRyKFxcXCJhcmlhLWV4cGFuZGVkXFxcIiwhMSkubmV4dCgpLmF0dHIoXFxcImFyaWEtaGlkZGVuXFxcIiwhMCksZy5wYXJlbnQoXFxcIi5mci10b29sYmFyOm5vdCguZnItaW5saW5lKVxcXCIpLmNzcyhcXFwiekluZGV4XFxcIixcXFwiXFxcIiksMCE9PWMucGFyZW50cyhcXFwiLmZyLXBvcHVwXFxcIikubGVuZ3RofHxiLm9wdHMudG9vbGJhcklubGluZXx8KGIubm9kZS5oYXNDbGFzcyhjLmdldCgwKSxcXFwiZnItYWN0aXZlXFxcIik/Yi4kdGIuY3NzKFxcXCJ6SW5kZXhcXFwiLChiLm9wdHMuekluZGV4fHwxKSs0KTpiLiR0Yi5jc3MoXFxcInpJbmRleFxcXCIsXFxcIlxcXCIpKTt2YXIgaj1lLmZpbmQoXFxcImEuZnItY29tbWFuZC5mci1hY3RpdmU6Zmlyc3RcXFwiKTtiLmhlbHBlcnMuaXNNb2JpbGUoKXx8KGoubGVuZ3RoP2IuYWNjZXNzaWJpbGl0eS5mb2N1c1Rvb2xiYXJFbGVtZW50KGopOmIuYWNjZXNzaWJpbGl0eS5mb2N1c1Rvb2xiYXJFbGVtZW50KGMpKX1mdW5jdGlvbiBmKGEpe2EuYWRkQ2xhc3MoXFxcImZyLWJsaW5rXFxcIiksc2V0VGltZW91dChmdW5jdGlvbigpe2EucmVtb3ZlQ2xhc3MoXFxcImZyLWJsaW5rXFxcIil9LDUwMCk7Zm9yKHZhciBiPWEuZGF0YShcXFwiY21kXFxcIiksYz1bXTtcXFwidW5kZWZpbmVkXFxcIiE9dHlwZW9mIGEuZGF0YShcXFwicGFyYW1cXFwiKyhjLmxlbmd0aCsxKSk7KWMucHVzaChhLmRhdGEoXFxcInBhcmFtXFxcIisoYy5sZW5ndGgrMSkpKTt2YXIgZT1kKFxcXCIuZnItZHJvcGRvd24uZnItYWN0aXZlXFxcIik7ZS5sZW5ndGgmJihlLnJlbW92ZUNsYXNzKFxcXCJmci1hY3RpdmVcXFwiKS5hdHRyKFxcXCJhcmlhLWV4cGFuZGVkXFxcIiwhMSkubmV4dCgpLmF0dHIoXFxcImFyaWEtaGlkZGVuXFxcIiwhMCksZS5wYXJlbnQoXFxcIi5mci10b29sYmFyOm5vdCguZnItaW5saW5lKVxcXCIpLmNzcyhcXFwiekluZGV4XFxcIixcXFwiXFxcIikpLGEucGFyZW50cyhcXFwiLmZyLXBvcHVwLCAuZnItdG9vbGJhclxcXCIpLmRhdGEoXFxcImluc3RhbmNlXFxcIikuY29tbWFuZHMuZXhlYyhiLGMpfWZ1bmN0aW9uIGcoYSl7ZihhKX1mdW5jdGlvbiBoKGMpe3ZhciBkPWMucGFyZW50cyhcXFwiLmZyLXBvcHVwLCAuZnItdG9vbGJhclxcXCIpLmRhdGEoXFxcImluc3RhbmNlXFxcIik7aWYoMCE9PWMucGFyZW50cyhcXFwiLmZyLXBvcHVwXFxcIikubGVuZ3RofHxjLmRhdGEoXFxcInBvcHVwXFxcIil8fGQucG9wdXBzLmhpZGVBbGwoKSxkLnBvcHVwcy5hcmVWaXNpYmxlKCkmJiFkLnBvcHVwcy5hcmVWaXNpYmxlKGQpKXtmb3IodmFyIGY9MDtmPGEuRkUuSU5TVEFOQ0VTLmxlbmd0aDtmKyspYS5GRS5JTlNUQU5DRVNbZl0hPWQmJmEuRkUuSU5TVEFOQ0VTW2ZdLnBvcHVwcyYmYS5GRS5JTlNUQU5DRVNbZl0ucG9wdXBzLmFyZVZpc2libGUoKSYmYS5GRS5JTlNUQU5DRVNbZl0uJGVsLmZpbmQoXFxcIi5mci1tYXJrZXJcXFwiKS5yZW1vdmUoKTtkLnBvcHVwcy5oaWRlQWxsKCl9Yi5ub2RlLmhhc0NsYXNzKGMuZ2V0KDApLFxcXCJmci1kcm9wZG93blxcXCIpP2UoYyk6KGcoYyksYS5GRS5DT01NQU5EU1tjLmRhdGEoXFxcImNtZFxcXCIpXSYmYS5GRS5DT01NQU5EU1tjLmRhdGEoXFxcImNtZFxcXCIpXS5yZWZyZXNoQWZ0ZXJDYWxsYmFjayE9PSExJiZkLmJ1dHRvbi5idWxrUmVmcmVzaCgpKX1mdW5jdGlvbiBpKGIpe3ZhciBjPWEoYi5jdXJyZW50VGFyZ2V0KTtoKGMpfWZ1bmN0aW9uIGooYSl7dmFyIGI9YS5maW5kKFxcXCIuZnItZHJvcGRvd24uZnItYWN0aXZlXFxcIik7Yi5sZW5ndGgmJihiLnJlbW92ZUNsYXNzKFxcXCJmci1hY3RpdmVcXFwiKS5hdHRyKFxcXCJhcmlhLWV4cGFuZGVkXFxcIiwhMSkubmV4dCgpLmF0dHIoXFxcImFyaWEtaGlkZGVuXFxcIiwhMCksYi5wYXJlbnQoXFxcIi5mci10b29sYmFyOm5vdCguZnItaW5saW5lKVxcXCIpLmNzcyhcXFwiekluZGV4XFxcIixcXFwiXFxcIikpfWZ1bmN0aW9uIGsoYSl7YS5wcmV2ZW50RGVmYXVsdCgpLGEuc3RvcFByb3BhZ2F0aW9uKCl9ZnVuY3Rpb24gbChhKXtpZihhLnN0b3BQcm9wYWdhdGlvbigpLCFiLmhlbHBlcnMuaXNNb2JpbGUoKSlyZXR1cm4hMX1mdW5jdGlvbiBtKGMsZCl7Yi5ldmVudHMuYmluZENsaWNrKGMsXFxcIi5mci1jb21tYW5kOm5vdCguZnItZGlzYWJsZWQpXFxcIixpKSxiLmV2ZW50cy4kb24oYyxiLl9tb3VzZWRvd24rXFxcIiBcXFwiK2IuX21vdXNldXArXFxcIiBcXFwiK2IuX21vdmUsXFxcIi5mci1kcm9wZG93bi1tZW51XFxcIixrLCEwKSxiLmV2ZW50cy4kb24oYyxiLl9tb3VzZWRvd24rXFxcIiBcXFwiK2IuX21vdXNldXArXFxcIiBcXFwiK2IuX21vdmUsXFxcIi5mci1kcm9wZG93bi1tZW51IC5mci1kcm9wZG93bi13cmFwcGVyXFxcIixsLCEwKTt2YXIgZT1jLmdldCgwKS5vd25lckRvY3VtZW50LGY9XFxcImRlZmF1bHRWaWV3XFxcImluIGU/ZS5kZWZhdWx0VmlldzplLnBhcmVudFdpbmRvdyxnPWZ1bmN0aW9uKGQpeyghZHx8ZC50eXBlPT1iLl9tb3VzZXVwJiZkLnRhcmdldCE9YShcXFwiaHRtbFxcXCIpLmdldCgwKXx8XFxcImtleWRvd25cXFwiPT1kLnR5cGUmJihiLmtleXMuaXNDaGFyYWN0ZXIoZC53aGljaCkmJiFiLmtleXMuY3RybEtleShkKXx8ZC53aGljaD09YS5GRS5LRVlDT0RFLkVTQykpJiZqKGMpfTtiLmV2ZW50cy4kb24oYShmKSxiLl9tb3VzZXVwK1xcXCIgcmVzaXplIGtleWRvd25cXFwiLGcsITApLGIub3B0cy5pZnJhbWUmJmIuZXZlbnRzLiRvbihiLiR3aW4sYi5fbW91c2V1cCxnLCEwKSxiLm5vZGUuaGFzQ2xhc3MoYy5nZXQoMCksXFxcImZyLXBvcHVwXFxcIik/YS5tZXJnZSh3LGMuZmluZChcXFwiLmZyLWJ0blxcXCIpLnRvQXJyYXkoKSk6YS5tZXJnZSh2LGMuZmluZChcXFwiLmZyLWJ0blxcXCIpLnRvQXJyYXkoKSksYi50b29sdGlwLmJpbmQoYyxcXFwiLmZyLWJ0biwgLmZyLXRpdGxlXFxcIixkKX1mdW5jdGlvbiBuKGEsYyl7dmFyIGQ9XFxcIlxcXCI7aWYoYy5odG1sKWQrPVxcXCJmdW5jdGlvblxcXCI9PXR5cGVvZiBjLmh0bWw/Yy5odG1sLmNhbGwoYik6Yy5odG1sO2Vsc2V7dmFyIGU9Yy5vcHRpb25zO1xcXCJmdW5jdGlvblxcXCI9PXR5cGVvZiBlJiYoZT1lKCkpLGQrPSc8dWwgY2xhc3M9XFxcImZyLWRyb3Bkb3duLWxpc3RcXFwiIHJvbGU9XFxcInByZXNlbnRhdGlvblxcXCI+Jztmb3IodmFyIGYgaW4gZSlpZihlLmhhc093blByb3BlcnR5KGYpKXt2YXIgZz1iLnNob3J0Y3V0cy5nZXQoYStcXFwiLlxcXCIrZik7Zz1nPyc8c3BhbiBjbGFzcz1cXFwiZnItc2hvcnRjdXRcXFwiPicrZytcXFwiPC9zcGFuPlxcXCI6XFxcIlxcXCIsZCs9JzxsaSByb2xlPVxcXCJwcmVzZW50YXRpb25cXFwiPjxhIGNsYXNzPVxcXCJmci1jb21tYW5kXFxcIiB0YWJJbmRleD1cXFwiLTFcXFwiIHJvbGU9XFxcIm9wdGlvblxcXCIgZGF0YS1jbWQ9XFxcIicrYSsnXFxcIiBkYXRhLXBhcmFtMT1cXFwiJytmKydcXFwiIHRpdGxlPVxcXCInK2VbZl0rJ1xcXCI+JytiLmxhbmd1YWdlLnRyYW5zbGF0ZShlW2ZdKStcXFwiPC9hPjwvbGk+XFxcIn1kKz1cXFwiPC91bD5cXFwifXJldHVybiBkfWZ1bmN0aW9uIG8oYSxjLGQpe2lmKGIuaGVscGVycy5pc01vYmlsZSgpJiZjLnNob3dPbk1vYmlsZT09PSExKXJldHVyblxcXCJcXFwiO3ZhciBlPWMuZGlzcGxheVNlbGVjdGlvbjtcXFwiZnVuY3Rpb25cXFwiPT10eXBlb2YgZSYmKGU9ZShiKSk7dmFyIGY7aWYoZSl7dmFyIGc9XFxcImZ1bmN0aW9uXFxcIj09dHlwZW9mIGMuZGVmYXVsdFNlbGVjdGlvbj9jLmRlZmF1bHRTZWxlY3Rpb24oYik6Yy5kZWZhdWx0U2VsZWN0aW9uO2Y9JzxzcGFuIHN0eWxlPVxcXCJ3aWR0aDonKyhjLmRpc3BsYXlTZWxlY3Rpb25XaWR0aHx8MTAwKSsncHhcXFwiPicrKGd8fGIubGFuZ3VhZ2UudHJhbnNsYXRlKGMudGl0bGUpKStcXFwiPC9zcGFuPlxcXCJ9ZWxzZSBmPWIuaWNvbi5jcmVhdGUoYy5pY29ufHxhKSxmKz0nPHNwYW4gY2xhc3M9XFxcImZyLXNyLW9ubHlcXFwiPicrKGIubGFuZ3VhZ2UudHJhbnNsYXRlKGMudGl0bGUpfHxcXFwiXFxcIikrXFxcIjwvc3Bhbj5cXFwiO3ZhciBoPWMucG9wdXA/JyBkYXRhLXBvcHVwPVxcXCJ0cnVlXFxcIic6XFxcIlxcXCIsaT1jLm1vZGFsPycgZGF0YS1tb2RhbD1cXFwidHJ1ZVxcXCInOlxcXCJcXFwiLGo9Yi5zaG9ydGN1dHMuZ2V0KGErXFxcIi5cXFwiKTtqPWo/XFxcIiAoXFxcIitqK1xcXCIpXFxcIjpcXFwiXFxcIjt2YXIgaz1hK1xcXCItXFxcIitiLmlkLGw9XFxcImRyb3Bkb3duLW1lbnUtXFxcIitrLG09JzxidXR0b24gaWQ9XFxcIicraysnXFxcInR5cGU9XFxcImJ1dHRvblxcXCIgdGFiSW5kZXg9XFxcIi0xXFxcIiByb2xlPVxcXCJidXR0b25cXFwiJysoYy50b2dnbGU/JyBhcmlhLXByZXNzZWQ9XFxcImZhbHNlXFxcIic6XFxcIlxcXCIpKyhcXFwiZHJvcGRvd25cXFwiPT1jLnR5cGU/JyBhcmlhLWNvbnRyb2xzPVxcXCInK2wrJ1xcXCIgYXJpYS1leHBhbmRlZD1cXFwiZmFsc2VcXFwiIGFyaWEtaGFzcG9wdXA9XFxcInRydWVcXFwiJzpcXFwiXFxcIikrKGMuZGlzYWJsZWQ/JyBhcmlhLWRpc2FibGVkPVxcXCJ0cnVlXFxcIic6XFxcIlxcXCIpKycgdGl0bGU9XFxcIicrKGIubGFuZ3VhZ2UudHJhbnNsYXRlKGMudGl0bGUpfHxcXFwiXFxcIikraisnXFxcIiBjbGFzcz1cXFwiZnItY29tbWFuZCBmci1idG4nKyhcXFwiZHJvcGRvd25cXFwiPT1jLnR5cGU/XFxcIiBmci1kcm9wZG93blxcXCI6XFxcIlxcXCIpKyhcXFwiIGZyLWJ0bi1cXFwiK2IuaWNvbi5nZXRUZW1wbGF0ZShjLmljb24pKSsoYy5kaXNwbGF5U2VsZWN0aW9uP1xcXCIgZnItc2VsZWN0aW9uXFxcIjpcXFwiXFxcIikrKGMuYmFjaz9cXFwiIGZyLWJhY2tcXFwiOlxcXCJcXFwiKSsoYy5kaXNhYmxlZD9cXFwiIGZyLWRpc2FibGVkXFxcIjpcXFwiXFxcIikrKGQ/XFxcIlxcXCI6XFxcIiBmci1oaWRkZW5cXFwiKSsnXFxcIiBkYXRhLWNtZD1cXFwiJythKydcXFwiJytoK2krXFxcIj5cXFwiK2YrXFxcIjwvYnV0dG9uPlxcXCI7aWYoXFxcImRyb3Bkb3duXFxcIj09Yy50eXBlKXt2YXIgbz0nPGRpdiBpZD1cXFwiJytsKydcXFwiIGNsYXNzPVxcXCJmci1kcm9wZG93bi1tZW51XFxcIiByb2xlPVxcXCJsaXN0Ym94XFxcIiBhcmlhLWxhYmVsbGVkYnk9XFxcIicraysnXFxcIiBhcmlhLWhpZGRlbj1cXFwidHJ1ZVxcXCI+PGRpdiBjbGFzcz1cXFwiZnItZHJvcGRvd24td3JhcHBlclxcXCIgcm9sZT1cXFwicHJlc2VudGF0aW9uXFxcIj48ZGl2IGNsYXNzPVxcXCJmci1kcm9wZG93bi1jb250ZW50XFxcIiByb2xlPVxcXCJwcmVzZW50YXRpb25cXFwiPic7bys9bihhLGMpLG8rPVxcXCI8L2Rpdj48L2Rpdj48L2Rpdj5cXFwiLG0rPW99cmV0dXJuIG19ZnVuY3Rpb24gcChjLGQpe2Zvcih2YXIgZT1cXFwiXFxcIixmPTA7ZjxjLmxlbmd0aDtmKyspe3ZhciBnPWNbZl0saD1hLkZFLkNPTU1BTkRTW2ddO2lmKCEoaCYmXFxcInVuZGVmaW5lZFxcXCIhPXR5cGVvZiBoLnBsdWdpbiYmYi5vcHRzLnBsdWdpbnNFbmFibGVkLmluZGV4T2YoaC5wbHVnaW4pPDApKWlmKGgpe3ZhciBpPVxcXCJ1bmRlZmluZWRcXFwiPT10eXBlb2YgZHx8ZC5pbmRleE9mKGcpPj0wO2UrPW8oZyxoLGkpfWVsc2VcXFwifFxcXCI9PWc/ZSs9JzxkaXYgY2xhc3M9XFxcImZyLXNlcGFyYXRvciBmci12c1xcXCIgcm9sZT1cXFwic2VwYXJhdG9yXFxcIiBhcmlhLW9yaWVudGF0aW9uPVxcXCJ2ZXJ0aWNhbFxcXCI+PC9kaXY+JzpcXFwiLVxcXCI9PWcmJihlKz0nPGRpdiBjbGFzcz1cXFwiZnItc2VwYXJhdG9yIGZyLWhzXFxcIiByb2xlPVxcXCJzZXBhcmF0b3JcXFwiIGFyaWEtb3JpZW50YXRpb249XFxcImhvcml6b250YWxcXFwiPjwvZGl2PicpfXJldHVybiBlfWZ1bmN0aW9uIHEoYyl7dmFyIGQsZT1jLnBhcmVudHMoXFxcIi5mci1wb3B1cCwgLmZyLXRvb2xiYXJcXFwiKS5kYXRhKFxcXCJpbnN0YW5jZVxcXCIpfHxiLGY9Yy5kYXRhKFxcXCJjbWRcXFwiKTtiLm5vZGUuaGFzQ2xhc3MoYy5nZXQoMCksXFxcImZyLWRyb3Bkb3duXFxcIik/ZD1jLm5leHQoKTooYy5yZW1vdmVDbGFzcyhcXFwiZnItYWN0aXZlXFxcIiksYy5hdHRyKFxcXCJhcmlhLXByZXNzZWRcXFwiKSYmYy5hdHRyKFxcXCJhcmlhLXByZXNzZWRcXFwiLCExKSksYS5GRS5DT01NQU5EU1tmXSYmYS5GRS5DT01NQU5EU1tmXS5yZWZyZXNoP2EuRkUuQ09NTUFORFNbZl0ucmVmcmVzaC5hcHBseShlLFtjLGRdKTpiLnJlZnJlc2hbZl0mJmUucmVmcmVzaFtmXShjLGQpfWZ1bmN0aW9uIHIoYyl7dmFyIGQ9Yi4kdGI/Yi4kdGIuZGF0YShcXFwiaW5zdGFuY2VcXFwiKXx8YjpiO3JldHVybiBiLmV2ZW50cy50cmlnZ2VyKFxcXCJidXR0b25zLnJlZnJlc2hcXFwiKT09PSExfHx2b2lkIHNldFRpbWVvdXQoZnVuY3Rpb24oKXtmb3IodmFyIGU9ZC5zZWxlY3Rpb24uaW5FZGl0b3IoKSYmZC5jb3JlLmhhc0ZvY3VzKCksZj0wO2Y8Yy5sZW5ndGg7ZisrKXt2YXIgZz1hKGNbZl0pLGg9Zy5kYXRhKFxcXCJjbWRcXFwiKTswPT09Zy5wYXJlbnRzKFxcXCIuZnItcG9wdXBcXFwiKS5sZW5ndGg/ZXx8YS5GRS5DT01NQU5EU1toXSYmYS5GRS5DT01NQU5EU1toXS5mb3JjZWRSZWZyZXNoP2QuYnV0dG9uLnJlZnJlc2goZyk6Yi5ub2RlLmhhc0NsYXNzKGcuZ2V0KDApLFxcXCJmci1kcm9wZG93blxcXCIpfHwoZy5yZW1vdmVDbGFzcyhcXFwiZnItYWN0aXZlXFxcIiksZy5hdHRyKFxcXCJhcmlhLXByZXNzZWRcXFwiKSYmZy5hdHRyKFxcXCJhcmlhLXByZXNzZWRcXFwiLCExKSk6Zy5wYXJlbnRzKFxcXCIuZnItcG9wdXBcXFwiKS5pcyhcXFwiOnZpc2libGVcXFwiKSYmZC5idXR0b24ucmVmcmVzaChnKX19LDApfWZ1bmN0aW9uIHMoKXtyKHYpLHIodyl9ZnVuY3Rpb24gdCgpe3Y9W10sdz1bXX1mdW5jdGlvbiB1KCl7Yi5vcHRzLnRvb2xiYXJJbmxpbmU/Yi5ldmVudHMub24oXFxcInRvb2xiYXIuc2hvd1xcXCIscyk6KGIuZXZlbnRzLm9uKFxcXCJtb3VzZXVwXFxcIixzKSxiLmV2ZW50cy5vbihcXFwia2V5dXBcXFwiLHMpLGIuZXZlbnRzLm9uKFxcXCJibHVyXFxcIixzKSxiLmV2ZW50cy5vbihcXFwiZm9jdXNcXFwiLHMpLGIuZXZlbnRzLm9uKFxcXCJjb250ZW50Q2hhbmdlZFxcXCIscykpLGIuZXZlbnRzLm9uKFxcXCJzaGFyZWQuZGVzdHJveVxcXCIsdCl9dmFyIHY9W107KGIub3B0cy50b29sYmFySW5saW5lfHxiLm9wdHMudG9vbGJhckNvbnRhaW5lcikmJihiLnNoYXJlZC5idXR0b25zfHwoYi5zaGFyZWQuYnV0dG9ucz1bXSksdj1iLnNoYXJlZC5idXR0b25zKTt2YXIgdz1bXTtyZXR1cm4gYi5zaGFyZWQucG9wdXBfYnV0dG9uc3x8KGIuc2hhcmVkLnBvcHVwX2J1dHRvbnM9W10pLHc9Yi5zaGFyZWQucG9wdXBfYnV0dG9ucyx7X2luaXQ6dSxidWlsZExpc3Q6cCxiaW5kQ29tbWFuZHM6bSxyZWZyZXNoOnEsYnVsa1JlZnJlc2g6cyxleGVjOmYsY2xpY2s6aCxoaWRlQWN0aXZlRHJvcGRvd25zOmosZ2V0QnV0dG9uczpkfX0sYS5GRS5NT0RVTEVTLm1vZGFscz1mdW5jdGlvbihiKXtmdW5jdGlvbiBjKGEpe3JldHVybiBuW2FdfWZ1bmN0aW9uIGQoYyxkKXt2YXIgZT0nPGRpdiB0YWJJbmRleD1cXFwiLTFcXFwiIGNsYXNzPVxcXCJmci1tb2RhbCcrKGIub3B0cy50aGVtZT9cXFwiIFxcXCIrYi5vcHRzLnRoZW1lK1xcXCItdGhlbWVcXFwiOlxcXCJcXFwiKSsnXFxcIj48ZGl2IGNsYXNzPVxcXCJmci1tb2RhbC13cmFwcGVyXFxcIj4nLGY9JzxpIHRpdGxlPVxcXCInK2IubGFuZ3VhZ2UudHJhbnNsYXRlKFxcXCJDYW5jZWxcXFwiKSsnXFxcIiBjbGFzcz1cXFwiZmEgZmEtdGltZXMgZnItbW9kYWwtY2xvc2VcXFwiPjwvaT4nO3JldHVybiBlKz0nPGRpdiBjbGFzcz1cXFwiZnItbW9kYWwtaGVhZFxcXCI+JytjK2YrXFxcIjwvZGl2PlxcXCIsZSs9JzxkaXYgdGFiSW5kZXg9XFxcIi0xXFxcIiBjbGFzcz1cXFwiZnItbW9kYWwtYm9keVxcXCI+JytkK1xcXCI8L2Rpdj5cXFwiLGUrPVxcXCI8L2Rpdj48L2Rpdj5cXFwiLGEoZSl9ZnVuY3Rpb24gZShjLGUsZil7aWYoYi5zaGFyZWQuJG92ZXJsYXl8fChiLnNoYXJlZC4kb3ZlcmxheT1hKCc8ZGl2IGNsYXNzPVxcXCJmci1vdmVybGF5XFxcIj4nKS5hcHBlbmRUbyhcXFwiYm9keVxcXCIpKSxtPWIuc2hhcmVkLiRvdmVybGF5LGIub3B0cy50aGVtZSYmbS5hZGRDbGFzcyhiLm9wdHMudGhlbWUrXFxcIi10aGVtZVxcXCIpLCFuW2NdKXt2YXIgZz1kKGUsZik7bltjXT17JG1vZGFsOmcsJGhlYWQ6Zy5maW5kKFxcXCIuZnItbW9kYWwtaGVhZFxcXCIpLCRib2R5OmcuZmluZChcXFwiLmZyLW1vZGFsLWJvZHlcXFwiKX0sYi5oZWxwZXJzLmlzTW9iaWxlKCl8fGcuYWRkQ2xhc3MoXFxcImZyLWRlc2t0b3BcXFwiKSxnLmFwcGVuZFRvKFxcXCJib2R5XFxcIiksYi5ldmVudHMuYmluZENsaWNrKGcsXFxcImkuZnItbW9kYWwtY2xvc2VcXFwiLGZ1bmN0aW9uKCl7aChjKX0pLG5bY10uJGJvZHkuY3NzKFxcXCJtYXJnaW4tdG9wXFxcIixuW2NdLiRoZWFkLm91dGVySGVpZ2h0KCkpLGIuZXZlbnRzLiRvbihnLFxcXCJrZXlkb3duXFxcIixmdW5jdGlvbihkKXt2YXIgZT1kLndoaWNoO3JldHVybiBlPT1hLkZFLktFWUNPREUuRVNDPyhoKGMpLGIuYWNjZXNzaWJpbGl0eS5mb2N1c01vZGFsQnV0dG9uKGcpLCExKTohKCFhKGQuY3VycmVudFRhcmdldCkuaXMoXFxcImlucHV0W3R5cGU9dGV4dF0sIHRleHRhcmVhXFxcIikmJmUhPWEuRkUuS0VZQ09ERS5BUlJPV19VUCYmZSE9YS5GRS5LRVlDT0RFLkFSUk9XX0RPV04mJiFiLmtleXMuaXNCcm93c2VyQWN0aW9uKGQpKXx8KGQucHJldmVudERlZmF1bHQoKSxkLnN0b3BQcm9wYWdhdGlvbigpLCExKX0sITApLGgoYywhMCl9cmV0dXJuIG5bY119ZnVuY3Rpb24gZigpe2Zvcih2YXIgYSBpbiBuKXt2YXIgYj1uW2FdO2ImJmIuJG1vZGFsJiZiLiRtb2RhbC5yZW1vdmVEYXRhKCkucmVtb3ZlKCl9bSYmbS5yZW1vdmVEYXRhKCkucmVtb3ZlKCksbj17fX1mdW5jdGlvbiBnKGMpe2lmKG5bY10pe3ZhciBkPW5bY10uJG1vZGFsO2QuZGF0YShcXFwiaW5zdGFuY2VcXFwiLGIpLGQuc2hvdygpLG0uc2hvdygpLGEoYi5vX2RvYykuZmluZChcXFwiYm9keVxcXCIpLmFkZENsYXNzKFxcXCJwcmV2ZW50LXNjcm9sbFxcXCIpLGIuaGVscGVycy5pc01vYmlsZSgpJiZhKGIub19kb2MpLmZpbmQoXFxcImJvZHlcXFwiKS5hZGRDbGFzcyhcXFwiZnItbW9iaWxlXFxcIiksZC5hZGRDbGFzcyhcXFwiZnItYWN0aXZlXFxcIiksYi5hY2Nlc3NpYmlsaXR5LmZvY3VzTW9kYWwoZCl9fWZ1bmN0aW9uIGgoYyxkKXtpZihuW2NdKXt2YXIgZT1uW2NdLiRtb2RhbCxmPWUuZGF0YShcXFwiaW5zdGFuY2VcXFwiKXx8YjtmLmV2ZW50cy5lbmFibGVCbHVyKCksZS5oaWRlKCksbS5oaWRlKCksYShmLm9fZG9jKS5maW5kKFxcXCJib2R5XFxcIikucmVtb3ZlQ2xhc3MoXFxcInByZXZlbnQtc2Nyb2xsIGZyLW1vYmlsZVxcXCIpLGUucmVtb3ZlQ2xhc3MoXFxcImZyLWFjdGl2ZVxcXCIpLGR8fChiLmFjY2Vzc2liaWxpdHkucmVzdG9yZVNlbGVjdGlvbihmKSxiLmV2ZW50cy50cmlnZ2VyKFxcXCJtb2RhbHMuaGlkZVxcXCIpKX19ZnVuY3Rpb24gaShhKXtpZihuW2FdKXt2YXIgYz1uW2FdLGQ9Yy4kbW9kYWwsZT1jLiRib2R5LGY9Yi4kd2luLmhlaWdodCgpLGc9ZC5maW5kKFxcXCIuZnItbW9kYWwtd3JhcHBlclxcXCIpLGg9Zy5vdXRlckhlaWdodCghMCksaT1nLmhlaWdodCgpLShlLm91dGVySGVpZ2h0KCEwKS1lLmhlaWdodCgpKSxqPWYtaCtpLGs9ZS5nZXQoMCkuc2Nyb2xsSGVpZ2h0LGw9XFxcImF1dG9cXFwiO2s+aiYmKGw9aiksZS5oZWlnaHQobCl9fWZ1bmN0aW9uIGooYSl7dmFyIGM7aWYoXFxcInN0cmluZ1xcXCI9PXR5cGVvZiBhKXtpZighblthXSlyZXR1cm47Yz1uW2FdLiRtb2RhbH1lbHNlIGM9YTtyZXR1cm4gYyYmYi5ub2RlLmhhc0NsYXNzKGMsXFxcImZyLWFjdGl2ZVxcXCIpJiZiLmNvcmUuc2FtZUluc3RhbmNlKGMpfHwhMX1mdW5jdGlvbiBrKGEpe2Zvcih2YXIgYiBpbiBuKWlmKG4uaGFzT3duUHJvcGVydHkoYikmJmooYikmJihcXFwidW5kZWZpbmVkXFxcIj09dHlwZW9mIGF8fG5bYl0uJG1vZGFsLmRhdGEoXFxcImluc3RhbmNlXFxcIik9PWEpKXJldHVybiBuW2JdLiRtb2RhbDtyZXR1cm4hMX1mdW5jdGlvbiBsKCl7Yi5ldmVudHMub24oXFxcInNoYXJlZC5kZXN0cm95XFxcIixmLCEwKX1iLnNoYXJlZC5tb2RhbHN8fChiLnNoYXJlZC5tb2RhbHM9e30pO3ZhciBtLG49Yi5zaGFyZWQubW9kYWxzO3JldHVybntfaW5pdDpsLGdldDpjLGNyZWF0ZTplLHNob3c6ZyxoaWRlOmgscmVzaXplOmksaXNWaXNpYmxlOmosYXJlVmlzaWJsZTprfX0sYS5GRS5QT1BVUF9URU1QTEFURVM9e1xcXCJ0ZXh0LmVkaXRcXFwiOlxcXCJbX0VESVRfXVxcXCJ9LGEuRkUuUmVnaXN0ZXJUZW1wbGF0ZT1mdW5jdGlvbihiLGMpe2EuRkUuUE9QVVBfVEVNUExBVEVTW2JdPWN9LGEuRkUuTU9EVUxFUy5wb3B1cHM9ZnVuY3Rpb24oYil7ZnVuY3Rpb24gYyhhLGMpe2MuaXMoXFxcIjp2aXNpYmxlXFxcIil8fChjPWIuJHNjKSxjLmlzKHhbYV0uZGF0YShcXFwiY29udGFpbmVyXFxcIikpfHwoeFthXS5kYXRhKFxcXCJjb250YWluZXJcXFwiLGMpLGMuYXBwZW5kKHhbYV0pKX1mdW5jdGlvbiBkKGEsZCxlLGgpe2lmKGcoKSYmYi4kZWwuZmluZChcXFwiLmZyLW1hcmtlclxcXCIpLmxlbmd0aD4wPyhiLmV2ZW50cy5kaXNhYmxlQmx1cigpLGIuc2VsZWN0aW9uLnJlc3RvcmUoKSk6KGIuZXZlbnRzLmRpc2FibGVCbHVyKCksYi5ldmVudHMuZm9jdXMoKSxiLmV2ZW50cy5lbmFibGVCbHVyKCkpLG0oW2FdKSwheFthXSlyZXR1cm4hMTt2YXIgaT1iLmJ1dHRvbi5nZXRCdXR0b25zKFxcXCIuZnItZHJvcGRvd24uZnItYWN0aXZlXFxcIik7aS5yZW1vdmVDbGFzcyhcXFwiZnItYWN0aXZlXFxcIikuYXR0cihcXFwiYXJpYS1leHBhbmRlZFxcXCIsITEpLnBhcmVudChcXFwiLmZyLXRvb2xiYXJcXFwiKS5jc3MoXFxcInpJbmRleFxcXCIsXFxcIlxcXCIpLGkubmV4dCgpLmF0dHIoXFxcImFyaWEtaGlkZGVuXFxcIiwhMCkseFthXS5kYXRhKFxcXCJpbnN0YW5jZVxcXCIsYiksYi4kdGImJmIuJHRiLmRhdGEoXFxcImluc3RhbmNlXFxcIixiKTt2YXIgaj14W2FdLm91dGVyV2lkdGgoKSxrPWYoYSk7eFthXS5hZGRDbGFzcyhcXFwiZnItYWN0aXZlXFxcIikucmVtb3ZlQ2xhc3MoXFxcImZyLWhpZGRlblxcXCIpLmZpbmQoXFxcImlucHV0LCB0ZXh0YXJlYVxcXCIpLnJlbW92ZUF0dHIoXFxcImRpc2FibGVkXFxcIik7dmFyIGw9eFthXS5kYXRhKFxcXCJjb250YWluZXJcXFwiKTtiLm9wdHMudG9vbGJhcklubGluZSYmbCYmYi4kdGImJmwuZ2V0KDApPT1iLiR0Yi5nZXQoMCkmJihjKGEsYi4kc2MpLGU9Yi4kdGIub2Zmc2V0KCkudG9wLWIuaGVscGVycy5nZXRQWChiLiR0Yi5jc3MoXFxcIm1hcmdpbi10b3BcXFwiKSksZD1iLiR0Yi5vZmZzZXQoKS5sZWZ0K2IuJHRiLm91dGVyV2lkdGgoKS8yKyhwYXJzZUZsb2F0KGIuJHRiLmZpbmQoXFxcIi5mci1hcnJvd1xcXCIpLmNzcyhcXFwibWFyZ2luLWxlZnRcXFwiKSl8fDApK2IuJHRiLmZpbmQoXFxcIi5mci1hcnJvd1xcXCIpLm91dGVyV2lkdGgoKS8yLGIubm9kZS5oYXNDbGFzcyhiLiR0Yi5nZXQoMCksXFxcImZyLWFib3ZlXFxcIikmJmUmJihlKz1iLiR0Yi5vdXRlckhlaWdodCgpKSxoPTApLGw9eFthXS5kYXRhKFxcXCJjb250YWluZXJcXFwiKSwhYi5vcHRzLmlmcmFtZXx8aHx8a3x8KGQmJihkLT1iLiRpZnJhbWUub2Zmc2V0KCkubGVmdCksZSYmKGUtPWIuJGlmcmFtZS5vZmZzZXQoKS50b3ApKSxsLmlzKGIuJHRiKT9iLiR0Yi5jc3MoXFxcInpJbmRleFxcXCIsKGIub3B0cy56SW5kZXh8fDEpKzQpOnhbYV0uY3NzKFxcXCJ6SW5kZXhcXFwiLChiLm9wdHMuekluZGV4fHwxKSs0KSxkJiYoZC09ai8yKSxiLm9wdHMudG9vbGJhckJvdHRvbSYmbCYmYi4kdGImJmwuZ2V0KDApPT1iLiR0Yi5nZXQoMCkmJih4W2FdLmFkZENsYXNzKFxcXCJmci1hYm92ZVxcXCIpLGUmJihlLT14W2FdLm91dGVySGVpZ2h0KCkpKSx4W2FdLnJlbW92ZUNsYXNzKFxcXCJmci1hY3RpdmVcXFwiKSxiLnBvc2l0aW9uLmF0KGQsZSx4W2FdLGh8fDApLHhbYV0uYWRkQ2xhc3MoXFxcImZyLWFjdGl2ZVxcXCIpLGt8fGIuYWNjZXNzaWJpbGl0eS5mb2N1c1BvcHVwKHhbYV0pLGIub3B0cy50b29sYmFySW5saW5lJiZiLnRvb2xiYXIuaGlkZSgpLGIuZXZlbnRzLnRyaWdnZXIoXFxcInBvcHVwcy5zaG93LlxcXCIrYSkscyhhKS5fcmVwb3NpdGlvblBvcHVwKCksbygpfWZ1bmN0aW9uIGUoYSxjKXtiLmV2ZW50cy5vbihcXFwicG9wdXBzLnNob3cuXFxcIithLGMpfWZ1bmN0aW9uIGYoYSl7cmV0dXJuIHhbYV0mJmIubm9kZS5oYXNDbGFzcyh4W2FdLFxcXCJmci1hY3RpdmVcXFwiKSYmYi5jb3JlLnNhbWVJbnN0YW5jZSh4W2FdKXx8ITF9ZnVuY3Rpb24gZyhhKXtmb3IodmFyIGIgaW4geClpZih4Lmhhc093blByb3BlcnR5KGIpJiZmKGIpJiYoXFxcInVuZGVmaW5lZFxcXCI9PXR5cGVvZiBhfHx4W2JdLmRhdGEoXFxcImluc3RhbmNlXFxcIik9PWEpKXJldHVybiB4W2JdO1xcbnJldHVybiExfWZ1bmN0aW9uIGgoYSl7dmFyIGM9bnVsbDtjPVxcXCJzdHJpbmdcXFwiIT10eXBlb2YgYT9hOnhbYV0sYyYmYi5ub2RlLmhhc0NsYXNzKGMsXFxcImZyLWFjdGl2ZVxcXCIpJiYoYy5yZW1vdmVDbGFzcyhcXFwiZnItYWN0aXZlIGZyLWFib3ZlXFxcIiksYi5ldmVudHMudHJpZ2dlcihcXFwicG9wdXBzLmhpZGUuXFxcIithKSxiLiR0YiYmKGIub3B0cy56SW5kZXg+MT9iLiR0Yi5jc3MoXFxcInpJbmRleFxcXCIsYi5vcHRzLnpJbmRleCsxKTpiLiR0Yi5jc3MoXFxcInpJbmRleFxcXCIsXFxcIlxcXCIpKSxiLmV2ZW50cy5kaXNhYmxlQmx1cigpLGMuZmluZChcXFwiaW5wdXQsIHRleHRhcmVhLCBidXR0b25cXFwiKS5maWx0ZXIoXFxcIjpmb2N1c1xcXCIpLmJsdXIoKSxjLmZpbmQoXFxcImlucHV0LCB0ZXh0YXJlYVxcXCIpLmF0dHIoXFxcImRpc2FibGVkXFxcIixcXFwiZGlzYWJsZWRcXFwiKSl9ZnVuY3Rpb24gaShhLGMpe2IuZXZlbnRzLm9uKFxcXCJwb3B1cHMuaGlkZS5cXFwiK2EsYyl9ZnVuY3Rpb24gaihhKXt2YXIgYz14W2FdO2lmKGMmJiFjLmRhdGEoXFxcImluc3RcXFwiK2IuaWQpKXt2YXIgZD1zKGEpO3QoZCxhKX1yZXR1cm4gY31mdW5jdGlvbiBrKGEsYyl7Yi5ldmVudHMub24oXFxcInBvcHVwcy5yZWZyZXNoLlxcXCIrYSxjKX1mdW5jdGlvbiBsKGMpe2IuZXZlbnRzLnRyaWdnZXIoXFxcInBvcHVwcy5yZWZyZXNoLlxcXCIrYyk7Zm9yKHZhciBkPXhbY10uZmluZChcXFwiLmZyLWNvbW1hbmRcXFwiKSxlPTA7ZTxkLmxlbmd0aDtlKyspe3ZhciBmPWEoZFtlXSk7MD09PWYucGFyZW50cyhcXFwiLmZyLWRyb3Bkb3duLW1lbnVcXFwiKS5sZW5ndGgmJmIuYnV0dG9uLnJlZnJlc2goZil9fWZ1bmN0aW9uIG0oYSl7XFxcInVuZGVmaW5lZFxcXCI9PXR5cGVvZiBhJiYoYT1bXSk7Zm9yKHZhciBiIGluIHgpeC5oYXNPd25Qcm9wZXJ0eShiKSYmYS5pbmRleE9mKGIpPDAmJmgoYil9ZnVuY3Rpb24gbigpe2Iuc2hhcmVkLmV4aXRfZmxhZz0hMH1mdW5jdGlvbiBvKCl7Yi5zaGFyZWQuZXhpdF9mbGFnPSExfWZ1bmN0aW9uIHAoKXtyZXR1cm4gYi5zaGFyZWQuZXhpdF9mbGFnfWZ1bmN0aW9uIHEoYyxkKXt2YXIgZT1hLkZFLlBPUFVQX1RFTVBMQVRFU1tjXTtcXFwiZnVuY3Rpb25cXFwiPT10eXBlb2YgZSYmKGU9ZS5hcHBseShiKSk7Zm9yKHZhciBmIGluIGQpZC5oYXNPd25Qcm9wZXJ0eShmKSYmKGU9ZS5yZXBsYWNlKFxcXCJbX1xcXCIrZi50b1VwcGVyQ2FzZSgpK1xcXCJfXVxcXCIsZFtmXSkpO3JldHVybiBlfWZ1bmN0aW9uIHIoYyxkKXt2YXIgZT1xKGMsZCksZj1hKCc8ZGl2IGNsYXNzPVxcXCJmci1wb3B1cCcrKGIuaGVscGVycy5pc01vYmlsZSgpP1xcXCIgZnItbW9iaWxlXFxcIjpcXFwiIGZyLWRlc2t0b3BcXFwiKSsoYi5vcHRzLnRvb2xiYXJJbmxpbmU/XFxcIiBmci1pbmxpbmVcXFwiOlxcXCJcXFwiKSsnXFxcIj48c3BhbiBjbGFzcz1cXFwiZnItYXJyb3dcXFwiPjwvc3Bhbj4nK2UrXFxcIjwvZGl2PlxcXCIpO2Iub3B0cy50aGVtZSYmZi5hZGRDbGFzcyhiLm9wdHMudGhlbWUrXFxcIi10aGVtZVxcXCIpLGIub3B0cy56SW5kZXg+MSYmYi4kdGIuY3NzKFxcXCJ6LWluZGV4XFxcIixiLm9wdHMuekluZGV4KzIpLFxcXCJhdXRvXFxcIiE9Yi5vcHRzLmRpcmVjdGlvbiYmZi5yZW1vdmVDbGFzcyhcXFwiZnItbHRyIGZyLXJ0bFxcXCIpLmFkZENsYXNzKFxcXCJmci1cXFwiK2Iub3B0cy5kaXJlY3Rpb24pLGYuZmluZChcXFwiaW5wdXQsIHRleHRhcmVhXFxcIikuYXR0cihcXFwiZGlyXFxcIixiLm9wdHMuZGlyZWN0aW9uKS5hdHRyKFxcXCJkaXNhYmxlZFxcXCIsXFxcImRpc2FibGVkXFxcIik7dmFyIGc9YShcXFwiYm9keVxcXCIpO3JldHVybiBnLmFwcGVuZChmKSxmLmRhdGEoXFxcImNvbnRhaW5lclxcXCIsZykseFtjXT1mLGIuYnV0dG9uLmJpbmRDb21tYW5kcyhmLCExKSxmfWZ1bmN0aW9uIHMoYyl7dmFyIGQ9eFtjXTtyZXR1cm57X3dpbmRvd1Jlc2l6ZTpmdW5jdGlvbigpe3ZhciBhPWQuZGF0YShcXFwiaW5zdGFuY2VcXFwiKXx8YjshYS5oZWxwZXJzLmlzTW9iaWxlKCkmJmQuaXMoXFxcIjp2aXNpYmxlXFxcIikmJihhLmV2ZW50cy5kaXNhYmxlQmx1cigpLGEucG9wdXBzLmhpZGUoYyksYS5ldmVudHMuZW5hYmxlQmx1cigpKX0sX2lucHV0Rm9jdXM6ZnVuY3Rpb24oYyl7dmFyIGU9ZC5kYXRhKFxcXCJpbnN0YW5jZVxcXCIpfHxiLGY9YShjLmN1cnJlbnRUYXJnZXQpO2lmKGYuaXMoXFxcImlucHV0OmZpbGVcXFwiKSYmZi5jbG9zZXN0KFxcXCIuZnItbGF5ZXJcXFwiKS5hZGRDbGFzcyhcXFwiZnItaW5wdXQtZm9jdXNcXFwiKSxjLnByZXZlbnREZWZhdWx0KCksYy5zdG9wUHJvcGFnYXRpb24oKSxzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7ZS5ldmVudHMuZW5hYmxlQmx1cigpfSwwKSxlLmhlbHBlcnMuaXNNb2JpbGUoKSl7dmFyIGc9YShlLm9fd2luKS5zY3JvbGxUb3AoKTtzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7YShlLm9fd2luKS5zY3JvbGxUb3AoZyl9LDApfX0sX2lucHV0Qmx1cjpmdW5jdGlvbihjKXt2YXIgZT1kLmRhdGEoXFxcImluc3RhbmNlXFxcIil8fGIsZj1hKGMuY3VycmVudFRhcmdldCk7Zi5pcyhcXFwiaW5wdXQ6ZmlsZVxcXCIpJiZmLmNsb3Nlc3QoXFxcIi5mci1sYXllclxcXCIpLnJlbW92ZUNsYXNzKFxcXCJmci1pbnB1dC1mb2N1c1xcXCIpLGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQhPXRoaXMmJmEodGhpcykuaXMoXFxcIjp2aXNpYmxlXFxcIikmJihlLmV2ZW50cy5ibHVyQWN0aXZlKCkmJmUuZXZlbnRzLnRyaWdnZXIoXFxcImJsdXJcXFwiKSxlLmV2ZW50cy5lbmFibGVCbHVyKCkpfSxfZWRpdG9yS2V5ZG93bjpmdW5jdGlvbihlKXt2YXIgZz1kLmRhdGEoXFxcImluc3RhbmNlXFxcIil8fGI7Zy5rZXlzLmN0cmxLZXkoZSl8fGUud2hpY2g9PWEuRkUuS0VZQ09ERS5BTFR8fGUud2hpY2g9PWEuRkUuS0VZQ09ERS5FU0N8fChmKGMpJiZkLmZpbmQoXFxcIi5mci1iYWNrOnZpc2libGVcXFwiKS5sZW5ndGg/Zy5idXR0b24uZXhlYyhkLmZpbmQoXFxcIi5mci1iYWNrOnZpc2libGU6Zmlyc3RcXFwiKSk6ZS53aGljaCE9YS5GRS5LRVlDT0RFLkFMVCYmZy5wb3B1cHMuaGlkZShjKSl9LF9wcmV2ZW50Rm9jdXM6ZnVuY3Rpb24oYyl7dmFyIGU9ZC5kYXRhKFxcXCJpbnN0YW5jZVxcXCIpfHxiO1xcXCJtb3VzZXVwXFxcIj09Yy50eXBlJiZiLmJ1dHRvbi5oaWRlQWN0aXZlRHJvcGRvd25zKGQpO3ZhciBmPWMub3JpZ2luYWxFdmVudD9jLm9yaWdpbmFsRXZlbnQudGFyZ2V0fHxjLm9yaWdpbmFsRXZlbnQub3JpZ2luYWxUYXJnZXQ6bnVsbDtcXFwibW91c2V1cFxcXCI9PWMudHlwZXx8YShmKS5pcyhcXFwiOmZvY3VzXFxcIil8fGUuZXZlbnRzLmRpc2FibGVCbHVyKCksYi5icm93c2VyLnNhZmFyaSYmXFxcIm1vdXNlZG93blxcXCI9PWMudHlwZSYmYShmKS5pcyhcXFwiaW5wdXRbdHlwZT1maWxlXVxcXCIpJiZlLmV2ZW50cy5kaXNhYmxlQmx1cigpO3ZhciBnPVxcXCJpbnB1dCwgdGV4dGFyZWEsIGJ1dHRvbiwgc2VsZWN0LCBsYWJlbCwgLmZyLWNvbW1hbmRcXFwiO3JldHVybiBmJiYhYShmKS5pcyhnKSYmMD09PWEoZikucGFyZW50cyhnKS5sZW5ndGg/KGMuc3RvcFByb3BhZ2F0aW9uKCksITEpOihmJiZhKGYpLmlzKGcpJiZjLnN0b3BQcm9wYWdhdGlvbigpLHZvaWQgbygpKX0sX2VkaXRvck1vdXNldXA6ZnVuY3Rpb24oKXtkLmlzKFxcXCI6dmlzaWJsZVxcXCIpJiZwKCkmJmQuZmluZChcXFwiaW5wdXQ6Zm9jdXMsIHRleHRhcmVhOmZvY3VzLCBidXR0b246Zm9jdXMsIHNlbGVjdDpmb2N1c1xcXCIpLmZpbHRlcihcXFwiOnZpc2libGVcXFwiKS5sZW5ndGg+MCYmYi5ldmVudHMuZGlzYWJsZUJsdXIoKX0sX3dpbmRvd01vdXNldXA6ZnVuY3Rpb24oYSl7aWYoIWIuY29yZS5zYW1lSW5zdGFuY2UoZCkpcmV0dXJuITA7dmFyIGU9ZC5kYXRhKFxcXCJpbnN0YW5jZVxcXCIpfHxiO2QuaXMoXFxcIjp2aXNpYmxlXFxcIikmJnAoKSYmKGEuc3RvcFByb3BhZ2F0aW9uKCksZS5tYXJrZXJzLnJlbW92ZSgpLGUucG9wdXBzLmhpZGUoYyksbygpKX0sX3dpbmRvd0tleWRvd246ZnVuY3Rpb24oZSl7aWYoIWIuY29yZS5zYW1lSW5zdGFuY2UoZCkpcmV0dXJuITA7dmFyIGY9ZC5kYXRhKFxcXCJpbnN0YW5jZVxcXCIpfHxiLGc9ZS53aGljaDtpZihhLkZFLktFWUNPREUuRVNDPT1nKXtpZihmLnBvcHVwcy5pc1Zpc2libGUoYykmJmYub3B0cy50b29sYmFySW5saW5lKXJldHVybiBlLnN0b3BQcm9wYWdhdGlvbigpLGYucG9wdXBzLmlzVmlzaWJsZShjKSYmKGQuZmluZChcXFwiLmZyLWJhY2s6dmlzaWJsZVxcXCIpLmxlbmd0aD8oZi5idXR0b24uZXhlYyhkLmZpbmQoXFxcIi5mci1iYWNrOnZpc2libGU6Zmlyc3RcXFwiKSksZi5hY2Nlc3NpYmlsaXR5LmZvY3VzUG9wdXBCdXR0b24oZCkpOmQuZmluZChcXFwiLmZyLWRpc21pc3M6dmlzaWJsZVxcXCIpLmxlbmd0aD9mLmJ1dHRvbi5leGVjKGQuZmluZChcXFwiLmZyLWRpc21pc3M6dmlzaWJsZTpmaXJzdFxcXCIpKTooZi5wb3B1cHMuaGlkZShjKSxmLnRvb2xiYXIuc2hvd0lubGluZShudWxsLCEwKSxmLmFjY2Vzc2liaWxpdHkuRm9jdXNQb3B1cEJ1dHRvbihkKSkpLCExO2lmKGYucG9wdXBzLmlzVmlzaWJsZShjKSlyZXR1cm4gZC5maW5kKFxcXCIuZnItYmFjazp2aXNpYmxlXFxcIikubGVuZ3RoPyhmLmJ1dHRvbi5leGVjKGQuZmluZChcXFwiLmZyLWJhY2s6dmlzaWJsZTpmaXJzdFxcXCIpKSxmLmFjY2Vzc2liaWxpdHkuZm9jdXNQb3B1cEJ1dHRvbihkKSk6ZC5maW5kKFxcXCIuZnItZGlzbWlzczp2aXNpYmxlXFxcIikubGVuZ3RoP2YuYnV0dG9uLmV4ZWMoZC5maW5kKFxcXCIuZnItZGlzbWlzczp2aXNpYmxlOmZpcnN0XFxcIikpOihmLnBvcHVwcy5oaWRlKGMpLGYuYWNjZXNzaWJpbGl0eS5mb2N1c1BvcHVwQnV0dG9uKGQpKSwhMX19LF9kb1BsYWNlaG9sZGVyOmZ1bmN0aW9uKCl7dmFyIGI9YSh0aGlzKS5uZXh0KCk7MD09PWIubGVuZ3RoJiZhKHRoaXMpLmF0dHIoXFxcInBsYWNlaG9sZGVyXFxcIikmJmEodGhpcykuYWZ0ZXIoJzxsYWJlbCBmb3I9XFxcIicrYSh0aGlzKS5hdHRyKFxcXCJpZFxcXCIpKydcXFwiPicrYSh0aGlzKS5hdHRyKFxcXCJwbGFjZWhvbGRlclxcXCIpK1xcXCI8L2xhYmVsPlxcXCIpLGEodGhpcykudG9nZ2xlQ2xhc3MoXFxcImZyLW5vdC1lbXB0eVxcXCIsXFxcIlxcXCIhPT1hKHRoaXMpLnZhbCgpKX0sX3JlcG9zaXRpb25Qb3B1cDpmdW5jdGlvbigpe2lmKCFiLm9wdHMuaGVpZ2h0JiYhYi5vcHRzLmhlaWdodE1heHx8Yi5vcHRzLnRvb2xiYXJJbmxpbmUpcmV0dXJuITA7aWYoYi4kd3AmJmYoYykmJmQucGFyZW50KCkuZ2V0KDApPT1iLiRzYy5nZXQoMCkpe3ZhciBhPWQub2Zmc2V0KCkudG9wLWIuJHdwLm9mZnNldCgpLnRvcCxlPWIuJHdwLm91dGVySGVpZ2h0KCk7Yi5ub2RlLmhhc0NsYXNzKGQuZ2V0KDApLFxcXCJmci1hYm92ZVxcXCIpJiYoYSs9ZC5vdXRlckhlaWdodCgpKSxhPmV8fGE8MD9kLmFkZENsYXNzKFxcXCJmci1oaWRkZW5cXFwiKTpkLnJlbW92ZUNsYXNzKFxcXCJmci1oaWRkZW5cXFwiKX19fX1mdW5jdGlvbiB0KGEsYyl7Yi5ldmVudHMub24oXFxcIm1vdXNldXBcXFwiLGEuX2VkaXRvck1vdXNldXAsITApLGIuJHdwJiZiLmV2ZW50cy5vbihcXFwia2V5ZG93blxcXCIsYS5fZWRpdG9yS2V5ZG93biksYi5ldmVudHMub24oXFxcImJsdXJcXFwiLGZ1bmN0aW9uKCl7ZygpJiZiLm1hcmtlcnMucmVtb3ZlKCksbSgpfSksYi4kd3AmJiFiLmhlbHBlcnMuaXNNb2JpbGUoKSYmYi5ldmVudHMuJG9uKGIuJHdwLFxcXCJzY3JvbGwucG9wdXBcXFwiK2MsYS5fcmVwb3NpdGlvblBvcHVwKSxiLmV2ZW50cy5vbihcXFwid2luZG93Lm1vdXNldXBcXFwiLGEuX3dpbmRvd01vdXNldXAsITApLGIuZXZlbnRzLm9uKFxcXCJ3aW5kb3cua2V5ZG93blxcXCIsYS5fd2luZG93S2V5ZG93biwhMCkseFtjXS5kYXRhKFxcXCJpbnN0XFxcIitiLmlkLCEwKSxiLmV2ZW50cy5vbihcXFwiZGVzdHJveVxcXCIsZnVuY3Rpb24oKXtiLmNvcmUuc2FtZUluc3RhbmNlKHhbY10pJiZ4W2NdLnJlbW92ZUNsYXNzKFxcXCJmci1hY3RpdmVcXFwiKS5hcHBlbmRUbyhcXFwiYm9keVxcXCIpfSwhMCl9ZnVuY3Rpb24gdShjLGQpe3ZhciBlPXIoYyxkKSxmPXMoYyk7cmV0dXJuIHQoZixjKSxiLmV2ZW50cy4kb24oZSxcXFwibW91c2Vkb3duIG1vdXNldXAgdG91Y2hzdGFydCB0b3VjaGVuZCB0b3VjaFxcXCIsXFxcIipcXFwiLGYuX3ByZXZlbnRGb2N1cywhMCksYi5ldmVudHMuJG9uKGUsXFxcImZvY3VzXFxcIixcXFwiaW5wdXQsIHRleHRhcmVhLCBidXR0b24sIHNlbGVjdFxcXCIsZi5faW5wdXRGb2N1cywhMCksYi5ldmVudHMuJG9uKGUsXFxcImJsdXJcXFwiLFxcXCJpbnB1dCwgdGV4dGFyZWEsIGJ1dHRvbiwgc2VsZWN0XFxcIixmLl9pbnB1dEJsdXIsITApLGIuYWNjZXNzaWJpbGl0eS5yZWdpc3RlclBvcHVwKGMpLGIuZXZlbnRzLiRvbihlLFxcXCJrZXlkb3duIGtleXVwIGNoYW5nZSBpbnB1dFxcXCIsXFxcImlucHV0LCB0ZXh0YXJlYVxcXCIsZi5fZG9QbGFjZWhvbGRlciwhMCksYi5oZWxwZXJzLmlzSU9TKCkmJmIuZXZlbnRzLiRvbihlLFxcXCJ0b3VjaGVuZFxcXCIsXFxcImxhYmVsXFxcIixmdW5jdGlvbigpe2EoXFxcIiNcXFwiK2EodGhpcykuYXR0cihcXFwiZm9yXFxcIikpLnByb3AoXFxcImNoZWNrZWRcXFwiLGZ1bmN0aW9uKGEsYil7cmV0dXJuIWJ9KX0sITApLGIuZXZlbnRzLiRvbihhKGIub193aW4pLFxcXCJyZXNpemVcXFwiLGYuX3dpbmRvd1Jlc2l6ZSwhMCksZX1mdW5jdGlvbiB2KCl7Zm9yKHZhciBhIGluIHgpaWYoeC5oYXNPd25Qcm9wZXJ0eShhKSl7dmFyIGI9eFthXTtiLmh0bWwoXFxcIlxcXCIpLnJlbW92ZURhdGEoKS5yZW1vdmUoKSx4W2FdPW51bGx9eD1bXX1mdW5jdGlvbiB3KCl7Yi5ldmVudHMub24oXFxcInNoYXJlZC5kZXN0cm95XFxcIix2LCEwKSxiLmV2ZW50cy5vbihcXFwid2luZG93Lm1vdXNlZG93blxcXCIsbiksYi5ldmVudHMub24oXFxcIndpbmRvdy50b3VjaG1vdmVcXFwiLG8pLGIuZXZlbnRzLm9uKFxcXCJtb3VzZWRvd25cXFwiLGZ1bmN0aW9uKGEpe2coKSYmKGEuc3RvcFByb3BhZ2F0aW9uKCksYi4kZWwuZmluZChcXFwiLmZyLW1hcmtlclxcXCIpLnJlbW92ZSgpLG4oKSxiLmV2ZW50cy5kaXNhYmxlQmx1cigpKX0pfWIuc2hhcmVkLnBvcHVwc3x8KGIuc2hhcmVkLnBvcHVwcz17fSk7dmFyIHg9Yi5zaGFyZWQucG9wdXBzO3JldHVybiBiLnNoYXJlZC5leGl0X2ZsYWc9ITEse19pbml0OncsY3JlYXRlOnUsZ2V0Omosc2hvdzpkLGhpZGU6aCxvbkhpZGU6aSxoaWRlQWxsOm0sc2V0Q29udGFpbmVyOmMscmVmcmVzaDpsLG9uUmVmcmVzaDprLG9uU2hvdzplLGlzVmlzaWJsZTpmLGFyZVZpc2libGU6Z319LGEuRkUuTU9EVUxFUy5wb3NpdGlvbj1mdW5jdGlvbihiKXtmdW5jdGlvbiBjKCl7dmFyIGE9Yi5zZWxlY3Rpb24ucmFuZ2VzKDApLGM9YS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtpZigwPT09Yy50b3AmJjA9PT1jLmxlZnQmJjA9PT1jLndpZHRofHwwPT09Yy5oZWlnaHQpe3ZhciBkPSExOzA9PT1iLiRlbC5maW5kKFxcXCIuZnItbWFya2VyXFxcIikubGVuZ3RoJiYoYi5zZWxlY3Rpb24uc2F2ZSgpLGQ9ITApO3ZhciBlPWIuJGVsLmZpbmQoXFxcIi5mci1tYXJrZXI6Zmlyc3RcXFwiKTtlLmNzcyhcXFwiZGlzcGxheVxcXCIsXFxcImlubGluZVxcXCIpLGUuY3NzKFxcXCJsaW5lLWhlaWdodFxcXCIsXFxcIlxcXCIpO3ZhciBmPWUub2Zmc2V0KCksZz1lLm91dGVySGVpZ2h0KCk7ZS5jc3MoXFxcImRpc3BsYXlcXFwiLFxcXCJub25lXFxcIiksZS5jc3MoXFxcImxpbmUtaGVpZ2h0XFxcIiwwKSxjPXt9LGMubGVmdD1mLmxlZnQsYy53aWR0aD0wLGMuaGVpZ2h0PWcsYy50b3A9Zi50b3AtKGIuaGVscGVycy5pc01vYmlsZSgpPzA6Yi5oZWxwZXJzLnNjcm9sbFRvcCgpKSxjLnJpZ2h0PTEsYy5ib3R0b209MSxjLm9rPSEwLGQmJmIuc2VsZWN0aW9uLnJlc3RvcmUoKX1yZXR1cm4gY31mdW5jdGlvbiBkKGEsYyxkKXt2YXIgZT1hLmdldCgwKS5vZmZzZXRIZWlnaHQ7aWYoIWIuaGVscGVycy5pc01vYmlsZSgpJiZiLiR0YiYmYS5wYXJlbnQoKS5nZXQoMCkhPWIuJHRiLmdldCgwKSl7dmFyIGY9YS5wYXJlbnQoKS5vZmZzZXQoKS50b3AsZz1jLWUtKGR8fDApO2EucGFyZW50KCkuZ2V0KDApPT1iLiRzYy5nZXQoMCkmJihmLT1hLnBhcmVudCgpLnBvc2l0aW9uKCkudG9wKTt2YXIgaD1iLiRzYy5nZXQoMCkuc2Nyb2xsSGVpZ2h0O2YrYytlPmIuJHNjLm9mZnNldCgpLnRvcCtoJiZhLnBhcmVudCgpLm9mZnNldCgpLnRvcCtnPjA/KGM9ZyxhLmFkZENsYXNzKFxcXCJmci1hYm92ZVxcXCIpKTphLnJlbW92ZUNsYXNzKFxcXCJmci1hYm92ZVxcXCIpfXJldHVybiBjfWZ1bmN0aW9uIGUoYSxjKXt2YXIgZD1hLmdldCgwKS5vZmZzZXRXaWR0aDtyZXR1cm4gYytkPmIuJHNjLmdldCgwKS5jbGllbnRXaWR0aC0xMCYmKGM9Yi4kc2MuZ2V0KDApLmNsaWVudFdpZHRoLWQtMTApLGM8MCYmKGM9MTApLGN9ZnVuY3Rpb24gZihhKXt2YXIgZD1jKCk7YS5jc3Moe3RvcDowLGxlZnQ6MH0pO3ZhciBlPWQudG9wK2QuaGVpZ2h0LGY9ZC5sZWZ0K2Qud2lkdGgvMi1hLmdldCgwKS5vZmZzZXRXaWR0aC8yK2IuaGVscGVycy5zY3JvbGxMZWZ0KCk7Yi5vcHRzLmlmcmFtZXx8KGUrPWIuaGVscGVycy5zY3JvbGxUb3AoKSksZyhmLGUsYSxkLmhlaWdodCl9ZnVuY3Rpb24gZyhhLGMsZixnKXt2YXIgaD1mLmRhdGEoXFxcImNvbnRhaW5lclxcXCIpOyFofHxcXFwiQk9EWVxcXCI9PT1oLmdldCgwKS50YWdOYW1lJiZcXFwic3RhdGljXFxcIj09aC5jc3MoXFxcInBvc2l0aW9uXFxcIil8fChhJiYoYS09aC5vZmZzZXQoKS5sZWZ0KSxjJiYoYy09aC5vZmZzZXQoKS50b3ApLFxcXCJCT0RZXFxcIiE9aC5nZXQoMCkudGFnTmFtZT8oYSYmKGErPWguZ2V0KDApLnNjcm9sbExlZnQpLGMmJihjKz1oLmdldCgwKS5zY3JvbGxUb3ApKTpcXFwiYWJzb2x1dGVcXFwiPT1oLmNzcyhcXFwicG9zaXRpb25cXFwiKSYmKGEmJihhKz1oLnBvc2l0aW9uKCkubGVmdCksYyYmKGMrPWgucG9zaXRpb24oKS50b3ApKSksYi5vcHRzLmlmcmFtZSYmaCYmYi4kdGImJmguZ2V0KDApIT1iLiR0Yi5nZXQoMCkmJihhJiYoYSs9Yi4kaWZyYW1lLm9mZnNldCgpLmxlZnQpLGMmJihjKz1iLiRpZnJhbWUub2Zmc2V0KCkudG9wKSk7dmFyIGk9ZShmLGEpO2lmKGEpe2YuY3NzKFxcXCJsZWZ0XFxcIixpKTt2YXIgaj1mLmRhdGEoXFxcImZyLWFycm93XFxcIik7anx8KGo9Zi5maW5kKFxcXCIuZnItYXJyb3dcXFwiKSxmLmRhdGEoXFxcImZyLWFycm93XFxcIixqKSksai5kYXRhKFxcXCJtYXJnaW4tbGVmdFxcXCIpfHxqLmRhdGEoXFxcIm1hcmdpbi1sZWZ0XFxcIixiLmhlbHBlcnMuZ2V0UFgoai5jc3MoXFxcIm1hcmdpbi1sZWZ0XFxcIikpKSxqLmNzcyhcXFwibWFyZ2luLWxlZnRcXFwiLGEtaStqLmRhdGEoXFxcIm1hcmdpbi1sZWZ0XFxcIikpfWMmJmYuY3NzKFxcXCJ0b3BcXFwiLGQoZixjLGcpKX1mdW5jdGlvbiBoKGMpe3ZhciBkPWEoYyksZT1kLmlzKFxcXCIuZnItc3RpY2t5LW9uXFxcIiksZj1kLmRhdGEoXFxcInN0aWNreS10b3BcXFwiKSxnPWQuZGF0YShcXFwic3RpY2t5LXNjaGVkdWxlZFxcXCIpO2lmKFxcXCJ1bmRlZmluZWRcXFwiPT10eXBlb2YgZil7ZC5kYXRhKFxcXCJzdGlja3ktdG9wXFxcIiwwKTt2YXIgaD1hKCc8ZGl2IGNsYXNzPVxcXCJmci1zdGlja3ktZHVtbXlcXFwiIHN0eWxlPVxcXCJoZWlnaHQ6ICcrZC5vdXRlckhlaWdodCgpKydweDtcXFwiPjwvZGl2PicpO2IuJGJveC5wcmVwZW5kKGgpfWVsc2UgYi4kYm94LmZpbmQoXFxcIi5mci1zdGlja3ktZHVtbXlcXFwiKS5jc3MoXFxcImhlaWdodFxcXCIsZC5vdXRlckhlaWdodCgpKTtpZihiLmNvcmUuaGFzRm9jdXMoKXx8Yi4kdGIuZmluZChcXFwiaW5wdXQ6dmlzaWJsZTpmb2N1c1xcXCIpLmxlbmd0aD4wKXt2YXIgaT1iLmhlbHBlcnMuc2Nyb2xsVG9wKCksaj1NYXRoLm1pbihNYXRoLm1heChpLWIuJHRiLnBhcmVudCgpLm9mZnNldCgpLnRvcCwwKSxiLiR0Yi5wYXJlbnQoKS5vdXRlckhlaWdodCgpLWQub3V0ZXJIZWlnaHQoKSk7aiE9ZiYmaiE9ZyYmKGNsZWFyVGltZW91dChkLmRhdGEoXFxcInN0aWNreS10aW1lb3V0XFxcIikpLGQuZGF0YShcXFwic3RpY2t5LXNjaGVkdWxlZFxcXCIsaiksZC5vdXRlckhlaWdodCgpPGktYi4kdGIucGFyZW50KCkub2Zmc2V0KCkudG9wJiZkLmFkZENsYXNzKFxcXCJmci1vcGFjaXR5LTBcXFwiKSxkLmRhdGEoXFxcInN0aWNreS10aW1lb3V0XFxcIixzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7dmFyIGE9Yi5oZWxwZXJzLnNjcm9sbFRvcCgpLGM9TWF0aC5taW4oTWF0aC5tYXgoYS1iLiR0Yi5wYXJlbnQoKS5vZmZzZXQoKS50b3AsMCksYi4kdGIucGFyZW50KCkub3V0ZXJIZWlnaHQoKS1kLm91dGVySGVpZ2h0KCkpO2M+MCYmXFxcIkJPRFlcXFwiPT1iLiR0Yi5wYXJlbnQoKS5nZXQoMCkudGFnTmFtZSYmKGMrPWIuJHRiLnBhcmVudCgpLnBvc2l0aW9uKCkudG9wKSxjIT1mJiYoZC5jc3MoXFxcInRvcFxcXCIsTWF0aC5tYXgoYywwKSksZC5kYXRhKFxcXCJzdGlja3ktdG9wXFxcIixjKSxkLmRhdGEoXFxcInN0aWNreS1zY2hlZHVsZWRcXFwiLGMpKSxkLnJlbW92ZUNsYXNzKFxcXCJmci1vcGFjaXR5LTBcXFwiKX0sMTAwKSkpLGV8fChkLmNzcyhcXFwidG9wXFxcIixcXFwiMFxcXCIpLGQud2lkdGgoYi4kdGIucGFyZW50KCkud2lkdGgoKSksZC5hZGRDbGFzcyhcXFwiZnItc3RpY2t5LW9uXFxcIiksYi4kYm94LmFkZENsYXNzKFxcXCJmci1zdGlja3ktYm94XFxcIikpfWVsc2UgY2xlYXJUaW1lb3V0KGEoYykuY3NzKFxcXCJzdGlja3ktdGltZW91dFxcXCIpKSxkLmNzcyhcXFwidG9wXFxcIixcXFwiMFxcXCIpLGQuY3NzKFxcXCJwb3NpdGlvblxcXCIsXFxcIlxcXCIpLGQud2lkdGgoXFxcIlxcXCIpLGQuZGF0YShcXFwic3RpY2t5LXRvcFxcXCIsMCksZC5yZW1vdmVDbGFzcyhcXFwiZnItc3RpY2t5LW9uXFxcIiksYi4kYm94LnJlbW92ZUNsYXNzKFxcXCJmci1zdGlja3ktYm94XFxcIil9ZnVuY3Rpb24gaShjKXtpZihjLm9mZnNldFdpZHRoKXt2YXIgZCxlLGY9YShjKSxnPWYub3V0ZXJIZWlnaHQoKSxoPWYuZGF0YShcXFwic3RpY2t5LXBvc2l0aW9uXFxcIiksaT1hKFxcXCJib2R5XFxcIj09Yi5vcHRzLnNjcm9sbGFibGVDb250YWluZXI/Yi5vX3dpbjpiLm9wdHMuc2Nyb2xsYWJsZUNvbnRhaW5lcikub3V0ZXJIZWlnaHQoKSxqPTAsaz0wO1xcXCJib2R5XFxcIiE9PWIub3B0cy5zY3JvbGxhYmxlQ29udGFpbmVyJiYoaj1iLiRzYy5vZmZzZXQoKS50b3Asaz1hKGIub193aW4pLm91dGVySGVpZ2h0KCktai1pKTt2YXIgbD1cXFwiYm9keVxcXCI9PWIub3B0cy5zY3JvbGxhYmxlQ29udGFpbmVyP2IuaGVscGVycy5zY3JvbGxUb3AoKTpqLG09Zi5pcyhcXFwiLmZyLXN0aWNreS1vblxcXCIpO2YuZGF0YShcXFwic3RpY2t5LXBhcmVudFxcXCIpfHxmLmRhdGEoXFxcInN0aWNreS1wYXJlbnRcXFwiLGYucGFyZW50KCkpO3ZhciBuPWYuZGF0YShcXFwic3RpY2t5LXBhcmVudFxcXCIpLG89bi5vZmZzZXQoKS50b3AscD1uLm91dGVySGVpZ2h0KCk7aWYoZi5kYXRhKFxcXCJzdGlja3ktb2Zmc2V0XFxcIil8fChmLmRhdGEoXFxcInN0aWNreS1vZmZzZXRcXFwiLCEwKSxmLmFmdGVyKCc8ZGl2IGNsYXNzPVxcXCJmci1zdGlja3ktZHVtbXlcXFwiIHN0eWxlPVxcXCJoZWlnaHQ6ICcrZysncHg7XFxcIj48L2Rpdj4nKSksIWgpe3ZhciBxPVxcXCJhdXRvXFxcIiE9PWYuY3NzKFxcXCJ0b3BcXFwiKXx8XFxcImF1dG9cXFwiIT09Zi5jc3MoXFxcImJvdHRvbVxcXCIpO3F8fGYuY3NzKFxcXCJwb3NpdGlvblxcXCIsXFxcImZpeGVkXFxcIiksaD17dG9wOmIubm9kZS5oYXNDbGFzcyhmLmdldCgwKSxcXFwiZnItdG9wXFxcIiksYm90dG9tOmIubm9kZS5oYXNDbGFzcyhmLmdldCgwKSxcXFwiZnItYm90dG9tXFxcIil9LHF8fGYuY3NzKFxcXCJwb3NpdGlvblxcXCIsXFxcIlxcXCIpLGYuZGF0YShcXFwic3RpY2t5LXBvc2l0aW9uXFxcIixoKSxmLmRhdGEoXFxcInRvcFxcXCIsYi5ub2RlLmhhc0NsYXNzKGYuZ2V0KDApLFxcXCJmci10b3BcXFwiKT9mLmNzcyhcXFwidG9wXFxcIik6XFxcImF1dG9cXFwiKSxmLmRhdGEoXFxcImJvdHRvbVxcXCIsYi5ub2RlLmhhc0NsYXNzKGYuZ2V0KDApLFxcXCJmci1ib3R0b21cXFwiKT9mLmNzcyhcXFwiYm90dG9tXFxcIik6XFxcImF1dG9cXFwiKX12YXIgcj1mdW5jdGlvbigpe3JldHVybiBvPGwrZCYmbytwLWc+PWwrZH0scz1mdW5jdGlvbigpe3JldHVybiBvK2c8bCtpLWUmJm8rcD5sK2ktZX07ZD1iLmhlbHBlcnMuZ2V0UFgoZi5kYXRhKFxcXCJ0b3BcXFwiKSksZT1iLmhlbHBlcnMuZ2V0UFgoZi5kYXRhKFxcXCJib3R0b21cXFwiKSk7dmFyIHQ9aC50b3AmJnIoKSx1PWguYm90dG9tJiZzKCk7dHx8dT8oZi5jc3MoXFxcIndpZHRoXFxcIixuLndpZHRoKCkrXFxcInB4XFxcIiksbXx8KGYuYWRkQ2xhc3MoXFxcImZyLXN0aWNreS1vblxcXCIpLGYucmVtb3ZlQ2xhc3MoXFxcImZyLXN0aWNreS1vZmZcXFwiKSxmLmNzcyhcXFwidG9wXFxcIikmJihcXFwiYXV0b1xcXCIhPWYuZGF0YShcXFwidG9wXFxcIik/Zi5jc3MoXFxcInRvcFxcXCIsYi5oZWxwZXJzLmdldFBYKGYuZGF0YShcXFwidG9wXFxcIikpK2opOmYuZGF0YShcXFwidG9wXFxcIixcXFwiYXV0b1xcXCIpKSxmLmNzcyhcXFwiYm90dG9tXFxcIikmJihcXFwiYXV0b1xcXCIhPWYuZGF0YShcXFwiYm90dG9tXFxcIik/Zi5jc3MoXFxcImJvdHRvbVxcXCIsYi5oZWxwZXJzLmdldFBYKGYuZGF0YShcXFwiYm90dG9tXFxcIikpK2spOmYuY3NzKFxcXCJib3R0b21cXFwiLFxcXCJhdXRvXFxcIikpKSk6Yi5ub2RlLmhhc0NsYXNzKGYuZ2V0KDApLFxcXCJmci1zdGlja3ktb2ZmXFxcIil8fChmLndpZHRoKFxcXCJcXFwiKSxmLnJlbW92ZUNsYXNzKFxcXCJmci1zdGlja3ktb25cXFwiKSxmLmFkZENsYXNzKFxcXCJmci1zdGlja3ktb2ZmXFxcIiksZi5jc3MoXFxcInRvcFxcXCIpJiZcXFwiYXV0b1xcXCIhPWYuZGF0YShcXFwidG9wXFxcIikmJmgudG9wJiZmLmNzcyhcXFwidG9wXFxcIiwwKSxmLmNzcyhcXFwiYm90dG9tXFxcIikmJlxcXCJhdXRvXFxcIiE9Zi5kYXRhKFxcXCJib3R0b21cXFwiKSYmaC5ib3R0b20mJmYuY3NzKFxcXCJib3R0b21cXFwiLDApKX19ZnVuY3Rpb24gaigpe3ZhciBhPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXFxcInRlc3RcXFwiKSxjPWEuc3R5bGU7cmV0dXJuIGMuY3NzVGV4dD1cXFwicG9zaXRpb246XFxcIitbXFxcIi13ZWJraXQtXFxcIixcXFwiLW1vei1cXFwiLFxcXCItbXMtXFxcIixcXFwiLW8tXFxcIixcXFwiXFxcIl0uam9pbihcXFwic3RpY2t5OyBwb3NpdGlvbjpcXFwiKStcXFwiIHN0aWNreTtcXFwiLGMucG9zaXRpb24uaW5kZXhPZihcXFwic3RpY2t5XFxcIikhPT0tMSYmIWIuaGVscGVycy5pc0lPUygpJiYhYi5oZWxwZXJzLmlzQW5kcm9pZCgpJiYhYi5icm93c2VyLmNocm9tZX1mdW5jdGlvbiBrKCl7aWYoIWooKSlpZihiLl9zdGlja3lFbGVtZW50cz1bXSxiLmhlbHBlcnMuaXNJT1MoKSl7dmFyIGM9ZnVuY3Rpb24oKXtiLmhlbHBlcnMucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCkoYyk7Zm9yKHZhciBhPTA7YTxiLl9zdGlja3lFbGVtZW50cy5sZW5ndGg7YSsrKWgoYi5fc3RpY2t5RWxlbWVudHNbYV0pfTtjKCksYi5ldmVudHMuJG9uKGEoYi5vX3dpbiksXFxcInNjcm9sbFxcXCIsZnVuY3Rpb24oKXtpZihiLmNvcmUuaGFzRm9jdXMoKSlmb3IodmFyIGM9MDtjPGIuX3N0aWNreUVsZW1lbnRzLmxlbmd0aDtjKyspe3ZhciBkPWEoYi5fc3RpY2t5RWxlbWVudHNbY10pLGU9ZC5wYXJlbnQoKSxmPWIuaGVscGVycy5zY3JvbGxUb3AoKTtkLm91dGVySGVpZ2h0KCk8Zi1lLm9mZnNldCgpLnRvcCYmKGQuYWRkQ2xhc3MoXFxcImZyLW9wYWNpdHktMFxcXCIpLGQuZGF0YShcXFwic3RpY2t5LXRvcFxcXCIsLTEpLGQuZGF0YShcXFwic3RpY2t5LXNjaGVkdWxlZFxcXCIsLTEpKX19LCEwKX1lbHNlIGIuZXZlbnRzLiRvbihhKFxcXCJib2R5XFxcIj09Yi5vcHRzLnNjcm9sbGFibGVDb250YWluZXI/Yi5vX3dpbjpiLm9wdHMuc2Nyb2xsYWJsZUNvbnRhaW5lciksXFxcInNjcm9sbFxcXCIsbCwhMCksYi5ldmVudHMuJG9uKGEoYi5vX3dpbiksXFxcInJlc2l6ZVxcXCIsbCwhMCksYi5ldmVudHMub24oXFxcImluaXRpYWxpemVkXFxcIixsKSxiLmV2ZW50cy5vbihcXFwiZm9jdXNcXFwiLGwpLGIuZXZlbnRzLiRvbihhKGIub193aW4pLFxcXCJyZXNpemVcXFwiLFxcXCJ0ZXh0YXJlYVxcXCIsbCwhMCk7Yi5ldmVudHMub24oXFxcImRlc3Ryb3lcXFwiLGZ1bmN0aW9uKCl7Yi5fc3RpY2t5RWxlbWVudHM9W119KX1mdW5jdGlvbiBsKCl7aWYoYi5fc3RpY2t5RWxlbWVudHMpZm9yKHZhciBhPTA7YTxiLl9zdGlja3lFbGVtZW50cy5sZW5ndGg7YSsrKWkoYi5fc3RpY2t5RWxlbWVudHNbYV0pfWZ1bmN0aW9uIG0oYSl7YS5hZGRDbGFzcyhcXFwiZnItc3RpY2t5XFxcIiksYi5oZWxwZXJzLmlzSU9TKCkmJmEuYWRkQ2xhc3MoXFxcImZyLXN0aWNreS1pb3NcXFwiKSxqKCl8fChhLnJlbW92ZUNsYXNzKFxcXCJmci1zdGlja3lcXFwiKSxiLl9zdGlja3lFbGVtZW50cy5wdXNoKGEuZ2V0KDApKSl9ZnVuY3Rpb24gbigpe2soKX1yZXR1cm57X2luaXQ6bixmb3JTZWxlY3Rpb246ZixhZGRTdGlja3k6bSxyZWZyZXNoOmwsYXQ6ZyxnZXRCb3VuZGluZ1JlY3Q6Y319LGEuRkUuTU9EVUxFUy5yZWZyZXNoPWZ1bmN0aW9uKGIpe2Z1bmN0aW9uIGMoYSl7ZyhhLCFiLnVuZG8uY2FuRG8oKSl9ZnVuY3Rpb24gZChhKXtnKGEsIWIudW5kby5jYW5SZWRvKCkpfWZ1bmN0aW9uIGUoYSl7aWYoYi5ub2RlLmhhc0NsYXNzKGEuZ2V0KDApLFxcXCJmci1uby1yZWZyZXNoXFxcIikpcmV0dXJuITE7Zm9yKHZhciBjPWIuc2VsZWN0aW9uLmJsb2NrcygpLGQ9MDtkPGMubGVuZ3RoO2QrKyl7Zm9yKHZhciBlPWNbZF0ucHJldmlvdXNTaWJsaW5nO2UmJmUubm9kZVR5cGU9PU5vZGUuVEVYVF9OT0RFJiYwPT09ZS50ZXh0Q29udGVudC5sZW5ndGg7KWU9ZS5wcmV2aW91c1NpYmxpbmc7aWYoXFxcIkxJXFxcIiE9Y1tkXS50YWdOYW1lfHxlKXJldHVybiBnKGEsITEpLCEwO2coYSwhMCl9fWZ1bmN0aW9uIGYoYyl7aWYoYi5ub2RlLmhhc0NsYXNzKGMuZ2V0KDApLFxcXCJmci1uby1yZWZyZXNoXFxcIikpcmV0dXJuITE7Zm9yKHZhciBkPWIuc2VsZWN0aW9uLmJsb2NrcygpLGU9MDtlPGQubGVuZ3RoO2UrKyl7dmFyIGY9XFxcInJ0bFxcXCI9PWIub3B0cy5kaXJlY3Rpb258fFxcXCJydGxcXFwiPT1hKGRbZV0pLmNzcyhcXFwiZGlyZWN0aW9uXFxcIik/XFxcIm1hcmdpbi1yaWdodFxcXCI6XFxcIm1hcmdpbi1sZWZ0XFxcIjtpZihcXFwiTElcXFwiPT1kW2VdLnRhZ05hbWV8fFxcXCJMSVxcXCI9PWRbZV0ucGFyZW50Tm9kZS50YWdOYW1lKXJldHVybiBnKGMsITEpLCEwO2lmKGIuaGVscGVycy5nZXRQWChhKGRbZV0pLmNzcyhmKSk+MClyZXR1cm4gZyhjLCExKSwhMH1nKGMsITApfWZ1bmN0aW9uIGcoYSxiKXthLnRvZ2dsZUNsYXNzKFxcXCJmci1kaXNhYmxlZFxcXCIsYikuYXR0cihcXFwiYXJpYS1kaXNhYmxlZFxcXCIsYil9cmV0dXJue3VuZG86YyxyZWRvOmQsb3V0ZGVudDpmLGluZGVudDplfX0sYS5leHRlbmQoYS5GRS5ERUZBVUxUUyx7ZWRpdEluUG9wdXA6ITF9KSxhLkZFLk1PRFVMRVMudGV4dEVkaXQ9ZnVuY3Rpb24oYil7ZnVuY3Rpb24gYygpe3ZhciBhPSc8ZGl2IGlkPVxcXCJmci10ZXh0LWVkaXQtJytiLmlkKydcXFwiIGNsYXNzPVxcXCJmci1sYXllciBmci10ZXh0LWVkaXQtbGF5ZXJcXFwiPjxkaXYgY2xhc3M9XFxcImZyLWlucHV0LWxpbmVcXFwiPjxpbnB1dCB0eXBlPVxcXCJ0ZXh0XFxcIiBwbGFjZWhvbGRlcj1cXFwiJytiLmxhbmd1YWdlLnRyYW5zbGF0ZShcXFwiVGV4dFxcXCIpKydcXFwiIHRhYkluZGV4PVxcXCIxXFxcIj48L2Rpdj48ZGl2IGNsYXNzPVxcXCJmci1hY3Rpb24tYnV0dG9uc1xcXCI+PGJ1dHRvbiB0eXBlPVxcXCJidXR0b25cXFwiIGNsYXNzPVxcXCJmci1jb21tYW5kIGZyLXN1Ym1pdFxcXCIgZGF0YS1jbWQ9XFxcInVwZGF0ZVRleHRcXFwiIHRhYkluZGV4PVxcXCIyXFxcIj4nK2IubGFuZ3VhZ2UudHJhbnNsYXRlKFxcXCJVcGRhdGVcXFwiKStcXFwiPC9idXR0b24+PC9kaXY+PC9kaXY+XFxcIixjPXtlZGl0OmF9O2IucG9wdXBzLmNyZWF0ZShcXFwidGV4dC5lZGl0XFxcIixjKX1mdW5jdGlvbiBkKCl7dmFyIGMsZD1iLnBvcHVwcy5nZXQoXFxcInRleHQuZWRpdFxcXCIpO2M9XFxcIklOUFVUXFxcIj09PWIuJGVsLnByb3AoXFxcInRhZ05hbWVcXFwiKT9iLiRlbC5hdHRyKFxcXCJwbGFjZWhvbGRlclxcXCIpOmIuJGVsLnRleHQoKSxkLmZpbmQoXFxcImlucHV0XFxcIikudmFsKGMpLnRyaWdnZXIoXFxcImNoYW5nZVxcXCIpLGIucG9wdXBzLnNldENvbnRhaW5lcihcXFwidGV4dC5lZGl0XFxcIixhKFxcXCJib2R5XFxcIikpLGIucG9wdXBzLnNob3coXFxcInRleHQuZWRpdFxcXCIsYi4kZWwub2Zmc2V0KCkubGVmdCtiLiRlbC5vdXRlcldpZHRoKCkvMixiLiRlbC5vZmZzZXQoKS50b3ArYi4kZWwub3V0ZXJIZWlnaHQoKSxiLiRlbC5vdXRlckhlaWdodCgpKX1mdW5jdGlvbiBlKCl7Yi5ldmVudHMuJG9uKGIuJGVsLGIuX21vdXNldXAsZnVuY3Rpb24oKXtzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7ZCgpfSwxMCl9KX1mdW5jdGlvbiBmKCl7dmFyIGE9Yi5wb3B1cHMuZ2V0KFxcXCJ0ZXh0LmVkaXRcXFwiKSxjPWEuZmluZChcXFwiaW5wdXRcXFwiKS52YWwoKTswPT09Yy5sZW5ndGgmJihjPWIub3B0cy5wbGFjZWhvbGRlclRleHQpLFxcXCJJTlBVVFxcXCI9PT1iLiRlbC5wcm9wKFxcXCJ0YWdOYW1lXFxcIik/Yi4kZWwuYXR0cihcXFwicGxhY2Vob2xkZXJcXFwiLGMpOmIuJGVsLnRleHQoYyksYi5ldmVudHMudHJpZ2dlcihcXFwiY29udGVudENoYW5nZWRcXFwiKSxiLnBvcHVwcy5oaWRlKFxcXCJ0ZXh0LmVkaXRcXFwiKX1mdW5jdGlvbiBnKCl7Yi5vcHRzLmVkaXRJblBvcHVwJiYoYygpLGUoKSl9cmV0dXJue19pbml0OmcsdXBkYXRlOmZ9fSxhLkZFLlJlZ2lzdGVyQ29tbWFuZChcXFwidXBkYXRlVGV4dFxcXCIse2ZvY3VzOiExLHVuZG86ITEsY2FsbGJhY2s6ZnVuY3Rpb24oKXt0aGlzLnRleHRFZGl0LnVwZGF0ZSgpfX0pLGEuZXh0ZW5kKGEuRkUuREVGQVVMVFMse3Rvb2xiYXJCb3R0b206ITEsdG9vbGJhckJ1dHRvbnM6W1xcXCJmdWxsc2NyZWVuXFxcIixcXFwicHJpbnRcXFwiLFxcXCJib2xkXFxcIixcXFwiaXRhbGljXFxcIixcXFwidW5kZXJsaW5lXFxcIixcXFwic3RyaWtlVGhyb3VnaFxcXCIsXFxcInN1YnNjcmlwdFxcXCIsXFxcInN1cGVyc2NyaXB0XFxcIixcXFwiZm9udEZhbWlseVxcXCIsXFxcImZvbnRTaXplXFxcIixcXFwifFxcXCIsXFxcInNwZWNpYWxDaGFyYWN0ZXJzXFxcIixcXFwiY29sb3JcXFwiLFxcXCJlbW90aWNvbnNcXFwiLFxcXCJpbmxpbmVTdHlsZVxcXCIsXFxcInBhcmFncmFwaFN0eWxlXFxcIixcXFwifFxcXCIsXFxcInBhcmFncmFwaEZvcm1hdFxcXCIsXFxcImFsaWduXFxcIixcXFwiZm9ybWF0T0xcXFwiLFxcXCJmb3JtYXRVTFxcXCIsXFxcIm91dGRlbnRcXFwiLFxcXCJpbmRlbnRcXFwiLFxcXCJxdW90ZVxcXCIsXFxcImluc2VydEhSXFxcIixcXFwiLVxcXCIsXFxcImluc2VydExpbmtcXFwiLFxcXCJpbnNlcnRJbWFnZVxcXCIsXFxcImluc2VydFZpZGVvXFxcIixcXFwiaW5zZXJ0RmlsZVxcXCIsXFxcImluc2VydFRhYmxlXFxcIixcXFwidW5kb1xcXCIsXFxcInJlZG9cXFwiLFxcXCJjbGVhckZvcm1hdHRpbmdcXFwiLFxcXCJzZWxlY3RBbGxcXFwiLFxcXCJodG1sXFxcIixcXFwiYXBwbHlGb3JtYXRcXFwiLFxcXCJyZW1vdmVGb3JtYXRcXFwiLFxcXCJoZWxwXFxcIl0sdG9vbGJhckJ1dHRvbnNYUzpbXFxcImJvbGRcXFwiLFxcXCJpdGFsaWNcXFwiLFxcXCJmb250RmFtaWx5XFxcIixcXFwiZm9udFNpemVcXFwiLFxcXCJ8XFxcIixcXFwidW5kb1xcXCIsXFxcInJlZG9cXFwiXSx0b29sYmFyQnV0dG9uc1NNOltcXFwiYm9sZFxcXCIsXFxcIml0YWxpY1xcXCIsXFxcInVuZGVybGluZVxcXCIsXFxcInxcXFwiLFxcXCJmb250RmFtaWx5XFxcIixcXFwiZm9udFNpemVcXFwiLFxcXCJpbnNlcnRMaW5rXFxcIixcXFwiaW5zZXJ0SW1hZ2VcXFwiLFxcXCJ0YWJsZVxcXCIsXFxcInxcXFwiLFxcXCJ1bmRvXFxcIixcXFwicmVkb1xcXCJdLHRvb2xiYXJCdXR0b25zTUQ6W1xcXCJmdWxsc2NyZWVuXFxcIixcXFwiYm9sZFxcXCIsXFxcIml0YWxpY1xcXCIsXFxcInVuZGVybGluZVxcXCIsXFxcImZvbnRGYW1pbHlcXFwiLFxcXCJmb250U2l6ZVxcXCIsXFxcImNvbG9yXFxcIixcXFwicGFyYWdyYXBoU3R5bGVcXFwiLFxcXCJwYXJhZ3JhcGhGb3JtYXRcXFwiLFxcXCJhbGlnblxcXCIsXFxcImZvcm1hdE9MXFxcIixcXFwiZm9ybWF0VUxcXFwiLFxcXCJvdXRkZW50XFxcIixcXFwiaW5kZW50XFxcIixcXFwicXVvdGVcXFwiLFxcXCJpbnNlcnRIUlxcXCIsXFxcIi1cXFwiLFxcXCJpbnNlcnRMaW5rXFxcIixcXFwiaW5zZXJ0SW1hZ2VcXFwiLFxcXCJpbnNlcnRWaWRlb1xcXCIsXFxcImluc2VydEZpbGVcXFwiLFxcXCJpbnNlcnRUYWJsZVxcXCIsXFxcInVuZG9cXFwiLFxcXCJyZWRvXFxcIixcXFwiY2xlYXJGb3JtYXR0aW5nXFxcIl0sdG9vbGJhckNvbnRhaW5lcjpudWxsLHRvb2xiYXJJbmxpbmU6ITEsdG9vbGJhclN0aWNreTohMCx0b29sYmFyU3RpY2t5T2Zmc2V0OjAsdG9vbGJhclZpc2libGVXaXRob3V0U2VsZWN0aW9uOiExfSksYS5GRS5NT0RVTEVTLnRvb2xiYXI9ZnVuY3Rpb24oYil7ZnVuY3Rpb24gYyhhLGIpe2Zvcih2YXIgYz0wO2M8Yi5sZW5ndGg7YysrKVxcXCItXFxcIiE9YltjXSYmXFxcInxcXFwiIT1iW2NdJiZhLmluZGV4T2YoYltjXSk8MCYmYS5wdXNoKGJbY10pfWZ1bmN0aW9uIGQoKXt2YXIgZD1hLm1lcmdlKFtdLGUoKSk7YyhkLGIub3B0cy50b29sYmFyQnV0dG9uc1hTfHxbXSksYyhkLGIub3B0cy50b29sYmFyQnV0dG9uc1NNfHxbXSksYyhkLGIub3B0cy50b29sYmFyQnV0dG9uc01EfHxbXSksYyhkLGIub3B0cy50b29sYmFyQnV0dG9ucyk7Zm9yKHZhciBmPWQubGVuZ3RoLTE7Zj49MDtmLS0pXFxcIi1cXFwiIT1kW2ZdJiZcXFwifFxcXCIhPWRbZl0mJmQuaW5kZXhPZihkW2ZdKTxmJiZkLnNwbGljZShmLDEpO3ZhciBnPWIuYnV0dG9uLmJ1aWxkTGlzdChkLGUoKSk7Yi4kdGIuYXBwZW5kKGcpLGIuYnV0dG9uLmJpbmRDb21tYW5kcyhiLiR0Yil9ZnVuY3Rpb24gZSgpe3ZhciBhPWIuaGVscGVycy5zY3JlZW5TaXplKCk7cmV0dXJuIHZbYV19ZnVuY3Rpb24gZigpe3ZhciBhPWUoKTtiLiR0Yi5maW5kKFxcXCIuZnItc2VwYXJhdG9yXFxcIikucmVtb3ZlKCksYi4kdGIuZmluZChcXFwiPiAuZnItY29tbWFuZFxcXCIpLmFkZENsYXNzKFxcXCJmci1oaWRkZW5cXFwiKTtmb3IodmFyIGM9MDtjPGEubGVuZ3RoO2MrKylpZihcXFwifFxcXCI9PWFbY118fFxcXCItXFxcIj09YVtjXSliLiR0Yi5hcHBlbmQoYi5idXR0b24uYnVpbGRMaXN0KFthW2NdXSkpO2Vsc2V7dmFyIGQ9Yi4kdGIuZmluZCgnPiAuZnItY29tbWFuZFtkYXRhLWNtZD1cXFwiJythW2NdKydcXFwiXScpLGY9bnVsbDtiLm5vZGUuaGFzQ2xhc3MoZC5uZXh0KCkuZ2V0KDApLFxcXCJmci1kcm9wZG93bi1tZW51XFxcIikmJihmPWQubmV4dCgpKSxkLnJlbW92ZUNsYXNzKFxcXCJmci1oaWRkZW5cXFwiKS5hcHBlbmRUbyhiLiR0YiksZiYmZi5hcHBlbmRUbyhiLiR0Yil9fWZ1bmN0aW9uIGcoKXtiLmV2ZW50cy4kb24oYShiLm9fd2luKSxcXFwicmVzaXplXFxcIixmKSxiLmV2ZW50cy4kb24oYShiLm9fd2luKSxcXFwib3JpZW50YXRpb25jaGFuZ2VcXFwiLGYpfWZ1bmN0aW9uIGgoYyxkKXtzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7aWYoKCFjfHxjLndoaWNoIT1hLkZFLktFWUNPREUuRVNDKSYmYi5zZWxlY3Rpb24uaW5FZGl0b3IoKSYmYi5jb3JlLmhhc0ZvY3VzKCkmJiFiLnBvcHVwcy5hcmVWaXNpYmxlKCkmJihiLm9wdHMudG9vbGJhclZpc2libGVXaXRob3V0U2VsZWN0aW9ufHwhYi5zZWxlY3Rpb24uaXNDb2xsYXBzZWQoKSYmIWIua2V5cy5pc0lNRSgpfHxkKSl7aWYoYi4kdGIuZGF0YShcXFwiaW5zdGFuY2VcXFwiLGIpLGIuZXZlbnRzLnRyaWdnZXIoXFxcInRvb2xiYXIuc2hvd1xcXCIsW2NdKT09PSExKXJldHVybiExO2IuJHRiLnNob3coKSxiLm9wdHMudG9vbGJhckNvbnRhaW5lcnx8Yi5wb3NpdGlvbi5mb3JTZWxlY3Rpb24oYi4kdGIpLGIub3B0cy56SW5kZXg+MT9iLiR0Yi5jc3MoXFxcInotaW5kZXhcXFwiLGIub3B0cy56SW5kZXgrMSk6Yi4kdGIuY3NzKFxcXCJ6LWluZGV4XFxcIixudWxsKX19LDApfWZ1bmN0aW9uIGkoKXt2YXIgYT1iLmJ1dHRvbi5nZXRCdXR0b25zKFxcXCIuZnItZHJvcGRvd24uZnItYWN0aXZlXFxcIik7cmV0dXJuISFhLm5leHQoKS5maW5kKGIub19kb2MuYWN0aXZlRWxlbWVudCkubGVuZ3RofHx2b2lkKGIuZXZlbnRzLnRyaWdnZXIoXFxcInRvb2xiYXIuaGlkZVxcXCIpIT09ITEmJmIuJHRiLmhpZGUoKSl9ZnVuY3Rpb24gaigpe3JldHVybiBiLmV2ZW50cy50cmlnZ2VyKFxcXCJ0b29sYmFyLnNob3dcXFwiKSE9PSExJiZ2b2lkIGIuJHRiLnNob3coKX1mdW5jdGlvbiBrKGMpe2NsZWFyVGltZW91dCh3KSxjJiZjLndoaWNoPT1hLkZFLktFWUNPREUuRVNDfHwodz1zZXRUaW1lb3V0KGgsYi5vcHRzLnR5cGluZ1RpbWVyKSl9ZnVuY3Rpb24gbCgpe2IuZXZlbnRzLm9uKFxcXCJ3aW5kb3cubW91c2Vkb3duXFxcIixpKSxiLmV2ZW50cy5vbihcXFwia2V5ZG93blxcXCIsaSksYi5ldmVudHMub24oXFxcImJsdXJcXFwiLGkpLGIuZXZlbnRzLm9uKFxcXCJ3aW5kb3cubW91c2V1cFxcXCIsaCksYi5oZWxwZXJzLmlzTW9iaWxlKCk/Yi5oZWxwZXJzLmlzSU9TKCl8fChiLmV2ZW50cy5vbihcXFwid2luZG93LnRvdWNoZW5kXFxcIixoKSxiLmJyb3dzZXIubW96aWxsYSYmc2V0SW50ZXJ2YWwoaCwyMDApKTpiLmV2ZW50cy5vbihcXFwid2luZG93LmtleXVwXFxcIixrKSxiLmV2ZW50cy5vbihcXFwia2V5ZG93blxcXCIsZnVuY3Rpb24oYil7YiYmYi53aGljaD09YS5GRS5LRVlDT0RFLkVTQyYmaSgpfSksYi5ldmVudHMub24oXFxcImtleWRvd25cXFwiLGZ1bmN0aW9uKGIpe2lmKGIud2hpY2g9PWEuRkUuS0VZQ09ERS5BTFQpcmV0dXJuIGIuc3RvcFByb3BhZ2F0aW9uKCksITF9LCEwKSxiLmV2ZW50cy4kb24oYi4kd3AsXFxcInNjcm9sbC50b29sYmFyXFxcIixoKSxiLmV2ZW50cy5vbihcXFwiY29tbWFuZHMuYWZ0ZXJcXFwiLGgpLGIuaGVscGVycy5pc01vYmlsZSgpJiYoYi5ldmVudHMuJG9uKGIuJGRvYyxcXFwic2VsZWN0aW9uY2hhbmdlXFxcIixrKSxiLmV2ZW50cy4kb24oYi4kZG9jLFxcXCJvcmllbnRhdGlvbmNoYW5nZVxcXCIsaCkpfWZ1bmN0aW9uIG0oKXtiLm9wdHMudG9vbGJhcklubGluZT8oYi4kc2MuYXBwZW5kKGIuJHRiKSxiLiR0Yi5kYXRhKFxcXCJjb250YWluZXJcXFwiLGIuJHNjKSxiLiR0Yi5hZGRDbGFzcyhcXFwiZnItaW5saW5lXFxcIiksYi4kdGIucHJlcGVuZCgnPHNwYW4gY2xhc3M9XFxcImZyLWFycm93XFxcIj48L3NwYW4+JyksbCgpLGIub3B0cy50b29sYmFyQm90dG9tPSExKTooYi5vcHRzLnRvb2xiYXJCb3R0b20mJiFiLmhlbHBlcnMuaXNJT1MoKT8oYi4kYm94LmFwcGVuZChiLiR0YiksYi4kdGIuYWRkQ2xhc3MoXFxcImZyLWJvdHRvbVxcXCIpLGIuJGJveC5hZGRDbGFzcyhcXFwiZnItYm90dG9tXFxcIikpOihiLm9wdHMudG9vbGJhckJvdHRvbT0hMSxiLiRib3gucHJlcGVuZChiLiR0YiksYi4kdGIuYWRkQ2xhc3MoXFxcImZyLXRvcFxcXCIpLGIuJGJveC5hZGRDbGFzcyhcXFwiZnItdG9wXFxcIikpLGIuJHRiLmFkZENsYXNzKFxcXCJmci1iYXNpY1xcXCIpLGIub3B0cy50b29sYmFyU3RpY2t5JiYoYi5vcHRzLnRvb2xiYXJTdGlja3lPZmZzZXQmJihiLm9wdHMudG9vbGJhckJvdHRvbT9iLiR0Yi5jc3MoXFxcImJvdHRvbVxcXCIsYi5vcHRzLnRvb2xiYXJTdGlja3lPZmZzZXQpOmIuJHRiLmNzcyhcXFwidG9wXFxcIixiLm9wdHMudG9vbGJhclN0aWNreU9mZnNldCkpLGIucG9zaXRpb24uYWRkU3RpY2t5KGIuJHRiKSkpfWZ1bmN0aW9uIG4oKXtiLiR0Yi5odG1sKFxcXCJcXFwiKS5yZW1vdmVEYXRhKCkucmVtb3ZlKCksYi4kdGI9bnVsbH1mdW5jdGlvbiBvKCl7Yi4kYm94LnJlbW92ZUNsYXNzKFxcXCJmci10b3AgZnItYm90dG9tIGZyLWlubGluZSBmci1iYXNpY1xcXCIpLGIuJGJveC5maW5kKFxcXCIuZnItc3RpY2t5LWR1bW15XFxcIikucmVtb3ZlKCl9ZnVuY3Rpb24gcCgpe2Iub3B0cy50aGVtZSYmYi4kdGIuYWRkQ2xhc3MoYi5vcHRzLnRoZW1lK1xcXCItdGhlbWVcXFwiKSxiLm9wdHMuekluZGV4PjEmJmIuJHRiLmNzcyhcXFwiei1pbmRleFxcXCIsYi5vcHRzLnpJbmRleCsxKSxcXFwiYXV0b1xcXCIhPWIub3B0cy5kaXJlY3Rpb24mJmIuJHRiLnJlbW92ZUNsYXNzKFxcXCJmci1sdHIgZnItcnRsXFxcIikuYWRkQ2xhc3MoXFxcImZyLVxcXCIrYi5vcHRzLmRpcmVjdGlvbiksYi5oZWxwZXJzLmlzTW9iaWxlKCk/Yi4kdGIuYWRkQ2xhc3MoXFxcImZyLW1vYmlsZVxcXCIpOmIuJHRiLmFkZENsYXNzKFxcXCJmci1kZXNrdG9wXFxcIiksYi5vcHRzLnRvb2xiYXJDb250YWluZXI/KGIub3B0cy50b29sYmFySW5saW5lJiYobCgpLGkoKSksYi5vcHRzLnRvb2xiYXJCb3R0b20/Yi4kdGIuYWRkQ2xhc3MoXFxcImZyLWJvdHRvbVxcXCIpOmIuJHRiLmFkZENsYXNzKFxcXCJmci10b3BcXFwiKSk6bSgpLHQ9Yi4kdGIuZ2V0KDApLm93bmVyRG9jdW1lbnQsdT1cXFwiZGVmYXVsdFZpZXdcXFwiaW4gdD90LmRlZmF1bHRWaWV3OnQucGFyZW50V2luZG93LGQoKSxnKCksYi5hY2Nlc3NpYmlsaXR5LnJlZ2lzdGVyVG9vbGJhcihiLiR0YiksYi5ldmVudHMuJG9uKGIuJHRiLGIuX21vdXNlZG93bitcXFwiIFxcXCIrYi5fbW91c2V1cCxmdW5jdGlvbihhKXt2YXIgYz1hLm9yaWdpbmFsRXZlbnQ/YS5vcmlnaW5hbEV2ZW50LnRhcmdldHx8YS5vcmlnaW5hbEV2ZW50Lm9yaWdpbmFsVGFyZ2V0Om51bGw7aWYoYyYmXFxcIklOUFVUXFxcIiE9Yy50YWdOYW1lJiYhYi5lZGl0LmlzRGlzYWJsZWQoKSlyZXR1cm4gYS5zdG9wUHJvcGFnYXRpb24oKSxhLnByZXZlbnREZWZhdWx0KCksITF9LCEwKX1mdW5jdGlvbiBxKCl7cmV0dXJuIGIuJHNjPWEoYi5vcHRzLnNjcm9sbGFibGVDb250YWluZXIpLCEhYi4kd3AmJihiLm9wdHMudG9vbGJhckNvbnRhaW5lcj8oYi5zaGFyZWQuJHRiPyhiLiR0Yj1iLnNoYXJlZC4kdGIsYi5vcHRzLnRvb2xiYXJJbmxpbmUmJmwoKSk6KGIuc2hhcmVkLiR0Yj1hKCc8ZGl2IGNsYXNzPVxcXCJmci10b29sYmFyXFxcIj48L2Rpdj4nKSxiLiR0Yj1iLnNoYXJlZC4kdGIsYShiLm9wdHMudG9vbGJhckNvbnRhaW5lcikuYXBwZW5kKGIuJHRiKSxwKCksYi4kdGIuZGF0YShcXFwiaW5zdGFuY2VcXFwiLGIpKSxiLm9wdHMudG9vbGJhcklubGluZT9iLiRib3guYWRkQ2xhc3MoXFxcImZyLWlubGluZVxcXCIpOmIuJGJveC5hZGRDbGFzcyhcXFwiZnItYmFzaWNcXFwiKSxiLmV2ZW50cy5vbihcXFwiZm9jdXNcXFwiLGZ1bmN0aW9uKCl7Yi4kdGIuZGF0YShcXFwiaW5zdGFuY2VcXFwiLGIpfSwhMCksYi5vcHRzLnRvb2xiYXJJbmxpbmU9ITEpOmIub3B0cy50b29sYmFySW5saW5lPyhiLiRib3guYWRkQ2xhc3MoXFxcImZyLWlubGluZVxcXCIpLGIuc2hhcmVkLiR0Yj8oYi4kdGI9Yi5zaGFyZWQuJHRiLGwoKSk6KGIuc2hhcmVkLiR0Yj1hKCc8ZGl2IGNsYXNzPVxcXCJmci10b29sYmFyXFxcIj48L2Rpdj4nKSxiLiR0Yj1iLnNoYXJlZC4kdGIscCgpKSk6KGIuJGJveC5hZGRDbGFzcyhcXFwiZnItYmFzaWNcXFwiKSxiLiR0Yj1hKCc8ZGl2IGNsYXNzPVxcXCJmci10b29sYmFyXFxcIj48L2Rpdj4nKSxwKCksYi4kdGIuZGF0YShcXFwiaW5zdGFuY2VcXFwiLGIpKSxiLmV2ZW50cy5vbihcXFwiZGVzdHJveVxcXCIsbywhMCksdm9pZCBiLmV2ZW50cy5vbihiLm9wdHMudG9vbGJhcklubGluZXx8Yi5vcHRzLnRvb2xiYXJDb250YWluZXI/XFxcInNoYXJlZC5kZXN0cm95XFxcIjpcXFwiZGVzdHJveVxcXCIsbiwhMCkpfWZ1bmN0aW9uIHIoKXsheCYmYi4kdGImJihiLiR0Yi5maW5kKFxcXCI+IC5mci1jb21tYW5kXFxcIikuYWRkQ2xhc3MoXFxcImZyLWRpc2FibGVkIGZyLW5vLXJlZnJlc2hcXFwiKS5hdHRyKFxcXCJhcmlhLWRpc2FibGVkXFxcIiwhMCkseD0hMCl9ZnVuY3Rpb24gcygpe3gmJmIuJHRiJiYoYi4kdGIuZmluZChcXFwiPiAuZnItY29tbWFuZFxcXCIpLnJlbW92ZUNsYXNzKFxcXCJmci1kaXNhYmxlZCBmci1uby1yZWZyZXNoXFxcIikuYXR0cihcXFwiYXJpYS1kaXNhYmxlZFxcXCIsITEpLHg9ITEpLGIuYnV0dG9uLmJ1bGtSZWZyZXNoKCl9dmFyIHQsdSx2PVtdO3ZbYS5GRS5YU109Yi5vcHRzLnRvb2xiYXJCdXR0b25zWFN8fGIub3B0cy50b29sYmFyQnV0dG9ucyx2W2EuRkUuU01dPWIub3B0cy50b29sYmFyQnV0dG9uc1NNfHxiLm9wdHMudG9vbGJhckJ1dHRvbnMsdlthLkZFLk1EXT1iLm9wdHMudG9vbGJhckJ1dHRvbnNNRHx8Yi5vcHRzLnRvb2xiYXJCdXR0b25zLHZbYS5GRS5MR109Yi5vcHRzLnRvb2xiYXJCdXR0b25zO3ZhciB3PW51bGwseD0hMTtyZXR1cm57X2luaXQ6cSxoaWRlOmksc2hvdzpqLHNob3dJbmxpbmU6aCxkaXNhYmxlOnIsZW5hYmxlOnN9fX0pO1wiXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3Jhdy1sb2FkZXIhLi9+L2Zyb2FsYS1lZGl0b3IvanMvZnJvYWxhX2VkaXRvci5taW4uanNcbi8vIG1vZHVsZSBpZCA9IDNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQSIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	eval("__webpack_require__(2)(__webpack_require__(5))//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL34vY29kZW1pcnJvci9saWIvY29kZW1pcnJvci5qcz8yNTI1Il0sInNvdXJjZXNDb250ZW50IjpbInJlcXVpcmUoXCIhIS92YXIvYXBwL3dlYi9qcy9ub2RlX21vZHVsZXMvc2NyaXB0LWxvYWRlci9hZGRTY3JpcHQuanNcIikocmVxdWlyZShcIiEhL3Zhci9hcHAvd2ViL2pzL25vZGVfbW9kdWxlcy9yYXctbG9hZGVyL2luZGV4LmpzIS92YXIvYXBwL3dlYi9qcy9ub2RlX21vZHVsZXMvY29kZW1pcnJvci9saWIvY29kZW1pcnJvci5qc1wiKSlcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vc2NyaXB0LWxvYWRlciEuL34vY29kZW1pcnJvci9saWIvY29kZW1pcnJvci5qc1xuLy8gbW9kdWxlIGlkID0gNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 5 */
/***/ function(module, exports) {

	eval("module.exports = \"// CodeMirror, copyright (c) by Marijn Haverbeke and others\\n// Distributed under an MIT license: http://codemirror.net/LICENSE\\n\\n// This is CodeMirror (http://codemirror.net), a code editor\\n// implemented in JavaScript on top of the browser's DOM.\\n//\\n// You can find some technical background for some of the code below\\n// at http://marijnhaverbeke.nl/blog/#cm-internals .\\n\\n(function (global, factory) {\\n\\ttypeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\\n\\ttypeof define === 'function' && define.amd ? define(factory) :\\n\\t(global.CodeMirror = factory());\\n}(this, (function () { 'use strict';\\n\\n// Kludges for bugs and behavior differences that can't be feature\\n// detected are enabled based on userAgent etc sniffing.\\nvar userAgent = navigator.userAgent;\\nvar platform = navigator.platform;\\n\\nvar gecko = /gecko\\\\/\\\\d/i.test(userAgent);\\nvar ie_upto10 = /MSIE \\\\d/.test(userAgent);\\nvar ie_11up = /Trident\\\\/(?:[7-9]|\\\\d{2,})\\\\..*rv:(\\\\d+)/.exec(userAgent);\\nvar edge = /Edge\\\\/(\\\\d+)/.exec(userAgent);\\nvar ie = ie_upto10 || ie_11up || edge;\\nvar ie_version = ie && (ie_upto10 ? document.documentMode || 6 : +(edge || ie_11up)[1]);\\nvar webkit = !edge && /WebKit\\\\//.test(userAgent);\\nvar qtwebkit = webkit && /Qt\\\\/\\\\d+\\\\.\\\\d+/.test(userAgent);\\nvar chrome = !edge && /Chrome\\\\//.test(userAgent);\\nvar presto = /Opera\\\\//.test(userAgent);\\nvar safari = /Apple Computer/.test(navigator.vendor);\\nvar mac_geMountainLion = /Mac OS X 1\\\\d\\\\D([8-9]|\\\\d\\\\d)\\\\D/.test(userAgent);\\nvar phantom = /PhantomJS/.test(userAgent);\\n\\nvar ios = !edge && /AppleWebKit/.test(userAgent) && /Mobile\\\\/\\\\w+/.test(userAgent);\\nvar android = /Android/.test(userAgent);\\n// This is woefully incomplete. Suggestions for alternative methods welcome.\\nvar mobile = ios || android || /webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(userAgent);\\nvar mac = ios || /Mac/.test(platform);\\nvar chromeOS = /\\\\bCrOS\\\\b/.test(userAgent);\\nvar windows = /win/i.test(platform);\\n\\nvar presto_version = presto && userAgent.match(/Version\\\\/(\\\\d*\\\\.\\\\d*)/);\\nif (presto_version) { presto_version = Number(presto_version[1]); }\\nif (presto_version && presto_version >= 15) { presto = false; webkit = true; }\\n// Some browsers use the wrong event properties to signal cmd/ctrl on OS X\\nvar flipCtrlCmd = mac && (qtwebkit || presto && (presto_version == null || presto_version < 12.11));\\nvar captureRightClick = gecko || (ie && ie_version >= 9);\\n\\nfunction classTest(cls) { return new RegExp(\\\"(^|\\\\\\\\s)\\\" + cls + \\\"(?:$|\\\\\\\\s)\\\\\\\\s*\\\") }\\n\\nvar rmClass = function(node, cls) {\\n  var current = node.className;\\n  var match = classTest(cls).exec(current);\\n  if (match) {\\n    var after = current.slice(match.index + match[0].length);\\n    node.className = current.slice(0, match.index) + (after ? match[1] + after : \\\"\\\");\\n  }\\n};\\n\\nfunction removeChildren(e) {\\n  for (var count = e.childNodes.length; count > 0; --count)\\n    { e.removeChild(e.firstChild); }\\n  return e\\n}\\n\\nfunction removeChildrenAndAdd(parent, e) {\\n  return removeChildren(parent).appendChild(e)\\n}\\n\\nfunction elt(tag, content, className, style) {\\n  var e = document.createElement(tag);\\n  if (className) { e.className = className; }\\n  if (style) { e.style.cssText = style; }\\n  if (typeof content == \\\"string\\\") { e.appendChild(document.createTextNode(content)); }\\n  else if (content) { for (var i = 0; i < content.length; ++i) { e.appendChild(content[i]); } }\\n  return e\\n}\\n// wrapper for elt, which removes the elt from the accessibility tree\\nfunction eltP(tag, content, className, style) {\\n  var e = elt(tag, content, className, style);\\n  e.setAttribute(\\\"role\\\", \\\"presentation\\\");\\n  return e\\n}\\n\\nvar range;\\nif (document.createRange) { range = function(node, start, end, endNode) {\\n  var r = document.createRange();\\n  r.setEnd(endNode || node, end);\\n  r.setStart(node, start);\\n  return r\\n}; }\\nelse { range = function(node, start, end) {\\n  var r = document.body.createTextRange();\\n  try { r.moveToElementText(node.parentNode); }\\n  catch(e) { return r }\\n  r.collapse(true);\\n  r.moveEnd(\\\"character\\\", end);\\n  r.moveStart(\\\"character\\\", start);\\n  return r\\n}; }\\n\\nfunction contains(parent, child) {\\n  if (child.nodeType == 3) // Android browser always returns false when child is a textnode\\n    { child = child.parentNode; }\\n  if (parent.contains)\\n    { return parent.contains(child) }\\n  do {\\n    if (child.nodeType == 11) { child = child.host; }\\n    if (child == parent) { return true }\\n  } while (child = child.parentNode)\\n}\\n\\nfunction activeElt() {\\n  // IE and Edge may throw an \\\"Unspecified Error\\\" when accessing document.activeElement.\\n  // IE < 10 will throw when accessed while the page is loading or in an iframe.\\n  // IE > 9 and Edge will throw when accessed in an iframe if document.body is unavailable.\\n  var activeElement;\\n  try {\\n    activeElement = document.activeElement;\\n  } catch(e) {\\n    activeElement = document.body || null;\\n  }\\n  while (activeElement && activeElement.shadowRoot && activeElement.shadowRoot.activeElement)\\n    { activeElement = activeElement.shadowRoot.activeElement; }\\n  return activeElement\\n}\\n\\nfunction addClass(node, cls) {\\n  var current = node.className;\\n  if (!classTest(cls).test(current)) { node.className += (current ? \\\" \\\" : \\\"\\\") + cls; }\\n}\\nfunction joinClasses(a, b) {\\n  var as = a.split(\\\" \\\");\\n  for (var i = 0; i < as.length; i++)\\n    { if (as[i] && !classTest(as[i]).test(b)) { b += \\\" \\\" + as[i]; } }\\n  return b\\n}\\n\\nvar selectInput = function(node) { node.select(); };\\nif (ios) // Mobile Safari apparently has a bug where select() is broken.\\n  { selectInput = function(node) { node.selectionStart = 0; node.selectionEnd = node.value.length; }; }\\nelse if (ie) // Suppress mysterious IE10 errors\\n  { selectInput = function(node) { try { node.select(); } catch(_e) {} }; }\\n\\nfunction bind(f) {\\n  var args = Array.prototype.slice.call(arguments, 1);\\n  return function(){return f.apply(null, args)}\\n}\\n\\nfunction copyObj(obj, target, overwrite) {\\n  if (!target) { target = {}; }\\n  for (var prop in obj)\\n    { if (obj.hasOwnProperty(prop) && (overwrite !== false || !target.hasOwnProperty(prop)))\\n      { target[prop] = obj[prop]; } }\\n  return target\\n}\\n\\n// Counts the column offset in a string, taking tabs into account.\\n// Used mostly to find indentation.\\nfunction countColumn(string, end, tabSize, startIndex, startValue) {\\n  if (end == null) {\\n    end = string.search(/[^\\\\s\\\\u00a0]/);\\n    if (end == -1) { end = string.length; }\\n  }\\n  for (var i = startIndex || 0, n = startValue || 0;;) {\\n    var nextTab = string.indexOf(\\\"\\\\t\\\", i);\\n    if (nextTab < 0 || nextTab >= end)\\n      { return n + (end - i) }\\n    n += nextTab - i;\\n    n += tabSize - (n % tabSize);\\n    i = nextTab + 1;\\n  }\\n}\\n\\nvar Delayed = function() {this.id = null;};\\nDelayed.prototype.set = function (ms, f) {\\n  clearTimeout(this.id);\\n  this.id = setTimeout(f, ms);\\n};\\n\\nfunction indexOf(array, elt) {\\n  for (var i = 0; i < array.length; ++i)\\n    { if (array[i] == elt) { return i } }\\n  return -1\\n}\\n\\n// Number of pixels added to scroller and sizer to hide scrollbar\\nvar scrollerGap = 30;\\n\\n// Returned or thrown by various protocols to signal 'I'm not\\n// handling this'.\\nvar Pass = {toString: function(){return \\\"CodeMirror.Pass\\\"}};\\n\\n// Reused option objects for setSelection & friends\\nvar sel_dontScroll = {scroll: false};\\nvar sel_mouse = {origin: \\\"*mouse\\\"};\\nvar sel_move = {origin: \\\"+move\\\"};\\n\\n// The inverse of countColumn -- find the offset that corresponds to\\n// a particular column.\\nfunction findColumn(string, goal, tabSize) {\\n  for (var pos = 0, col = 0;;) {\\n    var nextTab = string.indexOf(\\\"\\\\t\\\", pos);\\n    if (nextTab == -1) { nextTab = string.length; }\\n    var skipped = nextTab - pos;\\n    if (nextTab == string.length || col + skipped >= goal)\\n      { return pos + Math.min(skipped, goal - col) }\\n    col += nextTab - pos;\\n    col += tabSize - (col % tabSize);\\n    pos = nextTab + 1;\\n    if (col >= goal) { return pos }\\n  }\\n}\\n\\nvar spaceStrs = [\\\"\\\"];\\nfunction spaceStr(n) {\\n  while (spaceStrs.length <= n)\\n    { spaceStrs.push(lst(spaceStrs) + \\\" \\\"); }\\n  return spaceStrs[n]\\n}\\n\\nfunction lst(arr) { return arr[arr.length-1] }\\n\\nfunction map(array, f) {\\n  var out = [];\\n  for (var i = 0; i < array.length; i++) { out[i] = f(array[i], i); }\\n  return out\\n}\\n\\nfunction insertSorted(array, value, score) {\\n  var pos = 0, priority = score(value);\\n  while (pos < array.length && score(array[pos]) <= priority) { pos++; }\\n  array.splice(pos, 0, value);\\n}\\n\\nfunction nothing() {}\\n\\nfunction createObj(base, props) {\\n  var inst;\\n  if (Object.create) {\\n    inst = Object.create(base);\\n  } else {\\n    nothing.prototype = base;\\n    inst = new nothing();\\n  }\\n  if (props) { copyObj(props, inst); }\\n  return inst\\n}\\n\\nvar nonASCIISingleCaseWordChar = /[\\\\u00df\\\\u0587\\\\u0590-\\\\u05f4\\\\u0600-\\\\u06ff\\\\u3040-\\\\u309f\\\\u30a0-\\\\u30ff\\\\u3400-\\\\u4db5\\\\u4e00-\\\\u9fcc\\\\uac00-\\\\ud7af]/;\\nfunction isWordCharBasic(ch) {\\n  return /\\\\w/.test(ch) || ch > \\\"\\\\x80\\\" &&\\n    (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch))\\n}\\nfunction isWordChar(ch, helper) {\\n  if (!helper) { return isWordCharBasic(ch) }\\n  if (helper.source.indexOf(\\\"\\\\\\\\w\\\") > -1 && isWordCharBasic(ch)) { return true }\\n  return helper.test(ch)\\n}\\n\\nfunction isEmpty(obj) {\\n  for (var n in obj) { if (obj.hasOwnProperty(n) && obj[n]) { return false } }\\n  return true\\n}\\n\\n// Extending unicode characters. A series of a non-extending char +\\n// any number of extending chars is treated as a single unit as far\\n// as editing and measuring is concerned. This is not fully correct,\\n// since some scripts/fonts/browsers also treat other configurations\\n// of code points as a group.\\nvar extendingChars = /[\\\\u0300-\\\\u036f\\\\u0483-\\\\u0489\\\\u0591-\\\\u05bd\\\\u05bf\\\\u05c1\\\\u05c2\\\\u05c4\\\\u05c5\\\\u05c7\\\\u0610-\\\\u061a\\\\u064b-\\\\u065e\\\\u0670\\\\u06d6-\\\\u06dc\\\\u06de-\\\\u06e4\\\\u06e7\\\\u06e8\\\\u06ea-\\\\u06ed\\\\u0711\\\\u0730-\\\\u074a\\\\u07a6-\\\\u07b0\\\\u07eb-\\\\u07f3\\\\u0816-\\\\u0819\\\\u081b-\\\\u0823\\\\u0825-\\\\u0827\\\\u0829-\\\\u082d\\\\u0900-\\\\u0902\\\\u093c\\\\u0941-\\\\u0948\\\\u094d\\\\u0951-\\\\u0955\\\\u0962\\\\u0963\\\\u0981\\\\u09bc\\\\u09be\\\\u09c1-\\\\u09c4\\\\u09cd\\\\u09d7\\\\u09e2\\\\u09e3\\\\u0a01\\\\u0a02\\\\u0a3c\\\\u0a41\\\\u0a42\\\\u0a47\\\\u0a48\\\\u0a4b-\\\\u0a4d\\\\u0a51\\\\u0a70\\\\u0a71\\\\u0a75\\\\u0a81\\\\u0a82\\\\u0abc\\\\u0ac1-\\\\u0ac5\\\\u0ac7\\\\u0ac8\\\\u0acd\\\\u0ae2\\\\u0ae3\\\\u0b01\\\\u0b3c\\\\u0b3e\\\\u0b3f\\\\u0b41-\\\\u0b44\\\\u0b4d\\\\u0b56\\\\u0b57\\\\u0b62\\\\u0b63\\\\u0b82\\\\u0bbe\\\\u0bc0\\\\u0bcd\\\\u0bd7\\\\u0c3e-\\\\u0c40\\\\u0c46-\\\\u0c48\\\\u0c4a-\\\\u0c4d\\\\u0c55\\\\u0c56\\\\u0c62\\\\u0c63\\\\u0cbc\\\\u0cbf\\\\u0cc2\\\\u0cc6\\\\u0ccc\\\\u0ccd\\\\u0cd5\\\\u0cd6\\\\u0ce2\\\\u0ce3\\\\u0d3e\\\\u0d41-\\\\u0d44\\\\u0d4d\\\\u0d57\\\\u0d62\\\\u0d63\\\\u0dca\\\\u0dcf\\\\u0dd2-\\\\u0dd4\\\\u0dd6\\\\u0ddf\\\\u0e31\\\\u0e34-\\\\u0e3a\\\\u0e47-\\\\u0e4e\\\\u0eb1\\\\u0eb4-\\\\u0eb9\\\\u0ebb\\\\u0ebc\\\\u0ec8-\\\\u0ecd\\\\u0f18\\\\u0f19\\\\u0f35\\\\u0f37\\\\u0f39\\\\u0f71-\\\\u0f7e\\\\u0f80-\\\\u0f84\\\\u0f86\\\\u0f87\\\\u0f90-\\\\u0f97\\\\u0f99-\\\\u0fbc\\\\u0fc6\\\\u102d-\\\\u1030\\\\u1032-\\\\u1037\\\\u1039\\\\u103a\\\\u103d\\\\u103e\\\\u1058\\\\u1059\\\\u105e-\\\\u1060\\\\u1071-\\\\u1074\\\\u1082\\\\u1085\\\\u1086\\\\u108d\\\\u109d\\\\u135f\\\\u1712-\\\\u1714\\\\u1732-\\\\u1734\\\\u1752\\\\u1753\\\\u1772\\\\u1773\\\\u17b7-\\\\u17bd\\\\u17c6\\\\u17c9-\\\\u17d3\\\\u17dd\\\\u180b-\\\\u180d\\\\u18a9\\\\u1920-\\\\u1922\\\\u1927\\\\u1928\\\\u1932\\\\u1939-\\\\u193b\\\\u1a17\\\\u1a18\\\\u1a56\\\\u1a58-\\\\u1a5e\\\\u1a60\\\\u1a62\\\\u1a65-\\\\u1a6c\\\\u1a73-\\\\u1a7c\\\\u1a7f\\\\u1b00-\\\\u1b03\\\\u1b34\\\\u1b36-\\\\u1b3a\\\\u1b3c\\\\u1b42\\\\u1b6b-\\\\u1b73\\\\u1b80\\\\u1b81\\\\u1ba2-\\\\u1ba5\\\\u1ba8\\\\u1ba9\\\\u1c2c-\\\\u1c33\\\\u1c36\\\\u1c37\\\\u1cd0-\\\\u1cd2\\\\u1cd4-\\\\u1ce0\\\\u1ce2-\\\\u1ce8\\\\u1ced\\\\u1dc0-\\\\u1de6\\\\u1dfd-\\\\u1dff\\\\u200c\\\\u200d\\\\u20d0-\\\\u20f0\\\\u2cef-\\\\u2cf1\\\\u2de0-\\\\u2dff\\\\u302a-\\\\u302f\\\\u3099\\\\u309a\\\\ua66f-\\\\ua672\\\\ua67c\\\\ua67d\\\\ua6f0\\\\ua6f1\\\\ua802\\\\ua806\\\\ua80b\\\\ua825\\\\ua826\\\\ua8c4\\\\ua8e0-\\\\ua8f1\\\\ua926-\\\\ua92d\\\\ua947-\\\\ua951\\\\ua980-\\\\ua982\\\\ua9b3\\\\ua9b6-\\\\ua9b9\\\\ua9bc\\\\uaa29-\\\\uaa2e\\\\uaa31\\\\uaa32\\\\uaa35\\\\uaa36\\\\uaa43\\\\uaa4c\\\\uaab0\\\\uaab2-\\\\uaab4\\\\uaab7\\\\uaab8\\\\uaabe\\\\uaabf\\\\uaac1\\\\uabe5\\\\uabe8\\\\uabed\\\\udc00-\\\\udfff\\\\ufb1e\\\\ufe00-\\\\ufe0f\\\\ufe20-\\\\ufe26\\\\uff9e\\\\uff9f]/;\\nfunction isExtendingChar(ch) { return ch.charCodeAt(0) >= 768 && extendingChars.test(ch) }\\n\\n// Returns a number from the range [`0`; `str.length`] unless `pos` is outside that range.\\nfunction skipExtendingChars(str, pos, dir) {\\n  while ((dir < 0 ? pos > 0 : pos < str.length) && isExtendingChar(str.charAt(pos))) { pos += dir; }\\n  return pos\\n}\\n\\n// Returns the value from the range [`from`; `to`] that satisfies\\n// `pred` and is closest to `from`. Assumes that at least `to` satisfies `pred`.\\nfunction findFirst(pred, from, to) {\\n  for (;;) {\\n    if (Math.abs(from - to) <= 1) { return pred(from) ? from : to }\\n    var mid = Math.floor((from + to) / 2);\\n    if (pred(mid)) { to = mid; }\\n    else { from = mid; }\\n  }\\n}\\n\\n// The display handles the DOM integration, both for input reading\\n// and content drawing. It holds references to DOM nodes and\\n// display-related state.\\n\\nfunction Display(place, doc, input) {\\n  var d = this;\\n  this.input = input;\\n\\n  // Covers bottom-right square when both scrollbars are present.\\n  d.scrollbarFiller = elt(\\\"div\\\", null, \\\"CodeMirror-scrollbar-filler\\\");\\n  d.scrollbarFiller.setAttribute(\\\"cm-not-content\\\", \\\"true\\\");\\n  // Covers bottom of gutter when coverGutterNextToScrollbar is on\\n  // and h scrollbar is present.\\n  d.gutterFiller = elt(\\\"div\\\", null, \\\"CodeMirror-gutter-filler\\\");\\n  d.gutterFiller.setAttribute(\\\"cm-not-content\\\", \\\"true\\\");\\n  // Will contain the actual code, positioned to cover the viewport.\\n  d.lineDiv = eltP(\\\"div\\\", null, \\\"CodeMirror-code\\\");\\n  // Elements are added to these to represent selection and cursors.\\n  d.selectionDiv = elt(\\\"div\\\", null, null, \\\"position: relative; z-index: 1\\\");\\n  d.cursorDiv = elt(\\\"div\\\", null, \\\"CodeMirror-cursors\\\");\\n  // A visibility: hidden element used to find the size of things.\\n  d.measure = elt(\\\"div\\\", null, \\\"CodeMirror-measure\\\");\\n  // When lines outside of the viewport are measured, they are drawn in this.\\n  d.lineMeasure = elt(\\\"div\\\", null, \\\"CodeMirror-measure\\\");\\n  // Wraps everything that needs to exist inside the vertically-padded coordinate system\\n  d.lineSpace = eltP(\\\"div\\\", [d.measure, d.lineMeasure, d.selectionDiv, d.cursorDiv, d.lineDiv],\\n                    null, \\\"position: relative; outline: none\\\");\\n  var lines = eltP(\\\"div\\\", [d.lineSpace], \\\"CodeMirror-lines\\\");\\n  // Moved around its parent to cover visible view.\\n  d.mover = elt(\\\"div\\\", [lines], null, \\\"position: relative\\\");\\n  // Set to the height of the document, allowing scrolling.\\n  d.sizer = elt(\\\"div\\\", [d.mover], \\\"CodeMirror-sizer\\\");\\n  d.sizerWidth = null;\\n  // Behavior of elts with overflow: auto and padding is\\n  // inconsistent across browsers. This is used to ensure the\\n  // scrollable area is big enough.\\n  d.heightForcer = elt(\\\"div\\\", null, null, \\\"position: absolute; height: \\\" + scrollerGap + \\\"px; width: 1px;\\\");\\n  // Will contain the gutters, if any.\\n  d.gutters = elt(\\\"div\\\", null, \\\"CodeMirror-gutters\\\");\\n  d.lineGutter = null;\\n  // Actual scrollable element.\\n  d.scroller = elt(\\\"div\\\", [d.sizer, d.heightForcer, d.gutters], \\\"CodeMirror-scroll\\\");\\n  d.scroller.setAttribute(\\\"tabIndex\\\", \\\"-1\\\");\\n  // The element in which the editor lives.\\n  d.wrapper = elt(\\\"div\\\", [d.scrollbarFiller, d.gutterFiller, d.scroller], \\\"CodeMirror\\\");\\n\\n  // Work around IE7 z-index bug (not perfect, hence IE7 not really being supported)\\n  if (ie && ie_version < 8) { d.gutters.style.zIndex = -1; d.scroller.style.paddingRight = 0; }\\n  if (!webkit && !(gecko && mobile)) { d.scroller.draggable = true; }\\n\\n  if (place) {\\n    if (place.appendChild) { place.appendChild(d.wrapper); }\\n    else { place(d.wrapper); }\\n  }\\n\\n  // Current rendered range (may be bigger than the view window).\\n  d.viewFrom = d.viewTo = doc.first;\\n  d.reportedViewFrom = d.reportedViewTo = doc.first;\\n  // Information about the rendered lines.\\n  d.view = [];\\n  d.renderedView = null;\\n  // Holds info about a single rendered line when it was rendered\\n  // for measurement, while not in view.\\n  d.externalMeasured = null;\\n  // Empty space (in pixels) above the view\\n  d.viewOffset = 0;\\n  d.lastWrapHeight = d.lastWrapWidth = 0;\\n  d.updateLineNumbers = null;\\n\\n  d.nativeBarWidth = d.barHeight = d.barWidth = 0;\\n  d.scrollbarsClipped = false;\\n\\n  // Used to only resize the line number gutter when necessary (when\\n  // the amount of lines crosses a boundary that makes its width change)\\n  d.lineNumWidth = d.lineNumInnerWidth = d.lineNumChars = null;\\n  // Set to true when a non-horizontal-scrolling line widget is\\n  // added. As an optimization, line widget aligning is skipped when\\n  // this is false.\\n  d.alignWidgets = false;\\n\\n  d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;\\n\\n  // Tracks the maximum line length so that the horizontal scrollbar\\n  // can be kept static when scrolling.\\n  d.maxLine = null;\\n  d.maxLineLength = 0;\\n  d.maxLineChanged = false;\\n\\n  // Used for measuring wheel scrolling granularity\\n  d.wheelDX = d.wheelDY = d.wheelStartX = d.wheelStartY = null;\\n\\n  // True when shift is held down.\\n  d.shift = false;\\n\\n  // Used to track whether anything happened since the context menu\\n  // was opened.\\n  d.selForContextMenu = null;\\n\\n  d.activeTouch = null;\\n\\n  input.init(d);\\n}\\n\\n// Find the line object corresponding to the given line number.\\nfunction getLine(doc, n) {\\n  n -= doc.first;\\n  if (n < 0 || n >= doc.size) { throw new Error(\\\"There is no line \\\" + (n + doc.first) + \\\" in the document.\\\") }\\n  var chunk = doc;\\n  while (!chunk.lines) {\\n    for (var i = 0;; ++i) {\\n      var child = chunk.children[i], sz = child.chunkSize();\\n      if (n < sz) { chunk = child; break }\\n      n -= sz;\\n    }\\n  }\\n  return chunk.lines[n]\\n}\\n\\n// Get the part of a document between two positions, as an array of\\n// strings.\\nfunction getBetween(doc, start, end) {\\n  var out = [], n = start.line;\\n  doc.iter(start.line, end.line + 1, function (line) {\\n    var text = line.text;\\n    if (n == end.line) { text = text.slice(0, end.ch); }\\n    if (n == start.line) { text = text.slice(start.ch); }\\n    out.push(text);\\n    ++n;\\n  });\\n  return out\\n}\\n// Get the lines between from and to, as array of strings.\\nfunction getLines(doc, from, to) {\\n  var out = [];\\n  doc.iter(from, to, function (line) { out.push(line.text); }); // iter aborts when callback returns truthy value\\n  return out\\n}\\n\\n// Update the height of a line, propagating the height change\\n// upwards to parent nodes.\\nfunction updateLineHeight(line, height) {\\n  var diff = height - line.height;\\n  if (diff) { for (var n = line; n; n = n.parent) { n.height += diff; } }\\n}\\n\\n// Given a line object, find its line number by walking up through\\n// its parent links.\\nfunction lineNo(line) {\\n  if (line.parent == null) { return null }\\n  var cur = line.parent, no = indexOf(cur.lines, line);\\n  for (var chunk = cur.parent; chunk; cur = chunk, chunk = chunk.parent) {\\n    for (var i = 0;; ++i) {\\n      if (chunk.children[i] == cur) { break }\\n      no += chunk.children[i].chunkSize();\\n    }\\n  }\\n  return no + cur.first\\n}\\n\\n// Find the line at the given vertical position, using the height\\n// information in the document tree.\\nfunction lineAtHeight(chunk, h) {\\n  var n = chunk.first;\\n  outer: do {\\n    for (var i$1 = 0; i$1 < chunk.children.length; ++i$1) {\\n      var child = chunk.children[i$1], ch = child.height;\\n      if (h < ch) { chunk = child; continue outer }\\n      h -= ch;\\n      n += child.chunkSize();\\n    }\\n    return n\\n  } while (!chunk.lines)\\n  var i = 0;\\n  for (; i < chunk.lines.length; ++i) {\\n    var line = chunk.lines[i], lh = line.height;\\n    if (h < lh) { break }\\n    h -= lh;\\n  }\\n  return n + i\\n}\\n\\nfunction isLine(doc, l) {return l >= doc.first && l < doc.first + doc.size}\\n\\nfunction lineNumberFor(options, i) {\\n  return String(options.lineNumberFormatter(i + options.firstLineNumber))\\n}\\n\\n// A Pos instance represents a position within the text.\\nfunction Pos(line, ch, sticky) {\\n  if ( sticky === void 0 ) sticky = null;\\n\\n  if (!(this instanceof Pos)) { return new Pos(line, ch, sticky) }\\n  this.line = line;\\n  this.ch = ch;\\n  this.sticky = sticky;\\n}\\n\\n// Compare two positions, return 0 if they are the same, a negative\\n// number when a is less, and a positive number otherwise.\\nfunction cmp(a, b) { return a.line - b.line || a.ch - b.ch }\\n\\nfunction equalCursorPos(a, b) { return a.sticky == b.sticky && cmp(a, b) == 0 }\\n\\nfunction copyPos(x) {return Pos(x.line, x.ch)}\\nfunction maxPos(a, b) { return cmp(a, b) < 0 ? b : a }\\nfunction minPos(a, b) { return cmp(a, b) < 0 ? a : b }\\n\\n// Most of the external API clips given positions to make sure they\\n// actually exist within the document.\\nfunction clipLine(doc, n) {return Math.max(doc.first, Math.min(n, doc.first + doc.size - 1))}\\nfunction clipPos(doc, pos) {\\n  if (pos.line < doc.first) { return Pos(doc.first, 0) }\\n  var last = doc.first + doc.size - 1;\\n  if (pos.line > last) { return Pos(last, getLine(doc, last).text.length) }\\n  return clipToLen(pos, getLine(doc, pos.line).text.length)\\n}\\nfunction clipToLen(pos, linelen) {\\n  var ch = pos.ch;\\n  if (ch == null || ch > linelen) { return Pos(pos.line, linelen) }\\n  else if (ch < 0) { return Pos(pos.line, 0) }\\n  else { return pos }\\n}\\nfunction clipPosArray(doc, array) {\\n  var out = [];\\n  for (var i = 0; i < array.length; i++) { out[i] = clipPos(doc, array[i]); }\\n  return out\\n}\\n\\n// Optimize some code when these features are not used.\\nvar sawReadOnlySpans = false;\\nvar sawCollapsedSpans = false;\\n\\nfunction seeReadOnlySpans() {\\n  sawReadOnlySpans = true;\\n}\\n\\nfunction seeCollapsedSpans() {\\n  sawCollapsedSpans = true;\\n}\\n\\n// TEXTMARKER SPANS\\n\\nfunction MarkedSpan(marker, from, to) {\\n  this.marker = marker;\\n  this.from = from; this.to = to;\\n}\\n\\n// Search an array of spans for a span matching the given marker.\\nfunction getMarkedSpanFor(spans, marker) {\\n  if (spans) { for (var i = 0; i < spans.length; ++i) {\\n    var span = spans[i];\\n    if (span.marker == marker) { return span }\\n  } }\\n}\\n// Remove a span from an array, returning undefined if no spans are\\n// left (we don't store arrays for lines without spans).\\nfunction removeMarkedSpan(spans, span) {\\n  var r;\\n  for (var i = 0; i < spans.length; ++i)\\n    { if (spans[i] != span) { (r || (r = [])).push(spans[i]); } }\\n  return r\\n}\\n// Add a span to a line.\\nfunction addMarkedSpan(line, span) {\\n  line.markedSpans = line.markedSpans ? line.markedSpans.concat([span]) : [span];\\n  span.marker.attachLine(line);\\n}\\n\\n// Used for the algorithm that adjusts markers for a change in the\\n// document. These functions cut an array of spans at a given\\n// character position, returning an array of remaining chunks (or\\n// undefined if nothing remains).\\nfunction markedSpansBefore(old, startCh, isInsert) {\\n  var nw;\\n  if (old) { for (var i = 0; i < old.length; ++i) {\\n    var span = old[i], marker = span.marker;\\n    var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= startCh : span.from < startCh);\\n    if (startsBefore || span.from == startCh && marker.type == \\\"bookmark\\\" && (!isInsert || !span.marker.insertLeft)) {\\n      var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= startCh : span.to > startCh);(nw || (nw = [])).push(new MarkedSpan(marker, span.from, endsAfter ? null : span.to));\\n    }\\n  } }\\n  return nw\\n}\\nfunction markedSpansAfter(old, endCh, isInsert) {\\n  var nw;\\n  if (old) { for (var i = 0; i < old.length; ++i) {\\n    var span = old[i], marker = span.marker;\\n    var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= endCh : span.to > endCh);\\n    if (endsAfter || span.from == endCh && marker.type == \\\"bookmark\\\" && (!isInsert || span.marker.insertLeft)) {\\n      var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= endCh : span.from < endCh);(nw || (nw = [])).push(new MarkedSpan(marker, startsBefore ? null : span.from - endCh,\\n                                            span.to == null ? null : span.to - endCh));\\n    }\\n  } }\\n  return nw\\n}\\n\\n// Given a change object, compute the new set of marker spans that\\n// cover the line in which the change took place. Removes spans\\n// entirely within the change, reconnects spans belonging to the\\n// same marker that appear on both sides of the change, and cuts off\\n// spans partially within the change. Returns an array of span\\n// arrays with one element for each line in (after) the change.\\nfunction stretchSpansOverChange(doc, change) {\\n  if (change.full) { return null }\\n  var oldFirst = isLine(doc, change.from.line) && getLine(doc, change.from.line).markedSpans;\\n  var oldLast = isLine(doc, change.to.line) && getLine(doc, change.to.line).markedSpans;\\n  if (!oldFirst && !oldLast) { return null }\\n\\n  var startCh = change.from.ch, endCh = change.to.ch, isInsert = cmp(change.from, change.to) == 0;\\n  // Get the spans that 'stick out' on both sides\\n  var first = markedSpansBefore(oldFirst, startCh, isInsert);\\n  var last = markedSpansAfter(oldLast, endCh, isInsert);\\n\\n  // Next, merge those two ends\\n  var sameLine = change.text.length == 1, offset = lst(change.text).length + (sameLine ? startCh : 0);\\n  if (first) {\\n    // Fix up .to properties of first\\n    for (var i = 0; i < first.length; ++i) {\\n      var span = first[i];\\n      if (span.to == null) {\\n        var found = getMarkedSpanFor(last, span.marker);\\n        if (!found) { span.to = startCh; }\\n        else if (sameLine) { span.to = found.to == null ? null : found.to + offset; }\\n      }\\n    }\\n  }\\n  if (last) {\\n    // Fix up .from in last (or move them into first in case of sameLine)\\n    for (var i$1 = 0; i$1 < last.length; ++i$1) {\\n      var span$1 = last[i$1];\\n      if (span$1.to != null) { span$1.to += offset; }\\n      if (span$1.from == null) {\\n        var found$1 = getMarkedSpanFor(first, span$1.marker);\\n        if (!found$1) {\\n          span$1.from = offset;\\n          if (sameLine) { (first || (first = [])).push(span$1); }\\n        }\\n      } else {\\n        span$1.from += offset;\\n        if (sameLine) { (first || (first = [])).push(span$1); }\\n      }\\n    }\\n  }\\n  // Make sure we didn't create any zero-length spans\\n  if (first) { first = clearEmptySpans(first); }\\n  if (last && last != first) { last = clearEmptySpans(last); }\\n\\n  var newMarkers = [first];\\n  if (!sameLine) {\\n    // Fill gap with whole-line-spans\\n    var gap = change.text.length - 2, gapMarkers;\\n    if (gap > 0 && first)\\n      { for (var i$2 = 0; i$2 < first.length; ++i$2)\\n        { if (first[i$2].to == null)\\n          { (gapMarkers || (gapMarkers = [])).push(new MarkedSpan(first[i$2].marker, null, null)); } } }\\n    for (var i$3 = 0; i$3 < gap; ++i$3)\\n      { newMarkers.push(gapMarkers); }\\n    newMarkers.push(last);\\n  }\\n  return newMarkers\\n}\\n\\n// Remove spans that are empty and don't have a clearWhenEmpty\\n// option of false.\\nfunction clearEmptySpans(spans) {\\n  for (var i = 0; i < spans.length; ++i) {\\n    var span = spans[i];\\n    if (span.from != null && span.from == span.to && span.marker.clearWhenEmpty !== false)\\n      { spans.splice(i--, 1); }\\n  }\\n  if (!spans.length) { return null }\\n  return spans\\n}\\n\\n// Used to 'clip' out readOnly ranges when making a change.\\nfunction removeReadOnlyRanges(doc, from, to) {\\n  var markers = null;\\n  doc.iter(from.line, to.line + 1, function (line) {\\n    if (line.markedSpans) { for (var i = 0; i < line.markedSpans.length; ++i) {\\n      var mark = line.markedSpans[i].marker;\\n      if (mark.readOnly && (!markers || indexOf(markers, mark) == -1))\\n        { (markers || (markers = [])).push(mark); }\\n    } }\\n  });\\n  if (!markers) { return null }\\n  var parts = [{from: from, to: to}];\\n  for (var i = 0; i < markers.length; ++i) {\\n    var mk = markers[i], m = mk.find(0);\\n    for (var j = 0; j < parts.length; ++j) {\\n      var p = parts[j];\\n      if (cmp(p.to, m.from) < 0 || cmp(p.from, m.to) > 0) { continue }\\n      var newParts = [j, 1], dfrom = cmp(p.from, m.from), dto = cmp(p.to, m.to);\\n      if (dfrom < 0 || !mk.inclusiveLeft && !dfrom)\\n        { newParts.push({from: p.from, to: m.from}); }\\n      if (dto > 0 || !mk.inclusiveRight && !dto)\\n        { newParts.push({from: m.to, to: p.to}); }\\n      parts.splice.apply(parts, newParts);\\n      j += newParts.length - 3;\\n    }\\n  }\\n  return parts\\n}\\n\\n// Connect or disconnect spans from a line.\\nfunction detachMarkedSpans(line) {\\n  var spans = line.markedSpans;\\n  if (!spans) { return }\\n  for (var i = 0; i < spans.length; ++i)\\n    { spans[i].marker.detachLine(line); }\\n  line.markedSpans = null;\\n}\\nfunction attachMarkedSpans(line, spans) {\\n  if (!spans) { return }\\n  for (var i = 0; i < spans.length; ++i)\\n    { spans[i].marker.attachLine(line); }\\n  line.markedSpans = spans;\\n}\\n\\n// Helpers used when computing which overlapping collapsed span\\n// counts as the larger one.\\nfunction extraLeft(marker) { return marker.inclusiveLeft ? -1 : 0 }\\nfunction extraRight(marker) { return marker.inclusiveRight ? 1 : 0 }\\n\\n// Returns a number indicating which of two overlapping collapsed\\n// spans is larger (and thus includes the other). Falls back to\\n// comparing ids when the spans cover exactly the same range.\\nfunction compareCollapsedMarkers(a, b) {\\n  var lenDiff = a.lines.length - b.lines.length;\\n  if (lenDiff != 0) { return lenDiff }\\n  var aPos = a.find(), bPos = b.find();\\n  var fromCmp = cmp(aPos.from, bPos.from) || extraLeft(a) - extraLeft(b);\\n  if (fromCmp) { return -fromCmp }\\n  var toCmp = cmp(aPos.to, bPos.to) || extraRight(a) - extraRight(b);\\n  if (toCmp) { return toCmp }\\n  return b.id - a.id\\n}\\n\\n// Find out whether a line ends or starts in a collapsed span. If\\n// so, return the marker for that span.\\nfunction collapsedSpanAtSide(line, start) {\\n  var sps = sawCollapsedSpans && line.markedSpans, found;\\n  if (sps) { for (var sp = (void 0), i = 0; i < sps.length; ++i) {\\n    sp = sps[i];\\n    if (sp.marker.collapsed && (start ? sp.from : sp.to) == null &&\\n        (!found || compareCollapsedMarkers(found, sp.marker) < 0))\\n      { found = sp.marker; }\\n  } }\\n  return found\\n}\\nfunction collapsedSpanAtStart(line) { return collapsedSpanAtSide(line, true) }\\nfunction collapsedSpanAtEnd(line) { return collapsedSpanAtSide(line, false) }\\n\\n// Test whether there exists a collapsed span that partially\\n// overlaps (covers the start or end, but not both) of a new span.\\n// Such overlap is not allowed.\\nfunction conflictingCollapsedRange(doc, lineNo$$1, from, to, marker) {\\n  var line = getLine(doc, lineNo$$1);\\n  var sps = sawCollapsedSpans && line.markedSpans;\\n  if (sps) { for (var i = 0; i < sps.length; ++i) {\\n    var sp = sps[i];\\n    if (!sp.marker.collapsed) { continue }\\n    var found = sp.marker.find(0);\\n    var fromCmp = cmp(found.from, from) || extraLeft(sp.marker) - extraLeft(marker);\\n    var toCmp = cmp(found.to, to) || extraRight(sp.marker) - extraRight(marker);\\n    if (fromCmp >= 0 && toCmp <= 0 || fromCmp <= 0 && toCmp >= 0) { continue }\\n    if (fromCmp <= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.to, from) >= 0 : cmp(found.to, from) > 0) ||\\n        fromCmp >= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.from, to) <= 0 : cmp(found.from, to) < 0))\\n      { return true }\\n  } }\\n}\\n\\n// A visual line is a line as drawn on the screen. Folding, for\\n// example, can cause multiple logical lines to appear on the same\\n// visual line. This finds the start of the visual line that the\\n// given line is part of (usually that is the line itself).\\nfunction visualLine(line) {\\n  var merged;\\n  while (merged = collapsedSpanAtStart(line))\\n    { line = merged.find(-1, true).line; }\\n  return line\\n}\\n\\nfunction visualLineEnd(line) {\\n  var merged;\\n  while (merged = collapsedSpanAtEnd(line))\\n    { line = merged.find(1, true).line; }\\n  return line\\n}\\n\\n// Returns an array of logical lines that continue the visual line\\n// started by the argument, or undefined if there are no such lines.\\nfunction visualLineContinued(line) {\\n  var merged, lines;\\n  while (merged = collapsedSpanAtEnd(line)) {\\n    line = merged.find(1, true).line\\n    ;(lines || (lines = [])).push(line);\\n  }\\n  return lines\\n}\\n\\n// Get the line number of the start of the visual line that the\\n// given line number is part of.\\nfunction visualLineNo(doc, lineN) {\\n  var line = getLine(doc, lineN), vis = visualLine(line);\\n  if (line == vis) { return lineN }\\n  return lineNo(vis)\\n}\\n\\n// Get the line number of the start of the next visual line after\\n// the given line.\\nfunction visualLineEndNo(doc, lineN) {\\n  if (lineN > doc.lastLine()) { return lineN }\\n  var line = getLine(doc, lineN), merged;\\n  if (!lineIsHidden(doc, line)) { return lineN }\\n  while (merged = collapsedSpanAtEnd(line))\\n    { line = merged.find(1, true).line; }\\n  return lineNo(line) + 1\\n}\\n\\n// Compute whether a line is hidden. Lines count as hidden when they\\n// are part of a visual line that starts with another line, or when\\n// they are entirely covered by collapsed, non-widget span.\\nfunction lineIsHidden(doc, line) {\\n  var sps = sawCollapsedSpans && line.markedSpans;\\n  if (sps) { for (var sp = (void 0), i = 0; i < sps.length; ++i) {\\n    sp = sps[i];\\n    if (!sp.marker.collapsed) { continue }\\n    if (sp.from == null) { return true }\\n    if (sp.marker.widgetNode) { continue }\\n    if (sp.from == 0 && sp.marker.inclusiveLeft && lineIsHiddenInner(doc, line, sp))\\n      { return true }\\n  } }\\n}\\nfunction lineIsHiddenInner(doc, line, span) {\\n  if (span.to == null) {\\n    var end = span.marker.find(1, true);\\n    return lineIsHiddenInner(doc, end.line, getMarkedSpanFor(end.line.markedSpans, span.marker))\\n  }\\n  if (span.marker.inclusiveRight && span.to == line.text.length)\\n    { return true }\\n  for (var sp = (void 0), i = 0; i < line.markedSpans.length; ++i) {\\n    sp = line.markedSpans[i];\\n    if (sp.marker.collapsed && !sp.marker.widgetNode && sp.from == span.to &&\\n        (sp.to == null || sp.to != span.from) &&\\n        (sp.marker.inclusiveLeft || span.marker.inclusiveRight) &&\\n        lineIsHiddenInner(doc, line, sp)) { return true }\\n  }\\n}\\n\\n// Find the height above the given line.\\nfunction heightAtLine(lineObj) {\\n  lineObj = visualLine(lineObj);\\n\\n  var h = 0, chunk = lineObj.parent;\\n  for (var i = 0; i < chunk.lines.length; ++i) {\\n    var line = chunk.lines[i];\\n    if (line == lineObj) { break }\\n    else { h += line.height; }\\n  }\\n  for (var p = chunk.parent; p; chunk = p, p = chunk.parent) {\\n    for (var i$1 = 0; i$1 < p.children.length; ++i$1) {\\n      var cur = p.children[i$1];\\n      if (cur == chunk) { break }\\n      else { h += cur.height; }\\n    }\\n  }\\n  return h\\n}\\n\\n// Compute the character length of a line, taking into account\\n// collapsed ranges (see markText) that might hide parts, and join\\n// other lines onto it.\\nfunction lineLength(line) {\\n  if (line.height == 0) { return 0 }\\n  var len = line.text.length, merged, cur = line;\\n  while (merged = collapsedSpanAtStart(cur)) {\\n    var found = merged.find(0, true);\\n    cur = found.from.line;\\n    len += found.from.ch - found.to.ch;\\n  }\\n  cur = line;\\n  while (merged = collapsedSpanAtEnd(cur)) {\\n    var found$1 = merged.find(0, true);\\n    len -= cur.text.length - found$1.from.ch;\\n    cur = found$1.to.line;\\n    len += cur.text.length - found$1.to.ch;\\n  }\\n  return len\\n}\\n\\n// Find the longest line in the document.\\nfunction findMaxLine(cm) {\\n  var d = cm.display, doc = cm.doc;\\n  d.maxLine = getLine(doc, doc.first);\\n  d.maxLineLength = lineLength(d.maxLine);\\n  d.maxLineChanged = true;\\n  doc.iter(function (line) {\\n    var len = lineLength(line);\\n    if (len > d.maxLineLength) {\\n      d.maxLineLength = len;\\n      d.maxLine = line;\\n    }\\n  });\\n}\\n\\n// BIDI HELPERS\\n\\nfunction iterateBidiSections(order, from, to, f) {\\n  if (!order) { return f(from, to, \\\"ltr\\\") }\\n  var found = false;\\n  for (var i = 0; i < order.length; ++i) {\\n    var part = order[i];\\n    if (part.from < to && part.to > from || from == to && part.to == from) {\\n      f(Math.max(part.from, from), Math.min(part.to, to), part.level == 1 ? \\\"rtl\\\" : \\\"ltr\\\");\\n      found = true;\\n    }\\n  }\\n  if (!found) { f(from, to, \\\"ltr\\\"); }\\n}\\n\\nvar bidiOther = null;\\nfunction getBidiPartAt(order, ch, sticky) {\\n  var found;\\n  bidiOther = null;\\n  for (var i = 0; i < order.length; ++i) {\\n    var cur = order[i];\\n    if (cur.from < ch && cur.to > ch) { return i }\\n    if (cur.to == ch) {\\n      if (cur.from != cur.to && sticky == \\\"before\\\") { found = i; }\\n      else { bidiOther = i; }\\n    }\\n    if (cur.from == ch) {\\n      if (cur.from != cur.to && sticky != \\\"before\\\") { found = i; }\\n      else { bidiOther = i; }\\n    }\\n  }\\n  return found != null ? found : bidiOther\\n}\\n\\n// Bidirectional ordering algorithm\\n// See http://unicode.org/reports/tr9/tr9-13.html for the algorithm\\n// that this (partially) implements.\\n\\n// One-char codes used for character types:\\n// L (L):   Left-to-Right\\n// R (R):   Right-to-Left\\n// r (AL):  Right-to-Left Arabic\\n// 1 (EN):  European Number\\n// + (ES):  European Number Separator\\n// % (ET):  European Number Terminator\\n// n (AN):  Arabic Number\\n// , (CS):  Common Number Separator\\n// m (NSM): Non-Spacing Mark\\n// b (BN):  Boundary Neutral\\n// s (B):   Paragraph Separator\\n// t (S):   Segment Separator\\n// w (WS):  Whitespace\\n// N (ON):  Other Neutrals\\n\\n// Returns null if characters are ordered as they appear\\n// (left-to-right), or an array of sections ({from, to, level}\\n// objects) in the order in which they occur visually.\\nvar bidiOrdering = (function() {\\n  // Character types for codepoints 0 to 0xff\\n  var lowTypes = \\\"bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN\\\";\\n  // Character types for codepoints 0x600 to 0x6f9\\n  var arabicTypes = \\\"nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111\\\";\\n  function charType(code) {\\n    if (code <= 0xf7) { return lowTypes.charAt(code) }\\n    else if (0x590 <= code && code <= 0x5f4) { return \\\"R\\\" }\\n    else if (0x600 <= code && code <= 0x6f9) { return arabicTypes.charAt(code - 0x600) }\\n    else if (0x6ee <= code && code <= 0x8ac) { return \\\"r\\\" }\\n    else if (0x2000 <= code && code <= 0x200b) { return \\\"w\\\" }\\n    else if (code == 0x200c) { return \\\"b\\\" }\\n    else { return \\\"L\\\" }\\n  }\\n\\n  var bidiRE = /[\\\\u0590-\\\\u05f4\\\\u0600-\\\\u06ff\\\\u0700-\\\\u08ac]/;\\n  var isNeutral = /[stwN]/, isStrong = /[LRr]/, countsAsLeft = /[Lb1n]/, countsAsNum = /[1n]/;\\n\\n  function BidiSpan(level, from, to) {\\n    this.level = level;\\n    this.from = from; this.to = to;\\n  }\\n\\n  return function(str, direction) {\\n    var outerType = direction == \\\"ltr\\\" ? \\\"L\\\" : \\\"R\\\";\\n\\n    if (str.length == 0 || direction == \\\"ltr\\\" && !bidiRE.test(str)) { return false }\\n    var len = str.length, types = [];\\n    for (var i = 0; i < len; ++i)\\n      { types.push(charType(str.charCodeAt(i))); }\\n\\n    // W1. Examine each non-spacing mark (NSM) in the level run, and\\n    // change the type of the NSM to the type of the previous\\n    // character. If the NSM is at the start of the level run, it will\\n    // get the type of sor.\\n    for (var i$1 = 0, prev = outerType; i$1 < len; ++i$1) {\\n      var type = types[i$1];\\n      if (type == \\\"m\\\") { types[i$1] = prev; }\\n      else { prev = type; }\\n    }\\n\\n    // W2. Search backwards from each instance of a European number\\n    // until the first strong type (R, L, AL, or sor) is found. If an\\n    // AL is found, change the type of the European number to Arabic\\n    // number.\\n    // W3. Change all ALs to R.\\n    for (var i$2 = 0, cur = outerType; i$2 < len; ++i$2) {\\n      var type$1 = types[i$2];\\n      if (type$1 == \\\"1\\\" && cur == \\\"r\\\") { types[i$2] = \\\"n\\\"; }\\n      else if (isStrong.test(type$1)) { cur = type$1; if (type$1 == \\\"r\\\") { types[i$2] = \\\"R\\\"; } }\\n    }\\n\\n    // W4. A single European separator between two European numbers\\n    // changes to a European number. A single common separator between\\n    // two numbers of the same type changes to that type.\\n    for (var i$3 = 1, prev$1 = types[0]; i$3 < len - 1; ++i$3) {\\n      var type$2 = types[i$3];\\n      if (type$2 == \\\"+\\\" && prev$1 == \\\"1\\\" && types[i$3+1] == \\\"1\\\") { types[i$3] = \\\"1\\\"; }\\n      else if (type$2 == \\\",\\\" && prev$1 == types[i$3+1] &&\\n               (prev$1 == \\\"1\\\" || prev$1 == \\\"n\\\")) { types[i$3] = prev$1; }\\n      prev$1 = type$2;\\n    }\\n\\n    // W5. A sequence of European terminators adjacent to European\\n    // numbers changes to all European numbers.\\n    // W6. Otherwise, separators and terminators change to Other\\n    // Neutral.\\n    for (var i$4 = 0; i$4 < len; ++i$4) {\\n      var type$3 = types[i$4];\\n      if (type$3 == \\\",\\\") { types[i$4] = \\\"N\\\"; }\\n      else if (type$3 == \\\"%\\\") {\\n        var end = (void 0);\\n        for (end = i$4 + 1; end < len && types[end] == \\\"%\\\"; ++end) {}\\n        var replace = (i$4 && types[i$4-1] == \\\"!\\\") || (end < len && types[end] == \\\"1\\\") ? \\\"1\\\" : \\\"N\\\";\\n        for (var j = i$4; j < end; ++j) { types[j] = replace; }\\n        i$4 = end - 1;\\n      }\\n    }\\n\\n    // W7. Search backwards from each instance of a European number\\n    // until the first strong type (R, L, or sor) is found. If an L is\\n    // found, then change the type of the European number to L.\\n    for (var i$5 = 0, cur$1 = outerType; i$5 < len; ++i$5) {\\n      var type$4 = types[i$5];\\n      if (cur$1 == \\\"L\\\" && type$4 == \\\"1\\\") { types[i$5] = \\\"L\\\"; }\\n      else if (isStrong.test(type$4)) { cur$1 = type$4; }\\n    }\\n\\n    // N1. A sequence of neutrals takes the direction of the\\n    // surrounding strong text if the text on both sides has the same\\n    // direction. European and Arabic numbers act as if they were R in\\n    // terms of their influence on neutrals. Start-of-level-run (sor)\\n    // and end-of-level-run (eor) are used at level run boundaries.\\n    // N2. Any remaining neutrals take the embedding direction.\\n    for (var i$6 = 0; i$6 < len; ++i$6) {\\n      if (isNeutral.test(types[i$6])) {\\n        var end$1 = (void 0);\\n        for (end$1 = i$6 + 1; end$1 < len && isNeutral.test(types[end$1]); ++end$1) {}\\n        var before = (i$6 ? types[i$6-1] : outerType) == \\\"L\\\";\\n        var after = (end$1 < len ? types[end$1] : outerType) == \\\"L\\\";\\n        var replace$1 = before == after ? (before ? \\\"L\\\" : \\\"R\\\") : outerType;\\n        for (var j$1 = i$6; j$1 < end$1; ++j$1) { types[j$1] = replace$1; }\\n        i$6 = end$1 - 1;\\n      }\\n    }\\n\\n    // Here we depart from the documented algorithm, in order to avoid\\n    // building up an actual levels array. Since there are only three\\n    // levels (0, 1, 2) in an implementation that doesn't take\\n    // explicit embedding into account, we can build up the order on\\n    // the fly, without following the level-based algorithm.\\n    var order = [], m;\\n    for (var i$7 = 0; i$7 < len;) {\\n      if (countsAsLeft.test(types[i$7])) {\\n        var start = i$7;\\n        for (++i$7; i$7 < len && countsAsLeft.test(types[i$7]); ++i$7) {}\\n        order.push(new BidiSpan(0, start, i$7));\\n      } else {\\n        var pos = i$7, at = order.length;\\n        for (++i$7; i$7 < len && types[i$7] != \\\"L\\\"; ++i$7) {}\\n        for (var j$2 = pos; j$2 < i$7;) {\\n          if (countsAsNum.test(types[j$2])) {\\n            if (pos < j$2) { order.splice(at, 0, new BidiSpan(1, pos, j$2)); }\\n            var nstart = j$2;\\n            for (++j$2; j$2 < i$7 && countsAsNum.test(types[j$2]); ++j$2) {}\\n            order.splice(at, 0, new BidiSpan(2, nstart, j$2));\\n            pos = j$2;\\n          } else { ++j$2; }\\n        }\\n        if (pos < i$7) { order.splice(at, 0, new BidiSpan(1, pos, i$7)); }\\n      }\\n    }\\n    if (order[0].level == 1 && (m = str.match(/^\\\\s+/))) {\\n      order[0].from = m[0].length;\\n      order.unshift(new BidiSpan(0, 0, m[0].length));\\n    }\\n    if (lst(order).level == 1 && (m = str.match(/\\\\s+$/))) {\\n      lst(order).to -= m[0].length;\\n      order.push(new BidiSpan(0, len - m[0].length, len));\\n    }\\n\\n    return direction == \\\"rtl\\\" ? order.reverse() : order\\n  }\\n})();\\n\\n// Get the bidi ordering for the given line (and cache it). Returns\\n// false for lines that are fully left-to-right, and an array of\\n// BidiSpan objects otherwise.\\nfunction getOrder(line, direction) {\\n  var order = line.order;\\n  if (order == null) { order = line.order = bidiOrdering(line.text, direction); }\\n  return order\\n}\\n\\nfunction moveCharLogically(line, ch, dir) {\\n  var target = skipExtendingChars(line.text, ch + dir, dir);\\n  return target < 0 || target > line.text.length ? null : target\\n}\\n\\nfunction moveLogically(line, start, dir) {\\n  var ch = moveCharLogically(line, start.ch, dir);\\n  return ch == null ? null : new Pos(start.line, ch, dir < 0 ? \\\"after\\\" : \\\"before\\\")\\n}\\n\\nfunction endOfLine(visually, cm, lineObj, lineNo, dir) {\\n  if (visually) {\\n    var order = getOrder(lineObj, cm.doc.direction);\\n    if (order) {\\n      var part = dir < 0 ? lst(order) : order[0];\\n      var moveInStorageOrder = (dir < 0) == (part.level == 1);\\n      var sticky = moveInStorageOrder ? \\\"after\\\" : \\\"before\\\";\\n      var ch;\\n      // With a wrapped rtl chunk (possibly spanning multiple bidi parts),\\n      // it could be that the last bidi part is not on the last visual line,\\n      // since visual lines contain content order-consecutive chunks.\\n      // Thus, in rtl, we are looking for the first (content-order) character\\n      // in the rtl chunk that is on the last line (that is, the same line\\n      // as the last (content-order) character).\\n      if (part.level > 0) {\\n        var prep = prepareMeasureForLine(cm, lineObj);\\n        ch = dir < 0 ? lineObj.text.length - 1 : 0;\\n        var targetTop = measureCharPrepared(cm, prep, ch).top;\\n        ch = findFirst(function (ch) { return measureCharPrepared(cm, prep, ch).top == targetTop; }, (dir < 0) == (part.level == 1) ? part.from : part.to - 1, ch);\\n        if (sticky == \\\"before\\\") { ch = moveCharLogically(lineObj, ch, 1, true); }\\n      } else { ch = dir < 0 ? part.to : part.from; }\\n      return new Pos(lineNo, ch, sticky)\\n    }\\n  }\\n  return new Pos(lineNo, dir < 0 ? lineObj.text.length : 0, dir < 0 ? \\\"before\\\" : \\\"after\\\")\\n}\\n\\nfunction moveVisually(cm, line, start, dir) {\\n  var bidi = getOrder(line, cm.doc.direction);\\n  if (!bidi) { return moveLogically(line, start, dir) }\\n  if (start.ch >= line.text.length) {\\n    start.ch = line.text.length;\\n    start.sticky = \\\"before\\\";\\n  } else if (start.ch <= 0) {\\n    start.ch = 0;\\n    start.sticky = \\\"after\\\";\\n  }\\n  var partPos = getBidiPartAt(bidi, start.ch, start.sticky), part = bidi[partPos];\\n  if (cm.doc.direction == \\\"ltr\\\" && part.level % 2 == 0 && (dir > 0 ? part.to > start.ch : part.from < start.ch)) {\\n    // Case 1: We move within an ltr part in an ltr editor. Even with wrapped lines,\\n    // nothing interesting happens.\\n    return moveLogically(line, start, dir)\\n  }\\n\\n  var mv = function (pos, dir) { return moveCharLogically(line, pos instanceof Pos ? pos.ch : pos, dir); };\\n  var prep;\\n  var getWrappedLineExtent = function (ch) {\\n    if (!cm.options.lineWrapping) { return {begin: 0, end: line.text.length} }\\n    prep = prep || prepareMeasureForLine(cm, line);\\n    return wrappedLineExtentChar(cm, line, prep, ch)\\n  };\\n  var wrappedLineExtent = getWrappedLineExtent(start.sticky == \\\"before\\\" ? mv(start, -1) : start.ch);\\n\\n  if (cm.doc.direction == \\\"rtl\\\" || part.level == 1) {\\n    var moveInStorageOrder = (part.level == 1) == (dir < 0);\\n    var ch = mv(start, moveInStorageOrder ? 1 : -1);\\n    if (ch != null && (!moveInStorageOrder ? ch >= part.from && ch >= wrappedLineExtent.begin : ch <= part.to && ch <= wrappedLineExtent.end)) {\\n      // Case 2: We move within an rtl part or in an rtl editor on the same visual line\\n      var sticky = moveInStorageOrder ? \\\"before\\\" : \\\"after\\\";\\n      return new Pos(start.line, ch, sticky)\\n    }\\n  }\\n\\n  // Case 3: Could not move within this bidi part in this visual line, so leave\\n  // the current bidi part\\n\\n  var searchInVisualLine = function (partPos, dir, wrappedLineExtent) {\\n    var getRes = function (ch, moveInStorageOrder) { return moveInStorageOrder\\n      ? new Pos(start.line, mv(ch, 1), \\\"before\\\")\\n      : new Pos(start.line, ch, \\\"after\\\"); };\\n\\n    for (; partPos >= 0 && partPos < bidi.length; partPos += dir) {\\n      var part = bidi[partPos];\\n      var moveInStorageOrder = (dir > 0) == (part.level != 1);\\n      var ch = moveInStorageOrder ? wrappedLineExtent.begin : mv(wrappedLineExtent.end, -1);\\n      if (part.from <= ch && ch < part.to) { return getRes(ch, moveInStorageOrder) }\\n      ch = moveInStorageOrder ? part.from : mv(part.to, -1);\\n      if (wrappedLineExtent.begin <= ch && ch < wrappedLineExtent.end) { return getRes(ch, moveInStorageOrder) }\\n    }\\n  };\\n\\n  // Case 3a: Look for other bidi parts on the same visual line\\n  var res = searchInVisualLine(partPos + dir, dir, wrappedLineExtent);\\n  if (res) { return res }\\n\\n  // Case 3b: Look for other bidi parts on the next visual line\\n  var nextCh = dir > 0 ? wrappedLineExtent.end : mv(wrappedLineExtent.begin, -1);\\n  if (nextCh != null && !(dir > 0 && nextCh == line.text.length)) {\\n    res = searchInVisualLine(dir > 0 ? 0 : bidi.length - 1, dir, getWrappedLineExtent(nextCh));\\n    if (res) { return res }\\n  }\\n\\n  // Case 4: Nowhere to move\\n  return null\\n}\\n\\n// EVENT HANDLING\\n\\n// Lightweight event framework. on/off also work on DOM nodes,\\n// registering native DOM handlers.\\n\\nvar noHandlers = [];\\n\\nvar on = function(emitter, type, f) {\\n  if (emitter.addEventListener) {\\n    emitter.addEventListener(type, f, false);\\n  } else if (emitter.attachEvent) {\\n    emitter.attachEvent(\\\"on\\\" + type, f);\\n  } else {\\n    var map$$1 = emitter._handlers || (emitter._handlers = {});\\n    map$$1[type] = (map$$1[type] || noHandlers).concat(f);\\n  }\\n};\\n\\nfunction getHandlers(emitter, type) {\\n  return emitter._handlers && emitter._handlers[type] || noHandlers\\n}\\n\\nfunction off(emitter, type, f) {\\n  if (emitter.removeEventListener) {\\n    emitter.removeEventListener(type, f, false);\\n  } else if (emitter.detachEvent) {\\n    emitter.detachEvent(\\\"on\\\" + type, f);\\n  } else {\\n    var map$$1 = emitter._handlers, arr = map$$1 && map$$1[type];\\n    if (arr) {\\n      var index = indexOf(arr, f);\\n      if (index > -1)\\n        { map$$1[type] = arr.slice(0, index).concat(arr.slice(index + 1)); }\\n    }\\n  }\\n}\\n\\nfunction signal(emitter, type /*, values...*/) {\\n  var handlers = getHandlers(emitter, type);\\n  if (!handlers.length) { return }\\n  var args = Array.prototype.slice.call(arguments, 2);\\n  for (var i = 0; i < handlers.length; ++i) { handlers[i].apply(null, args); }\\n}\\n\\n// The DOM events that CodeMirror handles can be overridden by\\n// registering a (non-DOM) handler on the editor for the event name,\\n// and preventDefault-ing the event in that handler.\\nfunction signalDOMEvent(cm, e, override) {\\n  if (typeof e == \\\"string\\\")\\n    { e = {type: e, preventDefault: function() { this.defaultPrevented = true; }}; }\\n  signal(cm, override || e.type, cm, e);\\n  return e_defaultPrevented(e) || e.codemirrorIgnore\\n}\\n\\nfunction signalCursorActivity(cm) {\\n  var arr = cm._handlers && cm._handlers.cursorActivity;\\n  if (!arr) { return }\\n  var set = cm.curOp.cursorActivityHandlers || (cm.curOp.cursorActivityHandlers = []);\\n  for (var i = 0; i < arr.length; ++i) { if (indexOf(set, arr[i]) == -1)\\n    { set.push(arr[i]); } }\\n}\\n\\nfunction hasHandler(emitter, type) {\\n  return getHandlers(emitter, type).length > 0\\n}\\n\\n// Add on and off methods to a constructor's prototype, to make\\n// registering events on such objects more convenient.\\nfunction eventMixin(ctor) {\\n  ctor.prototype.on = function(type, f) {on(this, type, f);};\\n  ctor.prototype.off = function(type, f) {off(this, type, f);};\\n}\\n\\n// Due to the fact that we still support jurassic IE versions, some\\n// compatibility wrappers are needed.\\n\\nfunction e_preventDefault(e) {\\n  if (e.preventDefault) { e.preventDefault(); }\\n  else { e.returnValue = false; }\\n}\\nfunction e_stopPropagation(e) {\\n  if (e.stopPropagation) { e.stopPropagation(); }\\n  else { e.cancelBubble = true; }\\n}\\nfunction e_defaultPrevented(e) {\\n  return e.defaultPrevented != null ? e.defaultPrevented : e.returnValue == false\\n}\\nfunction e_stop(e) {e_preventDefault(e); e_stopPropagation(e);}\\n\\nfunction e_target(e) {return e.target || e.srcElement}\\nfunction e_button(e) {\\n  var b = e.which;\\n  if (b == null) {\\n    if (e.button & 1) { b = 1; }\\n    else if (e.button & 2) { b = 3; }\\n    else if (e.button & 4) { b = 2; }\\n  }\\n  if (mac && e.ctrlKey && b == 1) { b = 3; }\\n  return b\\n}\\n\\n// Detect drag-and-drop\\nvar dragAndDrop = function() {\\n  // There is *some* kind of drag-and-drop support in IE6-8, but I\\n  // couldn't get it to work yet.\\n  if (ie && ie_version < 9) { return false }\\n  var div = elt('div');\\n  return \\\"draggable\\\" in div || \\\"dragDrop\\\" in div\\n}();\\n\\nvar zwspSupported;\\nfunction zeroWidthElement(measure) {\\n  if (zwspSupported == null) {\\n    var test = elt(\\\"span\\\", \\\"\\\\u200b\\\");\\n    removeChildrenAndAdd(measure, elt(\\\"span\\\", [test, document.createTextNode(\\\"x\\\")]));\\n    if (measure.firstChild.offsetHeight != 0)\\n      { zwspSupported = test.offsetWidth <= 1 && test.offsetHeight > 2 && !(ie && ie_version < 8); }\\n  }\\n  var node = zwspSupported ? elt(\\\"span\\\", \\\"\\\\u200b\\\") :\\n    elt(\\\"span\\\", \\\"\\\\u00a0\\\", null, \\\"display: inline-block; width: 1px; margin-right: -1px\\\");\\n  node.setAttribute(\\\"cm-text\\\", \\\"\\\");\\n  return node\\n}\\n\\n// Feature-detect IE's crummy client rect reporting for bidi text\\nvar badBidiRects;\\nfunction hasBadBidiRects(measure) {\\n  if (badBidiRects != null) { return badBidiRects }\\n  var txt = removeChildrenAndAdd(measure, document.createTextNode(\\\"A\\\\u062eA\\\"));\\n  var r0 = range(txt, 0, 1).getBoundingClientRect();\\n  var r1 = range(txt, 1, 2).getBoundingClientRect();\\n  removeChildren(measure);\\n  if (!r0 || r0.left == r0.right) { return false } // Safari returns null in some cases (#2780)\\n  return badBidiRects = (r1.right - r0.right < 3)\\n}\\n\\n// See if \\\"\\\".split is the broken IE version, if so, provide an\\n// alternative way to split lines.\\nvar splitLinesAuto = \\\"\\\\n\\\\nb\\\".split(/\\\\n/).length != 3 ? function (string) {\\n  var pos = 0, result = [], l = string.length;\\n  while (pos <= l) {\\n    var nl = string.indexOf(\\\"\\\\n\\\", pos);\\n    if (nl == -1) { nl = string.length; }\\n    var line = string.slice(pos, string.charAt(nl - 1) == \\\"\\\\r\\\" ? nl - 1 : nl);\\n    var rt = line.indexOf(\\\"\\\\r\\\");\\n    if (rt != -1) {\\n      result.push(line.slice(0, rt));\\n      pos += rt + 1;\\n    } else {\\n      result.push(line);\\n      pos = nl + 1;\\n    }\\n  }\\n  return result\\n} : function (string) { return string.split(/\\\\r\\\\n?|\\\\n/); };\\n\\nvar hasSelection = window.getSelection ? function (te) {\\n  try { return te.selectionStart != te.selectionEnd }\\n  catch(e) { return false }\\n} : function (te) {\\n  var range$$1;\\n  try {range$$1 = te.ownerDocument.selection.createRange();}\\n  catch(e) {}\\n  if (!range$$1 || range$$1.parentElement() != te) { return false }\\n  return range$$1.compareEndPoints(\\\"StartToEnd\\\", range$$1) != 0\\n};\\n\\nvar hasCopyEvent = (function () {\\n  var e = elt(\\\"div\\\");\\n  if (\\\"oncopy\\\" in e) { return true }\\n  e.setAttribute(\\\"oncopy\\\", \\\"return;\\\");\\n  return typeof e.oncopy == \\\"function\\\"\\n})();\\n\\nvar badZoomedRects = null;\\nfunction hasBadZoomedRects(measure) {\\n  if (badZoomedRects != null) { return badZoomedRects }\\n  var node = removeChildrenAndAdd(measure, elt(\\\"span\\\", \\\"x\\\"));\\n  var normal = node.getBoundingClientRect();\\n  var fromRange = range(node, 0, 1).getBoundingClientRect();\\n  return badZoomedRects = Math.abs(normal.left - fromRange.left) > 1\\n}\\n\\n// Known modes, by name and by MIME\\nvar modes = {};\\nvar mimeModes = {};\\n\\n// Extra arguments are stored as the mode's dependencies, which is\\n// used by (legacy) mechanisms like loadmode.js to automatically\\n// load a mode. (Preferred mechanism is the require/define calls.)\\nfunction defineMode(name, mode) {\\n  if (arguments.length > 2)\\n    { mode.dependencies = Array.prototype.slice.call(arguments, 2); }\\n  modes[name] = mode;\\n}\\n\\nfunction defineMIME(mime, spec) {\\n  mimeModes[mime] = spec;\\n}\\n\\n// Given a MIME type, a {name, ...options} config object, or a name\\n// string, return a mode config object.\\nfunction resolveMode(spec) {\\n  if (typeof spec == \\\"string\\\" && mimeModes.hasOwnProperty(spec)) {\\n    spec = mimeModes[spec];\\n  } else if (spec && typeof spec.name == \\\"string\\\" && mimeModes.hasOwnProperty(spec.name)) {\\n    var found = mimeModes[spec.name];\\n    if (typeof found == \\\"string\\\") { found = {name: found}; }\\n    spec = createObj(found, spec);\\n    spec.name = found.name;\\n  } else if (typeof spec == \\\"string\\\" && /^[\\\\w\\\\-]+\\\\/[\\\\w\\\\-]+\\\\+xml$/.test(spec)) {\\n    return resolveMode(\\\"application/xml\\\")\\n  } else if (typeof spec == \\\"string\\\" && /^[\\\\w\\\\-]+\\\\/[\\\\w\\\\-]+\\\\+json$/.test(spec)) {\\n    return resolveMode(\\\"application/json\\\")\\n  }\\n  if (typeof spec == \\\"string\\\") { return {name: spec} }\\n  else { return spec || {name: \\\"null\\\"} }\\n}\\n\\n// Given a mode spec (anything that resolveMode accepts), find and\\n// initialize an actual mode object.\\nfunction getMode(options, spec) {\\n  spec = resolveMode(spec);\\n  var mfactory = modes[spec.name];\\n  if (!mfactory) { return getMode(options, \\\"text/plain\\\") }\\n  var modeObj = mfactory(options, spec);\\n  if (modeExtensions.hasOwnProperty(spec.name)) {\\n    var exts = modeExtensions[spec.name];\\n    for (var prop in exts) {\\n      if (!exts.hasOwnProperty(prop)) { continue }\\n      if (modeObj.hasOwnProperty(prop)) { modeObj[\\\"_\\\" + prop] = modeObj[prop]; }\\n      modeObj[prop] = exts[prop];\\n    }\\n  }\\n  modeObj.name = spec.name;\\n  if (spec.helperType) { modeObj.helperType = spec.helperType; }\\n  if (spec.modeProps) { for (var prop$1 in spec.modeProps)\\n    { modeObj[prop$1] = spec.modeProps[prop$1]; } }\\n\\n  return modeObj\\n}\\n\\n// This can be used to attach properties to mode objects from\\n// outside the actual mode definition.\\nvar modeExtensions = {};\\nfunction extendMode(mode, properties) {\\n  var exts = modeExtensions.hasOwnProperty(mode) ? modeExtensions[mode] : (modeExtensions[mode] = {});\\n  copyObj(properties, exts);\\n}\\n\\nfunction copyState(mode, state) {\\n  if (state === true) { return state }\\n  if (mode.copyState) { return mode.copyState(state) }\\n  var nstate = {};\\n  for (var n in state) {\\n    var val = state[n];\\n    if (val instanceof Array) { val = val.concat([]); }\\n    nstate[n] = val;\\n  }\\n  return nstate\\n}\\n\\n// Given a mode and a state (for that mode), find the inner mode and\\n// state at the position that the state refers to.\\nfunction innerMode(mode, state) {\\n  var info;\\n  while (mode.innerMode) {\\n    info = mode.innerMode(state);\\n    if (!info || info.mode == mode) { break }\\n    state = info.state;\\n    mode = info.mode;\\n  }\\n  return info || {mode: mode, state: state}\\n}\\n\\nfunction startState(mode, a1, a2) {\\n  return mode.startState ? mode.startState(a1, a2) : true\\n}\\n\\n// STRING STREAM\\n\\n// Fed to the mode parsers, provides helper functions to make\\n// parsers more succinct.\\n\\nvar StringStream = function(string, tabSize) {\\n  this.pos = this.start = 0;\\n  this.string = string;\\n  this.tabSize = tabSize || 8;\\n  this.lastColumnPos = this.lastColumnValue = 0;\\n  this.lineStart = 0;\\n};\\n\\nStringStream.prototype.eol = function () {return this.pos >= this.string.length};\\nStringStream.prototype.sol = function () {return this.pos == this.lineStart};\\nStringStream.prototype.peek = function () {return this.string.charAt(this.pos) || undefined};\\nStringStream.prototype.next = function () {\\n  if (this.pos < this.string.length)\\n    { return this.string.charAt(this.pos++) }\\n};\\nStringStream.prototype.eat = function (match) {\\n  var ch = this.string.charAt(this.pos);\\n  var ok;\\n  if (typeof match == \\\"string\\\") { ok = ch == match; }\\n  else { ok = ch && (match.test ? match.test(ch) : match(ch)); }\\n  if (ok) {++this.pos; return ch}\\n};\\nStringStream.prototype.eatWhile = function (match) {\\n  var start = this.pos;\\n  while (this.eat(match)){}\\n  return this.pos > start\\n};\\nStringStream.prototype.eatSpace = function () {\\n    var this$1 = this;\\n\\n  var start = this.pos;\\n  while (/[\\\\s\\\\u00a0]/.test(this.string.charAt(this.pos))) { ++this$1.pos; }\\n  return this.pos > start\\n};\\nStringStream.prototype.skipToEnd = function () {this.pos = this.string.length;};\\nStringStream.prototype.skipTo = function (ch) {\\n  var found = this.string.indexOf(ch, this.pos);\\n  if (found > -1) {this.pos = found; return true}\\n};\\nStringStream.prototype.backUp = function (n) {this.pos -= n;};\\nStringStream.prototype.column = function () {\\n  if (this.lastColumnPos < this.start) {\\n    this.lastColumnValue = countColumn(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);\\n    this.lastColumnPos = this.start;\\n  }\\n  return this.lastColumnValue - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0)\\n};\\nStringStream.prototype.indentation = function () {\\n  return countColumn(this.string, null, this.tabSize) -\\n    (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0)\\n};\\nStringStream.prototype.match = function (pattern, consume, caseInsensitive) {\\n  if (typeof pattern == \\\"string\\\") {\\n    var cased = function (str) { return caseInsensitive ? str.toLowerCase() : str; };\\n    var substr = this.string.substr(this.pos, pattern.length);\\n    if (cased(substr) == cased(pattern)) {\\n      if (consume !== false) { this.pos += pattern.length; }\\n      return true\\n    }\\n  } else {\\n    var match = this.string.slice(this.pos).match(pattern);\\n    if (match && match.index > 0) { return null }\\n    if (match && consume !== false) { this.pos += match[0].length; }\\n    return match\\n  }\\n};\\nStringStream.prototype.current = function (){return this.string.slice(this.start, this.pos)};\\nStringStream.prototype.hideFirstChars = function (n, inner) {\\n  this.lineStart += n;\\n  try { return inner() }\\n  finally { this.lineStart -= n; }\\n};\\n\\n// Compute a style array (an array starting with a mode generation\\n// -- for invalidation -- followed by pairs of end positions and\\n// style strings), which is used to highlight the tokens on the\\n// line.\\nfunction highlightLine(cm, line, state, forceToEnd) {\\n  // A styles array always starts with a number identifying the\\n  // mode/overlays that it is based on (for easy invalidation).\\n  var st = [cm.state.modeGen], lineClasses = {};\\n  // Compute the base array of styles\\n  runMode(cm, line.text, cm.doc.mode, state, function (end, style) { return st.push(end, style); },\\n    lineClasses, forceToEnd);\\n\\n  // Run overlays, adjust style array.\\n  var loop = function ( o ) {\\n    var overlay = cm.state.overlays[o], i = 1, at = 0;\\n    runMode(cm, line.text, overlay.mode, true, function (end, style) {\\n      var start = i;\\n      // Ensure there's a token end at the current position, and that i points at it\\n      while (at < end) {\\n        var i_end = st[i];\\n        if (i_end > end)\\n          { st.splice(i, 1, end, st[i+1], i_end); }\\n        i += 2;\\n        at = Math.min(end, i_end);\\n      }\\n      if (!style) { return }\\n      if (overlay.opaque) {\\n        st.splice(start, i - start, end, \\\"overlay \\\" + style);\\n        i = start + 2;\\n      } else {\\n        for (; start < i; start += 2) {\\n          var cur = st[start+1];\\n          st[start+1] = (cur ? cur + \\\" \\\" : \\\"\\\") + \\\"overlay \\\" + style;\\n        }\\n      }\\n    }, lineClasses);\\n  };\\n\\n  for (var o = 0; o < cm.state.overlays.length; ++o) loop( o );\\n\\n  return {styles: st, classes: lineClasses.bgClass || lineClasses.textClass ? lineClasses : null}\\n}\\n\\nfunction getLineStyles(cm, line, updateFrontier) {\\n  if (!line.styles || line.styles[0] != cm.state.modeGen) {\\n    var state = getStateBefore(cm, lineNo(line));\\n    var result = highlightLine(cm, line, line.text.length > cm.options.maxHighlightLength ? copyState(cm.doc.mode, state) : state);\\n    line.stateAfter = state;\\n    line.styles = result.styles;\\n    if (result.classes) { line.styleClasses = result.classes; }\\n    else if (line.styleClasses) { line.styleClasses = null; }\\n    if (updateFrontier === cm.doc.frontier) { cm.doc.frontier++; }\\n  }\\n  return line.styles\\n}\\n\\nfunction getStateBefore(cm, n, precise) {\\n  var doc = cm.doc, display = cm.display;\\n  if (!doc.mode.startState) { return true }\\n  var pos = findStartLine(cm, n, precise), state = pos > doc.first && getLine(doc, pos-1).stateAfter;\\n  if (!state) { state = startState(doc.mode); }\\n  else { state = copyState(doc.mode, state); }\\n  doc.iter(pos, n, function (line) {\\n    processLine(cm, line.text, state);\\n    var save = pos == n - 1 || pos % 5 == 0 || pos >= display.viewFrom && pos < display.viewTo;\\n    line.stateAfter = save ? copyState(doc.mode, state) : null;\\n    ++pos;\\n  });\\n  if (precise) { doc.frontier = pos; }\\n  return state\\n}\\n\\n// Lightweight form of highlight -- proceed over this line and\\n// update state, but don't save a style array. Used for lines that\\n// aren't currently visible.\\nfunction processLine(cm, text, state, startAt) {\\n  var mode = cm.doc.mode;\\n  var stream = new StringStream(text, cm.options.tabSize);\\n  stream.start = stream.pos = startAt || 0;\\n  if (text == \\\"\\\") { callBlankLine(mode, state); }\\n  while (!stream.eol()) {\\n    readToken(mode, stream, state);\\n    stream.start = stream.pos;\\n  }\\n}\\n\\nfunction callBlankLine(mode, state) {\\n  if (mode.blankLine) { return mode.blankLine(state) }\\n  if (!mode.innerMode) { return }\\n  var inner = innerMode(mode, state);\\n  if (inner.mode.blankLine) { return inner.mode.blankLine(inner.state) }\\n}\\n\\nfunction readToken(mode, stream, state, inner) {\\n  for (var i = 0; i < 10; i++) {\\n    if (inner) { inner[0] = innerMode(mode, state).mode; }\\n    var style = mode.token(stream, state);\\n    if (stream.pos > stream.start) { return style }\\n  }\\n  throw new Error(\\\"Mode \\\" + mode.name + \\\" failed to advance stream.\\\")\\n}\\n\\n// Utility for getTokenAt and getLineTokens\\nfunction takeToken(cm, pos, precise, asArray) {\\n  var getObj = function (copy) { return ({\\n    start: stream.start, end: stream.pos,\\n    string: stream.current(),\\n    type: style || null,\\n    state: copy ? copyState(doc.mode, state) : state\\n  }); };\\n\\n  var doc = cm.doc, mode = doc.mode, style;\\n  pos = clipPos(doc, pos);\\n  var line = getLine(doc, pos.line), state = getStateBefore(cm, pos.line, precise);\\n  var stream = new StringStream(line.text, cm.options.tabSize), tokens;\\n  if (asArray) { tokens = []; }\\n  while ((asArray || stream.pos < pos.ch) && !stream.eol()) {\\n    stream.start = stream.pos;\\n    style = readToken(mode, stream, state);\\n    if (asArray) { tokens.push(getObj(true)); }\\n  }\\n  return asArray ? tokens : getObj()\\n}\\n\\nfunction extractLineClasses(type, output) {\\n  if (type) { for (;;) {\\n    var lineClass = type.match(/(?:^|\\\\s+)line-(background-)?(\\\\S+)/);\\n    if (!lineClass) { break }\\n    type = type.slice(0, lineClass.index) + type.slice(lineClass.index + lineClass[0].length);\\n    var prop = lineClass[1] ? \\\"bgClass\\\" : \\\"textClass\\\";\\n    if (output[prop] == null)\\n      { output[prop] = lineClass[2]; }\\n    else if (!(new RegExp(\\\"(?:^|\\\\s)\\\" + lineClass[2] + \\\"(?:$|\\\\s)\\\")).test(output[prop]))\\n      { output[prop] += \\\" \\\" + lineClass[2]; }\\n  } }\\n  return type\\n}\\n\\n// Run the given mode's parser over a line, calling f for each token.\\nfunction runMode(cm, text, mode, state, f, lineClasses, forceToEnd) {\\n  var flattenSpans = mode.flattenSpans;\\n  if (flattenSpans == null) { flattenSpans = cm.options.flattenSpans; }\\n  var curStart = 0, curStyle = null;\\n  var stream = new StringStream(text, cm.options.tabSize), style;\\n  var inner = cm.options.addModeClass && [null];\\n  if (text == \\\"\\\") { extractLineClasses(callBlankLine(mode, state), lineClasses); }\\n  while (!stream.eol()) {\\n    if (stream.pos > cm.options.maxHighlightLength) {\\n      flattenSpans = false;\\n      if (forceToEnd) { processLine(cm, text, state, stream.pos); }\\n      stream.pos = text.length;\\n      style = null;\\n    } else {\\n      style = extractLineClasses(readToken(mode, stream, state, inner), lineClasses);\\n    }\\n    if (inner) {\\n      var mName = inner[0].name;\\n      if (mName) { style = \\\"m-\\\" + (style ? mName + \\\" \\\" + style : mName); }\\n    }\\n    if (!flattenSpans || curStyle != style) {\\n      while (curStart < stream.start) {\\n        curStart = Math.min(stream.start, curStart + 5000);\\n        f(curStart, curStyle);\\n      }\\n      curStyle = style;\\n    }\\n    stream.start = stream.pos;\\n  }\\n  while (curStart < stream.pos) {\\n    // Webkit seems to refuse to render text nodes longer than 57444\\n    // characters, and returns inaccurate measurements in nodes\\n    // starting around 5000 chars.\\n    var pos = Math.min(stream.pos, curStart + 5000);\\n    f(pos, curStyle);\\n    curStart = pos;\\n  }\\n}\\n\\n// Finds the line to start with when starting a parse. Tries to\\n// find a line with a stateAfter, so that it can start with a\\n// valid state. If that fails, it returns the line with the\\n// smallest indentation, which tends to need the least context to\\n// parse correctly.\\nfunction findStartLine(cm, n, precise) {\\n  var minindent, minline, doc = cm.doc;\\n  var lim = precise ? -1 : n - (cm.doc.mode.innerMode ? 1000 : 100);\\n  for (var search = n; search > lim; --search) {\\n    if (search <= doc.first) { return doc.first }\\n    var line = getLine(doc, search - 1);\\n    if (line.stateAfter && (!precise || search <= doc.frontier)) { return search }\\n    var indented = countColumn(line.text, null, cm.options.tabSize);\\n    if (minline == null || minindent > indented) {\\n      minline = search - 1;\\n      minindent = indented;\\n    }\\n  }\\n  return minline\\n}\\n\\n// LINE DATA STRUCTURE\\n\\n// Line objects. These hold state related to a line, including\\n// highlighting info (the styles array).\\nvar Line = function(text, markedSpans, estimateHeight) {\\n  this.text = text;\\n  attachMarkedSpans(this, markedSpans);\\n  this.height = estimateHeight ? estimateHeight(this) : 1;\\n};\\n\\nLine.prototype.lineNo = function () { return lineNo(this) };\\neventMixin(Line);\\n\\n// Change the content (text, markers) of a line. Automatically\\n// invalidates cached information and tries to re-estimate the\\n// line's height.\\nfunction updateLine(line, text, markedSpans, estimateHeight) {\\n  line.text = text;\\n  if (line.stateAfter) { line.stateAfter = null; }\\n  if (line.styles) { line.styles = null; }\\n  if (line.order != null) { line.order = null; }\\n  detachMarkedSpans(line);\\n  attachMarkedSpans(line, markedSpans);\\n  var estHeight = estimateHeight ? estimateHeight(line) : 1;\\n  if (estHeight != line.height) { updateLineHeight(line, estHeight); }\\n}\\n\\n// Detach a line from the document tree and its markers.\\nfunction cleanUpLine(line) {\\n  line.parent = null;\\n  detachMarkedSpans(line);\\n}\\n\\n// Convert a style as returned by a mode (either null, or a string\\n// containing one or more styles) to a CSS style. This is cached,\\n// and also looks for line-wide styles.\\nvar styleToClassCache = {};\\nvar styleToClassCacheWithMode = {};\\nfunction interpretTokenStyle(style, options) {\\n  if (!style || /^\\\\s*$/.test(style)) { return null }\\n  var cache = options.addModeClass ? styleToClassCacheWithMode : styleToClassCache;\\n  return cache[style] ||\\n    (cache[style] = style.replace(/\\\\S+/g, \\\"cm-$&\\\"))\\n}\\n\\n// Render the DOM representation of the text of a line. Also builds\\n// up a 'line map', which points at the DOM nodes that represent\\n// specific stretches of text, and is used by the measuring code.\\n// The returned object contains the DOM node, this map, and\\n// information about line-wide styles that were set by the mode.\\nfunction buildLineContent(cm, lineView) {\\n  // The padding-right forces the element to have a 'border', which\\n  // is needed on Webkit to be able to get line-level bounding\\n  // rectangles for it (in measureChar).\\n  var content = eltP(\\\"span\\\", null, null, webkit ? \\\"padding-right: .1px\\\" : null);\\n  var builder = {pre: eltP(\\\"pre\\\", [content], \\\"CodeMirror-line\\\"), content: content,\\n                 col: 0, pos: 0, cm: cm,\\n                 trailingSpace: false,\\n                 splitSpaces: (ie || webkit) && cm.getOption(\\\"lineWrapping\\\")};\\n  lineView.measure = {};\\n\\n  // Iterate over the logical lines that make up this visual line.\\n  for (var i = 0; i <= (lineView.rest ? lineView.rest.length : 0); i++) {\\n    var line = i ? lineView.rest[i - 1] : lineView.line, order = (void 0);\\n    builder.pos = 0;\\n    builder.addToken = buildToken;\\n    // Optionally wire in some hacks into the token-rendering\\n    // algorithm, to deal with browser quirks.\\n    if (hasBadBidiRects(cm.display.measure) && (order = getOrder(line, cm.doc.direction)))\\n      { builder.addToken = buildTokenBadBidi(builder.addToken, order); }\\n    builder.map = [];\\n    var allowFrontierUpdate = lineView != cm.display.externalMeasured && lineNo(line);\\n    insertLineContent(line, builder, getLineStyles(cm, line, allowFrontierUpdate));\\n    if (line.styleClasses) {\\n      if (line.styleClasses.bgClass)\\n        { builder.bgClass = joinClasses(line.styleClasses.bgClass, builder.bgClass || \\\"\\\"); }\\n      if (line.styleClasses.textClass)\\n        { builder.textClass = joinClasses(line.styleClasses.textClass, builder.textClass || \\\"\\\"); }\\n    }\\n\\n    // Ensure at least a single node is present, for measuring.\\n    if (builder.map.length == 0)\\n      { builder.map.push(0, 0, builder.content.appendChild(zeroWidthElement(cm.display.measure))); }\\n\\n    // Store the map and a cache object for the current logical line\\n    if (i == 0) {\\n      lineView.measure.map = builder.map;\\n      lineView.measure.cache = {};\\n    } else {\\n      (lineView.measure.maps || (lineView.measure.maps = [])).push(builder.map)\\n      ;(lineView.measure.caches || (lineView.measure.caches = [])).push({});\\n    }\\n  }\\n\\n  // See issue #2901\\n  if (webkit) {\\n    var last = builder.content.lastChild;\\n    if (/\\\\bcm-tab\\\\b/.test(last.className) || (last.querySelector && last.querySelector(\\\".cm-tab\\\")))\\n      { builder.content.className = \\\"cm-tab-wrap-hack\\\"; }\\n  }\\n\\n  signal(cm, \\\"renderLine\\\", cm, lineView.line, builder.pre);\\n  if (builder.pre.className)\\n    { builder.textClass = joinClasses(builder.pre.className, builder.textClass || \\\"\\\"); }\\n\\n  return builder\\n}\\n\\nfunction defaultSpecialCharPlaceholder(ch) {\\n  var token = elt(\\\"span\\\", \\\"\\\\u2022\\\", \\\"cm-invalidchar\\\");\\n  token.title = \\\"\\\\\\\\u\\\" + ch.charCodeAt(0).toString(16);\\n  token.setAttribute(\\\"aria-label\\\", token.title);\\n  return token\\n}\\n\\n// Build up the DOM representation for a single token, and add it to\\n// the line map. Takes care to render special characters separately.\\nfunction buildToken(builder, text, style, startStyle, endStyle, title, css) {\\n  if (!text) { return }\\n  var displayText = builder.splitSpaces ? splitSpaces(text, builder.trailingSpace) : text;\\n  var special = builder.cm.state.specialChars, mustWrap = false;\\n  var content;\\n  if (!special.test(text)) {\\n    builder.col += text.length;\\n    content = document.createTextNode(displayText);\\n    builder.map.push(builder.pos, builder.pos + text.length, content);\\n    if (ie && ie_version < 9) { mustWrap = true; }\\n    builder.pos += text.length;\\n  } else {\\n    content = document.createDocumentFragment();\\n    var pos = 0;\\n    while (true) {\\n      special.lastIndex = pos;\\n      var m = special.exec(text);\\n      var skipped = m ? m.index - pos : text.length - pos;\\n      if (skipped) {\\n        var txt = document.createTextNode(displayText.slice(pos, pos + skipped));\\n        if (ie && ie_version < 9) { content.appendChild(elt(\\\"span\\\", [txt])); }\\n        else { content.appendChild(txt); }\\n        builder.map.push(builder.pos, builder.pos + skipped, txt);\\n        builder.col += skipped;\\n        builder.pos += skipped;\\n      }\\n      if (!m) { break }\\n      pos += skipped + 1;\\n      var txt$1 = (void 0);\\n      if (m[0] == \\\"\\\\t\\\") {\\n        var tabSize = builder.cm.options.tabSize, tabWidth = tabSize - builder.col % tabSize;\\n        txt$1 = content.appendChild(elt(\\\"span\\\", spaceStr(tabWidth), \\\"cm-tab\\\"));\\n        txt$1.setAttribute(\\\"role\\\", \\\"presentation\\\");\\n        txt$1.setAttribute(\\\"cm-text\\\", \\\"\\\\t\\\");\\n        builder.col += tabWidth;\\n      } else if (m[0] == \\\"\\\\r\\\" || m[0] == \\\"\\\\n\\\") {\\n        txt$1 = content.appendChild(elt(\\\"span\\\", m[0] == \\\"\\\\r\\\" ? \\\"\\\\u240d\\\" : \\\"\\\\u2424\\\", \\\"cm-invalidchar\\\"));\\n        txt$1.setAttribute(\\\"cm-text\\\", m[0]);\\n        builder.col += 1;\\n      } else {\\n        txt$1 = builder.cm.options.specialCharPlaceholder(m[0]);\\n        txt$1.setAttribute(\\\"cm-text\\\", m[0]);\\n        if (ie && ie_version < 9) { content.appendChild(elt(\\\"span\\\", [txt$1])); }\\n        else { content.appendChild(txt$1); }\\n        builder.col += 1;\\n      }\\n      builder.map.push(builder.pos, builder.pos + 1, txt$1);\\n      builder.pos++;\\n    }\\n  }\\n  builder.trailingSpace = displayText.charCodeAt(text.length - 1) == 32;\\n  if (style || startStyle || endStyle || mustWrap || css) {\\n    var fullStyle = style || \\\"\\\";\\n    if (startStyle) { fullStyle += startStyle; }\\n    if (endStyle) { fullStyle += endStyle; }\\n    var token = elt(\\\"span\\\", [content], fullStyle, css);\\n    if (title) { token.title = title; }\\n    return builder.content.appendChild(token)\\n  }\\n  builder.content.appendChild(content);\\n}\\n\\nfunction splitSpaces(text, trailingBefore) {\\n  if (text.length > 1 && !/  /.test(text)) { return text }\\n  var spaceBefore = trailingBefore, result = \\\"\\\";\\n  for (var i = 0; i < text.length; i++) {\\n    var ch = text.charAt(i);\\n    if (ch == \\\" \\\" && spaceBefore && (i == text.length - 1 || text.charCodeAt(i + 1) == 32))\\n      { ch = \\\"\\\\u00a0\\\"; }\\n    result += ch;\\n    spaceBefore = ch == \\\" \\\";\\n  }\\n  return result\\n}\\n\\n// Work around nonsense dimensions being reported for stretches of\\n// right-to-left text.\\nfunction buildTokenBadBidi(inner, order) {\\n  return function (builder, text, style, startStyle, endStyle, title, css) {\\n    style = style ? style + \\\" cm-force-border\\\" : \\\"cm-force-border\\\";\\n    var start = builder.pos, end = start + text.length;\\n    for (;;) {\\n      // Find the part that overlaps with the start of this text\\n      var part = (void 0);\\n      for (var i = 0; i < order.length; i++) {\\n        part = order[i];\\n        if (part.to > start && part.from <= start) { break }\\n      }\\n      if (part.to >= end) { return inner(builder, text, style, startStyle, endStyle, title, css) }\\n      inner(builder, text.slice(0, part.to - start), style, startStyle, null, title, css);\\n      startStyle = null;\\n      text = text.slice(part.to - start);\\n      start = part.to;\\n    }\\n  }\\n}\\n\\nfunction buildCollapsedSpan(builder, size, marker, ignoreWidget) {\\n  var widget = !ignoreWidget && marker.widgetNode;\\n  if (widget) { builder.map.push(builder.pos, builder.pos + size, widget); }\\n  if (!ignoreWidget && builder.cm.display.input.needsContentAttribute) {\\n    if (!widget)\\n      { widget = builder.content.appendChild(document.createElement(\\\"span\\\")); }\\n    widget.setAttribute(\\\"cm-marker\\\", marker.id);\\n  }\\n  if (widget) {\\n    builder.cm.display.input.setUneditable(widget);\\n    builder.content.appendChild(widget);\\n  }\\n  builder.pos += size;\\n  builder.trailingSpace = false;\\n}\\n\\n// Outputs a number of spans to make up a line, taking highlighting\\n// and marked text into account.\\nfunction insertLineContent(line, builder, styles) {\\n  var spans = line.markedSpans, allText = line.text, at = 0;\\n  if (!spans) {\\n    for (var i$1 = 1; i$1 < styles.length; i$1+=2)\\n      { builder.addToken(builder, allText.slice(at, at = styles[i$1]), interpretTokenStyle(styles[i$1+1], builder.cm.options)); }\\n    return\\n  }\\n\\n  var len = allText.length, pos = 0, i = 1, text = \\\"\\\", style, css;\\n  var nextChange = 0, spanStyle, spanEndStyle, spanStartStyle, title, collapsed;\\n  for (;;) {\\n    if (nextChange == pos) { // Update current marker set\\n      spanStyle = spanEndStyle = spanStartStyle = title = css = \\\"\\\";\\n      collapsed = null; nextChange = Infinity;\\n      var foundBookmarks = [], endStyles = (void 0);\\n      for (var j = 0; j < spans.length; ++j) {\\n        var sp = spans[j], m = sp.marker;\\n        if (m.type == \\\"bookmark\\\" && sp.from == pos && m.widgetNode) {\\n          foundBookmarks.push(m);\\n        } else if (sp.from <= pos && (sp.to == null || sp.to > pos || m.collapsed && sp.to == pos && sp.from == pos)) {\\n          if (sp.to != null && sp.to != pos && nextChange > sp.to) {\\n            nextChange = sp.to;\\n            spanEndStyle = \\\"\\\";\\n          }\\n          if (m.className) { spanStyle += \\\" \\\" + m.className; }\\n          if (m.css) { css = (css ? css + \\\";\\\" : \\\"\\\") + m.css; }\\n          if (m.startStyle && sp.from == pos) { spanStartStyle += \\\" \\\" + m.startStyle; }\\n          if (m.endStyle && sp.to == nextChange) { (endStyles || (endStyles = [])).push(m.endStyle, sp.to); }\\n          if (m.title && !title) { title = m.title; }\\n          if (m.collapsed && (!collapsed || compareCollapsedMarkers(collapsed.marker, m) < 0))\\n            { collapsed = sp; }\\n        } else if (sp.from > pos && nextChange > sp.from) {\\n          nextChange = sp.from;\\n        }\\n      }\\n      if (endStyles) { for (var j$1 = 0; j$1 < endStyles.length; j$1 += 2)\\n        { if (endStyles[j$1 + 1] == nextChange) { spanEndStyle += \\\" \\\" + endStyles[j$1]; } } }\\n\\n      if (!collapsed || collapsed.from == pos) { for (var j$2 = 0; j$2 < foundBookmarks.length; ++j$2)\\n        { buildCollapsedSpan(builder, 0, foundBookmarks[j$2]); } }\\n      if (collapsed && (collapsed.from || 0) == pos) {\\n        buildCollapsedSpan(builder, (collapsed.to == null ? len + 1 : collapsed.to) - pos,\\n                           collapsed.marker, collapsed.from == null);\\n        if (collapsed.to == null) { return }\\n        if (collapsed.to == pos) { collapsed = false; }\\n      }\\n    }\\n    if (pos >= len) { break }\\n\\n    var upto = Math.min(len, nextChange);\\n    while (true) {\\n      if (text) {\\n        var end = pos + text.length;\\n        if (!collapsed) {\\n          var tokenText = end > upto ? text.slice(0, upto - pos) : text;\\n          builder.addToken(builder, tokenText, style ? style + spanStyle : spanStyle,\\n                           spanStartStyle, pos + tokenText.length == nextChange ? spanEndStyle : \\\"\\\", title, css);\\n        }\\n        if (end >= upto) {text = text.slice(upto - pos); pos = upto; break}\\n        pos = end;\\n        spanStartStyle = \\\"\\\";\\n      }\\n      text = allText.slice(at, at = styles[i++]);\\n      style = interpretTokenStyle(styles[i++], builder.cm.options);\\n    }\\n  }\\n}\\n\\n\\n// These objects are used to represent the visible (currently drawn)\\n// part of the document. A LineView may correspond to multiple\\n// logical lines, if those are connected by collapsed ranges.\\nfunction LineView(doc, line, lineN) {\\n  // The starting line\\n  this.line = line;\\n  // Continuing lines, if any\\n  this.rest = visualLineContinued(line);\\n  // Number of logical lines in this visual line\\n  this.size = this.rest ? lineNo(lst(this.rest)) - lineN + 1 : 1;\\n  this.node = this.text = null;\\n  this.hidden = lineIsHidden(doc, line);\\n}\\n\\n// Create a range of LineView objects for the given lines.\\nfunction buildViewArray(cm, from, to) {\\n  var array = [], nextPos;\\n  for (var pos = from; pos < to; pos = nextPos) {\\n    var view = new LineView(cm.doc, getLine(cm.doc, pos), pos);\\n    nextPos = pos + view.size;\\n    array.push(view);\\n  }\\n  return array\\n}\\n\\nvar operationGroup = null;\\n\\nfunction pushOperation(op) {\\n  if (operationGroup) {\\n    operationGroup.ops.push(op);\\n  } else {\\n    op.ownsGroup = operationGroup = {\\n      ops: [op],\\n      delayedCallbacks: []\\n    };\\n  }\\n}\\n\\nfunction fireCallbacksForOps(group) {\\n  // Calls delayed callbacks and cursorActivity handlers until no\\n  // new ones appear\\n  var callbacks = group.delayedCallbacks, i = 0;\\n  do {\\n    for (; i < callbacks.length; i++)\\n      { callbacks[i].call(null); }\\n    for (var j = 0; j < group.ops.length; j++) {\\n      var op = group.ops[j];\\n      if (op.cursorActivityHandlers)\\n        { while (op.cursorActivityCalled < op.cursorActivityHandlers.length)\\n          { op.cursorActivityHandlers[op.cursorActivityCalled++].call(null, op.cm); } }\\n    }\\n  } while (i < callbacks.length)\\n}\\n\\nfunction finishOperation(op, endCb) {\\n  var group = op.ownsGroup;\\n  if (!group) { return }\\n\\n  try { fireCallbacksForOps(group); }\\n  finally {\\n    operationGroup = null;\\n    endCb(group);\\n  }\\n}\\n\\nvar orphanDelayedCallbacks = null;\\n\\n// Often, we want to signal events at a point where we are in the\\n// middle of some work, but don't want the handler to start calling\\n// other methods on the editor, which might be in an inconsistent\\n// state or simply not expect any other events to happen.\\n// signalLater looks whether there are any handlers, and schedules\\n// them to be executed when the last operation ends, or, if no\\n// operation is active, when a timeout fires.\\nfunction signalLater(emitter, type /*, values...*/) {\\n  var arr = getHandlers(emitter, type);\\n  if (!arr.length) { return }\\n  var args = Array.prototype.slice.call(arguments, 2), list;\\n  if (operationGroup) {\\n    list = operationGroup.delayedCallbacks;\\n  } else if (orphanDelayedCallbacks) {\\n    list = orphanDelayedCallbacks;\\n  } else {\\n    list = orphanDelayedCallbacks = [];\\n    setTimeout(fireOrphanDelayed, 0);\\n  }\\n  var loop = function ( i ) {\\n    list.push(function () { return arr[i].apply(null, args); });\\n  };\\n\\n  for (var i = 0; i < arr.length; ++i)\\n    loop( i );\\n}\\n\\nfunction fireOrphanDelayed() {\\n  var delayed = orphanDelayedCallbacks;\\n  orphanDelayedCallbacks = null;\\n  for (var i = 0; i < delayed.length; ++i) { delayed[i](); }\\n}\\n\\n// When an aspect of a line changes, a string is added to\\n// lineView.changes. This updates the relevant part of the line's\\n// DOM structure.\\nfunction updateLineForChanges(cm, lineView, lineN, dims) {\\n  for (var j = 0; j < lineView.changes.length; j++) {\\n    var type = lineView.changes[j];\\n    if (type == \\\"text\\\") { updateLineText(cm, lineView); }\\n    else if (type == \\\"gutter\\\") { updateLineGutter(cm, lineView, lineN, dims); }\\n    else if (type == \\\"class\\\") { updateLineClasses(cm, lineView); }\\n    else if (type == \\\"widget\\\") { updateLineWidgets(cm, lineView, dims); }\\n  }\\n  lineView.changes = null;\\n}\\n\\n// Lines with gutter elements, widgets or a background class need to\\n// be wrapped, and have the extra elements added to the wrapper div\\nfunction ensureLineWrapped(lineView) {\\n  if (lineView.node == lineView.text) {\\n    lineView.node = elt(\\\"div\\\", null, null, \\\"position: relative\\\");\\n    if (lineView.text.parentNode)\\n      { lineView.text.parentNode.replaceChild(lineView.node, lineView.text); }\\n    lineView.node.appendChild(lineView.text);\\n    if (ie && ie_version < 8) { lineView.node.style.zIndex = 2; }\\n  }\\n  return lineView.node\\n}\\n\\nfunction updateLineBackground(cm, lineView) {\\n  var cls = lineView.bgClass ? lineView.bgClass + \\\" \\\" + (lineView.line.bgClass || \\\"\\\") : lineView.line.bgClass;\\n  if (cls) { cls += \\\" CodeMirror-linebackground\\\"; }\\n  if (lineView.background) {\\n    if (cls) { lineView.background.className = cls; }\\n    else { lineView.background.parentNode.removeChild(lineView.background); lineView.background = null; }\\n  } else if (cls) {\\n    var wrap = ensureLineWrapped(lineView);\\n    lineView.background = wrap.insertBefore(elt(\\\"div\\\", null, cls), wrap.firstChild);\\n    cm.display.input.setUneditable(lineView.background);\\n  }\\n}\\n\\n// Wrapper around buildLineContent which will reuse the structure\\n// in display.externalMeasured when possible.\\nfunction getLineContent(cm, lineView) {\\n  var ext = cm.display.externalMeasured;\\n  if (ext && ext.line == lineView.line) {\\n    cm.display.externalMeasured = null;\\n    lineView.measure = ext.measure;\\n    return ext.built\\n  }\\n  return buildLineContent(cm, lineView)\\n}\\n\\n// Redraw the line's text. Interacts with the background and text\\n// classes because the mode may output tokens that influence these\\n// classes.\\nfunction updateLineText(cm, lineView) {\\n  var cls = lineView.text.className;\\n  var built = getLineContent(cm, lineView);\\n  if (lineView.text == lineView.node) { lineView.node = built.pre; }\\n  lineView.text.parentNode.replaceChild(built.pre, lineView.text);\\n  lineView.text = built.pre;\\n  if (built.bgClass != lineView.bgClass || built.textClass != lineView.textClass) {\\n    lineView.bgClass = built.bgClass;\\n    lineView.textClass = built.textClass;\\n    updateLineClasses(cm, lineView);\\n  } else if (cls) {\\n    lineView.text.className = cls;\\n  }\\n}\\n\\nfunction updateLineClasses(cm, lineView) {\\n  updateLineBackground(cm, lineView);\\n  if (lineView.line.wrapClass)\\n    { ensureLineWrapped(lineView).className = lineView.line.wrapClass; }\\n  else if (lineView.node != lineView.text)\\n    { lineView.node.className = \\\"\\\"; }\\n  var textClass = lineView.textClass ? lineView.textClass + \\\" \\\" + (lineView.line.textClass || \\\"\\\") : lineView.line.textClass;\\n  lineView.text.className = textClass || \\\"\\\";\\n}\\n\\nfunction updateLineGutter(cm, lineView, lineN, dims) {\\n  if (lineView.gutter) {\\n    lineView.node.removeChild(lineView.gutter);\\n    lineView.gutter = null;\\n  }\\n  if (lineView.gutterBackground) {\\n    lineView.node.removeChild(lineView.gutterBackground);\\n    lineView.gutterBackground = null;\\n  }\\n  if (lineView.line.gutterClass) {\\n    var wrap = ensureLineWrapped(lineView);\\n    lineView.gutterBackground = elt(\\\"div\\\", null, \\\"CodeMirror-gutter-background \\\" + lineView.line.gutterClass,\\n                                    (\\\"left: \\\" + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + \\\"px; width: \\\" + (dims.gutterTotalWidth) + \\\"px\\\"));\\n    cm.display.input.setUneditable(lineView.gutterBackground);\\n    wrap.insertBefore(lineView.gutterBackground, lineView.text);\\n  }\\n  var markers = lineView.line.gutterMarkers;\\n  if (cm.options.lineNumbers || markers) {\\n    var wrap$1 = ensureLineWrapped(lineView);\\n    var gutterWrap = lineView.gutter = elt(\\\"div\\\", null, \\\"CodeMirror-gutter-wrapper\\\", (\\\"left: \\\" + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + \\\"px\\\"));\\n    cm.display.input.setUneditable(gutterWrap);\\n    wrap$1.insertBefore(gutterWrap, lineView.text);\\n    if (lineView.line.gutterClass)\\n      { gutterWrap.className += \\\" \\\" + lineView.line.gutterClass; }\\n    if (cm.options.lineNumbers && (!markers || !markers[\\\"CodeMirror-linenumbers\\\"]))\\n      { lineView.lineNumber = gutterWrap.appendChild(\\n        elt(\\\"div\\\", lineNumberFor(cm.options, lineN),\\n            \\\"CodeMirror-linenumber CodeMirror-gutter-elt\\\",\\n            (\\\"left: \\\" + (dims.gutterLeft[\\\"CodeMirror-linenumbers\\\"]) + \\\"px; width: \\\" + (cm.display.lineNumInnerWidth) + \\\"px\\\"))); }\\n    if (markers) { for (var k = 0; k < cm.options.gutters.length; ++k) {\\n      var id = cm.options.gutters[k], found = markers.hasOwnProperty(id) && markers[id];\\n      if (found)\\n        { gutterWrap.appendChild(elt(\\\"div\\\", [found], \\\"CodeMirror-gutter-elt\\\",\\n                                   (\\\"left: \\\" + (dims.gutterLeft[id]) + \\\"px; width: \\\" + (dims.gutterWidth[id]) + \\\"px\\\"))); }\\n    } }\\n  }\\n}\\n\\nfunction updateLineWidgets(cm, lineView, dims) {\\n  if (lineView.alignable) { lineView.alignable = null; }\\n  for (var node = lineView.node.firstChild, next = (void 0); node; node = next) {\\n    next = node.nextSibling;\\n    if (node.className == \\\"CodeMirror-linewidget\\\")\\n      { lineView.node.removeChild(node); }\\n  }\\n  insertLineWidgets(cm, lineView, dims);\\n}\\n\\n// Build a line's DOM representation from scratch\\nfunction buildLineElement(cm, lineView, lineN, dims) {\\n  var built = getLineContent(cm, lineView);\\n  lineView.text = lineView.node = built.pre;\\n  if (built.bgClass) { lineView.bgClass = built.bgClass; }\\n  if (built.textClass) { lineView.textClass = built.textClass; }\\n\\n  updateLineClasses(cm, lineView);\\n  updateLineGutter(cm, lineView, lineN, dims);\\n  insertLineWidgets(cm, lineView, dims);\\n  return lineView.node\\n}\\n\\n// A lineView may contain multiple logical lines (when merged by\\n// collapsed spans). The widgets for all of them need to be drawn.\\nfunction insertLineWidgets(cm, lineView, dims) {\\n  insertLineWidgetsFor(cm, lineView.line, lineView, dims, true);\\n  if (lineView.rest) { for (var i = 0; i < lineView.rest.length; i++)\\n    { insertLineWidgetsFor(cm, lineView.rest[i], lineView, dims, false); } }\\n}\\n\\nfunction insertLineWidgetsFor(cm, line, lineView, dims, allowAbove) {\\n  if (!line.widgets) { return }\\n  var wrap = ensureLineWrapped(lineView);\\n  for (var i = 0, ws = line.widgets; i < ws.length; ++i) {\\n    var widget = ws[i], node = elt(\\\"div\\\", [widget.node], \\\"CodeMirror-linewidget\\\");\\n    if (!widget.handleMouseEvents) { node.setAttribute(\\\"cm-ignore-events\\\", \\\"true\\\"); }\\n    positionLineWidget(widget, node, lineView, dims);\\n    cm.display.input.setUneditable(node);\\n    if (allowAbove && widget.above)\\n      { wrap.insertBefore(node, lineView.gutter || lineView.text); }\\n    else\\n      { wrap.appendChild(node); }\\n    signalLater(widget, \\\"redraw\\\");\\n  }\\n}\\n\\nfunction positionLineWidget(widget, node, lineView, dims) {\\n  if (widget.noHScroll) {\\n    (lineView.alignable || (lineView.alignable = [])).push(node);\\n    var width = dims.wrapperWidth;\\n    node.style.left = dims.fixedPos + \\\"px\\\";\\n    if (!widget.coverGutter) {\\n      width -= dims.gutterTotalWidth;\\n      node.style.paddingLeft = dims.gutterTotalWidth + \\\"px\\\";\\n    }\\n    node.style.width = width + \\\"px\\\";\\n  }\\n  if (widget.coverGutter) {\\n    node.style.zIndex = 5;\\n    node.style.position = \\\"relative\\\";\\n    if (!widget.noHScroll) { node.style.marginLeft = -dims.gutterTotalWidth + \\\"px\\\"; }\\n  }\\n}\\n\\nfunction widgetHeight(widget) {\\n  if (widget.height != null) { return widget.height }\\n  var cm = widget.doc.cm;\\n  if (!cm) { return 0 }\\n  if (!contains(document.body, widget.node)) {\\n    var parentStyle = \\\"position: relative;\\\";\\n    if (widget.coverGutter)\\n      { parentStyle += \\\"margin-left: -\\\" + cm.display.gutters.offsetWidth + \\\"px;\\\"; }\\n    if (widget.noHScroll)\\n      { parentStyle += \\\"width: \\\" + cm.display.wrapper.clientWidth + \\\"px;\\\"; }\\n    removeChildrenAndAdd(cm.display.measure, elt(\\\"div\\\", [widget.node], null, parentStyle));\\n  }\\n  return widget.height = widget.node.parentNode.offsetHeight\\n}\\n\\n// Return true when the given mouse event happened in a widget\\nfunction eventInWidget(display, e) {\\n  for (var n = e_target(e); n != display.wrapper; n = n.parentNode) {\\n    if (!n || (n.nodeType == 1 && n.getAttribute(\\\"cm-ignore-events\\\") == \\\"true\\\") ||\\n        (n.parentNode == display.sizer && n != display.mover))\\n      { return true }\\n  }\\n}\\n\\n// POSITION MEASUREMENT\\n\\nfunction paddingTop(display) {return display.lineSpace.offsetTop}\\nfunction paddingVert(display) {return display.mover.offsetHeight - display.lineSpace.offsetHeight}\\nfunction paddingH(display) {\\n  if (display.cachedPaddingH) { return display.cachedPaddingH }\\n  var e = removeChildrenAndAdd(display.measure, elt(\\\"pre\\\", \\\"x\\\"));\\n  var style = window.getComputedStyle ? window.getComputedStyle(e) : e.currentStyle;\\n  var data = {left: parseInt(style.paddingLeft), right: parseInt(style.paddingRight)};\\n  if (!isNaN(data.left) && !isNaN(data.right)) { display.cachedPaddingH = data; }\\n  return data\\n}\\n\\nfunction scrollGap(cm) { return scrollerGap - cm.display.nativeBarWidth }\\nfunction displayWidth(cm) {\\n  return cm.display.scroller.clientWidth - scrollGap(cm) - cm.display.barWidth\\n}\\nfunction displayHeight(cm) {\\n  return cm.display.scroller.clientHeight - scrollGap(cm) - cm.display.barHeight\\n}\\n\\n// Ensure the lineView.wrapping.heights array is populated. This is\\n// an array of bottom offsets for the lines that make up a drawn\\n// line. When lineWrapping is on, there might be more than one\\n// height.\\nfunction ensureLineHeights(cm, lineView, rect) {\\n  var wrapping = cm.options.lineWrapping;\\n  var curWidth = wrapping && displayWidth(cm);\\n  if (!lineView.measure.heights || wrapping && lineView.measure.width != curWidth) {\\n    var heights = lineView.measure.heights = [];\\n    if (wrapping) {\\n      lineView.measure.width = curWidth;\\n      var rects = lineView.text.firstChild.getClientRects();\\n      for (var i = 0; i < rects.length - 1; i++) {\\n        var cur = rects[i], next = rects[i + 1];\\n        if (Math.abs(cur.bottom - next.bottom) > 2)\\n          { heights.push((cur.bottom + next.top) / 2 - rect.top); }\\n      }\\n    }\\n    heights.push(rect.bottom - rect.top);\\n  }\\n}\\n\\n// Find a line map (mapping character offsets to text nodes) and a\\n// measurement cache for the given line number. (A line view might\\n// contain multiple lines when collapsed ranges are present.)\\nfunction mapFromLineView(lineView, line, lineN) {\\n  if (lineView.line == line)\\n    { return {map: lineView.measure.map, cache: lineView.measure.cache} }\\n  for (var i = 0; i < lineView.rest.length; i++)\\n    { if (lineView.rest[i] == line)\\n      { return {map: lineView.measure.maps[i], cache: lineView.measure.caches[i]} } }\\n  for (var i$1 = 0; i$1 < lineView.rest.length; i$1++)\\n    { if (lineNo(lineView.rest[i$1]) > lineN)\\n      { return {map: lineView.measure.maps[i$1], cache: lineView.measure.caches[i$1], before: true} } }\\n}\\n\\n// Render a line into the hidden node display.externalMeasured. Used\\n// when measurement is needed for a line that's not in the viewport.\\nfunction updateExternalMeasurement(cm, line) {\\n  line = visualLine(line);\\n  var lineN = lineNo(line);\\n  var view = cm.display.externalMeasured = new LineView(cm.doc, line, lineN);\\n  view.lineN = lineN;\\n  var built = view.built = buildLineContent(cm, view);\\n  view.text = built.pre;\\n  removeChildrenAndAdd(cm.display.lineMeasure, built.pre);\\n  return view\\n}\\n\\n// Get a {top, bottom, left, right} box (in line-local coordinates)\\n// for a given character.\\nfunction measureChar(cm, line, ch, bias) {\\n  return measureCharPrepared(cm, prepareMeasureForLine(cm, line), ch, bias)\\n}\\n\\n// Find a line view that corresponds to the given line number.\\nfunction findViewForLine(cm, lineN) {\\n  if (lineN >= cm.display.viewFrom && lineN < cm.display.viewTo)\\n    { return cm.display.view[findViewIndex(cm, lineN)] }\\n  var ext = cm.display.externalMeasured;\\n  if (ext && lineN >= ext.lineN && lineN < ext.lineN + ext.size)\\n    { return ext }\\n}\\n\\n// Measurement can be split in two steps, the set-up work that\\n// applies to the whole line, and the measurement of the actual\\n// character. Functions like coordsChar, that need to do a lot of\\n// measurements in a row, can thus ensure that the set-up work is\\n// only done once.\\nfunction prepareMeasureForLine(cm, line) {\\n  var lineN = lineNo(line);\\n  var view = findViewForLine(cm, lineN);\\n  if (view && !view.text) {\\n    view = null;\\n  } else if (view && view.changes) {\\n    updateLineForChanges(cm, view, lineN, getDimensions(cm));\\n    cm.curOp.forceUpdate = true;\\n  }\\n  if (!view)\\n    { view = updateExternalMeasurement(cm, line); }\\n\\n  var info = mapFromLineView(view, line, lineN);\\n  return {\\n    line: line, view: view, rect: null,\\n    map: info.map, cache: info.cache, before: info.before,\\n    hasHeights: false\\n  }\\n}\\n\\n// Given a prepared measurement object, measures the position of an\\n// actual character (or fetches it from the cache).\\nfunction measureCharPrepared(cm, prepared, ch, bias, varHeight) {\\n  if (prepared.before) { ch = -1; }\\n  var key = ch + (bias || \\\"\\\"), found;\\n  if (prepared.cache.hasOwnProperty(key)) {\\n    found = prepared.cache[key];\\n  } else {\\n    if (!prepared.rect)\\n      { prepared.rect = prepared.view.text.getBoundingClientRect(); }\\n    if (!prepared.hasHeights) {\\n      ensureLineHeights(cm, prepared.view, prepared.rect);\\n      prepared.hasHeights = true;\\n    }\\n    found = measureCharInner(cm, prepared, ch, bias);\\n    if (!found.bogus) { prepared.cache[key] = found; }\\n  }\\n  return {left: found.left, right: found.right,\\n          top: varHeight ? found.rtop : found.top,\\n          bottom: varHeight ? found.rbottom : found.bottom}\\n}\\n\\nvar nullRect = {left: 0, right: 0, top: 0, bottom: 0};\\n\\nfunction nodeAndOffsetInLineMap(map$$1, ch, bias) {\\n  var node, start, end, collapse, mStart, mEnd;\\n  // First, search the line map for the text node corresponding to,\\n  // or closest to, the target character.\\n  for (var i = 0; i < map$$1.length; i += 3) {\\n    mStart = map$$1[i];\\n    mEnd = map$$1[i + 1];\\n    if (ch < mStart) {\\n      start = 0; end = 1;\\n      collapse = \\\"left\\\";\\n    } else if (ch < mEnd) {\\n      start = ch - mStart;\\n      end = start + 1;\\n    } else if (i == map$$1.length - 3 || ch == mEnd && map$$1[i + 3] > ch) {\\n      end = mEnd - mStart;\\n      start = end - 1;\\n      if (ch >= mEnd) { collapse = \\\"right\\\"; }\\n    }\\n    if (start != null) {\\n      node = map$$1[i + 2];\\n      if (mStart == mEnd && bias == (node.insertLeft ? \\\"left\\\" : \\\"right\\\"))\\n        { collapse = bias; }\\n      if (bias == \\\"left\\\" && start == 0)\\n        { while (i && map$$1[i - 2] == map$$1[i - 3] && map$$1[i - 1].insertLeft) {\\n          node = map$$1[(i -= 3) + 2];\\n          collapse = \\\"left\\\";\\n        } }\\n      if (bias == \\\"right\\\" && start == mEnd - mStart)\\n        { while (i < map$$1.length - 3 && map$$1[i + 3] == map$$1[i + 4] && !map$$1[i + 5].insertLeft) {\\n          node = map$$1[(i += 3) + 2];\\n          collapse = \\\"right\\\";\\n        } }\\n      break\\n    }\\n  }\\n  return {node: node, start: start, end: end, collapse: collapse, coverStart: mStart, coverEnd: mEnd}\\n}\\n\\nfunction getUsefulRect(rects, bias) {\\n  var rect = nullRect;\\n  if (bias == \\\"left\\\") { for (var i = 0; i < rects.length; i++) {\\n    if ((rect = rects[i]).left != rect.right) { break }\\n  } } else { for (var i$1 = rects.length - 1; i$1 >= 0; i$1--) {\\n    if ((rect = rects[i$1]).left != rect.right) { break }\\n  } }\\n  return rect\\n}\\n\\nfunction measureCharInner(cm, prepared, ch, bias) {\\n  var place = nodeAndOffsetInLineMap(prepared.map, ch, bias);\\n  var node = place.node, start = place.start, end = place.end, collapse = place.collapse;\\n\\n  var rect;\\n  if (node.nodeType == 3) { // If it is a text node, use a range to retrieve the coordinates.\\n    for (var i$1 = 0; i$1 < 4; i$1++) { // Retry a maximum of 4 times when nonsense rectangles are returned\\n      while (start && isExtendingChar(prepared.line.text.charAt(place.coverStart + start))) { --start; }\\n      while (place.coverStart + end < place.coverEnd && isExtendingChar(prepared.line.text.charAt(place.coverStart + end))) { ++end; }\\n      if (ie && ie_version < 9 && start == 0 && end == place.coverEnd - place.coverStart)\\n        { rect = node.parentNode.getBoundingClientRect(); }\\n      else\\n        { rect = getUsefulRect(range(node, start, end).getClientRects(), bias); }\\n      if (rect.left || rect.right || start == 0) { break }\\n      end = start;\\n      start = start - 1;\\n      collapse = \\\"right\\\";\\n    }\\n    if (ie && ie_version < 11) { rect = maybeUpdateRectForZooming(cm.display.measure, rect); }\\n  } else { // If it is a widget, simply get the box for the whole widget.\\n    if (start > 0) { collapse = bias = \\\"right\\\"; }\\n    var rects;\\n    if (cm.options.lineWrapping && (rects = node.getClientRects()).length > 1)\\n      { rect = rects[bias == \\\"right\\\" ? rects.length - 1 : 0]; }\\n    else\\n      { rect = node.getBoundingClientRect(); }\\n  }\\n  if (ie && ie_version < 9 && !start && (!rect || !rect.left && !rect.right)) {\\n    var rSpan = node.parentNode.getClientRects()[0];\\n    if (rSpan)\\n      { rect = {left: rSpan.left, right: rSpan.left + charWidth(cm.display), top: rSpan.top, bottom: rSpan.bottom}; }\\n    else\\n      { rect = nullRect; }\\n  }\\n\\n  var rtop = rect.top - prepared.rect.top, rbot = rect.bottom - prepared.rect.top;\\n  var mid = (rtop + rbot) / 2;\\n  var heights = prepared.view.measure.heights;\\n  var i = 0;\\n  for (; i < heights.length - 1; i++)\\n    { if (mid < heights[i]) { break } }\\n  var top = i ? heights[i - 1] : 0, bot = heights[i];\\n  var result = {left: (collapse == \\\"right\\\" ? rect.right : rect.left) - prepared.rect.left,\\n                right: (collapse == \\\"left\\\" ? rect.left : rect.right) - prepared.rect.left,\\n                top: top, bottom: bot};\\n  if (!rect.left && !rect.right) { result.bogus = true; }\\n  if (!cm.options.singleCursorHeightPerLine) { result.rtop = rtop; result.rbottom = rbot; }\\n\\n  return result\\n}\\n\\n// Work around problem with bounding client rects on ranges being\\n// returned incorrectly when zoomed on IE10 and below.\\nfunction maybeUpdateRectForZooming(measure, rect) {\\n  if (!window.screen || screen.logicalXDPI == null ||\\n      screen.logicalXDPI == screen.deviceXDPI || !hasBadZoomedRects(measure))\\n    { return rect }\\n  var scaleX = screen.logicalXDPI / screen.deviceXDPI;\\n  var scaleY = screen.logicalYDPI / screen.deviceYDPI;\\n  return {left: rect.left * scaleX, right: rect.right * scaleX,\\n          top: rect.top * scaleY, bottom: rect.bottom * scaleY}\\n}\\n\\nfunction clearLineMeasurementCacheFor(lineView) {\\n  if (lineView.measure) {\\n    lineView.measure.cache = {};\\n    lineView.measure.heights = null;\\n    if (lineView.rest) { for (var i = 0; i < lineView.rest.length; i++)\\n      { lineView.measure.caches[i] = {}; } }\\n  }\\n}\\n\\nfunction clearLineMeasurementCache(cm) {\\n  cm.display.externalMeasure = null;\\n  removeChildren(cm.display.lineMeasure);\\n  for (var i = 0; i < cm.display.view.length; i++)\\n    { clearLineMeasurementCacheFor(cm.display.view[i]); }\\n}\\n\\nfunction clearCaches(cm) {\\n  clearLineMeasurementCache(cm);\\n  cm.display.cachedCharWidth = cm.display.cachedTextHeight = cm.display.cachedPaddingH = null;\\n  if (!cm.options.lineWrapping) { cm.display.maxLineChanged = true; }\\n  cm.display.lineNumChars = null;\\n}\\n\\nfunction pageScrollX() { return window.pageXOffset || (document.documentElement || document.body).scrollLeft }\\nfunction pageScrollY() { return window.pageYOffset || (document.documentElement || document.body).scrollTop }\\n\\n// Converts a {top, bottom, left, right} box from line-local\\n// coordinates into another coordinate system. Context may be one of\\n// \\\"line\\\", \\\"div\\\" (display.lineDiv), \\\"local\\\"./null (editor), \\\"window\\\",\\n// or \\\"page\\\".\\nfunction intoCoordSystem(cm, lineObj, rect, context, includeWidgets) {\\n  if (!includeWidgets && lineObj.widgets) { for (var i = 0; i < lineObj.widgets.length; ++i) { if (lineObj.widgets[i].above) {\\n    var size = widgetHeight(lineObj.widgets[i]);\\n    rect.top += size; rect.bottom += size;\\n  } } }\\n  if (context == \\\"line\\\") { return rect }\\n  if (!context) { context = \\\"local\\\"; }\\n  var yOff = heightAtLine(lineObj);\\n  if (context == \\\"local\\\") { yOff += paddingTop(cm.display); }\\n  else { yOff -= cm.display.viewOffset; }\\n  if (context == \\\"page\\\" || context == \\\"window\\\") {\\n    var lOff = cm.display.lineSpace.getBoundingClientRect();\\n    yOff += lOff.top + (context == \\\"window\\\" ? 0 : pageScrollY());\\n    var xOff = lOff.left + (context == \\\"window\\\" ? 0 : pageScrollX());\\n    rect.left += xOff; rect.right += xOff;\\n  }\\n  rect.top += yOff; rect.bottom += yOff;\\n  return rect\\n}\\n\\n// Coverts a box from \\\"div\\\" coords to another coordinate system.\\n// Context may be \\\"window\\\", \\\"page\\\", \\\"div\\\", or \\\"local\\\"./null.\\nfunction fromCoordSystem(cm, coords, context) {\\n  if (context == \\\"div\\\") { return coords }\\n  var left = coords.left, top = coords.top;\\n  // First move into \\\"page\\\" coordinate system\\n  if (context == \\\"page\\\") {\\n    left -= pageScrollX();\\n    top -= pageScrollY();\\n  } else if (context == \\\"local\\\" || !context) {\\n    var localBox = cm.display.sizer.getBoundingClientRect();\\n    left += localBox.left;\\n    top += localBox.top;\\n  }\\n\\n  var lineSpaceBox = cm.display.lineSpace.getBoundingClientRect();\\n  return {left: left - lineSpaceBox.left, top: top - lineSpaceBox.top}\\n}\\n\\nfunction charCoords(cm, pos, context, lineObj, bias) {\\n  if (!lineObj) { lineObj = getLine(cm.doc, pos.line); }\\n  return intoCoordSystem(cm, lineObj, measureChar(cm, lineObj, pos.ch, bias), context)\\n}\\n\\n// Returns a box for a given cursor position, which may have an\\n// 'other' property containing the position of the secondary cursor\\n// on a bidi boundary.\\n// A cursor Pos(line, char, \\\"before\\\") is on the same visual line as `char - 1`\\n// and after `char - 1` in writing order of `char - 1`\\n// A cursor Pos(line, char, \\\"after\\\") is on the same visual line as `char`\\n// and before `char` in writing order of `char`\\n// Examples (upper-case letters are RTL, lower-case are LTR):\\n//     Pos(0, 1, ...)\\n//     before   after\\n// ab     a|b     a|b\\n// aB     a|B     aB|\\n// Ab     |Ab     A|b\\n// AB     B|A     B|A\\n// Every position after the last character on a line is considered to stick\\n// to the last character on the line.\\nfunction cursorCoords(cm, pos, context, lineObj, preparedMeasure, varHeight) {\\n  lineObj = lineObj || getLine(cm.doc, pos.line);\\n  if (!preparedMeasure) { preparedMeasure = prepareMeasureForLine(cm, lineObj); }\\n  function get(ch, right) {\\n    var m = measureCharPrepared(cm, preparedMeasure, ch, right ? \\\"right\\\" : \\\"left\\\", varHeight);\\n    if (right) { m.left = m.right; } else { m.right = m.left; }\\n    return intoCoordSystem(cm, lineObj, m, context)\\n  }\\n  var order = getOrder(lineObj, cm.doc.direction), ch = pos.ch, sticky = pos.sticky;\\n  if (ch >= lineObj.text.length) {\\n    ch = lineObj.text.length;\\n    sticky = \\\"before\\\";\\n  } else if (ch <= 0) {\\n    ch = 0;\\n    sticky = \\\"after\\\";\\n  }\\n  if (!order) { return get(sticky == \\\"before\\\" ? ch - 1 : ch, sticky == \\\"before\\\") }\\n\\n  function getBidi(ch, partPos, invert) {\\n    var part = order[partPos], right = (part.level % 2) != 0;\\n    return get(invert ? ch - 1 : ch, right != invert)\\n  }\\n  var partPos = getBidiPartAt(order, ch, sticky);\\n  var other = bidiOther;\\n  var val = getBidi(ch, partPos, sticky == \\\"before\\\");\\n  if (other != null) { val.other = getBidi(ch, other, sticky != \\\"before\\\"); }\\n  return val\\n}\\n\\n// Used to cheaply estimate the coordinates for a position. Used for\\n// intermediate scroll updates.\\nfunction estimateCoords(cm, pos) {\\n  var left = 0;\\n  pos = clipPos(cm.doc, pos);\\n  if (!cm.options.lineWrapping) { left = charWidth(cm.display) * pos.ch; }\\n  var lineObj = getLine(cm.doc, pos.line);\\n  var top = heightAtLine(lineObj) + paddingTop(cm.display);\\n  return {left: left, right: left, top: top, bottom: top + lineObj.height}\\n}\\n\\n// Positions returned by coordsChar contain some extra information.\\n// xRel is the relative x position of the input coordinates compared\\n// to the found position (so xRel > 0 means the coordinates are to\\n// the right of the character position, for example). When outside\\n// is true, that means the coordinates lie outside the line's\\n// vertical range.\\nfunction PosWithInfo(line, ch, sticky, outside, xRel) {\\n  var pos = Pos(line, ch, sticky);\\n  pos.xRel = xRel;\\n  if (outside) { pos.outside = true; }\\n  return pos\\n}\\n\\n// Compute the character position closest to the given coordinates.\\n// Input must be lineSpace-local (\\\"div\\\" coordinate system).\\nfunction coordsChar(cm, x, y) {\\n  var doc = cm.doc;\\n  y += cm.display.viewOffset;\\n  if (y < 0) { return PosWithInfo(doc.first, 0, null, true, -1) }\\n  var lineN = lineAtHeight(doc, y), last = doc.first + doc.size - 1;\\n  if (lineN > last)\\n    { return PosWithInfo(doc.first + doc.size - 1, getLine(doc, last).text.length, null, true, 1) }\\n  if (x < 0) { x = 0; }\\n\\n  var lineObj = getLine(doc, lineN);\\n  for (;;) {\\n    var found = coordsCharInner(cm, lineObj, lineN, x, y);\\n    var merged = collapsedSpanAtEnd(lineObj);\\n    var mergedPos = merged && merged.find(0, true);\\n    if (merged && (found.ch > mergedPos.from.ch || found.ch == mergedPos.from.ch && found.xRel > 0))\\n      { lineN = lineNo(lineObj = mergedPos.to.line); }\\n    else\\n      { return found }\\n  }\\n}\\n\\nfunction wrappedLineExtent(cm, lineObj, preparedMeasure, y) {\\n  var measure = function (ch) { return intoCoordSystem(cm, lineObj, measureCharPrepared(cm, preparedMeasure, ch), \\\"line\\\"); };\\n  var end = lineObj.text.length;\\n  var begin = findFirst(function (ch) { return measure(ch - 1).bottom <= y; }, end, 0);\\n  end = findFirst(function (ch) { return measure(ch).top > y; }, begin, end);\\n  return {begin: begin, end: end}\\n}\\n\\nfunction wrappedLineExtentChar(cm, lineObj, preparedMeasure, target) {\\n  var targetTop = intoCoordSystem(cm, lineObj, measureCharPrepared(cm, preparedMeasure, target), \\\"line\\\").top;\\n  return wrappedLineExtent(cm, lineObj, preparedMeasure, targetTop)\\n}\\n\\nfunction coordsCharInner(cm, lineObj, lineNo$$1, x, y) {\\n  y -= heightAtLine(lineObj);\\n  var begin = 0, end = lineObj.text.length;\\n  var preparedMeasure = prepareMeasureForLine(cm, lineObj);\\n  var pos;\\n  var order = getOrder(lineObj, cm.doc.direction);\\n  if (order) {\\n    if (cm.options.lineWrapping) {\\n      var assign;\\n      ((assign = wrappedLineExtent(cm, lineObj, preparedMeasure, y), begin = assign.begin, end = assign.end, assign));\\n    }\\n    pos = new Pos(lineNo$$1, begin);\\n    var beginLeft = cursorCoords(cm, pos, \\\"line\\\", lineObj, preparedMeasure).left;\\n    var dir = beginLeft < x ? 1 : -1;\\n    var prevDiff, diff = beginLeft - x, prevPos;\\n    do {\\n      prevDiff = diff;\\n      prevPos = pos;\\n      pos = moveVisually(cm, lineObj, pos, dir);\\n      if (pos == null || pos.ch < begin || end <= (pos.sticky == \\\"before\\\" ? pos.ch - 1 : pos.ch)) {\\n        pos = prevPos;\\n        break\\n      }\\n      diff = cursorCoords(cm, pos, \\\"line\\\", lineObj, preparedMeasure).left - x;\\n    } while ((dir < 0) != (diff < 0) && (Math.abs(diff) <= Math.abs(prevDiff)))\\n    if (Math.abs(diff) > Math.abs(prevDiff)) {\\n      if ((diff < 0) == (prevDiff < 0)) { throw new Error(\\\"Broke out of infinite loop in coordsCharInner\\\") }\\n      pos = prevPos;\\n    }\\n  } else {\\n    var ch = findFirst(function (ch) {\\n      var box = intoCoordSystem(cm, lineObj, measureCharPrepared(cm, preparedMeasure, ch), \\\"line\\\");\\n      if (box.top > y) {\\n        // For the cursor stickiness\\n        end = Math.min(ch, end);\\n        return true\\n      }\\n      else if (box.bottom <= y) { return false }\\n      else if (box.left > x) { return true }\\n      else if (box.right < x) { return false }\\n      else { return (x - box.left < box.right - x) }\\n    }, begin, end);\\n    ch = skipExtendingChars(lineObj.text, ch, 1);\\n    pos = new Pos(lineNo$$1, ch, ch == end ? \\\"before\\\" : \\\"after\\\");\\n  }\\n  var coords = cursorCoords(cm, pos, \\\"line\\\", lineObj, preparedMeasure);\\n  if (y < coords.top || coords.bottom < y) { pos.outside = true; }\\n  pos.xRel = x < coords.left ? -1 : (x > coords.right ? 1 : 0);\\n  return pos\\n}\\n\\nvar measureText;\\n// Compute the default text height.\\nfunction textHeight(display) {\\n  if (display.cachedTextHeight != null) { return display.cachedTextHeight }\\n  if (measureText == null) {\\n    measureText = elt(\\\"pre\\\");\\n    // Measure a bunch of lines, for browsers that compute\\n    // fractional heights.\\n    for (var i = 0; i < 49; ++i) {\\n      measureText.appendChild(document.createTextNode(\\\"x\\\"));\\n      measureText.appendChild(elt(\\\"br\\\"));\\n    }\\n    measureText.appendChild(document.createTextNode(\\\"x\\\"));\\n  }\\n  removeChildrenAndAdd(display.measure, measureText);\\n  var height = measureText.offsetHeight / 50;\\n  if (height > 3) { display.cachedTextHeight = height; }\\n  removeChildren(display.measure);\\n  return height || 1\\n}\\n\\n// Compute the default character width.\\nfunction charWidth(display) {\\n  if (display.cachedCharWidth != null) { return display.cachedCharWidth }\\n  var anchor = elt(\\\"span\\\", \\\"xxxxxxxxxx\\\");\\n  var pre = elt(\\\"pre\\\", [anchor]);\\n  removeChildrenAndAdd(display.measure, pre);\\n  var rect = anchor.getBoundingClientRect(), width = (rect.right - rect.left) / 10;\\n  if (width > 2) { display.cachedCharWidth = width; }\\n  return width || 10\\n}\\n\\n// Do a bulk-read of the DOM positions and sizes needed to draw the\\n// view, so that we don't interleave reading and writing to the DOM.\\nfunction getDimensions(cm) {\\n  var d = cm.display, left = {}, width = {};\\n  var gutterLeft = d.gutters.clientLeft;\\n  for (var n = d.gutters.firstChild, i = 0; n; n = n.nextSibling, ++i) {\\n    left[cm.options.gutters[i]] = n.offsetLeft + n.clientLeft + gutterLeft;\\n    width[cm.options.gutters[i]] = n.clientWidth;\\n  }\\n  return {fixedPos: compensateForHScroll(d),\\n          gutterTotalWidth: d.gutters.offsetWidth,\\n          gutterLeft: left,\\n          gutterWidth: width,\\n          wrapperWidth: d.wrapper.clientWidth}\\n}\\n\\n// Computes display.scroller.scrollLeft + display.gutters.offsetWidth,\\n// but using getBoundingClientRect to get a sub-pixel-accurate\\n// result.\\nfunction compensateForHScroll(display) {\\n  return display.scroller.getBoundingClientRect().left - display.sizer.getBoundingClientRect().left\\n}\\n\\n// Returns a function that estimates the height of a line, to use as\\n// first approximation until the line becomes visible (and is thus\\n// properly measurable).\\nfunction estimateHeight(cm) {\\n  var th = textHeight(cm.display), wrapping = cm.options.lineWrapping;\\n  var perLine = wrapping && Math.max(5, cm.display.scroller.clientWidth / charWidth(cm.display) - 3);\\n  return function (line) {\\n    if (lineIsHidden(cm.doc, line)) { return 0 }\\n\\n    var widgetsHeight = 0;\\n    if (line.widgets) { for (var i = 0; i < line.widgets.length; i++) {\\n      if (line.widgets[i].height) { widgetsHeight += line.widgets[i].height; }\\n    } }\\n\\n    if (wrapping)\\n      { return widgetsHeight + (Math.ceil(line.text.length / perLine) || 1) * th }\\n    else\\n      { return widgetsHeight + th }\\n  }\\n}\\n\\nfunction estimateLineHeights(cm) {\\n  var doc = cm.doc, est = estimateHeight(cm);\\n  doc.iter(function (line) {\\n    var estHeight = est(line);\\n    if (estHeight != line.height) { updateLineHeight(line, estHeight); }\\n  });\\n}\\n\\n// Given a mouse event, find the corresponding position. If liberal\\n// is false, it checks whether a gutter or scrollbar was clicked,\\n// and returns null if it was. forRect is used by rectangular\\n// selections, and tries to estimate a character position even for\\n// coordinates beyond the right of the text.\\nfunction posFromMouse(cm, e, liberal, forRect) {\\n  var display = cm.display;\\n  if (!liberal && e_target(e).getAttribute(\\\"cm-not-content\\\") == \\\"true\\\") { return null }\\n\\n  var x, y, space = display.lineSpace.getBoundingClientRect();\\n  // Fails unpredictably on IE[67] when mouse is dragged around quickly.\\n  try { x = e.clientX - space.left; y = e.clientY - space.top; }\\n  catch (e) { return null }\\n  var coords = coordsChar(cm, x, y), line;\\n  if (forRect && coords.xRel == 1 && (line = getLine(cm.doc, coords.line).text).length == coords.ch) {\\n    var colDiff = countColumn(line, line.length, cm.options.tabSize) - line.length;\\n    coords = Pos(coords.line, Math.max(0, Math.round((x - paddingH(cm.display).left) / charWidth(cm.display)) - colDiff));\\n  }\\n  return coords\\n}\\n\\n// Find the view element corresponding to a given line. Return null\\n// when the line isn't visible.\\nfunction findViewIndex(cm, n) {\\n  if (n >= cm.display.viewTo) { return null }\\n  n -= cm.display.viewFrom;\\n  if (n < 0) { return null }\\n  var view = cm.display.view;\\n  for (var i = 0; i < view.length; i++) {\\n    n -= view[i].size;\\n    if (n < 0) { return i }\\n  }\\n}\\n\\nfunction updateSelection(cm) {\\n  cm.display.input.showSelection(cm.display.input.prepareSelection());\\n}\\n\\nfunction prepareSelection(cm, primary) {\\n  var doc = cm.doc, result = {};\\n  var curFragment = result.cursors = document.createDocumentFragment();\\n  var selFragment = result.selection = document.createDocumentFragment();\\n\\n  for (var i = 0; i < doc.sel.ranges.length; i++) {\\n    if (primary === false && i == doc.sel.primIndex) { continue }\\n    var range$$1 = doc.sel.ranges[i];\\n    if (range$$1.from().line >= cm.display.viewTo || range$$1.to().line < cm.display.viewFrom) { continue }\\n    var collapsed = range$$1.empty();\\n    if (collapsed || cm.options.showCursorWhenSelecting)\\n      { drawSelectionCursor(cm, range$$1.head, curFragment); }\\n    if (!collapsed)\\n      { drawSelectionRange(cm, range$$1, selFragment); }\\n  }\\n  return result\\n}\\n\\n// Draws a cursor for the given range\\nfunction drawSelectionCursor(cm, head, output) {\\n  var pos = cursorCoords(cm, head, \\\"div\\\", null, null, !cm.options.singleCursorHeightPerLine);\\n\\n  var cursor = output.appendChild(elt(\\\"div\\\", \\\"\\\\u00a0\\\", \\\"CodeMirror-cursor\\\"));\\n  cursor.style.left = pos.left + \\\"px\\\";\\n  cursor.style.top = pos.top + \\\"px\\\";\\n  cursor.style.height = Math.max(0, pos.bottom - pos.top) * cm.options.cursorHeight + \\\"px\\\";\\n\\n  if (pos.other) {\\n    // Secondary cursor, shown when on a 'jump' in bi-directional text\\n    var otherCursor = output.appendChild(elt(\\\"div\\\", \\\"\\\\u00a0\\\", \\\"CodeMirror-cursor CodeMirror-secondarycursor\\\"));\\n    otherCursor.style.display = \\\"\\\";\\n    otherCursor.style.left = pos.other.left + \\\"px\\\";\\n    otherCursor.style.top = pos.other.top + \\\"px\\\";\\n    otherCursor.style.height = (pos.other.bottom - pos.other.top) * .85 + \\\"px\\\";\\n  }\\n}\\n\\n// Draws the given range as a highlighted selection\\nfunction drawSelectionRange(cm, range$$1, output) {\\n  var display = cm.display, doc = cm.doc;\\n  var fragment = document.createDocumentFragment();\\n  var padding = paddingH(cm.display), leftSide = padding.left;\\n  var rightSide = Math.max(display.sizerWidth, displayWidth(cm) - display.sizer.offsetLeft) - padding.right;\\n\\n  function add(left, top, width, bottom) {\\n    if (top < 0) { top = 0; }\\n    top = Math.round(top);\\n    bottom = Math.round(bottom);\\n    fragment.appendChild(elt(\\\"div\\\", null, \\\"CodeMirror-selected\\\", (\\\"position: absolute; left: \\\" + left + \\\"px;\\\\n                             top: \\\" + top + \\\"px; width: \\\" + (width == null ? rightSide - left : width) + \\\"px;\\\\n                             height: \\\" + (bottom - top) + \\\"px\\\")));\\n  }\\n\\n  function drawForLine(line, fromArg, toArg) {\\n    var lineObj = getLine(doc, line);\\n    var lineLen = lineObj.text.length;\\n    var start, end;\\n    function coords(ch, bias) {\\n      return charCoords(cm, Pos(line, ch), \\\"div\\\", lineObj, bias)\\n    }\\n\\n    iterateBidiSections(getOrder(lineObj, doc.direction), fromArg || 0, toArg == null ? lineLen : toArg, function (from, to, dir) {\\n      var leftPos = coords(from, \\\"left\\\"), rightPos, left, right;\\n      if (from == to) {\\n        rightPos = leftPos;\\n        left = right = leftPos.left;\\n      } else {\\n        rightPos = coords(to - 1, \\\"right\\\");\\n        if (dir == \\\"rtl\\\") { var tmp = leftPos; leftPos = rightPos; rightPos = tmp; }\\n        left = leftPos.left;\\n        right = rightPos.right;\\n      }\\n      if (fromArg == null && from == 0) { left = leftSide; }\\n      if (rightPos.top - leftPos.top > 3) { // Different lines, draw top part\\n        add(left, leftPos.top, null, leftPos.bottom);\\n        left = leftSide;\\n        if (leftPos.bottom < rightPos.top) { add(left, leftPos.bottom, null, rightPos.top); }\\n      }\\n      if (toArg == null && to == lineLen) { right = rightSide; }\\n      if (!start || leftPos.top < start.top || leftPos.top == start.top && leftPos.left < start.left)\\n        { start = leftPos; }\\n      if (!end || rightPos.bottom > end.bottom || rightPos.bottom == end.bottom && rightPos.right > end.right)\\n        { end = rightPos; }\\n      if (left < leftSide + 1) { left = leftSide; }\\n      add(left, rightPos.top, right - left, rightPos.bottom);\\n    });\\n    return {start: start, end: end}\\n  }\\n\\n  var sFrom = range$$1.from(), sTo = range$$1.to();\\n  if (sFrom.line == sTo.line) {\\n    drawForLine(sFrom.line, sFrom.ch, sTo.ch);\\n  } else {\\n    var fromLine = getLine(doc, sFrom.line), toLine = getLine(doc, sTo.line);\\n    var singleVLine = visualLine(fromLine) == visualLine(toLine);\\n    var leftEnd = drawForLine(sFrom.line, sFrom.ch, singleVLine ? fromLine.text.length + 1 : null).end;\\n    var rightStart = drawForLine(sTo.line, singleVLine ? 0 : null, sTo.ch).start;\\n    if (singleVLine) {\\n      if (leftEnd.top < rightStart.top - 2) {\\n        add(leftEnd.right, leftEnd.top, null, leftEnd.bottom);\\n        add(leftSide, rightStart.top, rightStart.left, rightStart.bottom);\\n      } else {\\n        add(leftEnd.right, leftEnd.top, rightStart.left - leftEnd.right, leftEnd.bottom);\\n      }\\n    }\\n    if (leftEnd.bottom < rightStart.top)\\n      { add(leftSide, leftEnd.bottom, null, rightStart.top); }\\n  }\\n\\n  output.appendChild(fragment);\\n}\\n\\n// Cursor-blinking\\nfunction restartBlink(cm) {\\n  if (!cm.state.focused) { return }\\n  var display = cm.display;\\n  clearInterval(display.blinker);\\n  var on = true;\\n  display.cursorDiv.style.visibility = \\\"\\\";\\n  if (cm.options.cursorBlinkRate > 0)\\n    { display.blinker = setInterval(function () { return display.cursorDiv.style.visibility = (on = !on) ? \\\"\\\" : \\\"hidden\\\"; },\\n      cm.options.cursorBlinkRate); }\\n  else if (cm.options.cursorBlinkRate < 0)\\n    { display.cursorDiv.style.visibility = \\\"hidden\\\"; }\\n}\\n\\nfunction ensureFocus(cm) {\\n  if (!cm.state.focused) { cm.display.input.focus(); onFocus(cm); }\\n}\\n\\nfunction delayBlurEvent(cm) {\\n  cm.state.delayingBlurEvent = true;\\n  setTimeout(function () { if (cm.state.delayingBlurEvent) {\\n    cm.state.delayingBlurEvent = false;\\n    onBlur(cm);\\n  } }, 100);\\n}\\n\\nfunction onFocus(cm, e) {\\n  if (cm.state.delayingBlurEvent) { cm.state.delayingBlurEvent = false; }\\n\\n  if (cm.options.readOnly == \\\"nocursor\\\") { return }\\n  if (!cm.state.focused) {\\n    signal(cm, \\\"focus\\\", cm, e);\\n    cm.state.focused = true;\\n    addClass(cm.display.wrapper, \\\"CodeMirror-focused\\\");\\n    // This test prevents this from firing when a context\\n    // menu is closed (since the input reset would kill the\\n    // select-all detection hack)\\n    if (!cm.curOp && cm.display.selForContextMenu != cm.doc.sel) {\\n      cm.display.input.reset();\\n      if (webkit) { setTimeout(function () { return cm.display.input.reset(true); }, 20); } // Issue #1730\\n    }\\n    cm.display.input.receivedFocus();\\n  }\\n  restartBlink(cm);\\n}\\nfunction onBlur(cm, e) {\\n  if (cm.state.delayingBlurEvent) { return }\\n\\n  if (cm.state.focused) {\\n    signal(cm, \\\"blur\\\", cm, e);\\n    cm.state.focused = false;\\n    rmClass(cm.display.wrapper, \\\"CodeMirror-focused\\\");\\n  }\\n  clearInterval(cm.display.blinker);\\n  setTimeout(function () { if (!cm.state.focused) { cm.display.shift = false; } }, 150);\\n}\\n\\n// Re-align line numbers and gutter marks to compensate for\\n// horizontal scrolling.\\nfunction alignHorizontally(cm) {\\n  var display = cm.display, view = display.view;\\n  if (!display.alignWidgets && (!display.gutters.firstChild || !cm.options.fixedGutter)) { return }\\n  var comp = compensateForHScroll(display) - display.scroller.scrollLeft + cm.doc.scrollLeft;\\n  var gutterW = display.gutters.offsetWidth, left = comp + \\\"px\\\";\\n  for (var i = 0; i < view.length; i++) { if (!view[i].hidden) {\\n    if (cm.options.fixedGutter) {\\n      if (view[i].gutter)\\n        { view[i].gutter.style.left = left; }\\n      if (view[i].gutterBackground)\\n        { view[i].gutterBackground.style.left = left; }\\n    }\\n    var align = view[i].alignable;\\n    if (align) { for (var j = 0; j < align.length; j++)\\n      { align[j].style.left = left; } }\\n  } }\\n  if (cm.options.fixedGutter)\\n    { display.gutters.style.left = (comp + gutterW) + \\\"px\\\"; }\\n}\\n\\n// Used to ensure that the line number gutter is still the right\\n// size for the current document size. Returns true when an update\\n// is needed.\\nfunction maybeUpdateLineNumberWidth(cm) {\\n  if (!cm.options.lineNumbers) { return false }\\n  var doc = cm.doc, last = lineNumberFor(cm.options, doc.first + doc.size - 1), display = cm.display;\\n  if (last.length != display.lineNumChars) {\\n    var test = display.measure.appendChild(elt(\\\"div\\\", [elt(\\\"div\\\", last)],\\n                                               \\\"CodeMirror-linenumber CodeMirror-gutter-elt\\\"));\\n    var innerW = test.firstChild.offsetWidth, padding = test.offsetWidth - innerW;\\n    display.lineGutter.style.width = \\\"\\\";\\n    display.lineNumInnerWidth = Math.max(innerW, display.lineGutter.offsetWidth - padding) + 1;\\n    display.lineNumWidth = display.lineNumInnerWidth + padding;\\n    display.lineNumChars = display.lineNumInnerWidth ? last.length : -1;\\n    display.lineGutter.style.width = display.lineNumWidth + \\\"px\\\";\\n    updateGutterSpace(cm);\\n    return true\\n  }\\n  return false\\n}\\n\\n// Read the actual heights of the rendered lines, and update their\\n// stored heights to match.\\nfunction updateHeightsInViewport(cm) {\\n  var display = cm.display;\\n  var prevBottom = display.lineDiv.offsetTop;\\n  for (var i = 0; i < display.view.length; i++) {\\n    var cur = display.view[i], height = (void 0);\\n    if (cur.hidden) { continue }\\n    if (ie && ie_version < 8) {\\n      var bot = cur.node.offsetTop + cur.node.offsetHeight;\\n      height = bot - prevBottom;\\n      prevBottom = bot;\\n    } else {\\n      var box = cur.node.getBoundingClientRect();\\n      height = box.bottom - box.top;\\n    }\\n    var diff = cur.line.height - height;\\n    if (height < 2) { height = textHeight(display); }\\n    if (diff > .001 || diff < -.001) {\\n      updateLineHeight(cur.line, height);\\n      updateWidgetHeight(cur.line);\\n      if (cur.rest) { for (var j = 0; j < cur.rest.length; j++)\\n        { updateWidgetHeight(cur.rest[j]); } }\\n    }\\n  }\\n}\\n\\n// Read and store the height of line widgets associated with the\\n// given line.\\nfunction updateWidgetHeight(line) {\\n  if (line.widgets) { for (var i = 0; i < line.widgets.length; ++i)\\n    { line.widgets[i].height = line.widgets[i].node.parentNode.offsetHeight; } }\\n}\\n\\n// Compute the lines that are visible in a given viewport (defaults\\n// the the current scroll position). viewport may contain top,\\n// height, and ensure (see op.scrollToPos) properties.\\nfunction visibleLines(display, doc, viewport) {\\n  var top = viewport && viewport.top != null ? Math.max(0, viewport.top) : display.scroller.scrollTop;\\n  top = Math.floor(top - paddingTop(display));\\n  var bottom = viewport && viewport.bottom != null ? viewport.bottom : top + display.wrapper.clientHeight;\\n\\n  var from = lineAtHeight(doc, top), to = lineAtHeight(doc, bottom);\\n  // Ensure is a {from: {line, ch}, to: {line, ch}} object, and\\n  // forces those lines into the viewport (if possible).\\n  if (viewport && viewport.ensure) {\\n    var ensureFrom = viewport.ensure.from.line, ensureTo = viewport.ensure.to.line;\\n    if (ensureFrom < from) {\\n      from = ensureFrom;\\n      to = lineAtHeight(doc, heightAtLine(getLine(doc, ensureFrom)) + display.wrapper.clientHeight);\\n    } else if (Math.min(ensureTo, doc.lastLine()) >= to) {\\n      from = lineAtHeight(doc, heightAtLine(getLine(doc, ensureTo)) - display.wrapper.clientHeight);\\n      to = ensureTo;\\n    }\\n  }\\n  return {from: from, to: Math.max(to, from + 1)}\\n}\\n\\n// Sync the scrollable area and scrollbars, ensure the viewport\\n// covers the visible area.\\nfunction setScrollTop(cm, val) {\\n  if (Math.abs(cm.doc.scrollTop - val) < 2) { return }\\n  cm.doc.scrollTop = val;\\n  if (!gecko) { updateDisplaySimple(cm, {top: val}); }\\n  if (cm.display.scroller.scrollTop != val) { cm.display.scroller.scrollTop = val; }\\n  cm.display.scrollbars.setScrollTop(val);\\n  if (gecko) { updateDisplaySimple(cm); }\\n  startWorker(cm, 100);\\n}\\n// Sync scroller and scrollbar, ensure the gutter elements are\\n// aligned.\\nfunction setScrollLeft(cm, val, isScroller) {\\n  if (isScroller ? val == cm.doc.scrollLeft : Math.abs(cm.doc.scrollLeft - val) < 2) { return }\\n  val = Math.min(val, cm.display.scroller.scrollWidth - cm.display.scroller.clientWidth);\\n  cm.doc.scrollLeft = val;\\n  alignHorizontally(cm);\\n  if (cm.display.scroller.scrollLeft != val) { cm.display.scroller.scrollLeft = val; }\\n  cm.display.scrollbars.setScrollLeft(val);\\n}\\n\\n// Since the delta values reported on mouse wheel events are\\n// unstandardized between browsers and even browser versions, and\\n// generally horribly unpredictable, this code starts by measuring\\n// the scroll effect that the first few mouse wheel events have,\\n// and, from that, detects the way it can convert deltas to pixel\\n// offsets afterwards.\\n//\\n// The reason we want to know the amount a wheel event will scroll\\n// is that it gives us a chance to update the display before the\\n// actual scrolling happens, reducing flickering.\\n\\nvar wheelSamples = 0;\\nvar wheelPixelsPerUnit = null;\\n// Fill in a browser-detected starting value on browsers where we\\n// know one. These don't have to be accurate -- the result of them\\n// being wrong would just be a slight flicker on the first wheel\\n// scroll (if it is large enough).\\nif (ie) { wheelPixelsPerUnit = -.53; }\\nelse if (gecko) { wheelPixelsPerUnit = 15; }\\nelse if (chrome) { wheelPixelsPerUnit = -.7; }\\nelse if (safari) { wheelPixelsPerUnit = -1/3; }\\n\\nfunction wheelEventDelta(e) {\\n  var dx = e.wheelDeltaX, dy = e.wheelDeltaY;\\n  if (dx == null && e.detail && e.axis == e.HORIZONTAL_AXIS) { dx = e.detail; }\\n  if (dy == null && e.detail && e.axis == e.VERTICAL_AXIS) { dy = e.detail; }\\n  else if (dy == null) { dy = e.wheelDelta; }\\n  return {x: dx, y: dy}\\n}\\nfunction wheelEventPixels(e) {\\n  var delta = wheelEventDelta(e);\\n  delta.x *= wheelPixelsPerUnit;\\n  delta.y *= wheelPixelsPerUnit;\\n  return delta\\n}\\n\\nfunction onScrollWheel(cm, e) {\\n  var delta = wheelEventDelta(e), dx = delta.x, dy = delta.y;\\n\\n  var display = cm.display, scroll = display.scroller;\\n  // Quit if there's nothing to scroll here\\n  var canScrollX = scroll.scrollWidth > scroll.clientWidth;\\n  var canScrollY = scroll.scrollHeight > scroll.clientHeight;\\n  if (!(dx && canScrollX || dy && canScrollY)) { return }\\n\\n  // Webkit browsers on OS X abort momentum scrolls when the target\\n  // of the scroll event is removed from the scrollable element.\\n  // This hack (see related code in patchDisplay) makes sure the\\n  // element is kept around.\\n  if (dy && mac && webkit) {\\n    outer: for (var cur = e.target, view = display.view; cur != scroll; cur = cur.parentNode) {\\n      for (var i = 0; i < view.length; i++) {\\n        if (view[i].node == cur) {\\n          cm.display.currentWheelTarget = cur;\\n          break outer\\n        }\\n      }\\n    }\\n  }\\n\\n  // On some browsers, horizontal scrolling will cause redraws to\\n  // happen before the gutter has been realigned, causing it to\\n  // wriggle around in a most unseemly way. When we have an\\n  // estimated pixels/delta value, we just handle horizontal\\n  // scrolling entirely here. It'll be slightly off from native, but\\n  // better than glitching out.\\n  if (dx && !gecko && !presto && wheelPixelsPerUnit != null) {\\n    if (dy && canScrollY)\\n      { setScrollTop(cm, Math.max(0, Math.min(scroll.scrollTop + dy * wheelPixelsPerUnit, scroll.scrollHeight - scroll.clientHeight))); }\\n    setScrollLeft(cm, Math.max(0, Math.min(scroll.scrollLeft + dx * wheelPixelsPerUnit, scroll.scrollWidth - scroll.clientWidth)));\\n    // Only prevent default scrolling if vertical scrolling is\\n    // actually possible. Otherwise, it causes vertical scroll\\n    // jitter on OSX trackpads when deltaX is small and deltaY\\n    // is large (issue #3579)\\n    if (!dy || (dy && canScrollY))\\n      { e_preventDefault(e); }\\n    display.wheelStartX = null; // Abort measurement, if in progress\\n    return\\n  }\\n\\n  // 'Project' the visible viewport to cover the area that is being\\n  // scrolled into view (if we know enough to estimate it).\\n  if (dy && wheelPixelsPerUnit != null) {\\n    var pixels = dy * wheelPixelsPerUnit;\\n    var top = cm.doc.scrollTop, bot = top + display.wrapper.clientHeight;\\n    if (pixels < 0) { top = Math.max(0, top + pixels - 50); }\\n    else { bot = Math.min(cm.doc.height, bot + pixels + 50); }\\n    updateDisplaySimple(cm, {top: top, bottom: bot});\\n  }\\n\\n  if (wheelSamples < 20) {\\n    if (display.wheelStartX == null) {\\n      display.wheelStartX = scroll.scrollLeft; display.wheelStartY = scroll.scrollTop;\\n      display.wheelDX = dx; display.wheelDY = dy;\\n      setTimeout(function () {\\n        if (display.wheelStartX == null) { return }\\n        var movedX = scroll.scrollLeft - display.wheelStartX;\\n        var movedY = scroll.scrollTop - display.wheelStartY;\\n        var sample = (movedY && display.wheelDY && movedY / display.wheelDY) ||\\n          (movedX && display.wheelDX && movedX / display.wheelDX);\\n        display.wheelStartX = display.wheelStartY = null;\\n        if (!sample) { return }\\n        wheelPixelsPerUnit = (wheelPixelsPerUnit * wheelSamples + sample) / (wheelSamples + 1);\\n        ++wheelSamples;\\n      }, 200);\\n    } else {\\n      display.wheelDX += dx; display.wheelDY += dy;\\n    }\\n  }\\n}\\n\\n// SCROLLBARS\\n\\n// Prepare DOM reads needed to update the scrollbars. Done in one\\n// shot to minimize update/measure roundtrips.\\nfunction measureForScrollbars(cm) {\\n  var d = cm.display, gutterW = d.gutters.offsetWidth;\\n  var docH = Math.round(cm.doc.height + paddingVert(cm.display));\\n  return {\\n    clientHeight: d.scroller.clientHeight,\\n    viewHeight: d.wrapper.clientHeight,\\n    scrollWidth: d.scroller.scrollWidth, clientWidth: d.scroller.clientWidth,\\n    viewWidth: d.wrapper.clientWidth,\\n    barLeft: cm.options.fixedGutter ? gutterW : 0,\\n    docHeight: docH,\\n    scrollHeight: docH + scrollGap(cm) + d.barHeight,\\n    nativeBarWidth: d.nativeBarWidth,\\n    gutterWidth: gutterW\\n  }\\n}\\n\\nvar NativeScrollbars = function(place, scroll, cm) {\\n  this.cm = cm;\\n  var vert = this.vert = elt(\\\"div\\\", [elt(\\\"div\\\", null, null, \\\"min-width: 1px\\\")], \\\"CodeMirror-vscrollbar\\\");\\n  var horiz = this.horiz = elt(\\\"div\\\", [elt(\\\"div\\\", null, null, \\\"height: 100%; min-height: 1px\\\")], \\\"CodeMirror-hscrollbar\\\");\\n  place(vert); place(horiz);\\n\\n  on(vert, \\\"scroll\\\", function () {\\n    if (vert.clientHeight) { scroll(vert.scrollTop, \\\"vertical\\\"); }\\n  });\\n  on(horiz, \\\"scroll\\\", function () {\\n    if (horiz.clientWidth) { scroll(horiz.scrollLeft, \\\"horizontal\\\"); }\\n  });\\n\\n  this.checkedZeroWidth = false;\\n  // Need to set a minimum width to see the scrollbar on IE7 (but must not set it on IE8).\\n  if (ie && ie_version < 8) { this.horiz.style.minHeight = this.vert.style.minWidth = \\\"18px\\\"; }\\n};\\n\\nNativeScrollbars.prototype.update = function (measure) {\\n  var needsH = measure.scrollWidth > measure.clientWidth + 1;\\n  var needsV = measure.scrollHeight > measure.clientHeight + 1;\\n  var sWidth = measure.nativeBarWidth;\\n\\n  if (needsV) {\\n    this.vert.style.display = \\\"block\\\";\\n    this.vert.style.bottom = needsH ? sWidth + \\\"px\\\" : \\\"0\\\";\\n    var totalHeight = measure.viewHeight - (needsH ? sWidth : 0);\\n    // A bug in IE8 can cause this value to be negative, so guard it.\\n    this.vert.firstChild.style.height =\\n      Math.max(0, measure.scrollHeight - measure.clientHeight + totalHeight) + \\\"px\\\";\\n  } else {\\n    this.vert.style.display = \\\"\\\";\\n    this.vert.firstChild.style.height = \\\"0\\\";\\n  }\\n\\n  if (needsH) {\\n    this.horiz.style.display = \\\"block\\\";\\n    this.horiz.style.right = needsV ? sWidth + \\\"px\\\" : \\\"0\\\";\\n    this.horiz.style.left = measure.barLeft + \\\"px\\\";\\n    var totalWidth = measure.viewWidth - measure.barLeft - (needsV ? sWidth : 0);\\n    this.horiz.firstChild.style.width =\\n      Math.max(0, measure.scrollWidth - measure.clientWidth + totalWidth) + \\\"px\\\";\\n  } else {\\n    this.horiz.style.display = \\\"\\\";\\n    this.horiz.firstChild.style.width = \\\"0\\\";\\n  }\\n\\n  if (!this.checkedZeroWidth && measure.clientHeight > 0) {\\n    if (sWidth == 0) { this.zeroWidthHack(); }\\n    this.checkedZeroWidth = true;\\n  }\\n\\n  return {right: needsV ? sWidth : 0, bottom: needsH ? sWidth : 0}\\n};\\n\\nNativeScrollbars.prototype.setScrollLeft = function (pos) {\\n  if (this.horiz.scrollLeft != pos) { this.horiz.scrollLeft = pos; }\\n  if (this.disableHoriz) { this.enableZeroWidthBar(this.horiz, this.disableHoriz); }\\n};\\n\\nNativeScrollbars.prototype.setScrollTop = function (pos) {\\n  if (this.vert.scrollTop != pos) { this.vert.scrollTop = pos; }\\n  if (this.disableVert) { this.enableZeroWidthBar(this.vert, this.disableVert); }\\n};\\n\\nNativeScrollbars.prototype.zeroWidthHack = function () {\\n  var w = mac && !mac_geMountainLion ? \\\"12px\\\" : \\\"18px\\\";\\n  this.horiz.style.height = this.vert.style.width = w;\\n  this.horiz.style.pointerEvents = this.vert.style.pointerEvents = \\\"none\\\";\\n  this.disableHoriz = new Delayed;\\n  this.disableVert = new Delayed;\\n};\\n\\nNativeScrollbars.prototype.enableZeroWidthBar = function (bar, delay) {\\n  bar.style.pointerEvents = \\\"auto\\\";\\n  function maybeDisable() {\\n    // To find out whether the scrollbar is still visible, we\\n    // check whether the element under the pixel in the bottom\\n    // left corner of the scrollbar box is the scrollbar box\\n    // itself (when the bar is still visible) or its filler child\\n    // (when the bar is hidden). If it is still visible, we keep\\n    // it enabled, if it's hidden, we disable pointer events.\\n    var box = bar.getBoundingClientRect();\\n    var elt$$1 = document.elementFromPoint(box.left + 1, box.bottom - 1);\\n    if (elt$$1 != bar) { bar.style.pointerEvents = \\\"none\\\"; }\\n    else { delay.set(1000, maybeDisable); }\\n  }\\n  delay.set(1000, maybeDisable);\\n};\\n\\nNativeScrollbars.prototype.clear = function () {\\n  var parent = this.horiz.parentNode;\\n  parent.removeChild(this.horiz);\\n  parent.removeChild(this.vert);\\n};\\n\\nvar NullScrollbars = function () {};\\n\\nNullScrollbars.prototype.update = function () { return {bottom: 0, right: 0} };\\nNullScrollbars.prototype.setScrollLeft = function () {};\\nNullScrollbars.prototype.setScrollTop = function () {};\\nNullScrollbars.prototype.clear = function () {};\\n\\nfunction updateScrollbars(cm, measure) {\\n  if (!measure) { measure = measureForScrollbars(cm); }\\n  var startWidth = cm.display.barWidth, startHeight = cm.display.barHeight;\\n  updateScrollbarsInner(cm, measure);\\n  for (var i = 0; i < 4 && startWidth != cm.display.barWidth || startHeight != cm.display.barHeight; i++) {\\n    if (startWidth != cm.display.barWidth && cm.options.lineWrapping)\\n      { updateHeightsInViewport(cm); }\\n    updateScrollbarsInner(cm, measureForScrollbars(cm));\\n    startWidth = cm.display.barWidth; startHeight = cm.display.barHeight;\\n  }\\n}\\n\\n// Re-synchronize the fake scrollbars with the actual size of the\\n// content.\\nfunction updateScrollbarsInner(cm, measure) {\\n  var d = cm.display;\\n  var sizes = d.scrollbars.update(measure);\\n\\n  d.sizer.style.paddingRight = (d.barWidth = sizes.right) + \\\"px\\\";\\n  d.sizer.style.paddingBottom = (d.barHeight = sizes.bottom) + \\\"px\\\";\\n  d.heightForcer.style.borderBottom = sizes.bottom + \\\"px solid transparent\\\";\\n\\n  if (sizes.right && sizes.bottom) {\\n    d.scrollbarFiller.style.display = \\\"block\\\";\\n    d.scrollbarFiller.style.height = sizes.bottom + \\\"px\\\";\\n    d.scrollbarFiller.style.width = sizes.right + \\\"px\\\";\\n  } else { d.scrollbarFiller.style.display = \\\"\\\"; }\\n  if (sizes.bottom && cm.options.coverGutterNextToScrollbar && cm.options.fixedGutter) {\\n    d.gutterFiller.style.display = \\\"block\\\";\\n    d.gutterFiller.style.height = sizes.bottom + \\\"px\\\";\\n    d.gutterFiller.style.width = measure.gutterWidth + \\\"px\\\";\\n  } else { d.gutterFiller.style.display = \\\"\\\"; }\\n}\\n\\nvar scrollbarModel = {\\\"native\\\": NativeScrollbars, \\\"null\\\": NullScrollbars};\\n\\nfunction initScrollbars(cm) {\\n  if (cm.display.scrollbars) {\\n    cm.display.scrollbars.clear();\\n    if (cm.display.scrollbars.addClass)\\n      { rmClass(cm.display.wrapper, cm.display.scrollbars.addClass); }\\n  }\\n\\n  cm.display.scrollbars = new scrollbarModel[cm.options.scrollbarStyle](function (node) {\\n    cm.display.wrapper.insertBefore(node, cm.display.scrollbarFiller);\\n    // Prevent clicks in the scrollbars from killing focus\\n    on(node, \\\"mousedown\\\", function () {\\n      if (cm.state.focused) { setTimeout(function () { return cm.display.input.focus(); }, 0); }\\n    });\\n    node.setAttribute(\\\"cm-not-content\\\", \\\"true\\\");\\n  }, function (pos, axis) {\\n    if (axis == \\\"horizontal\\\") { setScrollLeft(cm, pos); }\\n    else { setScrollTop(cm, pos); }\\n  }, cm);\\n  if (cm.display.scrollbars.addClass)\\n    { addClass(cm.display.wrapper, cm.display.scrollbars.addClass); }\\n}\\n\\n// SCROLLING THINGS INTO VIEW\\n\\n// If an editor sits on the top or bottom of the window, partially\\n// scrolled out of view, this ensures that the cursor is visible.\\nfunction maybeScrollWindow(cm, rect) {\\n  if (signalDOMEvent(cm, \\\"scrollCursorIntoView\\\")) { return }\\n\\n  var display = cm.display, box = display.sizer.getBoundingClientRect(), doScroll = null;\\n  if (rect.top + box.top < 0) { doScroll = true; }\\n  else if (rect.bottom + box.top > (window.innerHeight || document.documentElement.clientHeight)) { doScroll = false; }\\n  if (doScroll != null && !phantom) {\\n    var scrollNode = elt(\\\"div\\\", \\\"\\\\u200b\\\", null, (\\\"position: absolute;\\\\n                         top: \\\" + (rect.top - display.viewOffset - paddingTop(cm.display)) + \\\"px;\\\\n                         height: \\\" + (rect.bottom - rect.top + scrollGap(cm) + display.barHeight) + \\\"px;\\\\n                         left: \\\" + (rect.left) + \\\"px; width: \\\" + (Math.max(2, rect.right - rect.left)) + \\\"px;\\\"));\\n    cm.display.lineSpace.appendChild(scrollNode);\\n    scrollNode.scrollIntoView(doScroll);\\n    cm.display.lineSpace.removeChild(scrollNode);\\n  }\\n}\\n\\n// Scroll a given position into view (immediately), verifying that\\n// it actually became visible (as line heights are accurately\\n// measured, the position of something may 'drift' during drawing).\\nfunction scrollPosIntoView(cm, pos, end, margin) {\\n  if (margin == null) { margin = 0; }\\n  var rect;\\n  for (var limit = 0; limit < 5; limit++) {\\n    var changed = false;\\n    var coords = cursorCoords(cm, pos);\\n    var endCoords = !end || end == pos ? coords : cursorCoords(cm, end);\\n    rect = {left: Math.min(coords.left, endCoords.left),\\n            top: Math.min(coords.top, endCoords.top) - margin,\\n            right: Math.max(coords.left, endCoords.left),\\n            bottom: Math.max(coords.bottom, endCoords.bottom) + margin};\\n    var scrollPos = calculateScrollPos(cm, rect);\\n    var startTop = cm.doc.scrollTop, startLeft = cm.doc.scrollLeft;\\n    if (scrollPos.scrollTop != null) {\\n      setScrollTop(cm, scrollPos.scrollTop);\\n      if (Math.abs(cm.doc.scrollTop - startTop) > 1) { changed = true; }\\n    }\\n    if (scrollPos.scrollLeft != null) {\\n      setScrollLeft(cm, scrollPos.scrollLeft);\\n      if (Math.abs(cm.doc.scrollLeft - startLeft) > 1) { changed = true; }\\n    }\\n    if (!changed) { break }\\n  }\\n  return rect\\n}\\n\\n// Scroll a given set of coordinates into view (immediately).\\nfunction scrollIntoView(cm, rect) {\\n  var scrollPos = calculateScrollPos(cm, rect);\\n  if (scrollPos.scrollTop != null) { setScrollTop(cm, scrollPos.scrollTop); }\\n  if (scrollPos.scrollLeft != null) { setScrollLeft(cm, scrollPos.scrollLeft); }\\n}\\n\\n// Calculate a new scroll position needed to scroll the given\\n// rectangle into view. Returns an object with scrollTop and\\n// scrollLeft properties. When these are undefined, the\\n// vertical/horizontal position does not need to be adjusted.\\nfunction calculateScrollPos(cm, rect) {\\n  var display = cm.display, snapMargin = textHeight(cm.display);\\n  if (rect.top < 0) { rect.top = 0; }\\n  var screentop = cm.curOp && cm.curOp.scrollTop != null ? cm.curOp.scrollTop : display.scroller.scrollTop;\\n  var screen = displayHeight(cm), result = {};\\n  if (rect.bottom - rect.top > screen) { rect.bottom = rect.top + screen; }\\n  var docBottom = cm.doc.height + paddingVert(display);\\n  var atTop = rect.top < snapMargin, atBottom = rect.bottom > docBottom - snapMargin;\\n  if (rect.top < screentop) {\\n    result.scrollTop = atTop ? 0 : rect.top;\\n  } else if (rect.bottom > screentop + screen) {\\n    var newTop = Math.min(rect.top, (atBottom ? docBottom : rect.bottom) - screen);\\n    if (newTop != screentop) { result.scrollTop = newTop; }\\n  }\\n\\n  var screenleft = cm.curOp && cm.curOp.scrollLeft != null ? cm.curOp.scrollLeft : display.scroller.scrollLeft;\\n  var screenw = displayWidth(cm) - (cm.options.fixedGutter ? display.gutters.offsetWidth : 0);\\n  var tooWide = rect.right - rect.left > screenw;\\n  if (tooWide) { rect.right = rect.left + screenw; }\\n  if (rect.left < 10)\\n    { result.scrollLeft = 0; }\\n  else if (rect.left < screenleft)\\n    { result.scrollLeft = Math.max(0, rect.left - (tooWide ? 0 : 10)); }\\n  else if (rect.right > screenw + screenleft - 3)\\n    { result.scrollLeft = rect.right + (tooWide ? 0 : 10) - screenw; }\\n  return result\\n}\\n\\n// Store a relative adjustment to the scroll position in the current\\n// operation (to be applied when the operation finishes).\\nfunction addToScrollPos(cm, left, top) {\\n  if (left != null || top != null) { resolveScrollToPos(cm); }\\n  if (left != null)\\n    { cm.curOp.scrollLeft = (cm.curOp.scrollLeft == null ? cm.doc.scrollLeft : cm.curOp.scrollLeft) + left; }\\n  if (top != null)\\n    { cm.curOp.scrollTop = (cm.curOp.scrollTop == null ? cm.doc.scrollTop : cm.curOp.scrollTop) + top; }\\n}\\n\\n// Make sure that at the end of the operation the current cursor is\\n// shown.\\nfunction ensureCursorVisible(cm) {\\n  resolveScrollToPos(cm);\\n  var cur = cm.getCursor(), from = cur, to = cur;\\n  if (!cm.options.lineWrapping) {\\n    from = cur.ch ? Pos(cur.line, cur.ch - 1) : cur;\\n    to = Pos(cur.line, cur.ch + 1);\\n  }\\n  cm.curOp.scrollToPos = {from: from, to: to, margin: cm.options.cursorScrollMargin};\\n}\\n\\n// When an operation has its scrollToPos property set, and another\\n// scroll action is applied before the end of the operation, this\\n// 'simulates' scrolling that position into view in a cheap way, so\\n// that the effect of intermediate scroll commands is not ignored.\\nfunction resolveScrollToPos(cm) {\\n  var range$$1 = cm.curOp.scrollToPos;\\n  if (range$$1) {\\n    cm.curOp.scrollToPos = null;\\n    var from = estimateCoords(cm, range$$1.from), to = estimateCoords(cm, range$$1.to);\\n    var sPos = calculateScrollPos(cm, {\\n      left: Math.min(from.left, to.left),\\n      top: Math.min(from.top, to.top) - range$$1.margin,\\n      right: Math.max(from.right, to.right),\\n      bottom: Math.max(from.bottom, to.bottom) + range$$1.margin\\n    });\\n    cm.scrollTo(sPos.scrollLeft, sPos.scrollTop);\\n  }\\n}\\n\\n// Operations are used to wrap a series of changes to the editor\\n// state in such a way that each change won't have to update the\\n// cursor and display (which would be awkward, slow, and\\n// error-prone). Instead, display updates are batched and then all\\n// combined and executed at once.\\n\\nvar nextOpId = 0;\\n// Start a new operation.\\nfunction startOperation(cm) {\\n  cm.curOp = {\\n    cm: cm,\\n    viewChanged: false,      // Flag that indicates that lines might need to be redrawn\\n    startHeight: cm.doc.height, // Used to detect need to update scrollbar\\n    forceUpdate: false,      // Used to force a redraw\\n    updateInput: null,       // Whether to reset the input textarea\\n    typing: false,           // Whether this reset should be careful to leave existing text (for compositing)\\n    changeObjs: null,        // Accumulated changes, for firing change events\\n    cursorActivityHandlers: null, // Set of handlers to fire cursorActivity on\\n    cursorActivityCalled: 0, // Tracks which cursorActivity handlers have been called already\\n    selectionChanged: false, // Whether the selection needs to be redrawn\\n    updateMaxLine: false,    // Set when the widest line needs to be determined anew\\n    scrollLeft: null, scrollTop: null, // Intermediate scroll position, not pushed to DOM yet\\n    scrollToPos: null,       // Used to scroll to a specific position\\n    focus: false,\\n    id: ++nextOpId           // Unique ID\\n  };\\n  pushOperation(cm.curOp);\\n}\\n\\n// Finish an operation, updating the display and signalling delayed events\\nfunction endOperation(cm) {\\n  var op = cm.curOp;\\n  finishOperation(op, function (group) {\\n    for (var i = 0; i < group.ops.length; i++)\\n      { group.ops[i].cm.curOp = null; }\\n    endOperations(group);\\n  });\\n}\\n\\n// The DOM updates done when an operation finishes are batched so\\n// that the minimum number of relayouts are required.\\nfunction endOperations(group) {\\n  var ops = group.ops;\\n  for (var i = 0; i < ops.length; i++) // Read DOM\\n    { endOperation_R1(ops[i]); }\\n  for (var i$1 = 0; i$1 < ops.length; i$1++) // Write DOM (maybe)\\n    { endOperation_W1(ops[i$1]); }\\n  for (var i$2 = 0; i$2 < ops.length; i$2++) // Read DOM\\n    { endOperation_R2(ops[i$2]); }\\n  for (var i$3 = 0; i$3 < ops.length; i$3++) // Write DOM (maybe)\\n    { endOperation_W2(ops[i$3]); }\\n  for (var i$4 = 0; i$4 < ops.length; i$4++) // Read DOM\\n    { endOperation_finish(ops[i$4]); }\\n}\\n\\nfunction endOperation_R1(op) {\\n  var cm = op.cm, display = cm.display;\\n  maybeClipScrollbars(cm);\\n  if (op.updateMaxLine) { findMaxLine(cm); }\\n\\n  op.mustUpdate = op.viewChanged || op.forceUpdate || op.scrollTop != null ||\\n    op.scrollToPos && (op.scrollToPos.from.line < display.viewFrom ||\\n                       op.scrollToPos.to.line >= display.viewTo) ||\\n    display.maxLineChanged && cm.options.lineWrapping;\\n  op.update = op.mustUpdate &&\\n    new DisplayUpdate(cm, op.mustUpdate && {top: op.scrollTop, ensure: op.scrollToPos}, op.forceUpdate);\\n}\\n\\nfunction endOperation_W1(op) {\\n  op.updatedDisplay = op.mustUpdate && updateDisplayIfNeeded(op.cm, op.update);\\n}\\n\\nfunction endOperation_R2(op) {\\n  var cm = op.cm, display = cm.display;\\n  if (op.updatedDisplay) { updateHeightsInViewport(cm); }\\n\\n  op.barMeasure = measureForScrollbars(cm);\\n\\n  // If the max line changed since it was last measured, measure it,\\n  // and ensure the document's width matches it.\\n  // updateDisplay_W2 will use these properties to do the actual resizing\\n  if (display.maxLineChanged && !cm.options.lineWrapping) {\\n    op.adjustWidthTo = measureChar(cm, display.maxLine, display.maxLine.text.length).left + 3;\\n    cm.display.sizerWidth = op.adjustWidthTo;\\n    op.barMeasure.scrollWidth =\\n      Math.max(display.scroller.clientWidth, display.sizer.offsetLeft + op.adjustWidthTo + scrollGap(cm) + cm.display.barWidth);\\n    op.maxScrollLeft = Math.max(0, display.sizer.offsetLeft + op.adjustWidthTo - displayWidth(cm));\\n  }\\n\\n  if (op.updatedDisplay || op.selectionChanged)\\n    { op.preparedSelection = display.input.prepareSelection(op.focus); }\\n}\\n\\nfunction endOperation_W2(op) {\\n  var cm = op.cm;\\n\\n  if (op.adjustWidthTo != null) {\\n    cm.display.sizer.style.minWidth = op.adjustWidthTo + \\\"px\\\";\\n    if (op.maxScrollLeft < cm.doc.scrollLeft)\\n      { setScrollLeft(cm, Math.min(cm.display.scroller.scrollLeft, op.maxScrollLeft), true); }\\n    cm.display.maxLineChanged = false;\\n  }\\n\\n  var takeFocus = op.focus && op.focus == activeElt() && (!document.hasFocus || document.hasFocus());\\n  if (op.preparedSelection)\\n    { cm.display.input.showSelection(op.preparedSelection, takeFocus); }\\n  if (op.updatedDisplay || op.startHeight != cm.doc.height)\\n    { updateScrollbars(cm, op.barMeasure); }\\n  if (op.updatedDisplay)\\n    { setDocumentHeight(cm, op.barMeasure); }\\n\\n  if (op.selectionChanged) { restartBlink(cm); }\\n\\n  if (cm.state.focused && op.updateInput)\\n    { cm.display.input.reset(op.typing); }\\n  if (takeFocus) { ensureFocus(op.cm); }\\n}\\n\\nfunction endOperation_finish(op) {\\n  var cm = op.cm, display = cm.display, doc = cm.doc;\\n\\n  if (op.updatedDisplay) { postUpdateDisplay(cm, op.update); }\\n\\n  // Abort mouse wheel delta measurement, when scrolling explicitly\\n  if (display.wheelStartX != null && (op.scrollTop != null || op.scrollLeft != null || op.scrollToPos))\\n    { display.wheelStartX = display.wheelStartY = null; }\\n\\n  // Propagate the scroll position to the actual DOM scroller\\n  if (op.scrollTop != null && (display.scroller.scrollTop != op.scrollTop || op.forceScroll)) {\\n    doc.scrollTop = Math.max(0, Math.min(display.scroller.scrollHeight - display.scroller.clientHeight, op.scrollTop));\\n    display.scrollbars.setScrollTop(doc.scrollTop);\\n    display.scroller.scrollTop = doc.scrollTop;\\n  }\\n  if (op.scrollLeft != null && (display.scroller.scrollLeft != op.scrollLeft || op.forceScroll)) {\\n    doc.scrollLeft = Math.max(0, Math.min(display.scroller.scrollWidth - display.scroller.clientWidth, op.scrollLeft));\\n    display.scrollbars.setScrollLeft(doc.scrollLeft);\\n    display.scroller.scrollLeft = doc.scrollLeft;\\n    alignHorizontally(cm);\\n  }\\n  // If we need to scroll a specific position into view, do so.\\n  if (op.scrollToPos) {\\n    var rect = scrollPosIntoView(cm, clipPos(doc, op.scrollToPos.from),\\n                                 clipPos(doc, op.scrollToPos.to), op.scrollToPos.margin);\\n    maybeScrollWindow(cm, rect);\\n  }\\n\\n  // Fire events for markers that are hidden/unidden by editing or\\n  // undoing\\n  var hidden = op.maybeHiddenMarkers, unhidden = op.maybeUnhiddenMarkers;\\n  if (hidden) { for (var i = 0; i < hidden.length; ++i)\\n    { if (!hidden[i].lines.length) { signal(hidden[i], \\\"hide\\\"); } } }\\n  if (unhidden) { for (var i$1 = 0; i$1 < unhidden.length; ++i$1)\\n    { if (unhidden[i$1].lines.length) { signal(unhidden[i$1], \\\"unhide\\\"); } } }\\n\\n  if (display.wrapper.offsetHeight)\\n    { doc.scrollTop = cm.display.scroller.scrollTop; }\\n\\n  // Fire change events, and delayed event handlers\\n  if (op.changeObjs)\\n    { signal(cm, \\\"changes\\\", cm, op.changeObjs); }\\n  if (op.update)\\n    { op.update.finish(); }\\n}\\n\\n// Run the given function in an operation\\nfunction runInOp(cm, f) {\\n  if (cm.curOp) { return f() }\\n  startOperation(cm);\\n  try { return f() }\\n  finally { endOperation(cm); }\\n}\\n// Wraps a function in an operation. Returns the wrapped function.\\nfunction operation(cm, f) {\\n  return function() {\\n    if (cm.curOp) { return f.apply(cm, arguments) }\\n    startOperation(cm);\\n    try { return f.apply(cm, arguments) }\\n    finally { endOperation(cm); }\\n  }\\n}\\n// Used to add methods to editor and doc instances, wrapping them in\\n// operations.\\nfunction methodOp(f) {\\n  return function() {\\n    if (this.curOp) { return f.apply(this, arguments) }\\n    startOperation(this);\\n    try { return f.apply(this, arguments) }\\n    finally { endOperation(this); }\\n  }\\n}\\nfunction docMethodOp(f) {\\n  return function() {\\n    var cm = this.cm;\\n    if (!cm || cm.curOp) { return f.apply(this, arguments) }\\n    startOperation(cm);\\n    try { return f.apply(this, arguments) }\\n    finally { endOperation(cm); }\\n  }\\n}\\n\\n// Updates the display.view data structure for a given change to the\\n// document. From and to are in pre-change coordinates. Lendiff is\\n// the amount of lines added or subtracted by the change. This is\\n// used for changes that span multiple lines, or change the way\\n// lines are divided into visual lines. regLineChange (below)\\n// registers single-line changes.\\nfunction regChange(cm, from, to, lendiff) {\\n  if (from == null) { from = cm.doc.first; }\\n  if (to == null) { to = cm.doc.first + cm.doc.size; }\\n  if (!lendiff) { lendiff = 0; }\\n\\n  var display = cm.display;\\n  if (lendiff && to < display.viewTo &&\\n      (display.updateLineNumbers == null || display.updateLineNumbers > from))\\n    { display.updateLineNumbers = from; }\\n\\n  cm.curOp.viewChanged = true;\\n\\n  if (from >= display.viewTo) { // Change after\\n    if (sawCollapsedSpans && visualLineNo(cm.doc, from) < display.viewTo)\\n      { resetView(cm); }\\n  } else if (to <= display.viewFrom) { // Change before\\n    if (sawCollapsedSpans && visualLineEndNo(cm.doc, to + lendiff) > display.viewFrom) {\\n      resetView(cm);\\n    } else {\\n      display.viewFrom += lendiff;\\n      display.viewTo += lendiff;\\n    }\\n  } else if (from <= display.viewFrom && to >= display.viewTo) { // Full overlap\\n    resetView(cm);\\n  } else if (from <= display.viewFrom) { // Top overlap\\n    var cut = viewCuttingPoint(cm, to, to + lendiff, 1);\\n    if (cut) {\\n      display.view = display.view.slice(cut.index);\\n      display.viewFrom = cut.lineN;\\n      display.viewTo += lendiff;\\n    } else {\\n      resetView(cm);\\n    }\\n  } else if (to >= display.viewTo) { // Bottom overlap\\n    var cut$1 = viewCuttingPoint(cm, from, from, -1);\\n    if (cut$1) {\\n      display.view = display.view.slice(0, cut$1.index);\\n      display.viewTo = cut$1.lineN;\\n    } else {\\n      resetView(cm);\\n    }\\n  } else { // Gap in the middle\\n    var cutTop = viewCuttingPoint(cm, from, from, -1);\\n    var cutBot = viewCuttingPoint(cm, to, to + lendiff, 1);\\n    if (cutTop && cutBot) {\\n      display.view = display.view.slice(0, cutTop.index)\\n        .concat(buildViewArray(cm, cutTop.lineN, cutBot.lineN))\\n        .concat(display.view.slice(cutBot.index));\\n      display.viewTo += lendiff;\\n    } else {\\n      resetView(cm);\\n    }\\n  }\\n\\n  var ext = display.externalMeasured;\\n  if (ext) {\\n    if (to < ext.lineN)\\n      { ext.lineN += lendiff; }\\n    else if (from < ext.lineN + ext.size)\\n      { display.externalMeasured = null; }\\n  }\\n}\\n\\n// Register a change to a single line. Type must be one of \\\"text\\\",\\n// \\\"gutter\\\", \\\"class\\\", \\\"widget\\\"\\nfunction regLineChange(cm, line, type) {\\n  cm.curOp.viewChanged = true;\\n  var display = cm.display, ext = cm.display.externalMeasured;\\n  if (ext && line >= ext.lineN && line < ext.lineN + ext.size)\\n    { display.externalMeasured = null; }\\n\\n  if (line < display.viewFrom || line >= display.viewTo) { return }\\n  var lineView = display.view[findViewIndex(cm, line)];\\n  if (lineView.node == null) { return }\\n  var arr = lineView.changes || (lineView.changes = []);\\n  if (indexOf(arr, type) == -1) { arr.push(type); }\\n}\\n\\n// Clear the view.\\nfunction resetView(cm) {\\n  cm.display.viewFrom = cm.display.viewTo = cm.doc.first;\\n  cm.display.view = [];\\n  cm.display.viewOffset = 0;\\n}\\n\\nfunction viewCuttingPoint(cm, oldN, newN, dir) {\\n  var index = findViewIndex(cm, oldN), diff, view = cm.display.view;\\n  if (!sawCollapsedSpans || newN == cm.doc.first + cm.doc.size)\\n    { return {index: index, lineN: newN} }\\n  var n = cm.display.viewFrom;\\n  for (var i = 0; i < index; i++)\\n    { n += view[i].size; }\\n  if (n != oldN) {\\n    if (dir > 0) {\\n      if (index == view.length - 1) { return null }\\n      diff = (n + view[index].size) - oldN;\\n      index++;\\n    } else {\\n      diff = n - oldN;\\n    }\\n    oldN += diff; newN += diff;\\n  }\\n  while (visualLineNo(cm.doc, newN) != newN) {\\n    if (index == (dir < 0 ? 0 : view.length - 1)) { return null }\\n    newN += dir * view[index - (dir < 0 ? 1 : 0)].size;\\n    index += dir;\\n  }\\n  return {index: index, lineN: newN}\\n}\\n\\n// Force the view to cover a given range, adding empty view element\\n// or clipping off existing ones as needed.\\nfunction adjustView(cm, from, to) {\\n  var display = cm.display, view = display.view;\\n  if (view.length == 0 || from >= display.viewTo || to <= display.viewFrom) {\\n    display.view = buildViewArray(cm, from, to);\\n    display.viewFrom = from;\\n  } else {\\n    if (display.viewFrom > from)\\n      { display.view = buildViewArray(cm, from, display.viewFrom).concat(display.view); }\\n    else if (display.viewFrom < from)\\n      { display.view = display.view.slice(findViewIndex(cm, from)); }\\n    display.viewFrom = from;\\n    if (display.viewTo < to)\\n      { display.view = display.view.concat(buildViewArray(cm, display.viewTo, to)); }\\n    else if (display.viewTo > to)\\n      { display.view = display.view.slice(0, findViewIndex(cm, to)); }\\n  }\\n  display.viewTo = to;\\n}\\n\\n// Count the number of lines in the view whose DOM representation is\\n// out of date (or nonexistent).\\nfunction countDirtyView(cm) {\\n  var view = cm.display.view, dirty = 0;\\n  for (var i = 0; i < view.length; i++) {\\n    var lineView = view[i];\\n    if (!lineView.hidden && (!lineView.node || lineView.changes)) { ++dirty; }\\n  }\\n  return dirty\\n}\\n\\n// HIGHLIGHT WORKER\\n\\nfunction startWorker(cm, time) {\\n  if (cm.doc.mode.startState && cm.doc.frontier < cm.display.viewTo)\\n    { cm.state.highlight.set(time, bind(highlightWorker, cm)); }\\n}\\n\\nfunction highlightWorker(cm) {\\n  var doc = cm.doc;\\n  if (doc.frontier < doc.first) { doc.frontier = doc.first; }\\n  if (doc.frontier >= cm.display.viewTo) { return }\\n  var end = +new Date + cm.options.workTime;\\n  var state = copyState(doc.mode, getStateBefore(cm, doc.frontier));\\n  var changedLines = [];\\n\\n  doc.iter(doc.frontier, Math.min(doc.first + doc.size, cm.display.viewTo + 500), function (line) {\\n    if (doc.frontier >= cm.display.viewFrom) { // Visible\\n      var oldStyles = line.styles, tooLong = line.text.length > cm.options.maxHighlightLength;\\n      var highlighted = highlightLine(cm, line, tooLong ? copyState(doc.mode, state) : state, true);\\n      line.styles = highlighted.styles;\\n      var oldCls = line.styleClasses, newCls = highlighted.classes;\\n      if (newCls) { line.styleClasses = newCls; }\\n      else if (oldCls) { line.styleClasses = null; }\\n      var ischange = !oldStyles || oldStyles.length != line.styles.length ||\\n        oldCls != newCls && (!oldCls || !newCls || oldCls.bgClass != newCls.bgClass || oldCls.textClass != newCls.textClass);\\n      for (var i = 0; !ischange && i < oldStyles.length; ++i) { ischange = oldStyles[i] != line.styles[i]; }\\n      if (ischange) { changedLines.push(doc.frontier); }\\n      line.stateAfter = tooLong ? state : copyState(doc.mode, state);\\n    } else {\\n      if (line.text.length <= cm.options.maxHighlightLength)\\n        { processLine(cm, line.text, state); }\\n      line.stateAfter = doc.frontier % 5 == 0 ? copyState(doc.mode, state) : null;\\n    }\\n    ++doc.frontier;\\n    if (+new Date > end) {\\n      startWorker(cm, cm.options.workDelay);\\n      return true\\n    }\\n  });\\n  if (changedLines.length) { runInOp(cm, function () {\\n    for (var i = 0; i < changedLines.length; i++)\\n      { regLineChange(cm, changedLines[i], \\\"text\\\"); }\\n  }); }\\n}\\n\\n// DISPLAY DRAWING\\n\\nvar DisplayUpdate = function(cm, viewport, force) {\\n  var display = cm.display;\\n\\n  this.viewport = viewport;\\n  // Store some values that we'll need later (but don't want to force a relayout for)\\n  this.visible = visibleLines(display, cm.doc, viewport);\\n  this.editorIsHidden = !display.wrapper.offsetWidth;\\n  this.wrapperHeight = display.wrapper.clientHeight;\\n  this.wrapperWidth = display.wrapper.clientWidth;\\n  this.oldDisplayWidth = displayWidth(cm);\\n  this.force = force;\\n  this.dims = getDimensions(cm);\\n  this.events = [];\\n};\\n\\nDisplayUpdate.prototype.signal = function (emitter, type) {\\n  if (hasHandler(emitter, type))\\n    { this.events.push(arguments); }\\n};\\nDisplayUpdate.prototype.finish = function () {\\n    var this$1 = this;\\n\\n  for (var i = 0; i < this.events.length; i++)\\n    { signal.apply(null, this$1.events[i]); }\\n};\\n\\nfunction maybeClipScrollbars(cm) {\\n  var display = cm.display;\\n  if (!display.scrollbarsClipped && display.scroller.offsetWidth) {\\n    display.nativeBarWidth = display.scroller.offsetWidth - display.scroller.clientWidth;\\n    display.heightForcer.style.height = scrollGap(cm) + \\\"px\\\";\\n    display.sizer.style.marginBottom = -display.nativeBarWidth + \\\"px\\\";\\n    display.sizer.style.borderRightWidth = scrollGap(cm) + \\\"px\\\";\\n    display.scrollbarsClipped = true;\\n  }\\n}\\n\\n// Does the actual updating of the line display. Bails out\\n// (returning false) when there is nothing to be done and forced is\\n// false.\\nfunction updateDisplayIfNeeded(cm, update) {\\n  var display = cm.display, doc = cm.doc;\\n\\n  if (update.editorIsHidden) {\\n    resetView(cm);\\n    return false\\n  }\\n\\n  // Bail out if the visible area is already rendered and nothing changed.\\n  if (!update.force &&\\n      update.visible.from >= display.viewFrom && update.visible.to <= display.viewTo &&\\n      (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo) &&\\n      display.renderedView == display.view && countDirtyView(cm) == 0)\\n    { return false }\\n\\n  if (maybeUpdateLineNumberWidth(cm)) {\\n    resetView(cm);\\n    update.dims = getDimensions(cm);\\n  }\\n\\n  // Compute a suitable new viewport (from & to)\\n  var end = doc.first + doc.size;\\n  var from = Math.max(update.visible.from - cm.options.viewportMargin, doc.first);\\n  var to = Math.min(end, update.visible.to + cm.options.viewportMargin);\\n  if (display.viewFrom < from && from - display.viewFrom < 20) { from = Math.max(doc.first, display.viewFrom); }\\n  if (display.viewTo > to && display.viewTo - to < 20) { to = Math.min(end, display.viewTo); }\\n  if (sawCollapsedSpans) {\\n    from = visualLineNo(cm.doc, from);\\n    to = visualLineEndNo(cm.doc, to);\\n  }\\n\\n  var different = from != display.viewFrom || to != display.viewTo ||\\n    display.lastWrapHeight != update.wrapperHeight || display.lastWrapWidth != update.wrapperWidth;\\n  adjustView(cm, from, to);\\n\\n  display.viewOffset = heightAtLine(getLine(cm.doc, display.viewFrom));\\n  // Position the mover div to align with the current scroll position\\n  cm.display.mover.style.top = display.viewOffset + \\\"px\\\";\\n\\n  var toUpdate = countDirtyView(cm);\\n  if (!different && toUpdate == 0 && !update.force && display.renderedView == display.view &&\\n      (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo))\\n    { return false }\\n\\n  // For big changes, we hide the enclosing element during the\\n  // update, since that speeds up the operations on most browsers.\\n  var focused = activeElt();\\n  if (toUpdate > 4) { display.lineDiv.style.display = \\\"none\\\"; }\\n  patchDisplay(cm, display.updateLineNumbers, update.dims);\\n  if (toUpdate > 4) { display.lineDiv.style.display = \\\"\\\"; }\\n  display.renderedView = display.view;\\n  // There might have been a widget with a focused element that got\\n  // hidden or updated, if so re-focus it.\\n  if (focused && activeElt() != focused && focused.offsetHeight) { focused.focus(); }\\n\\n  // Prevent selection and cursors from interfering with the scroll\\n  // width and height.\\n  removeChildren(display.cursorDiv);\\n  removeChildren(display.selectionDiv);\\n  display.gutters.style.height = display.sizer.style.minHeight = 0;\\n\\n  if (different) {\\n    display.lastWrapHeight = update.wrapperHeight;\\n    display.lastWrapWidth = update.wrapperWidth;\\n    startWorker(cm, 400);\\n  }\\n\\n  display.updateLineNumbers = null;\\n\\n  return true\\n}\\n\\nfunction postUpdateDisplay(cm, update) {\\n  var viewport = update.viewport;\\n\\n  for (var first = true;; first = false) {\\n    if (!first || !cm.options.lineWrapping || update.oldDisplayWidth == displayWidth(cm)) {\\n      // Clip forced viewport to actual scrollable area.\\n      if (viewport && viewport.top != null)\\n        { viewport = {top: Math.min(cm.doc.height + paddingVert(cm.display) - displayHeight(cm), viewport.top)}; }\\n      // Updated line heights might result in the drawn area not\\n      // actually covering the viewport. Keep looping until it does.\\n      update.visible = visibleLines(cm.display, cm.doc, viewport);\\n      if (update.visible.from >= cm.display.viewFrom && update.visible.to <= cm.display.viewTo)\\n        { break }\\n    }\\n    if (!updateDisplayIfNeeded(cm, update)) { break }\\n    updateHeightsInViewport(cm);\\n    var barMeasure = measureForScrollbars(cm);\\n    updateSelection(cm);\\n    updateScrollbars(cm, barMeasure);\\n    setDocumentHeight(cm, barMeasure);\\n  }\\n\\n  update.signal(cm, \\\"update\\\", cm);\\n  if (cm.display.viewFrom != cm.display.reportedViewFrom || cm.display.viewTo != cm.display.reportedViewTo) {\\n    update.signal(cm, \\\"viewportChange\\\", cm, cm.display.viewFrom, cm.display.viewTo);\\n    cm.display.reportedViewFrom = cm.display.viewFrom; cm.display.reportedViewTo = cm.display.viewTo;\\n  }\\n}\\n\\nfunction updateDisplaySimple(cm, viewport) {\\n  var update = new DisplayUpdate(cm, viewport);\\n  if (updateDisplayIfNeeded(cm, update)) {\\n    updateHeightsInViewport(cm);\\n    postUpdateDisplay(cm, update);\\n    var barMeasure = measureForScrollbars(cm);\\n    updateSelection(cm);\\n    updateScrollbars(cm, barMeasure);\\n    setDocumentHeight(cm, barMeasure);\\n    update.finish();\\n  }\\n}\\n\\n// Sync the actual display DOM structure with display.view, removing\\n// nodes for lines that are no longer in view, and creating the ones\\n// that are not there yet, and updating the ones that are out of\\n// date.\\nfunction patchDisplay(cm, updateNumbersFrom, dims) {\\n  var display = cm.display, lineNumbers = cm.options.lineNumbers;\\n  var container = display.lineDiv, cur = container.firstChild;\\n\\n  function rm(node) {\\n    var next = node.nextSibling;\\n    // Works around a throw-scroll bug in OS X Webkit\\n    if (webkit && mac && cm.display.currentWheelTarget == node)\\n      { node.style.display = \\\"none\\\"; }\\n    else\\n      { node.parentNode.removeChild(node); }\\n    return next\\n  }\\n\\n  var view = display.view, lineN = display.viewFrom;\\n  // Loop over the elements in the view, syncing cur (the DOM nodes\\n  // in display.lineDiv) with the view as we go.\\n  for (var i = 0; i < view.length; i++) {\\n    var lineView = view[i];\\n    if (lineView.hidden) {\\n    } else if (!lineView.node || lineView.node.parentNode != container) { // Not drawn yet\\n      var node = buildLineElement(cm, lineView, lineN, dims);\\n      container.insertBefore(node, cur);\\n    } else { // Already drawn\\n      while (cur != lineView.node) { cur = rm(cur); }\\n      var updateNumber = lineNumbers && updateNumbersFrom != null &&\\n        updateNumbersFrom <= lineN && lineView.lineNumber;\\n      if (lineView.changes) {\\n        if (indexOf(lineView.changes, \\\"gutter\\\") > -1) { updateNumber = false; }\\n        updateLineForChanges(cm, lineView, lineN, dims);\\n      }\\n      if (updateNumber) {\\n        removeChildren(lineView.lineNumber);\\n        lineView.lineNumber.appendChild(document.createTextNode(lineNumberFor(cm.options, lineN)));\\n      }\\n      cur = lineView.node.nextSibling;\\n    }\\n    lineN += lineView.size;\\n  }\\n  while (cur) { cur = rm(cur); }\\n}\\n\\nfunction updateGutterSpace(cm) {\\n  var width = cm.display.gutters.offsetWidth;\\n  cm.display.sizer.style.marginLeft = width + \\\"px\\\";\\n}\\n\\nfunction setDocumentHeight(cm, measure) {\\n  cm.display.sizer.style.minHeight = measure.docHeight + \\\"px\\\";\\n  cm.display.heightForcer.style.top = measure.docHeight + \\\"px\\\";\\n  cm.display.gutters.style.height = (measure.docHeight + cm.display.barHeight + scrollGap(cm)) + \\\"px\\\";\\n}\\n\\n// Rebuild the gutter elements, ensure the margin to the left of the\\n// code matches their width.\\nfunction updateGutters(cm) {\\n  var gutters = cm.display.gutters, specs = cm.options.gutters;\\n  removeChildren(gutters);\\n  var i = 0;\\n  for (; i < specs.length; ++i) {\\n    var gutterClass = specs[i];\\n    var gElt = gutters.appendChild(elt(\\\"div\\\", null, \\\"CodeMirror-gutter \\\" + gutterClass));\\n    if (gutterClass == \\\"CodeMirror-linenumbers\\\") {\\n      cm.display.lineGutter = gElt;\\n      gElt.style.width = (cm.display.lineNumWidth || 1) + \\\"px\\\";\\n    }\\n  }\\n  gutters.style.display = i ? \\\"\\\" : \\\"none\\\";\\n  updateGutterSpace(cm);\\n}\\n\\n// Make sure the gutters options contains the element\\n// \\\"CodeMirror-linenumbers\\\" when the lineNumbers option is true.\\nfunction setGuttersForLineNumbers(options) {\\n  var found = indexOf(options.gutters, \\\"CodeMirror-linenumbers\\\");\\n  if (found == -1 && options.lineNumbers) {\\n    options.gutters = options.gutters.concat([\\\"CodeMirror-linenumbers\\\"]);\\n  } else if (found > -1 && !options.lineNumbers) {\\n    options.gutters = options.gutters.slice(0);\\n    options.gutters.splice(found, 1);\\n  }\\n}\\n\\n// Selection objects are immutable. A new one is created every time\\n// the selection changes. A selection is one or more non-overlapping\\n// (and non-touching) ranges, sorted, and an integer that indicates\\n// which one is the primary selection (the one that's scrolled into\\n// view, that getCursor returns, etc).\\nvar Selection = function(ranges, primIndex) {\\n  this.ranges = ranges;\\n  this.primIndex = primIndex;\\n};\\n\\nSelection.prototype.primary = function () { return this.ranges[this.primIndex] };\\n\\nSelection.prototype.equals = function (other) {\\n    var this$1 = this;\\n\\n  if (other == this) { return true }\\n  if (other.primIndex != this.primIndex || other.ranges.length != this.ranges.length) { return false }\\n  for (var i = 0; i < this.ranges.length; i++) {\\n    var here = this$1.ranges[i], there = other.ranges[i];\\n    if (!equalCursorPos(here.anchor, there.anchor) || !equalCursorPos(here.head, there.head)) { return false }\\n  }\\n  return true\\n};\\n\\nSelection.prototype.deepCopy = function () {\\n    var this$1 = this;\\n\\n  var out = [];\\n  for (var i = 0; i < this.ranges.length; i++)\\n    { out[i] = new Range(copyPos(this$1.ranges[i].anchor), copyPos(this$1.ranges[i].head)); }\\n  return new Selection(out, this.primIndex)\\n};\\n\\nSelection.prototype.somethingSelected = function () {\\n    var this$1 = this;\\n\\n  for (var i = 0; i < this.ranges.length; i++)\\n    { if (!this$1.ranges[i].empty()) { return true } }\\n  return false\\n};\\n\\nSelection.prototype.contains = function (pos, end) {\\n    var this$1 = this;\\n\\n  if (!end) { end = pos; }\\n  for (var i = 0; i < this.ranges.length; i++) {\\n    var range = this$1.ranges[i];\\n    if (cmp(end, range.from()) >= 0 && cmp(pos, range.to()) <= 0)\\n      { return i }\\n  }\\n  return -1\\n};\\n\\nvar Range = function(anchor, head) {\\n  this.anchor = anchor; this.head = head;\\n};\\n\\nRange.prototype.from = function () { return minPos(this.anchor, this.head) };\\nRange.prototype.to = function () { return maxPos(this.anchor, this.head) };\\nRange.prototype.empty = function () { return this.head.line == this.anchor.line && this.head.ch == this.anchor.ch };\\n\\n// Take an unsorted, potentially overlapping set of ranges, and\\n// build a selection out of it. 'Consumes' ranges array (modifying\\n// it).\\nfunction normalizeSelection(ranges, primIndex) {\\n  var prim = ranges[primIndex];\\n  ranges.sort(function (a, b) { return cmp(a.from(), b.from()); });\\n  primIndex = indexOf(ranges, prim);\\n  for (var i = 1; i < ranges.length; i++) {\\n    var cur = ranges[i], prev = ranges[i - 1];\\n    if (cmp(prev.to(), cur.from()) >= 0) {\\n      var from = minPos(prev.from(), cur.from()), to = maxPos(prev.to(), cur.to());\\n      var inv = prev.empty() ? cur.from() == cur.head : prev.from() == prev.head;\\n      if (i <= primIndex) { --primIndex; }\\n      ranges.splice(--i, 2, new Range(inv ? to : from, inv ? from : to));\\n    }\\n  }\\n  return new Selection(ranges, primIndex)\\n}\\n\\nfunction simpleSelection(anchor, head) {\\n  return new Selection([new Range(anchor, head || anchor)], 0)\\n}\\n\\n// Compute the position of the end of a change (its 'to' property\\n// refers to the pre-change end).\\nfunction changeEnd(change) {\\n  if (!change.text) { return change.to }\\n  return Pos(change.from.line + change.text.length - 1,\\n             lst(change.text).length + (change.text.length == 1 ? change.from.ch : 0))\\n}\\n\\n// Adjust a position to refer to the post-change position of the\\n// same text, or the end of the change if the change covers it.\\nfunction adjustForChange(pos, change) {\\n  if (cmp(pos, change.from) < 0) { return pos }\\n  if (cmp(pos, change.to) <= 0) { return changeEnd(change) }\\n\\n  var line = pos.line + change.text.length - (change.to.line - change.from.line) - 1, ch = pos.ch;\\n  if (pos.line == change.to.line) { ch += changeEnd(change).ch - change.to.ch; }\\n  return Pos(line, ch)\\n}\\n\\nfunction computeSelAfterChange(doc, change) {\\n  var out = [];\\n  for (var i = 0; i < doc.sel.ranges.length; i++) {\\n    var range = doc.sel.ranges[i];\\n    out.push(new Range(adjustForChange(range.anchor, change),\\n                       adjustForChange(range.head, change)));\\n  }\\n  return normalizeSelection(out, doc.sel.primIndex)\\n}\\n\\nfunction offsetPos(pos, old, nw) {\\n  if (pos.line == old.line)\\n    { return Pos(nw.line, pos.ch - old.ch + nw.ch) }\\n  else\\n    { return Pos(nw.line + (pos.line - old.line), pos.ch) }\\n}\\n\\n// Used by replaceSelections to allow moving the selection to the\\n// start or around the replaced test. Hint may be \\\"start\\\" or \\\"around\\\".\\nfunction computeReplacedSel(doc, changes, hint) {\\n  var out = [];\\n  var oldPrev = Pos(doc.first, 0), newPrev = oldPrev;\\n  for (var i = 0; i < changes.length; i++) {\\n    var change = changes[i];\\n    var from = offsetPos(change.from, oldPrev, newPrev);\\n    var to = offsetPos(changeEnd(change), oldPrev, newPrev);\\n    oldPrev = change.to;\\n    newPrev = to;\\n    if (hint == \\\"around\\\") {\\n      var range = doc.sel.ranges[i], inv = cmp(range.head, range.anchor) < 0;\\n      out[i] = new Range(inv ? to : from, inv ? from : to);\\n    } else {\\n      out[i] = new Range(from, from);\\n    }\\n  }\\n  return new Selection(out, doc.sel.primIndex)\\n}\\n\\n// Used to get the editor into a consistent state again when options change.\\n\\nfunction loadMode(cm) {\\n  cm.doc.mode = getMode(cm.options, cm.doc.modeOption);\\n  resetModeState(cm);\\n}\\n\\nfunction resetModeState(cm) {\\n  cm.doc.iter(function (line) {\\n    if (line.stateAfter) { line.stateAfter = null; }\\n    if (line.styles) { line.styles = null; }\\n  });\\n  cm.doc.frontier = cm.doc.first;\\n  startWorker(cm, 100);\\n  cm.state.modeGen++;\\n  if (cm.curOp) { regChange(cm); }\\n}\\n\\n// DOCUMENT DATA STRUCTURE\\n\\n// By default, updates that start and end at the beginning of a line\\n// are treated specially, in order to make the association of line\\n// widgets and marker elements with the text behave more intuitive.\\nfunction isWholeLineUpdate(doc, change) {\\n  return change.from.ch == 0 && change.to.ch == 0 && lst(change.text) == \\\"\\\" &&\\n    (!doc.cm || doc.cm.options.wholeLineUpdateBefore)\\n}\\n\\n// Perform a change on the document data structure.\\nfunction updateDoc(doc, change, markedSpans, estimateHeight$$1) {\\n  function spansFor(n) {return markedSpans ? markedSpans[n] : null}\\n  function update(line, text, spans) {\\n    updateLine(line, text, spans, estimateHeight$$1);\\n    signalLater(line, \\\"change\\\", line, change);\\n  }\\n  function linesFor(start, end) {\\n    var result = [];\\n    for (var i = start; i < end; ++i)\\n      { result.push(new Line(text[i], spansFor(i), estimateHeight$$1)); }\\n    return result\\n  }\\n\\n  var from = change.from, to = change.to, text = change.text;\\n  var firstLine = getLine(doc, from.line), lastLine = getLine(doc, to.line);\\n  var lastText = lst(text), lastSpans = spansFor(text.length - 1), nlines = to.line - from.line;\\n\\n  // Adjust the line structure\\n  if (change.full) {\\n    doc.insert(0, linesFor(0, text.length));\\n    doc.remove(text.length, doc.size - text.length);\\n  } else if (isWholeLineUpdate(doc, change)) {\\n    // This is a whole-line replace. Treated specially to make\\n    // sure line objects move the way they are supposed to.\\n    var added = linesFor(0, text.length - 1);\\n    update(lastLine, lastLine.text, lastSpans);\\n    if (nlines) { doc.remove(from.line, nlines); }\\n    if (added.length) { doc.insert(from.line, added); }\\n  } else if (firstLine == lastLine) {\\n    if (text.length == 1) {\\n      update(firstLine, firstLine.text.slice(0, from.ch) + lastText + firstLine.text.slice(to.ch), lastSpans);\\n    } else {\\n      var added$1 = linesFor(1, text.length - 1);\\n      added$1.push(new Line(lastText + firstLine.text.slice(to.ch), lastSpans, estimateHeight$$1));\\n      update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));\\n      doc.insert(from.line + 1, added$1);\\n    }\\n  } else if (text.length == 1) {\\n    update(firstLine, firstLine.text.slice(0, from.ch) + text[0] + lastLine.text.slice(to.ch), spansFor(0));\\n    doc.remove(from.line + 1, nlines);\\n  } else {\\n    update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));\\n    update(lastLine, lastText + lastLine.text.slice(to.ch), lastSpans);\\n    var added$2 = linesFor(1, text.length - 1);\\n    if (nlines > 1) { doc.remove(from.line + 1, nlines - 1); }\\n    doc.insert(from.line + 1, added$2);\\n  }\\n\\n  signalLater(doc, \\\"change\\\", doc, change);\\n}\\n\\n// Call f for all linked documents.\\nfunction linkedDocs(doc, f, sharedHistOnly) {\\n  function propagate(doc, skip, sharedHist) {\\n    if (doc.linked) { for (var i = 0; i < doc.linked.length; ++i) {\\n      var rel = doc.linked[i];\\n      if (rel.doc == skip) { continue }\\n      var shared = sharedHist && rel.sharedHist;\\n      if (sharedHistOnly && !shared) { continue }\\n      f(rel.doc, shared);\\n      propagate(rel.doc, doc, shared);\\n    } }\\n  }\\n  propagate(doc, null, true);\\n}\\n\\n// Attach a document to an editor.\\nfunction attachDoc(cm, doc) {\\n  if (doc.cm) { throw new Error(\\\"This document is already in use.\\\") }\\n  cm.doc = doc;\\n  doc.cm = cm;\\n  estimateLineHeights(cm);\\n  loadMode(cm);\\n  setDirectionClass(cm);\\n  if (!cm.options.lineWrapping) { findMaxLine(cm); }\\n  cm.options.mode = doc.modeOption;\\n  regChange(cm);\\n}\\n\\nfunction setDirectionClass(cm) {\\n  (cm.doc.direction == \\\"rtl\\\" ? addClass : rmClass)(cm.display.lineDiv, \\\"CodeMirror-rtl\\\");\\n}\\n\\nfunction directionChanged(cm) {\\n  runInOp(cm, function () {\\n    setDirectionClass(cm);\\n    regChange(cm);\\n  });\\n}\\n\\nfunction History(startGen) {\\n  // Arrays of change events and selections. Doing something adds an\\n  // event to done and clears undo. Undoing moves events from done\\n  // to undone, redoing moves them in the other direction.\\n  this.done = []; this.undone = [];\\n  this.undoDepth = Infinity;\\n  // Used to track when changes can be merged into a single undo\\n  // event\\n  this.lastModTime = this.lastSelTime = 0;\\n  this.lastOp = this.lastSelOp = null;\\n  this.lastOrigin = this.lastSelOrigin = null;\\n  // Used by the isClean() method\\n  this.generation = this.maxGeneration = startGen || 1;\\n}\\n\\n// Create a history change event from an updateDoc-style change\\n// object.\\nfunction historyChangeFromChange(doc, change) {\\n  var histChange = {from: copyPos(change.from), to: changeEnd(change), text: getBetween(doc, change.from, change.to)};\\n  attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);\\n  linkedDocs(doc, function (doc) { return attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1); }, true);\\n  return histChange\\n}\\n\\n// Pop all selection events off the end of a history array. Stop at\\n// a change event.\\nfunction clearSelectionEvents(array) {\\n  while (array.length) {\\n    var last = lst(array);\\n    if (last.ranges) { array.pop(); }\\n    else { break }\\n  }\\n}\\n\\n// Find the top change event in the history. Pop off selection\\n// events that are in the way.\\nfunction lastChangeEvent(hist, force) {\\n  if (force) {\\n    clearSelectionEvents(hist.done);\\n    return lst(hist.done)\\n  } else if (hist.done.length && !lst(hist.done).ranges) {\\n    return lst(hist.done)\\n  } else if (hist.done.length > 1 && !hist.done[hist.done.length - 2].ranges) {\\n    hist.done.pop();\\n    return lst(hist.done)\\n  }\\n}\\n\\n// Register a change in the history. Merges changes that are within\\n// a single operation, or are close together with an origin that\\n// allows merging (starting with \\\"+\\\") into a single event.\\nfunction addChangeToHistory(doc, change, selAfter, opId) {\\n  var hist = doc.history;\\n  hist.undone.length = 0;\\n  var time = +new Date, cur;\\n  var last;\\n\\n  if ((hist.lastOp == opId ||\\n       hist.lastOrigin == change.origin && change.origin &&\\n       ((change.origin.charAt(0) == \\\"+\\\" && doc.cm && hist.lastModTime > time - doc.cm.options.historyEventDelay) ||\\n        change.origin.charAt(0) == \\\"*\\\")) &&\\n      (cur = lastChangeEvent(hist, hist.lastOp == opId))) {\\n    // Merge this change into the last event\\n    last = lst(cur.changes);\\n    if (cmp(change.from, change.to) == 0 && cmp(change.from, last.to) == 0) {\\n      // Optimized case for simple insertion -- don't want to add\\n      // new changesets for every character typed\\n      last.to = changeEnd(change);\\n    } else {\\n      // Add new sub-event\\n      cur.changes.push(historyChangeFromChange(doc, change));\\n    }\\n  } else {\\n    // Can not be merged, start a new event.\\n    var before = lst(hist.done);\\n    if (!before || !before.ranges)\\n      { pushSelectionToHistory(doc.sel, hist.done); }\\n    cur = {changes: [historyChangeFromChange(doc, change)],\\n           generation: hist.generation};\\n    hist.done.push(cur);\\n    while (hist.done.length > hist.undoDepth) {\\n      hist.done.shift();\\n      if (!hist.done[0].ranges) { hist.done.shift(); }\\n    }\\n  }\\n  hist.done.push(selAfter);\\n  hist.generation = ++hist.maxGeneration;\\n  hist.lastModTime = hist.lastSelTime = time;\\n  hist.lastOp = hist.lastSelOp = opId;\\n  hist.lastOrigin = hist.lastSelOrigin = change.origin;\\n\\n  if (!last) { signal(doc, \\\"historyAdded\\\"); }\\n}\\n\\nfunction selectionEventCanBeMerged(doc, origin, prev, sel) {\\n  var ch = origin.charAt(0);\\n  return ch == \\\"*\\\" ||\\n    ch == \\\"+\\\" &&\\n    prev.ranges.length == sel.ranges.length &&\\n    prev.somethingSelected() == sel.somethingSelected() &&\\n    new Date - doc.history.lastSelTime <= (doc.cm ? doc.cm.options.historyEventDelay : 500)\\n}\\n\\n// Called whenever the selection changes, sets the new selection as\\n// the pending selection in the history, and pushes the old pending\\n// selection into the 'done' array when it was significantly\\n// different (in number of selected ranges, emptiness, or time).\\nfunction addSelectionToHistory(doc, sel, opId, options) {\\n  var hist = doc.history, origin = options && options.origin;\\n\\n  // A new event is started when the previous origin does not match\\n  // the current, or the origins don't allow matching. Origins\\n  // starting with * are always merged, those starting with + are\\n  // merged when similar and close together in time.\\n  if (opId == hist.lastSelOp ||\\n      (origin && hist.lastSelOrigin == origin &&\\n       (hist.lastModTime == hist.lastSelTime && hist.lastOrigin == origin ||\\n        selectionEventCanBeMerged(doc, origin, lst(hist.done), sel))))\\n    { hist.done[hist.done.length - 1] = sel; }\\n  else\\n    { pushSelectionToHistory(sel, hist.done); }\\n\\n  hist.lastSelTime = +new Date;\\n  hist.lastSelOrigin = origin;\\n  hist.lastSelOp = opId;\\n  if (options && options.clearRedo !== false)\\n    { clearSelectionEvents(hist.undone); }\\n}\\n\\nfunction pushSelectionToHistory(sel, dest) {\\n  var top = lst(dest);\\n  if (!(top && top.ranges && top.equals(sel)))\\n    { dest.push(sel); }\\n}\\n\\n// Used to store marked span information in the history.\\nfunction attachLocalSpans(doc, change, from, to) {\\n  var existing = change[\\\"spans_\\\" + doc.id], n = 0;\\n  doc.iter(Math.max(doc.first, from), Math.min(doc.first + doc.size, to), function (line) {\\n    if (line.markedSpans)\\n      { (existing || (existing = change[\\\"spans_\\\" + doc.id] = {}))[n] = line.markedSpans; }\\n    ++n;\\n  });\\n}\\n\\n// When un/re-doing restores text containing marked spans, those\\n// that have been explicitly cleared should not be restored.\\nfunction removeClearedSpans(spans) {\\n  if (!spans) { return null }\\n  var out;\\n  for (var i = 0; i < spans.length; ++i) {\\n    if (spans[i].marker.explicitlyCleared) { if (!out) { out = spans.slice(0, i); } }\\n    else if (out) { out.push(spans[i]); }\\n  }\\n  return !out ? spans : out.length ? out : null\\n}\\n\\n// Retrieve and filter the old marked spans stored in a change event.\\nfunction getOldSpans(doc, change) {\\n  var found = change[\\\"spans_\\\" + doc.id];\\n  if (!found) { return null }\\n  var nw = [];\\n  for (var i = 0; i < change.text.length; ++i)\\n    { nw.push(removeClearedSpans(found[i])); }\\n  return nw\\n}\\n\\n// Used for un/re-doing changes from the history. Combines the\\n// result of computing the existing spans with the set of spans that\\n// existed in the history (so that deleting around a span and then\\n// undoing brings back the span).\\nfunction mergeOldSpans(doc, change) {\\n  var old = getOldSpans(doc, change);\\n  var stretched = stretchSpansOverChange(doc, change);\\n  if (!old) { return stretched }\\n  if (!stretched) { return old }\\n\\n  for (var i = 0; i < old.length; ++i) {\\n    var oldCur = old[i], stretchCur = stretched[i];\\n    if (oldCur && stretchCur) {\\n      spans: for (var j = 0; j < stretchCur.length; ++j) {\\n        var span = stretchCur[j];\\n        for (var k = 0; k < oldCur.length; ++k)\\n          { if (oldCur[k].marker == span.marker) { continue spans } }\\n        oldCur.push(span);\\n      }\\n    } else if (stretchCur) {\\n      old[i] = stretchCur;\\n    }\\n  }\\n  return old\\n}\\n\\n// Used both to provide a JSON-safe object in .getHistory, and, when\\n// detaching a document, to split the history in two\\nfunction copyHistoryArray(events, newGroup, instantiateSel) {\\n  var copy = [];\\n  for (var i = 0; i < events.length; ++i) {\\n    var event = events[i];\\n    if (event.ranges) {\\n      copy.push(instantiateSel ? Selection.prototype.deepCopy.call(event) : event);\\n      continue\\n    }\\n    var changes = event.changes, newChanges = [];\\n    copy.push({changes: newChanges});\\n    for (var j = 0; j < changes.length; ++j) {\\n      var change = changes[j], m = (void 0);\\n      newChanges.push({from: change.from, to: change.to, text: change.text});\\n      if (newGroup) { for (var prop in change) { if (m = prop.match(/^spans_(\\\\d+)$/)) {\\n        if (indexOf(newGroup, Number(m[1])) > -1) {\\n          lst(newChanges)[prop] = change[prop];\\n          delete change[prop];\\n        }\\n      } } }\\n    }\\n  }\\n  return copy\\n}\\n\\n// The 'scroll' parameter given to many of these indicated whether\\n// the new cursor position should be scrolled into view after\\n// modifying the selection.\\n\\n// If shift is held or the extend flag is set, extends a range to\\n// include a given position (and optionally a second position).\\n// Otherwise, simply returns the range between the given positions.\\n// Used for cursor motion and such.\\nfunction extendRange(doc, range, head, other) {\\n  if (doc.cm && doc.cm.display.shift || doc.extend) {\\n    var anchor = range.anchor;\\n    if (other) {\\n      var posBefore = cmp(head, anchor) < 0;\\n      if (posBefore != (cmp(other, anchor) < 0)) {\\n        anchor = head;\\n        head = other;\\n      } else if (posBefore != (cmp(head, other) < 0)) {\\n        head = other;\\n      }\\n    }\\n    return new Range(anchor, head)\\n  } else {\\n    return new Range(other || head, head)\\n  }\\n}\\n\\n// Extend the primary selection range, discard the rest.\\nfunction extendSelection(doc, head, other, options) {\\n  setSelection(doc, new Selection([extendRange(doc, doc.sel.primary(), head, other)], 0), options);\\n}\\n\\n// Extend all selections (pos is an array of selections with length\\n// equal the number of selections)\\nfunction extendSelections(doc, heads, options) {\\n  var out = [];\\n  for (var i = 0; i < doc.sel.ranges.length; i++)\\n    { out[i] = extendRange(doc, doc.sel.ranges[i], heads[i], null); }\\n  var newSel = normalizeSelection(out, doc.sel.primIndex);\\n  setSelection(doc, newSel, options);\\n}\\n\\n// Updates a single range in the selection.\\nfunction replaceOneSelection(doc, i, range, options) {\\n  var ranges = doc.sel.ranges.slice(0);\\n  ranges[i] = range;\\n  setSelection(doc, normalizeSelection(ranges, doc.sel.primIndex), options);\\n}\\n\\n// Reset the selection to a single range.\\nfunction setSimpleSelection(doc, anchor, head, options) {\\n  setSelection(doc, simpleSelection(anchor, head), options);\\n}\\n\\n// Give beforeSelectionChange handlers a change to influence a\\n// selection update.\\nfunction filterSelectionChange(doc, sel, options) {\\n  var obj = {\\n    ranges: sel.ranges,\\n    update: function(ranges) {\\n      var this$1 = this;\\n\\n      this.ranges = [];\\n      for (var i = 0; i < ranges.length; i++)\\n        { this$1.ranges[i] = new Range(clipPos(doc, ranges[i].anchor),\\n                                   clipPos(doc, ranges[i].head)); }\\n    },\\n    origin: options && options.origin\\n  };\\n  signal(doc, \\\"beforeSelectionChange\\\", doc, obj);\\n  if (doc.cm) { signal(doc.cm, \\\"beforeSelectionChange\\\", doc.cm, obj); }\\n  if (obj.ranges != sel.ranges) { return normalizeSelection(obj.ranges, obj.ranges.length - 1) }\\n  else { return sel }\\n}\\n\\nfunction setSelectionReplaceHistory(doc, sel, options) {\\n  var done = doc.history.done, last = lst(done);\\n  if (last && last.ranges) {\\n    done[done.length - 1] = sel;\\n    setSelectionNoUndo(doc, sel, options);\\n  } else {\\n    setSelection(doc, sel, options);\\n  }\\n}\\n\\n// Set a new selection.\\nfunction setSelection(doc, sel, options) {\\n  setSelectionNoUndo(doc, sel, options);\\n  addSelectionToHistory(doc, doc.sel, doc.cm ? doc.cm.curOp.id : NaN, options);\\n}\\n\\nfunction setSelectionNoUndo(doc, sel, options) {\\n  if (hasHandler(doc, \\\"beforeSelectionChange\\\") || doc.cm && hasHandler(doc.cm, \\\"beforeSelectionChange\\\"))\\n    { sel = filterSelectionChange(doc, sel, options); }\\n\\n  var bias = options && options.bias ||\\n    (cmp(sel.primary().head, doc.sel.primary().head) < 0 ? -1 : 1);\\n  setSelectionInner(doc, skipAtomicInSelection(doc, sel, bias, true));\\n\\n  if (!(options && options.scroll === false) && doc.cm)\\n    { ensureCursorVisible(doc.cm); }\\n}\\n\\nfunction setSelectionInner(doc, sel) {\\n  if (sel.equals(doc.sel)) { return }\\n\\n  doc.sel = sel;\\n\\n  if (doc.cm) {\\n    doc.cm.curOp.updateInput = doc.cm.curOp.selectionChanged = true;\\n    signalCursorActivity(doc.cm);\\n  }\\n  signalLater(doc, \\\"cursorActivity\\\", doc);\\n}\\n\\n// Verify that the selection does not partially select any atomic\\n// marked ranges.\\nfunction reCheckSelection(doc) {\\n  setSelectionInner(doc, skipAtomicInSelection(doc, doc.sel, null, false), sel_dontScroll);\\n}\\n\\n// Return a selection that does not partially select any atomic\\n// ranges.\\nfunction skipAtomicInSelection(doc, sel, bias, mayClear) {\\n  var out;\\n  for (var i = 0; i < sel.ranges.length; i++) {\\n    var range = sel.ranges[i];\\n    var old = sel.ranges.length == doc.sel.ranges.length && doc.sel.ranges[i];\\n    var newAnchor = skipAtomic(doc, range.anchor, old && old.anchor, bias, mayClear);\\n    var newHead = skipAtomic(doc, range.head, old && old.head, bias, mayClear);\\n    if (out || newAnchor != range.anchor || newHead != range.head) {\\n      if (!out) { out = sel.ranges.slice(0, i); }\\n      out[i] = new Range(newAnchor, newHead);\\n    }\\n  }\\n  return out ? normalizeSelection(out, sel.primIndex) : sel\\n}\\n\\nfunction skipAtomicInner(doc, pos, oldPos, dir, mayClear) {\\n  var line = getLine(doc, pos.line);\\n  if (line.markedSpans) { for (var i = 0; i < line.markedSpans.length; ++i) {\\n    var sp = line.markedSpans[i], m = sp.marker;\\n    if ((sp.from == null || (m.inclusiveLeft ? sp.from <= pos.ch : sp.from < pos.ch)) &&\\n        (sp.to == null || (m.inclusiveRight ? sp.to >= pos.ch : sp.to > pos.ch))) {\\n      if (mayClear) {\\n        signal(m, \\\"beforeCursorEnter\\\");\\n        if (m.explicitlyCleared) {\\n          if (!line.markedSpans) { break }\\n          else {--i; continue}\\n        }\\n      }\\n      if (!m.atomic) { continue }\\n\\n      if (oldPos) {\\n        var near = m.find(dir < 0 ? 1 : -1), diff = (void 0);\\n        if (dir < 0 ? m.inclusiveRight : m.inclusiveLeft)\\n          { near = movePos(doc, near, -dir, near && near.line == pos.line ? line : null); }\\n        if (near && near.line == pos.line && (diff = cmp(near, oldPos)) && (dir < 0 ? diff < 0 : diff > 0))\\n          { return skipAtomicInner(doc, near, pos, dir, mayClear) }\\n      }\\n\\n      var far = m.find(dir < 0 ? -1 : 1);\\n      if (dir < 0 ? m.inclusiveLeft : m.inclusiveRight)\\n        { far = movePos(doc, far, dir, far.line == pos.line ? line : null); }\\n      return far ? skipAtomicInner(doc, far, pos, dir, mayClear) : null\\n    }\\n  } }\\n  return pos\\n}\\n\\n// Ensure a given position is not inside an atomic range.\\nfunction skipAtomic(doc, pos, oldPos, bias, mayClear) {\\n  var dir = bias || 1;\\n  var found = skipAtomicInner(doc, pos, oldPos, dir, mayClear) ||\\n      (!mayClear && skipAtomicInner(doc, pos, oldPos, dir, true)) ||\\n      skipAtomicInner(doc, pos, oldPos, -dir, mayClear) ||\\n      (!mayClear && skipAtomicInner(doc, pos, oldPos, -dir, true));\\n  if (!found) {\\n    doc.cantEdit = true;\\n    return Pos(doc.first, 0)\\n  }\\n  return found\\n}\\n\\nfunction movePos(doc, pos, dir, line) {\\n  if (dir < 0 && pos.ch == 0) {\\n    if (pos.line > doc.first) { return clipPos(doc, Pos(pos.line - 1)) }\\n    else { return null }\\n  } else if (dir > 0 && pos.ch == (line || getLine(doc, pos.line)).text.length) {\\n    if (pos.line < doc.first + doc.size - 1) { return Pos(pos.line + 1, 0) }\\n    else { return null }\\n  } else {\\n    return new Pos(pos.line, pos.ch + dir)\\n  }\\n}\\n\\nfunction selectAll(cm) {\\n  cm.setSelection(Pos(cm.firstLine(), 0), Pos(cm.lastLine()), sel_dontScroll);\\n}\\n\\n// UPDATING\\n\\n// Allow \\\"beforeChange\\\" event handlers to influence a change\\nfunction filterChange(doc, change, update) {\\n  var obj = {\\n    canceled: false,\\n    from: change.from,\\n    to: change.to,\\n    text: change.text,\\n    origin: change.origin,\\n    cancel: function () { return obj.canceled = true; }\\n  };\\n  if (update) { obj.update = function (from, to, text, origin) {\\n    if (from) { obj.from = clipPos(doc, from); }\\n    if (to) { obj.to = clipPos(doc, to); }\\n    if (text) { obj.text = text; }\\n    if (origin !== undefined) { obj.origin = origin; }\\n  }; }\\n  signal(doc, \\\"beforeChange\\\", doc, obj);\\n  if (doc.cm) { signal(doc.cm, \\\"beforeChange\\\", doc.cm, obj); }\\n\\n  if (obj.canceled) { return null }\\n  return {from: obj.from, to: obj.to, text: obj.text, origin: obj.origin}\\n}\\n\\n// Apply a change to a document, and add it to the document's\\n// history, and propagating it to all linked documents.\\nfunction makeChange(doc, change, ignoreReadOnly) {\\n  if (doc.cm) {\\n    if (!doc.cm.curOp) { return operation(doc.cm, makeChange)(doc, change, ignoreReadOnly) }\\n    if (doc.cm.state.suppressEdits) { return }\\n  }\\n\\n  if (hasHandler(doc, \\\"beforeChange\\\") || doc.cm && hasHandler(doc.cm, \\\"beforeChange\\\")) {\\n    change = filterChange(doc, change, true);\\n    if (!change) { return }\\n  }\\n\\n  // Possibly split or suppress the update based on the presence\\n  // of read-only spans in its range.\\n  var split = sawReadOnlySpans && !ignoreReadOnly && removeReadOnlyRanges(doc, change.from, change.to);\\n  if (split) {\\n    for (var i = split.length - 1; i >= 0; --i)\\n      { makeChangeInner(doc, {from: split[i].from, to: split[i].to, text: i ? [\\\"\\\"] : change.text}); }\\n  } else {\\n    makeChangeInner(doc, change);\\n  }\\n}\\n\\nfunction makeChangeInner(doc, change) {\\n  if (change.text.length == 1 && change.text[0] == \\\"\\\" && cmp(change.from, change.to) == 0) { return }\\n  var selAfter = computeSelAfterChange(doc, change);\\n  addChangeToHistory(doc, change, selAfter, doc.cm ? doc.cm.curOp.id : NaN);\\n\\n  makeChangeSingleDoc(doc, change, selAfter, stretchSpansOverChange(doc, change));\\n  var rebased = [];\\n\\n  linkedDocs(doc, function (doc, sharedHist) {\\n    if (!sharedHist && indexOf(rebased, doc.history) == -1) {\\n      rebaseHist(doc.history, change);\\n      rebased.push(doc.history);\\n    }\\n    makeChangeSingleDoc(doc, change, null, stretchSpansOverChange(doc, change));\\n  });\\n}\\n\\n// Revert a change stored in a document's history.\\nfunction makeChangeFromHistory(doc, type, allowSelectionOnly) {\\n  if (doc.cm && doc.cm.state.suppressEdits && !allowSelectionOnly) { return }\\n\\n  var hist = doc.history, event, selAfter = doc.sel;\\n  var source = type == \\\"undo\\\" ? hist.done : hist.undone, dest = type == \\\"undo\\\" ? hist.undone : hist.done;\\n\\n  // Verify that there is a useable event (so that ctrl-z won't\\n  // needlessly clear selection events)\\n  var i = 0;\\n  for (; i < source.length; i++) {\\n    event = source[i];\\n    if (allowSelectionOnly ? event.ranges && !event.equals(doc.sel) : !event.ranges)\\n      { break }\\n  }\\n  if (i == source.length) { return }\\n  hist.lastOrigin = hist.lastSelOrigin = null;\\n\\n  for (;;) {\\n    event = source.pop();\\n    if (event.ranges) {\\n      pushSelectionToHistory(event, dest);\\n      if (allowSelectionOnly && !event.equals(doc.sel)) {\\n        setSelection(doc, event, {clearRedo: false});\\n        return\\n      }\\n      selAfter = event;\\n    }\\n    else { break }\\n  }\\n\\n  // Build up a reverse change object to add to the opposite history\\n  // stack (redo when undoing, and vice versa).\\n  var antiChanges = [];\\n  pushSelectionToHistory(selAfter, dest);\\n  dest.push({changes: antiChanges, generation: hist.generation});\\n  hist.generation = event.generation || ++hist.maxGeneration;\\n\\n  var filter = hasHandler(doc, \\\"beforeChange\\\") || doc.cm && hasHandler(doc.cm, \\\"beforeChange\\\");\\n\\n  var loop = function ( i ) {\\n    var change = event.changes[i];\\n    change.origin = type;\\n    if (filter && !filterChange(doc, change, false)) {\\n      source.length = 0;\\n      return {}\\n    }\\n\\n    antiChanges.push(historyChangeFromChange(doc, change));\\n\\n    var after = i ? computeSelAfterChange(doc, change) : lst(source);\\n    makeChangeSingleDoc(doc, change, after, mergeOldSpans(doc, change));\\n    if (!i && doc.cm) { doc.cm.scrollIntoView({from: change.from, to: changeEnd(change)}); }\\n    var rebased = [];\\n\\n    // Propagate to the linked documents\\n    linkedDocs(doc, function (doc, sharedHist) {\\n      if (!sharedHist && indexOf(rebased, doc.history) == -1) {\\n        rebaseHist(doc.history, change);\\n        rebased.push(doc.history);\\n      }\\n      makeChangeSingleDoc(doc, change, null, mergeOldSpans(doc, change));\\n    });\\n  };\\n\\n  for (var i$1 = event.changes.length - 1; i$1 >= 0; --i$1) {\\n    var returned = loop( i$1 );\\n\\n    if ( returned ) return returned.v;\\n  }\\n}\\n\\n// Sub-views need their line numbers shifted when text is added\\n// above or below them in the parent document.\\nfunction shiftDoc(doc, distance) {\\n  if (distance == 0) { return }\\n  doc.first += distance;\\n  doc.sel = new Selection(map(doc.sel.ranges, function (range) { return new Range(\\n    Pos(range.anchor.line + distance, range.anchor.ch),\\n    Pos(range.head.line + distance, range.head.ch)\\n  ); }), doc.sel.primIndex);\\n  if (doc.cm) {\\n    regChange(doc.cm, doc.first, doc.first - distance, distance);\\n    for (var d = doc.cm.display, l = d.viewFrom; l < d.viewTo; l++)\\n      { regLineChange(doc.cm, l, \\\"gutter\\\"); }\\n  }\\n}\\n\\n// More lower-level change function, handling only a single document\\n// (not linked ones).\\nfunction makeChangeSingleDoc(doc, change, selAfter, spans) {\\n  if (doc.cm && !doc.cm.curOp)\\n    { return operation(doc.cm, makeChangeSingleDoc)(doc, change, selAfter, spans) }\\n\\n  if (change.to.line < doc.first) {\\n    shiftDoc(doc, change.text.length - 1 - (change.to.line - change.from.line));\\n    return\\n  }\\n  if (change.from.line > doc.lastLine()) { return }\\n\\n  // Clip the change to the size of this doc\\n  if (change.from.line < doc.first) {\\n    var shift = change.text.length - 1 - (doc.first - change.from.line);\\n    shiftDoc(doc, shift);\\n    change = {from: Pos(doc.first, 0), to: Pos(change.to.line + shift, change.to.ch),\\n              text: [lst(change.text)], origin: change.origin};\\n  }\\n  var last = doc.lastLine();\\n  if (change.to.line > last) {\\n    change = {from: change.from, to: Pos(last, getLine(doc, last).text.length),\\n              text: [change.text[0]], origin: change.origin};\\n  }\\n\\n  change.removed = getBetween(doc, change.from, change.to);\\n\\n  if (!selAfter) { selAfter = computeSelAfterChange(doc, change); }\\n  if (doc.cm) { makeChangeSingleDocInEditor(doc.cm, change, spans); }\\n  else { updateDoc(doc, change, spans); }\\n  setSelectionNoUndo(doc, selAfter, sel_dontScroll);\\n}\\n\\n// Handle the interaction of a change to a document with the editor\\n// that this document is part of.\\nfunction makeChangeSingleDocInEditor(cm, change, spans) {\\n  var doc = cm.doc, display = cm.display, from = change.from, to = change.to;\\n\\n  var recomputeMaxLength = false, checkWidthStart = from.line;\\n  if (!cm.options.lineWrapping) {\\n    checkWidthStart = lineNo(visualLine(getLine(doc, from.line)));\\n    doc.iter(checkWidthStart, to.line + 1, function (line) {\\n      if (line == display.maxLine) {\\n        recomputeMaxLength = true;\\n        return true\\n      }\\n    });\\n  }\\n\\n  if (doc.sel.contains(change.from, change.to) > -1)\\n    { signalCursorActivity(cm); }\\n\\n  updateDoc(doc, change, spans, estimateHeight(cm));\\n\\n  if (!cm.options.lineWrapping) {\\n    doc.iter(checkWidthStart, from.line + change.text.length, function (line) {\\n      var len = lineLength(line);\\n      if (len > display.maxLineLength) {\\n        display.maxLine = line;\\n        display.maxLineLength = len;\\n        display.maxLineChanged = true;\\n        recomputeMaxLength = false;\\n      }\\n    });\\n    if (recomputeMaxLength) { cm.curOp.updateMaxLine = true; }\\n  }\\n\\n  // Adjust frontier, schedule worker\\n  doc.frontier = Math.min(doc.frontier, from.line);\\n  startWorker(cm, 400);\\n\\n  var lendiff = change.text.length - (to.line - from.line) - 1;\\n  // Remember that these lines changed, for updating the display\\n  if (change.full)\\n    { regChange(cm); }\\n  else if (from.line == to.line && change.text.length == 1 && !isWholeLineUpdate(cm.doc, change))\\n    { regLineChange(cm, from.line, \\\"text\\\"); }\\n  else\\n    { regChange(cm, from.line, to.line + 1, lendiff); }\\n\\n  var changesHandler = hasHandler(cm, \\\"changes\\\"), changeHandler = hasHandler(cm, \\\"change\\\");\\n  if (changeHandler || changesHandler) {\\n    var obj = {\\n      from: from, to: to,\\n      text: change.text,\\n      removed: change.removed,\\n      origin: change.origin\\n    };\\n    if (changeHandler) { signalLater(cm, \\\"change\\\", cm, obj); }\\n    if (changesHandler) { (cm.curOp.changeObjs || (cm.curOp.changeObjs = [])).push(obj); }\\n  }\\n  cm.display.selForContextMenu = null;\\n}\\n\\nfunction replaceRange(doc, code, from, to, origin) {\\n  if (!to) { to = from; }\\n  if (cmp(to, from) < 0) { var tmp = to; to = from; from = tmp; }\\n  if (typeof code == \\\"string\\\") { code = doc.splitLines(code); }\\n  makeChange(doc, {from: from, to: to, text: code, origin: origin});\\n}\\n\\n// Rebasing/resetting history to deal with externally-sourced changes\\n\\nfunction rebaseHistSelSingle(pos, from, to, diff) {\\n  if (to < pos.line) {\\n    pos.line += diff;\\n  } else if (from < pos.line) {\\n    pos.line = from;\\n    pos.ch = 0;\\n  }\\n}\\n\\n// Tries to rebase an array of history events given a change in the\\n// document. If the change touches the same lines as the event, the\\n// event, and everything 'behind' it, is discarded. If the change is\\n// before the event, the event's positions are updated. Uses a\\n// copy-on-write scheme for the positions, to avoid having to\\n// reallocate them all on every rebase, but also avoid problems with\\n// shared position objects being unsafely updated.\\nfunction rebaseHistArray(array, from, to, diff) {\\n  for (var i = 0; i < array.length; ++i) {\\n    var sub = array[i], ok = true;\\n    if (sub.ranges) {\\n      if (!sub.copied) { sub = array[i] = sub.deepCopy(); sub.copied = true; }\\n      for (var j = 0; j < sub.ranges.length; j++) {\\n        rebaseHistSelSingle(sub.ranges[j].anchor, from, to, diff);\\n        rebaseHistSelSingle(sub.ranges[j].head, from, to, diff);\\n      }\\n      continue\\n    }\\n    for (var j$1 = 0; j$1 < sub.changes.length; ++j$1) {\\n      var cur = sub.changes[j$1];\\n      if (to < cur.from.line) {\\n        cur.from = Pos(cur.from.line + diff, cur.from.ch);\\n        cur.to = Pos(cur.to.line + diff, cur.to.ch);\\n      } else if (from <= cur.to.line) {\\n        ok = false;\\n        break\\n      }\\n    }\\n    if (!ok) {\\n      array.splice(0, i + 1);\\n      i = 0;\\n    }\\n  }\\n}\\n\\nfunction rebaseHist(hist, change) {\\n  var from = change.from.line, to = change.to.line, diff = change.text.length - (to - from) - 1;\\n  rebaseHistArray(hist.done, from, to, diff);\\n  rebaseHistArray(hist.undone, from, to, diff);\\n}\\n\\n// Utility for applying a change to a line by handle or number,\\n// returning the number and optionally registering the line as\\n// changed.\\nfunction changeLine(doc, handle, changeType, op) {\\n  var no = handle, line = handle;\\n  if (typeof handle == \\\"number\\\") { line = getLine(doc, clipLine(doc, handle)); }\\n  else { no = lineNo(handle); }\\n  if (no == null) { return null }\\n  if (op(line, no) && doc.cm) { regLineChange(doc.cm, no, changeType); }\\n  return line\\n}\\n\\n// The document is represented as a BTree consisting of leaves, with\\n// chunk of lines in them, and branches, with up to ten leaves or\\n// other branch nodes below them. The top node is always a branch\\n// node, and is the document object itself (meaning it has\\n// additional methods and properties).\\n//\\n// All nodes have parent links. The tree is used both to go from\\n// line numbers to line objects, and to go from objects to numbers.\\n// It also indexes by height, and is used to convert between height\\n// and line object, and to find the total height of the document.\\n//\\n// See also http://marijnhaverbeke.nl/blog/codemirror-line-tree.html\\n\\nvar LeafChunk = function(lines) {\\n  var this$1 = this;\\n\\n  this.lines = lines;\\n  this.parent = null;\\n  var height = 0;\\n  for (var i = 0; i < lines.length; ++i) {\\n    lines[i].parent = this$1;\\n    height += lines[i].height;\\n  }\\n  this.height = height;\\n};\\n\\nLeafChunk.prototype.chunkSize = function () { return this.lines.length };\\n\\n// Remove the n lines at offset 'at'.\\nLeafChunk.prototype.removeInner = function (at, n) {\\n    var this$1 = this;\\n\\n  for (var i = at, e = at + n; i < e; ++i) {\\n    var line = this$1.lines[i];\\n    this$1.height -= line.height;\\n    cleanUpLine(line);\\n    signalLater(line, \\\"delete\\\");\\n  }\\n  this.lines.splice(at, n);\\n};\\n\\n// Helper used to collapse a small branch into a single leaf.\\nLeafChunk.prototype.collapse = function (lines) {\\n  lines.push.apply(lines, this.lines);\\n};\\n\\n// Insert the given array of lines at offset 'at', count them as\\n// having the given height.\\nLeafChunk.prototype.insertInner = function (at, lines, height) {\\n    var this$1 = this;\\n\\n  this.height += height;\\n  this.lines = this.lines.slice(0, at).concat(lines).concat(this.lines.slice(at));\\n  for (var i = 0; i < lines.length; ++i) { lines[i].parent = this$1; }\\n};\\n\\n// Used to iterate over a part of the tree.\\nLeafChunk.prototype.iterN = function (at, n, op) {\\n    var this$1 = this;\\n\\n  for (var e = at + n; at < e; ++at)\\n    { if (op(this$1.lines[at])) { return true } }\\n};\\n\\nvar BranchChunk = function(children) {\\n  var this$1 = this;\\n\\n  this.children = children;\\n  var size = 0, height = 0;\\n  for (var i = 0; i < children.length; ++i) {\\n    var ch = children[i];\\n    size += ch.chunkSize(); height += ch.height;\\n    ch.parent = this$1;\\n  }\\n  this.size = size;\\n  this.height = height;\\n  this.parent = null;\\n};\\n\\nBranchChunk.prototype.chunkSize = function () { return this.size };\\n\\nBranchChunk.prototype.removeInner = function (at, n) {\\n    var this$1 = this;\\n\\n  this.size -= n;\\n  for (var i = 0; i < this.children.length; ++i) {\\n    var child = this$1.children[i], sz = child.chunkSize();\\n    if (at < sz) {\\n      var rm = Math.min(n, sz - at), oldHeight = child.height;\\n      child.removeInner(at, rm);\\n      this$1.height -= oldHeight - child.height;\\n      if (sz == rm) { this$1.children.splice(i--, 1); child.parent = null; }\\n      if ((n -= rm) == 0) { break }\\n      at = 0;\\n    } else { at -= sz; }\\n  }\\n  // If the result is smaller than 25 lines, ensure that it is a\\n  // single leaf node.\\n  if (this.size - n < 25 &&\\n      (this.children.length > 1 || !(this.children[0] instanceof LeafChunk))) {\\n    var lines = [];\\n    this.collapse(lines);\\n    this.children = [new LeafChunk(lines)];\\n    this.children[0].parent = this;\\n  }\\n};\\n\\nBranchChunk.prototype.collapse = function (lines) {\\n    var this$1 = this;\\n\\n  for (var i = 0; i < this.children.length; ++i) { this$1.children[i].collapse(lines); }\\n};\\n\\nBranchChunk.prototype.insertInner = function (at, lines, height) {\\n    var this$1 = this;\\n\\n  this.size += lines.length;\\n  this.height += height;\\n  for (var i = 0; i < this.children.length; ++i) {\\n    var child = this$1.children[i], sz = child.chunkSize();\\n    if (at <= sz) {\\n      child.insertInner(at, lines, height);\\n      if (child.lines && child.lines.length > 50) {\\n        // To avoid memory thrashing when child.lines is huge (e.g. first view of a large file), it's never spliced.\\n        // Instead, small slices are taken. They're taken in order because sequential memory accesses are fastest.\\n        var remaining = child.lines.length % 25 + 25;\\n        for (var pos = remaining; pos < child.lines.length;) {\\n          var leaf = new LeafChunk(child.lines.slice(pos, pos += 25));\\n          child.height -= leaf.height;\\n          this$1.children.splice(++i, 0, leaf);\\n          leaf.parent = this$1;\\n        }\\n        child.lines = child.lines.slice(0, remaining);\\n        this$1.maybeSpill();\\n      }\\n      break\\n    }\\n    at -= sz;\\n  }\\n};\\n\\n// When a node has grown, check whether it should be split.\\nBranchChunk.prototype.maybeSpill = function () {\\n  if (this.children.length <= 10) { return }\\n  var me = this;\\n  do {\\n    var spilled = me.children.splice(me.children.length - 5, 5);\\n    var sibling = new BranchChunk(spilled);\\n    if (!me.parent) { // Become the parent node\\n      var copy = new BranchChunk(me.children);\\n      copy.parent = me;\\n      me.children = [copy, sibling];\\n      me = copy;\\n   } else {\\n      me.size -= sibling.size;\\n      me.height -= sibling.height;\\n      var myIndex = indexOf(me.parent.children, me);\\n      me.parent.children.splice(myIndex + 1, 0, sibling);\\n    }\\n    sibling.parent = me.parent;\\n  } while (me.children.length > 10)\\n  me.parent.maybeSpill();\\n};\\n\\nBranchChunk.prototype.iterN = function (at, n, op) {\\n    var this$1 = this;\\n\\n  for (var i = 0; i < this.children.length; ++i) {\\n    var child = this$1.children[i], sz = child.chunkSize();\\n    if (at < sz) {\\n      var used = Math.min(n, sz - at);\\n      if (child.iterN(at, used, op)) { return true }\\n      if ((n -= used) == 0) { break }\\n      at = 0;\\n    } else { at -= sz; }\\n  }\\n};\\n\\n// Line widgets are block elements displayed above or below a line.\\n\\nvar LineWidget = function(doc, node, options) {\\n  var this$1 = this;\\n\\n  if (options) { for (var opt in options) { if (options.hasOwnProperty(opt))\\n    { this$1[opt] = options[opt]; } } }\\n  this.doc = doc;\\n  this.node = node;\\n};\\n\\nLineWidget.prototype.clear = function () {\\n    var this$1 = this;\\n\\n  var cm = this.doc.cm, ws = this.line.widgets, line = this.line, no = lineNo(line);\\n  if (no == null || !ws) { return }\\n  for (var i = 0; i < ws.length; ++i) { if (ws[i] == this$1) { ws.splice(i--, 1); } }\\n  if (!ws.length) { line.widgets = null; }\\n  var height = widgetHeight(this);\\n  updateLineHeight(line, Math.max(0, line.height - height));\\n  if (cm) {\\n    runInOp(cm, function () {\\n      adjustScrollWhenAboveVisible(cm, line, -height);\\n      regLineChange(cm, no, \\\"widget\\\");\\n    });\\n    signalLater(cm, \\\"lineWidgetCleared\\\", cm, this, no);\\n  }\\n};\\n\\nLineWidget.prototype.changed = function () {\\n    var this$1 = this;\\n\\n  var oldH = this.height, cm = this.doc.cm, line = this.line;\\n  this.height = null;\\n  var diff = widgetHeight(this) - oldH;\\n  if (!diff) { return }\\n  updateLineHeight(line, line.height + diff);\\n  if (cm) {\\n    runInOp(cm, function () {\\n      cm.curOp.forceUpdate = true;\\n      adjustScrollWhenAboveVisible(cm, line, diff);\\n      signalLater(cm, \\\"lineWidgetChanged\\\", cm, this$1, lineNo(line));\\n    });\\n  }\\n};\\neventMixin(LineWidget);\\n\\nfunction adjustScrollWhenAboveVisible(cm, line, diff) {\\n  if (heightAtLine(line) < ((cm.curOp && cm.curOp.scrollTop) || cm.doc.scrollTop))\\n    { addToScrollPos(cm, null, diff); }\\n}\\n\\nfunction addLineWidget(doc, handle, node, options) {\\n  var widget = new LineWidget(doc, node, options);\\n  var cm = doc.cm;\\n  if (cm && widget.noHScroll) { cm.display.alignWidgets = true; }\\n  changeLine(doc, handle, \\\"widget\\\", function (line) {\\n    var widgets = line.widgets || (line.widgets = []);\\n    if (widget.insertAt == null) { widgets.push(widget); }\\n    else { widgets.splice(Math.min(widgets.length - 1, Math.max(0, widget.insertAt)), 0, widget); }\\n    widget.line = line;\\n    if (cm && !lineIsHidden(doc, line)) {\\n      var aboveVisible = heightAtLine(line) < doc.scrollTop;\\n      updateLineHeight(line, line.height + widgetHeight(widget));\\n      if (aboveVisible) { addToScrollPos(cm, null, widget.height); }\\n      cm.curOp.forceUpdate = true;\\n    }\\n    return true\\n  });\\n  signalLater(cm, \\\"lineWidgetAdded\\\", cm, widget, typeof handle == \\\"number\\\" ? handle : lineNo(handle));\\n  return widget\\n}\\n\\n// TEXTMARKERS\\n\\n// Created with markText and setBookmark methods. A TextMarker is a\\n// handle that can be used to clear or find a marked position in the\\n// document. Line objects hold arrays (markedSpans) containing\\n// {from, to, marker} object pointing to such marker objects, and\\n// indicating that such a marker is present on that line. Multiple\\n// lines may point to the same marker when it spans across lines.\\n// The spans will have null for their from/to properties when the\\n// marker continues beyond the start/end of the line. Markers have\\n// links back to the lines they currently touch.\\n\\n// Collapsed markers have unique ids, in order to be able to order\\n// them, which is needed for uniquely determining an outer marker\\n// when they overlap (they may nest, but not partially overlap).\\nvar nextMarkerId = 0;\\n\\nvar TextMarker = function(doc, type) {\\n  this.lines = [];\\n  this.type = type;\\n  this.doc = doc;\\n  this.id = ++nextMarkerId;\\n};\\n\\n// Clear the marker.\\nTextMarker.prototype.clear = function () {\\n    var this$1 = this;\\n\\n  if (this.explicitlyCleared) { return }\\n  var cm = this.doc.cm, withOp = cm && !cm.curOp;\\n  if (withOp) { startOperation(cm); }\\n  if (hasHandler(this, \\\"clear\\\")) {\\n    var found = this.find();\\n    if (found) { signalLater(this, \\\"clear\\\", found.from, found.to); }\\n  }\\n  var min = null, max = null;\\n  for (var i = 0; i < this.lines.length; ++i) {\\n    var line = this$1.lines[i];\\n    var span = getMarkedSpanFor(line.markedSpans, this$1);\\n    if (cm && !this$1.collapsed) { regLineChange(cm, lineNo(line), \\\"text\\\"); }\\n    else if (cm) {\\n      if (span.to != null) { max = lineNo(line); }\\n      if (span.from != null) { min = lineNo(line); }\\n    }\\n    line.markedSpans = removeMarkedSpan(line.markedSpans, span);\\n    if (span.from == null && this$1.collapsed && !lineIsHidden(this$1.doc, line) && cm)\\n      { updateLineHeight(line, textHeight(cm.display)); }\\n  }\\n  if (cm && this.collapsed && !cm.options.lineWrapping) { for (var i$1 = 0; i$1 < this.lines.length; ++i$1) {\\n    var visual = visualLine(this$1.lines[i$1]), len = lineLength(visual);\\n    if (len > cm.display.maxLineLength) {\\n      cm.display.maxLine = visual;\\n      cm.display.maxLineLength = len;\\n      cm.display.maxLineChanged = true;\\n    }\\n  } }\\n\\n  if (min != null && cm && this.collapsed) { regChange(cm, min, max + 1); }\\n  this.lines.length = 0;\\n  this.explicitlyCleared = true;\\n  if (this.atomic && this.doc.cantEdit) {\\n    this.doc.cantEdit = false;\\n    if (cm) { reCheckSelection(cm.doc); }\\n  }\\n  if (cm) { signalLater(cm, \\\"markerCleared\\\", cm, this, min, max); }\\n  if (withOp) { endOperation(cm); }\\n  if (this.parent) { this.parent.clear(); }\\n};\\n\\n// Find the position of the marker in the document. Returns a {from,\\n// to} object by default. Side can be passed to get a specific side\\n// -- 0 (both), -1 (left), or 1 (right). When lineObj is true, the\\n// Pos objects returned contain a line object, rather than a line\\n// number (used to prevent looking up the same line twice).\\nTextMarker.prototype.find = function (side, lineObj) {\\n    var this$1 = this;\\n\\n  if (side == null && this.type == \\\"bookmark\\\") { side = 1; }\\n  var from, to;\\n  for (var i = 0; i < this.lines.length; ++i) {\\n    var line = this$1.lines[i];\\n    var span = getMarkedSpanFor(line.markedSpans, this$1);\\n    if (span.from != null) {\\n      from = Pos(lineObj ? line : lineNo(line), span.from);\\n      if (side == -1) { return from }\\n    }\\n    if (span.to != null) {\\n      to = Pos(lineObj ? line : lineNo(line), span.to);\\n      if (side == 1) { return to }\\n    }\\n  }\\n  return from && {from: from, to: to}\\n};\\n\\n// Signals that the marker's widget changed, and surrounding layout\\n// should be recomputed.\\nTextMarker.prototype.changed = function () {\\n    var this$1 = this;\\n\\n  var pos = this.find(-1, true), widget = this, cm = this.doc.cm;\\n  if (!pos || !cm) { return }\\n  runInOp(cm, function () {\\n    var line = pos.line, lineN = lineNo(pos.line);\\n    var view = findViewForLine(cm, lineN);\\n    if (view) {\\n      clearLineMeasurementCacheFor(view);\\n      cm.curOp.selectionChanged = cm.curOp.forceUpdate = true;\\n    }\\n    cm.curOp.updateMaxLine = true;\\n    if (!lineIsHidden(widget.doc, line) && widget.height != null) {\\n      var oldHeight = widget.height;\\n      widget.height = null;\\n      var dHeight = widgetHeight(widget) - oldHeight;\\n      if (dHeight)\\n        { updateLineHeight(line, line.height + dHeight); }\\n    }\\n    signalLater(cm, \\\"markerChanged\\\", cm, this$1);\\n  });\\n};\\n\\nTextMarker.prototype.attachLine = function (line) {\\n  if (!this.lines.length && this.doc.cm) {\\n    var op = this.doc.cm.curOp;\\n    if (!op.maybeHiddenMarkers || indexOf(op.maybeHiddenMarkers, this) == -1)\\n      { (op.maybeUnhiddenMarkers || (op.maybeUnhiddenMarkers = [])).push(this); }\\n  }\\n  this.lines.push(line);\\n};\\n\\nTextMarker.prototype.detachLine = function (line) {\\n  this.lines.splice(indexOf(this.lines, line), 1);\\n  if (!this.lines.length && this.doc.cm) {\\n    var op = this.doc.cm.curOp;(op.maybeHiddenMarkers || (op.maybeHiddenMarkers = [])).push(this);\\n  }\\n};\\neventMixin(TextMarker);\\n\\n// Create a marker, wire it up to the right lines, and\\nfunction markText(doc, from, to, options, type) {\\n  // Shared markers (across linked documents) are handled separately\\n  // (markTextShared will call out to this again, once per\\n  // document).\\n  if (options && options.shared) { return markTextShared(doc, from, to, options, type) }\\n  // Ensure we are in an operation.\\n  if (doc.cm && !doc.cm.curOp) { return operation(doc.cm, markText)(doc, from, to, options, type) }\\n\\n  var marker = new TextMarker(doc, type), diff = cmp(from, to);\\n  if (options) { copyObj(options, marker, false); }\\n  // Don't connect empty markers unless clearWhenEmpty is false\\n  if (diff > 0 || diff == 0 && marker.clearWhenEmpty !== false)\\n    { return marker }\\n  if (marker.replacedWith) {\\n    // Showing up as a widget implies collapsed (widget replaces text)\\n    marker.collapsed = true;\\n    marker.widgetNode = eltP(\\\"span\\\", [marker.replacedWith], \\\"CodeMirror-widget\\\");\\n    if (!options.handleMouseEvents) { marker.widgetNode.setAttribute(\\\"cm-ignore-events\\\", \\\"true\\\"); }\\n    if (options.insertLeft) { marker.widgetNode.insertLeft = true; }\\n  }\\n  if (marker.collapsed) {\\n    if (conflictingCollapsedRange(doc, from.line, from, to, marker) ||\\n        from.line != to.line && conflictingCollapsedRange(doc, to.line, from, to, marker))\\n      { throw new Error(\\\"Inserting collapsed marker partially overlapping an existing one\\\") }\\n    seeCollapsedSpans();\\n  }\\n\\n  if (marker.addToHistory)\\n    { addChangeToHistory(doc, {from: from, to: to, origin: \\\"markText\\\"}, doc.sel, NaN); }\\n\\n  var curLine = from.line, cm = doc.cm, updateMaxLine;\\n  doc.iter(curLine, to.line + 1, function (line) {\\n    if (cm && marker.collapsed && !cm.options.lineWrapping && visualLine(line) == cm.display.maxLine)\\n      { updateMaxLine = true; }\\n    if (marker.collapsed && curLine != from.line) { updateLineHeight(line, 0); }\\n    addMarkedSpan(line, new MarkedSpan(marker,\\n                                       curLine == from.line ? from.ch : null,\\n                                       curLine == to.line ? to.ch : null));\\n    ++curLine;\\n  });\\n  // lineIsHidden depends on the presence of the spans, so needs a second pass\\n  if (marker.collapsed) { doc.iter(from.line, to.line + 1, function (line) {\\n    if (lineIsHidden(doc, line)) { updateLineHeight(line, 0); }\\n  }); }\\n\\n  if (marker.clearOnEnter) { on(marker, \\\"beforeCursorEnter\\\", function () { return marker.clear(); }); }\\n\\n  if (marker.readOnly) {\\n    seeReadOnlySpans();\\n    if (doc.history.done.length || doc.history.undone.length)\\n      { doc.clearHistory(); }\\n  }\\n  if (marker.collapsed) {\\n    marker.id = ++nextMarkerId;\\n    marker.atomic = true;\\n  }\\n  if (cm) {\\n    // Sync editor state\\n    if (updateMaxLine) { cm.curOp.updateMaxLine = true; }\\n    if (marker.collapsed)\\n      { regChange(cm, from.line, to.line + 1); }\\n    else if (marker.className || marker.title || marker.startStyle || marker.endStyle || marker.css)\\n      { for (var i = from.line; i <= to.line; i++) { regLineChange(cm, i, \\\"text\\\"); } }\\n    if (marker.atomic) { reCheckSelection(cm.doc); }\\n    signalLater(cm, \\\"markerAdded\\\", cm, marker);\\n  }\\n  return marker\\n}\\n\\n// SHARED TEXTMARKERS\\n\\n// A shared marker spans multiple linked documents. It is\\n// implemented as a meta-marker-object controlling multiple normal\\n// markers.\\nvar SharedTextMarker = function(markers, primary) {\\n  var this$1 = this;\\n\\n  this.markers = markers;\\n  this.primary = primary;\\n  for (var i = 0; i < markers.length; ++i)\\n    { markers[i].parent = this$1; }\\n};\\n\\nSharedTextMarker.prototype.clear = function () {\\n    var this$1 = this;\\n\\n  if (this.explicitlyCleared) { return }\\n  this.explicitlyCleared = true;\\n  for (var i = 0; i < this.markers.length; ++i)\\n    { this$1.markers[i].clear(); }\\n  signalLater(this, \\\"clear\\\");\\n};\\n\\nSharedTextMarker.prototype.find = function (side, lineObj) {\\n  return this.primary.find(side, lineObj)\\n};\\neventMixin(SharedTextMarker);\\n\\nfunction markTextShared(doc, from, to, options, type) {\\n  options = copyObj(options);\\n  options.shared = false;\\n  var markers = [markText(doc, from, to, options, type)], primary = markers[0];\\n  var widget = options.widgetNode;\\n  linkedDocs(doc, function (doc) {\\n    if (widget) { options.widgetNode = widget.cloneNode(true); }\\n    markers.push(markText(doc, clipPos(doc, from), clipPos(doc, to), options, type));\\n    for (var i = 0; i < doc.linked.length; ++i)\\n      { if (doc.linked[i].isParent) { return } }\\n    primary = lst(markers);\\n  });\\n  return new SharedTextMarker(markers, primary)\\n}\\n\\nfunction findSharedMarkers(doc) {\\n  return doc.findMarks(Pos(doc.first, 0), doc.clipPos(Pos(doc.lastLine())), function (m) { return m.parent; })\\n}\\n\\nfunction copySharedMarkers(doc, markers) {\\n  for (var i = 0; i < markers.length; i++) {\\n    var marker = markers[i], pos = marker.find();\\n    var mFrom = doc.clipPos(pos.from), mTo = doc.clipPos(pos.to);\\n    if (cmp(mFrom, mTo)) {\\n      var subMark = markText(doc, mFrom, mTo, marker.primary, marker.primary.type);\\n      marker.markers.push(subMark);\\n      subMark.parent = marker;\\n    }\\n  }\\n}\\n\\nfunction detachSharedMarkers(markers) {\\n  var loop = function ( i ) {\\n    var marker = markers[i], linked = [marker.primary.doc];\\n    linkedDocs(marker.primary.doc, function (d) { return linked.push(d); });\\n    for (var j = 0; j < marker.markers.length; j++) {\\n      var subMarker = marker.markers[j];\\n      if (indexOf(linked, subMarker.doc) == -1) {\\n        subMarker.parent = null;\\n        marker.markers.splice(j--, 1);\\n      }\\n    }\\n  };\\n\\n  for (var i = 0; i < markers.length; i++) loop( i );\\n}\\n\\nvar nextDocId = 0;\\nvar Doc = function(text, mode, firstLine, lineSep, direction) {\\n  if (!(this instanceof Doc)) { return new Doc(text, mode, firstLine, lineSep, direction) }\\n  if (firstLine == null) { firstLine = 0; }\\n\\n  BranchChunk.call(this, [new LeafChunk([new Line(\\\"\\\", null)])]);\\n  this.first = firstLine;\\n  this.scrollTop = this.scrollLeft = 0;\\n  this.cantEdit = false;\\n  this.cleanGeneration = 1;\\n  this.frontier = firstLine;\\n  var start = Pos(firstLine, 0);\\n  this.sel = simpleSelection(start);\\n  this.history = new History(null);\\n  this.id = ++nextDocId;\\n  this.modeOption = mode;\\n  this.lineSep = lineSep;\\n  this.direction = (direction == \\\"rtl\\\") ? \\\"rtl\\\" : \\\"ltr\\\";\\n  this.extend = false;\\n\\n  if (typeof text == \\\"string\\\") { text = this.splitLines(text); }\\n  updateDoc(this, {from: start, to: start, text: text});\\n  setSelection(this, simpleSelection(start), sel_dontScroll);\\n};\\n\\nDoc.prototype = createObj(BranchChunk.prototype, {\\n  constructor: Doc,\\n  // Iterate over the document. Supports two forms -- with only one\\n  // argument, it calls that for each line in the document. With\\n  // three, it iterates over the range given by the first two (with\\n  // the second being non-inclusive).\\n  iter: function(from, to, op) {\\n    if (op) { this.iterN(from - this.first, to - from, op); }\\n    else { this.iterN(this.first, this.first + this.size, from); }\\n  },\\n\\n  // Non-public interface for adding and removing lines.\\n  insert: function(at, lines) {\\n    var height = 0;\\n    for (var i = 0; i < lines.length; ++i) { height += lines[i].height; }\\n    this.insertInner(at - this.first, lines, height);\\n  },\\n  remove: function(at, n) { this.removeInner(at - this.first, n); },\\n\\n  // From here, the methods are part of the public interface. Most\\n  // are also available from CodeMirror (editor) instances.\\n\\n  getValue: function(lineSep) {\\n    var lines = getLines(this, this.first, this.first + this.size);\\n    if (lineSep === false) { return lines }\\n    return lines.join(lineSep || this.lineSeparator())\\n  },\\n  setValue: docMethodOp(function(code) {\\n    var top = Pos(this.first, 0), last = this.first + this.size - 1;\\n    makeChange(this, {from: top, to: Pos(last, getLine(this, last).text.length),\\n                      text: this.splitLines(code), origin: \\\"setValue\\\", full: true}, true);\\n    setSelection(this, simpleSelection(top));\\n  }),\\n  replaceRange: function(code, from, to, origin) {\\n    from = clipPos(this, from);\\n    to = to ? clipPos(this, to) : from;\\n    replaceRange(this, code, from, to, origin);\\n  },\\n  getRange: function(from, to, lineSep) {\\n    var lines = getBetween(this, clipPos(this, from), clipPos(this, to));\\n    if (lineSep === false) { return lines }\\n    return lines.join(lineSep || this.lineSeparator())\\n  },\\n\\n  getLine: function(line) {var l = this.getLineHandle(line); return l && l.text},\\n\\n  getLineHandle: function(line) {if (isLine(this, line)) { return getLine(this, line) }},\\n  getLineNumber: function(line) {return lineNo(line)},\\n\\n  getLineHandleVisualStart: function(line) {\\n    if (typeof line == \\\"number\\\") { line = getLine(this, line); }\\n    return visualLine(line)\\n  },\\n\\n  lineCount: function() {return this.size},\\n  firstLine: function() {return this.first},\\n  lastLine: function() {return this.first + this.size - 1},\\n\\n  clipPos: function(pos) {return clipPos(this, pos)},\\n\\n  getCursor: function(start) {\\n    var range$$1 = this.sel.primary(), pos;\\n    if (start == null || start == \\\"head\\\") { pos = range$$1.head; }\\n    else if (start == \\\"anchor\\\") { pos = range$$1.anchor; }\\n    else if (start == \\\"end\\\" || start == \\\"to\\\" || start === false) { pos = range$$1.to(); }\\n    else { pos = range$$1.from(); }\\n    return pos\\n  },\\n  listSelections: function() { return this.sel.ranges },\\n  somethingSelected: function() {return this.sel.somethingSelected()},\\n\\n  setCursor: docMethodOp(function(line, ch, options) {\\n    setSimpleSelection(this, clipPos(this, typeof line == \\\"number\\\" ? Pos(line, ch || 0) : line), null, options);\\n  }),\\n  setSelection: docMethodOp(function(anchor, head, options) {\\n    setSimpleSelection(this, clipPos(this, anchor), clipPos(this, head || anchor), options);\\n  }),\\n  extendSelection: docMethodOp(function(head, other, options) {\\n    extendSelection(this, clipPos(this, head), other && clipPos(this, other), options);\\n  }),\\n  extendSelections: docMethodOp(function(heads, options) {\\n    extendSelections(this, clipPosArray(this, heads), options);\\n  }),\\n  extendSelectionsBy: docMethodOp(function(f, options) {\\n    var heads = map(this.sel.ranges, f);\\n    extendSelections(this, clipPosArray(this, heads), options);\\n  }),\\n  setSelections: docMethodOp(function(ranges, primary, options) {\\n    var this$1 = this;\\n\\n    if (!ranges.length) { return }\\n    var out = [];\\n    for (var i = 0; i < ranges.length; i++)\\n      { out[i] = new Range(clipPos(this$1, ranges[i].anchor),\\n                         clipPos(this$1, ranges[i].head)); }\\n    if (primary == null) { primary = Math.min(ranges.length - 1, this.sel.primIndex); }\\n    setSelection(this, normalizeSelection(out, primary), options);\\n  }),\\n  addSelection: docMethodOp(function(anchor, head, options) {\\n    var ranges = this.sel.ranges.slice(0);\\n    ranges.push(new Range(clipPos(this, anchor), clipPos(this, head || anchor)));\\n    setSelection(this, normalizeSelection(ranges, ranges.length - 1), options);\\n  }),\\n\\n  getSelection: function(lineSep) {\\n    var this$1 = this;\\n\\n    var ranges = this.sel.ranges, lines;\\n    for (var i = 0; i < ranges.length; i++) {\\n      var sel = getBetween(this$1, ranges[i].from(), ranges[i].to());\\n      lines = lines ? lines.concat(sel) : sel;\\n    }\\n    if (lineSep === false) { return lines }\\n    else { return lines.join(lineSep || this.lineSeparator()) }\\n  },\\n  getSelections: function(lineSep) {\\n    var this$1 = this;\\n\\n    var parts = [], ranges = this.sel.ranges;\\n    for (var i = 0; i < ranges.length; i++) {\\n      var sel = getBetween(this$1, ranges[i].from(), ranges[i].to());\\n      if (lineSep !== false) { sel = sel.join(lineSep || this$1.lineSeparator()); }\\n      parts[i] = sel;\\n    }\\n    return parts\\n  },\\n  replaceSelection: function(code, collapse, origin) {\\n    var dup = [];\\n    for (var i = 0; i < this.sel.ranges.length; i++)\\n      { dup[i] = code; }\\n    this.replaceSelections(dup, collapse, origin || \\\"+input\\\");\\n  },\\n  replaceSelections: docMethodOp(function(code, collapse, origin) {\\n    var this$1 = this;\\n\\n    var changes = [], sel = this.sel;\\n    for (var i = 0; i < sel.ranges.length; i++) {\\n      var range$$1 = sel.ranges[i];\\n      changes[i] = {from: range$$1.from(), to: range$$1.to(), text: this$1.splitLines(code[i]), origin: origin};\\n    }\\n    var newSel = collapse && collapse != \\\"end\\\" && computeReplacedSel(this, changes, collapse);\\n    for (var i$1 = changes.length - 1; i$1 >= 0; i$1--)\\n      { makeChange(this$1, changes[i$1]); }\\n    if (newSel) { setSelectionReplaceHistory(this, newSel); }\\n    else if (this.cm) { ensureCursorVisible(this.cm); }\\n  }),\\n  undo: docMethodOp(function() {makeChangeFromHistory(this, \\\"undo\\\");}),\\n  redo: docMethodOp(function() {makeChangeFromHistory(this, \\\"redo\\\");}),\\n  undoSelection: docMethodOp(function() {makeChangeFromHistory(this, \\\"undo\\\", true);}),\\n  redoSelection: docMethodOp(function() {makeChangeFromHistory(this, \\\"redo\\\", true);}),\\n\\n  setExtending: function(val) {this.extend = val;},\\n  getExtending: function() {return this.extend},\\n\\n  historySize: function() {\\n    var hist = this.history, done = 0, undone = 0;\\n    for (var i = 0; i < hist.done.length; i++) { if (!hist.done[i].ranges) { ++done; } }\\n    for (var i$1 = 0; i$1 < hist.undone.length; i$1++) { if (!hist.undone[i$1].ranges) { ++undone; } }\\n    return {undo: done, redo: undone}\\n  },\\n  clearHistory: function() {this.history = new History(this.history.maxGeneration);},\\n\\n  markClean: function() {\\n    this.cleanGeneration = this.changeGeneration(true);\\n  },\\n  changeGeneration: function(forceSplit) {\\n    if (forceSplit)\\n      { this.history.lastOp = this.history.lastSelOp = this.history.lastOrigin = null; }\\n    return this.history.generation\\n  },\\n  isClean: function (gen) {\\n    return this.history.generation == (gen || this.cleanGeneration)\\n  },\\n\\n  getHistory: function() {\\n    return {done: copyHistoryArray(this.history.done),\\n            undone: copyHistoryArray(this.history.undone)}\\n  },\\n  setHistory: function(histData) {\\n    var hist = this.history = new History(this.history.maxGeneration);\\n    hist.done = copyHistoryArray(histData.done.slice(0), null, true);\\n    hist.undone = copyHistoryArray(histData.undone.slice(0), null, true);\\n  },\\n\\n  setGutterMarker: docMethodOp(function(line, gutterID, value) {\\n    return changeLine(this, line, \\\"gutter\\\", function (line) {\\n      var markers = line.gutterMarkers || (line.gutterMarkers = {});\\n      markers[gutterID] = value;\\n      if (!value && isEmpty(markers)) { line.gutterMarkers = null; }\\n      return true\\n    })\\n  }),\\n\\n  clearGutter: docMethodOp(function(gutterID) {\\n    var this$1 = this;\\n\\n    this.iter(function (line) {\\n      if (line.gutterMarkers && line.gutterMarkers[gutterID]) {\\n        changeLine(this$1, line, \\\"gutter\\\", function () {\\n          line.gutterMarkers[gutterID] = null;\\n          if (isEmpty(line.gutterMarkers)) { line.gutterMarkers = null; }\\n          return true\\n        });\\n      }\\n    });\\n  }),\\n\\n  lineInfo: function(line) {\\n    var n;\\n    if (typeof line == \\\"number\\\") {\\n      if (!isLine(this, line)) { return null }\\n      n = line;\\n      line = getLine(this, line);\\n      if (!line) { return null }\\n    } else {\\n      n = lineNo(line);\\n      if (n == null) { return null }\\n    }\\n    return {line: n, handle: line, text: line.text, gutterMarkers: line.gutterMarkers,\\n            textClass: line.textClass, bgClass: line.bgClass, wrapClass: line.wrapClass,\\n            widgets: line.widgets}\\n  },\\n\\n  addLineClass: docMethodOp(function(handle, where, cls) {\\n    return changeLine(this, handle, where == \\\"gutter\\\" ? \\\"gutter\\\" : \\\"class\\\", function (line) {\\n      var prop = where == \\\"text\\\" ? \\\"textClass\\\"\\n               : where == \\\"background\\\" ? \\\"bgClass\\\"\\n               : where == \\\"gutter\\\" ? \\\"gutterClass\\\" : \\\"wrapClass\\\";\\n      if (!line[prop]) { line[prop] = cls; }\\n      else if (classTest(cls).test(line[prop])) { return false }\\n      else { line[prop] += \\\" \\\" + cls; }\\n      return true\\n    })\\n  }),\\n  removeLineClass: docMethodOp(function(handle, where, cls) {\\n    return changeLine(this, handle, where == \\\"gutter\\\" ? \\\"gutter\\\" : \\\"class\\\", function (line) {\\n      var prop = where == \\\"text\\\" ? \\\"textClass\\\"\\n               : where == \\\"background\\\" ? \\\"bgClass\\\"\\n               : where == \\\"gutter\\\" ? \\\"gutterClass\\\" : \\\"wrapClass\\\";\\n      var cur = line[prop];\\n      if (!cur) { return false }\\n      else if (cls == null) { line[prop] = null; }\\n      else {\\n        var found = cur.match(classTest(cls));\\n        if (!found) { return false }\\n        var end = found.index + found[0].length;\\n        line[prop] = cur.slice(0, found.index) + (!found.index || end == cur.length ? \\\"\\\" : \\\" \\\") + cur.slice(end) || null;\\n      }\\n      return true\\n    })\\n  }),\\n\\n  addLineWidget: docMethodOp(function(handle, node, options) {\\n    return addLineWidget(this, handle, node, options)\\n  }),\\n  removeLineWidget: function(widget) { widget.clear(); },\\n\\n  markText: function(from, to, options) {\\n    return markText(this, clipPos(this, from), clipPos(this, to), options, options && options.type || \\\"range\\\")\\n  },\\n  setBookmark: function(pos, options) {\\n    var realOpts = {replacedWith: options && (options.nodeType == null ? options.widget : options),\\n                    insertLeft: options && options.insertLeft,\\n                    clearWhenEmpty: false, shared: options && options.shared,\\n                    handleMouseEvents: options && options.handleMouseEvents};\\n    pos = clipPos(this, pos);\\n    return markText(this, pos, pos, realOpts, \\\"bookmark\\\")\\n  },\\n  findMarksAt: function(pos) {\\n    pos = clipPos(this, pos);\\n    var markers = [], spans = getLine(this, pos.line).markedSpans;\\n    if (spans) { for (var i = 0; i < spans.length; ++i) {\\n      var span = spans[i];\\n      if ((span.from == null || span.from <= pos.ch) &&\\n          (span.to == null || span.to >= pos.ch))\\n        { markers.push(span.marker.parent || span.marker); }\\n    } }\\n    return markers\\n  },\\n  findMarks: function(from, to, filter) {\\n    from = clipPos(this, from); to = clipPos(this, to);\\n    var found = [], lineNo$$1 = from.line;\\n    this.iter(from.line, to.line + 1, function (line) {\\n      var spans = line.markedSpans;\\n      if (spans) { for (var i = 0; i < spans.length; i++) {\\n        var span = spans[i];\\n        if (!(span.to != null && lineNo$$1 == from.line && from.ch >= span.to ||\\n              span.from == null && lineNo$$1 != from.line ||\\n              span.from != null && lineNo$$1 == to.line && span.from >= to.ch) &&\\n            (!filter || filter(span.marker)))\\n          { found.push(span.marker.parent || span.marker); }\\n      } }\\n      ++lineNo$$1;\\n    });\\n    return found\\n  },\\n  getAllMarks: function() {\\n    var markers = [];\\n    this.iter(function (line) {\\n      var sps = line.markedSpans;\\n      if (sps) { for (var i = 0; i < sps.length; ++i)\\n        { if (sps[i].from != null) { markers.push(sps[i].marker); } } }\\n    });\\n    return markers\\n  },\\n\\n  posFromIndex: function(off) {\\n    var ch, lineNo$$1 = this.first, sepSize = this.lineSeparator().length;\\n    this.iter(function (line) {\\n      var sz = line.text.length + sepSize;\\n      if (sz > off) { ch = off; return true }\\n      off -= sz;\\n      ++lineNo$$1;\\n    });\\n    return clipPos(this, Pos(lineNo$$1, ch))\\n  },\\n  indexFromPos: function (coords) {\\n    coords = clipPos(this, coords);\\n    var index = coords.ch;\\n    if (coords.line < this.first || coords.ch < 0) { return 0 }\\n    var sepSize = this.lineSeparator().length;\\n    this.iter(this.first, coords.line, function (line) { // iter aborts when callback returns a truthy value\\n      index += line.text.length + sepSize;\\n    });\\n    return index\\n  },\\n\\n  copy: function(copyHistory) {\\n    var doc = new Doc(getLines(this, this.first, this.first + this.size),\\n                      this.modeOption, this.first, this.lineSep, this.direction);\\n    doc.scrollTop = this.scrollTop; doc.scrollLeft = this.scrollLeft;\\n    doc.sel = this.sel;\\n    doc.extend = false;\\n    if (copyHistory) {\\n      doc.history.undoDepth = this.history.undoDepth;\\n      doc.setHistory(this.getHistory());\\n    }\\n    return doc\\n  },\\n\\n  linkedDoc: function(options) {\\n    if (!options) { options = {}; }\\n    var from = this.first, to = this.first + this.size;\\n    if (options.from != null && options.from > from) { from = options.from; }\\n    if (options.to != null && options.to < to) { to = options.to; }\\n    var copy = new Doc(getLines(this, from, to), options.mode || this.modeOption, from, this.lineSep, this.direction);\\n    if (options.sharedHist) { copy.history = this.history\\n    ; }(this.linked || (this.linked = [])).push({doc: copy, sharedHist: options.sharedHist});\\n    copy.linked = [{doc: this, isParent: true, sharedHist: options.sharedHist}];\\n    copySharedMarkers(copy, findSharedMarkers(this));\\n    return copy\\n  },\\n  unlinkDoc: function(other) {\\n    var this$1 = this;\\n\\n    if (other instanceof CodeMirror$1) { other = other.doc; }\\n    if (this.linked) { for (var i = 0; i < this.linked.length; ++i) {\\n      var link = this$1.linked[i];\\n      if (link.doc != other) { continue }\\n      this$1.linked.splice(i, 1);\\n      other.unlinkDoc(this$1);\\n      detachSharedMarkers(findSharedMarkers(this$1));\\n      break\\n    } }\\n    // If the histories were shared, split them again\\n    if (other.history == this.history) {\\n      var splitIds = [other.id];\\n      linkedDocs(other, function (doc) { return splitIds.push(doc.id); }, true);\\n      other.history = new History(null);\\n      other.history.done = copyHistoryArray(this.history.done, splitIds);\\n      other.history.undone = copyHistoryArray(this.history.undone, splitIds);\\n    }\\n  },\\n  iterLinkedDocs: function(f) {linkedDocs(this, f);},\\n\\n  getMode: function() {return this.mode},\\n  getEditor: function() {return this.cm},\\n\\n  splitLines: function(str) {\\n    if (this.lineSep) { return str.split(this.lineSep) }\\n    return splitLinesAuto(str)\\n  },\\n  lineSeparator: function() { return this.lineSep || \\\"\\\\n\\\" },\\n\\n  setDirection: docMethodOp(function (dir) {\\n    if (dir != \\\"rtl\\\") { dir = \\\"ltr\\\"; }\\n    if (dir == this.direction) { return }\\n    this.direction = dir;\\n    this.iter(function (line) { return line.order = null; });\\n    if (this.cm) { directionChanged(this.cm); }\\n  })\\n});\\n\\n// Public alias.\\nDoc.prototype.eachLine = Doc.prototype.iter;\\n\\n// Kludge to work around strange IE behavior where it'll sometimes\\n// re-fire a series of drag-related events right after the drop (#1551)\\nvar lastDrop = 0;\\n\\nfunction onDrop(e) {\\n  var cm = this;\\n  clearDragCursor(cm);\\n  if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e))\\n    { return }\\n  e_preventDefault(e);\\n  if (ie) { lastDrop = +new Date; }\\n  var pos = posFromMouse(cm, e, true), files = e.dataTransfer.files;\\n  if (!pos || cm.isReadOnly()) { return }\\n  // Might be a file drop, in which case we simply extract the text\\n  // and insert it.\\n  if (files && files.length && window.FileReader && window.File) {\\n    var n = files.length, text = Array(n), read = 0;\\n    var loadFile = function (file, i) {\\n      if (cm.options.allowDropFileTypes &&\\n          indexOf(cm.options.allowDropFileTypes, file.type) == -1)\\n        { return }\\n\\n      var reader = new FileReader;\\n      reader.onload = operation(cm, function () {\\n        var content = reader.result;\\n        if (/[\\\\x00-\\\\x08\\\\x0e-\\\\x1f]{2}/.test(content)) { content = \\\"\\\"; }\\n        text[i] = content;\\n        if (++read == n) {\\n          pos = clipPos(cm.doc, pos);\\n          var change = {from: pos, to: pos,\\n                        text: cm.doc.splitLines(text.join(cm.doc.lineSeparator())),\\n                        origin: \\\"paste\\\"};\\n          makeChange(cm.doc, change);\\n          setSelectionReplaceHistory(cm.doc, simpleSelection(pos, changeEnd(change)));\\n        }\\n      });\\n      reader.readAsText(file);\\n    };\\n    for (var i = 0; i < n; ++i) { loadFile(files[i], i); }\\n  } else { // Normal drop\\n    // Don't do a replace if the drop happened inside of the selected text.\\n    if (cm.state.draggingText && cm.doc.sel.contains(pos) > -1) {\\n      cm.state.draggingText(e);\\n      // Ensure the editor is re-focused\\n      setTimeout(function () { return cm.display.input.focus(); }, 20);\\n      return\\n    }\\n    try {\\n      var text$1 = e.dataTransfer.getData(\\\"Text\\\");\\n      if (text$1) {\\n        var selected;\\n        if (cm.state.draggingText && !cm.state.draggingText.copy)\\n          { selected = cm.listSelections(); }\\n        setSelectionNoUndo(cm.doc, simpleSelection(pos, pos));\\n        if (selected) { for (var i$1 = 0; i$1 < selected.length; ++i$1)\\n          { replaceRange(cm.doc, \\\"\\\", selected[i$1].anchor, selected[i$1].head, \\\"drag\\\"); } }\\n        cm.replaceSelection(text$1, \\\"around\\\", \\\"paste\\\");\\n        cm.display.input.focus();\\n      }\\n    }\\n    catch(e){}\\n  }\\n}\\n\\nfunction onDragStart(cm, e) {\\n  if (ie && (!cm.state.draggingText || +new Date - lastDrop < 100)) { e_stop(e); return }\\n  if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e)) { return }\\n\\n  e.dataTransfer.setData(\\\"Text\\\", cm.getSelection());\\n  e.dataTransfer.effectAllowed = \\\"copyMove\\\";\\n\\n  // Use dummy image instead of default browsers image.\\n  // Recent Safari (~6.0.2) have a tendency to segfault when this happens, so we don't do it there.\\n  if (e.dataTransfer.setDragImage && !safari) {\\n    var img = elt(\\\"img\\\", null, null, \\\"position: fixed; left: 0; top: 0;\\\");\\n    img.src = \\\"data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\\\";\\n    if (presto) {\\n      img.width = img.height = 1;\\n      cm.display.wrapper.appendChild(img);\\n      // Force a relayout, or Opera won't use our image for some obscure reason\\n      img._top = img.offsetTop;\\n    }\\n    e.dataTransfer.setDragImage(img, 0, 0);\\n    if (presto) { img.parentNode.removeChild(img); }\\n  }\\n}\\n\\nfunction onDragOver(cm, e) {\\n  var pos = posFromMouse(cm, e);\\n  if (!pos) { return }\\n  var frag = document.createDocumentFragment();\\n  drawSelectionCursor(cm, pos, frag);\\n  if (!cm.display.dragCursor) {\\n    cm.display.dragCursor = elt(\\\"div\\\", null, \\\"CodeMirror-cursors CodeMirror-dragcursors\\\");\\n    cm.display.lineSpace.insertBefore(cm.display.dragCursor, cm.display.cursorDiv);\\n  }\\n  removeChildrenAndAdd(cm.display.dragCursor, frag);\\n}\\n\\nfunction clearDragCursor(cm) {\\n  if (cm.display.dragCursor) {\\n    cm.display.lineSpace.removeChild(cm.display.dragCursor);\\n    cm.display.dragCursor = null;\\n  }\\n}\\n\\n// These must be handled carefully, because naively registering a\\n// handler for each editor will cause the editors to never be\\n// garbage collected.\\n\\nfunction forEachCodeMirror(f) {\\n  if (!document.body.getElementsByClassName) { return }\\n  var byClass = document.body.getElementsByClassName(\\\"CodeMirror\\\");\\n  for (var i = 0; i < byClass.length; i++) {\\n    var cm = byClass[i].CodeMirror;\\n    if (cm) { f(cm); }\\n  }\\n}\\n\\nvar globalsRegistered = false;\\nfunction ensureGlobalHandlers() {\\n  if (globalsRegistered) { return }\\n  registerGlobalHandlers();\\n  globalsRegistered = true;\\n}\\nfunction registerGlobalHandlers() {\\n  // When the window resizes, we need to refresh active editors.\\n  var resizeTimer;\\n  on(window, \\\"resize\\\", function () {\\n    if (resizeTimer == null) { resizeTimer = setTimeout(function () {\\n      resizeTimer = null;\\n      forEachCodeMirror(onResize);\\n    }, 100); }\\n  });\\n  // When the window loses focus, we want to show the editor as blurred\\n  on(window, \\\"blur\\\", function () { return forEachCodeMirror(onBlur); });\\n}\\n// Called when the window resizes\\nfunction onResize(cm) {\\n  var d = cm.display;\\n  if (d.lastWrapHeight == d.wrapper.clientHeight && d.lastWrapWidth == d.wrapper.clientWidth)\\n    { return }\\n  // Might be a text scaling operation, clear size caches.\\n  d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;\\n  d.scrollbarsClipped = false;\\n  cm.setSize();\\n}\\n\\nvar keyNames = {\\n  3: \\\"Enter\\\", 8: \\\"Backspace\\\", 9: \\\"Tab\\\", 13: \\\"Enter\\\", 16: \\\"Shift\\\", 17: \\\"Ctrl\\\", 18: \\\"Alt\\\",\\n  19: \\\"Pause\\\", 20: \\\"CapsLock\\\", 27: \\\"Esc\\\", 32: \\\"Space\\\", 33: \\\"PageUp\\\", 34: \\\"PageDown\\\", 35: \\\"End\\\",\\n  36: \\\"Home\\\", 37: \\\"Left\\\", 38: \\\"Up\\\", 39: \\\"Right\\\", 40: \\\"Down\\\", 44: \\\"PrintScrn\\\", 45: \\\"Insert\\\",\\n  46: \\\"Delete\\\", 59: \\\";\\\", 61: \\\"=\\\", 91: \\\"Mod\\\", 92: \\\"Mod\\\", 93: \\\"Mod\\\",\\n  106: \\\"*\\\", 107: \\\"=\\\", 109: \\\"-\\\", 110: \\\".\\\", 111: \\\"/\\\", 127: \\\"Delete\\\",\\n  173: \\\"-\\\", 186: \\\";\\\", 187: \\\"=\\\", 188: \\\",\\\", 189: \\\"-\\\", 190: \\\".\\\", 191: \\\"/\\\", 192: \\\"`\\\", 219: \\\"[\\\", 220: \\\"\\\\\\\\\\\",\\n  221: \\\"]\\\", 222: \\\"'\\\", 63232: \\\"Up\\\", 63233: \\\"Down\\\", 63234: \\\"Left\\\", 63235: \\\"Right\\\", 63272: \\\"Delete\\\",\\n  63273: \\\"Home\\\", 63275: \\\"End\\\", 63276: \\\"PageUp\\\", 63277: \\\"PageDown\\\", 63302: \\\"Insert\\\"\\n};\\n\\n// Number keys\\nfor (var i = 0; i < 10; i++) { keyNames[i + 48] = keyNames[i + 96] = String(i); }\\n// Alphabetic keys\\nfor (var i$1 = 65; i$1 <= 90; i$1++) { keyNames[i$1] = String.fromCharCode(i$1); }\\n// Function keys\\nfor (var i$2 = 1; i$2 <= 12; i$2++) { keyNames[i$2 + 111] = keyNames[i$2 + 63235] = \\\"F\\\" + i$2; }\\n\\nvar keyMap = {};\\n\\nkeyMap.basic = {\\n  \\\"Left\\\": \\\"goCharLeft\\\", \\\"Right\\\": \\\"goCharRight\\\", \\\"Up\\\": \\\"goLineUp\\\", \\\"Down\\\": \\\"goLineDown\\\",\\n  \\\"End\\\": \\\"goLineEnd\\\", \\\"Home\\\": \\\"goLineStartSmart\\\", \\\"PageUp\\\": \\\"goPageUp\\\", \\\"PageDown\\\": \\\"goPageDown\\\",\\n  \\\"Delete\\\": \\\"delCharAfter\\\", \\\"Backspace\\\": \\\"delCharBefore\\\", \\\"Shift-Backspace\\\": \\\"delCharBefore\\\",\\n  \\\"Tab\\\": \\\"defaultTab\\\", \\\"Shift-Tab\\\": \\\"indentAuto\\\",\\n  \\\"Enter\\\": \\\"newlineAndIndent\\\", \\\"Insert\\\": \\\"toggleOverwrite\\\",\\n  \\\"Esc\\\": \\\"singleSelection\\\"\\n};\\n// Note that the save and find-related commands aren't defined by\\n// default. User code or addons can define them. Unknown commands\\n// are simply ignored.\\nkeyMap.pcDefault = {\\n  \\\"Ctrl-A\\\": \\\"selectAll\\\", \\\"Ctrl-D\\\": \\\"deleteLine\\\", \\\"Ctrl-Z\\\": \\\"undo\\\", \\\"Shift-Ctrl-Z\\\": \\\"redo\\\", \\\"Ctrl-Y\\\": \\\"redo\\\",\\n  \\\"Ctrl-Home\\\": \\\"goDocStart\\\", \\\"Ctrl-End\\\": \\\"goDocEnd\\\", \\\"Ctrl-Up\\\": \\\"goLineUp\\\", \\\"Ctrl-Down\\\": \\\"goLineDown\\\",\\n  \\\"Ctrl-Left\\\": \\\"goGroupLeft\\\", \\\"Ctrl-Right\\\": \\\"goGroupRight\\\", \\\"Alt-Left\\\": \\\"goLineStart\\\", \\\"Alt-Right\\\": \\\"goLineEnd\\\",\\n  \\\"Ctrl-Backspace\\\": \\\"delGroupBefore\\\", \\\"Ctrl-Delete\\\": \\\"delGroupAfter\\\", \\\"Ctrl-S\\\": \\\"save\\\", \\\"Ctrl-F\\\": \\\"find\\\",\\n  \\\"Ctrl-G\\\": \\\"findNext\\\", \\\"Shift-Ctrl-G\\\": \\\"findPrev\\\", \\\"Shift-Ctrl-F\\\": \\\"replace\\\", \\\"Shift-Ctrl-R\\\": \\\"replaceAll\\\",\\n  \\\"Ctrl-[\\\": \\\"indentLess\\\", \\\"Ctrl-]\\\": \\\"indentMore\\\",\\n  \\\"Ctrl-U\\\": \\\"undoSelection\\\", \\\"Shift-Ctrl-U\\\": \\\"redoSelection\\\", \\\"Alt-U\\\": \\\"redoSelection\\\",\\n  fallthrough: \\\"basic\\\"\\n};\\n// Very basic readline/emacs-style bindings, which are standard on Mac.\\nkeyMap.emacsy = {\\n  \\\"Ctrl-F\\\": \\\"goCharRight\\\", \\\"Ctrl-B\\\": \\\"goCharLeft\\\", \\\"Ctrl-P\\\": \\\"goLineUp\\\", \\\"Ctrl-N\\\": \\\"goLineDown\\\",\\n  \\\"Alt-F\\\": \\\"goWordRight\\\", \\\"Alt-B\\\": \\\"goWordLeft\\\", \\\"Ctrl-A\\\": \\\"goLineStart\\\", \\\"Ctrl-E\\\": \\\"goLineEnd\\\",\\n  \\\"Ctrl-V\\\": \\\"goPageDown\\\", \\\"Shift-Ctrl-V\\\": \\\"goPageUp\\\", \\\"Ctrl-D\\\": \\\"delCharAfter\\\", \\\"Ctrl-H\\\": \\\"delCharBefore\\\",\\n  \\\"Alt-D\\\": \\\"delWordAfter\\\", \\\"Alt-Backspace\\\": \\\"delWordBefore\\\", \\\"Ctrl-K\\\": \\\"killLine\\\", \\\"Ctrl-T\\\": \\\"transposeChars\\\",\\n  \\\"Ctrl-O\\\": \\\"openLine\\\"\\n};\\nkeyMap.macDefault = {\\n  \\\"Cmd-A\\\": \\\"selectAll\\\", \\\"Cmd-D\\\": \\\"deleteLine\\\", \\\"Cmd-Z\\\": \\\"undo\\\", \\\"Shift-Cmd-Z\\\": \\\"redo\\\", \\\"Cmd-Y\\\": \\\"redo\\\",\\n  \\\"Cmd-Home\\\": \\\"goDocStart\\\", \\\"Cmd-Up\\\": \\\"goDocStart\\\", \\\"Cmd-End\\\": \\\"goDocEnd\\\", \\\"Cmd-Down\\\": \\\"goDocEnd\\\", \\\"Alt-Left\\\": \\\"goGroupLeft\\\",\\n  \\\"Alt-Right\\\": \\\"goGroupRight\\\", \\\"Cmd-Left\\\": \\\"goLineLeft\\\", \\\"Cmd-Right\\\": \\\"goLineRight\\\", \\\"Alt-Backspace\\\": \\\"delGroupBefore\\\",\\n  \\\"Ctrl-Alt-Backspace\\\": \\\"delGroupAfter\\\", \\\"Alt-Delete\\\": \\\"delGroupAfter\\\", \\\"Cmd-S\\\": \\\"save\\\", \\\"Cmd-F\\\": \\\"find\\\",\\n  \\\"Cmd-G\\\": \\\"findNext\\\", \\\"Shift-Cmd-G\\\": \\\"findPrev\\\", \\\"Cmd-Alt-F\\\": \\\"replace\\\", \\\"Shift-Cmd-Alt-F\\\": \\\"replaceAll\\\",\\n  \\\"Cmd-[\\\": \\\"indentLess\\\", \\\"Cmd-]\\\": \\\"indentMore\\\", \\\"Cmd-Backspace\\\": \\\"delWrappedLineLeft\\\", \\\"Cmd-Delete\\\": \\\"delWrappedLineRight\\\",\\n  \\\"Cmd-U\\\": \\\"undoSelection\\\", \\\"Shift-Cmd-U\\\": \\\"redoSelection\\\", \\\"Ctrl-Up\\\": \\\"goDocStart\\\", \\\"Ctrl-Down\\\": \\\"goDocEnd\\\",\\n  fallthrough: [\\\"basic\\\", \\\"emacsy\\\"]\\n};\\nkeyMap[\\\"default\\\"] = mac ? keyMap.macDefault : keyMap.pcDefault;\\n\\n// KEYMAP DISPATCH\\n\\nfunction normalizeKeyName(name) {\\n  var parts = name.split(/-(?!$)/);\\n  name = parts[parts.length - 1];\\n  var alt, ctrl, shift, cmd;\\n  for (var i = 0; i < parts.length - 1; i++) {\\n    var mod = parts[i];\\n    if (/^(cmd|meta|m)$/i.test(mod)) { cmd = true; }\\n    else if (/^a(lt)?$/i.test(mod)) { alt = true; }\\n    else if (/^(c|ctrl|control)$/i.test(mod)) { ctrl = true; }\\n    else if (/^s(hift)?$/i.test(mod)) { shift = true; }\\n    else { throw new Error(\\\"Unrecognized modifier name: \\\" + mod) }\\n  }\\n  if (alt) { name = \\\"Alt-\\\" + name; }\\n  if (ctrl) { name = \\\"Ctrl-\\\" + name; }\\n  if (cmd) { name = \\\"Cmd-\\\" + name; }\\n  if (shift) { name = \\\"Shift-\\\" + name; }\\n  return name\\n}\\n\\n// This is a kludge to keep keymaps mostly working as raw objects\\n// (backwards compatibility) while at the same time support features\\n// like normalization and multi-stroke key bindings. It compiles a\\n// new normalized keymap, and then updates the old object to reflect\\n// this.\\nfunction normalizeKeyMap(keymap) {\\n  var copy = {};\\n  for (var keyname in keymap) { if (keymap.hasOwnProperty(keyname)) {\\n    var value = keymap[keyname];\\n    if (/^(name|fallthrough|(de|at)tach)$/.test(keyname)) { continue }\\n    if (value == \\\"...\\\") { delete keymap[keyname]; continue }\\n\\n    var keys = map(keyname.split(\\\" \\\"), normalizeKeyName);\\n    for (var i = 0; i < keys.length; i++) {\\n      var val = (void 0), name = (void 0);\\n      if (i == keys.length - 1) {\\n        name = keys.join(\\\" \\\");\\n        val = value;\\n      } else {\\n        name = keys.slice(0, i + 1).join(\\\" \\\");\\n        val = \\\"...\\\";\\n      }\\n      var prev = copy[name];\\n      if (!prev) { copy[name] = val; }\\n      else if (prev != val) { throw new Error(\\\"Inconsistent bindings for \\\" + name) }\\n    }\\n    delete keymap[keyname];\\n  } }\\n  for (var prop in copy) { keymap[prop] = copy[prop]; }\\n  return keymap\\n}\\n\\nfunction lookupKey(key, map$$1, handle, context) {\\n  map$$1 = getKeyMap(map$$1);\\n  var found = map$$1.call ? map$$1.call(key, context) : map$$1[key];\\n  if (found === false) { return \\\"nothing\\\" }\\n  if (found === \\\"...\\\") { return \\\"multi\\\" }\\n  if (found != null && handle(found)) { return \\\"handled\\\" }\\n\\n  if (map$$1.fallthrough) {\\n    if (Object.prototype.toString.call(map$$1.fallthrough) != \\\"[object Array]\\\")\\n      { return lookupKey(key, map$$1.fallthrough, handle, context) }\\n    for (var i = 0; i < map$$1.fallthrough.length; i++) {\\n      var result = lookupKey(key, map$$1.fallthrough[i], handle, context);\\n      if (result) { return result }\\n    }\\n  }\\n}\\n\\n// Modifier key presses don't count as 'real' key presses for the\\n// purpose of keymap fallthrough.\\nfunction isModifierKey(value) {\\n  var name = typeof value == \\\"string\\\" ? value : keyNames[value.keyCode];\\n  return name == \\\"Ctrl\\\" || name == \\\"Alt\\\" || name == \\\"Shift\\\" || name == \\\"Mod\\\"\\n}\\n\\n// Look up the name of a key as indicated by an event object.\\nfunction keyName(event, noShift) {\\n  if (presto && event.keyCode == 34 && event[\\\"char\\\"]) { return false }\\n  var base = keyNames[event.keyCode], name = base;\\n  if (name == null || event.altGraphKey) { return false }\\n  if (event.altKey && base != \\\"Alt\\\") { name = \\\"Alt-\\\" + name; }\\n  if ((flipCtrlCmd ? event.metaKey : event.ctrlKey) && base != \\\"Ctrl\\\") { name = \\\"Ctrl-\\\" + name; }\\n  if ((flipCtrlCmd ? event.ctrlKey : event.metaKey) && base != \\\"Cmd\\\") { name = \\\"Cmd-\\\" + name; }\\n  if (!noShift && event.shiftKey && base != \\\"Shift\\\") { name = \\\"Shift-\\\" + name; }\\n  return name\\n}\\n\\nfunction getKeyMap(val) {\\n  return typeof val == \\\"string\\\" ? keyMap[val] : val\\n}\\n\\n// Helper for deleting text near the selection(s), used to implement\\n// backspace, delete, and similar functionality.\\nfunction deleteNearSelection(cm, compute) {\\n  var ranges = cm.doc.sel.ranges, kill = [];\\n  // Build up a set of ranges to kill first, merging overlapping\\n  // ranges.\\n  for (var i = 0; i < ranges.length; i++) {\\n    var toKill = compute(ranges[i]);\\n    while (kill.length && cmp(toKill.from, lst(kill).to) <= 0) {\\n      var replaced = kill.pop();\\n      if (cmp(replaced.from, toKill.from) < 0) {\\n        toKill.from = replaced.from;\\n        break\\n      }\\n    }\\n    kill.push(toKill);\\n  }\\n  // Next, remove those actual ranges.\\n  runInOp(cm, function () {\\n    for (var i = kill.length - 1; i >= 0; i--)\\n      { replaceRange(cm.doc, \\\"\\\", kill[i].from, kill[i].to, \\\"+delete\\\"); }\\n    ensureCursorVisible(cm);\\n  });\\n}\\n\\n// Commands are parameter-less actions that can be performed on an\\n// editor, mostly used for keybindings.\\nvar commands = {\\n  selectAll: selectAll,\\n  singleSelection: function (cm) { return cm.setSelection(cm.getCursor(\\\"anchor\\\"), cm.getCursor(\\\"head\\\"), sel_dontScroll); },\\n  killLine: function (cm) { return deleteNearSelection(cm, function (range) {\\n    if (range.empty()) {\\n      var len = getLine(cm.doc, range.head.line).text.length;\\n      if (range.head.ch == len && range.head.line < cm.lastLine())\\n        { return {from: range.head, to: Pos(range.head.line + 1, 0)} }\\n      else\\n        { return {from: range.head, to: Pos(range.head.line, len)} }\\n    } else {\\n      return {from: range.from(), to: range.to()}\\n    }\\n  }); },\\n  deleteLine: function (cm) { return deleteNearSelection(cm, function (range) { return ({\\n    from: Pos(range.from().line, 0),\\n    to: clipPos(cm.doc, Pos(range.to().line + 1, 0))\\n  }); }); },\\n  delLineLeft: function (cm) { return deleteNearSelection(cm, function (range) { return ({\\n    from: Pos(range.from().line, 0), to: range.from()\\n  }); }); },\\n  delWrappedLineLeft: function (cm) { return deleteNearSelection(cm, function (range) {\\n    var top = cm.charCoords(range.head, \\\"div\\\").top + 5;\\n    var leftPos = cm.coordsChar({left: 0, top: top}, \\\"div\\\");\\n    return {from: leftPos, to: range.from()}\\n  }); },\\n  delWrappedLineRight: function (cm) { return deleteNearSelection(cm, function (range) {\\n    var top = cm.charCoords(range.head, \\\"div\\\").top + 5;\\n    var rightPos = cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, \\\"div\\\");\\n    return {from: range.from(), to: rightPos }\\n  }); },\\n  undo: function (cm) { return cm.undo(); },\\n  redo: function (cm) { return cm.redo(); },\\n  undoSelection: function (cm) { return cm.undoSelection(); },\\n  redoSelection: function (cm) { return cm.redoSelection(); },\\n  goDocStart: function (cm) { return cm.extendSelection(Pos(cm.firstLine(), 0)); },\\n  goDocEnd: function (cm) { return cm.extendSelection(Pos(cm.lastLine())); },\\n  goLineStart: function (cm) { return cm.extendSelectionsBy(function (range) { return lineStart(cm, range.head.line); },\\n    {origin: \\\"+move\\\", bias: 1}\\n  ); },\\n  goLineStartSmart: function (cm) { return cm.extendSelectionsBy(function (range) { return lineStartSmart(cm, range.head); },\\n    {origin: \\\"+move\\\", bias: 1}\\n  ); },\\n  goLineEnd: function (cm) { return cm.extendSelectionsBy(function (range) { return lineEnd(cm, range.head.line); },\\n    {origin: \\\"+move\\\", bias: -1}\\n  ); },\\n  goLineRight: function (cm) { return cm.extendSelectionsBy(function (range) {\\n    var top = cm.charCoords(range.head, \\\"div\\\").top + 5;\\n    return cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, \\\"div\\\")\\n  }, sel_move); },\\n  goLineLeft: function (cm) { return cm.extendSelectionsBy(function (range) {\\n    var top = cm.charCoords(range.head, \\\"div\\\").top + 5;\\n    return cm.coordsChar({left: 0, top: top}, \\\"div\\\")\\n  }, sel_move); },\\n  goLineLeftSmart: function (cm) { return cm.extendSelectionsBy(function (range) {\\n    var top = cm.charCoords(range.head, \\\"div\\\").top + 5;\\n    var pos = cm.coordsChar({left: 0, top: top}, \\\"div\\\");\\n    if (pos.ch < cm.getLine(pos.line).search(/\\\\S/)) { return lineStartSmart(cm, range.head) }\\n    return pos\\n  }, sel_move); },\\n  goLineUp: function (cm) { return cm.moveV(-1, \\\"line\\\"); },\\n  goLineDown: function (cm) { return cm.moveV(1, \\\"line\\\"); },\\n  goPageUp: function (cm) { return cm.moveV(-1, \\\"page\\\"); },\\n  goPageDown: function (cm) { return cm.moveV(1, \\\"page\\\"); },\\n  goCharLeft: function (cm) { return cm.moveH(-1, \\\"char\\\"); },\\n  goCharRight: function (cm) { return cm.moveH(1, \\\"char\\\"); },\\n  goColumnLeft: function (cm) { return cm.moveH(-1, \\\"column\\\"); },\\n  goColumnRight: function (cm) { return cm.moveH(1, \\\"column\\\"); },\\n  goWordLeft: function (cm) { return cm.moveH(-1, \\\"word\\\"); },\\n  goGroupRight: function (cm) { return cm.moveH(1, \\\"group\\\"); },\\n  goGroupLeft: function (cm) { return cm.moveH(-1, \\\"group\\\"); },\\n  goWordRight: function (cm) { return cm.moveH(1, \\\"word\\\"); },\\n  delCharBefore: function (cm) { return cm.deleteH(-1, \\\"char\\\"); },\\n  delCharAfter: function (cm) { return cm.deleteH(1, \\\"char\\\"); },\\n  delWordBefore: function (cm) { return cm.deleteH(-1, \\\"word\\\"); },\\n  delWordAfter: function (cm) { return cm.deleteH(1, \\\"word\\\"); },\\n  delGroupBefore: function (cm) { return cm.deleteH(-1, \\\"group\\\"); },\\n  delGroupAfter: function (cm) { return cm.deleteH(1, \\\"group\\\"); },\\n  indentAuto: function (cm) { return cm.indentSelection(\\\"smart\\\"); },\\n  indentMore: function (cm) { return cm.indentSelection(\\\"add\\\"); },\\n  indentLess: function (cm) { return cm.indentSelection(\\\"subtract\\\"); },\\n  insertTab: function (cm) { return cm.replaceSelection(\\\"\\\\t\\\"); },\\n  insertSoftTab: function (cm) {\\n    var spaces = [], ranges = cm.listSelections(), tabSize = cm.options.tabSize;\\n    for (var i = 0; i < ranges.length; i++) {\\n      var pos = ranges[i].from();\\n      var col = countColumn(cm.getLine(pos.line), pos.ch, tabSize);\\n      spaces.push(spaceStr(tabSize - col % tabSize));\\n    }\\n    cm.replaceSelections(spaces);\\n  },\\n  defaultTab: function (cm) {\\n    if (cm.somethingSelected()) { cm.indentSelection(\\\"add\\\"); }\\n    else { cm.execCommand(\\\"insertTab\\\"); }\\n  },\\n  // Swap the two chars left and right of each selection's head.\\n  // Move cursor behind the two swapped characters afterwards.\\n  //\\n  // Doesn't consider line feeds a character.\\n  // Doesn't scan more than one line above to find a character.\\n  // Doesn't do anything on an empty line.\\n  // Doesn't do anything with non-empty selections.\\n  transposeChars: function (cm) { return runInOp(cm, function () {\\n    var ranges = cm.listSelections(), newSel = [];\\n    for (var i = 0; i < ranges.length; i++) {\\n      if (!ranges[i].empty()) { continue }\\n      var cur = ranges[i].head, line = getLine(cm.doc, cur.line).text;\\n      if (line) {\\n        if (cur.ch == line.length) { cur = new Pos(cur.line, cur.ch - 1); }\\n        if (cur.ch > 0) {\\n          cur = new Pos(cur.line, cur.ch + 1);\\n          cm.replaceRange(line.charAt(cur.ch - 1) + line.charAt(cur.ch - 2),\\n                          Pos(cur.line, cur.ch - 2), cur, \\\"+transpose\\\");\\n        } else if (cur.line > cm.doc.first) {\\n          var prev = getLine(cm.doc, cur.line - 1).text;\\n          if (prev) {\\n            cur = new Pos(cur.line, 1);\\n            cm.replaceRange(line.charAt(0) + cm.doc.lineSeparator() +\\n                            prev.charAt(prev.length - 1),\\n                            Pos(cur.line - 1, prev.length - 1), cur, \\\"+transpose\\\");\\n          }\\n        }\\n      }\\n      newSel.push(new Range(cur, cur));\\n    }\\n    cm.setSelections(newSel);\\n  }); },\\n  newlineAndIndent: function (cm) { return runInOp(cm, function () {\\n    var sels = cm.listSelections();\\n    for (var i = sels.length - 1; i >= 0; i--)\\n      { cm.replaceRange(cm.doc.lineSeparator(), sels[i].anchor, sels[i].head, \\\"+input\\\"); }\\n    sels = cm.listSelections();\\n    for (var i$1 = 0; i$1 < sels.length; i$1++)\\n      { cm.indentLine(sels[i$1].from().line, null, true); }\\n    ensureCursorVisible(cm);\\n  }); },\\n  openLine: function (cm) { return cm.replaceSelection(\\\"\\\\n\\\", \\\"start\\\"); },\\n  toggleOverwrite: function (cm) { return cm.toggleOverwrite(); }\\n};\\n\\n\\nfunction lineStart(cm, lineN) {\\n  var line = getLine(cm.doc, lineN);\\n  var visual = visualLine(line);\\n  if (visual != line) { lineN = lineNo(visual); }\\n  return endOfLine(true, cm, visual, lineN, 1)\\n}\\nfunction lineEnd(cm, lineN) {\\n  var line = getLine(cm.doc, lineN);\\n  var visual = visualLineEnd(line);\\n  if (visual != line) { lineN = lineNo(visual); }\\n  return endOfLine(true, cm, line, lineN, -1)\\n}\\nfunction lineStartSmart(cm, pos) {\\n  var start = lineStart(cm, pos.line);\\n  var line = getLine(cm.doc, start.line);\\n  var order = getOrder(line, cm.doc.direction);\\n  if (!order || order[0].level == 0) {\\n    var firstNonWS = Math.max(0, line.text.search(/\\\\S/));\\n    var inWS = pos.line == start.line && pos.ch <= firstNonWS && pos.ch;\\n    return Pos(start.line, inWS ? 0 : firstNonWS, start.sticky)\\n  }\\n  return start\\n}\\n\\n// Run a handler that was bound to a key.\\nfunction doHandleBinding(cm, bound, dropShift) {\\n  if (typeof bound == \\\"string\\\") {\\n    bound = commands[bound];\\n    if (!bound) { return false }\\n  }\\n  // Ensure previous input has been read, so that the handler sees a\\n  // consistent view of the document\\n  cm.display.input.ensurePolled();\\n  var prevShift = cm.display.shift, done = false;\\n  try {\\n    if (cm.isReadOnly()) { cm.state.suppressEdits = true; }\\n    if (dropShift) { cm.display.shift = false; }\\n    done = bound(cm) != Pass;\\n  } finally {\\n    cm.display.shift = prevShift;\\n    cm.state.suppressEdits = false;\\n  }\\n  return done\\n}\\n\\nfunction lookupKeyForEditor(cm, name, handle) {\\n  for (var i = 0; i < cm.state.keyMaps.length; i++) {\\n    var result = lookupKey(name, cm.state.keyMaps[i], handle, cm);\\n    if (result) { return result }\\n  }\\n  return (cm.options.extraKeys && lookupKey(name, cm.options.extraKeys, handle, cm))\\n    || lookupKey(name, cm.options.keyMap, handle, cm)\\n}\\n\\nvar stopSeq = new Delayed;\\nfunction dispatchKey(cm, name, e, handle) {\\n  var seq = cm.state.keySeq;\\n  if (seq) {\\n    if (isModifierKey(name)) { return \\\"handled\\\" }\\n    stopSeq.set(50, function () {\\n      if (cm.state.keySeq == seq) {\\n        cm.state.keySeq = null;\\n        cm.display.input.reset();\\n      }\\n    });\\n    name = seq + \\\" \\\" + name;\\n  }\\n  var result = lookupKeyForEditor(cm, name, handle);\\n\\n  if (result == \\\"multi\\\")\\n    { cm.state.keySeq = name; }\\n  if (result == \\\"handled\\\")\\n    { signalLater(cm, \\\"keyHandled\\\", cm, name, e); }\\n\\n  if (result == \\\"handled\\\" || result == \\\"multi\\\") {\\n    e_preventDefault(e);\\n    restartBlink(cm);\\n  }\\n\\n  if (seq && !result && /\\\\'$/.test(name)) {\\n    e_preventDefault(e);\\n    return true\\n  }\\n  return !!result\\n}\\n\\n// Handle a key from the keydown event.\\nfunction handleKeyBinding(cm, e) {\\n  var name = keyName(e, true);\\n  if (!name) { return false }\\n\\n  if (e.shiftKey && !cm.state.keySeq) {\\n    // First try to resolve full name (including 'Shift-'). Failing\\n    // that, see if there is a cursor-motion command (starting with\\n    // 'go') bound to the keyname without 'Shift-'.\\n    return dispatchKey(cm, \\\"Shift-\\\" + name, e, function (b) { return doHandleBinding(cm, b, true); })\\n        || dispatchKey(cm, name, e, function (b) {\\n             if (typeof b == \\\"string\\\" ? /^go[A-Z]/.test(b) : b.motion)\\n               { return doHandleBinding(cm, b) }\\n           })\\n  } else {\\n    return dispatchKey(cm, name, e, function (b) { return doHandleBinding(cm, b); })\\n  }\\n}\\n\\n// Handle a key from the keypress event\\nfunction handleCharBinding(cm, e, ch) {\\n  return dispatchKey(cm, \\\"'\\\" + ch + \\\"'\\\", e, function (b) { return doHandleBinding(cm, b, true); })\\n}\\n\\nvar lastStoppedKey = null;\\nfunction onKeyDown(e) {\\n  var cm = this;\\n  cm.curOp.focus = activeElt();\\n  if (signalDOMEvent(cm, e)) { return }\\n  // IE does strange things with escape.\\n  if (ie && ie_version < 11 && e.keyCode == 27) { e.returnValue = false; }\\n  var code = e.keyCode;\\n  cm.display.shift = code == 16 || e.shiftKey;\\n  var handled = handleKeyBinding(cm, e);\\n  if (presto) {\\n    lastStoppedKey = handled ? code : null;\\n    // Opera has no cut event... we try to at least catch the key combo\\n    if (!handled && code == 88 && !hasCopyEvent && (mac ? e.metaKey : e.ctrlKey))\\n      { cm.replaceSelection(\\\"\\\", null, \\\"cut\\\"); }\\n  }\\n\\n  // Turn mouse into crosshair when Alt is held on Mac.\\n  if (code == 18 && !/\\\\bCodeMirror-crosshair\\\\b/.test(cm.display.lineDiv.className))\\n    { showCrossHair(cm); }\\n}\\n\\nfunction showCrossHair(cm) {\\n  var lineDiv = cm.display.lineDiv;\\n  addClass(lineDiv, \\\"CodeMirror-crosshair\\\");\\n\\n  function up(e) {\\n    if (e.keyCode == 18 || !e.altKey) {\\n      rmClass(lineDiv, \\\"CodeMirror-crosshair\\\");\\n      off(document, \\\"keyup\\\", up);\\n      off(document, \\\"mouseover\\\", up);\\n    }\\n  }\\n  on(document, \\\"keyup\\\", up);\\n  on(document, \\\"mouseover\\\", up);\\n}\\n\\nfunction onKeyUp(e) {\\n  if (e.keyCode == 16) { this.doc.sel.shift = false; }\\n  signalDOMEvent(this, e);\\n}\\n\\nfunction onKeyPress(e) {\\n  var cm = this;\\n  if (eventInWidget(cm.display, e) || signalDOMEvent(cm, e) || e.ctrlKey && !e.altKey || mac && e.metaKey) { return }\\n  var keyCode = e.keyCode, charCode = e.charCode;\\n  if (presto && keyCode == lastStoppedKey) {lastStoppedKey = null; e_preventDefault(e); return}\\n  if ((presto && (!e.which || e.which < 10)) && handleKeyBinding(cm, e)) { return }\\n  var ch = String.fromCharCode(charCode == null ? keyCode : charCode);\\n  // Some browsers fire keypress events for backspace\\n  if (ch == \\\"\\\\x08\\\") { return }\\n  if (handleCharBinding(cm, e, ch)) { return }\\n  cm.display.input.onKeyPress(e);\\n}\\n\\n// A mouse down can be a single click, double click, triple click,\\n// start of selection drag, start of text drag, new cursor\\n// (ctrl-click), rectangle drag (alt-drag), or xwin\\n// middle-click-paste. Or it might be a click on something we should\\n// not interfere with, such as a scrollbar or widget.\\nfunction onMouseDown(e) {\\n  var cm = this, display = cm.display;\\n  if (signalDOMEvent(cm, e) || display.activeTouch && display.input.supportsTouch()) { return }\\n  display.input.ensurePolled();\\n  display.shift = e.shiftKey;\\n\\n  if (eventInWidget(display, e)) {\\n    if (!webkit) {\\n      // Briefly turn off draggability, to allow widgets to do\\n      // normal dragging things.\\n      display.scroller.draggable = false;\\n      setTimeout(function () { return display.scroller.draggable = true; }, 100);\\n    }\\n    return\\n  }\\n  if (clickInGutter(cm, e)) { return }\\n  var start = posFromMouse(cm, e);\\n  window.focus();\\n\\n  switch (e_button(e)) {\\n  case 1:\\n    // #3261: make sure, that we're not starting a second selection\\n    if (cm.state.selectingText)\\n      { cm.state.selectingText(e); }\\n    else if (start)\\n      { leftButtonDown(cm, e, start); }\\n    else if (e_target(e) == display.scroller)\\n      { e_preventDefault(e); }\\n    break\\n  case 2:\\n    if (webkit) { cm.state.lastMiddleDown = +new Date; }\\n    if (start) { extendSelection(cm.doc, start); }\\n    setTimeout(function () { return display.input.focus(); }, 20);\\n    e_preventDefault(e);\\n    break\\n  case 3:\\n    if (captureRightClick) { onContextMenu(cm, e); }\\n    else { delayBlurEvent(cm); }\\n    break\\n  }\\n}\\n\\nvar lastClick;\\nvar lastDoubleClick;\\nfunction leftButtonDown(cm, e, start) {\\n  if (ie) { setTimeout(bind(ensureFocus, cm), 0); }\\n  else { cm.curOp.focus = activeElt(); }\\n\\n  var now = +new Date, type;\\n  if (lastDoubleClick && lastDoubleClick.time > now - 400 && cmp(lastDoubleClick.pos, start) == 0) {\\n    type = \\\"triple\\\";\\n  } else if (lastClick && lastClick.time > now - 400 && cmp(lastClick.pos, start) == 0) {\\n    type = \\\"double\\\";\\n    lastDoubleClick = {time: now, pos: start};\\n  } else {\\n    type = \\\"single\\\";\\n    lastClick = {time: now, pos: start};\\n  }\\n\\n  var sel = cm.doc.sel, modifier = mac ? e.metaKey : e.ctrlKey, contained;\\n  if (cm.options.dragDrop && dragAndDrop && !cm.isReadOnly() &&\\n      type == \\\"single\\\" && (contained = sel.contains(start)) > -1 &&\\n      (cmp((contained = sel.ranges[contained]).from(), start) < 0 || start.xRel > 0) &&\\n      (cmp(contained.to(), start) > 0 || start.xRel < 0))\\n    { leftButtonStartDrag(cm, e, start, modifier); }\\n  else\\n    { leftButtonSelect(cm, e, start, type, modifier); }\\n}\\n\\n// Start a text drag. When it ends, see if any dragging actually\\n// happen, and treat as a click if it didn't.\\nfunction leftButtonStartDrag(cm, e, start, modifier) {\\n  var display = cm.display, startTime = +new Date;\\n  var dragEnd = operation(cm, function (e2) {\\n    if (webkit) { display.scroller.draggable = false; }\\n    cm.state.draggingText = false;\\n    off(document, \\\"mouseup\\\", dragEnd);\\n    off(display.scroller, \\\"drop\\\", dragEnd);\\n    if (Math.abs(e.clientX - e2.clientX) + Math.abs(e.clientY - e2.clientY) < 10) {\\n      e_preventDefault(e2);\\n      if (!modifier && +new Date - 200 < startTime)\\n        { extendSelection(cm.doc, start); }\\n      // Work around unexplainable focus problem in IE9 (#2127) and Chrome (#3081)\\n      if (webkit || ie && ie_version == 9)\\n        { setTimeout(function () {document.body.focus(); display.input.focus();}, 20); }\\n      else\\n        { display.input.focus(); }\\n    }\\n  });\\n  // Let the drag handler handle this.\\n  if (webkit) { display.scroller.draggable = true; }\\n  cm.state.draggingText = dragEnd;\\n  dragEnd.copy = mac ? e.altKey : e.ctrlKey;\\n  // IE's approach to draggable\\n  if (display.scroller.dragDrop) { display.scroller.dragDrop(); }\\n  on(document, \\\"mouseup\\\", dragEnd);\\n  on(display.scroller, \\\"drop\\\", dragEnd);\\n}\\n\\n// Normal selection, as opposed to text dragging.\\nfunction leftButtonSelect(cm, e, start, type, addNew) {\\n  var display = cm.display, doc = cm.doc;\\n  e_preventDefault(e);\\n\\n  var ourRange, ourIndex, startSel = doc.sel, ranges = startSel.ranges;\\n  if (addNew && !e.shiftKey) {\\n    ourIndex = doc.sel.contains(start);\\n    if (ourIndex > -1)\\n      { ourRange = ranges[ourIndex]; }\\n    else\\n      { ourRange = new Range(start, start); }\\n  } else {\\n    ourRange = doc.sel.primary();\\n    ourIndex = doc.sel.primIndex;\\n  }\\n\\n  if (chromeOS ? e.shiftKey && e.metaKey : e.altKey) {\\n    type = \\\"rect\\\";\\n    if (!addNew) { ourRange = new Range(start, start); }\\n    start = posFromMouse(cm, e, true, true);\\n    ourIndex = -1;\\n  } else if (type == \\\"double\\\") {\\n    var word = cm.findWordAt(start);\\n    if (cm.display.shift || doc.extend)\\n      { ourRange = extendRange(doc, ourRange, word.anchor, word.head); }\\n    else\\n      { ourRange = word; }\\n  } else if (type == \\\"triple\\\") {\\n    var line = new Range(Pos(start.line, 0), clipPos(doc, Pos(start.line + 1, 0)));\\n    if (cm.display.shift || doc.extend)\\n      { ourRange = extendRange(doc, ourRange, line.anchor, line.head); }\\n    else\\n      { ourRange = line; }\\n  } else {\\n    ourRange = extendRange(doc, ourRange, start);\\n  }\\n\\n  if (!addNew) {\\n    ourIndex = 0;\\n    setSelection(doc, new Selection([ourRange], 0), sel_mouse);\\n    startSel = doc.sel;\\n  } else if (ourIndex == -1) {\\n    ourIndex = ranges.length;\\n    setSelection(doc, normalizeSelection(ranges.concat([ourRange]), ourIndex),\\n                 {scroll: false, origin: \\\"*mouse\\\"});\\n  } else if (ranges.length > 1 && ranges[ourIndex].empty() && type == \\\"single\\\" && !e.shiftKey) {\\n    setSelection(doc, normalizeSelection(ranges.slice(0, ourIndex).concat(ranges.slice(ourIndex + 1)), 0),\\n                 {scroll: false, origin: \\\"*mouse\\\"});\\n    startSel = doc.sel;\\n  } else {\\n    replaceOneSelection(doc, ourIndex, ourRange, sel_mouse);\\n  }\\n\\n  var lastPos = start;\\n  function extendTo(pos) {\\n    if (cmp(lastPos, pos) == 0) { return }\\n    lastPos = pos;\\n\\n    if (type == \\\"rect\\\") {\\n      var ranges = [], tabSize = cm.options.tabSize;\\n      var startCol = countColumn(getLine(doc, start.line).text, start.ch, tabSize);\\n      var posCol = countColumn(getLine(doc, pos.line).text, pos.ch, tabSize);\\n      var left = Math.min(startCol, posCol), right = Math.max(startCol, posCol);\\n      for (var line = Math.min(start.line, pos.line), end = Math.min(cm.lastLine(), Math.max(start.line, pos.line));\\n           line <= end; line++) {\\n        var text = getLine(doc, line).text, leftPos = findColumn(text, left, tabSize);\\n        if (left == right)\\n          { ranges.push(new Range(Pos(line, leftPos), Pos(line, leftPos))); }\\n        else if (text.length > leftPos)\\n          { ranges.push(new Range(Pos(line, leftPos), Pos(line, findColumn(text, right, tabSize)))); }\\n      }\\n      if (!ranges.length) { ranges.push(new Range(start, start)); }\\n      setSelection(doc, normalizeSelection(startSel.ranges.slice(0, ourIndex).concat(ranges), ourIndex),\\n                   {origin: \\\"*mouse\\\", scroll: false});\\n      cm.scrollIntoView(pos);\\n    } else {\\n      var oldRange = ourRange;\\n      var anchor = oldRange.anchor, head = pos;\\n      if (type != \\\"single\\\") {\\n        var range$$1;\\n        if (type == \\\"double\\\")\\n          { range$$1 = cm.findWordAt(pos); }\\n        else\\n          { range$$1 = new Range(Pos(pos.line, 0), clipPos(doc, Pos(pos.line + 1, 0))); }\\n        if (cmp(range$$1.anchor, anchor) > 0) {\\n          head = range$$1.head;\\n          anchor = minPos(oldRange.from(), range$$1.anchor);\\n        } else {\\n          head = range$$1.anchor;\\n          anchor = maxPos(oldRange.to(), range$$1.head);\\n        }\\n      }\\n      var ranges$1 = startSel.ranges.slice(0);\\n      ranges$1[ourIndex] = new Range(clipPos(doc, anchor), head);\\n      setSelection(doc, normalizeSelection(ranges$1, ourIndex), sel_mouse);\\n    }\\n  }\\n\\n  var editorSize = display.wrapper.getBoundingClientRect();\\n  // Used to ensure timeout re-tries don't fire when another extend\\n  // happened in the meantime (clearTimeout isn't reliable -- at\\n  // least on Chrome, the timeouts still happen even when cleared,\\n  // if the clear happens after their scheduled firing time).\\n  var counter = 0;\\n\\n  function extend(e) {\\n    var curCount = ++counter;\\n    var cur = posFromMouse(cm, e, true, type == \\\"rect\\\");\\n    if (!cur) { return }\\n    if (cmp(cur, lastPos) != 0) {\\n      cm.curOp.focus = activeElt();\\n      extendTo(cur);\\n      var visible = visibleLines(display, doc);\\n      if (cur.line >= visible.to || cur.line < visible.from)\\n        { setTimeout(operation(cm, function () {if (counter == curCount) { extend(e); }}), 150); }\\n    } else {\\n      var outside = e.clientY < editorSize.top ? -20 : e.clientY > editorSize.bottom ? 20 : 0;\\n      if (outside) { setTimeout(operation(cm, function () {\\n        if (counter != curCount) { return }\\n        display.scroller.scrollTop += outside;\\n        extend(e);\\n      }), 50); }\\n    }\\n  }\\n\\n  function done(e) {\\n    cm.state.selectingText = false;\\n    counter = Infinity;\\n    e_preventDefault(e);\\n    display.input.focus();\\n    off(document, \\\"mousemove\\\", move);\\n    off(document, \\\"mouseup\\\", up);\\n    doc.history.lastSelOrigin = null;\\n  }\\n\\n  var move = operation(cm, function (e) {\\n    if (!e_button(e)) { done(e); }\\n    else { extend(e); }\\n  });\\n  var up = operation(cm, done);\\n  cm.state.selectingText = up;\\n  on(document, \\\"mousemove\\\", move);\\n  on(document, \\\"mouseup\\\", up);\\n}\\n\\n\\n// Determines whether an event happened in the gutter, and fires the\\n// handlers for the corresponding event.\\nfunction gutterEvent(cm, e, type, prevent) {\\n  var mX, mY;\\n  try { mX = e.clientX; mY = e.clientY; }\\n  catch(e) { return false }\\n  if (mX >= Math.floor(cm.display.gutters.getBoundingClientRect().right)) { return false }\\n  if (prevent) { e_preventDefault(e); }\\n\\n  var display = cm.display;\\n  var lineBox = display.lineDiv.getBoundingClientRect();\\n\\n  if (mY > lineBox.bottom || !hasHandler(cm, type)) { return e_defaultPrevented(e) }\\n  mY -= lineBox.top - display.viewOffset;\\n\\n  for (var i = 0; i < cm.options.gutters.length; ++i) {\\n    var g = display.gutters.childNodes[i];\\n    if (g && g.getBoundingClientRect().right >= mX) {\\n      var line = lineAtHeight(cm.doc, mY);\\n      var gutter = cm.options.gutters[i];\\n      signal(cm, type, cm, line, gutter, e);\\n      return e_defaultPrevented(e)\\n    }\\n  }\\n}\\n\\nfunction clickInGutter(cm, e) {\\n  return gutterEvent(cm, e, \\\"gutterClick\\\", true)\\n}\\n\\n// CONTEXT MENU HANDLING\\n\\n// To make the context menu work, we need to briefly unhide the\\n// textarea (making it as unobtrusive as possible) to let the\\n// right-click take effect on it.\\nfunction onContextMenu(cm, e) {\\n  if (eventInWidget(cm.display, e) || contextMenuInGutter(cm, e)) { return }\\n  if (signalDOMEvent(cm, e, \\\"contextmenu\\\")) { return }\\n  cm.display.input.onContextMenu(e);\\n}\\n\\nfunction contextMenuInGutter(cm, e) {\\n  if (!hasHandler(cm, \\\"gutterContextMenu\\\")) { return false }\\n  return gutterEvent(cm, e, \\\"gutterContextMenu\\\", false)\\n}\\n\\nfunction themeChanged(cm) {\\n  cm.display.wrapper.className = cm.display.wrapper.className.replace(/\\\\s*cm-s-\\\\S+/g, \\\"\\\") +\\n    cm.options.theme.replace(/(^|\\\\s)\\\\s*/g, \\\" cm-s-\\\");\\n  clearCaches(cm);\\n}\\n\\nvar Init = {toString: function(){return \\\"CodeMirror.Init\\\"}};\\n\\nvar defaults = {};\\nvar optionHandlers = {};\\n\\nfunction defineOptions(CodeMirror) {\\n  var optionHandlers = CodeMirror.optionHandlers;\\n\\n  function option(name, deflt, handle, notOnInit) {\\n    CodeMirror.defaults[name] = deflt;\\n    if (handle) { optionHandlers[name] =\\n      notOnInit ? function (cm, val, old) {if (old != Init) { handle(cm, val, old); }} : handle; }\\n  }\\n\\n  CodeMirror.defineOption = option;\\n\\n  // Passed to option handlers when there is no old value.\\n  CodeMirror.Init = Init;\\n\\n  // These two are, on init, called from the constructor because they\\n  // have to be initialized before the editor can start at all.\\n  option(\\\"value\\\", \\\"\\\", function (cm, val) { return cm.setValue(val); }, true);\\n  option(\\\"mode\\\", null, function (cm, val) {\\n    cm.doc.modeOption = val;\\n    loadMode(cm);\\n  }, true);\\n\\n  option(\\\"indentUnit\\\", 2, loadMode, true);\\n  option(\\\"indentWithTabs\\\", false);\\n  option(\\\"smartIndent\\\", true);\\n  option(\\\"tabSize\\\", 4, function (cm) {\\n    resetModeState(cm);\\n    clearCaches(cm);\\n    regChange(cm);\\n  }, true);\\n  option(\\\"lineSeparator\\\", null, function (cm, val) {\\n    cm.doc.lineSep = val;\\n    if (!val) { return }\\n    var newBreaks = [], lineNo = cm.doc.first;\\n    cm.doc.iter(function (line) {\\n      for (var pos = 0;;) {\\n        var found = line.text.indexOf(val, pos);\\n        if (found == -1) { break }\\n        pos = found + val.length;\\n        newBreaks.push(Pos(lineNo, found));\\n      }\\n      lineNo++;\\n    });\\n    for (var i = newBreaks.length - 1; i >= 0; i--)\\n      { replaceRange(cm.doc, val, newBreaks[i], Pos(newBreaks[i].line, newBreaks[i].ch + val.length)); }\\n  });\\n  option(\\\"specialChars\\\", /[\\\\u0000-\\\\u001f\\\\u007f-\\\\u009f\\\\u00ad\\\\u061c\\\\u200b-\\\\u200f\\\\u2028\\\\u2029\\\\ufeff]/g, function (cm, val, old) {\\n    cm.state.specialChars = new RegExp(val.source + (val.test(\\\"\\\\t\\\") ? \\\"\\\" : \\\"|\\\\t\\\"), \\\"g\\\");\\n    if (old != Init) { cm.refresh(); }\\n  });\\n  option(\\\"specialCharPlaceholder\\\", defaultSpecialCharPlaceholder, function (cm) { return cm.refresh(); }, true);\\n  option(\\\"electricChars\\\", true);\\n  option(\\\"inputStyle\\\", mobile ? \\\"contenteditable\\\" : \\\"textarea\\\", function () {\\n    throw new Error(\\\"inputStyle can not (yet) be changed in a running editor\\\") // FIXME\\n  }, true);\\n  option(\\\"spellcheck\\\", false, function (cm, val) { return cm.getInputField().spellcheck = val; }, true);\\n  option(\\\"rtlMoveVisually\\\", !windows);\\n  option(\\\"wholeLineUpdateBefore\\\", true);\\n\\n  option(\\\"theme\\\", \\\"default\\\", function (cm) {\\n    themeChanged(cm);\\n    guttersChanged(cm);\\n  }, true);\\n  option(\\\"keyMap\\\", \\\"default\\\", function (cm, val, old) {\\n    var next = getKeyMap(val);\\n    var prev = old != Init && getKeyMap(old);\\n    if (prev && prev.detach) { prev.detach(cm, next); }\\n    if (next.attach) { next.attach(cm, prev || null); }\\n  });\\n  option(\\\"extraKeys\\\", null);\\n\\n  option(\\\"lineWrapping\\\", false, wrappingChanged, true);\\n  option(\\\"gutters\\\", [], function (cm) {\\n    setGuttersForLineNumbers(cm.options);\\n    guttersChanged(cm);\\n  }, true);\\n  option(\\\"fixedGutter\\\", true, function (cm, val) {\\n    cm.display.gutters.style.left = val ? compensateForHScroll(cm.display) + \\\"px\\\" : \\\"0\\\";\\n    cm.refresh();\\n  }, true);\\n  option(\\\"coverGutterNextToScrollbar\\\", false, function (cm) { return updateScrollbars(cm); }, true);\\n  option(\\\"scrollbarStyle\\\", \\\"native\\\", function (cm) {\\n    initScrollbars(cm);\\n    updateScrollbars(cm);\\n    cm.display.scrollbars.setScrollTop(cm.doc.scrollTop);\\n    cm.display.scrollbars.setScrollLeft(cm.doc.scrollLeft);\\n  }, true);\\n  option(\\\"lineNumbers\\\", false, function (cm) {\\n    setGuttersForLineNumbers(cm.options);\\n    guttersChanged(cm);\\n  }, true);\\n  option(\\\"firstLineNumber\\\", 1, guttersChanged, true);\\n  option(\\\"lineNumberFormatter\\\", function (integer) { return integer; }, guttersChanged, true);\\n  option(\\\"showCursorWhenSelecting\\\", false, updateSelection, true);\\n\\n  option(\\\"resetSelectionOnContextMenu\\\", true);\\n  option(\\\"lineWiseCopyCut\\\", true);\\n\\n  option(\\\"readOnly\\\", false, function (cm, val) {\\n    if (val == \\\"nocursor\\\") {\\n      onBlur(cm);\\n      cm.display.input.blur();\\n      cm.display.disabled = true;\\n    } else {\\n      cm.display.disabled = false;\\n    }\\n    cm.display.input.readOnlyChanged(val);\\n  });\\n  option(\\\"disableInput\\\", false, function (cm, val) {if (!val) { cm.display.input.reset(); }}, true);\\n  option(\\\"dragDrop\\\", true, dragDropChanged);\\n  option(\\\"allowDropFileTypes\\\", null);\\n\\n  option(\\\"cursorBlinkRate\\\", 530);\\n  option(\\\"cursorScrollMargin\\\", 0);\\n  option(\\\"cursorHeight\\\", 1, updateSelection, true);\\n  option(\\\"singleCursorHeightPerLine\\\", true, updateSelection, true);\\n  option(\\\"workTime\\\", 100);\\n  option(\\\"workDelay\\\", 100);\\n  option(\\\"flattenSpans\\\", true, resetModeState, true);\\n  option(\\\"addModeClass\\\", false, resetModeState, true);\\n  option(\\\"pollInterval\\\", 100);\\n  option(\\\"undoDepth\\\", 200, function (cm, val) { return cm.doc.history.undoDepth = val; });\\n  option(\\\"historyEventDelay\\\", 1250);\\n  option(\\\"viewportMargin\\\", 10, function (cm) { return cm.refresh(); }, true);\\n  option(\\\"maxHighlightLength\\\", 10000, resetModeState, true);\\n  option(\\\"moveInputWithCursor\\\", true, function (cm, val) {\\n    if (!val) { cm.display.input.resetPosition(); }\\n  });\\n\\n  option(\\\"tabindex\\\", null, function (cm, val) { return cm.display.input.getField().tabIndex = val || \\\"\\\"; });\\n  option(\\\"autofocus\\\", null);\\n  option(\\\"direction\\\", \\\"ltr\\\", function (cm, val) { return cm.doc.setDirection(val); }, true);\\n}\\n\\nfunction guttersChanged(cm) {\\n  updateGutters(cm);\\n  regChange(cm);\\n  alignHorizontally(cm);\\n}\\n\\nfunction dragDropChanged(cm, value, old) {\\n  var wasOn = old && old != Init;\\n  if (!value != !wasOn) {\\n    var funcs = cm.display.dragFunctions;\\n    var toggle = value ? on : off;\\n    toggle(cm.display.scroller, \\\"dragstart\\\", funcs.start);\\n    toggle(cm.display.scroller, \\\"dragenter\\\", funcs.enter);\\n    toggle(cm.display.scroller, \\\"dragover\\\", funcs.over);\\n    toggle(cm.display.scroller, \\\"dragleave\\\", funcs.leave);\\n    toggle(cm.display.scroller, \\\"drop\\\", funcs.drop);\\n  }\\n}\\n\\nfunction wrappingChanged(cm) {\\n  if (cm.options.lineWrapping) {\\n    addClass(cm.display.wrapper, \\\"CodeMirror-wrap\\\");\\n    cm.display.sizer.style.minWidth = \\\"\\\";\\n    cm.display.sizerWidth = null;\\n  } else {\\n    rmClass(cm.display.wrapper, \\\"CodeMirror-wrap\\\");\\n    findMaxLine(cm);\\n  }\\n  estimateLineHeights(cm);\\n  regChange(cm);\\n  clearCaches(cm);\\n  setTimeout(function () { return updateScrollbars(cm); }, 100);\\n}\\n\\n// A CodeMirror instance represents an editor. This is the object\\n// that user code is usually dealing with.\\n\\nfunction CodeMirror$1(place, options) {\\n  var this$1 = this;\\n\\n  if (!(this instanceof CodeMirror$1)) { return new CodeMirror$1(place, options) }\\n\\n  this.options = options = options ? copyObj(options) : {};\\n  // Determine effective options based on given values and defaults.\\n  copyObj(defaults, options, false);\\n  setGuttersForLineNumbers(options);\\n\\n  var doc = options.value;\\n  if (typeof doc == \\\"string\\\") { doc = new Doc(doc, options.mode, null, options.lineSeparator, options.direction); }\\n  this.doc = doc;\\n\\n  var input = new CodeMirror$1.inputStyles[options.inputStyle](this);\\n  var display = this.display = new Display(place, doc, input);\\n  display.wrapper.CodeMirror = this;\\n  updateGutters(this);\\n  themeChanged(this);\\n  if (options.lineWrapping)\\n    { this.display.wrapper.className += \\\" CodeMirror-wrap\\\"; }\\n  initScrollbars(this);\\n\\n  this.state = {\\n    keyMaps: [],  // stores maps added by addKeyMap\\n    overlays: [], // highlighting overlays, as added by addOverlay\\n    modeGen: 0,   // bumped when mode/overlay changes, used to invalidate highlighting info\\n    overwrite: false,\\n    delayingBlurEvent: false,\\n    focused: false,\\n    suppressEdits: false, // used to disable editing during key handlers when in readOnly mode\\n    pasteIncoming: false, cutIncoming: false, // help recognize paste/cut edits in input.poll\\n    selectingText: false,\\n    draggingText: false,\\n    highlight: new Delayed(), // stores highlight worker timeout\\n    keySeq: null,  // Unfinished key sequence\\n    specialChars: null\\n  };\\n\\n  if (options.autofocus && !mobile) { display.input.focus(); }\\n\\n  // Override magic textarea content restore that IE sometimes does\\n  // on our hidden textarea on reload\\n  if (ie && ie_version < 11) { setTimeout(function () { return this$1.display.input.reset(true); }, 20); }\\n\\n  registerEventHandlers(this);\\n  ensureGlobalHandlers();\\n\\n  startOperation(this);\\n  this.curOp.forceUpdate = true;\\n  attachDoc(this, doc);\\n\\n  if ((options.autofocus && !mobile) || this.hasFocus())\\n    { setTimeout(bind(onFocus, this), 20); }\\n  else\\n    { onBlur(this); }\\n\\n  for (var opt in optionHandlers) { if (optionHandlers.hasOwnProperty(opt))\\n    { optionHandlers[opt](this$1, options[opt], Init); } }\\n  maybeUpdateLineNumberWidth(this);\\n  if (options.finishInit) { options.finishInit(this); }\\n  for (var i = 0; i < initHooks.length; ++i) { initHooks[i](this$1); }\\n  endOperation(this);\\n  // Suppress optimizelegibility in Webkit, since it breaks text\\n  // measuring on line wrapping boundaries.\\n  if (webkit && options.lineWrapping &&\\n      getComputedStyle(display.lineDiv).textRendering == \\\"optimizelegibility\\\")\\n    { display.lineDiv.style.textRendering = \\\"auto\\\"; }\\n}\\n\\n// The default configuration options.\\nCodeMirror$1.defaults = defaults;\\n// Functions to run when options are changed.\\nCodeMirror$1.optionHandlers = optionHandlers;\\n\\n// Attach the necessary event handlers when initializing the editor\\nfunction registerEventHandlers(cm) {\\n  var d = cm.display;\\n  on(d.scroller, \\\"mousedown\\\", operation(cm, onMouseDown));\\n  // Older IE's will not fire a second mousedown for a double click\\n  if (ie && ie_version < 11)\\n    { on(d.scroller, \\\"dblclick\\\", operation(cm, function (e) {\\n      if (signalDOMEvent(cm, e)) { return }\\n      var pos = posFromMouse(cm, e);\\n      if (!pos || clickInGutter(cm, e) || eventInWidget(cm.display, e)) { return }\\n      e_preventDefault(e);\\n      var word = cm.findWordAt(pos);\\n      extendSelection(cm.doc, word.anchor, word.head);\\n    })); }\\n  else\\n    { on(d.scroller, \\\"dblclick\\\", function (e) { return signalDOMEvent(cm, e) || e_preventDefault(e); }); }\\n  // Some browsers fire contextmenu *after* opening the menu, at\\n  // which point we can't mess with it anymore. Context menu is\\n  // handled in onMouseDown for these browsers.\\n  if (!captureRightClick) { on(d.scroller, \\\"contextmenu\\\", function (e) { return onContextMenu(cm, e); }); }\\n\\n  // Used to suppress mouse event handling when a touch happens\\n  var touchFinished, prevTouch = {end: 0};\\n  function finishTouch() {\\n    if (d.activeTouch) {\\n      touchFinished = setTimeout(function () { return d.activeTouch = null; }, 1000);\\n      prevTouch = d.activeTouch;\\n      prevTouch.end = +new Date;\\n    }\\n  }\\n  function isMouseLikeTouchEvent(e) {\\n    if (e.touches.length != 1) { return false }\\n    var touch = e.touches[0];\\n    return touch.radiusX <= 1 && touch.radiusY <= 1\\n  }\\n  function farAway(touch, other) {\\n    if (other.left == null) { return true }\\n    var dx = other.left - touch.left, dy = other.top - touch.top;\\n    return dx * dx + dy * dy > 20 * 20\\n  }\\n  on(d.scroller, \\\"touchstart\\\", function (e) {\\n    if (!signalDOMEvent(cm, e) && !isMouseLikeTouchEvent(e)) {\\n      d.input.ensurePolled();\\n      clearTimeout(touchFinished);\\n      var now = +new Date;\\n      d.activeTouch = {start: now, moved: false,\\n                       prev: now - prevTouch.end <= 300 ? prevTouch : null};\\n      if (e.touches.length == 1) {\\n        d.activeTouch.left = e.touches[0].pageX;\\n        d.activeTouch.top = e.touches[0].pageY;\\n      }\\n    }\\n  });\\n  on(d.scroller, \\\"touchmove\\\", function () {\\n    if (d.activeTouch) { d.activeTouch.moved = true; }\\n  });\\n  on(d.scroller, \\\"touchend\\\", function (e) {\\n    var touch = d.activeTouch;\\n    if (touch && !eventInWidget(d, e) && touch.left != null &&\\n        !touch.moved && new Date - touch.start < 300) {\\n      var pos = cm.coordsChar(d.activeTouch, \\\"page\\\"), range;\\n      if (!touch.prev || farAway(touch, touch.prev)) // Single tap\\n        { range = new Range(pos, pos); }\\n      else if (!touch.prev.prev || farAway(touch, touch.prev.prev)) // Double tap\\n        { range = cm.findWordAt(pos); }\\n      else // Triple tap\\n        { range = new Range(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0))); }\\n      cm.setSelection(range.anchor, range.head);\\n      cm.focus();\\n      e_preventDefault(e);\\n    }\\n    finishTouch();\\n  });\\n  on(d.scroller, \\\"touchcancel\\\", finishTouch);\\n\\n  // Sync scrolling between fake scrollbars and real scrollable\\n  // area, ensure viewport is updated when scrolling.\\n  on(d.scroller, \\\"scroll\\\", function () {\\n    if (d.scroller.clientHeight) {\\n      setScrollTop(cm, d.scroller.scrollTop);\\n      setScrollLeft(cm, d.scroller.scrollLeft, true);\\n      signal(cm, \\\"scroll\\\", cm);\\n    }\\n  });\\n\\n  // Listen to wheel events in order to try and update the viewport on time.\\n  on(d.scroller, \\\"mousewheel\\\", function (e) { return onScrollWheel(cm, e); });\\n  on(d.scroller, \\\"DOMMouseScroll\\\", function (e) { return onScrollWheel(cm, e); });\\n\\n  // Prevent wrapper from ever scrolling\\n  on(d.wrapper, \\\"scroll\\\", function () { return d.wrapper.scrollTop = d.wrapper.scrollLeft = 0; });\\n\\n  d.dragFunctions = {\\n    enter: function (e) {if (!signalDOMEvent(cm, e)) { e_stop(e); }},\\n    over: function (e) {if (!signalDOMEvent(cm, e)) { onDragOver(cm, e); e_stop(e); }},\\n    start: function (e) { return onDragStart(cm, e); },\\n    drop: operation(cm, onDrop),\\n    leave: function (e) {if (!signalDOMEvent(cm, e)) { clearDragCursor(cm); }}\\n  };\\n\\n  var inp = d.input.getField();\\n  on(inp, \\\"keyup\\\", function (e) { return onKeyUp.call(cm, e); });\\n  on(inp, \\\"keydown\\\", operation(cm, onKeyDown));\\n  on(inp, \\\"keypress\\\", operation(cm, onKeyPress));\\n  on(inp, \\\"focus\\\", function (e) { return onFocus(cm, e); });\\n  on(inp, \\\"blur\\\", function (e) { return onBlur(cm, e); });\\n}\\n\\nvar initHooks = [];\\nCodeMirror$1.defineInitHook = function (f) { return initHooks.push(f); };\\n\\n// Indent the given line. The how parameter can be \\\"smart\\\",\\n// \\\"add\\\"/null, \\\"subtract\\\", or \\\"prev\\\". When aggressive is false\\n// (typically set to true for forced single-line indents), empty\\n// lines are not indented, and places where the mode returns Pass\\n// are left alone.\\nfunction indentLine(cm, n, how, aggressive) {\\n  var doc = cm.doc, state;\\n  if (how == null) { how = \\\"add\\\"; }\\n  if (how == \\\"smart\\\") {\\n    // Fall back to \\\"prev\\\" when the mode doesn't have an indentation\\n    // method.\\n    if (!doc.mode.indent) { how = \\\"prev\\\"; }\\n    else { state = getStateBefore(cm, n); }\\n  }\\n\\n  var tabSize = cm.options.tabSize;\\n  var line = getLine(doc, n), curSpace = countColumn(line.text, null, tabSize);\\n  if (line.stateAfter) { line.stateAfter = null; }\\n  var curSpaceString = line.text.match(/^\\\\s*/)[0], indentation;\\n  if (!aggressive && !/\\\\S/.test(line.text)) {\\n    indentation = 0;\\n    how = \\\"not\\\";\\n  } else if (how == \\\"smart\\\") {\\n    indentation = doc.mode.indent(state, line.text.slice(curSpaceString.length), line.text);\\n    if (indentation == Pass || indentation > 150) {\\n      if (!aggressive) { return }\\n      how = \\\"prev\\\";\\n    }\\n  }\\n  if (how == \\\"prev\\\") {\\n    if (n > doc.first) { indentation = countColumn(getLine(doc, n-1).text, null, tabSize); }\\n    else { indentation = 0; }\\n  } else if (how == \\\"add\\\") {\\n    indentation = curSpace + cm.options.indentUnit;\\n  } else if (how == \\\"subtract\\\") {\\n    indentation = curSpace - cm.options.indentUnit;\\n  } else if (typeof how == \\\"number\\\") {\\n    indentation = curSpace + how;\\n  }\\n  indentation = Math.max(0, indentation);\\n\\n  var indentString = \\\"\\\", pos = 0;\\n  if (cm.options.indentWithTabs)\\n    { for (var i = Math.floor(indentation / tabSize); i; --i) {pos += tabSize; indentString += \\\"\\\\t\\\";} }\\n  if (pos < indentation) { indentString += spaceStr(indentation - pos); }\\n\\n  if (indentString != curSpaceString) {\\n    replaceRange(doc, indentString, Pos(n, 0), Pos(n, curSpaceString.length), \\\"+input\\\");\\n    line.stateAfter = null;\\n    return true\\n  } else {\\n    // Ensure that, if the cursor was in the whitespace at the start\\n    // of the line, it is moved to the end of that space.\\n    for (var i$1 = 0; i$1 < doc.sel.ranges.length; i$1++) {\\n      var range = doc.sel.ranges[i$1];\\n      if (range.head.line == n && range.head.ch < curSpaceString.length) {\\n        var pos$1 = Pos(n, curSpaceString.length);\\n        replaceOneSelection(doc, i$1, new Range(pos$1, pos$1));\\n        break\\n      }\\n    }\\n  }\\n}\\n\\n// This will be set to a {lineWise: bool, text: [string]} object, so\\n// that, when pasting, we know what kind of selections the copied\\n// text was made out of.\\nvar lastCopied = null;\\n\\nfunction setLastCopied(newLastCopied) {\\n  lastCopied = newLastCopied;\\n}\\n\\nfunction applyTextInput(cm, inserted, deleted, sel, origin) {\\n  var doc = cm.doc;\\n  cm.display.shift = false;\\n  if (!sel) { sel = doc.sel; }\\n\\n  var paste = cm.state.pasteIncoming || origin == \\\"paste\\\";\\n  var textLines = splitLinesAuto(inserted), multiPaste = null;\\n  // When pasing N lines into N selections, insert one line per selection\\n  if (paste && sel.ranges.length > 1) {\\n    if (lastCopied && lastCopied.text.join(\\\"\\\\n\\\") == inserted) {\\n      if (sel.ranges.length % lastCopied.text.length == 0) {\\n        multiPaste = [];\\n        for (var i = 0; i < lastCopied.text.length; i++)\\n          { multiPaste.push(doc.splitLines(lastCopied.text[i])); }\\n      }\\n    } else if (textLines.length == sel.ranges.length) {\\n      multiPaste = map(textLines, function (l) { return [l]; });\\n    }\\n  }\\n\\n  var updateInput;\\n  // Normal behavior is to insert the new text into every selection\\n  for (var i$1 = sel.ranges.length - 1; i$1 >= 0; i$1--) {\\n    var range$$1 = sel.ranges[i$1];\\n    var from = range$$1.from(), to = range$$1.to();\\n    if (range$$1.empty()) {\\n      if (deleted && deleted > 0) // Handle deletion\\n        { from = Pos(from.line, from.ch - deleted); }\\n      else if (cm.state.overwrite && !paste) // Handle overwrite\\n        { to = Pos(to.line, Math.min(getLine(doc, to.line).text.length, to.ch + lst(textLines).length)); }\\n      else if (lastCopied && lastCopied.lineWise && lastCopied.text.join(\\\"\\\\n\\\") == inserted)\\n        { from = to = Pos(from.line, 0); }\\n    }\\n    updateInput = cm.curOp.updateInput;\\n    var changeEvent = {from: from, to: to, text: multiPaste ? multiPaste[i$1 % multiPaste.length] : textLines,\\n                       origin: origin || (paste ? \\\"paste\\\" : cm.state.cutIncoming ? \\\"cut\\\" : \\\"+input\\\")};\\n    makeChange(cm.doc, changeEvent);\\n    signalLater(cm, \\\"inputRead\\\", cm, changeEvent);\\n  }\\n  if (inserted && !paste)\\n    { triggerElectric(cm, inserted); }\\n\\n  ensureCursorVisible(cm);\\n  cm.curOp.updateInput = updateInput;\\n  cm.curOp.typing = true;\\n  cm.state.pasteIncoming = cm.state.cutIncoming = false;\\n}\\n\\nfunction handlePaste(e, cm) {\\n  var pasted = e.clipboardData && e.clipboardData.getData(\\\"Text\\\");\\n  if (pasted) {\\n    e.preventDefault();\\n    if (!cm.isReadOnly() && !cm.options.disableInput)\\n      { runInOp(cm, function () { return applyTextInput(cm, pasted, 0, null, \\\"paste\\\"); }); }\\n    return true\\n  }\\n}\\n\\nfunction triggerElectric(cm, inserted) {\\n  // When an 'electric' character is inserted, immediately trigger a reindent\\n  if (!cm.options.electricChars || !cm.options.smartIndent) { return }\\n  var sel = cm.doc.sel;\\n\\n  for (var i = sel.ranges.length - 1; i >= 0; i--) {\\n    var range$$1 = sel.ranges[i];\\n    if (range$$1.head.ch > 100 || (i && sel.ranges[i - 1].head.line == range$$1.head.line)) { continue }\\n    var mode = cm.getModeAt(range$$1.head);\\n    var indented = false;\\n    if (mode.electricChars) {\\n      for (var j = 0; j < mode.electricChars.length; j++)\\n        { if (inserted.indexOf(mode.electricChars.charAt(j)) > -1) {\\n          indented = indentLine(cm, range$$1.head.line, \\\"smart\\\");\\n          break\\n        } }\\n    } else if (mode.electricInput) {\\n      if (mode.electricInput.test(getLine(cm.doc, range$$1.head.line).text.slice(0, range$$1.head.ch)))\\n        { indented = indentLine(cm, range$$1.head.line, \\\"smart\\\"); }\\n    }\\n    if (indented) { signalLater(cm, \\\"electricInput\\\", cm, range$$1.head.line); }\\n  }\\n}\\n\\nfunction copyableRanges(cm) {\\n  var text = [], ranges = [];\\n  for (var i = 0; i < cm.doc.sel.ranges.length; i++) {\\n    var line = cm.doc.sel.ranges[i].head.line;\\n    var lineRange = {anchor: Pos(line, 0), head: Pos(line + 1, 0)};\\n    ranges.push(lineRange);\\n    text.push(cm.getRange(lineRange.anchor, lineRange.head));\\n  }\\n  return {text: text, ranges: ranges}\\n}\\n\\nfunction disableBrowserMagic(field, spellcheck) {\\n  field.setAttribute(\\\"autocorrect\\\", \\\"off\\\");\\n  field.setAttribute(\\\"autocapitalize\\\", \\\"off\\\");\\n  field.setAttribute(\\\"spellcheck\\\", !!spellcheck);\\n}\\n\\nfunction hiddenTextarea() {\\n  var te = elt(\\\"textarea\\\", null, null, \\\"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none\\\");\\n  var div = elt(\\\"div\\\", [te], null, \\\"overflow: hidden; position: relative; width: 3px; height: 0px;\\\");\\n  // The textarea is kept positioned near the cursor to prevent the\\n  // fact that it'll be scrolled into view on input from scrolling\\n  // our fake cursor out of view. On webkit, when wrap=off, paste is\\n  // very slow. So make the area wide instead.\\n  if (webkit) { te.style.width = \\\"1000px\\\"; }\\n  else { te.setAttribute(\\\"wrap\\\", \\\"off\\\"); }\\n  // If border: 0; -- iOS fails to open keyboard (issue #1287)\\n  if (ios) { te.style.border = \\\"1px solid black\\\"; }\\n  disableBrowserMagic(te);\\n  return div\\n}\\n\\n// The publicly visible API. Note that methodOp(f) means\\n// 'wrap f in an operation, performed on its `this` parameter'.\\n\\n// This is not the complete set of editor methods. Most of the\\n// methods defined on the Doc type are also injected into\\n// CodeMirror.prototype, for backwards compatibility and\\n// convenience.\\n\\nvar addEditorMethods = function(CodeMirror) {\\n  var optionHandlers = CodeMirror.optionHandlers;\\n\\n  var helpers = CodeMirror.helpers = {};\\n\\n  CodeMirror.prototype = {\\n    constructor: CodeMirror,\\n    focus: function(){window.focus(); this.display.input.focus();},\\n\\n    setOption: function(option, value) {\\n      var options = this.options, old = options[option];\\n      if (options[option] == value && option != \\\"mode\\\") { return }\\n      options[option] = value;\\n      if (optionHandlers.hasOwnProperty(option))\\n        { operation(this, optionHandlers[option])(this, value, old); }\\n      signal(this, \\\"optionChange\\\", this, option);\\n    },\\n\\n    getOption: function(option) {return this.options[option]},\\n    getDoc: function() {return this.doc},\\n\\n    addKeyMap: function(map$$1, bottom) {\\n      this.state.keyMaps[bottom ? \\\"push\\\" : \\\"unshift\\\"](getKeyMap(map$$1));\\n    },\\n    removeKeyMap: function(map$$1) {\\n      var maps = this.state.keyMaps;\\n      for (var i = 0; i < maps.length; ++i)\\n        { if (maps[i] == map$$1 || maps[i].name == map$$1) {\\n          maps.splice(i, 1);\\n          return true\\n        } }\\n    },\\n\\n    addOverlay: methodOp(function(spec, options) {\\n      var mode = spec.token ? spec : CodeMirror.getMode(this.options, spec);\\n      if (mode.startState) { throw new Error(\\\"Overlays may not be stateful.\\\") }\\n      insertSorted(this.state.overlays,\\n                   {mode: mode, modeSpec: spec, opaque: options && options.opaque,\\n                    priority: (options && options.priority) || 0},\\n                   function (overlay) { return overlay.priority; });\\n      this.state.modeGen++;\\n      regChange(this);\\n    }),\\n    removeOverlay: methodOp(function(spec) {\\n      var this$1 = this;\\n\\n      var overlays = this.state.overlays;\\n      for (var i = 0; i < overlays.length; ++i) {\\n        var cur = overlays[i].modeSpec;\\n        if (cur == spec || typeof spec == \\\"string\\\" && cur.name == spec) {\\n          overlays.splice(i, 1);\\n          this$1.state.modeGen++;\\n          regChange(this$1);\\n          return\\n        }\\n      }\\n    }),\\n\\n    indentLine: methodOp(function(n, dir, aggressive) {\\n      if (typeof dir != \\\"string\\\" && typeof dir != \\\"number\\\") {\\n        if (dir == null) { dir = this.options.smartIndent ? \\\"smart\\\" : \\\"prev\\\"; }\\n        else { dir = dir ? \\\"add\\\" : \\\"subtract\\\"; }\\n      }\\n      if (isLine(this.doc, n)) { indentLine(this, n, dir, aggressive); }\\n    }),\\n    indentSelection: methodOp(function(how) {\\n      var this$1 = this;\\n\\n      var ranges = this.doc.sel.ranges, end = -1;\\n      for (var i = 0; i < ranges.length; i++) {\\n        var range$$1 = ranges[i];\\n        if (!range$$1.empty()) {\\n          var from = range$$1.from(), to = range$$1.to();\\n          var start = Math.max(end, from.line);\\n          end = Math.min(this$1.lastLine(), to.line - (to.ch ? 0 : 1)) + 1;\\n          for (var j = start; j < end; ++j)\\n            { indentLine(this$1, j, how); }\\n          var newRanges = this$1.doc.sel.ranges;\\n          if (from.ch == 0 && ranges.length == newRanges.length && newRanges[i].from().ch > 0)\\n            { replaceOneSelection(this$1.doc, i, new Range(from, newRanges[i].to()), sel_dontScroll); }\\n        } else if (range$$1.head.line > end) {\\n          indentLine(this$1, range$$1.head.line, how, true);\\n          end = range$$1.head.line;\\n          if (i == this$1.doc.sel.primIndex) { ensureCursorVisible(this$1); }\\n        }\\n      }\\n    }),\\n\\n    // Fetch the parser token for a given character. Useful for hacks\\n    // that want to inspect the mode state (say, for completion).\\n    getTokenAt: function(pos, precise) {\\n      return takeToken(this, pos, precise)\\n    },\\n\\n    getLineTokens: function(line, precise) {\\n      return takeToken(this, Pos(line), precise, true)\\n    },\\n\\n    getTokenTypeAt: function(pos) {\\n      pos = clipPos(this.doc, pos);\\n      var styles = getLineStyles(this, getLine(this.doc, pos.line));\\n      var before = 0, after = (styles.length - 1) / 2, ch = pos.ch;\\n      var type;\\n      if (ch == 0) { type = styles[2]; }\\n      else { for (;;) {\\n        var mid = (before + after) >> 1;\\n        if ((mid ? styles[mid * 2 - 1] : 0) >= ch) { after = mid; }\\n        else if (styles[mid * 2 + 1] < ch) { before = mid + 1; }\\n        else { type = styles[mid * 2 + 2]; break }\\n      } }\\n      var cut = type ? type.indexOf(\\\"overlay \\\") : -1;\\n      return cut < 0 ? type : cut == 0 ? null : type.slice(0, cut - 1)\\n    },\\n\\n    getModeAt: function(pos) {\\n      var mode = this.doc.mode;\\n      if (!mode.innerMode) { return mode }\\n      return CodeMirror.innerMode(mode, this.getTokenAt(pos).state).mode\\n    },\\n\\n    getHelper: function(pos, type) {\\n      return this.getHelpers(pos, type)[0]\\n    },\\n\\n    getHelpers: function(pos, type) {\\n      var this$1 = this;\\n\\n      var found = [];\\n      if (!helpers.hasOwnProperty(type)) { return found }\\n      var help = helpers[type], mode = this.getModeAt(pos);\\n      if (typeof mode[type] == \\\"string\\\") {\\n        if (help[mode[type]]) { found.push(help[mode[type]]); }\\n      } else if (mode[type]) {\\n        for (var i = 0; i < mode[type].length; i++) {\\n          var val = help[mode[type][i]];\\n          if (val) { found.push(val); }\\n        }\\n      } else if (mode.helperType && help[mode.helperType]) {\\n        found.push(help[mode.helperType]);\\n      } else if (help[mode.name]) {\\n        found.push(help[mode.name]);\\n      }\\n      for (var i$1 = 0; i$1 < help._global.length; i$1++) {\\n        var cur = help._global[i$1];\\n        if (cur.pred(mode, this$1) && indexOf(found, cur.val) == -1)\\n          { found.push(cur.val); }\\n      }\\n      return found\\n    },\\n\\n    getStateAfter: function(line, precise) {\\n      var doc = this.doc;\\n      line = clipLine(doc, line == null ? doc.first + doc.size - 1: line);\\n      return getStateBefore(this, line + 1, precise)\\n    },\\n\\n    cursorCoords: function(start, mode) {\\n      var pos, range$$1 = this.doc.sel.primary();\\n      if (start == null) { pos = range$$1.head; }\\n      else if (typeof start == \\\"object\\\") { pos = clipPos(this.doc, start); }\\n      else { pos = start ? range$$1.from() : range$$1.to(); }\\n      return cursorCoords(this, pos, mode || \\\"page\\\")\\n    },\\n\\n    charCoords: function(pos, mode) {\\n      return charCoords(this, clipPos(this.doc, pos), mode || \\\"page\\\")\\n    },\\n\\n    coordsChar: function(coords, mode) {\\n      coords = fromCoordSystem(this, coords, mode || \\\"page\\\");\\n      return coordsChar(this, coords.left, coords.top)\\n    },\\n\\n    lineAtHeight: function(height, mode) {\\n      height = fromCoordSystem(this, {top: height, left: 0}, mode || \\\"page\\\").top;\\n      return lineAtHeight(this.doc, height + this.display.viewOffset)\\n    },\\n    heightAtLine: function(line, mode, includeWidgets) {\\n      var end = false, lineObj;\\n      if (typeof line == \\\"number\\\") {\\n        var last = this.doc.first + this.doc.size - 1;\\n        if (line < this.doc.first) { line = this.doc.first; }\\n        else if (line > last) { line = last; end = true; }\\n        lineObj = getLine(this.doc, line);\\n      } else {\\n        lineObj = line;\\n      }\\n      return intoCoordSystem(this, lineObj, {top: 0, left: 0}, mode || \\\"page\\\", includeWidgets || end).top +\\n        (end ? this.doc.height - heightAtLine(lineObj) : 0)\\n    },\\n\\n    defaultTextHeight: function() { return textHeight(this.display) },\\n    defaultCharWidth: function() { return charWidth(this.display) },\\n\\n    getViewport: function() { return {from: this.display.viewFrom, to: this.display.viewTo}},\\n\\n    addWidget: function(pos, node, scroll, vert, horiz) {\\n      var display = this.display;\\n      pos = cursorCoords(this, clipPos(this.doc, pos));\\n      var top = pos.bottom, left = pos.left;\\n      node.style.position = \\\"absolute\\\";\\n      node.setAttribute(\\\"cm-ignore-events\\\", \\\"true\\\");\\n      this.display.input.setUneditable(node);\\n      display.sizer.appendChild(node);\\n      if (vert == \\\"over\\\") {\\n        top = pos.top;\\n      } else if (vert == \\\"above\\\" || vert == \\\"near\\\") {\\n        var vspace = Math.max(display.wrapper.clientHeight, this.doc.height),\\n        hspace = Math.max(display.sizer.clientWidth, display.lineSpace.clientWidth);\\n        // Default to positioning above (if specified and possible); otherwise default to positioning below\\n        if ((vert == 'above' || pos.bottom + node.offsetHeight > vspace) && pos.top > node.offsetHeight)\\n          { top = pos.top - node.offsetHeight; }\\n        else if (pos.bottom + node.offsetHeight <= vspace)\\n          { top = pos.bottom; }\\n        if (left + node.offsetWidth > hspace)\\n          { left = hspace - node.offsetWidth; }\\n      }\\n      node.style.top = top + \\\"px\\\";\\n      node.style.left = node.style.right = \\\"\\\";\\n      if (horiz == \\\"right\\\") {\\n        left = display.sizer.clientWidth - node.offsetWidth;\\n        node.style.right = \\\"0px\\\";\\n      } else {\\n        if (horiz == \\\"left\\\") { left = 0; }\\n        else if (horiz == \\\"middle\\\") { left = (display.sizer.clientWidth - node.offsetWidth) / 2; }\\n        node.style.left = left + \\\"px\\\";\\n      }\\n      if (scroll)\\n        { scrollIntoView(this, {left: left, top: top, right: left + node.offsetWidth, bottom: top + node.offsetHeight}); }\\n    },\\n\\n    triggerOnKeyDown: methodOp(onKeyDown),\\n    triggerOnKeyPress: methodOp(onKeyPress),\\n    triggerOnKeyUp: onKeyUp,\\n\\n    execCommand: function(cmd) {\\n      if (commands.hasOwnProperty(cmd))\\n        { return commands[cmd].call(null, this) }\\n    },\\n\\n    triggerElectric: methodOp(function(text) { triggerElectric(this, text); }),\\n\\n    findPosH: function(from, amount, unit, visually) {\\n      var this$1 = this;\\n\\n      var dir = 1;\\n      if (amount < 0) { dir = -1; amount = -amount; }\\n      var cur = clipPos(this.doc, from);\\n      for (var i = 0; i < amount; ++i) {\\n        cur = findPosH(this$1.doc, cur, dir, unit, visually);\\n        if (cur.hitSide) { break }\\n      }\\n      return cur\\n    },\\n\\n    moveH: methodOp(function(dir, unit) {\\n      var this$1 = this;\\n\\n      this.extendSelectionsBy(function (range$$1) {\\n        if (this$1.display.shift || this$1.doc.extend || range$$1.empty())\\n          { return findPosH(this$1.doc, range$$1.head, dir, unit, this$1.options.rtlMoveVisually) }\\n        else\\n          { return dir < 0 ? range$$1.from() : range$$1.to() }\\n      }, sel_move);\\n    }),\\n\\n    deleteH: methodOp(function(dir, unit) {\\n      var sel = this.doc.sel, doc = this.doc;\\n      if (sel.somethingSelected())\\n        { doc.replaceSelection(\\\"\\\", null, \\\"+delete\\\"); }\\n      else\\n        { deleteNearSelection(this, function (range$$1) {\\n          var other = findPosH(doc, range$$1.head, dir, unit, false);\\n          return dir < 0 ? {from: other, to: range$$1.head} : {from: range$$1.head, to: other}\\n        }); }\\n    }),\\n\\n    findPosV: function(from, amount, unit, goalColumn) {\\n      var this$1 = this;\\n\\n      var dir = 1, x = goalColumn;\\n      if (amount < 0) { dir = -1; amount = -amount; }\\n      var cur = clipPos(this.doc, from);\\n      for (var i = 0; i < amount; ++i) {\\n        var coords = cursorCoords(this$1, cur, \\\"div\\\");\\n        if (x == null) { x = coords.left; }\\n        else { coords.left = x; }\\n        cur = findPosV(this$1, coords, dir, unit);\\n        if (cur.hitSide) { break }\\n      }\\n      return cur\\n    },\\n\\n    moveV: methodOp(function(dir, unit) {\\n      var this$1 = this;\\n\\n      var doc = this.doc, goals = [];\\n      var collapse = !this.display.shift && !doc.extend && doc.sel.somethingSelected();\\n      doc.extendSelectionsBy(function (range$$1) {\\n        if (collapse)\\n          { return dir < 0 ? range$$1.from() : range$$1.to() }\\n        var headPos = cursorCoords(this$1, range$$1.head, \\\"div\\\");\\n        if (range$$1.goalColumn != null) { headPos.left = range$$1.goalColumn; }\\n        goals.push(headPos.left);\\n        var pos = findPosV(this$1, headPos, dir, unit);\\n        if (unit == \\\"page\\\" && range$$1 == doc.sel.primary())\\n          { addToScrollPos(this$1, null, charCoords(this$1, pos, \\\"div\\\").top - headPos.top); }\\n        return pos\\n      }, sel_move);\\n      if (goals.length) { for (var i = 0; i < doc.sel.ranges.length; i++)\\n        { doc.sel.ranges[i].goalColumn = goals[i]; } }\\n    }),\\n\\n    // Find the word at the given position (as returned by coordsChar).\\n    findWordAt: function(pos) {\\n      var doc = this.doc, line = getLine(doc, pos.line).text;\\n      var start = pos.ch, end = pos.ch;\\n      if (line) {\\n        var helper = this.getHelper(pos, \\\"wordChars\\\");\\n        if ((pos.sticky == \\\"before\\\" || end == line.length) && start) { --start; } else { ++end; }\\n        var startChar = line.charAt(start);\\n        var check = isWordChar(startChar, helper)\\n          ? function (ch) { return isWordChar(ch, helper); }\\n          : /\\\\s/.test(startChar) ? function (ch) { return /\\\\s/.test(ch); }\\n          : function (ch) { return (!/\\\\s/.test(ch) && !isWordChar(ch)); };\\n        while (start > 0 && check(line.charAt(start - 1))) { --start; }\\n        while (end < line.length && check(line.charAt(end))) { ++end; }\\n      }\\n      return new Range(Pos(pos.line, start), Pos(pos.line, end))\\n    },\\n\\n    toggleOverwrite: function(value) {\\n      if (value != null && value == this.state.overwrite) { return }\\n      if (this.state.overwrite = !this.state.overwrite)\\n        { addClass(this.display.cursorDiv, \\\"CodeMirror-overwrite\\\"); }\\n      else\\n        { rmClass(this.display.cursorDiv, \\\"CodeMirror-overwrite\\\"); }\\n\\n      signal(this, \\\"overwriteToggle\\\", this, this.state.overwrite);\\n    },\\n    hasFocus: function() { return this.display.input.getField() == activeElt() },\\n    isReadOnly: function() { return !!(this.options.readOnly || this.doc.cantEdit) },\\n\\n    scrollTo: methodOp(function(x, y) {\\n      if (x != null || y != null) { resolveScrollToPos(this); }\\n      if (x != null) { this.curOp.scrollLeft = x; }\\n      if (y != null) { this.curOp.scrollTop = y; }\\n    }),\\n    getScrollInfo: function() {\\n      var scroller = this.display.scroller;\\n      return {left: scroller.scrollLeft, top: scroller.scrollTop,\\n              height: scroller.scrollHeight - scrollGap(this) - this.display.barHeight,\\n              width: scroller.scrollWidth - scrollGap(this) - this.display.barWidth,\\n              clientHeight: displayHeight(this), clientWidth: displayWidth(this)}\\n    },\\n\\n    scrollIntoView: methodOp(function(range$$1, margin) {\\n      if (range$$1 == null) {\\n        range$$1 = {from: this.doc.sel.primary().head, to: null};\\n        if (margin == null) { margin = this.options.cursorScrollMargin; }\\n      } else if (typeof range$$1 == \\\"number\\\") {\\n        range$$1 = {from: Pos(range$$1, 0), to: null};\\n      } else if (range$$1.from == null) {\\n        range$$1 = {from: range$$1, to: null};\\n      }\\n      if (!range$$1.to) { range$$1.to = range$$1.from; }\\n      range$$1.margin = margin || 0;\\n\\n      if (range$$1.from.line != null) {\\n        resolveScrollToPos(this);\\n        this.curOp.scrollToPos = range$$1;\\n      } else {\\n        var sPos = calculateScrollPos(this, {\\n          left: Math.min(range$$1.from.left, range$$1.to.left),\\n          top: Math.min(range$$1.from.top, range$$1.to.top) - range$$1.margin,\\n          right: Math.max(range$$1.from.right, range$$1.to.right),\\n          bottom: Math.max(range$$1.from.bottom, range$$1.to.bottom) + range$$1.margin\\n        });\\n        this.scrollTo(sPos.scrollLeft, sPos.scrollTop);\\n      }\\n    }),\\n\\n    setSize: methodOp(function(width, height) {\\n      var this$1 = this;\\n\\n      var interpret = function (val) { return typeof val == \\\"number\\\" || /^\\\\d+$/.test(String(val)) ? val + \\\"px\\\" : val; };\\n      if (width != null) { this.display.wrapper.style.width = interpret(width); }\\n      if (height != null) { this.display.wrapper.style.height = interpret(height); }\\n      if (this.options.lineWrapping) { clearLineMeasurementCache(this); }\\n      var lineNo$$1 = this.display.viewFrom;\\n      this.doc.iter(lineNo$$1, this.display.viewTo, function (line) {\\n        if (line.widgets) { for (var i = 0; i < line.widgets.length; i++)\\n          { if (line.widgets[i].noHScroll) { regLineChange(this$1, lineNo$$1, \\\"widget\\\"); break } } }\\n        ++lineNo$$1;\\n      });\\n      this.curOp.forceUpdate = true;\\n      signal(this, \\\"refresh\\\", this);\\n    }),\\n\\n    operation: function(f){return runInOp(this, f)},\\n\\n    refresh: methodOp(function() {\\n      var oldHeight = this.display.cachedTextHeight;\\n      regChange(this);\\n      this.curOp.forceUpdate = true;\\n      clearCaches(this);\\n      this.scrollTo(this.doc.scrollLeft, this.doc.scrollTop);\\n      updateGutterSpace(this);\\n      if (oldHeight == null || Math.abs(oldHeight - textHeight(this.display)) > .5)\\n        { estimateLineHeights(this); }\\n      signal(this, \\\"refresh\\\", this);\\n    }),\\n\\n    swapDoc: methodOp(function(doc) {\\n      var old = this.doc;\\n      old.cm = null;\\n      attachDoc(this, doc);\\n      clearCaches(this);\\n      this.display.input.reset();\\n      this.scrollTo(doc.scrollLeft, doc.scrollTop);\\n      this.curOp.forceScroll = true;\\n      signalLater(this, \\\"swapDoc\\\", this, old);\\n      return old\\n    }),\\n\\n    getInputField: function(){return this.display.input.getField()},\\n    getWrapperElement: function(){return this.display.wrapper},\\n    getScrollerElement: function(){return this.display.scroller},\\n    getGutterElement: function(){return this.display.gutters}\\n  };\\n  eventMixin(CodeMirror);\\n\\n  CodeMirror.registerHelper = function(type, name, value) {\\n    if (!helpers.hasOwnProperty(type)) { helpers[type] = CodeMirror[type] = {_global: []}; }\\n    helpers[type][name] = value;\\n  };\\n  CodeMirror.registerGlobalHelper = function(type, name, predicate, value) {\\n    CodeMirror.registerHelper(type, name, value);\\n    helpers[type]._global.push({pred: predicate, val: value});\\n  };\\n};\\n\\n// Used for horizontal relative motion. Dir is -1 or 1 (left or\\n// right), unit can be \\\"char\\\", \\\"column\\\" (like char, but doesn't\\n// cross line boundaries), \\\"word\\\" (across next word), or \\\"group\\\" (to\\n// the start of next group of word or non-word-non-whitespace\\n// chars). The visually param controls whether, in right-to-left\\n// text, direction 1 means to move towards the next index in the\\n// string, or towards the character to the right of the current\\n// position. The resulting position will have a hitSide=true\\n// property if it reached the end of the document.\\nfunction findPosH(doc, pos, dir, unit, visually) {\\n  var oldPos = pos;\\n  var origDir = dir;\\n  var lineObj = getLine(doc, pos.line);\\n  function findNextLine() {\\n    var l = pos.line + dir;\\n    if (l < doc.first || l >= doc.first + doc.size) { return false }\\n    pos = new Pos(l, pos.ch, pos.sticky);\\n    return lineObj = getLine(doc, l)\\n  }\\n  function moveOnce(boundToLine) {\\n    var next;\\n    if (visually) {\\n      next = moveVisually(doc.cm, lineObj, pos, dir);\\n    } else {\\n      next = moveLogically(lineObj, pos, dir);\\n    }\\n    if (next == null) {\\n      if (!boundToLine && findNextLine())\\n        { pos = endOfLine(visually, doc.cm, lineObj, pos.line, dir); }\\n      else\\n        { return false }\\n    } else {\\n      pos = next;\\n    }\\n    return true\\n  }\\n\\n  if (unit == \\\"char\\\") {\\n    moveOnce();\\n  } else if (unit == \\\"column\\\") {\\n    moveOnce(true);\\n  } else if (unit == \\\"word\\\" || unit == \\\"group\\\") {\\n    var sawType = null, group = unit == \\\"group\\\";\\n    var helper = doc.cm && doc.cm.getHelper(pos, \\\"wordChars\\\");\\n    for (var first = true;; first = false) {\\n      if (dir < 0 && !moveOnce(!first)) { break }\\n      var cur = lineObj.text.charAt(pos.ch) || \\\"\\\\n\\\";\\n      var type = isWordChar(cur, helper) ? \\\"w\\\"\\n        : group && cur == \\\"\\\\n\\\" ? \\\"n\\\"\\n        : !group || /\\\\s/.test(cur) ? null\\n        : \\\"p\\\";\\n      if (group && !first && !type) { type = \\\"s\\\"; }\\n      if (sawType && sawType != type) {\\n        if (dir < 0) {dir = 1; moveOnce(); pos.sticky = \\\"after\\\";}\\n        break\\n      }\\n\\n      if (type) { sawType = type; }\\n      if (dir > 0 && !moveOnce(!first)) { break }\\n    }\\n  }\\n  var result = skipAtomic(doc, pos, oldPos, origDir, true);\\n  if (equalCursorPos(oldPos, result)) { result.hitSide = true; }\\n  return result\\n}\\n\\n// For relative vertical movement. Dir may be -1 or 1. Unit can be\\n// \\\"page\\\" or \\\"line\\\". The resulting position will have a hitSide=true\\n// property if it reached the end of the document.\\nfunction findPosV(cm, pos, dir, unit) {\\n  var doc = cm.doc, x = pos.left, y;\\n  if (unit == \\\"page\\\") {\\n    var pageSize = Math.min(cm.display.wrapper.clientHeight, window.innerHeight || document.documentElement.clientHeight);\\n    var moveAmount = Math.max(pageSize - .5 * textHeight(cm.display), 3);\\n    y = (dir > 0 ? pos.bottom : pos.top) + dir * moveAmount;\\n\\n  } else if (unit == \\\"line\\\") {\\n    y = dir > 0 ? pos.bottom + 3 : pos.top - 3;\\n  }\\n  var target;\\n  for (;;) {\\n    target = coordsChar(cm, x, y);\\n    if (!target.outside) { break }\\n    if (dir < 0 ? y <= 0 : y >= doc.height) { target.hitSide = true; break }\\n    y += dir * 5;\\n  }\\n  return target\\n}\\n\\n// CONTENTEDITABLE INPUT STYLE\\n\\nvar ContentEditableInput = function(cm) {\\n  this.cm = cm;\\n  this.lastAnchorNode = this.lastAnchorOffset = this.lastFocusNode = this.lastFocusOffset = null;\\n  this.polling = new Delayed();\\n  this.composing = null;\\n  this.gracePeriod = false;\\n  this.readDOMTimeout = null;\\n};\\n\\nContentEditableInput.prototype.init = function (display) {\\n    var this$1 = this;\\n\\n  var input = this, cm = input.cm;\\n  var div = input.div = display.lineDiv;\\n  disableBrowserMagic(div, cm.options.spellcheck);\\n\\n  on(div, \\\"paste\\\", function (e) {\\n    if (signalDOMEvent(cm, e) || handlePaste(e, cm)) { return }\\n    // IE doesn't fire input events, so we schedule a read for the pasted content in this way\\n    if (ie_version <= 11) { setTimeout(operation(cm, function () { return this$1.updateFromDOM(); }), 20); }\\n  });\\n\\n  on(div, \\\"compositionstart\\\", function (e) {\\n    this$1.composing = {data: e.data, done: false};\\n  });\\n  on(div, \\\"compositionupdate\\\", function (e) {\\n    if (!this$1.composing) { this$1.composing = {data: e.data, done: false}; }\\n  });\\n  on(div, \\\"compositionend\\\", function (e) {\\n    if (this$1.composing) {\\n      if (e.data != this$1.composing.data) { this$1.readFromDOMSoon(); }\\n      this$1.composing.done = true;\\n    }\\n  });\\n\\n  on(div, \\\"touchstart\\\", function () { return input.forceCompositionEnd(); });\\n\\n  on(div, \\\"input\\\", function () {\\n    if (!this$1.composing) { this$1.readFromDOMSoon(); }\\n  });\\n\\n  function onCopyCut(e) {\\n    if (signalDOMEvent(cm, e)) { return }\\n    if (cm.somethingSelected()) {\\n      setLastCopied({lineWise: false, text: cm.getSelections()});\\n      if (e.type == \\\"cut\\\") { cm.replaceSelection(\\\"\\\", null, \\\"cut\\\"); }\\n    } else if (!cm.options.lineWiseCopyCut) {\\n      return\\n    } else {\\n      var ranges = copyableRanges(cm);\\n      setLastCopied({lineWise: true, text: ranges.text});\\n      if (e.type == \\\"cut\\\") {\\n        cm.operation(function () {\\n          cm.setSelections(ranges.ranges, 0, sel_dontScroll);\\n          cm.replaceSelection(\\\"\\\", null, \\\"cut\\\");\\n        });\\n      }\\n    }\\n    if (e.clipboardData) {\\n      e.clipboardData.clearData();\\n      var content = lastCopied.text.join(\\\"\\\\n\\\");\\n      // iOS exposes the clipboard API, but seems to discard content inserted into it\\n      e.clipboardData.setData(\\\"Text\\\", content);\\n      if (e.clipboardData.getData(\\\"Text\\\") == content) {\\n        e.preventDefault();\\n        return\\n      }\\n    }\\n    // Old-fashioned briefly-focus-a-textarea hack\\n    var kludge = hiddenTextarea(), te = kludge.firstChild;\\n    cm.display.lineSpace.insertBefore(kludge, cm.display.lineSpace.firstChild);\\n    te.value = lastCopied.text.join(\\\"\\\\n\\\");\\n    var hadFocus = document.activeElement;\\n    selectInput(te);\\n    setTimeout(function () {\\n      cm.display.lineSpace.removeChild(kludge);\\n      hadFocus.focus();\\n      if (hadFocus == div) { input.showPrimarySelection(); }\\n    }, 50);\\n  }\\n  on(div, \\\"copy\\\", onCopyCut);\\n  on(div, \\\"cut\\\", onCopyCut);\\n};\\n\\nContentEditableInput.prototype.prepareSelection = function () {\\n  var result = prepareSelection(this.cm, false);\\n  result.focus = this.cm.state.focused;\\n  return result\\n};\\n\\nContentEditableInput.prototype.showSelection = function (info, takeFocus) {\\n  if (!info || !this.cm.display.view.length) { return }\\n  if (info.focus || takeFocus) { this.showPrimarySelection(); }\\n  this.showMultipleSelections(info);\\n};\\n\\nContentEditableInput.prototype.showPrimarySelection = function () {\\n  var sel = window.getSelection(), prim = this.cm.doc.sel.primary();\\n  var curAnchor = domToPos(this.cm, sel.anchorNode, sel.anchorOffset);\\n  var curFocus = domToPos(this.cm, sel.focusNode, sel.focusOffset);\\n  if (curAnchor && !curAnchor.bad && curFocus && !curFocus.bad &&\\n      cmp(minPos(curAnchor, curFocus), prim.from()) == 0 &&\\n      cmp(maxPos(curAnchor, curFocus), prim.to()) == 0)\\n    { return }\\n\\n  var start = posToDOM(this.cm, prim.from());\\n  var end = posToDOM(this.cm, prim.to());\\n  if (!start && !end) {\\n    sel.removeAllRanges();\\n    return\\n  }\\n\\n  var view = this.cm.display.view;\\n  var old = sel.rangeCount && sel.getRangeAt(0);\\n  if (!start) {\\n    start = {node: view[0].measure.map[2], offset: 0};\\n  } else if (!end) { // FIXME dangerously hacky\\n    var measure = view[view.length - 1].measure;\\n    var map$$1 = measure.maps ? measure.maps[measure.maps.length - 1] : measure.map;\\n    end = {node: map$$1[map$$1.length - 1], offset: map$$1[map$$1.length - 2] - map$$1[map$$1.length - 3]};\\n  }\\n\\n  var rng;\\n  try { rng = range(start.node, start.offset, end.offset, end.node); }\\n  catch(e) {} // Our model of the DOM might be outdated, in which case the range we try to set can be impossible\\n  if (rng) {\\n    if (!gecko && this.cm.state.focused) {\\n      sel.collapse(start.node, start.offset);\\n      if (!rng.collapsed) {\\n        sel.removeAllRanges();\\n        sel.addRange(rng);\\n      }\\n    } else {\\n      sel.removeAllRanges();\\n      sel.addRange(rng);\\n    }\\n    if (old && sel.anchorNode == null) { sel.addRange(old); }\\n    else if (gecko) { this.startGracePeriod(); }\\n  }\\n  this.rememberSelection();\\n};\\n\\nContentEditableInput.prototype.startGracePeriod = function () {\\n    var this$1 = this;\\n\\n  clearTimeout(this.gracePeriod);\\n  this.gracePeriod = setTimeout(function () {\\n    this$1.gracePeriod = false;\\n    if (this$1.selectionChanged())\\n      { this$1.cm.operation(function () { return this$1.cm.curOp.selectionChanged = true; }); }\\n  }, 20);\\n};\\n\\nContentEditableInput.prototype.showMultipleSelections = function (info) {\\n  removeChildrenAndAdd(this.cm.display.cursorDiv, info.cursors);\\n  removeChildrenAndAdd(this.cm.display.selectionDiv, info.selection);\\n};\\n\\nContentEditableInput.prototype.rememberSelection = function () {\\n  var sel = window.getSelection();\\n  this.lastAnchorNode = sel.anchorNode; this.lastAnchorOffset = sel.anchorOffset;\\n  this.lastFocusNode = sel.focusNode; this.lastFocusOffset = sel.focusOffset;\\n};\\n\\nContentEditableInput.prototype.selectionInEditor = function () {\\n  var sel = window.getSelection();\\n  if (!sel.rangeCount) { return false }\\n  var node = sel.getRangeAt(0).commonAncestorContainer;\\n  return contains(this.div, node)\\n};\\n\\nContentEditableInput.prototype.focus = function () {\\n  if (this.cm.options.readOnly != \\\"nocursor\\\") {\\n    if (!this.selectionInEditor())\\n      { this.showSelection(this.prepareSelection(), true); }\\n    this.div.focus();\\n  }\\n};\\nContentEditableInput.prototype.blur = function () { this.div.blur(); };\\nContentEditableInput.prototype.getField = function () { return this.div };\\n\\nContentEditableInput.prototype.supportsTouch = function () { return true };\\n\\nContentEditableInput.prototype.receivedFocus = function () {\\n  var input = this;\\n  if (this.selectionInEditor())\\n    { this.pollSelection(); }\\n  else\\n    { runInOp(this.cm, function () { return input.cm.curOp.selectionChanged = true; }); }\\n\\n  function poll() {\\n    if (input.cm.state.focused) {\\n      input.pollSelection();\\n      input.polling.set(input.cm.options.pollInterval, poll);\\n    }\\n  }\\n  this.polling.set(this.cm.options.pollInterval, poll);\\n};\\n\\nContentEditableInput.prototype.selectionChanged = function () {\\n  var sel = window.getSelection();\\n  return sel.anchorNode != this.lastAnchorNode || sel.anchorOffset != this.lastAnchorOffset ||\\n    sel.focusNode != this.lastFocusNode || sel.focusOffset != this.lastFocusOffset\\n};\\n\\nContentEditableInput.prototype.pollSelection = function () {\\n  if (this.readDOMTimeout != null || this.gracePeriod || !this.selectionChanged()) { return }\\n  var sel = window.getSelection(), cm = this.cm;\\n  // On Android Chrome (version 56, at least), backspacing into an\\n  // uneditable block element will put the cursor in that element,\\n  // and then, because it's not editable, hide the virtual keyboard.\\n  // Because Android doesn't allow us to actually detect backspace\\n  // presses in a sane way, this code checks for when that happens\\n  // and simulates a backspace press in this case.\\n  if (android && chrome && this.cm.options.gutters.length && isInGutter(sel.anchorNode)) {\\n    this.cm.triggerOnKeyDown({type: \\\"keydown\\\", keyCode: 8, preventDefault: Math.abs});\\n    this.blur();\\n    this.focus();\\n    return\\n  }\\n  if (this.composing) { return }\\n  this.rememberSelection();\\n  var anchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);\\n  var head = domToPos(cm, sel.focusNode, sel.focusOffset);\\n  if (anchor && head) { runInOp(cm, function () {\\n    setSelection(cm.doc, simpleSelection(anchor, head), sel_dontScroll);\\n    if (anchor.bad || head.bad) { cm.curOp.selectionChanged = true; }\\n  }); }\\n};\\n\\nContentEditableInput.prototype.pollContent = function () {\\n  if (this.readDOMTimeout != null) {\\n    clearTimeout(this.readDOMTimeout);\\n    this.readDOMTimeout = null;\\n  }\\n\\n  var cm = this.cm, display = cm.display, sel = cm.doc.sel.primary();\\n  var from = sel.from(), to = sel.to();\\n  if (from.ch == 0 && from.line > cm.firstLine())\\n    { from = Pos(from.line - 1, getLine(cm.doc, from.line - 1).length); }\\n  if (to.ch == getLine(cm.doc, to.line).text.length && to.line < cm.lastLine())\\n    { to = Pos(to.line + 1, 0); }\\n  if (from.line < display.viewFrom || to.line > display.viewTo - 1) { return false }\\n\\n  var fromIndex, fromLine, fromNode;\\n  if (from.line == display.viewFrom || (fromIndex = findViewIndex(cm, from.line)) == 0) {\\n    fromLine = lineNo(display.view[0].line);\\n    fromNode = display.view[0].node;\\n  } else {\\n    fromLine = lineNo(display.view[fromIndex].line);\\n    fromNode = display.view[fromIndex - 1].node.nextSibling;\\n  }\\n  var toIndex = findViewIndex(cm, to.line);\\n  var toLine, toNode;\\n  if (toIndex == display.view.length - 1) {\\n    toLine = display.viewTo - 1;\\n    toNode = display.lineDiv.lastChild;\\n  } else {\\n    toLine = lineNo(display.view[toIndex + 1].line) - 1;\\n    toNode = display.view[toIndex + 1].node.previousSibling;\\n  }\\n\\n  if (!fromNode) { return false }\\n  var newText = cm.doc.splitLines(domTextBetween(cm, fromNode, toNode, fromLine, toLine));\\n  var oldText = getBetween(cm.doc, Pos(fromLine, 0), Pos(toLine, getLine(cm.doc, toLine).text.length));\\n  while (newText.length > 1 && oldText.length > 1) {\\n    if (lst(newText) == lst(oldText)) { newText.pop(); oldText.pop(); toLine--; }\\n    else if (newText[0] == oldText[0]) { newText.shift(); oldText.shift(); fromLine++; }\\n    else { break }\\n  }\\n\\n  var cutFront = 0, cutEnd = 0;\\n  var newTop = newText[0], oldTop = oldText[0], maxCutFront = Math.min(newTop.length, oldTop.length);\\n  while (cutFront < maxCutFront && newTop.charCodeAt(cutFront) == oldTop.charCodeAt(cutFront))\\n    { ++cutFront; }\\n  var newBot = lst(newText), oldBot = lst(oldText);\\n  var maxCutEnd = Math.min(newBot.length - (newText.length == 1 ? cutFront : 0),\\n                           oldBot.length - (oldText.length == 1 ? cutFront : 0));\\n  while (cutEnd < maxCutEnd &&\\n         newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1))\\n    { ++cutEnd; }\\n  // Try to move start of change to start of selection if ambiguous\\n  if (newText.length == 1 && oldText.length == 1 && fromLine == from.line) {\\n    while (cutFront && cutFront > from.ch &&\\n           newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1)) {\\n      cutFront--;\\n      cutEnd++;\\n    }\\n  }\\n\\n  newText[newText.length - 1] = newBot.slice(0, newBot.length - cutEnd).replace(/^\\\\u200b+/, \\\"\\\");\\n  newText[0] = newText[0].slice(cutFront).replace(/\\\\u200b+$/, \\\"\\\");\\n\\n  var chFrom = Pos(fromLine, cutFront);\\n  var chTo = Pos(toLine, oldText.length ? lst(oldText).length - cutEnd : 0);\\n  if (newText.length > 1 || newText[0] || cmp(chFrom, chTo)) {\\n    replaceRange(cm.doc, newText, chFrom, chTo, \\\"+input\\\");\\n    return true\\n  }\\n};\\n\\nContentEditableInput.prototype.ensurePolled = function () {\\n  this.forceCompositionEnd();\\n};\\nContentEditableInput.prototype.reset = function () {\\n  this.forceCompositionEnd();\\n};\\nContentEditableInput.prototype.forceCompositionEnd = function () {\\n  if (!this.composing) { return }\\n  clearTimeout(this.readDOMTimeout);\\n  this.composing = null;\\n  this.updateFromDOM();\\n  this.div.blur();\\n  this.div.focus();\\n};\\nContentEditableInput.prototype.readFromDOMSoon = function () {\\n    var this$1 = this;\\n\\n  if (this.readDOMTimeout != null) { return }\\n  this.readDOMTimeout = setTimeout(function () {\\n    this$1.readDOMTimeout = null;\\n    if (this$1.composing) {\\n      if (this$1.composing.done) { this$1.composing = null; }\\n      else { return }\\n    }\\n    this$1.updateFromDOM();\\n  }, 80);\\n};\\n\\nContentEditableInput.prototype.updateFromDOM = function () {\\n    var this$1 = this;\\n\\n  if (this.cm.isReadOnly() || !this.pollContent())\\n    { runInOp(this.cm, function () { return regChange(this$1.cm); }); }\\n};\\n\\nContentEditableInput.prototype.setUneditable = function (node) {\\n  node.contentEditable = \\\"false\\\";\\n};\\n\\nContentEditableInput.prototype.onKeyPress = function (e) {\\n  if (e.charCode == 0) { return }\\n  e.preventDefault();\\n  if (!this.cm.isReadOnly())\\n    { operation(this.cm, applyTextInput)(this.cm, String.fromCharCode(e.charCode == null ? e.keyCode : e.charCode), 0); }\\n};\\n\\nContentEditableInput.prototype.readOnlyChanged = function (val) {\\n  this.div.contentEditable = String(val != \\\"nocursor\\\");\\n};\\n\\nContentEditableInput.prototype.onContextMenu = function () {};\\nContentEditableInput.prototype.resetPosition = function () {};\\n\\nContentEditableInput.prototype.needsContentAttribute = true;\\n\\nfunction posToDOM(cm, pos) {\\n  var view = findViewForLine(cm, pos.line);\\n  if (!view || view.hidden) { return null }\\n  var line = getLine(cm.doc, pos.line);\\n  var info = mapFromLineView(view, line, pos.line);\\n\\n  var order = getOrder(line, cm.doc.direction), side = \\\"left\\\";\\n  if (order) {\\n    var partPos = getBidiPartAt(order, pos.ch);\\n    side = partPos % 2 ? \\\"right\\\" : \\\"left\\\";\\n  }\\n  var result = nodeAndOffsetInLineMap(info.map, pos.ch, side);\\n  result.offset = result.collapse == \\\"right\\\" ? result.end : result.start;\\n  return result\\n}\\n\\nfunction isInGutter(node) {\\n  for (var scan = node; scan; scan = scan.parentNode)\\n    { if (/CodeMirror-gutter-wrapper/.test(scan.className)) { return true } }\\n  return false\\n}\\n\\nfunction badPos(pos, bad) { if (bad) { pos.bad = true; } return pos }\\n\\nfunction domTextBetween(cm, from, to, fromLine, toLine) {\\n  var text = \\\"\\\", closing = false, lineSep = cm.doc.lineSeparator();\\n  function recognizeMarker(id) { return function (marker) { return marker.id == id; } }\\n  function close() {\\n    if (closing) {\\n      text += lineSep;\\n      closing = false;\\n    }\\n  }\\n  function addText(str) {\\n    if (str) {\\n      close();\\n      text += str;\\n    }\\n  }\\n  function walk(node) {\\n    if (node.nodeType == 1) {\\n      var cmText = node.getAttribute(\\\"cm-text\\\");\\n      if (cmText != null) {\\n        addText(cmText || node.textContent.replace(/\\\\u200b/g, \\\"\\\"));\\n        return\\n      }\\n      var markerID = node.getAttribute(\\\"cm-marker\\\"), range$$1;\\n      if (markerID) {\\n        var found = cm.findMarks(Pos(fromLine, 0), Pos(toLine + 1, 0), recognizeMarker(+markerID));\\n        if (found.length && (range$$1 = found[0].find()))\\n          { addText(getBetween(cm.doc, range$$1.from, range$$1.to).join(lineSep)); }\\n        return\\n      }\\n      if (node.getAttribute(\\\"contenteditable\\\") == \\\"false\\\") { return }\\n      var isBlock = /^(pre|div|p)$/i.test(node.nodeName);\\n      if (isBlock) { close(); }\\n      for (var i = 0; i < node.childNodes.length; i++)\\n        { walk(node.childNodes[i]); }\\n      if (isBlock) { closing = true; }\\n    } else if (node.nodeType == 3) {\\n      addText(node.nodeValue);\\n    }\\n  }\\n  for (;;) {\\n    walk(from);\\n    if (from == to) { break }\\n    from = from.nextSibling;\\n  }\\n  return text\\n}\\n\\nfunction domToPos(cm, node, offset) {\\n  var lineNode;\\n  if (node == cm.display.lineDiv) {\\n    lineNode = cm.display.lineDiv.childNodes[offset];\\n    if (!lineNode) { return badPos(cm.clipPos(Pos(cm.display.viewTo - 1)), true) }\\n    node = null; offset = 0;\\n  } else {\\n    for (lineNode = node;; lineNode = lineNode.parentNode) {\\n      if (!lineNode || lineNode == cm.display.lineDiv) { return null }\\n      if (lineNode.parentNode && lineNode.parentNode == cm.display.lineDiv) { break }\\n    }\\n  }\\n  for (var i = 0; i < cm.display.view.length; i++) {\\n    var lineView = cm.display.view[i];\\n    if (lineView.node == lineNode)\\n      { return locateNodeInLineView(lineView, node, offset) }\\n  }\\n}\\n\\nfunction locateNodeInLineView(lineView, node, offset) {\\n  var wrapper = lineView.text.firstChild, bad = false;\\n  if (!node || !contains(wrapper, node)) { return badPos(Pos(lineNo(lineView.line), 0), true) }\\n  if (node == wrapper) {\\n    bad = true;\\n    node = wrapper.childNodes[offset];\\n    offset = 0;\\n    if (!node) {\\n      var line = lineView.rest ? lst(lineView.rest) : lineView.line;\\n      return badPos(Pos(lineNo(line), line.text.length), bad)\\n    }\\n  }\\n\\n  var textNode = node.nodeType == 3 ? node : null, topNode = node;\\n  if (!textNode && node.childNodes.length == 1 && node.firstChild.nodeType == 3) {\\n    textNode = node.firstChild;\\n    if (offset) { offset = textNode.nodeValue.length; }\\n  }\\n  while (topNode.parentNode != wrapper) { topNode = topNode.parentNode; }\\n  var measure = lineView.measure, maps = measure.maps;\\n\\n  function find(textNode, topNode, offset) {\\n    for (var i = -1; i < (maps ? maps.length : 0); i++) {\\n      var map$$1 = i < 0 ? measure.map : maps[i];\\n      for (var j = 0; j < map$$1.length; j += 3) {\\n        var curNode = map$$1[j + 2];\\n        if (curNode == textNode || curNode == topNode) {\\n          var line = lineNo(i < 0 ? lineView.line : lineView.rest[i]);\\n          var ch = map$$1[j] + offset;\\n          if (offset < 0 || curNode != textNode) { ch = map$$1[j + (offset ? 1 : 0)]; }\\n          return Pos(line, ch)\\n        }\\n      }\\n    }\\n  }\\n  var found = find(textNode, topNode, offset);\\n  if (found) { return badPos(found, bad) }\\n\\n  // FIXME this is all really shaky. might handle the few cases it needs to handle, but likely to cause problems\\n  for (var after = topNode.nextSibling, dist = textNode ? textNode.nodeValue.length - offset : 0; after; after = after.nextSibling) {\\n    found = find(after, after.firstChild, 0);\\n    if (found)\\n      { return badPos(Pos(found.line, found.ch - dist), bad) }\\n    else\\n      { dist += after.textContent.length; }\\n  }\\n  for (var before = topNode.previousSibling, dist$1 = offset; before; before = before.previousSibling) {\\n    found = find(before, before.firstChild, -1);\\n    if (found)\\n      { return badPos(Pos(found.line, found.ch + dist$1), bad) }\\n    else\\n      { dist$1 += before.textContent.length; }\\n  }\\n}\\n\\n// TEXTAREA INPUT STYLE\\n\\nvar TextareaInput = function(cm) {\\n  this.cm = cm;\\n  // See input.poll and input.reset\\n  this.prevInput = \\\"\\\";\\n\\n  // Flag that indicates whether we expect input to appear real soon\\n  // now (after some event like 'keypress' or 'input') and are\\n  // polling intensively.\\n  this.pollingFast = false;\\n  // Self-resetting timeout for the poller\\n  this.polling = new Delayed();\\n  // Tracks when input.reset has punted to just putting a short\\n  // string into the textarea instead of the full selection.\\n  this.inaccurateSelection = false;\\n  // Used to work around IE issue with selection being forgotten when focus moves away from textarea\\n  this.hasSelection = false;\\n  this.composing = null;\\n};\\n\\nTextareaInput.prototype.init = function (display) {\\n    var this$1 = this;\\n\\n  var input = this, cm = this.cm;\\n\\n  // Wraps and hides input textarea\\n  var div = this.wrapper = hiddenTextarea();\\n  // The semihidden textarea that is focused when the editor is\\n  // focused, and receives input.\\n  var te = this.textarea = div.firstChild;\\n  display.wrapper.insertBefore(div, display.wrapper.firstChild);\\n\\n  // Needed to hide big blue blinking cursor on Mobile Safari (doesn't seem to work in iOS 8 anymore)\\n  if (ios) { te.style.width = \\\"0px\\\"; }\\n\\n  on(te, \\\"input\\\", function () {\\n    if (ie && ie_version >= 9 && this$1.hasSelection) { this$1.hasSelection = null; }\\n    input.poll();\\n  });\\n\\n  on(te, \\\"paste\\\", function (e) {\\n    if (signalDOMEvent(cm, e) || handlePaste(e, cm)) { return }\\n\\n    cm.state.pasteIncoming = true;\\n    input.fastPoll();\\n  });\\n\\n  function prepareCopyCut(e) {\\n    if (signalDOMEvent(cm, e)) { return }\\n    if (cm.somethingSelected()) {\\n      setLastCopied({lineWise: false, text: cm.getSelections()});\\n      if (input.inaccurateSelection) {\\n        input.prevInput = \\\"\\\";\\n        input.inaccurateSelection = false;\\n        te.value = lastCopied.text.join(\\\"\\\\n\\\");\\n        selectInput(te);\\n      }\\n    } else if (!cm.options.lineWiseCopyCut) {\\n      return\\n    } else {\\n      var ranges = copyableRanges(cm);\\n      setLastCopied({lineWise: true, text: ranges.text});\\n      if (e.type == \\\"cut\\\") {\\n        cm.setSelections(ranges.ranges, null, sel_dontScroll);\\n      } else {\\n        input.prevInput = \\\"\\\";\\n        te.value = ranges.text.join(\\\"\\\\n\\\");\\n        selectInput(te);\\n      }\\n    }\\n    if (e.type == \\\"cut\\\") { cm.state.cutIncoming = true; }\\n  }\\n  on(te, \\\"cut\\\", prepareCopyCut);\\n  on(te, \\\"copy\\\", prepareCopyCut);\\n\\n  on(display.scroller, \\\"paste\\\", function (e) {\\n    if (eventInWidget(display, e) || signalDOMEvent(cm, e)) { return }\\n    cm.state.pasteIncoming = true;\\n    input.focus();\\n  });\\n\\n  // Prevent normal selection in the editor (we handle our own)\\n  on(display.lineSpace, \\\"selectstart\\\", function (e) {\\n    if (!eventInWidget(display, e)) { e_preventDefault(e); }\\n  });\\n\\n  on(te, \\\"compositionstart\\\", function () {\\n    var start = cm.getCursor(\\\"from\\\");\\n    if (input.composing) { input.composing.range.clear(); }\\n    input.composing = {\\n      start: start,\\n      range: cm.markText(start, cm.getCursor(\\\"to\\\"), {className: \\\"CodeMirror-composing\\\"})\\n    };\\n  });\\n  on(te, \\\"compositionend\\\", function () {\\n    if (input.composing) {\\n      input.poll();\\n      input.composing.range.clear();\\n      input.composing = null;\\n    }\\n  });\\n};\\n\\nTextareaInput.prototype.prepareSelection = function () {\\n  // Redraw the selection and/or cursor\\n  var cm = this.cm, display = cm.display, doc = cm.doc;\\n  var result = prepareSelection(cm);\\n\\n  // Move the hidden textarea near the cursor to prevent scrolling artifacts\\n  if (cm.options.moveInputWithCursor) {\\n    var headPos = cursorCoords(cm, doc.sel.primary().head, \\\"div\\\");\\n    var wrapOff = display.wrapper.getBoundingClientRect(), lineOff = display.lineDiv.getBoundingClientRect();\\n    result.teTop = Math.max(0, Math.min(display.wrapper.clientHeight - 10,\\n                                        headPos.top + lineOff.top - wrapOff.top));\\n    result.teLeft = Math.max(0, Math.min(display.wrapper.clientWidth - 10,\\n                                         headPos.left + lineOff.left - wrapOff.left));\\n  }\\n\\n  return result\\n};\\n\\nTextareaInput.prototype.showSelection = function (drawn) {\\n  var cm = this.cm, display = cm.display;\\n  removeChildrenAndAdd(display.cursorDiv, drawn.cursors);\\n  removeChildrenAndAdd(display.selectionDiv, drawn.selection);\\n  if (drawn.teTop != null) {\\n    this.wrapper.style.top = drawn.teTop + \\\"px\\\";\\n    this.wrapper.style.left = drawn.teLeft + \\\"px\\\";\\n  }\\n};\\n\\n// Reset the input to correspond to the selection (or to be empty,\\n// when not typing and nothing is selected)\\nTextareaInput.prototype.reset = function (typing) {\\n  if (this.contextMenuPending) { return }\\n  var minimal, selected, cm = this.cm, doc = cm.doc;\\n  if (cm.somethingSelected()) {\\n    this.prevInput = \\\"\\\";\\n    var range$$1 = doc.sel.primary();\\n    minimal = hasCopyEvent &&\\n      (range$$1.to().line - range$$1.from().line > 100 || (selected = cm.getSelection()).length > 1000);\\n    var content = minimal ? \\\"-\\\" : selected || cm.getSelection();\\n    this.textarea.value = content;\\n    if (cm.state.focused) { selectInput(this.textarea); }\\n    if (ie && ie_version >= 9) { this.hasSelection = content; }\\n  } else if (!typing) {\\n    this.prevInput = this.textarea.value = \\\"\\\";\\n    if (ie && ie_version >= 9) { this.hasSelection = null; }\\n  }\\n  this.inaccurateSelection = minimal;\\n};\\n\\nTextareaInput.prototype.getField = function () { return this.textarea };\\n\\nTextareaInput.prototype.supportsTouch = function () { return false };\\n\\nTextareaInput.prototype.focus = function () {\\n  if (this.cm.options.readOnly != \\\"nocursor\\\" && (!mobile || activeElt() != this.textarea)) {\\n    try { this.textarea.focus(); }\\n    catch (e) {} // IE8 will throw if the textarea is display: none or not in DOM\\n  }\\n};\\n\\nTextareaInput.prototype.blur = function () { this.textarea.blur(); };\\n\\nTextareaInput.prototype.resetPosition = function () {\\n  this.wrapper.style.top = this.wrapper.style.left = 0;\\n};\\n\\nTextareaInput.prototype.receivedFocus = function () { this.slowPoll(); };\\n\\n// Poll for input changes, using the normal rate of polling. This\\n// runs as long as the editor is focused.\\nTextareaInput.prototype.slowPoll = function () {\\n    var this$1 = this;\\n\\n  if (this.pollingFast) { return }\\n  this.polling.set(this.cm.options.pollInterval, function () {\\n    this$1.poll();\\n    if (this$1.cm.state.focused) { this$1.slowPoll(); }\\n  });\\n};\\n\\n// When an event has just come in that is likely to add or change\\n// something in the input textarea, we poll faster, to ensure that\\n// the change appears on the screen quickly.\\nTextareaInput.prototype.fastPoll = function () {\\n  var missed = false, input = this;\\n  input.pollingFast = true;\\n  function p() {\\n    var changed = input.poll();\\n    if (!changed && !missed) {missed = true; input.polling.set(60, p);}\\n    else {input.pollingFast = false; input.slowPoll();}\\n  }\\n  input.polling.set(20, p);\\n};\\n\\n// Read input from the textarea, and update the document to match.\\n// When something is selected, it is present in the textarea, and\\n// selected (unless it is huge, in which case a placeholder is\\n// used). When nothing is selected, the cursor sits after previously\\n// seen text (can be empty), which is stored in prevInput (we must\\n// not reset the textarea when typing, because that breaks IME).\\nTextareaInput.prototype.poll = function () {\\n    var this$1 = this;\\n\\n  var cm = this.cm, input = this.textarea, prevInput = this.prevInput;\\n  // Since this is called a *lot*, try to bail out as cheaply as\\n  // possible when it is clear that nothing happened. hasSelection\\n  // will be the case when there is a lot of text in the textarea,\\n  // in which case reading its value would be expensive.\\n  if (this.contextMenuPending || !cm.state.focused ||\\n      (hasSelection(input) && !prevInput && !this.composing) ||\\n      cm.isReadOnly() || cm.options.disableInput || cm.state.keySeq)\\n    { return false }\\n\\n  var text = input.value;\\n  // If nothing changed, bail.\\n  if (text == prevInput && !cm.somethingSelected()) { return false }\\n  // Work around nonsensical selection resetting in IE9/10, and\\n  // inexplicable appearance of private area unicode characters on\\n  // some key combos in Mac (#2689).\\n  if (ie && ie_version >= 9 && this.hasSelection === text ||\\n      mac && /[\\\\uf700-\\\\uf7ff]/.test(text)) {\\n    cm.display.input.reset();\\n    return false\\n  }\\n\\n  if (cm.doc.sel == cm.display.selForContextMenu) {\\n    var first = text.charCodeAt(0);\\n    if (first == 0x200b && !prevInput) { prevInput = \\\"\\\\u200b\\\"; }\\n    if (first == 0x21da) { this.reset(); return this.cm.execCommand(\\\"undo\\\") }\\n  }\\n  // Find the part of the input that is actually new\\n  var same = 0, l = Math.min(prevInput.length, text.length);\\n  while (same < l && prevInput.charCodeAt(same) == text.charCodeAt(same)) { ++same; }\\n\\n  runInOp(cm, function () {\\n    applyTextInput(cm, text.slice(same), prevInput.length - same,\\n                   null, this$1.composing ? \\\"*compose\\\" : null);\\n\\n    // Don't leave long text in the textarea, since it makes further polling slow\\n    if (text.length > 1000 || text.indexOf(\\\"\\\\n\\\") > -1) { input.value = this$1.prevInput = \\\"\\\"; }\\n    else { this$1.prevInput = text; }\\n\\n    if (this$1.composing) {\\n      this$1.composing.range.clear();\\n      this$1.composing.range = cm.markText(this$1.composing.start, cm.getCursor(\\\"to\\\"),\\n                                         {className: \\\"CodeMirror-composing\\\"});\\n    }\\n  });\\n  return true\\n};\\n\\nTextareaInput.prototype.ensurePolled = function () {\\n  if (this.pollingFast && this.poll()) { this.pollingFast = false; }\\n};\\n\\nTextareaInput.prototype.onKeyPress = function () {\\n  if (ie && ie_version >= 9) { this.hasSelection = null; }\\n  this.fastPoll();\\n};\\n\\nTextareaInput.prototype.onContextMenu = function (e) {\\n  var input = this, cm = input.cm, display = cm.display, te = input.textarea;\\n  var pos = posFromMouse(cm, e), scrollPos = display.scroller.scrollTop;\\n  if (!pos || presto) { return } // Opera is difficult.\\n\\n  // Reset the current text selection only if the click is done outside of the selection\\n  // and 'resetSelectionOnContextMenu' option is true.\\n  var reset = cm.options.resetSelectionOnContextMenu;\\n  if (reset && cm.doc.sel.contains(pos) == -1)\\n    { operation(cm, setSelection)(cm.doc, simpleSelection(pos), sel_dontScroll); }\\n\\n  var oldCSS = te.style.cssText, oldWrapperCSS = input.wrapper.style.cssText;\\n  input.wrapper.style.cssText = \\\"position: absolute\\\";\\n  var wrapperBox = input.wrapper.getBoundingClientRect();\\n  te.style.cssText = \\\"position: absolute; width: 30px; height: 30px;\\\\n      top: \\\" + (e.clientY - wrapperBox.top - 5) + \\\"px; left: \\\" + (e.clientX - wrapperBox.left - 5) + \\\"px;\\\\n      z-index: 1000; background: \\\" + (ie ? \\\"rgba(255, 255, 255, .05)\\\" : \\\"transparent\\\") + \\\";\\\\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);\\\";\\n  var oldScrollY;\\n  if (webkit) { oldScrollY = window.scrollY; } // Work around Chrome issue (#2712)\\n  display.input.focus();\\n  if (webkit) { window.scrollTo(null, oldScrollY); }\\n  display.input.reset();\\n  // Adds \\\"Select all\\\" to context menu in FF\\n  if (!cm.somethingSelected()) { te.value = input.prevInput = \\\" \\\"; }\\n  input.contextMenuPending = true;\\n  display.selForContextMenu = cm.doc.sel;\\n  clearTimeout(display.detectingSelectAll);\\n\\n  // Select-all will be greyed out if there's nothing to select, so\\n  // this adds a zero-width space so that we can later check whether\\n  // it got selected.\\n  function prepareSelectAllHack() {\\n    if (te.selectionStart != null) {\\n      var selected = cm.somethingSelected();\\n      var extval = \\\"\\\\u200b\\\" + (selected ? te.value : \\\"\\\");\\n      te.value = \\\"\\\\u21da\\\"; // Used to catch context-menu undo\\n      te.value = extval;\\n      input.prevInput = selected ? \\\"\\\" : \\\"\\\\u200b\\\";\\n      te.selectionStart = 1; te.selectionEnd = extval.length;\\n      // Re-set this, in case some other handler touched the\\n      // selection in the meantime.\\n      display.selForContextMenu = cm.doc.sel;\\n    }\\n  }\\n  function rehide() {\\n    input.contextMenuPending = false;\\n    input.wrapper.style.cssText = oldWrapperCSS;\\n    te.style.cssText = oldCSS;\\n    if (ie && ie_version < 9) { display.scrollbars.setScrollTop(display.scroller.scrollTop = scrollPos); }\\n\\n    // Try to detect the user choosing select-all\\n    if (te.selectionStart != null) {\\n      if (!ie || (ie && ie_version < 9)) { prepareSelectAllHack(); }\\n      var i = 0, poll = function () {\\n        if (display.selForContextMenu == cm.doc.sel && te.selectionStart == 0 &&\\n            te.selectionEnd > 0 && input.prevInput == \\\"\\\\u200b\\\") {\\n          operation(cm, selectAll)(cm);\\n        } else if (i++ < 10) {\\n          display.detectingSelectAll = setTimeout(poll, 500);\\n        } else {\\n          display.selForContextMenu = null;\\n          display.input.reset();\\n        }\\n      };\\n      display.detectingSelectAll = setTimeout(poll, 200);\\n    }\\n  }\\n\\n  if (ie && ie_version >= 9) { prepareSelectAllHack(); }\\n  if (captureRightClick) {\\n    e_stop(e);\\n    var mouseup = function () {\\n      off(window, \\\"mouseup\\\", mouseup);\\n      setTimeout(rehide, 20);\\n    };\\n    on(window, \\\"mouseup\\\", mouseup);\\n  } else {\\n    setTimeout(rehide, 50);\\n  }\\n};\\n\\nTextareaInput.prototype.readOnlyChanged = function (val) {\\n  if (!val) { this.reset(); }\\n};\\n\\nTextareaInput.prototype.setUneditable = function () {};\\n\\nTextareaInput.prototype.needsContentAttribute = false;\\n\\nfunction fromTextArea(textarea, options) {\\n  options = options ? copyObj(options) : {};\\n  options.value = textarea.value;\\n  if (!options.tabindex && textarea.tabIndex)\\n    { options.tabindex = textarea.tabIndex; }\\n  if (!options.placeholder && textarea.placeholder)\\n    { options.placeholder = textarea.placeholder; }\\n  // Set autofocus to true if this textarea is focused, or if it has\\n  // autofocus and no other element is focused.\\n  if (options.autofocus == null) {\\n    var hasFocus = activeElt();\\n    options.autofocus = hasFocus == textarea ||\\n      textarea.getAttribute(\\\"autofocus\\\") != null && hasFocus == document.body;\\n  }\\n\\n  function save() {textarea.value = cm.getValue();}\\n\\n  var realSubmit;\\n  if (textarea.form) {\\n    on(textarea.form, \\\"submit\\\", save);\\n    // Deplorable hack to make the submit method do the right thing.\\n    if (!options.leaveSubmitMethodAlone) {\\n      var form = textarea.form;\\n      realSubmit = form.submit;\\n      try {\\n        var wrappedSubmit = form.submit = function () {\\n          save();\\n          form.submit = realSubmit;\\n          form.submit();\\n          form.submit = wrappedSubmit;\\n        };\\n      } catch(e) {}\\n    }\\n  }\\n\\n  options.finishInit = function (cm) {\\n    cm.save = save;\\n    cm.getTextArea = function () { return textarea; };\\n    cm.toTextArea = function () {\\n      cm.toTextArea = isNaN; // Prevent this from being ran twice\\n      save();\\n      textarea.parentNode.removeChild(cm.getWrapperElement());\\n      textarea.style.display = \\\"\\\";\\n      if (textarea.form) {\\n        off(textarea.form, \\\"submit\\\", save);\\n        if (typeof textarea.form.submit == \\\"function\\\")\\n          { textarea.form.submit = realSubmit; }\\n      }\\n    };\\n  };\\n\\n  textarea.style.display = \\\"none\\\";\\n  var cm = CodeMirror$1(function (node) { return textarea.parentNode.insertBefore(node, textarea.nextSibling); },\\n    options);\\n  return cm\\n}\\n\\nfunction addLegacyProps(CodeMirror) {\\n  CodeMirror.off = off;\\n  CodeMirror.on = on;\\n  CodeMirror.wheelEventPixels = wheelEventPixels;\\n  CodeMirror.Doc = Doc;\\n  CodeMirror.splitLines = splitLinesAuto;\\n  CodeMirror.countColumn = countColumn;\\n  CodeMirror.findColumn = findColumn;\\n  CodeMirror.isWordChar = isWordCharBasic;\\n  CodeMirror.Pass = Pass;\\n  CodeMirror.signal = signal;\\n  CodeMirror.Line = Line;\\n  CodeMirror.changeEnd = changeEnd;\\n  CodeMirror.scrollbarModel = scrollbarModel;\\n  CodeMirror.Pos = Pos;\\n  CodeMirror.cmpPos = cmp;\\n  CodeMirror.modes = modes;\\n  CodeMirror.mimeModes = mimeModes;\\n  CodeMirror.resolveMode = resolveMode;\\n  CodeMirror.getMode = getMode;\\n  CodeMirror.modeExtensions = modeExtensions;\\n  CodeMirror.extendMode = extendMode;\\n  CodeMirror.copyState = copyState;\\n  CodeMirror.startState = startState;\\n  CodeMirror.innerMode = innerMode;\\n  CodeMirror.commands = commands;\\n  CodeMirror.keyMap = keyMap;\\n  CodeMirror.keyName = keyName;\\n  CodeMirror.isModifierKey = isModifierKey;\\n  CodeMirror.lookupKey = lookupKey;\\n  CodeMirror.normalizeKeyMap = normalizeKeyMap;\\n  CodeMirror.StringStream = StringStream;\\n  CodeMirror.SharedTextMarker = SharedTextMarker;\\n  CodeMirror.TextMarker = TextMarker;\\n  CodeMirror.LineWidget = LineWidget;\\n  CodeMirror.e_preventDefault = e_preventDefault;\\n  CodeMirror.e_stopPropagation = e_stopPropagation;\\n  CodeMirror.e_stop = e_stop;\\n  CodeMirror.addClass = addClass;\\n  CodeMirror.contains = contains;\\n  CodeMirror.rmClass = rmClass;\\n  CodeMirror.keyNames = keyNames;\\n}\\n\\n// EDITOR CONSTRUCTOR\\n\\ndefineOptions(CodeMirror$1);\\n\\naddEditorMethods(CodeMirror$1);\\n\\n// Set up methods on CodeMirror's prototype to redirect to the editor's document.\\nvar dontDelegate = \\\"iter insert remove copy getEditor constructor\\\".split(\\\" \\\");\\nfor (var prop in Doc.prototype) { if (Doc.prototype.hasOwnProperty(prop) && indexOf(dontDelegate, prop) < 0)\\n  { CodeMirror$1.prototype[prop] = (function(method) {\\n    return function() {return method.apply(this.doc, arguments)}\\n  })(Doc.prototype[prop]); } }\\n\\neventMixin(Doc);\\n\\n// INPUT HANDLING\\n\\nCodeMirror$1.inputStyles = {\\\"textarea\\\": TextareaInput, \\\"contenteditable\\\": ContentEditableInput};\\n\\n// MODE DEFINITION AND QUERYING\\n\\n// Extra arguments are stored as the mode's dependencies, which is\\n// used by (legacy) mechanisms like loadmode.js to automatically\\n// load a mode. (Preferred mechanism is the require/define calls.)\\nCodeMirror$1.defineMode = function(name/*, mode, */) {\\n  if (!CodeMirror$1.defaults.mode && name != \\\"null\\\") { CodeMirror$1.defaults.mode = name; }\\n  defineMode.apply(this, arguments);\\n};\\n\\nCodeMirror$1.defineMIME = defineMIME;\\n\\n// Minimal default mode.\\nCodeMirror$1.defineMode(\\\"null\\\", function () { return ({token: function (stream) { return stream.skipToEnd(); }}); });\\nCodeMirror$1.defineMIME(\\\"text/plain\\\", \\\"null\\\");\\n\\n// EXTENSIONS\\n\\nCodeMirror$1.defineExtension = function (name, func) {\\n  CodeMirror$1.prototype[name] = func;\\n};\\nCodeMirror$1.defineDocExtension = function (name, func) {\\n  Doc.prototype[name] = func;\\n};\\n\\nCodeMirror$1.fromTextArea = fromTextArea;\\n\\naddLegacyProps(CodeMirror$1);\\n\\nCodeMirror$1.version = \\\"5.25.0\\\";\\n\\nreturn CodeMirror$1;\\n\\n})));\\n\"//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL34vY29kZW1pcnJvci9saWIvY29kZW1pcnJvci5qcz9iMGIxIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gXCIvLyBDb2RlTWlycm9yLCBjb3B5cmlnaHQgKGMpIGJ5IE1hcmlqbiBIYXZlcmJla2UgYW5kIG90aGVyc1xcbi8vIERpc3RyaWJ1dGVkIHVuZGVyIGFuIE1JVCBsaWNlbnNlOiBodHRwOi8vY29kZW1pcnJvci5uZXQvTElDRU5TRVxcblxcbi8vIFRoaXMgaXMgQ29kZU1pcnJvciAoaHR0cDovL2NvZGVtaXJyb3IubmV0KSwgYSBjb2RlIGVkaXRvclxcbi8vIGltcGxlbWVudGVkIGluIEphdmFTY3JpcHQgb24gdG9wIG9mIHRoZSBicm93c2VyJ3MgRE9NLlxcbi8vXFxuLy8gWW91IGNhbiBmaW5kIHNvbWUgdGVjaG5pY2FsIGJhY2tncm91bmQgZm9yIHNvbWUgb2YgdGhlIGNvZGUgYmVsb3dcXG4vLyBhdCBodHRwOi8vbWFyaWpuaGF2ZXJiZWtlLm5sL2Jsb2cvI2NtLWludGVybmFscyAuXFxuXFxuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcXG5cXHR0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKSA6XFxuXFx0dHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKGZhY3RvcnkpIDpcXG5cXHQoZ2xvYmFsLkNvZGVNaXJyb3IgPSBmYWN0b3J5KCkpO1xcbn0odGhpcywgKGZ1bmN0aW9uICgpIHsgJ3VzZSBzdHJpY3QnO1xcblxcbi8vIEtsdWRnZXMgZm9yIGJ1Z3MgYW5kIGJlaGF2aW9yIGRpZmZlcmVuY2VzIHRoYXQgY2FuJ3QgYmUgZmVhdHVyZVxcbi8vIGRldGVjdGVkIGFyZSBlbmFibGVkIGJhc2VkIG9uIHVzZXJBZ2VudCBldGMgc25pZmZpbmcuXFxudmFyIHVzZXJBZ2VudCA9IG5hdmlnYXRvci51c2VyQWdlbnQ7XFxudmFyIHBsYXRmb3JtID0gbmF2aWdhdG9yLnBsYXRmb3JtO1xcblxcbnZhciBnZWNrbyA9IC9nZWNrb1xcXFwvXFxcXGQvaS50ZXN0KHVzZXJBZ2VudCk7XFxudmFyIGllX3VwdG8xMCA9IC9NU0lFIFxcXFxkLy50ZXN0KHVzZXJBZ2VudCk7XFxudmFyIGllXzExdXAgPSAvVHJpZGVudFxcXFwvKD86WzctOV18XFxcXGR7Mix9KVxcXFwuLipydjooXFxcXGQrKS8uZXhlYyh1c2VyQWdlbnQpO1xcbnZhciBlZGdlID0gL0VkZ2VcXFxcLyhcXFxcZCspLy5leGVjKHVzZXJBZ2VudCk7XFxudmFyIGllID0gaWVfdXB0bzEwIHx8IGllXzExdXAgfHwgZWRnZTtcXG52YXIgaWVfdmVyc2lvbiA9IGllICYmIChpZV91cHRvMTAgPyBkb2N1bWVudC5kb2N1bWVudE1vZGUgfHwgNiA6ICsoZWRnZSB8fCBpZV8xMXVwKVsxXSk7XFxudmFyIHdlYmtpdCA9ICFlZGdlICYmIC9XZWJLaXRcXFxcLy8udGVzdCh1c2VyQWdlbnQpO1xcbnZhciBxdHdlYmtpdCA9IHdlYmtpdCAmJiAvUXRcXFxcL1xcXFxkK1xcXFwuXFxcXGQrLy50ZXN0KHVzZXJBZ2VudCk7XFxudmFyIGNocm9tZSA9ICFlZGdlICYmIC9DaHJvbWVcXFxcLy8udGVzdCh1c2VyQWdlbnQpO1xcbnZhciBwcmVzdG8gPSAvT3BlcmFcXFxcLy8udGVzdCh1c2VyQWdlbnQpO1xcbnZhciBzYWZhcmkgPSAvQXBwbGUgQ29tcHV0ZXIvLnRlc3QobmF2aWdhdG9yLnZlbmRvcik7XFxudmFyIG1hY19nZU1vdW50YWluTGlvbiA9IC9NYWMgT1MgWCAxXFxcXGRcXFxcRChbOC05XXxcXFxcZFxcXFxkKVxcXFxELy50ZXN0KHVzZXJBZ2VudCk7XFxudmFyIHBoYW50b20gPSAvUGhhbnRvbUpTLy50ZXN0KHVzZXJBZ2VudCk7XFxuXFxudmFyIGlvcyA9ICFlZGdlICYmIC9BcHBsZVdlYktpdC8udGVzdCh1c2VyQWdlbnQpICYmIC9Nb2JpbGVcXFxcL1xcXFx3Ky8udGVzdCh1c2VyQWdlbnQpO1xcbnZhciBhbmRyb2lkID0gL0FuZHJvaWQvLnRlc3QodXNlckFnZW50KTtcXG4vLyBUaGlzIGlzIHdvZWZ1bGx5IGluY29tcGxldGUuIFN1Z2dlc3Rpb25zIGZvciBhbHRlcm5hdGl2ZSBtZXRob2RzIHdlbGNvbWUuXFxudmFyIG1vYmlsZSA9IGlvcyB8fCBhbmRyb2lkIHx8IC93ZWJPU3xCbGFja0JlcnJ5fE9wZXJhIE1pbml8T3BlcmEgTW9iaXxJRU1vYmlsZS9pLnRlc3QodXNlckFnZW50KTtcXG52YXIgbWFjID0gaW9zIHx8IC9NYWMvLnRlc3QocGxhdGZvcm0pO1xcbnZhciBjaHJvbWVPUyA9IC9cXFxcYkNyT1NcXFxcYi8udGVzdCh1c2VyQWdlbnQpO1xcbnZhciB3aW5kb3dzID0gL3dpbi9pLnRlc3QocGxhdGZvcm0pO1xcblxcbnZhciBwcmVzdG9fdmVyc2lvbiA9IHByZXN0byAmJiB1c2VyQWdlbnQubWF0Y2goL1ZlcnNpb25cXFxcLyhcXFxcZCpcXFxcLlxcXFxkKikvKTtcXG5pZiAocHJlc3RvX3ZlcnNpb24pIHsgcHJlc3RvX3ZlcnNpb24gPSBOdW1iZXIocHJlc3RvX3ZlcnNpb25bMV0pOyB9XFxuaWYgKHByZXN0b192ZXJzaW9uICYmIHByZXN0b192ZXJzaW9uID49IDE1KSB7IHByZXN0byA9IGZhbHNlOyB3ZWJraXQgPSB0cnVlOyB9XFxuLy8gU29tZSBicm93c2VycyB1c2UgdGhlIHdyb25nIGV2ZW50IHByb3BlcnRpZXMgdG8gc2lnbmFsIGNtZC9jdHJsIG9uIE9TIFhcXG52YXIgZmxpcEN0cmxDbWQgPSBtYWMgJiYgKHF0d2Via2l0IHx8IHByZXN0byAmJiAocHJlc3RvX3ZlcnNpb24gPT0gbnVsbCB8fCBwcmVzdG9fdmVyc2lvbiA8IDEyLjExKSk7XFxudmFyIGNhcHR1cmVSaWdodENsaWNrID0gZ2Vja28gfHwgKGllICYmIGllX3ZlcnNpb24gPj0gOSk7XFxuXFxuZnVuY3Rpb24gY2xhc3NUZXN0KGNscykgeyByZXR1cm4gbmV3IFJlZ0V4cChcXFwiKF58XFxcXFxcXFxzKVxcXCIgKyBjbHMgKyBcXFwiKD86JHxcXFxcXFxcXHMpXFxcXFxcXFxzKlxcXCIpIH1cXG5cXG52YXIgcm1DbGFzcyA9IGZ1bmN0aW9uKG5vZGUsIGNscykge1xcbiAgdmFyIGN1cnJlbnQgPSBub2RlLmNsYXNzTmFtZTtcXG4gIHZhciBtYXRjaCA9IGNsYXNzVGVzdChjbHMpLmV4ZWMoY3VycmVudCk7XFxuICBpZiAobWF0Y2gpIHtcXG4gICAgdmFyIGFmdGVyID0gY3VycmVudC5zbGljZShtYXRjaC5pbmRleCArIG1hdGNoWzBdLmxlbmd0aCk7XFxuICAgIG5vZGUuY2xhc3NOYW1lID0gY3VycmVudC5zbGljZSgwLCBtYXRjaC5pbmRleCkgKyAoYWZ0ZXIgPyBtYXRjaFsxXSArIGFmdGVyIDogXFxcIlxcXCIpO1xcbiAgfVxcbn07XFxuXFxuZnVuY3Rpb24gcmVtb3ZlQ2hpbGRyZW4oZSkge1xcbiAgZm9yICh2YXIgY291bnQgPSBlLmNoaWxkTm9kZXMubGVuZ3RoOyBjb3VudCA+IDA7IC0tY291bnQpXFxuICAgIHsgZS5yZW1vdmVDaGlsZChlLmZpcnN0Q2hpbGQpOyB9XFxuICByZXR1cm4gZVxcbn1cXG5cXG5mdW5jdGlvbiByZW1vdmVDaGlsZHJlbkFuZEFkZChwYXJlbnQsIGUpIHtcXG4gIHJldHVybiByZW1vdmVDaGlsZHJlbihwYXJlbnQpLmFwcGVuZENoaWxkKGUpXFxufVxcblxcbmZ1bmN0aW9uIGVsdCh0YWcsIGNvbnRlbnQsIGNsYXNzTmFtZSwgc3R5bGUpIHtcXG4gIHZhciBlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xcbiAgaWYgKGNsYXNzTmFtZSkgeyBlLmNsYXNzTmFtZSA9IGNsYXNzTmFtZTsgfVxcbiAgaWYgKHN0eWxlKSB7IGUuc3R5bGUuY3NzVGV4dCA9IHN0eWxlOyB9XFxuICBpZiAodHlwZW9mIGNvbnRlbnQgPT0gXFxcInN0cmluZ1xcXCIpIHsgZS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjb250ZW50KSk7IH1cXG4gIGVsc2UgaWYgKGNvbnRlbnQpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBjb250ZW50Lmxlbmd0aDsgKytpKSB7IGUuYXBwZW5kQ2hpbGQoY29udGVudFtpXSk7IH0gfVxcbiAgcmV0dXJuIGVcXG59XFxuLy8gd3JhcHBlciBmb3IgZWx0LCB3aGljaCByZW1vdmVzIHRoZSBlbHQgZnJvbSB0aGUgYWNjZXNzaWJpbGl0eSB0cmVlXFxuZnVuY3Rpb24gZWx0UCh0YWcsIGNvbnRlbnQsIGNsYXNzTmFtZSwgc3R5bGUpIHtcXG4gIHZhciBlID0gZWx0KHRhZywgY29udGVudCwgY2xhc3NOYW1lLCBzdHlsZSk7XFxuICBlLnNldEF0dHJpYnV0ZShcXFwicm9sZVxcXCIsIFxcXCJwcmVzZW50YXRpb25cXFwiKTtcXG4gIHJldHVybiBlXFxufVxcblxcbnZhciByYW5nZTtcXG5pZiAoZG9jdW1lbnQuY3JlYXRlUmFuZ2UpIHsgcmFuZ2UgPSBmdW5jdGlvbihub2RlLCBzdGFydCwgZW5kLCBlbmROb2RlKSB7XFxuICB2YXIgciA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XFxuICByLnNldEVuZChlbmROb2RlIHx8IG5vZGUsIGVuZCk7XFxuICByLnNldFN0YXJ0KG5vZGUsIHN0YXJ0KTtcXG4gIHJldHVybiByXFxufTsgfVxcbmVsc2UgeyByYW5nZSA9IGZ1bmN0aW9uKG5vZGUsIHN0YXJ0LCBlbmQpIHtcXG4gIHZhciByID0gZG9jdW1lbnQuYm9keS5jcmVhdGVUZXh0UmFuZ2UoKTtcXG4gIHRyeSB7IHIubW92ZVRvRWxlbWVudFRleHQobm9kZS5wYXJlbnROb2RlKTsgfVxcbiAgY2F0Y2goZSkgeyByZXR1cm4gciB9XFxuICByLmNvbGxhcHNlKHRydWUpO1xcbiAgci5tb3ZlRW5kKFxcXCJjaGFyYWN0ZXJcXFwiLCBlbmQpO1xcbiAgci5tb3ZlU3RhcnQoXFxcImNoYXJhY3RlclxcXCIsIHN0YXJ0KTtcXG4gIHJldHVybiByXFxufTsgfVxcblxcbmZ1bmN0aW9uIGNvbnRhaW5zKHBhcmVudCwgY2hpbGQpIHtcXG4gIGlmIChjaGlsZC5ub2RlVHlwZSA9PSAzKSAvLyBBbmRyb2lkIGJyb3dzZXIgYWx3YXlzIHJldHVybnMgZmFsc2Ugd2hlbiBjaGlsZCBpcyBhIHRleHRub2RlXFxuICAgIHsgY2hpbGQgPSBjaGlsZC5wYXJlbnROb2RlOyB9XFxuICBpZiAocGFyZW50LmNvbnRhaW5zKVxcbiAgICB7IHJldHVybiBwYXJlbnQuY29udGFpbnMoY2hpbGQpIH1cXG4gIGRvIHtcXG4gICAgaWYgKGNoaWxkLm5vZGVUeXBlID09IDExKSB7IGNoaWxkID0gY2hpbGQuaG9zdDsgfVxcbiAgICBpZiAoY2hpbGQgPT0gcGFyZW50KSB7IHJldHVybiB0cnVlIH1cXG4gIH0gd2hpbGUgKGNoaWxkID0gY2hpbGQucGFyZW50Tm9kZSlcXG59XFxuXFxuZnVuY3Rpb24gYWN0aXZlRWx0KCkge1xcbiAgLy8gSUUgYW5kIEVkZ2UgbWF5IHRocm93IGFuIFxcXCJVbnNwZWNpZmllZCBFcnJvclxcXCIgd2hlbiBhY2Nlc3NpbmcgZG9jdW1lbnQuYWN0aXZlRWxlbWVudC5cXG4gIC8vIElFIDwgMTAgd2lsbCB0aHJvdyB3aGVuIGFjY2Vzc2VkIHdoaWxlIHRoZSBwYWdlIGlzIGxvYWRpbmcgb3IgaW4gYW4gaWZyYW1lLlxcbiAgLy8gSUUgPiA5IGFuZCBFZGdlIHdpbGwgdGhyb3cgd2hlbiBhY2Nlc3NlZCBpbiBhbiBpZnJhbWUgaWYgZG9jdW1lbnQuYm9keSBpcyB1bmF2YWlsYWJsZS5cXG4gIHZhciBhY3RpdmVFbGVtZW50O1xcbiAgdHJ5IHtcXG4gICAgYWN0aXZlRWxlbWVudCA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XFxuICB9IGNhdGNoKGUpIHtcXG4gICAgYWN0aXZlRWxlbWVudCA9IGRvY3VtZW50LmJvZHkgfHwgbnVsbDtcXG4gIH1cXG4gIHdoaWxlIChhY3RpdmVFbGVtZW50ICYmIGFjdGl2ZUVsZW1lbnQuc2hhZG93Um9vdCAmJiBhY3RpdmVFbGVtZW50LnNoYWRvd1Jvb3QuYWN0aXZlRWxlbWVudClcXG4gICAgeyBhY3RpdmVFbGVtZW50ID0gYWN0aXZlRWxlbWVudC5zaGFkb3dSb290LmFjdGl2ZUVsZW1lbnQ7IH1cXG4gIHJldHVybiBhY3RpdmVFbGVtZW50XFxufVxcblxcbmZ1bmN0aW9uIGFkZENsYXNzKG5vZGUsIGNscykge1xcbiAgdmFyIGN1cnJlbnQgPSBub2RlLmNsYXNzTmFtZTtcXG4gIGlmICghY2xhc3NUZXN0KGNscykudGVzdChjdXJyZW50KSkgeyBub2RlLmNsYXNzTmFtZSArPSAoY3VycmVudCA/IFxcXCIgXFxcIiA6IFxcXCJcXFwiKSArIGNsczsgfVxcbn1cXG5mdW5jdGlvbiBqb2luQ2xhc3NlcyhhLCBiKSB7XFxuICB2YXIgYXMgPSBhLnNwbGl0KFxcXCIgXFxcIik7XFxuICBmb3IgKHZhciBpID0gMDsgaSA8IGFzLmxlbmd0aDsgaSsrKVxcbiAgICB7IGlmIChhc1tpXSAmJiAhY2xhc3NUZXN0KGFzW2ldKS50ZXN0KGIpKSB7IGIgKz0gXFxcIiBcXFwiICsgYXNbaV07IH0gfVxcbiAgcmV0dXJuIGJcXG59XFxuXFxudmFyIHNlbGVjdElucHV0ID0gZnVuY3Rpb24obm9kZSkgeyBub2RlLnNlbGVjdCgpOyB9O1xcbmlmIChpb3MpIC8vIE1vYmlsZSBTYWZhcmkgYXBwYXJlbnRseSBoYXMgYSBidWcgd2hlcmUgc2VsZWN0KCkgaXMgYnJva2VuLlxcbiAgeyBzZWxlY3RJbnB1dCA9IGZ1bmN0aW9uKG5vZGUpIHsgbm9kZS5zZWxlY3Rpb25TdGFydCA9IDA7IG5vZGUuc2VsZWN0aW9uRW5kID0gbm9kZS52YWx1ZS5sZW5ndGg7IH07IH1cXG5lbHNlIGlmIChpZSkgLy8gU3VwcHJlc3MgbXlzdGVyaW91cyBJRTEwIGVycm9yc1xcbiAgeyBzZWxlY3RJbnB1dCA9IGZ1bmN0aW9uKG5vZGUpIHsgdHJ5IHsgbm9kZS5zZWxlY3QoKTsgfSBjYXRjaChfZSkge30gfTsgfVxcblxcbmZ1bmN0aW9uIGJpbmQoZikge1xcbiAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xcbiAgcmV0dXJuIGZ1bmN0aW9uKCl7cmV0dXJuIGYuYXBwbHkobnVsbCwgYXJncyl9XFxufVxcblxcbmZ1bmN0aW9uIGNvcHlPYmoob2JqLCB0YXJnZXQsIG92ZXJ3cml0ZSkge1xcbiAgaWYgKCF0YXJnZXQpIHsgdGFyZ2V0ID0ge307IH1cXG4gIGZvciAodmFyIHByb3AgaW4gb2JqKVxcbiAgICB7IGlmIChvYmouaGFzT3duUHJvcGVydHkocHJvcCkgJiYgKG92ZXJ3cml0ZSAhPT0gZmFsc2UgfHwgIXRhcmdldC5oYXNPd25Qcm9wZXJ0eShwcm9wKSkpXFxuICAgICAgeyB0YXJnZXRbcHJvcF0gPSBvYmpbcHJvcF07IH0gfVxcbiAgcmV0dXJuIHRhcmdldFxcbn1cXG5cXG4vLyBDb3VudHMgdGhlIGNvbHVtbiBvZmZzZXQgaW4gYSBzdHJpbmcsIHRha2luZyB0YWJzIGludG8gYWNjb3VudC5cXG4vLyBVc2VkIG1vc3RseSB0byBmaW5kIGluZGVudGF0aW9uLlxcbmZ1bmN0aW9uIGNvdW50Q29sdW1uKHN0cmluZywgZW5kLCB0YWJTaXplLCBzdGFydEluZGV4LCBzdGFydFZhbHVlKSB7XFxuICBpZiAoZW5kID09IG51bGwpIHtcXG4gICAgZW5kID0gc3RyaW5nLnNlYXJjaCgvW15cXFxcc1xcXFx1MDBhMF0vKTtcXG4gICAgaWYgKGVuZCA9PSAtMSkgeyBlbmQgPSBzdHJpbmcubGVuZ3RoOyB9XFxuICB9XFxuICBmb3IgKHZhciBpID0gc3RhcnRJbmRleCB8fCAwLCBuID0gc3RhcnRWYWx1ZSB8fCAwOzspIHtcXG4gICAgdmFyIG5leHRUYWIgPSBzdHJpbmcuaW5kZXhPZihcXFwiXFxcXHRcXFwiLCBpKTtcXG4gICAgaWYgKG5leHRUYWIgPCAwIHx8IG5leHRUYWIgPj0gZW5kKVxcbiAgICAgIHsgcmV0dXJuIG4gKyAoZW5kIC0gaSkgfVxcbiAgICBuICs9IG5leHRUYWIgLSBpO1xcbiAgICBuICs9IHRhYlNpemUgLSAobiAlIHRhYlNpemUpO1xcbiAgICBpID0gbmV4dFRhYiArIDE7XFxuICB9XFxufVxcblxcbnZhciBEZWxheWVkID0gZnVuY3Rpb24oKSB7dGhpcy5pZCA9IG51bGw7fTtcXG5EZWxheWVkLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAobXMsIGYpIHtcXG4gIGNsZWFyVGltZW91dCh0aGlzLmlkKTtcXG4gIHRoaXMuaWQgPSBzZXRUaW1lb3V0KGYsIG1zKTtcXG59O1xcblxcbmZ1bmN0aW9uIGluZGV4T2YoYXJyYXksIGVsdCkge1xcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7ICsraSlcXG4gICAgeyBpZiAoYXJyYXlbaV0gPT0gZWx0KSB7IHJldHVybiBpIH0gfVxcbiAgcmV0dXJuIC0xXFxufVxcblxcbi8vIE51bWJlciBvZiBwaXhlbHMgYWRkZWQgdG8gc2Nyb2xsZXIgYW5kIHNpemVyIHRvIGhpZGUgc2Nyb2xsYmFyXFxudmFyIHNjcm9sbGVyR2FwID0gMzA7XFxuXFxuLy8gUmV0dXJuZWQgb3IgdGhyb3duIGJ5IHZhcmlvdXMgcHJvdG9jb2xzIHRvIHNpZ25hbCAnSSdtIG5vdFxcbi8vIGhhbmRsaW5nIHRoaXMnLlxcbnZhciBQYXNzID0ge3RvU3RyaW5nOiBmdW5jdGlvbigpe3JldHVybiBcXFwiQ29kZU1pcnJvci5QYXNzXFxcIn19O1xcblxcbi8vIFJldXNlZCBvcHRpb24gb2JqZWN0cyBmb3Igc2V0U2VsZWN0aW9uICYgZnJpZW5kc1xcbnZhciBzZWxfZG9udFNjcm9sbCA9IHtzY3JvbGw6IGZhbHNlfTtcXG52YXIgc2VsX21vdXNlID0ge29yaWdpbjogXFxcIiptb3VzZVxcXCJ9O1xcbnZhciBzZWxfbW92ZSA9IHtvcmlnaW46IFxcXCIrbW92ZVxcXCJ9O1xcblxcbi8vIFRoZSBpbnZlcnNlIG9mIGNvdW50Q29sdW1uIC0tIGZpbmQgdGhlIG9mZnNldCB0aGF0IGNvcnJlc3BvbmRzIHRvXFxuLy8gYSBwYXJ0aWN1bGFyIGNvbHVtbi5cXG5mdW5jdGlvbiBmaW5kQ29sdW1uKHN0cmluZywgZ29hbCwgdGFiU2l6ZSkge1xcbiAgZm9yICh2YXIgcG9zID0gMCwgY29sID0gMDs7KSB7XFxuICAgIHZhciBuZXh0VGFiID0gc3RyaW5nLmluZGV4T2YoXFxcIlxcXFx0XFxcIiwgcG9zKTtcXG4gICAgaWYgKG5leHRUYWIgPT0gLTEpIHsgbmV4dFRhYiA9IHN0cmluZy5sZW5ndGg7IH1cXG4gICAgdmFyIHNraXBwZWQgPSBuZXh0VGFiIC0gcG9zO1xcbiAgICBpZiAobmV4dFRhYiA9PSBzdHJpbmcubGVuZ3RoIHx8IGNvbCArIHNraXBwZWQgPj0gZ29hbClcXG4gICAgICB7IHJldHVybiBwb3MgKyBNYXRoLm1pbihza2lwcGVkLCBnb2FsIC0gY29sKSB9XFxuICAgIGNvbCArPSBuZXh0VGFiIC0gcG9zO1xcbiAgICBjb2wgKz0gdGFiU2l6ZSAtIChjb2wgJSB0YWJTaXplKTtcXG4gICAgcG9zID0gbmV4dFRhYiArIDE7XFxuICAgIGlmIChjb2wgPj0gZ29hbCkgeyByZXR1cm4gcG9zIH1cXG4gIH1cXG59XFxuXFxudmFyIHNwYWNlU3RycyA9IFtcXFwiXFxcIl07XFxuZnVuY3Rpb24gc3BhY2VTdHIobikge1xcbiAgd2hpbGUgKHNwYWNlU3Rycy5sZW5ndGggPD0gbilcXG4gICAgeyBzcGFjZVN0cnMucHVzaChsc3Qoc3BhY2VTdHJzKSArIFxcXCIgXFxcIik7IH1cXG4gIHJldHVybiBzcGFjZVN0cnNbbl1cXG59XFxuXFxuZnVuY3Rpb24gbHN0KGFycikgeyByZXR1cm4gYXJyW2Fyci5sZW5ndGgtMV0gfVxcblxcbmZ1bmN0aW9uIG1hcChhcnJheSwgZikge1xcbiAgdmFyIG91dCA9IFtdO1xcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykgeyBvdXRbaV0gPSBmKGFycmF5W2ldLCBpKTsgfVxcbiAgcmV0dXJuIG91dFxcbn1cXG5cXG5mdW5jdGlvbiBpbnNlcnRTb3J0ZWQoYXJyYXksIHZhbHVlLCBzY29yZSkge1xcbiAgdmFyIHBvcyA9IDAsIHByaW9yaXR5ID0gc2NvcmUodmFsdWUpO1xcbiAgd2hpbGUgKHBvcyA8IGFycmF5Lmxlbmd0aCAmJiBzY29yZShhcnJheVtwb3NdKSA8PSBwcmlvcml0eSkgeyBwb3MrKzsgfVxcbiAgYXJyYXkuc3BsaWNlKHBvcywgMCwgdmFsdWUpO1xcbn1cXG5cXG5mdW5jdGlvbiBub3RoaW5nKCkge31cXG5cXG5mdW5jdGlvbiBjcmVhdGVPYmooYmFzZSwgcHJvcHMpIHtcXG4gIHZhciBpbnN0O1xcbiAgaWYgKE9iamVjdC5jcmVhdGUpIHtcXG4gICAgaW5zdCA9IE9iamVjdC5jcmVhdGUoYmFzZSk7XFxuICB9IGVsc2Uge1xcbiAgICBub3RoaW5nLnByb3RvdHlwZSA9IGJhc2U7XFxuICAgIGluc3QgPSBuZXcgbm90aGluZygpO1xcbiAgfVxcbiAgaWYgKHByb3BzKSB7IGNvcHlPYmoocHJvcHMsIGluc3QpOyB9XFxuICByZXR1cm4gaW5zdFxcbn1cXG5cXG52YXIgbm9uQVNDSUlTaW5nbGVDYXNlV29yZENoYXIgPSAvW1xcXFx1MDBkZlxcXFx1MDU4N1xcXFx1MDU5MC1cXFxcdTA1ZjRcXFxcdTA2MDAtXFxcXHUwNmZmXFxcXHUzMDQwLVxcXFx1MzA5ZlxcXFx1MzBhMC1cXFxcdTMwZmZcXFxcdTM0MDAtXFxcXHU0ZGI1XFxcXHU0ZTAwLVxcXFx1OWZjY1xcXFx1YWMwMC1cXFxcdWQ3YWZdLztcXG5mdW5jdGlvbiBpc1dvcmRDaGFyQmFzaWMoY2gpIHtcXG4gIHJldHVybiAvXFxcXHcvLnRlc3QoY2gpIHx8IGNoID4gXFxcIlxcXFx4ODBcXFwiICYmXFxuICAgIChjaC50b1VwcGVyQ2FzZSgpICE9IGNoLnRvTG93ZXJDYXNlKCkgfHwgbm9uQVNDSUlTaW5nbGVDYXNlV29yZENoYXIudGVzdChjaCkpXFxufVxcbmZ1bmN0aW9uIGlzV29yZENoYXIoY2gsIGhlbHBlcikge1xcbiAgaWYgKCFoZWxwZXIpIHsgcmV0dXJuIGlzV29yZENoYXJCYXNpYyhjaCkgfVxcbiAgaWYgKGhlbHBlci5zb3VyY2UuaW5kZXhPZihcXFwiXFxcXFxcXFx3XFxcIikgPiAtMSAmJiBpc1dvcmRDaGFyQmFzaWMoY2gpKSB7IHJldHVybiB0cnVlIH1cXG4gIHJldHVybiBoZWxwZXIudGVzdChjaClcXG59XFxuXFxuZnVuY3Rpb24gaXNFbXB0eShvYmopIHtcXG4gIGZvciAodmFyIG4gaW4gb2JqKSB7IGlmIChvYmouaGFzT3duUHJvcGVydHkobikgJiYgb2JqW25dKSB7IHJldHVybiBmYWxzZSB9IH1cXG4gIHJldHVybiB0cnVlXFxufVxcblxcbi8vIEV4dGVuZGluZyB1bmljb2RlIGNoYXJhY3RlcnMuIEEgc2VyaWVzIG9mIGEgbm9uLWV4dGVuZGluZyBjaGFyICtcXG4vLyBhbnkgbnVtYmVyIG9mIGV4dGVuZGluZyBjaGFycyBpcyB0cmVhdGVkIGFzIGEgc2luZ2xlIHVuaXQgYXMgZmFyXFxuLy8gYXMgZWRpdGluZyBhbmQgbWVhc3VyaW5nIGlzIGNvbmNlcm5lZC4gVGhpcyBpcyBub3QgZnVsbHkgY29ycmVjdCxcXG4vLyBzaW5jZSBzb21lIHNjcmlwdHMvZm9udHMvYnJvd3NlcnMgYWxzbyB0cmVhdCBvdGhlciBjb25maWd1cmF0aW9uc1xcbi8vIG9mIGNvZGUgcG9pbnRzIGFzIGEgZ3JvdXAuXFxudmFyIGV4dGVuZGluZ0NoYXJzID0gL1tcXFxcdTAzMDAtXFxcXHUwMzZmXFxcXHUwNDgzLVxcXFx1MDQ4OVxcXFx1MDU5MS1cXFxcdTA1YmRcXFxcdTA1YmZcXFxcdTA1YzFcXFxcdTA1YzJcXFxcdTA1YzRcXFxcdTA1YzVcXFxcdTA1YzdcXFxcdTA2MTAtXFxcXHUwNjFhXFxcXHUwNjRiLVxcXFx1MDY1ZVxcXFx1MDY3MFxcXFx1MDZkNi1cXFxcdTA2ZGNcXFxcdTA2ZGUtXFxcXHUwNmU0XFxcXHUwNmU3XFxcXHUwNmU4XFxcXHUwNmVhLVxcXFx1MDZlZFxcXFx1MDcxMVxcXFx1MDczMC1cXFxcdTA3NGFcXFxcdTA3YTYtXFxcXHUwN2IwXFxcXHUwN2ViLVxcXFx1MDdmM1xcXFx1MDgxNi1cXFxcdTA4MTlcXFxcdTA4MWItXFxcXHUwODIzXFxcXHUwODI1LVxcXFx1MDgyN1xcXFx1MDgyOS1cXFxcdTA4MmRcXFxcdTA5MDAtXFxcXHUwOTAyXFxcXHUwOTNjXFxcXHUwOTQxLVxcXFx1MDk0OFxcXFx1MDk0ZFxcXFx1MDk1MS1cXFxcdTA5NTVcXFxcdTA5NjJcXFxcdTA5NjNcXFxcdTA5ODFcXFxcdTA5YmNcXFxcdTA5YmVcXFxcdTA5YzEtXFxcXHUwOWM0XFxcXHUwOWNkXFxcXHUwOWQ3XFxcXHUwOWUyXFxcXHUwOWUzXFxcXHUwYTAxXFxcXHUwYTAyXFxcXHUwYTNjXFxcXHUwYTQxXFxcXHUwYTQyXFxcXHUwYTQ3XFxcXHUwYTQ4XFxcXHUwYTRiLVxcXFx1MGE0ZFxcXFx1MGE1MVxcXFx1MGE3MFxcXFx1MGE3MVxcXFx1MGE3NVxcXFx1MGE4MVxcXFx1MGE4MlxcXFx1MGFiY1xcXFx1MGFjMS1cXFxcdTBhYzVcXFxcdTBhYzdcXFxcdTBhYzhcXFxcdTBhY2RcXFxcdTBhZTJcXFxcdTBhZTNcXFxcdTBiMDFcXFxcdTBiM2NcXFxcdTBiM2VcXFxcdTBiM2ZcXFxcdTBiNDEtXFxcXHUwYjQ0XFxcXHUwYjRkXFxcXHUwYjU2XFxcXHUwYjU3XFxcXHUwYjYyXFxcXHUwYjYzXFxcXHUwYjgyXFxcXHUwYmJlXFxcXHUwYmMwXFxcXHUwYmNkXFxcXHUwYmQ3XFxcXHUwYzNlLVxcXFx1MGM0MFxcXFx1MGM0Ni1cXFxcdTBjNDhcXFxcdTBjNGEtXFxcXHUwYzRkXFxcXHUwYzU1XFxcXHUwYzU2XFxcXHUwYzYyXFxcXHUwYzYzXFxcXHUwY2JjXFxcXHUwY2JmXFxcXHUwY2MyXFxcXHUwY2M2XFxcXHUwY2NjXFxcXHUwY2NkXFxcXHUwY2Q1XFxcXHUwY2Q2XFxcXHUwY2UyXFxcXHUwY2UzXFxcXHUwZDNlXFxcXHUwZDQxLVxcXFx1MGQ0NFxcXFx1MGQ0ZFxcXFx1MGQ1N1xcXFx1MGQ2MlxcXFx1MGQ2M1xcXFx1MGRjYVxcXFx1MGRjZlxcXFx1MGRkMi1cXFxcdTBkZDRcXFxcdTBkZDZcXFxcdTBkZGZcXFxcdTBlMzFcXFxcdTBlMzQtXFxcXHUwZTNhXFxcXHUwZTQ3LVxcXFx1MGU0ZVxcXFx1MGViMVxcXFx1MGViNC1cXFxcdTBlYjlcXFxcdTBlYmJcXFxcdTBlYmNcXFxcdTBlYzgtXFxcXHUwZWNkXFxcXHUwZjE4XFxcXHUwZjE5XFxcXHUwZjM1XFxcXHUwZjM3XFxcXHUwZjM5XFxcXHUwZjcxLVxcXFx1MGY3ZVxcXFx1MGY4MC1cXFxcdTBmODRcXFxcdTBmODZcXFxcdTBmODdcXFxcdTBmOTAtXFxcXHUwZjk3XFxcXHUwZjk5LVxcXFx1MGZiY1xcXFx1MGZjNlxcXFx1MTAyZC1cXFxcdTEwMzBcXFxcdTEwMzItXFxcXHUxMDM3XFxcXHUxMDM5XFxcXHUxMDNhXFxcXHUxMDNkXFxcXHUxMDNlXFxcXHUxMDU4XFxcXHUxMDU5XFxcXHUxMDVlLVxcXFx1MTA2MFxcXFx1MTA3MS1cXFxcdTEwNzRcXFxcdTEwODJcXFxcdTEwODVcXFxcdTEwODZcXFxcdTEwOGRcXFxcdTEwOWRcXFxcdTEzNWZcXFxcdTE3MTItXFxcXHUxNzE0XFxcXHUxNzMyLVxcXFx1MTczNFxcXFx1MTc1MlxcXFx1MTc1M1xcXFx1MTc3MlxcXFx1MTc3M1xcXFx1MTdiNy1cXFxcdTE3YmRcXFxcdTE3YzZcXFxcdTE3YzktXFxcXHUxN2QzXFxcXHUxN2RkXFxcXHUxODBiLVxcXFx1MTgwZFxcXFx1MThhOVxcXFx1MTkyMC1cXFxcdTE5MjJcXFxcdTE5MjdcXFxcdTE5MjhcXFxcdTE5MzJcXFxcdTE5MzktXFxcXHUxOTNiXFxcXHUxYTE3XFxcXHUxYTE4XFxcXHUxYTU2XFxcXHUxYTU4LVxcXFx1MWE1ZVxcXFx1MWE2MFxcXFx1MWE2MlxcXFx1MWE2NS1cXFxcdTFhNmNcXFxcdTFhNzMtXFxcXHUxYTdjXFxcXHUxYTdmXFxcXHUxYjAwLVxcXFx1MWIwM1xcXFx1MWIzNFxcXFx1MWIzNi1cXFxcdTFiM2FcXFxcdTFiM2NcXFxcdTFiNDJcXFxcdTFiNmItXFxcXHUxYjczXFxcXHUxYjgwXFxcXHUxYjgxXFxcXHUxYmEyLVxcXFx1MWJhNVxcXFx1MWJhOFxcXFx1MWJhOVxcXFx1MWMyYy1cXFxcdTFjMzNcXFxcdTFjMzZcXFxcdTFjMzdcXFxcdTFjZDAtXFxcXHUxY2QyXFxcXHUxY2Q0LVxcXFx1MWNlMFxcXFx1MWNlMi1cXFxcdTFjZThcXFxcdTFjZWRcXFxcdTFkYzAtXFxcXHUxZGU2XFxcXHUxZGZkLVxcXFx1MWRmZlxcXFx1MjAwY1xcXFx1MjAwZFxcXFx1MjBkMC1cXFxcdTIwZjBcXFxcdTJjZWYtXFxcXHUyY2YxXFxcXHUyZGUwLVxcXFx1MmRmZlxcXFx1MzAyYS1cXFxcdTMwMmZcXFxcdTMwOTlcXFxcdTMwOWFcXFxcdWE2NmYtXFxcXHVhNjcyXFxcXHVhNjdjXFxcXHVhNjdkXFxcXHVhNmYwXFxcXHVhNmYxXFxcXHVhODAyXFxcXHVhODA2XFxcXHVhODBiXFxcXHVhODI1XFxcXHVhODI2XFxcXHVhOGM0XFxcXHVhOGUwLVxcXFx1YThmMVxcXFx1YTkyNi1cXFxcdWE5MmRcXFxcdWE5NDctXFxcXHVhOTUxXFxcXHVhOTgwLVxcXFx1YTk4MlxcXFx1YTliM1xcXFx1YTliNi1cXFxcdWE5YjlcXFxcdWE5YmNcXFxcdWFhMjktXFxcXHVhYTJlXFxcXHVhYTMxXFxcXHVhYTMyXFxcXHVhYTM1XFxcXHVhYTM2XFxcXHVhYTQzXFxcXHVhYTRjXFxcXHVhYWIwXFxcXHVhYWIyLVxcXFx1YWFiNFxcXFx1YWFiN1xcXFx1YWFiOFxcXFx1YWFiZVxcXFx1YWFiZlxcXFx1YWFjMVxcXFx1YWJlNVxcXFx1YWJlOFxcXFx1YWJlZFxcXFx1ZGMwMC1cXFxcdWRmZmZcXFxcdWZiMWVcXFxcdWZlMDAtXFxcXHVmZTBmXFxcXHVmZTIwLVxcXFx1ZmUyNlxcXFx1ZmY5ZVxcXFx1ZmY5Zl0vO1xcbmZ1bmN0aW9uIGlzRXh0ZW5kaW5nQ2hhcihjaCkgeyByZXR1cm4gY2guY2hhckNvZGVBdCgwKSA+PSA3NjggJiYgZXh0ZW5kaW5nQ2hhcnMudGVzdChjaCkgfVxcblxcbi8vIFJldHVybnMgYSBudW1iZXIgZnJvbSB0aGUgcmFuZ2UgW2AwYDsgYHN0ci5sZW5ndGhgXSB1bmxlc3MgYHBvc2AgaXMgb3V0c2lkZSB0aGF0IHJhbmdlLlxcbmZ1bmN0aW9uIHNraXBFeHRlbmRpbmdDaGFycyhzdHIsIHBvcywgZGlyKSB7XFxuICB3aGlsZSAoKGRpciA8IDAgPyBwb3MgPiAwIDogcG9zIDwgc3RyLmxlbmd0aCkgJiYgaXNFeHRlbmRpbmdDaGFyKHN0ci5jaGFyQXQocG9zKSkpIHsgcG9zICs9IGRpcjsgfVxcbiAgcmV0dXJuIHBvc1xcbn1cXG5cXG4vLyBSZXR1cm5zIHRoZSB2YWx1ZSBmcm9tIHRoZSByYW5nZSBbYGZyb21gOyBgdG9gXSB0aGF0IHNhdGlzZmllc1xcbi8vIGBwcmVkYCBhbmQgaXMgY2xvc2VzdCB0byBgZnJvbWAuIEFzc3VtZXMgdGhhdCBhdCBsZWFzdCBgdG9gIHNhdGlzZmllcyBgcHJlZGAuXFxuZnVuY3Rpb24gZmluZEZpcnN0KHByZWQsIGZyb20sIHRvKSB7XFxuICBmb3IgKDs7KSB7XFxuICAgIGlmIChNYXRoLmFicyhmcm9tIC0gdG8pIDw9IDEpIHsgcmV0dXJuIHByZWQoZnJvbSkgPyBmcm9tIDogdG8gfVxcbiAgICB2YXIgbWlkID0gTWF0aC5mbG9vcigoZnJvbSArIHRvKSAvIDIpO1xcbiAgICBpZiAocHJlZChtaWQpKSB7IHRvID0gbWlkOyB9XFxuICAgIGVsc2UgeyBmcm9tID0gbWlkOyB9XFxuICB9XFxufVxcblxcbi8vIFRoZSBkaXNwbGF5IGhhbmRsZXMgdGhlIERPTSBpbnRlZ3JhdGlvbiwgYm90aCBmb3IgaW5wdXQgcmVhZGluZ1xcbi8vIGFuZCBjb250ZW50IGRyYXdpbmcuIEl0IGhvbGRzIHJlZmVyZW5jZXMgdG8gRE9NIG5vZGVzIGFuZFxcbi8vIGRpc3BsYXktcmVsYXRlZCBzdGF0ZS5cXG5cXG5mdW5jdGlvbiBEaXNwbGF5KHBsYWNlLCBkb2MsIGlucHV0KSB7XFxuICB2YXIgZCA9IHRoaXM7XFxuICB0aGlzLmlucHV0ID0gaW5wdXQ7XFxuXFxuICAvLyBDb3ZlcnMgYm90dG9tLXJpZ2h0IHNxdWFyZSB3aGVuIGJvdGggc2Nyb2xsYmFycyBhcmUgcHJlc2VudC5cXG4gIGQuc2Nyb2xsYmFyRmlsbGVyID0gZWx0KFxcXCJkaXZcXFwiLCBudWxsLCBcXFwiQ29kZU1pcnJvci1zY3JvbGxiYXItZmlsbGVyXFxcIik7XFxuICBkLnNjcm9sbGJhckZpbGxlci5zZXRBdHRyaWJ1dGUoXFxcImNtLW5vdC1jb250ZW50XFxcIiwgXFxcInRydWVcXFwiKTtcXG4gIC8vIENvdmVycyBib3R0b20gb2YgZ3V0dGVyIHdoZW4gY292ZXJHdXR0ZXJOZXh0VG9TY3JvbGxiYXIgaXMgb25cXG4gIC8vIGFuZCBoIHNjcm9sbGJhciBpcyBwcmVzZW50LlxcbiAgZC5ndXR0ZXJGaWxsZXIgPSBlbHQoXFxcImRpdlxcXCIsIG51bGwsIFxcXCJDb2RlTWlycm9yLWd1dHRlci1maWxsZXJcXFwiKTtcXG4gIGQuZ3V0dGVyRmlsbGVyLnNldEF0dHJpYnV0ZShcXFwiY20tbm90LWNvbnRlbnRcXFwiLCBcXFwidHJ1ZVxcXCIpO1xcbiAgLy8gV2lsbCBjb250YWluIHRoZSBhY3R1YWwgY29kZSwgcG9zaXRpb25lZCB0byBjb3ZlciB0aGUgdmlld3BvcnQuXFxuICBkLmxpbmVEaXYgPSBlbHRQKFxcXCJkaXZcXFwiLCBudWxsLCBcXFwiQ29kZU1pcnJvci1jb2RlXFxcIik7XFxuICAvLyBFbGVtZW50cyBhcmUgYWRkZWQgdG8gdGhlc2UgdG8gcmVwcmVzZW50IHNlbGVjdGlvbiBhbmQgY3Vyc29ycy5cXG4gIGQuc2VsZWN0aW9uRGl2ID0gZWx0KFxcXCJkaXZcXFwiLCBudWxsLCBudWxsLCBcXFwicG9zaXRpb246IHJlbGF0aXZlOyB6LWluZGV4OiAxXFxcIik7XFxuICBkLmN1cnNvckRpdiA9IGVsdChcXFwiZGl2XFxcIiwgbnVsbCwgXFxcIkNvZGVNaXJyb3ItY3Vyc29yc1xcXCIpO1xcbiAgLy8gQSB2aXNpYmlsaXR5OiBoaWRkZW4gZWxlbWVudCB1c2VkIHRvIGZpbmQgdGhlIHNpemUgb2YgdGhpbmdzLlxcbiAgZC5tZWFzdXJlID0gZWx0KFxcXCJkaXZcXFwiLCBudWxsLCBcXFwiQ29kZU1pcnJvci1tZWFzdXJlXFxcIik7XFxuICAvLyBXaGVuIGxpbmVzIG91dHNpZGUgb2YgdGhlIHZpZXdwb3J0IGFyZSBtZWFzdXJlZCwgdGhleSBhcmUgZHJhd24gaW4gdGhpcy5cXG4gIGQubGluZU1lYXN1cmUgPSBlbHQoXFxcImRpdlxcXCIsIG51bGwsIFxcXCJDb2RlTWlycm9yLW1lYXN1cmVcXFwiKTtcXG4gIC8vIFdyYXBzIGV2ZXJ5dGhpbmcgdGhhdCBuZWVkcyB0byBleGlzdCBpbnNpZGUgdGhlIHZlcnRpY2FsbHktcGFkZGVkIGNvb3JkaW5hdGUgc3lzdGVtXFxuICBkLmxpbmVTcGFjZSA9IGVsdFAoXFxcImRpdlxcXCIsIFtkLm1lYXN1cmUsIGQubGluZU1lYXN1cmUsIGQuc2VsZWN0aW9uRGl2LCBkLmN1cnNvckRpdiwgZC5saW5lRGl2XSxcXG4gICAgICAgICAgICAgICAgICAgIG51bGwsIFxcXCJwb3NpdGlvbjogcmVsYXRpdmU7IG91dGxpbmU6IG5vbmVcXFwiKTtcXG4gIHZhciBsaW5lcyA9IGVsdFAoXFxcImRpdlxcXCIsIFtkLmxpbmVTcGFjZV0sIFxcXCJDb2RlTWlycm9yLWxpbmVzXFxcIik7XFxuICAvLyBNb3ZlZCBhcm91bmQgaXRzIHBhcmVudCB0byBjb3ZlciB2aXNpYmxlIHZpZXcuXFxuICBkLm1vdmVyID0gZWx0KFxcXCJkaXZcXFwiLCBbbGluZXNdLCBudWxsLCBcXFwicG9zaXRpb246IHJlbGF0aXZlXFxcIik7XFxuICAvLyBTZXQgdG8gdGhlIGhlaWdodCBvZiB0aGUgZG9jdW1lbnQsIGFsbG93aW5nIHNjcm9sbGluZy5cXG4gIGQuc2l6ZXIgPSBlbHQoXFxcImRpdlxcXCIsIFtkLm1vdmVyXSwgXFxcIkNvZGVNaXJyb3Itc2l6ZXJcXFwiKTtcXG4gIGQuc2l6ZXJXaWR0aCA9IG51bGw7XFxuICAvLyBCZWhhdmlvciBvZiBlbHRzIHdpdGggb3ZlcmZsb3c6IGF1dG8gYW5kIHBhZGRpbmcgaXNcXG4gIC8vIGluY29uc2lzdGVudCBhY3Jvc3MgYnJvd3NlcnMuIFRoaXMgaXMgdXNlZCB0byBlbnN1cmUgdGhlXFxuICAvLyBzY3JvbGxhYmxlIGFyZWEgaXMgYmlnIGVub3VnaC5cXG4gIGQuaGVpZ2h0Rm9yY2VyID0gZWx0KFxcXCJkaXZcXFwiLCBudWxsLCBudWxsLCBcXFwicG9zaXRpb246IGFic29sdXRlOyBoZWlnaHQ6IFxcXCIgKyBzY3JvbGxlckdhcCArIFxcXCJweDsgd2lkdGg6IDFweDtcXFwiKTtcXG4gIC8vIFdpbGwgY29udGFpbiB0aGUgZ3V0dGVycywgaWYgYW55LlxcbiAgZC5ndXR0ZXJzID0gZWx0KFxcXCJkaXZcXFwiLCBudWxsLCBcXFwiQ29kZU1pcnJvci1ndXR0ZXJzXFxcIik7XFxuICBkLmxpbmVHdXR0ZXIgPSBudWxsO1xcbiAgLy8gQWN0dWFsIHNjcm9sbGFibGUgZWxlbWVudC5cXG4gIGQuc2Nyb2xsZXIgPSBlbHQoXFxcImRpdlxcXCIsIFtkLnNpemVyLCBkLmhlaWdodEZvcmNlciwgZC5ndXR0ZXJzXSwgXFxcIkNvZGVNaXJyb3Itc2Nyb2xsXFxcIik7XFxuICBkLnNjcm9sbGVyLnNldEF0dHJpYnV0ZShcXFwidGFiSW5kZXhcXFwiLCBcXFwiLTFcXFwiKTtcXG4gIC8vIFRoZSBlbGVtZW50IGluIHdoaWNoIHRoZSBlZGl0b3IgbGl2ZXMuXFxuICBkLndyYXBwZXIgPSBlbHQoXFxcImRpdlxcXCIsIFtkLnNjcm9sbGJhckZpbGxlciwgZC5ndXR0ZXJGaWxsZXIsIGQuc2Nyb2xsZXJdLCBcXFwiQ29kZU1pcnJvclxcXCIpO1xcblxcbiAgLy8gV29yayBhcm91bmQgSUU3IHotaW5kZXggYnVnIChub3QgcGVyZmVjdCwgaGVuY2UgSUU3IG5vdCByZWFsbHkgYmVpbmcgc3VwcG9ydGVkKVxcbiAgaWYgKGllICYmIGllX3ZlcnNpb24gPCA4KSB7IGQuZ3V0dGVycy5zdHlsZS56SW5kZXggPSAtMTsgZC5zY3JvbGxlci5zdHlsZS5wYWRkaW5nUmlnaHQgPSAwOyB9XFxuICBpZiAoIXdlYmtpdCAmJiAhKGdlY2tvICYmIG1vYmlsZSkpIHsgZC5zY3JvbGxlci5kcmFnZ2FibGUgPSB0cnVlOyB9XFxuXFxuICBpZiAocGxhY2UpIHtcXG4gICAgaWYgKHBsYWNlLmFwcGVuZENoaWxkKSB7IHBsYWNlLmFwcGVuZENoaWxkKGQud3JhcHBlcik7IH1cXG4gICAgZWxzZSB7IHBsYWNlKGQud3JhcHBlcik7IH1cXG4gIH1cXG5cXG4gIC8vIEN1cnJlbnQgcmVuZGVyZWQgcmFuZ2UgKG1heSBiZSBiaWdnZXIgdGhhbiB0aGUgdmlldyB3aW5kb3cpLlxcbiAgZC52aWV3RnJvbSA9IGQudmlld1RvID0gZG9jLmZpcnN0O1xcbiAgZC5yZXBvcnRlZFZpZXdGcm9tID0gZC5yZXBvcnRlZFZpZXdUbyA9IGRvYy5maXJzdDtcXG4gIC8vIEluZm9ybWF0aW9uIGFib3V0IHRoZSByZW5kZXJlZCBsaW5lcy5cXG4gIGQudmlldyA9IFtdO1xcbiAgZC5yZW5kZXJlZFZpZXcgPSBudWxsO1xcbiAgLy8gSG9sZHMgaW5mbyBhYm91dCBhIHNpbmdsZSByZW5kZXJlZCBsaW5lIHdoZW4gaXQgd2FzIHJlbmRlcmVkXFxuICAvLyBmb3IgbWVhc3VyZW1lbnQsIHdoaWxlIG5vdCBpbiB2aWV3LlxcbiAgZC5leHRlcm5hbE1lYXN1cmVkID0gbnVsbDtcXG4gIC8vIEVtcHR5IHNwYWNlIChpbiBwaXhlbHMpIGFib3ZlIHRoZSB2aWV3XFxuICBkLnZpZXdPZmZzZXQgPSAwO1xcbiAgZC5sYXN0V3JhcEhlaWdodCA9IGQubGFzdFdyYXBXaWR0aCA9IDA7XFxuICBkLnVwZGF0ZUxpbmVOdW1iZXJzID0gbnVsbDtcXG5cXG4gIGQubmF0aXZlQmFyV2lkdGggPSBkLmJhckhlaWdodCA9IGQuYmFyV2lkdGggPSAwO1xcbiAgZC5zY3JvbGxiYXJzQ2xpcHBlZCA9IGZhbHNlO1xcblxcbiAgLy8gVXNlZCB0byBvbmx5IHJlc2l6ZSB0aGUgbGluZSBudW1iZXIgZ3V0dGVyIHdoZW4gbmVjZXNzYXJ5ICh3aGVuXFxuICAvLyB0aGUgYW1vdW50IG9mIGxpbmVzIGNyb3NzZXMgYSBib3VuZGFyeSB0aGF0IG1ha2VzIGl0cyB3aWR0aCBjaGFuZ2UpXFxuICBkLmxpbmVOdW1XaWR0aCA9IGQubGluZU51bUlubmVyV2lkdGggPSBkLmxpbmVOdW1DaGFycyA9IG51bGw7XFxuICAvLyBTZXQgdG8gdHJ1ZSB3aGVuIGEgbm9uLWhvcml6b250YWwtc2Nyb2xsaW5nIGxpbmUgd2lkZ2V0IGlzXFxuICAvLyBhZGRlZC4gQXMgYW4gb3B0aW1pemF0aW9uLCBsaW5lIHdpZGdldCBhbGlnbmluZyBpcyBza2lwcGVkIHdoZW5cXG4gIC8vIHRoaXMgaXMgZmFsc2UuXFxuICBkLmFsaWduV2lkZ2V0cyA9IGZhbHNlO1xcblxcbiAgZC5jYWNoZWRDaGFyV2lkdGggPSBkLmNhY2hlZFRleHRIZWlnaHQgPSBkLmNhY2hlZFBhZGRpbmdIID0gbnVsbDtcXG5cXG4gIC8vIFRyYWNrcyB0aGUgbWF4aW11bSBsaW5lIGxlbmd0aCBzbyB0aGF0IHRoZSBob3Jpem9udGFsIHNjcm9sbGJhclxcbiAgLy8gY2FuIGJlIGtlcHQgc3RhdGljIHdoZW4gc2Nyb2xsaW5nLlxcbiAgZC5tYXhMaW5lID0gbnVsbDtcXG4gIGQubWF4TGluZUxlbmd0aCA9IDA7XFxuICBkLm1heExpbmVDaGFuZ2VkID0gZmFsc2U7XFxuXFxuICAvLyBVc2VkIGZvciBtZWFzdXJpbmcgd2hlZWwgc2Nyb2xsaW5nIGdyYW51bGFyaXR5XFxuICBkLndoZWVsRFggPSBkLndoZWVsRFkgPSBkLndoZWVsU3RhcnRYID0gZC53aGVlbFN0YXJ0WSA9IG51bGw7XFxuXFxuICAvLyBUcnVlIHdoZW4gc2hpZnQgaXMgaGVsZCBkb3duLlxcbiAgZC5zaGlmdCA9IGZhbHNlO1xcblxcbiAgLy8gVXNlZCB0byB0cmFjayB3aGV0aGVyIGFueXRoaW5nIGhhcHBlbmVkIHNpbmNlIHRoZSBjb250ZXh0IG1lbnVcXG4gIC8vIHdhcyBvcGVuZWQuXFxuICBkLnNlbEZvckNvbnRleHRNZW51ID0gbnVsbDtcXG5cXG4gIGQuYWN0aXZlVG91Y2ggPSBudWxsO1xcblxcbiAgaW5wdXQuaW5pdChkKTtcXG59XFxuXFxuLy8gRmluZCB0aGUgbGluZSBvYmplY3QgY29ycmVzcG9uZGluZyB0byB0aGUgZ2l2ZW4gbGluZSBudW1iZXIuXFxuZnVuY3Rpb24gZ2V0TGluZShkb2MsIG4pIHtcXG4gIG4gLT0gZG9jLmZpcnN0O1xcbiAgaWYgKG4gPCAwIHx8IG4gPj0gZG9jLnNpemUpIHsgdGhyb3cgbmV3IEVycm9yKFxcXCJUaGVyZSBpcyBubyBsaW5lIFxcXCIgKyAobiArIGRvYy5maXJzdCkgKyBcXFwiIGluIHRoZSBkb2N1bWVudC5cXFwiKSB9XFxuICB2YXIgY2h1bmsgPSBkb2M7XFxuICB3aGlsZSAoIWNodW5rLmxpbmVzKSB7XFxuICAgIGZvciAodmFyIGkgPSAwOzsgKytpKSB7XFxuICAgICAgdmFyIGNoaWxkID0gY2h1bmsuY2hpbGRyZW5baV0sIHN6ID0gY2hpbGQuY2h1bmtTaXplKCk7XFxuICAgICAgaWYgKG4gPCBzeikgeyBjaHVuayA9IGNoaWxkOyBicmVhayB9XFxuICAgICAgbiAtPSBzejtcXG4gICAgfVxcbiAgfVxcbiAgcmV0dXJuIGNodW5rLmxpbmVzW25dXFxufVxcblxcbi8vIEdldCB0aGUgcGFydCBvZiBhIGRvY3VtZW50IGJldHdlZW4gdHdvIHBvc2l0aW9ucywgYXMgYW4gYXJyYXkgb2ZcXG4vLyBzdHJpbmdzLlxcbmZ1bmN0aW9uIGdldEJldHdlZW4oZG9jLCBzdGFydCwgZW5kKSB7XFxuICB2YXIgb3V0ID0gW10sIG4gPSBzdGFydC5saW5lO1xcbiAgZG9jLml0ZXIoc3RhcnQubGluZSwgZW5kLmxpbmUgKyAxLCBmdW5jdGlvbiAobGluZSkge1xcbiAgICB2YXIgdGV4dCA9IGxpbmUudGV4dDtcXG4gICAgaWYgKG4gPT0gZW5kLmxpbmUpIHsgdGV4dCA9IHRleHQuc2xpY2UoMCwgZW5kLmNoKTsgfVxcbiAgICBpZiAobiA9PSBzdGFydC5saW5lKSB7IHRleHQgPSB0ZXh0LnNsaWNlKHN0YXJ0LmNoKTsgfVxcbiAgICBvdXQucHVzaCh0ZXh0KTtcXG4gICAgKytuO1xcbiAgfSk7XFxuICByZXR1cm4gb3V0XFxufVxcbi8vIEdldCB0aGUgbGluZXMgYmV0d2VlbiBmcm9tIGFuZCB0bywgYXMgYXJyYXkgb2Ygc3RyaW5ncy5cXG5mdW5jdGlvbiBnZXRMaW5lcyhkb2MsIGZyb20sIHRvKSB7XFxuICB2YXIgb3V0ID0gW107XFxuICBkb2MuaXRlcihmcm9tLCB0bywgZnVuY3Rpb24gKGxpbmUpIHsgb3V0LnB1c2gobGluZS50ZXh0KTsgfSk7IC8vIGl0ZXIgYWJvcnRzIHdoZW4gY2FsbGJhY2sgcmV0dXJucyB0cnV0aHkgdmFsdWVcXG4gIHJldHVybiBvdXRcXG59XFxuXFxuLy8gVXBkYXRlIHRoZSBoZWlnaHQgb2YgYSBsaW5lLCBwcm9wYWdhdGluZyB0aGUgaGVpZ2h0IGNoYW5nZVxcbi8vIHVwd2FyZHMgdG8gcGFyZW50IG5vZGVzLlxcbmZ1bmN0aW9uIHVwZGF0ZUxpbmVIZWlnaHQobGluZSwgaGVpZ2h0KSB7XFxuICB2YXIgZGlmZiA9IGhlaWdodCAtIGxpbmUuaGVpZ2h0O1xcbiAgaWYgKGRpZmYpIHsgZm9yICh2YXIgbiA9IGxpbmU7IG47IG4gPSBuLnBhcmVudCkgeyBuLmhlaWdodCArPSBkaWZmOyB9IH1cXG59XFxuXFxuLy8gR2l2ZW4gYSBsaW5lIG9iamVjdCwgZmluZCBpdHMgbGluZSBudW1iZXIgYnkgd2Fsa2luZyB1cCB0aHJvdWdoXFxuLy8gaXRzIHBhcmVudCBsaW5rcy5cXG5mdW5jdGlvbiBsaW5lTm8obGluZSkge1xcbiAgaWYgKGxpbmUucGFyZW50ID09IG51bGwpIHsgcmV0dXJuIG51bGwgfVxcbiAgdmFyIGN1ciA9IGxpbmUucGFyZW50LCBubyA9IGluZGV4T2YoY3VyLmxpbmVzLCBsaW5lKTtcXG4gIGZvciAodmFyIGNodW5rID0gY3VyLnBhcmVudDsgY2h1bms7IGN1ciA9IGNodW5rLCBjaHVuayA9IGNodW5rLnBhcmVudCkge1xcbiAgICBmb3IgKHZhciBpID0gMDs7ICsraSkge1xcbiAgICAgIGlmIChjaHVuay5jaGlsZHJlbltpXSA9PSBjdXIpIHsgYnJlYWsgfVxcbiAgICAgIG5vICs9IGNodW5rLmNoaWxkcmVuW2ldLmNodW5rU2l6ZSgpO1xcbiAgICB9XFxuICB9XFxuICByZXR1cm4gbm8gKyBjdXIuZmlyc3RcXG59XFxuXFxuLy8gRmluZCB0aGUgbGluZSBhdCB0aGUgZ2l2ZW4gdmVydGljYWwgcG9zaXRpb24sIHVzaW5nIHRoZSBoZWlnaHRcXG4vLyBpbmZvcm1hdGlvbiBpbiB0aGUgZG9jdW1lbnQgdHJlZS5cXG5mdW5jdGlvbiBsaW5lQXRIZWlnaHQoY2h1bmssIGgpIHtcXG4gIHZhciBuID0gY2h1bmsuZmlyc3Q7XFxuICBvdXRlcjogZG8ge1xcbiAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBjaHVuay5jaGlsZHJlbi5sZW5ndGg7ICsraSQxKSB7XFxuICAgICAgdmFyIGNoaWxkID0gY2h1bmsuY2hpbGRyZW5baSQxXSwgY2ggPSBjaGlsZC5oZWlnaHQ7XFxuICAgICAgaWYgKGggPCBjaCkgeyBjaHVuayA9IGNoaWxkOyBjb250aW51ZSBvdXRlciB9XFxuICAgICAgaCAtPSBjaDtcXG4gICAgICBuICs9IGNoaWxkLmNodW5rU2l6ZSgpO1xcbiAgICB9XFxuICAgIHJldHVybiBuXFxuICB9IHdoaWxlICghY2h1bmsubGluZXMpXFxuICB2YXIgaSA9IDA7XFxuICBmb3IgKDsgaSA8IGNodW5rLmxpbmVzLmxlbmd0aDsgKytpKSB7XFxuICAgIHZhciBsaW5lID0gY2h1bmsubGluZXNbaV0sIGxoID0gbGluZS5oZWlnaHQ7XFxuICAgIGlmIChoIDwgbGgpIHsgYnJlYWsgfVxcbiAgICBoIC09IGxoO1xcbiAgfVxcbiAgcmV0dXJuIG4gKyBpXFxufVxcblxcbmZ1bmN0aW9uIGlzTGluZShkb2MsIGwpIHtyZXR1cm4gbCA+PSBkb2MuZmlyc3QgJiYgbCA8IGRvYy5maXJzdCArIGRvYy5zaXplfVxcblxcbmZ1bmN0aW9uIGxpbmVOdW1iZXJGb3Iob3B0aW9ucywgaSkge1xcbiAgcmV0dXJuIFN0cmluZyhvcHRpb25zLmxpbmVOdW1iZXJGb3JtYXR0ZXIoaSArIG9wdGlvbnMuZmlyc3RMaW5lTnVtYmVyKSlcXG59XFxuXFxuLy8gQSBQb3MgaW5zdGFuY2UgcmVwcmVzZW50cyBhIHBvc2l0aW9uIHdpdGhpbiB0aGUgdGV4dC5cXG5mdW5jdGlvbiBQb3MobGluZSwgY2gsIHN0aWNreSkge1xcbiAgaWYgKCBzdGlja3kgPT09IHZvaWQgMCApIHN0aWNreSA9IG51bGw7XFxuXFxuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUG9zKSkgeyByZXR1cm4gbmV3IFBvcyhsaW5lLCBjaCwgc3RpY2t5KSB9XFxuICB0aGlzLmxpbmUgPSBsaW5lO1xcbiAgdGhpcy5jaCA9IGNoO1xcbiAgdGhpcy5zdGlja3kgPSBzdGlja3k7XFxufVxcblxcbi8vIENvbXBhcmUgdHdvIHBvc2l0aW9ucywgcmV0dXJuIDAgaWYgdGhleSBhcmUgdGhlIHNhbWUsIGEgbmVnYXRpdmVcXG4vLyBudW1iZXIgd2hlbiBhIGlzIGxlc3MsIGFuZCBhIHBvc2l0aXZlIG51bWJlciBvdGhlcndpc2UuXFxuZnVuY3Rpb24gY21wKGEsIGIpIHsgcmV0dXJuIGEubGluZSAtIGIubGluZSB8fCBhLmNoIC0gYi5jaCB9XFxuXFxuZnVuY3Rpb24gZXF1YWxDdXJzb3JQb3MoYSwgYikgeyByZXR1cm4gYS5zdGlja3kgPT0gYi5zdGlja3kgJiYgY21wKGEsIGIpID09IDAgfVxcblxcbmZ1bmN0aW9uIGNvcHlQb3MoeCkge3JldHVybiBQb3MoeC5saW5lLCB4LmNoKX1cXG5mdW5jdGlvbiBtYXhQb3MoYSwgYikgeyByZXR1cm4gY21wKGEsIGIpIDwgMCA/IGIgOiBhIH1cXG5mdW5jdGlvbiBtaW5Qb3MoYSwgYikgeyByZXR1cm4gY21wKGEsIGIpIDwgMCA/IGEgOiBiIH1cXG5cXG4vLyBNb3N0IG9mIHRoZSBleHRlcm5hbCBBUEkgY2xpcHMgZ2l2ZW4gcG9zaXRpb25zIHRvIG1ha2Ugc3VyZSB0aGV5XFxuLy8gYWN0dWFsbHkgZXhpc3Qgd2l0aGluIHRoZSBkb2N1bWVudC5cXG5mdW5jdGlvbiBjbGlwTGluZShkb2MsIG4pIHtyZXR1cm4gTWF0aC5tYXgoZG9jLmZpcnN0LCBNYXRoLm1pbihuLCBkb2MuZmlyc3QgKyBkb2Muc2l6ZSAtIDEpKX1cXG5mdW5jdGlvbiBjbGlwUG9zKGRvYywgcG9zKSB7XFxuICBpZiAocG9zLmxpbmUgPCBkb2MuZmlyc3QpIHsgcmV0dXJuIFBvcyhkb2MuZmlyc3QsIDApIH1cXG4gIHZhciBsYXN0ID0gZG9jLmZpcnN0ICsgZG9jLnNpemUgLSAxO1xcbiAgaWYgKHBvcy5saW5lID4gbGFzdCkgeyByZXR1cm4gUG9zKGxhc3QsIGdldExpbmUoZG9jLCBsYXN0KS50ZXh0Lmxlbmd0aCkgfVxcbiAgcmV0dXJuIGNsaXBUb0xlbihwb3MsIGdldExpbmUoZG9jLCBwb3MubGluZSkudGV4dC5sZW5ndGgpXFxufVxcbmZ1bmN0aW9uIGNsaXBUb0xlbihwb3MsIGxpbmVsZW4pIHtcXG4gIHZhciBjaCA9IHBvcy5jaDtcXG4gIGlmIChjaCA9PSBudWxsIHx8IGNoID4gbGluZWxlbikgeyByZXR1cm4gUG9zKHBvcy5saW5lLCBsaW5lbGVuKSB9XFxuICBlbHNlIGlmIChjaCA8IDApIHsgcmV0dXJuIFBvcyhwb3MubGluZSwgMCkgfVxcbiAgZWxzZSB7IHJldHVybiBwb3MgfVxcbn1cXG5mdW5jdGlvbiBjbGlwUG9zQXJyYXkoZG9jLCBhcnJheSkge1xcbiAgdmFyIG91dCA9IFtdO1xcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykgeyBvdXRbaV0gPSBjbGlwUG9zKGRvYywgYXJyYXlbaV0pOyB9XFxuICByZXR1cm4gb3V0XFxufVxcblxcbi8vIE9wdGltaXplIHNvbWUgY29kZSB3aGVuIHRoZXNlIGZlYXR1cmVzIGFyZSBub3QgdXNlZC5cXG52YXIgc2F3UmVhZE9ubHlTcGFucyA9IGZhbHNlO1xcbnZhciBzYXdDb2xsYXBzZWRTcGFucyA9IGZhbHNlO1xcblxcbmZ1bmN0aW9uIHNlZVJlYWRPbmx5U3BhbnMoKSB7XFxuICBzYXdSZWFkT25seVNwYW5zID0gdHJ1ZTtcXG59XFxuXFxuZnVuY3Rpb24gc2VlQ29sbGFwc2VkU3BhbnMoKSB7XFxuICBzYXdDb2xsYXBzZWRTcGFucyA9IHRydWU7XFxufVxcblxcbi8vIFRFWFRNQVJLRVIgU1BBTlNcXG5cXG5mdW5jdGlvbiBNYXJrZWRTcGFuKG1hcmtlciwgZnJvbSwgdG8pIHtcXG4gIHRoaXMubWFya2VyID0gbWFya2VyO1xcbiAgdGhpcy5mcm9tID0gZnJvbTsgdGhpcy50byA9IHRvO1xcbn1cXG5cXG4vLyBTZWFyY2ggYW4gYXJyYXkgb2Ygc3BhbnMgZm9yIGEgc3BhbiBtYXRjaGluZyB0aGUgZ2l2ZW4gbWFya2VyLlxcbmZ1bmN0aW9uIGdldE1hcmtlZFNwYW5Gb3Ioc3BhbnMsIG1hcmtlcikge1xcbiAgaWYgKHNwYW5zKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgc3BhbnMubGVuZ3RoOyArK2kpIHtcXG4gICAgdmFyIHNwYW4gPSBzcGFuc1tpXTtcXG4gICAgaWYgKHNwYW4ubWFya2VyID09IG1hcmtlcikgeyByZXR1cm4gc3BhbiB9XFxuICB9IH1cXG59XFxuLy8gUmVtb3ZlIGEgc3BhbiBmcm9tIGFuIGFycmF5LCByZXR1cm5pbmcgdW5kZWZpbmVkIGlmIG5vIHNwYW5zIGFyZVxcbi8vIGxlZnQgKHdlIGRvbid0IHN0b3JlIGFycmF5cyBmb3IgbGluZXMgd2l0aG91dCBzcGFucykuXFxuZnVuY3Rpb24gcmVtb3ZlTWFya2VkU3BhbihzcGFucywgc3Bhbikge1xcbiAgdmFyIHI7XFxuICBmb3IgKHZhciBpID0gMDsgaSA8IHNwYW5zLmxlbmd0aDsgKytpKVxcbiAgICB7IGlmIChzcGFuc1tpXSAhPSBzcGFuKSB7IChyIHx8IChyID0gW10pKS5wdXNoKHNwYW5zW2ldKTsgfSB9XFxuICByZXR1cm4gclxcbn1cXG4vLyBBZGQgYSBzcGFuIHRvIGEgbGluZS5cXG5mdW5jdGlvbiBhZGRNYXJrZWRTcGFuKGxpbmUsIHNwYW4pIHtcXG4gIGxpbmUubWFya2VkU3BhbnMgPSBsaW5lLm1hcmtlZFNwYW5zID8gbGluZS5tYXJrZWRTcGFucy5jb25jYXQoW3NwYW5dKSA6IFtzcGFuXTtcXG4gIHNwYW4ubWFya2VyLmF0dGFjaExpbmUobGluZSk7XFxufVxcblxcbi8vIFVzZWQgZm9yIHRoZSBhbGdvcml0aG0gdGhhdCBhZGp1c3RzIG1hcmtlcnMgZm9yIGEgY2hhbmdlIGluIHRoZVxcbi8vIGRvY3VtZW50LiBUaGVzZSBmdW5jdGlvbnMgY3V0IGFuIGFycmF5IG9mIHNwYW5zIGF0IGEgZ2l2ZW5cXG4vLyBjaGFyYWN0ZXIgcG9zaXRpb24sIHJldHVybmluZyBhbiBhcnJheSBvZiByZW1haW5pbmcgY2h1bmtzIChvclxcbi8vIHVuZGVmaW5lZCBpZiBub3RoaW5nIHJlbWFpbnMpLlxcbmZ1bmN0aW9uIG1hcmtlZFNwYW5zQmVmb3JlKG9sZCwgc3RhcnRDaCwgaXNJbnNlcnQpIHtcXG4gIHZhciBudztcXG4gIGlmIChvbGQpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBvbGQubGVuZ3RoOyArK2kpIHtcXG4gICAgdmFyIHNwYW4gPSBvbGRbaV0sIG1hcmtlciA9IHNwYW4ubWFya2VyO1xcbiAgICB2YXIgc3RhcnRzQmVmb3JlID0gc3Bhbi5mcm9tID09IG51bGwgfHwgKG1hcmtlci5pbmNsdXNpdmVMZWZ0ID8gc3Bhbi5mcm9tIDw9IHN0YXJ0Q2ggOiBzcGFuLmZyb20gPCBzdGFydENoKTtcXG4gICAgaWYgKHN0YXJ0c0JlZm9yZSB8fCBzcGFuLmZyb20gPT0gc3RhcnRDaCAmJiBtYXJrZXIudHlwZSA9PSBcXFwiYm9va21hcmtcXFwiICYmICghaXNJbnNlcnQgfHwgIXNwYW4ubWFya2VyLmluc2VydExlZnQpKSB7XFxuICAgICAgdmFyIGVuZHNBZnRlciA9IHNwYW4udG8gPT0gbnVsbCB8fCAobWFya2VyLmluY2x1c2l2ZVJpZ2h0ID8gc3Bhbi50byA+PSBzdGFydENoIDogc3Bhbi50byA+IHN0YXJ0Q2gpOyhudyB8fCAobncgPSBbXSkpLnB1c2gobmV3IE1hcmtlZFNwYW4obWFya2VyLCBzcGFuLmZyb20sIGVuZHNBZnRlciA/IG51bGwgOiBzcGFuLnRvKSk7XFxuICAgIH1cXG4gIH0gfVxcbiAgcmV0dXJuIG53XFxufVxcbmZ1bmN0aW9uIG1hcmtlZFNwYW5zQWZ0ZXIob2xkLCBlbmRDaCwgaXNJbnNlcnQpIHtcXG4gIHZhciBudztcXG4gIGlmIChvbGQpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBvbGQubGVuZ3RoOyArK2kpIHtcXG4gICAgdmFyIHNwYW4gPSBvbGRbaV0sIG1hcmtlciA9IHNwYW4ubWFya2VyO1xcbiAgICB2YXIgZW5kc0FmdGVyID0gc3Bhbi50byA9PSBudWxsIHx8IChtYXJrZXIuaW5jbHVzaXZlUmlnaHQgPyBzcGFuLnRvID49IGVuZENoIDogc3Bhbi50byA+IGVuZENoKTtcXG4gICAgaWYgKGVuZHNBZnRlciB8fCBzcGFuLmZyb20gPT0gZW5kQ2ggJiYgbWFya2VyLnR5cGUgPT0gXFxcImJvb2ttYXJrXFxcIiAmJiAoIWlzSW5zZXJ0IHx8IHNwYW4ubWFya2VyLmluc2VydExlZnQpKSB7XFxuICAgICAgdmFyIHN0YXJ0c0JlZm9yZSA9IHNwYW4uZnJvbSA9PSBudWxsIHx8IChtYXJrZXIuaW5jbHVzaXZlTGVmdCA/IHNwYW4uZnJvbSA8PSBlbmRDaCA6IHNwYW4uZnJvbSA8IGVuZENoKTsobncgfHwgKG53ID0gW10pKS5wdXNoKG5ldyBNYXJrZWRTcGFuKG1hcmtlciwgc3RhcnRzQmVmb3JlID8gbnVsbCA6IHNwYW4uZnJvbSAtIGVuZENoLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3Bhbi50byA9PSBudWxsID8gbnVsbCA6IHNwYW4udG8gLSBlbmRDaCkpO1xcbiAgICB9XFxuICB9IH1cXG4gIHJldHVybiBud1xcbn1cXG5cXG4vLyBHaXZlbiBhIGNoYW5nZSBvYmplY3QsIGNvbXB1dGUgdGhlIG5ldyBzZXQgb2YgbWFya2VyIHNwYW5zIHRoYXRcXG4vLyBjb3ZlciB0aGUgbGluZSBpbiB3aGljaCB0aGUgY2hhbmdlIHRvb2sgcGxhY2UuIFJlbW92ZXMgc3BhbnNcXG4vLyBlbnRpcmVseSB3aXRoaW4gdGhlIGNoYW5nZSwgcmVjb25uZWN0cyBzcGFucyBiZWxvbmdpbmcgdG8gdGhlXFxuLy8gc2FtZSBtYXJrZXIgdGhhdCBhcHBlYXIgb24gYm90aCBzaWRlcyBvZiB0aGUgY2hhbmdlLCBhbmQgY3V0cyBvZmZcXG4vLyBzcGFucyBwYXJ0aWFsbHkgd2l0aGluIHRoZSBjaGFuZ2UuIFJldHVybnMgYW4gYXJyYXkgb2Ygc3Bhblxcbi8vIGFycmF5cyB3aXRoIG9uZSBlbGVtZW50IGZvciBlYWNoIGxpbmUgaW4gKGFmdGVyKSB0aGUgY2hhbmdlLlxcbmZ1bmN0aW9uIHN0cmV0Y2hTcGFuc092ZXJDaGFuZ2UoZG9jLCBjaGFuZ2UpIHtcXG4gIGlmIChjaGFuZ2UuZnVsbCkgeyByZXR1cm4gbnVsbCB9XFxuICB2YXIgb2xkRmlyc3QgPSBpc0xpbmUoZG9jLCBjaGFuZ2UuZnJvbS5saW5lKSAmJiBnZXRMaW5lKGRvYywgY2hhbmdlLmZyb20ubGluZSkubWFya2VkU3BhbnM7XFxuICB2YXIgb2xkTGFzdCA9IGlzTGluZShkb2MsIGNoYW5nZS50by5saW5lKSAmJiBnZXRMaW5lKGRvYywgY2hhbmdlLnRvLmxpbmUpLm1hcmtlZFNwYW5zO1xcbiAgaWYgKCFvbGRGaXJzdCAmJiAhb2xkTGFzdCkgeyByZXR1cm4gbnVsbCB9XFxuXFxuICB2YXIgc3RhcnRDaCA9IGNoYW5nZS5mcm9tLmNoLCBlbmRDaCA9IGNoYW5nZS50by5jaCwgaXNJbnNlcnQgPSBjbXAoY2hhbmdlLmZyb20sIGNoYW5nZS50bykgPT0gMDtcXG4gIC8vIEdldCB0aGUgc3BhbnMgdGhhdCAnc3RpY2sgb3V0JyBvbiBib3RoIHNpZGVzXFxuICB2YXIgZmlyc3QgPSBtYXJrZWRTcGFuc0JlZm9yZShvbGRGaXJzdCwgc3RhcnRDaCwgaXNJbnNlcnQpO1xcbiAgdmFyIGxhc3QgPSBtYXJrZWRTcGFuc0FmdGVyKG9sZExhc3QsIGVuZENoLCBpc0luc2VydCk7XFxuXFxuICAvLyBOZXh0LCBtZXJnZSB0aG9zZSB0d28gZW5kc1xcbiAgdmFyIHNhbWVMaW5lID0gY2hhbmdlLnRleHQubGVuZ3RoID09IDEsIG9mZnNldCA9IGxzdChjaGFuZ2UudGV4dCkubGVuZ3RoICsgKHNhbWVMaW5lID8gc3RhcnRDaCA6IDApO1xcbiAgaWYgKGZpcnN0KSB7XFxuICAgIC8vIEZpeCB1cCAudG8gcHJvcGVydGllcyBvZiBmaXJzdFxcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZpcnN0Lmxlbmd0aDsgKytpKSB7XFxuICAgICAgdmFyIHNwYW4gPSBmaXJzdFtpXTtcXG4gICAgICBpZiAoc3Bhbi50byA9PSBudWxsKSB7XFxuICAgICAgICB2YXIgZm91bmQgPSBnZXRNYXJrZWRTcGFuRm9yKGxhc3QsIHNwYW4ubWFya2VyKTtcXG4gICAgICAgIGlmICghZm91bmQpIHsgc3Bhbi50byA9IHN0YXJ0Q2g7IH1cXG4gICAgICAgIGVsc2UgaWYgKHNhbWVMaW5lKSB7IHNwYW4udG8gPSBmb3VuZC50byA9PSBudWxsID8gbnVsbCA6IGZvdW5kLnRvICsgb2Zmc2V0OyB9XFxuICAgICAgfVxcbiAgICB9XFxuICB9XFxuICBpZiAobGFzdCkge1xcbiAgICAvLyBGaXggdXAgLmZyb20gaW4gbGFzdCAob3IgbW92ZSB0aGVtIGludG8gZmlyc3QgaW4gY2FzZSBvZiBzYW1lTGluZSlcXG4gICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgbGFzdC5sZW5ndGg7ICsraSQxKSB7XFxuICAgICAgdmFyIHNwYW4kMSA9IGxhc3RbaSQxXTtcXG4gICAgICBpZiAoc3BhbiQxLnRvICE9IG51bGwpIHsgc3BhbiQxLnRvICs9IG9mZnNldDsgfVxcbiAgICAgIGlmIChzcGFuJDEuZnJvbSA9PSBudWxsKSB7XFxuICAgICAgICB2YXIgZm91bmQkMSA9IGdldE1hcmtlZFNwYW5Gb3IoZmlyc3QsIHNwYW4kMS5tYXJrZXIpO1xcbiAgICAgICAgaWYgKCFmb3VuZCQxKSB7XFxuICAgICAgICAgIHNwYW4kMS5mcm9tID0gb2Zmc2V0O1xcbiAgICAgICAgICBpZiAoc2FtZUxpbmUpIHsgKGZpcnN0IHx8IChmaXJzdCA9IFtdKSkucHVzaChzcGFuJDEpOyB9XFxuICAgICAgICB9XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIHNwYW4kMS5mcm9tICs9IG9mZnNldDtcXG4gICAgICAgIGlmIChzYW1lTGluZSkgeyAoZmlyc3QgfHwgKGZpcnN0ID0gW10pKS5wdXNoKHNwYW4kMSk7IH1cXG4gICAgICB9XFxuICAgIH1cXG4gIH1cXG4gIC8vIE1ha2Ugc3VyZSB3ZSBkaWRuJ3QgY3JlYXRlIGFueSB6ZXJvLWxlbmd0aCBzcGFuc1xcbiAgaWYgKGZpcnN0KSB7IGZpcnN0ID0gY2xlYXJFbXB0eVNwYW5zKGZpcnN0KTsgfVxcbiAgaWYgKGxhc3QgJiYgbGFzdCAhPSBmaXJzdCkgeyBsYXN0ID0gY2xlYXJFbXB0eVNwYW5zKGxhc3QpOyB9XFxuXFxuICB2YXIgbmV3TWFya2VycyA9IFtmaXJzdF07XFxuICBpZiAoIXNhbWVMaW5lKSB7XFxuICAgIC8vIEZpbGwgZ2FwIHdpdGggd2hvbGUtbGluZS1zcGFuc1xcbiAgICB2YXIgZ2FwID0gY2hhbmdlLnRleHQubGVuZ3RoIC0gMiwgZ2FwTWFya2VycztcXG4gICAgaWYgKGdhcCA+IDAgJiYgZmlyc3QpXFxuICAgICAgeyBmb3IgKHZhciBpJDIgPSAwOyBpJDIgPCBmaXJzdC5sZW5ndGg7ICsraSQyKVxcbiAgICAgICAgeyBpZiAoZmlyc3RbaSQyXS50byA9PSBudWxsKVxcbiAgICAgICAgICB7IChnYXBNYXJrZXJzIHx8IChnYXBNYXJrZXJzID0gW10pKS5wdXNoKG5ldyBNYXJrZWRTcGFuKGZpcnN0W2kkMl0ubWFya2VyLCBudWxsLCBudWxsKSk7IH0gfSB9XFxuICAgIGZvciAodmFyIGkkMyA9IDA7IGkkMyA8IGdhcDsgKytpJDMpXFxuICAgICAgeyBuZXdNYXJrZXJzLnB1c2goZ2FwTWFya2Vycyk7IH1cXG4gICAgbmV3TWFya2Vycy5wdXNoKGxhc3QpO1xcbiAgfVxcbiAgcmV0dXJuIG5ld01hcmtlcnNcXG59XFxuXFxuLy8gUmVtb3ZlIHNwYW5zIHRoYXQgYXJlIGVtcHR5IGFuZCBkb24ndCBoYXZlIGEgY2xlYXJXaGVuRW1wdHlcXG4vLyBvcHRpb24gb2YgZmFsc2UuXFxuZnVuY3Rpb24gY2xlYXJFbXB0eVNwYW5zKHNwYW5zKSB7XFxuICBmb3IgKHZhciBpID0gMDsgaSA8IHNwYW5zLmxlbmd0aDsgKytpKSB7XFxuICAgIHZhciBzcGFuID0gc3BhbnNbaV07XFxuICAgIGlmIChzcGFuLmZyb20gIT0gbnVsbCAmJiBzcGFuLmZyb20gPT0gc3Bhbi50byAmJiBzcGFuLm1hcmtlci5jbGVhcldoZW5FbXB0eSAhPT0gZmFsc2UpXFxuICAgICAgeyBzcGFucy5zcGxpY2UoaS0tLCAxKTsgfVxcbiAgfVxcbiAgaWYgKCFzcGFucy5sZW5ndGgpIHsgcmV0dXJuIG51bGwgfVxcbiAgcmV0dXJuIHNwYW5zXFxufVxcblxcbi8vIFVzZWQgdG8gJ2NsaXAnIG91dCByZWFkT25seSByYW5nZXMgd2hlbiBtYWtpbmcgYSBjaGFuZ2UuXFxuZnVuY3Rpb24gcmVtb3ZlUmVhZE9ubHlSYW5nZXMoZG9jLCBmcm9tLCB0bykge1xcbiAgdmFyIG1hcmtlcnMgPSBudWxsO1xcbiAgZG9jLml0ZXIoZnJvbS5saW5lLCB0by5saW5lICsgMSwgZnVuY3Rpb24gKGxpbmUpIHtcXG4gICAgaWYgKGxpbmUubWFya2VkU3BhbnMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lLm1hcmtlZFNwYW5zLmxlbmd0aDsgKytpKSB7XFxuICAgICAgdmFyIG1hcmsgPSBsaW5lLm1hcmtlZFNwYW5zW2ldLm1hcmtlcjtcXG4gICAgICBpZiAobWFyay5yZWFkT25seSAmJiAoIW1hcmtlcnMgfHwgaW5kZXhPZihtYXJrZXJzLCBtYXJrKSA9PSAtMSkpXFxuICAgICAgICB7IChtYXJrZXJzIHx8IChtYXJrZXJzID0gW10pKS5wdXNoKG1hcmspOyB9XFxuICAgIH0gfVxcbiAgfSk7XFxuICBpZiAoIW1hcmtlcnMpIHsgcmV0dXJuIG51bGwgfVxcbiAgdmFyIHBhcnRzID0gW3tmcm9tOiBmcm9tLCB0bzogdG99XTtcXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbWFya2Vycy5sZW5ndGg7ICsraSkge1xcbiAgICB2YXIgbWsgPSBtYXJrZXJzW2ldLCBtID0gbWsuZmluZCgwKTtcXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBwYXJ0cy5sZW5ndGg7ICsraikge1xcbiAgICAgIHZhciBwID0gcGFydHNbal07XFxuICAgICAgaWYgKGNtcChwLnRvLCBtLmZyb20pIDwgMCB8fCBjbXAocC5mcm9tLCBtLnRvKSA+IDApIHsgY29udGludWUgfVxcbiAgICAgIHZhciBuZXdQYXJ0cyA9IFtqLCAxXSwgZGZyb20gPSBjbXAocC5mcm9tLCBtLmZyb20pLCBkdG8gPSBjbXAocC50bywgbS50byk7XFxuICAgICAgaWYgKGRmcm9tIDwgMCB8fCAhbWsuaW5jbHVzaXZlTGVmdCAmJiAhZGZyb20pXFxuICAgICAgICB7IG5ld1BhcnRzLnB1c2goe2Zyb206IHAuZnJvbSwgdG86IG0uZnJvbX0pOyB9XFxuICAgICAgaWYgKGR0byA+IDAgfHwgIW1rLmluY2x1c2l2ZVJpZ2h0ICYmICFkdG8pXFxuICAgICAgICB7IG5ld1BhcnRzLnB1c2goe2Zyb206IG0udG8sIHRvOiBwLnRvfSk7IH1cXG4gICAgICBwYXJ0cy5zcGxpY2UuYXBwbHkocGFydHMsIG5ld1BhcnRzKTtcXG4gICAgICBqICs9IG5ld1BhcnRzLmxlbmd0aCAtIDM7XFxuICAgIH1cXG4gIH1cXG4gIHJldHVybiBwYXJ0c1xcbn1cXG5cXG4vLyBDb25uZWN0IG9yIGRpc2Nvbm5lY3Qgc3BhbnMgZnJvbSBhIGxpbmUuXFxuZnVuY3Rpb24gZGV0YWNoTWFya2VkU3BhbnMobGluZSkge1xcbiAgdmFyIHNwYW5zID0gbGluZS5tYXJrZWRTcGFucztcXG4gIGlmICghc3BhbnMpIHsgcmV0dXJuIH1cXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3BhbnMubGVuZ3RoOyArK2kpXFxuICAgIHsgc3BhbnNbaV0ubWFya2VyLmRldGFjaExpbmUobGluZSk7IH1cXG4gIGxpbmUubWFya2VkU3BhbnMgPSBudWxsO1xcbn1cXG5mdW5jdGlvbiBhdHRhY2hNYXJrZWRTcGFucyhsaW5lLCBzcGFucykge1xcbiAgaWYgKCFzcGFucykgeyByZXR1cm4gfVxcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzcGFucy5sZW5ndGg7ICsraSlcXG4gICAgeyBzcGFuc1tpXS5tYXJrZXIuYXR0YWNoTGluZShsaW5lKTsgfVxcbiAgbGluZS5tYXJrZWRTcGFucyA9IHNwYW5zO1xcbn1cXG5cXG4vLyBIZWxwZXJzIHVzZWQgd2hlbiBjb21wdXRpbmcgd2hpY2ggb3ZlcmxhcHBpbmcgY29sbGFwc2VkIHNwYW5cXG4vLyBjb3VudHMgYXMgdGhlIGxhcmdlciBvbmUuXFxuZnVuY3Rpb24gZXh0cmFMZWZ0KG1hcmtlcikgeyByZXR1cm4gbWFya2VyLmluY2x1c2l2ZUxlZnQgPyAtMSA6IDAgfVxcbmZ1bmN0aW9uIGV4dHJhUmlnaHQobWFya2VyKSB7IHJldHVybiBtYXJrZXIuaW5jbHVzaXZlUmlnaHQgPyAxIDogMCB9XFxuXFxuLy8gUmV0dXJucyBhIG51bWJlciBpbmRpY2F0aW5nIHdoaWNoIG9mIHR3byBvdmVybGFwcGluZyBjb2xsYXBzZWRcXG4vLyBzcGFucyBpcyBsYXJnZXIgKGFuZCB0aHVzIGluY2x1ZGVzIHRoZSBvdGhlcikuIEZhbGxzIGJhY2sgdG9cXG4vLyBjb21wYXJpbmcgaWRzIHdoZW4gdGhlIHNwYW5zIGNvdmVyIGV4YWN0bHkgdGhlIHNhbWUgcmFuZ2UuXFxuZnVuY3Rpb24gY29tcGFyZUNvbGxhcHNlZE1hcmtlcnMoYSwgYikge1xcbiAgdmFyIGxlbkRpZmYgPSBhLmxpbmVzLmxlbmd0aCAtIGIubGluZXMubGVuZ3RoO1xcbiAgaWYgKGxlbkRpZmYgIT0gMCkgeyByZXR1cm4gbGVuRGlmZiB9XFxuICB2YXIgYVBvcyA9IGEuZmluZCgpLCBiUG9zID0gYi5maW5kKCk7XFxuICB2YXIgZnJvbUNtcCA9IGNtcChhUG9zLmZyb20sIGJQb3MuZnJvbSkgfHwgZXh0cmFMZWZ0KGEpIC0gZXh0cmFMZWZ0KGIpO1xcbiAgaWYgKGZyb21DbXApIHsgcmV0dXJuIC1mcm9tQ21wIH1cXG4gIHZhciB0b0NtcCA9IGNtcChhUG9zLnRvLCBiUG9zLnRvKSB8fCBleHRyYVJpZ2h0KGEpIC0gZXh0cmFSaWdodChiKTtcXG4gIGlmICh0b0NtcCkgeyByZXR1cm4gdG9DbXAgfVxcbiAgcmV0dXJuIGIuaWQgLSBhLmlkXFxufVxcblxcbi8vIEZpbmQgb3V0IHdoZXRoZXIgYSBsaW5lIGVuZHMgb3Igc3RhcnRzIGluIGEgY29sbGFwc2VkIHNwYW4uIElmXFxuLy8gc28sIHJldHVybiB0aGUgbWFya2VyIGZvciB0aGF0IHNwYW4uXFxuZnVuY3Rpb24gY29sbGFwc2VkU3BhbkF0U2lkZShsaW5lLCBzdGFydCkge1xcbiAgdmFyIHNwcyA9IHNhd0NvbGxhcHNlZFNwYW5zICYmIGxpbmUubWFya2VkU3BhbnMsIGZvdW5kO1xcbiAgaWYgKHNwcykgeyBmb3IgKHZhciBzcCA9ICh2b2lkIDApLCBpID0gMDsgaSA8IHNwcy5sZW5ndGg7ICsraSkge1xcbiAgICBzcCA9IHNwc1tpXTtcXG4gICAgaWYgKHNwLm1hcmtlci5jb2xsYXBzZWQgJiYgKHN0YXJ0ID8gc3AuZnJvbSA6IHNwLnRvKSA9PSBudWxsICYmXFxuICAgICAgICAoIWZvdW5kIHx8IGNvbXBhcmVDb2xsYXBzZWRNYXJrZXJzKGZvdW5kLCBzcC5tYXJrZXIpIDwgMCkpXFxuICAgICAgeyBmb3VuZCA9IHNwLm1hcmtlcjsgfVxcbiAgfSB9XFxuICByZXR1cm4gZm91bmRcXG59XFxuZnVuY3Rpb24gY29sbGFwc2VkU3BhbkF0U3RhcnQobGluZSkgeyByZXR1cm4gY29sbGFwc2VkU3BhbkF0U2lkZShsaW5lLCB0cnVlKSB9XFxuZnVuY3Rpb24gY29sbGFwc2VkU3BhbkF0RW5kKGxpbmUpIHsgcmV0dXJuIGNvbGxhcHNlZFNwYW5BdFNpZGUobGluZSwgZmFsc2UpIH1cXG5cXG4vLyBUZXN0IHdoZXRoZXIgdGhlcmUgZXhpc3RzIGEgY29sbGFwc2VkIHNwYW4gdGhhdCBwYXJ0aWFsbHlcXG4vLyBvdmVybGFwcyAoY292ZXJzIHRoZSBzdGFydCBvciBlbmQsIGJ1dCBub3QgYm90aCkgb2YgYSBuZXcgc3Bhbi5cXG4vLyBTdWNoIG92ZXJsYXAgaXMgbm90IGFsbG93ZWQuXFxuZnVuY3Rpb24gY29uZmxpY3RpbmdDb2xsYXBzZWRSYW5nZShkb2MsIGxpbmVObyQkMSwgZnJvbSwgdG8sIG1hcmtlcikge1xcbiAgdmFyIGxpbmUgPSBnZXRMaW5lKGRvYywgbGluZU5vJCQxKTtcXG4gIHZhciBzcHMgPSBzYXdDb2xsYXBzZWRTcGFucyAmJiBsaW5lLm1hcmtlZFNwYW5zO1xcbiAgaWYgKHNwcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHNwcy5sZW5ndGg7ICsraSkge1xcbiAgICB2YXIgc3AgPSBzcHNbaV07XFxuICAgIGlmICghc3AubWFya2VyLmNvbGxhcHNlZCkgeyBjb250aW51ZSB9XFxuICAgIHZhciBmb3VuZCA9IHNwLm1hcmtlci5maW5kKDApO1xcbiAgICB2YXIgZnJvbUNtcCA9IGNtcChmb3VuZC5mcm9tLCBmcm9tKSB8fCBleHRyYUxlZnQoc3AubWFya2VyKSAtIGV4dHJhTGVmdChtYXJrZXIpO1xcbiAgICB2YXIgdG9DbXAgPSBjbXAoZm91bmQudG8sIHRvKSB8fCBleHRyYVJpZ2h0KHNwLm1hcmtlcikgLSBleHRyYVJpZ2h0KG1hcmtlcik7XFxuICAgIGlmIChmcm9tQ21wID49IDAgJiYgdG9DbXAgPD0gMCB8fCBmcm9tQ21wIDw9IDAgJiYgdG9DbXAgPj0gMCkgeyBjb250aW51ZSB9XFxuICAgIGlmIChmcm9tQ21wIDw9IDAgJiYgKHNwLm1hcmtlci5pbmNsdXNpdmVSaWdodCAmJiBtYXJrZXIuaW5jbHVzaXZlTGVmdCA/IGNtcChmb3VuZC50bywgZnJvbSkgPj0gMCA6IGNtcChmb3VuZC50bywgZnJvbSkgPiAwKSB8fFxcbiAgICAgICAgZnJvbUNtcCA+PSAwICYmIChzcC5tYXJrZXIuaW5jbHVzaXZlUmlnaHQgJiYgbWFya2VyLmluY2x1c2l2ZUxlZnQgPyBjbXAoZm91bmQuZnJvbSwgdG8pIDw9IDAgOiBjbXAoZm91bmQuZnJvbSwgdG8pIDwgMCkpXFxuICAgICAgeyByZXR1cm4gdHJ1ZSB9XFxuICB9IH1cXG59XFxuXFxuLy8gQSB2aXN1YWwgbGluZSBpcyBhIGxpbmUgYXMgZHJhd24gb24gdGhlIHNjcmVlbi4gRm9sZGluZywgZm9yXFxuLy8gZXhhbXBsZSwgY2FuIGNhdXNlIG11bHRpcGxlIGxvZ2ljYWwgbGluZXMgdG8gYXBwZWFyIG9uIHRoZSBzYW1lXFxuLy8gdmlzdWFsIGxpbmUuIFRoaXMgZmluZHMgdGhlIHN0YXJ0IG9mIHRoZSB2aXN1YWwgbGluZSB0aGF0IHRoZVxcbi8vIGdpdmVuIGxpbmUgaXMgcGFydCBvZiAodXN1YWxseSB0aGF0IGlzIHRoZSBsaW5lIGl0c2VsZikuXFxuZnVuY3Rpb24gdmlzdWFsTGluZShsaW5lKSB7XFxuICB2YXIgbWVyZ2VkO1xcbiAgd2hpbGUgKG1lcmdlZCA9IGNvbGxhcHNlZFNwYW5BdFN0YXJ0KGxpbmUpKVxcbiAgICB7IGxpbmUgPSBtZXJnZWQuZmluZCgtMSwgdHJ1ZSkubGluZTsgfVxcbiAgcmV0dXJuIGxpbmVcXG59XFxuXFxuZnVuY3Rpb24gdmlzdWFsTGluZUVuZChsaW5lKSB7XFxuICB2YXIgbWVyZ2VkO1xcbiAgd2hpbGUgKG1lcmdlZCA9IGNvbGxhcHNlZFNwYW5BdEVuZChsaW5lKSlcXG4gICAgeyBsaW5lID0gbWVyZ2VkLmZpbmQoMSwgdHJ1ZSkubGluZTsgfVxcbiAgcmV0dXJuIGxpbmVcXG59XFxuXFxuLy8gUmV0dXJucyBhbiBhcnJheSBvZiBsb2dpY2FsIGxpbmVzIHRoYXQgY29udGludWUgdGhlIHZpc3VhbCBsaW5lXFxuLy8gc3RhcnRlZCBieSB0aGUgYXJndW1lbnQsIG9yIHVuZGVmaW5lZCBpZiB0aGVyZSBhcmUgbm8gc3VjaCBsaW5lcy5cXG5mdW5jdGlvbiB2aXN1YWxMaW5lQ29udGludWVkKGxpbmUpIHtcXG4gIHZhciBtZXJnZWQsIGxpbmVzO1xcbiAgd2hpbGUgKG1lcmdlZCA9IGNvbGxhcHNlZFNwYW5BdEVuZChsaW5lKSkge1xcbiAgICBsaW5lID0gbWVyZ2VkLmZpbmQoMSwgdHJ1ZSkubGluZVxcbiAgICA7KGxpbmVzIHx8IChsaW5lcyA9IFtdKSkucHVzaChsaW5lKTtcXG4gIH1cXG4gIHJldHVybiBsaW5lc1xcbn1cXG5cXG4vLyBHZXQgdGhlIGxpbmUgbnVtYmVyIG9mIHRoZSBzdGFydCBvZiB0aGUgdmlzdWFsIGxpbmUgdGhhdCB0aGVcXG4vLyBnaXZlbiBsaW5lIG51bWJlciBpcyBwYXJ0IG9mLlxcbmZ1bmN0aW9uIHZpc3VhbExpbmVObyhkb2MsIGxpbmVOKSB7XFxuICB2YXIgbGluZSA9IGdldExpbmUoZG9jLCBsaW5lTiksIHZpcyA9IHZpc3VhbExpbmUobGluZSk7XFxuICBpZiAobGluZSA9PSB2aXMpIHsgcmV0dXJuIGxpbmVOIH1cXG4gIHJldHVybiBsaW5lTm8odmlzKVxcbn1cXG5cXG4vLyBHZXQgdGhlIGxpbmUgbnVtYmVyIG9mIHRoZSBzdGFydCBvZiB0aGUgbmV4dCB2aXN1YWwgbGluZSBhZnRlclxcbi8vIHRoZSBnaXZlbiBsaW5lLlxcbmZ1bmN0aW9uIHZpc3VhbExpbmVFbmRObyhkb2MsIGxpbmVOKSB7XFxuICBpZiAobGluZU4gPiBkb2MubGFzdExpbmUoKSkgeyByZXR1cm4gbGluZU4gfVxcbiAgdmFyIGxpbmUgPSBnZXRMaW5lKGRvYywgbGluZU4pLCBtZXJnZWQ7XFxuICBpZiAoIWxpbmVJc0hpZGRlbihkb2MsIGxpbmUpKSB7IHJldHVybiBsaW5lTiB9XFxuICB3aGlsZSAobWVyZ2VkID0gY29sbGFwc2VkU3BhbkF0RW5kKGxpbmUpKVxcbiAgICB7IGxpbmUgPSBtZXJnZWQuZmluZCgxLCB0cnVlKS5saW5lOyB9XFxuICByZXR1cm4gbGluZU5vKGxpbmUpICsgMVxcbn1cXG5cXG4vLyBDb21wdXRlIHdoZXRoZXIgYSBsaW5lIGlzIGhpZGRlbi4gTGluZXMgY291bnQgYXMgaGlkZGVuIHdoZW4gdGhleVxcbi8vIGFyZSBwYXJ0IG9mIGEgdmlzdWFsIGxpbmUgdGhhdCBzdGFydHMgd2l0aCBhbm90aGVyIGxpbmUsIG9yIHdoZW5cXG4vLyB0aGV5IGFyZSBlbnRpcmVseSBjb3ZlcmVkIGJ5IGNvbGxhcHNlZCwgbm9uLXdpZGdldCBzcGFuLlxcbmZ1bmN0aW9uIGxpbmVJc0hpZGRlbihkb2MsIGxpbmUpIHtcXG4gIHZhciBzcHMgPSBzYXdDb2xsYXBzZWRTcGFucyAmJiBsaW5lLm1hcmtlZFNwYW5zO1xcbiAgaWYgKHNwcykgeyBmb3IgKHZhciBzcCA9ICh2b2lkIDApLCBpID0gMDsgaSA8IHNwcy5sZW5ndGg7ICsraSkge1xcbiAgICBzcCA9IHNwc1tpXTtcXG4gICAgaWYgKCFzcC5tYXJrZXIuY29sbGFwc2VkKSB7IGNvbnRpbnVlIH1cXG4gICAgaWYgKHNwLmZyb20gPT0gbnVsbCkgeyByZXR1cm4gdHJ1ZSB9XFxuICAgIGlmIChzcC5tYXJrZXIud2lkZ2V0Tm9kZSkgeyBjb250aW51ZSB9XFxuICAgIGlmIChzcC5mcm9tID09IDAgJiYgc3AubWFya2VyLmluY2x1c2l2ZUxlZnQgJiYgbGluZUlzSGlkZGVuSW5uZXIoZG9jLCBsaW5lLCBzcCkpXFxuICAgICAgeyByZXR1cm4gdHJ1ZSB9XFxuICB9IH1cXG59XFxuZnVuY3Rpb24gbGluZUlzSGlkZGVuSW5uZXIoZG9jLCBsaW5lLCBzcGFuKSB7XFxuICBpZiAoc3Bhbi50byA9PSBudWxsKSB7XFxuICAgIHZhciBlbmQgPSBzcGFuLm1hcmtlci5maW5kKDEsIHRydWUpO1xcbiAgICByZXR1cm4gbGluZUlzSGlkZGVuSW5uZXIoZG9jLCBlbmQubGluZSwgZ2V0TWFya2VkU3BhbkZvcihlbmQubGluZS5tYXJrZWRTcGFucywgc3Bhbi5tYXJrZXIpKVxcbiAgfVxcbiAgaWYgKHNwYW4ubWFya2VyLmluY2x1c2l2ZVJpZ2h0ICYmIHNwYW4udG8gPT0gbGluZS50ZXh0Lmxlbmd0aClcXG4gICAgeyByZXR1cm4gdHJ1ZSB9XFxuICBmb3IgKHZhciBzcCA9ICh2b2lkIDApLCBpID0gMDsgaSA8IGxpbmUubWFya2VkU3BhbnMubGVuZ3RoOyArK2kpIHtcXG4gICAgc3AgPSBsaW5lLm1hcmtlZFNwYW5zW2ldO1xcbiAgICBpZiAoc3AubWFya2VyLmNvbGxhcHNlZCAmJiAhc3AubWFya2VyLndpZGdldE5vZGUgJiYgc3AuZnJvbSA9PSBzcGFuLnRvICYmXFxuICAgICAgICAoc3AudG8gPT0gbnVsbCB8fCBzcC50byAhPSBzcGFuLmZyb20pICYmXFxuICAgICAgICAoc3AubWFya2VyLmluY2x1c2l2ZUxlZnQgfHwgc3Bhbi5tYXJrZXIuaW5jbHVzaXZlUmlnaHQpICYmXFxuICAgICAgICBsaW5lSXNIaWRkZW5Jbm5lcihkb2MsIGxpbmUsIHNwKSkgeyByZXR1cm4gdHJ1ZSB9XFxuICB9XFxufVxcblxcbi8vIEZpbmQgdGhlIGhlaWdodCBhYm92ZSB0aGUgZ2l2ZW4gbGluZS5cXG5mdW5jdGlvbiBoZWlnaHRBdExpbmUobGluZU9iaikge1xcbiAgbGluZU9iaiA9IHZpc3VhbExpbmUobGluZU9iaik7XFxuXFxuICB2YXIgaCA9IDAsIGNodW5rID0gbGluZU9iai5wYXJlbnQ7XFxuICBmb3IgKHZhciBpID0gMDsgaSA8IGNodW5rLmxpbmVzLmxlbmd0aDsgKytpKSB7XFxuICAgIHZhciBsaW5lID0gY2h1bmsubGluZXNbaV07XFxuICAgIGlmIChsaW5lID09IGxpbmVPYmopIHsgYnJlYWsgfVxcbiAgICBlbHNlIHsgaCArPSBsaW5lLmhlaWdodDsgfVxcbiAgfVxcbiAgZm9yICh2YXIgcCA9IGNodW5rLnBhcmVudDsgcDsgY2h1bmsgPSBwLCBwID0gY2h1bmsucGFyZW50KSB7XFxuICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IHAuY2hpbGRyZW4ubGVuZ3RoOyArK2kkMSkge1xcbiAgICAgIHZhciBjdXIgPSBwLmNoaWxkcmVuW2kkMV07XFxuICAgICAgaWYgKGN1ciA9PSBjaHVuaykgeyBicmVhayB9XFxuICAgICAgZWxzZSB7IGggKz0gY3VyLmhlaWdodDsgfVxcbiAgICB9XFxuICB9XFxuICByZXR1cm4gaFxcbn1cXG5cXG4vLyBDb21wdXRlIHRoZSBjaGFyYWN0ZXIgbGVuZ3RoIG9mIGEgbGluZSwgdGFraW5nIGludG8gYWNjb3VudFxcbi8vIGNvbGxhcHNlZCByYW5nZXMgKHNlZSBtYXJrVGV4dCkgdGhhdCBtaWdodCBoaWRlIHBhcnRzLCBhbmQgam9pblxcbi8vIG90aGVyIGxpbmVzIG9udG8gaXQuXFxuZnVuY3Rpb24gbGluZUxlbmd0aChsaW5lKSB7XFxuICBpZiAobGluZS5oZWlnaHQgPT0gMCkgeyByZXR1cm4gMCB9XFxuICB2YXIgbGVuID0gbGluZS50ZXh0Lmxlbmd0aCwgbWVyZ2VkLCBjdXIgPSBsaW5lO1xcbiAgd2hpbGUgKG1lcmdlZCA9IGNvbGxhcHNlZFNwYW5BdFN0YXJ0KGN1cikpIHtcXG4gICAgdmFyIGZvdW5kID0gbWVyZ2VkLmZpbmQoMCwgdHJ1ZSk7XFxuICAgIGN1ciA9IGZvdW5kLmZyb20ubGluZTtcXG4gICAgbGVuICs9IGZvdW5kLmZyb20uY2ggLSBmb3VuZC50by5jaDtcXG4gIH1cXG4gIGN1ciA9IGxpbmU7XFxuICB3aGlsZSAobWVyZ2VkID0gY29sbGFwc2VkU3BhbkF0RW5kKGN1cikpIHtcXG4gICAgdmFyIGZvdW5kJDEgPSBtZXJnZWQuZmluZCgwLCB0cnVlKTtcXG4gICAgbGVuIC09IGN1ci50ZXh0Lmxlbmd0aCAtIGZvdW5kJDEuZnJvbS5jaDtcXG4gICAgY3VyID0gZm91bmQkMS50by5saW5lO1xcbiAgICBsZW4gKz0gY3VyLnRleHQubGVuZ3RoIC0gZm91bmQkMS50by5jaDtcXG4gIH1cXG4gIHJldHVybiBsZW5cXG59XFxuXFxuLy8gRmluZCB0aGUgbG9uZ2VzdCBsaW5lIGluIHRoZSBkb2N1bWVudC5cXG5mdW5jdGlvbiBmaW5kTWF4TGluZShjbSkge1xcbiAgdmFyIGQgPSBjbS5kaXNwbGF5LCBkb2MgPSBjbS5kb2M7XFxuICBkLm1heExpbmUgPSBnZXRMaW5lKGRvYywgZG9jLmZpcnN0KTtcXG4gIGQubWF4TGluZUxlbmd0aCA9IGxpbmVMZW5ndGgoZC5tYXhMaW5lKTtcXG4gIGQubWF4TGluZUNoYW5nZWQgPSB0cnVlO1xcbiAgZG9jLml0ZXIoZnVuY3Rpb24gKGxpbmUpIHtcXG4gICAgdmFyIGxlbiA9IGxpbmVMZW5ndGgobGluZSk7XFxuICAgIGlmIChsZW4gPiBkLm1heExpbmVMZW5ndGgpIHtcXG4gICAgICBkLm1heExpbmVMZW5ndGggPSBsZW47XFxuICAgICAgZC5tYXhMaW5lID0gbGluZTtcXG4gICAgfVxcbiAgfSk7XFxufVxcblxcbi8vIEJJREkgSEVMUEVSU1xcblxcbmZ1bmN0aW9uIGl0ZXJhdGVCaWRpU2VjdGlvbnMob3JkZXIsIGZyb20sIHRvLCBmKSB7XFxuICBpZiAoIW9yZGVyKSB7IHJldHVybiBmKGZyb20sIHRvLCBcXFwibHRyXFxcIikgfVxcbiAgdmFyIGZvdW5kID0gZmFsc2U7XFxuICBmb3IgKHZhciBpID0gMDsgaSA8IG9yZGVyLmxlbmd0aDsgKytpKSB7XFxuICAgIHZhciBwYXJ0ID0gb3JkZXJbaV07XFxuICAgIGlmIChwYXJ0LmZyb20gPCB0byAmJiBwYXJ0LnRvID4gZnJvbSB8fCBmcm9tID09IHRvICYmIHBhcnQudG8gPT0gZnJvbSkge1xcbiAgICAgIGYoTWF0aC5tYXgocGFydC5mcm9tLCBmcm9tKSwgTWF0aC5taW4ocGFydC50bywgdG8pLCBwYXJ0LmxldmVsID09IDEgPyBcXFwicnRsXFxcIiA6IFxcXCJsdHJcXFwiKTtcXG4gICAgICBmb3VuZCA9IHRydWU7XFxuICAgIH1cXG4gIH1cXG4gIGlmICghZm91bmQpIHsgZihmcm9tLCB0bywgXFxcImx0clxcXCIpOyB9XFxufVxcblxcbnZhciBiaWRpT3RoZXIgPSBudWxsO1xcbmZ1bmN0aW9uIGdldEJpZGlQYXJ0QXQob3JkZXIsIGNoLCBzdGlja3kpIHtcXG4gIHZhciBmb3VuZDtcXG4gIGJpZGlPdGhlciA9IG51bGw7XFxuICBmb3IgKHZhciBpID0gMDsgaSA8IG9yZGVyLmxlbmd0aDsgKytpKSB7XFxuICAgIHZhciBjdXIgPSBvcmRlcltpXTtcXG4gICAgaWYgKGN1ci5mcm9tIDwgY2ggJiYgY3VyLnRvID4gY2gpIHsgcmV0dXJuIGkgfVxcbiAgICBpZiAoY3VyLnRvID09IGNoKSB7XFxuICAgICAgaWYgKGN1ci5mcm9tICE9IGN1ci50byAmJiBzdGlja3kgPT0gXFxcImJlZm9yZVxcXCIpIHsgZm91bmQgPSBpOyB9XFxuICAgICAgZWxzZSB7IGJpZGlPdGhlciA9IGk7IH1cXG4gICAgfVxcbiAgICBpZiAoY3VyLmZyb20gPT0gY2gpIHtcXG4gICAgICBpZiAoY3VyLmZyb20gIT0gY3VyLnRvICYmIHN0aWNreSAhPSBcXFwiYmVmb3JlXFxcIikgeyBmb3VuZCA9IGk7IH1cXG4gICAgICBlbHNlIHsgYmlkaU90aGVyID0gaTsgfVxcbiAgICB9XFxuICB9XFxuICByZXR1cm4gZm91bmQgIT0gbnVsbCA/IGZvdW5kIDogYmlkaU90aGVyXFxufVxcblxcbi8vIEJpZGlyZWN0aW9uYWwgb3JkZXJpbmcgYWxnb3JpdGhtXFxuLy8gU2VlIGh0dHA6Ly91bmljb2RlLm9yZy9yZXBvcnRzL3RyOS90cjktMTMuaHRtbCBmb3IgdGhlIGFsZ29yaXRobVxcbi8vIHRoYXQgdGhpcyAocGFydGlhbGx5KSBpbXBsZW1lbnRzLlxcblxcbi8vIE9uZS1jaGFyIGNvZGVzIHVzZWQgZm9yIGNoYXJhY3RlciB0eXBlczpcXG4vLyBMIChMKTogICBMZWZ0LXRvLVJpZ2h0XFxuLy8gUiAoUik6ICAgUmlnaHQtdG8tTGVmdFxcbi8vIHIgKEFMKTogIFJpZ2h0LXRvLUxlZnQgQXJhYmljXFxuLy8gMSAoRU4pOiAgRXVyb3BlYW4gTnVtYmVyXFxuLy8gKyAoRVMpOiAgRXVyb3BlYW4gTnVtYmVyIFNlcGFyYXRvclxcbi8vICUgKEVUKTogIEV1cm9wZWFuIE51bWJlciBUZXJtaW5hdG9yXFxuLy8gbiAoQU4pOiAgQXJhYmljIE51bWJlclxcbi8vICwgKENTKTogIENvbW1vbiBOdW1iZXIgU2VwYXJhdG9yXFxuLy8gbSAoTlNNKTogTm9uLVNwYWNpbmcgTWFya1xcbi8vIGIgKEJOKTogIEJvdW5kYXJ5IE5ldXRyYWxcXG4vLyBzIChCKTogICBQYXJhZ3JhcGggU2VwYXJhdG9yXFxuLy8gdCAoUyk6ICAgU2VnbWVudCBTZXBhcmF0b3JcXG4vLyB3IChXUyk6ICBXaGl0ZXNwYWNlXFxuLy8gTiAoT04pOiAgT3RoZXIgTmV1dHJhbHNcXG5cXG4vLyBSZXR1cm5zIG51bGwgaWYgY2hhcmFjdGVycyBhcmUgb3JkZXJlZCBhcyB0aGV5IGFwcGVhclxcbi8vIChsZWZ0LXRvLXJpZ2h0KSwgb3IgYW4gYXJyYXkgb2Ygc2VjdGlvbnMgKHtmcm9tLCB0bywgbGV2ZWx9XFxuLy8gb2JqZWN0cykgaW4gdGhlIG9yZGVyIGluIHdoaWNoIHRoZXkgb2NjdXIgdmlzdWFsbHkuXFxudmFyIGJpZGlPcmRlcmluZyA9IChmdW5jdGlvbigpIHtcXG4gIC8vIENoYXJhY3RlciB0eXBlcyBmb3IgY29kZXBvaW50cyAwIHRvIDB4ZmZcXG4gIHZhciBsb3dUeXBlcyA9IFxcXCJiYmJiYmJiYmJ0c3R3c2JiYmJiYmJiYmJiYmJic3NzdHdOTiUlJU5OTk5OTixOLE4xMTExMTExMTExTk5OTk5OTkxMTExMTExMTExMTExMTExMTExMTExMTExMTk5OTk5OTExMTExMTExMTExMTExMTExMTExMTExMTExOTk5OYmJiYmJic2JiYmJiYmJiYmJiYmJiYmJiYmJiYmJiYmJiLE4lJSUlTk5OTkxOTk5OTiUlMTFOTE5OTjFMTk5OTk5MTExMTExMTExMTExMTExMTExMTExMTE5MTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTlxcXCI7XFxuICAvLyBDaGFyYWN0ZXIgdHlwZXMgZm9yIGNvZGVwb2ludHMgMHg2MDAgdG8gMHg2ZjlcXG4gIHZhciBhcmFiaWNUeXBlcyA9IFxcXCJubm5ubm5OTnIlJXIsck5ObW1tbW1tbW1tbW1ycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJtbW1tbW1tbW1tbW1tbW1tbW1tbW1ubm5ubm5ubm5uJW5ucnJybXJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJybW1tbW1tbW5ObW1tbW1tcnJtbU5tbW1tcnIxMTExMTExMTExXFxcIjtcXG4gIGZ1bmN0aW9uIGNoYXJUeXBlKGNvZGUpIHtcXG4gICAgaWYgKGNvZGUgPD0gMHhmNykgeyByZXR1cm4gbG93VHlwZXMuY2hhckF0KGNvZGUpIH1cXG4gICAgZWxzZSBpZiAoMHg1OTAgPD0gY29kZSAmJiBjb2RlIDw9IDB4NWY0KSB7IHJldHVybiBcXFwiUlxcXCIgfVxcbiAgICBlbHNlIGlmICgweDYwMCA8PSBjb2RlICYmIGNvZGUgPD0gMHg2ZjkpIHsgcmV0dXJuIGFyYWJpY1R5cGVzLmNoYXJBdChjb2RlIC0gMHg2MDApIH1cXG4gICAgZWxzZSBpZiAoMHg2ZWUgPD0gY29kZSAmJiBjb2RlIDw9IDB4OGFjKSB7IHJldHVybiBcXFwiclxcXCIgfVxcbiAgICBlbHNlIGlmICgweDIwMDAgPD0gY29kZSAmJiBjb2RlIDw9IDB4MjAwYikgeyByZXR1cm4gXFxcIndcXFwiIH1cXG4gICAgZWxzZSBpZiAoY29kZSA9PSAweDIwMGMpIHsgcmV0dXJuIFxcXCJiXFxcIiB9XFxuICAgIGVsc2UgeyByZXR1cm4gXFxcIkxcXFwiIH1cXG4gIH1cXG5cXG4gIHZhciBiaWRpUkUgPSAvW1xcXFx1MDU5MC1cXFxcdTA1ZjRcXFxcdTA2MDAtXFxcXHUwNmZmXFxcXHUwNzAwLVxcXFx1MDhhY10vO1xcbiAgdmFyIGlzTmV1dHJhbCA9IC9bc3R3Tl0vLCBpc1N0cm9uZyA9IC9bTFJyXS8sIGNvdW50c0FzTGVmdCA9IC9bTGIxbl0vLCBjb3VudHNBc051bSA9IC9bMW5dLztcXG5cXG4gIGZ1bmN0aW9uIEJpZGlTcGFuKGxldmVsLCBmcm9tLCB0bykge1xcbiAgICB0aGlzLmxldmVsID0gbGV2ZWw7XFxuICAgIHRoaXMuZnJvbSA9IGZyb207IHRoaXMudG8gPSB0bztcXG4gIH1cXG5cXG4gIHJldHVybiBmdW5jdGlvbihzdHIsIGRpcmVjdGlvbikge1xcbiAgICB2YXIgb3V0ZXJUeXBlID0gZGlyZWN0aW9uID09IFxcXCJsdHJcXFwiID8gXFxcIkxcXFwiIDogXFxcIlJcXFwiO1xcblxcbiAgICBpZiAoc3RyLmxlbmd0aCA9PSAwIHx8IGRpcmVjdGlvbiA9PSBcXFwibHRyXFxcIiAmJiAhYmlkaVJFLnRlc3Qoc3RyKSkgeyByZXR1cm4gZmFsc2UgfVxcbiAgICB2YXIgbGVuID0gc3RyLmxlbmd0aCwgdHlwZXMgPSBbXTtcXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSlcXG4gICAgICB7IHR5cGVzLnB1c2goY2hhclR5cGUoc3RyLmNoYXJDb2RlQXQoaSkpKTsgfVxcblxcbiAgICAvLyBXMS4gRXhhbWluZSBlYWNoIG5vbi1zcGFjaW5nIG1hcmsgKE5TTSkgaW4gdGhlIGxldmVsIHJ1biwgYW5kXFxuICAgIC8vIGNoYW5nZSB0aGUgdHlwZSBvZiB0aGUgTlNNIHRvIHRoZSB0eXBlIG9mIHRoZSBwcmV2aW91c1xcbiAgICAvLyBjaGFyYWN0ZXIuIElmIHRoZSBOU00gaXMgYXQgdGhlIHN0YXJ0IG9mIHRoZSBsZXZlbCBydW4sIGl0IHdpbGxcXG4gICAgLy8gZ2V0IHRoZSB0eXBlIG9mIHNvci5cXG4gICAgZm9yICh2YXIgaSQxID0gMCwgcHJldiA9IG91dGVyVHlwZTsgaSQxIDwgbGVuOyArK2kkMSkge1xcbiAgICAgIHZhciB0eXBlID0gdHlwZXNbaSQxXTtcXG4gICAgICBpZiAodHlwZSA9PSBcXFwibVxcXCIpIHsgdHlwZXNbaSQxXSA9IHByZXY7IH1cXG4gICAgICBlbHNlIHsgcHJldiA9IHR5cGU7IH1cXG4gICAgfVxcblxcbiAgICAvLyBXMi4gU2VhcmNoIGJhY2t3YXJkcyBmcm9tIGVhY2ggaW5zdGFuY2Ugb2YgYSBFdXJvcGVhbiBudW1iZXJcXG4gICAgLy8gdW50aWwgdGhlIGZpcnN0IHN0cm9uZyB0eXBlIChSLCBMLCBBTCwgb3Igc29yKSBpcyBmb3VuZC4gSWYgYW5cXG4gICAgLy8gQUwgaXMgZm91bmQsIGNoYW5nZSB0aGUgdHlwZSBvZiB0aGUgRXVyb3BlYW4gbnVtYmVyIHRvIEFyYWJpY1xcbiAgICAvLyBudW1iZXIuXFxuICAgIC8vIFczLiBDaGFuZ2UgYWxsIEFMcyB0byBSLlxcbiAgICBmb3IgKHZhciBpJDIgPSAwLCBjdXIgPSBvdXRlclR5cGU7IGkkMiA8IGxlbjsgKytpJDIpIHtcXG4gICAgICB2YXIgdHlwZSQxID0gdHlwZXNbaSQyXTtcXG4gICAgICBpZiAodHlwZSQxID09IFxcXCIxXFxcIiAmJiBjdXIgPT0gXFxcInJcXFwiKSB7IHR5cGVzW2kkMl0gPSBcXFwiblxcXCI7IH1cXG4gICAgICBlbHNlIGlmIChpc1N0cm9uZy50ZXN0KHR5cGUkMSkpIHsgY3VyID0gdHlwZSQxOyBpZiAodHlwZSQxID09IFxcXCJyXFxcIikgeyB0eXBlc1tpJDJdID0gXFxcIlJcXFwiOyB9IH1cXG4gICAgfVxcblxcbiAgICAvLyBXNC4gQSBzaW5nbGUgRXVyb3BlYW4gc2VwYXJhdG9yIGJldHdlZW4gdHdvIEV1cm9wZWFuIG51bWJlcnNcXG4gICAgLy8gY2hhbmdlcyB0byBhIEV1cm9wZWFuIG51bWJlci4gQSBzaW5nbGUgY29tbW9uIHNlcGFyYXRvciBiZXR3ZWVuXFxuICAgIC8vIHR3byBudW1iZXJzIG9mIHRoZSBzYW1lIHR5cGUgY2hhbmdlcyB0byB0aGF0IHR5cGUuXFxuICAgIGZvciAodmFyIGkkMyA9IDEsIHByZXYkMSA9IHR5cGVzWzBdOyBpJDMgPCBsZW4gLSAxOyArK2kkMykge1xcbiAgICAgIHZhciB0eXBlJDIgPSB0eXBlc1tpJDNdO1xcbiAgICAgIGlmICh0eXBlJDIgPT0gXFxcIitcXFwiICYmIHByZXYkMSA9PSBcXFwiMVxcXCIgJiYgdHlwZXNbaSQzKzFdID09IFxcXCIxXFxcIikgeyB0eXBlc1tpJDNdID0gXFxcIjFcXFwiOyB9XFxuICAgICAgZWxzZSBpZiAodHlwZSQyID09IFxcXCIsXFxcIiAmJiBwcmV2JDEgPT0gdHlwZXNbaSQzKzFdICYmXFxuICAgICAgICAgICAgICAgKHByZXYkMSA9PSBcXFwiMVxcXCIgfHwgcHJldiQxID09IFxcXCJuXFxcIikpIHsgdHlwZXNbaSQzXSA9IHByZXYkMTsgfVxcbiAgICAgIHByZXYkMSA9IHR5cGUkMjtcXG4gICAgfVxcblxcbiAgICAvLyBXNS4gQSBzZXF1ZW5jZSBvZiBFdXJvcGVhbiB0ZXJtaW5hdG9ycyBhZGphY2VudCB0byBFdXJvcGVhblxcbiAgICAvLyBudW1iZXJzIGNoYW5nZXMgdG8gYWxsIEV1cm9wZWFuIG51bWJlcnMuXFxuICAgIC8vIFc2LiBPdGhlcndpc2UsIHNlcGFyYXRvcnMgYW5kIHRlcm1pbmF0b3JzIGNoYW5nZSB0byBPdGhlclxcbiAgICAvLyBOZXV0cmFsLlxcbiAgICBmb3IgKHZhciBpJDQgPSAwOyBpJDQgPCBsZW47ICsraSQ0KSB7XFxuICAgICAgdmFyIHR5cGUkMyA9IHR5cGVzW2kkNF07XFxuICAgICAgaWYgKHR5cGUkMyA9PSBcXFwiLFxcXCIpIHsgdHlwZXNbaSQ0XSA9IFxcXCJOXFxcIjsgfVxcbiAgICAgIGVsc2UgaWYgKHR5cGUkMyA9PSBcXFwiJVxcXCIpIHtcXG4gICAgICAgIHZhciBlbmQgPSAodm9pZCAwKTtcXG4gICAgICAgIGZvciAoZW5kID0gaSQ0ICsgMTsgZW5kIDwgbGVuICYmIHR5cGVzW2VuZF0gPT0gXFxcIiVcXFwiOyArK2VuZCkge31cXG4gICAgICAgIHZhciByZXBsYWNlID0gKGkkNCAmJiB0eXBlc1tpJDQtMV0gPT0gXFxcIiFcXFwiKSB8fCAoZW5kIDwgbGVuICYmIHR5cGVzW2VuZF0gPT0gXFxcIjFcXFwiKSA/IFxcXCIxXFxcIiA6IFxcXCJOXFxcIjtcXG4gICAgICAgIGZvciAodmFyIGogPSBpJDQ7IGogPCBlbmQ7ICsraikgeyB0eXBlc1tqXSA9IHJlcGxhY2U7IH1cXG4gICAgICAgIGkkNCA9IGVuZCAtIDE7XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIC8vIFc3LiBTZWFyY2ggYmFja3dhcmRzIGZyb20gZWFjaCBpbnN0YW5jZSBvZiBhIEV1cm9wZWFuIG51bWJlclxcbiAgICAvLyB1bnRpbCB0aGUgZmlyc3Qgc3Ryb25nIHR5cGUgKFIsIEwsIG9yIHNvcikgaXMgZm91bmQuIElmIGFuIEwgaXNcXG4gICAgLy8gZm91bmQsIHRoZW4gY2hhbmdlIHRoZSB0eXBlIG9mIHRoZSBFdXJvcGVhbiBudW1iZXIgdG8gTC5cXG4gICAgZm9yICh2YXIgaSQ1ID0gMCwgY3VyJDEgPSBvdXRlclR5cGU7IGkkNSA8IGxlbjsgKytpJDUpIHtcXG4gICAgICB2YXIgdHlwZSQ0ID0gdHlwZXNbaSQ1XTtcXG4gICAgICBpZiAoY3VyJDEgPT0gXFxcIkxcXFwiICYmIHR5cGUkNCA9PSBcXFwiMVxcXCIpIHsgdHlwZXNbaSQ1XSA9IFxcXCJMXFxcIjsgfVxcbiAgICAgIGVsc2UgaWYgKGlzU3Ryb25nLnRlc3QodHlwZSQ0KSkgeyBjdXIkMSA9IHR5cGUkNDsgfVxcbiAgICB9XFxuXFxuICAgIC8vIE4xLiBBIHNlcXVlbmNlIG9mIG5ldXRyYWxzIHRha2VzIHRoZSBkaXJlY3Rpb24gb2YgdGhlXFxuICAgIC8vIHN1cnJvdW5kaW5nIHN0cm9uZyB0ZXh0IGlmIHRoZSB0ZXh0IG9uIGJvdGggc2lkZXMgaGFzIHRoZSBzYW1lXFxuICAgIC8vIGRpcmVjdGlvbi4gRXVyb3BlYW4gYW5kIEFyYWJpYyBudW1iZXJzIGFjdCBhcyBpZiB0aGV5IHdlcmUgUiBpblxcbiAgICAvLyB0ZXJtcyBvZiB0aGVpciBpbmZsdWVuY2Ugb24gbmV1dHJhbHMuIFN0YXJ0LW9mLWxldmVsLXJ1biAoc29yKVxcbiAgICAvLyBhbmQgZW5kLW9mLWxldmVsLXJ1biAoZW9yKSBhcmUgdXNlZCBhdCBsZXZlbCBydW4gYm91bmRhcmllcy5cXG4gICAgLy8gTjIuIEFueSByZW1haW5pbmcgbmV1dHJhbHMgdGFrZSB0aGUgZW1iZWRkaW5nIGRpcmVjdGlvbi5cXG4gICAgZm9yICh2YXIgaSQ2ID0gMDsgaSQ2IDwgbGVuOyArK2kkNikge1xcbiAgICAgIGlmIChpc05ldXRyYWwudGVzdCh0eXBlc1tpJDZdKSkge1xcbiAgICAgICAgdmFyIGVuZCQxID0gKHZvaWQgMCk7XFxuICAgICAgICBmb3IgKGVuZCQxID0gaSQ2ICsgMTsgZW5kJDEgPCBsZW4gJiYgaXNOZXV0cmFsLnRlc3QodHlwZXNbZW5kJDFdKTsgKytlbmQkMSkge31cXG4gICAgICAgIHZhciBiZWZvcmUgPSAoaSQ2ID8gdHlwZXNbaSQ2LTFdIDogb3V0ZXJUeXBlKSA9PSBcXFwiTFxcXCI7XFxuICAgICAgICB2YXIgYWZ0ZXIgPSAoZW5kJDEgPCBsZW4gPyB0eXBlc1tlbmQkMV0gOiBvdXRlclR5cGUpID09IFxcXCJMXFxcIjtcXG4gICAgICAgIHZhciByZXBsYWNlJDEgPSBiZWZvcmUgPT0gYWZ0ZXIgPyAoYmVmb3JlID8gXFxcIkxcXFwiIDogXFxcIlJcXFwiKSA6IG91dGVyVHlwZTtcXG4gICAgICAgIGZvciAodmFyIGokMSA9IGkkNjsgaiQxIDwgZW5kJDE7ICsraiQxKSB7IHR5cGVzW2okMV0gPSByZXBsYWNlJDE7IH1cXG4gICAgICAgIGkkNiA9IGVuZCQxIC0gMTtcXG4gICAgICB9XFxuICAgIH1cXG5cXG4gICAgLy8gSGVyZSB3ZSBkZXBhcnQgZnJvbSB0aGUgZG9jdW1lbnRlZCBhbGdvcml0aG0sIGluIG9yZGVyIHRvIGF2b2lkXFxuICAgIC8vIGJ1aWxkaW5nIHVwIGFuIGFjdHVhbCBsZXZlbHMgYXJyYXkuIFNpbmNlIHRoZXJlIGFyZSBvbmx5IHRocmVlXFxuICAgIC8vIGxldmVscyAoMCwgMSwgMikgaW4gYW4gaW1wbGVtZW50YXRpb24gdGhhdCBkb2Vzbid0IHRha2VcXG4gICAgLy8gZXhwbGljaXQgZW1iZWRkaW5nIGludG8gYWNjb3VudCwgd2UgY2FuIGJ1aWxkIHVwIHRoZSBvcmRlciBvblxcbiAgICAvLyB0aGUgZmx5LCB3aXRob3V0IGZvbGxvd2luZyB0aGUgbGV2ZWwtYmFzZWQgYWxnb3JpdGhtLlxcbiAgICB2YXIgb3JkZXIgPSBbXSwgbTtcXG4gICAgZm9yICh2YXIgaSQ3ID0gMDsgaSQ3IDwgbGVuOykge1xcbiAgICAgIGlmIChjb3VudHNBc0xlZnQudGVzdCh0eXBlc1tpJDddKSkge1xcbiAgICAgICAgdmFyIHN0YXJ0ID0gaSQ3O1xcbiAgICAgICAgZm9yICgrK2kkNzsgaSQ3IDwgbGVuICYmIGNvdW50c0FzTGVmdC50ZXN0KHR5cGVzW2kkN10pOyArK2kkNykge31cXG4gICAgICAgIG9yZGVyLnB1c2gobmV3IEJpZGlTcGFuKDAsIHN0YXJ0LCBpJDcpKTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgdmFyIHBvcyA9IGkkNywgYXQgPSBvcmRlci5sZW5ndGg7XFxuICAgICAgICBmb3IgKCsraSQ3OyBpJDcgPCBsZW4gJiYgdHlwZXNbaSQ3XSAhPSBcXFwiTFxcXCI7ICsraSQ3KSB7fVxcbiAgICAgICAgZm9yICh2YXIgaiQyID0gcG9zOyBqJDIgPCBpJDc7KSB7XFxuICAgICAgICAgIGlmIChjb3VudHNBc051bS50ZXN0KHR5cGVzW2okMl0pKSB7XFxuICAgICAgICAgICAgaWYgKHBvcyA8IGokMikgeyBvcmRlci5zcGxpY2UoYXQsIDAsIG5ldyBCaWRpU3BhbigxLCBwb3MsIGokMikpOyB9XFxuICAgICAgICAgICAgdmFyIG5zdGFydCA9IGokMjtcXG4gICAgICAgICAgICBmb3IgKCsraiQyOyBqJDIgPCBpJDcgJiYgY291bnRzQXNOdW0udGVzdCh0eXBlc1tqJDJdKTsgKytqJDIpIHt9XFxuICAgICAgICAgICAgb3JkZXIuc3BsaWNlKGF0LCAwLCBuZXcgQmlkaVNwYW4oMiwgbnN0YXJ0LCBqJDIpKTtcXG4gICAgICAgICAgICBwb3MgPSBqJDI7XFxuICAgICAgICAgIH0gZWxzZSB7ICsraiQyOyB9XFxuICAgICAgICB9XFxuICAgICAgICBpZiAocG9zIDwgaSQ3KSB7IG9yZGVyLnNwbGljZShhdCwgMCwgbmV3IEJpZGlTcGFuKDEsIHBvcywgaSQ3KSk7IH1cXG4gICAgICB9XFxuICAgIH1cXG4gICAgaWYgKG9yZGVyWzBdLmxldmVsID09IDEgJiYgKG0gPSBzdHIubWF0Y2goL15cXFxccysvKSkpIHtcXG4gICAgICBvcmRlclswXS5mcm9tID0gbVswXS5sZW5ndGg7XFxuICAgICAgb3JkZXIudW5zaGlmdChuZXcgQmlkaVNwYW4oMCwgMCwgbVswXS5sZW5ndGgpKTtcXG4gICAgfVxcbiAgICBpZiAobHN0KG9yZGVyKS5sZXZlbCA9PSAxICYmIChtID0gc3RyLm1hdGNoKC9cXFxccyskLykpKSB7XFxuICAgICAgbHN0KG9yZGVyKS50byAtPSBtWzBdLmxlbmd0aDtcXG4gICAgICBvcmRlci5wdXNoKG5ldyBCaWRpU3BhbigwLCBsZW4gLSBtWzBdLmxlbmd0aCwgbGVuKSk7XFxuICAgIH1cXG5cXG4gICAgcmV0dXJuIGRpcmVjdGlvbiA9PSBcXFwicnRsXFxcIiA/IG9yZGVyLnJldmVyc2UoKSA6IG9yZGVyXFxuICB9XFxufSkoKTtcXG5cXG4vLyBHZXQgdGhlIGJpZGkgb3JkZXJpbmcgZm9yIHRoZSBnaXZlbiBsaW5lIChhbmQgY2FjaGUgaXQpLiBSZXR1cm5zXFxuLy8gZmFsc2UgZm9yIGxpbmVzIHRoYXQgYXJlIGZ1bGx5IGxlZnQtdG8tcmlnaHQsIGFuZCBhbiBhcnJheSBvZlxcbi8vIEJpZGlTcGFuIG9iamVjdHMgb3RoZXJ3aXNlLlxcbmZ1bmN0aW9uIGdldE9yZGVyKGxpbmUsIGRpcmVjdGlvbikge1xcbiAgdmFyIG9yZGVyID0gbGluZS5vcmRlcjtcXG4gIGlmIChvcmRlciA9PSBudWxsKSB7IG9yZGVyID0gbGluZS5vcmRlciA9IGJpZGlPcmRlcmluZyhsaW5lLnRleHQsIGRpcmVjdGlvbik7IH1cXG4gIHJldHVybiBvcmRlclxcbn1cXG5cXG5mdW5jdGlvbiBtb3ZlQ2hhckxvZ2ljYWxseShsaW5lLCBjaCwgZGlyKSB7XFxuICB2YXIgdGFyZ2V0ID0gc2tpcEV4dGVuZGluZ0NoYXJzKGxpbmUudGV4dCwgY2ggKyBkaXIsIGRpcik7XFxuICByZXR1cm4gdGFyZ2V0IDwgMCB8fCB0YXJnZXQgPiBsaW5lLnRleHQubGVuZ3RoID8gbnVsbCA6IHRhcmdldFxcbn1cXG5cXG5mdW5jdGlvbiBtb3ZlTG9naWNhbGx5KGxpbmUsIHN0YXJ0LCBkaXIpIHtcXG4gIHZhciBjaCA9IG1vdmVDaGFyTG9naWNhbGx5KGxpbmUsIHN0YXJ0LmNoLCBkaXIpO1xcbiAgcmV0dXJuIGNoID09IG51bGwgPyBudWxsIDogbmV3IFBvcyhzdGFydC5saW5lLCBjaCwgZGlyIDwgMCA/IFxcXCJhZnRlclxcXCIgOiBcXFwiYmVmb3JlXFxcIilcXG59XFxuXFxuZnVuY3Rpb24gZW5kT2ZMaW5lKHZpc3VhbGx5LCBjbSwgbGluZU9iaiwgbGluZU5vLCBkaXIpIHtcXG4gIGlmICh2aXN1YWxseSkge1xcbiAgICB2YXIgb3JkZXIgPSBnZXRPcmRlcihsaW5lT2JqLCBjbS5kb2MuZGlyZWN0aW9uKTtcXG4gICAgaWYgKG9yZGVyKSB7XFxuICAgICAgdmFyIHBhcnQgPSBkaXIgPCAwID8gbHN0KG9yZGVyKSA6IG9yZGVyWzBdO1xcbiAgICAgIHZhciBtb3ZlSW5TdG9yYWdlT3JkZXIgPSAoZGlyIDwgMCkgPT0gKHBhcnQubGV2ZWwgPT0gMSk7XFxuICAgICAgdmFyIHN0aWNreSA9IG1vdmVJblN0b3JhZ2VPcmRlciA/IFxcXCJhZnRlclxcXCIgOiBcXFwiYmVmb3JlXFxcIjtcXG4gICAgICB2YXIgY2g7XFxuICAgICAgLy8gV2l0aCBhIHdyYXBwZWQgcnRsIGNodW5rIChwb3NzaWJseSBzcGFubmluZyBtdWx0aXBsZSBiaWRpIHBhcnRzKSxcXG4gICAgICAvLyBpdCBjb3VsZCBiZSB0aGF0IHRoZSBsYXN0IGJpZGkgcGFydCBpcyBub3Qgb24gdGhlIGxhc3QgdmlzdWFsIGxpbmUsXFxuICAgICAgLy8gc2luY2UgdmlzdWFsIGxpbmVzIGNvbnRhaW4gY29udGVudCBvcmRlci1jb25zZWN1dGl2ZSBjaHVua3MuXFxuICAgICAgLy8gVGh1cywgaW4gcnRsLCB3ZSBhcmUgbG9va2luZyBmb3IgdGhlIGZpcnN0IChjb250ZW50LW9yZGVyKSBjaGFyYWN0ZXJcXG4gICAgICAvLyBpbiB0aGUgcnRsIGNodW5rIHRoYXQgaXMgb24gdGhlIGxhc3QgbGluZSAodGhhdCBpcywgdGhlIHNhbWUgbGluZVxcbiAgICAgIC8vIGFzIHRoZSBsYXN0IChjb250ZW50LW9yZGVyKSBjaGFyYWN0ZXIpLlxcbiAgICAgIGlmIChwYXJ0LmxldmVsID4gMCkge1xcbiAgICAgICAgdmFyIHByZXAgPSBwcmVwYXJlTWVhc3VyZUZvckxpbmUoY20sIGxpbmVPYmopO1xcbiAgICAgICAgY2ggPSBkaXIgPCAwID8gbGluZU9iai50ZXh0Lmxlbmd0aCAtIDEgOiAwO1xcbiAgICAgICAgdmFyIHRhcmdldFRvcCA9IG1lYXN1cmVDaGFyUHJlcGFyZWQoY20sIHByZXAsIGNoKS50b3A7XFxuICAgICAgICBjaCA9IGZpbmRGaXJzdChmdW5jdGlvbiAoY2gpIHsgcmV0dXJuIG1lYXN1cmVDaGFyUHJlcGFyZWQoY20sIHByZXAsIGNoKS50b3AgPT0gdGFyZ2V0VG9wOyB9LCAoZGlyIDwgMCkgPT0gKHBhcnQubGV2ZWwgPT0gMSkgPyBwYXJ0LmZyb20gOiBwYXJ0LnRvIC0gMSwgY2gpO1xcbiAgICAgICAgaWYgKHN0aWNreSA9PSBcXFwiYmVmb3JlXFxcIikgeyBjaCA9IG1vdmVDaGFyTG9naWNhbGx5KGxpbmVPYmosIGNoLCAxLCB0cnVlKTsgfVxcbiAgICAgIH0gZWxzZSB7IGNoID0gZGlyIDwgMCA/IHBhcnQudG8gOiBwYXJ0LmZyb207IH1cXG4gICAgICByZXR1cm4gbmV3IFBvcyhsaW5lTm8sIGNoLCBzdGlja3kpXFxuICAgIH1cXG4gIH1cXG4gIHJldHVybiBuZXcgUG9zKGxpbmVObywgZGlyIDwgMCA/IGxpbmVPYmoudGV4dC5sZW5ndGggOiAwLCBkaXIgPCAwID8gXFxcImJlZm9yZVxcXCIgOiBcXFwiYWZ0ZXJcXFwiKVxcbn1cXG5cXG5mdW5jdGlvbiBtb3ZlVmlzdWFsbHkoY20sIGxpbmUsIHN0YXJ0LCBkaXIpIHtcXG4gIHZhciBiaWRpID0gZ2V0T3JkZXIobGluZSwgY20uZG9jLmRpcmVjdGlvbik7XFxuICBpZiAoIWJpZGkpIHsgcmV0dXJuIG1vdmVMb2dpY2FsbHkobGluZSwgc3RhcnQsIGRpcikgfVxcbiAgaWYgKHN0YXJ0LmNoID49IGxpbmUudGV4dC5sZW5ndGgpIHtcXG4gICAgc3RhcnQuY2ggPSBsaW5lLnRleHQubGVuZ3RoO1xcbiAgICBzdGFydC5zdGlja3kgPSBcXFwiYmVmb3JlXFxcIjtcXG4gIH0gZWxzZSBpZiAoc3RhcnQuY2ggPD0gMCkge1xcbiAgICBzdGFydC5jaCA9IDA7XFxuICAgIHN0YXJ0LnN0aWNreSA9IFxcXCJhZnRlclxcXCI7XFxuICB9XFxuICB2YXIgcGFydFBvcyA9IGdldEJpZGlQYXJ0QXQoYmlkaSwgc3RhcnQuY2gsIHN0YXJ0LnN0aWNreSksIHBhcnQgPSBiaWRpW3BhcnRQb3NdO1xcbiAgaWYgKGNtLmRvYy5kaXJlY3Rpb24gPT0gXFxcImx0clxcXCIgJiYgcGFydC5sZXZlbCAlIDIgPT0gMCAmJiAoZGlyID4gMCA/IHBhcnQudG8gPiBzdGFydC5jaCA6IHBhcnQuZnJvbSA8IHN0YXJ0LmNoKSkge1xcbiAgICAvLyBDYXNlIDE6IFdlIG1vdmUgd2l0aGluIGFuIGx0ciBwYXJ0IGluIGFuIGx0ciBlZGl0b3IuIEV2ZW4gd2l0aCB3cmFwcGVkIGxpbmVzLFxcbiAgICAvLyBub3RoaW5nIGludGVyZXN0aW5nIGhhcHBlbnMuXFxuICAgIHJldHVybiBtb3ZlTG9naWNhbGx5KGxpbmUsIHN0YXJ0LCBkaXIpXFxuICB9XFxuXFxuICB2YXIgbXYgPSBmdW5jdGlvbiAocG9zLCBkaXIpIHsgcmV0dXJuIG1vdmVDaGFyTG9naWNhbGx5KGxpbmUsIHBvcyBpbnN0YW5jZW9mIFBvcyA/IHBvcy5jaCA6IHBvcywgZGlyKTsgfTtcXG4gIHZhciBwcmVwO1xcbiAgdmFyIGdldFdyYXBwZWRMaW5lRXh0ZW50ID0gZnVuY3Rpb24gKGNoKSB7XFxuICAgIGlmICghY20ub3B0aW9ucy5saW5lV3JhcHBpbmcpIHsgcmV0dXJuIHtiZWdpbjogMCwgZW5kOiBsaW5lLnRleHQubGVuZ3RofSB9XFxuICAgIHByZXAgPSBwcmVwIHx8IHByZXBhcmVNZWFzdXJlRm9yTGluZShjbSwgbGluZSk7XFxuICAgIHJldHVybiB3cmFwcGVkTGluZUV4dGVudENoYXIoY20sIGxpbmUsIHByZXAsIGNoKVxcbiAgfTtcXG4gIHZhciB3cmFwcGVkTGluZUV4dGVudCA9IGdldFdyYXBwZWRMaW5lRXh0ZW50KHN0YXJ0LnN0aWNreSA9PSBcXFwiYmVmb3JlXFxcIiA/IG12KHN0YXJ0LCAtMSkgOiBzdGFydC5jaCk7XFxuXFxuICBpZiAoY20uZG9jLmRpcmVjdGlvbiA9PSBcXFwicnRsXFxcIiB8fCBwYXJ0LmxldmVsID09IDEpIHtcXG4gICAgdmFyIG1vdmVJblN0b3JhZ2VPcmRlciA9IChwYXJ0LmxldmVsID09IDEpID09IChkaXIgPCAwKTtcXG4gICAgdmFyIGNoID0gbXYoc3RhcnQsIG1vdmVJblN0b3JhZ2VPcmRlciA/IDEgOiAtMSk7XFxuICAgIGlmIChjaCAhPSBudWxsICYmICghbW92ZUluU3RvcmFnZU9yZGVyID8gY2ggPj0gcGFydC5mcm9tICYmIGNoID49IHdyYXBwZWRMaW5lRXh0ZW50LmJlZ2luIDogY2ggPD0gcGFydC50byAmJiBjaCA8PSB3cmFwcGVkTGluZUV4dGVudC5lbmQpKSB7XFxuICAgICAgLy8gQ2FzZSAyOiBXZSBtb3ZlIHdpdGhpbiBhbiBydGwgcGFydCBvciBpbiBhbiBydGwgZWRpdG9yIG9uIHRoZSBzYW1lIHZpc3VhbCBsaW5lXFxuICAgICAgdmFyIHN0aWNreSA9IG1vdmVJblN0b3JhZ2VPcmRlciA/IFxcXCJiZWZvcmVcXFwiIDogXFxcImFmdGVyXFxcIjtcXG4gICAgICByZXR1cm4gbmV3IFBvcyhzdGFydC5saW5lLCBjaCwgc3RpY2t5KVxcbiAgICB9XFxuICB9XFxuXFxuICAvLyBDYXNlIDM6IENvdWxkIG5vdCBtb3ZlIHdpdGhpbiB0aGlzIGJpZGkgcGFydCBpbiB0aGlzIHZpc3VhbCBsaW5lLCBzbyBsZWF2ZVxcbiAgLy8gdGhlIGN1cnJlbnQgYmlkaSBwYXJ0XFxuXFxuICB2YXIgc2VhcmNoSW5WaXN1YWxMaW5lID0gZnVuY3Rpb24gKHBhcnRQb3MsIGRpciwgd3JhcHBlZExpbmVFeHRlbnQpIHtcXG4gICAgdmFyIGdldFJlcyA9IGZ1bmN0aW9uIChjaCwgbW92ZUluU3RvcmFnZU9yZGVyKSB7IHJldHVybiBtb3ZlSW5TdG9yYWdlT3JkZXJcXG4gICAgICA/IG5ldyBQb3Moc3RhcnQubGluZSwgbXYoY2gsIDEpLCBcXFwiYmVmb3JlXFxcIilcXG4gICAgICA6IG5ldyBQb3Moc3RhcnQubGluZSwgY2gsIFxcXCJhZnRlclxcXCIpOyB9O1xcblxcbiAgICBmb3IgKDsgcGFydFBvcyA+PSAwICYmIHBhcnRQb3MgPCBiaWRpLmxlbmd0aDsgcGFydFBvcyArPSBkaXIpIHtcXG4gICAgICB2YXIgcGFydCA9IGJpZGlbcGFydFBvc107XFxuICAgICAgdmFyIG1vdmVJblN0b3JhZ2VPcmRlciA9IChkaXIgPiAwKSA9PSAocGFydC5sZXZlbCAhPSAxKTtcXG4gICAgICB2YXIgY2ggPSBtb3ZlSW5TdG9yYWdlT3JkZXIgPyB3cmFwcGVkTGluZUV4dGVudC5iZWdpbiA6IG12KHdyYXBwZWRMaW5lRXh0ZW50LmVuZCwgLTEpO1xcbiAgICAgIGlmIChwYXJ0LmZyb20gPD0gY2ggJiYgY2ggPCBwYXJ0LnRvKSB7IHJldHVybiBnZXRSZXMoY2gsIG1vdmVJblN0b3JhZ2VPcmRlcikgfVxcbiAgICAgIGNoID0gbW92ZUluU3RvcmFnZU9yZGVyID8gcGFydC5mcm9tIDogbXYocGFydC50bywgLTEpO1xcbiAgICAgIGlmICh3cmFwcGVkTGluZUV4dGVudC5iZWdpbiA8PSBjaCAmJiBjaCA8IHdyYXBwZWRMaW5lRXh0ZW50LmVuZCkgeyByZXR1cm4gZ2V0UmVzKGNoLCBtb3ZlSW5TdG9yYWdlT3JkZXIpIH1cXG4gICAgfVxcbiAgfTtcXG5cXG4gIC8vIENhc2UgM2E6IExvb2sgZm9yIG90aGVyIGJpZGkgcGFydHMgb24gdGhlIHNhbWUgdmlzdWFsIGxpbmVcXG4gIHZhciByZXMgPSBzZWFyY2hJblZpc3VhbExpbmUocGFydFBvcyArIGRpciwgZGlyLCB3cmFwcGVkTGluZUV4dGVudCk7XFxuICBpZiAocmVzKSB7IHJldHVybiByZXMgfVxcblxcbiAgLy8gQ2FzZSAzYjogTG9vayBmb3Igb3RoZXIgYmlkaSBwYXJ0cyBvbiB0aGUgbmV4dCB2aXN1YWwgbGluZVxcbiAgdmFyIG5leHRDaCA9IGRpciA+IDAgPyB3cmFwcGVkTGluZUV4dGVudC5lbmQgOiBtdih3cmFwcGVkTGluZUV4dGVudC5iZWdpbiwgLTEpO1xcbiAgaWYgKG5leHRDaCAhPSBudWxsICYmICEoZGlyID4gMCAmJiBuZXh0Q2ggPT0gbGluZS50ZXh0Lmxlbmd0aCkpIHtcXG4gICAgcmVzID0gc2VhcmNoSW5WaXN1YWxMaW5lKGRpciA+IDAgPyAwIDogYmlkaS5sZW5ndGggLSAxLCBkaXIsIGdldFdyYXBwZWRMaW5lRXh0ZW50KG5leHRDaCkpO1xcbiAgICBpZiAocmVzKSB7IHJldHVybiByZXMgfVxcbiAgfVxcblxcbiAgLy8gQ2FzZSA0OiBOb3doZXJlIHRvIG1vdmVcXG4gIHJldHVybiBudWxsXFxufVxcblxcbi8vIEVWRU5UIEhBTkRMSU5HXFxuXFxuLy8gTGlnaHR3ZWlnaHQgZXZlbnQgZnJhbWV3b3JrLiBvbi9vZmYgYWxzbyB3b3JrIG9uIERPTSBub2RlcyxcXG4vLyByZWdpc3RlcmluZyBuYXRpdmUgRE9NIGhhbmRsZXJzLlxcblxcbnZhciBub0hhbmRsZXJzID0gW107XFxuXFxudmFyIG9uID0gZnVuY3Rpb24oZW1pdHRlciwgdHlwZSwgZikge1xcbiAgaWYgKGVtaXR0ZXIuYWRkRXZlbnRMaXN0ZW5lcikge1xcbiAgICBlbWl0dGVyLmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgZiwgZmFsc2UpO1xcbiAgfSBlbHNlIGlmIChlbWl0dGVyLmF0dGFjaEV2ZW50KSB7XFxuICAgIGVtaXR0ZXIuYXR0YWNoRXZlbnQoXFxcIm9uXFxcIiArIHR5cGUsIGYpO1xcbiAgfSBlbHNlIHtcXG4gICAgdmFyIG1hcCQkMSA9IGVtaXR0ZXIuX2hhbmRsZXJzIHx8IChlbWl0dGVyLl9oYW5kbGVycyA9IHt9KTtcXG4gICAgbWFwJCQxW3R5cGVdID0gKG1hcCQkMVt0eXBlXSB8fCBub0hhbmRsZXJzKS5jb25jYXQoZik7XFxuICB9XFxufTtcXG5cXG5mdW5jdGlvbiBnZXRIYW5kbGVycyhlbWl0dGVyLCB0eXBlKSB7XFxuICByZXR1cm4gZW1pdHRlci5faGFuZGxlcnMgJiYgZW1pdHRlci5faGFuZGxlcnNbdHlwZV0gfHwgbm9IYW5kbGVyc1xcbn1cXG5cXG5mdW5jdGlvbiBvZmYoZW1pdHRlciwgdHlwZSwgZikge1xcbiAgaWYgKGVtaXR0ZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcikge1xcbiAgICBlbWl0dGVyLnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgZiwgZmFsc2UpO1xcbiAgfSBlbHNlIGlmIChlbWl0dGVyLmRldGFjaEV2ZW50KSB7XFxuICAgIGVtaXR0ZXIuZGV0YWNoRXZlbnQoXFxcIm9uXFxcIiArIHR5cGUsIGYpO1xcbiAgfSBlbHNlIHtcXG4gICAgdmFyIG1hcCQkMSA9IGVtaXR0ZXIuX2hhbmRsZXJzLCBhcnIgPSBtYXAkJDEgJiYgbWFwJCQxW3R5cGVdO1xcbiAgICBpZiAoYXJyKSB7XFxuICAgICAgdmFyIGluZGV4ID0gaW5kZXhPZihhcnIsIGYpO1xcbiAgICAgIGlmIChpbmRleCA+IC0xKVxcbiAgICAgICAgeyBtYXAkJDFbdHlwZV0gPSBhcnIuc2xpY2UoMCwgaW5kZXgpLmNvbmNhdChhcnIuc2xpY2UoaW5kZXggKyAxKSk7IH1cXG4gICAgfVxcbiAgfVxcbn1cXG5cXG5mdW5jdGlvbiBzaWduYWwoZW1pdHRlciwgdHlwZSAvKiwgdmFsdWVzLi4uKi8pIHtcXG4gIHZhciBoYW5kbGVycyA9IGdldEhhbmRsZXJzKGVtaXR0ZXIsIHR5cGUpO1xcbiAgaWYgKCFoYW5kbGVycy5sZW5ndGgpIHsgcmV0dXJuIH1cXG4gIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKTtcXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgaGFuZGxlcnMubGVuZ3RoOyArK2kpIHsgaGFuZGxlcnNbaV0uYXBwbHkobnVsbCwgYXJncyk7IH1cXG59XFxuXFxuLy8gVGhlIERPTSBldmVudHMgdGhhdCBDb2RlTWlycm9yIGhhbmRsZXMgY2FuIGJlIG92ZXJyaWRkZW4gYnlcXG4vLyByZWdpc3RlcmluZyBhIChub24tRE9NKSBoYW5kbGVyIG9uIHRoZSBlZGl0b3IgZm9yIHRoZSBldmVudCBuYW1lLFxcbi8vIGFuZCBwcmV2ZW50RGVmYXVsdC1pbmcgdGhlIGV2ZW50IGluIHRoYXQgaGFuZGxlci5cXG5mdW5jdGlvbiBzaWduYWxET01FdmVudChjbSwgZSwgb3ZlcnJpZGUpIHtcXG4gIGlmICh0eXBlb2YgZSA9PSBcXFwic3RyaW5nXFxcIilcXG4gICAgeyBlID0ge3R5cGU6IGUsIHByZXZlbnREZWZhdWx0OiBmdW5jdGlvbigpIHsgdGhpcy5kZWZhdWx0UHJldmVudGVkID0gdHJ1ZTsgfX07IH1cXG4gIHNpZ25hbChjbSwgb3ZlcnJpZGUgfHwgZS50eXBlLCBjbSwgZSk7XFxuICByZXR1cm4gZV9kZWZhdWx0UHJldmVudGVkKGUpIHx8IGUuY29kZW1pcnJvcklnbm9yZVxcbn1cXG5cXG5mdW5jdGlvbiBzaWduYWxDdXJzb3JBY3Rpdml0eShjbSkge1xcbiAgdmFyIGFyciA9IGNtLl9oYW5kbGVycyAmJiBjbS5faGFuZGxlcnMuY3Vyc29yQWN0aXZpdHk7XFxuICBpZiAoIWFycikgeyByZXR1cm4gfVxcbiAgdmFyIHNldCA9IGNtLmN1ck9wLmN1cnNvckFjdGl2aXR5SGFuZGxlcnMgfHwgKGNtLmN1ck9wLmN1cnNvckFjdGl2aXR5SGFuZGxlcnMgPSBbXSk7XFxuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7ICsraSkgeyBpZiAoaW5kZXhPZihzZXQsIGFycltpXSkgPT0gLTEpXFxuICAgIHsgc2V0LnB1c2goYXJyW2ldKTsgfSB9XFxufVxcblxcbmZ1bmN0aW9uIGhhc0hhbmRsZXIoZW1pdHRlciwgdHlwZSkge1xcbiAgcmV0dXJuIGdldEhhbmRsZXJzKGVtaXR0ZXIsIHR5cGUpLmxlbmd0aCA+IDBcXG59XFxuXFxuLy8gQWRkIG9uIGFuZCBvZmYgbWV0aG9kcyB0byBhIGNvbnN0cnVjdG9yJ3MgcHJvdG90eXBlLCB0byBtYWtlXFxuLy8gcmVnaXN0ZXJpbmcgZXZlbnRzIG9uIHN1Y2ggb2JqZWN0cyBtb3JlIGNvbnZlbmllbnQuXFxuZnVuY3Rpb24gZXZlbnRNaXhpbihjdG9yKSB7XFxuICBjdG9yLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uKHR5cGUsIGYpIHtvbih0aGlzLCB0eXBlLCBmKTt9O1xcbiAgY3Rvci5wcm90b3R5cGUub2ZmID0gZnVuY3Rpb24odHlwZSwgZikge29mZih0aGlzLCB0eXBlLCBmKTt9O1xcbn1cXG5cXG4vLyBEdWUgdG8gdGhlIGZhY3QgdGhhdCB3ZSBzdGlsbCBzdXBwb3J0IGp1cmFzc2ljIElFIHZlcnNpb25zLCBzb21lXFxuLy8gY29tcGF0aWJpbGl0eSB3cmFwcGVycyBhcmUgbmVlZGVkLlxcblxcbmZ1bmN0aW9uIGVfcHJldmVudERlZmF1bHQoZSkge1xcbiAgaWYgKGUucHJldmVudERlZmF1bHQpIHsgZS5wcmV2ZW50RGVmYXVsdCgpOyB9XFxuICBlbHNlIHsgZS5yZXR1cm5WYWx1ZSA9IGZhbHNlOyB9XFxufVxcbmZ1bmN0aW9uIGVfc3RvcFByb3BhZ2F0aW9uKGUpIHtcXG4gIGlmIChlLnN0b3BQcm9wYWdhdGlvbikgeyBlLnN0b3BQcm9wYWdhdGlvbigpOyB9XFxuICBlbHNlIHsgZS5jYW5jZWxCdWJibGUgPSB0cnVlOyB9XFxufVxcbmZ1bmN0aW9uIGVfZGVmYXVsdFByZXZlbnRlZChlKSB7XFxuICByZXR1cm4gZS5kZWZhdWx0UHJldmVudGVkICE9IG51bGwgPyBlLmRlZmF1bHRQcmV2ZW50ZWQgOiBlLnJldHVyblZhbHVlID09IGZhbHNlXFxufVxcbmZ1bmN0aW9uIGVfc3RvcChlKSB7ZV9wcmV2ZW50RGVmYXVsdChlKTsgZV9zdG9wUHJvcGFnYXRpb24oZSk7fVxcblxcbmZ1bmN0aW9uIGVfdGFyZ2V0KGUpIHtyZXR1cm4gZS50YXJnZXQgfHwgZS5zcmNFbGVtZW50fVxcbmZ1bmN0aW9uIGVfYnV0dG9uKGUpIHtcXG4gIHZhciBiID0gZS53aGljaDtcXG4gIGlmIChiID09IG51bGwpIHtcXG4gICAgaWYgKGUuYnV0dG9uICYgMSkgeyBiID0gMTsgfVxcbiAgICBlbHNlIGlmIChlLmJ1dHRvbiAmIDIpIHsgYiA9IDM7IH1cXG4gICAgZWxzZSBpZiAoZS5idXR0b24gJiA0KSB7IGIgPSAyOyB9XFxuICB9XFxuICBpZiAobWFjICYmIGUuY3RybEtleSAmJiBiID09IDEpIHsgYiA9IDM7IH1cXG4gIHJldHVybiBiXFxufVxcblxcbi8vIERldGVjdCBkcmFnLWFuZC1kcm9wXFxudmFyIGRyYWdBbmREcm9wID0gZnVuY3Rpb24oKSB7XFxuICAvLyBUaGVyZSBpcyAqc29tZSoga2luZCBvZiBkcmFnLWFuZC1kcm9wIHN1cHBvcnQgaW4gSUU2LTgsIGJ1dCBJXFxuICAvLyBjb3VsZG4ndCBnZXQgaXQgdG8gd29yayB5ZXQuXFxuICBpZiAoaWUgJiYgaWVfdmVyc2lvbiA8IDkpIHsgcmV0dXJuIGZhbHNlIH1cXG4gIHZhciBkaXYgPSBlbHQoJ2RpdicpO1xcbiAgcmV0dXJuIFxcXCJkcmFnZ2FibGVcXFwiIGluIGRpdiB8fCBcXFwiZHJhZ0Ryb3BcXFwiIGluIGRpdlxcbn0oKTtcXG5cXG52YXIgendzcFN1cHBvcnRlZDtcXG5mdW5jdGlvbiB6ZXJvV2lkdGhFbGVtZW50KG1lYXN1cmUpIHtcXG4gIGlmICh6d3NwU3VwcG9ydGVkID09IG51bGwpIHtcXG4gICAgdmFyIHRlc3QgPSBlbHQoXFxcInNwYW5cXFwiLCBcXFwiXFxcXHUyMDBiXFxcIik7XFxuICAgIHJlbW92ZUNoaWxkcmVuQW5kQWRkKG1lYXN1cmUsIGVsdChcXFwic3BhblxcXCIsIFt0ZXN0LCBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcXFwieFxcXCIpXSkpO1xcbiAgICBpZiAobWVhc3VyZS5maXJzdENoaWxkLm9mZnNldEhlaWdodCAhPSAwKVxcbiAgICAgIHsgendzcFN1cHBvcnRlZCA9IHRlc3Qub2Zmc2V0V2lkdGggPD0gMSAmJiB0ZXN0Lm9mZnNldEhlaWdodCA+IDIgJiYgIShpZSAmJiBpZV92ZXJzaW9uIDwgOCk7IH1cXG4gIH1cXG4gIHZhciBub2RlID0gendzcFN1cHBvcnRlZCA/IGVsdChcXFwic3BhblxcXCIsIFxcXCJcXFxcdTIwMGJcXFwiKSA6XFxuICAgIGVsdChcXFwic3BhblxcXCIsIFxcXCJcXFxcdTAwYTBcXFwiLCBudWxsLCBcXFwiZGlzcGxheTogaW5saW5lLWJsb2NrOyB3aWR0aDogMXB4OyBtYXJnaW4tcmlnaHQ6IC0xcHhcXFwiKTtcXG4gIG5vZGUuc2V0QXR0cmlidXRlKFxcXCJjbS10ZXh0XFxcIiwgXFxcIlxcXCIpO1xcbiAgcmV0dXJuIG5vZGVcXG59XFxuXFxuLy8gRmVhdHVyZS1kZXRlY3QgSUUncyBjcnVtbXkgY2xpZW50IHJlY3QgcmVwb3J0aW5nIGZvciBiaWRpIHRleHRcXG52YXIgYmFkQmlkaVJlY3RzO1xcbmZ1bmN0aW9uIGhhc0JhZEJpZGlSZWN0cyhtZWFzdXJlKSB7XFxuICBpZiAoYmFkQmlkaVJlY3RzICE9IG51bGwpIHsgcmV0dXJuIGJhZEJpZGlSZWN0cyB9XFxuICB2YXIgdHh0ID0gcmVtb3ZlQ2hpbGRyZW5BbmRBZGQobWVhc3VyZSwgZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXFxcIkFcXFxcdTA2MmVBXFxcIikpO1xcbiAgdmFyIHIwID0gcmFuZ2UodHh0LCAwLCAxKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcXG4gIHZhciByMSA9IHJhbmdlKHR4dCwgMSwgMikuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XFxuICByZW1vdmVDaGlsZHJlbihtZWFzdXJlKTtcXG4gIGlmICghcjAgfHwgcjAubGVmdCA9PSByMC5yaWdodCkgeyByZXR1cm4gZmFsc2UgfSAvLyBTYWZhcmkgcmV0dXJucyBudWxsIGluIHNvbWUgY2FzZXMgKCMyNzgwKVxcbiAgcmV0dXJuIGJhZEJpZGlSZWN0cyA9IChyMS5yaWdodCAtIHIwLnJpZ2h0IDwgMylcXG59XFxuXFxuLy8gU2VlIGlmIFxcXCJcXFwiLnNwbGl0IGlzIHRoZSBicm9rZW4gSUUgdmVyc2lvbiwgaWYgc28sIHByb3ZpZGUgYW5cXG4vLyBhbHRlcm5hdGl2ZSB3YXkgdG8gc3BsaXQgbGluZXMuXFxudmFyIHNwbGl0TGluZXNBdXRvID0gXFxcIlxcXFxuXFxcXG5iXFxcIi5zcGxpdCgvXFxcXG4vKS5sZW5ndGggIT0gMyA/IGZ1bmN0aW9uIChzdHJpbmcpIHtcXG4gIHZhciBwb3MgPSAwLCByZXN1bHQgPSBbXSwgbCA9IHN0cmluZy5sZW5ndGg7XFxuICB3aGlsZSAocG9zIDw9IGwpIHtcXG4gICAgdmFyIG5sID0gc3RyaW5nLmluZGV4T2YoXFxcIlxcXFxuXFxcIiwgcG9zKTtcXG4gICAgaWYgKG5sID09IC0xKSB7IG5sID0gc3RyaW5nLmxlbmd0aDsgfVxcbiAgICB2YXIgbGluZSA9IHN0cmluZy5zbGljZShwb3MsIHN0cmluZy5jaGFyQXQobmwgLSAxKSA9PSBcXFwiXFxcXHJcXFwiID8gbmwgLSAxIDogbmwpO1xcbiAgICB2YXIgcnQgPSBsaW5lLmluZGV4T2YoXFxcIlxcXFxyXFxcIik7XFxuICAgIGlmIChydCAhPSAtMSkge1xcbiAgICAgIHJlc3VsdC5wdXNoKGxpbmUuc2xpY2UoMCwgcnQpKTtcXG4gICAgICBwb3MgKz0gcnQgKyAxO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIHJlc3VsdC5wdXNoKGxpbmUpO1xcbiAgICAgIHBvcyA9IG5sICsgMTtcXG4gICAgfVxcbiAgfVxcbiAgcmV0dXJuIHJlc3VsdFxcbn0gOiBmdW5jdGlvbiAoc3RyaW5nKSB7IHJldHVybiBzdHJpbmcuc3BsaXQoL1xcXFxyXFxcXG4/fFxcXFxuLyk7IH07XFxuXFxudmFyIGhhc1NlbGVjdGlvbiA9IHdpbmRvdy5nZXRTZWxlY3Rpb24gPyBmdW5jdGlvbiAodGUpIHtcXG4gIHRyeSB7IHJldHVybiB0ZS5zZWxlY3Rpb25TdGFydCAhPSB0ZS5zZWxlY3Rpb25FbmQgfVxcbiAgY2F0Y2goZSkgeyByZXR1cm4gZmFsc2UgfVxcbn0gOiBmdW5jdGlvbiAodGUpIHtcXG4gIHZhciByYW5nZSQkMTtcXG4gIHRyeSB7cmFuZ2UkJDEgPSB0ZS5vd25lckRvY3VtZW50LnNlbGVjdGlvbi5jcmVhdGVSYW5nZSgpO31cXG4gIGNhdGNoKGUpIHt9XFxuICBpZiAoIXJhbmdlJCQxIHx8IHJhbmdlJCQxLnBhcmVudEVsZW1lbnQoKSAhPSB0ZSkgeyByZXR1cm4gZmFsc2UgfVxcbiAgcmV0dXJuIHJhbmdlJCQxLmNvbXBhcmVFbmRQb2ludHMoXFxcIlN0YXJ0VG9FbmRcXFwiLCByYW5nZSQkMSkgIT0gMFxcbn07XFxuXFxudmFyIGhhc0NvcHlFdmVudCA9IChmdW5jdGlvbiAoKSB7XFxuICB2YXIgZSA9IGVsdChcXFwiZGl2XFxcIik7XFxuICBpZiAoXFxcIm9uY29weVxcXCIgaW4gZSkgeyByZXR1cm4gdHJ1ZSB9XFxuICBlLnNldEF0dHJpYnV0ZShcXFwib25jb3B5XFxcIiwgXFxcInJldHVybjtcXFwiKTtcXG4gIHJldHVybiB0eXBlb2YgZS5vbmNvcHkgPT0gXFxcImZ1bmN0aW9uXFxcIlxcbn0pKCk7XFxuXFxudmFyIGJhZFpvb21lZFJlY3RzID0gbnVsbDtcXG5mdW5jdGlvbiBoYXNCYWRab29tZWRSZWN0cyhtZWFzdXJlKSB7XFxuICBpZiAoYmFkWm9vbWVkUmVjdHMgIT0gbnVsbCkgeyByZXR1cm4gYmFkWm9vbWVkUmVjdHMgfVxcbiAgdmFyIG5vZGUgPSByZW1vdmVDaGlsZHJlbkFuZEFkZChtZWFzdXJlLCBlbHQoXFxcInNwYW5cXFwiLCBcXFwieFxcXCIpKTtcXG4gIHZhciBub3JtYWwgPSBub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xcbiAgdmFyIGZyb21SYW5nZSA9IHJhbmdlKG5vZGUsIDAsIDEpLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xcbiAgcmV0dXJuIGJhZFpvb21lZFJlY3RzID0gTWF0aC5hYnMobm9ybWFsLmxlZnQgLSBmcm9tUmFuZ2UubGVmdCkgPiAxXFxufVxcblxcbi8vIEtub3duIG1vZGVzLCBieSBuYW1lIGFuZCBieSBNSU1FXFxudmFyIG1vZGVzID0ge307XFxudmFyIG1pbWVNb2RlcyA9IHt9O1xcblxcbi8vIEV4dHJhIGFyZ3VtZW50cyBhcmUgc3RvcmVkIGFzIHRoZSBtb2RlJ3MgZGVwZW5kZW5jaWVzLCB3aGljaCBpc1xcbi8vIHVzZWQgYnkgKGxlZ2FjeSkgbWVjaGFuaXNtcyBsaWtlIGxvYWRtb2RlLmpzIHRvIGF1dG9tYXRpY2FsbHlcXG4vLyBsb2FkIGEgbW9kZS4gKFByZWZlcnJlZCBtZWNoYW5pc20gaXMgdGhlIHJlcXVpcmUvZGVmaW5lIGNhbGxzLilcXG5mdW5jdGlvbiBkZWZpbmVNb2RlKG5hbWUsIG1vZGUpIHtcXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMilcXG4gICAgeyBtb2RlLmRlcGVuZGVuY2llcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMik7IH1cXG4gIG1vZGVzW25hbWVdID0gbW9kZTtcXG59XFxuXFxuZnVuY3Rpb24gZGVmaW5lTUlNRShtaW1lLCBzcGVjKSB7XFxuICBtaW1lTW9kZXNbbWltZV0gPSBzcGVjO1xcbn1cXG5cXG4vLyBHaXZlbiBhIE1JTUUgdHlwZSwgYSB7bmFtZSwgLi4ub3B0aW9uc30gY29uZmlnIG9iamVjdCwgb3IgYSBuYW1lXFxuLy8gc3RyaW5nLCByZXR1cm4gYSBtb2RlIGNvbmZpZyBvYmplY3QuXFxuZnVuY3Rpb24gcmVzb2x2ZU1vZGUoc3BlYykge1xcbiAgaWYgKHR5cGVvZiBzcGVjID09IFxcXCJzdHJpbmdcXFwiICYmIG1pbWVNb2Rlcy5oYXNPd25Qcm9wZXJ0eShzcGVjKSkge1xcbiAgICBzcGVjID0gbWltZU1vZGVzW3NwZWNdO1xcbiAgfSBlbHNlIGlmIChzcGVjICYmIHR5cGVvZiBzcGVjLm5hbWUgPT0gXFxcInN0cmluZ1xcXCIgJiYgbWltZU1vZGVzLmhhc093blByb3BlcnR5KHNwZWMubmFtZSkpIHtcXG4gICAgdmFyIGZvdW5kID0gbWltZU1vZGVzW3NwZWMubmFtZV07XFxuICAgIGlmICh0eXBlb2YgZm91bmQgPT0gXFxcInN0cmluZ1xcXCIpIHsgZm91bmQgPSB7bmFtZTogZm91bmR9OyB9XFxuICAgIHNwZWMgPSBjcmVhdGVPYmooZm91bmQsIHNwZWMpO1xcbiAgICBzcGVjLm5hbWUgPSBmb3VuZC5uYW1lO1xcbiAgfSBlbHNlIGlmICh0eXBlb2Ygc3BlYyA9PSBcXFwic3RyaW5nXFxcIiAmJiAvXltcXFxcd1xcXFwtXStcXFxcL1tcXFxcd1xcXFwtXStcXFxcK3htbCQvLnRlc3Qoc3BlYykpIHtcXG4gICAgcmV0dXJuIHJlc29sdmVNb2RlKFxcXCJhcHBsaWNhdGlvbi94bWxcXFwiKVxcbiAgfSBlbHNlIGlmICh0eXBlb2Ygc3BlYyA9PSBcXFwic3RyaW5nXFxcIiAmJiAvXltcXFxcd1xcXFwtXStcXFxcL1tcXFxcd1xcXFwtXStcXFxcK2pzb24kLy50ZXN0KHNwZWMpKSB7XFxuICAgIHJldHVybiByZXNvbHZlTW9kZShcXFwiYXBwbGljYXRpb24vanNvblxcXCIpXFxuICB9XFxuICBpZiAodHlwZW9mIHNwZWMgPT0gXFxcInN0cmluZ1xcXCIpIHsgcmV0dXJuIHtuYW1lOiBzcGVjfSB9XFxuICBlbHNlIHsgcmV0dXJuIHNwZWMgfHwge25hbWU6IFxcXCJudWxsXFxcIn0gfVxcbn1cXG5cXG4vLyBHaXZlbiBhIG1vZGUgc3BlYyAoYW55dGhpbmcgdGhhdCByZXNvbHZlTW9kZSBhY2NlcHRzKSwgZmluZCBhbmRcXG4vLyBpbml0aWFsaXplIGFuIGFjdHVhbCBtb2RlIG9iamVjdC5cXG5mdW5jdGlvbiBnZXRNb2RlKG9wdGlvbnMsIHNwZWMpIHtcXG4gIHNwZWMgPSByZXNvbHZlTW9kZShzcGVjKTtcXG4gIHZhciBtZmFjdG9yeSA9IG1vZGVzW3NwZWMubmFtZV07XFxuICBpZiAoIW1mYWN0b3J5KSB7IHJldHVybiBnZXRNb2RlKG9wdGlvbnMsIFxcXCJ0ZXh0L3BsYWluXFxcIikgfVxcbiAgdmFyIG1vZGVPYmogPSBtZmFjdG9yeShvcHRpb25zLCBzcGVjKTtcXG4gIGlmIChtb2RlRXh0ZW5zaW9ucy5oYXNPd25Qcm9wZXJ0eShzcGVjLm5hbWUpKSB7XFxuICAgIHZhciBleHRzID0gbW9kZUV4dGVuc2lvbnNbc3BlYy5uYW1lXTtcXG4gICAgZm9yICh2YXIgcHJvcCBpbiBleHRzKSB7XFxuICAgICAgaWYgKCFleHRzLmhhc093blByb3BlcnR5KHByb3ApKSB7IGNvbnRpbnVlIH1cXG4gICAgICBpZiAobW9kZU9iai5oYXNPd25Qcm9wZXJ0eShwcm9wKSkgeyBtb2RlT2JqW1xcXCJfXFxcIiArIHByb3BdID0gbW9kZU9ialtwcm9wXTsgfVxcbiAgICAgIG1vZGVPYmpbcHJvcF0gPSBleHRzW3Byb3BdO1xcbiAgICB9XFxuICB9XFxuICBtb2RlT2JqLm5hbWUgPSBzcGVjLm5hbWU7XFxuICBpZiAoc3BlYy5oZWxwZXJUeXBlKSB7IG1vZGVPYmouaGVscGVyVHlwZSA9IHNwZWMuaGVscGVyVHlwZTsgfVxcbiAgaWYgKHNwZWMubW9kZVByb3BzKSB7IGZvciAodmFyIHByb3AkMSBpbiBzcGVjLm1vZGVQcm9wcylcXG4gICAgeyBtb2RlT2JqW3Byb3AkMV0gPSBzcGVjLm1vZGVQcm9wc1twcm9wJDFdOyB9IH1cXG5cXG4gIHJldHVybiBtb2RlT2JqXFxufVxcblxcbi8vIFRoaXMgY2FuIGJlIHVzZWQgdG8gYXR0YWNoIHByb3BlcnRpZXMgdG8gbW9kZSBvYmplY3RzIGZyb21cXG4vLyBvdXRzaWRlIHRoZSBhY3R1YWwgbW9kZSBkZWZpbml0aW9uLlxcbnZhciBtb2RlRXh0ZW5zaW9ucyA9IHt9O1xcbmZ1bmN0aW9uIGV4dGVuZE1vZGUobW9kZSwgcHJvcGVydGllcykge1xcbiAgdmFyIGV4dHMgPSBtb2RlRXh0ZW5zaW9ucy5oYXNPd25Qcm9wZXJ0eShtb2RlKSA/IG1vZGVFeHRlbnNpb25zW21vZGVdIDogKG1vZGVFeHRlbnNpb25zW21vZGVdID0ge30pO1xcbiAgY29weU9iaihwcm9wZXJ0aWVzLCBleHRzKTtcXG59XFxuXFxuZnVuY3Rpb24gY29weVN0YXRlKG1vZGUsIHN0YXRlKSB7XFxuICBpZiAoc3RhdGUgPT09IHRydWUpIHsgcmV0dXJuIHN0YXRlIH1cXG4gIGlmIChtb2RlLmNvcHlTdGF0ZSkgeyByZXR1cm4gbW9kZS5jb3B5U3RhdGUoc3RhdGUpIH1cXG4gIHZhciBuc3RhdGUgPSB7fTtcXG4gIGZvciAodmFyIG4gaW4gc3RhdGUpIHtcXG4gICAgdmFyIHZhbCA9IHN0YXRlW25dO1xcbiAgICBpZiAodmFsIGluc3RhbmNlb2YgQXJyYXkpIHsgdmFsID0gdmFsLmNvbmNhdChbXSk7IH1cXG4gICAgbnN0YXRlW25dID0gdmFsO1xcbiAgfVxcbiAgcmV0dXJuIG5zdGF0ZVxcbn1cXG5cXG4vLyBHaXZlbiBhIG1vZGUgYW5kIGEgc3RhdGUgKGZvciB0aGF0IG1vZGUpLCBmaW5kIHRoZSBpbm5lciBtb2RlIGFuZFxcbi8vIHN0YXRlIGF0IHRoZSBwb3NpdGlvbiB0aGF0IHRoZSBzdGF0ZSByZWZlcnMgdG8uXFxuZnVuY3Rpb24gaW5uZXJNb2RlKG1vZGUsIHN0YXRlKSB7XFxuICB2YXIgaW5mbztcXG4gIHdoaWxlIChtb2RlLmlubmVyTW9kZSkge1xcbiAgICBpbmZvID0gbW9kZS5pbm5lck1vZGUoc3RhdGUpO1xcbiAgICBpZiAoIWluZm8gfHwgaW5mby5tb2RlID09IG1vZGUpIHsgYnJlYWsgfVxcbiAgICBzdGF0ZSA9IGluZm8uc3RhdGU7XFxuICAgIG1vZGUgPSBpbmZvLm1vZGU7XFxuICB9XFxuICByZXR1cm4gaW5mbyB8fCB7bW9kZTogbW9kZSwgc3RhdGU6IHN0YXRlfVxcbn1cXG5cXG5mdW5jdGlvbiBzdGFydFN0YXRlKG1vZGUsIGExLCBhMikge1xcbiAgcmV0dXJuIG1vZGUuc3RhcnRTdGF0ZSA/IG1vZGUuc3RhcnRTdGF0ZShhMSwgYTIpIDogdHJ1ZVxcbn1cXG5cXG4vLyBTVFJJTkcgU1RSRUFNXFxuXFxuLy8gRmVkIHRvIHRoZSBtb2RlIHBhcnNlcnMsIHByb3ZpZGVzIGhlbHBlciBmdW5jdGlvbnMgdG8gbWFrZVxcbi8vIHBhcnNlcnMgbW9yZSBzdWNjaW5jdC5cXG5cXG52YXIgU3RyaW5nU3RyZWFtID0gZnVuY3Rpb24oc3RyaW5nLCB0YWJTaXplKSB7XFxuICB0aGlzLnBvcyA9IHRoaXMuc3RhcnQgPSAwO1xcbiAgdGhpcy5zdHJpbmcgPSBzdHJpbmc7XFxuICB0aGlzLnRhYlNpemUgPSB0YWJTaXplIHx8IDg7XFxuICB0aGlzLmxhc3RDb2x1bW5Qb3MgPSB0aGlzLmxhc3RDb2x1bW5WYWx1ZSA9IDA7XFxuICB0aGlzLmxpbmVTdGFydCA9IDA7XFxufTtcXG5cXG5TdHJpbmdTdHJlYW0ucHJvdG90eXBlLmVvbCA9IGZ1bmN0aW9uICgpIHtyZXR1cm4gdGhpcy5wb3MgPj0gdGhpcy5zdHJpbmcubGVuZ3RofTtcXG5TdHJpbmdTdHJlYW0ucHJvdG90eXBlLnNvbCA9IGZ1bmN0aW9uICgpIHtyZXR1cm4gdGhpcy5wb3MgPT0gdGhpcy5saW5lU3RhcnR9O1xcblN0cmluZ1N0cmVhbS5wcm90b3R5cGUucGVlayA9IGZ1bmN0aW9uICgpIHtyZXR1cm4gdGhpcy5zdHJpbmcuY2hhckF0KHRoaXMucG9zKSB8fCB1bmRlZmluZWR9O1xcblN0cmluZ1N0cmVhbS5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICgpIHtcXG4gIGlmICh0aGlzLnBvcyA8IHRoaXMuc3RyaW5nLmxlbmd0aClcXG4gICAgeyByZXR1cm4gdGhpcy5zdHJpbmcuY2hhckF0KHRoaXMucG9zKyspIH1cXG59O1xcblN0cmluZ1N0cmVhbS5wcm90b3R5cGUuZWF0ID0gZnVuY3Rpb24gKG1hdGNoKSB7XFxuICB2YXIgY2ggPSB0aGlzLnN0cmluZy5jaGFyQXQodGhpcy5wb3MpO1xcbiAgdmFyIG9rO1xcbiAgaWYgKHR5cGVvZiBtYXRjaCA9PSBcXFwic3RyaW5nXFxcIikgeyBvayA9IGNoID09IG1hdGNoOyB9XFxuICBlbHNlIHsgb2sgPSBjaCAmJiAobWF0Y2gudGVzdCA/IG1hdGNoLnRlc3QoY2gpIDogbWF0Y2goY2gpKTsgfVxcbiAgaWYgKG9rKSB7Kyt0aGlzLnBvczsgcmV0dXJuIGNofVxcbn07XFxuU3RyaW5nU3RyZWFtLnByb3RvdHlwZS5lYXRXaGlsZSA9IGZ1bmN0aW9uIChtYXRjaCkge1xcbiAgdmFyIHN0YXJ0ID0gdGhpcy5wb3M7XFxuICB3aGlsZSAodGhpcy5lYXQobWF0Y2gpKXt9XFxuICByZXR1cm4gdGhpcy5wb3MgPiBzdGFydFxcbn07XFxuU3RyaW5nU3RyZWFtLnByb3RvdHlwZS5lYXRTcGFjZSA9IGZ1bmN0aW9uICgpIHtcXG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XFxuXFxuICB2YXIgc3RhcnQgPSB0aGlzLnBvcztcXG4gIHdoaWxlICgvW1xcXFxzXFxcXHUwMGEwXS8udGVzdCh0aGlzLnN0cmluZy5jaGFyQXQodGhpcy5wb3MpKSkgeyArK3RoaXMkMS5wb3M7IH1cXG4gIHJldHVybiB0aGlzLnBvcyA+IHN0YXJ0XFxufTtcXG5TdHJpbmdTdHJlYW0ucHJvdG90eXBlLnNraXBUb0VuZCA9IGZ1bmN0aW9uICgpIHt0aGlzLnBvcyA9IHRoaXMuc3RyaW5nLmxlbmd0aDt9O1xcblN0cmluZ1N0cmVhbS5wcm90b3R5cGUuc2tpcFRvID0gZnVuY3Rpb24gKGNoKSB7XFxuICB2YXIgZm91bmQgPSB0aGlzLnN0cmluZy5pbmRleE9mKGNoLCB0aGlzLnBvcyk7XFxuICBpZiAoZm91bmQgPiAtMSkge3RoaXMucG9zID0gZm91bmQ7IHJldHVybiB0cnVlfVxcbn07XFxuU3RyaW5nU3RyZWFtLnByb3RvdHlwZS5iYWNrVXAgPSBmdW5jdGlvbiAobikge3RoaXMucG9zIC09IG47fTtcXG5TdHJpbmdTdHJlYW0ucHJvdG90eXBlLmNvbHVtbiA9IGZ1bmN0aW9uICgpIHtcXG4gIGlmICh0aGlzLmxhc3RDb2x1bW5Qb3MgPCB0aGlzLnN0YXJ0KSB7XFxuICAgIHRoaXMubGFzdENvbHVtblZhbHVlID0gY291bnRDb2x1bW4odGhpcy5zdHJpbmcsIHRoaXMuc3RhcnQsIHRoaXMudGFiU2l6ZSwgdGhpcy5sYXN0Q29sdW1uUG9zLCB0aGlzLmxhc3RDb2x1bW5WYWx1ZSk7XFxuICAgIHRoaXMubGFzdENvbHVtblBvcyA9IHRoaXMuc3RhcnQ7XFxuICB9XFxuICByZXR1cm4gdGhpcy5sYXN0Q29sdW1uVmFsdWUgLSAodGhpcy5saW5lU3RhcnQgPyBjb3VudENvbHVtbih0aGlzLnN0cmluZywgdGhpcy5saW5lU3RhcnQsIHRoaXMudGFiU2l6ZSkgOiAwKVxcbn07XFxuU3RyaW5nU3RyZWFtLnByb3RvdHlwZS5pbmRlbnRhdGlvbiA9IGZ1bmN0aW9uICgpIHtcXG4gIHJldHVybiBjb3VudENvbHVtbih0aGlzLnN0cmluZywgbnVsbCwgdGhpcy50YWJTaXplKSAtXFxuICAgICh0aGlzLmxpbmVTdGFydCA/IGNvdW50Q29sdW1uKHRoaXMuc3RyaW5nLCB0aGlzLmxpbmVTdGFydCwgdGhpcy50YWJTaXplKSA6IDApXFxufTtcXG5TdHJpbmdTdHJlYW0ucHJvdG90eXBlLm1hdGNoID0gZnVuY3Rpb24gKHBhdHRlcm4sIGNvbnN1bWUsIGNhc2VJbnNlbnNpdGl2ZSkge1xcbiAgaWYgKHR5cGVvZiBwYXR0ZXJuID09IFxcXCJzdHJpbmdcXFwiKSB7XFxuICAgIHZhciBjYXNlZCA9IGZ1bmN0aW9uIChzdHIpIHsgcmV0dXJuIGNhc2VJbnNlbnNpdGl2ZSA/IHN0ci50b0xvd2VyQ2FzZSgpIDogc3RyOyB9O1xcbiAgICB2YXIgc3Vic3RyID0gdGhpcy5zdHJpbmcuc3Vic3RyKHRoaXMucG9zLCBwYXR0ZXJuLmxlbmd0aCk7XFxuICAgIGlmIChjYXNlZChzdWJzdHIpID09IGNhc2VkKHBhdHRlcm4pKSB7XFxuICAgICAgaWYgKGNvbnN1bWUgIT09IGZhbHNlKSB7IHRoaXMucG9zICs9IHBhdHRlcm4ubGVuZ3RoOyB9XFxuICAgICAgcmV0dXJuIHRydWVcXG4gICAgfVxcbiAgfSBlbHNlIHtcXG4gICAgdmFyIG1hdGNoID0gdGhpcy5zdHJpbmcuc2xpY2UodGhpcy5wb3MpLm1hdGNoKHBhdHRlcm4pO1xcbiAgICBpZiAobWF0Y2ggJiYgbWF0Y2guaW5kZXggPiAwKSB7IHJldHVybiBudWxsIH1cXG4gICAgaWYgKG1hdGNoICYmIGNvbnN1bWUgIT09IGZhbHNlKSB7IHRoaXMucG9zICs9IG1hdGNoWzBdLmxlbmd0aDsgfVxcbiAgICByZXR1cm4gbWF0Y2hcXG4gIH1cXG59O1xcblN0cmluZ1N0cmVhbS5wcm90b3R5cGUuY3VycmVudCA9IGZ1bmN0aW9uICgpe3JldHVybiB0aGlzLnN0cmluZy5zbGljZSh0aGlzLnN0YXJ0LCB0aGlzLnBvcyl9O1xcblN0cmluZ1N0cmVhbS5wcm90b3R5cGUuaGlkZUZpcnN0Q2hhcnMgPSBmdW5jdGlvbiAobiwgaW5uZXIpIHtcXG4gIHRoaXMubGluZVN0YXJ0ICs9IG47XFxuICB0cnkgeyByZXR1cm4gaW5uZXIoKSB9XFxuICBmaW5hbGx5IHsgdGhpcy5saW5lU3RhcnQgLT0gbjsgfVxcbn07XFxuXFxuLy8gQ29tcHV0ZSBhIHN0eWxlIGFycmF5IChhbiBhcnJheSBzdGFydGluZyB3aXRoIGEgbW9kZSBnZW5lcmF0aW9uXFxuLy8gLS0gZm9yIGludmFsaWRhdGlvbiAtLSBmb2xsb3dlZCBieSBwYWlycyBvZiBlbmQgcG9zaXRpb25zIGFuZFxcbi8vIHN0eWxlIHN0cmluZ3MpLCB3aGljaCBpcyB1c2VkIHRvIGhpZ2hsaWdodCB0aGUgdG9rZW5zIG9uIHRoZVxcbi8vIGxpbmUuXFxuZnVuY3Rpb24gaGlnaGxpZ2h0TGluZShjbSwgbGluZSwgc3RhdGUsIGZvcmNlVG9FbmQpIHtcXG4gIC8vIEEgc3R5bGVzIGFycmF5IGFsd2F5cyBzdGFydHMgd2l0aCBhIG51bWJlciBpZGVudGlmeWluZyB0aGVcXG4gIC8vIG1vZGUvb3ZlcmxheXMgdGhhdCBpdCBpcyBiYXNlZCBvbiAoZm9yIGVhc3kgaW52YWxpZGF0aW9uKS5cXG4gIHZhciBzdCA9IFtjbS5zdGF0ZS5tb2RlR2VuXSwgbGluZUNsYXNzZXMgPSB7fTtcXG4gIC8vIENvbXB1dGUgdGhlIGJhc2UgYXJyYXkgb2Ygc3R5bGVzXFxuICBydW5Nb2RlKGNtLCBsaW5lLnRleHQsIGNtLmRvYy5tb2RlLCBzdGF0ZSwgZnVuY3Rpb24gKGVuZCwgc3R5bGUpIHsgcmV0dXJuIHN0LnB1c2goZW5kLCBzdHlsZSk7IH0sXFxuICAgIGxpbmVDbGFzc2VzLCBmb3JjZVRvRW5kKTtcXG5cXG4gIC8vIFJ1biBvdmVybGF5cywgYWRqdXN0IHN0eWxlIGFycmF5LlxcbiAgdmFyIGxvb3AgPSBmdW5jdGlvbiAoIG8gKSB7XFxuICAgIHZhciBvdmVybGF5ID0gY20uc3RhdGUub3ZlcmxheXNbb10sIGkgPSAxLCBhdCA9IDA7XFxuICAgIHJ1bk1vZGUoY20sIGxpbmUudGV4dCwgb3ZlcmxheS5tb2RlLCB0cnVlLCBmdW5jdGlvbiAoZW5kLCBzdHlsZSkge1xcbiAgICAgIHZhciBzdGFydCA9IGk7XFxuICAgICAgLy8gRW5zdXJlIHRoZXJlJ3MgYSB0b2tlbiBlbmQgYXQgdGhlIGN1cnJlbnQgcG9zaXRpb24sIGFuZCB0aGF0IGkgcG9pbnRzIGF0IGl0XFxuICAgICAgd2hpbGUgKGF0IDwgZW5kKSB7XFxuICAgICAgICB2YXIgaV9lbmQgPSBzdFtpXTtcXG4gICAgICAgIGlmIChpX2VuZCA+IGVuZClcXG4gICAgICAgICAgeyBzdC5zcGxpY2UoaSwgMSwgZW5kLCBzdFtpKzFdLCBpX2VuZCk7IH1cXG4gICAgICAgIGkgKz0gMjtcXG4gICAgICAgIGF0ID0gTWF0aC5taW4oZW5kLCBpX2VuZCk7XFxuICAgICAgfVxcbiAgICAgIGlmICghc3R5bGUpIHsgcmV0dXJuIH1cXG4gICAgICBpZiAob3ZlcmxheS5vcGFxdWUpIHtcXG4gICAgICAgIHN0LnNwbGljZShzdGFydCwgaSAtIHN0YXJ0LCBlbmQsIFxcXCJvdmVybGF5IFxcXCIgKyBzdHlsZSk7XFxuICAgICAgICBpID0gc3RhcnQgKyAyO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBmb3IgKDsgc3RhcnQgPCBpOyBzdGFydCArPSAyKSB7XFxuICAgICAgICAgIHZhciBjdXIgPSBzdFtzdGFydCsxXTtcXG4gICAgICAgICAgc3Rbc3RhcnQrMV0gPSAoY3VyID8gY3VyICsgXFxcIiBcXFwiIDogXFxcIlxcXCIpICsgXFxcIm92ZXJsYXkgXFxcIiArIHN0eWxlO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgfSwgbGluZUNsYXNzZXMpO1xcbiAgfTtcXG5cXG4gIGZvciAodmFyIG8gPSAwOyBvIDwgY20uc3RhdGUub3ZlcmxheXMubGVuZ3RoOyArK28pIGxvb3AoIG8gKTtcXG5cXG4gIHJldHVybiB7c3R5bGVzOiBzdCwgY2xhc3NlczogbGluZUNsYXNzZXMuYmdDbGFzcyB8fCBsaW5lQ2xhc3Nlcy50ZXh0Q2xhc3MgPyBsaW5lQ2xhc3NlcyA6IG51bGx9XFxufVxcblxcbmZ1bmN0aW9uIGdldExpbmVTdHlsZXMoY20sIGxpbmUsIHVwZGF0ZUZyb250aWVyKSB7XFxuICBpZiAoIWxpbmUuc3R5bGVzIHx8IGxpbmUuc3R5bGVzWzBdICE9IGNtLnN0YXRlLm1vZGVHZW4pIHtcXG4gICAgdmFyIHN0YXRlID0gZ2V0U3RhdGVCZWZvcmUoY20sIGxpbmVObyhsaW5lKSk7XFxuICAgIHZhciByZXN1bHQgPSBoaWdobGlnaHRMaW5lKGNtLCBsaW5lLCBsaW5lLnRleHQubGVuZ3RoID4gY20ub3B0aW9ucy5tYXhIaWdobGlnaHRMZW5ndGggPyBjb3B5U3RhdGUoY20uZG9jLm1vZGUsIHN0YXRlKSA6IHN0YXRlKTtcXG4gICAgbGluZS5zdGF0ZUFmdGVyID0gc3RhdGU7XFxuICAgIGxpbmUuc3R5bGVzID0gcmVzdWx0LnN0eWxlcztcXG4gICAgaWYgKHJlc3VsdC5jbGFzc2VzKSB7IGxpbmUuc3R5bGVDbGFzc2VzID0gcmVzdWx0LmNsYXNzZXM7IH1cXG4gICAgZWxzZSBpZiAobGluZS5zdHlsZUNsYXNzZXMpIHsgbGluZS5zdHlsZUNsYXNzZXMgPSBudWxsOyB9XFxuICAgIGlmICh1cGRhdGVGcm9udGllciA9PT0gY20uZG9jLmZyb250aWVyKSB7IGNtLmRvYy5mcm9udGllcisrOyB9XFxuICB9XFxuICByZXR1cm4gbGluZS5zdHlsZXNcXG59XFxuXFxuZnVuY3Rpb24gZ2V0U3RhdGVCZWZvcmUoY20sIG4sIHByZWNpc2UpIHtcXG4gIHZhciBkb2MgPSBjbS5kb2MsIGRpc3BsYXkgPSBjbS5kaXNwbGF5O1xcbiAgaWYgKCFkb2MubW9kZS5zdGFydFN0YXRlKSB7IHJldHVybiB0cnVlIH1cXG4gIHZhciBwb3MgPSBmaW5kU3RhcnRMaW5lKGNtLCBuLCBwcmVjaXNlKSwgc3RhdGUgPSBwb3MgPiBkb2MuZmlyc3QgJiYgZ2V0TGluZShkb2MsIHBvcy0xKS5zdGF0ZUFmdGVyO1xcbiAgaWYgKCFzdGF0ZSkgeyBzdGF0ZSA9IHN0YXJ0U3RhdGUoZG9jLm1vZGUpOyB9XFxuICBlbHNlIHsgc3RhdGUgPSBjb3B5U3RhdGUoZG9jLm1vZGUsIHN0YXRlKTsgfVxcbiAgZG9jLml0ZXIocG9zLCBuLCBmdW5jdGlvbiAobGluZSkge1xcbiAgICBwcm9jZXNzTGluZShjbSwgbGluZS50ZXh0LCBzdGF0ZSk7XFxuICAgIHZhciBzYXZlID0gcG9zID09IG4gLSAxIHx8IHBvcyAlIDUgPT0gMCB8fCBwb3MgPj0gZGlzcGxheS52aWV3RnJvbSAmJiBwb3MgPCBkaXNwbGF5LnZpZXdUbztcXG4gICAgbGluZS5zdGF0ZUFmdGVyID0gc2F2ZSA/IGNvcHlTdGF0ZShkb2MubW9kZSwgc3RhdGUpIDogbnVsbDtcXG4gICAgKytwb3M7XFxuICB9KTtcXG4gIGlmIChwcmVjaXNlKSB7IGRvYy5mcm9udGllciA9IHBvczsgfVxcbiAgcmV0dXJuIHN0YXRlXFxufVxcblxcbi8vIExpZ2h0d2VpZ2h0IGZvcm0gb2YgaGlnaGxpZ2h0IC0tIHByb2NlZWQgb3ZlciB0aGlzIGxpbmUgYW5kXFxuLy8gdXBkYXRlIHN0YXRlLCBidXQgZG9uJ3Qgc2F2ZSBhIHN0eWxlIGFycmF5LiBVc2VkIGZvciBsaW5lcyB0aGF0XFxuLy8gYXJlbid0IGN1cnJlbnRseSB2aXNpYmxlLlxcbmZ1bmN0aW9uIHByb2Nlc3NMaW5lKGNtLCB0ZXh0LCBzdGF0ZSwgc3RhcnRBdCkge1xcbiAgdmFyIG1vZGUgPSBjbS5kb2MubW9kZTtcXG4gIHZhciBzdHJlYW0gPSBuZXcgU3RyaW5nU3RyZWFtKHRleHQsIGNtLm9wdGlvbnMudGFiU2l6ZSk7XFxuICBzdHJlYW0uc3RhcnQgPSBzdHJlYW0ucG9zID0gc3RhcnRBdCB8fCAwO1xcbiAgaWYgKHRleHQgPT0gXFxcIlxcXCIpIHsgY2FsbEJsYW5rTGluZShtb2RlLCBzdGF0ZSk7IH1cXG4gIHdoaWxlICghc3RyZWFtLmVvbCgpKSB7XFxuICAgIHJlYWRUb2tlbihtb2RlLCBzdHJlYW0sIHN0YXRlKTtcXG4gICAgc3RyZWFtLnN0YXJ0ID0gc3RyZWFtLnBvcztcXG4gIH1cXG59XFxuXFxuZnVuY3Rpb24gY2FsbEJsYW5rTGluZShtb2RlLCBzdGF0ZSkge1xcbiAgaWYgKG1vZGUuYmxhbmtMaW5lKSB7IHJldHVybiBtb2RlLmJsYW5rTGluZShzdGF0ZSkgfVxcbiAgaWYgKCFtb2RlLmlubmVyTW9kZSkgeyByZXR1cm4gfVxcbiAgdmFyIGlubmVyID0gaW5uZXJNb2RlKG1vZGUsIHN0YXRlKTtcXG4gIGlmIChpbm5lci5tb2RlLmJsYW5rTGluZSkgeyByZXR1cm4gaW5uZXIubW9kZS5ibGFua0xpbmUoaW5uZXIuc3RhdGUpIH1cXG59XFxuXFxuZnVuY3Rpb24gcmVhZFRva2VuKG1vZGUsIHN0cmVhbSwgc3RhdGUsIGlubmVyKSB7XFxuICBmb3IgKHZhciBpID0gMDsgaSA8IDEwOyBpKyspIHtcXG4gICAgaWYgKGlubmVyKSB7IGlubmVyWzBdID0gaW5uZXJNb2RlKG1vZGUsIHN0YXRlKS5tb2RlOyB9XFxuICAgIHZhciBzdHlsZSA9IG1vZGUudG9rZW4oc3RyZWFtLCBzdGF0ZSk7XFxuICAgIGlmIChzdHJlYW0ucG9zID4gc3RyZWFtLnN0YXJ0KSB7IHJldHVybiBzdHlsZSB9XFxuICB9XFxuICB0aHJvdyBuZXcgRXJyb3IoXFxcIk1vZGUgXFxcIiArIG1vZGUubmFtZSArIFxcXCIgZmFpbGVkIHRvIGFkdmFuY2Ugc3RyZWFtLlxcXCIpXFxufVxcblxcbi8vIFV0aWxpdHkgZm9yIGdldFRva2VuQXQgYW5kIGdldExpbmVUb2tlbnNcXG5mdW5jdGlvbiB0YWtlVG9rZW4oY20sIHBvcywgcHJlY2lzZSwgYXNBcnJheSkge1xcbiAgdmFyIGdldE9iaiA9IGZ1bmN0aW9uIChjb3B5KSB7IHJldHVybiAoe1xcbiAgICBzdGFydDogc3RyZWFtLnN0YXJ0LCBlbmQ6IHN0cmVhbS5wb3MsXFxuICAgIHN0cmluZzogc3RyZWFtLmN1cnJlbnQoKSxcXG4gICAgdHlwZTogc3R5bGUgfHwgbnVsbCxcXG4gICAgc3RhdGU6IGNvcHkgPyBjb3B5U3RhdGUoZG9jLm1vZGUsIHN0YXRlKSA6IHN0YXRlXFxuICB9KTsgfTtcXG5cXG4gIHZhciBkb2MgPSBjbS5kb2MsIG1vZGUgPSBkb2MubW9kZSwgc3R5bGU7XFxuICBwb3MgPSBjbGlwUG9zKGRvYywgcG9zKTtcXG4gIHZhciBsaW5lID0gZ2V0TGluZShkb2MsIHBvcy5saW5lKSwgc3RhdGUgPSBnZXRTdGF0ZUJlZm9yZShjbSwgcG9zLmxpbmUsIHByZWNpc2UpO1xcbiAgdmFyIHN0cmVhbSA9IG5ldyBTdHJpbmdTdHJlYW0obGluZS50ZXh0LCBjbS5vcHRpb25zLnRhYlNpemUpLCB0b2tlbnM7XFxuICBpZiAoYXNBcnJheSkgeyB0b2tlbnMgPSBbXTsgfVxcbiAgd2hpbGUgKChhc0FycmF5IHx8IHN0cmVhbS5wb3MgPCBwb3MuY2gpICYmICFzdHJlYW0uZW9sKCkpIHtcXG4gICAgc3RyZWFtLnN0YXJ0ID0gc3RyZWFtLnBvcztcXG4gICAgc3R5bGUgPSByZWFkVG9rZW4obW9kZSwgc3RyZWFtLCBzdGF0ZSk7XFxuICAgIGlmIChhc0FycmF5KSB7IHRva2Vucy5wdXNoKGdldE9iaih0cnVlKSk7IH1cXG4gIH1cXG4gIHJldHVybiBhc0FycmF5ID8gdG9rZW5zIDogZ2V0T2JqKClcXG59XFxuXFxuZnVuY3Rpb24gZXh0cmFjdExpbmVDbGFzc2VzKHR5cGUsIG91dHB1dCkge1xcbiAgaWYgKHR5cGUpIHsgZm9yICg7Oykge1xcbiAgICB2YXIgbGluZUNsYXNzID0gdHlwZS5tYXRjaCgvKD86XnxcXFxccyspbGluZS0oYmFja2dyb3VuZC0pPyhcXFxcUyspLyk7XFxuICAgIGlmICghbGluZUNsYXNzKSB7IGJyZWFrIH1cXG4gICAgdHlwZSA9IHR5cGUuc2xpY2UoMCwgbGluZUNsYXNzLmluZGV4KSArIHR5cGUuc2xpY2UobGluZUNsYXNzLmluZGV4ICsgbGluZUNsYXNzWzBdLmxlbmd0aCk7XFxuICAgIHZhciBwcm9wID0gbGluZUNsYXNzWzFdID8gXFxcImJnQ2xhc3NcXFwiIDogXFxcInRleHRDbGFzc1xcXCI7XFxuICAgIGlmIChvdXRwdXRbcHJvcF0gPT0gbnVsbClcXG4gICAgICB7IG91dHB1dFtwcm9wXSA9IGxpbmVDbGFzc1syXTsgfVxcbiAgICBlbHNlIGlmICghKG5ldyBSZWdFeHAoXFxcIig/Ol58XFxcXHMpXFxcIiArIGxpbmVDbGFzc1syXSArIFxcXCIoPzokfFxcXFxzKVxcXCIpKS50ZXN0KG91dHB1dFtwcm9wXSkpXFxuICAgICAgeyBvdXRwdXRbcHJvcF0gKz0gXFxcIiBcXFwiICsgbGluZUNsYXNzWzJdOyB9XFxuICB9IH1cXG4gIHJldHVybiB0eXBlXFxufVxcblxcbi8vIFJ1biB0aGUgZ2l2ZW4gbW9kZSdzIHBhcnNlciBvdmVyIGEgbGluZSwgY2FsbGluZyBmIGZvciBlYWNoIHRva2VuLlxcbmZ1bmN0aW9uIHJ1bk1vZGUoY20sIHRleHQsIG1vZGUsIHN0YXRlLCBmLCBsaW5lQ2xhc3NlcywgZm9yY2VUb0VuZCkge1xcbiAgdmFyIGZsYXR0ZW5TcGFucyA9IG1vZGUuZmxhdHRlblNwYW5zO1xcbiAgaWYgKGZsYXR0ZW5TcGFucyA9PSBudWxsKSB7IGZsYXR0ZW5TcGFucyA9IGNtLm9wdGlvbnMuZmxhdHRlblNwYW5zOyB9XFxuICB2YXIgY3VyU3RhcnQgPSAwLCBjdXJTdHlsZSA9IG51bGw7XFxuICB2YXIgc3RyZWFtID0gbmV3IFN0cmluZ1N0cmVhbSh0ZXh0LCBjbS5vcHRpb25zLnRhYlNpemUpLCBzdHlsZTtcXG4gIHZhciBpbm5lciA9IGNtLm9wdGlvbnMuYWRkTW9kZUNsYXNzICYmIFtudWxsXTtcXG4gIGlmICh0ZXh0ID09IFxcXCJcXFwiKSB7IGV4dHJhY3RMaW5lQ2xhc3NlcyhjYWxsQmxhbmtMaW5lKG1vZGUsIHN0YXRlKSwgbGluZUNsYXNzZXMpOyB9XFxuICB3aGlsZSAoIXN0cmVhbS5lb2woKSkge1xcbiAgICBpZiAoc3RyZWFtLnBvcyA+IGNtLm9wdGlvbnMubWF4SGlnaGxpZ2h0TGVuZ3RoKSB7XFxuICAgICAgZmxhdHRlblNwYW5zID0gZmFsc2U7XFxuICAgICAgaWYgKGZvcmNlVG9FbmQpIHsgcHJvY2Vzc0xpbmUoY20sIHRleHQsIHN0YXRlLCBzdHJlYW0ucG9zKTsgfVxcbiAgICAgIHN0cmVhbS5wb3MgPSB0ZXh0Lmxlbmd0aDtcXG4gICAgICBzdHlsZSA9IG51bGw7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgc3R5bGUgPSBleHRyYWN0TGluZUNsYXNzZXMocmVhZFRva2VuKG1vZGUsIHN0cmVhbSwgc3RhdGUsIGlubmVyKSwgbGluZUNsYXNzZXMpO1xcbiAgICB9XFxuICAgIGlmIChpbm5lcikge1xcbiAgICAgIHZhciBtTmFtZSA9IGlubmVyWzBdLm5hbWU7XFxuICAgICAgaWYgKG1OYW1lKSB7IHN0eWxlID0gXFxcIm0tXFxcIiArIChzdHlsZSA/IG1OYW1lICsgXFxcIiBcXFwiICsgc3R5bGUgOiBtTmFtZSk7IH1cXG4gICAgfVxcbiAgICBpZiAoIWZsYXR0ZW5TcGFucyB8fCBjdXJTdHlsZSAhPSBzdHlsZSkge1xcbiAgICAgIHdoaWxlIChjdXJTdGFydCA8IHN0cmVhbS5zdGFydCkge1xcbiAgICAgICAgY3VyU3RhcnQgPSBNYXRoLm1pbihzdHJlYW0uc3RhcnQsIGN1clN0YXJ0ICsgNTAwMCk7XFxuICAgICAgICBmKGN1clN0YXJ0LCBjdXJTdHlsZSk7XFxuICAgICAgfVxcbiAgICAgIGN1clN0eWxlID0gc3R5bGU7XFxuICAgIH1cXG4gICAgc3RyZWFtLnN0YXJ0ID0gc3RyZWFtLnBvcztcXG4gIH1cXG4gIHdoaWxlIChjdXJTdGFydCA8IHN0cmVhbS5wb3MpIHtcXG4gICAgLy8gV2Via2l0IHNlZW1zIHRvIHJlZnVzZSB0byByZW5kZXIgdGV4dCBub2RlcyBsb25nZXIgdGhhbiA1NzQ0NFxcbiAgICAvLyBjaGFyYWN0ZXJzLCBhbmQgcmV0dXJucyBpbmFjY3VyYXRlIG1lYXN1cmVtZW50cyBpbiBub2Rlc1xcbiAgICAvLyBzdGFydGluZyBhcm91bmQgNTAwMCBjaGFycy5cXG4gICAgdmFyIHBvcyA9IE1hdGgubWluKHN0cmVhbS5wb3MsIGN1clN0YXJ0ICsgNTAwMCk7XFxuICAgIGYocG9zLCBjdXJTdHlsZSk7XFxuICAgIGN1clN0YXJ0ID0gcG9zO1xcbiAgfVxcbn1cXG5cXG4vLyBGaW5kcyB0aGUgbGluZSB0byBzdGFydCB3aXRoIHdoZW4gc3RhcnRpbmcgYSBwYXJzZS4gVHJpZXMgdG9cXG4vLyBmaW5kIGEgbGluZSB3aXRoIGEgc3RhdGVBZnRlciwgc28gdGhhdCBpdCBjYW4gc3RhcnQgd2l0aCBhXFxuLy8gdmFsaWQgc3RhdGUuIElmIHRoYXQgZmFpbHMsIGl0IHJldHVybnMgdGhlIGxpbmUgd2l0aCB0aGVcXG4vLyBzbWFsbGVzdCBpbmRlbnRhdGlvbiwgd2hpY2ggdGVuZHMgdG8gbmVlZCB0aGUgbGVhc3QgY29udGV4dCB0b1xcbi8vIHBhcnNlIGNvcnJlY3RseS5cXG5mdW5jdGlvbiBmaW5kU3RhcnRMaW5lKGNtLCBuLCBwcmVjaXNlKSB7XFxuICB2YXIgbWluaW5kZW50LCBtaW5saW5lLCBkb2MgPSBjbS5kb2M7XFxuICB2YXIgbGltID0gcHJlY2lzZSA/IC0xIDogbiAtIChjbS5kb2MubW9kZS5pbm5lck1vZGUgPyAxMDAwIDogMTAwKTtcXG4gIGZvciAodmFyIHNlYXJjaCA9IG47IHNlYXJjaCA+IGxpbTsgLS1zZWFyY2gpIHtcXG4gICAgaWYgKHNlYXJjaCA8PSBkb2MuZmlyc3QpIHsgcmV0dXJuIGRvYy5maXJzdCB9XFxuICAgIHZhciBsaW5lID0gZ2V0TGluZShkb2MsIHNlYXJjaCAtIDEpO1xcbiAgICBpZiAobGluZS5zdGF0ZUFmdGVyICYmICghcHJlY2lzZSB8fCBzZWFyY2ggPD0gZG9jLmZyb250aWVyKSkgeyByZXR1cm4gc2VhcmNoIH1cXG4gICAgdmFyIGluZGVudGVkID0gY291bnRDb2x1bW4obGluZS50ZXh0LCBudWxsLCBjbS5vcHRpb25zLnRhYlNpemUpO1xcbiAgICBpZiAobWlubGluZSA9PSBudWxsIHx8IG1pbmluZGVudCA+IGluZGVudGVkKSB7XFxuICAgICAgbWlubGluZSA9IHNlYXJjaCAtIDE7XFxuICAgICAgbWluaW5kZW50ID0gaW5kZW50ZWQ7XFxuICAgIH1cXG4gIH1cXG4gIHJldHVybiBtaW5saW5lXFxufVxcblxcbi8vIExJTkUgREFUQSBTVFJVQ1RVUkVcXG5cXG4vLyBMaW5lIG9iamVjdHMuIFRoZXNlIGhvbGQgc3RhdGUgcmVsYXRlZCB0byBhIGxpbmUsIGluY2x1ZGluZ1xcbi8vIGhpZ2hsaWdodGluZyBpbmZvICh0aGUgc3R5bGVzIGFycmF5KS5cXG52YXIgTGluZSA9IGZ1bmN0aW9uKHRleHQsIG1hcmtlZFNwYW5zLCBlc3RpbWF0ZUhlaWdodCkge1xcbiAgdGhpcy50ZXh0ID0gdGV4dDtcXG4gIGF0dGFjaE1hcmtlZFNwYW5zKHRoaXMsIG1hcmtlZFNwYW5zKTtcXG4gIHRoaXMuaGVpZ2h0ID0gZXN0aW1hdGVIZWlnaHQgPyBlc3RpbWF0ZUhlaWdodCh0aGlzKSA6IDE7XFxufTtcXG5cXG5MaW5lLnByb3RvdHlwZS5saW5lTm8gPSBmdW5jdGlvbiAoKSB7IHJldHVybiBsaW5lTm8odGhpcykgfTtcXG5ldmVudE1peGluKExpbmUpO1xcblxcbi8vIENoYW5nZSB0aGUgY29udGVudCAodGV4dCwgbWFya2Vycykgb2YgYSBsaW5lLiBBdXRvbWF0aWNhbGx5XFxuLy8gaW52YWxpZGF0ZXMgY2FjaGVkIGluZm9ybWF0aW9uIGFuZCB0cmllcyB0byByZS1lc3RpbWF0ZSB0aGVcXG4vLyBsaW5lJ3MgaGVpZ2h0LlxcbmZ1bmN0aW9uIHVwZGF0ZUxpbmUobGluZSwgdGV4dCwgbWFya2VkU3BhbnMsIGVzdGltYXRlSGVpZ2h0KSB7XFxuICBsaW5lLnRleHQgPSB0ZXh0O1xcbiAgaWYgKGxpbmUuc3RhdGVBZnRlcikgeyBsaW5lLnN0YXRlQWZ0ZXIgPSBudWxsOyB9XFxuICBpZiAobGluZS5zdHlsZXMpIHsgbGluZS5zdHlsZXMgPSBudWxsOyB9XFxuICBpZiAobGluZS5vcmRlciAhPSBudWxsKSB7IGxpbmUub3JkZXIgPSBudWxsOyB9XFxuICBkZXRhY2hNYXJrZWRTcGFucyhsaW5lKTtcXG4gIGF0dGFjaE1hcmtlZFNwYW5zKGxpbmUsIG1hcmtlZFNwYW5zKTtcXG4gIHZhciBlc3RIZWlnaHQgPSBlc3RpbWF0ZUhlaWdodCA/IGVzdGltYXRlSGVpZ2h0KGxpbmUpIDogMTtcXG4gIGlmIChlc3RIZWlnaHQgIT0gbGluZS5oZWlnaHQpIHsgdXBkYXRlTGluZUhlaWdodChsaW5lLCBlc3RIZWlnaHQpOyB9XFxufVxcblxcbi8vIERldGFjaCBhIGxpbmUgZnJvbSB0aGUgZG9jdW1lbnQgdHJlZSBhbmQgaXRzIG1hcmtlcnMuXFxuZnVuY3Rpb24gY2xlYW5VcExpbmUobGluZSkge1xcbiAgbGluZS5wYXJlbnQgPSBudWxsO1xcbiAgZGV0YWNoTWFya2VkU3BhbnMobGluZSk7XFxufVxcblxcbi8vIENvbnZlcnQgYSBzdHlsZSBhcyByZXR1cm5lZCBieSBhIG1vZGUgKGVpdGhlciBudWxsLCBvciBhIHN0cmluZ1xcbi8vIGNvbnRhaW5pbmcgb25lIG9yIG1vcmUgc3R5bGVzKSB0byBhIENTUyBzdHlsZS4gVGhpcyBpcyBjYWNoZWQsXFxuLy8gYW5kIGFsc28gbG9va3MgZm9yIGxpbmUtd2lkZSBzdHlsZXMuXFxudmFyIHN0eWxlVG9DbGFzc0NhY2hlID0ge307XFxudmFyIHN0eWxlVG9DbGFzc0NhY2hlV2l0aE1vZGUgPSB7fTtcXG5mdW5jdGlvbiBpbnRlcnByZXRUb2tlblN0eWxlKHN0eWxlLCBvcHRpb25zKSB7XFxuICBpZiAoIXN0eWxlIHx8IC9eXFxcXHMqJC8udGVzdChzdHlsZSkpIHsgcmV0dXJuIG51bGwgfVxcbiAgdmFyIGNhY2hlID0gb3B0aW9ucy5hZGRNb2RlQ2xhc3MgPyBzdHlsZVRvQ2xhc3NDYWNoZVdpdGhNb2RlIDogc3R5bGVUb0NsYXNzQ2FjaGU7XFxuICByZXR1cm4gY2FjaGVbc3R5bGVdIHx8XFxuICAgIChjYWNoZVtzdHlsZV0gPSBzdHlsZS5yZXBsYWNlKC9cXFxcUysvZywgXFxcImNtLSQmXFxcIikpXFxufVxcblxcbi8vIFJlbmRlciB0aGUgRE9NIHJlcHJlc2VudGF0aW9uIG9mIHRoZSB0ZXh0IG9mIGEgbGluZS4gQWxzbyBidWlsZHNcXG4vLyB1cCBhICdsaW5lIG1hcCcsIHdoaWNoIHBvaW50cyBhdCB0aGUgRE9NIG5vZGVzIHRoYXQgcmVwcmVzZW50XFxuLy8gc3BlY2lmaWMgc3RyZXRjaGVzIG9mIHRleHQsIGFuZCBpcyB1c2VkIGJ5IHRoZSBtZWFzdXJpbmcgY29kZS5cXG4vLyBUaGUgcmV0dXJuZWQgb2JqZWN0IGNvbnRhaW5zIHRoZSBET00gbm9kZSwgdGhpcyBtYXAsIGFuZFxcbi8vIGluZm9ybWF0aW9uIGFib3V0IGxpbmUtd2lkZSBzdHlsZXMgdGhhdCB3ZXJlIHNldCBieSB0aGUgbW9kZS5cXG5mdW5jdGlvbiBidWlsZExpbmVDb250ZW50KGNtLCBsaW5lVmlldykge1xcbiAgLy8gVGhlIHBhZGRpbmctcmlnaHQgZm9yY2VzIHRoZSBlbGVtZW50IHRvIGhhdmUgYSAnYm9yZGVyJywgd2hpY2hcXG4gIC8vIGlzIG5lZWRlZCBvbiBXZWJraXQgdG8gYmUgYWJsZSB0byBnZXQgbGluZS1sZXZlbCBib3VuZGluZ1xcbiAgLy8gcmVjdGFuZ2xlcyBmb3IgaXQgKGluIG1lYXN1cmVDaGFyKS5cXG4gIHZhciBjb250ZW50ID0gZWx0UChcXFwic3BhblxcXCIsIG51bGwsIG51bGwsIHdlYmtpdCA/IFxcXCJwYWRkaW5nLXJpZ2h0OiAuMXB4XFxcIiA6IG51bGwpO1xcbiAgdmFyIGJ1aWxkZXIgPSB7cHJlOiBlbHRQKFxcXCJwcmVcXFwiLCBbY29udGVudF0sIFxcXCJDb2RlTWlycm9yLWxpbmVcXFwiKSwgY29udGVudDogY29udGVudCxcXG4gICAgICAgICAgICAgICAgIGNvbDogMCwgcG9zOiAwLCBjbTogY20sXFxuICAgICAgICAgICAgICAgICB0cmFpbGluZ1NwYWNlOiBmYWxzZSxcXG4gICAgICAgICAgICAgICAgIHNwbGl0U3BhY2VzOiAoaWUgfHwgd2Via2l0KSAmJiBjbS5nZXRPcHRpb24oXFxcImxpbmVXcmFwcGluZ1xcXCIpfTtcXG4gIGxpbmVWaWV3Lm1lYXN1cmUgPSB7fTtcXG5cXG4gIC8vIEl0ZXJhdGUgb3ZlciB0aGUgbG9naWNhbCBsaW5lcyB0aGF0IG1ha2UgdXAgdGhpcyB2aXN1YWwgbGluZS5cXG4gIGZvciAodmFyIGkgPSAwOyBpIDw9IChsaW5lVmlldy5yZXN0ID8gbGluZVZpZXcucmVzdC5sZW5ndGggOiAwKTsgaSsrKSB7XFxuICAgIHZhciBsaW5lID0gaSA/IGxpbmVWaWV3LnJlc3RbaSAtIDFdIDogbGluZVZpZXcubGluZSwgb3JkZXIgPSAodm9pZCAwKTtcXG4gICAgYnVpbGRlci5wb3MgPSAwO1xcbiAgICBidWlsZGVyLmFkZFRva2VuID0gYnVpbGRUb2tlbjtcXG4gICAgLy8gT3B0aW9uYWxseSB3aXJlIGluIHNvbWUgaGFja3MgaW50byB0aGUgdG9rZW4tcmVuZGVyaW5nXFxuICAgIC8vIGFsZ29yaXRobSwgdG8gZGVhbCB3aXRoIGJyb3dzZXIgcXVpcmtzLlxcbiAgICBpZiAoaGFzQmFkQmlkaVJlY3RzKGNtLmRpc3BsYXkubWVhc3VyZSkgJiYgKG9yZGVyID0gZ2V0T3JkZXIobGluZSwgY20uZG9jLmRpcmVjdGlvbikpKVxcbiAgICAgIHsgYnVpbGRlci5hZGRUb2tlbiA9IGJ1aWxkVG9rZW5CYWRCaWRpKGJ1aWxkZXIuYWRkVG9rZW4sIG9yZGVyKTsgfVxcbiAgICBidWlsZGVyLm1hcCA9IFtdO1xcbiAgICB2YXIgYWxsb3dGcm9udGllclVwZGF0ZSA9IGxpbmVWaWV3ICE9IGNtLmRpc3BsYXkuZXh0ZXJuYWxNZWFzdXJlZCAmJiBsaW5lTm8obGluZSk7XFxuICAgIGluc2VydExpbmVDb250ZW50KGxpbmUsIGJ1aWxkZXIsIGdldExpbmVTdHlsZXMoY20sIGxpbmUsIGFsbG93RnJvbnRpZXJVcGRhdGUpKTtcXG4gICAgaWYgKGxpbmUuc3R5bGVDbGFzc2VzKSB7XFxuICAgICAgaWYgKGxpbmUuc3R5bGVDbGFzc2VzLmJnQ2xhc3MpXFxuICAgICAgICB7IGJ1aWxkZXIuYmdDbGFzcyA9IGpvaW5DbGFzc2VzKGxpbmUuc3R5bGVDbGFzc2VzLmJnQ2xhc3MsIGJ1aWxkZXIuYmdDbGFzcyB8fCBcXFwiXFxcIik7IH1cXG4gICAgICBpZiAobGluZS5zdHlsZUNsYXNzZXMudGV4dENsYXNzKVxcbiAgICAgICAgeyBidWlsZGVyLnRleHRDbGFzcyA9IGpvaW5DbGFzc2VzKGxpbmUuc3R5bGVDbGFzc2VzLnRleHRDbGFzcywgYnVpbGRlci50ZXh0Q2xhc3MgfHwgXFxcIlxcXCIpOyB9XFxuICAgIH1cXG5cXG4gICAgLy8gRW5zdXJlIGF0IGxlYXN0IGEgc2luZ2xlIG5vZGUgaXMgcHJlc2VudCwgZm9yIG1lYXN1cmluZy5cXG4gICAgaWYgKGJ1aWxkZXIubWFwLmxlbmd0aCA9PSAwKVxcbiAgICAgIHsgYnVpbGRlci5tYXAucHVzaCgwLCAwLCBidWlsZGVyLmNvbnRlbnQuYXBwZW5kQ2hpbGQoemVyb1dpZHRoRWxlbWVudChjbS5kaXNwbGF5Lm1lYXN1cmUpKSk7IH1cXG5cXG4gICAgLy8gU3RvcmUgdGhlIG1hcCBhbmQgYSBjYWNoZSBvYmplY3QgZm9yIHRoZSBjdXJyZW50IGxvZ2ljYWwgbGluZVxcbiAgICBpZiAoaSA9PSAwKSB7XFxuICAgICAgbGluZVZpZXcubWVhc3VyZS5tYXAgPSBidWlsZGVyLm1hcDtcXG4gICAgICBsaW5lVmlldy5tZWFzdXJlLmNhY2hlID0ge307XFxuICAgIH0gZWxzZSB7XFxuICAgICAgKGxpbmVWaWV3Lm1lYXN1cmUubWFwcyB8fCAobGluZVZpZXcubWVhc3VyZS5tYXBzID0gW10pKS5wdXNoKGJ1aWxkZXIubWFwKVxcbiAgICAgIDsobGluZVZpZXcubWVhc3VyZS5jYWNoZXMgfHwgKGxpbmVWaWV3Lm1lYXN1cmUuY2FjaGVzID0gW10pKS5wdXNoKHt9KTtcXG4gICAgfVxcbiAgfVxcblxcbiAgLy8gU2VlIGlzc3VlICMyOTAxXFxuICBpZiAod2Via2l0KSB7XFxuICAgIHZhciBsYXN0ID0gYnVpbGRlci5jb250ZW50Lmxhc3RDaGlsZDtcXG4gICAgaWYgKC9cXFxcYmNtLXRhYlxcXFxiLy50ZXN0KGxhc3QuY2xhc3NOYW1lKSB8fCAobGFzdC5xdWVyeVNlbGVjdG9yICYmIGxhc3QucXVlcnlTZWxlY3RvcihcXFwiLmNtLXRhYlxcXCIpKSlcXG4gICAgICB7IGJ1aWxkZXIuY29udGVudC5jbGFzc05hbWUgPSBcXFwiY20tdGFiLXdyYXAtaGFja1xcXCI7IH1cXG4gIH1cXG5cXG4gIHNpZ25hbChjbSwgXFxcInJlbmRlckxpbmVcXFwiLCBjbSwgbGluZVZpZXcubGluZSwgYnVpbGRlci5wcmUpO1xcbiAgaWYgKGJ1aWxkZXIucHJlLmNsYXNzTmFtZSlcXG4gICAgeyBidWlsZGVyLnRleHRDbGFzcyA9IGpvaW5DbGFzc2VzKGJ1aWxkZXIucHJlLmNsYXNzTmFtZSwgYnVpbGRlci50ZXh0Q2xhc3MgfHwgXFxcIlxcXCIpOyB9XFxuXFxuICByZXR1cm4gYnVpbGRlclxcbn1cXG5cXG5mdW5jdGlvbiBkZWZhdWx0U3BlY2lhbENoYXJQbGFjZWhvbGRlcihjaCkge1xcbiAgdmFyIHRva2VuID0gZWx0KFxcXCJzcGFuXFxcIiwgXFxcIlxcXFx1MjAyMlxcXCIsIFxcXCJjbS1pbnZhbGlkY2hhclxcXCIpO1xcbiAgdG9rZW4udGl0bGUgPSBcXFwiXFxcXFxcXFx1XFxcIiArIGNoLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpO1xcbiAgdG9rZW4uc2V0QXR0cmlidXRlKFxcXCJhcmlhLWxhYmVsXFxcIiwgdG9rZW4udGl0bGUpO1xcbiAgcmV0dXJuIHRva2VuXFxufVxcblxcbi8vIEJ1aWxkIHVwIHRoZSBET00gcmVwcmVzZW50YXRpb24gZm9yIGEgc2luZ2xlIHRva2VuLCBhbmQgYWRkIGl0IHRvXFxuLy8gdGhlIGxpbmUgbWFwLiBUYWtlcyBjYXJlIHRvIHJlbmRlciBzcGVjaWFsIGNoYXJhY3RlcnMgc2VwYXJhdGVseS5cXG5mdW5jdGlvbiBidWlsZFRva2VuKGJ1aWxkZXIsIHRleHQsIHN0eWxlLCBzdGFydFN0eWxlLCBlbmRTdHlsZSwgdGl0bGUsIGNzcykge1xcbiAgaWYgKCF0ZXh0KSB7IHJldHVybiB9XFxuICB2YXIgZGlzcGxheVRleHQgPSBidWlsZGVyLnNwbGl0U3BhY2VzID8gc3BsaXRTcGFjZXModGV4dCwgYnVpbGRlci50cmFpbGluZ1NwYWNlKSA6IHRleHQ7XFxuICB2YXIgc3BlY2lhbCA9IGJ1aWxkZXIuY20uc3RhdGUuc3BlY2lhbENoYXJzLCBtdXN0V3JhcCA9IGZhbHNlO1xcbiAgdmFyIGNvbnRlbnQ7XFxuICBpZiAoIXNwZWNpYWwudGVzdCh0ZXh0KSkge1xcbiAgICBidWlsZGVyLmNvbCArPSB0ZXh0Lmxlbmd0aDtcXG4gICAgY29udGVudCA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGRpc3BsYXlUZXh0KTtcXG4gICAgYnVpbGRlci5tYXAucHVzaChidWlsZGVyLnBvcywgYnVpbGRlci5wb3MgKyB0ZXh0Lmxlbmd0aCwgY29udGVudCk7XFxuICAgIGlmIChpZSAmJiBpZV92ZXJzaW9uIDwgOSkgeyBtdXN0V3JhcCA9IHRydWU7IH1cXG4gICAgYnVpbGRlci5wb3MgKz0gdGV4dC5sZW5ndGg7XFxuICB9IGVsc2Uge1xcbiAgICBjb250ZW50ID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xcbiAgICB2YXIgcG9zID0gMDtcXG4gICAgd2hpbGUgKHRydWUpIHtcXG4gICAgICBzcGVjaWFsLmxhc3RJbmRleCA9IHBvcztcXG4gICAgICB2YXIgbSA9IHNwZWNpYWwuZXhlYyh0ZXh0KTtcXG4gICAgICB2YXIgc2tpcHBlZCA9IG0gPyBtLmluZGV4IC0gcG9zIDogdGV4dC5sZW5ndGggLSBwb3M7XFxuICAgICAgaWYgKHNraXBwZWQpIHtcXG4gICAgICAgIHZhciB0eHQgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShkaXNwbGF5VGV4dC5zbGljZShwb3MsIHBvcyArIHNraXBwZWQpKTtcXG4gICAgICAgIGlmIChpZSAmJiBpZV92ZXJzaW9uIDwgOSkgeyBjb250ZW50LmFwcGVuZENoaWxkKGVsdChcXFwic3BhblxcXCIsIFt0eHRdKSk7IH1cXG4gICAgICAgIGVsc2UgeyBjb250ZW50LmFwcGVuZENoaWxkKHR4dCk7IH1cXG4gICAgICAgIGJ1aWxkZXIubWFwLnB1c2goYnVpbGRlci5wb3MsIGJ1aWxkZXIucG9zICsgc2tpcHBlZCwgdHh0KTtcXG4gICAgICAgIGJ1aWxkZXIuY29sICs9IHNraXBwZWQ7XFxuICAgICAgICBidWlsZGVyLnBvcyArPSBza2lwcGVkO1xcbiAgICAgIH1cXG4gICAgICBpZiAoIW0pIHsgYnJlYWsgfVxcbiAgICAgIHBvcyArPSBza2lwcGVkICsgMTtcXG4gICAgICB2YXIgdHh0JDEgPSAodm9pZCAwKTtcXG4gICAgICBpZiAobVswXSA9PSBcXFwiXFxcXHRcXFwiKSB7XFxuICAgICAgICB2YXIgdGFiU2l6ZSA9IGJ1aWxkZXIuY20ub3B0aW9ucy50YWJTaXplLCB0YWJXaWR0aCA9IHRhYlNpemUgLSBidWlsZGVyLmNvbCAlIHRhYlNpemU7XFxuICAgICAgICB0eHQkMSA9IGNvbnRlbnQuYXBwZW5kQ2hpbGQoZWx0KFxcXCJzcGFuXFxcIiwgc3BhY2VTdHIodGFiV2lkdGgpLCBcXFwiY20tdGFiXFxcIikpO1xcbiAgICAgICAgdHh0JDEuc2V0QXR0cmlidXRlKFxcXCJyb2xlXFxcIiwgXFxcInByZXNlbnRhdGlvblxcXCIpO1xcbiAgICAgICAgdHh0JDEuc2V0QXR0cmlidXRlKFxcXCJjbS10ZXh0XFxcIiwgXFxcIlxcXFx0XFxcIik7XFxuICAgICAgICBidWlsZGVyLmNvbCArPSB0YWJXaWR0aDtcXG4gICAgICB9IGVsc2UgaWYgKG1bMF0gPT0gXFxcIlxcXFxyXFxcIiB8fCBtWzBdID09IFxcXCJcXFxcblxcXCIpIHtcXG4gICAgICAgIHR4dCQxID0gY29udGVudC5hcHBlbmRDaGlsZChlbHQoXFxcInNwYW5cXFwiLCBtWzBdID09IFxcXCJcXFxcclxcXCIgPyBcXFwiXFxcXHUyNDBkXFxcIiA6IFxcXCJcXFxcdTI0MjRcXFwiLCBcXFwiY20taW52YWxpZGNoYXJcXFwiKSk7XFxuICAgICAgICB0eHQkMS5zZXRBdHRyaWJ1dGUoXFxcImNtLXRleHRcXFwiLCBtWzBdKTtcXG4gICAgICAgIGJ1aWxkZXIuY29sICs9IDE7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIHR4dCQxID0gYnVpbGRlci5jbS5vcHRpb25zLnNwZWNpYWxDaGFyUGxhY2Vob2xkZXIobVswXSk7XFxuICAgICAgICB0eHQkMS5zZXRBdHRyaWJ1dGUoXFxcImNtLXRleHRcXFwiLCBtWzBdKTtcXG4gICAgICAgIGlmIChpZSAmJiBpZV92ZXJzaW9uIDwgOSkgeyBjb250ZW50LmFwcGVuZENoaWxkKGVsdChcXFwic3BhblxcXCIsIFt0eHQkMV0pKTsgfVxcbiAgICAgICAgZWxzZSB7IGNvbnRlbnQuYXBwZW5kQ2hpbGQodHh0JDEpOyB9XFxuICAgICAgICBidWlsZGVyLmNvbCArPSAxO1xcbiAgICAgIH1cXG4gICAgICBidWlsZGVyLm1hcC5wdXNoKGJ1aWxkZXIucG9zLCBidWlsZGVyLnBvcyArIDEsIHR4dCQxKTtcXG4gICAgICBidWlsZGVyLnBvcysrO1xcbiAgICB9XFxuICB9XFxuICBidWlsZGVyLnRyYWlsaW5nU3BhY2UgPSBkaXNwbGF5VGV4dC5jaGFyQ29kZUF0KHRleHQubGVuZ3RoIC0gMSkgPT0gMzI7XFxuICBpZiAoc3R5bGUgfHwgc3RhcnRTdHlsZSB8fCBlbmRTdHlsZSB8fCBtdXN0V3JhcCB8fCBjc3MpIHtcXG4gICAgdmFyIGZ1bGxTdHlsZSA9IHN0eWxlIHx8IFxcXCJcXFwiO1xcbiAgICBpZiAoc3RhcnRTdHlsZSkgeyBmdWxsU3R5bGUgKz0gc3RhcnRTdHlsZTsgfVxcbiAgICBpZiAoZW5kU3R5bGUpIHsgZnVsbFN0eWxlICs9IGVuZFN0eWxlOyB9XFxuICAgIHZhciB0b2tlbiA9IGVsdChcXFwic3BhblxcXCIsIFtjb250ZW50XSwgZnVsbFN0eWxlLCBjc3MpO1xcbiAgICBpZiAodGl0bGUpIHsgdG9rZW4udGl0bGUgPSB0aXRsZTsgfVxcbiAgICByZXR1cm4gYnVpbGRlci5jb250ZW50LmFwcGVuZENoaWxkKHRva2VuKVxcbiAgfVxcbiAgYnVpbGRlci5jb250ZW50LmFwcGVuZENoaWxkKGNvbnRlbnQpO1xcbn1cXG5cXG5mdW5jdGlvbiBzcGxpdFNwYWNlcyh0ZXh0LCB0cmFpbGluZ0JlZm9yZSkge1xcbiAgaWYgKHRleHQubGVuZ3RoID4gMSAmJiAhLyAgLy50ZXN0KHRleHQpKSB7IHJldHVybiB0ZXh0IH1cXG4gIHZhciBzcGFjZUJlZm9yZSA9IHRyYWlsaW5nQmVmb3JlLCByZXN1bHQgPSBcXFwiXFxcIjtcXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGV4dC5sZW5ndGg7IGkrKykge1xcbiAgICB2YXIgY2ggPSB0ZXh0LmNoYXJBdChpKTtcXG4gICAgaWYgKGNoID09IFxcXCIgXFxcIiAmJiBzcGFjZUJlZm9yZSAmJiAoaSA9PSB0ZXh0Lmxlbmd0aCAtIDEgfHwgdGV4dC5jaGFyQ29kZUF0KGkgKyAxKSA9PSAzMikpXFxuICAgICAgeyBjaCA9IFxcXCJcXFxcdTAwYTBcXFwiOyB9XFxuICAgIHJlc3VsdCArPSBjaDtcXG4gICAgc3BhY2VCZWZvcmUgPSBjaCA9PSBcXFwiIFxcXCI7XFxuICB9XFxuICByZXR1cm4gcmVzdWx0XFxufVxcblxcbi8vIFdvcmsgYXJvdW5kIG5vbnNlbnNlIGRpbWVuc2lvbnMgYmVpbmcgcmVwb3J0ZWQgZm9yIHN0cmV0Y2hlcyBvZlxcbi8vIHJpZ2h0LXRvLWxlZnQgdGV4dC5cXG5mdW5jdGlvbiBidWlsZFRva2VuQmFkQmlkaShpbm5lciwgb3JkZXIpIHtcXG4gIHJldHVybiBmdW5jdGlvbiAoYnVpbGRlciwgdGV4dCwgc3R5bGUsIHN0YXJ0U3R5bGUsIGVuZFN0eWxlLCB0aXRsZSwgY3NzKSB7XFxuICAgIHN0eWxlID0gc3R5bGUgPyBzdHlsZSArIFxcXCIgY20tZm9yY2UtYm9yZGVyXFxcIiA6IFxcXCJjbS1mb3JjZS1ib3JkZXJcXFwiO1xcbiAgICB2YXIgc3RhcnQgPSBidWlsZGVyLnBvcywgZW5kID0gc3RhcnQgKyB0ZXh0Lmxlbmd0aDtcXG4gICAgZm9yICg7Oykge1xcbiAgICAgIC8vIEZpbmQgdGhlIHBhcnQgdGhhdCBvdmVybGFwcyB3aXRoIHRoZSBzdGFydCBvZiB0aGlzIHRleHRcXG4gICAgICB2YXIgcGFydCA9ICh2b2lkIDApO1xcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3JkZXIubGVuZ3RoOyBpKyspIHtcXG4gICAgICAgIHBhcnQgPSBvcmRlcltpXTtcXG4gICAgICAgIGlmIChwYXJ0LnRvID4gc3RhcnQgJiYgcGFydC5mcm9tIDw9IHN0YXJ0KSB7IGJyZWFrIH1cXG4gICAgICB9XFxuICAgICAgaWYgKHBhcnQudG8gPj0gZW5kKSB7IHJldHVybiBpbm5lcihidWlsZGVyLCB0ZXh0LCBzdHlsZSwgc3RhcnRTdHlsZSwgZW5kU3R5bGUsIHRpdGxlLCBjc3MpIH1cXG4gICAgICBpbm5lcihidWlsZGVyLCB0ZXh0LnNsaWNlKDAsIHBhcnQudG8gLSBzdGFydCksIHN0eWxlLCBzdGFydFN0eWxlLCBudWxsLCB0aXRsZSwgY3NzKTtcXG4gICAgICBzdGFydFN0eWxlID0gbnVsbDtcXG4gICAgICB0ZXh0ID0gdGV4dC5zbGljZShwYXJ0LnRvIC0gc3RhcnQpO1xcbiAgICAgIHN0YXJ0ID0gcGFydC50bztcXG4gICAgfVxcbiAgfVxcbn1cXG5cXG5mdW5jdGlvbiBidWlsZENvbGxhcHNlZFNwYW4oYnVpbGRlciwgc2l6ZSwgbWFya2VyLCBpZ25vcmVXaWRnZXQpIHtcXG4gIHZhciB3aWRnZXQgPSAhaWdub3JlV2lkZ2V0ICYmIG1hcmtlci53aWRnZXROb2RlO1xcbiAgaWYgKHdpZGdldCkgeyBidWlsZGVyLm1hcC5wdXNoKGJ1aWxkZXIucG9zLCBidWlsZGVyLnBvcyArIHNpemUsIHdpZGdldCk7IH1cXG4gIGlmICghaWdub3JlV2lkZ2V0ICYmIGJ1aWxkZXIuY20uZGlzcGxheS5pbnB1dC5uZWVkc0NvbnRlbnRBdHRyaWJ1dGUpIHtcXG4gICAgaWYgKCF3aWRnZXQpXFxuICAgICAgeyB3aWRnZXQgPSBidWlsZGVyLmNvbnRlbnQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcXFwic3BhblxcXCIpKTsgfVxcbiAgICB3aWRnZXQuc2V0QXR0cmlidXRlKFxcXCJjbS1tYXJrZXJcXFwiLCBtYXJrZXIuaWQpO1xcbiAgfVxcbiAgaWYgKHdpZGdldCkge1xcbiAgICBidWlsZGVyLmNtLmRpc3BsYXkuaW5wdXQuc2V0VW5lZGl0YWJsZSh3aWRnZXQpO1xcbiAgICBidWlsZGVyLmNvbnRlbnQuYXBwZW5kQ2hpbGQod2lkZ2V0KTtcXG4gIH1cXG4gIGJ1aWxkZXIucG9zICs9IHNpemU7XFxuICBidWlsZGVyLnRyYWlsaW5nU3BhY2UgPSBmYWxzZTtcXG59XFxuXFxuLy8gT3V0cHV0cyBhIG51bWJlciBvZiBzcGFucyB0byBtYWtlIHVwIGEgbGluZSwgdGFraW5nIGhpZ2hsaWdodGluZ1xcbi8vIGFuZCBtYXJrZWQgdGV4dCBpbnRvIGFjY291bnQuXFxuZnVuY3Rpb24gaW5zZXJ0TGluZUNvbnRlbnQobGluZSwgYnVpbGRlciwgc3R5bGVzKSB7XFxuICB2YXIgc3BhbnMgPSBsaW5lLm1hcmtlZFNwYW5zLCBhbGxUZXh0ID0gbGluZS50ZXh0LCBhdCA9IDA7XFxuICBpZiAoIXNwYW5zKSB7XFxuICAgIGZvciAodmFyIGkkMSA9IDE7IGkkMSA8IHN0eWxlcy5sZW5ndGg7IGkkMSs9MilcXG4gICAgICB7IGJ1aWxkZXIuYWRkVG9rZW4oYnVpbGRlciwgYWxsVGV4dC5zbGljZShhdCwgYXQgPSBzdHlsZXNbaSQxXSksIGludGVycHJldFRva2VuU3R5bGUoc3R5bGVzW2kkMSsxXSwgYnVpbGRlci5jbS5vcHRpb25zKSk7IH1cXG4gICAgcmV0dXJuXFxuICB9XFxuXFxuICB2YXIgbGVuID0gYWxsVGV4dC5sZW5ndGgsIHBvcyA9IDAsIGkgPSAxLCB0ZXh0ID0gXFxcIlxcXCIsIHN0eWxlLCBjc3M7XFxuICB2YXIgbmV4dENoYW5nZSA9IDAsIHNwYW5TdHlsZSwgc3BhbkVuZFN0eWxlLCBzcGFuU3RhcnRTdHlsZSwgdGl0bGUsIGNvbGxhcHNlZDtcXG4gIGZvciAoOzspIHtcXG4gICAgaWYgKG5leHRDaGFuZ2UgPT0gcG9zKSB7IC8vIFVwZGF0ZSBjdXJyZW50IG1hcmtlciBzZXRcXG4gICAgICBzcGFuU3R5bGUgPSBzcGFuRW5kU3R5bGUgPSBzcGFuU3RhcnRTdHlsZSA9IHRpdGxlID0gY3NzID0gXFxcIlxcXCI7XFxuICAgICAgY29sbGFwc2VkID0gbnVsbDsgbmV4dENoYW5nZSA9IEluZmluaXR5O1xcbiAgICAgIHZhciBmb3VuZEJvb2ttYXJrcyA9IFtdLCBlbmRTdHlsZXMgPSAodm9pZCAwKTtcXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHNwYW5zLmxlbmd0aDsgKytqKSB7XFxuICAgICAgICB2YXIgc3AgPSBzcGFuc1tqXSwgbSA9IHNwLm1hcmtlcjtcXG4gICAgICAgIGlmIChtLnR5cGUgPT0gXFxcImJvb2ttYXJrXFxcIiAmJiBzcC5mcm9tID09IHBvcyAmJiBtLndpZGdldE5vZGUpIHtcXG4gICAgICAgICAgZm91bmRCb29rbWFya3MucHVzaChtKTtcXG4gICAgICAgIH0gZWxzZSBpZiAoc3AuZnJvbSA8PSBwb3MgJiYgKHNwLnRvID09IG51bGwgfHwgc3AudG8gPiBwb3MgfHwgbS5jb2xsYXBzZWQgJiYgc3AudG8gPT0gcG9zICYmIHNwLmZyb20gPT0gcG9zKSkge1xcbiAgICAgICAgICBpZiAoc3AudG8gIT0gbnVsbCAmJiBzcC50byAhPSBwb3MgJiYgbmV4dENoYW5nZSA+IHNwLnRvKSB7XFxuICAgICAgICAgICAgbmV4dENoYW5nZSA9IHNwLnRvO1xcbiAgICAgICAgICAgIHNwYW5FbmRTdHlsZSA9IFxcXCJcXFwiO1xcbiAgICAgICAgICB9XFxuICAgICAgICAgIGlmIChtLmNsYXNzTmFtZSkgeyBzcGFuU3R5bGUgKz0gXFxcIiBcXFwiICsgbS5jbGFzc05hbWU7IH1cXG4gICAgICAgICAgaWYgKG0uY3NzKSB7IGNzcyA9IChjc3MgPyBjc3MgKyBcXFwiO1xcXCIgOiBcXFwiXFxcIikgKyBtLmNzczsgfVxcbiAgICAgICAgICBpZiAobS5zdGFydFN0eWxlICYmIHNwLmZyb20gPT0gcG9zKSB7IHNwYW5TdGFydFN0eWxlICs9IFxcXCIgXFxcIiArIG0uc3RhcnRTdHlsZTsgfVxcbiAgICAgICAgICBpZiAobS5lbmRTdHlsZSAmJiBzcC50byA9PSBuZXh0Q2hhbmdlKSB7IChlbmRTdHlsZXMgfHwgKGVuZFN0eWxlcyA9IFtdKSkucHVzaChtLmVuZFN0eWxlLCBzcC50byk7IH1cXG4gICAgICAgICAgaWYgKG0udGl0bGUgJiYgIXRpdGxlKSB7IHRpdGxlID0gbS50aXRsZTsgfVxcbiAgICAgICAgICBpZiAobS5jb2xsYXBzZWQgJiYgKCFjb2xsYXBzZWQgfHwgY29tcGFyZUNvbGxhcHNlZE1hcmtlcnMoY29sbGFwc2VkLm1hcmtlciwgbSkgPCAwKSlcXG4gICAgICAgICAgICB7IGNvbGxhcHNlZCA9IHNwOyB9XFxuICAgICAgICB9IGVsc2UgaWYgKHNwLmZyb20gPiBwb3MgJiYgbmV4dENoYW5nZSA+IHNwLmZyb20pIHtcXG4gICAgICAgICAgbmV4dENoYW5nZSA9IHNwLmZyb207XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICAgIGlmIChlbmRTdHlsZXMpIHsgZm9yICh2YXIgaiQxID0gMDsgaiQxIDwgZW5kU3R5bGVzLmxlbmd0aDsgaiQxICs9IDIpXFxuICAgICAgICB7IGlmIChlbmRTdHlsZXNbaiQxICsgMV0gPT0gbmV4dENoYW5nZSkgeyBzcGFuRW5kU3R5bGUgKz0gXFxcIiBcXFwiICsgZW5kU3R5bGVzW2okMV07IH0gfSB9XFxuXFxuICAgICAgaWYgKCFjb2xsYXBzZWQgfHwgY29sbGFwc2VkLmZyb20gPT0gcG9zKSB7IGZvciAodmFyIGokMiA9IDA7IGokMiA8IGZvdW5kQm9va21hcmtzLmxlbmd0aDsgKytqJDIpXFxuICAgICAgICB7IGJ1aWxkQ29sbGFwc2VkU3BhbihidWlsZGVyLCAwLCBmb3VuZEJvb2ttYXJrc1tqJDJdKTsgfSB9XFxuICAgICAgaWYgKGNvbGxhcHNlZCAmJiAoY29sbGFwc2VkLmZyb20gfHwgMCkgPT0gcG9zKSB7XFxuICAgICAgICBidWlsZENvbGxhcHNlZFNwYW4oYnVpbGRlciwgKGNvbGxhcHNlZC50byA9PSBudWxsID8gbGVuICsgMSA6IGNvbGxhcHNlZC50bykgLSBwb3MsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sbGFwc2VkLm1hcmtlciwgY29sbGFwc2VkLmZyb20gPT0gbnVsbCk7XFxuICAgICAgICBpZiAoY29sbGFwc2VkLnRvID09IG51bGwpIHsgcmV0dXJuIH1cXG4gICAgICAgIGlmIChjb2xsYXBzZWQudG8gPT0gcG9zKSB7IGNvbGxhcHNlZCA9IGZhbHNlOyB9XFxuICAgICAgfVxcbiAgICB9XFxuICAgIGlmIChwb3MgPj0gbGVuKSB7IGJyZWFrIH1cXG5cXG4gICAgdmFyIHVwdG8gPSBNYXRoLm1pbihsZW4sIG5leHRDaGFuZ2UpO1xcbiAgICB3aGlsZSAodHJ1ZSkge1xcbiAgICAgIGlmICh0ZXh0KSB7XFxuICAgICAgICB2YXIgZW5kID0gcG9zICsgdGV4dC5sZW5ndGg7XFxuICAgICAgICBpZiAoIWNvbGxhcHNlZCkge1xcbiAgICAgICAgICB2YXIgdG9rZW5UZXh0ID0gZW5kID4gdXB0byA/IHRleHQuc2xpY2UoMCwgdXB0byAtIHBvcykgOiB0ZXh0O1xcbiAgICAgICAgICBidWlsZGVyLmFkZFRva2VuKGJ1aWxkZXIsIHRva2VuVGV4dCwgc3R5bGUgPyBzdHlsZSArIHNwYW5TdHlsZSA6IHNwYW5TdHlsZSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBzcGFuU3RhcnRTdHlsZSwgcG9zICsgdG9rZW5UZXh0Lmxlbmd0aCA9PSBuZXh0Q2hhbmdlID8gc3BhbkVuZFN0eWxlIDogXFxcIlxcXCIsIHRpdGxlLCBjc3MpO1xcbiAgICAgICAgfVxcbiAgICAgICAgaWYgKGVuZCA+PSB1cHRvKSB7dGV4dCA9IHRleHQuc2xpY2UodXB0byAtIHBvcyk7IHBvcyA9IHVwdG87IGJyZWFrfVxcbiAgICAgICAgcG9zID0gZW5kO1xcbiAgICAgICAgc3BhblN0YXJ0U3R5bGUgPSBcXFwiXFxcIjtcXG4gICAgICB9XFxuICAgICAgdGV4dCA9IGFsbFRleHQuc2xpY2UoYXQsIGF0ID0gc3R5bGVzW2krK10pO1xcbiAgICAgIHN0eWxlID0gaW50ZXJwcmV0VG9rZW5TdHlsZShzdHlsZXNbaSsrXSwgYnVpbGRlci5jbS5vcHRpb25zKTtcXG4gICAgfVxcbiAgfVxcbn1cXG5cXG5cXG4vLyBUaGVzZSBvYmplY3RzIGFyZSB1c2VkIHRvIHJlcHJlc2VudCB0aGUgdmlzaWJsZSAoY3VycmVudGx5IGRyYXduKVxcbi8vIHBhcnQgb2YgdGhlIGRvY3VtZW50LiBBIExpbmVWaWV3IG1heSBjb3JyZXNwb25kIHRvIG11bHRpcGxlXFxuLy8gbG9naWNhbCBsaW5lcywgaWYgdGhvc2UgYXJlIGNvbm5lY3RlZCBieSBjb2xsYXBzZWQgcmFuZ2VzLlxcbmZ1bmN0aW9uIExpbmVWaWV3KGRvYywgbGluZSwgbGluZU4pIHtcXG4gIC8vIFRoZSBzdGFydGluZyBsaW5lXFxuICB0aGlzLmxpbmUgPSBsaW5lO1xcbiAgLy8gQ29udGludWluZyBsaW5lcywgaWYgYW55XFxuICB0aGlzLnJlc3QgPSB2aXN1YWxMaW5lQ29udGludWVkKGxpbmUpO1xcbiAgLy8gTnVtYmVyIG9mIGxvZ2ljYWwgbGluZXMgaW4gdGhpcyB2aXN1YWwgbGluZVxcbiAgdGhpcy5zaXplID0gdGhpcy5yZXN0ID8gbGluZU5vKGxzdCh0aGlzLnJlc3QpKSAtIGxpbmVOICsgMSA6IDE7XFxuICB0aGlzLm5vZGUgPSB0aGlzLnRleHQgPSBudWxsO1xcbiAgdGhpcy5oaWRkZW4gPSBsaW5lSXNIaWRkZW4oZG9jLCBsaW5lKTtcXG59XFxuXFxuLy8gQ3JlYXRlIGEgcmFuZ2Ugb2YgTGluZVZpZXcgb2JqZWN0cyBmb3IgdGhlIGdpdmVuIGxpbmVzLlxcbmZ1bmN0aW9uIGJ1aWxkVmlld0FycmF5KGNtLCBmcm9tLCB0bykge1xcbiAgdmFyIGFycmF5ID0gW10sIG5leHRQb3M7XFxuICBmb3IgKHZhciBwb3MgPSBmcm9tOyBwb3MgPCB0bzsgcG9zID0gbmV4dFBvcykge1xcbiAgICB2YXIgdmlldyA9IG5ldyBMaW5lVmlldyhjbS5kb2MsIGdldExpbmUoY20uZG9jLCBwb3MpLCBwb3MpO1xcbiAgICBuZXh0UG9zID0gcG9zICsgdmlldy5zaXplO1xcbiAgICBhcnJheS5wdXNoKHZpZXcpO1xcbiAgfVxcbiAgcmV0dXJuIGFycmF5XFxufVxcblxcbnZhciBvcGVyYXRpb25Hcm91cCA9IG51bGw7XFxuXFxuZnVuY3Rpb24gcHVzaE9wZXJhdGlvbihvcCkge1xcbiAgaWYgKG9wZXJhdGlvbkdyb3VwKSB7XFxuICAgIG9wZXJhdGlvbkdyb3VwLm9wcy5wdXNoKG9wKTtcXG4gIH0gZWxzZSB7XFxuICAgIG9wLm93bnNHcm91cCA9IG9wZXJhdGlvbkdyb3VwID0ge1xcbiAgICAgIG9wczogW29wXSxcXG4gICAgICBkZWxheWVkQ2FsbGJhY2tzOiBbXVxcbiAgICB9O1xcbiAgfVxcbn1cXG5cXG5mdW5jdGlvbiBmaXJlQ2FsbGJhY2tzRm9yT3BzKGdyb3VwKSB7XFxuICAvLyBDYWxscyBkZWxheWVkIGNhbGxiYWNrcyBhbmQgY3Vyc29yQWN0aXZpdHkgaGFuZGxlcnMgdW50aWwgbm9cXG4gIC8vIG5ldyBvbmVzIGFwcGVhclxcbiAgdmFyIGNhbGxiYWNrcyA9IGdyb3VwLmRlbGF5ZWRDYWxsYmFja3MsIGkgPSAwO1xcbiAgZG8ge1xcbiAgICBmb3IgKDsgaSA8IGNhbGxiYWNrcy5sZW5ndGg7IGkrKylcXG4gICAgICB7IGNhbGxiYWNrc1tpXS5jYWxsKG51bGwpOyB9XFxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgZ3JvdXAub3BzLmxlbmd0aDsgaisrKSB7XFxuICAgICAgdmFyIG9wID0gZ3JvdXAub3BzW2pdO1xcbiAgICAgIGlmIChvcC5jdXJzb3JBY3Rpdml0eUhhbmRsZXJzKVxcbiAgICAgICAgeyB3aGlsZSAob3AuY3Vyc29yQWN0aXZpdHlDYWxsZWQgPCBvcC5jdXJzb3JBY3Rpdml0eUhhbmRsZXJzLmxlbmd0aClcXG4gICAgICAgICAgeyBvcC5jdXJzb3JBY3Rpdml0eUhhbmRsZXJzW29wLmN1cnNvckFjdGl2aXR5Q2FsbGVkKytdLmNhbGwobnVsbCwgb3AuY20pOyB9IH1cXG4gICAgfVxcbiAgfSB3aGlsZSAoaSA8IGNhbGxiYWNrcy5sZW5ndGgpXFxufVxcblxcbmZ1bmN0aW9uIGZpbmlzaE9wZXJhdGlvbihvcCwgZW5kQ2IpIHtcXG4gIHZhciBncm91cCA9IG9wLm93bnNHcm91cDtcXG4gIGlmICghZ3JvdXApIHsgcmV0dXJuIH1cXG5cXG4gIHRyeSB7IGZpcmVDYWxsYmFja3NGb3JPcHMoZ3JvdXApOyB9XFxuICBmaW5hbGx5IHtcXG4gICAgb3BlcmF0aW9uR3JvdXAgPSBudWxsO1xcbiAgICBlbmRDYihncm91cCk7XFxuICB9XFxufVxcblxcbnZhciBvcnBoYW5EZWxheWVkQ2FsbGJhY2tzID0gbnVsbDtcXG5cXG4vLyBPZnRlbiwgd2Ugd2FudCB0byBzaWduYWwgZXZlbnRzIGF0IGEgcG9pbnQgd2hlcmUgd2UgYXJlIGluIHRoZVxcbi8vIG1pZGRsZSBvZiBzb21lIHdvcmssIGJ1dCBkb24ndCB3YW50IHRoZSBoYW5kbGVyIHRvIHN0YXJ0IGNhbGxpbmdcXG4vLyBvdGhlciBtZXRob2RzIG9uIHRoZSBlZGl0b3IsIHdoaWNoIG1pZ2h0IGJlIGluIGFuIGluY29uc2lzdGVudFxcbi8vIHN0YXRlIG9yIHNpbXBseSBub3QgZXhwZWN0IGFueSBvdGhlciBldmVudHMgdG8gaGFwcGVuLlxcbi8vIHNpZ25hbExhdGVyIGxvb2tzIHdoZXRoZXIgdGhlcmUgYXJlIGFueSBoYW5kbGVycywgYW5kIHNjaGVkdWxlc1xcbi8vIHRoZW0gdG8gYmUgZXhlY3V0ZWQgd2hlbiB0aGUgbGFzdCBvcGVyYXRpb24gZW5kcywgb3IsIGlmIG5vXFxuLy8gb3BlcmF0aW9uIGlzIGFjdGl2ZSwgd2hlbiBhIHRpbWVvdXQgZmlyZXMuXFxuZnVuY3Rpb24gc2lnbmFsTGF0ZXIoZW1pdHRlciwgdHlwZSAvKiwgdmFsdWVzLi4uKi8pIHtcXG4gIHZhciBhcnIgPSBnZXRIYW5kbGVycyhlbWl0dGVyLCB0eXBlKTtcXG4gIGlmICghYXJyLmxlbmd0aCkgeyByZXR1cm4gfVxcbiAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpLCBsaXN0O1xcbiAgaWYgKG9wZXJhdGlvbkdyb3VwKSB7XFxuICAgIGxpc3QgPSBvcGVyYXRpb25Hcm91cC5kZWxheWVkQ2FsbGJhY2tzO1xcbiAgfSBlbHNlIGlmIChvcnBoYW5EZWxheWVkQ2FsbGJhY2tzKSB7XFxuICAgIGxpc3QgPSBvcnBoYW5EZWxheWVkQ2FsbGJhY2tzO1xcbiAgfSBlbHNlIHtcXG4gICAgbGlzdCA9IG9ycGhhbkRlbGF5ZWRDYWxsYmFja3MgPSBbXTtcXG4gICAgc2V0VGltZW91dChmaXJlT3JwaGFuRGVsYXllZCwgMCk7XFxuICB9XFxuICB2YXIgbG9vcCA9IGZ1bmN0aW9uICggaSApIHtcXG4gICAgbGlzdC5wdXNoKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGFycltpXS5hcHBseShudWxsLCBhcmdzKTsgfSk7XFxuICB9O1xcblxcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyArK2kpXFxuICAgIGxvb3AoIGkgKTtcXG59XFxuXFxuZnVuY3Rpb24gZmlyZU9ycGhhbkRlbGF5ZWQoKSB7XFxuICB2YXIgZGVsYXllZCA9IG9ycGhhbkRlbGF5ZWRDYWxsYmFja3M7XFxuICBvcnBoYW5EZWxheWVkQ2FsbGJhY2tzID0gbnVsbDtcXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZGVsYXllZC5sZW5ndGg7ICsraSkgeyBkZWxheWVkW2ldKCk7IH1cXG59XFxuXFxuLy8gV2hlbiBhbiBhc3BlY3Qgb2YgYSBsaW5lIGNoYW5nZXMsIGEgc3RyaW5nIGlzIGFkZGVkIHRvXFxuLy8gbGluZVZpZXcuY2hhbmdlcy4gVGhpcyB1cGRhdGVzIHRoZSByZWxldmFudCBwYXJ0IG9mIHRoZSBsaW5lJ3NcXG4vLyBET00gc3RydWN0dXJlLlxcbmZ1bmN0aW9uIHVwZGF0ZUxpbmVGb3JDaGFuZ2VzKGNtLCBsaW5lVmlldywgbGluZU4sIGRpbXMpIHtcXG4gIGZvciAodmFyIGogPSAwOyBqIDwgbGluZVZpZXcuY2hhbmdlcy5sZW5ndGg7IGorKykge1xcbiAgICB2YXIgdHlwZSA9IGxpbmVWaWV3LmNoYW5nZXNbal07XFxuICAgIGlmICh0eXBlID09IFxcXCJ0ZXh0XFxcIikgeyB1cGRhdGVMaW5lVGV4dChjbSwgbGluZVZpZXcpOyB9XFxuICAgIGVsc2UgaWYgKHR5cGUgPT0gXFxcImd1dHRlclxcXCIpIHsgdXBkYXRlTGluZUd1dHRlcihjbSwgbGluZVZpZXcsIGxpbmVOLCBkaW1zKTsgfVxcbiAgICBlbHNlIGlmICh0eXBlID09IFxcXCJjbGFzc1xcXCIpIHsgdXBkYXRlTGluZUNsYXNzZXMoY20sIGxpbmVWaWV3KTsgfVxcbiAgICBlbHNlIGlmICh0eXBlID09IFxcXCJ3aWRnZXRcXFwiKSB7IHVwZGF0ZUxpbmVXaWRnZXRzKGNtLCBsaW5lVmlldywgZGltcyk7IH1cXG4gIH1cXG4gIGxpbmVWaWV3LmNoYW5nZXMgPSBudWxsO1xcbn1cXG5cXG4vLyBMaW5lcyB3aXRoIGd1dHRlciBlbGVtZW50cywgd2lkZ2V0cyBvciBhIGJhY2tncm91bmQgY2xhc3MgbmVlZCB0b1xcbi8vIGJlIHdyYXBwZWQsIGFuZCBoYXZlIHRoZSBleHRyYSBlbGVtZW50cyBhZGRlZCB0byB0aGUgd3JhcHBlciBkaXZcXG5mdW5jdGlvbiBlbnN1cmVMaW5lV3JhcHBlZChsaW5lVmlldykge1xcbiAgaWYgKGxpbmVWaWV3Lm5vZGUgPT0gbGluZVZpZXcudGV4dCkge1xcbiAgICBsaW5lVmlldy5ub2RlID0gZWx0KFxcXCJkaXZcXFwiLCBudWxsLCBudWxsLCBcXFwicG9zaXRpb246IHJlbGF0aXZlXFxcIik7XFxuICAgIGlmIChsaW5lVmlldy50ZXh0LnBhcmVudE5vZGUpXFxuICAgICAgeyBsaW5lVmlldy50ZXh0LnBhcmVudE5vZGUucmVwbGFjZUNoaWxkKGxpbmVWaWV3Lm5vZGUsIGxpbmVWaWV3LnRleHQpOyB9XFxuICAgIGxpbmVWaWV3Lm5vZGUuYXBwZW5kQ2hpbGQobGluZVZpZXcudGV4dCk7XFxuICAgIGlmIChpZSAmJiBpZV92ZXJzaW9uIDwgOCkgeyBsaW5lVmlldy5ub2RlLnN0eWxlLnpJbmRleCA9IDI7IH1cXG4gIH1cXG4gIHJldHVybiBsaW5lVmlldy5ub2RlXFxufVxcblxcbmZ1bmN0aW9uIHVwZGF0ZUxpbmVCYWNrZ3JvdW5kKGNtLCBsaW5lVmlldykge1xcbiAgdmFyIGNscyA9IGxpbmVWaWV3LmJnQ2xhc3MgPyBsaW5lVmlldy5iZ0NsYXNzICsgXFxcIiBcXFwiICsgKGxpbmVWaWV3LmxpbmUuYmdDbGFzcyB8fCBcXFwiXFxcIikgOiBsaW5lVmlldy5saW5lLmJnQ2xhc3M7XFxuICBpZiAoY2xzKSB7IGNscyArPSBcXFwiIENvZGVNaXJyb3ItbGluZWJhY2tncm91bmRcXFwiOyB9XFxuICBpZiAobGluZVZpZXcuYmFja2dyb3VuZCkge1xcbiAgICBpZiAoY2xzKSB7IGxpbmVWaWV3LmJhY2tncm91bmQuY2xhc3NOYW1lID0gY2xzOyB9XFxuICAgIGVsc2UgeyBsaW5lVmlldy5iYWNrZ3JvdW5kLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobGluZVZpZXcuYmFja2dyb3VuZCk7IGxpbmVWaWV3LmJhY2tncm91bmQgPSBudWxsOyB9XFxuICB9IGVsc2UgaWYgKGNscykge1xcbiAgICB2YXIgd3JhcCA9IGVuc3VyZUxpbmVXcmFwcGVkKGxpbmVWaWV3KTtcXG4gICAgbGluZVZpZXcuYmFja2dyb3VuZCA9IHdyYXAuaW5zZXJ0QmVmb3JlKGVsdChcXFwiZGl2XFxcIiwgbnVsbCwgY2xzKSwgd3JhcC5maXJzdENoaWxkKTtcXG4gICAgY20uZGlzcGxheS5pbnB1dC5zZXRVbmVkaXRhYmxlKGxpbmVWaWV3LmJhY2tncm91bmQpO1xcbiAgfVxcbn1cXG5cXG4vLyBXcmFwcGVyIGFyb3VuZCBidWlsZExpbmVDb250ZW50IHdoaWNoIHdpbGwgcmV1c2UgdGhlIHN0cnVjdHVyZVxcbi8vIGluIGRpc3BsYXkuZXh0ZXJuYWxNZWFzdXJlZCB3aGVuIHBvc3NpYmxlLlxcbmZ1bmN0aW9uIGdldExpbmVDb250ZW50KGNtLCBsaW5lVmlldykge1xcbiAgdmFyIGV4dCA9IGNtLmRpc3BsYXkuZXh0ZXJuYWxNZWFzdXJlZDtcXG4gIGlmIChleHQgJiYgZXh0LmxpbmUgPT0gbGluZVZpZXcubGluZSkge1xcbiAgICBjbS5kaXNwbGF5LmV4dGVybmFsTWVhc3VyZWQgPSBudWxsO1xcbiAgICBsaW5lVmlldy5tZWFzdXJlID0gZXh0Lm1lYXN1cmU7XFxuICAgIHJldHVybiBleHQuYnVpbHRcXG4gIH1cXG4gIHJldHVybiBidWlsZExpbmVDb250ZW50KGNtLCBsaW5lVmlldylcXG59XFxuXFxuLy8gUmVkcmF3IHRoZSBsaW5lJ3MgdGV4dC4gSW50ZXJhY3RzIHdpdGggdGhlIGJhY2tncm91bmQgYW5kIHRleHRcXG4vLyBjbGFzc2VzIGJlY2F1c2UgdGhlIG1vZGUgbWF5IG91dHB1dCB0b2tlbnMgdGhhdCBpbmZsdWVuY2UgdGhlc2VcXG4vLyBjbGFzc2VzLlxcbmZ1bmN0aW9uIHVwZGF0ZUxpbmVUZXh0KGNtLCBsaW5lVmlldykge1xcbiAgdmFyIGNscyA9IGxpbmVWaWV3LnRleHQuY2xhc3NOYW1lO1xcbiAgdmFyIGJ1aWx0ID0gZ2V0TGluZUNvbnRlbnQoY20sIGxpbmVWaWV3KTtcXG4gIGlmIChsaW5lVmlldy50ZXh0ID09IGxpbmVWaWV3Lm5vZGUpIHsgbGluZVZpZXcubm9kZSA9IGJ1aWx0LnByZTsgfVxcbiAgbGluZVZpZXcudGV4dC5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZChidWlsdC5wcmUsIGxpbmVWaWV3LnRleHQpO1xcbiAgbGluZVZpZXcudGV4dCA9IGJ1aWx0LnByZTtcXG4gIGlmIChidWlsdC5iZ0NsYXNzICE9IGxpbmVWaWV3LmJnQ2xhc3MgfHwgYnVpbHQudGV4dENsYXNzICE9IGxpbmVWaWV3LnRleHRDbGFzcykge1xcbiAgICBsaW5lVmlldy5iZ0NsYXNzID0gYnVpbHQuYmdDbGFzcztcXG4gICAgbGluZVZpZXcudGV4dENsYXNzID0gYnVpbHQudGV4dENsYXNzO1xcbiAgICB1cGRhdGVMaW5lQ2xhc3NlcyhjbSwgbGluZVZpZXcpO1xcbiAgfSBlbHNlIGlmIChjbHMpIHtcXG4gICAgbGluZVZpZXcudGV4dC5jbGFzc05hbWUgPSBjbHM7XFxuICB9XFxufVxcblxcbmZ1bmN0aW9uIHVwZGF0ZUxpbmVDbGFzc2VzKGNtLCBsaW5lVmlldykge1xcbiAgdXBkYXRlTGluZUJhY2tncm91bmQoY20sIGxpbmVWaWV3KTtcXG4gIGlmIChsaW5lVmlldy5saW5lLndyYXBDbGFzcylcXG4gICAgeyBlbnN1cmVMaW5lV3JhcHBlZChsaW5lVmlldykuY2xhc3NOYW1lID0gbGluZVZpZXcubGluZS53cmFwQ2xhc3M7IH1cXG4gIGVsc2UgaWYgKGxpbmVWaWV3Lm5vZGUgIT0gbGluZVZpZXcudGV4dClcXG4gICAgeyBsaW5lVmlldy5ub2RlLmNsYXNzTmFtZSA9IFxcXCJcXFwiOyB9XFxuICB2YXIgdGV4dENsYXNzID0gbGluZVZpZXcudGV4dENsYXNzID8gbGluZVZpZXcudGV4dENsYXNzICsgXFxcIiBcXFwiICsgKGxpbmVWaWV3LmxpbmUudGV4dENsYXNzIHx8IFxcXCJcXFwiKSA6IGxpbmVWaWV3LmxpbmUudGV4dENsYXNzO1xcbiAgbGluZVZpZXcudGV4dC5jbGFzc05hbWUgPSB0ZXh0Q2xhc3MgfHwgXFxcIlxcXCI7XFxufVxcblxcbmZ1bmN0aW9uIHVwZGF0ZUxpbmVHdXR0ZXIoY20sIGxpbmVWaWV3LCBsaW5lTiwgZGltcykge1xcbiAgaWYgKGxpbmVWaWV3Lmd1dHRlcikge1xcbiAgICBsaW5lVmlldy5ub2RlLnJlbW92ZUNoaWxkKGxpbmVWaWV3Lmd1dHRlcik7XFxuICAgIGxpbmVWaWV3Lmd1dHRlciA9IG51bGw7XFxuICB9XFxuICBpZiAobGluZVZpZXcuZ3V0dGVyQmFja2dyb3VuZCkge1xcbiAgICBsaW5lVmlldy5ub2RlLnJlbW92ZUNoaWxkKGxpbmVWaWV3Lmd1dHRlckJhY2tncm91bmQpO1xcbiAgICBsaW5lVmlldy5ndXR0ZXJCYWNrZ3JvdW5kID0gbnVsbDtcXG4gIH1cXG4gIGlmIChsaW5lVmlldy5saW5lLmd1dHRlckNsYXNzKSB7XFxuICAgIHZhciB3cmFwID0gZW5zdXJlTGluZVdyYXBwZWQobGluZVZpZXcpO1xcbiAgICBsaW5lVmlldy5ndXR0ZXJCYWNrZ3JvdW5kID0gZWx0KFxcXCJkaXZcXFwiLCBudWxsLCBcXFwiQ29kZU1pcnJvci1ndXR0ZXItYmFja2dyb3VuZCBcXFwiICsgbGluZVZpZXcubGluZS5ndXR0ZXJDbGFzcyxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoXFxcImxlZnQ6IFxcXCIgKyAoY20ub3B0aW9ucy5maXhlZEd1dHRlciA/IGRpbXMuZml4ZWRQb3MgOiAtZGltcy5ndXR0ZXJUb3RhbFdpZHRoKSArIFxcXCJweDsgd2lkdGg6IFxcXCIgKyAoZGltcy5ndXR0ZXJUb3RhbFdpZHRoKSArIFxcXCJweFxcXCIpKTtcXG4gICAgY20uZGlzcGxheS5pbnB1dC5zZXRVbmVkaXRhYmxlKGxpbmVWaWV3Lmd1dHRlckJhY2tncm91bmQpO1xcbiAgICB3cmFwLmluc2VydEJlZm9yZShsaW5lVmlldy5ndXR0ZXJCYWNrZ3JvdW5kLCBsaW5lVmlldy50ZXh0KTtcXG4gIH1cXG4gIHZhciBtYXJrZXJzID0gbGluZVZpZXcubGluZS5ndXR0ZXJNYXJrZXJzO1xcbiAgaWYgKGNtLm9wdGlvbnMubGluZU51bWJlcnMgfHwgbWFya2Vycykge1xcbiAgICB2YXIgd3JhcCQxID0gZW5zdXJlTGluZVdyYXBwZWQobGluZVZpZXcpO1xcbiAgICB2YXIgZ3V0dGVyV3JhcCA9IGxpbmVWaWV3Lmd1dHRlciA9IGVsdChcXFwiZGl2XFxcIiwgbnVsbCwgXFxcIkNvZGVNaXJyb3ItZ3V0dGVyLXdyYXBwZXJcXFwiLCAoXFxcImxlZnQ6IFxcXCIgKyAoY20ub3B0aW9ucy5maXhlZEd1dHRlciA/IGRpbXMuZml4ZWRQb3MgOiAtZGltcy5ndXR0ZXJUb3RhbFdpZHRoKSArIFxcXCJweFxcXCIpKTtcXG4gICAgY20uZGlzcGxheS5pbnB1dC5zZXRVbmVkaXRhYmxlKGd1dHRlcldyYXApO1xcbiAgICB3cmFwJDEuaW5zZXJ0QmVmb3JlKGd1dHRlcldyYXAsIGxpbmVWaWV3LnRleHQpO1xcbiAgICBpZiAobGluZVZpZXcubGluZS5ndXR0ZXJDbGFzcylcXG4gICAgICB7IGd1dHRlcldyYXAuY2xhc3NOYW1lICs9IFxcXCIgXFxcIiArIGxpbmVWaWV3LmxpbmUuZ3V0dGVyQ2xhc3M7IH1cXG4gICAgaWYgKGNtLm9wdGlvbnMubGluZU51bWJlcnMgJiYgKCFtYXJrZXJzIHx8ICFtYXJrZXJzW1xcXCJDb2RlTWlycm9yLWxpbmVudW1iZXJzXFxcIl0pKVxcbiAgICAgIHsgbGluZVZpZXcubGluZU51bWJlciA9IGd1dHRlcldyYXAuYXBwZW5kQ2hpbGQoXFxuICAgICAgICBlbHQoXFxcImRpdlxcXCIsIGxpbmVOdW1iZXJGb3IoY20ub3B0aW9ucywgbGluZU4pLFxcbiAgICAgICAgICAgIFxcXCJDb2RlTWlycm9yLWxpbmVudW1iZXIgQ29kZU1pcnJvci1ndXR0ZXItZWx0XFxcIixcXG4gICAgICAgICAgICAoXFxcImxlZnQ6IFxcXCIgKyAoZGltcy5ndXR0ZXJMZWZ0W1xcXCJDb2RlTWlycm9yLWxpbmVudW1iZXJzXFxcIl0pICsgXFxcInB4OyB3aWR0aDogXFxcIiArIChjbS5kaXNwbGF5LmxpbmVOdW1Jbm5lcldpZHRoKSArIFxcXCJweFxcXCIpKSk7IH1cXG4gICAgaWYgKG1hcmtlcnMpIHsgZm9yICh2YXIgayA9IDA7IGsgPCBjbS5vcHRpb25zLmd1dHRlcnMubGVuZ3RoOyArK2spIHtcXG4gICAgICB2YXIgaWQgPSBjbS5vcHRpb25zLmd1dHRlcnNba10sIGZvdW5kID0gbWFya2Vycy5oYXNPd25Qcm9wZXJ0eShpZCkgJiYgbWFya2Vyc1tpZF07XFxuICAgICAgaWYgKGZvdW5kKVxcbiAgICAgICAgeyBndXR0ZXJXcmFwLmFwcGVuZENoaWxkKGVsdChcXFwiZGl2XFxcIiwgW2ZvdW5kXSwgXFxcIkNvZGVNaXJyb3ItZ3V0dGVyLWVsdFxcXCIsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoXFxcImxlZnQ6IFxcXCIgKyAoZGltcy5ndXR0ZXJMZWZ0W2lkXSkgKyBcXFwicHg7IHdpZHRoOiBcXFwiICsgKGRpbXMuZ3V0dGVyV2lkdGhbaWRdKSArIFxcXCJweFxcXCIpKSk7IH1cXG4gICAgfSB9XFxuICB9XFxufVxcblxcbmZ1bmN0aW9uIHVwZGF0ZUxpbmVXaWRnZXRzKGNtLCBsaW5lVmlldywgZGltcykge1xcbiAgaWYgKGxpbmVWaWV3LmFsaWduYWJsZSkgeyBsaW5lVmlldy5hbGlnbmFibGUgPSBudWxsOyB9XFxuICBmb3IgKHZhciBub2RlID0gbGluZVZpZXcubm9kZS5maXJzdENoaWxkLCBuZXh0ID0gKHZvaWQgMCk7IG5vZGU7IG5vZGUgPSBuZXh0KSB7XFxuICAgIG5leHQgPSBub2RlLm5leHRTaWJsaW5nO1xcbiAgICBpZiAobm9kZS5jbGFzc05hbWUgPT0gXFxcIkNvZGVNaXJyb3ItbGluZXdpZGdldFxcXCIpXFxuICAgICAgeyBsaW5lVmlldy5ub2RlLnJlbW92ZUNoaWxkKG5vZGUpOyB9XFxuICB9XFxuICBpbnNlcnRMaW5lV2lkZ2V0cyhjbSwgbGluZVZpZXcsIGRpbXMpO1xcbn1cXG5cXG4vLyBCdWlsZCBhIGxpbmUncyBET00gcmVwcmVzZW50YXRpb24gZnJvbSBzY3JhdGNoXFxuZnVuY3Rpb24gYnVpbGRMaW5lRWxlbWVudChjbSwgbGluZVZpZXcsIGxpbmVOLCBkaW1zKSB7XFxuICB2YXIgYnVpbHQgPSBnZXRMaW5lQ29udGVudChjbSwgbGluZVZpZXcpO1xcbiAgbGluZVZpZXcudGV4dCA9IGxpbmVWaWV3Lm5vZGUgPSBidWlsdC5wcmU7XFxuICBpZiAoYnVpbHQuYmdDbGFzcykgeyBsaW5lVmlldy5iZ0NsYXNzID0gYnVpbHQuYmdDbGFzczsgfVxcbiAgaWYgKGJ1aWx0LnRleHRDbGFzcykgeyBsaW5lVmlldy50ZXh0Q2xhc3MgPSBidWlsdC50ZXh0Q2xhc3M7IH1cXG5cXG4gIHVwZGF0ZUxpbmVDbGFzc2VzKGNtLCBsaW5lVmlldyk7XFxuICB1cGRhdGVMaW5lR3V0dGVyKGNtLCBsaW5lVmlldywgbGluZU4sIGRpbXMpO1xcbiAgaW5zZXJ0TGluZVdpZGdldHMoY20sIGxpbmVWaWV3LCBkaW1zKTtcXG4gIHJldHVybiBsaW5lVmlldy5ub2RlXFxufVxcblxcbi8vIEEgbGluZVZpZXcgbWF5IGNvbnRhaW4gbXVsdGlwbGUgbG9naWNhbCBsaW5lcyAod2hlbiBtZXJnZWQgYnlcXG4vLyBjb2xsYXBzZWQgc3BhbnMpLiBUaGUgd2lkZ2V0cyBmb3IgYWxsIG9mIHRoZW0gbmVlZCB0byBiZSBkcmF3bi5cXG5mdW5jdGlvbiBpbnNlcnRMaW5lV2lkZ2V0cyhjbSwgbGluZVZpZXcsIGRpbXMpIHtcXG4gIGluc2VydExpbmVXaWRnZXRzRm9yKGNtLCBsaW5lVmlldy5saW5lLCBsaW5lVmlldywgZGltcywgdHJ1ZSk7XFxuICBpZiAobGluZVZpZXcucmVzdCkgeyBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmVWaWV3LnJlc3QubGVuZ3RoOyBpKyspXFxuICAgIHsgaW5zZXJ0TGluZVdpZGdldHNGb3IoY20sIGxpbmVWaWV3LnJlc3RbaV0sIGxpbmVWaWV3LCBkaW1zLCBmYWxzZSk7IH0gfVxcbn1cXG5cXG5mdW5jdGlvbiBpbnNlcnRMaW5lV2lkZ2V0c0ZvcihjbSwgbGluZSwgbGluZVZpZXcsIGRpbXMsIGFsbG93QWJvdmUpIHtcXG4gIGlmICghbGluZS53aWRnZXRzKSB7IHJldHVybiB9XFxuICB2YXIgd3JhcCA9IGVuc3VyZUxpbmVXcmFwcGVkKGxpbmVWaWV3KTtcXG4gIGZvciAodmFyIGkgPSAwLCB3cyA9IGxpbmUud2lkZ2V0czsgaSA8IHdzLmxlbmd0aDsgKytpKSB7XFxuICAgIHZhciB3aWRnZXQgPSB3c1tpXSwgbm9kZSA9IGVsdChcXFwiZGl2XFxcIiwgW3dpZGdldC5ub2RlXSwgXFxcIkNvZGVNaXJyb3ItbGluZXdpZGdldFxcXCIpO1xcbiAgICBpZiAoIXdpZGdldC5oYW5kbGVNb3VzZUV2ZW50cykgeyBub2RlLnNldEF0dHJpYnV0ZShcXFwiY20taWdub3JlLWV2ZW50c1xcXCIsIFxcXCJ0cnVlXFxcIik7IH1cXG4gICAgcG9zaXRpb25MaW5lV2lkZ2V0KHdpZGdldCwgbm9kZSwgbGluZVZpZXcsIGRpbXMpO1xcbiAgICBjbS5kaXNwbGF5LmlucHV0LnNldFVuZWRpdGFibGUobm9kZSk7XFxuICAgIGlmIChhbGxvd0Fib3ZlICYmIHdpZGdldC5hYm92ZSlcXG4gICAgICB7IHdyYXAuaW5zZXJ0QmVmb3JlKG5vZGUsIGxpbmVWaWV3Lmd1dHRlciB8fCBsaW5lVmlldy50ZXh0KTsgfVxcbiAgICBlbHNlXFxuICAgICAgeyB3cmFwLmFwcGVuZENoaWxkKG5vZGUpOyB9XFxuICAgIHNpZ25hbExhdGVyKHdpZGdldCwgXFxcInJlZHJhd1xcXCIpO1xcbiAgfVxcbn1cXG5cXG5mdW5jdGlvbiBwb3NpdGlvbkxpbmVXaWRnZXQod2lkZ2V0LCBub2RlLCBsaW5lVmlldywgZGltcykge1xcbiAgaWYgKHdpZGdldC5ub0hTY3JvbGwpIHtcXG4gICAgKGxpbmVWaWV3LmFsaWduYWJsZSB8fCAobGluZVZpZXcuYWxpZ25hYmxlID0gW10pKS5wdXNoKG5vZGUpO1xcbiAgICB2YXIgd2lkdGggPSBkaW1zLndyYXBwZXJXaWR0aDtcXG4gICAgbm9kZS5zdHlsZS5sZWZ0ID0gZGltcy5maXhlZFBvcyArIFxcXCJweFxcXCI7XFxuICAgIGlmICghd2lkZ2V0LmNvdmVyR3V0dGVyKSB7XFxuICAgICAgd2lkdGggLT0gZGltcy5ndXR0ZXJUb3RhbFdpZHRoO1xcbiAgICAgIG5vZGUuc3R5bGUucGFkZGluZ0xlZnQgPSBkaW1zLmd1dHRlclRvdGFsV2lkdGggKyBcXFwicHhcXFwiO1xcbiAgICB9XFxuICAgIG5vZGUuc3R5bGUud2lkdGggPSB3aWR0aCArIFxcXCJweFxcXCI7XFxuICB9XFxuICBpZiAod2lkZ2V0LmNvdmVyR3V0dGVyKSB7XFxuICAgIG5vZGUuc3R5bGUuekluZGV4ID0gNTtcXG4gICAgbm9kZS5zdHlsZS5wb3NpdGlvbiA9IFxcXCJyZWxhdGl2ZVxcXCI7XFxuICAgIGlmICghd2lkZ2V0Lm5vSFNjcm9sbCkgeyBub2RlLnN0eWxlLm1hcmdpbkxlZnQgPSAtZGltcy5ndXR0ZXJUb3RhbFdpZHRoICsgXFxcInB4XFxcIjsgfVxcbiAgfVxcbn1cXG5cXG5mdW5jdGlvbiB3aWRnZXRIZWlnaHQod2lkZ2V0KSB7XFxuICBpZiAod2lkZ2V0LmhlaWdodCAhPSBudWxsKSB7IHJldHVybiB3aWRnZXQuaGVpZ2h0IH1cXG4gIHZhciBjbSA9IHdpZGdldC5kb2MuY207XFxuICBpZiAoIWNtKSB7IHJldHVybiAwIH1cXG4gIGlmICghY29udGFpbnMoZG9jdW1lbnQuYm9keSwgd2lkZ2V0Lm5vZGUpKSB7XFxuICAgIHZhciBwYXJlbnRTdHlsZSA9IFxcXCJwb3NpdGlvbjogcmVsYXRpdmU7XFxcIjtcXG4gICAgaWYgKHdpZGdldC5jb3Zlckd1dHRlcilcXG4gICAgICB7IHBhcmVudFN0eWxlICs9IFxcXCJtYXJnaW4tbGVmdDogLVxcXCIgKyBjbS5kaXNwbGF5Lmd1dHRlcnMub2Zmc2V0V2lkdGggKyBcXFwicHg7XFxcIjsgfVxcbiAgICBpZiAod2lkZ2V0Lm5vSFNjcm9sbClcXG4gICAgICB7IHBhcmVudFN0eWxlICs9IFxcXCJ3aWR0aDogXFxcIiArIGNtLmRpc3BsYXkud3JhcHBlci5jbGllbnRXaWR0aCArIFxcXCJweDtcXFwiOyB9XFxuICAgIHJlbW92ZUNoaWxkcmVuQW5kQWRkKGNtLmRpc3BsYXkubWVhc3VyZSwgZWx0KFxcXCJkaXZcXFwiLCBbd2lkZ2V0Lm5vZGVdLCBudWxsLCBwYXJlbnRTdHlsZSkpO1xcbiAgfVxcbiAgcmV0dXJuIHdpZGdldC5oZWlnaHQgPSB3aWRnZXQubm9kZS5wYXJlbnROb2RlLm9mZnNldEhlaWdodFxcbn1cXG5cXG4vLyBSZXR1cm4gdHJ1ZSB3aGVuIHRoZSBnaXZlbiBtb3VzZSBldmVudCBoYXBwZW5lZCBpbiBhIHdpZGdldFxcbmZ1bmN0aW9uIGV2ZW50SW5XaWRnZXQoZGlzcGxheSwgZSkge1xcbiAgZm9yICh2YXIgbiA9IGVfdGFyZ2V0KGUpOyBuICE9IGRpc3BsYXkud3JhcHBlcjsgbiA9IG4ucGFyZW50Tm9kZSkge1xcbiAgICBpZiAoIW4gfHwgKG4ubm9kZVR5cGUgPT0gMSAmJiBuLmdldEF0dHJpYnV0ZShcXFwiY20taWdub3JlLWV2ZW50c1xcXCIpID09IFxcXCJ0cnVlXFxcIikgfHxcXG4gICAgICAgIChuLnBhcmVudE5vZGUgPT0gZGlzcGxheS5zaXplciAmJiBuICE9IGRpc3BsYXkubW92ZXIpKVxcbiAgICAgIHsgcmV0dXJuIHRydWUgfVxcbiAgfVxcbn1cXG5cXG4vLyBQT1NJVElPTiBNRUFTVVJFTUVOVFxcblxcbmZ1bmN0aW9uIHBhZGRpbmdUb3AoZGlzcGxheSkge3JldHVybiBkaXNwbGF5LmxpbmVTcGFjZS5vZmZzZXRUb3B9XFxuZnVuY3Rpb24gcGFkZGluZ1ZlcnQoZGlzcGxheSkge3JldHVybiBkaXNwbGF5Lm1vdmVyLm9mZnNldEhlaWdodCAtIGRpc3BsYXkubGluZVNwYWNlLm9mZnNldEhlaWdodH1cXG5mdW5jdGlvbiBwYWRkaW5nSChkaXNwbGF5KSB7XFxuICBpZiAoZGlzcGxheS5jYWNoZWRQYWRkaW5nSCkgeyByZXR1cm4gZGlzcGxheS5jYWNoZWRQYWRkaW5nSCB9XFxuICB2YXIgZSA9IHJlbW92ZUNoaWxkcmVuQW5kQWRkKGRpc3BsYXkubWVhc3VyZSwgZWx0KFxcXCJwcmVcXFwiLCBcXFwieFxcXCIpKTtcXG4gIHZhciBzdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlID8gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZSkgOiBlLmN1cnJlbnRTdHlsZTtcXG4gIHZhciBkYXRhID0ge2xlZnQ6IHBhcnNlSW50KHN0eWxlLnBhZGRpbmdMZWZ0KSwgcmlnaHQ6IHBhcnNlSW50KHN0eWxlLnBhZGRpbmdSaWdodCl9O1xcbiAgaWYgKCFpc05hTihkYXRhLmxlZnQpICYmICFpc05hTihkYXRhLnJpZ2h0KSkgeyBkaXNwbGF5LmNhY2hlZFBhZGRpbmdIID0gZGF0YTsgfVxcbiAgcmV0dXJuIGRhdGFcXG59XFxuXFxuZnVuY3Rpb24gc2Nyb2xsR2FwKGNtKSB7IHJldHVybiBzY3JvbGxlckdhcCAtIGNtLmRpc3BsYXkubmF0aXZlQmFyV2lkdGggfVxcbmZ1bmN0aW9uIGRpc3BsYXlXaWR0aChjbSkge1xcbiAgcmV0dXJuIGNtLmRpc3BsYXkuc2Nyb2xsZXIuY2xpZW50V2lkdGggLSBzY3JvbGxHYXAoY20pIC0gY20uZGlzcGxheS5iYXJXaWR0aFxcbn1cXG5mdW5jdGlvbiBkaXNwbGF5SGVpZ2h0KGNtKSB7XFxuICByZXR1cm4gY20uZGlzcGxheS5zY3JvbGxlci5jbGllbnRIZWlnaHQgLSBzY3JvbGxHYXAoY20pIC0gY20uZGlzcGxheS5iYXJIZWlnaHRcXG59XFxuXFxuLy8gRW5zdXJlIHRoZSBsaW5lVmlldy53cmFwcGluZy5oZWlnaHRzIGFycmF5IGlzIHBvcHVsYXRlZC4gVGhpcyBpc1xcbi8vIGFuIGFycmF5IG9mIGJvdHRvbSBvZmZzZXRzIGZvciB0aGUgbGluZXMgdGhhdCBtYWtlIHVwIGEgZHJhd25cXG4vLyBsaW5lLiBXaGVuIGxpbmVXcmFwcGluZyBpcyBvbiwgdGhlcmUgbWlnaHQgYmUgbW9yZSB0aGFuIG9uZVxcbi8vIGhlaWdodC5cXG5mdW5jdGlvbiBlbnN1cmVMaW5lSGVpZ2h0cyhjbSwgbGluZVZpZXcsIHJlY3QpIHtcXG4gIHZhciB3cmFwcGluZyA9IGNtLm9wdGlvbnMubGluZVdyYXBwaW5nO1xcbiAgdmFyIGN1cldpZHRoID0gd3JhcHBpbmcgJiYgZGlzcGxheVdpZHRoKGNtKTtcXG4gIGlmICghbGluZVZpZXcubWVhc3VyZS5oZWlnaHRzIHx8IHdyYXBwaW5nICYmIGxpbmVWaWV3Lm1lYXN1cmUud2lkdGggIT0gY3VyV2lkdGgpIHtcXG4gICAgdmFyIGhlaWdodHMgPSBsaW5lVmlldy5tZWFzdXJlLmhlaWdodHMgPSBbXTtcXG4gICAgaWYgKHdyYXBwaW5nKSB7XFxuICAgICAgbGluZVZpZXcubWVhc3VyZS53aWR0aCA9IGN1cldpZHRoO1xcbiAgICAgIHZhciByZWN0cyA9IGxpbmVWaWV3LnRleHQuZmlyc3RDaGlsZC5nZXRDbGllbnRSZWN0cygpO1xcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVjdHMubGVuZ3RoIC0gMTsgaSsrKSB7XFxuICAgICAgICB2YXIgY3VyID0gcmVjdHNbaV0sIG5leHQgPSByZWN0c1tpICsgMV07XFxuICAgICAgICBpZiAoTWF0aC5hYnMoY3VyLmJvdHRvbSAtIG5leHQuYm90dG9tKSA+IDIpXFxuICAgICAgICAgIHsgaGVpZ2h0cy5wdXNoKChjdXIuYm90dG9tICsgbmV4dC50b3ApIC8gMiAtIHJlY3QudG9wKTsgfVxcbiAgICAgIH1cXG4gICAgfVxcbiAgICBoZWlnaHRzLnB1c2gocmVjdC5ib3R0b20gLSByZWN0LnRvcCk7XFxuICB9XFxufVxcblxcbi8vIEZpbmQgYSBsaW5lIG1hcCAobWFwcGluZyBjaGFyYWN0ZXIgb2Zmc2V0cyB0byB0ZXh0IG5vZGVzKSBhbmQgYVxcbi8vIG1lYXN1cmVtZW50IGNhY2hlIGZvciB0aGUgZ2l2ZW4gbGluZSBudW1iZXIuIChBIGxpbmUgdmlldyBtaWdodFxcbi8vIGNvbnRhaW4gbXVsdGlwbGUgbGluZXMgd2hlbiBjb2xsYXBzZWQgcmFuZ2VzIGFyZSBwcmVzZW50LilcXG5mdW5jdGlvbiBtYXBGcm9tTGluZVZpZXcobGluZVZpZXcsIGxpbmUsIGxpbmVOKSB7XFxuICBpZiAobGluZVZpZXcubGluZSA9PSBsaW5lKVxcbiAgICB7IHJldHVybiB7bWFwOiBsaW5lVmlldy5tZWFzdXJlLm1hcCwgY2FjaGU6IGxpbmVWaWV3Lm1lYXN1cmUuY2FjaGV9IH1cXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGluZVZpZXcucmVzdC5sZW5ndGg7IGkrKylcXG4gICAgeyBpZiAobGluZVZpZXcucmVzdFtpXSA9PSBsaW5lKVxcbiAgICAgIHsgcmV0dXJuIHttYXA6IGxpbmVWaWV3Lm1lYXN1cmUubWFwc1tpXSwgY2FjaGU6IGxpbmVWaWV3Lm1lYXN1cmUuY2FjaGVzW2ldfSB9IH1cXG4gIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IGxpbmVWaWV3LnJlc3QubGVuZ3RoOyBpJDErKylcXG4gICAgeyBpZiAobGluZU5vKGxpbmVWaWV3LnJlc3RbaSQxXSkgPiBsaW5lTilcXG4gICAgICB7IHJldHVybiB7bWFwOiBsaW5lVmlldy5tZWFzdXJlLm1hcHNbaSQxXSwgY2FjaGU6IGxpbmVWaWV3Lm1lYXN1cmUuY2FjaGVzW2kkMV0sIGJlZm9yZTogdHJ1ZX0gfSB9XFxufVxcblxcbi8vIFJlbmRlciBhIGxpbmUgaW50byB0aGUgaGlkZGVuIG5vZGUgZGlzcGxheS5leHRlcm5hbE1lYXN1cmVkLiBVc2VkXFxuLy8gd2hlbiBtZWFzdXJlbWVudCBpcyBuZWVkZWQgZm9yIGEgbGluZSB0aGF0J3Mgbm90IGluIHRoZSB2aWV3cG9ydC5cXG5mdW5jdGlvbiB1cGRhdGVFeHRlcm5hbE1lYXN1cmVtZW50KGNtLCBsaW5lKSB7XFxuICBsaW5lID0gdmlzdWFsTGluZShsaW5lKTtcXG4gIHZhciBsaW5lTiA9IGxpbmVObyhsaW5lKTtcXG4gIHZhciB2aWV3ID0gY20uZGlzcGxheS5leHRlcm5hbE1lYXN1cmVkID0gbmV3IExpbmVWaWV3KGNtLmRvYywgbGluZSwgbGluZU4pO1xcbiAgdmlldy5saW5lTiA9IGxpbmVOO1xcbiAgdmFyIGJ1aWx0ID0gdmlldy5idWlsdCA9IGJ1aWxkTGluZUNvbnRlbnQoY20sIHZpZXcpO1xcbiAgdmlldy50ZXh0ID0gYnVpbHQucHJlO1xcbiAgcmVtb3ZlQ2hpbGRyZW5BbmRBZGQoY20uZGlzcGxheS5saW5lTWVhc3VyZSwgYnVpbHQucHJlKTtcXG4gIHJldHVybiB2aWV3XFxufVxcblxcbi8vIEdldCBhIHt0b3AsIGJvdHRvbSwgbGVmdCwgcmlnaHR9IGJveCAoaW4gbGluZS1sb2NhbCBjb29yZGluYXRlcylcXG4vLyBmb3IgYSBnaXZlbiBjaGFyYWN0ZXIuXFxuZnVuY3Rpb24gbWVhc3VyZUNoYXIoY20sIGxpbmUsIGNoLCBiaWFzKSB7XFxuICByZXR1cm4gbWVhc3VyZUNoYXJQcmVwYXJlZChjbSwgcHJlcGFyZU1lYXN1cmVGb3JMaW5lKGNtLCBsaW5lKSwgY2gsIGJpYXMpXFxufVxcblxcbi8vIEZpbmQgYSBsaW5lIHZpZXcgdGhhdCBjb3JyZXNwb25kcyB0byB0aGUgZ2l2ZW4gbGluZSBudW1iZXIuXFxuZnVuY3Rpb24gZmluZFZpZXdGb3JMaW5lKGNtLCBsaW5lTikge1xcbiAgaWYgKGxpbmVOID49IGNtLmRpc3BsYXkudmlld0Zyb20gJiYgbGluZU4gPCBjbS5kaXNwbGF5LnZpZXdUbylcXG4gICAgeyByZXR1cm4gY20uZGlzcGxheS52aWV3W2ZpbmRWaWV3SW5kZXgoY20sIGxpbmVOKV0gfVxcbiAgdmFyIGV4dCA9IGNtLmRpc3BsYXkuZXh0ZXJuYWxNZWFzdXJlZDtcXG4gIGlmIChleHQgJiYgbGluZU4gPj0gZXh0LmxpbmVOICYmIGxpbmVOIDwgZXh0LmxpbmVOICsgZXh0LnNpemUpXFxuICAgIHsgcmV0dXJuIGV4dCB9XFxufVxcblxcbi8vIE1lYXN1cmVtZW50IGNhbiBiZSBzcGxpdCBpbiB0d28gc3RlcHMsIHRoZSBzZXQtdXAgd29yayB0aGF0XFxuLy8gYXBwbGllcyB0byB0aGUgd2hvbGUgbGluZSwgYW5kIHRoZSBtZWFzdXJlbWVudCBvZiB0aGUgYWN0dWFsXFxuLy8gY2hhcmFjdGVyLiBGdW5jdGlvbnMgbGlrZSBjb29yZHNDaGFyLCB0aGF0IG5lZWQgdG8gZG8gYSBsb3Qgb2ZcXG4vLyBtZWFzdXJlbWVudHMgaW4gYSByb3csIGNhbiB0aHVzIGVuc3VyZSB0aGF0IHRoZSBzZXQtdXAgd29yayBpc1xcbi8vIG9ubHkgZG9uZSBvbmNlLlxcbmZ1bmN0aW9uIHByZXBhcmVNZWFzdXJlRm9yTGluZShjbSwgbGluZSkge1xcbiAgdmFyIGxpbmVOID0gbGluZU5vKGxpbmUpO1xcbiAgdmFyIHZpZXcgPSBmaW5kVmlld0ZvckxpbmUoY20sIGxpbmVOKTtcXG4gIGlmICh2aWV3ICYmICF2aWV3LnRleHQpIHtcXG4gICAgdmlldyA9IG51bGw7XFxuICB9IGVsc2UgaWYgKHZpZXcgJiYgdmlldy5jaGFuZ2VzKSB7XFxuICAgIHVwZGF0ZUxpbmVGb3JDaGFuZ2VzKGNtLCB2aWV3LCBsaW5lTiwgZ2V0RGltZW5zaW9ucyhjbSkpO1xcbiAgICBjbS5jdXJPcC5mb3JjZVVwZGF0ZSA9IHRydWU7XFxuICB9XFxuICBpZiAoIXZpZXcpXFxuICAgIHsgdmlldyA9IHVwZGF0ZUV4dGVybmFsTWVhc3VyZW1lbnQoY20sIGxpbmUpOyB9XFxuXFxuICB2YXIgaW5mbyA9IG1hcEZyb21MaW5lVmlldyh2aWV3LCBsaW5lLCBsaW5lTik7XFxuICByZXR1cm4ge1xcbiAgICBsaW5lOiBsaW5lLCB2aWV3OiB2aWV3LCByZWN0OiBudWxsLFxcbiAgICBtYXA6IGluZm8ubWFwLCBjYWNoZTogaW5mby5jYWNoZSwgYmVmb3JlOiBpbmZvLmJlZm9yZSxcXG4gICAgaGFzSGVpZ2h0czogZmFsc2VcXG4gIH1cXG59XFxuXFxuLy8gR2l2ZW4gYSBwcmVwYXJlZCBtZWFzdXJlbWVudCBvYmplY3QsIG1lYXN1cmVzIHRoZSBwb3NpdGlvbiBvZiBhblxcbi8vIGFjdHVhbCBjaGFyYWN0ZXIgKG9yIGZldGNoZXMgaXQgZnJvbSB0aGUgY2FjaGUpLlxcbmZ1bmN0aW9uIG1lYXN1cmVDaGFyUHJlcGFyZWQoY20sIHByZXBhcmVkLCBjaCwgYmlhcywgdmFySGVpZ2h0KSB7XFxuICBpZiAocHJlcGFyZWQuYmVmb3JlKSB7IGNoID0gLTE7IH1cXG4gIHZhciBrZXkgPSBjaCArIChiaWFzIHx8IFxcXCJcXFwiKSwgZm91bmQ7XFxuICBpZiAocHJlcGFyZWQuY2FjaGUuaGFzT3duUHJvcGVydHkoa2V5KSkge1xcbiAgICBmb3VuZCA9IHByZXBhcmVkLmNhY2hlW2tleV07XFxuICB9IGVsc2Uge1xcbiAgICBpZiAoIXByZXBhcmVkLnJlY3QpXFxuICAgICAgeyBwcmVwYXJlZC5yZWN0ID0gcHJlcGFyZWQudmlldy50ZXh0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpOyB9XFxuICAgIGlmICghcHJlcGFyZWQuaGFzSGVpZ2h0cykge1xcbiAgICAgIGVuc3VyZUxpbmVIZWlnaHRzKGNtLCBwcmVwYXJlZC52aWV3LCBwcmVwYXJlZC5yZWN0KTtcXG4gICAgICBwcmVwYXJlZC5oYXNIZWlnaHRzID0gdHJ1ZTtcXG4gICAgfVxcbiAgICBmb3VuZCA9IG1lYXN1cmVDaGFySW5uZXIoY20sIHByZXBhcmVkLCBjaCwgYmlhcyk7XFxuICAgIGlmICghZm91bmQuYm9ndXMpIHsgcHJlcGFyZWQuY2FjaGVba2V5XSA9IGZvdW5kOyB9XFxuICB9XFxuICByZXR1cm4ge2xlZnQ6IGZvdW5kLmxlZnQsIHJpZ2h0OiBmb3VuZC5yaWdodCxcXG4gICAgICAgICAgdG9wOiB2YXJIZWlnaHQgPyBmb3VuZC5ydG9wIDogZm91bmQudG9wLFxcbiAgICAgICAgICBib3R0b206IHZhckhlaWdodCA/IGZvdW5kLnJib3R0b20gOiBmb3VuZC5ib3R0b219XFxufVxcblxcbnZhciBudWxsUmVjdCA9IHtsZWZ0OiAwLCByaWdodDogMCwgdG9wOiAwLCBib3R0b206IDB9O1xcblxcbmZ1bmN0aW9uIG5vZGVBbmRPZmZzZXRJbkxpbmVNYXAobWFwJCQxLCBjaCwgYmlhcykge1xcbiAgdmFyIG5vZGUsIHN0YXJ0LCBlbmQsIGNvbGxhcHNlLCBtU3RhcnQsIG1FbmQ7XFxuICAvLyBGaXJzdCwgc2VhcmNoIHRoZSBsaW5lIG1hcCBmb3IgdGhlIHRleHQgbm9kZSBjb3JyZXNwb25kaW5nIHRvLFxcbiAgLy8gb3IgY2xvc2VzdCB0bywgdGhlIHRhcmdldCBjaGFyYWN0ZXIuXFxuICBmb3IgKHZhciBpID0gMDsgaSA8IG1hcCQkMS5sZW5ndGg7IGkgKz0gMykge1xcbiAgICBtU3RhcnQgPSBtYXAkJDFbaV07XFxuICAgIG1FbmQgPSBtYXAkJDFbaSArIDFdO1xcbiAgICBpZiAoY2ggPCBtU3RhcnQpIHtcXG4gICAgICBzdGFydCA9IDA7IGVuZCA9IDE7XFxuICAgICAgY29sbGFwc2UgPSBcXFwibGVmdFxcXCI7XFxuICAgIH0gZWxzZSBpZiAoY2ggPCBtRW5kKSB7XFxuICAgICAgc3RhcnQgPSBjaCAtIG1TdGFydDtcXG4gICAgICBlbmQgPSBzdGFydCArIDE7XFxuICAgIH0gZWxzZSBpZiAoaSA9PSBtYXAkJDEubGVuZ3RoIC0gMyB8fCBjaCA9PSBtRW5kICYmIG1hcCQkMVtpICsgM10gPiBjaCkge1xcbiAgICAgIGVuZCA9IG1FbmQgLSBtU3RhcnQ7XFxuICAgICAgc3RhcnQgPSBlbmQgLSAxO1xcbiAgICAgIGlmIChjaCA+PSBtRW5kKSB7IGNvbGxhcHNlID0gXFxcInJpZ2h0XFxcIjsgfVxcbiAgICB9XFxuICAgIGlmIChzdGFydCAhPSBudWxsKSB7XFxuICAgICAgbm9kZSA9IG1hcCQkMVtpICsgMl07XFxuICAgICAgaWYgKG1TdGFydCA9PSBtRW5kICYmIGJpYXMgPT0gKG5vZGUuaW5zZXJ0TGVmdCA/IFxcXCJsZWZ0XFxcIiA6IFxcXCJyaWdodFxcXCIpKVxcbiAgICAgICAgeyBjb2xsYXBzZSA9IGJpYXM7IH1cXG4gICAgICBpZiAoYmlhcyA9PSBcXFwibGVmdFxcXCIgJiYgc3RhcnQgPT0gMClcXG4gICAgICAgIHsgd2hpbGUgKGkgJiYgbWFwJCQxW2kgLSAyXSA9PSBtYXAkJDFbaSAtIDNdICYmIG1hcCQkMVtpIC0gMV0uaW5zZXJ0TGVmdCkge1xcbiAgICAgICAgICBub2RlID0gbWFwJCQxWyhpIC09IDMpICsgMl07XFxuICAgICAgICAgIGNvbGxhcHNlID0gXFxcImxlZnRcXFwiO1xcbiAgICAgICAgfSB9XFxuICAgICAgaWYgKGJpYXMgPT0gXFxcInJpZ2h0XFxcIiAmJiBzdGFydCA9PSBtRW5kIC0gbVN0YXJ0KVxcbiAgICAgICAgeyB3aGlsZSAoaSA8IG1hcCQkMS5sZW5ndGggLSAzICYmIG1hcCQkMVtpICsgM10gPT0gbWFwJCQxW2kgKyA0XSAmJiAhbWFwJCQxW2kgKyA1XS5pbnNlcnRMZWZ0KSB7XFxuICAgICAgICAgIG5vZGUgPSBtYXAkJDFbKGkgKz0gMykgKyAyXTtcXG4gICAgICAgICAgY29sbGFwc2UgPSBcXFwicmlnaHRcXFwiO1xcbiAgICAgICAgfSB9XFxuICAgICAgYnJlYWtcXG4gICAgfVxcbiAgfVxcbiAgcmV0dXJuIHtub2RlOiBub2RlLCBzdGFydDogc3RhcnQsIGVuZDogZW5kLCBjb2xsYXBzZTogY29sbGFwc2UsIGNvdmVyU3RhcnQ6IG1TdGFydCwgY292ZXJFbmQ6IG1FbmR9XFxufVxcblxcbmZ1bmN0aW9uIGdldFVzZWZ1bFJlY3QocmVjdHMsIGJpYXMpIHtcXG4gIHZhciByZWN0ID0gbnVsbFJlY3Q7XFxuICBpZiAoYmlhcyA9PSBcXFwibGVmdFxcXCIpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCByZWN0cy5sZW5ndGg7IGkrKykge1xcbiAgICBpZiAoKHJlY3QgPSByZWN0c1tpXSkubGVmdCAhPSByZWN0LnJpZ2h0KSB7IGJyZWFrIH1cXG4gIH0gfSBlbHNlIHsgZm9yICh2YXIgaSQxID0gcmVjdHMubGVuZ3RoIC0gMTsgaSQxID49IDA7IGkkMS0tKSB7XFxuICAgIGlmICgocmVjdCA9IHJlY3RzW2kkMV0pLmxlZnQgIT0gcmVjdC5yaWdodCkgeyBicmVhayB9XFxuICB9IH1cXG4gIHJldHVybiByZWN0XFxufVxcblxcbmZ1bmN0aW9uIG1lYXN1cmVDaGFySW5uZXIoY20sIHByZXBhcmVkLCBjaCwgYmlhcykge1xcbiAgdmFyIHBsYWNlID0gbm9kZUFuZE9mZnNldEluTGluZU1hcChwcmVwYXJlZC5tYXAsIGNoLCBiaWFzKTtcXG4gIHZhciBub2RlID0gcGxhY2Uubm9kZSwgc3RhcnQgPSBwbGFjZS5zdGFydCwgZW5kID0gcGxhY2UuZW5kLCBjb2xsYXBzZSA9IHBsYWNlLmNvbGxhcHNlO1xcblxcbiAgdmFyIHJlY3Q7XFxuICBpZiAobm9kZS5ub2RlVHlwZSA9PSAzKSB7IC8vIElmIGl0IGlzIGEgdGV4dCBub2RlLCB1c2UgYSByYW5nZSB0byByZXRyaWV2ZSB0aGUgY29vcmRpbmF0ZXMuXFxuICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IDQ7IGkkMSsrKSB7IC8vIFJldHJ5IGEgbWF4aW11bSBvZiA0IHRpbWVzIHdoZW4gbm9uc2Vuc2UgcmVjdGFuZ2xlcyBhcmUgcmV0dXJuZWRcXG4gICAgICB3aGlsZSAoc3RhcnQgJiYgaXNFeHRlbmRpbmdDaGFyKHByZXBhcmVkLmxpbmUudGV4dC5jaGFyQXQocGxhY2UuY292ZXJTdGFydCArIHN0YXJ0KSkpIHsgLS1zdGFydDsgfVxcbiAgICAgIHdoaWxlIChwbGFjZS5jb3ZlclN0YXJ0ICsgZW5kIDwgcGxhY2UuY292ZXJFbmQgJiYgaXNFeHRlbmRpbmdDaGFyKHByZXBhcmVkLmxpbmUudGV4dC5jaGFyQXQocGxhY2UuY292ZXJTdGFydCArIGVuZCkpKSB7ICsrZW5kOyB9XFxuICAgICAgaWYgKGllICYmIGllX3ZlcnNpb24gPCA5ICYmIHN0YXJ0ID09IDAgJiYgZW5kID09IHBsYWNlLmNvdmVyRW5kIC0gcGxhY2UuY292ZXJTdGFydClcXG4gICAgICAgIHsgcmVjdCA9IG5vZGUucGFyZW50Tm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTsgfVxcbiAgICAgIGVsc2VcXG4gICAgICAgIHsgcmVjdCA9IGdldFVzZWZ1bFJlY3QocmFuZ2Uobm9kZSwgc3RhcnQsIGVuZCkuZ2V0Q2xpZW50UmVjdHMoKSwgYmlhcyk7IH1cXG4gICAgICBpZiAocmVjdC5sZWZ0IHx8IHJlY3QucmlnaHQgfHwgc3RhcnQgPT0gMCkgeyBicmVhayB9XFxuICAgICAgZW5kID0gc3RhcnQ7XFxuICAgICAgc3RhcnQgPSBzdGFydCAtIDE7XFxuICAgICAgY29sbGFwc2UgPSBcXFwicmlnaHRcXFwiO1xcbiAgICB9XFxuICAgIGlmIChpZSAmJiBpZV92ZXJzaW9uIDwgMTEpIHsgcmVjdCA9IG1heWJlVXBkYXRlUmVjdEZvclpvb21pbmcoY20uZGlzcGxheS5tZWFzdXJlLCByZWN0KTsgfVxcbiAgfSBlbHNlIHsgLy8gSWYgaXQgaXMgYSB3aWRnZXQsIHNpbXBseSBnZXQgdGhlIGJveCBmb3IgdGhlIHdob2xlIHdpZGdldC5cXG4gICAgaWYgKHN0YXJ0ID4gMCkgeyBjb2xsYXBzZSA9IGJpYXMgPSBcXFwicmlnaHRcXFwiOyB9XFxuICAgIHZhciByZWN0cztcXG4gICAgaWYgKGNtLm9wdGlvbnMubGluZVdyYXBwaW5nICYmIChyZWN0cyA9IG5vZGUuZ2V0Q2xpZW50UmVjdHMoKSkubGVuZ3RoID4gMSlcXG4gICAgICB7IHJlY3QgPSByZWN0c1tiaWFzID09IFxcXCJyaWdodFxcXCIgPyByZWN0cy5sZW5ndGggLSAxIDogMF07IH1cXG4gICAgZWxzZVxcbiAgICAgIHsgcmVjdCA9IG5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7IH1cXG4gIH1cXG4gIGlmIChpZSAmJiBpZV92ZXJzaW9uIDwgOSAmJiAhc3RhcnQgJiYgKCFyZWN0IHx8ICFyZWN0LmxlZnQgJiYgIXJlY3QucmlnaHQpKSB7XFxuICAgIHZhciByU3BhbiA9IG5vZGUucGFyZW50Tm9kZS5nZXRDbGllbnRSZWN0cygpWzBdO1xcbiAgICBpZiAoclNwYW4pXFxuICAgICAgeyByZWN0ID0ge2xlZnQ6IHJTcGFuLmxlZnQsIHJpZ2h0OiByU3Bhbi5sZWZ0ICsgY2hhcldpZHRoKGNtLmRpc3BsYXkpLCB0b3A6IHJTcGFuLnRvcCwgYm90dG9tOiByU3Bhbi5ib3R0b219OyB9XFxuICAgIGVsc2VcXG4gICAgICB7IHJlY3QgPSBudWxsUmVjdDsgfVxcbiAgfVxcblxcbiAgdmFyIHJ0b3AgPSByZWN0LnRvcCAtIHByZXBhcmVkLnJlY3QudG9wLCByYm90ID0gcmVjdC5ib3R0b20gLSBwcmVwYXJlZC5yZWN0LnRvcDtcXG4gIHZhciBtaWQgPSAocnRvcCArIHJib3QpIC8gMjtcXG4gIHZhciBoZWlnaHRzID0gcHJlcGFyZWQudmlldy5tZWFzdXJlLmhlaWdodHM7XFxuICB2YXIgaSA9IDA7XFxuICBmb3IgKDsgaSA8IGhlaWdodHMubGVuZ3RoIC0gMTsgaSsrKVxcbiAgICB7IGlmIChtaWQgPCBoZWlnaHRzW2ldKSB7IGJyZWFrIH0gfVxcbiAgdmFyIHRvcCA9IGkgPyBoZWlnaHRzW2kgLSAxXSA6IDAsIGJvdCA9IGhlaWdodHNbaV07XFxuICB2YXIgcmVzdWx0ID0ge2xlZnQ6IChjb2xsYXBzZSA9PSBcXFwicmlnaHRcXFwiID8gcmVjdC5yaWdodCA6IHJlY3QubGVmdCkgLSBwcmVwYXJlZC5yZWN0LmxlZnQsXFxuICAgICAgICAgICAgICAgIHJpZ2h0OiAoY29sbGFwc2UgPT0gXFxcImxlZnRcXFwiID8gcmVjdC5sZWZ0IDogcmVjdC5yaWdodCkgLSBwcmVwYXJlZC5yZWN0LmxlZnQsXFxuICAgICAgICAgICAgICAgIHRvcDogdG9wLCBib3R0b206IGJvdH07XFxuICBpZiAoIXJlY3QubGVmdCAmJiAhcmVjdC5yaWdodCkgeyByZXN1bHQuYm9ndXMgPSB0cnVlOyB9XFxuICBpZiAoIWNtLm9wdGlvbnMuc2luZ2xlQ3Vyc29ySGVpZ2h0UGVyTGluZSkgeyByZXN1bHQucnRvcCA9IHJ0b3A7IHJlc3VsdC5yYm90dG9tID0gcmJvdDsgfVxcblxcbiAgcmV0dXJuIHJlc3VsdFxcbn1cXG5cXG4vLyBXb3JrIGFyb3VuZCBwcm9ibGVtIHdpdGggYm91bmRpbmcgY2xpZW50IHJlY3RzIG9uIHJhbmdlcyBiZWluZ1xcbi8vIHJldHVybmVkIGluY29ycmVjdGx5IHdoZW4gem9vbWVkIG9uIElFMTAgYW5kIGJlbG93LlxcbmZ1bmN0aW9uIG1heWJlVXBkYXRlUmVjdEZvclpvb21pbmcobWVhc3VyZSwgcmVjdCkge1xcbiAgaWYgKCF3aW5kb3cuc2NyZWVuIHx8IHNjcmVlbi5sb2dpY2FsWERQSSA9PSBudWxsIHx8XFxuICAgICAgc2NyZWVuLmxvZ2ljYWxYRFBJID09IHNjcmVlbi5kZXZpY2VYRFBJIHx8ICFoYXNCYWRab29tZWRSZWN0cyhtZWFzdXJlKSlcXG4gICAgeyByZXR1cm4gcmVjdCB9XFxuICB2YXIgc2NhbGVYID0gc2NyZWVuLmxvZ2ljYWxYRFBJIC8gc2NyZWVuLmRldmljZVhEUEk7XFxuICB2YXIgc2NhbGVZID0gc2NyZWVuLmxvZ2ljYWxZRFBJIC8gc2NyZWVuLmRldmljZVlEUEk7XFxuICByZXR1cm4ge2xlZnQ6IHJlY3QubGVmdCAqIHNjYWxlWCwgcmlnaHQ6IHJlY3QucmlnaHQgKiBzY2FsZVgsXFxuICAgICAgICAgIHRvcDogcmVjdC50b3AgKiBzY2FsZVksIGJvdHRvbTogcmVjdC5ib3R0b20gKiBzY2FsZVl9XFxufVxcblxcbmZ1bmN0aW9uIGNsZWFyTGluZU1lYXN1cmVtZW50Q2FjaGVGb3IobGluZVZpZXcpIHtcXG4gIGlmIChsaW5lVmlldy5tZWFzdXJlKSB7XFxuICAgIGxpbmVWaWV3Lm1lYXN1cmUuY2FjaGUgPSB7fTtcXG4gICAgbGluZVZpZXcubWVhc3VyZS5oZWlnaHRzID0gbnVsbDtcXG4gICAgaWYgKGxpbmVWaWV3LnJlc3QpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lVmlldy5yZXN0Lmxlbmd0aDsgaSsrKVxcbiAgICAgIHsgbGluZVZpZXcubWVhc3VyZS5jYWNoZXNbaV0gPSB7fTsgfSB9XFxuICB9XFxufVxcblxcbmZ1bmN0aW9uIGNsZWFyTGluZU1lYXN1cmVtZW50Q2FjaGUoY20pIHtcXG4gIGNtLmRpc3BsYXkuZXh0ZXJuYWxNZWFzdXJlID0gbnVsbDtcXG4gIHJlbW92ZUNoaWxkcmVuKGNtLmRpc3BsYXkubGluZU1lYXN1cmUpO1xcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjbS5kaXNwbGF5LnZpZXcubGVuZ3RoOyBpKyspXFxuICAgIHsgY2xlYXJMaW5lTWVhc3VyZW1lbnRDYWNoZUZvcihjbS5kaXNwbGF5LnZpZXdbaV0pOyB9XFxufVxcblxcbmZ1bmN0aW9uIGNsZWFyQ2FjaGVzKGNtKSB7XFxuICBjbGVhckxpbmVNZWFzdXJlbWVudENhY2hlKGNtKTtcXG4gIGNtLmRpc3BsYXkuY2FjaGVkQ2hhcldpZHRoID0gY20uZGlzcGxheS5jYWNoZWRUZXh0SGVpZ2h0ID0gY20uZGlzcGxheS5jYWNoZWRQYWRkaW5nSCA9IG51bGw7XFxuICBpZiAoIWNtLm9wdGlvbnMubGluZVdyYXBwaW5nKSB7IGNtLmRpc3BsYXkubWF4TGluZUNoYW5nZWQgPSB0cnVlOyB9XFxuICBjbS5kaXNwbGF5LmxpbmVOdW1DaGFycyA9IG51bGw7XFxufVxcblxcbmZ1bmN0aW9uIHBhZ2VTY3JvbGxYKCkgeyByZXR1cm4gd2luZG93LnBhZ2VYT2Zmc2V0IHx8IChkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgfHwgZG9jdW1lbnQuYm9keSkuc2Nyb2xsTGVmdCB9XFxuZnVuY3Rpb24gcGFnZVNjcm9sbFkoKSB7IHJldHVybiB3aW5kb3cucGFnZVlPZmZzZXQgfHwgKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCB8fCBkb2N1bWVudC5ib2R5KS5zY3JvbGxUb3AgfVxcblxcbi8vIENvbnZlcnRzIGEge3RvcCwgYm90dG9tLCBsZWZ0LCByaWdodH0gYm94IGZyb20gbGluZS1sb2NhbFxcbi8vIGNvb3JkaW5hdGVzIGludG8gYW5vdGhlciBjb29yZGluYXRlIHN5c3RlbS4gQ29udGV4dCBtYXkgYmUgb25lIG9mXFxuLy8gXFxcImxpbmVcXFwiLCBcXFwiZGl2XFxcIiAoZGlzcGxheS5saW5lRGl2KSwgXFxcImxvY2FsXFxcIi4vbnVsbCAoZWRpdG9yKSwgXFxcIndpbmRvd1xcXCIsXFxuLy8gb3IgXFxcInBhZ2VcXFwiLlxcbmZ1bmN0aW9uIGludG9Db29yZFN5c3RlbShjbSwgbGluZU9iaiwgcmVjdCwgY29udGV4dCwgaW5jbHVkZVdpZGdldHMpIHtcXG4gIGlmICghaW5jbHVkZVdpZGdldHMgJiYgbGluZU9iai53aWRnZXRzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgbGluZU9iai53aWRnZXRzLmxlbmd0aDsgKytpKSB7IGlmIChsaW5lT2JqLndpZGdldHNbaV0uYWJvdmUpIHtcXG4gICAgdmFyIHNpemUgPSB3aWRnZXRIZWlnaHQobGluZU9iai53aWRnZXRzW2ldKTtcXG4gICAgcmVjdC50b3AgKz0gc2l6ZTsgcmVjdC5ib3R0b20gKz0gc2l6ZTtcXG4gIH0gfSB9XFxuICBpZiAoY29udGV4dCA9PSBcXFwibGluZVxcXCIpIHsgcmV0dXJuIHJlY3QgfVxcbiAgaWYgKCFjb250ZXh0KSB7IGNvbnRleHQgPSBcXFwibG9jYWxcXFwiOyB9XFxuICB2YXIgeU9mZiA9IGhlaWdodEF0TGluZShsaW5lT2JqKTtcXG4gIGlmIChjb250ZXh0ID09IFxcXCJsb2NhbFxcXCIpIHsgeU9mZiArPSBwYWRkaW5nVG9wKGNtLmRpc3BsYXkpOyB9XFxuICBlbHNlIHsgeU9mZiAtPSBjbS5kaXNwbGF5LnZpZXdPZmZzZXQ7IH1cXG4gIGlmIChjb250ZXh0ID09IFxcXCJwYWdlXFxcIiB8fCBjb250ZXh0ID09IFxcXCJ3aW5kb3dcXFwiKSB7XFxuICAgIHZhciBsT2ZmID0gY20uZGlzcGxheS5saW5lU3BhY2UuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XFxuICAgIHlPZmYgKz0gbE9mZi50b3AgKyAoY29udGV4dCA9PSBcXFwid2luZG93XFxcIiA/IDAgOiBwYWdlU2Nyb2xsWSgpKTtcXG4gICAgdmFyIHhPZmYgPSBsT2ZmLmxlZnQgKyAoY29udGV4dCA9PSBcXFwid2luZG93XFxcIiA/IDAgOiBwYWdlU2Nyb2xsWCgpKTtcXG4gICAgcmVjdC5sZWZ0ICs9IHhPZmY7IHJlY3QucmlnaHQgKz0geE9mZjtcXG4gIH1cXG4gIHJlY3QudG9wICs9IHlPZmY7IHJlY3QuYm90dG9tICs9IHlPZmY7XFxuICByZXR1cm4gcmVjdFxcbn1cXG5cXG4vLyBDb3ZlcnRzIGEgYm94IGZyb20gXFxcImRpdlxcXCIgY29vcmRzIHRvIGFub3RoZXIgY29vcmRpbmF0ZSBzeXN0ZW0uXFxuLy8gQ29udGV4dCBtYXkgYmUgXFxcIndpbmRvd1xcXCIsIFxcXCJwYWdlXFxcIiwgXFxcImRpdlxcXCIsIG9yIFxcXCJsb2NhbFxcXCIuL251bGwuXFxuZnVuY3Rpb24gZnJvbUNvb3JkU3lzdGVtKGNtLCBjb29yZHMsIGNvbnRleHQpIHtcXG4gIGlmIChjb250ZXh0ID09IFxcXCJkaXZcXFwiKSB7IHJldHVybiBjb29yZHMgfVxcbiAgdmFyIGxlZnQgPSBjb29yZHMubGVmdCwgdG9wID0gY29vcmRzLnRvcDtcXG4gIC8vIEZpcnN0IG1vdmUgaW50byBcXFwicGFnZVxcXCIgY29vcmRpbmF0ZSBzeXN0ZW1cXG4gIGlmIChjb250ZXh0ID09IFxcXCJwYWdlXFxcIikge1xcbiAgICBsZWZ0IC09IHBhZ2VTY3JvbGxYKCk7XFxuICAgIHRvcCAtPSBwYWdlU2Nyb2xsWSgpO1xcbiAgfSBlbHNlIGlmIChjb250ZXh0ID09IFxcXCJsb2NhbFxcXCIgfHwgIWNvbnRleHQpIHtcXG4gICAgdmFyIGxvY2FsQm94ID0gY20uZGlzcGxheS5zaXplci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcXG4gICAgbGVmdCArPSBsb2NhbEJveC5sZWZ0O1xcbiAgICB0b3AgKz0gbG9jYWxCb3gudG9wO1xcbiAgfVxcblxcbiAgdmFyIGxpbmVTcGFjZUJveCA9IGNtLmRpc3BsYXkubGluZVNwYWNlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xcbiAgcmV0dXJuIHtsZWZ0OiBsZWZ0IC0gbGluZVNwYWNlQm94LmxlZnQsIHRvcDogdG9wIC0gbGluZVNwYWNlQm94LnRvcH1cXG59XFxuXFxuZnVuY3Rpb24gY2hhckNvb3JkcyhjbSwgcG9zLCBjb250ZXh0LCBsaW5lT2JqLCBiaWFzKSB7XFxuICBpZiAoIWxpbmVPYmopIHsgbGluZU9iaiA9IGdldExpbmUoY20uZG9jLCBwb3MubGluZSk7IH1cXG4gIHJldHVybiBpbnRvQ29vcmRTeXN0ZW0oY20sIGxpbmVPYmosIG1lYXN1cmVDaGFyKGNtLCBsaW5lT2JqLCBwb3MuY2gsIGJpYXMpLCBjb250ZXh0KVxcbn1cXG5cXG4vLyBSZXR1cm5zIGEgYm94IGZvciBhIGdpdmVuIGN1cnNvciBwb3NpdGlvbiwgd2hpY2ggbWF5IGhhdmUgYW5cXG4vLyAnb3RoZXInIHByb3BlcnR5IGNvbnRhaW5pbmcgdGhlIHBvc2l0aW9uIG9mIHRoZSBzZWNvbmRhcnkgY3Vyc29yXFxuLy8gb24gYSBiaWRpIGJvdW5kYXJ5Llxcbi8vIEEgY3Vyc29yIFBvcyhsaW5lLCBjaGFyLCBcXFwiYmVmb3JlXFxcIikgaXMgb24gdGhlIHNhbWUgdmlzdWFsIGxpbmUgYXMgYGNoYXIgLSAxYFxcbi8vIGFuZCBhZnRlciBgY2hhciAtIDFgIGluIHdyaXRpbmcgb3JkZXIgb2YgYGNoYXIgLSAxYFxcbi8vIEEgY3Vyc29yIFBvcyhsaW5lLCBjaGFyLCBcXFwiYWZ0ZXJcXFwiKSBpcyBvbiB0aGUgc2FtZSB2aXN1YWwgbGluZSBhcyBgY2hhcmBcXG4vLyBhbmQgYmVmb3JlIGBjaGFyYCBpbiB3cml0aW5nIG9yZGVyIG9mIGBjaGFyYFxcbi8vIEV4YW1wbGVzICh1cHBlci1jYXNlIGxldHRlcnMgYXJlIFJUTCwgbG93ZXItY2FzZSBhcmUgTFRSKTpcXG4vLyAgICAgUG9zKDAsIDEsIC4uLilcXG4vLyAgICAgYmVmb3JlICAgYWZ0ZXJcXG4vLyBhYiAgICAgYXxiICAgICBhfGJcXG4vLyBhQiAgICAgYXxCICAgICBhQnxcXG4vLyBBYiAgICAgfEFiICAgICBBfGJcXG4vLyBBQiAgICAgQnxBICAgICBCfEFcXG4vLyBFdmVyeSBwb3NpdGlvbiBhZnRlciB0aGUgbGFzdCBjaGFyYWN0ZXIgb24gYSBsaW5lIGlzIGNvbnNpZGVyZWQgdG8gc3RpY2tcXG4vLyB0byB0aGUgbGFzdCBjaGFyYWN0ZXIgb24gdGhlIGxpbmUuXFxuZnVuY3Rpb24gY3Vyc29yQ29vcmRzKGNtLCBwb3MsIGNvbnRleHQsIGxpbmVPYmosIHByZXBhcmVkTWVhc3VyZSwgdmFySGVpZ2h0KSB7XFxuICBsaW5lT2JqID0gbGluZU9iaiB8fCBnZXRMaW5lKGNtLmRvYywgcG9zLmxpbmUpO1xcbiAgaWYgKCFwcmVwYXJlZE1lYXN1cmUpIHsgcHJlcGFyZWRNZWFzdXJlID0gcHJlcGFyZU1lYXN1cmVGb3JMaW5lKGNtLCBsaW5lT2JqKTsgfVxcbiAgZnVuY3Rpb24gZ2V0KGNoLCByaWdodCkge1xcbiAgICB2YXIgbSA9IG1lYXN1cmVDaGFyUHJlcGFyZWQoY20sIHByZXBhcmVkTWVhc3VyZSwgY2gsIHJpZ2h0ID8gXFxcInJpZ2h0XFxcIiA6IFxcXCJsZWZ0XFxcIiwgdmFySGVpZ2h0KTtcXG4gICAgaWYgKHJpZ2h0KSB7IG0ubGVmdCA9IG0ucmlnaHQ7IH0gZWxzZSB7IG0ucmlnaHQgPSBtLmxlZnQ7IH1cXG4gICAgcmV0dXJuIGludG9Db29yZFN5c3RlbShjbSwgbGluZU9iaiwgbSwgY29udGV4dClcXG4gIH1cXG4gIHZhciBvcmRlciA9IGdldE9yZGVyKGxpbmVPYmosIGNtLmRvYy5kaXJlY3Rpb24pLCBjaCA9IHBvcy5jaCwgc3RpY2t5ID0gcG9zLnN0aWNreTtcXG4gIGlmIChjaCA+PSBsaW5lT2JqLnRleHQubGVuZ3RoKSB7XFxuICAgIGNoID0gbGluZU9iai50ZXh0Lmxlbmd0aDtcXG4gICAgc3RpY2t5ID0gXFxcImJlZm9yZVxcXCI7XFxuICB9IGVsc2UgaWYgKGNoIDw9IDApIHtcXG4gICAgY2ggPSAwO1xcbiAgICBzdGlja3kgPSBcXFwiYWZ0ZXJcXFwiO1xcbiAgfVxcbiAgaWYgKCFvcmRlcikgeyByZXR1cm4gZ2V0KHN0aWNreSA9PSBcXFwiYmVmb3JlXFxcIiA/IGNoIC0gMSA6IGNoLCBzdGlja3kgPT0gXFxcImJlZm9yZVxcXCIpIH1cXG5cXG4gIGZ1bmN0aW9uIGdldEJpZGkoY2gsIHBhcnRQb3MsIGludmVydCkge1xcbiAgICB2YXIgcGFydCA9IG9yZGVyW3BhcnRQb3NdLCByaWdodCA9IChwYXJ0LmxldmVsICUgMikgIT0gMDtcXG4gICAgcmV0dXJuIGdldChpbnZlcnQgPyBjaCAtIDEgOiBjaCwgcmlnaHQgIT0gaW52ZXJ0KVxcbiAgfVxcbiAgdmFyIHBhcnRQb3MgPSBnZXRCaWRpUGFydEF0KG9yZGVyLCBjaCwgc3RpY2t5KTtcXG4gIHZhciBvdGhlciA9IGJpZGlPdGhlcjtcXG4gIHZhciB2YWwgPSBnZXRCaWRpKGNoLCBwYXJ0UG9zLCBzdGlja3kgPT0gXFxcImJlZm9yZVxcXCIpO1xcbiAgaWYgKG90aGVyICE9IG51bGwpIHsgdmFsLm90aGVyID0gZ2V0QmlkaShjaCwgb3RoZXIsIHN0aWNreSAhPSBcXFwiYmVmb3JlXFxcIik7IH1cXG4gIHJldHVybiB2YWxcXG59XFxuXFxuLy8gVXNlZCB0byBjaGVhcGx5IGVzdGltYXRlIHRoZSBjb29yZGluYXRlcyBmb3IgYSBwb3NpdGlvbi4gVXNlZCBmb3JcXG4vLyBpbnRlcm1lZGlhdGUgc2Nyb2xsIHVwZGF0ZXMuXFxuZnVuY3Rpb24gZXN0aW1hdGVDb29yZHMoY20sIHBvcykge1xcbiAgdmFyIGxlZnQgPSAwO1xcbiAgcG9zID0gY2xpcFBvcyhjbS5kb2MsIHBvcyk7XFxuICBpZiAoIWNtLm9wdGlvbnMubGluZVdyYXBwaW5nKSB7IGxlZnQgPSBjaGFyV2lkdGgoY20uZGlzcGxheSkgKiBwb3MuY2g7IH1cXG4gIHZhciBsaW5lT2JqID0gZ2V0TGluZShjbS5kb2MsIHBvcy5saW5lKTtcXG4gIHZhciB0b3AgPSBoZWlnaHRBdExpbmUobGluZU9iaikgKyBwYWRkaW5nVG9wKGNtLmRpc3BsYXkpO1xcbiAgcmV0dXJuIHtsZWZ0OiBsZWZ0LCByaWdodDogbGVmdCwgdG9wOiB0b3AsIGJvdHRvbTogdG9wICsgbGluZU9iai5oZWlnaHR9XFxufVxcblxcbi8vIFBvc2l0aW9ucyByZXR1cm5lZCBieSBjb29yZHNDaGFyIGNvbnRhaW4gc29tZSBleHRyYSBpbmZvcm1hdGlvbi5cXG4vLyB4UmVsIGlzIHRoZSByZWxhdGl2ZSB4IHBvc2l0aW9uIG9mIHRoZSBpbnB1dCBjb29yZGluYXRlcyBjb21wYXJlZFxcbi8vIHRvIHRoZSBmb3VuZCBwb3NpdGlvbiAoc28geFJlbCA+IDAgbWVhbnMgdGhlIGNvb3JkaW5hdGVzIGFyZSB0b1xcbi8vIHRoZSByaWdodCBvZiB0aGUgY2hhcmFjdGVyIHBvc2l0aW9uLCBmb3IgZXhhbXBsZSkuIFdoZW4gb3V0c2lkZVxcbi8vIGlzIHRydWUsIHRoYXQgbWVhbnMgdGhlIGNvb3JkaW5hdGVzIGxpZSBvdXRzaWRlIHRoZSBsaW5lJ3NcXG4vLyB2ZXJ0aWNhbCByYW5nZS5cXG5mdW5jdGlvbiBQb3NXaXRoSW5mbyhsaW5lLCBjaCwgc3RpY2t5LCBvdXRzaWRlLCB4UmVsKSB7XFxuICB2YXIgcG9zID0gUG9zKGxpbmUsIGNoLCBzdGlja3kpO1xcbiAgcG9zLnhSZWwgPSB4UmVsO1xcbiAgaWYgKG91dHNpZGUpIHsgcG9zLm91dHNpZGUgPSB0cnVlOyB9XFxuICByZXR1cm4gcG9zXFxufVxcblxcbi8vIENvbXB1dGUgdGhlIGNoYXJhY3RlciBwb3NpdGlvbiBjbG9zZXN0IHRvIHRoZSBnaXZlbiBjb29yZGluYXRlcy5cXG4vLyBJbnB1dCBtdXN0IGJlIGxpbmVTcGFjZS1sb2NhbCAoXFxcImRpdlxcXCIgY29vcmRpbmF0ZSBzeXN0ZW0pLlxcbmZ1bmN0aW9uIGNvb3Jkc0NoYXIoY20sIHgsIHkpIHtcXG4gIHZhciBkb2MgPSBjbS5kb2M7XFxuICB5ICs9IGNtLmRpc3BsYXkudmlld09mZnNldDtcXG4gIGlmICh5IDwgMCkgeyByZXR1cm4gUG9zV2l0aEluZm8oZG9jLmZpcnN0LCAwLCBudWxsLCB0cnVlLCAtMSkgfVxcbiAgdmFyIGxpbmVOID0gbGluZUF0SGVpZ2h0KGRvYywgeSksIGxhc3QgPSBkb2MuZmlyc3QgKyBkb2Muc2l6ZSAtIDE7XFxuICBpZiAobGluZU4gPiBsYXN0KVxcbiAgICB7IHJldHVybiBQb3NXaXRoSW5mbyhkb2MuZmlyc3QgKyBkb2Muc2l6ZSAtIDEsIGdldExpbmUoZG9jLCBsYXN0KS50ZXh0Lmxlbmd0aCwgbnVsbCwgdHJ1ZSwgMSkgfVxcbiAgaWYgKHggPCAwKSB7IHggPSAwOyB9XFxuXFxuICB2YXIgbGluZU9iaiA9IGdldExpbmUoZG9jLCBsaW5lTik7XFxuICBmb3IgKDs7KSB7XFxuICAgIHZhciBmb3VuZCA9IGNvb3Jkc0NoYXJJbm5lcihjbSwgbGluZU9iaiwgbGluZU4sIHgsIHkpO1xcbiAgICB2YXIgbWVyZ2VkID0gY29sbGFwc2VkU3BhbkF0RW5kKGxpbmVPYmopO1xcbiAgICB2YXIgbWVyZ2VkUG9zID0gbWVyZ2VkICYmIG1lcmdlZC5maW5kKDAsIHRydWUpO1xcbiAgICBpZiAobWVyZ2VkICYmIChmb3VuZC5jaCA+IG1lcmdlZFBvcy5mcm9tLmNoIHx8IGZvdW5kLmNoID09IG1lcmdlZFBvcy5mcm9tLmNoICYmIGZvdW5kLnhSZWwgPiAwKSlcXG4gICAgICB7IGxpbmVOID0gbGluZU5vKGxpbmVPYmogPSBtZXJnZWRQb3MudG8ubGluZSk7IH1cXG4gICAgZWxzZVxcbiAgICAgIHsgcmV0dXJuIGZvdW5kIH1cXG4gIH1cXG59XFxuXFxuZnVuY3Rpb24gd3JhcHBlZExpbmVFeHRlbnQoY20sIGxpbmVPYmosIHByZXBhcmVkTWVhc3VyZSwgeSkge1xcbiAgdmFyIG1lYXN1cmUgPSBmdW5jdGlvbiAoY2gpIHsgcmV0dXJuIGludG9Db29yZFN5c3RlbShjbSwgbGluZU9iaiwgbWVhc3VyZUNoYXJQcmVwYXJlZChjbSwgcHJlcGFyZWRNZWFzdXJlLCBjaCksIFxcXCJsaW5lXFxcIik7IH07XFxuICB2YXIgZW5kID0gbGluZU9iai50ZXh0Lmxlbmd0aDtcXG4gIHZhciBiZWdpbiA9IGZpbmRGaXJzdChmdW5jdGlvbiAoY2gpIHsgcmV0dXJuIG1lYXN1cmUoY2ggLSAxKS5ib3R0b20gPD0geTsgfSwgZW5kLCAwKTtcXG4gIGVuZCA9IGZpbmRGaXJzdChmdW5jdGlvbiAoY2gpIHsgcmV0dXJuIG1lYXN1cmUoY2gpLnRvcCA+IHk7IH0sIGJlZ2luLCBlbmQpO1xcbiAgcmV0dXJuIHtiZWdpbjogYmVnaW4sIGVuZDogZW5kfVxcbn1cXG5cXG5mdW5jdGlvbiB3cmFwcGVkTGluZUV4dGVudENoYXIoY20sIGxpbmVPYmosIHByZXBhcmVkTWVhc3VyZSwgdGFyZ2V0KSB7XFxuICB2YXIgdGFyZ2V0VG9wID0gaW50b0Nvb3JkU3lzdGVtKGNtLCBsaW5lT2JqLCBtZWFzdXJlQ2hhclByZXBhcmVkKGNtLCBwcmVwYXJlZE1lYXN1cmUsIHRhcmdldCksIFxcXCJsaW5lXFxcIikudG9wO1xcbiAgcmV0dXJuIHdyYXBwZWRMaW5lRXh0ZW50KGNtLCBsaW5lT2JqLCBwcmVwYXJlZE1lYXN1cmUsIHRhcmdldFRvcClcXG59XFxuXFxuZnVuY3Rpb24gY29vcmRzQ2hhcklubmVyKGNtLCBsaW5lT2JqLCBsaW5lTm8kJDEsIHgsIHkpIHtcXG4gIHkgLT0gaGVpZ2h0QXRMaW5lKGxpbmVPYmopO1xcbiAgdmFyIGJlZ2luID0gMCwgZW5kID0gbGluZU9iai50ZXh0Lmxlbmd0aDtcXG4gIHZhciBwcmVwYXJlZE1lYXN1cmUgPSBwcmVwYXJlTWVhc3VyZUZvckxpbmUoY20sIGxpbmVPYmopO1xcbiAgdmFyIHBvcztcXG4gIHZhciBvcmRlciA9IGdldE9yZGVyKGxpbmVPYmosIGNtLmRvYy5kaXJlY3Rpb24pO1xcbiAgaWYgKG9yZGVyKSB7XFxuICAgIGlmIChjbS5vcHRpb25zLmxpbmVXcmFwcGluZykge1xcbiAgICAgIHZhciBhc3NpZ247XFxuICAgICAgKChhc3NpZ24gPSB3cmFwcGVkTGluZUV4dGVudChjbSwgbGluZU9iaiwgcHJlcGFyZWRNZWFzdXJlLCB5KSwgYmVnaW4gPSBhc3NpZ24uYmVnaW4sIGVuZCA9IGFzc2lnbi5lbmQsIGFzc2lnbikpO1xcbiAgICB9XFxuICAgIHBvcyA9IG5ldyBQb3MobGluZU5vJCQxLCBiZWdpbik7XFxuICAgIHZhciBiZWdpbkxlZnQgPSBjdXJzb3JDb29yZHMoY20sIHBvcywgXFxcImxpbmVcXFwiLCBsaW5lT2JqLCBwcmVwYXJlZE1lYXN1cmUpLmxlZnQ7XFxuICAgIHZhciBkaXIgPSBiZWdpbkxlZnQgPCB4ID8gMSA6IC0xO1xcbiAgICB2YXIgcHJldkRpZmYsIGRpZmYgPSBiZWdpbkxlZnQgLSB4LCBwcmV2UG9zO1xcbiAgICBkbyB7XFxuICAgICAgcHJldkRpZmYgPSBkaWZmO1xcbiAgICAgIHByZXZQb3MgPSBwb3M7XFxuICAgICAgcG9zID0gbW92ZVZpc3VhbGx5KGNtLCBsaW5lT2JqLCBwb3MsIGRpcik7XFxuICAgICAgaWYgKHBvcyA9PSBudWxsIHx8IHBvcy5jaCA8IGJlZ2luIHx8IGVuZCA8PSAocG9zLnN0aWNreSA9PSBcXFwiYmVmb3JlXFxcIiA/IHBvcy5jaCAtIDEgOiBwb3MuY2gpKSB7XFxuICAgICAgICBwb3MgPSBwcmV2UG9zO1xcbiAgICAgICAgYnJlYWtcXG4gICAgICB9XFxuICAgICAgZGlmZiA9IGN1cnNvckNvb3JkcyhjbSwgcG9zLCBcXFwibGluZVxcXCIsIGxpbmVPYmosIHByZXBhcmVkTWVhc3VyZSkubGVmdCAtIHg7XFxuICAgIH0gd2hpbGUgKChkaXIgPCAwKSAhPSAoZGlmZiA8IDApICYmIChNYXRoLmFicyhkaWZmKSA8PSBNYXRoLmFicyhwcmV2RGlmZikpKVxcbiAgICBpZiAoTWF0aC5hYnMoZGlmZikgPiBNYXRoLmFicyhwcmV2RGlmZikpIHtcXG4gICAgICBpZiAoKGRpZmYgPCAwKSA9PSAocHJldkRpZmYgPCAwKSkgeyB0aHJvdyBuZXcgRXJyb3IoXFxcIkJyb2tlIG91dCBvZiBpbmZpbml0ZSBsb29wIGluIGNvb3Jkc0NoYXJJbm5lclxcXCIpIH1cXG4gICAgICBwb3MgPSBwcmV2UG9zO1xcbiAgICB9XFxuICB9IGVsc2Uge1xcbiAgICB2YXIgY2ggPSBmaW5kRmlyc3QoZnVuY3Rpb24gKGNoKSB7XFxuICAgICAgdmFyIGJveCA9IGludG9Db29yZFN5c3RlbShjbSwgbGluZU9iaiwgbWVhc3VyZUNoYXJQcmVwYXJlZChjbSwgcHJlcGFyZWRNZWFzdXJlLCBjaCksIFxcXCJsaW5lXFxcIik7XFxuICAgICAgaWYgKGJveC50b3AgPiB5KSB7XFxuICAgICAgICAvLyBGb3IgdGhlIGN1cnNvciBzdGlja2luZXNzXFxuICAgICAgICBlbmQgPSBNYXRoLm1pbihjaCwgZW5kKTtcXG4gICAgICAgIHJldHVybiB0cnVlXFxuICAgICAgfVxcbiAgICAgIGVsc2UgaWYgKGJveC5ib3R0b20gPD0geSkgeyByZXR1cm4gZmFsc2UgfVxcbiAgICAgIGVsc2UgaWYgKGJveC5sZWZ0ID4geCkgeyByZXR1cm4gdHJ1ZSB9XFxuICAgICAgZWxzZSBpZiAoYm94LnJpZ2h0IDwgeCkgeyByZXR1cm4gZmFsc2UgfVxcbiAgICAgIGVsc2UgeyByZXR1cm4gKHggLSBib3gubGVmdCA8IGJveC5yaWdodCAtIHgpIH1cXG4gICAgfSwgYmVnaW4sIGVuZCk7XFxuICAgIGNoID0gc2tpcEV4dGVuZGluZ0NoYXJzKGxpbmVPYmoudGV4dCwgY2gsIDEpO1xcbiAgICBwb3MgPSBuZXcgUG9zKGxpbmVObyQkMSwgY2gsIGNoID09IGVuZCA/IFxcXCJiZWZvcmVcXFwiIDogXFxcImFmdGVyXFxcIik7XFxuICB9XFxuICB2YXIgY29vcmRzID0gY3Vyc29yQ29vcmRzKGNtLCBwb3MsIFxcXCJsaW5lXFxcIiwgbGluZU9iaiwgcHJlcGFyZWRNZWFzdXJlKTtcXG4gIGlmICh5IDwgY29vcmRzLnRvcCB8fCBjb29yZHMuYm90dG9tIDwgeSkgeyBwb3Mub3V0c2lkZSA9IHRydWU7IH1cXG4gIHBvcy54UmVsID0geCA8IGNvb3Jkcy5sZWZ0ID8gLTEgOiAoeCA+IGNvb3Jkcy5yaWdodCA/IDEgOiAwKTtcXG4gIHJldHVybiBwb3NcXG59XFxuXFxudmFyIG1lYXN1cmVUZXh0O1xcbi8vIENvbXB1dGUgdGhlIGRlZmF1bHQgdGV4dCBoZWlnaHQuXFxuZnVuY3Rpb24gdGV4dEhlaWdodChkaXNwbGF5KSB7XFxuICBpZiAoZGlzcGxheS5jYWNoZWRUZXh0SGVpZ2h0ICE9IG51bGwpIHsgcmV0dXJuIGRpc3BsYXkuY2FjaGVkVGV4dEhlaWdodCB9XFxuICBpZiAobWVhc3VyZVRleHQgPT0gbnVsbCkge1xcbiAgICBtZWFzdXJlVGV4dCA9IGVsdChcXFwicHJlXFxcIik7XFxuICAgIC8vIE1lYXN1cmUgYSBidW5jaCBvZiBsaW5lcywgZm9yIGJyb3dzZXJzIHRoYXQgY29tcHV0ZVxcbiAgICAvLyBmcmFjdGlvbmFsIGhlaWdodHMuXFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNDk7ICsraSkge1xcbiAgICAgIG1lYXN1cmVUZXh0LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFxcXCJ4XFxcIikpO1xcbiAgICAgIG1lYXN1cmVUZXh0LmFwcGVuZENoaWxkKGVsdChcXFwiYnJcXFwiKSk7XFxuICAgIH1cXG4gICAgbWVhc3VyZVRleHQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXFxcInhcXFwiKSk7XFxuICB9XFxuICByZW1vdmVDaGlsZHJlbkFuZEFkZChkaXNwbGF5Lm1lYXN1cmUsIG1lYXN1cmVUZXh0KTtcXG4gIHZhciBoZWlnaHQgPSBtZWFzdXJlVGV4dC5vZmZzZXRIZWlnaHQgLyA1MDtcXG4gIGlmIChoZWlnaHQgPiAzKSB7IGRpc3BsYXkuY2FjaGVkVGV4dEhlaWdodCA9IGhlaWdodDsgfVxcbiAgcmVtb3ZlQ2hpbGRyZW4oZGlzcGxheS5tZWFzdXJlKTtcXG4gIHJldHVybiBoZWlnaHQgfHwgMVxcbn1cXG5cXG4vLyBDb21wdXRlIHRoZSBkZWZhdWx0IGNoYXJhY3RlciB3aWR0aC5cXG5mdW5jdGlvbiBjaGFyV2lkdGgoZGlzcGxheSkge1xcbiAgaWYgKGRpc3BsYXkuY2FjaGVkQ2hhcldpZHRoICE9IG51bGwpIHsgcmV0dXJuIGRpc3BsYXkuY2FjaGVkQ2hhcldpZHRoIH1cXG4gIHZhciBhbmNob3IgPSBlbHQoXFxcInNwYW5cXFwiLCBcXFwieHh4eHh4eHh4eFxcXCIpO1xcbiAgdmFyIHByZSA9IGVsdChcXFwicHJlXFxcIiwgW2FuY2hvcl0pO1xcbiAgcmVtb3ZlQ2hpbGRyZW5BbmRBZGQoZGlzcGxheS5tZWFzdXJlLCBwcmUpO1xcbiAgdmFyIHJlY3QgPSBhbmNob3IuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIHdpZHRoID0gKHJlY3QucmlnaHQgLSByZWN0LmxlZnQpIC8gMTA7XFxuICBpZiAod2lkdGggPiAyKSB7IGRpc3BsYXkuY2FjaGVkQ2hhcldpZHRoID0gd2lkdGg7IH1cXG4gIHJldHVybiB3aWR0aCB8fCAxMFxcbn1cXG5cXG4vLyBEbyBhIGJ1bGstcmVhZCBvZiB0aGUgRE9NIHBvc2l0aW9ucyBhbmQgc2l6ZXMgbmVlZGVkIHRvIGRyYXcgdGhlXFxuLy8gdmlldywgc28gdGhhdCB3ZSBkb24ndCBpbnRlcmxlYXZlIHJlYWRpbmcgYW5kIHdyaXRpbmcgdG8gdGhlIERPTS5cXG5mdW5jdGlvbiBnZXREaW1lbnNpb25zKGNtKSB7XFxuICB2YXIgZCA9IGNtLmRpc3BsYXksIGxlZnQgPSB7fSwgd2lkdGggPSB7fTtcXG4gIHZhciBndXR0ZXJMZWZ0ID0gZC5ndXR0ZXJzLmNsaWVudExlZnQ7XFxuICBmb3IgKHZhciBuID0gZC5ndXR0ZXJzLmZpcnN0Q2hpbGQsIGkgPSAwOyBuOyBuID0gbi5uZXh0U2libGluZywgKytpKSB7XFxuICAgIGxlZnRbY20ub3B0aW9ucy5ndXR0ZXJzW2ldXSA9IG4ub2Zmc2V0TGVmdCArIG4uY2xpZW50TGVmdCArIGd1dHRlckxlZnQ7XFxuICAgIHdpZHRoW2NtLm9wdGlvbnMuZ3V0dGVyc1tpXV0gPSBuLmNsaWVudFdpZHRoO1xcbiAgfVxcbiAgcmV0dXJuIHtmaXhlZFBvczogY29tcGVuc2F0ZUZvckhTY3JvbGwoZCksXFxuICAgICAgICAgIGd1dHRlclRvdGFsV2lkdGg6IGQuZ3V0dGVycy5vZmZzZXRXaWR0aCxcXG4gICAgICAgICAgZ3V0dGVyTGVmdDogbGVmdCxcXG4gICAgICAgICAgZ3V0dGVyV2lkdGg6IHdpZHRoLFxcbiAgICAgICAgICB3cmFwcGVyV2lkdGg6IGQud3JhcHBlci5jbGllbnRXaWR0aH1cXG59XFxuXFxuLy8gQ29tcHV0ZXMgZGlzcGxheS5zY3JvbGxlci5zY3JvbGxMZWZ0ICsgZGlzcGxheS5ndXR0ZXJzLm9mZnNldFdpZHRoLFxcbi8vIGJ1dCB1c2luZyBnZXRCb3VuZGluZ0NsaWVudFJlY3QgdG8gZ2V0IGEgc3ViLXBpeGVsLWFjY3VyYXRlXFxuLy8gcmVzdWx0LlxcbmZ1bmN0aW9uIGNvbXBlbnNhdGVGb3JIU2Nyb2xsKGRpc3BsYXkpIHtcXG4gIHJldHVybiBkaXNwbGF5LnNjcm9sbGVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQgLSBkaXNwbGF5LnNpemVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnRcXG59XFxuXFxuLy8gUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgZXN0aW1hdGVzIHRoZSBoZWlnaHQgb2YgYSBsaW5lLCB0byB1c2UgYXNcXG4vLyBmaXJzdCBhcHByb3hpbWF0aW9uIHVudGlsIHRoZSBsaW5lIGJlY29tZXMgdmlzaWJsZSAoYW5kIGlzIHRodXNcXG4vLyBwcm9wZXJseSBtZWFzdXJhYmxlKS5cXG5mdW5jdGlvbiBlc3RpbWF0ZUhlaWdodChjbSkge1xcbiAgdmFyIHRoID0gdGV4dEhlaWdodChjbS5kaXNwbGF5KSwgd3JhcHBpbmcgPSBjbS5vcHRpb25zLmxpbmVXcmFwcGluZztcXG4gIHZhciBwZXJMaW5lID0gd3JhcHBpbmcgJiYgTWF0aC5tYXgoNSwgY20uZGlzcGxheS5zY3JvbGxlci5jbGllbnRXaWR0aCAvIGNoYXJXaWR0aChjbS5kaXNwbGF5KSAtIDMpO1xcbiAgcmV0dXJuIGZ1bmN0aW9uIChsaW5lKSB7XFxuICAgIGlmIChsaW5lSXNIaWRkZW4oY20uZG9jLCBsaW5lKSkgeyByZXR1cm4gMCB9XFxuXFxuICAgIHZhciB3aWRnZXRzSGVpZ2h0ID0gMDtcXG4gICAgaWYgKGxpbmUud2lkZ2V0cykgeyBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmUud2lkZ2V0cy5sZW5ndGg7IGkrKykge1xcbiAgICAgIGlmIChsaW5lLndpZGdldHNbaV0uaGVpZ2h0KSB7IHdpZGdldHNIZWlnaHQgKz0gbGluZS53aWRnZXRzW2ldLmhlaWdodDsgfVxcbiAgICB9IH1cXG5cXG4gICAgaWYgKHdyYXBwaW5nKVxcbiAgICAgIHsgcmV0dXJuIHdpZGdldHNIZWlnaHQgKyAoTWF0aC5jZWlsKGxpbmUudGV4dC5sZW5ndGggLyBwZXJMaW5lKSB8fCAxKSAqIHRoIH1cXG4gICAgZWxzZVxcbiAgICAgIHsgcmV0dXJuIHdpZGdldHNIZWlnaHQgKyB0aCB9XFxuICB9XFxufVxcblxcbmZ1bmN0aW9uIGVzdGltYXRlTGluZUhlaWdodHMoY20pIHtcXG4gIHZhciBkb2MgPSBjbS5kb2MsIGVzdCA9IGVzdGltYXRlSGVpZ2h0KGNtKTtcXG4gIGRvYy5pdGVyKGZ1bmN0aW9uIChsaW5lKSB7XFxuICAgIHZhciBlc3RIZWlnaHQgPSBlc3QobGluZSk7XFxuICAgIGlmIChlc3RIZWlnaHQgIT0gbGluZS5oZWlnaHQpIHsgdXBkYXRlTGluZUhlaWdodChsaW5lLCBlc3RIZWlnaHQpOyB9XFxuICB9KTtcXG59XFxuXFxuLy8gR2l2ZW4gYSBtb3VzZSBldmVudCwgZmluZCB0aGUgY29ycmVzcG9uZGluZyBwb3NpdGlvbi4gSWYgbGliZXJhbFxcbi8vIGlzIGZhbHNlLCBpdCBjaGVja3Mgd2hldGhlciBhIGd1dHRlciBvciBzY3JvbGxiYXIgd2FzIGNsaWNrZWQsXFxuLy8gYW5kIHJldHVybnMgbnVsbCBpZiBpdCB3YXMuIGZvclJlY3QgaXMgdXNlZCBieSByZWN0YW5ndWxhclxcbi8vIHNlbGVjdGlvbnMsIGFuZCB0cmllcyB0byBlc3RpbWF0ZSBhIGNoYXJhY3RlciBwb3NpdGlvbiBldmVuIGZvclxcbi8vIGNvb3JkaW5hdGVzIGJleW9uZCB0aGUgcmlnaHQgb2YgdGhlIHRleHQuXFxuZnVuY3Rpb24gcG9zRnJvbU1vdXNlKGNtLCBlLCBsaWJlcmFsLCBmb3JSZWN0KSB7XFxuICB2YXIgZGlzcGxheSA9IGNtLmRpc3BsYXk7XFxuICBpZiAoIWxpYmVyYWwgJiYgZV90YXJnZXQoZSkuZ2V0QXR0cmlidXRlKFxcXCJjbS1ub3QtY29udGVudFxcXCIpID09IFxcXCJ0cnVlXFxcIikgeyByZXR1cm4gbnVsbCB9XFxuXFxuICB2YXIgeCwgeSwgc3BhY2UgPSBkaXNwbGF5LmxpbmVTcGFjZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcXG4gIC8vIEZhaWxzIHVucHJlZGljdGFibHkgb24gSUVbNjddIHdoZW4gbW91c2UgaXMgZHJhZ2dlZCBhcm91bmQgcXVpY2tseS5cXG4gIHRyeSB7IHggPSBlLmNsaWVudFggLSBzcGFjZS5sZWZ0OyB5ID0gZS5jbGllbnRZIC0gc3BhY2UudG9wOyB9XFxuICBjYXRjaCAoZSkgeyByZXR1cm4gbnVsbCB9XFxuICB2YXIgY29vcmRzID0gY29vcmRzQ2hhcihjbSwgeCwgeSksIGxpbmU7XFxuICBpZiAoZm9yUmVjdCAmJiBjb29yZHMueFJlbCA9PSAxICYmIChsaW5lID0gZ2V0TGluZShjbS5kb2MsIGNvb3Jkcy5saW5lKS50ZXh0KS5sZW5ndGggPT0gY29vcmRzLmNoKSB7XFxuICAgIHZhciBjb2xEaWZmID0gY291bnRDb2x1bW4obGluZSwgbGluZS5sZW5ndGgsIGNtLm9wdGlvbnMudGFiU2l6ZSkgLSBsaW5lLmxlbmd0aDtcXG4gICAgY29vcmRzID0gUG9zKGNvb3Jkcy5saW5lLCBNYXRoLm1heCgwLCBNYXRoLnJvdW5kKCh4IC0gcGFkZGluZ0goY20uZGlzcGxheSkubGVmdCkgLyBjaGFyV2lkdGgoY20uZGlzcGxheSkpIC0gY29sRGlmZikpO1xcbiAgfVxcbiAgcmV0dXJuIGNvb3Jkc1xcbn1cXG5cXG4vLyBGaW5kIHRoZSB2aWV3IGVsZW1lbnQgY29ycmVzcG9uZGluZyB0byBhIGdpdmVuIGxpbmUuIFJldHVybiBudWxsXFxuLy8gd2hlbiB0aGUgbGluZSBpc24ndCB2aXNpYmxlLlxcbmZ1bmN0aW9uIGZpbmRWaWV3SW5kZXgoY20sIG4pIHtcXG4gIGlmIChuID49IGNtLmRpc3BsYXkudmlld1RvKSB7IHJldHVybiBudWxsIH1cXG4gIG4gLT0gY20uZGlzcGxheS52aWV3RnJvbTtcXG4gIGlmIChuIDwgMCkgeyByZXR1cm4gbnVsbCB9XFxuICB2YXIgdmlldyA9IGNtLmRpc3BsYXkudmlldztcXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdmlldy5sZW5ndGg7IGkrKykge1xcbiAgICBuIC09IHZpZXdbaV0uc2l6ZTtcXG4gICAgaWYgKG4gPCAwKSB7IHJldHVybiBpIH1cXG4gIH1cXG59XFxuXFxuZnVuY3Rpb24gdXBkYXRlU2VsZWN0aW9uKGNtKSB7XFxuICBjbS5kaXNwbGF5LmlucHV0LnNob3dTZWxlY3Rpb24oY20uZGlzcGxheS5pbnB1dC5wcmVwYXJlU2VsZWN0aW9uKCkpO1xcbn1cXG5cXG5mdW5jdGlvbiBwcmVwYXJlU2VsZWN0aW9uKGNtLCBwcmltYXJ5KSB7XFxuICB2YXIgZG9jID0gY20uZG9jLCByZXN1bHQgPSB7fTtcXG4gIHZhciBjdXJGcmFnbWVudCA9IHJlc3VsdC5jdXJzb3JzID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xcbiAgdmFyIHNlbEZyYWdtZW50ID0gcmVzdWx0LnNlbGVjdGlvbiA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcXG5cXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZG9jLnNlbC5yYW5nZXMubGVuZ3RoOyBpKyspIHtcXG4gICAgaWYgKHByaW1hcnkgPT09IGZhbHNlICYmIGkgPT0gZG9jLnNlbC5wcmltSW5kZXgpIHsgY29udGludWUgfVxcbiAgICB2YXIgcmFuZ2UkJDEgPSBkb2Muc2VsLnJhbmdlc1tpXTtcXG4gICAgaWYgKHJhbmdlJCQxLmZyb20oKS5saW5lID49IGNtLmRpc3BsYXkudmlld1RvIHx8IHJhbmdlJCQxLnRvKCkubGluZSA8IGNtLmRpc3BsYXkudmlld0Zyb20pIHsgY29udGludWUgfVxcbiAgICB2YXIgY29sbGFwc2VkID0gcmFuZ2UkJDEuZW1wdHkoKTtcXG4gICAgaWYgKGNvbGxhcHNlZCB8fCBjbS5vcHRpb25zLnNob3dDdXJzb3JXaGVuU2VsZWN0aW5nKVxcbiAgICAgIHsgZHJhd1NlbGVjdGlvbkN1cnNvcihjbSwgcmFuZ2UkJDEuaGVhZCwgY3VyRnJhZ21lbnQpOyB9XFxuICAgIGlmICghY29sbGFwc2VkKVxcbiAgICAgIHsgZHJhd1NlbGVjdGlvblJhbmdlKGNtLCByYW5nZSQkMSwgc2VsRnJhZ21lbnQpOyB9XFxuICB9XFxuICByZXR1cm4gcmVzdWx0XFxufVxcblxcbi8vIERyYXdzIGEgY3Vyc29yIGZvciB0aGUgZ2l2ZW4gcmFuZ2VcXG5mdW5jdGlvbiBkcmF3U2VsZWN0aW9uQ3Vyc29yKGNtLCBoZWFkLCBvdXRwdXQpIHtcXG4gIHZhciBwb3MgPSBjdXJzb3JDb29yZHMoY20sIGhlYWQsIFxcXCJkaXZcXFwiLCBudWxsLCBudWxsLCAhY20ub3B0aW9ucy5zaW5nbGVDdXJzb3JIZWlnaHRQZXJMaW5lKTtcXG5cXG4gIHZhciBjdXJzb3IgPSBvdXRwdXQuYXBwZW5kQ2hpbGQoZWx0KFxcXCJkaXZcXFwiLCBcXFwiXFxcXHUwMGEwXFxcIiwgXFxcIkNvZGVNaXJyb3ItY3Vyc29yXFxcIikpO1xcbiAgY3Vyc29yLnN0eWxlLmxlZnQgPSBwb3MubGVmdCArIFxcXCJweFxcXCI7XFxuICBjdXJzb3Iuc3R5bGUudG9wID0gcG9zLnRvcCArIFxcXCJweFxcXCI7XFxuICBjdXJzb3Iuc3R5bGUuaGVpZ2h0ID0gTWF0aC5tYXgoMCwgcG9zLmJvdHRvbSAtIHBvcy50b3ApICogY20ub3B0aW9ucy5jdXJzb3JIZWlnaHQgKyBcXFwicHhcXFwiO1xcblxcbiAgaWYgKHBvcy5vdGhlcikge1xcbiAgICAvLyBTZWNvbmRhcnkgY3Vyc29yLCBzaG93biB3aGVuIG9uIGEgJ2p1bXAnIGluIGJpLWRpcmVjdGlvbmFsIHRleHRcXG4gICAgdmFyIG90aGVyQ3Vyc29yID0gb3V0cHV0LmFwcGVuZENoaWxkKGVsdChcXFwiZGl2XFxcIiwgXFxcIlxcXFx1MDBhMFxcXCIsIFxcXCJDb2RlTWlycm9yLWN1cnNvciBDb2RlTWlycm9yLXNlY29uZGFyeWN1cnNvclxcXCIpKTtcXG4gICAgb3RoZXJDdXJzb3Iuc3R5bGUuZGlzcGxheSA9IFxcXCJcXFwiO1xcbiAgICBvdGhlckN1cnNvci5zdHlsZS5sZWZ0ID0gcG9zLm90aGVyLmxlZnQgKyBcXFwicHhcXFwiO1xcbiAgICBvdGhlckN1cnNvci5zdHlsZS50b3AgPSBwb3Mub3RoZXIudG9wICsgXFxcInB4XFxcIjtcXG4gICAgb3RoZXJDdXJzb3Iuc3R5bGUuaGVpZ2h0ID0gKHBvcy5vdGhlci5ib3R0b20gLSBwb3Mub3RoZXIudG9wKSAqIC44NSArIFxcXCJweFxcXCI7XFxuICB9XFxufVxcblxcbi8vIERyYXdzIHRoZSBnaXZlbiByYW5nZSBhcyBhIGhpZ2hsaWdodGVkIHNlbGVjdGlvblxcbmZ1bmN0aW9uIGRyYXdTZWxlY3Rpb25SYW5nZShjbSwgcmFuZ2UkJDEsIG91dHB1dCkge1xcbiAgdmFyIGRpc3BsYXkgPSBjbS5kaXNwbGF5LCBkb2MgPSBjbS5kb2M7XFxuICB2YXIgZnJhZ21lbnQgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XFxuICB2YXIgcGFkZGluZyA9IHBhZGRpbmdIKGNtLmRpc3BsYXkpLCBsZWZ0U2lkZSA9IHBhZGRpbmcubGVmdDtcXG4gIHZhciByaWdodFNpZGUgPSBNYXRoLm1heChkaXNwbGF5LnNpemVyV2lkdGgsIGRpc3BsYXlXaWR0aChjbSkgLSBkaXNwbGF5LnNpemVyLm9mZnNldExlZnQpIC0gcGFkZGluZy5yaWdodDtcXG5cXG4gIGZ1bmN0aW9uIGFkZChsZWZ0LCB0b3AsIHdpZHRoLCBib3R0b20pIHtcXG4gICAgaWYgKHRvcCA8IDApIHsgdG9wID0gMDsgfVxcbiAgICB0b3AgPSBNYXRoLnJvdW5kKHRvcCk7XFxuICAgIGJvdHRvbSA9IE1hdGgucm91bmQoYm90dG9tKTtcXG4gICAgZnJhZ21lbnQuYXBwZW5kQ2hpbGQoZWx0KFxcXCJkaXZcXFwiLCBudWxsLCBcXFwiQ29kZU1pcnJvci1zZWxlY3RlZFxcXCIsIChcXFwicG9zaXRpb246IGFic29sdXRlOyBsZWZ0OiBcXFwiICsgbGVmdCArIFxcXCJweDtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9wOiBcXFwiICsgdG9wICsgXFxcInB4OyB3aWR0aDogXFxcIiArICh3aWR0aCA9PSBudWxsID8gcmlnaHRTaWRlIC0gbGVmdCA6IHdpZHRoKSArIFxcXCJweDtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBcXFwiICsgKGJvdHRvbSAtIHRvcCkgKyBcXFwicHhcXFwiKSkpO1xcbiAgfVxcblxcbiAgZnVuY3Rpb24gZHJhd0ZvckxpbmUobGluZSwgZnJvbUFyZywgdG9BcmcpIHtcXG4gICAgdmFyIGxpbmVPYmogPSBnZXRMaW5lKGRvYywgbGluZSk7XFxuICAgIHZhciBsaW5lTGVuID0gbGluZU9iai50ZXh0Lmxlbmd0aDtcXG4gICAgdmFyIHN0YXJ0LCBlbmQ7XFxuICAgIGZ1bmN0aW9uIGNvb3JkcyhjaCwgYmlhcykge1xcbiAgICAgIHJldHVybiBjaGFyQ29vcmRzKGNtLCBQb3MobGluZSwgY2gpLCBcXFwiZGl2XFxcIiwgbGluZU9iaiwgYmlhcylcXG4gICAgfVxcblxcbiAgICBpdGVyYXRlQmlkaVNlY3Rpb25zKGdldE9yZGVyKGxpbmVPYmosIGRvYy5kaXJlY3Rpb24pLCBmcm9tQXJnIHx8IDAsIHRvQXJnID09IG51bGwgPyBsaW5lTGVuIDogdG9BcmcsIGZ1bmN0aW9uIChmcm9tLCB0bywgZGlyKSB7XFxuICAgICAgdmFyIGxlZnRQb3MgPSBjb29yZHMoZnJvbSwgXFxcImxlZnRcXFwiKSwgcmlnaHRQb3MsIGxlZnQsIHJpZ2h0O1xcbiAgICAgIGlmIChmcm9tID09IHRvKSB7XFxuICAgICAgICByaWdodFBvcyA9IGxlZnRQb3M7XFxuICAgICAgICBsZWZ0ID0gcmlnaHQgPSBsZWZ0UG9zLmxlZnQ7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIHJpZ2h0UG9zID0gY29vcmRzKHRvIC0gMSwgXFxcInJpZ2h0XFxcIik7XFxuICAgICAgICBpZiAoZGlyID09IFxcXCJydGxcXFwiKSB7IHZhciB0bXAgPSBsZWZ0UG9zOyBsZWZ0UG9zID0gcmlnaHRQb3M7IHJpZ2h0UG9zID0gdG1wOyB9XFxuICAgICAgICBsZWZ0ID0gbGVmdFBvcy5sZWZ0O1xcbiAgICAgICAgcmlnaHQgPSByaWdodFBvcy5yaWdodDtcXG4gICAgICB9XFxuICAgICAgaWYgKGZyb21BcmcgPT0gbnVsbCAmJiBmcm9tID09IDApIHsgbGVmdCA9IGxlZnRTaWRlOyB9XFxuICAgICAgaWYgKHJpZ2h0UG9zLnRvcCAtIGxlZnRQb3MudG9wID4gMykgeyAvLyBEaWZmZXJlbnQgbGluZXMsIGRyYXcgdG9wIHBhcnRcXG4gICAgICAgIGFkZChsZWZ0LCBsZWZ0UG9zLnRvcCwgbnVsbCwgbGVmdFBvcy5ib3R0b20pO1xcbiAgICAgICAgbGVmdCA9IGxlZnRTaWRlO1xcbiAgICAgICAgaWYgKGxlZnRQb3MuYm90dG9tIDwgcmlnaHRQb3MudG9wKSB7IGFkZChsZWZ0LCBsZWZ0UG9zLmJvdHRvbSwgbnVsbCwgcmlnaHRQb3MudG9wKTsgfVxcbiAgICAgIH1cXG4gICAgICBpZiAodG9BcmcgPT0gbnVsbCAmJiB0byA9PSBsaW5lTGVuKSB7IHJpZ2h0ID0gcmlnaHRTaWRlOyB9XFxuICAgICAgaWYgKCFzdGFydCB8fCBsZWZ0UG9zLnRvcCA8IHN0YXJ0LnRvcCB8fCBsZWZ0UG9zLnRvcCA9PSBzdGFydC50b3AgJiYgbGVmdFBvcy5sZWZ0IDwgc3RhcnQubGVmdClcXG4gICAgICAgIHsgc3RhcnQgPSBsZWZ0UG9zOyB9XFxuICAgICAgaWYgKCFlbmQgfHwgcmlnaHRQb3MuYm90dG9tID4gZW5kLmJvdHRvbSB8fCByaWdodFBvcy5ib3R0b20gPT0gZW5kLmJvdHRvbSAmJiByaWdodFBvcy5yaWdodCA+IGVuZC5yaWdodClcXG4gICAgICAgIHsgZW5kID0gcmlnaHRQb3M7IH1cXG4gICAgICBpZiAobGVmdCA8IGxlZnRTaWRlICsgMSkgeyBsZWZ0ID0gbGVmdFNpZGU7IH1cXG4gICAgICBhZGQobGVmdCwgcmlnaHRQb3MudG9wLCByaWdodCAtIGxlZnQsIHJpZ2h0UG9zLmJvdHRvbSk7XFxuICAgIH0pO1xcbiAgICByZXR1cm4ge3N0YXJ0OiBzdGFydCwgZW5kOiBlbmR9XFxuICB9XFxuXFxuICB2YXIgc0Zyb20gPSByYW5nZSQkMS5mcm9tKCksIHNUbyA9IHJhbmdlJCQxLnRvKCk7XFxuICBpZiAoc0Zyb20ubGluZSA9PSBzVG8ubGluZSkge1xcbiAgICBkcmF3Rm9yTGluZShzRnJvbS5saW5lLCBzRnJvbS5jaCwgc1RvLmNoKTtcXG4gIH0gZWxzZSB7XFxuICAgIHZhciBmcm9tTGluZSA9IGdldExpbmUoZG9jLCBzRnJvbS5saW5lKSwgdG9MaW5lID0gZ2V0TGluZShkb2MsIHNUby5saW5lKTtcXG4gICAgdmFyIHNpbmdsZVZMaW5lID0gdmlzdWFsTGluZShmcm9tTGluZSkgPT0gdmlzdWFsTGluZSh0b0xpbmUpO1xcbiAgICB2YXIgbGVmdEVuZCA9IGRyYXdGb3JMaW5lKHNGcm9tLmxpbmUsIHNGcm9tLmNoLCBzaW5nbGVWTGluZSA/IGZyb21MaW5lLnRleHQubGVuZ3RoICsgMSA6IG51bGwpLmVuZDtcXG4gICAgdmFyIHJpZ2h0U3RhcnQgPSBkcmF3Rm9yTGluZShzVG8ubGluZSwgc2luZ2xlVkxpbmUgPyAwIDogbnVsbCwgc1RvLmNoKS5zdGFydDtcXG4gICAgaWYgKHNpbmdsZVZMaW5lKSB7XFxuICAgICAgaWYgKGxlZnRFbmQudG9wIDwgcmlnaHRTdGFydC50b3AgLSAyKSB7XFxuICAgICAgICBhZGQobGVmdEVuZC5yaWdodCwgbGVmdEVuZC50b3AsIG51bGwsIGxlZnRFbmQuYm90dG9tKTtcXG4gICAgICAgIGFkZChsZWZ0U2lkZSwgcmlnaHRTdGFydC50b3AsIHJpZ2h0U3RhcnQubGVmdCwgcmlnaHRTdGFydC5ib3R0b20pO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBhZGQobGVmdEVuZC5yaWdodCwgbGVmdEVuZC50b3AsIHJpZ2h0U3RhcnQubGVmdCAtIGxlZnRFbmQucmlnaHQsIGxlZnRFbmQuYm90dG9tKTtcXG4gICAgICB9XFxuICAgIH1cXG4gICAgaWYgKGxlZnRFbmQuYm90dG9tIDwgcmlnaHRTdGFydC50b3ApXFxuICAgICAgeyBhZGQobGVmdFNpZGUsIGxlZnRFbmQuYm90dG9tLCBudWxsLCByaWdodFN0YXJ0LnRvcCk7IH1cXG4gIH1cXG5cXG4gIG91dHB1dC5hcHBlbmRDaGlsZChmcmFnbWVudCk7XFxufVxcblxcbi8vIEN1cnNvci1ibGlua2luZ1xcbmZ1bmN0aW9uIHJlc3RhcnRCbGluayhjbSkge1xcbiAgaWYgKCFjbS5zdGF0ZS5mb2N1c2VkKSB7IHJldHVybiB9XFxuICB2YXIgZGlzcGxheSA9IGNtLmRpc3BsYXk7XFxuICBjbGVhckludGVydmFsKGRpc3BsYXkuYmxpbmtlcik7XFxuICB2YXIgb24gPSB0cnVlO1xcbiAgZGlzcGxheS5jdXJzb3JEaXYuc3R5bGUudmlzaWJpbGl0eSA9IFxcXCJcXFwiO1xcbiAgaWYgKGNtLm9wdGlvbnMuY3Vyc29yQmxpbmtSYXRlID4gMClcXG4gICAgeyBkaXNwbGF5LmJsaW5rZXIgPSBzZXRJbnRlcnZhbChmdW5jdGlvbiAoKSB7IHJldHVybiBkaXNwbGF5LmN1cnNvckRpdi5zdHlsZS52aXNpYmlsaXR5ID0gKG9uID0gIW9uKSA/IFxcXCJcXFwiIDogXFxcImhpZGRlblxcXCI7IH0sXFxuICAgICAgY20ub3B0aW9ucy5jdXJzb3JCbGlua1JhdGUpOyB9XFxuICBlbHNlIGlmIChjbS5vcHRpb25zLmN1cnNvckJsaW5rUmF0ZSA8IDApXFxuICAgIHsgZGlzcGxheS5jdXJzb3JEaXYuc3R5bGUudmlzaWJpbGl0eSA9IFxcXCJoaWRkZW5cXFwiOyB9XFxufVxcblxcbmZ1bmN0aW9uIGVuc3VyZUZvY3VzKGNtKSB7XFxuICBpZiAoIWNtLnN0YXRlLmZvY3VzZWQpIHsgY20uZGlzcGxheS5pbnB1dC5mb2N1cygpOyBvbkZvY3VzKGNtKTsgfVxcbn1cXG5cXG5mdW5jdGlvbiBkZWxheUJsdXJFdmVudChjbSkge1xcbiAgY20uc3RhdGUuZGVsYXlpbmdCbHVyRXZlbnQgPSB0cnVlO1xcbiAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IGlmIChjbS5zdGF0ZS5kZWxheWluZ0JsdXJFdmVudCkge1xcbiAgICBjbS5zdGF0ZS5kZWxheWluZ0JsdXJFdmVudCA9IGZhbHNlO1xcbiAgICBvbkJsdXIoY20pO1xcbiAgfSB9LCAxMDApO1xcbn1cXG5cXG5mdW5jdGlvbiBvbkZvY3VzKGNtLCBlKSB7XFxuICBpZiAoY20uc3RhdGUuZGVsYXlpbmdCbHVyRXZlbnQpIHsgY20uc3RhdGUuZGVsYXlpbmdCbHVyRXZlbnQgPSBmYWxzZTsgfVxcblxcbiAgaWYgKGNtLm9wdGlvbnMucmVhZE9ubHkgPT0gXFxcIm5vY3Vyc29yXFxcIikgeyByZXR1cm4gfVxcbiAgaWYgKCFjbS5zdGF0ZS5mb2N1c2VkKSB7XFxuICAgIHNpZ25hbChjbSwgXFxcImZvY3VzXFxcIiwgY20sIGUpO1xcbiAgICBjbS5zdGF0ZS5mb2N1c2VkID0gdHJ1ZTtcXG4gICAgYWRkQ2xhc3MoY20uZGlzcGxheS53cmFwcGVyLCBcXFwiQ29kZU1pcnJvci1mb2N1c2VkXFxcIik7XFxuICAgIC8vIFRoaXMgdGVzdCBwcmV2ZW50cyB0aGlzIGZyb20gZmlyaW5nIHdoZW4gYSBjb250ZXh0XFxuICAgIC8vIG1lbnUgaXMgY2xvc2VkIChzaW5jZSB0aGUgaW5wdXQgcmVzZXQgd291bGQga2lsbCB0aGVcXG4gICAgLy8gc2VsZWN0LWFsbCBkZXRlY3Rpb24gaGFjaylcXG4gICAgaWYgKCFjbS5jdXJPcCAmJiBjbS5kaXNwbGF5LnNlbEZvckNvbnRleHRNZW51ICE9IGNtLmRvYy5zZWwpIHtcXG4gICAgICBjbS5kaXNwbGF5LmlucHV0LnJlc2V0KCk7XFxuICAgICAgaWYgKHdlYmtpdCkgeyBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNtLmRpc3BsYXkuaW5wdXQucmVzZXQodHJ1ZSk7IH0sIDIwKTsgfSAvLyBJc3N1ZSAjMTczMFxcbiAgICB9XFxuICAgIGNtLmRpc3BsYXkuaW5wdXQucmVjZWl2ZWRGb2N1cygpO1xcbiAgfVxcbiAgcmVzdGFydEJsaW5rKGNtKTtcXG59XFxuZnVuY3Rpb24gb25CbHVyKGNtLCBlKSB7XFxuICBpZiAoY20uc3RhdGUuZGVsYXlpbmdCbHVyRXZlbnQpIHsgcmV0dXJuIH1cXG5cXG4gIGlmIChjbS5zdGF0ZS5mb2N1c2VkKSB7XFxuICAgIHNpZ25hbChjbSwgXFxcImJsdXJcXFwiLCBjbSwgZSk7XFxuICAgIGNtLnN0YXRlLmZvY3VzZWQgPSBmYWxzZTtcXG4gICAgcm1DbGFzcyhjbS5kaXNwbGF5LndyYXBwZXIsIFxcXCJDb2RlTWlycm9yLWZvY3VzZWRcXFwiKTtcXG4gIH1cXG4gIGNsZWFySW50ZXJ2YWwoY20uZGlzcGxheS5ibGlua2VyKTtcXG4gIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyBpZiAoIWNtLnN0YXRlLmZvY3VzZWQpIHsgY20uZGlzcGxheS5zaGlmdCA9IGZhbHNlOyB9IH0sIDE1MCk7XFxufVxcblxcbi8vIFJlLWFsaWduIGxpbmUgbnVtYmVycyBhbmQgZ3V0dGVyIG1hcmtzIHRvIGNvbXBlbnNhdGUgZm9yXFxuLy8gaG9yaXpvbnRhbCBzY3JvbGxpbmcuXFxuZnVuY3Rpb24gYWxpZ25Ib3Jpem9udGFsbHkoY20pIHtcXG4gIHZhciBkaXNwbGF5ID0gY20uZGlzcGxheSwgdmlldyA9IGRpc3BsYXkudmlldztcXG4gIGlmICghZGlzcGxheS5hbGlnbldpZGdldHMgJiYgKCFkaXNwbGF5Lmd1dHRlcnMuZmlyc3RDaGlsZCB8fCAhY20ub3B0aW9ucy5maXhlZEd1dHRlcikpIHsgcmV0dXJuIH1cXG4gIHZhciBjb21wID0gY29tcGVuc2F0ZUZvckhTY3JvbGwoZGlzcGxheSkgLSBkaXNwbGF5LnNjcm9sbGVyLnNjcm9sbExlZnQgKyBjbS5kb2Muc2Nyb2xsTGVmdDtcXG4gIHZhciBndXR0ZXJXID0gZGlzcGxheS5ndXR0ZXJzLm9mZnNldFdpZHRoLCBsZWZ0ID0gY29tcCArIFxcXCJweFxcXCI7XFxuICBmb3IgKHZhciBpID0gMDsgaSA8IHZpZXcubGVuZ3RoOyBpKyspIHsgaWYgKCF2aWV3W2ldLmhpZGRlbikge1xcbiAgICBpZiAoY20ub3B0aW9ucy5maXhlZEd1dHRlcikge1xcbiAgICAgIGlmICh2aWV3W2ldLmd1dHRlcilcXG4gICAgICAgIHsgdmlld1tpXS5ndXR0ZXIuc3R5bGUubGVmdCA9IGxlZnQ7IH1cXG4gICAgICBpZiAodmlld1tpXS5ndXR0ZXJCYWNrZ3JvdW5kKVxcbiAgICAgICAgeyB2aWV3W2ldLmd1dHRlckJhY2tncm91bmQuc3R5bGUubGVmdCA9IGxlZnQ7IH1cXG4gICAgfVxcbiAgICB2YXIgYWxpZ24gPSB2aWV3W2ldLmFsaWduYWJsZTtcXG4gICAgaWYgKGFsaWduKSB7IGZvciAodmFyIGogPSAwOyBqIDwgYWxpZ24ubGVuZ3RoOyBqKyspXFxuICAgICAgeyBhbGlnbltqXS5zdHlsZS5sZWZ0ID0gbGVmdDsgfSB9XFxuICB9IH1cXG4gIGlmIChjbS5vcHRpb25zLmZpeGVkR3V0dGVyKVxcbiAgICB7IGRpc3BsYXkuZ3V0dGVycy5zdHlsZS5sZWZ0ID0gKGNvbXAgKyBndXR0ZXJXKSArIFxcXCJweFxcXCI7IH1cXG59XFxuXFxuLy8gVXNlZCB0byBlbnN1cmUgdGhhdCB0aGUgbGluZSBudW1iZXIgZ3V0dGVyIGlzIHN0aWxsIHRoZSByaWdodFxcbi8vIHNpemUgZm9yIHRoZSBjdXJyZW50IGRvY3VtZW50IHNpemUuIFJldHVybnMgdHJ1ZSB3aGVuIGFuIHVwZGF0ZVxcbi8vIGlzIG5lZWRlZC5cXG5mdW5jdGlvbiBtYXliZVVwZGF0ZUxpbmVOdW1iZXJXaWR0aChjbSkge1xcbiAgaWYgKCFjbS5vcHRpb25zLmxpbmVOdW1iZXJzKSB7IHJldHVybiBmYWxzZSB9XFxuICB2YXIgZG9jID0gY20uZG9jLCBsYXN0ID0gbGluZU51bWJlckZvcihjbS5vcHRpb25zLCBkb2MuZmlyc3QgKyBkb2Muc2l6ZSAtIDEpLCBkaXNwbGF5ID0gY20uZGlzcGxheTtcXG4gIGlmIChsYXN0Lmxlbmd0aCAhPSBkaXNwbGF5LmxpbmVOdW1DaGFycykge1xcbiAgICB2YXIgdGVzdCA9IGRpc3BsYXkubWVhc3VyZS5hcHBlbmRDaGlsZChlbHQoXFxcImRpdlxcXCIsIFtlbHQoXFxcImRpdlxcXCIsIGxhc3QpXSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcXCJDb2RlTWlycm9yLWxpbmVudW1iZXIgQ29kZU1pcnJvci1ndXR0ZXItZWx0XFxcIikpO1xcbiAgICB2YXIgaW5uZXJXID0gdGVzdC5maXJzdENoaWxkLm9mZnNldFdpZHRoLCBwYWRkaW5nID0gdGVzdC5vZmZzZXRXaWR0aCAtIGlubmVyVztcXG4gICAgZGlzcGxheS5saW5lR3V0dGVyLnN0eWxlLndpZHRoID0gXFxcIlxcXCI7XFxuICAgIGRpc3BsYXkubGluZU51bUlubmVyV2lkdGggPSBNYXRoLm1heChpbm5lclcsIGRpc3BsYXkubGluZUd1dHRlci5vZmZzZXRXaWR0aCAtIHBhZGRpbmcpICsgMTtcXG4gICAgZGlzcGxheS5saW5lTnVtV2lkdGggPSBkaXNwbGF5LmxpbmVOdW1Jbm5lcldpZHRoICsgcGFkZGluZztcXG4gICAgZGlzcGxheS5saW5lTnVtQ2hhcnMgPSBkaXNwbGF5LmxpbmVOdW1Jbm5lcldpZHRoID8gbGFzdC5sZW5ndGggOiAtMTtcXG4gICAgZGlzcGxheS5saW5lR3V0dGVyLnN0eWxlLndpZHRoID0gZGlzcGxheS5saW5lTnVtV2lkdGggKyBcXFwicHhcXFwiO1xcbiAgICB1cGRhdGVHdXR0ZXJTcGFjZShjbSk7XFxuICAgIHJldHVybiB0cnVlXFxuICB9XFxuICByZXR1cm4gZmFsc2VcXG59XFxuXFxuLy8gUmVhZCB0aGUgYWN0dWFsIGhlaWdodHMgb2YgdGhlIHJlbmRlcmVkIGxpbmVzLCBhbmQgdXBkYXRlIHRoZWlyXFxuLy8gc3RvcmVkIGhlaWdodHMgdG8gbWF0Y2guXFxuZnVuY3Rpb24gdXBkYXRlSGVpZ2h0c0luVmlld3BvcnQoY20pIHtcXG4gIHZhciBkaXNwbGF5ID0gY20uZGlzcGxheTtcXG4gIHZhciBwcmV2Qm90dG9tID0gZGlzcGxheS5saW5lRGl2Lm9mZnNldFRvcDtcXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZGlzcGxheS52aWV3Lmxlbmd0aDsgaSsrKSB7XFxuICAgIHZhciBjdXIgPSBkaXNwbGF5LnZpZXdbaV0sIGhlaWdodCA9ICh2b2lkIDApO1xcbiAgICBpZiAoY3VyLmhpZGRlbikgeyBjb250aW51ZSB9XFxuICAgIGlmIChpZSAmJiBpZV92ZXJzaW9uIDwgOCkge1xcbiAgICAgIHZhciBib3QgPSBjdXIubm9kZS5vZmZzZXRUb3AgKyBjdXIubm9kZS5vZmZzZXRIZWlnaHQ7XFxuICAgICAgaGVpZ2h0ID0gYm90IC0gcHJldkJvdHRvbTtcXG4gICAgICBwcmV2Qm90dG9tID0gYm90O1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIHZhciBib3ggPSBjdXIubm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcXG4gICAgICBoZWlnaHQgPSBib3guYm90dG9tIC0gYm94LnRvcDtcXG4gICAgfVxcbiAgICB2YXIgZGlmZiA9IGN1ci5saW5lLmhlaWdodCAtIGhlaWdodDtcXG4gICAgaWYgKGhlaWdodCA8IDIpIHsgaGVpZ2h0ID0gdGV4dEhlaWdodChkaXNwbGF5KTsgfVxcbiAgICBpZiAoZGlmZiA+IC4wMDEgfHwgZGlmZiA8IC0uMDAxKSB7XFxuICAgICAgdXBkYXRlTGluZUhlaWdodChjdXIubGluZSwgaGVpZ2h0KTtcXG4gICAgICB1cGRhdGVXaWRnZXRIZWlnaHQoY3VyLmxpbmUpO1xcbiAgICAgIGlmIChjdXIucmVzdCkgeyBmb3IgKHZhciBqID0gMDsgaiA8IGN1ci5yZXN0Lmxlbmd0aDsgaisrKVxcbiAgICAgICAgeyB1cGRhdGVXaWRnZXRIZWlnaHQoY3VyLnJlc3Rbal0pOyB9IH1cXG4gICAgfVxcbiAgfVxcbn1cXG5cXG4vLyBSZWFkIGFuZCBzdG9yZSB0aGUgaGVpZ2h0IG9mIGxpbmUgd2lkZ2V0cyBhc3NvY2lhdGVkIHdpdGggdGhlXFxuLy8gZ2l2ZW4gbGluZS5cXG5mdW5jdGlvbiB1cGRhdGVXaWRnZXRIZWlnaHQobGluZSkge1xcbiAgaWYgKGxpbmUud2lkZ2V0cykgeyBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmUud2lkZ2V0cy5sZW5ndGg7ICsraSlcXG4gICAgeyBsaW5lLndpZGdldHNbaV0uaGVpZ2h0ID0gbGluZS53aWRnZXRzW2ldLm5vZGUucGFyZW50Tm9kZS5vZmZzZXRIZWlnaHQ7IH0gfVxcbn1cXG5cXG4vLyBDb21wdXRlIHRoZSBsaW5lcyB0aGF0IGFyZSB2aXNpYmxlIGluIGEgZ2l2ZW4gdmlld3BvcnQgKGRlZmF1bHRzXFxuLy8gdGhlIHRoZSBjdXJyZW50IHNjcm9sbCBwb3NpdGlvbikuIHZpZXdwb3J0IG1heSBjb250YWluIHRvcCxcXG4vLyBoZWlnaHQsIGFuZCBlbnN1cmUgKHNlZSBvcC5zY3JvbGxUb1BvcykgcHJvcGVydGllcy5cXG5mdW5jdGlvbiB2aXNpYmxlTGluZXMoZGlzcGxheSwgZG9jLCB2aWV3cG9ydCkge1xcbiAgdmFyIHRvcCA9IHZpZXdwb3J0ICYmIHZpZXdwb3J0LnRvcCAhPSBudWxsID8gTWF0aC5tYXgoMCwgdmlld3BvcnQudG9wKSA6IGRpc3BsYXkuc2Nyb2xsZXIuc2Nyb2xsVG9wO1xcbiAgdG9wID0gTWF0aC5mbG9vcih0b3AgLSBwYWRkaW5nVG9wKGRpc3BsYXkpKTtcXG4gIHZhciBib3R0b20gPSB2aWV3cG9ydCAmJiB2aWV3cG9ydC5ib3R0b20gIT0gbnVsbCA/IHZpZXdwb3J0LmJvdHRvbSA6IHRvcCArIGRpc3BsYXkud3JhcHBlci5jbGllbnRIZWlnaHQ7XFxuXFxuICB2YXIgZnJvbSA9IGxpbmVBdEhlaWdodChkb2MsIHRvcCksIHRvID0gbGluZUF0SGVpZ2h0KGRvYywgYm90dG9tKTtcXG4gIC8vIEVuc3VyZSBpcyBhIHtmcm9tOiB7bGluZSwgY2h9LCB0bzoge2xpbmUsIGNofX0gb2JqZWN0LCBhbmRcXG4gIC8vIGZvcmNlcyB0aG9zZSBsaW5lcyBpbnRvIHRoZSB2aWV3cG9ydCAoaWYgcG9zc2libGUpLlxcbiAgaWYgKHZpZXdwb3J0ICYmIHZpZXdwb3J0LmVuc3VyZSkge1xcbiAgICB2YXIgZW5zdXJlRnJvbSA9IHZpZXdwb3J0LmVuc3VyZS5mcm9tLmxpbmUsIGVuc3VyZVRvID0gdmlld3BvcnQuZW5zdXJlLnRvLmxpbmU7XFxuICAgIGlmIChlbnN1cmVGcm9tIDwgZnJvbSkge1xcbiAgICAgIGZyb20gPSBlbnN1cmVGcm9tO1xcbiAgICAgIHRvID0gbGluZUF0SGVpZ2h0KGRvYywgaGVpZ2h0QXRMaW5lKGdldExpbmUoZG9jLCBlbnN1cmVGcm9tKSkgKyBkaXNwbGF5LndyYXBwZXIuY2xpZW50SGVpZ2h0KTtcXG4gICAgfSBlbHNlIGlmIChNYXRoLm1pbihlbnN1cmVUbywgZG9jLmxhc3RMaW5lKCkpID49IHRvKSB7XFxuICAgICAgZnJvbSA9IGxpbmVBdEhlaWdodChkb2MsIGhlaWdodEF0TGluZShnZXRMaW5lKGRvYywgZW5zdXJlVG8pKSAtIGRpc3BsYXkud3JhcHBlci5jbGllbnRIZWlnaHQpO1xcbiAgICAgIHRvID0gZW5zdXJlVG87XFxuICAgIH1cXG4gIH1cXG4gIHJldHVybiB7ZnJvbTogZnJvbSwgdG86IE1hdGgubWF4KHRvLCBmcm9tICsgMSl9XFxufVxcblxcbi8vIFN5bmMgdGhlIHNjcm9sbGFibGUgYXJlYSBhbmQgc2Nyb2xsYmFycywgZW5zdXJlIHRoZSB2aWV3cG9ydFxcbi8vIGNvdmVycyB0aGUgdmlzaWJsZSBhcmVhLlxcbmZ1bmN0aW9uIHNldFNjcm9sbFRvcChjbSwgdmFsKSB7XFxuICBpZiAoTWF0aC5hYnMoY20uZG9jLnNjcm9sbFRvcCAtIHZhbCkgPCAyKSB7IHJldHVybiB9XFxuICBjbS5kb2Muc2Nyb2xsVG9wID0gdmFsO1xcbiAgaWYgKCFnZWNrbykgeyB1cGRhdGVEaXNwbGF5U2ltcGxlKGNtLCB7dG9wOiB2YWx9KTsgfVxcbiAgaWYgKGNtLmRpc3BsYXkuc2Nyb2xsZXIuc2Nyb2xsVG9wICE9IHZhbCkgeyBjbS5kaXNwbGF5LnNjcm9sbGVyLnNjcm9sbFRvcCA9IHZhbDsgfVxcbiAgY20uZGlzcGxheS5zY3JvbGxiYXJzLnNldFNjcm9sbFRvcCh2YWwpO1xcbiAgaWYgKGdlY2tvKSB7IHVwZGF0ZURpc3BsYXlTaW1wbGUoY20pOyB9XFxuICBzdGFydFdvcmtlcihjbSwgMTAwKTtcXG59XFxuLy8gU3luYyBzY3JvbGxlciBhbmQgc2Nyb2xsYmFyLCBlbnN1cmUgdGhlIGd1dHRlciBlbGVtZW50cyBhcmVcXG4vLyBhbGlnbmVkLlxcbmZ1bmN0aW9uIHNldFNjcm9sbExlZnQoY20sIHZhbCwgaXNTY3JvbGxlcikge1xcbiAgaWYgKGlzU2Nyb2xsZXIgPyB2YWwgPT0gY20uZG9jLnNjcm9sbExlZnQgOiBNYXRoLmFicyhjbS5kb2Muc2Nyb2xsTGVmdCAtIHZhbCkgPCAyKSB7IHJldHVybiB9XFxuICB2YWwgPSBNYXRoLm1pbih2YWwsIGNtLmRpc3BsYXkuc2Nyb2xsZXIuc2Nyb2xsV2lkdGggLSBjbS5kaXNwbGF5LnNjcm9sbGVyLmNsaWVudFdpZHRoKTtcXG4gIGNtLmRvYy5zY3JvbGxMZWZ0ID0gdmFsO1xcbiAgYWxpZ25Ib3Jpem9udGFsbHkoY20pO1xcbiAgaWYgKGNtLmRpc3BsYXkuc2Nyb2xsZXIuc2Nyb2xsTGVmdCAhPSB2YWwpIHsgY20uZGlzcGxheS5zY3JvbGxlci5zY3JvbGxMZWZ0ID0gdmFsOyB9XFxuICBjbS5kaXNwbGF5LnNjcm9sbGJhcnMuc2V0U2Nyb2xsTGVmdCh2YWwpO1xcbn1cXG5cXG4vLyBTaW5jZSB0aGUgZGVsdGEgdmFsdWVzIHJlcG9ydGVkIG9uIG1vdXNlIHdoZWVsIGV2ZW50cyBhcmVcXG4vLyB1bnN0YW5kYXJkaXplZCBiZXR3ZWVuIGJyb3dzZXJzIGFuZCBldmVuIGJyb3dzZXIgdmVyc2lvbnMsIGFuZFxcbi8vIGdlbmVyYWxseSBob3JyaWJseSB1bnByZWRpY3RhYmxlLCB0aGlzIGNvZGUgc3RhcnRzIGJ5IG1lYXN1cmluZ1xcbi8vIHRoZSBzY3JvbGwgZWZmZWN0IHRoYXQgdGhlIGZpcnN0IGZldyBtb3VzZSB3aGVlbCBldmVudHMgaGF2ZSxcXG4vLyBhbmQsIGZyb20gdGhhdCwgZGV0ZWN0cyB0aGUgd2F5IGl0IGNhbiBjb252ZXJ0IGRlbHRhcyB0byBwaXhlbFxcbi8vIG9mZnNldHMgYWZ0ZXJ3YXJkcy5cXG4vL1xcbi8vIFRoZSByZWFzb24gd2Ugd2FudCB0byBrbm93IHRoZSBhbW91bnQgYSB3aGVlbCBldmVudCB3aWxsIHNjcm9sbFxcbi8vIGlzIHRoYXQgaXQgZ2l2ZXMgdXMgYSBjaGFuY2UgdG8gdXBkYXRlIHRoZSBkaXNwbGF5IGJlZm9yZSB0aGVcXG4vLyBhY3R1YWwgc2Nyb2xsaW5nIGhhcHBlbnMsIHJlZHVjaW5nIGZsaWNrZXJpbmcuXFxuXFxudmFyIHdoZWVsU2FtcGxlcyA9IDA7XFxudmFyIHdoZWVsUGl4ZWxzUGVyVW5pdCA9IG51bGw7XFxuLy8gRmlsbCBpbiBhIGJyb3dzZXItZGV0ZWN0ZWQgc3RhcnRpbmcgdmFsdWUgb24gYnJvd3NlcnMgd2hlcmUgd2VcXG4vLyBrbm93IG9uZS4gVGhlc2UgZG9uJ3QgaGF2ZSB0byBiZSBhY2N1cmF0ZSAtLSB0aGUgcmVzdWx0IG9mIHRoZW1cXG4vLyBiZWluZyB3cm9uZyB3b3VsZCBqdXN0IGJlIGEgc2xpZ2h0IGZsaWNrZXIgb24gdGhlIGZpcnN0IHdoZWVsXFxuLy8gc2Nyb2xsIChpZiBpdCBpcyBsYXJnZSBlbm91Z2gpLlxcbmlmIChpZSkgeyB3aGVlbFBpeGVsc1BlclVuaXQgPSAtLjUzOyB9XFxuZWxzZSBpZiAoZ2Vja28pIHsgd2hlZWxQaXhlbHNQZXJVbml0ID0gMTU7IH1cXG5lbHNlIGlmIChjaHJvbWUpIHsgd2hlZWxQaXhlbHNQZXJVbml0ID0gLS43OyB9XFxuZWxzZSBpZiAoc2FmYXJpKSB7IHdoZWVsUGl4ZWxzUGVyVW5pdCA9IC0xLzM7IH1cXG5cXG5mdW5jdGlvbiB3aGVlbEV2ZW50RGVsdGEoZSkge1xcbiAgdmFyIGR4ID0gZS53aGVlbERlbHRhWCwgZHkgPSBlLndoZWVsRGVsdGFZO1xcbiAgaWYgKGR4ID09IG51bGwgJiYgZS5kZXRhaWwgJiYgZS5heGlzID09IGUuSE9SSVpPTlRBTF9BWElTKSB7IGR4ID0gZS5kZXRhaWw7IH1cXG4gIGlmIChkeSA9PSBudWxsICYmIGUuZGV0YWlsICYmIGUuYXhpcyA9PSBlLlZFUlRJQ0FMX0FYSVMpIHsgZHkgPSBlLmRldGFpbDsgfVxcbiAgZWxzZSBpZiAoZHkgPT0gbnVsbCkgeyBkeSA9IGUud2hlZWxEZWx0YTsgfVxcbiAgcmV0dXJuIHt4OiBkeCwgeTogZHl9XFxufVxcbmZ1bmN0aW9uIHdoZWVsRXZlbnRQaXhlbHMoZSkge1xcbiAgdmFyIGRlbHRhID0gd2hlZWxFdmVudERlbHRhKGUpO1xcbiAgZGVsdGEueCAqPSB3aGVlbFBpeGVsc1BlclVuaXQ7XFxuICBkZWx0YS55ICo9IHdoZWVsUGl4ZWxzUGVyVW5pdDtcXG4gIHJldHVybiBkZWx0YVxcbn1cXG5cXG5mdW5jdGlvbiBvblNjcm9sbFdoZWVsKGNtLCBlKSB7XFxuICB2YXIgZGVsdGEgPSB3aGVlbEV2ZW50RGVsdGEoZSksIGR4ID0gZGVsdGEueCwgZHkgPSBkZWx0YS55O1xcblxcbiAgdmFyIGRpc3BsYXkgPSBjbS5kaXNwbGF5LCBzY3JvbGwgPSBkaXNwbGF5LnNjcm9sbGVyO1xcbiAgLy8gUXVpdCBpZiB0aGVyZSdzIG5vdGhpbmcgdG8gc2Nyb2xsIGhlcmVcXG4gIHZhciBjYW5TY3JvbGxYID0gc2Nyb2xsLnNjcm9sbFdpZHRoID4gc2Nyb2xsLmNsaWVudFdpZHRoO1xcbiAgdmFyIGNhblNjcm9sbFkgPSBzY3JvbGwuc2Nyb2xsSGVpZ2h0ID4gc2Nyb2xsLmNsaWVudEhlaWdodDtcXG4gIGlmICghKGR4ICYmIGNhblNjcm9sbFggfHwgZHkgJiYgY2FuU2Nyb2xsWSkpIHsgcmV0dXJuIH1cXG5cXG4gIC8vIFdlYmtpdCBicm93c2VycyBvbiBPUyBYIGFib3J0IG1vbWVudHVtIHNjcm9sbHMgd2hlbiB0aGUgdGFyZ2V0XFxuICAvLyBvZiB0aGUgc2Nyb2xsIGV2ZW50IGlzIHJlbW92ZWQgZnJvbSB0aGUgc2Nyb2xsYWJsZSBlbGVtZW50LlxcbiAgLy8gVGhpcyBoYWNrIChzZWUgcmVsYXRlZCBjb2RlIGluIHBhdGNoRGlzcGxheSkgbWFrZXMgc3VyZSB0aGVcXG4gIC8vIGVsZW1lbnQgaXMga2VwdCBhcm91bmQuXFxuICBpZiAoZHkgJiYgbWFjICYmIHdlYmtpdCkge1xcbiAgICBvdXRlcjogZm9yICh2YXIgY3VyID0gZS50YXJnZXQsIHZpZXcgPSBkaXNwbGF5LnZpZXc7IGN1ciAhPSBzY3JvbGw7IGN1ciA9IGN1ci5wYXJlbnROb2RlKSB7XFxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2aWV3Lmxlbmd0aDsgaSsrKSB7XFxuICAgICAgICBpZiAodmlld1tpXS5ub2RlID09IGN1cikge1xcbiAgICAgICAgICBjbS5kaXNwbGF5LmN1cnJlbnRXaGVlbFRhcmdldCA9IGN1cjtcXG4gICAgICAgICAgYnJlYWsgb3V0ZXJcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIH1cXG4gIH1cXG5cXG4gIC8vIE9uIHNvbWUgYnJvd3NlcnMsIGhvcml6b250YWwgc2Nyb2xsaW5nIHdpbGwgY2F1c2UgcmVkcmF3cyB0b1xcbiAgLy8gaGFwcGVuIGJlZm9yZSB0aGUgZ3V0dGVyIGhhcyBiZWVuIHJlYWxpZ25lZCwgY2F1c2luZyBpdCB0b1xcbiAgLy8gd3JpZ2dsZSBhcm91bmQgaW4gYSBtb3N0IHVuc2VlbWx5IHdheS4gV2hlbiB3ZSBoYXZlIGFuXFxuICAvLyBlc3RpbWF0ZWQgcGl4ZWxzL2RlbHRhIHZhbHVlLCB3ZSBqdXN0IGhhbmRsZSBob3Jpem9udGFsXFxuICAvLyBzY3JvbGxpbmcgZW50aXJlbHkgaGVyZS4gSXQnbGwgYmUgc2xpZ2h0bHkgb2ZmIGZyb20gbmF0aXZlLCBidXRcXG4gIC8vIGJldHRlciB0aGFuIGdsaXRjaGluZyBvdXQuXFxuICBpZiAoZHggJiYgIWdlY2tvICYmICFwcmVzdG8gJiYgd2hlZWxQaXhlbHNQZXJVbml0ICE9IG51bGwpIHtcXG4gICAgaWYgKGR5ICYmIGNhblNjcm9sbFkpXFxuICAgICAgeyBzZXRTY3JvbGxUb3AoY20sIE1hdGgubWF4KDAsIE1hdGgubWluKHNjcm9sbC5zY3JvbGxUb3AgKyBkeSAqIHdoZWVsUGl4ZWxzUGVyVW5pdCwgc2Nyb2xsLnNjcm9sbEhlaWdodCAtIHNjcm9sbC5jbGllbnRIZWlnaHQpKSk7IH1cXG4gICAgc2V0U2Nyb2xsTGVmdChjbSwgTWF0aC5tYXgoMCwgTWF0aC5taW4oc2Nyb2xsLnNjcm9sbExlZnQgKyBkeCAqIHdoZWVsUGl4ZWxzUGVyVW5pdCwgc2Nyb2xsLnNjcm9sbFdpZHRoIC0gc2Nyb2xsLmNsaWVudFdpZHRoKSkpO1xcbiAgICAvLyBPbmx5IHByZXZlbnQgZGVmYXVsdCBzY3JvbGxpbmcgaWYgdmVydGljYWwgc2Nyb2xsaW5nIGlzXFxuICAgIC8vIGFjdHVhbGx5IHBvc3NpYmxlLiBPdGhlcndpc2UsIGl0IGNhdXNlcyB2ZXJ0aWNhbCBzY3JvbGxcXG4gICAgLy8gaml0dGVyIG9uIE9TWCB0cmFja3BhZHMgd2hlbiBkZWx0YVggaXMgc21hbGwgYW5kIGRlbHRhWVxcbiAgICAvLyBpcyBsYXJnZSAoaXNzdWUgIzM1NzkpXFxuICAgIGlmICghZHkgfHwgKGR5ICYmIGNhblNjcm9sbFkpKVxcbiAgICAgIHsgZV9wcmV2ZW50RGVmYXVsdChlKTsgfVxcbiAgICBkaXNwbGF5LndoZWVsU3RhcnRYID0gbnVsbDsgLy8gQWJvcnQgbWVhc3VyZW1lbnQsIGlmIGluIHByb2dyZXNzXFxuICAgIHJldHVyblxcbiAgfVxcblxcbiAgLy8gJ1Byb2plY3QnIHRoZSB2aXNpYmxlIHZpZXdwb3J0IHRvIGNvdmVyIHRoZSBhcmVhIHRoYXQgaXMgYmVpbmdcXG4gIC8vIHNjcm9sbGVkIGludG8gdmlldyAoaWYgd2Uga25vdyBlbm91Z2ggdG8gZXN0aW1hdGUgaXQpLlxcbiAgaWYgKGR5ICYmIHdoZWVsUGl4ZWxzUGVyVW5pdCAhPSBudWxsKSB7XFxuICAgIHZhciBwaXhlbHMgPSBkeSAqIHdoZWVsUGl4ZWxzUGVyVW5pdDtcXG4gICAgdmFyIHRvcCA9IGNtLmRvYy5zY3JvbGxUb3AsIGJvdCA9IHRvcCArIGRpc3BsYXkud3JhcHBlci5jbGllbnRIZWlnaHQ7XFxuICAgIGlmIChwaXhlbHMgPCAwKSB7IHRvcCA9IE1hdGgubWF4KDAsIHRvcCArIHBpeGVscyAtIDUwKTsgfVxcbiAgICBlbHNlIHsgYm90ID0gTWF0aC5taW4oY20uZG9jLmhlaWdodCwgYm90ICsgcGl4ZWxzICsgNTApOyB9XFxuICAgIHVwZGF0ZURpc3BsYXlTaW1wbGUoY20sIHt0b3A6IHRvcCwgYm90dG9tOiBib3R9KTtcXG4gIH1cXG5cXG4gIGlmICh3aGVlbFNhbXBsZXMgPCAyMCkge1xcbiAgICBpZiAoZGlzcGxheS53aGVlbFN0YXJ0WCA9PSBudWxsKSB7XFxuICAgICAgZGlzcGxheS53aGVlbFN0YXJ0WCA9IHNjcm9sbC5zY3JvbGxMZWZ0OyBkaXNwbGF5LndoZWVsU3RhcnRZID0gc2Nyb2xsLnNjcm9sbFRvcDtcXG4gICAgICBkaXNwbGF5LndoZWVsRFggPSBkeDsgZGlzcGxheS53aGVlbERZID0gZHk7XFxuICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XFxuICAgICAgICBpZiAoZGlzcGxheS53aGVlbFN0YXJ0WCA9PSBudWxsKSB7IHJldHVybiB9XFxuICAgICAgICB2YXIgbW92ZWRYID0gc2Nyb2xsLnNjcm9sbExlZnQgLSBkaXNwbGF5LndoZWVsU3RhcnRYO1xcbiAgICAgICAgdmFyIG1vdmVkWSA9IHNjcm9sbC5zY3JvbGxUb3AgLSBkaXNwbGF5LndoZWVsU3RhcnRZO1xcbiAgICAgICAgdmFyIHNhbXBsZSA9IChtb3ZlZFkgJiYgZGlzcGxheS53aGVlbERZICYmIG1vdmVkWSAvIGRpc3BsYXkud2hlZWxEWSkgfHxcXG4gICAgICAgICAgKG1vdmVkWCAmJiBkaXNwbGF5LndoZWVsRFggJiYgbW92ZWRYIC8gZGlzcGxheS53aGVlbERYKTtcXG4gICAgICAgIGRpc3BsYXkud2hlZWxTdGFydFggPSBkaXNwbGF5LndoZWVsU3RhcnRZID0gbnVsbDtcXG4gICAgICAgIGlmICghc2FtcGxlKSB7IHJldHVybiB9XFxuICAgICAgICB3aGVlbFBpeGVsc1BlclVuaXQgPSAod2hlZWxQaXhlbHNQZXJVbml0ICogd2hlZWxTYW1wbGVzICsgc2FtcGxlKSAvICh3aGVlbFNhbXBsZXMgKyAxKTtcXG4gICAgICAgICsrd2hlZWxTYW1wbGVzO1xcbiAgICAgIH0sIDIwMCk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgZGlzcGxheS53aGVlbERYICs9IGR4OyBkaXNwbGF5LndoZWVsRFkgKz0gZHk7XFxuICAgIH1cXG4gIH1cXG59XFxuXFxuLy8gU0NST0xMQkFSU1xcblxcbi8vIFByZXBhcmUgRE9NIHJlYWRzIG5lZWRlZCB0byB1cGRhdGUgdGhlIHNjcm9sbGJhcnMuIERvbmUgaW4gb25lXFxuLy8gc2hvdCB0byBtaW5pbWl6ZSB1cGRhdGUvbWVhc3VyZSByb3VuZHRyaXBzLlxcbmZ1bmN0aW9uIG1lYXN1cmVGb3JTY3JvbGxiYXJzKGNtKSB7XFxuICB2YXIgZCA9IGNtLmRpc3BsYXksIGd1dHRlclcgPSBkLmd1dHRlcnMub2Zmc2V0V2lkdGg7XFxuICB2YXIgZG9jSCA9IE1hdGgucm91bmQoY20uZG9jLmhlaWdodCArIHBhZGRpbmdWZXJ0KGNtLmRpc3BsYXkpKTtcXG4gIHJldHVybiB7XFxuICAgIGNsaWVudEhlaWdodDogZC5zY3JvbGxlci5jbGllbnRIZWlnaHQsXFxuICAgIHZpZXdIZWlnaHQ6IGQud3JhcHBlci5jbGllbnRIZWlnaHQsXFxuICAgIHNjcm9sbFdpZHRoOiBkLnNjcm9sbGVyLnNjcm9sbFdpZHRoLCBjbGllbnRXaWR0aDogZC5zY3JvbGxlci5jbGllbnRXaWR0aCxcXG4gICAgdmlld1dpZHRoOiBkLndyYXBwZXIuY2xpZW50V2lkdGgsXFxuICAgIGJhckxlZnQ6IGNtLm9wdGlvbnMuZml4ZWRHdXR0ZXIgPyBndXR0ZXJXIDogMCxcXG4gICAgZG9jSGVpZ2h0OiBkb2NILFxcbiAgICBzY3JvbGxIZWlnaHQ6IGRvY0ggKyBzY3JvbGxHYXAoY20pICsgZC5iYXJIZWlnaHQsXFxuICAgIG5hdGl2ZUJhcldpZHRoOiBkLm5hdGl2ZUJhcldpZHRoLFxcbiAgICBndXR0ZXJXaWR0aDogZ3V0dGVyV1xcbiAgfVxcbn1cXG5cXG52YXIgTmF0aXZlU2Nyb2xsYmFycyA9IGZ1bmN0aW9uKHBsYWNlLCBzY3JvbGwsIGNtKSB7XFxuICB0aGlzLmNtID0gY207XFxuICB2YXIgdmVydCA9IHRoaXMudmVydCA9IGVsdChcXFwiZGl2XFxcIiwgW2VsdChcXFwiZGl2XFxcIiwgbnVsbCwgbnVsbCwgXFxcIm1pbi13aWR0aDogMXB4XFxcIildLCBcXFwiQ29kZU1pcnJvci12c2Nyb2xsYmFyXFxcIik7XFxuICB2YXIgaG9yaXogPSB0aGlzLmhvcml6ID0gZWx0KFxcXCJkaXZcXFwiLCBbZWx0KFxcXCJkaXZcXFwiLCBudWxsLCBudWxsLCBcXFwiaGVpZ2h0OiAxMDAlOyBtaW4taGVpZ2h0OiAxcHhcXFwiKV0sIFxcXCJDb2RlTWlycm9yLWhzY3JvbGxiYXJcXFwiKTtcXG4gIHBsYWNlKHZlcnQpOyBwbGFjZShob3Jpeik7XFxuXFxuICBvbih2ZXJ0LCBcXFwic2Nyb2xsXFxcIiwgZnVuY3Rpb24gKCkge1xcbiAgICBpZiAodmVydC5jbGllbnRIZWlnaHQpIHsgc2Nyb2xsKHZlcnQuc2Nyb2xsVG9wLCBcXFwidmVydGljYWxcXFwiKTsgfVxcbiAgfSk7XFxuICBvbihob3JpeiwgXFxcInNjcm9sbFxcXCIsIGZ1bmN0aW9uICgpIHtcXG4gICAgaWYgKGhvcml6LmNsaWVudFdpZHRoKSB7IHNjcm9sbChob3Jpei5zY3JvbGxMZWZ0LCBcXFwiaG9yaXpvbnRhbFxcXCIpOyB9XFxuICB9KTtcXG5cXG4gIHRoaXMuY2hlY2tlZFplcm9XaWR0aCA9IGZhbHNlO1xcbiAgLy8gTmVlZCB0byBzZXQgYSBtaW5pbXVtIHdpZHRoIHRvIHNlZSB0aGUgc2Nyb2xsYmFyIG9uIElFNyAoYnV0IG11c3Qgbm90IHNldCBpdCBvbiBJRTgpLlxcbiAgaWYgKGllICYmIGllX3ZlcnNpb24gPCA4KSB7IHRoaXMuaG9yaXouc3R5bGUubWluSGVpZ2h0ID0gdGhpcy52ZXJ0LnN0eWxlLm1pbldpZHRoID0gXFxcIjE4cHhcXFwiOyB9XFxufTtcXG5cXG5OYXRpdmVTY3JvbGxiYXJzLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAobWVhc3VyZSkge1xcbiAgdmFyIG5lZWRzSCA9IG1lYXN1cmUuc2Nyb2xsV2lkdGggPiBtZWFzdXJlLmNsaWVudFdpZHRoICsgMTtcXG4gIHZhciBuZWVkc1YgPSBtZWFzdXJlLnNjcm9sbEhlaWdodCA+IG1lYXN1cmUuY2xpZW50SGVpZ2h0ICsgMTtcXG4gIHZhciBzV2lkdGggPSBtZWFzdXJlLm5hdGl2ZUJhcldpZHRoO1xcblxcbiAgaWYgKG5lZWRzVikge1xcbiAgICB0aGlzLnZlcnQuc3R5bGUuZGlzcGxheSA9IFxcXCJibG9ja1xcXCI7XFxuICAgIHRoaXMudmVydC5zdHlsZS5ib3R0b20gPSBuZWVkc0ggPyBzV2lkdGggKyBcXFwicHhcXFwiIDogXFxcIjBcXFwiO1xcbiAgICB2YXIgdG90YWxIZWlnaHQgPSBtZWFzdXJlLnZpZXdIZWlnaHQgLSAobmVlZHNIID8gc1dpZHRoIDogMCk7XFxuICAgIC8vIEEgYnVnIGluIElFOCBjYW4gY2F1c2UgdGhpcyB2YWx1ZSB0byBiZSBuZWdhdGl2ZSwgc28gZ3VhcmQgaXQuXFxuICAgIHRoaXMudmVydC5maXJzdENoaWxkLnN0eWxlLmhlaWdodCA9XFxuICAgICAgTWF0aC5tYXgoMCwgbWVhc3VyZS5zY3JvbGxIZWlnaHQgLSBtZWFzdXJlLmNsaWVudEhlaWdodCArIHRvdGFsSGVpZ2h0KSArIFxcXCJweFxcXCI7XFxuICB9IGVsc2Uge1xcbiAgICB0aGlzLnZlcnQuc3R5bGUuZGlzcGxheSA9IFxcXCJcXFwiO1xcbiAgICB0aGlzLnZlcnQuZmlyc3RDaGlsZC5zdHlsZS5oZWlnaHQgPSBcXFwiMFxcXCI7XFxuICB9XFxuXFxuICBpZiAobmVlZHNIKSB7XFxuICAgIHRoaXMuaG9yaXouc3R5bGUuZGlzcGxheSA9IFxcXCJibG9ja1xcXCI7XFxuICAgIHRoaXMuaG9yaXouc3R5bGUucmlnaHQgPSBuZWVkc1YgPyBzV2lkdGggKyBcXFwicHhcXFwiIDogXFxcIjBcXFwiO1xcbiAgICB0aGlzLmhvcml6LnN0eWxlLmxlZnQgPSBtZWFzdXJlLmJhckxlZnQgKyBcXFwicHhcXFwiO1xcbiAgICB2YXIgdG90YWxXaWR0aCA9IG1lYXN1cmUudmlld1dpZHRoIC0gbWVhc3VyZS5iYXJMZWZ0IC0gKG5lZWRzViA/IHNXaWR0aCA6IDApO1xcbiAgICB0aGlzLmhvcml6LmZpcnN0Q2hpbGQuc3R5bGUud2lkdGggPVxcbiAgICAgIE1hdGgubWF4KDAsIG1lYXN1cmUuc2Nyb2xsV2lkdGggLSBtZWFzdXJlLmNsaWVudFdpZHRoICsgdG90YWxXaWR0aCkgKyBcXFwicHhcXFwiO1xcbiAgfSBlbHNlIHtcXG4gICAgdGhpcy5ob3Jpei5zdHlsZS5kaXNwbGF5ID0gXFxcIlxcXCI7XFxuICAgIHRoaXMuaG9yaXouZmlyc3RDaGlsZC5zdHlsZS53aWR0aCA9IFxcXCIwXFxcIjtcXG4gIH1cXG5cXG4gIGlmICghdGhpcy5jaGVja2VkWmVyb1dpZHRoICYmIG1lYXN1cmUuY2xpZW50SGVpZ2h0ID4gMCkge1xcbiAgICBpZiAoc1dpZHRoID09IDApIHsgdGhpcy56ZXJvV2lkdGhIYWNrKCk7IH1cXG4gICAgdGhpcy5jaGVja2VkWmVyb1dpZHRoID0gdHJ1ZTtcXG4gIH1cXG5cXG4gIHJldHVybiB7cmlnaHQ6IG5lZWRzViA/IHNXaWR0aCA6IDAsIGJvdHRvbTogbmVlZHNIID8gc1dpZHRoIDogMH1cXG59O1xcblxcbk5hdGl2ZVNjcm9sbGJhcnMucHJvdG90eXBlLnNldFNjcm9sbExlZnQgPSBmdW5jdGlvbiAocG9zKSB7XFxuICBpZiAodGhpcy5ob3Jpei5zY3JvbGxMZWZ0ICE9IHBvcykgeyB0aGlzLmhvcml6LnNjcm9sbExlZnQgPSBwb3M7IH1cXG4gIGlmICh0aGlzLmRpc2FibGVIb3JpeikgeyB0aGlzLmVuYWJsZVplcm9XaWR0aEJhcih0aGlzLmhvcml6LCB0aGlzLmRpc2FibGVIb3Jpeik7IH1cXG59O1xcblxcbk5hdGl2ZVNjcm9sbGJhcnMucHJvdG90eXBlLnNldFNjcm9sbFRvcCA9IGZ1bmN0aW9uIChwb3MpIHtcXG4gIGlmICh0aGlzLnZlcnQuc2Nyb2xsVG9wICE9IHBvcykgeyB0aGlzLnZlcnQuc2Nyb2xsVG9wID0gcG9zOyB9XFxuICBpZiAodGhpcy5kaXNhYmxlVmVydCkgeyB0aGlzLmVuYWJsZVplcm9XaWR0aEJhcih0aGlzLnZlcnQsIHRoaXMuZGlzYWJsZVZlcnQpOyB9XFxufTtcXG5cXG5OYXRpdmVTY3JvbGxiYXJzLnByb3RvdHlwZS56ZXJvV2lkdGhIYWNrID0gZnVuY3Rpb24gKCkge1xcbiAgdmFyIHcgPSBtYWMgJiYgIW1hY19nZU1vdW50YWluTGlvbiA/IFxcXCIxMnB4XFxcIiA6IFxcXCIxOHB4XFxcIjtcXG4gIHRoaXMuaG9yaXouc3R5bGUuaGVpZ2h0ID0gdGhpcy52ZXJ0LnN0eWxlLndpZHRoID0gdztcXG4gIHRoaXMuaG9yaXouc3R5bGUucG9pbnRlckV2ZW50cyA9IHRoaXMudmVydC5zdHlsZS5wb2ludGVyRXZlbnRzID0gXFxcIm5vbmVcXFwiO1xcbiAgdGhpcy5kaXNhYmxlSG9yaXogPSBuZXcgRGVsYXllZDtcXG4gIHRoaXMuZGlzYWJsZVZlcnQgPSBuZXcgRGVsYXllZDtcXG59O1xcblxcbk5hdGl2ZVNjcm9sbGJhcnMucHJvdG90eXBlLmVuYWJsZVplcm9XaWR0aEJhciA9IGZ1bmN0aW9uIChiYXIsIGRlbGF5KSB7XFxuICBiYXIuc3R5bGUucG9pbnRlckV2ZW50cyA9IFxcXCJhdXRvXFxcIjtcXG4gIGZ1bmN0aW9uIG1heWJlRGlzYWJsZSgpIHtcXG4gICAgLy8gVG8gZmluZCBvdXQgd2hldGhlciB0aGUgc2Nyb2xsYmFyIGlzIHN0aWxsIHZpc2libGUsIHdlXFxuICAgIC8vIGNoZWNrIHdoZXRoZXIgdGhlIGVsZW1lbnQgdW5kZXIgdGhlIHBpeGVsIGluIHRoZSBib3R0b21cXG4gICAgLy8gbGVmdCBjb3JuZXIgb2YgdGhlIHNjcm9sbGJhciBib3ggaXMgdGhlIHNjcm9sbGJhciBib3hcXG4gICAgLy8gaXRzZWxmICh3aGVuIHRoZSBiYXIgaXMgc3RpbGwgdmlzaWJsZSkgb3IgaXRzIGZpbGxlciBjaGlsZFxcbiAgICAvLyAod2hlbiB0aGUgYmFyIGlzIGhpZGRlbikuIElmIGl0IGlzIHN0aWxsIHZpc2libGUsIHdlIGtlZXBcXG4gICAgLy8gaXQgZW5hYmxlZCwgaWYgaXQncyBoaWRkZW4sIHdlIGRpc2FibGUgcG9pbnRlciBldmVudHMuXFxuICAgIHZhciBib3ggPSBiYXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XFxuICAgIHZhciBlbHQkJDEgPSBkb2N1bWVudC5lbGVtZW50RnJvbVBvaW50KGJveC5sZWZ0ICsgMSwgYm94LmJvdHRvbSAtIDEpO1xcbiAgICBpZiAoZWx0JCQxICE9IGJhcikgeyBiYXIuc3R5bGUucG9pbnRlckV2ZW50cyA9IFxcXCJub25lXFxcIjsgfVxcbiAgICBlbHNlIHsgZGVsYXkuc2V0KDEwMDAsIG1heWJlRGlzYWJsZSk7IH1cXG4gIH1cXG4gIGRlbGF5LnNldCgxMDAwLCBtYXliZURpc2FibGUpO1xcbn07XFxuXFxuTmF0aXZlU2Nyb2xsYmFycy5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XFxuICB2YXIgcGFyZW50ID0gdGhpcy5ob3Jpei5wYXJlbnROb2RlO1xcbiAgcGFyZW50LnJlbW92ZUNoaWxkKHRoaXMuaG9yaXopO1xcbiAgcGFyZW50LnJlbW92ZUNoaWxkKHRoaXMudmVydCk7XFxufTtcXG5cXG52YXIgTnVsbFNjcm9sbGJhcnMgPSBmdW5jdGlvbiAoKSB7fTtcXG5cXG5OdWxsU2Nyb2xsYmFycy5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkgeyByZXR1cm4ge2JvdHRvbTogMCwgcmlnaHQ6IDB9IH07XFxuTnVsbFNjcm9sbGJhcnMucHJvdG90eXBlLnNldFNjcm9sbExlZnQgPSBmdW5jdGlvbiAoKSB7fTtcXG5OdWxsU2Nyb2xsYmFycy5wcm90b3R5cGUuc2V0U2Nyb2xsVG9wID0gZnVuY3Rpb24gKCkge307XFxuTnVsbFNjcm9sbGJhcnMucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge307XFxuXFxuZnVuY3Rpb24gdXBkYXRlU2Nyb2xsYmFycyhjbSwgbWVhc3VyZSkge1xcbiAgaWYgKCFtZWFzdXJlKSB7IG1lYXN1cmUgPSBtZWFzdXJlRm9yU2Nyb2xsYmFycyhjbSk7IH1cXG4gIHZhciBzdGFydFdpZHRoID0gY20uZGlzcGxheS5iYXJXaWR0aCwgc3RhcnRIZWlnaHQgPSBjbS5kaXNwbGF5LmJhckhlaWdodDtcXG4gIHVwZGF0ZVNjcm9sbGJhcnNJbm5lcihjbSwgbWVhc3VyZSk7XFxuICBmb3IgKHZhciBpID0gMDsgaSA8IDQgJiYgc3RhcnRXaWR0aCAhPSBjbS5kaXNwbGF5LmJhcldpZHRoIHx8IHN0YXJ0SGVpZ2h0ICE9IGNtLmRpc3BsYXkuYmFySGVpZ2h0OyBpKyspIHtcXG4gICAgaWYgKHN0YXJ0V2lkdGggIT0gY20uZGlzcGxheS5iYXJXaWR0aCAmJiBjbS5vcHRpb25zLmxpbmVXcmFwcGluZylcXG4gICAgICB7IHVwZGF0ZUhlaWdodHNJblZpZXdwb3J0KGNtKTsgfVxcbiAgICB1cGRhdGVTY3JvbGxiYXJzSW5uZXIoY20sIG1lYXN1cmVGb3JTY3JvbGxiYXJzKGNtKSk7XFxuICAgIHN0YXJ0V2lkdGggPSBjbS5kaXNwbGF5LmJhcldpZHRoOyBzdGFydEhlaWdodCA9IGNtLmRpc3BsYXkuYmFySGVpZ2h0O1xcbiAgfVxcbn1cXG5cXG4vLyBSZS1zeW5jaHJvbml6ZSB0aGUgZmFrZSBzY3JvbGxiYXJzIHdpdGggdGhlIGFjdHVhbCBzaXplIG9mIHRoZVxcbi8vIGNvbnRlbnQuXFxuZnVuY3Rpb24gdXBkYXRlU2Nyb2xsYmFyc0lubmVyKGNtLCBtZWFzdXJlKSB7XFxuICB2YXIgZCA9IGNtLmRpc3BsYXk7XFxuICB2YXIgc2l6ZXMgPSBkLnNjcm9sbGJhcnMudXBkYXRlKG1lYXN1cmUpO1xcblxcbiAgZC5zaXplci5zdHlsZS5wYWRkaW5nUmlnaHQgPSAoZC5iYXJXaWR0aCA9IHNpemVzLnJpZ2h0KSArIFxcXCJweFxcXCI7XFxuICBkLnNpemVyLnN0eWxlLnBhZGRpbmdCb3R0b20gPSAoZC5iYXJIZWlnaHQgPSBzaXplcy5ib3R0b20pICsgXFxcInB4XFxcIjtcXG4gIGQuaGVpZ2h0Rm9yY2VyLnN0eWxlLmJvcmRlckJvdHRvbSA9IHNpemVzLmJvdHRvbSArIFxcXCJweCBzb2xpZCB0cmFuc3BhcmVudFxcXCI7XFxuXFxuICBpZiAoc2l6ZXMucmlnaHQgJiYgc2l6ZXMuYm90dG9tKSB7XFxuICAgIGQuc2Nyb2xsYmFyRmlsbGVyLnN0eWxlLmRpc3BsYXkgPSBcXFwiYmxvY2tcXFwiO1xcbiAgICBkLnNjcm9sbGJhckZpbGxlci5zdHlsZS5oZWlnaHQgPSBzaXplcy5ib3R0b20gKyBcXFwicHhcXFwiO1xcbiAgICBkLnNjcm9sbGJhckZpbGxlci5zdHlsZS53aWR0aCA9IHNpemVzLnJpZ2h0ICsgXFxcInB4XFxcIjtcXG4gIH0gZWxzZSB7IGQuc2Nyb2xsYmFyRmlsbGVyLnN0eWxlLmRpc3BsYXkgPSBcXFwiXFxcIjsgfVxcbiAgaWYgKHNpemVzLmJvdHRvbSAmJiBjbS5vcHRpb25zLmNvdmVyR3V0dGVyTmV4dFRvU2Nyb2xsYmFyICYmIGNtLm9wdGlvbnMuZml4ZWRHdXR0ZXIpIHtcXG4gICAgZC5ndXR0ZXJGaWxsZXIuc3R5bGUuZGlzcGxheSA9IFxcXCJibG9ja1xcXCI7XFxuICAgIGQuZ3V0dGVyRmlsbGVyLnN0eWxlLmhlaWdodCA9IHNpemVzLmJvdHRvbSArIFxcXCJweFxcXCI7XFxuICAgIGQuZ3V0dGVyRmlsbGVyLnN0eWxlLndpZHRoID0gbWVhc3VyZS5ndXR0ZXJXaWR0aCArIFxcXCJweFxcXCI7XFxuICB9IGVsc2UgeyBkLmd1dHRlckZpbGxlci5zdHlsZS5kaXNwbGF5ID0gXFxcIlxcXCI7IH1cXG59XFxuXFxudmFyIHNjcm9sbGJhck1vZGVsID0ge1xcXCJuYXRpdmVcXFwiOiBOYXRpdmVTY3JvbGxiYXJzLCBcXFwibnVsbFxcXCI6IE51bGxTY3JvbGxiYXJzfTtcXG5cXG5mdW5jdGlvbiBpbml0U2Nyb2xsYmFycyhjbSkge1xcbiAgaWYgKGNtLmRpc3BsYXkuc2Nyb2xsYmFycykge1xcbiAgICBjbS5kaXNwbGF5LnNjcm9sbGJhcnMuY2xlYXIoKTtcXG4gICAgaWYgKGNtLmRpc3BsYXkuc2Nyb2xsYmFycy5hZGRDbGFzcylcXG4gICAgICB7IHJtQ2xhc3MoY20uZGlzcGxheS53cmFwcGVyLCBjbS5kaXNwbGF5LnNjcm9sbGJhcnMuYWRkQ2xhc3MpOyB9XFxuICB9XFxuXFxuICBjbS5kaXNwbGF5LnNjcm9sbGJhcnMgPSBuZXcgc2Nyb2xsYmFyTW9kZWxbY20ub3B0aW9ucy5zY3JvbGxiYXJTdHlsZV0oZnVuY3Rpb24gKG5vZGUpIHtcXG4gICAgY20uZGlzcGxheS53cmFwcGVyLmluc2VydEJlZm9yZShub2RlLCBjbS5kaXNwbGF5LnNjcm9sbGJhckZpbGxlcik7XFxuICAgIC8vIFByZXZlbnQgY2xpY2tzIGluIHRoZSBzY3JvbGxiYXJzIGZyb20ga2lsbGluZyBmb2N1c1xcbiAgICBvbihub2RlLCBcXFwibW91c2Vkb3duXFxcIiwgZnVuY3Rpb24gKCkge1xcbiAgICAgIGlmIChjbS5zdGF0ZS5mb2N1c2VkKSB7IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyByZXR1cm4gY20uZGlzcGxheS5pbnB1dC5mb2N1cygpOyB9LCAwKTsgfVxcbiAgICB9KTtcXG4gICAgbm9kZS5zZXRBdHRyaWJ1dGUoXFxcImNtLW5vdC1jb250ZW50XFxcIiwgXFxcInRydWVcXFwiKTtcXG4gIH0sIGZ1bmN0aW9uIChwb3MsIGF4aXMpIHtcXG4gICAgaWYgKGF4aXMgPT0gXFxcImhvcml6b250YWxcXFwiKSB7IHNldFNjcm9sbExlZnQoY20sIHBvcyk7IH1cXG4gICAgZWxzZSB7IHNldFNjcm9sbFRvcChjbSwgcG9zKTsgfVxcbiAgfSwgY20pO1xcbiAgaWYgKGNtLmRpc3BsYXkuc2Nyb2xsYmFycy5hZGRDbGFzcylcXG4gICAgeyBhZGRDbGFzcyhjbS5kaXNwbGF5LndyYXBwZXIsIGNtLmRpc3BsYXkuc2Nyb2xsYmFycy5hZGRDbGFzcyk7IH1cXG59XFxuXFxuLy8gU0NST0xMSU5HIFRISU5HUyBJTlRPIFZJRVdcXG5cXG4vLyBJZiBhbiBlZGl0b3Igc2l0cyBvbiB0aGUgdG9wIG9yIGJvdHRvbSBvZiB0aGUgd2luZG93LCBwYXJ0aWFsbHlcXG4vLyBzY3JvbGxlZCBvdXQgb2YgdmlldywgdGhpcyBlbnN1cmVzIHRoYXQgdGhlIGN1cnNvciBpcyB2aXNpYmxlLlxcbmZ1bmN0aW9uIG1heWJlU2Nyb2xsV2luZG93KGNtLCByZWN0KSB7XFxuICBpZiAoc2lnbmFsRE9NRXZlbnQoY20sIFxcXCJzY3JvbGxDdXJzb3JJbnRvVmlld1xcXCIpKSB7IHJldHVybiB9XFxuXFxuICB2YXIgZGlzcGxheSA9IGNtLmRpc3BsYXksIGJveCA9IGRpc3BsYXkuc2l6ZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIGRvU2Nyb2xsID0gbnVsbDtcXG4gIGlmIChyZWN0LnRvcCArIGJveC50b3AgPCAwKSB7IGRvU2Nyb2xsID0gdHJ1ZTsgfVxcbiAgZWxzZSBpZiAocmVjdC5ib3R0b20gKyBib3gudG9wID4gKHdpbmRvdy5pbm5lckhlaWdodCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0KSkgeyBkb1Njcm9sbCA9IGZhbHNlOyB9XFxuICBpZiAoZG9TY3JvbGwgIT0gbnVsbCAmJiAhcGhhbnRvbSkge1xcbiAgICB2YXIgc2Nyb2xsTm9kZSA9IGVsdChcXFwiZGl2XFxcIiwgXFxcIlxcXFx1MjAwYlxcXCIsIG51bGwsIChcXFwicG9zaXRpb246IGFic29sdXRlO1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgIHRvcDogXFxcIiArIChyZWN0LnRvcCAtIGRpc3BsYXkudmlld09mZnNldCAtIHBhZGRpbmdUb3AoY20uZGlzcGxheSkpICsgXFxcInB4O1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogXFxcIiArIChyZWN0LmJvdHRvbSAtIHJlY3QudG9wICsgc2Nyb2xsR2FwKGNtKSArIGRpc3BsYXkuYmFySGVpZ2h0KSArIFxcXCJweDtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICBsZWZ0OiBcXFwiICsgKHJlY3QubGVmdCkgKyBcXFwicHg7IHdpZHRoOiBcXFwiICsgKE1hdGgubWF4KDIsIHJlY3QucmlnaHQgLSByZWN0LmxlZnQpKSArIFxcXCJweDtcXFwiKSk7XFxuICAgIGNtLmRpc3BsYXkubGluZVNwYWNlLmFwcGVuZENoaWxkKHNjcm9sbE5vZGUpO1xcbiAgICBzY3JvbGxOb2RlLnNjcm9sbEludG9WaWV3KGRvU2Nyb2xsKTtcXG4gICAgY20uZGlzcGxheS5saW5lU3BhY2UucmVtb3ZlQ2hpbGQoc2Nyb2xsTm9kZSk7XFxuICB9XFxufVxcblxcbi8vIFNjcm9sbCBhIGdpdmVuIHBvc2l0aW9uIGludG8gdmlldyAoaW1tZWRpYXRlbHkpLCB2ZXJpZnlpbmcgdGhhdFxcbi8vIGl0IGFjdHVhbGx5IGJlY2FtZSB2aXNpYmxlIChhcyBsaW5lIGhlaWdodHMgYXJlIGFjY3VyYXRlbHlcXG4vLyBtZWFzdXJlZCwgdGhlIHBvc2l0aW9uIG9mIHNvbWV0aGluZyBtYXkgJ2RyaWZ0JyBkdXJpbmcgZHJhd2luZykuXFxuZnVuY3Rpb24gc2Nyb2xsUG9zSW50b1ZpZXcoY20sIHBvcywgZW5kLCBtYXJnaW4pIHtcXG4gIGlmIChtYXJnaW4gPT0gbnVsbCkgeyBtYXJnaW4gPSAwOyB9XFxuICB2YXIgcmVjdDtcXG4gIGZvciAodmFyIGxpbWl0ID0gMDsgbGltaXQgPCA1OyBsaW1pdCsrKSB7XFxuICAgIHZhciBjaGFuZ2VkID0gZmFsc2U7XFxuICAgIHZhciBjb29yZHMgPSBjdXJzb3JDb29yZHMoY20sIHBvcyk7XFxuICAgIHZhciBlbmRDb29yZHMgPSAhZW5kIHx8IGVuZCA9PSBwb3MgPyBjb29yZHMgOiBjdXJzb3JDb29yZHMoY20sIGVuZCk7XFxuICAgIHJlY3QgPSB7bGVmdDogTWF0aC5taW4oY29vcmRzLmxlZnQsIGVuZENvb3Jkcy5sZWZ0KSxcXG4gICAgICAgICAgICB0b3A6IE1hdGgubWluKGNvb3Jkcy50b3AsIGVuZENvb3Jkcy50b3ApIC0gbWFyZ2luLFxcbiAgICAgICAgICAgIHJpZ2h0OiBNYXRoLm1heChjb29yZHMubGVmdCwgZW5kQ29vcmRzLmxlZnQpLFxcbiAgICAgICAgICAgIGJvdHRvbTogTWF0aC5tYXgoY29vcmRzLmJvdHRvbSwgZW5kQ29vcmRzLmJvdHRvbSkgKyBtYXJnaW59O1xcbiAgICB2YXIgc2Nyb2xsUG9zID0gY2FsY3VsYXRlU2Nyb2xsUG9zKGNtLCByZWN0KTtcXG4gICAgdmFyIHN0YXJ0VG9wID0gY20uZG9jLnNjcm9sbFRvcCwgc3RhcnRMZWZ0ID0gY20uZG9jLnNjcm9sbExlZnQ7XFxuICAgIGlmIChzY3JvbGxQb3Muc2Nyb2xsVG9wICE9IG51bGwpIHtcXG4gICAgICBzZXRTY3JvbGxUb3AoY20sIHNjcm9sbFBvcy5zY3JvbGxUb3ApO1xcbiAgICAgIGlmIChNYXRoLmFicyhjbS5kb2Muc2Nyb2xsVG9wIC0gc3RhcnRUb3ApID4gMSkgeyBjaGFuZ2VkID0gdHJ1ZTsgfVxcbiAgICB9XFxuICAgIGlmIChzY3JvbGxQb3Muc2Nyb2xsTGVmdCAhPSBudWxsKSB7XFxuICAgICAgc2V0U2Nyb2xsTGVmdChjbSwgc2Nyb2xsUG9zLnNjcm9sbExlZnQpO1xcbiAgICAgIGlmIChNYXRoLmFicyhjbS5kb2Muc2Nyb2xsTGVmdCAtIHN0YXJ0TGVmdCkgPiAxKSB7IGNoYW5nZWQgPSB0cnVlOyB9XFxuICAgIH1cXG4gICAgaWYgKCFjaGFuZ2VkKSB7IGJyZWFrIH1cXG4gIH1cXG4gIHJldHVybiByZWN0XFxufVxcblxcbi8vIFNjcm9sbCBhIGdpdmVuIHNldCBvZiBjb29yZGluYXRlcyBpbnRvIHZpZXcgKGltbWVkaWF0ZWx5KS5cXG5mdW5jdGlvbiBzY3JvbGxJbnRvVmlldyhjbSwgcmVjdCkge1xcbiAgdmFyIHNjcm9sbFBvcyA9IGNhbGN1bGF0ZVNjcm9sbFBvcyhjbSwgcmVjdCk7XFxuICBpZiAoc2Nyb2xsUG9zLnNjcm9sbFRvcCAhPSBudWxsKSB7IHNldFNjcm9sbFRvcChjbSwgc2Nyb2xsUG9zLnNjcm9sbFRvcCk7IH1cXG4gIGlmIChzY3JvbGxQb3Muc2Nyb2xsTGVmdCAhPSBudWxsKSB7IHNldFNjcm9sbExlZnQoY20sIHNjcm9sbFBvcy5zY3JvbGxMZWZ0KTsgfVxcbn1cXG5cXG4vLyBDYWxjdWxhdGUgYSBuZXcgc2Nyb2xsIHBvc2l0aW9uIG5lZWRlZCB0byBzY3JvbGwgdGhlIGdpdmVuXFxuLy8gcmVjdGFuZ2xlIGludG8gdmlldy4gUmV0dXJucyBhbiBvYmplY3Qgd2l0aCBzY3JvbGxUb3AgYW5kXFxuLy8gc2Nyb2xsTGVmdCBwcm9wZXJ0aWVzLiBXaGVuIHRoZXNlIGFyZSB1bmRlZmluZWQsIHRoZVxcbi8vIHZlcnRpY2FsL2hvcml6b250YWwgcG9zaXRpb24gZG9lcyBub3QgbmVlZCB0byBiZSBhZGp1c3RlZC5cXG5mdW5jdGlvbiBjYWxjdWxhdGVTY3JvbGxQb3MoY20sIHJlY3QpIHtcXG4gIHZhciBkaXNwbGF5ID0gY20uZGlzcGxheSwgc25hcE1hcmdpbiA9IHRleHRIZWlnaHQoY20uZGlzcGxheSk7XFxuICBpZiAocmVjdC50b3AgPCAwKSB7IHJlY3QudG9wID0gMDsgfVxcbiAgdmFyIHNjcmVlbnRvcCA9IGNtLmN1ck9wICYmIGNtLmN1ck9wLnNjcm9sbFRvcCAhPSBudWxsID8gY20uY3VyT3Auc2Nyb2xsVG9wIDogZGlzcGxheS5zY3JvbGxlci5zY3JvbGxUb3A7XFxuICB2YXIgc2NyZWVuID0gZGlzcGxheUhlaWdodChjbSksIHJlc3VsdCA9IHt9O1xcbiAgaWYgKHJlY3QuYm90dG9tIC0gcmVjdC50b3AgPiBzY3JlZW4pIHsgcmVjdC5ib3R0b20gPSByZWN0LnRvcCArIHNjcmVlbjsgfVxcbiAgdmFyIGRvY0JvdHRvbSA9IGNtLmRvYy5oZWlnaHQgKyBwYWRkaW5nVmVydChkaXNwbGF5KTtcXG4gIHZhciBhdFRvcCA9IHJlY3QudG9wIDwgc25hcE1hcmdpbiwgYXRCb3R0b20gPSByZWN0LmJvdHRvbSA+IGRvY0JvdHRvbSAtIHNuYXBNYXJnaW47XFxuICBpZiAocmVjdC50b3AgPCBzY3JlZW50b3ApIHtcXG4gICAgcmVzdWx0LnNjcm9sbFRvcCA9IGF0VG9wID8gMCA6IHJlY3QudG9wO1xcbiAgfSBlbHNlIGlmIChyZWN0LmJvdHRvbSA+IHNjcmVlbnRvcCArIHNjcmVlbikge1xcbiAgICB2YXIgbmV3VG9wID0gTWF0aC5taW4ocmVjdC50b3AsIChhdEJvdHRvbSA/IGRvY0JvdHRvbSA6IHJlY3QuYm90dG9tKSAtIHNjcmVlbik7XFxuICAgIGlmIChuZXdUb3AgIT0gc2NyZWVudG9wKSB7IHJlc3VsdC5zY3JvbGxUb3AgPSBuZXdUb3A7IH1cXG4gIH1cXG5cXG4gIHZhciBzY3JlZW5sZWZ0ID0gY20uY3VyT3AgJiYgY20uY3VyT3Auc2Nyb2xsTGVmdCAhPSBudWxsID8gY20uY3VyT3Auc2Nyb2xsTGVmdCA6IGRpc3BsYXkuc2Nyb2xsZXIuc2Nyb2xsTGVmdDtcXG4gIHZhciBzY3JlZW53ID0gZGlzcGxheVdpZHRoKGNtKSAtIChjbS5vcHRpb25zLmZpeGVkR3V0dGVyID8gZGlzcGxheS5ndXR0ZXJzLm9mZnNldFdpZHRoIDogMCk7XFxuICB2YXIgdG9vV2lkZSA9IHJlY3QucmlnaHQgLSByZWN0LmxlZnQgPiBzY3JlZW53O1xcbiAgaWYgKHRvb1dpZGUpIHsgcmVjdC5yaWdodCA9IHJlY3QubGVmdCArIHNjcmVlbnc7IH1cXG4gIGlmIChyZWN0LmxlZnQgPCAxMClcXG4gICAgeyByZXN1bHQuc2Nyb2xsTGVmdCA9IDA7IH1cXG4gIGVsc2UgaWYgKHJlY3QubGVmdCA8IHNjcmVlbmxlZnQpXFxuICAgIHsgcmVzdWx0LnNjcm9sbExlZnQgPSBNYXRoLm1heCgwLCByZWN0LmxlZnQgLSAodG9vV2lkZSA/IDAgOiAxMCkpOyB9XFxuICBlbHNlIGlmIChyZWN0LnJpZ2h0ID4gc2NyZWVudyArIHNjcmVlbmxlZnQgLSAzKVxcbiAgICB7IHJlc3VsdC5zY3JvbGxMZWZ0ID0gcmVjdC5yaWdodCArICh0b29XaWRlID8gMCA6IDEwKSAtIHNjcmVlbnc7IH1cXG4gIHJldHVybiByZXN1bHRcXG59XFxuXFxuLy8gU3RvcmUgYSByZWxhdGl2ZSBhZGp1c3RtZW50IHRvIHRoZSBzY3JvbGwgcG9zaXRpb24gaW4gdGhlIGN1cnJlbnRcXG4vLyBvcGVyYXRpb24gKHRvIGJlIGFwcGxpZWQgd2hlbiB0aGUgb3BlcmF0aW9uIGZpbmlzaGVzKS5cXG5mdW5jdGlvbiBhZGRUb1Njcm9sbFBvcyhjbSwgbGVmdCwgdG9wKSB7XFxuICBpZiAobGVmdCAhPSBudWxsIHx8IHRvcCAhPSBudWxsKSB7IHJlc29sdmVTY3JvbGxUb1BvcyhjbSk7IH1cXG4gIGlmIChsZWZ0ICE9IG51bGwpXFxuICAgIHsgY20uY3VyT3Auc2Nyb2xsTGVmdCA9IChjbS5jdXJPcC5zY3JvbGxMZWZ0ID09IG51bGwgPyBjbS5kb2Muc2Nyb2xsTGVmdCA6IGNtLmN1ck9wLnNjcm9sbExlZnQpICsgbGVmdDsgfVxcbiAgaWYgKHRvcCAhPSBudWxsKVxcbiAgICB7IGNtLmN1ck9wLnNjcm9sbFRvcCA9IChjbS5jdXJPcC5zY3JvbGxUb3AgPT0gbnVsbCA/IGNtLmRvYy5zY3JvbGxUb3AgOiBjbS5jdXJPcC5zY3JvbGxUb3ApICsgdG9wOyB9XFxufVxcblxcbi8vIE1ha2Ugc3VyZSB0aGF0IGF0IHRoZSBlbmQgb2YgdGhlIG9wZXJhdGlvbiB0aGUgY3VycmVudCBjdXJzb3IgaXNcXG4vLyBzaG93bi5cXG5mdW5jdGlvbiBlbnN1cmVDdXJzb3JWaXNpYmxlKGNtKSB7XFxuICByZXNvbHZlU2Nyb2xsVG9Qb3MoY20pO1xcbiAgdmFyIGN1ciA9IGNtLmdldEN1cnNvcigpLCBmcm9tID0gY3VyLCB0byA9IGN1cjtcXG4gIGlmICghY20ub3B0aW9ucy5saW5lV3JhcHBpbmcpIHtcXG4gICAgZnJvbSA9IGN1ci5jaCA/IFBvcyhjdXIubGluZSwgY3VyLmNoIC0gMSkgOiBjdXI7XFxuICAgIHRvID0gUG9zKGN1ci5saW5lLCBjdXIuY2ggKyAxKTtcXG4gIH1cXG4gIGNtLmN1ck9wLnNjcm9sbFRvUG9zID0ge2Zyb206IGZyb20sIHRvOiB0bywgbWFyZ2luOiBjbS5vcHRpb25zLmN1cnNvclNjcm9sbE1hcmdpbn07XFxufVxcblxcbi8vIFdoZW4gYW4gb3BlcmF0aW9uIGhhcyBpdHMgc2Nyb2xsVG9Qb3MgcHJvcGVydHkgc2V0LCBhbmQgYW5vdGhlclxcbi8vIHNjcm9sbCBhY3Rpb24gaXMgYXBwbGllZCBiZWZvcmUgdGhlIGVuZCBvZiB0aGUgb3BlcmF0aW9uLCB0aGlzXFxuLy8gJ3NpbXVsYXRlcycgc2Nyb2xsaW5nIHRoYXQgcG9zaXRpb24gaW50byB2aWV3IGluIGEgY2hlYXAgd2F5LCBzb1xcbi8vIHRoYXQgdGhlIGVmZmVjdCBvZiBpbnRlcm1lZGlhdGUgc2Nyb2xsIGNvbW1hbmRzIGlzIG5vdCBpZ25vcmVkLlxcbmZ1bmN0aW9uIHJlc29sdmVTY3JvbGxUb1BvcyhjbSkge1xcbiAgdmFyIHJhbmdlJCQxID0gY20uY3VyT3Auc2Nyb2xsVG9Qb3M7XFxuICBpZiAocmFuZ2UkJDEpIHtcXG4gICAgY20uY3VyT3Auc2Nyb2xsVG9Qb3MgPSBudWxsO1xcbiAgICB2YXIgZnJvbSA9IGVzdGltYXRlQ29vcmRzKGNtLCByYW5nZSQkMS5mcm9tKSwgdG8gPSBlc3RpbWF0ZUNvb3JkcyhjbSwgcmFuZ2UkJDEudG8pO1xcbiAgICB2YXIgc1BvcyA9IGNhbGN1bGF0ZVNjcm9sbFBvcyhjbSwge1xcbiAgICAgIGxlZnQ6IE1hdGgubWluKGZyb20ubGVmdCwgdG8ubGVmdCksXFxuICAgICAgdG9wOiBNYXRoLm1pbihmcm9tLnRvcCwgdG8udG9wKSAtIHJhbmdlJCQxLm1hcmdpbixcXG4gICAgICByaWdodDogTWF0aC5tYXgoZnJvbS5yaWdodCwgdG8ucmlnaHQpLFxcbiAgICAgIGJvdHRvbTogTWF0aC5tYXgoZnJvbS5ib3R0b20sIHRvLmJvdHRvbSkgKyByYW5nZSQkMS5tYXJnaW5cXG4gICAgfSk7XFxuICAgIGNtLnNjcm9sbFRvKHNQb3Muc2Nyb2xsTGVmdCwgc1Bvcy5zY3JvbGxUb3ApO1xcbiAgfVxcbn1cXG5cXG4vLyBPcGVyYXRpb25zIGFyZSB1c2VkIHRvIHdyYXAgYSBzZXJpZXMgb2YgY2hhbmdlcyB0byB0aGUgZWRpdG9yXFxuLy8gc3RhdGUgaW4gc3VjaCBhIHdheSB0aGF0IGVhY2ggY2hhbmdlIHdvbid0IGhhdmUgdG8gdXBkYXRlIHRoZVxcbi8vIGN1cnNvciBhbmQgZGlzcGxheSAod2hpY2ggd291bGQgYmUgYXdrd2FyZCwgc2xvdywgYW5kXFxuLy8gZXJyb3ItcHJvbmUpLiBJbnN0ZWFkLCBkaXNwbGF5IHVwZGF0ZXMgYXJlIGJhdGNoZWQgYW5kIHRoZW4gYWxsXFxuLy8gY29tYmluZWQgYW5kIGV4ZWN1dGVkIGF0IG9uY2UuXFxuXFxudmFyIG5leHRPcElkID0gMDtcXG4vLyBTdGFydCBhIG5ldyBvcGVyYXRpb24uXFxuZnVuY3Rpb24gc3RhcnRPcGVyYXRpb24oY20pIHtcXG4gIGNtLmN1ck9wID0ge1xcbiAgICBjbTogY20sXFxuICAgIHZpZXdDaGFuZ2VkOiBmYWxzZSwgICAgICAvLyBGbGFnIHRoYXQgaW5kaWNhdGVzIHRoYXQgbGluZXMgbWlnaHQgbmVlZCB0byBiZSByZWRyYXduXFxuICAgIHN0YXJ0SGVpZ2h0OiBjbS5kb2MuaGVpZ2h0LCAvLyBVc2VkIHRvIGRldGVjdCBuZWVkIHRvIHVwZGF0ZSBzY3JvbGxiYXJcXG4gICAgZm9yY2VVcGRhdGU6IGZhbHNlLCAgICAgIC8vIFVzZWQgdG8gZm9yY2UgYSByZWRyYXdcXG4gICAgdXBkYXRlSW5wdXQ6IG51bGwsICAgICAgIC8vIFdoZXRoZXIgdG8gcmVzZXQgdGhlIGlucHV0IHRleHRhcmVhXFxuICAgIHR5cGluZzogZmFsc2UsICAgICAgICAgICAvLyBXaGV0aGVyIHRoaXMgcmVzZXQgc2hvdWxkIGJlIGNhcmVmdWwgdG8gbGVhdmUgZXhpc3RpbmcgdGV4dCAoZm9yIGNvbXBvc2l0aW5nKVxcbiAgICBjaGFuZ2VPYmpzOiBudWxsLCAgICAgICAgLy8gQWNjdW11bGF0ZWQgY2hhbmdlcywgZm9yIGZpcmluZyBjaGFuZ2UgZXZlbnRzXFxuICAgIGN1cnNvckFjdGl2aXR5SGFuZGxlcnM6IG51bGwsIC8vIFNldCBvZiBoYW5kbGVycyB0byBmaXJlIGN1cnNvckFjdGl2aXR5IG9uXFxuICAgIGN1cnNvckFjdGl2aXR5Q2FsbGVkOiAwLCAvLyBUcmFja3Mgd2hpY2ggY3Vyc29yQWN0aXZpdHkgaGFuZGxlcnMgaGF2ZSBiZWVuIGNhbGxlZCBhbHJlYWR5XFxuICAgIHNlbGVjdGlvbkNoYW5nZWQ6IGZhbHNlLCAvLyBXaGV0aGVyIHRoZSBzZWxlY3Rpb24gbmVlZHMgdG8gYmUgcmVkcmF3blxcbiAgICB1cGRhdGVNYXhMaW5lOiBmYWxzZSwgICAgLy8gU2V0IHdoZW4gdGhlIHdpZGVzdCBsaW5lIG5lZWRzIHRvIGJlIGRldGVybWluZWQgYW5ld1xcbiAgICBzY3JvbGxMZWZ0OiBudWxsLCBzY3JvbGxUb3A6IG51bGwsIC8vIEludGVybWVkaWF0ZSBzY3JvbGwgcG9zaXRpb24sIG5vdCBwdXNoZWQgdG8gRE9NIHlldFxcbiAgICBzY3JvbGxUb1BvczogbnVsbCwgICAgICAgLy8gVXNlZCB0byBzY3JvbGwgdG8gYSBzcGVjaWZpYyBwb3NpdGlvblxcbiAgICBmb2N1czogZmFsc2UsXFxuICAgIGlkOiArK25leHRPcElkICAgICAgICAgICAvLyBVbmlxdWUgSURcXG4gIH07XFxuICBwdXNoT3BlcmF0aW9uKGNtLmN1ck9wKTtcXG59XFxuXFxuLy8gRmluaXNoIGFuIG9wZXJhdGlvbiwgdXBkYXRpbmcgdGhlIGRpc3BsYXkgYW5kIHNpZ25hbGxpbmcgZGVsYXllZCBldmVudHNcXG5mdW5jdGlvbiBlbmRPcGVyYXRpb24oY20pIHtcXG4gIHZhciBvcCA9IGNtLmN1ck9wO1xcbiAgZmluaXNoT3BlcmF0aW9uKG9wLCBmdW5jdGlvbiAoZ3JvdXApIHtcXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBncm91cC5vcHMubGVuZ3RoOyBpKyspXFxuICAgICAgeyBncm91cC5vcHNbaV0uY20uY3VyT3AgPSBudWxsOyB9XFxuICAgIGVuZE9wZXJhdGlvbnMoZ3JvdXApO1xcbiAgfSk7XFxufVxcblxcbi8vIFRoZSBET00gdXBkYXRlcyBkb25lIHdoZW4gYW4gb3BlcmF0aW9uIGZpbmlzaGVzIGFyZSBiYXRjaGVkIHNvXFxuLy8gdGhhdCB0aGUgbWluaW11bSBudW1iZXIgb2YgcmVsYXlvdXRzIGFyZSByZXF1aXJlZC5cXG5mdW5jdGlvbiBlbmRPcGVyYXRpb25zKGdyb3VwKSB7XFxuICB2YXIgb3BzID0gZ3JvdXAub3BzO1xcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcHMubGVuZ3RoOyBpKyspIC8vIFJlYWQgRE9NXFxuICAgIHsgZW5kT3BlcmF0aW9uX1IxKG9wc1tpXSk7IH1cXG4gIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IG9wcy5sZW5ndGg7IGkkMSsrKSAvLyBXcml0ZSBET00gKG1heWJlKVxcbiAgICB7IGVuZE9wZXJhdGlvbl9XMShvcHNbaSQxXSk7IH1cXG4gIGZvciAodmFyIGkkMiA9IDA7IGkkMiA8IG9wcy5sZW5ndGg7IGkkMisrKSAvLyBSZWFkIERPTVxcbiAgICB7IGVuZE9wZXJhdGlvbl9SMihvcHNbaSQyXSk7IH1cXG4gIGZvciAodmFyIGkkMyA9IDA7IGkkMyA8IG9wcy5sZW5ndGg7IGkkMysrKSAvLyBXcml0ZSBET00gKG1heWJlKVxcbiAgICB7IGVuZE9wZXJhdGlvbl9XMihvcHNbaSQzXSk7IH1cXG4gIGZvciAodmFyIGkkNCA9IDA7IGkkNCA8IG9wcy5sZW5ndGg7IGkkNCsrKSAvLyBSZWFkIERPTVxcbiAgICB7IGVuZE9wZXJhdGlvbl9maW5pc2gob3BzW2kkNF0pOyB9XFxufVxcblxcbmZ1bmN0aW9uIGVuZE9wZXJhdGlvbl9SMShvcCkge1xcbiAgdmFyIGNtID0gb3AuY20sIGRpc3BsYXkgPSBjbS5kaXNwbGF5O1xcbiAgbWF5YmVDbGlwU2Nyb2xsYmFycyhjbSk7XFxuICBpZiAob3AudXBkYXRlTWF4TGluZSkgeyBmaW5kTWF4TGluZShjbSk7IH1cXG5cXG4gIG9wLm11c3RVcGRhdGUgPSBvcC52aWV3Q2hhbmdlZCB8fCBvcC5mb3JjZVVwZGF0ZSB8fCBvcC5zY3JvbGxUb3AgIT0gbnVsbCB8fFxcbiAgICBvcC5zY3JvbGxUb1BvcyAmJiAob3Auc2Nyb2xsVG9Qb3MuZnJvbS5saW5lIDwgZGlzcGxheS52aWV3RnJvbSB8fFxcbiAgICAgICAgICAgICAgICAgICAgICAgb3Auc2Nyb2xsVG9Qb3MudG8ubGluZSA+PSBkaXNwbGF5LnZpZXdUbykgfHxcXG4gICAgZGlzcGxheS5tYXhMaW5lQ2hhbmdlZCAmJiBjbS5vcHRpb25zLmxpbmVXcmFwcGluZztcXG4gIG9wLnVwZGF0ZSA9IG9wLm11c3RVcGRhdGUgJiZcXG4gICAgbmV3IERpc3BsYXlVcGRhdGUoY20sIG9wLm11c3RVcGRhdGUgJiYge3RvcDogb3Auc2Nyb2xsVG9wLCBlbnN1cmU6IG9wLnNjcm9sbFRvUG9zfSwgb3AuZm9yY2VVcGRhdGUpO1xcbn1cXG5cXG5mdW5jdGlvbiBlbmRPcGVyYXRpb25fVzEob3ApIHtcXG4gIG9wLnVwZGF0ZWREaXNwbGF5ID0gb3AubXVzdFVwZGF0ZSAmJiB1cGRhdGVEaXNwbGF5SWZOZWVkZWQob3AuY20sIG9wLnVwZGF0ZSk7XFxufVxcblxcbmZ1bmN0aW9uIGVuZE9wZXJhdGlvbl9SMihvcCkge1xcbiAgdmFyIGNtID0gb3AuY20sIGRpc3BsYXkgPSBjbS5kaXNwbGF5O1xcbiAgaWYgKG9wLnVwZGF0ZWREaXNwbGF5KSB7IHVwZGF0ZUhlaWdodHNJblZpZXdwb3J0KGNtKTsgfVxcblxcbiAgb3AuYmFyTWVhc3VyZSA9IG1lYXN1cmVGb3JTY3JvbGxiYXJzKGNtKTtcXG5cXG4gIC8vIElmIHRoZSBtYXggbGluZSBjaGFuZ2VkIHNpbmNlIGl0IHdhcyBsYXN0IG1lYXN1cmVkLCBtZWFzdXJlIGl0LFxcbiAgLy8gYW5kIGVuc3VyZSB0aGUgZG9jdW1lbnQncyB3aWR0aCBtYXRjaGVzIGl0LlxcbiAgLy8gdXBkYXRlRGlzcGxheV9XMiB3aWxsIHVzZSB0aGVzZSBwcm9wZXJ0aWVzIHRvIGRvIHRoZSBhY3R1YWwgcmVzaXppbmdcXG4gIGlmIChkaXNwbGF5Lm1heExpbmVDaGFuZ2VkICYmICFjbS5vcHRpb25zLmxpbmVXcmFwcGluZykge1xcbiAgICBvcC5hZGp1c3RXaWR0aFRvID0gbWVhc3VyZUNoYXIoY20sIGRpc3BsYXkubWF4TGluZSwgZGlzcGxheS5tYXhMaW5lLnRleHQubGVuZ3RoKS5sZWZ0ICsgMztcXG4gICAgY20uZGlzcGxheS5zaXplcldpZHRoID0gb3AuYWRqdXN0V2lkdGhUbztcXG4gICAgb3AuYmFyTWVhc3VyZS5zY3JvbGxXaWR0aCA9XFxuICAgICAgTWF0aC5tYXgoZGlzcGxheS5zY3JvbGxlci5jbGllbnRXaWR0aCwgZGlzcGxheS5zaXplci5vZmZzZXRMZWZ0ICsgb3AuYWRqdXN0V2lkdGhUbyArIHNjcm9sbEdhcChjbSkgKyBjbS5kaXNwbGF5LmJhcldpZHRoKTtcXG4gICAgb3AubWF4U2Nyb2xsTGVmdCA9IE1hdGgubWF4KDAsIGRpc3BsYXkuc2l6ZXIub2Zmc2V0TGVmdCArIG9wLmFkanVzdFdpZHRoVG8gLSBkaXNwbGF5V2lkdGgoY20pKTtcXG4gIH1cXG5cXG4gIGlmIChvcC51cGRhdGVkRGlzcGxheSB8fCBvcC5zZWxlY3Rpb25DaGFuZ2VkKVxcbiAgICB7IG9wLnByZXBhcmVkU2VsZWN0aW9uID0gZGlzcGxheS5pbnB1dC5wcmVwYXJlU2VsZWN0aW9uKG9wLmZvY3VzKTsgfVxcbn1cXG5cXG5mdW5jdGlvbiBlbmRPcGVyYXRpb25fVzIob3ApIHtcXG4gIHZhciBjbSA9IG9wLmNtO1xcblxcbiAgaWYgKG9wLmFkanVzdFdpZHRoVG8gIT0gbnVsbCkge1xcbiAgICBjbS5kaXNwbGF5LnNpemVyLnN0eWxlLm1pbldpZHRoID0gb3AuYWRqdXN0V2lkdGhUbyArIFxcXCJweFxcXCI7XFxuICAgIGlmIChvcC5tYXhTY3JvbGxMZWZ0IDwgY20uZG9jLnNjcm9sbExlZnQpXFxuICAgICAgeyBzZXRTY3JvbGxMZWZ0KGNtLCBNYXRoLm1pbihjbS5kaXNwbGF5LnNjcm9sbGVyLnNjcm9sbExlZnQsIG9wLm1heFNjcm9sbExlZnQpLCB0cnVlKTsgfVxcbiAgICBjbS5kaXNwbGF5Lm1heExpbmVDaGFuZ2VkID0gZmFsc2U7XFxuICB9XFxuXFxuICB2YXIgdGFrZUZvY3VzID0gb3AuZm9jdXMgJiYgb3AuZm9jdXMgPT0gYWN0aXZlRWx0KCkgJiYgKCFkb2N1bWVudC5oYXNGb2N1cyB8fCBkb2N1bWVudC5oYXNGb2N1cygpKTtcXG4gIGlmIChvcC5wcmVwYXJlZFNlbGVjdGlvbilcXG4gICAgeyBjbS5kaXNwbGF5LmlucHV0LnNob3dTZWxlY3Rpb24ob3AucHJlcGFyZWRTZWxlY3Rpb24sIHRha2VGb2N1cyk7IH1cXG4gIGlmIChvcC51cGRhdGVkRGlzcGxheSB8fCBvcC5zdGFydEhlaWdodCAhPSBjbS5kb2MuaGVpZ2h0KVxcbiAgICB7IHVwZGF0ZVNjcm9sbGJhcnMoY20sIG9wLmJhck1lYXN1cmUpOyB9XFxuICBpZiAob3AudXBkYXRlZERpc3BsYXkpXFxuICAgIHsgc2V0RG9jdW1lbnRIZWlnaHQoY20sIG9wLmJhck1lYXN1cmUpOyB9XFxuXFxuICBpZiAob3Auc2VsZWN0aW9uQ2hhbmdlZCkgeyByZXN0YXJ0QmxpbmsoY20pOyB9XFxuXFxuICBpZiAoY20uc3RhdGUuZm9jdXNlZCAmJiBvcC51cGRhdGVJbnB1dClcXG4gICAgeyBjbS5kaXNwbGF5LmlucHV0LnJlc2V0KG9wLnR5cGluZyk7IH1cXG4gIGlmICh0YWtlRm9jdXMpIHsgZW5zdXJlRm9jdXMob3AuY20pOyB9XFxufVxcblxcbmZ1bmN0aW9uIGVuZE9wZXJhdGlvbl9maW5pc2gob3ApIHtcXG4gIHZhciBjbSA9IG9wLmNtLCBkaXNwbGF5ID0gY20uZGlzcGxheSwgZG9jID0gY20uZG9jO1xcblxcbiAgaWYgKG9wLnVwZGF0ZWREaXNwbGF5KSB7IHBvc3RVcGRhdGVEaXNwbGF5KGNtLCBvcC51cGRhdGUpOyB9XFxuXFxuICAvLyBBYm9ydCBtb3VzZSB3aGVlbCBkZWx0YSBtZWFzdXJlbWVudCwgd2hlbiBzY3JvbGxpbmcgZXhwbGljaXRseVxcbiAgaWYgKGRpc3BsYXkud2hlZWxTdGFydFggIT0gbnVsbCAmJiAob3Auc2Nyb2xsVG9wICE9IG51bGwgfHwgb3Auc2Nyb2xsTGVmdCAhPSBudWxsIHx8IG9wLnNjcm9sbFRvUG9zKSlcXG4gICAgeyBkaXNwbGF5LndoZWVsU3RhcnRYID0gZGlzcGxheS53aGVlbFN0YXJ0WSA9IG51bGw7IH1cXG5cXG4gIC8vIFByb3BhZ2F0ZSB0aGUgc2Nyb2xsIHBvc2l0aW9uIHRvIHRoZSBhY3R1YWwgRE9NIHNjcm9sbGVyXFxuICBpZiAob3Auc2Nyb2xsVG9wICE9IG51bGwgJiYgKGRpc3BsYXkuc2Nyb2xsZXIuc2Nyb2xsVG9wICE9IG9wLnNjcm9sbFRvcCB8fCBvcC5mb3JjZVNjcm9sbCkpIHtcXG4gICAgZG9jLnNjcm9sbFRvcCA9IE1hdGgubWF4KDAsIE1hdGgubWluKGRpc3BsYXkuc2Nyb2xsZXIuc2Nyb2xsSGVpZ2h0IC0gZGlzcGxheS5zY3JvbGxlci5jbGllbnRIZWlnaHQsIG9wLnNjcm9sbFRvcCkpO1xcbiAgICBkaXNwbGF5LnNjcm9sbGJhcnMuc2V0U2Nyb2xsVG9wKGRvYy5zY3JvbGxUb3ApO1xcbiAgICBkaXNwbGF5LnNjcm9sbGVyLnNjcm9sbFRvcCA9IGRvYy5zY3JvbGxUb3A7XFxuICB9XFxuICBpZiAob3Auc2Nyb2xsTGVmdCAhPSBudWxsICYmIChkaXNwbGF5LnNjcm9sbGVyLnNjcm9sbExlZnQgIT0gb3Auc2Nyb2xsTGVmdCB8fCBvcC5mb3JjZVNjcm9sbCkpIHtcXG4gICAgZG9jLnNjcm9sbExlZnQgPSBNYXRoLm1heCgwLCBNYXRoLm1pbihkaXNwbGF5LnNjcm9sbGVyLnNjcm9sbFdpZHRoIC0gZGlzcGxheS5zY3JvbGxlci5jbGllbnRXaWR0aCwgb3Auc2Nyb2xsTGVmdCkpO1xcbiAgICBkaXNwbGF5LnNjcm9sbGJhcnMuc2V0U2Nyb2xsTGVmdChkb2Muc2Nyb2xsTGVmdCk7XFxuICAgIGRpc3BsYXkuc2Nyb2xsZXIuc2Nyb2xsTGVmdCA9IGRvYy5zY3JvbGxMZWZ0O1xcbiAgICBhbGlnbkhvcml6b250YWxseShjbSk7XFxuICB9XFxuICAvLyBJZiB3ZSBuZWVkIHRvIHNjcm9sbCBhIHNwZWNpZmljIHBvc2l0aW9uIGludG8gdmlldywgZG8gc28uXFxuICBpZiAob3Auc2Nyb2xsVG9Qb3MpIHtcXG4gICAgdmFyIHJlY3QgPSBzY3JvbGxQb3NJbnRvVmlldyhjbSwgY2xpcFBvcyhkb2MsIG9wLnNjcm9sbFRvUG9zLmZyb20pLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsaXBQb3MoZG9jLCBvcC5zY3JvbGxUb1Bvcy50byksIG9wLnNjcm9sbFRvUG9zLm1hcmdpbik7XFxuICAgIG1heWJlU2Nyb2xsV2luZG93KGNtLCByZWN0KTtcXG4gIH1cXG5cXG4gIC8vIEZpcmUgZXZlbnRzIGZvciBtYXJrZXJzIHRoYXQgYXJlIGhpZGRlbi91bmlkZGVuIGJ5IGVkaXRpbmcgb3JcXG4gIC8vIHVuZG9pbmdcXG4gIHZhciBoaWRkZW4gPSBvcC5tYXliZUhpZGRlbk1hcmtlcnMsIHVuaGlkZGVuID0gb3AubWF5YmVVbmhpZGRlbk1hcmtlcnM7XFxuICBpZiAoaGlkZGVuKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgaGlkZGVuLmxlbmd0aDsgKytpKVxcbiAgICB7IGlmICghaGlkZGVuW2ldLmxpbmVzLmxlbmd0aCkgeyBzaWduYWwoaGlkZGVuW2ldLCBcXFwiaGlkZVxcXCIpOyB9IH0gfVxcbiAgaWYgKHVuaGlkZGVuKSB7IGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IHVuaGlkZGVuLmxlbmd0aDsgKytpJDEpXFxuICAgIHsgaWYgKHVuaGlkZGVuW2kkMV0ubGluZXMubGVuZ3RoKSB7IHNpZ25hbCh1bmhpZGRlbltpJDFdLCBcXFwidW5oaWRlXFxcIik7IH0gfSB9XFxuXFxuICBpZiAoZGlzcGxheS53cmFwcGVyLm9mZnNldEhlaWdodClcXG4gICAgeyBkb2Muc2Nyb2xsVG9wID0gY20uZGlzcGxheS5zY3JvbGxlci5zY3JvbGxUb3A7IH1cXG5cXG4gIC8vIEZpcmUgY2hhbmdlIGV2ZW50cywgYW5kIGRlbGF5ZWQgZXZlbnQgaGFuZGxlcnNcXG4gIGlmIChvcC5jaGFuZ2VPYmpzKVxcbiAgICB7IHNpZ25hbChjbSwgXFxcImNoYW5nZXNcXFwiLCBjbSwgb3AuY2hhbmdlT2Jqcyk7IH1cXG4gIGlmIChvcC51cGRhdGUpXFxuICAgIHsgb3AudXBkYXRlLmZpbmlzaCgpOyB9XFxufVxcblxcbi8vIFJ1biB0aGUgZ2l2ZW4gZnVuY3Rpb24gaW4gYW4gb3BlcmF0aW9uXFxuZnVuY3Rpb24gcnVuSW5PcChjbSwgZikge1xcbiAgaWYgKGNtLmN1ck9wKSB7IHJldHVybiBmKCkgfVxcbiAgc3RhcnRPcGVyYXRpb24oY20pO1xcbiAgdHJ5IHsgcmV0dXJuIGYoKSB9XFxuICBmaW5hbGx5IHsgZW5kT3BlcmF0aW9uKGNtKTsgfVxcbn1cXG4vLyBXcmFwcyBhIGZ1bmN0aW9uIGluIGFuIG9wZXJhdGlvbi4gUmV0dXJucyB0aGUgd3JhcHBlZCBmdW5jdGlvbi5cXG5mdW5jdGlvbiBvcGVyYXRpb24oY20sIGYpIHtcXG4gIHJldHVybiBmdW5jdGlvbigpIHtcXG4gICAgaWYgKGNtLmN1ck9wKSB7IHJldHVybiBmLmFwcGx5KGNtLCBhcmd1bWVudHMpIH1cXG4gICAgc3RhcnRPcGVyYXRpb24oY20pO1xcbiAgICB0cnkgeyByZXR1cm4gZi5hcHBseShjbSwgYXJndW1lbnRzKSB9XFxuICAgIGZpbmFsbHkgeyBlbmRPcGVyYXRpb24oY20pOyB9XFxuICB9XFxufVxcbi8vIFVzZWQgdG8gYWRkIG1ldGhvZHMgdG8gZWRpdG9yIGFuZCBkb2MgaW5zdGFuY2VzLCB3cmFwcGluZyB0aGVtIGluXFxuLy8gb3BlcmF0aW9ucy5cXG5mdW5jdGlvbiBtZXRob2RPcChmKSB7XFxuICByZXR1cm4gZnVuY3Rpb24oKSB7XFxuICAgIGlmICh0aGlzLmN1ck9wKSB7IHJldHVybiBmLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfVxcbiAgICBzdGFydE9wZXJhdGlvbih0aGlzKTtcXG4gICAgdHJ5IHsgcmV0dXJuIGYuYXBwbHkodGhpcywgYXJndW1lbnRzKSB9XFxuICAgIGZpbmFsbHkgeyBlbmRPcGVyYXRpb24odGhpcyk7IH1cXG4gIH1cXG59XFxuZnVuY3Rpb24gZG9jTWV0aG9kT3AoZikge1xcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xcbiAgICB2YXIgY20gPSB0aGlzLmNtO1xcbiAgICBpZiAoIWNtIHx8IGNtLmN1ck9wKSB7IHJldHVybiBmLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfVxcbiAgICBzdGFydE9wZXJhdGlvbihjbSk7XFxuICAgIHRyeSB7IHJldHVybiBmLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfVxcbiAgICBmaW5hbGx5IHsgZW5kT3BlcmF0aW9uKGNtKTsgfVxcbiAgfVxcbn1cXG5cXG4vLyBVcGRhdGVzIHRoZSBkaXNwbGF5LnZpZXcgZGF0YSBzdHJ1Y3R1cmUgZm9yIGEgZ2l2ZW4gY2hhbmdlIHRvIHRoZVxcbi8vIGRvY3VtZW50LiBGcm9tIGFuZCB0byBhcmUgaW4gcHJlLWNoYW5nZSBjb29yZGluYXRlcy4gTGVuZGlmZiBpc1xcbi8vIHRoZSBhbW91bnQgb2YgbGluZXMgYWRkZWQgb3Igc3VidHJhY3RlZCBieSB0aGUgY2hhbmdlLiBUaGlzIGlzXFxuLy8gdXNlZCBmb3IgY2hhbmdlcyB0aGF0IHNwYW4gbXVsdGlwbGUgbGluZXMsIG9yIGNoYW5nZSB0aGUgd2F5XFxuLy8gbGluZXMgYXJlIGRpdmlkZWQgaW50byB2aXN1YWwgbGluZXMuIHJlZ0xpbmVDaGFuZ2UgKGJlbG93KVxcbi8vIHJlZ2lzdGVycyBzaW5nbGUtbGluZSBjaGFuZ2VzLlxcbmZ1bmN0aW9uIHJlZ0NoYW5nZShjbSwgZnJvbSwgdG8sIGxlbmRpZmYpIHtcXG4gIGlmIChmcm9tID09IG51bGwpIHsgZnJvbSA9IGNtLmRvYy5maXJzdDsgfVxcbiAgaWYgKHRvID09IG51bGwpIHsgdG8gPSBjbS5kb2MuZmlyc3QgKyBjbS5kb2Muc2l6ZTsgfVxcbiAgaWYgKCFsZW5kaWZmKSB7IGxlbmRpZmYgPSAwOyB9XFxuXFxuICB2YXIgZGlzcGxheSA9IGNtLmRpc3BsYXk7XFxuICBpZiAobGVuZGlmZiAmJiB0byA8IGRpc3BsYXkudmlld1RvICYmXFxuICAgICAgKGRpc3BsYXkudXBkYXRlTGluZU51bWJlcnMgPT0gbnVsbCB8fCBkaXNwbGF5LnVwZGF0ZUxpbmVOdW1iZXJzID4gZnJvbSkpXFxuICAgIHsgZGlzcGxheS51cGRhdGVMaW5lTnVtYmVycyA9IGZyb207IH1cXG5cXG4gIGNtLmN1ck9wLnZpZXdDaGFuZ2VkID0gdHJ1ZTtcXG5cXG4gIGlmIChmcm9tID49IGRpc3BsYXkudmlld1RvKSB7IC8vIENoYW5nZSBhZnRlclxcbiAgICBpZiAoc2F3Q29sbGFwc2VkU3BhbnMgJiYgdmlzdWFsTGluZU5vKGNtLmRvYywgZnJvbSkgPCBkaXNwbGF5LnZpZXdUbylcXG4gICAgICB7IHJlc2V0VmlldyhjbSk7IH1cXG4gIH0gZWxzZSBpZiAodG8gPD0gZGlzcGxheS52aWV3RnJvbSkgeyAvLyBDaGFuZ2UgYmVmb3JlXFxuICAgIGlmIChzYXdDb2xsYXBzZWRTcGFucyAmJiB2aXN1YWxMaW5lRW5kTm8oY20uZG9jLCB0byArIGxlbmRpZmYpID4gZGlzcGxheS52aWV3RnJvbSkge1xcbiAgICAgIHJlc2V0VmlldyhjbSk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgZGlzcGxheS52aWV3RnJvbSArPSBsZW5kaWZmO1xcbiAgICAgIGRpc3BsYXkudmlld1RvICs9IGxlbmRpZmY7XFxuICAgIH1cXG4gIH0gZWxzZSBpZiAoZnJvbSA8PSBkaXNwbGF5LnZpZXdGcm9tICYmIHRvID49IGRpc3BsYXkudmlld1RvKSB7IC8vIEZ1bGwgb3ZlcmxhcFxcbiAgICByZXNldFZpZXcoY20pO1xcbiAgfSBlbHNlIGlmIChmcm9tIDw9IGRpc3BsYXkudmlld0Zyb20pIHsgLy8gVG9wIG92ZXJsYXBcXG4gICAgdmFyIGN1dCA9IHZpZXdDdXR0aW5nUG9pbnQoY20sIHRvLCB0byArIGxlbmRpZmYsIDEpO1xcbiAgICBpZiAoY3V0KSB7XFxuICAgICAgZGlzcGxheS52aWV3ID0gZGlzcGxheS52aWV3LnNsaWNlKGN1dC5pbmRleCk7XFxuICAgICAgZGlzcGxheS52aWV3RnJvbSA9IGN1dC5saW5lTjtcXG4gICAgICBkaXNwbGF5LnZpZXdUbyArPSBsZW5kaWZmO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIHJlc2V0VmlldyhjbSk7XFxuICAgIH1cXG4gIH0gZWxzZSBpZiAodG8gPj0gZGlzcGxheS52aWV3VG8pIHsgLy8gQm90dG9tIG92ZXJsYXBcXG4gICAgdmFyIGN1dCQxID0gdmlld0N1dHRpbmdQb2ludChjbSwgZnJvbSwgZnJvbSwgLTEpO1xcbiAgICBpZiAoY3V0JDEpIHtcXG4gICAgICBkaXNwbGF5LnZpZXcgPSBkaXNwbGF5LnZpZXcuc2xpY2UoMCwgY3V0JDEuaW5kZXgpO1xcbiAgICAgIGRpc3BsYXkudmlld1RvID0gY3V0JDEubGluZU47XFxuICAgIH0gZWxzZSB7XFxuICAgICAgcmVzZXRWaWV3KGNtKTtcXG4gICAgfVxcbiAgfSBlbHNlIHsgLy8gR2FwIGluIHRoZSBtaWRkbGVcXG4gICAgdmFyIGN1dFRvcCA9IHZpZXdDdXR0aW5nUG9pbnQoY20sIGZyb20sIGZyb20sIC0xKTtcXG4gICAgdmFyIGN1dEJvdCA9IHZpZXdDdXR0aW5nUG9pbnQoY20sIHRvLCB0byArIGxlbmRpZmYsIDEpO1xcbiAgICBpZiAoY3V0VG9wICYmIGN1dEJvdCkge1xcbiAgICAgIGRpc3BsYXkudmlldyA9IGRpc3BsYXkudmlldy5zbGljZSgwLCBjdXRUb3AuaW5kZXgpXFxuICAgICAgICAuY29uY2F0KGJ1aWxkVmlld0FycmF5KGNtLCBjdXRUb3AubGluZU4sIGN1dEJvdC5saW5lTikpXFxuICAgICAgICAuY29uY2F0KGRpc3BsYXkudmlldy5zbGljZShjdXRCb3QuaW5kZXgpKTtcXG4gICAgICBkaXNwbGF5LnZpZXdUbyArPSBsZW5kaWZmO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIHJlc2V0VmlldyhjbSk7XFxuICAgIH1cXG4gIH1cXG5cXG4gIHZhciBleHQgPSBkaXNwbGF5LmV4dGVybmFsTWVhc3VyZWQ7XFxuICBpZiAoZXh0KSB7XFxuICAgIGlmICh0byA8IGV4dC5saW5lTilcXG4gICAgICB7IGV4dC5saW5lTiArPSBsZW5kaWZmOyB9XFxuICAgIGVsc2UgaWYgKGZyb20gPCBleHQubGluZU4gKyBleHQuc2l6ZSlcXG4gICAgICB7IGRpc3BsYXkuZXh0ZXJuYWxNZWFzdXJlZCA9IG51bGw7IH1cXG4gIH1cXG59XFxuXFxuLy8gUmVnaXN0ZXIgYSBjaGFuZ2UgdG8gYSBzaW5nbGUgbGluZS4gVHlwZSBtdXN0IGJlIG9uZSBvZiBcXFwidGV4dFxcXCIsXFxuLy8gXFxcImd1dHRlclxcXCIsIFxcXCJjbGFzc1xcXCIsIFxcXCJ3aWRnZXRcXFwiXFxuZnVuY3Rpb24gcmVnTGluZUNoYW5nZShjbSwgbGluZSwgdHlwZSkge1xcbiAgY20uY3VyT3Audmlld0NoYW5nZWQgPSB0cnVlO1xcbiAgdmFyIGRpc3BsYXkgPSBjbS5kaXNwbGF5LCBleHQgPSBjbS5kaXNwbGF5LmV4dGVybmFsTWVhc3VyZWQ7XFxuICBpZiAoZXh0ICYmIGxpbmUgPj0gZXh0LmxpbmVOICYmIGxpbmUgPCBleHQubGluZU4gKyBleHQuc2l6ZSlcXG4gICAgeyBkaXNwbGF5LmV4dGVybmFsTWVhc3VyZWQgPSBudWxsOyB9XFxuXFxuICBpZiAobGluZSA8IGRpc3BsYXkudmlld0Zyb20gfHwgbGluZSA+PSBkaXNwbGF5LnZpZXdUbykgeyByZXR1cm4gfVxcbiAgdmFyIGxpbmVWaWV3ID0gZGlzcGxheS52aWV3W2ZpbmRWaWV3SW5kZXgoY20sIGxpbmUpXTtcXG4gIGlmIChsaW5lVmlldy5ub2RlID09IG51bGwpIHsgcmV0dXJuIH1cXG4gIHZhciBhcnIgPSBsaW5lVmlldy5jaGFuZ2VzIHx8IChsaW5lVmlldy5jaGFuZ2VzID0gW10pO1xcbiAgaWYgKGluZGV4T2YoYXJyLCB0eXBlKSA9PSAtMSkgeyBhcnIucHVzaCh0eXBlKTsgfVxcbn1cXG5cXG4vLyBDbGVhciB0aGUgdmlldy5cXG5mdW5jdGlvbiByZXNldFZpZXcoY20pIHtcXG4gIGNtLmRpc3BsYXkudmlld0Zyb20gPSBjbS5kaXNwbGF5LnZpZXdUbyA9IGNtLmRvYy5maXJzdDtcXG4gIGNtLmRpc3BsYXkudmlldyA9IFtdO1xcbiAgY20uZGlzcGxheS52aWV3T2Zmc2V0ID0gMDtcXG59XFxuXFxuZnVuY3Rpb24gdmlld0N1dHRpbmdQb2ludChjbSwgb2xkTiwgbmV3TiwgZGlyKSB7XFxuICB2YXIgaW5kZXggPSBmaW5kVmlld0luZGV4KGNtLCBvbGROKSwgZGlmZiwgdmlldyA9IGNtLmRpc3BsYXkudmlldztcXG4gIGlmICghc2F3Q29sbGFwc2VkU3BhbnMgfHwgbmV3TiA9PSBjbS5kb2MuZmlyc3QgKyBjbS5kb2Muc2l6ZSlcXG4gICAgeyByZXR1cm4ge2luZGV4OiBpbmRleCwgbGluZU46IG5ld059IH1cXG4gIHZhciBuID0gY20uZGlzcGxheS52aWV3RnJvbTtcXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgaW5kZXg7IGkrKylcXG4gICAgeyBuICs9IHZpZXdbaV0uc2l6ZTsgfVxcbiAgaWYgKG4gIT0gb2xkTikge1xcbiAgICBpZiAoZGlyID4gMCkge1xcbiAgICAgIGlmIChpbmRleCA9PSB2aWV3Lmxlbmd0aCAtIDEpIHsgcmV0dXJuIG51bGwgfVxcbiAgICAgIGRpZmYgPSAobiArIHZpZXdbaW5kZXhdLnNpemUpIC0gb2xkTjtcXG4gICAgICBpbmRleCsrO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIGRpZmYgPSBuIC0gb2xkTjtcXG4gICAgfVxcbiAgICBvbGROICs9IGRpZmY7IG5ld04gKz0gZGlmZjtcXG4gIH1cXG4gIHdoaWxlICh2aXN1YWxMaW5lTm8oY20uZG9jLCBuZXdOKSAhPSBuZXdOKSB7XFxuICAgIGlmIChpbmRleCA9PSAoZGlyIDwgMCA/IDAgOiB2aWV3Lmxlbmd0aCAtIDEpKSB7IHJldHVybiBudWxsIH1cXG4gICAgbmV3TiArPSBkaXIgKiB2aWV3W2luZGV4IC0gKGRpciA8IDAgPyAxIDogMCldLnNpemU7XFxuICAgIGluZGV4ICs9IGRpcjtcXG4gIH1cXG4gIHJldHVybiB7aW5kZXg6IGluZGV4LCBsaW5lTjogbmV3Tn1cXG59XFxuXFxuLy8gRm9yY2UgdGhlIHZpZXcgdG8gY292ZXIgYSBnaXZlbiByYW5nZSwgYWRkaW5nIGVtcHR5IHZpZXcgZWxlbWVudFxcbi8vIG9yIGNsaXBwaW5nIG9mZiBleGlzdGluZyBvbmVzIGFzIG5lZWRlZC5cXG5mdW5jdGlvbiBhZGp1c3RWaWV3KGNtLCBmcm9tLCB0bykge1xcbiAgdmFyIGRpc3BsYXkgPSBjbS5kaXNwbGF5LCB2aWV3ID0gZGlzcGxheS52aWV3O1xcbiAgaWYgKHZpZXcubGVuZ3RoID09IDAgfHwgZnJvbSA+PSBkaXNwbGF5LnZpZXdUbyB8fCB0byA8PSBkaXNwbGF5LnZpZXdGcm9tKSB7XFxuICAgIGRpc3BsYXkudmlldyA9IGJ1aWxkVmlld0FycmF5KGNtLCBmcm9tLCB0byk7XFxuICAgIGRpc3BsYXkudmlld0Zyb20gPSBmcm9tO1xcbiAgfSBlbHNlIHtcXG4gICAgaWYgKGRpc3BsYXkudmlld0Zyb20gPiBmcm9tKVxcbiAgICAgIHsgZGlzcGxheS52aWV3ID0gYnVpbGRWaWV3QXJyYXkoY20sIGZyb20sIGRpc3BsYXkudmlld0Zyb20pLmNvbmNhdChkaXNwbGF5LnZpZXcpOyB9XFxuICAgIGVsc2UgaWYgKGRpc3BsYXkudmlld0Zyb20gPCBmcm9tKVxcbiAgICAgIHsgZGlzcGxheS52aWV3ID0gZGlzcGxheS52aWV3LnNsaWNlKGZpbmRWaWV3SW5kZXgoY20sIGZyb20pKTsgfVxcbiAgICBkaXNwbGF5LnZpZXdGcm9tID0gZnJvbTtcXG4gICAgaWYgKGRpc3BsYXkudmlld1RvIDwgdG8pXFxuICAgICAgeyBkaXNwbGF5LnZpZXcgPSBkaXNwbGF5LnZpZXcuY29uY2F0KGJ1aWxkVmlld0FycmF5KGNtLCBkaXNwbGF5LnZpZXdUbywgdG8pKTsgfVxcbiAgICBlbHNlIGlmIChkaXNwbGF5LnZpZXdUbyA+IHRvKVxcbiAgICAgIHsgZGlzcGxheS52aWV3ID0gZGlzcGxheS52aWV3LnNsaWNlKDAsIGZpbmRWaWV3SW5kZXgoY20sIHRvKSk7IH1cXG4gIH1cXG4gIGRpc3BsYXkudmlld1RvID0gdG87XFxufVxcblxcbi8vIENvdW50IHRoZSBudW1iZXIgb2YgbGluZXMgaW4gdGhlIHZpZXcgd2hvc2UgRE9NIHJlcHJlc2VudGF0aW9uIGlzXFxuLy8gb3V0IG9mIGRhdGUgKG9yIG5vbmV4aXN0ZW50KS5cXG5mdW5jdGlvbiBjb3VudERpcnR5VmlldyhjbSkge1xcbiAgdmFyIHZpZXcgPSBjbS5kaXNwbGF5LnZpZXcsIGRpcnR5ID0gMDtcXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdmlldy5sZW5ndGg7IGkrKykge1xcbiAgICB2YXIgbGluZVZpZXcgPSB2aWV3W2ldO1xcbiAgICBpZiAoIWxpbmVWaWV3LmhpZGRlbiAmJiAoIWxpbmVWaWV3Lm5vZGUgfHwgbGluZVZpZXcuY2hhbmdlcykpIHsgKytkaXJ0eTsgfVxcbiAgfVxcbiAgcmV0dXJuIGRpcnR5XFxufVxcblxcbi8vIEhJR0hMSUdIVCBXT1JLRVJcXG5cXG5mdW5jdGlvbiBzdGFydFdvcmtlcihjbSwgdGltZSkge1xcbiAgaWYgKGNtLmRvYy5tb2RlLnN0YXJ0U3RhdGUgJiYgY20uZG9jLmZyb250aWVyIDwgY20uZGlzcGxheS52aWV3VG8pXFxuICAgIHsgY20uc3RhdGUuaGlnaGxpZ2h0LnNldCh0aW1lLCBiaW5kKGhpZ2hsaWdodFdvcmtlciwgY20pKTsgfVxcbn1cXG5cXG5mdW5jdGlvbiBoaWdobGlnaHRXb3JrZXIoY20pIHtcXG4gIHZhciBkb2MgPSBjbS5kb2M7XFxuICBpZiAoZG9jLmZyb250aWVyIDwgZG9jLmZpcnN0KSB7IGRvYy5mcm9udGllciA9IGRvYy5maXJzdDsgfVxcbiAgaWYgKGRvYy5mcm9udGllciA+PSBjbS5kaXNwbGF5LnZpZXdUbykgeyByZXR1cm4gfVxcbiAgdmFyIGVuZCA9ICtuZXcgRGF0ZSArIGNtLm9wdGlvbnMud29ya1RpbWU7XFxuICB2YXIgc3RhdGUgPSBjb3B5U3RhdGUoZG9jLm1vZGUsIGdldFN0YXRlQmVmb3JlKGNtLCBkb2MuZnJvbnRpZXIpKTtcXG4gIHZhciBjaGFuZ2VkTGluZXMgPSBbXTtcXG5cXG4gIGRvYy5pdGVyKGRvYy5mcm9udGllciwgTWF0aC5taW4oZG9jLmZpcnN0ICsgZG9jLnNpemUsIGNtLmRpc3BsYXkudmlld1RvICsgNTAwKSwgZnVuY3Rpb24gKGxpbmUpIHtcXG4gICAgaWYgKGRvYy5mcm9udGllciA+PSBjbS5kaXNwbGF5LnZpZXdGcm9tKSB7IC8vIFZpc2libGVcXG4gICAgICB2YXIgb2xkU3R5bGVzID0gbGluZS5zdHlsZXMsIHRvb0xvbmcgPSBsaW5lLnRleHQubGVuZ3RoID4gY20ub3B0aW9ucy5tYXhIaWdobGlnaHRMZW5ndGg7XFxuICAgICAgdmFyIGhpZ2hsaWdodGVkID0gaGlnaGxpZ2h0TGluZShjbSwgbGluZSwgdG9vTG9uZyA/IGNvcHlTdGF0ZShkb2MubW9kZSwgc3RhdGUpIDogc3RhdGUsIHRydWUpO1xcbiAgICAgIGxpbmUuc3R5bGVzID0gaGlnaGxpZ2h0ZWQuc3R5bGVzO1xcbiAgICAgIHZhciBvbGRDbHMgPSBsaW5lLnN0eWxlQ2xhc3NlcywgbmV3Q2xzID0gaGlnaGxpZ2h0ZWQuY2xhc3NlcztcXG4gICAgICBpZiAobmV3Q2xzKSB7IGxpbmUuc3R5bGVDbGFzc2VzID0gbmV3Q2xzOyB9XFxuICAgICAgZWxzZSBpZiAob2xkQ2xzKSB7IGxpbmUuc3R5bGVDbGFzc2VzID0gbnVsbDsgfVxcbiAgICAgIHZhciBpc2NoYW5nZSA9ICFvbGRTdHlsZXMgfHwgb2xkU3R5bGVzLmxlbmd0aCAhPSBsaW5lLnN0eWxlcy5sZW5ndGggfHxcXG4gICAgICAgIG9sZENscyAhPSBuZXdDbHMgJiYgKCFvbGRDbHMgfHwgIW5ld0NscyB8fCBvbGRDbHMuYmdDbGFzcyAhPSBuZXdDbHMuYmdDbGFzcyB8fCBvbGRDbHMudGV4dENsYXNzICE9IG5ld0Nscy50ZXh0Q2xhc3MpO1xcbiAgICAgIGZvciAodmFyIGkgPSAwOyAhaXNjaGFuZ2UgJiYgaSA8IG9sZFN0eWxlcy5sZW5ndGg7ICsraSkgeyBpc2NoYW5nZSA9IG9sZFN0eWxlc1tpXSAhPSBsaW5lLnN0eWxlc1tpXTsgfVxcbiAgICAgIGlmIChpc2NoYW5nZSkgeyBjaGFuZ2VkTGluZXMucHVzaChkb2MuZnJvbnRpZXIpOyB9XFxuICAgICAgbGluZS5zdGF0ZUFmdGVyID0gdG9vTG9uZyA/IHN0YXRlIDogY29weVN0YXRlKGRvYy5tb2RlLCBzdGF0ZSk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgaWYgKGxpbmUudGV4dC5sZW5ndGggPD0gY20ub3B0aW9ucy5tYXhIaWdobGlnaHRMZW5ndGgpXFxuICAgICAgICB7IHByb2Nlc3NMaW5lKGNtLCBsaW5lLnRleHQsIHN0YXRlKTsgfVxcbiAgICAgIGxpbmUuc3RhdGVBZnRlciA9IGRvYy5mcm9udGllciAlIDUgPT0gMCA/IGNvcHlTdGF0ZShkb2MubW9kZSwgc3RhdGUpIDogbnVsbDtcXG4gICAgfVxcbiAgICArK2RvYy5mcm9udGllcjtcXG4gICAgaWYgKCtuZXcgRGF0ZSA+IGVuZCkge1xcbiAgICAgIHN0YXJ0V29ya2VyKGNtLCBjbS5vcHRpb25zLndvcmtEZWxheSk7XFxuICAgICAgcmV0dXJuIHRydWVcXG4gICAgfVxcbiAgfSk7XFxuICBpZiAoY2hhbmdlZExpbmVzLmxlbmd0aCkgeyBydW5Jbk9wKGNtLCBmdW5jdGlvbiAoKSB7XFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hhbmdlZExpbmVzLmxlbmd0aDsgaSsrKVxcbiAgICAgIHsgcmVnTGluZUNoYW5nZShjbSwgY2hhbmdlZExpbmVzW2ldLCBcXFwidGV4dFxcXCIpOyB9XFxuICB9KTsgfVxcbn1cXG5cXG4vLyBESVNQTEFZIERSQVdJTkdcXG5cXG52YXIgRGlzcGxheVVwZGF0ZSA9IGZ1bmN0aW9uKGNtLCB2aWV3cG9ydCwgZm9yY2UpIHtcXG4gIHZhciBkaXNwbGF5ID0gY20uZGlzcGxheTtcXG5cXG4gIHRoaXMudmlld3BvcnQgPSB2aWV3cG9ydDtcXG4gIC8vIFN0b3JlIHNvbWUgdmFsdWVzIHRoYXQgd2UnbGwgbmVlZCBsYXRlciAoYnV0IGRvbid0IHdhbnQgdG8gZm9yY2UgYSByZWxheW91dCBmb3IpXFxuICB0aGlzLnZpc2libGUgPSB2aXNpYmxlTGluZXMoZGlzcGxheSwgY20uZG9jLCB2aWV3cG9ydCk7XFxuICB0aGlzLmVkaXRvcklzSGlkZGVuID0gIWRpc3BsYXkud3JhcHBlci5vZmZzZXRXaWR0aDtcXG4gIHRoaXMud3JhcHBlckhlaWdodCA9IGRpc3BsYXkud3JhcHBlci5jbGllbnRIZWlnaHQ7XFxuICB0aGlzLndyYXBwZXJXaWR0aCA9IGRpc3BsYXkud3JhcHBlci5jbGllbnRXaWR0aDtcXG4gIHRoaXMub2xkRGlzcGxheVdpZHRoID0gZGlzcGxheVdpZHRoKGNtKTtcXG4gIHRoaXMuZm9yY2UgPSBmb3JjZTtcXG4gIHRoaXMuZGltcyA9IGdldERpbWVuc2lvbnMoY20pO1xcbiAgdGhpcy5ldmVudHMgPSBbXTtcXG59O1xcblxcbkRpc3BsYXlVcGRhdGUucHJvdG90eXBlLnNpZ25hbCA9IGZ1bmN0aW9uIChlbWl0dGVyLCB0eXBlKSB7XFxuICBpZiAoaGFzSGFuZGxlcihlbWl0dGVyLCB0eXBlKSlcXG4gICAgeyB0aGlzLmV2ZW50cy5wdXNoKGFyZ3VtZW50cyk7IH1cXG59O1xcbkRpc3BsYXlVcGRhdGUucHJvdG90eXBlLmZpbmlzaCA9IGZ1bmN0aW9uICgpIHtcXG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XFxuXFxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZXZlbnRzLmxlbmd0aDsgaSsrKVxcbiAgICB7IHNpZ25hbC5hcHBseShudWxsLCB0aGlzJDEuZXZlbnRzW2ldKTsgfVxcbn07XFxuXFxuZnVuY3Rpb24gbWF5YmVDbGlwU2Nyb2xsYmFycyhjbSkge1xcbiAgdmFyIGRpc3BsYXkgPSBjbS5kaXNwbGF5O1xcbiAgaWYgKCFkaXNwbGF5LnNjcm9sbGJhcnNDbGlwcGVkICYmIGRpc3BsYXkuc2Nyb2xsZXIub2Zmc2V0V2lkdGgpIHtcXG4gICAgZGlzcGxheS5uYXRpdmVCYXJXaWR0aCA9IGRpc3BsYXkuc2Nyb2xsZXIub2Zmc2V0V2lkdGggLSBkaXNwbGF5LnNjcm9sbGVyLmNsaWVudFdpZHRoO1xcbiAgICBkaXNwbGF5LmhlaWdodEZvcmNlci5zdHlsZS5oZWlnaHQgPSBzY3JvbGxHYXAoY20pICsgXFxcInB4XFxcIjtcXG4gICAgZGlzcGxheS5zaXplci5zdHlsZS5tYXJnaW5Cb3R0b20gPSAtZGlzcGxheS5uYXRpdmVCYXJXaWR0aCArIFxcXCJweFxcXCI7XFxuICAgIGRpc3BsYXkuc2l6ZXIuc3R5bGUuYm9yZGVyUmlnaHRXaWR0aCA9IHNjcm9sbEdhcChjbSkgKyBcXFwicHhcXFwiO1xcbiAgICBkaXNwbGF5LnNjcm9sbGJhcnNDbGlwcGVkID0gdHJ1ZTtcXG4gIH1cXG59XFxuXFxuLy8gRG9lcyB0aGUgYWN0dWFsIHVwZGF0aW5nIG9mIHRoZSBsaW5lIGRpc3BsYXkuIEJhaWxzIG91dFxcbi8vIChyZXR1cm5pbmcgZmFsc2UpIHdoZW4gdGhlcmUgaXMgbm90aGluZyB0byBiZSBkb25lIGFuZCBmb3JjZWQgaXNcXG4vLyBmYWxzZS5cXG5mdW5jdGlvbiB1cGRhdGVEaXNwbGF5SWZOZWVkZWQoY20sIHVwZGF0ZSkge1xcbiAgdmFyIGRpc3BsYXkgPSBjbS5kaXNwbGF5LCBkb2MgPSBjbS5kb2M7XFxuXFxuICBpZiAodXBkYXRlLmVkaXRvcklzSGlkZGVuKSB7XFxuICAgIHJlc2V0VmlldyhjbSk7XFxuICAgIHJldHVybiBmYWxzZVxcbiAgfVxcblxcbiAgLy8gQmFpbCBvdXQgaWYgdGhlIHZpc2libGUgYXJlYSBpcyBhbHJlYWR5IHJlbmRlcmVkIGFuZCBub3RoaW5nIGNoYW5nZWQuXFxuICBpZiAoIXVwZGF0ZS5mb3JjZSAmJlxcbiAgICAgIHVwZGF0ZS52aXNpYmxlLmZyb20gPj0gZGlzcGxheS52aWV3RnJvbSAmJiB1cGRhdGUudmlzaWJsZS50byA8PSBkaXNwbGF5LnZpZXdUbyAmJlxcbiAgICAgIChkaXNwbGF5LnVwZGF0ZUxpbmVOdW1iZXJzID09IG51bGwgfHwgZGlzcGxheS51cGRhdGVMaW5lTnVtYmVycyA+PSBkaXNwbGF5LnZpZXdUbykgJiZcXG4gICAgICBkaXNwbGF5LnJlbmRlcmVkVmlldyA9PSBkaXNwbGF5LnZpZXcgJiYgY291bnREaXJ0eVZpZXcoY20pID09IDApXFxuICAgIHsgcmV0dXJuIGZhbHNlIH1cXG5cXG4gIGlmIChtYXliZVVwZGF0ZUxpbmVOdW1iZXJXaWR0aChjbSkpIHtcXG4gICAgcmVzZXRWaWV3KGNtKTtcXG4gICAgdXBkYXRlLmRpbXMgPSBnZXREaW1lbnNpb25zKGNtKTtcXG4gIH1cXG5cXG4gIC8vIENvbXB1dGUgYSBzdWl0YWJsZSBuZXcgdmlld3BvcnQgKGZyb20gJiB0bylcXG4gIHZhciBlbmQgPSBkb2MuZmlyc3QgKyBkb2Muc2l6ZTtcXG4gIHZhciBmcm9tID0gTWF0aC5tYXgodXBkYXRlLnZpc2libGUuZnJvbSAtIGNtLm9wdGlvbnMudmlld3BvcnRNYXJnaW4sIGRvYy5maXJzdCk7XFxuICB2YXIgdG8gPSBNYXRoLm1pbihlbmQsIHVwZGF0ZS52aXNpYmxlLnRvICsgY20ub3B0aW9ucy52aWV3cG9ydE1hcmdpbik7XFxuICBpZiAoZGlzcGxheS52aWV3RnJvbSA8IGZyb20gJiYgZnJvbSAtIGRpc3BsYXkudmlld0Zyb20gPCAyMCkgeyBmcm9tID0gTWF0aC5tYXgoZG9jLmZpcnN0LCBkaXNwbGF5LnZpZXdGcm9tKTsgfVxcbiAgaWYgKGRpc3BsYXkudmlld1RvID4gdG8gJiYgZGlzcGxheS52aWV3VG8gLSB0byA8IDIwKSB7IHRvID0gTWF0aC5taW4oZW5kLCBkaXNwbGF5LnZpZXdUbyk7IH1cXG4gIGlmIChzYXdDb2xsYXBzZWRTcGFucykge1xcbiAgICBmcm9tID0gdmlzdWFsTGluZU5vKGNtLmRvYywgZnJvbSk7XFxuICAgIHRvID0gdmlzdWFsTGluZUVuZE5vKGNtLmRvYywgdG8pO1xcbiAgfVxcblxcbiAgdmFyIGRpZmZlcmVudCA9IGZyb20gIT0gZGlzcGxheS52aWV3RnJvbSB8fCB0byAhPSBkaXNwbGF5LnZpZXdUbyB8fFxcbiAgICBkaXNwbGF5Lmxhc3RXcmFwSGVpZ2h0ICE9IHVwZGF0ZS53cmFwcGVySGVpZ2h0IHx8IGRpc3BsYXkubGFzdFdyYXBXaWR0aCAhPSB1cGRhdGUud3JhcHBlcldpZHRoO1xcbiAgYWRqdXN0VmlldyhjbSwgZnJvbSwgdG8pO1xcblxcbiAgZGlzcGxheS52aWV3T2Zmc2V0ID0gaGVpZ2h0QXRMaW5lKGdldExpbmUoY20uZG9jLCBkaXNwbGF5LnZpZXdGcm9tKSk7XFxuICAvLyBQb3NpdGlvbiB0aGUgbW92ZXIgZGl2IHRvIGFsaWduIHdpdGggdGhlIGN1cnJlbnQgc2Nyb2xsIHBvc2l0aW9uXFxuICBjbS5kaXNwbGF5Lm1vdmVyLnN0eWxlLnRvcCA9IGRpc3BsYXkudmlld09mZnNldCArIFxcXCJweFxcXCI7XFxuXFxuICB2YXIgdG9VcGRhdGUgPSBjb3VudERpcnR5VmlldyhjbSk7XFxuICBpZiAoIWRpZmZlcmVudCAmJiB0b1VwZGF0ZSA9PSAwICYmICF1cGRhdGUuZm9yY2UgJiYgZGlzcGxheS5yZW5kZXJlZFZpZXcgPT0gZGlzcGxheS52aWV3ICYmXFxuICAgICAgKGRpc3BsYXkudXBkYXRlTGluZU51bWJlcnMgPT0gbnVsbCB8fCBkaXNwbGF5LnVwZGF0ZUxpbmVOdW1iZXJzID49IGRpc3BsYXkudmlld1RvKSlcXG4gICAgeyByZXR1cm4gZmFsc2UgfVxcblxcbiAgLy8gRm9yIGJpZyBjaGFuZ2VzLCB3ZSBoaWRlIHRoZSBlbmNsb3NpbmcgZWxlbWVudCBkdXJpbmcgdGhlXFxuICAvLyB1cGRhdGUsIHNpbmNlIHRoYXQgc3BlZWRzIHVwIHRoZSBvcGVyYXRpb25zIG9uIG1vc3QgYnJvd3NlcnMuXFxuICB2YXIgZm9jdXNlZCA9IGFjdGl2ZUVsdCgpO1xcbiAgaWYgKHRvVXBkYXRlID4gNCkgeyBkaXNwbGF5LmxpbmVEaXYuc3R5bGUuZGlzcGxheSA9IFxcXCJub25lXFxcIjsgfVxcbiAgcGF0Y2hEaXNwbGF5KGNtLCBkaXNwbGF5LnVwZGF0ZUxpbmVOdW1iZXJzLCB1cGRhdGUuZGltcyk7XFxuICBpZiAodG9VcGRhdGUgPiA0KSB7IGRpc3BsYXkubGluZURpdi5zdHlsZS5kaXNwbGF5ID0gXFxcIlxcXCI7IH1cXG4gIGRpc3BsYXkucmVuZGVyZWRWaWV3ID0gZGlzcGxheS52aWV3O1xcbiAgLy8gVGhlcmUgbWlnaHQgaGF2ZSBiZWVuIGEgd2lkZ2V0IHdpdGggYSBmb2N1c2VkIGVsZW1lbnQgdGhhdCBnb3RcXG4gIC8vIGhpZGRlbiBvciB1cGRhdGVkLCBpZiBzbyByZS1mb2N1cyBpdC5cXG4gIGlmIChmb2N1c2VkICYmIGFjdGl2ZUVsdCgpICE9IGZvY3VzZWQgJiYgZm9jdXNlZC5vZmZzZXRIZWlnaHQpIHsgZm9jdXNlZC5mb2N1cygpOyB9XFxuXFxuICAvLyBQcmV2ZW50IHNlbGVjdGlvbiBhbmQgY3Vyc29ycyBmcm9tIGludGVyZmVyaW5nIHdpdGggdGhlIHNjcm9sbFxcbiAgLy8gd2lkdGggYW5kIGhlaWdodC5cXG4gIHJlbW92ZUNoaWxkcmVuKGRpc3BsYXkuY3Vyc29yRGl2KTtcXG4gIHJlbW92ZUNoaWxkcmVuKGRpc3BsYXkuc2VsZWN0aW9uRGl2KTtcXG4gIGRpc3BsYXkuZ3V0dGVycy5zdHlsZS5oZWlnaHQgPSBkaXNwbGF5LnNpemVyLnN0eWxlLm1pbkhlaWdodCA9IDA7XFxuXFxuICBpZiAoZGlmZmVyZW50KSB7XFxuICAgIGRpc3BsYXkubGFzdFdyYXBIZWlnaHQgPSB1cGRhdGUud3JhcHBlckhlaWdodDtcXG4gICAgZGlzcGxheS5sYXN0V3JhcFdpZHRoID0gdXBkYXRlLndyYXBwZXJXaWR0aDtcXG4gICAgc3RhcnRXb3JrZXIoY20sIDQwMCk7XFxuICB9XFxuXFxuICBkaXNwbGF5LnVwZGF0ZUxpbmVOdW1iZXJzID0gbnVsbDtcXG5cXG4gIHJldHVybiB0cnVlXFxufVxcblxcbmZ1bmN0aW9uIHBvc3RVcGRhdGVEaXNwbGF5KGNtLCB1cGRhdGUpIHtcXG4gIHZhciB2aWV3cG9ydCA9IHVwZGF0ZS52aWV3cG9ydDtcXG5cXG4gIGZvciAodmFyIGZpcnN0ID0gdHJ1ZTs7IGZpcnN0ID0gZmFsc2UpIHtcXG4gICAgaWYgKCFmaXJzdCB8fCAhY20ub3B0aW9ucy5saW5lV3JhcHBpbmcgfHwgdXBkYXRlLm9sZERpc3BsYXlXaWR0aCA9PSBkaXNwbGF5V2lkdGgoY20pKSB7XFxuICAgICAgLy8gQ2xpcCBmb3JjZWQgdmlld3BvcnQgdG8gYWN0dWFsIHNjcm9sbGFibGUgYXJlYS5cXG4gICAgICBpZiAodmlld3BvcnQgJiYgdmlld3BvcnQudG9wICE9IG51bGwpXFxuICAgICAgICB7IHZpZXdwb3J0ID0ge3RvcDogTWF0aC5taW4oY20uZG9jLmhlaWdodCArIHBhZGRpbmdWZXJ0KGNtLmRpc3BsYXkpIC0gZGlzcGxheUhlaWdodChjbSksIHZpZXdwb3J0LnRvcCl9OyB9XFxuICAgICAgLy8gVXBkYXRlZCBsaW5lIGhlaWdodHMgbWlnaHQgcmVzdWx0IGluIHRoZSBkcmF3biBhcmVhIG5vdFxcbiAgICAgIC8vIGFjdHVhbGx5IGNvdmVyaW5nIHRoZSB2aWV3cG9ydC4gS2VlcCBsb29waW5nIHVudGlsIGl0IGRvZXMuXFxuICAgICAgdXBkYXRlLnZpc2libGUgPSB2aXNpYmxlTGluZXMoY20uZGlzcGxheSwgY20uZG9jLCB2aWV3cG9ydCk7XFxuICAgICAgaWYgKHVwZGF0ZS52aXNpYmxlLmZyb20gPj0gY20uZGlzcGxheS52aWV3RnJvbSAmJiB1cGRhdGUudmlzaWJsZS50byA8PSBjbS5kaXNwbGF5LnZpZXdUbylcXG4gICAgICAgIHsgYnJlYWsgfVxcbiAgICB9XFxuICAgIGlmICghdXBkYXRlRGlzcGxheUlmTmVlZGVkKGNtLCB1cGRhdGUpKSB7IGJyZWFrIH1cXG4gICAgdXBkYXRlSGVpZ2h0c0luVmlld3BvcnQoY20pO1xcbiAgICB2YXIgYmFyTWVhc3VyZSA9IG1lYXN1cmVGb3JTY3JvbGxiYXJzKGNtKTtcXG4gICAgdXBkYXRlU2VsZWN0aW9uKGNtKTtcXG4gICAgdXBkYXRlU2Nyb2xsYmFycyhjbSwgYmFyTWVhc3VyZSk7XFxuICAgIHNldERvY3VtZW50SGVpZ2h0KGNtLCBiYXJNZWFzdXJlKTtcXG4gIH1cXG5cXG4gIHVwZGF0ZS5zaWduYWwoY20sIFxcXCJ1cGRhdGVcXFwiLCBjbSk7XFxuICBpZiAoY20uZGlzcGxheS52aWV3RnJvbSAhPSBjbS5kaXNwbGF5LnJlcG9ydGVkVmlld0Zyb20gfHwgY20uZGlzcGxheS52aWV3VG8gIT0gY20uZGlzcGxheS5yZXBvcnRlZFZpZXdUbykge1xcbiAgICB1cGRhdGUuc2lnbmFsKGNtLCBcXFwidmlld3BvcnRDaGFuZ2VcXFwiLCBjbSwgY20uZGlzcGxheS52aWV3RnJvbSwgY20uZGlzcGxheS52aWV3VG8pO1xcbiAgICBjbS5kaXNwbGF5LnJlcG9ydGVkVmlld0Zyb20gPSBjbS5kaXNwbGF5LnZpZXdGcm9tOyBjbS5kaXNwbGF5LnJlcG9ydGVkVmlld1RvID0gY20uZGlzcGxheS52aWV3VG87XFxuICB9XFxufVxcblxcbmZ1bmN0aW9uIHVwZGF0ZURpc3BsYXlTaW1wbGUoY20sIHZpZXdwb3J0KSB7XFxuICB2YXIgdXBkYXRlID0gbmV3IERpc3BsYXlVcGRhdGUoY20sIHZpZXdwb3J0KTtcXG4gIGlmICh1cGRhdGVEaXNwbGF5SWZOZWVkZWQoY20sIHVwZGF0ZSkpIHtcXG4gICAgdXBkYXRlSGVpZ2h0c0luVmlld3BvcnQoY20pO1xcbiAgICBwb3N0VXBkYXRlRGlzcGxheShjbSwgdXBkYXRlKTtcXG4gICAgdmFyIGJhck1lYXN1cmUgPSBtZWFzdXJlRm9yU2Nyb2xsYmFycyhjbSk7XFxuICAgIHVwZGF0ZVNlbGVjdGlvbihjbSk7XFxuICAgIHVwZGF0ZVNjcm9sbGJhcnMoY20sIGJhck1lYXN1cmUpO1xcbiAgICBzZXREb2N1bWVudEhlaWdodChjbSwgYmFyTWVhc3VyZSk7XFxuICAgIHVwZGF0ZS5maW5pc2goKTtcXG4gIH1cXG59XFxuXFxuLy8gU3luYyB0aGUgYWN0dWFsIGRpc3BsYXkgRE9NIHN0cnVjdHVyZSB3aXRoIGRpc3BsYXkudmlldywgcmVtb3ZpbmdcXG4vLyBub2RlcyBmb3IgbGluZXMgdGhhdCBhcmUgbm8gbG9uZ2VyIGluIHZpZXcsIGFuZCBjcmVhdGluZyB0aGUgb25lc1xcbi8vIHRoYXQgYXJlIG5vdCB0aGVyZSB5ZXQsIGFuZCB1cGRhdGluZyB0aGUgb25lcyB0aGF0IGFyZSBvdXQgb2ZcXG4vLyBkYXRlLlxcbmZ1bmN0aW9uIHBhdGNoRGlzcGxheShjbSwgdXBkYXRlTnVtYmVyc0Zyb20sIGRpbXMpIHtcXG4gIHZhciBkaXNwbGF5ID0gY20uZGlzcGxheSwgbGluZU51bWJlcnMgPSBjbS5vcHRpb25zLmxpbmVOdW1iZXJzO1xcbiAgdmFyIGNvbnRhaW5lciA9IGRpc3BsYXkubGluZURpdiwgY3VyID0gY29udGFpbmVyLmZpcnN0Q2hpbGQ7XFxuXFxuICBmdW5jdGlvbiBybShub2RlKSB7XFxuICAgIHZhciBuZXh0ID0gbm9kZS5uZXh0U2libGluZztcXG4gICAgLy8gV29ya3MgYXJvdW5kIGEgdGhyb3ctc2Nyb2xsIGJ1ZyBpbiBPUyBYIFdlYmtpdFxcbiAgICBpZiAod2Via2l0ICYmIG1hYyAmJiBjbS5kaXNwbGF5LmN1cnJlbnRXaGVlbFRhcmdldCA9PSBub2RlKVxcbiAgICAgIHsgbm9kZS5zdHlsZS5kaXNwbGF5ID0gXFxcIm5vbmVcXFwiOyB9XFxuICAgIGVsc2VcXG4gICAgICB7IG5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChub2RlKTsgfVxcbiAgICByZXR1cm4gbmV4dFxcbiAgfVxcblxcbiAgdmFyIHZpZXcgPSBkaXNwbGF5LnZpZXcsIGxpbmVOID0gZGlzcGxheS52aWV3RnJvbTtcXG4gIC8vIExvb3Agb3ZlciB0aGUgZWxlbWVudHMgaW4gdGhlIHZpZXcsIHN5bmNpbmcgY3VyICh0aGUgRE9NIG5vZGVzXFxuICAvLyBpbiBkaXNwbGF5LmxpbmVEaXYpIHdpdGggdGhlIHZpZXcgYXMgd2UgZ28uXFxuICBmb3IgKHZhciBpID0gMDsgaSA8IHZpZXcubGVuZ3RoOyBpKyspIHtcXG4gICAgdmFyIGxpbmVWaWV3ID0gdmlld1tpXTtcXG4gICAgaWYgKGxpbmVWaWV3LmhpZGRlbikge1xcbiAgICB9IGVsc2UgaWYgKCFsaW5lVmlldy5ub2RlIHx8IGxpbmVWaWV3Lm5vZGUucGFyZW50Tm9kZSAhPSBjb250YWluZXIpIHsgLy8gTm90IGRyYXduIHlldFxcbiAgICAgIHZhciBub2RlID0gYnVpbGRMaW5lRWxlbWVudChjbSwgbGluZVZpZXcsIGxpbmVOLCBkaW1zKTtcXG4gICAgICBjb250YWluZXIuaW5zZXJ0QmVmb3JlKG5vZGUsIGN1cik7XFxuICAgIH0gZWxzZSB7IC8vIEFscmVhZHkgZHJhd25cXG4gICAgICB3aGlsZSAoY3VyICE9IGxpbmVWaWV3Lm5vZGUpIHsgY3VyID0gcm0oY3VyKTsgfVxcbiAgICAgIHZhciB1cGRhdGVOdW1iZXIgPSBsaW5lTnVtYmVycyAmJiB1cGRhdGVOdW1iZXJzRnJvbSAhPSBudWxsICYmXFxuICAgICAgICB1cGRhdGVOdW1iZXJzRnJvbSA8PSBsaW5lTiAmJiBsaW5lVmlldy5saW5lTnVtYmVyO1xcbiAgICAgIGlmIChsaW5lVmlldy5jaGFuZ2VzKSB7XFxuICAgICAgICBpZiAoaW5kZXhPZihsaW5lVmlldy5jaGFuZ2VzLCBcXFwiZ3V0dGVyXFxcIikgPiAtMSkgeyB1cGRhdGVOdW1iZXIgPSBmYWxzZTsgfVxcbiAgICAgICAgdXBkYXRlTGluZUZvckNoYW5nZXMoY20sIGxpbmVWaWV3LCBsaW5lTiwgZGltcyk7XFxuICAgICAgfVxcbiAgICAgIGlmICh1cGRhdGVOdW1iZXIpIHtcXG4gICAgICAgIHJlbW92ZUNoaWxkcmVuKGxpbmVWaWV3LmxpbmVOdW1iZXIpO1xcbiAgICAgICAgbGluZVZpZXcubGluZU51bWJlci5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShsaW5lTnVtYmVyRm9yKGNtLm9wdGlvbnMsIGxpbmVOKSkpO1xcbiAgICAgIH1cXG4gICAgICBjdXIgPSBsaW5lVmlldy5ub2RlLm5leHRTaWJsaW5nO1xcbiAgICB9XFxuICAgIGxpbmVOICs9IGxpbmVWaWV3LnNpemU7XFxuICB9XFxuICB3aGlsZSAoY3VyKSB7IGN1ciA9IHJtKGN1cik7IH1cXG59XFxuXFxuZnVuY3Rpb24gdXBkYXRlR3V0dGVyU3BhY2UoY20pIHtcXG4gIHZhciB3aWR0aCA9IGNtLmRpc3BsYXkuZ3V0dGVycy5vZmZzZXRXaWR0aDtcXG4gIGNtLmRpc3BsYXkuc2l6ZXIuc3R5bGUubWFyZ2luTGVmdCA9IHdpZHRoICsgXFxcInB4XFxcIjtcXG59XFxuXFxuZnVuY3Rpb24gc2V0RG9jdW1lbnRIZWlnaHQoY20sIG1lYXN1cmUpIHtcXG4gIGNtLmRpc3BsYXkuc2l6ZXIuc3R5bGUubWluSGVpZ2h0ID0gbWVhc3VyZS5kb2NIZWlnaHQgKyBcXFwicHhcXFwiO1xcbiAgY20uZGlzcGxheS5oZWlnaHRGb3JjZXIuc3R5bGUudG9wID0gbWVhc3VyZS5kb2NIZWlnaHQgKyBcXFwicHhcXFwiO1xcbiAgY20uZGlzcGxheS5ndXR0ZXJzLnN0eWxlLmhlaWdodCA9IChtZWFzdXJlLmRvY0hlaWdodCArIGNtLmRpc3BsYXkuYmFySGVpZ2h0ICsgc2Nyb2xsR2FwKGNtKSkgKyBcXFwicHhcXFwiO1xcbn1cXG5cXG4vLyBSZWJ1aWxkIHRoZSBndXR0ZXIgZWxlbWVudHMsIGVuc3VyZSB0aGUgbWFyZ2luIHRvIHRoZSBsZWZ0IG9mIHRoZVxcbi8vIGNvZGUgbWF0Y2hlcyB0aGVpciB3aWR0aC5cXG5mdW5jdGlvbiB1cGRhdGVHdXR0ZXJzKGNtKSB7XFxuICB2YXIgZ3V0dGVycyA9IGNtLmRpc3BsYXkuZ3V0dGVycywgc3BlY3MgPSBjbS5vcHRpb25zLmd1dHRlcnM7XFxuICByZW1vdmVDaGlsZHJlbihndXR0ZXJzKTtcXG4gIHZhciBpID0gMDtcXG4gIGZvciAoOyBpIDwgc3BlY3MubGVuZ3RoOyArK2kpIHtcXG4gICAgdmFyIGd1dHRlckNsYXNzID0gc3BlY3NbaV07XFxuICAgIHZhciBnRWx0ID0gZ3V0dGVycy5hcHBlbmRDaGlsZChlbHQoXFxcImRpdlxcXCIsIG51bGwsIFxcXCJDb2RlTWlycm9yLWd1dHRlciBcXFwiICsgZ3V0dGVyQ2xhc3MpKTtcXG4gICAgaWYgKGd1dHRlckNsYXNzID09IFxcXCJDb2RlTWlycm9yLWxpbmVudW1iZXJzXFxcIikge1xcbiAgICAgIGNtLmRpc3BsYXkubGluZUd1dHRlciA9IGdFbHQ7XFxuICAgICAgZ0VsdC5zdHlsZS53aWR0aCA9IChjbS5kaXNwbGF5LmxpbmVOdW1XaWR0aCB8fCAxKSArIFxcXCJweFxcXCI7XFxuICAgIH1cXG4gIH1cXG4gIGd1dHRlcnMuc3R5bGUuZGlzcGxheSA9IGkgPyBcXFwiXFxcIiA6IFxcXCJub25lXFxcIjtcXG4gIHVwZGF0ZUd1dHRlclNwYWNlKGNtKTtcXG59XFxuXFxuLy8gTWFrZSBzdXJlIHRoZSBndXR0ZXJzIG9wdGlvbnMgY29udGFpbnMgdGhlIGVsZW1lbnRcXG4vLyBcXFwiQ29kZU1pcnJvci1saW5lbnVtYmVyc1xcXCIgd2hlbiB0aGUgbGluZU51bWJlcnMgb3B0aW9uIGlzIHRydWUuXFxuZnVuY3Rpb24gc2V0R3V0dGVyc0ZvckxpbmVOdW1iZXJzKG9wdGlvbnMpIHtcXG4gIHZhciBmb3VuZCA9IGluZGV4T2Yob3B0aW9ucy5ndXR0ZXJzLCBcXFwiQ29kZU1pcnJvci1saW5lbnVtYmVyc1xcXCIpO1xcbiAgaWYgKGZvdW5kID09IC0xICYmIG9wdGlvbnMubGluZU51bWJlcnMpIHtcXG4gICAgb3B0aW9ucy5ndXR0ZXJzID0gb3B0aW9ucy5ndXR0ZXJzLmNvbmNhdChbXFxcIkNvZGVNaXJyb3ItbGluZW51bWJlcnNcXFwiXSk7XFxuICB9IGVsc2UgaWYgKGZvdW5kID4gLTEgJiYgIW9wdGlvbnMubGluZU51bWJlcnMpIHtcXG4gICAgb3B0aW9ucy5ndXR0ZXJzID0gb3B0aW9ucy5ndXR0ZXJzLnNsaWNlKDApO1xcbiAgICBvcHRpb25zLmd1dHRlcnMuc3BsaWNlKGZvdW5kLCAxKTtcXG4gIH1cXG59XFxuXFxuLy8gU2VsZWN0aW9uIG9iamVjdHMgYXJlIGltbXV0YWJsZS4gQSBuZXcgb25lIGlzIGNyZWF0ZWQgZXZlcnkgdGltZVxcbi8vIHRoZSBzZWxlY3Rpb24gY2hhbmdlcy4gQSBzZWxlY3Rpb24gaXMgb25lIG9yIG1vcmUgbm9uLW92ZXJsYXBwaW5nXFxuLy8gKGFuZCBub24tdG91Y2hpbmcpIHJhbmdlcywgc29ydGVkLCBhbmQgYW4gaW50ZWdlciB0aGF0IGluZGljYXRlc1xcbi8vIHdoaWNoIG9uZSBpcyB0aGUgcHJpbWFyeSBzZWxlY3Rpb24gKHRoZSBvbmUgdGhhdCdzIHNjcm9sbGVkIGludG9cXG4vLyB2aWV3LCB0aGF0IGdldEN1cnNvciByZXR1cm5zLCBldGMpLlxcbnZhciBTZWxlY3Rpb24gPSBmdW5jdGlvbihyYW5nZXMsIHByaW1JbmRleCkge1xcbiAgdGhpcy5yYW5nZXMgPSByYW5nZXM7XFxuICB0aGlzLnByaW1JbmRleCA9IHByaW1JbmRleDtcXG59O1xcblxcblNlbGVjdGlvbi5wcm90b3R5cGUucHJpbWFyeSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMucmFuZ2VzW3RoaXMucHJpbUluZGV4XSB9O1xcblxcblNlbGVjdGlvbi5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gKG90aGVyKSB7XFxuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xcblxcbiAgaWYgKG90aGVyID09IHRoaXMpIHsgcmV0dXJuIHRydWUgfVxcbiAgaWYgKG90aGVyLnByaW1JbmRleCAhPSB0aGlzLnByaW1JbmRleCB8fCBvdGhlci5yYW5nZXMubGVuZ3RoICE9IHRoaXMucmFuZ2VzLmxlbmd0aCkgeyByZXR1cm4gZmFsc2UgfVxcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnJhbmdlcy5sZW5ndGg7IGkrKykge1xcbiAgICB2YXIgaGVyZSA9IHRoaXMkMS5yYW5nZXNbaV0sIHRoZXJlID0gb3RoZXIucmFuZ2VzW2ldO1xcbiAgICBpZiAoIWVxdWFsQ3Vyc29yUG9zKGhlcmUuYW5jaG9yLCB0aGVyZS5hbmNob3IpIHx8ICFlcXVhbEN1cnNvclBvcyhoZXJlLmhlYWQsIHRoZXJlLmhlYWQpKSB7IHJldHVybiBmYWxzZSB9XFxuICB9XFxuICByZXR1cm4gdHJ1ZVxcbn07XFxuXFxuU2VsZWN0aW9uLnByb3RvdHlwZS5kZWVwQ29weSA9IGZ1bmN0aW9uICgpIHtcXG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XFxuXFxuICB2YXIgb3V0ID0gW107XFxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucmFuZ2VzLmxlbmd0aDsgaSsrKVxcbiAgICB7IG91dFtpXSA9IG5ldyBSYW5nZShjb3B5UG9zKHRoaXMkMS5yYW5nZXNbaV0uYW5jaG9yKSwgY29weVBvcyh0aGlzJDEucmFuZ2VzW2ldLmhlYWQpKTsgfVxcbiAgcmV0dXJuIG5ldyBTZWxlY3Rpb24ob3V0LCB0aGlzLnByaW1JbmRleClcXG59O1xcblxcblNlbGVjdGlvbi5wcm90b3R5cGUuc29tZXRoaW5nU2VsZWN0ZWQgPSBmdW5jdGlvbiAoKSB7XFxuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xcblxcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnJhbmdlcy5sZW5ndGg7IGkrKylcXG4gICAgeyBpZiAoIXRoaXMkMS5yYW5nZXNbaV0uZW1wdHkoKSkgeyByZXR1cm4gdHJ1ZSB9IH1cXG4gIHJldHVybiBmYWxzZVxcbn07XFxuXFxuU2VsZWN0aW9uLnByb3RvdHlwZS5jb250YWlucyA9IGZ1bmN0aW9uIChwb3MsIGVuZCkge1xcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcXG5cXG4gIGlmICghZW5kKSB7IGVuZCA9IHBvczsgfVxcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnJhbmdlcy5sZW5ndGg7IGkrKykge1xcbiAgICB2YXIgcmFuZ2UgPSB0aGlzJDEucmFuZ2VzW2ldO1xcbiAgICBpZiAoY21wKGVuZCwgcmFuZ2UuZnJvbSgpKSA+PSAwICYmIGNtcChwb3MsIHJhbmdlLnRvKCkpIDw9IDApXFxuICAgICAgeyByZXR1cm4gaSB9XFxuICB9XFxuICByZXR1cm4gLTFcXG59O1xcblxcbnZhciBSYW5nZSA9IGZ1bmN0aW9uKGFuY2hvciwgaGVhZCkge1xcbiAgdGhpcy5hbmNob3IgPSBhbmNob3I7IHRoaXMuaGVhZCA9IGhlYWQ7XFxufTtcXG5cXG5SYW5nZS5wcm90b3R5cGUuZnJvbSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1pblBvcyh0aGlzLmFuY2hvciwgdGhpcy5oZWFkKSB9O1xcblJhbmdlLnByb3RvdHlwZS50byA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1heFBvcyh0aGlzLmFuY2hvciwgdGhpcy5oZWFkKSB9O1xcblJhbmdlLnByb3RvdHlwZS5lbXB0eSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuaGVhZC5saW5lID09IHRoaXMuYW5jaG9yLmxpbmUgJiYgdGhpcy5oZWFkLmNoID09IHRoaXMuYW5jaG9yLmNoIH07XFxuXFxuLy8gVGFrZSBhbiB1bnNvcnRlZCwgcG90ZW50aWFsbHkgb3ZlcmxhcHBpbmcgc2V0IG9mIHJhbmdlcywgYW5kXFxuLy8gYnVpbGQgYSBzZWxlY3Rpb24gb3V0IG9mIGl0LiAnQ29uc3VtZXMnIHJhbmdlcyBhcnJheSAobW9kaWZ5aW5nXFxuLy8gaXQpLlxcbmZ1bmN0aW9uIG5vcm1hbGl6ZVNlbGVjdGlvbihyYW5nZXMsIHByaW1JbmRleCkge1xcbiAgdmFyIHByaW0gPSByYW5nZXNbcHJpbUluZGV4XTtcXG4gIHJhbmdlcy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBjbXAoYS5mcm9tKCksIGIuZnJvbSgpKTsgfSk7XFxuICBwcmltSW5kZXggPSBpbmRleE9mKHJhbmdlcywgcHJpbSk7XFxuICBmb3IgKHZhciBpID0gMTsgaSA8IHJhbmdlcy5sZW5ndGg7IGkrKykge1xcbiAgICB2YXIgY3VyID0gcmFuZ2VzW2ldLCBwcmV2ID0gcmFuZ2VzW2kgLSAxXTtcXG4gICAgaWYgKGNtcChwcmV2LnRvKCksIGN1ci5mcm9tKCkpID49IDApIHtcXG4gICAgICB2YXIgZnJvbSA9IG1pblBvcyhwcmV2LmZyb20oKSwgY3VyLmZyb20oKSksIHRvID0gbWF4UG9zKHByZXYudG8oKSwgY3VyLnRvKCkpO1xcbiAgICAgIHZhciBpbnYgPSBwcmV2LmVtcHR5KCkgPyBjdXIuZnJvbSgpID09IGN1ci5oZWFkIDogcHJldi5mcm9tKCkgPT0gcHJldi5oZWFkO1xcbiAgICAgIGlmIChpIDw9IHByaW1JbmRleCkgeyAtLXByaW1JbmRleDsgfVxcbiAgICAgIHJhbmdlcy5zcGxpY2UoLS1pLCAyLCBuZXcgUmFuZ2UoaW52ID8gdG8gOiBmcm9tLCBpbnYgPyBmcm9tIDogdG8pKTtcXG4gICAgfVxcbiAgfVxcbiAgcmV0dXJuIG5ldyBTZWxlY3Rpb24ocmFuZ2VzLCBwcmltSW5kZXgpXFxufVxcblxcbmZ1bmN0aW9uIHNpbXBsZVNlbGVjdGlvbihhbmNob3IsIGhlYWQpIHtcXG4gIHJldHVybiBuZXcgU2VsZWN0aW9uKFtuZXcgUmFuZ2UoYW5jaG9yLCBoZWFkIHx8IGFuY2hvcildLCAwKVxcbn1cXG5cXG4vLyBDb21wdXRlIHRoZSBwb3NpdGlvbiBvZiB0aGUgZW5kIG9mIGEgY2hhbmdlIChpdHMgJ3RvJyBwcm9wZXJ0eVxcbi8vIHJlZmVycyB0byB0aGUgcHJlLWNoYW5nZSBlbmQpLlxcbmZ1bmN0aW9uIGNoYW5nZUVuZChjaGFuZ2UpIHtcXG4gIGlmICghY2hhbmdlLnRleHQpIHsgcmV0dXJuIGNoYW5nZS50byB9XFxuICByZXR1cm4gUG9zKGNoYW5nZS5mcm9tLmxpbmUgKyBjaGFuZ2UudGV4dC5sZW5ndGggLSAxLFxcbiAgICAgICAgICAgICBsc3QoY2hhbmdlLnRleHQpLmxlbmd0aCArIChjaGFuZ2UudGV4dC5sZW5ndGggPT0gMSA/IGNoYW5nZS5mcm9tLmNoIDogMCkpXFxufVxcblxcbi8vIEFkanVzdCBhIHBvc2l0aW9uIHRvIHJlZmVyIHRvIHRoZSBwb3N0LWNoYW5nZSBwb3NpdGlvbiBvZiB0aGVcXG4vLyBzYW1lIHRleHQsIG9yIHRoZSBlbmQgb2YgdGhlIGNoYW5nZSBpZiB0aGUgY2hhbmdlIGNvdmVycyBpdC5cXG5mdW5jdGlvbiBhZGp1c3RGb3JDaGFuZ2UocG9zLCBjaGFuZ2UpIHtcXG4gIGlmIChjbXAocG9zLCBjaGFuZ2UuZnJvbSkgPCAwKSB7IHJldHVybiBwb3MgfVxcbiAgaWYgKGNtcChwb3MsIGNoYW5nZS50bykgPD0gMCkgeyByZXR1cm4gY2hhbmdlRW5kKGNoYW5nZSkgfVxcblxcbiAgdmFyIGxpbmUgPSBwb3MubGluZSArIGNoYW5nZS50ZXh0Lmxlbmd0aCAtIChjaGFuZ2UudG8ubGluZSAtIGNoYW5nZS5mcm9tLmxpbmUpIC0gMSwgY2ggPSBwb3MuY2g7XFxuICBpZiAocG9zLmxpbmUgPT0gY2hhbmdlLnRvLmxpbmUpIHsgY2ggKz0gY2hhbmdlRW5kKGNoYW5nZSkuY2ggLSBjaGFuZ2UudG8uY2g7IH1cXG4gIHJldHVybiBQb3MobGluZSwgY2gpXFxufVxcblxcbmZ1bmN0aW9uIGNvbXB1dGVTZWxBZnRlckNoYW5nZShkb2MsIGNoYW5nZSkge1xcbiAgdmFyIG91dCA9IFtdO1xcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBkb2Muc2VsLnJhbmdlcy5sZW5ndGg7IGkrKykge1xcbiAgICB2YXIgcmFuZ2UgPSBkb2Muc2VsLnJhbmdlc1tpXTtcXG4gICAgb3V0LnB1c2gobmV3IFJhbmdlKGFkanVzdEZvckNoYW5nZShyYW5nZS5hbmNob3IsIGNoYW5nZSksXFxuICAgICAgICAgICAgICAgICAgICAgICBhZGp1c3RGb3JDaGFuZ2UocmFuZ2UuaGVhZCwgY2hhbmdlKSkpO1xcbiAgfVxcbiAgcmV0dXJuIG5vcm1hbGl6ZVNlbGVjdGlvbihvdXQsIGRvYy5zZWwucHJpbUluZGV4KVxcbn1cXG5cXG5mdW5jdGlvbiBvZmZzZXRQb3MocG9zLCBvbGQsIG53KSB7XFxuICBpZiAocG9zLmxpbmUgPT0gb2xkLmxpbmUpXFxuICAgIHsgcmV0dXJuIFBvcyhudy5saW5lLCBwb3MuY2ggLSBvbGQuY2ggKyBudy5jaCkgfVxcbiAgZWxzZVxcbiAgICB7IHJldHVybiBQb3MobncubGluZSArIChwb3MubGluZSAtIG9sZC5saW5lKSwgcG9zLmNoKSB9XFxufVxcblxcbi8vIFVzZWQgYnkgcmVwbGFjZVNlbGVjdGlvbnMgdG8gYWxsb3cgbW92aW5nIHRoZSBzZWxlY3Rpb24gdG8gdGhlXFxuLy8gc3RhcnQgb3IgYXJvdW5kIHRoZSByZXBsYWNlZCB0ZXN0LiBIaW50IG1heSBiZSBcXFwic3RhcnRcXFwiIG9yIFxcXCJhcm91bmRcXFwiLlxcbmZ1bmN0aW9uIGNvbXB1dGVSZXBsYWNlZFNlbChkb2MsIGNoYW5nZXMsIGhpbnQpIHtcXG4gIHZhciBvdXQgPSBbXTtcXG4gIHZhciBvbGRQcmV2ID0gUG9zKGRvYy5maXJzdCwgMCksIG5ld1ByZXYgPSBvbGRQcmV2O1xcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGFuZ2VzLmxlbmd0aDsgaSsrKSB7XFxuICAgIHZhciBjaGFuZ2UgPSBjaGFuZ2VzW2ldO1xcbiAgICB2YXIgZnJvbSA9IG9mZnNldFBvcyhjaGFuZ2UuZnJvbSwgb2xkUHJldiwgbmV3UHJldik7XFxuICAgIHZhciB0byA9IG9mZnNldFBvcyhjaGFuZ2VFbmQoY2hhbmdlKSwgb2xkUHJldiwgbmV3UHJldik7XFxuICAgIG9sZFByZXYgPSBjaGFuZ2UudG87XFxuICAgIG5ld1ByZXYgPSB0bztcXG4gICAgaWYgKGhpbnQgPT0gXFxcImFyb3VuZFxcXCIpIHtcXG4gICAgICB2YXIgcmFuZ2UgPSBkb2Muc2VsLnJhbmdlc1tpXSwgaW52ID0gY21wKHJhbmdlLmhlYWQsIHJhbmdlLmFuY2hvcikgPCAwO1xcbiAgICAgIG91dFtpXSA9IG5ldyBSYW5nZShpbnYgPyB0byA6IGZyb20sIGludiA/IGZyb20gOiB0byk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgb3V0W2ldID0gbmV3IFJhbmdlKGZyb20sIGZyb20pO1xcbiAgICB9XFxuICB9XFxuICByZXR1cm4gbmV3IFNlbGVjdGlvbihvdXQsIGRvYy5zZWwucHJpbUluZGV4KVxcbn1cXG5cXG4vLyBVc2VkIHRvIGdldCB0aGUgZWRpdG9yIGludG8gYSBjb25zaXN0ZW50IHN0YXRlIGFnYWluIHdoZW4gb3B0aW9ucyBjaGFuZ2UuXFxuXFxuZnVuY3Rpb24gbG9hZE1vZGUoY20pIHtcXG4gIGNtLmRvYy5tb2RlID0gZ2V0TW9kZShjbS5vcHRpb25zLCBjbS5kb2MubW9kZU9wdGlvbik7XFxuICByZXNldE1vZGVTdGF0ZShjbSk7XFxufVxcblxcbmZ1bmN0aW9uIHJlc2V0TW9kZVN0YXRlKGNtKSB7XFxuICBjbS5kb2MuaXRlcihmdW5jdGlvbiAobGluZSkge1xcbiAgICBpZiAobGluZS5zdGF0ZUFmdGVyKSB7IGxpbmUuc3RhdGVBZnRlciA9IG51bGw7IH1cXG4gICAgaWYgKGxpbmUuc3R5bGVzKSB7IGxpbmUuc3R5bGVzID0gbnVsbDsgfVxcbiAgfSk7XFxuICBjbS5kb2MuZnJvbnRpZXIgPSBjbS5kb2MuZmlyc3Q7XFxuICBzdGFydFdvcmtlcihjbSwgMTAwKTtcXG4gIGNtLnN0YXRlLm1vZGVHZW4rKztcXG4gIGlmIChjbS5jdXJPcCkgeyByZWdDaGFuZ2UoY20pOyB9XFxufVxcblxcbi8vIERPQ1VNRU5UIERBVEEgU1RSVUNUVVJFXFxuXFxuLy8gQnkgZGVmYXVsdCwgdXBkYXRlcyB0aGF0IHN0YXJ0IGFuZCBlbmQgYXQgdGhlIGJlZ2lubmluZyBvZiBhIGxpbmVcXG4vLyBhcmUgdHJlYXRlZCBzcGVjaWFsbHksIGluIG9yZGVyIHRvIG1ha2UgdGhlIGFzc29jaWF0aW9uIG9mIGxpbmVcXG4vLyB3aWRnZXRzIGFuZCBtYXJrZXIgZWxlbWVudHMgd2l0aCB0aGUgdGV4dCBiZWhhdmUgbW9yZSBpbnR1aXRpdmUuXFxuZnVuY3Rpb24gaXNXaG9sZUxpbmVVcGRhdGUoZG9jLCBjaGFuZ2UpIHtcXG4gIHJldHVybiBjaGFuZ2UuZnJvbS5jaCA9PSAwICYmIGNoYW5nZS50by5jaCA9PSAwICYmIGxzdChjaGFuZ2UudGV4dCkgPT0gXFxcIlxcXCIgJiZcXG4gICAgKCFkb2MuY20gfHwgZG9jLmNtLm9wdGlvbnMud2hvbGVMaW5lVXBkYXRlQmVmb3JlKVxcbn1cXG5cXG4vLyBQZXJmb3JtIGEgY2hhbmdlIG9uIHRoZSBkb2N1bWVudCBkYXRhIHN0cnVjdHVyZS5cXG5mdW5jdGlvbiB1cGRhdGVEb2MoZG9jLCBjaGFuZ2UsIG1hcmtlZFNwYW5zLCBlc3RpbWF0ZUhlaWdodCQkMSkge1xcbiAgZnVuY3Rpb24gc3BhbnNGb3Iobikge3JldHVybiBtYXJrZWRTcGFucyA/IG1hcmtlZFNwYW5zW25dIDogbnVsbH1cXG4gIGZ1bmN0aW9uIHVwZGF0ZShsaW5lLCB0ZXh0LCBzcGFucykge1xcbiAgICB1cGRhdGVMaW5lKGxpbmUsIHRleHQsIHNwYW5zLCBlc3RpbWF0ZUhlaWdodCQkMSk7XFxuICAgIHNpZ25hbExhdGVyKGxpbmUsIFxcXCJjaGFuZ2VcXFwiLCBsaW5lLCBjaGFuZ2UpO1xcbiAgfVxcbiAgZnVuY3Rpb24gbGluZXNGb3Ioc3RhcnQsIGVuZCkge1xcbiAgICB2YXIgcmVzdWx0ID0gW107XFxuICAgIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKVxcbiAgICAgIHsgcmVzdWx0LnB1c2gobmV3IExpbmUodGV4dFtpXSwgc3BhbnNGb3IoaSksIGVzdGltYXRlSGVpZ2h0JCQxKSk7IH1cXG4gICAgcmV0dXJuIHJlc3VsdFxcbiAgfVxcblxcbiAgdmFyIGZyb20gPSBjaGFuZ2UuZnJvbSwgdG8gPSBjaGFuZ2UudG8sIHRleHQgPSBjaGFuZ2UudGV4dDtcXG4gIHZhciBmaXJzdExpbmUgPSBnZXRMaW5lKGRvYywgZnJvbS5saW5lKSwgbGFzdExpbmUgPSBnZXRMaW5lKGRvYywgdG8ubGluZSk7XFxuICB2YXIgbGFzdFRleHQgPSBsc3QodGV4dCksIGxhc3RTcGFucyA9IHNwYW5zRm9yKHRleHQubGVuZ3RoIC0gMSksIG5saW5lcyA9IHRvLmxpbmUgLSBmcm9tLmxpbmU7XFxuXFxuICAvLyBBZGp1c3QgdGhlIGxpbmUgc3RydWN0dXJlXFxuICBpZiAoY2hhbmdlLmZ1bGwpIHtcXG4gICAgZG9jLmluc2VydCgwLCBsaW5lc0ZvcigwLCB0ZXh0Lmxlbmd0aCkpO1xcbiAgICBkb2MucmVtb3ZlKHRleHQubGVuZ3RoLCBkb2Muc2l6ZSAtIHRleHQubGVuZ3RoKTtcXG4gIH0gZWxzZSBpZiAoaXNXaG9sZUxpbmVVcGRhdGUoZG9jLCBjaGFuZ2UpKSB7XFxuICAgIC8vIFRoaXMgaXMgYSB3aG9sZS1saW5lIHJlcGxhY2UuIFRyZWF0ZWQgc3BlY2lhbGx5IHRvIG1ha2VcXG4gICAgLy8gc3VyZSBsaW5lIG9iamVjdHMgbW92ZSB0aGUgd2F5IHRoZXkgYXJlIHN1cHBvc2VkIHRvLlxcbiAgICB2YXIgYWRkZWQgPSBsaW5lc0ZvcigwLCB0ZXh0Lmxlbmd0aCAtIDEpO1xcbiAgICB1cGRhdGUobGFzdExpbmUsIGxhc3RMaW5lLnRleHQsIGxhc3RTcGFucyk7XFxuICAgIGlmIChubGluZXMpIHsgZG9jLnJlbW92ZShmcm9tLmxpbmUsIG5saW5lcyk7IH1cXG4gICAgaWYgKGFkZGVkLmxlbmd0aCkgeyBkb2MuaW5zZXJ0KGZyb20ubGluZSwgYWRkZWQpOyB9XFxuICB9IGVsc2UgaWYgKGZpcnN0TGluZSA9PSBsYXN0TGluZSkge1xcbiAgICBpZiAodGV4dC5sZW5ndGggPT0gMSkge1xcbiAgICAgIHVwZGF0ZShmaXJzdExpbmUsIGZpcnN0TGluZS50ZXh0LnNsaWNlKDAsIGZyb20uY2gpICsgbGFzdFRleHQgKyBmaXJzdExpbmUudGV4dC5zbGljZSh0by5jaCksIGxhc3RTcGFucyk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgdmFyIGFkZGVkJDEgPSBsaW5lc0ZvcigxLCB0ZXh0Lmxlbmd0aCAtIDEpO1xcbiAgICAgIGFkZGVkJDEucHVzaChuZXcgTGluZShsYXN0VGV4dCArIGZpcnN0TGluZS50ZXh0LnNsaWNlKHRvLmNoKSwgbGFzdFNwYW5zLCBlc3RpbWF0ZUhlaWdodCQkMSkpO1xcbiAgICAgIHVwZGF0ZShmaXJzdExpbmUsIGZpcnN0TGluZS50ZXh0LnNsaWNlKDAsIGZyb20uY2gpICsgdGV4dFswXSwgc3BhbnNGb3IoMCkpO1xcbiAgICAgIGRvYy5pbnNlcnQoZnJvbS5saW5lICsgMSwgYWRkZWQkMSk7XFxuICAgIH1cXG4gIH0gZWxzZSBpZiAodGV4dC5sZW5ndGggPT0gMSkge1xcbiAgICB1cGRhdGUoZmlyc3RMaW5lLCBmaXJzdExpbmUudGV4dC5zbGljZSgwLCBmcm9tLmNoKSArIHRleHRbMF0gKyBsYXN0TGluZS50ZXh0LnNsaWNlKHRvLmNoKSwgc3BhbnNGb3IoMCkpO1xcbiAgICBkb2MucmVtb3ZlKGZyb20ubGluZSArIDEsIG5saW5lcyk7XFxuICB9IGVsc2Uge1xcbiAgICB1cGRhdGUoZmlyc3RMaW5lLCBmaXJzdExpbmUudGV4dC5zbGljZSgwLCBmcm9tLmNoKSArIHRleHRbMF0sIHNwYW5zRm9yKDApKTtcXG4gICAgdXBkYXRlKGxhc3RMaW5lLCBsYXN0VGV4dCArIGxhc3RMaW5lLnRleHQuc2xpY2UodG8uY2gpLCBsYXN0U3BhbnMpO1xcbiAgICB2YXIgYWRkZWQkMiA9IGxpbmVzRm9yKDEsIHRleHQubGVuZ3RoIC0gMSk7XFxuICAgIGlmIChubGluZXMgPiAxKSB7IGRvYy5yZW1vdmUoZnJvbS5saW5lICsgMSwgbmxpbmVzIC0gMSk7IH1cXG4gICAgZG9jLmluc2VydChmcm9tLmxpbmUgKyAxLCBhZGRlZCQyKTtcXG4gIH1cXG5cXG4gIHNpZ25hbExhdGVyKGRvYywgXFxcImNoYW5nZVxcXCIsIGRvYywgY2hhbmdlKTtcXG59XFxuXFxuLy8gQ2FsbCBmIGZvciBhbGwgbGlua2VkIGRvY3VtZW50cy5cXG5mdW5jdGlvbiBsaW5rZWREb2NzKGRvYywgZiwgc2hhcmVkSGlzdE9ubHkpIHtcXG4gIGZ1bmN0aW9uIHByb3BhZ2F0ZShkb2MsIHNraXAsIHNoYXJlZEhpc3QpIHtcXG4gICAgaWYgKGRvYy5saW5rZWQpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBkb2MubGlua2VkLmxlbmd0aDsgKytpKSB7XFxuICAgICAgdmFyIHJlbCA9IGRvYy5saW5rZWRbaV07XFxuICAgICAgaWYgKHJlbC5kb2MgPT0gc2tpcCkgeyBjb250aW51ZSB9XFxuICAgICAgdmFyIHNoYXJlZCA9IHNoYXJlZEhpc3QgJiYgcmVsLnNoYXJlZEhpc3Q7XFxuICAgICAgaWYgKHNoYXJlZEhpc3RPbmx5ICYmICFzaGFyZWQpIHsgY29udGludWUgfVxcbiAgICAgIGYocmVsLmRvYywgc2hhcmVkKTtcXG4gICAgICBwcm9wYWdhdGUocmVsLmRvYywgZG9jLCBzaGFyZWQpO1xcbiAgICB9IH1cXG4gIH1cXG4gIHByb3BhZ2F0ZShkb2MsIG51bGwsIHRydWUpO1xcbn1cXG5cXG4vLyBBdHRhY2ggYSBkb2N1bWVudCB0byBhbiBlZGl0b3IuXFxuZnVuY3Rpb24gYXR0YWNoRG9jKGNtLCBkb2MpIHtcXG4gIGlmIChkb2MuY20pIHsgdGhyb3cgbmV3IEVycm9yKFxcXCJUaGlzIGRvY3VtZW50IGlzIGFscmVhZHkgaW4gdXNlLlxcXCIpIH1cXG4gIGNtLmRvYyA9IGRvYztcXG4gIGRvYy5jbSA9IGNtO1xcbiAgZXN0aW1hdGVMaW5lSGVpZ2h0cyhjbSk7XFxuICBsb2FkTW9kZShjbSk7XFxuICBzZXREaXJlY3Rpb25DbGFzcyhjbSk7XFxuICBpZiAoIWNtLm9wdGlvbnMubGluZVdyYXBwaW5nKSB7IGZpbmRNYXhMaW5lKGNtKTsgfVxcbiAgY20ub3B0aW9ucy5tb2RlID0gZG9jLm1vZGVPcHRpb247XFxuICByZWdDaGFuZ2UoY20pO1xcbn1cXG5cXG5mdW5jdGlvbiBzZXREaXJlY3Rpb25DbGFzcyhjbSkge1xcbiAgKGNtLmRvYy5kaXJlY3Rpb24gPT0gXFxcInJ0bFxcXCIgPyBhZGRDbGFzcyA6IHJtQ2xhc3MpKGNtLmRpc3BsYXkubGluZURpdiwgXFxcIkNvZGVNaXJyb3ItcnRsXFxcIik7XFxufVxcblxcbmZ1bmN0aW9uIGRpcmVjdGlvbkNoYW5nZWQoY20pIHtcXG4gIHJ1bkluT3AoY20sIGZ1bmN0aW9uICgpIHtcXG4gICAgc2V0RGlyZWN0aW9uQ2xhc3MoY20pO1xcbiAgICByZWdDaGFuZ2UoY20pO1xcbiAgfSk7XFxufVxcblxcbmZ1bmN0aW9uIEhpc3Rvcnkoc3RhcnRHZW4pIHtcXG4gIC8vIEFycmF5cyBvZiBjaGFuZ2UgZXZlbnRzIGFuZCBzZWxlY3Rpb25zLiBEb2luZyBzb21ldGhpbmcgYWRkcyBhblxcbiAgLy8gZXZlbnQgdG8gZG9uZSBhbmQgY2xlYXJzIHVuZG8uIFVuZG9pbmcgbW92ZXMgZXZlbnRzIGZyb20gZG9uZVxcbiAgLy8gdG8gdW5kb25lLCByZWRvaW5nIG1vdmVzIHRoZW0gaW4gdGhlIG90aGVyIGRpcmVjdGlvbi5cXG4gIHRoaXMuZG9uZSA9IFtdOyB0aGlzLnVuZG9uZSA9IFtdO1xcbiAgdGhpcy51bmRvRGVwdGggPSBJbmZpbml0eTtcXG4gIC8vIFVzZWQgdG8gdHJhY2sgd2hlbiBjaGFuZ2VzIGNhbiBiZSBtZXJnZWQgaW50byBhIHNpbmdsZSB1bmRvXFxuICAvLyBldmVudFxcbiAgdGhpcy5sYXN0TW9kVGltZSA9IHRoaXMubGFzdFNlbFRpbWUgPSAwO1xcbiAgdGhpcy5sYXN0T3AgPSB0aGlzLmxhc3RTZWxPcCA9IG51bGw7XFxuICB0aGlzLmxhc3RPcmlnaW4gPSB0aGlzLmxhc3RTZWxPcmlnaW4gPSBudWxsO1xcbiAgLy8gVXNlZCBieSB0aGUgaXNDbGVhbigpIG1ldGhvZFxcbiAgdGhpcy5nZW5lcmF0aW9uID0gdGhpcy5tYXhHZW5lcmF0aW9uID0gc3RhcnRHZW4gfHwgMTtcXG59XFxuXFxuLy8gQ3JlYXRlIGEgaGlzdG9yeSBjaGFuZ2UgZXZlbnQgZnJvbSBhbiB1cGRhdGVEb2Mtc3R5bGUgY2hhbmdlXFxuLy8gb2JqZWN0LlxcbmZ1bmN0aW9uIGhpc3RvcnlDaGFuZ2VGcm9tQ2hhbmdlKGRvYywgY2hhbmdlKSB7XFxuICB2YXIgaGlzdENoYW5nZSA9IHtmcm9tOiBjb3B5UG9zKGNoYW5nZS5mcm9tKSwgdG86IGNoYW5nZUVuZChjaGFuZ2UpLCB0ZXh0OiBnZXRCZXR3ZWVuKGRvYywgY2hhbmdlLmZyb20sIGNoYW5nZS50byl9O1xcbiAgYXR0YWNoTG9jYWxTcGFucyhkb2MsIGhpc3RDaGFuZ2UsIGNoYW5nZS5mcm9tLmxpbmUsIGNoYW5nZS50by5saW5lICsgMSk7XFxuICBsaW5rZWREb2NzKGRvYywgZnVuY3Rpb24gKGRvYykgeyByZXR1cm4gYXR0YWNoTG9jYWxTcGFucyhkb2MsIGhpc3RDaGFuZ2UsIGNoYW5nZS5mcm9tLmxpbmUsIGNoYW5nZS50by5saW5lICsgMSk7IH0sIHRydWUpO1xcbiAgcmV0dXJuIGhpc3RDaGFuZ2VcXG59XFxuXFxuLy8gUG9wIGFsbCBzZWxlY3Rpb24gZXZlbnRzIG9mZiB0aGUgZW5kIG9mIGEgaGlzdG9yeSBhcnJheS4gU3RvcCBhdFxcbi8vIGEgY2hhbmdlIGV2ZW50LlxcbmZ1bmN0aW9uIGNsZWFyU2VsZWN0aW9uRXZlbnRzKGFycmF5KSB7XFxuICB3aGlsZSAoYXJyYXkubGVuZ3RoKSB7XFxuICAgIHZhciBsYXN0ID0gbHN0KGFycmF5KTtcXG4gICAgaWYgKGxhc3QucmFuZ2VzKSB7IGFycmF5LnBvcCgpOyB9XFxuICAgIGVsc2UgeyBicmVhayB9XFxuICB9XFxufVxcblxcbi8vIEZpbmQgdGhlIHRvcCBjaGFuZ2UgZXZlbnQgaW4gdGhlIGhpc3RvcnkuIFBvcCBvZmYgc2VsZWN0aW9uXFxuLy8gZXZlbnRzIHRoYXQgYXJlIGluIHRoZSB3YXkuXFxuZnVuY3Rpb24gbGFzdENoYW5nZUV2ZW50KGhpc3QsIGZvcmNlKSB7XFxuICBpZiAoZm9yY2UpIHtcXG4gICAgY2xlYXJTZWxlY3Rpb25FdmVudHMoaGlzdC5kb25lKTtcXG4gICAgcmV0dXJuIGxzdChoaXN0LmRvbmUpXFxuICB9IGVsc2UgaWYgKGhpc3QuZG9uZS5sZW5ndGggJiYgIWxzdChoaXN0LmRvbmUpLnJhbmdlcykge1xcbiAgICByZXR1cm4gbHN0KGhpc3QuZG9uZSlcXG4gIH0gZWxzZSBpZiAoaGlzdC5kb25lLmxlbmd0aCA+IDEgJiYgIWhpc3QuZG9uZVtoaXN0LmRvbmUubGVuZ3RoIC0gMl0ucmFuZ2VzKSB7XFxuICAgIGhpc3QuZG9uZS5wb3AoKTtcXG4gICAgcmV0dXJuIGxzdChoaXN0LmRvbmUpXFxuICB9XFxufVxcblxcbi8vIFJlZ2lzdGVyIGEgY2hhbmdlIGluIHRoZSBoaXN0b3J5LiBNZXJnZXMgY2hhbmdlcyB0aGF0IGFyZSB3aXRoaW5cXG4vLyBhIHNpbmdsZSBvcGVyYXRpb24sIG9yIGFyZSBjbG9zZSB0b2dldGhlciB3aXRoIGFuIG9yaWdpbiB0aGF0XFxuLy8gYWxsb3dzIG1lcmdpbmcgKHN0YXJ0aW5nIHdpdGggXFxcIitcXFwiKSBpbnRvIGEgc2luZ2xlIGV2ZW50LlxcbmZ1bmN0aW9uIGFkZENoYW5nZVRvSGlzdG9yeShkb2MsIGNoYW5nZSwgc2VsQWZ0ZXIsIG9wSWQpIHtcXG4gIHZhciBoaXN0ID0gZG9jLmhpc3Rvcnk7XFxuICBoaXN0LnVuZG9uZS5sZW5ndGggPSAwO1xcbiAgdmFyIHRpbWUgPSArbmV3IERhdGUsIGN1cjtcXG4gIHZhciBsYXN0O1xcblxcbiAgaWYgKChoaXN0Lmxhc3RPcCA9PSBvcElkIHx8XFxuICAgICAgIGhpc3QubGFzdE9yaWdpbiA9PSBjaGFuZ2Uub3JpZ2luICYmIGNoYW5nZS5vcmlnaW4gJiZcXG4gICAgICAgKChjaGFuZ2Uub3JpZ2luLmNoYXJBdCgwKSA9PSBcXFwiK1xcXCIgJiYgZG9jLmNtICYmIGhpc3QubGFzdE1vZFRpbWUgPiB0aW1lIC0gZG9jLmNtLm9wdGlvbnMuaGlzdG9yeUV2ZW50RGVsYXkpIHx8XFxuICAgICAgICBjaGFuZ2Uub3JpZ2luLmNoYXJBdCgwKSA9PSBcXFwiKlxcXCIpKSAmJlxcbiAgICAgIChjdXIgPSBsYXN0Q2hhbmdlRXZlbnQoaGlzdCwgaGlzdC5sYXN0T3AgPT0gb3BJZCkpKSB7XFxuICAgIC8vIE1lcmdlIHRoaXMgY2hhbmdlIGludG8gdGhlIGxhc3QgZXZlbnRcXG4gICAgbGFzdCA9IGxzdChjdXIuY2hhbmdlcyk7XFxuICAgIGlmIChjbXAoY2hhbmdlLmZyb20sIGNoYW5nZS50bykgPT0gMCAmJiBjbXAoY2hhbmdlLmZyb20sIGxhc3QudG8pID09IDApIHtcXG4gICAgICAvLyBPcHRpbWl6ZWQgY2FzZSBmb3Igc2ltcGxlIGluc2VydGlvbiAtLSBkb24ndCB3YW50IHRvIGFkZFxcbiAgICAgIC8vIG5ldyBjaGFuZ2VzZXRzIGZvciBldmVyeSBjaGFyYWN0ZXIgdHlwZWRcXG4gICAgICBsYXN0LnRvID0gY2hhbmdlRW5kKGNoYW5nZSk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgLy8gQWRkIG5ldyBzdWItZXZlbnRcXG4gICAgICBjdXIuY2hhbmdlcy5wdXNoKGhpc3RvcnlDaGFuZ2VGcm9tQ2hhbmdlKGRvYywgY2hhbmdlKSk7XFxuICAgIH1cXG4gIH0gZWxzZSB7XFxuICAgIC8vIENhbiBub3QgYmUgbWVyZ2VkLCBzdGFydCBhIG5ldyBldmVudC5cXG4gICAgdmFyIGJlZm9yZSA9IGxzdChoaXN0LmRvbmUpO1xcbiAgICBpZiAoIWJlZm9yZSB8fCAhYmVmb3JlLnJhbmdlcylcXG4gICAgICB7IHB1c2hTZWxlY3Rpb25Ub0hpc3RvcnkoZG9jLnNlbCwgaGlzdC5kb25lKTsgfVxcbiAgICBjdXIgPSB7Y2hhbmdlczogW2hpc3RvcnlDaGFuZ2VGcm9tQ2hhbmdlKGRvYywgY2hhbmdlKV0sXFxuICAgICAgICAgICBnZW5lcmF0aW9uOiBoaXN0LmdlbmVyYXRpb259O1xcbiAgICBoaXN0LmRvbmUucHVzaChjdXIpO1xcbiAgICB3aGlsZSAoaGlzdC5kb25lLmxlbmd0aCA+IGhpc3QudW5kb0RlcHRoKSB7XFxuICAgICAgaGlzdC5kb25lLnNoaWZ0KCk7XFxuICAgICAgaWYgKCFoaXN0LmRvbmVbMF0ucmFuZ2VzKSB7IGhpc3QuZG9uZS5zaGlmdCgpOyB9XFxuICAgIH1cXG4gIH1cXG4gIGhpc3QuZG9uZS5wdXNoKHNlbEFmdGVyKTtcXG4gIGhpc3QuZ2VuZXJhdGlvbiA9ICsraGlzdC5tYXhHZW5lcmF0aW9uO1xcbiAgaGlzdC5sYXN0TW9kVGltZSA9IGhpc3QubGFzdFNlbFRpbWUgPSB0aW1lO1xcbiAgaGlzdC5sYXN0T3AgPSBoaXN0Lmxhc3RTZWxPcCA9IG9wSWQ7XFxuICBoaXN0Lmxhc3RPcmlnaW4gPSBoaXN0Lmxhc3RTZWxPcmlnaW4gPSBjaGFuZ2Uub3JpZ2luO1xcblxcbiAgaWYgKCFsYXN0KSB7IHNpZ25hbChkb2MsIFxcXCJoaXN0b3J5QWRkZWRcXFwiKTsgfVxcbn1cXG5cXG5mdW5jdGlvbiBzZWxlY3Rpb25FdmVudENhbkJlTWVyZ2VkKGRvYywgb3JpZ2luLCBwcmV2LCBzZWwpIHtcXG4gIHZhciBjaCA9IG9yaWdpbi5jaGFyQXQoMCk7XFxuICByZXR1cm4gY2ggPT0gXFxcIipcXFwiIHx8XFxuICAgIGNoID09IFxcXCIrXFxcIiAmJlxcbiAgICBwcmV2LnJhbmdlcy5sZW5ndGggPT0gc2VsLnJhbmdlcy5sZW5ndGggJiZcXG4gICAgcHJldi5zb21ldGhpbmdTZWxlY3RlZCgpID09IHNlbC5zb21ldGhpbmdTZWxlY3RlZCgpICYmXFxuICAgIG5ldyBEYXRlIC0gZG9jLmhpc3RvcnkubGFzdFNlbFRpbWUgPD0gKGRvYy5jbSA/IGRvYy5jbS5vcHRpb25zLmhpc3RvcnlFdmVudERlbGF5IDogNTAwKVxcbn1cXG5cXG4vLyBDYWxsZWQgd2hlbmV2ZXIgdGhlIHNlbGVjdGlvbiBjaGFuZ2VzLCBzZXRzIHRoZSBuZXcgc2VsZWN0aW9uIGFzXFxuLy8gdGhlIHBlbmRpbmcgc2VsZWN0aW9uIGluIHRoZSBoaXN0b3J5LCBhbmQgcHVzaGVzIHRoZSBvbGQgcGVuZGluZ1xcbi8vIHNlbGVjdGlvbiBpbnRvIHRoZSAnZG9uZScgYXJyYXkgd2hlbiBpdCB3YXMgc2lnbmlmaWNhbnRseVxcbi8vIGRpZmZlcmVudCAoaW4gbnVtYmVyIG9mIHNlbGVjdGVkIHJhbmdlcywgZW1wdGluZXNzLCBvciB0aW1lKS5cXG5mdW5jdGlvbiBhZGRTZWxlY3Rpb25Ub0hpc3RvcnkoZG9jLCBzZWwsIG9wSWQsIG9wdGlvbnMpIHtcXG4gIHZhciBoaXN0ID0gZG9jLmhpc3RvcnksIG9yaWdpbiA9IG9wdGlvbnMgJiYgb3B0aW9ucy5vcmlnaW47XFxuXFxuICAvLyBBIG5ldyBldmVudCBpcyBzdGFydGVkIHdoZW4gdGhlIHByZXZpb3VzIG9yaWdpbiBkb2VzIG5vdCBtYXRjaFxcbiAgLy8gdGhlIGN1cnJlbnQsIG9yIHRoZSBvcmlnaW5zIGRvbid0IGFsbG93IG1hdGNoaW5nLiBPcmlnaW5zXFxuICAvLyBzdGFydGluZyB3aXRoICogYXJlIGFsd2F5cyBtZXJnZWQsIHRob3NlIHN0YXJ0aW5nIHdpdGggKyBhcmVcXG4gIC8vIG1lcmdlZCB3aGVuIHNpbWlsYXIgYW5kIGNsb3NlIHRvZ2V0aGVyIGluIHRpbWUuXFxuICBpZiAob3BJZCA9PSBoaXN0Lmxhc3RTZWxPcCB8fFxcbiAgICAgIChvcmlnaW4gJiYgaGlzdC5sYXN0U2VsT3JpZ2luID09IG9yaWdpbiAmJlxcbiAgICAgICAoaGlzdC5sYXN0TW9kVGltZSA9PSBoaXN0Lmxhc3RTZWxUaW1lICYmIGhpc3QubGFzdE9yaWdpbiA9PSBvcmlnaW4gfHxcXG4gICAgICAgIHNlbGVjdGlvbkV2ZW50Q2FuQmVNZXJnZWQoZG9jLCBvcmlnaW4sIGxzdChoaXN0LmRvbmUpLCBzZWwpKSkpXFxuICAgIHsgaGlzdC5kb25lW2hpc3QuZG9uZS5sZW5ndGggLSAxXSA9IHNlbDsgfVxcbiAgZWxzZVxcbiAgICB7IHB1c2hTZWxlY3Rpb25Ub0hpc3Rvcnkoc2VsLCBoaXN0LmRvbmUpOyB9XFxuXFxuICBoaXN0Lmxhc3RTZWxUaW1lID0gK25ldyBEYXRlO1xcbiAgaGlzdC5sYXN0U2VsT3JpZ2luID0gb3JpZ2luO1xcbiAgaGlzdC5sYXN0U2VsT3AgPSBvcElkO1xcbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5jbGVhclJlZG8gIT09IGZhbHNlKVxcbiAgICB7IGNsZWFyU2VsZWN0aW9uRXZlbnRzKGhpc3QudW5kb25lKTsgfVxcbn1cXG5cXG5mdW5jdGlvbiBwdXNoU2VsZWN0aW9uVG9IaXN0b3J5KHNlbCwgZGVzdCkge1xcbiAgdmFyIHRvcCA9IGxzdChkZXN0KTtcXG4gIGlmICghKHRvcCAmJiB0b3AucmFuZ2VzICYmIHRvcC5lcXVhbHMoc2VsKSkpXFxuICAgIHsgZGVzdC5wdXNoKHNlbCk7IH1cXG59XFxuXFxuLy8gVXNlZCB0byBzdG9yZSBtYXJrZWQgc3BhbiBpbmZvcm1hdGlvbiBpbiB0aGUgaGlzdG9yeS5cXG5mdW5jdGlvbiBhdHRhY2hMb2NhbFNwYW5zKGRvYywgY2hhbmdlLCBmcm9tLCB0bykge1xcbiAgdmFyIGV4aXN0aW5nID0gY2hhbmdlW1xcXCJzcGFuc19cXFwiICsgZG9jLmlkXSwgbiA9IDA7XFxuICBkb2MuaXRlcihNYXRoLm1heChkb2MuZmlyc3QsIGZyb20pLCBNYXRoLm1pbihkb2MuZmlyc3QgKyBkb2Muc2l6ZSwgdG8pLCBmdW5jdGlvbiAobGluZSkge1xcbiAgICBpZiAobGluZS5tYXJrZWRTcGFucylcXG4gICAgICB7IChleGlzdGluZyB8fCAoZXhpc3RpbmcgPSBjaGFuZ2VbXFxcInNwYW5zX1xcXCIgKyBkb2MuaWRdID0ge30pKVtuXSA9IGxpbmUubWFya2VkU3BhbnM7IH1cXG4gICAgKytuO1xcbiAgfSk7XFxufVxcblxcbi8vIFdoZW4gdW4vcmUtZG9pbmcgcmVzdG9yZXMgdGV4dCBjb250YWluaW5nIG1hcmtlZCBzcGFucywgdGhvc2VcXG4vLyB0aGF0IGhhdmUgYmVlbiBleHBsaWNpdGx5IGNsZWFyZWQgc2hvdWxkIG5vdCBiZSByZXN0b3JlZC5cXG5mdW5jdGlvbiByZW1vdmVDbGVhcmVkU3BhbnMoc3BhbnMpIHtcXG4gIGlmICghc3BhbnMpIHsgcmV0dXJuIG51bGwgfVxcbiAgdmFyIG91dDtcXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3BhbnMubGVuZ3RoOyArK2kpIHtcXG4gICAgaWYgKHNwYW5zW2ldLm1hcmtlci5leHBsaWNpdGx5Q2xlYXJlZCkgeyBpZiAoIW91dCkgeyBvdXQgPSBzcGFucy5zbGljZSgwLCBpKTsgfSB9XFxuICAgIGVsc2UgaWYgKG91dCkgeyBvdXQucHVzaChzcGFuc1tpXSk7IH1cXG4gIH1cXG4gIHJldHVybiAhb3V0ID8gc3BhbnMgOiBvdXQubGVuZ3RoID8gb3V0IDogbnVsbFxcbn1cXG5cXG4vLyBSZXRyaWV2ZSBhbmQgZmlsdGVyIHRoZSBvbGQgbWFya2VkIHNwYW5zIHN0b3JlZCBpbiBhIGNoYW5nZSBldmVudC5cXG5mdW5jdGlvbiBnZXRPbGRTcGFucyhkb2MsIGNoYW5nZSkge1xcbiAgdmFyIGZvdW5kID0gY2hhbmdlW1xcXCJzcGFuc19cXFwiICsgZG9jLmlkXTtcXG4gIGlmICghZm91bmQpIHsgcmV0dXJuIG51bGwgfVxcbiAgdmFyIG53ID0gW107XFxuICBmb3IgKHZhciBpID0gMDsgaSA8IGNoYW5nZS50ZXh0Lmxlbmd0aDsgKytpKVxcbiAgICB7IG53LnB1c2gocmVtb3ZlQ2xlYXJlZFNwYW5zKGZvdW5kW2ldKSk7IH1cXG4gIHJldHVybiBud1xcbn1cXG5cXG4vLyBVc2VkIGZvciB1bi9yZS1kb2luZyBjaGFuZ2VzIGZyb20gdGhlIGhpc3RvcnkuIENvbWJpbmVzIHRoZVxcbi8vIHJlc3VsdCBvZiBjb21wdXRpbmcgdGhlIGV4aXN0aW5nIHNwYW5zIHdpdGggdGhlIHNldCBvZiBzcGFucyB0aGF0XFxuLy8gZXhpc3RlZCBpbiB0aGUgaGlzdG9yeSAoc28gdGhhdCBkZWxldGluZyBhcm91bmQgYSBzcGFuIGFuZCB0aGVuXFxuLy8gdW5kb2luZyBicmluZ3MgYmFjayB0aGUgc3BhbikuXFxuZnVuY3Rpb24gbWVyZ2VPbGRTcGFucyhkb2MsIGNoYW5nZSkge1xcbiAgdmFyIG9sZCA9IGdldE9sZFNwYW5zKGRvYywgY2hhbmdlKTtcXG4gIHZhciBzdHJldGNoZWQgPSBzdHJldGNoU3BhbnNPdmVyQ2hhbmdlKGRvYywgY2hhbmdlKTtcXG4gIGlmICghb2xkKSB7IHJldHVybiBzdHJldGNoZWQgfVxcbiAgaWYgKCFzdHJldGNoZWQpIHsgcmV0dXJuIG9sZCB9XFxuXFxuICBmb3IgKHZhciBpID0gMDsgaSA8IG9sZC5sZW5ndGg7ICsraSkge1xcbiAgICB2YXIgb2xkQ3VyID0gb2xkW2ldLCBzdHJldGNoQ3VyID0gc3RyZXRjaGVkW2ldO1xcbiAgICBpZiAob2xkQ3VyICYmIHN0cmV0Y2hDdXIpIHtcXG4gICAgICBzcGFuczogZm9yICh2YXIgaiA9IDA7IGogPCBzdHJldGNoQ3VyLmxlbmd0aDsgKytqKSB7XFxuICAgICAgICB2YXIgc3BhbiA9IHN0cmV0Y2hDdXJbal07XFxuICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IG9sZEN1ci5sZW5ndGg7ICsraylcXG4gICAgICAgICAgeyBpZiAob2xkQ3VyW2tdLm1hcmtlciA9PSBzcGFuLm1hcmtlcikgeyBjb250aW51ZSBzcGFucyB9IH1cXG4gICAgICAgIG9sZEN1ci5wdXNoKHNwYW4pO1xcbiAgICAgIH1cXG4gICAgfSBlbHNlIGlmIChzdHJldGNoQ3VyKSB7XFxuICAgICAgb2xkW2ldID0gc3RyZXRjaEN1cjtcXG4gICAgfVxcbiAgfVxcbiAgcmV0dXJuIG9sZFxcbn1cXG5cXG4vLyBVc2VkIGJvdGggdG8gcHJvdmlkZSBhIEpTT04tc2FmZSBvYmplY3QgaW4gLmdldEhpc3RvcnksIGFuZCwgd2hlblxcbi8vIGRldGFjaGluZyBhIGRvY3VtZW50LCB0byBzcGxpdCB0aGUgaGlzdG9yeSBpbiB0d29cXG5mdW5jdGlvbiBjb3B5SGlzdG9yeUFycmF5KGV2ZW50cywgbmV3R3JvdXAsIGluc3RhbnRpYXRlU2VsKSB7XFxuICB2YXIgY29weSA9IFtdO1xcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBldmVudHMubGVuZ3RoOyArK2kpIHtcXG4gICAgdmFyIGV2ZW50ID0gZXZlbnRzW2ldO1xcbiAgICBpZiAoZXZlbnQucmFuZ2VzKSB7XFxuICAgICAgY29weS5wdXNoKGluc3RhbnRpYXRlU2VsID8gU2VsZWN0aW9uLnByb3RvdHlwZS5kZWVwQ29weS5jYWxsKGV2ZW50KSA6IGV2ZW50KTtcXG4gICAgICBjb250aW51ZVxcbiAgICB9XFxuICAgIHZhciBjaGFuZ2VzID0gZXZlbnQuY2hhbmdlcywgbmV3Q2hhbmdlcyA9IFtdO1xcbiAgICBjb3B5LnB1c2goe2NoYW5nZXM6IG5ld0NoYW5nZXN9KTtcXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBjaGFuZ2VzLmxlbmd0aDsgKytqKSB7XFxuICAgICAgdmFyIGNoYW5nZSA9IGNoYW5nZXNbal0sIG0gPSAodm9pZCAwKTtcXG4gICAgICBuZXdDaGFuZ2VzLnB1c2goe2Zyb206IGNoYW5nZS5mcm9tLCB0bzogY2hhbmdlLnRvLCB0ZXh0OiBjaGFuZ2UudGV4dH0pO1xcbiAgICAgIGlmIChuZXdHcm91cCkgeyBmb3IgKHZhciBwcm9wIGluIGNoYW5nZSkgeyBpZiAobSA9IHByb3AubWF0Y2goL15zcGFuc18oXFxcXGQrKSQvKSkge1xcbiAgICAgICAgaWYgKGluZGV4T2YobmV3R3JvdXAsIE51bWJlcihtWzFdKSkgPiAtMSkge1xcbiAgICAgICAgICBsc3QobmV3Q2hhbmdlcylbcHJvcF0gPSBjaGFuZ2VbcHJvcF07XFxuICAgICAgICAgIGRlbGV0ZSBjaGFuZ2VbcHJvcF07XFxuICAgICAgICB9XFxuICAgICAgfSB9IH1cXG4gICAgfVxcbiAgfVxcbiAgcmV0dXJuIGNvcHlcXG59XFxuXFxuLy8gVGhlICdzY3JvbGwnIHBhcmFtZXRlciBnaXZlbiB0byBtYW55IG9mIHRoZXNlIGluZGljYXRlZCB3aGV0aGVyXFxuLy8gdGhlIG5ldyBjdXJzb3IgcG9zaXRpb24gc2hvdWxkIGJlIHNjcm9sbGVkIGludG8gdmlldyBhZnRlclxcbi8vIG1vZGlmeWluZyB0aGUgc2VsZWN0aW9uLlxcblxcbi8vIElmIHNoaWZ0IGlzIGhlbGQgb3IgdGhlIGV4dGVuZCBmbGFnIGlzIHNldCwgZXh0ZW5kcyBhIHJhbmdlIHRvXFxuLy8gaW5jbHVkZSBhIGdpdmVuIHBvc2l0aW9uIChhbmQgb3B0aW9uYWxseSBhIHNlY29uZCBwb3NpdGlvbikuXFxuLy8gT3RoZXJ3aXNlLCBzaW1wbHkgcmV0dXJucyB0aGUgcmFuZ2UgYmV0d2VlbiB0aGUgZ2l2ZW4gcG9zaXRpb25zLlxcbi8vIFVzZWQgZm9yIGN1cnNvciBtb3Rpb24gYW5kIHN1Y2guXFxuZnVuY3Rpb24gZXh0ZW5kUmFuZ2UoZG9jLCByYW5nZSwgaGVhZCwgb3RoZXIpIHtcXG4gIGlmIChkb2MuY20gJiYgZG9jLmNtLmRpc3BsYXkuc2hpZnQgfHwgZG9jLmV4dGVuZCkge1xcbiAgICB2YXIgYW5jaG9yID0gcmFuZ2UuYW5jaG9yO1xcbiAgICBpZiAob3RoZXIpIHtcXG4gICAgICB2YXIgcG9zQmVmb3JlID0gY21wKGhlYWQsIGFuY2hvcikgPCAwO1xcbiAgICAgIGlmIChwb3NCZWZvcmUgIT0gKGNtcChvdGhlciwgYW5jaG9yKSA8IDApKSB7XFxuICAgICAgICBhbmNob3IgPSBoZWFkO1xcbiAgICAgICAgaGVhZCA9IG90aGVyO1xcbiAgICAgIH0gZWxzZSBpZiAocG9zQmVmb3JlICE9IChjbXAoaGVhZCwgb3RoZXIpIDwgMCkpIHtcXG4gICAgICAgIGhlYWQgPSBvdGhlcjtcXG4gICAgICB9XFxuICAgIH1cXG4gICAgcmV0dXJuIG5ldyBSYW5nZShhbmNob3IsIGhlYWQpXFxuICB9IGVsc2Uge1xcbiAgICByZXR1cm4gbmV3IFJhbmdlKG90aGVyIHx8IGhlYWQsIGhlYWQpXFxuICB9XFxufVxcblxcbi8vIEV4dGVuZCB0aGUgcHJpbWFyeSBzZWxlY3Rpb24gcmFuZ2UsIGRpc2NhcmQgdGhlIHJlc3QuXFxuZnVuY3Rpb24gZXh0ZW5kU2VsZWN0aW9uKGRvYywgaGVhZCwgb3RoZXIsIG9wdGlvbnMpIHtcXG4gIHNldFNlbGVjdGlvbihkb2MsIG5ldyBTZWxlY3Rpb24oW2V4dGVuZFJhbmdlKGRvYywgZG9jLnNlbC5wcmltYXJ5KCksIGhlYWQsIG90aGVyKV0sIDApLCBvcHRpb25zKTtcXG59XFxuXFxuLy8gRXh0ZW5kIGFsbCBzZWxlY3Rpb25zIChwb3MgaXMgYW4gYXJyYXkgb2Ygc2VsZWN0aW9ucyB3aXRoIGxlbmd0aFxcbi8vIGVxdWFsIHRoZSBudW1iZXIgb2Ygc2VsZWN0aW9ucylcXG5mdW5jdGlvbiBleHRlbmRTZWxlY3Rpb25zKGRvYywgaGVhZHMsIG9wdGlvbnMpIHtcXG4gIHZhciBvdXQgPSBbXTtcXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZG9jLnNlbC5yYW5nZXMubGVuZ3RoOyBpKyspXFxuICAgIHsgb3V0W2ldID0gZXh0ZW5kUmFuZ2UoZG9jLCBkb2Muc2VsLnJhbmdlc1tpXSwgaGVhZHNbaV0sIG51bGwpOyB9XFxuICB2YXIgbmV3U2VsID0gbm9ybWFsaXplU2VsZWN0aW9uKG91dCwgZG9jLnNlbC5wcmltSW5kZXgpO1xcbiAgc2V0U2VsZWN0aW9uKGRvYywgbmV3U2VsLCBvcHRpb25zKTtcXG59XFxuXFxuLy8gVXBkYXRlcyBhIHNpbmdsZSByYW5nZSBpbiB0aGUgc2VsZWN0aW9uLlxcbmZ1bmN0aW9uIHJlcGxhY2VPbmVTZWxlY3Rpb24oZG9jLCBpLCByYW5nZSwgb3B0aW9ucykge1xcbiAgdmFyIHJhbmdlcyA9IGRvYy5zZWwucmFuZ2VzLnNsaWNlKDApO1xcbiAgcmFuZ2VzW2ldID0gcmFuZ2U7XFxuICBzZXRTZWxlY3Rpb24oZG9jLCBub3JtYWxpemVTZWxlY3Rpb24ocmFuZ2VzLCBkb2Muc2VsLnByaW1JbmRleCksIG9wdGlvbnMpO1xcbn1cXG5cXG4vLyBSZXNldCB0aGUgc2VsZWN0aW9uIHRvIGEgc2luZ2xlIHJhbmdlLlxcbmZ1bmN0aW9uIHNldFNpbXBsZVNlbGVjdGlvbihkb2MsIGFuY2hvciwgaGVhZCwgb3B0aW9ucykge1xcbiAgc2V0U2VsZWN0aW9uKGRvYywgc2ltcGxlU2VsZWN0aW9uKGFuY2hvciwgaGVhZCksIG9wdGlvbnMpO1xcbn1cXG5cXG4vLyBHaXZlIGJlZm9yZVNlbGVjdGlvbkNoYW5nZSBoYW5kbGVycyBhIGNoYW5nZSB0byBpbmZsdWVuY2UgYVxcbi8vIHNlbGVjdGlvbiB1cGRhdGUuXFxuZnVuY3Rpb24gZmlsdGVyU2VsZWN0aW9uQ2hhbmdlKGRvYywgc2VsLCBvcHRpb25zKSB7XFxuICB2YXIgb2JqID0ge1xcbiAgICByYW5nZXM6IHNlbC5yYW5nZXMsXFxuICAgIHVwZGF0ZTogZnVuY3Rpb24ocmFuZ2VzKSB7XFxuICAgICAgdmFyIHRoaXMkMSA9IHRoaXM7XFxuXFxuICAgICAgdGhpcy5yYW5nZXMgPSBbXTtcXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJhbmdlcy5sZW5ndGg7IGkrKylcXG4gICAgICAgIHsgdGhpcyQxLnJhbmdlc1tpXSA9IG5ldyBSYW5nZShjbGlwUG9zKGRvYywgcmFuZ2VzW2ldLmFuY2hvciksXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGlwUG9zKGRvYywgcmFuZ2VzW2ldLmhlYWQpKTsgfVxcbiAgICB9LFxcbiAgICBvcmlnaW46IG9wdGlvbnMgJiYgb3B0aW9ucy5vcmlnaW5cXG4gIH07XFxuICBzaWduYWwoZG9jLCBcXFwiYmVmb3JlU2VsZWN0aW9uQ2hhbmdlXFxcIiwgZG9jLCBvYmopO1xcbiAgaWYgKGRvYy5jbSkgeyBzaWduYWwoZG9jLmNtLCBcXFwiYmVmb3JlU2VsZWN0aW9uQ2hhbmdlXFxcIiwgZG9jLmNtLCBvYmopOyB9XFxuICBpZiAob2JqLnJhbmdlcyAhPSBzZWwucmFuZ2VzKSB7IHJldHVybiBub3JtYWxpemVTZWxlY3Rpb24ob2JqLnJhbmdlcywgb2JqLnJhbmdlcy5sZW5ndGggLSAxKSB9XFxuICBlbHNlIHsgcmV0dXJuIHNlbCB9XFxufVxcblxcbmZ1bmN0aW9uIHNldFNlbGVjdGlvblJlcGxhY2VIaXN0b3J5KGRvYywgc2VsLCBvcHRpb25zKSB7XFxuICB2YXIgZG9uZSA9IGRvYy5oaXN0b3J5LmRvbmUsIGxhc3QgPSBsc3QoZG9uZSk7XFxuICBpZiAobGFzdCAmJiBsYXN0LnJhbmdlcykge1xcbiAgICBkb25lW2RvbmUubGVuZ3RoIC0gMV0gPSBzZWw7XFxuICAgIHNldFNlbGVjdGlvbk5vVW5kbyhkb2MsIHNlbCwgb3B0aW9ucyk7XFxuICB9IGVsc2Uge1xcbiAgICBzZXRTZWxlY3Rpb24oZG9jLCBzZWwsIG9wdGlvbnMpO1xcbiAgfVxcbn1cXG5cXG4vLyBTZXQgYSBuZXcgc2VsZWN0aW9uLlxcbmZ1bmN0aW9uIHNldFNlbGVjdGlvbihkb2MsIHNlbCwgb3B0aW9ucykge1xcbiAgc2V0U2VsZWN0aW9uTm9VbmRvKGRvYywgc2VsLCBvcHRpb25zKTtcXG4gIGFkZFNlbGVjdGlvblRvSGlzdG9yeShkb2MsIGRvYy5zZWwsIGRvYy5jbSA/IGRvYy5jbS5jdXJPcC5pZCA6IE5hTiwgb3B0aW9ucyk7XFxufVxcblxcbmZ1bmN0aW9uIHNldFNlbGVjdGlvbk5vVW5kbyhkb2MsIHNlbCwgb3B0aW9ucykge1xcbiAgaWYgKGhhc0hhbmRsZXIoZG9jLCBcXFwiYmVmb3JlU2VsZWN0aW9uQ2hhbmdlXFxcIikgfHwgZG9jLmNtICYmIGhhc0hhbmRsZXIoZG9jLmNtLCBcXFwiYmVmb3JlU2VsZWN0aW9uQ2hhbmdlXFxcIikpXFxuICAgIHsgc2VsID0gZmlsdGVyU2VsZWN0aW9uQ2hhbmdlKGRvYywgc2VsLCBvcHRpb25zKTsgfVxcblxcbiAgdmFyIGJpYXMgPSBvcHRpb25zICYmIG9wdGlvbnMuYmlhcyB8fFxcbiAgICAoY21wKHNlbC5wcmltYXJ5KCkuaGVhZCwgZG9jLnNlbC5wcmltYXJ5KCkuaGVhZCkgPCAwID8gLTEgOiAxKTtcXG4gIHNldFNlbGVjdGlvbklubmVyKGRvYywgc2tpcEF0b21pY0luU2VsZWN0aW9uKGRvYywgc2VsLCBiaWFzLCB0cnVlKSk7XFxuXFxuICBpZiAoIShvcHRpb25zICYmIG9wdGlvbnMuc2Nyb2xsID09PSBmYWxzZSkgJiYgZG9jLmNtKVxcbiAgICB7IGVuc3VyZUN1cnNvclZpc2libGUoZG9jLmNtKTsgfVxcbn1cXG5cXG5mdW5jdGlvbiBzZXRTZWxlY3Rpb25Jbm5lcihkb2MsIHNlbCkge1xcbiAgaWYgKHNlbC5lcXVhbHMoZG9jLnNlbCkpIHsgcmV0dXJuIH1cXG5cXG4gIGRvYy5zZWwgPSBzZWw7XFxuXFxuICBpZiAoZG9jLmNtKSB7XFxuICAgIGRvYy5jbS5jdXJPcC51cGRhdGVJbnB1dCA9IGRvYy5jbS5jdXJPcC5zZWxlY3Rpb25DaGFuZ2VkID0gdHJ1ZTtcXG4gICAgc2lnbmFsQ3Vyc29yQWN0aXZpdHkoZG9jLmNtKTtcXG4gIH1cXG4gIHNpZ25hbExhdGVyKGRvYywgXFxcImN1cnNvckFjdGl2aXR5XFxcIiwgZG9jKTtcXG59XFxuXFxuLy8gVmVyaWZ5IHRoYXQgdGhlIHNlbGVjdGlvbiBkb2VzIG5vdCBwYXJ0aWFsbHkgc2VsZWN0IGFueSBhdG9taWNcXG4vLyBtYXJrZWQgcmFuZ2VzLlxcbmZ1bmN0aW9uIHJlQ2hlY2tTZWxlY3Rpb24oZG9jKSB7XFxuICBzZXRTZWxlY3Rpb25Jbm5lcihkb2MsIHNraXBBdG9taWNJblNlbGVjdGlvbihkb2MsIGRvYy5zZWwsIG51bGwsIGZhbHNlKSwgc2VsX2RvbnRTY3JvbGwpO1xcbn1cXG5cXG4vLyBSZXR1cm4gYSBzZWxlY3Rpb24gdGhhdCBkb2VzIG5vdCBwYXJ0aWFsbHkgc2VsZWN0IGFueSBhdG9taWNcXG4vLyByYW5nZXMuXFxuZnVuY3Rpb24gc2tpcEF0b21pY0luU2VsZWN0aW9uKGRvYywgc2VsLCBiaWFzLCBtYXlDbGVhcikge1xcbiAgdmFyIG91dDtcXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc2VsLnJhbmdlcy5sZW5ndGg7IGkrKykge1xcbiAgICB2YXIgcmFuZ2UgPSBzZWwucmFuZ2VzW2ldO1xcbiAgICB2YXIgb2xkID0gc2VsLnJhbmdlcy5sZW5ndGggPT0gZG9jLnNlbC5yYW5nZXMubGVuZ3RoICYmIGRvYy5zZWwucmFuZ2VzW2ldO1xcbiAgICB2YXIgbmV3QW5jaG9yID0gc2tpcEF0b21pYyhkb2MsIHJhbmdlLmFuY2hvciwgb2xkICYmIG9sZC5hbmNob3IsIGJpYXMsIG1heUNsZWFyKTtcXG4gICAgdmFyIG5ld0hlYWQgPSBza2lwQXRvbWljKGRvYywgcmFuZ2UuaGVhZCwgb2xkICYmIG9sZC5oZWFkLCBiaWFzLCBtYXlDbGVhcik7XFxuICAgIGlmIChvdXQgfHwgbmV3QW5jaG9yICE9IHJhbmdlLmFuY2hvciB8fCBuZXdIZWFkICE9IHJhbmdlLmhlYWQpIHtcXG4gICAgICBpZiAoIW91dCkgeyBvdXQgPSBzZWwucmFuZ2VzLnNsaWNlKDAsIGkpOyB9XFxuICAgICAgb3V0W2ldID0gbmV3IFJhbmdlKG5ld0FuY2hvciwgbmV3SGVhZCk7XFxuICAgIH1cXG4gIH1cXG4gIHJldHVybiBvdXQgPyBub3JtYWxpemVTZWxlY3Rpb24ob3V0LCBzZWwucHJpbUluZGV4KSA6IHNlbFxcbn1cXG5cXG5mdW5jdGlvbiBza2lwQXRvbWljSW5uZXIoZG9jLCBwb3MsIG9sZFBvcywgZGlyLCBtYXlDbGVhcikge1xcbiAgdmFyIGxpbmUgPSBnZXRMaW5lKGRvYywgcG9zLmxpbmUpO1xcbiAgaWYgKGxpbmUubWFya2VkU3BhbnMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lLm1hcmtlZFNwYW5zLmxlbmd0aDsgKytpKSB7XFxuICAgIHZhciBzcCA9IGxpbmUubWFya2VkU3BhbnNbaV0sIG0gPSBzcC5tYXJrZXI7XFxuICAgIGlmICgoc3AuZnJvbSA9PSBudWxsIHx8IChtLmluY2x1c2l2ZUxlZnQgPyBzcC5mcm9tIDw9IHBvcy5jaCA6IHNwLmZyb20gPCBwb3MuY2gpKSAmJlxcbiAgICAgICAgKHNwLnRvID09IG51bGwgfHwgKG0uaW5jbHVzaXZlUmlnaHQgPyBzcC50byA+PSBwb3MuY2ggOiBzcC50byA+IHBvcy5jaCkpKSB7XFxuICAgICAgaWYgKG1heUNsZWFyKSB7XFxuICAgICAgICBzaWduYWwobSwgXFxcImJlZm9yZUN1cnNvckVudGVyXFxcIik7XFxuICAgICAgICBpZiAobS5leHBsaWNpdGx5Q2xlYXJlZCkge1xcbiAgICAgICAgICBpZiAoIWxpbmUubWFya2VkU3BhbnMpIHsgYnJlYWsgfVxcbiAgICAgICAgICBlbHNlIHstLWk7IGNvbnRpbnVlfVxcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgICBpZiAoIW0uYXRvbWljKSB7IGNvbnRpbnVlIH1cXG5cXG4gICAgICBpZiAob2xkUG9zKSB7XFxuICAgICAgICB2YXIgbmVhciA9IG0uZmluZChkaXIgPCAwID8gMSA6IC0xKSwgZGlmZiA9ICh2b2lkIDApO1xcbiAgICAgICAgaWYgKGRpciA8IDAgPyBtLmluY2x1c2l2ZVJpZ2h0IDogbS5pbmNsdXNpdmVMZWZ0KVxcbiAgICAgICAgICB7IG5lYXIgPSBtb3ZlUG9zKGRvYywgbmVhciwgLWRpciwgbmVhciAmJiBuZWFyLmxpbmUgPT0gcG9zLmxpbmUgPyBsaW5lIDogbnVsbCk7IH1cXG4gICAgICAgIGlmIChuZWFyICYmIG5lYXIubGluZSA9PSBwb3MubGluZSAmJiAoZGlmZiA9IGNtcChuZWFyLCBvbGRQb3MpKSAmJiAoZGlyIDwgMCA/IGRpZmYgPCAwIDogZGlmZiA+IDApKVxcbiAgICAgICAgICB7IHJldHVybiBza2lwQXRvbWljSW5uZXIoZG9jLCBuZWFyLCBwb3MsIGRpciwgbWF5Q2xlYXIpIH1cXG4gICAgICB9XFxuXFxuICAgICAgdmFyIGZhciA9IG0uZmluZChkaXIgPCAwID8gLTEgOiAxKTtcXG4gICAgICBpZiAoZGlyIDwgMCA/IG0uaW5jbHVzaXZlTGVmdCA6IG0uaW5jbHVzaXZlUmlnaHQpXFxuICAgICAgICB7IGZhciA9IG1vdmVQb3MoZG9jLCBmYXIsIGRpciwgZmFyLmxpbmUgPT0gcG9zLmxpbmUgPyBsaW5lIDogbnVsbCk7IH1cXG4gICAgICByZXR1cm4gZmFyID8gc2tpcEF0b21pY0lubmVyKGRvYywgZmFyLCBwb3MsIGRpciwgbWF5Q2xlYXIpIDogbnVsbFxcbiAgICB9XFxuICB9IH1cXG4gIHJldHVybiBwb3NcXG59XFxuXFxuLy8gRW5zdXJlIGEgZ2l2ZW4gcG9zaXRpb24gaXMgbm90IGluc2lkZSBhbiBhdG9taWMgcmFuZ2UuXFxuZnVuY3Rpb24gc2tpcEF0b21pYyhkb2MsIHBvcywgb2xkUG9zLCBiaWFzLCBtYXlDbGVhcikge1xcbiAgdmFyIGRpciA9IGJpYXMgfHwgMTtcXG4gIHZhciBmb3VuZCA9IHNraXBBdG9taWNJbm5lcihkb2MsIHBvcywgb2xkUG9zLCBkaXIsIG1heUNsZWFyKSB8fFxcbiAgICAgICghbWF5Q2xlYXIgJiYgc2tpcEF0b21pY0lubmVyKGRvYywgcG9zLCBvbGRQb3MsIGRpciwgdHJ1ZSkpIHx8XFxuICAgICAgc2tpcEF0b21pY0lubmVyKGRvYywgcG9zLCBvbGRQb3MsIC1kaXIsIG1heUNsZWFyKSB8fFxcbiAgICAgICghbWF5Q2xlYXIgJiYgc2tpcEF0b21pY0lubmVyKGRvYywgcG9zLCBvbGRQb3MsIC1kaXIsIHRydWUpKTtcXG4gIGlmICghZm91bmQpIHtcXG4gICAgZG9jLmNhbnRFZGl0ID0gdHJ1ZTtcXG4gICAgcmV0dXJuIFBvcyhkb2MuZmlyc3QsIDApXFxuICB9XFxuICByZXR1cm4gZm91bmRcXG59XFxuXFxuZnVuY3Rpb24gbW92ZVBvcyhkb2MsIHBvcywgZGlyLCBsaW5lKSB7XFxuICBpZiAoZGlyIDwgMCAmJiBwb3MuY2ggPT0gMCkge1xcbiAgICBpZiAocG9zLmxpbmUgPiBkb2MuZmlyc3QpIHsgcmV0dXJuIGNsaXBQb3MoZG9jLCBQb3MocG9zLmxpbmUgLSAxKSkgfVxcbiAgICBlbHNlIHsgcmV0dXJuIG51bGwgfVxcbiAgfSBlbHNlIGlmIChkaXIgPiAwICYmIHBvcy5jaCA9PSAobGluZSB8fCBnZXRMaW5lKGRvYywgcG9zLmxpbmUpKS50ZXh0Lmxlbmd0aCkge1xcbiAgICBpZiAocG9zLmxpbmUgPCBkb2MuZmlyc3QgKyBkb2Muc2l6ZSAtIDEpIHsgcmV0dXJuIFBvcyhwb3MubGluZSArIDEsIDApIH1cXG4gICAgZWxzZSB7IHJldHVybiBudWxsIH1cXG4gIH0gZWxzZSB7XFxuICAgIHJldHVybiBuZXcgUG9zKHBvcy5saW5lLCBwb3MuY2ggKyBkaXIpXFxuICB9XFxufVxcblxcbmZ1bmN0aW9uIHNlbGVjdEFsbChjbSkge1xcbiAgY20uc2V0U2VsZWN0aW9uKFBvcyhjbS5maXJzdExpbmUoKSwgMCksIFBvcyhjbS5sYXN0TGluZSgpKSwgc2VsX2RvbnRTY3JvbGwpO1xcbn1cXG5cXG4vLyBVUERBVElOR1xcblxcbi8vIEFsbG93IFxcXCJiZWZvcmVDaGFuZ2VcXFwiIGV2ZW50IGhhbmRsZXJzIHRvIGluZmx1ZW5jZSBhIGNoYW5nZVxcbmZ1bmN0aW9uIGZpbHRlckNoYW5nZShkb2MsIGNoYW5nZSwgdXBkYXRlKSB7XFxuICB2YXIgb2JqID0ge1xcbiAgICBjYW5jZWxlZDogZmFsc2UsXFxuICAgIGZyb206IGNoYW5nZS5mcm9tLFxcbiAgICB0bzogY2hhbmdlLnRvLFxcbiAgICB0ZXh0OiBjaGFuZ2UudGV4dCxcXG4gICAgb3JpZ2luOiBjaGFuZ2Uub3JpZ2luLFxcbiAgICBjYW5jZWw6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG9iai5jYW5jZWxlZCA9IHRydWU7IH1cXG4gIH07XFxuICBpZiAodXBkYXRlKSB7IG9iai51cGRhdGUgPSBmdW5jdGlvbiAoZnJvbSwgdG8sIHRleHQsIG9yaWdpbikge1xcbiAgICBpZiAoZnJvbSkgeyBvYmouZnJvbSA9IGNsaXBQb3MoZG9jLCBmcm9tKTsgfVxcbiAgICBpZiAodG8pIHsgb2JqLnRvID0gY2xpcFBvcyhkb2MsIHRvKTsgfVxcbiAgICBpZiAodGV4dCkgeyBvYmoudGV4dCA9IHRleHQ7IH1cXG4gICAgaWYgKG9yaWdpbiAhPT0gdW5kZWZpbmVkKSB7IG9iai5vcmlnaW4gPSBvcmlnaW47IH1cXG4gIH07IH1cXG4gIHNpZ25hbChkb2MsIFxcXCJiZWZvcmVDaGFuZ2VcXFwiLCBkb2MsIG9iaik7XFxuICBpZiAoZG9jLmNtKSB7IHNpZ25hbChkb2MuY20sIFxcXCJiZWZvcmVDaGFuZ2VcXFwiLCBkb2MuY20sIG9iaik7IH1cXG5cXG4gIGlmIChvYmouY2FuY2VsZWQpIHsgcmV0dXJuIG51bGwgfVxcbiAgcmV0dXJuIHtmcm9tOiBvYmouZnJvbSwgdG86IG9iai50bywgdGV4dDogb2JqLnRleHQsIG9yaWdpbjogb2JqLm9yaWdpbn1cXG59XFxuXFxuLy8gQXBwbHkgYSBjaGFuZ2UgdG8gYSBkb2N1bWVudCwgYW5kIGFkZCBpdCB0byB0aGUgZG9jdW1lbnQnc1xcbi8vIGhpc3RvcnksIGFuZCBwcm9wYWdhdGluZyBpdCB0byBhbGwgbGlua2VkIGRvY3VtZW50cy5cXG5mdW5jdGlvbiBtYWtlQ2hhbmdlKGRvYywgY2hhbmdlLCBpZ25vcmVSZWFkT25seSkge1xcbiAgaWYgKGRvYy5jbSkge1xcbiAgICBpZiAoIWRvYy5jbS5jdXJPcCkgeyByZXR1cm4gb3BlcmF0aW9uKGRvYy5jbSwgbWFrZUNoYW5nZSkoZG9jLCBjaGFuZ2UsIGlnbm9yZVJlYWRPbmx5KSB9XFxuICAgIGlmIChkb2MuY20uc3RhdGUuc3VwcHJlc3NFZGl0cykgeyByZXR1cm4gfVxcbiAgfVxcblxcbiAgaWYgKGhhc0hhbmRsZXIoZG9jLCBcXFwiYmVmb3JlQ2hhbmdlXFxcIikgfHwgZG9jLmNtICYmIGhhc0hhbmRsZXIoZG9jLmNtLCBcXFwiYmVmb3JlQ2hhbmdlXFxcIikpIHtcXG4gICAgY2hhbmdlID0gZmlsdGVyQ2hhbmdlKGRvYywgY2hhbmdlLCB0cnVlKTtcXG4gICAgaWYgKCFjaGFuZ2UpIHsgcmV0dXJuIH1cXG4gIH1cXG5cXG4gIC8vIFBvc3NpYmx5IHNwbGl0IG9yIHN1cHByZXNzIHRoZSB1cGRhdGUgYmFzZWQgb24gdGhlIHByZXNlbmNlXFxuICAvLyBvZiByZWFkLW9ubHkgc3BhbnMgaW4gaXRzIHJhbmdlLlxcbiAgdmFyIHNwbGl0ID0gc2F3UmVhZE9ubHlTcGFucyAmJiAhaWdub3JlUmVhZE9ubHkgJiYgcmVtb3ZlUmVhZE9ubHlSYW5nZXMoZG9jLCBjaGFuZ2UuZnJvbSwgY2hhbmdlLnRvKTtcXG4gIGlmIChzcGxpdCkge1xcbiAgICBmb3IgKHZhciBpID0gc3BsaXQubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpXFxuICAgICAgeyBtYWtlQ2hhbmdlSW5uZXIoZG9jLCB7ZnJvbTogc3BsaXRbaV0uZnJvbSwgdG86IHNwbGl0W2ldLnRvLCB0ZXh0OiBpID8gW1xcXCJcXFwiXSA6IGNoYW5nZS50ZXh0fSk7IH1cXG4gIH0gZWxzZSB7XFxuICAgIG1ha2VDaGFuZ2VJbm5lcihkb2MsIGNoYW5nZSk7XFxuICB9XFxufVxcblxcbmZ1bmN0aW9uIG1ha2VDaGFuZ2VJbm5lcihkb2MsIGNoYW5nZSkge1xcbiAgaWYgKGNoYW5nZS50ZXh0Lmxlbmd0aCA9PSAxICYmIGNoYW5nZS50ZXh0WzBdID09IFxcXCJcXFwiICYmIGNtcChjaGFuZ2UuZnJvbSwgY2hhbmdlLnRvKSA9PSAwKSB7IHJldHVybiB9XFxuICB2YXIgc2VsQWZ0ZXIgPSBjb21wdXRlU2VsQWZ0ZXJDaGFuZ2UoZG9jLCBjaGFuZ2UpO1xcbiAgYWRkQ2hhbmdlVG9IaXN0b3J5KGRvYywgY2hhbmdlLCBzZWxBZnRlciwgZG9jLmNtID8gZG9jLmNtLmN1ck9wLmlkIDogTmFOKTtcXG5cXG4gIG1ha2VDaGFuZ2VTaW5nbGVEb2MoZG9jLCBjaGFuZ2UsIHNlbEFmdGVyLCBzdHJldGNoU3BhbnNPdmVyQ2hhbmdlKGRvYywgY2hhbmdlKSk7XFxuICB2YXIgcmViYXNlZCA9IFtdO1xcblxcbiAgbGlua2VkRG9jcyhkb2MsIGZ1bmN0aW9uIChkb2MsIHNoYXJlZEhpc3QpIHtcXG4gICAgaWYgKCFzaGFyZWRIaXN0ICYmIGluZGV4T2YocmViYXNlZCwgZG9jLmhpc3RvcnkpID09IC0xKSB7XFxuICAgICAgcmViYXNlSGlzdChkb2MuaGlzdG9yeSwgY2hhbmdlKTtcXG4gICAgICByZWJhc2VkLnB1c2goZG9jLmhpc3RvcnkpO1xcbiAgICB9XFxuICAgIG1ha2VDaGFuZ2VTaW5nbGVEb2MoZG9jLCBjaGFuZ2UsIG51bGwsIHN0cmV0Y2hTcGFuc092ZXJDaGFuZ2UoZG9jLCBjaGFuZ2UpKTtcXG4gIH0pO1xcbn1cXG5cXG4vLyBSZXZlcnQgYSBjaGFuZ2Ugc3RvcmVkIGluIGEgZG9jdW1lbnQncyBoaXN0b3J5LlxcbmZ1bmN0aW9uIG1ha2VDaGFuZ2VGcm9tSGlzdG9yeShkb2MsIHR5cGUsIGFsbG93U2VsZWN0aW9uT25seSkge1xcbiAgaWYgKGRvYy5jbSAmJiBkb2MuY20uc3RhdGUuc3VwcHJlc3NFZGl0cyAmJiAhYWxsb3dTZWxlY3Rpb25Pbmx5KSB7IHJldHVybiB9XFxuXFxuICB2YXIgaGlzdCA9IGRvYy5oaXN0b3J5LCBldmVudCwgc2VsQWZ0ZXIgPSBkb2Muc2VsO1xcbiAgdmFyIHNvdXJjZSA9IHR5cGUgPT0gXFxcInVuZG9cXFwiID8gaGlzdC5kb25lIDogaGlzdC51bmRvbmUsIGRlc3QgPSB0eXBlID09IFxcXCJ1bmRvXFxcIiA/IGhpc3QudW5kb25lIDogaGlzdC5kb25lO1xcblxcbiAgLy8gVmVyaWZ5IHRoYXQgdGhlcmUgaXMgYSB1c2VhYmxlIGV2ZW50IChzbyB0aGF0IGN0cmwteiB3b24ndFxcbiAgLy8gbmVlZGxlc3NseSBjbGVhciBzZWxlY3Rpb24gZXZlbnRzKVxcbiAgdmFyIGkgPSAwO1xcbiAgZm9yICg7IGkgPCBzb3VyY2UubGVuZ3RoOyBpKyspIHtcXG4gICAgZXZlbnQgPSBzb3VyY2VbaV07XFxuICAgIGlmIChhbGxvd1NlbGVjdGlvbk9ubHkgPyBldmVudC5yYW5nZXMgJiYgIWV2ZW50LmVxdWFscyhkb2Muc2VsKSA6ICFldmVudC5yYW5nZXMpXFxuICAgICAgeyBicmVhayB9XFxuICB9XFxuICBpZiAoaSA9PSBzb3VyY2UubGVuZ3RoKSB7IHJldHVybiB9XFxuICBoaXN0Lmxhc3RPcmlnaW4gPSBoaXN0Lmxhc3RTZWxPcmlnaW4gPSBudWxsO1xcblxcbiAgZm9yICg7Oykge1xcbiAgICBldmVudCA9IHNvdXJjZS5wb3AoKTtcXG4gICAgaWYgKGV2ZW50LnJhbmdlcykge1xcbiAgICAgIHB1c2hTZWxlY3Rpb25Ub0hpc3RvcnkoZXZlbnQsIGRlc3QpO1xcbiAgICAgIGlmIChhbGxvd1NlbGVjdGlvbk9ubHkgJiYgIWV2ZW50LmVxdWFscyhkb2Muc2VsKSkge1xcbiAgICAgICAgc2V0U2VsZWN0aW9uKGRvYywgZXZlbnQsIHtjbGVhclJlZG86IGZhbHNlfSk7XFxuICAgICAgICByZXR1cm5cXG4gICAgICB9XFxuICAgICAgc2VsQWZ0ZXIgPSBldmVudDtcXG4gICAgfVxcbiAgICBlbHNlIHsgYnJlYWsgfVxcbiAgfVxcblxcbiAgLy8gQnVpbGQgdXAgYSByZXZlcnNlIGNoYW5nZSBvYmplY3QgdG8gYWRkIHRvIHRoZSBvcHBvc2l0ZSBoaXN0b3J5XFxuICAvLyBzdGFjayAocmVkbyB3aGVuIHVuZG9pbmcsIGFuZCB2aWNlIHZlcnNhKS5cXG4gIHZhciBhbnRpQ2hhbmdlcyA9IFtdO1xcbiAgcHVzaFNlbGVjdGlvblRvSGlzdG9yeShzZWxBZnRlciwgZGVzdCk7XFxuICBkZXN0LnB1c2goe2NoYW5nZXM6IGFudGlDaGFuZ2VzLCBnZW5lcmF0aW9uOiBoaXN0LmdlbmVyYXRpb259KTtcXG4gIGhpc3QuZ2VuZXJhdGlvbiA9IGV2ZW50LmdlbmVyYXRpb24gfHwgKytoaXN0Lm1heEdlbmVyYXRpb247XFxuXFxuICB2YXIgZmlsdGVyID0gaGFzSGFuZGxlcihkb2MsIFxcXCJiZWZvcmVDaGFuZ2VcXFwiKSB8fCBkb2MuY20gJiYgaGFzSGFuZGxlcihkb2MuY20sIFxcXCJiZWZvcmVDaGFuZ2VcXFwiKTtcXG5cXG4gIHZhciBsb29wID0gZnVuY3Rpb24gKCBpICkge1xcbiAgICB2YXIgY2hhbmdlID0gZXZlbnQuY2hhbmdlc1tpXTtcXG4gICAgY2hhbmdlLm9yaWdpbiA9IHR5cGU7XFxuICAgIGlmIChmaWx0ZXIgJiYgIWZpbHRlckNoYW5nZShkb2MsIGNoYW5nZSwgZmFsc2UpKSB7XFxuICAgICAgc291cmNlLmxlbmd0aCA9IDA7XFxuICAgICAgcmV0dXJuIHt9XFxuICAgIH1cXG5cXG4gICAgYW50aUNoYW5nZXMucHVzaChoaXN0b3J5Q2hhbmdlRnJvbUNoYW5nZShkb2MsIGNoYW5nZSkpO1xcblxcbiAgICB2YXIgYWZ0ZXIgPSBpID8gY29tcHV0ZVNlbEFmdGVyQ2hhbmdlKGRvYywgY2hhbmdlKSA6IGxzdChzb3VyY2UpO1xcbiAgICBtYWtlQ2hhbmdlU2luZ2xlRG9jKGRvYywgY2hhbmdlLCBhZnRlciwgbWVyZ2VPbGRTcGFucyhkb2MsIGNoYW5nZSkpO1xcbiAgICBpZiAoIWkgJiYgZG9jLmNtKSB7IGRvYy5jbS5zY3JvbGxJbnRvVmlldyh7ZnJvbTogY2hhbmdlLmZyb20sIHRvOiBjaGFuZ2VFbmQoY2hhbmdlKX0pOyB9XFxuICAgIHZhciByZWJhc2VkID0gW107XFxuXFxuICAgIC8vIFByb3BhZ2F0ZSB0byB0aGUgbGlua2VkIGRvY3VtZW50c1xcbiAgICBsaW5rZWREb2NzKGRvYywgZnVuY3Rpb24gKGRvYywgc2hhcmVkSGlzdCkge1xcbiAgICAgIGlmICghc2hhcmVkSGlzdCAmJiBpbmRleE9mKHJlYmFzZWQsIGRvYy5oaXN0b3J5KSA9PSAtMSkge1xcbiAgICAgICAgcmViYXNlSGlzdChkb2MuaGlzdG9yeSwgY2hhbmdlKTtcXG4gICAgICAgIHJlYmFzZWQucHVzaChkb2MuaGlzdG9yeSk7XFxuICAgICAgfVxcbiAgICAgIG1ha2VDaGFuZ2VTaW5nbGVEb2MoZG9jLCBjaGFuZ2UsIG51bGwsIG1lcmdlT2xkU3BhbnMoZG9jLCBjaGFuZ2UpKTtcXG4gICAgfSk7XFxuICB9O1xcblxcbiAgZm9yICh2YXIgaSQxID0gZXZlbnQuY2hhbmdlcy5sZW5ndGggLSAxOyBpJDEgPj0gMDsgLS1pJDEpIHtcXG4gICAgdmFyIHJldHVybmVkID0gbG9vcCggaSQxICk7XFxuXFxuICAgIGlmICggcmV0dXJuZWQgKSByZXR1cm4gcmV0dXJuZWQudjtcXG4gIH1cXG59XFxuXFxuLy8gU3ViLXZpZXdzIG5lZWQgdGhlaXIgbGluZSBudW1iZXJzIHNoaWZ0ZWQgd2hlbiB0ZXh0IGlzIGFkZGVkXFxuLy8gYWJvdmUgb3IgYmVsb3cgdGhlbSBpbiB0aGUgcGFyZW50IGRvY3VtZW50LlxcbmZ1bmN0aW9uIHNoaWZ0RG9jKGRvYywgZGlzdGFuY2UpIHtcXG4gIGlmIChkaXN0YW5jZSA9PSAwKSB7IHJldHVybiB9XFxuICBkb2MuZmlyc3QgKz0gZGlzdGFuY2U7XFxuICBkb2Muc2VsID0gbmV3IFNlbGVjdGlvbihtYXAoZG9jLnNlbC5yYW5nZXMsIGZ1bmN0aW9uIChyYW5nZSkgeyByZXR1cm4gbmV3IFJhbmdlKFxcbiAgICBQb3MocmFuZ2UuYW5jaG9yLmxpbmUgKyBkaXN0YW5jZSwgcmFuZ2UuYW5jaG9yLmNoKSxcXG4gICAgUG9zKHJhbmdlLmhlYWQubGluZSArIGRpc3RhbmNlLCByYW5nZS5oZWFkLmNoKVxcbiAgKTsgfSksIGRvYy5zZWwucHJpbUluZGV4KTtcXG4gIGlmIChkb2MuY20pIHtcXG4gICAgcmVnQ2hhbmdlKGRvYy5jbSwgZG9jLmZpcnN0LCBkb2MuZmlyc3QgLSBkaXN0YW5jZSwgZGlzdGFuY2UpO1xcbiAgICBmb3IgKHZhciBkID0gZG9jLmNtLmRpc3BsYXksIGwgPSBkLnZpZXdGcm9tOyBsIDwgZC52aWV3VG87IGwrKylcXG4gICAgICB7IHJlZ0xpbmVDaGFuZ2UoZG9jLmNtLCBsLCBcXFwiZ3V0dGVyXFxcIik7IH1cXG4gIH1cXG59XFxuXFxuLy8gTW9yZSBsb3dlci1sZXZlbCBjaGFuZ2UgZnVuY3Rpb24sIGhhbmRsaW5nIG9ubHkgYSBzaW5nbGUgZG9jdW1lbnRcXG4vLyAobm90IGxpbmtlZCBvbmVzKS5cXG5mdW5jdGlvbiBtYWtlQ2hhbmdlU2luZ2xlRG9jKGRvYywgY2hhbmdlLCBzZWxBZnRlciwgc3BhbnMpIHtcXG4gIGlmIChkb2MuY20gJiYgIWRvYy5jbS5jdXJPcClcXG4gICAgeyByZXR1cm4gb3BlcmF0aW9uKGRvYy5jbSwgbWFrZUNoYW5nZVNpbmdsZURvYykoZG9jLCBjaGFuZ2UsIHNlbEFmdGVyLCBzcGFucykgfVxcblxcbiAgaWYgKGNoYW5nZS50by5saW5lIDwgZG9jLmZpcnN0KSB7XFxuICAgIHNoaWZ0RG9jKGRvYywgY2hhbmdlLnRleHQubGVuZ3RoIC0gMSAtIChjaGFuZ2UudG8ubGluZSAtIGNoYW5nZS5mcm9tLmxpbmUpKTtcXG4gICAgcmV0dXJuXFxuICB9XFxuICBpZiAoY2hhbmdlLmZyb20ubGluZSA+IGRvYy5sYXN0TGluZSgpKSB7IHJldHVybiB9XFxuXFxuICAvLyBDbGlwIHRoZSBjaGFuZ2UgdG8gdGhlIHNpemUgb2YgdGhpcyBkb2NcXG4gIGlmIChjaGFuZ2UuZnJvbS5saW5lIDwgZG9jLmZpcnN0KSB7XFxuICAgIHZhciBzaGlmdCA9IGNoYW5nZS50ZXh0Lmxlbmd0aCAtIDEgLSAoZG9jLmZpcnN0IC0gY2hhbmdlLmZyb20ubGluZSk7XFxuICAgIHNoaWZ0RG9jKGRvYywgc2hpZnQpO1xcbiAgICBjaGFuZ2UgPSB7ZnJvbTogUG9zKGRvYy5maXJzdCwgMCksIHRvOiBQb3MoY2hhbmdlLnRvLmxpbmUgKyBzaGlmdCwgY2hhbmdlLnRvLmNoKSxcXG4gICAgICAgICAgICAgIHRleHQ6IFtsc3QoY2hhbmdlLnRleHQpXSwgb3JpZ2luOiBjaGFuZ2Uub3JpZ2lufTtcXG4gIH1cXG4gIHZhciBsYXN0ID0gZG9jLmxhc3RMaW5lKCk7XFxuICBpZiAoY2hhbmdlLnRvLmxpbmUgPiBsYXN0KSB7XFxuICAgIGNoYW5nZSA9IHtmcm9tOiBjaGFuZ2UuZnJvbSwgdG86IFBvcyhsYXN0LCBnZXRMaW5lKGRvYywgbGFzdCkudGV4dC5sZW5ndGgpLFxcbiAgICAgICAgICAgICAgdGV4dDogW2NoYW5nZS50ZXh0WzBdXSwgb3JpZ2luOiBjaGFuZ2Uub3JpZ2lufTtcXG4gIH1cXG5cXG4gIGNoYW5nZS5yZW1vdmVkID0gZ2V0QmV0d2Vlbihkb2MsIGNoYW5nZS5mcm9tLCBjaGFuZ2UudG8pO1xcblxcbiAgaWYgKCFzZWxBZnRlcikgeyBzZWxBZnRlciA9IGNvbXB1dGVTZWxBZnRlckNoYW5nZShkb2MsIGNoYW5nZSk7IH1cXG4gIGlmIChkb2MuY20pIHsgbWFrZUNoYW5nZVNpbmdsZURvY0luRWRpdG9yKGRvYy5jbSwgY2hhbmdlLCBzcGFucyk7IH1cXG4gIGVsc2UgeyB1cGRhdGVEb2MoZG9jLCBjaGFuZ2UsIHNwYW5zKTsgfVxcbiAgc2V0U2VsZWN0aW9uTm9VbmRvKGRvYywgc2VsQWZ0ZXIsIHNlbF9kb250U2Nyb2xsKTtcXG59XFxuXFxuLy8gSGFuZGxlIHRoZSBpbnRlcmFjdGlvbiBvZiBhIGNoYW5nZSB0byBhIGRvY3VtZW50IHdpdGggdGhlIGVkaXRvclxcbi8vIHRoYXQgdGhpcyBkb2N1bWVudCBpcyBwYXJ0IG9mLlxcbmZ1bmN0aW9uIG1ha2VDaGFuZ2VTaW5nbGVEb2NJbkVkaXRvcihjbSwgY2hhbmdlLCBzcGFucykge1xcbiAgdmFyIGRvYyA9IGNtLmRvYywgZGlzcGxheSA9IGNtLmRpc3BsYXksIGZyb20gPSBjaGFuZ2UuZnJvbSwgdG8gPSBjaGFuZ2UudG87XFxuXFxuICB2YXIgcmVjb21wdXRlTWF4TGVuZ3RoID0gZmFsc2UsIGNoZWNrV2lkdGhTdGFydCA9IGZyb20ubGluZTtcXG4gIGlmICghY20ub3B0aW9ucy5saW5lV3JhcHBpbmcpIHtcXG4gICAgY2hlY2tXaWR0aFN0YXJ0ID0gbGluZU5vKHZpc3VhbExpbmUoZ2V0TGluZShkb2MsIGZyb20ubGluZSkpKTtcXG4gICAgZG9jLml0ZXIoY2hlY2tXaWR0aFN0YXJ0LCB0by5saW5lICsgMSwgZnVuY3Rpb24gKGxpbmUpIHtcXG4gICAgICBpZiAobGluZSA9PSBkaXNwbGF5Lm1heExpbmUpIHtcXG4gICAgICAgIHJlY29tcHV0ZU1heExlbmd0aCA9IHRydWU7XFxuICAgICAgICByZXR1cm4gdHJ1ZVxcbiAgICAgIH1cXG4gICAgfSk7XFxuICB9XFxuXFxuICBpZiAoZG9jLnNlbC5jb250YWlucyhjaGFuZ2UuZnJvbSwgY2hhbmdlLnRvKSA+IC0xKVxcbiAgICB7IHNpZ25hbEN1cnNvckFjdGl2aXR5KGNtKTsgfVxcblxcbiAgdXBkYXRlRG9jKGRvYywgY2hhbmdlLCBzcGFucywgZXN0aW1hdGVIZWlnaHQoY20pKTtcXG5cXG4gIGlmICghY20ub3B0aW9ucy5saW5lV3JhcHBpbmcpIHtcXG4gICAgZG9jLml0ZXIoY2hlY2tXaWR0aFN0YXJ0LCBmcm9tLmxpbmUgKyBjaGFuZ2UudGV4dC5sZW5ndGgsIGZ1bmN0aW9uIChsaW5lKSB7XFxuICAgICAgdmFyIGxlbiA9IGxpbmVMZW5ndGgobGluZSk7XFxuICAgICAgaWYgKGxlbiA+IGRpc3BsYXkubWF4TGluZUxlbmd0aCkge1xcbiAgICAgICAgZGlzcGxheS5tYXhMaW5lID0gbGluZTtcXG4gICAgICAgIGRpc3BsYXkubWF4TGluZUxlbmd0aCA9IGxlbjtcXG4gICAgICAgIGRpc3BsYXkubWF4TGluZUNoYW5nZWQgPSB0cnVlO1xcbiAgICAgICAgcmVjb21wdXRlTWF4TGVuZ3RoID0gZmFsc2U7XFxuICAgICAgfVxcbiAgICB9KTtcXG4gICAgaWYgKHJlY29tcHV0ZU1heExlbmd0aCkgeyBjbS5jdXJPcC51cGRhdGVNYXhMaW5lID0gdHJ1ZTsgfVxcbiAgfVxcblxcbiAgLy8gQWRqdXN0IGZyb250aWVyLCBzY2hlZHVsZSB3b3JrZXJcXG4gIGRvYy5mcm9udGllciA9IE1hdGgubWluKGRvYy5mcm9udGllciwgZnJvbS5saW5lKTtcXG4gIHN0YXJ0V29ya2VyKGNtLCA0MDApO1xcblxcbiAgdmFyIGxlbmRpZmYgPSBjaGFuZ2UudGV4dC5sZW5ndGggLSAodG8ubGluZSAtIGZyb20ubGluZSkgLSAxO1xcbiAgLy8gUmVtZW1iZXIgdGhhdCB0aGVzZSBsaW5lcyBjaGFuZ2VkLCBmb3IgdXBkYXRpbmcgdGhlIGRpc3BsYXlcXG4gIGlmIChjaGFuZ2UuZnVsbClcXG4gICAgeyByZWdDaGFuZ2UoY20pOyB9XFxuICBlbHNlIGlmIChmcm9tLmxpbmUgPT0gdG8ubGluZSAmJiBjaGFuZ2UudGV4dC5sZW5ndGggPT0gMSAmJiAhaXNXaG9sZUxpbmVVcGRhdGUoY20uZG9jLCBjaGFuZ2UpKVxcbiAgICB7IHJlZ0xpbmVDaGFuZ2UoY20sIGZyb20ubGluZSwgXFxcInRleHRcXFwiKTsgfVxcbiAgZWxzZVxcbiAgICB7IHJlZ0NoYW5nZShjbSwgZnJvbS5saW5lLCB0by5saW5lICsgMSwgbGVuZGlmZik7IH1cXG5cXG4gIHZhciBjaGFuZ2VzSGFuZGxlciA9IGhhc0hhbmRsZXIoY20sIFxcXCJjaGFuZ2VzXFxcIiksIGNoYW5nZUhhbmRsZXIgPSBoYXNIYW5kbGVyKGNtLCBcXFwiY2hhbmdlXFxcIik7XFxuICBpZiAoY2hhbmdlSGFuZGxlciB8fCBjaGFuZ2VzSGFuZGxlcikge1xcbiAgICB2YXIgb2JqID0ge1xcbiAgICAgIGZyb206IGZyb20sIHRvOiB0byxcXG4gICAgICB0ZXh0OiBjaGFuZ2UudGV4dCxcXG4gICAgICByZW1vdmVkOiBjaGFuZ2UucmVtb3ZlZCxcXG4gICAgICBvcmlnaW46IGNoYW5nZS5vcmlnaW5cXG4gICAgfTtcXG4gICAgaWYgKGNoYW5nZUhhbmRsZXIpIHsgc2lnbmFsTGF0ZXIoY20sIFxcXCJjaGFuZ2VcXFwiLCBjbSwgb2JqKTsgfVxcbiAgICBpZiAoY2hhbmdlc0hhbmRsZXIpIHsgKGNtLmN1ck9wLmNoYW5nZU9ianMgfHwgKGNtLmN1ck9wLmNoYW5nZU9ianMgPSBbXSkpLnB1c2gob2JqKTsgfVxcbiAgfVxcbiAgY20uZGlzcGxheS5zZWxGb3JDb250ZXh0TWVudSA9IG51bGw7XFxufVxcblxcbmZ1bmN0aW9uIHJlcGxhY2VSYW5nZShkb2MsIGNvZGUsIGZyb20sIHRvLCBvcmlnaW4pIHtcXG4gIGlmICghdG8pIHsgdG8gPSBmcm9tOyB9XFxuICBpZiAoY21wKHRvLCBmcm9tKSA8IDApIHsgdmFyIHRtcCA9IHRvOyB0byA9IGZyb207IGZyb20gPSB0bXA7IH1cXG4gIGlmICh0eXBlb2YgY29kZSA9PSBcXFwic3RyaW5nXFxcIikgeyBjb2RlID0gZG9jLnNwbGl0TGluZXMoY29kZSk7IH1cXG4gIG1ha2VDaGFuZ2UoZG9jLCB7ZnJvbTogZnJvbSwgdG86IHRvLCB0ZXh0OiBjb2RlLCBvcmlnaW46IG9yaWdpbn0pO1xcbn1cXG5cXG4vLyBSZWJhc2luZy9yZXNldHRpbmcgaGlzdG9yeSB0byBkZWFsIHdpdGggZXh0ZXJuYWxseS1zb3VyY2VkIGNoYW5nZXNcXG5cXG5mdW5jdGlvbiByZWJhc2VIaXN0U2VsU2luZ2xlKHBvcywgZnJvbSwgdG8sIGRpZmYpIHtcXG4gIGlmICh0byA8IHBvcy5saW5lKSB7XFxuICAgIHBvcy5saW5lICs9IGRpZmY7XFxuICB9IGVsc2UgaWYgKGZyb20gPCBwb3MubGluZSkge1xcbiAgICBwb3MubGluZSA9IGZyb207XFxuICAgIHBvcy5jaCA9IDA7XFxuICB9XFxufVxcblxcbi8vIFRyaWVzIHRvIHJlYmFzZSBhbiBhcnJheSBvZiBoaXN0b3J5IGV2ZW50cyBnaXZlbiBhIGNoYW5nZSBpbiB0aGVcXG4vLyBkb2N1bWVudC4gSWYgdGhlIGNoYW5nZSB0b3VjaGVzIHRoZSBzYW1lIGxpbmVzIGFzIHRoZSBldmVudCwgdGhlXFxuLy8gZXZlbnQsIGFuZCBldmVyeXRoaW5nICdiZWhpbmQnIGl0LCBpcyBkaXNjYXJkZWQuIElmIHRoZSBjaGFuZ2UgaXNcXG4vLyBiZWZvcmUgdGhlIGV2ZW50LCB0aGUgZXZlbnQncyBwb3NpdGlvbnMgYXJlIHVwZGF0ZWQuIFVzZXMgYVxcbi8vIGNvcHktb24td3JpdGUgc2NoZW1lIGZvciB0aGUgcG9zaXRpb25zLCB0byBhdm9pZCBoYXZpbmcgdG9cXG4vLyByZWFsbG9jYXRlIHRoZW0gYWxsIG9uIGV2ZXJ5IHJlYmFzZSwgYnV0IGFsc28gYXZvaWQgcHJvYmxlbXMgd2l0aFxcbi8vIHNoYXJlZCBwb3NpdGlvbiBvYmplY3RzIGJlaW5nIHVuc2FmZWx5IHVwZGF0ZWQuXFxuZnVuY3Rpb24gcmViYXNlSGlzdEFycmF5KGFycmF5LCBmcm9tLCB0bywgZGlmZikge1xcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7ICsraSkge1xcbiAgICB2YXIgc3ViID0gYXJyYXlbaV0sIG9rID0gdHJ1ZTtcXG4gICAgaWYgKHN1Yi5yYW5nZXMpIHtcXG4gICAgICBpZiAoIXN1Yi5jb3BpZWQpIHsgc3ViID0gYXJyYXlbaV0gPSBzdWIuZGVlcENvcHkoKTsgc3ViLmNvcGllZCA9IHRydWU7IH1cXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHN1Yi5yYW5nZXMubGVuZ3RoOyBqKyspIHtcXG4gICAgICAgIHJlYmFzZUhpc3RTZWxTaW5nbGUoc3ViLnJhbmdlc1tqXS5hbmNob3IsIGZyb20sIHRvLCBkaWZmKTtcXG4gICAgICAgIHJlYmFzZUhpc3RTZWxTaW5nbGUoc3ViLnJhbmdlc1tqXS5oZWFkLCBmcm9tLCB0bywgZGlmZik7XFxuICAgICAgfVxcbiAgICAgIGNvbnRpbnVlXFxuICAgIH1cXG4gICAgZm9yICh2YXIgaiQxID0gMDsgaiQxIDwgc3ViLmNoYW5nZXMubGVuZ3RoOyArK2okMSkge1xcbiAgICAgIHZhciBjdXIgPSBzdWIuY2hhbmdlc1tqJDFdO1xcbiAgICAgIGlmICh0byA8IGN1ci5mcm9tLmxpbmUpIHtcXG4gICAgICAgIGN1ci5mcm9tID0gUG9zKGN1ci5mcm9tLmxpbmUgKyBkaWZmLCBjdXIuZnJvbS5jaCk7XFxuICAgICAgICBjdXIudG8gPSBQb3MoY3VyLnRvLmxpbmUgKyBkaWZmLCBjdXIudG8uY2gpO1xcbiAgICAgIH0gZWxzZSBpZiAoZnJvbSA8PSBjdXIudG8ubGluZSkge1xcbiAgICAgICAgb2sgPSBmYWxzZTtcXG4gICAgICAgIGJyZWFrXFxuICAgICAgfVxcbiAgICB9XFxuICAgIGlmICghb2spIHtcXG4gICAgICBhcnJheS5zcGxpY2UoMCwgaSArIDEpO1xcbiAgICAgIGkgPSAwO1xcbiAgICB9XFxuICB9XFxufVxcblxcbmZ1bmN0aW9uIHJlYmFzZUhpc3QoaGlzdCwgY2hhbmdlKSB7XFxuICB2YXIgZnJvbSA9IGNoYW5nZS5mcm9tLmxpbmUsIHRvID0gY2hhbmdlLnRvLmxpbmUsIGRpZmYgPSBjaGFuZ2UudGV4dC5sZW5ndGggLSAodG8gLSBmcm9tKSAtIDE7XFxuICByZWJhc2VIaXN0QXJyYXkoaGlzdC5kb25lLCBmcm9tLCB0bywgZGlmZik7XFxuICByZWJhc2VIaXN0QXJyYXkoaGlzdC51bmRvbmUsIGZyb20sIHRvLCBkaWZmKTtcXG59XFxuXFxuLy8gVXRpbGl0eSBmb3IgYXBwbHlpbmcgYSBjaGFuZ2UgdG8gYSBsaW5lIGJ5IGhhbmRsZSBvciBudW1iZXIsXFxuLy8gcmV0dXJuaW5nIHRoZSBudW1iZXIgYW5kIG9wdGlvbmFsbHkgcmVnaXN0ZXJpbmcgdGhlIGxpbmUgYXNcXG4vLyBjaGFuZ2VkLlxcbmZ1bmN0aW9uIGNoYW5nZUxpbmUoZG9jLCBoYW5kbGUsIGNoYW5nZVR5cGUsIG9wKSB7XFxuICB2YXIgbm8gPSBoYW5kbGUsIGxpbmUgPSBoYW5kbGU7XFxuICBpZiAodHlwZW9mIGhhbmRsZSA9PSBcXFwibnVtYmVyXFxcIikgeyBsaW5lID0gZ2V0TGluZShkb2MsIGNsaXBMaW5lKGRvYywgaGFuZGxlKSk7IH1cXG4gIGVsc2UgeyBubyA9IGxpbmVObyhoYW5kbGUpOyB9XFxuICBpZiAobm8gPT0gbnVsbCkgeyByZXR1cm4gbnVsbCB9XFxuICBpZiAob3AobGluZSwgbm8pICYmIGRvYy5jbSkgeyByZWdMaW5lQ2hhbmdlKGRvYy5jbSwgbm8sIGNoYW5nZVR5cGUpOyB9XFxuICByZXR1cm4gbGluZVxcbn1cXG5cXG4vLyBUaGUgZG9jdW1lbnQgaXMgcmVwcmVzZW50ZWQgYXMgYSBCVHJlZSBjb25zaXN0aW5nIG9mIGxlYXZlcywgd2l0aFxcbi8vIGNodW5rIG9mIGxpbmVzIGluIHRoZW0sIGFuZCBicmFuY2hlcywgd2l0aCB1cCB0byB0ZW4gbGVhdmVzIG9yXFxuLy8gb3RoZXIgYnJhbmNoIG5vZGVzIGJlbG93IHRoZW0uIFRoZSB0b3Agbm9kZSBpcyBhbHdheXMgYSBicmFuY2hcXG4vLyBub2RlLCBhbmQgaXMgdGhlIGRvY3VtZW50IG9iamVjdCBpdHNlbGYgKG1lYW5pbmcgaXQgaGFzXFxuLy8gYWRkaXRpb25hbCBtZXRob2RzIGFuZCBwcm9wZXJ0aWVzKS5cXG4vL1xcbi8vIEFsbCBub2RlcyBoYXZlIHBhcmVudCBsaW5rcy4gVGhlIHRyZWUgaXMgdXNlZCBib3RoIHRvIGdvIGZyb21cXG4vLyBsaW5lIG51bWJlcnMgdG8gbGluZSBvYmplY3RzLCBhbmQgdG8gZ28gZnJvbSBvYmplY3RzIHRvIG51bWJlcnMuXFxuLy8gSXQgYWxzbyBpbmRleGVzIGJ5IGhlaWdodCwgYW5kIGlzIHVzZWQgdG8gY29udmVydCBiZXR3ZWVuIGhlaWdodFxcbi8vIGFuZCBsaW5lIG9iamVjdCwgYW5kIHRvIGZpbmQgdGhlIHRvdGFsIGhlaWdodCBvZiB0aGUgZG9jdW1lbnQuXFxuLy9cXG4vLyBTZWUgYWxzbyBodHRwOi8vbWFyaWpuaGF2ZXJiZWtlLm5sL2Jsb2cvY29kZW1pcnJvci1saW5lLXRyZWUuaHRtbFxcblxcbnZhciBMZWFmQ2h1bmsgPSBmdW5jdGlvbihsaW5lcykge1xcbiAgdmFyIHRoaXMkMSA9IHRoaXM7XFxuXFxuICB0aGlzLmxpbmVzID0gbGluZXM7XFxuICB0aGlzLnBhcmVudCA9IG51bGw7XFxuICB2YXIgaGVpZ2h0ID0gMDtcXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyArK2kpIHtcXG4gICAgbGluZXNbaV0ucGFyZW50ID0gdGhpcyQxO1xcbiAgICBoZWlnaHQgKz0gbGluZXNbaV0uaGVpZ2h0O1xcbiAgfVxcbiAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XFxufTtcXG5cXG5MZWFmQ2h1bmsucHJvdG90eXBlLmNodW5rU2l6ZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMubGluZXMubGVuZ3RoIH07XFxuXFxuLy8gUmVtb3ZlIHRoZSBuIGxpbmVzIGF0IG9mZnNldCAnYXQnLlxcbkxlYWZDaHVuay5wcm90b3R5cGUucmVtb3ZlSW5uZXIgPSBmdW5jdGlvbiAoYXQsIG4pIHtcXG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XFxuXFxuICBmb3IgKHZhciBpID0gYXQsIGUgPSBhdCArIG47IGkgPCBlOyArK2kpIHtcXG4gICAgdmFyIGxpbmUgPSB0aGlzJDEubGluZXNbaV07XFxuICAgIHRoaXMkMS5oZWlnaHQgLT0gbGluZS5oZWlnaHQ7XFxuICAgIGNsZWFuVXBMaW5lKGxpbmUpO1xcbiAgICBzaWduYWxMYXRlcihsaW5lLCBcXFwiZGVsZXRlXFxcIik7XFxuICB9XFxuICB0aGlzLmxpbmVzLnNwbGljZShhdCwgbik7XFxufTtcXG5cXG4vLyBIZWxwZXIgdXNlZCB0byBjb2xsYXBzZSBhIHNtYWxsIGJyYW5jaCBpbnRvIGEgc2luZ2xlIGxlYWYuXFxuTGVhZkNodW5rLnByb3RvdHlwZS5jb2xsYXBzZSA9IGZ1bmN0aW9uIChsaW5lcykge1xcbiAgbGluZXMucHVzaC5hcHBseShsaW5lcywgdGhpcy5saW5lcyk7XFxufTtcXG5cXG4vLyBJbnNlcnQgdGhlIGdpdmVuIGFycmF5IG9mIGxpbmVzIGF0IG9mZnNldCAnYXQnLCBjb3VudCB0aGVtIGFzXFxuLy8gaGF2aW5nIHRoZSBnaXZlbiBoZWlnaHQuXFxuTGVhZkNodW5rLnByb3RvdHlwZS5pbnNlcnRJbm5lciA9IGZ1bmN0aW9uIChhdCwgbGluZXMsIGhlaWdodCkge1xcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcXG5cXG4gIHRoaXMuaGVpZ2h0ICs9IGhlaWdodDtcXG4gIHRoaXMubGluZXMgPSB0aGlzLmxpbmVzLnNsaWNlKDAsIGF0KS5jb25jYXQobGluZXMpLmNvbmNhdCh0aGlzLmxpbmVzLnNsaWNlKGF0KSk7XFxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgKytpKSB7IGxpbmVzW2ldLnBhcmVudCA9IHRoaXMkMTsgfVxcbn07XFxuXFxuLy8gVXNlZCB0byBpdGVyYXRlIG92ZXIgYSBwYXJ0IG9mIHRoZSB0cmVlLlxcbkxlYWZDaHVuay5wcm90b3R5cGUuaXRlck4gPSBmdW5jdGlvbiAoYXQsIG4sIG9wKSB7XFxuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xcblxcbiAgZm9yICh2YXIgZSA9IGF0ICsgbjsgYXQgPCBlOyArK2F0KVxcbiAgICB7IGlmIChvcCh0aGlzJDEubGluZXNbYXRdKSkgeyByZXR1cm4gdHJ1ZSB9IH1cXG59O1xcblxcbnZhciBCcmFuY2hDaHVuayA9IGZ1bmN0aW9uKGNoaWxkcmVuKSB7XFxuICB2YXIgdGhpcyQxID0gdGhpcztcXG5cXG4gIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcXG4gIHZhciBzaXplID0gMCwgaGVpZ2h0ID0gMDtcXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyArK2kpIHtcXG4gICAgdmFyIGNoID0gY2hpbGRyZW5baV07XFxuICAgIHNpemUgKz0gY2guY2h1bmtTaXplKCk7IGhlaWdodCArPSBjaC5oZWlnaHQ7XFxuICAgIGNoLnBhcmVudCA9IHRoaXMkMTtcXG4gIH1cXG4gIHRoaXMuc2l6ZSA9IHNpemU7XFxuICB0aGlzLmhlaWdodCA9IGhlaWdodDtcXG4gIHRoaXMucGFyZW50ID0gbnVsbDtcXG59O1xcblxcbkJyYW5jaENodW5rLnByb3RvdHlwZS5jaHVua1NpemUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLnNpemUgfTtcXG5cXG5CcmFuY2hDaHVuay5wcm90b3R5cGUucmVtb3ZlSW5uZXIgPSBmdW5jdGlvbiAoYXQsIG4pIHtcXG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XFxuXFxuICB0aGlzLnNpemUgLT0gbjtcXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7ICsraSkge1xcbiAgICB2YXIgY2hpbGQgPSB0aGlzJDEuY2hpbGRyZW5baV0sIHN6ID0gY2hpbGQuY2h1bmtTaXplKCk7XFxuICAgIGlmIChhdCA8IHN6KSB7XFxuICAgICAgdmFyIHJtID0gTWF0aC5taW4obiwgc3ogLSBhdCksIG9sZEhlaWdodCA9IGNoaWxkLmhlaWdodDtcXG4gICAgICBjaGlsZC5yZW1vdmVJbm5lcihhdCwgcm0pO1xcbiAgICAgIHRoaXMkMS5oZWlnaHQgLT0gb2xkSGVpZ2h0IC0gY2hpbGQuaGVpZ2h0O1xcbiAgICAgIGlmIChzeiA9PSBybSkgeyB0aGlzJDEuY2hpbGRyZW4uc3BsaWNlKGktLSwgMSk7IGNoaWxkLnBhcmVudCA9IG51bGw7IH1cXG4gICAgICBpZiAoKG4gLT0gcm0pID09IDApIHsgYnJlYWsgfVxcbiAgICAgIGF0ID0gMDtcXG4gICAgfSBlbHNlIHsgYXQgLT0gc3o7IH1cXG4gIH1cXG4gIC8vIElmIHRoZSByZXN1bHQgaXMgc21hbGxlciB0aGFuIDI1IGxpbmVzLCBlbnN1cmUgdGhhdCBpdCBpcyBhXFxuICAvLyBzaW5nbGUgbGVhZiBub2RlLlxcbiAgaWYgKHRoaXMuc2l6ZSAtIG4gPCAyNSAmJlxcbiAgICAgICh0aGlzLmNoaWxkcmVuLmxlbmd0aCA+IDEgfHwgISh0aGlzLmNoaWxkcmVuWzBdIGluc3RhbmNlb2YgTGVhZkNodW5rKSkpIHtcXG4gICAgdmFyIGxpbmVzID0gW107XFxuICAgIHRoaXMuY29sbGFwc2UobGluZXMpO1xcbiAgICB0aGlzLmNoaWxkcmVuID0gW25ldyBMZWFmQ2h1bmsobGluZXMpXTtcXG4gICAgdGhpcy5jaGlsZHJlblswXS5wYXJlbnQgPSB0aGlzO1xcbiAgfVxcbn07XFxuXFxuQnJhbmNoQ2h1bmsucHJvdG90eXBlLmNvbGxhcHNlID0gZnVuY3Rpb24gKGxpbmVzKSB7XFxuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xcblxcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgKytpKSB7IHRoaXMkMS5jaGlsZHJlbltpXS5jb2xsYXBzZShsaW5lcyk7IH1cXG59O1xcblxcbkJyYW5jaENodW5rLnByb3RvdHlwZS5pbnNlcnRJbm5lciA9IGZ1bmN0aW9uIChhdCwgbGluZXMsIGhlaWdodCkge1xcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcXG5cXG4gIHRoaXMuc2l6ZSArPSBsaW5lcy5sZW5ndGg7XFxuICB0aGlzLmhlaWdodCArPSBoZWlnaHQ7XFxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyArK2kpIHtcXG4gICAgdmFyIGNoaWxkID0gdGhpcyQxLmNoaWxkcmVuW2ldLCBzeiA9IGNoaWxkLmNodW5rU2l6ZSgpO1xcbiAgICBpZiAoYXQgPD0gc3opIHtcXG4gICAgICBjaGlsZC5pbnNlcnRJbm5lcihhdCwgbGluZXMsIGhlaWdodCk7XFxuICAgICAgaWYgKGNoaWxkLmxpbmVzICYmIGNoaWxkLmxpbmVzLmxlbmd0aCA+IDUwKSB7XFxuICAgICAgICAvLyBUbyBhdm9pZCBtZW1vcnkgdGhyYXNoaW5nIHdoZW4gY2hpbGQubGluZXMgaXMgaHVnZSAoZS5nLiBmaXJzdCB2aWV3IG9mIGEgbGFyZ2UgZmlsZSksIGl0J3MgbmV2ZXIgc3BsaWNlZC5cXG4gICAgICAgIC8vIEluc3RlYWQsIHNtYWxsIHNsaWNlcyBhcmUgdGFrZW4uIFRoZXkncmUgdGFrZW4gaW4gb3JkZXIgYmVjYXVzZSBzZXF1ZW50aWFsIG1lbW9yeSBhY2Nlc3NlcyBhcmUgZmFzdGVzdC5cXG4gICAgICAgIHZhciByZW1haW5pbmcgPSBjaGlsZC5saW5lcy5sZW5ndGggJSAyNSArIDI1O1xcbiAgICAgICAgZm9yICh2YXIgcG9zID0gcmVtYWluaW5nOyBwb3MgPCBjaGlsZC5saW5lcy5sZW5ndGg7KSB7XFxuICAgICAgICAgIHZhciBsZWFmID0gbmV3IExlYWZDaHVuayhjaGlsZC5saW5lcy5zbGljZShwb3MsIHBvcyArPSAyNSkpO1xcbiAgICAgICAgICBjaGlsZC5oZWlnaHQgLT0gbGVhZi5oZWlnaHQ7XFxuICAgICAgICAgIHRoaXMkMS5jaGlsZHJlbi5zcGxpY2UoKytpLCAwLCBsZWFmKTtcXG4gICAgICAgICAgbGVhZi5wYXJlbnQgPSB0aGlzJDE7XFxuICAgICAgICB9XFxuICAgICAgICBjaGlsZC5saW5lcyA9IGNoaWxkLmxpbmVzLnNsaWNlKDAsIHJlbWFpbmluZyk7XFxuICAgICAgICB0aGlzJDEubWF5YmVTcGlsbCgpO1xcbiAgICAgIH1cXG4gICAgICBicmVha1xcbiAgICB9XFxuICAgIGF0IC09IHN6O1xcbiAgfVxcbn07XFxuXFxuLy8gV2hlbiBhIG5vZGUgaGFzIGdyb3duLCBjaGVjayB3aGV0aGVyIGl0IHNob3VsZCBiZSBzcGxpdC5cXG5CcmFuY2hDaHVuay5wcm90b3R5cGUubWF5YmVTcGlsbCA9IGZ1bmN0aW9uICgpIHtcXG4gIGlmICh0aGlzLmNoaWxkcmVuLmxlbmd0aCA8PSAxMCkgeyByZXR1cm4gfVxcbiAgdmFyIG1lID0gdGhpcztcXG4gIGRvIHtcXG4gICAgdmFyIHNwaWxsZWQgPSBtZS5jaGlsZHJlbi5zcGxpY2UobWUuY2hpbGRyZW4ubGVuZ3RoIC0gNSwgNSk7XFxuICAgIHZhciBzaWJsaW5nID0gbmV3IEJyYW5jaENodW5rKHNwaWxsZWQpO1xcbiAgICBpZiAoIW1lLnBhcmVudCkgeyAvLyBCZWNvbWUgdGhlIHBhcmVudCBub2RlXFxuICAgICAgdmFyIGNvcHkgPSBuZXcgQnJhbmNoQ2h1bmsobWUuY2hpbGRyZW4pO1xcbiAgICAgIGNvcHkucGFyZW50ID0gbWU7XFxuICAgICAgbWUuY2hpbGRyZW4gPSBbY29weSwgc2libGluZ107XFxuICAgICAgbWUgPSBjb3B5O1xcbiAgIH0gZWxzZSB7XFxuICAgICAgbWUuc2l6ZSAtPSBzaWJsaW5nLnNpemU7XFxuICAgICAgbWUuaGVpZ2h0IC09IHNpYmxpbmcuaGVpZ2h0O1xcbiAgICAgIHZhciBteUluZGV4ID0gaW5kZXhPZihtZS5wYXJlbnQuY2hpbGRyZW4sIG1lKTtcXG4gICAgICBtZS5wYXJlbnQuY2hpbGRyZW4uc3BsaWNlKG15SW5kZXggKyAxLCAwLCBzaWJsaW5nKTtcXG4gICAgfVxcbiAgICBzaWJsaW5nLnBhcmVudCA9IG1lLnBhcmVudDtcXG4gIH0gd2hpbGUgKG1lLmNoaWxkcmVuLmxlbmd0aCA+IDEwKVxcbiAgbWUucGFyZW50Lm1heWJlU3BpbGwoKTtcXG59O1xcblxcbkJyYW5jaENodW5rLnByb3RvdHlwZS5pdGVyTiA9IGZ1bmN0aW9uIChhdCwgbiwgb3ApIHtcXG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XFxuXFxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyArK2kpIHtcXG4gICAgdmFyIGNoaWxkID0gdGhpcyQxLmNoaWxkcmVuW2ldLCBzeiA9IGNoaWxkLmNodW5rU2l6ZSgpO1xcbiAgICBpZiAoYXQgPCBzeikge1xcbiAgICAgIHZhciB1c2VkID0gTWF0aC5taW4obiwgc3ogLSBhdCk7XFxuICAgICAgaWYgKGNoaWxkLml0ZXJOKGF0LCB1c2VkLCBvcCkpIHsgcmV0dXJuIHRydWUgfVxcbiAgICAgIGlmICgobiAtPSB1c2VkKSA9PSAwKSB7IGJyZWFrIH1cXG4gICAgICBhdCA9IDA7XFxuICAgIH0gZWxzZSB7IGF0IC09IHN6OyB9XFxuICB9XFxufTtcXG5cXG4vLyBMaW5lIHdpZGdldHMgYXJlIGJsb2NrIGVsZW1lbnRzIGRpc3BsYXllZCBhYm92ZSBvciBiZWxvdyBhIGxpbmUuXFxuXFxudmFyIExpbmVXaWRnZXQgPSBmdW5jdGlvbihkb2MsIG5vZGUsIG9wdGlvbnMpIHtcXG4gIHZhciB0aGlzJDEgPSB0aGlzO1xcblxcbiAgaWYgKG9wdGlvbnMpIHsgZm9yICh2YXIgb3B0IGluIG9wdGlvbnMpIHsgaWYgKG9wdGlvbnMuaGFzT3duUHJvcGVydHkob3B0KSlcXG4gICAgeyB0aGlzJDFbb3B0XSA9IG9wdGlvbnNbb3B0XTsgfSB9IH1cXG4gIHRoaXMuZG9jID0gZG9jO1xcbiAgdGhpcy5ub2RlID0gbm9kZTtcXG59O1xcblxcbkxpbmVXaWRnZXQucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcXG5cXG4gIHZhciBjbSA9IHRoaXMuZG9jLmNtLCB3cyA9IHRoaXMubGluZS53aWRnZXRzLCBsaW5lID0gdGhpcy5saW5lLCBubyA9IGxpbmVObyhsaW5lKTtcXG4gIGlmIChubyA9PSBudWxsIHx8ICF3cykgeyByZXR1cm4gfVxcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB3cy5sZW5ndGg7ICsraSkgeyBpZiAod3NbaV0gPT0gdGhpcyQxKSB7IHdzLnNwbGljZShpLS0sIDEpOyB9IH1cXG4gIGlmICghd3MubGVuZ3RoKSB7IGxpbmUud2lkZ2V0cyA9IG51bGw7IH1cXG4gIHZhciBoZWlnaHQgPSB3aWRnZXRIZWlnaHQodGhpcyk7XFxuICB1cGRhdGVMaW5lSGVpZ2h0KGxpbmUsIE1hdGgubWF4KDAsIGxpbmUuaGVpZ2h0IC0gaGVpZ2h0KSk7XFxuICBpZiAoY20pIHtcXG4gICAgcnVuSW5PcChjbSwgZnVuY3Rpb24gKCkge1xcbiAgICAgIGFkanVzdFNjcm9sbFdoZW5BYm92ZVZpc2libGUoY20sIGxpbmUsIC1oZWlnaHQpO1xcbiAgICAgIHJlZ0xpbmVDaGFuZ2UoY20sIG5vLCBcXFwid2lkZ2V0XFxcIik7XFxuICAgIH0pO1xcbiAgICBzaWduYWxMYXRlcihjbSwgXFxcImxpbmVXaWRnZXRDbGVhcmVkXFxcIiwgY20sIHRoaXMsIG5vKTtcXG4gIH1cXG59O1xcblxcbkxpbmVXaWRnZXQucHJvdG90eXBlLmNoYW5nZWQgPSBmdW5jdGlvbiAoKSB7XFxuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xcblxcbiAgdmFyIG9sZEggPSB0aGlzLmhlaWdodCwgY20gPSB0aGlzLmRvYy5jbSwgbGluZSA9IHRoaXMubGluZTtcXG4gIHRoaXMuaGVpZ2h0ID0gbnVsbDtcXG4gIHZhciBkaWZmID0gd2lkZ2V0SGVpZ2h0KHRoaXMpIC0gb2xkSDtcXG4gIGlmICghZGlmZikgeyByZXR1cm4gfVxcbiAgdXBkYXRlTGluZUhlaWdodChsaW5lLCBsaW5lLmhlaWdodCArIGRpZmYpO1xcbiAgaWYgKGNtKSB7XFxuICAgIHJ1bkluT3AoY20sIGZ1bmN0aW9uICgpIHtcXG4gICAgICBjbS5jdXJPcC5mb3JjZVVwZGF0ZSA9IHRydWU7XFxuICAgICAgYWRqdXN0U2Nyb2xsV2hlbkFib3ZlVmlzaWJsZShjbSwgbGluZSwgZGlmZik7XFxuICAgICAgc2lnbmFsTGF0ZXIoY20sIFxcXCJsaW5lV2lkZ2V0Q2hhbmdlZFxcXCIsIGNtLCB0aGlzJDEsIGxpbmVObyhsaW5lKSk7XFxuICAgIH0pO1xcbiAgfVxcbn07XFxuZXZlbnRNaXhpbihMaW5lV2lkZ2V0KTtcXG5cXG5mdW5jdGlvbiBhZGp1c3RTY3JvbGxXaGVuQWJvdmVWaXNpYmxlKGNtLCBsaW5lLCBkaWZmKSB7XFxuICBpZiAoaGVpZ2h0QXRMaW5lKGxpbmUpIDwgKChjbS5jdXJPcCAmJiBjbS5jdXJPcC5zY3JvbGxUb3ApIHx8IGNtLmRvYy5zY3JvbGxUb3ApKVxcbiAgICB7IGFkZFRvU2Nyb2xsUG9zKGNtLCBudWxsLCBkaWZmKTsgfVxcbn1cXG5cXG5mdW5jdGlvbiBhZGRMaW5lV2lkZ2V0KGRvYywgaGFuZGxlLCBub2RlLCBvcHRpb25zKSB7XFxuICB2YXIgd2lkZ2V0ID0gbmV3IExpbmVXaWRnZXQoZG9jLCBub2RlLCBvcHRpb25zKTtcXG4gIHZhciBjbSA9IGRvYy5jbTtcXG4gIGlmIChjbSAmJiB3aWRnZXQubm9IU2Nyb2xsKSB7IGNtLmRpc3BsYXkuYWxpZ25XaWRnZXRzID0gdHJ1ZTsgfVxcbiAgY2hhbmdlTGluZShkb2MsIGhhbmRsZSwgXFxcIndpZGdldFxcXCIsIGZ1bmN0aW9uIChsaW5lKSB7XFxuICAgIHZhciB3aWRnZXRzID0gbGluZS53aWRnZXRzIHx8IChsaW5lLndpZGdldHMgPSBbXSk7XFxuICAgIGlmICh3aWRnZXQuaW5zZXJ0QXQgPT0gbnVsbCkgeyB3aWRnZXRzLnB1c2god2lkZ2V0KTsgfVxcbiAgICBlbHNlIHsgd2lkZ2V0cy5zcGxpY2UoTWF0aC5taW4od2lkZ2V0cy5sZW5ndGggLSAxLCBNYXRoLm1heCgwLCB3aWRnZXQuaW5zZXJ0QXQpKSwgMCwgd2lkZ2V0KTsgfVxcbiAgICB3aWRnZXQubGluZSA9IGxpbmU7XFxuICAgIGlmIChjbSAmJiAhbGluZUlzSGlkZGVuKGRvYywgbGluZSkpIHtcXG4gICAgICB2YXIgYWJvdmVWaXNpYmxlID0gaGVpZ2h0QXRMaW5lKGxpbmUpIDwgZG9jLnNjcm9sbFRvcDtcXG4gICAgICB1cGRhdGVMaW5lSGVpZ2h0KGxpbmUsIGxpbmUuaGVpZ2h0ICsgd2lkZ2V0SGVpZ2h0KHdpZGdldCkpO1xcbiAgICAgIGlmIChhYm92ZVZpc2libGUpIHsgYWRkVG9TY3JvbGxQb3MoY20sIG51bGwsIHdpZGdldC5oZWlnaHQpOyB9XFxuICAgICAgY20uY3VyT3AuZm9yY2VVcGRhdGUgPSB0cnVlO1xcbiAgICB9XFxuICAgIHJldHVybiB0cnVlXFxuICB9KTtcXG4gIHNpZ25hbExhdGVyKGNtLCBcXFwibGluZVdpZGdldEFkZGVkXFxcIiwgY20sIHdpZGdldCwgdHlwZW9mIGhhbmRsZSA9PSBcXFwibnVtYmVyXFxcIiA/IGhhbmRsZSA6IGxpbmVObyhoYW5kbGUpKTtcXG4gIHJldHVybiB3aWRnZXRcXG59XFxuXFxuLy8gVEVYVE1BUktFUlNcXG5cXG4vLyBDcmVhdGVkIHdpdGggbWFya1RleHQgYW5kIHNldEJvb2ttYXJrIG1ldGhvZHMuIEEgVGV4dE1hcmtlciBpcyBhXFxuLy8gaGFuZGxlIHRoYXQgY2FuIGJlIHVzZWQgdG8gY2xlYXIgb3IgZmluZCBhIG1hcmtlZCBwb3NpdGlvbiBpbiB0aGVcXG4vLyBkb2N1bWVudC4gTGluZSBvYmplY3RzIGhvbGQgYXJyYXlzIChtYXJrZWRTcGFucykgY29udGFpbmluZ1xcbi8vIHtmcm9tLCB0bywgbWFya2VyfSBvYmplY3QgcG9pbnRpbmcgdG8gc3VjaCBtYXJrZXIgb2JqZWN0cywgYW5kXFxuLy8gaW5kaWNhdGluZyB0aGF0IHN1Y2ggYSBtYXJrZXIgaXMgcHJlc2VudCBvbiB0aGF0IGxpbmUuIE11bHRpcGxlXFxuLy8gbGluZXMgbWF5IHBvaW50IHRvIHRoZSBzYW1lIG1hcmtlciB3aGVuIGl0IHNwYW5zIGFjcm9zcyBsaW5lcy5cXG4vLyBUaGUgc3BhbnMgd2lsbCBoYXZlIG51bGwgZm9yIHRoZWlyIGZyb20vdG8gcHJvcGVydGllcyB3aGVuIHRoZVxcbi8vIG1hcmtlciBjb250aW51ZXMgYmV5b25kIHRoZSBzdGFydC9lbmQgb2YgdGhlIGxpbmUuIE1hcmtlcnMgaGF2ZVxcbi8vIGxpbmtzIGJhY2sgdG8gdGhlIGxpbmVzIHRoZXkgY3VycmVudGx5IHRvdWNoLlxcblxcbi8vIENvbGxhcHNlZCBtYXJrZXJzIGhhdmUgdW5pcXVlIGlkcywgaW4gb3JkZXIgdG8gYmUgYWJsZSB0byBvcmRlclxcbi8vIHRoZW0sIHdoaWNoIGlzIG5lZWRlZCBmb3IgdW5pcXVlbHkgZGV0ZXJtaW5pbmcgYW4gb3V0ZXIgbWFya2VyXFxuLy8gd2hlbiB0aGV5IG92ZXJsYXAgKHRoZXkgbWF5IG5lc3QsIGJ1dCBub3QgcGFydGlhbGx5IG92ZXJsYXApLlxcbnZhciBuZXh0TWFya2VySWQgPSAwO1xcblxcbnZhciBUZXh0TWFya2VyID0gZnVuY3Rpb24oZG9jLCB0eXBlKSB7XFxuICB0aGlzLmxpbmVzID0gW107XFxuICB0aGlzLnR5cGUgPSB0eXBlO1xcbiAgdGhpcy5kb2MgPSBkb2M7XFxuICB0aGlzLmlkID0gKytuZXh0TWFya2VySWQ7XFxufTtcXG5cXG4vLyBDbGVhciB0aGUgbWFya2VyLlxcblRleHRNYXJrZXIucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcXG5cXG4gIGlmICh0aGlzLmV4cGxpY2l0bHlDbGVhcmVkKSB7IHJldHVybiB9XFxuICB2YXIgY20gPSB0aGlzLmRvYy5jbSwgd2l0aE9wID0gY20gJiYgIWNtLmN1ck9wO1xcbiAgaWYgKHdpdGhPcCkgeyBzdGFydE9wZXJhdGlvbihjbSk7IH1cXG4gIGlmIChoYXNIYW5kbGVyKHRoaXMsIFxcXCJjbGVhclxcXCIpKSB7XFxuICAgIHZhciBmb3VuZCA9IHRoaXMuZmluZCgpO1xcbiAgICBpZiAoZm91bmQpIHsgc2lnbmFsTGF0ZXIodGhpcywgXFxcImNsZWFyXFxcIiwgZm91bmQuZnJvbSwgZm91bmQudG8pOyB9XFxuICB9XFxuICB2YXIgbWluID0gbnVsbCwgbWF4ID0gbnVsbDtcXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5saW5lcy5sZW5ndGg7ICsraSkge1xcbiAgICB2YXIgbGluZSA9IHRoaXMkMS5saW5lc1tpXTtcXG4gICAgdmFyIHNwYW4gPSBnZXRNYXJrZWRTcGFuRm9yKGxpbmUubWFya2VkU3BhbnMsIHRoaXMkMSk7XFxuICAgIGlmIChjbSAmJiAhdGhpcyQxLmNvbGxhcHNlZCkgeyByZWdMaW5lQ2hhbmdlKGNtLCBsaW5lTm8obGluZSksIFxcXCJ0ZXh0XFxcIik7IH1cXG4gICAgZWxzZSBpZiAoY20pIHtcXG4gICAgICBpZiAoc3Bhbi50byAhPSBudWxsKSB7IG1heCA9IGxpbmVObyhsaW5lKTsgfVxcbiAgICAgIGlmIChzcGFuLmZyb20gIT0gbnVsbCkgeyBtaW4gPSBsaW5lTm8obGluZSk7IH1cXG4gICAgfVxcbiAgICBsaW5lLm1hcmtlZFNwYW5zID0gcmVtb3ZlTWFya2VkU3BhbihsaW5lLm1hcmtlZFNwYW5zLCBzcGFuKTtcXG4gICAgaWYgKHNwYW4uZnJvbSA9PSBudWxsICYmIHRoaXMkMS5jb2xsYXBzZWQgJiYgIWxpbmVJc0hpZGRlbih0aGlzJDEuZG9jLCBsaW5lKSAmJiBjbSlcXG4gICAgICB7IHVwZGF0ZUxpbmVIZWlnaHQobGluZSwgdGV4dEhlaWdodChjbS5kaXNwbGF5KSk7IH1cXG4gIH1cXG4gIGlmIChjbSAmJiB0aGlzLmNvbGxhcHNlZCAmJiAhY20ub3B0aW9ucy5saW5lV3JhcHBpbmcpIHsgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgdGhpcy5saW5lcy5sZW5ndGg7ICsraSQxKSB7XFxuICAgIHZhciB2aXN1YWwgPSB2aXN1YWxMaW5lKHRoaXMkMS5saW5lc1tpJDFdKSwgbGVuID0gbGluZUxlbmd0aCh2aXN1YWwpO1xcbiAgICBpZiAobGVuID4gY20uZGlzcGxheS5tYXhMaW5lTGVuZ3RoKSB7XFxuICAgICAgY20uZGlzcGxheS5tYXhMaW5lID0gdmlzdWFsO1xcbiAgICAgIGNtLmRpc3BsYXkubWF4TGluZUxlbmd0aCA9IGxlbjtcXG4gICAgICBjbS5kaXNwbGF5Lm1heExpbmVDaGFuZ2VkID0gdHJ1ZTtcXG4gICAgfVxcbiAgfSB9XFxuXFxuICBpZiAobWluICE9IG51bGwgJiYgY20gJiYgdGhpcy5jb2xsYXBzZWQpIHsgcmVnQ2hhbmdlKGNtLCBtaW4sIG1heCArIDEpOyB9XFxuICB0aGlzLmxpbmVzLmxlbmd0aCA9IDA7XFxuICB0aGlzLmV4cGxpY2l0bHlDbGVhcmVkID0gdHJ1ZTtcXG4gIGlmICh0aGlzLmF0b21pYyAmJiB0aGlzLmRvYy5jYW50RWRpdCkge1xcbiAgICB0aGlzLmRvYy5jYW50RWRpdCA9IGZhbHNlO1xcbiAgICBpZiAoY20pIHsgcmVDaGVja1NlbGVjdGlvbihjbS5kb2MpOyB9XFxuICB9XFxuICBpZiAoY20pIHsgc2lnbmFsTGF0ZXIoY20sIFxcXCJtYXJrZXJDbGVhcmVkXFxcIiwgY20sIHRoaXMsIG1pbiwgbWF4KTsgfVxcbiAgaWYgKHdpdGhPcCkgeyBlbmRPcGVyYXRpb24oY20pOyB9XFxuICBpZiAodGhpcy5wYXJlbnQpIHsgdGhpcy5wYXJlbnQuY2xlYXIoKTsgfVxcbn07XFxuXFxuLy8gRmluZCB0aGUgcG9zaXRpb24gb2YgdGhlIG1hcmtlciBpbiB0aGUgZG9jdW1lbnQuIFJldHVybnMgYSB7ZnJvbSxcXG4vLyB0b30gb2JqZWN0IGJ5IGRlZmF1bHQuIFNpZGUgY2FuIGJlIHBhc3NlZCB0byBnZXQgYSBzcGVjaWZpYyBzaWRlXFxuLy8gLS0gMCAoYm90aCksIC0xIChsZWZ0KSwgb3IgMSAocmlnaHQpLiBXaGVuIGxpbmVPYmogaXMgdHJ1ZSwgdGhlXFxuLy8gUG9zIG9iamVjdHMgcmV0dXJuZWQgY29udGFpbiBhIGxpbmUgb2JqZWN0LCByYXRoZXIgdGhhbiBhIGxpbmVcXG4vLyBudW1iZXIgKHVzZWQgdG8gcHJldmVudCBsb29raW5nIHVwIHRoZSBzYW1lIGxpbmUgdHdpY2UpLlxcblRleHRNYXJrZXIucHJvdG90eXBlLmZpbmQgPSBmdW5jdGlvbiAoc2lkZSwgbGluZU9iaikge1xcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcXG5cXG4gIGlmIChzaWRlID09IG51bGwgJiYgdGhpcy50eXBlID09IFxcXCJib29rbWFya1xcXCIpIHsgc2lkZSA9IDE7IH1cXG4gIHZhciBmcm9tLCB0bztcXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5saW5lcy5sZW5ndGg7ICsraSkge1xcbiAgICB2YXIgbGluZSA9IHRoaXMkMS5saW5lc1tpXTtcXG4gICAgdmFyIHNwYW4gPSBnZXRNYXJrZWRTcGFuRm9yKGxpbmUubWFya2VkU3BhbnMsIHRoaXMkMSk7XFxuICAgIGlmIChzcGFuLmZyb20gIT0gbnVsbCkge1xcbiAgICAgIGZyb20gPSBQb3MobGluZU9iaiA/IGxpbmUgOiBsaW5lTm8obGluZSksIHNwYW4uZnJvbSk7XFxuICAgICAgaWYgKHNpZGUgPT0gLTEpIHsgcmV0dXJuIGZyb20gfVxcbiAgICB9XFxuICAgIGlmIChzcGFuLnRvICE9IG51bGwpIHtcXG4gICAgICB0byA9IFBvcyhsaW5lT2JqID8gbGluZSA6IGxpbmVObyhsaW5lKSwgc3Bhbi50byk7XFxuICAgICAgaWYgKHNpZGUgPT0gMSkgeyByZXR1cm4gdG8gfVxcbiAgICB9XFxuICB9XFxuICByZXR1cm4gZnJvbSAmJiB7ZnJvbTogZnJvbSwgdG86IHRvfVxcbn07XFxuXFxuLy8gU2lnbmFscyB0aGF0IHRoZSBtYXJrZXIncyB3aWRnZXQgY2hhbmdlZCwgYW5kIHN1cnJvdW5kaW5nIGxheW91dFxcbi8vIHNob3VsZCBiZSByZWNvbXB1dGVkLlxcblRleHRNYXJrZXIucHJvdG90eXBlLmNoYW5nZWQgPSBmdW5jdGlvbiAoKSB7XFxuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xcblxcbiAgdmFyIHBvcyA9IHRoaXMuZmluZCgtMSwgdHJ1ZSksIHdpZGdldCA9IHRoaXMsIGNtID0gdGhpcy5kb2MuY207XFxuICBpZiAoIXBvcyB8fCAhY20pIHsgcmV0dXJuIH1cXG4gIHJ1bkluT3AoY20sIGZ1bmN0aW9uICgpIHtcXG4gICAgdmFyIGxpbmUgPSBwb3MubGluZSwgbGluZU4gPSBsaW5lTm8ocG9zLmxpbmUpO1xcbiAgICB2YXIgdmlldyA9IGZpbmRWaWV3Rm9yTGluZShjbSwgbGluZU4pO1xcbiAgICBpZiAodmlldykge1xcbiAgICAgIGNsZWFyTGluZU1lYXN1cmVtZW50Q2FjaGVGb3Iodmlldyk7XFxuICAgICAgY20uY3VyT3Auc2VsZWN0aW9uQ2hhbmdlZCA9IGNtLmN1ck9wLmZvcmNlVXBkYXRlID0gdHJ1ZTtcXG4gICAgfVxcbiAgICBjbS5jdXJPcC51cGRhdGVNYXhMaW5lID0gdHJ1ZTtcXG4gICAgaWYgKCFsaW5lSXNIaWRkZW4od2lkZ2V0LmRvYywgbGluZSkgJiYgd2lkZ2V0LmhlaWdodCAhPSBudWxsKSB7XFxuICAgICAgdmFyIG9sZEhlaWdodCA9IHdpZGdldC5oZWlnaHQ7XFxuICAgICAgd2lkZ2V0LmhlaWdodCA9IG51bGw7XFxuICAgICAgdmFyIGRIZWlnaHQgPSB3aWRnZXRIZWlnaHQod2lkZ2V0KSAtIG9sZEhlaWdodDtcXG4gICAgICBpZiAoZEhlaWdodClcXG4gICAgICAgIHsgdXBkYXRlTGluZUhlaWdodChsaW5lLCBsaW5lLmhlaWdodCArIGRIZWlnaHQpOyB9XFxuICAgIH1cXG4gICAgc2lnbmFsTGF0ZXIoY20sIFxcXCJtYXJrZXJDaGFuZ2VkXFxcIiwgY20sIHRoaXMkMSk7XFxuICB9KTtcXG59O1xcblxcblRleHRNYXJrZXIucHJvdG90eXBlLmF0dGFjaExpbmUgPSBmdW5jdGlvbiAobGluZSkge1xcbiAgaWYgKCF0aGlzLmxpbmVzLmxlbmd0aCAmJiB0aGlzLmRvYy5jbSkge1xcbiAgICB2YXIgb3AgPSB0aGlzLmRvYy5jbS5jdXJPcDtcXG4gICAgaWYgKCFvcC5tYXliZUhpZGRlbk1hcmtlcnMgfHwgaW5kZXhPZihvcC5tYXliZUhpZGRlbk1hcmtlcnMsIHRoaXMpID09IC0xKVxcbiAgICAgIHsgKG9wLm1heWJlVW5oaWRkZW5NYXJrZXJzIHx8IChvcC5tYXliZVVuaGlkZGVuTWFya2VycyA9IFtdKSkucHVzaCh0aGlzKTsgfVxcbiAgfVxcbiAgdGhpcy5saW5lcy5wdXNoKGxpbmUpO1xcbn07XFxuXFxuVGV4dE1hcmtlci5wcm90b3R5cGUuZGV0YWNoTGluZSA9IGZ1bmN0aW9uIChsaW5lKSB7XFxuICB0aGlzLmxpbmVzLnNwbGljZShpbmRleE9mKHRoaXMubGluZXMsIGxpbmUpLCAxKTtcXG4gIGlmICghdGhpcy5saW5lcy5sZW5ndGggJiYgdGhpcy5kb2MuY20pIHtcXG4gICAgdmFyIG9wID0gdGhpcy5kb2MuY20uY3VyT3A7KG9wLm1heWJlSGlkZGVuTWFya2VycyB8fCAob3AubWF5YmVIaWRkZW5NYXJrZXJzID0gW10pKS5wdXNoKHRoaXMpO1xcbiAgfVxcbn07XFxuZXZlbnRNaXhpbihUZXh0TWFya2VyKTtcXG5cXG4vLyBDcmVhdGUgYSBtYXJrZXIsIHdpcmUgaXQgdXAgdG8gdGhlIHJpZ2h0IGxpbmVzLCBhbmRcXG5mdW5jdGlvbiBtYXJrVGV4dChkb2MsIGZyb20sIHRvLCBvcHRpb25zLCB0eXBlKSB7XFxuICAvLyBTaGFyZWQgbWFya2VycyAoYWNyb3NzIGxpbmtlZCBkb2N1bWVudHMpIGFyZSBoYW5kbGVkIHNlcGFyYXRlbHlcXG4gIC8vIChtYXJrVGV4dFNoYXJlZCB3aWxsIGNhbGwgb3V0IHRvIHRoaXMgYWdhaW4sIG9uY2UgcGVyXFxuICAvLyBkb2N1bWVudCkuXFxuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnNoYXJlZCkgeyByZXR1cm4gbWFya1RleHRTaGFyZWQoZG9jLCBmcm9tLCB0bywgb3B0aW9ucywgdHlwZSkgfVxcbiAgLy8gRW5zdXJlIHdlIGFyZSBpbiBhbiBvcGVyYXRpb24uXFxuICBpZiAoZG9jLmNtICYmICFkb2MuY20uY3VyT3ApIHsgcmV0dXJuIG9wZXJhdGlvbihkb2MuY20sIG1hcmtUZXh0KShkb2MsIGZyb20sIHRvLCBvcHRpb25zLCB0eXBlKSB9XFxuXFxuICB2YXIgbWFya2VyID0gbmV3IFRleHRNYXJrZXIoZG9jLCB0eXBlKSwgZGlmZiA9IGNtcChmcm9tLCB0byk7XFxuICBpZiAob3B0aW9ucykgeyBjb3B5T2JqKG9wdGlvbnMsIG1hcmtlciwgZmFsc2UpOyB9XFxuICAvLyBEb24ndCBjb25uZWN0IGVtcHR5IG1hcmtlcnMgdW5sZXNzIGNsZWFyV2hlbkVtcHR5IGlzIGZhbHNlXFxuICBpZiAoZGlmZiA+IDAgfHwgZGlmZiA9PSAwICYmIG1hcmtlci5jbGVhcldoZW5FbXB0eSAhPT0gZmFsc2UpXFxuICAgIHsgcmV0dXJuIG1hcmtlciB9XFxuICBpZiAobWFya2VyLnJlcGxhY2VkV2l0aCkge1xcbiAgICAvLyBTaG93aW5nIHVwIGFzIGEgd2lkZ2V0IGltcGxpZXMgY29sbGFwc2VkICh3aWRnZXQgcmVwbGFjZXMgdGV4dClcXG4gICAgbWFya2VyLmNvbGxhcHNlZCA9IHRydWU7XFxuICAgIG1hcmtlci53aWRnZXROb2RlID0gZWx0UChcXFwic3BhblxcXCIsIFttYXJrZXIucmVwbGFjZWRXaXRoXSwgXFxcIkNvZGVNaXJyb3Itd2lkZ2V0XFxcIik7XFxuICAgIGlmICghb3B0aW9ucy5oYW5kbGVNb3VzZUV2ZW50cykgeyBtYXJrZXIud2lkZ2V0Tm9kZS5zZXRBdHRyaWJ1dGUoXFxcImNtLWlnbm9yZS1ldmVudHNcXFwiLCBcXFwidHJ1ZVxcXCIpOyB9XFxuICAgIGlmIChvcHRpb25zLmluc2VydExlZnQpIHsgbWFya2VyLndpZGdldE5vZGUuaW5zZXJ0TGVmdCA9IHRydWU7IH1cXG4gIH1cXG4gIGlmIChtYXJrZXIuY29sbGFwc2VkKSB7XFxuICAgIGlmIChjb25mbGljdGluZ0NvbGxhcHNlZFJhbmdlKGRvYywgZnJvbS5saW5lLCBmcm9tLCB0bywgbWFya2VyKSB8fFxcbiAgICAgICAgZnJvbS5saW5lICE9IHRvLmxpbmUgJiYgY29uZmxpY3RpbmdDb2xsYXBzZWRSYW5nZShkb2MsIHRvLmxpbmUsIGZyb20sIHRvLCBtYXJrZXIpKVxcbiAgICAgIHsgdGhyb3cgbmV3IEVycm9yKFxcXCJJbnNlcnRpbmcgY29sbGFwc2VkIG1hcmtlciBwYXJ0aWFsbHkgb3ZlcmxhcHBpbmcgYW4gZXhpc3Rpbmcgb25lXFxcIikgfVxcbiAgICBzZWVDb2xsYXBzZWRTcGFucygpO1xcbiAgfVxcblxcbiAgaWYgKG1hcmtlci5hZGRUb0hpc3RvcnkpXFxuICAgIHsgYWRkQ2hhbmdlVG9IaXN0b3J5KGRvYywge2Zyb206IGZyb20sIHRvOiB0bywgb3JpZ2luOiBcXFwibWFya1RleHRcXFwifSwgZG9jLnNlbCwgTmFOKTsgfVxcblxcbiAgdmFyIGN1ckxpbmUgPSBmcm9tLmxpbmUsIGNtID0gZG9jLmNtLCB1cGRhdGVNYXhMaW5lO1xcbiAgZG9jLml0ZXIoY3VyTGluZSwgdG8ubGluZSArIDEsIGZ1bmN0aW9uIChsaW5lKSB7XFxuICAgIGlmIChjbSAmJiBtYXJrZXIuY29sbGFwc2VkICYmICFjbS5vcHRpb25zLmxpbmVXcmFwcGluZyAmJiB2aXN1YWxMaW5lKGxpbmUpID09IGNtLmRpc3BsYXkubWF4TGluZSlcXG4gICAgICB7IHVwZGF0ZU1heExpbmUgPSB0cnVlOyB9XFxuICAgIGlmIChtYXJrZXIuY29sbGFwc2VkICYmIGN1ckxpbmUgIT0gZnJvbS5saW5lKSB7IHVwZGF0ZUxpbmVIZWlnaHQobGluZSwgMCk7IH1cXG4gICAgYWRkTWFya2VkU3BhbihsaW5lLCBuZXcgTWFya2VkU3BhbihtYXJrZXIsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VyTGluZSA9PSBmcm9tLmxpbmUgPyBmcm9tLmNoIDogbnVsbCxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJMaW5lID09IHRvLmxpbmUgPyB0by5jaCA6IG51bGwpKTtcXG4gICAgKytjdXJMaW5lO1xcbiAgfSk7XFxuICAvLyBsaW5lSXNIaWRkZW4gZGVwZW5kcyBvbiB0aGUgcHJlc2VuY2Ugb2YgdGhlIHNwYW5zLCBzbyBuZWVkcyBhIHNlY29uZCBwYXNzXFxuICBpZiAobWFya2VyLmNvbGxhcHNlZCkgeyBkb2MuaXRlcihmcm9tLmxpbmUsIHRvLmxpbmUgKyAxLCBmdW5jdGlvbiAobGluZSkge1xcbiAgICBpZiAobGluZUlzSGlkZGVuKGRvYywgbGluZSkpIHsgdXBkYXRlTGluZUhlaWdodChsaW5lLCAwKTsgfVxcbiAgfSk7IH1cXG5cXG4gIGlmIChtYXJrZXIuY2xlYXJPbkVudGVyKSB7IG9uKG1hcmtlciwgXFxcImJlZm9yZUN1cnNvckVudGVyXFxcIiwgZnVuY3Rpb24gKCkgeyByZXR1cm4gbWFya2VyLmNsZWFyKCk7IH0pOyB9XFxuXFxuICBpZiAobWFya2VyLnJlYWRPbmx5KSB7XFxuICAgIHNlZVJlYWRPbmx5U3BhbnMoKTtcXG4gICAgaWYgKGRvYy5oaXN0b3J5LmRvbmUubGVuZ3RoIHx8IGRvYy5oaXN0b3J5LnVuZG9uZS5sZW5ndGgpXFxuICAgICAgeyBkb2MuY2xlYXJIaXN0b3J5KCk7IH1cXG4gIH1cXG4gIGlmIChtYXJrZXIuY29sbGFwc2VkKSB7XFxuICAgIG1hcmtlci5pZCA9ICsrbmV4dE1hcmtlcklkO1xcbiAgICBtYXJrZXIuYXRvbWljID0gdHJ1ZTtcXG4gIH1cXG4gIGlmIChjbSkge1xcbiAgICAvLyBTeW5jIGVkaXRvciBzdGF0ZVxcbiAgICBpZiAodXBkYXRlTWF4TGluZSkgeyBjbS5jdXJPcC51cGRhdGVNYXhMaW5lID0gdHJ1ZTsgfVxcbiAgICBpZiAobWFya2VyLmNvbGxhcHNlZClcXG4gICAgICB7IHJlZ0NoYW5nZShjbSwgZnJvbS5saW5lLCB0by5saW5lICsgMSk7IH1cXG4gICAgZWxzZSBpZiAobWFya2VyLmNsYXNzTmFtZSB8fCBtYXJrZXIudGl0bGUgfHwgbWFya2VyLnN0YXJ0U3R5bGUgfHwgbWFya2VyLmVuZFN0eWxlIHx8IG1hcmtlci5jc3MpXFxuICAgICAgeyBmb3IgKHZhciBpID0gZnJvbS5saW5lOyBpIDw9IHRvLmxpbmU7IGkrKykgeyByZWdMaW5lQ2hhbmdlKGNtLCBpLCBcXFwidGV4dFxcXCIpOyB9IH1cXG4gICAgaWYgKG1hcmtlci5hdG9taWMpIHsgcmVDaGVja1NlbGVjdGlvbihjbS5kb2MpOyB9XFxuICAgIHNpZ25hbExhdGVyKGNtLCBcXFwibWFya2VyQWRkZWRcXFwiLCBjbSwgbWFya2VyKTtcXG4gIH1cXG4gIHJldHVybiBtYXJrZXJcXG59XFxuXFxuLy8gU0hBUkVEIFRFWFRNQVJLRVJTXFxuXFxuLy8gQSBzaGFyZWQgbWFya2VyIHNwYW5zIG11bHRpcGxlIGxpbmtlZCBkb2N1bWVudHMuIEl0IGlzXFxuLy8gaW1wbGVtZW50ZWQgYXMgYSBtZXRhLW1hcmtlci1vYmplY3QgY29udHJvbGxpbmcgbXVsdGlwbGUgbm9ybWFsXFxuLy8gbWFya2Vycy5cXG52YXIgU2hhcmVkVGV4dE1hcmtlciA9IGZ1bmN0aW9uKG1hcmtlcnMsIHByaW1hcnkpIHtcXG4gIHZhciB0aGlzJDEgPSB0aGlzO1xcblxcbiAgdGhpcy5tYXJrZXJzID0gbWFya2VycztcXG4gIHRoaXMucHJpbWFyeSA9IHByaW1hcnk7XFxuICBmb3IgKHZhciBpID0gMDsgaSA8IG1hcmtlcnMubGVuZ3RoOyArK2kpXFxuICAgIHsgbWFya2Vyc1tpXS5wYXJlbnQgPSB0aGlzJDE7IH1cXG59O1xcblxcblNoYXJlZFRleHRNYXJrZXIucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcXG5cXG4gIGlmICh0aGlzLmV4cGxpY2l0bHlDbGVhcmVkKSB7IHJldHVybiB9XFxuICB0aGlzLmV4cGxpY2l0bHlDbGVhcmVkID0gdHJ1ZTtcXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5tYXJrZXJzLmxlbmd0aDsgKytpKVxcbiAgICB7IHRoaXMkMS5tYXJrZXJzW2ldLmNsZWFyKCk7IH1cXG4gIHNpZ25hbExhdGVyKHRoaXMsIFxcXCJjbGVhclxcXCIpO1xcbn07XFxuXFxuU2hhcmVkVGV4dE1hcmtlci5wcm90b3R5cGUuZmluZCA9IGZ1bmN0aW9uIChzaWRlLCBsaW5lT2JqKSB7XFxuICByZXR1cm4gdGhpcy5wcmltYXJ5LmZpbmQoc2lkZSwgbGluZU9iailcXG59O1xcbmV2ZW50TWl4aW4oU2hhcmVkVGV4dE1hcmtlcik7XFxuXFxuZnVuY3Rpb24gbWFya1RleHRTaGFyZWQoZG9jLCBmcm9tLCB0bywgb3B0aW9ucywgdHlwZSkge1xcbiAgb3B0aW9ucyA9IGNvcHlPYmoob3B0aW9ucyk7XFxuICBvcHRpb25zLnNoYXJlZCA9IGZhbHNlO1xcbiAgdmFyIG1hcmtlcnMgPSBbbWFya1RleHQoZG9jLCBmcm9tLCB0bywgb3B0aW9ucywgdHlwZSldLCBwcmltYXJ5ID0gbWFya2Vyc1swXTtcXG4gIHZhciB3aWRnZXQgPSBvcHRpb25zLndpZGdldE5vZGU7XFxuICBsaW5rZWREb2NzKGRvYywgZnVuY3Rpb24gKGRvYykge1xcbiAgICBpZiAod2lkZ2V0KSB7IG9wdGlvbnMud2lkZ2V0Tm9kZSA9IHdpZGdldC5jbG9uZU5vZGUodHJ1ZSk7IH1cXG4gICAgbWFya2Vycy5wdXNoKG1hcmtUZXh0KGRvYywgY2xpcFBvcyhkb2MsIGZyb20pLCBjbGlwUG9zKGRvYywgdG8pLCBvcHRpb25zLCB0eXBlKSk7XFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZG9jLmxpbmtlZC5sZW5ndGg7ICsraSlcXG4gICAgICB7IGlmIChkb2MubGlua2VkW2ldLmlzUGFyZW50KSB7IHJldHVybiB9IH1cXG4gICAgcHJpbWFyeSA9IGxzdChtYXJrZXJzKTtcXG4gIH0pO1xcbiAgcmV0dXJuIG5ldyBTaGFyZWRUZXh0TWFya2VyKG1hcmtlcnMsIHByaW1hcnkpXFxufVxcblxcbmZ1bmN0aW9uIGZpbmRTaGFyZWRNYXJrZXJzKGRvYykge1xcbiAgcmV0dXJuIGRvYy5maW5kTWFya3MoUG9zKGRvYy5maXJzdCwgMCksIGRvYy5jbGlwUG9zKFBvcyhkb2MubGFzdExpbmUoKSkpLCBmdW5jdGlvbiAobSkgeyByZXR1cm4gbS5wYXJlbnQ7IH0pXFxufVxcblxcbmZ1bmN0aW9uIGNvcHlTaGFyZWRNYXJrZXJzKGRvYywgbWFya2Vycykge1xcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXJrZXJzLmxlbmd0aDsgaSsrKSB7XFxuICAgIHZhciBtYXJrZXIgPSBtYXJrZXJzW2ldLCBwb3MgPSBtYXJrZXIuZmluZCgpO1xcbiAgICB2YXIgbUZyb20gPSBkb2MuY2xpcFBvcyhwb3MuZnJvbSksIG1UbyA9IGRvYy5jbGlwUG9zKHBvcy50byk7XFxuICAgIGlmIChjbXAobUZyb20sIG1UbykpIHtcXG4gICAgICB2YXIgc3ViTWFyayA9IG1hcmtUZXh0KGRvYywgbUZyb20sIG1UbywgbWFya2VyLnByaW1hcnksIG1hcmtlci5wcmltYXJ5LnR5cGUpO1xcbiAgICAgIG1hcmtlci5tYXJrZXJzLnB1c2goc3ViTWFyayk7XFxuICAgICAgc3ViTWFyay5wYXJlbnQgPSBtYXJrZXI7XFxuICAgIH1cXG4gIH1cXG59XFxuXFxuZnVuY3Rpb24gZGV0YWNoU2hhcmVkTWFya2VycyhtYXJrZXJzKSB7XFxuICB2YXIgbG9vcCA9IGZ1bmN0aW9uICggaSApIHtcXG4gICAgdmFyIG1hcmtlciA9IG1hcmtlcnNbaV0sIGxpbmtlZCA9IFttYXJrZXIucHJpbWFyeS5kb2NdO1xcbiAgICBsaW5rZWREb2NzKG1hcmtlci5wcmltYXJ5LmRvYywgZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGxpbmtlZC5wdXNoKGQpOyB9KTtcXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBtYXJrZXIubWFya2Vycy5sZW5ndGg7IGorKykge1xcbiAgICAgIHZhciBzdWJNYXJrZXIgPSBtYXJrZXIubWFya2Vyc1tqXTtcXG4gICAgICBpZiAoaW5kZXhPZihsaW5rZWQsIHN1Yk1hcmtlci5kb2MpID09IC0xKSB7XFxuICAgICAgICBzdWJNYXJrZXIucGFyZW50ID0gbnVsbDtcXG4gICAgICAgIG1hcmtlci5tYXJrZXJzLnNwbGljZShqLS0sIDEpO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgfTtcXG5cXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbWFya2Vycy5sZW5ndGg7IGkrKykgbG9vcCggaSApO1xcbn1cXG5cXG52YXIgbmV4dERvY0lkID0gMDtcXG52YXIgRG9jID0gZnVuY3Rpb24odGV4dCwgbW9kZSwgZmlyc3RMaW5lLCBsaW5lU2VwLCBkaXJlY3Rpb24pIHtcXG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBEb2MpKSB7IHJldHVybiBuZXcgRG9jKHRleHQsIG1vZGUsIGZpcnN0TGluZSwgbGluZVNlcCwgZGlyZWN0aW9uKSB9XFxuICBpZiAoZmlyc3RMaW5lID09IG51bGwpIHsgZmlyc3RMaW5lID0gMDsgfVxcblxcbiAgQnJhbmNoQ2h1bmsuY2FsbCh0aGlzLCBbbmV3IExlYWZDaHVuayhbbmV3IExpbmUoXFxcIlxcXCIsIG51bGwpXSldKTtcXG4gIHRoaXMuZmlyc3QgPSBmaXJzdExpbmU7XFxuICB0aGlzLnNjcm9sbFRvcCA9IHRoaXMuc2Nyb2xsTGVmdCA9IDA7XFxuICB0aGlzLmNhbnRFZGl0ID0gZmFsc2U7XFxuICB0aGlzLmNsZWFuR2VuZXJhdGlvbiA9IDE7XFxuICB0aGlzLmZyb250aWVyID0gZmlyc3RMaW5lO1xcbiAgdmFyIHN0YXJ0ID0gUG9zKGZpcnN0TGluZSwgMCk7XFxuICB0aGlzLnNlbCA9IHNpbXBsZVNlbGVjdGlvbihzdGFydCk7XFxuICB0aGlzLmhpc3RvcnkgPSBuZXcgSGlzdG9yeShudWxsKTtcXG4gIHRoaXMuaWQgPSArK25leHREb2NJZDtcXG4gIHRoaXMubW9kZU9wdGlvbiA9IG1vZGU7XFxuICB0aGlzLmxpbmVTZXAgPSBsaW5lU2VwO1xcbiAgdGhpcy5kaXJlY3Rpb24gPSAoZGlyZWN0aW9uID09IFxcXCJydGxcXFwiKSA/IFxcXCJydGxcXFwiIDogXFxcImx0clxcXCI7XFxuICB0aGlzLmV4dGVuZCA9IGZhbHNlO1xcblxcbiAgaWYgKHR5cGVvZiB0ZXh0ID09IFxcXCJzdHJpbmdcXFwiKSB7IHRleHQgPSB0aGlzLnNwbGl0TGluZXModGV4dCk7IH1cXG4gIHVwZGF0ZURvYyh0aGlzLCB7ZnJvbTogc3RhcnQsIHRvOiBzdGFydCwgdGV4dDogdGV4dH0pO1xcbiAgc2V0U2VsZWN0aW9uKHRoaXMsIHNpbXBsZVNlbGVjdGlvbihzdGFydCksIHNlbF9kb250U2Nyb2xsKTtcXG59O1xcblxcbkRvYy5wcm90b3R5cGUgPSBjcmVhdGVPYmooQnJhbmNoQ2h1bmsucHJvdG90eXBlLCB7XFxuICBjb25zdHJ1Y3RvcjogRG9jLFxcbiAgLy8gSXRlcmF0ZSBvdmVyIHRoZSBkb2N1bWVudC4gU3VwcG9ydHMgdHdvIGZvcm1zIC0tIHdpdGggb25seSBvbmVcXG4gIC8vIGFyZ3VtZW50LCBpdCBjYWxscyB0aGF0IGZvciBlYWNoIGxpbmUgaW4gdGhlIGRvY3VtZW50LiBXaXRoXFxuICAvLyB0aHJlZSwgaXQgaXRlcmF0ZXMgb3ZlciB0aGUgcmFuZ2UgZ2l2ZW4gYnkgdGhlIGZpcnN0IHR3byAod2l0aFxcbiAgLy8gdGhlIHNlY29uZCBiZWluZyBub24taW5jbHVzaXZlKS5cXG4gIGl0ZXI6IGZ1bmN0aW9uKGZyb20sIHRvLCBvcCkge1xcbiAgICBpZiAob3ApIHsgdGhpcy5pdGVyTihmcm9tIC0gdGhpcy5maXJzdCwgdG8gLSBmcm9tLCBvcCk7IH1cXG4gICAgZWxzZSB7IHRoaXMuaXRlck4odGhpcy5maXJzdCwgdGhpcy5maXJzdCArIHRoaXMuc2l6ZSwgZnJvbSk7IH1cXG4gIH0sXFxuXFxuICAvLyBOb24tcHVibGljIGludGVyZmFjZSBmb3IgYWRkaW5nIGFuZCByZW1vdmluZyBsaW5lcy5cXG4gIGluc2VydDogZnVuY3Rpb24oYXQsIGxpbmVzKSB7XFxuICAgIHZhciBoZWlnaHQgPSAwO1xcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgKytpKSB7IGhlaWdodCArPSBsaW5lc1tpXS5oZWlnaHQ7IH1cXG4gICAgdGhpcy5pbnNlcnRJbm5lcihhdCAtIHRoaXMuZmlyc3QsIGxpbmVzLCBoZWlnaHQpO1xcbiAgfSxcXG4gIHJlbW92ZTogZnVuY3Rpb24oYXQsIG4pIHsgdGhpcy5yZW1vdmVJbm5lcihhdCAtIHRoaXMuZmlyc3QsIG4pOyB9LFxcblxcbiAgLy8gRnJvbSBoZXJlLCB0aGUgbWV0aG9kcyBhcmUgcGFydCBvZiB0aGUgcHVibGljIGludGVyZmFjZS4gTW9zdFxcbiAgLy8gYXJlIGFsc28gYXZhaWxhYmxlIGZyb20gQ29kZU1pcnJvciAoZWRpdG9yKSBpbnN0YW5jZXMuXFxuXFxuICBnZXRWYWx1ZTogZnVuY3Rpb24obGluZVNlcCkge1xcbiAgICB2YXIgbGluZXMgPSBnZXRMaW5lcyh0aGlzLCB0aGlzLmZpcnN0LCB0aGlzLmZpcnN0ICsgdGhpcy5zaXplKTtcXG4gICAgaWYgKGxpbmVTZXAgPT09IGZhbHNlKSB7IHJldHVybiBsaW5lcyB9XFxuICAgIHJldHVybiBsaW5lcy5qb2luKGxpbmVTZXAgfHwgdGhpcy5saW5lU2VwYXJhdG9yKCkpXFxuICB9LFxcbiAgc2V0VmFsdWU6IGRvY01ldGhvZE9wKGZ1bmN0aW9uKGNvZGUpIHtcXG4gICAgdmFyIHRvcCA9IFBvcyh0aGlzLmZpcnN0LCAwKSwgbGFzdCA9IHRoaXMuZmlyc3QgKyB0aGlzLnNpemUgLSAxO1xcbiAgICBtYWtlQ2hhbmdlKHRoaXMsIHtmcm9tOiB0b3AsIHRvOiBQb3MobGFzdCwgZ2V0TGluZSh0aGlzLCBsYXN0KS50ZXh0Lmxlbmd0aCksXFxuICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IHRoaXMuc3BsaXRMaW5lcyhjb2RlKSwgb3JpZ2luOiBcXFwic2V0VmFsdWVcXFwiLCBmdWxsOiB0cnVlfSwgdHJ1ZSk7XFxuICAgIHNldFNlbGVjdGlvbih0aGlzLCBzaW1wbGVTZWxlY3Rpb24odG9wKSk7XFxuICB9KSxcXG4gIHJlcGxhY2VSYW5nZTogZnVuY3Rpb24oY29kZSwgZnJvbSwgdG8sIG9yaWdpbikge1xcbiAgICBmcm9tID0gY2xpcFBvcyh0aGlzLCBmcm9tKTtcXG4gICAgdG8gPSB0byA/IGNsaXBQb3ModGhpcywgdG8pIDogZnJvbTtcXG4gICAgcmVwbGFjZVJhbmdlKHRoaXMsIGNvZGUsIGZyb20sIHRvLCBvcmlnaW4pO1xcbiAgfSxcXG4gIGdldFJhbmdlOiBmdW5jdGlvbihmcm9tLCB0bywgbGluZVNlcCkge1xcbiAgICB2YXIgbGluZXMgPSBnZXRCZXR3ZWVuKHRoaXMsIGNsaXBQb3ModGhpcywgZnJvbSksIGNsaXBQb3ModGhpcywgdG8pKTtcXG4gICAgaWYgKGxpbmVTZXAgPT09IGZhbHNlKSB7IHJldHVybiBsaW5lcyB9XFxuICAgIHJldHVybiBsaW5lcy5qb2luKGxpbmVTZXAgfHwgdGhpcy5saW5lU2VwYXJhdG9yKCkpXFxuICB9LFxcblxcbiAgZ2V0TGluZTogZnVuY3Rpb24obGluZSkge3ZhciBsID0gdGhpcy5nZXRMaW5lSGFuZGxlKGxpbmUpOyByZXR1cm4gbCAmJiBsLnRleHR9LFxcblxcbiAgZ2V0TGluZUhhbmRsZTogZnVuY3Rpb24obGluZSkge2lmIChpc0xpbmUodGhpcywgbGluZSkpIHsgcmV0dXJuIGdldExpbmUodGhpcywgbGluZSkgfX0sXFxuICBnZXRMaW5lTnVtYmVyOiBmdW5jdGlvbihsaW5lKSB7cmV0dXJuIGxpbmVObyhsaW5lKX0sXFxuXFxuICBnZXRMaW5lSGFuZGxlVmlzdWFsU3RhcnQ6IGZ1bmN0aW9uKGxpbmUpIHtcXG4gICAgaWYgKHR5cGVvZiBsaW5lID09IFxcXCJudW1iZXJcXFwiKSB7IGxpbmUgPSBnZXRMaW5lKHRoaXMsIGxpbmUpOyB9XFxuICAgIHJldHVybiB2aXN1YWxMaW5lKGxpbmUpXFxuICB9LFxcblxcbiAgbGluZUNvdW50OiBmdW5jdGlvbigpIHtyZXR1cm4gdGhpcy5zaXplfSxcXG4gIGZpcnN0TGluZTogZnVuY3Rpb24oKSB7cmV0dXJuIHRoaXMuZmlyc3R9LFxcbiAgbGFzdExpbmU6IGZ1bmN0aW9uKCkge3JldHVybiB0aGlzLmZpcnN0ICsgdGhpcy5zaXplIC0gMX0sXFxuXFxuICBjbGlwUG9zOiBmdW5jdGlvbihwb3MpIHtyZXR1cm4gY2xpcFBvcyh0aGlzLCBwb3MpfSxcXG5cXG4gIGdldEN1cnNvcjogZnVuY3Rpb24oc3RhcnQpIHtcXG4gICAgdmFyIHJhbmdlJCQxID0gdGhpcy5zZWwucHJpbWFyeSgpLCBwb3M7XFxuICAgIGlmIChzdGFydCA9PSBudWxsIHx8IHN0YXJ0ID09IFxcXCJoZWFkXFxcIikgeyBwb3MgPSByYW5nZSQkMS5oZWFkOyB9XFxuICAgIGVsc2UgaWYgKHN0YXJ0ID09IFxcXCJhbmNob3JcXFwiKSB7IHBvcyA9IHJhbmdlJCQxLmFuY2hvcjsgfVxcbiAgICBlbHNlIGlmIChzdGFydCA9PSBcXFwiZW5kXFxcIiB8fCBzdGFydCA9PSBcXFwidG9cXFwiIHx8IHN0YXJ0ID09PSBmYWxzZSkgeyBwb3MgPSByYW5nZSQkMS50bygpOyB9XFxuICAgIGVsc2UgeyBwb3MgPSByYW5nZSQkMS5mcm9tKCk7IH1cXG4gICAgcmV0dXJuIHBvc1xcbiAgfSxcXG4gIGxpc3RTZWxlY3Rpb25zOiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuc2VsLnJhbmdlcyB9LFxcbiAgc29tZXRoaW5nU2VsZWN0ZWQ6IGZ1bmN0aW9uKCkge3JldHVybiB0aGlzLnNlbC5zb21ldGhpbmdTZWxlY3RlZCgpfSxcXG5cXG4gIHNldEN1cnNvcjogZG9jTWV0aG9kT3AoZnVuY3Rpb24obGluZSwgY2gsIG9wdGlvbnMpIHtcXG4gICAgc2V0U2ltcGxlU2VsZWN0aW9uKHRoaXMsIGNsaXBQb3ModGhpcywgdHlwZW9mIGxpbmUgPT0gXFxcIm51bWJlclxcXCIgPyBQb3MobGluZSwgY2ggfHwgMCkgOiBsaW5lKSwgbnVsbCwgb3B0aW9ucyk7XFxuICB9KSxcXG4gIHNldFNlbGVjdGlvbjogZG9jTWV0aG9kT3AoZnVuY3Rpb24oYW5jaG9yLCBoZWFkLCBvcHRpb25zKSB7XFxuICAgIHNldFNpbXBsZVNlbGVjdGlvbih0aGlzLCBjbGlwUG9zKHRoaXMsIGFuY2hvciksIGNsaXBQb3ModGhpcywgaGVhZCB8fCBhbmNob3IpLCBvcHRpb25zKTtcXG4gIH0pLFxcbiAgZXh0ZW5kU2VsZWN0aW9uOiBkb2NNZXRob2RPcChmdW5jdGlvbihoZWFkLCBvdGhlciwgb3B0aW9ucykge1xcbiAgICBleHRlbmRTZWxlY3Rpb24odGhpcywgY2xpcFBvcyh0aGlzLCBoZWFkKSwgb3RoZXIgJiYgY2xpcFBvcyh0aGlzLCBvdGhlciksIG9wdGlvbnMpO1xcbiAgfSksXFxuICBleHRlbmRTZWxlY3Rpb25zOiBkb2NNZXRob2RPcChmdW5jdGlvbihoZWFkcywgb3B0aW9ucykge1xcbiAgICBleHRlbmRTZWxlY3Rpb25zKHRoaXMsIGNsaXBQb3NBcnJheSh0aGlzLCBoZWFkcyksIG9wdGlvbnMpO1xcbiAgfSksXFxuICBleHRlbmRTZWxlY3Rpb25zQnk6IGRvY01ldGhvZE9wKGZ1bmN0aW9uKGYsIG9wdGlvbnMpIHtcXG4gICAgdmFyIGhlYWRzID0gbWFwKHRoaXMuc2VsLnJhbmdlcywgZik7XFxuICAgIGV4dGVuZFNlbGVjdGlvbnModGhpcywgY2xpcFBvc0FycmF5KHRoaXMsIGhlYWRzKSwgb3B0aW9ucyk7XFxuICB9KSxcXG4gIHNldFNlbGVjdGlvbnM6IGRvY01ldGhvZE9wKGZ1bmN0aW9uKHJhbmdlcywgcHJpbWFyeSwgb3B0aW9ucykge1xcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcXG5cXG4gICAgaWYgKCFyYW5nZXMubGVuZ3RoKSB7IHJldHVybiB9XFxuICAgIHZhciBvdXQgPSBbXTtcXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCByYW5nZXMubGVuZ3RoOyBpKyspXFxuICAgICAgeyBvdXRbaV0gPSBuZXcgUmFuZ2UoY2xpcFBvcyh0aGlzJDEsIHJhbmdlc1tpXS5hbmNob3IpLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICBjbGlwUG9zKHRoaXMkMSwgcmFuZ2VzW2ldLmhlYWQpKTsgfVxcbiAgICBpZiAocHJpbWFyeSA9PSBudWxsKSB7IHByaW1hcnkgPSBNYXRoLm1pbihyYW5nZXMubGVuZ3RoIC0gMSwgdGhpcy5zZWwucHJpbUluZGV4KTsgfVxcbiAgICBzZXRTZWxlY3Rpb24odGhpcywgbm9ybWFsaXplU2VsZWN0aW9uKG91dCwgcHJpbWFyeSksIG9wdGlvbnMpO1xcbiAgfSksXFxuICBhZGRTZWxlY3Rpb246IGRvY01ldGhvZE9wKGZ1bmN0aW9uKGFuY2hvciwgaGVhZCwgb3B0aW9ucykge1xcbiAgICB2YXIgcmFuZ2VzID0gdGhpcy5zZWwucmFuZ2VzLnNsaWNlKDApO1xcbiAgICByYW5nZXMucHVzaChuZXcgUmFuZ2UoY2xpcFBvcyh0aGlzLCBhbmNob3IpLCBjbGlwUG9zKHRoaXMsIGhlYWQgfHwgYW5jaG9yKSkpO1xcbiAgICBzZXRTZWxlY3Rpb24odGhpcywgbm9ybWFsaXplU2VsZWN0aW9uKHJhbmdlcywgcmFuZ2VzLmxlbmd0aCAtIDEpLCBvcHRpb25zKTtcXG4gIH0pLFxcblxcbiAgZ2V0U2VsZWN0aW9uOiBmdW5jdGlvbihsaW5lU2VwKSB7XFxuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xcblxcbiAgICB2YXIgcmFuZ2VzID0gdGhpcy5zZWwucmFuZ2VzLCBsaW5lcztcXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCByYW5nZXMubGVuZ3RoOyBpKyspIHtcXG4gICAgICB2YXIgc2VsID0gZ2V0QmV0d2Vlbih0aGlzJDEsIHJhbmdlc1tpXS5mcm9tKCksIHJhbmdlc1tpXS50bygpKTtcXG4gICAgICBsaW5lcyA9IGxpbmVzID8gbGluZXMuY29uY2F0KHNlbCkgOiBzZWw7XFxuICAgIH1cXG4gICAgaWYgKGxpbmVTZXAgPT09IGZhbHNlKSB7IHJldHVybiBsaW5lcyB9XFxuICAgIGVsc2UgeyByZXR1cm4gbGluZXMuam9pbihsaW5lU2VwIHx8IHRoaXMubGluZVNlcGFyYXRvcigpKSB9XFxuICB9LFxcbiAgZ2V0U2VsZWN0aW9uczogZnVuY3Rpb24obGluZVNlcCkge1xcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcXG5cXG4gICAgdmFyIHBhcnRzID0gW10sIHJhbmdlcyA9IHRoaXMuc2VsLnJhbmdlcztcXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCByYW5nZXMubGVuZ3RoOyBpKyspIHtcXG4gICAgICB2YXIgc2VsID0gZ2V0QmV0d2Vlbih0aGlzJDEsIHJhbmdlc1tpXS5mcm9tKCksIHJhbmdlc1tpXS50bygpKTtcXG4gICAgICBpZiAobGluZVNlcCAhPT0gZmFsc2UpIHsgc2VsID0gc2VsLmpvaW4obGluZVNlcCB8fCB0aGlzJDEubGluZVNlcGFyYXRvcigpKTsgfVxcbiAgICAgIHBhcnRzW2ldID0gc2VsO1xcbiAgICB9XFxuICAgIHJldHVybiBwYXJ0c1xcbiAgfSxcXG4gIHJlcGxhY2VTZWxlY3Rpb246IGZ1bmN0aW9uKGNvZGUsIGNvbGxhcHNlLCBvcmlnaW4pIHtcXG4gICAgdmFyIGR1cCA9IFtdO1xcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuc2VsLnJhbmdlcy5sZW5ndGg7IGkrKylcXG4gICAgICB7IGR1cFtpXSA9IGNvZGU7IH1cXG4gICAgdGhpcy5yZXBsYWNlU2VsZWN0aW9ucyhkdXAsIGNvbGxhcHNlLCBvcmlnaW4gfHwgXFxcIitpbnB1dFxcXCIpO1xcbiAgfSxcXG4gIHJlcGxhY2VTZWxlY3Rpb25zOiBkb2NNZXRob2RPcChmdW5jdGlvbihjb2RlLCBjb2xsYXBzZSwgb3JpZ2luKSB7XFxuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xcblxcbiAgICB2YXIgY2hhbmdlcyA9IFtdLCBzZWwgPSB0aGlzLnNlbDtcXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWwucmFuZ2VzLmxlbmd0aDsgaSsrKSB7XFxuICAgICAgdmFyIHJhbmdlJCQxID0gc2VsLnJhbmdlc1tpXTtcXG4gICAgICBjaGFuZ2VzW2ldID0ge2Zyb206IHJhbmdlJCQxLmZyb20oKSwgdG86IHJhbmdlJCQxLnRvKCksIHRleHQ6IHRoaXMkMS5zcGxpdExpbmVzKGNvZGVbaV0pLCBvcmlnaW46IG9yaWdpbn07XFxuICAgIH1cXG4gICAgdmFyIG5ld1NlbCA9IGNvbGxhcHNlICYmIGNvbGxhcHNlICE9IFxcXCJlbmRcXFwiICYmIGNvbXB1dGVSZXBsYWNlZFNlbCh0aGlzLCBjaGFuZ2VzLCBjb2xsYXBzZSk7XFxuICAgIGZvciAodmFyIGkkMSA9IGNoYW5nZXMubGVuZ3RoIC0gMTsgaSQxID49IDA7IGkkMS0tKVxcbiAgICAgIHsgbWFrZUNoYW5nZSh0aGlzJDEsIGNoYW5nZXNbaSQxXSk7IH1cXG4gICAgaWYgKG5ld1NlbCkgeyBzZXRTZWxlY3Rpb25SZXBsYWNlSGlzdG9yeSh0aGlzLCBuZXdTZWwpOyB9XFxuICAgIGVsc2UgaWYgKHRoaXMuY20pIHsgZW5zdXJlQ3Vyc29yVmlzaWJsZSh0aGlzLmNtKTsgfVxcbiAgfSksXFxuICB1bmRvOiBkb2NNZXRob2RPcChmdW5jdGlvbigpIHttYWtlQ2hhbmdlRnJvbUhpc3RvcnkodGhpcywgXFxcInVuZG9cXFwiKTt9KSxcXG4gIHJlZG86IGRvY01ldGhvZE9wKGZ1bmN0aW9uKCkge21ha2VDaGFuZ2VGcm9tSGlzdG9yeSh0aGlzLCBcXFwicmVkb1xcXCIpO30pLFxcbiAgdW5kb1NlbGVjdGlvbjogZG9jTWV0aG9kT3AoZnVuY3Rpb24oKSB7bWFrZUNoYW5nZUZyb21IaXN0b3J5KHRoaXMsIFxcXCJ1bmRvXFxcIiwgdHJ1ZSk7fSksXFxuICByZWRvU2VsZWN0aW9uOiBkb2NNZXRob2RPcChmdW5jdGlvbigpIHttYWtlQ2hhbmdlRnJvbUhpc3RvcnkodGhpcywgXFxcInJlZG9cXFwiLCB0cnVlKTt9KSxcXG5cXG4gIHNldEV4dGVuZGluZzogZnVuY3Rpb24odmFsKSB7dGhpcy5leHRlbmQgPSB2YWw7fSxcXG4gIGdldEV4dGVuZGluZzogZnVuY3Rpb24oKSB7cmV0dXJuIHRoaXMuZXh0ZW5kfSxcXG5cXG4gIGhpc3RvcnlTaXplOiBmdW5jdGlvbigpIHtcXG4gICAgdmFyIGhpc3QgPSB0aGlzLmhpc3RvcnksIGRvbmUgPSAwLCB1bmRvbmUgPSAwO1xcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhpc3QuZG9uZS5sZW5ndGg7IGkrKykgeyBpZiAoIWhpc3QuZG9uZVtpXS5yYW5nZXMpIHsgKytkb25lOyB9IH1cXG4gICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgaGlzdC51bmRvbmUubGVuZ3RoOyBpJDErKykgeyBpZiAoIWhpc3QudW5kb25lW2kkMV0ucmFuZ2VzKSB7ICsrdW5kb25lOyB9IH1cXG4gICAgcmV0dXJuIHt1bmRvOiBkb25lLCByZWRvOiB1bmRvbmV9XFxuICB9LFxcbiAgY2xlYXJIaXN0b3J5OiBmdW5jdGlvbigpIHt0aGlzLmhpc3RvcnkgPSBuZXcgSGlzdG9yeSh0aGlzLmhpc3RvcnkubWF4R2VuZXJhdGlvbik7fSxcXG5cXG4gIG1hcmtDbGVhbjogZnVuY3Rpb24oKSB7XFxuICAgIHRoaXMuY2xlYW5HZW5lcmF0aW9uID0gdGhpcy5jaGFuZ2VHZW5lcmF0aW9uKHRydWUpO1xcbiAgfSxcXG4gIGNoYW5nZUdlbmVyYXRpb246IGZ1bmN0aW9uKGZvcmNlU3BsaXQpIHtcXG4gICAgaWYgKGZvcmNlU3BsaXQpXFxuICAgICAgeyB0aGlzLmhpc3RvcnkubGFzdE9wID0gdGhpcy5oaXN0b3J5Lmxhc3RTZWxPcCA9IHRoaXMuaGlzdG9yeS5sYXN0T3JpZ2luID0gbnVsbDsgfVxcbiAgICByZXR1cm4gdGhpcy5oaXN0b3J5LmdlbmVyYXRpb25cXG4gIH0sXFxuICBpc0NsZWFuOiBmdW5jdGlvbiAoZ2VuKSB7XFxuICAgIHJldHVybiB0aGlzLmhpc3RvcnkuZ2VuZXJhdGlvbiA9PSAoZ2VuIHx8IHRoaXMuY2xlYW5HZW5lcmF0aW9uKVxcbiAgfSxcXG5cXG4gIGdldEhpc3Rvcnk6IGZ1bmN0aW9uKCkge1xcbiAgICByZXR1cm4ge2RvbmU6IGNvcHlIaXN0b3J5QXJyYXkodGhpcy5oaXN0b3J5LmRvbmUpLFxcbiAgICAgICAgICAgIHVuZG9uZTogY29weUhpc3RvcnlBcnJheSh0aGlzLmhpc3RvcnkudW5kb25lKX1cXG4gIH0sXFxuICBzZXRIaXN0b3J5OiBmdW5jdGlvbihoaXN0RGF0YSkge1xcbiAgICB2YXIgaGlzdCA9IHRoaXMuaGlzdG9yeSA9IG5ldyBIaXN0b3J5KHRoaXMuaGlzdG9yeS5tYXhHZW5lcmF0aW9uKTtcXG4gICAgaGlzdC5kb25lID0gY29weUhpc3RvcnlBcnJheShoaXN0RGF0YS5kb25lLnNsaWNlKDApLCBudWxsLCB0cnVlKTtcXG4gICAgaGlzdC51bmRvbmUgPSBjb3B5SGlzdG9yeUFycmF5KGhpc3REYXRhLnVuZG9uZS5zbGljZSgwKSwgbnVsbCwgdHJ1ZSk7XFxuICB9LFxcblxcbiAgc2V0R3V0dGVyTWFya2VyOiBkb2NNZXRob2RPcChmdW5jdGlvbihsaW5lLCBndXR0ZXJJRCwgdmFsdWUpIHtcXG4gICAgcmV0dXJuIGNoYW5nZUxpbmUodGhpcywgbGluZSwgXFxcImd1dHRlclxcXCIsIGZ1bmN0aW9uIChsaW5lKSB7XFxuICAgICAgdmFyIG1hcmtlcnMgPSBsaW5lLmd1dHRlck1hcmtlcnMgfHwgKGxpbmUuZ3V0dGVyTWFya2VycyA9IHt9KTtcXG4gICAgICBtYXJrZXJzW2d1dHRlcklEXSA9IHZhbHVlO1xcbiAgICAgIGlmICghdmFsdWUgJiYgaXNFbXB0eShtYXJrZXJzKSkgeyBsaW5lLmd1dHRlck1hcmtlcnMgPSBudWxsOyB9XFxuICAgICAgcmV0dXJuIHRydWVcXG4gICAgfSlcXG4gIH0pLFxcblxcbiAgY2xlYXJHdXR0ZXI6IGRvY01ldGhvZE9wKGZ1bmN0aW9uKGd1dHRlcklEKSB7XFxuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xcblxcbiAgICB0aGlzLml0ZXIoZnVuY3Rpb24gKGxpbmUpIHtcXG4gICAgICBpZiAobGluZS5ndXR0ZXJNYXJrZXJzICYmIGxpbmUuZ3V0dGVyTWFya2Vyc1tndXR0ZXJJRF0pIHtcXG4gICAgICAgIGNoYW5nZUxpbmUodGhpcyQxLCBsaW5lLCBcXFwiZ3V0dGVyXFxcIiwgZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICBsaW5lLmd1dHRlck1hcmtlcnNbZ3V0dGVySURdID0gbnVsbDtcXG4gICAgICAgICAgaWYgKGlzRW1wdHkobGluZS5ndXR0ZXJNYXJrZXJzKSkgeyBsaW5lLmd1dHRlck1hcmtlcnMgPSBudWxsOyB9XFxuICAgICAgICAgIHJldHVybiB0cnVlXFxuICAgICAgICB9KTtcXG4gICAgICB9XFxuICAgIH0pO1xcbiAgfSksXFxuXFxuICBsaW5lSW5mbzogZnVuY3Rpb24obGluZSkge1xcbiAgICB2YXIgbjtcXG4gICAgaWYgKHR5cGVvZiBsaW5lID09IFxcXCJudW1iZXJcXFwiKSB7XFxuICAgICAgaWYgKCFpc0xpbmUodGhpcywgbGluZSkpIHsgcmV0dXJuIG51bGwgfVxcbiAgICAgIG4gPSBsaW5lO1xcbiAgICAgIGxpbmUgPSBnZXRMaW5lKHRoaXMsIGxpbmUpO1xcbiAgICAgIGlmICghbGluZSkgeyByZXR1cm4gbnVsbCB9XFxuICAgIH0gZWxzZSB7XFxuICAgICAgbiA9IGxpbmVObyhsaW5lKTtcXG4gICAgICBpZiAobiA9PSBudWxsKSB7IHJldHVybiBudWxsIH1cXG4gICAgfVxcbiAgICByZXR1cm4ge2xpbmU6IG4sIGhhbmRsZTogbGluZSwgdGV4dDogbGluZS50ZXh0LCBndXR0ZXJNYXJrZXJzOiBsaW5lLmd1dHRlck1hcmtlcnMsXFxuICAgICAgICAgICAgdGV4dENsYXNzOiBsaW5lLnRleHRDbGFzcywgYmdDbGFzczogbGluZS5iZ0NsYXNzLCB3cmFwQ2xhc3M6IGxpbmUud3JhcENsYXNzLFxcbiAgICAgICAgICAgIHdpZGdldHM6IGxpbmUud2lkZ2V0c31cXG4gIH0sXFxuXFxuICBhZGRMaW5lQ2xhc3M6IGRvY01ldGhvZE9wKGZ1bmN0aW9uKGhhbmRsZSwgd2hlcmUsIGNscykge1xcbiAgICByZXR1cm4gY2hhbmdlTGluZSh0aGlzLCBoYW5kbGUsIHdoZXJlID09IFxcXCJndXR0ZXJcXFwiID8gXFxcImd1dHRlclxcXCIgOiBcXFwiY2xhc3NcXFwiLCBmdW5jdGlvbiAobGluZSkge1xcbiAgICAgIHZhciBwcm9wID0gd2hlcmUgPT0gXFxcInRleHRcXFwiID8gXFxcInRleHRDbGFzc1xcXCJcXG4gICAgICAgICAgICAgICA6IHdoZXJlID09IFxcXCJiYWNrZ3JvdW5kXFxcIiA/IFxcXCJiZ0NsYXNzXFxcIlxcbiAgICAgICAgICAgICAgIDogd2hlcmUgPT0gXFxcImd1dHRlclxcXCIgPyBcXFwiZ3V0dGVyQ2xhc3NcXFwiIDogXFxcIndyYXBDbGFzc1xcXCI7XFxuICAgICAgaWYgKCFsaW5lW3Byb3BdKSB7IGxpbmVbcHJvcF0gPSBjbHM7IH1cXG4gICAgICBlbHNlIGlmIChjbGFzc1Rlc3QoY2xzKS50ZXN0KGxpbmVbcHJvcF0pKSB7IHJldHVybiBmYWxzZSB9XFxuICAgICAgZWxzZSB7IGxpbmVbcHJvcF0gKz0gXFxcIiBcXFwiICsgY2xzOyB9XFxuICAgICAgcmV0dXJuIHRydWVcXG4gICAgfSlcXG4gIH0pLFxcbiAgcmVtb3ZlTGluZUNsYXNzOiBkb2NNZXRob2RPcChmdW5jdGlvbihoYW5kbGUsIHdoZXJlLCBjbHMpIHtcXG4gICAgcmV0dXJuIGNoYW5nZUxpbmUodGhpcywgaGFuZGxlLCB3aGVyZSA9PSBcXFwiZ3V0dGVyXFxcIiA/IFxcXCJndXR0ZXJcXFwiIDogXFxcImNsYXNzXFxcIiwgZnVuY3Rpb24gKGxpbmUpIHtcXG4gICAgICB2YXIgcHJvcCA9IHdoZXJlID09IFxcXCJ0ZXh0XFxcIiA/IFxcXCJ0ZXh0Q2xhc3NcXFwiXFxuICAgICAgICAgICAgICAgOiB3aGVyZSA9PSBcXFwiYmFja2dyb3VuZFxcXCIgPyBcXFwiYmdDbGFzc1xcXCJcXG4gICAgICAgICAgICAgICA6IHdoZXJlID09IFxcXCJndXR0ZXJcXFwiID8gXFxcImd1dHRlckNsYXNzXFxcIiA6IFxcXCJ3cmFwQ2xhc3NcXFwiO1xcbiAgICAgIHZhciBjdXIgPSBsaW5lW3Byb3BdO1xcbiAgICAgIGlmICghY3VyKSB7IHJldHVybiBmYWxzZSB9XFxuICAgICAgZWxzZSBpZiAoY2xzID09IG51bGwpIHsgbGluZVtwcm9wXSA9IG51bGw7IH1cXG4gICAgICBlbHNlIHtcXG4gICAgICAgIHZhciBmb3VuZCA9IGN1ci5tYXRjaChjbGFzc1Rlc3QoY2xzKSk7XFxuICAgICAgICBpZiAoIWZvdW5kKSB7IHJldHVybiBmYWxzZSB9XFxuICAgICAgICB2YXIgZW5kID0gZm91bmQuaW5kZXggKyBmb3VuZFswXS5sZW5ndGg7XFxuICAgICAgICBsaW5lW3Byb3BdID0gY3VyLnNsaWNlKDAsIGZvdW5kLmluZGV4KSArICghZm91bmQuaW5kZXggfHwgZW5kID09IGN1ci5sZW5ndGggPyBcXFwiXFxcIiA6IFxcXCIgXFxcIikgKyBjdXIuc2xpY2UoZW5kKSB8fCBudWxsO1xcbiAgICAgIH1cXG4gICAgICByZXR1cm4gdHJ1ZVxcbiAgICB9KVxcbiAgfSksXFxuXFxuICBhZGRMaW5lV2lkZ2V0OiBkb2NNZXRob2RPcChmdW5jdGlvbihoYW5kbGUsIG5vZGUsIG9wdGlvbnMpIHtcXG4gICAgcmV0dXJuIGFkZExpbmVXaWRnZXQodGhpcywgaGFuZGxlLCBub2RlLCBvcHRpb25zKVxcbiAgfSksXFxuICByZW1vdmVMaW5lV2lkZ2V0OiBmdW5jdGlvbih3aWRnZXQpIHsgd2lkZ2V0LmNsZWFyKCk7IH0sXFxuXFxuICBtYXJrVGV4dDogZnVuY3Rpb24oZnJvbSwgdG8sIG9wdGlvbnMpIHtcXG4gICAgcmV0dXJuIG1hcmtUZXh0KHRoaXMsIGNsaXBQb3ModGhpcywgZnJvbSksIGNsaXBQb3ModGhpcywgdG8pLCBvcHRpb25zLCBvcHRpb25zICYmIG9wdGlvbnMudHlwZSB8fCBcXFwicmFuZ2VcXFwiKVxcbiAgfSxcXG4gIHNldEJvb2ttYXJrOiBmdW5jdGlvbihwb3MsIG9wdGlvbnMpIHtcXG4gICAgdmFyIHJlYWxPcHRzID0ge3JlcGxhY2VkV2l0aDogb3B0aW9ucyAmJiAob3B0aW9ucy5ub2RlVHlwZSA9PSBudWxsID8gb3B0aW9ucy53aWRnZXQgOiBvcHRpb25zKSxcXG4gICAgICAgICAgICAgICAgICAgIGluc2VydExlZnQ6IG9wdGlvbnMgJiYgb3B0aW9ucy5pbnNlcnRMZWZ0LFxcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJXaGVuRW1wdHk6IGZhbHNlLCBzaGFyZWQ6IG9wdGlvbnMgJiYgb3B0aW9ucy5zaGFyZWQsXFxuICAgICAgICAgICAgICAgICAgICBoYW5kbGVNb3VzZUV2ZW50czogb3B0aW9ucyAmJiBvcHRpb25zLmhhbmRsZU1vdXNlRXZlbnRzfTtcXG4gICAgcG9zID0gY2xpcFBvcyh0aGlzLCBwb3MpO1xcbiAgICByZXR1cm4gbWFya1RleHQodGhpcywgcG9zLCBwb3MsIHJlYWxPcHRzLCBcXFwiYm9va21hcmtcXFwiKVxcbiAgfSxcXG4gIGZpbmRNYXJrc0F0OiBmdW5jdGlvbihwb3MpIHtcXG4gICAgcG9zID0gY2xpcFBvcyh0aGlzLCBwb3MpO1xcbiAgICB2YXIgbWFya2VycyA9IFtdLCBzcGFucyA9IGdldExpbmUodGhpcywgcG9zLmxpbmUpLm1hcmtlZFNwYW5zO1xcbiAgICBpZiAoc3BhbnMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBzcGFucy5sZW5ndGg7ICsraSkge1xcbiAgICAgIHZhciBzcGFuID0gc3BhbnNbaV07XFxuICAgICAgaWYgKChzcGFuLmZyb20gPT0gbnVsbCB8fCBzcGFuLmZyb20gPD0gcG9zLmNoKSAmJlxcbiAgICAgICAgICAoc3Bhbi50byA9PSBudWxsIHx8IHNwYW4udG8gPj0gcG9zLmNoKSlcXG4gICAgICAgIHsgbWFya2Vycy5wdXNoKHNwYW4ubWFya2VyLnBhcmVudCB8fCBzcGFuLm1hcmtlcik7IH1cXG4gICAgfSB9XFxuICAgIHJldHVybiBtYXJrZXJzXFxuICB9LFxcbiAgZmluZE1hcmtzOiBmdW5jdGlvbihmcm9tLCB0bywgZmlsdGVyKSB7XFxuICAgIGZyb20gPSBjbGlwUG9zKHRoaXMsIGZyb20pOyB0byA9IGNsaXBQb3ModGhpcywgdG8pO1xcbiAgICB2YXIgZm91bmQgPSBbXSwgbGluZU5vJCQxID0gZnJvbS5saW5lO1xcbiAgICB0aGlzLml0ZXIoZnJvbS5saW5lLCB0by5saW5lICsgMSwgZnVuY3Rpb24gKGxpbmUpIHtcXG4gICAgICB2YXIgc3BhbnMgPSBsaW5lLm1hcmtlZFNwYW5zO1xcbiAgICAgIGlmIChzcGFucykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHNwYW5zLmxlbmd0aDsgaSsrKSB7XFxuICAgICAgICB2YXIgc3BhbiA9IHNwYW5zW2ldO1xcbiAgICAgICAgaWYgKCEoc3Bhbi50byAhPSBudWxsICYmIGxpbmVObyQkMSA9PSBmcm9tLmxpbmUgJiYgZnJvbS5jaCA+PSBzcGFuLnRvIHx8XFxuICAgICAgICAgICAgICBzcGFuLmZyb20gPT0gbnVsbCAmJiBsaW5lTm8kJDEgIT0gZnJvbS5saW5lIHx8XFxuICAgICAgICAgICAgICBzcGFuLmZyb20gIT0gbnVsbCAmJiBsaW5lTm8kJDEgPT0gdG8ubGluZSAmJiBzcGFuLmZyb20gPj0gdG8uY2gpICYmXFxuICAgICAgICAgICAgKCFmaWx0ZXIgfHwgZmlsdGVyKHNwYW4ubWFya2VyKSkpXFxuICAgICAgICAgIHsgZm91bmQucHVzaChzcGFuLm1hcmtlci5wYXJlbnQgfHwgc3Bhbi5tYXJrZXIpOyB9XFxuICAgICAgfSB9XFxuICAgICAgKytsaW5lTm8kJDE7XFxuICAgIH0pO1xcbiAgICByZXR1cm4gZm91bmRcXG4gIH0sXFxuICBnZXRBbGxNYXJrczogZnVuY3Rpb24oKSB7XFxuICAgIHZhciBtYXJrZXJzID0gW107XFxuICAgIHRoaXMuaXRlcihmdW5jdGlvbiAobGluZSkge1xcbiAgICAgIHZhciBzcHMgPSBsaW5lLm1hcmtlZFNwYW5zO1xcbiAgICAgIGlmIChzcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBzcHMubGVuZ3RoOyArK2kpXFxuICAgICAgICB7IGlmIChzcHNbaV0uZnJvbSAhPSBudWxsKSB7IG1hcmtlcnMucHVzaChzcHNbaV0ubWFya2VyKTsgfSB9IH1cXG4gICAgfSk7XFxuICAgIHJldHVybiBtYXJrZXJzXFxuICB9LFxcblxcbiAgcG9zRnJvbUluZGV4OiBmdW5jdGlvbihvZmYpIHtcXG4gICAgdmFyIGNoLCBsaW5lTm8kJDEgPSB0aGlzLmZpcnN0LCBzZXBTaXplID0gdGhpcy5saW5lU2VwYXJhdG9yKCkubGVuZ3RoO1xcbiAgICB0aGlzLml0ZXIoZnVuY3Rpb24gKGxpbmUpIHtcXG4gICAgICB2YXIgc3ogPSBsaW5lLnRleHQubGVuZ3RoICsgc2VwU2l6ZTtcXG4gICAgICBpZiAoc3ogPiBvZmYpIHsgY2ggPSBvZmY7IHJldHVybiB0cnVlIH1cXG4gICAgICBvZmYgLT0gc3o7XFxuICAgICAgKytsaW5lTm8kJDE7XFxuICAgIH0pO1xcbiAgICByZXR1cm4gY2xpcFBvcyh0aGlzLCBQb3MobGluZU5vJCQxLCBjaCkpXFxuICB9LFxcbiAgaW5kZXhGcm9tUG9zOiBmdW5jdGlvbiAoY29vcmRzKSB7XFxuICAgIGNvb3JkcyA9IGNsaXBQb3ModGhpcywgY29vcmRzKTtcXG4gICAgdmFyIGluZGV4ID0gY29vcmRzLmNoO1xcbiAgICBpZiAoY29vcmRzLmxpbmUgPCB0aGlzLmZpcnN0IHx8IGNvb3Jkcy5jaCA8IDApIHsgcmV0dXJuIDAgfVxcbiAgICB2YXIgc2VwU2l6ZSA9IHRoaXMubGluZVNlcGFyYXRvcigpLmxlbmd0aDtcXG4gICAgdGhpcy5pdGVyKHRoaXMuZmlyc3QsIGNvb3Jkcy5saW5lLCBmdW5jdGlvbiAobGluZSkgeyAvLyBpdGVyIGFib3J0cyB3aGVuIGNhbGxiYWNrIHJldHVybnMgYSB0cnV0aHkgdmFsdWVcXG4gICAgICBpbmRleCArPSBsaW5lLnRleHQubGVuZ3RoICsgc2VwU2l6ZTtcXG4gICAgfSk7XFxuICAgIHJldHVybiBpbmRleFxcbiAgfSxcXG5cXG4gIGNvcHk6IGZ1bmN0aW9uKGNvcHlIaXN0b3J5KSB7XFxuICAgIHZhciBkb2MgPSBuZXcgRG9jKGdldExpbmVzKHRoaXMsIHRoaXMuZmlyc3QsIHRoaXMuZmlyc3QgKyB0aGlzLnNpemUpLFxcbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1vZGVPcHRpb24sIHRoaXMuZmlyc3QsIHRoaXMubGluZVNlcCwgdGhpcy5kaXJlY3Rpb24pO1xcbiAgICBkb2Muc2Nyb2xsVG9wID0gdGhpcy5zY3JvbGxUb3A7IGRvYy5zY3JvbGxMZWZ0ID0gdGhpcy5zY3JvbGxMZWZ0O1xcbiAgICBkb2Muc2VsID0gdGhpcy5zZWw7XFxuICAgIGRvYy5leHRlbmQgPSBmYWxzZTtcXG4gICAgaWYgKGNvcHlIaXN0b3J5KSB7XFxuICAgICAgZG9jLmhpc3RvcnkudW5kb0RlcHRoID0gdGhpcy5oaXN0b3J5LnVuZG9EZXB0aDtcXG4gICAgICBkb2Muc2V0SGlzdG9yeSh0aGlzLmdldEhpc3RvcnkoKSk7XFxuICAgIH1cXG4gICAgcmV0dXJuIGRvY1xcbiAgfSxcXG5cXG4gIGxpbmtlZERvYzogZnVuY3Rpb24ob3B0aW9ucykge1xcbiAgICBpZiAoIW9wdGlvbnMpIHsgb3B0aW9ucyA9IHt9OyB9XFxuICAgIHZhciBmcm9tID0gdGhpcy5maXJzdCwgdG8gPSB0aGlzLmZpcnN0ICsgdGhpcy5zaXplO1xcbiAgICBpZiAob3B0aW9ucy5mcm9tICE9IG51bGwgJiYgb3B0aW9ucy5mcm9tID4gZnJvbSkgeyBmcm9tID0gb3B0aW9ucy5mcm9tOyB9XFxuICAgIGlmIChvcHRpb25zLnRvICE9IG51bGwgJiYgb3B0aW9ucy50byA8IHRvKSB7IHRvID0gb3B0aW9ucy50bzsgfVxcbiAgICB2YXIgY29weSA9IG5ldyBEb2MoZ2V0TGluZXModGhpcywgZnJvbSwgdG8pLCBvcHRpb25zLm1vZGUgfHwgdGhpcy5tb2RlT3B0aW9uLCBmcm9tLCB0aGlzLmxpbmVTZXAsIHRoaXMuZGlyZWN0aW9uKTtcXG4gICAgaWYgKG9wdGlvbnMuc2hhcmVkSGlzdCkgeyBjb3B5Lmhpc3RvcnkgPSB0aGlzLmhpc3RvcnlcXG4gICAgOyB9KHRoaXMubGlua2VkIHx8ICh0aGlzLmxpbmtlZCA9IFtdKSkucHVzaCh7ZG9jOiBjb3B5LCBzaGFyZWRIaXN0OiBvcHRpb25zLnNoYXJlZEhpc3R9KTtcXG4gICAgY29weS5saW5rZWQgPSBbe2RvYzogdGhpcywgaXNQYXJlbnQ6IHRydWUsIHNoYXJlZEhpc3Q6IG9wdGlvbnMuc2hhcmVkSGlzdH1dO1xcbiAgICBjb3B5U2hhcmVkTWFya2Vycyhjb3B5LCBmaW5kU2hhcmVkTWFya2Vycyh0aGlzKSk7XFxuICAgIHJldHVybiBjb3B5XFxuICB9LFxcbiAgdW5saW5rRG9jOiBmdW5jdGlvbihvdGhlcikge1xcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcXG5cXG4gICAgaWYgKG90aGVyIGluc3RhbmNlb2YgQ29kZU1pcnJvciQxKSB7IG90aGVyID0gb3RoZXIuZG9jOyB9XFxuICAgIGlmICh0aGlzLmxpbmtlZCkgeyBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGlua2VkLmxlbmd0aDsgKytpKSB7XFxuICAgICAgdmFyIGxpbmsgPSB0aGlzJDEubGlua2VkW2ldO1xcbiAgICAgIGlmIChsaW5rLmRvYyAhPSBvdGhlcikgeyBjb250aW51ZSB9XFxuICAgICAgdGhpcyQxLmxpbmtlZC5zcGxpY2UoaSwgMSk7XFxuICAgICAgb3RoZXIudW5saW5rRG9jKHRoaXMkMSk7XFxuICAgICAgZGV0YWNoU2hhcmVkTWFya2VycyhmaW5kU2hhcmVkTWFya2Vycyh0aGlzJDEpKTtcXG4gICAgICBicmVha1xcbiAgICB9IH1cXG4gICAgLy8gSWYgdGhlIGhpc3RvcmllcyB3ZXJlIHNoYXJlZCwgc3BsaXQgdGhlbSBhZ2FpblxcbiAgICBpZiAob3RoZXIuaGlzdG9yeSA9PSB0aGlzLmhpc3RvcnkpIHtcXG4gICAgICB2YXIgc3BsaXRJZHMgPSBbb3RoZXIuaWRdO1xcbiAgICAgIGxpbmtlZERvY3Mob3RoZXIsIGZ1bmN0aW9uIChkb2MpIHsgcmV0dXJuIHNwbGl0SWRzLnB1c2goZG9jLmlkKTsgfSwgdHJ1ZSk7XFxuICAgICAgb3RoZXIuaGlzdG9yeSA9IG5ldyBIaXN0b3J5KG51bGwpO1xcbiAgICAgIG90aGVyLmhpc3RvcnkuZG9uZSA9IGNvcHlIaXN0b3J5QXJyYXkodGhpcy5oaXN0b3J5LmRvbmUsIHNwbGl0SWRzKTtcXG4gICAgICBvdGhlci5oaXN0b3J5LnVuZG9uZSA9IGNvcHlIaXN0b3J5QXJyYXkodGhpcy5oaXN0b3J5LnVuZG9uZSwgc3BsaXRJZHMpO1xcbiAgICB9XFxuICB9LFxcbiAgaXRlckxpbmtlZERvY3M6IGZ1bmN0aW9uKGYpIHtsaW5rZWREb2NzKHRoaXMsIGYpO30sXFxuXFxuICBnZXRNb2RlOiBmdW5jdGlvbigpIHtyZXR1cm4gdGhpcy5tb2RlfSxcXG4gIGdldEVkaXRvcjogZnVuY3Rpb24oKSB7cmV0dXJuIHRoaXMuY219LFxcblxcbiAgc3BsaXRMaW5lczogZnVuY3Rpb24oc3RyKSB7XFxuICAgIGlmICh0aGlzLmxpbmVTZXApIHsgcmV0dXJuIHN0ci5zcGxpdCh0aGlzLmxpbmVTZXApIH1cXG4gICAgcmV0dXJuIHNwbGl0TGluZXNBdXRvKHN0cilcXG4gIH0sXFxuICBsaW5lU2VwYXJhdG9yOiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMubGluZVNlcCB8fCBcXFwiXFxcXG5cXFwiIH0sXFxuXFxuICBzZXREaXJlY3Rpb246IGRvY01ldGhvZE9wKGZ1bmN0aW9uIChkaXIpIHtcXG4gICAgaWYgKGRpciAhPSBcXFwicnRsXFxcIikgeyBkaXIgPSBcXFwibHRyXFxcIjsgfVxcbiAgICBpZiAoZGlyID09IHRoaXMuZGlyZWN0aW9uKSB7IHJldHVybiB9XFxuICAgIHRoaXMuZGlyZWN0aW9uID0gZGlyO1xcbiAgICB0aGlzLml0ZXIoZnVuY3Rpb24gKGxpbmUpIHsgcmV0dXJuIGxpbmUub3JkZXIgPSBudWxsOyB9KTtcXG4gICAgaWYgKHRoaXMuY20pIHsgZGlyZWN0aW9uQ2hhbmdlZCh0aGlzLmNtKTsgfVxcbiAgfSlcXG59KTtcXG5cXG4vLyBQdWJsaWMgYWxpYXMuXFxuRG9jLnByb3RvdHlwZS5lYWNoTGluZSA9IERvYy5wcm90b3R5cGUuaXRlcjtcXG5cXG4vLyBLbHVkZ2UgdG8gd29yayBhcm91bmQgc3RyYW5nZSBJRSBiZWhhdmlvciB3aGVyZSBpdCdsbCBzb21ldGltZXNcXG4vLyByZS1maXJlIGEgc2VyaWVzIG9mIGRyYWctcmVsYXRlZCBldmVudHMgcmlnaHQgYWZ0ZXIgdGhlIGRyb3AgKCMxNTUxKVxcbnZhciBsYXN0RHJvcCA9IDA7XFxuXFxuZnVuY3Rpb24gb25Ecm9wKGUpIHtcXG4gIHZhciBjbSA9IHRoaXM7XFxuICBjbGVhckRyYWdDdXJzb3IoY20pO1xcbiAgaWYgKHNpZ25hbERPTUV2ZW50KGNtLCBlKSB8fCBldmVudEluV2lkZ2V0KGNtLmRpc3BsYXksIGUpKVxcbiAgICB7IHJldHVybiB9XFxuICBlX3ByZXZlbnREZWZhdWx0KGUpO1xcbiAgaWYgKGllKSB7IGxhc3REcm9wID0gK25ldyBEYXRlOyB9XFxuICB2YXIgcG9zID0gcG9zRnJvbU1vdXNlKGNtLCBlLCB0cnVlKSwgZmlsZXMgPSBlLmRhdGFUcmFuc2Zlci5maWxlcztcXG4gIGlmICghcG9zIHx8IGNtLmlzUmVhZE9ubHkoKSkgeyByZXR1cm4gfVxcbiAgLy8gTWlnaHQgYmUgYSBmaWxlIGRyb3AsIGluIHdoaWNoIGNhc2Ugd2Ugc2ltcGx5IGV4dHJhY3QgdGhlIHRleHRcXG4gIC8vIGFuZCBpbnNlcnQgaXQuXFxuICBpZiAoZmlsZXMgJiYgZmlsZXMubGVuZ3RoICYmIHdpbmRvdy5GaWxlUmVhZGVyICYmIHdpbmRvdy5GaWxlKSB7XFxuICAgIHZhciBuID0gZmlsZXMubGVuZ3RoLCB0ZXh0ID0gQXJyYXkobiksIHJlYWQgPSAwO1xcbiAgICB2YXIgbG9hZEZpbGUgPSBmdW5jdGlvbiAoZmlsZSwgaSkge1xcbiAgICAgIGlmIChjbS5vcHRpb25zLmFsbG93RHJvcEZpbGVUeXBlcyAmJlxcbiAgICAgICAgICBpbmRleE9mKGNtLm9wdGlvbnMuYWxsb3dEcm9wRmlsZVR5cGVzLCBmaWxlLnR5cGUpID09IC0xKVxcbiAgICAgICAgeyByZXR1cm4gfVxcblxcbiAgICAgIHZhciByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcjtcXG4gICAgICByZWFkZXIub25sb2FkID0gb3BlcmF0aW9uKGNtLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgICB2YXIgY29udGVudCA9IHJlYWRlci5yZXN1bHQ7XFxuICAgICAgICBpZiAoL1tcXFxceDAwLVxcXFx4MDhcXFxceDBlLVxcXFx4MWZdezJ9Ly50ZXN0KGNvbnRlbnQpKSB7IGNvbnRlbnQgPSBcXFwiXFxcIjsgfVxcbiAgICAgICAgdGV4dFtpXSA9IGNvbnRlbnQ7XFxuICAgICAgICBpZiAoKytyZWFkID09IG4pIHtcXG4gICAgICAgICAgcG9zID0gY2xpcFBvcyhjbS5kb2MsIHBvcyk7XFxuICAgICAgICAgIHZhciBjaGFuZ2UgPSB7ZnJvbTogcG9zLCB0bzogcG9zLFxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IGNtLmRvYy5zcGxpdExpbmVzKHRleHQuam9pbihjbS5kb2MubGluZVNlcGFyYXRvcigpKSksXFxuICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luOiBcXFwicGFzdGVcXFwifTtcXG4gICAgICAgICAgbWFrZUNoYW5nZShjbS5kb2MsIGNoYW5nZSk7XFxuICAgICAgICAgIHNldFNlbGVjdGlvblJlcGxhY2VIaXN0b3J5KGNtLmRvYywgc2ltcGxlU2VsZWN0aW9uKHBvcywgY2hhbmdlRW5kKGNoYW5nZSkpKTtcXG4gICAgICAgIH1cXG4gICAgICB9KTtcXG4gICAgICByZWFkZXIucmVhZEFzVGV4dChmaWxlKTtcXG4gICAgfTtcXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyArK2kpIHsgbG9hZEZpbGUoZmlsZXNbaV0sIGkpOyB9XFxuICB9IGVsc2UgeyAvLyBOb3JtYWwgZHJvcFxcbiAgICAvLyBEb24ndCBkbyBhIHJlcGxhY2UgaWYgdGhlIGRyb3AgaGFwcGVuZWQgaW5zaWRlIG9mIHRoZSBzZWxlY3RlZCB0ZXh0LlxcbiAgICBpZiAoY20uc3RhdGUuZHJhZ2dpbmdUZXh0ICYmIGNtLmRvYy5zZWwuY29udGFpbnMocG9zKSA+IC0xKSB7XFxuICAgICAgY20uc3RhdGUuZHJhZ2dpbmdUZXh0KGUpO1xcbiAgICAgIC8vIEVuc3VyZSB0aGUgZWRpdG9yIGlzIHJlLWZvY3VzZWRcXG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNtLmRpc3BsYXkuaW5wdXQuZm9jdXMoKTsgfSwgMjApO1xcbiAgICAgIHJldHVyblxcbiAgICB9XFxuICAgIHRyeSB7XFxuICAgICAgdmFyIHRleHQkMSA9IGUuZGF0YVRyYW5zZmVyLmdldERhdGEoXFxcIlRleHRcXFwiKTtcXG4gICAgICBpZiAodGV4dCQxKSB7XFxuICAgICAgICB2YXIgc2VsZWN0ZWQ7XFxuICAgICAgICBpZiAoY20uc3RhdGUuZHJhZ2dpbmdUZXh0ICYmICFjbS5zdGF0ZS5kcmFnZ2luZ1RleHQuY29weSlcXG4gICAgICAgICAgeyBzZWxlY3RlZCA9IGNtLmxpc3RTZWxlY3Rpb25zKCk7IH1cXG4gICAgICAgIHNldFNlbGVjdGlvbk5vVW5kbyhjbS5kb2MsIHNpbXBsZVNlbGVjdGlvbihwb3MsIHBvcykpO1xcbiAgICAgICAgaWYgKHNlbGVjdGVkKSB7IGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IHNlbGVjdGVkLmxlbmd0aDsgKytpJDEpXFxuICAgICAgICAgIHsgcmVwbGFjZVJhbmdlKGNtLmRvYywgXFxcIlxcXCIsIHNlbGVjdGVkW2kkMV0uYW5jaG9yLCBzZWxlY3RlZFtpJDFdLmhlYWQsIFxcXCJkcmFnXFxcIik7IH0gfVxcbiAgICAgICAgY20ucmVwbGFjZVNlbGVjdGlvbih0ZXh0JDEsIFxcXCJhcm91bmRcXFwiLCBcXFwicGFzdGVcXFwiKTtcXG4gICAgICAgIGNtLmRpc3BsYXkuaW5wdXQuZm9jdXMoKTtcXG4gICAgICB9XFxuICAgIH1cXG4gICAgY2F0Y2goZSl7fVxcbiAgfVxcbn1cXG5cXG5mdW5jdGlvbiBvbkRyYWdTdGFydChjbSwgZSkge1xcbiAgaWYgKGllICYmICghY20uc3RhdGUuZHJhZ2dpbmdUZXh0IHx8ICtuZXcgRGF0ZSAtIGxhc3REcm9wIDwgMTAwKSkgeyBlX3N0b3AoZSk7IHJldHVybiB9XFxuICBpZiAoc2lnbmFsRE9NRXZlbnQoY20sIGUpIHx8IGV2ZW50SW5XaWRnZXQoY20uZGlzcGxheSwgZSkpIHsgcmV0dXJuIH1cXG5cXG4gIGUuZGF0YVRyYW5zZmVyLnNldERhdGEoXFxcIlRleHRcXFwiLCBjbS5nZXRTZWxlY3Rpb24oKSk7XFxuICBlLmRhdGFUcmFuc2Zlci5lZmZlY3RBbGxvd2VkID0gXFxcImNvcHlNb3ZlXFxcIjtcXG5cXG4gIC8vIFVzZSBkdW1teSBpbWFnZSBpbnN0ZWFkIG9mIGRlZmF1bHQgYnJvd3NlcnMgaW1hZ2UuXFxuICAvLyBSZWNlbnQgU2FmYXJpICh+Ni4wLjIpIGhhdmUgYSB0ZW5kZW5jeSB0byBzZWdmYXVsdCB3aGVuIHRoaXMgaGFwcGVucywgc28gd2UgZG9uJ3QgZG8gaXQgdGhlcmUuXFxuICBpZiAoZS5kYXRhVHJhbnNmZXIuc2V0RHJhZ0ltYWdlICYmICFzYWZhcmkpIHtcXG4gICAgdmFyIGltZyA9IGVsdChcXFwiaW1nXFxcIiwgbnVsbCwgbnVsbCwgXFxcInBvc2l0aW9uOiBmaXhlZDsgbGVmdDogMDsgdG9wOiAwO1xcXCIpO1xcbiAgICBpbWcuc3JjID0gXFxcImRhdGE6aW1hZ2UvZ2lmO2Jhc2U2NCxSMGxHT0RsaEFRQUJBQUFBQUNINUJBRUtBQUVBTEFBQUFBQUJBQUVBQUFJQ1RBRUFPdz09XFxcIjtcXG4gICAgaWYgKHByZXN0bykge1xcbiAgICAgIGltZy53aWR0aCA9IGltZy5oZWlnaHQgPSAxO1xcbiAgICAgIGNtLmRpc3BsYXkud3JhcHBlci5hcHBlbmRDaGlsZChpbWcpO1xcbiAgICAgIC8vIEZvcmNlIGEgcmVsYXlvdXQsIG9yIE9wZXJhIHdvbid0IHVzZSBvdXIgaW1hZ2UgZm9yIHNvbWUgb2JzY3VyZSByZWFzb25cXG4gICAgICBpbWcuX3RvcCA9IGltZy5vZmZzZXRUb3A7XFxuICAgIH1cXG4gICAgZS5kYXRhVHJhbnNmZXIuc2V0RHJhZ0ltYWdlKGltZywgMCwgMCk7XFxuICAgIGlmIChwcmVzdG8pIHsgaW1nLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoaW1nKTsgfVxcbiAgfVxcbn1cXG5cXG5mdW5jdGlvbiBvbkRyYWdPdmVyKGNtLCBlKSB7XFxuICB2YXIgcG9zID0gcG9zRnJvbU1vdXNlKGNtLCBlKTtcXG4gIGlmICghcG9zKSB7IHJldHVybiB9XFxuICB2YXIgZnJhZyA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcXG4gIGRyYXdTZWxlY3Rpb25DdXJzb3IoY20sIHBvcywgZnJhZyk7XFxuICBpZiAoIWNtLmRpc3BsYXkuZHJhZ0N1cnNvcikge1xcbiAgICBjbS5kaXNwbGF5LmRyYWdDdXJzb3IgPSBlbHQoXFxcImRpdlxcXCIsIG51bGwsIFxcXCJDb2RlTWlycm9yLWN1cnNvcnMgQ29kZU1pcnJvci1kcmFnY3Vyc29yc1xcXCIpO1xcbiAgICBjbS5kaXNwbGF5LmxpbmVTcGFjZS5pbnNlcnRCZWZvcmUoY20uZGlzcGxheS5kcmFnQ3Vyc29yLCBjbS5kaXNwbGF5LmN1cnNvckRpdik7XFxuICB9XFxuICByZW1vdmVDaGlsZHJlbkFuZEFkZChjbS5kaXNwbGF5LmRyYWdDdXJzb3IsIGZyYWcpO1xcbn1cXG5cXG5mdW5jdGlvbiBjbGVhckRyYWdDdXJzb3IoY20pIHtcXG4gIGlmIChjbS5kaXNwbGF5LmRyYWdDdXJzb3IpIHtcXG4gICAgY20uZGlzcGxheS5saW5lU3BhY2UucmVtb3ZlQ2hpbGQoY20uZGlzcGxheS5kcmFnQ3Vyc29yKTtcXG4gICAgY20uZGlzcGxheS5kcmFnQ3Vyc29yID0gbnVsbDtcXG4gIH1cXG59XFxuXFxuLy8gVGhlc2UgbXVzdCBiZSBoYW5kbGVkIGNhcmVmdWxseSwgYmVjYXVzZSBuYWl2ZWx5IHJlZ2lzdGVyaW5nIGFcXG4vLyBoYW5kbGVyIGZvciBlYWNoIGVkaXRvciB3aWxsIGNhdXNlIHRoZSBlZGl0b3JzIHRvIG5ldmVyIGJlXFxuLy8gZ2FyYmFnZSBjb2xsZWN0ZWQuXFxuXFxuZnVuY3Rpb24gZm9yRWFjaENvZGVNaXJyb3IoZikge1xcbiAgaWYgKCFkb2N1bWVudC5ib2R5LmdldEVsZW1lbnRzQnlDbGFzc05hbWUpIHsgcmV0dXJuIH1cXG4gIHZhciBieUNsYXNzID0gZG9jdW1lbnQuYm9keS5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKFxcXCJDb2RlTWlycm9yXFxcIik7XFxuICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5Q2xhc3MubGVuZ3RoOyBpKyspIHtcXG4gICAgdmFyIGNtID0gYnlDbGFzc1tpXS5Db2RlTWlycm9yO1xcbiAgICBpZiAoY20pIHsgZihjbSk7IH1cXG4gIH1cXG59XFxuXFxudmFyIGdsb2JhbHNSZWdpc3RlcmVkID0gZmFsc2U7XFxuZnVuY3Rpb24gZW5zdXJlR2xvYmFsSGFuZGxlcnMoKSB7XFxuICBpZiAoZ2xvYmFsc1JlZ2lzdGVyZWQpIHsgcmV0dXJuIH1cXG4gIHJlZ2lzdGVyR2xvYmFsSGFuZGxlcnMoKTtcXG4gIGdsb2JhbHNSZWdpc3RlcmVkID0gdHJ1ZTtcXG59XFxuZnVuY3Rpb24gcmVnaXN0ZXJHbG9iYWxIYW5kbGVycygpIHtcXG4gIC8vIFdoZW4gdGhlIHdpbmRvdyByZXNpemVzLCB3ZSBuZWVkIHRvIHJlZnJlc2ggYWN0aXZlIGVkaXRvcnMuXFxuICB2YXIgcmVzaXplVGltZXI7XFxuICBvbih3aW5kb3csIFxcXCJyZXNpemVcXFwiLCBmdW5jdGlvbiAoKSB7XFxuICAgIGlmIChyZXNpemVUaW1lciA9PSBudWxsKSB7IHJlc2l6ZVRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XFxuICAgICAgcmVzaXplVGltZXIgPSBudWxsO1xcbiAgICAgIGZvckVhY2hDb2RlTWlycm9yKG9uUmVzaXplKTtcXG4gICAgfSwgMTAwKTsgfVxcbiAgfSk7XFxuICAvLyBXaGVuIHRoZSB3aW5kb3cgbG9zZXMgZm9jdXMsIHdlIHdhbnQgdG8gc2hvdyB0aGUgZWRpdG9yIGFzIGJsdXJyZWRcXG4gIG9uKHdpbmRvdywgXFxcImJsdXJcXFwiLCBmdW5jdGlvbiAoKSB7IHJldHVybiBmb3JFYWNoQ29kZU1pcnJvcihvbkJsdXIpOyB9KTtcXG59XFxuLy8gQ2FsbGVkIHdoZW4gdGhlIHdpbmRvdyByZXNpemVzXFxuZnVuY3Rpb24gb25SZXNpemUoY20pIHtcXG4gIHZhciBkID0gY20uZGlzcGxheTtcXG4gIGlmIChkLmxhc3RXcmFwSGVpZ2h0ID09IGQud3JhcHBlci5jbGllbnRIZWlnaHQgJiYgZC5sYXN0V3JhcFdpZHRoID09IGQud3JhcHBlci5jbGllbnRXaWR0aClcXG4gICAgeyByZXR1cm4gfVxcbiAgLy8gTWlnaHQgYmUgYSB0ZXh0IHNjYWxpbmcgb3BlcmF0aW9uLCBjbGVhciBzaXplIGNhY2hlcy5cXG4gIGQuY2FjaGVkQ2hhcldpZHRoID0gZC5jYWNoZWRUZXh0SGVpZ2h0ID0gZC5jYWNoZWRQYWRkaW5nSCA9IG51bGw7XFxuICBkLnNjcm9sbGJhcnNDbGlwcGVkID0gZmFsc2U7XFxuICBjbS5zZXRTaXplKCk7XFxufVxcblxcbnZhciBrZXlOYW1lcyA9IHtcXG4gIDM6IFxcXCJFbnRlclxcXCIsIDg6IFxcXCJCYWNrc3BhY2VcXFwiLCA5OiBcXFwiVGFiXFxcIiwgMTM6IFxcXCJFbnRlclxcXCIsIDE2OiBcXFwiU2hpZnRcXFwiLCAxNzogXFxcIkN0cmxcXFwiLCAxODogXFxcIkFsdFxcXCIsXFxuICAxOTogXFxcIlBhdXNlXFxcIiwgMjA6IFxcXCJDYXBzTG9ja1xcXCIsIDI3OiBcXFwiRXNjXFxcIiwgMzI6IFxcXCJTcGFjZVxcXCIsIDMzOiBcXFwiUGFnZVVwXFxcIiwgMzQ6IFxcXCJQYWdlRG93blxcXCIsIDM1OiBcXFwiRW5kXFxcIixcXG4gIDM2OiBcXFwiSG9tZVxcXCIsIDM3OiBcXFwiTGVmdFxcXCIsIDM4OiBcXFwiVXBcXFwiLCAzOTogXFxcIlJpZ2h0XFxcIiwgNDA6IFxcXCJEb3duXFxcIiwgNDQ6IFxcXCJQcmludFNjcm5cXFwiLCA0NTogXFxcIkluc2VydFxcXCIsXFxuICA0NjogXFxcIkRlbGV0ZVxcXCIsIDU5OiBcXFwiO1xcXCIsIDYxOiBcXFwiPVxcXCIsIDkxOiBcXFwiTW9kXFxcIiwgOTI6IFxcXCJNb2RcXFwiLCA5MzogXFxcIk1vZFxcXCIsXFxuICAxMDY6IFxcXCIqXFxcIiwgMTA3OiBcXFwiPVxcXCIsIDEwOTogXFxcIi1cXFwiLCAxMTA6IFxcXCIuXFxcIiwgMTExOiBcXFwiL1xcXCIsIDEyNzogXFxcIkRlbGV0ZVxcXCIsXFxuICAxNzM6IFxcXCItXFxcIiwgMTg2OiBcXFwiO1xcXCIsIDE4NzogXFxcIj1cXFwiLCAxODg6IFxcXCIsXFxcIiwgMTg5OiBcXFwiLVxcXCIsIDE5MDogXFxcIi5cXFwiLCAxOTE6IFxcXCIvXFxcIiwgMTkyOiBcXFwiYFxcXCIsIDIxOTogXFxcIltcXFwiLCAyMjA6IFxcXCJcXFxcXFxcXFxcXCIsXFxuICAyMjE6IFxcXCJdXFxcIiwgMjIyOiBcXFwiJ1xcXCIsIDYzMjMyOiBcXFwiVXBcXFwiLCA2MzIzMzogXFxcIkRvd25cXFwiLCA2MzIzNDogXFxcIkxlZnRcXFwiLCA2MzIzNTogXFxcIlJpZ2h0XFxcIiwgNjMyNzI6IFxcXCJEZWxldGVcXFwiLFxcbiAgNjMyNzM6IFxcXCJIb21lXFxcIiwgNjMyNzU6IFxcXCJFbmRcXFwiLCA2MzI3NjogXFxcIlBhZ2VVcFxcXCIsIDYzMjc3OiBcXFwiUGFnZURvd25cXFwiLCA2MzMwMjogXFxcIkluc2VydFxcXCJcXG59O1xcblxcbi8vIE51bWJlciBrZXlzXFxuZm9yICh2YXIgaSA9IDA7IGkgPCAxMDsgaSsrKSB7IGtleU5hbWVzW2kgKyA0OF0gPSBrZXlOYW1lc1tpICsgOTZdID0gU3RyaW5nKGkpOyB9XFxuLy8gQWxwaGFiZXRpYyBrZXlzXFxuZm9yICh2YXIgaSQxID0gNjU7IGkkMSA8PSA5MDsgaSQxKyspIHsga2V5TmFtZXNbaSQxXSA9IFN0cmluZy5mcm9tQ2hhckNvZGUoaSQxKTsgfVxcbi8vIEZ1bmN0aW9uIGtleXNcXG5mb3IgKHZhciBpJDIgPSAxOyBpJDIgPD0gMTI7IGkkMisrKSB7IGtleU5hbWVzW2kkMiArIDExMV0gPSBrZXlOYW1lc1tpJDIgKyA2MzIzNV0gPSBcXFwiRlxcXCIgKyBpJDI7IH1cXG5cXG52YXIga2V5TWFwID0ge307XFxuXFxua2V5TWFwLmJhc2ljID0ge1xcbiAgXFxcIkxlZnRcXFwiOiBcXFwiZ29DaGFyTGVmdFxcXCIsIFxcXCJSaWdodFxcXCI6IFxcXCJnb0NoYXJSaWdodFxcXCIsIFxcXCJVcFxcXCI6IFxcXCJnb0xpbmVVcFxcXCIsIFxcXCJEb3duXFxcIjogXFxcImdvTGluZURvd25cXFwiLFxcbiAgXFxcIkVuZFxcXCI6IFxcXCJnb0xpbmVFbmRcXFwiLCBcXFwiSG9tZVxcXCI6IFxcXCJnb0xpbmVTdGFydFNtYXJ0XFxcIiwgXFxcIlBhZ2VVcFxcXCI6IFxcXCJnb1BhZ2VVcFxcXCIsIFxcXCJQYWdlRG93blxcXCI6IFxcXCJnb1BhZ2VEb3duXFxcIixcXG4gIFxcXCJEZWxldGVcXFwiOiBcXFwiZGVsQ2hhckFmdGVyXFxcIiwgXFxcIkJhY2tzcGFjZVxcXCI6IFxcXCJkZWxDaGFyQmVmb3JlXFxcIiwgXFxcIlNoaWZ0LUJhY2tzcGFjZVxcXCI6IFxcXCJkZWxDaGFyQmVmb3JlXFxcIixcXG4gIFxcXCJUYWJcXFwiOiBcXFwiZGVmYXVsdFRhYlxcXCIsIFxcXCJTaGlmdC1UYWJcXFwiOiBcXFwiaW5kZW50QXV0b1xcXCIsXFxuICBcXFwiRW50ZXJcXFwiOiBcXFwibmV3bGluZUFuZEluZGVudFxcXCIsIFxcXCJJbnNlcnRcXFwiOiBcXFwidG9nZ2xlT3ZlcndyaXRlXFxcIixcXG4gIFxcXCJFc2NcXFwiOiBcXFwic2luZ2xlU2VsZWN0aW9uXFxcIlxcbn07XFxuLy8gTm90ZSB0aGF0IHRoZSBzYXZlIGFuZCBmaW5kLXJlbGF0ZWQgY29tbWFuZHMgYXJlbid0IGRlZmluZWQgYnlcXG4vLyBkZWZhdWx0LiBVc2VyIGNvZGUgb3IgYWRkb25zIGNhbiBkZWZpbmUgdGhlbS4gVW5rbm93biBjb21tYW5kc1xcbi8vIGFyZSBzaW1wbHkgaWdub3JlZC5cXG5rZXlNYXAucGNEZWZhdWx0ID0ge1xcbiAgXFxcIkN0cmwtQVxcXCI6IFxcXCJzZWxlY3RBbGxcXFwiLCBcXFwiQ3RybC1EXFxcIjogXFxcImRlbGV0ZUxpbmVcXFwiLCBcXFwiQ3RybC1aXFxcIjogXFxcInVuZG9cXFwiLCBcXFwiU2hpZnQtQ3RybC1aXFxcIjogXFxcInJlZG9cXFwiLCBcXFwiQ3RybC1ZXFxcIjogXFxcInJlZG9cXFwiLFxcbiAgXFxcIkN0cmwtSG9tZVxcXCI6IFxcXCJnb0RvY1N0YXJ0XFxcIiwgXFxcIkN0cmwtRW5kXFxcIjogXFxcImdvRG9jRW5kXFxcIiwgXFxcIkN0cmwtVXBcXFwiOiBcXFwiZ29MaW5lVXBcXFwiLCBcXFwiQ3RybC1Eb3duXFxcIjogXFxcImdvTGluZURvd25cXFwiLFxcbiAgXFxcIkN0cmwtTGVmdFxcXCI6IFxcXCJnb0dyb3VwTGVmdFxcXCIsIFxcXCJDdHJsLVJpZ2h0XFxcIjogXFxcImdvR3JvdXBSaWdodFxcXCIsIFxcXCJBbHQtTGVmdFxcXCI6IFxcXCJnb0xpbmVTdGFydFxcXCIsIFxcXCJBbHQtUmlnaHRcXFwiOiBcXFwiZ29MaW5lRW5kXFxcIixcXG4gIFxcXCJDdHJsLUJhY2tzcGFjZVxcXCI6IFxcXCJkZWxHcm91cEJlZm9yZVxcXCIsIFxcXCJDdHJsLURlbGV0ZVxcXCI6IFxcXCJkZWxHcm91cEFmdGVyXFxcIiwgXFxcIkN0cmwtU1xcXCI6IFxcXCJzYXZlXFxcIiwgXFxcIkN0cmwtRlxcXCI6IFxcXCJmaW5kXFxcIixcXG4gIFxcXCJDdHJsLUdcXFwiOiBcXFwiZmluZE5leHRcXFwiLCBcXFwiU2hpZnQtQ3RybC1HXFxcIjogXFxcImZpbmRQcmV2XFxcIiwgXFxcIlNoaWZ0LUN0cmwtRlxcXCI6IFxcXCJyZXBsYWNlXFxcIiwgXFxcIlNoaWZ0LUN0cmwtUlxcXCI6IFxcXCJyZXBsYWNlQWxsXFxcIixcXG4gIFxcXCJDdHJsLVtcXFwiOiBcXFwiaW5kZW50TGVzc1xcXCIsIFxcXCJDdHJsLV1cXFwiOiBcXFwiaW5kZW50TW9yZVxcXCIsXFxuICBcXFwiQ3RybC1VXFxcIjogXFxcInVuZG9TZWxlY3Rpb25cXFwiLCBcXFwiU2hpZnQtQ3RybC1VXFxcIjogXFxcInJlZG9TZWxlY3Rpb25cXFwiLCBcXFwiQWx0LVVcXFwiOiBcXFwicmVkb1NlbGVjdGlvblxcXCIsXFxuICBmYWxsdGhyb3VnaDogXFxcImJhc2ljXFxcIlxcbn07XFxuLy8gVmVyeSBiYXNpYyByZWFkbGluZS9lbWFjcy1zdHlsZSBiaW5kaW5ncywgd2hpY2ggYXJlIHN0YW5kYXJkIG9uIE1hYy5cXG5rZXlNYXAuZW1hY3N5ID0ge1xcbiAgXFxcIkN0cmwtRlxcXCI6IFxcXCJnb0NoYXJSaWdodFxcXCIsIFxcXCJDdHJsLUJcXFwiOiBcXFwiZ29DaGFyTGVmdFxcXCIsIFxcXCJDdHJsLVBcXFwiOiBcXFwiZ29MaW5lVXBcXFwiLCBcXFwiQ3RybC1OXFxcIjogXFxcImdvTGluZURvd25cXFwiLFxcbiAgXFxcIkFsdC1GXFxcIjogXFxcImdvV29yZFJpZ2h0XFxcIiwgXFxcIkFsdC1CXFxcIjogXFxcImdvV29yZExlZnRcXFwiLCBcXFwiQ3RybC1BXFxcIjogXFxcImdvTGluZVN0YXJ0XFxcIiwgXFxcIkN0cmwtRVxcXCI6IFxcXCJnb0xpbmVFbmRcXFwiLFxcbiAgXFxcIkN0cmwtVlxcXCI6IFxcXCJnb1BhZ2VEb3duXFxcIiwgXFxcIlNoaWZ0LUN0cmwtVlxcXCI6IFxcXCJnb1BhZ2VVcFxcXCIsIFxcXCJDdHJsLURcXFwiOiBcXFwiZGVsQ2hhckFmdGVyXFxcIiwgXFxcIkN0cmwtSFxcXCI6IFxcXCJkZWxDaGFyQmVmb3JlXFxcIixcXG4gIFxcXCJBbHQtRFxcXCI6IFxcXCJkZWxXb3JkQWZ0ZXJcXFwiLCBcXFwiQWx0LUJhY2tzcGFjZVxcXCI6IFxcXCJkZWxXb3JkQmVmb3JlXFxcIiwgXFxcIkN0cmwtS1xcXCI6IFxcXCJraWxsTGluZVxcXCIsIFxcXCJDdHJsLVRcXFwiOiBcXFwidHJhbnNwb3NlQ2hhcnNcXFwiLFxcbiAgXFxcIkN0cmwtT1xcXCI6IFxcXCJvcGVuTGluZVxcXCJcXG59O1xcbmtleU1hcC5tYWNEZWZhdWx0ID0ge1xcbiAgXFxcIkNtZC1BXFxcIjogXFxcInNlbGVjdEFsbFxcXCIsIFxcXCJDbWQtRFxcXCI6IFxcXCJkZWxldGVMaW5lXFxcIiwgXFxcIkNtZC1aXFxcIjogXFxcInVuZG9cXFwiLCBcXFwiU2hpZnQtQ21kLVpcXFwiOiBcXFwicmVkb1xcXCIsIFxcXCJDbWQtWVxcXCI6IFxcXCJyZWRvXFxcIixcXG4gIFxcXCJDbWQtSG9tZVxcXCI6IFxcXCJnb0RvY1N0YXJ0XFxcIiwgXFxcIkNtZC1VcFxcXCI6IFxcXCJnb0RvY1N0YXJ0XFxcIiwgXFxcIkNtZC1FbmRcXFwiOiBcXFwiZ29Eb2NFbmRcXFwiLCBcXFwiQ21kLURvd25cXFwiOiBcXFwiZ29Eb2NFbmRcXFwiLCBcXFwiQWx0LUxlZnRcXFwiOiBcXFwiZ29Hcm91cExlZnRcXFwiLFxcbiAgXFxcIkFsdC1SaWdodFxcXCI6IFxcXCJnb0dyb3VwUmlnaHRcXFwiLCBcXFwiQ21kLUxlZnRcXFwiOiBcXFwiZ29MaW5lTGVmdFxcXCIsIFxcXCJDbWQtUmlnaHRcXFwiOiBcXFwiZ29MaW5lUmlnaHRcXFwiLCBcXFwiQWx0LUJhY2tzcGFjZVxcXCI6IFxcXCJkZWxHcm91cEJlZm9yZVxcXCIsXFxuICBcXFwiQ3RybC1BbHQtQmFja3NwYWNlXFxcIjogXFxcImRlbEdyb3VwQWZ0ZXJcXFwiLCBcXFwiQWx0LURlbGV0ZVxcXCI6IFxcXCJkZWxHcm91cEFmdGVyXFxcIiwgXFxcIkNtZC1TXFxcIjogXFxcInNhdmVcXFwiLCBcXFwiQ21kLUZcXFwiOiBcXFwiZmluZFxcXCIsXFxuICBcXFwiQ21kLUdcXFwiOiBcXFwiZmluZE5leHRcXFwiLCBcXFwiU2hpZnQtQ21kLUdcXFwiOiBcXFwiZmluZFByZXZcXFwiLCBcXFwiQ21kLUFsdC1GXFxcIjogXFxcInJlcGxhY2VcXFwiLCBcXFwiU2hpZnQtQ21kLUFsdC1GXFxcIjogXFxcInJlcGxhY2VBbGxcXFwiLFxcbiAgXFxcIkNtZC1bXFxcIjogXFxcImluZGVudExlc3NcXFwiLCBcXFwiQ21kLV1cXFwiOiBcXFwiaW5kZW50TW9yZVxcXCIsIFxcXCJDbWQtQmFja3NwYWNlXFxcIjogXFxcImRlbFdyYXBwZWRMaW5lTGVmdFxcXCIsIFxcXCJDbWQtRGVsZXRlXFxcIjogXFxcImRlbFdyYXBwZWRMaW5lUmlnaHRcXFwiLFxcbiAgXFxcIkNtZC1VXFxcIjogXFxcInVuZG9TZWxlY3Rpb25cXFwiLCBcXFwiU2hpZnQtQ21kLVVcXFwiOiBcXFwicmVkb1NlbGVjdGlvblxcXCIsIFxcXCJDdHJsLVVwXFxcIjogXFxcImdvRG9jU3RhcnRcXFwiLCBcXFwiQ3RybC1Eb3duXFxcIjogXFxcImdvRG9jRW5kXFxcIixcXG4gIGZhbGx0aHJvdWdoOiBbXFxcImJhc2ljXFxcIiwgXFxcImVtYWNzeVxcXCJdXFxufTtcXG5rZXlNYXBbXFxcImRlZmF1bHRcXFwiXSA9IG1hYyA/IGtleU1hcC5tYWNEZWZhdWx0IDoga2V5TWFwLnBjRGVmYXVsdDtcXG5cXG4vLyBLRVlNQVAgRElTUEFUQ0hcXG5cXG5mdW5jdGlvbiBub3JtYWxpemVLZXlOYW1lKG5hbWUpIHtcXG4gIHZhciBwYXJ0cyA9IG5hbWUuc3BsaXQoLy0oPyEkKS8pO1xcbiAgbmFtZSA9IHBhcnRzW3BhcnRzLmxlbmd0aCAtIDFdO1xcbiAgdmFyIGFsdCwgY3RybCwgc2hpZnQsIGNtZDtcXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoIC0gMTsgaSsrKSB7XFxuICAgIHZhciBtb2QgPSBwYXJ0c1tpXTtcXG4gICAgaWYgKC9eKGNtZHxtZXRhfG0pJC9pLnRlc3QobW9kKSkgeyBjbWQgPSB0cnVlOyB9XFxuICAgIGVsc2UgaWYgKC9eYShsdCk/JC9pLnRlc3QobW9kKSkgeyBhbHQgPSB0cnVlOyB9XFxuICAgIGVsc2UgaWYgKC9eKGN8Y3RybHxjb250cm9sKSQvaS50ZXN0KG1vZCkpIHsgY3RybCA9IHRydWU7IH1cXG4gICAgZWxzZSBpZiAoL15zKGhpZnQpPyQvaS50ZXN0KG1vZCkpIHsgc2hpZnQgPSB0cnVlOyB9XFxuICAgIGVsc2UgeyB0aHJvdyBuZXcgRXJyb3IoXFxcIlVucmVjb2duaXplZCBtb2RpZmllciBuYW1lOiBcXFwiICsgbW9kKSB9XFxuICB9XFxuICBpZiAoYWx0KSB7IG5hbWUgPSBcXFwiQWx0LVxcXCIgKyBuYW1lOyB9XFxuICBpZiAoY3RybCkgeyBuYW1lID0gXFxcIkN0cmwtXFxcIiArIG5hbWU7IH1cXG4gIGlmIChjbWQpIHsgbmFtZSA9IFxcXCJDbWQtXFxcIiArIG5hbWU7IH1cXG4gIGlmIChzaGlmdCkgeyBuYW1lID0gXFxcIlNoaWZ0LVxcXCIgKyBuYW1lOyB9XFxuICByZXR1cm4gbmFtZVxcbn1cXG5cXG4vLyBUaGlzIGlzIGEga2x1ZGdlIHRvIGtlZXAga2V5bWFwcyBtb3N0bHkgd29ya2luZyBhcyByYXcgb2JqZWN0c1xcbi8vIChiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSkgd2hpbGUgYXQgdGhlIHNhbWUgdGltZSBzdXBwb3J0IGZlYXR1cmVzXFxuLy8gbGlrZSBub3JtYWxpemF0aW9uIGFuZCBtdWx0aS1zdHJva2Uga2V5IGJpbmRpbmdzLiBJdCBjb21waWxlcyBhXFxuLy8gbmV3IG5vcm1hbGl6ZWQga2V5bWFwLCBhbmQgdGhlbiB1cGRhdGVzIHRoZSBvbGQgb2JqZWN0IHRvIHJlZmxlY3RcXG4vLyB0aGlzLlxcbmZ1bmN0aW9uIG5vcm1hbGl6ZUtleU1hcChrZXltYXApIHtcXG4gIHZhciBjb3B5ID0ge307XFxuICBmb3IgKHZhciBrZXluYW1lIGluIGtleW1hcCkgeyBpZiAoa2V5bWFwLmhhc093blByb3BlcnR5KGtleW5hbWUpKSB7XFxuICAgIHZhciB2YWx1ZSA9IGtleW1hcFtrZXluYW1lXTtcXG4gICAgaWYgKC9eKG5hbWV8ZmFsbHRocm91Z2h8KGRlfGF0KXRhY2gpJC8udGVzdChrZXluYW1lKSkgeyBjb250aW51ZSB9XFxuICAgIGlmICh2YWx1ZSA9PSBcXFwiLi4uXFxcIikgeyBkZWxldGUga2V5bWFwW2tleW5hbWVdOyBjb250aW51ZSB9XFxuXFxuICAgIHZhciBrZXlzID0gbWFwKGtleW5hbWUuc3BsaXQoXFxcIiBcXFwiKSwgbm9ybWFsaXplS2V5TmFtZSk7XFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xcbiAgICAgIHZhciB2YWwgPSAodm9pZCAwKSwgbmFtZSA9ICh2b2lkIDApO1xcbiAgICAgIGlmIChpID09IGtleXMubGVuZ3RoIC0gMSkge1xcbiAgICAgICAgbmFtZSA9IGtleXMuam9pbihcXFwiIFxcXCIpO1xcbiAgICAgICAgdmFsID0gdmFsdWU7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIG5hbWUgPSBrZXlzLnNsaWNlKDAsIGkgKyAxKS5qb2luKFxcXCIgXFxcIik7XFxuICAgICAgICB2YWwgPSBcXFwiLi4uXFxcIjtcXG4gICAgICB9XFxuICAgICAgdmFyIHByZXYgPSBjb3B5W25hbWVdO1xcbiAgICAgIGlmICghcHJldikgeyBjb3B5W25hbWVdID0gdmFsOyB9XFxuICAgICAgZWxzZSBpZiAocHJldiAhPSB2YWwpIHsgdGhyb3cgbmV3IEVycm9yKFxcXCJJbmNvbnNpc3RlbnQgYmluZGluZ3MgZm9yIFxcXCIgKyBuYW1lKSB9XFxuICAgIH1cXG4gICAgZGVsZXRlIGtleW1hcFtrZXluYW1lXTtcXG4gIH0gfVxcbiAgZm9yICh2YXIgcHJvcCBpbiBjb3B5KSB7IGtleW1hcFtwcm9wXSA9IGNvcHlbcHJvcF07IH1cXG4gIHJldHVybiBrZXltYXBcXG59XFxuXFxuZnVuY3Rpb24gbG9va3VwS2V5KGtleSwgbWFwJCQxLCBoYW5kbGUsIGNvbnRleHQpIHtcXG4gIG1hcCQkMSA9IGdldEtleU1hcChtYXAkJDEpO1xcbiAgdmFyIGZvdW5kID0gbWFwJCQxLmNhbGwgPyBtYXAkJDEuY2FsbChrZXksIGNvbnRleHQpIDogbWFwJCQxW2tleV07XFxuICBpZiAoZm91bmQgPT09IGZhbHNlKSB7IHJldHVybiBcXFwibm90aGluZ1xcXCIgfVxcbiAgaWYgKGZvdW5kID09PSBcXFwiLi4uXFxcIikgeyByZXR1cm4gXFxcIm11bHRpXFxcIiB9XFxuICBpZiAoZm91bmQgIT0gbnVsbCAmJiBoYW5kbGUoZm91bmQpKSB7IHJldHVybiBcXFwiaGFuZGxlZFxcXCIgfVxcblxcbiAgaWYgKG1hcCQkMS5mYWxsdGhyb3VnaCkge1xcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG1hcCQkMS5mYWxsdGhyb3VnaCkgIT0gXFxcIltvYmplY3QgQXJyYXldXFxcIilcXG4gICAgICB7IHJldHVybiBsb29rdXBLZXkoa2V5LCBtYXAkJDEuZmFsbHRocm91Z2gsIGhhbmRsZSwgY29udGV4dCkgfVxcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1hcCQkMS5mYWxsdGhyb3VnaC5sZW5ndGg7IGkrKykge1xcbiAgICAgIHZhciByZXN1bHQgPSBsb29rdXBLZXkoa2V5LCBtYXAkJDEuZmFsbHRocm91Z2hbaV0sIGhhbmRsZSwgY29udGV4dCk7XFxuICAgICAgaWYgKHJlc3VsdCkgeyByZXR1cm4gcmVzdWx0IH1cXG4gICAgfVxcbiAgfVxcbn1cXG5cXG4vLyBNb2RpZmllciBrZXkgcHJlc3NlcyBkb24ndCBjb3VudCBhcyAncmVhbCcga2V5IHByZXNzZXMgZm9yIHRoZVxcbi8vIHB1cnBvc2Ugb2Yga2V5bWFwIGZhbGx0aHJvdWdoLlxcbmZ1bmN0aW9uIGlzTW9kaWZpZXJLZXkodmFsdWUpIHtcXG4gIHZhciBuYW1lID0gdHlwZW9mIHZhbHVlID09IFxcXCJzdHJpbmdcXFwiID8gdmFsdWUgOiBrZXlOYW1lc1t2YWx1ZS5rZXlDb2RlXTtcXG4gIHJldHVybiBuYW1lID09IFxcXCJDdHJsXFxcIiB8fCBuYW1lID09IFxcXCJBbHRcXFwiIHx8IG5hbWUgPT0gXFxcIlNoaWZ0XFxcIiB8fCBuYW1lID09IFxcXCJNb2RcXFwiXFxufVxcblxcbi8vIExvb2sgdXAgdGhlIG5hbWUgb2YgYSBrZXkgYXMgaW5kaWNhdGVkIGJ5IGFuIGV2ZW50IG9iamVjdC5cXG5mdW5jdGlvbiBrZXlOYW1lKGV2ZW50LCBub1NoaWZ0KSB7XFxuICBpZiAocHJlc3RvICYmIGV2ZW50LmtleUNvZGUgPT0gMzQgJiYgZXZlbnRbXFxcImNoYXJcXFwiXSkgeyByZXR1cm4gZmFsc2UgfVxcbiAgdmFyIGJhc2UgPSBrZXlOYW1lc1tldmVudC5rZXlDb2RlXSwgbmFtZSA9IGJhc2U7XFxuICBpZiAobmFtZSA9PSBudWxsIHx8IGV2ZW50LmFsdEdyYXBoS2V5KSB7IHJldHVybiBmYWxzZSB9XFxuICBpZiAoZXZlbnQuYWx0S2V5ICYmIGJhc2UgIT0gXFxcIkFsdFxcXCIpIHsgbmFtZSA9IFxcXCJBbHQtXFxcIiArIG5hbWU7IH1cXG4gIGlmICgoZmxpcEN0cmxDbWQgPyBldmVudC5tZXRhS2V5IDogZXZlbnQuY3RybEtleSkgJiYgYmFzZSAhPSBcXFwiQ3RybFxcXCIpIHsgbmFtZSA9IFxcXCJDdHJsLVxcXCIgKyBuYW1lOyB9XFxuICBpZiAoKGZsaXBDdHJsQ21kID8gZXZlbnQuY3RybEtleSA6IGV2ZW50Lm1ldGFLZXkpICYmIGJhc2UgIT0gXFxcIkNtZFxcXCIpIHsgbmFtZSA9IFxcXCJDbWQtXFxcIiArIG5hbWU7IH1cXG4gIGlmICghbm9TaGlmdCAmJiBldmVudC5zaGlmdEtleSAmJiBiYXNlICE9IFxcXCJTaGlmdFxcXCIpIHsgbmFtZSA9IFxcXCJTaGlmdC1cXFwiICsgbmFtZTsgfVxcbiAgcmV0dXJuIG5hbWVcXG59XFxuXFxuZnVuY3Rpb24gZ2V0S2V5TWFwKHZhbCkge1xcbiAgcmV0dXJuIHR5cGVvZiB2YWwgPT0gXFxcInN0cmluZ1xcXCIgPyBrZXlNYXBbdmFsXSA6IHZhbFxcbn1cXG5cXG4vLyBIZWxwZXIgZm9yIGRlbGV0aW5nIHRleHQgbmVhciB0aGUgc2VsZWN0aW9uKHMpLCB1c2VkIHRvIGltcGxlbWVudFxcbi8vIGJhY2tzcGFjZSwgZGVsZXRlLCBhbmQgc2ltaWxhciBmdW5jdGlvbmFsaXR5LlxcbmZ1bmN0aW9uIGRlbGV0ZU5lYXJTZWxlY3Rpb24oY20sIGNvbXB1dGUpIHtcXG4gIHZhciByYW5nZXMgPSBjbS5kb2Muc2VsLnJhbmdlcywga2lsbCA9IFtdO1xcbiAgLy8gQnVpbGQgdXAgYSBzZXQgb2YgcmFuZ2VzIHRvIGtpbGwgZmlyc3QsIG1lcmdpbmcgb3ZlcmxhcHBpbmdcXG4gIC8vIHJhbmdlcy5cXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcmFuZ2VzLmxlbmd0aDsgaSsrKSB7XFxuICAgIHZhciB0b0tpbGwgPSBjb21wdXRlKHJhbmdlc1tpXSk7XFxuICAgIHdoaWxlIChraWxsLmxlbmd0aCAmJiBjbXAodG9LaWxsLmZyb20sIGxzdChraWxsKS50bykgPD0gMCkge1xcbiAgICAgIHZhciByZXBsYWNlZCA9IGtpbGwucG9wKCk7XFxuICAgICAgaWYgKGNtcChyZXBsYWNlZC5mcm9tLCB0b0tpbGwuZnJvbSkgPCAwKSB7XFxuICAgICAgICB0b0tpbGwuZnJvbSA9IHJlcGxhY2VkLmZyb207XFxuICAgICAgICBicmVha1xcbiAgICAgIH1cXG4gICAgfVxcbiAgICBraWxsLnB1c2godG9LaWxsKTtcXG4gIH1cXG4gIC8vIE5leHQsIHJlbW92ZSB0aG9zZSBhY3R1YWwgcmFuZ2VzLlxcbiAgcnVuSW5PcChjbSwgZnVuY3Rpb24gKCkge1xcbiAgICBmb3IgKHZhciBpID0ga2lsbC5sZW5ndGggLSAxOyBpID49IDA7IGktLSlcXG4gICAgICB7IHJlcGxhY2VSYW5nZShjbS5kb2MsIFxcXCJcXFwiLCBraWxsW2ldLmZyb20sIGtpbGxbaV0udG8sIFxcXCIrZGVsZXRlXFxcIik7IH1cXG4gICAgZW5zdXJlQ3Vyc29yVmlzaWJsZShjbSk7XFxuICB9KTtcXG59XFxuXFxuLy8gQ29tbWFuZHMgYXJlIHBhcmFtZXRlci1sZXNzIGFjdGlvbnMgdGhhdCBjYW4gYmUgcGVyZm9ybWVkIG9uIGFuXFxuLy8gZWRpdG9yLCBtb3N0bHkgdXNlZCBmb3Iga2V5YmluZGluZ3MuXFxudmFyIGNvbW1hbmRzID0ge1xcbiAgc2VsZWN0QWxsOiBzZWxlY3RBbGwsXFxuICBzaW5nbGVTZWxlY3Rpb246IGZ1bmN0aW9uIChjbSkgeyByZXR1cm4gY20uc2V0U2VsZWN0aW9uKGNtLmdldEN1cnNvcihcXFwiYW5jaG9yXFxcIiksIGNtLmdldEN1cnNvcihcXFwiaGVhZFxcXCIpLCBzZWxfZG9udFNjcm9sbCk7IH0sXFxuICBraWxsTGluZTogZnVuY3Rpb24gKGNtKSB7IHJldHVybiBkZWxldGVOZWFyU2VsZWN0aW9uKGNtLCBmdW5jdGlvbiAocmFuZ2UpIHtcXG4gICAgaWYgKHJhbmdlLmVtcHR5KCkpIHtcXG4gICAgICB2YXIgbGVuID0gZ2V0TGluZShjbS5kb2MsIHJhbmdlLmhlYWQubGluZSkudGV4dC5sZW5ndGg7XFxuICAgICAgaWYgKHJhbmdlLmhlYWQuY2ggPT0gbGVuICYmIHJhbmdlLmhlYWQubGluZSA8IGNtLmxhc3RMaW5lKCkpXFxuICAgICAgICB7IHJldHVybiB7ZnJvbTogcmFuZ2UuaGVhZCwgdG86IFBvcyhyYW5nZS5oZWFkLmxpbmUgKyAxLCAwKX0gfVxcbiAgICAgIGVsc2VcXG4gICAgICAgIHsgcmV0dXJuIHtmcm9tOiByYW5nZS5oZWFkLCB0bzogUG9zKHJhbmdlLmhlYWQubGluZSwgbGVuKX0gfVxcbiAgICB9IGVsc2Uge1xcbiAgICAgIHJldHVybiB7ZnJvbTogcmFuZ2UuZnJvbSgpLCB0bzogcmFuZ2UudG8oKX1cXG4gICAgfVxcbiAgfSk7IH0sXFxuICBkZWxldGVMaW5lOiBmdW5jdGlvbiAoY20pIHsgcmV0dXJuIGRlbGV0ZU5lYXJTZWxlY3Rpb24oY20sIGZ1bmN0aW9uIChyYW5nZSkgeyByZXR1cm4gKHtcXG4gICAgZnJvbTogUG9zKHJhbmdlLmZyb20oKS5saW5lLCAwKSxcXG4gICAgdG86IGNsaXBQb3MoY20uZG9jLCBQb3MocmFuZ2UudG8oKS5saW5lICsgMSwgMCkpXFxuICB9KTsgfSk7IH0sXFxuICBkZWxMaW5lTGVmdDogZnVuY3Rpb24gKGNtKSB7IHJldHVybiBkZWxldGVOZWFyU2VsZWN0aW9uKGNtLCBmdW5jdGlvbiAocmFuZ2UpIHsgcmV0dXJuICh7XFxuICAgIGZyb206IFBvcyhyYW5nZS5mcm9tKCkubGluZSwgMCksIHRvOiByYW5nZS5mcm9tKClcXG4gIH0pOyB9KTsgfSxcXG4gIGRlbFdyYXBwZWRMaW5lTGVmdDogZnVuY3Rpb24gKGNtKSB7IHJldHVybiBkZWxldGVOZWFyU2VsZWN0aW9uKGNtLCBmdW5jdGlvbiAocmFuZ2UpIHtcXG4gICAgdmFyIHRvcCA9IGNtLmNoYXJDb29yZHMocmFuZ2UuaGVhZCwgXFxcImRpdlxcXCIpLnRvcCArIDU7XFxuICAgIHZhciBsZWZ0UG9zID0gY20uY29vcmRzQ2hhcih7bGVmdDogMCwgdG9wOiB0b3B9LCBcXFwiZGl2XFxcIik7XFxuICAgIHJldHVybiB7ZnJvbTogbGVmdFBvcywgdG86IHJhbmdlLmZyb20oKX1cXG4gIH0pOyB9LFxcbiAgZGVsV3JhcHBlZExpbmVSaWdodDogZnVuY3Rpb24gKGNtKSB7IHJldHVybiBkZWxldGVOZWFyU2VsZWN0aW9uKGNtLCBmdW5jdGlvbiAocmFuZ2UpIHtcXG4gICAgdmFyIHRvcCA9IGNtLmNoYXJDb29yZHMocmFuZ2UuaGVhZCwgXFxcImRpdlxcXCIpLnRvcCArIDU7XFxuICAgIHZhciByaWdodFBvcyA9IGNtLmNvb3Jkc0NoYXIoe2xlZnQ6IGNtLmRpc3BsYXkubGluZURpdi5vZmZzZXRXaWR0aCArIDEwMCwgdG9wOiB0b3B9LCBcXFwiZGl2XFxcIik7XFxuICAgIHJldHVybiB7ZnJvbTogcmFuZ2UuZnJvbSgpLCB0bzogcmlnaHRQb3MgfVxcbiAgfSk7IH0sXFxuICB1bmRvOiBmdW5jdGlvbiAoY20pIHsgcmV0dXJuIGNtLnVuZG8oKTsgfSxcXG4gIHJlZG86IGZ1bmN0aW9uIChjbSkgeyByZXR1cm4gY20ucmVkbygpOyB9LFxcbiAgdW5kb1NlbGVjdGlvbjogZnVuY3Rpb24gKGNtKSB7IHJldHVybiBjbS51bmRvU2VsZWN0aW9uKCk7IH0sXFxuICByZWRvU2VsZWN0aW9uOiBmdW5jdGlvbiAoY20pIHsgcmV0dXJuIGNtLnJlZG9TZWxlY3Rpb24oKTsgfSxcXG4gIGdvRG9jU3RhcnQ6IGZ1bmN0aW9uIChjbSkgeyByZXR1cm4gY20uZXh0ZW5kU2VsZWN0aW9uKFBvcyhjbS5maXJzdExpbmUoKSwgMCkpOyB9LFxcbiAgZ29Eb2NFbmQ6IGZ1bmN0aW9uIChjbSkgeyByZXR1cm4gY20uZXh0ZW5kU2VsZWN0aW9uKFBvcyhjbS5sYXN0TGluZSgpKSk7IH0sXFxuICBnb0xpbmVTdGFydDogZnVuY3Rpb24gKGNtKSB7IHJldHVybiBjbS5leHRlbmRTZWxlY3Rpb25zQnkoZnVuY3Rpb24gKHJhbmdlKSB7IHJldHVybiBsaW5lU3RhcnQoY20sIHJhbmdlLmhlYWQubGluZSk7IH0sXFxuICAgIHtvcmlnaW46IFxcXCIrbW92ZVxcXCIsIGJpYXM6IDF9XFxuICApOyB9LFxcbiAgZ29MaW5lU3RhcnRTbWFydDogZnVuY3Rpb24gKGNtKSB7IHJldHVybiBjbS5leHRlbmRTZWxlY3Rpb25zQnkoZnVuY3Rpb24gKHJhbmdlKSB7IHJldHVybiBsaW5lU3RhcnRTbWFydChjbSwgcmFuZ2UuaGVhZCk7IH0sXFxuICAgIHtvcmlnaW46IFxcXCIrbW92ZVxcXCIsIGJpYXM6IDF9XFxuICApOyB9LFxcbiAgZ29MaW5lRW5kOiBmdW5jdGlvbiAoY20pIHsgcmV0dXJuIGNtLmV4dGVuZFNlbGVjdGlvbnNCeShmdW5jdGlvbiAocmFuZ2UpIHsgcmV0dXJuIGxpbmVFbmQoY20sIHJhbmdlLmhlYWQubGluZSk7IH0sXFxuICAgIHtvcmlnaW46IFxcXCIrbW92ZVxcXCIsIGJpYXM6IC0xfVxcbiAgKTsgfSxcXG4gIGdvTGluZVJpZ2h0OiBmdW5jdGlvbiAoY20pIHsgcmV0dXJuIGNtLmV4dGVuZFNlbGVjdGlvbnNCeShmdW5jdGlvbiAocmFuZ2UpIHtcXG4gICAgdmFyIHRvcCA9IGNtLmNoYXJDb29yZHMocmFuZ2UuaGVhZCwgXFxcImRpdlxcXCIpLnRvcCArIDU7XFxuICAgIHJldHVybiBjbS5jb29yZHNDaGFyKHtsZWZ0OiBjbS5kaXNwbGF5LmxpbmVEaXYub2Zmc2V0V2lkdGggKyAxMDAsIHRvcDogdG9wfSwgXFxcImRpdlxcXCIpXFxuICB9LCBzZWxfbW92ZSk7IH0sXFxuICBnb0xpbmVMZWZ0OiBmdW5jdGlvbiAoY20pIHsgcmV0dXJuIGNtLmV4dGVuZFNlbGVjdGlvbnNCeShmdW5jdGlvbiAocmFuZ2UpIHtcXG4gICAgdmFyIHRvcCA9IGNtLmNoYXJDb29yZHMocmFuZ2UuaGVhZCwgXFxcImRpdlxcXCIpLnRvcCArIDU7XFxuICAgIHJldHVybiBjbS5jb29yZHNDaGFyKHtsZWZ0OiAwLCB0b3A6IHRvcH0sIFxcXCJkaXZcXFwiKVxcbiAgfSwgc2VsX21vdmUpOyB9LFxcbiAgZ29MaW5lTGVmdFNtYXJ0OiBmdW5jdGlvbiAoY20pIHsgcmV0dXJuIGNtLmV4dGVuZFNlbGVjdGlvbnNCeShmdW5jdGlvbiAocmFuZ2UpIHtcXG4gICAgdmFyIHRvcCA9IGNtLmNoYXJDb29yZHMocmFuZ2UuaGVhZCwgXFxcImRpdlxcXCIpLnRvcCArIDU7XFxuICAgIHZhciBwb3MgPSBjbS5jb29yZHNDaGFyKHtsZWZ0OiAwLCB0b3A6IHRvcH0sIFxcXCJkaXZcXFwiKTtcXG4gICAgaWYgKHBvcy5jaCA8IGNtLmdldExpbmUocG9zLmxpbmUpLnNlYXJjaCgvXFxcXFMvKSkgeyByZXR1cm4gbGluZVN0YXJ0U21hcnQoY20sIHJhbmdlLmhlYWQpIH1cXG4gICAgcmV0dXJuIHBvc1xcbiAgfSwgc2VsX21vdmUpOyB9LFxcbiAgZ29MaW5lVXA6IGZ1bmN0aW9uIChjbSkgeyByZXR1cm4gY20ubW92ZVYoLTEsIFxcXCJsaW5lXFxcIik7IH0sXFxuICBnb0xpbmVEb3duOiBmdW5jdGlvbiAoY20pIHsgcmV0dXJuIGNtLm1vdmVWKDEsIFxcXCJsaW5lXFxcIik7IH0sXFxuICBnb1BhZ2VVcDogZnVuY3Rpb24gKGNtKSB7IHJldHVybiBjbS5tb3ZlVigtMSwgXFxcInBhZ2VcXFwiKTsgfSxcXG4gIGdvUGFnZURvd246IGZ1bmN0aW9uIChjbSkgeyByZXR1cm4gY20ubW92ZVYoMSwgXFxcInBhZ2VcXFwiKTsgfSxcXG4gIGdvQ2hhckxlZnQ6IGZ1bmN0aW9uIChjbSkgeyByZXR1cm4gY20ubW92ZUgoLTEsIFxcXCJjaGFyXFxcIik7IH0sXFxuICBnb0NoYXJSaWdodDogZnVuY3Rpb24gKGNtKSB7IHJldHVybiBjbS5tb3ZlSCgxLCBcXFwiY2hhclxcXCIpOyB9LFxcbiAgZ29Db2x1bW5MZWZ0OiBmdW5jdGlvbiAoY20pIHsgcmV0dXJuIGNtLm1vdmVIKC0xLCBcXFwiY29sdW1uXFxcIik7IH0sXFxuICBnb0NvbHVtblJpZ2h0OiBmdW5jdGlvbiAoY20pIHsgcmV0dXJuIGNtLm1vdmVIKDEsIFxcXCJjb2x1bW5cXFwiKTsgfSxcXG4gIGdvV29yZExlZnQ6IGZ1bmN0aW9uIChjbSkgeyByZXR1cm4gY20ubW92ZUgoLTEsIFxcXCJ3b3JkXFxcIik7IH0sXFxuICBnb0dyb3VwUmlnaHQ6IGZ1bmN0aW9uIChjbSkgeyByZXR1cm4gY20ubW92ZUgoMSwgXFxcImdyb3VwXFxcIik7IH0sXFxuICBnb0dyb3VwTGVmdDogZnVuY3Rpb24gKGNtKSB7IHJldHVybiBjbS5tb3ZlSCgtMSwgXFxcImdyb3VwXFxcIik7IH0sXFxuICBnb1dvcmRSaWdodDogZnVuY3Rpb24gKGNtKSB7IHJldHVybiBjbS5tb3ZlSCgxLCBcXFwid29yZFxcXCIpOyB9LFxcbiAgZGVsQ2hhckJlZm9yZTogZnVuY3Rpb24gKGNtKSB7IHJldHVybiBjbS5kZWxldGVIKC0xLCBcXFwiY2hhclxcXCIpOyB9LFxcbiAgZGVsQ2hhckFmdGVyOiBmdW5jdGlvbiAoY20pIHsgcmV0dXJuIGNtLmRlbGV0ZUgoMSwgXFxcImNoYXJcXFwiKTsgfSxcXG4gIGRlbFdvcmRCZWZvcmU6IGZ1bmN0aW9uIChjbSkgeyByZXR1cm4gY20uZGVsZXRlSCgtMSwgXFxcIndvcmRcXFwiKTsgfSxcXG4gIGRlbFdvcmRBZnRlcjogZnVuY3Rpb24gKGNtKSB7IHJldHVybiBjbS5kZWxldGVIKDEsIFxcXCJ3b3JkXFxcIik7IH0sXFxuICBkZWxHcm91cEJlZm9yZTogZnVuY3Rpb24gKGNtKSB7IHJldHVybiBjbS5kZWxldGVIKC0xLCBcXFwiZ3JvdXBcXFwiKTsgfSxcXG4gIGRlbEdyb3VwQWZ0ZXI6IGZ1bmN0aW9uIChjbSkgeyByZXR1cm4gY20uZGVsZXRlSCgxLCBcXFwiZ3JvdXBcXFwiKTsgfSxcXG4gIGluZGVudEF1dG86IGZ1bmN0aW9uIChjbSkgeyByZXR1cm4gY20uaW5kZW50U2VsZWN0aW9uKFxcXCJzbWFydFxcXCIpOyB9LFxcbiAgaW5kZW50TW9yZTogZnVuY3Rpb24gKGNtKSB7IHJldHVybiBjbS5pbmRlbnRTZWxlY3Rpb24oXFxcImFkZFxcXCIpOyB9LFxcbiAgaW5kZW50TGVzczogZnVuY3Rpb24gKGNtKSB7IHJldHVybiBjbS5pbmRlbnRTZWxlY3Rpb24oXFxcInN1YnRyYWN0XFxcIik7IH0sXFxuICBpbnNlcnRUYWI6IGZ1bmN0aW9uIChjbSkgeyByZXR1cm4gY20ucmVwbGFjZVNlbGVjdGlvbihcXFwiXFxcXHRcXFwiKTsgfSxcXG4gIGluc2VydFNvZnRUYWI6IGZ1bmN0aW9uIChjbSkge1xcbiAgICB2YXIgc3BhY2VzID0gW10sIHJhbmdlcyA9IGNtLmxpc3RTZWxlY3Rpb25zKCksIHRhYlNpemUgPSBjbS5vcHRpb25zLnRhYlNpemU7XFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmFuZ2VzLmxlbmd0aDsgaSsrKSB7XFxuICAgICAgdmFyIHBvcyA9IHJhbmdlc1tpXS5mcm9tKCk7XFxuICAgICAgdmFyIGNvbCA9IGNvdW50Q29sdW1uKGNtLmdldExpbmUocG9zLmxpbmUpLCBwb3MuY2gsIHRhYlNpemUpO1xcbiAgICAgIHNwYWNlcy5wdXNoKHNwYWNlU3RyKHRhYlNpemUgLSBjb2wgJSB0YWJTaXplKSk7XFxuICAgIH1cXG4gICAgY20ucmVwbGFjZVNlbGVjdGlvbnMoc3BhY2VzKTtcXG4gIH0sXFxuICBkZWZhdWx0VGFiOiBmdW5jdGlvbiAoY20pIHtcXG4gICAgaWYgKGNtLnNvbWV0aGluZ1NlbGVjdGVkKCkpIHsgY20uaW5kZW50U2VsZWN0aW9uKFxcXCJhZGRcXFwiKTsgfVxcbiAgICBlbHNlIHsgY20uZXhlY0NvbW1hbmQoXFxcImluc2VydFRhYlxcXCIpOyB9XFxuICB9LFxcbiAgLy8gU3dhcCB0aGUgdHdvIGNoYXJzIGxlZnQgYW5kIHJpZ2h0IG9mIGVhY2ggc2VsZWN0aW9uJ3MgaGVhZC5cXG4gIC8vIE1vdmUgY3Vyc29yIGJlaGluZCB0aGUgdHdvIHN3YXBwZWQgY2hhcmFjdGVycyBhZnRlcndhcmRzLlxcbiAgLy9cXG4gIC8vIERvZXNuJ3QgY29uc2lkZXIgbGluZSBmZWVkcyBhIGNoYXJhY3Rlci5cXG4gIC8vIERvZXNuJ3Qgc2NhbiBtb3JlIHRoYW4gb25lIGxpbmUgYWJvdmUgdG8gZmluZCBhIGNoYXJhY3Rlci5cXG4gIC8vIERvZXNuJ3QgZG8gYW55dGhpbmcgb24gYW4gZW1wdHkgbGluZS5cXG4gIC8vIERvZXNuJ3QgZG8gYW55dGhpbmcgd2l0aCBub24tZW1wdHkgc2VsZWN0aW9ucy5cXG4gIHRyYW5zcG9zZUNoYXJzOiBmdW5jdGlvbiAoY20pIHsgcmV0dXJuIHJ1bkluT3AoY20sIGZ1bmN0aW9uICgpIHtcXG4gICAgdmFyIHJhbmdlcyA9IGNtLmxpc3RTZWxlY3Rpb25zKCksIG5ld1NlbCA9IFtdO1xcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJhbmdlcy5sZW5ndGg7IGkrKykge1xcbiAgICAgIGlmICghcmFuZ2VzW2ldLmVtcHR5KCkpIHsgY29udGludWUgfVxcbiAgICAgIHZhciBjdXIgPSByYW5nZXNbaV0uaGVhZCwgbGluZSA9IGdldExpbmUoY20uZG9jLCBjdXIubGluZSkudGV4dDtcXG4gICAgICBpZiAobGluZSkge1xcbiAgICAgICAgaWYgKGN1ci5jaCA9PSBsaW5lLmxlbmd0aCkgeyBjdXIgPSBuZXcgUG9zKGN1ci5saW5lLCBjdXIuY2ggLSAxKTsgfVxcbiAgICAgICAgaWYgKGN1ci5jaCA+IDApIHtcXG4gICAgICAgICAgY3VyID0gbmV3IFBvcyhjdXIubGluZSwgY3VyLmNoICsgMSk7XFxuICAgICAgICAgIGNtLnJlcGxhY2VSYW5nZShsaW5lLmNoYXJBdChjdXIuY2ggLSAxKSArIGxpbmUuY2hhckF0KGN1ci5jaCAtIDIpLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgUG9zKGN1ci5saW5lLCBjdXIuY2ggLSAyKSwgY3VyLCBcXFwiK3RyYW5zcG9zZVxcXCIpO1xcbiAgICAgICAgfSBlbHNlIGlmIChjdXIubGluZSA+IGNtLmRvYy5maXJzdCkge1xcbiAgICAgICAgICB2YXIgcHJldiA9IGdldExpbmUoY20uZG9jLCBjdXIubGluZSAtIDEpLnRleHQ7XFxuICAgICAgICAgIGlmIChwcmV2KSB7XFxuICAgICAgICAgICAgY3VyID0gbmV3IFBvcyhjdXIubGluZSwgMSk7XFxuICAgICAgICAgICAgY20ucmVwbGFjZVJhbmdlKGxpbmUuY2hhckF0KDApICsgY20uZG9jLmxpbmVTZXBhcmF0b3IoKSArXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZXYuY2hhckF0KHByZXYubGVuZ3RoIC0gMSksXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFBvcyhjdXIubGluZSAtIDEsIHByZXYubGVuZ3RoIC0gMSksIGN1ciwgXFxcIit0cmFuc3Bvc2VcXFwiKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgICBuZXdTZWwucHVzaChuZXcgUmFuZ2UoY3VyLCBjdXIpKTtcXG4gICAgfVxcbiAgICBjbS5zZXRTZWxlY3Rpb25zKG5ld1NlbCk7XFxuICB9KTsgfSxcXG4gIG5ld2xpbmVBbmRJbmRlbnQ6IGZ1bmN0aW9uIChjbSkgeyByZXR1cm4gcnVuSW5PcChjbSwgZnVuY3Rpb24gKCkge1xcbiAgICB2YXIgc2VscyA9IGNtLmxpc3RTZWxlY3Rpb25zKCk7XFxuICAgIGZvciAodmFyIGkgPSBzZWxzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxcbiAgICAgIHsgY20ucmVwbGFjZVJhbmdlKGNtLmRvYy5saW5lU2VwYXJhdG9yKCksIHNlbHNbaV0uYW5jaG9yLCBzZWxzW2ldLmhlYWQsIFxcXCIraW5wdXRcXFwiKTsgfVxcbiAgICBzZWxzID0gY20ubGlzdFNlbGVjdGlvbnMoKTtcXG4gICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgc2Vscy5sZW5ndGg7IGkkMSsrKVxcbiAgICAgIHsgY20uaW5kZW50TGluZShzZWxzW2kkMV0uZnJvbSgpLmxpbmUsIG51bGwsIHRydWUpOyB9XFxuICAgIGVuc3VyZUN1cnNvclZpc2libGUoY20pO1xcbiAgfSk7IH0sXFxuICBvcGVuTGluZTogZnVuY3Rpb24gKGNtKSB7IHJldHVybiBjbS5yZXBsYWNlU2VsZWN0aW9uKFxcXCJcXFxcblxcXCIsIFxcXCJzdGFydFxcXCIpOyB9LFxcbiAgdG9nZ2xlT3ZlcndyaXRlOiBmdW5jdGlvbiAoY20pIHsgcmV0dXJuIGNtLnRvZ2dsZU92ZXJ3cml0ZSgpOyB9XFxufTtcXG5cXG5cXG5mdW5jdGlvbiBsaW5lU3RhcnQoY20sIGxpbmVOKSB7XFxuICB2YXIgbGluZSA9IGdldExpbmUoY20uZG9jLCBsaW5lTik7XFxuICB2YXIgdmlzdWFsID0gdmlzdWFsTGluZShsaW5lKTtcXG4gIGlmICh2aXN1YWwgIT0gbGluZSkgeyBsaW5lTiA9IGxpbmVObyh2aXN1YWwpOyB9XFxuICByZXR1cm4gZW5kT2ZMaW5lKHRydWUsIGNtLCB2aXN1YWwsIGxpbmVOLCAxKVxcbn1cXG5mdW5jdGlvbiBsaW5lRW5kKGNtLCBsaW5lTikge1xcbiAgdmFyIGxpbmUgPSBnZXRMaW5lKGNtLmRvYywgbGluZU4pO1xcbiAgdmFyIHZpc3VhbCA9IHZpc3VhbExpbmVFbmQobGluZSk7XFxuICBpZiAodmlzdWFsICE9IGxpbmUpIHsgbGluZU4gPSBsaW5lTm8odmlzdWFsKTsgfVxcbiAgcmV0dXJuIGVuZE9mTGluZSh0cnVlLCBjbSwgbGluZSwgbGluZU4sIC0xKVxcbn1cXG5mdW5jdGlvbiBsaW5lU3RhcnRTbWFydChjbSwgcG9zKSB7XFxuICB2YXIgc3RhcnQgPSBsaW5lU3RhcnQoY20sIHBvcy5saW5lKTtcXG4gIHZhciBsaW5lID0gZ2V0TGluZShjbS5kb2MsIHN0YXJ0LmxpbmUpO1xcbiAgdmFyIG9yZGVyID0gZ2V0T3JkZXIobGluZSwgY20uZG9jLmRpcmVjdGlvbik7XFxuICBpZiAoIW9yZGVyIHx8IG9yZGVyWzBdLmxldmVsID09IDApIHtcXG4gICAgdmFyIGZpcnN0Tm9uV1MgPSBNYXRoLm1heCgwLCBsaW5lLnRleHQuc2VhcmNoKC9cXFxcUy8pKTtcXG4gICAgdmFyIGluV1MgPSBwb3MubGluZSA9PSBzdGFydC5saW5lICYmIHBvcy5jaCA8PSBmaXJzdE5vbldTICYmIHBvcy5jaDtcXG4gICAgcmV0dXJuIFBvcyhzdGFydC5saW5lLCBpbldTID8gMCA6IGZpcnN0Tm9uV1MsIHN0YXJ0LnN0aWNreSlcXG4gIH1cXG4gIHJldHVybiBzdGFydFxcbn1cXG5cXG4vLyBSdW4gYSBoYW5kbGVyIHRoYXQgd2FzIGJvdW5kIHRvIGEga2V5LlxcbmZ1bmN0aW9uIGRvSGFuZGxlQmluZGluZyhjbSwgYm91bmQsIGRyb3BTaGlmdCkge1xcbiAgaWYgKHR5cGVvZiBib3VuZCA9PSBcXFwic3RyaW5nXFxcIikge1xcbiAgICBib3VuZCA9IGNvbW1hbmRzW2JvdW5kXTtcXG4gICAgaWYgKCFib3VuZCkgeyByZXR1cm4gZmFsc2UgfVxcbiAgfVxcbiAgLy8gRW5zdXJlIHByZXZpb3VzIGlucHV0IGhhcyBiZWVuIHJlYWQsIHNvIHRoYXQgdGhlIGhhbmRsZXIgc2VlcyBhXFxuICAvLyBjb25zaXN0ZW50IHZpZXcgb2YgdGhlIGRvY3VtZW50XFxuICBjbS5kaXNwbGF5LmlucHV0LmVuc3VyZVBvbGxlZCgpO1xcbiAgdmFyIHByZXZTaGlmdCA9IGNtLmRpc3BsYXkuc2hpZnQsIGRvbmUgPSBmYWxzZTtcXG4gIHRyeSB7XFxuICAgIGlmIChjbS5pc1JlYWRPbmx5KCkpIHsgY20uc3RhdGUuc3VwcHJlc3NFZGl0cyA9IHRydWU7IH1cXG4gICAgaWYgKGRyb3BTaGlmdCkgeyBjbS5kaXNwbGF5LnNoaWZ0ID0gZmFsc2U7IH1cXG4gICAgZG9uZSA9IGJvdW5kKGNtKSAhPSBQYXNzO1xcbiAgfSBmaW5hbGx5IHtcXG4gICAgY20uZGlzcGxheS5zaGlmdCA9IHByZXZTaGlmdDtcXG4gICAgY20uc3RhdGUuc3VwcHJlc3NFZGl0cyA9IGZhbHNlO1xcbiAgfVxcbiAgcmV0dXJuIGRvbmVcXG59XFxuXFxuZnVuY3Rpb24gbG9va3VwS2V5Rm9yRWRpdG9yKGNtLCBuYW1lLCBoYW5kbGUpIHtcXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY20uc3RhdGUua2V5TWFwcy5sZW5ndGg7IGkrKykge1xcbiAgICB2YXIgcmVzdWx0ID0gbG9va3VwS2V5KG5hbWUsIGNtLnN0YXRlLmtleU1hcHNbaV0sIGhhbmRsZSwgY20pO1xcbiAgICBpZiAocmVzdWx0KSB7IHJldHVybiByZXN1bHQgfVxcbiAgfVxcbiAgcmV0dXJuIChjbS5vcHRpb25zLmV4dHJhS2V5cyAmJiBsb29rdXBLZXkobmFtZSwgY20ub3B0aW9ucy5leHRyYUtleXMsIGhhbmRsZSwgY20pKVxcbiAgICB8fCBsb29rdXBLZXkobmFtZSwgY20ub3B0aW9ucy5rZXlNYXAsIGhhbmRsZSwgY20pXFxufVxcblxcbnZhciBzdG9wU2VxID0gbmV3IERlbGF5ZWQ7XFxuZnVuY3Rpb24gZGlzcGF0Y2hLZXkoY20sIG5hbWUsIGUsIGhhbmRsZSkge1xcbiAgdmFyIHNlcSA9IGNtLnN0YXRlLmtleVNlcTtcXG4gIGlmIChzZXEpIHtcXG4gICAgaWYgKGlzTW9kaWZpZXJLZXkobmFtZSkpIHsgcmV0dXJuIFxcXCJoYW5kbGVkXFxcIiB9XFxuICAgIHN0b3BTZXEuc2V0KDUwLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgaWYgKGNtLnN0YXRlLmtleVNlcSA9PSBzZXEpIHtcXG4gICAgICAgIGNtLnN0YXRlLmtleVNlcSA9IG51bGw7XFxuICAgICAgICBjbS5kaXNwbGF5LmlucHV0LnJlc2V0KCk7XFxuICAgICAgfVxcbiAgICB9KTtcXG4gICAgbmFtZSA9IHNlcSArIFxcXCIgXFxcIiArIG5hbWU7XFxuICB9XFxuICB2YXIgcmVzdWx0ID0gbG9va3VwS2V5Rm9yRWRpdG9yKGNtLCBuYW1lLCBoYW5kbGUpO1xcblxcbiAgaWYgKHJlc3VsdCA9PSBcXFwibXVsdGlcXFwiKVxcbiAgICB7IGNtLnN0YXRlLmtleVNlcSA9IG5hbWU7IH1cXG4gIGlmIChyZXN1bHQgPT0gXFxcImhhbmRsZWRcXFwiKVxcbiAgICB7IHNpZ25hbExhdGVyKGNtLCBcXFwia2V5SGFuZGxlZFxcXCIsIGNtLCBuYW1lLCBlKTsgfVxcblxcbiAgaWYgKHJlc3VsdCA9PSBcXFwiaGFuZGxlZFxcXCIgfHwgcmVzdWx0ID09IFxcXCJtdWx0aVxcXCIpIHtcXG4gICAgZV9wcmV2ZW50RGVmYXVsdChlKTtcXG4gICAgcmVzdGFydEJsaW5rKGNtKTtcXG4gIH1cXG5cXG4gIGlmIChzZXEgJiYgIXJlc3VsdCAmJiAvXFxcXCckLy50ZXN0KG5hbWUpKSB7XFxuICAgIGVfcHJldmVudERlZmF1bHQoZSk7XFxuICAgIHJldHVybiB0cnVlXFxuICB9XFxuICByZXR1cm4gISFyZXN1bHRcXG59XFxuXFxuLy8gSGFuZGxlIGEga2V5IGZyb20gdGhlIGtleWRvd24gZXZlbnQuXFxuZnVuY3Rpb24gaGFuZGxlS2V5QmluZGluZyhjbSwgZSkge1xcbiAgdmFyIG5hbWUgPSBrZXlOYW1lKGUsIHRydWUpO1xcbiAgaWYgKCFuYW1lKSB7IHJldHVybiBmYWxzZSB9XFxuXFxuICBpZiAoZS5zaGlmdEtleSAmJiAhY20uc3RhdGUua2V5U2VxKSB7XFxuICAgIC8vIEZpcnN0IHRyeSB0byByZXNvbHZlIGZ1bGwgbmFtZSAoaW5jbHVkaW5nICdTaGlmdC0nKS4gRmFpbGluZ1xcbiAgICAvLyB0aGF0LCBzZWUgaWYgdGhlcmUgaXMgYSBjdXJzb3ItbW90aW9uIGNvbW1hbmQgKHN0YXJ0aW5nIHdpdGhcXG4gICAgLy8gJ2dvJykgYm91bmQgdG8gdGhlIGtleW5hbWUgd2l0aG91dCAnU2hpZnQtJy5cXG4gICAgcmV0dXJuIGRpc3BhdGNoS2V5KGNtLCBcXFwiU2hpZnQtXFxcIiArIG5hbWUsIGUsIGZ1bmN0aW9uIChiKSB7IHJldHVybiBkb0hhbmRsZUJpbmRpbmcoY20sIGIsIHRydWUpOyB9KVxcbiAgICAgICAgfHwgZGlzcGF0Y2hLZXkoY20sIG5hbWUsIGUsIGZ1bmN0aW9uIChiKSB7XFxuICAgICAgICAgICAgIGlmICh0eXBlb2YgYiA9PSBcXFwic3RyaW5nXFxcIiA/IC9eZ29bQS1aXS8udGVzdChiKSA6IGIubW90aW9uKVxcbiAgICAgICAgICAgICAgIHsgcmV0dXJuIGRvSGFuZGxlQmluZGluZyhjbSwgYikgfVxcbiAgICAgICAgICAgfSlcXG4gIH0gZWxzZSB7XFxuICAgIHJldHVybiBkaXNwYXRjaEtleShjbSwgbmFtZSwgZSwgZnVuY3Rpb24gKGIpIHsgcmV0dXJuIGRvSGFuZGxlQmluZGluZyhjbSwgYik7IH0pXFxuICB9XFxufVxcblxcbi8vIEhhbmRsZSBhIGtleSBmcm9tIHRoZSBrZXlwcmVzcyBldmVudFxcbmZ1bmN0aW9uIGhhbmRsZUNoYXJCaW5kaW5nKGNtLCBlLCBjaCkge1xcbiAgcmV0dXJuIGRpc3BhdGNoS2V5KGNtLCBcXFwiJ1xcXCIgKyBjaCArIFxcXCInXFxcIiwgZSwgZnVuY3Rpb24gKGIpIHsgcmV0dXJuIGRvSGFuZGxlQmluZGluZyhjbSwgYiwgdHJ1ZSk7IH0pXFxufVxcblxcbnZhciBsYXN0U3RvcHBlZEtleSA9IG51bGw7XFxuZnVuY3Rpb24gb25LZXlEb3duKGUpIHtcXG4gIHZhciBjbSA9IHRoaXM7XFxuICBjbS5jdXJPcC5mb2N1cyA9IGFjdGl2ZUVsdCgpO1xcbiAgaWYgKHNpZ25hbERPTUV2ZW50KGNtLCBlKSkgeyByZXR1cm4gfVxcbiAgLy8gSUUgZG9lcyBzdHJhbmdlIHRoaW5ncyB3aXRoIGVzY2FwZS5cXG4gIGlmIChpZSAmJiBpZV92ZXJzaW9uIDwgMTEgJiYgZS5rZXlDb2RlID09IDI3KSB7IGUucmV0dXJuVmFsdWUgPSBmYWxzZTsgfVxcbiAgdmFyIGNvZGUgPSBlLmtleUNvZGU7XFxuICBjbS5kaXNwbGF5LnNoaWZ0ID0gY29kZSA9PSAxNiB8fCBlLnNoaWZ0S2V5O1xcbiAgdmFyIGhhbmRsZWQgPSBoYW5kbGVLZXlCaW5kaW5nKGNtLCBlKTtcXG4gIGlmIChwcmVzdG8pIHtcXG4gICAgbGFzdFN0b3BwZWRLZXkgPSBoYW5kbGVkID8gY29kZSA6IG51bGw7XFxuICAgIC8vIE9wZXJhIGhhcyBubyBjdXQgZXZlbnQuLi4gd2UgdHJ5IHRvIGF0IGxlYXN0IGNhdGNoIHRoZSBrZXkgY29tYm9cXG4gICAgaWYgKCFoYW5kbGVkICYmIGNvZGUgPT0gODggJiYgIWhhc0NvcHlFdmVudCAmJiAobWFjID8gZS5tZXRhS2V5IDogZS5jdHJsS2V5KSlcXG4gICAgICB7IGNtLnJlcGxhY2VTZWxlY3Rpb24oXFxcIlxcXCIsIG51bGwsIFxcXCJjdXRcXFwiKTsgfVxcbiAgfVxcblxcbiAgLy8gVHVybiBtb3VzZSBpbnRvIGNyb3NzaGFpciB3aGVuIEFsdCBpcyBoZWxkIG9uIE1hYy5cXG4gIGlmIChjb2RlID09IDE4ICYmICEvXFxcXGJDb2RlTWlycm9yLWNyb3NzaGFpclxcXFxiLy50ZXN0KGNtLmRpc3BsYXkubGluZURpdi5jbGFzc05hbWUpKVxcbiAgICB7IHNob3dDcm9zc0hhaXIoY20pOyB9XFxufVxcblxcbmZ1bmN0aW9uIHNob3dDcm9zc0hhaXIoY20pIHtcXG4gIHZhciBsaW5lRGl2ID0gY20uZGlzcGxheS5saW5lRGl2O1xcbiAgYWRkQ2xhc3MobGluZURpdiwgXFxcIkNvZGVNaXJyb3ItY3Jvc3NoYWlyXFxcIik7XFxuXFxuICBmdW5jdGlvbiB1cChlKSB7XFxuICAgIGlmIChlLmtleUNvZGUgPT0gMTggfHwgIWUuYWx0S2V5KSB7XFxuICAgICAgcm1DbGFzcyhsaW5lRGl2LCBcXFwiQ29kZU1pcnJvci1jcm9zc2hhaXJcXFwiKTtcXG4gICAgICBvZmYoZG9jdW1lbnQsIFxcXCJrZXl1cFxcXCIsIHVwKTtcXG4gICAgICBvZmYoZG9jdW1lbnQsIFxcXCJtb3VzZW92ZXJcXFwiLCB1cCk7XFxuICAgIH1cXG4gIH1cXG4gIG9uKGRvY3VtZW50LCBcXFwia2V5dXBcXFwiLCB1cCk7XFxuICBvbihkb2N1bWVudCwgXFxcIm1vdXNlb3ZlclxcXCIsIHVwKTtcXG59XFxuXFxuZnVuY3Rpb24gb25LZXlVcChlKSB7XFxuICBpZiAoZS5rZXlDb2RlID09IDE2KSB7IHRoaXMuZG9jLnNlbC5zaGlmdCA9IGZhbHNlOyB9XFxuICBzaWduYWxET01FdmVudCh0aGlzLCBlKTtcXG59XFxuXFxuZnVuY3Rpb24gb25LZXlQcmVzcyhlKSB7XFxuICB2YXIgY20gPSB0aGlzO1xcbiAgaWYgKGV2ZW50SW5XaWRnZXQoY20uZGlzcGxheSwgZSkgfHwgc2lnbmFsRE9NRXZlbnQoY20sIGUpIHx8IGUuY3RybEtleSAmJiAhZS5hbHRLZXkgfHwgbWFjICYmIGUubWV0YUtleSkgeyByZXR1cm4gfVxcbiAgdmFyIGtleUNvZGUgPSBlLmtleUNvZGUsIGNoYXJDb2RlID0gZS5jaGFyQ29kZTtcXG4gIGlmIChwcmVzdG8gJiYga2V5Q29kZSA9PSBsYXN0U3RvcHBlZEtleSkge2xhc3RTdG9wcGVkS2V5ID0gbnVsbDsgZV9wcmV2ZW50RGVmYXVsdChlKTsgcmV0dXJufVxcbiAgaWYgKChwcmVzdG8gJiYgKCFlLndoaWNoIHx8IGUud2hpY2ggPCAxMCkpICYmIGhhbmRsZUtleUJpbmRpbmcoY20sIGUpKSB7IHJldHVybiB9XFxuICB2YXIgY2ggPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNoYXJDb2RlID09IG51bGwgPyBrZXlDb2RlIDogY2hhckNvZGUpO1xcbiAgLy8gU29tZSBicm93c2VycyBmaXJlIGtleXByZXNzIGV2ZW50cyBmb3IgYmFja3NwYWNlXFxuICBpZiAoY2ggPT0gXFxcIlxcXFx4MDhcXFwiKSB7IHJldHVybiB9XFxuICBpZiAoaGFuZGxlQ2hhckJpbmRpbmcoY20sIGUsIGNoKSkgeyByZXR1cm4gfVxcbiAgY20uZGlzcGxheS5pbnB1dC5vbktleVByZXNzKGUpO1xcbn1cXG5cXG4vLyBBIG1vdXNlIGRvd24gY2FuIGJlIGEgc2luZ2xlIGNsaWNrLCBkb3VibGUgY2xpY2ssIHRyaXBsZSBjbGljayxcXG4vLyBzdGFydCBvZiBzZWxlY3Rpb24gZHJhZywgc3RhcnQgb2YgdGV4dCBkcmFnLCBuZXcgY3Vyc29yXFxuLy8gKGN0cmwtY2xpY2spLCByZWN0YW5nbGUgZHJhZyAoYWx0LWRyYWcpLCBvciB4d2luXFxuLy8gbWlkZGxlLWNsaWNrLXBhc3RlLiBPciBpdCBtaWdodCBiZSBhIGNsaWNrIG9uIHNvbWV0aGluZyB3ZSBzaG91bGRcXG4vLyBub3QgaW50ZXJmZXJlIHdpdGgsIHN1Y2ggYXMgYSBzY3JvbGxiYXIgb3Igd2lkZ2V0LlxcbmZ1bmN0aW9uIG9uTW91c2VEb3duKGUpIHtcXG4gIHZhciBjbSA9IHRoaXMsIGRpc3BsYXkgPSBjbS5kaXNwbGF5O1xcbiAgaWYgKHNpZ25hbERPTUV2ZW50KGNtLCBlKSB8fCBkaXNwbGF5LmFjdGl2ZVRvdWNoICYmIGRpc3BsYXkuaW5wdXQuc3VwcG9ydHNUb3VjaCgpKSB7IHJldHVybiB9XFxuICBkaXNwbGF5LmlucHV0LmVuc3VyZVBvbGxlZCgpO1xcbiAgZGlzcGxheS5zaGlmdCA9IGUuc2hpZnRLZXk7XFxuXFxuICBpZiAoZXZlbnRJbldpZGdldChkaXNwbGF5LCBlKSkge1xcbiAgICBpZiAoIXdlYmtpdCkge1xcbiAgICAgIC8vIEJyaWVmbHkgdHVybiBvZmYgZHJhZ2dhYmlsaXR5LCB0byBhbGxvdyB3aWRnZXRzIHRvIGRvXFxuICAgICAgLy8gbm9ybWFsIGRyYWdnaW5nIHRoaW5ncy5cXG4gICAgICBkaXNwbGF5LnNjcm9sbGVyLmRyYWdnYWJsZSA9IGZhbHNlO1xcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyByZXR1cm4gZGlzcGxheS5zY3JvbGxlci5kcmFnZ2FibGUgPSB0cnVlOyB9LCAxMDApO1xcbiAgICB9XFxuICAgIHJldHVyblxcbiAgfVxcbiAgaWYgKGNsaWNrSW5HdXR0ZXIoY20sIGUpKSB7IHJldHVybiB9XFxuICB2YXIgc3RhcnQgPSBwb3NGcm9tTW91c2UoY20sIGUpO1xcbiAgd2luZG93LmZvY3VzKCk7XFxuXFxuICBzd2l0Y2ggKGVfYnV0dG9uKGUpKSB7XFxuICBjYXNlIDE6XFxuICAgIC8vICMzMjYxOiBtYWtlIHN1cmUsIHRoYXQgd2UncmUgbm90IHN0YXJ0aW5nIGEgc2Vjb25kIHNlbGVjdGlvblxcbiAgICBpZiAoY20uc3RhdGUuc2VsZWN0aW5nVGV4dClcXG4gICAgICB7IGNtLnN0YXRlLnNlbGVjdGluZ1RleHQoZSk7IH1cXG4gICAgZWxzZSBpZiAoc3RhcnQpXFxuICAgICAgeyBsZWZ0QnV0dG9uRG93bihjbSwgZSwgc3RhcnQpOyB9XFxuICAgIGVsc2UgaWYgKGVfdGFyZ2V0KGUpID09IGRpc3BsYXkuc2Nyb2xsZXIpXFxuICAgICAgeyBlX3ByZXZlbnREZWZhdWx0KGUpOyB9XFxuICAgIGJyZWFrXFxuICBjYXNlIDI6XFxuICAgIGlmICh3ZWJraXQpIHsgY20uc3RhdGUubGFzdE1pZGRsZURvd24gPSArbmV3IERhdGU7IH1cXG4gICAgaWYgKHN0YXJ0KSB7IGV4dGVuZFNlbGVjdGlvbihjbS5kb2MsIHN0YXJ0KTsgfVxcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRpc3BsYXkuaW5wdXQuZm9jdXMoKTsgfSwgMjApO1xcbiAgICBlX3ByZXZlbnREZWZhdWx0KGUpO1xcbiAgICBicmVha1xcbiAgY2FzZSAzOlxcbiAgICBpZiAoY2FwdHVyZVJpZ2h0Q2xpY2spIHsgb25Db250ZXh0TWVudShjbSwgZSk7IH1cXG4gICAgZWxzZSB7IGRlbGF5Qmx1ckV2ZW50KGNtKTsgfVxcbiAgICBicmVha1xcbiAgfVxcbn1cXG5cXG52YXIgbGFzdENsaWNrO1xcbnZhciBsYXN0RG91YmxlQ2xpY2s7XFxuZnVuY3Rpb24gbGVmdEJ1dHRvbkRvd24oY20sIGUsIHN0YXJ0KSB7XFxuICBpZiAoaWUpIHsgc2V0VGltZW91dChiaW5kKGVuc3VyZUZvY3VzLCBjbSksIDApOyB9XFxuICBlbHNlIHsgY20uY3VyT3AuZm9jdXMgPSBhY3RpdmVFbHQoKTsgfVxcblxcbiAgdmFyIG5vdyA9ICtuZXcgRGF0ZSwgdHlwZTtcXG4gIGlmIChsYXN0RG91YmxlQ2xpY2sgJiYgbGFzdERvdWJsZUNsaWNrLnRpbWUgPiBub3cgLSA0MDAgJiYgY21wKGxhc3REb3VibGVDbGljay5wb3MsIHN0YXJ0KSA9PSAwKSB7XFxuICAgIHR5cGUgPSBcXFwidHJpcGxlXFxcIjtcXG4gIH0gZWxzZSBpZiAobGFzdENsaWNrICYmIGxhc3RDbGljay50aW1lID4gbm93IC0gNDAwICYmIGNtcChsYXN0Q2xpY2sucG9zLCBzdGFydCkgPT0gMCkge1xcbiAgICB0eXBlID0gXFxcImRvdWJsZVxcXCI7XFxuICAgIGxhc3REb3VibGVDbGljayA9IHt0aW1lOiBub3csIHBvczogc3RhcnR9O1xcbiAgfSBlbHNlIHtcXG4gICAgdHlwZSA9IFxcXCJzaW5nbGVcXFwiO1xcbiAgICBsYXN0Q2xpY2sgPSB7dGltZTogbm93LCBwb3M6IHN0YXJ0fTtcXG4gIH1cXG5cXG4gIHZhciBzZWwgPSBjbS5kb2Muc2VsLCBtb2RpZmllciA9IG1hYyA/IGUubWV0YUtleSA6IGUuY3RybEtleSwgY29udGFpbmVkO1xcbiAgaWYgKGNtLm9wdGlvbnMuZHJhZ0Ryb3AgJiYgZHJhZ0FuZERyb3AgJiYgIWNtLmlzUmVhZE9ubHkoKSAmJlxcbiAgICAgIHR5cGUgPT0gXFxcInNpbmdsZVxcXCIgJiYgKGNvbnRhaW5lZCA9IHNlbC5jb250YWlucyhzdGFydCkpID4gLTEgJiZcXG4gICAgICAoY21wKChjb250YWluZWQgPSBzZWwucmFuZ2VzW2NvbnRhaW5lZF0pLmZyb20oKSwgc3RhcnQpIDwgMCB8fCBzdGFydC54UmVsID4gMCkgJiZcXG4gICAgICAoY21wKGNvbnRhaW5lZC50bygpLCBzdGFydCkgPiAwIHx8IHN0YXJ0LnhSZWwgPCAwKSlcXG4gICAgeyBsZWZ0QnV0dG9uU3RhcnREcmFnKGNtLCBlLCBzdGFydCwgbW9kaWZpZXIpOyB9XFxuICBlbHNlXFxuICAgIHsgbGVmdEJ1dHRvblNlbGVjdChjbSwgZSwgc3RhcnQsIHR5cGUsIG1vZGlmaWVyKTsgfVxcbn1cXG5cXG4vLyBTdGFydCBhIHRleHQgZHJhZy4gV2hlbiBpdCBlbmRzLCBzZWUgaWYgYW55IGRyYWdnaW5nIGFjdHVhbGx5XFxuLy8gaGFwcGVuLCBhbmQgdHJlYXQgYXMgYSBjbGljayBpZiBpdCBkaWRuJ3QuXFxuZnVuY3Rpb24gbGVmdEJ1dHRvblN0YXJ0RHJhZyhjbSwgZSwgc3RhcnQsIG1vZGlmaWVyKSB7XFxuICB2YXIgZGlzcGxheSA9IGNtLmRpc3BsYXksIHN0YXJ0VGltZSA9ICtuZXcgRGF0ZTtcXG4gIHZhciBkcmFnRW5kID0gb3BlcmF0aW9uKGNtLCBmdW5jdGlvbiAoZTIpIHtcXG4gICAgaWYgKHdlYmtpdCkgeyBkaXNwbGF5LnNjcm9sbGVyLmRyYWdnYWJsZSA9IGZhbHNlOyB9XFxuICAgIGNtLnN0YXRlLmRyYWdnaW5nVGV4dCA9IGZhbHNlO1xcbiAgICBvZmYoZG9jdW1lbnQsIFxcXCJtb3VzZXVwXFxcIiwgZHJhZ0VuZCk7XFxuICAgIG9mZihkaXNwbGF5LnNjcm9sbGVyLCBcXFwiZHJvcFxcXCIsIGRyYWdFbmQpO1xcbiAgICBpZiAoTWF0aC5hYnMoZS5jbGllbnRYIC0gZTIuY2xpZW50WCkgKyBNYXRoLmFicyhlLmNsaWVudFkgLSBlMi5jbGllbnRZKSA8IDEwKSB7XFxuICAgICAgZV9wcmV2ZW50RGVmYXVsdChlMik7XFxuICAgICAgaWYgKCFtb2RpZmllciAmJiArbmV3IERhdGUgLSAyMDAgPCBzdGFydFRpbWUpXFxuICAgICAgICB7IGV4dGVuZFNlbGVjdGlvbihjbS5kb2MsIHN0YXJ0KTsgfVxcbiAgICAgIC8vIFdvcmsgYXJvdW5kIHVuZXhwbGFpbmFibGUgZm9jdXMgcHJvYmxlbSBpbiBJRTkgKCMyMTI3KSBhbmQgQ2hyb21lICgjMzA4MSlcXG4gICAgICBpZiAod2Via2l0IHx8IGllICYmIGllX3ZlcnNpb24gPT0gOSlcXG4gICAgICAgIHsgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7ZG9jdW1lbnQuYm9keS5mb2N1cygpOyBkaXNwbGF5LmlucHV0LmZvY3VzKCk7fSwgMjApOyB9XFxuICAgICAgZWxzZVxcbiAgICAgICAgeyBkaXNwbGF5LmlucHV0LmZvY3VzKCk7IH1cXG4gICAgfVxcbiAgfSk7XFxuICAvLyBMZXQgdGhlIGRyYWcgaGFuZGxlciBoYW5kbGUgdGhpcy5cXG4gIGlmICh3ZWJraXQpIHsgZGlzcGxheS5zY3JvbGxlci5kcmFnZ2FibGUgPSB0cnVlOyB9XFxuICBjbS5zdGF0ZS5kcmFnZ2luZ1RleHQgPSBkcmFnRW5kO1xcbiAgZHJhZ0VuZC5jb3B5ID0gbWFjID8gZS5hbHRLZXkgOiBlLmN0cmxLZXk7XFxuICAvLyBJRSdzIGFwcHJvYWNoIHRvIGRyYWdnYWJsZVxcbiAgaWYgKGRpc3BsYXkuc2Nyb2xsZXIuZHJhZ0Ryb3ApIHsgZGlzcGxheS5zY3JvbGxlci5kcmFnRHJvcCgpOyB9XFxuICBvbihkb2N1bWVudCwgXFxcIm1vdXNldXBcXFwiLCBkcmFnRW5kKTtcXG4gIG9uKGRpc3BsYXkuc2Nyb2xsZXIsIFxcXCJkcm9wXFxcIiwgZHJhZ0VuZCk7XFxufVxcblxcbi8vIE5vcm1hbCBzZWxlY3Rpb24sIGFzIG9wcG9zZWQgdG8gdGV4dCBkcmFnZ2luZy5cXG5mdW5jdGlvbiBsZWZ0QnV0dG9uU2VsZWN0KGNtLCBlLCBzdGFydCwgdHlwZSwgYWRkTmV3KSB7XFxuICB2YXIgZGlzcGxheSA9IGNtLmRpc3BsYXksIGRvYyA9IGNtLmRvYztcXG4gIGVfcHJldmVudERlZmF1bHQoZSk7XFxuXFxuICB2YXIgb3VyUmFuZ2UsIG91ckluZGV4LCBzdGFydFNlbCA9IGRvYy5zZWwsIHJhbmdlcyA9IHN0YXJ0U2VsLnJhbmdlcztcXG4gIGlmIChhZGROZXcgJiYgIWUuc2hpZnRLZXkpIHtcXG4gICAgb3VySW5kZXggPSBkb2Muc2VsLmNvbnRhaW5zKHN0YXJ0KTtcXG4gICAgaWYgKG91ckluZGV4ID4gLTEpXFxuICAgICAgeyBvdXJSYW5nZSA9IHJhbmdlc1tvdXJJbmRleF07IH1cXG4gICAgZWxzZVxcbiAgICAgIHsgb3VyUmFuZ2UgPSBuZXcgUmFuZ2Uoc3RhcnQsIHN0YXJ0KTsgfVxcbiAgfSBlbHNlIHtcXG4gICAgb3VyUmFuZ2UgPSBkb2Muc2VsLnByaW1hcnkoKTtcXG4gICAgb3VySW5kZXggPSBkb2Muc2VsLnByaW1JbmRleDtcXG4gIH1cXG5cXG4gIGlmIChjaHJvbWVPUyA/IGUuc2hpZnRLZXkgJiYgZS5tZXRhS2V5IDogZS5hbHRLZXkpIHtcXG4gICAgdHlwZSA9IFxcXCJyZWN0XFxcIjtcXG4gICAgaWYgKCFhZGROZXcpIHsgb3VyUmFuZ2UgPSBuZXcgUmFuZ2Uoc3RhcnQsIHN0YXJ0KTsgfVxcbiAgICBzdGFydCA9IHBvc0Zyb21Nb3VzZShjbSwgZSwgdHJ1ZSwgdHJ1ZSk7XFxuICAgIG91ckluZGV4ID0gLTE7XFxuICB9IGVsc2UgaWYgKHR5cGUgPT0gXFxcImRvdWJsZVxcXCIpIHtcXG4gICAgdmFyIHdvcmQgPSBjbS5maW5kV29yZEF0KHN0YXJ0KTtcXG4gICAgaWYgKGNtLmRpc3BsYXkuc2hpZnQgfHwgZG9jLmV4dGVuZClcXG4gICAgICB7IG91clJhbmdlID0gZXh0ZW5kUmFuZ2UoZG9jLCBvdXJSYW5nZSwgd29yZC5hbmNob3IsIHdvcmQuaGVhZCk7IH1cXG4gICAgZWxzZVxcbiAgICAgIHsgb3VyUmFuZ2UgPSB3b3JkOyB9XFxuICB9IGVsc2UgaWYgKHR5cGUgPT0gXFxcInRyaXBsZVxcXCIpIHtcXG4gICAgdmFyIGxpbmUgPSBuZXcgUmFuZ2UoUG9zKHN0YXJ0LmxpbmUsIDApLCBjbGlwUG9zKGRvYywgUG9zKHN0YXJ0LmxpbmUgKyAxLCAwKSkpO1xcbiAgICBpZiAoY20uZGlzcGxheS5zaGlmdCB8fCBkb2MuZXh0ZW5kKVxcbiAgICAgIHsgb3VyUmFuZ2UgPSBleHRlbmRSYW5nZShkb2MsIG91clJhbmdlLCBsaW5lLmFuY2hvciwgbGluZS5oZWFkKTsgfVxcbiAgICBlbHNlXFxuICAgICAgeyBvdXJSYW5nZSA9IGxpbmU7IH1cXG4gIH0gZWxzZSB7XFxuICAgIG91clJhbmdlID0gZXh0ZW5kUmFuZ2UoZG9jLCBvdXJSYW5nZSwgc3RhcnQpO1xcbiAgfVxcblxcbiAgaWYgKCFhZGROZXcpIHtcXG4gICAgb3VySW5kZXggPSAwO1xcbiAgICBzZXRTZWxlY3Rpb24oZG9jLCBuZXcgU2VsZWN0aW9uKFtvdXJSYW5nZV0sIDApLCBzZWxfbW91c2UpO1xcbiAgICBzdGFydFNlbCA9IGRvYy5zZWw7XFxuICB9IGVsc2UgaWYgKG91ckluZGV4ID09IC0xKSB7XFxuICAgIG91ckluZGV4ID0gcmFuZ2VzLmxlbmd0aDtcXG4gICAgc2V0U2VsZWN0aW9uKGRvYywgbm9ybWFsaXplU2VsZWN0aW9uKHJhbmdlcy5jb25jYXQoW291clJhbmdlXSksIG91ckluZGV4KSxcXG4gICAgICAgICAgICAgICAgIHtzY3JvbGw6IGZhbHNlLCBvcmlnaW46IFxcXCIqbW91c2VcXFwifSk7XFxuICB9IGVsc2UgaWYgKHJhbmdlcy5sZW5ndGggPiAxICYmIHJhbmdlc1tvdXJJbmRleF0uZW1wdHkoKSAmJiB0eXBlID09IFxcXCJzaW5nbGVcXFwiICYmICFlLnNoaWZ0S2V5KSB7XFxuICAgIHNldFNlbGVjdGlvbihkb2MsIG5vcm1hbGl6ZVNlbGVjdGlvbihyYW5nZXMuc2xpY2UoMCwgb3VySW5kZXgpLmNvbmNhdChyYW5nZXMuc2xpY2Uob3VySW5kZXggKyAxKSksIDApLFxcbiAgICAgICAgICAgICAgICAge3Njcm9sbDogZmFsc2UsIG9yaWdpbjogXFxcIiptb3VzZVxcXCJ9KTtcXG4gICAgc3RhcnRTZWwgPSBkb2Muc2VsO1xcbiAgfSBlbHNlIHtcXG4gICAgcmVwbGFjZU9uZVNlbGVjdGlvbihkb2MsIG91ckluZGV4LCBvdXJSYW5nZSwgc2VsX21vdXNlKTtcXG4gIH1cXG5cXG4gIHZhciBsYXN0UG9zID0gc3RhcnQ7XFxuICBmdW5jdGlvbiBleHRlbmRUbyhwb3MpIHtcXG4gICAgaWYgKGNtcChsYXN0UG9zLCBwb3MpID09IDApIHsgcmV0dXJuIH1cXG4gICAgbGFzdFBvcyA9IHBvcztcXG5cXG4gICAgaWYgKHR5cGUgPT0gXFxcInJlY3RcXFwiKSB7XFxuICAgICAgdmFyIHJhbmdlcyA9IFtdLCB0YWJTaXplID0gY20ub3B0aW9ucy50YWJTaXplO1xcbiAgICAgIHZhciBzdGFydENvbCA9IGNvdW50Q29sdW1uKGdldExpbmUoZG9jLCBzdGFydC5saW5lKS50ZXh0LCBzdGFydC5jaCwgdGFiU2l6ZSk7XFxuICAgICAgdmFyIHBvc0NvbCA9IGNvdW50Q29sdW1uKGdldExpbmUoZG9jLCBwb3MubGluZSkudGV4dCwgcG9zLmNoLCB0YWJTaXplKTtcXG4gICAgICB2YXIgbGVmdCA9IE1hdGgubWluKHN0YXJ0Q29sLCBwb3NDb2wpLCByaWdodCA9IE1hdGgubWF4KHN0YXJ0Q29sLCBwb3NDb2wpO1xcbiAgICAgIGZvciAodmFyIGxpbmUgPSBNYXRoLm1pbihzdGFydC5saW5lLCBwb3MubGluZSksIGVuZCA9IE1hdGgubWluKGNtLmxhc3RMaW5lKCksIE1hdGgubWF4KHN0YXJ0LmxpbmUsIHBvcy5saW5lKSk7XFxuICAgICAgICAgICBsaW5lIDw9IGVuZDsgbGluZSsrKSB7XFxuICAgICAgICB2YXIgdGV4dCA9IGdldExpbmUoZG9jLCBsaW5lKS50ZXh0LCBsZWZ0UG9zID0gZmluZENvbHVtbih0ZXh0LCBsZWZ0LCB0YWJTaXplKTtcXG4gICAgICAgIGlmIChsZWZ0ID09IHJpZ2h0KVxcbiAgICAgICAgICB7IHJhbmdlcy5wdXNoKG5ldyBSYW5nZShQb3MobGluZSwgbGVmdFBvcyksIFBvcyhsaW5lLCBsZWZ0UG9zKSkpOyB9XFxuICAgICAgICBlbHNlIGlmICh0ZXh0Lmxlbmd0aCA+IGxlZnRQb3MpXFxuICAgICAgICAgIHsgcmFuZ2VzLnB1c2gobmV3IFJhbmdlKFBvcyhsaW5lLCBsZWZ0UG9zKSwgUG9zKGxpbmUsIGZpbmRDb2x1bW4odGV4dCwgcmlnaHQsIHRhYlNpemUpKSkpOyB9XFxuICAgICAgfVxcbiAgICAgIGlmICghcmFuZ2VzLmxlbmd0aCkgeyByYW5nZXMucHVzaChuZXcgUmFuZ2Uoc3RhcnQsIHN0YXJ0KSk7IH1cXG4gICAgICBzZXRTZWxlY3Rpb24oZG9jLCBub3JtYWxpemVTZWxlY3Rpb24oc3RhcnRTZWwucmFuZ2VzLnNsaWNlKDAsIG91ckluZGV4KS5jb25jYXQocmFuZ2VzKSwgb3VySW5kZXgpLFxcbiAgICAgICAgICAgICAgICAgICB7b3JpZ2luOiBcXFwiKm1vdXNlXFxcIiwgc2Nyb2xsOiBmYWxzZX0pO1xcbiAgICAgIGNtLnNjcm9sbEludG9WaWV3KHBvcyk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgdmFyIG9sZFJhbmdlID0gb3VyUmFuZ2U7XFxuICAgICAgdmFyIGFuY2hvciA9IG9sZFJhbmdlLmFuY2hvciwgaGVhZCA9IHBvcztcXG4gICAgICBpZiAodHlwZSAhPSBcXFwic2luZ2xlXFxcIikge1xcbiAgICAgICAgdmFyIHJhbmdlJCQxO1xcbiAgICAgICAgaWYgKHR5cGUgPT0gXFxcImRvdWJsZVxcXCIpXFxuICAgICAgICAgIHsgcmFuZ2UkJDEgPSBjbS5maW5kV29yZEF0KHBvcyk7IH1cXG4gICAgICAgIGVsc2VcXG4gICAgICAgICAgeyByYW5nZSQkMSA9IG5ldyBSYW5nZShQb3MocG9zLmxpbmUsIDApLCBjbGlwUG9zKGRvYywgUG9zKHBvcy5saW5lICsgMSwgMCkpKTsgfVxcbiAgICAgICAgaWYgKGNtcChyYW5nZSQkMS5hbmNob3IsIGFuY2hvcikgPiAwKSB7XFxuICAgICAgICAgIGhlYWQgPSByYW5nZSQkMS5oZWFkO1xcbiAgICAgICAgICBhbmNob3IgPSBtaW5Qb3Mob2xkUmFuZ2UuZnJvbSgpLCByYW5nZSQkMS5hbmNob3IpO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgaGVhZCA9IHJhbmdlJCQxLmFuY2hvcjtcXG4gICAgICAgICAgYW5jaG9yID0gbWF4UG9zKG9sZFJhbmdlLnRvKCksIHJhbmdlJCQxLmhlYWQpO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgICB2YXIgcmFuZ2VzJDEgPSBzdGFydFNlbC5yYW5nZXMuc2xpY2UoMCk7XFxuICAgICAgcmFuZ2VzJDFbb3VySW5kZXhdID0gbmV3IFJhbmdlKGNsaXBQb3MoZG9jLCBhbmNob3IpLCBoZWFkKTtcXG4gICAgICBzZXRTZWxlY3Rpb24oZG9jLCBub3JtYWxpemVTZWxlY3Rpb24ocmFuZ2VzJDEsIG91ckluZGV4KSwgc2VsX21vdXNlKTtcXG4gICAgfVxcbiAgfVxcblxcbiAgdmFyIGVkaXRvclNpemUgPSBkaXNwbGF5LndyYXBwZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XFxuICAvLyBVc2VkIHRvIGVuc3VyZSB0aW1lb3V0IHJlLXRyaWVzIGRvbid0IGZpcmUgd2hlbiBhbm90aGVyIGV4dGVuZFxcbiAgLy8gaGFwcGVuZWQgaW4gdGhlIG1lYW50aW1lIChjbGVhclRpbWVvdXQgaXNuJ3QgcmVsaWFibGUgLS0gYXRcXG4gIC8vIGxlYXN0IG9uIENocm9tZSwgdGhlIHRpbWVvdXRzIHN0aWxsIGhhcHBlbiBldmVuIHdoZW4gY2xlYXJlZCxcXG4gIC8vIGlmIHRoZSBjbGVhciBoYXBwZW5zIGFmdGVyIHRoZWlyIHNjaGVkdWxlZCBmaXJpbmcgdGltZSkuXFxuICB2YXIgY291bnRlciA9IDA7XFxuXFxuICBmdW5jdGlvbiBleHRlbmQoZSkge1xcbiAgICB2YXIgY3VyQ291bnQgPSArK2NvdW50ZXI7XFxuICAgIHZhciBjdXIgPSBwb3NGcm9tTW91c2UoY20sIGUsIHRydWUsIHR5cGUgPT0gXFxcInJlY3RcXFwiKTtcXG4gICAgaWYgKCFjdXIpIHsgcmV0dXJuIH1cXG4gICAgaWYgKGNtcChjdXIsIGxhc3RQb3MpICE9IDApIHtcXG4gICAgICBjbS5jdXJPcC5mb2N1cyA9IGFjdGl2ZUVsdCgpO1xcbiAgICAgIGV4dGVuZFRvKGN1cik7XFxuICAgICAgdmFyIHZpc2libGUgPSB2aXNpYmxlTGluZXMoZGlzcGxheSwgZG9jKTtcXG4gICAgICBpZiAoY3VyLmxpbmUgPj0gdmlzaWJsZS50byB8fCBjdXIubGluZSA8IHZpc2libGUuZnJvbSlcXG4gICAgICAgIHsgc2V0VGltZW91dChvcGVyYXRpb24oY20sIGZ1bmN0aW9uICgpIHtpZiAoY291bnRlciA9PSBjdXJDb3VudCkgeyBleHRlbmQoZSk7IH19KSwgMTUwKTsgfVxcbiAgICB9IGVsc2Uge1xcbiAgICAgIHZhciBvdXRzaWRlID0gZS5jbGllbnRZIDwgZWRpdG9yU2l6ZS50b3AgPyAtMjAgOiBlLmNsaWVudFkgPiBlZGl0b3JTaXplLmJvdHRvbSA/IDIwIDogMDtcXG4gICAgICBpZiAob3V0c2lkZSkgeyBzZXRUaW1lb3V0KG9wZXJhdGlvbihjbSwgZnVuY3Rpb24gKCkge1xcbiAgICAgICAgaWYgKGNvdW50ZXIgIT0gY3VyQ291bnQpIHsgcmV0dXJuIH1cXG4gICAgICAgIGRpc3BsYXkuc2Nyb2xsZXIuc2Nyb2xsVG9wICs9IG91dHNpZGU7XFxuICAgICAgICBleHRlbmQoZSk7XFxuICAgICAgfSksIDUwKTsgfVxcbiAgICB9XFxuICB9XFxuXFxuICBmdW5jdGlvbiBkb25lKGUpIHtcXG4gICAgY20uc3RhdGUuc2VsZWN0aW5nVGV4dCA9IGZhbHNlO1xcbiAgICBjb3VudGVyID0gSW5maW5pdHk7XFxuICAgIGVfcHJldmVudERlZmF1bHQoZSk7XFxuICAgIGRpc3BsYXkuaW5wdXQuZm9jdXMoKTtcXG4gICAgb2ZmKGRvY3VtZW50LCBcXFwibW91c2Vtb3ZlXFxcIiwgbW92ZSk7XFxuICAgIG9mZihkb2N1bWVudCwgXFxcIm1vdXNldXBcXFwiLCB1cCk7XFxuICAgIGRvYy5oaXN0b3J5Lmxhc3RTZWxPcmlnaW4gPSBudWxsO1xcbiAgfVxcblxcbiAgdmFyIG1vdmUgPSBvcGVyYXRpb24oY20sIGZ1bmN0aW9uIChlKSB7XFxuICAgIGlmICghZV9idXR0b24oZSkpIHsgZG9uZShlKTsgfVxcbiAgICBlbHNlIHsgZXh0ZW5kKGUpOyB9XFxuICB9KTtcXG4gIHZhciB1cCA9IG9wZXJhdGlvbihjbSwgZG9uZSk7XFxuICBjbS5zdGF0ZS5zZWxlY3RpbmdUZXh0ID0gdXA7XFxuICBvbihkb2N1bWVudCwgXFxcIm1vdXNlbW92ZVxcXCIsIG1vdmUpO1xcbiAgb24oZG9jdW1lbnQsIFxcXCJtb3VzZXVwXFxcIiwgdXApO1xcbn1cXG5cXG5cXG4vLyBEZXRlcm1pbmVzIHdoZXRoZXIgYW4gZXZlbnQgaGFwcGVuZWQgaW4gdGhlIGd1dHRlciwgYW5kIGZpcmVzIHRoZVxcbi8vIGhhbmRsZXJzIGZvciB0aGUgY29ycmVzcG9uZGluZyBldmVudC5cXG5mdW5jdGlvbiBndXR0ZXJFdmVudChjbSwgZSwgdHlwZSwgcHJldmVudCkge1xcbiAgdmFyIG1YLCBtWTtcXG4gIHRyeSB7IG1YID0gZS5jbGllbnRYOyBtWSA9IGUuY2xpZW50WTsgfVxcbiAgY2F0Y2goZSkgeyByZXR1cm4gZmFsc2UgfVxcbiAgaWYgKG1YID49IE1hdGguZmxvb3IoY20uZGlzcGxheS5ndXR0ZXJzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnJpZ2h0KSkgeyByZXR1cm4gZmFsc2UgfVxcbiAgaWYgKHByZXZlbnQpIHsgZV9wcmV2ZW50RGVmYXVsdChlKTsgfVxcblxcbiAgdmFyIGRpc3BsYXkgPSBjbS5kaXNwbGF5O1xcbiAgdmFyIGxpbmVCb3ggPSBkaXNwbGF5LmxpbmVEaXYuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XFxuXFxuICBpZiAobVkgPiBsaW5lQm94LmJvdHRvbSB8fCAhaGFzSGFuZGxlcihjbSwgdHlwZSkpIHsgcmV0dXJuIGVfZGVmYXVsdFByZXZlbnRlZChlKSB9XFxuICBtWSAtPSBsaW5lQm94LnRvcCAtIGRpc3BsYXkudmlld09mZnNldDtcXG5cXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY20ub3B0aW9ucy5ndXR0ZXJzLmxlbmd0aDsgKytpKSB7XFxuICAgIHZhciBnID0gZGlzcGxheS5ndXR0ZXJzLmNoaWxkTm9kZXNbaV07XFxuICAgIGlmIChnICYmIGcuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkucmlnaHQgPj0gbVgpIHtcXG4gICAgICB2YXIgbGluZSA9IGxpbmVBdEhlaWdodChjbS5kb2MsIG1ZKTtcXG4gICAgICB2YXIgZ3V0dGVyID0gY20ub3B0aW9ucy5ndXR0ZXJzW2ldO1xcbiAgICAgIHNpZ25hbChjbSwgdHlwZSwgY20sIGxpbmUsIGd1dHRlciwgZSk7XFxuICAgICAgcmV0dXJuIGVfZGVmYXVsdFByZXZlbnRlZChlKVxcbiAgICB9XFxuICB9XFxufVxcblxcbmZ1bmN0aW9uIGNsaWNrSW5HdXR0ZXIoY20sIGUpIHtcXG4gIHJldHVybiBndXR0ZXJFdmVudChjbSwgZSwgXFxcImd1dHRlckNsaWNrXFxcIiwgdHJ1ZSlcXG59XFxuXFxuLy8gQ09OVEVYVCBNRU5VIEhBTkRMSU5HXFxuXFxuLy8gVG8gbWFrZSB0aGUgY29udGV4dCBtZW51IHdvcmssIHdlIG5lZWQgdG8gYnJpZWZseSB1bmhpZGUgdGhlXFxuLy8gdGV4dGFyZWEgKG1ha2luZyBpdCBhcyB1bm9idHJ1c2l2ZSBhcyBwb3NzaWJsZSkgdG8gbGV0IHRoZVxcbi8vIHJpZ2h0LWNsaWNrIHRha2UgZWZmZWN0IG9uIGl0LlxcbmZ1bmN0aW9uIG9uQ29udGV4dE1lbnUoY20sIGUpIHtcXG4gIGlmIChldmVudEluV2lkZ2V0KGNtLmRpc3BsYXksIGUpIHx8IGNvbnRleHRNZW51SW5HdXR0ZXIoY20sIGUpKSB7IHJldHVybiB9XFxuICBpZiAoc2lnbmFsRE9NRXZlbnQoY20sIGUsIFxcXCJjb250ZXh0bWVudVxcXCIpKSB7IHJldHVybiB9XFxuICBjbS5kaXNwbGF5LmlucHV0Lm9uQ29udGV4dE1lbnUoZSk7XFxufVxcblxcbmZ1bmN0aW9uIGNvbnRleHRNZW51SW5HdXR0ZXIoY20sIGUpIHtcXG4gIGlmICghaGFzSGFuZGxlcihjbSwgXFxcImd1dHRlckNvbnRleHRNZW51XFxcIikpIHsgcmV0dXJuIGZhbHNlIH1cXG4gIHJldHVybiBndXR0ZXJFdmVudChjbSwgZSwgXFxcImd1dHRlckNvbnRleHRNZW51XFxcIiwgZmFsc2UpXFxufVxcblxcbmZ1bmN0aW9uIHRoZW1lQ2hhbmdlZChjbSkge1xcbiAgY20uZGlzcGxheS53cmFwcGVyLmNsYXNzTmFtZSA9IGNtLmRpc3BsYXkud3JhcHBlci5jbGFzc05hbWUucmVwbGFjZSgvXFxcXHMqY20tcy1cXFxcUysvZywgXFxcIlxcXCIpICtcXG4gICAgY20ub3B0aW9ucy50aGVtZS5yZXBsYWNlKC8oXnxcXFxccylcXFxccyovZywgXFxcIiBjbS1zLVxcXCIpO1xcbiAgY2xlYXJDYWNoZXMoY20pO1xcbn1cXG5cXG52YXIgSW5pdCA9IHt0b1N0cmluZzogZnVuY3Rpb24oKXtyZXR1cm4gXFxcIkNvZGVNaXJyb3IuSW5pdFxcXCJ9fTtcXG5cXG52YXIgZGVmYXVsdHMgPSB7fTtcXG52YXIgb3B0aW9uSGFuZGxlcnMgPSB7fTtcXG5cXG5mdW5jdGlvbiBkZWZpbmVPcHRpb25zKENvZGVNaXJyb3IpIHtcXG4gIHZhciBvcHRpb25IYW5kbGVycyA9IENvZGVNaXJyb3Iub3B0aW9uSGFuZGxlcnM7XFxuXFxuICBmdW5jdGlvbiBvcHRpb24obmFtZSwgZGVmbHQsIGhhbmRsZSwgbm90T25Jbml0KSB7XFxuICAgIENvZGVNaXJyb3IuZGVmYXVsdHNbbmFtZV0gPSBkZWZsdDtcXG4gICAgaWYgKGhhbmRsZSkgeyBvcHRpb25IYW5kbGVyc1tuYW1lXSA9XFxuICAgICAgbm90T25Jbml0ID8gZnVuY3Rpb24gKGNtLCB2YWwsIG9sZCkge2lmIChvbGQgIT0gSW5pdCkgeyBoYW5kbGUoY20sIHZhbCwgb2xkKTsgfX0gOiBoYW5kbGU7IH1cXG4gIH1cXG5cXG4gIENvZGVNaXJyb3IuZGVmaW5lT3B0aW9uID0gb3B0aW9uO1xcblxcbiAgLy8gUGFzc2VkIHRvIG9wdGlvbiBoYW5kbGVycyB3aGVuIHRoZXJlIGlzIG5vIG9sZCB2YWx1ZS5cXG4gIENvZGVNaXJyb3IuSW5pdCA9IEluaXQ7XFxuXFxuICAvLyBUaGVzZSB0d28gYXJlLCBvbiBpbml0LCBjYWxsZWQgZnJvbSB0aGUgY29uc3RydWN0b3IgYmVjYXVzZSB0aGV5XFxuICAvLyBoYXZlIHRvIGJlIGluaXRpYWxpemVkIGJlZm9yZSB0aGUgZWRpdG9yIGNhbiBzdGFydCBhdCBhbGwuXFxuICBvcHRpb24oXFxcInZhbHVlXFxcIiwgXFxcIlxcXCIsIGZ1bmN0aW9uIChjbSwgdmFsKSB7IHJldHVybiBjbS5zZXRWYWx1ZSh2YWwpOyB9LCB0cnVlKTtcXG4gIG9wdGlvbihcXFwibW9kZVxcXCIsIG51bGwsIGZ1bmN0aW9uIChjbSwgdmFsKSB7XFxuICAgIGNtLmRvYy5tb2RlT3B0aW9uID0gdmFsO1xcbiAgICBsb2FkTW9kZShjbSk7XFxuICB9LCB0cnVlKTtcXG5cXG4gIG9wdGlvbihcXFwiaW5kZW50VW5pdFxcXCIsIDIsIGxvYWRNb2RlLCB0cnVlKTtcXG4gIG9wdGlvbihcXFwiaW5kZW50V2l0aFRhYnNcXFwiLCBmYWxzZSk7XFxuICBvcHRpb24oXFxcInNtYXJ0SW5kZW50XFxcIiwgdHJ1ZSk7XFxuICBvcHRpb24oXFxcInRhYlNpemVcXFwiLCA0LCBmdW5jdGlvbiAoY20pIHtcXG4gICAgcmVzZXRNb2RlU3RhdGUoY20pO1xcbiAgICBjbGVhckNhY2hlcyhjbSk7XFxuICAgIHJlZ0NoYW5nZShjbSk7XFxuICB9LCB0cnVlKTtcXG4gIG9wdGlvbihcXFwibGluZVNlcGFyYXRvclxcXCIsIG51bGwsIGZ1bmN0aW9uIChjbSwgdmFsKSB7XFxuICAgIGNtLmRvYy5saW5lU2VwID0gdmFsO1xcbiAgICBpZiAoIXZhbCkgeyByZXR1cm4gfVxcbiAgICB2YXIgbmV3QnJlYWtzID0gW10sIGxpbmVObyA9IGNtLmRvYy5maXJzdDtcXG4gICAgY20uZG9jLml0ZXIoZnVuY3Rpb24gKGxpbmUpIHtcXG4gICAgICBmb3IgKHZhciBwb3MgPSAwOzspIHtcXG4gICAgICAgIHZhciBmb3VuZCA9IGxpbmUudGV4dC5pbmRleE9mKHZhbCwgcG9zKTtcXG4gICAgICAgIGlmIChmb3VuZCA9PSAtMSkgeyBicmVhayB9XFxuICAgICAgICBwb3MgPSBmb3VuZCArIHZhbC5sZW5ndGg7XFxuICAgICAgICBuZXdCcmVha3MucHVzaChQb3MobGluZU5vLCBmb3VuZCkpO1xcbiAgICAgIH1cXG4gICAgICBsaW5lTm8rKztcXG4gICAgfSk7XFxuICAgIGZvciAodmFyIGkgPSBuZXdCcmVha3MubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pXFxuICAgICAgeyByZXBsYWNlUmFuZ2UoY20uZG9jLCB2YWwsIG5ld0JyZWFrc1tpXSwgUG9zKG5ld0JyZWFrc1tpXS5saW5lLCBuZXdCcmVha3NbaV0uY2ggKyB2YWwubGVuZ3RoKSk7IH1cXG4gIH0pO1xcbiAgb3B0aW9uKFxcXCJzcGVjaWFsQ2hhcnNcXFwiLCAvW1xcXFx1MDAwMC1cXFxcdTAwMWZcXFxcdTAwN2YtXFxcXHUwMDlmXFxcXHUwMGFkXFxcXHUwNjFjXFxcXHUyMDBiLVxcXFx1MjAwZlxcXFx1MjAyOFxcXFx1MjAyOVxcXFx1ZmVmZl0vZywgZnVuY3Rpb24gKGNtLCB2YWwsIG9sZCkge1xcbiAgICBjbS5zdGF0ZS5zcGVjaWFsQ2hhcnMgPSBuZXcgUmVnRXhwKHZhbC5zb3VyY2UgKyAodmFsLnRlc3QoXFxcIlxcXFx0XFxcIikgPyBcXFwiXFxcIiA6IFxcXCJ8XFxcXHRcXFwiKSwgXFxcImdcXFwiKTtcXG4gICAgaWYgKG9sZCAhPSBJbml0KSB7IGNtLnJlZnJlc2goKTsgfVxcbiAgfSk7XFxuICBvcHRpb24oXFxcInNwZWNpYWxDaGFyUGxhY2Vob2xkZXJcXFwiLCBkZWZhdWx0U3BlY2lhbENoYXJQbGFjZWhvbGRlciwgZnVuY3Rpb24gKGNtKSB7IHJldHVybiBjbS5yZWZyZXNoKCk7IH0sIHRydWUpO1xcbiAgb3B0aW9uKFxcXCJlbGVjdHJpY0NoYXJzXFxcIiwgdHJ1ZSk7XFxuICBvcHRpb24oXFxcImlucHV0U3R5bGVcXFwiLCBtb2JpbGUgPyBcXFwiY29udGVudGVkaXRhYmxlXFxcIiA6IFxcXCJ0ZXh0YXJlYVxcXCIsIGZ1bmN0aW9uICgpIHtcXG4gICAgdGhyb3cgbmV3IEVycm9yKFxcXCJpbnB1dFN0eWxlIGNhbiBub3QgKHlldCkgYmUgY2hhbmdlZCBpbiBhIHJ1bm5pbmcgZWRpdG9yXFxcIikgLy8gRklYTUVcXG4gIH0sIHRydWUpO1xcbiAgb3B0aW9uKFxcXCJzcGVsbGNoZWNrXFxcIiwgZmFsc2UsIGZ1bmN0aW9uIChjbSwgdmFsKSB7IHJldHVybiBjbS5nZXRJbnB1dEZpZWxkKCkuc3BlbGxjaGVjayA9IHZhbDsgfSwgdHJ1ZSk7XFxuICBvcHRpb24oXFxcInJ0bE1vdmVWaXN1YWxseVxcXCIsICF3aW5kb3dzKTtcXG4gIG9wdGlvbihcXFwid2hvbGVMaW5lVXBkYXRlQmVmb3JlXFxcIiwgdHJ1ZSk7XFxuXFxuICBvcHRpb24oXFxcInRoZW1lXFxcIiwgXFxcImRlZmF1bHRcXFwiLCBmdW5jdGlvbiAoY20pIHtcXG4gICAgdGhlbWVDaGFuZ2VkKGNtKTtcXG4gICAgZ3V0dGVyc0NoYW5nZWQoY20pO1xcbiAgfSwgdHJ1ZSk7XFxuICBvcHRpb24oXFxcImtleU1hcFxcXCIsIFxcXCJkZWZhdWx0XFxcIiwgZnVuY3Rpb24gKGNtLCB2YWwsIG9sZCkge1xcbiAgICB2YXIgbmV4dCA9IGdldEtleU1hcCh2YWwpO1xcbiAgICB2YXIgcHJldiA9IG9sZCAhPSBJbml0ICYmIGdldEtleU1hcChvbGQpO1xcbiAgICBpZiAocHJldiAmJiBwcmV2LmRldGFjaCkgeyBwcmV2LmRldGFjaChjbSwgbmV4dCk7IH1cXG4gICAgaWYgKG5leHQuYXR0YWNoKSB7IG5leHQuYXR0YWNoKGNtLCBwcmV2IHx8IG51bGwpOyB9XFxuICB9KTtcXG4gIG9wdGlvbihcXFwiZXh0cmFLZXlzXFxcIiwgbnVsbCk7XFxuXFxuICBvcHRpb24oXFxcImxpbmVXcmFwcGluZ1xcXCIsIGZhbHNlLCB3cmFwcGluZ0NoYW5nZWQsIHRydWUpO1xcbiAgb3B0aW9uKFxcXCJndXR0ZXJzXFxcIiwgW10sIGZ1bmN0aW9uIChjbSkge1xcbiAgICBzZXRHdXR0ZXJzRm9yTGluZU51bWJlcnMoY20ub3B0aW9ucyk7XFxuICAgIGd1dHRlcnNDaGFuZ2VkKGNtKTtcXG4gIH0sIHRydWUpO1xcbiAgb3B0aW9uKFxcXCJmaXhlZEd1dHRlclxcXCIsIHRydWUsIGZ1bmN0aW9uIChjbSwgdmFsKSB7XFxuICAgIGNtLmRpc3BsYXkuZ3V0dGVycy5zdHlsZS5sZWZ0ID0gdmFsID8gY29tcGVuc2F0ZUZvckhTY3JvbGwoY20uZGlzcGxheSkgKyBcXFwicHhcXFwiIDogXFxcIjBcXFwiO1xcbiAgICBjbS5yZWZyZXNoKCk7XFxuICB9LCB0cnVlKTtcXG4gIG9wdGlvbihcXFwiY292ZXJHdXR0ZXJOZXh0VG9TY3JvbGxiYXJcXFwiLCBmYWxzZSwgZnVuY3Rpb24gKGNtKSB7IHJldHVybiB1cGRhdGVTY3JvbGxiYXJzKGNtKTsgfSwgdHJ1ZSk7XFxuICBvcHRpb24oXFxcInNjcm9sbGJhclN0eWxlXFxcIiwgXFxcIm5hdGl2ZVxcXCIsIGZ1bmN0aW9uIChjbSkge1xcbiAgICBpbml0U2Nyb2xsYmFycyhjbSk7XFxuICAgIHVwZGF0ZVNjcm9sbGJhcnMoY20pO1xcbiAgICBjbS5kaXNwbGF5LnNjcm9sbGJhcnMuc2V0U2Nyb2xsVG9wKGNtLmRvYy5zY3JvbGxUb3ApO1xcbiAgICBjbS5kaXNwbGF5LnNjcm9sbGJhcnMuc2V0U2Nyb2xsTGVmdChjbS5kb2Muc2Nyb2xsTGVmdCk7XFxuICB9LCB0cnVlKTtcXG4gIG9wdGlvbihcXFwibGluZU51bWJlcnNcXFwiLCBmYWxzZSwgZnVuY3Rpb24gKGNtKSB7XFxuICAgIHNldEd1dHRlcnNGb3JMaW5lTnVtYmVycyhjbS5vcHRpb25zKTtcXG4gICAgZ3V0dGVyc0NoYW5nZWQoY20pO1xcbiAgfSwgdHJ1ZSk7XFxuICBvcHRpb24oXFxcImZpcnN0TGluZU51bWJlclxcXCIsIDEsIGd1dHRlcnNDaGFuZ2VkLCB0cnVlKTtcXG4gIG9wdGlvbihcXFwibGluZU51bWJlckZvcm1hdHRlclxcXCIsIGZ1bmN0aW9uIChpbnRlZ2VyKSB7IHJldHVybiBpbnRlZ2VyOyB9LCBndXR0ZXJzQ2hhbmdlZCwgdHJ1ZSk7XFxuICBvcHRpb24oXFxcInNob3dDdXJzb3JXaGVuU2VsZWN0aW5nXFxcIiwgZmFsc2UsIHVwZGF0ZVNlbGVjdGlvbiwgdHJ1ZSk7XFxuXFxuICBvcHRpb24oXFxcInJlc2V0U2VsZWN0aW9uT25Db250ZXh0TWVudVxcXCIsIHRydWUpO1xcbiAgb3B0aW9uKFxcXCJsaW5lV2lzZUNvcHlDdXRcXFwiLCB0cnVlKTtcXG5cXG4gIG9wdGlvbihcXFwicmVhZE9ubHlcXFwiLCBmYWxzZSwgZnVuY3Rpb24gKGNtLCB2YWwpIHtcXG4gICAgaWYgKHZhbCA9PSBcXFwibm9jdXJzb3JcXFwiKSB7XFxuICAgICAgb25CbHVyKGNtKTtcXG4gICAgICBjbS5kaXNwbGF5LmlucHV0LmJsdXIoKTtcXG4gICAgICBjbS5kaXNwbGF5LmRpc2FibGVkID0gdHJ1ZTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICBjbS5kaXNwbGF5LmRpc2FibGVkID0gZmFsc2U7XFxuICAgIH1cXG4gICAgY20uZGlzcGxheS5pbnB1dC5yZWFkT25seUNoYW5nZWQodmFsKTtcXG4gIH0pO1xcbiAgb3B0aW9uKFxcXCJkaXNhYmxlSW5wdXRcXFwiLCBmYWxzZSwgZnVuY3Rpb24gKGNtLCB2YWwpIHtpZiAoIXZhbCkgeyBjbS5kaXNwbGF5LmlucHV0LnJlc2V0KCk7IH19LCB0cnVlKTtcXG4gIG9wdGlvbihcXFwiZHJhZ0Ryb3BcXFwiLCB0cnVlLCBkcmFnRHJvcENoYW5nZWQpO1xcbiAgb3B0aW9uKFxcXCJhbGxvd0Ryb3BGaWxlVHlwZXNcXFwiLCBudWxsKTtcXG5cXG4gIG9wdGlvbihcXFwiY3Vyc29yQmxpbmtSYXRlXFxcIiwgNTMwKTtcXG4gIG9wdGlvbihcXFwiY3Vyc29yU2Nyb2xsTWFyZ2luXFxcIiwgMCk7XFxuICBvcHRpb24oXFxcImN1cnNvckhlaWdodFxcXCIsIDEsIHVwZGF0ZVNlbGVjdGlvbiwgdHJ1ZSk7XFxuICBvcHRpb24oXFxcInNpbmdsZUN1cnNvckhlaWdodFBlckxpbmVcXFwiLCB0cnVlLCB1cGRhdGVTZWxlY3Rpb24sIHRydWUpO1xcbiAgb3B0aW9uKFxcXCJ3b3JrVGltZVxcXCIsIDEwMCk7XFxuICBvcHRpb24oXFxcIndvcmtEZWxheVxcXCIsIDEwMCk7XFxuICBvcHRpb24oXFxcImZsYXR0ZW5TcGFuc1xcXCIsIHRydWUsIHJlc2V0TW9kZVN0YXRlLCB0cnVlKTtcXG4gIG9wdGlvbihcXFwiYWRkTW9kZUNsYXNzXFxcIiwgZmFsc2UsIHJlc2V0TW9kZVN0YXRlLCB0cnVlKTtcXG4gIG9wdGlvbihcXFwicG9sbEludGVydmFsXFxcIiwgMTAwKTtcXG4gIG9wdGlvbihcXFwidW5kb0RlcHRoXFxcIiwgMjAwLCBmdW5jdGlvbiAoY20sIHZhbCkgeyByZXR1cm4gY20uZG9jLmhpc3RvcnkudW5kb0RlcHRoID0gdmFsOyB9KTtcXG4gIG9wdGlvbihcXFwiaGlzdG9yeUV2ZW50RGVsYXlcXFwiLCAxMjUwKTtcXG4gIG9wdGlvbihcXFwidmlld3BvcnRNYXJnaW5cXFwiLCAxMCwgZnVuY3Rpb24gKGNtKSB7IHJldHVybiBjbS5yZWZyZXNoKCk7IH0sIHRydWUpO1xcbiAgb3B0aW9uKFxcXCJtYXhIaWdobGlnaHRMZW5ndGhcXFwiLCAxMDAwMCwgcmVzZXRNb2RlU3RhdGUsIHRydWUpO1xcbiAgb3B0aW9uKFxcXCJtb3ZlSW5wdXRXaXRoQ3Vyc29yXFxcIiwgdHJ1ZSwgZnVuY3Rpb24gKGNtLCB2YWwpIHtcXG4gICAgaWYgKCF2YWwpIHsgY20uZGlzcGxheS5pbnB1dC5yZXNldFBvc2l0aW9uKCk7IH1cXG4gIH0pO1xcblxcbiAgb3B0aW9uKFxcXCJ0YWJpbmRleFxcXCIsIG51bGwsIGZ1bmN0aW9uIChjbSwgdmFsKSB7IHJldHVybiBjbS5kaXNwbGF5LmlucHV0LmdldEZpZWxkKCkudGFiSW5kZXggPSB2YWwgfHwgXFxcIlxcXCI7IH0pO1xcbiAgb3B0aW9uKFxcXCJhdXRvZm9jdXNcXFwiLCBudWxsKTtcXG4gIG9wdGlvbihcXFwiZGlyZWN0aW9uXFxcIiwgXFxcImx0clxcXCIsIGZ1bmN0aW9uIChjbSwgdmFsKSB7IHJldHVybiBjbS5kb2Muc2V0RGlyZWN0aW9uKHZhbCk7IH0sIHRydWUpO1xcbn1cXG5cXG5mdW5jdGlvbiBndXR0ZXJzQ2hhbmdlZChjbSkge1xcbiAgdXBkYXRlR3V0dGVycyhjbSk7XFxuICByZWdDaGFuZ2UoY20pO1xcbiAgYWxpZ25Ib3Jpem9udGFsbHkoY20pO1xcbn1cXG5cXG5mdW5jdGlvbiBkcmFnRHJvcENoYW5nZWQoY20sIHZhbHVlLCBvbGQpIHtcXG4gIHZhciB3YXNPbiA9IG9sZCAmJiBvbGQgIT0gSW5pdDtcXG4gIGlmICghdmFsdWUgIT0gIXdhc09uKSB7XFxuICAgIHZhciBmdW5jcyA9IGNtLmRpc3BsYXkuZHJhZ0Z1bmN0aW9ucztcXG4gICAgdmFyIHRvZ2dsZSA9IHZhbHVlID8gb24gOiBvZmY7XFxuICAgIHRvZ2dsZShjbS5kaXNwbGF5LnNjcm9sbGVyLCBcXFwiZHJhZ3N0YXJ0XFxcIiwgZnVuY3Muc3RhcnQpO1xcbiAgICB0b2dnbGUoY20uZGlzcGxheS5zY3JvbGxlciwgXFxcImRyYWdlbnRlclxcXCIsIGZ1bmNzLmVudGVyKTtcXG4gICAgdG9nZ2xlKGNtLmRpc3BsYXkuc2Nyb2xsZXIsIFxcXCJkcmFnb3ZlclxcXCIsIGZ1bmNzLm92ZXIpO1xcbiAgICB0b2dnbGUoY20uZGlzcGxheS5zY3JvbGxlciwgXFxcImRyYWdsZWF2ZVxcXCIsIGZ1bmNzLmxlYXZlKTtcXG4gICAgdG9nZ2xlKGNtLmRpc3BsYXkuc2Nyb2xsZXIsIFxcXCJkcm9wXFxcIiwgZnVuY3MuZHJvcCk7XFxuICB9XFxufVxcblxcbmZ1bmN0aW9uIHdyYXBwaW5nQ2hhbmdlZChjbSkge1xcbiAgaWYgKGNtLm9wdGlvbnMubGluZVdyYXBwaW5nKSB7XFxuICAgIGFkZENsYXNzKGNtLmRpc3BsYXkud3JhcHBlciwgXFxcIkNvZGVNaXJyb3Itd3JhcFxcXCIpO1xcbiAgICBjbS5kaXNwbGF5LnNpemVyLnN0eWxlLm1pbldpZHRoID0gXFxcIlxcXCI7XFxuICAgIGNtLmRpc3BsYXkuc2l6ZXJXaWR0aCA9IG51bGw7XFxuICB9IGVsc2Uge1xcbiAgICBybUNsYXNzKGNtLmRpc3BsYXkud3JhcHBlciwgXFxcIkNvZGVNaXJyb3Itd3JhcFxcXCIpO1xcbiAgICBmaW5kTWF4TGluZShjbSk7XFxuICB9XFxuICBlc3RpbWF0ZUxpbmVIZWlnaHRzKGNtKTtcXG4gIHJlZ0NoYW5nZShjbSk7XFxuICBjbGVhckNhY2hlcyhjbSk7XFxuICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIHVwZGF0ZVNjcm9sbGJhcnMoY20pOyB9LCAxMDApO1xcbn1cXG5cXG4vLyBBIENvZGVNaXJyb3IgaW5zdGFuY2UgcmVwcmVzZW50cyBhbiBlZGl0b3IuIFRoaXMgaXMgdGhlIG9iamVjdFxcbi8vIHRoYXQgdXNlciBjb2RlIGlzIHVzdWFsbHkgZGVhbGluZyB3aXRoLlxcblxcbmZ1bmN0aW9uIENvZGVNaXJyb3IkMShwbGFjZSwgb3B0aW9ucykge1xcbiAgdmFyIHRoaXMkMSA9IHRoaXM7XFxuXFxuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgQ29kZU1pcnJvciQxKSkgeyByZXR1cm4gbmV3IENvZGVNaXJyb3IkMShwbGFjZSwgb3B0aW9ucykgfVxcblxcbiAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyA9IG9wdGlvbnMgPyBjb3B5T2JqKG9wdGlvbnMpIDoge307XFxuICAvLyBEZXRlcm1pbmUgZWZmZWN0aXZlIG9wdGlvbnMgYmFzZWQgb24gZ2l2ZW4gdmFsdWVzIGFuZCBkZWZhdWx0cy5cXG4gIGNvcHlPYmooZGVmYXVsdHMsIG9wdGlvbnMsIGZhbHNlKTtcXG4gIHNldEd1dHRlcnNGb3JMaW5lTnVtYmVycyhvcHRpb25zKTtcXG5cXG4gIHZhciBkb2MgPSBvcHRpb25zLnZhbHVlO1xcbiAgaWYgKHR5cGVvZiBkb2MgPT0gXFxcInN0cmluZ1xcXCIpIHsgZG9jID0gbmV3IERvYyhkb2MsIG9wdGlvbnMubW9kZSwgbnVsbCwgb3B0aW9ucy5saW5lU2VwYXJhdG9yLCBvcHRpb25zLmRpcmVjdGlvbik7IH1cXG4gIHRoaXMuZG9jID0gZG9jO1xcblxcbiAgdmFyIGlucHV0ID0gbmV3IENvZGVNaXJyb3IkMS5pbnB1dFN0eWxlc1tvcHRpb25zLmlucHV0U3R5bGVdKHRoaXMpO1xcbiAgdmFyIGRpc3BsYXkgPSB0aGlzLmRpc3BsYXkgPSBuZXcgRGlzcGxheShwbGFjZSwgZG9jLCBpbnB1dCk7XFxuICBkaXNwbGF5LndyYXBwZXIuQ29kZU1pcnJvciA9IHRoaXM7XFxuICB1cGRhdGVHdXR0ZXJzKHRoaXMpO1xcbiAgdGhlbWVDaGFuZ2VkKHRoaXMpO1xcbiAgaWYgKG9wdGlvbnMubGluZVdyYXBwaW5nKVxcbiAgICB7IHRoaXMuZGlzcGxheS53cmFwcGVyLmNsYXNzTmFtZSArPSBcXFwiIENvZGVNaXJyb3Itd3JhcFxcXCI7IH1cXG4gIGluaXRTY3JvbGxiYXJzKHRoaXMpO1xcblxcbiAgdGhpcy5zdGF0ZSA9IHtcXG4gICAga2V5TWFwczogW10sICAvLyBzdG9yZXMgbWFwcyBhZGRlZCBieSBhZGRLZXlNYXBcXG4gICAgb3ZlcmxheXM6IFtdLCAvLyBoaWdobGlnaHRpbmcgb3ZlcmxheXMsIGFzIGFkZGVkIGJ5IGFkZE92ZXJsYXlcXG4gICAgbW9kZUdlbjogMCwgICAvLyBidW1wZWQgd2hlbiBtb2RlL292ZXJsYXkgY2hhbmdlcywgdXNlZCB0byBpbnZhbGlkYXRlIGhpZ2hsaWdodGluZyBpbmZvXFxuICAgIG92ZXJ3cml0ZTogZmFsc2UsXFxuICAgIGRlbGF5aW5nQmx1ckV2ZW50OiBmYWxzZSxcXG4gICAgZm9jdXNlZDogZmFsc2UsXFxuICAgIHN1cHByZXNzRWRpdHM6IGZhbHNlLCAvLyB1c2VkIHRvIGRpc2FibGUgZWRpdGluZyBkdXJpbmcga2V5IGhhbmRsZXJzIHdoZW4gaW4gcmVhZE9ubHkgbW9kZVxcbiAgICBwYXN0ZUluY29taW5nOiBmYWxzZSwgY3V0SW5jb21pbmc6IGZhbHNlLCAvLyBoZWxwIHJlY29nbml6ZSBwYXN0ZS9jdXQgZWRpdHMgaW4gaW5wdXQucG9sbFxcbiAgICBzZWxlY3RpbmdUZXh0OiBmYWxzZSxcXG4gICAgZHJhZ2dpbmdUZXh0OiBmYWxzZSxcXG4gICAgaGlnaGxpZ2h0OiBuZXcgRGVsYXllZCgpLCAvLyBzdG9yZXMgaGlnaGxpZ2h0IHdvcmtlciB0aW1lb3V0XFxuICAgIGtleVNlcTogbnVsbCwgIC8vIFVuZmluaXNoZWQga2V5IHNlcXVlbmNlXFxuICAgIHNwZWNpYWxDaGFyczogbnVsbFxcbiAgfTtcXG5cXG4gIGlmIChvcHRpb25zLmF1dG9mb2N1cyAmJiAhbW9iaWxlKSB7IGRpc3BsYXkuaW5wdXQuZm9jdXMoKTsgfVxcblxcbiAgLy8gT3ZlcnJpZGUgbWFnaWMgdGV4dGFyZWEgY29udGVudCByZXN0b3JlIHRoYXQgSUUgc29tZXRpbWVzIGRvZXNcXG4gIC8vIG9uIG91ciBoaWRkZW4gdGV4dGFyZWEgb24gcmVsb2FkXFxuICBpZiAoaWUgJiYgaWVfdmVyc2lvbiA8IDExKSB7IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcyQxLmRpc3BsYXkuaW5wdXQucmVzZXQodHJ1ZSk7IH0sIDIwKTsgfVxcblxcbiAgcmVnaXN0ZXJFdmVudEhhbmRsZXJzKHRoaXMpO1xcbiAgZW5zdXJlR2xvYmFsSGFuZGxlcnMoKTtcXG5cXG4gIHN0YXJ0T3BlcmF0aW9uKHRoaXMpO1xcbiAgdGhpcy5jdXJPcC5mb3JjZVVwZGF0ZSA9IHRydWU7XFxuICBhdHRhY2hEb2ModGhpcywgZG9jKTtcXG5cXG4gIGlmICgob3B0aW9ucy5hdXRvZm9jdXMgJiYgIW1vYmlsZSkgfHwgdGhpcy5oYXNGb2N1cygpKVxcbiAgICB7IHNldFRpbWVvdXQoYmluZChvbkZvY3VzLCB0aGlzKSwgMjApOyB9XFxuICBlbHNlXFxuICAgIHsgb25CbHVyKHRoaXMpOyB9XFxuXFxuICBmb3IgKHZhciBvcHQgaW4gb3B0aW9uSGFuZGxlcnMpIHsgaWYgKG9wdGlvbkhhbmRsZXJzLmhhc093blByb3BlcnR5KG9wdCkpXFxuICAgIHsgb3B0aW9uSGFuZGxlcnNbb3B0XSh0aGlzJDEsIG9wdGlvbnNbb3B0XSwgSW5pdCk7IH0gfVxcbiAgbWF5YmVVcGRhdGVMaW5lTnVtYmVyV2lkdGgodGhpcyk7XFxuICBpZiAob3B0aW9ucy5maW5pc2hJbml0KSB7IG9wdGlvbnMuZmluaXNoSW5pdCh0aGlzKTsgfVxcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbml0SG9va3MubGVuZ3RoOyArK2kpIHsgaW5pdEhvb2tzW2ldKHRoaXMkMSk7IH1cXG4gIGVuZE9wZXJhdGlvbih0aGlzKTtcXG4gIC8vIFN1cHByZXNzIG9wdGltaXplbGVnaWJpbGl0eSBpbiBXZWJraXQsIHNpbmNlIGl0IGJyZWFrcyB0ZXh0XFxuICAvLyBtZWFzdXJpbmcgb24gbGluZSB3cmFwcGluZyBib3VuZGFyaWVzLlxcbiAgaWYgKHdlYmtpdCAmJiBvcHRpb25zLmxpbmVXcmFwcGluZyAmJlxcbiAgICAgIGdldENvbXB1dGVkU3R5bGUoZGlzcGxheS5saW5lRGl2KS50ZXh0UmVuZGVyaW5nID09IFxcXCJvcHRpbWl6ZWxlZ2liaWxpdHlcXFwiKVxcbiAgICB7IGRpc3BsYXkubGluZURpdi5zdHlsZS50ZXh0UmVuZGVyaW5nID0gXFxcImF1dG9cXFwiOyB9XFxufVxcblxcbi8vIFRoZSBkZWZhdWx0IGNvbmZpZ3VyYXRpb24gb3B0aW9ucy5cXG5Db2RlTWlycm9yJDEuZGVmYXVsdHMgPSBkZWZhdWx0cztcXG4vLyBGdW5jdGlvbnMgdG8gcnVuIHdoZW4gb3B0aW9ucyBhcmUgY2hhbmdlZC5cXG5Db2RlTWlycm9yJDEub3B0aW9uSGFuZGxlcnMgPSBvcHRpb25IYW5kbGVycztcXG5cXG4vLyBBdHRhY2ggdGhlIG5lY2Vzc2FyeSBldmVudCBoYW5kbGVycyB3aGVuIGluaXRpYWxpemluZyB0aGUgZWRpdG9yXFxuZnVuY3Rpb24gcmVnaXN0ZXJFdmVudEhhbmRsZXJzKGNtKSB7XFxuICB2YXIgZCA9IGNtLmRpc3BsYXk7XFxuICBvbihkLnNjcm9sbGVyLCBcXFwibW91c2Vkb3duXFxcIiwgb3BlcmF0aW9uKGNtLCBvbk1vdXNlRG93bikpO1xcbiAgLy8gT2xkZXIgSUUncyB3aWxsIG5vdCBmaXJlIGEgc2Vjb25kIG1vdXNlZG93biBmb3IgYSBkb3VibGUgY2xpY2tcXG4gIGlmIChpZSAmJiBpZV92ZXJzaW9uIDwgMTEpXFxuICAgIHsgb24oZC5zY3JvbGxlciwgXFxcImRibGNsaWNrXFxcIiwgb3BlcmF0aW9uKGNtLCBmdW5jdGlvbiAoZSkge1xcbiAgICAgIGlmIChzaWduYWxET01FdmVudChjbSwgZSkpIHsgcmV0dXJuIH1cXG4gICAgICB2YXIgcG9zID0gcG9zRnJvbU1vdXNlKGNtLCBlKTtcXG4gICAgICBpZiAoIXBvcyB8fCBjbGlja0luR3V0dGVyKGNtLCBlKSB8fCBldmVudEluV2lkZ2V0KGNtLmRpc3BsYXksIGUpKSB7IHJldHVybiB9XFxuICAgICAgZV9wcmV2ZW50RGVmYXVsdChlKTtcXG4gICAgICB2YXIgd29yZCA9IGNtLmZpbmRXb3JkQXQocG9zKTtcXG4gICAgICBleHRlbmRTZWxlY3Rpb24oY20uZG9jLCB3b3JkLmFuY2hvciwgd29yZC5oZWFkKTtcXG4gICAgfSkpOyB9XFxuICBlbHNlXFxuICAgIHsgb24oZC5zY3JvbGxlciwgXFxcImRibGNsaWNrXFxcIiwgZnVuY3Rpb24gKGUpIHsgcmV0dXJuIHNpZ25hbERPTUV2ZW50KGNtLCBlKSB8fCBlX3ByZXZlbnREZWZhdWx0KGUpOyB9KTsgfVxcbiAgLy8gU29tZSBicm93c2VycyBmaXJlIGNvbnRleHRtZW51ICphZnRlciogb3BlbmluZyB0aGUgbWVudSwgYXRcXG4gIC8vIHdoaWNoIHBvaW50IHdlIGNhbid0IG1lc3Mgd2l0aCBpdCBhbnltb3JlLiBDb250ZXh0IG1lbnUgaXNcXG4gIC8vIGhhbmRsZWQgaW4gb25Nb3VzZURvd24gZm9yIHRoZXNlIGJyb3dzZXJzLlxcbiAgaWYgKCFjYXB0dXJlUmlnaHRDbGljaykgeyBvbihkLnNjcm9sbGVyLCBcXFwiY29udGV4dG1lbnVcXFwiLCBmdW5jdGlvbiAoZSkgeyByZXR1cm4gb25Db250ZXh0TWVudShjbSwgZSk7IH0pOyB9XFxuXFxuICAvLyBVc2VkIHRvIHN1cHByZXNzIG1vdXNlIGV2ZW50IGhhbmRsaW5nIHdoZW4gYSB0b3VjaCBoYXBwZW5zXFxuICB2YXIgdG91Y2hGaW5pc2hlZCwgcHJldlRvdWNoID0ge2VuZDogMH07XFxuICBmdW5jdGlvbiBmaW5pc2hUb3VjaCgpIHtcXG4gICAgaWYgKGQuYWN0aXZlVG91Y2gpIHtcXG4gICAgICB0b3VjaEZpbmlzaGVkID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHJldHVybiBkLmFjdGl2ZVRvdWNoID0gbnVsbDsgfSwgMTAwMCk7XFxuICAgICAgcHJldlRvdWNoID0gZC5hY3RpdmVUb3VjaDtcXG4gICAgICBwcmV2VG91Y2guZW5kID0gK25ldyBEYXRlO1xcbiAgICB9XFxuICB9XFxuICBmdW5jdGlvbiBpc01vdXNlTGlrZVRvdWNoRXZlbnQoZSkge1xcbiAgICBpZiAoZS50b3VjaGVzLmxlbmd0aCAhPSAxKSB7IHJldHVybiBmYWxzZSB9XFxuICAgIHZhciB0b3VjaCA9IGUudG91Y2hlc1swXTtcXG4gICAgcmV0dXJuIHRvdWNoLnJhZGl1c1ggPD0gMSAmJiB0b3VjaC5yYWRpdXNZIDw9IDFcXG4gIH1cXG4gIGZ1bmN0aW9uIGZhckF3YXkodG91Y2gsIG90aGVyKSB7XFxuICAgIGlmIChvdGhlci5sZWZ0ID09IG51bGwpIHsgcmV0dXJuIHRydWUgfVxcbiAgICB2YXIgZHggPSBvdGhlci5sZWZ0IC0gdG91Y2gubGVmdCwgZHkgPSBvdGhlci50b3AgLSB0b3VjaC50b3A7XFxuICAgIHJldHVybiBkeCAqIGR4ICsgZHkgKiBkeSA+IDIwICogMjBcXG4gIH1cXG4gIG9uKGQuc2Nyb2xsZXIsIFxcXCJ0b3VjaHN0YXJ0XFxcIiwgZnVuY3Rpb24gKGUpIHtcXG4gICAgaWYgKCFzaWduYWxET01FdmVudChjbSwgZSkgJiYgIWlzTW91c2VMaWtlVG91Y2hFdmVudChlKSkge1xcbiAgICAgIGQuaW5wdXQuZW5zdXJlUG9sbGVkKCk7XFxuICAgICAgY2xlYXJUaW1lb3V0KHRvdWNoRmluaXNoZWQpO1xcbiAgICAgIHZhciBub3cgPSArbmV3IERhdGU7XFxuICAgICAgZC5hY3RpdmVUb3VjaCA9IHtzdGFydDogbm93LCBtb3ZlZDogZmFsc2UsXFxuICAgICAgICAgICAgICAgICAgICAgICBwcmV2OiBub3cgLSBwcmV2VG91Y2guZW5kIDw9IDMwMCA/IHByZXZUb3VjaCA6IG51bGx9O1xcbiAgICAgIGlmIChlLnRvdWNoZXMubGVuZ3RoID09IDEpIHtcXG4gICAgICAgIGQuYWN0aXZlVG91Y2gubGVmdCA9IGUudG91Y2hlc1swXS5wYWdlWDtcXG4gICAgICAgIGQuYWN0aXZlVG91Y2gudG9wID0gZS50b3VjaGVzWzBdLnBhZ2VZO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgfSk7XFxuICBvbihkLnNjcm9sbGVyLCBcXFwidG91Y2htb3ZlXFxcIiwgZnVuY3Rpb24gKCkge1xcbiAgICBpZiAoZC5hY3RpdmVUb3VjaCkgeyBkLmFjdGl2ZVRvdWNoLm1vdmVkID0gdHJ1ZTsgfVxcbiAgfSk7XFxuICBvbihkLnNjcm9sbGVyLCBcXFwidG91Y2hlbmRcXFwiLCBmdW5jdGlvbiAoZSkge1xcbiAgICB2YXIgdG91Y2ggPSBkLmFjdGl2ZVRvdWNoO1xcbiAgICBpZiAodG91Y2ggJiYgIWV2ZW50SW5XaWRnZXQoZCwgZSkgJiYgdG91Y2gubGVmdCAhPSBudWxsICYmXFxuICAgICAgICAhdG91Y2gubW92ZWQgJiYgbmV3IERhdGUgLSB0b3VjaC5zdGFydCA8IDMwMCkge1xcbiAgICAgIHZhciBwb3MgPSBjbS5jb29yZHNDaGFyKGQuYWN0aXZlVG91Y2gsIFxcXCJwYWdlXFxcIiksIHJhbmdlO1xcbiAgICAgIGlmICghdG91Y2gucHJldiB8fCBmYXJBd2F5KHRvdWNoLCB0b3VjaC5wcmV2KSkgLy8gU2luZ2xlIHRhcFxcbiAgICAgICAgeyByYW5nZSA9IG5ldyBSYW5nZShwb3MsIHBvcyk7IH1cXG4gICAgICBlbHNlIGlmICghdG91Y2gucHJldi5wcmV2IHx8IGZhckF3YXkodG91Y2gsIHRvdWNoLnByZXYucHJldikpIC8vIERvdWJsZSB0YXBcXG4gICAgICAgIHsgcmFuZ2UgPSBjbS5maW5kV29yZEF0KHBvcyk7IH1cXG4gICAgICBlbHNlIC8vIFRyaXBsZSB0YXBcXG4gICAgICAgIHsgcmFuZ2UgPSBuZXcgUmFuZ2UoUG9zKHBvcy5saW5lLCAwKSwgY2xpcFBvcyhjbS5kb2MsIFBvcyhwb3MubGluZSArIDEsIDApKSk7IH1cXG4gICAgICBjbS5zZXRTZWxlY3Rpb24ocmFuZ2UuYW5jaG9yLCByYW5nZS5oZWFkKTtcXG4gICAgICBjbS5mb2N1cygpO1xcbiAgICAgIGVfcHJldmVudERlZmF1bHQoZSk7XFxuICAgIH1cXG4gICAgZmluaXNoVG91Y2goKTtcXG4gIH0pO1xcbiAgb24oZC5zY3JvbGxlciwgXFxcInRvdWNoY2FuY2VsXFxcIiwgZmluaXNoVG91Y2gpO1xcblxcbiAgLy8gU3luYyBzY3JvbGxpbmcgYmV0d2VlbiBmYWtlIHNjcm9sbGJhcnMgYW5kIHJlYWwgc2Nyb2xsYWJsZVxcbiAgLy8gYXJlYSwgZW5zdXJlIHZpZXdwb3J0IGlzIHVwZGF0ZWQgd2hlbiBzY3JvbGxpbmcuXFxuICBvbihkLnNjcm9sbGVyLCBcXFwic2Nyb2xsXFxcIiwgZnVuY3Rpb24gKCkge1xcbiAgICBpZiAoZC5zY3JvbGxlci5jbGllbnRIZWlnaHQpIHtcXG4gICAgICBzZXRTY3JvbGxUb3AoY20sIGQuc2Nyb2xsZXIuc2Nyb2xsVG9wKTtcXG4gICAgICBzZXRTY3JvbGxMZWZ0KGNtLCBkLnNjcm9sbGVyLnNjcm9sbExlZnQsIHRydWUpO1xcbiAgICAgIHNpZ25hbChjbSwgXFxcInNjcm9sbFxcXCIsIGNtKTtcXG4gICAgfVxcbiAgfSk7XFxuXFxuICAvLyBMaXN0ZW4gdG8gd2hlZWwgZXZlbnRzIGluIG9yZGVyIHRvIHRyeSBhbmQgdXBkYXRlIHRoZSB2aWV3cG9ydCBvbiB0aW1lLlxcbiAgb24oZC5zY3JvbGxlciwgXFxcIm1vdXNld2hlZWxcXFwiLCBmdW5jdGlvbiAoZSkgeyByZXR1cm4gb25TY3JvbGxXaGVlbChjbSwgZSk7IH0pO1xcbiAgb24oZC5zY3JvbGxlciwgXFxcIkRPTU1vdXNlU2Nyb2xsXFxcIiwgZnVuY3Rpb24gKGUpIHsgcmV0dXJuIG9uU2Nyb2xsV2hlZWwoY20sIGUpOyB9KTtcXG5cXG4gIC8vIFByZXZlbnQgd3JhcHBlciBmcm9tIGV2ZXIgc2Nyb2xsaW5nXFxuICBvbihkLndyYXBwZXIsIFxcXCJzY3JvbGxcXFwiLCBmdW5jdGlvbiAoKSB7IHJldHVybiBkLndyYXBwZXIuc2Nyb2xsVG9wID0gZC53cmFwcGVyLnNjcm9sbExlZnQgPSAwOyB9KTtcXG5cXG4gIGQuZHJhZ0Z1bmN0aW9ucyA9IHtcXG4gICAgZW50ZXI6IGZ1bmN0aW9uIChlKSB7aWYgKCFzaWduYWxET01FdmVudChjbSwgZSkpIHsgZV9zdG9wKGUpOyB9fSxcXG4gICAgb3ZlcjogZnVuY3Rpb24gKGUpIHtpZiAoIXNpZ25hbERPTUV2ZW50KGNtLCBlKSkgeyBvbkRyYWdPdmVyKGNtLCBlKTsgZV9zdG9wKGUpOyB9fSxcXG4gICAgc3RhcnQ6IGZ1bmN0aW9uIChlKSB7IHJldHVybiBvbkRyYWdTdGFydChjbSwgZSk7IH0sXFxuICAgIGRyb3A6IG9wZXJhdGlvbihjbSwgb25Ecm9wKSxcXG4gICAgbGVhdmU6IGZ1bmN0aW9uIChlKSB7aWYgKCFzaWduYWxET01FdmVudChjbSwgZSkpIHsgY2xlYXJEcmFnQ3Vyc29yKGNtKTsgfX1cXG4gIH07XFxuXFxuICB2YXIgaW5wID0gZC5pbnB1dC5nZXRGaWVsZCgpO1xcbiAgb24oaW5wLCBcXFwia2V5dXBcXFwiLCBmdW5jdGlvbiAoZSkgeyByZXR1cm4gb25LZXlVcC5jYWxsKGNtLCBlKTsgfSk7XFxuICBvbihpbnAsIFxcXCJrZXlkb3duXFxcIiwgb3BlcmF0aW9uKGNtLCBvbktleURvd24pKTtcXG4gIG9uKGlucCwgXFxcImtleXByZXNzXFxcIiwgb3BlcmF0aW9uKGNtLCBvbktleVByZXNzKSk7XFxuICBvbihpbnAsIFxcXCJmb2N1c1xcXCIsIGZ1bmN0aW9uIChlKSB7IHJldHVybiBvbkZvY3VzKGNtLCBlKTsgfSk7XFxuICBvbihpbnAsIFxcXCJibHVyXFxcIiwgZnVuY3Rpb24gKGUpIHsgcmV0dXJuIG9uQmx1cihjbSwgZSk7IH0pO1xcbn1cXG5cXG52YXIgaW5pdEhvb2tzID0gW107XFxuQ29kZU1pcnJvciQxLmRlZmluZUluaXRIb29rID0gZnVuY3Rpb24gKGYpIHsgcmV0dXJuIGluaXRIb29rcy5wdXNoKGYpOyB9O1xcblxcbi8vIEluZGVudCB0aGUgZ2l2ZW4gbGluZS4gVGhlIGhvdyBwYXJhbWV0ZXIgY2FuIGJlIFxcXCJzbWFydFxcXCIsXFxuLy8gXFxcImFkZFxcXCIvbnVsbCwgXFxcInN1YnRyYWN0XFxcIiwgb3IgXFxcInByZXZcXFwiLiBXaGVuIGFnZ3Jlc3NpdmUgaXMgZmFsc2VcXG4vLyAodHlwaWNhbGx5IHNldCB0byB0cnVlIGZvciBmb3JjZWQgc2luZ2xlLWxpbmUgaW5kZW50cyksIGVtcHR5XFxuLy8gbGluZXMgYXJlIG5vdCBpbmRlbnRlZCwgYW5kIHBsYWNlcyB3aGVyZSB0aGUgbW9kZSByZXR1cm5zIFBhc3NcXG4vLyBhcmUgbGVmdCBhbG9uZS5cXG5mdW5jdGlvbiBpbmRlbnRMaW5lKGNtLCBuLCBob3csIGFnZ3Jlc3NpdmUpIHtcXG4gIHZhciBkb2MgPSBjbS5kb2MsIHN0YXRlO1xcbiAgaWYgKGhvdyA9PSBudWxsKSB7IGhvdyA9IFxcXCJhZGRcXFwiOyB9XFxuICBpZiAoaG93ID09IFxcXCJzbWFydFxcXCIpIHtcXG4gICAgLy8gRmFsbCBiYWNrIHRvIFxcXCJwcmV2XFxcIiB3aGVuIHRoZSBtb2RlIGRvZXNuJ3QgaGF2ZSBhbiBpbmRlbnRhdGlvblxcbiAgICAvLyBtZXRob2QuXFxuICAgIGlmICghZG9jLm1vZGUuaW5kZW50KSB7IGhvdyA9IFxcXCJwcmV2XFxcIjsgfVxcbiAgICBlbHNlIHsgc3RhdGUgPSBnZXRTdGF0ZUJlZm9yZShjbSwgbik7IH1cXG4gIH1cXG5cXG4gIHZhciB0YWJTaXplID0gY20ub3B0aW9ucy50YWJTaXplO1xcbiAgdmFyIGxpbmUgPSBnZXRMaW5lKGRvYywgbiksIGN1clNwYWNlID0gY291bnRDb2x1bW4obGluZS50ZXh0LCBudWxsLCB0YWJTaXplKTtcXG4gIGlmIChsaW5lLnN0YXRlQWZ0ZXIpIHsgbGluZS5zdGF0ZUFmdGVyID0gbnVsbDsgfVxcbiAgdmFyIGN1clNwYWNlU3RyaW5nID0gbGluZS50ZXh0Lm1hdGNoKC9eXFxcXHMqLylbMF0sIGluZGVudGF0aW9uO1xcbiAgaWYgKCFhZ2dyZXNzaXZlICYmICEvXFxcXFMvLnRlc3QobGluZS50ZXh0KSkge1xcbiAgICBpbmRlbnRhdGlvbiA9IDA7XFxuICAgIGhvdyA9IFxcXCJub3RcXFwiO1xcbiAgfSBlbHNlIGlmIChob3cgPT0gXFxcInNtYXJ0XFxcIikge1xcbiAgICBpbmRlbnRhdGlvbiA9IGRvYy5tb2RlLmluZGVudChzdGF0ZSwgbGluZS50ZXh0LnNsaWNlKGN1clNwYWNlU3RyaW5nLmxlbmd0aCksIGxpbmUudGV4dCk7XFxuICAgIGlmIChpbmRlbnRhdGlvbiA9PSBQYXNzIHx8IGluZGVudGF0aW9uID4gMTUwKSB7XFxuICAgICAgaWYgKCFhZ2dyZXNzaXZlKSB7IHJldHVybiB9XFxuICAgICAgaG93ID0gXFxcInByZXZcXFwiO1xcbiAgICB9XFxuICB9XFxuICBpZiAoaG93ID09IFxcXCJwcmV2XFxcIikge1xcbiAgICBpZiAobiA+IGRvYy5maXJzdCkgeyBpbmRlbnRhdGlvbiA9IGNvdW50Q29sdW1uKGdldExpbmUoZG9jLCBuLTEpLnRleHQsIG51bGwsIHRhYlNpemUpOyB9XFxuICAgIGVsc2UgeyBpbmRlbnRhdGlvbiA9IDA7IH1cXG4gIH0gZWxzZSBpZiAoaG93ID09IFxcXCJhZGRcXFwiKSB7XFxuICAgIGluZGVudGF0aW9uID0gY3VyU3BhY2UgKyBjbS5vcHRpb25zLmluZGVudFVuaXQ7XFxuICB9IGVsc2UgaWYgKGhvdyA9PSBcXFwic3VidHJhY3RcXFwiKSB7XFxuICAgIGluZGVudGF0aW9uID0gY3VyU3BhY2UgLSBjbS5vcHRpb25zLmluZGVudFVuaXQ7XFxuICB9IGVsc2UgaWYgKHR5cGVvZiBob3cgPT0gXFxcIm51bWJlclxcXCIpIHtcXG4gICAgaW5kZW50YXRpb24gPSBjdXJTcGFjZSArIGhvdztcXG4gIH1cXG4gIGluZGVudGF0aW9uID0gTWF0aC5tYXgoMCwgaW5kZW50YXRpb24pO1xcblxcbiAgdmFyIGluZGVudFN0cmluZyA9IFxcXCJcXFwiLCBwb3MgPSAwO1xcbiAgaWYgKGNtLm9wdGlvbnMuaW5kZW50V2l0aFRhYnMpXFxuICAgIHsgZm9yICh2YXIgaSA9IE1hdGguZmxvb3IoaW5kZW50YXRpb24gLyB0YWJTaXplKTsgaTsgLS1pKSB7cG9zICs9IHRhYlNpemU7IGluZGVudFN0cmluZyArPSBcXFwiXFxcXHRcXFwiO30gfVxcbiAgaWYgKHBvcyA8IGluZGVudGF0aW9uKSB7IGluZGVudFN0cmluZyArPSBzcGFjZVN0cihpbmRlbnRhdGlvbiAtIHBvcyk7IH1cXG5cXG4gIGlmIChpbmRlbnRTdHJpbmcgIT0gY3VyU3BhY2VTdHJpbmcpIHtcXG4gICAgcmVwbGFjZVJhbmdlKGRvYywgaW5kZW50U3RyaW5nLCBQb3MobiwgMCksIFBvcyhuLCBjdXJTcGFjZVN0cmluZy5sZW5ndGgpLCBcXFwiK2lucHV0XFxcIik7XFxuICAgIGxpbmUuc3RhdGVBZnRlciA9IG51bGw7XFxuICAgIHJldHVybiB0cnVlXFxuICB9IGVsc2Uge1xcbiAgICAvLyBFbnN1cmUgdGhhdCwgaWYgdGhlIGN1cnNvciB3YXMgaW4gdGhlIHdoaXRlc3BhY2UgYXQgdGhlIHN0YXJ0XFxuICAgIC8vIG9mIHRoZSBsaW5lLCBpdCBpcyBtb3ZlZCB0byB0aGUgZW5kIG9mIHRoYXQgc3BhY2UuXFxuICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IGRvYy5zZWwucmFuZ2VzLmxlbmd0aDsgaSQxKyspIHtcXG4gICAgICB2YXIgcmFuZ2UgPSBkb2Muc2VsLnJhbmdlc1tpJDFdO1xcbiAgICAgIGlmIChyYW5nZS5oZWFkLmxpbmUgPT0gbiAmJiByYW5nZS5oZWFkLmNoIDwgY3VyU3BhY2VTdHJpbmcubGVuZ3RoKSB7XFxuICAgICAgICB2YXIgcG9zJDEgPSBQb3MobiwgY3VyU3BhY2VTdHJpbmcubGVuZ3RoKTtcXG4gICAgICAgIHJlcGxhY2VPbmVTZWxlY3Rpb24oZG9jLCBpJDEsIG5ldyBSYW5nZShwb3MkMSwgcG9zJDEpKTtcXG4gICAgICAgIGJyZWFrXFxuICAgICAgfVxcbiAgICB9XFxuICB9XFxufVxcblxcbi8vIFRoaXMgd2lsbCBiZSBzZXQgdG8gYSB7bGluZVdpc2U6IGJvb2wsIHRleHQ6IFtzdHJpbmddfSBvYmplY3QsIHNvXFxuLy8gdGhhdCwgd2hlbiBwYXN0aW5nLCB3ZSBrbm93IHdoYXQga2luZCBvZiBzZWxlY3Rpb25zIHRoZSBjb3BpZWRcXG4vLyB0ZXh0IHdhcyBtYWRlIG91dCBvZi5cXG52YXIgbGFzdENvcGllZCA9IG51bGw7XFxuXFxuZnVuY3Rpb24gc2V0TGFzdENvcGllZChuZXdMYXN0Q29waWVkKSB7XFxuICBsYXN0Q29waWVkID0gbmV3TGFzdENvcGllZDtcXG59XFxuXFxuZnVuY3Rpb24gYXBwbHlUZXh0SW5wdXQoY20sIGluc2VydGVkLCBkZWxldGVkLCBzZWwsIG9yaWdpbikge1xcbiAgdmFyIGRvYyA9IGNtLmRvYztcXG4gIGNtLmRpc3BsYXkuc2hpZnQgPSBmYWxzZTtcXG4gIGlmICghc2VsKSB7IHNlbCA9IGRvYy5zZWw7IH1cXG5cXG4gIHZhciBwYXN0ZSA9IGNtLnN0YXRlLnBhc3RlSW5jb21pbmcgfHwgb3JpZ2luID09IFxcXCJwYXN0ZVxcXCI7XFxuICB2YXIgdGV4dExpbmVzID0gc3BsaXRMaW5lc0F1dG8oaW5zZXJ0ZWQpLCBtdWx0aVBhc3RlID0gbnVsbDtcXG4gIC8vIFdoZW4gcGFzaW5nIE4gbGluZXMgaW50byBOIHNlbGVjdGlvbnMsIGluc2VydCBvbmUgbGluZSBwZXIgc2VsZWN0aW9uXFxuICBpZiAocGFzdGUgJiYgc2VsLnJhbmdlcy5sZW5ndGggPiAxKSB7XFxuICAgIGlmIChsYXN0Q29waWVkICYmIGxhc3RDb3BpZWQudGV4dC5qb2luKFxcXCJcXFxcblxcXCIpID09IGluc2VydGVkKSB7XFxuICAgICAgaWYgKHNlbC5yYW5nZXMubGVuZ3RoICUgbGFzdENvcGllZC50ZXh0Lmxlbmd0aCA9PSAwKSB7XFxuICAgICAgICBtdWx0aVBhc3RlID0gW107XFxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxhc3RDb3BpZWQudGV4dC5sZW5ndGg7IGkrKylcXG4gICAgICAgICAgeyBtdWx0aVBhc3RlLnB1c2goZG9jLnNwbGl0TGluZXMobGFzdENvcGllZC50ZXh0W2ldKSk7IH1cXG4gICAgICB9XFxuICAgIH0gZWxzZSBpZiAodGV4dExpbmVzLmxlbmd0aCA9PSBzZWwucmFuZ2VzLmxlbmd0aCkge1xcbiAgICAgIG11bHRpUGFzdGUgPSBtYXAodGV4dExpbmVzLCBmdW5jdGlvbiAobCkgeyByZXR1cm4gW2xdOyB9KTtcXG4gICAgfVxcbiAgfVxcblxcbiAgdmFyIHVwZGF0ZUlucHV0O1xcbiAgLy8gTm9ybWFsIGJlaGF2aW9yIGlzIHRvIGluc2VydCB0aGUgbmV3IHRleHQgaW50byBldmVyeSBzZWxlY3Rpb25cXG4gIGZvciAodmFyIGkkMSA9IHNlbC5yYW5nZXMubGVuZ3RoIC0gMTsgaSQxID49IDA7IGkkMS0tKSB7XFxuICAgIHZhciByYW5nZSQkMSA9IHNlbC5yYW5nZXNbaSQxXTtcXG4gICAgdmFyIGZyb20gPSByYW5nZSQkMS5mcm9tKCksIHRvID0gcmFuZ2UkJDEudG8oKTtcXG4gICAgaWYgKHJhbmdlJCQxLmVtcHR5KCkpIHtcXG4gICAgICBpZiAoZGVsZXRlZCAmJiBkZWxldGVkID4gMCkgLy8gSGFuZGxlIGRlbGV0aW9uXFxuICAgICAgICB7IGZyb20gPSBQb3MoZnJvbS5saW5lLCBmcm9tLmNoIC0gZGVsZXRlZCk7IH1cXG4gICAgICBlbHNlIGlmIChjbS5zdGF0ZS5vdmVyd3JpdGUgJiYgIXBhc3RlKSAvLyBIYW5kbGUgb3ZlcndyaXRlXFxuICAgICAgICB7IHRvID0gUG9zKHRvLmxpbmUsIE1hdGgubWluKGdldExpbmUoZG9jLCB0by5saW5lKS50ZXh0Lmxlbmd0aCwgdG8uY2ggKyBsc3QodGV4dExpbmVzKS5sZW5ndGgpKTsgfVxcbiAgICAgIGVsc2UgaWYgKGxhc3RDb3BpZWQgJiYgbGFzdENvcGllZC5saW5lV2lzZSAmJiBsYXN0Q29waWVkLnRleHQuam9pbihcXFwiXFxcXG5cXFwiKSA9PSBpbnNlcnRlZClcXG4gICAgICAgIHsgZnJvbSA9IHRvID0gUG9zKGZyb20ubGluZSwgMCk7IH1cXG4gICAgfVxcbiAgICB1cGRhdGVJbnB1dCA9IGNtLmN1ck9wLnVwZGF0ZUlucHV0O1xcbiAgICB2YXIgY2hhbmdlRXZlbnQgPSB7ZnJvbTogZnJvbSwgdG86IHRvLCB0ZXh0OiBtdWx0aVBhc3RlID8gbXVsdGlQYXN0ZVtpJDEgJSBtdWx0aVBhc3RlLmxlbmd0aF0gOiB0ZXh0TGluZXMsXFxuICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW46IG9yaWdpbiB8fCAocGFzdGUgPyBcXFwicGFzdGVcXFwiIDogY20uc3RhdGUuY3V0SW5jb21pbmcgPyBcXFwiY3V0XFxcIiA6IFxcXCIraW5wdXRcXFwiKX07XFxuICAgIG1ha2VDaGFuZ2UoY20uZG9jLCBjaGFuZ2VFdmVudCk7XFxuICAgIHNpZ25hbExhdGVyKGNtLCBcXFwiaW5wdXRSZWFkXFxcIiwgY20sIGNoYW5nZUV2ZW50KTtcXG4gIH1cXG4gIGlmIChpbnNlcnRlZCAmJiAhcGFzdGUpXFxuICAgIHsgdHJpZ2dlckVsZWN0cmljKGNtLCBpbnNlcnRlZCk7IH1cXG5cXG4gIGVuc3VyZUN1cnNvclZpc2libGUoY20pO1xcbiAgY20uY3VyT3AudXBkYXRlSW5wdXQgPSB1cGRhdGVJbnB1dDtcXG4gIGNtLmN1ck9wLnR5cGluZyA9IHRydWU7XFxuICBjbS5zdGF0ZS5wYXN0ZUluY29taW5nID0gY20uc3RhdGUuY3V0SW5jb21pbmcgPSBmYWxzZTtcXG59XFxuXFxuZnVuY3Rpb24gaGFuZGxlUGFzdGUoZSwgY20pIHtcXG4gIHZhciBwYXN0ZWQgPSBlLmNsaXBib2FyZERhdGEgJiYgZS5jbGlwYm9hcmREYXRhLmdldERhdGEoXFxcIlRleHRcXFwiKTtcXG4gIGlmIChwYXN0ZWQpIHtcXG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xcbiAgICBpZiAoIWNtLmlzUmVhZE9ubHkoKSAmJiAhY20ub3B0aW9ucy5kaXNhYmxlSW5wdXQpXFxuICAgICAgeyBydW5Jbk9wKGNtLCBmdW5jdGlvbiAoKSB7IHJldHVybiBhcHBseVRleHRJbnB1dChjbSwgcGFzdGVkLCAwLCBudWxsLCBcXFwicGFzdGVcXFwiKTsgfSk7IH1cXG4gICAgcmV0dXJuIHRydWVcXG4gIH1cXG59XFxuXFxuZnVuY3Rpb24gdHJpZ2dlckVsZWN0cmljKGNtLCBpbnNlcnRlZCkge1xcbiAgLy8gV2hlbiBhbiAnZWxlY3RyaWMnIGNoYXJhY3RlciBpcyBpbnNlcnRlZCwgaW1tZWRpYXRlbHkgdHJpZ2dlciBhIHJlaW5kZW50XFxuICBpZiAoIWNtLm9wdGlvbnMuZWxlY3RyaWNDaGFycyB8fCAhY20ub3B0aW9ucy5zbWFydEluZGVudCkgeyByZXR1cm4gfVxcbiAgdmFyIHNlbCA9IGNtLmRvYy5zZWw7XFxuXFxuICBmb3IgKHZhciBpID0gc2VsLnJhbmdlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xcbiAgICB2YXIgcmFuZ2UkJDEgPSBzZWwucmFuZ2VzW2ldO1xcbiAgICBpZiAocmFuZ2UkJDEuaGVhZC5jaCA+IDEwMCB8fCAoaSAmJiBzZWwucmFuZ2VzW2kgLSAxXS5oZWFkLmxpbmUgPT0gcmFuZ2UkJDEuaGVhZC5saW5lKSkgeyBjb250aW51ZSB9XFxuICAgIHZhciBtb2RlID0gY20uZ2V0TW9kZUF0KHJhbmdlJCQxLmhlYWQpO1xcbiAgICB2YXIgaW5kZW50ZWQgPSBmYWxzZTtcXG4gICAgaWYgKG1vZGUuZWxlY3RyaWNDaGFycykge1xcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbW9kZS5lbGVjdHJpY0NoYXJzLmxlbmd0aDsgaisrKVxcbiAgICAgICAgeyBpZiAoaW5zZXJ0ZWQuaW5kZXhPZihtb2RlLmVsZWN0cmljQ2hhcnMuY2hhckF0KGopKSA+IC0xKSB7XFxuICAgICAgICAgIGluZGVudGVkID0gaW5kZW50TGluZShjbSwgcmFuZ2UkJDEuaGVhZC5saW5lLCBcXFwic21hcnRcXFwiKTtcXG4gICAgICAgICAgYnJlYWtcXG4gICAgICAgIH0gfVxcbiAgICB9IGVsc2UgaWYgKG1vZGUuZWxlY3RyaWNJbnB1dCkge1xcbiAgICAgIGlmIChtb2RlLmVsZWN0cmljSW5wdXQudGVzdChnZXRMaW5lKGNtLmRvYywgcmFuZ2UkJDEuaGVhZC5saW5lKS50ZXh0LnNsaWNlKDAsIHJhbmdlJCQxLmhlYWQuY2gpKSlcXG4gICAgICAgIHsgaW5kZW50ZWQgPSBpbmRlbnRMaW5lKGNtLCByYW5nZSQkMS5oZWFkLmxpbmUsIFxcXCJzbWFydFxcXCIpOyB9XFxuICAgIH1cXG4gICAgaWYgKGluZGVudGVkKSB7IHNpZ25hbExhdGVyKGNtLCBcXFwiZWxlY3RyaWNJbnB1dFxcXCIsIGNtLCByYW5nZSQkMS5oZWFkLmxpbmUpOyB9XFxuICB9XFxufVxcblxcbmZ1bmN0aW9uIGNvcHlhYmxlUmFuZ2VzKGNtKSB7XFxuICB2YXIgdGV4dCA9IFtdLCByYW5nZXMgPSBbXTtcXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY20uZG9jLnNlbC5yYW5nZXMubGVuZ3RoOyBpKyspIHtcXG4gICAgdmFyIGxpbmUgPSBjbS5kb2Muc2VsLnJhbmdlc1tpXS5oZWFkLmxpbmU7XFxuICAgIHZhciBsaW5lUmFuZ2UgPSB7YW5jaG9yOiBQb3MobGluZSwgMCksIGhlYWQ6IFBvcyhsaW5lICsgMSwgMCl9O1xcbiAgICByYW5nZXMucHVzaChsaW5lUmFuZ2UpO1xcbiAgICB0ZXh0LnB1c2goY20uZ2V0UmFuZ2UobGluZVJhbmdlLmFuY2hvciwgbGluZVJhbmdlLmhlYWQpKTtcXG4gIH1cXG4gIHJldHVybiB7dGV4dDogdGV4dCwgcmFuZ2VzOiByYW5nZXN9XFxufVxcblxcbmZ1bmN0aW9uIGRpc2FibGVCcm93c2VyTWFnaWMoZmllbGQsIHNwZWxsY2hlY2spIHtcXG4gIGZpZWxkLnNldEF0dHJpYnV0ZShcXFwiYXV0b2NvcnJlY3RcXFwiLCBcXFwib2ZmXFxcIik7XFxuICBmaWVsZC5zZXRBdHRyaWJ1dGUoXFxcImF1dG9jYXBpdGFsaXplXFxcIiwgXFxcIm9mZlxcXCIpO1xcbiAgZmllbGQuc2V0QXR0cmlidXRlKFxcXCJzcGVsbGNoZWNrXFxcIiwgISFzcGVsbGNoZWNrKTtcXG59XFxuXFxuZnVuY3Rpb24gaGlkZGVuVGV4dGFyZWEoKSB7XFxuICB2YXIgdGUgPSBlbHQoXFxcInRleHRhcmVhXFxcIiwgbnVsbCwgbnVsbCwgXFxcInBvc2l0aW9uOiBhYnNvbHV0ZTsgYm90dG9tOiAtMWVtOyBwYWRkaW5nOiAwOyB3aWR0aDogMXB4OyBoZWlnaHQ6IDFlbTsgb3V0bGluZTogbm9uZVxcXCIpO1xcbiAgdmFyIGRpdiA9IGVsdChcXFwiZGl2XFxcIiwgW3RlXSwgbnVsbCwgXFxcIm92ZXJmbG93OiBoaWRkZW47IHBvc2l0aW9uOiByZWxhdGl2ZTsgd2lkdGg6IDNweDsgaGVpZ2h0OiAwcHg7XFxcIik7XFxuICAvLyBUaGUgdGV4dGFyZWEgaXMga2VwdCBwb3NpdGlvbmVkIG5lYXIgdGhlIGN1cnNvciB0byBwcmV2ZW50IHRoZVxcbiAgLy8gZmFjdCB0aGF0IGl0J2xsIGJlIHNjcm9sbGVkIGludG8gdmlldyBvbiBpbnB1dCBmcm9tIHNjcm9sbGluZ1xcbiAgLy8gb3VyIGZha2UgY3Vyc29yIG91dCBvZiB2aWV3LiBPbiB3ZWJraXQsIHdoZW4gd3JhcD1vZmYsIHBhc3RlIGlzXFxuICAvLyB2ZXJ5IHNsb3cuIFNvIG1ha2UgdGhlIGFyZWEgd2lkZSBpbnN0ZWFkLlxcbiAgaWYgKHdlYmtpdCkgeyB0ZS5zdHlsZS53aWR0aCA9IFxcXCIxMDAwcHhcXFwiOyB9XFxuICBlbHNlIHsgdGUuc2V0QXR0cmlidXRlKFxcXCJ3cmFwXFxcIiwgXFxcIm9mZlxcXCIpOyB9XFxuICAvLyBJZiBib3JkZXI6IDA7IC0tIGlPUyBmYWlscyB0byBvcGVuIGtleWJvYXJkIChpc3N1ZSAjMTI4NylcXG4gIGlmIChpb3MpIHsgdGUuc3R5bGUuYm9yZGVyID0gXFxcIjFweCBzb2xpZCBibGFja1xcXCI7IH1cXG4gIGRpc2FibGVCcm93c2VyTWFnaWModGUpO1xcbiAgcmV0dXJuIGRpdlxcbn1cXG5cXG4vLyBUaGUgcHVibGljbHkgdmlzaWJsZSBBUEkuIE5vdGUgdGhhdCBtZXRob2RPcChmKSBtZWFuc1xcbi8vICd3cmFwIGYgaW4gYW4gb3BlcmF0aW9uLCBwZXJmb3JtZWQgb24gaXRzIGB0aGlzYCBwYXJhbWV0ZXInLlxcblxcbi8vIFRoaXMgaXMgbm90IHRoZSBjb21wbGV0ZSBzZXQgb2YgZWRpdG9yIG1ldGhvZHMuIE1vc3Qgb2YgdGhlXFxuLy8gbWV0aG9kcyBkZWZpbmVkIG9uIHRoZSBEb2MgdHlwZSBhcmUgYWxzbyBpbmplY3RlZCBpbnRvXFxuLy8gQ29kZU1pcnJvci5wcm90b3R5cGUsIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSBhbmRcXG4vLyBjb252ZW5pZW5jZS5cXG5cXG52YXIgYWRkRWRpdG9yTWV0aG9kcyA9IGZ1bmN0aW9uKENvZGVNaXJyb3IpIHtcXG4gIHZhciBvcHRpb25IYW5kbGVycyA9IENvZGVNaXJyb3Iub3B0aW9uSGFuZGxlcnM7XFxuXFxuICB2YXIgaGVscGVycyA9IENvZGVNaXJyb3IuaGVscGVycyA9IHt9O1xcblxcbiAgQ29kZU1pcnJvci5wcm90b3R5cGUgPSB7XFxuICAgIGNvbnN0cnVjdG9yOiBDb2RlTWlycm9yLFxcbiAgICBmb2N1czogZnVuY3Rpb24oKXt3aW5kb3cuZm9jdXMoKTsgdGhpcy5kaXNwbGF5LmlucHV0LmZvY3VzKCk7fSxcXG5cXG4gICAgc2V0T3B0aW9uOiBmdW5jdGlvbihvcHRpb24sIHZhbHVlKSB7XFxuICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsIG9sZCA9IG9wdGlvbnNbb3B0aW9uXTtcXG4gICAgICBpZiAob3B0aW9uc1tvcHRpb25dID09IHZhbHVlICYmIG9wdGlvbiAhPSBcXFwibW9kZVxcXCIpIHsgcmV0dXJuIH1cXG4gICAgICBvcHRpb25zW29wdGlvbl0gPSB2YWx1ZTtcXG4gICAgICBpZiAob3B0aW9uSGFuZGxlcnMuaGFzT3duUHJvcGVydHkob3B0aW9uKSlcXG4gICAgICAgIHsgb3BlcmF0aW9uKHRoaXMsIG9wdGlvbkhhbmRsZXJzW29wdGlvbl0pKHRoaXMsIHZhbHVlLCBvbGQpOyB9XFxuICAgICAgc2lnbmFsKHRoaXMsIFxcXCJvcHRpb25DaGFuZ2VcXFwiLCB0aGlzLCBvcHRpb24pO1xcbiAgICB9LFxcblxcbiAgICBnZXRPcHRpb246IGZ1bmN0aW9uKG9wdGlvbikge3JldHVybiB0aGlzLm9wdGlvbnNbb3B0aW9uXX0sXFxuICAgIGdldERvYzogZnVuY3Rpb24oKSB7cmV0dXJuIHRoaXMuZG9jfSxcXG5cXG4gICAgYWRkS2V5TWFwOiBmdW5jdGlvbihtYXAkJDEsIGJvdHRvbSkge1xcbiAgICAgIHRoaXMuc3RhdGUua2V5TWFwc1tib3R0b20gPyBcXFwicHVzaFxcXCIgOiBcXFwidW5zaGlmdFxcXCJdKGdldEtleU1hcChtYXAkJDEpKTtcXG4gICAgfSxcXG4gICAgcmVtb3ZlS2V5TWFwOiBmdW5jdGlvbihtYXAkJDEpIHtcXG4gICAgICB2YXIgbWFwcyA9IHRoaXMuc3RhdGUua2V5TWFwcztcXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1hcHMubGVuZ3RoOyArK2kpXFxuICAgICAgICB7IGlmIChtYXBzW2ldID09IG1hcCQkMSB8fCBtYXBzW2ldLm5hbWUgPT0gbWFwJCQxKSB7XFxuICAgICAgICAgIG1hcHMuc3BsaWNlKGksIDEpO1xcbiAgICAgICAgICByZXR1cm4gdHJ1ZVxcbiAgICAgICAgfSB9XFxuICAgIH0sXFxuXFxuICAgIGFkZE92ZXJsYXk6IG1ldGhvZE9wKGZ1bmN0aW9uKHNwZWMsIG9wdGlvbnMpIHtcXG4gICAgICB2YXIgbW9kZSA9IHNwZWMudG9rZW4gPyBzcGVjIDogQ29kZU1pcnJvci5nZXRNb2RlKHRoaXMub3B0aW9ucywgc3BlYyk7XFxuICAgICAgaWYgKG1vZGUuc3RhcnRTdGF0ZSkgeyB0aHJvdyBuZXcgRXJyb3IoXFxcIk92ZXJsYXlzIG1heSBub3QgYmUgc3RhdGVmdWwuXFxcIikgfVxcbiAgICAgIGluc2VydFNvcnRlZCh0aGlzLnN0YXRlLm92ZXJsYXlzLFxcbiAgICAgICAgICAgICAgICAgICB7bW9kZTogbW9kZSwgbW9kZVNwZWM6IHNwZWMsIG9wYXF1ZTogb3B0aW9ucyAmJiBvcHRpb25zLm9wYXF1ZSxcXG4gICAgICAgICAgICAgICAgICAgIHByaW9yaXR5OiAob3B0aW9ucyAmJiBvcHRpb25zLnByaW9yaXR5KSB8fCAwfSxcXG4gICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKG92ZXJsYXkpIHsgcmV0dXJuIG92ZXJsYXkucHJpb3JpdHk7IH0pO1xcbiAgICAgIHRoaXMuc3RhdGUubW9kZUdlbisrO1xcbiAgICAgIHJlZ0NoYW5nZSh0aGlzKTtcXG4gICAgfSksXFxuICAgIHJlbW92ZU92ZXJsYXk6IG1ldGhvZE9wKGZ1bmN0aW9uKHNwZWMpIHtcXG4gICAgICB2YXIgdGhpcyQxID0gdGhpcztcXG5cXG4gICAgICB2YXIgb3ZlcmxheXMgPSB0aGlzLnN0YXRlLm92ZXJsYXlzO1xcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3ZlcmxheXMubGVuZ3RoOyArK2kpIHtcXG4gICAgICAgIHZhciBjdXIgPSBvdmVybGF5c1tpXS5tb2RlU3BlYztcXG4gICAgICAgIGlmIChjdXIgPT0gc3BlYyB8fCB0eXBlb2Ygc3BlYyA9PSBcXFwic3RyaW5nXFxcIiAmJiBjdXIubmFtZSA9PSBzcGVjKSB7XFxuICAgICAgICAgIG92ZXJsYXlzLnNwbGljZShpLCAxKTtcXG4gICAgICAgICAgdGhpcyQxLnN0YXRlLm1vZGVHZW4rKztcXG4gICAgICAgICAgcmVnQ2hhbmdlKHRoaXMkMSk7XFxuICAgICAgICAgIHJldHVyblxcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgfSksXFxuXFxuICAgIGluZGVudExpbmU6IG1ldGhvZE9wKGZ1bmN0aW9uKG4sIGRpciwgYWdncmVzc2l2ZSkge1xcbiAgICAgIGlmICh0eXBlb2YgZGlyICE9IFxcXCJzdHJpbmdcXFwiICYmIHR5cGVvZiBkaXIgIT0gXFxcIm51bWJlclxcXCIpIHtcXG4gICAgICAgIGlmIChkaXIgPT0gbnVsbCkgeyBkaXIgPSB0aGlzLm9wdGlvbnMuc21hcnRJbmRlbnQgPyBcXFwic21hcnRcXFwiIDogXFxcInByZXZcXFwiOyB9XFxuICAgICAgICBlbHNlIHsgZGlyID0gZGlyID8gXFxcImFkZFxcXCIgOiBcXFwic3VidHJhY3RcXFwiOyB9XFxuICAgICAgfVxcbiAgICAgIGlmIChpc0xpbmUodGhpcy5kb2MsIG4pKSB7IGluZGVudExpbmUodGhpcywgbiwgZGlyLCBhZ2dyZXNzaXZlKTsgfVxcbiAgICB9KSxcXG4gICAgaW5kZW50U2VsZWN0aW9uOiBtZXRob2RPcChmdW5jdGlvbihob3cpIHtcXG4gICAgICB2YXIgdGhpcyQxID0gdGhpcztcXG5cXG4gICAgICB2YXIgcmFuZ2VzID0gdGhpcy5kb2Muc2VsLnJhbmdlcywgZW5kID0gLTE7XFxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByYW5nZXMubGVuZ3RoOyBpKyspIHtcXG4gICAgICAgIHZhciByYW5nZSQkMSA9IHJhbmdlc1tpXTtcXG4gICAgICAgIGlmICghcmFuZ2UkJDEuZW1wdHkoKSkge1xcbiAgICAgICAgICB2YXIgZnJvbSA9IHJhbmdlJCQxLmZyb20oKSwgdG8gPSByYW5nZSQkMS50bygpO1xcbiAgICAgICAgICB2YXIgc3RhcnQgPSBNYXRoLm1heChlbmQsIGZyb20ubGluZSk7XFxuICAgICAgICAgIGVuZCA9IE1hdGgubWluKHRoaXMkMS5sYXN0TGluZSgpLCB0by5saW5lIC0gKHRvLmNoID8gMCA6IDEpKSArIDE7XFxuICAgICAgICAgIGZvciAodmFyIGogPSBzdGFydDsgaiA8IGVuZDsgKytqKVxcbiAgICAgICAgICAgIHsgaW5kZW50TGluZSh0aGlzJDEsIGosIGhvdyk7IH1cXG4gICAgICAgICAgdmFyIG5ld1JhbmdlcyA9IHRoaXMkMS5kb2Muc2VsLnJhbmdlcztcXG4gICAgICAgICAgaWYgKGZyb20uY2ggPT0gMCAmJiByYW5nZXMubGVuZ3RoID09IG5ld1Jhbmdlcy5sZW5ndGggJiYgbmV3UmFuZ2VzW2ldLmZyb20oKS5jaCA+IDApXFxuICAgICAgICAgICAgeyByZXBsYWNlT25lU2VsZWN0aW9uKHRoaXMkMS5kb2MsIGksIG5ldyBSYW5nZShmcm9tLCBuZXdSYW5nZXNbaV0udG8oKSksIHNlbF9kb250U2Nyb2xsKTsgfVxcbiAgICAgICAgfSBlbHNlIGlmIChyYW5nZSQkMS5oZWFkLmxpbmUgPiBlbmQpIHtcXG4gICAgICAgICAgaW5kZW50TGluZSh0aGlzJDEsIHJhbmdlJCQxLmhlYWQubGluZSwgaG93LCB0cnVlKTtcXG4gICAgICAgICAgZW5kID0gcmFuZ2UkJDEuaGVhZC5saW5lO1xcbiAgICAgICAgICBpZiAoaSA9PSB0aGlzJDEuZG9jLnNlbC5wcmltSW5kZXgpIHsgZW5zdXJlQ3Vyc29yVmlzaWJsZSh0aGlzJDEpOyB9XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICB9KSxcXG5cXG4gICAgLy8gRmV0Y2ggdGhlIHBhcnNlciB0b2tlbiBmb3IgYSBnaXZlbiBjaGFyYWN0ZXIuIFVzZWZ1bCBmb3IgaGFja3NcXG4gICAgLy8gdGhhdCB3YW50IHRvIGluc3BlY3QgdGhlIG1vZGUgc3RhdGUgKHNheSwgZm9yIGNvbXBsZXRpb24pLlxcbiAgICBnZXRUb2tlbkF0OiBmdW5jdGlvbihwb3MsIHByZWNpc2UpIHtcXG4gICAgICByZXR1cm4gdGFrZVRva2VuKHRoaXMsIHBvcywgcHJlY2lzZSlcXG4gICAgfSxcXG5cXG4gICAgZ2V0TGluZVRva2VuczogZnVuY3Rpb24obGluZSwgcHJlY2lzZSkge1xcbiAgICAgIHJldHVybiB0YWtlVG9rZW4odGhpcywgUG9zKGxpbmUpLCBwcmVjaXNlLCB0cnVlKVxcbiAgICB9LFxcblxcbiAgICBnZXRUb2tlblR5cGVBdDogZnVuY3Rpb24ocG9zKSB7XFxuICAgICAgcG9zID0gY2xpcFBvcyh0aGlzLmRvYywgcG9zKTtcXG4gICAgICB2YXIgc3R5bGVzID0gZ2V0TGluZVN0eWxlcyh0aGlzLCBnZXRMaW5lKHRoaXMuZG9jLCBwb3MubGluZSkpO1xcbiAgICAgIHZhciBiZWZvcmUgPSAwLCBhZnRlciA9IChzdHlsZXMubGVuZ3RoIC0gMSkgLyAyLCBjaCA9IHBvcy5jaDtcXG4gICAgICB2YXIgdHlwZTtcXG4gICAgICBpZiAoY2ggPT0gMCkgeyB0eXBlID0gc3R5bGVzWzJdOyB9XFxuICAgICAgZWxzZSB7IGZvciAoOzspIHtcXG4gICAgICAgIHZhciBtaWQgPSAoYmVmb3JlICsgYWZ0ZXIpID4+IDE7XFxuICAgICAgICBpZiAoKG1pZCA/IHN0eWxlc1ttaWQgKiAyIC0gMV0gOiAwKSA+PSBjaCkgeyBhZnRlciA9IG1pZDsgfVxcbiAgICAgICAgZWxzZSBpZiAoc3R5bGVzW21pZCAqIDIgKyAxXSA8IGNoKSB7IGJlZm9yZSA9IG1pZCArIDE7IH1cXG4gICAgICAgIGVsc2UgeyB0eXBlID0gc3R5bGVzW21pZCAqIDIgKyAyXTsgYnJlYWsgfVxcbiAgICAgIH0gfVxcbiAgICAgIHZhciBjdXQgPSB0eXBlID8gdHlwZS5pbmRleE9mKFxcXCJvdmVybGF5IFxcXCIpIDogLTE7XFxuICAgICAgcmV0dXJuIGN1dCA8IDAgPyB0eXBlIDogY3V0ID09IDAgPyBudWxsIDogdHlwZS5zbGljZSgwLCBjdXQgLSAxKVxcbiAgICB9LFxcblxcbiAgICBnZXRNb2RlQXQ6IGZ1bmN0aW9uKHBvcykge1xcbiAgICAgIHZhciBtb2RlID0gdGhpcy5kb2MubW9kZTtcXG4gICAgICBpZiAoIW1vZGUuaW5uZXJNb2RlKSB7IHJldHVybiBtb2RlIH1cXG4gICAgICByZXR1cm4gQ29kZU1pcnJvci5pbm5lck1vZGUobW9kZSwgdGhpcy5nZXRUb2tlbkF0KHBvcykuc3RhdGUpLm1vZGVcXG4gICAgfSxcXG5cXG4gICAgZ2V0SGVscGVyOiBmdW5jdGlvbihwb3MsIHR5cGUpIHtcXG4gICAgICByZXR1cm4gdGhpcy5nZXRIZWxwZXJzKHBvcywgdHlwZSlbMF1cXG4gICAgfSxcXG5cXG4gICAgZ2V0SGVscGVyczogZnVuY3Rpb24ocG9zLCB0eXBlKSB7XFxuICAgICAgdmFyIHRoaXMkMSA9IHRoaXM7XFxuXFxuICAgICAgdmFyIGZvdW5kID0gW107XFxuICAgICAgaWYgKCFoZWxwZXJzLmhhc093blByb3BlcnR5KHR5cGUpKSB7IHJldHVybiBmb3VuZCB9XFxuICAgICAgdmFyIGhlbHAgPSBoZWxwZXJzW3R5cGVdLCBtb2RlID0gdGhpcy5nZXRNb2RlQXQocG9zKTtcXG4gICAgICBpZiAodHlwZW9mIG1vZGVbdHlwZV0gPT0gXFxcInN0cmluZ1xcXCIpIHtcXG4gICAgICAgIGlmIChoZWxwW21vZGVbdHlwZV1dKSB7IGZvdW5kLnB1c2goaGVscFttb2RlW3R5cGVdXSk7IH1cXG4gICAgICB9IGVsc2UgaWYgKG1vZGVbdHlwZV0pIHtcXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbW9kZVt0eXBlXS5sZW5ndGg7IGkrKykge1xcbiAgICAgICAgICB2YXIgdmFsID0gaGVscFttb2RlW3R5cGVdW2ldXTtcXG4gICAgICAgICAgaWYgKHZhbCkgeyBmb3VuZC5wdXNoKHZhbCk7IH1cXG4gICAgICAgIH1cXG4gICAgICB9IGVsc2UgaWYgKG1vZGUuaGVscGVyVHlwZSAmJiBoZWxwW21vZGUuaGVscGVyVHlwZV0pIHtcXG4gICAgICAgIGZvdW5kLnB1c2goaGVscFttb2RlLmhlbHBlclR5cGVdKTtcXG4gICAgICB9IGVsc2UgaWYgKGhlbHBbbW9kZS5uYW1lXSkge1xcbiAgICAgICAgZm91bmQucHVzaChoZWxwW21vZGUubmFtZV0pO1xcbiAgICAgIH1cXG4gICAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBoZWxwLl9nbG9iYWwubGVuZ3RoOyBpJDErKykge1xcbiAgICAgICAgdmFyIGN1ciA9IGhlbHAuX2dsb2JhbFtpJDFdO1xcbiAgICAgICAgaWYgKGN1ci5wcmVkKG1vZGUsIHRoaXMkMSkgJiYgaW5kZXhPZihmb3VuZCwgY3VyLnZhbCkgPT0gLTEpXFxuICAgICAgICAgIHsgZm91bmQucHVzaChjdXIudmFsKTsgfVxcbiAgICAgIH1cXG4gICAgICByZXR1cm4gZm91bmRcXG4gICAgfSxcXG5cXG4gICAgZ2V0U3RhdGVBZnRlcjogZnVuY3Rpb24obGluZSwgcHJlY2lzZSkge1xcbiAgICAgIHZhciBkb2MgPSB0aGlzLmRvYztcXG4gICAgICBsaW5lID0gY2xpcExpbmUoZG9jLCBsaW5lID09IG51bGwgPyBkb2MuZmlyc3QgKyBkb2Muc2l6ZSAtIDE6IGxpbmUpO1xcbiAgICAgIHJldHVybiBnZXRTdGF0ZUJlZm9yZSh0aGlzLCBsaW5lICsgMSwgcHJlY2lzZSlcXG4gICAgfSxcXG5cXG4gICAgY3Vyc29yQ29vcmRzOiBmdW5jdGlvbihzdGFydCwgbW9kZSkge1xcbiAgICAgIHZhciBwb3MsIHJhbmdlJCQxID0gdGhpcy5kb2Muc2VsLnByaW1hcnkoKTtcXG4gICAgICBpZiAoc3RhcnQgPT0gbnVsbCkgeyBwb3MgPSByYW5nZSQkMS5oZWFkOyB9XFxuICAgICAgZWxzZSBpZiAodHlwZW9mIHN0YXJ0ID09IFxcXCJvYmplY3RcXFwiKSB7IHBvcyA9IGNsaXBQb3ModGhpcy5kb2MsIHN0YXJ0KTsgfVxcbiAgICAgIGVsc2UgeyBwb3MgPSBzdGFydCA/IHJhbmdlJCQxLmZyb20oKSA6IHJhbmdlJCQxLnRvKCk7IH1cXG4gICAgICByZXR1cm4gY3Vyc29yQ29vcmRzKHRoaXMsIHBvcywgbW9kZSB8fCBcXFwicGFnZVxcXCIpXFxuICAgIH0sXFxuXFxuICAgIGNoYXJDb29yZHM6IGZ1bmN0aW9uKHBvcywgbW9kZSkge1xcbiAgICAgIHJldHVybiBjaGFyQ29vcmRzKHRoaXMsIGNsaXBQb3ModGhpcy5kb2MsIHBvcyksIG1vZGUgfHwgXFxcInBhZ2VcXFwiKVxcbiAgICB9LFxcblxcbiAgICBjb29yZHNDaGFyOiBmdW5jdGlvbihjb29yZHMsIG1vZGUpIHtcXG4gICAgICBjb29yZHMgPSBmcm9tQ29vcmRTeXN0ZW0odGhpcywgY29vcmRzLCBtb2RlIHx8IFxcXCJwYWdlXFxcIik7XFxuICAgICAgcmV0dXJuIGNvb3Jkc0NoYXIodGhpcywgY29vcmRzLmxlZnQsIGNvb3Jkcy50b3ApXFxuICAgIH0sXFxuXFxuICAgIGxpbmVBdEhlaWdodDogZnVuY3Rpb24oaGVpZ2h0LCBtb2RlKSB7XFxuICAgICAgaGVpZ2h0ID0gZnJvbUNvb3JkU3lzdGVtKHRoaXMsIHt0b3A6IGhlaWdodCwgbGVmdDogMH0sIG1vZGUgfHwgXFxcInBhZ2VcXFwiKS50b3A7XFxuICAgICAgcmV0dXJuIGxpbmVBdEhlaWdodCh0aGlzLmRvYywgaGVpZ2h0ICsgdGhpcy5kaXNwbGF5LnZpZXdPZmZzZXQpXFxuICAgIH0sXFxuICAgIGhlaWdodEF0TGluZTogZnVuY3Rpb24obGluZSwgbW9kZSwgaW5jbHVkZVdpZGdldHMpIHtcXG4gICAgICB2YXIgZW5kID0gZmFsc2UsIGxpbmVPYmo7XFxuICAgICAgaWYgKHR5cGVvZiBsaW5lID09IFxcXCJudW1iZXJcXFwiKSB7XFxuICAgICAgICB2YXIgbGFzdCA9IHRoaXMuZG9jLmZpcnN0ICsgdGhpcy5kb2Muc2l6ZSAtIDE7XFxuICAgICAgICBpZiAobGluZSA8IHRoaXMuZG9jLmZpcnN0KSB7IGxpbmUgPSB0aGlzLmRvYy5maXJzdDsgfVxcbiAgICAgICAgZWxzZSBpZiAobGluZSA+IGxhc3QpIHsgbGluZSA9IGxhc3Q7IGVuZCA9IHRydWU7IH1cXG4gICAgICAgIGxpbmVPYmogPSBnZXRMaW5lKHRoaXMuZG9jLCBsaW5lKTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgbGluZU9iaiA9IGxpbmU7XFxuICAgICAgfVxcbiAgICAgIHJldHVybiBpbnRvQ29vcmRTeXN0ZW0odGhpcywgbGluZU9iaiwge3RvcDogMCwgbGVmdDogMH0sIG1vZGUgfHwgXFxcInBhZ2VcXFwiLCBpbmNsdWRlV2lkZ2V0cyB8fCBlbmQpLnRvcCArXFxuICAgICAgICAoZW5kID8gdGhpcy5kb2MuaGVpZ2h0IC0gaGVpZ2h0QXRMaW5lKGxpbmVPYmopIDogMClcXG4gICAgfSxcXG5cXG4gICAgZGVmYXVsdFRleHRIZWlnaHQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGV4dEhlaWdodCh0aGlzLmRpc3BsYXkpIH0sXFxuICAgIGRlZmF1bHRDaGFyV2lkdGg6IGZ1bmN0aW9uKCkgeyByZXR1cm4gY2hhcldpZHRoKHRoaXMuZGlzcGxheSkgfSxcXG5cXG4gICAgZ2V0Vmlld3BvcnQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4ge2Zyb206IHRoaXMuZGlzcGxheS52aWV3RnJvbSwgdG86IHRoaXMuZGlzcGxheS52aWV3VG99fSxcXG5cXG4gICAgYWRkV2lkZ2V0OiBmdW5jdGlvbihwb3MsIG5vZGUsIHNjcm9sbCwgdmVydCwgaG9yaXopIHtcXG4gICAgICB2YXIgZGlzcGxheSA9IHRoaXMuZGlzcGxheTtcXG4gICAgICBwb3MgPSBjdXJzb3JDb29yZHModGhpcywgY2xpcFBvcyh0aGlzLmRvYywgcG9zKSk7XFxuICAgICAgdmFyIHRvcCA9IHBvcy5ib3R0b20sIGxlZnQgPSBwb3MubGVmdDtcXG4gICAgICBub2RlLnN0eWxlLnBvc2l0aW9uID0gXFxcImFic29sdXRlXFxcIjtcXG4gICAgICBub2RlLnNldEF0dHJpYnV0ZShcXFwiY20taWdub3JlLWV2ZW50c1xcXCIsIFxcXCJ0cnVlXFxcIik7XFxuICAgICAgdGhpcy5kaXNwbGF5LmlucHV0LnNldFVuZWRpdGFibGUobm9kZSk7XFxuICAgICAgZGlzcGxheS5zaXplci5hcHBlbmRDaGlsZChub2RlKTtcXG4gICAgICBpZiAodmVydCA9PSBcXFwib3ZlclxcXCIpIHtcXG4gICAgICAgIHRvcCA9IHBvcy50b3A7XFxuICAgICAgfSBlbHNlIGlmICh2ZXJ0ID09IFxcXCJhYm92ZVxcXCIgfHwgdmVydCA9PSBcXFwibmVhclxcXCIpIHtcXG4gICAgICAgIHZhciB2c3BhY2UgPSBNYXRoLm1heChkaXNwbGF5LndyYXBwZXIuY2xpZW50SGVpZ2h0LCB0aGlzLmRvYy5oZWlnaHQpLFxcbiAgICAgICAgaHNwYWNlID0gTWF0aC5tYXgoZGlzcGxheS5zaXplci5jbGllbnRXaWR0aCwgZGlzcGxheS5saW5lU3BhY2UuY2xpZW50V2lkdGgpO1xcbiAgICAgICAgLy8gRGVmYXVsdCB0byBwb3NpdGlvbmluZyBhYm92ZSAoaWYgc3BlY2lmaWVkIGFuZCBwb3NzaWJsZSk7IG90aGVyd2lzZSBkZWZhdWx0IHRvIHBvc2l0aW9uaW5nIGJlbG93XFxuICAgICAgICBpZiAoKHZlcnQgPT0gJ2Fib3ZlJyB8fCBwb3MuYm90dG9tICsgbm9kZS5vZmZzZXRIZWlnaHQgPiB2c3BhY2UpICYmIHBvcy50b3AgPiBub2RlLm9mZnNldEhlaWdodClcXG4gICAgICAgICAgeyB0b3AgPSBwb3MudG9wIC0gbm9kZS5vZmZzZXRIZWlnaHQ7IH1cXG4gICAgICAgIGVsc2UgaWYgKHBvcy5ib3R0b20gKyBub2RlLm9mZnNldEhlaWdodCA8PSB2c3BhY2UpXFxuICAgICAgICAgIHsgdG9wID0gcG9zLmJvdHRvbTsgfVxcbiAgICAgICAgaWYgKGxlZnQgKyBub2RlLm9mZnNldFdpZHRoID4gaHNwYWNlKVxcbiAgICAgICAgICB7IGxlZnQgPSBoc3BhY2UgLSBub2RlLm9mZnNldFdpZHRoOyB9XFxuICAgICAgfVxcbiAgICAgIG5vZGUuc3R5bGUudG9wID0gdG9wICsgXFxcInB4XFxcIjtcXG4gICAgICBub2RlLnN0eWxlLmxlZnQgPSBub2RlLnN0eWxlLnJpZ2h0ID0gXFxcIlxcXCI7XFxuICAgICAgaWYgKGhvcml6ID09IFxcXCJyaWdodFxcXCIpIHtcXG4gICAgICAgIGxlZnQgPSBkaXNwbGF5LnNpemVyLmNsaWVudFdpZHRoIC0gbm9kZS5vZmZzZXRXaWR0aDtcXG4gICAgICAgIG5vZGUuc3R5bGUucmlnaHQgPSBcXFwiMHB4XFxcIjtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgaWYgKGhvcml6ID09IFxcXCJsZWZ0XFxcIikgeyBsZWZ0ID0gMDsgfVxcbiAgICAgICAgZWxzZSBpZiAoaG9yaXogPT0gXFxcIm1pZGRsZVxcXCIpIHsgbGVmdCA9IChkaXNwbGF5LnNpemVyLmNsaWVudFdpZHRoIC0gbm9kZS5vZmZzZXRXaWR0aCkgLyAyOyB9XFxuICAgICAgICBub2RlLnN0eWxlLmxlZnQgPSBsZWZ0ICsgXFxcInB4XFxcIjtcXG4gICAgICB9XFxuICAgICAgaWYgKHNjcm9sbClcXG4gICAgICAgIHsgc2Nyb2xsSW50b1ZpZXcodGhpcywge2xlZnQ6IGxlZnQsIHRvcDogdG9wLCByaWdodDogbGVmdCArIG5vZGUub2Zmc2V0V2lkdGgsIGJvdHRvbTogdG9wICsgbm9kZS5vZmZzZXRIZWlnaHR9KTsgfVxcbiAgICB9LFxcblxcbiAgICB0cmlnZ2VyT25LZXlEb3duOiBtZXRob2RPcChvbktleURvd24pLFxcbiAgICB0cmlnZ2VyT25LZXlQcmVzczogbWV0aG9kT3Aob25LZXlQcmVzcyksXFxuICAgIHRyaWdnZXJPbktleVVwOiBvbktleVVwLFxcblxcbiAgICBleGVjQ29tbWFuZDogZnVuY3Rpb24oY21kKSB7XFxuICAgICAgaWYgKGNvbW1hbmRzLmhhc093blByb3BlcnR5KGNtZCkpXFxuICAgICAgICB7IHJldHVybiBjb21tYW5kc1tjbWRdLmNhbGwobnVsbCwgdGhpcykgfVxcbiAgICB9LFxcblxcbiAgICB0cmlnZ2VyRWxlY3RyaWM6IG1ldGhvZE9wKGZ1bmN0aW9uKHRleHQpIHsgdHJpZ2dlckVsZWN0cmljKHRoaXMsIHRleHQpOyB9KSxcXG5cXG4gICAgZmluZFBvc0g6IGZ1bmN0aW9uKGZyb20sIGFtb3VudCwgdW5pdCwgdmlzdWFsbHkpIHtcXG4gICAgICB2YXIgdGhpcyQxID0gdGhpcztcXG5cXG4gICAgICB2YXIgZGlyID0gMTtcXG4gICAgICBpZiAoYW1vdW50IDwgMCkgeyBkaXIgPSAtMTsgYW1vdW50ID0gLWFtb3VudDsgfVxcbiAgICAgIHZhciBjdXIgPSBjbGlwUG9zKHRoaXMuZG9jLCBmcm9tKTtcXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFtb3VudDsgKytpKSB7XFxuICAgICAgICBjdXIgPSBmaW5kUG9zSCh0aGlzJDEuZG9jLCBjdXIsIGRpciwgdW5pdCwgdmlzdWFsbHkpO1xcbiAgICAgICAgaWYgKGN1ci5oaXRTaWRlKSB7IGJyZWFrIH1cXG4gICAgICB9XFxuICAgICAgcmV0dXJuIGN1clxcbiAgICB9LFxcblxcbiAgICBtb3ZlSDogbWV0aG9kT3AoZnVuY3Rpb24oZGlyLCB1bml0KSB7XFxuICAgICAgdmFyIHRoaXMkMSA9IHRoaXM7XFxuXFxuICAgICAgdGhpcy5leHRlbmRTZWxlY3Rpb25zQnkoZnVuY3Rpb24gKHJhbmdlJCQxKSB7XFxuICAgICAgICBpZiAodGhpcyQxLmRpc3BsYXkuc2hpZnQgfHwgdGhpcyQxLmRvYy5leHRlbmQgfHwgcmFuZ2UkJDEuZW1wdHkoKSlcXG4gICAgICAgICAgeyByZXR1cm4gZmluZFBvc0godGhpcyQxLmRvYywgcmFuZ2UkJDEuaGVhZCwgZGlyLCB1bml0LCB0aGlzJDEub3B0aW9ucy5ydGxNb3ZlVmlzdWFsbHkpIH1cXG4gICAgICAgIGVsc2VcXG4gICAgICAgICAgeyByZXR1cm4gZGlyIDwgMCA/IHJhbmdlJCQxLmZyb20oKSA6IHJhbmdlJCQxLnRvKCkgfVxcbiAgICAgIH0sIHNlbF9tb3ZlKTtcXG4gICAgfSksXFxuXFxuICAgIGRlbGV0ZUg6IG1ldGhvZE9wKGZ1bmN0aW9uKGRpciwgdW5pdCkge1xcbiAgICAgIHZhciBzZWwgPSB0aGlzLmRvYy5zZWwsIGRvYyA9IHRoaXMuZG9jO1xcbiAgICAgIGlmIChzZWwuc29tZXRoaW5nU2VsZWN0ZWQoKSlcXG4gICAgICAgIHsgZG9jLnJlcGxhY2VTZWxlY3Rpb24oXFxcIlxcXCIsIG51bGwsIFxcXCIrZGVsZXRlXFxcIik7IH1cXG4gICAgICBlbHNlXFxuICAgICAgICB7IGRlbGV0ZU5lYXJTZWxlY3Rpb24odGhpcywgZnVuY3Rpb24gKHJhbmdlJCQxKSB7XFxuICAgICAgICAgIHZhciBvdGhlciA9IGZpbmRQb3NIKGRvYywgcmFuZ2UkJDEuaGVhZCwgZGlyLCB1bml0LCBmYWxzZSk7XFxuICAgICAgICAgIHJldHVybiBkaXIgPCAwID8ge2Zyb206IG90aGVyLCB0bzogcmFuZ2UkJDEuaGVhZH0gOiB7ZnJvbTogcmFuZ2UkJDEuaGVhZCwgdG86IG90aGVyfVxcbiAgICAgICAgfSk7IH1cXG4gICAgfSksXFxuXFxuICAgIGZpbmRQb3NWOiBmdW5jdGlvbihmcm9tLCBhbW91bnQsIHVuaXQsIGdvYWxDb2x1bW4pIHtcXG4gICAgICB2YXIgdGhpcyQxID0gdGhpcztcXG5cXG4gICAgICB2YXIgZGlyID0gMSwgeCA9IGdvYWxDb2x1bW47XFxuICAgICAgaWYgKGFtb3VudCA8IDApIHsgZGlyID0gLTE7IGFtb3VudCA9IC1hbW91bnQ7IH1cXG4gICAgICB2YXIgY3VyID0gY2xpcFBvcyh0aGlzLmRvYywgZnJvbSk7XFxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbW91bnQ7ICsraSkge1xcbiAgICAgICAgdmFyIGNvb3JkcyA9IGN1cnNvckNvb3Jkcyh0aGlzJDEsIGN1ciwgXFxcImRpdlxcXCIpO1xcbiAgICAgICAgaWYgKHggPT0gbnVsbCkgeyB4ID0gY29vcmRzLmxlZnQ7IH1cXG4gICAgICAgIGVsc2UgeyBjb29yZHMubGVmdCA9IHg7IH1cXG4gICAgICAgIGN1ciA9IGZpbmRQb3NWKHRoaXMkMSwgY29vcmRzLCBkaXIsIHVuaXQpO1xcbiAgICAgICAgaWYgKGN1ci5oaXRTaWRlKSB7IGJyZWFrIH1cXG4gICAgICB9XFxuICAgICAgcmV0dXJuIGN1clxcbiAgICB9LFxcblxcbiAgICBtb3ZlVjogbWV0aG9kT3AoZnVuY3Rpb24oZGlyLCB1bml0KSB7XFxuICAgICAgdmFyIHRoaXMkMSA9IHRoaXM7XFxuXFxuICAgICAgdmFyIGRvYyA9IHRoaXMuZG9jLCBnb2FscyA9IFtdO1xcbiAgICAgIHZhciBjb2xsYXBzZSA9ICF0aGlzLmRpc3BsYXkuc2hpZnQgJiYgIWRvYy5leHRlbmQgJiYgZG9jLnNlbC5zb21ldGhpbmdTZWxlY3RlZCgpO1xcbiAgICAgIGRvYy5leHRlbmRTZWxlY3Rpb25zQnkoZnVuY3Rpb24gKHJhbmdlJCQxKSB7XFxuICAgICAgICBpZiAoY29sbGFwc2UpXFxuICAgICAgICAgIHsgcmV0dXJuIGRpciA8IDAgPyByYW5nZSQkMS5mcm9tKCkgOiByYW5nZSQkMS50bygpIH1cXG4gICAgICAgIHZhciBoZWFkUG9zID0gY3Vyc29yQ29vcmRzKHRoaXMkMSwgcmFuZ2UkJDEuaGVhZCwgXFxcImRpdlxcXCIpO1xcbiAgICAgICAgaWYgKHJhbmdlJCQxLmdvYWxDb2x1bW4gIT0gbnVsbCkgeyBoZWFkUG9zLmxlZnQgPSByYW5nZSQkMS5nb2FsQ29sdW1uOyB9XFxuICAgICAgICBnb2Fscy5wdXNoKGhlYWRQb3MubGVmdCk7XFxuICAgICAgICB2YXIgcG9zID0gZmluZFBvc1YodGhpcyQxLCBoZWFkUG9zLCBkaXIsIHVuaXQpO1xcbiAgICAgICAgaWYgKHVuaXQgPT0gXFxcInBhZ2VcXFwiICYmIHJhbmdlJCQxID09IGRvYy5zZWwucHJpbWFyeSgpKVxcbiAgICAgICAgICB7IGFkZFRvU2Nyb2xsUG9zKHRoaXMkMSwgbnVsbCwgY2hhckNvb3Jkcyh0aGlzJDEsIHBvcywgXFxcImRpdlxcXCIpLnRvcCAtIGhlYWRQb3MudG9wKTsgfVxcbiAgICAgICAgcmV0dXJuIHBvc1xcbiAgICAgIH0sIHNlbF9tb3ZlKTtcXG4gICAgICBpZiAoZ29hbHMubGVuZ3RoKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgZG9jLnNlbC5yYW5nZXMubGVuZ3RoOyBpKyspXFxuICAgICAgICB7IGRvYy5zZWwucmFuZ2VzW2ldLmdvYWxDb2x1bW4gPSBnb2Fsc1tpXTsgfSB9XFxuICAgIH0pLFxcblxcbiAgICAvLyBGaW5kIHRoZSB3b3JkIGF0IHRoZSBnaXZlbiBwb3NpdGlvbiAoYXMgcmV0dXJuZWQgYnkgY29vcmRzQ2hhcikuXFxuICAgIGZpbmRXb3JkQXQ6IGZ1bmN0aW9uKHBvcykge1xcbiAgICAgIHZhciBkb2MgPSB0aGlzLmRvYywgbGluZSA9IGdldExpbmUoZG9jLCBwb3MubGluZSkudGV4dDtcXG4gICAgICB2YXIgc3RhcnQgPSBwb3MuY2gsIGVuZCA9IHBvcy5jaDtcXG4gICAgICBpZiAobGluZSkge1xcbiAgICAgICAgdmFyIGhlbHBlciA9IHRoaXMuZ2V0SGVscGVyKHBvcywgXFxcIndvcmRDaGFyc1xcXCIpO1xcbiAgICAgICAgaWYgKChwb3Muc3RpY2t5ID09IFxcXCJiZWZvcmVcXFwiIHx8IGVuZCA9PSBsaW5lLmxlbmd0aCkgJiYgc3RhcnQpIHsgLS1zdGFydDsgfSBlbHNlIHsgKytlbmQ7IH1cXG4gICAgICAgIHZhciBzdGFydENoYXIgPSBsaW5lLmNoYXJBdChzdGFydCk7XFxuICAgICAgICB2YXIgY2hlY2sgPSBpc1dvcmRDaGFyKHN0YXJ0Q2hhciwgaGVscGVyKVxcbiAgICAgICAgICA/IGZ1bmN0aW9uIChjaCkgeyByZXR1cm4gaXNXb3JkQ2hhcihjaCwgaGVscGVyKTsgfVxcbiAgICAgICAgICA6IC9cXFxccy8udGVzdChzdGFydENoYXIpID8gZnVuY3Rpb24gKGNoKSB7IHJldHVybiAvXFxcXHMvLnRlc3QoY2gpOyB9XFxuICAgICAgICAgIDogZnVuY3Rpb24gKGNoKSB7IHJldHVybiAoIS9cXFxccy8udGVzdChjaCkgJiYgIWlzV29yZENoYXIoY2gpKTsgfTtcXG4gICAgICAgIHdoaWxlIChzdGFydCA+IDAgJiYgY2hlY2sobGluZS5jaGFyQXQoc3RhcnQgLSAxKSkpIHsgLS1zdGFydDsgfVxcbiAgICAgICAgd2hpbGUgKGVuZCA8IGxpbmUubGVuZ3RoICYmIGNoZWNrKGxpbmUuY2hhckF0KGVuZCkpKSB7ICsrZW5kOyB9XFxuICAgICAgfVxcbiAgICAgIHJldHVybiBuZXcgUmFuZ2UoUG9zKHBvcy5saW5lLCBzdGFydCksIFBvcyhwb3MubGluZSwgZW5kKSlcXG4gICAgfSxcXG5cXG4gICAgdG9nZ2xlT3ZlcndyaXRlOiBmdW5jdGlvbih2YWx1ZSkge1xcbiAgICAgIGlmICh2YWx1ZSAhPSBudWxsICYmIHZhbHVlID09IHRoaXMuc3RhdGUub3ZlcndyaXRlKSB7IHJldHVybiB9XFxuICAgICAgaWYgKHRoaXMuc3RhdGUub3ZlcndyaXRlID0gIXRoaXMuc3RhdGUub3ZlcndyaXRlKVxcbiAgICAgICAgeyBhZGRDbGFzcyh0aGlzLmRpc3BsYXkuY3Vyc29yRGl2LCBcXFwiQ29kZU1pcnJvci1vdmVyd3JpdGVcXFwiKTsgfVxcbiAgICAgIGVsc2VcXG4gICAgICAgIHsgcm1DbGFzcyh0aGlzLmRpc3BsYXkuY3Vyc29yRGl2LCBcXFwiQ29kZU1pcnJvci1vdmVyd3JpdGVcXFwiKTsgfVxcblxcbiAgICAgIHNpZ25hbCh0aGlzLCBcXFwib3ZlcndyaXRlVG9nZ2xlXFxcIiwgdGhpcywgdGhpcy5zdGF0ZS5vdmVyd3JpdGUpO1xcbiAgICB9LFxcbiAgICBoYXNGb2N1czogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLmRpc3BsYXkuaW5wdXQuZ2V0RmllbGQoKSA9PSBhY3RpdmVFbHQoKSB9LFxcbiAgICBpc1JlYWRPbmx5OiBmdW5jdGlvbigpIHsgcmV0dXJuICEhKHRoaXMub3B0aW9ucy5yZWFkT25seSB8fCB0aGlzLmRvYy5jYW50RWRpdCkgfSxcXG5cXG4gICAgc2Nyb2xsVG86IG1ldGhvZE9wKGZ1bmN0aW9uKHgsIHkpIHtcXG4gICAgICBpZiAoeCAhPSBudWxsIHx8IHkgIT0gbnVsbCkgeyByZXNvbHZlU2Nyb2xsVG9Qb3ModGhpcyk7IH1cXG4gICAgICBpZiAoeCAhPSBudWxsKSB7IHRoaXMuY3VyT3Auc2Nyb2xsTGVmdCA9IHg7IH1cXG4gICAgICBpZiAoeSAhPSBudWxsKSB7IHRoaXMuY3VyT3Auc2Nyb2xsVG9wID0geTsgfVxcbiAgICB9KSxcXG4gICAgZ2V0U2Nyb2xsSW5mbzogZnVuY3Rpb24oKSB7XFxuICAgICAgdmFyIHNjcm9sbGVyID0gdGhpcy5kaXNwbGF5LnNjcm9sbGVyO1xcbiAgICAgIHJldHVybiB7bGVmdDogc2Nyb2xsZXIuc2Nyb2xsTGVmdCwgdG9wOiBzY3JvbGxlci5zY3JvbGxUb3AsXFxuICAgICAgICAgICAgICBoZWlnaHQ6IHNjcm9sbGVyLnNjcm9sbEhlaWdodCAtIHNjcm9sbEdhcCh0aGlzKSAtIHRoaXMuZGlzcGxheS5iYXJIZWlnaHQsXFxuICAgICAgICAgICAgICB3aWR0aDogc2Nyb2xsZXIuc2Nyb2xsV2lkdGggLSBzY3JvbGxHYXAodGhpcykgLSB0aGlzLmRpc3BsYXkuYmFyV2lkdGgsXFxuICAgICAgICAgICAgICBjbGllbnRIZWlnaHQ6IGRpc3BsYXlIZWlnaHQodGhpcyksIGNsaWVudFdpZHRoOiBkaXNwbGF5V2lkdGgodGhpcyl9XFxuICAgIH0sXFxuXFxuICAgIHNjcm9sbEludG9WaWV3OiBtZXRob2RPcChmdW5jdGlvbihyYW5nZSQkMSwgbWFyZ2luKSB7XFxuICAgICAgaWYgKHJhbmdlJCQxID09IG51bGwpIHtcXG4gICAgICAgIHJhbmdlJCQxID0ge2Zyb206IHRoaXMuZG9jLnNlbC5wcmltYXJ5KCkuaGVhZCwgdG86IG51bGx9O1xcbiAgICAgICAgaWYgKG1hcmdpbiA9PSBudWxsKSB7IG1hcmdpbiA9IHRoaXMub3B0aW9ucy5jdXJzb3JTY3JvbGxNYXJnaW47IH1cXG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiByYW5nZSQkMSA9PSBcXFwibnVtYmVyXFxcIikge1xcbiAgICAgICAgcmFuZ2UkJDEgPSB7ZnJvbTogUG9zKHJhbmdlJCQxLCAwKSwgdG86IG51bGx9O1xcbiAgICAgIH0gZWxzZSBpZiAocmFuZ2UkJDEuZnJvbSA9PSBudWxsKSB7XFxuICAgICAgICByYW5nZSQkMSA9IHtmcm9tOiByYW5nZSQkMSwgdG86IG51bGx9O1xcbiAgICAgIH1cXG4gICAgICBpZiAoIXJhbmdlJCQxLnRvKSB7IHJhbmdlJCQxLnRvID0gcmFuZ2UkJDEuZnJvbTsgfVxcbiAgICAgIHJhbmdlJCQxLm1hcmdpbiA9IG1hcmdpbiB8fCAwO1xcblxcbiAgICAgIGlmIChyYW5nZSQkMS5mcm9tLmxpbmUgIT0gbnVsbCkge1xcbiAgICAgICAgcmVzb2x2ZVNjcm9sbFRvUG9zKHRoaXMpO1xcbiAgICAgICAgdGhpcy5jdXJPcC5zY3JvbGxUb1BvcyA9IHJhbmdlJCQxO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICB2YXIgc1BvcyA9IGNhbGN1bGF0ZVNjcm9sbFBvcyh0aGlzLCB7XFxuICAgICAgICAgIGxlZnQ6IE1hdGgubWluKHJhbmdlJCQxLmZyb20ubGVmdCwgcmFuZ2UkJDEudG8ubGVmdCksXFxuICAgICAgICAgIHRvcDogTWF0aC5taW4ocmFuZ2UkJDEuZnJvbS50b3AsIHJhbmdlJCQxLnRvLnRvcCkgLSByYW5nZSQkMS5tYXJnaW4sXFxuICAgICAgICAgIHJpZ2h0OiBNYXRoLm1heChyYW5nZSQkMS5mcm9tLnJpZ2h0LCByYW5nZSQkMS50by5yaWdodCksXFxuICAgICAgICAgIGJvdHRvbTogTWF0aC5tYXgocmFuZ2UkJDEuZnJvbS5ib3R0b20sIHJhbmdlJCQxLnRvLmJvdHRvbSkgKyByYW5nZSQkMS5tYXJnaW5cXG4gICAgICAgIH0pO1xcbiAgICAgICAgdGhpcy5zY3JvbGxUbyhzUG9zLnNjcm9sbExlZnQsIHNQb3Muc2Nyb2xsVG9wKTtcXG4gICAgICB9XFxuICAgIH0pLFxcblxcbiAgICBzZXRTaXplOiBtZXRob2RPcChmdW5jdGlvbih3aWR0aCwgaGVpZ2h0KSB7XFxuICAgICAgdmFyIHRoaXMkMSA9IHRoaXM7XFxuXFxuICAgICAgdmFyIGludGVycHJldCA9IGZ1bmN0aW9uICh2YWwpIHsgcmV0dXJuIHR5cGVvZiB2YWwgPT0gXFxcIm51bWJlclxcXCIgfHwgL15cXFxcZCskLy50ZXN0KFN0cmluZyh2YWwpKSA/IHZhbCArIFxcXCJweFxcXCIgOiB2YWw7IH07XFxuICAgICAgaWYgKHdpZHRoICE9IG51bGwpIHsgdGhpcy5kaXNwbGF5LndyYXBwZXIuc3R5bGUud2lkdGggPSBpbnRlcnByZXQod2lkdGgpOyB9XFxuICAgICAgaWYgKGhlaWdodCAhPSBudWxsKSB7IHRoaXMuZGlzcGxheS53cmFwcGVyLnN0eWxlLmhlaWdodCA9IGludGVycHJldChoZWlnaHQpOyB9XFxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5saW5lV3JhcHBpbmcpIHsgY2xlYXJMaW5lTWVhc3VyZW1lbnRDYWNoZSh0aGlzKTsgfVxcbiAgICAgIHZhciBsaW5lTm8kJDEgPSB0aGlzLmRpc3BsYXkudmlld0Zyb207XFxuICAgICAgdGhpcy5kb2MuaXRlcihsaW5lTm8kJDEsIHRoaXMuZGlzcGxheS52aWV3VG8sIGZ1bmN0aW9uIChsaW5lKSB7XFxuICAgICAgICBpZiAobGluZS53aWRnZXRzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgbGluZS53aWRnZXRzLmxlbmd0aDsgaSsrKVxcbiAgICAgICAgICB7IGlmIChsaW5lLndpZGdldHNbaV0ubm9IU2Nyb2xsKSB7IHJlZ0xpbmVDaGFuZ2UodGhpcyQxLCBsaW5lTm8kJDEsIFxcXCJ3aWRnZXRcXFwiKTsgYnJlYWsgfSB9IH1cXG4gICAgICAgICsrbGluZU5vJCQxO1xcbiAgICAgIH0pO1xcbiAgICAgIHRoaXMuY3VyT3AuZm9yY2VVcGRhdGUgPSB0cnVlO1xcbiAgICAgIHNpZ25hbCh0aGlzLCBcXFwicmVmcmVzaFxcXCIsIHRoaXMpO1xcbiAgICB9KSxcXG5cXG4gICAgb3BlcmF0aW9uOiBmdW5jdGlvbihmKXtyZXR1cm4gcnVuSW5PcCh0aGlzLCBmKX0sXFxuXFxuICAgIHJlZnJlc2g6IG1ldGhvZE9wKGZ1bmN0aW9uKCkge1xcbiAgICAgIHZhciBvbGRIZWlnaHQgPSB0aGlzLmRpc3BsYXkuY2FjaGVkVGV4dEhlaWdodDtcXG4gICAgICByZWdDaGFuZ2UodGhpcyk7XFxuICAgICAgdGhpcy5jdXJPcC5mb3JjZVVwZGF0ZSA9IHRydWU7XFxuICAgICAgY2xlYXJDYWNoZXModGhpcyk7XFxuICAgICAgdGhpcy5zY3JvbGxUbyh0aGlzLmRvYy5zY3JvbGxMZWZ0LCB0aGlzLmRvYy5zY3JvbGxUb3ApO1xcbiAgICAgIHVwZGF0ZUd1dHRlclNwYWNlKHRoaXMpO1xcbiAgICAgIGlmIChvbGRIZWlnaHQgPT0gbnVsbCB8fCBNYXRoLmFicyhvbGRIZWlnaHQgLSB0ZXh0SGVpZ2h0KHRoaXMuZGlzcGxheSkpID4gLjUpXFxuICAgICAgICB7IGVzdGltYXRlTGluZUhlaWdodHModGhpcyk7IH1cXG4gICAgICBzaWduYWwodGhpcywgXFxcInJlZnJlc2hcXFwiLCB0aGlzKTtcXG4gICAgfSksXFxuXFxuICAgIHN3YXBEb2M6IG1ldGhvZE9wKGZ1bmN0aW9uKGRvYykge1xcbiAgICAgIHZhciBvbGQgPSB0aGlzLmRvYztcXG4gICAgICBvbGQuY20gPSBudWxsO1xcbiAgICAgIGF0dGFjaERvYyh0aGlzLCBkb2MpO1xcbiAgICAgIGNsZWFyQ2FjaGVzKHRoaXMpO1xcbiAgICAgIHRoaXMuZGlzcGxheS5pbnB1dC5yZXNldCgpO1xcbiAgICAgIHRoaXMuc2Nyb2xsVG8oZG9jLnNjcm9sbExlZnQsIGRvYy5zY3JvbGxUb3ApO1xcbiAgICAgIHRoaXMuY3VyT3AuZm9yY2VTY3JvbGwgPSB0cnVlO1xcbiAgICAgIHNpZ25hbExhdGVyKHRoaXMsIFxcXCJzd2FwRG9jXFxcIiwgdGhpcywgb2xkKTtcXG4gICAgICByZXR1cm4gb2xkXFxuICAgIH0pLFxcblxcbiAgICBnZXRJbnB1dEZpZWxkOiBmdW5jdGlvbigpe3JldHVybiB0aGlzLmRpc3BsYXkuaW5wdXQuZ2V0RmllbGQoKX0sXFxuICAgIGdldFdyYXBwZXJFbGVtZW50OiBmdW5jdGlvbigpe3JldHVybiB0aGlzLmRpc3BsYXkud3JhcHBlcn0sXFxuICAgIGdldFNjcm9sbGVyRWxlbWVudDogZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5kaXNwbGF5LnNjcm9sbGVyfSxcXG4gICAgZ2V0R3V0dGVyRWxlbWVudDogZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5kaXNwbGF5Lmd1dHRlcnN9XFxuICB9O1xcbiAgZXZlbnRNaXhpbihDb2RlTWlycm9yKTtcXG5cXG4gIENvZGVNaXJyb3IucmVnaXN0ZXJIZWxwZXIgPSBmdW5jdGlvbih0eXBlLCBuYW1lLCB2YWx1ZSkge1xcbiAgICBpZiAoIWhlbHBlcnMuaGFzT3duUHJvcGVydHkodHlwZSkpIHsgaGVscGVyc1t0eXBlXSA9IENvZGVNaXJyb3JbdHlwZV0gPSB7X2dsb2JhbDogW119OyB9XFxuICAgIGhlbHBlcnNbdHlwZV1bbmFtZV0gPSB2YWx1ZTtcXG4gIH07XFxuICBDb2RlTWlycm9yLnJlZ2lzdGVyR2xvYmFsSGVscGVyID0gZnVuY3Rpb24odHlwZSwgbmFtZSwgcHJlZGljYXRlLCB2YWx1ZSkge1xcbiAgICBDb2RlTWlycm9yLnJlZ2lzdGVySGVscGVyKHR5cGUsIG5hbWUsIHZhbHVlKTtcXG4gICAgaGVscGVyc1t0eXBlXS5fZ2xvYmFsLnB1c2goe3ByZWQ6IHByZWRpY2F0ZSwgdmFsOiB2YWx1ZX0pO1xcbiAgfTtcXG59O1xcblxcbi8vIFVzZWQgZm9yIGhvcml6b250YWwgcmVsYXRpdmUgbW90aW9uLiBEaXIgaXMgLTEgb3IgMSAobGVmdCBvclxcbi8vIHJpZ2h0KSwgdW5pdCBjYW4gYmUgXFxcImNoYXJcXFwiLCBcXFwiY29sdW1uXFxcIiAobGlrZSBjaGFyLCBidXQgZG9lc24ndFxcbi8vIGNyb3NzIGxpbmUgYm91bmRhcmllcyksIFxcXCJ3b3JkXFxcIiAoYWNyb3NzIG5leHQgd29yZCksIG9yIFxcXCJncm91cFxcXCIgKHRvXFxuLy8gdGhlIHN0YXJ0IG9mIG5leHQgZ3JvdXAgb2Ygd29yZCBvciBub24td29yZC1ub24td2hpdGVzcGFjZVxcbi8vIGNoYXJzKS4gVGhlIHZpc3VhbGx5IHBhcmFtIGNvbnRyb2xzIHdoZXRoZXIsIGluIHJpZ2h0LXRvLWxlZnRcXG4vLyB0ZXh0LCBkaXJlY3Rpb24gMSBtZWFucyB0byBtb3ZlIHRvd2FyZHMgdGhlIG5leHQgaW5kZXggaW4gdGhlXFxuLy8gc3RyaW5nLCBvciB0b3dhcmRzIHRoZSBjaGFyYWN0ZXIgdG8gdGhlIHJpZ2h0IG9mIHRoZSBjdXJyZW50XFxuLy8gcG9zaXRpb24uIFRoZSByZXN1bHRpbmcgcG9zaXRpb24gd2lsbCBoYXZlIGEgaGl0U2lkZT10cnVlXFxuLy8gcHJvcGVydHkgaWYgaXQgcmVhY2hlZCB0aGUgZW5kIG9mIHRoZSBkb2N1bWVudC5cXG5mdW5jdGlvbiBmaW5kUG9zSChkb2MsIHBvcywgZGlyLCB1bml0LCB2aXN1YWxseSkge1xcbiAgdmFyIG9sZFBvcyA9IHBvcztcXG4gIHZhciBvcmlnRGlyID0gZGlyO1xcbiAgdmFyIGxpbmVPYmogPSBnZXRMaW5lKGRvYywgcG9zLmxpbmUpO1xcbiAgZnVuY3Rpb24gZmluZE5leHRMaW5lKCkge1xcbiAgICB2YXIgbCA9IHBvcy5saW5lICsgZGlyO1xcbiAgICBpZiAobCA8IGRvYy5maXJzdCB8fCBsID49IGRvYy5maXJzdCArIGRvYy5zaXplKSB7IHJldHVybiBmYWxzZSB9XFxuICAgIHBvcyA9IG5ldyBQb3MobCwgcG9zLmNoLCBwb3Muc3RpY2t5KTtcXG4gICAgcmV0dXJuIGxpbmVPYmogPSBnZXRMaW5lKGRvYywgbClcXG4gIH1cXG4gIGZ1bmN0aW9uIG1vdmVPbmNlKGJvdW5kVG9MaW5lKSB7XFxuICAgIHZhciBuZXh0O1xcbiAgICBpZiAodmlzdWFsbHkpIHtcXG4gICAgICBuZXh0ID0gbW92ZVZpc3VhbGx5KGRvYy5jbSwgbGluZU9iaiwgcG9zLCBkaXIpO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIG5leHQgPSBtb3ZlTG9naWNhbGx5KGxpbmVPYmosIHBvcywgZGlyKTtcXG4gICAgfVxcbiAgICBpZiAobmV4dCA9PSBudWxsKSB7XFxuICAgICAgaWYgKCFib3VuZFRvTGluZSAmJiBmaW5kTmV4dExpbmUoKSlcXG4gICAgICAgIHsgcG9zID0gZW5kT2ZMaW5lKHZpc3VhbGx5LCBkb2MuY20sIGxpbmVPYmosIHBvcy5saW5lLCBkaXIpOyB9XFxuICAgICAgZWxzZVxcbiAgICAgICAgeyByZXR1cm4gZmFsc2UgfVxcbiAgICB9IGVsc2Uge1xcbiAgICAgIHBvcyA9IG5leHQ7XFxuICAgIH1cXG4gICAgcmV0dXJuIHRydWVcXG4gIH1cXG5cXG4gIGlmICh1bml0ID09IFxcXCJjaGFyXFxcIikge1xcbiAgICBtb3ZlT25jZSgpO1xcbiAgfSBlbHNlIGlmICh1bml0ID09IFxcXCJjb2x1bW5cXFwiKSB7XFxuICAgIG1vdmVPbmNlKHRydWUpO1xcbiAgfSBlbHNlIGlmICh1bml0ID09IFxcXCJ3b3JkXFxcIiB8fCB1bml0ID09IFxcXCJncm91cFxcXCIpIHtcXG4gICAgdmFyIHNhd1R5cGUgPSBudWxsLCBncm91cCA9IHVuaXQgPT0gXFxcImdyb3VwXFxcIjtcXG4gICAgdmFyIGhlbHBlciA9IGRvYy5jbSAmJiBkb2MuY20uZ2V0SGVscGVyKHBvcywgXFxcIndvcmRDaGFyc1xcXCIpO1xcbiAgICBmb3IgKHZhciBmaXJzdCA9IHRydWU7OyBmaXJzdCA9IGZhbHNlKSB7XFxuICAgICAgaWYgKGRpciA8IDAgJiYgIW1vdmVPbmNlKCFmaXJzdCkpIHsgYnJlYWsgfVxcbiAgICAgIHZhciBjdXIgPSBsaW5lT2JqLnRleHQuY2hhckF0KHBvcy5jaCkgfHwgXFxcIlxcXFxuXFxcIjtcXG4gICAgICB2YXIgdHlwZSA9IGlzV29yZENoYXIoY3VyLCBoZWxwZXIpID8gXFxcIndcXFwiXFxuICAgICAgICA6IGdyb3VwICYmIGN1ciA9PSBcXFwiXFxcXG5cXFwiID8gXFxcIm5cXFwiXFxuICAgICAgICA6ICFncm91cCB8fCAvXFxcXHMvLnRlc3QoY3VyKSA/IG51bGxcXG4gICAgICAgIDogXFxcInBcXFwiO1xcbiAgICAgIGlmIChncm91cCAmJiAhZmlyc3QgJiYgIXR5cGUpIHsgdHlwZSA9IFxcXCJzXFxcIjsgfVxcbiAgICAgIGlmIChzYXdUeXBlICYmIHNhd1R5cGUgIT0gdHlwZSkge1xcbiAgICAgICAgaWYgKGRpciA8IDApIHtkaXIgPSAxOyBtb3ZlT25jZSgpOyBwb3Muc3RpY2t5ID0gXFxcImFmdGVyXFxcIjt9XFxuICAgICAgICBicmVha1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAodHlwZSkgeyBzYXdUeXBlID0gdHlwZTsgfVxcbiAgICAgIGlmIChkaXIgPiAwICYmICFtb3ZlT25jZSghZmlyc3QpKSB7IGJyZWFrIH1cXG4gICAgfVxcbiAgfVxcbiAgdmFyIHJlc3VsdCA9IHNraXBBdG9taWMoZG9jLCBwb3MsIG9sZFBvcywgb3JpZ0RpciwgdHJ1ZSk7XFxuICBpZiAoZXF1YWxDdXJzb3JQb3Mob2xkUG9zLCByZXN1bHQpKSB7IHJlc3VsdC5oaXRTaWRlID0gdHJ1ZTsgfVxcbiAgcmV0dXJuIHJlc3VsdFxcbn1cXG5cXG4vLyBGb3IgcmVsYXRpdmUgdmVydGljYWwgbW92ZW1lbnQuIERpciBtYXkgYmUgLTEgb3IgMS4gVW5pdCBjYW4gYmVcXG4vLyBcXFwicGFnZVxcXCIgb3IgXFxcImxpbmVcXFwiLiBUaGUgcmVzdWx0aW5nIHBvc2l0aW9uIHdpbGwgaGF2ZSBhIGhpdFNpZGU9dHJ1ZVxcbi8vIHByb3BlcnR5IGlmIGl0IHJlYWNoZWQgdGhlIGVuZCBvZiB0aGUgZG9jdW1lbnQuXFxuZnVuY3Rpb24gZmluZFBvc1YoY20sIHBvcywgZGlyLCB1bml0KSB7XFxuICB2YXIgZG9jID0gY20uZG9jLCB4ID0gcG9zLmxlZnQsIHk7XFxuICBpZiAodW5pdCA9PSBcXFwicGFnZVxcXCIpIHtcXG4gICAgdmFyIHBhZ2VTaXplID0gTWF0aC5taW4oY20uZGlzcGxheS53cmFwcGVyLmNsaWVudEhlaWdodCwgd2luZG93LmlubmVySGVpZ2h0IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQpO1xcbiAgICB2YXIgbW92ZUFtb3VudCA9IE1hdGgubWF4KHBhZ2VTaXplIC0gLjUgKiB0ZXh0SGVpZ2h0KGNtLmRpc3BsYXkpLCAzKTtcXG4gICAgeSA9IChkaXIgPiAwID8gcG9zLmJvdHRvbSA6IHBvcy50b3ApICsgZGlyICogbW92ZUFtb3VudDtcXG5cXG4gIH0gZWxzZSBpZiAodW5pdCA9PSBcXFwibGluZVxcXCIpIHtcXG4gICAgeSA9IGRpciA+IDAgPyBwb3MuYm90dG9tICsgMyA6IHBvcy50b3AgLSAzO1xcbiAgfVxcbiAgdmFyIHRhcmdldDtcXG4gIGZvciAoOzspIHtcXG4gICAgdGFyZ2V0ID0gY29vcmRzQ2hhcihjbSwgeCwgeSk7XFxuICAgIGlmICghdGFyZ2V0Lm91dHNpZGUpIHsgYnJlYWsgfVxcbiAgICBpZiAoZGlyIDwgMCA/IHkgPD0gMCA6IHkgPj0gZG9jLmhlaWdodCkgeyB0YXJnZXQuaGl0U2lkZSA9IHRydWU7IGJyZWFrIH1cXG4gICAgeSArPSBkaXIgKiA1O1xcbiAgfVxcbiAgcmV0dXJuIHRhcmdldFxcbn1cXG5cXG4vLyBDT05URU5URURJVEFCTEUgSU5QVVQgU1RZTEVcXG5cXG52YXIgQ29udGVudEVkaXRhYmxlSW5wdXQgPSBmdW5jdGlvbihjbSkge1xcbiAgdGhpcy5jbSA9IGNtO1xcbiAgdGhpcy5sYXN0QW5jaG9yTm9kZSA9IHRoaXMubGFzdEFuY2hvck9mZnNldCA9IHRoaXMubGFzdEZvY3VzTm9kZSA9IHRoaXMubGFzdEZvY3VzT2Zmc2V0ID0gbnVsbDtcXG4gIHRoaXMucG9sbGluZyA9IG5ldyBEZWxheWVkKCk7XFxuICB0aGlzLmNvbXBvc2luZyA9IG51bGw7XFxuICB0aGlzLmdyYWNlUGVyaW9kID0gZmFsc2U7XFxuICB0aGlzLnJlYWRET01UaW1lb3V0ID0gbnVsbDtcXG59O1xcblxcbkNvbnRlbnRFZGl0YWJsZUlucHV0LnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKGRpc3BsYXkpIHtcXG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XFxuXFxuICB2YXIgaW5wdXQgPSB0aGlzLCBjbSA9IGlucHV0LmNtO1xcbiAgdmFyIGRpdiA9IGlucHV0LmRpdiA9IGRpc3BsYXkubGluZURpdjtcXG4gIGRpc2FibGVCcm93c2VyTWFnaWMoZGl2LCBjbS5vcHRpb25zLnNwZWxsY2hlY2spO1xcblxcbiAgb24oZGl2LCBcXFwicGFzdGVcXFwiLCBmdW5jdGlvbiAoZSkge1xcbiAgICBpZiAoc2lnbmFsRE9NRXZlbnQoY20sIGUpIHx8IGhhbmRsZVBhc3RlKGUsIGNtKSkgeyByZXR1cm4gfVxcbiAgICAvLyBJRSBkb2Vzbid0IGZpcmUgaW5wdXQgZXZlbnRzLCBzbyB3ZSBzY2hlZHVsZSBhIHJlYWQgZm9yIHRoZSBwYXN0ZWQgY29udGVudCBpbiB0aGlzIHdheVxcbiAgICBpZiAoaWVfdmVyc2lvbiA8PSAxMSkgeyBzZXRUaW1lb3V0KG9wZXJhdGlvbihjbSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcyQxLnVwZGF0ZUZyb21ET00oKTsgfSksIDIwKTsgfVxcbiAgfSk7XFxuXFxuICBvbihkaXYsIFxcXCJjb21wb3NpdGlvbnN0YXJ0XFxcIiwgZnVuY3Rpb24gKGUpIHtcXG4gICAgdGhpcyQxLmNvbXBvc2luZyA9IHtkYXRhOiBlLmRhdGEsIGRvbmU6IGZhbHNlfTtcXG4gIH0pO1xcbiAgb24oZGl2LCBcXFwiY29tcG9zaXRpb251cGRhdGVcXFwiLCBmdW5jdGlvbiAoZSkge1xcbiAgICBpZiAoIXRoaXMkMS5jb21wb3NpbmcpIHsgdGhpcyQxLmNvbXBvc2luZyA9IHtkYXRhOiBlLmRhdGEsIGRvbmU6IGZhbHNlfTsgfVxcbiAgfSk7XFxuICBvbihkaXYsIFxcXCJjb21wb3NpdGlvbmVuZFxcXCIsIGZ1bmN0aW9uIChlKSB7XFxuICAgIGlmICh0aGlzJDEuY29tcG9zaW5nKSB7XFxuICAgICAgaWYgKGUuZGF0YSAhPSB0aGlzJDEuY29tcG9zaW5nLmRhdGEpIHsgdGhpcyQxLnJlYWRGcm9tRE9NU29vbigpOyB9XFxuICAgICAgdGhpcyQxLmNvbXBvc2luZy5kb25lID0gdHJ1ZTtcXG4gICAgfVxcbiAgfSk7XFxuXFxuICBvbihkaXYsIFxcXCJ0b3VjaHN0YXJ0XFxcIiwgZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5wdXQuZm9yY2VDb21wb3NpdGlvbkVuZCgpOyB9KTtcXG5cXG4gIG9uKGRpdiwgXFxcImlucHV0XFxcIiwgZnVuY3Rpb24gKCkge1xcbiAgICBpZiAoIXRoaXMkMS5jb21wb3NpbmcpIHsgdGhpcyQxLnJlYWRGcm9tRE9NU29vbigpOyB9XFxuICB9KTtcXG5cXG4gIGZ1bmN0aW9uIG9uQ29weUN1dChlKSB7XFxuICAgIGlmIChzaWduYWxET01FdmVudChjbSwgZSkpIHsgcmV0dXJuIH1cXG4gICAgaWYgKGNtLnNvbWV0aGluZ1NlbGVjdGVkKCkpIHtcXG4gICAgICBzZXRMYXN0Q29waWVkKHtsaW5lV2lzZTogZmFsc2UsIHRleHQ6IGNtLmdldFNlbGVjdGlvbnMoKX0pO1xcbiAgICAgIGlmIChlLnR5cGUgPT0gXFxcImN1dFxcXCIpIHsgY20ucmVwbGFjZVNlbGVjdGlvbihcXFwiXFxcIiwgbnVsbCwgXFxcImN1dFxcXCIpOyB9XFxuICAgIH0gZWxzZSBpZiAoIWNtLm9wdGlvbnMubGluZVdpc2VDb3B5Q3V0KSB7XFxuICAgICAgcmV0dXJuXFxuICAgIH0gZWxzZSB7XFxuICAgICAgdmFyIHJhbmdlcyA9IGNvcHlhYmxlUmFuZ2VzKGNtKTtcXG4gICAgICBzZXRMYXN0Q29waWVkKHtsaW5lV2lzZTogdHJ1ZSwgdGV4dDogcmFuZ2VzLnRleHR9KTtcXG4gICAgICBpZiAoZS50eXBlID09IFxcXCJjdXRcXFwiKSB7XFxuICAgICAgICBjbS5vcGVyYXRpb24oZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICBjbS5zZXRTZWxlY3Rpb25zKHJhbmdlcy5yYW5nZXMsIDAsIHNlbF9kb250U2Nyb2xsKTtcXG4gICAgICAgICAgY20ucmVwbGFjZVNlbGVjdGlvbihcXFwiXFxcIiwgbnVsbCwgXFxcImN1dFxcXCIpO1xcbiAgICAgICAgfSk7XFxuICAgICAgfVxcbiAgICB9XFxuICAgIGlmIChlLmNsaXBib2FyZERhdGEpIHtcXG4gICAgICBlLmNsaXBib2FyZERhdGEuY2xlYXJEYXRhKCk7XFxuICAgICAgdmFyIGNvbnRlbnQgPSBsYXN0Q29waWVkLnRleHQuam9pbihcXFwiXFxcXG5cXFwiKTtcXG4gICAgICAvLyBpT1MgZXhwb3NlcyB0aGUgY2xpcGJvYXJkIEFQSSwgYnV0IHNlZW1zIHRvIGRpc2NhcmQgY29udGVudCBpbnNlcnRlZCBpbnRvIGl0XFxuICAgICAgZS5jbGlwYm9hcmREYXRhLnNldERhdGEoXFxcIlRleHRcXFwiLCBjb250ZW50KTtcXG4gICAgICBpZiAoZS5jbGlwYm9hcmREYXRhLmdldERhdGEoXFxcIlRleHRcXFwiKSA9PSBjb250ZW50KSB7XFxuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XFxuICAgICAgICByZXR1cm5cXG4gICAgICB9XFxuICAgIH1cXG4gICAgLy8gT2xkLWZhc2hpb25lZCBicmllZmx5LWZvY3VzLWEtdGV4dGFyZWEgaGFja1xcbiAgICB2YXIga2x1ZGdlID0gaGlkZGVuVGV4dGFyZWEoKSwgdGUgPSBrbHVkZ2UuZmlyc3RDaGlsZDtcXG4gICAgY20uZGlzcGxheS5saW5lU3BhY2UuaW5zZXJ0QmVmb3JlKGtsdWRnZSwgY20uZGlzcGxheS5saW5lU3BhY2UuZmlyc3RDaGlsZCk7XFxuICAgIHRlLnZhbHVlID0gbGFzdENvcGllZC50ZXh0LmpvaW4oXFxcIlxcXFxuXFxcIik7XFxuICAgIHZhciBoYWRGb2N1cyA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XFxuICAgIHNlbGVjdElucHV0KHRlKTtcXG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XFxuICAgICAgY20uZGlzcGxheS5saW5lU3BhY2UucmVtb3ZlQ2hpbGQoa2x1ZGdlKTtcXG4gICAgICBoYWRGb2N1cy5mb2N1cygpO1xcbiAgICAgIGlmIChoYWRGb2N1cyA9PSBkaXYpIHsgaW5wdXQuc2hvd1ByaW1hcnlTZWxlY3Rpb24oKTsgfVxcbiAgICB9LCA1MCk7XFxuICB9XFxuICBvbihkaXYsIFxcXCJjb3B5XFxcIiwgb25Db3B5Q3V0KTtcXG4gIG9uKGRpdiwgXFxcImN1dFxcXCIsIG9uQ29weUN1dCk7XFxufTtcXG5cXG5Db250ZW50RWRpdGFibGVJbnB1dC5wcm90b3R5cGUucHJlcGFyZVNlbGVjdGlvbiA9IGZ1bmN0aW9uICgpIHtcXG4gIHZhciByZXN1bHQgPSBwcmVwYXJlU2VsZWN0aW9uKHRoaXMuY20sIGZhbHNlKTtcXG4gIHJlc3VsdC5mb2N1cyA9IHRoaXMuY20uc3RhdGUuZm9jdXNlZDtcXG4gIHJldHVybiByZXN1bHRcXG59O1xcblxcbkNvbnRlbnRFZGl0YWJsZUlucHV0LnByb3RvdHlwZS5zaG93U2VsZWN0aW9uID0gZnVuY3Rpb24gKGluZm8sIHRha2VGb2N1cykge1xcbiAgaWYgKCFpbmZvIHx8ICF0aGlzLmNtLmRpc3BsYXkudmlldy5sZW5ndGgpIHsgcmV0dXJuIH1cXG4gIGlmIChpbmZvLmZvY3VzIHx8IHRha2VGb2N1cykgeyB0aGlzLnNob3dQcmltYXJ5U2VsZWN0aW9uKCk7IH1cXG4gIHRoaXMuc2hvd011bHRpcGxlU2VsZWN0aW9ucyhpbmZvKTtcXG59O1xcblxcbkNvbnRlbnRFZGl0YWJsZUlucHV0LnByb3RvdHlwZS5zaG93UHJpbWFyeVNlbGVjdGlvbiA9IGZ1bmN0aW9uICgpIHtcXG4gIHZhciBzZWwgPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCksIHByaW0gPSB0aGlzLmNtLmRvYy5zZWwucHJpbWFyeSgpO1xcbiAgdmFyIGN1ckFuY2hvciA9IGRvbVRvUG9zKHRoaXMuY20sIHNlbC5hbmNob3JOb2RlLCBzZWwuYW5jaG9yT2Zmc2V0KTtcXG4gIHZhciBjdXJGb2N1cyA9IGRvbVRvUG9zKHRoaXMuY20sIHNlbC5mb2N1c05vZGUsIHNlbC5mb2N1c09mZnNldCk7XFxuICBpZiAoY3VyQW5jaG9yICYmICFjdXJBbmNob3IuYmFkICYmIGN1ckZvY3VzICYmICFjdXJGb2N1cy5iYWQgJiZcXG4gICAgICBjbXAobWluUG9zKGN1ckFuY2hvciwgY3VyRm9jdXMpLCBwcmltLmZyb20oKSkgPT0gMCAmJlxcbiAgICAgIGNtcChtYXhQb3MoY3VyQW5jaG9yLCBjdXJGb2N1cyksIHByaW0udG8oKSkgPT0gMClcXG4gICAgeyByZXR1cm4gfVxcblxcbiAgdmFyIHN0YXJ0ID0gcG9zVG9ET00odGhpcy5jbSwgcHJpbS5mcm9tKCkpO1xcbiAgdmFyIGVuZCA9IHBvc1RvRE9NKHRoaXMuY20sIHByaW0udG8oKSk7XFxuICBpZiAoIXN0YXJ0ICYmICFlbmQpIHtcXG4gICAgc2VsLnJlbW92ZUFsbFJhbmdlcygpO1xcbiAgICByZXR1cm5cXG4gIH1cXG5cXG4gIHZhciB2aWV3ID0gdGhpcy5jbS5kaXNwbGF5LnZpZXc7XFxuICB2YXIgb2xkID0gc2VsLnJhbmdlQ291bnQgJiYgc2VsLmdldFJhbmdlQXQoMCk7XFxuICBpZiAoIXN0YXJ0KSB7XFxuICAgIHN0YXJ0ID0ge25vZGU6IHZpZXdbMF0ubWVhc3VyZS5tYXBbMl0sIG9mZnNldDogMH07XFxuICB9IGVsc2UgaWYgKCFlbmQpIHsgLy8gRklYTUUgZGFuZ2Vyb3VzbHkgaGFja3lcXG4gICAgdmFyIG1lYXN1cmUgPSB2aWV3W3ZpZXcubGVuZ3RoIC0gMV0ubWVhc3VyZTtcXG4gICAgdmFyIG1hcCQkMSA9IG1lYXN1cmUubWFwcyA/IG1lYXN1cmUubWFwc1ttZWFzdXJlLm1hcHMubGVuZ3RoIC0gMV0gOiBtZWFzdXJlLm1hcDtcXG4gICAgZW5kID0ge25vZGU6IG1hcCQkMVttYXAkJDEubGVuZ3RoIC0gMV0sIG9mZnNldDogbWFwJCQxW21hcCQkMS5sZW5ndGggLSAyXSAtIG1hcCQkMVttYXAkJDEubGVuZ3RoIC0gM119O1xcbiAgfVxcblxcbiAgdmFyIHJuZztcXG4gIHRyeSB7IHJuZyA9IHJhbmdlKHN0YXJ0Lm5vZGUsIHN0YXJ0Lm9mZnNldCwgZW5kLm9mZnNldCwgZW5kLm5vZGUpOyB9XFxuICBjYXRjaChlKSB7fSAvLyBPdXIgbW9kZWwgb2YgdGhlIERPTSBtaWdodCBiZSBvdXRkYXRlZCwgaW4gd2hpY2ggY2FzZSB0aGUgcmFuZ2Ugd2UgdHJ5IHRvIHNldCBjYW4gYmUgaW1wb3NzaWJsZVxcbiAgaWYgKHJuZykge1xcbiAgICBpZiAoIWdlY2tvICYmIHRoaXMuY20uc3RhdGUuZm9jdXNlZCkge1xcbiAgICAgIHNlbC5jb2xsYXBzZShzdGFydC5ub2RlLCBzdGFydC5vZmZzZXQpO1xcbiAgICAgIGlmICghcm5nLmNvbGxhcHNlZCkge1xcbiAgICAgICAgc2VsLnJlbW92ZUFsbFJhbmdlcygpO1xcbiAgICAgICAgc2VsLmFkZFJhbmdlKHJuZyk7XFxuICAgICAgfVxcbiAgICB9IGVsc2Uge1xcbiAgICAgIHNlbC5yZW1vdmVBbGxSYW5nZXMoKTtcXG4gICAgICBzZWwuYWRkUmFuZ2Uocm5nKTtcXG4gICAgfVxcbiAgICBpZiAob2xkICYmIHNlbC5hbmNob3JOb2RlID09IG51bGwpIHsgc2VsLmFkZFJhbmdlKG9sZCk7IH1cXG4gICAgZWxzZSBpZiAoZ2Vja28pIHsgdGhpcy5zdGFydEdyYWNlUGVyaW9kKCk7IH1cXG4gIH1cXG4gIHRoaXMucmVtZW1iZXJTZWxlY3Rpb24oKTtcXG59O1xcblxcbkNvbnRlbnRFZGl0YWJsZUlucHV0LnByb3RvdHlwZS5zdGFydEdyYWNlUGVyaW9kID0gZnVuY3Rpb24gKCkge1xcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcXG5cXG4gIGNsZWFyVGltZW91dCh0aGlzLmdyYWNlUGVyaW9kKTtcXG4gIHRoaXMuZ3JhY2VQZXJpb2QgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcXG4gICAgdGhpcyQxLmdyYWNlUGVyaW9kID0gZmFsc2U7XFxuICAgIGlmICh0aGlzJDEuc2VsZWN0aW9uQ2hhbmdlZCgpKVxcbiAgICAgIHsgdGhpcyQxLmNtLm9wZXJhdGlvbihmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzJDEuY20uY3VyT3Auc2VsZWN0aW9uQ2hhbmdlZCA9IHRydWU7IH0pOyB9XFxuICB9LCAyMCk7XFxufTtcXG5cXG5Db250ZW50RWRpdGFibGVJbnB1dC5wcm90b3R5cGUuc2hvd011bHRpcGxlU2VsZWN0aW9ucyA9IGZ1bmN0aW9uIChpbmZvKSB7XFxuICByZW1vdmVDaGlsZHJlbkFuZEFkZCh0aGlzLmNtLmRpc3BsYXkuY3Vyc29yRGl2LCBpbmZvLmN1cnNvcnMpO1xcbiAgcmVtb3ZlQ2hpbGRyZW5BbmRBZGQodGhpcy5jbS5kaXNwbGF5LnNlbGVjdGlvbkRpdiwgaW5mby5zZWxlY3Rpb24pO1xcbn07XFxuXFxuQ29udGVudEVkaXRhYmxlSW5wdXQucHJvdG90eXBlLnJlbWVtYmVyU2VsZWN0aW9uID0gZnVuY3Rpb24gKCkge1xcbiAgdmFyIHNlbCA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKTtcXG4gIHRoaXMubGFzdEFuY2hvck5vZGUgPSBzZWwuYW5jaG9yTm9kZTsgdGhpcy5sYXN0QW5jaG9yT2Zmc2V0ID0gc2VsLmFuY2hvck9mZnNldDtcXG4gIHRoaXMubGFzdEZvY3VzTm9kZSA9IHNlbC5mb2N1c05vZGU7IHRoaXMubGFzdEZvY3VzT2Zmc2V0ID0gc2VsLmZvY3VzT2Zmc2V0O1xcbn07XFxuXFxuQ29udGVudEVkaXRhYmxlSW5wdXQucHJvdG90eXBlLnNlbGVjdGlvbkluRWRpdG9yID0gZnVuY3Rpb24gKCkge1xcbiAgdmFyIHNlbCA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKTtcXG4gIGlmICghc2VsLnJhbmdlQ291bnQpIHsgcmV0dXJuIGZhbHNlIH1cXG4gIHZhciBub2RlID0gc2VsLmdldFJhbmdlQXQoMCkuY29tbW9uQW5jZXN0b3JDb250YWluZXI7XFxuICByZXR1cm4gY29udGFpbnModGhpcy5kaXYsIG5vZGUpXFxufTtcXG5cXG5Db250ZW50RWRpdGFibGVJbnB1dC5wcm90b3R5cGUuZm9jdXMgPSBmdW5jdGlvbiAoKSB7XFxuICBpZiAodGhpcy5jbS5vcHRpb25zLnJlYWRPbmx5ICE9IFxcXCJub2N1cnNvclxcXCIpIHtcXG4gICAgaWYgKCF0aGlzLnNlbGVjdGlvbkluRWRpdG9yKCkpXFxuICAgICAgeyB0aGlzLnNob3dTZWxlY3Rpb24odGhpcy5wcmVwYXJlU2VsZWN0aW9uKCksIHRydWUpOyB9XFxuICAgIHRoaXMuZGl2LmZvY3VzKCk7XFxuICB9XFxufTtcXG5Db250ZW50RWRpdGFibGVJbnB1dC5wcm90b3R5cGUuYmx1ciA9IGZ1bmN0aW9uICgpIHsgdGhpcy5kaXYuYmx1cigpOyB9O1xcbkNvbnRlbnRFZGl0YWJsZUlucHV0LnByb3RvdHlwZS5nZXRGaWVsZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuZGl2IH07XFxuXFxuQ29udGVudEVkaXRhYmxlSW5wdXQucHJvdG90eXBlLnN1cHBvcnRzVG91Y2ggPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0cnVlIH07XFxuXFxuQ29udGVudEVkaXRhYmxlSW5wdXQucHJvdG90eXBlLnJlY2VpdmVkRm9jdXMgPSBmdW5jdGlvbiAoKSB7XFxuICB2YXIgaW5wdXQgPSB0aGlzO1xcbiAgaWYgKHRoaXMuc2VsZWN0aW9uSW5FZGl0b3IoKSlcXG4gICAgeyB0aGlzLnBvbGxTZWxlY3Rpb24oKTsgfVxcbiAgZWxzZVxcbiAgICB7IHJ1bkluT3AodGhpcy5jbSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5wdXQuY20uY3VyT3Auc2VsZWN0aW9uQ2hhbmdlZCA9IHRydWU7IH0pOyB9XFxuXFxuICBmdW5jdGlvbiBwb2xsKCkge1xcbiAgICBpZiAoaW5wdXQuY20uc3RhdGUuZm9jdXNlZCkge1xcbiAgICAgIGlucHV0LnBvbGxTZWxlY3Rpb24oKTtcXG4gICAgICBpbnB1dC5wb2xsaW5nLnNldChpbnB1dC5jbS5vcHRpb25zLnBvbGxJbnRlcnZhbCwgcG9sbCk7XFxuICAgIH1cXG4gIH1cXG4gIHRoaXMucG9sbGluZy5zZXQodGhpcy5jbS5vcHRpb25zLnBvbGxJbnRlcnZhbCwgcG9sbCk7XFxufTtcXG5cXG5Db250ZW50RWRpdGFibGVJbnB1dC5wcm90b3R5cGUuc2VsZWN0aW9uQ2hhbmdlZCA9IGZ1bmN0aW9uICgpIHtcXG4gIHZhciBzZWwgPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XFxuICByZXR1cm4gc2VsLmFuY2hvck5vZGUgIT0gdGhpcy5sYXN0QW5jaG9yTm9kZSB8fCBzZWwuYW5jaG9yT2Zmc2V0ICE9IHRoaXMubGFzdEFuY2hvck9mZnNldCB8fFxcbiAgICBzZWwuZm9jdXNOb2RlICE9IHRoaXMubGFzdEZvY3VzTm9kZSB8fCBzZWwuZm9jdXNPZmZzZXQgIT0gdGhpcy5sYXN0Rm9jdXNPZmZzZXRcXG59O1xcblxcbkNvbnRlbnRFZGl0YWJsZUlucHV0LnByb3RvdHlwZS5wb2xsU2VsZWN0aW9uID0gZnVuY3Rpb24gKCkge1xcbiAgaWYgKHRoaXMucmVhZERPTVRpbWVvdXQgIT0gbnVsbCB8fCB0aGlzLmdyYWNlUGVyaW9kIHx8ICF0aGlzLnNlbGVjdGlvbkNoYW5nZWQoKSkgeyByZXR1cm4gfVxcbiAgdmFyIHNlbCA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKSwgY20gPSB0aGlzLmNtO1xcbiAgLy8gT24gQW5kcm9pZCBDaHJvbWUgKHZlcnNpb24gNTYsIGF0IGxlYXN0KSwgYmFja3NwYWNpbmcgaW50byBhblxcbiAgLy8gdW5lZGl0YWJsZSBibG9jayBlbGVtZW50IHdpbGwgcHV0IHRoZSBjdXJzb3IgaW4gdGhhdCBlbGVtZW50LFxcbiAgLy8gYW5kIHRoZW4sIGJlY2F1c2UgaXQncyBub3QgZWRpdGFibGUsIGhpZGUgdGhlIHZpcnR1YWwga2V5Ym9hcmQuXFxuICAvLyBCZWNhdXNlIEFuZHJvaWQgZG9lc24ndCBhbGxvdyB1cyB0byBhY3R1YWxseSBkZXRlY3QgYmFja3NwYWNlXFxuICAvLyBwcmVzc2VzIGluIGEgc2FuZSB3YXksIHRoaXMgY29kZSBjaGVja3MgZm9yIHdoZW4gdGhhdCBoYXBwZW5zXFxuICAvLyBhbmQgc2ltdWxhdGVzIGEgYmFja3NwYWNlIHByZXNzIGluIHRoaXMgY2FzZS5cXG4gIGlmIChhbmRyb2lkICYmIGNocm9tZSAmJiB0aGlzLmNtLm9wdGlvbnMuZ3V0dGVycy5sZW5ndGggJiYgaXNJbkd1dHRlcihzZWwuYW5jaG9yTm9kZSkpIHtcXG4gICAgdGhpcy5jbS50cmlnZ2VyT25LZXlEb3duKHt0eXBlOiBcXFwia2V5ZG93blxcXCIsIGtleUNvZGU6IDgsIHByZXZlbnREZWZhdWx0OiBNYXRoLmFic30pO1xcbiAgICB0aGlzLmJsdXIoKTtcXG4gICAgdGhpcy5mb2N1cygpO1xcbiAgICByZXR1cm5cXG4gIH1cXG4gIGlmICh0aGlzLmNvbXBvc2luZykgeyByZXR1cm4gfVxcbiAgdGhpcy5yZW1lbWJlclNlbGVjdGlvbigpO1xcbiAgdmFyIGFuY2hvciA9IGRvbVRvUG9zKGNtLCBzZWwuYW5jaG9yTm9kZSwgc2VsLmFuY2hvck9mZnNldCk7XFxuICB2YXIgaGVhZCA9IGRvbVRvUG9zKGNtLCBzZWwuZm9jdXNOb2RlLCBzZWwuZm9jdXNPZmZzZXQpO1xcbiAgaWYgKGFuY2hvciAmJiBoZWFkKSB7IHJ1bkluT3AoY20sIGZ1bmN0aW9uICgpIHtcXG4gICAgc2V0U2VsZWN0aW9uKGNtLmRvYywgc2ltcGxlU2VsZWN0aW9uKGFuY2hvciwgaGVhZCksIHNlbF9kb250U2Nyb2xsKTtcXG4gICAgaWYgKGFuY2hvci5iYWQgfHwgaGVhZC5iYWQpIHsgY20uY3VyT3Auc2VsZWN0aW9uQ2hhbmdlZCA9IHRydWU7IH1cXG4gIH0pOyB9XFxufTtcXG5cXG5Db250ZW50RWRpdGFibGVJbnB1dC5wcm90b3R5cGUucG9sbENvbnRlbnQgPSBmdW5jdGlvbiAoKSB7XFxuICBpZiAodGhpcy5yZWFkRE9NVGltZW91dCAhPSBudWxsKSB7XFxuICAgIGNsZWFyVGltZW91dCh0aGlzLnJlYWRET01UaW1lb3V0KTtcXG4gICAgdGhpcy5yZWFkRE9NVGltZW91dCA9IG51bGw7XFxuICB9XFxuXFxuICB2YXIgY20gPSB0aGlzLmNtLCBkaXNwbGF5ID0gY20uZGlzcGxheSwgc2VsID0gY20uZG9jLnNlbC5wcmltYXJ5KCk7XFxuICB2YXIgZnJvbSA9IHNlbC5mcm9tKCksIHRvID0gc2VsLnRvKCk7XFxuICBpZiAoZnJvbS5jaCA9PSAwICYmIGZyb20ubGluZSA+IGNtLmZpcnN0TGluZSgpKVxcbiAgICB7IGZyb20gPSBQb3MoZnJvbS5saW5lIC0gMSwgZ2V0TGluZShjbS5kb2MsIGZyb20ubGluZSAtIDEpLmxlbmd0aCk7IH1cXG4gIGlmICh0by5jaCA9PSBnZXRMaW5lKGNtLmRvYywgdG8ubGluZSkudGV4dC5sZW5ndGggJiYgdG8ubGluZSA8IGNtLmxhc3RMaW5lKCkpXFxuICAgIHsgdG8gPSBQb3ModG8ubGluZSArIDEsIDApOyB9XFxuICBpZiAoZnJvbS5saW5lIDwgZGlzcGxheS52aWV3RnJvbSB8fCB0by5saW5lID4gZGlzcGxheS52aWV3VG8gLSAxKSB7IHJldHVybiBmYWxzZSB9XFxuXFxuICB2YXIgZnJvbUluZGV4LCBmcm9tTGluZSwgZnJvbU5vZGU7XFxuICBpZiAoZnJvbS5saW5lID09IGRpc3BsYXkudmlld0Zyb20gfHwgKGZyb21JbmRleCA9IGZpbmRWaWV3SW5kZXgoY20sIGZyb20ubGluZSkpID09IDApIHtcXG4gICAgZnJvbUxpbmUgPSBsaW5lTm8oZGlzcGxheS52aWV3WzBdLmxpbmUpO1xcbiAgICBmcm9tTm9kZSA9IGRpc3BsYXkudmlld1swXS5ub2RlO1xcbiAgfSBlbHNlIHtcXG4gICAgZnJvbUxpbmUgPSBsaW5lTm8oZGlzcGxheS52aWV3W2Zyb21JbmRleF0ubGluZSk7XFxuICAgIGZyb21Ob2RlID0gZGlzcGxheS52aWV3W2Zyb21JbmRleCAtIDFdLm5vZGUubmV4dFNpYmxpbmc7XFxuICB9XFxuICB2YXIgdG9JbmRleCA9IGZpbmRWaWV3SW5kZXgoY20sIHRvLmxpbmUpO1xcbiAgdmFyIHRvTGluZSwgdG9Ob2RlO1xcbiAgaWYgKHRvSW5kZXggPT0gZGlzcGxheS52aWV3Lmxlbmd0aCAtIDEpIHtcXG4gICAgdG9MaW5lID0gZGlzcGxheS52aWV3VG8gLSAxO1xcbiAgICB0b05vZGUgPSBkaXNwbGF5LmxpbmVEaXYubGFzdENoaWxkO1xcbiAgfSBlbHNlIHtcXG4gICAgdG9MaW5lID0gbGluZU5vKGRpc3BsYXkudmlld1t0b0luZGV4ICsgMV0ubGluZSkgLSAxO1xcbiAgICB0b05vZGUgPSBkaXNwbGF5LnZpZXdbdG9JbmRleCArIDFdLm5vZGUucHJldmlvdXNTaWJsaW5nO1xcbiAgfVxcblxcbiAgaWYgKCFmcm9tTm9kZSkgeyByZXR1cm4gZmFsc2UgfVxcbiAgdmFyIG5ld1RleHQgPSBjbS5kb2Muc3BsaXRMaW5lcyhkb21UZXh0QmV0d2VlbihjbSwgZnJvbU5vZGUsIHRvTm9kZSwgZnJvbUxpbmUsIHRvTGluZSkpO1xcbiAgdmFyIG9sZFRleHQgPSBnZXRCZXR3ZWVuKGNtLmRvYywgUG9zKGZyb21MaW5lLCAwKSwgUG9zKHRvTGluZSwgZ2V0TGluZShjbS5kb2MsIHRvTGluZSkudGV4dC5sZW5ndGgpKTtcXG4gIHdoaWxlIChuZXdUZXh0Lmxlbmd0aCA+IDEgJiYgb2xkVGV4dC5sZW5ndGggPiAxKSB7XFxuICAgIGlmIChsc3QobmV3VGV4dCkgPT0gbHN0KG9sZFRleHQpKSB7IG5ld1RleHQucG9wKCk7IG9sZFRleHQucG9wKCk7IHRvTGluZS0tOyB9XFxuICAgIGVsc2UgaWYgKG5ld1RleHRbMF0gPT0gb2xkVGV4dFswXSkgeyBuZXdUZXh0LnNoaWZ0KCk7IG9sZFRleHQuc2hpZnQoKTsgZnJvbUxpbmUrKzsgfVxcbiAgICBlbHNlIHsgYnJlYWsgfVxcbiAgfVxcblxcbiAgdmFyIGN1dEZyb250ID0gMCwgY3V0RW5kID0gMDtcXG4gIHZhciBuZXdUb3AgPSBuZXdUZXh0WzBdLCBvbGRUb3AgPSBvbGRUZXh0WzBdLCBtYXhDdXRGcm9udCA9IE1hdGgubWluKG5ld1RvcC5sZW5ndGgsIG9sZFRvcC5sZW5ndGgpO1xcbiAgd2hpbGUgKGN1dEZyb250IDwgbWF4Q3V0RnJvbnQgJiYgbmV3VG9wLmNoYXJDb2RlQXQoY3V0RnJvbnQpID09IG9sZFRvcC5jaGFyQ29kZUF0KGN1dEZyb250KSlcXG4gICAgeyArK2N1dEZyb250OyB9XFxuICB2YXIgbmV3Qm90ID0gbHN0KG5ld1RleHQpLCBvbGRCb3QgPSBsc3Qob2xkVGV4dCk7XFxuICB2YXIgbWF4Q3V0RW5kID0gTWF0aC5taW4obmV3Qm90Lmxlbmd0aCAtIChuZXdUZXh0Lmxlbmd0aCA9PSAxID8gY3V0RnJvbnQgOiAwKSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBvbGRCb3QubGVuZ3RoIC0gKG9sZFRleHQubGVuZ3RoID09IDEgPyBjdXRGcm9udCA6IDApKTtcXG4gIHdoaWxlIChjdXRFbmQgPCBtYXhDdXRFbmQgJiZcXG4gICAgICAgICBuZXdCb3QuY2hhckNvZGVBdChuZXdCb3QubGVuZ3RoIC0gY3V0RW5kIC0gMSkgPT0gb2xkQm90LmNoYXJDb2RlQXQob2xkQm90Lmxlbmd0aCAtIGN1dEVuZCAtIDEpKVxcbiAgICB7ICsrY3V0RW5kOyB9XFxuICAvLyBUcnkgdG8gbW92ZSBzdGFydCBvZiBjaGFuZ2UgdG8gc3RhcnQgb2Ygc2VsZWN0aW9uIGlmIGFtYmlndW91c1xcbiAgaWYgKG5ld1RleHQubGVuZ3RoID09IDEgJiYgb2xkVGV4dC5sZW5ndGggPT0gMSAmJiBmcm9tTGluZSA9PSBmcm9tLmxpbmUpIHtcXG4gICAgd2hpbGUgKGN1dEZyb250ICYmIGN1dEZyb250ID4gZnJvbS5jaCAmJlxcbiAgICAgICAgICAgbmV3Qm90LmNoYXJDb2RlQXQobmV3Qm90Lmxlbmd0aCAtIGN1dEVuZCAtIDEpID09IG9sZEJvdC5jaGFyQ29kZUF0KG9sZEJvdC5sZW5ndGggLSBjdXRFbmQgLSAxKSkge1xcbiAgICAgIGN1dEZyb250LS07XFxuICAgICAgY3V0RW5kKys7XFxuICAgIH1cXG4gIH1cXG5cXG4gIG5ld1RleHRbbmV3VGV4dC5sZW5ndGggLSAxXSA9IG5ld0JvdC5zbGljZSgwLCBuZXdCb3QubGVuZ3RoIC0gY3V0RW5kKS5yZXBsYWNlKC9eXFxcXHUyMDBiKy8sIFxcXCJcXFwiKTtcXG4gIG5ld1RleHRbMF0gPSBuZXdUZXh0WzBdLnNsaWNlKGN1dEZyb250KS5yZXBsYWNlKC9cXFxcdTIwMGIrJC8sIFxcXCJcXFwiKTtcXG5cXG4gIHZhciBjaEZyb20gPSBQb3MoZnJvbUxpbmUsIGN1dEZyb250KTtcXG4gIHZhciBjaFRvID0gUG9zKHRvTGluZSwgb2xkVGV4dC5sZW5ndGggPyBsc3Qob2xkVGV4dCkubGVuZ3RoIC0gY3V0RW5kIDogMCk7XFxuICBpZiAobmV3VGV4dC5sZW5ndGggPiAxIHx8IG5ld1RleHRbMF0gfHwgY21wKGNoRnJvbSwgY2hUbykpIHtcXG4gICAgcmVwbGFjZVJhbmdlKGNtLmRvYywgbmV3VGV4dCwgY2hGcm9tLCBjaFRvLCBcXFwiK2lucHV0XFxcIik7XFxuICAgIHJldHVybiB0cnVlXFxuICB9XFxufTtcXG5cXG5Db250ZW50RWRpdGFibGVJbnB1dC5wcm90b3R5cGUuZW5zdXJlUG9sbGVkID0gZnVuY3Rpb24gKCkge1xcbiAgdGhpcy5mb3JjZUNvbXBvc2l0aW9uRW5kKCk7XFxufTtcXG5Db250ZW50RWRpdGFibGVJbnB1dC5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoKSB7XFxuICB0aGlzLmZvcmNlQ29tcG9zaXRpb25FbmQoKTtcXG59O1xcbkNvbnRlbnRFZGl0YWJsZUlucHV0LnByb3RvdHlwZS5mb3JjZUNvbXBvc2l0aW9uRW5kID0gZnVuY3Rpb24gKCkge1xcbiAgaWYgKCF0aGlzLmNvbXBvc2luZykgeyByZXR1cm4gfVxcbiAgY2xlYXJUaW1lb3V0KHRoaXMucmVhZERPTVRpbWVvdXQpO1xcbiAgdGhpcy5jb21wb3NpbmcgPSBudWxsO1xcbiAgdGhpcy51cGRhdGVGcm9tRE9NKCk7XFxuICB0aGlzLmRpdi5ibHVyKCk7XFxuICB0aGlzLmRpdi5mb2N1cygpO1xcbn07XFxuQ29udGVudEVkaXRhYmxlSW5wdXQucHJvdG90eXBlLnJlYWRGcm9tRE9NU29vbiA9IGZ1bmN0aW9uICgpIHtcXG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XFxuXFxuICBpZiAodGhpcy5yZWFkRE9NVGltZW91dCAhPSBudWxsKSB7IHJldHVybiB9XFxuICB0aGlzLnJlYWRET01UaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XFxuICAgIHRoaXMkMS5yZWFkRE9NVGltZW91dCA9IG51bGw7XFxuICAgIGlmICh0aGlzJDEuY29tcG9zaW5nKSB7XFxuICAgICAgaWYgKHRoaXMkMS5jb21wb3NpbmcuZG9uZSkgeyB0aGlzJDEuY29tcG9zaW5nID0gbnVsbDsgfVxcbiAgICAgIGVsc2UgeyByZXR1cm4gfVxcbiAgICB9XFxuICAgIHRoaXMkMS51cGRhdGVGcm9tRE9NKCk7XFxuICB9LCA4MCk7XFxufTtcXG5cXG5Db250ZW50RWRpdGFibGVJbnB1dC5wcm90b3R5cGUudXBkYXRlRnJvbURPTSA9IGZ1bmN0aW9uICgpIHtcXG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XFxuXFxuICBpZiAodGhpcy5jbS5pc1JlYWRPbmx5KCkgfHwgIXRoaXMucG9sbENvbnRlbnQoKSlcXG4gICAgeyBydW5Jbk9wKHRoaXMuY20sIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlZ0NoYW5nZSh0aGlzJDEuY20pOyB9KTsgfVxcbn07XFxuXFxuQ29udGVudEVkaXRhYmxlSW5wdXQucHJvdG90eXBlLnNldFVuZWRpdGFibGUgPSBmdW5jdGlvbiAobm9kZSkge1xcbiAgbm9kZS5jb250ZW50RWRpdGFibGUgPSBcXFwiZmFsc2VcXFwiO1xcbn07XFxuXFxuQ29udGVudEVkaXRhYmxlSW5wdXQucHJvdG90eXBlLm9uS2V5UHJlc3MgPSBmdW5jdGlvbiAoZSkge1xcbiAgaWYgKGUuY2hhckNvZGUgPT0gMCkgeyByZXR1cm4gfVxcbiAgZS5wcmV2ZW50RGVmYXVsdCgpO1xcbiAgaWYgKCF0aGlzLmNtLmlzUmVhZE9ubHkoKSlcXG4gICAgeyBvcGVyYXRpb24odGhpcy5jbSwgYXBwbHlUZXh0SW5wdXQpKHRoaXMuY20sIFN0cmluZy5mcm9tQ2hhckNvZGUoZS5jaGFyQ29kZSA9PSBudWxsID8gZS5rZXlDb2RlIDogZS5jaGFyQ29kZSksIDApOyB9XFxufTtcXG5cXG5Db250ZW50RWRpdGFibGVJbnB1dC5wcm90b3R5cGUucmVhZE9ubHlDaGFuZ2VkID0gZnVuY3Rpb24gKHZhbCkge1xcbiAgdGhpcy5kaXYuY29udGVudEVkaXRhYmxlID0gU3RyaW5nKHZhbCAhPSBcXFwibm9jdXJzb3JcXFwiKTtcXG59O1xcblxcbkNvbnRlbnRFZGl0YWJsZUlucHV0LnByb3RvdHlwZS5vbkNvbnRleHRNZW51ID0gZnVuY3Rpb24gKCkge307XFxuQ29udGVudEVkaXRhYmxlSW5wdXQucHJvdG90eXBlLnJlc2V0UG9zaXRpb24gPSBmdW5jdGlvbiAoKSB7fTtcXG5cXG5Db250ZW50RWRpdGFibGVJbnB1dC5wcm90b3R5cGUubmVlZHNDb250ZW50QXR0cmlidXRlID0gdHJ1ZTtcXG5cXG5mdW5jdGlvbiBwb3NUb0RPTShjbSwgcG9zKSB7XFxuICB2YXIgdmlldyA9IGZpbmRWaWV3Rm9yTGluZShjbSwgcG9zLmxpbmUpO1xcbiAgaWYgKCF2aWV3IHx8IHZpZXcuaGlkZGVuKSB7IHJldHVybiBudWxsIH1cXG4gIHZhciBsaW5lID0gZ2V0TGluZShjbS5kb2MsIHBvcy5saW5lKTtcXG4gIHZhciBpbmZvID0gbWFwRnJvbUxpbmVWaWV3KHZpZXcsIGxpbmUsIHBvcy5saW5lKTtcXG5cXG4gIHZhciBvcmRlciA9IGdldE9yZGVyKGxpbmUsIGNtLmRvYy5kaXJlY3Rpb24pLCBzaWRlID0gXFxcImxlZnRcXFwiO1xcbiAgaWYgKG9yZGVyKSB7XFxuICAgIHZhciBwYXJ0UG9zID0gZ2V0QmlkaVBhcnRBdChvcmRlciwgcG9zLmNoKTtcXG4gICAgc2lkZSA9IHBhcnRQb3MgJSAyID8gXFxcInJpZ2h0XFxcIiA6IFxcXCJsZWZ0XFxcIjtcXG4gIH1cXG4gIHZhciByZXN1bHQgPSBub2RlQW5kT2Zmc2V0SW5MaW5lTWFwKGluZm8ubWFwLCBwb3MuY2gsIHNpZGUpO1xcbiAgcmVzdWx0Lm9mZnNldCA9IHJlc3VsdC5jb2xsYXBzZSA9PSBcXFwicmlnaHRcXFwiID8gcmVzdWx0LmVuZCA6IHJlc3VsdC5zdGFydDtcXG4gIHJldHVybiByZXN1bHRcXG59XFxuXFxuZnVuY3Rpb24gaXNJbkd1dHRlcihub2RlKSB7XFxuICBmb3IgKHZhciBzY2FuID0gbm9kZTsgc2Nhbjsgc2NhbiA9IHNjYW4ucGFyZW50Tm9kZSlcXG4gICAgeyBpZiAoL0NvZGVNaXJyb3ItZ3V0dGVyLXdyYXBwZXIvLnRlc3Qoc2Nhbi5jbGFzc05hbWUpKSB7IHJldHVybiB0cnVlIH0gfVxcbiAgcmV0dXJuIGZhbHNlXFxufVxcblxcbmZ1bmN0aW9uIGJhZFBvcyhwb3MsIGJhZCkgeyBpZiAoYmFkKSB7IHBvcy5iYWQgPSB0cnVlOyB9IHJldHVybiBwb3MgfVxcblxcbmZ1bmN0aW9uIGRvbVRleHRCZXR3ZWVuKGNtLCBmcm9tLCB0bywgZnJvbUxpbmUsIHRvTGluZSkge1xcbiAgdmFyIHRleHQgPSBcXFwiXFxcIiwgY2xvc2luZyA9IGZhbHNlLCBsaW5lU2VwID0gY20uZG9jLmxpbmVTZXBhcmF0b3IoKTtcXG4gIGZ1bmN0aW9uIHJlY29nbml6ZU1hcmtlcihpZCkgeyByZXR1cm4gZnVuY3Rpb24gKG1hcmtlcikgeyByZXR1cm4gbWFya2VyLmlkID09IGlkOyB9IH1cXG4gIGZ1bmN0aW9uIGNsb3NlKCkge1xcbiAgICBpZiAoY2xvc2luZykge1xcbiAgICAgIHRleHQgKz0gbGluZVNlcDtcXG4gICAgICBjbG9zaW5nID0gZmFsc2U7XFxuICAgIH1cXG4gIH1cXG4gIGZ1bmN0aW9uIGFkZFRleHQoc3RyKSB7XFxuICAgIGlmIChzdHIpIHtcXG4gICAgICBjbG9zZSgpO1xcbiAgICAgIHRleHQgKz0gc3RyO1xcbiAgICB9XFxuICB9XFxuICBmdW5jdGlvbiB3YWxrKG5vZGUpIHtcXG4gICAgaWYgKG5vZGUubm9kZVR5cGUgPT0gMSkge1xcbiAgICAgIHZhciBjbVRleHQgPSBub2RlLmdldEF0dHJpYnV0ZShcXFwiY20tdGV4dFxcXCIpO1xcbiAgICAgIGlmIChjbVRleHQgIT0gbnVsbCkge1xcbiAgICAgICAgYWRkVGV4dChjbVRleHQgfHwgbm9kZS50ZXh0Q29udGVudC5yZXBsYWNlKC9cXFxcdTIwMGIvZywgXFxcIlxcXCIpKTtcXG4gICAgICAgIHJldHVyblxcbiAgICAgIH1cXG4gICAgICB2YXIgbWFya2VySUQgPSBub2RlLmdldEF0dHJpYnV0ZShcXFwiY20tbWFya2VyXFxcIiksIHJhbmdlJCQxO1xcbiAgICAgIGlmIChtYXJrZXJJRCkge1xcbiAgICAgICAgdmFyIGZvdW5kID0gY20uZmluZE1hcmtzKFBvcyhmcm9tTGluZSwgMCksIFBvcyh0b0xpbmUgKyAxLCAwKSwgcmVjb2duaXplTWFya2VyKCttYXJrZXJJRCkpO1xcbiAgICAgICAgaWYgKGZvdW5kLmxlbmd0aCAmJiAocmFuZ2UkJDEgPSBmb3VuZFswXS5maW5kKCkpKVxcbiAgICAgICAgICB7IGFkZFRleHQoZ2V0QmV0d2VlbihjbS5kb2MsIHJhbmdlJCQxLmZyb20sIHJhbmdlJCQxLnRvKS5qb2luKGxpbmVTZXApKTsgfVxcbiAgICAgICAgcmV0dXJuXFxuICAgICAgfVxcbiAgICAgIGlmIChub2RlLmdldEF0dHJpYnV0ZShcXFwiY29udGVudGVkaXRhYmxlXFxcIikgPT0gXFxcImZhbHNlXFxcIikgeyByZXR1cm4gfVxcbiAgICAgIHZhciBpc0Jsb2NrID0gL14ocHJlfGRpdnxwKSQvaS50ZXN0KG5vZGUubm9kZU5hbWUpO1xcbiAgICAgIGlmIChpc0Jsb2NrKSB7IGNsb3NlKCk7IH1cXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUuY2hpbGROb2Rlcy5sZW5ndGg7IGkrKylcXG4gICAgICAgIHsgd2Fsayhub2RlLmNoaWxkTm9kZXNbaV0pOyB9XFxuICAgICAgaWYgKGlzQmxvY2spIHsgY2xvc2luZyA9IHRydWU7IH1cXG4gICAgfSBlbHNlIGlmIChub2RlLm5vZGVUeXBlID09IDMpIHtcXG4gICAgICBhZGRUZXh0KG5vZGUubm9kZVZhbHVlKTtcXG4gICAgfVxcbiAgfVxcbiAgZm9yICg7Oykge1xcbiAgICB3YWxrKGZyb20pO1xcbiAgICBpZiAoZnJvbSA9PSB0bykgeyBicmVhayB9XFxuICAgIGZyb20gPSBmcm9tLm5leHRTaWJsaW5nO1xcbiAgfVxcbiAgcmV0dXJuIHRleHRcXG59XFxuXFxuZnVuY3Rpb24gZG9tVG9Qb3MoY20sIG5vZGUsIG9mZnNldCkge1xcbiAgdmFyIGxpbmVOb2RlO1xcbiAgaWYgKG5vZGUgPT0gY20uZGlzcGxheS5saW5lRGl2KSB7XFxuICAgIGxpbmVOb2RlID0gY20uZGlzcGxheS5saW5lRGl2LmNoaWxkTm9kZXNbb2Zmc2V0XTtcXG4gICAgaWYgKCFsaW5lTm9kZSkgeyByZXR1cm4gYmFkUG9zKGNtLmNsaXBQb3MoUG9zKGNtLmRpc3BsYXkudmlld1RvIC0gMSkpLCB0cnVlKSB9XFxuICAgIG5vZGUgPSBudWxsOyBvZmZzZXQgPSAwO1xcbiAgfSBlbHNlIHtcXG4gICAgZm9yIChsaW5lTm9kZSA9IG5vZGU7OyBsaW5lTm9kZSA9IGxpbmVOb2RlLnBhcmVudE5vZGUpIHtcXG4gICAgICBpZiAoIWxpbmVOb2RlIHx8IGxpbmVOb2RlID09IGNtLmRpc3BsYXkubGluZURpdikgeyByZXR1cm4gbnVsbCB9XFxuICAgICAgaWYgKGxpbmVOb2RlLnBhcmVudE5vZGUgJiYgbGluZU5vZGUucGFyZW50Tm9kZSA9PSBjbS5kaXNwbGF5LmxpbmVEaXYpIHsgYnJlYWsgfVxcbiAgICB9XFxuICB9XFxuICBmb3IgKHZhciBpID0gMDsgaSA8IGNtLmRpc3BsYXkudmlldy5sZW5ndGg7IGkrKykge1xcbiAgICB2YXIgbGluZVZpZXcgPSBjbS5kaXNwbGF5LnZpZXdbaV07XFxuICAgIGlmIChsaW5lVmlldy5ub2RlID09IGxpbmVOb2RlKVxcbiAgICAgIHsgcmV0dXJuIGxvY2F0ZU5vZGVJbkxpbmVWaWV3KGxpbmVWaWV3LCBub2RlLCBvZmZzZXQpIH1cXG4gIH1cXG59XFxuXFxuZnVuY3Rpb24gbG9jYXRlTm9kZUluTGluZVZpZXcobGluZVZpZXcsIG5vZGUsIG9mZnNldCkge1xcbiAgdmFyIHdyYXBwZXIgPSBsaW5lVmlldy50ZXh0LmZpcnN0Q2hpbGQsIGJhZCA9IGZhbHNlO1xcbiAgaWYgKCFub2RlIHx8ICFjb250YWlucyh3cmFwcGVyLCBub2RlKSkgeyByZXR1cm4gYmFkUG9zKFBvcyhsaW5lTm8obGluZVZpZXcubGluZSksIDApLCB0cnVlKSB9XFxuICBpZiAobm9kZSA9PSB3cmFwcGVyKSB7XFxuICAgIGJhZCA9IHRydWU7XFxuICAgIG5vZGUgPSB3cmFwcGVyLmNoaWxkTm9kZXNbb2Zmc2V0XTtcXG4gICAgb2Zmc2V0ID0gMDtcXG4gICAgaWYgKCFub2RlKSB7XFxuICAgICAgdmFyIGxpbmUgPSBsaW5lVmlldy5yZXN0ID8gbHN0KGxpbmVWaWV3LnJlc3QpIDogbGluZVZpZXcubGluZTtcXG4gICAgICByZXR1cm4gYmFkUG9zKFBvcyhsaW5lTm8obGluZSksIGxpbmUudGV4dC5sZW5ndGgpLCBiYWQpXFxuICAgIH1cXG4gIH1cXG5cXG4gIHZhciB0ZXh0Tm9kZSA9IG5vZGUubm9kZVR5cGUgPT0gMyA/IG5vZGUgOiBudWxsLCB0b3BOb2RlID0gbm9kZTtcXG4gIGlmICghdGV4dE5vZGUgJiYgbm9kZS5jaGlsZE5vZGVzLmxlbmd0aCA9PSAxICYmIG5vZGUuZmlyc3RDaGlsZC5ub2RlVHlwZSA9PSAzKSB7XFxuICAgIHRleHROb2RlID0gbm9kZS5maXJzdENoaWxkO1xcbiAgICBpZiAob2Zmc2V0KSB7IG9mZnNldCA9IHRleHROb2RlLm5vZGVWYWx1ZS5sZW5ndGg7IH1cXG4gIH1cXG4gIHdoaWxlICh0b3BOb2RlLnBhcmVudE5vZGUgIT0gd3JhcHBlcikgeyB0b3BOb2RlID0gdG9wTm9kZS5wYXJlbnROb2RlOyB9XFxuICB2YXIgbWVhc3VyZSA9IGxpbmVWaWV3Lm1lYXN1cmUsIG1hcHMgPSBtZWFzdXJlLm1hcHM7XFxuXFxuICBmdW5jdGlvbiBmaW5kKHRleHROb2RlLCB0b3BOb2RlLCBvZmZzZXQpIHtcXG4gICAgZm9yICh2YXIgaSA9IC0xOyBpIDwgKG1hcHMgPyBtYXBzLmxlbmd0aCA6IDApOyBpKyspIHtcXG4gICAgICB2YXIgbWFwJCQxID0gaSA8IDAgPyBtZWFzdXJlLm1hcCA6IG1hcHNbaV07XFxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBtYXAkJDEubGVuZ3RoOyBqICs9IDMpIHtcXG4gICAgICAgIHZhciBjdXJOb2RlID0gbWFwJCQxW2ogKyAyXTtcXG4gICAgICAgIGlmIChjdXJOb2RlID09IHRleHROb2RlIHx8IGN1ck5vZGUgPT0gdG9wTm9kZSkge1xcbiAgICAgICAgICB2YXIgbGluZSA9IGxpbmVObyhpIDwgMCA/IGxpbmVWaWV3LmxpbmUgOiBsaW5lVmlldy5yZXN0W2ldKTtcXG4gICAgICAgICAgdmFyIGNoID0gbWFwJCQxW2pdICsgb2Zmc2V0O1xcbiAgICAgICAgICBpZiAob2Zmc2V0IDwgMCB8fCBjdXJOb2RlICE9IHRleHROb2RlKSB7IGNoID0gbWFwJCQxW2ogKyAob2Zmc2V0ID8gMSA6IDApXTsgfVxcbiAgICAgICAgICByZXR1cm4gUG9zKGxpbmUsIGNoKVxcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgfVxcbiAgfVxcbiAgdmFyIGZvdW5kID0gZmluZCh0ZXh0Tm9kZSwgdG9wTm9kZSwgb2Zmc2V0KTtcXG4gIGlmIChmb3VuZCkgeyByZXR1cm4gYmFkUG9zKGZvdW5kLCBiYWQpIH1cXG5cXG4gIC8vIEZJWE1FIHRoaXMgaXMgYWxsIHJlYWxseSBzaGFreS4gbWlnaHQgaGFuZGxlIHRoZSBmZXcgY2FzZXMgaXQgbmVlZHMgdG8gaGFuZGxlLCBidXQgbGlrZWx5IHRvIGNhdXNlIHByb2JsZW1zXFxuICBmb3IgKHZhciBhZnRlciA9IHRvcE5vZGUubmV4dFNpYmxpbmcsIGRpc3QgPSB0ZXh0Tm9kZSA/IHRleHROb2RlLm5vZGVWYWx1ZS5sZW5ndGggLSBvZmZzZXQgOiAwOyBhZnRlcjsgYWZ0ZXIgPSBhZnRlci5uZXh0U2libGluZykge1xcbiAgICBmb3VuZCA9IGZpbmQoYWZ0ZXIsIGFmdGVyLmZpcnN0Q2hpbGQsIDApO1xcbiAgICBpZiAoZm91bmQpXFxuICAgICAgeyByZXR1cm4gYmFkUG9zKFBvcyhmb3VuZC5saW5lLCBmb3VuZC5jaCAtIGRpc3QpLCBiYWQpIH1cXG4gICAgZWxzZVxcbiAgICAgIHsgZGlzdCArPSBhZnRlci50ZXh0Q29udGVudC5sZW5ndGg7IH1cXG4gIH1cXG4gIGZvciAodmFyIGJlZm9yZSA9IHRvcE5vZGUucHJldmlvdXNTaWJsaW5nLCBkaXN0JDEgPSBvZmZzZXQ7IGJlZm9yZTsgYmVmb3JlID0gYmVmb3JlLnByZXZpb3VzU2libGluZykge1xcbiAgICBmb3VuZCA9IGZpbmQoYmVmb3JlLCBiZWZvcmUuZmlyc3RDaGlsZCwgLTEpO1xcbiAgICBpZiAoZm91bmQpXFxuICAgICAgeyByZXR1cm4gYmFkUG9zKFBvcyhmb3VuZC5saW5lLCBmb3VuZC5jaCArIGRpc3QkMSksIGJhZCkgfVxcbiAgICBlbHNlXFxuICAgICAgeyBkaXN0JDEgKz0gYmVmb3JlLnRleHRDb250ZW50Lmxlbmd0aDsgfVxcbiAgfVxcbn1cXG5cXG4vLyBURVhUQVJFQSBJTlBVVCBTVFlMRVxcblxcbnZhciBUZXh0YXJlYUlucHV0ID0gZnVuY3Rpb24oY20pIHtcXG4gIHRoaXMuY20gPSBjbTtcXG4gIC8vIFNlZSBpbnB1dC5wb2xsIGFuZCBpbnB1dC5yZXNldFxcbiAgdGhpcy5wcmV2SW5wdXQgPSBcXFwiXFxcIjtcXG5cXG4gIC8vIEZsYWcgdGhhdCBpbmRpY2F0ZXMgd2hldGhlciB3ZSBleHBlY3QgaW5wdXQgdG8gYXBwZWFyIHJlYWwgc29vblxcbiAgLy8gbm93IChhZnRlciBzb21lIGV2ZW50IGxpa2UgJ2tleXByZXNzJyBvciAnaW5wdXQnKSBhbmQgYXJlXFxuICAvLyBwb2xsaW5nIGludGVuc2l2ZWx5LlxcbiAgdGhpcy5wb2xsaW5nRmFzdCA9IGZhbHNlO1xcbiAgLy8gU2VsZi1yZXNldHRpbmcgdGltZW91dCBmb3IgdGhlIHBvbGxlclxcbiAgdGhpcy5wb2xsaW5nID0gbmV3IERlbGF5ZWQoKTtcXG4gIC8vIFRyYWNrcyB3aGVuIGlucHV0LnJlc2V0IGhhcyBwdW50ZWQgdG8ganVzdCBwdXR0aW5nIGEgc2hvcnRcXG4gIC8vIHN0cmluZyBpbnRvIHRoZSB0ZXh0YXJlYSBpbnN0ZWFkIG9mIHRoZSBmdWxsIHNlbGVjdGlvbi5cXG4gIHRoaXMuaW5hY2N1cmF0ZVNlbGVjdGlvbiA9IGZhbHNlO1xcbiAgLy8gVXNlZCB0byB3b3JrIGFyb3VuZCBJRSBpc3N1ZSB3aXRoIHNlbGVjdGlvbiBiZWluZyBmb3Jnb3R0ZW4gd2hlbiBmb2N1cyBtb3ZlcyBhd2F5IGZyb20gdGV4dGFyZWFcXG4gIHRoaXMuaGFzU2VsZWN0aW9uID0gZmFsc2U7XFxuICB0aGlzLmNvbXBvc2luZyA9IG51bGw7XFxufTtcXG5cXG5UZXh0YXJlYUlucHV0LnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKGRpc3BsYXkpIHtcXG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XFxuXFxuICB2YXIgaW5wdXQgPSB0aGlzLCBjbSA9IHRoaXMuY207XFxuXFxuICAvLyBXcmFwcyBhbmQgaGlkZXMgaW5wdXQgdGV4dGFyZWFcXG4gIHZhciBkaXYgPSB0aGlzLndyYXBwZXIgPSBoaWRkZW5UZXh0YXJlYSgpO1xcbiAgLy8gVGhlIHNlbWloaWRkZW4gdGV4dGFyZWEgdGhhdCBpcyBmb2N1c2VkIHdoZW4gdGhlIGVkaXRvciBpc1xcbiAgLy8gZm9jdXNlZCwgYW5kIHJlY2VpdmVzIGlucHV0LlxcbiAgdmFyIHRlID0gdGhpcy50ZXh0YXJlYSA9IGRpdi5maXJzdENoaWxkO1xcbiAgZGlzcGxheS53cmFwcGVyLmluc2VydEJlZm9yZShkaXYsIGRpc3BsYXkud3JhcHBlci5maXJzdENoaWxkKTtcXG5cXG4gIC8vIE5lZWRlZCB0byBoaWRlIGJpZyBibHVlIGJsaW5raW5nIGN1cnNvciBvbiBNb2JpbGUgU2FmYXJpIChkb2Vzbid0IHNlZW0gdG8gd29yayBpbiBpT1MgOCBhbnltb3JlKVxcbiAgaWYgKGlvcykgeyB0ZS5zdHlsZS53aWR0aCA9IFxcXCIwcHhcXFwiOyB9XFxuXFxuICBvbih0ZSwgXFxcImlucHV0XFxcIiwgZnVuY3Rpb24gKCkge1xcbiAgICBpZiAoaWUgJiYgaWVfdmVyc2lvbiA+PSA5ICYmIHRoaXMkMS5oYXNTZWxlY3Rpb24pIHsgdGhpcyQxLmhhc1NlbGVjdGlvbiA9IG51bGw7IH1cXG4gICAgaW5wdXQucG9sbCgpO1xcbiAgfSk7XFxuXFxuICBvbih0ZSwgXFxcInBhc3RlXFxcIiwgZnVuY3Rpb24gKGUpIHtcXG4gICAgaWYgKHNpZ25hbERPTUV2ZW50KGNtLCBlKSB8fCBoYW5kbGVQYXN0ZShlLCBjbSkpIHsgcmV0dXJuIH1cXG5cXG4gICAgY20uc3RhdGUucGFzdGVJbmNvbWluZyA9IHRydWU7XFxuICAgIGlucHV0LmZhc3RQb2xsKCk7XFxuICB9KTtcXG5cXG4gIGZ1bmN0aW9uIHByZXBhcmVDb3B5Q3V0KGUpIHtcXG4gICAgaWYgKHNpZ25hbERPTUV2ZW50KGNtLCBlKSkgeyByZXR1cm4gfVxcbiAgICBpZiAoY20uc29tZXRoaW5nU2VsZWN0ZWQoKSkge1xcbiAgICAgIHNldExhc3RDb3BpZWQoe2xpbmVXaXNlOiBmYWxzZSwgdGV4dDogY20uZ2V0U2VsZWN0aW9ucygpfSk7XFxuICAgICAgaWYgKGlucHV0LmluYWNjdXJhdGVTZWxlY3Rpb24pIHtcXG4gICAgICAgIGlucHV0LnByZXZJbnB1dCA9IFxcXCJcXFwiO1xcbiAgICAgICAgaW5wdXQuaW5hY2N1cmF0ZVNlbGVjdGlvbiA9IGZhbHNlO1xcbiAgICAgICAgdGUudmFsdWUgPSBsYXN0Q29waWVkLnRleHQuam9pbihcXFwiXFxcXG5cXFwiKTtcXG4gICAgICAgIHNlbGVjdElucHV0KHRlKTtcXG4gICAgICB9XFxuICAgIH0gZWxzZSBpZiAoIWNtLm9wdGlvbnMubGluZVdpc2VDb3B5Q3V0KSB7XFxuICAgICAgcmV0dXJuXFxuICAgIH0gZWxzZSB7XFxuICAgICAgdmFyIHJhbmdlcyA9IGNvcHlhYmxlUmFuZ2VzKGNtKTtcXG4gICAgICBzZXRMYXN0Q29waWVkKHtsaW5lV2lzZTogdHJ1ZSwgdGV4dDogcmFuZ2VzLnRleHR9KTtcXG4gICAgICBpZiAoZS50eXBlID09IFxcXCJjdXRcXFwiKSB7XFxuICAgICAgICBjbS5zZXRTZWxlY3Rpb25zKHJhbmdlcy5yYW5nZXMsIG51bGwsIHNlbF9kb250U2Nyb2xsKTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgaW5wdXQucHJldklucHV0ID0gXFxcIlxcXCI7XFxuICAgICAgICB0ZS52YWx1ZSA9IHJhbmdlcy50ZXh0LmpvaW4oXFxcIlxcXFxuXFxcIik7XFxuICAgICAgICBzZWxlY3RJbnB1dCh0ZSk7XFxuICAgICAgfVxcbiAgICB9XFxuICAgIGlmIChlLnR5cGUgPT0gXFxcImN1dFxcXCIpIHsgY20uc3RhdGUuY3V0SW5jb21pbmcgPSB0cnVlOyB9XFxuICB9XFxuICBvbih0ZSwgXFxcImN1dFxcXCIsIHByZXBhcmVDb3B5Q3V0KTtcXG4gIG9uKHRlLCBcXFwiY29weVxcXCIsIHByZXBhcmVDb3B5Q3V0KTtcXG5cXG4gIG9uKGRpc3BsYXkuc2Nyb2xsZXIsIFxcXCJwYXN0ZVxcXCIsIGZ1bmN0aW9uIChlKSB7XFxuICAgIGlmIChldmVudEluV2lkZ2V0KGRpc3BsYXksIGUpIHx8IHNpZ25hbERPTUV2ZW50KGNtLCBlKSkgeyByZXR1cm4gfVxcbiAgICBjbS5zdGF0ZS5wYXN0ZUluY29taW5nID0gdHJ1ZTtcXG4gICAgaW5wdXQuZm9jdXMoKTtcXG4gIH0pO1xcblxcbiAgLy8gUHJldmVudCBub3JtYWwgc2VsZWN0aW9uIGluIHRoZSBlZGl0b3IgKHdlIGhhbmRsZSBvdXIgb3duKVxcbiAgb24oZGlzcGxheS5saW5lU3BhY2UsIFxcXCJzZWxlY3RzdGFydFxcXCIsIGZ1bmN0aW9uIChlKSB7XFxuICAgIGlmICghZXZlbnRJbldpZGdldChkaXNwbGF5LCBlKSkgeyBlX3ByZXZlbnREZWZhdWx0KGUpOyB9XFxuICB9KTtcXG5cXG4gIG9uKHRlLCBcXFwiY29tcG9zaXRpb25zdGFydFxcXCIsIGZ1bmN0aW9uICgpIHtcXG4gICAgdmFyIHN0YXJ0ID0gY20uZ2V0Q3Vyc29yKFxcXCJmcm9tXFxcIik7XFxuICAgIGlmIChpbnB1dC5jb21wb3NpbmcpIHsgaW5wdXQuY29tcG9zaW5nLnJhbmdlLmNsZWFyKCk7IH1cXG4gICAgaW5wdXQuY29tcG9zaW5nID0ge1xcbiAgICAgIHN0YXJ0OiBzdGFydCxcXG4gICAgICByYW5nZTogY20ubWFya1RleHQoc3RhcnQsIGNtLmdldEN1cnNvcihcXFwidG9cXFwiKSwge2NsYXNzTmFtZTogXFxcIkNvZGVNaXJyb3ItY29tcG9zaW5nXFxcIn0pXFxuICAgIH07XFxuICB9KTtcXG4gIG9uKHRlLCBcXFwiY29tcG9zaXRpb25lbmRcXFwiLCBmdW5jdGlvbiAoKSB7XFxuICAgIGlmIChpbnB1dC5jb21wb3NpbmcpIHtcXG4gICAgICBpbnB1dC5wb2xsKCk7XFxuICAgICAgaW5wdXQuY29tcG9zaW5nLnJhbmdlLmNsZWFyKCk7XFxuICAgICAgaW5wdXQuY29tcG9zaW5nID0gbnVsbDtcXG4gICAgfVxcbiAgfSk7XFxufTtcXG5cXG5UZXh0YXJlYUlucHV0LnByb3RvdHlwZS5wcmVwYXJlU2VsZWN0aW9uID0gZnVuY3Rpb24gKCkge1xcbiAgLy8gUmVkcmF3IHRoZSBzZWxlY3Rpb24gYW5kL29yIGN1cnNvclxcbiAgdmFyIGNtID0gdGhpcy5jbSwgZGlzcGxheSA9IGNtLmRpc3BsYXksIGRvYyA9IGNtLmRvYztcXG4gIHZhciByZXN1bHQgPSBwcmVwYXJlU2VsZWN0aW9uKGNtKTtcXG5cXG4gIC8vIE1vdmUgdGhlIGhpZGRlbiB0ZXh0YXJlYSBuZWFyIHRoZSBjdXJzb3IgdG8gcHJldmVudCBzY3JvbGxpbmcgYXJ0aWZhY3RzXFxuICBpZiAoY20ub3B0aW9ucy5tb3ZlSW5wdXRXaXRoQ3Vyc29yKSB7XFxuICAgIHZhciBoZWFkUG9zID0gY3Vyc29yQ29vcmRzKGNtLCBkb2Muc2VsLnByaW1hcnkoKS5oZWFkLCBcXFwiZGl2XFxcIik7XFxuICAgIHZhciB3cmFwT2ZmID0gZGlzcGxheS53cmFwcGVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLCBsaW5lT2ZmID0gZGlzcGxheS5saW5lRGl2LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xcbiAgICByZXN1bHQudGVUb3AgPSBNYXRoLm1heCgwLCBNYXRoLm1pbihkaXNwbGF5LndyYXBwZXIuY2xpZW50SGVpZ2h0IC0gMTAsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRQb3MudG9wICsgbGluZU9mZi50b3AgLSB3cmFwT2ZmLnRvcCkpO1xcbiAgICByZXN1bHQudGVMZWZ0ID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oZGlzcGxheS53cmFwcGVyLmNsaWVudFdpZHRoIC0gMTAsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWFkUG9zLmxlZnQgKyBsaW5lT2ZmLmxlZnQgLSB3cmFwT2ZmLmxlZnQpKTtcXG4gIH1cXG5cXG4gIHJldHVybiByZXN1bHRcXG59O1xcblxcblRleHRhcmVhSW5wdXQucHJvdG90eXBlLnNob3dTZWxlY3Rpb24gPSBmdW5jdGlvbiAoZHJhd24pIHtcXG4gIHZhciBjbSA9IHRoaXMuY20sIGRpc3BsYXkgPSBjbS5kaXNwbGF5O1xcbiAgcmVtb3ZlQ2hpbGRyZW5BbmRBZGQoZGlzcGxheS5jdXJzb3JEaXYsIGRyYXduLmN1cnNvcnMpO1xcbiAgcmVtb3ZlQ2hpbGRyZW5BbmRBZGQoZGlzcGxheS5zZWxlY3Rpb25EaXYsIGRyYXduLnNlbGVjdGlvbik7XFxuICBpZiAoZHJhd24udGVUb3AgIT0gbnVsbCkge1xcbiAgICB0aGlzLndyYXBwZXIuc3R5bGUudG9wID0gZHJhd24udGVUb3AgKyBcXFwicHhcXFwiO1xcbiAgICB0aGlzLndyYXBwZXIuc3R5bGUubGVmdCA9IGRyYXduLnRlTGVmdCArIFxcXCJweFxcXCI7XFxuICB9XFxufTtcXG5cXG4vLyBSZXNldCB0aGUgaW5wdXQgdG8gY29ycmVzcG9uZCB0byB0aGUgc2VsZWN0aW9uIChvciB0byBiZSBlbXB0eSxcXG4vLyB3aGVuIG5vdCB0eXBpbmcgYW5kIG5vdGhpbmcgaXMgc2VsZWN0ZWQpXFxuVGV4dGFyZWFJbnB1dC5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAodHlwaW5nKSB7XFxuICBpZiAodGhpcy5jb250ZXh0TWVudVBlbmRpbmcpIHsgcmV0dXJuIH1cXG4gIHZhciBtaW5pbWFsLCBzZWxlY3RlZCwgY20gPSB0aGlzLmNtLCBkb2MgPSBjbS5kb2M7XFxuICBpZiAoY20uc29tZXRoaW5nU2VsZWN0ZWQoKSkge1xcbiAgICB0aGlzLnByZXZJbnB1dCA9IFxcXCJcXFwiO1xcbiAgICB2YXIgcmFuZ2UkJDEgPSBkb2Muc2VsLnByaW1hcnkoKTtcXG4gICAgbWluaW1hbCA9IGhhc0NvcHlFdmVudCAmJlxcbiAgICAgIChyYW5nZSQkMS50bygpLmxpbmUgLSByYW5nZSQkMS5mcm9tKCkubGluZSA+IDEwMCB8fCAoc2VsZWN0ZWQgPSBjbS5nZXRTZWxlY3Rpb24oKSkubGVuZ3RoID4gMTAwMCk7XFxuICAgIHZhciBjb250ZW50ID0gbWluaW1hbCA/IFxcXCItXFxcIiA6IHNlbGVjdGVkIHx8IGNtLmdldFNlbGVjdGlvbigpO1xcbiAgICB0aGlzLnRleHRhcmVhLnZhbHVlID0gY29udGVudDtcXG4gICAgaWYgKGNtLnN0YXRlLmZvY3VzZWQpIHsgc2VsZWN0SW5wdXQodGhpcy50ZXh0YXJlYSk7IH1cXG4gICAgaWYgKGllICYmIGllX3ZlcnNpb24gPj0gOSkgeyB0aGlzLmhhc1NlbGVjdGlvbiA9IGNvbnRlbnQ7IH1cXG4gIH0gZWxzZSBpZiAoIXR5cGluZykge1xcbiAgICB0aGlzLnByZXZJbnB1dCA9IHRoaXMudGV4dGFyZWEudmFsdWUgPSBcXFwiXFxcIjtcXG4gICAgaWYgKGllICYmIGllX3ZlcnNpb24gPj0gOSkgeyB0aGlzLmhhc1NlbGVjdGlvbiA9IG51bGw7IH1cXG4gIH1cXG4gIHRoaXMuaW5hY2N1cmF0ZVNlbGVjdGlvbiA9IG1pbmltYWw7XFxufTtcXG5cXG5UZXh0YXJlYUlucHV0LnByb3RvdHlwZS5nZXRGaWVsZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMudGV4dGFyZWEgfTtcXG5cXG5UZXh0YXJlYUlucHV0LnByb3RvdHlwZS5zdXBwb3J0c1RvdWNoID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gZmFsc2UgfTtcXG5cXG5UZXh0YXJlYUlucHV0LnByb3RvdHlwZS5mb2N1cyA9IGZ1bmN0aW9uICgpIHtcXG4gIGlmICh0aGlzLmNtLm9wdGlvbnMucmVhZE9ubHkgIT0gXFxcIm5vY3Vyc29yXFxcIiAmJiAoIW1vYmlsZSB8fCBhY3RpdmVFbHQoKSAhPSB0aGlzLnRleHRhcmVhKSkge1xcbiAgICB0cnkgeyB0aGlzLnRleHRhcmVhLmZvY3VzKCk7IH1cXG4gICAgY2F0Y2ggKGUpIHt9IC8vIElFOCB3aWxsIHRocm93IGlmIHRoZSB0ZXh0YXJlYSBpcyBkaXNwbGF5OiBub25lIG9yIG5vdCBpbiBET01cXG4gIH1cXG59O1xcblxcblRleHRhcmVhSW5wdXQucHJvdG90eXBlLmJsdXIgPSBmdW5jdGlvbiAoKSB7IHRoaXMudGV4dGFyZWEuYmx1cigpOyB9O1xcblxcblRleHRhcmVhSW5wdXQucHJvdG90eXBlLnJlc2V0UG9zaXRpb24gPSBmdW5jdGlvbiAoKSB7XFxuICB0aGlzLndyYXBwZXIuc3R5bGUudG9wID0gdGhpcy53cmFwcGVyLnN0eWxlLmxlZnQgPSAwO1xcbn07XFxuXFxuVGV4dGFyZWFJbnB1dC5wcm90b3R5cGUucmVjZWl2ZWRGb2N1cyA9IGZ1bmN0aW9uICgpIHsgdGhpcy5zbG93UG9sbCgpOyB9O1xcblxcbi8vIFBvbGwgZm9yIGlucHV0IGNoYW5nZXMsIHVzaW5nIHRoZSBub3JtYWwgcmF0ZSBvZiBwb2xsaW5nLiBUaGlzXFxuLy8gcnVucyBhcyBsb25nIGFzIHRoZSBlZGl0b3IgaXMgZm9jdXNlZC5cXG5UZXh0YXJlYUlucHV0LnByb3RvdHlwZS5zbG93UG9sbCA9IGZ1bmN0aW9uICgpIHtcXG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XFxuXFxuICBpZiAodGhpcy5wb2xsaW5nRmFzdCkgeyByZXR1cm4gfVxcbiAgdGhpcy5wb2xsaW5nLnNldCh0aGlzLmNtLm9wdGlvbnMucG9sbEludGVydmFsLCBmdW5jdGlvbiAoKSB7XFxuICAgIHRoaXMkMS5wb2xsKCk7XFxuICAgIGlmICh0aGlzJDEuY20uc3RhdGUuZm9jdXNlZCkgeyB0aGlzJDEuc2xvd1BvbGwoKTsgfVxcbiAgfSk7XFxufTtcXG5cXG4vLyBXaGVuIGFuIGV2ZW50IGhhcyBqdXN0IGNvbWUgaW4gdGhhdCBpcyBsaWtlbHkgdG8gYWRkIG9yIGNoYW5nZVxcbi8vIHNvbWV0aGluZyBpbiB0aGUgaW5wdXQgdGV4dGFyZWEsIHdlIHBvbGwgZmFzdGVyLCB0byBlbnN1cmUgdGhhdFxcbi8vIHRoZSBjaGFuZ2UgYXBwZWFycyBvbiB0aGUgc2NyZWVuIHF1aWNrbHkuXFxuVGV4dGFyZWFJbnB1dC5wcm90b3R5cGUuZmFzdFBvbGwgPSBmdW5jdGlvbiAoKSB7XFxuICB2YXIgbWlzc2VkID0gZmFsc2UsIGlucHV0ID0gdGhpcztcXG4gIGlucHV0LnBvbGxpbmdGYXN0ID0gdHJ1ZTtcXG4gIGZ1bmN0aW9uIHAoKSB7XFxuICAgIHZhciBjaGFuZ2VkID0gaW5wdXQucG9sbCgpO1xcbiAgICBpZiAoIWNoYW5nZWQgJiYgIW1pc3NlZCkge21pc3NlZCA9IHRydWU7IGlucHV0LnBvbGxpbmcuc2V0KDYwLCBwKTt9XFxuICAgIGVsc2Uge2lucHV0LnBvbGxpbmdGYXN0ID0gZmFsc2U7IGlucHV0LnNsb3dQb2xsKCk7fVxcbiAgfVxcbiAgaW5wdXQucG9sbGluZy5zZXQoMjAsIHApO1xcbn07XFxuXFxuLy8gUmVhZCBpbnB1dCBmcm9tIHRoZSB0ZXh0YXJlYSwgYW5kIHVwZGF0ZSB0aGUgZG9jdW1lbnQgdG8gbWF0Y2guXFxuLy8gV2hlbiBzb21ldGhpbmcgaXMgc2VsZWN0ZWQsIGl0IGlzIHByZXNlbnQgaW4gdGhlIHRleHRhcmVhLCBhbmRcXG4vLyBzZWxlY3RlZCAodW5sZXNzIGl0IGlzIGh1Z2UsIGluIHdoaWNoIGNhc2UgYSBwbGFjZWhvbGRlciBpc1xcbi8vIHVzZWQpLiBXaGVuIG5vdGhpbmcgaXMgc2VsZWN0ZWQsIHRoZSBjdXJzb3Igc2l0cyBhZnRlciBwcmV2aW91c2x5XFxuLy8gc2VlbiB0ZXh0IChjYW4gYmUgZW1wdHkpLCB3aGljaCBpcyBzdG9yZWQgaW4gcHJldklucHV0ICh3ZSBtdXN0XFxuLy8gbm90IHJlc2V0IHRoZSB0ZXh0YXJlYSB3aGVuIHR5cGluZywgYmVjYXVzZSB0aGF0IGJyZWFrcyBJTUUpLlxcblRleHRhcmVhSW5wdXQucHJvdG90eXBlLnBvbGwgPSBmdW5jdGlvbiAoKSB7XFxuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xcblxcbiAgdmFyIGNtID0gdGhpcy5jbSwgaW5wdXQgPSB0aGlzLnRleHRhcmVhLCBwcmV2SW5wdXQgPSB0aGlzLnByZXZJbnB1dDtcXG4gIC8vIFNpbmNlIHRoaXMgaXMgY2FsbGVkIGEgKmxvdCosIHRyeSB0byBiYWlsIG91dCBhcyBjaGVhcGx5IGFzXFxuICAvLyBwb3NzaWJsZSB3aGVuIGl0IGlzIGNsZWFyIHRoYXQgbm90aGluZyBoYXBwZW5lZC4gaGFzU2VsZWN0aW9uXFxuICAvLyB3aWxsIGJlIHRoZSBjYXNlIHdoZW4gdGhlcmUgaXMgYSBsb3Qgb2YgdGV4dCBpbiB0aGUgdGV4dGFyZWEsXFxuICAvLyBpbiB3aGljaCBjYXNlIHJlYWRpbmcgaXRzIHZhbHVlIHdvdWxkIGJlIGV4cGVuc2l2ZS5cXG4gIGlmICh0aGlzLmNvbnRleHRNZW51UGVuZGluZyB8fCAhY20uc3RhdGUuZm9jdXNlZCB8fFxcbiAgICAgIChoYXNTZWxlY3Rpb24oaW5wdXQpICYmICFwcmV2SW5wdXQgJiYgIXRoaXMuY29tcG9zaW5nKSB8fFxcbiAgICAgIGNtLmlzUmVhZE9ubHkoKSB8fCBjbS5vcHRpb25zLmRpc2FibGVJbnB1dCB8fCBjbS5zdGF0ZS5rZXlTZXEpXFxuICAgIHsgcmV0dXJuIGZhbHNlIH1cXG5cXG4gIHZhciB0ZXh0ID0gaW5wdXQudmFsdWU7XFxuICAvLyBJZiBub3RoaW5nIGNoYW5nZWQsIGJhaWwuXFxuICBpZiAodGV4dCA9PSBwcmV2SW5wdXQgJiYgIWNtLnNvbWV0aGluZ1NlbGVjdGVkKCkpIHsgcmV0dXJuIGZhbHNlIH1cXG4gIC8vIFdvcmsgYXJvdW5kIG5vbnNlbnNpY2FsIHNlbGVjdGlvbiByZXNldHRpbmcgaW4gSUU5LzEwLCBhbmRcXG4gIC8vIGluZXhwbGljYWJsZSBhcHBlYXJhbmNlIG9mIHByaXZhdGUgYXJlYSB1bmljb2RlIGNoYXJhY3RlcnMgb25cXG4gIC8vIHNvbWUga2V5IGNvbWJvcyBpbiBNYWMgKCMyNjg5KS5cXG4gIGlmIChpZSAmJiBpZV92ZXJzaW9uID49IDkgJiYgdGhpcy5oYXNTZWxlY3Rpb24gPT09IHRleHQgfHxcXG4gICAgICBtYWMgJiYgL1tcXFxcdWY3MDAtXFxcXHVmN2ZmXS8udGVzdCh0ZXh0KSkge1xcbiAgICBjbS5kaXNwbGF5LmlucHV0LnJlc2V0KCk7XFxuICAgIHJldHVybiBmYWxzZVxcbiAgfVxcblxcbiAgaWYgKGNtLmRvYy5zZWwgPT0gY20uZGlzcGxheS5zZWxGb3JDb250ZXh0TWVudSkge1xcbiAgICB2YXIgZmlyc3QgPSB0ZXh0LmNoYXJDb2RlQXQoMCk7XFxuICAgIGlmIChmaXJzdCA9PSAweDIwMGIgJiYgIXByZXZJbnB1dCkgeyBwcmV2SW5wdXQgPSBcXFwiXFxcXHUyMDBiXFxcIjsgfVxcbiAgICBpZiAoZmlyc3QgPT0gMHgyMWRhKSB7IHRoaXMucmVzZXQoKTsgcmV0dXJuIHRoaXMuY20uZXhlY0NvbW1hbmQoXFxcInVuZG9cXFwiKSB9XFxuICB9XFxuICAvLyBGaW5kIHRoZSBwYXJ0IG9mIHRoZSBpbnB1dCB0aGF0IGlzIGFjdHVhbGx5IG5ld1xcbiAgdmFyIHNhbWUgPSAwLCBsID0gTWF0aC5taW4ocHJldklucHV0Lmxlbmd0aCwgdGV4dC5sZW5ndGgpO1xcbiAgd2hpbGUgKHNhbWUgPCBsICYmIHByZXZJbnB1dC5jaGFyQ29kZUF0KHNhbWUpID09IHRleHQuY2hhckNvZGVBdChzYW1lKSkgeyArK3NhbWU7IH1cXG5cXG4gIHJ1bkluT3AoY20sIGZ1bmN0aW9uICgpIHtcXG4gICAgYXBwbHlUZXh0SW5wdXQoY20sIHRleHQuc2xpY2Uoc2FtZSksIHByZXZJbnB1dC5sZW5ndGggLSBzYW1lLFxcbiAgICAgICAgICAgICAgICAgICBudWxsLCB0aGlzJDEuY29tcG9zaW5nID8gXFxcIipjb21wb3NlXFxcIiA6IG51bGwpO1xcblxcbiAgICAvLyBEb24ndCBsZWF2ZSBsb25nIHRleHQgaW4gdGhlIHRleHRhcmVhLCBzaW5jZSBpdCBtYWtlcyBmdXJ0aGVyIHBvbGxpbmcgc2xvd1xcbiAgICBpZiAodGV4dC5sZW5ndGggPiAxMDAwIHx8IHRleHQuaW5kZXhPZihcXFwiXFxcXG5cXFwiKSA+IC0xKSB7IGlucHV0LnZhbHVlID0gdGhpcyQxLnByZXZJbnB1dCA9IFxcXCJcXFwiOyB9XFxuICAgIGVsc2UgeyB0aGlzJDEucHJldklucHV0ID0gdGV4dDsgfVxcblxcbiAgICBpZiAodGhpcyQxLmNvbXBvc2luZykge1xcbiAgICAgIHRoaXMkMS5jb21wb3NpbmcucmFuZ2UuY2xlYXIoKTtcXG4gICAgICB0aGlzJDEuY29tcG9zaW5nLnJhbmdlID0gY20ubWFya1RleHQodGhpcyQxLmNvbXBvc2luZy5zdGFydCwgY20uZ2V0Q3Vyc29yKFxcXCJ0b1xcXCIpLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge2NsYXNzTmFtZTogXFxcIkNvZGVNaXJyb3ItY29tcG9zaW5nXFxcIn0pO1xcbiAgICB9XFxuICB9KTtcXG4gIHJldHVybiB0cnVlXFxufTtcXG5cXG5UZXh0YXJlYUlucHV0LnByb3RvdHlwZS5lbnN1cmVQb2xsZWQgPSBmdW5jdGlvbiAoKSB7XFxuICBpZiAodGhpcy5wb2xsaW5nRmFzdCAmJiB0aGlzLnBvbGwoKSkgeyB0aGlzLnBvbGxpbmdGYXN0ID0gZmFsc2U7IH1cXG59O1xcblxcblRleHRhcmVhSW5wdXQucHJvdG90eXBlLm9uS2V5UHJlc3MgPSBmdW5jdGlvbiAoKSB7XFxuICBpZiAoaWUgJiYgaWVfdmVyc2lvbiA+PSA5KSB7IHRoaXMuaGFzU2VsZWN0aW9uID0gbnVsbDsgfVxcbiAgdGhpcy5mYXN0UG9sbCgpO1xcbn07XFxuXFxuVGV4dGFyZWFJbnB1dC5wcm90b3R5cGUub25Db250ZXh0TWVudSA9IGZ1bmN0aW9uIChlKSB7XFxuICB2YXIgaW5wdXQgPSB0aGlzLCBjbSA9IGlucHV0LmNtLCBkaXNwbGF5ID0gY20uZGlzcGxheSwgdGUgPSBpbnB1dC50ZXh0YXJlYTtcXG4gIHZhciBwb3MgPSBwb3NGcm9tTW91c2UoY20sIGUpLCBzY3JvbGxQb3MgPSBkaXNwbGF5LnNjcm9sbGVyLnNjcm9sbFRvcDtcXG4gIGlmICghcG9zIHx8IHByZXN0bykgeyByZXR1cm4gfSAvLyBPcGVyYSBpcyBkaWZmaWN1bHQuXFxuXFxuICAvLyBSZXNldCB0aGUgY3VycmVudCB0ZXh0IHNlbGVjdGlvbiBvbmx5IGlmIHRoZSBjbGljayBpcyBkb25lIG91dHNpZGUgb2YgdGhlIHNlbGVjdGlvblxcbiAgLy8gYW5kICdyZXNldFNlbGVjdGlvbk9uQ29udGV4dE1lbnUnIG9wdGlvbiBpcyB0cnVlLlxcbiAgdmFyIHJlc2V0ID0gY20ub3B0aW9ucy5yZXNldFNlbGVjdGlvbk9uQ29udGV4dE1lbnU7XFxuICBpZiAocmVzZXQgJiYgY20uZG9jLnNlbC5jb250YWlucyhwb3MpID09IC0xKVxcbiAgICB7IG9wZXJhdGlvbihjbSwgc2V0U2VsZWN0aW9uKShjbS5kb2MsIHNpbXBsZVNlbGVjdGlvbihwb3MpLCBzZWxfZG9udFNjcm9sbCk7IH1cXG5cXG4gIHZhciBvbGRDU1MgPSB0ZS5zdHlsZS5jc3NUZXh0LCBvbGRXcmFwcGVyQ1NTID0gaW5wdXQud3JhcHBlci5zdHlsZS5jc3NUZXh0O1xcbiAgaW5wdXQud3JhcHBlci5zdHlsZS5jc3NUZXh0ID0gXFxcInBvc2l0aW9uOiBhYnNvbHV0ZVxcXCI7XFxuICB2YXIgd3JhcHBlckJveCA9IGlucHV0LndyYXBwZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XFxuICB0ZS5zdHlsZS5jc3NUZXh0ID0gXFxcInBvc2l0aW9uOiBhYnNvbHV0ZTsgd2lkdGg6IDMwcHg7IGhlaWdodDogMzBweDtcXFxcbiAgICAgIHRvcDogXFxcIiArIChlLmNsaWVudFkgLSB3cmFwcGVyQm94LnRvcCAtIDUpICsgXFxcInB4OyBsZWZ0OiBcXFwiICsgKGUuY2xpZW50WCAtIHdyYXBwZXJCb3gubGVmdCAtIDUpICsgXFxcInB4O1xcXFxuICAgICAgei1pbmRleDogMTAwMDsgYmFja2dyb3VuZDogXFxcIiArIChpZSA/IFxcXCJyZ2JhKDI1NSwgMjU1LCAyNTUsIC4wNSlcXFwiIDogXFxcInRyYW5zcGFyZW50XFxcIikgKyBcXFwiO1xcXFxuICAgICAgb3V0bGluZTogbm9uZTsgYm9yZGVyLXdpZHRoOiAwOyBvdXRsaW5lOiBub25lOyBvdmVyZmxvdzogaGlkZGVuOyBvcGFjaXR5OiAuMDU7IGZpbHRlcjogYWxwaGEob3BhY2l0eT01KTtcXFwiO1xcbiAgdmFyIG9sZFNjcm9sbFk7XFxuICBpZiAod2Via2l0KSB7IG9sZFNjcm9sbFkgPSB3aW5kb3cuc2Nyb2xsWTsgfSAvLyBXb3JrIGFyb3VuZCBDaHJvbWUgaXNzdWUgKCMyNzEyKVxcbiAgZGlzcGxheS5pbnB1dC5mb2N1cygpO1xcbiAgaWYgKHdlYmtpdCkgeyB3aW5kb3cuc2Nyb2xsVG8obnVsbCwgb2xkU2Nyb2xsWSk7IH1cXG4gIGRpc3BsYXkuaW5wdXQucmVzZXQoKTtcXG4gIC8vIEFkZHMgXFxcIlNlbGVjdCBhbGxcXFwiIHRvIGNvbnRleHQgbWVudSBpbiBGRlxcbiAgaWYgKCFjbS5zb21ldGhpbmdTZWxlY3RlZCgpKSB7IHRlLnZhbHVlID0gaW5wdXQucHJldklucHV0ID0gXFxcIiBcXFwiOyB9XFxuICBpbnB1dC5jb250ZXh0TWVudVBlbmRpbmcgPSB0cnVlO1xcbiAgZGlzcGxheS5zZWxGb3JDb250ZXh0TWVudSA9IGNtLmRvYy5zZWw7XFxuICBjbGVhclRpbWVvdXQoZGlzcGxheS5kZXRlY3RpbmdTZWxlY3RBbGwpO1xcblxcbiAgLy8gU2VsZWN0LWFsbCB3aWxsIGJlIGdyZXllZCBvdXQgaWYgdGhlcmUncyBub3RoaW5nIHRvIHNlbGVjdCwgc29cXG4gIC8vIHRoaXMgYWRkcyBhIHplcm8td2lkdGggc3BhY2Ugc28gdGhhdCB3ZSBjYW4gbGF0ZXIgY2hlY2sgd2hldGhlclxcbiAgLy8gaXQgZ290IHNlbGVjdGVkLlxcbiAgZnVuY3Rpb24gcHJlcGFyZVNlbGVjdEFsbEhhY2soKSB7XFxuICAgIGlmICh0ZS5zZWxlY3Rpb25TdGFydCAhPSBudWxsKSB7XFxuICAgICAgdmFyIHNlbGVjdGVkID0gY20uc29tZXRoaW5nU2VsZWN0ZWQoKTtcXG4gICAgICB2YXIgZXh0dmFsID0gXFxcIlxcXFx1MjAwYlxcXCIgKyAoc2VsZWN0ZWQgPyB0ZS52YWx1ZSA6IFxcXCJcXFwiKTtcXG4gICAgICB0ZS52YWx1ZSA9IFxcXCJcXFxcdTIxZGFcXFwiOyAvLyBVc2VkIHRvIGNhdGNoIGNvbnRleHQtbWVudSB1bmRvXFxuICAgICAgdGUudmFsdWUgPSBleHR2YWw7XFxuICAgICAgaW5wdXQucHJldklucHV0ID0gc2VsZWN0ZWQgPyBcXFwiXFxcIiA6IFxcXCJcXFxcdTIwMGJcXFwiO1xcbiAgICAgIHRlLnNlbGVjdGlvblN0YXJ0ID0gMTsgdGUuc2VsZWN0aW9uRW5kID0gZXh0dmFsLmxlbmd0aDtcXG4gICAgICAvLyBSZS1zZXQgdGhpcywgaW4gY2FzZSBzb21lIG90aGVyIGhhbmRsZXIgdG91Y2hlZCB0aGVcXG4gICAgICAvLyBzZWxlY3Rpb24gaW4gdGhlIG1lYW50aW1lLlxcbiAgICAgIGRpc3BsYXkuc2VsRm9yQ29udGV4dE1lbnUgPSBjbS5kb2Muc2VsO1xcbiAgICB9XFxuICB9XFxuICBmdW5jdGlvbiByZWhpZGUoKSB7XFxuICAgIGlucHV0LmNvbnRleHRNZW51UGVuZGluZyA9IGZhbHNlO1xcbiAgICBpbnB1dC53cmFwcGVyLnN0eWxlLmNzc1RleHQgPSBvbGRXcmFwcGVyQ1NTO1xcbiAgICB0ZS5zdHlsZS5jc3NUZXh0ID0gb2xkQ1NTO1xcbiAgICBpZiAoaWUgJiYgaWVfdmVyc2lvbiA8IDkpIHsgZGlzcGxheS5zY3JvbGxiYXJzLnNldFNjcm9sbFRvcChkaXNwbGF5LnNjcm9sbGVyLnNjcm9sbFRvcCA9IHNjcm9sbFBvcyk7IH1cXG5cXG4gICAgLy8gVHJ5IHRvIGRldGVjdCB0aGUgdXNlciBjaG9vc2luZyBzZWxlY3QtYWxsXFxuICAgIGlmICh0ZS5zZWxlY3Rpb25TdGFydCAhPSBudWxsKSB7XFxuICAgICAgaWYgKCFpZSB8fCAoaWUgJiYgaWVfdmVyc2lvbiA8IDkpKSB7IHByZXBhcmVTZWxlY3RBbGxIYWNrKCk7IH1cXG4gICAgICB2YXIgaSA9IDAsIHBvbGwgPSBmdW5jdGlvbiAoKSB7XFxuICAgICAgICBpZiAoZGlzcGxheS5zZWxGb3JDb250ZXh0TWVudSA9PSBjbS5kb2Muc2VsICYmIHRlLnNlbGVjdGlvblN0YXJ0ID09IDAgJiZcXG4gICAgICAgICAgICB0ZS5zZWxlY3Rpb25FbmQgPiAwICYmIGlucHV0LnByZXZJbnB1dCA9PSBcXFwiXFxcXHUyMDBiXFxcIikge1xcbiAgICAgICAgICBvcGVyYXRpb24oY20sIHNlbGVjdEFsbCkoY20pO1xcbiAgICAgICAgfSBlbHNlIGlmIChpKysgPCAxMCkge1xcbiAgICAgICAgICBkaXNwbGF5LmRldGVjdGluZ1NlbGVjdEFsbCA9IHNldFRpbWVvdXQocG9sbCwgNTAwKTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIGRpc3BsYXkuc2VsRm9yQ29udGV4dE1lbnUgPSBudWxsO1xcbiAgICAgICAgICBkaXNwbGF5LmlucHV0LnJlc2V0KCk7XFxuICAgICAgICB9XFxuICAgICAgfTtcXG4gICAgICBkaXNwbGF5LmRldGVjdGluZ1NlbGVjdEFsbCA9IHNldFRpbWVvdXQocG9sbCwgMjAwKTtcXG4gICAgfVxcbiAgfVxcblxcbiAgaWYgKGllICYmIGllX3ZlcnNpb24gPj0gOSkgeyBwcmVwYXJlU2VsZWN0QWxsSGFjaygpOyB9XFxuICBpZiAoY2FwdHVyZVJpZ2h0Q2xpY2spIHtcXG4gICAgZV9zdG9wKGUpO1xcbiAgICB2YXIgbW91c2V1cCA9IGZ1bmN0aW9uICgpIHtcXG4gICAgICBvZmYod2luZG93LCBcXFwibW91c2V1cFxcXCIsIG1vdXNldXApO1xcbiAgICAgIHNldFRpbWVvdXQocmVoaWRlLCAyMCk7XFxuICAgIH07XFxuICAgIG9uKHdpbmRvdywgXFxcIm1vdXNldXBcXFwiLCBtb3VzZXVwKTtcXG4gIH0gZWxzZSB7XFxuICAgIHNldFRpbWVvdXQocmVoaWRlLCA1MCk7XFxuICB9XFxufTtcXG5cXG5UZXh0YXJlYUlucHV0LnByb3RvdHlwZS5yZWFkT25seUNoYW5nZWQgPSBmdW5jdGlvbiAodmFsKSB7XFxuICBpZiAoIXZhbCkgeyB0aGlzLnJlc2V0KCk7IH1cXG59O1xcblxcblRleHRhcmVhSW5wdXQucHJvdG90eXBlLnNldFVuZWRpdGFibGUgPSBmdW5jdGlvbiAoKSB7fTtcXG5cXG5UZXh0YXJlYUlucHV0LnByb3RvdHlwZS5uZWVkc0NvbnRlbnRBdHRyaWJ1dGUgPSBmYWxzZTtcXG5cXG5mdW5jdGlvbiBmcm9tVGV4dEFyZWEodGV4dGFyZWEsIG9wdGlvbnMpIHtcXG4gIG9wdGlvbnMgPSBvcHRpb25zID8gY29weU9iaihvcHRpb25zKSA6IHt9O1xcbiAgb3B0aW9ucy52YWx1ZSA9IHRleHRhcmVhLnZhbHVlO1xcbiAgaWYgKCFvcHRpb25zLnRhYmluZGV4ICYmIHRleHRhcmVhLnRhYkluZGV4KVxcbiAgICB7IG9wdGlvbnMudGFiaW5kZXggPSB0ZXh0YXJlYS50YWJJbmRleDsgfVxcbiAgaWYgKCFvcHRpb25zLnBsYWNlaG9sZGVyICYmIHRleHRhcmVhLnBsYWNlaG9sZGVyKVxcbiAgICB7IG9wdGlvbnMucGxhY2Vob2xkZXIgPSB0ZXh0YXJlYS5wbGFjZWhvbGRlcjsgfVxcbiAgLy8gU2V0IGF1dG9mb2N1cyB0byB0cnVlIGlmIHRoaXMgdGV4dGFyZWEgaXMgZm9jdXNlZCwgb3IgaWYgaXQgaGFzXFxuICAvLyBhdXRvZm9jdXMgYW5kIG5vIG90aGVyIGVsZW1lbnQgaXMgZm9jdXNlZC5cXG4gIGlmIChvcHRpb25zLmF1dG9mb2N1cyA9PSBudWxsKSB7XFxuICAgIHZhciBoYXNGb2N1cyA9IGFjdGl2ZUVsdCgpO1xcbiAgICBvcHRpb25zLmF1dG9mb2N1cyA9IGhhc0ZvY3VzID09IHRleHRhcmVhIHx8XFxuICAgICAgdGV4dGFyZWEuZ2V0QXR0cmlidXRlKFxcXCJhdXRvZm9jdXNcXFwiKSAhPSBudWxsICYmIGhhc0ZvY3VzID09IGRvY3VtZW50LmJvZHk7XFxuICB9XFxuXFxuICBmdW5jdGlvbiBzYXZlKCkge3RleHRhcmVhLnZhbHVlID0gY20uZ2V0VmFsdWUoKTt9XFxuXFxuICB2YXIgcmVhbFN1Ym1pdDtcXG4gIGlmICh0ZXh0YXJlYS5mb3JtKSB7XFxuICAgIG9uKHRleHRhcmVhLmZvcm0sIFxcXCJzdWJtaXRcXFwiLCBzYXZlKTtcXG4gICAgLy8gRGVwbG9yYWJsZSBoYWNrIHRvIG1ha2UgdGhlIHN1Ym1pdCBtZXRob2QgZG8gdGhlIHJpZ2h0IHRoaW5nLlxcbiAgICBpZiAoIW9wdGlvbnMubGVhdmVTdWJtaXRNZXRob2RBbG9uZSkge1xcbiAgICAgIHZhciBmb3JtID0gdGV4dGFyZWEuZm9ybTtcXG4gICAgICByZWFsU3VibWl0ID0gZm9ybS5zdWJtaXQ7XFxuICAgICAgdHJ5IHtcXG4gICAgICAgIHZhciB3cmFwcGVkU3VibWl0ID0gZm9ybS5zdWJtaXQgPSBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgIHNhdmUoKTtcXG4gICAgICAgICAgZm9ybS5zdWJtaXQgPSByZWFsU3VibWl0O1xcbiAgICAgICAgICBmb3JtLnN1Ym1pdCgpO1xcbiAgICAgICAgICBmb3JtLnN1Ym1pdCA9IHdyYXBwZWRTdWJtaXQ7XFxuICAgICAgICB9O1xcbiAgICAgIH0gY2F0Y2goZSkge31cXG4gICAgfVxcbiAgfVxcblxcbiAgb3B0aW9ucy5maW5pc2hJbml0ID0gZnVuY3Rpb24gKGNtKSB7XFxuICAgIGNtLnNhdmUgPSBzYXZlO1xcbiAgICBjbS5nZXRUZXh0QXJlYSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRleHRhcmVhOyB9O1xcbiAgICBjbS50b1RleHRBcmVhID0gZnVuY3Rpb24gKCkge1xcbiAgICAgIGNtLnRvVGV4dEFyZWEgPSBpc05hTjsgLy8gUHJldmVudCB0aGlzIGZyb20gYmVpbmcgcmFuIHR3aWNlXFxuICAgICAgc2F2ZSgpO1xcbiAgICAgIHRleHRhcmVhLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoY20uZ2V0V3JhcHBlckVsZW1lbnQoKSk7XFxuICAgICAgdGV4dGFyZWEuc3R5bGUuZGlzcGxheSA9IFxcXCJcXFwiO1xcbiAgICAgIGlmICh0ZXh0YXJlYS5mb3JtKSB7XFxuICAgICAgICBvZmYodGV4dGFyZWEuZm9ybSwgXFxcInN1Ym1pdFxcXCIsIHNhdmUpO1xcbiAgICAgICAgaWYgKHR5cGVvZiB0ZXh0YXJlYS5mb3JtLnN1Ym1pdCA9PSBcXFwiZnVuY3Rpb25cXFwiKVxcbiAgICAgICAgICB7IHRleHRhcmVhLmZvcm0uc3VibWl0ID0gcmVhbFN1Ym1pdDsgfVxcbiAgICAgIH1cXG4gICAgfTtcXG4gIH07XFxuXFxuICB0ZXh0YXJlYS5zdHlsZS5kaXNwbGF5ID0gXFxcIm5vbmVcXFwiO1xcbiAgdmFyIGNtID0gQ29kZU1pcnJvciQxKGZ1bmN0aW9uIChub2RlKSB7IHJldHVybiB0ZXh0YXJlYS5wYXJlbnROb2RlLmluc2VydEJlZm9yZShub2RlLCB0ZXh0YXJlYS5uZXh0U2libGluZyk7IH0sXFxuICAgIG9wdGlvbnMpO1xcbiAgcmV0dXJuIGNtXFxufVxcblxcbmZ1bmN0aW9uIGFkZExlZ2FjeVByb3BzKENvZGVNaXJyb3IpIHtcXG4gIENvZGVNaXJyb3Iub2ZmID0gb2ZmO1xcbiAgQ29kZU1pcnJvci5vbiA9IG9uO1xcbiAgQ29kZU1pcnJvci53aGVlbEV2ZW50UGl4ZWxzID0gd2hlZWxFdmVudFBpeGVscztcXG4gIENvZGVNaXJyb3IuRG9jID0gRG9jO1xcbiAgQ29kZU1pcnJvci5zcGxpdExpbmVzID0gc3BsaXRMaW5lc0F1dG87XFxuICBDb2RlTWlycm9yLmNvdW50Q29sdW1uID0gY291bnRDb2x1bW47XFxuICBDb2RlTWlycm9yLmZpbmRDb2x1bW4gPSBmaW5kQ29sdW1uO1xcbiAgQ29kZU1pcnJvci5pc1dvcmRDaGFyID0gaXNXb3JkQ2hhckJhc2ljO1xcbiAgQ29kZU1pcnJvci5QYXNzID0gUGFzcztcXG4gIENvZGVNaXJyb3Iuc2lnbmFsID0gc2lnbmFsO1xcbiAgQ29kZU1pcnJvci5MaW5lID0gTGluZTtcXG4gIENvZGVNaXJyb3IuY2hhbmdlRW5kID0gY2hhbmdlRW5kO1xcbiAgQ29kZU1pcnJvci5zY3JvbGxiYXJNb2RlbCA9IHNjcm9sbGJhck1vZGVsO1xcbiAgQ29kZU1pcnJvci5Qb3MgPSBQb3M7XFxuICBDb2RlTWlycm9yLmNtcFBvcyA9IGNtcDtcXG4gIENvZGVNaXJyb3IubW9kZXMgPSBtb2RlcztcXG4gIENvZGVNaXJyb3IubWltZU1vZGVzID0gbWltZU1vZGVzO1xcbiAgQ29kZU1pcnJvci5yZXNvbHZlTW9kZSA9IHJlc29sdmVNb2RlO1xcbiAgQ29kZU1pcnJvci5nZXRNb2RlID0gZ2V0TW9kZTtcXG4gIENvZGVNaXJyb3IubW9kZUV4dGVuc2lvbnMgPSBtb2RlRXh0ZW5zaW9ucztcXG4gIENvZGVNaXJyb3IuZXh0ZW5kTW9kZSA9IGV4dGVuZE1vZGU7XFxuICBDb2RlTWlycm9yLmNvcHlTdGF0ZSA9IGNvcHlTdGF0ZTtcXG4gIENvZGVNaXJyb3Iuc3RhcnRTdGF0ZSA9IHN0YXJ0U3RhdGU7XFxuICBDb2RlTWlycm9yLmlubmVyTW9kZSA9IGlubmVyTW9kZTtcXG4gIENvZGVNaXJyb3IuY29tbWFuZHMgPSBjb21tYW5kcztcXG4gIENvZGVNaXJyb3Iua2V5TWFwID0ga2V5TWFwO1xcbiAgQ29kZU1pcnJvci5rZXlOYW1lID0ga2V5TmFtZTtcXG4gIENvZGVNaXJyb3IuaXNNb2RpZmllcktleSA9IGlzTW9kaWZpZXJLZXk7XFxuICBDb2RlTWlycm9yLmxvb2t1cEtleSA9IGxvb2t1cEtleTtcXG4gIENvZGVNaXJyb3Iubm9ybWFsaXplS2V5TWFwID0gbm9ybWFsaXplS2V5TWFwO1xcbiAgQ29kZU1pcnJvci5TdHJpbmdTdHJlYW0gPSBTdHJpbmdTdHJlYW07XFxuICBDb2RlTWlycm9yLlNoYXJlZFRleHRNYXJrZXIgPSBTaGFyZWRUZXh0TWFya2VyO1xcbiAgQ29kZU1pcnJvci5UZXh0TWFya2VyID0gVGV4dE1hcmtlcjtcXG4gIENvZGVNaXJyb3IuTGluZVdpZGdldCA9IExpbmVXaWRnZXQ7XFxuICBDb2RlTWlycm9yLmVfcHJldmVudERlZmF1bHQgPSBlX3ByZXZlbnREZWZhdWx0O1xcbiAgQ29kZU1pcnJvci5lX3N0b3BQcm9wYWdhdGlvbiA9IGVfc3RvcFByb3BhZ2F0aW9uO1xcbiAgQ29kZU1pcnJvci5lX3N0b3AgPSBlX3N0b3A7XFxuICBDb2RlTWlycm9yLmFkZENsYXNzID0gYWRkQ2xhc3M7XFxuICBDb2RlTWlycm9yLmNvbnRhaW5zID0gY29udGFpbnM7XFxuICBDb2RlTWlycm9yLnJtQ2xhc3MgPSBybUNsYXNzO1xcbiAgQ29kZU1pcnJvci5rZXlOYW1lcyA9IGtleU5hbWVzO1xcbn1cXG5cXG4vLyBFRElUT1IgQ09OU1RSVUNUT1JcXG5cXG5kZWZpbmVPcHRpb25zKENvZGVNaXJyb3IkMSk7XFxuXFxuYWRkRWRpdG9yTWV0aG9kcyhDb2RlTWlycm9yJDEpO1xcblxcbi8vIFNldCB1cCBtZXRob2RzIG9uIENvZGVNaXJyb3IncyBwcm90b3R5cGUgdG8gcmVkaXJlY3QgdG8gdGhlIGVkaXRvcidzIGRvY3VtZW50LlxcbnZhciBkb250RGVsZWdhdGUgPSBcXFwiaXRlciBpbnNlcnQgcmVtb3ZlIGNvcHkgZ2V0RWRpdG9yIGNvbnN0cnVjdG9yXFxcIi5zcGxpdChcXFwiIFxcXCIpO1xcbmZvciAodmFyIHByb3AgaW4gRG9jLnByb3RvdHlwZSkgeyBpZiAoRG9jLnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eShwcm9wKSAmJiBpbmRleE9mKGRvbnREZWxlZ2F0ZSwgcHJvcCkgPCAwKVxcbiAgeyBDb2RlTWlycm9yJDEucHJvdG90eXBlW3Byb3BdID0gKGZ1bmN0aW9uKG1ldGhvZCkge1xcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7cmV0dXJuIG1ldGhvZC5hcHBseSh0aGlzLmRvYywgYXJndW1lbnRzKX1cXG4gIH0pKERvYy5wcm90b3R5cGVbcHJvcF0pOyB9IH1cXG5cXG5ldmVudE1peGluKERvYyk7XFxuXFxuLy8gSU5QVVQgSEFORExJTkdcXG5cXG5Db2RlTWlycm9yJDEuaW5wdXRTdHlsZXMgPSB7XFxcInRleHRhcmVhXFxcIjogVGV4dGFyZWFJbnB1dCwgXFxcImNvbnRlbnRlZGl0YWJsZVxcXCI6IENvbnRlbnRFZGl0YWJsZUlucHV0fTtcXG5cXG4vLyBNT0RFIERFRklOSVRJT04gQU5EIFFVRVJZSU5HXFxuXFxuLy8gRXh0cmEgYXJndW1lbnRzIGFyZSBzdG9yZWQgYXMgdGhlIG1vZGUncyBkZXBlbmRlbmNpZXMsIHdoaWNoIGlzXFxuLy8gdXNlZCBieSAobGVnYWN5KSBtZWNoYW5pc21zIGxpa2UgbG9hZG1vZGUuanMgdG8gYXV0b21hdGljYWxseVxcbi8vIGxvYWQgYSBtb2RlLiAoUHJlZmVycmVkIG1lY2hhbmlzbSBpcyB0aGUgcmVxdWlyZS9kZWZpbmUgY2FsbHMuKVxcbkNvZGVNaXJyb3IkMS5kZWZpbmVNb2RlID0gZnVuY3Rpb24obmFtZS8qLCBtb2RlLCDigKYqLykge1xcbiAgaWYgKCFDb2RlTWlycm9yJDEuZGVmYXVsdHMubW9kZSAmJiBuYW1lICE9IFxcXCJudWxsXFxcIikgeyBDb2RlTWlycm9yJDEuZGVmYXVsdHMubW9kZSA9IG5hbWU7IH1cXG4gIGRlZmluZU1vZGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcXG59O1xcblxcbkNvZGVNaXJyb3IkMS5kZWZpbmVNSU1FID0gZGVmaW5lTUlNRTtcXG5cXG4vLyBNaW5pbWFsIGRlZmF1bHQgbW9kZS5cXG5Db2RlTWlycm9yJDEuZGVmaW5lTW9kZShcXFwibnVsbFxcXCIsIGZ1bmN0aW9uICgpIHsgcmV0dXJuICh7dG9rZW46IGZ1bmN0aW9uIChzdHJlYW0pIHsgcmV0dXJuIHN0cmVhbS5za2lwVG9FbmQoKTsgfX0pOyB9KTtcXG5Db2RlTWlycm9yJDEuZGVmaW5lTUlNRShcXFwidGV4dC9wbGFpblxcXCIsIFxcXCJudWxsXFxcIik7XFxuXFxuLy8gRVhURU5TSU9OU1xcblxcbkNvZGVNaXJyb3IkMS5kZWZpbmVFeHRlbnNpb24gPSBmdW5jdGlvbiAobmFtZSwgZnVuYykge1xcbiAgQ29kZU1pcnJvciQxLnByb3RvdHlwZVtuYW1lXSA9IGZ1bmM7XFxufTtcXG5Db2RlTWlycm9yJDEuZGVmaW5lRG9jRXh0ZW5zaW9uID0gZnVuY3Rpb24gKG5hbWUsIGZ1bmMpIHtcXG4gIERvYy5wcm90b3R5cGVbbmFtZV0gPSBmdW5jO1xcbn07XFxuXFxuQ29kZU1pcnJvciQxLmZyb21UZXh0QXJlYSA9IGZyb21UZXh0QXJlYTtcXG5cXG5hZGRMZWdhY3lQcm9wcyhDb2RlTWlycm9yJDEpO1xcblxcbkNvZGVNaXJyb3IkMS52ZXJzaW9uID0gXFxcIjUuMjUuMFxcXCI7XFxuXFxucmV0dXJuIENvZGVNaXJyb3IkMTtcXG5cXG59KSkpO1xcblwiXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3Jhdy1sb2FkZXIhLi9+L2NvZGVtaXJyb3IvbGliL2NvZGVtaXJyb3IuanNcbi8vIG1vZHVsZSBpZCA9IDVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQSIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	eval("__webpack_require__(2)(__webpack_require__(7))//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL34vY29kZW1pcnJvci9tb2RlL3htbC94bWwuanM/ODBhNyJdLCJzb3VyY2VzQ29udGVudCI6WyJyZXF1aXJlKFwiISEvdmFyL2FwcC93ZWIvanMvbm9kZV9tb2R1bGVzL3NjcmlwdC1sb2FkZXIvYWRkU2NyaXB0LmpzXCIpKHJlcXVpcmUoXCIhIS92YXIvYXBwL3dlYi9qcy9ub2RlX21vZHVsZXMvcmF3LWxvYWRlci9pbmRleC5qcyEvdmFyL2FwcC93ZWIvanMvbm9kZV9tb2R1bGVzL2NvZGVtaXJyb3IvbW9kZS94bWwveG1sLmpzXCIpKVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9zY3JpcHQtbG9hZGVyIS4vfi9jb2RlbWlycm9yL21vZGUveG1sL3htbC5qc1xuLy8gbW9kdWxlIGlkID0gNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 7 */
/***/ function(module, exports) {

	eval("module.exports = \"// CodeMirror, copyright (c) by Marijn Haverbeke and others\\n// Distributed under an MIT license: http://codemirror.net/LICENSE\\n\\n(function(mod) {\\n  if (typeof exports == \\\"object\\\" && typeof module == \\\"object\\\") // CommonJS\\n    mod(require(\\\"../../lib/codemirror\\\"));\\n  else if (typeof define == \\\"function\\\" && define.amd) // AMD\\n    define([\\\"../../lib/codemirror\\\"], mod);\\n  else // Plain browser env\\n    mod(CodeMirror);\\n})(function(CodeMirror) {\\n\\\"use strict\\\";\\n\\nvar htmlConfig = {\\n  autoSelfClosers: {'area': true, 'base': true, 'br': true, 'col': true, 'command': true,\\n                    'embed': true, 'frame': true, 'hr': true, 'img': true, 'input': true,\\n                    'keygen': true, 'link': true, 'meta': true, 'param': true, 'source': true,\\n                    'track': true, 'wbr': true, 'menuitem': true},\\n  implicitlyClosed: {'dd': true, 'li': true, 'optgroup': true, 'option': true, 'p': true,\\n                     'rp': true, 'rt': true, 'tbody': true, 'td': true, 'tfoot': true,\\n                     'th': true, 'tr': true},\\n  contextGrabbers: {\\n    'dd': {'dd': true, 'dt': true},\\n    'dt': {'dd': true, 'dt': true},\\n    'li': {'li': true},\\n    'option': {'option': true, 'optgroup': true},\\n    'optgroup': {'optgroup': true},\\n    'p': {'address': true, 'article': true, 'aside': true, 'blockquote': true, 'dir': true,\\n          'div': true, 'dl': true, 'fieldset': true, 'footer': true, 'form': true,\\n          'h1': true, 'h2': true, 'h3': true, 'h4': true, 'h5': true, 'h6': true,\\n          'header': true, 'hgroup': true, 'hr': true, 'menu': true, 'nav': true, 'ol': true,\\n          'p': true, 'pre': true, 'section': true, 'table': true, 'ul': true},\\n    'rp': {'rp': true, 'rt': true},\\n    'rt': {'rp': true, 'rt': true},\\n    'tbody': {'tbody': true, 'tfoot': true},\\n    'td': {'td': true, 'th': true},\\n    'tfoot': {'tbody': true},\\n    'th': {'td': true, 'th': true},\\n    'thead': {'tbody': true, 'tfoot': true},\\n    'tr': {'tr': true}\\n  },\\n  doNotIndent: {\\\"pre\\\": true},\\n  allowUnquoted: true,\\n  allowMissing: true,\\n  caseFold: true\\n}\\n\\nvar xmlConfig = {\\n  autoSelfClosers: {},\\n  implicitlyClosed: {},\\n  contextGrabbers: {},\\n  doNotIndent: {},\\n  allowUnquoted: false,\\n  allowMissing: false,\\n  caseFold: false\\n}\\n\\nCodeMirror.defineMode(\\\"xml\\\", function(editorConf, config_) {\\n  var indentUnit = editorConf.indentUnit\\n  var config = {}\\n  var defaults = config_.htmlMode ? htmlConfig : xmlConfig\\n  for (var prop in defaults) config[prop] = defaults[prop]\\n  for (var prop in config_) config[prop] = config_[prop]\\n\\n  // Return variables for tokenizers\\n  var type, setStyle;\\n\\n  function inText(stream, state) {\\n    function chain(parser) {\\n      state.tokenize = parser;\\n      return parser(stream, state);\\n    }\\n\\n    var ch = stream.next();\\n    if (ch == \\\"<\\\") {\\n      if (stream.eat(\\\"!\\\")) {\\n        if (stream.eat(\\\"[\\\")) {\\n          if (stream.match(\\\"CDATA[\\\")) return chain(inBlock(\\\"atom\\\", \\\"]]>\\\"));\\n          else return null;\\n        } else if (stream.match(\\\"--\\\")) {\\n          return chain(inBlock(\\\"comment\\\", \\\"-->\\\"));\\n        } else if (stream.match(\\\"DOCTYPE\\\", true, true)) {\\n          stream.eatWhile(/[\\\\w\\\\._\\\\-]/);\\n          return chain(doctype(1));\\n        } else {\\n          return null;\\n        }\\n      } else if (stream.eat(\\\"?\\\")) {\\n        stream.eatWhile(/[\\\\w\\\\._\\\\-]/);\\n        state.tokenize = inBlock(\\\"meta\\\", \\\"?>\\\");\\n        return \\\"meta\\\";\\n      } else {\\n        type = stream.eat(\\\"/\\\") ? \\\"closeTag\\\" : \\\"openTag\\\";\\n        state.tokenize = inTag;\\n        return \\\"tag bracket\\\";\\n      }\\n    } else if (ch == \\\"&\\\") {\\n      var ok;\\n      if (stream.eat(\\\"#\\\")) {\\n        if (stream.eat(\\\"x\\\")) {\\n          ok = stream.eatWhile(/[a-fA-F\\\\d]/) && stream.eat(\\\";\\\");\\n        } else {\\n          ok = stream.eatWhile(/[\\\\d]/) && stream.eat(\\\";\\\");\\n        }\\n      } else {\\n        ok = stream.eatWhile(/[\\\\w\\\\.\\\\-:]/) && stream.eat(\\\";\\\");\\n      }\\n      return ok ? \\\"atom\\\" : \\\"error\\\";\\n    } else {\\n      stream.eatWhile(/[^&<]/);\\n      return null;\\n    }\\n  }\\n  inText.isInText = true;\\n\\n  function inTag(stream, state) {\\n    var ch = stream.next();\\n    if (ch == \\\">\\\" || (ch == \\\"/\\\" && stream.eat(\\\">\\\"))) {\\n      state.tokenize = inText;\\n      type = ch == \\\">\\\" ? \\\"endTag\\\" : \\\"selfcloseTag\\\";\\n      return \\\"tag bracket\\\";\\n    } else if (ch == \\\"=\\\") {\\n      type = \\\"equals\\\";\\n      return null;\\n    } else if (ch == \\\"<\\\") {\\n      state.tokenize = inText;\\n      state.state = baseState;\\n      state.tagName = state.tagStart = null;\\n      var next = state.tokenize(stream, state);\\n      return next ? next + \\\" tag error\\\" : \\\"tag error\\\";\\n    } else if (/[\\\\'\\\\\\\"]/.test(ch)) {\\n      state.tokenize = inAttribute(ch);\\n      state.stringStartCol = stream.column();\\n      return state.tokenize(stream, state);\\n    } else {\\n      stream.match(/^[^\\\\s\\\\u00a0=<>\\\\\\\"\\\\']*[^\\\\s\\\\u00a0=<>\\\\\\\"\\\\'\\\\/]/);\\n      return \\\"word\\\";\\n    }\\n  }\\n\\n  function inAttribute(quote) {\\n    var closure = function(stream, state) {\\n      while (!stream.eol()) {\\n        if (stream.next() == quote) {\\n          state.tokenize = inTag;\\n          break;\\n        }\\n      }\\n      return \\\"string\\\";\\n    };\\n    closure.isInAttribute = true;\\n    return closure;\\n  }\\n\\n  function inBlock(style, terminator) {\\n    return function(stream, state) {\\n      while (!stream.eol()) {\\n        if (stream.match(terminator)) {\\n          state.tokenize = inText;\\n          break;\\n        }\\n        stream.next();\\n      }\\n      return style;\\n    };\\n  }\\n  function doctype(depth) {\\n    return function(stream, state) {\\n      var ch;\\n      while ((ch = stream.next()) != null) {\\n        if (ch == \\\"<\\\") {\\n          state.tokenize = doctype(depth + 1);\\n          return state.tokenize(stream, state);\\n        } else if (ch == \\\">\\\") {\\n          if (depth == 1) {\\n            state.tokenize = inText;\\n            break;\\n          } else {\\n            state.tokenize = doctype(depth - 1);\\n            return state.tokenize(stream, state);\\n          }\\n        }\\n      }\\n      return \\\"meta\\\";\\n    };\\n  }\\n\\n  function Context(state, tagName, startOfLine) {\\n    this.prev = state.context;\\n    this.tagName = tagName;\\n    this.indent = state.indented;\\n    this.startOfLine = startOfLine;\\n    if (config.doNotIndent.hasOwnProperty(tagName) || (state.context && state.context.noIndent))\\n      this.noIndent = true;\\n  }\\n  function popContext(state) {\\n    if (state.context) state.context = state.context.prev;\\n  }\\n  function maybePopContext(state, nextTagName) {\\n    var parentTagName;\\n    while (true) {\\n      if (!state.context) {\\n        return;\\n      }\\n      parentTagName = state.context.tagName;\\n      if (!config.contextGrabbers.hasOwnProperty(parentTagName) ||\\n          !config.contextGrabbers[parentTagName].hasOwnProperty(nextTagName)) {\\n        return;\\n      }\\n      popContext(state);\\n    }\\n  }\\n\\n  function baseState(type, stream, state) {\\n    if (type == \\\"openTag\\\") {\\n      state.tagStart = stream.column();\\n      return tagNameState;\\n    } else if (type == \\\"closeTag\\\") {\\n      return closeTagNameState;\\n    } else {\\n      return baseState;\\n    }\\n  }\\n  function tagNameState(type, stream, state) {\\n    if (type == \\\"word\\\") {\\n      state.tagName = stream.current();\\n      setStyle = \\\"tag\\\";\\n      return attrState;\\n    } else {\\n      setStyle = \\\"error\\\";\\n      return tagNameState;\\n    }\\n  }\\n  function closeTagNameState(type, stream, state) {\\n    if (type == \\\"word\\\") {\\n      var tagName = stream.current();\\n      if (state.context && state.context.tagName != tagName &&\\n          config.implicitlyClosed.hasOwnProperty(state.context.tagName))\\n        popContext(state);\\n      if ((state.context && state.context.tagName == tagName) || config.matchClosing === false) {\\n        setStyle = \\\"tag\\\";\\n        return closeState;\\n      } else {\\n        setStyle = \\\"tag error\\\";\\n        return closeStateErr;\\n      }\\n    } else {\\n      setStyle = \\\"error\\\";\\n      return closeStateErr;\\n    }\\n  }\\n\\n  function closeState(type, _stream, state) {\\n    if (type != \\\"endTag\\\") {\\n      setStyle = \\\"error\\\";\\n      return closeState;\\n    }\\n    popContext(state);\\n    return baseState;\\n  }\\n  function closeStateErr(type, stream, state) {\\n    setStyle = \\\"error\\\";\\n    return closeState(type, stream, state);\\n  }\\n\\n  function attrState(type, _stream, state) {\\n    if (type == \\\"word\\\") {\\n      setStyle = \\\"attribute\\\";\\n      return attrEqState;\\n    } else if (type == \\\"endTag\\\" || type == \\\"selfcloseTag\\\") {\\n      var tagName = state.tagName, tagStart = state.tagStart;\\n      state.tagName = state.tagStart = null;\\n      if (type == \\\"selfcloseTag\\\" ||\\n          config.autoSelfClosers.hasOwnProperty(tagName)) {\\n        maybePopContext(state, tagName);\\n      } else {\\n        maybePopContext(state, tagName);\\n        state.context = new Context(state, tagName, tagStart == state.indented);\\n      }\\n      return baseState;\\n    }\\n    setStyle = \\\"error\\\";\\n    return attrState;\\n  }\\n  function attrEqState(type, stream, state) {\\n    if (type == \\\"equals\\\") return attrValueState;\\n    if (!config.allowMissing) setStyle = \\\"error\\\";\\n    return attrState(type, stream, state);\\n  }\\n  function attrValueState(type, stream, state) {\\n    if (type == \\\"string\\\") return attrContinuedState;\\n    if (type == \\\"word\\\" && config.allowUnquoted) {setStyle = \\\"string\\\"; return attrState;}\\n    setStyle = \\\"error\\\";\\n    return attrState(type, stream, state);\\n  }\\n  function attrContinuedState(type, stream, state) {\\n    if (type == \\\"string\\\") return attrContinuedState;\\n    return attrState(type, stream, state);\\n  }\\n\\n  return {\\n    startState: function(baseIndent) {\\n      var state = {tokenize: inText,\\n                   state: baseState,\\n                   indented: baseIndent || 0,\\n                   tagName: null, tagStart: null,\\n                   context: null}\\n      if (baseIndent != null) state.baseIndent = baseIndent\\n      return state\\n    },\\n\\n    token: function(stream, state) {\\n      if (!state.tagName && stream.sol())\\n        state.indented = stream.indentation();\\n\\n      if (stream.eatSpace()) return null;\\n      type = null;\\n      var style = state.tokenize(stream, state);\\n      if ((style || type) && style != \\\"comment\\\") {\\n        setStyle = null;\\n        state.state = state.state(type || style, stream, state);\\n        if (setStyle)\\n          style = setStyle == \\\"error\\\" ? style + \\\" error\\\" : setStyle;\\n      }\\n      return style;\\n    },\\n\\n    indent: function(state, textAfter, fullLine) {\\n      var context = state.context;\\n      // Indent multi-line strings (e.g. css).\\n      if (state.tokenize.isInAttribute) {\\n        if (state.tagStart == state.indented)\\n          return state.stringStartCol + 1;\\n        else\\n          return state.indented + indentUnit;\\n      }\\n      if (context && context.noIndent) return CodeMirror.Pass;\\n      if (state.tokenize != inTag && state.tokenize != inText)\\n        return fullLine ? fullLine.match(/^(\\\\s*)/)[0].length : 0;\\n      // Indent the starts of attribute names.\\n      if (state.tagName) {\\n        if (config.multilineTagIndentPastTag !== false)\\n          return state.tagStart + state.tagName.length + 2;\\n        else\\n          return state.tagStart + indentUnit * (config.multilineTagIndentFactor || 1);\\n      }\\n      if (config.alignCDATA && /<!\\\\[CDATA\\\\[/.test(textAfter)) return 0;\\n      var tagAfter = textAfter && /^<(\\\\/)?([\\\\w_:\\\\.-]*)/.exec(textAfter);\\n      if (tagAfter && tagAfter[1]) { // Closing tag spotted\\n        while (context) {\\n          if (context.tagName == tagAfter[2]) {\\n            context = context.prev;\\n            break;\\n          } else if (config.implicitlyClosed.hasOwnProperty(context.tagName)) {\\n            context = context.prev;\\n          } else {\\n            break;\\n          }\\n        }\\n      } else if (tagAfter) { // Opening tag spotted\\n        while (context) {\\n          var grabbers = config.contextGrabbers[context.tagName];\\n          if (grabbers && grabbers.hasOwnProperty(tagAfter[2]))\\n            context = context.prev;\\n          else\\n            break;\\n        }\\n      }\\n      while (context && context.prev && !context.startOfLine)\\n        context = context.prev;\\n      if (context) return context.indent + indentUnit;\\n      else return state.baseIndent || 0;\\n    },\\n\\n    electricInput: /<\\\\/[\\\\s\\\\w:]+>$/,\\n    blockCommentStart: \\\"<!--\\\",\\n    blockCommentEnd: \\\"-->\\\",\\n\\n    configuration: config.htmlMode ? \\\"html\\\" : \\\"xml\\\",\\n    helperType: config.htmlMode ? \\\"html\\\" : \\\"xml\\\",\\n\\n    skipAttribute: function(state) {\\n      if (state.state == attrValueState)\\n        state.state = attrState\\n    }\\n  };\\n});\\n\\nCodeMirror.defineMIME(\\\"text/xml\\\", \\\"xml\\\");\\nCodeMirror.defineMIME(\\\"application/xml\\\", \\\"xml\\\");\\nif (!CodeMirror.mimeModes.hasOwnProperty(\\\"text/html\\\"))\\n  CodeMirror.defineMIME(\\\"text/html\\\", {name: \\\"xml\\\", htmlMode: true});\\n\\n});\\n\"//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL34vY29kZW1pcnJvci9tb2RlL3htbC94bWwuanM/Y2MzNSJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IFwiLy8gQ29kZU1pcnJvciwgY29weXJpZ2h0IChjKSBieSBNYXJpam4gSGF2ZXJiZWtlIGFuZCBvdGhlcnNcXG4vLyBEaXN0cmlidXRlZCB1bmRlciBhbiBNSVQgbGljZW5zZTogaHR0cDovL2NvZGVtaXJyb3IubmV0L0xJQ0VOU0VcXG5cXG4oZnVuY3Rpb24obW9kKSB7XFxuICBpZiAodHlwZW9mIGV4cG9ydHMgPT0gXFxcIm9iamVjdFxcXCIgJiYgdHlwZW9mIG1vZHVsZSA9PSBcXFwib2JqZWN0XFxcIikgLy8gQ29tbW9uSlNcXG4gICAgbW9kKHJlcXVpcmUoXFxcIi4uLy4uL2xpYi9jb2RlbWlycm9yXFxcIikpO1xcbiAgZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PSBcXFwiZnVuY3Rpb25cXFwiICYmIGRlZmluZS5hbWQpIC8vIEFNRFxcbiAgICBkZWZpbmUoW1xcXCIuLi8uLi9saWIvY29kZW1pcnJvclxcXCJdLCBtb2QpO1xcbiAgZWxzZSAvLyBQbGFpbiBicm93c2VyIGVudlxcbiAgICBtb2QoQ29kZU1pcnJvcik7XFxufSkoZnVuY3Rpb24oQ29kZU1pcnJvcikge1xcblxcXCJ1c2Ugc3RyaWN0XFxcIjtcXG5cXG52YXIgaHRtbENvbmZpZyA9IHtcXG4gIGF1dG9TZWxmQ2xvc2VyczogeydhcmVhJzogdHJ1ZSwgJ2Jhc2UnOiB0cnVlLCAnYnInOiB0cnVlLCAnY29sJzogdHJ1ZSwgJ2NvbW1hbmQnOiB0cnVlLFxcbiAgICAgICAgICAgICAgICAgICAgJ2VtYmVkJzogdHJ1ZSwgJ2ZyYW1lJzogdHJ1ZSwgJ2hyJzogdHJ1ZSwgJ2ltZyc6IHRydWUsICdpbnB1dCc6IHRydWUsXFxuICAgICAgICAgICAgICAgICAgICAna2V5Z2VuJzogdHJ1ZSwgJ2xpbmsnOiB0cnVlLCAnbWV0YSc6IHRydWUsICdwYXJhbSc6IHRydWUsICdzb3VyY2UnOiB0cnVlLFxcbiAgICAgICAgICAgICAgICAgICAgJ3RyYWNrJzogdHJ1ZSwgJ3dicic6IHRydWUsICdtZW51aXRlbSc6IHRydWV9LFxcbiAgaW1wbGljaXRseUNsb3NlZDogeydkZCc6IHRydWUsICdsaSc6IHRydWUsICdvcHRncm91cCc6IHRydWUsICdvcHRpb24nOiB0cnVlLCAncCc6IHRydWUsXFxuICAgICAgICAgICAgICAgICAgICAgJ3JwJzogdHJ1ZSwgJ3J0JzogdHJ1ZSwgJ3Rib2R5JzogdHJ1ZSwgJ3RkJzogdHJ1ZSwgJ3Rmb290JzogdHJ1ZSxcXG4gICAgICAgICAgICAgICAgICAgICAndGgnOiB0cnVlLCAndHInOiB0cnVlfSxcXG4gIGNvbnRleHRHcmFiYmVyczoge1xcbiAgICAnZGQnOiB7J2RkJzogdHJ1ZSwgJ2R0JzogdHJ1ZX0sXFxuICAgICdkdCc6IHsnZGQnOiB0cnVlLCAnZHQnOiB0cnVlfSxcXG4gICAgJ2xpJzogeydsaSc6IHRydWV9LFxcbiAgICAnb3B0aW9uJzogeydvcHRpb24nOiB0cnVlLCAnb3B0Z3JvdXAnOiB0cnVlfSxcXG4gICAgJ29wdGdyb3VwJzogeydvcHRncm91cCc6IHRydWV9LFxcbiAgICAncCc6IHsnYWRkcmVzcyc6IHRydWUsICdhcnRpY2xlJzogdHJ1ZSwgJ2FzaWRlJzogdHJ1ZSwgJ2Jsb2NrcXVvdGUnOiB0cnVlLCAnZGlyJzogdHJ1ZSxcXG4gICAgICAgICAgJ2Rpdic6IHRydWUsICdkbCc6IHRydWUsICdmaWVsZHNldCc6IHRydWUsICdmb290ZXInOiB0cnVlLCAnZm9ybSc6IHRydWUsXFxuICAgICAgICAgICdoMSc6IHRydWUsICdoMic6IHRydWUsICdoMyc6IHRydWUsICdoNCc6IHRydWUsICdoNSc6IHRydWUsICdoNic6IHRydWUsXFxuICAgICAgICAgICdoZWFkZXInOiB0cnVlLCAnaGdyb3VwJzogdHJ1ZSwgJ2hyJzogdHJ1ZSwgJ21lbnUnOiB0cnVlLCAnbmF2JzogdHJ1ZSwgJ29sJzogdHJ1ZSxcXG4gICAgICAgICAgJ3AnOiB0cnVlLCAncHJlJzogdHJ1ZSwgJ3NlY3Rpb24nOiB0cnVlLCAndGFibGUnOiB0cnVlLCAndWwnOiB0cnVlfSxcXG4gICAgJ3JwJzogeydycCc6IHRydWUsICdydCc6IHRydWV9LFxcbiAgICAncnQnOiB7J3JwJzogdHJ1ZSwgJ3J0JzogdHJ1ZX0sXFxuICAgICd0Ym9keSc6IHsndGJvZHknOiB0cnVlLCAndGZvb3QnOiB0cnVlfSxcXG4gICAgJ3RkJzogeyd0ZCc6IHRydWUsICd0aCc6IHRydWV9LFxcbiAgICAndGZvb3QnOiB7J3Rib2R5JzogdHJ1ZX0sXFxuICAgICd0aCc6IHsndGQnOiB0cnVlLCAndGgnOiB0cnVlfSxcXG4gICAgJ3RoZWFkJzogeyd0Ym9keSc6IHRydWUsICd0Zm9vdCc6IHRydWV9LFxcbiAgICAndHInOiB7J3RyJzogdHJ1ZX1cXG4gIH0sXFxuICBkb05vdEluZGVudDoge1xcXCJwcmVcXFwiOiB0cnVlfSxcXG4gIGFsbG93VW5xdW90ZWQ6IHRydWUsXFxuICBhbGxvd01pc3Npbmc6IHRydWUsXFxuICBjYXNlRm9sZDogdHJ1ZVxcbn1cXG5cXG52YXIgeG1sQ29uZmlnID0ge1xcbiAgYXV0b1NlbGZDbG9zZXJzOiB7fSxcXG4gIGltcGxpY2l0bHlDbG9zZWQ6IHt9LFxcbiAgY29udGV4dEdyYWJiZXJzOiB7fSxcXG4gIGRvTm90SW5kZW50OiB7fSxcXG4gIGFsbG93VW5xdW90ZWQ6IGZhbHNlLFxcbiAgYWxsb3dNaXNzaW5nOiBmYWxzZSxcXG4gIGNhc2VGb2xkOiBmYWxzZVxcbn1cXG5cXG5Db2RlTWlycm9yLmRlZmluZU1vZGUoXFxcInhtbFxcXCIsIGZ1bmN0aW9uKGVkaXRvckNvbmYsIGNvbmZpZ18pIHtcXG4gIHZhciBpbmRlbnRVbml0ID0gZWRpdG9yQ29uZi5pbmRlbnRVbml0XFxuICB2YXIgY29uZmlnID0ge31cXG4gIHZhciBkZWZhdWx0cyA9IGNvbmZpZ18uaHRtbE1vZGUgPyBodG1sQ29uZmlnIDogeG1sQ29uZmlnXFxuICBmb3IgKHZhciBwcm9wIGluIGRlZmF1bHRzKSBjb25maWdbcHJvcF0gPSBkZWZhdWx0c1twcm9wXVxcbiAgZm9yICh2YXIgcHJvcCBpbiBjb25maWdfKSBjb25maWdbcHJvcF0gPSBjb25maWdfW3Byb3BdXFxuXFxuICAvLyBSZXR1cm4gdmFyaWFibGVzIGZvciB0b2tlbml6ZXJzXFxuICB2YXIgdHlwZSwgc2V0U3R5bGU7XFxuXFxuICBmdW5jdGlvbiBpblRleHQoc3RyZWFtLCBzdGF0ZSkge1xcbiAgICBmdW5jdGlvbiBjaGFpbihwYXJzZXIpIHtcXG4gICAgICBzdGF0ZS50b2tlbml6ZSA9IHBhcnNlcjtcXG4gICAgICByZXR1cm4gcGFyc2VyKHN0cmVhbSwgc3RhdGUpO1xcbiAgICB9XFxuXFxuICAgIHZhciBjaCA9IHN0cmVhbS5uZXh0KCk7XFxuICAgIGlmIChjaCA9PSBcXFwiPFxcXCIpIHtcXG4gICAgICBpZiAoc3RyZWFtLmVhdChcXFwiIVxcXCIpKSB7XFxuICAgICAgICBpZiAoc3RyZWFtLmVhdChcXFwiW1xcXCIpKSB7XFxuICAgICAgICAgIGlmIChzdHJlYW0ubWF0Y2goXFxcIkNEQVRBW1xcXCIpKSByZXR1cm4gY2hhaW4oaW5CbG9jayhcXFwiYXRvbVxcXCIsIFxcXCJdXT5cXFwiKSk7XFxuICAgICAgICAgIGVsc2UgcmV0dXJuIG51bGw7XFxuICAgICAgICB9IGVsc2UgaWYgKHN0cmVhbS5tYXRjaChcXFwiLS1cXFwiKSkge1xcbiAgICAgICAgICByZXR1cm4gY2hhaW4oaW5CbG9jayhcXFwiY29tbWVudFxcXCIsIFxcXCItLT5cXFwiKSk7XFxuICAgICAgICB9IGVsc2UgaWYgKHN0cmVhbS5tYXRjaChcXFwiRE9DVFlQRVxcXCIsIHRydWUsIHRydWUpKSB7XFxuICAgICAgICAgIHN0cmVhbS5lYXRXaGlsZSgvW1xcXFx3XFxcXC5fXFxcXC1dLyk7XFxuICAgICAgICAgIHJldHVybiBjaGFpbihkb2N0eXBlKDEpKTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIHJldHVybiBudWxsO1xcbiAgICAgICAgfVxcbiAgICAgIH0gZWxzZSBpZiAoc3RyZWFtLmVhdChcXFwiP1xcXCIpKSB7XFxuICAgICAgICBzdHJlYW0uZWF0V2hpbGUoL1tcXFxcd1xcXFwuX1xcXFwtXS8pO1xcbiAgICAgICAgc3RhdGUudG9rZW5pemUgPSBpbkJsb2NrKFxcXCJtZXRhXFxcIiwgXFxcIj8+XFxcIik7XFxuICAgICAgICByZXR1cm4gXFxcIm1ldGFcXFwiO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICB0eXBlID0gc3RyZWFtLmVhdChcXFwiL1xcXCIpID8gXFxcImNsb3NlVGFnXFxcIiA6IFxcXCJvcGVuVGFnXFxcIjtcXG4gICAgICAgIHN0YXRlLnRva2VuaXplID0gaW5UYWc7XFxuICAgICAgICByZXR1cm4gXFxcInRhZyBicmFja2V0XFxcIjtcXG4gICAgICB9XFxuICAgIH0gZWxzZSBpZiAoY2ggPT0gXFxcIiZcXFwiKSB7XFxuICAgICAgdmFyIG9rO1xcbiAgICAgIGlmIChzdHJlYW0uZWF0KFxcXCIjXFxcIikpIHtcXG4gICAgICAgIGlmIChzdHJlYW0uZWF0KFxcXCJ4XFxcIikpIHtcXG4gICAgICAgICAgb2sgPSBzdHJlYW0uZWF0V2hpbGUoL1thLWZBLUZcXFxcZF0vKSAmJiBzdHJlYW0uZWF0KFxcXCI7XFxcIik7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICBvayA9IHN0cmVhbS5lYXRXaGlsZSgvW1xcXFxkXS8pICYmIHN0cmVhbS5lYXQoXFxcIjtcXFwiKTtcXG4gICAgICAgIH1cXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgb2sgPSBzdHJlYW0uZWF0V2hpbGUoL1tcXFxcd1xcXFwuXFxcXC06XS8pICYmIHN0cmVhbS5lYXQoXFxcIjtcXFwiKTtcXG4gICAgICB9XFxuICAgICAgcmV0dXJuIG9rID8gXFxcImF0b21cXFwiIDogXFxcImVycm9yXFxcIjtcXG4gICAgfSBlbHNlIHtcXG4gICAgICBzdHJlYW0uZWF0V2hpbGUoL1teJjxdLyk7XFxuICAgICAgcmV0dXJuIG51bGw7XFxuICAgIH1cXG4gIH1cXG4gIGluVGV4dC5pc0luVGV4dCA9IHRydWU7XFxuXFxuICBmdW5jdGlvbiBpblRhZyhzdHJlYW0sIHN0YXRlKSB7XFxuICAgIHZhciBjaCA9IHN0cmVhbS5uZXh0KCk7XFxuICAgIGlmIChjaCA9PSBcXFwiPlxcXCIgfHwgKGNoID09IFxcXCIvXFxcIiAmJiBzdHJlYW0uZWF0KFxcXCI+XFxcIikpKSB7XFxuICAgICAgc3RhdGUudG9rZW5pemUgPSBpblRleHQ7XFxuICAgICAgdHlwZSA9IGNoID09IFxcXCI+XFxcIiA/IFxcXCJlbmRUYWdcXFwiIDogXFxcInNlbGZjbG9zZVRhZ1xcXCI7XFxuICAgICAgcmV0dXJuIFxcXCJ0YWcgYnJhY2tldFxcXCI7XFxuICAgIH0gZWxzZSBpZiAoY2ggPT0gXFxcIj1cXFwiKSB7XFxuICAgICAgdHlwZSA9IFxcXCJlcXVhbHNcXFwiO1xcbiAgICAgIHJldHVybiBudWxsO1xcbiAgICB9IGVsc2UgaWYgKGNoID09IFxcXCI8XFxcIikge1xcbiAgICAgIHN0YXRlLnRva2VuaXplID0gaW5UZXh0O1xcbiAgICAgIHN0YXRlLnN0YXRlID0gYmFzZVN0YXRlO1xcbiAgICAgIHN0YXRlLnRhZ05hbWUgPSBzdGF0ZS50YWdTdGFydCA9IG51bGw7XFxuICAgICAgdmFyIG5leHQgPSBzdGF0ZS50b2tlbml6ZShzdHJlYW0sIHN0YXRlKTtcXG4gICAgICByZXR1cm4gbmV4dCA/IG5leHQgKyBcXFwiIHRhZyBlcnJvclxcXCIgOiBcXFwidGFnIGVycm9yXFxcIjtcXG4gICAgfSBlbHNlIGlmICgvW1xcXFwnXFxcXFxcXCJdLy50ZXN0KGNoKSkge1xcbiAgICAgIHN0YXRlLnRva2VuaXplID0gaW5BdHRyaWJ1dGUoY2gpO1xcbiAgICAgIHN0YXRlLnN0cmluZ1N0YXJ0Q29sID0gc3RyZWFtLmNvbHVtbigpO1xcbiAgICAgIHJldHVybiBzdGF0ZS50b2tlbml6ZShzdHJlYW0sIHN0YXRlKTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICBzdHJlYW0ubWF0Y2goL15bXlxcXFxzXFxcXHUwMGEwPTw+XFxcXFxcXCJcXFxcJ10qW15cXFxcc1xcXFx1MDBhMD08PlxcXFxcXFwiXFxcXCdcXFxcL10vKTtcXG4gICAgICByZXR1cm4gXFxcIndvcmRcXFwiO1xcbiAgICB9XFxuICB9XFxuXFxuICBmdW5jdGlvbiBpbkF0dHJpYnV0ZShxdW90ZSkge1xcbiAgICB2YXIgY2xvc3VyZSA9IGZ1bmN0aW9uKHN0cmVhbSwgc3RhdGUpIHtcXG4gICAgICB3aGlsZSAoIXN0cmVhbS5lb2woKSkge1xcbiAgICAgICAgaWYgKHN0cmVhbS5uZXh0KCkgPT0gcXVvdGUpIHtcXG4gICAgICAgICAgc3RhdGUudG9rZW5pemUgPSBpblRhZztcXG4gICAgICAgICAgYnJlYWs7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICAgIHJldHVybiBcXFwic3RyaW5nXFxcIjtcXG4gICAgfTtcXG4gICAgY2xvc3VyZS5pc0luQXR0cmlidXRlID0gdHJ1ZTtcXG4gICAgcmV0dXJuIGNsb3N1cmU7XFxuICB9XFxuXFxuICBmdW5jdGlvbiBpbkJsb2NrKHN0eWxlLCB0ZXJtaW5hdG9yKSB7XFxuICAgIHJldHVybiBmdW5jdGlvbihzdHJlYW0sIHN0YXRlKSB7XFxuICAgICAgd2hpbGUgKCFzdHJlYW0uZW9sKCkpIHtcXG4gICAgICAgIGlmIChzdHJlYW0ubWF0Y2godGVybWluYXRvcikpIHtcXG4gICAgICAgICAgc3RhdGUudG9rZW5pemUgPSBpblRleHQ7XFxuICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgfVxcbiAgICAgICAgc3RyZWFtLm5leHQoKTtcXG4gICAgICB9XFxuICAgICAgcmV0dXJuIHN0eWxlO1xcbiAgICB9O1xcbiAgfVxcbiAgZnVuY3Rpb24gZG9jdHlwZShkZXB0aCkge1xcbiAgICByZXR1cm4gZnVuY3Rpb24oc3RyZWFtLCBzdGF0ZSkge1xcbiAgICAgIHZhciBjaDtcXG4gICAgICB3aGlsZSAoKGNoID0gc3RyZWFtLm5leHQoKSkgIT0gbnVsbCkge1xcbiAgICAgICAgaWYgKGNoID09IFxcXCI8XFxcIikge1xcbiAgICAgICAgICBzdGF0ZS50b2tlbml6ZSA9IGRvY3R5cGUoZGVwdGggKyAxKTtcXG4gICAgICAgICAgcmV0dXJuIHN0YXRlLnRva2VuaXplKHN0cmVhbSwgc3RhdGUpO1xcbiAgICAgICAgfSBlbHNlIGlmIChjaCA9PSBcXFwiPlxcXCIpIHtcXG4gICAgICAgICAgaWYgKGRlcHRoID09IDEpIHtcXG4gICAgICAgICAgICBzdGF0ZS50b2tlbml6ZSA9IGluVGV4dDtcXG4gICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICBzdGF0ZS50b2tlbml6ZSA9IGRvY3R5cGUoZGVwdGggLSAxKTtcXG4gICAgICAgICAgICByZXR1cm4gc3RhdGUudG9rZW5pemUoc3RyZWFtLCBzdGF0ZSk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgICAgcmV0dXJuIFxcXCJtZXRhXFxcIjtcXG4gICAgfTtcXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIENvbnRleHQoc3RhdGUsIHRhZ05hbWUsIHN0YXJ0T2ZMaW5lKSB7XFxuICAgIHRoaXMucHJldiA9IHN0YXRlLmNvbnRleHQ7XFxuICAgIHRoaXMudGFnTmFtZSA9IHRhZ05hbWU7XFxuICAgIHRoaXMuaW5kZW50ID0gc3RhdGUuaW5kZW50ZWQ7XFxuICAgIHRoaXMuc3RhcnRPZkxpbmUgPSBzdGFydE9mTGluZTtcXG4gICAgaWYgKGNvbmZpZy5kb05vdEluZGVudC5oYXNPd25Qcm9wZXJ0eSh0YWdOYW1lKSB8fCAoc3RhdGUuY29udGV4dCAmJiBzdGF0ZS5jb250ZXh0Lm5vSW5kZW50KSlcXG4gICAgICB0aGlzLm5vSW5kZW50ID0gdHJ1ZTtcXG4gIH1cXG4gIGZ1bmN0aW9uIHBvcENvbnRleHQoc3RhdGUpIHtcXG4gICAgaWYgKHN0YXRlLmNvbnRleHQpIHN0YXRlLmNvbnRleHQgPSBzdGF0ZS5jb250ZXh0LnByZXY7XFxuICB9XFxuICBmdW5jdGlvbiBtYXliZVBvcENvbnRleHQoc3RhdGUsIG5leHRUYWdOYW1lKSB7XFxuICAgIHZhciBwYXJlbnRUYWdOYW1lO1xcbiAgICB3aGlsZSAodHJ1ZSkge1xcbiAgICAgIGlmICghc3RhdGUuY29udGV4dCkge1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICAgIH1cXG4gICAgICBwYXJlbnRUYWdOYW1lID0gc3RhdGUuY29udGV4dC50YWdOYW1lO1xcbiAgICAgIGlmICghY29uZmlnLmNvbnRleHRHcmFiYmVycy5oYXNPd25Qcm9wZXJ0eShwYXJlbnRUYWdOYW1lKSB8fFxcbiAgICAgICAgICAhY29uZmlnLmNvbnRleHRHcmFiYmVyc1twYXJlbnRUYWdOYW1lXS5oYXNPd25Qcm9wZXJ0eShuZXh0VGFnTmFtZSkpIHtcXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9XFxuICAgICAgcG9wQ29udGV4dChzdGF0ZSk7XFxuICAgIH1cXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIGJhc2VTdGF0ZSh0eXBlLCBzdHJlYW0sIHN0YXRlKSB7XFxuICAgIGlmICh0eXBlID09IFxcXCJvcGVuVGFnXFxcIikge1xcbiAgICAgIHN0YXRlLnRhZ1N0YXJ0ID0gc3RyZWFtLmNvbHVtbigpO1xcbiAgICAgIHJldHVybiB0YWdOYW1lU3RhdGU7XFxuICAgIH0gZWxzZSBpZiAodHlwZSA9PSBcXFwiY2xvc2VUYWdcXFwiKSB7XFxuICAgICAgcmV0dXJuIGNsb3NlVGFnTmFtZVN0YXRlO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIHJldHVybiBiYXNlU3RhdGU7XFxuICAgIH1cXG4gIH1cXG4gIGZ1bmN0aW9uIHRhZ05hbWVTdGF0ZSh0eXBlLCBzdHJlYW0sIHN0YXRlKSB7XFxuICAgIGlmICh0eXBlID09IFxcXCJ3b3JkXFxcIikge1xcbiAgICAgIHN0YXRlLnRhZ05hbWUgPSBzdHJlYW0uY3VycmVudCgpO1xcbiAgICAgIHNldFN0eWxlID0gXFxcInRhZ1xcXCI7XFxuICAgICAgcmV0dXJuIGF0dHJTdGF0ZTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICBzZXRTdHlsZSA9IFxcXCJlcnJvclxcXCI7XFxuICAgICAgcmV0dXJuIHRhZ05hbWVTdGF0ZTtcXG4gICAgfVxcbiAgfVxcbiAgZnVuY3Rpb24gY2xvc2VUYWdOYW1lU3RhdGUodHlwZSwgc3RyZWFtLCBzdGF0ZSkge1xcbiAgICBpZiAodHlwZSA9PSBcXFwid29yZFxcXCIpIHtcXG4gICAgICB2YXIgdGFnTmFtZSA9IHN0cmVhbS5jdXJyZW50KCk7XFxuICAgICAgaWYgKHN0YXRlLmNvbnRleHQgJiYgc3RhdGUuY29udGV4dC50YWdOYW1lICE9IHRhZ05hbWUgJiZcXG4gICAgICAgICAgY29uZmlnLmltcGxpY2l0bHlDbG9zZWQuaGFzT3duUHJvcGVydHkoc3RhdGUuY29udGV4dC50YWdOYW1lKSlcXG4gICAgICAgIHBvcENvbnRleHQoc3RhdGUpO1xcbiAgICAgIGlmICgoc3RhdGUuY29udGV4dCAmJiBzdGF0ZS5jb250ZXh0LnRhZ05hbWUgPT0gdGFnTmFtZSkgfHwgY29uZmlnLm1hdGNoQ2xvc2luZyA9PT0gZmFsc2UpIHtcXG4gICAgICAgIHNldFN0eWxlID0gXFxcInRhZ1xcXCI7XFxuICAgICAgICByZXR1cm4gY2xvc2VTdGF0ZTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgc2V0U3R5bGUgPSBcXFwidGFnIGVycm9yXFxcIjtcXG4gICAgICAgIHJldHVybiBjbG9zZVN0YXRlRXJyO1xcbiAgICAgIH1cXG4gICAgfSBlbHNlIHtcXG4gICAgICBzZXRTdHlsZSA9IFxcXCJlcnJvclxcXCI7XFxuICAgICAgcmV0dXJuIGNsb3NlU3RhdGVFcnI7XFxuICAgIH1cXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIGNsb3NlU3RhdGUodHlwZSwgX3N0cmVhbSwgc3RhdGUpIHtcXG4gICAgaWYgKHR5cGUgIT0gXFxcImVuZFRhZ1xcXCIpIHtcXG4gICAgICBzZXRTdHlsZSA9IFxcXCJlcnJvclxcXCI7XFxuICAgICAgcmV0dXJuIGNsb3NlU3RhdGU7XFxuICAgIH1cXG4gICAgcG9wQ29udGV4dChzdGF0ZSk7XFxuICAgIHJldHVybiBiYXNlU3RhdGU7XFxuICB9XFxuICBmdW5jdGlvbiBjbG9zZVN0YXRlRXJyKHR5cGUsIHN0cmVhbSwgc3RhdGUpIHtcXG4gICAgc2V0U3R5bGUgPSBcXFwiZXJyb3JcXFwiO1xcbiAgICByZXR1cm4gY2xvc2VTdGF0ZSh0eXBlLCBzdHJlYW0sIHN0YXRlKTtcXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIGF0dHJTdGF0ZSh0eXBlLCBfc3RyZWFtLCBzdGF0ZSkge1xcbiAgICBpZiAodHlwZSA9PSBcXFwid29yZFxcXCIpIHtcXG4gICAgICBzZXRTdHlsZSA9IFxcXCJhdHRyaWJ1dGVcXFwiO1xcbiAgICAgIHJldHVybiBhdHRyRXFTdGF0ZTtcXG4gICAgfSBlbHNlIGlmICh0eXBlID09IFxcXCJlbmRUYWdcXFwiIHx8IHR5cGUgPT0gXFxcInNlbGZjbG9zZVRhZ1xcXCIpIHtcXG4gICAgICB2YXIgdGFnTmFtZSA9IHN0YXRlLnRhZ05hbWUsIHRhZ1N0YXJ0ID0gc3RhdGUudGFnU3RhcnQ7XFxuICAgICAgc3RhdGUudGFnTmFtZSA9IHN0YXRlLnRhZ1N0YXJ0ID0gbnVsbDtcXG4gICAgICBpZiAodHlwZSA9PSBcXFwic2VsZmNsb3NlVGFnXFxcIiB8fFxcbiAgICAgICAgICBjb25maWcuYXV0b1NlbGZDbG9zZXJzLmhhc093blByb3BlcnR5KHRhZ05hbWUpKSB7XFxuICAgICAgICBtYXliZVBvcENvbnRleHQoc3RhdGUsIHRhZ05hbWUpO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBtYXliZVBvcENvbnRleHQoc3RhdGUsIHRhZ05hbWUpO1xcbiAgICAgICAgc3RhdGUuY29udGV4dCA9IG5ldyBDb250ZXh0KHN0YXRlLCB0YWdOYW1lLCB0YWdTdGFydCA9PSBzdGF0ZS5pbmRlbnRlZCk7XFxuICAgICAgfVxcbiAgICAgIHJldHVybiBiYXNlU3RhdGU7XFxuICAgIH1cXG4gICAgc2V0U3R5bGUgPSBcXFwiZXJyb3JcXFwiO1xcbiAgICByZXR1cm4gYXR0clN0YXRlO1xcbiAgfVxcbiAgZnVuY3Rpb24gYXR0ckVxU3RhdGUodHlwZSwgc3RyZWFtLCBzdGF0ZSkge1xcbiAgICBpZiAodHlwZSA9PSBcXFwiZXF1YWxzXFxcIikgcmV0dXJuIGF0dHJWYWx1ZVN0YXRlO1xcbiAgICBpZiAoIWNvbmZpZy5hbGxvd01pc3NpbmcpIHNldFN0eWxlID0gXFxcImVycm9yXFxcIjtcXG4gICAgcmV0dXJuIGF0dHJTdGF0ZSh0eXBlLCBzdHJlYW0sIHN0YXRlKTtcXG4gIH1cXG4gIGZ1bmN0aW9uIGF0dHJWYWx1ZVN0YXRlKHR5cGUsIHN0cmVhbSwgc3RhdGUpIHtcXG4gICAgaWYgKHR5cGUgPT0gXFxcInN0cmluZ1xcXCIpIHJldHVybiBhdHRyQ29udGludWVkU3RhdGU7XFxuICAgIGlmICh0eXBlID09IFxcXCJ3b3JkXFxcIiAmJiBjb25maWcuYWxsb3dVbnF1b3RlZCkge3NldFN0eWxlID0gXFxcInN0cmluZ1xcXCI7IHJldHVybiBhdHRyU3RhdGU7fVxcbiAgICBzZXRTdHlsZSA9IFxcXCJlcnJvclxcXCI7XFxuICAgIHJldHVybiBhdHRyU3RhdGUodHlwZSwgc3RyZWFtLCBzdGF0ZSk7XFxuICB9XFxuICBmdW5jdGlvbiBhdHRyQ29udGludWVkU3RhdGUodHlwZSwgc3RyZWFtLCBzdGF0ZSkge1xcbiAgICBpZiAodHlwZSA9PSBcXFwic3RyaW5nXFxcIikgcmV0dXJuIGF0dHJDb250aW51ZWRTdGF0ZTtcXG4gICAgcmV0dXJuIGF0dHJTdGF0ZSh0eXBlLCBzdHJlYW0sIHN0YXRlKTtcXG4gIH1cXG5cXG4gIHJldHVybiB7XFxuICAgIHN0YXJ0U3RhdGU6IGZ1bmN0aW9uKGJhc2VJbmRlbnQpIHtcXG4gICAgICB2YXIgc3RhdGUgPSB7dG9rZW5pemU6IGluVGV4dCxcXG4gICAgICAgICAgICAgICAgICAgc3RhdGU6IGJhc2VTdGF0ZSxcXG4gICAgICAgICAgICAgICAgICAgaW5kZW50ZWQ6IGJhc2VJbmRlbnQgfHwgMCxcXG4gICAgICAgICAgICAgICAgICAgdGFnTmFtZTogbnVsbCwgdGFnU3RhcnQ6IG51bGwsXFxuICAgICAgICAgICAgICAgICAgIGNvbnRleHQ6IG51bGx9XFxuICAgICAgaWYgKGJhc2VJbmRlbnQgIT0gbnVsbCkgc3RhdGUuYmFzZUluZGVudCA9IGJhc2VJbmRlbnRcXG4gICAgICByZXR1cm4gc3RhdGVcXG4gICAgfSxcXG5cXG4gICAgdG9rZW46IGZ1bmN0aW9uKHN0cmVhbSwgc3RhdGUpIHtcXG4gICAgICBpZiAoIXN0YXRlLnRhZ05hbWUgJiYgc3RyZWFtLnNvbCgpKVxcbiAgICAgICAgc3RhdGUuaW5kZW50ZWQgPSBzdHJlYW0uaW5kZW50YXRpb24oKTtcXG5cXG4gICAgICBpZiAoc3RyZWFtLmVhdFNwYWNlKCkpIHJldHVybiBudWxsO1xcbiAgICAgIHR5cGUgPSBudWxsO1xcbiAgICAgIHZhciBzdHlsZSA9IHN0YXRlLnRva2VuaXplKHN0cmVhbSwgc3RhdGUpO1xcbiAgICAgIGlmICgoc3R5bGUgfHwgdHlwZSkgJiYgc3R5bGUgIT0gXFxcImNvbW1lbnRcXFwiKSB7XFxuICAgICAgICBzZXRTdHlsZSA9IG51bGw7XFxuICAgICAgICBzdGF0ZS5zdGF0ZSA9IHN0YXRlLnN0YXRlKHR5cGUgfHwgc3R5bGUsIHN0cmVhbSwgc3RhdGUpO1xcbiAgICAgICAgaWYgKHNldFN0eWxlKVxcbiAgICAgICAgICBzdHlsZSA9IHNldFN0eWxlID09IFxcXCJlcnJvclxcXCIgPyBzdHlsZSArIFxcXCIgZXJyb3JcXFwiIDogc2V0U3R5bGU7XFxuICAgICAgfVxcbiAgICAgIHJldHVybiBzdHlsZTtcXG4gICAgfSxcXG5cXG4gICAgaW5kZW50OiBmdW5jdGlvbihzdGF0ZSwgdGV4dEFmdGVyLCBmdWxsTGluZSkge1xcbiAgICAgIHZhciBjb250ZXh0ID0gc3RhdGUuY29udGV4dDtcXG4gICAgICAvLyBJbmRlbnQgbXVsdGktbGluZSBzdHJpbmdzIChlLmcuIGNzcykuXFxuICAgICAgaWYgKHN0YXRlLnRva2VuaXplLmlzSW5BdHRyaWJ1dGUpIHtcXG4gICAgICAgIGlmIChzdGF0ZS50YWdTdGFydCA9PSBzdGF0ZS5pbmRlbnRlZClcXG4gICAgICAgICAgcmV0dXJuIHN0YXRlLnN0cmluZ1N0YXJ0Q29sICsgMTtcXG4gICAgICAgIGVsc2VcXG4gICAgICAgICAgcmV0dXJuIHN0YXRlLmluZGVudGVkICsgaW5kZW50VW5pdDtcXG4gICAgICB9XFxuICAgICAgaWYgKGNvbnRleHQgJiYgY29udGV4dC5ub0luZGVudCkgcmV0dXJuIENvZGVNaXJyb3IuUGFzcztcXG4gICAgICBpZiAoc3RhdGUudG9rZW5pemUgIT0gaW5UYWcgJiYgc3RhdGUudG9rZW5pemUgIT0gaW5UZXh0KVxcbiAgICAgICAgcmV0dXJuIGZ1bGxMaW5lID8gZnVsbExpbmUubWF0Y2goL14oXFxcXHMqKS8pWzBdLmxlbmd0aCA6IDA7XFxuICAgICAgLy8gSW5kZW50IHRoZSBzdGFydHMgb2YgYXR0cmlidXRlIG5hbWVzLlxcbiAgICAgIGlmIChzdGF0ZS50YWdOYW1lKSB7XFxuICAgICAgICBpZiAoY29uZmlnLm11bHRpbGluZVRhZ0luZGVudFBhc3RUYWcgIT09IGZhbHNlKVxcbiAgICAgICAgICByZXR1cm4gc3RhdGUudGFnU3RhcnQgKyBzdGF0ZS50YWdOYW1lLmxlbmd0aCArIDI7XFxuICAgICAgICBlbHNlXFxuICAgICAgICAgIHJldHVybiBzdGF0ZS50YWdTdGFydCArIGluZGVudFVuaXQgKiAoY29uZmlnLm11bHRpbGluZVRhZ0luZGVudEZhY3RvciB8fCAxKTtcXG4gICAgICB9XFxuICAgICAgaWYgKGNvbmZpZy5hbGlnbkNEQVRBICYmIC88IVxcXFxbQ0RBVEFcXFxcWy8udGVzdCh0ZXh0QWZ0ZXIpKSByZXR1cm4gMDtcXG4gICAgICB2YXIgdGFnQWZ0ZXIgPSB0ZXh0QWZ0ZXIgJiYgL148KFxcXFwvKT8oW1xcXFx3XzpcXFxcLi1dKikvLmV4ZWModGV4dEFmdGVyKTtcXG4gICAgICBpZiAodGFnQWZ0ZXIgJiYgdGFnQWZ0ZXJbMV0pIHsgLy8gQ2xvc2luZyB0YWcgc3BvdHRlZFxcbiAgICAgICAgd2hpbGUgKGNvbnRleHQpIHtcXG4gICAgICAgICAgaWYgKGNvbnRleHQudGFnTmFtZSA9PSB0YWdBZnRlclsyXSkge1xcbiAgICAgICAgICAgIGNvbnRleHQgPSBjb250ZXh0LnByZXY7XFxuICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgIH0gZWxzZSBpZiAoY29uZmlnLmltcGxpY2l0bHlDbG9zZWQuaGFzT3duUHJvcGVydHkoY29udGV4dC50YWdOYW1lKSkge1xcbiAgICAgICAgICAgIGNvbnRleHQgPSBjb250ZXh0LnByZXY7XFxuICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICB9IGVsc2UgaWYgKHRhZ0FmdGVyKSB7IC8vIE9wZW5pbmcgdGFnIHNwb3R0ZWRcXG4gICAgICAgIHdoaWxlIChjb250ZXh0KSB7XFxuICAgICAgICAgIHZhciBncmFiYmVycyA9IGNvbmZpZy5jb250ZXh0R3JhYmJlcnNbY29udGV4dC50YWdOYW1lXTtcXG4gICAgICAgICAgaWYgKGdyYWJiZXJzICYmIGdyYWJiZXJzLmhhc093blByb3BlcnR5KHRhZ0FmdGVyWzJdKSlcXG4gICAgICAgICAgICBjb250ZXh0ID0gY29udGV4dC5wcmV2O1xcbiAgICAgICAgICBlbHNlXFxuICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICAgIHdoaWxlIChjb250ZXh0ICYmIGNvbnRleHQucHJldiAmJiAhY29udGV4dC5zdGFydE9mTGluZSlcXG4gICAgICAgIGNvbnRleHQgPSBjb250ZXh0LnByZXY7XFxuICAgICAgaWYgKGNvbnRleHQpIHJldHVybiBjb250ZXh0LmluZGVudCArIGluZGVudFVuaXQ7XFxuICAgICAgZWxzZSByZXR1cm4gc3RhdGUuYmFzZUluZGVudCB8fCAwO1xcbiAgICB9LFxcblxcbiAgICBlbGVjdHJpY0lucHV0OiAvPFxcXFwvW1xcXFxzXFxcXHc6XSs+JC8sXFxuICAgIGJsb2NrQ29tbWVudFN0YXJ0OiBcXFwiPCEtLVxcXCIsXFxuICAgIGJsb2NrQ29tbWVudEVuZDogXFxcIi0tPlxcXCIsXFxuXFxuICAgIGNvbmZpZ3VyYXRpb246IGNvbmZpZy5odG1sTW9kZSA/IFxcXCJodG1sXFxcIiA6IFxcXCJ4bWxcXFwiLFxcbiAgICBoZWxwZXJUeXBlOiBjb25maWcuaHRtbE1vZGUgPyBcXFwiaHRtbFxcXCIgOiBcXFwieG1sXFxcIixcXG5cXG4gICAgc2tpcEF0dHJpYnV0ZTogZnVuY3Rpb24oc3RhdGUpIHtcXG4gICAgICBpZiAoc3RhdGUuc3RhdGUgPT0gYXR0clZhbHVlU3RhdGUpXFxuICAgICAgICBzdGF0ZS5zdGF0ZSA9IGF0dHJTdGF0ZVxcbiAgICB9XFxuICB9O1xcbn0pO1xcblxcbkNvZGVNaXJyb3IuZGVmaW5lTUlNRShcXFwidGV4dC94bWxcXFwiLCBcXFwieG1sXFxcIik7XFxuQ29kZU1pcnJvci5kZWZpbmVNSU1FKFxcXCJhcHBsaWNhdGlvbi94bWxcXFwiLCBcXFwieG1sXFxcIik7XFxuaWYgKCFDb2RlTWlycm9yLm1pbWVNb2Rlcy5oYXNPd25Qcm9wZXJ0eShcXFwidGV4dC9odG1sXFxcIikpXFxuICBDb2RlTWlycm9yLmRlZmluZU1JTUUoXFxcInRleHQvaHRtbFxcXCIsIHtuYW1lOiBcXFwieG1sXFxcIiwgaHRtbE1vZGU6IHRydWV9KTtcXG5cXG59KTtcXG5cIlxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yYXctbG9hZGVyIS4vfi9jb2RlbWlycm9yL21vZGUveG1sL3htbC5qc1xuLy8gbW9kdWxlIGlkID0gN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	eval("__webpack_require__(2)(__webpack_require__(9))//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL34vZnJvYWxhLWVkaXRvci9qcy9wbHVnaW5zL2FsaWduLm1pbi5qcz9jYzMxIl0sInNvdXJjZXNDb250ZW50IjpbInJlcXVpcmUoXCIhIS92YXIvYXBwL3dlYi9qcy9ub2RlX21vZHVsZXMvc2NyaXB0LWxvYWRlci9hZGRTY3JpcHQuanNcIikocmVxdWlyZShcIiEhL3Zhci9hcHAvd2ViL2pzL25vZGVfbW9kdWxlcy9yYXctbG9hZGVyL2luZGV4LmpzIS92YXIvYXBwL3dlYi9qcy9ub2RlX21vZHVsZXMvZnJvYWxhLWVkaXRvci9qcy9wbHVnaW5zL2FsaWduLm1pbi5qc1wiKSlcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vc2NyaXB0LWxvYWRlciEuL34vZnJvYWxhLWVkaXRvci9qcy9wbHVnaW5zL2FsaWduLm1pbi5qc1xuLy8gbW9kdWxlIGlkID0gOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 9 */
/***/ function(module, exports) {

	eval("module.exports = \"/*!\\n * froala_editor v2.5.1 (https://www.froala.com/wysiwyg-editor)\\n * License https://froala.com/wysiwyg-editor/terms/\\n * Copyright 2014-2017 Froala Labs\\n */\\n\\n!function(a){\\\"function\\\"==typeof define&&define.amd?define([\\\"jquery\\\"],a):\\\"object\\\"==typeof module&&module.exports?module.exports=function(b,c){return void 0===c&&(c=\\\"undefined\\\"!=typeof window?require(\\\"jquery\\\"):require(\\\"jquery\\\")(b)),a(c)}:a(window.jQuery)}(function(a){a.FE.PLUGINS.align=function(b){function c(c){b.selection.save(),b.html.wrap(!0,!0,!0,!0),b.selection.restore();for(var d=b.selection.blocks(),e=0;e<d.length;e++)b.helpers.getAlignment(a(d[e].parentNode))==c?a(d[e]).css(\\\"text-align\\\",\\\"\\\").removeClass(\\\"fr-temp-div\\\"):a(d[e]).css(\\\"text-align\\\",c).removeClass(\\\"fr-temp-div\\\"),\\\"\\\"===a(d[e]).attr(\\\"class\\\")&&a(d[e]).removeAttr(\\\"class\\\"),\\\"\\\"===a(d[e]).attr(\\\"style\\\")&&a(d[e]).removeAttr(\\\"style\\\");b.selection.save(),b.html.unwrap(),b.selection.restore()}function d(c){var d=b.selection.blocks();if(d.length){var e=b.helpers.getAlignment(a(d[0]));c.find(\\\"> *:first\\\").replaceWith(b.icon.create(\\\"align-\\\"+e))}}function e(c,d){var e=b.selection.blocks();if(e.length){var f=b.helpers.getAlignment(a(e[0]));d.find('a.fr-command[data-param1=\\\"'+f+'\\\"]').addClass(\\\"fr-active\\\").attr(\\\"aria-selected\\\",!0)}}return{apply:c,refresh:d,refreshOnShow:e}},a.FE.DefineIcon(\\\"align\\\",{NAME:\\\"align-left\\\"}),a.FE.DefineIcon(\\\"align-left\\\",{NAME:\\\"align-left\\\"}),a.FE.DefineIcon(\\\"align-right\\\",{NAME:\\\"align-right\\\"}),a.FE.DefineIcon(\\\"align-center\\\",{NAME:\\\"align-center\\\"}),a.FE.DefineIcon(\\\"align-justify\\\",{NAME:\\\"align-justify\\\"}),a.FE.RegisterCommand(\\\"align\\\",{type:\\\"dropdown\\\",title:\\\"Align\\\",options:{left:\\\"Align Left\\\",center:\\\"Align Center\\\",right:\\\"Align Right\\\",justify:\\\"Align Justify\\\"},html:function(){var b='<ul class=\\\"fr-dropdown-list\\\" role=\\\"presentation\\\">',c=a.FE.COMMANDS.align.options;for(var d in c)c.hasOwnProperty(d)&&(b+='<li role=\\\"presentation\\\"><a class=\\\"fr-command fr-title\\\" tabIndex=\\\"-1\\\" role=\\\"option\\\" data-cmd=\\\"align\\\" data-param1=\\\"'+d+'\\\" title=\\\"'+this.language.translate(c[d])+'\\\">'+this.icon.create(\\\"align-\\\"+d)+'<span class=\\\"fr-sr-only\\\">'+this.language.translate(c[d])+\\\"</span></a></li>\\\");return b+=\\\"</ul>\\\"},callback:function(a,b){this.align.apply(b)},refresh:function(a){this.align.refresh(a)},refreshOnShow:function(a,b){this.align.refreshOnShow(a,b)},plugin:\\\"align\\\"})});\"//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL34vZnJvYWxhLWVkaXRvci9qcy9wbHVnaW5zL2FsaWduLm1pbi5qcz9iYmFkIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gXCIvKiFcXG4gKiBmcm9hbGFfZWRpdG9yIHYyLjUuMSAoaHR0cHM6Ly93d3cuZnJvYWxhLmNvbS93eXNpd3lnLWVkaXRvcilcXG4gKiBMaWNlbnNlIGh0dHBzOi8vZnJvYWxhLmNvbS93eXNpd3lnLWVkaXRvci90ZXJtcy9cXG4gKiBDb3B5cmlnaHQgMjAxNC0yMDE3IEZyb2FsYSBMYWJzXFxuICovXFxuXFxuIWZ1bmN0aW9uKGEpe1xcXCJmdW5jdGlvblxcXCI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQ/ZGVmaW5lKFtcXFwianF1ZXJ5XFxcIl0sYSk6XFxcIm9iamVjdFxcXCI9PXR5cGVvZiBtb2R1bGUmJm1vZHVsZS5leHBvcnRzP21vZHVsZS5leHBvcnRzPWZ1bmN0aW9uKGIsYyl7cmV0dXJuIHZvaWQgMD09PWMmJihjPVxcXCJ1bmRlZmluZWRcXFwiIT10eXBlb2Ygd2luZG93P3JlcXVpcmUoXFxcImpxdWVyeVxcXCIpOnJlcXVpcmUoXFxcImpxdWVyeVxcXCIpKGIpKSxhKGMpfTphKHdpbmRvdy5qUXVlcnkpfShmdW5jdGlvbihhKXthLkZFLlBMVUdJTlMuYWxpZ249ZnVuY3Rpb24oYil7ZnVuY3Rpb24gYyhjKXtiLnNlbGVjdGlvbi5zYXZlKCksYi5odG1sLndyYXAoITAsITAsITAsITApLGIuc2VsZWN0aW9uLnJlc3RvcmUoKTtmb3IodmFyIGQ9Yi5zZWxlY3Rpb24uYmxvY2tzKCksZT0wO2U8ZC5sZW5ndGg7ZSsrKWIuaGVscGVycy5nZXRBbGlnbm1lbnQoYShkW2VdLnBhcmVudE5vZGUpKT09Yz9hKGRbZV0pLmNzcyhcXFwidGV4dC1hbGlnblxcXCIsXFxcIlxcXCIpLnJlbW92ZUNsYXNzKFxcXCJmci10ZW1wLWRpdlxcXCIpOmEoZFtlXSkuY3NzKFxcXCJ0ZXh0LWFsaWduXFxcIixjKS5yZW1vdmVDbGFzcyhcXFwiZnItdGVtcC1kaXZcXFwiKSxcXFwiXFxcIj09PWEoZFtlXSkuYXR0cihcXFwiY2xhc3NcXFwiKSYmYShkW2VdKS5yZW1vdmVBdHRyKFxcXCJjbGFzc1xcXCIpLFxcXCJcXFwiPT09YShkW2VdKS5hdHRyKFxcXCJzdHlsZVxcXCIpJiZhKGRbZV0pLnJlbW92ZUF0dHIoXFxcInN0eWxlXFxcIik7Yi5zZWxlY3Rpb24uc2F2ZSgpLGIuaHRtbC51bndyYXAoKSxiLnNlbGVjdGlvbi5yZXN0b3JlKCl9ZnVuY3Rpb24gZChjKXt2YXIgZD1iLnNlbGVjdGlvbi5ibG9ja3MoKTtpZihkLmxlbmd0aCl7dmFyIGU9Yi5oZWxwZXJzLmdldEFsaWdubWVudChhKGRbMF0pKTtjLmZpbmQoXFxcIj4gKjpmaXJzdFxcXCIpLnJlcGxhY2VXaXRoKGIuaWNvbi5jcmVhdGUoXFxcImFsaWduLVxcXCIrZSkpfX1mdW5jdGlvbiBlKGMsZCl7dmFyIGU9Yi5zZWxlY3Rpb24uYmxvY2tzKCk7aWYoZS5sZW5ndGgpe3ZhciBmPWIuaGVscGVycy5nZXRBbGlnbm1lbnQoYShlWzBdKSk7ZC5maW5kKCdhLmZyLWNvbW1hbmRbZGF0YS1wYXJhbTE9XFxcIicrZisnXFxcIl0nKS5hZGRDbGFzcyhcXFwiZnItYWN0aXZlXFxcIikuYXR0cihcXFwiYXJpYS1zZWxlY3RlZFxcXCIsITApfX1yZXR1cm57YXBwbHk6YyxyZWZyZXNoOmQscmVmcmVzaE9uU2hvdzplfX0sYS5GRS5EZWZpbmVJY29uKFxcXCJhbGlnblxcXCIse05BTUU6XFxcImFsaWduLWxlZnRcXFwifSksYS5GRS5EZWZpbmVJY29uKFxcXCJhbGlnbi1sZWZ0XFxcIix7TkFNRTpcXFwiYWxpZ24tbGVmdFxcXCJ9KSxhLkZFLkRlZmluZUljb24oXFxcImFsaWduLXJpZ2h0XFxcIix7TkFNRTpcXFwiYWxpZ24tcmlnaHRcXFwifSksYS5GRS5EZWZpbmVJY29uKFxcXCJhbGlnbi1jZW50ZXJcXFwiLHtOQU1FOlxcXCJhbGlnbi1jZW50ZXJcXFwifSksYS5GRS5EZWZpbmVJY29uKFxcXCJhbGlnbi1qdXN0aWZ5XFxcIix7TkFNRTpcXFwiYWxpZ24tanVzdGlmeVxcXCJ9KSxhLkZFLlJlZ2lzdGVyQ29tbWFuZChcXFwiYWxpZ25cXFwiLHt0eXBlOlxcXCJkcm9wZG93blxcXCIsdGl0bGU6XFxcIkFsaWduXFxcIixvcHRpb25zOntsZWZ0OlxcXCJBbGlnbiBMZWZ0XFxcIixjZW50ZXI6XFxcIkFsaWduIENlbnRlclxcXCIscmlnaHQ6XFxcIkFsaWduIFJpZ2h0XFxcIixqdXN0aWZ5OlxcXCJBbGlnbiBKdXN0aWZ5XFxcIn0saHRtbDpmdW5jdGlvbigpe3ZhciBiPSc8dWwgY2xhc3M9XFxcImZyLWRyb3Bkb3duLWxpc3RcXFwiIHJvbGU9XFxcInByZXNlbnRhdGlvblxcXCI+JyxjPWEuRkUuQ09NTUFORFMuYWxpZ24ub3B0aW9ucztmb3IodmFyIGQgaW4gYyljLmhhc093blByb3BlcnR5KGQpJiYoYis9JzxsaSByb2xlPVxcXCJwcmVzZW50YXRpb25cXFwiPjxhIGNsYXNzPVxcXCJmci1jb21tYW5kIGZyLXRpdGxlXFxcIiB0YWJJbmRleD1cXFwiLTFcXFwiIHJvbGU9XFxcIm9wdGlvblxcXCIgZGF0YS1jbWQ9XFxcImFsaWduXFxcIiBkYXRhLXBhcmFtMT1cXFwiJytkKydcXFwiIHRpdGxlPVxcXCInK3RoaXMubGFuZ3VhZ2UudHJhbnNsYXRlKGNbZF0pKydcXFwiPicrdGhpcy5pY29uLmNyZWF0ZShcXFwiYWxpZ24tXFxcIitkKSsnPHNwYW4gY2xhc3M9XFxcImZyLXNyLW9ubHlcXFwiPicrdGhpcy5sYW5ndWFnZS50cmFuc2xhdGUoY1tkXSkrXFxcIjwvc3Bhbj48L2E+PC9saT5cXFwiKTtyZXR1cm4gYis9XFxcIjwvdWw+XFxcIn0sY2FsbGJhY2s6ZnVuY3Rpb24oYSxiKXt0aGlzLmFsaWduLmFwcGx5KGIpfSxyZWZyZXNoOmZ1bmN0aW9uKGEpe3RoaXMuYWxpZ24ucmVmcmVzaChhKX0scmVmcmVzaE9uU2hvdzpmdW5jdGlvbihhLGIpe3RoaXMuYWxpZ24ucmVmcmVzaE9uU2hvdyhhLGIpfSxwbHVnaW46XFxcImFsaWduXFxcIn0pfSk7XCJcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcmF3LWxvYWRlciEuL34vZnJvYWxhLWVkaXRvci9qcy9wbHVnaW5zL2FsaWduLm1pbi5qc1xuLy8gbW9kdWxlIGlkID0gOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	eval("__webpack_require__(2)(__webpack_require__(11))//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTAuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2Zyb2FsYS1lZGl0b3IvanMvcGx1Z2lucy9jaGFyX2NvdW50ZXIubWluLmpzPzc3YjEiXSwic291cmNlc0NvbnRlbnQiOlsicmVxdWlyZShcIiEhL3Zhci9hcHAvd2ViL2pzL25vZGVfbW9kdWxlcy9zY3JpcHQtbG9hZGVyL2FkZFNjcmlwdC5qc1wiKShyZXF1aXJlKFwiISEvdmFyL2FwcC93ZWIvanMvbm9kZV9tb2R1bGVzL3Jhdy1sb2FkZXIvaW5kZXguanMhL3Zhci9hcHAvd2ViL2pzL25vZGVfbW9kdWxlcy9mcm9hbGEtZWRpdG9yL2pzL3BsdWdpbnMvY2hhcl9jb3VudGVyLm1pbi5qc1wiKSlcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vc2NyaXB0LWxvYWRlciEuL34vZnJvYWxhLWVkaXRvci9qcy9wbHVnaW5zL2NoYXJfY291bnRlci5taW4uanNcbi8vIG1vZHVsZSBpZCA9IDEwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 11 */
/***/ function(module, exports) {

	eval("module.exports = \"/*!\\n * froala_editor v2.5.1 (https://www.froala.com/wysiwyg-editor)\\n * License https://froala.com/wysiwyg-editor/terms/\\n * Copyright 2014-2017 Froala Labs\\n */\\n\\n!function(a){\\\"function\\\"==typeof define&&define.amd?define([\\\"jquery\\\"],a):\\\"object\\\"==typeof module&&module.exports?module.exports=function(b,c){return void 0===c&&(c=\\\"undefined\\\"!=typeof window?require(\\\"jquery\\\"):require(\\\"jquery\\\")(b)),a(c)}:a(window.jQuery)}(function(a){a.extend(a.FE.DEFAULTS,{charCounterMax:-1,charCounterCount:!0}),a.FE.PLUGINS.charCounter=function(b){function c(){return b.el.textContent.length}function d(a){if(b.opts.charCounterMax<0)return!0;if(c()<b.opts.charCounterMax)return!0;var d=a.which;return!(!b.keys.ctrlKey(a)&&b.keys.isCharacter(d))||(a.preventDefault(),a.stopPropagation(),b.events.trigger(\\\"charCounter.exceeded\\\"),!1)}function e(d){if(b.opts.charCounterMax<0)return d;var e=a(\\\"<div>\\\").html(d).text().length;return e+c()<=b.opts.charCounterMax?d:(b.events.trigger(\\\"charCounter.exceeded\\\"),\\\"\\\")}function f(){if(b.opts.charCounterCount){var a=c()+(b.opts.charCounterMax>0?\\\"/\\\"+b.opts.charCounterMax:\\\"\\\");h.text(a),b.opts.toolbarBottom&&h.css(\\\"margin-bottom\\\",b.$tb.outerHeight(!0));var d=b.$wp.get(0).offsetWidth-b.$wp.get(0).clientWidth;d>=0&&(\\\"rtl\\\"==b.opts.direction?h.css(\\\"margin-left\\\",d):h.css(\\\"margin-right\\\",d))}}function g(){return!!b.$wp&&(!!b.opts.charCounterCount&&(h=a('<span class=\\\"fr-counter\\\"></span>'),h.css(\\\"bottom\\\",b.$wp.css(\\\"border-bottom-width\\\")),b.$box.append(h),b.events.on(\\\"keydown\\\",d,!0),b.events.on(\\\"paste.afterCleanup\\\",e),b.events.on(\\\"keyup contentChanged input\\\",function(){b.events.trigger(\\\"charCounter.update\\\")}),b.events.on(\\\"charCounter.update\\\",f),b.events.trigger(\\\"charCounter.update\\\"),void b.events.on(\\\"destroy\\\",function(){a(b.o_win).off(\\\"resize.char\\\"+b.id),h.removeData().remove(),h=null})))}var h;return{_init:g,count:c}}});\"//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTEuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2Zyb2FsYS1lZGl0b3IvanMvcGx1Z2lucy9jaGFyX2NvdW50ZXIubWluLmpzPzUwMWQiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBcIi8qIVxcbiAqIGZyb2FsYV9lZGl0b3IgdjIuNS4xIChodHRwczovL3d3dy5mcm9hbGEuY29tL3d5c2l3eWctZWRpdG9yKVxcbiAqIExpY2Vuc2UgaHR0cHM6Ly9mcm9hbGEuY29tL3d5c2l3eWctZWRpdG9yL3Rlcm1zL1xcbiAqIENvcHlyaWdodCAyMDE0LTIwMTcgRnJvYWxhIExhYnNcXG4gKi9cXG5cXG4hZnVuY3Rpb24oYSl7XFxcImZ1bmN0aW9uXFxcIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUoW1xcXCJqcXVlcnlcXFwiXSxhKTpcXFwib2JqZWN0XFxcIj09dHlwZW9mIG1vZHVsZSYmbW9kdWxlLmV4cG9ydHM/bW9kdWxlLmV4cG9ydHM9ZnVuY3Rpb24oYixjKXtyZXR1cm4gdm9pZCAwPT09YyYmKGM9XFxcInVuZGVmaW5lZFxcXCIhPXR5cGVvZiB3aW5kb3c/cmVxdWlyZShcXFwianF1ZXJ5XFxcIik6cmVxdWlyZShcXFwianF1ZXJ5XFxcIikoYikpLGEoYyl9OmEod2luZG93LmpRdWVyeSl9KGZ1bmN0aW9uKGEpe2EuZXh0ZW5kKGEuRkUuREVGQVVMVFMse2NoYXJDb3VudGVyTWF4Oi0xLGNoYXJDb3VudGVyQ291bnQ6ITB9KSxhLkZFLlBMVUdJTlMuY2hhckNvdW50ZXI9ZnVuY3Rpb24oYil7ZnVuY3Rpb24gYygpe3JldHVybiBiLmVsLnRleHRDb250ZW50Lmxlbmd0aH1mdW5jdGlvbiBkKGEpe2lmKGIub3B0cy5jaGFyQ291bnRlck1heDwwKXJldHVybiEwO2lmKGMoKTxiLm9wdHMuY2hhckNvdW50ZXJNYXgpcmV0dXJuITA7dmFyIGQ9YS53aGljaDtyZXR1cm4hKCFiLmtleXMuY3RybEtleShhKSYmYi5rZXlzLmlzQ2hhcmFjdGVyKGQpKXx8KGEucHJldmVudERlZmF1bHQoKSxhLnN0b3BQcm9wYWdhdGlvbigpLGIuZXZlbnRzLnRyaWdnZXIoXFxcImNoYXJDb3VudGVyLmV4Y2VlZGVkXFxcIiksITEpfWZ1bmN0aW9uIGUoZCl7aWYoYi5vcHRzLmNoYXJDb3VudGVyTWF4PDApcmV0dXJuIGQ7dmFyIGU9YShcXFwiPGRpdj5cXFwiKS5odG1sKGQpLnRleHQoKS5sZW5ndGg7cmV0dXJuIGUrYygpPD1iLm9wdHMuY2hhckNvdW50ZXJNYXg/ZDooYi5ldmVudHMudHJpZ2dlcihcXFwiY2hhckNvdW50ZXIuZXhjZWVkZWRcXFwiKSxcXFwiXFxcIil9ZnVuY3Rpb24gZigpe2lmKGIub3B0cy5jaGFyQ291bnRlckNvdW50KXt2YXIgYT1jKCkrKGIub3B0cy5jaGFyQ291bnRlck1heD4wP1xcXCIvXFxcIitiLm9wdHMuY2hhckNvdW50ZXJNYXg6XFxcIlxcXCIpO2gudGV4dChhKSxiLm9wdHMudG9vbGJhckJvdHRvbSYmaC5jc3MoXFxcIm1hcmdpbi1ib3R0b21cXFwiLGIuJHRiLm91dGVySGVpZ2h0KCEwKSk7dmFyIGQ9Yi4kd3AuZ2V0KDApLm9mZnNldFdpZHRoLWIuJHdwLmdldCgwKS5jbGllbnRXaWR0aDtkPj0wJiYoXFxcInJ0bFxcXCI9PWIub3B0cy5kaXJlY3Rpb24/aC5jc3MoXFxcIm1hcmdpbi1sZWZ0XFxcIixkKTpoLmNzcyhcXFwibWFyZ2luLXJpZ2h0XFxcIixkKSl9fWZ1bmN0aW9uIGcoKXtyZXR1cm4hIWIuJHdwJiYoISFiLm9wdHMuY2hhckNvdW50ZXJDb3VudCYmKGg9YSgnPHNwYW4gY2xhc3M9XFxcImZyLWNvdW50ZXJcXFwiPjwvc3Bhbj4nKSxoLmNzcyhcXFwiYm90dG9tXFxcIixiLiR3cC5jc3MoXFxcImJvcmRlci1ib3R0b20td2lkdGhcXFwiKSksYi4kYm94LmFwcGVuZChoKSxiLmV2ZW50cy5vbihcXFwia2V5ZG93blxcXCIsZCwhMCksYi5ldmVudHMub24oXFxcInBhc3RlLmFmdGVyQ2xlYW51cFxcXCIsZSksYi5ldmVudHMub24oXFxcImtleXVwIGNvbnRlbnRDaGFuZ2VkIGlucHV0XFxcIixmdW5jdGlvbigpe2IuZXZlbnRzLnRyaWdnZXIoXFxcImNoYXJDb3VudGVyLnVwZGF0ZVxcXCIpfSksYi5ldmVudHMub24oXFxcImNoYXJDb3VudGVyLnVwZGF0ZVxcXCIsZiksYi5ldmVudHMudHJpZ2dlcihcXFwiY2hhckNvdW50ZXIudXBkYXRlXFxcIiksdm9pZCBiLmV2ZW50cy5vbihcXFwiZGVzdHJveVxcXCIsZnVuY3Rpb24oKXthKGIub193aW4pLm9mZihcXFwicmVzaXplLmNoYXJcXFwiK2IuaWQpLGgucmVtb3ZlRGF0YSgpLnJlbW92ZSgpLGg9bnVsbH0pKSl9dmFyIGg7cmV0dXJue19pbml0OmcsY291bnQ6Y319fSk7XCJcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcmF3LWxvYWRlciEuL34vZnJvYWxhLWVkaXRvci9qcy9wbHVnaW5zL2NoYXJfY291bnRlci5taW4uanNcbi8vIG1vZHVsZSBpZCA9IDExXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	eval("__webpack_require__(2)(__webpack_require__(13))//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTIuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2Zyb2FsYS1lZGl0b3IvanMvcGx1Z2lucy9jb2RlX3ZpZXcubWluLmpzPzljNWIiXSwic291cmNlc0NvbnRlbnQiOlsicmVxdWlyZShcIiEhL3Zhci9hcHAvd2ViL2pzL25vZGVfbW9kdWxlcy9zY3JpcHQtbG9hZGVyL2FkZFNjcmlwdC5qc1wiKShyZXF1aXJlKFwiISEvdmFyL2FwcC93ZWIvanMvbm9kZV9tb2R1bGVzL3Jhdy1sb2FkZXIvaW5kZXguanMhL3Zhci9hcHAvd2ViL2pzL25vZGVfbW9kdWxlcy9mcm9hbGEtZWRpdG9yL2pzL3BsdWdpbnMvY29kZV92aWV3Lm1pbi5qc1wiKSlcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vc2NyaXB0LWxvYWRlciEuL34vZnJvYWxhLWVkaXRvci9qcy9wbHVnaW5zL2NvZGVfdmlldy5taW4uanNcbi8vIG1vZHVsZSBpZCA9IDEyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 13 */
/***/ function(module, exports) {

	eval("module.exports = \"/*!\\n * froala_editor v2.5.1 (https://www.froala.com/wysiwyg-editor)\\n * License https://froala.com/wysiwyg-editor/terms/\\n * Copyright 2014-2017 Froala Labs\\n */\\n\\n!function(a){\\\"function\\\"==typeof define&&define.amd?define([\\\"jquery\\\"],a):\\\"object\\\"==typeof module&&module.exports?module.exports=function(b,c){return void 0===c&&(c=\\\"undefined\\\"!=typeof window?require(\\\"jquery\\\"):require(\\\"jquery\\\")(b)),a(c)}:a(window.jQuery)}(function(a){a.extend(a.FE.DEFAULTS,{codeMirror:!0,codeMirrorOptions:{lineNumbers:!0,tabMode:\\\"indent\\\",indentWithTabs:!0,lineWrapping:!0,mode:\\\"text/html\\\",tabSize:2},codeBeautifierOptions:{end_with_newline:!0,indent_inner_html:!0,extra_liners:[\\\"p\\\",\\\"h1\\\",\\\"h2\\\",\\\"h3\\\",\\\"h4\\\",\\\"h5\\\",\\\"h6\\\",\\\"blockquote\\\",\\\"pre\\\",\\\"ul\\\",\\\"ol\\\",\\\"table\\\",\\\"dl\\\"],brace_style:\\\"expand\\\",indent_char:\\\"\\\\t\\\",indent_size:1,wrap_line_length:0},codeViewKeepActiveButtons:[\\\"fullscreen\\\"]}),a.FE.PLUGINS.codeView=function(b){function c(){return b.$box.hasClass(\\\"fr-code-view\\\")}function d(){return l?l.getValue():k.val()}function e(a){var c=d();b.html.set(c),b.$el.blur(),b.$tb.find(\\\" > .fr-command\\\").not(a).removeClass(\\\"fr-disabled\\\").attr(\\\"aria-disabled\\\",!1),a.removeClass(\\\"fr-active\\\").attr(\\\"aria-pressed\\\",!1),b.events.focus(!0),b.placeholder.refresh(),b.undo.saveStep()}function f(c){k||(i(),!l&&b.opts.codeMirror&&\\\"undefined\\\"!=typeof CodeMirror?l=CodeMirror.fromTextArea(k.get(0),b.opts.codeMirrorOptions):b.events.$on(k,\\\"keydown keyup change input\\\",function(){if(b.opts.height)this.removeAttribute(\\\"rows\\\");else if(this.rows||(this.rows=1),0===this.value.length)this.rows=1;else{for(this.style.height=\\\"auto\\\";this.rows>1&&this.scrollHeight<=this.offsetHeight;)this.rows-=1;for(;this.scrollHeight>this.offsetHeight&&(!b.opts.heightMax||this.offsetHeight<b.opts.heightMax);)this.rows+=1}})),b.undo.saveStep(),b.html.cleanEmptyTags(),b.html.cleanWhiteTags(!0),b.core.hasFocus()&&(b.core.isEmpty()||(b.selection.save(),b.$el.find('.fr-marker[data-type=\\\"true\\\"]:first').replaceWith('<span class=\\\"fr-tmp fr-sm\\\">F</span>'),b.$el.find('.fr-marker[data-type=\\\"false\\\"]:last').replaceWith('<span class=\\\"fr-tmp fr-em\\\">F</span>')));var d=b.html.get(!1,!0);b.$el.find(\\\"span.fr-tmp\\\").remove(),b.$box.toggleClass(\\\"fr-code-view\\\",!0),b.core.hasFocus()&&b.$el.blur(),d=d.replace(/<span class=\\\"fr-tmp fr-sm\\\">F<\\\\/span>/,\\\"FROALA-SM\\\"),d=d.replace(/<span class=\\\"fr-tmp fr-em\\\">F<\\\\/span>/,\\\"FROALA-EM\\\"),b.codeBeautifier&&(d=b.codeBeautifier.run(d,b.opts.codeBeautifierOptions));var e,f;if(l){e=d.indexOf(\\\"FROALA-SM\\\"),f=d.indexOf(\\\"FROALA-EM\\\"),e>f?e=f:f-=9,d=d.replace(/FROALA-SM/g,\\\"\\\").replace(/FROALA-EM/g,\\\"\\\");var g=d.substring(0,e).length-d.substring(0,e).replace(/\\\\n/g,\\\"\\\").length,h=d.substring(0,f).length-d.substring(0,f).replace(/\\\\n/g,\\\"\\\").length;e=d.substring(0,e).length-d.substring(0,d.substring(0,e).lastIndexOf(\\\"\\\\n\\\")+1).length,f=d.substring(0,f).length-d.substring(0,d.substring(0,f).lastIndexOf(\\\"\\\\n\\\")+1).length,l.setSize(null,b.opts.height?b.opts.height:\\\"auto\\\"),b.opts.heightMin&&b.$box.find(\\\".CodeMirror-scroll\\\").css(\\\"min-height\\\",b.opts.heightMin),l.setValue(d),l.focus(),l.setSelection({line:g,ch:e},{line:h,ch:f}),l.refresh(),l.clearHistory()}else{e=d.indexOf(\\\"FROALA-SM\\\"),f=d.indexOf(\\\"FROALA-EM\\\")-9,b.opts.heightMin&&k.css(\\\"min-height\\\",b.opts.heightMin),b.opts.height&&k.css(\\\"height\\\",b.opts.height),b.opts.heightMax&&k.css(\\\"max-height\\\",b.opts.height||b.opts.heightMax),k.val(d.replace(/FROALA-SM/g,\\\"\\\").replace(/FROALA-EM/g,\\\"\\\")).trigger(\\\"change\\\");var j=a(b.o_doc).scrollTop();k.focus(),k.get(0).setSelectionRange(e,f),a(b.o_doc).scrollTop(j)}b.$tb.find(\\\" > .fr-command\\\").not(c).filter(function(){return b.opts.codeViewKeepActiveButtons.indexOf(a(this).data(\\\"cmd\\\"))<0}).addClass(\\\"fr-disabled\\\").attr(\\\"aria-disabled\\\",!0),c.addClass(\\\"fr-active\\\").attr(\\\"aria-pressed\\\",!0),!b.helpers.isMobile()&&b.opts.toolbarInline&&b.toolbar.hide()}function g(a){\\\"undefined\\\"==typeof a&&(a=!c());var d=b.$tb.find('.fr-command[data-cmd=\\\"html\\\"]');a?(b.popups.hideAll(),f(d)):(b.$box.toggleClass(\\\"fr-code-view\\\",!1),e(d))}function h(){c()&&g(b.$tb.find('button[data-cmd=\\\"html\\\"]')),l&&l.toTextArea(),k.val(\\\"\\\").removeData().remove(),k=null,m&&(m.remove(),m=null)}function i(){k=a('<textarea class=\\\"fr-code\\\" tabIndex=\\\"-1\\\">'),b.$wp.append(k),k.attr(\\\"dir\\\",b.opts.direction),b.$box.hasClass(\\\"fr-basic\\\")||(m=a('<a data-cmd=\\\"html\\\" title=\\\"Code View\\\" class=\\\"fr-command fr-btn html-switch'+(b.helpers.isMobile()?\\\"\\\":\\\" fr-desktop\\\")+'\\\" role=\\\"button\\\" tabIndex=\\\"-1\\\"><i class=\\\"fa fa-code\\\"></i></button>'),b.$box.append(m),b.events.bindClick(b.$box,\\\"a.html-switch\\\",function(){g(!1)}));var e=function(){return!c()};b.events.on(\\\"buttons.refresh\\\",e),b.events.on(\\\"copy\\\",e,!0),b.events.on(\\\"cut\\\",e,!0),b.events.on(\\\"paste\\\",e,!0),b.events.on(\\\"destroy\\\",h,!0),b.events.on(\\\"html.set\\\",function(){c()&&g(!0)}),b.events.on(\\\"form.submit\\\",function(){c()&&(b.html.set(d()),b.events.trigger(\\\"contentChanged\\\",[],!0))},!0)}function j(){if(!b.$wp)return!1}var k,l,m;return{_init:j,toggle:g,isActive:c,get:d}},a.FE.RegisterCommand(\\\"html\\\",{title:\\\"Code View\\\",undo:!1,focus:!1,forcedRefresh:!0,toggle:!0,callback:function(){this.codeView.toggle()},plugin:\\\"codeView\\\"}),a.FE.DefineIcon(\\\"html\\\",{NAME:\\\"code\\\"})});\"//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2Zyb2FsYS1lZGl0b3IvanMvcGx1Z2lucy9jb2RlX3ZpZXcubWluLmpzPzg0ZjMiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBcIi8qIVxcbiAqIGZyb2FsYV9lZGl0b3IgdjIuNS4xIChodHRwczovL3d3dy5mcm9hbGEuY29tL3d5c2l3eWctZWRpdG9yKVxcbiAqIExpY2Vuc2UgaHR0cHM6Ly9mcm9hbGEuY29tL3d5c2l3eWctZWRpdG9yL3Rlcm1zL1xcbiAqIENvcHlyaWdodCAyMDE0LTIwMTcgRnJvYWxhIExhYnNcXG4gKi9cXG5cXG4hZnVuY3Rpb24oYSl7XFxcImZ1bmN0aW9uXFxcIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUoW1xcXCJqcXVlcnlcXFwiXSxhKTpcXFwib2JqZWN0XFxcIj09dHlwZW9mIG1vZHVsZSYmbW9kdWxlLmV4cG9ydHM/bW9kdWxlLmV4cG9ydHM9ZnVuY3Rpb24oYixjKXtyZXR1cm4gdm9pZCAwPT09YyYmKGM9XFxcInVuZGVmaW5lZFxcXCIhPXR5cGVvZiB3aW5kb3c/cmVxdWlyZShcXFwianF1ZXJ5XFxcIik6cmVxdWlyZShcXFwianF1ZXJ5XFxcIikoYikpLGEoYyl9OmEod2luZG93LmpRdWVyeSl9KGZ1bmN0aW9uKGEpe2EuZXh0ZW5kKGEuRkUuREVGQVVMVFMse2NvZGVNaXJyb3I6ITAsY29kZU1pcnJvck9wdGlvbnM6e2xpbmVOdW1iZXJzOiEwLHRhYk1vZGU6XFxcImluZGVudFxcXCIsaW5kZW50V2l0aFRhYnM6ITAsbGluZVdyYXBwaW5nOiEwLG1vZGU6XFxcInRleHQvaHRtbFxcXCIsdGFiU2l6ZToyfSxjb2RlQmVhdXRpZmllck9wdGlvbnM6e2VuZF93aXRoX25ld2xpbmU6ITAsaW5kZW50X2lubmVyX2h0bWw6ITAsZXh0cmFfbGluZXJzOltcXFwicFxcXCIsXFxcImgxXFxcIixcXFwiaDJcXFwiLFxcXCJoM1xcXCIsXFxcImg0XFxcIixcXFwiaDVcXFwiLFxcXCJoNlxcXCIsXFxcImJsb2NrcXVvdGVcXFwiLFxcXCJwcmVcXFwiLFxcXCJ1bFxcXCIsXFxcIm9sXFxcIixcXFwidGFibGVcXFwiLFxcXCJkbFxcXCJdLGJyYWNlX3N0eWxlOlxcXCJleHBhbmRcXFwiLGluZGVudF9jaGFyOlxcXCJcXFxcdFxcXCIsaW5kZW50X3NpemU6MSx3cmFwX2xpbmVfbGVuZ3RoOjB9LGNvZGVWaWV3S2VlcEFjdGl2ZUJ1dHRvbnM6W1xcXCJmdWxsc2NyZWVuXFxcIl19KSxhLkZFLlBMVUdJTlMuY29kZVZpZXc9ZnVuY3Rpb24oYil7ZnVuY3Rpb24gYygpe3JldHVybiBiLiRib3guaGFzQ2xhc3MoXFxcImZyLWNvZGUtdmlld1xcXCIpfWZ1bmN0aW9uIGQoKXtyZXR1cm4gbD9sLmdldFZhbHVlKCk6ay52YWwoKX1mdW5jdGlvbiBlKGEpe3ZhciBjPWQoKTtiLmh0bWwuc2V0KGMpLGIuJGVsLmJsdXIoKSxiLiR0Yi5maW5kKFxcXCIgPiAuZnItY29tbWFuZFxcXCIpLm5vdChhKS5yZW1vdmVDbGFzcyhcXFwiZnItZGlzYWJsZWRcXFwiKS5hdHRyKFxcXCJhcmlhLWRpc2FibGVkXFxcIiwhMSksYS5yZW1vdmVDbGFzcyhcXFwiZnItYWN0aXZlXFxcIikuYXR0cihcXFwiYXJpYS1wcmVzc2VkXFxcIiwhMSksYi5ldmVudHMuZm9jdXMoITApLGIucGxhY2Vob2xkZXIucmVmcmVzaCgpLGIudW5kby5zYXZlU3RlcCgpfWZ1bmN0aW9uIGYoYyl7a3x8KGkoKSwhbCYmYi5vcHRzLmNvZGVNaXJyb3ImJlxcXCJ1bmRlZmluZWRcXFwiIT10eXBlb2YgQ29kZU1pcnJvcj9sPUNvZGVNaXJyb3IuZnJvbVRleHRBcmVhKGsuZ2V0KDApLGIub3B0cy5jb2RlTWlycm9yT3B0aW9ucyk6Yi5ldmVudHMuJG9uKGssXFxcImtleWRvd24ga2V5dXAgY2hhbmdlIGlucHV0XFxcIixmdW5jdGlvbigpe2lmKGIub3B0cy5oZWlnaHQpdGhpcy5yZW1vdmVBdHRyaWJ1dGUoXFxcInJvd3NcXFwiKTtlbHNlIGlmKHRoaXMucm93c3x8KHRoaXMucm93cz0xKSwwPT09dGhpcy52YWx1ZS5sZW5ndGgpdGhpcy5yb3dzPTE7ZWxzZXtmb3IodGhpcy5zdHlsZS5oZWlnaHQ9XFxcImF1dG9cXFwiO3RoaXMucm93cz4xJiZ0aGlzLnNjcm9sbEhlaWdodDw9dGhpcy5vZmZzZXRIZWlnaHQ7KXRoaXMucm93cy09MTtmb3IoO3RoaXMuc2Nyb2xsSGVpZ2h0PnRoaXMub2Zmc2V0SGVpZ2h0JiYoIWIub3B0cy5oZWlnaHRNYXh8fHRoaXMub2Zmc2V0SGVpZ2h0PGIub3B0cy5oZWlnaHRNYXgpOyl0aGlzLnJvd3MrPTF9fSkpLGIudW5kby5zYXZlU3RlcCgpLGIuaHRtbC5jbGVhbkVtcHR5VGFncygpLGIuaHRtbC5jbGVhbldoaXRlVGFncyghMCksYi5jb3JlLmhhc0ZvY3VzKCkmJihiLmNvcmUuaXNFbXB0eSgpfHwoYi5zZWxlY3Rpb24uc2F2ZSgpLGIuJGVsLmZpbmQoJy5mci1tYXJrZXJbZGF0YS10eXBlPVxcXCJ0cnVlXFxcIl06Zmlyc3QnKS5yZXBsYWNlV2l0aCgnPHNwYW4gY2xhc3M9XFxcImZyLXRtcCBmci1zbVxcXCI+Rjwvc3Bhbj4nKSxiLiRlbC5maW5kKCcuZnItbWFya2VyW2RhdGEtdHlwZT1cXFwiZmFsc2VcXFwiXTpsYXN0JykucmVwbGFjZVdpdGgoJzxzcGFuIGNsYXNzPVxcXCJmci10bXAgZnItZW1cXFwiPkY8L3NwYW4+JykpKTt2YXIgZD1iLmh0bWwuZ2V0KCExLCEwKTtiLiRlbC5maW5kKFxcXCJzcGFuLmZyLXRtcFxcXCIpLnJlbW92ZSgpLGIuJGJveC50b2dnbGVDbGFzcyhcXFwiZnItY29kZS12aWV3XFxcIiwhMCksYi5jb3JlLmhhc0ZvY3VzKCkmJmIuJGVsLmJsdXIoKSxkPWQucmVwbGFjZSgvPHNwYW4gY2xhc3M9XFxcImZyLXRtcCBmci1zbVxcXCI+RjxcXFxcL3NwYW4+LyxcXFwiRlJPQUxBLVNNXFxcIiksZD1kLnJlcGxhY2UoLzxzcGFuIGNsYXNzPVxcXCJmci10bXAgZnItZW1cXFwiPkY8XFxcXC9zcGFuPi8sXFxcIkZST0FMQS1FTVxcXCIpLGIuY29kZUJlYXV0aWZpZXImJihkPWIuY29kZUJlYXV0aWZpZXIucnVuKGQsYi5vcHRzLmNvZGVCZWF1dGlmaWVyT3B0aW9ucykpO3ZhciBlLGY7aWYobCl7ZT1kLmluZGV4T2YoXFxcIkZST0FMQS1TTVxcXCIpLGY9ZC5pbmRleE9mKFxcXCJGUk9BTEEtRU1cXFwiKSxlPmY/ZT1mOmYtPTksZD1kLnJlcGxhY2UoL0ZST0FMQS1TTS9nLFxcXCJcXFwiKS5yZXBsYWNlKC9GUk9BTEEtRU0vZyxcXFwiXFxcIik7dmFyIGc9ZC5zdWJzdHJpbmcoMCxlKS5sZW5ndGgtZC5zdWJzdHJpbmcoMCxlKS5yZXBsYWNlKC9cXFxcbi9nLFxcXCJcXFwiKS5sZW5ndGgsaD1kLnN1YnN0cmluZygwLGYpLmxlbmd0aC1kLnN1YnN0cmluZygwLGYpLnJlcGxhY2UoL1xcXFxuL2csXFxcIlxcXCIpLmxlbmd0aDtlPWQuc3Vic3RyaW5nKDAsZSkubGVuZ3RoLWQuc3Vic3RyaW5nKDAsZC5zdWJzdHJpbmcoMCxlKS5sYXN0SW5kZXhPZihcXFwiXFxcXG5cXFwiKSsxKS5sZW5ndGgsZj1kLnN1YnN0cmluZygwLGYpLmxlbmd0aC1kLnN1YnN0cmluZygwLGQuc3Vic3RyaW5nKDAsZikubGFzdEluZGV4T2YoXFxcIlxcXFxuXFxcIikrMSkubGVuZ3RoLGwuc2V0U2l6ZShudWxsLGIub3B0cy5oZWlnaHQ/Yi5vcHRzLmhlaWdodDpcXFwiYXV0b1xcXCIpLGIub3B0cy5oZWlnaHRNaW4mJmIuJGJveC5maW5kKFxcXCIuQ29kZU1pcnJvci1zY3JvbGxcXFwiKS5jc3MoXFxcIm1pbi1oZWlnaHRcXFwiLGIub3B0cy5oZWlnaHRNaW4pLGwuc2V0VmFsdWUoZCksbC5mb2N1cygpLGwuc2V0U2VsZWN0aW9uKHtsaW5lOmcsY2g6ZX0se2xpbmU6aCxjaDpmfSksbC5yZWZyZXNoKCksbC5jbGVhckhpc3RvcnkoKX1lbHNle2U9ZC5pbmRleE9mKFxcXCJGUk9BTEEtU01cXFwiKSxmPWQuaW5kZXhPZihcXFwiRlJPQUxBLUVNXFxcIiktOSxiLm9wdHMuaGVpZ2h0TWluJiZrLmNzcyhcXFwibWluLWhlaWdodFxcXCIsYi5vcHRzLmhlaWdodE1pbiksYi5vcHRzLmhlaWdodCYmay5jc3MoXFxcImhlaWdodFxcXCIsYi5vcHRzLmhlaWdodCksYi5vcHRzLmhlaWdodE1heCYmay5jc3MoXFxcIm1heC1oZWlnaHRcXFwiLGIub3B0cy5oZWlnaHR8fGIub3B0cy5oZWlnaHRNYXgpLGsudmFsKGQucmVwbGFjZSgvRlJPQUxBLVNNL2csXFxcIlxcXCIpLnJlcGxhY2UoL0ZST0FMQS1FTS9nLFxcXCJcXFwiKSkudHJpZ2dlcihcXFwiY2hhbmdlXFxcIik7dmFyIGo9YShiLm9fZG9jKS5zY3JvbGxUb3AoKTtrLmZvY3VzKCksay5nZXQoMCkuc2V0U2VsZWN0aW9uUmFuZ2UoZSxmKSxhKGIub19kb2MpLnNjcm9sbFRvcChqKX1iLiR0Yi5maW5kKFxcXCIgPiAuZnItY29tbWFuZFxcXCIpLm5vdChjKS5maWx0ZXIoZnVuY3Rpb24oKXtyZXR1cm4gYi5vcHRzLmNvZGVWaWV3S2VlcEFjdGl2ZUJ1dHRvbnMuaW5kZXhPZihhKHRoaXMpLmRhdGEoXFxcImNtZFxcXCIpKTwwfSkuYWRkQ2xhc3MoXFxcImZyLWRpc2FibGVkXFxcIikuYXR0cihcXFwiYXJpYS1kaXNhYmxlZFxcXCIsITApLGMuYWRkQ2xhc3MoXFxcImZyLWFjdGl2ZVxcXCIpLmF0dHIoXFxcImFyaWEtcHJlc3NlZFxcXCIsITApLCFiLmhlbHBlcnMuaXNNb2JpbGUoKSYmYi5vcHRzLnRvb2xiYXJJbmxpbmUmJmIudG9vbGJhci5oaWRlKCl9ZnVuY3Rpb24gZyhhKXtcXFwidW5kZWZpbmVkXFxcIj09dHlwZW9mIGEmJihhPSFjKCkpO3ZhciBkPWIuJHRiLmZpbmQoJy5mci1jb21tYW5kW2RhdGEtY21kPVxcXCJodG1sXFxcIl0nKTthPyhiLnBvcHVwcy5oaWRlQWxsKCksZihkKSk6KGIuJGJveC50b2dnbGVDbGFzcyhcXFwiZnItY29kZS12aWV3XFxcIiwhMSksZShkKSl9ZnVuY3Rpb24gaCgpe2MoKSYmZyhiLiR0Yi5maW5kKCdidXR0b25bZGF0YS1jbWQ9XFxcImh0bWxcXFwiXScpKSxsJiZsLnRvVGV4dEFyZWEoKSxrLnZhbChcXFwiXFxcIikucmVtb3ZlRGF0YSgpLnJlbW92ZSgpLGs9bnVsbCxtJiYobS5yZW1vdmUoKSxtPW51bGwpfWZ1bmN0aW9uIGkoKXtrPWEoJzx0ZXh0YXJlYSBjbGFzcz1cXFwiZnItY29kZVxcXCIgdGFiSW5kZXg9XFxcIi0xXFxcIj4nKSxiLiR3cC5hcHBlbmQoayksay5hdHRyKFxcXCJkaXJcXFwiLGIub3B0cy5kaXJlY3Rpb24pLGIuJGJveC5oYXNDbGFzcyhcXFwiZnItYmFzaWNcXFwiKXx8KG09YSgnPGEgZGF0YS1jbWQ9XFxcImh0bWxcXFwiIHRpdGxlPVxcXCJDb2RlIFZpZXdcXFwiIGNsYXNzPVxcXCJmci1jb21tYW5kIGZyLWJ0biBodG1sLXN3aXRjaCcrKGIuaGVscGVycy5pc01vYmlsZSgpP1xcXCJcXFwiOlxcXCIgZnItZGVza3RvcFxcXCIpKydcXFwiIHJvbGU9XFxcImJ1dHRvblxcXCIgdGFiSW5kZXg9XFxcIi0xXFxcIj48aSBjbGFzcz1cXFwiZmEgZmEtY29kZVxcXCI+PC9pPjwvYnV0dG9uPicpLGIuJGJveC5hcHBlbmQobSksYi5ldmVudHMuYmluZENsaWNrKGIuJGJveCxcXFwiYS5odG1sLXN3aXRjaFxcXCIsZnVuY3Rpb24oKXtnKCExKX0pKTt2YXIgZT1mdW5jdGlvbigpe3JldHVybiFjKCl9O2IuZXZlbnRzLm9uKFxcXCJidXR0b25zLnJlZnJlc2hcXFwiLGUpLGIuZXZlbnRzLm9uKFxcXCJjb3B5XFxcIixlLCEwKSxiLmV2ZW50cy5vbihcXFwiY3V0XFxcIixlLCEwKSxiLmV2ZW50cy5vbihcXFwicGFzdGVcXFwiLGUsITApLGIuZXZlbnRzLm9uKFxcXCJkZXN0cm95XFxcIixoLCEwKSxiLmV2ZW50cy5vbihcXFwiaHRtbC5zZXRcXFwiLGZ1bmN0aW9uKCl7YygpJiZnKCEwKX0pLGIuZXZlbnRzLm9uKFxcXCJmb3JtLnN1Ym1pdFxcXCIsZnVuY3Rpb24oKXtjKCkmJihiLmh0bWwuc2V0KGQoKSksYi5ldmVudHMudHJpZ2dlcihcXFwiY29udGVudENoYW5nZWRcXFwiLFtdLCEwKSl9LCEwKX1mdW5jdGlvbiBqKCl7aWYoIWIuJHdwKXJldHVybiExfXZhciBrLGwsbTtyZXR1cm57X2luaXQ6aix0b2dnbGU6Zyxpc0FjdGl2ZTpjLGdldDpkfX0sYS5GRS5SZWdpc3RlckNvbW1hbmQoXFxcImh0bWxcXFwiLHt0aXRsZTpcXFwiQ29kZSBWaWV3XFxcIix1bmRvOiExLGZvY3VzOiExLGZvcmNlZFJlZnJlc2g6ITAsdG9nZ2xlOiEwLGNhbGxiYWNrOmZ1bmN0aW9uKCl7dGhpcy5jb2RlVmlldy50b2dnbGUoKX0scGx1Z2luOlxcXCJjb2RlVmlld1xcXCJ9KSxhLkZFLkRlZmluZUljb24oXFxcImh0bWxcXFwiLHtOQU1FOlxcXCJjb2RlXFxcIn0pfSk7XCJcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcmF3LWxvYWRlciEuL34vZnJvYWxhLWVkaXRvci9qcy9wbHVnaW5zL2NvZGVfdmlldy5taW4uanNcbi8vIG1vZHVsZSBpZCA9IDEzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

	eval("__webpack_require__(2)(__webpack_require__(15))//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTQuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2Zyb2FsYS1lZGl0b3IvanMvcGx1Z2lucy9lbnRpdGllcy5taW4uanM/OTY4OCJdLCJzb3VyY2VzQ29udGVudCI6WyJyZXF1aXJlKFwiISEvdmFyL2FwcC93ZWIvanMvbm9kZV9tb2R1bGVzL3NjcmlwdC1sb2FkZXIvYWRkU2NyaXB0LmpzXCIpKHJlcXVpcmUoXCIhIS92YXIvYXBwL3dlYi9qcy9ub2RlX21vZHVsZXMvcmF3LWxvYWRlci9pbmRleC5qcyEvdmFyL2FwcC93ZWIvanMvbm9kZV9tb2R1bGVzL2Zyb2FsYS1lZGl0b3IvanMvcGx1Z2lucy9lbnRpdGllcy5taW4uanNcIikpXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3NjcmlwdC1sb2FkZXIhLi9+L2Zyb2FsYS1lZGl0b3IvanMvcGx1Z2lucy9lbnRpdGllcy5taW4uanNcbi8vIG1vZHVsZSBpZCA9IDE0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 15 */
/***/ function(module, exports) {

	eval("module.exports = \"/*!\\n * froala_editor v2.5.1 (https://www.froala.com/wysiwyg-editor)\\n * License https://froala.com/wysiwyg-editor/terms/\\n * Copyright 2014-2017 Froala Labs\\n */\\n\\n!function(a){\\\"function\\\"==typeof define&&define.amd?define([\\\"jquery\\\"],a):\\\"object\\\"==typeof module&&module.exports?module.exports=function(b,c){return void 0===c&&(c=\\\"undefined\\\"!=typeof window?require(\\\"jquery\\\"):require(\\\"jquery\\\")(b)),a(c)}:a(window.jQuery)}(function(a){a.extend(a.FE.DEFAULTS,{entities:\\\"&quot;&#39;&iexcl;&cent;&pound;&curren;&yen;&brvbar;&sect;&uml;&copy;&ordf;&laquo;&not;&shy;&reg;&macr;&deg;&plusmn;&sup2;&sup3;&acute;&micro;&para;&middot;&cedil;&sup1;&ordm;&raquo;&frac14;&frac12;&frac34;&iquest;&Agrave;&Aacute;&Acirc;&Atilde;&Auml;&Aring;&AElig;&Ccedil;&Egrave;&Eacute;&Ecirc;&Euml;&Igrave;&Iacute;&Icirc;&Iuml;&ETH;&Ntilde;&Ograve;&Oacute;&Ocirc;&Otilde;&Ouml;&times;&Oslash;&Ugrave;&Uacute;&Ucirc;&Uuml;&Yacute;&THORN;&szlig;&agrave;&aacute;&acirc;&atilde;&auml;&aring;&aelig;&ccedil;&egrave;&eacute;&ecirc;&euml;&igrave;&iacute;&icirc;&iuml;&eth;&ntilde;&ograve;&oacute;&ocirc;&otilde;&ouml;&divide;&oslash;&ugrave;&uacute;&ucirc;&uuml;&yacute;&thorn;&yuml;&OElig;&oelig;&Scaron;&scaron;&Yuml;&fnof;&circ;&tilde;&Alpha;&Beta;&Gamma;&Delta;&Epsilon;&Zeta;&Eta;&Theta;&Iota;&Kappa;&Lambda;&Mu;&Nu;&Xi;&Omicron;&Pi;&Rho;&Sigma;&Tau;&Upsilon;&Phi;&Chi;&Psi;&Omega;&alpha;&beta;&gamma;&delta;&epsilon;&zeta;&eta;&theta;&iota;&kappa;&lambda;&mu;&nu;&xi;&omicron;&pi;&rho;&sigmaf;&sigma;&tau;&upsilon;&phi;&chi;&psi;&omega;&thetasym;&upsih;&piv;&ensp;&emsp;&thinsp;&zwnj;&zwj;&lrm;&rlm;&ndash;&mdash;&lsquo;&rsquo;&sbquo;&ldquo;&rdquo;&bdquo;&dagger;&Dagger;&bull;&hellip;&permil;&prime;&Prime;&lsaquo;&rsaquo;&oline;&frasl;&euro;&image;&weierp;&real;&trade;&alefsym;&larr;&uarr;&rarr;&darr;&harr;&crarr;&lArr;&uArr;&rArr;&dArr;&hArr;&forall;&part;&exist;&empty;&nabla;&isin;&notin;&ni;&prod;&sum;&minus;&lowast;&radic;&prop;&infin;&ang;&and;&or;&cap;&cup;&int;&there4;&sim;&cong;&asymp;&ne;&equiv;&le;&ge;&sub;&sup;&nsub;&sube;&supe;&oplus;&otimes;&perp;&sdot;&lceil;&rceil;&lfloor;&rfloor;&lang;&rang;&loz;&spades;&clubs;&hearts;&diams;\\\"}),a.FE.PLUGINS.entities=function(b){function c(a){var b=a.textContent;if(b.match(g)){for(var c=\\\"\\\",d=0;d<b.length;d++)c+=h[b[d]]?h[b[d]]:b[d];a.textContent=c}}function d(a){if(a&&[\\\"STYLE\\\",\\\"SCRIPT\\\",\\\"svg\\\"].indexOf(a.tagName)>=0)return!0;for(var e=b.node.contents(a),f=0;f<e.length;f++)e[f].nodeType==Node.TEXT_NODE?c(e[f]):d(e[f]);a.nodeType==Node.TEXT_NODE&&c(a)}function e(a){if(0===a.length)return\\\"\\\";var c=b.clean.exec(a,d).replace(/\\\\&amp;/g,\\\"&\\\");return c}function f(){b.opts.htmlSimpleAmpersand||(b.opts.entities=b.opts.entities+\\\"&amp;\\\");var c=a(\\\"<div>\\\").html(b.opts.entities).text(),d=b.opts.entities.split(\\\";\\\");h={},g=\\\"\\\";for(var f=0;f<c.length;f++){var i=c.charAt(f);h[i]=d[f]+\\\";\\\",g+=\\\"\\\\\\\\\\\"+i+(f<c.length-1?\\\"|\\\":\\\"\\\")}g=new RegExp(\\\"(\\\"+g+\\\")\\\",\\\"g\\\"),b.events.on(\\\"html.get\\\",e,!0)}var g,h;return{_init:f}}});\"//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTUuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2Zyb2FsYS1lZGl0b3IvanMvcGx1Z2lucy9lbnRpdGllcy5taW4uanM/ODViMiJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IFwiLyohXFxuICogZnJvYWxhX2VkaXRvciB2Mi41LjEgKGh0dHBzOi8vd3d3LmZyb2FsYS5jb20vd3lzaXd5Zy1lZGl0b3IpXFxuICogTGljZW5zZSBodHRwczovL2Zyb2FsYS5jb20vd3lzaXd5Zy1lZGl0b3IvdGVybXMvXFxuICogQ29weXJpZ2h0IDIwMTQtMjAxNyBGcm9hbGEgTGFic1xcbiAqL1xcblxcbiFmdW5jdGlvbihhKXtcXFwiZnVuY3Rpb25cXFwiPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZShbXFxcImpxdWVyeVxcXCJdLGEpOlxcXCJvYmplY3RcXFwiPT10eXBlb2YgbW9kdWxlJiZtb2R1bGUuZXhwb3J0cz9tb2R1bGUuZXhwb3J0cz1mdW5jdGlvbihiLGMpe3JldHVybiB2b2lkIDA9PT1jJiYoYz1cXFwidW5kZWZpbmVkXFxcIiE9dHlwZW9mIHdpbmRvdz9yZXF1aXJlKFxcXCJqcXVlcnlcXFwiKTpyZXF1aXJlKFxcXCJqcXVlcnlcXFwiKShiKSksYShjKX06YSh3aW5kb3cualF1ZXJ5KX0oZnVuY3Rpb24oYSl7YS5leHRlbmQoYS5GRS5ERUZBVUxUUyx7ZW50aXRpZXM6XFxcIiZxdW90OyYjMzk7JmlleGNsOyZjZW50OyZwb3VuZDsmY3VycmVuOyZ5ZW47JmJydmJhcjsmc2VjdDsmdW1sOyZjb3B5OyZvcmRmOyZsYXF1bzsmbm90OyZzaHk7JnJlZzsmbWFjcjsmZGVnOyZwbHVzbW47JnN1cDI7JnN1cDM7JmFjdXRlOyZtaWNybzsmcGFyYTsmbWlkZG90OyZjZWRpbDsmc3VwMTsmb3JkbTsmcmFxdW87JmZyYWMxNDsmZnJhYzEyOyZmcmFjMzQ7JmlxdWVzdDsmQWdyYXZlOyZBYWN1dGU7JkFjaXJjOyZBdGlsZGU7JkF1bWw7JkFyaW5nOyZBRWxpZzsmQ2NlZGlsOyZFZ3JhdmU7JkVhY3V0ZTsmRWNpcmM7JkV1bWw7JklncmF2ZTsmSWFjdXRlOyZJY2lyYzsmSXVtbDsmRVRIOyZOdGlsZGU7Jk9ncmF2ZTsmT2FjdXRlOyZPY2lyYzsmT3RpbGRlOyZPdW1sOyZ0aW1lczsmT3NsYXNoOyZVZ3JhdmU7JlVhY3V0ZTsmVWNpcmM7JlV1bWw7JllhY3V0ZTsmVEhPUk47JnN6bGlnOyZhZ3JhdmU7JmFhY3V0ZTsmYWNpcmM7JmF0aWxkZTsmYXVtbDsmYXJpbmc7JmFlbGlnOyZjY2VkaWw7JmVncmF2ZTsmZWFjdXRlOyZlY2lyYzsmZXVtbDsmaWdyYXZlOyZpYWN1dGU7JmljaXJjOyZpdW1sOyZldGg7Jm50aWxkZTsmb2dyYXZlOyZvYWN1dGU7Jm9jaXJjOyZvdGlsZGU7Jm91bWw7JmRpdmlkZTsmb3NsYXNoOyZ1Z3JhdmU7JnVhY3V0ZTsmdWNpcmM7JnV1bWw7JnlhY3V0ZTsmdGhvcm47Jnl1bWw7Jk9FbGlnOyZvZWxpZzsmU2Nhcm9uOyZzY2Fyb247Jll1bWw7JmZub2Y7JmNpcmM7JnRpbGRlOyZBbHBoYTsmQmV0YTsmR2FtbWE7JkRlbHRhOyZFcHNpbG9uOyZaZXRhOyZFdGE7JlRoZXRhOyZJb3RhOyZLYXBwYTsmTGFtYmRhOyZNdTsmTnU7JlhpOyZPbWljcm9uOyZQaTsmUmhvOyZTaWdtYTsmVGF1OyZVcHNpbG9uOyZQaGk7JkNoaTsmUHNpOyZPbWVnYTsmYWxwaGE7JmJldGE7JmdhbW1hOyZkZWx0YTsmZXBzaWxvbjsmemV0YTsmZXRhOyZ0aGV0YTsmaW90YTsma2FwcGE7JmxhbWJkYTsmbXU7Jm51OyZ4aTsmb21pY3JvbjsmcGk7JnJobzsmc2lnbWFmOyZzaWdtYTsmdGF1OyZ1cHNpbG9uOyZwaGk7JmNoaTsmcHNpOyZvbWVnYTsmdGhldGFzeW07JnVwc2loOyZwaXY7JmVuc3A7JmVtc3A7JnRoaW5zcDsmenduajsmendqOyZscm07JnJsbTsmbmRhc2g7Jm1kYXNoOyZsc3F1bzsmcnNxdW87JnNicXVvOyZsZHF1bzsmcmRxdW87JmJkcXVvOyZkYWdnZXI7JkRhZ2dlcjsmYnVsbDsmaGVsbGlwOyZwZXJtaWw7JnByaW1lOyZQcmltZTsmbHNhcXVvOyZyc2FxdW87Jm9saW5lOyZmcmFzbDsmZXVybzsmaW1hZ2U7JndlaWVycDsmcmVhbDsmdHJhZGU7JmFsZWZzeW07JmxhcnI7JnVhcnI7JnJhcnI7JmRhcnI7JmhhcnI7JmNyYXJyOyZsQXJyOyZ1QXJyOyZyQXJyOyZkQXJyOyZoQXJyOyZmb3JhbGw7JnBhcnQ7JmV4aXN0OyZlbXB0eTsmbmFibGE7JmlzaW47Jm5vdGluOyZuaTsmcHJvZDsmc3VtOyZtaW51czsmbG93YXN0OyZyYWRpYzsmcHJvcDsmaW5maW47JmFuZzsmYW5kOyZvcjsmY2FwOyZjdXA7JmludDsmdGhlcmU0OyZzaW07JmNvbmc7JmFzeW1wOyZuZTsmZXF1aXY7JmxlOyZnZTsmc3ViOyZzdXA7Jm5zdWI7JnN1YmU7JnN1cGU7Jm9wbHVzOyZvdGltZXM7JnBlcnA7JnNkb3Q7JmxjZWlsOyZyY2VpbDsmbGZsb29yOyZyZmxvb3I7Jmxhbmc7JnJhbmc7Jmxvejsmc3BhZGVzOyZjbHViczsmaGVhcnRzOyZkaWFtcztcXFwifSksYS5GRS5QTFVHSU5TLmVudGl0aWVzPWZ1bmN0aW9uKGIpe2Z1bmN0aW9uIGMoYSl7dmFyIGI9YS50ZXh0Q29udGVudDtpZihiLm1hdGNoKGcpKXtmb3IodmFyIGM9XFxcIlxcXCIsZD0wO2Q8Yi5sZW5ndGg7ZCsrKWMrPWhbYltkXV0/aFtiW2RdXTpiW2RdO2EudGV4dENvbnRlbnQ9Y319ZnVuY3Rpb24gZChhKXtpZihhJiZbXFxcIlNUWUxFXFxcIixcXFwiU0NSSVBUXFxcIixcXFwic3ZnXFxcIl0uaW5kZXhPZihhLnRhZ05hbWUpPj0wKXJldHVybiEwO2Zvcih2YXIgZT1iLm5vZGUuY29udGVudHMoYSksZj0wO2Y8ZS5sZW5ndGg7ZisrKWVbZl0ubm9kZVR5cGU9PU5vZGUuVEVYVF9OT0RFP2MoZVtmXSk6ZChlW2ZdKTthLm5vZGVUeXBlPT1Ob2RlLlRFWFRfTk9ERSYmYyhhKX1mdW5jdGlvbiBlKGEpe2lmKDA9PT1hLmxlbmd0aClyZXR1cm5cXFwiXFxcIjt2YXIgYz1iLmNsZWFuLmV4ZWMoYSxkKS5yZXBsYWNlKC9cXFxcJmFtcDsvZyxcXFwiJlxcXCIpO3JldHVybiBjfWZ1bmN0aW9uIGYoKXtiLm9wdHMuaHRtbFNpbXBsZUFtcGVyc2FuZHx8KGIub3B0cy5lbnRpdGllcz1iLm9wdHMuZW50aXRpZXMrXFxcIiZhbXA7XFxcIik7dmFyIGM9YShcXFwiPGRpdj5cXFwiKS5odG1sKGIub3B0cy5lbnRpdGllcykudGV4dCgpLGQ9Yi5vcHRzLmVudGl0aWVzLnNwbGl0KFxcXCI7XFxcIik7aD17fSxnPVxcXCJcXFwiO2Zvcih2YXIgZj0wO2Y8Yy5sZW5ndGg7ZisrKXt2YXIgaT1jLmNoYXJBdChmKTtoW2ldPWRbZl0rXFxcIjtcXFwiLGcrPVxcXCJcXFxcXFxcXFxcXCIraSsoZjxjLmxlbmd0aC0xP1xcXCJ8XFxcIjpcXFwiXFxcIil9Zz1uZXcgUmVnRXhwKFxcXCIoXFxcIitnK1xcXCIpXFxcIixcXFwiZ1xcXCIpLGIuZXZlbnRzLm9uKFxcXCJodG1sLmdldFxcXCIsZSwhMCl9dmFyIGcsaDtyZXR1cm57X2luaXQ6Zn19fSk7XCJcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcmF3LWxvYWRlciEuL34vZnJvYWxhLWVkaXRvci9qcy9wbHVnaW5zL2VudGl0aWVzLm1pbi5qc1xuLy8gbW9kdWxlIGlkID0gMTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQSIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

	eval("__webpack_require__(2)(__webpack_require__(17))//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTYuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2Zyb2FsYS1lZGl0b3IvanMvcGx1Z2lucy9saW5rLm1pbi5qcz9lNGE2Il0sInNvdXJjZXNDb250ZW50IjpbInJlcXVpcmUoXCIhIS92YXIvYXBwL3dlYi9qcy9ub2RlX21vZHVsZXMvc2NyaXB0LWxvYWRlci9hZGRTY3JpcHQuanNcIikocmVxdWlyZShcIiEhL3Zhci9hcHAvd2ViL2pzL25vZGVfbW9kdWxlcy9yYXctbG9hZGVyL2luZGV4LmpzIS92YXIvYXBwL3dlYi9qcy9ub2RlX21vZHVsZXMvZnJvYWxhLWVkaXRvci9qcy9wbHVnaW5zL2xpbmsubWluLmpzXCIpKVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9zY3JpcHQtbG9hZGVyIS4vfi9mcm9hbGEtZWRpdG9yL2pzL3BsdWdpbnMvbGluay5taW4uanNcbi8vIG1vZHVsZSBpZCA9IDE2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 17 */
/***/ function(module, exports) {

	eval("module.exports = \"/*!\\n * froala_editor v2.5.1 (https://www.froala.com/wysiwyg-editor)\\n * License https://froala.com/wysiwyg-editor/terms/\\n * Copyright 2014-2017 Froala Labs\\n */\\n\\n!function(a){\\\"function\\\"==typeof define&&define.amd?define([\\\"jquery\\\"],a):\\\"object\\\"==typeof module&&module.exports?module.exports=function(b,c){return void 0===c&&(c=\\\"undefined\\\"!=typeof window?require(\\\"jquery\\\"):require(\\\"jquery\\\")(b)),a(c)}:a(window.jQuery)}(function(a){a.extend(a.FE.POPUP_TEMPLATES,{\\\"link.edit\\\":\\\"[_BUTTONS_]\\\",\\\"link.insert\\\":\\\"[_BUTTONS_][_INPUT_LAYER_]\\\"}),a.extend(a.FE.DEFAULTS,{linkEditButtons:[\\\"linkOpen\\\",\\\"linkStyle\\\",\\\"linkEdit\\\",\\\"linkRemove\\\"],linkInsertButtons:[\\\"linkBack\\\",\\\"|\\\",\\\"linkList\\\"],linkAttributes:{},linkAutoPrefix:\\\"http://\\\",linkStyles:{\\\"fr-green\\\":\\\"Green\\\",\\\"fr-strong\\\":\\\"Thick\\\"},linkMultipleStyles:!0,linkConvertEmailAddress:!0,linkAlwaysBlank:!1,linkAlwaysNoFollow:!1,linkList:[{text:\\\"Froala\\\",href:\\\"https://froala.com\\\",target:\\\"_blank\\\"},{text:\\\"Google\\\",href:\\\"https://google.com\\\",target:\\\"_blank\\\"},{displayText:\\\"Facebook\\\",href:\\\"https://facebook.com\\\"}],linkText:!0}),a.FE.PLUGINS.link=function(b){function c(){var c=b.image?b.image.get():null;if(!c&&b.$wp){var d=b.selection.ranges(0).commonAncestorContainer;if(d&&(d.contains&&d.contains(b.el)||!b.el.contains(d)||b.el==d)&&(d=null),d&&\\\"A\\\"===d.tagName)return d;var e=b.selection.element(),f=b.selection.endElement();return\\\"A\\\"==e.tagName||b.node.isElement(e)||(e=a(e).parentsUntil(b.$el,\\\"a:first\\\").get(0)),\\\"A\\\"==f.tagName||b.node.isElement(f)||(f=a(f).parentsUntil(b.$el,\\\"a:first\\\").get(0)),f&&(f.contains&&f.contains(b.el)||!b.el.contains(f)||b.el==f)&&(f=null),e&&(e.contains&&e.contains(b.el)||!b.el.contains(e)||b.el==e)&&(e=null),f&&f==e&&\\\"A\\\"==f.tagName?e:null}return\\\"A\\\"==b.el.tagName?b.el:c&&c.get(0).parentNode&&\\\"A\\\"==c.get(0).parentNode.tagName?c.get(0).parentNode:void 0}function d(){var a=b.image?b.image.get():null,c=[];if(a)\\\"A\\\"==a.get(0).parentNode.tagName&&c.push(a.get(0).parentNode);else{var d,e,f,g;if(b.win.getSelection){var h=b.win.getSelection();if(h.getRangeAt&&h.rangeCount){g=b.doc.createRange();for(var i=0;i<h.rangeCount;++i)if(d=h.getRangeAt(i),e=d.commonAncestorContainer,e&&1!=e.nodeType&&(e=e.parentNode),e&&\\\"a\\\"==e.nodeName.toLowerCase())c.push(e);else{f=e.getElementsByTagName(\\\"a\\\");for(var j=0;j<f.length;++j)g.selectNodeContents(f[j]),g.compareBoundaryPoints(d.END_TO_START,d)<1&&g.compareBoundaryPoints(d.START_TO_END,d)>-1&&c.push(f[j])}}}else if(b.doc.selection&&\\\"Control\\\"!=b.doc.selection.type)if(d=b.doc.selection.createRange(),e=d.parentElement(),\\\"a\\\"==e.nodeName.toLowerCase())c.push(e);else{f=e.getElementsByTagName(\\\"a\\\"),g=b.doc.body.createTextRange();for(var k=0;k<f.length;++k)g.moveToElementText(f[k]),g.compareEndPoints(\\\"StartToEnd\\\",d)>-1&&g.compareEndPoints(\\\"EndToStart\\\",d)<1&&c.push(f[k])}}return c}function e(d){g(),setTimeout(function(){if(!d||d&&(1==d.which||\\\"mouseup\\\"!=d.type)){var e=c(),g=b.image?b.image.get():null;if(e&&!g){if(b.image){var h=b.node.contents(e);if(1==h.length&&\\\"IMG\\\"==h[0].tagName){var i=b.selection.ranges(0);return 0===i.startOffset&&0===i.endOffset?a(e).before(a.FE.MARKERS):a(e).after(a.FE.MARKERS),b.selection.restore(),!1}}d&&d.stopPropagation(),f(e)}}},b.helpers.isIOS()?100:0)}function f(c){var d=b.popups.get(\\\"link.edit\\\");d||(d=h());var e=a(c);b.popups.isVisible(\\\"link.edit\\\")||b.popups.refresh(\\\"link.edit\\\"),b.popups.setContainer(\\\"link.edit\\\",b.$sc);var f=e.offset().left+a(c).outerWidth()/2,g=e.offset().top+e.outerHeight();b.popups.show(\\\"link.edit\\\",f,g,e.outerHeight())}function g(){b.popups.hide(\\\"link.edit\\\")}function h(){var a=\\\"\\\";b.opts.linkEditButtons.length>1&&(\\\"A\\\"==b.el.tagName&&b.opts.linkEditButtons.indexOf(\\\"linkRemove\\\")>=0&&b.opts.linkEditButtons.splice(b.opts.linkEditButtons.indexOf(\\\"linkRemove\\\"),1),a='<div class=\\\"fr-buttons\\\">'+b.button.buildList(b.opts.linkEditButtons)+\\\"</div>\\\");var d={buttons:a},e=b.popups.create(\\\"link.edit\\\",d);return b.$wp&&b.events.$on(b.$wp,\\\"scroll.link-edit\\\",function(){c()&&b.popups.isVisible(\\\"link.edit\\\")&&f(c())}),e}function i(){}function j(){var d=b.popups.get(\\\"link.insert\\\"),e=c();if(e){var f,g,h=a(e),i=d.find('input.fr-link-attr[type=\\\"text\\\"]'),j=d.find('input.fr-link-attr[type=\\\"checkbox\\\"]');for(f=0;f<i.length;f++)g=a(i[f]),g.val(h.attr(g.attr(\\\"name\\\")||\\\"\\\"));for(j.prop(\\\"checked\\\",!1),f=0;f<j.length;f++)g=a(j[f]),h.attr(g.attr(\\\"name\\\"))==g.data(\\\"checked\\\")&&g.prop(\\\"checked\\\",!0);d.find('input.fr-link-attr[type=\\\"text\\\"][name=\\\"text\\\"]').val(h.text())}else d.find('input.fr-link-attr[type=\\\"text\\\"]').val(\\\"\\\"),d.find('input.fr-link-attr[type=\\\"checkbox\\\"]').prop(\\\"checked\\\",!1),d.find('input.fr-link-attr[type=\\\"text\\\"][name=\\\"text\\\"]').val(b.selection.text());d.find(\\\"input.fr-link-attr\\\").trigger(\\\"change\\\");var k=b.image?b.image.get():null;k?d.find('.fr-link-attr[name=\\\"text\\\"]').parent().hide():d.find('.fr-link-attr[name=\\\"text\\\"]').parent().show()}function k(){var a=b.$tb.find('.fr-command[data-cmd=\\\"insertLink\\\"]'),c=b.popups.get(\\\"link.insert\\\");if(c||(c=l()),!c.hasClass(\\\"fr-active\\\"))if(b.popups.refresh(\\\"link.insert\\\"),b.popups.setContainer(\\\"link.insert\\\",b.$tb||b.$sc),a.is(\\\":visible\\\")){var d=a.offset().left+a.outerWidth()/2,e=a.offset().top+(b.opts.toolbarBottom?10:a.outerHeight()-10);b.popups.show(\\\"link.insert\\\",d,e,a.outerHeight())}else b.position.forSelection(c),b.popups.show(\\\"link.insert\\\")}function l(a){if(a)return b.popups.onRefresh(\\\"link.insert\\\",j),b.popups.onHide(\\\"link.insert\\\",i),!0;var d=\\\"\\\";b.opts.linkInsertButtons.length>=1&&(d='<div class=\\\"fr-buttons\\\">'+b.button.buildList(b.opts.linkInsertButtons)+\\\"</div>\\\");var e='<svg version=\\\"1.1\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\" xmlns:xlink=\\\"http://www.w3.org/1999/xlink\\\" width=\\\"10\\\" height=\\\"10\\\" viewBox=\\\"0 0 32 32\\\"><path d=\\\"M27 4l-15 15-7-7-5 5 12 12 20-20z\\\" fill=\\\"#FFF\\\"></path></svg>',f=\\\"\\\",g=0;f='<div class=\\\"fr-link-insert-layer fr-layer fr-active\\\" id=\\\"fr-link-insert-layer-'+b.id+'\\\">',f+='<div class=\\\"fr-input-line\\\"><input id=\\\"fr-link-insert-layer-url-'+b.id+'\\\" name=\\\"href\\\" type=\\\"text\\\" class=\\\"fr-link-attr\\\" placeholder=\\\"URL\\\" tabIndex=\\\"'+ ++g+'\\\"></div>',b.opts.linkText&&(f+='<div class=\\\"fr-input-line\\\"><input id=\\\"fr-link-insert-layer-text-'+b.id+'\\\" name=\\\"text\\\" type=\\\"text\\\" class=\\\"fr-link-attr\\\" placeholder=\\\"'+b.language.translate(\\\"Text\\\")+'\\\" tabIndex=\\\"'+ ++g+'\\\"></div>');for(var h in b.opts.linkAttributes)if(b.opts.linkAttributes.hasOwnProperty(h)){var k=b.opts.linkAttributes[h];f+='<div class=\\\"fr-input-line\\\"><input name=\\\"'+h+'\\\" type=\\\"text\\\" class=\\\"fr-link-attr\\\" placeholder=\\\"'+b.language.translate(k)+'\\\" tabIndex=\\\"'+ ++g+'\\\"></div>'}b.opts.linkAlwaysBlank||(f+='<div class=\\\"fr-checkbox-line\\\"><span class=\\\"fr-checkbox\\\"><input name=\\\"target\\\" class=\\\"fr-link-attr\\\" data-checked=\\\"_blank\\\" type=\\\"checkbox\\\" id=\\\"fr-link-target-'+b.id+'\\\" tabIndex=\\\"'+ ++g+'\\\"><span>'+e+'</span></span><label for=\\\"fr-link-target-'+b.id+'\\\">'+b.language.translate(\\\"Open in new tab\\\")+\\\"</label></div>\\\"),f+='<div class=\\\"fr-action-buttons\\\"><button class=\\\"fr-command fr-submit\\\" role=\\\"button\\\" data-cmd=\\\"linkInsert\\\" href=\\\"#\\\" tabIndex=\\\"'+ ++g+'\\\" type=\\\"button\\\">'+b.language.translate(\\\"Insert\\\")+\\\"</button></div></div>\\\";var l={buttons:d,input_layer:f},m=b.popups.create(\\\"link.insert\\\",l);return b.$wp&&b.events.$on(b.$wp,\\\"scroll.link-insert\\\",function(){var a=b.image?b.image.get():null;a&&b.popups.isVisible(\\\"link.insert\\\")&&u(),c&&b.popups.isVisible(\\\"link.insert\\\")&&s()}),m}function m(){var d=c(),e=b.image?b.image.get():null;return b.events.trigger(\\\"link.beforeRemove\\\",[d])!==!1&&void(e&&d?(e.unwrap(),b.image.edit(e)):d&&(b.selection.save(),a(d).replaceWith(a(d).html()),b.selection.restore(),g()))}function n(){b.events.on(\\\"keyup\\\",function(b){b.which!=a.FE.KEYCODE.ESC&&e(b)}),b.events.on(\\\"window.mouseup\\\",e),b.helpers.isMobile()&&b.events.$on(b.$doc,\\\"selectionchange\\\",e),l(!0),\\\"A\\\"==b.el.tagName&&b.$el.addClass(\\\"fr-view\\\"),b.events.on(\\\"toolbar.esc\\\",function(){if(b.popups.isVisible(\\\"link.edit\\\"))return b.events.disableBlur(),b.events.focus(),!1},!0)}function o(c){var d,e,f=b.opts.linkList[c],g=b.popups.get(\\\"link.insert\\\"),h=g.find('input.fr-link-attr[type=\\\"text\\\"]'),i=g.find('input.fr-link-attr[type=\\\"checkbox\\\"]');for(e=0;e<h.length;e++)d=a(h[e]),f[d.attr(\\\"name\\\")]?d.val(f[d.attr(\\\"name\\\")]):\\\"text\\\"!=d.attr(\\\"name\\\")&&d.val(\\\"\\\");for(e=0;e<i.length;e++)d=a(i[e]),d.prop(\\\"checked\\\",d.data(\\\"checked\\\")==f[d.attr(\\\"name\\\")]);b.accessibility.focusPopup(g)}function p(){var c,d,e=b.popups.get(\\\"link.insert\\\"),f=e.find('input.fr-link-attr[type=\\\"text\\\"]'),g=e.find('input.fr-link-attr[type=\\\"checkbox\\\"]'),h=f.filter('[name=\\\"href\\\"]').val(),i=f.filter('[name=\\\"text\\\"]').val(),j={};for(d=0;d<f.length;d++)c=a(f[d]),[\\\"href\\\",\\\"text\\\"].indexOf(c.attr(\\\"name\\\"))<0&&(j[c.attr(\\\"name\\\")]=c.val());for(d=0;d<g.length;d++)c=a(g[d]),c.is(\\\":checked\\\")?j[c.attr(\\\"name\\\")]=c.data(\\\"checked\\\"):j[c.attr(\\\"name\\\")]=c.data(\\\"unchecked\\\")||null;var k=b.helpers.scrollTop();r(h,i,j),a(b.o_win).scrollTop(k)}function q(){if(!b.selection.isCollapsed()){b.selection.save();for(var c=b.$el.find(\\\".fr-marker\\\").addClass(\\\"fr-unprocessed\\\").toArray();c.length;){var d=a(c.pop());d.removeClass(\\\"fr-unprocessed\\\");var e=b.node.deepestParent(d.get(0));if(e){var f=d.get(0),g=\\\"\\\",h=\\\"\\\";do f=f.parentNode,b.node.isBlock(f)||(g+=b.node.closeTagString(f),h=b.node.openTagString(f)+h);while(f!=e);var i=b.node.openTagString(d.get(0))+d.html()+b.node.closeTagString(d.get(0));d.replaceWith('<span id=\\\"fr-break\\\"></span>');var j=a(e).html();j=j.replace(/<span id=\\\"fr-break\\\"><\\\\/span>/g,g+i+h),a(e).html(j)}c=b.$el.find(\\\".fr-marker.fr-unprocessed\\\").toArray()}b.selection.restore()}}function r(f,g,h){if(\\\"undefined\\\"==typeof h&&(h={}),b.events.trigger(\\\"link.beforeInsert\\\",[f,g,h])===!1)return!1;var i=b.image?b.image.get():null;i||\\\"A\\\"==b.el.tagName?\\\"A\\\"==b.el.tagName&&b.$el.focus():(b.selection.restore(),b.popups.hide(\\\"link.insert\\\"));var j=f;if(b.opts.linkConvertEmailAddress){var k=/^[\\\\w._]+@[a-z\\\\u00a1-\\\\uffff0-9_-]+?\\\\.[a-z\\\\u00a1-\\\\uffff0-9]{2,}$/i;k.test(f)&&!/^mailto:.*/i.test(f)&&(f=\\\"mailto:\\\"+f)}if(\\\"\\\"===b.opts.linkAutoPrefix||/^(mailto|tel|sms|notes|data):.*/i.test(f)||/^data:image.*/i.test(f)||/^(https?:|ftps?:|file:|)\\\\/\\\\//i.test(f)||[\\\"/\\\",\\\"{\\\",\\\"[\\\",\\\"#\\\",\\\"(\\\"].indexOf((f||\\\"\\\")[0])<0&&(f=b.opts.linkAutoPrefix+f),f=b.helpers.sanitizeURL(f),b.opts.linkAlwaysBlank&&(h.target=\\\"_blank\\\"),b.opts.linkAlwaysNoFollow&&(h.rel=\\\"nofollow\\\"),\\\"_blank\\\"==h.target&&(h.rel?h.rel+=\\\" noopener noreferrer\\\":h.rel=\\\"noopener noreferrer\\\"),g=g||\\\"\\\",f===b.opts.linkAutoPrefix){var l=b.popups.get(\\\"link.insert\\\");return l.find('input[name=\\\"href\\\"]').addClass(\\\"fr-error\\\"),b.events.trigger(\\\"link.bad\\\",[j]),!1}var m,n=c();if(n)m=a(n),m.attr(\\\"href\\\",f),g.length>0&&m.text()!=g&&!i&&m.text(g),i||m.prepend(a.FE.START_MARKER).append(a.FE.END_MARKER),m.attr(h),i||b.selection.restore();else{i?i.wrap('<a href=\\\"'+f+'\\\"></a>'):(b.format.remove(\\\"a\\\"),b.selection.isCollapsed()?(g=0===g.length?j:g,b.html.insert('<a href=\\\"'+f+'\\\">'+a.FE.START_MARKER+g+a.FE.END_MARKER+\\\"</a>\\\"),b.selection.restore()):g.length>0&&g!=b.selection.text().replace(/\\\\n/g,\\\"\\\")?(b.selection.remove(),b.html.insert('<a href=\\\"'+f+'\\\">'+a.FE.START_MARKER+g+a.FE.END_MARKER+\\\"</a>\\\"),b.selection.restore()):(q(),b.format.apply(\\\"a\\\",{href:f})));for(var o=d(),p=0;p<o.length;p++)m=a(o[p]),m.attr(h),m.removeAttr(\\\"_moz_dirty\\\");1==o.length&&b.$wp&&!i&&(a(o[0]).prepend(a.FE.START_MARKER).append(a.FE.END_MARKER),b.selection.restore())}if(i){var r=b.popups.get(\\\"link.insert\\\");r.find(\\\"input:focus\\\").blur(),b.image.edit(i)}else e()}function s(){g();var d=c();if(d){var e=b.popups.get(\\\"link.insert\\\");e||(e=l()),b.popups.isVisible(\\\"link.insert\\\")||(b.popups.refresh(\\\"link.insert\\\"),b.selection.save(),b.helpers.isMobile()&&(b.events.disableBlur(),b.$el.blur(),b.events.enableBlur())),b.popups.setContainer(\\\"link.insert\\\",b.$sc);var f=(b.image?b.image.get():null)||a(d),h=f.offset().left+f.outerWidth()/2,i=f.offset().top+f.outerHeight();b.popups.show(\\\"link.insert\\\",h,i,f.outerHeight())}}function t(){var a=b.image?b.image.get():null;if(a)b.image.back();else{b.events.disableBlur(),b.selection.restore(),b.events.enableBlur();var d=c();d&&b.$wp?(b.selection.restore(),g(),e()):\\\"A\\\"==b.el.tagName?(b.$el.focus(),e()):(b.popups.hide(\\\"link.insert\\\"),b.toolbar.showInline())}}function u(){var a=b.image?b.image.get():null;if(a){var c=b.popups.get(\\\"link.insert\\\");c||(c=l()),j(!0),b.popups.setContainer(\\\"link.insert\\\",b.$sc);var d=a.offset().left+a.outerWidth()/2,e=a.offset().top+a.outerHeight();b.popups.show(\\\"link.insert\\\",d,e,a.outerHeight())}}function v(d,f,g){\\\"undefined\\\"==typeof g&&(g=b.opts.linkMultipleStyles),\\\"undefined\\\"==typeof f&&(f=b.opts.linkStyles);var h=c();if(!h)return!1;if(!g){var i=Object.keys(f);i.splice(i.indexOf(d),1),a(h).removeClass(i.join(\\\" \\\"))}a(h).toggleClass(d),e()}return{_init:n,remove:m,showInsertPopup:k,usePredefined:o,insertCallback:p,insert:r,update:s,get:c,allSelected:d,back:t,imageLink:u,applyStyle:v}},a.FE.DefineIcon(\\\"insertLink\\\",{NAME:\\\"link\\\"}),a.FE.RegisterShortcut(a.FE.KEYCODE.K,\\\"insertLink\\\",null,\\\"K\\\"),a.FE.RegisterCommand(\\\"insertLink\\\",{title:\\\"Insert Link\\\",undo:!1,focus:!0,refreshOnCallback:!1,popup:!0,callback:function(){this.popups.isVisible(\\\"link.insert\\\")?(this.$el.find(\\\".fr-marker\\\").length&&(this.events.disableBlur(),this.selection.restore()),this.popups.hide(\\\"link.insert\\\")):this.link.showInsertPopup()},plugin:\\\"link\\\"}),a.FE.DefineIcon(\\\"linkOpen\\\",{NAME:\\\"external-link\\\"}),a.FE.RegisterCommand(\\\"linkOpen\\\",{title:\\\"Open Link\\\",undo:!1,refresh:function(a){var b=this.link.get();b?a.removeClass(\\\"fr-hidden\\\"):a.addClass(\\\"fr-hidden\\\")},callback:function(){var a=this.link.get();a&&this.o_win.open(a.href)}}),a.FE.DefineIcon(\\\"linkEdit\\\",{NAME:\\\"edit\\\"}),a.FE.RegisterCommand(\\\"linkEdit\\\",{title:\\\"Edit Link\\\",undo:!1,refreshAfterCallback:!1,popup:!0,callback:function(){this.link.update()},refresh:function(a){var b=this.link.get();b?a.removeClass(\\\"fr-hidden\\\"):a.addClass(\\\"fr-hidden\\\")}}),a.FE.DefineIcon(\\\"linkRemove\\\",{NAME:\\\"unlink\\\"}),a.FE.RegisterCommand(\\\"linkRemove\\\",{title:\\\"Unlink\\\",callback:function(){this.link.remove()},refresh:function(a){var b=this.link.get();b?a.removeClass(\\\"fr-hidden\\\"):a.addClass(\\\"fr-hidden\\\")}}),a.FE.DefineIcon(\\\"linkBack\\\",{NAME:\\\"arrow-left\\\"}),a.FE.RegisterCommand(\\\"linkBack\\\",{title:\\\"Back\\\",undo:!1,focus:!1,back:!0,refreshAfterCallback:!1,callback:function(){this.link.back()},refresh:function(a){var b=this.link.get()&&this.doc.hasFocus(),c=this.image?this.image.get():null;c||b||this.opts.toolbarInline?(a.removeClass(\\\"fr-hidden\\\"),a.next(\\\".fr-separator\\\").removeClass(\\\"fr-hidden\\\")):(a.addClass(\\\"fr-hidden\\\"),a.next(\\\".fr-separator\\\").addClass(\\\"fr-hidden\\\"))}}),a.FE.DefineIcon(\\\"linkList\\\",{NAME:\\\"search\\\"}),a.FE.RegisterCommand(\\\"linkList\\\",{title:\\\"Choose Link\\\",type:\\\"dropdown\\\",focus:!1,undo:!1,refreshAfterCallback:!1,html:function(){for(var a='<ul class=\\\"fr-dropdown-list\\\" role=\\\"presentation\\\">',b=this.opts.linkList,c=0;c<b.length;c++)a+='<li role=\\\"presentation\\\"><a class=\\\"fr-command\\\" tabIndex=\\\"-1\\\" role=\\\"option\\\" data-cmd=\\\"linkList\\\" data-param1=\\\"'+c+'\\\">'+(b[c].displayText||b[c].text)+\\\"</a></li>\\\";return a+=\\\"</ul>\\\"},callback:function(a,b){this.link.usePredefined(b)}}),a.FE.RegisterCommand(\\\"linkInsert\\\",{focus:!1,refreshAfterCallback:!1,callback:function(){this.link.insertCallback()},refresh:function(a){var b=this.link.get();b?a.text(this.language.translate(\\\"Update\\\")):a.text(this.language.translate(\\\"Insert\\\"))}}),a.FE.DefineIcon(\\\"imageLink\\\",{NAME:\\\"link\\\"}),a.FE.RegisterCommand(\\\"imageLink\\\",{title:\\\"Insert Link\\\",undo:!1,focus:!1,popup:!0,callback:function(){this.link.imageLink()},refresh:function(a){var b,c=this.link.get();c?(b=a.prev(),b.hasClass(\\\"fr-separator\\\")&&b.removeClass(\\\"fr-hidden\\\"),a.addClass(\\\"fr-hidden\\\")):(b=a.prev(),b.hasClass(\\\"fr-separator\\\")&&b.addClass(\\\"fr-hidden\\\"),a.removeClass(\\\"fr-hidden\\\"))}}),a.FE.DefineIcon(\\\"linkStyle\\\",{NAME:\\\"magic\\\"}),a.FE.RegisterCommand(\\\"linkStyle\\\",{title:\\\"Style\\\",type:\\\"dropdown\\\",html:function(){var a='<ul class=\\\"fr-dropdown-list\\\" role=\\\"presentation\\\">',b=this.opts.linkStyles;for(var c in b)b.hasOwnProperty(c)&&(a+='<li role=\\\"presentation\\\"><a class=\\\"fr-command\\\" tabIndex=\\\"-1\\\" role=\\\"option\\\" data-cmd=\\\"linkStyle\\\" data-param1=\\\"'+c+'\\\">'+this.language.translate(b[c])+\\\"</a></li>\\\");return a+=\\\"</ul>\\\"},callback:function(a,b){this.link.applyStyle(b)},refreshOnShow:function(b,c){var d=this.link.get();if(d){var e=a(d);c.find(\\\".fr-command\\\").each(function(){var b=a(this).data(\\\"param1\\\"),c=e.hasClass(b);a(this).toggleClass(\\\"fr-active\\\",c).attr(\\\"aria-selected\\\",c)})}}})});\"//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTcuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2Zyb2FsYS1lZGl0b3IvanMvcGx1Z2lucy9saW5rLm1pbi5qcz81MmY1Il0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gXCIvKiFcXG4gKiBmcm9hbGFfZWRpdG9yIHYyLjUuMSAoaHR0cHM6Ly93d3cuZnJvYWxhLmNvbS93eXNpd3lnLWVkaXRvcilcXG4gKiBMaWNlbnNlIGh0dHBzOi8vZnJvYWxhLmNvbS93eXNpd3lnLWVkaXRvci90ZXJtcy9cXG4gKiBDb3B5cmlnaHQgMjAxNC0yMDE3IEZyb2FsYSBMYWJzXFxuICovXFxuXFxuIWZ1bmN0aW9uKGEpe1xcXCJmdW5jdGlvblxcXCI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQ/ZGVmaW5lKFtcXFwianF1ZXJ5XFxcIl0sYSk6XFxcIm9iamVjdFxcXCI9PXR5cGVvZiBtb2R1bGUmJm1vZHVsZS5leHBvcnRzP21vZHVsZS5leHBvcnRzPWZ1bmN0aW9uKGIsYyl7cmV0dXJuIHZvaWQgMD09PWMmJihjPVxcXCJ1bmRlZmluZWRcXFwiIT10eXBlb2Ygd2luZG93P3JlcXVpcmUoXFxcImpxdWVyeVxcXCIpOnJlcXVpcmUoXFxcImpxdWVyeVxcXCIpKGIpKSxhKGMpfTphKHdpbmRvdy5qUXVlcnkpfShmdW5jdGlvbihhKXthLmV4dGVuZChhLkZFLlBPUFVQX1RFTVBMQVRFUyx7XFxcImxpbmsuZWRpdFxcXCI6XFxcIltfQlVUVE9OU19dXFxcIixcXFwibGluay5pbnNlcnRcXFwiOlxcXCJbX0JVVFRPTlNfXVtfSU5QVVRfTEFZRVJfXVxcXCJ9KSxhLmV4dGVuZChhLkZFLkRFRkFVTFRTLHtsaW5rRWRpdEJ1dHRvbnM6W1xcXCJsaW5rT3BlblxcXCIsXFxcImxpbmtTdHlsZVxcXCIsXFxcImxpbmtFZGl0XFxcIixcXFwibGlua1JlbW92ZVxcXCJdLGxpbmtJbnNlcnRCdXR0b25zOltcXFwibGlua0JhY2tcXFwiLFxcXCJ8XFxcIixcXFwibGlua0xpc3RcXFwiXSxsaW5rQXR0cmlidXRlczp7fSxsaW5rQXV0b1ByZWZpeDpcXFwiaHR0cDovL1xcXCIsbGlua1N0eWxlczp7XFxcImZyLWdyZWVuXFxcIjpcXFwiR3JlZW5cXFwiLFxcXCJmci1zdHJvbmdcXFwiOlxcXCJUaGlja1xcXCJ9LGxpbmtNdWx0aXBsZVN0eWxlczohMCxsaW5rQ29udmVydEVtYWlsQWRkcmVzczohMCxsaW5rQWx3YXlzQmxhbms6ITEsbGlua0Fsd2F5c05vRm9sbG93OiExLGxpbmtMaXN0Olt7dGV4dDpcXFwiRnJvYWxhXFxcIixocmVmOlxcXCJodHRwczovL2Zyb2FsYS5jb21cXFwiLHRhcmdldDpcXFwiX2JsYW5rXFxcIn0se3RleHQ6XFxcIkdvb2dsZVxcXCIsaHJlZjpcXFwiaHR0cHM6Ly9nb29nbGUuY29tXFxcIix0YXJnZXQ6XFxcIl9ibGFua1xcXCJ9LHtkaXNwbGF5VGV4dDpcXFwiRmFjZWJvb2tcXFwiLGhyZWY6XFxcImh0dHBzOi8vZmFjZWJvb2suY29tXFxcIn1dLGxpbmtUZXh0OiEwfSksYS5GRS5QTFVHSU5TLmxpbms9ZnVuY3Rpb24oYil7ZnVuY3Rpb24gYygpe3ZhciBjPWIuaW1hZ2U/Yi5pbWFnZS5nZXQoKTpudWxsO2lmKCFjJiZiLiR3cCl7dmFyIGQ9Yi5zZWxlY3Rpb24ucmFuZ2VzKDApLmNvbW1vbkFuY2VzdG9yQ29udGFpbmVyO2lmKGQmJihkLmNvbnRhaW5zJiZkLmNvbnRhaW5zKGIuZWwpfHwhYi5lbC5jb250YWlucyhkKXx8Yi5lbD09ZCkmJihkPW51bGwpLGQmJlxcXCJBXFxcIj09PWQudGFnTmFtZSlyZXR1cm4gZDt2YXIgZT1iLnNlbGVjdGlvbi5lbGVtZW50KCksZj1iLnNlbGVjdGlvbi5lbmRFbGVtZW50KCk7cmV0dXJuXFxcIkFcXFwiPT1lLnRhZ05hbWV8fGIubm9kZS5pc0VsZW1lbnQoZSl8fChlPWEoZSkucGFyZW50c1VudGlsKGIuJGVsLFxcXCJhOmZpcnN0XFxcIikuZ2V0KDApKSxcXFwiQVxcXCI9PWYudGFnTmFtZXx8Yi5ub2RlLmlzRWxlbWVudChmKXx8KGY9YShmKS5wYXJlbnRzVW50aWwoYi4kZWwsXFxcImE6Zmlyc3RcXFwiKS5nZXQoMCkpLGYmJihmLmNvbnRhaW5zJiZmLmNvbnRhaW5zKGIuZWwpfHwhYi5lbC5jb250YWlucyhmKXx8Yi5lbD09ZikmJihmPW51bGwpLGUmJihlLmNvbnRhaW5zJiZlLmNvbnRhaW5zKGIuZWwpfHwhYi5lbC5jb250YWlucyhlKXx8Yi5lbD09ZSkmJihlPW51bGwpLGYmJmY9PWUmJlxcXCJBXFxcIj09Zi50YWdOYW1lP2U6bnVsbH1yZXR1cm5cXFwiQVxcXCI9PWIuZWwudGFnTmFtZT9iLmVsOmMmJmMuZ2V0KDApLnBhcmVudE5vZGUmJlxcXCJBXFxcIj09Yy5nZXQoMCkucGFyZW50Tm9kZS50YWdOYW1lP2MuZ2V0KDApLnBhcmVudE5vZGU6dm9pZCAwfWZ1bmN0aW9uIGQoKXt2YXIgYT1iLmltYWdlP2IuaW1hZ2UuZ2V0KCk6bnVsbCxjPVtdO2lmKGEpXFxcIkFcXFwiPT1hLmdldCgwKS5wYXJlbnROb2RlLnRhZ05hbWUmJmMucHVzaChhLmdldCgwKS5wYXJlbnROb2RlKTtlbHNle3ZhciBkLGUsZixnO2lmKGIud2luLmdldFNlbGVjdGlvbil7dmFyIGg9Yi53aW4uZ2V0U2VsZWN0aW9uKCk7aWYoaC5nZXRSYW5nZUF0JiZoLnJhbmdlQ291bnQpe2c9Yi5kb2MuY3JlYXRlUmFuZ2UoKTtmb3IodmFyIGk9MDtpPGgucmFuZ2VDb3VudDsrK2kpaWYoZD1oLmdldFJhbmdlQXQoaSksZT1kLmNvbW1vbkFuY2VzdG9yQ29udGFpbmVyLGUmJjEhPWUubm9kZVR5cGUmJihlPWUucGFyZW50Tm9kZSksZSYmXFxcImFcXFwiPT1lLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkpYy5wdXNoKGUpO2Vsc2V7Zj1lLmdldEVsZW1lbnRzQnlUYWdOYW1lKFxcXCJhXFxcIik7Zm9yKHZhciBqPTA7ajxmLmxlbmd0aDsrK2opZy5zZWxlY3ROb2RlQ29udGVudHMoZltqXSksZy5jb21wYXJlQm91bmRhcnlQb2ludHMoZC5FTkRfVE9fU1RBUlQsZCk8MSYmZy5jb21wYXJlQm91bmRhcnlQb2ludHMoZC5TVEFSVF9UT19FTkQsZCk+LTEmJmMucHVzaChmW2pdKX19fWVsc2UgaWYoYi5kb2Muc2VsZWN0aW9uJiZcXFwiQ29udHJvbFxcXCIhPWIuZG9jLnNlbGVjdGlvbi50eXBlKWlmKGQ9Yi5kb2Muc2VsZWN0aW9uLmNyZWF0ZVJhbmdlKCksZT1kLnBhcmVudEVsZW1lbnQoKSxcXFwiYVxcXCI9PWUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSljLnB1c2goZSk7ZWxzZXtmPWUuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXFxcImFcXFwiKSxnPWIuZG9jLmJvZHkuY3JlYXRlVGV4dFJhbmdlKCk7Zm9yKHZhciBrPTA7azxmLmxlbmd0aDsrK2spZy5tb3ZlVG9FbGVtZW50VGV4dChmW2tdKSxnLmNvbXBhcmVFbmRQb2ludHMoXFxcIlN0YXJ0VG9FbmRcXFwiLGQpPi0xJiZnLmNvbXBhcmVFbmRQb2ludHMoXFxcIkVuZFRvU3RhcnRcXFwiLGQpPDEmJmMucHVzaChmW2tdKX19cmV0dXJuIGN9ZnVuY3Rpb24gZShkKXtnKCksc2V0VGltZW91dChmdW5jdGlvbigpe2lmKCFkfHxkJiYoMT09ZC53aGljaHx8XFxcIm1vdXNldXBcXFwiIT1kLnR5cGUpKXt2YXIgZT1jKCksZz1iLmltYWdlP2IuaW1hZ2UuZ2V0KCk6bnVsbDtpZihlJiYhZyl7aWYoYi5pbWFnZSl7dmFyIGg9Yi5ub2RlLmNvbnRlbnRzKGUpO2lmKDE9PWgubGVuZ3RoJiZcXFwiSU1HXFxcIj09aFswXS50YWdOYW1lKXt2YXIgaT1iLnNlbGVjdGlvbi5yYW5nZXMoMCk7cmV0dXJuIDA9PT1pLnN0YXJ0T2Zmc2V0JiYwPT09aS5lbmRPZmZzZXQ/YShlKS5iZWZvcmUoYS5GRS5NQVJLRVJTKTphKGUpLmFmdGVyKGEuRkUuTUFSS0VSUyksYi5zZWxlY3Rpb24ucmVzdG9yZSgpLCExfX1kJiZkLnN0b3BQcm9wYWdhdGlvbigpLGYoZSl9fX0sYi5oZWxwZXJzLmlzSU9TKCk/MTAwOjApfWZ1bmN0aW9uIGYoYyl7dmFyIGQ9Yi5wb3B1cHMuZ2V0KFxcXCJsaW5rLmVkaXRcXFwiKTtkfHwoZD1oKCkpO3ZhciBlPWEoYyk7Yi5wb3B1cHMuaXNWaXNpYmxlKFxcXCJsaW5rLmVkaXRcXFwiKXx8Yi5wb3B1cHMucmVmcmVzaChcXFwibGluay5lZGl0XFxcIiksYi5wb3B1cHMuc2V0Q29udGFpbmVyKFxcXCJsaW5rLmVkaXRcXFwiLGIuJHNjKTt2YXIgZj1lLm9mZnNldCgpLmxlZnQrYShjKS5vdXRlcldpZHRoKCkvMixnPWUub2Zmc2V0KCkudG9wK2Uub3V0ZXJIZWlnaHQoKTtiLnBvcHVwcy5zaG93KFxcXCJsaW5rLmVkaXRcXFwiLGYsZyxlLm91dGVySGVpZ2h0KCkpfWZ1bmN0aW9uIGcoKXtiLnBvcHVwcy5oaWRlKFxcXCJsaW5rLmVkaXRcXFwiKX1mdW5jdGlvbiBoKCl7dmFyIGE9XFxcIlxcXCI7Yi5vcHRzLmxpbmtFZGl0QnV0dG9ucy5sZW5ndGg+MSYmKFxcXCJBXFxcIj09Yi5lbC50YWdOYW1lJiZiLm9wdHMubGlua0VkaXRCdXR0b25zLmluZGV4T2YoXFxcImxpbmtSZW1vdmVcXFwiKT49MCYmYi5vcHRzLmxpbmtFZGl0QnV0dG9ucy5zcGxpY2UoYi5vcHRzLmxpbmtFZGl0QnV0dG9ucy5pbmRleE9mKFxcXCJsaW5rUmVtb3ZlXFxcIiksMSksYT0nPGRpdiBjbGFzcz1cXFwiZnItYnV0dG9uc1xcXCI+JytiLmJ1dHRvbi5idWlsZExpc3QoYi5vcHRzLmxpbmtFZGl0QnV0dG9ucykrXFxcIjwvZGl2PlxcXCIpO3ZhciBkPXtidXR0b25zOmF9LGU9Yi5wb3B1cHMuY3JlYXRlKFxcXCJsaW5rLmVkaXRcXFwiLGQpO3JldHVybiBiLiR3cCYmYi5ldmVudHMuJG9uKGIuJHdwLFxcXCJzY3JvbGwubGluay1lZGl0XFxcIixmdW5jdGlvbigpe2MoKSYmYi5wb3B1cHMuaXNWaXNpYmxlKFxcXCJsaW5rLmVkaXRcXFwiKSYmZihjKCkpfSksZX1mdW5jdGlvbiBpKCl7fWZ1bmN0aW9uIGooKXt2YXIgZD1iLnBvcHVwcy5nZXQoXFxcImxpbmsuaW5zZXJ0XFxcIiksZT1jKCk7aWYoZSl7dmFyIGYsZyxoPWEoZSksaT1kLmZpbmQoJ2lucHV0LmZyLWxpbmstYXR0clt0eXBlPVxcXCJ0ZXh0XFxcIl0nKSxqPWQuZmluZCgnaW5wdXQuZnItbGluay1hdHRyW3R5cGU9XFxcImNoZWNrYm94XFxcIl0nKTtmb3IoZj0wO2Y8aS5sZW5ndGg7ZisrKWc9YShpW2ZdKSxnLnZhbChoLmF0dHIoZy5hdHRyKFxcXCJuYW1lXFxcIil8fFxcXCJcXFwiKSk7Zm9yKGoucHJvcChcXFwiY2hlY2tlZFxcXCIsITEpLGY9MDtmPGoubGVuZ3RoO2YrKylnPWEoaltmXSksaC5hdHRyKGcuYXR0cihcXFwibmFtZVxcXCIpKT09Zy5kYXRhKFxcXCJjaGVja2VkXFxcIikmJmcucHJvcChcXFwiY2hlY2tlZFxcXCIsITApO2QuZmluZCgnaW5wdXQuZnItbGluay1hdHRyW3R5cGU9XFxcInRleHRcXFwiXVtuYW1lPVxcXCJ0ZXh0XFxcIl0nKS52YWwoaC50ZXh0KCkpfWVsc2UgZC5maW5kKCdpbnB1dC5mci1saW5rLWF0dHJbdHlwZT1cXFwidGV4dFxcXCJdJykudmFsKFxcXCJcXFwiKSxkLmZpbmQoJ2lucHV0LmZyLWxpbmstYXR0clt0eXBlPVxcXCJjaGVja2JveFxcXCJdJykucHJvcChcXFwiY2hlY2tlZFxcXCIsITEpLGQuZmluZCgnaW5wdXQuZnItbGluay1hdHRyW3R5cGU9XFxcInRleHRcXFwiXVtuYW1lPVxcXCJ0ZXh0XFxcIl0nKS52YWwoYi5zZWxlY3Rpb24udGV4dCgpKTtkLmZpbmQoXFxcImlucHV0LmZyLWxpbmstYXR0clxcXCIpLnRyaWdnZXIoXFxcImNoYW5nZVxcXCIpO3ZhciBrPWIuaW1hZ2U/Yi5pbWFnZS5nZXQoKTpudWxsO2s/ZC5maW5kKCcuZnItbGluay1hdHRyW25hbWU9XFxcInRleHRcXFwiXScpLnBhcmVudCgpLmhpZGUoKTpkLmZpbmQoJy5mci1saW5rLWF0dHJbbmFtZT1cXFwidGV4dFxcXCJdJykucGFyZW50KCkuc2hvdygpfWZ1bmN0aW9uIGsoKXt2YXIgYT1iLiR0Yi5maW5kKCcuZnItY29tbWFuZFtkYXRhLWNtZD1cXFwiaW5zZXJ0TGlua1xcXCJdJyksYz1iLnBvcHVwcy5nZXQoXFxcImxpbmsuaW5zZXJ0XFxcIik7aWYoY3x8KGM9bCgpKSwhYy5oYXNDbGFzcyhcXFwiZnItYWN0aXZlXFxcIikpaWYoYi5wb3B1cHMucmVmcmVzaChcXFwibGluay5pbnNlcnRcXFwiKSxiLnBvcHVwcy5zZXRDb250YWluZXIoXFxcImxpbmsuaW5zZXJ0XFxcIixiLiR0Ynx8Yi4kc2MpLGEuaXMoXFxcIjp2aXNpYmxlXFxcIikpe3ZhciBkPWEub2Zmc2V0KCkubGVmdCthLm91dGVyV2lkdGgoKS8yLGU9YS5vZmZzZXQoKS50b3ArKGIub3B0cy50b29sYmFyQm90dG9tPzEwOmEub3V0ZXJIZWlnaHQoKS0xMCk7Yi5wb3B1cHMuc2hvdyhcXFwibGluay5pbnNlcnRcXFwiLGQsZSxhLm91dGVySGVpZ2h0KCkpfWVsc2UgYi5wb3NpdGlvbi5mb3JTZWxlY3Rpb24oYyksYi5wb3B1cHMuc2hvdyhcXFwibGluay5pbnNlcnRcXFwiKX1mdW5jdGlvbiBsKGEpe2lmKGEpcmV0dXJuIGIucG9wdXBzLm9uUmVmcmVzaChcXFwibGluay5pbnNlcnRcXFwiLGopLGIucG9wdXBzLm9uSGlkZShcXFwibGluay5pbnNlcnRcXFwiLGkpLCEwO3ZhciBkPVxcXCJcXFwiO2Iub3B0cy5saW5rSW5zZXJ0QnV0dG9ucy5sZW5ndGg+PTEmJihkPSc8ZGl2IGNsYXNzPVxcXCJmci1idXR0b25zXFxcIj4nK2IuYnV0dG9uLmJ1aWxkTGlzdChiLm9wdHMubGlua0luc2VydEJ1dHRvbnMpK1xcXCI8L2Rpdj5cXFwiKTt2YXIgZT0nPHN2ZyB2ZXJzaW9uPVxcXCIxLjFcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCIgeG1sbnM6eGxpbms9XFxcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmtcXFwiIHdpZHRoPVxcXCIxMFxcXCIgaGVpZ2h0PVxcXCIxMFxcXCIgdmlld0JveD1cXFwiMCAwIDMyIDMyXFxcIj48cGF0aCBkPVxcXCJNMjcgNGwtMTUgMTUtNy03LTUgNSAxMiAxMiAyMC0yMHpcXFwiIGZpbGw9XFxcIiNGRkZcXFwiPjwvcGF0aD48L3N2Zz4nLGY9XFxcIlxcXCIsZz0wO2Y9JzxkaXYgY2xhc3M9XFxcImZyLWxpbmstaW5zZXJ0LWxheWVyIGZyLWxheWVyIGZyLWFjdGl2ZVxcXCIgaWQ9XFxcImZyLWxpbmstaW5zZXJ0LWxheWVyLScrYi5pZCsnXFxcIj4nLGYrPSc8ZGl2IGNsYXNzPVxcXCJmci1pbnB1dC1saW5lXFxcIj48aW5wdXQgaWQ9XFxcImZyLWxpbmstaW5zZXJ0LWxheWVyLXVybC0nK2IuaWQrJ1xcXCIgbmFtZT1cXFwiaHJlZlxcXCIgdHlwZT1cXFwidGV4dFxcXCIgY2xhc3M9XFxcImZyLWxpbmstYXR0clxcXCIgcGxhY2Vob2xkZXI9XFxcIlVSTFxcXCIgdGFiSW5kZXg9XFxcIicrICsrZysnXFxcIj48L2Rpdj4nLGIub3B0cy5saW5rVGV4dCYmKGYrPSc8ZGl2IGNsYXNzPVxcXCJmci1pbnB1dC1saW5lXFxcIj48aW5wdXQgaWQ9XFxcImZyLWxpbmstaW5zZXJ0LWxheWVyLXRleHQtJytiLmlkKydcXFwiIG5hbWU9XFxcInRleHRcXFwiIHR5cGU9XFxcInRleHRcXFwiIGNsYXNzPVxcXCJmci1saW5rLWF0dHJcXFwiIHBsYWNlaG9sZGVyPVxcXCInK2IubGFuZ3VhZ2UudHJhbnNsYXRlKFxcXCJUZXh0XFxcIikrJ1xcXCIgdGFiSW5kZXg9XFxcIicrICsrZysnXFxcIj48L2Rpdj4nKTtmb3IodmFyIGggaW4gYi5vcHRzLmxpbmtBdHRyaWJ1dGVzKWlmKGIub3B0cy5saW5rQXR0cmlidXRlcy5oYXNPd25Qcm9wZXJ0eShoKSl7dmFyIGs9Yi5vcHRzLmxpbmtBdHRyaWJ1dGVzW2hdO2YrPSc8ZGl2IGNsYXNzPVxcXCJmci1pbnB1dC1saW5lXFxcIj48aW5wdXQgbmFtZT1cXFwiJytoKydcXFwiIHR5cGU9XFxcInRleHRcXFwiIGNsYXNzPVxcXCJmci1saW5rLWF0dHJcXFwiIHBsYWNlaG9sZGVyPVxcXCInK2IubGFuZ3VhZ2UudHJhbnNsYXRlKGspKydcXFwiIHRhYkluZGV4PVxcXCInKyArK2crJ1xcXCI+PC9kaXY+J31iLm9wdHMubGlua0Fsd2F5c0JsYW5rfHwoZis9JzxkaXYgY2xhc3M9XFxcImZyLWNoZWNrYm94LWxpbmVcXFwiPjxzcGFuIGNsYXNzPVxcXCJmci1jaGVja2JveFxcXCI+PGlucHV0IG5hbWU9XFxcInRhcmdldFxcXCIgY2xhc3M9XFxcImZyLWxpbmstYXR0clxcXCIgZGF0YS1jaGVja2VkPVxcXCJfYmxhbmtcXFwiIHR5cGU9XFxcImNoZWNrYm94XFxcIiBpZD1cXFwiZnItbGluay10YXJnZXQtJytiLmlkKydcXFwiIHRhYkluZGV4PVxcXCInKyArK2crJ1xcXCI+PHNwYW4+JytlKyc8L3NwYW4+PC9zcGFuPjxsYWJlbCBmb3I9XFxcImZyLWxpbmstdGFyZ2V0LScrYi5pZCsnXFxcIj4nK2IubGFuZ3VhZ2UudHJhbnNsYXRlKFxcXCJPcGVuIGluIG5ldyB0YWJcXFwiKStcXFwiPC9sYWJlbD48L2Rpdj5cXFwiKSxmKz0nPGRpdiBjbGFzcz1cXFwiZnItYWN0aW9uLWJ1dHRvbnNcXFwiPjxidXR0b24gY2xhc3M9XFxcImZyLWNvbW1hbmQgZnItc3VibWl0XFxcIiByb2xlPVxcXCJidXR0b25cXFwiIGRhdGEtY21kPVxcXCJsaW5rSW5zZXJ0XFxcIiBocmVmPVxcXCIjXFxcIiB0YWJJbmRleD1cXFwiJysgKytnKydcXFwiIHR5cGU9XFxcImJ1dHRvblxcXCI+JytiLmxhbmd1YWdlLnRyYW5zbGF0ZShcXFwiSW5zZXJ0XFxcIikrXFxcIjwvYnV0dG9uPjwvZGl2PjwvZGl2PlxcXCI7dmFyIGw9e2J1dHRvbnM6ZCxpbnB1dF9sYXllcjpmfSxtPWIucG9wdXBzLmNyZWF0ZShcXFwibGluay5pbnNlcnRcXFwiLGwpO3JldHVybiBiLiR3cCYmYi5ldmVudHMuJG9uKGIuJHdwLFxcXCJzY3JvbGwubGluay1pbnNlcnRcXFwiLGZ1bmN0aW9uKCl7dmFyIGE9Yi5pbWFnZT9iLmltYWdlLmdldCgpOm51bGw7YSYmYi5wb3B1cHMuaXNWaXNpYmxlKFxcXCJsaW5rLmluc2VydFxcXCIpJiZ1KCksYyYmYi5wb3B1cHMuaXNWaXNpYmxlKFxcXCJsaW5rLmluc2VydFxcXCIpJiZzKCl9KSxtfWZ1bmN0aW9uIG0oKXt2YXIgZD1jKCksZT1iLmltYWdlP2IuaW1hZ2UuZ2V0KCk6bnVsbDtyZXR1cm4gYi5ldmVudHMudHJpZ2dlcihcXFwibGluay5iZWZvcmVSZW1vdmVcXFwiLFtkXSkhPT0hMSYmdm9pZChlJiZkPyhlLnVud3JhcCgpLGIuaW1hZ2UuZWRpdChlKSk6ZCYmKGIuc2VsZWN0aW9uLnNhdmUoKSxhKGQpLnJlcGxhY2VXaXRoKGEoZCkuaHRtbCgpKSxiLnNlbGVjdGlvbi5yZXN0b3JlKCksZygpKSl9ZnVuY3Rpb24gbigpe2IuZXZlbnRzLm9uKFxcXCJrZXl1cFxcXCIsZnVuY3Rpb24oYil7Yi53aGljaCE9YS5GRS5LRVlDT0RFLkVTQyYmZShiKX0pLGIuZXZlbnRzLm9uKFxcXCJ3aW5kb3cubW91c2V1cFxcXCIsZSksYi5oZWxwZXJzLmlzTW9iaWxlKCkmJmIuZXZlbnRzLiRvbihiLiRkb2MsXFxcInNlbGVjdGlvbmNoYW5nZVxcXCIsZSksbCghMCksXFxcIkFcXFwiPT1iLmVsLnRhZ05hbWUmJmIuJGVsLmFkZENsYXNzKFxcXCJmci12aWV3XFxcIiksYi5ldmVudHMub24oXFxcInRvb2xiYXIuZXNjXFxcIixmdW5jdGlvbigpe2lmKGIucG9wdXBzLmlzVmlzaWJsZShcXFwibGluay5lZGl0XFxcIikpcmV0dXJuIGIuZXZlbnRzLmRpc2FibGVCbHVyKCksYi5ldmVudHMuZm9jdXMoKSwhMX0sITApfWZ1bmN0aW9uIG8oYyl7dmFyIGQsZSxmPWIub3B0cy5saW5rTGlzdFtjXSxnPWIucG9wdXBzLmdldChcXFwibGluay5pbnNlcnRcXFwiKSxoPWcuZmluZCgnaW5wdXQuZnItbGluay1hdHRyW3R5cGU9XFxcInRleHRcXFwiXScpLGk9Zy5maW5kKCdpbnB1dC5mci1saW5rLWF0dHJbdHlwZT1cXFwiY2hlY2tib3hcXFwiXScpO2ZvcihlPTA7ZTxoLmxlbmd0aDtlKyspZD1hKGhbZV0pLGZbZC5hdHRyKFxcXCJuYW1lXFxcIildP2QudmFsKGZbZC5hdHRyKFxcXCJuYW1lXFxcIildKTpcXFwidGV4dFxcXCIhPWQuYXR0cihcXFwibmFtZVxcXCIpJiZkLnZhbChcXFwiXFxcIik7Zm9yKGU9MDtlPGkubGVuZ3RoO2UrKylkPWEoaVtlXSksZC5wcm9wKFxcXCJjaGVja2VkXFxcIixkLmRhdGEoXFxcImNoZWNrZWRcXFwiKT09ZltkLmF0dHIoXFxcIm5hbWVcXFwiKV0pO2IuYWNjZXNzaWJpbGl0eS5mb2N1c1BvcHVwKGcpfWZ1bmN0aW9uIHAoKXt2YXIgYyxkLGU9Yi5wb3B1cHMuZ2V0KFxcXCJsaW5rLmluc2VydFxcXCIpLGY9ZS5maW5kKCdpbnB1dC5mci1saW5rLWF0dHJbdHlwZT1cXFwidGV4dFxcXCJdJyksZz1lLmZpbmQoJ2lucHV0LmZyLWxpbmstYXR0clt0eXBlPVxcXCJjaGVja2JveFxcXCJdJyksaD1mLmZpbHRlcignW25hbWU9XFxcImhyZWZcXFwiXScpLnZhbCgpLGk9Zi5maWx0ZXIoJ1tuYW1lPVxcXCJ0ZXh0XFxcIl0nKS52YWwoKSxqPXt9O2ZvcihkPTA7ZDxmLmxlbmd0aDtkKyspYz1hKGZbZF0pLFtcXFwiaHJlZlxcXCIsXFxcInRleHRcXFwiXS5pbmRleE9mKGMuYXR0cihcXFwibmFtZVxcXCIpKTwwJiYoaltjLmF0dHIoXFxcIm5hbWVcXFwiKV09Yy52YWwoKSk7Zm9yKGQ9MDtkPGcubGVuZ3RoO2QrKyljPWEoZ1tkXSksYy5pcyhcXFwiOmNoZWNrZWRcXFwiKT9qW2MuYXR0cihcXFwibmFtZVxcXCIpXT1jLmRhdGEoXFxcImNoZWNrZWRcXFwiKTpqW2MuYXR0cihcXFwibmFtZVxcXCIpXT1jLmRhdGEoXFxcInVuY2hlY2tlZFxcXCIpfHxudWxsO3ZhciBrPWIuaGVscGVycy5zY3JvbGxUb3AoKTtyKGgsaSxqKSxhKGIub193aW4pLnNjcm9sbFRvcChrKX1mdW5jdGlvbiBxKCl7aWYoIWIuc2VsZWN0aW9uLmlzQ29sbGFwc2VkKCkpe2Iuc2VsZWN0aW9uLnNhdmUoKTtmb3IodmFyIGM9Yi4kZWwuZmluZChcXFwiLmZyLW1hcmtlclxcXCIpLmFkZENsYXNzKFxcXCJmci11bnByb2Nlc3NlZFxcXCIpLnRvQXJyYXkoKTtjLmxlbmd0aDspe3ZhciBkPWEoYy5wb3AoKSk7ZC5yZW1vdmVDbGFzcyhcXFwiZnItdW5wcm9jZXNzZWRcXFwiKTt2YXIgZT1iLm5vZGUuZGVlcGVzdFBhcmVudChkLmdldCgwKSk7aWYoZSl7dmFyIGY9ZC5nZXQoMCksZz1cXFwiXFxcIixoPVxcXCJcXFwiO2RvIGY9Zi5wYXJlbnROb2RlLGIubm9kZS5pc0Jsb2NrKGYpfHwoZys9Yi5ub2RlLmNsb3NlVGFnU3RyaW5nKGYpLGg9Yi5ub2RlLm9wZW5UYWdTdHJpbmcoZikraCk7d2hpbGUoZiE9ZSk7dmFyIGk9Yi5ub2RlLm9wZW5UYWdTdHJpbmcoZC5nZXQoMCkpK2QuaHRtbCgpK2Iubm9kZS5jbG9zZVRhZ1N0cmluZyhkLmdldCgwKSk7ZC5yZXBsYWNlV2l0aCgnPHNwYW4gaWQ9XFxcImZyLWJyZWFrXFxcIj48L3NwYW4+Jyk7dmFyIGo9YShlKS5odG1sKCk7aj1qLnJlcGxhY2UoLzxzcGFuIGlkPVxcXCJmci1icmVha1xcXCI+PFxcXFwvc3Bhbj4vZyxnK2kraCksYShlKS5odG1sKGopfWM9Yi4kZWwuZmluZChcXFwiLmZyLW1hcmtlci5mci11bnByb2Nlc3NlZFxcXCIpLnRvQXJyYXkoKX1iLnNlbGVjdGlvbi5yZXN0b3JlKCl9fWZ1bmN0aW9uIHIoZixnLGgpe2lmKFxcXCJ1bmRlZmluZWRcXFwiPT10eXBlb2YgaCYmKGg9e30pLGIuZXZlbnRzLnRyaWdnZXIoXFxcImxpbmsuYmVmb3JlSW5zZXJ0XFxcIixbZixnLGhdKT09PSExKXJldHVybiExO3ZhciBpPWIuaW1hZ2U/Yi5pbWFnZS5nZXQoKTpudWxsO2l8fFxcXCJBXFxcIj09Yi5lbC50YWdOYW1lP1xcXCJBXFxcIj09Yi5lbC50YWdOYW1lJiZiLiRlbC5mb2N1cygpOihiLnNlbGVjdGlvbi5yZXN0b3JlKCksYi5wb3B1cHMuaGlkZShcXFwibGluay5pbnNlcnRcXFwiKSk7dmFyIGo9ZjtpZihiLm9wdHMubGlua0NvbnZlcnRFbWFpbEFkZHJlc3Mpe3ZhciBrPS9eW1xcXFx3Ll9dK0BbYS16XFxcXHUwMGExLVxcXFx1ZmZmZjAtOV8tXSs/XFxcXC5bYS16XFxcXHUwMGExLVxcXFx1ZmZmZjAtOV17Mix9JC9pO2sudGVzdChmKSYmIS9ebWFpbHRvOi4qL2kudGVzdChmKSYmKGY9XFxcIm1haWx0bzpcXFwiK2YpfWlmKFxcXCJcXFwiPT09Yi5vcHRzLmxpbmtBdXRvUHJlZml4fHwvXihtYWlsdG98dGVsfHNtc3xub3Rlc3xkYXRhKTouKi9pLnRlc3QoZil8fC9eZGF0YTppbWFnZS4qL2kudGVzdChmKXx8L14oaHR0cHM/OnxmdHBzPzp8ZmlsZTp8KVxcXFwvXFxcXC8vaS50ZXN0KGYpfHxbXFxcIi9cXFwiLFxcXCJ7XFxcIixcXFwiW1xcXCIsXFxcIiNcXFwiLFxcXCIoXFxcIl0uaW5kZXhPZigoZnx8XFxcIlxcXCIpWzBdKTwwJiYoZj1iLm9wdHMubGlua0F1dG9QcmVmaXgrZiksZj1iLmhlbHBlcnMuc2FuaXRpemVVUkwoZiksYi5vcHRzLmxpbmtBbHdheXNCbGFuayYmKGgudGFyZ2V0PVxcXCJfYmxhbmtcXFwiKSxiLm9wdHMubGlua0Fsd2F5c05vRm9sbG93JiYoaC5yZWw9XFxcIm5vZm9sbG93XFxcIiksXFxcIl9ibGFua1xcXCI9PWgudGFyZ2V0JiYoaC5yZWw/aC5yZWwrPVxcXCIgbm9vcGVuZXIgbm9yZWZlcnJlclxcXCI6aC5yZWw9XFxcIm5vb3BlbmVyIG5vcmVmZXJyZXJcXFwiKSxnPWd8fFxcXCJcXFwiLGY9PT1iLm9wdHMubGlua0F1dG9QcmVmaXgpe3ZhciBsPWIucG9wdXBzLmdldChcXFwibGluay5pbnNlcnRcXFwiKTtyZXR1cm4gbC5maW5kKCdpbnB1dFtuYW1lPVxcXCJocmVmXFxcIl0nKS5hZGRDbGFzcyhcXFwiZnItZXJyb3JcXFwiKSxiLmV2ZW50cy50cmlnZ2VyKFxcXCJsaW5rLmJhZFxcXCIsW2pdKSwhMX12YXIgbSxuPWMoKTtpZihuKW09YShuKSxtLmF0dHIoXFxcImhyZWZcXFwiLGYpLGcubGVuZ3RoPjAmJm0udGV4dCgpIT1nJiYhaSYmbS50ZXh0KGcpLGl8fG0ucHJlcGVuZChhLkZFLlNUQVJUX01BUktFUikuYXBwZW5kKGEuRkUuRU5EX01BUktFUiksbS5hdHRyKGgpLGl8fGIuc2VsZWN0aW9uLnJlc3RvcmUoKTtlbHNle2k/aS53cmFwKCc8YSBocmVmPVxcXCInK2YrJ1xcXCI+PC9hPicpOihiLmZvcm1hdC5yZW1vdmUoXFxcImFcXFwiKSxiLnNlbGVjdGlvbi5pc0NvbGxhcHNlZCgpPyhnPTA9PT1nLmxlbmd0aD9qOmcsYi5odG1sLmluc2VydCgnPGEgaHJlZj1cXFwiJytmKydcXFwiPicrYS5GRS5TVEFSVF9NQVJLRVIrZythLkZFLkVORF9NQVJLRVIrXFxcIjwvYT5cXFwiKSxiLnNlbGVjdGlvbi5yZXN0b3JlKCkpOmcubGVuZ3RoPjAmJmchPWIuc2VsZWN0aW9uLnRleHQoKS5yZXBsYWNlKC9cXFxcbi9nLFxcXCJcXFwiKT8oYi5zZWxlY3Rpb24ucmVtb3ZlKCksYi5odG1sLmluc2VydCgnPGEgaHJlZj1cXFwiJytmKydcXFwiPicrYS5GRS5TVEFSVF9NQVJLRVIrZythLkZFLkVORF9NQVJLRVIrXFxcIjwvYT5cXFwiKSxiLnNlbGVjdGlvbi5yZXN0b3JlKCkpOihxKCksYi5mb3JtYXQuYXBwbHkoXFxcImFcXFwiLHtocmVmOmZ9KSkpO2Zvcih2YXIgbz1kKCkscD0wO3A8by5sZW5ndGg7cCsrKW09YShvW3BdKSxtLmF0dHIoaCksbS5yZW1vdmVBdHRyKFxcXCJfbW96X2RpcnR5XFxcIik7MT09by5sZW5ndGgmJmIuJHdwJiYhaSYmKGEob1swXSkucHJlcGVuZChhLkZFLlNUQVJUX01BUktFUikuYXBwZW5kKGEuRkUuRU5EX01BUktFUiksYi5zZWxlY3Rpb24ucmVzdG9yZSgpKX1pZihpKXt2YXIgcj1iLnBvcHVwcy5nZXQoXFxcImxpbmsuaW5zZXJ0XFxcIik7ci5maW5kKFxcXCJpbnB1dDpmb2N1c1xcXCIpLmJsdXIoKSxiLmltYWdlLmVkaXQoaSl9ZWxzZSBlKCl9ZnVuY3Rpb24gcygpe2coKTt2YXIgZD1jKCk7aWYoZCl7dmFyIGU9Yi5wb3B1cHMuZ2V0KFxcXCJsaW5rLmluc2VydFxcXCIpO2V8fChlPWwoKSksYi5wb3B1cHMuaXNWaXNpYmxlKFxcXCJsaW5rLmluc2VydFxcXCIpfHwoYi5wb3B1cHMucmVmcmVzaChcXFwibGluay5pbnNlcnRcXFwiKSxiLnNlbGVjdGlvbi5zYXZlKCksYi5oZWxwZXJzLmlzTW9iaWxlKCkmJihiLmV2ZW50cy5kaXNhYmxlQmx1cigpLGIuJGVsLmJsdXIoKSxiLmV2ZW50cy5lbmFibGVCbHVyKCkpKSxiLnBvcHVwcy5zZXRDb250YWluZXIoXFxcImxpbmsuaW5zZXJ0XFxcIixiLiRzYyk7dmFyIGY9KGIuaW1hZ2U/Yi5pbWFnZS5nZXQoKTpudWxsKXx8YShkKSxoPWYub2Zmc2V0KCkubGVmdCtmLm91dGVyV2lkdGgoKS8yLGk9Zi5vZmZzZXQoKS50b3ArZi5vdXRlckhlaWdodCgpO2IucG9wdXBzLnNob3coXFxcImxpbmsuaW5zZXJ0XFxcIixoLGksZi5vdXRlckhlaWdodCgpKX19ZnVuY3Rpb24gdCgpe3ZhciBhPWIuaW1hZ2U/Yi5pbWFnZS5nZXQoKTpudWxsO2lmKGEpYi5pbWFnZS5iYWNrKCk7ZWxzZXtiLmV2ZW50cy5kaXNhYmxlQmx1cigpLGIuc2VsZWN0aW9uLnJlc3RvcmUoKSxiLmV2ZW50cy5lbmFibGVCbHVyKCk7dmFyIGQ9YygpO2QmJmIuJHdwPyhiLnNlbGVjdGlvbi5yZXN0b3JlKCksZygpLGUoKSk6XFxcIkFcXFwiPT1iLmVsLnRhZ05hbWU/KGIuJGVsLmZvY3VzKCksZSgpKTooYi5wb3B1cHMuaGlkZShcXFwibGluay5pbnNlcnRcXFwiKSxiLnRvb2xiYXIuc2hvd0lubGluZSgpKX19ZnVuY3Rpb24gdSgpe3ZhciBhPWIuaW1hZ2U/Yi5pbWFnZS5nZXQoKTpudWxsO2lmKGEpe3ZhciBjPWIucG9wdXBzLmdldChcXFwibGluay5pbnNlcnRcXFwiKTtjfHwoYz1sKCkpLGooITApLGIucG9wdXBzLnNldENvbnRhaW5lcihcXFwibGluay5pbnNlcnRcXFwiLGIuJHNjKTt2YXIgZD1hLm9mZnNldCgpLmxlZnQrYS5vdXRlcldpZHRoKCkvMixlPWEub2Zmc2V0KCkudG9wK2Eub3V0ZXJIZWlnaHQoKTtiLnBvcHVwcy5zaG93KFxcXCJsaW5rLmluc2VydFxcXCIsZCxlLGEub3V0ZXJIZWlnaHQoKSl9fWZ1bmN0aW9uIHYoZCxmLGcpe1xcXCJ1bmRlZmluZWRcXFwiPT10eXBlb2YgZyYmKGc9Yi5vcHRzLmxpbmtNdWx0aXBsZVN0eWxlcyksXFxcInVuZGVmaW5lZFxcXCI9PXR5cGVvZiBmJiYoZj1iLm9wdHMubGlua1N0eWxlcyk7dmFyIGg9YygpO2lmKCFoKXJldHVybiExO2lmKCFnKXt2YXIgaT1PYmplY3Qua2V5cyhmKTtpLnNwbGljZShpLmluZGV4T2YoZCksMSksYShoKS5yZW1vdmVDbGFzcyhpLmpvaW4oXFxcIiBcXFwiKSl9YShoKS50b2dnbGVDbGFzcyhkKSxlKCl9cmV0dXJue19pbml0Om4scmVtb3ZlOm0sc2hvd0luc2VydFBvcHVwOmssdXNlUHJlZGVmaW5lZDpvLGluc2VydENhbGxiYWNrOnAsaW5zZXJ0OnIsdXBkYXRlOnMsZ2V0OmMsYWxsU2VsZWN0ZWQ6ZCxiYWNrOnQsaW1hZ2VMaW5rOnUsYXBwbHlTdHlsZTp2fX0sYS5GRS5EZWZpbmVJY29uKFxcXCJpbnNlcnRMaW5rXFxcIix7TkFNRTpcXFwibGlua1xcXCJ9KSxhLkZFLlJlZ2lzdGVyU2hvcnRjdXQoYS5GRS5LRVlDT0RFLkssXFxcImluc2VydExpbmtcXFwiLG51bGwsXFxcIktcXFwiKSxhLkZFLlJlZ2lzdGVyQ29tbWFuZChcXFwiaW5zZXJ0TGlua1xcXCIse3RpdGxlOlxcXCJJbnNlcnQgTGlua1xcXCIsdW5kbzohMSxmb2N1czohMCxyZWZyZXNoT25DYWxsYmFjazohMSxwb3B1cDohMCxjYWxsYmFjazpmdW5jdGlvbigpe3RoaXMucG9wdXBzLmlzVmlzaWJsZShcXFwibGluay5pbnNlcnRcXFwiKT8odGhpcy4kZWwuZmluZChcXFwiLmZyLW1hcmtlclxcXCIpLmxlbmd0aCYmKHRoaXMuZXZlbnRzLmRpc2FibGVCbHVyKCksdGhpcy5zZWxlY3Rpb24ucmVzdG9yZSgpKSx0aGlzLnBvcHVwcy5oaWRlKFxcXCJsaW5rLmluc2VydFxcXCIpKTp0aGlzLmxpbmsuc2hvd0luc2VydFBvcHVwKCl9LHBsdWdpbjpcXFwibGlua1xcXCJ9KSxhLkZFLkRlZmluZUljb24oXFxcImxpbmtPcGVuXFxcIix7TkFNRTpcXFwiZXh0ZXJuYWwtbGlua1xcXCJ9KSxhLkZFLlJlZ2lzdGVyQ29tbWFuZChcXFwibGlua09wZW5cXFwiLHt0aXRsZTpcXFwiT3BlbiBMaW5rXFxcIix1bmRvOiExLHJlZnJlc2g6ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5saW5rLmdldCgpO2I/YS5yZW1vdmVDbGFzcyhcXFwiZnItaGlkZGVuXFxcIik6YS5hZGRDbGFzcyhcXFwiZnItaGlkZGVuXFxcIil9LGNhbGxiYWNrOmZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5saW5rLmdldCgpO2EmJnRoaXMub193aW4ub3BlbihhLmhyZWYpfX0pLGEuRkUuRGVmaW5lSWNvbihcXFwibGlua0VkaXRcXFwiLHtOQU1FOlxcXCJlZGl0XFxcIn0pLGEuRkUuUmVnaXN0ZXJDb21tYW5kKFxcXCJsaW5rRWRpdFxcXCIse3RpdGxlOlxcXCJFZGl0IExpbmtcXFwiLHVuZG86ITEscmVmcmVzaEFmdGVyQ2FsbGJhY2s6ITEscG9wdXA6ITAsY2FsbGJhY2s6ZnVuY3Rpb24oKXt0aGlzLmxpbmsudXBkYXRlKCl9LHJlZnJlc2g6ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5saW5rLmdldCgpO2I/YS5yZW1vdmVDbGFzcyhcXFwiZnItaGlkZGVuXFxcIik6YS5hZGRDbGFzcyhcXFwiZnItaGlkZGVuXFxcIil9fSksYS5GRS5EZWZpbmVJY29uKFxcXCJsaW5rUmVtb3ZlXFxcIix7TkFNRTpcXFwidW5saW5rXFxcIn0pLGEuRkUuUmVnaXN0ZXJDb21tYW5kKFxcXCJsaW5rUmVtb3ZlXFxcIix7dGl0bGU6XFxcIlVubGlua1xcXCIsY2FsbGJhY2s6ZnVuY3Rpb24oKXt0aGlzLmxpbmsucmVtb3ZlKCl9LHJlZnJlc2g6ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5saW5rLmdldCgpO2I/YS5yZW1vdmVDbGFzcyhcXFwiZnItaGlkZGVuXFxcIik6YS5hZGRDbGFzcyhcXFwiZnItaGlkZGVuXFxcIil9fSksYS5GRS5EZWZpbmVJY29uKFxcXCJsaW5rQmFja1xcXCIse05BTUU6XFxcImFycm93LWxlZnRcXFwifSksYS5GRS5SZWdpc3RlckNvbW1hbmQoXFxcImxpbmtCYWNrXFxcIix7dGl0bGU6XFxcIkJhY2tcXFwiLHVuZG86ITEsZm9jdXM6ITEsYmFjazohMCxyZWZyZXNoQWZ0ZXJDYWxsYmFjazohMSxjYWxsYmFjazpmdW5jdGlvbigpe3RoaXMubGluay5iYWNrKCl9LHJlZnJlc2g6ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5saW5rLmdldCgpJiZ0aGlzLmRvYy5oYXNGb2N1cygpLGM9dGhpcy5pbWFnZT90aGlzLmltYWdlLmdldCgpOm51bGw7Y3x8Ynx8dGhpcy5vcHRzLnRvb2xiYXJJbmxpbmU/KGEucmVtb3ZlQ2xhc3MoXFxcImZyLWhpZGRlblxcXCIpLGEubmV4dChcXFwiLmZyLXNlcGFyYXRvclxcXCIpLnJlbW92ZUNsYXNzKFxcXCJmci1oaWRkZW5cXFwiKSk6KGEuYWRkQ2xhc3MoXFxcImZyLWhpZGRlblxcXCIpLGEubmV4dChcXFwiLmZyLXNlcGFyYXRvclxcXCIpLmFkZENsYXNzKFxcXCJmci1oaWRkZW5cXFwiKSl9fSksYS5GRS5EZWZpbmVJY29uKFxcXCJsaW5rTGlzdFxcXCIse05BTUU6XFxcInNlYXJjaFxcXCJ9KSxhLkZFLlJlZ2lzdGVyQ29tbWFuZChcXFwibGlua0xpc3RcXFwiLHt0aXRsZTpcXFwiQ2hvb3NlIExpbmtcXFwiLHR5cGU6XFxcImRyb3Bkb3duXFxcIixmb2N1czohMSx1bmRvOiExLHJlZnJlc2hBZnRlckNhbGxiYWNrOiExLGh0bWw6ZnVuY3Rpb24oKXtmb3IodmFyIGE9Jzx1bCBjbGFzcz1cXFwiZnItZHJvcGRvd24tbGlzdFxcXCIgcm9sZT1cXFwicHJlc2VudGF0aW9uXFxcIj4nLGI9dGhpcy5vcHRzLmxpbmtMaXN0LGM9MDtjPGIubGVuZ3RoO2MrKylhKz0nPGxpIHJvbGU9XFxcInByZXNlbnRhdGlvblxcXCI+PGEgY2xhc3M9XFxcImZyLWNvbW1hbmRcXFwiIHRhYkluZGV4PVxcXCItMVxcXCIgcm9sZT1cXFwib3B0aW9uXFxcIiBkYXRhLWNtZD1cXFwibGlua0xpc3RcXFwiIGRhdGEtcGFyYW0xPVxcXCInK2MrJ1xcXCI+JysoYltjXS5kaXNwbGF5VGV4dHx8YltjXS50ZXh0KStcXFwiPC9hPjwvbGk+XFxcIjtyZXR1cm4gYSs9XFxcIjwvdWw+XFxcIn0sY2FsbGJhY2s6ZnVuY3Rpb24oYSxiKXt0aGlzLmxpbmsudXNlUHJlZGVmaW5lZChiKX19KSxhLkZFLlJlZ2lzdGVyQ29tbWFuZChcXFwibGlua0luc2VydFxcXCIse2ZvY3VzOiExLHJlZnJlc2hBZnRlckNhbGxiYWNrOiExLGNhbGxiYWNrOmZ1bmN0aW9uKCl7dGhpcy5saW5rLmluc2VydENhbGxiYWNrKCl9LHJlZnJlc2g6ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5saW5rLmdldCgpO2I/YS50ZXh0KHRoaXMubGFuZ3VhZ2UudHJhbnNsYXRlKFxcXCJVcGRhdGVcXFwiKSk6YS50ZXh0KHRoaXMubGFuZ3VhZ2UudHJhbnNsYXRlKFxcXCJJbnNlcnRcXFwiKSl9fSksYS5GRS5EZWZpbmVJY29uKFxcXCJpbWFnZUxpbmtcXFwiLHtOQU1FOlxcXCJsaW5rXFxcIn0pLGEuRkUuUmVnaXN0ZXJDb21tYW5kKFxcXCJpbWFnZUxpbmtcXFwiLHt0aXRsZTpcXFwiSW5zZXJ0IExpbmtcXFwiLHVuZG86ITEsZm9jdXM6ITEscG9wdXA6ITAsY2FsbGJhY2s6ZnVuY3Rpb24oKXt0aGlzLmxpbmsuaW1hZ2VMaW5rKCl9LHJlZnJlc2g6ZnVuY3Rpb24oYSl7dmFyIGIsYz10aGlzLmxpbmsuZ2V0KCk7Yz8oYj1hLnByZXYoKSxiLmhhc0NsYXNzKFxcXCJmci1zZXBhcmF0b3JcXFwiKSYmYi5yZW1vdmVDbGFzcyhcXFwiZnItaGlkZGVuXFxcIiksYS5hZGRDbGFzcyhcXFwiZnItaGlkZGVuXFxcIikpOihiPWEucHJldigpLGIuaGFzQ2xhc3MoXFxcImZyLXNlcGFyYXRvclxcXCIpJiZiLmFkZENsYXNzKFxcXCJmci1oaWRkZW5cXFwiKSxhLnJlbW92ZUNsYXNzKFxcXCJmci1oaWRkZW5cXFwiKSl9fSksYS5GRS5EZWZpbmVJY29uKFxcXCJsaW5rU3R5bGVcXFwiLHtOQU1FOlxcXCJtYWdpY1xcXCJ9KSxhLkZFLlJlZ2lzdGVyQ29tbWFuZChcXFwibGlua1N0eWxlXFxcIix7dGl0bGU6XFxcIlN0eWxlXFxcIix0eXBlOlxcXCJkcm9wZG93blxcXCIsaHRtbDpmdW5jdGlvbigpe3ZhciBhPSc8dWwgY2xhc3M9XFxcImZyLWRyb3Bkb3duLWxpc3RcXFwiIHJvbGU9XFxcInByZXNlbnRhdGlvblxcXCI+JyxiPXRoaXMub3B0cy5saW5rU3R5bGVzO2Zvcih2YXIgYyBpbiBiKWIuaGFzT3duUHJvcGVydHkoYykmJihhKz0nPGxpIHJvbGU9XFxcInByZXNlbnRhdGlvblxcXCI+PGEgY2xhc3M9XFxcImZyLWNvbW1hbmRcXFwiIHRhYkluZGV4PVxcXCItMVxcXCIgcm9sZT1cXFwib3B0aW9uXFxcIiBkYXRhLWNtZD1cXFwibGlua1N0eWxlXFxcIiBkYXRhLXBhcmFtMT1cXFwiJytjKydcXFwiPicrdGhpcy5sYW5ndWFnZS50cmFuc2xhdGUoYltjXSkrXFxcIjwvYT48L2xpPlxcXCIpO3JldHVybiBhKz1cXFwiPC91bD5cXFwifSxjYWxsYmFjazpmdW5jdGlvbihhLGIpe3RoaXMubGluay5hcHBseVN0eWxlKGIpfSxyZWZyZXNoT25TaG93OmZ1bmN0aW9uKGIsYyl7dmFyIGQ9dGhpcy5saW5rLmdldCgpO2lmKGQpe3ZhciBlPWEoZCk7Yy5maW5kKFxcXCIuZnItY29tbWFuZFxcXCIpLmVhY2goZnVuY3Rpb24oKXt2YXIgYj1hKHRoaXMpLmRhdGEoXFxcInBhcmFtMVxcXCIpLGM9ZS5oYXNDbGFzcyhiKTthKHRoaXMpLnRvZ2dsZUNsYXNzKFxcXCJmci1hY3RpdmVcXFwiLGMpLmF0dHIoXFxcImFyaWEtc2VsZWN0ZWRcXFwiLGMpfSl9fX0pfSk7XCJcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcmF3LWxvYWRlciEuL34vZnJvYWxhLWVkaXRvci9qcy9wbHVnaW5zL2xpbmsubWluLmpzXG4vLyBtb2R1bGUgaWQgPSAxN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

	eval("__webpack_require__(2)(__webpack_require__(19))//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTguanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2Zyb2FsYS1lZGl0b3IvanMvcGx1Z2lucy91cmwubWluLmpzPzY2NWYiXSwic291cmNlc0NvbnRlbnQiOlsicmVxdWlyZShcIiEhL3Zhci9hcHAvd2ViL2pzL25vZGVfbW9kdWxlcy9zY3JpcHQtbG9hZGVyL2FkZFNjcmlwdC5qc1wiKShyZXF1aXJlKFwiISEvdmFyL2FwcC93ZWIvanMvbm9kZV9tb2R1bGVzL3Jhdy1sb2FkZXIvaW5kZXguanMhL3Zhci9hcHAvd2ViL2pzL25vZGVfbW9kdWxlcy9mcm9hbGEtZWRpdG9yL2pzL3BsdWdpbnMvdXJsLm1pbi5qc1wiKSlcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vc2NyaXB0LWxvYWRlciEuL34vZnJvYWxhLWVkaXRvci9qcy9wbHVnaW5zL3VybC5taW4uanNcbi8vIG1vZHVsZSBpZCA9IDE4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 19 */
/***/ function(module, exports) {

	eval("module.exports = \"/*!\\n * froala_editor v2.5.1 (https://www.froala.com/wysiwyg-editor)\\n * License https://froala.com/wysiwyg-editor/terms/\\n * Copyright 2014-2017 Froala Labs\\n */\\n\\n!function(a){\\\"function\\\"==typeof define&&define.amd?define([\\\"jquery\\\"],a):\\\"object\\\"==typeof module&&module.exports?module.exports=function(b,c){return void 0===c&&(c=\\\"undefined\\\"!=typeof window?require(\\\"jquery\\\"):require(\\\"jquery\\\")(b)),a(c)}:a(window.jQuery)}(function(a){a.extend(a.FE.DEFAULTS,{}),a.FE.URLRegEx=\\\"(\\\\\\\\s|^|>)(((http|https|ftp|ftps)\\\\\\\\:\\\\\\\\/\\\\\\\\/)?[a-zA-Z0-9\\\\\\\\-\\\\\\\\.]+(\\\\\\\\.[a-zA-Z]{2,3})(:\\\\\\\\d*)?(\\\\\\\\/[^\\\\\\\\s<]*)?)(\\\\\\\\s|$|<)\\\",a.FE.PLUGINS.url=function(b){function c(a){for(;a.parentNode;)if(a=a.parentNode,[\\\"A\\\",\\\"BUTTON\\\",\\\"TEXTAREA\\\"].indexOf(a.tagName)>=0)return!0;return!1}function d(){for(var d,e=b.doc.createTreeWalker(b.el,NodeFilter.SHOW_TEXT,b.node.filter(function(b){return new RegExp(a.FE.URLRegEx,\\\"gi\\\").test(b.textContent.replace(/&nbsp;/gi,\\\" \\\"))&&!c(b)}),!1),f=[];e.nextNode();)d=e.currentNode,f.push(d);for(var g=0;g<f.length;g++){d=f[g];var h=null;b.opts.linkAlwaysNoFollow&&(h=\\\"nofollow\\\"),b.opts.linkAlwaysBlank&&(h?h+=\\\" noopener noreferrer\\\":h=\\\"noopener noreferrer\\\"),a(d).before(d.textContent.replace(new RegExp(a.FE.URLRegEx,\\\"gi\\\"),\\\"$1<a\\\"+(b.opts.linkAlwaysBlank?' target=\\\"_blank\\\"':\\\"\\\")+(h?' rel=\\\"'+h+'\\\"':\\\"\\\")+' href=\\\"$2\\\">$2</a>$8')),d.parentNode.removeChild(d)}}function e(){b.events.on(\\\"paste.afterCleanup\\\",function(c){if(new RegExp(a.FE.URLRegEx,\\\"gi\\\").test(c))return c.replace(new RegExp(a.FE.URLRegEx,\\\"gi\\\"),\\\"$1<a\\\"+(b.opts.linkAlwaysBlank?' target=\\\"_blank\\\"':\\\"\\\")+(b.opts.linkAlwaysNoFollow?' rel=\\\"nofollow\\\"':\\\"\\\")+' href=\\\"$2\\\">$2</a>$8')}),b.events.on(\\\"keyup\\\",function(c){var e=c.which;e!=a.FE.KEYCODE.ENTER&&e!=a.FE.KEYCODE.SPACE||d(b.node.contents(b.el))},!0),b.events.on(\\\"keydown\\\",function(c){var d=c.which;if(d==a.FE.KEYCODE.ENTER){var e=b.selection.element();if((\\\"A\\\"==e.tagName||a(e).parents(\\\"a\\\").length)&&b.selection.info(e).atEnd)return c.stopImmediatePropagation(),\\\"A\\\"!==e.tagName&&(e=a(e).parents(\\\"a\\\")[0]),a(e).after(\\\"&nbsp;\\\"+a.FE.MARKERS),b.selection.restore(),!1}})}return{_init:e}}});\"//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTkuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2Zyb2FsYS1lZGl0b3IvanMvcGx1Z2lucy91cmwubWluLmpzP2E1NmIiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBcIi8qIVxcbiAqIGZyb2FsYV9lZGl0b3IgdjIuNS4xIChodHRwczovL3d3dy5mcm9hbGEuY29tL3d5c2l3eWctZWRpdG9yKVxcbiAqIExpY2Vuc2UgaHR0cHM6Ly9mcm9hbGEuY29tL3d5c2l3eWctZWRpdG9yL3Rlcm1zL1xcbiAqIENvcHlyaWdodCAyMDE0LTIwMTcgRnJvYWxhIExhYnNcXG4gKi9cXG5cXG4hZnVuY3Rpb24oYSl7XFxcImZ1bmN0aW9uXFxcIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUoW1xcXCJqcXVlcnlcXFwiXSxhKTpcXFwib2JqZWN0XFxcIj09dHlwZW9mIG1vZHVsZSYmbW9kdWxlLmV4cG9ydHM/bW9kdWxlLmV4cG9ydHM9ZnVuY3Rpb24oYixjKXtyZXR1cm4gdm9pZCAwPT09YyYmKGM9XFxcInVuZGVmaW5lZFxcXCIhPXR5cGVvZiB3aW5kb3c/cmVxdWlyZShcXFwianF1ZXJ5XFxcIik6cmVxdWlyZShcXFwianF1ZXJ5XFxcIikoYikpLGEoYyl9OmEod2luZG93LmpRdWVyeSl9KGZ1bmN0aW9uKGEpe2EuZXh0ZW5kKGEuRkUuREVGQVVMVFMse30pLGEuRkUuVVJMUmVnRXg9XFxcIihcXFxcXFxcXHN8Xnw+KSgoKGh0dHB8aHR0cHN8ZnRwfGZ0cHMpXFxcXFxcXFw6XFxcXFxcXFwvXFxcXFxcXFwvKT9bYS16QS1aMC05XFxcXFxcXFwtXFxcXFxcXFwuXSsoXFxcXFxcXFwuW2EtekEtWl17MiwzfSkoOlxcXFxcXFxcZCopPyhcXFxcXFxcXC9bXlxcXFxcXFxcczxdKik/KShcXFxcXFxcXHN8JHw8KVxcXCIsYS5GRS5QTFVHSU5TLnVybD1mdW5jdGlvbihiKXtmdW5jdGlvbiBjKGEpe2Zvcig7YS5wYXJlbnROb2RlOylpZihhPWEucGFyZW50Tm9kZSxbXFxcIkFcXFwiLFxcXCJCVVRUT05cXFwiLFxcXCJURVhUQVJFQVxcXCJdLmluZGV4T2YoYS50YWdOYW1lKT49MClyZXR1cm4hMDtyZXR1cm4hMX1mdW5jdGlvbiBkKCl7Zm9yKHZhciBkLGU9Yi5kb2MuY3JlYXRlVHJlZVdhbGtlcihiLmVsLE5vZGVGaWx0ZXIuU0hPV19URVhULGIubm9kZS5maWx0ZXIoZnVuY3Rpb24oYil7cmV0dXJuIG5ldyBSZWdFeHAoYS5GRS5VUkxSZWdFeCxcXFwiZ2lcXFwiKS50ZXN0KGIudGV4dENvbnRlbnQucmVwbGFjZSgvJm5ic3A7L2dpLFxcXCIgXFxcIikpJiYhYyhiKX0pLCExKSxmPVtdO2UubmV4dE5vZGUoKTspZD1lLmN1cnJlbnROb2RlLGYucHVzaChkKTtmb3IodmFyIGc9MDtnPGYubGVuZ3RoO2crKyl7ZD1mW2ddO3ZhciBoPW51bGw7Yi5vcHRzLmxpbmtBbHdheXNOb0ZvbGxvdyYmKGg9XFxcIm5vZm9sbG93XFxcIiksYi5vcHRzLmxpbmtBbHdheXNCbGFuayYmKGg/aCs9XFxcIiBub29wZW5lciBub3JlZmVycmVyXFxcIjpoPVxcXCJub29wZW5lciBub3JlZmVycmVyXFxcIiksYShkKS5iZWZvcmUoZC50ZXh0Q29udGVudC5yZXBsYWNlKG5ldyBSZWdFeHAoYS5GRS5VUkxSZWdFeCxcXFwiZ2lcXFwiKSxcXFwiJDE8YVxcXCIrKGIub3B0cy5saW5rQWx3YXlzQmxhbms/JyB0YXJnZXQ9XFxcIl9ibGFua1xcXCInOlxcXCJcXFwiKSsoaD8nIHJlbD1cXFwiJytoKydcXFwiJzpcXFwiXFxcIikrJyBocmVmPVxcXCIkMlxcXCI+JDI8L2E+JDgnKSksZC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGQpfX1mdW5jdGlvbiBlKCl7Yi5ldmVudHMub24oXFxcInBhc3RlLmFmdGVyQ2xlYW51cFxcXCIsZnVuY3Rpb24oYyl7aWYobmV3IFJlZ0V4cChhLkZFLlVSTFJlZ0V4LFxcXCJnaVxcXCIpLnRlc3QoYykpcmV0dXJuIGMucmVwbGFjZShuZXcgUmVnRXhwKGEuRkUuVVJMUmVnRXgsXFxcImdpXFxcIiksXFxcIiQxPGFcXFwiKyhiLm9wdHMubGlua0Fsd2F5c0JsYW5rPycgdGFyZ2V0PVxcXCJfYmxhbmtcXFwiJzpcXFwiXFxcIikrKGIub3B0cy5saW5rQWx3YXlzTm9Gb2xsb3c/JyByZWw9XFxcIm5vZm9sbG93XFxcIic6XFxcIlxcXCIpKycgaHJlZj1cXFwiJDJcXFwiPiQyPC9hPiQ4Jyl9KSxiLmV2ZW50cy5vbihcXFwia2V5dXBcXFwiLGZ1bmN0aW9uKGMpe3ZhciBlPWMud2hpY2g7ZSE9YS5GRS5LRVlDT0RFLkVOVEVSJiZlIT1hLkZFLktFWUNPREUuU1BBQ0V8fGQoYi5ub2RlLmNvbnRlbnRzKGIuZWwpKX0sITApLGIuZXZlbnRzLm9uKFxcXCJrZXlkb3duXFxcIixmdW5jdGlvbihjKXt2YXIgZD1jLndoaWNoO2lmKGQ9PWEuRkUuS0VZQ09ERS5FTlRFUil7dmFyIGU9Yi5zZWxlY3Rpb24uZWxlbWVudCgpO2lmKChcXFwiQVxcXCI9PWUudGFnTmFtZXx8YShlKS5wYXJlbnRzKFxcXCJhXFxcIikubGVuZ3RoKSYmYi5zZWxlY3Rpb24uaW5mbyhlKS5hdEVuZClyZXR1cm4gYy5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKSxcXFwiQVxcXCIhPT1lLnRhZ05hbWUmJihlPWEoZSkucGFyZW50cyhcXFwiYVxcXCIpWzBdKSxhKGUpLmFmdGVyKFxcXCImbmJzcDtcXFwiK2EuRkUuTUFSS0VSUyksYi5zZWxlY3Rpb24ucmVzdG9yZSgpLCExfX0pfXJldHVybntfaW5pdDplfX19KTtcIlxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yYXctbG9hZGVyIS4vfi9mcm9hbGEtZWRpdG9yL2pzL3BsdWdpbnMvdXJsLm1pbi5qc1xuLy8gbW9kdWxlIGlkID0gMTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQSIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {

	eval("__webpack_require__(2)(__webpack_require__(21))//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjAuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2Zyb2FsYS1lZGl0b3IvanMvcGx1Z2lucy9pbWFnZS5taW4uanM/ZDZmOCJdLCJzb3VyY2VzQ29udGVudCI6WyJyZXF1aXJlKFwiISEvdmFyL2FwcC93ZWIvanMvbm9kZV9tb2R1bGVzL3NjcmlwdC1sb2FkZXIvYWRkU2NyaXB0LmpzXCIpKHJlcXVpcmUoXCIhIS92YXIvYXBwL3dlYi9qcy9ub2RlX21vZHVsZXMvcmF3LWxvYWRlci9pbmRleC5qcyEvdmFyL2FwcC93ZWIvanMvbm9kZV9tb2R1bGVzL2Zyb2FsYS1lZGl0b3IvanMvcGx1Z2lucy9pbWFnZS5taW4uanNcIikpXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3NjcmlwdC1sb2FkZXIhLi9+L2Zyb2FsYS1lZGl0b3IvanMvcGx1Z2lucy9pbWFnZS5taW4uanNcbi8vIG1vZHVsZSBpZCA9IDIwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 21 */
/***/ function(module, exports) {

	eval("module.exports = \"/*!\\n * froala_editor v2.5.1 (https://www.froala.com/wysiwyg-editor)\\n * License https://froala.com/wysiwyg-editor/terms/\\n * Copyright 2014-2017 Froala Labs\\n */\\n\\n!function(a){\\\"function\\\"==typeof define&&define.amd?define([\\\"jquery\\\"],a):\\\"object\\\"==typeof module&&module.exports?module.exports=function(b,c){return void 0===c&&(c=\\\"undefined\\\"!=typeof window?require(\\\"jquery\\\"):require(\\\"jquery\\\")(b)),a(c)}:a(window.jQuery)}(function(a){a.extend(a.FE.POPUP_TEMPLATES,{\\\"image.insert\\\":\\\"[_BUTTONS_][_UPLOAD_LAYER_][_BY_URL_LAYER_][_PROGRESS_BAR_]\\\",\\\"image.edit\\\":\\\"[_BUTTONS_]\\\",\\\"image.alt\\\":\\\"[_BUTTONS_][_ALT_LAYER_]\\\",\\\"image.size\\\":\\\"[_BUTTONS_][_SIZE_LAYER_]\\\"}),a.extend(a.FE.DEFAULTS,{imageInsertButtons:[\\\"imageBack\\\",\\\"|\\\",\\\"imageUpload\\\",\\\"imageByURL\\\"],imageEditButtons:[\\\"imageReplace\\\",\\\"imageAlign\\\",\\\"imageRemove\\\",\\\"|\\\",\\\"imageLink\\\",\\\"linkOpen\\\",\\\"linkEdit\\\",\\\"linkRemove\\\",\\\"-\\\",\\\"imageDisplay\\\",\\\"imageStyle\\\",\\\"imageAlt\\\",\\\"imageSize\\\"],imageAltButtons:[\\\"imageBack\\\",\\\"|\\\"],imageSizeButtons:[\\\"imageBack\\\",\\\"|\\\"],imageUploadURL:\\\"https://i.froala.com/upload\\\",imageUploadParam:\\\"file\\\",imageUploadParams:{},imageUploadToS3:!1,imageUploadMethod:\\\"POST\\\",imageMaxSize:10485760,imageAllowedTypes:[\\\"jpeg\\\",\\\"jpg\\\",\\\"png\\\",\\\"gif\\\",\\\"svg+xml\\\"],imageResize:!0,imageResizeWithPercent:!1,imageRoundPercent:!1,imageDefaultWidth:300,imageDefaultAlign:\\\"center\\\",imageDefaultDisplay:\\\"block\\\",imageSplitHTML:!1,imageStyles:{\\\"fr-rounded\\\":\\\"Rounded\\\",\\\"fr-bordered\\\":\\\"Bordered\\\"},imageMove:!0,imageMultipleStyles:!0,imageTextNear:!0,imagePaste:!0,imagePasteProcess:!1,imageMinWidth:16,imageOutputSize:!1,imageDefaultMargin:5}),a.FE.PLUGINS.image=function(b){function c(){var a=b.popups.get(\\\"image.insert\\\"),c=a.find(\\\".fr-image-by-url-layer input\\\");c.val(\\\"\\\"),xa&&c.val(xa.attr(\\\"src\\\")),c.trigger(\\\"change\\\")}function d(){var a=b.$tb.find('.fr-command[data-cmd=\\\"insertImage\\\"]'),c=b.popups.get(\\\"image.insert\\\");if(c||(c=M()),s(),!c.hasClass(\\\"fr-active\\\"))if(b.popups.refresh(\\\"image.insert\\\"),b.popups.setContainer(\\\"image.insert\\\",b.$tb),a.is(\\\":visible\\\")){var d=a.offset().left+a.outerWidth()/2,e=a.offset().top+(b.opts.toolbarBottom?10:a.outerHeight()-10);b.popups.show(\\\"image.insert\\\",d,e,a.outerHeight())}else b.position.forSelection(c),b.popups.show(\\\"image.insert\\\")}function e(){var a=b.popups.get(\\\"image.edit\\\");if(a||(a=q()),a){b.popups.setContainer(\\\"image.edit\\\",b.$sc),b.popups.refresh(\\\"image.edit\\\");var c=xa.offset().left+xa.outerWidth()/2,d=xa.offset().top+xa.outerHeight();b.popups.show(\\\"image.edit\\\",c,d,xa.outerHeight())}}function f(){s()}function g(a){a.hasClass(\\\"fr-dii\\\")||a.hasClass(\\\"fr-dib\\\")||(a.addClass(\\\"fr-fi\\\"+ma(a)[0]),a.addClass(\\\"fr-di\\\"+na(a)[0]),a.css(\\\"margin\\\",\\\"\\\"),a.css(\\\"float\\\",\\\"\\\"),a.css(\\\"display\\\",\\\"\\\"),a.css(\\\"z-index\\\",\\\"\\\"),a.css(\\\"position\\\",\\\"\\\"),a.css(\\\"overflow\\\",\\\"\\\"),a.css(\\\"vertical-align\\\",\\\"\\\"))}function h(a){var b=a.hasClass(\\\"fr-dib\\\")?\\\"block\\\":a.hasClass(\\\"fr-dii\\\")?\\\"inline\\\":null,c=a.hasClass(\\\"fr-fil\\\")?\\\"left\\\":a.hasClass(\\\"fr-fir\\\")?\\\"right\\\":ma(a);ka(a,b,c),a.removeClass(\\\"fr-dib fr-dii fr-fir fr-fil\\\")}function i(){for(var c=\\\"IMG\\\"==b.el.tagName?[b.el]:b.el.querySelectorAll(\\\"img\\\"),d=0;d<c.length;d++){var e=a(c[d]);!b.opts.htmlUntouched&&b.opts.useClasses?((b.opts.imageEditButtons.indexOf(\\\"imageAlign\\\")>=0||b.opts.imageEditButtons.indexOf(\\\"imageDisplay\\\")>=0)&&g(e),b.opts.imageTextNear||e.removeClass(\\\"fr-dii\\\").addClass(\\\"fr-dib\\\")):b.opts.htmlUntouched||b.opts.useClasses||(b.opts.imageEditButtons.indexOf(\\\"imageAlign\\\")>=0||b.opts.imageEditButtons.indexOf(\\\"imageDisplay\\\")>=0)&&h(e),b.opts.iframe&&e.on(\\\"load\\\",b.size.syncIframe)}}function j(){var c,d=Array.prototype.slice.call(b.el.querySelectorAll(\\\"img\\\")),e=[];for(c=0;c<d.length;c++)e.push(d[c].getAttribute(\\\"src\\\")),a(d[c]).toggleClass(\\\"fr-draggable\\\",b.opts.imageMove),\\\"\\\"===d[c].getAttribute(\\\"class\\\")&&d[c].removeAttribute(\\\"class\\\"),\\\"\\\"===d[c].getAttribute(\\\"style\\\")&&d[c].removeAttribute(\\\"style\\\");if(Ka)for(c=0;c<Ka.length;c++)e.indexOf(Ka[c].getAttribute(\\\"src\\\"))<0&&b.events.trigger(\\\"image.removed\\\",[a(Ka[c])]);Ka=d}function k(){ya||Z();var a=b.$wp||b.$sc;a.append(ya),ya.data(\\\"instance\\\",b);var c=a.scrollTop()-(\\\"static\\\"!=a.css(\\\"position\\\")?a.offset().top:0),d=a.scrollLeft()-(\\\"static\\\"!=a.css(\\\"position\\\")?a.offset().left:0);d-=b.helpers.getPX(a.css(\\\"border-left-width\\\")),c-=b.helpers.getPX(a.css(\\\"border-top-width\\\")),b.$el.is(\\\"img\\\")&&(c=0,d=0),ya.css(\\\"top\\\",(b.opts.iframe?xa.offset().top:xa.offset().top+c)-1).css(\\\"left\\\",(b.opts.iframe?xa.offset().left:xa.offset().left+d)-1).css(\\\"width\\\",xa.get(0).getBoundingClientRect().width).css(\\\"height\\\",xa.get(0).getBoundingClientRect().height).addClass(\\\"fr-active\\\")}function l(a){return'<div class=\\\"fr-handler fr-h'+a+'\\\"></div>'}function m(c){if(!b.core.sameInstance(ya))return!0;if(c.preventDefault(),c.stopPropagation(),b.$el.find(\\\"img.fr-error\\\").left)return!1;b.undo.canDo()||b.undo.saveStep();var d=c.pageX||c.originalEvent.touches[0].pageX;if(\\\"mousedown\\\"==c.type){var e=b.$oel.get(0),f=e.ownerDocument,g=f.defaultView||f.parentWindow,h=g.location!=g.parent.location;h&&(d+=b.helpers.getPX(a(g.frameElement).offset().left)+g.frameElement.clientLeft)}za=a(this),za.data(\\\"start-x\\\",d),za.data(\\\"start-width\\\",xa.width()),za.data(\\\"start-height\\\",xa.height());var i=xa.width();if(b.opts.imageResizeWithPercent){var j=xa.parentsUntil(b.$el,b.html.blockTagsQuery()).get(0)||b.el;xa.css(\\\"width\\\",(i/a(j).outerWidth()*100).toFixed(2)+\\\"%\\\")}else xa.css(\\\"width\\\",i);Aa.show(),b.popups.hideAll(),ia()}function n(c){if(!b.core.sameInstance(ya))return!0;var d;if(za&&xa){if(c.preventDefault(),b.$el.find(\\\"img.fr-error\\\").left)return!1;var e=c.pageX||(c.originalEvent.touches?c.originalEvent.touches[0].pageX:null);if(!e)return!1;var f=za.data(\\\"start-x\\\"),g=e-f,h=za.data(\\\"start-width\\\");if((za.hasClass(\\\"fr-hnw\\\")||za.hasClass(\\\"fr-hsw\\\"))&&(g=0-g),b.opts.imageResizeWithPercent){var i=xa.parentsUntil(b.$el,b.html.blockTagsQuery()).get(0)||b.el;h=((h+g)/a(i).outerWidth()*100).toFixed(2),b.opts.imageRoundPercent&&(h=Math.round(h)),xa.css(\\\"width\\\",h+\\\"%\\\"),d=(b.helpers.getPX(xa.css(\\\"width\\\"))/a(i).outerWidth()*100).toFixed(2),d!==h&&xa.css(\\\"width\\\",d+\\\"%\\\"),xa.css(\\\"height\\\",\\\"\\\").removeAttr(\\\"height\\\")}else h+g>=b.opts.imageMinWidth&&xa.css(\\\"width\\\",h+g),d=b.helpers.getPX(xa.css(\\\"width\\\")),d!==h+g&&xa.css(\\\"width\\\",d),xa.css(\\\"height\\\",za.data(\\\"start-height\\\")*xa.width()/za.data(\\\"start-width\\\"));k(),b.events.trigger(\\\"image.resize\\\",[va()])}}function o(a){if(!b.core.sameInstance(ya))return!0;if(za&&xa){if(a&&a.stopPropagation(),b.$el.find(\\\"img.fr-error\\\").left)return!1;za=null,Aa.hide(),k(),e(),b.undo.saveStep(),b.events.trigger(\\\"image.resizeEnd\\\",[va()])}}function p(a,c){b.edit.on(),xa&&xa.addClass(\\\"fr-error\\\"),u(b.language.translate(\\\"Something went wrong. Please try again.\\\")),b.events.trigger(\\\"image.error\\\",[{code:a,message:Ja[a]},c])}function q(a){if(a)return b.$wp&&b.events.$on(b.$wp,\\\"scroll\\\",function(){xa&&b.popups.isVisible(\\\"image.edit\\\")&&(b.events.disableBlur(),w(xa))}),!0;var c=\\\"\\\";if(b.opts.imageEditButtons.length>0){c+='<div class=\\\"fr-buttons\\\">',c+=b.button.buildList(b.opts.imageEditButtons),c+=\\\"</div>\\\";var d={buttons:c},e=b.popups.create(\\\"image.edit\\\",d);return e}return!1}function r(a){var c=b.popups.get(\\\"image.insert\\\");if(c||(c=M()),c.find(\\\".fr-layer.fr-active\\\").removeClass(\\\"fr-active\\\").addClass(\\\"fr-pactive\\\"),c.find(\\\".fr-image-progress-bar-layer\\\").addClass(\\\"fr-active\\\"),c.find(\\\".fr-buttons\\\").hide(),xa){b.popups.setContainer(\\\"image.insert\\\",b.$sc);var d=xa.offset().left+xa.width()/2,e=xa.offset().top+xa.height();b.popups.show(\\\"image.insert\\\",d,e,xa.outerHeight())}\\\"undefined\\\"==typeof a&&t(\\\"Uploading\\\",0)}function s(a){var c=b.popups.get(\\\"image.insert\\\");if(c&&(c.find(\\\".fr-layer.fr-pactive\\\").addClass(\\\"fr-active\\\").removeClass(\\\"fr-pactive\\\"),c.find(\\\".fr-image-progress-bar-layer\\\").removeClass(\\\"fr-active\\\"),c.find(\\\".fr-buttons\\\").show(),a||b.$el.find(\\\"img.fr-error\\\").length)){if(b.events.focus(),b.$el.find(\\\"img.fr-error\\\").length&&(b.$el.find(\\\"img.fr-error\\\").remove(),b.undo.saveStep(),b.undo.run(),b.undo.dropRedo()),!b.$wp&&xa){var d=xa;ga(!0),b.selection.setAfter(d.get(0)),b.selection.restore()}b.popups.hide(\\\"image.insert\\\")}}function t(a,c){var d=b.popups.get(\\\"image.insert\\\");if(d){var e=d.find(\\\".fr-image-progress-bar-layer\\\");e.find(\\\"h3\\\").text(a+(c?\\\" \\\"+c+\\\"%\\\":\\\"\\\")),e.removeClass(\\\"fr-error\\\"),c?(e.find(\\\"div\\\").removeClass(\\\"fr-indeterminate\\\"),e.find(\\\"div > span\\\").css(\\\"width\\\",c+\\\"%\\\")):e.find(\\\"div\\\").addClass(\\\"fr-indeterminate\\\")}}function u(a){r();var c=b.popups.get(\\\"image.insert\\\"),d=c.find(\\\".fr-image-progress-bar-layer\\\");d.addClass(\\\"fr-error\\\");var e=d.find(\\\"h3\\\");e.text(a),b.events.disableBlur(),e.focus()}function v(){var a=b.popups.get(\\\"image.insert\\\"),c=a.find(\\\".fr-image-by-url-layer input\\\");c.val().length>0&&(r(),t(\\\"Loading image\\\"),y(c.val(),!0,[],xa),c.val(\\\"\\\"),c.blur())}function w(a){fa.call(a.get(0))}function x(){var c=a(this);b.popups.hide(\\\"image.insert\\\"),c.removeClass(\\\"fr-uploading\\\"),c.next().is(\\\"br\\\")&&c.next().remove(),w(c),b.events.trigger(\\\"image.loaded\\\",[c])}function y(a,c,d,e,f){b.edit.off(),t(\\\"Loading image\\\"),c&&(a=b.helpers.sanitizeURL(a));var g=new Image;g.onload=function(){var c,g;if(e){b.undo.canDo()||e.hasClass(\\\"fr-uploading\\\")||b.undo.saveStep();var h=e.data(\\\"fr-old-src\\\");b.$wp?(c=e.clone().removeData(\\\"fr-old-src\\\").removeClass(\\\"fr-uploading\\\"),c.off(\\\"load\\\"),h&&e.attr(\\\"src\\\",h),e.replaceWith(c)):c=e;for(var i=c.get(0).attributes,k=0;k<i.length;k++){var l=i[k];0===l.nodeName.indexOf(\\\"data-\\\")&&c.removeAttr(l.nodeName)}if(\\\"undefined\\\"!=typeof d)for(g in d)d.hasOwnProperty(g)&&\\\"link\\\"!=g&&c.attr(\\\"data-\\\"+g,d[g]);c.on(\\\"load\\\",x),c.attr(\\\"src\\\",a),b.edit.on(),j(),b.undo.saveStep(),b.$el.blur(),b.events.trigger(h?\\\"image.replaced\\\":\\\"image.inserted\\\",[c,f])}else c=E(a,d,x),j(),b.undo.saveStep(),b.events.trigger(\\\"image.inserted\\\",[c,f])},g.onerror=function(){p(Ca)},r(\\\"Loading image\\\"),g.src=a}function z(c){try{if(b.events.trigger(\\\"image.uploaded\\\",[c],!0)===!1)return b.edit.on(),!1;var d=a.parseJSON(c);return d.link?d:(p(Da,c),!1)}catch(e){return p(Fa,c),!1}}function A(c){try{var d=a(c).find(\\\"Location\\\").text(),e=a(c).find(\\\"Key\\\").text();return b.events.trigger(\\\"image.uploadedToS3\\\",[d,e,c],!0)===!1?(b.edit.on(),!1):d}catch(f){return p(Fa,c),!1}}function B(a){t(\\\"Loading image\\\");var c=this.status,d=this.response,e=this.responseXML,f=this.responseText;try{if(b.opts.imageUploadToS3)if(201==c){var g=A(e);g&&y(g,!1,[],a,d||e)}else p(Fa,d||e);else if(c>=200&&c<300){var h=z(f);h&&y(h.link,!1,h,a,d||f)}else p(Ea,d||f)}catch(i){p(Fa,d||f)}}function C(){p(Fa,this.response||this.responseText||this.responseXML)}function D(a){if(a.lengthComputable){var b=a.loaded/a.total*100|0;t(\\\"Uploading\\\",b)}}function E(c,d,e){var f,g=\\\"\\\";if(d&&\\\"undefined\\\"!=typeof d)for(f in d)d.hasOwnProperty(f)&&\\\"link\\\"!=f&&(g+=\\\" data-\\\"+f+'=\\\"'+d[f]+'\\\"');var h=b.opts.imageDefaultWidth;h&&\\\"auto\\\"!=h&&(h+=b.opts.imageResizeWithPercent?\\\"%\\\":\\\"px\\\");var i=a('<img src=\\\"'+c+'\\\"'+g+(h?' style=\\\"width: '+h+';\\\"':\\\"\\\")+\\\">\\\");ka(i,b.opts.imageDefaultDisplay,b.opts.imageDefaultAlign),i.on(\\\"load\\\",e),b.edit.on(),b.events.focus(!0),b.selection.restore(),b.undo.saveStep(),b.opts.imageSplitHTML?b.markers.split():b.markers.insert();var j=b.$el.find(\\\".fr-marker\\\");return j.parent().is(\\\"hr\\\")&&j.parent().after(j),b.node.isLastSibling(j)&&j.parent().hasClass(\\\"fr-deletable\\\")&&j.insertAfter(j.parent()),j.replaceWith(i),b.html.wrap(),b.selection.clear(),i}function F(){b.edit.on(),s(!0)}function G(c,d,e,f){function g(){var e=a(this);e.off(\\\"load\\\"),e.addClass(\\\"fr-uploading\\\"),e.next().is(\\\"br\\\")&&e.next().remove(),b.placeholder.refresh(),e.is(f)||w(e),k(),r(),b.edit.off(),c.onload=function(){B.call(c,e)},c.onerror=C,c.upload.onprogress=D,c.onabort=F,e.off(\\\"abortUpload\\\").on(\\\"abortUpload\\\",function(){4!=c.readyState&&c.abort()}),c.send(d)}var h,i=new FileReader;i.addEventListener(\\\"load\\\",function(){var a=i.result;if(i.result.indexOf(\\\"svg+xml\\\")<0){for(var c=atob(i.result.split(\\\",\\\")[1]),d=[],e=0;e<c.length;e++)d.push(c.charCodeAt(e));a=window.URL.createObjectURL(new Blob([new Uint8Array(d)],{type:\\\"image/jpeg\\\"}))}f?(f.on(\\\"load\\\",g),b.edit.on(),b.undo.saveStep(),f.data(\\\"fr-old-src\\\",f.attr(\\\"src\\\")),f.attr(\\\"src\\\",a)):h=E(a,null,g)},!1),i.readAsDataURL(e)}function H(a,c){if(\\\"undefined\\\"!=typeof a&&a.length>0){if(b.events.trigger(\\\"image.beforeUpload\\\",[a])===!1)return!1;var d=a[0];if(d.size>b.opts.imageMaxSize)return p(Ga),!1;if(b.opts.imageAllowedTypes.indexOf(d.type.replace(/image\\\\//g,\\\"\\\"))<0)return p(Ha),!1;var e;if(b.drag_support.formdata&&(e=b.drag_support.formdata?new FormData:null),e){var f;if(b.opts.imageUploadToS3!==!1){e.append(\\\"key\\\",b.opts.imageUploadToS3.keyStart+(new Date).getTime()+\\\"-\\\"+(d.name||\\\"untitled\\\")),e.append(\\\"success_action_status\\\",\\\"201\\\"),e.append(\\\"X-Requested-With\\\",\\\"xhr\\\"),e.append(\\\"Content-Type\\\",d.type);for(f in b.opts.imageUploadToS3.params)b.opts.imageUploadToS3.params.hasOwnProperty(f)&&e.append(f,b.opts.imageUploadToS3.params[f])}for(f in b.opts.imageUploadParams)b.opts.imageUploadParams.hasOwnProperty(f)&&e.append(f,b.opts.imageUploadParams[f]);e.append(b.opts.imageUploadParam,d);var g=b.opts.imageUploadURL;b.opts.imageUploadToS3&&(g=b.opts.imageUploadToS3.uploadURL?b.opts.imageUploadToS3.uploadURL:\\\"https://\\\"+b.opts.imageUploadToS3.region+\\\".amazonaws.com/\\\"+b.opts.imageUploadToS3.bucket);var h=b.core.getXHR(g,b.opts.imageUploadMethod);G(h,e,d,c||xa)}}}function I(c){b.events.$on(c,\\\"dragover dragenter\\\",\\\".fr-image-upload-layer\\\",function(){return a(this).addClass(\\\"fr-drop\\\"),!1}),b.events.$on(c,\\\"dragleave dragend\\\",\\\".fr-image-upload-layer\\\",function(){return a(this).removeClass(\\\"fr-drop\\\"),!1}),b.events.$on(c,\\\"drop\\\",\\\".fr-image-upload-layer\\\",function(d){d.preventDefault(),d.stopPropagation(),a(this).removeClass(\\\"fr-drop\\\");var e=d.originalEvent.dataTransfer;if(e&&e.files){var f=c.data(\\\"instance\\\")||b;f.events.disableBlur(),f.image.upload(e.files),f.events.enableBlur()}}),b.events.$on(c,\\\"change\\\",'.fr-image-upload-layer input[type=\\\"file\\\"]',function(){if(this.files){var d=c.data(\\\"instance\\\")||b;d.events.disableBlur(),c.find(\\\"input:focus\\\").blur(),d.events.enableBlur(),d.image.upload(this.files)}a(this).val(\\\"\\\")})}function J(c){var d=c.originalEvent.dataTransfer;if(d&&d.files&&d.files.length){var e=d.files[0];if(e&&e.type&&e.type.indexOf(\\\"image\\\")!==-1){b.markers.remove(),b.markers.insertAtPoint(c.originalEvent),b.$el.find(\\\".fr-marker\\\").replaceWith(a.FE.MARKERS),b.popups.hideAll();var f=b.popups.get(\\\"image.insert\\\");return f||(f=M()),b.popups.setContainer(\\\"image.insert\\\",b.$sc),b.popups.show(\\\"image.insert\\\",c.originalEvent.pageX,c.originalEvent.pageY),r(),b.opts.imageAllowedTypes.indexOf(e.type.replace(/image\\\\//g,\\\"\\\"))>=0?H(d.files):p(Ha),c.preventDefault(),c.stopPropagation(),!1}}}function K(){var c,d,e=b.selection.ranges(0);e.collapsed&&e.startContainer.nodeType==Node.ELEMENT_NODE&&(e.startContainer.childNodes.length==e.startOffset?(c=e.startContainer.childNodes[e.startOffset-1],c&&\\\"IMG\\\"==c.tagName&&\\\"block\\\"==a(c).css(\\\"display\\\")&&(d=b.node.blockParent(c),d&&b.html.defaultTag()?d.nextSibling||([\\\"TD\\\",\\\"TH\\\"].indexOf(d.tagName)<0?a(d).after(\\\"<\\\"+b.html.defaultTag()+\\\"><br>\\\"+a.FE.MARKERS+\\\"</\\\"+b.html.defaultTag()+\\\">\\\"):a(c).after(\\\"<br>\\\"+a.FE.MARKERS),b.selection.restore()):d||(a(c).after(\\\"<br>\\\"+a.FE.MARKERS),b.selection.restore()))):0===e.startOffset&&e.startContainer.childNodes.length>e.startOffset&&(c=e.startContainer.childNodes[e.startOffset],c&&\\\"IMG\\\"==c.tagName&&\\\"block\\\"==a(c).css(\\\"display\\\")&&(d=b.node.blockParent(c),d&&b.html.defaultTag()?d.previousSibling||([\\\"TD\\\",\\\"TH\\\"].indexOf(d.tagName)<0?a(d).before(\\\"<\\\"+b.html.defaultTag()+\\\"><br>\\\"+a.FE.MARKERS+\\\"</\\\"+b.html.defaultTag()+\\\">\\\"):a(c).before(\\\"<br>\\\"+a.FE.MARKERS),b.selection.restore()):d||(a(c).before(a.FE.MARKERS+\\\"<br>\\\"),b.selection.restore()))))}function L(){b.events.$on(b.$el,b._mousedown,\\\"IMG\\\"==b.el.tagName?null:'img:not([contenteditable=\\\"false\\\"])',function(c){return\\\"false\\\"==a(this).parents(\\\"[contenteditable]:not(.fr-element):not(body):first\\\").attr(\\\"contenteditable\\\")||(b.helpers.isMobile()||b.selection.clear(),Ba=!0,b.popups.areVisible()&&b.events.disableBlur(),b.browser.msie&&(b.events.disableBlur(),b.$el.attr(\\\"contenteditable\\\",!1)),b.draggable||c.preventDefault(),void c.stopPropagation())}),b.events.$on(b.$el,b._mouseup,\\\"IMG\\\"==b.el.tagName?null:'img:not([contenteditable=\\\"false\\\"])',function(c){return\\\"false\\\"==a(this).parents(\\\"[contenteditable]:not(.fr-element):not(body):first\\\").attr(\\\"contenteditable\\\")||void(Ba&&(Ba=!1,c.stopPropagation(),b.browser.msie&&(b.$el.attr(\\\"contenteditable\\\",!0),b.events.enableBlur())))}),b.events.on(\\\"keyup\\\",function(c){if(c.shiftKey&&\\\"\\\"===b.selection.text().replace(/\\\\n/g,\\\"\\\")){var d=b.selection.element(),e=b.selection.endElement();d&&\\\"IMG\\\"==d.tagName?w(a(d)):e&&\\\"IMG\\\"==e.tagName&&w(a(e))}},!0),b.events.on(\\\"drop\\\",J),b.events.on(\\\"mousedown window.mousedown\\\",ha),b.events.on(\\\"window.touchmove\\\",ia),b.events.on(\\\"mouseup window.mouseup\\\",function(){return xa?(ga(),!1):void ia()}),b.events.on(\\\"commands.mousedown\\\",function(a){a.parents(\\\".fr-toolbar\\\").length>0&&ga()}),b.browser.edge||b.events.on(\\\"mouseup\\\",K),b.events.on(\\\"blur image.hideResizer commands.undo commands.redo element.dropped\\\",function(){Ba=!1,ga(!0)}),b.events.on(\\\"modals.hide\\\",function(){xa&&(ta(),b.selection.clear())})}function M(a){if(a)return b.popups.onRefresh(\\\"image.insert\\\",c),b.popups.onHide(\\\"image.insert\\\",f),!0;var d,e=\\\"\\\";b.opts.imageInsertButtons.length>1&&(e='<div class=\\\"fr-buttons\\\">'+b.button.buildList(b.opts.imageInsertButtons)+\\\"</div>\\\");var g=b.opts.imageInsertButtons.indexOf(\\\"imageUpload\\\"),h=b.opts.imageInsertButtons.indexOf(\\\"imageByURL\\\"),i=\\\"\\\";g>=0&&(d=\\\" fr-active\\\",h>=0&&g>h&&(d=\\\"\\\"),i='<div class=\\\"fr-image-upload-layer'+d+' fr-layer\\\" id=\\\"fr-image-upload-layer-'+b.id+'\\\"><strong>'+b.language.translate(\\\"Drop image\\\")+\\\"</strong><br>(\\\"+b.language.translate(\\\"or click\\\")+')<div class=\\\"fr-form\\\"><input type=\\\"file\\\" accept=\\\"image/'+b.opts.imageAllowedTypes.join(\\\", image/\\\").toLowerCase()+'\\\" tabIndex=\\\"-1\\\" aria-labelledby=\\\"fr-image-upload-layer-'+b.id+'\\\" role=\\\"button\\\"></div></div>');var j=\\\"\\\";h>=0&&(d=\\\" fr-active\\\",g>=0&&h>g&&(d=\\\"\\\"),j='<div class=\\\"fr-image-by-url-layer'+d+' fr-layer\\\" id=\\\"fr-image-by-url-layer-'+b.id+'\\\"><div class=\\\"fr-input-line\\\"><input id=\\\"fr-image-by-url-layer-text-'+b.id+'\\\" type=\\\"text\\\" placeholder=\\\"http://\\\" tabIndex=\\\"1\\\" aria-required=\\\"true\\\"></div><div class=\\\"fr-action-buttons\\\"><button type=\\\"button\\\" class=\\\"fr-command fr-submit\\\" data-cmd=\\\"imageInsertByURL\\\" tabIndex=\\\"2\\\" role=\\\"button\\\">'+b.language.translate(\\\"Insert\\\")+\\\"</button></div></div>\\\");var k='<div class=\\\"fr-image-progress-bar-layer fr-layer\\\"><h3 tabIndex=\\\"-1\\\" class=\\\"fr-message\\\">Uploading</h3><div class=\\\"fr-loader\\\"><span class=\\\"fr-progress\\\"></span></div><div class=\\\"fr-action-buttons\\\"><button type=\\\"button\\\" class=\\\"fr-command fr-dismiss\\\" data-cmd=\\\"imageDismissError\\\" tabIndex=\\\"2\\\" role=\\\"button\\\">OK</button></div></div>',l={buttons:e,upload_layer:i,by_url_layer:j,progress_bar:k},m=b.popups.create(\\\"image.insert\\\",l);return b.$wp&&b.events.$on(b.$wp,\\\"scroll\\\",function(){xa&&b.popups.isVisible(\\\"image.insert\\\")&&sa()}),I(m),m}function N(){if(xa){var a=b.popups.get(\\\"image.alt\\\");a.find(\\\"input\\\").val(xa.attr(\\\"alt\\\")||\\\"\\\").trigger(\\\"change\\\")}}function O(){var a=b.popups.get(\\\"image.alt\\\");a||(a=P()),s(),b.popups.refresh(\\\"image.alt\\\"),b.popups.setContainer(\\\"image.alt\\\",b.$sc);var c=xa.offset().left+xa.width()/2,d=xa.offset().top+xa.height();b.popups.show(\\\"image.alt\\\",c,d,xa.outerHeight())}function P(a){if(a)return b.popups.onRefresh(\\\"image.alt\\\",N),!0;var c=\\\"\\\";c='<div class=\\\"fr-buttons\\\">'+b.button.buildList(b.opts.imageAltButtons)+\\\"</div>\\\";var d=\\\"\\\";d='<div class=\\\"fr-image-alt-layer fr-layer fr-active\\\" id=\\\"fr-image-alt-layer-'+b.id+'\\\"><div class=\\\"fr-input-line\\\"><input id=\\\"fr-image-alt-layer-text-'+b.id+'\\\" type=\\\"text\\\" placeholder=\\\"'+b.language.translate(\\\"Alternate Text\\\")+'\\\" tabIndex=\\\"1\\\"></div><div class=\\\"fr-action-buttons\\\"><button type=\\\"button\\\" class=\\\"fr-command fr-submit\\\" data-cmd=\\\"imageSetAlt\\\" tabIndex=\\\"2\\\" role=\\\"button\\\">'+b.language.translate(\\\"Update\\\")+\\\"</button></div></div>\\\";var e={buttons:c,alt_layer:d},f=b.popups.create(\\\"image.alt\\\",e);return b.$wp&&b.events.$on(b.$wp,\\\"scroll.image-alt\\\",function(){xa&&b.popups.isVisible(\\\"image.alt\\\")&&O()}),f}function Q(a){if(xa){var c=b.popups.get(\\\"image.alt\\\");xa.attr(\\\"alt\\\",a||c.find(\\\"input\\\").val()||\\\"\\\"),c.find(\\\"input:focus\\\").blur(),w(xa)}}function R(){if(xa){var a=b.popups.get(\\\"image.size\\\");a.find('input[name=\\\"width\\\"]').val(xa.get(0).style.width).trigger(\\\"change\\\"),a.find('input[name=\\\"height\\\"]').val(xa.get(0).style.height).trigger(\\\"change\\\")}}function S(){var a=b.popups.get(\\\"image.size\\\");a||(a=T()),s(),b.popups.refresh(\\\"image.size\\\"),b.popups.setContainer(\\\"image.size\\\",b.$sc);var c=xa.offset().left+xa.width()/2,d=xa.offset().top+xa.height();b.popups.show(\\\"image.size\\\",c,d,xa.outerHeight())}function T(a){if(a)return b.popups.onRefresh(\\\"image.size\\\",R),!0;var c=\\\"\\\";c='<div class=\\\"fr-buttons\\\">'+b.button.buildList(b.opts.imageSizeButtons)+\\\"</div>\\\";var d=\\\"\\\";d='<div class=\\\"fr-image-size-layer fr-layer fr-active\\\" id=\\\"fr-image-size-layer-'+b.id+'\\\"><div class=\\\"fr-image-group\\\"><div class=\\\"fr-input-line\\\"><input id=\\\"fr-image-size-layer-width-'+b.id+'\\\" type=\\\"text\\\" name=\\\"width\\\" placeholder=\\\"'+b.language.translate(\\\"Width\\\")+'\\\" tabIndex=\\\"1\\\"></div><div class=\\\"fr-input-line\\\"><input id=\\\"fr-image-size-layer-height'+b.id+'\\\" type=\\\"text\\\" name=\\\"height\\\" placeholder=\\\"'+b.language.translate(\\\"Height\\\")+'\\\" tabIndex=\\\"1\\\"></div></div><div class=\\\"fr-action-buttons\\\"><button type=\\\"button\\\" class=\\\"fr-command fr-submit\\\" data-cmd=\\\"imageSetSize\\\" tabIndex=\\\"2\\\" role=\\\"button\\\">'+b.language.translate(\\\"Update\\\")+\\\"</button></div></div>\\\";var e={buttons:c,size_layer:d},f=b.popups.create(\\\"image.size\\\",e);return b.$wp&&b.events.$on(b.$wp,\\\"scroll.image-size\\\",function(){xa&&b.popups.isVisible(\\\"image.size\\\")&&S()}),f}function U(a,c){if(xa){var d=b.popups.get(\\\"image.size\\\");a=a||d.find('input[name=\\\"width\\\"]').val()||\\\"\\\",c=c||d.find('input[name=\\\"height\\\"]').val()||\\\"\\\";var e=/^[\\\\d]+((px)|%)*$/g;a.match(e)&&xa.css(\\\"width\\\",a),c.match(e)&&xa.css(\\\"height\\\",c),d.find(\\\"input:focus\\\").blur(),w(xa)}}function V(a){var c,d,e=b.popups.get(\\\"image.insert\\\");if(xa||b.opts.toolbarInline)xa&&(d=xa.offset().top+xa.outerHeight());else{var f=b.$tb.find('.fr-command[data-cmd=\\\"insertImage\\\"]');c=f.offset().left+f.outerWidth()/2,d=f.offset().top+(b.opts.toolbarBottom?10:f.outerHeight()-10)}!xa&&b.opts.toolbarInline&&(d=e.offset().top-b.helpers.getPX(e.css(\\\"margin-top\\\")),e.hasClass(\\\"fr-above\\\")&&(d+=e.outerHeight())),e.find(\\\".fr-layer\\\").removeClass(\\\"fr-active\\\"),e.find(\\\".fr-\\\"+a+\\\"-layer\\\").addClass(\\\"fr-active\\\"),b.popups.show(\\\"image.insert\\\",c,d,xa?xa.outerHeight():0),b.accessibility.focusPopup(e)}function W(a){var c=b.popups.get(\\\"image.insert\\\");c.find(\\\".fr-image-upload-layer\\\").hasClass(\\\"fr-active\\\")&&a.addClass(\\\"fr-active\\\").attr(\\\"aria-pressed\\\",!0)}function X(a){var c=b.popups.get(\\\"image.insert\\\");c.find(\\\".fr-image-by-url-layer\\\").hasClass(\\\"fr-active\\\")&&a.addClass(\\\"fr-active\\\").attr(\\\"aria-pressed\\\",!0)}function Y(a,b,c,d){return a.pageX=b,m.call(this,a),a.pageX=a.pageX+c*Math.floor(Math.pow(1.1,d)),n.call(this,a),o.call(this,a),++d}function Z(){var c;if(b.shared.$image_resizer?(ya=b.shared.$image_resizer,Aa=b.shared.$img_overlay,b.events.on(\\\"destroy\\\",function(){ya.removeClass(\\\"fr-active\\\").appendTo(a(\\\"body\\\"))},!0)):(b.shared.$image_resizer=a('<div class=\\\"fr-image-resizer\\\"></div>'),ya=b.shared.$image_resizer,b.events.$on(ya,\\\"mousedown\\\",function(a){a.stopPropagation()},!0),b.opts.imageResize&&(ya.append(l(\\\"nw\\\")+l(\\\"ne\\\")+l(\\\"sw\\\")+l(\\\"se\\\")),b.shared.$img_overlay=a('<div class=\\\"fr-image-overlay\\\"></div>'),Aa=b.shared.$img_overlay,c=ya.get(0).ownerDocument,a(c).find(\\\"body\\\").append(Aa))),b.events.on(\\\"shared.destroy\\\",function(){ya.html(\\\"\\\").removeData().remove(),ya=null,b.opts.imageResize&&(Aa.remove(),Aa=null)},!0),b.helpers.isMobile()||b.events.$on(a(b.o_win),\\\"resize\\\",function(){xa&&!xa.hasClass(\\\"fr-uploading\\\")?ga(!0):xa&&(k(),sa(),r(!1))}),b.opts.imageResize){c=ya.get(0).ownerDocument,b.events.$on(ya,b._mousedown,\\\".fr-handler\\\",m),b.events.$on(a(c),b._mousemove,n),b.events.$on(a(c.defaultView||c.parentWindow),b._mouseup,o),b.events.$on(Aa,\\\"mouseleave\\\",o);var d=1,e=null,f=0;b.events.on(\\\"keydown\\\",function(c){if(xa){var g=navigator.userAgent.indexOf(\\\"Mac OS X\\\")!=-1?c.metaKey:c.ctrlKey,h=c.which;(h!==e||c.timeStamp-f>200)&&(d=1),(h==a.FE.KEYCODE.EQUALS||b.browser.mozilla&&h==a.FE.KEYCODE.FF_EQUALS)&&g&&!c.altKey?d=Y.call(this,c,1,1,d):(h==a.FE.KEYCODE.HYPHEN||b.browser.mozilla&&h==a.FE.KEYCODE.FF_HYPHEN)&&g&&!c.altKey?d=Y.call(this,c,2,-1,d):b.keys.ctrlKey(c)||h!=a.FE.KEYCODE.ENTER||(xa.before(\\\"<br>\\\"),w(xa)),e=h,f=c.timeStamp}},!0),b.events.on(\\\"keyup\\\",function(){d=1})}}function $(c){c=c||xa,c&&b.events.trigger(\\\"image.beforeRemove\\\",[c])!==!1&&(b.popups.hideAll(),ta(),ga(!0),b.undo.canDo()||b.undo.saveStep(),c.get(0)==b.el?c.removeAttr(\\\"src\\\"):(\\\"A\\\"==c.get(0).parentNode.tagName?(b.selection.setBefore(c.get(0).parentNode)||b.selection.setAfter(c.get(0).parentNode)||c.parent().after(a.FE.MARKERS),a(c.get(0).parentNode).remove()):(b.selection.setBefore(c.get(0))||b.selection.setAfter(c.get(0))||c.after(a.FE.MARKERS),c.remove()),b.html.fillEmptyBlocks(),b.selection.restore()),b.undo.saveStep())}function _(c){var d=c.which;if(xa&&(d==a.FE.KEYCODE.BACKSPACE||d==a.FE.KEYCODE.DELETE))return c.preventDefault(),c.stopPropagation(),$(),!1;if(xa&&d==a.FE.KEYCODE.ESC){var e=xa;return ga(!0),b.selection.setAfter(e.get(0)),b.selection.restore(),c.preventDefault(),!1}if(xa&&(d==a.FE.KEYCODE.ARROW_LEFT||d==a.FE.KEYCODE.ARROW_RIGHT)){var f=xa.get(0);return ga(!0),d==a.FE.KEYCODE.ARROW_LEFT?b.selection.setBefore(f):b.selection.setAfter(f),b.selection.restore(),c.preventDefault(),!1}return xa&&d!=a.FE.KEYCODE.F10&&!b.keys.isBrowserAction(c)?(c.preventDefault(),c.stopPropagation(),!1):void 0}function aa(a){if(a&&\\\"IMG\\\"==a.tagName)b.node.hasClass(a,\\\"fr-uploading\\\")||b.node.hasClass(a,\\\"fr-error\\\")?a.parentNode.removeChild(a):b.node.hasClass(a,\\\"fr-draggable\\\")&&a.classList.remove(\\\"fr-draggable\\\");else if(a&&a.nodeType==Node.ELEMENT_NODE)for(var c=a.querySelectorAll(\\\"img.fr-uploading, img.fr-error, img.fr-draggable\\\"),d=0;d<c.length;d++)aa(c[d])}function ba(){if(L(),\\\"IMG\\\"==b.el.tagName&&b.$el.addClass(\\\"fr-view\\\"),b.events.$on(b.$el,b.helpers.isMobile()&&!b.helpers.isWindowsPhone()?\\\"touchend\\\":\\\"click\\\",\\\"IMG\\\"==b.el.tagName?null:'img:not([contenteditable=\\\"false\\\"])',fa),b.helpers.isMobile()&&(b.events.$on(b.$el,\\\"touchstart\\\",\\\"IMG\\\"==b.el.tagName?null:'img:not([contenteditable=\\\"false\\\"])',function(){La=!1}),b.events.$on(b.$el,\\\"touchmove\\\",function(){La=!0})),b.$wp?(b.events.on(\\\"window.keydown keydown\\\",_,!0),b.events.on(\\\"keyup\\\",function(b){if(b.which==a.FE.KEYCODE.ENTER)return!1},!0)):b.events.$on(b.$win,\\\"keydown\\\",_),b.events.on(\\\"toolbar.esc\\\",function(){if(xa){if(b.$wp)b.events.disableBlur(),b.events.focus();else{var a=xa;ga(!0),b.selection.setAfter(a.get(0)),b.selection.restore()}return!1}},!0),b.events.on(\\\"toolbar.focusEditor\\\",function(){if(xa)return!1},!0),b.events.on(\\\"window.cut window.copy\\\",function(a){xa&&b.popups.isVisible(\\\"image.edit\\\")&&!b.popups.get(\\\"image.edit\\\").find(\\\":focus\\\").length&&(ta(),b.paste.saveCopiedText(xa.get(0).outerHTML,\\\"\\\\n\\\"),\\\"copy\\\"==a.type?setTimeout(function(){w(xa)}):(ga(!0),b.undo.saveStep(),setTimeout(function(){b.undo.saveStep()},0)))},!0),b.events.$on(a(b.o_win),\\\"keydown\\\",function(b){var c=b.which;if(xa&&c==a.FE.KEYCODE.BACKSPACE)return b.preventDefault(),!1}),b.events.$on(b.$win,\\\"keydown\\\",function(b){var c=b.which;xa&&xa.hasClass(\\\"fr-uploading\\\")&&c==a.FE.KEYCODE.ESC&&xa.trigger(\\\"abortUpload\\\")}),b.events.on(\\\"destroy\\\",function(){xa&&xa.hasClass(\\\"fr-uploading\\\")&&xa.trigger(\\\"abortUpload\\\")}),b.events.on(\\\"paste.before\\\",da),b.events.on(\\\"paste.beforeCleanup\\\",ea),b.events.on(\\\"paste.after\\\",ca),b.events.on(\\\"html.set\\\",i),b.events.on(\\\"html.inserted\\\",i),i(),b.events.on(\\\"destroy\\\",function(){Ka=[]}),b.events.on(\\\"html.processGet\\\",aa),b.opts.imageOutputSize){var c;b.events.on(\\\"html.beforeGet\\\",function(){c=b.el.querySelectorAll(\\\"img\\\");for(var d=0;d<c.length;d++){var e=c[d].style.width||a(c[d]).width(),f=c[d].style.height||a(c[d]).height();e&&c[d].setAttribute(\\\"width\\\",(\\\"\\\"+e).replace(/px/,\\\"\\\")),f&&c[d].setAttribute(\\\"height\\\",(\\\"\\\"+f).replace(/px/,\\\"\\\"))}}),b.events.on(\\\"html.afterGet\\\",function(){for(var a=0;a<c.length;a++)c[a].removeAttribute(\\\"width\\\"),c[a].removeAttribute(\\\"height\\\")})}b.opts.iframe&&b.events.on(\\\"image.loaded\\\",b.size.syncIframe),b.$wp&&(j(),b.events.on(\\\"contentChanged\\\",j)),b.events.$on(a(b.o_win),\\\"orientationchange.image\\\",function(){setTimeout(function(){xa&&w(xa)},100)}),q(!0),M(!0),T(!0),P(!0),b.events.on(\\\"node.remove\\\",function(a){if(\\\"IMG\\\"==a.get(0).tagName)return $(a),!1})}function ca(){b.opts.imagePaste?b.$el.find(\\\"img[data-fr-image-pasted]\\\").each(function(c,d){if(b.opts.imagePasteProcess){var f=b.opts.imageDefaultWidth;f&&\\\"auto\\\"!=f&&(f+=b.opts.imageResizeWithPercent?\\\"%\\\":\\\"px\\\"),a(d).css(\\\"width\\\",f),a(d).removeClass(\\\"fr-dii fr-dib fr-fir fr-fil\\\").addClass((b.opts.imageDefaultDisplay?\\\"fr-di\\\"+b.opts.imageDefaultDisplay[0]:\\\"\\\")+(b.opts.imageDefaultAlign&&\\\"center\\\"!=b.opts.imageDefaultAlign?\\\" fr-fi\\\"+b.opts.imageDefaultAlign[0]:\\\"\\\"))}if(0===d.src.indexOf(\\\"data:\\\")){if(b.events.trigger(\\\"image.beforePasteUpload\\\",[d])===!1)return!1;xa=a(d),k(),e(),sa(),r(),b.edit.off();for(var g=atob(a(d).attr(\\\"src\\\").split(\\\",\\\")[1]),h=[],i=0;i<g.length;i++)h.push(g.charCodeAt(i));var j=new Blob([new Uint8Array(h)],{type:\\\"image/jpeg\\\"});H([j],a(d)),a(d).removeAttr(\\\"data-fr-image-pasted\\\")}else 0!==d.src.indexOf(\\\"http\\\")||0===d.src.indexOf(\\\"https://mail.google.com/mail\\\")?(b.selection.save(),a(d).remove(),b.selection.restore()):a(d).removeAttr(\\\"data-fr-image-pasted\\\")}):b.$el.find(\\\"img[data-fr-image-pasted]\\\").remove()}function da(a){if(a&&a.clipboardData&&a.clipboardData.items&&a.clipboardData.items[0]){var c=a.clipboardData.items[0].getAsFile();if(c){var d=new FileReader;return d.onload=function(a){var c=a.target.result,d=b.opts.imageDefaultWidth;d&&\\\"auto\\\"!=d&&(d+=b.opts.imageResizeWithPercent?\\\"%\\\":\\\"px\\\"),b.html.insert('<img data-fr-image-pasted=\\\"true\\\" class=\\\"'+(b.opts.imageDefaultDisplay?\\\"fr-di\\\"+b.opts.imageDefaultDisplay[0]:\\\"\\\")+(b.opts.imageDefaultAlign&&\\\"center\\\"!=b.opts.imageDefaultAlign?\\\" fr-fi\\\"+b.opts.imageDefaultAlign[0]:\\\"\\\")+'\\\" src=\\\"'+c+'\\\"'+(d?' style=\\\"width: '+d+';\\\"':\\\"\\\")+\\\">\\\"),b.events.trigger(\\\"paste.after\\\")},d.readAsDataURL(c),!1}}}function ea(a){return a=a.replace(/<img /gi,'<img data-fr-image-pasted=\\\"true\\\" ')}function fa(c){if(\\\"false\\\"==a(this).parents(\\\"[contenteditable]:not(.fr-element):not(body):first\\\").attr(\\\"contenteditable\\\"))return!0;if(c&&\\\"touchend\\\"==c.type&&La)return!0;if(c&&b.edit.isDisabled())return c.stopPropagation(),c.preventDefault(),!1;for(var d=0;d<a.FE.INSTANCES.length;d++)a.FE.INSTANCES[d]!=b&&a.FE.INSTANCES[d].events.trigger(\\\"image.hideResizer\\\");b.toolbar.disable(),c&&(c.stopPropagation(),c.preventDefault()),b.helpers.isMobile()&&(b.events.disableBlur(),b.$el.blur(),b.events.enableBlur()),b.opts.iframe&&b.size.syncIframe(),xa=a(this),ta(),k(),e(),b.selection.clear(),b.button.bulkRefresh(),b.events.trigger(\\\"video.hideResizer\\\")}function ga(a){xa&&(ja()||a===!0)&&(b.toolbar.enable(),ya.removeClass(\\\"fr-active\\\"),b.popups.hide(\\\"image.edit\\\"),xa=null,ia())}function ha(){Ma=!0}function ia(){Ma=!1}function ja(){return Ma}function ka(a,c,d){!b.opts.htmlUntouched&&b.opts.useClasses?(a.removeClass(\\\"fr-fil fr-fir fr-dib fr-dii\\\"),a.addClass(\\\"fr-fi\\\"+d[0]+\\\" fr-di\\\"+c[0])):\\\"inline\\\"==c?(a.css({display:\\\"inline-block\\\",verticalAlign:\\\"bottom\\\",margin:b.opts.imageDefaultMargin}),\\\"center\\\"==d?a.css({float:\\\"none\\\",marginBottom:\\\"\\\",marginTop:\\\"\\\",maxWidth:\\\"calc(100% - \\\"+2*b.opts.imageDefaultMargin+\\\"px)\\\"}):\\\"left\\\"==d?a.css({float:\\\"left\\\",marginLeft:0,maxWidth:\\\"calc(100% - \\\"+b.opts.imageDefaultMargin+\\\"px)\\\"}):a.css({float:\\\"right\\\",marginRight:0,maxWidth:\\\"calc(100% - \\\"+b.opts.imageDefaultMargin+\\\"px)\\\"})):\\\"block\\\"==c&&(a.css({display:\\\"block\\\",float:\\\"none\\\",verticalAlign:\\\"top\\\",margin:b.opts.imageDefaultMargin+\\\"px auto\\\"}),\\\"left\\\"==d?a.css({marginLeft:0}):\\\"right\\\"==d&&a.css({marginRight:0}))}function la(a){xa.removeClass(\\\"fr-fir fr-fil\\\"),!b.opts.htmlUntouched&&b.opts.useClasses?\\\"left\\\"==a?xa.addClass(\\\"fr-fil\\\"):\\\"right\\\"==a&&xa.addClass(\\\"fr-fir\\\"):ka(xa,na(),a),k(),e()}function ma(a){if(\\\"undefined\\\"==typeof a&&(a=xa),a){if(a.hasClass(\\\"fr-fil\\\"))return\\\"left\\\";if(a.hasClass(\\\"fr-fir\\\"))return\\\"right\\\";if(a.hasClass(\\\"fr-dib\\\")||a.hasClass(\\\"fr-dii\\\"))return\\\"center\\\";var b=a.css(\\\"float\\\");if(a.css(\\\"float\\\",\\\"none\\\"),\\\"block\\\"==a.css(\\\"display\\\")){if(a.css(\\\"float\\\",\\\"\\\"),a.css(\\\"float\\\")!=b&&a.css(\\\"float\\\",b),0===parseInt(a.css(\\\"margin-left\\\"),10))return\\\"left\\\";if(0===parseInt(a.css(\\\"margin-right\\\"),10))return\\\"right\\\"}else{if(a.css(\\\"float\\\",\\\"\\\"),a.css(\\\"float\\\")!=b&&a.css(\\\"float\\\",b),\\n\\\"left\\\"==a.css(\\\"float\\\"))return\\\"left\\\";if(\\\"right\\\"==a.css(\\\"float\\\"))return\\\"right\\\"}}return\\\"center\\\"}function na(a){\\\"undefined\\\"==typeof a&&(a=xa);var b=a.css(\\\"float\\\");return a.css(\\\"float\\\",\\\"none\\\"),\\\"block\\\"==a.css(\\\"display\\\")?(a.css(\\\"float\\\",\\\"\\\"),a.css(\\\"float\\\")!=b&&a.css(\\\"float\\\",b),\\\"block\\\"):(a.css(\\\"float\\\",\\\"\\\"),a.css(\\\"float\\\")!=b&&a.css(\\\"float\\\",b),\\\"inline\\\")}function oa(a){xa&&a.find(\\\"> *:first\\\").replaceWith(b.icon.create(\\\"image-align-\\\"+ma()))}function pa(a,b){xa&&b.find('.fr-command[data-param1=\\\"'+ma()+'\\\"]').addClass(\\\"fr-active\\\").attr(\\\"aria-selected\\\",!0)}function qa(a){xa.removeClass(\\\"fr-dii fr-dib\\\"),!b.opts.htmlUntouched&&b.opts.useClasses?\\\"inline\\\"==a?xa.addClass(\\\"fr-dii\\\"):\\\"block\\\"==a&&xa.addClass(\\\"fr-dib\\\"):ka(xa,a,ma()),k(),e()}function ra(a,b){xa&&b.find('.fr-command[data-param1=\\\"'+na()+'\\\"]').addClass(\\\"fr-active\\\").attr(\\\"aria-selected\\\",!0)}function sa(){var a=b.popups.get(\\\"image.insert\\\");a||(a=M()),b.popups.isVisible(\\\"image.insert\\\")||(s(),b.popups.refresh(\\\"image.insert\\\"),b.popups.setContainer(\\\"image.insert\\\",b.$sc));var c=xa.offset().left+xa.width()/2,d=xa.offset().top+xa.height();b.popups.show(\\\"image.insert\\\",c,d,xa.outerHeight())}function ta(){if(xa){b.selection.clear();var a=b.doc.createRange();a.selectNode(xa.get(0));var c=b.selection.get();c.addRange(a)}}function ua(){xa?(b.events.disableBlur(),a(\\\".fr-popup input:focus\\\").blur(),w(xa)):(b.events.disableBlur(),b.selection.restore(),b.events.enableBlur(),b.popups.hide(\\\"image.insert\\\"),b.toolbar.showInline())}function va(){return xa}function wa(a,c,d){if(\\\"undefined\\\"==typeof c&&(c=b.opts.imageStyles),\\\"undefined\\\"==typeof d&&(d=b.opts.imageMultipleStyles),!xa)return!1;if(!d){var e=Object.keys(c);e.splice(e.indexOf(a),1),xa.removeClass(e.join(\\\" \\\"))}\\\"object\\\"==typeof c[a]?(xa.removeAttr(\\\"style\\\"),xa.css(c[a].style)):xa.toggleClass(a),w(xa)}var xa,ya,za,Aa,Ba=!1,Ca=1,Da=2,Ea=3,Fa=4,Ga=5,Ha=6,Ia=7,Ja={};Ja[Ca]=\\\"Image cannot be loaded from the passed link.\\\",Ja[Da]=\\\"No link in upload response.\\\",Ja[Ea]=\\\"Error during file upload.\\\",Ja[Fa]=\\\"Parsing response failed.\\\",Ja[Ga]=\\\"File is too large.\\\",Ja[Ha]=\\\"Image file type is invalid.\\\",Ja[Ia]=\\\"Files can be uploaded only to same domain in IE 8 and IE 9.\\\";var Ka,La,Ma=!1;return{_init:ba,showInsertPopup:d,showLayer:V,refreshUploadButton:W,refreshByURLButton:X,upload:H,insertByURL:v,align:la,refreshAlign:oa,refreshAlignOnShow:pa,display:qa,refreshDisplayOnShow:ra,replace:sa,back:ua,get:va,insert:y,showProgressBar:r,remove:$,hideProgressBar:s,applyStyle:wa,showAltPopup:O,showSizePopup:S,setAlt:Q,setSize:U,exitEdit:ga,edit:w}},a.FE.DefineIcon(\\\"insertImage\\\",{NAME:\\\"image\\\"}),a.FE.RegisterShortcut(a.FE.KEYCODE.P,\\\"insertImage\\\",null,\\\"P\\\"),a.FE.RegisterCommand(\\\"insertImage\\\",{title:\\\"Insert Image\\\",undo:!1,focus:!0,refreshAfterCallback:!1,popup:!0,callback:function(){this.popups.isVisible(\\\"image.insert\\\")?(this.$el.find(\\\".fr-marker\\\").length&&(this.events.disableBlur(),this.selection.restore()),this.popups.hide(\\\"image.insert\\\")):this.image.showInsertPopup()},plugin:\\\"image\\\"}),a.FE.DefineIcon(\\\"imageUpload\\\",{NAME:\\\"upload\\\"}),a.FE.RegisterCommand(\\\"imageUpload\\\",{title:\\\"Upload Image\\\",undo:!1,focus:!1,toggle:!0,callback:function(){this.image.showLayer(\\\"image-upload\\\")},refresh:function(a){this.image.refreshUploadButton(a)}}),a.FE.DefineIcon(\\\"imageByURL\\\",{NAME:\\\"link\\\"}),a.FE.RegisterCommand(\\\"imageByURL\\\",{title:\\\"By URL\\\",undo:!1,focus:!1,toggle:!0,callback:function(){this.image.showLayer(\\\"image-by-url\\\")},refresh:function(a){this.image.refreshByURLButton(a)}}),a.FE.RegisterCommand(\\\"imageInsertByURL\\\",{title:\\\"Insert Image\\\",undo:!0,refreshAfterCallback:!1,callback:function(){this.image.insertByURL()},refresh:function(a){var b=this.image.get();b?a.text(this.language.translate(\\\"Replace\\\")):a.text(this.language.translate(\\\"Insert\\\"))}}),a.FE.DefineIcon(\\\"imageDisplay\\\",{NAME:\\\"star\\\"}),a.FE.RegisterCommand(\\\"imageDisplay\\\",{title:\\\"Display\\\",type:\\\"dropdown\\\",options:{inline:\\\"Inline\\\",block:\\\"Break Text\\\"},callback:function(a,b){this.image.display(b)},refresh:function(a){this.opts.imageTextNear||a.addClass(\\\"fr-hidden\\\")},refreshOnShow:function(a,b){this.image.refreshDisplayOnShow(a,b)}}),a.FE.DefineIcon(\\\"image-align\\\",{NAME:\\\"align-left\\\"}),a.FE.DefineIcon(\\\"image-align-left\\\",{NAME:\\\"align-left\\\"}),a.FE.DefineIcon(\\\"image-align-right\\\",{NAME:\\\"align-right\\\"}),a.FE.DefineIcon(\\\"image-align-center\\\",{NAME:\\\"align-justify\\\"}),a.FE.DefineIcon(\\\"imageAlign\\\",{NAME:\\\"align-justify\\\"}),a.FE.RegisterCommand(\\\"imageAlign\\\",{type:\\\"dropdown\\\",title:\\\"Align\\\",options:{left:\\\"Align Left\\\",center:\\\"None\\\",right:\\\"Align Right\\\"},html:function(){var b='<ul class=\\\"fr-dropdown-list\\\" role=\\\"presentation\\\">',c=a.FE.COMMANDS.imageAlign.options;for(var d in c)c.hasOwnProperty(d)&&(b+='<li role=\\\"presentation\\\"><a class=\\\"fr-command fr-title\\\" tabIndex=\\\"-1\\\" role=\\\"option\\\" data-cmd=\\\"imageAlign\\\" data-param1=\\\"'+d+'\\\" title=\\\"'+this.language.translate(c[d])+'\\\">'+this.icon.create(\\\"image-align-\\\"+d)+'<span class=\\\"fr-sr-only\\\">'+this.language.translate(c[d])+\\\"</span></a></li>\\\");return b+=\\\"</ul>\\\"},callback:function(a,b){this.image.align(b)},refresh:function(a){this.image.refreshAlign(a)},refreshOnShow:function(a,b){this.image.refreshAlignOnShow(a,b)}}),a.FE.DefineIcon(\\\"imageReplace\\\",{NAME:\\\"exchange\\\"}),a.FE.RegisterCommand(\\\"imageReplace\\\",{title:\\\"Replace\\\",undo:!1,focus:!1,popup:!0,refreshAfterCallback:!1,callback:function(){this.image.replace()}}),a.FE.DefineIcon(\\\"imageRemove\\\",{NAME:\\\"trash\\\"}),a.FE.RegisterCommand(\\\"imageRemove\\\",{title:\\\"Remove\\\",callback:function(){this.image.remove()}}),a.FE.DefineIcon(\\\"imageBack\\\",{NAME:\\\"arrow-left\\\"}),a.FE.RegisterCommand(\\\"imageBack\\\",{title:\\\"Back\\\",undo:!1,focus:!1,back:!0,callback:function(){this.image.back()},refresh:function(a){var b=this.image.get();b||this.opts.toolbarInline?(a.removeClass(\\\"fr-hidden\\\"),a.next(\\\".fr-separator\\\").removeClass(\\\"fr-hidden\\\")):(a.addClass(\\\"fr-hidden\\\"),a.next(\\\".fr-separator\\\").addClass(\\\"fr-hidden\\\"))}}),a.FE.RegisterCommand(\\\"imageDismissError\\\",{title:\\\"OK\\\",undo:!1,callback:function(){this.image.hideProgressBar(!0)}}),a.FE.DefineIcon(\\\"imageStyle\\\",{NAME:\\\"magic\\\"}),a.FE.RegisterCommand(\\\"imageStyle\\\",{title:\\\"Style\\\",type:\\\"dropdown\\\",html:function(){var a='<ul class=\\\"fr-dropdown-list\\\" role=\\\"presentation\\\">',b=this.opts.imageStyles;for(var c in b)if(b.hasOwnProperty(c)){var d=b[c];\\\"object\\\"==typeof d&&(d=d.title),a+='<li role=\\\"presentation\\\"><a class=\\\"fr-command\\\" tabIndex=\\\"-1\\\" role=\\\"option\\\" data-cmd=\\\"imageStyle\\\" data-param1=\\\"'+c+'\\\">'+this.language.translate(d)+\\\"</a></li>\\\"}return a+=\\\"</ul>\\\"},callback:function(a,b){this.image.applyStyle(b)},refreshOnShow:function(b,c){var d=this.image.get();d&&c.find(\\\".fr-command\\\").each(function(){var b=a(this).data(\\\"param1\\\"),c=d.hasClass(b);a(this).toggleClass(\\\"fr-active\\\",c).attr(\\\"aria-selected\\\",c)})}}),a.FE.DefineIcon(\\\"imageAlt\\\",{NAME:\\\"info\\\"}),a.FE.RegisterCommand(\\\"imageAlt\\\",{undo:!1,focus:!1,popup:!0,title:\\\"Alternate Text\\\",callback:function(){this.image.showAltPopup()}}),a.FE.RegisterCommand(\\\"imageSetAlt\\\",{undo:!0,focus:!1,title:\\\"Update\\\",refreshAfterCallback:!1,callback:function(){this.image.setAlt()}}),a.FE.DefineIcon(\\\"imageSize\\\",{NAME:\\\"arrows-alt\\\"}),a.FE.RegisterCommand(\\\"imageSize\\\",{undo:!1,focus:!1,popup:!0,title:\\\"Change Size\\\",callback:function(){this.image.showSizePopup()}}),a.FE.RegisterCommand(\\\"imageSetSize\\\",{undo:!0,focus:!1,title:\\\"Update\\\",refreshAfterCallback:!1,callback:function(){this.image.setSize()}})});\"//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjEuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2Zyb2FsYS1lZGl0b3IvanMvcGx1Z2lucy9pbWFnZS5taW4uanM/ZDNiYiJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IFwiLyohXFxuICogZnJvYWxhX2VkaXRvciB2Mi41LjEgKGh0dHBzOi8vd3d3LmZyb2FsYS5jb20vd3lzaXd5Zy1lZGl0b3IpXFxuICogTGljZW5zZSBodHRwczovL2Zyb2FsYS5jb20vd3lzaXd5Zy1lZGl0b3IvdGVybXMvXFxuICogQ29weXJpZ2h0IDIwMTQtMjAxNyBGcm9hbGEgTGFic1xcbiAqL1xcblxcbiFmdW5jdGlvbihhKXtcXFwiZnVuY3Rpb25cXFwiPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZShbXFxcImpxdWVyeVxcXCJdLGEpOlxcXCJvYmplY3RcXFwiPT10eXBlb2YgbW9kdWxlJiZtb2R1bGUuZXhwb3J0cz9tb2R1bGUuZXhwb3J0cz1mdW5jdGlvbihiLGMpe3JldHVybiB2b2lkIDA9PT1jJiYoYz1cXFwidW5kZWZpbmVkXFxcIiE9dHlwZW9mIHdpbmRvdz9yZXF1aXJlKFxcXCJqcXVlcnlcXFwiKTpyZXF1aXJlKFxcXCJqcXVlcnlcXFwiKShiKSksYShjKX06YSh3aW5kb3cualF1ZXJ5KX0oZnVuY3Rpb24oYSl7YS5leHRlbmQoYS5GRS5QT1BVUF9URU1QTEFURVMse1xcXCJpbWFnZS5pbnNlcnRcXFwiOlxcXCJbX0JVVFRPTlNfXVtfVVBMT0FEX0xBWUVSX11bX0JZX1VSTF9MQVlFUl9dW19QUk9HUkVTU19CQVJfXVxcXCIsXFxcImltYWdlLmVkaXRcXFwiOlxcXCJbX0JVVFRPTlNfXVxcXCIsXFxcImltYWdlLmFsdFxcXCI6XFxcIltfQlVUVE9OU19dW19BTFRfTEFZRVJfXVxcXCIsXFxcImltYWdlLnNpemVcXFwiOlxcXCJbX0JVVFRPTlNfXVtfU0laRV9MQVlFUl9dXFxcIn0pLGEuZXh0ZW5kKGEuRkUuREVGQVVMVFMse2ltYWdlSW5zZXJ0QnV0dG9uczpbXFxcImltYWdlQmFja1xcXCIsXFxcInxcXFwiLFxcXCJpbWFnZVVwbG9hZFxcXCIsXFxcImltYWdlQnlVUkxcXFwiXSxpbWFnZUVkaXRCdXR0b25zOltcXFwiaW1hZ2VSZXBsYWNlXFxcIixcXFwiaW1hZ2VBbGlnblxcXCIsXFxcImltYWdlUmVtb3ZlXFxcIixcXFwifFxcXCIsXFxcImltYWdlTGlua1xcXCIsXFxcImxpbmtPcGVuXFxcIixcXFwibGlua0VkaXRcXFwiLFxcXCJsaW5rUmVtb3ZlXFxcIixcXFwiLVxcXCIsXFxcImltYWdlRGlzcGxheVxcXCIsXFxcImltYWdlU3R5bGVcXFwiLFxcXCJpbWFnZUFsdFxcXCIsXFxcImltYWdlU2l6ZVxcXCJdLGltYWdlQWx0QnV0dG9uczpbXFxcImltYWdlQmFja1xcXCIsXFxcInxcXFwiXSxpbWFnZVNpemVCdXR0b25zOltcXFwiaW1hZ2VCYWNrXFxcIixcXFwifFxcXCJdLGltYWdlVXBsb2FkVVJMOlxcXCJodHRwczovL2kuZnJvYWxhLmNvbS91cGxvYWRcXFwiLGltYWdlVXBsb2FkUGFyYW06XFxcImZpbGVcXFwiLGltYWdlVXBsb2FkUGFyYW1zOnt9LGltYWdlVXBsb2FkVG9TMzohMSxpbWFnZVVwbG9hZE1ldGhvZDpcXFwiUE9TVFxcXCIsaW1hZ2VNYXhTaXplOjEwNDg1NzYwLGltYWdlQWxsb3dlZFR5cGVzOltcXFwianBlZ1xcXCIsXFxcImpwZ1xcXCIsXFxcInBuZ1xcXCIsXFxcImdpZlxcXCIsXFxcInN2Zyt4bWxcXFwiXSxpbWFnZVJlc2l6ZTohMCxpbWFnZVJlc2l6ZVdpdGhQZXJjZW50OiExLGltYWdlUm91bmRQZXJjZW50OiExLGltYWdlRGVmYXVsdFdpZHRoOjMwMCxpbWFnZURlZmF1bHRBbGlnbjpcXFwiY2VudGVyXFxcIixpbWFnZURlZmF1bHREaXNwbGF5OlxcXCJibG9ja1xcXCIsaW1hZ2VTcGxpdEhUTUw6ITEsaW1hZ2VTdHlsZXM6e1xcXCJmci1yb3VuZGVkXFxcIjpcXFwiUm91bmRlZFxcXCIsXFxcImZyLWJvcmRlcmVkXFxcIjpcXFwiQm9yZGVyZWRcXFwifSxpbWFnZU1vdmU6ITAsaW1hZ2VNdWx0aXBsZVN0eWxlczohMCxpbWFnZVRleHROZWFyOiEwLGltYWdlUGFzdGU6ITAsaW1hZ2VQYXN0ZVByb2Nlc3M6ITEsaW1hZ2VNaW5XaWR0aDoxNixpbWFnZU91dHB1dFNpemU6ITEsaW1hZ2VEZWZhdWx0TWFyZ2luOjV9KSxhLkZFLlBMVUdJTlMuaW1hZ2U9ZnVuY3Rpb24oYil7ZnVuY3Rpb24gYygpe3ZhciBhPWIucG9wdXBzLmdldChcXFwiaW1hZ2UuaW5zZXJ0XFxcIiksYz1hLmZpbmQoXFxcIi5mci1pbWFnZS1ieS11cmwtbGF5ZXIgaW5wdXRcXFwiKTtjLnZhbChcXFwiXFxcIikseGEmJmMudmFsKHhhLmF0dHIoXFxcInNyY1xcXCIpKSxjLnRyaWdnZXIoXFxcImNoYW5nZVxcXCIpfWZ1bmN0aW9uIGQoKXt2YXIgYT1iLiR0Yi5maW5kKCcuZnItY29tbWFuZFtkYXRhLWNtZD1cXFwiaW5zZXJ0SW1hZ2VcXFwiXScpLGM9Yi5wb3B1cHMuZ2V0KFxcXCJpbWFnZS5pbnNlcnRcXFwiKTtpZihjfHwoYz1NKCkpLHMoKSwhYy5oYXNDbGFzcyhcXFwiZnItYWN0aXZlXFxcIikpaWYoYi5wb3B1cHMucmVmcmVzaChcXFwiaW1hZ2UuaW5zZXJ0XFxcIiksYi5wb3B1cHMuc2V0Q29udGFpbmVyKFxcXCJpbWFnZS5pbnNlcnRcXFwiLGIuJHRiKSxhLmlzKFxcXCI6dmlzaWJsZVxcXCIpKXt2YXIgZD1hLm9mZnNldCgpLmxlZnQrYS5vdXRlcldpZHRoKCkvMixlPWEub2Zmc2V0KCkudG9wKyhiLm9wdHMudG9vbGJhckJvdHRvbT8xMDphLm91dGVySGVpZ2h0KCktMTApO2IucG9wdXBzLnNob3coXFxcImltYWdlLmluc2VydFxcXCIsZCxlLGEub3V0ZXJIZWlnaHQoKSl9ZWxzZSBiLnBvc2l0aW9uLmZvclNlbGVjdGlvbihjKSxiLnBvcHVwcy5zaG93KFxcXCJpbWFnZS5pbnNlcnRcXFwiKX1mdW5jdGlvbiBlKCl7dmFyIGE9Yi5wb3B1cHMuZ2V0KFxcXCJpbWFnZS5lZGl0XFxcIik7aWYoYXx8KGE9cSgpKSxhKXtiLnBvcHVwcy5zZXRDb250YWluZXIoXFxcImltYWdlLmVkaXRcXFwiLGIuJHNjKSxiLnBvcHVwcy5yZWZyZXNoKFxcXCJpbWFnZS5lZGl0XFxcIik7dmFyIGM9eGEub2Zmc2V0KCkubGVmdCt4YS5vdXRlcldpZHRoKCkvMixkPXhhLm9mZnNldCgpLnRvcCt4YS5vdXRlckhlaWdodCgpO2IucG9wdXBzLnNob3coXFxcImltYWdlLmVkaXRcXFwiLGMsZCx4YS5vdXRlckhlaWdodCgpKX19ZnVuY3Rpb24gZigpe3MoKX1mdW5jdGlvbiBnKGEpe2EuaGFzQ2xhc3MoXFxcImZyLWRpaVxcXCIpfHxhLmhhc0NsYXNzKFxcXCJmci1kaWJcXFwiKXx8KGEuYWRkQ2xhc3MoXFxcImZyLWZpXFxcIittYShhKVswXSksYS5hZGRDbGFzcyhcXFwiZnItZGlcXFwiK25hKGEpWzBdKSxhLmNzcyhcXFwibWFyZ2luXFxcIixcXFwiXFxcIiksYS5jc3MoXFxcImZsb2F0XFxcIixcXFwiXFxcIiksYS5jc3MoXFxcImRpc3BsYXlcXFwiLFxcXCJcXFwiKSxhLmNzcyhcXFwiei1pbmRleFxcXCIsXFxcIlxcXCIpLGEuY3NzKFxcXCJwb3NpdGlvblxcXCIsXFxcIlxcXCIpLGEuY3NzKFxcXCJvdmVyZmxvd1xcXCIsXFxcIlxcXCIpLGEuY3NzKFxcXCJ2ZXJ0aWNhbC1hbGlnblxcXCIsXFxcIlxcXCIpKX1mdW5jdGlvbiBoKGEpe3ZhciBiPWEuaGFzQ2xhc3MoXFxcImZyLWRpYlxcXCIpP1xcXCJibG9ja1xcXCI6YS5oYXNDbGFzcyhcXFwiZnItZGlpXFxcIik/XFxcImlubGluZVxcXCI6bnVsbCxjPWEuaGFzQ2xhc3MoXFxcImZyLWZpbFxcXCIpP1xcXCJsZWZ0XFxcIjphLmhhc0NsYXNzKFxcXCJmci1maXJcXFwiKT9cXFwicmlnaHRcXFwiOm1hKGEpO2thKGEsYixjKSxhLnJlbW92ZUNsYXNzKFxcXCJmci1kaWIgZnItZGlpIGZyLWZpciBmci1maWxcXFwiKX1mdW5jdGlvbiBpKCl7Zm9yKHZhciBjPVxcXCJJTUdcXFwiPT1iLmVsLnRhZ05hbWU/W2IuZWxdOmIuZWwucXVlcnlTZWxlY3RvckFsbChcXFwiaW1nXFxcIiksZD0wO2Q8Yy5sZW5ndGg7ZCsrKXt2YXIgZT1hKGNbZF0pOyFiLm9wdHMuaHRtbFVudG91Y2hlZCYmYi5vcHRzLnVzZUNsYXNzZXM/KChiLm9wdHMuaW1hZ2VFZGl0QnV0dG9ucy5pbmRleE9mKFxcXCJpbWFnZUFsaWduXFxcIik+PTB8fGIub3B0cy5pbWFnZUVkaXRCdXR0b25zLmluZGV4T2YoXFxcImltYWdlRGlzcGxheVxcXCIpPj0wKSYmZyhlKSxiLm9wdHMuaW1hZ2VUZXh0TmVhcnx8ZS5yZW1vdmVDbGFzcyhcXFwiZnItZGlpXFxcIikuYWRkQ2xhc3MoXFxcImZyLWRpYlxcXCIpKTpiLm9wdHMuaHRtbFVudG91Y2hlZHx8Yi5vcHRzLnVzZUNsYXNzZXN8fChiLm9wdHMuaW1hZ2VFZGl0QnV0dG9ucy5pbmRleE9mKFxcXCJpbWFnZUFsaWduXFxcIik+PTB8fGIub3B0cy5pbWFnZUVkaXRCdXR0b25zLmluZGV4T2YoXFxcImltYWdlRGlzcGxheVxcXCIpPj0wKSYmaChlKSxiLm9wdHMuaWZyYW1lJiZlLm9uKFxcXCJsb2FkXFxcIixiLnNpemUuc3luY0lmcmFtZSl9fWZ1bmN0aW9uIGooKXt2YXIgYyxkPUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGIuZWwucXVlcnlTZWxlY3RvckFsbChcXFwiaW1nXFxcIikpLGU9W107Zm9yKGM9MDtjPGQubGVuZ3RoO2MrKyllLnB1c2goZFtjXS5nZXRBdHRyaWJ1dGUoXFxcInNyY1xcXCIpKSxhKGRbY10pLnRvZ2dsZUNsYXNzKFxcXCJmci1kcmFnZ2FibGVcXFwiLGIub3B0cy5pbWFnZU1vdmUpLFxcXCJcXFwiPT09ZFtjXS5nZXRBdHRyaWJ1dGUoXFxcImNsYXNzXFxcIikmJmRbY10ucmVtb3ZlQXR0cmlidXRlKFxcXCJjbGFzc1xcXCIpLFxcXCJcXFwiPT09ZFtjXS5nZXRBdHRyaWJ1dGUoXFxcInN0eWxlXFxcIikmJmRbY10ucmVtb3ZlQXR0cmlidXRlKFxcXCJzdHlsZVxcXCIpO2lmKEthKWZvcihjPTA7YzxLYS5sZW5ndGg7YysrKWUuaW5kZXhPZihLYVtjXS5nZXRBdHRyaWJ1dGUoXFxcInNyY1xcXCIpKTwwJiZiLmV2ZW50cy50cmlnZ2VyKFxcXCJpbWFnZS5yZW1vdmVkXFxcIixbYShLYVtjXSldKTtLYT1kfWZ1bmN0aW9uIGsoKXt5YXx8WigpO3ZhciBhPWIuJHdwfHxiLiRzYzthLmFwcGVuZCh5YSkseWEuZGF0YShcXFwiaW5zdGFuY2VcXFwiLGIpO3ZhciBjPWEuc2Nyb2xsVG9wKCktKFxcXCJzdGF0aWNcXFwiIT1hLmNzcyhcXFwicG9zaXRpb25cXFwiKT9hLm9mZnNldCgpLnRvcDowKSxkPWEuc2Nyb2xsTGVmdCgpLShcXFwic3RhdGljXFxcIiE9YS5jc3MoXFxcInBvc2l0aW9uXFxcIik/YS5vZmZzZXQoKS5sZWZ0OjApO2QtPWIuaGVscGVycy5nZXRQWChhLmNzcyhcXFwiYm9yZGVyLWxlZnQtd2lkdGhcXFwiKSksYy09Yi5oZWxwZXJzLmdldFBYKGEuY3NzKFxcXCJib3JkZXItdG9wLXdpZHRoXFxcIikpLGIuJGVsLmlzKFxcXCJpbWdcXFwiKSYmKGM9MCxkPTApLHlhLmNzcyhcXFwidG9wXFxcIiwoYi5vcHRzLmlmcmFtZT94YS5vZmZzZXQoKS50b3A6eGEub2Zmc2V0KCkudG9wK2MpLTEpLmNzcyhcXFwibGVmdFxcXCIsKGIub3B0cy5pZnJhbWU/eGEub2Zmc2V0KCkubGVmdDp4YS5vZmZzZXQoKS5sZWZ0K2QpLTEpLmNzcyhcXFwid2lkdGhcXFwiLHhhLmdldCgwKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aCkuY3NzKFxcXCJoZWlnaHRcXFwiLHhhLmdldCgwKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHQpLmFkZENsYXNzKFxcXCJmci1hY3RpdmVcXFwiKX1mdW5jdGlvbiBsKGEpe3JldHVybic8ZGl2IGNsYXNzPVxcXCJmci1oYW5kbGVyIGZyLWgnK2ErJ1xcXCI+PC9kaXY+J31mdW5jdGlvbiBtKGMpe2lmKCFiLmNvcmUuc2FtZUluc3RhbmNlKHlhKSlyZXR1cm4hMDtpZihjLnByZXZlbnREZWZhdWx0KCksYy5zdG9wUHJvcGFnYXRpb24oKSxiLiRlbC5maW5kKFxcXCJpbWcuZnItZXJyb3JcXFwiKS5sZWZ0KXJldHVybiExO2IudW5kby5jYW5EbygpfHxiLnVuZG8uc2F2ZVN0ZXAoKTt2YXIgZD1jLnBhZ2VYfHxjLm9yaWdpbmFsRXZlbnQudG91Y2hlc1swXS5wYWdlWDtpZihcXFwibW91c2Vkb3duXFxcIj09Yy50eXBlKXt2YXIgZT1iLiRvZWwuZ2V0KDApLGY9ZS5vd25lckRvY3VtZW50LGc9Zi5kZWZhdWx0Vmlld3x8Zi5wYXJlbnRXaW5kb3csaD1nLmxvY2F0aW9uIT1nLnBhcmVudC5sb2NhdGlvbjtoJiYoZCs9Yi5oZWxwZXJzLmdldFBYKGEoZy5mcmFtZUVsZW1lbnQpLm9mZnNldCgpLmxlZnQpK2cuZnJhbWVFbGVtZW50LmNsaWVudExlZnQpfXphPWEodGhpcyksemEuZGF0YShcXFwic3RhcnQteFxcXCIsZCksemEuZGF0YShcXFwic3RhcnQtd2lkdGhcXFwiLHhhLndpZHRoKCkpLHphLmRhdGEoXFxcInN0YXJ0LWhlaWdodFxcXCIseGEuaGVpZ2h0KCkpO3ZhciBpPXhhLndpZHRoKCk7aWYoYi5vcHRzLmltYWdlUmVzaXplV2l0aFBlcmNlbnQpe3ZhciBqPXhhLnBhcmVudHNVbnRpbChiLiRlbCxiLmh0bWwuYmxvY2tUYWdzUXVlcnkoKSkuZ2V0KDApfHxiLmVsO3hhLmNzcyhcXFwid2lkdGhcXFwiLChpL2Eoaikub3V0ZXJXaWR0aCgpKjEwMCkudG9GaXhlZCgyKStcXFwiJVxcXCIpfWVsc2UgeGEuY3NzKFxcXCJ3aWR0aFxcXCIsaSk7QWEuc2hvdygpLGIucG9wdXBzLmhpZGVBbGwoKSxpYSgpfWZ1bmN0aW9uIG4oYyl7aWYoIWIuY29yZS5zYW1lSW5zdGFuY2UoeWEpKXJldHVybiEwO3ZhciBkO2lmKHphJiZ4YSl7aWYoYy5wcmV2ZW50RGVmYXVsdCgpLGIuJGVsLmZpbmQoXFxcImltZy5mci1lcnJvclxcXCIpLmxlZnQpcmV0dXJuITE7dmFyIGU9Yy5wYWdlWHx8KGMub3JpZ2luYWxFdmVudC50b3VjaGVzP2Mub3JpZ2luYWxFdmVudC50b3VjaGVzWzBdLnBhZ2VYOm51bGwpO2lmKCFlKXJldHVybiExO3ZhciBmPXphLmRhdGEoXFxcInN0YXJ0LXhcXFwiKSxnPWUtZixoPXphLmRhdGEoXFxcInN0YXJ0LXdpZHRoXFxcIik7aWYoKHphLmhhc0NsYXNzKFxcXCJmci1obndcXFwiKXx8emEuaGFzQ2xhc3MoXFxcImZyLWhzd1xcXCIpKSYmKGc9MC1nKSxiLm9wdHMuaW1hZ2VSZXNpemVXaXRoUGVyY2VudCl7dmFyIGk9eGEucGFyZW50c1VudGlsKGIuJGVsLGIuaHRtbC5ibG9ja1RhZ3NRdWVyeSgpKS5nZXQoMCl8fGIuZWw7aD0oKGgrZykvYShpKS5vdXRlcldpZHRoKCkqMTAwKS50b0ZpeGVkKDIpLGIub3B0cy5pbWFnZVJvdW5kUGVyY2VudCYmKGg9TWF0aC5yb3VuZChoKSkseGEuY3NzKFxcXCJ3aWR0aFxcXCIsaCtcXFwiJVxcXCIpLGQ9KGIuaGVscGVycy5nZXRQWCh4YS5jc3MoXFxcIndpZHRoXFxcIikpL2EoaSkub3V0ZXJXaWR0aCgpKjEwMCkudG9GaXhlZCgyKSxkIT09aCYmeGEuY3NzKFxcXCJ3aWR0aFxcXCIsZCtcXFwiJVxcXCIpLHhhLmNzcyhcXFwiaGVpZ2h0XFxcIixcXFwiXFxcIikucmVtb3ZlQXR0cihcXFwiaGVpZ2h0XFxcIil9ZWxzZSBoK2c+PWIub3B0cy5pbWFnZU1pbldpZHRoJiZ4YS5jc3MoXFxcIndpZHRoXFxcIixoK2cpLGQ9Yi5oZWxwZXJzLmdldFBYKHhhLmNzcyhcXFwid2lkdGhcXFwiKSksZCE9PWgrZyYmeGEuY3NzKFxcXCJ3aWR0aFxcXCIsZCkseGEuY3NzKFxcXCJoZWlnaHRcXFwiLHphLmRhdGEoXFxcInN0YXJ0LWhlaWdodFxcXCIpKnhhLndpZHRoKCkvemEuZGF0YShcXFwic3RhcnQtd2lkdGhcXFwiKSk7aygpLGIuZXZlbnRzLnRyaWdnZXIoXFxcImltYWdlLnJlc2l6ZVxcXCIsW3ZhKCldKX19ZnVuY3Rpb24gbyhhKXtpZighYi5jb3JlLnNhbWVJbnN0YW5jZSh5YSkpcmV0dXJuITA7aWYoemEmJnhhKXtpZihhJiZhLnN0b3BQcm9wYWdhdGlvbigpLGIuJGVsLmZpbmQoXFxcImltZy5mci1lcnJvclxcXCIpLmxlZnQpcmV0dXJuITE7emE9bnVsbCxBYS5oaWRlKCksaygpLGUoKSxiLnVuZG8uc2F2ZVN0ZXAoKSxiLmV2ZW50cy50cmlnZ2VyKFxcXCJpbWFnZS5yZXNpemVFbmRcXFwiLFt2YSgpXSl9fWZ1bmN0aW9uIHAoYSxjKXtiLmVkaXQub24oKSx4YSYmeGEuYWRkQ2xhc3MoXFxcImZyLWVycm9yXFxcIiksdShiLmxhbmd1YWdlLnRyYW5zbGF0ZShcXFwiU29tZXRoaW5nIHdlbnQgd3JvbmcuIFBsZWFzZSB0cnkgYWdhaW4uXFxcIikpLGIuZXZlbnRzLnRyaWdnZXIoXFxcImltYWdlLmVycm9yXFxcIixbe2NvZGU6YSxtZXNzYWdlOkphW2FdfSxjXSl9ZnVuY3Rpb24gcShhKXtpZihhKXJldHVybiBiLiR3cCYmYi5ldmVudHMuJG9uKGIuJHdwLFxcXCJzY3JvbGxcXFwiLGZ1bmN0aW9uKCl7eGEmJmIucG9wdXBzLmlzVmlzaWJsZShcXFwiaW1hZ2UuZWRpdFxcXCIpJiYoYi5ldmVudHMuZGlzYWJsZUJsdXIoKSx3KHhhKSl9KSwhMDt2YXIgYz1cXFwiXFxcIjtpZihiLm9wdHMuaW1hZ2VFZGl0QnV0dG9ucy5sZW5ndGg+MCl7Yys9JzxkaXYgY2xhc3M9XFxcImZyLWJ1dHRvbnNcXFwiPicsYys9Yi5idXR0b24uYnVpbGRMaXN0KGIub3B0cy5pbWFnZUVkaXRCdXR0b25zKSxjKz1cXFwiPC9kaXY+XFxcIjt2YXIgZD17YnV0dG9uczpjfSxlPWIucG9wdXBzLmNyZWF0ZShcXFwiaW1hZ2UuZWRpdFxcXCIsZCk7cmV0dXJuIGV9cmV0dXJuITF9ZnVuY3Rpb24gcihhKXt2YXIgYz1iLnBvcHVwcy5nZXQoXFxcImltYWdlLmluc2VydFxcXCIpO2lmKGN8fChjPU0oKSksYy5maW5kKFxcXCIuZnItbGF5ZXIuZnItYWN0aXZlXFxcIikucmVtb3ZlQ2xhc3MoXFxcImZyLWFjdGl2ZVxcXCIpLmFkZENsYXNzKFxcXCJmci1wYWN0aXZlXFxcIiksYy5maW5kKFxcXCIuZnItaW1hZ2UtcHJvZ3Jlc3MtYmFyLWxheWVyXFxcIikuYWRkQ2xhc3MoXFxcImZyLWFjdGl2ZVxcXCIpLGMuZmluZChcXFwiLmZyLWJ1dHRvbnNcXFwiKS5oaWRlKCkseGEpe2IucG9wdXBzLnNldENvbnRhaW5lcihcXFwiaW1hZ2UuaW5zZXJ0XFxcIixiLiRzYyk7dmFyIGQ9eGEub2Zmc2V0KCkubGVmdCt4YS53aWR0aCgpLzIsZT14YS5vZmZzZXQoKS50b3AreGEuaGVpZ2h0KCk7Yi5wb3B1cHMuc2hvdyhcXFwiaW1hZ2UuaW5zZXJ0XFxcIixkLGUseGEub3V0ZXJIZWlnaHQoKSl9XFxcInVuZGVmaW5lZFxcXCI9PXR5cGVvZiBhJiZ0KFxcXCJVcGxvYWRpbmdcXFwiLDApfWZ1bmN0aW9uIHMoYSl7dmFyIGM9Yi5wb3B1cHMuZ2V0KFxcXCJpbWFnZS5pbnNlcnRcXFwiKTtpZihjJiYoYy5maW5kKFxcXCIuZnItbGF5ZXIuZnItcGFjdGl2ZVxcXCIpLmFkZENsYXNzKFxcXCJmci1hY3RpdmVcXFwiKS5yZW1vdmVDbGFzcyhcXFwiZnItcGFjdGl2ZVxcXCIpLGMuZmluZChcXFwiLmZyLWltYWdlLXByb2dyZXNzLWJhci1sYXllclxcXCIpLnJlbW92ZUNsYXNzKFxcXCJmci1hY3RpdmVcXFwiKSxjLmZpbmQoXFxcIi5mci1idXR0b25zXFxcIikuc2hvdygpLGF8fGIuJGVsLmZpbmQoXFxcImltZy5mci1lcnJvclxcXCIpLmxlbmd0aCkpe2lmKGIuZXZlbnRzLmZvY3VzKCksYi4kZWwuZmluZChcXFwiaW1nLmZyLWVycm9yXFxcIikubGVuZ3RoJiYoYi4kZWwuZmluZChcXFwiaW1nLmZyLWVycm9yXFxcIikucmVtb3ZlKCksYi51bmRvLnNhdmVTdGVwKCksYi51bmRvLnJ1bigpLGIudW5kby5kcm9wUmVkbygpKSwhYi4kd3AmJnhhKXt2YXIgZD14YTtnYSghMCksYi5zZWxlY3Rpb24uc2V0QWZ0ZXIoZC5nZXQoMCkpLGIuc2VsZWN0aW9uLnJlc3RvcmUoKX1iLnBvcHVwcy5oaWRlKFxcXCJpbWFnZS5pbnNlcnRcXFwiKX19ZnVuY3Rpb24gdChhLGMpe3ZhciBkPWIucG9wdXBzLmdldChcXFwiaW1hZ2UuaW5zZXJ0XFxcIik7aWYoZCl7dmFyIGU9ZC5maW5kKFxcXCIuZnItaW1hZ2UtcHJvZ3Jlc3MtYmFyLWxheWVyXFxcIik7ZS5maW5kKFxcXCJoM1xcXCIpLnRleHQoYSsoYz9cXFwiIFxcXCIrYytcXFwiJVxcXCI6XFxcIlxcXCIpKSxlLnJlbW92ZUNsYXNzKFxcXCJmci1lcnJvclxcXCIpLGM/KGUuZmluZChcXFwiZGl2XFxcIikucmVtb3ZlQ2xhc3MoXFxcImZyLWluZGV0ZXJtaW5hdGVcXFwiKSxlLmZpbmQoXFxcImRpdiA+IHNwYW5cXFwiKS5jc3MoXFxcIndpZHRoXFxcIixjK1xcXCIlXFxcIikpOmUuZmluZChcXFwiZGl2XFxcIikuYWRkQ2xhc3MoXFxcImZyLWluZGV0ZXJtaW5hdGVcXFwiKX19ZnVuY3Rpb24gdShhKXtyKCk7dmFyIGM9Yi5wb3B1cHMuZ2V0KFxcXCJpbWFnZS5pbnNlcnRcXFwiKSxkPWMuZmluZChcXFwiLmZyLWltYWdlLXByb2dyZXNzLWJhci1sYXllclxcXCIpO2QuYWRkQ2xhc3MoXFxcImZyLWVycm9yXFxcIik7dmFyIGU9ZC5maW5kKFxcXCJoM1xcXCIpO2UudGV4dChhKSxiLmV2ZW50cy5kaXNhYmxlQmx1cigpLGUuZm9jdXMoKX1mdW5jdGlvbiB2KCl7dmFyIGE9Yi5wb3B1cHMuZ2V0KFxcXCJpbWFnZS5pbnNlcnRcXFwiKSxjPWEuZmluZChcXFwiLmZyLWltYWdlLWJ5LXVybC1sYXllciBpbnB1dFxcXCIpO2MudmFsKCkubGVuZ3RoPjAmJihyKCksdChcXFwiTG9hZGluZyBpbWFnZVxcXCIpLHkoYy52YWwoKSwhMCxbXSx4YSksYy52YWwoXFxcIlxcXCIpLGMuYmx1cigpKX1mdW5jdGlvbiB3KGEpe2ZhLmNhbGwoYS5nZXQoMCkpfWZ1bmN0aW9uIHgoKXt2YXIgYz1hKHRoaXMpO2IucG9wdXBzLmhpZGUoXFxcImltYWdlLmluc2VydFxcXCIpLGMucmVtb3ZlQ2xhc3MoXFxcImZyLXVwbG9hZGluZ1xcXCIpLGMubmV4dCgpLmlzKFxcXCJiclxcXCIpJiZjLm5leHQoKS5yZW1vdmUoKSx3KGMpLGIuZXZlbnRzLnRyaWdnZXIoXFxcImltYWdlLmxvYWRlZFxcXCIsW2NdKX1mdW5jdGlvbiB5KGEsYyxkLGUsZil7Yi5lZGl0Lm9mZigpLHQoXFxcIkxvYWRpbmcgaW1hZ2VcXFwiKSxjJiYoYT1iLmhlbHBlcnMuc2FuaXRpemVVUkwoYSkpO3ZhciBnPW5ldyBJbWFnZTtnLm9ubG9hZD1mdW5jdGlvbigpe3ZhciBjLGc7aWYoZSl7Yi51bmRvLmNhbkRvKCl8fGUuaGFzQ2xhc3MoXFxcImZyLXVwbG9hZGluZ1xcXCIpfHxiLnVuZG8uc2F2ZVN0ZXAoKTt2YXIgaD1lLmRhdGEoXFxcImZyLW9sZC1zcmNcXFwiKTtiLiR3cD8oYz1lLmNsb25lKCkucmVtb3ZlRGF0YShcXFwiZnItb2xkLXNyY1xcXCIpLnJlbW92ZUNsYXNzKFxcXCJmci11cGxvYWRpbmdcXFwiKSxjLm9mZihcXFwibG9hZFxcXCIpLGgmJmUuYXR0cihcXFwic3JjXFxcIixoKSxlLnJlcGxhY2VXaXRoKGMpKTpjPWU7Zm9yKHZhciBpPWMuZ2V0KDApLmF0dHJpYnV0ZXMsaz0wO2s8aS5sZW5ndGg7aysrKXt2YXIgbD1pW2tdOzA9PT1sLm5vZGVOYW1lLmluZGV4T2YoXFxcImRhdGEtXFxcIikmJmMucmVtb3ZlQXR0cihsLm5vZGVOYW1lKX1pZihcXFwidW5kZWZpbmVkXFxcIiE9dHlwZW9mIGQpZm9yKGcgaW4gZClkLmhhc093blByb3BlcnR5KGcpJiZcXFwibGlua1xcXCIhPWcmJmMuYXR0cihcXFwiZGF0YS1cXFwiK2csZFtnXSk7Yy5vbihcXFwibG9hZFxcXCIseCksYy5hdHRyKFxcXCJzcmNcXFwiLGEpLGIuZWRpdC5vbigpLGooKSxiLnVuZG8uc2F2ZVN0ZXAoKSxiLiRlbC5ibHVyKCksYi5ldmVudHMudHJpZ2dlcihoP1xcXCJpbWFnZS5yZXBsYWNlZFxcXCI6XFxcImltYWdlLmluc2VydGVkXFxcIixbYyxmXSl9ZWxzZSBjPUUoYSxkLHgpLGooKSxiLnVuZG8uc2F2ZVN0ZXAoKSxiLmV2ZW50cy50cmlnZ2VyKFxcXCJpbWFnZS5pbnNlcnRlZFxcXCIsW2MsZl0pfSxnLm9uZXJyb3I9ZnVuY3Rpb24oKXtwKENhKX0scihcXFwiTG9hZGluZyBpbWFnZVxcXCIpLGcuc3JjPWF9ZnVuY3Rpb24geihjKXt0cnl7aWYoYi5ldmVudHMudHJpZ2dlcihcXFwiaW1hZ2UudXBsb2FkZWRcXFwiLFtjXSwhMCk9PT0hMSlyZXR1cm4gYi5lZGl0Lm9uKCksITE7dmFyIGQ9YS5wYXJzZUpTT04oYyk7cmV0dXJuIGQubGluaz9kOihwKERhLGMpLCExKX1jYXRjaChlKXtyZXR1cm4gcChGYSxjKSwhMX19ZnVuY3Rpb24gQShjKXt0cnl7dmFyIGQ9YShjKS5maW5kKFxcXCJMb2NhdGlvblxcXCIpLnRleHQoKSxlPWEoYykuZmluZChcXFwiS2V5XFxcIikudGV4dCgpO3JldHVybiBiLmV2ZW50cy50cmlnZ2VyKFxcXCJpbWFnZS51cGxvYWRlZFRvUzNcXFwiLFtkLGUsY10sITApPT09ITE/KGIuZWRpdC5vbigpLCExKTpkfWNhdGNoKGYpe3JldHVybiBwKEZhLGMpLCExfX1mdW5jdGlvbiBCKGEpe3QoXFxcIkxvYWRpbmcgaW1hZ2VcXFwiKTt2YXIgYz10aGlzLnN0YXR1cyxkPXRoaXMucmVzcG9uc2UsZT10aGlzLnJlc3BvbnNlWE1MLGY9dGhpcy5yZXNwb25zZVRleHQ7dHJ5e2lmKGIub3B0cy5pbWFnZVVwbG9hZFRvUzMpaWYoMjAxPT1jKXt2YXIgZz1BKGUpO2cmJnkoZywhMSxbXSxhLGR8fGUpfWVsc2UgcChGYSxkfHxlKTtlbHNlIGlmKGM+PTIwMCYmYzwzMDApe3ZhciBoPXooZik7aCYmeShoLmxpbmssITEsaCxhLGR8fGYpfWVsc2UgcChFYSxkfHxmKX1jYXRjaChpKXtwKEZhLGR8fGYpfX1mdW5jdGlvbiBDKCl7cChGYSx0aGlzLnJlc3BvbnNlfHx0aGlzLnJlc3BvbnNlVGV4dHx8dGhpcy5yZXNwb25zZVhNTCl9ZnVuY3Rpb24gRChhKXtpZihhLmxlbmd0aENvbXB1dGFibGUpe3ZhciBiPWEubG9hZGVkL2EudG90YWwqMTAwfDA7dChcXFwiVXBsb2FkaW5nXFxcIixiKX19ZnVuY3Rpb24gRShjLGQsZSl7dmFyIGYsZz1cXFwiXFxcIjtpZihkJiZcXFwidW5kZWZpbmVkXFxcIiE9dHlwZW9mIGQpZm9yKGYgaW4gZClkLmhhc093blByb3BlcnR5KGYpJiZcXFwibGlua1xcXCIhPWYmJihnKz1cXFwiIGRhdGEtXFxcIitmKyc9XFxcIicrZFtmXSsnXFxcIicpO3ZhciBoPWIub3B0cy5pbWFnZURlZmF1bHRXaWR0aDtoJiZcXFwiYXV0b1xcXCIhPWgmJihoKz1iLm9wdHMuaW1hZ2VSZXNpemVXaXRoUGVyY2VudD9cXFwiJVxcXCI6XFxcInB4XFxcIik7dmFyIGk9YSgnPGltZyBzcmM9XFxcIicrYysnXFxcIicrZysoaD8nIHN0eWxlPVxcXCJ3aWR0aDogJytoKyc7XFxcIic6XFxcIlxcXCIpK1xcXCI+XFxcIik7a2EoaSxiLm9wdHMuaW1hZ2VEZWZhdWx0RGlzcGxheSxiLm9wdHMuaW1hZ2VEZWZhdWx0QWxpZ24pLGkub24oXFxcImxvYWRcXFwiLGUpLGIuZWRpdC5vbigpLGIuZXZlbnRzLmZvY3VzKCEwKSxiLnNlbGVjdGlvbi5yZXN0b3JlKCksYi51bmRvLnNhdmVTdGVwKCksYi5vcHRzLmltYWdlU3BsaXRIVE1MP2IubWFya2Vycy5zcGxpdCgpOmIubWFya2Vycy5pbnNlcnQoKTt2YXIgaj1iLiRlbC5maW5kKFxcXCIuZnItbWFya2VyXFxcIik7cmV0dXJuIGoucGFyZW50KCkuaXMoXFxcImhyXFxcIikmJmoucGFyZW50KCkuYWZ0ZXIoaiksYi5ub2RlLmlzTGFzdFNpYmxpbmcoaikmJmoucGFyZW50KCkuaGFzQ2xhc3MoXFxcImZyLWRlbGV0YWJsZVxcXCIpJiZqLmluc2VydEFmdGVyKGoucGFyZW50KCkpLGoucmVwbGFjZVdpdGgoaSksYi5odG1sLndyYXAoKSxiLnNlbGVjdGlvbi5jbGVhcigpLGl9ZnVuY3Rpb24gRigpe2IuZWRpdC5vbigpLHMoITApfWZ1bmN0aW9uIEcoYyxkLGUsZil7ZnVuY3Rpb24gZygpe3ZhciBlPWEodGhpcyk7ZS5vZmYoXFxcImxvYWRcXFwiKSxlLmFkZENsYXNzKFxcXCJmci11cGxvYWRpbmdcXFwiKSxlLm5leHQoKS5pcyhcXFwiYnJcXFwiKSYmZS5uZXh0KCkucmVtb3ZlKCksYi5wbGFjZWhvbGRlci5yZWZyZXNoKCksZS5pcyhmKXx8dyhlKSxrKCkscigpLGIuZWRpdC5vZmYoKSxjLm9ubG9hZD1mdW5jdGlvbigpe0IuY2FsbChjLGUpfSxjLm9uZXJyb3I9QyxjLnVwbG9hZC5vbnByb2dyZXNzPUQsYy5vbmFib3J0PUYsZS5vZmYoXFxcImFib3J0VXBsb2FkXFxcIikub24oXFxcImFib3J0VXBsb2FkXFxcIixmdW5jdGlvbigpezQhPWMucmVhZHlTdGF0ZSYmYy5hYm9ydCgpfSksYy5zZW5kKGQpfXZhciBoLGk9bmV3IEZpbGVSZWFkZXI7aS5hZGRFdmVudExpc3RlbmVyKFxcXCJsb2FkXFxcIixmdW5jdGlvbigpe3ZhciBhPWkucmVzdWx0O2lmKGkucmVzdWx0LmluZGV4T2YoXFxcInN2Zyt4bWxcXFwiKTwwKXtmb3IodmFyIGM9YXRvYihpLnJlc3VsdC5zcGxpdChcXFwiLFxcXCIpWzFdKSxkPVtdLGU9MDtlPGMubGVuZ3RoO2UrKylkLnB1c2goYy5jaGFyQ29kZUF0KGUpKTthPXdpbmRvdy5VUkwuY3JlYXRlT2JqZWN0VVJMKG5ldyBCbG9iKFtuZXcgVWludDhBcnJheShkKV0se3R5cGU6XFxcImltYWdlL2pwZWdcXFwifSkpfWY/KGYub24oXFxcImxvYWRcXFwiLGcpLGIuZWRpdC5vbigpLGIudW5kby5zYXZlU3RlcCgpLGYuZGF0YShcXFwiZnItb2xkLXNyY1xcXCIsZi5hdHRyKFxcXCJzcmNcXFwiKSksZi5hdHRyKFxcXCJzcmNcXFwiLGEpKTpoPUUoYSxudWxsLGcpfSwhMSksaS5yZWFkQXNEYXRhVVJMKGUpfWZ1bmN0aW9uIEgoYSxjKXtpZihcXFwidW5kZWZpbmVkXFxcIiE9dHlwZW9mIGEmJmEubGVuZ3RoPjApe2lmKGIuZXZlbnRzLnRyaWdnZXIoXFxcImltYWdlLmJlZm9yZVVwbG9hZFxcXCIsW2FdKT09PSExKXJldHVybiExO3ZhciBkPWFbMF07aWYoZC5zaXplPmIub3B0cy5pbWFnZU1heFNpemUpcmV0dXJuIHAoR2EpLCExO2lmKGIub3B0cy5pbWFnZUFsbG93ZWRUeXBlcy5pbmRleE9mKGQudHlwZS5yZXBsYWNlKC9pbWFnZVxcXFwvL2csXFxcIlxcXCIpKTwwKXJldHVybiBwKEhhKSwhMTt2YXIgZTtpZihiLmRyYWdfc3VwcG9ydC5mb3JtZGF0YSYmKGU9Yi5kcmFnX3N1cHBvcnQuZm9ybWRhdGE/bmV3IEZvcm1EYXRhOm51bGwpLGUpe3ZhciBmO2lmKGIub3B0cy5pbWFnZVVwbG9hZFRvUzMhPT0hMSl7ZS5hcHBlbmQoXFxcImtleVxcXCIsYi5vcHRzLmltYWdlVXBsb2FkVG9TMy5rZXlTdGFydCsobmV3IERhdGUpLmdldFRpbWUoKStcXFwiLVxcXCIrKGQubmFtZXx8XFxcInVudGl0bGVkXFxcIikpLGUuYXBwZW5kKFxcXCJzdWNjZXNzX2FjdGlvbl9zdGF0dXNcXFwiLFxcXCIyMDFcXFwiKSxlLmFwcGVuZChcXFwiWC1SZXF1ZXN0ZWQtV2l0aFxcXCIsXFxcInhoclxcXCIpLGUuYXBwZW5kKFxcXCJDb250ZW50LVR5cGVcXFwiLGQudHlwZSk7Zm9yKGYgaW4gYi5vcHRzLmltYWdlVXBsb2FkVG9TMy5wYXJhbXMpYi5vcHRzLmltYWdlVXBsb2FkVG9TMy5wYXJhbXMuaGFzT3duUHJvcGVydHkoZikmJmUuYXBwZW5kKGYsYi5vcHRzLmltYWdlVXBsb2FkVG9TMy5wYXJhbXNbZl0pfWZvcihmIGluIGIub3B0cy5pbWFnZVVwbG9hZFBhcmFtcyliLm9wdHMuaW1hZ2VVcGxvYWRQYXJhbXMuaGFzT3duUHJvcGVydHkoZikmJmUuYXBwZW5kKGYsYi5vcHRzLmltYWdlVXBsb2FkUGFyYW1zW2ZdKTtlLmFwcGVuZChiLm9wdHMuaW1hZ2VVcGxvYWRQYXJhbSxkKTt2YXIgZz1iLm9wdHMuaW1hZ2VVcGxvYWRVUkw7Yi5vcHRzLmltYWdlVXBsb2FkVG9TMyYmKGc9Yi5vcHRzLmltYWdlVXBsb2FkVG9TMy51cGxvYWRVUkw/Yi5vcHRzLmltYWdlVXBsb2FkVG9TMy51cGxvYWRVUkw6XFxcImh0dHBzOi8vXFxcIitiLm9wdHMuaW1hZ2VVcGxvYWRUb1MzLnJlZ2lvbitcXFwiLmFtYXpvbmF3cy5jb20vXFxcIitiLm9wdHMuaW1hZ2VVcGxvYWRUb1MzLmJ1Y2tldCk7dmFyIGg9Yi5jb3JlLmdldFhIUihnLGIub3B0cy5pbWFnZVVwbG9hZE1ldGhvZCk7RyhoLGUsZCxjfHx4YSl9fX1mdW5jdGlvbiBJKGMpe2IuZXZlbnRzLiRvbihjLFxcXCJkcmFnb3ZlciBkcmFnZW50ZXJcXFwiLFxcXCIuZnItaW1hZ2UtdXBsb2FkLWxheWVyXFxcIixmdW5jdGlvbigpe3JldHVybiBhKHRoaXMpLmFkZENsYXNzKFxcXCJmci1kcm9wXFxcIiksITF9KSxiLmV2ZW50cy4kb24oYyxcXFwiZHJhZ2xlYXZlIGRyYWdlbmRcXFwiLFxcXCIuZnItaW1hZ2UtdXBsb2FkLWxheWVyXFxcIixmdW5jdGlvbigpe3JldHVybiBhKHRoaXMpLnJlbW92ZUNsYXNzKFxcXCJmci1kcm9wXFxcIiksITF9KSxiLmV2ZW50cy4kb24oYyxcXFwiZHJvcFxcXCIsXFxcIi5mci1pbWFnZS11cGxvYWQtbGF5ZXJcXFwiLGZ1bmN0aW9uKGQpe2QucHJldmVudERlZmF1bHQoKSxkLnN0b3BQcm9wYWdhdGlvbigpLGEodGhpcykucmVtb3ZlQ2xhc3MoXFxcImZyLWRyb3BcXFwiKTt2YXIgZT1kLm9yaWdpbmFsRXZlbnQuZGF0YVRyYW5zZmVyO2lmKGUmJmUuZmlsZXMpe3ZhciBmPWMuZGF0YShcXFwiaW5zdGFuY2VcXFwiKXx8YjtmLmV2ZW50cy5kaXNhYmxlQmx1cigpLGYuaW1hZ2UudXBsb2FkKGUuZmlsZXMpLGYuZXZlbnRzLmVuYWJsZUJsdXIoKX19KSxiLmV2ZW50cy4kb24oYyxcXFwiY2hhbmdlXFxcIiwnLmZyLWltYWdlLXVwbG9hZC1sYXllciBpbnB1dFt0eXBlPVxcXCJmaWxlXFxcIl0nLGZ1bmN0aW9uKCl7aWYodGhpcy5maWxlcyl7dmFyIGQ9Yy5kYXRhKFxcXCJpbnN0YW5jZVxcXCIpfHxiO2QuZXZlbnRzLmRpc2FibGVCbHVyKCksYy5maW5kKFxcXCJpbnB1dDpmb2N1c1xcXCIpLmJsdXIoKSxkLmV2ZW50cy5lbmFibGVCbHVyKCksZC5pbWFnZS51cGxvYWQodGhpcy5maWxlcyl9YSh0aGlzKS52YWwoXFxcIlxcXCIpfSl9ZnVuY3Rpb24gSihjKXt2YXIgZD1jLm9yaWdpbmFsRXZlbnQuZGF0YVRyYW5zZmVyO2lmKGQmJmQuZmlsZXMmJmQuZmlsZXMubGVuZ3RoKXt2YXIgZT1kLmZpbGVzWzBdO2lmKGUmJmUudHlwZSYmZS50eXBlLmluZGV4T2YoXFxcImltYWdlXFxcIikhPT0tMSl7Yi5tYXJrZXJzLnJlbW92ZSgpLGIubWFya2Vycy5pbnNlcnRBdFBvaW50KGMub3JpZ2luYWxFdmVudCksYi4kZWwuZmluZChcXFwiLmZyLW1hcmtlclxcXCIpLnJlcGxhY2VXaXRoKGEuRkUuTUFSS0VSUyksYi5wb3B1cHMuaGlkZUFsbCgpO3ZhciBmPWIucG9wdXBzLmdldChcXFwiaW1hZ2UuaW5zZXJ0XFxcIik7cmV0dXJuIGZ8fChmPU0oKSksYi5wb3B1cHMuc2V0Q29udGFpbmVyKFxcXCJpbWFnZS5pbnNlcnRcXFwiLGIuJHNjKSxiLnBvcHVwcy5zaG93KFxcXCJpbWFnZS5pbnNlcnRcXFwiLGMub3JpZ2luYWxFdmVudC5wYWdlWCxjLm9yaWdpbmFsRXZlbnQucGFnZVkpLHIoKSxiLm9wdHMuaW1hZ2VBbGxvd2VkVHlwZXMuaW5kZXhPZihlLnR5cGUucmVwbGFjZSgvaW1hZ2VcXFxcLy9nLFxcXCJcXFwiKSk+PTA/SChkLmZpbGVzKTpwKEhhKSxjLnByZXZlbnREZWZhdWx0KCksYy5zdG9wUHJvcGFnYXRpb24oKSwhMX19fWZ1bmN0aW9uIEsoKXt2YXIgYyxkLGU9Yi5zZWxlY3Rpb24ucmFuZ2VzKDApO2UuY29sbGFwc2VkJiZlLnN0YXJ0Q29udGFpbmVyLm5vZGVUeXBlPT1Ob2RlLkVMRU1FTlRfTk9ERSYmKGUuc3RhcnRDb250YWluZXIuY2hpbGROb2Rlcy5sZW5ndGg9PWUuc3RhcnRPZmZzZXQ/KGM9ZS5zdGFydENvbnRhaW5lci5jaGlsZE5vZGVzW2Uuc3RhcnRPZmZzZXQtMV0sYyYmXFxcIklNR1xcXCI9PWMudGFnTmFtZSYmXFxcImJsb2NrXFxcIj09YShjKS5jc3MoXFxcImRpc3BsYXlcXFwiKSYmKGQ9Yi5ub2RlLmJsb2NrUGFyZW50KGMpLGQmJmIuaHRtbC5kZWZhdWx0VGFnKCk/ZC5uZXh0U2libGluZ3x8KFtcXFwiVERcXFwiLFxcXCJUSFxcXCJdLmluZGV4T2YoZC50YWdOYW1lKTwwP2EoZCkuYWZ0ZXIoXFxcIjxcXFwiK2IuaHRtbC5kZWZhdWx0VGFnKCkrXFxcIj48YnI+XFxcIithLkZFLk1BUktFUlMrXFxcIjwvXFxcIitiLmh0bWwuZGVmYXVsdFRhZygpK1xcXCI+XFxcIik6YShjKS5hZnRlcihcXFwiPGJyPlxcXCIrYS5GRS5NQVJLRVJTKSxiLnNlbGVjdGlvbi5yZXN0b3JlKCkpOmR8fChhKGMpLmFmdGVyKFxcXCI8YnI+XFxcIithLkZFLk1BUktFUlMpLGIuc2VsZWN0aW9uLnJlc3RvcmUoKSkpKTowPT09ZS5zdGFydE9mZnNldCYmZS5zdGFydENvbnRhaW5lci5jaGlsZE5vZGVzLmxlbmd0aD5lLnN0YXJ0T2Zmc2V0JiYoYz1lLnN0YXJ0Q29udGFpbmVyLmNoaWxkTm9kZXNbZS5zdGFydE9mZnNldF0sYyYmXFxcIklNR1xcXCI9PWMudGFnTmFtZSYmXFxcImJsb2NrXFxcIj09YShjKS5jc3MoXFxcImRpc3BsYXlcXFwiKSYmKGQ9Yi5ub2RlLmJsb2NrUGFyZW50KGMpLGQmJmIuaHRtbC5kZWZhdWx0VGFnKCk/ZC5wcmV2aW91c1NpYmxpbmd8fChbXFxcIlREXFxcIixcXFwiVEhcXFwiXS5pbmRleE9mKGQudGFnTmFtZSk8MD9hKGQpLmJlZm9yZShcXFwiPFxcXCIrYi5odG1sLmRlZmF1bHRUYWcoKStcXFwiPjxicj5cXFwiK2EuRkUuTUFSS0VSUytcXFwiPC9cXFwiK2IuaHRtbC5kZWZhdWx0VGFnKCkrXFxcIj5cXFwiKTphKGMpLmJlZm9yZShcXFwiPGJyPlxcXCIrYS5GRS5NQVJLRVJTKSxiLnNlbGVjdGlvbi5yZXN0b3JlKCkpOmR8fChhKGMpLmJlZm9yZShhLkZFLk1BUktFUlMrXFxcIjxicj5cXFwiKSxiLnNlbGVjdGlvbi5yZXN0b3JlKCkpKSkpfWZ1bmN0aW9uIEwoKXtiLmV2ZW50cy4kb24oYi4kZWwsYi5fbW91c2Vkb3duLFxcXCJJTUdcXFwiPT1iLmVsLnRhZ05hbWU/bnVsbDonaW1nOm5vdChbY29udGVudGVkaXRhYmxlPVxcXCJmYWxzZVxcXCJdKScsZnVuY3Rpb24oYyl7cmV0dXJuXFxcImZhbHNlXFxcIj09YSh0aGlzKS5wYXJlbnRzKFxcXCJbY29udGVudGVkaXRhYmxlXTpub3QoLmZyLWVsZW1lbnQpOm5vdChib2R5KTpmaXJzdFxcXCIpLmF0dHIoXFxcImNvbnRlbnRlZGl0YWJsZVxcXCIpfHwoYi5oZWxwZXJzLmlzTW9iaWxlKCl8fGIuc2VsZWN0aW9uLmNsZWFyKCksQmE9ITAsYi5wb3B1cHMuYXJlVmlzaWJsZSgpJiZiLmV2ZW50cy5kaXNhYmxlQmx1cigpLGIuYnJvd3Nlci5tc2llJiYoYi5ldmVudHMuZGlzYWJsZUJsdXIoKSxiLiRlbC5hdHRyKFxcXCJjb250ZW50ZWRpdGFibGVcXFwiLCExKSksYi5kcmFnZ2FibGV8fGMucHJldmVudERlZmF1bHQoKSx2b2lkIGMuc3RvcFByb3BhZ2F0aW9uKCkpfSksYi5ldmVudHMuJG9uKGIuJGVsLGIuX21vdXNldXAsXFxcIklNR1xcXCI9PWIuZWwudGFnTmFtZT9udWxsOidpbWc6bm90KFtjb250ZW50ZWRpdGFibGU9XFxcImZhbHNlXFxcIl0pJyxmdW5jdGlvbihjKXtyZXR1cm5cXFwiZmFsc2VcXFwiPT1hKHRoaXMpLnBhcmVudHMoXFxcIltjb250ZW50ZWRpdGFibGVdOm5vdCguZnItZWxlbWVudCk6bm90KGJvZHkpOmZpcnN0XFxcIikuYXR0cihcXFwiY29udGVudGVkaXRhYmxlXFxcIil8fHZvaWQoQmEmJihCYT0hMSxjLnN0b3BQcm9wYWdhdGlvbigpLGIuYnJvd3Nlci5tc2llJiYoYi4kZWwuYXR0cihcXFwiY29udGVudGVkaXRhYmxlXFxcIiwhMCksYi5ldmVudHMuZW5hYmxlQmx1cigpKSkpfSksYi5ldmVudHMub24oXFxcImtleXVwXFxcIixmdW5jdGlvbihjKXtpZihjLnNoaWZ0S2V5JiZcXFwiXFxcIj09PWIuc2VsZWN0aW9uLnRleHQoKS5yZXBsYWNlKC9cXFxcbi9nLFxcXCJcXFwiKSl7dmFyIGQ9Yi5zZWxlY3Rpb24uZWxlbWVudCgpLGU9Yi5zZWxlY3Rpb24uZW5kRWxlbWVudCgpO2QmJlxcXCJJTUdcXFwiPT1kLnRhZ05hbWU/dyhhKGQpKTplJiZcXFwiSU1HXFxcIj09ZS50YWdOYW1lJiZ3KGEoZSkpfX0sITApLGIuZXZlbnRzLm9uKFxcXCJkcm9wXFxcIixKKSxiLmV2ZW50cy5vbihcXFwibW91c2Vkb3duIHdpbmRvdy5tb3VzZWRvd25cXFwiLGhhKSxiLmV2ZW50cy5vbihcXFwid2luZG93LnRvdWNobW92ZVxcXCIsaWEpLGIuZXZlbnRzLm9uKFxcXCJtb3VzZXVwIHdpbmRvdy5tb3VzZXVwXFxcIixmdW5jdGlvbigpe3JldHVybiB4YT8oZ2EoKSwhMSk6dm9pZCBpYSgpfSksYi5ldmVudHMub24oXFxcImNvbW1hbmRzLm1vdXNlZG93blxcXCIsZnVuY3Rpb24oYSl7YS5wYXJlbnRzKFxcXCIuZnItdG9vbGJhclxcXCIpLmxlbmd0aD4wJiZnYSgpfSksYi5icm93c2VyLmVkZ2V8fGIuZXZlbnRzLm9uKFxcXCJtb3VzZXVwXFxcIixLKSxiLmV2ZW50cy5vbihcXFwiYmx1ciBpbWFnZS5oaWRlUmVzaXplciBjb21tYW5kcy51bmRvIGNvbW1hbmRzLnJlZG8gZWxlbWVudC5kcm9wcGVkXFxcIixmdW5jdGlvbigpe0JhPSExLGdhKCEwKX0pLGIuZXZlbnRzLm9uKFxcXCJtb2RhbHMuaGlkZVxcXCIsZnVuY3Rpb24oKXt4YSYmKHRhKCksYi5zZWxlY3Rpb24uY2xlYXIoKSl9KX1mdW5jdGlvbiBNKGEpe2lmKGEpcmV0dXJuIGIucG9wdXBzLm9uUmVmcmVzaChcXFwiaW1hZ2UuaW5zZXJ0XFxcIixjKSxiLnBvcHVwcy5vbkhpZGUoXFxcImltYWdlLmluc2VydFxcXCIsZiksITA7dmFyIGQsZT1cXFwiXFxcIjtiLm9wdHMuaW1hZ2VJbnNlcnRCdXR0b25zLmxlbmd0aD4xJiYoZT0nPGRpdiBjbGFzcz1cXFwiZnItYnV0dG9uc1xcXCI+JytiLmJ1dHRvbi5idWlsZExpc3QoYi5vcHRzLmltYWdlSW5zZXJ0QnV0dG9ucykrXFxcIjwvZGl2PlxcXCIpO3ZhciBnPWIub3B0cy5pbWFnZUluc2VydEJ1dHRvbnMuaW5kZXhPZihcXFwiaW1hZ2VVcGxvYWRcXFwiKSxoPWIub3B0cy5pbWFnZUluc2VydEJ1dHRvbnMuaW5kZXhPZihcXFwiaW1hZ2VCeVVSTFxcXCIpLGk9XFxcIlxcXCI7Zz49MCYmKGQ9XFxcIiBmci1hY3RpdmVcXFwiLGg+PTAmJmc+aCYmKGQ9XFxcIlxcXCIpLGk9JzxkaXYgY2xhc3M9XFxcImZyLWltYWdlLXVwbG9hZC1sYXllcicrZCsnIGZyLWxheWVyXFxcIiBpZD1cXFwiZnItaW1hZ2UtdXBsb2FkLWxheWVyLScrYi5pZCsnXFxcIj48c3Ryb25nPicrYi5sYW5ndWFnZS50cmFuc2xhdGUoXFxcIkRyb3AgaW1hZ2VcXFwiKStcXFwiPC9zdHJvbmc+PGJyPihcXFwiK2IubGFuZ3VhZ2UudHJhbnNsYXRlKFxcXCJvciBjbGlja1xcXCIpKycpPGRpdiBjbGFzcz1cXFwiZnItZm9ybVxcXCI+PGlucHV0IHR5cGU9XFxcImZpbGVcXFwiIGFjY2VwdD1cXFwiaW1hZ2UvJytiLm9wdHMuaW1hZ2VBbGxvd2VkVHlwZXMuam9pbihcXFwiLCBpbWFnZS9cXFwiKS50b0xvd2VyQ2FzZSgpKydcXFwiIHRhYkluZGV4PVxcXCItMVxcXCIgYXJpYS1sYWJlbGxlZGJ5PVxcXCJmci1pbWFnZS11cGxvYWQtbGF5ZXItJytiLmlkKydcXFwiIHJvbGU9XFxcImJ1dHRvblxcXCI+PC9kaXY+PC9kaXY+Jyk7dmFyIGo9XFxcIlxcXCI7aD49MCYmKGQ9XFxcIiBmci1hY3RpdmVcXFwiLGc+PTAmJmg+ZyYmKGQ9XFxcIlxcXCIpLGo9JzxkaXYgY2xhc3M9XFxcImZyLWltYWdlLWJ5LXVybC1sYXllcicrZCsnIGZyLWxheWVyXFxcIiBpZD1cXFwiZnItaW1hZ2UtYnktdXJsLWxheWVyLScrYi5pZCsnXFxcIj48ZGl2IGNsYXNzPVxcXCJmci1pbnB1dC1saW5lXFxcIj48aW5wdXQgaWQ9XFxcImZyLWltYWdlLWJ5LXVybC1sYXllci10ZXh0LScrYi5pZCsnXFxcIiB0eXBlPVxcXCJ0ZXh0XFxcIiBwbGFjZWhvbGRlcj1cXFwiaHR0cDovL1xcXCIgdGFiSW5kZXg9XFxcIjFcXFwiIGFyaWEtcmVxdWlyZWQ9XFxcInRydWVcXFwiPjwvZGl2PjxkaXYgY2xhc3M9XFxcImZyLWFjdGlvbi1idXR0b25zXFxcIj48YnV0dG9uIHR5cGU9XFxcImJ1dHRvblxcXCIgY2xhc3M9XFxcImZyLWNvbW1hbmQgZnItc3VibWl0XFxcIiBkYXRhLWNtZD1cXFwiaW1hZ2VJbnNlcnRCeVVSTFxcXCIgdGFiSW5kZXg9XFxcIjJcXFwiIHJvbGU9XFxcImJ1dHRvblxcXCI+JytiLmxhbmd1YWdlLnRyYW5zbGF0ZShcXFwiSW5zZXJ0XFxcIikrXFxcIjwvYnV0dG9uPjwvZGl2PjwvZGl2PlxcXCIpO3ZhciBrPSc8ZGl2IGNsYXNzPVxcXCJmci1pbWFnZS1wcm9ncmVzcy1iYXItbGF5ZXIgZnItbGF5ZXJcXFwiPjxoMyB0YWJJbmRleD1cXFwiLTFcXFwiIGNsYXNzPVxcXCJmci1tZXNzYWdlXFxcIj5VcGxvYWRpbmc8L2gzPjxkaXYgY2xhc3M9XFxcImZyLWxvYWRlclxcXCI+PHNwYW4gY2xhc3M9XFxcImZyLXByb2dyZXNzXFxcIj48L3NwYW4+PC9kaXY+PGRpdiBjbGFzcz1cXFwiZnItYWN0aW9uLWJ1dHRvbnNcXFwiPjxidXR0b24gdHlwZT1cXFwiYnV0dG9uXFxcIiBjbGFzcz1cXFwiZnItY29tbWFuZCBmci1kaXNtaXNzXFxcIiBkYXRhLWNtZD1cXFwiaW1hZ2VEaXNtaXNzRXJyb3JcXFwiIHRhYkluZGV4PVxcXCIyXFxcIiByb2xlPVxcXCJidXR0b25cXFwiPk9LPC9idXR0b24+PC9kaXY+PC9kaXY+JyxsPXtidXR0b25zOmUsdXBsb2FkX2xheWVyOmksYnlfdXJsX2xheWVyOmoscHJvZ3Jlc3NfYmFyOmt9LG09Yi5wb3B1cHMuY3JlYXRlKFxcXCJpbWFnZS5pbnNlcnRcXFwiLGwpO3JldHVybiBiLiR3cCYmYi5ldmVudHMuJG9uKGIuJHdwLFxcXCJzY3JvbGxcXFwiLGZ1bmN0aW9uKCl7eGEmJmIucG9wdXBzLmlzVmlzaWJsZShcXFwiaW1hZ2UuaW5zZXJ0XFxcIikmJnNhKCl9KSxJKG0pLG19ZnVuY3Rpb24gTigpe2lmKHhhKXt2YXIgYT1iLnBvcHVwcy5nZXQoXFxcImltYWdlLmFsdFxcXCIpO2EuZmluZChcXFwiaW5wdXRcXFwiKS52YWwoeGEuYXR0cihcXFwiYWx0XFxcIil8fFxcXCJcXFwiKS50cmlnZ2VyKFxcXCJjaGFuZ2VcXFwiKX19ZnVuY3Rpb24gTygpe3ZhciBhPWIucG9wdXBzLmdldChcXFwiaW1hZ2UuYWx0XFxcIik7YXx8KGE9UCgpKSxzKCksYi5wb3B1cHMucmVmcmVzaChcXFwiaW1hZ2UuYWx0XFxcIiksYi5wb3B1cHMuc2V0Q29udGFpbmVyKFxcXCJpbWFnZS5hbHRcXFwiLGIuJHNjKTt2YXIgYz14YS5vZmZzZXQoKS5sZWZ0K3hhLndpZHRoKCkvMixkPXhhLm9mZnNldCgpLnRvcCt4YS5oZWlnaHQoKTtiLnBvcHVwcy5zaG93KFxcXCJpbWFnZS5hbHRcXFwiLGMsZCx4YS5vdXRlckhlaWdodCgpKX1mdW5jdGlvbiBQKGEpe2lmKGEpcmV0dXJuIGIucG9wdXBzLm9uUmVmcmVzaChcXFwiaW1hZ2UuYWx0XFxcIixOKSwhMDt2YXIgYz1cXFwiXFxcIjtjPSc8ZGl2IGNsYXNzPVxcXCJmci1idXR0b25zXFxcIj4nK2IuYnV0dG9uLmJ1aWxkTGlzdChiLm9wdHMuaW1hZ2VBbHRCdXR0b25zKStcXFwiPC9kaXY+XFxcIjt2YXIgZD1cXFwiXFxcIjtkPSc8ZGl2IGNsYXNzPVxcXCJmci1pbWFnZS1hbHQtbGF5ZXIgZnItbGF5ZXIgZnItYWN0aXZlXFxcIiBpZD1cXFwiZnItaW1hZ2UtYWx0LWxheWVyLScrYi5pZCsnXFxcIj48ZGl2IGNsYXNzPVxcXCJmci1pbnB1dC1saW5lXFxcIj48aW5wdXQgaWQ9XFxcImZyLWltYWdlLWFsdC1sYXllci10ZXh0LScrYi5pZCsnXFxcIiB0eXBlPVxcXCJ0ZXh0XFxcIiBwbGFjZWhvbGRlcj1cXFwiJytiLmxhbmd1YWdlLnRyYW5zbGF0ZShcXFwiQWx0ZXJuYXRlIFRleHRcXFwiKSsnXFxcIiB0YWJJbmRleD1cXFwiMVxcXCI+PC9kaXY+PGRpdiBjbGFzcz1cXFwiZnItYWN0aW9uLWJ1dHRvbnNcXFwiPjxidXR0b24gdHlwZT1cXFwiYnV0dG9uXFxcIiBjbGFzcz1cXFwiZnItY29tbWFuZCBmci1zdWJtaXRcXFwiIGRhdGEtY21kPVxcXCJpbWFnZVNldEFsdFxcXCIgdGFiSW5kZXg9XFxcIjJcXFwiIHJvbGU9XFxcImJ1dHRvblxcXCI+JytiLmxhbmd1YWdlLnRyYW5zbGF0ZShcXFwiVXBkYXRlXFxcIikrXFxcIjwvYnV0dG9uPjwvZGl2PjwvZGl2PlxcXCI7dmFyIGU9e2J1dHRvbnM6YyxhbHRfbGF5ZXI6ZH0sZj1iLnBvcHVwcy5jcmVhdGUoXFxcImltYWdlLmFsdFxcXCIsZSk7cmV0dXJuIGIuJHdwJiZiLmV2ZW50cy4kb24oYi4kd3AsXFxcInNjcm9sbC5pbWFnZS1hbHRcXFwiLGZ1bmN0aW9uKCl7eGEmJmIucG9wdXBzLmlzVmlzaWJsZShcXFwiaW1hZ2UuYWx0XFxcIikmJk8oKX0pLGZ9ZnVuY3Rpb24gUShhKXtpZih4YSl7dmFyIGM9Yi5wb3B1cHMuZ2V0KFxcXCJpbWFnZS5hbHRcXFwiKTt4YS5hdHRyKFxcXCJhbHRcXFwiLGF8fGMuZmluZChcXFwiaW5wdXRcXFwiKS52YWwoKXx8XFxcIlxcXCIpLGMuZmluZChcXFwiaW5wdXQ6Zm9jdXNcXFwiKS5ibHVyKCksdyh4YSl9fWZ1bmN0aW9uIFIoKXtpZih4YSl7dmFyIGE9Yi5wb3B1cHMuZ2V0KFxcXCJpbWFnZS5zaXplXFxcIik7YS5maW5kKCdpbnB1dFtuYW1lPVxcXCJ3aWR0aFxcXCJdJykudmFsKHhhLmdldCgwKS5zdHlsZS53aWR0aCkudHJpZ2dlcihcXFwiY2hhbmdlXFxcIiksYS5maW5kKCdpbnB1dFtuYW1lPVxcXCJoZWlnaHRcXFwiXScpLnZhbCh4YS5nZXQoMCkuc3R5bGUuaGVpZ2h0KS50cmlnZ2VyKFxcXCJjaGFuZ2VcXFwiKX19ZnVuY3Rpb24gUygpe3ZhciBhPWIucG9wdXBzLmdldChcXFwiaW1hZ2Uuc2l6ZVxcXCIpO2F8fChhPVQoKSkscygpLGIucG9wdXBzLnJlZnJlc2goXFxcImltYWdlLnNpemVcXFwiKSxiLnBvcHVwcy5zZXRDb250YWluZXIoXFxcImltYWdlLnNpemVcXFwiLGIuJHNjKTt2YXIgYz14YS5vZmZzZXQoKS5sZWZ0K3hhLndpZHRoKCkvMixkPXhhLm9mZnNldCgpLnRvcCt4YS5oZWlnaHQoKTtiLnBvcHVwcy5zaG93KFxcXCJpbWFnZS5zaXplXFxcIixjLGQseGEub3V0ZXJIZWlnaHQoKSl9ZnVuY3Rpb24gVChhKXtpZihhKXJldHVybiBiLnBvcHVwcy5vblJlZnJlc2goXFxcImltYWdlLnNpemVcXFwiLFIpLCEwO3ZhciBjPVxcXCJcXFwiO2M9JzxkaXYgY2xhc3M9XFxcImZyLWJ1dHRvbnNcXFwiPicrYi5idXR0b24uYnVpbGRMaXN0KGIub3B0cy5pbWFnZVNpemVCdXR0b25zKStcXFwiPC9kaXY+XFxcIjt2YXIgZD1cXFwiXFxcIjtkPSc8ZGl2IGNsYXNzPVxcXCJmci1pbWFnZS1zaXplLWxheWVyIGZyLWxheWVyIGZyLWFjdGl2ZVxcXCIgaWQ9XFxcImZyLWltYWdlLXNpemUtbGF5ZXItJytiLmlkKydcXFwiPjxkaXYgY2xhc3M9XFxcImZyLWltYWdlLWdyb3VwXFxcIj48ZGl2IGNsYXNzPVxcXCJmci1pbnB1dC1saW5lXFxcIj48aW5wdXQgaWQ9XFxcImZyLWltYWdlLXNpemUtbGF5ZXItd2lkdGgtJytiLmlkKydcXFwiIHR5cGU9XFxcInRleHRcXFwiIG5hbWU9XFxcIndpZHRoXFxcIiBwbGFjZWhvbGRlcj1cXFwiJytiLmxhbmd1YWdlLnRyYW5zbGF0ZShcXFwiV2lkdGhcXFwiKSsnXFxcIiB0YWJJbmRleD1cXFwiMVxcXCI+PC9kaXY+PGRpdiBjbGFzcz1cXFwiZnItaW5wdXQtbGluZVxcXCI+PGlucHV0IGlkPVxcXCJmci1pbWFnZS1zaXplLWxheWVyLWhlaWdodCcrYi5pZCsnXFxcIiB0eXBlPVxcXCJ0ZXh0XFxcIiBuYW1lPVxcXCJoZWlnaHRcXFwiIHBsYWNlaG9sZGVyPVxcXCInK2IubGFuZ3VhZ2UudHJhbnNsYXRlKFxcXCJIZWlnaHRcXFwiKSsnXFxcIiB0YWJJbmRleD1cXFwiMVxcXCI+PC9kaXY+PC9kaXY+PGRpdiBjbGFzcz1cXFwiZnItYWN0aW9uLWJ1dHRvbnNcXFwiPjxidXR0b24gdHlwZT1cXFwiYnV0dG9uXFxcIiBjbGFzcz1cXFwiZnItY29tbWFuZCBmci1zdWJtaXRcXFwiIGRhdGEtY21kPVxcXCJpbWFnZVNldFNpemVcXFwiIHRhYkluZGV4PVxcXCIyXFxcIiByb2xlPVxcXCJidXR0b25cXFwiPicrYi5sYW5ndWFnZS50cmFuc2xhdGUoXFxcIlVwZGF0ZVxcXCIpK1xcXCI8L2J1dHRvbj48L2Rpdj48L2Rpdj5cXFwiO3ZhciBlPXtidXR0b25zOmMsc2l6ZV9sYXllcjpkfSxmPWIucG9wdXBzLmNyZWF0ZShcXFwiaW1hZ2Uuc2l6ZVxcXCIsZSk7cmV0dXJuIGIuJHdwJiZiLmV2ZW50cy4kb24oYi4kd3AsXFxcInNjcm9sbC5pbWFnZS1zaXplXFxcIixmdW5jdGlvbigpe3hhJiZiLnBvcHVwcy5pc1Zpc2libGUoXFxcImltYWdlLnNpemVcXFwiKSYmUygpfSksZn1mdW5jdGlvbiBVKGEsYyl7aWYoeGEpe3ZhciBkPWIucG9wdXBzLmdldChcXFwiaW1hZ2Uuc2l6ZVxcXCIpO2E9YXx8ZC5maW5kKCdpbnB1dFtuYW1lPVxcXCJ3aWR0aFxcXCJdJykudmFsKCl8fFxcXCJcXFwiLGM9Y3x8ZC5maW5kKCdpbnB1dFtuYW1lPVxcXCJoZWlnaHRcXFwiXScpLnZhbCgpfHxcXFwiXFxcIjt2YXIgZT0vXltcXFxcZF0rKChweCl8JSkqJC9nO2EubWF0Y2goZSkmJnhhLmNzcyhcXFwid2lkdGhcXFwiLGEpLGMubWF0Y2goZSkmJnhhLmNzcyhcXFwiaGVpZ2h0XFxcIixjKSxkLmZpbmQoXFxcImlucHV0OmZvY3VzXFxcIikuYmx1cigpLHcoeGEpfX1mdW5jdGlvbiBWKGEpe3ZhciBjLGQsZT1iLnBvcHVwcy5nZXQoXFxcImltYWdlLmluc2VydFxcXCIpO2lmKHhhfHxiLm9wdHMudG9vbGJhcklubGluZSl4YSYmKGQ9eGEub2Zmc2V0KCkudG9wK3hhLm91dGVySGVpZ2h0KCkpO2Vsc2V7dmFyIGY9Yi4kdGIuZmluZCgnLmZyLWNvbW1hbmRbZGF0YS1jbWQ9XFxcImluc2VydEltYWdlXFxcIl0nKTtjPWYub2Zmc2V0KCkubGVmdCtmLm91dGVyV2lkdGgoKS8yLGQ9Zi5vZmZzZXQoKS50b3ArKGIub3B0cy50b29sYmFyQm90dG9tPzEwOmYub3V0ZXJIZWlnaHQoKS0xMCl9IXhhJiZiLm9wdHMudG9vbGJhcklubGluZSYmKGQ9ZS5vZmZzZXQoKS50b3AtYi5oZWxwZXJzLmdldFBYKGUuY3NzKFxcXCJtYXJnaW4tdG9wXFxcIikpLGUuaGFzQ2xhc3MoXFxcImZyLWFib3ZlXFxcIikmJihkKz1lLm91dGVySGVpZ2h0KCkpKSxlLmZpbmQoXFxcIi5mci1sYXllclxcXCIpLnJlbW92ZUNsYXNzKFxcXCJmci1hY3RpdmVcXFwiKSxlLmZpbmQoXFxcIi5mci1cXFwiK2ErXFxcIi1sYXllclxcXCIpLmFkZENsYXNzKFxcXCJmci1hY3RpdmVcXFwiKSxiLnBvcHVwcy5zaG93KFxcXCJpbWFnZS5pbnNlcnRcXFwiLGMsZCx4YT94YS5vdXRlckhlaWdodCgpOjApLGIuYWNjZXNzaWJpbGl0eS5mb2N1c1BvcHVwKGUpfWZ1bmN0aW9uIFcoYSl7dmFyIGM9Yi5wb3B1cHMuZ2V0KFxcXCJpbWFnZS5pbnNlcnRcXFwiKTtjLmZpbmQoXFxcIi5mci1pbWFnZS11cGxvYWQtbGF5ZXJcXFwiKS5oYXNDbGFzcyhcXFwiZnItYWN0aXZlXFxcIikmJmEuYWRkQ2xhc3MoXFxcImZyLWFjdGl2ZVxcXCIpLmF0dHIoXFxcImFyaWEtcHJlc3NlZFxcXCIsITApfWZ1bmN0aW9uIFgoYSl7dmFyIGM9Yi5wb3B1cHMuZ2V0KFxcXCJpbWFnZS5pbnNlcnRcXFwiKTtjLmZpbmQoXFxcIi5mci1pbWFnZS1ieS11cmwtbGF5ZXJcXFwiKS5oYXNDbGFzcyhcXFwiZnItYWN0aXZlXFxcIikmJmEuYWRkQ2xhc3MoXFxcImZyLWFjdGl2ZVxcXCIpLmF0dHIoXFxcImFyaWEtcHJlc3NlZFxcXCIsITApfWZ1bmN0aW9uIFkoYSxiLGMsZCl7cmV0dXJuIGEucGFnZVg9YixtLmNhbGwodGhpcyxhKSxhLnBhZ2VYPWEucGFnZVgrYypNYXRoLmZsb29yKE1hdGgucG93KDEuMSxkKSksbi5jYWxsKHRoaXMsYSksby5jYWxsKHRoaXMsYSksKytkfWZ1bmN0aW9uIFooKXt2YXIgYztpZihiLnNoYXJlZC4kaW1hZ2VfcmVzaXplcj8oeWE9Yi5zaGFyZWQuJGltYWdlX3Jlc2l6ZXIsQWE9Yi5zaGFyZWQuJGltZ19vdmVybGF5LGIuZXZlbnRzLm9uKFxcXCJkZXN0cm95XFxcIixmdW5jdGlvbigpe3lhLnJlbW92ZUNsYXNzKFxcXCJmci1hY3RpdmVcXFwiKS5hcHBlbmRUbyhhKFxcXCJib2R5XFxcIikpfSwhMCkpOihiLnNoYXJlZC4kaW1hZ2VfcmVzaXplcj1hKCc8ZGl2IGNsYXNzPVxcXCJmci1pbWFnZS1yZXNpemVyXFxcIj48L2Rpdj4nKSx5YT1iLnNoYXJlZC4kaW1hZ2VfcmVzaXplcixiLmV2ZW50cy4kb24oeWEsXFxcIm1vdXNlZG93blxcXCIsZnVuY3Rpb24oYSl7YS5zdG9wUHJvcGFnYXRpb24oKX0sITApLGIub3B0cy5pbWFnZVJlc2l6ZSYmKHlhLmFwcGVuZChsKFxcXCJud1xcXCIpK2woXFxcIm5lXFxcIikrbChcXFwic3dcXFwiKStsKFxcXCJzZVxcXCIpKSxiLnNoYXJlZC4kaW1nX292ZXJsYXk9YSgnPGRpdiBjbGFzcz1cXFwiZnItaW1hZ2Utb3ZlcmxheVxcXCI+PC9kaXY+JyksQWE9Yi5zaGFyZWQuJGltZ19vdmVybGF5LGM9eWEuZ2V0KDApLm93bmVyRG9jdW1lbnQsYShjKS5maW5kKFxcXCJib2R5XFxcIikuYXBwZW5kKEFhKSkpLGIuZXZlbnRzLm9uKFxcXCJzaGFyZWQuZGVzdHJveVxcXCIsZnVuY3Rpb24oKXt5YS5odG1sKFxcXCJcXFwiKS5yZW1vdmVEYXRhKCkucmVtb3ZlKCkseWE9bnVsbCxiLm9wdHMuaW1hZ2VSZXNpemUmJihBYS5yZW1vdmUoKSxBYT1udWxsKX0sITApLGIuaGVscGVycy5pc01vYmlsZSgpfHxiLmV2ZW50cy4kb24oYShiLm9fd2luKSxcXFwicmVzaXplXFxcIixmdW5jdGlvbigpe3hhJiYheGEuaGFzQ2xhc3MoXFxcImZyLXVwbG9hZGluZ1xcXCIpP2dhKCEwKTp4YSYmKGsoKSxzYSgpLHIoITEpKX0pLGIub3B0cy5pbWFnZVJlc2l6ZSl7Yz15YS5nZXQoMCkub3duZXJEb2N1bWVudCxiLmV2ZW50cy4kb24oeWEsYi5fbW91c2Vkb3duLFxcXCIuZnItaGFuZGxlclxcXCIsbSksYi5ldmVudHMuJG9uKGEoYyksYi5fbW91c2Vtb3ZlLG4pLGIuZXZlbnRzLiRvbihhKGMuZGVmYXVsdFZpZXd8fGMucGFyZW50V2luZG93KSxiLl9tb3VzZXVwLG8pLGIuZXZlbnRzLiRvbihBYSxcXFwibW91c2VsZWF2ZVxcXCIsbyk7dmFyIGQ9MSxlPW51bGwsZj0wO2IuZXZlbnRzLm9uKFxcXCJrZXlkb3duXFxcIixmdW5jdGlvbihjKXtpZih4YSl7dmFyIGc9bmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKFxcXCJNYWMgT1MgWFxcXCIpIT0tMT9jLm1ldGFLZXk6Yy5jdHJsS2V5LGg9Yy53aGljaDsoaCE9PWV8fGMudGltZVN0YW1wLWY+MjAwKSYmKGQ9MSksKGg9PWEuRkUuS0VZQ09ERS5FUVVBTFN8fGIuYnJvd3Nlci5tb3ppbGxhJiZoPT1hLkZFLktFWUNPREUuRkZfRVFVQUxTKSYmZyYmIWMuYWx0S2V5P2Q9WS5jYWxsKHRoaXMsYywxLDEsZCk6KGg9PWEuRkUuS0VZQ09ERS5IWVBIRU58fGIuYnJvd3Nlci5tb3ppbGxhJiZoPT1hLkZFLktFWUNPREUuRkZfSFlQSEVOKSYmZyYmIWMuYWx0S2V5P2Q9WS5jYWxsKHRoaXMsYywyLC0xLGQpOmIua2V5cy5jdHJsS2V5KGMpfHxoIT1hLkZFLktFWUNPREUuRU5URVJ8fCh4YS5iZWZvcmUoXFxcIjxicj5cXFwiKSx3KHhhKSksZT1oLGY9Yy50aW1lU3RhbXB9fSwhMCksYi5ldmVudHMub24oXFxcImtleXVwXFxcIixmdW5jdGlvbigpe2Q9MX0pfX1mdW5jdGlvbiAkKGMpe2M9Y3x8eGEsYyYmYi5ldmVudHMudHJpZ2dlcihcXFwiaW1hZ2UuYmVmb3JlUmVtb3ZlXFxcIixbY10pIT09ITEmJihiLnBvcHVwcy5oaWRlQWxsKCksdGEoKSxnYSghMCksYi51bmRvLmNhbkRvKCl8fGIudW5kby5zYXZlU3RlcCgpLGMuZ2V0KDApPT1iLmVsP2MucmVtb3ZlQXR0cihcXFwic3JjXFxcIik6KFxcXCJBXFxcIj09Yy5nZXQoMCkucGFyZW50Tm9kZS50YWdOYW1lPyhiLnNlbGVjdGlvbi5zZXRCZWZvcmUoYy5nZXQoMCkucGFyZW50Tm9kZSl8fGIuc2VsZWN0aW9uLnNldEFmdGVyKGMuZ2V0KDApLnBhcmVudE5vZGUpfHxjLnBhcmVudCgpLmFmdGVyKGEuRkUuTUFSS0VSUyksYShjLmdldCgwKS5wYXJlbnROb2RlKS5yZW1vdmUoKSk6KGIuc2VsZWN0aW9uLnNldEJlZm9yZShjLmdldCgwKSl8fGIuc2VsZWN0aW9uLnNldEFmdGVyKGMuZ2V0KDApKXx8Yy5hZnRlcihhLkZFLk1BUktFUlMpLGMucmVtb3ZlKCkpLGIuaHRtbC5maWxsRW1wdHlCbG9ja3MoKSxiLnNlbGVjdGlvbi5yZXN0b3JlKCkpLGIudW5kby5zYXZlU3RlcCgpKX1mdW5jdGlvbiBfKGMpe3ZhciBkPWMud2hpY2g7aWYoeGEmJihkPT1hLkZFLktFWUNPREUuQkFDS1NQQUNFfHxkPT1hLkZFLktFWUNPREUuREVMRVRFKSlyZXR1cm4gYy5wcmV2ZW50RGVmYXVsdCgpLGMuc3RvcFByb3BhZ2F0aW9uKCksJCgpLCExO2lmKHhhJiZkPT1hLkZFLktFWUNPREUuRVNDKXt2YXIgZT14YTtyZXR1cm4gZ2EoITApLGIuc2VsZWN0aW9uLnNldEFmdGVyKGUuZ2V0KDApKSxiLnNlbGVjdGlvbi5yZXN0b3JlKCksYy5wcmV2ZW50RGVmYXVsdCgpLCExfWlmKHhhJiYoZD09YS5GRS5LRVlDT0RFLkFSUk9XX0xFRlR8fGQ9PWEuRkUuS0VZQ09ERS5BUlJPV19SSUdIVCkpe3ZhciBmPXhhLmdldCgwKTtyZXR1cm4gZ2EoITApLGQ9PWEuRkUuS0VZQ09ERS5BUlJPV19MRUZUP2Iuc2VsZWN0aW9uLnNldEJlZm9yZShmKTpiLnNlbGVjdGlvbi5zZXRBZnRlcihmKSxiLnNlbGVjdGlvbi5yZXN0b3JlKCksYy5wcmV2ZW50RGVmYXVsdCgpLCExfXJldHVybiB4YSYmZCE9YS5GRS5LRVlDT0RFLkYxMCYmIWIua2V5cy5pc0Jyb3dzZXJBY3Rpb24oYyk/KGMucHJldmVudERlZmF1bHQoKSxjLnN0b3BQcm9wYWdhdGlvbigpLCExKTp2b2lkIDB9ZnVuY3Rpb24gYWEoYSl7aWYoYSYmXFxcIklNR1xcXCI9PWEudGFnTmFtZSliLm5vZGUuaGFzQ2xhc3MoYSxcXFwiZnItdXBsb2FkaW5nXFxcIil8fGIubm9kZS5oYXNDbGFzcyhhLFxcXCJmci1lcnJvclxcXCIpP2EucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChhKTpiLm5vZGUuaGFzQ2xhc3MoYSxcXFwiZnItZHJhZ2dhYmxlXFxcIikmJmEuY2xhc3NMaXN0LnJlbW92ZShcXFwiZnItZHJhZ2dhYmxlXFxcIik7ZWxzZSBpZihhJiZhLm5vZGVUeXBlPT1Ob2RlLkVMRU1FTlRfTk9ERSlmb3IodmFyIGM9YS5xdWVyeVNlbGVjdG9yQWxsKFxcXCJpbWcuZnItdXBsb2FkaW5nLCBpbWcuZnItZXJyb3IsIGltZy5mci1kcmFnZ2FibGVcXFwiKSxkPTA7ZDxjLmxlbmd0aDtkKyspYWEoY1tkXSl9ZnVuY3Rpb24gYmEoKXtpZihMKCksXFxcIklNR1xcXCI9PWIuZWwudGFnTmFtZSYmYi4kZWwuYWRkQ2xhc3MoXFxcImZyLXZpZXdcXFwiKSxiLmV2ZW50cy4kb24oYi4kZWwsYi5oZWxwZXJzLmlzTW9iaWxlKCkmJiFiLmhlbHBlcnMuaXNXaW5kb3dzUGhvbmUoKT9cXFwidG91Y2hlbmRcXFwiOlxcXCJjbGlja1xcXCIsXFxcIklNR1xcXCI9PWIuZWwudGFnTmFtZT9udWxsOidpbWc6bm90KFtjb250ZW50ZWRpdGFibGU9XFxcImZhbHNlXFxcIl0pJyxmYSksYi5oZWxwZXJzLmlzTW9iaWxlKCkmJihiLmV2ZW50cy4kb24oYi4kZWwsXFxcInRvdWNoc3RhcnRcXFwiLFxcXCJJTUdcXFwiPT1iLmVsLnRhZ05hbWU/bnVsbDonaW1nOm5vdChbY29udGVudGVkaXRhYmxlPVxcXCJmYWxzZVxcXCJdKScsZnVuY3Rpb24oKXtMYT0hMX0pLGIuZXZlbnRzLiRvbihiLiRlbCxcXFwidG91Y2htb3ZlXFxcIixmdW5jdGlvbigpe0xhPSEwfSkpLGIuJHdwPyhiLmV2ZW50cy5vbihcXFwid2luZG93LmtleWRvd24ga2V5ZG93blxcXCIsXywhMCksYi5ldmVudHMub24oXFxcImtleXVwXFxcIixmdW5jdGlvbihiKXtpZihiLndoaWNoPT1hLkZFLktFWUNPREUuRU5URVIpcmV0dXJuITF9LCEwKSk6Yi5ldmVudHMuJG9uKGIuJHdpbixcXFwia2V5ZG93blxcXCIsXyksYi5ldmVudHMub24oXFxcInRvb2xiYXIuZXNjXFxcIixmdW5jdGlvbigpe2lmKHhhKXtpZihiLiR3cCliLmV2ZW50cy5kaXNhYmxlQmx1cigpLGIuZXZlbnRzLmZvY3VzKCk7ZWxzZXt2YXIgYT14YTtnYSghMCksYi5zZWxlY3Rpb24uc2V0QWZ0ZXIoYS5nZXQoMCkpLGIuc2VsZWN0aW9uLnJlc3RvcmUoKX1yZXR1cm4hMX19LCEwKSxiLmV2ZW50cy5vbihcXFwidG9vbGJhci5mb2N1c0VkaXRvclxcXCIsZnVuY3Rpb24oKXtpZih4YSlyZXR1cm4hMX0sITApLGIuZXZlbnRzLm9uKFxcXCJ3aW5kb3cuY3V0IHdpbmRvdy5jb3B5XFxcIixmdW5jdGlvbihhKXt4YSYmYi5wb3B1cHMuaXNWaXNpYmxlKFxcXCJpbWFnZS5lZGl0XFxcIikmJiFiLnBvcHVwcy5nZXQoXFxcImltYWdlLmVkaXRcXFwiKS5maW5kKFxcXCI6Zm9jdXNcXFwiKS5sZW5ndGgmJih0YSgpLGIucGFzdGUuc2F2ZUNvcGllZFRleHQoeGEuZ2V0KDApLm91dGVySFRNTCxcXFwiXFxcXG5cXFwiKSxcXFwiY29weVxcXCI9PWEudHlwZT9zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7dyh4YSl9KTooZ2EoITApLGIudW5kby5zYXZlU3RlcCgpLHNldFRpbWVvdXQoZnVuY3Rpb24oKXtiLnVuZG8uc2F2ZVN0ZXAoKX0sMCkpKX0sITApLGIuZXZlbnRzLiRvbihhKGIub193aW4pLFxcXCJrZXlkb3duXFxcIixmdW5jdGlvbihiKXt2YXIgYz1iLndoaWNoO2lmKHhhJiZjPT1hLkZFLktFWUNPREUuQkFDS1NQQUNFKXJldHVybiBiLnByZXZlbnREZWZhdWx0KCksITF9KSxiLmV2ZW50cy4kb24oYi4kd2luLFxcXCJrZXlkb3duXFxcIixmdW5jdGlvbihiKXt2YXIgYz1iLndoaWNoO3hhJiZ4YS5oYXNDbGFzcyhcXFwiZnItdXBsb2FkaW5nXFxcIikmJmM9PWEuRkUuS0VZQ09ERS5FU0MmJnhhLnRyaWdnZXIoXFxcImFib3J0VXBsb2FkXFxcIil9KSxiLmV2ZW50cy5vbihcXFwiZGVzdHJveVxcXCIsZnVuY3Rpb24oKXt4YSYmeGEuaGFzQ2xhc3MoXFxcImZyLXVwbG9hZGluZ1xcXCIpJiZ4YS50cmlnZ2VyKFxcXCJhYm9ydFVwbG9hZFxcXCIpfSksYi5ldmVudHMub24oXFxcInBhc3RlLmJlZm9yZVxcXCIsZGEpLGIuZXZlbnRzLm9uKFxcXCJwYXN0ZS5iZWZvcmVDbGVhbnVwXFxcIixlYSksYi5ldmVudHMub24oXFxcInBhc3RlLmFmdGVyXFxcIixjYSksYi5ldmVudHMub24oXFxcImh0bWwuc2V0XFxcIixpKSxiLmV2ZW50cy5vbihcXFwiaHRtbC5pbnNlcnRlZFxcXCIsaSksaSgpLGIuZXZlbnRzLm9uKFxcXCJkZXN0cm95XFxcIixmdW5jdGlvbigpe0thPVtdfSksYi5ldmVudHMub24oXFxcImh0bWwucHJvY2Vzc0dldFxcXCIsYWEpLGIub3B0cy5pbWFnZU91dHB1dFNpemUpe3ZhciBjO2IuZXZlbnRzLm9uKFxcXCJodG1sLmJlZm9yZUdldFxcXCIsZnVuY3Rpb24oKXtjPWIuZWwucXVlcnlTZWxlY3RvckFsbChcXFwiaW1nXFxcIik7Zm9yKHZhciBkPTA7ZDxjLmxlbmd0aDtkKyspe3ZhciBlPWNbZF0uc3R5bGUud2lkdGh8fGEoY1tkXSkud2lkdGgoKSxmPWNbZF0uc3R5bGUuaGVpZ2h0fHxhKGNbZF0pLmhlaWdodCgpO2UmJmNbZF0uc2V0QXR0cmlidXRlKFxcXCJ3aWR0aFxcXCIsKFxcXCJcXFwiK2UpLnJlcGxhY2UoL3B4LyxcXFwiXFxcIikpLGYmJmNbZF0uc2V0QXR0cmlidXRlKFxcXCJoZWlnaHRcXFwiLChcXFwiXFxcIitmKS5yZXBsYWNlKC9weC8sXFxcIlxcXCIpKX19KSxiLmV2ZW50cy5vbihcXFwiaHRtbC5hZnRlckdldFxcXCIsZnVuY3Rpb24oKXtmb3IodmFyIGE9MDthPGMubGVuZ3RoO2ErKyljW2FdLnJlbW92ZUF0dHJpYnV0ZShcXFwid2lkdGhcXFwiKSxjW2FdLnJlbW92ZUF0dHJpYnV0ZShcXFwiaGVpZ2h0XFxcIil9KX1iLm9wdHMuaWZyYW1lJiZiLmV2ZW50cy5vbihcXFwiaW1hZ2UubG9hZGVkXFxcIixiLnNpemUuc3luY0lmcmFtZSksYi4kd3AmJihqKCksYi5ldmVudHMub24oXFxcImNvbnRlbnRDaGFuZ2VkXFxcIixqKSksYi5ldmVudHMuJG9uKGEoYi5vX3dpbiksXFxcIm9yaWVudGF0aW9uY2hhbmdlLmltYWdlXFxcIixmdW5jdGlvbigpe3NldFRpbWVvdXQoZnVuY3Rpb24oKXt4YSYmdyh4YSl9LDEwMCl9KSxxKCEwKSxNKCEwKSxUKCEwKSxQKCEwKSxiLmV2ZW50cy5vbihcXFwibm9kZS5yZW1vdmVcXFwiLGZ1bmN0aW9uKGEpe2lmKFxcXCJJTUdcXFwiPT1hLmdldCgwKS50YWdOYW1lKXJldHVybiAkKGEpLCExfSl9ZnVuY3Rpb24gY2EoKXtiLm9wdHMuaW1hZ2VQYXN0ZT9iLiRlbC5maW5kKFxcXCJpbWdbZGF0YS1mci1pbWFnZS1wYXN0ZWRdXFxcIikuZWFjaChmdW5jdGlvbihjLGQpe2lmKGIub3B0cy5pbWFnZVBhc3RlUHJvY2Vzcyl7dmFyIGY9Yi5vcHRzLmltYWdlRGVmYXVsdFdpZHRoO2YmJlxcXCJhdXRvXFxcIiE9ZiYmKGYrPWIub3B0cy5pbWFnZVJlc2l6ZVdpdGhQZXJjZW50P1xcXCIlXFxcIjpcXFwicHhcXFwiKSxhKGQpLmNzcyhcXFwid2lkdGhcXFwiLGYpLGEoZCkucmVtb3ZlQ2xhc3MoXFxcImZyLWRpaSBmci1kaWIgZnItZmlyIGZyLWZpbFxcXCIpLmFkZENsYXNzKChiLm9wdHMuaW1hZ2VEZWZhdWx0RGlzcGxheT9cXFwiZnItZGlcXFwiK2Iub3B0cy5pbWFnZURlZmF1bHREaXNwbGF5WzBdOlxcXCJcXFwiKSsoYi5vcHRzLmltYWdlRGVmYXVsdEFsaWduJiZcXFwiY2VudGVyXFxcIiE9Yi5vcHRzLmltYWdlRGVmYXVsdEFsaWduP1xcXCIgZnItZmlcXFwiK2Iub3B0cy5pbWFnZURlZmF1bHRBbGlnblswXTpcXFwiXFxcIikpfWlmKDA9PT1kLnNyYy5pbmRleE9mKFxcXCJkYXRhOlxcXCIpKXtpZihiLmV2ZW50cy50cmlnZ2VyKFxcXCJpbWFnZS5iZWZvcmVQYXN0ZVVwbG9hZFxcXCIsW2RdKT09PSExKXJldHVybiExO3hhPWEoZCksaygpLGUoKSxzYSgpLHIoKSxiLmVkaXQub2ZmKCk7Zm9yKHZhciBnPWF0b2IoYShkKS5hdHRyKFxcXCJzcmNcXFwiKS5zcGxpdChcXFwiLFxcXCIpWzFdKSxoPVtdLGk9MDtpPGcubGVuZ3RoO2krKyloLnB1c2goZy5jaGFyQ29kZUF0KGkpKTt2YXIgaj1uZXcgQmxvYihbbmV3IFVpbnQ4QXJyYXkoaCldLHt0eXBlOlxcXCJpbWFnZS9qcGVnXFxcIn0pO0goW2pdLGEoZCkpLGEoZCkucmVtb3ZlQXR0cihcXFwiZGF0YS1mci1pbWFnZS1wYXN0ZWRcXFwiKX1lbHNlIDAhPT1kLnNyYy5pbmRleE9mKFxcXCJodHRwXFxcIil8fDA9PT1kLnNyYy5pbmRleE9mKFxcXCJodHRwczovL21haWwuZ29vZ2xlLmNvbS9tYWlsXFxcIik/KGIuc2VsZWN0aW9uLnNhdmUoKSxhKGQpLnJlbW92ZSgpLGIuc2VsZWN0aW9uLnJlc3RvcmUoKSk6YShkKS5yZW1vdmVBdHRyKFxcXCJkYXRhLWZyLWltYWdlLXBhc3RlZFxcXCIpfSk6Yi4kZWwuZmluZChcXFwiaW1nW2RhdGEtZnItaW1hZ2UtcGFzdGVkXVxcXCIpLnJlbW92ZSgpfWZ1bmN0aW9uIGRhKGEpe2lmKGEmJmEuY2xpcGJvYXJkRGF0YSYmYS5jbGlwYm9hcmREYXRhLml0ZW1zJiZhLmNsaXBib2FyZERhdGEuaXRlbXNbMF0pe3ZhciBjPWEuY2xpcGJvYXJkRGF0YS5pdGVtc1swXS5nZXRBc0ZpbGUoKTtpZihjKXt2YXIgZD1uZXcgRmlsZVJlYWRlcjtyZXR1cm4gZC5vbmxvYWQ9ZnVuY3Rpb24oYSl7dmFyIGM9YS50YXJnZXQucmVzdWx0LGQ9Yi5vcHRzLmltYWdlRGVmYXVsdFdpZHRoO2QmJlxcXCJhdXRvXFxcIiE9ZCYmKGQrPWIub3B0cy5pbWFnZVJlc2l6ZVdpdGhQZXJjZW50P1xcXCIlXFxcIjpcXFwicHhcXFwiKSxiLmh0bWwuaW5zZXJ0KCc8aW1nIGRhdGEtZnItaW1hZ2UtcGFzdGVkPVxcXCJ0cnVlXFxcIiBjbGFzcz1cXFwiJysoYi5vcHRzLmltYWdlRGVmYXVsdERpc3BsYXk/XFxcImZyLWRpXFxcIitiLm9wdHMuaW1hZ2VEZWZhdWx0RGlzcGxheVswXTpcXFwiXFxcIikrKGIub3B0cy5pbWFnZURlZmF1bHRBbGlnbiYmXFxcImNlbnRlclxcXCIhPWIub3B0cy5pbWFnZURlZmF1bHRBbGlnbj9cXFwiIGZyLWZpXFxcIitiLm9wdHMuaW1hZ2VEZWZhdWx0QWxpZ25bMF06XFxcIlxcXCIpKydcXFwiIHNyYz1cXFwiJytjKydcXFwiJysoZD8nIHN0eWxlPVxcXCJ3aWR0aDogJytkKyc7XFxcIic6XFxcIlxcXCIpK1xcXCI+XFxcIiksYi5ldmVudHMudHJpZ2dlcihcXFwicGFzdGUuYWZ0ZXJcXFwiKX0sZC5yZWFkQXNEYXRhVVJMKGMpLCExfX19ZnVuY3Rpb24gZWEoYSl7cmV0dXJuIGE9YS5yZXBsYWNlKC88aW1nIC9naSwnPGltZyBkYXRhLWZyLWltYWdlLXBhc3RlZD1cXFwidHJ1ZVxcXCIgJyl9ZnVuY3Rpb24gZmEoYyl7aWYoXFxcImZhbHNlXFxcIj09YSh0aGlzKS5wYXJlbnRzKFxcXCJbY29udGVudGVkaXRhYmxlXTpub3QoLmZyLWVsZW1lbnQpOm5vdChib2R5KTpmaXJzdFxcXCIpLmF0dHIoXFxcImNvbnRlbnRlZGl0YWJsZVxcXCIpKXJldHVybiEwO2lmKGMmJlxcXCJ0b3VjaGVuZFxcXCI9PWMudHlwZSYmTGEpcmV0dXJuITA7aWYoYyYmYi5lZGl0LmlzRGlzYWJsZWQoKSlyZXR1cm4gYy5zdG9wUHJvcGFnYXRpb24oKSxjLnByZXZlbnREZWZhdWx0KCksITE7Zm9yKHZhciBkPTA7ZDxhLkZFLklOU1RBTkNFUy5sZW5ndGg7ZCsrKWEuRkUuSU5TVEFOQ0VTW2RdIT1iJiZhLkZFLklOU1RBTkNFU1tkXS5ldmVudHMudHJpZ2dlcihcXFwiaW1hZ2UuaGlkZVJlc2l6ZXJcXFwiKTtiLnRvb2xiYXIuZGlzYWJsZSgpLGMmJihjLnN0b3BQcm9wYWdhdGlvbigpLGMucHJldmVudERlZmF1bHQoKSksYi5oZWxwZXJzLmlzTW9iaWxlKCkmJihiLmV2ZW50cy5kaXNhYmxlQmx1cigpLGIuJGVsLmJsdXIoKSxiLmV2ZW50cy5lbmFibGVCbHVyKCkpLGIub3B0cy5pZnJhbWUmJmIuc2l6ZS5zeW5jSWZyYW1lKCkseGE9YSh0aGlzKSx0YSgpLGsoKSxlKCksYi5zZWxlY3Rpb24uY2xlYXIoKSxiLmJ1dHRvbi5idWxrUmVmcmVzaCgpLGIuZXZlbnRzLnRyaWdnZXIoXFxcInZpZGVvLmhpZGVSZXNpemVyXFxcIil9ZnVuY3Rpb24gZ2EoYSl7eGEmJihqYSgpfHxhPT09ITApJiYoYi50b29sYmFyLmVuYWJsZSgpLHlhLnJlbW92ZUNsYXNzKFxcXCJmci1hY3RpdmVcXFwiKSxiLnBvcHVwcy5oaWRlKFxcXCJpbWFnZS5lZGl0XFxcIikseGE9bnVsbCxpYSgpKX1mdW5jdGlvbiBoYSgpe01hPSEwfWZ1bmN0aW9uIGlhKCl7TWE9ITF9ZnVuY3Rpb24gamEoKXtyZXR1cm4gTWF9ZnVuY3Rpb24ga2EoYSxjLGQpeyFiLm9wdHMuaHRtbFVudG91Y2hlZCYmYi5vcHRzLnVzZUNsYXNzZXM/KGEucmVtb3ZlQ2xhc3MoXFxcImZyLWZpbCBmci1maXIgZnItZGliIGZyLWRpaVxcXCIpLGEuYWRkQ2xhc3MoXFxcImZyLWZpXFxcIitkWzBdK1xcXCIgZnItZGlcXFwiK2NbMF0pKTpcXFwiaW5saW5lXFxcIj09Yz8oYS5jc3Moe2Rpc3BsYXk6XFxcImlubGluZS1ibG9ja1xcXCIsdmVydGljYWxBbGlnbjpcXFwiYm90dG9tXFxcIixtYXJnaW46Yi5vcHRzLmltYWdlRGVmYXVsdE1hcmdpbn0pLFxcXCJjZW50ZXJcXFwiPT1kP2EuY3NzKHtmbG9hdDpcXFwibm9uZVxcXCIsbWFyZ2luQm90dG9tOlxcXCJcXFwiLG1hcmdpblRvcDpcXFwiXFxcIixtYXhXaWR0aDpcXFwiY2FsYygxMDAlIC0gXFxcIisyKmIub3B0cy5pbWFnZURlZmF1bHRNYXJnaW4rXFxcInB4KVxcXCJ9KTpcXFwibGVmdFxcXCI9PWQ/YS5jc3Moe2Zsb2F0OlxcXCJsZWZ0XFxcIixtYXJnaW5MZWZ0OjAsbWF4V2lkdGg6XFxcImNhbGMoMTAwJSAtIFxcXCIrYi5vcHRzLmltYWdlRGVmYXVsdE1hcmdpbitcXFwicHgpXFxcIn0pOmEuY3NzKHtmbG9hdDpcXFwicmlnaHRcXFwiLG1hcmdpblJpZ2h0OjAsbWF4V2lkdGg6XFxcImNhbGMoMTAwJSAtIFxcXCIrYi5vcHRzLmltYWdlRGVmYXVsdE1hcmdpbitcXFwicHgpXFxcIn0pKTpcXFwiYmxvY2tcXFwiPT1jJiYoYS5jc3Moe2Rpc3BsYXk6XFxcImJsb2NrXFxcIixmbG9hdDpcXFwibm9uZVxcXCIsdmVydGljYWxBbGlnbjpcXFwidG9wXFxcIixtYXJnaW46Yi5vcHRzLmltYWdlRGVmYXVsdE1hcmdpbitcXFwicHggYXV0b1xcXCJ9KSxcXFwibGVmdFxcXCI9PWQ/YS5jc3Moe21hcmdpbkxlZnQ6MH0pOlxcXCJyaWdodFxcXCI9PWQmJmEuY3NzKHttYXJnaW5SaWdodDowfSkpfWZ1bmN0aW9uIGxhKGEpe3hhLnJlbW92ZUNsYXNzKFxcXCJmci1maXIgZnItZmlsXFxcIiksIWIub3B0cy5odG1sVW50b3VjaGVkJiZiLm9wdHMudXNlQ2xhc3Nlcz9cXFwibGVmdFxcXCI9PWE/eGEuYWRkQ2xhc3MoXFxcImZyLWZpbFxcXCIpOlxcXCJyaWdodFxcXCI9PWEmJnhhLmFkZENsYXNzKFxcXCJmci1maXJcXFwiKTprYSh4YSxuYSgpLGEpLGsoKSxlKCl9ZnVuY3Rpb24gbWEoYSl7aWYoXFxcInVuZGVmaW5lZFxcXCI9PXR5cGVvZiBhJiYoYT14YSksYSl7aWYoYS5oYXNDbGFzcyhcXFwiZnItZmlsXFxcIikpcmV0dXJuXFxcImxlZnRcXFwiO2lmKGEuaGFzQ2xhc3MoXFxcImZyLWZpclxcXCIpKXJldHVyblxcXCJyaWdodFxcXCI7aWYoYS5oYXNDbGFzcyhcXFwiZnItZGliXFxcIil8fGEuaGFzQ2xhc3MoXFxcImZyLWRpaVxcXCIpKXJldHVyblxcXCJjZW50ZXJcXFwiO3ZhciBiPWEuY3NzKFxcXCJmbG9hdFxcXCIpO2lmKGEuY3NzKFxcXCJmbG9hdFxcXCIsXFxcIm5vbmVcXFwiKSxcXFwiYmxvY2tcXFwiPT1hLmNzcyhcXFwiZGlzcGxheVxcXCIpKXtpZihhLmNzcyhcXFwiZmxvYXRcXFwiLFxcXCJcXFwiKSxhLmNzcyhcXFwiZmxvYXRcXFwiKSE9YiYmYS5jc3MoXFxcImZsb2F0XFxcIixiKSwwPT09cGFyc2VJbnQoYS5jc3MoXFxcIm1hcmdpbi1sZWZ0XFxcIiksMTApKXJldHVyblxcXCJsZWZ0XFxcIjtpZigwPT09cGFyc2VJbnQoYS5jc3MoXFxcIm1hcmdpbi1yaWdodFxcXCIpLDEwKSlyZXR1cm5cXFwicmlnaHRcXFwifWVsc2V7aWYoYS5jc3MoXFxcImZsb2F0XFxcIixcXFwiXFxcIiksYS5jc3MoXFxcImZsb2F0XFxcIikhPWImJmEuY3NzKFxcXCJmbG9hdFxcXCIsYiksXFxuXFxcImxlZnRcXFwiPT1hLmNzcyhcXFwiZmxvYXRcXFwiKSlyZXR1cm5cXFwibGVmdFxcXCI7aWYoXFxcInJpZ2h0XFxcIj09YS5jc3MoXFxcImZsb2F0XFxcIikpcmV0dXJuXFxcInJpZ2h0XFxcIn19cmV0dXJuXFxcImNlbnRlclxcXCJ9ZnVuY3Rpb24gbmEoYSl7XFxcInVuZGVmaW5lZFxcXCI9PXR5cGVvZiBhJiYoYT14YSk7dmFyIGI9YS5jc3MoXFxcImZsb2F0XFxcIik7cmV0dXJuIGEuY3NzKFxcXCJmbG9hdFxcXCIsXFxcIm5vbmVcXFwiKSxcXFwiYmxvY2tcXFwiPT1hLmNzcyhcXFwiZGlzcGxheVxcXCIpPyhhLmNzcyhcXFwiZmxvYXRcXFwiLFxcXCJcXFwiKSxhLmNzcyhcXFwiZmxvYXRcXFwiKSE9YiYmYS5jc3MoXFxcImZsb2F0XFxcIixiKSxcXFwiYmxvY2tcXFwiKTooYS5jc3MoXFxcImZsb2F0XFxcIixcXFwiXFxcIiksYS5jc3MoXFxcImZsb2F0XFxcIikhPWImJmEuY3NzKFxcXCJmbG9hdFxcXCIsYiksXFxcImlubGluZVxcXCIpfWZ1bmN0aW9uIG9hKGEpe3hhJiZhLmZpbmQoXFxcIj4gKjpmaXJzdFxcXCIpLnJlcGxhY2VXaXRoKGIuaWNvbi5jcmVhdGUoXFxcImltYWdlLWFsaWduLVxcXCIrbWEoKSkpfWZ1bmN0aW9uIHBhKGEsYil7eGEmJmIuZmluZCgnLmZyLWNvbW1hbmRbZGF0YS1wYXJhbTE9XFxcIicrbWEoKSsnXFxcIl0nKS5hZGRDbGFzcyhcXFwiZnItYWN0aXZlXFxcIikuYXR0cihcXFwiYXJpYS1zZWxlY3RlZFxcXCIsITApfWZ1bmN0aW9uIHFhKGEpe3hhLnJlbW92ZUNsYXNzKFxcXCJmci1kaWkgZnItZGliXFxcIiksIWIub3B0cy5odG1sVW50b3VjaGVkJiZiLm9wdHMudXNlQ2xhc3Nlcz9cXFwiaW5saW5lXFxcIj09YT94YS5hZGRDbGFzcyhcXFwiZnItZGlpXFxcIik6XFxcImJsb2NrXFxcIj09YSYmeGEuYWRkQ2xhc3MoXFxcImZyLWRpYlxcXCIpOmthKHhhLGEsbWEoKSksaygpLGUoKX1mdW5jdGlvbiByYShhLGIpe3hhJiZiLmZpbmQoJy5mci1jb21tYW5kW2RhdGEtcGFyYW0xPVxcXCInK25hKCkrJ1xcXCJdJykuYWRkQ2xhc3MoXFxcImZyLWFjdGl2ZVxcXCIpLmF0dHIoXFxcImFyaWEtc2VsZWN0ZWRcXFwiLCEwKX1mdW5jdGlvbiBzYSgpe3ZhciBhPWIucG9wdXBzLmdldChcXFwiaW1hZ2UuaW5zZXJ0XFxcIik7YXx8KGE9TSgpKSxiLnBvcHVwcy5pc1Zpc2libGUoXFxcImltYWdlLmluc2VydFxcXCIpfHwocygpLGIucG9wdXBzLnJlZnJlc2goXFxcImltYWdlLmluc2VydFxcXCIpLGIucG9wdXBzLnNldENvbnRhaW5lcihcXFwiaW1hZ2UuaW5zZXJ0XFxcIixiLiRzYykpO3ZhciBjPXhhLm9mZnNldCgpLmxlZnQreGEud2lkdGgoKS8yLGQ9eGEub2Zmc2V0KCkudG9wK3hhLmhlaWdodCgpO2IucG9wdXBzLnNob3coXFxcImltYWdlLmluc2VydFxcXCIsYyxkLHhhLm91dGVySGVpZ2h0KCkpfWZ1bmN0aW9uIHRhKCl7aWYoeGEpe2Iuc2VsZWN0aW9uLmNsZWFyKCk7dmFyIGE9Yi5kb2MuY3JlYXRlUmFuZ2UoKTthLnNlbGVjdE5vZGUoeGEuZ2V0KDApKTt2YXIgYz1iLnNlbGVjdGlvbi5nZXQoKTtjLmFkZFJhbmdlKGEpfX1mdW5jdGlvbiB1YSgpe3hhPyhiLmV2ZW50cy5kaXNhYmxlQmx1cigpLGEoXFxcIi5mci1wb3B1cCBpbnB1dDpmb2N1c1xcXCIpLmJsdXIoKSx3KHhhKSk6KGIuZXZlbnRzLmRpc2FibGVCbHVyKCksYi5zZWxlY3Rpb24ucmVzdG9yZSgpLGIuZXZlbnRzLmVuYWJsZUJsdXIoKSxiLnBvcHVwcy5oaWRlKFxcXCJpbWFnZS5pbnNlcnRcXFwiKSxiLnRvb2xiYXIuc2hvd0lubGluZSgpKX1mdW5jdGlvbiB2YSgpe3JldHVybiB4YX1mdW5jdGlvbiB3YShhLGMsZCl7aWYoXFxcInVuZGVmaW5lZFxcXCI9PXR5cGVvZiBjJiYoYz1iLm9wdHMuaW1hZ2VTdHlsZXMpLFxcXCJ1bmRlZmluZWRcXFwiPT10eXBlb2YgZCYmKGQ9Yi5vcHRzLmltYWdlTXVsdGlwbGVTdHlsZXMpLCF4YSlyZXR1cm4hMTtpZighZCl7dmFyIGU9T2JqZWN0LmtleXMoYyk7ZS5zcGxpY2UoZS5pbmRleE9mKGEpLDEpLHhhLnJlbW92ZUNsYXNzKGUuam9pbihcXFwiIFxcXCIpKX1cXFwib2JqZWN0XFxcIj09dHlwZW9mIGNbYV0/KHhhLnJlbW92ZUF0dHIoXFxcInN0eWxlXFxcIikseGEuY3NzKGNbYV0uc3R5bGUpKTp4YS50b2dnbGVDbGFzcyhhKSx3KHhhKX12YXIgeGEseWEsemEsQWEsQmE9ITEsQ2E9MSxEYT0yLEVhPTMsRmE9NCxHYT01LEhhPTYsSWE9NyxKYT17fTtKYVtDYV09XFxcIkltYWdlIGNhbm5vdCBiZSBsb2FkZWQgZnJvbSB0aGUgcGFzc2VkIGxpbmsuXFxcIixKYVtEYV09XFxcIk5vIGxpbmsgaW4gdXBsb2FkIHJlc3BvbnNlLlxcXCIsSmFbRWFdPVxcXCJFcnJvciBkdXJpbmcgZmlsZSB1cGxvYWQuXFxcIixKYVtGYV09XFxcIlBhcnNpbmcgcmVzcG9uc2UgZmFpbGVkLlxcXCIsSmFbR2FdPVxcXCJGaWxlIGlzIHRvbyBsYXJnZS5cXFwiLEphW0hhXT1cXFwiSW1hZ2UgZmlsZSB0eXBlIGlzIGludmFsaWQuXFxcIixKYVtJYV09XFxcIkZpbGVzIGNhbiBiZSB1cGxvYWRlZCBvbmx5IHRvIHNhbWUgZG9tYWluIGluIElFIDggYW5kIElFIDkuXFxcIjt2YXIgS2EsTGEsTWE9ITE7cmV0dXJue19pbml0OmJhLHNob3dJbnNlcnRQb3B1cDpkLHNob3dMYXllcjpWLHJlZnJlc2hVcGxvYWRCdXR0b246VyxyZWZyZXNoQnlVUkxCdXR0b246WCx1cGxvYWQ6SCxpbnNlcnRCeVVSTDp2LGFsaWduOmxhLHJlZnJlc2hBbGlnbjpvYSxyZWZyZXNoQWxpZ25PblNob3c6cGEsZGlzcGxheTpxYSxyZWZyZXNoRGlzcGxheU9uU2hvdzpyYSxyZXBsYWNlOnNhLGJhY2s6dWEsZ2V0OnZhLGluc2VydDp5LHNob3dQcm9ncmVzc0JhcjpyLHJlbW92ZTokLGhpZGVQcm9ncmVzc0JhcjpzLGFwcGx5U3R5bGU6d2Esc2hvd0FsdFBvcHVwOk8sc2hvd1NpemVQb3B1cDpTLHNldEFsdDpRLHNldFNpemU6VSxleGl0RWRpdDpnYSxlZGl0Ond9fSxhLkZFLkRlZmluZUljb24oXFxcImluc2VydEltYWdlXFxcIix7TkFNRTpcXFwiaW1hZ2VcXFwifSksYS5GRS5SZWdpc3RlclNob3J0Y3V0KGEuRkUuS0VZQ09ERS5QLFxcXCJpbnNlcnRJbWFnZVxcXCIsbnVsbCxcXFwiUFxcXCIpLGEuRkUuUmVnaXN0ZXJDb21tYW5kKFxcXCJpbnNlcnRJbWFnZVxcXCIse3RpdGxlOlxcXCJJbnNlcnQgSW1hZ2VcXFwiLHVuZG86ITEsZm9jdXM6ITAscmVmcmVzaEFmdGVyQ2FsbGJhY2s6ITEscG9wdXA6ITAsY2FsbGJhY2s6ZnVuY3Rpb24oKXt0aGlzLnBvcHVwcy5pc1Zpc2libGUoXFxcImltYWdlLmluc2VydFxcXCIpPyh0aGlzLiRlbC5maW5kKFxcXCIuZnItbWFya2VyXFxcIikubGVuZ3RoJiYodGhpcy5ldmVudHMuZGlzYWJsZUJsdXIoKSx0aGlzLnNlbGVjdGlvbi5yZXN0b3JlKCkpLHRoaXMucG9wdXBzLmhpZGUoXFxcImltYWdlLmluc2VydFxcXCIpKTp0aGlzLmltYWdlLnNob3dJbnNlcnRQb3B1cCgpfSxwbHVnaW46XFxcImltYWdlXFxcIn0pLGEuRkUuRGVmaW5lSWNvbihcXFwiaW1hZ2VVcGxvYWRcXFwiLHtOQU1FOlxcXCJ1cGxvYWRcXFwifSksYS5GRS5SZWdpc3RlckNvbW1hbmQoXFxcImltYWdlVXBsb2FkXFxcIix7dGl0bGU6XFxcIlVwbG9hZCBJbWFnZVxcXCIsdW5kbzohMSxmb2N1czohMSx0b2dnbGU6ITAsY2FsbGJhY2s6ZnVuY3Rpb24oKXt0aGlzLmltYWdlLnNob3dMYXllcihcXFwiaW1hZ2UtdXBsb2FkXFxcIil9LHJlZnJlc2g6ZnVuY3Rpb24oYSl7dGhpcy5pbWFnZS5yZWZyZXNoVXBsb2FkQnV0dG9uKGEpfX0pLGEuRkUuRGVmaW5lSWNvbihcXFwiaW1hZ2VCeVVSTFxcXCIse05BTUU6XFxcImxpbmtcXFwifSksYS5GRS5SZWdpc3RlckNvbW1hbmQoXFxcImltYWdlQnlVUkxcXFwiLHt0aXRsZTpcXFwiQnkgVVJMXFxcIix1bmRvOiExLGZvY3VzOiExLHRvZ2dsZTohMCxjYWxsYmFjazpmdW5jdGlvbigpe3RoaXMuaW1hZ2Uuc2hvd0xheWVyKFxcXCJpbWFnZS1ieS11cmxcXFwiKX0scmVmcmVzaDpmdW5jdGlvbihhKXt0aGlzLmltYWdlLnJlZnJlc2hCeVVSTEJ1dHRvbihhKX19KSxhLkZFLlJlZ2lzdGVyQ29tbWFuZChcXFwiaW1hZ2VJbnNlcnRCeVVSTFxcXCIse3RpdGxlOlxcXCJJbnNlcnQgSW1hZ2VcXFwiLHVuZG86ITAscmVmcmVzaEFmdGVyQ2FsbGJhY2s6ITEsY2FsbGJhY2s6ZnVuY3Rpb24oKXt0aGlzLmltYWdlLmluc2VydEJ5VVJMKCl9LHJlZnJlc2g6ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5pbWFnZS5nZXQoKTtiP2EudGV4dCh0aGlzLmxhbmd1YWdlLnRyYW5zbGF0ZShcXFwiUmVwbGFjZVxcXCIpKTphLnRleHQodGhpcy5sYW5ndWFnZS50cmFuc2xhdGUoXFxcIkluc2VydFxcXCIpKX19KSxhLkZFLkRlZmluZUljb24oXFxcImltYWdlRGlzcGxheVxcXCIse05BTUU6XFxcInN0YXJcXFwifSksYS5GRS5SZWdpc3RlckNvbW1hbmQoXFxcImltYWdlRGlzcGxheVxcXCIse3RpdGxlOlxcXCJEaXNwbGF5XFxcIix0eXBlOlxcXCJkcm9wZG93blxcXCIsb3B0aW9uczp7aW5saW5lOlxcXCJJbmxpbmVcXFwiLGJsb2NrOlxcXCJCcmVhayBUZXh0XFxcIn0sY2FsbGJhY2s6ZnVuY3Rpb24oYSxiKXt0aGlzLmltYWdlLmRpc3BsYXkoYil9LHJlZnJlc2g6ZnVuY3Rpb24oYSl7dGhpcy5vcHRzLmltYWdlVGV4dE5lYXJ8fGEuYWRkQ2xhc3MoXFxcImZyLWhpZGRlblxcXCIpfSxyZWZyZXNoT25TaG93OmZ1bmN0aW9uKGEsYil7dGhpcy5pbWFnZS5yZWZyZXNoRGlzcGxheU9uU2hvdyhhLGIpfX0pLGEuRkUuRGVmaW5lSWNvbihcXFwiaW1hZ2UtYWxpZ25cXFwiLHtOQU1FOlxcXCJhbGlnbi1sZWZ0XFxcIn0pLGEuRkUuRGVmaW5lSWNvbihcXFwiaW1hZ2UtYWxpZ24tbGVmdFxcXCIse05BTUU6XFxcImFsaWduLWxlZnRcXFwifSksYS5GRS5EZWZpbmVJY29uKFxcXCJpbWFnZS1hbGlnbi1yaWdodFxcXCIse05BTUU6XFxcImFsaWduLXJpZ2h0XFxcIn0pLGEuRkUuRGVmaW5lSWNvbihcXFwiaW1hZ2UtYWxpZ24tY2VudGVyXFxcIix7TkFNRTpcXFwiYWxpZ24tanVzdGlmeVxcXCJ9KSxhLkZFLkRlZmluZUljb24oXFxcImltYWdlQWxpZ25cXFwiLHtOQU1FOlxcXCJhbGlnbi1qdXN0aWZ5XFxcIn0pLGEuRkUuUmVnaXN0ZXJDb21tYW5kKFxcXCJpbWFnZUFsaWduXFxcIix7dHlwZTpcXFwiZHJvcGRvd25cXFwiLHRpdGxlOlxcXCJBbGlnblxcXCIsb3B0aW9uczp7bGVmdDpcXFwiQWxpZ24gTGVmdFxcXCIsY2VudGVyOlxcXCJOb25lXFxcIixyaWdodDpcXFwiQWxpZ24gUmlnaHRcXFwifSxodG1sOmZ1bmN0aW9uKCl7dmFyIGI9Jzx1bCBjbGFzcz1cXFwiZnItZHJvcGRvd24tbGlzdFxcXCIgcm9sZT1cXFwicHJlc2VudGF0aW9uXFxcIj4nLGM9YS5GRS5DT01NQU5EUy5pbWFnZUFsaWduLm9wdGlvbnM7Zm9yKHZhciBkIGluIGMpYy5oYXNPd25Qcm9wZXJ0eShkKSYmKGIrPSc8bGkgcm9sZT1cXFwicHJlc2VudGF0aW9uXFxcIj48YSBjbGFzcz1cXFwiZnItY29tbWFuZCBmci10aXRsZVxcXCIgdGFiSW5kZXg9XFxcIi0xXFxcIiByb2xlPVxcXCJvcHRpb25cXFwiIGRhdGEtY21kPVxcXCJpbWFnZUFsaWduXFxcIiBkYXRhLXBhcmFtMT1cXFwiJytkKydcXFwiIHRpdGxlPVxcXCInK3RoaXMubGFuZ3VhZ2UudHJhbnNsYXRlKGNbZF0pKydcXFwiPicrdGhpcy5pY29uLmNyZWF0ZShcXFwiaW1hZ2UtYWxpZ24tXFxcIitkKSsnPHNwYW4gY2xhc3M9XFxcImZyLXNyLW9ubHlcXFwiPicrdGhpcy5sYW5ndWFnZS50cmFuc2xhdGUoY1tkXSkrXFxcIjwvc3Bhbj48L2E+PC9saT5cXFwiKTtyZXR1cm4gYis9XFxcIjwvdWw+XFxcIn0sY2FsbGJhY2s6ZnVuY3Rpb24oYSxiKXt0aGlzLmltYWdlLmFsaWduKGIpfSxyZWZyZXNoOmZ1bmN0aW9uKGEpe3RoaXMuaW1hZ2UucmVmcmVzaEFsaWduKGEpfSxyZWZyZXNoT25TaG93OmZ1bmN0aW9uKGEsYil7dGhpcy5pbWFnZS5yZWZyZXNoQWxpZ25PblNob3coYSxiKX19KSxhLkZFLkRlZmluZUljb24oXFxcImltYWdlUmVwbGFjZVxcXCIse05BTUU6XFxcImV4Y2hhbmdlXFxcIn0pLGEuRkUuUmVnaXN0ZXJDb21tYW5kKFxcXCJpbWFnZVJlcGxhY2VcXFwiLHt0aXRsZTpcXFwiUmVwbGFjZVxcXCIsdW5kbzohMSxmb2N1czohMSxwb3B1cDohMCxyZWZyZXNoQWZ0ZXJDYWxsYmFjazohMSxjYWxsYmFjazpmdW5jdGlvbigpe3RoaXMuaW1hZ2UucmVwbGFjZSgpfX0pLGEuRkUuRGVmaW5lSWNvbihcXFwiaW1hZ2VSZW1vdmVcXFwiLHtOQU1FOlxcXCJ0cmFzaFxcXCJ9KSxhLkZFLlJlZ2lzdGVyQ29tbWFuZChcXFwiaW1hZ2VSZW1vdmVcXFwiLHt0aXRsZTpcXFwiUmVtb3ZlXFxcIixjYWxsYmFjazpmdW5jdGlvbigpe3RoaXMuaW1hZ2UucmVtb3ZlKCl9fSksYS5GRS5EZWZpbmVJY29uKFxcXCJpbWFnZUJhY2tcXFwiLHtOQU1FOlxcXCJhcnJvdy1sZWZ0XFxcIn0pLGEuRkUuUmVnaXN0ZXJDb21tYW5kKFxcXCJpbWFnZUJhY2tcXFwiLHt0aXRsZTpcXFwiQmFja1xcXCIsdW5kbzohMSxmb2N1czohMSxiYWNrOiEwLGNhbGxiYWNrOmZ1bmN0aW9uKCl7dGhpcy5pbWFnZS5iYWNrKCl9LHJlZnJlc2g6ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5pbWFnZS5nZXQoKTtifHx0aGlzLm9wdHMudG9vbGJhcklubGluZT8oYS5yZW1vdmVDbGFzcyhcXFwiZnItaGlkZGVuXFxcIiksYS5uZXh0KFxcXCIuZnItc2VwYXJhdG9yXFxcIikucmVtb3ZlQ2xhc3MoXFxcImZyLWhpZGRlblxcXCIpKTooYS5hZGRDbGFzcyhcXFwiZnItaGlkZGVuXFxcIiksYS5uZXh0KFxcXCIuZnItc2VwYXJhdG9yXFxcIikuYWRkQ2xhc3MoXFxcImZyLWhpZGRlblxcXCIpKX19KSxhLkZFLlJlZ2lzdGVyQ29tbWFuZChcXFwiaW1hZ2VEaXNtaXNzRXJyb3JcXFwiLHt0aXRsZTpcXFwiT0tcXFwiLHVuZG86ITEsY2FsbGJhY2s6ZnVuY3Rpb24oKXt0aGlzLmltYWdlLmhpZGVQcm9ncmVzc0JhcighMCl9fSksYS5GRS5EZWZpbmVJY29uKFxcXCJpbWFnZVN0eWxlXFxcIix7TkFNRTpcXFwibWFnaWNcXFwifSksYS5GRS5SZWdpc3RlckNvbW1hbmQoXFxcImltYWdlU3R5bGVcXFwiLHt0aXRsZTpcXFwiU3R5bGVcXFwiLHR5cGU6XFxcImRyb3Bkb3duXFxcIixodG1sOmZ1bmN0aW9uKCl7dmFyIGE9Jzx1bCBjbGFzcz1cXFwiZnItZHJvcGRvd24tbGlzdFxcXCIgcm9sZT1cXFwicHJlc2VudGF0aW9uXFxcIj4nLGI9dGhpcy5vcHRzLmltYWdlU3R5bGVzO2Zvcih2YXIgYyBpbiBiKWlmKGIuaGFzT3duUHJvcGVydHkoYykpe3ZhciBkPWJbY107XFxcIm9iamVjdFxcXCI9PXR5cGVvZiBkJiYoZD1kLnRpdGxlKSxhKz0nPGxpIHJvbGU9XFxcInByZXNlbnRhdGlvblxcXCI+PGEgY2xhc3M9XFxcImZyLWNvbW1hbmRcXFwiIHRhYkluZGV4PVxcXCItMVxcXCIgcm9sZT1cXFwib3B0aW9uXFxcIiBkYXRhLWNtZD1cXFwiaW1hZ2VTdHlsZVxcXCIgZGF0YS1wYXJhbTE9XFxcIicrYysnXFxcIj4nK3RoaXMubGFuZ3VhZ2UudHJhbnNsYXRlKGQpK1xcXCI8L2E+PC9saT5cXFwifXJldHVybiBhKz1cXFwiPC91bD5cXFwifSxjYWxsYmFjazpmdW5jdGlvbihhLGIpe3RoaXMuaW1hZ2UuYXBwbHlTdHlsZShiKX0scmVmcmVzaE9uU2hvdzpmdW5jdGlvbihiLGMpe3ZhciBkPXRoaXMuaW1hZ2UuZ2V0KCk7ZCYmYy5maW5kKFxcXCIuZnItY29tbWFuZFxcXCIpLmVhY2goZnVuY3Rpb24oKXt2YXIgYj1hKHRoaXMpLmRhdGEoXFxcInBhcmFtMVxcXCIpLGM9ZC5oYXNDbGFzcyhiKTthKHRoaXMpLnRvZ2dsZUNsYXNzKFxcXCJmci1hY3RpdmVcXFwiLGMpLmF0dHIoXFxcImFyaWEtc2VsZWN0ZWRcXFwiLGMpfSl9fSksYS5GRS5EZWZpbmVJY29uKFxcXCJpbWFnZUFsdFxcXCIse05BTUU6XFxcImluZm9cXFwifSksYS5GRS5SZWdpc3RlckNvbW1hbmQoXFxcImltYWdlQWx0XFxcIix7dW5kbzohMSxmb2N1czohMSxwb3B1cDohMCx0aXRsZTpcXFwiQWx0ZXJuYXRlIFRleHRcXFwiLGNhbGxiYWNrOmZ1bmN0aW9uKCl7dGhpcy5pbWFnZS5zaG93QWx0UG9wdXAoKX19KSxhLkZFLlJlZ2lzdGVyQ29tbWFuZChcXFwiaW1hZ2VTZXRBbHRcXFwiLHt1bmRvOiEwLGZvY3VzOiExLHRpdGxlOlxcXCJVcGRhdGVcXFwiLHJlZnJlc2hBZnRlckNhbGxiYWNrOiExLGNhbGxiYWNrOmZ1bmN0aW9uKCl7dGhpcy5pbWFnZS5zZXRBbHQoKX19KSxhLkZFLkRlZmluZUljb24oXFxcImltYWdlU2l6ZVxcXCIse05BTUU6XFxcImFycm93cy1hbHRcXFwifSksYS5GRS5SZWdpc3RlckNvbW1hbmQoXFxcImltYWdlU2l6ZVxcXCIse3VuZG86ITEsZm9jdXM6ITEscG9wdXA6ITAsdGl0bGU6XFxcIkNoYW5nZSBTaXplXFxcIixjYWxsYmFjazpmdW5jdGlvbigpe3RoaXMuaW1hZ2Uuc2hvd1NpemVQb3B1cCgpfX0pLGEuRkUuUmVnaXN0ZXJDb21tYW5kKFxcXCJpbWFnZVNldFNpemVcXFwiLHt1bmRvOiEwLGZvY3VzOiExLHRpdGxlOlxcXCJVcGRhdGVcXFwiLHJlZnJlc2hBZnRlckNhbGxiYWNrOiExLGNhbGxiYWNrOmZ1bmN0aW9uKCl7dGhpcy5pbWFnZS5zZXRTaXplKCl9fSl9KTtcIlxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yYXctbG9hZGVyIS4vfi9mcm9hbGEtZWRpdG9yL2pzL3BsdWdpbnMvaW1hZ2UubWluLmpzXG4vLyBtb2R1bGUgaWQgPSAyMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 22 */
/***/ function(module, exports, __webpack_require__) {

	eval("__webpack_require__(2)(__webpack_require__(23))//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjIuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2Zyb2FsYS1lZGl0b3IvanMvbGFuZ3VhZ2VzL2VuX2diLmpzPzczYTgiXSwic291cmNlc0NvbnRlbnQiOlsicmVxdWlyZShcIiEhL3Zhci9hcHAvd2ViL2pzL25vZGVfbW9kdWxlcy9zY3JpcHQtbG9hZGVyL2FkZFNjcmlwdC5qc1wiKShyZXF1aXJlKFwiISEvdmFyL2FwcC93ZWIvanMvbm9kZV9tb2R1bGVzL3Jhdy1sb2FkZXIvaW5kZXguanMhL3Zhci9hcHAvd2ViL2pzL25vZGVfbW9kdWxlcy9mcm9hbGEtZWRpdG9yL2pzL2xhbmd1YWdlcy9lbl9nYi5qc1wiKSlcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vc2NyaXB0LWxvYWRlciEuL34vZnJvYWxhLWVkaXRvci9qcy9sYW5ndWFnZXMvZW5fZ2IuanNcbi8vIG1vZHVsZSBpZCA9IDIyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 23 */
/***/ function(module, exports) {

	eval("module.exports = \"/*!\\n * froala_editor v2.5.1 (https://www.froala.com/wysiwyg-editor)\\n * License https://froala.com/wysiwyg-editor/terms/\\n * Copyright 2014-2017 Froala Labs\\n */\\n\\n/**\\n * English spoken in Great Britain\\n */\\n\\n$.FE.LANGUAGE['en_gb'] = {\\n  translation: {\\n    // Place holder\\n    \\\"Type something\\\": \\\"Type something\\\",\\n\\n    // Basic formatting\\n    \\\"Bold\\\": \\\"Bold\\\",\\n    \\\"Italic\\\": \\\"Italic\\\",\\n    \\\"Underline\\\": \\\"Underline\\\",\\n    \\\"Strikethrough\\\": \\\"Strikethrough\\\",\\n\\n    // Main buttons\\n    \\\"Insert\\\": \\\"Insert\\\",\\n    \\\"Delete\\\": \\\"Delete\\\",\\n    \\\"Cancel\\\": \\\"Cancel\\\",\\n    \\\"OK\\\": \\\"OK\\\",\\n    \\\"Back\\\": \\\"Back\\\",\\n    \\\"Remove\\\": \\\"Remove\\\",\\n    \\\"More\\\": \\\"More\\\",\\n    \\\"Update\\\": \\\"Update\\\",\\n    \\\"Style\\\": \\\"Style\\\",\\n\\n    // Font\\n    \\\"Font Family\\\": \\\"Font Family\\\",\\n    \\\"Font Size\\\": \\\"Font Size\\\",\\n\\n    // Colors\\n    \\\"Colors\\\": \\\"Colours\\\",\\n    \\\"Background\\\": \\\"Background\\\",\\n    \\\"Text\\\": \\\"Text\\\",\\n\\n    // Paragraphs\\n    \\\"Paragraph Format\\\": \\\"Paragraph Format\\\",\\n    \\\"Normal\\\": \\\"Normal\\\",\\n    \\\"Code\\\": \\\"Code\\\",\\n    \\\"Heading 1\\\": \\\"Heading 1\\\",\\n    \\\"Heading 2\\\": \\\"Heading 2\\\",\\n    \\\"Heading 3\\\": \\\"Heading 3\\\",\\n    \\\"Heading 4\\\": \\\"Heading 4\\\",\\n\\n    // Style\\n    \\\"Paragraph Style\\\": \\\"Paragraph Style\\\",\\n    \\\"Inline Style\\\": \\\"Inline Style\\\",\\n\\n    // Alignment\\n    \\\"Align\\\": \\\"Align\\\",\\n    \\\"Align Left\\\": \\\"Align Left\\\",\\n    \\\"Align Center\\\": \\\"Align Centre\\\",\\n    \\\"Align Right\\\": \\\"Alight Right\\\",\\n    \\\"Align Justify\\\": \\\"Align Justify\\\",\\n    \\\"None\\\": \\\"None\\\",\\n\\n    // Lists\\n    \\\"Ordered List\\\": \\\"Ordered List\\\",\\n    \\\"Unordered List\\\": \\\"Unordered List\\\",\\n\\n    // Indent\\n    \\\"Decrease Indent\\\": \\\"Decrease Indent\\\",\\n    \\\"Increase Indent\\\": \\\"Increase Indent\\\",\\n\\n    // Links\\n    \\\"Insert Link\\\": \\\"Insert Link\\\",\\n    \\\"Open in new tab\\\": \\\"Open in new tab\\\",\\n    \\\"Open Link\\\": \\\"Open Link\\\",\\n    \\\"Edit Link\\\": \\\"Edit Link\\\",\\n    \\\"Unlink\\\": \\\"Unlink\\\",\\n    \\\"Choose Link\\\": \\\"Choose Link\\\",\\n\\n    // Images\\n    \\\"Insert Image\\\": \\\"Insert Image\\\",\\n    \\\"Upload Image\\\": \\\"Upload Image\\\",\\n    \\\"By URL\\\": \\\"By URL\\\",\\n    \\\"Browse\\\": \\\"Browse\\\",\\n    \\\"Drop image\\\": \\\"Drop image\\\",\\n    \\\"or click\\\": \\\"or click\\\",\\n    \\\"Manage Images\\\": \\\"Manage Images\\\",\\n    \\\"Loading\\\": \\\"Loading\\\",\\n    \\\"Deleting\\\": \\\"Deleting\\\",\\n    \\\"Tags\\\": \\\"Tags\\\",\\n    \\\"Are you sure? Image will be deleted.\\\": \\\"Are you sure? Image will be deleted.\\\",\\n    \\\"Replace\\\": \\\"Replace\\\",\\n    \\\"Uploading\\\": \\\"Uploading\\\",\\n    \\\"Loading image\\\": \\\"Loading image\\\",\\n    \\\"Display\\\": \\\"Display\\\",\\n    \\\"Inline\\\": \\\"Inline\\\",\\n    \\\"Break Text\\\": \\\"Break Text\\\",\\n    \\\"Alternate Text\\\": \\\"Alternate Text\\\",\\n    \\\"Change Size\\\": \\\"Change Size\\\",\\n    \\\"Width\\\": \\\"Width\\\",\\n    \\\"Height\\\": \\\"Height\\\",\\n    \\\"Something went wrong. Please try again.\\\": \\\"Something went wrong. Please try again.\\\",\\n\\n    // Video\\n    \\\"Insert Video\\\": \\\"Insert Video\\\",\\n    \\\"Embedded Code\\\": \\\"Embedded Code\\\",\\n\\n    // Tables\\n    \\\"Insert Table\\\": \\\"Insert Table\\\",\\n    \\\"Table Header\\\": \\\"Table Header\\\",\\n    \\\"Remove Table\\\": \\\"Remove Table\\\",\\n    \\\"Table Style\\\": \\\"Table Style\\\",\\n    \\\"Horizontal Align\\\": \\\"Horizontal Align\\\",\\n    \\\"Row\\\": \\\"Row\\\",\\n    \\\"Insert row above\\\": \\\"Insert row above\\\",\\n    \\\"Insert row below\\\": \\\"Insert row below\\\",\\n    \\\"Delete row\\\": \\\"Delete row\\\",\\n    \\\"Column\\\": \\\"Column\\\",\\n    \\\"Insert column before\\\": \\\"Insert column before\\\",\\n    \\\"Insert column after\\\": \\\"Insert column after\\\",\\n    \\\"Delete column\\\": \\\"Delete column\\\",\\n    \\\"Cell\\\": \\\"Cell\\\",\\n    \\\"Merge cells\\\": \\\"Merge cells\\\",\\n    \\\"Horizontal split\\\": \\\"Horizontal split\\\",\\n    \\\"Vertical split\\\": \\\"Vertical split\\\",\\n    \\\"Cell Background\\\": \\\"Cell Background\\\",\\n    \\\"Vertical Align\\\": \\\"Vertical Align\\\",\\n    \\\"Top\\\": \\\"Top\\\",\\n    \\\"Middle\\\": \\\"Middle\\\",\\n    \\\"Bottom\\\": \\\"Bottom\\\",\\n    \\\"Align Top\\\": \\\"Align Top\\\",\\n    \\\"Align Middle\\\": \\\"Align Middle\\\",\\n    \\\"Align Bottom\\\": \\\"Align Bottom\\\",\\n    \\\"Cell Style\\\": \\\"Cell Style\\\",\\n\\n    // Files\\n    \\\"Upload File\\\": \\\"Upload File\\\",\\n    \\\"Drop file\\\": \\\"Drop file\\\",\\n\\n    // Emoticons\\n    \\\"Emoticons\\\": \\\"Emoticons\\\",\\n\\n    // Line breaker\\n    \\\"Break\\\": \\\"Break\\\",\\n\\n    // Math\\n    \\\"Subscript\\\": \\\"Subscript\\\",\\n    \\\"Superscript\\\": \\\"Superscript\\\",\\n\\n    // Full screen\\n    \\\"Fullscreen\\\": \\\"Fullscreen\\\",\\n\\n    // Horizontal line\\n    \\\"Insert Horizontal Line\\\": \\\"Insert Horizontal Line\\\",\\n\\n    // Clear formatting\\n    \\\"Clear Formatting\\\": \\\"Cell Formatting\\\",\\n\\n    // Undo, redo\\n    \\\"Undo\\\": \\\"Undo\\\",\\n    \\\"Redo\\\": \\\"Redo\\\",\\n\\n    // Select all\\n    \\\"Select All\\\": \\\"Select All\\\",\\n\\n    // Code view\\n    \\\"Code View\\\": \\\"Code View\\\",\\n\\n    // Quote\\n    \\\"Quote\\\": \\\"Quote\\\",\\n    \\\"Increase\\\": \\\"Increase\\\",\\n    \\\"Decrease\\\": \\\"Decrease\\\",\\n\\n    // Quick Insert\\n    \\\"Quick Insert\\\": \\\"Quick Insert\\\"\\n  },\\n  direction: \\\"ltr\\\"\\n};\\n\"//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2Zyb2FsYS1lZGl0b3IvanMvbGFuZ3VhZ2VzL2VuX2diLmpzP2U4NTUiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBcIi8qIVxcbiAqIGZyb2FsYV9lZGl0b3IgdjIuNS4xIChodHRwczovL3d3dy5mcm9hbGEuY29tL3d5c2l3eWctZWRpdG9yKVxcbiAqIExpY2Vuc2UgaHR0cHM6Ly9mcm9hbGEuY29tL3d5c2l3eWctZWRpdG9yL3Rlcm1zL1xcbiAqIENvcHlyaWdodCAyMDE0LTIwMTcgRnJvYWxhIExhYnNcXG4gKi9cXG5cXG4vKipcXG4gKiBFbmdsaXNoIHNwb2tlbiBpbiBHcmVhdCBCcml0YWluXFxuICovXFxuXFxuJC5GRS5MQU5HVUFHRVsnZW5fZ2InXSA9IHtcXG4gIHRyYW5zbGF0aW9uOiB7XFxuICAgIC8vIFBsYWNlIGhvbGRlclxcbiAgICBcXFwiVHlwZSBzb21ldGhpbmdcXFwiOiBcXFwiVHlwZSBzb21ldGhpbmdcXFwiLFxcblxcbiAgICAvLyBCYXNpYyBmb3JtYXR0aW5nXFxuICAgIFxcXCJCb2xkXFxcIjogXFxcIkJvbGRcXFwiLFxcbiAgICBcXFwiSXRhbGljXFxcIjogXFxcIkl0YWxpY1xcXCIsXFxuICAgIFxcXCJVbmRlcmxpbmVcXFwiOiBcXFwiVW5kZXJsaW5lXFxcIixcXG4gICAgXFxcIlN0cmlrZXRocm91Z2hcXFwiOiBcXFwiU3RyaWtldGhyb3VnaFxcXCIsXFxuXFxuICAgIC8vIE1haW4gYnV0dG9uc1xcbiAgICBcXFwiSW5zZXJ0XFxcIjogXFxcIkluc2VydFxcXCIsXFxuICAgIFxcXCJEZWxldGVcXFwiOiBcXFwiRGVsZXRlXFxcIixcXG4gICAgXFxcIkNhbmNlbFxcXCI6IFxcXCJDYW5jZWxcXFwiLFxcbiAgICBcXFwiT0tcXFwiOiBcXFwiT0tcXFwiLFxcbiAgICBcXFwiQmFja1xcXCI6IFxcXCJCYWNrXFxcIixcXG4gICAgXFxcIlJlbW92ZVxcXCI6IFxcXCJSZW1vdmVcXFwiLFxcbiAgICBcXFwiTW9yZVxcXCI6IFxcXCJNb3JlXFxcIixcXG4gICAgXFxcIlVwZGF0ZVxcXCI6IFxcXCJVcGRhdGVcXFwiLFxcbiAgICBcXFwiU3R5bGVcXFwiOiBcXFwiU3R5bGVcXFwiLFxcblxcbiAgICAvLyBGb250XFxuICAgIFxcXCJGb250IEZhbWlseVxcXCI6IFxcXCJGb250IEZhbWlseVxcXCIsXFxuICAgIFxcXCJGb250IFNpemVcXFwiOiBcXFwiRm9udCBTaXplXFxcIixcXG5cXG4gICAgLy8gQ29sb3JzXFxuICAgIFxcXCJDb2xvcnNcXFwiOiBcXFwiQ29sb3Vyc1xcXCIsXFxuICAgIFxcXCJCYWNrZ3JvdW5kXFxcIjogXFxcIkJhY2tncm91bmRcXFwiLFxcbiAgICBcXFwiVGV4dFxcXCI6IFxcXCJUZXh0XFxcIixcXG5cXG4gICAgLy8gUGFyYWdyYXBoc1xcbiAgICBcXFwiUGFyYWdyYXBoIEZvcm1hdFxcXCI6IFxcXCJQYXJhZ3JhcGggRm9ybWF0XFxcIixcXG4gICAgXFxcIk5vcm1hbFxcXCI6IFxcXCJOb3JtYWxcXFwiLFxcbiAgICBcXFwiQ29kZVxcXCI6IFxcXCJDb2RlXFxcIixcXG4gICAgXFxcIkhlYWRpbmcgMVxcXCI6IFxcXCJIZWFkaW5nIDFcXFwiLFxcbiAgICBcXFwiSGVhZGluZyAyXFxcIjogXFxcIkhlYWRpbmcgMlxcXCIsXFxuICAgIFxcXCJIZWFkaW5nIDNcXFwiOiBcXFwiSGVhZGluZyAzXFxcIixcXG4gICAgXFxcIkhlYWRpbmcgNFxcXCI6IFxcXCJIZWFkaW5nIDRcXFwiLFxcblxcbiAgICAvLyBTdHlsZVxcbiAgICBcXFwiUGFyYWdyYXBoIFN0eWxlXFxcIjogXFxcIlBhcmFncmFwaCBTdHlsZVxcXCIsXFxuICAgIFxcXCJJbmxpbmUgU3R5bGVcXFwiOiBcXFwiSW5saW5lIFN0eWxlXFxcIixcXG5cXG4gICAgLy8gQWxpZ25tZW50XFxuICAgIFxcXCJBbGlnblxcXCI6IFxcXCJBbGlnblxcXCIsXFxuICAgIFxcXCJBbGlnbiBMZWZ0XFxcIjogXFxcIkFsaWduIExlZnRcXFwiLFxcbiAgICBcXFwiQWxpZ24gQ2VudGVyXFxcIjogXFxcIkFsaWduIENlbnRyZVxcXCIsXFxuICAgIFxcXCJBbGlnbiBSaWdodFxcXCI6IFxcXCJBbGlnaHQgUmlnaHRcXFwiLFxcbiAgICBcXFwiQWxpZ24gSnVzdGlmeVxcXCI6IFxcXCJBbGlnbiBKdXN0aWZ5XFxcIixcXG4gICAgXFxcIk5vbmVcXFwiOiBcXFwiTm9uZVxcXCIsXFxuXFxuICAgIC8vIExpc3RzXFxuICAgIFxcXCJPcmRlcmVkIExpc3RcXFwiOiBcXFwiT3JkZXJlZCBMaXN0XFxcIixcXG4gICAgXFxcIlVub3JkZXJlZCBMaXN0XFxcIjogXFxcIlVub3JkZXJlZCBMaXN0XFxcIixcXG5cXG4gICAgLy8gSW5kZW50XFxuICAgIFxcXCJEZWNyZWFzZSBJbmRlbnRcXFwiOiBcXFwiRGVjcmVhc2UgSW5kZW50XFxcIixcXG4gICAgXFxcIkluY3JlYXNlIEluZGVudFxcXCI6IFxcXCJJbmNyZWFzZSBJbmRlbnRcXFwiLFxcblxcbiAgICAvLyBMaW5rc1xcbiAgICBcXFwiSW5zZXJ0IExpbmtcXFwiOiBcXFwiSW5zZXJ0IExpbmtcXFwiLFxcbiAgICBcXFwiT3BlbiBpbiBuZXcgdGFiXFxcIjogXFxcIk9wZW4gaW4gbmV3IHRhYlxcXCIsXFxuICAgIFxcXCJPcGVuIExpbmtcXFwiOiBcXFwiT3BlbiBMaW5rXFxcIixcXG4gICAgXFxcIkVkaXQgTGlua1xcXCI6IFxcXCJFZGl0IExpbmtcXFwiLFxcbiAgICBcXFwiVW5saW5rXFxcIjogXFxcIlVubGlua1xcXCIsXFxuICAgIFxcXCJDaG9vc2UgTGlua1xcXCI6IFxcXCJDaG9vc2UgTGlua1xcXCIsXFxuXFxuICAgIC8vIEltYWdlc1xcbiAgICBcXFwiSW5zZXJ0IEltYWdlXFxcIjogXFxcIkluc2VydCBJbWFnZVxcXCIsXFxuICAgIFxcXCJVcGxvYWQgSW1hZ2VcXFwiOiBcXFwiVXBsb2FkIEltYWdlXFxcIixcXG4gICAgXFxcIkJ5IFVSTFxcXCI6IFxcXCJCeSBVUkxcXFwiLFxcbiAgICBcXFwiQnJvd3NlXFxcIjogXFxcIkJyb3dzZVxcXCIsXFxuICAgIFxcXCJEcm9wIGltYWdlXFxcIjogXFxcIkRyb3AgaW1hZ2VcXFwiLFxcbiAgICBcXFwib3IgY2xpY2tcXFwiOiBcXFwib3IgY2xpY2tcXFwiLFxcbiAgICBcXFwiTWFuYWdlIEltYWdlc1xcXCI6IFxcXCJNYW5hZ2UgSW1hZ2VzXFxcIixcXG4gICAgXFxcIkxvYWRpbmdcXFwiOiBcXFwiTG9hZGluZ1xcXCIsXFxuICAgIFxcXCJEZWxldGluZ1xcXCI6IFxcXCJEZWxldGluZ1xcXCIsXFxuICAgIFxcXCJUYWdzXFxcIjogXFxcIlRhZ3NcXFwiLFxcbiAgICBcXFwiQXJlIHlvdSBzdXJlPyBJbWFnZSB3aWxsIGJlIGRlbGV0ZWQuXFxcIjogXFxcIkFyZSB5b3Ugc3VyZT8gSW1hZ2Ugd2lsbCBiZSBkZWxldGVkLlxcXCIsXFxuICAgIFxcXCJSZXBsYWNlXFxcIjogXFxcIlJlcGxhY2VcXFwiLFxcbiAgICBcXFwiVXBsb2FkaW5nXFxcIjogXFxcIlVwbG9hZGluZ1xcXCIsXFxuICAgIFxcXCJMb2FkaW5nIGltYWdlXFxcIjogXFxcIkxvYWRpbmcgaW1hZ2VcXFwiLFxcbiAgICBcXFwiRGlzcGxheVxcXCI6IFxcXCJEaXNwbGF5XFxcIixcXG4gICAgXFxcIklubGluZVxcXCI6IFxcXCJJbmxpbmVcXFwiLFxcbiAgICBcXFwiQnJlYWsgVGV4dFxcXCI6IFxcXCJCcmVhayBUZXh0XFxcIixcXG4gICAgXFxcIkFsdGVybmF0ZSBUZXh0XFxcIjogXFxcIkFsdGVybmF0ZSBUZXh0XFxcIixcXG4gICAgXFxcIkNoYW5nZSBTaXplXFxcIjogXFxcIkNoYW5nZSBTaXplXFxcIixcXG4gICAgXFxcIldpZHRoXFxcIjogXFxcIldpZHRoXFxcIixcXG4gICAgXFxcIkhlaWdodFxcXCI6IFxcXCJIZWlnaHRcXFwiLFxcbiAgICBcXFwiU29tZXRoaW5nIHdlbnQgd3JvbmcuIFBsZWFzZSB0cnkgYWdhaW4uXFxcIjogXFxcIlNvbWV0aGluZyB3ZW50IHdyb25nLiBQbGVhc2UgdHJ5IGFnYWluLlxcXCIsXFxuXFxuICAgIC8vIFZpZGVvXFxuICAgIFxcXCJJbnNlcnQgVmlkZW9cXFwiOiBcXFwiSW5zZXJ0IFZpZGVvXFxcIixcXG4gICAgXFxcIkVtYmVkZGVkIENvZGVcXFwiOiBcXFwiRW1iZWRkZWQgQ29kZVxcXCIsXFxuXFxuICAgIC8vIFRhYmxlc1xcbiAgICBcXFwiSW5zZXJ0IFRhYmxlXFxcIjogXFxcIkluc2VydCBUYWJsZVxcXCIsXFxuICAgIFxcXCJUYWJsZSBIZWFkZXJcXFwiOiBcXFwiVGFibGUgSGVhZGVyXFxcIixcXG4gICAgXFxcIlJlbW92ZSBUYWJsZVxcXCI6IFxcXCJSZW1vdmUgVGFibGVcXFwiLFxcbiAgICBcXFwiVGFibGUgU3R5bGVcXFwiOiBcXFwiVGFibGUgU3R5bGVcXFwiLFxcbiAgICBcXFwiSG9yaXpvbnRhbCBBbGlnblxcXCI6IFxcXCJIb3Jpem9udGFsIEFsaWduXFxcIixcXG4gICAgXFxcIlJvd1xcXCI6IFxcXCJSb3dcXFwiLFxcbiAgICBcXFwiSW5zZXJ0IHJvdyBhYm92ZVxcXCI6IFxcXCJJbnNlcnQgcm93IGFib3ZlXFxcIixcXG4gICAgXFxcIkluc2VydCByb3cgYmVsb3dcXFwiOiBcXFwiSW5zZXJ0IHJvdyBiZWxvd1xcXCIsXFxuICAgIFxcXCJEZWxldGUgcm93XFxcIjogXFxcIkRlbGV0ZSByb3dcXFwiLFxcbiAgICBcXFwiQ29sdW1uXFxcIjogXFxcIkNvbHVtblxcXCIsXFxuICAgIFxcXCJJbnNlcnQgY29sdW1uIGJlZm9yZVxcXCI6IFxcXCJJbnNlcnQgY29sdW1uIGJlZm9yZVxcXCIsXFxuICAgIFxcXCJJbnNlcnQgY29sdW1uIGFmdGVyXFxcIjogXFxcIkluc2VydCBjb2x1bW4gYWZ0ZXJcXFwiLFxcbiAgICBcXFwiRGVsZXRlIGNvbHVtblxcXCI6IFxcXCJEZWxldGUgY29sdW1uXFxcIixcXG4gICAgXFxcIkNlbGxcXFwiOiBcXFwiQ2VsbFxcXCIsXFxuICAgIFxcXCJNZXJnZSBjZWxsc1xcXCI6IFxcXCJNZXJnZSBjZWxsc1xcXCIsXFxuICAgIFxcXCJIb3Jpem9udGFsIHNwbGl0XFxcIjogXFxcIkhvcml6b250YWwgc3BsaXRcXFwiLFxcbiAgICBcXFwiVmVydGljYWwgc3BsaXRcXFwiOiBcXFwiVmVydGljYWwgc3BsaXRcXFwiLFxcbiAgICBcXFwiQ2VsbCBCYWNrZ3JvdW5kXFxcIjogXFxcIkNlbGwgQmFja2dyb3VuZFxcXCIsXFxuICAgIFxcXCJWZXJ0aWNhbCBBbGlnblxcXCI6IFxcXCJWZXJ0aWNhbCBBbGlnblxcXCIsXFxuICAgIFxcXCJUb3BcXFwiOiBcXFwiVG9wXFxcIixcXG4gICAgXFxcIk1pZGRsZVxcXCI6IFxcXCJNaWRkbGVcXFwiLFxcbiAgICBcXFwiQm90dG9tXFxcIjogXFxcIkJvdHRvbVxcXCIsXFxuICAgIFxcXCJBbGlnbiBUb3BcXFwiOiBcXFwiQWxpZ24gVG9wXFxcIixcXG4gICAgXFxcIkFsaWduIE1pZGRsZVxcXCI6IFxcXCJBbGlnbiBNaWRkbGVcXFwiLFxcbiAgICBcXFwiQWxpZ24gQm90dG9tXFxcIjogXFxcIkFsaWduIEJvdHRvbVxcXCIsXFxuICAgIFxcXCJDZWxsIFN0eWxlXFxcIjogXFxcIkNlbGwgU3R5bGVcXFwiLFxcblxcbiAgICAvLyBGaWxlc1xcbiAgICBcXFwiVXBsb2FkIEZpbGVcXFwiOiBcXFwiVXBsb2FkIEZpbGVcXFwiLFxcbiAgICBcXFwiRHJvcCBmaWxlXFxcIjogXFxcIkRyb3AgZmlsZVxcXCIsXFxuXFxuICAgIC8vIEVtb3RpY29uc1xcbiAgICBcXFwiRW1vdGljb25zXFxcIjogXFxcIkVtb3RpY29uc1xcXCIsXFxuXFxuICAgIC8vIExpbmUgYnJlYWtlclxcbiAgICBcXFwiQnJlYWtcXFwiOiBcXFwiQnJlYWtcXFwiLFxcblxcbiAgICAvLyBNYXRoXFxuICAgIFxcXCJTdWJzY3JpcHRcXFwiOiBcXFwiU3Vic2NyaXB0XFxcIixcXG4gICAgXFxcIlN1cGVyc2NyaXB0XFxcIjogXFxcIlN1cGVyc2NyaXB0XFxcIixcXG5cXG4gICAgLy8gRnVsbCBzY3JlZW5cXG4gICAgXFxcIkZ1bGxzY3JlZW5cXFwiOiBcXFwiRnVsbHNjcmVlblxcXCIsXFxuXFxuICAgIC8vIEhvcml6b250YWwgbGluZVxcbiAgICBcXFwiSW5zZXJ0IEhvcml6b250YWwgTGluZVxcXCI6IFxcXCJJbnNlcnQgSG9yaXpvbnRhbCBMaW5lXFxcIixcXG5cXG4gICAgLy8gQ2xlYXIgZm9ybWF0dGluZ1xcbiAgICBcXFwiQ2xlYXIgRm9ybWF0dGluZ1xcXCI6IFxcXCJDZWxsIEZvcm1hdHRpbmdcXFwiLFxcblxcbiAgICAvLyBVbmRvLCByZWRvXFxuICAgIFxcXCJVbmRvXFxcIjogXFxcIlVuZG9cXFwiLFxcbiAgICBcXFwiUmVkb1xcXCI6IFxcXCJSZWRvXFxcIixcXG5cXG4gICAgLy8gU2VsZWN0IGFsbFxcbiAgICBcXFwiU2VsZWN0IEFsbFxcXCI6IFxcXCJTZWxlY3QgQWxsXFxcIixcXG5cXG4gICAgLy8gQ29kZSB2aWV3XFxuICAgIFxcXCJDb2RlIFZpZXdcXFwiOiBcXFwiQ29kZSBWaWV3XFxcIixcXG5cXG4gICAgLy8gUXVvdGVcXG4gICAgXFxcIlF1b3RlXFxcIjogXFxcIlF1b3RlXFxcIixcXG4gICAgXFxcIkluY3JlYXNlXFxcIjogXFxcIkluY3JlYXNlXFxcIixcXG4gICAgXFxcIkRlY3JlYXNlXFxcIjogXFxcIkRlY3JlYXNlXFxcIixcXG5cXG4gICAgLy8gUXVpY2sgSW5zZXJ0XFxuICAgIFxcXCJRdWljayBJbnNlcnRcXFwiOiBcXFwiUXVpY2sgSW5zZXJ0XFxcIlxcbiAgfSxcXG4gIGRpcmVjdGlvbjogXFxcImx0clxcXCJcXG59O1xcblwiXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3Jhdy1sb2FkZXIhLi9+L2Zyb2FsYS1lZGl0b3IvanMvbGFuZ3VhZ2VzL2VuX2diLmpzXG4vLyBtb2R1bGUgaWQgPSAyM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9");

/***/ }
]);