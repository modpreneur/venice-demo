webpackJsonp([0],[
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\n__webpack_require__(1);\n\n__webpack_require__(4);\n\n__webpack_require__(6);\n\n__webpack_require__(8);\n\n__webpack_require__(10);\n\n__webpack_require__(12);\n\n__webpack_require__(14);\n\n__webpack_require__(16);\n\n__webpack_require__(18);\n\n__webpack_require__(20);\n\n__webpack_require__(22);//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9ub2RlX21vZHVsZXMvdmVuaWNlLWpzL21haW5Gcm9hbGEuanM/NWM3MyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENyZWF0ZWQgYnkgYnVyMDEgb24gOS8xMi8xNi5cbiAqL1xuaW1wb3J0ICdzY3JpcHQhZnJvYWxhLWVkaXRvci9qcy9mcm9hbGFfZWRpdG9yLm1pbi5qcyc7XG5pbXBvcnQgJ3NjcmlwdCFjb2RlbWlycm9yL2xpYi9jb2RlbWlycm9yLmpzJztcbmltcG9ydCAnc2NyaXB0IWNvZGVtaXJyb3IvbW9kZS94bWwveG1sLmpzJztcbmltcG9ydCAnc2NyaXB0IWZyb2FsYS1lZGl0b3IvanMvcGx1Z2lucy9hbGlnbi5taW4uanMnO1xuaW1wb3J0ICdzY3JpcHQhZnJvYWxhLWVkaXRvci9qcy9wbHVnaW5zL2NoYXJfY291bnRlci5taW4uanMnO1xuaW1wb3J0ICdzY3JpcHQhZnJvYWxhLWVkaXRvci9qcy9wbHVnaW5zL2NvZGVfdmlldy5taW4uanMnO1xuaW1wb3J0ICdzY3JpcHQhZnJvYWxhLWVkaXRvci9qcy9wbHVnaW5zL2VudGl0aWVzLm1pbi5qcyc7XG5pbXBvcnQgJ3NjcmlwdCFmcm9hbGEtZWRpdG9yL2pzL3BsdWdpbnMvbGluay5taW4uanMnO1xuaW1wb3J0ICdzY3JpcHQhZnJvYWxhLWVkaXRvci9qcy9wbHVnaW5zL3VybC5taW4uanMnO1xuaW1wb3J0ICdzY3JpcHQhZnJvYWxhLWVkaXRvci9qcy9wbHVnaW5zL2ltYWdlLm1pbi5qcyc7XG5pbXBvcnQgJ3NjcmlwdCFmcm9hbGEtZWRpdG9yL2pzL2xhbmd1YWdlcy9lbl9nYi5qcyc7XG5cblxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIG5vZGVfbW9kdWxlcy92ZW5pY2UtanMvbWFpbkZyb2FsYS5qcyJdLCJtYXBwaW5ncyI6Ijs7QUFHQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUEiLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	eval("__webpack_require__(2)(__webpack_require__(3))//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL34vZnJvYWxhLWVkaXRvci9qcy9mcm9hbGFfZWRpdG9yLm1pbi5qcz9hOWQwIl0sInNvdXJjZXNDb250ZW50IjpbInJlcXVpcmUoXCIhIS9Vc2Vycy9qYWt1YmZhamt1cy9Eb2N1bWVudHMvcHJhY2UvdmVuaWNlLWRlbW8vd2ViL2pzL25vZGVfbW9kdWxlcy9zY3JpcHQtbG9hZGVyL2FkZFNjcmlwdC5qc1wiKShyZXF1aXJlKFwiISEvVXNlcnMvamFrdWJmYWprdXMvRG9jdW1lbnRzL3ByYWNlL3ZlbmljZS1kZW1vL3dlYi9qcy9ub2RlX21vZHVsZXMvcmF3LWxvYWRlci9pbmRleC5qcyEvVXNlcnMvamFrdWJmYWprdXMvRG9jdW1lbnRzL3ByYWNlL3ZlbmljZS1kZW1vL3dlYi9qcy9ub2RlX21vZHVsZXMvZnJvYWxhLWVkaXRvci9qcy9mcm9hbGFfZWRpdG9yLm1pbi5qc1wiKSlcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vc2NyaXB0LWxvYWRlciEuL34vZnJvYWxhLWVkaXRvci9qcy9mcm9hbGFfZWRpdG9yLm1pbi5qc1xuLy8gbW9kdWxlIGlkID0gMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 2 */
/***/ function(module, exports) {

	eval("/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\r\nmodule.exports = function(src) {\r\n\tif (typeof execScript !== \"undefined\")\r\n\t\texecScript(src);\r\n\telse\r\n\t\teval.call(null, src);\r\n}\r\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL34vc2NyaXB0LWxvYWRlci9hZGRTY3JpcHQuanM/ODEwNyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxyXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXHJcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxyXG4qL1xyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHNyYykge1xyXG5cdGlmICh0eXBlb2YgZXhlY1NjcmlwdCAhPT0gXCJ1bmRlZmluZWRcIilcclxuXHRcdGV4ZWNTY3JpcHQoc3JjKTtcclxuXHRlbHNlXHJcblx0XHRldmFsLmNhbGwobnVsbCwgc3JjKTtcclxufVxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vc2NyaXB0LWxvYWRlci9hZGRTY3JpcHQuanNcbi8vIG1vZHVsZSBpZCA9IDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 3 */
/***/ function(module, exports) {

	eval("module.exports = \"/*!\\n * froala_editor v2.5.0 (https://www.froala.com/wysiwyg-editor)\\n * License https://froala.com/wysiwyg-editor/terms/\\n * Copyright 2014-2017 Froala Labs\\n */\\n\\n!function(a){\\\"function\\\"==typeof define&&define.amd?define([\\\"jquery\\\"],a):\\\"object\\\"==typeof module&&module.exports?module.exports=function(b,c){return void 0===c&&(c=\\\"undefined\\\"!=typeof window?require(\\\"jquery\\\"):require(\\\"jquery\\\")(b)),a(c)}:a(window.jQuery)}(function(a){var b=function(c,d){this.id=++a.FE.ID,this.opts=a.extend(!0,{},a.extend({},b.DEFAULTS,\\\"object\\\"==typeof d&&d));var e=JSON.stringify(this.opts);a.FE.OPTS_MAPPING[e]=a.FE.OPTS_MAPPING[e]||this.id,this.sid=a.FE.OPTS_MAPPING[e],a.FE.SHARED[this.sid]=a.FE.SHARED[this.sid]||{},this.shared=a.FE.SHARED[this.sid],this.shared.count=(this.shared.count||0)+1,this.$oel=a(c),this.$oel.data(\\\"froala.editor\\\",this),this.o_doc=c.ownerDocument,this.o_win=\\\"defaultView\\\"in this.o_doc?this.o_doc.defaultView:this.o_doc.parentWindow;var f=a(this.o_win).scrollTop();this.$oel.on(\\\"froala.doInit\\\",a.proxy(function(){this.$oel.off(\\\"froala.doInit\\\"),this.doc=this.$el.get(0).ownerDocument,this.win=\\\"defaultView\\\"in this.doc?this.doc.defaultView:this.doc.parentWindow,this.$doc=a(this.doc),this.$win=a(this.win),this.opts.pluginsEnabled||(this.opts.pluginsEnabled=Object.keys(a.FE.PLUGINS)),this.opts.initOnClick?(this.load(a.FE.MODULES),this.$el.on(\\\"touchstart.init\\\",function(){a(this).data(\\\"touched\\\",!0)}),this.$el.on(\\\"touchmove.init\\\",function(){a(this).removeData(\\\"touched\\\")}),this.$el.on(\\\"mousedown.init touchend.init dragenter.init focus.init\\\",a.proxy(function(b){if(\\\"touchend\\\"==b.type&&!this.$el.data(\\\"touched\\\"))return!0;if(1===b.which||!b.which){this.$el.off(\\\"mousedown.init touchstart.init touchmove.init touchend.init dragenter.init focus.init\\\"),this.load(a.FE.MODULES),this.load(a.FE.PLUGINS);var c=b.originalEvent&&b.originalEvent.originalTarget;c&&\\\"IMG\\\"==c.tagName&&a(c).trigger(\\\"mousedown\\\"),\\\"undefined\\\"==typeof this.ul&&this.destroy(),\\\"touchend\\\"==b.type&&this.image&&b.originalEvent&&b.originalEvent.target&&a(b.originalEvent.target).is(\\\"img\\\")&&setTimeout(a.proxy(function(){this.image.edit(a(b.originalEvent.target))},this),100),this.ready=!0,this.events.trigger(\\\"initialized\\\")}},this))):(this.load(a.FE.MODULES),this.load(a.FE.PLUGINS),a(this.o_win).scrollTop(f),\\\"undefined\\\"==typeof this.ul&&this.destroy(),this.ready=!0,this.events.trigger(\\\"initialized\\\"))},this)),this._init()};b.DEFAULTS={initOnClick:!1,pluginsEnabled:null},b.MODULES={},b.PLUGINS={},b.VERSION=\\\"2.5.0\\\",b.INSTANCES=[],b.OPTS_MAPPING={},b.SHARED={},b.ID=0,b.prototype._init=function(){var b=this.$oel.prop(\\\"tagName\\\");this.$oel.closest(\\\"label\\\").length>=1&&console.warn(\\\"Note! It is not recommended to initialize the Froala Editor within a label tag.\\\");var c=a.proxy(function(){\\\"TEXTAREA\\\"!=b&&(this._original_html=this._original_html||this.$oel.html()),this.$box=this.$box||this.$oel,this.opts.fullPage&&(this.opts.iframe=!0),this.opts.iframe?(this.$iframe=a('<iframe src=\\\"about:blank\\\" frameBorder=\\\"0\\\">'),this.$wp=a(\\\"<div></div>\\\"),this.$box.html(this.$wp),this.$wp.append(this.$iframe),this.$iframe.get(0).contentWindow.document.open(),this.$iframe.get(0).contentWindow.document.write(\\\"<!DOCTYPE html>\\\"),this.$iframe.get(0).contentWindow.document.write(\\\"<html><head></head><body></body></html>\\\"),this.$iframe.get(0).contentWindow.document.close(),this.$el=this.$iframe.contents().find(\\\"body\\\"),this.el=this.$el.get(0),this.$head=this.$iframe.contents().find(\\\"head\\\"),this.$html=this.$iframe.contents().find(\\\"html\\\"),this.iframe_document=this.$iframe.get(0).contentWindow.document,this.$oel.trigger(\\\"froala.doInit\\\")):(this.$el=a(\\\"<div></div>\\\"),this.el=this.$el.get(0),this.$wp=a(\\\"<div></div>\\\").append(this.$el),this.$box.html(this.$wp),this.$oel.trigger(\\\"froala.doInit\\\"))},this),d=a.proxy(function(){this.$box=a(\\\"<div>\\\"),this.$oel.before(this.$box).hide(),this._original_html=this.$oel.val(),this.$oel.parents(\\\"form\\\").on(\\\"submit.\\\"+this.id,a.proxy(function(){this.events.trigger(\\\"form.submit\\\")},this)),this.$oel.parents(\\\"form\\\").on(\\\"reset.\\\"+this.id,a.proxy(function(){this.events.trigger(\\\"form.reset\\\")},this)),c()},this),e=a.proxy(function(){this.$el=this.$oel,this.el=this.$el.get(0),this.$el.attr(\\\"contenteditable\\\",!0).css(\\\"outline\\\",\\\"none\\\").css(\\\"display\\\",\\\"inline-block\\\"),this.opts.multiLine=!1,this.opts.toolbarInline=!1,this.$oel.trigger(\\\"froala.doInit\\\")},this),f=a.proxy(function(){this.$el=this.$oel,this.el=this.$el.get(0),this.opts.toolbarInline=!1,this.$oel.trigger(\\\"froala.doInit\\\")},this),g=a.proxy(function(){this.$el=this.$oel,this.el=this.$el.get(0),this.opts.toolbarInline=!1,this.$oel.on(\\\"click.popup\\\",function(a){a.preventDefault()}),this.$oel.trigger(\\\"froala.doInit\\\")},this);this.opts.editInPopup?g():\\\"TEXTAREA\\\"==b?d():\\\"A\\\"==b?e():\\\"IMG\\\"==b?f():\\\"BUTTON\\\"==b||\\\"INPUT\\\"==b?(this.opts.editInPopup=!0,this.opts.toolbarInline=!1,g()):c()},b.prototype.load=function(b){for(var c in b)if(b.hasOwnProperty(c)){if(this[c])continue;if(a.FE.PLUGINS[c]&&this.opts.pluginsEnabled.indexOf(c)<0)continue;if(this[c]=new b[c](this),this[c]._init&&(this[c]._init(),this.opts.initOnClick&&\\\"core\\\"==c))return!1}},b.prototype.destroy=function(){this.shared.count--,this.events.$off();var b=this.html.get();if(this.events.trigger(\\\"destroy\\\",[],!0),this.events.trigger(\\\"shared.destroy\\\",void 0,!0),0===this.shared.count){for(var c in this.shared)this.shared.hasOwnProperty(c)&&(null==this.shared[c],a.FE.SHARED[this.sid][c]=null);a.FE.SHARED[this.sid]={}}this.$oel.parents(\\\"form\\\").off(\\\".\\\"+this.id),this.$oel.off(\\\"click.popup\\\"),this.$oel.removeData(\\\"froala.editor\\\"),this.$oel.off(\\\"froalaEditor\\\"),this.core.destroy(b),a.FE.INSTANCES.splice(a.FE.INSTANCES.indexOf(this),1)},a.fn.froalaEditor=function(c){for(var d=[],e=0;e<arguments.length;e++)d.push(arguments[e]);if(\\\"string\\\"==typeof c){var f=[];return this.each(function(){var b=a(this),e=b.data(\\\"froala.editor\\\");if(!e)return console.warn(\\\"Editor should be initialized before calling the \\\"+c+\\\" method.\\\");var g,h;if(c.indexOf(\\\".\\\")>0&&e[c.split(\\\".\\\")[0]]?(e[c.split(\\\".\\\")[0]]&&(g=e[c.split(\\\".\\\")[0]]),h=c.split(\\\".\\\")[1]):(g=e,h=c.split(\\\".\\\")[0]),!g[h])return a.error(\\\"Method \\\"+c+\\\" does not exist in Froala Editor.\\\");var i=g[h].apply(e,d.slice(1));void 0===i?f.push(this):0===f.length&&f.push(i)}),1==f.length?f[0]:f}if(\\\"object\\\"==typeof c||!c)return this.each(function(){var d=a(this).data(\\\"froala.editor\\\");if(!d){var e=this;new b(e,c)}})},a.fn.froalaEditor.Constructor=b,a.FroalaEditor=b,a.FE=b,a.FE.XS=0,a.FE.SM=1,a.FE.MD=2,a.FE.LG=3,a.FE.MODULES.helpers=function(b){function c(){var a,b,c=-1;return\\\"Microsoft Internet Explorer\\\"==navigator.appName?(a=navigator.userAgent,b=new RegExp(\\\"MSIE ([0-9]{1,}[\\\\\\\\.0-9]{0,})\\\"),null!==b.exec(a)&&(c=parseFloat(RegExp.$1))):\\\"Netscape\\\"==navigator.appName&&(a=navigator.userAgent,b=new RegExp(\\\"Trident/.*rv:([0-9]{1,}[\\\\\\\\.0-9]{0,})\\\"),null!==b.exec(a)&&(c=parseFloat(RegExp.$1))),c}function d(){var a={},b=c();if(b>0)a.msie=!0;else{var d=navigator.userAgent.toLowerCase(),e=/(edge)[ \\\\/]([\\\\w.]+)/.exec(d)||/(chrome)[ \\\\/]([\\\\w.]+)/.exec(d)||/(webkit)[ \\\\/]([\\\\w.]+)/.exec(d)||/(opera)(?:.*version|)[ \\\\/]([\\\\w.]+)/.exec(d)||/(msie) ([\\\\w.]+)/.exec(d)||d.indexOf(\\\"compatible\\\")<0&&/(mozilla)(?:.*? rv:([\\\\w.]+)|)/.exec(d)||[],f={browser:e[1]||\\\"\\\",version:e[2]||\\\"0\\\"};e[1]&&(a[f.browser]=!0),a.chrome?a.webkit=!0:a.webkit&&(a.safari=!0)}return a.msie&&(a.version=b),a}function e(){return/(iPad|iPhone|iPod)/g.test(navigator.userAgent)&&!h()}function f(){return/(Android)/g.test(navigator.userAgent)&&!h()}function g(){return/(Blackberry)/g.test(navigator.userAgent)}function h(){return/(Windows Phone)/gi.test(navigator.userAgent)}function i(){return f()||e()||g()}function j(){return window.requestAnimationFrame||window.webkitRequestAnimationFrame||window.mozRequestAnimationFrame||function(a){window.setTimeout(a,1e3/60)}}function k(a){return parseInt(a,10)||0}function l(){var b=a('<div class=\\\"fr-visibility-helper\\\"></div>').appendTo(\\\"body\\\"),c=k(b.css(\\\"margin-left\\\"));return b.remove(),c}function m(){return\\\"ontouchstart\\\"in window||window.DocumentTouch&&document instanceof DocumentTouch}function n(a){if(!/^(https?:|ftps?:|)\\\\/\\\\//i.test(a))return!1;a=String(a).replace(/</g,\\\"%3C\\\").replace(/>/g,\\\"%3E\\\").replace(/\\\"/g,\\\"%22\\\").replace(/ /g,\\\"%20\\\");var b=/(http|ftp|https):\\\\/\\\\/[a-z\\\\u00a1-\\\\uffff0-9{}]+(\\\\.[a-z\\\\u00a1-\\\\uffff0-9{}]*)*([a-z\\\\u00a1-\\\\uffff0-9.,@?^=%&amp;:\\\\/~+#-_{}]*[a-z\\\\u00a1-\\\\uffff0-9@?^=%&amp;\\\\/~+#-_{}])?/gi;return b.test(a)}function o(a){if(/^(https?:|ftps?:|)\\\\/\\\\//i.test(a)){if(!n(a)&&!n(\\\"http:\\\"+a))return\\\"\\\"}else a=encodeURIComponent(a).replace(/%23/g,\\\"#\\\").replace(/%2F/g,\\\"/\\\").replace(/%25/g,\\\"%\\\").replace(/mailto%3A/gi,\\\"mailto:\\\").replace(/file%3A/gi,\\\"file:\\\").replace(/sms%3A/gi,\\\"sms:\\\").replace(/tel%3A/gi,\\\"tel:\\\").replace(/notes%3A/gi,\\\"notes:\\\").replace(/data%3Aimage/gi,\\\"data:image\\\").replace(/blob%3A/gi,\\\"blob:\\\").replace(/webkit-fake-url%3A/gi,\\\"webkit-fake-url:\\\").replace(/%3F/g,\\\"?\\\").replace(/%3D/g,\\\"=\\\").replace(/%26/g,\\\"&\\\").replace(/&amp;/g,\\\"&\\\").replace(/%2C/g,\\\",\\\").replace(/%3B/g,\\\";\\\").replace(/%2B/g,\\\"+\\\").replace(/%40/g,\\\"@\\\").replace(/%5B/g,\\\"[\\\").replace(/%5D/g,\\\"]\\\").replace(/%7B/g,\\\"{\\\").replace(/%7D/g,\\\"}\\\");return a}function p(a){return a&&!a.propertyIsEnumerable(\\\"length\\\")&&\\\"object\\\"==typeof a&&\\\"number\\\"==typeof a.length}function q(a){function b(a){return(\\\"0\\\"+parseInt(a,10).toString(16)).slice(-2)}try{return a&&\\\"transparent\\\"!==a?/^#[0-9A-F]{6}$/i.test(a)?a:(a=a.match(/^rgb\\\\((\\\\d+),\\\\s*(\\\\d+),\\\\s*(\\\\d+)\\\\)$/),(\\\"#\\\"+b(a[1])+b(a[2])+b(a[3])).toUpperCase()):\\\"\\\"}catch(c){return null}}function r(a){var b=/^#?([a-f\\\\d])([a-f\\\\d])([a-f\\\\d])$/i;a=a.replace(b,function(a,b,c,d){return b+b+c+c+d+d});var c=/^#?([a-f\\\\d]{2})([a-f\\\\d]{2})([a-f\\\\d]{2})$/i.exec(a);return c?\\\"rgb(\\\"+parseInt(c[1],16)+\\\", \\\"+parseInt(c[2],16)+\\\", \\\"+parseInt(c[3],16)+\\\")\\\":\\\"\\\"}function s(b){var c=(b.css(\\\"text-align\\\")||\\\"\\\").replace(/-(.*)-/g,\\\"\\\");if([\\\"left\\\",\\\"right\\\",\\\"justify\\\",\\\"center\\\"].indexOf(c)<0){if(!y){var d=a('<div dir=\\\"auto\\\" style=\\\"text-align: initial; position: fixed; left: -3000px;\\\"><span id=\\\"s1\\\">.</span><span id=\\\"s2\\\">.</span></div>');a(\\\"body\\\").append(d);var e=d.find(\\\"#s1\\\").get(0).getBoundingClientRect().left,f=d.find(\\\"#s2\\\").get(0).getBoundingClientRect().left;d.remove(),y=e<f?\\\"left\\\":\\\"right\\\"}c=y}return c}function t(){return null==z&&(z=navigator.platform.toUpperCase().indexOf(\\\"MAC\\\")>=0),z}function u(){function a(a,b){var d=a[b];a[b]=function(a){var b,f=!1,g=!1;if(a&&a.match(e)){a=a.replace(e,\\\"\\\"),this.parentNode||(c.appendChild(this),g=!0);var h=this.parentNode;return this.id||(this.id=\\\"rootedQuerySelector_id_\\\"+(new Date).getTime(),f=!0),b=d.call(h,\\\"#\\\"+this.id+\\\" \\\"+a),f&&(this.id=\\\"\\\"),g&&c.removeChild(this),b}return d.call(this,a)}}var c=b.o_doc.createElement(\\\"div\\\");try{c.querySelectorAll(\\\":scope *\\\")}catch(d){var e=/^\\\\s*:scope/gi;a(Element.prototype,\\\"querySelector\\\"),a(Element.prototype,\\\"querySelectorAll\\\")}}function v(){return b.o_win.pageYOffset?b.o_win.pageYOffset:b.o_doc.documentElement&&b.o_doc.documentElement.scrollTop?b.o_doc.documentElement.scrollTop:b.o_doc.body.scrollTop?b.o_doc.body.scrollTop:0}function w(){return b.o_win.pageXOffset?b.o_win.pageXOffset:b.o_doc.documentElement&&b.o_doc.documentElement.scrollLeft?b.o_doc.documentElement.scrollLeft:b.o_doc.body.scrollLeft?b.o_doc.body.scrollLeft:0}function x(){b.browser=d(),u()}var y,z=null;return{_init:x,isIOS:e,isMac:t,isAndroid:f,isBlackberry:g,isWindowsPhone:h,isMobile:i,requestAnimationFrame:j,getPX:k,screenSize:l,isTouch:m,sanitizeURL:o,isArray:p,RGBToHex:q,HEXtoRGB:r,isURL:n,getAlignment:s,scrollTop:v,scrollLeft:w}},a.FE.MODULES.events=function(b){function c(a,b,c){s(a,b,c)}function d(){c(b.$el,\\\"cut copy paste beforepaste\\\",function(a){v(a.type,[a])})}function e(){c(b.$el,\\\"click mouseup mousedown touchstart touchend dragenter dragover dragleave dragend drop dragstart\\\",function(a){v(a.type,[a])}),r(\\\"mousedown\\\",function(){for(var c=0;c<a.FE.INSTANCES.length;c++)a.FE.INSTANCES[c]!=b&&a.FE.INSTANCES[c].popups&&a.FE.INSTANCES[c].popups.areVisible()&&a.FE.INSTANCES[c].$el.find(\\\".fr-marker\\\").remove()})}function f(){c(b.$el,\\\"keydown keypress keyup input\\\",function(a){v(a.type,[a])})}function g(){c(b.$win,b._mousedown,function(a){v(\\\"window.mousedown\\\",[a]),n()}),c(b.$win,b._mouseup,function(a){v(\\\"window.mouseup\\\",[a])}),c(b.$win,\\\"cut copy keydown keyup touchmove touchend\\\",function(a){v(\\\"window.\\\"+a.type,[a])})}function h(){c(b.$doc,\\\"dragend drop\\\",function(a){v(\\\"document.\\\"+a.type,[a])})}function i(c){if(\\\"undefined\\\"==typeof c&&(c=!0),!b.$wp)return!1;if(b.helpers.isIOS()&&b.$win.get(0).focus(),!b.core.hasFocus()&&c){var d=b.$win.scrollTop();return b.browser.msie&&b.$box&&b.$box.css(\\\"position\\\",\\\"fixed\\\"),b.$el.focus(),b.browser.msie&&b.$box&&b.$box.css(\\\"position\\\",\\\"\\\"),d!=b.$win.scrollTop()&&b.$win.scrollTop(d),!1}if(!b.core.hasFocus()||b.$el.find(\\\".fr-marker\\\").length>0)return!1;var e=b.selection.info(b.el);if(e.atStart&&b.selection.isCollapsed()&&null!=b.html.defaultTag()){var f=b.markers.insert();if(f&&!b.node.blockParent(f)){a(f).remove();var g=b.$el.find(b.html.blockTagsQuery()).get(0);g&&(a(g).prepend(a.FE.MARKERS),b.selection.restore())}else f&&a(f).remove()}}function j(){c(b.$el,\\\"focus\\\",function(a){p()&&(i(!1),C===!1&&v(a.type,[a]))}),c(b.$el,\\\"blur\\\",function(a){p()&&C===!0&&(v(a.type,[a]),n())}),r(\\\"focus\\\",function(){C=!0}),r(\\\"blur\\\",function(){C=!1})}function k(){b.helpers.isMobile()?(b._mousedown=\\\"touchstart\\\",b._mouseup=\\\"touchend\\\",b._move=\\\"touchmove\\\",b._mousemove=\\\"touchmove\\\"):(b._mousedown=\\\"mousedown\\\",b._mouseup=\\\"mouseup\\\",b._move=\\\"\\\",b._mousemove=\\\"mousemove\\\")}function l(c){var d=a(c.currentTarget);return b.edit.isDisabled()||b.node.hasClass(d.get(0),\\\"fr-disabled\\\")?(c.preventDefault(),!1):\\\"mousedown\\\"===c.type&&1!==c.which||(b.helpers.isMobile()||c.preventDefault(),(b.helpers.isAndroid()||b.helpers.isWindowsPhone())&&0===d.parents(\\\".fr-dropdown-menu\\\").length&&(c.preventDefault(),c.stopPropagation()),d.addClass(\\\"fr-selected\\\"),void b.events.trigger(\\\"commands.mousedown\\\",[d]))}function m(c,d){var e=a(c.currentTarget);if(b.edit.isDisabled()||b.node.hasClass(e.get(0),\\\"fr-disabled\\\"))return c.preventDefault(),!1;if(\\\"mouseup\\\"===c.type&&1!==c.which)return!0;if(!b.node.hasClass(e.get(0),\\\"fr-selected\\\"))return!0;if(\\\"touchmove\\\"!=c.type){if(c.stopPropagation(),c.stopImmediatePropagation(),c.preventDefault(),!b.node.hasClass(e.get(0),\\\"fr-selected\\\"))return b.button.getButtons(\\\".fr-selected\\\",!0).removeClass(\\\"fr-selected\\\"),!1;if(b.button.getButtons(\\\".fr-selected\\\",!0).removeClass(\\\"fr-selected\\\"),e.data(\\\"dragging\\\")||e.attr(\\\"disabled\\\"))return e.removeData(\\\"dragging\\\"),!1;var f=e.data(\\\"timeout\\\");f&&(clearTimeout(f),e.removeData(\\\"timeout\\\")),d.apply(b,[c])}else e.data(\\\"timeout\\\")||e.data(\\\"timeout\\\",setTimeout(function(){e.data(\\\"dragging\\\",!0)},100))}function n(){A=!0}function o(){A=!1}function p(){return A}function q(a,c,d){s(a,b._mousedown,c,function(a){b.edit.isDisabled()||l(a)},!0),s(a,b._mouseup+\\\" \\\"+b._move,c,function(a){b.edit.isDisabled()||m(a,d)},!0),s(a,\\\"mousedown click mouseup\\\",c,function(a){b.edit.isDisabled()||a.stopPropagation()},!0),r(\\\"window.mouseup\\\",function(){b.edit.isDisabled()||(a.find(c).removeClass(\\\"fr-selected\\\"),n())})}function r(a,c,d){var e=a.split(\\\" \\\");if(e.length>1){for(var f=0;f<e.length;f++)r(e[f],c,d);return!0}\\\"undefined\\\"==typeof d&&(d=!1);var g;g=0!==a.indexOf(\\\"shared.\\\")?B[a]=B[a]||[]:b.shared._events[a]=b.shared._events[a]||[],d?g.unshift(c):g.push(c)}function s(a,c,d,e,f){\\\"function\\\"==typeof d&&(f=e,e=d,d=!1);var g=f?b.shared.$_events:D,h=f?b.sid:b.id;d?a.on(c.split(\\\" \\\").join(\\\".ed\\\"+h+\\\" \\\")+\\\".ed\\\"+h,d,e):a.on(c.split(\\\" \\\").join(\\\".ed\\\"+h+\\\" \\\")+\\\".ed\\\"+h,e),g.indexOf(a.get(0))<0&&g.push(a.get(0))}function t(b,c){for(var d=0;d<b.length;d++)a(b[d]).off(\\\".ed\\\"+c)}function u(){t(D,b.id),D=[],0===b.shared.count&&(t(b.shared.$_events,b.sid),b.shared.$_events=null)}function v(c,d,e){if(!b.edit.isDisabled()||e){var f;if(0!==c.indexOf(\\\"shared.\\\"))f=B[c];else{if(b.shared.count>0)return!1;f=b.shared._events[c]}var g;if(f)for(var h=0;h<f.length;h++)if(g=f[h].apply(b,d),g===!1)return!1;return g=b.$oel.triggerHandler(\\\"froalaEditor.\\\"+c,a.merge([b],d||[])),g!==!1&&g}}function w(c,d,e){if(!b.edit.isDisabled()||e){var f;if(0!==c.indexOf(\\\"shared.\\\"))f=B[c];else{if(b.shared.count>0)return!1;f=b.shared._events[c]}var g;if(f)for(var h=0;h<f.length;h++)g=f[h].apply(b,[d]),\\\"undefined\\\"!=typeof g&&(d=g);return g=b.$oel.triggerHandler(\\\"froalaEditor.\\\"+c,a.merge([b],[d])),\\\"undefined\\\"!=typeof g&&(d=g),d}}function x(){for(var a in B)B.hasOwnProperty(a)&&delete B[a]}function y(){for(var a in b.shared._events)b.shared._events.hasOwnProperty(a)&&delete b.shared._events[a]}function z(){b.shared.$_events=b.shared.$_events||[],b.shared._events={},k(),e(),g(),h(),f(),j(),n(),d(),r(\\\"destroy\\\",x),r(\\\"shared.destroy\\\",y)}var A,B={},C=!1,D=[];return{_init:z,on:r,trigger:v,bindClick:q,disableBlur:o,enableBlur:n,blurActive:p,focus:i,chainTrigger:w,$on:s,$off:u}},a.FE.MODULES.node=function(b){function c(a){return a&&\\\"IFRAME\\\"!=a.tagName?Array.prototype.slice.call(a.childNodes||[]):[]}function d(b){return!!b&&(b.nodeType==Node.ELEMENT_NODE&&a.FE.BLOCK_TAGS.indexOf(b.tagName.toLowerCase())>=0)}function e(e,f){if(!e)return!0;if(e.querySelector(\\\"table\\\"))return!1;var g=c(e);1==g.length&&d(g[0])&&(g=c(g[0]));for(var h=!1,i=0;i<g.length;i++){var j=g[i];if(!(f&&b.node.hasClass(j,\\\"fr-marker\\\")||j.nodeType==Node.TEXT_NODE&&0===j.textContent.length)){if(\\\"BR\\\"!=j.tagName&&(j.textContent||\\\"\\\").replace(/\\\\u200B/gi,\\\"\\\").replace(/\\\\n/g,\\\"\\\").length>0)return!1;if(h)return!1;\\\"BR\\\"==j.tagName&&(h=!0)}}return!(e.querySelectorAll(a.FE.VOID_ELEMENTS.join(\\\",\\\")).length-e.querySelectorAll(\\\"br\\\").length)&&(!e.querySelector(b.opts.htmlAllowedEmptyTags.join(\\\":not(.fr-marker),\\\")+\\\":not(.fr-marker)\\\")&&(!(e.querySelectorAll(a.FE.BLOCK_TAGS.join(\\\",\\\")).length>1)&&!e.querySelector(b.opts.htmlDoNotWrapTags.join(\\\":not(.fr-marker),\\\")+\\\":not(.fr-marker)\\\")))}function f(a){for(;a&&a.parentNode!==b.el&&(!a.parentNode||!b.node.hasClass(a.parentNode,\\\"fr-inner\\\"));)if(a=a.parentNode,d(a))return a;return null}function g(c,e,f){if(\\\"undefined\\\"==typeof e&&(e=[]),\\\"undefined\\\"==typeof f&&(f=!0),e.push(b.el),e.indexOf(c.parentNode)>=0||c.parentNode&&b.node.hasClass(c.parentNode,\\\"fr-inner\\\")||c.parentNode&&a.FE.SIMPLE_ENTER_TAGS.indexOf(c.parentNode.tagName)>=0&&f)return null;for(;e.indexOf(c.parentNode)<0&&c.parentNode&&!b.node.hasClass(c.parentNode,\\\"fr-inner\\\")&&(a.FE.SIMPLE_ENTER_TAGS.indexOf(c.parentNode.tagName)<0||!f)&&(!d(c)||!d(c.parentNode)||!f);)c=c.parentNode;return c}function h(a){var b={},c=a.attributes;if(c)for(var d=0;d<c.length;d++){var e=c[d];b[e.nodeName]=e.value}return b}function i(a){for(var b=\\\"\\\",c=h(a),d=Object.keys(c).sort(),e=0;e<d.length;e++){var f=d[e],g=c[f];g.indexOf(\\\"'\\\")<0&&g.indexOf('\\\"')>=0?b+=\\\" \\\"+f+\\\"='\\\"+g+\\\"'\\\":g.indexOf('\\\"')>=0&&g.indexOf(\\\"'\\\")>=0?(g=g.replace(/\\\"/g,\\\"&quot;\\\"),b+=\\\" \\\"+f+'=\\\"'+g+'\\\"'):b+=\\\" \\\"+f+'=\\\"'+g+'\\\"'}return b}function j(a){for(var b=a.attributes,c=b.length-1;c>=0;c--){var d=b[c];a.removeAttribute(d.nodeName)}}function k(a){return\\\"<\\\"+a.tagName.toLowerCase()+i(a)+\\\">\\\"}function l(a){return\\\"</\\\"+a.tagName.toLowerCase()+\\\">\\\"}function m(a,c){\\\"undefined\\\"==typeof c&&(c=!0);for(var d=a.previousSibling;d&&c&&b.node.hasClass(d,\\\"fr-marker\\\");)d=d.previousSibling;return!d||d.nodeType==Node.TEXT_NODE&&\\\"\\\"===d.textContent&&m(d)}function n(a,c){\\\"undefined\\\"==typeof c&&(c=!0);for(var d=a.nextSibling;d&&c&&b.node.hasClass(d,\\\"fr-marker\\\");)d=d.nextSibling;return!d||d.nodeType==Node.TEXT_NODE&&\\\"\\\"===d.textContent&&n(d)}function o(b){return b&&b.nodeType==Node.ELEMENT_NODE&&a.FE.VOID_ELEMENTS.indexOf((b.tagName||\\\"\\\").toLowerCase())>=0}function p(a){return!!a&&[\\\"UL\\\",\\\"OL\\\"].indexOf(a.tagName)>=0}function q(a){return a===b.el}function r(a){return a&&a.nodeType==Node.ELEMENT_NODE&&a.getAttribute(\\\"class\\\")&&(a.getAttribute(\\\"class\\\")||\\\"\\\").indexOf(\\\"fr-deletable\\\")>=0}function s(a){return a===b.doc.activeElement&&(!b.doc.hasFocus||b.doc.hasFocus())&&!!(q(a)||a.type||a.href||~a.tabIndex)}function t(a){return(!a.getAttribute||\\\"false\\\"!=a.getAttribute(\\\"contenteditable\\\"))&&[\\\"STYLE\\\",\\\"SCRIPT\\\"].indexOf(a.tagName)<0}function u(b,c){return b instanceof a&&(b=b.get(0)),b&&b.classList&&b.classList.contains(c)}function v(a){return b.browser.msie?a:{acceptNode:a}}return{isBlock:d,isEmpty:e,blockParent:f,deepestParent:g,rawAttributes:h,attributes:i,clearAttributes:j,openTagString:k,closeTagString:l,isFirstSibling:m,isLastSibling:n,isList:p,isElement:q,contents:c,isVoid:o,hasFocus:s,isEditable:t,isDeletable:r,hasClass:u,filter:v}},a.FE.INVISIBLE_SPACE=\\\"&#8203;\\\",a.FE.START_MARKER='<span class=\\\"fr-marker\\\" data-id=\\\"0\\\" data-type=\\\"true\\\" style=\\\"display: none; line-height: 0;\\\">'+a.FE.INVISIBLE_SPACE+\\\"</span>\\\",a.FE.END_MARKER='<span class=\\\"fr-marker\\\" data-id=\\\"0\\\" data-type=\\\"false\\\" style=\\\"display: none; line-height: 0;\\\">'+a.FE.INVISIBLE_SPACE+\\\"</span>\\\",a.FE.MARKERS=a.FE.START_MARKER+a.FE.END_MARKER,a.FE.MODULES.markers=function(b){function c(c,d){return a('<span class=\\\"fr-marker\\\" data-id=\\\"'+d+'\\\" data-type=\\\"'+c+'\\\" style=\\\"display: '+(b.browser.safari?\\\"none\\\":\\\"inline-block\\\")+'; line-height: 0;\\\">'+a.FE.INVISIBLE_SPACE+\\\"</span>\\\",b.doc)[0]}function d(d,e,f){var g,h,i;try{var j=d.cloneRange();if(j.collapse(e),j.insertNode(c(e,f)),e===!0&&d.collapsed)for(g=b.$el.find('span.fr-marker[data-type=\\\"true\\\"][data-id=\\\"'+f+'\\\"]'),i=g.get(0).nextSibling;i&&i.nodeType===Node.TEXT_NODE&&0===i.textContent.length;)a(i).remove(),i=g.nextSibling;if(e===!0&&!d.collapsed&&(g=b.$el.find('span.fr-marker[data-type=\\\"true\\\"][data-id=\\\"'+f+'\\\"]').get(0),i=g.nextSibling,i&&i.nodeType===Node.ELEMENT_NODE&&b.node.isBlock(i))){h=[i];do i=h[0],h=b.node.contents(i);while(h[0]&&b.node.isBlock(h[0]));a(i).prepend(a(g))}if(e===!1&&!d.collapsed){if(g=b.$el.find('span.fr-marker[data-type=\\\"false\\\"][data-id=\\\"'+f+'\\\"]').get(0),i=g.previousSibling,i&&i.nodeType===Node.ELEMENT_NODE&&b.node.isBlock(i)){h=[i];do i=h[h.length-1],h=b.node.contents(i);while(h[h.length-1]&&b.node.isBlock(h[h.length-1]));a(i).append(a(g))}g.parentNode&&[\\\"TD\\\",\\\"TH\\\"].indexOf(g.parentNode.tagName)>=0&&g.parentNode.previousSibling&&!g.previousSibling&&a(g.parentNode.previousSibling).append(g)}var k=b.$el.find('span.fr-marker[data-type=\\\"'+e+'\\\"][data-id=\\\"'+f+'\\\"]').get(0);return k&&(k.style.display=\\\"none\\\"),k}catch(l){return null}}function e(){if(!b.$wp)return null;try{var c=b.selection.ranges(0),d=c.commonAncestorContainer;if(d!=b.el&&0===b.$el.find(d).length)return null;var e=c.cloneRange(),f=c.cloneRange();e.collapse(!0);var g=a('<span class=\\\"fr-marker\\\" style=\\\"display: none; line-height: 0;\\\">'+a.FE.INVISIBLE_SPACE+\\\"</span>\\\",b.doc)[0];if(e.insertNode(g),g=b.$el.find(\\\"span.fr-marker\\\").get(0)){for(var h=g.nextSibling;h&&h.nodeType===Node.TEXT_NODE&&0===h.textContent.length;)a(h).remove(),h=b.$el.find(\\\"span.fr-marker\\\").get(0).nextSibling;return b.selection.clear(),b.selection.get().addRange(f),g}return null}catch(i){console.warn(\\\"MARKER\\\",i)}}function f(){b.selection.isCollapsed()||b.selection.remove();var c=b.$el.find(\\\".fr-marker\\\").get(0);if(null==c&&(c=e()),null==c)return null;var d=b.node.deepestParent(c);if(d||(d=b.node.blockParent(c),d&&\\\"LI\\\"!=d.tagName&&(d=null)),d)if(b.node.isBlock(d)&&b.node.isEmpty(d))\\\"LI\\\"==d.tagName&&d.parentNode.firstElementChild==d?a(d).append('<span class=\\\"fr-marker\\\"></span>'):a(d).replaceWith('<span class=\\\"fr-marker\\\"></span>');else if(b.cursor.isAtStart(c,d))a(d).before('<span class=\\\"fr-marker\\\"></span>'),a(c).remove();else if(b.cursor.isAtEnd(c,d))a(d).after('<span class=\\\"fr-marker\\\"></span>'),a(c).remove();else{var f=c,g=\\\"\\\",h=\\\"\\\";do f=f.parentNode,g+=b.node.closeTagString(f),h=b.node.openTagString(f)+h;while(f!=d);a(c).replaceWith('<span id=\\\"fr-break\\\"></span>');var i=b.node.openTagString(d)+a(d).html()+b.node.closeTagString(d);i=i.replace(/<span id=\\\"fr-break\\\"><\\\\/span>/g,g+'<span class=\\\"fr-marker\\\"></span>'+h),a(d).replaceWith(i)}return b.$el.find(\\\".fr-marker\\\").get(0)}function g(a){var c=a.clientX,d=a.clientY;h();var f,g=null;if(\\\"undefined\\\"!=typeof b.doc.caretPositionFromPoint?(f=b.doc.caretPositionFromPoint(c,d),g=b.doc.createRange(),g.setStart(f.offsetNode,f.offset),g.setEnd(f.offsetNode,f.offset)):\\\"undefined\\\"!=typeof b.doc.caretRangeFromPoint&&(f=b.doc.caretRangeFromPoint(c,d),g=b.doc.createRange(),g.setStart(f.startContainer,f.startOffset),g.setEnd(f.startContainer,f.startOffset)),null!==g&&\\\"undefined\\\"!=typeof b.win.getSelection){var i=b.win.getSelection();i.removeAllRanges(),i.addRange(g)}else if(\\\"undefined\\\"!=typeof b.doc.body.createTextRange)try{g=b.doc.body.createTextRange(),g.moveToPoint(c,d);var j=g.duplicate();j.moveToPoint(c,d),g.setEndPoint(\\\"EndToEnd\\\",j),g.select()}catch(k){return!1}e()}function h(){b.$el.find(\\\".fr-marker\\\").remove()}return{place:d,insert:e,split:f,insertAtPoint:g,remove:h}},a.FE.MODULES.selection=function(b){function c(){var a=\\\"\\\";return b.win.getSelection?a=b.win.getSelection():b.doc.getSelection?a=b.doc.getSelection():b.doc.selection&&(a=b.doc.selection.createRange().text),a.toString()}function d(){var a=\\\"\\\";return a=b.win.getSelection?b.win.getSelection():b.doc.getSelection?b.doc.getSelection():b.doc.selection.createRange()}function e(a){var c=d(),e=[];if(c&&c.getRangeAt&&c.rangeCount){e=[];for(var f=0;f<c.rangeCount;f++)e.push(c.getRangeAt(f))}else e=b.doc.createRange?[b.doc.createRange()]:[];return\\\"undefined\\\"!=typeof a?e[a]:e}function f(){var a=d();try{a.removeAllRanges?a.removeAllRanges():a.empty?a.empty():a.clear&&a.clear()}catch(b){}}function g(){var f=d();try{if(f.rangeCount){var g,h=e(0),i=h.startContainer;if(i.nodeType==Node.TEXT_NODE&&h.startOffset==(i.textContent||\\\"\\\").length&&i.nextSibling&&(i=i.nextSibling),i.nodeType==Node.ELEMENT_NODE){var j=!1;if(i.childNodes.length>0&&i.childNodes[h.startOffset]){for(g=i.childNodes[h.startOffset];g&&g.nodeType==Node.TEXT_NODE&&0===g.textContent.length;)g=g.nextSibling;if(g&&g.textContent.replace(/\\\\u200B/g,\\\"\\\")===c().replace(/\\\\u200B/g,\\\"\\\")&&(i=g,j=!0),!j&&i.childNodes.length>1&&h.startOffset>0&&i.childNodes[h.startOffset-1]){for(g=i.childNodes[h.startOffset-1];g&&g.nodeType==Node.TEXT_NODE&&0===g.textContent.length;)g=g.nextSibling;g&&g.textContent.replace(/\\\\u200B/g,\\\"\\\")===c().replace(/\\\\u200B/g,\\\"\\\")&&(i=g,j=!0)}}else!h.collapsed&&i.nextSibling&&i.nextSibling.nodeType==Node.ELEMENT_NODE&&(g=i.nextSibling,g&&g.textContent.replace(/\\\\u200B/g,\\\"\\\")===c().replace(/\\\\u200B/g,\\\"\\\")&&(i=g,j=!0));!j&&i.childNodes.length>0&&a(i.childNodes[0]).text().replace(/\\\\u200B/g,\\\"\\\")===c().replace(/\\\\u200B/g,\\\"\\\")&&[\\\"BR\\\",\\\"IMG\\\",\\\"HR\\\"].indexOf(i.childNodes[0].tagName)<0&&(i=i.childNodes[0])}for(;i.nodeType!=Node.ELEMENT_NODE&&i.parentNode;)i=i.parentNode;for(var k=i;k&&\\\"HTML\\\"!=k.tagName;){if(k==b.el)return i;k=a(k).parent()[0]}}}catch(l){}return b.el}function h(){var f=d();try{if(f.rangeCount){var g,h=e(0),i=h.endContainer;if(i.nodeType==Node.ELEMENT_NODE){var j=!1;i.childNodes.length>0&&i.childNodes[h.endOffset]&&a(i.childNodes[h.endOffset]).text()===c()?(i=i.childNodes[h.endOffset],j=!0):!h.collapsed&&i.previousSibling&&i.previousSibling.nodeType==Node.ELEMENT_NODE?(g=i.previousSibling,g&&g.textContent.replace(/\\\\u200B/g,\\\"\\\")===c().replace(/\\\\u200B/g,\\\"\\\")&&(i=g,j=!0)):!h.collapsed&&i.childNodes.length>0&&i.childNodes[h.endOffset]&&(g=i.childNodes[h.endOffset].previousSibling,g.nodeType==Node.ELEMENT_NODE&&g&&g.textContent.replace(/\\\\u200B/g,\\\"\\\")===c().replace(/\\\\u200B/g,\\\"\\\")&&(i=g,j=!0)),!j&&i.childNodes.length>0&&a(i.childNodes[i.childNodes.length-1]).text()===c()&&[\\\"BR\\\",\\\"IMG\\\",\\\"HR\\\"].indexOf(i.childNodes[i.childNodes.length-1].tagName)<0&&(i=i.childNodes[i.childNodes.length-1])}for(i.nodeType==Node.TEXT_NODE&&0===h.endOffset&&i.previousSibling&&i.previousSibling.nodeType==Node.ELEMENT_NODE&&(i=i.previousSibling);i.nodeType!=Node.ELEMENT_NODE&&i.parentNode;)i=i.parentNode;for(var k=i;k&&\\\"HTML\\\"!=k.tagName;){if(k==b.el)return i;k=a(k).parent()[0]}}}catch(l){}return b.el}function i(a,b){var c=a;return c.nodeType==Node.ELEMENT_NODE&&c.childNodes.length>0&&c.childNodes[b]&&(c=c.childNodes[b]),c.nodeType==Node.TEXT_NODE&&(c=c.parentNode),c}function j(){var c,f=[],g=d();if(u()&&g.rangeCount){var h=e();for(c=0;c<h.length;c++){var j,k=h[c],l=i(k.startContainer,k.startOffset),m=i(k.endContainer,k.endOffset);b.node.isBlock(l)&&f.indexOf(l)<0&&f.push(l),j=b.node.blockParent(l),j&&f.indexOf(j)<0&&f.push(j);for(var n=[],o=l;o!==m&&o!==b.el;)n.indexOf(o)<0&&o.children&&o.children.length?(n.push(o),o=o.children[0]):o.nextSibling?o=o.nextSibling:o.parentNode&&(o=o.parentNode,n.push(o)),b.node.isBlock(o)&&n.indexOf(o)<0&&f.indexOf(o)<0&&(o!==m||k.endOffset>0)&&f.push(o);b.node.isBlock(m)&&f.indexOf(m)<0&&k.endOffset>0&&f.push(m),j=b.node.blockParent(m),j&&f.indexOf(j)<0&&f.push(j)}}for(c=f.length-1;c>0;c--)a(f[c]).find(f).length&&(\\\"LI\\\"!=f[c].tagName||1==f[c].children.length&&f.indexOf(f[c].children[0])>=0)&&f.splice(c,1);return f}function k(){if(b.$wp){b.markers.remove();var a,c,d=e(),f=[];for(c=0;c<d.length;c++)if(d[c].startContainer!==b.doc){a=d[c];var g=a.collapsed,h=b.markers.place(a,!0,c),i=b.markers.place(a,!1,c);b.el.normalize(),b.browser.safari&&!g&&(a=b.doc.createRange(),a.setStartAfter(h),a.setEndBefore(i),f.push(a))}if(b.browser.safari&&f.length)for(b.selection.clear(),c=0;c<f.length;c++)b.selection.get().addRange(f[c])}}function l(){var c,e=b.el.querySelectorAll('.fr-marker[data-type=\\\"true\\\"]');if(!b.$wp)return b.markers.remove(),!1;if(0===e.length)return!1;if(b.browser.msie||b.browser.edge)for(c=0;c<e.length;c++)e[c].style.display=\\\"inline-block\\\";b.core.hasFocus()||b.browser.msie||b.browser.webkit||b.$el.focus(),f();var g=d();for(c=0;c<e.length;c++){var h=a(e[c]).data(\\\"id\\\"),i=e[c],j=b.doc.createRange(),k=b.$el.find('.fr-marker[data-type=\\\"false\\\"][data-id=\\\"'+h+'\\\"]');(b.browser.msie||b.browser.edge)&&k.css(\\\"display\\\",\\\"inline-block\\\");var l=null;if(k.length>0){k=k[0];try{for(var n,o=!1,p=i.nextSibling;p&&p.nodeType==Node.TEXT_NODE&&0===p.textContent.length;)n=p,p=p.nextSibling,a(n).remove();for(var q=k.nextSibling;q&&q.nodeType==Node.TEXT_NODE&&0===q.textContent.length;)n=q,q=q.nextSibling,a(n).remove();if(i.nextSibling==k||k.nextSibling==i){for(var r=i.nextSibling==k?i:k,s=r==i?k:i,t=r.previousSibling;t&&t.nodeType==Node.TEXT_NODE&&0===t.length;)n=t,t=t.previousSibling,a(n).remove();if(t&&t.nodeType==Node.TEXT_NODE)for(;t&&t.previousSibling&&t.previousSibling.nodeType==Node.TEXT_NODE;)t.previousSibling.textContent=t.previousSibling.textContent+t.textContent,t=t.previousSibling,a(t.nextSibling).remove();for(var u=s.nextSibling;u&&u.nodeType==Node.TEXT_NODE&&0===u.length;)n=u,u=u.nextSibling,a(n).remove();if(u&&u.nodeType==Node.TEXT_NODE)for(;u&&u.nextSibling&&u.nextSibling.nodeType==Node.TEXT_NODE;)u.nextSibling.textContent=u.textContent+u.nextSibling.textContent,u=u.nextSibling,a(u.previousSibling).remove();if(t&&(b.node.isVoid(t)||b.node.isBlock(t))&&(t=null),u&&(b.node.isVoid(u)||b.node.isBlock(u))&&(u=null),t&&u&&t.nodeType==Node.TEXT_NODE&&u.nodeType==Node.TEXT_NODE){a(i).remove(),a(k).remove();var v=t.textContent.length;t.textContent=t.textContent+u.textContent,a(u).remove(),b.spaces.normalize(t),j.setStart(t,v),j.setEnd(t,v),o=!0}else!t&&u&&u.nodeType==Node.TEXT_NODE?(a(i).remove(),a(k).remove(),b.spaces.normalize(u),l=a(b.doc.createTextNode(\\\"\\\\u200b\\\")),a(u).before(l),j.setStart(u,0),j.setEnd(u,0),o=!0):!u&&t&&t.nodeType==Node.TEXT_NODE&&(a(i).remove(),a(k).remove(),b.spaces.normalize(t),l=a(b.doc.createTextNode(\\\"\\\\u200b\\\")),a(t).after(l),j.setStart(t,t.textContent.length),j.setEnd(t,t.textContent.length),o=!0)}if(!o){var w,x;(b.browser.chrome||b.browser.edge)&&i.nextSibling==k?(w=m(k,j,!0)||j.setStartAfter(k),x=m(i,j,!1)||j.setEndBefore(i)):(i.previousSibling==k&&(i=k,k=i.nextSibling),k.nextSibling&&\\\"BR\\\"===k.nextSibling.tagName||!k.nextSibling&&b.node.isBlock(i.previousSibling)||i.previousSibling&&\\\"BR\\\"==i.previousSibling.tagName||(i.style.display=\\\"inline\\\",k.style.display=\\\"inline\\\",l=a(b.doc.createTextNode(\\\"\\\\u200b\\\"))),w=m(i,j,!0)||a(i).before(l)&&j.setStartBefore(i),x=m(k,j,!1)||a(k).after(l)&&j.setEndAfter(k)),\\\"function\\\"==typeof w&&w(),\\\"function\\\"==typeof x&&x()}}catch(y){console.warn(\\\"RESTORE RANGE\\\",y)}}l&&l.remove();try{g.addRange(j)}catch(y){console.warn(\\\"ADD RANGE\\\",y)}}b.markers.remove()}function m(c,d,e){var f,g=c.previousSibling,h=c.nextSibling;return g&&h&&g.nodeType==Node.TEXT_NODE&&h.nodeType==Node.TEXT_NODE?(f=g.textContent.length,e?(h.textContent=g.textContent+h.textContent,a(g).remove(),a(c).remove(),b.spaces.normalize(h),function(){d.setStart(h,f)}):(g.textContent=g.textContent+h.textContent,a(h).remove(),a(c).remove(),b.spaces.normalize(g),function(){d.setEnd(g,f);\\n})):g&&!h&&g.nodeType==Node.TEXT_NODE?(f=g.textContent.length,e?(b.spaces.normalize(g),function(){d.setStart(g,f)}):(b.spaces.normalize(g),function(){d.setEnd(g,f)})):!(!h||g||h.nodeType!=Node.TEXT_NODE)&&(e?(b.spaces.normalize(h),function(){d.setStart(h,0)}):(b.spaces.normalize(h),function(){d.setEnd(h,0)}))}function n(){return!0}function o(){for(var a=e(),b=0;b<a.length;b++)if(!a[b].collapsed)return!1;return!0}function p(a){var c,d,e=!1,f=!1;if(b.win.getSelection){var g=b.win.getSelection();g.rangeCount&&(c=g.getRangeAt(0),d=c.cloneRange(),d.selectNodeContents(a),d.setEnd(c.startContainer,c.startOffset),e=\\\"\\\"===d.toString(),d.selectNodeContents(a),d.setStart(c.endContainer,c.endOffset),f=\\\"\\\"===d.toString())}else b.doc.selection&&\\\"Control\\\"!=b.doc.selection.type&&(c=b.doc.selection.createRange(),d=c.duplicate(),d.moveToElementText(a),d.setEndPoint(\\\"EndToStart\\\",c),e=\\\"\\\"===d.text,d.moveToElementText(a),d.setEndPoint(\\\"StartToEnd\\\",c),f=\\\"\\\"===d.text);return{atStart:e,atEnd:f}}function q(){if(o())return!1;b.$el.find(\\\"td, th, img, br:not(:last)\\\").prepend('<span class=\\\"fr-mk\\\">'+a.FE.INVISIBLE_SPACE+\\\"</span>\\\");var c=!1,d=p(b.el);return d.atStart&&d.atEnd&&(c=!0),b.$el.find(\\\".fr-mk\\\").remove(),c}function r(c,d){\\\"undefined\\\"==typeof d&&(d=!0);var e=a(c).html();e&&e.replace(/\\\\u200b/g,\\\"\\\").length!=e.length&&a(c).html(e.replace(/\\\\u200b/g,\\\"\\\"));for(var f=b.node.contents(c),g=0;g<f.length;g++)f[g].nodeType!=Node.ELEMENT_NODE?a(f[g]).remove():(r(f[g],0===g),0===g&&(d=!1));c.nodeType==Node.TEXT_NODE?a(c).replaceWith('<span data-first=\\\"true\\\" data-text=\\\"true\\\"></span>'):d&&a(c).attr(\\\"data-first\\\",!0)}function s(){return 0===a(this).find(\\\"fr-inner\\\").length}function t(c,d){var e=b.node.contents(c.get(0));[\\\"TD\\\",\\\"TH\\\"].indexOf(c.get(0).tagName)>=0&&1==c.find(\\\".fr-marker\\\").length&&b.node.hasClass(e[0],\\\"fr-marker\\\")&&c.attr(\\\"data-del-cell\\\",!0);for(var f=0;f<e.length;f++){var g=e[f];b.node.hasClass(g,\\\"fr-marker\\\")?d=(d+1)%2:d?a(g).find(\\\".fr-marker\\\").length>0?d=t(a(g),d):[\\\"TD\\\",\\\"TH\\\"].indexOf(g.tagName)<0&&!b.node.hasClass(g,\\\"fr-inner\\\")?!b.opts.keepFormatOnDelete||b.$el.find(\\\"[data-first]\\\").length>0?a(g).remove():r(g):b.node.hasClass(g,\\\"fr-inner\\\")?0===a(g).find(\\\".fr-inner\\\").length?a(g).html(\\\"<br>\\\"):a(g).find(\\\".fr-inner\\\").filter(s).html(\\\"<br>\\\"):(a(g).empty(),a(g).attr(\\\"data-del-cell\\\",!0)):a(g).find(\\\".fr-marker\\\").length>0&&(d=t(a(g),d))}return d}function u(){try{if(!b.$wp)return!1;for(var a=e(0),c=a.commonAncestorContainer;c&&!b.node.isElement(c);)c=c.parentNode;return!!b.node.isElement(c)}catch(d){return!1}}function v(){if(o())return!0;var c;k();var d=function(b){for(var c=b.previousSibling;c&&c.nodeType==Node.TEXT_NODE&&0===c.textContent.length;){var d=c;c=c.previousSibling,a(d).remove()}return c},e=function(b){for(var c=b.nextSibling;c&&c.nodeType==Node.TEXT_NODE&&0===c.textContent.length;){var d=c;c=c.nextSibling,a(d).remove()}return c},f=b.$el.find('.fr-marker[data-type=\\\"true\\\"]');for(c=0;c<f.length;c++)for(var g=f[c];!d(g)&&!b.node.isBlock(g.parentNode)&&!b.$el.is(g.parentNode);)a(g.parentNode).before(g);var h=b.$el.find('.fr-marker[data-type=\\\"false\\\"]');for(c=0;c<h.length;c++){for(var i=h[c];!e(i)&&!b.node.isBlock(i.parentNode)&&!b.$el.is(i.parentNode);)a(i.parentNode).after(i);i.parentNode&&b.node.isBlock(i.parentNode)&&b.node.isEmpty(i.parentNode)&&!b.$el.is(i.parentNode)&&b.opts.keepFormatOnDelete&&a(i.parentNode).after(i)}if(n()){t(b.$el,0);var j=b.$el.find('[data-first=\\\"true\\\"]');if(j.length)b.$el.find(\\\".fr-marker\\\").remove(),j.append(a.FE.INVISIBLE_SPACE+a.FE.MARKERS).removeAttr(\\\"data-first\\\"),j.attr(\\\"data-text\\\")&&j.replaceWith(j.html());else for(b.$el.find(\\\"table\\\").filter(function(){var b=a(this).find(\\\"[data-del-cell]\\\").length>0&&a(this).find(\\\"[data-del-cell]\\\").length==a(this).find(\\\"td, th\\\").length;return b}).remove(),b.$el.find(\\\"[data-del-cell]\\\").removeAttr(\\\"data-del-cell\\\"),f=b.$el.find('.fr-marker[data-type=\\\"true\\\"]'),c=0;c<f.length;c++){var m=f[c],p=m.nextSibling,q=b.$el.find('.fr-marker[data-type=\\\"false\\\"][data-id=\\\"'+a(m).data(\\\"id\\\")+'\\\"]').get(0);if(q){if(m&&(!p||p!=q)){var r=b.node.blockParent(m),s=b.node.blockParent(q),u=!1,v=!1;if(r&&[\\\"UL\\\",\\\"OL\\\"].indexOf(r.tagName)>=0&&(r=null,u=!0),s&&[\\\"UL\\\",\\\"OL\\\"].indexOf(s.tagName)>=0&&(s=null,v=!0),a(m).after(q),r!=s)if(null!=r||u)if(null!=s||v||0!==a(r).parentsUntil(b.$el,\\\"table\\\").length)r&&s&&0===a(r).parentsUntil(b.$el,\\\"table\\\").length&&0===a(s).parentsUntil(b.$el,\\\"table\\\").length&&(a(r).append(a(s).html()),a(s).remove());else{for(p=r;!p.nextSibling&&p.parentNode!=b.el;)p=p.parentNode;for(p=p.nextSibling;p&&\\\"BR\\\"!=p.tagName;){var w=p.nextSibling;a(r).append(p),p=w}p&&\\\"BR\\\"==p.tagName&&a(p).remove()}else{var x=b.node.deepestParent(m);x?(a(x).after(a(s).html()),a(s).remove()):0===a(s).parentsUntil(b.$el,\\\"table\\\").length&&(a(m).next().after(a(s).html()),a(s).remove())}}}else q=a(m).clone().attr(\\\"data-type\\\",!1),a(m).after(q)}}b.opts.keepFormatOnDelete||b.html.fillEmptyBlocks(),b.html.cleanEmptyTags(!0),b.clean.lists(),b.spaces.normalize();var y=b.$el.find(\\\".fr-marker:last\\\").get(0),z=b.$el.find(\\\".fr-marker:first\\\").get(0);!y.nextSibling&&z.previousSibling&&\\\"BR\\\"==z.previousSibling.tagName&&b.node.isElement(y.parentNode)&&b.node.isElement(z.parentNode)&&b.$el.append(\\\"<br>\\\"),l()}function w(c){if(!c||c.getElementsByClassName(\\\"fr-marker\\\").length>0)return!1;for(var d=c.firstChild;d&&b.node.isBlock(d);)c=d,d=d.firstChild;c.innerHTML=a.FE.MARKERS+c.innerHTML}function x(c){if(!c||c.getElementsByClassName(\\\"fr-marker\\\").length>0)return!1;for(var d=c.lastChild;d&&b.node.isBlock(d);)c=d,d=d.lastChild;c.innerHTML=c.innerHTML+a.FE.MARKERS}function y(c,d){\\\"undefined\\\"==typeof d&&(d=!0);for(var e=c.previousSibling;e&&e.nodeType==Node.TEXT_NODE&&0===e.textContent.length;)e=e.previousSibling;return e?(b.node.isBlock(e)?x(e):\\\"BR\\\"==e.tagName?a(e).before(a.FE.MARKERS):a(e).after(a.FE.MARKERS),!0):!!d&&(b.node.isBlock(c)?w(c):a(c).before(a.FE.MARKERS),!0)}function z(c,d){\\\"undefined\\\"==typeof d&&(d=!0);for(var e=c.nextSibling;e&&e.nodeType==Node.TEXT_NODE&&0===e.textContent.length;)e=e.nextSibling;return e?(b.node.isBlock(e)?w(e):a(e).before(a.FE.MARKERS),!0):!!d&&(b.node.isBlock(c)?x(c):a(c).after(a.FE.MARKERS),!0)}return{text:c,get:d,ranges:e,clear:f,element:g,endElement:h,save:k,restore:l,isCollapsed:o,isFull:q,inEditor:u,remove:v,blocks:j,info:p,setAtEnd:x,setAtStart:w,setBefore:y,setAfter:z,rangeElement:i}},a.extend(a.FE.DEFAULTS,{htmlAllowedTags:[\\\"a\\\",\\\"abbr\\\",\\\"address\\\",\\\"area\\\",\\\"article\\\",\\\"aside\\\",\\\"audio\\\",\\\"b\\\",\\\"base\\\",\\\"bdi\\\",\\\"bdo\\\",\\\"blockquote\\\",\\\"br\\\",\\\"button\\\",\\\"canvas\\\",\\\"caption\\\",\\\"cite\\\",\\\"code\\\",\\\"col\\\",\\\"colgroup\\\",\\\"datalist\\\",\\\"dd\\\",\\\"del\\\",\\\"details\\\",\\\"dfn\\\",\\\"dialog\\\",\\\"div\\\",\\\"dl\\\",\\\"dt\\\",\\\"em\\\",\\\"embed\\\",\\\"fieldset\\\",\\\"figcaption\\\",\\\"figure\\\",\\\"footer\\\",\\\"form\\\",\\\"h1\\\",\\\"h2\\\",\\\"h3\\\",\\\"h4\\\",\\\"h5\\\",\\\"h6\\\",\\\"header\\\",\\\"hgroup\\\",\\\"hr\\\",\\\"i\\\",\\\"iframe\\\",\\\"img\\\",\\\"input\\\",\\\"ins\\\",\\\"kbd\\\",\\\"keygen\\\",\\\"label\\\",\\\"legend\\\",\\\"li\\\",\\\"link\\\",\\\"main\\\",\\\"map\\\",\\\"mark\\\",\\\"menu\\\",\\\"menuitem\\\",\\\"meter\\\",\\\"nav\\\",\\\"noscript\\\",\\\"object\\\",\\\"ol\\\",\\\"optgroup\\\",\\\"option\\\",\\\"output\\\",\\\"p\\\",\\\"param\\\",\\\"pre\\\",\\\"progress\\\",\\\"queue\\\",\\\"rp\\\",\\\"rt\\\",\\\"ruby\\\",\\\"s\\\",\\\"samp\\\",\\\"script\\\",\\\"style\\\",\\\"section\\\",\\\"select\\\",\\\"small\\\",\\\"source\\\",\\\"span\\\",\\\"strike\\\",\\\"strong\\\",\\\"sub\\\",\\\"summary\\\",\\\"sup\\\",\\\"table\\\",\\\"tbody\\\",\\\"td\\\",\\\"textarea\\\",\\\"tfoot\\\",\\\"th\\\",\\\"thead\\\",\\\"time\\\",\\\"tr\\\",\\\"track\\\",\\\"u\\\",\\\"ul\\\",\\\"var\\\",\\\"video\\\",\\\"wbr\\\"],htmlRemoveTags:[\\\"script\\\",\\\"style\\\"],htmlAllowedAttrs:[\\\"accept\\\",\\\"accept-charset\\\",\\\"accesskey\\\",\\\"action\\\",\\\"align\\\",\\\"allowfullscreen\\\",\\\"allowtransparency\\\",\\\"alt\\\",\\\"async\\\",\\\"autocomplete\\\",\\\"autofocus\\\",\\\"autoplay\\\",\\\"autosave\\\",\\\"background\\\",\\\"bgcolor\\\",\\\"border\\\",\\\"charset\\\",\\\"cellpadding\\\",\\\"cellspacing\\\",\\\"checked\\\",\\\"cite\\\",\\\"class\\\",\\\"color\\\",\\\"cols\\\",\\\"colspan\\\",\\\"content\\\",\\\"contenteditable\\\",\\\"contextmenu\\\",\\\"controls\\\",\\\"coords\\\",\\\"data\\\",\\\"data-.*\\\",\\\"datetime\\\",\\\"default\\\",\\\"defer\\\",\\\"dir\\\",\\\"dirname\\\",\\\"disabled\\\",\\\"download\\\",\\\"draggable\\\",\\\"dropzone\\\",\\\"enctype\\\",\\\"for\\\",\\\"form\\\",\\\"formaction\\\",\\\"frameborder\\\",\\\"headers\\\",\\\"height\\\",\\\"hidden\\\",\\\"high\\\",\\\"href\\\",\\\"hreflang\\\",\\\"http-equiv\\\",\\\"icon\\\",\\\"id\\\",\\\"ismap\\\",\\\"itemprop\\\",\\\"keytype\\\",\\\"kind\\\",\\\"label\\\",\\\"lang\\\",\\\"language\\\",\\\"list\\\",\\\"loop\\\",\\\"low\\\",\\\"max\\\",\\\"maxlength\\\",\\\"media\\\",\\\"method\\\",\\\"min\\\",\\\"mozallowfullscreen\\\",\\\"multiple\\\",\\\"name\\\",\\\"novalidate\\\",\\\"open\\\",\\\"optimum\\\",\\\"pattern\\\",\\\"ping\\\",\\\"placeholder\\\",\\\"poster\\\",\\\"preload\\\",\\\"pubdate\\\",\\\"radiogroup\\\",\\\"readonly\\\",\\\"rel\\\",\\\"required\\\",\\\"reversed\\\",\\\"rows\\\",\\\"rowspan\\\",\\\"sandbox\\\",\\\"scope\\\",\\\"scoped\\\",\\\"scrolling\\\",\\\"seamless\\\",\\\"selected\\\",\\\"shape\\\",\\\"size\\\",\\\"sizes\\\",\\\"span\\\",\\\"src\\\",\\\"srcdoc\\\",\\\"srclang\\\",\\\"srcset\\\",\\\"start\\\",\\\"step\\\",\\\"summary\\\",\\\"spellcheck\\\",\\\"style\\\",\\\"tabindex\\\",\\\"target\\\",\\\"title\\\",\\\"type\\\",\\\"translate\\\",\\\"usemap\\\",\\\"value\\\",\\\"valign\\\",\\\"webkitallowfullscreen\\\",\\\"width\\\",\\\"wrap\\\"],htmlAllowedStyleProps:[],htmlAllowComments:!0,htmlUntouched:!1,fullPage:!1}),a.FE.HTML5Map={B:\\\"STRONG\\\",I:\\\"EM\\\",STRIKE:\\\"S\\\"},a.FE.MODULES.clean=function(b){function c(a){if(a.nodeType==Node.ELEMENT_NODE&&a.getAttribute(\\\"class\\\")&&a.getAttribute(\\\"class\\\").indexOf(\\\"fr-marker\\\")>=0)return!1;var d,e=b.node.contents(a),f=[];for(d=0;d<e.length;d++)e[d].nodeType!=Node.ELEMENT_NODE||b.node.isVoid(e[d])?e[d].nodeType==Node.TEXT_NODE&&(e[d].textContent=e[d].textContent.replace(/\\\\u200b/g,\\\"\\\").replace(/&/g,\\\"&amp;\\\")):e[d].textContent.replace(/\\\\u200b/g,\\\"\\\").length!=e[d].textContent.length&&c(e[d]);if(a.nodeType==Node.ELEMENT_NODE&&!b.node.isVoid(a)&&(a.normalize(),e=b.node.contents(a),f=a.querySelectorAll(\\\".fr-marker\\\"),e.length-f.length===0)){for(d=0;d<e.length;d++)if((e[d].getAttribute(\\\"class\\\")||\\\"\\\").indexOf(\\\"fr-marker\\\")<0)return!1;for(d=0;d<f.length;d++)a.parentNode.insertBefore(f[d].cloneNode(!0),a);return a.parentNode.removeChild(a),!1}}function d(a,c){if(a.nodeType==Node.COMMENT_NODE)return\\\"<!--\\\"+a.nodeValue+\\\"-->\\\";if(a.nodeType==Node.TEXT_NODE)return c?a.textContent.replace(/\\\\&/g,\\\"&amp;\\\").replace(/</g,\\\"&lt;\\\").replace(/>/g,\\\"&gt;\\\"):a.textContent.replace(/\\\\&/g,\\\"&amp;\\\").replace(/</g,\\\"&lt;\\\").replace(/>/g,\\\"&gt;\\\").replace(/\\\\u00A0/g,\\\"&nbsp;\\\").replace(/\\\\u0009/g,\\\"\\\");if(a.nodeType!=Node.ELEMENT_NODE)return a.outerHTML;if(a.nodeType==Node.ELEMENT_NODE&&[\\\"STYLE\\\",\\\"SCRIPT\\\",\\\"NOSCRIPT\\\"].indexOf(a.tagName)>=0)return a.outerHTML;if(a.nodeType==Node.ELEMENT_NODE&&\\\"svg\\\"==a.tagName){var e=document.createElement(\\\"div\\\"),f=a.cloneNode(!0);return e.appendChild(f),e.innerHTML}if(\\\"IFRAME\\\"==a.tagName)return a.outerHTML;var g=a.childNodes;if(0===g.length)return a.outerHTML;for(var h=\\\"\\\",i=0;i<g.length;i++)\\\"PRE\\\"==a.tagName&&(c=!0),h+=d(g[i],c);return b.node.openTagString(a)+h+b.node.closeTagString(a)}function e(a){return L=[],a=a.replace(/<script\\\\b[^<]*(?:(?!<\\\\/script>)<[^<]*)*<\\\\/script>/gi,function(a){return L.push(a),\\\"[FROALA.EDITOR.SCRIPT \\\"+(L.length-1)+\\\"]\\\"}),a=a.replace(/<noscript\\\\b[^<]*(?:(?!<\\\\/noscript>)<[^<]*)*<\\\\/noscript>/gi,function(a){return L.push(a),\\\"[FROALA.EDITOR.NOSCRIPT \\\"+(L.length-1)+\\\"]\\\"}),a=a.replace(/<img((?:[\\\\w\\\\W]*?)) src=\\\"/g,'<img$1 data-fr-src=\\\"')}function f(a){return a=a.replace(/\\\\[FROALA\\\\.EDITOR\\\\.SCRIPT ([\\\\d]*)\\\\]/gi,function(a,c){return b.opts.htmlRemoveTags.indexOf(\\\"script\\\")>=0?\\\"\\\":L[parseInt(c,10)]}),a=a.replace(/\\\\[FROALA\\\\.EDITOR\\\\.NOSCRIPT ([\\\\d]*)\\\\]/gi,function(a,c){return b.opts.htmlRemoveTags.indexOf(\\\"noscript\\\")>=0?\\\"\\\":L[parseInt(c,10)].replace(/\\\\&lt;/g,\\\"<\\\").replace(/\\\\&gt;/g,\\\">\\\")}),a=a.replace(/<img((?:[\\\\w\\\\W]*?)) data-fr-src=\\\"/g,'<img$1 src=\\\"')}function g(a){var b=a.replace(/;;/gi,\\\";\\\");return b=b.replace(/^;/gi,\\\"\\\"),\\\";\\\"!=b.charAt(b.length)&&(b+=\\\";\\\"),b}function h(a){var c;for(c in a)if(a.hasOwnProperty(c)){var d=null;b.opts.htmlAllowedStyleProps.length&&(d=a[c].match(K)),\\\"style\\\"==c&&d?a[c]=g(d.join(\\\";\\\")):c.match(J)||delete a[c]}for(var e=\\\"\\\",f=Object.keys(a).sort(),h=0;h<f.length;h++)c=f[h],e+=a[c].indexOf('\\\"')<0?\\\" \\\"+c+'=\\\"'+a[c]+'\\\"':\\\" \\\"+c+\\\"='\\\"+a[c]+\\\"'\\\";return e}function j(a,c,d){if(b.opts.fullPage){var e=b.html.extractDoctype(d),f=h(b.html.extractNodeAttrs(d,\\\"html\\\"));c=null==c?b.html.extractNode(d,\\\"head\\\")||\\\"<title></title>\\\":c;var g=h(b.html.extractNodeAttrs(d,\\\"head\\\")),i=h(b.html.extractNodeAttrs(d,\\\"body\\\"));return e+\\\"<html\\\"+f+\\\"><head\\\"+g+\\\">\\\"+c+\\\"</head><body\\\"+i+\\\">\\\"+a+\\\"</body></html>\\\"}return a}function k(c,e){var f,g=a(\\\"<div>\\\"+c+\\\"</div>\\\"),h=\\\"\\\";if(g){var i=b.node.contents(g.get(0));for(f=0;f<i.length;f++)e(i[f]);for(i=b.node.contents(g.get(0)),f=0;f<i.length;f++)h+=d(i[f])}return h}function l(a,c,d){a=e(a);var g=a,h=null;b.opts.fullPage&&(g=b.html.extractNode(a,\\\"body\\\")||(a.indexOf(\\\"<body\\\")>=0?\\\"\\\":a),d&&(h=b.html.extractNode(a,\\\"head\\\")||\\\"\\\")),g=k(g,c),h&&(h=k(h,c));var i=j(g,h,a);return f(i)}function m(a){return a.replace(/\\\\u200b/g,\\\"\\\").length==a.length?a:b.clean.exec(a,c)}function n(){var c=b.el.querySelectorAll(Object.keys(a.FE.HTML5Map).join(\\\",\\\"));if(c.length){var d=!1;b.el.querySelector(\\\".fr-marker\\\")||(b.selection.save(),d=!0);for(var e=0;e<c.length;e++)\\\"\\\"===b.node.attributes(c[e])&&a(c[e]).replaceWith(\\\"<\\\"+a.FE.HTML5Map[c[e].tagName]+\\\">\\\"+c[e].innerHTML+\\\"</\\\"+a.FE.HTML5Map[c[e].tagName]+\\\">\\\");d&&b.selection.restore()}}function o(c){if(\\\"SPAN\\\"==c.tagName&&(c.getAttribute(\\\"class\\\")||\\\"\\\").indexOf(\\\"fr-marker\\\")>=0)return!1;if(\\\"PRE\\\"==c.tagName&&q(c),c.nodeType==Node.ELEMENT_NODE&&(c.getAttribute(\\\"data-fr-src\\\")&&c.setAttribute(\\\"data-fr-src\\\",b.helpers.sanitizeURL(c.getAttribute(\\\"data-fr-src\\\"))),c.getAttribute(\\\"href\\\")&&c.setAttribute(\\\"href\\\",b.helpers.sanitizeURL(c.getAttribute(\\\"href\\\"))),[\\\"TABLE\\\",\\\"TBODY\\\",\\\"TFOOT\\\",\\\"TR\\\"].indexOf(c.tagName)>=0&&(c.innerHTML=c.innerHTML.trim())),!b.opts.pasteAllowLocalImages&&c.nodeType==Node.ELEMENT_NODE&&\\\"IMG\\\"==c.tagName&&c.getAttribute(\\\"data-fr-src\\\")&&0===c.getAttribute(\\\"data-fr-src\\\").indexOf(\\\"file://\\\"))return c.parentNode.removeChild(c),!1;if(c.nodeType==Node.ELEMENT_NODE&&a.FE.HTML5Map[c.tagName]&&\\\"\\\"===b.node.attributes(c)){var d=a.FE.HTML5Map[c.tagName],e=\\\"<\\\"+d+\\\">\\\"+c.innerHTML+\\\"</\\\"+d+\\\">\\\";c.insertAdjacentHTML(\\\"beforebegin\\\",e),c=c.previousSibling,c.parentNode.removeChild(c.nextSibling)}if(b.opts.htmlAllowComments||c.nodeType!=Node.COMMENT_NODE)if(c.tagName&&c.tagName.match(I))c.parentNode.removeChild(c);else if(c.tagName&&!c.tagName.match(H))\\\"svg\\\"===c.tagName?c.parentNode.removeChild(c):b.browser.safari&&\\\"path\\\"==c.tagName&&c.parentNode&&\\\"svg\\\"==c.parentNode.tagName||(c.outerHTML=c.innerHTML);else{var f=c.attributes;if(f)for(var h=f.length-1;h>=0;h--){var i=f[h],j=null;b.opts.htmlAllowedStyleProps.length&&(j=i.nodeValue.match(K)),\\\"style\\\"==i.nodeName&&j?i.nodeValue=g(j.join(\\\";\\\")):i.nodeName.match(J)||c.removeAttribute(i.nodeName)}}else 0!==c.data.indexOf(\\\"[FROALA.EDITOR\\\")&&c.parentNode.removeChild(c)}function p(a){for(var c=b.node.contents(a),d=0;d<c.length;d++)c[d].nodeType!=Node.TEXT_NODE&&p(c[d]);o(a)}function q(a){var b=a.innerHTML;b.indexOf(\\\"\\\\n\\\")>=0&&(a.innerHTML=b.replace(/\\\\n/g,\\\"<br>\\\"))}function r(c,d,e,f){\\\"undefined\\\"==typeof d&&(d=[]),\\\"undefined\\\"==typeof e&&(e=[]),\\\"undefined\\\"==typeof f&&(f=!1),c=c.replace(/<br> */g,\\\"<br>\\\");var g,h=a.merge([],b.opts.htmlAllowedTags);for(g=0;g<d.length;g++)h.indexOf(d[g])>=0&&h.splice(h.indexOf(d[g]),1);var i=a.merge([],b.opts.htmlAllowedAttrs);for(g=0;g<e.length;g++)i.indexOf(e[g])>=0&&i.splice(i.indexOf(e[g]),1);return i.push(\\\"data-fr-.*\\\"),i.push(\\\"fr-.*\\\"),H=new RegExp(\\\"^\\\"+h.join(\\\"$|^\\\")+\\\"$\\\",\\\"gi\\\"),J=new RegExp(\\\"^\\\"+i.join(\\\"$|^\\\")+\\\"$\\\",\\\"gi\\\"),I=new RegExp(\\\"^\\\"+b.opts.htmlRemoveTags.join(\\\"$|^\\\")+\\\"$\\\",\\\"gi\\\"),K=b.opts.htmlAllowedStyleProps.length?new RegExp(\\\"((^|;|\\\\\\\\s)\\\"+b.opts.htmlAllowedStyleProps.join(\\\":.+?(?=;|$))|((^|;|\\\\\\\\s)\\\")+\\\":.+?(?=(;|')|$))\\\",\\\"gi\\\"):null,c=l(c,p,!0)}function s(){for(var c=b.el.querySelectorAll(\\\"blockquote + blockquote\\\"),d=0;d<c.length;d++){var e=c[d];b.node.attributes(e)==b.node.attributes(e.previousSibling)&&(a(e).prev().append(a(e).html()),a(e).remove())}}function t(){for(var a=b.el.querySelectorAll(\\\"tr\\\"),c=0;c<a.length;c++){for(var d=a[c].children,e=!0,f=0;f<d.length;f++)if(\\\"TH\\\"!=d[f].tagName){e=!1;break}if(e!==!1&&0!==d.length){for(var g=a[c];g&&\\\"TABLE\\\"!=g.tagName&&\\\"THEAD\\\"!=g.tagName;)g=g.parentNode;var h=g;\\\"THEAD\\\"!=h.tagName&&(h=b.doc.createElement(\\\"THEAD\\\"),g.insertBefore(h,g.firstChild)),h.appendChild(a[c])}}}function u(){var c=b.html.defaultTag();if(c)for(var d=b.el.querySelectorAll(\\\"td > \\\"+c+\\\", th > \\\"+c),e=0;e<d.length;e++)\\\"\\\"===b.node.attributes(d[e])&&a(d[e]).replaceWith(d[e].innerHTML+\\\"<br>\\\")}function v(){t(),u()}function w(){var a=[],c=function(a){return!b.node.isList(a.parentNode)};do{if(a.length){var d=a[0],e=b.doc.createElement(\\\"ul\\\");d.parentNode.insertBefore(e,d);do{var f=d;d=d.nextSibling,e.appendChild(f)}while(d&&\\\"LI\\\"==d.tagName)}a=[];for(var g=b.el.querySelectorAll(\\\"li\\\"),h=0;h<g.length;h++)c(g[h])&&a.push(g[h])}while(a.length>0)}function x(){for(var a=b.el.querySelectorAll(\\\"ol + ol, ul + ul\\\"),c=0;c<a.length;c++){var d=a[c];if(b.node.isList(d.previousSibling)&&b.node.openTagString(d)==b.node.openTagString(d.previousSibling)){for(var e=b.node.contents(d),f=0;f<e.length;f++)d.previousSibling.appendChild(e[f]);d.parentNode.removeChild(d)}}}function y(){var a,c,d=function(a){a.querySelector(\\\"LI\\\")||(c=!0,a.parentNode.removeChild(a))};do{c=!1;var e=b.el.querySelectorAll(\\\"li:empty\\\");for(a=0;a<e.length;a++)e[a].parentNode.removeChild(e[a]);var f=b.el.querySelectorAll(\\\"ul, ol\\\");for(a=0;a<f.length;a++)d(f[a])}while(c===!0)}function z(){for(var c=b.el.querySelectorAll(\\\"ul > ul, ol > ol, ul > ol, ol > ul\\\"),d=0;d<c.length;d++){var e=c[d],f=e.previousSibling;f&&(\\\"LI\\\"==f.tagName?f.appendChild(e):a(e).wrap(\\\"<li></li>\\\"))}}function A(){for(var c=b.el.querySelectorAll(\\\"li > ul, li > ol\\\"),d=0;d<c.length;d++){var e=c[d];if(e.nextSibling){var f=e.nextSibling,g=a(\\\"<li>\\\");a(e.parentNode).after(g);do{var h=f;f=f.nextSibling,g.append(h)}while(f)}}}function B(){for(var c=b.el.querySelectorAll(\\\"li > ul, li > ol\\\"),d=0;d<c.length;d++){var e=c[d];if(b.node.isFirstSibling(e))a(e).before(\\\"<br/>\\\");else if(e.previousSibling&&\\\"BR\\\"==e.previousSibling.tagName){for(var f=e.previousSibling.previousSibling;f&&b.node.hasClass(f,\\\"fr-marker\\\");)f=f.previousSibling;f&&\\\"BR\\\"!=f.tagName&&a(e.previousSibling).remove()}}}function C(){for(var c=b.el.querySelectorAll(\\\"li:empty\\\"),d=0;d<c.length;d++)a(c[d]).remove()}function D(){for(var c=b.el.querySelectorAll(\\\"ul, ol\\\"),d=0;d<c.length;d++)for(var e=b.node.contents(c[d]),f=null,g=e.length-1;g>=0;g--)\\\"LI\\\"!=e[g].tagName?(f||(f=a(\\\"<li>\\\"),f.insertBefore(e[g])),f.prepend(e[g])):f=null}function E(){for(default_tag_els=b.el.querySelectorAll(b.html.defaultTag()),i=default_tag_els.length-1;i>=0;i--)el=default_tag_els[i],el.parentNode&&\\\"LI\\\"==el.parentNode.tagName&&(el.nextElementSibling&&el.nextElementSibling.tagName.toLowerCase()==b.html.defaultTag()&&a(\\\"<br>\\\").insertBefore(el.nextElementSibling),el.previousElementSibling&&el.previousElementSibling.tagName.toLowerCase()==b.html.defaultTag()&&a(\\\"<br>\\\").insertAfter(el.previousElementSibling),el.outerHTML=el.innerHTML)}function F(){w(),x(),y(),z(),A(),B(),D(),C(),E()}function G(){b.opts.fullPage&&a.merge(b.opts.htmlAllowedTags,[\\\"head\\\",\\\"title\\\",\\\"style\\\",\\\"link\\\",\\\"base\\\",\\\"body\\\",\\\"html\\\",\\\"meta\\\"])}var H,I,J,K,L=[];return{_init:G,html:r,toHTML5:n,tables:v,lists:F,quotes:s,invisibleSpaces:m,exec:l}},a.FE.MODULES.spaces=function(b){function c(c,d){var e=c.previousSibling,f=c.nextSibling,g=c.textContent,h=c.parentNode;if(\\\"PRE\\\"!=h.tagName){d&&(g=g.replace(/[\\\\f\\\\n\\\\r\\\\t\\\\v ]{2,}/g,\\\" \\\"),f&&\\\"BR\\\"!==f.tagName&&!b.node.isBlock(f)||!b.node.isBlock(h)||(g=g.replace(/[\\\\f\\\\n\\\\r\\\\t\\\\v ]{1,}$/g,\\\"\\\")),e&&\\\"BR\\\"!==e.tagName&&!b.node.isBlock(e)||!b.node.isBlock(h)||(g=g.replace(/^[\\\\f\\\\n\\\\r\\\\t\\\\v ]{1,}/g,\\\"\\\")),\\\" \\\"===g&&(e&&e.nodeType!=Node.TEXT_NODE||f&&f.nodeType!=Node.TEXT_NODE)&&(g=\\\"\\\")),g=g.replace(new RegExp(a.FE.UNICODE_NBSP,\\\"g\\\"),\\\" \\\");for(var i=\\\"\\\",j=0;j<g.length;j++)i+=32!=g.charCodeAt(j)||0!==j&&32!=i.charCodeAt(j-1)?g[j]:a.FE.UNICODE_NBSP;(!f||b.node.isBlock(f)||f.nodeType==Node.ELEMENT_NODE&&b.win.getComputedStyle(f)&&\\\"block\\\"==b.win.getComputedStyle(f).display)&&(i=i.replace(/ $/,a.FE.UNICODE_NBSP)),!e||b.node.isVoid(e)||b.node.isBlock(e)||(i=i.replace(/^\\\\u00A0([^ $])/,\\\" $1\\\"),1!==i.length||160!==i.charCodeAt(0)||!f||b.node.isVoid(f)||b.node.isBlock(f)||(i=\\\" \\\")),i=i.replace(/([^ \\\\u00A0])\\\\u00A0([^ \\\\u00A0])/g,\\\"$1 $2\\\"),c.textContent!=i&&(c.textContent=i)}}function d(a,d){if(\\\"undefined\\\"!=typeof a&&a||(a=b.el),\\\"undefined\\\"==typeof d&&(d=!1),b.opts.htmlUntouched)return!1;if(!a.getAttribute||\\\"false\\\"!=a.getAttribute(\\\"contenteditable\\\"))if(a.nodeType==Node.TEXT_NODE)c(a,d);else if(a.nodeType==Node.ELEMENT_NODE)for(var e=b.doc.createTreeWalker(a,NodeFilter.SHOW_TEXT,b.node.filter(function(a){for(var c=a.parentNode;c&&c!==b.el;){if(\\\"PRE\\\"===c.tagName)return!1;c=c.parentNode}return null!=a.textContent.match(/([ \\\\u00A0\\\\f\\\\n\\\\r\\\\t\\\\v]{2,})|(^[ \\\\u00A0\\\\f\\\\n\\\\r\\\\t\\\\v]{1,})|([ \\\\u00A0\\\\f\\\\n\\\\r\\\\t\\\\v]{1,}$)/g)&&!b.node.hasClass(a.parentNode,\\\"fr-marker\\\")}),!1);e.nextNode();)c(e.currentNode,d)}function e(){for(var a=[],c=b.el.querySelectorAll(\\\".fr-marker\\\"),e=0;e<c.length;e++){var f=null,g=b.node.blockParent(c[e]);f=g?g:c[e];for(var h=f.nextSibling,i=f.previousSibling;h&&\\\"BR\\\"==h.tagName;)h=h.nextSibling;for(;i&&\\\"BR\\\"==i.tagName;)i=i.previousSibling;f&&a.indexOf(f)<0&&a.push(f),i&&a.indexOf(i)<0&&a.push(i),h&&a.indexOf(h)<0&&a.push(h)}for(var j=0;j<a.length;j++)d(a[j])}return{normalize:d,normalizeAroundCursor:e}},a.FE.UNICODE_NBSP=String.fromCharCode(160),a.FE.VOID_ELEMENTS=[\\\"area\\\",\\\"base\\\",\\\"br\\\",\\\"col\\\",\\\"embed\\\",\\\"hr\\\",\\\"img\\\",\\\"input\\\",\\\"keygen\\\",\\\"link\\\",\\\"menuitem\\\",\\\"meta\\\",\\\"param\\\",\\\"source\\\",\\\"track\\\",\\\"wbr\\\"],a.FE.BLOCK_TAGS=[\\\"address\\\",\\\"article\\\",\\\"aside\\\",\\\"audio\\\",\\\"blockquote\\\",\\\"canvas\\\",\\\"dd\\\",\\\"div\\\",\\\"dl\\\",\\\"dt\\\",\\\"fieldset\\\",\\\"figcaption\\\",\\\"figure\\\",\\\"footer\\\",\\\"form\\\",\\\"h1\\\",\\\"h2\\\",\\\"h3\\\",\\\"h4\\\",\\\"h5\\\",\\\"h6\\\",\\\"header\\\",\\\"hgroup\\\",\\\"hr\\\",\\\"li\\\",\\\"main\\\",\\\"nav\\\",\\\"noscript\\\",\\\"ol\\\",\\\"output\\\",\\\"p\\\",\\\"pre\\\",\\\"section\\\",\\\"table\\\",\\\"tbody\\\",\\\"td\\\",\\\"tfoot\\\",\\\"th\\\",\\\"thead\\\",\\\"tr\\\",\\\"ul\\\",\\\"video\\\"],a.extend(a.FE.DEFAULTS,{htmlAllowedEmptyTags:[\\\"textarea\\\",\\\"a\\\",\\\"iframe\\\",\\\"object\\\",\\\"video\\\",\\\"style\\\",\\\"script\\\",\\\".fa\\\",\\\".fr-emoticon\\\"],htmlDoNotWrapTags:[\\\"script\\\",\\\"style\\\"],htmlSimpleAmpersand:!1,htmlIgnoreCSSProperties:[]}),a.FE.MODULES.html=function(b){function c(){return b.opts.enter==a.FE.ENTER_P?\\\"p\\\":b.opts.enter==a.FE.ENTER_DIV?\\\"div\\\":b.opts.enter==a.FE.ENTER_BR?null:void 0}function d(c){var d,e=[],g=[];if(c){var h=b.el.querySelectorAll(\\\".fr-marker\\\");for(d=0;d<h.length;d++){var i=b.node.blockParent(h[d])||h[d];if(i){var j=i.nextSibling,k=i.previousSibling;i&&g.indexOf(i)<0&&b.node.isBlock(i)&&g.push(i),k&&b.node.isBlock(k)&&g.indexOf(k)<0&&g.push(k),j&&b.node.isBlock(j)&&g.indexOf(j)<0&&g.push(j)}}}else g=b.el.querySelectorAll(f());var l=f();for(l+=\\\",\\\"+a.FE.VOID_ELEMENTS.join(\\\",\\\"),l+=\\\",\\\"+b.opts.htmlAllowedEmptyTags.join(\\\":not(.fr-marker),\\\")+\\\":not(.fr-marker)\\\",d=g.length-1;d>=0;d--)if(!(g[d].textContent&&g[d].textContent.replace(/\\\\u200B|\\\\n/g,\\\"\\\").length>0||g[d].querySelectorAll(l).length>0)){for(var m=b.node.contents(g[d]),n=!1,o=0;o<m.length;o++)if(m[o].nodeType!=Node.COMMENT_NODE&&m[o].textContent&&m[o].textContent.replace(/\\\\u200B|\\\\n/g,\\\"\\\").length>0){n=!0;break}n||e.push(g[d])}return e}function e(){return a.FE.BLOCK_TAGS.join(\\\":empty, \\\")+\\\":empty\\\"}function f(){return a.FE.BLOCK_TAGS.join(\\\", \\\")}function g(c){var d=a.merge([],a.FE.VOID_ELEMENTS);d=a.merge(d,b.opts.htmlAllowedEmptyTags),\\\"undefined\\\"==typeof c&&(d=a.merge(d,a.FE.BLOCK_TAGS));var e,f;e=b.el.querySelectorAll(\\\"*:empty:not(\\\"+d.join(\\\"):not(\\\")+\\\"):not(.fr-marker)\\\");do{f=!1;for(var g=0;g<e.length;g++)0!==e[g].attributes.length&&\\\"undefined\\\"==typeof e[g].getAttribute(\\\"href\\\")||(e[g].parentNode.removeChild(e[g]),f=!0);e=b.el.querySelectorAll(\\\"*:empty:not(\\\"+d.join(\\\"):not(\\\")+\\\"):not(.fr-marker)\\\")}while(e.length&&f)}function h(a,d){var e=c();if(d&&(e=\\\"div\\\"),e){for(var f=b.doc.createDocumentFragment(),g=null,h=!1,i=a.firstChild;i;){var j=i.nextSibling;if(i.nodeType==Node.ELEMENT_NODE&&(b.node.isBlock(i)||b.opts.htmlDoNotWrapTags.indexOf(i.tagName.toLowerCase())>=0&&!b.node.hasClass(i,\\\"fr-marker\\\")))g=null,f.appendChild(i);else if(i.nodeType!=Node.ELEMENT_NODE&&i.nodeType!=Node.TEXT_NODE)g=null,f.appendChild(i);else if(\\\"BR\\\"==i.tagName)null==g?(g=b.doc.createElement(e),d&&g.setAttribute(\\\"data-empty\\\",!0),g.appendChild(i),f.appendChild(g)):h===!1&&(g.appendChild(b.doc.createElement(\\\"br\\\")),g.setAttribute(\\\"data-empty\\\",!0)),g=null;else{var k=i.textContent;i.nodeType==Node.TEXT_NODE&&0===k.replace(/\\\\n/g,\\\"\\\").replace(/(^ *)|( *$)/g,\\\"\\\").length||(null==g&&(g=b.doc.createElement(e),d&&g.setAttribute(\\\"class\\\",\\\"fr-temp-div\\\"),f.appendChild(g),h=!1),g.appendChild(i),h||b.node.hasClass(i,\\\"fr-marker\\\")||i.nodeType==Node.TEXT_NODE&&0===k.replace(/ /g,\\\"\\\").length||(h=!0))}i=j}a.innerHTML=\\\"\\\",a.appendChild(f)}}function i(a,b){for(var c=0;c<a.length;c++)h(a[c],b)}function j(a,c,d,e){return!!b.$wp&&(\\\"undefined\\\"==typeof a&&(a=!1),\\\"undefined\\\"==typeof c&&(c=!1),\\\"undefined\\\"==typeof d&&(d=!1),\\\"undefined\\\"==typeof e&&(e=!1),h(b.el,a),e&&i(b.el.querySelectorAll(\\\".fr-inner\\\"),a),c&&i(b.el.querySelectorAll(\\\"td, th\\\"),a),void(d&&i(b.el.querySelectorAll(\\\"blockquote\\\"),a)))}function k(){b.$el.find(\\\"div.fr-temp-div\\\").each(function(){a(this).data(\\\"empty\\\")||\\\"LI\\\"==this.parentNode.tagName||b.node.isBlock(this.nextSibling)&&!a(this.nextSibling).hasClass(\\\"fr-temp-div\\\")?a(this).replaceWith(a(this).html()):a(this).replaceWith(a(this).html()+\\\"<br>\\\")}),b.$el.find(\\\".fr-temp-div\\\").removeClass(\\\"fr-temp-div\\\").filter(function(){return\\\"\\\"===a(this).attr(\\\"class\\\")}).removeAttr(\\\"class\\\")}function l(c){for(var e=d(c),f=0;f<e.length;f++){var g=e[f];\\\"false\\\"===g.getAttribute(\\\"contenteditable\\\")||g.querySelector(b.opts.htmlAllowedEmptyTags.join(\\\":not(.fr-marker),\\\")+\\\":not(.fr-marker)\\\")||b.node.isVoid(g)||\\\"TABLE\\\"!=g.tagName&&\\\"TBODY\\\"!=g.tagName&&\\\"TR\\\"!=g.tagName&&g.appendChild(b.doc.createElement(\\\"br\\\"))}if(b.browser.msie&&b.opts.enter==a.FE.ENTER_BR){var h=b.node.contents(b.el);h.length&&h[h.length-1].nodeType==Node.TEXT_NODE&&b.$el.append(\\\"<br>\\\")}}function m(){return b.$el.get(0).querySelectorAll(f())}function n(a){if(\\\"undefined\\\"==typeof a&&(a=b.el),a&&[\\\"SCRIPT\\\",\\\"STYLE\\\",\\\"PRE\\\"].indexOf(a.tagName)>=0)return!1;for(var c=b.doc.createTreeWalker(a,NodeFilter.SHOW_TEXT,b.node.filter(function(a){return null!=a.textContent.match(/([ \\\\n]{2,})|(^[ \\\\n]{1,})|([ \\\\n]{1,}$)/g)}),!1);c.nextNode();){var d=c.currentNode;if(\\\"PRE\\\"!=d.parentNode.tagName){var e=b.node.isBlock(d.parentNode)||b.node.isElement(d.parentNode),f=d.textContent.replace(/(?!^)( ){2,}(?!$)/g,\\\" \\\").replace(/\\\\n/g,\\\" \\\").replace(/^[ ]{2,}/g,\\\" \\\").replace(/[ ]{2,}$/g,\\\" \\\");if(e){var g=d.previousSibling,h=d.nextSibling;g&&h&&\\\" \\\"==f?f=b.node.isBlock(g)&&b.node.isBlock(h)?\\\"\\\":\\\"\\\\n\\\":(g||(f=f.replace(/^ */,\\\"\\\")),h||(f=f.replace(/ *$/,\\\"\\\")))}d.textContent=f}}}function o(a,b,c){var d=new RegExp(b,\\\"gi\\\"),e=d.exec(a);return e?e[c]:null}function p(a,b){var c=a.match(/<!DOCTYPE ?([^ ]*) ?([^ ]*) ?\\\"?([^\\\"]*)\\\"? ?\\\"?([^\\\"]*)\\\"?>/i);return c?b.implementation.createDocumentType(c[1],c[3],c[4]):b.implementation.createDocumentType(\\\"html\\\")}function q(a){var b=a.doctype,c=\\\"<!DOCTYPE html>\\\";return b&&(c=\\\"<!DOCTYPE \\\"+b.name+(b.publicId?' PUBLIC \\\"'+b.publicId+'\\\"':\\\"\\\")+(!b.publicId&&b.systemId?\\\" SYSTEM\\\":\\\"\\\")+(b.systemId?' \\\"'+b.systemId+'\\\"':\\\"\\\")+\\\">\\\"),c}function r(c,d){var e=c.parentNode;if(e&&(b.node.isBlock(e)||b.node.isElement(e))&&[\\\"TD\\\",\\\"TH\\\"].indexOf(e.tagName)<0){for(var f=c.previousSibling,g=c.nextSibling;f&&f.nodeType==Node.TEXT_NODE&&0===f.textContent.replace(/\\\\n|\\\\r/g,\\\"\\\").length;)f=f.previousSibling;f&&e&&\\\"BR\\\"!=f.tagName&&!b.node.isBlock(f)&&!g&&e.textContent.replace(/\\\\u200B/g,\\\"\\\").length>0&&f.textContent.length>0&&!b.node.hasClass(f,\\\"fr-marker\\\")&&(b.el==e&&!g&&b.opts.enter==a.FE.ENTER_BR&&b.browser.msie||(d&&b.selection.save(),c.parentNode.removeChild(c),d&&b.selection.restore()))}}function s(){var a,c,d=b.selection.element();a=b.node.isBlock(d)?d:b.node.blockParent(d);var e=[];if(a){var f=a.nextSibling,g=a.previousSibling;a&&e.indexOf(a)<0&&e.push(a),g&&b.node.isBlock(g)&&e.indexOf(g)<0&&e.push(g),f&&b.node.isBlock(f)&&e.indexOf(f)<0&&e.push(f)}var h=[];for(c=0;c<e.length;c++)for(var i=e[c].querySelectorAll(\\\"br\\\"),j=0;j<i.length;j++)h.indexOf(i[j])<0&&h.push(i[j]);if(d.parentNode==b.el){var k=b.el.children;for(c=0;c<k.length;c++)\\\"BR\\\"==k[c].tagName&&h.indexOf(k[c])<0&&h.push(k[c])}return h}function t(a,c){var d,e=null;if(a)for(e=s(),d=0;d<e.length;d++)r(e[d],c);else for(e=b.el.getElementsByTagName(\\\"br\\\"),d=0;d<e.length;d++)r(e[d],c)}function u(){b.opts.htmlUntouched||(g(),j()),n(),b.opts.htmlUntouched||(b.spaces.normalize(null,!0),b.html.fillEmptyBlocks(),b.clean.quotes(),b.clean.lists(),b.clean.tables(),b.clean.toHTML5(),b.html.cleanBRs()),b.selection.restore(),v(),b.placeholder.refresh()}function v(){b.core.isEmpty()&&(null!=c()?b.el.querySelector(f())||b.el.querySelector(b.opts.htmlDoNotWrapTags.join(\\\":not(.fr-marker),\\\")+\\\":not(.fr-marker)\\\")||(b.core.hasFocus()?(b.$el.html(\\\"<\\\"+c()+\\\">\\\"+a.FE.MARKERS+\\\"<br/></\\\"+c()+\\\">\\\"),b.selection.restore()):b.$el.html(\\\"<\\\"+c()+\\\"><br/></\\\"+c()+\\\">\\\")):b.el.querySelector(\\\"*:not(.fr-marker):not(br)\\\")||(b.core.hasFocus()?(b.$el.html(a.FE.MARKERS+\\\"<br/>\\\"),b.selection.restore()):b.$el.html(\\\"<br/>\\\")))}function w(a,b){return o(a,\\\"<\\\"+b+\\\"[^>]*?>([\\\\\\\\w\\\\\\\\W]*)</\\\"+b+\\\">\\\",1)}function x(c,d){var e=a(\\\"<div \\\"+(o(c,\\\"<\\\"+d+\\\"([^>]*?)>\\\",1)||\\\"\\\")+\\\">\\\");return b.node.rawAttributes(e.get(0))}function y(a){return o(a,\\\"<!DOCTYPE([^>]*?)>\\\",0)||\\\"<!DOCTYPE html>\\\"}function z(c){var d=b.clean.html(c||\\\"\\\",[],[],b.opts.fullPage);if(b.opts.fullPage){var e=w(d,\\\"body\\\")||(d.indexOf(\\\"<body\\\")>=0?\\\"\\\":d),f=x(d,\\\"body\\\"),g=w(d,\\\"head\\\")||\\\"<title></title>\\\",h=x(d,\\\"head\\\"),i=a(\\\"<div>\\\").append(g).contents().each(function(){(this.nodeType==Node.COMMENT_NODE||[\\\"BASE\\\",\\\"LINK\\\",\\\"META\\\",\\\"NOSCRIPT\\\",\\\"SCRIPT\\\",\\\"STYLE\\\",\\\"TEMPLATE\\\",\\\"TITLE\\\"].indexOf(this.tagName)>=0)&&this.parentNode.removeChild(this)}).end().html().trim();g=a(\\\"<div>\\\").append(g).contents().map(function(){return this.nodeType==Node.COMMENT_NODE?\\\"<!--\\\"+this.nodeValue+\\\"-->\\\":[\\\"BASE\\\",\\\"LINK\\\",\\\"META\\\",\\\"NOSCRIPT\\\",\\\"SCRIPT\\\",\\\"STYLE\\\",\\\"TEMPLATE\\\",\\\"TITLE\\\"].indexOf(this.tagName)>=0?this.outerHTML:\\\"\\\"}).toArray().join(\\\"\\\");var j=y(d),k=x(d,\\\"html\\\");b.$el.html(i+\\\"\\\\n\\\"+e),b.node.clearAttributes(b.el),b.$el.attr(f),b.$el.addClass(\\\"fr-view\\\"),b.$el.attr(\\\"spellcheck\\\",b.opts.spellcheck),b.$el.attr(\\\"dir\\\",b.opts.direction),b.$head.html(g),b.node.clearAttributes(b.$head.get(0)),b.$head.attr(h),b.node.clearAttributes(b.$html.get(0)),b.$html.attr(k),b.iframe_document.doctype.parentNode.replaceChild(p(j,b.iframe_document),b.iframe_document.doctype)}else b.$el.html(d);var l=b.edit.isDisabled();b.edit.on(),b.core.injectStyle(b.opts.iframeStyle),u(),b.opts.useClasses||(b.$el.find(\\\"[fr-original-class]\\\").each(function(){this.setAttribute(\\\"class\\\",this.getAttribute(\\\"fr-original-class\\\")),this.removeAttribute(\\\"fr-original-class\\\")}),b.$el.find(\\\"[fr-original-style]\\\").each(function(){this.setAttribute(\\\"style\\\",this.getAttribute(\\\"fr-original-style\\\")),this.removeAttribute(\\\"fr-original-style\\\")})),l&&b.edit.off(),b.events.trigger(\\\"html.set\\\")}function A(a){var b=/(#[^\\\\s\\\\+>~\\\\.\\\\[:]+)/g,c=/(\\\\[[^\\\\]]+\\\\])/g,d=/(\\\\.[^\\\\s\\\\+>~\\\\.\\\\[:]+)/g,e=/(::[^\\\\s\\\\+>~\\\\.\\\\[:]+|:first-line|:first-letter|:before|:after)/gi,f=/(:[\\\\w-]+\\\\([^\\\\)]*\\\\))/gi,g=/(:[^\\\\s\\\\+>~\\\\.\\\\[:]+)/g,h=/([^\\\\s\\\\+>~\\\\.\\\\[:]+)/g;!function(){var b=/:not\\\\(([^\\\\)]*)\\\\)/g;b.test(a)&&(a=a.replace(b,\\\"     $1 \\\"))}();var i=100*(a.match(b)||[]).length+10*(a.match(c)||[]).length+10*(a.match(d)||[]).length+10*(a.match(f)||[]).length+10*(a.match(g)||[]).length+(a.match(e)||[]).length;return a=a.replace(/[\\\\*\\\\s\\\\+>~]/g,\\\" \\\"),a=a.replace(/[#\\\\.]/g,\\\" \\\"),i+=(a.match(h)||[]).length}function B(a){if(b.events.trigger(\\\"html.processGet\\\",[a]),a&&a.getAttribute&&\\\"\\\"===a.getAttribute(\\\"class\\\")&&a.removeAttribute(\\\"class\\\"),a&&a.nodeType==Node.ELEMENT_NODE)for(var c=a.querySelectorAll('[class=\\\"\\\"]'),d=0;d<c.length;d++)c[d].removeAttribute(\\\"class\\\")}function C(a,b){return a[3]-b[3]}function D(a,c){if(!b.$wp)return b.$oel.clone().removeClass(\\\"fr-view\\\").removeAttr(\\\"contenteditable\\\").get(0).outerHTML;var d=\\\"\\\";b.events.trigger(\\\"html.beforeGet\\\");var e,f,g=[],h={},i=[];if(!b.opts.useClasses&&!c){var j=new RegExp(\\\"^\\\"+b.opts.htmlIgnoreCSSProperties.join(\\\"$|^\\\")+\\\"$\\\",\\\"gi\\\");for(e=0;e<b.doc.styleSheets.length;e++){var k,l=0;try{k=b.doc.styleSheets[e].cssRules,b.doc.styleSheets[e].ownerNode&&\\\"STYLE\\\"==b.doc.styleSheets[e].ownerNode.nodeType&&(l=1)}catch(m){}if(k)for(var n=0,o=k.length;n<o;n++)if(k[n].selectorText&&k[n].style.cssText.length>0){var p,r=k[n].selectorText.replace(/body |\\\\.fr-view /g,\\\"\\\").replace(/::/g,\\\":\\\");try{p=b.el.querySelectorAll(r)}catch(m){p=[]}for(f=0;f<p.length;f++){!p[f].getAttribute(\\\"fr-original-style\\\")&&p[f].getAttribute(\\\"style\\\")?(p[f].setAttribute(\\\"fr-original-style\\\",p[f].getAttribute(\\\"style\\\")),g.push(p[f])):p[f].getAttribute(\\\"fr-original-style\\\")||g.push(p[f]),h[p[f]]||(h[p[f]]={});for(var s=1e3*l+A(k[n].selectorText),t=k[n].style.cssText.split(\\\";\\\"),u=0;u<t.length;u++){var v=t[u].trim().split(\\\":\\\")[0];v.match(j)||(h[p[f]][v]||(h[p[f]][v]=0,\\n(p[f].getAttribute(\\\"fr-original-style\\\")||\\\"\\\").indexOf(v+\\\":\\\")>=0&&(h[p[f]][v]=1e4)),s>=h[p[f]][v]&&(h[p[f]][v]=s,t[u].trim().length&&i.push([p[f],v.trim(),t[u].trim().split(\\\":\\\")[1].trim(),s])))}}}}for(i.sort(C),e=0;e<i.length;e++){var w=i[e];w[0].style[w[1]]=w[2]}for(e=0;e<g.length;e++)if(g[e].getAttribute(\\\"class\\\")&&(g[e].setAttribute(\\\"fr-original-class\\\",g[e].getAttribute(\\\"class\\\")),g[e].removeAttribute(\\\"class\\\")),(g[e].getAttribute(\\\"fr-original-style\\\")||\\\"\\\").trim().length>0){var x=g[e].getAttribute(\\\"fr-original-style\\\").split(\\\";\\\");for(f=0;f<x.length;f++)x[f].indexOf(\\\":\\\")>0&&(g[e].style[x[f].split(\\\":\\\")[0].trim()]=x[f].split(\\\":\\\")[1].trim())}}if(b.core.isEmpty()?b.opts.fullPage&&(d=q(b.iframe_document),d+=\\\"<html\\\"+b.node.attributes(b.$html.get(0))+\\\">\\\"+b.$html.find(\\\"head\\\").get(0).outerHTML+\\\"<body></body></html>\\\"):(\\\"undefined\\\"==typeof a&&(a=!1),b.opts.fullPage?(d=q(b.iframe_document),b.$el.removeClass(\\\"fr-view\\\"),d+=\\\"<html\\\"+b.node.attributes(b.$html.get(0))+\\\">\\\"+b.$html.html()+\\\"</html>\\\",b.$el.addClass(\\\"fr-view\\\")):d=b.$el.html()),!b.opts.useClasses&&!c)for(e=0;e<g.length;e++)g[e].getAttribute(\\\"fr-original-class\\\")&&(g[e].setAttribute(\\\"class\\\",g[e].getAttribute(\\\"fr-original-class\\\")),g[e].removeAttribute(\\\"fr-original-class\\\")),g[e].getAttribute(\\\"fr-original-style\\\")?(g[e].setAttribute(\\\"style\\\",g[e].getAttribute(\\\"fr-original-style\\\")),g[e].removeAttribute(\\\"fr-original-style\\\")):g[e].removeAttribute(\\\"style\\\");b.opts.fullPage&&(d=d.replace(/<style data-fr-style=\\\"true\\\">(?:[\\\\w\\\\W]*?)<\\\\/style>/g,\\\"\\\"),d=d.replace(/<link([^>]*)data-fr-style=\\\"true\\\"([^>]*)>/g,\\\"\\\"),d=d.replace(/<style(?:[\\\\w\\\\W]*?)class=\\\"firebugResetStyles\\\"(?:[\\\\w\\\\W]*?)>(?:[\\\\w\\\\W]*?)<\\\\/style>/g,\\\"\\\"),d=d.replace(/<body((?:[\\\\w\\\\W]*?)) spellcheck=\\\"true\\\"((?:[\\\\w\\\\W]*?))>((?:[\\\\w\\\\W]*?))<\\\\/body>/g,\\\"<body$1$2>$3</body>\\\"),d=d.replace(/<body((?:[\\\\w\\\\W]*?)) contenteditable=\\\"(true|false)\\\"((?:[\\\\w\\\\W]*?))>((?:[\\\\w\\\\W]*?))<\\\\/body>/g,\\\"<body$1$3>$4</body>\\\"),d=d.replace(/<body((?:[\\\\w\\\\W]*?)) dir=\\\"([\\\\w]*)\\\"((?:[\\\\w\\\\W]*?))>((?:[\\\\w\\\\W]*?))<\\\\/body>/g,\\\"<body$1$3>$4</body>\\\"),d=d.replace(/<body((?:[\\\\w\\\\W]*?))class=\\\"([\\\\w\\\\W]*?)(fr-rtl|fr-ltr)([\\\\w\\\\W]*?)\\\"((?:[\\\\w\\\\W]*?))>((?:[\\\\w\\\\W]*?))<\\\\/body>/g,'<body$1class=\\\"$2$4\\\"$5>$6</body>'),d=d.replace(/<body((?:[\\\\w\\\\W]*?)) class=\\\"\\\"((?:[\\\\w\\\\W]*?))>((?:[\\\\w\\\\W]*?))<\\\\/body>/g,\\\"<body$1$2>$3</body>\\\")),b.opts.htmlSimpleAmpersand&&(d=d.replace(/\\\\&amp;/gi,\\\"&\\\")),b.events.trigger(\\\"html.afterGet\\\"),a||(d=d.replace(/<span[^>]*? class\\\\s*=\\\\s*[\\\"']?fr-marker[\\\"']?[^>]+>\\\\u200b<\\\\/span>/gi,\\\"\\\")),d=b.clean.invisibleSpaces(d),d=b.clean.exec(d,B);var y=b.events.chainTrigger(\\\"html.get\\\",d);return\\\"string\\\"==typeof y&&(d=y),d=d.replace(/<pre(?:[\\\\w\\\\W]*?)>(?:[\\\\w\\\\W]*?)<\\\\/pre>/g,function(a){return a.replace(/<br>/g,\\\"\\\\n\\\")})}function E(){var c=function(c,d){for(;d&&(d.nodeType==Node.TEXT_NODE||!b.node.isBlock(d))&&!b.node.isElement(d);)d&&d.nodeType!=Node.TEXT_NODE&&a(c).wrapInner(b.node.openTagString(d)+b.node.closeTagString(d)),d=d.parentNode;d&&c.innerHTML==d.innerHTML&&(c.innerHTML=d.outerHTML)},d=function(){var c,d=null;return b.win.getSelection?(c=b.win.getSelection(),c&&c.rangeCount&&(d=c.getRangeAt(0).commonAncestorContainer,d.nodeType!=Node.ELEMENT_NODE&&(d=d.parentNode))):(c=b.doc.selection)&&\\\"Control\\\"!=c.type&&(d=c.createRange().parentElement()),null!=d&&(a.inArray(b.el,a(d).parents())>=0||d==b.el)?d:null},e=\\\"\\\";if(\\\"undefined\\\"!=typeof b.win.getSelection){b.browser.mozilla&&(b.selection.save(),b.$el.find('.fr-marker[data-type=\\\"false\\\"]').length>1&&(b.$el.find('.fr-marker[data-type=\\\"false\\\"][data-id=\\\"0\\\"]').remove(),b.$el.find('.fr-marker[data-type=\\\"false\\\"]:last').attr(\\\"data-id\\\",\\\"0\\\"),b.$el.find(\\\".fr-marker\\\").not('[data-id=\\\"0\\\"]').remove()),b.selection.restore());for(var f=b.selection.ranges(),g=0;g<f.length;g++){var h=document.createElement(\\\"div\\\");h.appendChild(f[g].cloneContents());var i=h.children;if(i.length){var j=i[i.length-1];(\\\"P\\\"==j.tagName&&b.opts.enter==a.FroalaEditor.ENTER_P||\\\"DIV\\\"==j.tagName&&b.opts.enter==a.FroalaEditor.ENTER_DIV)&&b.node.isEmpty(j)&&h.removeChild(j)}c(h,d()),a(h).find(\\\".fr-element\\\").length>0&&(h=b.el),e+=h.innerHTML}}else\\\"undefined\\\"!=typeof b.doc.selection&&\\\"Text\\\"==b.doc.selection.type&&(e=b.doc.selection.createRange().htmlText);return e}function F(a){var c=b.doc.createElement(\\\"div\\\");return c.innerHTML=a,null!==c.querySelector(f())}function G(a){var c=b.doc.createElement(\\\"div\\\");return c.innerHTML=a,b.selection.setAtEnd(c),c.innerHTML}function H(a){return a.replace(/</gi,\\\"&lt;\\\").replace(/>/gi,\\\"&gt;\\\").replace(/\\\"/gi,\\\"&quot;\\\").replace(/'/gi,\\\"&#39;\\\")}function I(a,c,d){b.selection.isCollapsed()||b.selection.remove();var e;if(e=c?a:b.clean.html(a),e=e.replace(/\\\\r|\\\\n/g,\\\" \\\"),a.indexOf('class=\\\"fr-marker\\\"')<0&&(e=G(e)),b.core.isEmpty()&&!b.opts.keepFormatOnDelete)b.el.innerHTML=e;else{var f=b.markers.insert();if(f){var g,h=b.node.blockParent(f);if((F(e)||d)&&(g=b.node.deepestParent(f)||h&&\\\"LI\\\"==h.tagName)){if(f=b.markers.split(),!f)return!1;f.outerHTML=e}else f.outerHTML=e}else b.el.innerHTML=b.el.innerHTML+e}u(),b.events.trigger(\\\"html.inserted\\\")}function J(c){var d=null;if(\\\"undefined\\\"==typeof c&&(d=b.selection.element()),b.opts.keepFormatOnDelete)return!1;var e=d?(d.textContent.match(/\\\\u200B/g)||[]).length-d.querySelectorAll(\\\".fr-marker\\\").length:0,f=(b.el.textContent.match(/\\\\u200B/g)||[]).length-b.el.querySelectorAll(\\\".fr-marker\\\").length;if(f==e)return!1;var g,h;do{h=!1,g=b.el.querySelectorAll(\\\"*:not(.fr-marker)\\\");for(var i=0;i<g.length;i++){var j=g[i];if(d!=j){var k=j.textContent;0===j.children.length&&1===k.length&&8203==k.charCodeAt(0)&&(a(j).remove(),h=!0)}}}while(h)}function K(){var a=function(){J(),b.placeholder&&setTimeout(b.placeholder.refresh,0)};b.events.on(\\\"mouseup\\\",a),b.events.on(\\\"keydown\\\",a),b.events.on(\\\"contentChanged\\\",v)}return{defaultTag:c,emptyBlocks:d,emptyBlockTagsQuery:e,blockTagsQuery:f,fillEmptyBlocks:l,cleanEmptyTags:g,cleanWhiteTags:J,cleanBlankSpaces:n,blocks:m,getDoctype:q,set:z,get:D,getSelected:E,insert:I,wrap:j,unwrap:k,escapeEntities:H,checkIfEmpty:v,extractNode:w,extractNodeAttrs:x,extractDoctype:y,cleanBRs:t,_init:K}},a.extend(a.FE.DEFAULTS,{height:null,heightMax:null,heightMin:null,width:null}),a.FE.MODULES.size=function(a){function b(){c(),a.opts.height&&a.$el.css(\\\"minHeight\\\",a.opts.height-a.helpers.getPX(a.$el.css(\\\"padding-top\\\"))-a.helpers.getPX(a.$el.css(\\\"padding-bottom\\\"))),a.$iframe.height(a.$el.outerHeight(!0))}function c(){a.opts.heightMin?a.$el.css(\\\"minHeight\\\",a.opts.heightMin):a.$el.css(\\\"minHeight\\\",\\\"\\\"),a.opts.heightMax?(a.$wp.css(\\\"maxHeight\\\",a.opts.heightMax),a.$wp.css(\\\"overflow\\\",\\\"auto\\\")):(a.$wp.css(\\\"maxHeight\\\",\\\"\\\"),a.$wp.css(\\\"overflow\\\",\\\"\\\")),a.opts.height?(a.$wp.height(a.opts.height),a.$wp.css(\\\"overflow\\\",\\\"auto\\\"),a.$el.css(\\\"minHeight\\\",a.opts.height-a.helpers.getPX(a.$el.css(\\\"padding-top\\\"))-a.helpers.getPX(a.$el.css(\\\"padding-bottom\\\")))):(a.$wp.css(\\\"height\\\",\\\"\\\"),a.opts.heightMin||a.$el.css(\\\"minHeight\\\",\\\"\\\"),a.opts.heightMax||a.$wp.css(\\\"overflow\\\",\\\"\\\")),a.opts.width&&a.$box.width(a.opts.width)}function d(){return!!a.$wp&&(c(),void(a.$iframe&&(a.events.on(\\\"keyup\\\",b),a.events.on(\\\"commands.after\\\",b),a.events.on(\\\"html.set\\\",b),a.events.on(\\\"init\\\",b),a.events.on(\\\"initialized\\\",b))))}return{_init:d,syncIframe:b,refresh:c}},a.extend(a.FE.DEFAULTS,{language:null}),a.FE.LANGUAGE={},a.FE.MODULES.language=function(b){function c(a){return e&&e.translation[a]?e.translation[a]:a}function d(){a.FE.LANGUAGE&&(e=a.FE.LANGUAGE[b.opts.language]),e&&e.direction&&(b.opts.direction=e.direction)}var e;return{_init:d,translate:c}},a.extend(a.FE.DEFAULTS,{placeholderText:\\\"Type something\\\"}),a.FE.MODULES.placeholder=function(b){function c(){b.$placeholder||g();var c=0,d=0,e=0,f=0,h=0,i=0,j=b.node.contents(b.el),k=a(b.selection.element()).css(\\\"text-align\\\");if(j.length&&j[0].nodeType==Node.ELEMENT_NODE){var l=a(j[0]);!b.opts.toolbarInline&&b.ready&&(c=b.helpers.getPX(l.css(\\\"margin-top\\\")),f=b.helpers.getPX(l.css(\\\"padding-top\\\")),d=b.helpers.getPX(l.css(\\\"margin-left\\\")),e=b.helpers.getPX(l.css(\\\"margin-right\\\")),h=b.helpers.getPX(l.css(\\\"padding-left\\\")),i=b.helpers.getPX(l.css(\\\"padding-right\\\"))),b.$placeholder.css(\\\"font-size\\\",l.css(\\\"font-size\\\")),b.$placeholder.css(\\\"line-height\\\",l.css(\\\"line-height\\\"))}else b.$placeholder.css(\\\"font-size\\\",b.$el.css(\\\"font-size\\\")),b.$placeholder.css(\\\"line-height\\\",b.$el.css(\\\"line-height\\\"));b.$wp.addClass(\\\"show-placeholder\\\"),b.$placeholder.css({marginTop:Math.max(b.helpers.getPX(b.$el.css(\\\"margin-top\\\")),c),paddingTop:Math.max(b.helpers.getPX(b.$el.css(\\\"padding-top\\\")),f),paddingLeft:Math.max(b.helpers.getPX(b.$el.css(\\\"padding-left\\\")),h),marginLeft:Math.max(b.helpers.getPX(b.$el.css(\\\"margin-left\\\")),d),paddingRight:Math.max(b.helpers.getPX(b.$el.css(\\\"padding-right\\\")),i),marginRight:Math.max(b.helpers.getPX(b.$el.css(\\\"margin-right\\\")),e),textAlign:k}).text(b.language.translate(b.opts.placeholderText||b.$oel.attr(\\\"placeholder\\\")||\\\"\\\")),b.$placeholder.html(b.$placeholder.text().replace(/\\\\n/g,\\\"<br>\\\"))}function d(){b.$wp.removeClass(\\\"show-placeholder\\\")}function e(){return!b.$wp||b.node.hasClass(b.$wp.get(0),\\\"show-placeholder\\\")}function f(){return!!b.$wp&&void(b.core.isEmpty()?c():d())}function g(){b.$placeholder=a('<span class=\\\"fr-placeholder\\\"></span>'),b.$wp.append(b.$placeholder)}function h(){return!!b.$wp&&void b.events.on(\\\"init input keydown keyup contentChanged initialized\\\",f)}return{_init:h,show:c,hide:d,refresh:f,isVisible:e}},a.FE.MODULES.edit=function(a){function b(){if(a.browser.mozilla)try{a.doc.execCommand(\\\"enableObjectResizing\\\",!1,\\\"false\\\"),a.doc.execCommand(\\\"enableInlineTableEditing\\\",!1,\\\"false\\\")}catch(b){}if(a.browser.msie)try{a.doc.body.addEventListener(\\\"mscontrolselect\\\",function(a){return a.preventDefault(),!1})}catch(b){}}function c(){a.$wp?(a.$el.attr(\\\"contenteditable\\\",!0),a.$el.removeClass(\\\"fr-disabled\\\").attr(\\\"aria-disabled\\\",!1),a.$tb&&a.$tb.removeClass(\\\"fr-disabled\\\").attr(\\\"aria-disabled\\\",!1),b()):a.$el.is(\\\"a\\\")&&a.$el.attr(\\\"contenteditable\\\",!0),f=!1}function d(){a.$wp?(a.$el.attr(\\\"contenteditable\\\",!1),a.$el.addClass(\\\"fr-disabled\\\").attr(\\\"aria-disabled\\\",!0),a.$tb&&a.$tb.addClass(\\\"fr-disabled\\\").attr(\\\"aria-disabled\\\",!0)):a.$el.is(\\\"a\\\")&&a.$el.attr(\\\"contenteditable\\\",!1),f=!0}function e(){return f}var f=!1;return{on:c,off:d,disableDesign:b,isDisabled:e}},a.extend(a.FE.DEFAULTS,{editorClass:null,typingTimer:500,iframe:!1,requestWithCORS:!0,requestWithCredentials:!1,requestHeaders:{},useClasses:!0,spellcheck:!0,iframeStyle:'html{margin:0px;height:auto;}body{height:auto;padding:10px;background:transparent;color:#000000;position:relative;z-index: 2;-webkit-user-select:auto;margin:0px;overflow:hidden;min-height:20px;}body:after{content:\\\"\\\";display:block;clear:both;}',iframeStyleFiles:[],direction:\\\"auto\\\",zIndex:1,disableRightClick:!1,scrollableContainer:\\\"body\\\",keepFormatOnDelete:!1,theme:null}),a.FE.MODULES.core=function(b){function c(c){if(b.opts.iframe){b.$head.find(\\\"style[data-fr-style], link[data-fr-style]\\\").remove(),b.$head.append('<style data-fr-style=\\\"true\\\">'+c+\\\"</style>\\\");for(var d=0;d<b.opts.iframeStyleFiles.length;d++){var e=a('<link data-fr-style=\\\"true\\\" rel=\\\"stylesheet\\\" href=\\\"'+b.opts.iframeStyleFiles[d]+'\\\">');e.get(0).addEventListener(\\\"load\\\",b.size.syncIframe),b.$head.append(e)}}}function d(){b.opts.iframe||b.$el.addClass(\\\"fr-element fr-view\\\")}function e(){if(b.$box.addClass(\\\"fr-box\\\"+(b.opts.editorClass?\\\" \\\"+b.opts.editorClass:\\\"\\\")),b.$wp.addClass(\\\"fr-wrapper\\\"),d(),b.opts.iframe){b.$iframe.addClass(\\\"fr-iframe\\\"),b.$el.addClass(\\\"fr-view\\\");for(var a=0;a<b.o_doc.styleSheets.length;a++){var c;try{c=b.o_doc.styleSheets[a].cssRules}catch(e){}if(c)for(var f=0,g=c.length;f<g;f++)!c[f].selectorText||0!==c[f].selectorText.indexOf(\\\".fr-view\\\")&&0!==c[f].selectorText.indexOf(\\\".fr-element\\\")||c[f].style.cssText.length>0&&(0===c[f].selectorText.indexOf(\\\".fr-view\\\")?b.opts.iframeStyle+=c[f].selectorText.replace(/\\\\.fr-view/g,\\\"body\\\")+\\\"{\\\"+c[f].style.cssText+\\\"}\\\":b.opts.iframeStyle+=c[f].selectorText.replace(/\\\\.fr-element/g,\\\"body\\\")+\\\"{\\\"+c[f].style.cssText+\\\"}\\\")}}\\\"auto\\\"!=b.opts.direction&&b.$box.removeClass(\\\"fr-ltr fr-rtl\\\").addClass(\\\"fr-\\\"+b.opts.direction),b.$el.attr(\\\"dir\\\",b.opts.direction),b.$wp.attr(\\\"dir\\\",b.opts.direction),b.opts.zIndex>1&&b.$box.css(\\\"z-index\\\",b.opts.zIndex),b.opts.theme&&b.$box.addClass(b.opts.theme+\\\"-theme\\\")}function f(){return b.node.isEmpty(b.el)}function g(){b.drag_support={filereader:\\\"undefined\\\"!=typeof FileReader,formdata:!!b.win.FormData,progress:\\\"upload\\\"in new XMLHttpRequest}}function h(a,c){var d=new XMLHttpRequest;d.open(c,a,!0),b.opts.requestWithCredentials&&(d.withCredentials=!0);for(var e in b.opts.requestHeaders)b.opts.requestHeaders.hasOwnProperty(e)&&d.setRequestHeader(e,b.opts.requestHeaders[e]);return d}function i(a){\\\"TEXTAREA\\\"==b.$oel.get(0).tagName&&b.$oel.val(a),b.$wp&&(\\\"TEXTAREA\\\"==b.$oel.get(0).tagName?(b.$el.html(\\\"\\\"),b.$wp.html(\\\"\\\"),b.$box.replaceWith(b.$oel),b.$oel.show()):(b.$wp.replaceWith(a),b.$el.html(\\\"\\\"),b.$box.removeClass(\\\"fr-view fr-ltr fr-box \\\"+(b.opts.editorClass||\\\"\\\")),b.opts.theme&&b.$box.addClass(b.opts.theme+\\\"-theme\\\"))),this.$wp=null,this.$el=null,this.el=null,this.$box=null}function j(){return b.browser.mozilla&&b.helpers.isMobile()?b.selection.inEditor():b.node.hasFocus(b.el)||b.$el.find(\\\"*:focus\\\").length>0}function k(a){if(!a)return!1;var c=a.data(\\\"instance\\\");return!!c&&c.id==b.id}function l(){if(a.FE.INSTANCES.push(b),g(),b.$wp){e(),b.html.set(b._original_html),b.$el.attr(\\\"spellcheck\\\",b.opts.spellcheck),b.helpers.isMobile()&&(b.$el.attr(\\\"autocomplete\\\",b.opts.spellcheck?\\\"on\\\":\\\"off\\\"),b.$el.attr(\\\"autocorrect\\\",b.opts.spellcheck?\\\"on\\\":\\\"off\\\"),b.$el.attr(\\\"autocapitalize\\\",b.opts.spellcheck?\\\"on\\\":\\\"off\\\")),b.opts.disableRightClick&&b.events.$on(b.$el,\\\"contextmenu\\\",function(a){if(2==a.button)return!1});try{b.doc.execCommand(\\\"styleWithCSS\\\",!1,!1)}catch(c){}}\\\"TEXTAREA\\\"==b.$oel.get(0).tagName&&(b.events.on(\\\"contentChanged\\\",function(){b.$oel.val(b.html.get())}),b.events.on(\\\"form.submit\\\",function(){b.$oel.val(b.html.get())}),b.events.on(\\\"form.reset\\\",function(){b.html.set(b._original_html)}),b.$oel.val(b.html.get())),b.helpers.isIOS()&&b.events.$on(b.$doc,\\\"selectionchange\\\",function(){b.$doc.get(0).hasFocus()||b.$win.get(0).focus()}),b.events.trigger(\\\"init\\\")}return{_init:l,destroy:i,isEmpty:f,getXHR:h,injectStyle:c,hasFocus:j,sameInstance:k}},a.FE.MODULES.cursorLists=function(b){function c(a){for(var b=a;\\\"LI\\\"!=b.tagName;)b=b.parentNode;return b}function d(a){for(var c=a;!b.node.isList(c);)c=c.parentNode;return c}function e(e){var f,g=c(e),h=g.nextSibling,i=g.previousSibling,j=b.html.defaultTag();if(b.node.isEmpty(g,!0)&&h){for(var k=\\\"\\\",l=\\\"\\\",m=e.parentNode;!b.node.isList(m)&&m.parentNode&&\\\"LI\\\"!==m.parentNode.tagName;)k=b.node.openTagString(m)+k,l+=b.node.closeTagString(m),m=m.parentNode;k=b.node.openTagString(m)+k,l+=b.node.closeTagString(m);var n=\\\"\\\";for(n=m.parentNode&&\\\"LI\\\"==m.parentNode.tagName?l+\\\"<li>\\\"+a.FE.MARKERS+\\\"<br>\\\"+k:j?l+\\\"<\\\"+j+\\\">\\\"+a.FE.MARKERS+\\\"<br></\\\"+j+\\\">\\\"+k:l+a.FE.MARKERS+\\\"<br>\\\"+k,a(g).html('<span id=\\\"fr-break\\\"></span>');[\\\"UL\\\",\\\"OL\\\"].indexOf(m.tagName)<0||m.parentNode&&\\\"LI\\\"===m.parentNode.tagName;)m=m.parentNode;var o=b.node.openTagString(m)+a(m).html()+b.node.closeTagString(m);o=o.replace(/<span id=\\\"fr-break\\\"><\\\\/span>/g,n),a(m).replaceWith(o),b.$el.find(\\\"li:empty\\\").remove()}else i&&h||!b.node.isEmpty(g,!0)?(a(g).before(\\\"<li><br></li>\\\"),a(e).remove()):i?(f=d(g),f.parentNode&&\\\"LI\\\"==f.parentNode.tagName?a(f.parentNode).after(\\\"<li>\\\"+a.FE.MARKERS+\\\"<br></li>\\\"):j?a(f).after(\\\"<\\\"+j+\\\">\\\"+a.FE.MARKERS+\\\"<br></\\\"+j+\\\">\\\"):a(f).after(a.FE.MARKERS+\\\"<br>\\\"),a(g).remove()):(f=d(g),f.parentNode&&\\\"LI\\\"==f.parentNode.tagName?h?a(f.parentNode).before(\\\"<li>\\\"+a.FE.MARKERS+\\\"<br></li>\\\"):a(f.parentNode).after(\\\"<li>\\\"+a.FE.MARKERS+\\\"<br></li>\\\"):j?a(f).before(\\\"<\\\"+j+\\\">\\\"+a.FE.MARKERS+\\\"<br></\\\"+j+\\\">\\\"):a(f).before(a.FE.MARKERS+\\\"<br>\\\"),a(g).remove())}function f(d){for(var e=c(d),f=\\\"\\\",g=d,h=\\\"\\\",i=\\\"\\\";g!=e;){g=g.parentNode;var j=\\\"A\\\"==g.tagName&&b.cursor.isAtEnd(d,g)?\\\"fr-to-remove\\\":\\\"\\\";h=b.node.openTagString(a(g).clone().addClass(j).get(0))+h,i=b.node.closeTagString(g)+i}f=i+f+h+a.FE.MARKERS,a(d).replaceWith('<span id=\\\"fr-break\\\"></span>');var k=b.node.openTagString(e)+a(e).html()+b.node.closeTagString(e);k=k.replace(/<span id=\\\"fr-break\\\"><\\\\/span>/g,f),a(e).replaceWith(k)}function g(d){for(var e=c(d),f=a.FE.MARKERS,g=\\\"\\\",h=d,i=!1;h!=e;){h=h.parentNode;var j=\\\"A\\\"==h.tagName&&b.cursor.isAtEnd(d,h)?\\\"fr-to-remove\\\":\\\"\\\";i||h==e||b.node.isBlock(h)||(i=!0,g+=a.FE.INVISIBLE_SPACE),g=b.node.openTagString(a(h).clone().addClass(j).get(0))+g,f+=b.node.closeTagString(h)}var k=g+f;a(d).remove(),a(e).after(k)}function h(e){var f=c(e),g=f.previousSibling;if(g){g=a(g).find(b.html.blockTagsQuery()).get(-1)||g,a(e).replaceWith(a.FE.MARKERS);var h=b.node.contents(g);h.length&&\\\"BR\\\"==h[h.length-1].tagName&&a(h[h.length-1]).remove(),a(f).find(b.html.blockTagsQuery()).not(\\\"ol, ul, table\\\").each(function(){this.parentNode==f&&a(this).replaceWith(a(this).html()+(b.node.isEmpty(this)?\\\"\\\":\\\"<br>\\\"))});for(var i,j=b.node.contents(f)[0];j&&!b.node.isList(j);)i=j.nextSibling,a(g).append(j),j=i;for(g=f.previousSibling;j;)i=j.nextSibling,a(g).append(j),j=i;a(f).remove()}else{var k=d(f);if(a(e).replaceWith(a.FE.MARKERS),k.parentNode&&\\\"LI\\\"==k.parentNode.tagName){var l=k.previousSibling;b.node.isBlock(l)?(a(f).find(b.html.blockTagsQuery()).not(\\\"ol, ul, table\\\").each(function(){this.parentNode==f&&a(this).replaceWith(a(this).html()+(b.node.isEmpty(this)?\\\"\\\":\\\"<br>\\\"))}),a(l).append(a(f).html())):a(k).before(a(f).html())}else{var m=b.html.defaultTag();m&&0===a(f).find(b.html.blockTagsQuery()).length?a(k).before(\\\"<\\\"+m+\\\">\\\"+a(f).html()+\\\"</\\\"+m+\\\">\\\"):(a(k).before(a(f).html()),b.html.wrap())}a(f).remove(),0===a(k).find(\\\"li\\\").length&&a(k).remove()}}function i(d){var e,f=c(d),g=f.nextSibling;if(g){e=b.node.contents(g),e.length&&\\\"BR\\\"==e[0].tagName&&a(e[0]).remove(),a(g).find(b.html.blockTagsQuery()).not(\\\"ol, ul, table\\\").each(function(){this.parentNode==g&&a(this).replaceWith(a(this).html()+(b.node.isEmpty(this)?\\\"\\\":\\\"<br>\\\"))});for(var h,i=d,j=b.node.contents(g)[0];j&&!b.node.isList(j);)h=j.nextSibling,a(i).after(j),i=j,j=h;for(;j;)h=j.nextSibling,a(f).append(j),j=h;a(d).replaceWith(a.FE.MARKERS),a(g).remove()}else{for(var k=f;!k.nextSibling&&k!=b.el;)k=k.parentNode;if(k==b.el)return!1;if(k=k.nextSibling,b.node.isBlock(k))a.FE.NO_DELETE_TAGS.indexOf(k.tagName)<0&&(a(d).replaceWith(a.FE.MARKERS),e=b.node.contents(f),e.length&&\\\"BR\\\"==e[e.length-1].tagName&&a(e[e.length-1]).remove(),a(f).append(a(k).html()),a(k).remove());else for(e=b.node.contents(f),e.length&&\\\"BR\\\"==e[e.length-1].tagName&&a(e[e.length-1]).remove(),a(d).replaceWith(a.FE.MARKERS);k&&!b.node.isBlock(k)&&\\\"BR\\\"!=k.tagName;)a(f).append(a(k)),k=k.nextSibling}}return{_startEnter:e,_middleEnter:f,_endEnter:g,_backspace:h,_del:i}},a.FE.NO_DELETE_TAGS=[\\\"TH\\\",\\\"TD\\\",\\\"TR\\\",\\\"TABLE\\\",\\\"FORM\\\"],a.FE.SIMPLE_ENTER_TAGS=[\\\"TH\\\",\\\"TD\\\",\\\"LI\\\",\\\"DL\\\",\\\"DT\\\",\\\"FORM\\\"],a.FE.MODULES.cursor=function(b){function c(a){return!!a&&(!!b.node.isBlock(a)||(a.nextSibling&&a.nextSibling.nodeType==Node.TEXT_NODE&&0===a.nextSibling.textContent.replace(/\\\\u200b/g,\\\"\\\").length?c(a.nextSibling):!a.nextSibling&&c(a.parentNode)))}function d(a){return!!a&&(!!b.node.isBlock(a)||(a.previousSibling&&a.previousSibling.nodeType==Node.TEXT_NODE&&0===a.previousSibling.textContent.replace(/\\\\u200b/g,\\\"\\\").length?d(a.previousSibling):!a.previousSibling&&d(a.parentNode)))}function e(a,c){return!!a&&(a!=b.$wp.get(0)&&(a.previousSibling&&a.previousSibling.nodeType==Node.TEXT_NODE&&0===a.previousSibling.textContent.replace(/\\\\u200b/g,\\\"\\\").length?e(a.previousSibling,c):!a.previousSibling&&(a.parentNode==c||e(a.parentNode,c))))}function f(a,c){return!!a&&(a!=b.$wp.get(0)&&(a.nextSibling&&a.nextSibling.nodeType==Node.TEXT_NODE&&0===a.nextSibling.textContent.replace(/\\\\u200b/g,\\\"\\\").length?f(a.nextSibling,c):!a.nextSibling&&(a.parentNode==c||f(a.parentNode,c))))}function g(c){return a(c).parentsUntil(b.$el,\\\"LI\\\").length>0&&0===a(c).parentsUntil(\\\"LI\\\",\\\"TABLE\\\").length}function h(c){var d=a(c).parentsUntil(b.$el,\\\"BLOCKQUOTE\\\").length>0,e=b.node.deepestParent(c,[],!d);if(e&&\\\"BLOCKQUOTE\\\"==e.tagName){var f=b.node.deepestParent(c,[a(c).parentsUntil(b.$el,\\\"BLOCKQUOTE\\\").get(0)]);f&&f.previousSibling&&(e=f)}if(null!==e){var g,h=e.previousSibling;if(b.node.isBlock(e)&&b.node.isEditable(e)&&h&&a.FE.NO_DELETE_TAGS.indexOf(h.tagName)<0)if(b.node.isDeletable(h))a(h).remove(),a(c).replaceWith(a.FE.MARKERS);else if(b.node.isEditable(h))if(b.node.isBlock(h))if(b.node.isEmpty(h)&&!b.node.isList(h))a(h).remove();else{if(b.node.isList(h)&&(h=a(h).find(\\\"li:last\\\").get(0)),g=b.node.contents(h),g.length&&\\\"BR\\\"==g[g.length-1].tagName&&a(g[g.length-1]).remove(),\\\"BLOCKQUOTE\\\"==h.tagName&&\\\"BLOCKQUOTE\\\"!=e.tagName)for(g=b.node.contents(h);g.length&&b.node.isBlock(g[g.length-1]);)h=g[g.length-1],g=b.node.contents(h);else if(\\\"BLOCKQUOTE\\\"!=h.tagName&&\\\"BLOCKQUOTE\\\"==e.tagName)for(g=b.node.contents(e);g.length&&b.node.isBlock(g[0]);)e=g[0],g=b.node.contents(e);a(c).replaceWith(a.FE.MARKERS),a(h).append(b.node.isEmpty(e)?a.FE.MARKERS:e.innerHTML),a(e).remove()}else a(c).replaceWith(a.FE.MARKERS),\\\"BLOCKQUOTE\\\"==e.tagName&&h.nodeType==Node.ELEMENT_NODE?a(h).remove():(a(h).after(b.node.isEmpty(e)?\\\"\\\":a(e).html()),a(e).remove(),\\\"BR\\\"==h.tagName&&a(h).remove())}}function i(c){for(var d=c;!d.previousSibling;)if(d=d.parentNode,b.node.isElement(d))return!1;d=d.previousSibling;var e;if(!b.node.isBlock(d)&&b.node.isEditable(d)){for(e=b.node.contents(d);d.nodeType!=Node.TEXT_NODE&&!b.node.isDeletable(d)&&e.length&&b.node.isEditable(d);)d=e[e.length-1],e=b.node.contents(d);if(d.nodeType==Node.TEXT_NODE){if(b.helpers.isIOS())return!0;var f=d.textContent,g=f.length-1;if(b.opts.tabSpaces&&f.length>=b.opts.tabSpaces){var h=f.substr(f.length-b.opts.tabSpaces,f.length-1);0===h.replace(/ /g,\\\"\\\").replace(new RegExp(a.FE.UNICODE_NBSP,\\\"g\\\"),\\\"\\\").length&&(g=f.length-b.opts.tabSpaces)}d.textContent=f.substring(0,g),d.textContent.length&&55357==d.textContent.charCodeAt(d.textContent.length-1)&&(d.textContent=d.textContent.substr(0,d.textContent.length-1));var i=f.length!=d.textContent.length;0===d.textContent.length?i&&b.opts.keepFormatOnDelete?a(d).after(a.FE.INVISIBLE_SPACE+a.FE.MARKERS):2!=d.parentNode.childNodes.length||d.parentNode!=c.parentNode||b.node.isBlock(d.parentNode)||b.node.isElement(d.parentNode)?(a(d).after(a.FE.MARKERS),b.node.isElement(d.parentNode)&&!c.nextSibling&&d.previousSibling&&\\\"BR\\\"==d.previousSibling.tagName&&a(c).after(\\\"<br>\\\"),d.parentNode.removeChild(d)):(a(d.parentNode).after(a.FE.MARKERS),a(d.parentNode).remove()):a(d).after(a.FE.MARKERS)}else b.node.isDeletable(d)?(a(d).after(a.FE.MARKERS),a(d).remove()):b.events.trigger(\\\"node.remove\\\",[a(d)])!==!1&&(a(d).after(a.FE.MARKERS),a(d).remove())}else if(a.FE.NO_DELETE_TAGS.indexOf(d.tagName)<0&&(b.node.isEditable(d)||b.node.isDeletable(d)))if(b.node.isDeletable(d))a(c).replaceWith(a.FE.MARKERS),a(d).remove();else if(b.node.isEmpty(d)&&!b.node.isList(d))a(d).remove(),a(c).replaceWith(a.FE.MARKERS);else{for(b.node.isList(d)&&(d=a(d).find(\\\"li:last\\\").get(0)),e=b.node.contents(d),e&&\\\"BR\\\"==e[e.length-1].tagName&&a(e[e.length-1]).remove(),e=b.node.contents(d);e&&b.node.isBlock(e[e.length-1]);)d=e[e.length-1],e=b.node.contents(d);a(d).append(a.FE.MARKERS);for(var j=c;!j.previousSibling;)j=j.parentNode;for(;j&&\\\"BR\\\"!==j.tagName&&!b.node.isBlock(j);){var k=j;j=j.nextSibling,a(d).append(k)}j&&\\\"BR\\\"==j.tagName&&a(j).remove(),a(c).remove()}else c.nextSibling&&\\\"BR\\\"==c.nextSibling.tagName&&a(c.nextSibling).remove()}function j(){var f=!1,j=b.markers.insert();if(!j)return!0;for(var k=j.parentNode;k&&!b.node.isElement(k);){if(\\\"false\\\"===k.getAttribute(\\\"contenteditable\\\"))return a(j).replaceWith(a.FE.MARKERS),b.selection.restore(),!1;if(\\\"true\\\"===k.getAttribute(\\\"contenteditable\\\"))break;k=k.parentNode}b.el.normalize();var l=j.previousSibling;if(l){var m=l.textContent;m&&m.length&&8203==m.charCodeAt(m.length-1)&&(1==m.length?a(l).remove():(l.textContent=l.textContent.substr(0,m.length-1),l.textContent.length&&55357==l.textContent.charCodeAt(l.textContent.length-1)&&(l.textContent=l.textContent.substr(0,l.textContent.length-1))))}return c(j)?f=i(j):d(j)?g(j)&&e(j,a(j).parents(\\\"li:first\\\").get(0))?b.cursorLists._backspace(j):h(j):f=i(j),a(j).remove(),n(),b.html.fillEmptyBlocks(!0),b.opts.htmlUntouched||(b.html.cleanEmptyTags(),b.clean.quotes(),b.clean.lists()),b.spaces.normalizeAroundCursor(),b.selection.restore(),f}function k(c){var d=a(c).parentsUntil(b.$el,\\\"BLOCKQUOTE\\\").length>0,e=b.node.deepestParent(c,[],!d);if(e&&\\\"BLOCKQUOTE\\\"==e.tagName){var f=b.node.deepestParent(c,[a(c).parentsUntil(b.$el,\\\"BLOCKQUOTE\\\").get(0)]);f&&f.nextSibling&&(e=f)}if(null!==e){var g,h=e.nextSibling;if(b.node.isBlock(e)&&(b.node.isEditable(e)||b.node.isDeletable(e))&&h&&a.FE.NO_DELETE_TAGS.indexOf(h.tagName)<0)if(b.node.isDeletable(h))a(h).remove(),a(c).replaceWith(a.FE.MARKERS);else if(b.node.isBlock(h)&&b.node.isEditable(h))if(b.node.isList(h))if(b.node.isEmpty(e,!0))a(e).remove(),a(h).find(\\\"li:first\\\").prepend(a.FE.MARKERS);else{var i=a(h).find(\\\"li:first\\\");\\\"BLOCKQUOTE\\\"==e.tagName&&(g=b.node.contents(e),g.length&&b.node.isBlock(g[g.length-1])&&(e=g[g.length-1])),0===i.find(\\\"ul, ol\\\").length&&(a(c).replaceWith(a.FE.MARKERS),i.find(b.html.blockTagsQuery()).not(\\\"ol, ul, table\\\").each(function(){this.parentNode==i.get(0)&&a(this).replaceWith(a(this).html()+(b.node.isEmpty(this)?\\\"\\\":\\\"<br>\\\"))}),a(e).append(b.node.contents(i.get(0))),i.remove(),0===a(h).find(\\\"li\\\").length&&a(h).remove())}else{if(g=b.node.contents(h),g.length&&\\\"BR\\\"==g[0].tagName&&a(g[0]).remove(),\\\"BLOCKQUOTE\\\"!=h.tagName&&\\\"BLOCKQUOTE\\\"==e.tagName)for(g=b.node.contents(e);g.length&&b.node.isBlock(g[g.length-1]);)e=g[g.length-1],g=b.node.contents(e);else if(\\\"BLOCKQUOTE\\\"==h.tagName&&\\\"BLOCKQUOTE\\\"!=e.tagName)for(g=b.node.contents(h);g.length&&b.node.isBlock(g[0]);)h=g[0],g=b.node.contents(h);a(c).replaceWith(a.FE.MARKERS),a(e).append(h.innerHTML),a(h).remove()}else{for(a(c).replaceWith(a.FE.MARKERS);h&&\\\"BR\\\"!==h.tagName&&!b.node.isBlock(h)&&b.node.isEditable(h);){var j=h;h=h.nextSibling,a(e).append(j)}h&&\\\"BR\\\"==h.tagName&&b.node.isEditable(h)&&a(h).remove()}}}function l(d){for(var e=d;!e.nextSibling;)if(e=e.parentNode,b.node.isElement(e))return!1;if(e=e.nextSibling,\\\"BR\\\"==e.tagName&&b.node.isEditable(e))if(e.nextSibling){if(b.node.isBlock(e.nextSibling)&&b.node.isEditable(e.nextSibling)){if(!(a.FE.NO_DELETE_TAGS.indexOf(e.nextSibling.tagName)<0))return void a(e).remove();e=e.nextSibling,a(e.previousSibling).remove()}}else if(c(e)){if(g(d))b.cursorLists._del(d);else{var f=b.node.deepestParent(e);f&&(a(e).remove(),k(d))}return}var h;if(!b.node.isBlock(e)&&b.node.isEditable(e)){for(h=b.node.contents(e);e.nodeType!=Node.TEXT_NODE&&h.length&&!b.node.isDeletable(e)&&b.node.isEditable(e);)e=h[0],h=b.node.contents(e);e.nodeType==Node.TEXT_NODE?(a(e).before(a.FE.MARKERS),e.textContent.length&&55357==e.textContent.charCodeAt(0)?e.textContent=e.textContent.substring(2,e.textContent.length):e.textContent=e.textContent.substring(1,e.textContent.length)):b.node.isDeletable(e)?(a(e).before(a.FE.MARKERS),a(e).remove()):b.events.trigger(\\\"node.remove\\\",[a(e)])!==!1&&(a(e).before(a.FE.MARKERS),a(e).remove()),a(d).remove()}else if(a.FE.NO_DELETE_TAGS.indexOf(e.tagName)<0&&(b.node.isEditable(e)||b.node.isDeletable(e)))if(b.node.isDeletable(e))a(d).replaceWith(a.FE.MARKERS),a(e).remove();else if(b.node.isList(e))d.previousSibling?(a(e).find(\\\"li:first\\\").prepend(d),b.cursorLists._backspace(d)):(a(e).find(\\\"li:first\\\").prepend(a.FE.MARKERS),a(d).remove());else if(h=b.node.contents(e),h&&\\\"BR\\\"==h[0].tagName&&a(h[0]).remove(),h&&\\\"BLOCKQUOTE\\\"==e.tagName){var i=h[0];for(a(d).before(a.FE.MARKERS);i&&\\\"BR\\\"!=i.tagName;){var j=i;i=i.nextSibling,a(d).before(j)}i&&\\\"BR\\\"==i.tagName&&a(i).remove()}else a(d).after(a(e).html()).after(a.FE.MARKERS),a(e).remove()}function m(){var e=b.markers.insert();if(!e)return!1;if(b.el.normalize(),c(e))if(g(e))if(0===a(e).parents(\\\"li:first\\\").find(\\\"ul, ol\\\").length)b.cursorLists._del(e);else{var f=a(e).parents(\\\"li:first\\\").find(\\\"ul:first, ol:first\\\").find(\\\"li:first\\\");f=f.find(b.html.blockTagsQuery()).get(-1)||f,f.prepend(e),b.cursorLists._backspace(e)}else k(e);else l(d(e)?e:e);a(e).remove(),n(),b.html.fillEmptyBlocks(!0),b.opts.htmlUntouched||(b.html.cleanEmptyTags(),b.clean.quotes(),b.clean.lists()),b.spaces.normalizeAroundCursor(),b.selection.restore()}function n(){for(var a=b.el.querySelectorAll(\\\"blockquote:empty\\\"),c=0;c<a.length;c++)a[c].parentNode.removeChild(a[c])}function o(){b.$el.find(\\\".fr-to-remove\\\").each(function(){for(var c=b.node.contents(this),d=0;d<c.length;d++)c[d].nodeType==Node.TEXT_NODE&&(c[d].textContent=c[d].textContent.replace(/\\\\u200B/g,\\\"\\\"));a(this).replaceWith(this.innerHTML)})}function p(c,d,e){var g,h=b.node.deepestParent(c,[],!e);if(h&&\\\"BLOCKQUOTE\\\"==h.tagName)return f(c,h)?(g=b.html.defaultTag(),g?a(h).after(\\\"<\\\"+g+\\\">\\\"+a.FE.MARKERS+\\\"<br></\\\"+g+\\\">\\\"):a(h).after(a.FE.MARKERS+\\\"<br>\\\"),a(c).remove(),!1):(r(c,d,e),!1);if(null==h)g=b.html.defaultTag(),g&&b.node.isElement(c.parentNode)?a(c).replaceWith(\\\"<\\\"+g+\\\">\\\"+a.FE.MARKERS+\\\"<br></\\\"+g+\\\">\\\"):a(c).replaceWith((b.node.isEmpty(c.parentNode,!0)?\\\"\\\":\\\"<br/>\\\")+a.FE.MARKERS+\\\"<br/>\\\");else{var i=c,j=\\\"\\\";b.node.isBlock(h)&&!d||(j=\\\"<br/>\\\");var k=\\\"\\\",l=\\\"\\\";g=b.html.defaultTag();var m=\\\"\\\",n=\\\"\\\";g&&b.node.isBlock(h)&&(m=\\\"<\\\"+g+\\\">\\\",n=\\\"</\\\"+g+\\\">\\\",h.tagName==g.toUpperCase()&&(m=b.node.openTagString(a(h).clone().removeAttr(\\\"id\\\").get(0))));do if(i=i.parentNode,!d||i!=h||d&&!b.node.isBlock(h))if(k+=b.node.closeTagString(i),i==h&&b.node.isBlock(h))l=m+l;else{var o=\\\"A\\\"==i.tagName&&f(c,i)?\\\"fr-to-remove\\\":\\\"\\\";l=b.node.openTagString(a(i).clone().addClass(o).get(0))+l}while(i!=h);j=k+j+l+(c.parentNode==h&&b.node.isBlock(h)?\\\"\\\":a.FE.INVISIBLE_SPACE)+a.FE.MARKERS,b.node.isBlock(h)&&!a(h).find(\\\"*:last\\\").is(\\\"br\\\")&&a(h).append(\\\"<br/>\\\"),a(c).after('<span id=\\\"fr-break\\\"></span>'),a(c).remove(),h.nextSibling&&!b.node.isBlock(h.nextSibling)||b.node.isBlock(h)||a(h).after(\\\"<br>\\\");var p;p=!d&&b.node.isBlock(h)?b.node.openTagString(h)+a(h).html()+n:b.node.openTagString(h)+a(h).html()+b.node.closeTagString(h),p=p.replace(/<span id=\\\"fr-break\\\"><\\\\/span>/g,j),a(h).replaceWith(p)}}function q(c,d,g){var h,i=b.node.deepestParent(c,[],!g);if(i&&\\\"TABLE\\\"==i.tagName)return a(i).find(\\\"td:first, th:first\\\").prepend(c),q(c,d,g);if(i&&\\\"BLOCKQUOTE\\\"==i.tagName){if(e(c,i))return h=b.html.defaultTag(),h?a(i).before(\\\"<\\\"+h+\\\">\\\"+a.FE.MARKERS+\\\"<br></\\\"+h+\\\">\\\"):a(i).before(a.FE.MARKERS+\\\"<br>\\\"),a(c).remove(),!1;f(c,i)?p(c,d,!0):r(c,d,!0)}if(null==i)h=b.html.defaultTag(),h&&b.node.isElement(c.parentNode)?a(c).replaceWith(\\\"<\\\"+h+\\\">\\\"+a.FE.MARKERS+\\\"<br></\\\"+h+\\\">\\\"):a(c).replaceWith(\\\"<br>\\\"+a.FE.MARKERS);else{if(b.node.isBlock(i))if(d)a(c).remove(),a(i).prepend(\\\"<br>\\\"+a.FE.MARKERS);else{if(b.node.isEmpty(i,!0))return p(c,d,g);a(i).before(b.node.openTagString(a(i).clone().removeAttr(\\\"id\\\").get(0))+\\\"<br>\\\"+b.node.closeTagString(i))}else a(i).before(\\\"<br>\\\");a(c).remove()}}function r(c,d,g){var h=b.node.deepestParent(c,[],!g);if(null==h)b.html.defaultTag()&&c.parentNode===b.el?a(c).replaceWith(\\\"<\\\"+b.html.defaultTag()+\\\">\\\"+a.FE.MARKERS+\\\"<br></\\\"+b.html.defaultTag()+\\\">\\\"):(c.nextSibling&&!b.node.isBlock(c.nextSibling)||a(c).after(\\\"<br>\\\"),a(c).replaceWith(\\\"<br>\\\"+a.FE.MARKERS));else{var i=c,j=\\\"\\\";\\\"PRE\\\"==h.tagName&&(d=!0),b.node.isBlock(h)&&!d||(j=\\\"<br>\\\");var k=\\\"\\\",l=\\\"\\\";do{var m=i;if(i=i.parentNode,\\\"BLOCKQUOTE\\\"==h.tagName&&b.node.isEmpty(m)&&!b.node.hasClass(m,\\\"fr-marker\\\")&&a(m).find(c).length>0&&a(m).after(c),(\\\"BLOCKQUOTE\\\"!=h.tagName||!f(c,i)&&!e(c,i))&&(!d||i!=h||d&&!b.node.isBlock(h))){k+=b.node.closeTagString(i);var n=\\\"A\\\"==i.tagName&&f(c,i)?\\\"fr-to-remove\\\":\\\"\\\";l=b.node.openTagString(a(i).clone().addClass(n).removeAttr(\\\"id\\\").get(0))+l}}while(i!=h);var o=h==c.parentNode&&b.node.isBlock(h)||c.nextSibling;if(\\\"BLOCKQUOTE\\\"==h.tagName){c.previousSibling&&b.node.isBlock(c.previousSibling)&&c.nextSibling&&\\\"BR\\\"==c.nextSibling.tagName&&(a(c.nextSibling).after(c),c.nextSibling&&\\\"BR\\\"==c.nextSibling.tagName&&a(c.nextSibling).remove());var p=b.html.defaultTag();j=k+j+(p?\\\"<\\\"+p+\\\">\\\":\\\"\\\")+a.FE.MARKERS+\\\"<br>\\\"+(p?\\\"</\\\"+p+\\\">\\\":\\\"\\\")+l}else j=k+j+l+(o?\\\"\\\":a.FE.INVISIBLE_SPACE)+a.FE.MARKERS;a(c).replaceWith('<span id=\\\"fr-break\\\"></span>');var q=b.node.openTagString(h)+a(h).html()+b.node.closeTagString(h);q=q.replace(/<span id=\\\"fr-break\\\"><\\\\/span>/g,j),a(h).replaceWith(q)}}function s(e){var f=b.markers.insert();if(!f)return!0;b.el.normalize();var h=!1;\\na(f).parentsUntil(b.$el,\\\"BLOCKQUOTE\\\").length>0&&(e=!1,h=!0),a(f).parentsUntil(b.$el,\\\"TD, TH\\\").length&&(h=!1),c(f)?!g(f)||e||h?p(f,e,h):b.cursorLists._endEnter(f):d(f)?!g(f)||e||h?q(f,e,h):b.cursorLists._startEnter(f):!g(f)||e||h?r(f,e,h):b.cursorLists._middleEnter(f),o(),b.opts.htmlUntouched||(b.html.fillEmptyBlocks(!0),b.html.cleanEmptyTags(),b.clean.lists()),b.spaces.normalizeAroundCursor(),b.selection.restore()}return{enter:s,backspace:j,del:m,isAtEnd:f,isAtStart:e}},a.FE.ENTER_P=0,a.FE.ENTER_DIV=1,a.FE.ENTER_BR=2,a.FE.KEYCODE={BACKSPACE:8,TAB:9,ENTER:13,SHIFT:16,CTRL:17,ALT:18,ESC:27,SPACE:32,ARROW_LEFT:37,ARROW_UP:38,ARROW_RIGHT:39,ARROW_DOWN:40,DELETE:46,ZERO:48,ONE:49,TWO:50,THREE:51,FOUR:52,FIVE:53,SIX:54,SEVEN:55,EIGHT:56,NINE:57,FF_SEMICOLON:59,FF_EQUALS:61,QUESTION_MARK:63,A:65,B:66,C:67,D:68,E:69,F:70,G:71,H:72,I:73,J:74,K:75,L:76,M:77,N:78,O:79,P:80,Q:81,R:82,S:83,T:84,U:85,V:86,W:87,X:88,Y:89,Z:90,META:91,NUM_ZERO:96,NUM_ONE:97,NUM_TWO:98,NUM_THREE:99,NUM_FOUR:100,NUM_FIVE:101,NUM_SIX:102,NUM_SEVEN:103,NUM_EIGHT:104,NUM_NINE:105,NUM_MULTIPLY:106,NUM_PLUS:107,NUM_MINUS:109,NUM_PERIOD:110,NUM_DIVISION:111,F1:112,F2:113,F3:114,F4:115,F5:116,F6:117,F7:118,F8:119,F9:120,F10:121,F11:122,F12:123,FF_HYPHEN:173,SEMICOLON:186,DASH:189,EQUALS:187,COMMA:188,HYPHEN:189,PERIOD:190,SLASH:191,APOSTROPHE:192,TILDE:192,SINGLE_QUOTE:222,OPEN_SQUARE_BRACKET:219,BACKSLASH:220,CLOSE_SQUARE_BRACKET:221},a.extend(a.FE.DEFAULTS,{enter:a.FE.ENTER_P,multiLine:!0,tabSpaces:0}),a.FE.MODULES.keys=function(b){function c(a){b.opts.multiLine?b.helpers.isIOS()||(a.preventDefault(),a.stopPropagation(),b.selection.isCollapsed()||b.selection.remove(),b.cursor.enter()):(a.preventDefault(),a.stopPropagation())}function d(a){a.preventDefault(),a.stopPropagation(),b.opts.multiLine&&(b.selection.isCollapsed()||b.selection.remove(),b.cursor.enter(!0))}function e(a){b.selection.isCollapsed()?b.cursor.backspace()||(a.preventDefault(),a.stopPropagation(),z=!1):(a.preventDefault(),a.stopPropagation(),b.selection.remove(),b.html.fillEmptyBlocks(),z=!1),b.placeholder.refresh()}function f(a){a.preventDefault(),a.stopPropagation(),\\\"\\\"===b.selection.text()?b.cursor.del():b.selection.remove(),b.placeholder.refresh()}function g(c){var d=b.selection.element();if(!b.helpers.isMobile()&&(b.browser.mozilla||d&&\\\"A\\\"==d.tagName)){c.preventDefault(),c.stopPropagation(),b.selection.isCollapsed()||b.selection.remove();var e=b.markers.insert();if(e){var f=e.previousSibling,g=e.nextSibling;!g&&e.parentNode&&\\\"A\\\"==e.parentNode.tagName?(e.parentNode.insertAdjacentHTML(\\\"afterend\\\",\\\"&nbsp;\\\"+a.FE.MARKERS),e.parentNode.removeChild(e)):(f&&f.nodeType==Node.TEXT_NODE&&1==f.textContent.length&&160==f.textContent.charCodeAt(0)?f.textContent=f.textContent+\\\" \\\":e.insertAdjacentHTML(\\\"beforebegin\\\",\\\"&nbsp;\\\"),e.outerHTML=a.FE.MARKERS),b.selection.restore()}}}function h(){if(b.browser.mozilla&&b.selection.isCollapsed()&&!C){var a=b.selection.ranges(0),c=a.startContainer,d=a.startOffset;c&&c.nodeType==Node.TEXT_NODE&&d<=c.textContent.length&&d>0&&32==c.textContent.charCodeAt(d-1)&&(b.selection.save(),b.spaces.normalize(),b.selection.restore())}}function i(){b.selection.isFull()&&setTimeout(function(){var c=b.html.defaultTag();c?b.$el.html(\\\"<\\\"+c+\\\">\\\"+a.FE.MARKERS+\\\"<br/></\\\"+c+\\\">\\\"):b.$el.html(a.FE.MARKERS+\\\"<br/>\\\"),b.selection.restore(),b.placeholder.refresh(),b.button.bulkRefresh(),b.undo.saveStep()},0)}function j(a){if(b.opts.tabSpaces>0)if(b.selection.isCollapsed()){b.undo.saveStep(),a.preventDefault(),a.stopPropagation();for(var c=\\\"\\\",d=0;d<b.opts.tabSpaces;d++)c+=\\\"&nbsp;\\\";b.html.insert(c),b.placeholder.refresh(),b.undo.saveStep()}else a.preventDefault(),a.stopPropagation(),a.shiftKey?b.commands.outdent():b.commands.indent()}function k(){C=!1}function l(){return C}function m(h){b.events.disableBlur(),z=!0;var i=h.which;if(16===i)return!0;if(229===i)return C=!0,!0;C=!1;var k=t(i)&&!r(h),l=i==a.FE.KEYCODE.BACKSPACE||i==a.FE.KEYCODE.DELETE;if((b.selection.isFull()&&!b.opts.keepFormatOnDelete&&!b.placeholder.isVisible()||l&&b.placeholder.isVisible()&&b.opts.keepFormatOnDelete)&&(k||l)){var m=b.html.defaultTag();if(m?b.$el.html(\\\"<\\\"+m+\\\">\\\"+a.FE.MARKERS+\\\"<br/></\\\"+m+\\\">\\\"):b.$el.html(a.FE.MARKERS+\\\"<br/>\\\"),b.selection.restore(),!t(i))return h.preventDefault(),!0}i==a.FE.KEYCODE.ENTER?h.shiftKey?d(h):c(h):i!=a.FE.KEYCODE.BACKSPACE||r(h)||h.altKey?i!=a.FE.KEYCODE.DELETE||r(h)||h.altKey?i==a.FE.KEYCODE.SPACE?g(h):i==a.FE.KEYCODE.TAB?j(h):r(h)||!t(h.which)||b.selection.isCollapsed()||h.ctrlKey||b.selection.remove():b.placeholder.isVisible()?(h.preventDefault(),h.stopPropagation()):f(h):b.placeholder.isVisible()?(h.preventDefault(),h.stopPropagation()):e(h),b.events.enableBlur()}function n(a){for(var c=b.doc.createTreeWalker(a,NodeFilter.SHOW_TEXT,b.node.filter(function(a){return/\\\\u200B/gi.test(a.textContent)}),!1);c.nextNode();){var d=c.currentNode;d.textContent=d.textContent.replace(/\\\\u200B/gi,\\\"\\\")}}function o(){if(!b.$wp)return!0;var c;b.opts.height||b.opts.heightMax?(c=b.position.getBoundingRect().top,b.helpers.isIOS()&&(c-=b.helpers.scrollTop()),b.opts.iframe&&(c+=b.$iframe.offset().top),c>b.$wp.offset().top-b.helpers.scrollTop()+b.$wp.height()-20&&b.$wp.scrollTop(c+b.$wp.scrollTop()-(b.$wp.height()+b.$wp.offset().top)+b.helpers.scrollTop()+20)):(c=b.position.getBoundingRect().top,b.opts.toolbarBottom&&(c+=b.opts.toolbarStickyOffset),b.helpers.isIOS()&&(c-=b.helpers.scrollTop()),b.opts.iframe&&(c+=b.$iframe.offset().top,c-=b.helpers.scrollTop()),c+=b.opts.toolbarStickyOffset,c>b.o_win.innerHeight-20&&a(b.o_win).scrollTop(c+b.helpers.scrollTop()-b.o_win.innerHeight+20),c=b.position.getBoundingRect().top,b.opts.toolbarBottom||(c-=b.opts.toolbarStickyOffset),b.helpers.isIOS()&&(c-=b.helpers.scrollTop()),b.opts.iframe&&(c+=b.$iframe.offset().top,c-=b.helpers.scrollTop()),c<b.$tb.height()+20&&a(b.o_win).scrollTop(c+b.helpers.scrollTop()-b.$tb.height()-20))}function p(){var c=b.selection.element(),d=b.node.blockParent(c);if(d&&\\\"DIV\\\"==d.tagName&&b.selection.info(d).atStart){var e=b.html.defaultTag();d.previousSibling&&\\\"DIV\\\"!=d.previousSibling.tagName&&e&&\\\"div\\\"!=e&&(b.selection.save(),a(d).replaceWith(\\\"<\\\"+e+\\\">\\\"+d.innerHTML+\\\"</\\\"+e+\\\">\\\"),b.selection.restore())}}function q(c){if(b.helpers.isAndroid&&b.browser.mozilla)return!0;if(C)return C=!1,!1;if(!b.selection.isCollapsed())return!0;if(c&&(c.which===a.FE.KEYCODE.META||c.which==a.FE.KEYCODE.CTRL))return!0;if(c&&s(c.which))return!0;c&&c.which==a.FE.KEYCODE.ENTER&&b.helpers.isIOS()&&p(),c&&(c.which==a.FE.KEYCODE.ENTER||c.which==a.FE.KEYCODE.BACKSPACE||c.which>=37&&c.which<=40&&!b.browser.msie)&&(c.which==a.FE.KEYCODE.BACKSPACE&&z||o()),b.html.cleanBRs(!0,!0);var d=function(a){if(!a)return!1;var b=a.innerHTML;return b=b.replace(/<span[^>]*? class\\\\s*=\\\\s*[\\\"']?fr-marker[\\\"']?[^>]+>\\\\u200b<\\\\/span>/gi,\\\"\\\"),!!(b&&/\\\\u200B/.test(b)&&b.replace(/\\\\u200B/gi,\\\"\\\").length>0)},e=function(a){var c=/[\\\\u3041-\\\\u3096\\\\u30A0-\\\\u30FF\\\\u4E00-\\\\u9FFF\\\\u3130-\\\\u318F\\\\uAC00-\\\\uD7AF]/gi;return!b.helpers.isIOS()||0===((a.textContent||\\\"\\\").match(c)||[]).length},f=b.selection.element();d(f)&&!b.node.hasClass(f,\\\"fr-marker\\\")&&\\\"IFRAME\\\"!=f.tagName&&e(f)&&(b.selection.save(),n(f),b.selection.restore())}function r(a){if(navigator.userAgent.indexOf(\\\"Mac OS X\\\")!=-1){if(a.metaKey&&!a.altKey)return!0}else if(a.ctrlKey&&!a.altKey)return!0;return!1}function s(b){if(b>=a.FE.KEYCODE.ARROW_LEFT&&b<=a.FE.KEYCODE.ARROW_DOWN)return!0}function t(c){if(c>=a.FE.KEYCODE.ZERO&&c<=a.FE.KEYCODE.NINE)return!0;if(c>=a.FE.KEYCODE.NUM_ZERO&&c<=a.FE.KEYCODE.NUM_MULTIPLY)return!0;if(c>=a.FE.KEYCODE.A&&c<=a.FE.KEYCODE.Z)return!0;if(b.browser.webkit&&0===c)return!0;switch(c){case a.FE.KEYCODE.SPACE:case a.FE.KEYCODE.QUESTION_MARK:case a.FE.KEYCODE.NUM_PLUS:case a.FE.KEYCODE.NUM_MINUS:case a.FE.KEYCODE.NUM_PERIOD:case a.FE.KEYCODE.NUM_DIVISION:case a.FE.KEYCODE.SEMICOLON:case a.FE.KEYCODE.FF_SEMICOLON:case a.FE.KEYCODE.DASH:case a.FE.KEYCODE.EQUALS:case a.FE.KEYCODE.FF_EQUALS:case a.FE.KEYCODE.COMMA:case a.FE.KEYCODE.PERIOD:case a.FE.KEYCODE.SLASH:case a.FE.KEYCODE.APOSTROPHE:case a.FE.KEYCODE.SINGLE_QUOTE:case a.FE.KEYCODE.OPEN_SQUARE_BRACKET:case a.FE.KEYCODE.BACKSLASH:case a.FE.KEYCODE.CLOSE_SQUARE_BRACKET:return!0;default:return!1}}function u(c){var d=c.which;return!!(r(c)||d>=37&&d<=40||!t(d)&&d!=a.FE.KEYCODE.DELETE&&d!=a.FE.KEYCODE.BACKSPACE&&d!=a.FE.KEYCODE.ENTER)||(A||(B=b.snapshot.get(),b.undo.canDo()||b.undo.saveStep()),clearTimeout(A),void(A=setTimeout(function(){A=null,b.undo.saveStep()},Math.max(250,b.opts.typingTimer))))}function v(a){var c=a.which;return!!(r(a)||c>=37&&c<=40)||void(B&&A&&(b.undo.saveStep(B),B=null))}function w(){A&&(clearTimeout(A),b.undo.saveStep(),B=null)}function x(b){var c=b.which;return r(b)||c==a.FE.KEYCODE.F5}function y(){if(b.events.on(\\\"keydown\\\",u),b.events.on(\\\"input\\\",h),b.events.on(\\\"keyup input\\\",v),b.events.on(\\\"keypress\\\",k),b.events.on(\\\"keydown\\\",m),b.events.on(\\\"keyup\\\",q),b.events.on(\\\"html.inserted\\\",q),b.events.on(\\\"cut\\\",i),!b.browser.edge&&b.el.msGetInputContext)try{b.el.msGetInputContext().addEventListener(\\\"MSCandidateWindowShow\\\",function(){C=!0}),b.el.msGetInputContext().addEventListener(\\\"MSCandidateWindowHide\\\",function(){C=!1,q()})}catch(a){}}var z,A,B,C=!1;return{_init:y,ctrlKey:r,isCharacter:t,isArrow:s,forceUndo:w,isIME:l,isBrowserAction:x}},a.FE.MODULES.accessibility=function(b){function c(a){if(a&&a.length){a.data(\\\"blur-event-set\\\")||a.parents(\\\".fr-popup\\\").length||(b.events.$on(a,\\\"blur\\\",function(){var c=a.parents(\\\".fr-toolbar, .fr-popup\\\").data(\\\"instance\\\")||b;c.events.blurActive()&&c.events.trigger(\\\"blur\\\"),c.events.enableBlur()},!0),a.data(\\\"blur-event-set\\\",!0));var c=a.parents(\\\".fr-toolbar, .fr-popup\\\").data(\\\"instance\\\")||b;c.events.disableBlur(),a.focus(),b.shared.$f_el=a}}function d(a,b){var d=b?\\\"last\\\":\\\"first\\\",e=a.find(\\\"button:visible:not(.fr-disabled), .fr-group span.fr-command:visible\\\")[d]();if(e.length)return c(e),!0}function e(a){return a.is(\\\"input, textarea\\\")&&g(),b.events.disableBlur(),a.focus(),!0}function f(a,c){var d=a.find(\\\"input, textarea, button, select\\\").filter(\\\":visible\\\").not(\\\":disabled\\\").filter(c?\\\":last\\\":\\\":first\\\");if(d.length)return e(d);if(b.shared.with_kb){var f=a.find(\\\".fr-active-item:visible:first\\\");if(f.length)return e(f);var g=a.find(\\\"[tabIndex]:visible:first\\\");if(g.length)return e(g)}}function g(){0===b.$el.find(\\\".fr-marker\\\").length&&b.core.hasFocus()&&b.selection.save()}function h(a){a.$el.find(\\\".fr-marker\\\").length&&(a.events.disableBlur(),a.selection.restore(),a.events.enableBlur())}function i(a){var c=a.children().not(\\\".fr-buttons\\\");c.data(\\\"mouseenter-event-set\\\")||(b.events.$on(c,\\\"mouseenter\\\",\\\"[tabIndex]\\\",function(d){var e=a.data(\\\"instance\\\")||b;if(!F)return d.stopPropagation(),void d.preventDefault();var f=c.find(\\\":focus:first\\\");f.length&&!f.is(\\\"input, button, textarea\\\")&&(e.events.disableBlur(),f.blur(),e.events.disableBlur(),e.events.focus())}),c.data(\\\"mouseenter-event-set\\\",!0)),!f(c)&&b.shared.with_kb&&d(a.find(\\\".fr-buttons\\\"))}function j(a){b.core.hasFocus()||(b.events.disableBlur(),b.events.focus()),b.accessibility.saveSelection(),b.events.disableBlur(),b.$el.blur(),b.selection.clear(),b.events.disableBlur(),b.shared.with_kb?a.find(\\\".fr-command[tabIndex], [tabIndex]\\\").first().focus():a.find(\\\"[tabIndex]:first\\\").focus()}function k(){var a=b.popups.areVisible();if(a){var c=a.find(\\\".fr-buttons\\\");return c.find(\\\"button:focus, .fr-group span:focus\\\").length?!d(a.data(\\\"instance\\\").$tb):!d(c)}return!d(b.$tb)}function l(){var a=null;return b.shared.$f_el.is(\\\".fr-dropdown.fr-active\\\")?a=b.shared.$f_el:b.shared.$f_el.closest(\\\".fr-dropdown-menu\\\").prev().is(\\\".fr-dropdown.fr-active\\\")&&(a=b.shared.$f_el.closest(\\\".fr-dropdown-menu\\\").prev()),a}function m(e,g,h){if(b.shared.$f_el){var i=l();i&&(b.button.click(i),b.shared.$f_el=i);var j=e.find(\\\"button:visible:not(.fr-disabled), .fr-group span.fr-command:visible\\\"),k=j.index(b.shared.$f_el);if(0===k&&!h||k==j.length-1&&h){var m;if(g){if(e.parent().is(\\\".fr-popup\\\")){var n=e.parent().children().not(\\\".fr-buttons\\\");m=!f(n,!h)}m===!1&&(b.shared.$f_el=null)}g&&m===!1||d(e,!h)}else c(a(j.get(k+(h?1:-1))));return!1}}function n(a,b){return m(a,b,!0)}function o(a,b){return m(a,b)}function p(a){if(b.shared.$f_el){var d;if(b.shared.$f_el.is(\\\".fr-dropdown.fr-active\\\"))return d=a?b.shared.$f_el.next().find(\\\".fr-command:not(.fr-disabled)\\\").first():b.shared.$f_el.next().find(\\\".fr-command:not(.fr-disabled)\\\").last(),c(d),!1;if(b.shared.$f_el.is(\\\"a.fr-command\\\"))return d=a?b.shared.$f_el.closest(\\\"li\\\").nextAll(\\\":visible:first\\\").find(\\\".fr-command:not(.fr-disabled)\\\").first():b.shared.$f_el.closest(\\\"li\\\").prevAll(\\\":visible:first\\\").find(\\\".fr-command:not(.fr-disabled)\\\").first(),d.length||(d=a?b.shared.$f_el.closest(\\\".fr-dropdown-menu\\\").find(\\\".fr-command:not(.fr-disabled)\\\").first():b.shared.$f_el.closest(\\\".fr-dropdown-menu\\\").find(\\\".fr-command:not(.fr-disabled)\\\").last()),c(d),!1}}function q(){return b.shared.$f_el&&b.shared.$f_el.is(\\\".fr-dropdown:not(.fr-active)\\\")?s():p(!0)}function r(){return p()}function s(){if(b.shared.$f_el){if(b.shared.$f_el.hasClass(\\\"fr-dropdown\\\"))b.button.click(b.shared.$f_el);else if(b.shared.$f_el.is(\\\"button.fr-back\\\")){b.opts.toolbarInline&&(b.events.disableBlur(),b.events.focus());var a=b.popups.areVisible(b);a&&(b.shared.with_kb=!1),b.button.click(b.shared.$f_el),z(a)}else{if(b.events.disableBlur(),b.button.click(b.shared.$f_el),b.shared.$f_el.attr(\\\"data-popup\\\")){var c=b.popups.areVisible(b);c&&c.data(\\\"popup-button\\\",b.shared.$f_el)}else if(b.shared.$f_el.attr(\\\"data-modal\\\")){var d=b.modals.areVisible(b);d&&d.data(\\\"modal-button\\\",b.shared.$f_el)}b.shared.$f_el=null}return!1}}function t(){b.shared.$f_el&&(b.events.disableBlur(),b.shared.$f_el.blur(),b.shared.$f_el=null),b.events.trigger(\\\"toolbar.focusEditor\\\")!==!1&&(b.events.disableBlur(),b.events.focus())}function u(a){if(b.shared.$f_el){var d=l();return d?(b.button.click(d),c(d)):a.parent().find(\\\".fr-back:visible\\\").length?(b.shared.with_kb=!1,b.opts.toolbarInline&&(b.events.disableBlur(),b.events.focus()),b.button.exec(a.parent().find(\\\".fr-back:visible:first\\\")),z(a.parent())):b.shared.$f_el.is(\\\"button, .fr-group span\\\")&&(a.parent().is(\\\".fr-popup\\\")?(h(b),b.shared.$f_el=null,b.events.trigger(\\\"toolbar.esc\\\")!==!1&&(b.popups.hide(a.parent()),b.opts.toolbarInline&&b.toolbar.showInline(null,!0),z(a.parent()))):t()),!1}}function v(c,d){var e=navigator.userAgent.indexOf(\\\"Mac OS X\\\")!=-1?c.metaKey:c.ctrlKey,f=c.which,g=!1;return f!=a.FE.KEYCODE.TAB||e||c.shiftKey||c.altKey?f!=a.FE.KEYCODE.ARROW_RIGHT||e||c.shiftKey||c.altKey?f!=a.FE.KEYCODE.TAB||e||!c.shiftKey||c.altKey?f!=a.FE.KEYCODE.ARROW_LEFT||e||c.shiftKey||c.altKey?f!=a.FE.KEYCODE.ARROW_UP||e||c.shiftKey||c.altKey?f!=a.FE.KEYCODE.ARROW_DOWN||e||c.shiftKey||c.altKey?f!=a.FE.KEYCODE.ENTER||e||c.shiftKey||c.altKey?f!=a.FE.KEYCODE.ESC||e||c.shiftKey||c.altKey?f!=a.FE.KEYCODE.F10||e||c.shiftKey||!c.altKey||(g=k()):g=u(d):g=s():g=q():g=r():g=o(d):g=o(d,!0):g=n(d):g=n(d,!0),b.shared.$f_el||void 0!==g||(g=!0),!g&&b.keys.isBrowserAction(c)&&(g=!0),!!g||(c.preventDefault(),c.stopPropagation(),!1)}function w(c){c&&c.length&&(b.events.$on(c,\\\"keydown\\\",function(d){if(!a(d.target).is(\\\"a.fr-command, button.fr-command, .fr-group span.fr-command\\\"))return!0;var e=c.parents(\\\".fr-popup\\\").data(\\\"instance\\\")||c.data(\\\"instance\\\")||b;b.shared.with_kb=!0;var f=e.accessibility.exec(d,c);return b.shared.with_kb=!1,f},!0),b.events.$on(c,\\\"mouseenter\\\",\\\"[tabIndex]\\\",function(d){var e=c.parents(\\\".fr-popup\\\").data(\\\"instance\\\")||c.data(\\\"instance\\\")||b;if(!F)return d.stopPropagation(),void d.preventDefault();var f=a(d.currentTarget);e.shared.$f_el&&e.shared.$f_el.not(f)&&e.accessibility.focusEditor()},!0))}function x(a){var c=b.popups.get(a),d=y(a);w(c.find(\\\".fr-buttons\\\")),b.events.$on(c,\\\"mouseenter\\\",\\\"tabIndex\\\",d._tiMouseenter,!0),b.events.$on(c.children().not(\\\".fr-buttons\\\"),\\\"keydown\\\",\\\"[tabIndex]\\\",d._tiKeydown,!0),b.popups.onHide(a,function(){h(c.data(\\\"instance\\\")||b)}),b.popups.onShow(a,function(){F=!1,setTimeout(function(){F=!0},0)})}function y(c){var e=b.popups.get(c);return{_tiKeydown:function(g){var i=e.data(\\\"instance\\\")||b;if(i.events.trigger(\\\"popup.tab\\\",[g])===!1)return!1;var j=g.which,k=e.find(\\\":focus:first\\\");if(a.FE.KEYCODE.TAB==j){g.preventDefault();var l=e.children().not(\\\".fr-buttons\\\"),m=l.find(\\\"input, textarea, button, select\\\").filter(\\\":visible\\\").not(\\\".fr-no-touch input, .fr-no-touch textarea, .fr-no-touch button, .fr-no-touch select, :disabled\\\").toArray(),n=m.indexOf(this)+(g.shiftKey?-1:1);if(0<=n&&n<m.length)return i.events.disableBlur(),a(m[n]).focus(),g.stopPropagation(),!1;var o=e.find(\\\".fr-buttons\\\");if(o.length&&d(o,!!g.shiftKey))return g.stopPropagation(),!1;if(f(l))return g.stopPropagation(),!1}else{if(a.FE.KEYCODE.ENTER!=j)return a.FE.KEYCODE.ESC==j?(g.preventDefault(),g.stopPropagation(),h(i),i.popups.isVisible(c)&&e.find(\\\".fr-back:visible\\\").length?(i.opts.toolbarInline&&(i.events.disableBlur(),i.events.focus()),i.button.exec(e.find(\\\".fr-back:visible:first\\\")),z(e)):i.popups.isVisible(c)&&e.find(\\\".fr-dismiss:visible\\\").length?i.button.exec(e.find(\\\".fr-dismiss:visible:first\\\")):(i.popups.hide(c),i.opts.toolbarInline&&i.toolbar.showInline(null,!0),z(e)),!1):a.FE.KEYCODE.SPACE==j&&(k.is(\\\".fr-submit\\\")||k.is(\\\".fr-dismiss\\\"))?(g.preventDefault(),g.stopPropagation(),i.events.disableBlur(),i.button.exec(k),!0):i.keys.isBrowserAction(g)?void g.stopPropagation():k.is(\\\"input[type=text], textarea\\\")?void g.stopPropagation():a.FE.KEYCODE.SPACE==j&&(k.is(\\\".fr-link-attr\\\")||k.is(\\\"input[type=file]\\\"))?void g.stopPropagation():(g.stopPropagation(),g.preventDefault(),!1);var p=null;e.find(\\\".fr-submit:visible\\\").length>0?p=e.find(\\\".fr-submit:visible:first\\\"):e.find(\\\".fr-dismiss:visible\\\").length&&(p=e.find(\\\".fr-dismiss:visible:first\\\")),p&&(g.preventDefault(),g.stopPropagation(),i.events.disableBlur(),i.button.exec(p))}},_tiMouseenter:function(){var a=e.data(\\\"instance\\\")||b;C(a)}}}function z(a){var b=a.data(\\\"popup-button\\\");b&&setTimeout(function(){c(b),a.data(\\\"popup-button\\\",null)},0)}function A(a){var b=a.data(\\\"modal-button\\\");b&&setTimeout(function(){c(b),a.data(\\\"modal-button\\\",null)},0)}function B(){return null!=b.shared.$f_el}function C(a){var c=b.popups.areVisible(a);c&&c.data(\\\"popup-button\\\",null)}function D(c){var d=navigator.userAgent.indexOf(\\\"Mac OS X\\\")!=-1?c.metaKey:c.ctrlKey,e=c.which;if(e==a.FE.KEYCODE.F10&&!d&&!c.shiftKey&&c.altKey){b.shared.with_kb=!0;var g=b.popups.areVisible(b),h=!1;return g&&(h=f(g.children().not(\\\".fr-buttons\\\"))),h||k(),b.shared.with_kb=!1,c.preventDefault(),c.stopPropagation(),!1}return!0}function E(){b.$wp?b.events.on(\\\"keydown\\\",D,!0):b.events.$on(b.$win,\\\"keydown\\\",D,!0),b.events.on(\\\"mousedown\\\",function(a){C(b),b.shared.$f_el&&(h(b),a.stopPropagation(),b.events.disableBlur(),b.shared.$f_el=null)},!0),b.events.on(\\\"blur\\\",function(){b.shared.$f_el=null,C(b)},!0)}var F=!0;return{_init:E,registerPopup:x,registerToolbar:w,focusToolbarElement:c,focusToolbar:d,focusContent:f,focusPopup:i,focusModal:j,focusEditor:t,focusPopupButton:z,focusModalButton:A,hasFocus:B,exec:v,saveSelection:g,restoreSelection:h}},a.FE.MODULES.format=function(b){function c(a,b){var c=\\\"<\\\"+a;for(var d in b)b.hasOwnProperty(d)&&(c+=\\\" \\\"+d+'=\\\"'+b[d]+'\\\"');return c+=\\\">\\\"}function d(a){return\\\"</\\\"+a+\\\">\\\"}function e(a,b){var c=a;for(var d in b)b.hasOwnProperty(d)&&(c+=\\\"id\\\"==d?\\\"#\\\"+b[d]:\\\"class\\\"==d?\\\".\\\"+b[d]:\\\"[\\\"+d+'=\\\"'+b[d]+'\\\"]');return c}function f(a,b){return!(!a||a.nodeType!=Node.ELEMENT_NODE)&&(a.matches||a.matchesSelector||a.msMatchesSelector||a.mozMatchesSelector||a.webkitMatchesSelector||a.oMatchesSelector).call(a,b)}function g(d,e,f){if(d){if(b.node.isBlock(d))return g(d.firstChild,e,f),!1;for(var h=a(c(e,f)).insertBefore(d),i=d;i&&!a(i).is(\\\".fr-marker\\\")&&0===a(i).find(\\\".fr-marker\\\").length;){var j=i;i=i.nextSibling,h.append(j)}if(i)a(i).find(\\\".fr-marker\\\").length&&g(i.firstChild,e,f);else{for(var k=h.get(0).parentNode;k&&!k.nextSibling&&!b.node.isElement(k);)k=k.parentNode;if(k){var l=k.nextSibling;l&&(b.node.isBlock(l)?g(l.firstChild,e,f):g(l,e,f))}}h.is(\\\":empty\\\")&&h.remove()}}function h(h,i){var j;if(\\\"undefined\\\"==typeof i&&(i={}),i.style&&delete i.style,b.selection.isCollapsed()){b.markers.insert();var k=b.$el.find(\\\".fr-marker\\\");k.replaceWith(c(h,i)+a.FE.INVISIBLE_SPACE+a.FE.MARKERS+d(h)),b.selection.restore()}else{b.selection.save();var l=b.$el.find('.fr-marker[data-type=\\\"true\\\"]').get(0).nextSibling;g(l,h,i);var m;do for(m=b.$el.find(e(h,i)+\\\" > \\\"+e(h,i)),j=0;j<m.length;j++)m[j].outerHTML=m[j].innerHTML;while(m.length);b.el.normalize();var n=b.el.querySelectorAll(\\\".fr-marker\\\");for(j=0;j<n.length;j++){var o=a(n[j]);o.data(\\\"type\\\")===!0?f(o.get(0).nextSibling,e(h,i))&&o.next().prepend(o):f(o.get(0).previousSibling,e(h,i))&&o.prev().append(o)}b.selection.restore()}}function i(a,c,d,g){if(!g){var h=!1;if(a.data(\\\"type\\\")===!0)for(;b.node.isFirstSibling(a.get(0))&&!a.parent().is(b.$el)&&!a.parent().is(\\\"ol\\\")&&!a.parent().is(\\\"ul\\\");)a.parent().before(a),h=!0;else if(a.data(\\\"type\\\")===!1)for(;b.node.isLastSibling(a.get(0))&&!a.parent().is(b.$el)&&!a.parent().is(\\\"ol\\\")&&!a.parent().is(\\\"ul\\\");)a.parent().after(a),h=!0;if(h)return!0}if(a.parents(c).length||\\\"undefined\\\"==typeof c){var i=\\\"\\\",j=\\\"\\\",k=a.parent();if(k.is(b.$el)||b.node.isBlock(k.get(0)))return!1;for(;\\\"undefined\\\"==typeof c&&!b.node.isBlock(k.parent().get(0))||\\\"undefined\\\"!=typeof c&&!f(k.get(0),e(c,d));)i+=b.node.closeTagString(k.get(0)),j=b.node.openTagString(k.get(0))+j,k=k.parent();var l=a.get(0).outerHTML;a.replaceWith('<span id=\\\"mark\\\"></span>');var m=k.html().replace(/<span id=\\\"mark\\\"><\\\\/span>/,i+b.node.closeTagString(k.get(0))+j+l+i+b.node.openTagString(k.get(0))+j);return k.replaceWith(b.node.openTagString(k.get(0))+m+b.node.closeTagString(k.get(0))),!0}return!1}function j(c,d,g,h){for(var i=b.node.contents(c.get(0)),k=0;k<i.length;k++){var l=i[k];if(b.node.hasClass(l,\\\"fr-marker\\\"))d=(d+1)%2;else if(d)if(a(l).find(\\\".fr-marker\\\").length>0)d=j(a(l),d,g,h);else{for(var m=a(l).find(g||\\\"*\\\"),n=m.length-1;n>=0;n--){var o=m[n];b.node.isBlock(o)||b.node.isVoid(o)||!f(o,e(g,h))||(o.outerHTML=o.innerHTML)}\\\"undefined\\\"==typeof g&&l.nodeType==Node.ELEMENT_NODE&&!b.node.isVoid(l)&&!b.node.isBlock(l)||f(l,e(g,h))?a(l).replaceWith(l.innerHTML):\\\"undefined\\\"==typeof g&&l.nodeType==Node.ELEMENT_NODE&&b.node.isBlock(l)&&b.node.clearAttributes(l)}else a(l).find(\\\".fr-marker\\\").length>0&&(d=j(a(l),d,g,h))}return d}function k(c,d){\\\"undefined\\\"==typeof d&&(d={}),d.style&&delete d.style;var e=b.selection.isCollapsed();b.selection.save();for(var f=!0;f;){f=!1;for(var g=b.$el.find(\\\".fr-marker\\\"),h=0;h<g.length;h++)if(i(a(g[h]),c,d,e)){f=!0;break}}j(b.$el,0,c,d),e&&b.$el.find(\\\".fr-marker\\\").before(a.FE.INVISIBLE_SPACE).after(a.FE.INVISIBLE_SPACE),b.html.cleanEmptyTags(),b.el.normalize(),b.selection.restore()}function l(a,b){q(a,b)?k(a,b):h(a,b)}function m(b,c){var d=a(b);d.css(c,\\\"\\\"),\\\"\\\"===d.attr(\\\"style\\\")&&d.replaceWith(d.html())}function n(b,c){return 0===a(b).attr(\\\"style\\\").indexOf(c+\\\":\\\")||a(b).attr(\\\"style\\\").indexOf(\\\";\\\"+c+\\\":\\\")>=0||a(b).attr(\\\"style\\\").indexOf(\\\"; \\\"+c+\\\":\\\")>=0}function o(c,d){var e,f;if(b.selection.isCollapsed()){b.markers.insert(),f=b.$el.find(\\\".fr-marker\\\");var h=f.parent();if(b.node.openTagString(h.get(0))=='<span style=\\\"'+c+\\\": \\\"+h.css(c)+';\\\">')if(b.node.isEmpty(h.get(0)))h.replaceWith('<span style=\\\"'+c+\\\": \\\"+d+';\\\">'+a.FE.INVISIBLE_SPACE+a.FE.MARKERS+\\\"</span>\\\");else{var j={};j[c]=d,i(f,\\\"span\\\",j,!0),f=b.$el.find(\\\".fr-marker\\\"),f.replaceWith('<span style=\\\"'+c+\\\": \\\"+d+';\\\">'+a.FE.INVISIBLE_SPACE+a.FE.MARKERS+\\\"</span>\\\")}else b.node.isEmpty(h.get(0))&&h.is(\\\"span\\\")?(f.replaceWith(a.FE.MARKERS),h.css(c,d)):f.replaceWith('<span style=\\\"'+c+\\\": \\\"+d+';\\\">'+a.FE.INVISIBLE_SPACE+a.FE.MARKERS+\\\"</span>\\\");b.selection.restore()}else{if(b.selection.save(),null==d||\\\"color\\\"==c&&b.$el.find(\\\".fr-marker\\\").parents(\\\"u, a\\\").length>0){var k=b.$el.find(\\\".fr-marker\\\");for(e=0;e<k.length;e++)if(f=a(k[e]),f.data(\\\"type\\\")===!0)for(;b.node.isFirstSibling(f.get(0))&&!f.parent().is(b.$el)&&!b.node.isElement(f.parent().get(0))&&!b.node.isBlock(f.parent().get(0));)f.parent().before(f);else for(;b.node.isLastSibling(f.get(0))&&!f.parent().is(b.$el)&&!b.node.isElement(f.parent().get(0))&&!b.node.isBlock(f.parent().get(0));)f.parent().after(f)}var l=b.$el.find('.fr-marker[data-type=\\\"true\\\"]').get(0).nextSibling,o={class:\\\"fr-unprocessed\\\"};for(d&&(o.style=c+\\\": \\\"+d+\\\";\\\"),g(l,\\\"span\\\",o),b.$el.find(\\\".fr-marker + .fr-unprocessed\\\").each(function(){a(this).prepend(a(this).prev())}),b.$el.find(\\\".fr-unprocessed + .fr-marker\\\").each(function(){a(this).prev().append(this)});b.$el.find(\\\"span.fr-unprocessed\\\").length>0;){var p=b.$el.find(\\\"span.fr-unprocessed:first\\\").removeClass(\\\"fr-unprocessed\\\");if(p.parent().get(0).normalize(),p.parent().is(\\\"span\\\")&&1==p.parent().get(0).childNodes.length){p.parent().css(c,d);var q=p;p=p.parent(),q.replaceWith(q.html())}var r=p.find(\\\"span\\\");for(e=r.length-1;e>=0;e--)m(r[e],c);var s=p.parentsUntil(b.$el,\\\"span[style]\\\"),t=[];for(e=s.length-1;e>=0;e--)n(s[e],c)||t.push(s[e]);if(s=s.not(t),s.length){var u=\\\"\\\",v=\\\"\\\",w=\\\"\\\",x=\\\"\\\",y=p.get(0);do y=y.parentNode,a(y).addClass(\\\"fr-split\\\"),u+=b.node.closeTagString(y),v=b.node.openTagString(a(y).clone().addClass(\\\"fr-split\\\").get(0))+v,s.get(0)!=y&&(w+=b.node.closeTagString(y),x=b.node.openTagString(a(y).clone().addClass(\\\"fr-split\\\").get(0))+x);while(s.get(0)!=y);var z=u+b.node.openTagString(a(s.get(0)).clone().css(c,d||\\\"\\\").get(0))+x+p.css(c,\\\"\\\").get(0).outerHTML+w+\\\"</span>\\\"+v;p.replaceWith('<span id=\\\"fr-break\\\"></span>');var A=s.get(0).outerHTML;a(s.get(0)).replaceWith(A.replace(/<span id=\\\"fr-break\\\"><\\\\/span>/g,z))}}for(;b.$el.find(\\\".fr-split:empty\\\").length>0;)b.$el.find(\\\".fr-split:empty\\\").remove();b.$el.find(\\\".fr-split\\\").removeClass(\\\"fr-split\\\"),b.$el.find('span[style=\\\"\\\"]').removeAttr(\\\"style\\\"),b.$el.find('span[class=\\\"\\\"]').removeAttr(\\\"class\\\"),b.html.cleanEmptyTags(),a(b.$el.find(\\\"span\\\").get().reverse()).each(function(){this.attributes&&0!==this.attributes.length||a(this).replaceWith(this.innerHTML)}),b.el.normalize();var B=b.$el.find(\\\"span[style] + span[style]\\\");for(e=0;e<B.length;e++){var C=a(B[e]),D=a(B[e]).prev();C.get(0).previousSibling==D.get(0)&&b.node.openTagString(C.get(0))==b.node.openTagString(D.get(0))&&(C.prepend(D.html()),D.remove())}b.$el.find(\\\"span[style] span[style]\\\").each(function(){if(a(this).attr(\\\"style\\\").indexOf(\\\"font-size\\\")>=0){var b=a(this).parents(\\\"span[style]\\\");b.attr(\\\"style\\\").indexOf(\\\"background-color\\\")>=0&&(a(this).attr(\\\"style\\\",a(this).attr(\\\"style\\\")+\\\";\\\"+b.attr(\\\"style\\\")),i(a(this),\\\"span[style]\\\",{},!1))}}),b.el.normalize(),b.selection.restore()}}function p(a){o(a,null)}function q(a,c){\\\"undefined\\\"==typeof c&&(c={}),c.style&&delete c.style;var d=b.selection.ranges(0),g=d.startContainer;g.nodeType==Node.ELEMENT_NODE&&g.childNodes.length>0&&g.childNodes[d.startOffset]&&(g=g.childNodes[d.startOffset]);for(var h=g;h&&h.nodeType==Node.ELEMENT_NODE&&!f(h,e(a,c));)h=h.firstChild;if(h&&h.nodeType==Node.ELEMENT_NODE&&f(h,e(a,c)))return!0;var i=g;for(i&&i.nodeType!=Node.ELEMENT_NODE&&(i=i.parentNode);i&&i.nodeType==Node.ELEMENT_NODE&&i!=b.el&&!f(i,e(a,c));)i=i.parentNode;return!(!i||i.nodeType!=Node.ELEMENT_NODE||i==b.el||!f(i,e(a,c)))}return{is:q,toggle:l,apply:h,remove:k,applyStyle:o,removeStyle:p}},a.FE.COMMANDS={bold:{title:\\\"Bold\\\",toggle:!0,refresh:function(a){var b=this.format.is(\\\"strong\\\");a.toggleClass(\\\"fr-active\\\",b).attr(\\\"aria-pressed\\\",b)}},italic:{title:\\\"Italic\\\",toggle:!0,refresh:function(a){var b=this.format.is(\\\"em\\\");a.toggleClass(\\\"fr-active\\\",b).attr(\\\"aria-pressed\\\",b)}},underline:{title:\\\"Underline\\\",toggle:!0,refresh:function(a){var b=this.format.is(\\\"u\\\");a.toggleClass(\\\"fr-active\\\",b).attr(\\\"aria-pressed\\\",b)}},strikeThrough:{title:\\\"Strikethrough\\\",toggle:!0,refresh:function(a){var b=this.format.is(\\\"s\\\");a.toggleClass(\\\"fr-active\\\",b).attr(\\\"aria-pressed\\\",b)}},subscript:{title:\\\"Subscript\\\",toggle:!0,refresh:function(a){var b=this.format.is(\\\"sub\\\");a.toggleClass(\\\"fr-active\\\",b).attr(\\\"aria-pressed\\\",b)}},superscript:{title:\\\"Superscript\\\",toggle:!0,refresh:function(a){var b=this.format.is(\\\"sup\\\");a.toggleClass(\\\"fr-active\\\",b).attr(\\\"aria-pressed\\\",b)}},outdent:{title:\\\"Decrease Indent\\\"},indent:{title:\\\"Increase Indent\\\"},undo:{title:\\\"Undo\\\",undo:!1,forcedRefresh:!0,disabled:!0},redo:{title:\\\"Redo\\\",undo:!1,forcedRefresh:!0,disabled:!0},insertHR:{title:\\\"Insert Horizontal Line\\\"},clearFormatting:{title:\\\"Clear Formatting\\\"},selectAll:{title:\\\"Select All\\\",undo:!1}},a.FE.RegisterCommand=function(b,c){a.FE.COMMANDS[b]=c},a.FE.MODULES.commands=function(b){function c(a){return b.html.defaultTag()&&(a=\\\"<\\\"+b.html.defaultTag()+\\\">\\\"+a+\\\"</\\\"+b.html.defaultTag()+\\\">\\\"),a}function d(c,d){if(b.events.trigger(\\\"commands.before\\\",a.merge([c],d||[]))!==!1){var e=a.FE.COMMANDS[c]&&a.FE.COMMANDS[c].callback||i[c],f=!0,g=!1;a.FE.COMMANDS[c]&&(\\\"undefined\\\"!=typeof a.FE.COMMANDS[c].focus&&(f=a.FE.COMMANDS[c].focus),\\\"undefined\\\"!=typeof a.FE.COMMANDS[c].accessibilityFocus&&(g=a.FE.COMMANDS[c].accessibilityFocus)),(!b.core.hasFocus()&&f&&!b.popups.areVisible()||!b.core.hasFocus()&&g&&b.accessibility.hasFocus())&&b.events.focus(!0),a.FE.COMMANDS[c]&&a.FE.COMMANDS[c].undo!==!1&&(b.$el.find(\\\".fr-marker\\\").length&&(b.events.disableBlur(),b.selection.restore()),b.undo.saveStep()),e&&e.apply(b,a.merge([c],d||[])),b.events.trigger(\\\"commands.after\\\",a.merge([c],d||[])),a.FE.COMMANDS[c]&&a.FE.COMMANDS[c].undo!==!1&&b.undo.saveStep()}}function e(a,c){b.format.toggle(c)}function f(c){b.selection.save(),b.html.wrap(!0,!0,!0,!0),b.selection.restore();for(var d=b.selection.blocks(),e=0;e<d.length;e++)if(\\\"LI\\\"!=d[e].tagName&&\\\"LI\\\"!=d[e].parentNode.tagName){var f=a(d[e]),g=\\\"rtl\\\"==b.opts.direction||\\\"rtl\\\"==f.css(\\\"direction\\\")?\\\"margin-right\\\":\\\"margin-left\\\",h=b.helpers.getPX(f.css(g));f.css(g,Math.max(h+20*c,0)||\\\"\\\"),f.removeClass(\\\"fr-temp-div\\\")}b.selection.save(),b.html.unwrap(),b.selection.restore()}function g(a){return function(){d(a)}}function h(){b.events.on(\\\"keydown\\\",function(a){var c=b.selection.element();if(c&&\\\"HR\\\"==c.tagName&&!b.keys.isArrow(a.which))return a.preventDefault(),!1}),b.events.on(\\\"keyup\\\",function(c){var d=b.selection.element();if(d&&\\\"HR\\\"==d.tagName)if(c.which==a.FE.KEYCODE.ARROW_LEFT||c.which==a.FE.KEYCODE.ARROW_UP){if(d.previousSibling)return b.node.isBlock(d.previousSibling)?b.selection.setAtEnd(d.previousSibling):a(d).before(a.FE.MARKERS),b.selection.restore(),!1}else if((c.which==a.FE.KEYCODE.ARROW_RIGHT||c.which==a.FE.KEYCODE.ARROW_DOWN)&&d.nextSibling)return b.node.isBlock(d.nextSibling)?b.selection.setAtStart(d.nextSibling):a(d).after(a.FE.MARKERS),b.selection.restore(),!1}),b.events.on(\\\"mousedown\\\",function(a){if(a.target&&\\\"HR\\\"==a.target.tagName)return a.preventDefault(),a.stopPropagation(),!1}),b.events.on(\\\"mouseup\\\",function(){var c=b.selection.element(),d=b.selection.endElement();c==d&&c&&\\\"HR\\\"==c.tagName&&(c.nextSibling&&(b.node.isBlock(c.nextSibling)?b.selection.setAtStart(c.nextSibling):a(c).after(a.FE.MARKERS)),b.selection.restore())})}var i={bold:function(){e(\\\"bold\\\",\\\"strong\\\")},subscript:function(){e(\\\"subscript\\\",\\\"sub\\\")},superscript:function(){e(\\\"superscript\\\",\\\"sup\\\")},italic:function(){e(\\\"italic\\\",\\\"em\\\")},strikeThrough:function(){e(\\\"strikeThrough\\\",\\\"s\\\")},underline:function(){e(\\\"underline\\\",\\\"u\\\")},undo:function(){b.undo.run()},redo:function(){b.undo.redo()},indent:function(){f(1)},outdent:function(){f(-1)},show:function(){b.opts.toolbarInline&&b.toolbar.showInline(null,!0)},insertHR:function(){b.selection.remove();var d=\\\"\\\";b.core.isEmpty()&&(d=\\\"<br>\\\",d=c(d)),b.html.insert('<hr id=\\\"fr-just\\\">'+d);var e=b.$el.find(\\\"hr#fr-just\\\");e.removeAttr(\\\"id\\\");var f;e.prev().is(\\\"hr\\\")?f=b.selection.setAfter(e.get(0),!1):e.next().is(\\\"hr\\\")?f=b.selection.setBefore(e.get(0),!1):b.selection.setAfter(e.get(0),!1)||b.selection.setBefore(e.get(0),!1),f||\\\"undefined\\\"==typeof f||(d=a.FE.MARKERS+\\\"<br>\\\",d=c(d),e.after(d)),b.selection.restore()},clearFormatting:function(){b.format.remove()},selectAll:function(){b.doc.execCommand(\\\"selectAll\\\",!1,!1)}},j={};for(var k in i)i.hasOwnProperty(k)&&(j[k]=g(k));return a.extend(j,{exec:d,_init:h})},a.FE.MODULES.data=function(a){function b(a){return a}function c(a){if(!a)return a;for(var c=\\\"\\\",f=b(\\\"charCodeAt\\\"),g=b(\\\"fromCharCode\\\"),h=l.indexOf(a[0]),i=1;i<a.length-2;i++){for(var j=d(++h),k=a[f](i),m=\\\"\\\";/[0-9-]/.test(a[i+1]);)m+=a[++i];m=parseInt(m,10)||0,k=e(k,j,m),k^=h-1&31,c+=String[g](k)}return c}function d(a){\\nfor(var b=a.toString(),c=0,d=0;d<b.length;d++)c+=parseInt(b.charAt(d),10);return c>10?c%9+1:c}function e(a,b,c){for(var d=Math.abs(c);d-- >0;)a-=b;return c<0&&(a+=123),a}function f(a){return!(!a||\\\"none\\\"!=a.css(\\\"display\\\")||(a.remove(),0))}function g(){return f(j)||f(k)}function h(){return!!a.$box&&(a.$box.append(n(b(n(\\\"noLD2laB-7NB1C1ebcvH-9SB3a1C6QC2D4A-9d1E2B2B4xgAE4B2G2I1C3A3B2qMF1DE1fkxfcC-11C-9g1G2E4XC9a1E5A3G-10mvrioCC3AA1KA1qJ-7NB2MA6sxeqVA6TD6e2D4B-9rYA2a1A4bCD3vwC-7EC10D3E2lNC1KD1QB9SB6UE5TE4YF3YA5c1A3d1B3kGE2gFA5A2D2ch1KI1IB1thyH5wvVC11UB6c1F4wwwXA7gmnfB2jgB1A7nd1e1IC2NG4H1A9bjvnbC-8PG3mlazD4dH-9HI2qAA2jGC2IA1dajajFD5SG4J4c1qttyB-9wg1B2b2A6b1C3EG3B2I2rCD4E1B1LG1oaMA3RE7abC-8C-7aVA4C5B5F-11e1D3I3a5A8hmmnogH2IB5A2nhkgiA4TH4VC7yxdblH-8YC6D6C4xC3yqJJ2C-21spB-11fMF1KF1IC2USC4PG4TE3RD6ZF5XE3UE3uefaFE4D2G2AE1HA2JD1zzzQE3SD9vgqF4ua3B13XA4C5gd1E3E2A14ridsldcCA7MC5ghwE-11ZH5f1D3a1D8bwxmkzi1A7IB3KvpB-8rwMD3IE1GG-10bgqwxewvWE4H3VbD-16qC-11qc1E2TwEA6A3aCE4A1A4lOD3JC1iVA3RA13c2D8olqf1G3A32B17==\\\")))),j=a.$box.find(\\\"> div:last\\\"),k=j.find(\\\"> a\\\"),void(\\\"rtl\\\"==a.opts.direction&&j.css(\\\"left\\\",\\\"auto\\\").css(\\\"right\\\",0)))}function i(){var c=localStorage&&localStorage.FEK||a.opts.key||[\\\"\\\"];\\\"string\\\"==typeof c&&(c=[c]),a.ul=!0;for(var d=0;d<c.length;d++){var e=n(c[d])||\\\"\\\";if(!(e!==n(b(n(\\\"mcVRDoB1BGILD7YFe1BTXBA7B6==\\\")))&&e.indexOf(m,e.length-m.length)<0&&[n(\\\"9qqG-7amjlwq==\\\"),n(\\\"KA3B3C2A6D1D5H5H1A3==\\\"),n(\\\"QzbzvxyB2yA-9m==\\\"),n(\\\"naamngiA3dA-16xtE-11C-9B1H-8sc==\\\")].indexOf(m)<0)){a.ul=!1;break}}a.ul===!0&&h(),a.events.on(\\\"contentChanged\\\",function(){a.ul===!0&&g()&&h()}),a.events.on(\\\"destroy\\\",function(){j&&j.length&&j.remove()},!0)}var j,k,l=\\\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\\\",m=function(){for(var a=0,b=document.domain,c=b.split(\\\".\\\"),d=\\\"_gd\\\"+(new Date).getTime();a<c.length-1&&document.cookie.indexOf(d+\\\"=\\\"+d)==-1;)b=c.slice(-1-++a).join(\\\".\\\"),document.cookie=d+\\\"=\\\"+d+\\\";domain=\\\"+b+\\\";\\\";return document.cookie=d+\\\"=;expires=Thu, 01 Jan 1970 00:00:01 GMT;domain=\\\"+b+\\\";\\\",(b||\\\"\\\").replace(/(^\\\\.*)|(\\\\.*$)/g,\\\"\\\")}(),n=b(c);return{_init:i}},a.extend(a.FE.DEFAULTS,{pastePlain:!1,pasteDeniedTags:[\\\"colgroup\\\",\\\"col\\\"],pasteDeniedAttrs:[\\\"class\\\",\\\"id\\\",\\\"style\\\"],pasteAllowedStyleProps:[\\\"font-family\\\",\\\"font-size\\\",\\\"background\\\",\\\"color\\\",\\\"width\\\",\\\"text-align\\\",\\\"vertical-align\\\",\\\"background-color\\\"],pasteAllowLocalImages:!1}),a.FE.MODULES.paste=function(b){function c(c){a.FE.copied_html=b.html.getSelected(),a.FE.copied_text=a(\\\"<div>\\\").html(a.FE.copied_html).text(),\\\"cut\\\"==c.type&&(b.undo.saveStep(),setTimeout(function(){b.selection.save(),b.html.wrap(),b.selection.restore(),b.events.focus(),b.undo.saveStep()},0))}function d(a){if(r)return!1;if(a.originalEvent&&(a=a.originalEvent),b.events.trigger(\\\"paste.before\\\",[a])===!1)return a.preventDefault(),!1;if(n=b.$win.scrollTop(),a&&a.clipboardData&&a.clipboardData.getData){var c=\\\"\\\",d=a.clipboardData.types;if(b.helpers.isArray(d))for(var f=0;f<d.length;f++)c+=d[f]+\\\";\\\";else c=d;if(o=\\\"\\\",p=a.clipboardData.getData(\\\"text/rtf\\\"),/text\\\\/html/.test(c)?o=a.clipboardData.getData(\\\"text/html\\\"):/text\\\\/rtf/.test(c)&&b.browser.safari?o=p:/text\\\\/plain/.test(c)&&!this.browser.mozilla&&(o=b.html.escapeEntities(a.clipboardData.getData(\\\"text/plain\\\")).replace(/\\\\n/g,\\\"<br>\\\")),\\\"\\\"!==o)return i(),a.preventDefault&&(a.stopPropagation(),a.preventDefault()),!1;o=null}e()}function e(){b.selection.save(),b.events.disableBlur(),o=null,q?q.html(\\\"\\\"):(q=a('<div contenteditable=\\\"true\\\" style=\\\"position: fixed; top: 0; left: -9999px; height: 100%; width: 0; word-break: break-all; overflow:hidden; z-index: 9999; line-height: 140%;\\\" tabIndex=\\\"-1\\\"></div>'),b.$box.after(q),b.events.on(\\\"destroy\\\",function(){q.remove()})),q.focus(),b.win.setTimeout(i,1)}function f(a){var c;a=a.replace(/<p(.*?)class=\\\"?'?MsoListParagraph\\\"?'? ([\\\\s\\\\S]*?)>([\\\\s\\\\S]*?)<\\\\/p>/gi,\\\"<ul><li>$3</li></ul>\\\"),a=a.replace(/<p(.*?)class=\\\"?'?NumberedText\\\"?'? ([\\\\s\\\\S]*?)>([\\\\s\\\\S]*?)<\\\\/p>/gi,\\\"<ol><li>$3</li></ol>\\\"),a=a.replace(/<p(.*?)class=\\\"?'?MsoListParagraphCxSpFirst\\\"?'?([\\\\s\\\\S]*?)(level\\\\d)?([\\\\s\\\\S]*?)>([\\\\s\\\\S]*?)<\\\\/p>/gi,\\\"<ul><li$3>$5</li>\\\"),a=a.replace(/<p(.*?)class=\\\"?'?NumberedTextCxSpFirst\\\"?'?([\\\\s\\\\S]*?)(level\\\\d)?([\\\\s\\\\S]*?)>([\\\\s\\\\S]*?)<\\\\/p>/gi,\\\"<ol><li$3>$5</li>\\\"),a=a.replace(/<p(.*?)class=\\\"?'?MsoListParagraphCxSpMiddle\\\"?'?([\\\\s\\\\S]*?)(level\\\\d)?([\\\\s\\\\S]*?)>([\\\\s\\\\S]*?)<\\\\/p>/gi,\\\"<li$3>$5</li>\\\"),a=a.replace(/<p(.*?)class=\\\"?'?NumberedTextCxSpMiddle\\\"?'?([\\\\s\\\\S]*?)(level\\\\d)?([\\\\s\\\\S]*?)>([\\\\s\\\\S]*?)<\\\\/p>/gi,\\\"<li$3>$5</li>\\\"),a=a.replace(/<p(.*?)class=\\\"?'?MsoListBullet\\\"?'?([\\\\s\\\\S]*?)(level\\\\d)?([\\\\s\\\\S]*?)>([\\\\s\\\\S]*?)<\\\\/p>/gi,\\\"<li$3>$5</li>\\\"),a=a.replace(/<p(.*?)class=\\\"?'?MsoListParagraphCxSpLast\\\"?'?([\\\\s\\\\S]*?)(level\\\\d)?([\\\\s\\\\S]*?)>([\\\\s\\\\S]*?)<\\\\/p>/gi,\\\"<li$3>$5</li></ul>\\\"),a=a.replace(/<p(.*?)class=\\\"?'?NumberedTextCxSpLast\\\"?'?([\\\\s\\\\S]*?)(level\\\\d)?([\\\\s\\\\S]*?)>([\\\\s\\\\S]*?)<\\\\/p>/gi,\\\"<li$3>$5</li></ol>\\\"),a=a.replace(/<span([^<]*?)style=\\\"?'?mso-list:Ignore\\\"?'?([\\\\s\\\\S]*?)>([\\\\s\\\\S]*?)<span/gi,\\\"<span><span\\\"),a=a.replace(/<!--\\\\[if \\\\!supportLists\\\\]-->([\\\\s\\\\S]*?)<!--\\\\[endif\\\\]-->/gi,\\\"\\\"),a=a.replace(/<!\\\\[if \\\\!supportLists\\\\]>([\\\\s\\\\S]*?)<!\\\\[endif\\\\]>/gi,\\\"\\\"),a=a.replace(/(\\\\n|\\\\r| class=(\\\")?Mso[a-zA-Z0-9]+(\\\")?)/gi,\\\" \\\"),a=a.replace(/<!--[\\\\s\\\\S]*?-->/gi,\\\"\\\"),a=a.replace(/<(\\\\/)*(meta|link|span|\\\\\\\\?xml:|st1:|o:|font)(.*?)>/gi,\\\"\\\");var d=[\\\"style\\\",\\\"script\\\",\\\"applet\\\",\\\"embed\\\",\\\"noframes\\\",\\\"noscript\\\"];for(c=0;c<d.length;c++){var e=new RegExp(\\\"<\\\"+d[c]+\\\".*?\\\"+d[c]+\\\"(.*?)>\\\",\\\"gi\\\");a=a.replace(e,\\\"\\\")}a=a.replace(/&nbsp;/gi,\\\" \\\"),a=a.replace(/<td([^>]*)><\\\\/td>/g,\\\"<td$1><br></td>\\\"),a=a.replace(/<th([^>]*)><\\\\/th>/g,\\\"<th$1><br></th>\\\");var f;do f=a,a=a.replace(/<[^\\\\/>][^>]*><\\\\/[^>]+>/gi,\\\"\\\");while(a!=f);a=a.replace(/<lilevel([^1])([^>]*)>/gi,'<li data-indent=\\\"true\\\"$2>'),a=a.replace(/<lilevel1([^>]*)>/gi,\\\"<li$1>\\\"),a=b.clean.html(a,b.opts.pasteDeniedTags,b.opts.pasteDeniedAttrs),a=a.replace(/<a>(.[^<]+)<\\\\/a>/gi,\\\"$1\\\"),a=a.replace(/<br> */g,\\\"<br>\\\");var g=b.o_doc.createElement(\\\"div\\\");g.innerHTML=a;var h=g.querySelectorAll(\\\"li[data-indent]\\\");for(c=0;c<h.length;c++){var i=h[c],j=i.previousElementSibling;if(j&&\\\"LI\\\"==j.tagName){var k=j.querySelector(\\\":scope > ul, :scope > ol\\\");k||(k=document.createElement(\\\"ul\\\"),j.appendChild(k)),k.appendChild(i)}else i.removeAttribute(\\\"data-indent\\\")}return b.html.cleanBlankSpaces(g),a=g.innerHTML}function g(a){var c,d=null,e=b.doc.createElement(\\\"div\\\");e.innerHTML=a;var f=e.querySelectorAll(\\\"p, div, h1, h2, h3, h4, h5, h6, pre, blockquote\\\");for(c=0;c<f.length;c++)d=f[c],d.outerHTML=\\\"<\\\"+(b.html.defaultTag()||\\\"DIV\\\")+\\\">\\\"+d.innerHTML+\\\"</\\\"+(b.html.defaultTag()||\\\"DIV\\\")+\\\">\\\";for(f=e.querySelectorAll(\\\"*:not(\\\"+\\\"p, div, h1, h2, h3, h4, h5, h6, pre, blockquote, ul, ol, li, table, tbody, thead, tr, td, br, img\\\".split(\\\",\\\").join(\\\"):not(\\\")+\\\")\\\"),c=f.length-1;c>=0;c--)d=f[c],d.outerHTML=d.innerHTML;var g=function(a){for(var c=b.node.contents(a),d=0;d<c.length;d++)c[d].nodeType!=Node.TEXT_NODE&&c[d].nodeType!=Node.ELEMENT_NODE?c[d].parentNode.removeChild(c[d]):g(c[d])};return g(e),e.innerHTML}function h(a){return a.match(/(class=\\\\\\\"?Mso|class=\\\\'?Mso|style=\\\\\\\"[^\\\\\\\"]*\\\\bmso\\\\-|style=\\\\'[^\\\\']*\\\\bmso\\\\-|w:WordDocument)/gi)}function i(){var c,d=null,e=null;b.keys.forceUndo();var i=b.snapshot.get();null===o&&(o=q.get(0).innerHTML,b.selection.restore(),b.events.enableBlur());var k=h(o),m=b.events.chainTrigger(\\\"paste.beforeCleanup\\\",o);if(m&&\\\"string\\\"==typeof m&&(o=m),!k){var n=b.opts.htmlAllowedStyleProps;b.opts.htmlAllowedStyleProps=b.opts.pasteAllowedStyleProps,b.opts.htmlAllowComments=!1,o=b.clean.html(o,b.opts.pasteDeniedTags,b.opts.pasteDeniedAttrs),b.opts.htmlAllowedStyleProps=n,b.opts.htmlAllowComments=!0,o=l(o),o=o.replace(/\\\\r|\\\\n|\\\\t/g,\\\"\\\");var p=b.doc.createElement(\\\"div\\\");p.innerHTML=o,a.FE.copied_text&&p.textContent.replace(/(\\\\u00A0)/gi,\\\" \\\").replace(/\\\\r|\\\\n/gi,\\\"\\\")==a.FE.copied_text.replace(/(\\\\u00A0)/gi,\\\" \\\").replace(/\\\\r|\\\\n/gi,\\\"\\\")&&(o=a.FE.copied_html),o=o.replace(/^ */g,\\\"\\\").replace(/ *$/g,\\\"\\\")}o.indexOf(\\\"<body\\\")>=0&&(o=o.replace(/[.\\\\s\\\\S\\\\w\\\\W<>]*<body[^>]*>[\\\\s]*([.\\\\s\\\\S\\\\w\\\\W<>]*)\\\\s]*<\\\\/body>[.\\\\s\\\\S\\\\w\\\\W<>]*/g,\\\"$1\\\"),o=o.replace(/([^>])\\\\n([^<])/g,\\\"$1 $2\\\"));var r=!1;if(o.indexOf('id=\\\"docs-internal-guid')>=0&&(o=o.replace(/^.* id=\\\"docs-internal-guid[^>]*>(.*)<\\\\/b>.*$/,\\\"$1\\\"),r=!0),k&&!b.wordPaste&&(o=o.replace(/^\\\\n*/g,\\\"\\\").replace(/^ /g,\\\"\\\"),0===o.indexOf(\\\"<colgroup>\\\")&&(o=\\\"<table>\\\"+o+\\\"</table>\\\"),o=f(o),o=l(o)),b.opts.pastePlain&&(o=g(o)),m=b.events.chainTrigger(\\\"paste.afterCleanup\\\",o),\\\"string\\\"==typeof m&&(o=m),\\\"\\\"!==o){var s=b.o_doc.createElement(\\\"div\\\");s.innerHTML=o,b.spaces.normalize(s);var t=s.getElementsByTagName(\\\"span\\\");for(c=t.length-1;c>=0;c--){var u=t[c];0===u.attributes.length&&(u.outerHTML=u.innerHTML)}var v=s.children;if(1==v.length&&[\\\"OL\\\",\\\"UL\\\"].indexOf(v[0].tagName)>=0&&(v[0].outerHTML=v[0].innerHTML),!r){var w=s.getElementsByTagName(\\\"br\\\");for(c=w.length-1;c>=0;c--){var x=w[c];b.node.isBlock(x.previousSibling)&&x.parentNode.removeChild(x)}}if(b.opts.enter==a.FE.ENTER_BR)for(d=s.querySelectorAll(\\\"p, div\\\"),c=d.length-1;c>=0;c--)e=d[c],e.outerHTML=e.innerHTML+(e.nextSibling&&!b.node.isEmpty(e)?\\\"<br>\\\":\\\"\\\");else if(b.opts.enter==a.FE.ENTER_DIV)for(d=s.getElementsByTagName(\\\"p\\\"),c=d.length-1;c>=0;c--)e=d[c],e.outerHTML=\\\"<div>\\\"+e.innerHTML+\\\"</div>\\\";o=s.innerHTML,b.html.insert(o,!0)}j(),b.undo.saveStep(i),b.undo.saveStep()}function j(){b.events.trigger(\\\"paste.after\\\")}function k(){return p}function l(a){var c,d=b.o_doc.createElement(\\\"div\\\");d.innerHTML=a;for(var e=d.querySelectorAll(\\\"*:empty:not(br):not(img):not(td):not(th)\\\");e.length;){for(c=0;c<e.length;c++)e[c].parentNode.removeChild(e[c]);e=d.querySelectorAll(\\\"*:empty:not(br):not(img):not(td):not(th)\\\")}for(var f=d.querySelectorAll(\\\":scope > div:not([style]), td > div:not([style]), th > div:not([style]), li > div:not([style])\\\");f.length;){var g=f[f.length-1];if(b.html.defaultTag()&&\\\"div\\\"!=b.html.defaultTag())g.querySelector(b.html.blockTagsQuery())?g.outerHTML=g.innerHTML:g.outerHTML=\\\"<\\\"+b.html.defaultTag()+\\\">\\\"+g.innerHTML+\\\"</\\\"+b.html.defaultTag()+\\\">\\\";else{var h=g.querySelectorAll(\\\"*\\\");h.length&&\\\"BR\\\"===h[h.length-1].tagName?g.outerHTML=g.innerHTML:g.outerHTML=g.innerHTML+\\\"<br>\\\"}f=d.querySelectorAll(\\\":scope > div:not([style]), td > div:not([style]), th > div:not([style]), li > div:not([style])\\\")}for(f=d.querySelectorAll(\\\"div:not([style])\\\");f.length;){for(c=0;c<f.length;c++){var i=f[c],j=i.innerHTML.replace(/\\\\u0009/gi,\\\"\\\").trim();i.outerHTML=j}f=d.querySelectorAll(\\\"div:not([style])\\\")}return d.innerHTML}function m(){b.events.on(\\\"copy\\\",c),b.events.on(\\\"cut\\\",c),b.events.on(\\\"paste\\\",d),b.browser.msie&&b.browser.version<11&&(b.events.on(\\\"mouseup\\\",function(a){2==a.button&&(setTimeout(function(){r=!1},50),r=!0)},!0),b.events.on(\\\"beforepaste\\\",d))}var n,o,p,q,r=!1;return{_init:m,removeEmptyTags:l,getRtfClipboard:k,isWord:h}},a.extend(a.FE.DEFAULTS,{shortcutsEnabled:[\\\"show\\\",\\\"bold\\\",\\\"italic\\\",\\\"underline\\\",\\\"strikeThrough\\\",\\\"indent\\\",\\\"outdent\\\",\\\"undo\\\",\\\"redo\\\"],shortcutsHint:!0}),a.FE.SHORTCUTS_MAP={},a.FE.RegisterShortcut=function(b,c,d,e,f,g){a.FE.SHORTCUTS_MAP[(f?\\\"^\\\":\\\"\\\")+(g?\\\"@\\\":\\\"\\\")+b]={cmd:c,val:d,letter:e,shift:f,option:g},a.FE.DEFAULTS.shortcutsEnabled.push(c)},a.FE.RegisterShortcut(a.FE.KEYCODE.E,\\\"show\\\",null,\\\"E\\\",!1,!1),a.FE.RegisterShortcut(a.FE.KEYCODE.B,\\\"bold\\\",null,\\\"B\\\",!1,!1),a.FE.RegisterShortcut(a.FE.KEYCODE.I,\\\"italic\\\",null,\\\"I\\\",!1,!1),a.FE.RegisterShortcut(a.FE.KEYCODE.U,\\\"underline\\\",null,\\\"U\\\",!1,!1),a.FE.RegisterShortcut(a.FE.KEYCODE.S,\\\"strikeThrough\\\",null,\\\"S\\\",!1,!1),a.FE.RegisterShortcut(a.FE.KEYCODE.CLOSE_SQUARE_BRACKET,\\\"indent\\\",null,\\\"]\\\",!1,!1),a.FE.RegisterShortcut(a.FE.KEYCODE.OPEN_SQUARE_BRACKET,\\\"outdent\\\",null,\\\"[\\\",!1,!1),a.FE.RegisterShortcut(a.FE.KEYCODE.Z,\\\"undo\\\",null,\\\"Z\\\",!1,!1),a.FE.RegisterShortcut(a.FE.KEYCODE.Z,\\\"redo\\\",null,\\\"Z\\\",!0,!1),a.FE.MODULES.shortcuts=function(b){function c(c){if(!b.opts.shortcutsHint)return null;if(!f){f={};for(var d in a.FE.SHORTCUTS_MAP)a.FE.SHORTCUTS_MAP.hasOwnProperty(d)&&b.opts.shortcutsEnabled.indexOf(a.FE.SHORTCUTS_MAP[d].cmd)>=0&&(f[a.FE.SHORTCUTS_MAP[d].cmd+\\\".\\\"+(a.FE.SHORTCUTS_MAP[d].val||\\\"\\\")]={shift:a.FE.SHORTCUTS_MAP[d].shift,option:a.FE.SHORTCUTS_MAP[d].option,letter:a.FE.SHORTCUTS_MAP[d].letter})}var e=f[c];return e?(b.helpers.isMac()?String.fromCharCode(8984):\\\"Ctrl+\\\")+(e.shift?b.helpers.isMac()?String.fromCharCode(8679):\\\"Shift+\\\":\\\"\\\")+(e.option?b.helpers.isMac()?String.fromCharCode(8997):\\\"Alt+\\\":\\\"\\\")+e.letter:null}function d(c){if(!b.core.hasFocus())return!0;var d=c.which,e=navigator.userAgent.indexOf(\\\"Mac OS X\\\")!=-1?c.metaKey:c.ctrlKey;if(\\\"keyup\\\"==c.type&&g&&d!=a.FE.KEYCODE.META)return g=!1,!1;\\\"keydown\\\"==c.type&&(g=!1);var f=(c.shiftKey?\\\"^\\\":\\\"\\\")+(c.altKey?\\\"@\\\":\\\"\\\")+d;if(e&&a.FE.SHORTCUTS_MAP[f]){var h=a.FE.SHORTCUTS_MAP[f].cmd;if(h&&b.opts.shortcutsEnabled.indexOf(h)>=0){var i,j=a.FE.SHORTCUTS_MAP[f].val;if(h&&!j?i=b.$tb.find('.fr-command[data-cmd=\\\"'+h+'\\\"]'):h&&j&&(i=b.$tb.find('.fr-command[data-cmd=\\\"'+h+'\\\"][data-param1=\\\"'+j+'\\\"]')),i.length)return c.preventDefault(),c.stopPropagation(),i.parents(\\\".fr-toolbar\\\").data(\\\"instance\\\",b),\\\"keydown\\\"==c.type&&(b.button.exec(i),g=!0),!1;if(h&&b.commands[h])return c.preventDefault(),c.stopPropagation(),\\\"keydown\\\"==c.type&&(b.commands[h](),g=!0),!1}}}function e(){b.events.on(\\\"keydown\\\",d,!0),b.events.on(\\\"keyup\\\",d,!0)}var f=null,g=!1;return{_init:e,get:c}},a.FE.MODULES.snapshot=function(a){function b(a){for(var b=a.parentNode.childNodes,c=0,d=null,e=0;e<b.length;e++){if(d){var f=b[e].nodeType===Node.TEXT_NODE&&\\\"\\\"===b[e].textContent,g=d.nodeType===Node.TEXT_NODE&&b[e].nodeType===Node.TEXT_NODE;f||g||c++}if(b[e]==a)return c;d=b[e]}}function c(c){var d=[];if(!c.parentNode)return[];for(;!a.node.isElement(c);)d.push(b(c)),c=c.parentNode;return d.reverse()}function d(a,b){for(;a&&a.nodeType===Node.TEXT_NODE;){var c=a.previousSibling;c&&c.nodeType==Node.TEXT_NODE&&(b+=c.textContent.length),a=c}return b}function e(a){return{scLoc:c(a.startContainer),scOffset:d(a.startContainer,a.startOffset),ecLoc:c(a.endContainer),ecOffset:d(a.endContainer,a.endOffset)}}function f(){var b={};if(a.events.trigger(\\\"snapshot.before\\\"),b.html=(a.$wp?a.$el.html():a.$oel.get(0).outerHTML).replace(/ style=\\\"\\\"/g,\\\"\\\"),b.ranges=[],a.$wp&&a.selection.inEditor()&&a.core.hasFocus())for(var c=a.selection.ranges(),d=0;d<c.length;d++)b.ranges.push(e(c[d]));return a.events.trigger(\\\"snapshot.after\\\"),b}function g(b){for(var c=a.el,d=0;d<b.length;d++)c=c.childNodes[b[d]];return c}function h(b,c){try{var d=g(c.scLoc),e=c.scOffset,f=g(c.ecLoc),h=c.ecOffset,i=a.doc.createRange();i.setStart(d,e),i.setEnd(f,h),b.addRange(i)}catch(j){console.warn(j)}}function i(b){a.$el.html()!=b.html&&a.$el.html(b.html);var c=a.selection.get();a.selection.clear(),a.events.focus(!0);for(var d=0;d<b.ranges.length;d++)h(c,b.ranges[d])}function j(b,c){return b.html==c.html&&(!a.core.hasFocus()||JSON.stringify(b.ranges)==JSON.stringify(c.ranges))}return{get:f,restore:i,equal:j}},a.FE.MODULES.undo=function(a){function b(b){var c=b.which,d=a.keys.ctrlKey(b);d&&(90==c&&b.shiftKey&&b.preventDefault(),90==c&&b.preventDefault())}function c(){return!(0===a.undo_stack.length||a.undo_index<=1)}function d(){return a.undo_index!=a.undo_stack.length}function e(b){return!(!a.undo_stack||a.undoing||a.el.querySelector(\\\".fr-marker\\\"))&&void(\\\"undefined\\\"==typeof b?(b=a.snapshot.get(),a.undo_stack[a.undo_index-1]&&a.snapshot.equal(a.undo_stack[a.undo_index-1],b)||(f(),a.undo_stack.push(b),a.undo_index++,b.html!=l&&(a.events.trigger(\\\"contentChanged\\\"),l=b.html))):(f(),a.undo_index>0?a.undo_stack[a.undo_index-1]=b:(a.undo_stack.push(b),a.undo_index++)))}function f(){if(!a.undo_stack||a.undoing)return!1;for(;a.undo_stack.length>a.undo_index;)a.undo_stack.pop()}function g(){if(a.undo_index>1){a.undoing=!0;var b=a.undo_stack[--a.undo_index-1];clearTimeout(a._content_changed_timer),a.snapshot.restore(b),l=b.html,a.popups.hideAll(),a.toolbar.enable(),a.events.trigger(\\\"contentChanged\\\"),a.events.trigger(\\\"commands.undo\\\"),a.undoing=!1}}function h(){if(a.undo_index<a.undo_stack.length){a.undoing=!0;var b=a.undo_stack[a.undo_index++];clearTimeout(a._content_changed_timer),a.snapshot.restore(b),l=b.html,a.popups.hideAll(),a.toolbar.enable(),a.events.trigger(\\\"contentChanged\\\"),a.events.trigger(\\\"commands.redo\\\"),a.undoing=!1}}function i(){a.undo_index=0,a.undo_stack=[]}function j(){a.undo_stack=[]}function k(){i(),a.events.on(\\\"initialized\\\",function(){l=(a.$wp?a.$el.html():a.$oel.get(0).outerHTML).replace(/ style=\\\"\\\"/g,\\\"\\\")}),a.events.on(\\\"blur\\\",function(){a.el.querySelector(\\\".fr-dragging\\\")||a.undo.saveStep()}),a.events.on(\\\"keydown\\\",b),a.events.on(\\\"destroy\\\",j)}var l=null;return{_init:k,run:g,redo:h,canDo:c,canRedo:d,dropRedo:f,reset:i,saveStep:e}},a.FE.ICON_DEFAULT_TEMPLATE=\\\"font_awesome\\\",a.FE.ICON_TEMPLATES={font_awesome:'<i class=\\\"fa fa-[NAME]\\\" aria-hidden=\\\"true\\\"></i>',text:'<span style=\\\"text-align: center;\\\">[NAME]</span>',image:\\\"<img src=[SRC] alt=[ALT] />\\\",svg:'<svg viewBox=\\\"0 0 32 32\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\">[PATH]</svg>'},a.FE.ICONS={bold:{NAME:\\\"bold\\\"},italic:{NAME:\\\"italic\\\"},underline:{NAME:\\\"underline\\\"},strikeThrough:{NAME:\\\"strikethrough\\\"},subscript:{NAME:\\\"subscript\\\"},superscript:{NAME:\\\"superscript\\\"},color:{NAME:\\\"tint\\\"},outdent:{NAME:\\\"outdent\\\"},indent:{NAME:\\\"indent\\\"},undo:{NAME:\\\"rotate-left\\\"},redo:{NAME:\\\"rotate-right\\\"},insertHR:{NAME:\\\"minus\\\"},clearFormatting:{NAME:\\\"eraser\\\"},selectAll:{NAME:\\\"mouse-pointer\\\"}},a.FE.DefineIconTemplate=function(b,c){a.FE.ICON_TEMPLATES[b]=c},a.FE.DefineIcon=function(b,c){a.FE.ICONS[b]=c},a.FE.MODULES.icon=function(){function b(b){var c=null,d=a.FE.ICONS[b];if(\\\"undefined\\\"!=typeof d){var e=d.template||a.FE.ICON_DEFAULT_TEMPLATE;e&&(e=a.FE.ICON_TEMPLATES[e])&&(c=e.replace(/\\\\[([a-zA-Z]*)\\\\]/g,function(a,c){return\\\"NAME\\\"==c?d[c]||b:d[c]}))}return c||b}function c(b){var c=a.FE.ICONS[b],d=a.FE.ICON_DEFAULT_TEMPLATE;return\\\"undefined\\\"!=typeof c?d=c.template||a.FE.ICON_DEFAULT_TEMPLATE:d}return{create:b,getTemplate:c}},a.extend(a.FE.DEFAULTS,{tooltips:!0}),a.FE.MODULES.tooltip=function(b){function c(){b.$tooltip&&b.$tooltip.removeClass(\\\"fr-visible\\\").css(\\\"left\\\",\\\"-3000px\\\").css(\\\"position\\\",\\\"fixed\\\")}function d(c,d){if(c.data(\\\"title\\\")||c.data(\\\"title\\\",c.attr(\\\"title\\\")),!c.data(\\\"title\\\"))return!1;b.$tooltip||f(),c.removeAttr(\\\"title\\\"),b.$tooltip.text(c.data(\\\"title\\\")),b.$tooltip.addClass(\\\"fr-visible\\\");var e=c.offset().left+(c.outerWidth()-b.$tooltip.outerWidth())/2;e<0&&(e=0),e+b.$tooltip.outerWidth()>a(b.o_win).width()&&(e=a(b.o_win).width()-b.$tooltip.outerWidth()),\\\"undefined\\\"==typeof d&&(d=b.opts.toolbarBottom);var g=d?c.offset().top-b.$tooltip.height():c.offset().top+c.outerHeight();b.$tooltip.css(\\\"position\\\",\\\"\\\"),b.$tooltip.css(\\\"left\\\",e),b.$tooltip.css(\\\"top\\\",Math.ceil(g)),\\\"static\\\"!=a(b.o_doc).find(\\\"body\\\").css(\\\"position\\\")?(b.$tooltip.css(\\\"margin-left\\\",-a(b.o_doc).find(\\\"body\\\").offset().left),b.$tooltip.css(\\\"margin-top\\\",-a(b.o_doc).find(\\\"body\\\").offset().top)):(b.$tooltip.css(\\\"margin-left\\\",\\\"\\\"),b.$tooltip.css(\\\"margin-top\\\",\\\"\\\"))}function e(e,f,g){b.opts.tooltips&&!b.helpers.isMobile()&&(b.events.$on(e,\\\"mouseenter\\\",f,function(c){b.node.hasClass(c.currentTarget,\\\"fr-disabled\\\")||b.edit.isDisabled()||d(a(c.currentTarget),g)},!0),b.events.$on(e,\\\"mouseleave \\\"+b._mousedown+\\\" \\\"+b._mouseup,f,function(){c()},!0))}function f(){b.opts.tooltips&&!b.helpers.isMobile()&&(b.shared.$tooltip?b.$tooltip=b.shared.$tooltip:(b.shared.$tooltip=a('<div class=\\\"fr-tooltip\\\"></div>'),b.$tooltip=b.shared.$tooltip,b.opts.theme&&b.$tooltip.addClass(b.opts.theme+\\\"-theme\\\"),a(b.o_doc).find(\\\"body\\\").append(b.$tooltip)),b.events.on(\\\"shared.destroy\\\",function(){b.$tooltip.html(\\\"\\\").removeData().remove(),b.$tooltip=null},!0))}return{hide:c,to:d,bind:e}},a.FE.MODULES.button=function(b){function c(b,c,d){for(var e=a(),f=0;f<b.length;f++){var g=a(b[f]);if(g.is(c)&&(e=e.add(g)),d&&g.is(\\\".fr-dropdown\\\")){var h=g.next().find(c);e=e.add(h)}}return e}function d(d,e){var f,g=a();if(!d)return g;g=g.add(c(v,d,e)),g=g.add(c(w,d,e));for(f in b.shared.popups)if(b.shared.popups.hasOwnProperty(f)){var h=b.shared.popups[f],i=h.children().not(\\\".fr-buttons\\\").find(d);g=g.add(i)}for(f in b.shared.modals)if(b.shared.modals.hasOwnProperty(f)){var j=b.shared.modals[f],k=j.$modal.find(d);g=g.add(k)}return g}function e(c){var e=c.next(),f=b.node.hasClass(c.get(0),\\\"fr-active\\\"),g=d(\\\".fr-dropdown.fr-active\\\").not(c),h=c.parents(\\\".fr-toolbar, .fr-popup\\\").data(\\\"instance\\\")||b;if(h.helpers.isIOS()&&!h.el.querySelector(\\\".fr-marker\\\")&&(h.selection.save(),h.selection.clear(),h.selection.restore()),!f){var i=c.data(\\\"cmd\\\");e.find(\\\".fr-command\\\").removeClass(\\\"fr-active\\\").attr(\\\"aria-selected\\\",!1),a.FE.COMMANDS[i]&&a.FE.COMMANDS[i].refreshOnShow&&a.FE.COMMANDS[i].refreshOnShow.apply(h,[c,e]),e.css(\\\"left\\\",c.offset().left-c.parent().offset().left-(\\\"rtl\\\"==b.opts.direction?e.width()-c.outerWidth():0)),b.opts.toolbarBottom?e.css(\\\"bottom\\\",b.$tb.height()-c.position().top):e.css(\\\"top\\\",c.position().top+c.outerHeight())}c.addClass(\\\"fr-blink\\\").toggleClass(\\\"fr-active\\\"),c.hasClass(\\\"fr-active\\\")?(e.attr(\\\"aria-hidden\\\",!1),c.attr(\\\"aria-expanded\\\",!0)):(e.attr(\\\"aria-hidden\\\",!0),c.attr(\\\"aria-expanded\\\",!1)),setTimeout(function(){c.removeClass(\\\"fr-blink\\\")},300),e.offset().left+e.outerWidth()>b.$sc.offset().left+b.$sc.outerWidth()&&e.css(\\\"margin-left\\\",-(e.offset().left+e.outerWidth()-b.$sc.offset().left-b.$sc.outerWidth())),g.removeClass(\\\"fr-active\\\").attr(\\\"aria-expanded\\\",!1).next().attr(\\\"aria-hidden\\\",!0),g.parent(\\\".fr-toolbar:not(.fr-inline)\\\").css(\\\"zIndex\\\",\\\"\\\"),0!==c.parents(\\\".fr-popup\\\").length||b.opts.toolbarInline||(b.node.hasClass(c.get(0),\\\"fr-active\\\")?b.$tb.css(\\\"zIndex\\\",(b.opts.zIndex||1)+4):b.$tb.css(\\\"zIndex\\\",\\\"\\\"));var j=e.find(\\\"a.fr-command.fr-active:first\\\");j.length?b.accessibility.focusToolbarElement(j):b.accessibility.focusToolbarElement(c)}function f(a){a.addClass(\\\"fr-blink\\\"),setTimeout(function(){a.removeClass(\\\"fr-blink\\\")},500);for(var b=a.data(\\\"cmd\\\"),c=[];\\\"undefined\\\"!=typeof a.data(\\\"param\\\"+(c.length+1));)c.push(a.data(\\\"param\\\"+(c.length+1)));var e=d(\\\".fr-dropdown.fr-active\\\");e.length&&(e.removeClass(\\\"fr-active\\\").attr(\\\"aria-expanded\\\",!1).next().attr(\\\"aria-hidden\\\",!0),e.parent(\\\".fr-toolbar:not(.fr-inline)\\\").css(\\\"zIndex\\\",\\\"\\\")),a.parents(\\\".fr-popup, .fr-toolbar\\\").data(\\\"instance\\\").commands.exec(b,c)}function g(a){f(a)}function h(c){var d=c.parents(\\\".fr-popup, .fr-toolbar\\\").data(\\\"instance\\\");if(0!==c.parents(\\\".fr-popup\\\").length||c.data(\\\"popup\\\")||d.popups.hideAll(),d.popups.areVisible()&&!d.popups.areVisible(d)){for(var f=0;f<a.FE.INSTANCES.length;f++)a.FE.INSTANCES[f]!=d&&a.FE.INSTANCES[f].popups&&a.FE.INSTANCES[f].popups.areVisible()&&a.FE.INSTANCES[f].$el.find(\\\".fr-marker\\\").remove();d.popups.hideAll()}b.node.hasClass(c.get(0),\\\"fr-dropdown\\\")?e(c):(g(c),a.FE.COMMANDS[c.data(\\\"cmd\\\")]&&a.FE.COMMANDS[c.data(\\\"cmd\\\")].refreshAfterCallback!==!1&&d.button.bulkRefresh())}function i(b){var c=a(b.currentTarget);h(c)}function j(a){var b=a.find(\\\".fr-dropdown.fr-active\\\");b.length&&(b.removeClass(\\\"fr-active\\\").attr(\\\"aria-expanded\\\",!1).next().attr(\\\"aria-hidden\\\",!0),b.parent(\\\".fr-toolbar:not(.fr-inline)\\\").css(\\\"zIndex\\\",\\\"\\\"))}function k(a){a.preventDefault(),a.stopPropagation()}function l(a){if(a.stopPropagation(),!b.helpers.isMobile())return!1}function m(c,d){b.events.bindClick(c,\\\".fr-command:not(.fr-disabled)\\\",i),b.events.$on(c,b._mousedown+\\\" \\\"+b._mouseup+\\\" \\\"+b._move,\\\".fr-dropdown-menu\\\",k,!0),b.events.$on(c,b._mousedown+\\\" \\\"+b._mouseup+\\\" \\\"+b._move,\\\".fr-dropdown-menu .fr-dropdown-wrapper\\\",l,!0);var e=c.get(0).ownerDocument,f=\\\"defaultView\\\"in e?e.defaultView:e.parentWindow,g=function(d){(!d||d.type==b._mouseup&&d.target!=a(\\\"html\\\").get(0)||\\\"keydown\\\"==d.type&&(b.keys.isCharacter(d.which)&&!b.keys.ctrlKey(d)||d.which==a.FE.KEYCODE.ESC))&&j(c)};b.events.$on(a(f),b._mouseup+\\\" resize keydown\\\",g,!0),b.opts.iframe&&b.events.$on(b.$win,b._mouseup,g,!0),b.node.hasClass(c.get(0),\\\"fr-popup\\\")?a.merge(w,c.find(\\\".fr-btn\\\").toArray()):a.merge(v,c.find(\\\".fr-btn\\\").toArray()),b.tooltip.bind(c,\\\".fr-btn, .fr-title\\\",d)}function n(a,c){var d=\\\"\\\";if(c.html)d+=\\\"function\\\"==typeof c.html?c.html.call(b):c.html;else{var e=c.options;\\\"function\\\"==typeof e&&(e=e()),d+='<ul class=\\\"fr-dropdown-list\\\" role=\\\"presentation\\\">';for(var f in e)if(e.hasOwnProperty(f)){var g=b.shortcuts.get(a+\\\".\\\"+f);g=g?'<span class=\\\"fr-shortcut\\\">'+g+\\\"</span>\\\":\\\"\\\",d+='<li role=\\\"presentation\\\"><a class=\\\"fr-command\\\" tabIndex=\\\"-1\\\" role=\\\"option\\\" data-cmd=\\\"'+a+'\\\" data-param1=\\\"'+f+'\\\" title=\\\"'+e[f]+'\\\">'+b.language.translate(e[f])+\\\"</a></li>\\\"}d+=\\\"</ul>\\\"}return d}function o(a,c,d){if(b.helpers.isMobile()&&c.showOnMobile===!1)return\\\"\\\";var e=c.displaySelection;\\\"function\\\"==typeof e&&(e=e(b));var f;if(e){var g=\\\"function\\\"==typeof c.defaultSelection?c.defaultSelection(b):c.defaultSelection;f='<span style=\\\"width:'+(c.displaySelectionWidth||100)+'px\\\">'+(g||b.language.translate(c.title))+\\\"</span>\\\"}else f=b.icon.create(c.icon||a),f+='<span class=\\\"fr-sr-only\\\">'+(b.language.translate(c.title)||\\\"\\\")+\\\"</span>\\\";var h=c.popup?' data-popup=\\\"true\\\"':\\\"\\\",i=c.modal?' data-modal=\\\"true\\\"':\\\"\\\",j=b.shortcuts.get(a+\\\".\\\");j=j?\\\" (\\\"+j+\\\")\\\":\\\"\\\";var k=a+\\\"-\\\"+b.id,l='<button id=\\\"'+k+'\\\"type=\\\"button\\\" tabIndex=\\\"-1\\\" role=\\\"button\\\"'+(c.toggle?' aria-pressed=\\\"false\\\"':\\\"\\\")+(\\\"dropdown\\\"==c.type?' aria-controls=\\\"drop\\\" aria-expanded=\\\"false\\\" aria-haspopup=\\\"true\\\"':\\\"\\\")+(c.disabled?' aria-disabled=\\\"true\\\"':\\\"\\\")+' title=\\\"'+(b.language.translate(c.title)||\\\"\\\")+j+'\\\" class=\\\"fr-command fr-btn'+(\\\"dropdown\\\"==c.type?\\\" fr-dropdown\\\":\\\"\\\")+(\\\" fr-btn-\\\"+b.icon.getTemplate(c.icon))+(c.displaySelection?\\\" fr-selection\\\":\\\"\\\")+(c.back?\\\" fr-back\\\":\\\"\\\")+(c.disabled?\\\" fr-disabled\\\":\\\"\\\")+(d?\\\"\\\":\\\" fr-hidden\\\")+'\\\" data-cmd=\\\"'+a+'\\\"'+h+i+\\\">\\\"+f+\\\"</button>\\\";if(\\\"dropdown\\\"==c.type){var m='<div class=\\\"fr-dropdown-menu\\\" role=\\\"listbox\\\" aria-labelledby=\\\"'+k+'\\\" aria-hidden=\\\"true\\\"><div class=\\\"fr-dropdown-wrapper\\\" role=\\\"presentation\\\"><div class=\\\"fr-dropdown-content\\\" role=\\\"presentation\\\">';m+=n(a,c),m+=\\\"</div></div></div>\\\",l+=m}return l}function p(c,d){for(var e=\\\"\\\",f=0;f<c.length;f++){var g=c[f],h=a.FE.COMMANDS[g];if(!(h&&\\\"undefined\\\"!=typeof h.plugin&&b.opts.pluginsEnabled.indexOf(h.plugin)<0))if(h){var i=\\\"undefined\\\"==typeof d||d.indexOf(g)>=0;e+=o(g,h,i)}else\\\"|\\\"==g?e+='<div class=\\\"fr-separator fr-vs\\\" role=\\\"separator\\\" aria-orientation=\\\"vertical\\\"></div>':\\\"-\\\"==g&&(e+='<div class=\\\"fr-separator fr-hs\\\" role=\\\"separator\\\" aria-orientation=\\\"horizontal\\\"></div>')}return e}function q(c){var d,e=c.parents(\\\".fr-popup, .fr-toolbar\\\").data(\\\"instance\\\")||b,f=c.data(\\\"cmd\\\");b.node.hasClass(c.get(0),\\\"fr-dropdown\\\")?d=c.next():(c.removeClass(\\\"fr-active\\\"),c.attr(\\\"aria-pressed\\\")&&c.attr(\\\"aria-pressed\\\",!1)),a.FE.COMMANDS[f]&&a.FE.COMMANDS[f].refresh?a.FE.COMMANDS[f].refresh.apply(e,[c,d]):b.refresh[f]&&e.refresh[f](c,d)}function r(c){var d=b.$tb?b.$tb.data(\\\"instance\\\")||b:b;return b.events.trigger(\\\"buttons.refresh\\\")===!1||void setTimeout(function(){for(var e=d.selection.inEditor()&&d.core.hasFocus(),f=0;f<c.length;f++){var g=a(c[f]),h=g.data(\\\"cmd\\\");0===g.parents(\\\".fr-popup\\\").length?e||a.FE.COMMANDS[h]&&a.FE.COMMANDS[h].forcedRefresh?d.button.refresh(g):b.node.hasClass(g.get(0),\\\"fr-dropdown\\\")||(g.removeClass(\\\"fr-active\\\"),g.attr(\\\"aria-pressed\\\")&&g.attr(\\\"aria-pressed\\\",!1)):g.parents(\\\".fr-popup\\\").is(\\\":visible\\\")&&d.button.refresh(g)}},0)}function s(){r(v),r(w)}function t(){v=[],w=[]}function u(){b.opts.toolbarInline?b.events.on(\\\"toolbar.show\\\",s):(b.events.on(\\\"mouseup\\\",s),b.events.on(\\\"keyup\\\",s),b.events.on(\\\"blur\\\",s),b.events.on(\\\"focus\\\",s),b.events.on(\\\"contentChanged\\\",s)),b.events.on(\\\"shared.destroy\\\",t)}var v=[];(b.opts.toolbarInline||b.opts.toolbarContainer)&&(b.shared.buttons||(b.shared.buttons=[]),v=b.shared.buttons);var w=[];return b.shared.popup_buttons||(b.shared.popup_buttons=[]),w=b.shared.popup_buttons,{_init:u,buildList:p,bindCommands:m,refresh:q,bulkRefresh:s,exec:f,click:h,hideActiveDropdowns:j,getButtons:d}},a.FE.MODULES.modals=function(b){function c(a){return n[a]}function d(c,d){var e='<div tabIndex=\\\"-1\\\" class=\\\"fr-modal'+(b.opts.theme?\\\" \\\"+b.opts.theme+\\\"-theme\\\":\\\"\\\")+'\\\"><div class=\\\"fr-modal-wrapper\\\">',f='<i title=\\\"'+b.language.translate(\\\"Cancel\\\")+'\\\" class=\\\"fa fa-times fr-modal-close\\\"></i>';return e+='<div class=\\\"fr-modal-head\\\">'+c+f+\\\"</div>\\\",e+='<div tabIndex=\\\"-1\\\" class=\\\"fr-modal-body\\\">'+d+\\\"</div>\\\",e+=\\\"</div></div>\\\",a(e)}function e(c,e,f){if(b.shared.$overlay||(b.shared.$overlay=a('<div class=\\\"fr-overlay\\\">').appendTo(\\\"body\\\")),m=b.shared.$overlay,b.opts.theme&&m.addClass(b.opts.theme+\\\"-theme\\\"),!n[c]){var g=d(e,f);n[c]={$modal:g,$head:g.find(\\\".fr-modal-head\\\"),$body:g.find(\\\".fr-modal-body\\\")},b.helpers.isMobile()||g.addClass(\\\"fr-desktop\\\"),g.appendTo(\\\"body\\\"),b.events.bindClick(g,\\\"i.fr-modal-close\\\",function(){h(c)}),n[c].$body.css(\\\"margin-top\\\",n[c].$head.outerHeight()),b.events.$on(g,\\\"keydown\\\",function(d){var e=d.which;return e==a.FE.KEYCODE.ESC?(h(c),b.accessibility.focusModalButton(g),!1):!(!a(d.currentTarget).is(\\\"input[type=text], textarea\\\")&&e!=a.FE.KEYCODE.ARROW_UP&&e!=a.FE.KEYCODE.ARROW_DOWN&&!b.keys.isBrowserAction(d))||(d.preventDefault(),d.stopPropagation(),!1)},!0),h(c,!0)}return n[c]}function f(){for(var a in n){var b=n[a];b&&b.$modal&&b.$modal.removeData().remove()}m&&m.removeData().remove(),n={}}function g(a){if(n[a]){var c=n[a].$modal;c.data(\\\"instance\\\",b),c.show(),m.show(),b.$doc.find(\\\"body\\\").addClass(\\\"prevent-scroll\\\"),b.helpers.isMobile()&&b.$doc.find(\\\"body\\\").addClass(\\\"fr-mobile\\\"),c.addClass(\\\"fr-active\\\"),b.accessibility.focusModal(c)}}function h(a,c){if(n[a]){var d=n[a].$modal,e=d.data(\\\"instance\\\")||b;e.events.enableBlur(),d.hide(),m.hide(),e.$doc.find(\\\"body\\\").removeClass(\\\"prevent-scroll fr-mobile\\\"),d.removeClass(\\\"fr-active\\\"),c||(b.accessibility.restoreSelection(e),b.events.trigger(\\\"modals.hide\\\"))}}function i(a){if(n[a]){var c=n[a],d=c.$modal,e=c.$body,f=b.$win.height(),g=d.find(\\\".fr-modal-wrapper\\\"),h=g.outerHeight(!0),i=g.height()-(e.outerHeight(!0)-e.height()),j=f-h+i,k=e.get(0).scrollHeight,l=\\\"auto\\\";k>j&&(l=j),e.height(l)}}function j(a){var c;if(\\\"string\\\"==typeof a){if(!n[a])return;c=n[a].$modal}else c=a;return c&&b.node.hasClass(c,\\\"fr-active\\\")&&b.core.sameInstance(c)||!1}function k(a){for(var b in n)if(n.hasOwnProperty(b)&&j(b)&&(\\\"undefined\\\"==typeof a||n[b].$modal.data(\\\"instance\\\")==a))return n[b].$modal;return!1}function l(){b.events.on(\\\"shared.destroy\\\",f,!0)}b.shared.modals||(b.shared.modals={});var m,n=b.shared.modals;return{_init:l,get:c,create:e,show:g,hide:h,resize:i,isVisible:j,areVisible:k}},a.FE.POPUP_TEMPLATES={\\\"text.edit\\\":\\\"[_EDIT_]\\\"},a.FE.RegisterTemplate=function(b,c){a.FE.POPUP_TEMPLATES[b]=c},a.FE.MODULES.popups=function(b){function c(a,c){c.is(\\\":visible\\\")||(c=b.$sc),c.is(x[a].data(\\\"container\\\"))||(x[a].data(\\\"container\\\",c),c.append(x[a]))}function d(a,d,e,h){if(g()&&b.$el.find(\\\".fr-marker\\\").length>0?(b.events.disableBlur(),b.selection.restore()):(b.events.disableBlur(),b.events.focus(),b.events.enableBlur()),m([a]),!x[a])return!1;var i=b.button.getButtons(\\\".fr-dropdown.fr-active\\\");i.removeClass(\\\"fr-active\\\").attr(\\\"aria-expanded\\\",!1).parent(\\\".fr-toolbar\\\").css(\\\"zIndex\\\",\\\"\\\"),i.next().attr(\\\"aria-hidden\\\",!0),x[a].data(\\\"instance\\\",b),b.$tb&&b.$tb.data(\\\"instance\\\",b);var j=x[a].outerWidth(),k=f(a);x[a].addClass(\\\"fr-active\\\").removeClass(\\\"fr-hidden\\\").find(\\\"input, textarea\\\").removeAttr(\\\"disabled\\\");var l=x[a].data(\\\"container\\\");b.opts.toolbarInline&&l&&b.$tb&&l.get(0)==b.$tb.get(0)&&(c(a,b.$sc),e=b.$tb.offset().top-b.helpers.getPX(b.$tb.css(\\\"margin-top\\\")),d=b.$tb.offset().left+b.$tb.outerWidth()/2+(parseFloat(b.$tb.find(\\\".fr-arrow\\\").css(\\\"margin-left\\\"))||0)+b.$tb.find(\\\".fr-arrow\\\").outerWidth()/2,b.node.hasClass(b.$tb.get(0),\\\"fr-above\\\")&&e&&(e+=b.$tb.outerHeight()),h=0),l=x[a].data(\\\"container\\\"),!b.opts.iframe||h||k||(d&&(d-=b.$iframe.offset().left),e&&(e-=b.$iframe.offset().top)),l.is(b.$tb)?b.$tb.css(\\\"zIndex\\\",(b.opts.zIndex||1)+4):x[a].css(\\\"zIndex\\\",(b.opts.zIndex||1)+4),d&&(d-=j/2),b.opts.toolbarBottom&&l&&b.$tb&&l.get(0)==b.$tb.get(0)&&(x[a].addClass(\\\"fr-above\\\"),e&&(e-=x[a].outerHeight())),x[a].removeClass(\\\"fr-active\\\"),b.position.at(d,e,x[a],h||0),x[a].addClass(\\\"fr-active\\\"),k||b.accessibility.focusPopup(x[a]),b.opts.toolbarInline&&b.toolbar.hide(),b.events.trigger(\\\"popups.show.\\\"+a),s(a)._repositionPopup(),o()}function e(a,c){b.events.on(\\\"popups.show.\\\"+a,c)}function f(a){return x[a]&&b.node.hasClass(x[a],\\\"fr-active\\\")&&b.core.sameInstance(x[a])||!1}function g(a){for(var b in x)if(x.hasOwnProperty(b)&&f(b)&&(\\\"undefined\\\"==typeof a||x[b].data(\\\"instance\\\")==a))return x[b];return!1}function h(a){var c=null;c=\\\"string\\\"!=typeof a?a:x[a],c&&b.node.hasClass(c,\\\"fr-active\\\")&&(c.removeClass(\\\"fr-active fr-above\\\"),\\nb.events.trigger(\\\"popups.hide.\\\"+a),b.$tb&&(b.opts.zIndex>1?b.$tb.css(\\\"zIndex\\\",b.opts.zIndex+1):b.$tb.css(\\\"zIndex\\\",\\\"\\\")),b.events.disableBlur(),c.find(\\\"input, textarea, button\\\").filter(\\\":focus\\\").blur(),c.find(\\\"input, textarea\\\").attr(\\\"disabled\\\",\\\"disabled\\\"))}function i(a,c){b.events.on(\\\"popups.hide.\\\"+a,c)}function j(a){var c=x[a];if(c&&!c.data(\\\"inst\\\"+b.id)){var d=s(a);t(d,a)}return c}function k(a,c){b.events.on(\\\"popups.refresh.\\\"+a,c)}function l(c){b.events.trigger(\\\"popups.refresh.\\\"+c);for(var d=x[c].find(\\\".fr-command\\\"),e=0;e<d.length;e++){var f=a(d[e]);0===f.parents(\\\".fr-dropdown-menu\\\").length&&b.button.refresh(f)}}function m(a){\\\"undefined\\\"==typeof a&&(a=[]);for(var b in x)x.hasOwnProperty(b)&&a.indexOf(b)<0&&h(b)}function n(){b.shared.exit_flag=!0}function o(){b.shared.exit_flag=!1}function p(){return b.shared.exit_flag}function q(c,d){var e=a.FE.POPUP_TEMPLATES[c];\\\"function\\\"==typeof e&&(e=e.apply(b));for(var f in d)d.hasOwnProperty(f)&&(e=e.replace(\\\"[_\\\"+f.toUpperCase()+\\\"_]\\\",d[f]));return e}function r(c,d){var e=q(c,d),f=a('<div class=\\\"fr-popup'+(b.helpers.isMobile()?\\\" fr-mobile\\\":\\\" fr-desktop\\\")+(b.opts.toolbarInline?\\\" fr-inline\\\":\\\"\\\")+'\\\"><span class=\\\"fr-arrow\\\"></span>'+e+\\\"</div>\\\");b.opts.theme&&f.addClass(b.opts.theme+\\\"-theme\\\"),b.opts.zIndex>1&&b.$tb.css(\\\"z-index\\\",b.opts.zIndex+2),\\\"auto\\\"!=b.opts.direction&&f.removeClass(\\\"fr-ltr fr-rtl\\\").addClass(\\\"fr-\\\"+b.opts.direction),f.find(\\\"input, textarea\\\").attr(\\\"dir\\\",b.opts.direction).attr(\\\"disabled\\\",\\\"disabled\\\");var g=a(\\\"body\\\");return g.append(f),f.data(\\\"container\\\",g),x[c]=f,b.button.bindCommands(f,!1),f}function s(c){var d=x[c];return{_windowResize:function(){var a=d.data(\\\"instance\\\")||b;!a.helpers.isMobile()&&d.is(\\\":visible\\\")&&(a.events.disableBlur(),a.popups.hide(c),a.events.enableBlur())},_inputFocus:function(c){var e=d.data(\\\"instance\\\")||b,f=a(c.currentTarget);if(f.is(\\\"input:file\\\")&&f.closest(\\\".fr-layer\\\").addClass(\\\"fr-input-focus\\\"),c.preventDefault(),c.stopPropagation(),setTimeout(function(){e.events.enableBlur()},0),e.helpers.isMobile()){var g=a(e.o_win).scrollTop();setTimeout(function(){a(e.o_win).scrollTop(g)},0)}},_inputBlur:function(c){var e=d.data(\\\"instance\\\")||b,f=a(c.currentTarget);f.is(\\\"input:file\\\")&&f.closest(\\\".fr-layer\\\").removeClass(\\\"fr-input-focus\\\"),document.activeElement!=this&&a(this).is(\\\":visible\\\")&&(e.events.blurActive()&&e.events.trigger(\\\"blur\\\"),e.events.enableBlur())},_editorKeydown:function(e){var g=d.data(\\\"instance\\\")||b;g.keys.ctrlKey(e)||e.which==a.FE.KEYCODE.ALT||e.which==a.FE.KEYCODE.ESC||(f(c)&&d.find(\\\".fr-back:visible\\\").length?g.button.exec(d.find(\\\".fr-back:visible:first\\\")):e.which!=a.FE.KEYCODE.ALT&&g.popups.hide(c))},_preventFocus:function(c){var e=d.data(\\\"instance\\\")||b;\\\"mouseup\\\"==c.type&&b.button.hideActiveDropdowns(d);var f=c.originalEvent?c.originalEvent.target||c.originalEvent.originalTarget:null;\\\"mouseup\\\"==c.type||a(f).is(\\\":focus\\\")||e.events.disableBlur(),b.browser.safari&&\\\"mousedown\\\"==c.type&&a(f).is(\\\"input[type=file]\\\")&&e.events.disableBlur();var g=\\\"input, textarea, button, select, label, .fr-command\\\";return f&&!a(f).is(g)&&0===a(f).parents(g).length?(c.stopPropagation(),!1):(f&&a(f).is(g)&&c.stopPropagation(),void o())},_editorMouseup:function(){d.is(\\\":visible\\\")&&p()&&d.find(\\\"input:focus, textarea:focus, button:focus, select:focus\\\").filter(\\\":visible\\\").length>0&&b.events.disableBlur()},_windowMouseup:function(a){if(!b.core.sameInstance(d))return!0;var e=d.data(\\\"instance\\\")||b;d.is(\\\":visible\\\")&&p()&&(a.stopPropagation(),e.markers.remove(),e.popups.hide(c),o())},_windowKeydown:function(e){if(!b.core.sameInstance(d))return!0;var f=d.data(\\\"instance\\\")||b,g=e.which;if(a.FE.KEYCODE.ESC==g){if(f.popups.isVisible(c)&&f.opts.toolbarInline)return e.stopPropagation(),f.popups.isVisible(c)&&(d.find(\\\".fr-back:visible\\\").length?(f.button.exec(d.find(\\\".fr-back:visible:first\\\")),f.accessibility.focusPopupButton(d)):d.find(\\\".fr-dismiss:visible\\\").length?f.button.exec(d.find(\\\".fr-dismiss:visible:first\\\")):(f.popups.hide(c),f.toolbar.showInline(null,!0),f.accessibility.FocusPopupButton(d))),!1;if(f.popups.isVisible(c))return d.find(\\\".fr-back:visible\\\").length?(f.button.exec(d.find(\\\".fr-back:visible:first\\\")),f.accessibility.focusPopupButton(d)):d.find(\\\".fr-dismiss:visible\\\").length?f.button.exec(d.find(\\\".fr-dismiss:visible:first\\\")):(f.popups.hide(c),f.accessibility.focusPopupButton(d)),!1}},_doPlaceholder:function(){var b=a(this).next();0===b.length&&a(this).attr(\\\"placeholder\\\")&&a(this).after('<label for=\\\"'+a(this).attr(\\\"id\\\")+'\\\">'+a(this).attr(\\\"placeholder\\\")+\\\"</label>\\\"),a(this).toggleClass(\\\"fr-not-empty\\\",\\\"\\\"!==a(this).val())},_repositionPopup:function(){if(!b.opts.height&&!b.opts.heightMax||b.opts.toolbarInline)return!0;if(b.$wp&&f(c)&&d.parent().get(0)==b.$sc.get(0)){var a=d.offset().top-b.$wp.offset().top,e=b.$wp.outerHeight();b.node.hasClass(d.get(0),\\\"fr-above\\\")&&(a+=d.outerHeight()),a>e||a<0?d.addClass(\\\"fr-hidden\\\"):d.removeClass(\\\"fr-hidden\\\")}}}}function t(a,c){b.events.on(\\\"mouseup\\\",a._editorMouseup,!0),b.$wp&&b.events.on(\\\"keydown\\\",a._editorKeydown),b.events.on(\\\"blur\\\",function(){g()&&b.markers.remove(),m()}),b.$wp&&!b.helpers.isMobile()&&b.events.$on(b.$wp,\\\"scroll.popup\\\"+c,a._repositionPopup),b.events.on(\\\"window.mouseup\\\",a._windowMouseup,!0),b.events.on(\\\"window.keydown\\\",a._windowKeydown,!0),x[c].data(\\\"inst\\\"+b.id,!0),b.events.on(\\\"destroy\\\",function(){b.core.sameInstance(x[c])&&x[c].removeClass(\\\"fr-active\\\").appendTo(\\\"body\\\")},!0)}function u(c,d){var e=r(c,d),f=s(c);return t(f,c),b.events.$on(e,\\\"mousedown mouseup touchstart touchend touch\\\",\\\"*\\\",f._preventFocus,!0),b.events.$on(e,\\\"focus\\\",\\\"input, textarea, button, select\\\",f._inputFocus,!0),b.events.$on(e,\\\"blur\\\",\\\"input, textarea, button, select\\\",f._inputBlur,!0),b.accessibility.registerPopup(c),b.events.$on(e,\\\"keydown keyup change input\\\",\\\"input, textarea\\\",f._doPlaceholder,!0),b.helpers.isIOS()&&b.events.$on(e,\\\"touchend\\\",\\\"label\\\",function(){a(\\\"#\\\"+a(this).attr(\\\"for\\\")).prop(\\\"checked\\\",function(a,b){return!b})},!0),b.events.$on(a(b.o_win),\\\"resize\\\",f._windowResize,!0),e}function v(){for(var a in x)if(x.hasOwnProperty(a)){var b=x[a];b.html(\\\"\\\").removeData().remove(),x[a]=null}x=[]}function w(){b.events.on(\\\"shared.destroy\\\",v,!0),b.events.on(\\\"window.mousedown\\\",n),b.events.on(\\\"window.touchmove\\\",o),b.events.on(\\\"mousedown\\\",function(a){g()&&(a.stopPropagation(),b.$el.find(\\\".fr-marker\\\").remove(),n(),b.events.disableBlur())})}b.shared.popups||(b.shared.popups={});var x=b.shared.popups;return b.shared.exit_flag=!1,{_init:w,create:u,get:j,show:d,hide:h,onHide:i,hideAll:m,setContainer:c,refresh:l,onRefresh:k,onShow:e,isVisible:f,areVisible:g}},a.FE.MODULES.position=function(b){function c(){var a=b.selection.ranges(0),c=a.getBoundingClientRect();if(0===c.top&&0===c.left&&0===c.width||0===c.height){var d=!1;0===b.$el.find(\\\".fr-marker\\\").length&&(b.selection.save(),d=!0);var e=b.$el.find(\\\".fr-marker:first\\\");e.css(\\\"display\\\",\\\"inline\\\"),e.css(\\\"line-height\\\",\\\"\\\");var f=e.offset(),g=e.outerHeight();e.css(\\\"display\\\",\\\"none\\\"),e.css(\\\"line-height\\\",0),c={},c.left=f.left,c.width=0,c.height=g,c.top=f.top-(b.helpers.isMobile()?0:b.helpers.scrollTop()),c.right=1,c.bottom=1,c.ok=!0,d&&b.selection.restore()}return c}function d(a,c,d){var e=a.get(0).offsetHeight;if(!b.helpers.isMobile()&&b.$tb&&a.parent().get(0)!=b.$tb.get(0)){var f=a.parent().offset().top,g=c-e-(d||0);a.parent().get(0)==b.$sc.get(0)&&(f-=a.parent().position().top);var h=b.$sc.get(0).scrollHeight;f+c+e>b.$sc.offset().top+h&&a.parent().offset().top+g>0?(c=g,a.addClass(\\\"fr-above\\\")):a.removeClass(\\\"fr-above\\\")}return c}function e(a,c){var d=a.get(0).offsetWidth;return c+d>b.$sc.get(0).clientWidth-10&&(c=b.$sc.get(0).clientWidth-d-10),c<0&&(c=10),c}function f(a){var d=c();a.css({top:0,left:0});var e=d.top+d.height,f=d.left+d.width/2-a.get(0).offsetWidth/2+b.helpers.scrollLeft();b.opts.iframe||(e+=b.helpers.scrollTop()),g(f,e,a,d.height)}function g(a,c,f,g){var h=f.data(\\\"container\\\");!h||\\\"BODY\\\"===h.get(0).tagName&&\\\"static\\\"==h.css(\\\"position\\\")||(a&&(a-=h.offset().left),c&&(c-=h.offset().top),\\\"BODY\\\"!=h.get(0).tagName?(a&&(a+=h.get(0).scrollLeft),c&&(c+=h.get(0).scrollTop)):\\\"absolute\\\"==h.css(\\\"position\\\")&&(a&&(a+=h.position().left),c&&(c+=h.position().top))),b.opts.iframe&&h&&b.$tb&&h.get(0)!=b.$tb.get(0)&&(a&&(a+=b.$iframe.offset().left),c&&(c+=b.$iframe.offset().top));var i=e(f,a);if(a){f.css(\\\"left\\\",i);var j=f.data(\\\"fr-arrow\\\");j||(j=f.find(\\\".fr-arrow\\\"),f.data(\\\"fr-arrow\\\",j)),j.data(\\\"margin-left\\\")||j.data(\\\"margin-left\\\",b.helpers.getPX(j.css(\\\"margin-left\\\"))),j.css(\\\"margin-left\\\",a-i+j.data(\\\"margin-left\\\"))}c&&f.css(\\\"top\\\",d(f,c,g))}function h(c){var d=a(c),e=d.is(\\\".fr-sticky-on\\\"),f=d.data(\\\"sticky-top\\\"),g=d.data(\\\"sticky-scheduled\\\");if(\\\"undefined\\\"==typeof f){d.data(\\\"sticky-top\\\",0);var h=a('<div class=\\\"fr-sticky-dummy\\\" style=\\\"height: '+d.outerHeight()+'px;\\\"></div>');b.$box.prepend(h)}else b.$box.find(\\\".fr-sticky-dummy\\\").css(\\\"height\\\",d.outerHeight());if(b.core.hasFocus()||b.$tb.find(\\\"input:visible:focus\\\").length>0){var i=b.helpers.scrollTop(),j=Math.min(Math.max(i-b.$tb.parent().offset().top,0),b.$tb.parent().outerHeight()-d.outerHeight());j!=f&&j!=g&&(clearTimeout(d.data(\\\"sticky-timeout\\\")),d.data(\\\"sticky-scheduled\\\",j),d.outerHeight()<i-b.$tb.parent().offset().top&&d.addClass(\\\"fr-opacity-0\\\"),d.data(\\\"sticky-timeout\\\",setTimeout(function(){var a=b.helpers.scrollTop(),c=Math.min(Math.max(a-b.$tb.parent().offset().top,0),b.$tb.parent().outerHeight()-d.outerHeight());c>0&&\\\"BODY\\\"==b.$tb.parent().get(0).tagName&&(c+=b.$tb.parent().position().top),c!=f&&(d.css(\\\"top\\\",Math.max(c,0)),d.data(\\\"sticky-top\\\",c),d.data(\\\"sticky-scheduled\\\",c)),d.removeClass(\\\"fr-opacity-0\\\")},100))),e||(d.css(\\\"top\\\",\\\"0\\\"),d.width(b.$tb.parent().width()),d.addClass(\\\"fr-sticky-on\\\"),b.$box.addClass(\\\"fr-sticky-box\\\"))}else clearTimeout(a(c).css(\\\"sticky-timeout\\\")),d.css(\\\"top\\\",\\\"0\\\"),d.css(\\\"position\\\",\\\"\\\"),d.width(\\\"\\\"),d.data(\\\"sticky-top\\\",0),d.removeClass(\\\"fr-sticky-on\\\"),b.$box.removeClass(\\\"fr-sticky-box\\\")}function i(c){if(c.offsetWidth){var d,e,f=a(c),g=f.outerHeight(),h=f.data(\\\"sticky-position\\\"),i=a(\\\"body\\\"==b.opts.scrollableContainer?b.o_win:b.opts.scrollableContainer).outerHeight(),j=0,k=0;\\\"body\\\"!==b.opts.scrollableContainer&&(j=b.$sc.offset().top,k=a(b.o_win).outerHeight()-j-i);var l=\\\"body\\\"==b.opts.scrollableContainer?b.helpers.scrollTop():j,m=f.is(\\\".fr-sticky-on\\\");f.data(\\\"sticky-parent\\\")||f.data(\\\"sticky-parent\\\",f.parent());var n=f.data(\\\"sticky-parent\\\"),o=n.offset().top,p=n.outerHeight();if(f.data(\\\"sticky-offset\\\")||(f.data(\\\"sticky-offset\\\",!0),f.after('<div class=\\\"fr-sticky-dummy\\\" style=\\\"height: '+g+'px;\\\"></div>')),!h){var q=\\\"auto\\\"!==f.css(\\\"top\\\")||\\\"auto\\\"!==f.css(\\\"bottom\\\");q||f.css(\\\"position\\\",\\\"fixed\\\"),h={top:b.node.hasClass(f.get(0),\\\"fr-top\\\"),bottom:b.node.hasClass(f.get(0),\\\"fr-bottom\\\")},q||f.css(\\\"position\\\",\\\"\\\"),f.data(\\\"sticky-position\\\",h),f.data(\\\"top\\\",b.node.hasClass(f.get(0),\\\"fr-top\\\")?f.css(\\\"top\\\"):\\\"auto\\\"),f.data(\\\"bottom\\\",b.node.hasClass(f.get(0),\\\"fr-bottom\\\")?f.css(\\\"bottom\\\"):\\\"auto\\\")}var r=function(){return o<l+d&&o+p-g>=l+d},s=function(){return o+g<l+i-e&&o+p>l+i-e};d=b.helpers.getPX(f.data(\\\"top\\\")),e=b.helpers.getPX(f.data(\\\"bottom\\\"));var t=h.top&&r(),u=h.bottom&&s();t||u?(f.css(\\\"width\\\",n.width()+\\\"px\\\"),m||(f.addClass(\\\"fr-sticky-on\\\"),f.removeClass(\\\"fr-sticky-off\\\"),f.css(\\\"top\\\")&&(\\\"auto\\\"!=f.data(\\\"top\\\")?f.css(\\\"top\\\",b.helpers.getPX(f.data(\\\"top\\\"))+j):f.data(\\\"top\\\",\\\"auto\\\")),f.css(\\\"bottom\\\")&&(\\\"auto\\\"!=f.data(\\\"bottom\\\")?f.css(\\\"bottom\\\",b.helpers.getPX(f.data(\\\"bottom\\\"))+k):f.css(\\\"bottom\\\",\\\"auto\\\")))):b.node.hasClass(f.get(0),\\\"fr-sticky-off\\\")||(f.width(\\\"\\\"),f.removeClass(\\\"fr-sticky-on\\\"),f.addClass(\\\"fr-sticky-off\\\"),f.css(\\\"top\\\")&&\\\"auto\\\"!=f.data(\\\"top\\\")&&h.top&&f.css(\\\"top\\\",0),f.css(\\\"bottom\\\")&&\\\"auto\\\"!=f.data(\\\"bottom\\\")&&h.bottom&&f.css(\\\"bottom\\\",0))}}function j(){var a=document.createElement(\\\"test\\\"),c=a.style;return c.cssText=\\\"position:\\\"+[\\\"-webkit-\\\",\\\"-moz-\\\",\\\"-ms-\\\",\\\"-o-\\\",\\\"\\\"].join(\\\"sticky; position:\\\")+\\\" sticky;\\\",c.position.indexOf(\\\"sticky\\\")!==-1&&!b.helpers.isIOS()&&!b.helpers.isAndroid()&&!b.browser.chrome}function k(){if(!j())if(b._stickyElements=[],b.helpers.isIOS()){var c=function(){b.helpers.requestAnimationFrame()(c);for(var a=0;a<b._stickyElements.length;a++)h(b._stickyElements[a])};c(),b.events.$on(a(b.o_win),\\\"scroll\\\",function(){if(b.core.hasFocus())for(var c=0;c<b._stickyElements.length;c++){var d=a(b._stickyElements[c]),e=d.parent(),f=b.helpers.scrollTop();d.outerHeight()<f-e.offset().top&&(d.addClass(\\\"fr-opacity-0\\\"),d.data(\\\"sticky-top\\\",-1),d.data(\\\"sticky-scheduled\\\",-1))}},!0)}else b.events.$on(a(\\\"body\\\"==b.opts.scrollableContainer?b.o_win:b.opts.scrollableContainer),\\\"scroll\\\",l,!0),b.events.$on(a(b.o_win),\\\"resize\\\",l,!0),b.events.on(\\\"initialized\\\",l),b.events.on(\\\"focus\\\",l),b.events.$on(a(b.o_win),\\\"resize\\\",\\\"textarea\\\",l,!0);b.events.on(\\\"destroy\\\",function(){b._stickyElements=[]})}function l(){if(b._stickyElements)for(var a=0;a<b._stickyElements.length;a++)i(b._stickyElements[a])}function m(a){a.addClass(\\\"fr-sticky\\\"),b.helpers.isIOS()&&a.addClass(\\\"fr-sticky-ios\\\"),j()||b._stickyElements.push(a.get(0))}function n(){k()}return{_init:n,forSelection:f,addSticky:m,refresh:l,at:g,getBoundingRect:c}},a.FE.MODULES.refresh=function(b){function c(a){g(a,!b.undo.canDo())}function d(a){g(a,!b.undo.canRedo())}function e(a){if(b.node.hasClass(a.get(0),\\\"fr-no-refresh\\\"))return!1;for(var c=b.selection.blocks(),d=0;d<c.length;d++){for(var e=c[d].previousSibling;e&&e.nodeType==Node.TEXT_NODE&&0===e.textContent.length;)e=e.previousSibling;if(\\\"LI\\\"!=c[d].tagName||e)return g(a,!1),!0;g(a,!0)}}function f(c){if(b.node.hasClass(c.get(0),\\\"fr-no-refresh\\\"))return!1;for(var d=b.selection.blocks(),e=0;e<d.length;e++){var f=\\\"rtl\\\"==b.opts.direction||\\\"rtl\\\"==a(d[e]).css(\\\"direction\\\")?\\\"margin-right\\\":\\\"margin-left\\\";if(\\\"LI\\\"==d[e].tagName||\\\"LI\\\"==d[e].parentNode.tagName)return g(c,!1),!0;if(b.helpers.getPX(a(d[e]).css(f))>0)return g(c,!1),!0}g(c,!0)}function g(a,b){a.toggleClass(\\\"fr-disabled\\\",b).attr(\\\"aria-disabled\\\",b)}return{undo:c,redo:d,outdent:f,indent:e}},a.extend(a.FE.DEFAULTS,{editInPopup:!1}),a.FE.MODULES.textEdit=function(b){function c(){var a='<div id=\\\"fr-text-edit-'+b.id+'\\\" class=\\\"fr-layer fr-text-edit-layer\\\"><div class=\\\"fr-input-line\\\"><input type=\\\"text\\\" placeholder=\\\"'+b.language.translate(\\\"Text\\\")+'\\\" tabIndex=\\\"1\\\"></div><div class=\\\"fr-action-buttons\\\"><button type=\\\"button\\\" class=\\\"fr-command fr-submit\\\" data-cmd=\\\"updateText\\\" tabIndex=\\\"2\\\">'+b.language.translate(\\\"Update\\\")+\\\"</button></div></div>\\\",c={edit:a};b.popups.create(\\\"text.edit\\\",c)}function d(){var c,d=b.popups.get(\\\"text.edit\\\");c=\\\"INPUT\\\"===b.$el.prop(\\\"tagName\\\")?b.$el.attr(\\\"placeholder\\\"):b.$el.text(),d.find(\\\"input\\\").val(c).trigger(\\\"change\\\"),b.popups.setContainer(\\\"text.edit\\\",a(\\\"body\\\")),b.popups.show(\\\"text.edit\\\",b.$el.offset().left+b.$el.outerWidth()/2,b.$el.offset().top+b.$el.outerHeight(),b.$el.outerHeight())}function e(){b.events.$on(b.$el,b._mouseup,function(){setTimeout(function(){d()},10)})}function f(){var a=b.popups.get(\\\"text.edit\\\"),c=a.find(\\\"input\\\").val();0===c.length&&(c=b.opts.placeholderText),\\\"INPUT\\\"===b.$el.prop(\\\"tagName\\\")?b.$el.attr(\\\"placeholder\\\",c):b.$el.text(c),b.events.trigger(\\\"contentChanged\\\"),b.popups.hide(\\\"text.edit\\\")}function g(){b.opts.editInPopup&&(c(),e())}return{_init:g,update:f}},a.FE.RegisterCommand(\\\"updateText\\\",{focus:!1,undo:!1,callback:function(){this.textEdit.update()}}),a.extend(a.FE.DEFAULTS,{toolbarBottom:!1,toolbarButtons:[\\\"fullscreen\\\",\\\"print\\\",\\\"bold\\\",\\\"italic\\\",\\\"underline\\\",\\\"strikeThrough\\\",\\\"subscript\\\",\\\"superscript\\\",\\\"fontFamily\\\",\\\"fontSize\\\",\\\"|\\\",\\\"specialCharacters\\\",\\\"color\\\",\\\"emoticons\\\",\\\"inlineStyle\\\",\\\"paragraphStyle\\\",\\\"|\\\",\\\"paragraphFormat\\\",\\\"align\\\",\\\"formatOL\\\",\\\"formatUL\\\",\\\"outdent\\\",\\\"indent\\\",\\\"quote\\\",\\\"insertHR\\\",\\\"-\\\",\\\"insertLink\\\",\\\"insertImage\\\",\\\"insertVideo\\\",\\\"insertFile\\\",\\\"insertTable\\\",\\\"undo\\\",\\\"redo\\\",\\\"clearFormatting\\\",\\\"selectAll\\\",\\\"html\\\",\\\"applyFormat\\\",\\\"removeFormat\\\",\\\"help\\\"],toolbarButtonsXS:[\\\"bold\\\",\\\"italic\\\",\\\"fontFamily\\\",\\\"fontSize\\\",\\\"|\\\",\\\"undo\\\",\\\"redo\\\"],toolbarButtonsSM:[\\\"bold\\\",\\\"italic\\\",\\\"underline\\\",\\\"|\\\",\\\"fontFamily\\\",\\\"fontSize\\\",\\\"insertLink\\\",\\\"insertImage\\\",\\\"table\\\",\\\"|\\\",\\\"undo\\\",\\\"redo\\\"],toolbarButtonsMD:[\\\"fullscreen\\\",\\\"bold\\\",\\\"italic\\\",\\\"underline\\\",\\\"fontFamily\\\",\\\"fontSize\\\",\\\"color\\\",\\\"paragraphStyle\\\",\\\"paragraphFormat\\\",\\\"align\\\",\\\"formatOL\\\",\\\"formatUL\\\",\\\"outdent\\\",\\\"indent\\\",\\\"quote\\\",\\\"insertHR\\\",\\\"-\\\",\\\"insertLink\\\",\\\"insertImage\\\",\\\"insertVideo\\\",\\\"insertFile\\\",\\\"insertTable\\\",\\\"undo\\\",\\\"redo\\\",\\\"clearFormatting\\\"],toolbarContainer:null,toolbarInline:!1,toolbarSticky:!0,toolbarStickyOffset:0,toolbarVisibleWithoutSelection:!1}),a.FE.MODULES.toolbar=function(b){function c(a,b){for(var c=0;c<b.length;c++)\\\"-\\\"!=b[c]&&\\\"|\\\"!=b[c]&&a.indexOf(b[c])<0&&a.push(b[c])}function d(){var d=a.merge([],e());c(d,b.opts.toolbarButtonsXS||[]),c(d,b.opts.toolbarButtonsSM||[]),c(d,b.opts.toolbarButtonsMD||[]),c(d,b.opts.toolbarButtons);for(var f=d.length-1;f>=0;f--)\\\"-\\\"!=d[f]&&\\\"|\\\"!=d[f]&&d.indexOf(d[f])<f&&d.splice(f,1);var g=b.button.buildList(d,e());b.$tb.append(g),b.button.bindCommands(b.$tb)}function e(){var a=b.helpers.screenSize();return v[a]}function f(){var a=e();b.$tb.find(\\\".fr-separator\\\").remove(),b.$tb.find(\\\"> .fr-command\\\").addClass(\\\"fr-hidden\\\");for(var c=0;c<a.length;c++)if(\\\"|\\\"==a[c]||\\\"-\\\"==a[c])b.$tb.append(b.button.buildList([a[c]]));else{var d=b.$tb.find('> .fr-command[data-cmd=\\\"'+a[c]+'\\\"]'),f=null;b.node.hasClass(d.next().get(0),\\\"fr-dropdown-menu\\\")&&(f=d.next()),d.removeClass(\\\"fr-hidden\\\").appendTo(b.$tb),f&&f.appendTo(b.$tb)}}function g(){b.events.$on(a(b.o_win),\\\"resize\\\",f),b.events.$on(a(b.o_win),\\\"orientationchange\\\",f)}function h(c,d){setTimeout(function(){if((!c||c.which!=a.FE.KEYCODE.ESC)&&b.selection.inEditor()&&b.core.hasFocus()&&!b.popups.areVisible()&&(b.opts.toolbarVisibleWithoutSelection||!b.selection.isCollapsed()&&!b.keys.isIME()||d)){if(b.$tb.data(\\\"instance\\\",b),b.events.trigger(\\\"toolbar.show\\\",[c])===!1)return!1;b.$tb.show(),b.opts.toolbarContainer||b.position.forSelection(b.$tb),b.opts.zIndex>1?b.$tb.css(\\\"z-index\\\",b.opts.zIndex+1):b.$tb.css(\\\"z-index\\\",null)}},0)}function i(){var a=b.button.getButtons(\\\".fr-dropdown.fr-active\\\");return!!a.next().find(b.o_doc.activeElement).length||void(b.events.trigger(\\\"toolbar.hide\\\")!==!1&&b.$tb.hide())}function j(){return b.events.trigger(\\\"toolbar.show\\\")!==!1&&void b.$tb.show()}function k(c){clearTimeout(w),c&&c.which==a.FE.KEYCODE.ESC||(w=setTimeout(h,b.opts.typingTimer))}function l(){b.events.on(\\\"window.mousedown\\\",i),b.events.on(\\\"keydown\\\",i),b.events.on(\\\"blur\\\",i),b.events.on(\\\"window.mouseup\\\",h),b.helpers.isMobile()?b.helpers.isIOS()||(b.events.on(\\\"window.touchend\\\",h),b.browser.mozilla&&setInterval(h,200)):b.events.on(\\\"window.keyup\\\",k),b.events.on(\\\"keydown\\\",function(b){b&&b.which==a.FE.KEYCODE.ESC&&i()}),b.events.on(\\\"keydown\\\",function(b){if(b.which==a.FE.KEYCODE.ALT)return b.stopPropagation(),!1},!0),b.events.$on(b.$wp,\\\"scroll.toolbar\\\",h),b.events.on(\\\"commands.after\\\",h),b.helpers.isMobile()&&(b.events.$on(b.$doc,\\\"selectionchange\\\",k),b.events.$on(b.$doc,\\\"orientationchange\\\",h))}function m(){b.opts.toolbarInline?(b.$sc.append(b.$tb),b.$tb.data(\\\"container\\\",b.$sc),b.$tb.addClass(\\\"fr-inline\\\"),b.$tb.prepend('<span class=\\\"fr-arrow\\\"></span>'),l(),b.opts.toolbarBottom=!1):(b.opts.toolbarBottom&&!b.helpers.isIOS()?(b.$box.append(b.$tb),b.$tb.addClass(\\\"fr-bottom\\\"),b.$box.addClass(\\\"fr-bottom\\\")):(b.opts.toolbarBottom=!1,b.$box.prepend(b.$tb),b.$tb.addClass(\\\"fr-top\\\"),b.$box.addClass(\\\"fr-top\\\")),b.$tb.addClass(\\\"fr-basic\\\"),b.opts.toolbarSticky&&(b.opts.toolbarStickyOffset&&(b.opts.toolbarBottom?b.$tb.css(\\\"bottom\\\",b.opts.toolbarStickyOffset):b.$tb.css(\\\"top\\\",b.opts.toolbarStickyOffset)),b.position.addSticky(b.$tb)))}function n(){b.$tb.html(\\\"\\\").removeData().remove(),b.$tb=null}function o(){b.$box.removeClass(\\\"fr-top fr-bottom fr-inline fr-basic\\\"),b.$box.find(\\\".fr-sticky-dummy\\\").remove()}function p(){b.opts.theme&&b.$tb.addClass(b.opts.theme+\\\"-theme\\\"),b.opts.zIndex>1&&b.$tb.css(\\\"z-index\\\",b.opts.zIndex+1),\\\"auto\\\"!=b.opts.direction&&b.$tb.removeClass(\\\"fr-ltr fr-rtl\\\").addClass(\\\"fr-\\\"+b.opts.direction),b.helpers.isMobile()?b.$tb.addClass(\\\"fr-mobile\\\"):b.$tb.addClass(\\\"fr-desktop\\\"),b.opts.toolbarContainer?(b.opts.toolbarInline&&(l(),i()),b.opts.toolbarBottom?b.$tb.addClass(\\\"fr-bottom\\\"):b.$tb.addClass(\\\"fr-top\\\")):m(),t=b.$tb.get(0).ownerDocument,u=\\\"defaultView\\\"in t?t.defaultView:t.parentWindow,d(),g(),b.accessibility.registerToolbar(b.$tb),b.events.$on(b.$tb,b._mousedown+\\\" \\\"+b._mouseup,function(a){var c=a.originalEvent?a.originalEvent.target||a.originalEvent.originalTarget:null;if(c&&\\\"INPUT\\\"!=c.tagName&&!b.edit.isDisabled())return a.stopPropagation(),a.preventDefault(),!1},!0)}function q(){return b.$sc=a(b.opts.scrollableContainer),!!b.$wp&&(b.opts.toolbarContainer?(b.shared.$tb?(b.$tb=b.shared.$tb,b.opts.toolbarInline&&l()):(b.shared.$tb=a('<div class=\\\"fr-toolbar\\\"></div>'),b.$tb=b.shared.$tb,a(b.opts.toolbarContainer).append(b.$tb),p(),b.$tb.data(\\\"instance\\\",b)),b.opts.toolbarInline?b.$box.addClass(\\\"fr-inline\\\"):b.$box.addClass(\\\"fr-basic\\\"),b.events.on(\\\"focus\\\",function(){b.$tb.data(\\\"instance\\\",b)},!0),b.opts.toolbarInline=!1):b.opts.toolbarInline?(b.$box.addClass(\\\"fr-inline\\\"),b.shared.$tb?(b.$tb=b.shared.$tb,l()):(b.shared.$tb=a('<div class=\\\"fr-toolbar\\\"></div>'),b.$tb=b.shared.$tb,p())):(b.$box.addClass(\\\"fr-basic\\\"),b.$tb=a('<div class=\\\"fr-toolbar\\\"></div>'),p(),b.$tb.data(\\\"instance\\\",b)),b.events.on(\\\"destroy\\\",o,!0),void b.events.on(b.opts.toolbarInline||b.opts.toolbarContainer?\\\"shared.destroy\\\":\\\"destroy\\\",n,!0))}function r(){!x&&b.$tb&&(b.$tb.find(\\\"> .fr-command\\\").addClass(\\\"fr-disabled fr-no-refresh\\\").attr(\\\"aria-disabled\\\",!0),x=!0)}function s(){x&&b.$tb&&(b.$tb.find(\\\"> .fr-command\\\").removeClass(\\\"fr-disabled fr-no-refresh\\\").attr(\\\"aria-disabled\\\",!1),x=!1),b.button.bulkRefresh()}var t,u,v=[];v[a.FE.XS]=b.opts.toolbarButtonsXS||b.opts.toolbarButtons,v[a.FE.SM]=b.opts.toolbarButtonsSM||b.opts.toolbarButtons,v[a.FE.MD]=b.opts.toolbarButtonsMD||b.opts.toolbarButtons,v[a.FE.LG]=b.opts.toolbarButtons;var w=null,x=!1;return{_init:q,hide:i,show:j,showInline:h,disable:r,enable:s}}});\"//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL34vZnJvYWxhLWVkaXRvci9qcy9mcm9hbGFfZWRpdG9yLm1pbi5qcz81NDRiIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gXCIvKiFcXG4gKiBmcm9hbGFfZWRpdG9yIHYyLjUuMCAoaHR0cHM6Ly93d3cuZnJvYWxhLmNvbS93eXNpd3lnLWVkaXRvcilcXG4gKiBMaWNlbnNlIGh0dHBzOi8vZnJvYWxhLmNvbS93eXNpd3lnLWVkaXRvci90ZXJtcy9cXG4gKiBDb3B5cmlnaHQgMjAxNC0yMDE3IEZyb2FsYSBMYWJzXFxuICovXFxuXFxuIWZ1bmN0aW9uKGEpe1xcXCJmdW5jdGlvblxcXCI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQ/ZGVmaW5lKFtcXFwianF1ZXJ5XFxcIl0sYSk6XFxcIm9iamVjdFxcXCI9PXR5cGVvZiBtb2R1bGUmJm1vZHVsZS5leHBvcnRzP21vZHVsZS5leHBvcnRzPWZ1bmN0aW9uKGIsYyl7cmV0dXJuIHZvaWQgMD09PWMmJihjPVxcXCJ1bmRlZmluZWRcXFwiIT10eXBlb2Ygd2luZG93P3JlcXVpcmUoXFxcImpxdWVyeVxcXCIpOnJlcXVpcmUoXFxcImpxdWVyeVxcXCIpKGIpKSxhKGMpfTphKHdpbmRvdy5qUXVlcnkpfShmdW5jdGlvbihhKXt2YXIgYj1mdW5jdGlvbihjLGQpe3RoaXMuaWQ9KythLkZFLklELHRoaXMub3B0cz1hLmV4dGVuZCghMCx7fSxhLmV4dGVuZCh7fSxiLkRFRkFVTFRTLFxcXCJvYmplY3RcXFwiPT10eXBlb2YgZCYmZCkpO3ZhciBlPUpTT04uc3RyaW5naWZ5KHRoaXMub3B0cyk7YS5GRS5PUFRTX01BUFBJTkdbZV09YS5GRS5PUFRTX01BUFBJTkdbZV18fHRoaXMuaWQsdGhpcy5zaWQ9YS5GRS5PUFRTX01BUFBJTkdbZV0sYS5GRS5TSEFSRURbdGhpcy5zaWRdPWEuRkUuU0hBUkVEW3RoaXMuc2lkXXx8e30sdGhpcy5zaGFyZWQ9YS5GRS5TSEFSRURbdGhpcy5zaWRdLHRoaXMuc2hhcmVkLmNvdW50PSh0aGlzLnNoYXJlZC5jb3VudHx8MCkrMSx0aGlzLiRvZWw9YShjKSx0aGlzLiRvZWwuZGF0YShcXFwiZnJvYWxhLmVkaXRvclxcXCIsdGhpcyksdGhpcy5vX2RvYz1jLm93bmVyRG9jdW1lbnQsdGhpcy5vX3dpbj1cXFwiZGVmYXVsdFZpZXdcXFwiaW4gdGhpcy5vX2RvYz90aGlzLm9fZG9jLmRlZmF1bHRWaWV3OnRoaXMub19kb2MucGFyZW50V2luZG93O3ZhciBmPWEodGhpcy5vX3dpbikuc2Nyb2xsVG9wKCk7dGhpcy4kb2VsLm9uKFxcXCJmcm9hbGEuZG9Jbml0XFxcIixhLnByb3h5KGZ1bmN0aW9uKCl7dGhpcy4kb2VsLm9mZihcXFwiZnJvYWxhLmRvSW5pdFxcXCIpLHRoaXMuZG9jPXRoaXMuJGVsLmdldCgwKS5vd25lckRvY3VtZW50LHRoaXMud2luPVxcXCJkZWZhdWx0Vmlld1xcXCJpbiB0aGlzLmRvYz90aGlzLmRvYy5kZWZhdWx0Vmlldzp0aGlzLmRvYy5wYXJlbnRXaW5kb3csdGhpcy4kZG9jPWEodGhpcy5kb2MpLHRoaXMuJHdpbj1hKHRoaXMud2luKSx0aGlzLm9wdHMucGx1Z2luc0VuYWJsZWR8fCh0aGlzLm9wdHMucGx1Z2luc0VuYWJsZWQ9T2JqZWN0LmtleXMoYS5GRS5QTFVHSU5TKSksdGhpcy5vcHRzLmluaXRPbkNsaWNrPyh0aGlzLmxvYWQoYS5GRS5NT0RVTEVTKSx0aGlzLiRlbC5vbihcXFwidG91Y2hzdGFydC5pbml0XFxcIixmdW5jdGlvbigpe2EodGhpcykuZGF0YShcXFwidG91Y2hlZFxcXCIsITApfSksdGhpcy4kZWwub24oXFxcInRvdWNobW92ZS5pbml0XFxcIixmdW5jdGlvbigpe2EodGhpcykucmVtb3ZlRGF0YShcXFwidG91Y2hlZFxcXCIpfSksdGhpcy4kZWwub24oXFxcIm1vdXNlZG93bi5pbml0IHRvdWNoZW5kLmluaXQgZHJhZ2VudGVyLmluaXQgZm9jdXMuaW5pdFxcXCIsYS5wcm94eShmdW5jdGlvbihiKXtpZihcXFwidG91Y2hlbmRcXFwiPT1iLnR5cGUmJiF0aGlzLiRlbC5kYXRhKFxcXCJ0b3VjaGVkXFxcIikpcmV0dXJuITA7aWYoMT09PWIud2hpY2h8fCFiLndoaWNoKXt0aGlzLiRlbC5vZmYoXFxcIm1vdXNlZG93bi5pbml0IHRvdWNoc3RhcnQuaW5pdCB0b3VjaG1vdmUuaW5pdCB0b3VjaGVuZC5pbml0IGRyYWdlbnRlci5pbml0IGZvY3VzLmluaXRcXFwiKSx0aGlzLmxvYWQoYS5GRS5NT0RVTEVTKSx0aGlzLmxvYWQoYS5GRS5QTFVHSU5TKTt2YXIgYz1iLm9yaWdpbmFsRXZlbnQmJmIub3JpZ2luYWxFdmVudC5vcmlnaW5hbFRhcmdldDtjJiZcXFwiSU1HXFxcIj09Yy50YWdOYW1lJiZhKGMpLnRyaWdnZXIoXFxcIm1vdXNlZG93blxcXCIpLFxcXCJ1bmRlZmluZWRcXFwiPT10eXBlb2YgdGhpcy51bCYmdGhpcy5kZXN0cm95KCksXFxcInRvdWNoZW5kXFxcIj09Yi50eXBlJiZ0aGlzLmltYWdlJiZiLm9yaWdpbmFsRXZlbnQmJmIub3JpZ2luYWxFdmVudC50YXJnZXQmJmEoYi5vcmlnaW5hbEV2ZW50LnRhcmdldCkuaXMoXFxcImltZ1xcXCIpJiZzZXRUaW1lb3V0KGEucHJveHkoZnVuY3Rpb24oKXt0aGlzLmltYWdlLmVkaXQoYShiLm9yaWdpbmFsRXZlbnQudGFyZ2V0KSl9LHRoaXMpLDEwMCksdGhpcy5yZWFkeT0hMCx0aGlzLmV2ZW50cy50cmlnZ2VyKFxcXCJpbml0aWFsaXplZFxcXCIpfX0sdGhpcykpKToodGhpcy5sb2FkKGEuRkUuTU9EVUxFUyksdGhpcy5sb2FkKGEuRkUuUExVR0lOUyksYSh0aGlzLm9fd2luKS5zY3JvbGxUb3AoZiksXFxcInVuZGVmaW5lZFxcXCI9PXR5cGVvZiB0aGlzLnVsJiZ0aGlzLmRlc3Ryb3koKSx0aGlzLnJlYWR5PSEwLHRoaXMuZXZlbnRzLnRyaWdnZXIoXFxcImluaXRpYWxpemVkXFxcIikpfSx0aGlzKSksdGhpcy5faW5pdCgpfTtiLkRFRkFVTFRTPXtpbml0T25DbGljazohMSxwbHVnaW5zRW5hYmxlZDpudWxsfSxiLk1PRFVMRVM9e30sYi5QTFVHSU5TPXt9LGIuVkVSU0lPTj1cXFwiMi41LjBcXFwiLGIuSU5TVEFOQ0VTPVtdLGIuT1BUU19NQVBQSU5HPXt9LGIuU0hBUkVEPXt9LGIuSUQ9MCxiLnByb3RvdHlwZS5faW5pdD1mdW5jdGlvbigpe3ZhciBiPXRoaXMuJG9lbC5wcm9wKFxcXCJ0YWdOYW1lXFxcIik7dGhpcy4kb2VsLmNsb3Nlc3QoXFxcImxhYmVsXFxcIikubGVuZ3RoPj0xJiZjb25zb2xlLndhcm4oXFxcIk5vdGUhIEl0IGlzIG5vdCByZWNvbW1lbmRlZCB0byBpbml0aWFsaXplIHRoZSBGcm9hbGEgRWRpdG9yIHdpdGhpbiBhIGxhYmVsIHRhZy5cXFwiKTt2YXIgYz1hLnByb3h5KGZ1bmN0aW9uKCl7XFxcIlRFWFRBUkVBXFxcIiE9YiYmKHRoaXMuX29yaWdpbmFsX2h0bWw9dGhpcy5fb3JpZ2luYWxfaHRtbHx8dGhpcy4kb2VsLmh0bWwoKSksdGhpcy4kYm94PXRoaXMuJGJveHx8dGhpcy4kb2VsLHRoaXMub3B0cy5mdWxsUGFnZSYmKHRoaXMub3B0cy5pZnJhbWU9ITApLHRoaXMub3B0cy5pZnJhbWU/KHRoaXMuJGlmcmFtZT1hKCc8aWZyYW1lIHNyYz1cXFwiYWJvdXQ6YmxhbmtcXFwiIGZyYW1lQm9yZGVyPVxcXCIwXFxcIj4nKSx0aGlzLiR3cD1hKFxcXCI8ZGl2PjwvZGl2PlxcXCIpLHRoaXMuJGJveC5odG1sKHRoaXMuJHdwKSx0aGlzLiR3cC5hcHBlbmQodGhpcy4kaWZyYW1lKSx0aGlzLiRpZnJhbWUuZ2V0KDApLmNvbnRlbnRXaW5kb3cuZG9jdW1lbnQub3BlbigpLHRoaXMuJGlmcmFtZS5nZXQoMCkuY29udGVudFdpbmRvdy5kb2N1bWVudC53cml0ZShcXFwiPCFET0NUWVBFIGh0bWw+XFxcIiksdGhpcy4kaWZyYW1lLmdldCgwKS5jb250ZW50V2luZG93LmRvY3VtZW50LndyaXRlKFxcXCI8aHRtbD48aGVhZD48L2hlYWQ+PGJvZHk+PC9ib2R5PjwvaHRtbD5cXFwiKSx0aGlzLiRpZnJhbWUuZ2V0KDApLmNvbnRlbnRXaW5kb3cuZG9jdW1lbnQuY2xvc2UoKSx0aGlzLiRlbD10aGlzLiRpZnJhbWUuY29udGVudHMoKS5maW5kKFxcXCJib2R5XFxcIiksdGhpcy5lbD10aGlzLiRlbC5nZXQoMCksdGhpcy4kaGVhZD10aGlzLiRpZnJhbWUuY29udGVudHMoKS5maW5kKFxcXCJoZWFkXFxcIiksdGhpcy4kaHRtbD10aGlzLiRpZnJhbWUuY29udGVudHMoKS5maW5kKFxcXCJodG1sXFxcIiksdGhpcy5pZnJhbWVfZG9jdW1lbnQ9dGhpcy4kaWZyYW1lLmdldCgwKS5jb250ZW50V2luZG93LmRvY3VtZW50LHRoaXMuJG9lbC50cmlnZ2VyKFxcXCJmcm9hbGEuZG9Jbml0XFxcIikpOih0aGlzLiRlbD1hKFxcXCI8ZGl2PjwvZGl2PlxcXCIpLHRoaXMuZWw9dGhpcy4kZWwuZ2V0KDApLHRoaXMuJHdwPWEoXFxcIjxkaXY+PC9kaXY+XFxcIikuYXBwZW5kKHRoaXMuJGVsKSx0aGlzLiRib3guaHRtbCh0aGlzLiR3cCksdGhpcy4kb2VsLnRyaWdnZXIoXFxcImZyb2FsYS5kb0luaXRcXFwiKSl9LHRoaXMpLGQ9YS5wcm94eShmdW5jdGlvbigpe3RoaXMuJGJveD1hKFxcXCI8ZGl2PlxcXCIpLHRoaXMuJG9lbC5iZWZvcmUodGhpcy4kYm94KS5oaWRlKCksdGhpcy5fb3JpZ2luYWxfaHRtbD10aGlzLiRvZWwudmFsKCksdGhpcy4kb2VsLnBhcmVudHMoXFxcImZvcm1cXFwiKS5vbihcXFwic3VibWl0LlxcXCIrdGhpcy5pZCxhLnByb3h5KGZ1bmN0aW9uKCl7dGhpcy5ldmVudHMudHJpZ2dlcihcXFwiZm9ybS5zdWJtaXRcXFwiKX0sdGhpcykpLHRoaXMuJG9lbC5wYXJlbnRzKFxcXCJmb3JtXFxcIikub24oXFxcInJlc2V0LlxcXCIrdGhpcy5pZCxhLnByb3h5KGZ1bmN0aW9uKCl7dGhpcy5ldmVudHMudHJpZ2dlcihcXFwiZm9ybS5yZXNldFxcXCIpfSx0aGlzKSksYygpfSx0aGlzKSxlPWEucHJveHkoZnVuY3Rpb24oKXt0aGlzLiRlbD10aGlzLiRvZWwsdGhpcy5lbD10aGlzLiRlbC5nZXQoMCksdGhpcy4kZWwuYXR0cihcXFwiY29udGVudGVkaXRhYmxlXFxcIiwhMCkuY3NzKFxcXCJvdXRsaW5lXFxcIixcXFwibm9uZVxcXCIpLmNzcyhcXFwiZGlzcGxheVxcXCIsXFxcImlubGluZS1ibG9ja1xcXCIpLHRoaXMub3B0cy5tdWx0aUxpbmU9ITEsdGhpcy5vcHRzLnRvb2xiYXJJbmxpbmU9ITEsdGhpcy4kb2VsLnRyaWdnZXIoXFxcImZyb2FsYS5kb0luaXRcXFwiKX0sdGhpcyksZj1hLnByb3h5KGZ1bmN0aW9uKCl7dGhpcy4kZWw9dGhpcy4kb2VsLHRoaXMuZWw9dGhpcy4kZWwuZ2V0KDApLHRoaXMub3B0cy50b29sYmFySW5saW5lPSExLHRoaXMuJG9lbC50cmlnZ2VyKFxcXCJmcm9hbGEuZG9Jbml0XFxcIil9LHRoaXMpLGc9YS5wcm94eShmdW5jdGlvbigpe3RoaXMuJGVsPXRoaXMuJG9lbCx0aGlzLmVsPXRoaXMuJGVsLmdldCgwKSx0aGlzLm9wdHMudG9vbGJhcklubGluZT0hMSx0aGlzLiRvZWwub24oXFxcImNsaWNrLnBvcHVwXFxcIixmdW5jdGlvbihhKXthLnByZXZlbnREZWZhdWx0KCl9KSx0aGlzLiRvZWwudHJpZ2dlcihcXFwiZnJvYWxhLmRvSW5pdFxcXCIpfSx0aGlzKTt0aGlzLm9wdHMuZWRpdEluUG9wdXA/ZygpOlxcXCJURVhUQVJFQVxcXCI9PWI/ZCgpOlxcXCJBXFxcIj09Yj9lKCk6XFxcIklNR1xcXCI9PWI/ZigpOlxcXCJCVVRUT05cXFwiPT1ifHxcXFwiSU5QVVRcXFwiPT1iPyh0aGlzLm9wdHMuZWRpdEluUG9wdXA9ITAsdGhpcy5vcHRzLnRvb2xiYXJJbmxpbmU9ITEsZygpKTpjKCl9LGIucHJvdG90eXBlLmxvYWQ9ZnVuY3Rpb24oYil7Zm9yKHZhciBjIGluIGIpaWYoYi5oYXNPd25Qcm9wZXJ0eShjKSl7aWYodGhpc1tjXSljb250aW51ZTtpZihhLkZFLlBMVUdJTlNbY10mJnRoaXMub3B0cy5wbHVnaW5zRW5hYmxlZC5pbmRleE9mKGMpPDApY29udGludWU7aWYodGhpc1tjXT1uZXcgYltjXSh0aGlzKSx0aGlzW2NdLl9pbml0JiYodGhpc1tjXS5faW5pdCgpLHRoaXMub3B0cy5pbml0T25DbGljayYmXFxcImNvcmVcXFwiPT1jKSlyZXR1cm4hMX19LGIucHJvdG90eXBlLmRlc3Ryb3k9ZnVuY3Rpb24oKXt0aGlzLnNoYXJlZC5jb3VudC0tLHRoaXMuZXZlbnRzLiRvZmYoKTt2YXIgYj10aGlzLmh0bWwuZ2V0KCk7aWYodGhpcy5ldmVudHMudHJpZ2dlcihcXFwiZGVzdHJveVxcXCIsW10sITApLHRoaXMuZXZlbnRzLnRyaWdnZXIoXFxcInNoYXJlZC5kZXN0cm95XFxcIix2b2lkIDAsITApLDA9PT10aGlzLnNoYXJlZC5jb3VudCl7Zm9yKHZhciBjIGluIHRoaXMuc2hhcmVkKXRoaXMuc2hhcmVkLmhhc093blByb3BlcnR5KGMpJiYobnVsbD09dGhpcy5zaGFyZWRbY10sYS5GRS5TSEFSRURbdGhpcy5zaWRdW2NdPW51bGwpO2EuRkUuU0hBUkVEW3RoaXMuc2lkXT17fX10aGlzLiRvZWwucGFyZW50cyhcXFwiZm9ybVxcXCIpLm9mZihcXFwiLlxcXCIrdGhpcy5pZCksdGhpcy4kb2VsLm9mZihcXFwiY2xpY2sucG9wdXBcXFwiKSx0aGlzLiRvZWwucmVtb3ZlRGF0YShcXFwiZnJvYWxhLmVkaXRvclxcXCIpLHRoaXMuJG9lbC5vZmYoXFxcImZyb2FsYUVkaXRvclxcXCIpLHRoaXMuY29yZS5kZXN0cm95KGIpLGEuRkUuSU5TVEFOQ0VTLnNwbGljZShhLkZFLklOU1RBTkNFUy5pbmRleE9mKHRoaXMpLDEpfSxhLmZuLmZyb2FsYUVkaXRvcj1mdW5jdGlvbihjKXtmb3IodmFyIGQ9W10sZT0wO2U8YXJndW1lbnRzLmxlbmd0aDtlKyspZC5wdXNoKGFyZ3VtZW50c1tlXSk7aWYoXFxcInN0cmluZ1xcXCI9PXR5cGVvZiBjKXt2YXIgZj1bXTtyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCl7dmFyIGI9YSh0aGlzKSxlPWIuZGF0YShcXFwiZnJvYWxhLmVkaXRvclxcXCIpO2lmKCFlKXJldHVybiBjb25zb2xlLndhcm4oXFxcIkVkaXRvciBzaG91bGQgYmUgaW5pdGlhbGl6ZWQgYmVmb3JlIGNhbGxpbmcgdGhlIFxcXCIrYytcXFwiIG1ldGhvZC5cXFwiKTt2YXIgZyxoO2lmKGMuaW5kZXhPZihcXFwiLlxcXCIpPjAmJmVbYy5zcGxpdChcXFwiLlxcXCIpWzBdXT8oZVtjLnNwbGl0KFxcXCIuXFxcIilbMF1dJiYoZz1lW2Muc3BsaXQoXFxcIi5cXFwiKVswXV0pLGg9Yy5zcGxpdChcXFwiLlxcXCIpWzFdKTooZz1lLGg9Yy5zcGxpdChcXFwiLlxcXCIpWzBdKSwhZ1toXSlyZXR1cm4gYS5lcnJvcihcXFwiTWV0aG9kIFxcXCIrYytcXFwiIGRvZXMgbm90IGV4aXN0IGluIEZyb2FsYSBFZGl0b3IuXFxcIik7dmFyIGk9Z1toXS5hcHBseShlLGQuc2xpY2UoMSkpO3ZvaWQgMD09PWk/Zi5wdXNoKHRoaXMpOjA9PT1mLmxlbmd0aCYmZi5wdXNoKGkpfSksMT09Zi5sZW5ndGg/ZlswXTpmfWlmKFxcXCJvYmplY3RcXFwiPT10eXBlb2YgY3x8IWMpcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpe3ZhciBkPWEodGhpcykuZGF0YShcXFwiZnJvYWxhLmVkaXRvclxcXCIpO2lmKCFkKXt2YXIgZT10aGlzO25ldyBiKGUsYyl9fSl9LGEuZm4uZnJvYWxhRWRpdG9yLkNvbnN0cnVjdG9yPWIsYS5Gcm9hbGFFZGl0b3I9YixhLkZFPWIsYS5GRS5YUz0wLGEuRkUuU009MSxhLkZFLk1EPTIsYS5GRS5MRz0zLGEuRkUuTU9EVUxFUy5oZWxwZXJzPWZ1bmN0aW9uKGIpe2Z1bmN0aW9uIGMoKXt2YXIgYSxiLGM9LTE7cmV0dXJuXFxcIk1pY3Jvc29mdCBJbnRlcm5ldCBFeHBsb3JlclxcXCI9PW5hdmlnYXRvci5hcHBOYW1lPyhhPW5hdmlnYXRvci51c2VyQWdlbnQsYj1uZXcgUmVnRXhwKFxcXCJNU0lFIChbMC05XXsxLH1bXFxcXFxcXFwuMC05XXswLH0pXFxcIiksbnVsbCE9PWIuZXhlYyhhKSYmKGM9cGFyc2VGbG9hdChSZWdFeHAuJDEpKSk6XFxcIk5ldHNjYXBlXFxcIj09bmF2aWdhdG9yLmFwcE5hbWUmJihhPW5hdmlnYXRvci51c2VyQWdlbnQsYj1uZXcgUmVnRXhwKFxcXCJUcmlkZW50Ly4qcnY6KFswLTldezEsfVtcXFxcXFxcXC4wLTldezAsfSlcXFwiKSxudWxsIT09Yi5leGVjKGEpJiYoYz1wYXJzZUZsb2F0KFJlZ0V4cC4kMSkpKSxjfWZ1bmN0aW9uIGQoKXt2YXIgYT17fSxiPWMoKTtpZihiPjApYS5tc2llPSEwO2Vsc2V7dmFyIGQ9bmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLGU9LyhlZGdlKVsgXFxcXC9dKFtcXFxcdy5dKykvLmV4ZWMoZCl8fC8oY2hyb21lKVsgXFxcXC9dKFtcXFxcdy5dKykvLmV4ZWMoZCl8fC8od2Via2l0KVsgXFxcXC9dKFtcXFxcdy5dKykvLmV4ZWMoZCl8fC8ob3BlcmEpKD86Lip2ZXJzaW9ufClbIFxcXFwvXShbXFxcXHcuXSspLy5leGVjKGQpfHwvKG1zaWUpIChbXFxcXHcuXSspLy5leGVjKGQpfHxkLmluZGV4T2YoXFxcImNvbXBhdGlibGVcXFwiKTwwJiYvKG1vemlsbGEpKD86Lio/IHJ2OihbXFxcXHcuXSspfCkvLmV4ZWMoZCl8fFtdLGY9e2Jyb3dzZXI6ZVsxXXx8XFxcIlxcXCIsdmVyc2lvbjplWzJdfHxcXFwiMFxcXCJ9O2VbMV0mJihhW2YuYnJvd3Nlcl09ITApLGEuY2hyb21lP2Eud2Via2l0PSEwOmEud2Via2l0JiYoYS5zYWZhcmk9ITApfXJldHVybiBhLm1zaWUmJihhLnZlcnNpb249YiksYX1mdW5jdGlvbiBlKCl7cmV0dXJuLyhpUGFkfGlQaG9uZXxpUG9kKS9nLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkmJiFoKCl9ZnVuY3Rpb24gZigpe3JldHVybi8oQW5kcm9pZCkvZy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpJiYhaCgpfWZ1bmN0aW9uIGcoKXtyZXR1cm4vKEJsYWNrYmVycnkpL2cudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KX1mdW5jdGlvbiBoKCl7cmV0dXJuLyhXaW5kb3dzIFBob25lKS9naS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpfWZ1bmN0aW9uIGkoKXtyZXR1cm4gZigpfHxlKCl8fGcoKX1mdW5jdGlvbiBqKCl7cmV0dXJuIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWV8fHdpbmRvdy53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWV8fHdpbmRvdy5tb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWV8fGZ1bmN0aW9uKGEpe3dpbmRvdy5zZXRUaW1lb3V0KGEsMWUzLzYwKX19ZnVuY3Rpb24gayhhKXtyZXR1cm4gcGFyc2VJbnQoYSwxMCl8fDB9ZnVuY3Rpb24gbCgpe3ZhciBiPWEoJzxkaXYgY2xhc3M9XFxcImZyLXZpc2liaWxpdHktaGVscGVyXFxcIj48L2Rpdj4nKS5hcHBlbmRUbyhcXFwiYm9keVxcXCIpLGM9ayhiLmNzcyhcXFwibWFyZ2luLWxlZnRcXFwiKSk7cmV0dXJuIGIucmVtb3ZlKCksY31mdW5jdGlvbiBtKCl7cmV0dXJuXFxcIm9udG91Y2hzdGFydFxcXCJpbiB3aW5kb3d8fHdpbmRvdy5Eb2N1bWVudFRvdWNoJiZkb2N1bWVudCBpbnN0YW5jZW9mIERvY3VtZW50VG91Y2h9ZnVuY3Rpb24gbihhKXtpZighL14oaHR0cHM/OnxmdHBzPzp8KVxcXFwvXFxcXC8vaS50ZXN0KGEpKXJldHVybiExO2E9U3RyaW5nKGEpLnJlcGxhY2UoLzwvZyxcXFwiJTNDXFxcIikucmVwbGFjZSgvPi9nLFxcXCIlM0VcXFwiKS5yZXBsYWNlKC9cXFwiL2csXFxcIiUyMlxcXCIpLnJlcGxhY2UoLyAvZyxcXFwiJTIwXFxcIik7dmFyIGI9LyhodHRwfGZ0cHxodHRwcyk6XFxcXC9cXFxcL1thLXpcXFxcdTAwYTEtXFxcXHVmZmZmMC05e31dKyhcXFxcLlthLXpcXFxcdTAwYTEtXFxcXHVmZmZmMC05e31dKikqKFthLXpcXFxcdTAwYTEtXFxcXHVmZmZmMC05LixAP149JSZhbXA7OlxcXFwvfisjLV97fV0qW2EtelxcXFx1MDBhMS1cXFxcdWZmZmYwLTlAP149JSZhbXA7XFxcXC9+KyMtX3t9XSk/L2dpO3JldHVybiBiLnRlc3QoYSl9ZnVuY3Rpb24gbyhhKXtpZigvXihodHRwcz86fGZ0cHM/OnwpXFxcXC9cXFxcLy9pLnRlc3QoYSkpe2lmKCFuKGEpJiYhbihcXFwiaHR0cDpcXFwiK2EpKXJldHVyblxcXCJcXFwifWVsc2UgYT1lbmNvZGVVUklDb21wb25lbnQoYSkucmVwbGFjZSgvJTIzL2csXFxcIiNcXFwiKS5yZXBsYWNlKC8lMkYvZyxcXFwiL1xcXCIpLnJlcGxhY2UoLyUyNS9nLFxcXCIlXFxcIikucmVwbGFjZSgvbWFpbHRvJTNBL2dpLFxcXCJtYWlsdG86XFxcIikucmVwbGFjZSgvZmlsZSUzQS9naSxcXFwiZmlsZTpcXFwiKS5yZXBsYWNlKC9zbXMlM0EvZ2ksXFxcInNtczpcXFwiKS5yZXBsYWNlKC90ZWwlM0EvZ2ksXFxcInRlbDpcXFwiKS5yZXBsYWNlKC9ub3RlcyUzQS9naSxcXFwibm90ZXM6XFxcIikucmVwbGFjZSgvZGF0YSUzQWltYWdlL2dpLFxcXCJkYXRhOmltYWdlXFxcIikucmVwbGFjZSgvYmxvYiUzQS9naSxcXFwiYmxvYjpcXFwiKS5yZXBsYWNlKC93ZWJraXQtZmFrZS11cmwlM0EvZ2ksXFxcIndlYmtpdC1mYWtlLXVybDpcXFwiKS5yZXBsYWNlKC8lM0YvZyxcXFwiP1xcXCIpLnJlcGxhY2UoLyUzRC9nLFxcXCI9XFxcIikucmVwbGFjZSgvJTI2L2csXFxcIiZcXFwiKS5yZXBsYWNlKC8mYW1wOy9nLFxcXCImXFxcIikucmVwbGFjZSgvJTJDL2csXFxcIixcXFwiKS5yZXBsYWNlKC8lM0IvZyxcXFwiO1xcXCIpLnJlcGxhY2UoLyUyQi9nLFxcXCIrXFxcIikucmVwbGFjZSgvJTQwL2csXFxcIkBcXFwiKS5yZXBsYWNlKC8lNUIvZyxcXFwiW1xcXCIpLnJlcGxhY2UoLyU1RC9nLFxcXCJdXFxcIikucmVwbGFjZSgvJTdCL2csXFxcIntcXFwiKS5yZXBsYWNlKC8lN0QvZyxcXFwifVxcXCIpO3JldHVybiBhfWZ1bmN0aW9uIHAoYSl7cmV0dXJuIGEmJiFhLnByb3BlcnR5SXNFbnVtZXJhYmxlKFxcXCJsZW5ndGhcXFwiKSYmXFxcIm9iamVjdFxcXCI9PXR5cGVvZiBhJiZcXFwibnVtYmVyXFxcIj09dHlwZW9mIGEubGVuZ3RofWZ1bmN0aW9uIHEoYSl7ZnVuY3Rpb24gYihhKXtyZXR1cm4oXFxcIjBcXFwiK3BhcnNlSW50KGEsMTApLnRvU3RyaW5nKDE2KSkuc2xpY2UoLTIpfXRyeXtyZXR1cm4gYSYmXFxcInRyYW5zcGFyZW50XFxcIiE9PWE/L14jWzAtOUEtRl17Nn0kL2kudGVzdChhKT9hOihhPWEubWF0Y2goL15yZ2JcXFxcKChcXFxcZCspLFxcXFxzKihcXFxcZCspLFxcXFxzKihcXFxcZCspXFxcXCkkLyksKFxcXCIjXFxcIitiKGFbMV0pK2IoYVsyXSkrYihhWzNdKSkudG9VcHBlckNhc2UoKSk6XFxcIlxcXCJ9Y2F0Y2goYyl7cmV0dXJuIG51bGx9fWZ1bmN0aW9uIHIoYSl7dmFyIGI9L14jPyhbYS1mXFxcXGRdKShbYS1mXFxcXGRdKShbYS1mXFxcXGRdKSQvaTthPWEucmVwbGFjZShiLGZ1bmN0aW9uKGEsYixjLGQpe3JldHVybiBiK2IrYytjK2QrZH0pO3ZhciBjPS9eIz8oW2EtZlxcXFxkXXsyfSkoW2EtZlxcXFxkXXsyfSkoW2EtZlxcXFxkXXsyfSkkL2kuZXhlYyhhKTtyZXR1cm4gYz9cXFwicmdiKFxcXCIrcGFyc2VJbnQoY1sxXSwxNikrXFxcIiwgXFxcIitwYXJzZUludChjWzJdLDE2KStcXFwiLCBcXFwiK3BhcnNlSW50KGNbM10sMTYpK1xcXCIpXFxcIjpcXFwiXFxcIn1mdW5jdGlvbiBzKGIpe3ZhciBjPShiLmNzcyhcXFwidGV4dC1hbGlnblxcXCIpfHxcXFwiXFxcIikucmVwbGFjZSgvLSguKiktL2csXFxcIlxcXCIpO2lmKFtcXFwibGVmdFxcXCIsXFxcInJpZ2h0XFxcIixcXFwianVzdGlmeVxcXCIsXFxcImNlbnRlclxcXCJdLmluZGV4T2YoYyk8MCl7aWYoIXkpe3ZhciBkPWEoJzxkaXYgZGlyPVxcXCJhdXRvXFxcIiBzdHlsZT1cXFwidGV4dC1hbGlnbjogaW5pdGlhbDsgcG9zaXRpb246IGZpeGVkOyBsZWZ0OiAtMzAwMHB4O1xcXCI+PHNwYW4gaWQ9XFxcInMxXFxcIj4uPC9zcGFuPjxzcGFuIGlkPVxcXCJzMlxcXCI+Ljwvc3Bhbj48L2Rpdj4nKTthKFxcXCJib2R5XFxcIikuYXBwZW5kKGQpO3ZhciBlPWQuZmluZChcXFwiI3MxXFxcIikuZ2V0KDApLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQsZj1kLmZpbmQoXFxcIiNzMlxcXCIpLmdldCgwKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0O2QucmVtb3ZlKCkseT1lPGY/XFxcImxlZnRcXFwiOlxcXCJyaWdodFxcXCJ9Yz15fXJldHVybiBjfWZ1bmN0aW9uIHQoKXtyZXR1cm4gbnVsbD09eiYmKHo9bmF2aWdhdG9yLnBsYXRmb3JtLnRvVXBwZXJDYXNlKCkuaW5kZXhPZihcXFwiTUFDXFxcIik+PTApLHp9ZnVuY3Rpb24gdSgpe2Z1bmN0aW9uIGEoYSxiKXt2YXIgZD1hW2JdO2FbYl09ZnVuY3Rpb24oYSl7dmFyIGIsZj0hMSxnPSExO2lmKGEmJmEubWF0Y2goZSkpe2E9YS5yZXBsYWNlKGUsXFxcIlxcXCIpLHRoaXMucGFyZW50Tm9kZXx8KGMuYXBwZW5kQ2hpbGQodGhpcyksZz0hMCk7dmFyIGg9dGhpcy5wYXJlbnROb2RlO3JldHVybiB0aGlzLmlkfHwodGhpcy5pZD1cXFwicm9vdGVkUXVlcnlTZWxlY3Rvcl9pZF9cXFwiKyhuZXcgRGF0ZSkuZ2V0VGltZSgpLGY9ITApLGI9ZC5jYWxsKGgsXFxcIiNcXFwiK3RoaXMuaWQrXFxcIiBcXFwiK2EpLGYmJih0aGlzLmlkPVxcXCJcXFwiKSxnJiZjLnJlbW92ZUNoaWxkKHRoaXMpLGJ9cmV0dXJuIGQuY2FsbCh0aGlzLGEpfX12YXIgYz1iLm9fZG9jLmNyZWF0ZUVsZW1lbnQoXFxcImRpdlxcXCIpO3RyeXtjLnF1ZXJ5U2VsZWN0b3JBbGwoXFxcIjpzY29wZSAqXFxcIil9Y2F0Y2goZCl7dmFyIGU9L15cXFxccyo6c2NvcGUvZ2k7YShFbGVtZW50LnByb3RvdHlwZSxcXFwicXVlcnlTZWxlY3RvclxcXCIpLGEoRWxlbWVudC5wcm90b3R5cGUsXFxcInF1ZXJ5U2VsZWN0b3JBbGxcXFwiKX19ZnVuY3Rpb24gdigpe3JldHVybiBiLm9fd2luLnBhZ2VZT2Zmc2V0P2Iub193aW4ucGFnZVlPZmZzZXQ6Yi5vX2RvYy5kb2N1bWVudEVsZW1lbnQmJmIub19kb2MuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcD9iLm9fZG9jLmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3A6Yi5vX2RvYy5ib2R5LnNjcm9sbFRvcD9iLm9fZG9jLmJvZHkuc2Nyb2xsVG9wOjB9ZnVuY3Rpb24gdygpe3JldHVybiBiLm9fd2luLnBhZ2VYT2Zmc2V0P2Iub193aW4ucGFnZVhPZmZzZXQ6Yi5vX2RvYy5kb2N1bWVudEVsZW1lbnQmJmIub19kb2MuZG9jdW1lbnRFbGVtZW50LnNjcm9sbExlZnQ/Yi5vX2RvYy5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsTGVmdDpiLm9fZG9jLmJvZHkuc2Nyb2xsTGVmdD9iLm9fZG9jLmJvZHkuc2Nyb2xsTGVmdDowfWZ1bmN0aW9uIHgoKXtiLmJyb3dzZXI9ZCgpLHUoKX12YXIgeSx6PW51bGw7cmV0dXJue19pbml0OngsaXNJT1M6ZSxpc01hYzp0LGlzQW5kcm9pZDpmLGlzQmxhY2tiZXJyeTpnLGlzV2luZG93c1Bob25lOmgsaXNNb2JpbGU6aSxyZXF1ZXN0QW5pbWF0aW9uRnJhbWU6aixnZXRQWDprLHNjcmVlblNpemU6bCxpc1RvdWNoOm0sc2FuaXRpemVVUkw6byxpc0FycmF5OnAsUkdCVG9IZXg6cSxIRVh0b1JHQjpyLGlzVVJMOm4sZ2V0QWxpZ25tZW50OnMsc2Nyb2xsVG9wOnYsc2Nyb2xsTGVmdDp3fX0sYS5GRS5NT0RVTEVTLmV2ZW50cz1mdW5jdGlvbihiKXtmdW5jdGlvbiBjKGEsYixjKXtzKGEsYixjKX1mdW5jdGlvbiBkKCl7YyhiLiRlbCxcXFwiY3V0IGNvcHkgcGFzdGUgYmVmb3JlcGFzdGVcXFwiLGZ1bmN0aW9uKGEpe3YoYS50eXBlLFthXSl9KX1mdW5jdGlvbiBlKCl7YyhiLiRlbCxcXFwiY2xpY2sgbW91c2V1cCBtb3VzZWRvd24gdG91Y2hzdGFydCB0b3VjaGVuZCBkcmFnZW50ZXIgZHJhZ292ZXIgZHJhZ2xlYXZlIGRyYWdlbmQgZHJvcCBkcmFnc3RhcnRcXFwiLGZ1bmN0aW9uKGEpe3YoYS50eXBlLFthXSl9KSxyKFxcXCJtb3VzZWRvd25cXFwiLGZ1bmN0aW9uKCl7Zm9yKHZhciBjPTA7YzxhLkZFLklOU1RBTkNFUy5sZW5ndGg7YysrKWEuRkUuSU5TVEFOQ0VTW2NdIT1iJiZhLkZFLklOU1RBTkNFU1tjXS5wb3B1cHMmJmEuRkUuSU5TVEFOQ0VTW2NdLnBvcHVwcy5hcmVWaXNpYmxlKCkmJmEuRkUuSU5TVEFOQ0VTW2NdLiRlbC5maW5kKFxcXCIuZnItbWFya2VyXFxcIikucmVtb3ZlKCl9KX1mdW5jdGlvbiBmKCl7YyhiLiRlbCxcXFwia2V5ZG93biBrZXlwcmVzcyBrZXl1cCBpbnB1dFxcXCIsZnVuY3Rpb24oYSl7dihhLnR5cGUsW2FdKX0pfWZ1bmN0aW9uIGcoKXtjKGIuJHdpbixiLl9tb3VzZWRvd24sZnVuY3Rpb24oYSl7dihcXFwid2luZG93Lm1vdXNlZG93blxcXCIsW2FdKSxuKCl9KSxjKGIuJHdpbixiLl9tb3VzZXVwLGZ1bmN0aW9uKGEpe3YoXFxcIndpbmRvdy5tb3VzZXVwXFxcIixbYV0pfSksYyhiLiR3aW4sXFxcImN1dCBjb3B5IGtleWRvd24ga2V5dXAgdG91Y2htb3ZlIHRvdWNoZW5kXFxcIixmdW5jdGlvbihhKXt2KFxcXCJ3aW5kb3cuXFxcIithLnR5cGUsW2FdKX0pfWZ1bmN0aW9uIGgoKXtjKGIuJGRvYyxcXFwiZHJhZ2VuZCBkcm9wXFxcIixmdW5jdGlvbihhKXt2KFxcXCJkb2N1bWVudC5cXFwiK2EudHlwZSxbYV0pfSl9ZnVuY3Rpb24gaShjKXtpZihcXFwidW5kZWZpbmVkXFxcIj09dHlwZW9mIGMmJihjPSEwKSwhYi4kd3ApcmV0dXJuITE7aWYoYi5oZWxwZXJzLmlzSU9TKCkmJmIuJHdpbi5nZXQoMCkuZm9jdXMoKSwhYi5jb3JlLmhhc0ZvY3VzKCkmJmMpe3ZhciBkPWIuJHdpbi5zY3JvbGxUb3AoKTtyZXR1cm4gYi5icm93c2VyLm1zaWUmJmIuJGJveCYmYi4kYm94LmNzcyhcXFwicG9zaXRpb25cXFwiLFxcXCJmaXhlZFxcXCIpLGIuJGVsLmZvY3VzKCksYi5icm93c2VyLm1zaWUmJmIuJGJveCYmYi4kYm94LmNzcyhcXFwicG9zaXRpb25cXFwiLFxcXCJcXFwiKSxkIT1iLiR3aW4uc2Nyb2xsVG9wKCkmJmIuJHdpbi5zY3JvbGxUb3AoZCksITF9aWYoIWIuY29yZS5oYXNGb2N1cygpfHxiLiRlbC5maW5kKFxcXCIuZnItbWFya2VyXFxcIikubGVuZ3RoPjApcmV0dXJuITE7dmFyIGU9Yi5zZWxlY3Rpb24uaW5mbyhiLmVsKTtpZihlLmF0U3RhcnQmJmIuc2VsZWN0aW9uLmlzQ29sbGFwc2VkKCkmJm51bGwhPWIuaHRtbC5kZWZhdWx0VGFnKCkpe3ZhciBmPWIubWFya2Vycy5pbnNlcnQoKTtpZihmJiYhYi5ub2RlLmJsb2NrUGFyZW50KGYpKXthKGYpLnJlbW92ZSgpO3ZhciBnPWIuJGVsLmZpbmQoYi5odG1sLmJsb2NrVGFnc1F1ZXJ5KCkpLmdldCgwKTtnJiYoYShnKS5wcmVwZW5kKGEuRkUuTUFSS0VSUyksYi5zZWxlY3Rpb24ucmVzdG9yZSgpKX1lbHNlIGYmJmEoZikucmVtb3ZlKCl9fWZ1bmN0aW9uIGooKXtjKGIuJGVsLFxcXCJmb2N1c1xcXCIsZnVuY3Rpb24oYSl7cCgpJiYoaSghMSksQz09PSExJiZ2KGEudHlwZSxbYV0pKX0pLGMoYi4kZWwsXFxcImJsdXJcXFwiLGZ1bmN0aW9uKGEpe3AoKSYmQz09PSEwJiYodihhLnR5cGUsW2FdKSxuKCkpfSkscihcXFwiZm9jdXNcXFwiLGZ1bmN0aW9uKCl7Qz0hMH0pLHIoXFxcImJsdXJcXFwiLGZ1bmN0aW9uKCl7Qz0hMX0pfWZ1bmN0aW9uIGsoKXtiLmhlbHBlcnMuaXNNb2JpbGUoKT8oYi5fbW91c2Vkb3duPVxcXCJ0b3VjaHN0YXJ0XFxcIixiLl9tb3VzZXVwPVxcXCJ0b3VjaGVuZFxcXCIsYi5fbW92ZT1cXFwidG91Y2htb3ZlXFxcIixiLl9tb3VzZW1vdmU9XFxcInRvdWNobW92ZVxcXCIpOihiLl9tb3VzZWRvd249XFxcIm1vdXNlZG93blxcXCIsYi5fbW91c2V1cD1cXFwibW91c2V1cFxcXCIsYi5fbW92ZT1cXFwiXFxcIixiLl9tb3VzZW1vdmU9XFxcIm1vdXNlbW92ZVxcXCIpfWZ1bmN0aW9uIGwoYyl7dmFyIGQ9YShjLmN1cnJlbnRUYXJnZXQpO3JldHVybiBiLmVkaXQuaXNEaXNhYmxlZCgpfHxiLm5vZGUuaGFzQ2xhc3MoZC5nZXQoMCksXFxcImZyLWRpc2FibGVkXFxcIik/KGMucHJldmVudERlZmF1bHQoKSwhMSk6XFxcIm1vdXNlZG93blxcXCI9PT1jLnR5cGUmJjEhPT1jLndoaWNofHwoYi5oZWxwZXJzLmlzTW9iaWxlKCl8fGMucHJldmVudERlZmF1bHQoKSwoYi5oZWxwZXJzLmlzQW5kcm9pZCgpfHxiLmhlbHBlcnMuaXNXaW5kb3dzUGhvbmUoKSkmJjA9PT1kLnBhcmVudHMoXFxcIi5mci1kcm9wZG93bi1tZW51XFxcIikubGVuZ3RoJiYoYy5wcmV2ZW50RGVmYXVsdCgpLGMuc3RvcFByb3BhZ2F0aW9uKCkpLGQuYWRkQ2xhc3MoXFxcImZyLXNlbGVjdGVkXFxcIiksdm9pZCBiLmV2ZW50cy50cmlnZ2VyKFxcXCJjb21tYW5kcy5tb3VzZWRvd25cXFwiLFtkXSkpfWZ1bmN0aW9uIG0oYyxkKXt2YXIgZT1hKGMuY3VycmVudFRhcmdldCk7aWYoYi5lZGl0LmlzRGlzYWJsZWQoKXx8Yi5ub2RlLmhhc0NsYXNzKGUuZ2V0KDApLFxcXCJmci1kaXNhYmxlZFxcXCIpKXJldHVybiBjLnByZXZlbnREZWZhdWx0KCksITE7aWYoXFxcIm1vdXNldXBcXFwiPT09Yy50eXBlJiYxIT09Yy53aGljaClyZXR1cm4hMDtpZighYi5ub2RlLmhhc0NsYXNzKGUuZ2V0KDApLFxcXCJmci1zZWxlY3RlZFxcXCIpKXJldHVybiEwO2lmKFxcXCJ0b3VjaG1vdmVcXFwiIT1jLnR5cGUpe2lmKGMuc3RvcFByb3BhZ2F0aW9uKCksYy5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKSxjLnByZXZlbnREZWZhdWx0KCksIWIubm9kZS5oYXNDbGFzcyhlLmdldCgwKSxcXFwiZnItc2VsZWN0ZWRcXFwiKSlyZXR1cm4gYi5idXR0b24uZ2V0QnV0dG9ucyhcXFwiLmZyLXNlbGVjdGVkXFxcIiwhMCkucmVtb3ZlQ2xhc3MoXFxcImZyLXNlbGVjdGVkXFxcIiksITE7aWYoYi5idXR0b24uZ2V0QnV0dG9ucyhcXFwiLmZyLXNlbGVjdGVkXFxcIiwhMCkucmVtb3ZlQ2xhc3MoXFxcImZyLXNlbGVjdGVkXFxcIiksZS5kYXRhKFxcXCJkcmFnZ2luZ1xcXCIpfHxlLmF0dHIoXFxcImRpc2FibGVkXFxcIikpcmV0dXJuIGUucmVtb3ZlRGF0YShcXFwiZHJhZ2dpbmdcXFwiKSwhMTt2YXIgZj1lLmRhdGEoXFxcInRpbWVvdXRcXFwiKTtmJiYoY2xlYXJUaW1lb3V0KGYpLGUucmVtb3ZlRGF0YShcXFwidGltZW91dFxcXCIpKSxkLmFwcGx5KGIsW2NdKX1lbHNlIGUuZGF0YShcXFwidGltZW91dFxcXCIpfHxlLmRhdGEoXFxcInRpbWVvdXRcXFwiLHNldFRpbWVvdXQoZnVuY3Rpb24oKXtlLmRhdGEoXFxcImRyYWdnaW5nXFxcIiwhMCl9LDEwMCkpfWZ1bmN0aW9uIG4oKXtBPSEwfWZ1bmN0aW9uIG8oKXtBPSExfWZ1bmN0aW9uIHAoKXtyZXR1cm4gQX1mdW5jdGlvbiBxKGEsYyxkKXtzKGEsYi5fbW91c2Vkb3duLGMsZnVuY3Rpb24oYSl7Yi5lZGl0LmlzRGlzYWJsZWQoKXx8bChhKX0sITApLHMoYSxiLl9tb3VzZXVwK1xcXCIgXFxcIitiLl9tb3ZlLGMsZnVuY3Rpb24oYSl7Yi5lZGl0LmlzRGlzYWJsZWQoKXx8bShhLGQpfSwhMCkscyhhLFxcXCJtb3VzZWRvd24gY2xpY2sgbW91c2V1cFxcXCIsYyxmdW5jdGlvbihhKXtiLmVkaXQuaXNEaXNhYmxlZCgpfHxhLnN0b3BQcm9wYWdhdGlvbigpfSwhMCkscihcXFwid2luZG93Lm1vdXNldXBcXFwiLGZ1bmN0aW9uKCl7Yi5lZGl0LmlzRGlzYWJsZWQoKXx8KGEuZmluZChjKS5yZW1vdmVDbGFzcyhcXFwiZnItc2VsZWN0ZWRcXFwiKSxuKCkpfSl9ZnVuY3Rpb24gcihhLGMsZCl7dmFyIGU9YS5zcGxpdChcXFwiIFxcXCIpO2lmKGUubGVuZ3RoPjEpe2Zvcih2YXIgZj0wO2Y8ZS5sZW5ndGg7ZisrKXIoZVtmXSxjLGQpO3JldHVybiEwfVxcXCJ1bmRlZmluZWRcXFwiPT10eXBlb2YgZCYmKGQ9ITEpO3ZhciBnO2c9MCE9PWEuaW5kZXhPZihcXFwic2hhcmVkLlxcXCIpP0JbYV09QlthXXx8W106Yi5zaGFyZWQuX2V2ZW50c1thXT1iLnNoYXJlZC5fZXZlbnRzW2FdfHxbXSxkP2cudW5zaGlmdChjKTpnLnB1c2goYyl9ZnVuY3Rpb24gcyhhLGMsZCxlLGYpe1xcXCJmdW5jdGlvblxcXCI9PXR5cGVvZiBkJiYoZj1lLGU9ZCxkPSExKTt2YXIgZz1mP2Iuc2hhcmVkLiRfZXZlbnRzOkQsaD1mP2Iuc2lkOmIuaWQ7ZD9hLm9uKGMuc3BsaXQoXFxcIiBcXFwiKS5qb2luKFxcXCIuZWRcXFwiK2grXFxcIiBcXFwiKStcXFwiLmVkXFxcIitoLGQsZSk6YS5vbihjLnNwbGl0KFxcXCIgXFxcIikuam9pbihcXFwiLmVkXFxcIitoK1xcXCIgXFxcIikrXFxcIi5lZFxcXCIraCxlKSxnLmluZGV4T2YoYS5nZXQoMCkpPDAmJmcucHVzaChhLmdldCgwKSl9ZnVuY3Rpb24gdChiLGMpe2Zvcih2YXIgZD0wO2Q8Yi5sZW5ndGg7ZCsrKWEoYltkXSkub2ZmKFxcXCIuZWRcXFwiK2MpfWZ1bmN0aW9uIHUoKXt0KEQsYi5pZCksRD1bXSwwPT09Yi5zaGFyZWQuY291bnQmJih0KGIuc2hhcmVkLiRfZXZlbnRzLGIuc2lkKSxiLnNoYXJlZC4kX2V2ZW50cz1udWxsKX1mdW5jdGlvbiB2KGMsZCxlKXtpZighYi5lZGl0LmlzRGlzYWJsZWQoKXx8ZSl7dmFyIGY7aWYoMCE9PWMuaW5kZXhPZihcXFwic2hhcmVkLlxcXCIpKWY9QltjXTtlbHNle2lmKGIuc2hhcmVkLmNvdW50PjApcmV0dXJuITE7Zj1iLnNoYXJlZC5fZXZlbnRzW2NdfXZhciBnO2lmKGYpZm9yKHZhciBoPTA7aDxmLmxlbmd0aDtoKyspaWYoZz1mW2hdLmFwcGx5KGIsZCksZz09PSExKXJldHVybiExO3JldHVybiBnPWIuJG9lbC50cmlnZ2VySGFuZGxlcihcXFwiZnJvYWxhRWRpdG9yLlxcXCIrYyxhLm1lcmdlKFtiXSxkfHxbXSkpLGchPT0hMSYmZ319ZnVuY3Rpb24gdyhjLGQsZSl7aWYoIWIuZWRpdC5pc0Rpc2FibGVkKCl8fGUpe3ZhciBmO2lmKDAhPT1jLmluZGV4T2YoXFxcInNoYXJlZC5cXFwiKSlmPUJbY107ZWxzZXtpZihiLnNoYXJlZC5jb3VudD4wKXJldHVybiExO2Y9Yi5zaGFyZWQuX2V2ZW50c1tjXX12YXIgZztpZihmKWZvcih2YXIgaD0wO2g8Zi5sZW5ndGg7aCsrKWc9ZltoXS5hcHBseShiLFtkXSksXFxcInVuZGVmaW5lZFxcXCIhPXR5cGVvZiBnJiYoZD1nKTtyZXR1cm4gZz1iLiRvZWwudHJpZ2dlckhhbmRsZXIoXFxcImZyb2FsYUVkaXRvci5cXFwiK2MsYS5tZXJnZShbYl0sW2RdKSksXFxcInVuZGVmaW5lZFxcXCIhPXR5cGVvZiBnJiYoZD1nKSxkfX1mdW5jdGlvbiB4KCl7Zm9yKHZhciBhIGluIEIpQi5oYXNPd25Qcm9wZXJ0eShhKSYmZGVsZXRlIEJbYV19ZnVuY3Rpb24geSgpe2Zvcih2YXIgYSBpbiBiLnNoYXJlZC5fZXZlbnRzKWIuc2hhcmVkLl9ldmVudHMuaGFzT3duUHJvcGVydHkoYSkmJmRlbGV0ZSBiLnNoYXJlZC5fZXZlbnRzW2FdfWZ1bmN0aW9uIHooKXtiLnNoYXJlZC4kX2V2ZW50cz1iLnNoYXJlZC4kX2V2ZW50c3x8W10sYi5zaGFyZWQuX2V2ZW50cz17fSxrKCksZSgpLGcoKSxoKCksZigpLGooKSxuKCksZCgpLHIoXFxcImRlc3Ryb3lcXFwiLHgpLHIoXFxcInNoYXJlZC5kZXN0cm95XFxcIix5KX12YXIgQSxCPXt9LEM9ITEsRD1bXTtyZXR1cm57X2luaXQ6eixvbjpyLHRyaWdnZXI6dixiaW5kQ2xpY2s6cSxkaXNhYmxlQmx1cjpvLGVuYWJsZUJsdXI6bixibHVyQWN0aXZlOnAsZm9jdXM6aSxjaGFpblRyaWdnZXI6dywkb246cywkb2ZmOnV9fSxhLkZFLk1PRFVMRVMubm9kZT1mdW5jdGlvbihiKXtmdW5jdGlvbiBjKGEpe3JldHVybiBhJiZcXFwiSUZSQU1FXFxcIiE9YS50YWdOYW1lP0FycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGEuY2hpbGROb2Rlc3x8W10pOltdfWZ1bmN0aW9uIGQoYil7cmV0dXJuISFiJiYoYi5ub2RlVHlwZT09Tm9kZS5FTEVNRU5UX05PREUmJmEuRkUuQkxPQ0tfVEFHUy5pbmRleE9mKGIudGFnTmFtZS50b0xvd2VyQ2FzZSgpKT49MCl9ZnVuY3Rpb24gZShlLGYpe2lmKCFlKXJldHVybiEwO2lmKGUucXVlcnlTZWxlY3RvcihcXFwidGFibGVcXFwiKSlyZXR1cm4hMTt2YXIgZz1jKGUpOzE9PWcubGVuZ3RoJiZkKGdbMF0pJiYoZz1jKGdbMF0pKTtmb3IodmFyIGg9ITEsaT0wO2k8Zy5sZW5ndGg7aSsrKXt2YXIgaj1nW2ldO2lmKCEoZiYmYi5ub2RlLmhhc0NsYXNzKGosXFxcImZyLW1hcmtlclxcXCIpfHxqLm5vZGVUeXBlPT1Ob2RlLlRFWFRfTk9ERSYmMD09PWoudGV4dENvbnRlbnQubGVuZ3RoKSl7aWYoXFxcIkJSXFxcIiE9ai50YWdOYW1lJiYoai50ZXh0Q29udGVudHx8XFxcIlxcXCIpLnJlcGxhY2UoL1xcXFx1MjAwQi9naSxcXFwiXFxcIikucmVwbGFjZSgvXFxcXG4vZyxcXFwiXFxcIikubGVuZ3RoPjApcmV0dXJuITE7aWYoaClyZXR1cm4hMTtcXFwiQlJcXFwiPT1qLnRhZ05hbWUmJihoPSEwKX19cmV0dXJuIShlLnF1ZXJ5U2VsZWN0b3JBbGwoYS5GRS5WT0lEX0VMRU1FTlRTLmpvaW4oXFxcIixcXFwiKSkubGVuZ3RoLWUucXVlcnlTZWxlY3RvckFsbChcXFwiYnJcXFwiKS5sZW5ndGgpJiYoIWUucXVlcnlTZWxlY3RvcihiLm9wdHMuaHRtbEFsbG93ZWRFbXB0eVRhZ3Muam9pbihcXFwiOm5vdCguZnItbWFya2VyKSxcXFwiKStcXFwiOm5vdCguZnItbWFya2VyKVxcXCIpJiYoIShlLnF1ZXJ5U2VsZWN0b3JBbGwoYS5GRS5CTE9DS19UQUdTLmpvaW4oXFxcIixcXFwiKSkubGVuZ3RoPjEpJiYhZS5xdWVyeVNlbGVjdG9yKGIub3B0cy5odG1sRG9Ob3RXcmFwVGFncy5qb2luKFxcXCI6bm90KC5mci1tYXJrZXIpLFxcXCIpK1xcXCI6bm90KC5mci1tYXJrZXIpXFxcIikpKX1mdW5jdGlvbiBmKGEpe2Zvcig7YSYmYS5wYXJlbnROb2RlIT09Yi5lbCYmKCFhLnBhcmVudE5vZGV8fCFiLm5vZGUuaGFzQ2xhc3MoYS5wYXJlbnROb2RlLFxcXCJmci1pbm5lclxcXCIpKTspaWYoYT1hLnBhcmVudE5vZGUsZChhKSlyZXR1cm4gYTtyZXR1cm4gbnVsbH1mdW5jdGlvbiBnKGMsZSxmKXtpZihcXFwidW5kZWZpbmVkXFxcIj09dHlwZW9mIGUmJihlPVtdKSxcXFwidW5kZWZpbmVkXFxcIj09dHlwZW9mIGYmJihmPSEwKSxlLnB1c2goYi5lbCksZS5pbmRleE9mKGMucGFyZW50Tm9kZSk+PTB8fGMucGFyZW50Tm9kZSYmYi5ub2RlLmhhc0NsYXNzKGMucGFyZW50Tm9kZSxcXFwiZnItaW5uZXJcXFwiKXx8Yy5wYXJlbnROb2RlJiZhLkZFLlNJTVBMRV9FTlRFUl9UQUdTLmluZGV4T2YoYy5wYXJlbnROb2RlLnRhZ05hbWUpPj0wJiZmKXJldHVybiBudWxsO2Zvcig7ZS5pbmRleE9mKGMucGFyZW50Tm9kZSk8MCYmYy5wYXJlbnROb2RlJiYhYi5ub2RlLmhhc0NsYXNzKGMucGFyZW50Tm9kZSxcXFwiZnItaW5uZXJcXFwiKSYmKGEuRkUuU0lNUExFX0VOVEVSX1RBR1MuaW5kZXhPZihjLnBhcmVudE5vZGUudGFnTmFtZSk8MHx8IWYpJiYoIWQoYyl8fCFkKGMucGFyZW50Tm9kZSl8fCFmKTspYz1jLnBhcmVudE5vZGU7cmV0dXJuIGN9ZnVuY3Rpb24gaChhKXt2YXIgYj17fSxjPWEuYXR0cmlidXRlcztpZihjKWZvcih2YXIgZD0wO2Q8Yy5sZW5ndGg7ZCsrKXt2YXIgZT1jW2RdO2JbZS5ub2RlTmFtZV09ZS52YWx1ZX1yZXR1cm4gYn1mdW5jdGlvbiBpKGEpe2Zvcih2YXIgYj1cXFwiXFxcIixjPWgoYSksZD1PYmplY3Qua2V5cyhjKS5zb3J0KCksZT0wO2U8ZC5sZW5ndGg7ZSsrKXt2YXIgZj1kW2VdLGc9Y1tmXTtnLmluZGV4T2YoXFxcIidcXFwiKTwwJiZnLmluZGV4T2YoJ1xcXCInKT49MD9iKz1cXFwiIFxcXCIrZitcXFwiPSdcXFwiK2crXFxcIidcXFwiOmcuaW5kZXhPZignXFxcIicpPj0wJiZnLmluZGV4T2YoXFxcIidcXFwiKT49MD8oZz1nLnJlcGxhY2UoL1xcXCIvZyxcXFwiJnF1b3Q7XFxcIiksYis9XFxcIiBcXFwiK2YrJz1cXFwiJytnKydcXFwiJyk6Yis9XFxcIiBcXFwiK2YrJz1cXFwiJytnKydcXFwiJ31yZXR1cm4gYn1mdW5jdGlvbiBqKGEpe2Zvcih2YXIgYj1hLmF0dHJpYnV0ZXMsYz1iLmxlbmd0aC0xO2M+PTA7Yy0tKXt2YXIgZD1iW2NdO2EucmVtb3ZlQXR0cmlidXRlKGQubm9kZU5hbWUpfX1mdW5jdGlvbiBrKGEpe3JldHVyblxcXCI8XFxcIithLnRhZ05hbWUudG9Mb3dlckNhc2UoKStpKGEpK1xcXCI+XFxcIn1mdW5jdGlvbiBsKGEpe3JldHVyblxcXCI8L1xcXCIrYS50YWdOYW1lLnRvTG93ZXJDYXNlKCkrXFxcIj5cXFwifWZ1bmN0aW9uIG0oYSxjKXtcXFwidW5kZWZpbmVkXFxcIj09dHlwZW9mIGMmJihjPSEwKTtmb3IodmFyIGQ9YS5wcmV2aW91c1NpYmxpbmc7ZCYmYyYmYi5ub2RlLmhhc0NsYXNzKGQsXFxcImZyLW1hcmtlclxcXCIpOylkPWQucHJldmlvdXNTaWJsaW5nO3JldHVybiFkfHxkLm5vZGVUeXBlPT1Ob2RlLlRFWFRfTk9ERSYmXFxcIlxcXCI9PT1kLnRleHRDb250ZW50JiZtKGQpfWZ1bmN0aW9uIG4oYSxjKXtcXFwidW5kZWZpbmVkXFxcIj09dHlwZW9mIGMmJihjPSEwKTtmb3IodmFyIGQ9YS5uZXh0U2libGluZztkJiZjJiZiLm5vZGUuaGFzQ2xhc3MoZCxcXFwiZnItbWFya2VyXFxcIik7KWQ9ZC5uZXh0U2libGluZztyZXR1cm4hZHx8ZC5ub2RlVHlwZT09Tm9kZS5URVhUX05PREUmJlxcXCJcXFwiPT09ZC50ZXh0Q29udGVudCYmbihkKX1mdW5jdGlvbiBvKGIpe3JldHVybiBiJiZiLm5vZGVUeXBlPT1Ob2RlLkVMRU1FTlRfTk9ERSYmYS5GRS5WT0lEX0VMRU1FTlRTLmluZGV4T2YoKGIudGFnTmFtZXx8XFxcIlxcXCIpLnRvTG93ZXJDYXNlKCkpPj0wfWZ1bmN0aW9uIHAoYSl7cmV0dXJuISFhJiZbXFxcIlVMXFxcIixcXFwiT0xcXFwiXS5pbmRleE9mKGEudGFnTmFtZSk+PTB9ZnVuY3Rpb24gcShhKXtyZXR1cm4gYT09PWIuZWx9ZnVuY3Rpb24gcihhKXtyZXR1cm4gYSYmYS5ub2RlVHlwZT09Tm9kZS5FTEVNRU5UX05PREUmJmEuZ2V0QXR0cmlidXRlKFxcXCJjbGFzc1xcXCIpJiYoYS5nZXRBdHRyaWJ1dGUoXFxcImNsYXNzXFxcIil8fFxcXCJcXFwiKS5pbmRleE9mKFxcXCJmci1kZWxldGFibGVcXFwiKT49MH1mdW5jdGlvbiBzKGEpe3JldHVybiBhPT09Yi5kb2MuYWN0aXZlRWxlbWVudCYmKCFiLmRvYy5oYXNGb2N1c3x8Yi5kb2MuaGFzRm9jdXMoKSkmJiEhKHEoYSl8fGEudHlwZXx8YS5ocmVmfHx+YS50YWJJbmRleCl9ZnVuY3Rpb24gdChhKXtyZXR1cm4oIWEuZ2V0QXR0cmlidXRlfHxcXFwiZmFsc2VcXFwiIT1hLmdldEF0dHJpYnV0ZShcXFwiY29udGVudGVkaXRhYmxlXFxcIikpJiZbXFxcIlNUWUxFXFxcIixcXFwiU0NSSVBUXFxcIl0uaW5kZXhPZihhLnRhZ05hbWUpPDB9ZnVuY3Rpb24gdShiLGMpe3JldHVybiBiIGluc3RhbmNlb2YgYSYmKGI9Yi5nZXQoMCkpLGImJmIuY2xhc3NMaXN0JiZiLmNsYXNzTGlzdC5jb250YWlucyhjKX1mdW5jdGlvbiB2KGEpe3JldHVybiBiLmJyb3dzZXIubXNpZT9hOnthY2NlcHROb2RlOmF9fXJldHVybntpc0Jsb2NrOmQsaXNFbXB0eTplLGJsb2NrUGFyZW50OmYsZGVlcGVzdFBhcmVudDpnLHJhd0F0dHJpYnV0ZXM6aCxhdHRyaWJ1dGVzOmksY2xlYXJBdHRyaWJ1dGVzOmosb3BlblRhZ1N0cmluZzprLGNsb3NlVGFnU3RyaW5nOmwsaXNGaXJzdFNpYmxpbmc6bSxpc0xhc3RTaWJsaW5nOm4saXNMaXN0OnAsaXNFbGVtZW50OnEsY29udGVudHM6Yyxpc1ZvaWQ6byxoYXNGb2N1czpzLGlzRWRpdGFibGU6dCxpc0RlbGV0YWJsZTpyLGhhc0NsYXNzOnUsZmlsdGVyOnZ9fSxhLkZFLklOVklTSUJMRV9TUEFDRT1cXFwiJiM4MjAzO1xcXCIsYS5GRS5TVEFSVF9NQVJLRVI9JzxzcGFuIGNsYXNzPVxcXCJmci1tYXJrZXJcXFwiIGRhdGEtaWQ9XFxcIjBcXFwiIGRhdGEtdHlwZT1cXFwidHJ1ZVxcXCIgc3R5bGU9XFxcImRpc3BsYXk6IG5vbmU7IGxpbmUtaGVpZ2h0OiAwO1xcXCI+JythLkZFLklOVklTSUJMRV9TUEFDRStcXFwiPC9zcGFuPlxcXCIsYS5GRS5FTkRfTUFSS0VSPSc8c3BhbiBjbGFzcz1cXFwiZnItbWFya2VyXFxcIiBkYXRhLWlkPVxcXCIwXFxcIiBkYXRhLXR5cGU9XFxcImZhbHNlXFxcIiBzdHlsZT1cXFwiZGlzcGxheTogbm9uZTsgbGluZS1oZWlnaHQ6IDA7XFxcIj4nK2EuRkUuSU5WSVNJQkxFX1NQQUNFK1xcXCI8L3NwYW4+XFxcIixhLkZFLk1BUktFUlM9YS5GRS5TVEFSVF9NQVJLRVIrYS5GRS5FTkRfTUFSS0VSLGEuRkUuTU9EVUxFUy5tYXJrZXJzPWZ1bmN0aW9uKGIpe2Z1bmN0aW9uIGMoYyxkKXtyZXR1cm4gYSgnPHNwYW4gY2xhc3M9XFxcImZyLW1hcmtlclxcXCIgZGF0YS1pZD1cXFwiJytkKydcXFwiIGRhdGEtdHlwZT1cXFwiJytjKydcXFwiIHN0eWxlPVxcXCJkaXNwbGF5OiAnKyhiLmJyb3dzZXIuc2FmYXJpP1xcXCJub25lXFxcIjpcXFwiaW5saW5lLWJsb2NrXFxcIikrJzsgbGluZS1oZWlnaHQ6IDA7XFxcIj4nK2EuRkUuSU5WSVNJQkxFX1NQQUNFK1xcXCI8L3NwYW4+XFxcIixiLmRvYylbMF19ZnVuY3Rpb24gZChkLGUsZil7dmFyIGcsaCxpO3RyeXt2YXIgaj1kLmNsb25lUmFuZ2UoKTtpZihqLmNvbGxhcHNlKGUpLGouaW5zZXJ0Tm9kZShjKGUsZikpLGU9PT0hMCYmZC5jb2xsYXBzZWQpZm9yKGc9Yi4kZWwuZmluZCgnc3Bhbi5mci1tYXJrZXJbZGF0YS10eXBlPVxcXCJ0cnVlXFxcIl1bZGF0YS1pZD1cXFwiJytmKydcXFwiXScpLGk9Zy5nZXQoMCkubmV4dFNpYmxpbmc7aSYmaS5ub2RlVHlwZT09PU5vZGUuVEVYVF9OT0RFJiYwPT09aS50ZXh0Q29udGVudC5sZW5ndGg7KWEoaSkucmVtb3ZlKCksaT1nLm5leHRTaWJsaW5nO2lmKGU9PT0hMCYmIWQuY29sbGFwc2VkJiYoZz1iLiRlbC5maW5kKCdzcGFuLmZyLW1hcmtlcltkYXRhLXR5cGU9XFxcInRydWVcXFwiXVtkYXRhLWlkPVxcXCInK2YrJ1xcXCJdJykuZ2V0KDApLGk9Zy5uZXh0U2libGluZyxpJiZpLm5vZGVUeXBlPT09Tm9kZS5FTEVNRU5UX05PREUmJmIubm9kZS5pc0Jsb2NrKGkpKSl7aD1baV07ZG8gaT1oWzBdLGg9Yi5ub2RlLmNvbnRlbnRzKGkpO3doaWxlKGhbMF0mJmIubm9kZS5pc0Jsb2NrKGhbMF0pKTthKGkpLnByZXBlbmQoYShnKSl9aWYoZT09PSExJiYhZC5jb2xsYXBzZWQpe2lmKGc9Yi4kZWwuZmluZCgnc3Bhbi5mci1tYXJrZXJbZGF0YS10eXBlPVxcXCJmYWxzZVxcXCJdW2RhdGEtaWQ9XFxcIicrZisnXFxcIl0nKS5nZXQoMCksaT1nLnByZXZpb3VzU2libGluZyxpJiZpLm5vZGVUeXBlPT09Tm9kZS5FTEVNRU5UX05PREUmJmIubm9kZS5pc0Jsb2NrKGkpKXtoPVtpXTtkbyBpPWhbaC5sZW5ndGgtMV0saD1iLm5vZGUuY29udGVudHMoaSk7d2hpbGUoaFtoLmxlbmd0aC0xXSYmYi5ub2RlLmlzQmxvY2soaFtoLmxlbmd0aC0xXSkpO2EoaSkuYXBwZW5kKGEoZykpfWcucGFyZW50Tm9kZSYmW1xcXCJURFxcXCIsXFxcIlRIXFxcIl0uaW5kZXhPZihnLnBhcmVudE5vZGUudGFnTmFtZSk+PTAmJmcucGFyZW50Tm9kZS5wcmV2aW91c1NpYmxpbmcmJiFnLnByZXZpb3VzU2libGluZyYmYShnLnBhcmVudE5vZGUucHJldmlvdXNTaWJsaW5nKS5hcHBlbmQoZyl9dmFyIGs9Yi4kZWwuZmluZCgnc3Bhbi5mci1tYXJrZXJbZGF0YS10eXBlPVxcXCInK2UrJ1xcXCJdW2RhdGEtaWQ9XFxcIicrZisnXFxcIl0nKS5nZXQoMCk7cmV0dXJuIGsmJihrLnN0eWxlLmRpc3BsYXk9XFxcIm5vbmVcXFwiKSxrfWNhdGNoKGwpe3JldHVybiBudWxsfX1mdW5jdGlvbiBlKCl7aWYoIWIuJHdwKXJldHVybiBudWxsO3RyeXt2YXIgYz1iLnNlbGVjdGlvbi5yYW5nZXMoMCksZD1jLmNvbW1vbkFuY2VzdG9yQ29udGFpbmVyO2lmKGQhPWIuZWwmJjA9PT1iLiRlbC5maW5kKGQpLmxlbmd0aClyZXR1cm4gbnVsbDt2YXIgZT1jLmNsb25lUmFuZ2UoKSxmPWMuY2xvbmVSYW5nZSgpO2UuY29sbGFwc2UoITApO3ZhciBnPWEoJzxzcGFuIGNsYXNzPVxcXCJmci1tYXJrZXJcXFwiIHN0eWxlPVxcXCJkaXNwbGF5OiBub25lOyBsaW5lLWhlaWdodDogMDtcXFwiPicrYS5GRS5JTlZJU0lCTEVfU1BBQ0UrXFxcIjwvc3Bhbj5cXFwiLGIuZG9jKVswXTtpZihlLmluc2VydE5vZGUoZyksZz1iLiRlbC5maW5kKFxcXCJzcGFuLmZyLW1hcmtlclxcXCIpLmdldCgwKSl7Zm9yKHZhciBoPWcubmV4dFNpYmxpbmc7aCYmaC5ub2RlVHlwZT09PU5vZGUuVEVYVF9OT0RFJiYwPT09aC50ZXh0Q29udGVudC5sZW5ndGg7KWEoaCkucmVtb3ZlKCksaD1iLiRlbC5maW5kKFxcXCJzcGFuLmZyLW1hcmtlclxcXCIpLmdldCgwKS5uZXh0U2libGluZztyZXR1cm4gYi5zZWxlY3Rpb24uY2xlYXIoKSxiLnNlbGVjdGlvbi5nZXQoKS5hZGRSYW5nZShmKSxnfXJldHVybiBudWxsfWNhdGNoKGkpe2NvbnNvbGUud2FybihcXFwiTUFSS0VSXFxcIixpKX19ZnVuY3Rpb24gZigpe2Iuc2VsZWN0aW9uLmlzQ29sbGFwc2VkKCl8fGIuc2VsZWN0aW9uLnJlbW92ZSgpO3ZhciBjPWIuJGVsLmZpbmQoXFxcIi5mci1tYXJrZXJcXFwiKS5nZXQoMCk7aWYobnVsbD09YyYmKGM9ZSgpKSxudWxsPT1jKXJldHVybiBudWxsO3ZhciBkPWIubm9kZS5kZWVwZXN0UGFyZW50KGMpO2lmKGR8fChkPWIubm9kZS5ibG9ja1BhcmVudChjKSxkJiZcXFwiTElcXFwiIT1kLnRhZ05hbWUmJihkPW51bGwpKSxkKWlmKGIubm9kZS5pc0Jsb2NrKGQpJiZiLm5vZGUuaXNFbXB0eShkKSlcXFwiTElcXFwiPT1kLnRhZ05hbWUmJmQucGFyZW50Tm9kZS5maXJzdEVsZW1lbnRDaGlsZD09ZD9hKGQpLmFwcGVuZCgnPHNwYW4gY2xhc3M9XFxcImZyLW1hcmtlclxcXCI+PC9zcGFuPicpOmEoZCkucmVwbGFjZVdpdGgoJzxzcGFuIGNsYXNzPVxcXCJmci1tYXJrZXJcXFwiPjwvc3Bhbj4nKTtlbHNlIGlmKGIuY3Vyc29yLmlzQXRTdGFydChjLGQpKWEoZCkuYmVmb3JlKCc8c3BhbiBjbGFzcz1cXFwiZnItbWFya2VyXFxcIj48L3NwYW4+JyksYShjKS5yZW1vdmUoKTtlbHNlIGlmKGIuY3Vyc29yLmlzQXRFbmQoYyxkKSlhKGQpLmFmdGVyKCc8c3BhbiBjbGFzcz1cXFwiZnItbWFya2VyXFxcIj48L3NwYW4+JyksYShjKS5yZW1vdmUoKTtlbHNle3ZhciBmPWMsZz1cXFwiXFxcIixoPVxcXCJcXFwiO2RvIGY9Zi5wYXJlbnROb2RlLGcrPWIubm9kZS5jbG9zZVRhZ1N0cmluZyhmKSxoPWIubm9kZS5vcGVuVGFnU3RyaW5nKGYpK2g7d2hpbGUoZiE9ZCk7YShjKS5yZXBsYWNlV2l0aCgnPHNwYW4gaWQ9XFxcImZyLWJyZWFrXFxcIj48L3NwYW4+Jyk7dmFyIGk9Yi5ub2RlLm9wZW5UYWdTdHJpbmcoZCkrYShkKS5odG1sKCkrYi5ub2RlLmNsb3NlVGFnU3RyaW5nKGQpO2k9aS5yZXBsYWNlKC88c3BhbiBpZD1cXFwiZnItYnJlYWtcXFwiPjxcXFxcL3NwYW4+L2csZysnPHNwYW4gY2xhc3M9XFxcImZyLW1hcmtlclxcXCI+PC9zcGFuPicraCksYShkKS5yZXBsYWNlV2l0aChpKX1yZXR1cm4gYi4kZWwuZmluZChcXFwiLmZyLW1hcmtlclxcXCIpLmdldCgwKX1mdW5jdGlvbiBnKGEpe3ZhciBjPWEuY2xpZW50WCxkPWEuY2xpZW50WTtoKCk7dmFyIGYsZz1udWxsO2lmKFxcXCJ1bmRlZmluZWRcXFwiIT10eXBlb2YgYi5kb2MuY2FyZXRQb3NpdGlvbkZyb21Qb2ludD8oZj1iLmRvYy5jYXJldFBvc2l0aW9uRnJvbVBvaW50KGMsZCksZz1iLmRvYy5jcmVhdGVSYW5nZSgpLGcuc2V0U3RhcnQoZi5vZmZzZXROb2RlLGYub2Zmc2V0KSxnLnNldEVuZChmLm9mZnNldE5vZGUsZi5vZmZzZXQpKTpcXFwidW5kZWZpbmVkXFxcIiE9dHlwZW9mIGIuZG9jLmNhcmV0UmFuZ2VGcm9tUG9pbnQmJihmPWIuZG9jLmNhcmV0UmFuZ2VGcm9tUG9pbnQoYyxkKSxnPWIuZG9jLmNyZWF0ZVJhbmdlKCksZy5zZXRTdGFydChmLnN0YXJ0Q29udGFpbmVyLGYuc3RhcnRPZmZzZXQpLGcuc2V0RW5kKGYuc3RhcnRDb250YWluZXIsZi5zdGFydE9mZnNldCkpLG51bGwhPT1nJiZcXFwidW5kZWZpbmVkXFxcIiE9dHlwZW9mIGIud2luLmdldFNlbGVjdGlvbil7dmFyIGk9Yi53aW4uZ2V0U2VsZWN0aW9uKCk7aS5yZW1vdmVBbGxSYW5nZXMoKSxpLmFkZFJhbmdlKGcpfWVsc2UgaWYoXFxcInVuZGVmaW5lZFxcXCIhPXR5cGVvZiBiLmRvYy5ib2R5LmNyZWF0ZVRleHRSYW5nZSl0cnl7Zz1iLmRvYy5ib2R5LmNyZWF0ZVRleHRSYW5nZSgpLGcubW92ZVRvUG9pbnQoYyxkKTt2YXIgaj1nLmR1cGxpY2F0ZSgpO2oubW92ZVRvUG9pbnQoYyxkKSxnLnNldEVuZFBvaW50KFxcXCJFbmRUb0VuZFxcXCIsaiksZy5zZWxlY3QoKX1jYXRjaChrKXtyZXR1cm4hMX1lKCl9ZnVuY3Rpb24gaCgpe2IuJGVsLmZpbmQoXFxcIi5mci1tYXJrZXJcXFwiKS5yZW1vdmUoKX1yZXR1cm57cGxhY2U6ZCxpbnNlcnQ6ZSxzcGxpdDpmLGluc2VydEF0UG9pbnQ6ZyxyZW1vdmU6aH19LGEuRkUuTU9EVUxFUy5zZWxlY3Rpb249ZnVuY3Rpb24oYil7ZnVuY3Rpb24gYygpe3ZhciBhPVxcXCJcXFwiO3JldHVybiBiLndpbi5nZXRTZWxlY3Rpb24/YT1iLndpbi5nZXRTZWxlY3Rpb24oKTpiLmRvYy5nZXRTZWxlY3Rpb24/YT1iLmRvYy5nZXRTZWxlY3Rpb24oKTpiLmRvYy5zZWxlY3Rpb24mJihhPWIuZG9jLnNlbGVjdGlvbi5jcmVhdGVSYW5nZSgpLnRleHQpLGEudG9TdHJpbmcoKX1mdW5jdGlvbiBkKCl7dmFyIGE9XFxcIlxcXCI7cmV0dXJuIGE9Yi53aW4uZ2V0U2VsZWN0aW9uP2Iud2luLmdldFNlbGVjdGlvbigpOmIuZG9jLmdldFNlbGVjdGlvbj9iLmRvYy5nZXRTZWxlY3Rpb24oKTpiLmRvYy5zZWxlY3Rpb24uY3JlYXRlUmFuZ2UoKX1mdW5jdGlvbiBlKGEpe3ZhciBjPWQoKSxlPVtdO2lmKGMmJmMuZ2V0UmFuZ2VBdCYmYy5yYW5nZUNvdW50KXtlPVtdO2Zvcih2YXIgZj0wO2Y8Yy5yYW5nZUNvdW50O2YrKyllLnB1c2goYy5nZXRSYW5nZUF0KGYpKX1lbHNlIGU9Yi5kb2MuY3JlYXRlUmFuZ2U/W2IuZG9jLmNyZWF0ZVJhbmdlKCldOltdO3JldHVyblxcXCJ1bmRlZmluZWRcXFwiIT10eXBlb2YgYT9lW2FdOmV9ZnVuY3Rpb24gZigpe3ZhciBhPWQoKTt0cnl7YS5yZW1vdmVBbGxSYW5nZXM/YS5yZW1vdmVBbGxSYW5nZXMoKTphLmVtcHR5P2EuZW1wdHkoKTphLmNsZWFyJiZhLmNsZWFyKCl9Y2F0Y2goYil7fX1mdW5jdGlvbiBnKCl7dmFyIGY9ZCgpO3RyeXtpZihmLnJhbmdlQ291bnQpe3ZhciBnLGg9ZSgwKSxpPWguc3RhcnRDb250YWluZXI7aWYoaS5ub2RlVHlwZT09Tm9kZS5URVhUX05PREUmJmguc3RhcnRPZmZzZXQ9PShpLnRleHRDb250ZW50fHxcXFwiXFxcIikubGVuZ3RoJiZpLm5leHRTaWJsaW5nJiYoaT1pLm5leHRTaWJsaW5nKSxpLm5vZGVUeXBlPT1Ob2RlLkVMRU1FTlRfTk9ERSl7dmFyIGo9ITE7aWYoaS5jaGlsZE5vZGVzLmxlbmd0aD4wJiZpLmNoaWxkTm9kZXNbaC5zdGFydE9mZnNldF0pe2ZvcihnPWkuY2hpbGROb2Rlc1toLnN0YXJ0T2Zmc2V0XTtnJiZnLm5vZGVUeXBlPT1Ob2RlLlRFWFRfTk9ERSYmMD09PWcudGV4dENvbnRlbnQubGVuZ3RoOylnPWcubmV4dFNpYmxpbmc7aWYoZyYmZy50ZXh0Q29udGVudC5yZXBsYWNlKC9cXFxcdTIwMEIvZyxcXFwiXFxcIik9PT1jKCkucmVwbGFjZSgvXFxcXHUyMDBCL2csXFxcIlxcXCIpJiYoaT1nLGo9ITApLCFqJiZpLmNoaWxkTm9kZXMubGVuZ3RoPjEmJmguc3RhcnRPZmZzZXQ+MCYmaS5jaGlsZE5vZGVzW2guc3RhcnRPZmZzZXQtMV0pe2ZvcihnPWkuY2hpbGROb2Rlc1toLnN0YXJ0T2Zmc2V0LTFdO2cmJmcubm9kZVR5cGU9PU5vZGUuVEVYVF9OT0RFJiYwPT09Zy50ZXh0Q29udGVudC5sZW5ndGg7KWc9Zy5uZXh0U2libGluZztnJiZnLnRleHRDb250ZW50LnJlcGxhY2UoL1xcXFx1MjAwQi9nLFxcXCJcXFwiKT09PWMoKS5yZXBsYWNlKC9cXFxcdTIwMEIvZyxcXFwiXFxcIikmJihpPWcsaj0hMCl9fWVsc2UhaC5jb2xsYXBzZWQmJmkubmV4dFNpYmxpbmcmJmkubmV4dFNpYmxpbmcubm9kZVR5cGU9PU5vZGUuRUxFTUVOVF9OT0RFJiYoZz1pLm5leHRTaWJsaW5nLGcmJmcudGV4dENvbnRlbnQucmVwbGFjZSgvXFxcXHUyMDBCL2csXFxcIlxcXCIpPT09YygpLnJlcGxhY2UoL1xcXFx1MjAwQi9nLFxcXCJcXFwiKSYmKGk9ZyxqPSEwKSk7IWomJmkuY2hpbGROb2Rlcy5sZW5ndGg+MCYmYShpLmNoaWxkTm9kZXNbMF0pLnRleHQoKS5yZXBsYWNlKC9cXFxcdTIwMEIvZyxcXFwiXFxcIik9PT1jKCkucmVwbGFjZSgvXFxcXHUyMDBCL2csXFxcIlxcXCIpJiZbXFxcIkJSXFxcIixcXFwiSU1HXFxcIixcXFwiSFJcXFwiXS5pbmRleE9mKGkuY2hpbGROb2Rlc1swXS50YWdOYW1lKTwwJiYoaT1pLmNoaWxkTm9kZXNbMF0pfWZvcig7aS5ub2RlVHlwZSE9Tm9kZS5FTEVNRU5UX05PREUmJmkucGFyZW50Tm9kZTspaT1pLnBhcmVudE5vZGU7Zm9yKHZhciBrPWk7ayYmXFxcIkhUTUxcXFwiIT1rLnRhZ05hbWU7KXtpZihrPT1iLmVsKXJldHVybiBpO2s9YShrKS5wYXJlbnQoKVswXX19fWNhdGNoKGwpe31yZXR1cm4gYi5lbH1mdW5jdGlvbiBoKCl7dmFyIGY9ZCgpO3RyeXtpZihmLnJhbmdlQ291bnQpe3ZhciBnLGg9ZSgwKSxpPWguZW5kQ29udGFpbmVyO2lmKGkubm9kZVR5cGU9PU5vZGUuRUxFTUVOVF9OT0RFKXt2YXIgaj0hMTtpLmNoaWxkTm9kZXMubGVuZ3RoPjAmJmkuY2hpbGROb2Rlc1toLmVuZE9mZnNldF0mJmEoaS5jaGlsZE5vZGVzW2guZW5kT2Zmc2V0XSkudGV4dCgpPT09YygpPyhpPWkuY2hpbGROb2Rlc1toLmVuZE9mZnNldF0saj0hMCk6IWguY29sbGFwc2VkJiZpLnByZXZpb3VzU2libGluZyYmaS5wcmV2aW91c1NpYmxpbmcubm9kZVR5cGU9PU5vZGUuRUxFTUVOVF9OT0RFPyhnPWkucHJldmlvdXNTaWJsaW5nLGcmJmcudGV4dENvbnRlbnQucmVwbGFjZSgvXFxcXHUyMDBCL2csXFxcIlxcXCIpPT09YygpLnJlcGxhY2UoL1xcXFx1MjAwQi9nLFxcXCJcXFwiKSYmKGk9ZyxqPSEwKSk6IWguY29sbGFwc2VkJiZpLmNoaWxkTm9kZXMubGVuZ3RoPjAmJmkuY2hpbGROb2Rlc1toLmVuZE9mZnNldF0mJihnPWkuY2hpbGROb2Rlc1toLmVuZE9mZnNldF0ucHJldmlvdXNTaWJsaW5nLGcubm9kZVR5cGU9PU5vZGUuRUxFTUVOVF9OT0RFJiZnJiZnLnRleHRDb250ZW50LnJlcGxhY2UoL1xcXFx1MjAwQi9nLFxcXCJcXFwiKT09PWMoKS5yZXBsYWNlKC9cXFxcdTIwMEIvZyxcXFwiXFxcIikmJihpPWcsaj0hMCkpLCFqJiZpLmNoaWxkTm9kZXMubGVuZ3RoPjAmJmEoaS5jaGlsZE5vZGVzW2kuY2hpbGROb2Rlcy5sZW5ndGgtMV0pLnRleHQoKT09PWMoKSYmW1xcXCJCUlxcXCIsXFxcIklNR1xcXCIsXFxcIkhSXFxcIl0uaW5kZXhPZihpLmNoaWxkTm9kZXNbaS5jaGlsZE5vZGVzLmxlbmd0aC0xXS50YWdOYW1lKTwwJiYoaT1pLmNoaWxkTm9kZXNbaS5jaGlsZE5vZGVzLmxlbmd0aC0xXSl9Zm9yKGkubm9kZVR5cGU9PU5vZGUuVEVYVF9OT0RFJiYwPT09aC5lbmRPZmZzZXQmJmkucHJldmlvdXNTaWJsaW5nJiZpLnByZXZpb3VzU2libGluZy5ub2RlVHlwZT09Tm9kZS5FTEVNRU5UX05PREUmJihpPWkucHJldmlvdXNTaWJsaW5nKTtpLm5vZGVUeXBlIT1Ob2RlLkVMRU1FTlRfTk9ERSYmaS5wYXJlbnROb2RlOylpPWkucGFyZW50Tm9kZTtmb3IodmFyIGs9aTtrJiZcXFwiSFRNTFxcXCIhPWsudGFnTmFtZTspe2lmKGs9PWIuZWwpcmV0dXJuIGk7az1hKGspLnBhcmVudCgpWzBdfX19Y2F0Y2gobCl7fXJldHVybiBiLmVsfWZ1bmN0aW9uIGkoYSxiKXt2YXIgYz1hO3JldHVybiBjLm5vZGVUeXBlPT1Ob2RlLkVMRU1FTlRfTk9ERSYmYy5jaGlsZE5vZGVzLmxlbmd0aD4wJiZjLmNoaWxkTm9kZXNbYl0mJihjPWMuY2hpbGROb2Rlc1tiXSksYy5ub2RlVHlwZT09Tm9kZS5URVhUX05PREUmJihjPWMucGFyZW50Tm9kZSksY31mdW5jdGlvbiBqKCl7dmFyIGMsZj1bXSxnPWQoKTtpZih1KCkmJmcucmFuZ2VDb3VudCl7dmFyIGg9ZSgpO2ZvcihjPTA7YzxoLmxlbmd0aDtjKyspe3ZhciBqLGs9aFtjXSxsPWkoay5zdGFydENvbnRhaW5lcixrLnN0YXJ0T2Zmc2V0KSxtPWkoay5lbmRDb250YWluZXIsay5lbmRPZmZzZXQpO2Iubm9kZS5pc0Jsb2NrKGwpJiZmLmluZGV4T2YobCk8MCYmZi5wdXNoKGwpLGo9Yi5ub2RlLmJsb2NrUGFyZW50KGwpLGomJmYuaW5kZXhPZihqKTwwJiZmLnB1c2goaik7Zm9yKHZhciBuPVtdLG89bDtvIT09bSYmbyE9PWIuZWw7KW4uaW5kZXhPZihvKTwwJiZvLmNoaWxkcmVuJiZvLmNoaWxkcmVuLmxlbmd0aD8obi5wdXNoKG8pLG89by5jaGlsZHJlblswXSk6by5uZXh0U2libGluZz9vPW8ubmV4dFNpYmxpbmc6by5wYXJlbnROb2RlJiYobz1vLnBhcmVudE5vZGUsbi5wdXNoKG8pKSxiLm5vZGUuaXNCbG9jayhvKSYmbi5pbmRleE9mKG8pPDAmJmYuaW5kZXhPZihvKTwwJiYobyE9PW18fGsuZW5kT2Zmc2V0PjApJiZmLnB1c2gobyk7Yi5ub2RlLmlzQmxvY2sobSkmJmYuaW5kZXhPZihtKTwwJiZrLmVuZE9mZnNldD4wJiZmLnB1c2gobSksaj1iLm5vZGUuYmxvY2tQYXJlbnQobSksaiYmZi5pbmRleE9mKGopPDAmJmYucHVzaChqKX19Zm9yKGM9Zi5sZW5ndGgtMTtjPjA7Yy0tKWEoZltjXSkuZmluZChmKS5sZW5ndGgmJihcXFwiTElcXFwiIT1mW2NdLnRhZ05hbWV8fDE9PWZbY10uY2hpbGRyZW4ubGVuZ3RoJiZmLmluZGV4T2YoZltjXS5jaGlsZHJlblswXSk+PTApJiZmLnNwbGljZShjLDEpO3JldHVybiBmfWZ1bmN0aW9uIGsoKXtpZihiLiR3cCl7Yi5tYXJrZXJzLnJlbW92ZSgpO3ZhciBhLGMsZD1lKCksZj1bXTtmb3IoYz0wO2M8ZC5sZW5ndGg7YysrKWlmKGRbY10uc3RhcnRDb250YWluZXIhPT1iLmRvYyl7YT1kW2NdO3ZhciBnPWEuY29sbGFwc2VkLGg9Yi5tYXJrZXJzLnBsYWNlKGEsITAsYyksaT1iLm1hcmtlcnMucGxhY2UoYSwhMSxjKTtiLmVsLm5vcm1hbGl6ZSgpLGIuYnJvd3Nlci5zYWZhcmkmJiFnJiYoYT1iLmRvYy5jcmVhdGVSYW5nZSgpLGEuc2V0U3RhcnRBZnRlcihoKSxhLnNldEVuZEJlZm9yZShpKSxmLnB1c2goYSkpfWlmKGIuYnJvd3Nlci5zYWZhcmkmJmYubGVuZ3RoKWZvcihiLnNlbGVjdGlvbi5jbGVhcigpLGM9MDtjPGYubGVuZ3RoO2MrKyliLnNlbGVjdGlvbi5nZXQoKS5hZGRSYW5nZShmW2NdKX19ZnVuY3Rpb24gbCgpe3ZhciBjLGU9Yi5lbC5xdWVyeVNlbGVjdG9yQWxsKCcuZnItbWFya2VyW2RhdGEtdHlwZT1cXFwidHJ1ZVxcXCJdJyk7aWYoIWIuJHdwKXJldHVybiBiLm1hcmtlcnMucmVtb3ZlKCksITE7aWYoMD09PWUubGVuZ3RoKXJldHVybiExO2lmKGIuYnJvd3Nlci5tc2llfHxiLmJyb3dzZXIuZWRnZSlmb3IoYz0wO2M8ZS5sZW5ndGg7YysrKWVbY10uc3R5bGUuZGlzcGxheT1cXFwiaW5saW5lLWJsb2NrXFxcIjtiLmNvcmUuaGFzRm9jdXMoKXx8Yi5icm93c2VyLm1zaWV8fGIuYnJvd3Nlci53ZWJraXR8fGIuJGVsLmZvY3VzKCksZigpO3ZhciBnPWQoKTtmb3IoYz0wO2M8ZS5sZW5ndGg7YysrKXt2YXIgaD1hKGVbY10pLmRhdGEoXFxcImlkXFxcIiksaT1lW2NdLGo9Yi5kb2MuY3JlYXRlUmFuZ2UoKSxrPWIuJGVsLmZpbmQoJy5mci1tYXJrZXJbZGF0YS10eXBlPVxcXCJmYWxzZVxcXCJdW2RhdGEtaWQ9XFxcIicraCsnXFxcIl0nKTsoYi5icm93c2VyLm1zaWV8fGIuYnJvd3Nlci5lZGdlKSYmay5jc3MoXFxcImRpc3BsYXlcXFwiLFxcXCJpbmxpbmUtYmxvY2tcXFwiKTt2YXIgbD1udWxsO2lmKGsubGVuZ3RoPjApe2s9a1swXTt0cnl7Zm9yKHZhciBuLG89ITEscD1pLm5leHRTaWJsaW5nO3AmJnAubm9kZVR5cGU9PU5vZGUuVEVYVF9OT0RFJiYwPT09cC50ZXh0Q29udGVudC5sZW5ndGg7KW49cCxwPXAubmV4dFNpYmxpbmcsYShuKS5yZW1vdmUoKTtmb3IodmFyIHE9ay5uZXh0U2libGluZztxJiZxLm5vZGVUeXBlPT1Ob2RlLlRFWFRfTk9ERSYmMD09PXEudGV4dENvbnRlbnQubGVuZ3RoOyluPXEscT1xLm5leHRTaWJsaW5nLGEobikucmVtb3ZlKCk7aWYoaS5uZXh0U2libGluZz09a3x8ay5uZXh0U2libGluZz09aSl7Zm9yKHZhciByPWkubmV4dFNpYmxpbmc9PWs/aTprLHM9cj09aT9rOmksdD1yLnByZXZpb3VzU2libGluZzt0JiZ0Lm5vZGVUeXBlPT1Ob2RlLlRFWFRfTk9ERSYmMD09PXQubGVuZ3RoOyluPXQsdD10LnByZXZpb3VzU2libGluZyxhKG4pLnJlbW92ZSgpO2lmKHQmJnQubm9kZVR5cGU9PU5vZGUuVEVYVF9OT0RFKWZvcig7dCYmdC5wcmV2aW91c1NpYmxpbmcmJnQucHJldmlvdXNTaWJsaW5nLm5vZGVUeXBlPT1Ob2RlLlRFWFRfTk9ERTspdC5wcmV2aW91c1NpYmxpbmcudGV4dENvbnRlbnQ9dC5wcmV2aW91c1NpYmxpbmcudGV4dENvbnRlbnQrdC50ZXh0Q29udGVudCx0PXQucHJldmlvdXNTaWJsaW5nLGEodC5uZXh0U2libGluZykucmVtb3ZlKCk7Zm9yKHZhciB1PXMubmV4dFNpYmxpbmc7dSYmdS5ub2RlVHlwZT09Tm9kZS5URVhUX05PREUmJjA9PT11Lmxlbmd0aDspbj11LHU9dS5uZXh0U2libGluZyxhKG4pLnJlbW92ZSgpO2lmKHUmJnUubm9kZVR5cGU9PU5vZGUuVEVYVF9OT0RFKWZvcig7dSYmdS5uZXh0U2libGluZyYmdS5uZXh0U2libGluZy5ub2RlVHlwZT09Tm9kZS5URVhUX05PREU7KXUubmV4dFNpYmxpbmcudGV4dENvbnRlbnQ9dS50ZXh0Q29udGVudCt1Lm5leHRTaWJsaW5nLnRleHRDb250ZW50LHU9dS5uZXh0U2libGluZyxhKHUucHJldmlvdXNTaWJsaW5nKS5yZW1vdmUoKTtpZih0JiYoYi5ub2RlLmlzVm9pZCh0KXx8Yi5ub2RlLmlzQmxvY2sodCkpJiYodD1udWxsKSx1JiYoYi5ub2RlLmlzVm9pZCh1KXx8Yi5ub2RlLmlzQmxvY2sodSkpJiYodT1udWxsKSx0JiZ1JiZ0Lm5vZGVUeXBlPT1Ob2RlLlRFWFRfTk9ERSYmdS5ub2RlVHlwZT09Tm9kZS5URVhUX05PREUpe2EoaSkucmVtb3ZlKCksYShrKS5yZW1vdmUoKTt2YXIgdj10LnRleHRDb250ZW50Lmxlbmd0aDt0LnRleHRDb250ZW50PXQudGV4dENvbnRlbnQrdS50ZXh0Q29udGVudCxhKHUpLnJlbW92ZSgpLGIuc3BhY2VzLm5vcm1hbGl6ZSh0KSxqLnNldFN0YXJ0KHQsdiksai5zZXRFbmQodCx2KSxvPSEwfWVsc2UhdCYmdSYmdS5ub2RlVHlwZT09Tm9kZS5URVhUX05PREU/KGEoaSkucmVtb3ZlKCksYShrKS5yZW1vdmUoKSxiLnNwYWNlcy5ub3JtYWxpemUodSksbD1hKGIuZG9jLmNyZWF0ZVRleHROb2RlKFxcXCJcXFxcdTIwMGJcXFwiKSksYSh1KS5iZWZvcmUobCksai5zZXRTdGFydCh1LDApLGouc2V0RW5kKHUsMCksbz0hMCk6IXUmJnQmJnQubm9kZVR5cGU9PU5vZGUuVEVYVF9OT0RFJiYoYShpKS5yZW1vdmUoKSxhKGspLnJlbW92ZSgpLGIuc3BhY2VzLm5vcm1hbGl6ZSh0KSxsPWEoYi5kb2MuY3JlYXRlVGV4dE5vZGUoXFxcIlxcXFx1MjAwYlxcXCIpKSxhKHQpLmFmdGVyKGwpLGouc2V0U3RhcnQodCx0LnRleHRDb250ZW50Lmxlbmd0aCksai5zZXRFbmQodCx0LnRleHRDb250ZW50Lmxlbmd0aCksbz0hMCl9aWYoIW8pe3ZhciB3LHg7KGIuYnJvd3Nlci5jaHJvbWV8fGIuYnJvd3Nlci5lZGdlKSYmaS5uZXh0U2libGluZz09az8odz1tKGssaiwhMCl8fGouc2V0U3RhcnRBZnRlcihrKSx4PW0oaSxqLCExKXx8ai5zZXRFbmRCZWZvcmUoaSkpOihpLnByZXZpb3VzU2libGluZz09ayYmKGk9ayxrPWkubmV4dFNpYmxpbmcpLGsubmV4dFNpYmxpbmcmJlxcXCJCUlxcXCI9PT1rLm5leHRTaWJsaW5nLnRhZ05hbWV8fCFrLm5leHRTaWJsaW5nJiZiLm5vZGUuaXNCbG9jayhpLnByZXZpb3VzU2libGluZyl8fGkucHJldmlvdXNTaWJsaW5nJiZcXFwiQlJcXFwiPT1pLnByZXZpb3VzU2libGluZy50YWdOYW1lfHwoaS5zdHlsZS5kaXNwbGF5PVxcXCJpbmxpbmVcXFwiLGsuc3R5bGUuZGlzcGxheT1cXFwiaW5saW5lXFxcIixsPWEoYi5kb2MuY3JlYXRlVGV4dE5vZGUoXFxcIlxcXFx1MjAwYlxcXCIpKSksdz1tKGksaiwhMCl8fGEoaSkuYmVmb3JlKGwpJiZqLnNldFN0YXJ0QmVmb3JlKGkpLHg9bShrLGosITEpfHxhKGspLmFmdGVyKGwpJiZqLnNldEVuZEFmdGVyKGspKSxcXFwiZnVuY3Rpb25cXFwiPT10eXBlb2YgdyYmdygpLFxcXCJmdW5jdGlvblxcXCI9PXR5cGVvZiB4JiZ4KCl9fWNhdGNoKHkpe2NvbnNvbGUud2FybihcXFwiUkVTVE9SRSBSQU5HRVxcXCIseSl9fWwmJmwucmVtb3ZlKCk7dHJ5e2cuYWRkUmFuZ2Uoail9Y2F0Y2goeSl7Y29uc29sZS53YXJuKFxcXCJBREQgUkFOR0VcXFwiLHkpfX1iLm1hcmtlcnMucmVtb3ZlKCl9ZnVuY3Rpb24gbShjLGQsZSl7dmFyIGYsZz1jLnByZXZpb3VzU2libGluZyxoPWMubmV4dFNpYmxpbmc7cmV0dXJuIGcmJmgmJmcubm9kZVR5cGU9PU5vZGUuVEVYVF9OT0RFJiZoLm5vZGVUeXBlPT1Ob2RlLlRFWFRfTk9ERT8oZj1nLnRleHRDb250ZW50Lmxlbmd0aCxlPyhoLnRleHRDb250ZW50PWcudGV4dENvbnRlbnQraC50ZXh0Q29udGVudCxhKGcpLnJlbW92ZSgpLGEoYykucmVtb3ZlKCksYi5zcGFjZXMubm9ybWFsaXplKGgpLGZ1bmN0aW9uKCl7ZC5zZXRTdGFydChoLGYpfSk6KGcudGV4dENvbnRlbnQ9Zy50ZXh0Q29udGVudCtoLnRleHRDb250ZW50LGEoaCkucmVtb3ZlKCksYShjKS5yZW1vdmUoKSxiLnNwYWNlcy5ub3JtYWxpemUoZyksZnVuY3Rpb24oKXtkLnNldEVuZChnLGYpO1xcbn0pKTpnJiYhaCYmZy5ub2RlVHlwZT09Tm9kZS5URVhUX05PREU/KGY9Zy50ZXh0Q29udGVudC5sZW5ndGgsZT8oYi5zcGFjZXMubm9ybWFsaXplKGcpLGZ1bmN0aW9uKCl7ZC5zZXRTdGFydChnLGYpfSk6KGIuc3BhY2VzLm5vcm1hbGl6ZShnKSxmdW5jdGlvbigpe2Quc2V0RW5kKGcsZil9KSk6ISghaHx8Z3x8aC5ub2RlVHlwZSE9Tm9kZS5URVhUX05PREUpJiYoZT8oYi5zcGFjZXMubm9ybWFsaXplKGgpLGZ1bmN0aW9uKCl7ZC5zZXRTdGFydChoLDApfSk6KGIuc3BhY2VzLm5vcm1hbGl6ZShoKSxmdW5jdGlvbigpe2Quc2V0RW5kKGgsMCl9KSl9ZnVuY3Rpb24gbigpe3JldHVybiEwfWZ1bmN0aW9uIG8oKXtmb3IodmFyIGE9ZSgpLGI9MDtiPGEubGVuZ3RoO2IrKylpZighYVtiXS5jb2xsYXBzZWQpcmV0dXJuITE7cmV0dXJuITB9ZnVuY3Rpb24gcChhKXt2YXIgYyxkLGU9ITEsZj0hMTtpZihiLndpbi5nZXRTZWxlY3Rpb24pe3ZhciBnPWIud2luLmdldFNlbGVjdGlvbigpO2cucmFuZ2VDb3VudCYmKGM9Zy5nZXRSYW5nZUF0KDApLGQ9Yy5jbG9uZVJhbmdlKCksZC5zZWxlY3ROb2RlQ29udGVudHMoYSksZC5zZXRFbmQoYy5zdGFydENvbnRhaW5lcixjLnN0YXJ0T2Zmc2V0KSxlPVxcXCJcXFwiPT09ZC50b1N0cmluZygpLGQuc2VsZWN0Tm9kZUNvbnRlbnRzKGEpLGQuc2V0U3RhcnQoYy5lbmRDb250YWluZXIsYy5lbmRPZmZzZXQpLGY9XFxcIlxcXCI9PT1kLnRvU3RyaW5nKCkpfWVsc2UgYi5kb2Muc2VsZWN0aW9uJiZcXFwiQ29udHJvbFxcXCIhPWIuZG9jLnNlbGVjdGlvbi50eXBlJiYoYz1iLmRvYy5zZWxlY3Rpb24uY3JlYXRlUmFuZ2UoKSxkPWMuZHVwbGljYXRlKCksZC5tb3ZlVG9FbGVtZW50VGV4dChhKSxkLnNldEVuZFBvaW50KFxcXCJFbmRUb1N0YXJ0XFxcIixjKSxlPVxcXCJcXFwiPT09ZC50ZXh0LGQubW92ZVRvRWxlbWVudFRleHQoYSksZC5zZXRFbmRQb2ludChcXFwiU3RhcnRUb0VuZFxcXCIsYyksZj1cXFwiXFxcIj09PWQudGV4dCk7cmV0dXJue2F0U3RhcnQ6ZSxhdEVuZDpmfX1mdW5jdGlvbiBxKCl7aWYobygpKXJldHVybiExO2IuJGVsLmZpbmQoXFxcInRkLCB0aCwgaW1nLCBicjpub3QoOmxhc3QpXFxcIikucHJlcGVuZCgnPHNwYW4gY2xhc3M9XFxcImZyLW1rXFxcIj4nK2EuRkUuSU5WSVNJQkxFX1NQQUNFK1xcXCI8L3NwYW4+XFxcIik7dmFyIGM9ITEsZD1wKGIuZWwpO3JldHVybiBkLmF0U3RhcnQmJmQuYXRFbmQmJihjPSEwKSxiLiRlbC5maW5kKFxcXCIuZnItbWtcXFwiKS5yZW1vdmUoKSxjfWZ1bmN0aW9uIHIoYyxkKXtcXFwidW5kZWZpbmVkXFxcIj09dHlwZW9mIGQmJihkPSEwKTt2YXIgZT1hKGMpLmh0bWwoKTtlJiZlLnJlcGxhY2UoL1xcXFx1MjAwYi9nLFxcXCJcXFwiKS5sZW5ndGghPWUubGVuZ3RoJiZhKGMpLmh0bWwoZS5yZXBsYWNlKC9cXFxcdTIwMGIvZyxcXFwiXFxcIikpO2Zvcih2YXIgZj1iLm5vZGUuY29udGVudHMoYyksZz0wO2c8Zi5sZW5ndGg7ZysrKWZbZ10ubm9kZVR5cGUhPU5vZGUuRUxFTUVOVF9OT0RFP2EoZltnXSkucmVtb3ZlKCk6KHIoZltnXSwwPT09ZyksMD09PWcmJihkPSExKSk7Yy5ub2RlVHlwZT09Tm9kZS5URVhUX05PREU/YShjKS5yZXBsYWNlV2l0aCgnPHNwYW4gZGF0YS1maXJzdD1cXFwidHJ1ZVxcXCIgZGF0YS10ZXh0PVxcXCJ0cnVlXFxcIj48L3NwYW4+Jyk6ZCYmYShjKS5hdHRyKFxcXCJkYXRhLWZpcnN0XFxcIiwhMCl9ZnVuY3Rpb24gcygpe3JldHVybiAwPT09YSh0aGlzKS5maW5kKFxcXCJmci1pbm5lclxcXCIpLmxlbmd0aH1mdW5jdGlvbiB0KGMsZCl7dmFyIGU9Yi5ub2RlLmNvbnRlbnRzKGMuZ2V0KDApKTtbXFxcIlREXFxcIixcXFwiVEhcXFwiXS5pbmRleE9mKGMuZ2V0KDApLnRhZ05hbWUpPj0wJiYxPT1jLmZpbmQoXFxcIi5mci1tYXJrZXJcXFwiKS5sZW5ndGgmJmIubm9kZS5oYXNDbGFzcyhlWzBdLFxcXCJmci1tYXJrZXJcXFwiKSYmYy5hdHRyKFxcXCJkYXRhLWRlbC1jZWxsXFxcIiwhMCk7Zm9yKHZhciBmPTA7ZjxlLmxlbmd0aDtmKyspe3ZhciBnPWVbZl07Yi5ub2RlLmhhc0NsYXNzKGcsXFxcImZyLW1hcmtlclxcXCIpP2Q9KGQrMSklMjpkP2EoZykuZmluZChcXFwiLmZyLW1hcmtlclxcXCIpLmxlbmd0aD4wP2Q9dChhKGcpLGQpOltcXFwiVERcXFwiLFxcXCJUSFxcXCJdLmluZGV4T2YoZy50YWdOYW1lKTwwJiYhYi5ub2RlLmhhc0NsYXNzKGcsXFxcImZyLWlubmVyXFxcIik/IWIub3B0cy5rZWVwRm9ybWF0T25EZWxldGV8fGIuJGVsLmZpbmQoXFxcIltkYXRhLWZpcnN0XVxcXCIpLmxlbmd0aD4wP2EoZykucmVtb3ZlKCk6cihnKTpiLm5vZGUuaGFzQ2xhc3MoZyxcXFwiZnItaW5uZXJcXFwiKT8wPT09YShnKS5maW5kKFxcXCIuZnItaW5uZXJcXFwiKS5sZW5ndGg/YShnKS5odG1sKFxcXCI8YnI+XFxcIik6YShnKS5maW5kKFxcXCIuZnItaW5uZXJcXFwiKS5maWx0ZXIocykuaHRtbChcXFwiPGJyPlxcXCIpOihhKGcpLmVtcHR5KCksYShnKS5hdHRyKFxcXCJkYXRhLWRlbC1jZWxsXFxcIiwhMCkpOmEoZykuZmluZChcXFwiLmZyLW1hcmtlclxcXCIpLmxlbmd0aD4wJiYoZD10KGEoZyksZCkpfXJldHVybiBkfWZ1bmN0aW9uIHUoKXt0cnl7aWYoIWIuJHdwKXJldHVybiExO2Zvcih2YXIgYT1lKDApLGM9YS5jb21tb25BbmNlc3RvckNvbnRhaW5lcjtjJiYhYi5ub2RlLmlzRWxlbWVudChjKTspYz1jLnBhcmVudE5vZGU7cmV0dXJuISFiLm5vZGUuaXNFbGVtZW50KGMpfWNhdGNoKGQpe3JldHVybiExfX1mdW5jdGlvbiB2KCl7aWYobygpKXJldHVybiEwO3ZhciBjO2soKTt2YXIgZD1mdW5jdGlvbihiKXtmb3IodmFyIGM9Yi5wcmV2aW91c1NpYmxpbmc7YyYmYy5ub2RlVHlwZT09Tm9kZS5URVhUX05PREUmJjA9PT1jLnRleHRDb250ZW50Lmxlbmd0aDspe3ZhciBkPWM7Yz1jLnByZXZpb3VzU2libGluZyxhKGQpLnJlbW92ZSgpfXJldHVybiBjfSxlPWZ1bmN0aW9uKGIpe2Zvcih2YXIgYz1iLm5leHRTaWJsaW5nO2MmJmMubm9kZVR5cGU9PU5vZGUuVEVYVF9OT0RFJiYwPT09Yy50ZXh0Q29udGVudC5sZW5ndGg7KXt2YXIgZD1jO2M9Yy5uZXh0U2libGluZyxhKGQpLnJlbW92ZSgpfXJldHVybiBjfSxmPWIuJGVsLmZpbmQoJy5mci1tYXJrZXJbZGF0YS10eXBlPVxcXCJ0cnVlXFxcIl0nKTtmb3IoYz0wO2M8Zi5sZW5ndGg7YysrKWZvcih2YXIgZz1mW2NdOyFkKGcpJiYhYi5ub2RlLmlzQmxvY2soZy5wYXJlbnROb2RlKSYmIWIuJGVsLmlzKGcucGFyZW50Tm9kZSk7KWEoZy5wYXJlbnROb2RlKS5iZWZvcmUoZyk7dmFyIGg9Yi4kZWwuZmluZCgnLmZyLW1hcmtlcltkYXRhLXR5cGU9XFxcImZhbHNlXFxcIl0nKTtmb3IoYz0wO2M8aC5sZW5ndGg7YysrKXtmb3IodmFyIGk9aFtjXTshZShpKSYmIWIubm9kZS5pc0Jsb2NrKGkucGFyZW50Tm9kZSkmJiFiLiRlbC5pcyhpLnBhcmVudE5vZGUpOylhKGkucGFyZW50Tm9kZSkuYWZ0ZXIoaSk7aS5wYXJlbnROb2RlJiZiLm5vZGUuaXNCbG9jayhpLnBhcmVudE5vZGUpJiZiLm5vZGUuaXNFbXB0eShpLnBhcmVudE5vZGUpJiYhYi4kZWwuaXMoaS5wYXJlbnROb2RlKSYmYi5vcHRzLmtlZXBGb3JtYXRPbkRlbGV0ZSYmYShpLnBhcmVudE5vZGUpLmFmdGVyKGkpfWlmKG4oKSl7dChiLiRlbCwwKTt2YXIgaj1iLiRlbC5maW5kKCdbZGF0YS1maXJzdD1cXFwidHJ1ZVxcXCJdJyk7aWYoai5sZW5ndGgpYi4kZWwuZmluZChcXFwiLmZyLW1hcmtlclxcXCIpLnJlbW92ZSgpLGouYXBwZW5kKGEuRkUuSU5WSVNJQkxFX1NQQUNFK2EuRkUuTUFSS0VSUykucmVtb3ZlQXR0cihcXFwiZGF0YS1maXJzdFxcXCIpLGouYXR0cihcXFwiZGF0YS10ZXh0XFxcIikmJmoucmVwbGFjZVdpdGgoai5odG1sKCkpO2Vsc2UgZm9yKGIuJGVsLmZpbmQoXFxcInRhYmxlXFxcIikuZmlsdGVyKGZ1bmN0aW9uKCl7dmFyIGI9YSh0aGlzKS5maW5kKFxcXCJbZGF0YS1kZWwtY2VsbF1cXFwiKS5sZW5ndGg+MCYmYSh0aGlzKS5maW5kKFxcXCJbZGF0YS1kZWwtY2VsbF1cXFwiKS5sZW5ndGg9PWEodGhpcykuZmluZChcXFwidGQsIHRoXFxcIikubGVuZ3RoO3JldHVybiBifSkucmVtb3ZlKCksYi4kZWwuZmluZChcXFwiW2RhdGEtZGVsLWNlbGxdXFxcIikucmVtb3ZlQXR0cihcXFwiZGF0YS1kZWwtY2VsbFxcXCIpLGY9Yi4kZWwuZmluZCgnLmZyLW1hcmtlcltkYXRhLXR5cGU9XFxcInRydWVcXFwiXScpLGM9MDtjPGYubGVuZ3RoO2MrKyl7dmFyIG09ZltjXSxwPW0ubmV4dFNpYmxpbmcscT1iLiRlbC5maW5kKCcuZnItbWFya2VyW2RhdGEtdHlwZT1cXFwiZmFsc2VcXFwiXVtkYXRhLWlkPVxcXCInK2EobSkuZGF0YShcXFwiaWRcXFwiKSsnXFxcIl0nKS5nZXQoMCk7aWYocSl7aWYobSYmKCFwfHxwIT1xKSl7dmFyIHI9Yi5ub2RlLmJsb2NrUGFyZW50KG0pLHM9Yi5ub2RlLmJsb2NrUGFyZW50KHEpLHU9ITEsdj0hMTtpZihyJiZbXFxcIlVMXFxcIixcXFwiT0xcXFwiXS5pbmRleE9mKHIudGFnTmFtZSk+PTAmJihyPW51bGwsdT0hMCkscyYmW1xcXCJVTFxcXCIsXFxcIk9MXFxcIl0uaW5kZXhPZihzLnRhZ05hbWUpPj0wJiYocz1udWxsLHY9ITApLGEobSkuYWZ0ZXIocSksciE9cylpZihudWxsIT1yfHx1KWlmKG51bGwhPXN8fHZ8fDAhPT1hKHIpLnBhcmVudHNVbnRpbChiLiRlbCxcXFwidGFibGVcXFwiKS5sZW5ndGgpciYmcyYmMD09PWEocikucGFyZW50c1VudGlsKGIuJGVsLFxcXCJ0YWJsZVxcXCIpLmxlbmd0aCYmMD09PWEocykucGFyZW50c1VudGlsKGIuJGVsLFxcXCJ0YWJsZVxcXCIpLmxlbmd0aCYmKGEocikuYXBwZW5kKGEocykuaHRtbCgpKSxhKHMpLnJlbW92ZSgpKTtlbHNle2ZvcihwPXI7IXAubmV4dFNpYmxpbmcmJnAucGFyZW50Tm9kZSE9Yi5lbDspcD1wLnBhcmVudE5vZGU7Zm9yKHA9cC5uZXh0U2libGluZztwJiZcXFwiQlJcXFwiIT1wLnRhZ05hbWU7KXt2YXIgdz1wLm5leHRTaWJsaW5nO2EocikuYXBwZW5kKHApLHA9d31wJiZcXFwiQlJcXFwiPT1wLnRhZ05hbWUmJmEocCkucmVtb3ZlKCl9ZWxzZXt2YXIgeD1iLm5vZGUuZGVlcGVzdFBhcmVudChtKTt4PyhhKHgpLmFmdGVyKGEocykuaHRtbCgpKSxhKHMpLnJlbW92ZSgpKTowPT09YShzKS5wYXJlbnRzVW50aWwoYi4kZWwsXFxcInRhYmxlXFxcIikubGVuZ3RoJiYoYShtKS5uZXh0KCkuYWZ0ZXIoYShzKS5odG1sKCkpLGEocykucmVtb3ZlKCkpfX19ZWxzZSBxPWEobSkuY2xvbmUoKS5hdHRyKFxcXCJkYXRhLXR5cGVcXFwiLCExKSxhKG0pLmFmdGVyKHEpfX1iLm9wdHMua2VlcEZvcm1hdE9uRGVsZXRlfHxiLmh0bWwuZmlsbEVtcHR5QmxvY2tzKCksYi5odG1sLmNsZWFuRW1wdHlUYWdzKCEwKSxiLmNsZWFuLmxpc3RzKCksYi5zcGFjZXMubm9ybWFsaXplKCk7dmFyIHk9Yi4kZWwuZmluZChcXFwiLmZyLW1hcmtlcjpsYXN0XFxcIikuZ2V0KDApLHo9Yi4kZWwuZmluZChcXFwiLmZyLW1hcmtlcjpmaXJzdFxcXCIpLmdldCgwKTsheS5uZXh0U2libGluZyYmei5wcmV2aW91c1NpYmxpbmcmJlxcXCJCUlxcXCI9PXoucHJldmlvdXNTaWJsaW5nLnRhZ05hbWUmJmIubm9kZS5pc0VsZW1lbnQoeS5wYXJlbnROb2RlKSYmYi5ub2RlLmlzRWxlbWVudCh6LnBhcmVudE5vZGUpJiZiLiRlbC5hcHBlbmQoXFxcIjxicj5cXFwiKSxsKCl9ZnVuY3Rpb24gdyhjKXtpZighY3x8Yy5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKFxcXCJmci1tYXJrZXJcXFwiKS5sZW5ndGg+MClyZXR1cm4hMTtmb3IodmFyIGQ9Yy5maXJzdENoaWxkO2QmJmIubm9kZS5pc0Jsb2NrKGQpOyljPWQsZD1kLmZpcnN0Q2hpbGQ7Yy5pbm5lckhUTUw9YS5GRS5NQVJLRVJTK2MuaW5uZXJIVE1MfWZ1bmN0aW9uIHgoYyl7aWYoIWN8fGMuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShcXFwiZnItbWFya2VyXFxcIikubGVuZ3RoPjApcmV0dXJuITE7Zm9yKHZhciBkPWMubGFzdENoaWxkO2QmJmIubm9kZS5pc0Jsb2NrKGQpOyljPWQsZD1kLmxhc3RDaGlsZDtjLmlubmVySFRNTD1jLmlubmVySFRNTCthLkZFLk1BUktFUlN9ZnVuY3Rpb24geShjLGQpe1xcXCJ1bmRlZmluZWRcXFwiPT10eXBlb2YgZCYmKGQ9ITApO2Zvcih2YXIgZT1jLnByZXZpb3VzU2libGluZztlJiZlLm5vZGVUeXBlPT1Ob2RlLlRFWFRfTk9ERSYmMD09PWUudGV4dENvbnRlbnQubGVuZ3RoOyllPWUucHJldmlvdXNTaWJsaW5nO3JldHVybiBlPyhiLm5vZGUuaXNCbG9jayhlKT94KGUpOlxcXCJCUlxcXCI9PWUudGFnTmFtZT9hKGUpLmJlZm9yZShhLkZFLk1BUktFUlMpOmEoZSkuYWZ0ZXIoYS5GRS5NQVJLRVJTKSwhMCk6ISFkJiYoYi5ub2RlLmlzQmxvY2soYyk/dyhjKTphKGMpLmJlZm9yZShhLkZFLk1BUktFUlMpLCEwKX1mdW5jdGlvbiB6KGMsZCl7XFxcInVuZGVmaW5lZFxcXCI9PXR5cGVvZiBkJiYoZD0hMCk7Zm9yKHZhciBlPWMubmV4dFNpYmxpbmc7ZSYmZS5ub2RlVHlwZT09Tm9kZS5URVhUX05PREUmJjA9PT1lLnRleHRDb250ZW50Lmxlbmd0aDspZT1lLm5leHRTaWJsaW5nO3JldHVybiBlPyhiLm5vZGUuaXNCbG9jayhlKT93KGUpOmEoZSkuYmVmb3JlKGEuRkUuTUFSS0VSUyksITApOiEhZCYmKGIubm9kZS5pc0Jsb2NrKGMpP3goYyk6YShjKS5hZnRlcihhLkZFLk1BUktFUlMpLCEwKX1yZXR1cm57dGV4dDpjLGdldDpkLHJhbmdlczplLGNsZWFyOmYsZWxlbWVudDpnLGVuZEVsZW1lbnQ6aCxzYXZlOmsscmVzdG9yZTpsLGlzQ29sbGFwc2VkOm8saXNGdWxsOnEsaW5FZGl0b3I6dSxyZW1vdmU6dixibG9ja3M6aixpbmZvOnAsc2V0QXRFbmQ6eCxzZXRBdFN0YXJ0Oncsc2V0QmVmb3JlOnksc2V0QWZ0ZXI6eixyYW5nZUVsZW1lbnQ6aX19LGEuZXh0ZW5kKGEuRkUuREVGQVVMVFMse2h0bWxBbGxvd2VkVGFnczpbXFxcImFcXFwiLFxcXCJhYmJyXFxcIixcXFwiYWRkcmVzc1xcXCIsXFxcImFyZWFcXFwiLFxcXCJhcnRpY2xlXFxcIixcXFwiYXNpZGVcXFwiLFxcXCJhdWRpb1xcXCIsXFxcImJcXFwiLFxcXCJiYXNlXFxcIixcXFwiYmRpXFxcIixcXFwiYmRvXFxcIixcXFwiYmxvY2txdW90ZVxcXCIsXFxcImJyXFxcIixcXFwiYnV0dG9uXFxcIixcXFwiY2FudmFzXFxcIixcXFwiY2FwdGlvblxcXCIsXFxcImNpdGVcXFwiLFxcXCJjb2RlXFxcIixcXFwiY29sXFxcIixcXFwiY29sZ3JvdXBcXFwiLFxcXCJkYXRhbGlzdFxcXCIsXFxcImRkXFxcIixcXFwiZGVsXFxcIixcXFwiZGV0YWlsc1xcXCIsXFxcImRmblxcXCIsXFxcImRpYWxvZ1xcXCIsXFxcImRpdlxcXCIsXFxcImRsXFxcIixcXFwiZHRcXFwiLFxcXCJlbVxcXCIsXFxcImVtYmVkXFxcIixcXFwiZmllbGRzZXRcXFwiLFxcXCJmaWdjYXB0aW9uXFxcIixcXFwiZmlndXJlXFxcIixcXFwiZm9vdGVyXFxcIixcXFwiZm9ybVxcXCIsXFxcImgxXFxcIixcXFwiaDJcXFwiLFxcXCJoM1xcXCIsXFxcImg0XFxcIixcXFwiaDVcXFwiLFxcXCJoNlxcXCIsXFxcImhlYWRlclxcXCIsXFxcImhncm91cFxcXCIsXFxcImhyXFxcIixcXFwiaVxcXCIsXFxcImlmcmFtZVxcXCIsXFxcImltZ1xcXCIsXFxcImlucHV0XFxcIixcXFwiaW5zXFxcIixcXFwia2JkXFxcIixcXFwia2V5Z2VuXFxcIixcXFwibGFiZWxcXFwiLFxcXCJsZWdlbmRcXFwiLFxcXCJsaVxcXCIsXFxcImxpbmtcXFwiLFxcXCJtYWluXFxcIixcXFwibWFwXFxcIixcXFwibWFya1xcXCIsXFxcIm1lbnVcXFwiLFxcXCJtZW51aXRlbVxcXCIsXFxcIm1ldGVyXFxcIixcXFwibmF2XFxcIixcXFwibm9zY3JpcHRcXFwiLFxcXCJvYmplY3RcXFwiLFxcXCJvbFxcXCIsXFxcIm9wdGdyb3VwXFxcIixcXFwib3B0aW9uXFxcIixcXFwib3V0cHV0XFxcIixcXFwicFxcXCIsXFxcInBhcmFtXFxcIixcXFwicHJlXFxcIixcXFwicHJvZ3Jlc3NcXFwiLFxcXCJxdWV1ZVxcXCIsXFxcInJwXFxcIixcXFwicnRcXFwiLFxcXCJydWJ5XFxcIixcXFwic1xcXCIsXFxcInNhbXBcXFwiLFxcXCJzY3JpcHRcXFwiLFxcXCJzdHlsZVxcXCIsXFxcInNlY3Rpb25cXFwiLFxcXCJzZWxlY3RcXFwiLFxcXCJzbWFsbFxcXCIsXFxcInNvdXJjZVxcXCIsXFxcInNwYW5cXFwiLFxcXCJzdHJpa2VcXFwiLFxcXCJzdHJvbmdcXFwiLFxcXCJzdWJcXFwiLFxcXCJzdW1tYXJ5XFxcIixcXFwic3VwXFxcIixcXFwidGFibGVcXFwiLFxcXCJ0Ym9keVxcXCIsXFxcInRkXFxcIixcXFwidGV4dGFyZWFcXFwiLFxcXCJ0Zm9vdFxcXCIsXFxcInRoXFxcIixcXFwidGhlYWRcXFwiLFxcXCJ0aW1lXFxcIixcXFwidHJcXFwiLFxcXCJ0cmFja1xcXCIsXFxcInVcXFwiLFxcXCJ1bFxcXCIsXFxcInZhclxcXCIsXFxcInZpZGVvXFxcIixcXFwid2JyXFxcIl0saHRtbFJlbW92ZVRhZ3M6W1xcXCJzY3JpcHRcXFwiLFxcXCJzdHlsZVxcXCJdLGh0bWxBbGxvd2VkQXR0cnM6W1xcXCJhY2NlcHRcXFwiLFxcXCJhY2NlcHQtY2hhcnNldFxcXCIsXFxcImFjY2Vzc2tleVxcXCIsXFxcImFjdGlvblxcXCIsXFxcImFsaWduXFxcIixcXFwiYWxsb3dmdWxsc2NyZWVuXFxcIixcXFwiYWxsb3d0cmFuc3BhcmVuY3lcXFwiLFxcXCJhbHRcXFwiLFxcXCJhc3luY1xcXCIsXFxcImF1dG9jb21wbGV0ZVxcXCIsXFxcImF1dG9mb2N1c1xcXCIsXFxcImF1dG9wbGF5XFxcIixcXFwiYXV0b3NhdmVcXFwiLFxcXCJiYWNrZ3JvdW5kXFxcIixcXFwiYmdjb2xvclxcXCIsXFxcImJvcmRlclxcXCIsXFxcImNoYXJzZXRcXFwiLFxcXCJjZWxscGFkZGluZ1xcXCIsXFxcImNlbGxzcGFjaW5nXFxcIixcXFwiY2hlY2tlZFxcXCIsXFxcImNpdGVcXFwiLFxcXCJjbGFzc1xcXCIsXFxcImNvbG9yXFxcIixcXFwiY29sc1xcXCIsXFxcImNvbHNwYW5cXFwiLFxcXCJjb250ZW50XFxcIixcXFwiY29udGVudGVkaXRhYmxlXFxcIixcXFwiY29udGV4dG1lbnVcXFwiLFxcXCJjb250cm9sc1xcXCIsXFxcImNvb3Jkc1xcXCIsXFxcImRhdGFcXFwiLFxcXCJkYXRhLS4qXFxcIixcXFwiZGF0ZXRpbWVcXFwiLFxcXCJkZWZhdWx0XFxcIixcXFwiZGVmZXJcXFwiLFxcXCJkaXJcXFwiLFxcXCJkaXJuYW1lXFxcIixcXFwiZGlzYWJsZWRcXFwiLFxcXCJkb3dubG9hZFxcXCIsXFxcImRyYWdnYWJsZVxcXCIsXFxcImRyb3B6b25lXFxcIixcXFwiZW5jdHlwZVxcXCIsXFxcImZvclxcXCIsXFxcImZvcm1cXFwiLFxcXCJmb3JtYWN0aW9uXFxcIixcXFwiZnJhbWVib3JkZXJcXFwiLFxcXCJoZWFkZXJzXFxcIixcXFwiaGVpZ2h0XFxcIixcXFwiaGlkZGVuXFxcIixcXFwiaGlnaFxcXCIsXFxcImhyZWZcXFwiLFxcXCJocmVmbGFuZ1xcXCIsXFxcImh0dHAtZXF1aXZcXFwiLFxcXCJpY29uXFxcIixcXFwiaWRcXFwiLFxcXCJpc21hcFxcXCIsXFxcIml0ZW1wcm9wXFxcIixcXFwia2V5dHlwZVxcXCIsXFxcImtpbmRcXFwiLFxcXCJsYWJlbFxcXCIsXFxcImxhbmdcXFwiLFxcXCJsYW5ndWFnZVxcXCIsXFxcImxpc3RcXFwiLFxcXCJsb29wXFxcIixcXFwibG93XFxcIixcXFwibWF4XFxcIixcXFwibWF4bGVuZ3RoXFxcIixcXFwibWVkaWFcXFwiLFxcXCJtZXRob2RcXFwiLFxcXCJtaW5cXFwiLFxcXCJtb3phbGxvd2Z1bGxzY3JlZW5cXFwiLFxcXCJtdWx0aXBsZVxcXCIsXFxcIm5hbWVcXFwiLFxcXCJub3ZhbGlkYXRlXFxcIixcXFwib3BlblxcXCIsXFxcIm9wdGltdW1cXFwiLFxcXCJwYXR0ZXJuXFxcIixcXFwicGluZ1xcXCIsXFxcInBsYWNlaG9sZGVyXFxcIixcXFwicG9zdGVyXFxcIixcXFwicHJlbG9hZFxcXCIsXFxcInB1YmRhdGVcXFwiLFxcXCJyYWRpb2dyb3VwXFxcIixcXFwicmVhZG9ubHlcXFwiLFxcXCJyZWxcXFwiLFxcXCJyZXF1aXJlZFxcXCIsXFxcInJldmVyc2VkXFxcIixcXFwicm93c1xcXCIsXFxcInJvd3NwYW5cXFwiLFxcXCJzYW5kYm94XFxcIixcXFwic2NvcGVcXFwiLFxcXCJzY29wZWRcXFwiLFxcXCJzY3JvbGxpbmdcXFwiLFxcXCJzZWFtbGVzc1xcXCIsXFxcInNlbGVjdGVkXFxcIixcXFwic2hhcGVcXFwiLFxcXCJzaXplXFxcIixcXFwic2l6ZXNcXFwiLFxcXCJzcGFuXFxcIixcXFwic3JjXFxcIixcXFwic3JjZG9jXFxcIixcXFwic3JjbGFuZ1xcXCIsXFxcInNyY3NldFxcXCIsXFxcInN0YXJ0XFxcIixcXFwic3RlcFxcXCIsXFxcInN1bW1hcnlcXFwiLFxcXCJzcGVsbGNoZWNrXFxcIixcXFwic3R5bGVcXFwiLFxcXCJ0YWJpbmRleFxcXCIsXFxcInRhcmdldFxcXCIsXFxcInRpdGxlXFxcIixcXFwidHlwZVxcXCIsXFxcInRyYW5zbGF0ZVxcXCIsXFxcInVzZW1hcFxcXCIsXFxcInZhbHVlXFxcIixcXFwidmFsaWduXFxcIixcXFwid2Via2l0YWxsb3dmdWxsc2NyZWVuXFxcIixcXFwid2lkdGhcXFwiLFxcXCJ3cmFwXFxcIl0saHRtbEFsbG93ZWRTdHlsZVByb3BzOltdLGh0bWxBbGxvd0NvbW1lbnRzOiEwLGh0bWxVbnRvdWNoZWQ6ITEsZnVsbFBhZ2U6ITF9KSxhLkZFLkhUTUw1TWFwPXtCOlxcXCJTVFJPTkdcXFwiLEk6XFxcIkVNXFxcIixTVFJJS0U6XFxcIlNcXFwifSxhLkZFLk1PRFVMRVMuY2xlYW49ZnVuY3Rpb24oYil7ZnVuY3Rpb24gYyhhKXtpZihhLm5vZGVUeXBlPT1Ob2RlLkVMRU1FTlRfTk9ERSYmYS5nZXRBdHRyaWJ1dGUoXFxcImNsYXNzXFxcIikmJmEuZ2V0QXR0cmlidXRlKFxcXCJjbGFzc1xcXCIpLmluZGV4T2YoXFxcImZyLW1hcmtlclxcXCIpPj0wKXJldHVybiExO3ZhciBkLGU9Yi5ub2RlLmNvbnRlbnRzKGEpLGY9W107Zm9yKGQ9MDtkPGUubGVuZ3RoO2QrKyllW2RdLm5vZGVUeXBlIT1Ob2RlLkVMRU1FTlRfTk9ERXx8Yi5ub2RlLmlzVm9pZChlW2RdKT9lW2RdLm5vZGVUeXBlPT1Ob2RlLlRFWFRfTk9ERSYmKGVbZF0udGV4dENvbnRlbnQ9ZVtkXS50ZXh0Q29udGVudC5yZXBsYWNlKC9cXFxcdTIwMGIvZyxcXFwiXFxcIikucmVwbGFjZSgvJi9nLFxcXCImYW1wO1xcXCIpKTplW2RdLnRleHRDb250ZW50LnJlcGxhY2UoL1xcXFx1MjAwYi9nLFxcXCJcXFwiKS5sZW5ndGghPWVbZF0udGV4dENvbnRlbnQubGVuZ3RoJiZjKGVbZF0pO2lmKGEubm9kZVR5cGU9PU5vZGUuRUxFTUVOVF9OT0RFJiYhYi5ub2RlLmlzVm9pZChhKSYmKGEubm9ybWFsaXplKCksZT1iLm5vZGUuY29udGVudHMoYSksZj1hLnF1ZXJ5U2VsZWN0b3JBbGwoXFxcIi5mci1tYXJrZXJcXFwiKSxlLmxlbmd0aC1mLmxlbmd0aD09PTApKXtmb3IoZD0wO2Q8ZS5sZW5ndGg7ZCsrKWlmKChlW2RdLmdldEF0dHJpYnV0ZShcXFwiY2xhc3NcXFwiKXx8XFxcIlxcXCIpLmluZGV4T2YoXFxcImZyLW1hcmtlclxcXCIpPDApcmV0dXJuITE7Zm9yKGQ9MDtkPGYubGVuZ3RoO2QrKylhLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGZbZF0uY2xvbmVOb2RlKCEwKSxhKTtyZXR1cm4gYS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGEpLCExfX1mdW5jdGlvbiBkKGEsYyl7aWYoYS5ub2RlVHlwZT09Tm9kZS5DT01NRU5UX05PREUpcmV0dXJuXFxcIjwhLS1cXFwiK2Eubm9kZVZhbHVlK1xcXCItLT5cXFwiO2lmKGEubm9kZVR5cGU9PU5vZGUuVEVYVF9OT0RFKXJldHVybiBjP2EudGV4dENvbnRlbnQucmVwbGFjZSgvXFxcXCYvZyxcXFwiJmFtcDtcXFwiKS5yZXBsYWNlKC88L2csXFxcIiZsdDtcXFwiKS5yZXBsYWNlKC8+L2csXFxcIiZndDtcXFwiKTphLnRleHRDb250ZW50LnJlcGxhY2UoL1xcXFwmL2csXFxcIiZhbXA7XFxcIikucmVwbGFjZSgvPC9nLFxcXCImbHQ7XFxcIikucmVwbGFjZSgvPi9nLFxcXCImZ3Q7XFxcIikucmVwbGFjZSgvXFxcXHUwMEEwL2csXFxcIiZuYnNwO1xcXCIpLnJlcGxhY2UoL1xcXFx1MDAwOS9nLFxcXCJcXFwiKTtpZihhLm5vZGVUeXBlIT1Ob2RlLkVMRU1FTlRfTk9ERSlyZXR1cm4gYS5vdXRlckhUTUw7aWYoYS5ub2RlVHlwZT09Tm9kZS5FTEVNRU5UX05PREUmJltcXFwiU1RZTEVcXFwiLFxcXCJTQ1JJUFRcXFwiLFxcXCJOT1NDUklQVFxcXCJdLmluZGV4T2YoYS50YWdOYW1lKT49MClyZXR1cm4gYS5vdXRlckhUTUw7aWYoYS5ub2RlVHlwZT09Tm9kZS5FTEVNRU5UX05PREUmJlxcXCJzdmdcXFwiPT1hLnRhZ05hbWUpe3ZhciBlPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXFxcImRpdlxcXCIpLGY9YS5jbG9uZU5vZGUoITApO3JldHVybiBlLmFwcGVuZENoaWxkKGYpLGUuaW5uZXJIVE1MfWlmKFxcXCJJRlJBTUVcXFwiPT1hLnRhZ05hbWUpcmV0dXJuIGEub3V0ZXJIVE1MO3ZhciBnPWEuY2hpbGROb2RlcztpZigwPT09Zy5sZW5ndGgpcmV0dXJuIGEub3V0ZXJIVE1MO2Zvcih2YXIgaD1cXFwiXFxcIixpPTA7aTxnLmxlbmd0aDtpKyspXFxcIlBSRVxcXCI9PWEudGFnTmFtZSYmKGM9ITApLGgrPWQoZ1tpXSxjKTtyZXR1cm4gYi5ub2RlLm9wZW5UYWdTdHJpbmcoYSkraCtiLm5vZGUuY2xvc2VUYWdTdHJpbmcoYSl9ZnVuY3Rpb24gZShhKXtyZXR1cm4gTD1bXSxhPWEucmVwbGFjZSgvPHNjcmlwdFxcXFxiW148XSooPzooPyE8XFxcXC9zY3JpcHQ+KTxbXjxdKikqPFxcXFwvc2NyaXB0Pi9naSxmdW5jdGlvbihhKXtyZXR1cm4gTC5wdXNoKGEpLFxcXCJbRlJPQUxBLkVESVRPUi5TQ1JJUFQgXFxcIisoTC5sZW5ndGgtMSkrXFxcIl1cXFwifSksYT1hLnJlcGxhY2UoLzxub3NjcmlwdFxcXFxiW148XSooPzooPyE8XFxcXC9ub3NjcmlwdD4pPFtePF0qKSo8XFxcXC9ub3NjcmlwdD4vZ2ksZnVuY3Rpb24oYSl7cmV0dXJuIEwucHVzaChhKSxcXFwiW0ZST0FMQS5FRElUT1IuTk9TQ1JJUFQgXFxcIisoTC5sZW5ndGgtMSkrXFxcIl1cXFwifSksYT1hLnJlcGxhY2UoLzxpbWcoKD86W1xcXFx3XFxcXFddKj8pKSBzcmM9XFxcIi9nLCc8aW1nJDEgZGF0YS1mci1zcmM9XFxcIicpfWZ1bmN0aW9uIGYoYSl7cmV0dXJuIGE9YS5yZXBsYWNlKC9cXFxcW0ZST0FMQVxcXFwuRURJVE9SXFxcXC5TQ1JJUFQgKFtcXFxcZF0qKVxcXFxdL2dpLGZ1bmN0aW9uKGEsYyl7cmV0dXJuIGIub3B0cy5odG1sUmVtb3ZlVGFncy5pbmRleE9mKFxcXCJzY3JpcHRcXFwiKT49MD9cXFwiXFxcIjpMW3BhcnNlSW50KGMsMTApXX0pLGE9YS5yZXBsYWNlKC9cXFxcW0ZST0FMQVxcXFwuRURJVE9SXFxcXC5OT1NDUklQVCAoW1xcXFxkXSopXFxcXF0vZ2ksZnVuY3Rpb24oYSxjKXtyZXR1cm4gYi5vcHRzLmh0bWxSZW1vdmVUYWdzLmluZGV4T2YoXFxcIm5vc2NyaXB0XFxcIik+PTA/XFxcIlxcXCI6TFtwYXJzZUludChjLDEwKV0ucmVwbGFjZSgvXFxcXCZsdDsvZyxcXFwiPFxcXCIpLnJlcGxhY2UoL1xcXFwmZ3Q7L2csXFxcIj5cXFwiKX0pLGE9YS5yZXBsYWNlKC88aW1nKCg/OltcXFxcd1xcXFxXXSo/KSkgZGF0YS1mci1zcmM9XFxcIi9nLCc8aW1nJDEgc3JjPVxcXCInKX1mdW5jdGlvbiBnKGEpe3ZhciBiPWEucmVwbGFjZSgvOzsvZ2ksXFxcIjtcXFwiKTtyZXR1cm4gYj1iLnJlcGxhY2UoL147L2dpLFxcXCJcXFwiKSxcXFwiO1xcXCIhPWIuY2hhckF0KGIubGVuZ3RoKSYmKGIrPVxcXCI7XFxcIiksYn1mdW5jdGlvbiBoKGEpe3ZhciBjO2ZvcihjIGluIGEpaWYoYS5oYXNPd25Qcm9wZXJ0eShjKSl7dmFyIGQ9bnVsbDtiLm9wdHMuaHRtbEFsbG93ZWRTdHlsZVByb3BzLmxlbmd0aCYmKGQ9YVtjXS5tYXRjaChLKSksXFxcInN0eWxlXFxcIj09YyYmZD9hW2NdPWcoZC5qb2luKFxcXCI7XFxcIikpOmMubWF0Y2goSil8fGRlbGV0ZSBhW2NdfWZvcih2YXIgZT1cXFwiXFxcIixmPU9iamVjdC5rZXlzKGEpLnNvcnQoKSxoPTA7aDxmLmxlbmd0aDtoKyspYz1mW2hdLGUrPWFbY10uaW5kZXhPZignXFxcIicpPDA/XFxcIiBcXFwiK2MrJz1cXFwiJythW2NdKydcXFwiJzpcXFwiIFxcXCIrYytcXFwiPSdcXFwiK2FbY10rXFxcIidcXFwiO3JldHVybiBlfWZ1bmN0aW9uIGooYSxjLGQpe2lmKGIub3B0cy5mdWxsUGFnZSl7dmFyIGU9Yi5odG1sLmV4dHJhY3REb2N0eXBlKGQpLGY9aChiLmh0bWwuZXh0cmFjdE5vZGVBdHRycyhkLFxcXCJodG1sXFxcIikpO2M9bnVsbD09Yz9iLmh0bWwuZXh0cmFjdE5vZGUoZCxcXFwiaGVhZFxcXCIpfHxcXFwiPHRpdGxlPjwvdGl0bGU+XFxcIjpjO3ZhciBnPWgoYi5odG1sLmV4dHJhY3ROb2RlQXR0cnMoZCxcXFwiaGVhZFxcXCIpKSxpPWgoYi5odG1sLmV4dHJhY3ROb2RlQXR0cnMoZCxcXFwiYm9keVxcXCIpKTtyZXR1cm4gZStcXFwiPGh0bWxcXFwiK2YrXFxcIj48aGVhZFxcXCIrZytcXFwiPlxcXCIrYytcXFwiPC9oZWFkPjxib2R5XFxcIitpK1xcXCI+XFxcIithK1xcXCI8L2JvZHk+PC9odG1sPlxcXCJ9cmV0dXJuIGF9ZnVuY3Rpb24gayhjLGUpe3ZhciBmLGc9YShcXFwiPGRpdj5cXFwiK2MrXFxcIjwvZGl2PlxcXCIpLGg9XFxcIlxcXCI7aWYoZyl7dmFyIGk9Yi5ub2RlLmNvbnRlbnRzKGcuZ2V0KDApKTtmb3IoZj0wO2Y8aS5sZW5ndGg7ZisrKWUoaVtmXSk7Zm9yKGk9Yi5ub2RlLmNvbnRlbnRzKGcuZ2V0KDApKSxmPTA7ZjxpLmxlbmd0aDtmKyspaCs9ZChpW2ZdKX1yZXR1cm4gaH1mdW5jdGlvbiBsKGEsYyxkKXthPWUoYSk7dmFyIGc9YSxoPW51bGw7Yi5vcHRzLmZ1bGxQYWdlJiYoZz1iLmh0bWwuZXh0cmFjdE5vZGUoYSxcXFwiYm9keVxcXCIpfHwoYS5pbmRleE9mKFxcXCI8Ym9keVxcXCIpPj0wP1xcXCJcXFwiOmEpLGQmJihoPWIuaHRtbC5leHRyYWN0Tm9kZShhLFxcXCJoZWFkXFxcIil8fFxcXCJcXFwiKSksZz1rKGcsYyksaCYmKGg9ayhoLGMpKTt2YXIgaT1qKGcsaCxhKTtyZXR1cm4gZihpKX1mdW5jdGlvbiBtKGEpe3JldHVybiBhLnJlcGxhY2UoL1xcXFx1MjAwYi9nLFxcXCJcXFwiKS5sZW5ndGg9PWEubGVuZ3RoP2E6Yi5jbGVhbi5leGVjKGEsYyl9ZnVuY3Rpb24gbigpe3ZhciBjPWIuZWwucXVlcnlTZWxlY3RvckFsbChPYmplY3Qua2V5cyhhLkZFLkhUTUw1TWFwKS5qb2luKFxcXCIsXFxcIikpO2lmKGMubGVuZ3RoKXt2YXIgZD0hMTtiLmVsLnF1ZXJ5U2VsZWN0b3IoXFxcIi5mci1tYXJrZXJcXFwiKXx8KGIuc2VsZWN0aW9uLnNhdmUoKSxkPSEwKTtmb3IodmFyIGU9MDtlPGMubGVuZ3RoO2UrKylcXFwiXFxcIj09PWIubm9kZS5hdHRyaWJ1dGVzKGNbZV0pJiZhKGNbZV0pLnJlcGxhY2VXaXRoKFxcXCI8XFxcIithLkZFLkhUTUw1TWFwW2NbZV0udGFnTmFtZV0rXFxcIj5cXFwiK2NbZV0uaW5uZXJIVE1MK1xcXCI8L1xcXCIrYS5GRS5IVE1MNU1hcFtjW2VdLnRhZ05hbWVdK1xcXCI+XFxcIik7ZCYmYi5zZWxlY3Rpb24ucmVzdG9yZSgpfX1mdW5jdGlvbiBvKGMpe2lmKFxcXCJTUEFOXFxcIj09Yy50YWdOYW1lJiYoYy5nZXRBdHRyaWJ1dGUoXFxcImNsYXNzXFxcIil8fFxcXCJcXFwiKS5pbmRleE9mKFxcXCJmci1tYXJrZXJcXFwiKT49MClyZXR1cm4hMTtpZihcXFwiUFJFXFxcIj09Yy50YWdOYW1lJiZxKGMpLGMubm9kZVR5cGU9PU5vZGUuRUxFTUVOVF9OT0RFJiYoYy5nZXRBdHRyaWJ1dGUoXFxcImRhdGEtZnItc3JjXFxcIikmJmMuc2V0QXR0cmlidXRlKFxcXCJkYXRhLWZyLXNyY1xcXCIsYi5oZWxwZXJzLnNhbml0aXplVVJMKGMuZ2V0QXR0cmlidXRlKFxcXCJkYXRhLWZyLXNyY1xcXCIpKSksYy5nZXRBdHRyaWJ1dGUoXFxcImhyZWZcXFwiKSYmYy5zZXRBdHRyaWJ1dGUoXFxcImhyZWZcXFwiLGIuaGVscGVycy5zYW5pdGl6ZVVSTChjLmdldEF0dHJpYnV0ZShcXFwiaHJlZlxcXCIpKSksW1xcXCJUQUJMRVxcXCIsXFxcIlRCT0RZXFxcIixcXFwiVEZPT1RcXFwiLFxcXCJUUlxcXCJdLmluZGV4T2YoYy50YWdOYW1lKT49MCYmKGMuaW5uZXJIVE1MPWMuaW5uZXJIVE1MLnRyaW0oKSkpLCFiLm9wdHMucGFzdGVBbGxvd0xvY2FsSW1hZ2VzJiZjLm5vZGVUeXBlPT1Ob2RlLkVMRU1FTlRfTk9ERSYmXFxcIklNR1xcXCI9PWMudGFnTmFtZSYmYy5nZXRBdHRyaWJ1dGUoXFxcImRhdGEtZnItc3JjXFxcIikmJjA9PT1jLmdldEF0dHJpYnV0ZShcXFwiZGF0YS1mci1zcmNcXFwiKS5pbmRleE9mKFxcXCJmaWxlOi8vXFxcIikpcmV0dXJuIGMucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChjKSwhMTtpZihjLm5vZGVUeXBlPT1Ob2RlLkVMRU1FTlRfTk9ERSYmYS5GRS5IVE1MNU1hcFtjLnRhZ05hbWVdJiZcXFwiXFxcIj09PWIubm9kZS5hdHRyaWJ1dGVzKGMpKXt2YXIgZD1hLkZFLkhUTUw1TWFwW2MudGFnTmFtZV0sZT1cXFwiPFxcXCIrZCtcXFwiPlxcXCIrYy5pbm5lckhUTUwrXFxcIjwvXFxcIitkK1xcXCI+XFxcIjtjLmluc2VydEFkamFjZW50SFRNTChcXFwiYmVmb3JlYmVnaW5cXFwiLGUpLGM9Yy5wcmV2aW91c1NpYmxpbmcsYy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGMubmV4dFNpYmxpbmcpfWlmKGIub3B0cy5odG1sQWxsb3dDb21tZW50c3x8Yy5ub2RlVHlwZSE9Tm9kZS5DT01NRU5UX05PREUpaWYoYy50YWdOYW1lJiZjLnRhZ05hbWUubWF0Y2goSSkpYy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGMpO2Vsc2UgaWYoYy50YWdOYW1lJiYhYy50YWdOYW1lLm1hdGNoKEgpKVxcXCJzdmdcXFwiPT09Yy50YWdOYW1lP2MucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChjKTpiLmJyb3dzZXIuc2FmYXJpJiZcXFwicGF0aFxcXCI9PWMudGFnTmFtZSYmYy5wYXJlbnROb2RlJiZcXFwic3ZnXFxcIj09Yy5wYXJlbnROb2RlLnRhZ05hbWV8fChjLm91dGVySFRNTD1jLmlubmVySFRNTCk7ZWxzZXt2YXIgZj1jLmF0dHJpYnV0ZXM7aWYoZilmb3IodmFyIGg9Zi5sZW5ndGgtMTtoPj0wO2gtLSl7dmFyIGk9ZltoXSxqPW51bGw7Yi5vcHRzLmh0bWxBbGxvd2VkU3R5bGVQcm9wcy5sZW5ndGgmJihqPWkubm9kZVZhbHVlLm1hdGNoKEspKSxcXFwic3R5bGVcXFwiPT1pLm5vZGVOYW1lJiZqP2kubm9kZVZhbHVlPWcoai5qb2luKFxcXCI7XFxcIikpOmkubm9kZU5hbWUubWF0Y2goSil8fGMucmVtb3ZlQXR0cmlidXRlKGkubm9kZU5hbWUpfX1lbHNlIDAhPT1jLmRhdGEuaW5kZXhPZihcXFwiW0ZST0FMQS5FRElUT1JcXFwiKSYmYy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGMpfWZ1bmN0aW9uIHAoYSl7Zm9yKHZhciBjPWIubm9kZS5jb250ZW50cyhhKSxkPTA7ZDxjLmxlbmd0aDtkKyspY1tkXS5ub2RlVHlwZSE9Tm9kZS5URVhUX05PREUmJnAoY1tkXSk7byhhKX1mdW5jdGlvbiBxKGEpe3ZhciBiPWEuaW5uZXJIVE1MO2IuaW5kZXhPZihcXFwiXFxcXG5cXFwiKT49MCYmKGEuaW5uZXJIVE1MPWIucmVwbGFjZSgvXFxcXG4vZyxcXFwiPGJyPlxcXCIpKX1mdW5jdGlvbiByKGMsZCxlLGYpe1xcXCJ1bmRlZmluZWRcXFwiPT10eXBlb2YgZCYmKGQ9W10pLFxcXCJ1bmRlZmluZWRcXFwiPT10eXBlb2YgZSYmKGU9W10pLFxcXCJ1bmRlZmluZWRcXFwiPT10eXBlb2YgZiYmKGY9ITEpLGM9Yy5yZXBsYWNlKC88YnI+ICovZyxcXFwiPGJyPlxcXCIpO3ZhciBnLGg9YS5tZXJnZShbXSxiLm9wdHMuaHRtbEFsbG93ZWRUYWdzKTtmb3IoZz0wO2c8ZC5sZW5ndGg7ZysrKWguaW5kZXhPZihkW2ddKT49MCYmaC5zcGxpY2UoaC5pbmRleE9mKGRbZ10pLDEpO3ZhciBpPWEubWVyZ2UoW10sYi5vcHRzLmh0bWxBbGxvd2VkQXR0cnMpO2ZvcihnPTA7ZzxlLmxlbmd0aDtnKyspaS5pbmRleE9mKGVbZ10pPj0wJiZpLnNwbGljZShpLmluZGV4T2YoZVtnXSksMSk7cmV0dXJuIGkucHVzaChcXFwiZGF0YS1mci0uKlxcXCIpLGkucHVzaChcXFwiZnItLipcXFwiKSxIPW5ldyBSZWdFeHAoXFxcIl5cXFwiK2guam9pbihcXFwiJHxeXFxcIikrXFxcIiRcXFwiLFxcXCJnaVxcXCIpLEo9bmV3IFJlZ0V4cChcXFwiXlxcXCIraS5qb2luKFxcXCIkfF5cXFwiKStcXFwiJFxcXCIsXFxcImdpXFxcIiksST1uZXcgUmVnRXhwKFxcXCJeXFxcIitiLm9wdHMuaHRtbFJlbW92ZVRhZ3Muam9pbihcXFwiJHxeXFxcIikrXFxcIiRcXFwiLFxcXCJnaVxcXCIpLEs9Yi5vcHRzLmh0bWxBbGxvd2VkU3R5bGVQcm9wcy5sZW5ndGg/bmV3IFJlZ0V4cChcXFwiKChefDt8XFxcXFxcXFxzKVxcXCIrYi5vcHRzLmh0bWxBbGxvd2VkU3R5bGVQcm9wcy5qb2luKFxcXCI6Lis/KD89O3wkKSl8KChefDt8XFxcXFxcXFxzKVxcXCIpK1xcXCI6Lis/KD89KDt8Jyl8JCkpXFxcIixcXFwiZ2lcXFwiKTpudWxsLGM9bChjLHAsITApfWZ1bmN0aW9uIHMoKXtmb3IodmFyIGM9Yi5lbC5xdWVyeVNlbGVjdG9yQWxsKFxcXCJibG9ja3F1b3RlICsgYmxvY2txdW90ZVxcXCIpLGQ9MDtkPGMubGVuZ3RoO2QrKyl7dmFyIGU9Y1tkXTtiLm5vZGUuYXR0cmlidXRlcyhlKT09Yi5ub2RlLmF0dHJpYnV0ZXMoZS5wcmV2aW91c1NpYmxpbmcpJiYoYShlKS5wcmV2KCkuYXBwZW5kKGEoZSkuaHRtbCgpKSxhKGUpLnJlbW92ZSgpKX19ZnVuY3Rpb24gdCgpe2Zvcih2YXIgYT1iLmVsLnF1ZXJ5U2VsZWN0b3JBbGwoXFxcInRyXFxcIiksYz0wO2M8YS5sZW5ndGg7YysrKXtmb3IodmFyIGQ9YVtjXS5jaGlsZHJlbixlPSEwLGY9MDtmPGQubGVuZ3RoO2YrKylpZihcXFwiVEhcXFwiIT1kW2ZdLnRhZ05hbWUpe2U9ITE7YnJlYWt9aWYoZSE9PSExJiYwIT09ZC5sZW5ndGgpe2Zvcih2YXIgZz1hW2NdO2cmJlxcXCJUQUJMRVxcXCIhPWcudGFnTmFtZSYmXFxcIlRIRUFEXFxcIiE9Zy50YWdOYW1lOylnPWcucGFyZW50Tm9kZTt2YXIgaD1nO1xcXCJUSEVBRFxcXCIhPWgudGFnTmFtZSYmKGg9Yi5kb2MuY3JlYXRlRWxlbWVudChcXFwiVEhFQURcXFwiKSxnLmluc2VydEJlZm9yZShoLGcuZmlyc3RDaGlsZCkpLGguYXBwZW5kQ2hpbGQoYVtjXSl9fX1mdW5jdGlvbiB1KCl7dmFyIGM9Yi5odG1sLmRlZmF1bHRUYWcoKTtpZihjKWZvcih2YXIgZD1iLmVsLnF1ZXJ5U2VsZWN0b3JBbGwoXFxcInRkID4gXFxcIitjK1xcXCIsIHRoID4gXFxcIitjKSxlPTA7ZTxkLmxlbmd0aDtlKyspXFxcIlxcXCI9PT1iLm5vZGUuYXR0cmlidXRlcyhkW2VdKSYmYShkW2VdKS5yZXBsYWNlV2l0aChkW2VdLmlubmVySFRNTCtcXFwiPGJyPlxcXCIpfWZ1bmN0aW9uIHYoKXt0KCksdSgpfWZ1bmN0aW9uIHcoKXt2YXIgYT1bXSxjPWZ1bmN0aW9uKGEpe3JldHVybiFiLm5vZGUuaXNMaXN0KGEucGFyZW50Tm9kZSl9O2Rve2lmKGEubGVuZ3RoKXt2YXIgZD1hWzBdLGU9Yi5kb2MuY3JlYXRlRWxlbWVudChcXFwidWxcXFwiKTtkLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGUsZCk7ZG97dmFyIGY9ZDtkPWQubmV4dFNpYmxpbmcsZS5hcHBlbmRDaGlsZChmKX13aGlsZShkJiZcXFwiTElcXFwiPT1kLnRhZ05hbWUpfWE9W107Zm9yKHZhciBnPWIuZWwucXVlcnlTZWxlY3RvckFsbChcXFwibGlcXFwiKSxoPTA7aDxnLmxlbmd0aDtoKyspYyhnW2hdKSYmYS5wdXNoKGdbaF0pfXdoaWxlKGEubGVuZ3RoPjApfWZ1bmN0aW9uIHgoKXtmb3IodmFyIGE9Yi5lbC5xdWVyeVNlbGVjdG9yQWxsKFxcXCJvbCArIG9sLCB1bCArIHVsXFxcIiksYz0wO2M8YS5sZW5ndGg7YysrKXt2YXIgZD1hW2NdO2lmKGIubm9kZS5pc0xpc3QoZC5wcmV2aW91c1NpYmxpbmcpJiZiLm5vZGUub3BlblRhZ1N0cmluZyhkKT09Yi5ub2RlLm9wZW5UYWdTdHJpbmcoZC5wcmV2aW91c1NpYmxpbmcpKXtmb3IodmFyIGU9Yi5ub2RlLmNvbnRlbnRzKGQpLGY9MDtmPGUubGVuZ3RoO2YrKylkLnByZXZpb3VzU2libGluZy5hcHBlbmRDaGlsZChlW2ZdKTtkLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZCl9fX1mdW5jdGlvbiB5KCl7dmFyIGEsYyxkPWZ1bmN0aW9uKGEpe2EucXVlcnlTZWxlY3RvcihcXFwiTElcXFwiKXx8KGM9ITAsYS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGEpKX07ZG97Yz0hMTt2YXIgZT1iLmVsLnF1ZXJ5U2VsZWN0b3JBbGwoXFxcImxpOmVtcHR5XFxcIik7Zm9yKGE9MDthPGUubGVuZ3RoO2ErKyllW2FdLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZVthXSk7dmFyIGY9Yi5lbC5xdWVyeVNlbGVjdG9yQWxsKFxcXCJ1bCwgb2xcXFwiKTtmb3IoYT0wO2E8Zi5sZW5ndGg7YSsrKWQoZlthXSl9d2hpbGUoYz09PSEwKX1mdW5jdGlvbiB6KCl7Zm9yKHZhciBjPWIuZWwucXVlcnlTZWxlY3RvckFsbChcXFwidWwgPiB1bCwgb2wgPiBvbCwgdWwgPiBvbCwgb2wgPiB1bFxcXCIpLGQ9MDtkPGMubGVuZ3RoO2QrKyl7dmFyIGU9Y1tkXSxmPWUucHJldmlvdXNTaWJsaW5nO2YmJihcXFwiTElcXFwiPT1mLnRhZ05hbWU/Zi5hcHBlbmRDaGlsZChlKTphKGUpLndyYXAoXFxcIjxsaT48L2xpPlxcXCIpKX19ZnVuY3Rpb24gQSgpe2Zvcih2YXIgYz1iLmVsLnF1ZXJ5U2VsZWN0b3JBbGwoXFxcImxpID4gdWwsIGxpID4gb2xcXFwiKSxkPTA7ZDxjLmxlbmd0aDtkKyspe3ZhciBlPWNbZF07aWYoZS5uZXh0U2libGluZyl7dmFyIGY9ZS5uZXh0U2libGluZyxnPWEoXFxcIjxsaT5cXFwiKTthKGUucGFyZW50Tm9kZSkuYWZ0ZXIoZyk7ZG97dmFyIGg9ZjtmPWYubmV4dFNpYmxpbmcsZy5hcHBlbmQoaCl9d2hpbGUoZil9fX1mdW5jdGlvbiBCKCl7Zm9yKHZhciBjPWIuZWwucXVlcnlTZWxlY3RvckFsbChcXFwibGkgPiB1bCwgbGkgPiBvbFxcXCIpLGQ9MDtkPGMubGVuZ3RoO2QrKyl7dmFyIGU9Y1tkXTtpZihiLm5vZGUuaXNGaXJzdFNpYmxpbmcoZSkpYShlKS5iZWZvcmUoXFxcIjxici8+XFxcIik7ZWxzZSBpZihlLnByZXZpb3VzU2libGluZyYmXFxcIkJSXFxcIj09ZS5wcmV2aW91c1NpYmxpbmcudGFnTmFtZSl7Zm9yKHZhciBmPWUucHJldmlvdXNTaWJsaW5nLnByZXZpb3VzU2libGluZztmJiZiLm5vZGUuaGFzQ2xhc3MoZixcXFwiZnItbWFya2VyXFxcIik7KWY9Zi5wcmV2aW91c1NpYmxpbmc7ZiYmXFxcIkJSXFxcIiE9Zi50YWdOYW1lJiZhKGUucHJldmlvdXNTaWJsaW5nKS5yZW1vdmUoKX19fWZ1bmN0aW9uIEMoKXtmb3IodmFyIGM9Yi5lbC5xdWVyeVNlbGVjdG9yQWxsKFxcXCJsaTplbXB0eVxcXCIpLGQ9MDtkPGMubGVuZ3RoO2QrKylhKGNbZF0pLnJlbW92ZSgpfWZ1bmN0aW9uIEQoKXtmb3IodmFyIGM9Yi5lbC5xdWVyeVNlbGVjdG9yQWxsKFxcXCJ1bCwgb2xcXFwiKSxkPTA7ZDxjLmxlbmd0aDtkKyspZm9yKHZhciBlPWIubm9kZS5jb250ZW50cyhjW2RdKSxmPW51bGwsZz1lLmxlbmd0aC0xO2c+PTA7Zy0tKVxcXCJMSVxcXCIhPWVbZ10udGFnTmFtZT8oZnx8KGY9YShcXFwiPGxpPlxcXCIpLGYuaW5zZXJ0QmVmb3JlKGVbZ10pKSxmLnByZXBlbmQoZVtnXSkpOmY9bnVsbH1mdW5jdGlvbiBFKCl7Zm9yKGRlZmF1bHRfdGFnX2Vscz1iLmVsLnF1ZXJ5U2VsZWN0b3JBbGwoYi5odG1sLmRlZmF1bHRUYWcoKSksaT1kZWZhdWx0X3RhZ19lbHMubGVuZ3RoLTE7aT49MDtpLS0pZWw9ZGVmYXVsdF90YWdfZWxzW2ldLGVsLnBhcmVudE5vZGUmJlxcXCJMSVxcXCI9PWVsLnBhcmVudE5vZGUudGFnTmFtZSYmKGVsLm5leHRFbGVtZW50U2libGluZyYmZWwubmV4dEVsZW1lbnRTaWJsaW5nLnRhZ05hbWUudG9Mb3dlckNhc2UoKT09Yi5odG1sLmRlZmF1bHRUYWcoKSYmYShcXFwiPGJyPlxcXCIpLmluc2VydEJlZm9yZShlbC5uZXh0RWxlbWVudFNpYmxpbmcpLGVsLnByZXZpb3VzRWxlbWVudFNpYmxpbmcmJmVsLnByZXZpb3VzRWxlbWVudFNpYmxpbmcudGFnTmFtZS50b0xvd2VyQ2FzZSgpPT1iLmh0bWwuZGVmYXVsdFRhZygpJiZhKFxcXCI8YnI+XFxcIikuaW5zZXJ0QWZ0ZXIoZWwucHJldmlvdXNFbGVtZW50U2libGluZyksZWwub3V0ZXJIVE1MPWVsLmlubmVySFRNTCl9ZnVuY3Rpb24gRigpe3coKSx4KCkseSgpLHooKSxBKCksQigpLEQoKSxDKCksRSgpfWZ1bmN0aW9uIEcoKXtiLm9wdHMuZnVsbFBhZ2UmJmEubWVyZ2UoYi5vcHRzLmh0bWxBbGxvd2VkVGFncyxbXFxcImhlYWRcXFwiLFxcXCJ0aXRsZVxcXCIsXFxcInN0eWxlXFxcIixcXFwibGlua1xcXCIsXFxcImJhc2VcXFwiLFxcXCJib2R5XFxcIixcXFwiaHRtbFxcXCIsXFxcIm1ldGFcXFwiXSl9dmFyIEgsSSxKLEssTD1bXTtyZXR1cm57X2luaXQ6RyxodG1sOnIsdG9IVE1MNTpuLHRhYmxlczp2LGxpc3RzOkYscXVvdGVzOnMsaW52aXNpYmxlU3BhY2VzOm0sZXhlYzpsfX0sYS5GRS5NT0RVTEVTLnNwYWNlcz1mdW5jdGlvbihiKXtmdW5jdGlvbiBjKGMsZCl7dmFyIGU9Yy5wcmV2aW91c1NpYmxpbmcsZj1jLm5leHRTaWJsaW5nLGc9Yy50ZXh0Q29udGVudCxoPWMucGFyZW50Tm9kZTtpZihcXFwiUFJFXFxcIiE9aC50YWdOYW1lKXtkJiYoZz1nLnJlcGxhY2UoL1tcXFxcZlxcXFxuXFxcXHJcXFxcdFxcXFx2IF17Mix9L2csXFxcIiBcXFwiKSxmJiZcXFwiQlJcXFwiIT09Zi50YWdOYW1lJiYhYi5ub2RlLmlzQmxvY2soZil8fCFiLm5vZGUuaXNCbG9jayhoKXx8KGc9Zy5yZXBsYWNlKC9bXFxcXGZcXFxcblxcXFxyXFxcXHRcXFxcdiBdezEsfSQvZyxcXFwiXFxcIikpLGUmJlxcXCJCUlxcXCIhPT1lLnRhZ05hbWUmJiFiLm5vZGUuaXNCbG9jayhlKXx8IWIubm9kZS5pc0Jsb2NrKGgpfHwoZz1nLnJlcGxhY2UoL15bXFxcXGZcXFxcblxcXFxyXFxcXHRcXFxcdiBdezEsfS9nLFxcXCJcXFwiKSksXFxcIiBcXFwiPT09ZyYmKGUmJmUubm9kZVR5cGUhPU5vZGUuVEVYVF9OT0RFfHxmJiZmLm5vZGVUeXBlIT1Ob2RlLlRFWFRfTk9ERSkmJihnPVxcXCJcXFwiKSksZz1nLnJlcGxhY2UobmV3IFJlZ0V4cChhLkZFLlVOSUNPREVfTkJTUCxcXFwiZ1xcXCIpLFxcXCIgXFxcIik7Zm9yKHZhciBpPVxcXCJcXFwiLGo9MDtqPGcubGVuZ3RoO2orKylpKz0zMiE9Zy5jaGFyQ29kZUF0KGopfHwwIT09aiYmMzIhPWkuY2hhckNvZGVBdChqLTEpP2dbal06YS5GRS5VTklDT0RFX05CU1A7KCFmfHxiLm5vZGUuaXNCbG9jayhmKXx8Zi5ub2RlVHlwZT09Tm9kZS5FTEVNRU5UX05PREUmJmIud2luLmdldENvbXB1dGVkU3R5bGUoZikmJlxcXCJibG9ja1xcXCI9PWIud2luLmdldENvbXB1dGVkU3R5bGUoZikuZGlzcGxheSkmJihpPWkucmVwbGFjZSgvICQvLGEuRkUuVU5JQ09ERV9OQlNQKSksIWV8fGIubm9kZS5pc1ZvaWQoZSl8fGIubm9kZS5pc0Jsb2NrKGUpfHwoaT1pLnJlcGxhY2UoL15cXFxcdTAwQTAoW14gJF0pLyxcXFwiICQxXFxcIiksMSE9PWkubGVuZ3RofHwxNjAhPT1pLmNoYXJDb2RlQXQoMCl8fCFmfHxiLm5vZGUuaXNWb2lkKGYpfHxiLm5vZGUuaXNCbG9jayhmKXx8KGk9XFxcIiBcXFwiKSksaT1pLnJlcGxhY2UoLyhbXiBcXFxcdTAwQTBdKVxcXFx1MDBBMChbXiBcXFxcdTAwQTBdKS9nLFxcXCIkMSAkMlxcXCIpLGMudGV4dENvbnRlbnQhPWkmJihjLnRleHRDb250ZW50PWkpfX1mdW5jdGlvbiBkKGEsZCl7aWYoXFxcInVuZGVmaW5lZFxcXCIhPXR5cGVvZiBhJiZhfHwoYT1iLmVsKSxcXFwidW5kZWZpbmVkXFxcIj09dHlwZW9mIGQmJihkPSExKSxiLm9wdHMuaHRtbFVudG91Y2hlZClyZXR1cm4hMTtpZighYS5nZXRBdHRyaWJ1dGV8fFxcXCJmYWxzZVxcXCIhPWEuZ2V0QXR0cmlidXRlKFxcXCJjb250ZW50ZWRpdGFibGVcXFwiKSlpZihhLm5vZGVUeXBlPT1Ob2RlLlRFWFRfTk9ERSljKGEsZCk7ZWxzZSBpZihhLm5vZGVUeXBlPT1Ob2RlLkVMRU1FTlRfTk9ERSlmb3IodmFyIGU9Yi5kb2MuY3JlYXRlVHJlZVdhbGtlcihhLE5vZGVGaWx0ZXIuU0hPV19URVhULGIubm9kZS5maWx0ZXIoZnVuY3Rpb24oYSl7Zm9yKHZhciBjPWEucGFyZW50Tm9kZTtjJiZjIT09Yi5lbDspe2lmKFxcXCJQUkVcXFwiPT09Yy50YWdOYW1lKXJldHVybiExO2M9Yy5wYXJlbnROb2RlfXJldHVybiBudWxsIT1hLnRleHRDb250ZW50Lm1hdGNoKC8oWyBcXFxcdTAwQTBcXFxcZlxcXFxuXFxcXHJcXFxcdFxcXFx2XXsyLH0pfCheWyBcXFxcdTAwQTBcXFxcZlxcXFxuXFxcXHJcXFxcdFxcXFx2XXsxLH0pfChbIFxcXFx1MDBBMFxcXFxmXFxcXG5cXFxcclxcXFx0XFxcXHZdezEsfSQpL2cpJiYhYi5ub2RlLmhhc0NsYXNzKGEucGFyZW50Tm9kZSxcXFwiZnItbWFya2VyXFxcIil9KSwhMSk7ZS5uZXh0Tm9kZSgpOyljKGUuY3VycmVudE5vZGUsZCl9ZnVuY3Rpb24gZSgpe2Zvcih2YXIgYT1bXSxjPWIuZWwucXVlcnlTZWxlY3RvckFsbChcXFwiLmZyLW1hcmtlclxcXCIpLGU9MDtlPGMubGVuZ3RoO2UrKyl7dmFyIGY9bnVsbCxnPWIubm9kZS5ibG9ja1BhcmVudChjW2VdKTtmPWc/ZzpjW2VdO2Zvcih2YXIgaD1mLm5leHRTaWJsaW5nLGk9Zi5wcmV2aW91c1NpYmxpbmc7aCYmXFxcIkJSXFxcIj09aC50YWdOYW1lOyloPWgubmV4dFNpYmxpbmc7Zm9yKDtpJiZcXFwiQlJcXFwiPT1pLnRhZ05hbWU7KWk9aS5wcmV2aW91c1NpYmxpbmc7ZiYmYS5pbmRleE9mKGYpPDAmJmEucHVzaChmKSxpJiZhLmluZGV4T2YoaSk8MCYmYS5wdXNoKGkpLGgmJmEuaW5kZXhPZihoKTwwJiZhLnB1c2goaCl9Zm9yKHZhciBqPTA7ajxhLmxlbmd0aDtqKyspZChhW2pdKX1yZXR1cm57bm9ybWFsaXplOmQsbm9ybWFsaXplQXJvdW5kQ3Vyc29yOmV9fSxhLkZFLlVOSUNPREVfTkJTUD1TdHJpbmcuZnJvbUNoYXJDb2RlKDE2MCksYS5GRS5WT0lEX0VMRU1FTlRTPVtcXFwiYXJlYVxcXCIsXFxcImJhc2VcXFwiLFxcXCJiclxcXCIsXFxcImNvbFxcXCIsXFxcImVtYmVkXFxcIixcXFwiaHJcXFwiLFxcXCJpbWdcXFwiLFxcXCJpbnB1dFxcXCIsXFxcImtleWdlblxcXCIsXFxcImxpbmtcXFwiLFxcXCJtZW51aXRlbVxcXCIsXFxcIm1ldGFcXFwiLFxcXCJwYXJhbVxcXCIsXFxcInNvdXJjZVxcXCIsXFxcInRyYWNrXFxcIixcXFwid2JyXFxcIl0sYS5GRS5CTE9DS19UQUdTPVtcXFwiYWRkcmVzc1xcXCIsXFxcImFydGljbGVcXFwiLFxcXCJhc2lkZVxcXCIsXFxcImF1ZGlvXFxcIixcXFwiYmxvY2txdW90ZVxcXCIsXFxcImNhbnZhc1xcXCIsXFxcImRkXFxcIixcXFwiZGl2XFxcIixcXFwiZGxcXFwiLFxcXCJkdFxcXCIsXFxcImZpZWxkc2V0XFxcIixcXFwiZmlnY2FwdGlvblxcXCIsXFxcImZpZ3VyZVxcXCIsXFxcImZvb3RlclxcXCIsXFxcImZvcm1cXFwiLFxcXCJoMVxcXCIsXFxcImgyXFxcIixcXFwiaDNcXFwiLFxcXCJoNFxcXCIsXFxcImg1XFxcIixcXFwiaDZcXFwiLFxcXCJoZWFkZXJcXFwiLFxcXCJoZ3JvdXBcXFwiLFxcXCJoclxcXCIsXFxcImxpXFxcIixcXFwibWFpblxcXCIsXFxcIm5hdlxcXCIsXFxcIm5vc2NyaXB0XFxcIixcXFwib2xcXFwiLFxcXCJvdXRwdXRcXFwiLFxcXCJwXFxcIixcXFwicHJlXFxcIixcXFwic2VjdGlvblxcXCIsXFxcInRhYmxlXFxcIixcXFwidGJvZHlcXFwiLFxcXCJ0ZFxcXCIsXFxcInRmb290XFxcIixcXFwidGhcXFwiLFxcXCJ0aGVhZFxcXCIsXFxcInRyXFxcIixcXFwidWxcXFwiLFxcXCJ2aWRlb1xcXCJdLGEuZXh0ZW5kKGEuRkUuREVGQVVMVFMse2h0bWxBbGxvd2VkRW1wdHlUYWdzOltcXFwidGV4dGFyZWFcXFwiLFxcXCJhXFxcIixcXFwiaWZyYW1lXFxcIixcXFwib2JqZWN0XFxcIixcXFwidmlkZW9cXFwiLFxcXCJzdHlsZVxcXCIsXFxcInNjcmlwdFxcXCIsXFxcIi5mYVxcXCIsXFxcIi5mci1lbW90aWNvblxcXCJdLGh0bWxEb05vdFdyYXBUYWdzOltcXFwic2NyaXB0XFxcIixcXFwic3R5bGVcXFwiXSxodG1sU2ltcGxlQW1wZXJzYW5kOiExLGh0bWxJZ25vcmVDU1NQcm9wZXJ0aWVzOltdfSksYS5GRS5NT0RVTEVTLmh0bWw9ZnVuY3Rpb24oYil7ZnVuY3Rpb24gYygpe3JldHVybiBiLm9wdHMuZW50ZXI9PWEuRkUuRU5URVJfUD9cXFwicFxcXCI6Yi5vcHRzLmVudGVyPT1hLkZFLkVOVEVSX0RJVj9cXFwiZGl2XFxcIjpiLm9wdHMuZW50ZXI9PWEuRkUuRU5URVJfQlI/bnVsbDp2b2lkIDB9ZnVuY3Rpb24gZChjKXt2YXIgZCxlPVtdLGc9W107aWYoYyl7dmFyIGg9Yi5lbC5xdWVyeVNlbGVjdG9yQWxsKFxcXCIuZnItbWFya2VyXFxcIik7Zm9yKGQ9MDtkPGgubGVuZ3RoO2QrKyl7dmFyIGk9Yi5ub2RlLmJsb2NrUGFyZW50KGhbZF0pfHxoW2RdO2lmKGkpe3ZhciBqPWkubmV4dFNpYmxpbmcsaz1pLnByZXZpb3VzU2libGluZztpJiZnLmluZGV4T2YoaSk8MCYmYi5ub2RlLmlzQmxvY2soaSkmJmcucHVzaChpKSxrJiZiLm5vZGUuaXNCbG9jayhrKSYmZy5pbmRleE9mKGspPDAmJmcucHVzaChrKSxqJiZiLm5vZGUuaXNCbG9jayhqKSYmZy5pbmRleE9mKGopPDAmJmcucHVzaChqKX19fWVsc2UgZz1iLmVsLnF1ZXJ5U2VsZWN0b3JBbGwoZigpKTt2YXIgbD1mKCk7Zm9yKGwrPVxcXCIsXFxcIithLkZFLlZPSURfRUxFTUVOVFMuam9pbihcXFwiLFxcXCIpLGwrPVxcXCIsXFxcIitiLm9wdHMuaHRtbEFsbG93ZWRFbXB0eVRhZ3Muam9pbihcXFwiOm5vdCguZnItbWFya2VyKSxcXFwiKStcXFwiOm5vdCguZnItbWFya2VyKVxcXCIsZD1nLmxlbmd0aC0xO2Q+PTA7ZC0tKWlmKCEoZ1tkXS50ZXh0Q29udGVudCYmZ1tkXS50ZXh0Q29udGVudC5yZXBsYWNlKC9cXFxcdTIwMEJ8XFxcXG4vZyxcXFwiXFxcIikubGVuZ3RoPjB8fGdbZF0ucXVlcnlTZWxlY3RvckFsbChsKS5sZW5ndGg+MCkpe2Zvcih2YXIgbT1iLm5vZGUuY29udGVudHMoZ1tkXSksbj0hMSxvPTA7bzxtLmxlbmd0aDtvKyspaWYobVtvXS5ub2RlVHlwZSE9Tm9kZS5DT01NRU5UX05PREUmJm1bb10udGV4dENvbnRlbnQmJm1bb10udGV4dENvbnRlbnQucmVwbGFjZSgvXFxcXHUyMDBCfFxcXFxuL2csXFxcIlxcXCIpLmxlbmd0aD4wKXtuPSEwO2JyZWFrfW58fGUucHVzaChnW2RdKX1yZXR1cm4gZX1mdW5jdGlvbiBlKCl7cmV0dXJuIGEuRkUuQkxPQ0tfVEFHUy5qb2luKFxcXCI6ZW1wdHksIFxcXCIpK1xcXCI6ZW1wdHlcXFwifWZ1bmN0aW9uIGYoKXtyZXR1cm4gYS5GRS5CTE9DS19UQUdTLmpvaW4oXFxcIiwgXFxcIil9ZnVuY3Rpb24gZyhjKXt2YXIgZD1hLm1lcmdlKFtdLGEuRkUuVk9JRF9FTEVNRU5UUyk7ZD1hLm1lcmdlKGQsYi5vcHRzLmh0bWxBbGxvd2VkRW1wdHlUYWdzKSxcXFwidW5kZWZpbmVkXFxcIj09dHlwZW9mIGMmJihkPWEubWVyZ2UoZCxhLkZFLkJMT0NLX1RBR1MpKTt2YXIgZSxmO2U9Yi5lbC5xdWVyeVNlbGVjdG9yQWxsKFxcXCIqOmVtcHR5Om5vdChcXFwiK2Quam9pbihcXFwiKTpub3QoXFxcIikrXFxcIik6bm90KC5mci1tYXJrZXIpXFxcIik7ZG97Zj0hMTtmb3IodmFyIGc9MDtnPGUubGVuZ3RoO2crKykwIT09ZVtnXS5hdHRyaWJ1dGVzLmxlbmd0aCYmXFxcInVuZGVmaW5lZFxcXCI9PXR5cGVvZiBlW2ddLmdldEF0dHJpYnV0ZShcXFwiaHJlZlxcXCIpfHwoZVtnXS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGVbZ10pLGY9ITApO2U9Yi5lbC5xdWVyeVNlbGVjdG9yQWxsKFxcXCIqOmVtcHR5Om5vdChcXFwiK2Quam9pbihcXFwiKTpub3QoXFxcIikrXFxcIik6bm90KC5mci1tYXJrZXIpXFxcIil9d2hpbGUoZS5sZW5ndGgmJmYpfWZ1bmN0aW9uIGgoYSxkKXt2YXIgZT1jKCk7aWYoZCYmKGU9XFxcImRpdlxcXCIpLGUpe2Zvcih2YXIgZj1iLmRvYy5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCksZz1udWxsLGg9ITEsaT1hLmZpcnN0Q2hpbGQ7aTspe3ZhciBqPWkubmV4dFNpYmxpbmc7aWYoaS5ub2RlVHlwZT09Tm9kZS5FTEVNRU5UX05PREUmJihiLm5vZGUuaXNCbG9jayhpKXx8Yi5vcHRzLmh0bWxEb05vdFdyYXBUYWdzLmluZGV4T2YoaS50YWdOYW1lLnRvTG93ZXJDYXNlKCkpPj0wJiYhYi5ub2RlLmhhc0NsYXNzKGksXFxcImZyLW1hcmtlclxcXCIpKSlnPW51bGwsZi5hcHBlbmRDaGlsZChpKTtlbHNlIGlmKGkubm9kZVR5cGUhPU5vZGUuRUxFTUVOVF9OT0RFJiZpLm5vZGVUeXBlIT1Ob2RlLlRFWFRfTk9ERSlnPW51bGwsZi5hcHBlbmRDaGlsZChpKTtlbHNlIGlmKFxcXCJCUlxcXCI9PWkudGFnTmFtZSludWxsPT1nPyhnPWIuZG9jLmNyZWF0ZUVsZW1lbnQoZSksZCYmZy5zZXRBdHRyaWJ1dGUoXFxcImRhdGEtZW1wdHlcXFwiLCEwKSxnLmFwcGVuZENoaWxkKGkpLGYuYXBwZW5kQ2hpbGQoZykpOmg9PT0hMSYmKGcuYXBwZW5kQ2hpbGQoYi5kb2MuY3JlYXRlRWxlbWVudChcXFwiYnJcXFwiKSksZy5zZXRBdHRyaWJ1dGUoXFxcImRhdGEtZW1wdHlcXFwiLCEwKSksZz1udWxsO2Vsc2V7dmFyIGs9aS50ZXh0Q29udGVudDtpLm5vZGVUeXBlPT1Ob2RlLlRFWFRfTk9ERSYmMD09PWsucmVwbGFjZSgvXFxcXG4vZyxcXFwiXFxcIikucmVwbGFjZSgvKF4gKil8KCAqJCkvZyxcXFwiXFxcIikubGVuZ3RofHwobnVsbD09ZyYmKGc9Yi5kb2MuY3JlYXRlRWxlbWVudChlKSxkJiZnLnNldEF0dHJpYnV0ZShcXFwiY2xhc3NcXFwiLFxcXCJmci10ZW1wLWRpdlxcXCIpLGYuYXBwZW5kQ2hpbGQoZyksaD0hMSksZy5hcHBlbmRDaGlsZChpKSxofHxiLm5vZGUuaGFzQ2xhc3MoaSxcXFwiZnItbWFya2VyXFxcIil8fGkubm9kZVR5cGU9PU5vZGUuVEVYVF9OT0RFJiYwPT09ay5yZXBsYWNlKC8gL2csXFxcIlxcXCIpLmxlbmd0aHx8KGg9ITApKX1pPWp9YS5pbm5lckhUTUw9XFxcIlxcXCIsYS5hcHBlbmRDaGlsZChmKX19ZnVuY3Rpb24gaShhLGIpe2Zvcih2YXIgYz0wO2M8YS5sZW5ndGg7YysrKWgoYVtjXSxiKX1mdW5jdGlvbiBqKGEsYyxkLGUpe3JldHVybiEhYi4kd3AmJihcXFwidW5kZWZpbmVkXFxcIj09dHlwZW9mIGEmJihhPSExKSxcXFwidW5kZWZpbmVkXFxcIj09dHlwZW9mIGMmJihjPSExKSxcXFwidW5kZWZpbmVkXFxcIj09dHlwZW9mIGQmJihkPSExKSxcXFwidW5kZWZpbmVkXFxcIj09dHlwZW9mIGUmJihlPSExKSxoKGIuZWwsYSksZSYmaShiLmVsLnF1ZXJ5U2VsZWN0b3JBbGwoXFxcIi5mci1pbm5lclxcXCIpLGEpLGMmJmkoYi5lbC5xdWVyeVNlbGVjdG9yQWxsKFxcXCJ0ZCwgdGhcXFwiKSxhKSx2b2lkKGQmJmkoYi5lbC5xdWVyeVNlbGVjdG9yQWxsKFxcXCJibG9ja3F1b3RlXFxcIiksYSkpKX1mdW5jdGlvbiBrKCl7Yi4kZWwuZmluZChcXFwiZGl2LmZyLXRlbXAtZGl2XFxcIikuZWFjaChmdW5jdGlvbigpe2EodGhpcykuZGF0YShcXFwiZW1wdHlcXFwiKXx8XFxcIkxJXFxcIj09dGhpcy5wYXJlbnROb2RlLnRhZ05hbWV8fGIubm9kZS5pc0Jsb2NrKHRoaXMubmV4dFNpYmxpbmcpJiYhYSh0aGlzLm5leHRTaWJsaW5nKS5oYXNDbGFzcyhcXFwiZnItdGVtcC1kaXZcXFwiKT9hKHRoaXMpLnJlcGxhY2VXaXRoKGEodGhpcykuaHRtbCgpKTphKHRoaXMpLnJlcGxhY2VXaXRoKGEodGhpcykuaHRtbCgpK1xcXCI8YnI+XFxcIil9KSxiLiRlbC5maW5kKFxcXCIuZnItdGVtcC1kaXZcXFwiKS5yZW1vdmVDbGFzcyhcXFwiZnItdGVtcC1kaXZcXFwiKS5maWx0ZXIoZnVuY3Rpb24oKXtyZXR1cm5cXFwiXFxcIj09PWEodGhpcykuYXR0cihcXFwiY2xhc3NcXFwiKX0pLnJlbW92ZUF0dHIoXFxcImNsYXNzXFxcIil9ZnVuY3Rpb24gbChjKXtmb3IodmFyIGU9ZChjKSxmPTA7ZjxlLmxlbmd0aDtmKyspe3ZhciBnPWVbZl07XFxcImZhbHNlXFxcIj09PWcuZ2V0QXR0cmlidXRlKFxcXCJjb250ZW50ZWRpdGFibGVcXFwiKXx8Zy5xdWVyeVNlbGVjdG9yKGIub3B0cy5odG1sQWxsb3dlZEVtcHR5VGFncy5qb2luKFxcXCI6bm90KC5mci1tYXJrZXIpLFxcXCIpK1xcXCI6bm90KC5mci1tYXJrZXIpXFxcIil8fGIubm9kZS5pc1ZvaWQoZyl8fFxcXCJUQUJMRVxcXCIhPWcudGFnTmFtZSYmXFxcIlRCT0RZXFxcIiE9Zy50YWdOYW1lJiZcXFwiVFJcXFwiIT1nLnRhZ05hbWUmJmcuYXBwZW5kQ2hpbGQoYi5kb2MuY3JlYXRlRWxlbWVudChcXFwiYnJcXFwiKSl9aWYoYi5icm93c2VyLm1zaWUmJmIub3B0cy5lbnRlcj09YS5GRS5FTlRFUl9CUil7dmFyIGg9Yi5ub2RlLmNvbnRlbnRzKGIuZWwpO2gubGVuZ3RoJiZoW2gubGVuZ3RoLTFdLm5vZGVUeXBlPT1Ob2RlLlRFWFRfTk9ERSYmYi4kZWwuYXBwZW5kKFxcXCI8YnI+XFxcIil9fWZ1bmN0aW9uIG0oKXtyZXR1cm4gYi4kZWwuZ2V0KDApLnF1ZXJ5U2VsZWN0b3JBbGwoZigpKX1mdW5jdGlvbiBuKGEpe2lmKFxcXCJ1bmRlZmluZWRcXFwiPT10eXBlb2YgYSYmKGE9Yi5lbCksYSYmW1xcXCJTQ1JJUFRcXFwiLFxcXCJTVFlMRVxcXCIsXFxcIlBSRVxcXCJdLmluZGV4T2YoYS50YWdOYW1lKT49MClyZXR1cm4hMTtmb3IodmFyIGM9Yi5kb2MuY3JlYXRlVHJlZVdhbGtlcihhLE5vZGVGaWx0ZXIuU0hPV19URVhULGIubm9kZS5maWx0ZXIoZnVuY3Rpb24oYSl7cmV0dXJuIG51bGwhPWEudGV4dENvbnRlbnQubWF0Y2goLyhbIFxcXFxuXXsyLH0pfCheWyBcXFxcbl17MSx9KXwoWyBcXFxcbl17MSx9JCkvZyl9KSwhMSk7Yy5uZXh0Tm9kZSgpOyl7dmFyIGQ9Yy5jdXJyZW50Tm9kZTtpZihcXFwiUFJFXFxcIiE9ZC5wYXJlbnROb2RlLnRhZ05hbWUpe3ZhciBlPWIubm9kZS5pc0Jsb2NrKGQucGFyZW50Tm9kZSl8fGIubm9kZS5pc0VsZW1lbnQoZC5wYXJlbnROb2RlKSxmPWQudGV4dENvbnRlbnQucmVwbGFjZSgvKD8hXikoICl7Mix9KD8hJCkvZyxcXFwiIFxcXCIpLnJlcGxhY2UoL1xcXFxuL2csXFxcIiBcXFwiKS5yZXBsYWNlKC9eWyBdezIsfS9nLFxcXCIgXFxcIikucmVwbGFjZSgvWyBdezIsfSQvZyxcXFwiIFxcXCIpO2lmKGUpe3ZhciBnPWQucHJldmlvdXNTaWJsaW5nLGg9ZC5uZXh0U2libGluZztnJiZoJiZcXFwiIFxcXCI9PWY/Zj1iLm5vZGUuaXNCbG9jayhnKSYmYi5ub2RlLmlzQmxvY2soaCk/XFxcIlxcXCI6XFxcIlxcXFxuXFxcIjooZ3x8KGY9Zi5yZXBsYWNlKC9eICovLFxcXCJcXFwiKSksaHx8KGY9Zi5yZXBsYWNlKC8gKiQvLFxcXCJcXFwiKSkpfWQudGV4dENvbnRlbnQ9Zn19fWZ1bmN0aW9uIG8oYSxiLGMpe3ZhciBkPW5ldyBSZWdFeHAoYixcXFwiZ2lcXFwiKSxlPWQuZXhlYyhhKTtyZXR1cm4gZT9lW2NdOm51bGx9ZnVuY3Rpb24gcChhLGIpe3ZhciBjPWEubWF0Y2goLzwhRE9DVFlQRSA/KFteIF0qKSA/KFteIF0qKSA/XFxcIj8oW15cXFwiXSopXFxcIj8gP1xcXCI/KFteXFxcIl0qKVxcXCI/Pi9pKTtyZXR1cm4gYz9iLmltcGxlbWVudGF0aW9uLmNyZWF0ZURvY3VtZW50VHlwZShjWzFdLGNbM10sY1s0XSk6Yi5pbXBsZW1lbnRhdGlvbi5jcmVhdGVEb2N1bWVudFR5cGUoXFxcImh0bWxcXFwiKX1mdW5jdGlvbiBxKGEpe3ZhciBiPWEuZG9jdHlwZSxjPVxcXCI8IURPQ1RZUEUgaHRtbD5cXFwiO3JldHVybiBiJiYoYz1cXFwiPCFET0NUWVBFIFxcXCIrYi5uYW1lKyhiLnB1YmxpY0lkPycgUFVCTElDIFxcXCInK2IucHVibGljSWQrJ1xcXCInOlxcXCJcXFwiKSsoIWIucHVibGljSWQmJmIuc3lzdGVtSWQ/XFxcIiBTWVNURU1cXFwiOlxcXCJcXFwiKSsoYi5zeXN0ZW1JZD8nIFxcXCInK2Iuc3lzdGVtSWQrJ1xcXCInOlxcXCJcXFwiKStcXFwiPlxcXCIpLGN9ZnVuY3Rpb24gcihjLGQpe3ZhciBlPWMucGFyZW50Tm9kZTtpZihlJiYoYi5ub2RlLmlzQmxvY2soZSl8fGIubm9kZS5pc0VsZW1lbnQoZSkpJiZbXFxcIlREXFxcIixcXFwiVEhcXFwiXS5pbmRleE9mKGUudGFnTmFtZSk8MCl7Zm9yKHZhciBmPWMucHJldmlvdXNTaWJsaW5nLGc9Yy5uZXh0U2libGluZztmJiZmLm5vZGVUeXBlPT1Ob2RlLlRFWFRfTk9ERSYmMD09PWYudGV4dENvbnRlbnQucmVwbGFjZSgvXFxcXG58XFxcXHIvZyxcXFwiXFxcIikubGVuZ3RoOylmPWYucHJldmlvdXNTaWJsaW5nO2YmJmUmJlxcXCJCUlxcXCIhPWYudGFnTmFtZSYmIWIubm9kZS5pc0Jsb2NrKGYpJiYhZyYmZS50ZXh0Q29udGVudC5yZXBsYWNlKC9cXFxcdTIwMEIvZyxcXFwiXFxcIikubGVuZ3RoPjAmJmYudGV4dENvbnRlbnQubGVuZ3RoPjAmJiFiLm5vZGUuaGFzQ2xhc3MoZixcXFwiZnItbWFya2VyXFxcIikmJihiLmVsPT1lJiYhZyYmYi5vcHRzLmVudGVyPT1hLkZFLkVOVEVSX0JSJiZiLmJyb3dzZXIubXNpZXx8KGQmJmIuc2VsZWN0aW9uLnNhdmUoKSxjLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoYyksZCYmYi5zZWxlY3Rpb24ucmVzdG9yZSgpKSl9fWZ1bmN0aW9uIHMoKXt2YXIgYSxjLGQ9Yi5zZWxlY3Rpb24uZWxlbWVudCgpO2E9Yi5ub2RlLmlzQmxvY2soZCk/ZDpiLm5vZGUuYmxvY2tQYXJlbnQoZCk7dmFyIGU9W107aWYoYSl7dmFyIGY9YS5uZXh0U2libGluZyxnPWEucHJldmlvdXNTaWJsaW5nO2EmJmUuaW5kZXhPZihhKTwwJiZlLnB1c2goYSksZyYmYi5ub2RlLmlzQmxvY2soZykmJmUuaW5kZXhPZihnKTwwJiZlLnB1c2goZyksZiYmYi5ub2RlLmlzQmxvY2soZikmJmUuaW5kZXhPZihmKTwwJiZlLnB1c2goZil9dmFyIGg9W107Zm9yKGM9MDtjPGUubGVuZ3RoO2MrKylmb3IodmFyIGk9ZVtjXS5xdWVyeVNlbGVjdG9yQWxsKFxcXCJiclxcXCIpLGo9MDtqPGkubGVuZ3RoO2orKyloLmluZGV4T2YoaVtqXSk8MCYmaC5wdXNoKGlbal0pO2lmKGQucGFyZW50Tm9kZT09Yi5lbCl7dmFyIGs9Yi5lbC5jaGlsZHJlbjtmb3IoYz0wO2M8ay5sZW5ndGg7YysrKVxcXCJCUlxcXCI9PWtbY10udGFnTmFtZSYmaC5pbmRleE9mKGtbY10pPDAmJmgucHVzaChrW2NdKX1yZXR1cm4gaH1mdW5jdGlvbiB0KGEsYyl7dmFyIGQsZT1udWxsO2lmKGEpZm9yKGU9cygpLGQ9MDtkPGUubGVuZ3RoO2QrKylyKGVbZF0sYyk7ZWxzZSBmb3IoZT1iLmVsLmdldEVsZW1lbnRzQnlUYWdOYW1lKFxcXCJiclxcXCIpLGQ9MDtkPGUubGVuZ3RoO2QrKylyKGVbZF0sYyl9ZnVuY3Rpb24gdSgpe2Iub3B0cy5odG1sVW50b3VjaGVkfHwoZygpLGooKSksbigpLGIub3B0cy5odG1sVW50b3VjaGVkfHwoYi5zcGFjZXMubm9ybWFsaXplKG51bGwsITApLGIuaHRtbC5maWxsRW1wdHlCbG9ja3MoKSxiLmNsZWFuLnF1b3RlcygpLGIuY2xlYW4ubGlzdHMoKSxiLmNsZWFuLnRhYmxlcygpLGIuY2xlYW4udG9IVE1MNSgpLGIuaHRtbC5jbGVhbkJScygpKSxiLnNlbGVjdGlvbi5yZXN0b3JlKCksdigpLGIucGxhY2Vob2xkZXIucmVmcmVzaCgpfWZ1bmN0aW9uIHYoKXtiLmNvcmUuaXNFbXB0eSgpJiYobnVsbCE9YygpP2IuZWwucXVlcnlTZWxlY3RvcihmKCkpfHxiLmVsLnF1ZXJ5U2VsZWN0b3IoYi5vcHRzLmh0bWxEb05vdFdyYXBUYWdzLmpvaW4oXFxcIjpub3QoLmZyLW1hcmtlciksXFxcIikrXFxcIjpub3QoLmZyLW1hcmtlcilcXFwiKXx8KGIuY29yZS5oYXNGb2N1cygpPyhiLiRlbC5odG1sKFxcXCI8XFxcIitjKCkrXFxcIj5cXFwiK2EuRkUuTUFSS0VSUytcXFwiPGJyLz48L1xcXCIrYygpK1xcXCI+XFxcIiksYi5zZWxlY3Rpb24ucmVzdG9yZSgpKTpiLiRlbC5odG1sKFxcXCI8XFxcIitjKCkrXFxcIj48YnIvPjwvXFxcIitjKCkrXFxcIj5cXFwiKSk6Yi5lbC5xdWVyeVNlbGVjdG9yKFxcXCIqOm5vdCguZnItbWFya2VyKTpub3QoYnIpXFxcIil8fChiLmNvcmUuaGFzRm9jdXMoKT8oYi4kZWwuaHRtbChhLkZFLk1BUktFUlMrXFxcIjxici8+XFxcIiksYi5zZWxlY3Rpb24ucmVzdG9yZSgpKTpiLiRlbC5odG1sKFxcXCI8YnIvPlxcXCIpKSl9ZnVuY3Rpb24gdyhhLGIpe3JldHVybiBvKGEsXFxcIjxcXFwiK2IrXFxcIltePl0qPz4oW1xcXFxcXFxcd1xcXFxcXFxcV10qKTwvXFxcIitiK1xcXCI+XFxcIiwxKX1mdW5jdGlvbiB4KGMsZCl7dmFyIGU9YShcXFwiPGRpdiBcXFwiKyhvKGMsXFxcIjxcXFwiK2QrXFxcIihbXj5dKj8pPlxcXCIsMSl8fFxcXCJcXFwiKStcXFwiPlxcXCIpO3JldHVybiBiLm5vZGUucmF3QXR0cmlidXRlcyhlLmdldCgwKSl9ZnVuY3Rpb24geShhKXtyZXR1cm4gbyhhLFxcXCI8IURPQ1RZUEUoW14+XSo/KT5cXFwiLDApfHxcXFwiPCFET0NUWVBFIGh0bWw+XFxcIn1mdW5jdGlvbiB6KGMpe3ZhciBkPWIuY2xlYW4uaHRtbChjfHxcXFwiXFxcIixbXSxbXSxiLm9wdHMuZnVsbFBhZ2UpO2lmKGIub3B0cy5mdWxsUGFnZSl7dmFyIGU9dyhkLFxcXCJib2R5XFxcIil8fChkLmluZGV4T2YoXFxcIjxib2R5XFxcIik+PTA/XFxcIlxcXCI6ZCksZj14KGQsXFxcImJvZHlcXFwiKSxnPXcoZCxcXFwiaGVhZFxcXCIpfHxcXFwiPHRpdGxlPjwvdGl0bGU+XFxcIixoPXgoZCxcXFwiaGVhZFxcXCIpLGk9YShcXFwiPGRpdj5cXFwiKS5hcHBlbmQoZykuY29udGVudHMoKS5lYWNoKGZ1bmN0aW9uKCl7KHRoaXMubm9kZVR5cGU9PU5vZGUuQ09NTUVOVF9OT0RFfHxbXFxcIkJBU0VcXFwiLFxcXCJMSU5LXFxcIixcXFwiTUVUQVxcXCIsXFxcIk5PU0NSSVBUXFxcIixcXFwiU0NSSVBUXFxcIixcXFwiU1RZTEVcXFwiLFxcXCJURU1QTEFURVxcXCIsXFxcIlRJVExFXFxcIl0uaW5kZXhPZih0aGlzLnRhZ05hbWUpPj0wKSYmdGhpcy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMpfSkuZW5kKCkuaHRtbCgpLnRyaW0oKTtnPWEoXFxcIjxkaXY+XFxcIikuYXBwZW5kKGcpLmNvbnRlbnRzKCkubWFwKGZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubm9kZVR5cGU9PU5vZGUuQ09NTUVOVF9OT0RFP1xcXCI8IS0tXFxcIit0aGlzLm5vZGVWYWx1ZStcXFwiLS0+XFxcIjpbXFxcIkJBU0VcXFwiLFxcXCJMSU5LXFxcIixcXFwiTUVUQVxcXCIsXFxcIk5PU0NSSVBUXFxcIixcXFwiU0NSSVBUXFxcIixcXFwiU1RZTEVcXFwiLFxcXCJURU1QTEFURVxcXCIsXFxcIlRJVExFXFxcIl0uaW5kZXhPZih0aGlzLnRhZ05hbWUpPj0wP3RoaXMub3V0ZXJIVE1MOlxcXCJcXFwifSkudG9BcnJheSgpLmpvaW4oXFxcIlxcXCIpO3ZhciBqPXkoZCksaz14KGQsXFxcImh0bWxcXFwiKTtiLiRlbC5odG1sKGkrXFxcIlxcXFxuXFxcIitlKSxiLm5vZGUuY2xlYXJBdHRyaWJ1dGVzKGIuZWwpLGIuJGVsLmF0dHIoZiksYi4kZWwuYWRkQ2xhc3MoXFxcImZyLXZpZXdcXFwiKSxiLiRlbC5hdHRyKFxcXCJzcGVsbGNoZWNrXFxcIixiLm9wdHMuc3BlbGxjaGVjayksYi4kZWwuYXR0cihcXFwiZGlyXFxcIixiLm9wdHMuZGlyZWN0aW9uKSxiLiRoZWFkLmh0bWwoZyksYi5ub2RlLmNsZWFyQXR0cmlidXRlcyhiLiRoZWFkLmdldCgwKSksYi4kaGVhZC5hdHRyKGgpLGIubm9kZS5jbGVhckF0dHJpYnV0ZXMoYi4kaHRtbC5nZXQoMCkpLGIuJGh0bWwuYXR0cihrKSxiLmlmcmFtZV9kb2N1bWVudC5kb2N0eXBlLnBhcmVudE5vZGUucmVwbGFjZUNoaWxkKHAoaixiLmlmcmFtZV9kb2N1bWVudCksYi5pZnJhbWVfZG9jdW1lbnQuZG9jdHlwZSl9ZWxzZSBiLiRlbC5odG1sKGQpO3ZhciBsPWIuZWRpdC5pc0Rpc2FibGVkKCk7Yi5lZGl0Lm9uKCksYi5jb3JlLmluamVjdFN0eWxlKGIub3B0cy5pZnJhbWVTdHlsZSksdSgpLGIub3B0cy51c2VDbGFzc2VzfHwoYi4kZWwuZmluZChcXFwiW2ZyLW9yaWdpbmFsLWNsYXNzXVxcXCIpLmVhY2goZnVuY3Rpb24oKXt0aGlzLnNldEF0dHJpYnV0ZShcXFwiY2xhc3NcXFwiLHRoaXMuZ2V0QXR0cmlidXRlKFxcXCJmci1vcmlnaW5hbC1jbGFzc1xcXCIpKSx0aGlzLnJlbW92ZUF0dHJpYnV0ZShcXFwiZnItb3JpZ2luYWwtY2xhc3NcXFwiKX0pLGIuJGVsLmZpbmQoXFxcIltmci1vcmlnaW5hbC1zdHlsZV1cXFwiKS5lYWNoKGZ1bmN0aW9uKCl7dGhpcy5zZXRBdHRyaWJ1dGUoXFxcInN0eWxlXFxcIix0aGlzLmdldEF0dHJpYnV0ZShcXFwiZnItb3JpZ2luYWwtc3R5bGVcXFwiKSksdGhpcy5yZW1vdmVBdHRyaWJ1dGUoXFxcImZyLW9yaWdpbmFsLXN0eWxlXFxcIil9KSksbCYmYi5lZGl0Lm9mZigpLGIuZXZlbnRzLnRyaWdnZXIoXFxcImh0bWwuc2V0XFxcIil9ZnVuY3Rpb24gQShhKXt2YXIgYj0vKCNbXlxcXFxzXFxcXCs+flxcXFwuXFxcXFs6XSspL2csYz0vKFxcXFxbW15cXFxcXV0rXFxcXF0pL2csZD0vKFxcXFwuW15cXFxcc1xcXFwrPn5cXFxcLlxcXFxbOl0rKS9nLGU9Lyg6OlteXFxcXHNcXFxcKz5+XFxcXC5cXFxcWzpdK3w6Zmlyc3QtbGluZXw6Zmlyc3QtbGV0dGVyfDpiZWZvcmV8OmFmdGVyKS9naSxmPS8oOltcXFxcdy1dK1xcXFwoW15cXFxcKV0qXFxcXCkpL2dpLGc9Lyg6W15cXFxcc1xcXFwrPn5cXFxcLlxcXFxbOl0rKS9nLGg9LyhbXlxcXFxzXFxcXCs+flxcXFwuXFxcXFs6XSspL2c7IWZ1bmN0aW9uKCl7dmFyIGI9Lzpub3RcXFxcKChbXlxcXFwpXSopXFxcXCkvZztiLnRlc3QoYSkmJihhPWEucmVwbGFjZShiLFxcXCIgICAgICQxIFxcXCIpKX0oKTt2YXIgaT0xMDAqKGEubWF0Y2goYil8fFtdKS5sZW5ndGgrMTAqKGEubWF0Y2goYyl8fFtdKS5sZW5ndGgrMTAqKGEubWF0Y2goZCl8fFtdKS5sZW5ndGgrMTAqKGEubWF0Y2goZil8fFtdKS5sZW5ndGgrMTAqKGEubWF0Y2goZyl8fFtdKS5sZW5ndGgrKGEubWF0Y2goZSl8fFtdKS5sZW5ndGg7cmV0dXJuIGE9YS5yZXBsYWNlKC9bXFxcXCpcXFxcc1xcXFwrPn5dL2csXFxcIiBcXFwiKSxhPWEucmVwbGFjZSgvWyNcXFxcLl0vZyxcXFwiIFxcXCIpLGkrPShhLm1hdGNoKGgpfHxbXSkubGVuZ3RofWZ1bmN0aW9uIEIoYSl7aWYoYi5ldmVudHMudHJpZ2dlcihcXFwiaHRtbC5wcm9jZXNzR2V0XFxcIixbYV0pLGEmJmEuZ2V0QXR0cmlidXRlJiZcXFwiXFxcIj09PWEuZ2V0QXR0cmlidXRlKFxcXCJjbGFzc1xcXCIpJiZhLnJlbW92ZUF0dHJpYnV0ZShcXFwiY2xhc3NcXFwiKSxhJiZhLm5vZGVUeXBlPT1Ob2RlLkVMRU1FTlRfTk9ERSlmb3IodmFyIGM9YS5xdWVyeVNlbGVjdG9yQWxsKCdbY2xhc3M9XFxcIlxcXCJdJyksZD0wO2Q8Yy5sZW5ndGg7ZCsrKWNbZF0ucmVtb3ZlQXR0cmlidXRlKFxcXCJjbGFzc1xcXCIpfWZ1bmN0aW9uIEMoYSxiKXtyZXR1cm4gYVszXS1iWzNdfWZ1bmN0aW9uIEQoYSxjKXtpZighYi4kd3ApcmV0dXJuIGIuJG9lbC5jbG9uZSgpLnJlbW92ZUNsYXNzKFxcXCJmci12aWV3XFxcIikucmVtb3ZlQXR0cihcXFwiY29udGVudGVkaXRhYmxlXFxcIikuZ2V0KDApLm91dGVySFRNTDt2YXIgZD1cXFwiXFxcIjtiLmV2ZW50cy50cmlnZ2VyKFxcXCJodG1sLmJlZm9yZUdldFxcXCIpO3ZhciBlLGYsZz1bXSxoPXt9LGk9W107aWYoIWIub3B0cy51c2VDbGFzc2VzJiYhYyl7dmFyIGo9bmV3IFJlZ0V4cChcXFwiXlxcXCIrYi5vcHRzLmh0bWxJZ25vcmVDU1NQcm9wZXJ0aWVzLmpvaW4oXFxcIiR8XlxcXCIpK1xcXCIkXFxcIixcXFwiZ2lcXFwiKTtmb3IoZT0wO2U8Yi5kb2Muc3R5bGVTaGVldHMubGVuZ3RoO2UrKyl7dmFyIGssbD0wO3RyeXtrPWIuZG9jLnN0eWxlU2hlZXRzW2VdLmNzc1J1bGVzLGIuZG9jLnN0eWxlU2hlZXRzW2VdLm93bmVyTm9kZSYmXFxcIlNUWUxFXFxcIj09Yi5kb2Muc3R5bGVTaGVldHNbZV0ub3duZXJOb2RlLm5vZGVUeXBlJiYobD0xKX1jYXRjaChtKXt9aWYoaylmb3IodmFyIG49MCxvPWsubGVuZ3RoO248bztuKyspaWYoa1tuXS5zZWxlY3RvclRleHQmJmtbbl0uc3R5bGUuY3NzVGV4dC5sZW5ndGg+MCl7dmFyIHAscj1rW25dLnNlbGVjdG9yVGV4dC5yZXBsYWNlKC9ib2R5IHxcXFxcLmZyLXZpZXcgL2csXFxcIlxcXCIpLnJlcGxhY2UoLzo6L2csXFxcIjpcXFwiKTt0cnl7cD1iLmVsLnF1ZXJ5U2VsZWN0b3JBbGwocil9Y2F0Y2gobSl7cD1bXX1mb3IoZj0wO2Y8cC5sZW5ndGg7ZisrKXshcFtmXS5nZXRBdHRyaWJ1dGUoXFxcImZyLW9yaWdpbmFsLXN0eWxlXFxcIikmJnBbZl0uZ2V0QXR0cmlidXRlKFxcXCJzdHlsZVxcXCIpPyhwW2ZdLnNldEF0dHJpYnV0ZShcXFwiZnItb3JpZ2luYWwtc3R5bGVcXFwiLHBbZl0uZ2V0QXR0cmlidXRlKFxcXCJzdHlsZVxcXCIpKSxnLnB1c2gocFtmXSkpOnBbZl0uZ2V0QXR0cmlidXRlKFxcXCJmci1vcmlnaW5hbC1zdHlsZVxcXCIpfHxnLnB1c2gocFtmXSksaFtwW2ZdXXx8KGhbcFtmXV09e30pO2Zvcih2YXIgcz0xZTMqbCtBKGtbbl0uc2VsZWN0b3JUZXh0KSx0PWtbbl0uc3R5bGUuY3NzVGV4dC5zcGxpdChcXFwiO1xcXCIpLHU9MDt1PHQubGVuZ3RoO3UrKyl7dmFyIHY9dFt1XS50cmltKCkuc3BsaXQoXFxcIjpcXFwiKVswXTt2Lm1hdGNoKGopfHwoaFtwW2ZdXVt2XXx8KGhbcFtmXV1bdl09MCxcXG4ocFtmXS5nZXRBdHRyaWJ1dGUoXFxcImZyLW9yaWdpbmFsLXN0eWxlXFxcIil8fFxcXCJcXFwiKS5pbmRleE9mKHYrXFxcIjpcXFwiKT49MCYmKGhbcFtmXV1bdl09MWU0KSkscz49aFtwW2ZdXVt2XSYmKGhbcFtmXV1bdl09cyx0W3VdLnRyaW0oKS5sZW5ndGgmJmkucHVzaChbcFtmXSx2LnRyaW0oKSx0W3VdLnRyaW0oKS5zcGxpdChcXFwiOlxcXCIpWzFdLnRyaW0oKSxzXSkpKX19fX1mb3IoaS5zb3J0KEMpLGU9MDtlPGkubGVuZ3RoO2UrKyl7dmFyIHc9aVtlXTt3WzBdLnN0eWxlW3dbMV1dPXdbMl19Zm9yKGU9MDtlPGcubGVuZ3RoO2UrKylpZihnW2VdLmdldEF0dHJpYnV0ZShcXFwiY2xhc3NcXFwiKSYmKGdbZV0uc2V0QXR0cmlidXRlKFxcXCJmci1vcmlnaW5hbC1jbGFzc1xcXCIsZ1tlXS5nZXRBdHRyaWJ1dGUoXFxcImNsYXNzXFxcIikpLGdbZV0ucmVtb3ZlQXR0cmlidXRlKFxcXCJjbGFzc1xcXCIpKSwoZ1tlXS5nZXRBdHRyaWJ1dGUoXFxcImZyLW9yaWdpbmFsLXN0eWxlXFxcIil8fFxcXCJcXFwiKS50cmltKCkubGVuZ3RoPjApe3ZhciB4PWdbZV0uZ2V0QXR0cmlidXRlKFxcXCJmci1vcmlnaW5hbC1zdHlsZVxcXCIpLnNwbGl0KFxcXCI7XFxcIik7Zm9yKGY9MDtmPHgubGVuZ3RoO2YrKyl4W2ZdLmluZGV4T2YoXFxcIjpcXFwiKT4wJiYoZ1tlXS5zdHlsZVt4W2ZdLnNwbGl0KFxcXCI6XFxcIilbMF0udHJpbSgpXT14W2ZdLnNwbGl0KFxcXCI6XFxcIilbMV0udHJpbSgpKX19aWYoYi5jb3JlLmlzRW1wdHkoKT9iLm9wdHMuZnVsbFBhZ2UmJihkPXEoYi5pZnJhbWVfZG9jdW1lbnQpLGQrPVxcXCI8aHRtbFxcXCIrYi5ub2RlLmF0dHJpYnV0ZXMoYi4kaHRtbC5nZXQoMCkpK1xcXCI+XFxcIitiLiRodG1sLmZpbmQoXFxcImhlYWRcXFwiKS5nZXQoMCkub3V0ZXJIVE1MK1xcXCI8Ym9keT48L2JvZHk+PC9odG1sPlxcXCIpOihcXFwidW5kZWZpbmVkXFxcIj09dHlwZW9mIGEmJihhPSExKSxiLm9wdHMuZnVsbFBhZ2U/KGQ9cShiLmlmcmFtZV9kb2N1bWVudCksYi4kZWwucmVtb3ZlQ2xhc3MoXFxcImZyLXZpZXdcXFwiKSxkKz1cXFwiPGh0bWxcXFwiK2Iubm9kZS5hdHRyaWJ1dGVzKGIuJGh0bWwuZ2V0KDApKStcXFwiPlxcXCIrYi4kaHRtbC5odG1sKCkrXFxcIjwvaHRtbD5cXFwiLGIuJGVsLmFkZENsYXNzKFxcXCJmci12aWV3XFxcIikpOmQ9Yi4kZWwuaHRtbCgpKSwhYi5vcHRzLnVzZUNsYXNzZXMmJiFjKWZvcihlPTA7ZTxnLmxlbmd0aDtlKyspZ1tlXS5nZXRBdHRyaWJ1dGUoXFxcImZyLW9yaWdpbmFsLWNsYXNzXFxcIikmJihnW2VdLnNldEF0dHJpYnV0ZShcXFwiY2xhc3NcXFwiLGdbZV0uZ2V0QXR0cmlidXRlKFxcXCJmci1vcmlnaW5hbC1jbGFzc1xcXCIpKSxnW2VdLnJlbW92ZUF0dHJpYnV0ZShcXFwiZnItb3JpZ2luYWwtY2xhc3NcXFwiKSksZ1tlXS5nZXRBdHRyaWJ1dGUoXFxcImZyLW9yaWdpbmFsLXN0eWxlXFxcIik/KGdbZV0uc2V0QXR0cmlidXRlKFxcXCJzdHlsZVxcXCIsZ1tlXS5nZXRBdHRyaWJ1dGUoXFxcImZyLW9yaWdpbmFsLXN0eWxlXFxcIikpLGdbZV0ucmVtb3ZlQXR0cmlidXRlKFxcXCJmci1vcmlnaW5hbC1zdHlsZVxcXCIpKTpnW2VdLnJlbW92ZUF0dHJpYnV0ZShcXFwic3R5bGVcXFwiKTtiLm9wdHMuZnVsbFBhZ2UmJihkPWQucmVwbGFjZSgvPHN0eWxlIGRhdGEtZnItc3R5bGU9XFxcInRydWVcXFwiPig/OltcXFxcd1xcXFxXXSo/KTxcXFxcL3N0eWxlPi9nLFxcXCJcXFwiKSxkPWQucmVwbGFjZSgvPGxpbmsoW14+XSopZGF0YS1mci1zdHlsZT1cXFwidHJ1ZVxcXCIoW14+XSopPi9nLFxcXCJcXFwiKSxkPWQucmVwbGFjZSgvPHN0eWxlKD86W1xcXFx3XFxcXFddKj8pY2xhc3M9XFxcImZpcmVidWdSZXNldFN0eWxlc1xcXCIoPzpbXFxcXHdcXFxcV10qPyk+KD86W1xcXFx3XFxcXFddKj8pPFxcXFwvc3R5bGU+L2csXFxcIlxcXCIpLGQ9ZC5yZXBsYWNlKC88Ym9keSgoPzpbXFxcXHdcXFxcV10qPykpIHNwZWxsY2hlY2s9XFxcInRydWVcXFwiKCg/OltcXFxcd1xcXFxXXSo/KSk+KCg/OltcXFxcd1xcXFxXXSo/KSk8XFxcXC9ib2R5Pi9nLFxcXCI8Ym9keSQxJDI+JDM8L2JvZHk+XFxcIiksZD1kLnJlcGxhY2UoLzxib2R5KCg/OltcXFxcd1xcXFxXXSo/KSkgY29udGVudGVkaXRhYmxlPVxcXCIodHJ1ZXxmYWxzZSlcXFwiKCg/OltcXFxcd1xcXFxXXSo/KSk+KCg/OltcXFxcd1xcXFxXXSo/KSk8XFxcXC9ib2R5Pi9nLFxcXCI8Ym9keSQxJDM+JDQ8L2JvZHk+XFxcIiksZD1kLnJlcGxhY2UoLzxib2R5KCg/OltcXFxcd1xcXFxXXSo/KSkgZGlyPVxcXCIoW1xcXFx3XSopXFxcIigoPzpbXFxcXHdcXFxcV10qPykpPigoPzpbXFxcXHdcXFxcV10qPykpPFxcXFwvYm9keT4vZyxcXFwiPGJvZHkkMSQzPiQ0PC9ib2R5PlxcXCIpLGQ9ZC5yZXBsYWNlKC88Ym9keSgoPzpbXFxcXHdcXFxcV10qPykpY2xhc3M9XFxcIihbXFxcXHdcXFxcV10qPykoZnItcnRsfGZyLWx0cikoW1xcXFx3XFxcXFddKj8pXFxcIigoPzpbXFxcXHdcXFxcV10qPykpPigoPzpbXFxcXHdcXFxcV10qPykpPFxcXFwvYm9keT4vZywnPGJvZHkkMWNsYXNzPVxcXCIkMiQ0XFxcIiQ1PiQ2PC9ib2R5PicpLGQ9ZC5yZXBsYWNlKC88Ym9keSgoPzpbXFxcXHdcXFxcV10qPykpIGNsYXNzPVxcXCJcXFwiKCg/OltcXFxcd1xcXFxXXSo/KSk+KCg/OltcXFxcd1xcXFxXXSo/KSk8XFxcXC9ib2R5Pi9nLFxcXCI8Ym9keSQxJDI+JDM8L2JvZHk+XFxcIikpLGIub3B0cy5odG1sU2ltcGxlQW1wZXJzYW5kJiYoZD1kLnJlcGxhY2UoL1xcXFwmYW1wOy9naSxcXFwiJlxcXCIpKSxiLmV2ZW50cy50cmlnZ2VyKFxcXCJodG1sLmFmdGVyR2V0XFxcIiksYXx8KGQ9ZC5yZXBsYWNlKC88c3BhbltePl0qPyBjbGFzc1xcXFxzKj1cXFxccypbXFxcIiddP2ZyLW1hcmtlcltcXFwiJ10/W14+XSs+XFxcXHUyMDBiPFxcXFwvc3Bhbj4vZ2ksXFxcIlxcXCIpKSxkPWIuY2xlYW4uaW52aXNpYmxlU3BhY2VzKGQpLGQ9Yi5jbGVhbi5leGVjKGQsQik7dmFyIHk9Yi5ldmVudHMuY2hhaW5UcmlnZ2VyKFxcXCJodG1sLmdldFxcXCIsZCk7cmV0dXJuXFxcInN0cmluZ1xcXCI9PXR5cGVvZiB5JiYoZD15KSxkPWQucmVwbGFjZSgvPHByZSg/OltcXFxcd1xcXFxXXSo/KT4oPzpbXFxcXHdcXFxcV10qPyk8XFxcXC9wcmU+L2csZnVuY3Rpb24oYSl7cmV0dXJuIGEucmVwbGFjZSgvPGJyPi9nLFxcXCJcXFxcblxcXCIpfSl9ZnVuY3Rpb24gRSgpe3ZhciBjPWZ1bmN0aW9uKGMsZCl7Zm9yKDtkJiYoZC5ub2RlVHlwZT09Tm9kZS5URVhUX05PREV8fCFiLm5vZGUuaXNCbG9jayhkKSkmJiFiLm5vZGUuaXNFbGVtZW50KGQpOylkJiZkLm5vZGVUeXBlIT1Ob2RlLlRFWFRfTk9ERSYmYShjKS53cmFwSW5uZXIoYi5ub2RlLm9wZW5UYWdTdHJpbmcoZCkrYi5ub2RlLmNsb3NlVGFnU3RyaW5nKGQpKSxkPWQucGFyZW50Tm9kZTtkJiZjLmlubmVySFRNTD09ZC5pbm5lckhUTUwmJihjLmlubmVySFRNTD1kLm91dGVySFRNTCl9LGQ9ZnVuY3Rpb24oKXt2YXIgYyxkPW51bGw7cmV0dXJuIGIud2luLmdldFNlbGVjdGlvbj8oYz1iLndpbi5nZXRTZWxlY3Rpb24oKSxjJiZjLnJhbmdlQ291bnQmJihkPWMuZ2V0UmFuZ2VBdCgwKS5jb21tb25BbmNlc3RvckNvbnRhaW5lcixkLm5vZGVUeXBlIT1Ob2RlLkVMRU1FTlRfTk9ERSYmKGQ9ZC5wYXJlbnROb2RlKSkpOihjPWIuZG9jLnNlbGVjdGlvbikmJlxcXCJDb250cm9sXFxcIiE9Yy50eXBlJiYoZD1jLmNyZWF0ZVJhbmdlKCkucGFyZW50RWxlbWVudCgpKSxudWxsIT1kJiYoYS5pbkFycmF5KGIuZWwsYShkKS5wYXJlbnRzKCkpPj0wfHxkPT1iLmVsKT9kOm51bGx9LGU9XFxcIlxcXCI7aWYoXFxcInVuZGVmaW5lZFxcXCIhPXR5cGVvZiBiLndpbi5nZXRTZWxlY3Rpb24pe2IuYnJvd3Nlci5tb3ppbGxhJiYoYi5zZWxlY3Rpb24uc2F2ZSgpLGIuJGVsLmZpbmQoJy5mci1tYXJrZXJbZGF0YS10eXBlPVxcXCJmYWxzZVxcXCJdJykubGVuZ3RoPjEmJihiLiRlbC5maW5kKCcuZnItbWFya2VyW2RhdGEtdHlwZT1cXFwiZmFsc2VcXFwiXVtkYXRhLWlkPVxcXCIwXFxcIl0nKS5yZW1vdmUoKSxiLiRlbC5maW5kKCcuZnItbWFya2VyW2RhdGEtdHlwZT1cXFwiZmFsc2VcXFwiXTpsYXN0JykuYXR0cihcXFwiZGF0YS1pZFxcXCIsXFxcIjBcXFwiKSxiLiRlbC5maW5kKFxcXCIuZnItbWFya2VyXFxcIikubm90KCdbZGF0YS1pZD1cXFwiMFxcXCJdJykucmVtb3ZlKCkpLGIuc2VsZWN0aW9uLnJlc3RvcmUoKSk7Zm9yKHZhciBmPWIuc2VsZWN0aW9uLnJhbmdlcygpLGc9MDtnPGYubGVuZ3RoO2crKyl7dmFyIGg9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcXFwiZGl2XFxcIik7aC5hcHBlbmRDaGlsZChmW2ddLmNsb25lQ29udGVudHMoKSk7dmFyIGk9aC5jaGlsZHJlbjtpZihpLmxlbmd0aCl7dmFyIGo9aVtpLmxlbmd0aC0xXTsoXFxcIlBcXFwiPT1qLnRhZ05hbWUmJmIub3B0cy5lbnRlcj09YS5Gcm9hbGFFZGl0b3IuRU5URVJfUHx8XFxcIkRJVlxcXCI9PWoudGFnTmFtZSYmYi5vcHRzLmVudGVyPT1hLkZyb2FsYUVkaXRvci5FTlRFUl9ESVYpJiZiLm5vZGUuaXNFbXB0eShqKSYmaC5yZW1vdmVDaGlsZChqKX1jKGgsZCgpKSxhKGgpLmZpbmQoXFxcIi5mci1lbGVtZW50XFxcIikubGVuZ3RoPjAmJihoPWIuZWwpLGUrPWguaW5uZXJIVE1MfX1lbHNlXFxcInVuZGVmaW5lZFxcXCIhPXR5cGVvZiBiLmRvYy5zZWxlY3Rpb24mJlxcXCJUZXh0XFxcIj09Yi5kb2Muc2VsZWN0aW9uLnR5cGUmJihlPWIuZG9jLnNlbGVjdGlvbi5jcmVhdGVSYW5nZSgpLmh0bWxUZXh0KTtyZXR1cm4gZX1mdW5jdGlvbiBGKGEpe3ZhciBjPWIuZG9jLmNyZWF0ZUVsZW1lbnQoXFxcImRpdlxcXCIpO3JldHVybiBjLmlubmVySFRNTD1hLG51bGwhPT1jLnF1ZXJ5U2VsZWN0b3IoZigpKX1mdW5jdGlvbiBHKGEpe3ZhciBjPWIuZG9jLmNyZWF0ZUVsZW1lbnQoXFxcImRpdlxcXCIpO3JldHVybiBjLmlubmVySFRNTD1hLGIuc2VsZWN0aW9uLnNldEF0RW5kKGMpLGMuaW5uZXJIVE1MfWZ1bmN0aW9uIEgoYSl7cmV0dXJuIGEucmVwbGFjZSgvPC9naSxcXFwiJmx0O1xcXCIpLnJlcGxhY2UoLz4vZ2ksXFxcIiZndDtcXFwiKS5yZXBsYWNlKC9cXFwiL2dpLFxcXCImcXVvdDtcXFwiKS5yZXBsYWNlKC8nL2dpLFxcXCImIzM5O1xcXCIpfWZ1bmN0aW9uIEkoYSxjLGQpe2Iuc2VsZWN0aW9uLmlzQ29sbGFwc2VkKCl8fGIuc2VsZWN0aW9uLnJlbW92ZSgpO3ZhciBlO2lmKGU9Yz9hOmIuY2xlYW4uaHRtbChhKSxlPWUucmVwbGFjZSgvXFxcXHJ8XFxcXG4vZyxcXFwiIFxcXCIpLGEuaW5kZXhPZignY2xhc3M9XFxcImZyLW1hcmtlclxcXCInKTwwJiYoZT1HKGUpKSxiLmNvcmUuaXNFbXB0eSgpJiYhYi5vcHRzLmtlZXBGb3JtYXRPbkRlbGV0ZSliLmVsLmlubmVySFRNTD1lO2Vsc2V7dmFyIGY9Yi5tYXJrZXJzLmluc2VydCgpO2lmKGYpe3ZhciBnLGg9Yi5ub2RlLmJsb2NrUGFyZW50KGYpO2lmKChGKGUpfHxkKSYmKGc9Yi5ub2RlLmRlZXBlc3RQYXJlbnQoZil8fGgmJlxcXCJMSVxcXCI9PWgudGFnTmFtZSkpe2lmKGY9Yi5tYXJrZXJzLnNwbGl0KCksIWYpcmV0dXJuITE7Zi5vdXRlckhUTUw9ZX1lbHNlIGYub3V0ZXJIVE1MPWV9ZWxzZSBiLmVsLmlubmVySFRNTD1iLmVsLmlubmVySFRNTCtlfXUoKSxiLmV2ZW50cy50cmlnZ2VyKFxcXCJodG1sLmluc2VydGVkXFxcIil9ZnVuY3Rpb24gSihjKXt2YXIgZD1udWxsO2lmKFxcXCJ1bmRlZmluZWRcXFwiPT10eXBlb2YgYyYmKGQ9Yi5zZWxlY3Rpb24uZWxlbWVudCgpKSxiLm9wdHMua2VlcEZvcm1hdE9uRGVsZXRlKXJldHVybiExO3ZhciBlPWQ/KGQudGV4dENvbnRlbnQubWF0Y2goL1xcXFx1MjAwQi9nKXx8W10pLmxlbmd0aC1kLnF1ZXJ5U2VsZWN0b3JBbGwoXFxcIi5mci1tYXJrZXJcXFwiKS5sZW5ndGg6MCxmPShiLmVsLnRleHRDb250ZW50Lm1hdGNoKC9cXFxcdTIwMEIvZyl8fFtdKS5sZW5ndGgtYi5lbC5xdWVyeVNlbGVjdG9yQWxsKFxcXCIuZnItbWFya2VyXFxcIikubGVuZ3RoO2lmKGY9PWUpcmV0dXJuITE7dmFyIGcsaDtkb3toPSExLGc9Yi5lbC5xdWVyeVNlbGVjdG9yQWxsKFxcXCIqOm5vdCguZnItbWFya2VyKVxcXCIpO2Zvcih2YXIgaT0wO2k8Zy5sZW5ndGg7aSsrKXt2YXIgaj1nW2ldO2lmKGQhPWope3ZhciBrPWoudGV4dENvbnRlbnQ7MD09PWouY2hpbGRyZW4ubGVuZ3RoJiYxPT09ay5sZW5ndGgmJjgyMDM9PWsuY2hhckNvZGVBdCgwKSYmKGEoaikucmVtb3ZlKCksaD0hMCl9fX13aGlsZShoKX1mdW5jdGlvbiBLKCl7dmFyIGE9ZnVuY3Rpb24oKXtKKCksYi5wbGFjZWhvbGRlciYmc2V0VGltZW91dChiLnBsYWNlaG9sZGVyLnJlZnJlc2gsMCl9O2IuZXZlbnRzLm9uKFxcXCJtb3VzZXVwXFxcIixhKSxiLmV2ZW50cy5vbihcXFwia2V5ZG93blxcXCIsYSksYi5ldmVudHMub24oXFxcImNvbnRlbnRDaGFuZ2VkXFxcIix2KX1yZXR1cm57ZGVmYXVsdFRhZzpjLGVtcHR5QmxvY2tzOmQsZW1wdHlCbG9ja1RhZ3NRdWVyeTplLGJsb2NrVGFnc1F1ZXJ5OmYsZmlsbEVtcHR5QmxvY2tzOmwsY2xlYW5FbXB0eVRhZ3M6ZyxjbGVhbldoaXRlVGFnczpKLGNsZWFuQmxhbmtTcGFjZXM6bixibG9ja3M6bSxnZXREb2N0eXBlOnEsc2V0OnosZ2V0OkQsZ2V0U2VsZWN0ZWQ6RSxpbnNlcnQ6SSx3cmFwOmosdW53cmFwOmssZXNjYXBlRW50aXRpZXM6SCxjaGVja0lmRW1wdHk6dixleHRyYWN0Tm9kZTp3LGV4dHJhY3ROb2RlQXR0cnM6eCxleHRyYWN0RG9jdHlwZTp5LGNsZWFuQlJzOnQsX2luaXQ6S319LGEuZXh0ZW5kKGEuRkUuREVGQVVMVFMse2hlaWdodDpudWxsLGhlaWdodE1heDpudWxsLGhlaWdodE1pbjpudWxsLHdpZHRoOm51bGx9KSxhLkZFLk1PRFVMRVMuc2l6ZT1mdW5jdGlvbihhKXtmdW5jdGlvbiBiKCl7YygpLGEub3B0cy5oZWlnaHQmJmEuJGVsLmNzcyhcXFwibWluSGVpZ2h0XFxcIixhLm9wdHMuaGVpZ2h0LWEuaGVscGVycy5nZXRQWChhLiRlbC5jc3MoXFxcInBhZGRpbmctdG9wXFxcIikpLWEuaGVscGVycy5nZXRQWChhLiRlbC5jc3MoXFxcInBhZGRpbmctYm90dG9tXFxcIikpKSxhLiRpZnJhbWUuaGVpZ2h0KGEuJGVsLm91dGVySGVpZ2h0KCEwKSl9ZnVuY3Rpb24gYygpe2Eub3B0cy5oZWlnaHRNaW4/YS4kZWwuY3NzKFxcXCJtaW5IZWlnaHRcXFwiLGEub3B0cy5oZWlnaHRNaW4pOmEuJGVsLmNzcyhcXFwibWluSGVpZ2h0XFxcIixcXFwiXFxcIiksYS5vcHRzLmhlaWdodE1heD8oYS4kd3AuY3NzKFxcXCJtYXhIZWlnaHRcXFwiLGEub3B0cy5oZWlnaHRNYXgpLGEuJHdwLmNzcyhcXFwib3ZlcmZsb3dcXFwiLFxcXCJhdXRvXFxcIikpOihhLiR3cC5jc3MoXFxcIm1heEhlaWdodFxcXCIsXFxcIlxcXCIpLGEuJHdwLmNzcyhcXFwib3ZlcmZsb3dcXFwiLFxcXCJcXFwiKSksYS5vcHRzLmhlaWdodD8oYS4kd3AuaGVpZ2h0KGEub3B0cy5oZWlnaHQpLGEuJHdwLmNzcyhcXFwib3ZlcmZsb3dcXFwiLFxcXCJhdXRvXFxcIiksYS4kZWwuY3NzKFxcXCJtaW5IZWlnaHRcXFwiLGEub3B0cy5oZWlnaHQtYS5oZWxwZXJzLmdldFBYKGEuJGVsLmNzcyhcXFwicGFkZGluZy10b3BcXFwiKSktYS5oZWxwZXJzLmdldFBYKGEuJGVsLmNzcyhcXFwicGFkZGluZy1ib3R0b21cXFwiKSkpKTooYS4kd3AuY3NzKFxcXCJoZWlnaHRcXFwiLFxcXCJcXFwiKSxhLm9wdHMuaGVpZ2h0TWlufHxhLiRlbC5jc3MoXFxcIm1pbkhlaWdodFxcXCIsXFxcIlxcXCIpLGEub3B0cy5oZWlnaHRNYXh8fGEuJHdwLmNzcyhcXFwib3ZlcmZsb3dcXFwiLFxcXCJcXFwiKSksYS5vcHRzLndpZHRoJiZhLiRib3gud2lkdGgoYS5vcHRzLndpZHRoKX1mdW5jdGlvbiBkKCl7cmV0dXJuISFhLiR3cCYmKGMoKSx2b2lkKGEuJGlmcmFtZSYmKGEuZXZlbnRzLm9uKFxcXCJrZXl1cFxcXCIsYiksYS5ldmVudHMub24oXFxcImNvbW1hbmRzLmFmdGVyXFxcIixiKSxhLmV2ZW50cy5vbihcXFwiaHRtbC5zZXRcXFwiLGIpLGEuZXZlbnRzLm9uKFxcXCJpbml0XFxcIixiKSxhLmV2ZW50cy5vbihcXFwiaW5pdGlhbGl6ZWRcXFwiLGIpKSkpfXJldHVybntfaW5pdDpkLHN5bmNJZnJhbWU6YixyZWZyZXNoOmN9fSxhLmV4dGVuZChhLkZFLkRFRkFVTFRTLHtsYW5ndWFnZTpudWxsfSksYS5GRS5MQU5HVUFHRT17fSxhLkZFLk1PRFVMRVMubGFuZ3VhZ2U9ZnVuY3Rpb24oYil7ZnVuY3Rpb24gYyhhKXtyZXR1cm4gZSYmZS50cmFuc2xhdGlvblthXT9lLnRyYW5zbGF0aW9uW2FdOmF9ZnVuY3Rpb24gZCgpe2EuRkUuTEFOR1VBR0UmJihlPWEuRkUuTEFOR1VBR0VbYi5vcHRzLmxhbmd1YWdlXSksZSYmZS5kaXJlY3Rpb24mJihiLm9wdHMuZGlyZWN0aW9uPWUuZGlyZWN0aW9uKX12YXIgZTtyZXR1cm57X2luaXQ6ZCx0cmFuc2xhdGU6Y319LGEuZXh0ZW5kKGEuRkUuREVGQVVMVFMse3BsYWNlaG9sZGVyVGV4dDpcXFwiVHlwZSBzb21ldGhpbmdcXFwifSksYS5GRS5NT0RVTEVTLnBsYWNlaG9sZGVyPWZ1bmN0aW9uKGIpe2Z1bmN0aW9uIGMoKXtiLiRwbGFjZWhvbGRlcnx8ZygpO3ZhciBjPTAsZD0wLGU9MCxmPTAsaD0wLGk9MCxqPWIubm9kZS5jb250ZW50cyhiLmVsKSxrPWEoYi5zZWxlY3Rpb24uZWxlbWVudCgpKS5jc3MoXFxcInRleHQtYWxpZ25cXFwiKTtpZihqLmxlbmd0aCYmalswXS5ub2RlVHlwZT09Tm9kZS5FTEVNRU5UX05PREUpe3ZhciBsPWEoalswXSk7IWIub3B0cy50b29sYmFySW5saW5lJiZiLnJlYWR5JiYoYz1iLmhlbHBlcnMuZ2V0UFgobC5jc3MoXFxcIm1hcmdpbi10b3BcXFwiKSksZj1iLmhlbHBlcnMuZ2V0UFgobC5jc3MoXFxcInBhZGRpbmctdG9wXFxcIikpLGQ9Yi5oZWxwZXJzLmdldFBYKGwuY3NzKFxcXCJtYXJnaW4tbGVmdFxcXCIpKSxlPWIuaGVscGVycy5nZXRQWChsLmNzcyhcXFwibWFyZ2luLXJpZ2h0XFxcIikpLGg9Yi5oZWxwZXJzLmdldFBYKGwuY3NzKFxcXCJwYWRkaW5nLWxlZnRcXFwiKSksaT1iLmhlbHBlcnMuZ2V0UFgobC5jc3MoXFxcInBhZGRpbmctcmlnaHRcXFwiKSkpLGIuJHBsYWNlaG9sZGVyLmNzcyhcXFwiZm9udC1zaXplXFxcIixsLmNzcyhcXFwiZm9udC1zaXplXFxcIikpLGIuJHBsYWNlaG9sZGVyLmNzcyhcXFwibGluZS1oZWlnaHRcXFwiLGwuY3NzKFxcXCJsaW5lLWhlaWdodFxcXCIpKX1lbHNlIGIuJHBsYWNlaG9sZGVyLmNzcyhcXFwiZm9udC1zaXplXFxcIixiLiRlbC5jc3MoXFxcImZvbnQtc2l6ZVxcXCIpKSxiLiRwbGFjZWhvbGRlci5jc3MoXFxcImxpbmUtaGVpZ2h0XFxcIixiLiRlbC5jc3MoXFxcImxpbmUtaGVpZ2h0XFxcIikpO2IuJHdwLmFkZENsYXNzKFxcXCJzaG93LXBsYWNlaG9sZGVyXFxcIiksYi4kcGxhY2Vob2xkZXIuY3NzKHttYXJnaW5Ub3A6TWF0aC5tYXgoYi5oZWxwZXJzLmdldFBYKGIuJGVsLmNzcyhcXFwibWFyZ2luLXRvcFxcXCIpKSxjKSxwYWRkaW5nVG9wOk1hdGgubWF4KGIuaGVscGVycy5nZXRQWChiLiRlbC5jc3MoXFxcInBhZGRpbmctdG9wXFxcIikpLGYpLHBhZGRpbmdMZWZ0Ok1hdGgubWF4KGIuaGVscGVycy5nZXRQWChiLiRlbC5jc3MoXFxcInBhZGRpbmctbGVmdFxcXCIpKSxoKSxtYXJnaW5MZWZ0Ok1hdGgubWF4KGIuaGVscGVycy5nZXRQWChiLiRlbC5jc3MoXFxcIm1hcmdpbi1sZWZ0XFxcIikpLGQpLHBhZGRpbmdSaWdodDpNYXRoLm1heChiLmhlbHBlcnMuZ2V0UFgoYi4kZWwuY3NzKFxcXCJwYWRkaW5nLXJpZ2h0XFxcIikpLGkpLG1hcmdpblJpZ2h0Ok1hdGgubWF4KGIuaGVscGVycy5nZXRQWChiLiRlbC5jc3MoXFxcIm1hcmdpbi1yaWdodFxcXCIpKSxlKSx0ZXh0QWxpZ246a30pLnRleHQoYi5sYW5ndWFnZS50cmFuc2xhdGUoYi5vcHRzLnBsYWNlaG9sZGVyVGV4dHx8Yi4kb2VsLmF0dHIoXFxcInBsYWNlaG9sZGVyXFxcIil8fFxcXCJcXFwiKSksYi4kcGxhY2Vob2xkZXIuaHRtbChiLiRwbGFjZWhvbGRlci50ZXh0KCkucmVwbGFjZSgvXFxcXG4vZyxcXFwiPGJyPlxcXCIpKX1mdW5jdGlvbiBkKCl7Yi4kd3AucmVtb3ZlQ2xhc3MoXFxcInNob3ctcGxhY2Vob2xkZXJcXFwiKX1mdW5jdGlvbiBlKCl7cmV0dXJuIWIuJHdwfHxiLm5vZGUuaGFzQ2xhc3MoYi4kd3AuZ2V0KDApLFxcXCJzaG93LXBsYWNlaG9sZGVyXFxcIil9ZnVuY3Rpb24gZigpe3JldHVybiEhYi4kd3AmJnZvaWQoYi5jb3JlLmlzRW1wdHkoKT9jKCk6ZCgpKX1mdW5jdGlvbiBnKCl7Yi4kcGxhY2Vob2xkZXI9YSgnPHNwYW4gY2xhc3M9XFxcImZyLXBsYWNlaG9sZGVyXFxcIj48L3NwYW4+JyksYi4kd3AuYXBwZW5kKGIuJHBsYWNlaG9sZGVyKX1mdW5jdGlvbiBoKCl7cmV0dXJuISFiLiR3cCYmdm9pZCBiLmV2ZW50cy5vbihcXFwiaW5pdCBpbnB1dCBrZXlkb3duIGtleXVwIGNvbnRlbnRDaGFuZ2VkIGluaXRpYWxpemVkXFxcIixmKX1yZXR1cm57X2luaXQ6aCxzaG93OmMsaGlkZTpkLHJlZnJlc2g6Zixpc1Zpc2libGU6ZX19LGEuRkUuTU9EVUxFUy5lZGl0PWZ1bmN0aW9uKGEpe2Z1bmN0aW9uIGIoKXtpZihhLmJyb3dzZXIubW96aWxsYSl0cnl7YS5kb2MuZXhlY0NvbW1hbmQoXFxcImVuYWJsZU9iamVjdFJlc2l6aW5nXFxcIiwhMSxcXFwiZmFsc2VcXFwiKSxhLmRvYy5leGVjQ29tbWFuZChcXFwiZW5hYmxlSW5saW5lVGFibGVFZGl0aW5nXFxcIiwhMSxcXFwiZmFsc2VcXFwiKX1jYXRjaChiKXt9aWYoYS5icm93c2VyLm1zaWUpdHJ5e2EuZG9jLmJvZHkuYWRkRXZlbnRMaXN0ZW5lcihcXFwibXNjb250cm9sc2VsZWN0XFxcIixmdW5jdGlvbihhKXtyZXR1cm4gYS5wcmV2ZW50RGVmYXVsdCgpLCExfSl9Y2F0Y2goYil7fX1mdW5jdGlvbiBjKCl7YS4kd3A/KGEuJGVsLmF0dHIoXFxcImNvbnRlbnRlZGl0YWJsZVxcXCIsITApLGEuJGVsLnJlbW92ZUNsYXNzKFxcXCJmci1kaXNhYmxlZFxcXCIpLmF0dHIoXFxcImFyaWEtZGlzYWJsZWRcXFwiLCExKSxhLiR0YiYmYS4kdGIucmVtb3ZlQ2xhc3MoXFxcImZyLWRpc2FibGVkXFxcIikuYXR0cihcXFwiYXJpYS1kaXNhYmxlZFxcXCIsITEpLGIoKSk6YS4kZWwuaXMoXFxcImFcXFwiKSYmYS4kZWwuYXR0cihcXFwiY29udGVudGVkaXRhYmxlXFxcIiwhMCksZj0hMX1mdW5jdGlvbiBkKCl7YS4kd3A/KGEuJGVsLmF0dHIoXFxcImNvbnRlbnRlZGl0YWJsZVxcXCIsITEpLGEuJGVsLmFkZENsYXNzKFxcXCJmci1kaXNhYmxlZFxcXCIpLmF0dHIoXFxcImFyaWEtZGlzYWJsZWRcXFwiLCEwKSxhLiR0YiYmYS4kdGIuYWRkQ2xhc3MoXFxcImZyLWRpc2FibGVkXFxcIikuYXR0cihcXFwiYXJpYS1kaXNhYmxlZFxcXCIsITApKTphLiRlbC5pcyhcXFwiYVxcXCIpJiZhLiRlbC5hdHRyKFxcXCJjb250ZW50ZWRpdGFibGVcXFwiLCExKSxmPSEwfWZ1bmN0aW9uIGUoKXtyZXR1cm4gZn12YXIgZj0hMTtyZXR1cm57b246YyxvZmY6ZCxkaXNhYmxlRGVzaWduOmIsaXNEaXNhYmxlZDplfX0sYS5leHRlbmQoYS5GRS5ERUZBVUxUUyx7ZWRpdG9yQ2xhc3M6bnVsbCx0eXBpbmdUaW1lcjo1MDAsaWZyYW1lOiExLHJlcXVlc3RXaXRoQ09SUzohMCxyZXF1ZXN0V2l0aENyZWRlbnRpYWxzOiExLHJlcXVlc3RIZWFkZXJzOnt9LHVzZUNsYXNzZXM6ITAsc3BlbGxjaGVjazohMCxpZnJhbWVTdHlsZTonaHRtbHttYXJnaW46MHB4O2hlaWdodDphdXRvO31ib2R5e2hlaWdodDphdXRvO3BhZGRpbmc6MTBweDtiYWNrZ3JvdW5kOnRyYW5zcGFyZW50O2NvbG9yOiMwMDAwMDA7cG9zaXRpb246cmVsYXRpdmU7ei1pbmRleDogMjstd2Via2l0LXVzZXItc2VsZWN0OmF1dG87bWFyZ2luOjBweDtvdmVyZmxvdzpoaWRkZW47bWluLWhlaWdodDoyMHB4O31ib2R5OmFmdGVye2NvbnRlbnQ6XFxcIlxcXCI7ZGlzcGxheTpibG9jaztjbGVhcjpib3RoO30nLGlmcmFtZVN0eWxlRmlsZXM6W10sZGlyZWN0aW9uOlxcXCJhdXRvXFxcIix6SW5kZXg6MSxkaXNhYmxlUmlnaHRDbGljazohMSxzY3JvbGxhYmxlQ29udGFpbmVyOlxcXCJib2R5XFxcIixrZWVwRm9ybWF0T25EZWxldGU6ITEsdGhlbWU6bnVsbH0pLGEuRkUuTU9EVUxFUy5jb3JlPWZ1bmN0aW9uKGIpe2Z1bmN0aW9uIGMoYyl7aWYoYi5vcHRzLmlmcmFtZSl7Yi4kaGVhZC5maW5kKFxcXCJzdHlsZVtkYXRhLWZyLXN0eWxlXSwgbGlua1tkYXRhLWZyLXN0eWxlXVxcXCIpLnJlbW92ZSgpLGIuJGhlYWQuYXBwZW5kKCc8c3R5bGUgZGF0YS1mci1zdHlsZT1cXFwidHJ1ZVxcXCI+JytjK1xcXCI8L3N0eWxlPlxcXCIpO2Zvcih2YXIgZD0wO2Q8Yi5vcHRzLmlmcmFtZVN0eWxlRmlsZXMubGVuZ3RoO2QrKyl7dmFyIGU9YSgnPGxpbmsgZGF0YS1mci1zdHlsZT1cXFwidHJ1ZVxcXCIgcmVsPVxcXCJzdHlsZXNoZWV0XFxcIiBocmVmPVxcXCInK2Iub3B0cy5pZnJhbWVTdHlsZUZpbGVzW2RdKydcXFwiPicpO2UuZ2V0KDApLmFkZEV2ZW50TGlzdGVuZXIoXFxcImxvYWRcXFwiLGIuc2l6ZS5zeW5jSWZyYW1lKSxiLiRoZWFkLmFwcGVuZChlKX19fWZ1bmN0aW9uIGQoKXtiLm9wdHMuaWZyYW1lfHxiLiRlbC5hZGRDbGFzcyhcXFwiZnItZWxlbWVudCBmci12aWV3XFxcIil9ZnVuY3Rpb24gZSgpe2lmKGIuJGJveC5hZGRDbGFzcyhcXFwiZnItYm94XFxcIisoYi5vcHRzLmVkaXRvckNsYXNzP1xcXCIgXFxcIitiLm9wdHMuZWRpdG9yQ2xhc3M6XFxcIlxcXCIpKSxiLiR3cC5hZGRDbGFzcyhcXFwiZnItd3JhcHBlclxcXCIpLGQoKSxiLm9wdHMuaWZyYW1lKXtiLiRpZnJhbWUuYWRkQ2xhc3MoXFxcImZyLWlmcmFtZVxcXCIpLGIuJGVsLmFkZENsYXNzKFxcXCJmci12aWV3XFxcIik7Zm9yKHZhciBhPTA7YTxiLm9fZG9jLnN0eWxlU2hlZXRzLmxlbmd0aDthKyspe3ZhciBjO3RyeXtjPWIub19kb2Muc3R5bGVTaGVldHNbYV0uY3NzUnVsZXN9Y2F0Y2goZSl7fWlmKGMpZm9yKHZhciBmPTAsZz1jLmxlbmd0aDtmPGc7ZisrKSFjW2ZdLnNlbGVjdG9yVGV4dHx8MCE9PWNbZl0uc2VsZWN0b3JUZXh0LmluZGV4T2YoXFxcIi5mci12aWV3XFxcIikmJjAhPT1jW2ZdLnNlbGVjdG9yVGV4dC5pbmRleE9mKFxcXCIuZnItZWxlbWVudFxcXCIpfHxjW2ZdLnN0eWxlLmNzc1RleHQubGVuZ3RoPjAmJigwPT09Y1tmXS5zZWxlY3RvclRleHQuaW5kZXhPZihcXFwiLmZyLXZpZXdcXFwiKT9iLm9wdHMuaWZyYW1lU3R5bGUrPWNbZl0uc2VsZWN0b3JUZXh0LnJlcGxhY2UoL1xcXFwuZnItdmlldy9nLFxcXCJib2R5XFxcIikrXFxcIntcXFwiK2NbZl0uc3R5bGUuY3NzVGV4dCtcXFwifVxcXCI6Yi5vcHRzLmlmcmFtZVN0eWxlKz1jW2ZdLnNlbGVjdG9yVGV4dC5yZXBsYWNlKC9cXFxcLmZyLWVsZW1lbnQvZyxcXFwiYm9keVxcXCIpK1xcXCJ7XFxcIitjW2ZdLnN0eWxlLmNzc1RleHQrXFxcIn1cXFwiKX19XFxcImF1dG9cXFwiIT1iLm9wdHMuZGlyZWN0aW9uJiZiLiRib3gucmVtb3ZlQ2xhc3MoXFxcImZyLWx0ciBmci1ydGxcXFwiKS5hZGRDbGFzcyhcXFwiZnItXFxcIitiLm9wdHMuZGlyZWN0aW9uKSxiLiRlbC5hdHRyKFxcXCJkaXJcXFwiLGIub3B0cy5kaXJlY3Rpb24pLGIuJHdwLmF0dHIoXFxcImRpclxcXCIsYi5vcHRzLmRpcmVjdGlvbiksYi5vcHRzLnpJbmRleD4xJiZiLiRib3guY3NzKFxcXCJ6LWluZGV4XFxcIixiLm9wdHMuekluZGV4KSxiLm9wdHMudGhlbWUmJmIuJGJveC5hZGRDbGFzcyhiLm9wdHMudGhlbWUrXFxcIi10aGVtZVxcXCIpfWZ1bmN0aW9uIGYoKXtyZXR1cm4gYi5ub2RlLmlzRW1wdHkoYi5lbCl9ZnVuY3Rpb24gZygpe2IuZHJhZ19zdXBwb3J0PXtmaWxlcmVhZGVyOlxcXCJ1bmRlZmluZWRcXFwiIT10eXBlb2YgRmlsZVJlYWRlcixmb3JtZGF0YTohIWIud2luLkZvcm1EYXRhLHByb2dyZXNzOlxcXCJ1cGxvYWRcXFwiaW4gbmV3IFhNTEh0dHBSZXF1ZXN0fX1mdW5jdGlvbiBoKGEsYyl7dmFyIGQ9bmV3IFhNTEh0dHBSZXF1ZXN0O2Qub3BlbihjLGEsITApLGIub3B0cy5yZXF1ZXN0V2l0aENyZWRlbnRpYWxzJiYoZC53aXRoQ3JlZGVudGlhbHM9ITApO2Zvcih2YXIgZSBpbiBiLm9wdHMucmVxdWVzdEhlYWRlcnMpYi5vcHRzLnJlcXVlc3RIZWFkZXJzLmhhc093blByb3BlcnR5KGUpJiZkLnNldFJlcXVlc3RIZWFkZXIoZSxiLm9wdHMucmVxdWVzdEhlYWRlcnNbZV0pO3JldHVybiBkfWZ1bmN0aW9uIGkoYSl7XFxcIlRFWFRBUkVBXFxcIj09Yi4kb2VsLmdldCgwKS50YWdOYW1lJiZiLiRvZWwudmFsKGEpLGIuJHdwJiYoXFxcIlRFWFRBUkVBXFxcIj09Yi4kb2VsLmdldCgwKS50YWdOYW1lPyhiLiRlbC5odG1sKFxcXCJcXFwiKSxiLiR3cC5odG1sKFxcXCJcXFwiKSxiLiRib3gucmVwbGFjZVdpdGgoYi4kb2VsKSxiLiRvZWwuc2hvdygpKTooYi4kd3AucmVwbGFjZVdpdGgoYSksYi4kZWwuaHRtbChcXFwiXFxcIiksYi4kYm94LnJlbW92ZUNsYXNzKFxcXCJmci12aWV3IGZyLWx0ciBmci1ib3ggXFxcIisoYi5vcHRzLmVkaXRvckNsYXNzfHxcXFwiXFxcIikpLGIub3B0cy50aGVtZSYmYi4kYm94LmFkZENsYXNzKGIub3B0cy50aGVtZStcXFwiLXRoZW1lXFxcIikpKSx0aGlzLiR3cD1udWxsLHRoaXMuJGVsPW51bGwsdGhpcy5lbD1udWxsLHRoaXMuJGJveD1udWxsfWZ1bmN0aW9uIGooKXtyZXR1cm4gYi5icm93c2VyLm1vemlsbGEmJmIuaGVscGVycy5pc01vYmlsZSgpP2Iuc2VsZWN0aW9uLmluRWRpdG9yKCk6Yi5ub2RlLmhhc0ZvY3VzKGIuZWwpfHxiLiRlbC5maW5kKFxcXCIqOmZvY3VzXFxcIikubGVuZ3RoPjB9ZnVuY3Rpb24gayhhKXtpZighYSlyZXR1cm4hMTt2YXIgYz1hLmRhdGEoXFxcImluc3RhbmNlXFxcIik7cmV0dXJuISFjJiZjLmlkPT1iLmlkfWZ1bmN0aW9uIGwoKXtpZihhLkZFLklOU1RBTkNFUy5wdXNoKGIpLGcoKSxiLiR3cCl7ZSgpLGIuaHRtbC5zZXQoYi5fb3JpZ2luYWxfaHRtbCksYi4kZWwuYXR0cihcXFwic3BlbGxjaGVja1xcXCIsYi5vcHRzLnNwZWxsY2hlY2spLGIuaGVscGVycy5pc01vYmlsZSgpJiYoYi4kZWwuYXR0cihcXFwiYXV0b2NvbXBsZXRlXFxcIixiLm9wdHMuc3BlbGxjaGVjaz9cXFwib25cXFwiOlxcXCJvZmZcXFwiKSxiLiRlbC5hdHRyKFxcXCJhdXRvY29ycmVjdFxcXCIsYi5vcHRzLnNwZWxsY2hlY2s/XFxcIm9uXFxcIjpcXFwib2ZmXFxcIiksYi4kZWwuYXR0cihcXFwiYXV0b2NhcGl0YWxpemVcXFwiLGIub3B0cy5zcGVsbGNoZWNrP1xcXCJvblxcXCI6XFxcIm9mZlxcXCIpKSxiLm9wdHMuZGlzYWJsZVJpZ2h0Q2xpY2smJmIuZXZlbnRzLiRvbihiLiRlbCxcXFwiY29udGV4dG1lbnVcXFwiLGZ1bmN0aW9uKGEpe2lmKDI9PWEuYnV0dG9uKXJldHVybiExfSk7dHJ5e2IuZG9jLmV4ZWNDb21tYW5kKFxcXCJzdHlsZVdpdGhDU1NcXFwiLCExLCExKX1jYXRjaChjKXt9fVxcXCJURVhUQVJFQVxcXCI9PWIuJG9lbC5nZXQoMCkudGFnTmFtZSYmKGIuZXZlbnRzLm9uKFxcXCJjb250ZW50Q2hhbmdlZFxcXCIsZnVuY3Rpb24oKXtiLiRvZWwudmFsKGIuaHRtbC5nZXQoKSl9KSxiLmV2ZW50cy5vbihcXFwiZm9ybS5zdWJtaXRcXFwiLGZ1bmN0aW9uKCl7Yi4kb2VsLnZhbChiLmh0bWwuZ2V0KCkpfSksYi5ldmVudHMub24oXFxcImZvcm0ucmVzZXRcXFwiLGZ1bmN0aW9uKCl7Yi5odG1sLnNldChiLl9vcmlnaW5hbF9odG1sKX0pLGIuJG9lbC52YWwoYi5odG1sLmdldCgpKSksYi5oZWxwZXJzLmlzSU9TKCkmJmIuZXZlbnRzLiRvbihiLiRkb2MsXFxcInNlbGVjdGlvbmNoYW5nZVxcXCIsZnVuY3Rpb24oKXtiLiRkb2MuZ2V0KDApLmhhc0ZvY3VzKCl8fGIuJHdpbi5nZXQoMCkuZm9jdXMoKX0pLGIuZXZlbnRzLnRyaWdnZXIoXFxcImluaXRcXFwiKX1yZXR1cm57X2luaXQ6bCxkZXN0cm95OmksaXNFbXB0eTpmLGdldFhIUjpoLGluamVjdFN0eWxlOmMsaGFzRm9jdXM6aixzYW1lSW5zdGFuY2U6a319LGEuRkUuTU9EVUxFUy5jdXJzb3JMaXN0cz1mdW5jdGlvbihiKXtmdW5jdGlvbiBjKGEpe2Zvcih2YXIgYj1hO1xcXCJMSVxcXCIhPWIudGFnTmFtZTspYj1iLnBhcmVudE5vZGU7cmV0dXJuIGJ9ZnVuY3Rpb24gZChhKXtmb3IodmFyIGM9YTshYi5ub2RlLmlzTGlzdChjKTspYz1jLnBhcmVudE5vZGU7cmV0dXJuIGN9ZnVuY3Rpb24gZShlKXt2YXIgZixnPWMoZSksaD1nLm5leHRTaWJsaW5nLGk9Zy5wcmV2aW91c1NpYmxpbmcsaj1iLmh0bWwuZGVmYXVsdFRhZygpO2lmKGIubm9kZS5pc0VtcHR5KGcsITApJiZoKXtmb3IodmFyIGs9XFxcIlxcXCIsbD1cXFwiXFxcIixtPWUucGFyZW50Tm9kZTshYi5ub2RlLmlzTGlzdChtKSYmbS5wYXJlbnROb2RlJiZcXFwiTElcXFwiIT09bS5wYXJlbnROb2RlLnRhZ05hbWU7KWs9Yi5ub2RlLm9wZW5UYWdTdHJpbmcobSkrayxsKz1iLm5vZGUuY2xvc2VUYWdTdHJpbmcobSksbT1tLnBhcmVudE5vZGU7az1iLm5vZGUub3BlblRhZ1N0cmluZyhtKStrLGwrPWIubm9kZS5jbG9zZVRhZ1N0cmluZyhtKTt2YXIgbj1cXFwiXFxcIjtmb3Iobj1tLnBhcmVudE5vZGUmJlxcXCJMSVxcXCI9PW0ucGFyZW50Tm9kZS50YWdOYW1lP2wrXFxcIjxsaT5cXFwiK2EuRkUuTUFSS0VSUytcXFwiPGJyPlxcXCIrazpqP2wrXFxcIjxcXFwiK2orXFxcIj5cXFwiK2EuRkUuTUFSS0VSUytcXFwiPGJyPjwvXFxcIitqK1xcXCI+XFxcIitrOmwrYS5GRS5NQVJLRVJTK1xcXCI8YnI+XFxcIitrLGEoZykuaHRtbCgnPHNwYW4gaWQ9XFxcImZyLWJyZWFrXFxcIj48L3NwYW4+Jyk7W1xcXCJVTFxcXCIsXFxcIk9MXFxcIl0uaW5kZXhPZihtLnRhZ05hbWUpPDB8fG0ucGFyZW50Tm9kZSYmXFxcIkxJXFxcIj09PW0ucGFyZW50Tm9kZS50YWdOYW1lOyltPW0ucGFyZW50Tm9kZTt2YXIgbz1iLm5vZGUub3BlblRhZ1N0cmluZyhtKSthKG0pLmh0bWwoKStiLm5vZGUuY2xvc2VUYWdTdHJpbmcobSk7bz1vLnJlcGxhY2UoLzxzcGFuIGlkPVxcXCJmci1icmVha1xcXCI+PFxcXFwvc3Bhbj4vZyxuKSxhKG0pLnJlcGxhY2VXaXRoKG8pLGIuJGVsLmZpbmQoXFxcImxpOmVtcHR5XFxcIikucmVtb3ZlKCl9ZWxzZSBpJiZofHwhYi5ub2RlLmlzRW1wdHkoZywhMCk/KGEoZykuYmVmb3JlKFxcXCI8bGk+PGJyPjwvbGk+XFxcIiksYShlKS5yZW1vdmUoKSk6aT8oZj1kKGcpLGYucGFyZW50Tm9kZSYmXFxcIkxJXFxcIj09Zi5wYXJlbnROb2RlLnRhZ05hbWU/YShmLnBhcmVudE5vZGUpLmFmdGVyKFxcXCI8bGk+XFxcIithLkZFLk1BUktFUlMrXFxcIjxicj48L2xpPlxcXCIpOmo/YShmKS5hZnRlcihcXFwiPFxcXCIraitcXFwiPlxcXCIrYS5GRS5NQVJLRVJTK1xcXCI8YnI+PC9cXFwiK2orXFxcIj5cXFwiKTphKGYpLmFmdGVyKGEuRkUuTUFSS0VSUytcXFwiPGJyPlxcXCIpLGEoZykucmVtb3ZlKCkpOihmPWQoZyksZi5wYXJlbnROb2RlJiZcXFwiTElcXFwiPT1mLnBhcmVudE5vZGUudGFnTmFtZT9oP2EoZi5wYXJlbnROb2RlKS5iZWZvcmUoXFxcIjxsaT5cXFwiK2EuRkUuTUFSS0VSUytcXFwiPGJyPjwvbGk+XFxcIik6YShmLnBhcmVudE5vZGUpLmFmdGVyKFxcXCI8bGk+XFxcIithLkZFLk1BUktFUlMrXFxcIjxicj48L2xpPlxcXCIpOmo/YShmKS5iZWZvcmUoXFxcIjxcXFwiK2orXFxcIj5cXFwiK2EuRkUuTUFSS0VSUytcXFwiPGJyPjwvXFxcIitqK1xcXCI+XFxcIik6YShmKS5iZWZvcmUoYS5GRS5NQVJLRVJTK1xcXCI8YnI+XFxcIiksYShnKS5yZW1vdmUoKSl9ZnVuY3Rpb24gZihkKXtmb3IodmFyIGU9YyhkKSxmPVxcXCJcXFwiLGc9ZCxoPVxcXCJcXFwiLGk9XFxcIlxcXCI7ZyE9ZTspe2c9Zy5wYXJlbnROb2RlO3ZhciBqPVxcXCJBXFxcIj09Zy50YWdOYW1lJiZiLmN1cnNvci5pc0F0RW5kKGQsZyk/XFxcImZyLXRvLXJlbW92ZVxcXCI6XFxcIlxcXCI7aD1iLm5vZGUub3BlblRhZ1N0cmluZyhhKGcpLmNsb25lKCkuYWRkQ2xhc3MoaikuZ2V0KDApKStoLGk9Yi5ub2RlLmNsb3NlVGFnU3RyaW5nKGcpK2l9Zj1pK2YraCthLkZFLk1BUktFUlMsYShkKS5yZXBsYWNlV2l0aCgnPHNwYW4gaWQ9XFxcImZyLWJyZWFrXFxcIj48L3NwYW4+Jyk7dmFyIGs9Yi5ub2RlLm9wZW5UYWdTdHJpbmcoZSkrYShlKS5odG1sKCkrYi5ub2RlLmNsb3NlVGFnU3RyaW5nKGUpO2s9ay5yZXBsYWNlKC88c3BhbiBpZD1cXFwiZnItYnJlYWtcXFwiPjxcXFxcL3NwYW4+L2csZiksYShlKS5yZXBsYWNlV2l0aChrKX1mdW5jdGlvbiBnKGQpe2Zvcih2YXIgZT1jKGQpLGY9YS5GRS5NQVJLRVJTLGc9XFxcIlxcXCIsaD1kLGk9ITE7aCE9ZTspe2g9aC5wYXJlbnROb2RlO3ZhciBqPVxcXCJBXFxcIj09aC50YWdOYW1lJiZiLmN1cnNvci5pc0F0RW5kKGQsaCk/XFxcImZyLXRvLXJlbW92ZVxcXCI6XFxcIlxcXCI7aXx8aD09ZXx8Yi5ub2RlLmlzQmxvY2soaCl8fChpPSEwLGcrPWEuRkUuSU5WSVNJQkxFX1NQQUNFKSxnPWIubm9kZS5vcGVuVGFnU3RyaW5nKGEoaCkuY2xvbmUoKS5hZGRDbGFzcyhqKS5nZXQoMCkpK2csZis9Yi5ub2RlLmNsb3NlVGFnU3RyaW5nKGgpfXZhciBrPWcrZjthKGQpLnJlbW92ZSgpLGEoZSkuYWZ0ZXIoayl9ZnVuY3Rpb24gaChlKXt2YXIgZj1jKGUpLGc9Zi5wcmV2aW91c1NpYmxpbmc7aWYoZyl7Zz1hKGcpLmZpbmQoYi5odG1sLmJsb2NrVGFnc1F1ZXJ5KCkpLmdldCgtMSl8fGcsYShlKS5yZXBsYWNlV2l0aChhLkZFLk1BUktFUlMpO3ZhciBoPWIubm9kZS5jb250ZW50cyhnKTtoLmxlbmd0aCYmXFxcIkJSXFxcIj09aFtoLmxlbmd0aC0xXS50YWdOYW1lJiZhKGhbaC5sZW5ndGgtMV0pLnJlbW92ZSgpLGEoZikuZmluZChiLmh0bWwuYmxvY2tUYWdzUXVlcnkoKSkubm90KFxcXCJvbCwgdWwsIHRhYmxlXFxcIikuZWFjaChmdW5jdGlvbigpe3RoaXMucGFyZW50Tm9kZT09ZiYmYSh0aGlzKS5yZXBsYWNlV2l0aChhKHRoaXMpLmh0bWwoKSsoYi5ub2RlLmlzRW1wdHkodGhpcyk/XFxcIlxcXCI6XFxcIjxicj5cXFwiKSl9KTtmb3IodmFyIGksaj1iLm5vZGUuY29udGVudHMoZilbMF07aiYmIWIubm9kZS5pc0xpc3Qoaik7KWk9ai5uZXh0U2libGluZyxhKGcpLmFwcGVuZChqKSxqPWk7Zm9yKGc9Zi5wcmV2aW91c1NpYmxpbmc7ajspaT1qLm5leHRTaWJsaW5nLGEoZykuYXBwZW5kKGopLGo9aTthKGYpLnJlbW92ZSgpfWVsc2V7dmFyIGs9ZChmKTtpZihhKGUpLnJlcGxhY2VXaXRoKGEuRkUuTUFSS0VSUyksay5wYXJlbnROb2RlJiZcXFwiTElcXFwiPT1rLnBhcmVudE5vZGUudGFnTmFtZSl7dmFyIGw9ay5wcmV2aW91c1NpYmxpbmc7Yi5ub2RlLmlzQmxvY2sobCk/KGEoZikuZmluZChiLmh0bWwuYmxvY2tUYWdzUXVlcnkoKSkubm90KFxcXCJvbCwgdWwsIHRhYmxlXFxcIikuZWFjaChmdW5jdGlvbigpe3RoaXMucGFyZW50Tm9kZT09ZiYmYSh0aGlzKS5yZXBsYWNlV2l0aChhKHRoaXMpLmh0bWwoKSsoYi5ub2RlLmlzRW1wdHkodGhpcyk/XFxcIlxcXCI6XFxcIjxicj5cXFwiKSl9KSxhKGwpLmFwcGVuZChhKGYpLmh0bWwoKSkpOmEoaykuYmVmb3JlKGEoZikuaHRtbCgpKX1lbHNle3ZhciBtPWIuaHRtbC5kZWZhdWx0VGFnKCk7bSYmMD09PWEoZikuZmluZChiLmh0bWwuYmxvY2tUYWdzUXVlcnkoKSkubGVuZ3RoP2EoaykuYmVmb3JlKFxcXCI8XFxcIittK1xcXCI+XFxcIithKGYpLmh0bWwoKStcXFwiPC9cXFwiK20rXFxcIj5cXFwiKTooYShrKS5iZWZvcmUoYShmKS5odG1sKCkpLGIuaHRtbC53cmFwKCkpfWEoZikucmVtb3ZlKCksMD09PWEoaykuZmluZChcXFwibGlcXFwiKS5sZW5ndGgmJmEoaykucmVtb3ZlKCl9fWZ1bmN0aW9uIGkoZCl7dmFyIGUsZj1jKGQpLGc9Zi5uZXh0U2libGluZztpZihnKXtlPWIubm9kZS5jb250ZW50cyhnKSxlLmxlbmd0aCYmXFxcIkJSXFxcIj09ZVswXS50YWdOYW1lJiZhKGVbMF0pLnJlbW92ZSgpLGEoZykuZmluZChiLmh0bWwuYmxvY2tUYWdzUXVlcnkoKSkubm90KFxcXCJvbCwgdWwsIHRhYmxlXFxcIikuZWFjaChmdW5jdGlvbigpe3RoaXMucGFyZW50Tm9kZT09ZyYmYSh0aGlzKS5yZXBsYWNlV2l0aChhKHRoaXMpLmh0bWwoKSsoYi5ub2RlLmlzRW1wdHkodGhpcyk/XFxcIlxcXCI6XFxcIjxicj5cXFwiKSl9KTtmb3IodmFyIGgsaT1kLGo9Yi5ub2RlLmNvbnRlbnRzKGcpWzBdO2omJiFiLm5vZGUuaXNMaXN0KGopOyloPWoubmV4dFNpYmxpbmcsYShpKS5hZnRlcihqKSxpPWosaj1oO2Zvcig7ajspaD1qLm5leHRTaWJsaW5nLGEoZikuYXBwZW5kKGopLGo9aDthKGQpLnJlcGxhY2VXaXRoKGEuRkUuTUFSS0VSUyksYShnKS5yZW1vdmUoKX1lbHNle2Zvcih2YXIgaz1mOyFrLm5leHRTaWJsaW5nJiZrIT1iLmVsOylrPWsucGFyZW50Tm9kZTtpZihrPT1iLmVsKXJldHVybiExO2lmKGs9ay5uZXh0U2libGluZyxiLm5vZGUuaXNCbG9jayhrKSlhLkZFLk5PX0RFTEVURV9UQUdTLmluZGV4T2Yoay50YWdOYW1lKTwwJiYoYShkKS5yZXBsYWNlV2l0aChhLkZFLk1BUktFUlMpLGU9Yi5ub2RlLmNvbnRlbnRzKGYpLGUubGVuZ3RoJiZcXFwiQlJcXFwiPT1lW2UubGVuZ3RoLTFdLnRhZ05hbWUmJmEoZVtlLmxlbmd0aC0xXSkucmVtb3ZlKCksYShmKS5hcHBlbmQoYShrKS5odG1sKCkpLGEoaykucmVtb3ZlKCkpO2Vsc2UgZm9yKGU9Yi5ub2RlLmNvbnRlbnRzKGYpLGUubGVuZ3RoJiZcXFwiQlJcXFwiPT1lW2UubGVuZ3RoLTFdLnRhZ05hbWUmJmEoZVtlLmxlbmd0aC0xXSkucmVtb3ZlKCksYShkKS5yZXBsYWNlV2l0aChhLkZFLk1BUktFUlMpO2smJiFiLm5vZGUuaXNCbG9jayhrKSYmXFxcIkJSXFxcIiE9ay50YWdOYW1lOylhKGYpLmFwcGVuZChhKGspKSxrPWsubmV4dFNpYmxpbmd9fXJldHVybntfc3RhcnRFbnRlcjplLF9taWRkbGVFbnRlcjpmLF9lbmRFbnRlcjpnLF9iYWNrc3BhY2U6aCxfZGVsOml9fSxhLkZFLk5PX0RFTEVURV9UQUdTPVtcXFwiVEhcXFwiLFxcXCJURFxcXCIsXFxcIlRSXFxcIixcXFwiVEFCTEVcXFwiLFxcXCJGT1JNXFxcIl0sYS5GRS5TSU1QTEVfRU5URVJfVEFHUz1bXFxcIlRIXFxcIixcXFwiVERcXFwiLFxcXCJMSVxcXCIsXFxcIkRMXFxcIixcXFwiRFRcXFwiLFxcXCJGT1JNXFxcIl0sYS5GRS5NT0RVTEVTLmN1cnNvcj1mdW5jdGlvbihiKXtmdW5jdGlvbiBjKGEpe3JldHVybiEhYSYmKCEhYi5ub2RlLmlzQmxvY2soYSl8fChhLm5leHRTaWJsaW5nJiZhLm5leHRTaWJsaW5nLm5vZGVUeXBlPT1Ob2RlLlRFWFRfTk9ERSYmMD09PWEubmV4dFNpYmxpbmcudGV4dENvbnRlbnQucmVwbGFjZSgvXFxcXHUyMDBiL2csXFxcIlxcXCIpLmxlbmd0aD9jKGEubmV4dFNpYmxpbmcpOiFhLm5leHRTaWJsaW5nJiZjKGEucGFyZW50Tm9kZSkpKX1mdW5jdGlvbiBkKGEpe3JldHVybiEhYSYmKCEhYi5ub2RlLmlzQmxvY2soYSl8fChhLnByZXZpb3VzU2libGluZyYmYS5wcmV2aW91c1NpYmxpbmcubm9kZVR5cGU9PU5vZGUuVEVYVF9OT0RFJiYwPT09YS5wcmV2aW91c1NpYmxpbmcudGV4dENvbnRlbnQucmVwbGFjZSgvXFxcXHUyMDBiL2csXFxcIlxcXCIpLmxlbmd0aD9kKGEucHJldmlvdXNTaWJsaW5nKTohYS5wcmV2aW91c1NpYmxpbmcmJmQoYS5wYXJlbnROb2RlKSkpfWZ1bmN0aW9uIGUoYSxjKXtyZXR1cm4hIWEmJihhIT1iLiR3cC5nZXQoMCkmJihhLnByZXZpb3VzU2libGluZyYmYS5wcmV2aW91c1NpYmxpbmcubm9kZVR5cGU9PU5vZGUuVEVYVF9OT0RFJiYwPT09YS5wcmV2aW91c1NpYmxpbmcudGV4dENvbnRlbnQucmVwbGFjZSgvXFxcXHUyMDBiL2csXFxcIlxcXCIpLmxlbmd0aD9lKGEucHJldmlvdXNTaWJsaW5nLGMpOiFhLnByZXZpb3VzU2libGluZyYmKGEucGFyZW50Tm9kZT09Y3x8ZShhLnBhcmVudE5vZGUsYykpKSl9ZnVuY3Rpb24gZihhLGMpe3JldHVybiEhYSYmKGEhPWIuJHdwLmdldCgwKSYmKGEubmV4dFNpYmxpbmcmJmEubmV4dFNpYmxpbmcubm9kZVR5cGU9PU5vZGUuVEVYVF9OT0RFJiYwPT09YS5uZXh0U2libGluZy50ZXh0Q29udGVudC5yZXBsYWNlKC9cXFxcdTIwMGIvZyxcXFwiXFxcIikubGVuZ3RoP2YoYS5uZXh0U2libGluZyxjKTohYS5uZXh0U2libGluZyYmKGEucGFyZW50Tm9kZT09Y3x8ZihhLnBhcmVudE5vZGUsYykpKSl9ZnVuY3Rpb24gZyhjKXtyZXR1cm4gYShjKS5wYXJlbnRzVW50aWwoYi4kZWwsXFxcIkxJXFxcIikubGVuZ3RoPjAmJjA9PT1hKGMpLnBhcmVudHNVbnRpbChcXFwiTElcXFwiLFxcXCJUQUJMRVxcXCIpLmxlbmd0aH1mdW5jdGlvbiBoKGMpe3ZhciBkPWEoYykucGFyZW50c1VudGlsKGIuJGVsLFxcXCJCTE9DS1FVT1RFXFxcIikubGVuZ3RoPjAsZT1iLm5vZGUuZGVlcGVzdFBhcmVudChjLFtdLCFkKTtpZihlJiZcXFwiQkxPQ0tRVU9URVxcXCI9PWUudGFnTmFtZSl7dmFyIGY9Yi5ub2RlLmRlZXBlc3RQYXJlbnQoYyxbYShjKS5wYXJlbnRzVW50aWwoYi4kZWwsXFxcIkJMT0NLUVVPVEVcXFwiKS5nZXQoMCldKTtmJiZmLnByZXZpb3VzU2libGluZyYmKGU9Zil9aWYobnVsbCE9PWUpe3ZhciBnLGg9ZS5wcmV2aW91c1NpYmxpbmc7aWYoYi5ub2RlLmlzQmxvY2soZSkmJmIubm9kZS5pc0VkaXRhYmxlKGUpJiZoJiZhLkZFLk5PX0RFTEVURV9UQUdTLmluZGV4T2YoaC50YWdOYW1lKTwwKWlmKGIubm9kZS5pc0RlbGV0YWJsZShoKSlhKGgpLnJlbW92ZSgpLGEoYykucmVwbGFjZVdpdGgoYS5GRS5NQVJLRVJTKTtlbHNlIGlmKGIubm9kZS5pc0VkaXRhYmxlKGgpKWlmKGIubm9kZS5pc0Jsb2NrKGgpKWlmKGIubm9kZS5pc0VtcHR5KGgpJiYhYi5ub2RlLmlzTGlzdChoKSlhKGgpLnJlbW92ZSgpO2Vsc2V7aWYoYi5ub2RlLmlzTGlzdChoKSYmKGg9YShoKS5maW5kKFxcXCJsaTpsYXN0XFxcIikuZ2V0KDApKSxnPWIubm9kZS5jb250ZW50cyhoKSxnLmxlbmd0aCYmXFxcIkJSXFxcIj09Z1tnLmxlbmd0aC0xXS50YWdOYW1lJiZhKGdbZy5sZW5ndGgtMV0pLnJlbW92ZSgpLFxcXCJCTE9DS1FVT1RFXFxcIj09aC50YWdOYW1lJiZcXFwiQkxPQ0tRVU9URVxcXCIhPWUudGFnTmFtZSlmb3IoZz1iLm5vZGUuY29udGVudHMoaCk7Zy5sZW5ndGgmJmIubm9kZS5pc0Jsb2NrKGdbZy5sZW5ndGgtMV0pOyloPWdbZy5sZW5ndGgtMV0sZz1iLm5vZGUuY29udGVudHMoaCk7ZWxzZSBpZihcXFwiQkxPQ0tRVU9URVxcXCIhPWgudGFnTmFtZSYmXFxcIkJMT0NLUVVPVEVcXFwiPT1lLnRhZ05hbWUpZm9yKGc9Yi5ub2RlLmNvbnRlbnRzKGUpO2cubGVuZ3RoJiZiLm5vZGUuaXNCbG9jayhnWzBdKTspZT1nWzBdLGc9Yi5ub2RlLmNvbnRlbnRzKGUpO2EoYykucmVwbGFjZVdpdGgoYS5GRS5NQVJLRVJTKSxhKGgpLmFwcGVuZChiLm5vZGUuaXNFbXB0eShlKT9hLkZFLk1BUktFUlM6ZS5pbm5lckhUTUwpLGEoZSkucmVtb3ZlKCl9ZWxzZSBhKGMpLnJlcGxhY2VXaXRoKGEuRkUuTUFSS0VSUyksXFxcIkJMT0NLUVVPVEVcXFwiPT1lLnRhZ05hbWUmJmgubm9kZVR5cGU9PU5vZGUuRUxFTUVOVF9OT0RFP2EoaCkucmVtb3ZlKCk6KGEoaCkuYWZ0ZXIoYi5ub2RlLmlzRW1wdHkoZSk/XFxcIlxcXCI6YShlKS5odG1sKCkpLGEoZSkucmVtb3ZlKCksXFxcIkJSXFxcIj09aC50YWdOYW1lJiZhKGgpLnJlbW92ZSgpKX19ZnVuY3Rpb24gaShjKXtmb3IodmFyIGQ9YzshZC5wcmV2aW91c1NpYmxpbmc7KWlmKGQ9ZC5wYXJlbnROb2RlLGIubm9kZS5pc0VsZW1lbnQoZCkpcmV0dXJuITE7ZD1kLnByZXZpb3VzU2libGluZzt2YXIgZTtpZighYi5ub2RlLmlzQmxvY2soZCkmJmIubm9kZS5pc0VkaXRhYmxlKGQpKXtmb3IoZT1iLm5vZGUuY29udGVudHMoZCk7ZC5ub2RlVHlwZSE9Tm9kZS5URVhUX05PREUmJiFiLm5vZGUuaXNEZWxldGFibGUoZCkmJmUubGVuZ3RoJiZiLm5vZGUuaXNFZGl0YWJsZShkKTspZD1lW2UubGVuZ3RoLTFdLGU9Yi5ub2RlLmNvbnRlbnRzKGQpO2lmKGQubm9kZVR5cGU9PU5vZGUuVEVYVF9OT0RFKXtpZihiLmhlbHBlcnMuaXNJT1MoKSlyZXR1cm4hMDt2YXIgZj1kLnRleHRDb250ZW50LGc9Zi5sZW5ndGgtMTtpZihiLm9wdHMudGFiU3BhY2VzJiZmLmxlbmd0aD49Yi5vcHRzLnRhYlNwYWNlcyl7dmFyIGg9Zi5zdWJzdHIoZi5sZW5ndGgtYi5vcHRzLnRhYlNwYWNlcyxmLmxlbmd0aC0xKTswPT09aC5yZXBsYWNlKC8gL2csXFxcIlxcXCIpLnJlcGxhY2UobmV3IFJlZ0V4cChhLkZFLlVOSUNPREVfTkJTUCxcXFwiZ1xcXCIpLFxcXCJcXFwiKS5sZW5ndGgmJihnPWYubGVuZ3RoLWIub3B0cy50YWJTcGFjZXMpfWQudGV4dENvbnRlbnQ9Zi5zdWJzdHJpbmcoMCxnKSxkLnRleHRDb250ZW50Lmxlbmd0aCYmNTUzNTc9PWQudGV4dENvbnRlbnQuY2hhckNvZGVBdChkLnRleHRDb250ZW50Lmxlbmd0aC0xKSYmKGQudGV4dENvbnRlbnQ9ZC50ZXh0Q29udGVudC5zdWJzdHIoMCxkLnRleHRDb250ZW50Lmxlbmd0aC0xKSk7dmFyIGk9Zi5sZW5ndGghPWQudGV4dENvbnRlbnQubGVuZ3RoOzA9PT1kLnRleHRDb250ZW50Lmxlbmd0aD9pJiZiLm9wdHMua2VlcEZvcm1hdE9uRGVsZXRlP2EoZCkuYWZ0ZXIoYS5GRS5JTlZJU0lCTEVfU1BBQ0UrYS5GRS5NQVJLRVJTKToyIT1kLnBhcmVudE5vZGUuY2hpbGROb2Rlcy5sZW5ndGh8fGQucGFyZW50Tm9kZSE9Yy5wYXJlbnROb2RlfHxiLm5vZGUuaXNCbG9jayhkLnBhcmVudE5vZGUpfHxiLm5vZGUuaXNFbGVtZW50KGQucGFyZW50Tm9kZSk/KGEoZCkuYWZ0ZXIoYS5GRS5NQVJLRVJTKSxiLm5vZGUuaXNFbGVtZW50KGQucGFyZW50Tm9kZSkmJiFjLm5leHRTaWJsaW5nJiZkLnByZXZpb3VzU2libGluZyYmXFxcIkJSXFxcIj09ZC5wcmV2aW91c1NpYmxpbmcudGFnTmFtZSYmYShjKS5hZnRlcihcXFwiPGJyPlxcXCIpLGQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChkKSk6KGEoZC5wYXJlbnROb2RlKS5hZnRlcihhLkZFLk1BUktFUlMpLGEoZC5wYXJlbnROb2RlKS5yZW1vdmUoKSk6YShkKS5hZnRlcihhLkZFLk1BUktFUlMpfWVsc2UgYi5ub2RlLmlzRGVsZXRhYmxlKGQpPyhhKGQpLmFmdGVyKGEuRkUuTUFSS0VSUyksYShkKS5yZW1vdmUoKSk6Yi5ldmVudHMudHJpZ2dlcihcXFwibm9kZS5yZW1vdmVcXFwiLFthKGQpXSkhPT0hMSYmKGEoZCkuYWZ0ZXIoYS5GRS5NQVJLRVJTKSxhKGQpLnJlbW92ZSgpKX1lbHNlIGlmKGEuRkUuTk9fREVMRVRFX1RBR1MuaW5kZXhPZihkLnRhZ05hbWUpPDAmJihiLm5vZGUuaXNFZGl0YWJsZShkKXx8Yi5ub2RlLmlzRGVsZXRhYmxlKGQpKSlpZihiLm5vZGUuaXNEZWxldGFibGUoZCkpYShjKS5yZXBsYWNlV2l0aChhLkZFLk1BUktFUlMpLGEoZCkucmVtb3ZlKCk7ZWxzZSBpZihiLm5vZGUuaXNFbXB0eShkKSYmIWIubm9kZS5pc0xpc3QoZCkpYShkKS5yZW1vdmUoKSxhKGMpLnJlcGxhY2VXaXRoKGEuRkUuTUFSS0VSUyk7ZWxzZXtmb3IoYi5ub2RlLmlzTGlzdChkKSYmKGQ9YShkKS5maW5kKFxcXCJsaTpsYXN0XFxcIikuZ2V0KDApKSxlPWIubm9kZS5jb250ZW50cyhkKSxlJiZcXFwiQlJcXFwiPT1lW2UubGVuZ3RoLTFdLnRhZ05hbWUmJmEoZVtlLmxlbmd0aC0xXSkucmVtb3ZlKCksZT1iLm5vZGUuY29udGVudHMoZCk7ZSYmYi5ub2RlLmlzQmxvY2soZVtlLmxlbmd0aC0xXSk7KWQ9ZVtlLmxlbmd0aC0xXSxlPWIubm9kZS5jb250ZW50cyhkKTthKGQpLmFwcGVuZChhLkZFLk1BUktFUlMpO2Zvcih2YXIgaj1jOyFqLnByZXZpb3VzU2libGluZzspaj1qLnBhcmVudE5vZGU7Zm9yKDtqJiZcXFwiQlJcXFwiIT09ai50YWdOYW1lJiYhYi5ub2RlLmlzQmxvY2soaik7KXt2YXIgaz1qO2o9ai5uZXh0U2libGluZyxhKGQpLmFwcGVuZChrKX1qJiZcXFwiQlJcXFwiPT1qLnRhZ05hbWUmJmEoaikucmVtb3ZlKCksYShjKS5yZW1vdmUoKX1lbHNlIGMubmV4dFNpYmxpbmcmJlxcXCJCUlxcXCI9PWMubmV4dFNpYmxpbmcudGFnTmFtZSYmYShjLm5leHRTaWJsaW5nKS5yZW1vdmUoKX1mdW5jdGlvbiBqKCl7dmFyIGY9ITEsaj1iLm1hcmtlcnMuaW5zZXJ0KCk7aWYoIWopcmV0dXJuITA7Zm9yKHZhciBrPWoucGFyZW50Tm9kZTtrJiYhYi5ub2RlLmlzRWxlbWVudChrKTspe2lmKFxcXCJmYWxzZVxcXCI9PT1rLmdldEF0dHJpYnV0ZShcXFwiY29udGVudGVkaXRhYmxlXFxcIikpcmV0dXJuIGEoaikucmVwbGFjZVdpdGgoYS5GRS5NQVJLRVJTKSxiLnNlbGVjdGlvbi5yZXN0b3JlKCksITE7aWYoXFxcInRydWVcXFwiPT09ay5nZXRBdHRyaWJ1dGUoXFxcImNvbnRlbnRlZGl0YWJsZVxcXCIpKWJyZWFrO2s9ay5wYXJlbnROb2RlfWIuZWwubm9ybWFsaXplKCk7dmFyIGw9ai5wcmV2aW91c1NpYmxpbmc7aWYobCl7dmFyIG09bC50ZXh0Q29udGVudDttJiZtLmxlbmd0aCYmODIwMz09bS5jaGFyQ29kZUF0KG0ubGVuZ3RoLTEpJiYoMT09bS5sZW5ndGg/YShsKS5yZW1vdmUoKToobC50ZXh0Q29udGVudD1sLnRleHRDb250ZW50LnN1YnN0cigwLG0ubGVuZ3RoLTEpLGwudGV4dENvbnRlbnQubGVuZ3RoJiY1NTM1Nz09bC50ZXh0Q29udGVudC5jaGFyQ29kZUF0KGwudGV4dENvbnRlbnQubGVuZ3RoLTEpJiYobC50ZXh0Q29udGVudD1sLnRleHRDb250ZW50LnN1YnN0cigwLGwudGV4dENvbnRlbnQubGVuZ3RoLTEpKSkpfXJldHVybiBjKGopP2Y9aShqKTpkKGopP2coaikmJmUoaixhKGopLnBhcmVudHMoXFxcImxpOmZpcnN0XFxcIikuZ2V0KDApKT9iLmN1cnNvckxpc3RzLl9iYWNrc3BhY2Uoaik6aChqKTpmPWkoaiksYShqKS5yZW1vdmUoKSxuKCksYi5odG1sLmZpbGxFbXB0eUJsb2NrcyghMCksYi5vcHRzLmh0bWxVbnRvdWNoZWR8fChiLmh0bWwuY2xlYW5FbXB0eVRhZ3MoKSxiLmNsZWFuLnF1b3RlcygpLGIuY2xlYW4ubGlzdHMoKSksYi5zcGFjZXMubm9ybWFsaXplQXJvdW5kQ3Vyc29yKCksYi5zZWxlY3Rpb24ucmVzdG9yZSgpLGZ9ZnVuY3Rpb24gayhjKXt2YXIgZD1hKGMpLnBhcmVudHNVbnRpbChiLiRlbCxcXFwiQkxPQ0tRVU9URVxcXCIpLmxlbmd0aD4wLGU9Yi5ub2RlLmRlZXBlc3RQYXJlbnQoYyxbXSwhZCk7aWYoZSYmXFxcIkJMT0NLUVVPVEVcXFwiPT1lLnRhZ05hbWUpe3ZhciBmPWIubm9kZS5kZWVwZXN0UGFyZW50KGMsW2EoYykucGFyZW50c1VudGlsKGIuJGVsLFxcXCJCTE9DS1FVT1RFXFxcIikuZ2V0KDApXSk7ZiYmZi5uZXh0U2libGluZyYmKGU9Zil9aWYobnVsbCE9PWUpe3ZhciBnLGg9ZS5uZXh0U2libGluZztpZihiLm5vZGUuaXNCbG9jayhlKSYmKGIubm9kZS5pc0VkaXRhYmxlKGUpfHxiLm5vZGUuaXNEZWxldGFibGUoZSkpJiZoJiZhLkZFLk5PX0RFTEVURV9UQUdTLmluZGV4T2YoaC50YWdOYW1lKTwwKWlmKGIubm9kZS5pc0RlbGV0YWJsZShoKSlhKGgpLnJlbW92ZSgpLGEoYykucmVwbGFjZVdpdGgoYS5GRS5NQVJLRVJTKTtlbHNlIGlmKGIubm9kZS5pc0Jsb2NrKGgpJiZiLm5vZGUuaXNFZGl0YWJsZShoKSlpZihiLm5vZGUuaXNMaXN0KGgpKWlmKGIubm9kZS5pc0VtcHR5KGUsITApKWEoZSkucmVtb3ZlKCksYShoKS5maW5kKFxcXCJsaTpmaXJzdFxcXCIpLnByZXBlbmQoYS5GRS5NQVJLRVJTKTtlbHNle3ZhciBpPWEoaCkuZmluZChcXFwibGk6Zmlyc3RcXFwiKTtcXFwiQkxPQ0tRVU9URVxcXCI9PWUudGFnTmFtZSYmKGc9Yi5ub2RlLmNvbnRlbnRzKGUpLGcubGVuZ3RoJiZiLm5vZGUuaXNCbG9jayhnW2cubGVuZ3RoLTFdKSYmKGU9Z1tnLmxlbmd0aC0xXSkpLDA9PT1pLmZpbmQoXFxcInVsLCBvbFxcXCIpLmxlbmd0aCYmKGEoYykucmVwbGFjZVdpdGgoYS5GRS5NQVJLRVJTKSxpLmZpbmQoYi5odG1sLmJsb2NrVGFnc1F1ZXJ5KCkpLm5vdChcXFwib2wsIHVsLCB0YWJsZVxcXCIpLmVhY2goZnVuY3Rpb24oKXt0aGlzLnBhcmVudE5vZGU9PWkuZ2V0KDApJiZhKHRoaXMpLnJlcGxhY2VXaXRoKGEodGhpcykuaHRtbCgpKyhiLm5vZGUuaXNFbXB0eSh0aGlzKT9cXFwiXFxcIjpcXFwiPGJyPlxcXCIpKX0pLGEoZSkuYXBwZW5kKGIubm9kZS5jb250ZW50cyhpLmdldCgwKSkpLGkucmVtb3ZlKCksMD09PWEoaCkuZmluZChcXFwibGlcXFwiKS5sZW5ndGgmJmEoaCkucmVtb3ZlKCkpfWVsc2V7aWYoZz1iLm5vZGUuY29udGVudHMoaCksZy5sZW5ndGgmJlxcXCJCUlxcXCI9PWdbMF0udGFnTmFtZSYmYShnWzBdKS5yZW1vdmUoKSxcXFwiQkxPQ0tRVU9URVxcXCIhPWgudGFnTmFtZSYmXFxcIkJMT0NLUVVPVEVcXFwiPT1lLnRhZ05hbWUpZm9yKGc9Yi5ub2RlLmNvbnRlbnRzKGUpO2cubGVuZ3RoJiZiLm5vZGUuaXNCbG9jayhnW2cubGVuZ3RoLTFdKTspZT1nW2cubGVuZ3RoLTFdLGc9Yi5ub2RlLmNvbnRlbnRzKGUpO2Vsc2UgaWYoXFxcIkJMT0NLUVVPVEVcXFwiPT1oLnRhZ05hbWUmJlxcXCJCTE9DS1FVT1RFXFxcIiE9ZS50YWdOYW1lKWZvcihnPWIubm9kZS5jb250ZW50cyhoKTtnLmxlbmd0aCYmYi5ub2RlLmlzQmxvY2soZ1swXSk7KWg9Z1swXSxnPWIubm9kZS5jb250ZW50cyhoKTthKGMpLnJlcGxhY2VXaXRoKGEuRkUuTUFSS0VSUyksYShlKS5hcHBlbmQoaC5pbm5lckhUTUwpLGEoaCkucmVtb3ZlKCl9ZWxzZXtmb3IoYShjKS5yZXBsYWNlV2l0aChhLkZFLk1BUktFUlMpO2gmJlxcXCJCUlxcXCIhPT1oLnRhZ05hbWUmJiFiLm5vZGUuaXNCbG9jayhoKSYmYi5ub2RlLmlzRWRpdGFibGUoaCk7KXt2YXIgaj1oO2g9aC5uZXh0U2libGluZyxhKGUpLmFwcGVuZChqKX1oJiZcXFwiQlJcXFwiPT1oLnRhZ05hbWUmJmIubm9kZS5pc0VkaXRhYmxlKGgpJiZhKGgpLnJlbW92ZSgpfX19ZnVuY3Rpb24gbChkKXtmb3IodmFyIGU9ZDshZS5uZXh0U2libGluZzspaWYoZT1lLnBhcmVudE5vZGUsYi5ub2RlLmlzRWxlbWVudChlKSlyZXR1cm4hMTtpZihlPWUubmV4dFNpYmxpbmcsXFxcIkJSXFxcIj09ZS50YWdOYW1lJiZiLm5vZGUuaXNFZGl0YWJsZShlKSlpZihlLm5leHRTaWJsaW5nKXtpZihiLm5vZGUuaXNCbG9jayhlLm5leHRTaWJsaW5nKSYmYi5ub2RlLmlzRWRpdGFibGUoZS5uZXh0U2libGluZykpe2lmKCEoYS5GRS5OT19ERUxFVEVfVEFHUy5pbmRleE9mKGUubmV4dFNpYmxpbmcudGFnTmFtZSk8MCkpcmV0dXJuIHZvaWQgYShlKS5yZW1vdmUoKTtlPWUubmV4dFNpYmxpbmcsYShlLnByZXZpb3VzU2libGluZykucmVtb3ZlKCl9fWVsc2UgaWYoYyhlKSl7aWYoZyhkKSliLmN1cnNvckxpc3RzLl9kZWwoZCk7ZWxzZXt2YXIgZj1iLm5vZGUuZGVlcGVzdFBhcmVudChlKTtmJiYoYShlKS5yZW1vdmUoKSxrKGQpKX1yZXR1cm59dmFyIGg7aWYoIWIubm9kZS5pc0Jsb2NrKGUpJiZiLm5vZGUuaXNFZGl0YWJsZShlKSl7Zm9yKGg9Yi5ub2RlLmNvbnRlbnRzKGUpO2Uubm9kZVR5cGUhPU5vZGUuVEVYVF9OT0RFJiZoLmxlbmd0aCYmIWIubm9kZS5pc0RlbGV0YWJsZShlKSYmYi5ub2RlLmlzRWRpdGFibGUoZSk7KWU9aFswXSxoPWIubm9kZS5jb250ZW50cyhlKTtlLm5vZGVUeXBlPT1Ob2RlLlRFWFRfTk9ERT8oYShlKS5iZWZvcmUoYS5GRS5NQVJLRVJTKSxlLnRleHRDb250ZW50Lmxlbmd0aCYmNTUzNTc9PWUudGV4dENvbnRlbnQuY2hhckNvZGVBdCgwKT9lLnRleHRDb250ZW50PWUudGV4dENvbnRlbnQuc3Vic3RyaW5nKDIsZS50ZXh0Q29udGVudC5sZW5ndGgpOmUudGV4dENvbnRlbnQ9ZS50ZXh0Q29udGVudC5zdWJzdHJpbmcoMSxlLnRleHRDb250ZW50Lmxlbmd0aCkpOmIubm9kZS5pc0RlbGV0YWJsZShlKT8oYShlKS5iZWZvcmUoYS5GRS5NQVJLRVJTKSxhKGUpLnJlbW92ZSgpKTpiLmV2ZW50cy50cmlnZ2VyKFxcXCJub2RlLnJlbW92ZVxcXCIsW2EoZSldKSE9PSExJiYoYShlKS5iZWZvcmUoYS5GRS5NQVJLRVJTKSxhKGUpLnJlbW92ZSgpKSxhKGQpLnJlbW92ZSgpfWVsc2UgaWYoYS5GRS5OT19ERUxFVEVfVEFHUy5pbmRleE9mKGUudGFnTmFtZSk8MCYmKGIubm9kZS5pc0VkaXRhYmxlKGUpfHxiLm5vZGUuaXNEZWxldGFibGUoZSkpKWlmKGIubm9kZS5pc0RlbGV0YWJsZShlKSlhKGQpLnJlcGxhY2VXaXRoKGEuRkUuTUFSS0VSUyksYShlKS5yZW1vdmUoKTtlbHNlIGlmKGIubm9kZS5pc0xpc3QoZSkpZC5wcmV2aW91c1NpYmxpbmc/KGEoZSkuZmluZChcXFwibGk6Zmlyc3RcXFwiKS5wcmVwZW5kKGQpLGIuY3Vyc29yTGlzdHMuX2JhY2tzcGFjZShkKSk6KGEoZSkuZmluZChcXFwibGk6Zmlyc3RcXFwiKS5wcmVwZW5kKGEuRkUuTUFSS0VSUyksYShkKS5yZW1vdmUoKSk7ZWxzZSBpZihoPWIubm9kZS5jb250ZW50cyhlKSxoJiZcXFwiQlJcXFwiPT1oWzBdLnRhZ05hbWUmJmEoaFswXSkucmVtb3ZlKCksaCYmXFxcIkJMT0NLUVVPVEVcXFwiPT1lLnRhZ05hbWUpe3ZhciBpPWhbMF07Zm9yKGEoZCkuYmVmb3JlKGEuRkUuTUFSS0VSUyk7aSYmXFxcIkJSXFxcIiE9aS50YWdOYW1lOyl7dmFyIGo9aTtpPWkubmV4dFNpYmxpbmcsYShkKS5iZWZvcmUoail9aSYmXFxcIkJSXFxcIj09aS50YWdOYW1lJiZhKGkpLnJlbW92ZSgpfWVsc2UgYShkKS5hZnRlcihhKGUpLmh0bWwoKSkuYWZ0ZXIoYS5GRS5NQVJLRVJTKSxhKGUpLnJlbW92ZSgpfWZ1bmN0aW9uIG0oKXt2YXIgZT1iLm1hcmtlcnMuaW5zZXJ0KCk7aWYoIWUpcmV0dXJuITE7aWYoYi5lbC5ub3JtYWxpemUoKSxjKGUpKWlmKGcoZSkpaWYoMD09PWEoZSkucGFyZW50cyhcXFwibGk6Zmlyc3RcXFwiKS5maW5kKFxcXCJ1bCwgb2xcXFwiKS5sZW5ndGgpYi5jdXJzb3JMaXN0cy5fZGVsKGUpO2Vsc2V7dmFyIGY9YShlKS5wYXJlbnRzKFxcXCJsaTpmaXJzdFxcXCIpLmZpbmQoXFxcInVsOmZpcnN0LCBvbDpmaXJzdFxcXCIpLmZpbmQoXFxcImxpOmZpcnN0XFxcIik7Zj1mLmZpbmQoYi5odG1sLmJsb2NrVGFnc1F1ZXJ5KCkpLmdldCgtMSl8fGYsZi5wcmVwZW5kKGUpLGIuY3Vyc29yTGlzdHMuX2JhY2tzcGFjZShlKX1lbHNlIGsoZSk7ZWxzZSBsKGQoZSk/ZTplKTthKGUpLnJlbW92ZSgpLG4oKSxiLmh0bWwuZmlsbEVtcHR5QmxvY2tzKCEwKSxiLm9wdHMuaHRtbFVudG91Y2hlZHx8KGIuaHRtbC5jbGVhbkVtcHR5VGFncygpLGIuY2xlYW4ucXVvdGVzKCksYi5jbGVhbi5saXN0cygpKSxiLnNwYWNlcy5ub3JtYWxpemVBcm91bmRDdXJzb3IoKSxiLnNlbGVjdGlvbi5yZXN0b3JlKCl9ZnVuY3Rpb24gbigpe2Zvcih2YXIgYT1iLmVsLnF1ZXJ5U2VsZWN0b3JBbGwoXFxcImJsb2NrcXVvdGU6ZW1wdHlcXFwiKSxjPTA7YzxhLmxlbmd0aDtjKyspYVtjXS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGFbY10pfWZ1bmN0aW9uIG8oKXtiLiRlbC5maW5kKFxcXCIuZnItdG8tcmVtb3ZlXFxcIikuZWFjaChmdW5jdGlvbigpe2Zvcih2YXIgYz1iLm5vZGUuY29udGVudHModGhpcyksZD0wO2Q8Yy5sZW5ndGg7ZCsrKWNbZF0ubm9kZVR5cGU9PU5vZGUuVEVYVF9OT0RFJiYoY1tkXS50ZXh0Q29udGVudD1jW2RdLnRleHRDb250ZW50LnJlcGxhY2UoL1xcXFx1MjAwQi9nLFxcXCJcXFwiKSk7YSh0aGlzKS5yZXBsYWNlV2l0aCh0aGlzLmlubmVySFRNTCl9KX1mdW5jdGlvbiBwKGMsZCxlKXt2YXIgZyxoPWIubm9kZS5kZWVwZXN0UGFyZW50KGMsW10sIWUpO2lmKGgmJlxcXCJCTE9DS1FVT1RFXFxcIj09aC50YWdOYW1lKXJldHVybiBmKGMsaCk/KGc9Yi5odG1sLmRlZmF1bHRUYWcoKSxnP2EoaCkuYWZ0ZXIoXFxcIjxcXFwiK2crXFxcIj5cXFwiK2EuRkUuTUFSS0VSUytcXFwiPGJyPjwvXFxcIitnK1xcXCI+XFxcIik6YShoKS5hZnRlcihhLkZFLk1BUktFUlMrXFxcIjxicj5cXFwiKSxhKGMpLnJlbW92ZSgpLCExKToocihjLGQsZSksITEpO2lmKG51bGw9PWgpZz1iLmh0bWwuZGVmYXVsdFRhZygpLGcmJmIubm9kZS5pc0VsZW1lbnQoYy5wYXJlbnROb2RlKT9hKGMpLnJlcGxhY2VXaXRoKFxcXCI8XFxcIitnK1xcXCI+XFxcIithLkZFLk1BUktFUlMrXFxcIjxicj48L1xcXCIrZytcXFwiPlxcXCIpOmEoYykucmVwbGFjZVdpdGgoKGIubm9kZS5pc0VtcHR5KGMucGFyZW50Tm9kZSwhMCk/XFxcIlxcXCI6XFxcIjxici8+XFxcIikrYS5GRS5NQVJLRVJTK1xcXCI8YnIvPlxcXCIpO2Vsc2V7dmFyIGk9YyxqPVxcXCJcXFwiO2Iubm9kZS5pc0Jsb2NrKGgpJiYhZHx8KGo9XFxcIjxici8+XFxcIik7dmFyIGs9XFxcIlxcXCIsbD1cXFwiXFxcIjtnPWIuaHRtbC5kZWZhdWx0VGFnKCk7dmFyIG09XFxcIlxcXCIsbj1cXFwiXFxcIjtnJiZiLm5vZGUuaXNCbG9jayhoKSYmKG09XFxcIjxcXFwiK2crXFxcIj5cXFwiLG49XFxcIjwvXFxcIitnK1xcXCI+XFxcIixoLnRhZ05hbWU9PWcudG9VcHBlckNhc2UoKSYmKG09Yi5ub2RlLm9wZW5UYWdTdHJpbmcoYShoKS5jbG9uZSgpLnJlbW92ZUF0dHIoXFxcImlkXFxcIikuZ2V0KDApKSkpO2RvIGlmKGk9aS5wYXJlbnROb2RlLCFkfHxpIT1ofHxkJiYhYi5ub2RlLmlzQmxvY2soaCkpaWYoays9Yi5ub2RlLmNsb3NlVGFnU3RyaW5nKGkpLGk9PWgmJmIubm9kZS5pc0Jsb2NrKGgpKWw9bStsO2Vsc2V7dmFyIG89XFxcIkFcXFwiPT1pLnRhZ05hbWUmJmYoYyxpKT9cXFwiZnItdG8tcmVtb3ZlXFxcIjpcXFwiXFxcIjtsPWIubm9kZS5vcGVuVGFnU3RyaW5nKGEoaSkuY2xvbmUoKS5hZGRDbGFzcyhvKS5nZXQoMCkpK2x9d2hpbGUoaSE9aCk7aj1rK2orbCsoYy5wYXJlbnROb2RlPT1oJiZiLm5vZGUuaXNCbG9jayhoKT9cXFwiXFxcIjphLkZFLklOVklTSUJMRV9TUEFDRSkrYS5GRS5NQVJLRVJTLGIubm9kZS5pc0Jsb2NrKGgpJiYhYShoKS5maW5kKFxcXCIqOmxhc3RcXFwiKS5pcyhcXFwiYnJcXFwiKSYmYShoKS5hcHBlbmQoXFxcIjxici8+XFxcIiksYShjKS5hZnRlcignPHNwYW4gaWQ9XFxcImZyLWJyZWFrXFxcIj48L3NwYW4+JyksYShjKS5yZW1vdmUoKSxoLm5leHRTaWJsaW5nJiYhYi5ub2RlLmlzQmxvY2soaC5uZXh0U2libGluZyl8fGIubm9kZS5pc0Jsb2NrKGgpfHxhKGgpLmFmdGVyKFxcXCI8YnI+XFxcIik7dmFyIHA7cD0hZCYmYi5ub2RlLmlzQmxvY2soaCk/Yi5ub2RlLm9wZW5UYWdTdHJpbmcoaCkrYShoKS5odG1sKCkrbjpiLm5vZGUub3BlblRhZ1N0cmluZyhoKSthKGgpLmh0bWwoKStiLm5vZGUuY2xvc2VUYWdTdHJpbmcoaCkscD1wLnJlcGxhY2UoLzxzcGFuIGlkPVxcXCJmci1icmVha1xcXCI+PFxcXFwvc3Bhbj4vZyxqKSxhKGgpLnJlcGxhY2VXaXRoKHApfX1mdW5jdGlvbiBxKGMsZCxnKXt2YXIgaCxpPWIubm9kZS5kZWVwZXN0UGFyZW50KGMsW10sIWcpO2lmKGkmJlxcXCJUQUJMRVxcXCI9PWkudGFnTmFtZSlyZXR1cm4gYShpKS5maW5kKFxcXCJ0ZDpmaXJzdCwgdGg6Zmlyc3RcXFwiKS5wcmVwZW5kKGMpLHEoYyxkLGcpO2lmKGkmJlxcXCJCTE9DS1FVT1RFXFxcIj09aS50YWdOYW1lKXtpZihlKGMsaSkpcmV0dXJuIGg9Yi5odG1sLmRlZmF1bHRUYWcoKSxoP2EoaSkuYmVmb3JlKFxcXCI8XFxcIitoK1xcXCI+XFxcIithLkZFLk1BUktFUlMrXFxcIjxicj48L1xcXCIraCtcXFwiPlxcXCIpOmEoaSkuYmVmb3JlKGEuRkUuTUFSS0VSUytcXFwiPGJyPlxcXCIpLGEoYykucmVtb3ZlKCksITE7ZihjLGkpP3AoYyxkLCEwKTpyKGMsZCwhMCl9aWYobnVsbD09aSloPWIuaHRtbC5kZWZhdWx0VGFnKCksaCYmYi5ub2RlLmlzRWxlbWVudChjLnBhcmVudE5vZGUpP2EoYykucmVwbGFjZVdpdGgoXFxcIjxcXFwiK2grXFxcIj5cXFwiK2EuRkUuTUFSS0VSUytcXFwiPGJyPjwvXFxcIitoK1xcXCI+XFxcIik6YShjKS5yZXBsYWNlV2l0aChcXFwiPGJyPlxcXCIrYS5GRS5NQVJLRVJTKTtlbHNle2lmKGIubm9kZS5pc0Jsb2NrKGkpKWlmKGQpYShjKS5yZW1vdmUoKSxhKGkpLnByZXBlbmQoXFxcIjxicj5cXFwiK2EuRkUuTUFSS0VSUyk7ZWxzZXtpZihiLm5vZGUuaXNFbXB0eShpLCEwKSlyZXR1cm4gcChjLGQsZyk7YShpKS5iZWZvcmUoYi5ub2RlLm9wZW5UYWdTdHJpbmcoYShpKS5jbG9uZSgpLnJlbW92ZUF0dHIoXFxcImlkXFxcIikuZ2V0KDApKStcXFwiPGJyPlxcXCIrYi5ub2RlLmNsb3NlVGFnU3RyaW5nKGkpKX1lbHNlIGEoaSkuYmVmb3JlKFxcXCI8YnI+XFxcIik7YShjKS5yZW1vdmUoKX19ZnVuY3Rpb24gcihjLGQsZyl7dmFyIGg9Yi5ub2RlLmRlZXBlc3RQYXJlbnQoYyxbXSwhZyk7aWYobnVsbD09aCliLmh0bWwuZGVmYXVsdFRhZygpJiZjLnBhcmVudE5vZGU9PT1iLmVsP2EoYykucmVwbGFjZVdpdGgoXFxcIjxcXFwiK2IuaHRtbC5kZWZhdWx0VGFnKCkrXFxcIj5cXFwiK2EuRkUuTUFSS0VSUytcXFwiPGJyPjwvXFxcIitiLmh0bWwuZGVmYXVsdFRhZygpK1xcXCI+XFxcIik6KGMubmV4dFNpYmxpbmcmJiFiLm5vZGUuaXNCbG9jayhjLm5leHRTaWJsaW5nKXx8YShjKS5hZnRlcihcXFwiPGJyPlxcXCIpLGEoYykucmVwbGFjZVdpdGgoXFxcIjxicj5cXFwiK2EuRkUuTUFSS0VSUykpO2Vsc2V7dmFyIGk9YyxqPVxcXCJcXFwiO1xcXCJQUkVcXFwiPT1oLnRhZ05hbWUmJihkPSEwKSxiLm5vZGUuaXNCbG9jayhoKSYmIWR8fChqPVxcXCI8YnI+XFxcIik7dmFyIGs9XFxcIlxcXCIsbD1cXFwiXFxcIjtkb3t2YXIgbT1pO2lmKGk9aS5wYXJlbnROb2RlLFxcXCJCTE9DS1FVT1RFXFxcIj09aC50YWdOYW1lJiZiLm5vZGUuaXNFbXB0eShtKSYmIWIubm9kZS5oYXNDbGFzcyhtLFxcXCJmci1tYXJrZXJcXFwiKSYmYShtKS5maW5kKGMpLmxlbmd0aD4wJiZhKG0pLmFmdGVyKGMpLChcXFwiQkxPQ0tRVU9URVxcXCIhPWgudGFnTmFtZXx8IWYoYyxpKSYmIWUoYyxpKSkmJighZHx8aSE9aHx8ZCYmIWIubm9kZS5pc0Jsb2NrKGgpKSl7ays9Yi5ub2RlLmNsb3NlVGFnU3RyaW5nKGkpO3ZhciBuPVxcXCJBXFxcIj09aS50YWdOYW1lJiZmKGMsaSk/XFxcImZyLXRvLXJlbW92ZVxcXCI6XFxcIlxcXCI7bD1iLm5vZGUub3BlblRhZ1N0cmluZyhhKGkpLmNsb25lKCkuYWRkQ2xhc3MobikucmVtb3ZlQXR0cihcXFwiaWRcXFwiKS5nZXQoMCkpK2x9fXdoaWxlKGkhPWgpO3ZhciBvPWg9PWMucGFyZW50Tm9kZSYmYi5ub2RlLmlzQmxvY2soaCl8fGMubmV4dFNpYmxpbmc7aWYoXFxcIkJMT0NLUVVPVEVcXFwiPT1oLnRhZ05hbWUpe2MucHJldmlvdXNTaWJsaW5nJiZiLm5vZGUuaXNCbG9jayhjLnByZXZpb3VzU2libGluZykmJmMubmV4dFNpYmxpbmcmJlxcXCJCUlxcXCI9PWMubmV4dFNpYmxpbmcudGFnTmFtZSYmKGEoYy5uZXh0U2libGluZykuYWZ0ZXIoYyksYy5uZXh0U2libGluZyYmXFxcIkJSXFxcIj09Yy5uZXh0U2libGluZy50YWdOYW1lJiZhKGMubmV4dFNpYmxpbmcpLnJlbW92ZSgpKTt2YXIgcD1iLmh0bWwuZGVmYXVsdFRhZygpO2o9aytqKyhwP1xcXCI8XFxcIitwK1xcXCI+XFxcIjpcXFwiXFxcIikrYS5GRS5NQVJLRVJTK1xcXCI8YnI+XFxcIisocD9cXFwiPC9cXFwiK3ArXFxcIj5cXFwiOlxcXCJcXFwiKStsfWVsc2Ugaj1rK2orbCsobz9cXFwiXFxcIjphLkZFLklOVklTSUJMRV9TUEFDRSkrYS5GRS5NQVJLRVJTO2EoYykucmVwbGFjZVdpdGgoJzxzcGFuIGlkPVxcXCJmci1icmVha1xcXCI+PC9zcGFuPicpO3ZhciBxPWIubm9kZS5vcGVuVGFnU3RyaW5nKGgpK2EoaCkuaHRtbCgpK2Iubm9kZS5jbG9zZVRhZ1N0cmluZyhoKTtxPXEucmVwbGFjZSgvPHNwYW4gaWQ9XFxcImZyLWJyZWFrXFxcIj48XFxcXC9zcGFuPi9nLGopLGEoaCkucmVwbGFjZVdpdGgocSl9fWZ1bmN0aW9uIHMoZSl7dmFyIGY9Yi5tYXJrZXJzLmluc2VydCgpO2lmKCFmKXJldHVybiEwO2IuZWwubm9ybWFsaXplKCk7dmFyIGg9ITE7XFxuYShmKS5wYXJlbnRzVW50aWwoYi4kZWwsXFxcIkJMT0NLUVVPVEVcXFwiKS5sZW5ndGg+MCYmKGU9ITEsaD0hMCksYShmKS5wYXJlbnRzVW50aWwoYi4kZWwsXFxcIlRELCBUSFxcXCIpLmxlbmd0aCYmKGg9ITEpLGMoZik/IWcoZil8fGV8fGg/cChmLGUsaCk6Yi5jdXJzb3JMaXN0cy5fZW5kRW50ZXIoZik6ZChmKT8hZyhmKXx8ZXx8aD9xKGYsZSxoKTpiLmN1cnNvckxpc3RzLl9zdGFydEVudGVyKGYpOiFnKGYpfHxlfHxoP3IoZixlLGgpOmIuY3Vyc29yTGlzdHMuX21pZGRsZUVudGVyKGYpLG8oKSxiLm9wdHMuaHRtbFVudG91Y2hlZHx8KGIuaHRtbC5maWxsRW1wdHlCbG9ja3MoITApLGIuaHRtbC5jbGVhbkVtcHR5VGFncygpLGIuY2xlYW4ubGlzdHMoKSksYi5zcGFjZXMubm9ybWFsaXplQXJvdW5kQ3Vyc29yKCksYi5zZWxlY3Rpb24ucmVzdG9yZSgpfXJldHVybntlbnRlcjpzLGJhY2tzcGFjZTpqLGRlbDptLGlzQXRFbmQ6Zixpc0F0U3RhcnQ6ZX19LGEuRkUuRU5URVJfUD0wLGEuRkUuRU5URVJfRElWPTEsYS5GRS5FTlRFUl9CUj0yLGEuRkUuS0VZQ09ERT17QkFDS1NQQUNFOjgsVEFCOjksRU5URVI6MTMsU0hJRlQ6MTYsQ1RSTDoxNyxBTFQ6MTgsRVNDOjI3LFNQQUNFOjMyLEFSUk9XX0xFRlQ6MzcsQVJST1dfVVA6MzgsQVJST1dfUklHSFQ6MzksQVJST1dfRE9XTjo0MCxERUxFVEU6NDYsWkVSTzo0OCxPTkU6NDksVFdPOjUwLFRIUkVFOjUxLEZPVVI6NTIsRklWRTo1MyxTSVg6NTQsU0VWRU46NTUsRUlHSFQ6NTYsTklORTo1NyxGRl9TRU1JQ09MT046NTksRkZfRVFVQUxTOjYxLFFVRVNUSU9OX01BUks6NjMsQTo2NSxCOjY2LEM6NjcsRDo2OCxFOjY5LEY6NzAsRzo3MSxIOjcyLEk6NzMsSjo3NCxLOjc1LEw6NzYsTTo3NyxOOjc4LE86NzksUDo4MCxROjgxLFI6ODIsUzo4MyxUOjg0LFU6ODUsVjo4NixXOjg3LFg6ODgsWTo4OSxaOjkwLE1FVEE6OTEsTlVNX1pFUk86OTYsTlVNX09ORTo5NyxOVU1fVFdPOjk4LE5VTV9USFJFRTo5OSxOVU1fRk9VUjoxMDAsTlVNX0ZJVkU6MTAxLE5VTV9TSVg6MTAyLE5VTV9TRVZFTjoxMDMsTlVNX0VJR0hUOjEwNCxOVU1fTklORToxMDUsTlVNX01VTFRJUExZOjEwNixOVU1fUExVUzoxMDcsTlVNX01JTlVTOjEwOSxOVU1fUEVSSU9EOjExMCxOVU1fRElWSVNJT046MTExLEYxOjExMixGMjoxMTMsRjM6MTE0LEY0OjExNSxGNToxMTYsRjY6MTE3LEY3OjExOCxGODoxMTksRjk6MTIwLEYxMDoxMjEsRjExOjEyMixGMTI6MTIzLEZGX0hZUEhFTjoxNzMsU0VNSUNPTE9OOjE4NixEQVNIOjE4OSxFUVVBTFM6MTg3LENPTU1BOjE4OCxIWVBIRU46MTg5LFBFUklPRDoxOTAsU0xBU0g6MTkxLEFQT1NUUk9QSEU6MTkyLFRJTERFOjE5MixTSU5HTEVfUVVPVEU6MjIyLE9QRU5fU1FVQVJFX0JSQUNLRVQ6MjE5LEJBQ0tTTEFTSDoyMjAsQ0xPU0VfU1FVQVJFX0JSQUNLRVQ6MjIxfSxhLmV4dGVuZChhLkZFLkRFRkFVTFRTLHtlbnRlcjphLkZFLkVOVEVSX1AsbXVsdGlMaW5lOiEwLHRhYlNwYWNlczowfSksYS5GRS5NT0RVTEVTLmtleXM9ZnVuY3Rpb24oYil7ZnVuY3Rpb24gYyhhKXtiLm9wdHMubXVsdGlMaW5lP2IuaGVscGVycy5pc0lPUygpfHwoYS5wcmV2ZW50RGVmYXVsdCgpLGEuc3RvcFByb3BhZ2F0aW9uKCksYi5zZWxlY3Rpb24uaXNDb2xsYXBzZWQoKXx8Yi5zZWxlY3Rpb24ucmVtb3ZlKCksYi5jdXJzb3IuZW50ZXIoKSk6KGEucHJldmVudERlZmF1bHQoKSxhLnN0b3BQcm9wYWdhdGlvbigpKX1mdW5jdGlvbiBkKGEpe2EucHJldmVudERlZmF1bHQoKSxhLnN0b3BQcm9wYWdhdGlvbigpLGIub3B0cy5tdWx0aUxpbmUmJihiLnNlbGVjdGlvbi5pc0NvbGxhcHNlZCgpfHxiLnNlbGVjdGlvbi5yZW1vdmUoKSxiLmN1cnNvci5lbnRlcighMCkpfWZ1bmN0aW9uIGUoYSl7Yi5zZWxlY3Rpb24uaXNDb2xsYXBzZWQoKT9iLmN1cnNvci5iYWNrc3BhY2UoKXx8KGEucHJldmVudERlZmF1bHQoKSxhLnN0b3BQcm9wYWdhdGlvbigpLHo9ITEpOihhLnByZXZlbnREZWZhdWx0KCksYS5zdG9wUHJvcGFnYXRpb24oKSxiLnNlbGVjdGlvbi5yZW1vdmUoKSxiLmh0bWwuZmlsbEVtcHR5QmxvY2tzKCksej0hMSksYi5wbGFjZWhvbGRlci5yZWZyZXNoKCl9ZnVuY3Rpb24gZihhKXthLnByZXZlbnREZWZhdWx0KCksYS5zdG9wUHJvcGFnYXRpb24oKSxcXFwiXFxcIj09PWIuc2VsZWN0aW9uLnRleHQoKT9iLmN1cnNvci5kZWwoKTpiLnNlbGVjdGlvbi5yZW1vdmUoKSxiLnBsYWNlaG9sZGVyLnJlZnJlc2goKX1mdW5jdGlvbiBnKGMpe3ZhciBkPWIuc2VsZWN0aW9uLmVsZW1lbnQoKTtpZighYi5oZWxwZXJzLmlzTW9iaWxlKCkmJihiLmJyb3dzZXIubW96aWxsYXx8ZCYmXFxcIkFcXFwiPT1kLnRhZ05hbWUpKXtjLnByZXZlbnREZWZhdWx0KCksYy5zdG9wUHJvcGFnYXRpb24oKSxiLnNlbGVjdGlvbi5pc0NvbGxhcHNlZCgpfHxiLnNlbGVjdGlvbi5yZW1vdmUoKTt2YXIgZT1iLm1hcmtlcnMuaW5zZXJ0KCk7aWYoZSl7dmFyIGY9ZS5wcmV2aW91c1NpYmxpbmcsZz1lLm5leHRTaWJsaW5nOyFnJiZlLnBhcmVudE5vZGUmJlxcXCJBXFxcIj09ZS5wYXJlbnROb2RlLnRhZ05hbWU/KGUucGFyZW50Tm9kZS5pbnNlcnRBZGphY2VudEhUTUwoXFxcImFmdGVyZW5kXFxcIixcXFwiJm5ic3A7XFxcIithLkZFLk1BUktFUlMpLGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlKSk6KGYmJmYubm9kZVR5cGU9PU5vZGUuVEVYVF9OT0RFJiYxPT1mLnRleHRDb250ZW50Lmxlbmd0aCYmMTYwPT1mLnRleHRDb250ZW50LmNoYXJDb2RlQXQoMCk/Zi50ZXh0Q29udGVudD1mLnRleHRDb250ZW50K1xcXCIgXFxcIjplLmluc2VydEFkamFjZW50SFRNTChcXFwiYmVmb3JlYmVnaW5cXFwiLFxcXCImbmJzcDtcXFwiKSxlLm91dGVySFRNTD1hLkZFLk1BUktFUlMpLGIuc2VsZWN0aW9uLnJlc3RvcmUoKX19fWZ1bmN0aW9uIGgoKXtpZihiLmJyb3dzZXIubW96aWxsYSYmYi5zZWxlY3Rpb24uaXNDb2xsYXBzZWQoKSYmIUMpe3ZhciBhPWIuc2VsZWN0aW9uLnJhbmdlcygwKSxjPWEuc3RhcnRDb250YWluZXIsZD1hLnN0YXJ0T2Zmc2V0O2MmJmMubm9kZVR5cGU9PU5vZGUuVEVYVF9OT0RFJiZkPD1jLnRleHRDb250ZW50Lmxlbmd0aCYmZD4wJiYzMj09Yy50ZXh0Q29udGVudC5jaGFyQ29kZUF0KGQtMSkmJihiLnNlbGVjdGlvbi5zYXZlKCksYi5zcGFjZXMubm9ybWFsaXplKCksYi5zZWxlY3Rpb24ucmVzdG9yZSgpKX19ZnVuY3Rpb24gaSgpe2Iuc2VsZWN0aW9uLmlzRnVsbCgpJiZzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7dmFyIGM9Yi5odG1sLmRlZmF1bHRUYWcoKTtjP2IuJGVsLmh0bWwoXFxcIjxcXFwiK2MrXFxcIj5cXFwiK2EuRkUuTUFSS0VSUytcXFwiPGJyLz48L1xcXCIrYytcXFwiPlxcXCIpOmIuJGVsLmh0bWwoYS5GRS5NQVJLRVJTK1xcXCI8YnIvPlxcXCIpLGIuc2VsZWN0aW9uLnJlc3RvcmUoKSxiLnBsYWNlaG9sZGVyLnJlZnJlc2goKSxiLmJ1dHRvbi5idWxrUmVmcmVzaCgpLGIudW5kby5zYXZlU3RlcCgpfSwwKX1mdW5jdGlvbiBqKGEpe2lmKGIub3B0cy50YWJTcGFjZXM+MClpZihiLnNlbGVjdGlvbi5pc0NvbGxhcHNlZCgpKXtiLnVuZG8uc2F2ZVN0ZXAoKSxhLnByZXZlbnREZWZhdWx0KCksYS5zdG9wUHJvcGFnYXRpb24oKTtmb3IodmFyIGM9XFxcIlxcXCIsZD0wO2Q8Yi5vcHRzLnRhYlNwYWNlcztkKyspYys9XFxcIiZuYnNwO1xcXCI7Yi5odG1sLmluc2VydChjKSxiLnBsYWNlaG9sZGVyLnJlZnJlc2goKSxiLnVuZG8uc2F2ZVN0ZXAoKX1lbHNlIGEucHJldmVudERlZmF1bHQoKSxhLnN0b3BQcm9wYWdhdGlvbigpLGEuc2hpZnRLZXk/Yi5jb21tYW5kcy5vdXRkZW50KCk6Yi5jb21tYW5kcy5pbmRlbnQoKX1mdW5jdGlvbiBrKCl7Qz0hMX1mdW5jdGlvbiBsKCl7cmV0dXJuIEN9ZnVuY3Rpb24gbShoKXtiLmV2ZW50cy5kaXNhYmxlQmx1cigpLHo9ITA7dmFyIGk9aC53aGljaDtpZigxNj09PWkpcmV0dXJuITA7aWYoMjI5PT09aSlyZXR1cm4gQz0hMCwhMDtDPSExO3ZhciBrPXQoaSkmJiFyKGgpLGw9aT09YS5GRS5LRVlDT0RFLkJBQ0tTUEFDRXx8aT09YS5GRS5LRVlDT0RFLkRFTEVURTtpZigoYi5zZWxlY3Rpb24uaXNGdWxsKCkmJiFiLm9wdHMua2VlcEZvcm1hdE9uRGVsZXRlJiYhYi5wbGFjZWhvbGRlci5pc1Zpc2libGUoKXx8bCYmYi5wbGFjZWhvbGRlci5pc1Zpc2libGUoKSYmYi5vcHRzLmtlZXBGb3JtYXRPbkRlbGV0ZSkmJihrfHxsKSl7dmFyIG09Yi5odG1sLmRlZmF1bHRUYWcoKTtpZihtP2IuJGVsLmh0bWwoXFxcIjxcXFwiK20rXFxcIj5cXFwiK2EuRkUuTUFSS0VSUytcXFwiPGJyLz48L1xcXCIrbStcXFwiPlxcXCIpOmIuJGVsLmh0bWwoYS5GRS5NQVJLRVJTK1xcXCI8YnIvPlxcXCIpLGIuc2VsZWN0aW9uLnJlc3RvcmUoKSwhdChpKSlyZXR1cm4gaC5wcmV2ZW50RGVmYXVsdCgpLCEwfWk9PWEuRkUuS0VZQ09ERS5FTlRFUj9oLnNoaWZ0S2V5P2QoaCk6YyhoKTppIT1hLkZFLktFWUNPREUuQkFDS1NQQUNFfHxyKGgpfHxoLmFsdEtleT9pIT1hLkZFLktFWUNPREUuREVMRVRFfHxyKGgpfHxoLmFsdEtleT9pPT1hLkZFLktFWUNPREUuU1BBQ0U/ZyhoKTppPT1hLkZFLktFWUNPREUuVEFCP2ooaCk6cihoKXx8IXQoaC53aGljaCl8fGIuc2VsZWN0aW9uLmlzQ29sbGFwc2VkKCl8fGguY3RybEtleXx8Yi5zZWxlY3Rpb24ucmVtb3ZlKCk6Yi5wbGFjZWhvbGRlci5pc1Zpc2libGUoKT8oaC5wcmV2ZW50RGVmYXVsdCgpLGguc3RvcFByb3BhZ2F0aW9uKCkpOmYoaCk6Yi5wbGFjZWhvbGRlci5pc1Zpc2libGUoKT8oaC5wcmV2ZW50RGVmYXVsdCgpLGguc3RvcFByb3BhZ2F0aW9uKCkpOmUoaCksYi5ldmVudHMuZW5hYmxlQmx1cigpfWZ1bmN0aW9uIG4oYSl7Zm9yKHZhciBjPWIuZG9jLmNyZWF0ZVRyZWVXYWxrZXIoYSxOb2RlRmlsdGVyLlNIT1dfVEVYVCxiLm5vZGUuZmlsdGVyKGZ1bmN0aW9uKGEpe3JldHVybi9cXFxcdTIwMEIvZ2kudGVzdChhLnRleHRDb250ZW50KX0pLCExKTtjLm5leHROb2RlKCk7KXt2YXIgZD1jLmN1cnJlbnROb2RlO2QudGV4dENvbnRlbnQ9ZC50ZXh0Q29udGVudC5yZXBsYWNlKC9cXFxcdTIwMEIvZ2ksXFxcIlxcXCIpfX1mdW5jdGlvbiBvKCl7aWYoIWIuJHdwKXJldHVybiEwO3ZhciBjO2Iub3B0cy5oZWlnaHR8fGIub3B0cy5oZWlnaHRNYXg/KGM9Yi5wb3NpdGlvbi5nZXRCb3VuZGluZ1JlY3QoKS50b3AsYi5oZWxwZXJzLmlzSU9TKCkmJihjLT1iLmhlbHBlcnMuc2Nyb2xsVG9wKCkpLGIub3B0cy5pZnJhbWUmJihjKz1iLiRpZnJhbWUub2Zmc2V0KCkudG9wKSxjPmIuJHdwLm9mZnNldCgpLnRvcC1iLmhlbHBlcnMuc2Nyb2xsVG9wKCkrYi4kd3AuaGVpZ2h0KCktMjAmJmIuJHdwLnNjcm9sbFRvcChjK2IuJHdwLnNjcm9sbFRvcCgpLShiLiR3cC5oZWlnaHQoKStiLiR3cC5vZmZzZXQoKS50b3ApK2IuaGVscGVycy5zY3JvbGxUb3AoKSsyMCkpOihjPWIucG9zaXRpb24uZ2V0Qm91bmRpbmdSZWN0KCkudG9wLGIub3B0cy50b29sYmFyQm90dG9tJiYoYys9Yi5vcHRzLnRvb2xiYXJTdGlja3lPZmZzZXQpLGIuaGVscGVycy5pc0lPUygpJiYoYy09Yi5oZWxwZXJzLnNjcm9sbFRvcCgpKSxiLm9wdHMuaWZyYW1lJiYoYys9Yi4kaWZyYW1lLm9mZnNldCgpLnRvcCxjLT1iLmhlbHBlcnMuc2Nyb2xsVG9wKCkpLGMrPWIub3B0cy50b29sYmFyU3RpY2t5T2Zmc2V0LGM+Yi5vX3dpbi5pbm5lckhlaWdodC0yMCYmYShiLm9fd2luKS5zY3JvbGxUb3AoYytiLmhlbHBlcnMuc2Nyb2xsVG9wKCktYi5vX3dpbi5pbm5lckhlaWdodCsyMCksYz1iLnBvc2l0aW9uLmdldEJvdW5kaW5nUmVjdCgpLnRvcCxiLm9wdHMudG9vbGJhckJvdHRvbXx8KGMtPWIub3B0cy50b29sYmFyU3RpY2t5T2Zmc2V0KSxiLmhlbHBlcnMuaXNJT1MoKSYmKGMtPWIuaGVscGVycy5zY3JvbGxUb3AoKSksYi5vcHRzLmlmcmFtZSYmKGMrPWIuJGlmcmFtZS5vZmZzZXQoKS50b3AsYy09Yi5oZWxwZXJzLnNjcm9sbFRvcCgpKSxjPGIuJHRiLmhlaWdodCgpKzIwJiZhKGIub193aW4pLnNjcm9sbFRvcChjK2IuaGVscGVycy5zY3JvbGxUb3AoKS1iLiR0Yi5oZWlnaHQoKS0yMCkpfWZ1bmN0aW9uIHAoKXt2YXIgYz1iLnNlbGVjdGlvbi5lbGVtZW50KCksZD1iLm5vZGUuYmxvY2tQYXJlbnQoYyk7aWYoZCYmXFxcIkRJVlxcXCI9PWQudGFnTmFtZSYmYi5zZWxlY3Rpb24uaW5mbyhkKS5hdFN0YXJ0KXt2YXIgZT1iLmh0bWwuZGVmYXVsdFRhZygpO2QucHJldmlvdXNTaWJsaW5nJiZcXFwiRElWXFxcIiE9ZC5wcmV2aW91c1NpYmxpbmcudGFnTmFtZSYmZSYmXFxcImRpdlxcXCIhPWUmJihiLnNlbGVjdGlvbi5zYXZlKCksYShkKS5yZXBsYWNlV2l0aChcXFwiPFxcXCIrZStcXFwiPlxcXCIrZC5pbm5lckhUTUwrXFxcIjwvXFxcIitlK1xcXCI+XFxcIiksYi5zZWxlY3Rpb24ucmVzdG9yZSgpKX19ZnVuY3Rpb24gcShjKXtpZihiLmhlbHBlcnMuaXNBbmRyb2lkJiZiLmJyb3dzZXIubW96aWxsYSlyZXR1cm4hMDtpZihDKXJldHVybiBDPSExLCExO2lmKCFiLnNlbGVjdGlvbi5pc0NvbGxhcHNlZCgpKXJldHVybiEwO2lmKGMmJihjLndoaWNoPT09YS5GRS5LRVlDT0RFLk1FVEF8fGMud2hpY2g9PWEuRkUuS0VZQ09ERS5DVFJMKSlyZXR1cm4hMDtpZihjJiZzKGMud2hpY2gpKXJldHVybiEwO2MmJmMud2hpY2g9PWEuRkUuS0VZQ09ERS5FTlRFUiYmYi5oZWxwZXJzLmlzSU9TKCkmJnAoKSxjJiYoYy53aGljaD09YS5GRS5LRVlDT0RFLkVOVEVSfHxjLndoaWNoPT1hLkZFLktFWUNPREUuQkFDS1NQQUNFfHxjLndoaWNoPj0zNyYmYy53aGljaDw9NDAmJiFiLmJyb3dzZXIubXNpZSkmJihjLndoaWNoPT1hLkZFLktFWUNPREUuQkFDS1NQQUNFJiZ6fHxvKCkpLGIuaHRtbC5jbGVhbkJScyghMCwhMCk7dmFyIGQ9ZnVuY3Rpb24oYSl7aWYoIWEpcmV0dXJuITE7dmFyIGI9YS5pbm5lckhUTUw7cmV0dXJuIGI9Yi5yZXBsYWNlKC88c3BhbltePl0qPyBjbGFzc1xcXFxzKj1cXFxccypbXFxcIiddP2ZyLW1hcmtlcltcXFwiJ10/W14+XSs+XFxcXHUyMDBiPFxcXFwvc3Bhbj4vZ2ksXFxcIlxcXCIpLCEhKGImJi9cXFxcdTIwMEIvLnRlc3QoYikmJmIucmVwbGFjZSgvXFxcXHUyMDBCL2dpLFxcXCJcXFwiKS5sZW5ndGg+MCl9LGU9ZnVuY3Rpb24oYSl7dmFyIGM9L1tcXFxcdTMwNDEtXFxcXHUzMDk2XFxcXHUzMEEwLVxcXFx1MzBGRlxcXFx1NEUwMC1cXFxcdTlGRkZcXFxcdTMxMzAtXFxcXHUzMThGXFxcXHVBQzAwLVxcXFx1RDdBRl0vZ2k7cmV0dXJuIWIuaGVscGVycy5pc0lPUygpfHwwPT09KChhLnRleHRDb250ZW50fHxcXFwiXFxcIikubWF0Y2goYyl8fFtdKS5sZW5ndGh9LGY9Yi5zZWxlY3Rpb24uZWxlbWVudCgpO2QoZikmJiFiLm5vZGUuaGFzQ2xhc3MoZixcXFwiZnItbWFya2VyXFxcIikmJlxcXCJJRlJBTUVcXFwiIT1mLnRhZ05hbWUmJmUoZikmJihiLnNlbGVjdGlvbi5zYXZlKCksbihmKSxiLnNlbGVjdGlvbi5yZXN0b3JlKCkpfWZ1bmN0aW9uIHIoYSl7aWYobmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKFxcXCJNYWMgT1MgWFxcXCIpIT0tMSl7aWYoYS5tZXRhS2V5JiYhYS5hbHRLZXkpcmV0dXJuITB9ZWxzZSBpZihhLmN0cmxLZXkmJiFhLmFsdEtleSlyZXR1cm4hMDtyZXR1cm4hMX1mdW5jdGlvbiBzKGIpe2lmKGI+PWEuRkUuS0VZQ09ERS5BUlJPV19MRUZUJiZiPD1hLkZFLktFWUNPREUuQVJST1dfRE9XTilyZXR1cm4hMH1mdW5jdGlvbiB0KGMpe2lmKGM+PWEuRkUuS0VZQ09ERS5aRVJPJiZjPD1hLkZFLktFWUNPREUuTklORSlyZXR1cm4hMDtpZihjPj1hLkZFLktFWUNPREUuTlVNX1pFUk8mJmM8PWEuRkUuS0VZQ09ERS5OVU1fTVVMVElQTFkpcmV0dXJuITA7aWYoYz49YS5GRS5LRVlDT0RFLkEmJmM8PWEuRkUuS0VZQ09ERS5aKXJldHVybiEwO2lmKGIuYnJvd3Nlci53ZWJraXQmJjA9PT1jKXJldHVybiEwO3N3aXRjaChjKXtjYXNlIGEuRkUuS0VZQ09ERS5TUEFDRTpjYXNlIGEuRkUuS0VZQ09ERS5RVUVTVElPTl9NQVJLOmNhc2UgYS5GRS5LRVlDT0RFLk5VTV9QTFVTOmNhc2UgYS5GRS5LRVlDT0RFLk5VTV9NSU5VUzpjYXNlIGEuRkUuS0VZQ09ERS5OVU1fUEVSSU9EOmNhc2UgYS5GRS5LRVlDT0RFLk5VTV9ESVZJU0lPTjpjYXNlIGEuRkUuS0VZQ09ERS5TRU1JQ09MT046Y2FzZSBhLkZFLktFWUNPREUuRkZfU0VNSUNPTE9OOmNhc2UgYS5GRS5LRVlDT0RFLkRBU0g6Y2FzZSBhLkZFLktFWUNPREUuRVFVQUxTOmNhc2UgYS5GRS5LRVlDT0RFLkZGX0VRVUFMUzpjYXNlIGEuRkUuS0VZQ09ERS5DT01NQTpjYXNlIGEuRkUuS0VZQ09ERS5QRVJJT0Q6Y2FzZSBhLkZFLktFWUNPREUuU0xBU0g6Y2FzZSBhLkZFLktFWUNPREUuQVBPU1RST1BIRTpjYXNlIGEuRkUuS0VZQ09ERS5TSU5HTEVfUVVPVEU6Y2FzZSBhLkZFLktFWUNPREUuT1BFTl9TUVVBUkVfQlJBQ0tFVDpjYXNlIGEuRkUuS0VZQ09ERS5CQUNLU0xBU0g6Y2FzZSBhLkZFLktFWUNPREUuQ0xPU0VfU1FVQVJFX0JSQUNLRVQ6cmV0dXJuITA7ZGVmYXVsdDpyZXR1cm4hMX19ZnVuY3Rpb24gdShjKXt2YXIgZD1jLndoaWNoO3JldHVybiEhKHIoYyl8fGQ+PTM3JiZkPD00MHx8IXQoZCkmJmQhPWEuRkUuS0VZQ09ERS5ERUxFVEUmJmQhPWEuRkUuS0VZQ09ERS5CQUNLU1BBQ0UmJmQhPWEuRkUuS0VZQ09ERS5FTlRFUil8fChBfHwoQj1iLnNuYXBzaG90LmdldCgpLGIudW5kby5jYW5EbygpfHxiLnVuZG8uc2F2ZVN0ZXAoKSksY2xlYXJUaW1lb3V0KEEpLHZvaWQoQT1zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7QT1udWxsLGIudW5kby5zYXZlU3RlcCgpfSxNYXRoLm1heCgyNTAsYi5vcHRzLnR5cGluZ1RpbWVyKSkpKX1mdW5jdGlvbiB2KGEpe3ZhciBjPWEud2hpY2g7cmV0dXJuISEocihhKXx8Yz49MzcmJmM8PTQwKXx8dm9pZChCJiZBJiYoYi51bmRvLnNhdmVTdGVwKEIpLEI9bnVsbCkpfWZ1bmN0aW9uIHcoKXtBJiYoY2xlYXJUaW1lb3V0KEEpLGIudW5kby5zYXZlU3RlcCgpLEI9bnVsbCl9ZnVuY3Rpb24geChiKXt2YXIgYz1iLndoaWNoO3JldHVybiByKGIpfHxjPT1hLkZFLktFWUNPREUuRjV9ZnVuY3Rpb24geSgpe2lmKGIuZXZlbnRzLm9uKFxcXCJrZXlkb3duXFxcIix1KSxiLmV2ZW50cy5vbihcXFwiaW5wdXRcXFwiLGgpLGIuZXZlbnRzLm9uKFxcXCJrZXl1cCBpbnB1dFxcXCIsdiksYi5ldmVudHMub24oXFxcImtleXByZXNzXFxcIixrKSxiLmV2ZW50cy5vbihcXFwia2V5ZG93blxcXCIsbSksYi5ldmVudHMub24oXFxcImtleXVwXFxcIixxKSxiLmV2ZW50cy5vbihcXFwiaHRtbC5pbnNlcnRlZFxcXCIscSksYi5ldmVudHMub24oXFxcImN1dFxcXCIsaSksIWIuYnJvd3Nlci5lZGdlJiZiLmVsLm1zR2V0SW5wdXRDb250ZXh0KXRyeXtiLmVsLm1zR2V0SW5wdXRDb250ZXh0KCkuYWRkRXZlbnRMaXN0ZW5lcihcXFwiTVNDYW5kaWRhdGVXaW5kb3dTaG93XFxcIixmdW5jdGlvbigpe0M9ITB9KSxiLmVsLm1zR2V0SW5wdXRDb250ZXh0KCkuYWRkRXZlbnRMaXN0ZW5lcihcXFwiTVNDYW5kaWRhdGVXaW5kb3dIaWRlXFxcIixmdW5jdGlvbigpe0M9ITEscSgpfSl9Y2F0Y2goYSl7fX12YXIgeixBLEIsQz0hMTtyZXR1cm57X2luaXQ6eSxjdHJsS2V5OnIsaXNDaGFyYWN0ZXI6dCxpc0Fycm93OnMsZm9yY2VVbmRvOncsaXNJTUU6bCxpc0Jyb3dzZXJBY3Rpb246eH19LGEuRkUuTU9EVUxFUy5hY2Nlc3NpYmlsaXR5PWZ1bmN0aW9uKGIpe2Z1bmN0aW9uIGMoYSl7aWYoYSYmYS5sZW5ndGgpe2EuZGF0YShcXFwiYmx1ci1ldmVudC1zZXRcXFwiKXx8YS5wYXJlbnRzKFxcXCIuZnItcG9wdXBcXFwiKS5sZW5ndGh8fChiLmV2ZW50cy4kb24oYSxcXFwiYmx1clxcXCIsZnVuY3Rpb24oKXt2YXIgYz1hLnBhcmVudHMoXFxcIi5mci10b29sYmFyLCAuZnItcG9wdXBcXFwiKS5kYXRhKFxcXCJpbnN0YW5jZVxcXCIpfHxiO2MuZXZlbnRzLmJsdXJBY3RpdmUoKSYmYy5ldmVudHMudHJpZ2dlcihcXFwiYmx1clxcXCIpLGMuZXZlbnRzLmVuYWJsZUJsdXIoKX0sITApLGEuZGF0YShcXFwiYmx1ci1ldmVudC1zZXRcXFwiLCEwKSk7dmFyIGM9YS5wYXJlbnRzKFxcXCIuZnItdG9vbGJhciwgLmZyLXBvcHVwXFxcIikuZGF0YShcXFwiaW5zdGFuY2VcXFwiKXx8YjtjLmV2ZW50cy5kaXNhYmxlQmx1cigpLGEuZm9jdXMoKSxiLnNoYXJlZC4kZl9lbD1hfX1mdW5jdGlvbiBkKGEsYil7dmFyIGQ9Yj9cXFwibGFzdFxcXCI6XFxcImZpcnN0XFxcIixlPWEuZmluZChcXFwiYnV0dG9uOnZpc2libGU6bm90KC5mci1kaXNhYmxlZCksIC5mci1ncm91cCBzcGFuLmZyLWNvbW1hbmQ6dmlzaWJsZVxcXCIpW2RdKCk7aWYoZS5sZW5ndGgpcmV0dXJuIGMoZSksITB9ZnVuY3Rpb24gZShhKXtyZXR1cm4gYS5pcyhcXFwiaW5wdXQsIHRleHRhcmVhXFxcIikmJmcoKSxiLmV2ZW50cy5kaXNhYmxlQmx1cigpLGEuZm9jdXMoKSwhMH1mdW5jdGlvbiBmKGEsYyl7dmFyIGQ9YS5maW5kKFxcXCJpbnB1dCwgdGV4dGFyZWEsIGJ1dHRvbiwgc2VsZWN0XFxcIikuZmlsdGVyKFxcXCI6dmlzaWJsZVxcXCIpLm5vdChcXFwiOmRpc2FibGVkXFxcIikuZmlsdGVyKGM/XFxcIjpsYXN0XFxcIjpcXFwiOmZpcnN0XFxcIik7aWYoZC5sZW5ndGgpcmV0dXJuIGUoZCk7aWYoYi5zaGFyZWQud2l0aF9rYil7dmFyIGY9YS5maW5kKFxcXCIuZnItYWN0aXZlLWl0ZW06dmlzaWJsZTpmaXJzdFxcXCIpO2lmKGYubGVuZ3RoKXJldHVybiBlKGYpO3ZhciBnPWEuZmluZChcXFwiW3RhYkluZGV4XTp2aXNpYmxlOmZpcnN0XFxcIik7aWYoZy5sZW5ndGgpcmV0dXJuIGUoZyl9fWZ1bmN0aW9uIGcoKXswPT09Yi4kZWwuZmluZChcXFwiLmZyLW1hcmtlclxcXCIpLmxlbmd0aCYmYi5jb3JlLmhhc0ZvY3VzKCkmJmIuc2VsZWN0aW9uLnNhdmUoKX1mdW5jdGlvbiBoKGEpe2EuJGVsLmZpbmQoXFxcIi5mci1tYXJrZXJcXFwiKS5sZW5ndGgmJihhLmV2ZW50cy5kaXNhYmxlQmx1cigpLGEuc2VsZWN0aW9uLnJlc3RvcmUoKSxhLmV2ZW50cy5lbmFibGVCbHVyKCkpfWZ1bmN0aW9uIGkoYSl7dmFyIGM9YS5jaGlsZHJlbigpLm5vdChcXFwiLmZyLWJ1dHRvbnNcXFwiKTtjLmRhdGEoXFxcIm1vdXNlZW50ZXItZXZlbnQtc2V0XFxcIil8fChiLmV2ZW50cy4kb24oYyxcXFwibW91c2VlbnRlclxcXCIsXFxcIlt0YWJJbmRleF1cXFwiLGZ1bmN0aW9uKGQpe3ZhciBlPWEuZGF0YShcXFwiaW5zdGFuY2VcXFwiKXx8YjtpZighRilyZXR1cm4gZC5zdG9wUHJvcGFnYXRpb24oKSx2b2lkIGQucHJldmVudERlZmF1bHQoKTt2YXIgZj1jLmZpbmQoXFxcIjpmb2N1czpmaXJzdFxcXCIpO2YubGVuZ3RoJiYhZi5pcyhcXFwiaW5wdXQsIGJ1dHRvbiwgdGV4dGFyZWFcXFwiKSYmKGUuZXZlbnRzLmRpc2FibGVCbHVyKCksZi5ibHVyKCksZS5ldmVudHMuZGlzYWJsZUJsdXIoKSxlLmV2ZW50cy5mb2N1cygpKX0pLGMuZGF0YShcXFwibW91c2VlbnRlci1ldmVudC1zZXRcXFwiLCEwKSksIWYoYykmJmIuc2hhcmVkLndpdGhfa2ImJmQoYS5maW5kKFxcXCIuZnItYnV0dG9uc1xcXCIpKX1mdW5jdGlvbiBqKGEpe2IuY29yZS5oYXNGb2N1cygpfHwoYi5ldmVudHMuZGlzYWJsZUJsdXIoKSxiLmV2ZW50cy5mb2N1cygpKSxiLmFjY2Vzc2liaWxpdHkuc2F2ZVNlbGVjdGlvbigpLGIuZXZlbnRzLmRpc2FibGVCbHVyKCksYi4kZWwuYmx1cigpLGIuc2VsZWN0aW9uLmNsZWFyKCksYi5ldmVudHMuZGlzYWJsZUJsdXIoKSxiLnNoYXJlZC53aXRoX2tiP2EuZmluZChcXFwiLmZyLWNvbW1hbmRbdGFiSW5kZXhdLCBbdGFiSW5kZXhdXFxcIikuZmlyc3QoKS5mb2N1cygpOmEuZmluZChcXFwiW3RhYkluZGV4XTpmaXJzdFxcXCIpLmZvY3VzKCl9ZnVuY3Rpb24gaygpe3ZhciBhPWIucG9wdXBzLmFyZVZpc2libGUoKTtpZihhKXt2YXIgYz1hLmZpbmQoXFxcIi5mci1idXR0b25zXFxcIik7cmV0dXJuIGMuZmluZChcXFwiYnV0dG9uOmZvY3VzLCAuZnItZ3JvdXAgc3Bhbjpmb2N1c1xcXCIpLmxlbmd0aD8hZChhLmRhdGEoXFxcImluc3RhbmNlXFxcIikuJHRiKTohZChjKX1yZXR1cm4hZChiLiR0Yil9ZnVuY3Rpb24gbCgpe3ZhciBhPW51bGw7cmV0dXJuIGIuc2hhcmVkLiRmX2VsLmlzKFxcXCIuZnItZHJvcGRvd24uZnItYWN0aXZlXFxcIik/YT1iLnNoYXJlZC4kZl9lbDpiLnNoYXJlZC4kZl9lbC5jbG9zZXN0KFxcXCIuZnItZHJvcGRvd24tbWVudVxcXCIpLnByZXYoKS5pcyhcXFwiLmZyLWRyb3Bkb3duLmZyLWFjdGl2ZVxcXCIpJiYoYT1iLnNoYXJlZC4kZl9lbC5jbG9zZXN0KFxcXCIuZnItZHJvcGRvd24tbWVudVxcXCIpLnByZXYoKSksYX1mdW5jdGlvbiBtKGUsZyxoKXtpZihiLnNoYXJlZC4kZl9lbCl7dmFyIGk9bCgpO2kmJihiLmJ1dHRvbi5jbGljayhpKSxiLnNoYXJlZC4kZl9lbD1pKTt2YXIgaj1lLmZpbmQoXFxcImJ1dHRvbjp2aXNpYmxlOm5vdCguZnItZGlzYWJsZWQpLCAuZnItZ3JvdXAgc3Bhbi5mci1jb21tYW5kOnZpc2libGVcXFwiKSxrPWouaW5kZXgoYi5zaGFyZWQuJGZfZWwpO2lmKDA9PT1rJiYhaHx8az09ai5sZW5ndGgtMSYmaCl7dmFyIG07aWYoZyl7aWYoZS5wYXJlbnQoKS5pcyhcXFwiLmZyLXBvcHVwXFxcIikpe3ZhciBuPWUucGFyZW50KCkuY2hpbGRyZW4oKS5ub3QoXFxcIi5mci1idXR0b25zXFxcIik7bT0hZihuLCFoKX1tPT09ITEmJihiLnNoYXJlZC4kZl9lbD1udWxsKX1nJiZtPT09ITF8fGQoZSwhaCl9ZWxzZSBjKGEoai5nZXQoaysoaD8xOi0xKSkpKTtyZXR1cm4hMX19ZnVuY3Rpb24gbihhLGIpe3JldHVybiBtKGEsYiwhMCl9ZnVuY3Rpb24gbyhhLGIpe3JldHVybiBtKGEsYil9ZnVuY3Rpb24gcChhKXtpZihiLnNoYXJlZC4kZl9lbCl7dmFyIGQ7aWYoYi5zaGFyZWQuJGZfZWwuaXMoXFxcIi5mci1kcm9wZG93bi5mci1hY3RpdmVcXFwiKSlyZXR1cm4gZD1hP2Iuc2hhcmVkLiRmX2VsLm5leHQoKS5maW5kKFxcXCIuZnItY29tbWFuZDpub3QoLmZyLWRpc2FibGVkKVxcXCIpLmZpcnN0KCk6Yi5zaGFyZWQuJGZfZWwubmV4dCgpLmZpbmQoXFxcIi5mci1jb21tYW5kOm5vdCguZnItZGlzYWJsZWQpXFxcIikubGFzdCgpLGMoZCksITE7aWYoYi5zaGFyZWQuJGZfZWwuaXMoXFxcImEuZnItY29tbWFuZFxcXCIpKXJldHVybiBkPWE/Yi5zaGFyZWQuJGZfZWwuY2xvc2VzdChcXFwibGlcXFwiKS5uZXh0QWxsKFxcXCI6dmlzaWJsZTpmaXJzdFxcXCIpLmZpbmQoXFxcIi5mci1jb21tYW5kOm5vdCguZnItZGlzYWJsZWQpXFxcIikuZmlyc3QoKTpiLnNoYXJlZC4kZl9lbC5jbG9zZXN0KFxcXCJsaVxcXCIpLnByZXZBbGwoXFxcIjp2aXNpYmxlOmZpcnN0XFxcIikuZmluZChcXFwiLmZyLWNvbW1hbmQ6bm90KC5mci1kaXNhYmxlZClcXFwiKS5maXJzdCgpLGQubGVuZ3RofHwoZD1hP2Iuc2hhcmVkLiRmX2VsLmNsb3Nlc3QoXFxcIi5mci1kcm9wZG93bi1tZW51XFxcIikuZmluZChcXFwiLmZyLWNvbW1hbmQ6bm90KC5mci1kaXNhYmxlZClcXFwiKS5maXJzdCgpOmIuc2hhcmVkLiRmX2VsLmNsb3Nlc3QoXFxcIi5mci1kcm9wZG93bi1tZW51XFxcIikuZmluZChcXFwiLmZyLWNvbW1hbmQ6bm90KC5mci1kaXNhYmxlZClcXFwiKS5sYXN0KCkpLGMoZCksITF9fWZ1bmN0aW9uIHEoKXtyZXR1cm4gYi5zaGFyZWQuJGZfZWwmJmIuc2hhcmVkLiRmX2VsLmlzKFxcXCIuZnItZHJvcGRvd246bm90KC5mci1hY3RpdmUpXFxcIik/cygpOnAoITApfWZ1bmN0aW9uIHIoKXtyZXR1cm4gcCgpfWZ1bmN0aW9uIHMoKXtpZihiLnNoYXJlZC4kZl9lbCl7aWYoYi5zaGFyZWQuJGZfZWwuaGFzQ2xhc3MoXFxcImZyLWRyb3Bkb3duXFxcIikpYi5idXR0b24uY2xpY2soYi5zaGFyZWQuJGZfZWwpO2Vsc2UgaWYoYi5zaGFyZWQuJGZfZWwuaXMoXFxcImJ1dHRvbi5mci1iYWNrXFxcIikpe2Iub3B0cy50b29sYmFySW5saW5lJiYoYi5ldmVudHMuZGlzYWJsZUJsdXIoKSxiLmV2ZW50cy5mb2N1cygpKTt2YXIgYT1iLnBvcHVwcy5hcmVWaXNpYmxlKGIpO2EmJihiLnNoYXJlZC53aXRoX2tiPSExKSxiLmJ1dHRvbi5jbGljayhiLnNoYXJlZC4kZl9lbCkseihhKX1lbHNle2lmKGIuZXZlbnRzLmRpc2FibGVCbHVyKCksYi5idXR0b24uY2xpY2soYi5zaGFyZWQuJGZfZWwpLGIuc2hhcmVkLiRmX2VsLmF0dHIoXFxcImRhdGEtcG9wdXBcXFwiKSl7dmFyIGM9Yi5wb3B1cHMuYXJlVmlzaWJsZShiKTtjJiZjLmRhdGEoXFxcInBvcHVwLWJ1dHRvblxcXCIsYi5zaGFyZWQuJGZfZWwpfWVsc2UgaWYoYi5zaGFyZWQuJGZfZWwuYXR0cihcXFwiZGF0YS1tb2RhbFxcXCIpKXt2YXIgZD1iLm1vZGFscy5hcmVWaXNpYmxlKGIpO2QmJmQuZGF0YShcXFwibW9kYWwtYnV0dG9uXFxcIixiLnNoYXJlZC4kZl9lbCl9Yi5zaGFyZWQuJGZfZWw9bnVsbH1yZXR1cm4hMX19ZnVuY3Rpb24gdCgpe2Iuc2hhcmVkLiRmX2VsJiYoYi5ldmVudHMuZGlzYWJsZUJsdXIoKSxiLnNoYXJlZC4kZl9lbC5ibHVyKCksYi5zaGFyZWQuJGZfZWw9bnVsbCksYi5ldmVudHMudHJpZ2dlcihcXFwidG9vbGJhci5mb2N1c0VkaXRvclxcXCIpIT09ITEmJihiLmV2ZW50cy5kaXNhYmxlQmx1cigpLGIuZXZlbnRzLmZvY3VzKCkpfWZ1bmN0aW9uIHUoYSl7aWYoYi5zaGFyZWQuJGZfZWwpe3ZhciBkPWwoKTtyZXR1cm4gZD8oYi5idXR0b24uY2xpY2soZCksYyhkKSk6YS5wYXJlbnQoKS5maW5kKFxcXCIuZnItYmFjazp2aXNpYmxlXFxcIikubGVuZ3RoPyhiLnNoYXJlZC53aXRoX2tiPSExLGIub3B0cy50b29sYmFySW5saW5lJiYoYi5ldmVudHMuZGlzYWJsZUJsdXIoKSxiLmV2ZW50cy5mb2N1cygpKSxiLmJ1dHRvbi5leGVjKGEucGFyZW50KCkuZmluZChcXFwiLmZyLWJhY2s6dmlzaWJsZTpmaXJzdFxcXCIpKSx6KGEucGFyZW50KCkpKTpiLnNoYXJlZC4kZl9lbC5pcyhcXFwiYnV0dG9uLCAuZnItZ3JvdXAgc3BhblxcXCIpJiYoYS5wYXJlbnQoKS5pcyhcXFwiLmZyLXBvcHVwXFxcIik/KGgoYiksYi5zaGFyZWQuJGZfZWw9bnVsbCxiLmV2ZW50cy50cmlnZ2VyKFxcXCJ0b29sYmFyLmVzY1xcXCIpIT09ITEmJihiLnBvcHVwcy5oaWRlKGEucGFyZW50KCkpLGIub3B0cy50b29sYmFySW5saW5lJiZiLnRvb2xiYXIuc2hvd0lubGluZShudWxsLCEwKSx6KGEucGFyZW50KCkpKSk6dCgpKSwhMX19ZnVuY3Rpb24gdihjLGQpe3ZhciBlPW5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZihcXFwiTWFjIE9TIFhcXFwiKSE9LTE/Yy5tZXRhS2V5OmMuY3RybEtleSxmPWMud2hpY2gsZz0hMTtyZXR1cm4gZiE9YS5GRS5LRVlDT0RFLlRBQnx8ZXx8Yy5zaGlmdEtleXx8Yy5hbHRLZXk/ZiE9YS5GRS5LRVlDT0RFLkFSUk9XX1JJR0hUfHxlfHxjLnNoaWZ0S2V5fHxjLmFsdEtleT9mIT1hLkZFLktFWUNPREUuVEFCfHxlfHwhYy5zaGlmdEtleXx8Yy5hbHRLZXk/ZiE9YS5GRS5LRVlDT0RFLkFSUk9XX0xFRlR8fGV8fGMuc2hpZnRLZXl8fGMuYWx0S2V5P2YhPWEuRkUuS0VZQ09ERS5BUlJPV19VUHx8ZXx8Yy5zaGlmdEtleXx8Yy5hbHRLZXk/ZiE9YS5GRS5LRVlDT0RFLkFSUk9XX0RPV058fGV8fGMuc2hpZnRLZXl8fGMuYWx0S2V5P2YhPWEuRkUuS0VZQ09ERS5FTlRFUnx8ZXx8Yy5zaGlmdEtleXx8Yy5hbHRLZXk/ZiE9YS5GRS5LRVlDT0RFLkVTQ3x8ZXx8Yy5zaGlmdEtleXx8Yy5hbHRLZXk/ZiE9YS5GRS5LRVlDT0RFLkYxMHx8ZXx8Yy5zaGlmdEtleXx8IWMuYWx0S2V5fHwoZz1rKCkpOmc9dShkKTpnPXMoKTpnPXEoKTpnPXIoKTpnPW8oZCk6Zz1vKGQsITApOmc9bihkKTpnPW4oZCwhMCksYi5zaGFyZWQuJGZfZWx8fHZvaWQgMCE9PWd8fChnPSEwKSwhZyYmYi5rZXlzLmlzQnJvd3NlckFjdGlvbihjKSYmKGc9ITApLCEhZ3x8KGMucHJldmVudERlZmF1bHQoKSxjLnN0b3BQcm9wYWdhdGlvbigpLCExKX1mdW5jdGlvbiB3KGMpe2MmJmMubGVuZ3RoJiYoYi5ldmVudHMuJG9uKGMsXFxcImtleWRvd25cXFwiLGZ1bmN0aW9uKGQpe2lmKCFhKGQudGFyZ2V0KS5pcyhcXFwiYS5mci1jb21tYW5kLCBidXR0b24uZnItY29tbWFuZCwgLmZyLWdyb3VwIHNwYW4uZnItY29tbWFuZFxcXCIpKXJldHVybiEwO3ZhciBlPWMucGFyZW50cyhcXFwiLmZyLXBvcHVwXFxcIikuZGF0YShcXFwiaW5zdGFuY2VcXFwiKXx8Yy5kYXRhKFxcXCJpbnN0YW5jZVxcXCIpfHxiO2Iuc2hhcmVkLndpdGhfa2I9ITA7dmFyIGY9ZS5hY2Nlc3NpYmlsaXR5LmV4ZWMoZCxjKTtyZXR1cm4gYi5zaGFyZWQud2l0aF9rYj0hMSxmfSwhMCksYi5ldmVudHMuJG9uKGMsXFxcIm1vdXNlZW50ZXJcXFwiLFxcXCJbdGFiSW5kZXhdXFxcIixmdW5jdGlvbihkKXt2YXIgZT1jLnBhcmVudHMoXFxcIi5mci1wb3B1cFxcXCIpLmRhdGEoXFxcImluc3RhbmNlXFxcIil8fGMuZGF0YShcXFwiaW5zdGFuY2VcXFwiKXx8YjtpZighRilyZXR1cm4gZC5zdG9wUHJvcGFnYXRpb24oKSx2b2lkIGQucHJldmVudERlZmF1bHQoKTt2YXIgZj1hKGQuY3VycmVudFRhcmdldCk7ZS5zaGFyZWQuJGZfZWwmJmUuc2hhcmVkLiRmX2VsLm5vdChmKSYmZS5hY2Nlc3NpYmlsaXR5LmZvY3VzRWRpdG9yKCl9LCEwKSl9ZnVuY3Rpb24geChhKXt2YXIgYz1iLnBvcHVwcy5nZXQoYSksZD15KGEpO3coYy5maW5kKFxcXCIuZnItYnV0dG9uc1xcXCIpKSxiLmV2ZW50cy4kb24oYyxcXFwibW91c2VlbnRlclxcXCIsXFxcInRhYkluZGV4XFxcIixkLl90aU1vdXNlZW50ZXIsITApLGIuZXZlbnRzLiRvbihjLmNoaWxkcmVuKCkubm90KFxcXCIuZnItYnV0dG9uc1xcXCIpLFxcXCJrZXlkb3duXFxcIixcXFwiW3RhYkluZGV4XVxcXCIsZC5fdGlLZXlkb3duLCEwKSxiLnBvcHVwcy5vbkhpZGUoYSxmdW5jdGlvbigpe2goYy5kYXRhKFxcXCJpbnN0YW5jZVxcXCIpfHxiKX0pLGIucG9wdXBzLm9uU2hvdyhhLGZ1bmN0aW9uKCl7Rj0hMSxzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7Rj0hMH0sMCl9KX1mdW5jdGlvbiB5KGMpe3ZhciBlPWIucG9wdXBzLmdldChjKTtyZXR1cm57X3RpS2V5ZG93bjpmdW5jdGlvbihnKXt2YXIgaT1lLmRhdGEoXFxcImluc3RhbmNlXFxcIil8fGI7aWYoaS5ldmVudHMudHJpZ2dlcihcXFwicG9wdXAudGFiXFxcIixbZ10pPT09ITEpcmV0dXJuITE7dmFyIGo9Zy53aGljaCxrPWUuZmluZChcXFwiOmZvY3VzOmZpcnN0XFxcIik7aWYoYS5GRS5LRVlDT0RFLlRBQj09ail7Zy5wcmV2ZW50RGVmYXVsdCgpO3ZhciBsPWUuY2hpbGRyZW4oKS5ub3QoXFxcIi5mci1idXR0b25zXFxcIiksbT1sLmZpbmQoXFxcImlucHV0LCB0ZXh0YXJlYSwgYnV0dG9uLCBzZWxlY3RcXFwiKS5maWx0ZXIoXFxcIjp2aXNpYmxlXFxcIikubm90KFxcXCIuZnItbm8tdG91Y2ggaW5wdXQsIC5mci1uby10b3VjaCB0ZXh0YXJlYSwgLmZyLW5vLXRvdWNoIGJ1dHRvbiwgLmZyLW5vLXRvdWNoIHNlbGVjdCwgOmRpc2FibGVkXFxcIikudG9BcnJheSgpLG49bS5pbmRleE9mKHRoaXMpKyhnLnNoaWZ0S2V5Py0xOjEpO2lmKDA8PW4mJm48bS5sZW5ndGgpcmV0dXJuIGkuZXZlbnRzLmRpc2FibGVCbHVyKCksYShtW25dKS5mb2N1cygpLGcuc3RvcFByb3BhZ2F0aW9uKCksITE7dmFyIG89ZS5maW5kKFxcXCIuZnItYnV0dG9uc1xcXCIpO2lmKG8ubGVuZ3RoJiZkKG8sISFnLnNoaWZ0S2V5KSlyZXR1cm4gZy5zdG9wUHJvcGFnYXRpb24oKSwhMTtpZihmKGwpKXJldHVybiBnLnN0b3BQcm9wYWdhdGlvbigpLCExfWVsc2V7aWYoYS5GRS5LRVlDT0RFLkVOVEVSIT1qKXJldHVybiBhLkZFLktFWUNPREUuRVNDPT1qPyhnLnByZXZlbnREZWZhdWx0KCksZy5zdG9wUHJvcGFnYXRpb24oKSxoKGkpLGkucG9wdXBzLmlzVmlzaWJsZShjKSYmZS5maW5kKFxcXCIuZnItYmFjazp2aXNpYmxlXFxcIikubGVuZ3RoPyhpLm9wdHMudG9vbGJhcklubGluZSYmKGkuZXZlbnRzLmRpc2FibGVCbHVyKCksaS5ldmVudHMuZm9jdXMoKSksaS5idXR0b24uZXhlYyhlLmZpbmQoXFxcIi5mci1iYWNrOnZpc2libGU6Zmlyc3RcXFwiKSkseihlKSk6aS5wb3B1cHMuaXNWaXNpYmxlKGMpJiZlLmZpbmQoXFxcIi5mci1kaXNtaXNzOnZpc2libGVcXFwiKS5sZW5ndGg/aS5idXR0b24uZXhlYyhlLmZpbmQoXFxcIi5mci1kaXNtaXNzOnZpc2libGU6Zmlyc3RcXFwiKSk6KGkucG9wdXBzLmhpZGUoYyksaS5vcHRzLnRvb2xiYXJJbmxpbmUmJmkudG9vbGJhci5zaG93SW5saW5lKG51bGwsITApLHooZSkpLCExKTphLkZFLktFWUNPREUuU1BBQ0U9PWomJihrLmlzKFxcXCIuZnItc3VibWl0XFxcIil8fGsuaXMoXFxcIi5mci1kaXNtaXNzXFxcIikpPyhnLnByZXZlbnREZWZhdWx0KCksZy5zdG9wUHJvcGFnYXRpb24oKSxpLmV2ZW50cy5kaXNhYmxlQmx1cigpLGkuYnV0dG9uLmV4ZWMoayksITApOmkua2V5cy5pc0Jyb3dzZXJBY3Rpb24oZyk/dm9pZCBnLnN0b3BQcm9wYWdhdGlvbigpOmsuaXMoXFxcImlucHV0W3R5cGU9dGV4dF0sIHRleHRhcmVhXFxcIik/dm9pZCBnLnN0b3BQcm9wYWdhdGlvbigpOmEuRkUuS0VZQ09ERS5TUEFDRT09aiYmKGsuaXMoXFxcIi5mci1saW5rLWF0dHJcXFwiKXx8ay5pcyhcXFwiaW5wdXRbdHlwZT1maWxlXVxcXCIpKT92b2lkIGcuc3RvcFByb3BhZ2F0aW9uKCk6KGcuc3RvcFByb3BhZ2F0aW9uKCksZy5wcmV2ZW50RGVmYXVsdCgpLCExKTt2YXIgcD1udWxsO2UuZmluZChcXFwiLmZyLXN1Ym1pdDp2aXNpYmxlXFxcIikubGVuZ3RoPjA/cD1lLmZpbmQoXFxcIi5mci1zdWJtaXQ6dmlzaWJsZTpmaXJzdFxcXCIpOmUuZmluZChcXFwiLmZyLWRpc21pc3M6dmlzaWJsZVxcXCIpLmxlbmd0aCYmKHA9ZS5maW5kKFxcXCIuZnItZGlzbWlzczp2aXNpYmxlOmZpcnN0XFxcIikpLHAmJihnLnByZXZlbnREZWZhdWx0KCksZy5zdG9wUHJvcGFnYXRpb24oKSxpLmV2ZW50cy5kaXNhYmxlQmx1cigpLGkuYnV0dG9uLmV4ZWMocCkpfX0sX3RpTW91c2VlbnRlcjpmdW5jdGlvbigpe3ZhciBhPWUuZGF0YShcXFwiaW5zdGFuY2VcXFwiKXx8YjtDKGEpfX19ZnVuY3Rpb24geihhKXt2YXIgYj1hLmRhdGEoXFxcInBvcHVwLWJ1dHRvblxcXCIpO2ImJnNldFRpbWVvdXQoZnVuY3Rpb24oKXtjKGIpLGEuZGF0YShcXFwicG9wdXAtYnV0dG9uXFxcIixudWxsKX0sMCl9ZnVuY3Rpb24gQShhKXt2YXIgYj1hLmRhdGEoXFxcIm1vZGFsLWJ1dHRvblxcXCIpO2ImJnNldFRpbWVvdXQoZnVuY3Rpb24oKXtjKGIpLGEuZGF0YShcXFwibW9kYWwtYnV0dG9uXFxcIixudWxsKX0sMCl9ZnVuY3Rpb24gQigpe3JldHVybiBudWxsIT1iLnNoYXJlZC4kZl9lbH1mdW5jdGlvbiBDKGEpe3ZhciBjPWIucG9wdXBzLmFyZVZpc2libGUoYSk7YyYmYy5kYXRhKFxcXCJwb3B1cC1idXR0b25cXFwiLG51bGwpfWZ1bmN0aW9uIEQoYyl7dmFyIGQ9bmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKFxcXCJNYWMgT1MgWFxcXCIpIT0tMT9jLm1ldGFLZXk6Yy5jdHJsS2V5LGU9Yy53aGljaDtpZihlPT1hLkZFLktFWUNPREUuRjEwJiYhZCYmIWMuc2hpZnRLZXkmJmMuYWx0S2V5KXtiLnNoYXJlZC53aXRoX2tiPSEwO3ZhciBnPWIucG9wdXBzLmFyZVZpc2libGUoYiksaD0hMTtyZXR1cm4gZyYmKGg9ZihnLmNoaWxkcmVuKCkubm90KFxcXCIuZnItYnV0dG9uc1xcXCIpKSksaHx8aygpLGIuc2hhcmVkLndpdGhfa2I9ITEsYy5wcmV2ZW50RGVmYXVsdCgpLGMuc3RvcFByb3BhZ2F0aW9uKCksITF9cmV0dXJuITB9ZnVuY3Rpb24gRSgpe2IuJHdwP2IuZXZlbnRzLm9uKFxcXCJrZXlkb3duXFxcIixELCEwKTpiLmV2ZW50cy4kb24oYi4kd2luLFxcXCJrZXlkb3duXFxcIixELCEwKSxiLmV2ZW50cy5vbihcXFwibW91c2Vkb3duXFxcIixmdW5jdGlvbihhKXtDKGIpLGIuc2hhcmVkLiRmX2VsJiYoaChiKSxhLnN0b3BQcm9wYWdhdGlvbigpLGIuZXZlbnRzLmRpc2FibGVCbHVyKCksYi5zaGFyZWQuJGZfZWw9bnVsbCl9LCEwKSxiLmV2ZW50cy5vbihcXFwiYmx1clxcXCIsZnVuY3Rpb24oKXtiLnNoYXJlZC4kZl9lbD1udWxsLEMoYil9LCEwKX12YXIgRj0hMDtyZXR1cm57X2luaXQ6RSxyZWdpc3RlclBvcHVwOngscmVnaXN0ZXJUb29sYmFyOncsZm9jdXNUb29sYmFyRWxlbWVudDpjLGZvY3VzVG9vbGJhcjpkLGZvY3VzQ29udGVudDpmLGZvY3VzUG9wdXA6aSxmb2N1c01vZGFsOmosZm9jdXNFZGl0b3I6dCxmb2N1c1BvcHVwQnV0dG9uOnosZm9jdXNNb2RhbEJ1dHRvbjpBLGhhc0ZvY3VzOkIsZXhlYzp2LHNhdmVTZWxlY3Rpb246ZyxyZXN0b3JlU2VsZWN0aW9uOmh9fSxhLkZFLk1PRFVMRVMuZm9ybWF0PWZ1bmN0aW9uKGIpe2Z1bmN0aW9uIGMoYSxiKXt2YXIgYz1cXFwiPFxcXCIrYTtmb3IodmFyIGQgaW4gYiliLmhhc093blByb3BlcnR5KGQpJiYoYys9XFxcIiBcXFwiK2QrJz1cXFwiJytiW2RdKydcXFwiJyk7cmV0dXJuIGMrPVxcXCI+XFxcIn1mdW5jdGlvbiBkKGEpe3JldHVyblxcXCI8L1xcXCIrYStcXFwiPlxcXCJ9ZnVuY3Rpb24gZShhLGIpe3ZhciBjPWE7Zm9yKHZhciBkIGluIGIpYi5oYXNPd25Qcm9wZXJ0eShkKSYmKGMrPVxcXCJpZFxcXCI9PWQ/XFxcIiNcXFwiK2JbZF06XFxcImNsYXNzXFxcIj09ZD9cXFwiLlxcXCIrYltkXTpcXFwiW1xcXCIrZCsnPVxcXCInK2JbZF0rJ1xcXCJdJyk7cmV0dXJuIGN9ZnVuY3Rpb24gZihhLGIpe3JldHVybiEoIWF8fGEubm9kZVR5cGUhPU5vZGUuRUxFTUVOVF9OT0RFKSYmKGEubWF0Y2hlc3x8YS5tYXRjaGVzU2VsZWN0b3J8fGEubXNNYXRjaGVzU2VsZWN0b3J8fGEubW96TWF0Y2hlc1NlbGVjdG9yfHxhLndlYmtpdE1hdGNoZXNTZWxlY3Rvcnx8YS5vTWF0Y2hlc1NlbGVjdG9yKS5jYWxsKGEsYil9ZnVuY3Rpb24gZyhkLGUsZil7aWYoZCl7aWYoYi5ub2RlLmlzQmxvY2soZCkpcmV0dXJuIGcoZC5maXJzdENoaWxkLGUsZiksITE7Zm9yKHZhciBoPWEoYyhlLGYpKS5pbnNlcnRCZWZvcmUoZCksaT1kO2kmJiFhKGkpLmlzKFxcXCIuZnItbWFya2VyXFxcIikmJjA9PT1hKGkpLmZpbmQoXFxcIi5mci1tYXJrZXJcXFwiKS5sZW5ndGg7KXt2YXIgaj1pO2k9aS5uZXh0U2libGluZyxoLmFwcGVuZChqKX1pZihpKWEoaSkuZmluZChcXFwiLmZyLW1hcmtlclxcXCIpLmxlbmd0aCYmZyhpLmZpcnN0Q2hpbGQsZSxmKTtlbHNle2Zvcih2YXIgaz1oLmdldCgwKS5wYXJlbnROb2RlO2smJiFrLm5leHRTaWJsaW5nJiYhYi5ub2RlLmlzRWxlbWVudChrKTspaz1rLnBhcmVudE5vZGU7aWYoayl7dmFyIGw9ay5uZXh0U2libGluZztsJiYoYi5ub2RlLmlzQmxvY2sobCk/ZyhsLmZpcnN0Q2hpbGQsZSxmKTpnKGwsZSxmKSl9fWguaXMoXFxcIjplbXB0eVxcXCIpJiZoLnJlbW92ZSgpfX1mdW5jdGlvbiBoKGgsaSl7dmFyIGo7aWYoXFxcInVuZGVmaW5lZFxcXCI9PXR5cGVvZiBpJiYoaT17fSksaS5zdHlsZSYmZGVsZXRlIGkuc3R5bGUsYi5zZWxlY3Rpb24uaXNDb2xsYXBzZWQoKSl7Yi5tYXJrZXJzLmluc2VydCgpO3ZhciBrPWIuJGVsLmZpbmQoXFxcIi5mci1tYXJrZXJcXFwiKTtrLnJlcGxhY2VXaXRoKGMoaCxpKSthLkZFLklOVklTSUJMRV9TUEFDRSthLkZFLk1BUktFUlMrZChoKSksYi5zZWxlY3Rpb24ucmVzdG9yZSgpfWVsc2V7Yi5zZWxlY3Rpb24uc2F2ZSgpO3ZhciBsPWIuJGVsLmZpbmQoJy5mci1tYXJrZXJbZGF0YS10eXBlPVxcXCJ0cnVlXFxcIl0nKS5nZXQoMCkubmV4dFNpYmxpbmc7ZyhsLGgsaSk7dmFyIG07ZG8gZm9yKG09Yi4kZWwuZmluZChlKGgsaSkrXFxcIiA+IFxcXCIrZShoLGkpKSxqPTA7ajxtLmxlbmd0aDtqKyspbVtqXS5vdXRlckhUTUw9bVtqXS5pbm5lckhUTUw7d2hpbGUobS5sZW5ndGgpO2IuZWwubm9ybWFsaXplKCk7dmFyIG49Yi5lbC5xdWVyeVNlbGVjdG9yQWxsKFxcXCIuZnItbWFya2VyXFxcIik7Zm9yKGo9MDtqPG4ubGVuZ3RoO2orKyl7dmFyIG89YShuW2pdKTtvLmRhdGEoXFxcInR5cGVcXFwiKT09PSEwP2Yoby5nZXQoMCkubmV4dFNpYmxpbmcsZShoLGkpKSYmby5uZXh0KCkucHJlcGVuZChvKTpmKG8uZ2V0KDApLnByZXZpb3VzU2libGluZyxlKGgsaSkpJiZvLnByZXYoKS5hcHBlbmQobyl9Yi5zZWxlY3Rpb24ucmVzdG9yZSgpfX1mdW5jdGlvbiBpKGEsYyxkLGcpe2lmKCFnKXt2YXIgaD0hMTtpZihhLmRhdGEoXFxcInR5cGVcXFwiKT09PSEwKWZvcig7Yi5ub2RlLmlzRmlyc3RTaWJsaW5nKGEuZ2V0KDApKSYmIWEucGFyZW50KCkuaXMoYi4kZWwpJiYhYS5wYXJlbnQoKS5pcyhcXFwib2xcXFwiKSYmIWEucGFyZW50KCkuaXMoXFxcInVsXFxcIik7KWEucGFyZW50KCkuYmVmb3JlKGEpLGg9ITA7ZWxzZSBpZihhLmRhdGEoXFxcInR5cGVcXFwiKT09PSExKWZvcig7Yi5ub2RlLmlzTGFzdFNpYmxpbmcoYS5nZXQoMCkpJiYhYS5wYXJlbnQoKS5pcyhiLiRlbCkmJiFhLnBhcmVudCgpLmlzKFxcXCJvbFxcXCIpJiYhYS5wYXJlbnQoKS5pcyhcXFwidWxcXFwiKTspYS5wYXJlbnQoKS5hZnRlcihhKSxoPSEwO2lmKGgpcmV0dXJuITB9aWYoYS5wYXJlbnRzKGMpLmxlbmd0aHx8XFxcInVuZGVmaW5lZFxcXCI9PXR5cGVvZiBjKXt2YXIgaT1cXFwiXFxcIixqPVxcXCJcXFwiLGs9YS5wYXJlbnQoKTtpZihrLmlzKGIuJGVsKXx8Yi5ub2RlLmlzQmxvY2soay5nZXQoMCkpKXJldHVybiExO2Zvcig7XFxcInVuZGVmaW5lZFxcXCI9PXR5cGVvZiBjJiYhYi5ub2RlLmlzQmxvY2soay5wYXJlbnQoKS5nZXQoMCkpfHxcXFwidW5kZWZpbmVkXFxcIiE9dHlwZW9mIGMmJiFmKGsuZ2V0KDApLGUoYyxkKSk7KWkrPWIubm9kZS5jbG9zZVRhZ1N0cmluZyhrLmdldCgwKSksaj1iLm5vZGUub3BlblRhZ1N0cmluZyhrLmdldCgwKSkraixrPWsucGFyZW50KCk7dmFyIGw9YS5nZXQoMCkub3V0ZXJIVE1MO2EucmVwbGFjZVdpdGgoJzxzcGFuIGlkPVxcXCJtYXJrXFxcIj48L3NwYW4+Jyk7dmFyIG09ay5odG1sKCkucmVwbGFjZSgvPHNwYW4gaWQ9XFxcIm1hcmtcXFwiPjxcXFxcL3NwYW4+LyxpK2Iubm9kZS5jbG9zZVRhZ1N0cmluZyhrLmdldCgwKSkraitsK2krYi5ub2RlLm9wZW5UYWdTdHJpbmcoay5nZXQoMCkpK2opO3JldHVybiBrLnJlcGxhY2VXaXRoKGIubm9kZS5vcGVuVGFnU3RyaW5nKGsuZ2V0KDApKSttK2Iubm9kZS5jbG9zZVRhZ1N0cmluZyhrLmdldCgwKSkpLCEwfXJldHVybiExfWZ1bmN0aW9uIGooYyxkLGcsaCl7Zm9yKHZhciBpPWIubm9kZS5jb250ZW50cyhjLmdldCgwKSksaz0wO2s8aS5sZW5ndGg7aysrKXt2YXIgbD1pW2tdO2lmKGIubm9kZS5oYXNDbGFzcyhsLFxcXCJmci1tYXJrZXJcXFwiKSlkPShkKzEpJTI7ZWxzZSBpZihkKWlmKGEobCkuZmluZChcXFwiLmZyLW1hcmtlclxcXCIpLmxlbmd0aD4wKWQ9aihhKGwpLGQsZyxoKTtlbHNle2Zvcih2YXIgbT1hKGwpLmZpbmQoZ3x8XFxcIipcXFwiKSxuPW0ubGVuZ3RoLTE7bj49MDtuLS0pe3ZhciBvPW1bbl07Yi5ub2RlLmlzQmxvY2sobyl8fGIubm9kZS5pc1ZvaWQobyl8fCFmKG8sZShnLGgpKXx8KG8ub3V0ZXJIVE1MPW8uaW5uZXJIVE1MKX1cXFwidW5kZWZpbmVkXFxcIj09dHlwZW9mIGcmJmwubm9kZVR5cGU9PU5vZGUuRUxFTUVOVF9OT0RFJiYhYi5ub2RlLmlzVm9pZChsKSYmIWIubm9kZS5pc0Jsb2NrKGwpfHxmKGwsZShnLGgpKT9hKGwpLnJlcGxhY2VXaXRoKGwuaW5uZXJIVE1MKTpcXFwidW5kZWZpbmVkXFxcIj09dHlwZW9mIGcmJmwubm9kZVR5cGU9PU5vZGUuRUxFTUVOVF9OT0RFJiZiLm5vZGUuaXNCbG9jayhsKSYmYi5ub2RlLmNsZWFyQXR0cmlidXRlcyhsKX1lbHNlIGEobCkuZmluZChcXFwiLmZyLW1hcmtlclxcXCIpLmxlbmd0aD4wJiYoZD1qKGEobCksZCxnLGgpKX1yZXR1cm4gZH1mdW5jdGlvbiBrKGMsZCl7XFxcInVuZGVmaW5lZFxcXCI9PXR5cGVvZiBkJiYoZD17fSksZC5zdHlsZSYmZGVsZXRlIGQuc3R5bGU7dmFyIGU9Yi5zZWxlY3Rpb24uaXNDb2xsYXBzZWQoKTtiLnNlbGVjdGlvbi5zYXZlKCk7Zm9yKHZhciBmPSEwO2Y7KXtmPSExO2Zvcih2YXIgZz1iLiRlbC5maW5kKFxcXCIuZnItbWFya2VyXFxcIiksaD0wO2g8Zy5sZW5ndGg7aCsrKWlmKGkoYShnW2hdKSxjLGQsZSkpe2Y9ITA7YnJlYWt9fWooYi4kZWwsMCxjLGQpLGUmJmIuJGVsLmZpbmQoXFxcIi5mci1tYXJrZXJcXFwiKS5iZWZvcmUoYS5GRS5JTlZJU0lCTEVfU1BBQ0UpLmFmdGVyKGEuRkUuSU5WSVNJQkxFX1NQQUNFKSxiLmh0bWwuY2xlYW5FbXB0eVRhZ3MoKSxiLmVsLm5vcm1hbGl6ZSgpLGIuc2VsZWN0aW9uLnJlc3RvcmUoKX1mdW5jdGlvbiBsKGEsYil7cShhLGIpP2soYSxiKTpoKGEsYil9ZnVuY3Rpb24gbShiLGMpe3ZhciBkPWEoYik7ZC5jc3MoYyxcXFwiXFxcIiksXFxcIlxcXCI9PT1kLmF0dHIoXFxcInN0eWxlXFxcIikmJmQucmVwbGFjZVdpdGgoZC5odG1sKCkpfWZ1bmN0aW9uIG4oYixjKXtyZXR1cm4gMD09PWEoYikuYXR0cihcXFwic3R5bGVcXFwiKS5pbmRleE9mKGMrXFxcIjpcXFwiKXx8YShiKS5hdHRyKFxcXCJzdHlsZVxcXCIpLmluZGV4T2YoXFxcIjtcXFwiK2MrXFxcIjpcXFwiKT49MHx8YShiKS5hdHRyKFxcXCJzdHlsZVxcXCIpLmluZGV4T2YoXFxcIjsgXFxcIitjK1xcXCI6XFxcIik+PTB9ZnVuY3Rpb24gbyhjLGQpe3ZhciBlLGY7aWYoYi5zZWxlY3Rpb24uaXNDb2xsYXBzZWQoKSl7Yi5tYXJrZXJzLmluc2VydCgpLGY9Yi4kZWwuZmluZChcXFwiLmZyLW1hcmtlclxcXCIpO3ZhciBoPWYucGFyZW50KCk7aWYoYi5ub2RlLm9wZW5UYWdTdHJpbmcoaC5nZXQoMCkpPT0nPHNwYW4gc3R5bGU9XFxcIicrYytcXFwiOiBcXFwiK2guY3NzKGMpKyc7XFxcIj4nKWlmKGIubm9kZS5pc0VtcHR5KGguZ2V0KDApKSloLnJlcGxhY2VXaXRoKCc8c3BhbiBzdHlsZT1cXFwiJytjK1xcXCI6IFxcXCIrZCsnO1xcXCI+JythLkZFLklOVklTSUJMRV9TUEFDRSthLkZFLk1BUktFUlMrXFxcIjwvc3Bhbj5cXFwiKTtlbHNle3ZhciBqPXt9O2pbY109ZCxpKGYsXFxcInNwYW5cXFwiLGosITApLGY9Yi4kZWwuZmluZChcXFwiLmZyLW1hcmtlclxcXCIpLGYucmVwbGFjZVdpdGgoJzxzcGFuIHN0eWxlPVxcXCInK2MrXFxcIjogXFxcIitkKyc7XFxcIj4nK2EuRkUuSU5WSVNJQkxFX1NQQUNFK2EuRkUuTUFSS0VSUytcXFwiPC9zcGFuPlxcXCIpfWVsc2UgYi5ub2RlLmlzRW1wdHkoaC5nZXQoMCkpJiZoLmlzKFxcXCJzcGFuXFxcIik/KGYucmVwbGFjZVdpdGgoYS5GRS5NQVJLRVJTKSxoLmNzcyhjLGQpKTpmLnJlcGxhY2VXaXRoKCc8c3BhbiBzdHlsZT1cXFwiJytjK1xcXCI6IFxcXCIrZCsnO1xcXCI+JythLkZFLklOVklTSUJMRV9TUEFDRSthLkZFLk1BUktFUlMrXFxcIjwvc3Bhbj5cXFwiKTtiLnNlbGVjdGlvbi5yZXN0b3JlKCl9ZWxzZXtpZihiLnNlbGVjdGlvbi5zYXZlKCksbnVsbD09ZHx8XFxcImNvbG9yXFxcIj09YyYmYi4kZWwuZmluZChcXFwiLmZyLW1hcmtlclxcXCIpLnBhcmVudHMoXFxcInUsIGFcXFwiKS5sZW5ndGg+MCl7dmFyIGs9Yi4kZWwuZmluZChcXFwiLmZyLW1hcmtlclxcXCIpO2ZvcihlPTA7ZTxrLmxlbmd0aDtlKyspaWYoZj1hKGtbZV0pLGYuZGF0YShcXFwidHlwZVxcXCIpPT09ITApZm9yKDtiLm5vZGUuaXNGaXJzdFNpYmxpbmcoZi5nZXQoMCkpJiYhZi5wYXJlbnQoKS5pcyhiLiRlbCkmJiFiLm5vZGUuaXNFbGVtZW50KGYucGFyZW50KCkuZ2V0KDApKSYmIWIubm9kZS5pc0Jsb2NrKGYucGFyZW50KCkuZ2V0KDApKTspZi5wYXJlbnQoKS5iZWZvcmUoZik7ZWxzZSBmb3IoO2Iubm9kZS5pc0xhc3RTaWJsaW5nKGYuZ2V0KDApKSYmIWYucGFyZW50KCkuaXMoYi4kZWwpJiYhYi5ub2RlLmlzRWxlbWVudChmLnBhcmVudCgpLmdldCgwKSkmJiFiLm5vZGUuaXNCbG9jayhmLnBhcmVudCgpLmdldCgwKSk7KWYucGFyZW50KCkuYWZ0ZXIoZil9dmFyIGw9Yi4kZWwuZmluZCgnLmZyLW1hcmtlcltkYXRhLXR5cGU9XFxcInRydWVcXFwiXScpLmdldCgwKS5uZXh0U2libGluZyxvPXtjbGFzczpcXFwiZnItdW5wcm9jZXNzZWRcXFwifTtmb3IoZCYmKG8uc3R5bGU9YytcXFwiOiBcXFwiK2QrXFxcIjtcXFwiKSxnKGwsXFxcInNwYW5cXFwiLG8pLGIuJGVsLmZpbmQoXFxcIi5mci1tYXJrZXIgKyAuZnItdW5wcm9jZXNzZWRcXFwiKS5lYWNoKGZ1bmN0aW9uKCl7YSh0aGlzKS5wcmVwZW5kKGEodGhpcykucHJldigpKX0pLGIuJGVsLmZpbmQoXFxcIi5mci11bnByb2Nlc3NlZCArIC5mci1tYXJrZXJcXFwiKS5lYWNoKGZ1bmN0aW9uKCl7YSh0aGlzKS5wcmV2KCkuYXBwZW5kKHRoaXMpfSk7Yi4kZWwuZmluZChcXFwic3Bhbi5mci11bnByb2Nlc3NlZFxcXCIpLmxlbmd0aD4wOyl7dmFyIHA9Yi4kZWwuZmluZChcXFwic3Bhbi5mci11bnByb2Nlc3NlZDpmaXJzdFxcXCIpLnJlbW92ZUNsYXNzKFxcXCJmci11bnByb2Nlc3NlZFxcXCIpO2lmKHAucGFyZW50KCkuZ2V0KDApLm5vcm1hbGl6ZSgpLHAucGFyZW50KCkuaXMoXFxcInNwYW5cXFwiKSYmMT09cC5wYXJlbnQoKS5nZXQoMCkuY2hpbGROb2Rlcy5sZW5ndGgpe3AucGFyZW50KCkuY3NzKGMsZCk7dmFyIHE9cDtwPXAucGFyZW50KCkscS5yZXBsYWNlV2l0aChxLmh0bWwoKSl9dmFyIHI9cC5maW5kKFxcXCJzcGFuXFxcIik7Zm9yKGU9ci5sZW5ndGgtMTtlPj0wO2UtLSltKHJbZV0sYyk7dmFyIHM9cC5wYXJlbnRzVW50aWwoYi4kZWwsXFxcInNwYW5bc3R5bGVdXFxcIiksdD1bXTtmb3IoZT1zLmxlbmd0aC0xO2U+PTA7ZS0tKW4oc1tlXSxjKXx8dC5wdXNoKHNbZV0pO2lmKHM9cy5ub3QodCkscy5sZW5ndGgpe3ZhciB1PVxcXCJcXFwiLHY9XFxcIlxcXCIsdz1cXFwiXFxcIix4PVxcXCJcXFwiLHk9cC5nZXQoMCk7ZG8geT15LnBhcmVudE5vZGUsYSh5KS5hZGRDbGFzcyhcXFwiZnItc3BsaXRcXFwiKSx1Kz1iLm5vZGUuY2xvc2VUYWdTdHJpbmcoeSksdj1iLm5vZGUub3BlblRhZ1N0cmluZyhhKHkpLmNsb25lKCkuYWRkQ2xhc3MoXFxcImZyLXNwbGl0XFxcIikuZ2V0KDApKSt2LHMuZ2V0KDApIT15JiYodys9Yi5ub2RlLmNsb3NlVGFnU3RyaW5nKHkpLHg9Yi5ub2RlLm9wZW5UYWdTdHJpbmcoYSh5KS5jbG9uZSgpLmFkZENsYXNzKFxcXCJmci1zcGxpdFxcXCIpLmdldCgwKSkreCk7d2hpbGUocy5nZXQoMCkhPXkpO3ZhciB6PXUrYi5ub2RlLm9wZW5UYWdTdHJpbmcoYShzLmdldCgwKSkuY2xvbmUoKS5jc3MoYyxkfHxcXFwiXFxcIikuZ2V0KDApKSt4K3AuY3NzKGMsXFxcIlxcXCIpLmdldCgwKS5vdXRlckhUTUwrdytcXFwiPC9zcGFuPlxcXCIrdjtwLnJlcGxhY2VXaXRoKCc8c3BhbiBpZD1cXFwiZnItYnJlYWtcXFwiPjwvc3Bhbj4nKTt2YXIgQT1zLmdldCgwKS5vdXRlckhUTUw7YShzLmdldCgwKSkucmVwbGFjZVdpdGgoQS5yZXBsYWNlKC88c3BhbiBpZD1cXFwiZnItYnJlYWtcXFwiPjxcXFxcL3NwYW4+L2cseikpfX1mb3IoO2IuJGVsLmZpbmQoXFxcIi5mci1zcGxpdDplbXB0eVxcXCIpLmxlbmd0aD4wOyliLiRlbC5maW5kKFxcXCIuZnItc3BsaXQ6ZW1wdHlcXFwiKS5yZW1vdmUoKTtiLiRlbC5maW5kKFxcXCIuZnItc3BsaXRcXFwiKS5yZW1vdmVDbGFzcyhcXFwiZnItc3BsaXRcXFwiKSxiLiRlbC5maW5kKCdzcGFuW3N0eWxlPVxcXCJcXFwiXScpLnJlbW92ZUF0dHIoXFxcInN0eWxlXFxcIiksYi4kZWwuZmluZCgnc3BhbltjbGFzcz1cXFwiXFxcIl0nKS5yZW1vdmVBdHRyKFxcXCJjbGFzc1xcXCIpLGIuaHRtbC5jbGVhbkVtcHR5VGFncygpLGEoYi4kZWwuZmluZChcXFwic3BhblxcXCIpLmdldCgpLnJldmVyc2UoKSkuZWFjaChmdW5jdGlvbigpe3RoaXMuYXR0cmlidXRlcyYmMCE9PXRoaXMuYXR0cmlidXRlcy5sZW5ndGh8fGEodGhpcykucmVwbGFjZVdpdGgodGhpcy5pbm5lckhUTUwpfSksYi5lbC5ub3JtYWxpemUoKTt2YXIgQj1iLiRlbC5maW5kKFxcXCJzcGFuW3N0eWxlXSArIHNwYW5bc3R5bGVdXFxcIik7Zm9yKGU9MDtlPEIubGVuZ3RoO2UrKyl7dmFyIEM9YShCW2VdKSxEPWEoQltlXSkucHJldigpO0MuZ2V0KDApLnByZXZpb3VzU2libGluZz09RC5nZXQoMCkmJmIubm9kZS5vcGVuVGFnU3RyaW5nKEMuZ2V0KDApKT09Yi5ub2RlLm9wZW5UYWdTdHJpbmcoRC5nZXQoMCkpJiYoQy5wcmVwZW5kKEQuaHRtbCgpKSxELnJlbW92ZSgpKX1iLiRlbC5maW5kKFxcXCJzcGFuW3N0eWxlXSBzcGFuW3N0eWxlXVxcXCIpLmVhY2goZnVuY3Rpb24oKXtpZihhKHRoaXMpLmF0dHIoXFxcInN0eWxlXFxcIikuaW5kZXhPZihcXFwiZm9udC1zaXplXFxcIik+PTApe3ZhciBiPWEodGhpcykucGFyZW50cyhcXFwic3BhbltzdHlsZV1cXFwiKTtiLmF0dHIoXFxcInN0eWxlXFxcIikuaW5kZXhPZihcXFwiYmFja2dyb3VuZC1jb2xvclxcXCIpPj0wJiYoYSh0aGlzKS5hdHRyKFxcXCJzdHlsZVxcXCIsYSh0aGlzKS5hdHRyKFxcXCJzdHlsZVxcXCIpK1xcXCI7XFxcIitiLmF0dHIoXFxcInN0eWxlXFxcIikpLGkoYSh0aGlzKSxcXFwic3BhbltzdHlsZV1cXFwiLHt9LCExKSl9fSksYi5lbC5ub3JtYWxpemUoKSxiLnNlbGVjdGlvbi5yZXN0b3JlKCl9fWZ1bmN0aW9uIHAoYSl7byhhLG51bGwpfWZ1bmN0aW9uIHEoYSxjKXtcXFwidW5kZWZpbmVkXFxcIj09dHlwZW9mIGMmJihjPXt9KSxjLnN0eWxlJiZkZWxldGUgYy5zdHlsZTt2YXIgZD1iLnNlbGVjdGlvbi5yYW5nZXMoMCksZz1kLnN0YXJ0Q29udGFpbmVyO2cubm9kZVR5cGU9PU5vZGUuRUxFTUVOVF9OT0RFJiZnLmNoaWxkTm9kZXMubGVuZ3RoPjAmJmcuY2hpbGROb2Rlc1tkLnN0YXJ0T2Zmc2V0XSYmKGc9Zy5jaGlsZE5vZGVzW2Quc3RhcnRPZmZzZXRdKTtmb3IodmFyIGg9ZztoJiZoLm5vZGVUeXBlPT1Ob2RlLkVMRU1FTlRfTk9ERSYmIWYoaCxlKGEsYykpOyloPWguZmlyc3RDaGlsZDtpZihoJiZoLm5vZGVUeXBlPT1Ob2RlLkVMRU1FTlRfTk9ERSYmZihoLGUoYSxjKSkpcmV0dXJuITA7dmFyIGk9Zztmb3IoaSYmaS5ub2RlVHlwZSE9Tm9kZS5FTEVNRU5UX05PREUmJihpPWkucGFyZW50Tm9kZSk7aSYmaS5ub2RlVHlwZT09Tm9kZS5FTEVNRU5UX05PREUmJmkhPWIuZWwmJiFmKGksZShhLGMpKTspaT1pLnBhcmVudE5vZGU7cmV0dXJuISghaXx8aS5ub2RlVHlwZSE9Tm9kZS5FTEVNRU5UX05PREV8fGk9PWIuZWx8fCFmKGksZShhLGMpKSl9cmV0dXJue2lzOnEsdG9nZ2xlOmwsYXBwbHk6aCxyZW1vdmU6ayxhcHBseVN0eWxlOm8scmVtb3ZlU3R5bGU6cH19LGEuRkUuQ09NTUFORFM9e2JvbGQ6e3RpdGxlOlxcXCJCb2xkXFxcIix0b2dnbGU6ITAscmVmcmVzaDpmdW5jdGlvbihhKXt2YXIgYj10aGlzLmZvcm1hdC5pcyhcXFwic3Ryb25nXFxcIik7YS50b2dnbGVDbGFzcyhcXFwiZnItYWN0aXZlXFxcIixiKS5hdHRyKFxcXCJhcmlhLXByZXNzZWRcXFwiLGIpfX0saXRhbGljOnt0aXRsZTpcXFwiSXRhbGljXFxcIix0b2dnbGU6ITAscmVmcmVzaDpmdW5jdGlvbihhKXt2YXIgYj10aGlzLmZvcm1hdC5pcyhcXFwiZW1cXFwiKTthLnRvZ2dsZUNsYXNzKFxcXCJmci1hY3RpdmVcXFwiLGIpLmF0dHIoXFxcImFyaWEtcHJlc3NlZFxcXCIsYil9fSx1bmRlcmxpbmU6e3RpdGxlOlxcXCJVbmRlcmxpbmVcXFwiLHRvZ2dsZTohMCxyZWZyZXNoOmZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMuZm9ybWF0LmlzKFxcXCJ1XFxcIik7YS50b2dnbGVDbGFzcyhcXFwiZnItYWN0aXZlXFxcIixiKS5hdHRyKFxcXCJhcmlhLXByZXNzZWRcXFwiLGIpfX0sc3RyaWtlVGhyb3VnaDp7dGl0bGU6XFxcIlN0cmlrZXRocm91Z2hcXFwiLHRvZ2dsZTohMCxyZWZyZXNoOmZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMuZm9ybWF0LmlzKFxcXCJzXFxcIik7YS50b2dnbGVDbGFzcyhcXFwiZnItYWN0aXZlXFxcIixiKS5hdHRyKFxcXCJhcmlhLXByZXNzZWRcXFwiLGIpfX0sc3Vic2NyaXB0Ont0aXRsZTpcXFwiU3Vic2NyaXB0XFxcIix0b2dnbGU6ITAscmVmcmVzaDpmdW5jdGlvbihhKXt2YXIgYj10aGlzLmZvcm1hdC5pcyhcXFwic3ViXFxcIik7YS50b2dnbGVDbGFzcyhcXFwiZnItYWN0aXZlXFxcIixiKS5hdHRyKFxcXCJhcmlhLXByZXNzZWRcXFwiLGIpfX0sc3VwZXJzY3JpcHQ6e3RpdGxlOlxcXCJTdXBlcnNjcmlwdFxcXCIsdG9nZ2xlOiEwLHJlZnJlc2g6ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5mb3JtYXQuaXMoXFxcInN1cFxcXCIpO2EudG9nZ2xlQ2xhc3MoXFxcImZyLWFjdGl2ZVxcXCIsYikuYXR0cihcXFwiYXJpYS1wcmVzc2VkXFxcIixiKX19LG91dGRlbnQ6e3RpdGxlOlxcXCJEZWNyZWFzZSBJbmRlbnRcXFwifSxpbmRlbnQ6e3RpdGxlOlxcXCJJbmNyZWFzZSBJbmRlbnRcXFwifSx1bmRvOnt0aXRsZTpcXFwiVW5kb1xcXCIsdW5kbzohMSxmb3JjZWRSZWZyZXNoOiEwLGRpc2FibGVkOiEwfSxyZWRvOnt0aXRsZTpcXFwiUmVkb1xcXCIsdW5kbzohMSxmb3JjZWRSZWZyZXNoOiEwLGRpc2FibGVkOiEwfSxpbnNlcnRIUjp7dGl0bGU6XFxcIkluc2VydCBIb3Jpem9udGFsIExpbmVcXFwifSxjbGVhckZvcm1hdHRpbmc6e3RpdGxlOlxcXCJDbGVhciBGb3JtYXR0aW5nXFxcIn0sc2VsZWN0QWxsOnt0aXRsZTpcXFwiU2VsZWN0IEFsbFxcXCIsdW5kbzohMX19LGEuRkUuUmVnaXN0ZXJDb21tYW5kPWZ1bmN0aW9uKGIsYyl7YS5GRS5DT01NQU5EU1tiXT1jfSxhLkZFLk1PRFVMRVMuY29tbWFuZHM9ZnVuY3Rpb24oYil7ZnVuY3Rpb24gYyhhKXtyZXR1cm4gYi5odG1sLmRlZmF1bHRUYWcoKSYmKGE9XFxcIjxcXFwiK2IuaHRtbC5kZWZhdWx0VGFnKCkrXFxcIj5cXFwiK2ErXFxcIjwvXFxcIitiLmh0bWwuZGVmYXVsdFRhZygpK1xcXCI+XFxcIiksYX1mdW5jdGlvbiBkKGMsZCl7aWYoYi5ldmVudHMudHJpZ2dlcihcXFwiY29tbWFuZHMuYmVmb3JlXFxcIixhLm1lcmdlKFtjXSxkfHxbXSkpIT09ITEpe3ZhciBlPWEuRkUuQ09NTUFORFNbY10mJmEuRkUuQ09NTUFORFNbY10uY2FsbGJhY2t8fGlbY10sZj0hMCxnPSExO2EuRkUuQ09NTUFORFNbY10mJihcXFwidW5kZWZpbmVkXFxcIiE9dHlwZW9mIGEuRkUuQ09NTUFORFNbY10uZm9jdXMmJihmPWEuRkUuQ09NTUFORFNbY10uZm9jdXMpLFxcXCJ1bmRlZmluZWRcXFwiIT10eXBlb2YgYS5GRS5DT01NQU5EU1tjXS5hY2Nlc3NpYmlsaXR5Rm9jdXMmJihnPWEuRkUuQ09NTUFORFNbY10uYWNjZXNzaWJpbGl0eUZvY3VzKSksKCFiLmNvcmUuaGFzRm9jdXMoKSYmZiYmIWIucG9wdXBzLmFyZVZpc2libGUoKXx8IWIuY29yZS5oYXNGb2N1cygpJiZnJiZiLmFjY2Vzc2liaWxpdHkuaGFzRm9jdXMoKSkmJmIuZXZlbnRzLmZvY3VzKCEwKSxhLkZFLkNPTU1BTkRTW2NdJiZhLkZFLkNPTU1BTkRTW2NdLnVuZG8hPT0hMSYmKGIuJGVsLmZpbmQoXFxcIi5mci1tYXJrZXJcXFwiKS5sZW5ndGgmJihiLmV2ZW50cy5kaXNhYmxlQmx1cigpLGIuc2VsZWN0aW9uLnJlc3RvcmUoKSksYi51bmRvLnNhdmVTdGVwKCkpLGUmJmUuYXBwbHkoYixhLm1lcmdlKFtjXSxkfHxbXSkpLGIuZXZlbnRzLnRyaWdnZXIoXFxcImNvbW1hbmRzLmFmdGVyXFxcIixhLm1lcmdlKFtjXSxkfHxbXSkpLGEuRkUuQ09NTUFORFNbY10mJmEuRkUuQ09NTUFORFNbY10udW5kbyE9PSExJiZiLnVuZG8uc2F2ZVN0ZXAoKX19ZnVuY3Rpb24gZShhLGMpe2IuZm9ybWF0LnRvZ2dsZShjKX1mdW5jdGlvbiBmKGMpe2Iuc2VsZWN0aW9uLnNhdmUoKSxiLmh0bWwud3JhcCghMCwhMCwhMCwhMCksYi5zZWxlY3Rpb24ucmVzdG9yZSgpO2Zvcih2YXIgZD1iLnNlbGVjdGlvbi5ibG9ja3MoKSxlPTA7ZTxkLmxlbmd0aDtlKyspaWYoXFxcIkxJXFxcIiE9ZFtlXS50YWdOYW1lJiZcXFwiTElcXFwiIT1kW2VdLnBhcmVudE5vZGUudGFnTmFtZSl7dmFyIGY9YShkW2VdKSxnPVxcXCJydGxcXFwiPT1iLm9wdHMuZGlyZWN0aW9ufHxcXFwicnRsXFxcIj09Zi5jc3MoXFxcImRpcmVjdGlvblxcXCIpP1xcXCJtYXJnaW4tcmlnaHRcXFwiOlxcXCJtYXJnaW4tbGVmdFxcXCIsaD1iLmhlbHBlcnMuZ2V0UFgoZi5jc3MoZykpO2YuY3NzKGcsTWF0aC5tYXgoaCsyMCpjLDApfHxcXFwiXFxcIiksZi5yZW1vdmVDbGFzcyhcXFwiZnItdGVtcC1kaXZcXFwiKX1iLnNlbGVjdGlvbi5zYXZlKCksYi5odG1sLnVud3JhcCgpLGIuc2VsZWN0aW9uLnJlc3RvcmUoKX1mdW5jdGlvbiBnKGEpe3JldHVybiBmdW5jdGlvbigpe2QoYSl9fWZ1bmN0aW9uIGgoKXtiLmV2ZW50cy5vbihcXFwia2V5ZG93blxcXCIsZnVuY3Rpb24oYSl7dmFyIGM9Yi5zZWxlY3Rpb24uZWxlbWVudCgpO2lmKGMmJlxcXCJIUlxcXCI9PWMudGFnTmFtZSYmIWIua2V5cy5pc0Fycm93KGEud2hpY2gpKXJldHVybiBhLnByZXZlbnREZWZhdWx0KCksITF9KSxiLmV2ZW50cy5vbihcXFwia2V5dXBcXFwiLGZ1bmN0aW9uKGMpe3ZhciBkPWIuc2VsZWN0aW9uLmVsZW1lbnQoKTtpZihkJiZcXFwiSFJcXFwiPT1kLnRhZ05hbWUpaWYoYy53aGljaD09YS5GRS5LRVlDT0RFLkFSUk9XX0xFRlR8fGMud2hpY2g9PWEuRkUuS0VZQ09ERS5BUlJPV19VUCl7aWYoZC5wcmV2aW91c1NpYmxpbmcpcmV0dXJuIGIubm9kZS5pc0Jsb2NrKGQucHJldmlvdXNTaWJsaW5nKT9iLnNlbGVjdGlvbi5zZXRBdEVuZChkLnByZXZpb3VzU2libGluZyk6YShkKS5iZWZvcmUoYS5GRS5NQVJLRVJTKSxiLnNlbGVjdGlvbi5yZXN0b3JlKCksITF9ZWxzZSBpZigoYy53aGljaD09YS5GRS5LRVlDT0RFLkFSUk9XX1JJR0hUfHxjLndoaWNoPT1hLkZFLktFWUNPREUuQVJST1dfRE9XTikmJmQubmV4dFNpYmxpbmcpcmV0dXJuIGIubm9kZS5pc0Jsb2NrKGQubmV4dFNpYmxpbmcpP2Iuc2VsZWN0aW9uLnNldEF0U3RhcnQoZC5uZXh0U2libGluZyk6YShkKS5hZnRlcihhLkZFLk1BUktFUlMpLGIuc2VsZWN0aW9uLnJlc3RvcmUoKSwhMX0pLGIuZXZlbnRzLm9uKFxcXCJtb3VzZWRvd25cXFwiLGZ1bmN0aW9uKGEpe2lmKGEudGFyZ2V0JiZcXFwiSFJcXFwiPT1hLnRhcmdldC50YWdOYW1lKXJldHVybiBhLnByZXZlbnREZWZhdWx0KCksYS5zdG9wUHJvcGFnYXRpb24oKSwhMX0pLGIuZXZlbnRzLm9uKFxcXCJtb3VzZXVwXFxcIixmdW5jdGlvbigpe3ZhciBjPWIuc2VsZWN0aW9uLmVsZW1lbnQoKSxkPWIuc2VsZWN0aW9uLmVuZEVsZW1lbnQoKTtjPT1kJiZjJiZcXFwiSFJcXFwiPT1jLnRhZ05hbWUmJihjLm5leHRTaWJsaW5nJiYoYi5ub2RlLmlzQmxvY2soYy5uZXh0U2libGluZyk/Yi5zZWxlY3Rpb24uc2V0QXRTdGFydChjLm5leHRTaWJsaW5nKTphKGMpLmFmdGVyKGEuRkUuTUFSS0VSUykpLGIuc2VsZWN0aW9uLnJlc3RvcmUoKSl9KX12YXIgaT17Ym9sZDpmdW5jdGlvbigpe2UoXFxcImJvbGRcXFwiLFxcXCJzdHJvbmdcXFwiKX0sc3Vic2NyaXB0OmZ1bmN0aW9uKCl7ZShcXFwic3Vic2NyaXB0XFxcIixcXFwic3ViXFxcIil9LHN1cGVyc2NyaXB0OmZ1bmN0aW9uKCl7ZShcXFwic3VwZXJzY3JpcHRcXFwiLFxcXCJzdXBcXFwiKX0saXRhbGljOmZ1bmN0aW9uKCl7ZShcXFwiaXRhbGljXFxcIixcXFwiZW1cXFwiKX0sc3RyaWtlVGhyb3VnaDpmdW5jdGlvbigpe2UoXFxcInN0cmlrZVRocm91Z2hcXFwiLFxcXCJzXFxcIil9LHVuZGVybGluZTpmdW5jdGlvbigpe2UoXFxcInVuZGVybGluZVxcXCIsXFxcInVcXFwiKX0sdW5kbzpmdW5jdGlvbigpe2IudW5kby5ydW4oKX0scmVkbzpmdW5jdGlvbigpe2IudW5kby5yZWRvKCl9LGluZGVudDpmdW5jdGlvbigpe2YoMSl9LG91dGRlbnQ6ZnVuY3Rpb24oKXtmKC0xKX0sc2hvdzpmdW5jdGlvbigpe2Iub3B0cy50b29sYmFySW5saW5lJiZiLnRvb2xiYXIuc2hvd0lubGluZShudWxsLCEwKX0saW5zZXJ0SFI6ZnVuY3Rpb24oKXtiLnNlbGVjdGlvbi5yZW1vdmUoKTt2YXIgZD1cXFwiXFxcIjtiLmNvcmUuaXNFbXB0eSgpJiYoZD1cXFwiPGJyPlxcXCIsZD1jKGQpKSxiLmh0bWwuaW5zZXJ0KCc8aHIgaWQ9XFxcImZyLWp1c3RcXFwiPicrZCk7dmFyIGU9Yi4kZWwuZmluZChcXFwiaHIjZnItanVzdFxcXCIpO2UucmVtb3ZlQXR0cihcXFwiaWRcXFwiKTt2YXIgZjtlLnByZXYoKS5pcyhcXFwiaHJcXFwiKT9mPWIuc2VsZWN0aW9uLnNldEFmdGVyKGUuZ2V0KDApLCExKTplLm5leHQoKS5pcyhcXFwiaHJcXFwiKT9mPWIuc2VsZWN0aW9uLnNldEJlZm9yZShlLmdldCgwKSwhMSk6Yi5zZWxlY3Rpb24uc2V0QWZ0ZXIoZS5nZXQoMCksITEpfHxiLnNlbGVjdGlvbi5zZXRCZWZvcmUoZS5nZXQoMCksITEpLGZ8fFxcXCJ1bmRlZmluZWRcXFwiPT10eXBlb2YgZnx8KGQ9YS5GRS5NQVJLRVJTK1xcXCI8YnI+XFxcIixkPWMoZCksZS5hZnRlcihkKSksYi5zZWxlY3Rpb24ucmVzdG9yZSgpfSxjbGVhckZvcm1hdHRpbmc6ZnVuY3Rpb24oKXtiLmZvcm1hdC5yZW1vdmUoKX0sc2VsZWN0QWxsOmZ1bmN0aW9uKCl7Yi5kb2MuZXhlY0NvbW1hbmQoXFxcInNlbGVjdEFsbFxcXCIsITEsITEpfX0saj17fTtmb3IodmFyIGsgaW4gaSlpLmhhc093blByb3BlcnR5KGspJiYoaltrXT1nKGspKTtyZXR1cm4gYS5leHRlbmQoaix7ZXhlYzpkLF9pbml0Omh9KX0sYS5GRS5NT0RVTEVTLmRhdGE9ZnVuY3Rpb24oYSl7ZnVuY3Rpb24gYihhKXtyZXR1cm4gYX1mdW5jdGlvbiBjKGEpe2lmKCFhKXJldHVybiBhO2Zvcih2YXIgYz1cXFwiXFxcIixmPWIoXFxcImNoYXJDb2RlQXRcXFwiKSxnPWIoXFxcImZyb21DaGFyQ29kZVxcXCIpLGg9bC5pbmRleE9mKGFbMF0pLGk9MTtpPGEubGVuZ3RoLTI7aSsrKXtmb3IodmFyIGo9ZCgrK2gpLGs9YVtmXShpKSxtPVxcXCJcXFwiOy9bMC05LV0vLnRlc3QoYVtpKzFdKTspbSs9YVsrK2ldO209cGFyc2VJbnQobSwxMCl8fDAsaz1lKGssaixtKSxrXj1oLTEmMzEsYys9U3RyaW5nW2ddKGspfXJldHVybiBjfWZ1bmN0aW9uIGQoYSl7XFxuZm9yKHZhciBiPWEudG9TdHJpbmcoKSxjPTAsZD0wO2Q8Yi5sZW5ndGg7ZCsrKWMrPXBhcnNlSW50KGIuY2hhckF0KGQpLDEwKTtyZXR1cm4gYz4xMD9jJTkrMTpjfWZ1bmN0aW9uIGUoYSxiLGMpe2Zvcih2YXIgZD1NYXRoLmFicyhjKTtkLS0gPjA7KWEtPWI7cmV0dXJuIGM8MCYmKGErPTEyMyksYX1mdW5jdGlvbiBmKGEpe3JldHVybiEoIWF8fFxcXCJub25lXFxcIiE9YS5jc3MoXFxcImRpc3BsYXlcXFwiKXx8KGEucmVtb3ZlKCksMCkpfWZ1bmN0aW9uIGcoKXtyZXR1cm4gZihqKXx8ZihrKX1mdW5jdGlvbiBoKCl7cmV0dXJuISFhLiRib3gmJihhLiRib3guYXBwZW5kKG4oYihuKFxcXCJub0xEMmxhQi03TkIxQzFlYmN2SC05U0IzYTFDNlFDMkQ0QS05ZDFFMkIyQjR4Z0FFNEIyRzJJMUMzQTNCMnFNRjFERTFma3hmY0MtMTFDLTlnMUcyRTRYQzlhMUU1QTNHLTEwbXZyaW9DQzNBQTFLQTFxSi03TkIyTUE2c3hlcVZBNlRENmUyRDRCLTlyWUEyYTFBNGJDRDN2d0MtN0VDMTBEM0UybE5DMUtEMVFCOVNCNlVFNVRFNFlGM1lBNWMxQTNkMUIza0dFMmdGQTVBMkQyY2gxS0kxSUIxdGh5SDV3dlZDMTFVQjZjMUY0d3d3WEE3Z21uZkIyamdCMUE3bmQxZTFJQzJORzRIMUE5Ymp2bmJDLThQRzNtbGF6RDRkSC05SEkycUFBMmpHQzJJQTFkYWphakZENVNHNEo0YzFxdHR5Qi05d2cxQjJiMkE2YjFDM0VHM0IySTJyQ0Q0RTFCMUxHMW9hTUEzUkU3YWJDLThDLTdhVkE0QzVCNUYtMTFlMUQzSTNhNUE4aG1tbm9nSDJJQjVBMm5oa2dpQTRUSDRWQzd5eGRibEgtOFlDNkQ2QzR4QzN5cUpKMkMtMjFzcEItMTFmTUYxS0YxSUMyVVNDNFBHNFRFM1JENlpGNVhFM1VFM3VlZmFGRTREMkcyQUUxSEEySkQxenp6UUUzU0Q5dmdxRjR1YTNCMTNYQTRDNWdkMUUzRTJBMTRyaWRzbGRjQ0E3TUM1Z2h3RS0xMVpINWYxRDNhMUQ4Ynd4bWt6aTFBN0lCM0t2cEItOHJ3TUQzSUUxR0ctMTBiZ3F3eGV3dldFNEgzVmJELTE2cUMtMTFxYzFFMlR3RUE2QTNhQ0U0QTFBNGxPRDNKQzFpVkEzUkExM2MyRDhvbHFmMUczQTMyQjE3PT1cXFwiKSkpKSxqPWEuJGJveC5maW5kKFxcXCI+IGRpdjpsYXN0XFxcIiksaz1qLmZpbmQoXFxcIj4gYVxcXCIpLHZvaWQoXFxcInJ0bFxcXCI9PWEub3B0cy5kaXJlY3Rpb24mJmouY3NzKFxcXCJsZWZ0XFxcIixcXFwiYXV0b1xcXCIpLmNzcyhcXFwicmlnaHRcXFwiLDApKSl9ZnVuY3Rpb24gaSgpe3ZhciBjPWxvY2FsU3RvcmFnZSYmbG9jYWxTdG9yYWdlLkZFS3x8YS5vcHRzLmtleXx8W1xcXCJcXFwiXTtcXFwic3RyaW5nXFxcIj09dHlwZW9mIGMmJihjPVtjXSksYS51bD0hMDtmb3IodmFyIGQ9MDtkPGMubGVuZ3RoO2QrKyl7dmFyIGU9bihjW2RdKXx8XFxcIlxcXCI7aWYoIShlIT09bihiKG4oXFxcIm1jVlJEb0IxQkdJTEQ3WUZlMUJUWEJBN0I2PT1cXFwiKSkpJiZlLmluZGV4T2YobSxlLmxlbmd0aC1tLmxlbmd0aCk8MCYmW24oXFxcIjlxcUctN2Ftamx3cT09XFxcIiksbihcXFwiS0EzQjNDMkE2RDFENUg1SDFBMz09XFxcIiksbihcXFwiUXpienZ4eUIyeUEtOW09PVxcXCIpLG4oXFxcIm5hYW1uZ2lBM2RBLTE2eHRFLTExQy05QjFILThzYz09XFxcIildLmluZGV4T2YobSk8MCkpe2EudWw9ITE7YnJlYWt9fWEudWw9PT0hMCYmaCgpLGEuZXZlbnRzLm9uKFxcXCJjb250ZW50Q2hhbmdlZFxcXCIsZnVuY3Rpb24oKXthLnVsPT09ITAmJmcoKSYmaCgpfSksYS5ldmVudHMub24oXFxcImRlc3Ryb3lcXFwiLGZ1bmN0aW9uKCl7aiYmai5sZW5ndGgmJmoucmVtb3ZlKCl9LCEwKX12YXIgaixrLGw9XFxcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5XFxcIixtPWZ1bmN0aW9uKCl7Zm9yKHZhciBhPTAsYj1kb2N1bWVudC5kb21haW4sYz1iLnNwbGl0KFxcXCIuXFxcIiksZD1cXFwiX2dkXFxcIisobmV3IERhdGUpLmdldFRpbWUoKTthPGMubGVuZ3RoLTEmJmRvY3VtZW50LmNvb2tpZS5pbmRleE9mKGQrXFxcIj1cXFwiK2QpPT0tMTspYj1jLnNsaWNlKC0xLSsrYSkuam9pbihcXFwiLlxcXCIpLGRvY3VtZW50LmNvb2tpZT1kK1xcXCI9XFxcIitkK1xcXCI7ZG9tYWluPVxcXCIrYitcXFwiO1xcXCI7cmV0dXJuIGRvY3VtZW50LmNvb2tpZT1kK1xcXCI9O2V4cGlyZXM9VGh1LCAwMSBKYW4gMTk3MCAwMDowMDowMSBHTVQ7ZG9tYWluPVxcXCIrYitcXFwiO1xcXCIsKGJ8fFxcXCJcXFwiKS5yZXBsYWNlKC8oXlxcXFwuKil8KFxcXFwuKiQpL2csXFxcIlxcXCIpfSgpLG49YihjKTtyZXR1cm57X2luaXQ6aX19LGEuZXh0ZW5kKGEuRkUuREVGQVVMVFMse3Bhc3RlUGxhaW46ITEscGFzdGVEZW5pZWRUYWdzOltcXFwiY29sZ3JvdXBcXFwiLFxcXCJjb2xcXFwiXSxwYXN0ZURlbmllZEF0dHJzOltcXFwiY2xhc3NcXFwiLFxcXCJpZFxcXCIsXFxcInN0eWxlXFxcIl0scGFzdGVBbGxvd2VkU3R5bGVQcm9wczpbXFxcImZvbnQtZmFtaWx5XFxcIixcXFwiZm9udC1zaXplXFxcIixcXFwiYmFja2dyb3VuZFxcXCIsXFxcImNvbG9yXFxcIixcXFwid2lkdGhcXFwiLFxcXCJ0ZXh0LWFsaWduXFxcIixcXFwidmVydGljYWwtYWxpZ25cXFwiLFxcXCJiYWNrZ3JvdW5kLWNvbG9yXFxcIl0scGFzdGVBbGxvd0xvY2FsSW1hZ2VzOiExfSksYS5GRS5NT0RVTEVTLnBhc3RlPWZ1bmN0aW9uKGIpe2Z1bmN0aW9uIGMoYyl7YS5GRS5jb3BpZWRfaHRtbD1iLmh0bWwuZ2V0U2VsZWN0ZWQoKSxhLkZFLmNvcGllZF90ZXh0PWEoXFxcIjxkaXY+XFxcIikuaHRtbChhLkZFLmNvcGllZF9odG1sKS50ZXh0KCksXFxcImN1dFxcXCI9PWMudHlwZSYmKGIudW5kby5zYXZlU3RlcCgpLHNldFRpbWVvdXQoZnVuY3Rpb24oKXtiLnNlbGVjdGlvbi5zYXZlKCksYi5odG1sLndyYXAoKSxiLnNlbGVjdGlvbi5yZXN0b3JlKCksYi5ldmVudHMuZm9jdXMoKSxiLnVuZG8uc2F2ZVN0ZXAoKX0sMCkpfWZ1bmN0aW9uIGQoYSl7aWYocilyZXR1cm4hMTtpZihhLm9yaWdpbmFsRXZlbnQmJihhPWEub3JpZ2luYWxFdmVudCksYi5ldmVudHMudHJpZ2dlcihcXFwicGFzdGUuYmVmb3JlXFxcIixbYV0pPT09ITEpcmV0dXJuIGEucHJldmVudERlZmF1bHQoKSwhMTtpZihuPWIuJHdpbi5zY3JvbGxUb3AoKSxhJiZhLmNsaXBib2FyZERhdGEmJmEuY2xpcGJvYXJkRGF0YS5nZXREYXRhKXt2YXIgYz1cXFwiXFxcIixkPWEuY2xpcGJvYXJkRGF0YS50eXBlcztpZihiLmhlbHBlcnMuaXNBcnJheShkKSlmb3IodmFyIGY9MDtmPGQubGVuZ3RoO2YrKyljKz1kW2ZdK1xcXCI7XFxcIjtlbHNlIGM9ZDtpZihvPVxcXCJcXFwiLHA9YS5jbGlwYm9hcmREYXRhLmdldERhdGEoXFxcInRleHQvcnRmXFxcIiksL3RleHRcXFxcL2h0bWwvLnRlc3QoYyk/bz1hLmNsaXBib2FyZERhdGEuZ2V0RGF0YShcXFwidGV4dC9odG1sXFxcIik6L3RleHRcXFxcL3J0Zi8udGVzdChjKSYmYi5icm93c2VyLnNhZmFyaT9vPXA6L3RleHRcXFxcL3BsYWluLy50ZXN0KGMpJiYhdGhpcy5icm93c2VyLm1vemlsbGEmJihvPWIuaHRtbC5lc2NhcGVFbnRpdGllcyhhLmNsaXBib2FyZERhdGEuZ2V0RGF0YShcXFwidGV4dC9wbGFpblxcXCIpKS5yZXBsYWNlKC9cXFxcbi9nLFxcXCI8YnI+XFxcIikpLFxcXCJcXFwiIT09bylyZXR1cm4gaSgpLGEucHJldmVudERlZmF1bHQmJihhLnN0b3BQcm9wYWdhdGlvbigpLGEucHJldmVudERlZmF1bHQoKSksITE7bz1udWxsfWUoKX1mdW5jdGlvbiBlKCl7Yi5zZWxlY3Rpb24uc2F2ZSgpLGIuZXZlbnRzLmRpc2FibGVCbHVyKCksbz1udWxsLHE/cS5odG1sKFxcXCJcXFwiKToocT1hKCc8ZGl2IGNvbnRlbnRlZGl0YWJsZT1cXFwidHJ1ZVxcXCIgc3R5bGU9XFxcInBvc2l0aW9uOiBmaXhlZDsgdG9wOiAwOyBsZWZ0OiAtOTk5OXB4OyBoZWlnaHQ6IDEwMCU7IHdpZHRoOiAwOyB3b3JkLWJyZWFrOiBicmVhay1hbGw7IG92ZXJmbG93OmhpZGRlbjsgei1pbmRleDogOTk5OTsgbGluZS1oZWlnaHQ6IDE0MCU7XFxcIiB0YWJJbmRleD1cXFwiLTFcXFwiPjwvZGl2PicpLGIuJGJveC5hZnRlcihxKSxiLmV2ZW50cy5vbihcXFwiZGVzdHJveVxcXCIsZnVuY3Rpb24oKXtxLnJlbW92ZSgpfSkpLHEuZm9jdXMoKSxiLndpbi5zZXRUaW1lb3V0KGksMSl9ZnVuY3Rpb24gZihhKXt2YXIgYzthPWEucmVwbGFjZSgvPHAoLio/KWNsYXNzPVxcXCI/Jz9Nc29MaXN0UGFyYWdyYXBoXFxcIj8nPyAoW1xcXFxzXFxcXFNdKj8pPihbXFxcXHNcXFxcU10qPyk8XFxcXC9wPi9naSxcXFwiPHVsPjxsaT4kMzwvbGk+PC91bD5cXFwiKSxhPWEucmVwbGFjZSgvPHAoLio/KWNsYXNzPVxcXCI/Jz9OdW1iZXJlZFRleHRcXFwiPyc/IChbXFxcXHNcXFxcU10qPyk+KFtcXFxcc1xcXFxTXSo/KTxcXFxcL3A+L2dpLFxcXCI8b2w+PGxpPiQzPC9saT48L29sPlxcXCIpLGE9YS5yZXBsYWNlKC88cCguKj8pY2xhc3M9XFxcIj8nP01zb0xpc3RQYXJhZ3JhcGhDeFNwRmlyc3RcXFwiPyc/KFtcXFxcc1xcXFxTXSo/KShsZXZlbFxcXFxkKT8oW1xcXFxzXFxcXFNdKj8pPihbXFxcXHNcXFxcU10qPyk8XFxcXC9wPi9naSxcXFwiPHVsPjxsaSQzPiQ1PC9saT5cXFwiKSxhPWEucmVwbGFjZSgvPHAoLio/KWNsYXNzPVxcXCI/Jz9OdW1iZXJlZFRleHRDeFNwRmlyc3RcXFwiPyc/KFtcXFxcc1xcXFxTXSo/KShsZXZlbFxcXFxkKT8oW1xcXFxzXFxcXFNdKj8pPihbXFxcXHNcXFxcU10qPyk8XFxcXC9wPi9naSxcXFwiPG9sPjxsaSQzPiQ1PC9saT5cXFwiKSxhPWEucmVwbGFjZSgvPHAoLio/KWNsYXNzPVxcXCI/Jz9Nc29MaXN0UGFyYWdyYXBoQ3hTcE1pZGRsZVxcXCI/Jz8oW1xcXFxzXFxcXFNdKj8pKGxldmVsXFxcXGQpPyhbXFxcXHNcXFxcU10qPyk+KFtcXFxcc1xcXFxTXSo/KTxcXFxcL3A+L2dpLFxcXCI8bGkkMz4kNTwvbGk+XFxcIiksYT1hLnJlcGxhY2UoLzxwKC4qPyljbGFzcz1cXFwiPyc/TnVtYmVyZWRUZXh0Q3hTcE1pZGRsZVxcXCI/Jz8oW1xcXFxzXFxcXFNdKj8pKGxldmVsXFxcXGQpPyhbXFxcXHNcXFxcU10qPyk+KFtcXFxcc1xcXFxTXSo/KTxcXFxcL3A+L2dpLFxcXCI8bGkkMz4kNTwvbGk+XFxcIiksYT1hLnJlcGxhY2UoLzxwKC4qPyljbGFzcz1cXFwiPyc/TXNvTGlzdEJ1bGxldFxcXCI/Jz8oW1xcXFxzXFxcXFNdKj8pKGxldmVsXFxcXGQpPyhbXFxcXHNcXFxcU10qPyk+KFtcXFxcc1xcXFxTXSo/KTxcXFxcL3A+L2dpLFxcXCI8bGkkMz4kNTwvbGk+XFxcIiksYT1hLnJlcGxhY2UoLzxwKC4qPyljbGFzcz1cXFwiPyc/TXNvTGlzdFBhcmFncmFwaEN4U3BMYXN0XFxcIj8nPyhbXFxcXHNcXFxcU10qPykobGV2ZWxcXFxcZCk/KFtcXFxcc1xcXFxTXSo/KT4oW1xcXFxzXFxcXFNdKj8pPFxcXFwvcD4vZ2ksXFxcIjxsaSQzPiQ1PC9saT48L3VsPlxcXCIpLGE9YS5yZXBsYWNlKC88cCguKj8pY2xhc3M9XFxcIj8nP051bWJlcmVkVGV4dEN4U3BMYXN0XFxcIj8nPyhbXFxcXHNcXFxcU10qPykobGV2ZWxcXFxcZCk/KFtcXFxcc1xcXFxTXSo/KT4oW1xcXFxzXFxcXFNdKj8pPFxcXFwvcD4vZ2ksXFxcIjxsaSQzPiQ1PC9saT48L29sPlxcXCIpLGE9YS5yZXBsYWNlKC88c3BhbihbXjxdKj8pc3R5bGU9XFxcIj8nP21zby1saXN0Oklnbm9yZVxcXCI/Jz8oW1xcXFxzXFxcXFNdKj8pPihbXFxcXHNcXFxcU10qPyk8c3Bhbi9naSxcXFwiPHNwYW4+PHNwYW5cXFwiKSxhPWEucmVwbGFjZSgvPCEtLVxcXFxbaWYgXFxcXCFzdXBwb3J0TGlzdHNcXFxcXS0tPihbXFxcXHNcXFxcU10qPyk8IS0tXFxcXFtlbmRpZlxcXFxdLS0+L2dpLFxcXCJcXFwiKSxhPWEucmVwbGFjZSgvPCFcXFxcW2lmIFxcXFwhc3VwcG9ydExpc3RzXFxcXF0+KFtcXFxcc1xcXFxTXSo/KTwhXFxcXFtlbmRpZlxcXFxdPi9naSxcXFwiXFxcIiksYT1hLnJlcGxhY2UoLyhcXFxcbnxcXFxccnwgY2xhc3M9KFxcXCIpP01zb1thLXpBLVowLTldKyhcXFwiKT8pL2dpLFxcXCIgXFxcIiksYT1hLnJlcGxhY2UoLzwhLS1bXFxcXHNcXFxcU10qPy0tPi9naSxcXFwiXFxcIiksYT1hLnJlcGxhY2UoLzwoXFxcXC8pKihtZXRhfGxpbmt8c3BhbnxcXFxcXFxcXD94bWw6fHN0MTp8bzp8Zm9udCkoLio/KT4vZ2ksXFxcIlxcXCIpO3ZhciBkPVtcXFwic3R5bGVcXFwiLFxcXCJzY3JpcHRcXFwiLFxcXCJhcHBsZXRcXFwiLFxcXCJlbWJlZFxcXCIsXFxcIm5vZnJhbWVzXFxcIixcXFwibm9zY3JpcHRcXFwiXTtmb3IoYz0wO2M8ZC5sZW5ndGg7YysrKXt2YXIgZT1uZXcgUmVnRXhwKFxcXCI8XFxcIitkW2NdK1xcXCIuKj9cXFwiK2RbY10rXFxcIiguKj8pPlxcXCIsXFxcImdpXFxcIik7YT1hLnJlcGxhY2UoZSxcXFwiXFxcIil9YT1hLnJlcGxhY2UoLyZuYnNwOy9naSxcXFwiIFxcXCIpLGE9YS5yZXBsYWNlKC88dGQoW14+XSopPjxcXFxcL3RkPi9nLFxcXCI8dGQkMT48YnI+PC90ZD5cXFwiKSxhPWEucmVwbGFjZSgvPHRoKFtePl0qKT48XFxcXC90aD4vZyxcXFwiPHRoJDE+PGJyPjwvdGg+XFxcIik7dmFyIGY7ZG8gZj1hLGE9YS5yZXBsYWNlKC88W15cXFxcLz5dW14+XSo+PFxcXFwvW14+XSs+L2dpLFxcXCJcXFwiKTt3aGlsZShhIT1mKTthPWEucmVwbGFjZSgvPGxpbGV2ZWwoW14xXSkoW14+XSopPi9naSwnPGxpIGRhdGEtaW5kZW50PVxcXCJ0cnVlXFxcIiQyPicpLGE9YS5yZXBsYWNlKC88bGlsZXZlbDEoW14+XSopPi9naSxcXFwiPGxpJDE+XFxcIiksYT1iLmNsZWFuLmh0bWwoYSxiLm9wdHMucGFzdGVEZW5pZWRUYWdzLGIub3B0cy5wYXN0ZURlbmllZEF0dHJzKSxhPWEucmVwbGFjZSgvPGE+KC5bXjxdKyk8XFxcXC9hPi9naSxcXFwiJDFcXFwiKSxhPWEucmVwbGFjZSgvPGJyPiAqL2csXFxcIjxicj5cXFwiKTt2YXIgZz1iLm9fZG9jLmNyZWF0ZUVsZW1lbnQoXFxcImRpdlxcXCIpO2cuaW5uZXJIVE1MPWE7dmFyIGg9Zy5xdWVyeVNlbGVjdG9yQWxsKFxcXCJsaVtkYXRhLWluZGVudF1cXFwiKTtmb3IoYz0wO2M8aC5sZW5ndGg7YysrKXt2YXIgaT1oW2NdLGo9aS5wcmV2aW91c0VsZW1lbnRTaWJsaW5nO2lmKGomJlxcXCJMSVxcXCI9PWoudGFnTmFtZSl7dmFyIGs9ai5xdWVyeVNlbGVjdG9yKFxcXCI6c2NvcGUgPiB1bCwgOnNjb3BlID4gb2xcXFwiKTtrfHwoaz1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFxcXCJ1bFxcXCIpLGouYXBwZW5kQ2hpbGQoaykpLGsuYXBwZW5kQ2hpbGQoaSl9ZWxzZSBpLnJlbW92ZUF0dHJpYnV0ZShcXFwiZGF0YS1pbmRlbnRcXFwiKX1yZXR1cm4gYi5odG1sLmNsZWFuQmxhbmtTcGFjZXMoZyksYT1nLmlubmVySFRNTH1mdW5jdGlvbiBnKGEpe3ZhciBjLGQ9bnVsbCxlPWIuZG9jLmNyZWF0ZUVsZW1lbnQoXFxcImRpdlxcXCIpO2UuaW5uZXJIVE1MPWE7dmFyIGY9ZS5xdWVyeVNlbGVjdG9yQWxsKFxcXCJwLCBkaXYsIGgxLCBoMiwgaDMsIGg0LCBoNSwgaDYsIHByZSwgYmxvY2txdW90ZVxcXCIpO2ZvcihjPTA7YzxmLmxlbmd0aDtjKyspZD1mW2NdLGQub3V0ZXJIVE1MPVxcXCI8XFxcIisoYi5odG1sLmRlZmF1bHRUYWcoKXx8XFxcIkRJVlxcXCIpK1xcXCI+XFxcIitkLmlubmVySFRNTCtcXFwiPC9cXFwiKyhiLmh0bWwuZGVmYXVsdFRhZygpfHxcXFwiRElWXFxcIikrXFxcIj5cXFwiO2ZvcihmPWUucXVlcnlTZWxlY3RvckFsbChcXFwiKjpub3QoXFxcIitcXFwicCwgZGl2LCBoMSwgaDIsIGgzLCBoNCwgaDUsIGg2LCBwcmUsIGJsb2NrcXVvdGUsIHVsLCBvbCwgbGksIHRhYmxlLCB0Ym9keSwgdGhlYWQsIHRyLCB0ZCwgYnIsIGltZ1xcXCIuc3BsaXQoXFxcIixcXFwiKS5qb2luKFxcXCIpOm5vdChcXFwiKStcXFwiKVxcXCIpLGM9Zi5sZW5ndGgtMTtjPj0wO2MtLSlkPWZbY10sZC5vdXRlckhUTUw9ZC5pbm5lckhUTUw7dmFyIGc9ZnVuY3Rpb24oYSl7Zm9yKHZhciBjPWIubm9kZS5jb250ZW50cyhhKSxkPTA7ZDxjLmxlbmd0aDtkKyspY1tkXS5ub2RlVHlwZSE9Tm9kZS5URVhUX05PREUmJmNbZF0ubm9kZVR5cGUhPU5vZGUuRUxFTUVOVF9OT0RFP2NbZF0ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChjW2RdKTpnKGNbZF0pfTtyZXR1cm4gZyhlKSxlLmlubmVySFRNTH1mdW5jdGlvbiBoKGEpe3JldHVybiBhLm1hdGNoKC8oY2xhc3M9XFxcXFxcXCI/TXNvfGNsYXNzPVxcXFwnP01zb3xzdHlsZT1cXFxcXFxcIlteXFxcXFxcXCJdKlxcXFxibXNvXFxcXC18c3R5bGU9XFxcXCdbXlxcXFwnXSpcXFxcYm1zb1xcXFwtfHc6V29yZERvY3VtZW50KS9naSl9ZnVuY3Rpb24gaSgpe3ZhciBjLGQ9bnVsbCxlPW51bGw7Yi5rZXlzLmZvcmNlVW5kbygpO3ZhciBpPWIuc25hcHNob3QuZ2V0KCk7bnVsbD09PW8mJihvPXEuZ2V0KDApLmlubmVySFRNTCxiLnNlbGVjdGlvbi5yZXN0b3JlKCksYi5ldmVudHMuZW5hYmxlQmx1cigpKTt2YXIgaz1oKG8pLG09Yi5ldmVudHMuY2hhaW5UcmlnZ2VyKFxcXCJwYXN0ZS5iZWZvcmVDbGVhbnVwXFxcIixvKTtpZihtJiZcXFwic3RyaW5nXFxcIj09dHlwZW9mIG0mJihvPW0pLCFrKXt2YXIgbj1iLm9wdHMuaHRtbEFsbG93ZWRTdHlsZVByb3BzO2Iub3B0cy5odG1sQWxsb3dlZFN0eWxlUHJvcHM9Yi5vcHRzLnBhc3RlQWxsb3dlZFN0eWxlUHJvcHMsYi5vcHRzLmh0bWxBbGxvd0NvbW1lbnRzPSExLG89Yi5jbGVhbi5odG1sKG8sYi5vcHRzLnBhc3RlRGVuaWVkVGFncyxiLm9wdHMucGFzdGVEZW5pZWRBdHRycyksYi5vcHRzLmh0bWxBbGxvd2VkU3R5bGVQcm9wcz1uLGIub3B0cy5odG1sQWxsb3dDb21tZW50cz0hMCxvPWwobyksbz1vLnJlcGxhY2UoL1xcXFxyfFxcXFxufFxcXFx0L2csXFxcIlxcXCIpO3ZhciBwPWIuZG9jLmNyZWF0ZUVsZW1lbnQoXFxcImRpdlxcXCIpO3AuaW5uZXJIVE1MPW8sYS5GRS5jb3BpZWRfdGV4dCYmcC50ZXh0Q29udGVudC5yZXBsYWNlKC8oXFxcXHUwMEEwKS9naSxcXFwiIFxcXCIpLnJlcGxhY2UoL1xcXFxyfFxcXFxuL2dpLFxcXCJcXFwiKT09YS5GRS5jb3BpZWRfdGV4dC5yZXBsYWNlKC8oXFxcXHUwMEEwKS9naSxcXFwiIFxcXCIpLnJlcGxhY2UoL1xcXFxyfFxcXFxuL2dpLFxcXCJcXFwiKSYmKG89YS5GRS5jb3BpZWRfaHRtbCksbz1vLnJlcGxhY2UoL14gKi9nLFxcXCJcXFwiKS5yZXBsYWNlKC8gKiQvZyxcXFwiXFxcIil9by5pbmRleE9mKFxcXCI8Ym9keVxcXCIpPj0wJiYobz1vLnJlcGxhY2UoL1suXFxcXHNcXFxcU1xcXFx3XFxcXFc8Pl0qPGJvZHlbXj5dKj5bXFxcXHNdKihbLlxcXFxzXFxcXFNcXFxcd1xcXFxXPD5dKilcXFxcc10qPFxcXFwvYm9keT5bLlxcXFxzXFxcXFNcXFxcd1xcXFxXPD5dKi9nLFxcXCIkMVxcXCIpLG89by5yZXBsYWNlKC8oW14+XSlcXFxcbihbXjxdKS9nLFxcXCIkMSAkMlxcXCIpKTt2YXIgcj0hMTtpZihvLmluZGV4T2YoJ2lkPVxcXCJkb2NzLWludGVybmFsLWd1aWQnKT49MCYmKG89by5yZXBsYWNlKC9eLiogaWQ9XFxcImRvY3MtaW50ZXJuYWwtZ3VpZFtePl0qPiguKik8XFxcXC9iPi4qJC8sXFxcIiQxXFxcIikscj0hMCksayYmIWIud29yZFBhc3RlJiYobz1vLnJlcGxhY2UoL15cXFxcbiovZyxcXFwiXFxcIikucmVwbGFjZSgvXiAvZyxcXFwiXFxcIiksMD09PW8uaW5kZXhPZihcXFwiPGNvbGdyb3VwPlxcXCIpJiYobz1cXFwiPHRhYmxlPlxcXCIrbytcXFwiPC90YWJsZT5cXFwiKSxvPWYobyksbz1sKG8pKSxiLm9wdHMucGFzdGVQbGFpbiYmKG89ZyhvKSksbT1iLmV2ZW50cy5jaGFpblRyaWdnZXIoXFxcInBhc3RlLmFmdGVyQ2xlYW51cFxcXCIsbyksXFxcInN0cmluZ1xcXCI9PXR5cGVvZiBtJiYobz1tKSxcXFwiXFxcIiE9PW8pe3ZhciBzPWIub19kb2MuY3JlYXRlRWxlbWVudChcXFwiZGl2XFxcIik7cy5pbm5lckhUTUw9byxiLnNwYWNlcy5ub3JtYWxpemUocyk7dmFyIHQ9cy5nZXRFbGVtZW50c0J5VGFnTmFtZShcXFwic3BhblxcXCIpO2ZvcihjPXQubGVuZ3RoLTE7Yz49MDtjLS0pe3ZhciB1PXRbY107MD09PXUuYXR0cmlidXRlcy5sZW5ndGgmJih1Lm91dGVySFRNTD11LmlubmVySFRNTCl9dmFyIHY9cy5jaGlsZHJlbjtpZigxPT12Lmxlbmd0aCYmW1xcXCJPTFxcXCIsXFxcIlVMXFxcIl0uaW5kZXhPZih2WzBdLnRhZ05hbWUpPj0wJiYodlswXS5vdXRlckhUTUw9dlswXS5pbm5lckhUTUwpLCFyKXt2YXIgdz1zLmdldEVsZW1lbnRzQnlUYWdOYW1lKFxcXCJiclxcXCIpO2ZvcihjPXcubGVuZ3RoLTE7Yz49MDtjLS0pe3ZhciB4PXdbY107Yi5ub2RlLmlzQmxvY2soeC5wcmV2aW91c1NpYmxpbmcpJiZ4LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoeCl9fWlmKGIub3B0cy5lbnRlcj09YS5GRS5FTlRFUl9CUilmb3IoZD1zLnF1ZXJ5U2VsZWN0b3JBbGwoXFxcInAsIGRpdlxcXCIpLGM9ZC5sZW5ndGgtMTtjPj0wO2MtLSllPWRbY10sZS5vdXRlckhUTUw9ZS5pbm5lckhUTUwrKGUubmV4dFNpYmxpbmcmJiFiLm5vZGUuaXNFbXB0eShlKT9cXFwiPGJyPlxcXCI6XFxcIlxcXCIpO2Vsc2UgaWYoYi5vcHRzLmVudGVyPT1hLkZFLkVOVEVSX0RJVilmb3IoZD1zLmdldEVsZW1lbnRzQnlUYWdOYW1lKFxcXCJwXFxcIiksYz1kLmxlbmd0aC0xO2M+PTA7Yy0tKWU9ZFtjXSxlLm91dGVySFRNTD1cXFwiPGRpdj5cXFwiK2UuaW5uZXJIVE1MK1xcXCI8L2Rpdj5cXFwiO289cy5pbm5lckhUTUwsYi5odG1sLmluc2VydChvLCEwKX1qKCksYi51bmRvLnNhdmVTdGVwKGkpLGIudW5kby5zYXZlU3RlcCgpfWZ1bmN0aW9uIGooKXtiLmV2ZW50cy50cmlnZ2VyKFxcXCJwYXN0ZS5hZnRlclxcXCIpfWZ1bmN0aW9uIGsoKXtyZXR1cm4gcH1mdW5jdGlvbiBsKGEpe3ZhciBjLGQ9Yi5vX2RvYy5jcmVhdGVFbGVtZW50KFxcXCJkaXZcXFwiKTtkLmlubmVySFRNTD1hO2Zvcih2YXIgZT1kLnF1ZXJ5U2VsZWN0b3JBbGwoXFxcIio6ZW1wdHk6bm90KGJyKTpub3QoaW1nKTpub3QodGQpOm5vdCh0aClcXFwiKTtlLmxlbmd0aDspe2ZvcihjPTA7YzxlLmxlbmd0aDtjKyspZVtjXS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGVbY10pO2U9ZC5xdWVyeVNlbGVjdG9yQWxsKFxcXCIqOmVtcHR5Om5vdChicik6bm90KGltZyk6bm90KHRkKTpub3QodGgpXFxcIil9Zm9yKHZhciBmPWQucXVlcnlTZWxlY3RvckFsbChcXFwiOnNjb3BlID4gZGl2Om5vdChbc3R5bGVdKSwgdGQgPiBkaXY6bm90KFtzdHlsZV0pLCB0aCA+IGRpdjpub3QoW3N0eWxlXSksIGxpID4gZGl2Om5vdChbc3R5bGVdKVxcXCIpO2YubGVuZ3RoOyl7dmFyIGc9ZltmLmxlbmd0aC0xXTtpZihiLmh0bWwuZGVmYXVsdFRhZygpJiZcXFwiZGl2XFxcIiE9Yi5odG1sLmRlZmF1bHRUYWcoKSlnLnF1ZXJ5U2VsZWN0b3IoYi5odG1sLmJsb2NrVGFnc1F1ZXJ5KCkpP2cub3V0ZXJIVE1MPWcuaW5uZXJIVE1MOmcub3V0ZXJIVE1MPVxcXCI8XFxcIitiLmh0bWwuZGVmYXVsdFRhZygpK1xcXCI+XFxcIitnLmlubmVySFRNTCtcXFwiPC9cXFwiK2IuaHRtbC5kZWZhdWx0VGFnKCkrXFxcIj5cXFwiO2Vsc2V7dmFyIGg9Zy5xdWVyeVNlbGVjdG9yQWxsKFxcXCIqXFxcIik7aC5sZW5ndGgmJlxcXCJCUlxcXCI9PT1oW2gubGVuZ3RoLTFdLnRhZ05hbWU/Zy5vdXRlckhUTUw9Zy5pbm5lckhUTUw6Zy5vdXRlckhUTUw9Zy5pbm5lckhUTUwrXFxcIjxicj5cXFwifWY9ZC5xdWVyeVNlbGVjdG9yQWxsKFxcXCI6c2NvcGUgPiBkaXY6bm90KFtzdHlsZV0pLCB0ZCA+IGRpdjpub3QoW3N0eWxlXSksIHRoID4gZGl2Om5vdChbc3R5bGVdKSwgbGkgPiBkaXY6bm90KFtzdHlsZV0pXFxcIil9Zm9yKGY9ZC5xdWVyeVNlbGVjdG9yQWxsKFxcXCJkaXY6bm90KFtzdHlsZV0pXFxcIik7Zi5sZW5ndGg7KXtmb3IoYz0wO2M8Zi5sZW5ndGg7YysrKXt2YXIgaT1mW2NdLGo9aS5pbm5lckhUTUwucmVwbGFjZSgvXFxcXHUwMDA5L2dpLFxcXCJcXFwiKS50cmltKCk7aS5vdXRlckhUTUw9an1mPWQucXVlcnlTZWxlY3RvckFsbChcXFwiZGl2Om5vdChbc3R5bGVdKVxcXCIpfXJldHVybiBkLmlubmVySFRNTH1mdW5jdGlvbiBtKCl7Yi5ldmVudHMub24oXFxcImNvcHlcXFwiLGMpLGIuZXZlbnRzLm9uKFxcXCJjdXRcXFwiLGMpLGIuZXZlbnRzLm9uKFxcXCJwYXN0ZVxcXCIsZCksYi5icm93c2VyLm1zaWUmJmIuYnJvd3Nlci52ZXJzaW9uPDExJiYoYi5ldmVudHMub24oXFxcIm1vdXNldXBcXFwiLGZ1bmN0aW9uKGEpezI9PWEuYnV0dG9uJiYoc2V0VGltZW91dChmdW5jdGlvbigpe3I9ITF9LDUwKSxyPSEwKX0sITApLGIuZXZlbnRzLm9uKFxcXCJiZWZvcmVwYXN0ZVxcXCIsZCkpfXZhciBuLG8scCxxLHI9ITE7cmV0dXJue19pbml0Om0scmVtb3ZlRW1wdHlUYWdzOmwsZ2V0UnRmQ2xpcGJvYXJkOmssaXNXb3JkOmh9fSxhLmV4dGVuZChhLkZFLkRFRkFVTFRTLHtzaG9ydGN1dHNFbmFibGVkOltcXFwic2hvd1xcXCIsXFxcImJvbGRcXFwiLFxcXCJpdGFsaWNcXFwiLFxcXCJ1bmRlcmxpbmVcXFwiLFxcXCJzdHJpa2VUaHJvdWdoXFxcIixcXFwiaW5kZW50XFxcIixcXFwib3V0ZGVudFxcXCIsXFxcInVuZG9cXFwiLFxcXCJyZWRvXFxcIl0sc2hvcnRjdXRzSGludDohMH0pLGEuRkUuU0hPUlRDVVRTX01BUD17fSxhLkZFLlJlZ2lzdGVyU2hvcnRjdXQ9ZnVuY3Rpb24oYixjLGQsZSxmLGcpe2EuRkUuU0hPUlRDVVRTX01BUFsoZj9cXFwiXlxcXCI6XFxcIlxcXCIpKyhnP1xcXCJAXFxcIjpcXFwiXFxcIikrYl09e2NtZDpjLHZhbDpkLGxldHRlcjplLHNoaWZ0OmYsb3B0aW9uOmd9LGEuRkUuREVGQVVMVFMuc2hvcnRjdXRzRW5hYmxlZC5wdXNoKGMpfSxhLkZFLlJlZ2lzdGVyU2hvcnRjdXQoYS5GRS5LRVlDT0RFLkUsXFxcInNob3dcXFwiLG51bGwsXFxcIkVcXFwiLCExLCExKSxhLkZFLlJlZ2lzdGVyU2hvcnRjdXQoYS5GRS5LRVlDT0RFLkIsXFxcImJvbGRcXFwiLG51bGwsXFxcIkJcXFwiLCExLCExKSxhLkZFLlJlZ2lzdGVyU2hvcnRjdXQoYS5GRS5LRVlDT0RFLkksXFxcIml0YWxpY1xcXCIsbnVsbCxcXFwiSVxcXCIsITEsITEpLGEuRkUuUmVnaXN0ZXJTaG9ydGN1dChhLkZFLktFWUNPREUuVSxcXFwidW5kZXJsaW5lXFxcIixudWxsLFxcXCJVXFxcIiwhMSwhMSksYS5GRS5SZWdpc3RlclNob3J0Y3V0KGEuRkUuS0VZQ09ERS5TLFxcXCJzdHJpa2VUaHJvdWdoXFxcIixudWxsLFxcXCJTXFxcIiwhMSwhMSksYS5GRS5SZWdpc3RlclNob3J0Y3V0KGEuRkUuS0VZQ09ERS5DTE9TRV9TUVVBUkVfQlJBQ0tFVCxcXFwiaW5kZW50XFxcIixudWxsLFxcXCJdXFxcIiwhMSwhMSksYS5GRS5SZWdpc3RlclNob3J0Y3V0KGEuRkUuS0VZQ09ERS5PUEVOX1NRVUFSRV9CUkFDS0VULFxcXCJvdXRkZW50XFxcIixudWxsLFxcXCJbXFxcIiwhMSwhMSksYS5GRS5SZWdpc3RlclNob3J0Y3V0KGEuRkUuS0VZQ09ERS5aLFxcXCJ1bmRvXFxcIixudWxsLFxcXCJaXFxcIiwhMSwhMSksYS5GRS5SZWdpc3RlclNob3J0Y3V0KGEuRkUuS0VZQ09ERS5aLFxcXCJyZWRvXFxcIixudWxsLFxcXCJaXFxcIiwhMCwhMSksYS5GRS5NT0RVTEVTLnNob3J0Y3V0cz1mdW5jdGlvbihiKXtmdW5jdGlvbiBjKGMpe2lmKCFiLm9wdHMuc2hvcnRjdXRzSGludClyZXR1cm4gbnVsbDtpZighZil7Zj17fTtmb3IodmFyIGQgaW4gYS5GRS5TSE9SVENVVFNfTUFQKWEuRkUuU0hPUlRDVVRTX01BUC5oYXNPd25Qcm9wZXJ0eShkKSYmYi5vcHRzLnNob3J0Y3V0c0VuYWJsZWQuaW5kZXhPZihhLkZFLlNIT1JUQ1VUU19NQVBbZF0uY21kKT49MCYmKGZbYS5GRS5TSE9SVENVVFNfTUFQW2RdLmNtZCtcXFwiLlxcXCIrKGEuRkUuU0hPUlRDVVRTX01BUFtkXS52YWx8fFxcXCJcXFwiKV09e3NoaWZ0OmEuRkUuU0hPUlRDVVRTX01BUFtkXS5zaGlmdCxvcHRpb246YS5GRS5TSE9SVENVVFNfTUFQW2RdLm9wdGlvbixsZXR0ZXI6YS5GRS5TSE9SVENVVFNfTUFQW2RdLmxldHRlcn0pfXZhciBlPWZbY107cmV0dXJuIGU/KGIuaGVscGVycy5pc01hYygpP1N0cmluZy5mcm9tQ2hhckNvZGUoODk4NCk6XFxcIkN0cmwrXFxcIikrKGUuc2hpZnQ/Yi5oZWxwZXJzLmlzTWFjKCk/U3RyaW5nLmZyb21DaGFyQ29kZSg4Njc5KTpcXFwiU2hpZnQrXFxcIjpcXFwiXFxcIikrKGUub3B0aW9uP2IuaGVscGVycy5pc01hYygpP1N0cmluZy5mcm9tQ2hhckNvZGUoODk5Nyk6XFxcIkFsdCtcXFwiOlxcXCJcXFwiKStlLmxldHRlcjpudWxsfWZ1bmN0aW9uIGQoYyl7aWYoIWIuY29yZS5oYXNGb2N1cygpKXJldHVybiEwO3ZhciBkPWMud2hpY2gsZT1uYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoXFxcIk1hYyBPUyBYXFxcIikhPS0xP2MubWV0YUtleTpjLmN0cmxLZXk7aWYoXFxcImtleXVwXFxcIj09Yy50eXBlJiZnJiZkIT1hLkZFLktFWUNPREUuTUVUQSlyZXR1cm4gZz0hMSwhMTtcXFwia2V5ZG93blxcXCI9PWMudHlwZSYmKGc9ITEpO3ZhciBmPShjLnNoaWZ0S2V5P1xcXCJeXFxcIjpcXFwiXFxcIikrKGMuYWx0S2V5P1xcXCJAXFxcIjpcXFwiXFxcIikrZDtpZihlJiZhLkZFLlNIT1JUQ1VUU19NQVBbZl0pe3ZhciBoPWEuRkUuU0hPUlRDVVRTX01BUFtmXS5jbWQ7aWYoaCYmYi5vcHRzLnNob3J0Y3V0c0VuYWJsZWQuaW5kZXhPZihoKT49MCl7dmFyIGksaj1hLkZFLlNIT1JUQ1VUU19NQVBbZl0udmFsO2lmKGgmJiFqP2k9Yi4kdGIuZmluZCgnLmZyLWNvbW1hbmRbZGF0YS1jbWQ9XFxcIicraCsnXFxcIl0nKTpoJiZqJiYoaT1iLiR0Yi5maW5kKCcuZnItY29tbWFuZFtkYXRhLWNtZD1cXFwiJytoKydcXFwiXVtkYXRhLXBhcmFtMT1cXFwiJytqKydcXFwiXScpKSxpLmxlbmd0aClyZXR1cm4gYy5wcmV2ZW50RGVmYXVsdCgpLGMuc3RvcFByb3BhZ2F0aW9uKCksaS5wYXJlbnRzKFxcXCIuZnItdG9vbGJhclxcXCIpLmRhdGEoXFxcImluc3RhbmNlXFxcIixiKSxcXFwia2V5ZG93blxcXCI9PWMudHlwZSYmKGIuYnV0dG9uLmV4ZWMoaSksZz0hMCksITE7aWYoaCYmYi5jb21tYW5kc1toXSlyZXR1cm4gYy5wcmV2ZW50RGVmYXVsdCgpLGMuc3RvcFByb3BhZ2F0aW9uKCksXFxcImtleWRvd25cXFwiPT1jLnR5cGUmJihiLmNvbW1hbmRzW2hdKCksZz0hMCksITF9fX1mdW5jdGlvbiBlKCl7Yi5ldmVudHMub24oXFxcImtleWRvd25cXFwiLGQsITApLGIuZXZlbnRzLm9uKFxcXCJrZXl1cFxcXCIsZCwhMCl9dmFyIGY9bnVsbCxnPSExO3JldHVybntfaW5pdDplLGdldDpjfX0sYS5GRS5NT0RVTEVTLnNuYXBzaG90PWZ1bmN0aW9uKGEpe2Z1bmN0aW9uIGIoYSl7Zm9yKHZhciBiPWEucGFyZW50Tm9kZS5jaGlsZE5vZGVzLGM9MCxkPW51bGwsZT0wO2U8Yi5sZW5ndGg7ZSsrKXtpZihkKXt2YXIgZj1iW2VdLm5vZGVUeXBlPT09Tm9kZS5URVhUX05PREUmJlxcXCJcXFwiPT09YltlXS50ZXh0Q29udGVudCxnPWQubm9kZVR5cGU9PT1Ob2RlLlRFWFRfTk9ERSYmYltlXS5ub2RlVHlwZT09PU5vZGUuVEVYVF9OT0RFO2Z8fGd8fGMrK31pZihiW2VdPT1hKXJldHVybiBjO2Q9YltlXX19ZnVuY3Rpb24gYyhjKXt2YXIgZD1bXTtpZighYy5wYXJlbnROb2RlKXJldHVybltdO2Zvcig7IWEubm9kZS5pc0VsZW1lbnQoYyk7KWQucHVzaChiKGMpKSxjPWMucGFyZW50Tm9kZTtyZXR1cm4gZC5yZXZlcnNlKCl9ZnVuY3Rpb24gZChhLGIpe2Zvcig7YSYmYS5ub2RlVHlwZT09PU5vZGUuVEVYVF9OT0RFOyl7dmFyIGM9YS5wcmV2aW91c1NpYmxpbmc7YyYmYy5ub2RlVHlwZT09Tm9kZS5URVhUX05PREUmJihiKz1jLnRleHRDb250ZW50Lmxlbmd0aCksYT1jfXJldHVybiBifWZ1bmN0aW9uIGUoYSl7cmV0dXJue3NjTG9jOmMoYS5zdGFydENvbnRhaW5lciksc2NPZmZzZXQ6ZChhLnN0YXJ0Q29udGFpbmVyLGEuc3RhcnRPZmZzZXQpLGVjTG9jOmMoYS5lbmRDb250YWluZXIpLGVjT2Zmc2V0OmQoYS5lbmRDb250YWluZXIsYS5lbmRPZmZzZXQpfX1mdW5jdGlvbiBmKCl7dmFyIGI9e307aWYoYS5ldmVudHMudHJpZ2dlcihcXFwic25hcHNob3QuYmVmb3JlXFxcIiksYi5odG1sPShhLiR3cD9hLiRlbC5odG1sKCk6YS4kb2VsLmdldCgwKS5vdXRlckhUTUwpLnJlcGxhY2UoLyBzdHlsZT1cXFwiXFxcIi9nLFxcXCJcXFwiKSxiLnJhbmdlcz1bXSxhLiR3cCYmYS5zZWxlY3Rpb24uaW5FZGl0b3IoKSYmYS5jb3JlLmhhc0ZvY3VzKCkpZm9yKHZhciBjPWEuc2VsZWN0aW9uLnJhbmdlcygpLGQ9MDtkPGMubGVuZ3RoO2QrKyliLnJhbmdlcy5wdXNoKGUoY1tkXSkpO3JldHVybiBhLmV2ZW50cy50cmlnZ2VyKFxcXCJzbmFwc2hvdC5hZnRlclxcXCIpLGJ9ZnVuY3Rpb24gZyhiKXtmb3IodmFyIGM9YS5lbCxkPTA7ZDxiLmxlbmd0aDtkKyspYz1jLmNoaWxkTm9kZXNbYltkXV07cmV0dXJuIGN9ZnVuY3Rpb24gaChiLGMpe3RyeXt2YXIgZD1nKGMuc2NMb2MpLGU9Yy5zY09mZnNldCxmPWcoYy5lY0xvYyksaD1jLmVjT2Zmc2V0LGk9YS5kb2MuY3JlYXRlUmFuZ2UoKTtpLnNldFN0YXJ0KGQsZSksaS5zZXRFbmQoZixoKSxiLmFkZFJhbmdlKGkpfWNhdGNoKGope2NvbnNvbGUud2FybihqKX19ZnVuY3Rpb24gaShiKXthLiRlbC5odG1sKCkhPWIuaHRtbCYmYS4kZWwuaHRtbChiLmh0bWwpO3ZhciBjPWEuc2VsZWN0aW9uLmdldCgpO2Euc2VsZWN0aW9uLmNsZWFyKCksYS5ldmVudHMuZm9jdXMoITApO2Zvcih2YXIgZD0wO2Q8Yi5yYW5nZXMubGVuZ3RoO2QrKyloKGMsYi5yYW5nZXNbZF0pfWZ1bmN0aW9uIGooYixjKXtyZXR1cm4gYi5odG1sPT1jLmh0bWwmJighYS5jb3JlLmhhc0ZvY3VzKCl8fEpTT04uc3RyaW5naWZ5KGIucmFuZ2VzKT09SlNPTi5zdHJpbmdpZnkoYy5yYW5nZXMpKX1yZXR1cm57Z2V0OmYscmVzdG9yZTppLGVxdWFsOmp9fSxhLkZFLk1PRFVMRVMudW5kbz1mdW5jdGlvbihhKXtmdW5jdGlvbiBiKGIpe3ZhciBjPWIud2hpY2gsZD1hLmtleXMuY3RybEtleShiKTtkJiYoOTA9PWMmJmIuc2hpZnRLZXkmJmIucHJldmVudERlZmF1bHQoKSw5MD09YyYmYi5wcmV2ZW50RGVmYXVsdCgpKX1mdW5jdGlvbiBjKCl7cmV0dXJuISgwPT09YS51bmRvX3N0YWNrLmxlbmd0aHx8YS51bmRvX2luZGV4PD0xKX1mdW5jdGlvbiBkKCl7cmV0dXJuIGEudW5kb19pbmRleCE9YS51bmRvX3N0YWNrLmxlbmd0aH1mdW5jdGlvbiBlKGIpe3JldHVybiEoIWEudW5kb19zdGFja3x8YS51bmRvaW5nfHxhLmVsLnF1ZXJ5U2VsZWN0b3IoXFxcIi5mci1tYXJrZXJcXFwiKSkmJnZvaWQoXFxcInVuZGVmaW5lZFxcXCI9PXR5cGVvZiBiPyhiPWEuc25hcHNob3QuZ2V0KCksYS51bmRvX3N0YWNrW2EudW5kb19pbmRleC0xXSYmYS5zbmFwc2hvdC5lcXVhbChhLnVuZG9fc3RhY2tbYS51bmRvX2luZGV4LTFdLGIpfHwoZigpLGEudW5kb19zdGFjay5wdXNoKGIpLGEudW5kb19pbmRleCsrLGIuaHRtbCE9bCYmKGEuZXZlbnRzLnRyaWdnZXIoXFxcImNvbnRlbnRDaGFuZ2VkXFxcIiksbD1iLmh0bWwpKSk6KGYoKSxhLnVuZG9faW5kZXg+MD9hLnVuZG9fc3RhY2tbYS51bmRvX2luZGV4LTFdPWI6KGEudW5kb19zdGFjay5wdXNoKGIpLGEudW5kb19pbmRleCsrKSkpfWZ1bmN0aW9uIGYoKXtpZighYS51bmRvX3N0YWNrfHxhLnVuZG9pbmcpcmV0dXJuITE7Zm9yKDthLnVuZG9fc3RhY2subGVuZ3RoPmEudW5kb19pbmRleDspYS51bmRvX3N0YWNrLnBvcCgpfWZ1bmN0aW9uIGcoKXtpZihhLnVuZG9faW5kZXg+MSl7YS51bmRvaW5nPSEwO3ZhciBiPWEudW5kb19zdGFja1stLWEudW5kb19pbmRleC0xXTtjbGVhclRpbWVvdXQoYS5fY29udGVudF9jaGFuZ2VkX3RpbWVyKSxhLnNuYXBzaG90LnJlc3RvcmUoYiksbD1iLmh0bWwsYS5wb3B1cHMuaGlkZUFsbCgpLGEudG9vbGJhci5lbmFibGUoKSxhLmV2ZW50cy50cmlnZ2VyKFxcXCJjb250ZW50Q2hhbmdlZFxcXCIpLGEuZXZlbnRzLnRyaWdnZXIoXFxcImNvbW1hbmRzLnVuZG9cXFwiKSxhLnVuZG9pbmc9ITF9fWZ1bmN0aW9uIGgoKXtpZihhLnVuZG9faW5kZXg8YS51bmRvX3N0YWNrLmxlbmd0aCl7YS51bmRvaW5nPSEwO3ZhciBiPWEudW5kb19zdGFja1thLnVuZG9faW5kZXgrK107Y2xlYXJUaW1lb3V0KGEuX2NvbnRlbnRfY2hhbmdlZF90aW1lciksYS5zbmFwc2hvdC5yZXN0b3JlKGIpLGw9Yi5odG1sLGEucG9wdXBzLmhpZGVBbGwoKSxhLnRvb2xiYXIuZW5hYmxlKCksYS5ldmVudHMudHJpZ2dlcihcXFwiY29udGVudENoYW5nZWRcXFwiKSxhLmV2ZW50cy50cmlnZ2VyKFxcXCJjb21tYW5kcy5yZWRvXFxcIiksYS51bmRvaW5nPSExfX1mdW5jdGlvbiBpKCl7YS51bmRvX2luZGV4PTAsYS51bmRvX3N0YWNrPVtdfWZ1bmN0aW9uIGooKXthLnVuZG9fc3RhY2s9W119ZnVuY3Rpb24gaygpe2koKSxhLmV2ZW50cy5vbihcXFwiaW5pdGlhbGl6ZWRcXFwiLGZ1bmN0aW9uKCl7bD0oYS4kd3A/YS4kZWwuaHRtbCgpOmEuJG9lbC5nZXQoMCkub3V0ZXJIVE1MKS5yZXBsYWNlKC8gc3R5bGU9XFxcIlxcXCIvZyxcXFwiXFxcIil9KSxhLmV2ZW50cy5vbihcXFwiYmx1clxcXCIsZnVuY3Rpb24oKXthLmVsLnF1ZXJ5U2VsZWN0b3IoXFxcIi5mci1kcmFnZ2luZ1xcXCIpfHxhLnVuZG8uc2F2ZVN0ZXAoKX0pLGEuZXZlbnRzLm9uKFxcXCJrZXlkb3duXFxcIixiKSxhLmV2ZW50cy5vbihcXFwiZGVzdHJveVxcXCIsail9dmFyIGw9bnVsbDtyZXR1cm57X2luaXQ6ayxydW46ZyxyZWRvOmgsY2FuRG86YyxjYW5SZWRvOmQsZHJvcFJlZG86ZixyZXNldDppLHNhdmVTdGVwOmV9fSxhLkZFLklDT05fREVGQVVMVF9URU1QTEFURT1cXFwiZm9udF9hd2Vzb21lXFxcIixhLkZFLklDT05fVEVNUExBVEVTPXtmb250X2F3ZXNvbWU6JzxpIGNsYXNzPVxcXCJmYSBmYS1bTkFNRV1cXFwiIGFyaWEtaGlkZGVuPVxcXCJ0cnVlXFxcIj48L2k+Jyx0ZXh0Oic8c3BhbiBzdHlsZT1cXFwidGV4dC1hbGlnbjogY2VudGVyO1xcXCI+W05BTUVdPC9zcGFuPicsaW1hZ2U6XFxcIjxpbWcgc3JjPVtTUkNdIGFsdD1bQUxUXSAvPlxcXCIsc3ZnOic8c3ZnIHZpZXdCb3g9XFxcIjAgMCAzMiAzMlxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj5bUEFUSF08L3N2Zz4nfSxhLkZFLklDT05TPXtib2xkOntOQU1FOlxcXCJib2xkXFxcIn0saXRhbGljOntOQU1FOlxcXCJpdGFsaWNcXFwifSx1bmRlcmxpbmU6e05BTUU6XFxcInVuZGVybGluZVxcXCJ9LHN0cmlrZVRocm91Z2g6e05BTUU6XFxcInN0cmlrZXRocm91Z2hcXFwifSxzdWJzY3JpcHQ6e05BTUU6XFxcInN1YnNjcmlwdFxcXCJ9LHN1cGVyc2NyaXB0OntOQU1FOlxcXCJzdXBlcnNjcmlwdFxcXCJ9LGNvbG9yOntOQU1FOlxcXCJ0aW50XFxcIn0sb3V0ZGVudDp7TkFNRTpcXFwib3V0ZGVudFxcXCJ9LGluZGVudDp7TkFNRTpcXFwiaW5kZW50XFxcIn0sdW5kbzp7TkFNRTpcXFwicm90YXRlLWxlZnRcXFwifSxyZWRvOntOQU1FOlxcXCJyb3RhdGUtcmlnaHRcXFwifSxpbnNlcnRIUjp7TkFNRTpcXFwibWludXNcXFwifSxjbGVhckZvcm1hdHRpbmc6e05BTUU6XFxcImVyYXNlclxcXCJ9LHNlbGVjdEFsbDp7TkFNRTpcXFwibW91c2UtcG9pbnRlclxcXCJ9fSxhLkZFLkRlZmluZUljb25UZW1wbGF0ZT1mdW5jdGlvbihiLGMpe2EuRkUuSUNPTl9URU1QTEFURVNbYl09Y30sYS5GRS5EZWZpbmVJY29uPWZ1bmN0aW9uKGIsYyl7YS5GRS5JQ09OU1tiXT1jfSxhLkZFLk1PRFVMRVMuaWNvbj1mdW5jdGlvbigpe2Z1bmN0aW9uIGIoYil7dmFyIGM9bnVsbCxkPWEuRkUuSUNPTlNbYl07aWYoXFxcInVuZGVmaW5lZFxcXCIhPXR5cGVvZiBkKXt2YXIgZT1kLnRlbXBsYXRlfHxhLkZFLklDT05fREVGQVVMVF9URU1QTEFURTtlJiYoZT1hLkZFLklDT05fVEVNUExBVEVTW2VdKSYmKGM9ZS5yZXBsYWNlKC9cXFxcWyhbYS16QS1aXSopXFxcXF0vZyxmdW5jdGlvbihhLGMpe3JldHVyblxcXCJOQU1FXFxcIj09Yz9kW2NdfHxiOmRbY119KSl9cmV0dXJuIGN8fGJ9ZnVuY3Rpb24gYyhiKXt2YXIgYz1hLkZFLklDT05TW2JdLGQ9YS5GRS5JQ09OX0RFRkFVTFRfVEVNUExBVEU7cmV0dXJuXFxcInVuZGVmaW5lZFxcXCIhPXR5cGVvZiBjP2Q9Yy50ZW1wbGF0ZXx8YS5GRS5JQ09OX0RFRkFVTFRfVEVNUExBVEU6ZH1yZXR1cm57Y3JlYXRlOmIsZ2V0VGVtcGxhdGU6Y319LGEuZXh0ZW5kKGEuRkUuREVGQVVMVFMse3Rvb2x0aXBzOiEwfSksYS5GRS5NT0RVTEVTLnRvb2x0aXA9ZnVuY3Rpb24oYil7ZnVuY3Rpb24gYygpe2IuJHRvb2x0aXAmJmIuJHRvb2x0aXAucmVtb3ZlQ2xhc3MoXFxcImZyLXZpc2libGVcXFwiKS5jc3MoXFxcImxlZnRcXFwiLFxcXCItMzAwMHB4XFxcIikuY3NzKFxcXCJwb3NpdGlvblxcXCIsXFxcImZpeGVkXFxcIil9ZnVuY3Rpb24gZChjLGQpe2lmKGMuZGF0YShcXFwidGl0bGVcXFwiKXx8Yy5kYXRhKFxcXCJ0aXRsZVxcXCIsYy5hdHRyKFxcXCJ0aXRsZVxcXCIpKSwhYy5kYXRhKFxcXCJ0aXRsZVxcXCIpKXJldHVybiExO2IuJHRvb2x0aXB8fGYoKSxjLnJlbW92ZUF0dHIoXFxcInRpdGxlXFxcIiksYi4kdG9vbHRpcC50ZXh0KGMuZGF0YShcXFwidGl0bGVcXFwiKSksYi4kdG9vbHRpcC5hZGRDbGFzcyhcXFwiZnItdmlzaWJsZVxcXCIpO3ZhciBlPWMub2Zmc2V0KCkubGVmdCsoYy5vdXRlcldpZHRoKCktYi4kdG9vbHRpcC5vdXRlcldpZHRoKCkpLzI7ZTwwJiYoZT0wKSxlK2IuJHRvb2x0aXAub3V0ZXJXaWR0aCgpPmEoYi5vX3dpbikud2lkdGgoKSYmKGU9YShiLm9fd2luKS53aWR0aCgpLWIuJHRvb2x0aXAub3V0ZXJXaWR0aCgpKSxcXFwidW5kZWZpbmVkXFxcIj09dHlwZW9mIGQmJihkPWIub3B0cy50b29sYmFyQm90dG9tKTt2YXIgZz1kP2Mub2Zmc2V0KCkudG9wLWIuJHRvb2x0aXAuaGVpZ2h0KCk6Yy5vZmZzZXQoKS50b3ArYy5vdXRlckhlaWdodCgpO2IuJHRvb2x0aXAuY3NzKFxcXCJwb3NpdGlvblxcXCIsXFxcIlxcXCIpLGIuJHRvb2x0aXAuY3NzKFxcXCJsZWZ0XFxcIixlKSxiLiR0b29sdGlwLmNzcyhcXFwidG9wXFxcIixNYXRoLmNlaWwoZykpLFxcXCJzdGF0aWNcXFwiIT1hKGIub19kb2MpLmZpbmQoXFxcImJvZHlcXFwiKS5jc3MoXFxcInBvc2l0aW9uXFxcIik/KGIuJHRvb2x0aXAuY3NzKFxcXCJtYXJnaW4tbGVmdFxcXCIsLWEoYi5vX2RvYykuZmluZChcXFwiYm9keVxcXCIpLm9mZnNldCgpLmxlZnQpLGIuJHRvb2x0aXAuY3NzKFxcXCJtYXJnaW4tdG9wXFxcIiwtYShiLm9fZG9jKS5maW5kKFxcXCJib2R5XFxcIikub2Zmc2V0KCkudG9wKSk6KGIuJHRvb2x0aXAuY3NzKFxcXCJtYXJnaW4tbGVmdFxcXCIsXFxcIlxcXCIpLGIuJHRvb2x0aXAuY3NzKFxcXCJtYXJnaW4tdG9wXFxcIixcXFwiXFxcIikpfWZ1bmN0aW9uIGUoZSxmLGcpe2Iub3B0cy50b29sdGlwcyYmIWIuaGVscGVycy5pc01vYmlsZSgpJiYoYi5ldmVudHMuJG9uKGUsXFxcIm1vdXNlZW50ZXJcXFwiLGYsZnVuY3Rpb24oYyl7Yi5ub2RlLmhhc0NsYXNzKGMuY3VycmVudFRhcmdldCxcXFwiZnItZGlzYWJsZWRcXFwiKXx8Yi5lZGl0LmlzRGlzYWJsZWQoKXx8ZChhKGMuY3VycmVudFRhcmdldCksZyl9LCEwKSxiLmV2ZW50cy4kb24oZSxcXFwibW91c2VsZWF2ZSBcXFwiK2IuX21vdXNlZG93bitcXFwiIFxcXCIrYi5fbW91c2V1cCxmLGZ1bmN0aW9uKCl7YygpfSwhMCkpfWZ1bmN0aW9uIGYoKXtiLm9wdHMudG9vbHRpcHMmJiFiLmhlbHBlcnMuaXNNb2JpbGUoKSYmKGIuc2hhcmVkLiR0b29sdGlwP2IuJHRvb2x0aXA9Yi5zaGFyZWQuJHRvb2x0aXA6KGIuc2hhcmVkLiR0b29sdGlwPWEoJzxkaXYgY2xhc3M9XFxcImZyLXRvb2x0aXBcXFwiPjwvZGl2PicpLGIuJHRvb2x0aXA9Yi5zaGFyZWQuJHRvb2x0aXAsYi5vcHRzLnRoZW1lJiZiLiR0b29sdGlwLmFkZENsYXNzKGIub3B0cy50aGVtZStcXFwiLXRoZW1lXFxcIiksYShiLm9fZG9jKS5maW5kKFxcXCJib2R5XFxcIikuYXBwZW5kKGIuJHRvb2x0aXApKSxiLmV2ZW50cy5vbihcXFwic2hhcmVkLmRlc3Ryb3lcXFwiLGZ1bmN0aW9uKCl7Yi4kdG9vbHRpcC5odG1sKFxcXCJcXFwiKS5yZW1vdmVEYXRhKCkucmVtb3ZlKCksYi4kdG9vbHRpcD1udWxsfSwhMCkpfXJldHVybntoaWRlOmMsdG86ZCxiaW5kOmV9fSxhLkZFLk1PRFVMRVMuYnV0dG9uPWZ1bmN0aW9uKGIpe2Z1bmN0aW9uIGMoYixjLGQpe2Zvcih2YXIgZT1hKCksZj0wO2Y8Yi5sZW5ndGg7ZisrKXt2YXIgZz1hKGJbZl0pO2lmKGcuaXMoYykmJihlPWUuYWRkKGcpKSxkJiZnLmlzKFxcXCIuZnItZHJvcGRvd25cXFwiKSl7dmFyIGg9Zy5uZXh0KCkuZmluZChjKTtlPWUuYWRkKGgpfX1yZXR1cm4gZX1mdW5jdGlvbiBkKGQsZSl7dmFyIGYsZz1hKCk7aWYoIWQpcmV0dXJuIGc7Zz1nLmFkZChjKHYsZCxlKSksZz1nLmFkZChjKHcsZCxlKSk7Zm9yKGYgaW4gYi5zaGFyZWQucG9wdXBzKWlmKGIuc2hhcmVkLnBvcHVwcy5oYXNPd25Qcm9wZXJ0eShmKSl7dmFyIGg9Yi5zaGFyZWQucG9wdXBzW2ZdLGk9aC5jaGlsZHJlbigpLm5vdChcXFwiLmZyLWJ1dHRvbnNcXFwiKS5maW5kKGQpO2c9Zy5hZGQoaSl9Zm9yKGYgaW4gYi5zaGFyZWQubW9kYWxzKWlmKGIuc2hhcmVkLm1vZGFscy5oYXNPd25Qcm9wZXJ0eShmKSl7dmFyIGo9Yi5zaGFyZWQubW9kYWxzW2ZdLGs9ai4kbW9kYWwuZmluZChkKTtnPWcuYWRkKGspfXJldHVybiBnfWZ1bmN0aW9uIGUoYyl7dmFyIGU9Yy5uZXh0KCksZj1iLm5vZGUuaGFzQ2xhc3MoYy5nZXQoMCksXFxcImZyLWFjdGl2ZVxcXCIpLGc9ZChcXFwiLmZyLWRyb3Bkb3duLmZyLWFjdGl2ZVxcXCIpLm5vdChjKSxoPWMucGFyZW50cyhcXFwiLmZyLXRvb2xiYXIsIC5mci1wb3B1cFxcXCIpLmRhdGEoXFxcImluc3RhbmNlXFxcIil8fGI7aWYoaC5oZWxwZXJzLmlzSU9TKCkmJiFoLmVsLnF1ZXJ5U2VsZWN0b3IoXFxcIi5mci1tYXJrZXJcXFwiKSYmKGguc2VsZWN0aW9uLnNhdmUoKSxoLnNlbGVjdGlvbi5jbGVhcigpLGguc2VsZWN0aW9uLnJlc3RvcmUoKSksIWYpe3ZhciBpPWMuZGF0YShcXFwiY21kXFxcIik7ZS5maW5kKFxcXCIuZnItY29tbWFuZFxcXCIpLnJlbW92ZUNsYXNzKFxcXCJmci1hY3RpdmVcXFwiKS5hdHRyKFxcXCJhcmlhLXNlbGVjdGVkXFxcIiwhMSksYS5GRS5DT01NQU5EU1tpXSYmYS5GRS5DT01NQU5EU1tpXS5yZWZyZXNoT25TaG93JiZhLkZFLkNPTU1BTkRTW2ldLnJlZnJlc2hPblNob3cuYXBwbHkoaCxbYyxlXSksZS5jc3MoXFxcImxlZnRcXFwiLGMub2Zmc2V0KCkubGVmdC1jLnBhcmVudCgpLm9mZnNldCgpLmxlZnQtKFxcXCJydGxcXFwiPT1iLm9wdHMuZGlyZWN0aW9uP2Uud2lkdGgoKS1jLm91dGVyV2lkdGgoKTowKSksYi5vcHRzLnRvb2xiYXJCb3R0b20/ZS5jc3MoXFxcImJvdHRvbVxcXCIsYi4kdGIuaGVpZ2h0KCktYy5wb3NpdGlvbigpLnRvcCk6ZS5jc3MoXFxcInRvcFxcXCIsYy5wb3NpdGlvbigpLnRvcCtjLm91dGVySGVpZ2h0KCkpfWMuYWRkQ2xhc3MoXFxcImZyLWJsaW5rXFxcIikudG9nZ2xlQ2xhc3MoXFxcImZyLWFjdGl2ZVxcXCIpLGMuaGFzQ2xhc3MoXFxcImZyLWFjdGl2ZVxcXCIpPyhlLmF0dHIoXFxcImFyaWEtaGlkZGVuXFxcIiwhMSksYy5hdHRyKFxcXCJhcmlhLWV4cGFuZGVkXFxcIiwhMCkpOihlLmF0dHIoXFxcImFyaWEtaGlkZGVuXFxcIiwhMCksYy5hdHRyKFxcXCJhcmlhLWV4cGFuZGVkXFxcIiwhMSkpLHNldFRpbWVvdXQoZnVuY3Rpb24oKXtjLnJlbW92ZUNsYXNzKFxcXCJmci1ibGlua1xcXCIpfSwzMDApLGUub2Zmc2V0KCkubGVmdCtlLm91dGVyV2lkdGgoKT5iLiRzYy5vZmZzZXQoKS5sZWZ0K2IuJHNjLm91dGVyV2lkdGgoKSYmZS5jc3MoXFxcIm1hcmdpbi1sZWZ0XFxcIiwtKGUub2Zmc2V0KCkubGVmdCtlLm91dGVyV2lkdGgoKS1iLiRzYy5vZmZzZXQoKS5sZWZ0LWIuJHNjLm91dGVyV2lkdGgoKSkpLGcucmVtb3ZlQ2xhc3MoXFxcImZyLWFjdGl2ZVxcXCIpLmF0dHIoXFxcImFyaWEtZXhwYW5kZWRcXFwiLCExKS5uZXh0KCkuYXR0cihcXFwiYXJpYS1oaWRkZW5cXFwiLCEwKSxnLnBhcmVudChcXFwiLmZyLXRvb2xiYXI6bm90KC5mci1pbmxpbmUpXFxcIikuY3NzKFxcXCJ6SW5kZXhcXFwiLFxcXCJcXFwiKSwwIT09Yy5wYXJlbnRzKFxcXCIuZnItcG9wdXBcXFwiKS5sZW5ndGh8fGIub3B0cy50b29sYmFySW5saW5lfHwoYi5ub2RlLmhhc0NsYXNzKGMuZ2V0KDApLFxcXCJmci1hY3RpdmVcXFwiKT9iLiR0Yi5jc3MoXFxcInpJbmRleFxcXCIsKGIub3B0cy56SW5kZXh8fDEpKzQpOmIuJHRiLmNzcyhcXFwiekluZGV4XFxcIixcXFwiXFxcIikpO3ZhciBqPWUuZmluZChcXFwiYS5mci1jb21tYW5kLmZyLWFjdGl2ZTpmaXJzdFxcXCIpO2oubGVuZ3RoP2IuYWNjZXNzaWJpbGl0eS5mb2N1c1Rvb2xiYXJFbGVtZW50KGopOmIuYWNjZXNzaWJpbGl0eS5mb2N1c1Rvb2xiYXJFbGVtZW50KGMpfWZ1bmN0aW9uIGYoYSl7YS5hZGRDbGFzcyhcXFwiZnItYmxpbmtcXFwiKSxzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7YS5yZW1vdmVDbGFzcyhcXFwiZnItYmxpbmtcXFwiKX0sNTAwKTtmb3IodmFyIGI9YS5kYXRhKFxcXCJjbWRcXFwiKSxjPVtdO1xcXCJ1bmRlZmluZWRcXFwiIT10eXBlb2YgYS5kYXRhKFxcXCJwYXJhbVxcXCIrKGMubGVuZ3RoKzEpKTspYy5wdXNoKGEuZGF0YShcXFwicGFyYW1cXFwiKyhjLmxlbmd0aCsxKSkpO3ZhciBlPWQoXFxcIi5mci1kcm9wZG93bi5mci1hY3RpdmVcXFwiKTtlLmxlbmd0aCYmKGUucmVtb3ZlQ2xhc3MoXFxcImZyLWFjdGl2ZVxcXCIpLmF0dHIoXFxcImFyaWEtZXhwYW5kZWRcXFwiLCExKS5uZXh0KCkuYXR0cihcXFwiYXJpYS1oaWRkZW5cXFwiLCEwKSxlLnBhcmVudChcXFwiLmZyLXRvb2xiYXI6bm90KC5mci1pbmxpbmUpXFxcIikuY3NzKFxcXCJ6SW5kZXhcXFwiLFxcXCJcXFwiKSksYS5wYXJlbnRzKFxcXCIuZnItcG9wdXAsIC5mci10b29sYmFyXFxcIikuZGF0YShcXFwiaW5zdGFuY2VcXFwiKS5jb21tYW5kcy5leGVjKGIsYyl9ZnVuY3Rpb24gZyhhKXtmKGEpfWZ1bmN0aW9uIGgoYyl7dmFyIGQ9Yy5wYXJlbnRzKFxcXCIuZnItcG9wdXAsIC5mci10b29sYmFyXFxcIikuZGF0YShcXFwiaW5zdGFuY2VcXFwiKTtpZigwIT09Yy5wYXJlbnRzKFxcXCIuZnItcG9wdXBcXFwiKS5sZW5ndGh8fGMuZGF0YShcXFwicG9wdXBcXFwiKXx8ZC5wb3B1cHMuaGlkZUFsbCgpLGQucG9wdXBzLmFyZVZpc2libGUoKSYmIWQucG9wdXBzLmFyZVZpc2libGUoZCkpe2Zvcih2YXIgZj0wO2Y8YS5GRS5JTlNUQU5DRVMubGVuZ3RoO2YrKylhLkZFLklOU1RBTkNFU1tmXSE9ZCYmYS5GRS5JTlNUQU5DRVNbZl0ucG9wdXBzJiZhLkZFLklOU1RBTkNFU1tmXS5wb3B1cHMuYXJlVmlzaWJsZSgpJiZhLkZFLklOU1RBTkNFU1tmXS4kZWwuZmluZChcXFwiLmZyLW1hcmtlclxcXCIpLnJlbW92ZSgpO2QucG9wdXBzLmhpZGVBbGwoKX1iLm5vZGUuaGFzQ2xhc3MoYy5nZXQoMCksXFxcImZyLWRyb3Bkb3duXFxcIik/ZShjKTooZyhjKSxhLkZFLkNPTU1BTkRTW2MuZGF0YShcXFwiY21kXFxcIildJiZhLkZFLkNPTU1BTkRTW2MuZGF0YShcXFwiY21kXFxcIildLnJlZnJlc2hBZnRlckNhbGxiYWNrIT09ITEmJmQuYnV0dG9uLmJ1bGtSZWZyZXNoKCkpfWZ1bmN0aW9uIGkoYil7dmFyIGM9YShiLmN1cnJlbnRUYXJnZXQpO2goYyl9ZnVuY3Rpb24gaihhKXt2YXIgYj1hLmZpbmQoXFxcIi5mci1kcm9wZG93bi5mci1hY3RpdmVcXFwiKTtiLmxlbmd0aCYmKGIucmVtb3ZlQ2xhc3MoXFxcImZyLWFjdGl2ZVxcXCIpLmF0dHIoXFxcImFyaWEtZXhwYW5kZWRcXFwiLCExKS5uZXh0KCkuYXR0cihcXFwiYXJpYS1oaWRkZW5cXFwiLCEwKSxiLnBhcmVudChcXFwiLmZyLXRvb2xiYXI6bm90KC5mci1pbmxpbmUpXFxcIikuY3NzKFxcXCJ6SW5kZXhcXFwiLFxcXCJcXFwiKSl9ZnVuY3Rpb24gayhhKXthLnByZXZlbnREZWZhdWx0KCksYS5zdG9wUHJvcGFnYXRpb24oKX1mdW5jdGlvbiBsKGEpe2lmKGEuc3RvcFByb3BhZ2F0aW9uKCksIWIuaGVscGVycy5pc01vYmlsZSgpKXJldHVybiExfWZ1bmN0aW9uIG0oYyxkKXtiLmV2ZW50cy5iaW5kQ2xpY2soYyxcXFwiLmZyLWNvbW1hbmQ6bm90KC5mci1kaXNhYmxlZClcXFwiLGkpLGIuZXZlbnRzLiRvbihjLGIuX21vdXNlZG93bitcXFwiIFxcXCIrYi5fbW91c2V1cCtcXFwiIFxcXCIrYi5fbW92ZSxcXFwiLmZyLWRyb3Bkb3duLW1lbnVcXFwiLGssITApLGIuZXZlbnRzLiRvbihjLGIuX21vdXNlZG93bitcXFwiIFxcXCIrYi5fbW91c2V1cCtcXFwiIFxcXCIrYi5fbW92ZSxcXFwiLmZyLWRyb3Bkb3duLW1lbnUgLmZyLWRyb3Bkb3duLXdyYXBwZXJcXFwiLGwsITApO3ZhciBlPWMuZ2V0KDApLm93bmVyRG9jdW1lbnQsZj1cXFwiZGVmYXVsdFZpZXdcXFwiaW4gZT9lLmRlZmF1bHRWaWV3OmUucGFyZW50V2luZG93LGc9ZnVuY3Rpb24oZCl7KCFkfHxkLnR5cGU9PWIuX21vdXNldXAmJmQudGFyZ2V0IT1hKFxcXCJodG1sXFxcIikuZ2V0KDApfHxcXFwia2V5ZG93blxcXCI9PWQudHlwZSYmKGIua2V5cy5pc0NoYXJhY3RlcihkLndoaWNoKSYmIWIua2V5cy5jdHJsS2V5KGQpfHxkLndoaWNoPT1hLkZFLktFWUNPREUuRVNDKSkmJmooYyl9O2IuZXZlbnRzLiRvbihhKGYpLGIuX21vdXNldXArXFxcIiByZXNpemUga2V5ZG93blxcXCIsZywhMCksYi5vcHRzLmlmcmFtZSYmYi5ldmVudHMuJG9uKGIuJHdpbixiLl9tb3VzZXVwLGcsITApLGIubm9kZS5oYXNDbGFzcyhjLmdldCgwKSxcXFwiZnItcG9wdXBcXFwiKT9hLm1lcmdlKHcsYy5maW5kKFxcXCIuZnItYnRuXFxcIikudG9BcnJheSgpKTphLm1lcmdlKHYsYy5maW5kKFxcXCIuZnItYnRuXFxcIikudG9BcnJheSgpKSxiLnRvb2x0aXAuYmluZChjLFxcXCIuZnItYnRuLCAuZnItdGl0bGVcXFwiLGQpfWZ1bmN0aW9uIG4oYSxjKXt2YXIgZD1cXFwiXFxcIjtpZihjLmh0bWwpZCs9XFxcImZ1bmN0aW9uXFxcIj09dHlwZW9mIGMuaHRtbD9jLmh0bWwuY2FsbChiKTpjLmh0bWw7ZWxzZXt2YXIgZT1jLm9wdGlvbnM7XFxcImZ1bmN0aW9uXFxcIj09dHlwZW9mIGUmJihlPWUoKSksZCs9Jzx1bCBjbGFzcz1cXFwiZnItZHJvcGRvd24tbGlzdFxcXCIgcm9sZT1cXFwicHJlc2VudGF0aW9uXFxcIj4nO2Zvcih2YXIgZiBpbiBlKWlmKGUuaGFzT3duUHJvcGVydHkoZikpe3ZhciBnPWIuc2hvcnRjdXRzLmdldChhK1xcXCIuXFxcIitmKTtnPWc/JzxzcGFuIGNsYXNzPVxcXCJmci1zaG9ydGN1dFxcXCI+JytnK1xcXCI8L3NwYW4+XFxcIjpcXFwiXFxcIixkKz0nPGxpIHJvbGU9XFxcInByZXNlbnRhdGlvblxcXCI+PGEgY2xhc3M9XFxcImZyLWNvbW1hbmRcXFwiIHRhYkluZGV4PVxcXCItMVxcXCIgcm9sZT1cXFwib3B0aW9uXFxcIiBkYXRhLWNtZD1cXFwiJythKydcXFwiIGRhdGEtcGFyYW0xPVxcXCInK2YrJ1xcXCIgdGl0bGU9XFxcIicrZVtmXSsnXFxcIj4nK2IubGFuZ3VhZ2UudHJhbnNsYXRlKGVbZl0pK1xcXCI8L2E+PC9saT5cXFwifWQrPVxcXCI8L3VsPlxcXCJ9cmV0dXJuIGR9ZnVuY3Rpb24gbyhhLGMsZCl7aWYoYi5oZWxwZXJzLmlzTW9iaWxlKCkmJmMuc2hvd09uTW9iaWxlPT09ITEpcmV0dXJuXFxcIlxcXCI7dmFyIGU9Yy5kaXNwbGF5U2VsZWN0aW9uO1xcXCJmdW5jdGlvblxcXCI9PXR5cGVvZiBlJiYoZT1lKGIpKTt2YXIgZjtpZihlKXt2YXIgZz1cXFwiZnVuY3Rpb25cXFwiPT10eXBlb2YgYy5kZWZhdWx0U2VsZWN0aW9uP2MuZGVmYXVsdFNlbGVjdGlvbihiKTpjLmRlZmF1bHRTZWxlY3Rpb247Zj0nPHNwYW4gc3R5bGU9XFxcIndpZHRoOicrKGMuZGlzcGxheVNlbGVjdGlvbldpZHRofHwxMDApKydweFxcXCI+JysoZ3x8Yi5sYW5ndWFnZS50cmFuc2xhdGUoYy50aXRsZSkpK1xcXCI8L3NwYW4+XFxcIn1lbHNlIGY9Yi5pY29uLmNyZWF0ZShjLmljb258fGEpLGYrPSc8c3BhbiBjbGFzcz1cXFwiZnItc3Itb25seVxcXCI+JysoYi5sYW5ndWFnZS50cmFuc2xhdGUoYy50aXRsZSl8fFxcXCJcXFwiKStcXFwiPC9zcGFuPlxcXCI7dmFyIGg9Yy5wb3B1cD8nIGRhdGEtcG9wdXA9XFxcInRydWVcXFwiJzpcXFwiXFxcIixpPWMubW9kYWw/JyBkYXRhLW1vZGFsPVxcXCJ0cnVlXFxcIic6XFxcIlxcXCIsaj1iLnNob3J0Y3V0cy5nZXQoYStcXFwiLlxcXCIpO2o9aj9cXFwiIChcXFwiK2orXFxcIilcXFwiOlxcXCJcXFwiO3ZhciBrPWErXFxcIi1cXFwiK2IuaWQsbD0nPGJ1dHRvbiBpZD1cXFwiJytrKydcXFwidHlwZT1cXFwiYnV0dG9uXFxcIiB0YWJJbmRleD1cXFwiLTFcXFwiIHJvbGU9XFxcImJ1dHRvblxcXCInKyhjLnRvZ2dsZT8nIGFyaWEtcHJlc3NlZD1cXFwiZmFsc2VcXFwiJzpcXFwiXFxcIikrKFxcXCJkcm9wZG93blxcXCI9PWMudHlwZT8nIGFyaWEtY29udHJvbHM9XFxcImRyb3BcXFwiIGFyaWEtZXhwYW5kZWQ9XFxcImZhbHNlXFxcIiBhcmlhLWhhc3BvcHVwPVxcXCJ0cnVlXFxcIic6XFxcIlxcXCIpKyhjLmRpc2FibGVkPycgYXJpYS1kaXNhYmxlZD1cXFwidHJ1ZVxcXCInOlxcXCJcXFwiKSsnIHRpdGxlPVxcXCInKyhiLmxhbmd1YWdlLnRyYW5zbGF0ZShjLnRpdGxlKXx8XFxcIlxcXCIpK2orJ1xcXCIgY2xhc3M9XFxcImZyLWNvbW1hbmQgZnItYnRuJysoXFxcImRyb3Bkb3duXFxcIj09Yy50eXBlP1xcXCIgZnItZHJvcGRvd25cXFwiOlxcXCJcXFwiKSsoXFxcIiBmci1idG4tXFxcIitiLmljb24uZ2V0VGVtcGxhdGUoYy5pY29uKSkrKGMuZGlzcGxheVNlbGVjdGlvbj9cXFwiIGZyLXNlbGVjdGlvblxcXCI6XFxcIlxcXCIpKyhjLmJhY2s/XFxcIiBmci1iYWNrXFxcIjpcXFwiXFxcIikrKGMuZGlzYWJsZWQ/XFxcIiBmci1kaXNhYmxlZFxcXCI6XFxcIlxcXCIpKyhkP1xcXCJcXFwiOlxcXCIgZnItaGlkZGVuXFxcIikrJ1xcXCIgZGF0YS1jbWQ9XFxcIicrYSsnXFxcIicraCtpK1xcXCI+XFxcIitmK1xcXCI8L2J1dHRvbj5cXFwiO2lmKFxcXCJkcm9wZG93blxcXCI9PWMudHlwZSl7dmFyIG09JzxkaXYgY2xhc3M9XFxcImZyLWRyb3Bkb3duLW1lbnVcXFwiIHJvbGU9XFxcImxpc3Rib3hcXFwiIGFyaWEtbGFiZWxsZWRieT1cXFwiJytrKydcXFwiIGFyaWEtaGlkZGVuPVxcXCJ0cnVlXFxcIj48ZGl2IGNsYXNzPVxcXCJmci1kcm9wZG93bi13cmFwcGVyXFxcIiByb2xlPVxcXCJwcmVzZW50YXRpb25cXFwiPjxkaXYgY2xhc3M9XFxcImZyLWRyb3Bkb3duLWNvbnRlbnRcXFwiIHJvbGU9XFxcInByZXNlbnRhdGlvblxcXCI+JzttKz1uKGEsYyksbSs9XFxcIjwvZGl2PjwvZGl2PjwvZGl2PlxcXCIsbCs9bX1yZXR1cm4gbH1mdW5jdGlvbiBwKGMsZCl7Zm9yKHZhciBlPVxcXCJcXFwiLGY9MDtmPGMubGVuZ3RoO2YrKyl7dmFyIGc9Y1tmXSxoPWEuRkUuQ09NTUFORFNbZ107aWYoIShoJiZcXFwidW5kZWZpbmVkXFxcIiE9dHlwZW9mIGgucGx1Z2luJiZiLm9wdHMucGx1Z2luc0VuYWJsZWQuaW5kZXhPZihoLnBsdWdpbik8MCkpaWYoaCl7dmFyIGk9XFxcInVuZGVmaW5lZFxcXCI9PXR5cGVvZiBkfHxkLmluZGV4T2YoZyk+PTA7ZSs9byhnLGgsaSl9ZWxzZVxcXCJ8XFxcIj09Zz9lKz0nPGRpdiBjbGFzcz1cXFwiZnItc2VwYXJhdG9yIGZyLXZzXFxcIiByb2xlPVxcXCJzZXBhcmF0b3JcXFwiIGFyaWEtb3JpZW50YXRpb249XFxcInZlcnRpY2FsXFxcIj48L2Rpdj4nOlxcXCItXFxcIj09ZyYmKGUrPSc8ZGl2IGNsYXNzPVxcXCJmci1zZXBhcmF0b3IgZnItaHNcXFwiIHJvbGU9XFxcInNlcGFyYXRvclxcXCIgYXJpYS1vcmllbnRhdGlvbj1cXFwiaG9yaXpvbnRhbFxcXCI+PC9kaXY+Jyl9cmV0dXJuIGV9ZnVuY3Rpb24gcShjKXt2YXIgZCxlPWMucGFyZW50cyhcXFwiLmZyLXBvcHVwLCAuZnItdG9vbGJhclxcXCIpLmRhdGEoXFxcImluc3RhbmNlXFxcIil8fGIsZj1jLmRhdGEoXFxcImNtZFxcXCIpO2Iubm9kZS5oYXNDbGFzcyhjLmdldCgwKSxcXFwiZnItZHJvcGRvd25cXFwiKT9kPWMubmV4dCgpOihjLnJlbW92ZUNsYXNzKFxcXCJmci1hY3RpdmVcXFwiKSxjLmF0dHIoXFxcImFyaWEtcHJlc3NlZFxcXCIpJiZjLmF0dHIoXFxcImFyaWEtcHJlc3NlZFxcXCIsITEpKSxhLkZFLkNPTU1BTkRTW2ZdJiZhLkZFLkNPTU1BTkRTW2ZdLnJlZnJlc2g/YS5GRS5DT01NQU5EU1tmXS5yZWZyZXNoLmFwcGx5KGUsW2MsZF0pOmIucmVmcmVzaFtmXSYmZS5yZWZyZXNoW2ZdKGMsZCl9ZnVuY3Rpb24gcihjKXt2YXIgZD1iLiR0Yj9iLiR0Yi5kYXRhKFxcXCJpbnN0YW5jZVxcXCIpfHxiOmI7cmV0dXJuIGIuZXZlbnRzLnRyaWdnZXIoXFxcImJ1dHRvbnMucmVmcmVzaFxcXCIpPT09ITF8fHZvaWQgc2V0VGltZW91dChmdW5jdGlvbigpe2Zvcih2YXIgZT1kLnNlbGVjdGlvbi5pbkVkaXRvcigpJiZkLmNvcmUuaGFzRm9jdXMoKSxmPTA7ZjxjLmxlbmd0aDtmKyspe3ZhciBnPWEoY1tmXSksaD1nLmRhdGEoXFxcImNtZFxcXCIpOzA9PT1nLnBhcmVudHMoXFxcIi5mci1wb3B1cFxcXCIpLmxlbmd0aD9lfHxhLkZFLkNPTU1BTkRTW2hdJiZhLkZFLkNPTU1BTkRTW2hdLmZvcmNlZFJlZnJlc2g/ZC5idXR0b24ucmVmcmVzaChnKTpiLm5vZGUuaGFzQ2xhc3MoZy5nZXQoMCksXFxcImZyLWRyb3Bkb3duXFxcIil8fChnLnJlbW92ZUNsYXNzKFxcXCJmci1hY3RpdmVcXFwiKSxnLmF0dHIoXFxcImFyaWEtcHJlc3NlZFxcXCIpJiZnLmF0dHIoXFxcImFyaWEtcHJlc3NlZFxcXCIsITEpKTpnLnBhcmVudHMoXFxcIi5mci1wb3B1cFxcXCIpLmlzKFxcXCI6dmlzaWJsZVxcXCIpJiZkLmJ1dHRvbi5yZWZyZXNoKGcpfX0sMCl9ZnVuY3Rpb24gcygpe3Iodikscih3KX1mdW5jdGlvbiB0KCl7dj1bXSx3PVtdfWZ1bmN0aW9uIHUoKXtiLm9wdHMudG9vbGJhcklubGluZT9iLmV2ZW50cy5vbihcXFwidG9vbGJhci5zaG93XFxcIixzKTooYi5ldmVudHMub24oXFxcIm1vdXNldXBcXFwiLHMpLGIuZXZlbnRzLm9uKFxcXCJrZXl1cFxcXCIscyksYi5ldmVudHMub24oXFxcImJsdXJcXFwiLHMpLGIuZXZlbnRzLm9uKFxcXCJmb2N1c1xcXCIscyksYi5ldmVudHMub24oXFxcImNvbnRlbnRDaGFuZ2VkXFxcIixzKSksYi5ldmVudHMub24oXFxcInNoYXJlZC5kZXN0cm95XFxcIix0KX12YXIgdj1bXTsoYi5vcHRzLnRvb2xiYXJJbmxpbmV8fGIub3B0cy50b29sYmFyQ29udGFpbmVyKSYmKGIuc2hhcmVkLmJ1dHRvbnN8fChiLnNoYXJlZC5idXR0b25zPVtdKSx2PWIuc2hhcmVkLmJ1dHRvbnMpO3ZhciB3PVtdO3JldHVybiBiLnNoYXJlZC5wb3B1cF9idXR0b25zfHwoYi5zaGFyZWQucG9wdXBfYnV0dG9ucz1bXSksdz1iLnNoYXJlZC5wb3B1cF9idXR0b25zLHtfaW5pdDp1LGJ1aWxkTGlzdDpwLGJpbmRDb21tYW5kczptLHJlZnJlc2g6cSxidWxrUmVmcmVzaDpzLGV4ZWM6ZixjbGljazpoLGhpZGVBY3RpdmVEcm9wZG93bnM6aixnZXRCdXR0b25zOmR9fSxhLkZFLk1PRFVMRVMubW9kYWxzPWZ1bmN0aW9uKGIpe2Z1bmN0aW9uIGMoYSl7cmV0dXJuIG5bYV19ZnVuY3Rpb24gZChjLGQpe3ZhciBlPSc8ZGl2IHRhYkluZGV4PVxcXCItMVxcXCIgY2xhc3M9XFxcImZyLW1vZGFsJysoYi5vcHRzLnRoZW1lP1xcXCIgXFxcIitiLm9wdHMudGhlbWUrXFxcIi10aGVtZVxcXCI6XFxcIlxcXCIpKydcXFwiPjxkaXYgY2xhc3M9XFxcImZyLW1vZGFsLXdyYXBwZXJcXFwiPicsZj0nPGkgdGl0bGU9XFxcIicrYi5sYW5ndWFnZS50cmFuc2xhdGUoXFxcIkNhbmNlbFxcXCIpKydcXFwiIGNsYXNzPVxcXCJmYSBmYS10aW1lcyBmci1tb2RhbC1jbG9zZVxcXCI+PC9pPic7cmV0dXJuIGUrPSc8ZGl2IGNsYXNzPVxcXCJmci1tb2RhbC1oZWFkXFxcIj4nK2MrZitcXFwiPC9kaXY+XFxcIixlKz0nPGRpdiB0YWJJbmRleD1cXFwiLTFcXFwiIGNsYXNzPVxcXCJmci1tb2RhbC1ib2R5XFxcIj4nK2QrXFxcIjwvZGl2PlxcXCIsZSs9XFxcIjwvZGl2PjwvZGl2PlxcXCIsYShlKX1mdW5jdGlvbiBlKGMsZSxmKXtpZihiLnNoYXJlZC4kb3ZlcmxheXx8KGIuc2hhcmVkLiRvdmVybGF5PWEoJzxkaXYgY2xhc3M9XFxcImZyLW92ZXJsYXlcXFwiPicpLmFwcGVuZFRvKFxcXCJib2R5XFxcIikpLG09Yi5zaGFyZWQuJG92ZXJsYXksYi5vcHRzLnRoZW1lJiZtLmFkZENsYXNzKGIub3B0cy50aGVtZStcXFwiLXRoZW1lXFxcIiksIW5bY10pe3ZhciBnPWQoZSxmKTtuW2NdPXskbW9kYWw6ZywkaGVhZDpnLmZpbmQoXFxcIi5mci1tb2RhbC1oZWFkXFxcIiksJGJvZHk6Zy5maW5kKFxcXCIuZnItbW9kYWwtYm9keVxcXCIpfSxiLmhlbHBlcnMuaXNNb2JpbGUoKXx8Zy5hZGRDbGFzcyhcXFwiZnItZGVza3RvcFxcXCIpLGcuYXBwZW5kVG8oXFxcImJvZHlcXFwiKSxiLmV2ZW50cy5iaW5kQ2xpY2soZyxcXFwiaS5mci1tb2RhbC1jbG9zZVxcXCIsZnVuY3Rpb24oKXtoKGMpfSksbltjXS4kYm9keS5jc3MoXFxcIm1hcmdpbi10b3BcXFwiLG5bY10uJGhlYWQub3V0ZXJIZWlnaHQoKSksYi5ldmVudHMuJG9uKGcsXFxcImtleWRvd25cXFwiLGZ1bmN0aW9uKGQpe3ZhciBlPWQud2hpY2g7cmV0dXJuIGU9PWEuRkUuS0VZQ09ERS5FU0M/KGgoYyksYi5hY2Nlc3NpYmlsaXR5LmZvY3VzTW9kYWxCdXR0b24oZyksITEpOiEoIWEoZC5jdXJyZW50VGFyZ2V0KS5pcyhcXFwiaW5wdXRbdHlwZT10ZXh0XSwgdGV4dGFyZWFcXFwiKSYmZSE9YS5GRS5LRVlDT0RFLkFSUk9XX1VQJiZlIT1hLkZFLktFWUNPREUuQVJST1dfRE9XTiYmIWIua2V5cy5pc0Jyb3dzZXJBY3Rpb24oZCkpfHwoZC5wcmV2ZW50RGVmYXVsdCgpLGQuc3RvcFByb3BhZ2F0aW9uKCksITEpfSwhMCksaChjLCEwKX1yZXR1cm4gbltjXX1mdW5jdGlvbiBmKCl7Zm9yKHZhciBhIGluIG4pe3ZhciBiPW5bYV07YiYmYi4kbW9kYWwmJmIuJG1vZGFsLnJlbW92ZURhdGEoKS5yZW1vdmUoKX1tJiZtLnJlbW92ZURhdGEoKS5yZW1vdmUoKSxuPXt9fWZ1bmN0aW9uIGcoYSl7aWYoblthXSl7dmFyIGM9blthXS4kbW9kYWw7Yy5kYXRhKFxcXCJpbnN0YW5jZVxcXCIsYiksYy5zaG93KCksbS5zaG93KCksYi4kZG9jLmZpbmQoXFxcImJvZHlcXFwiKS5hZGRDbGFzcyhcXFwicHJldmVudC1zY3JvbGxcXFwiKSxiLmhlbHBlcnMuaXNNb2JpbGUoKSYmYi4kZG9jLmZpbmQoXFxcImJvZHlcXFwiKS5hZGRDbGFzcyhcXFwiZnItbW9iaWxlXFxcIiksYy5hZGRDbGFzcyhcXFwiZnItYWN0aXZlXFxcIiksYi5hY2Nlc3NpYmlsaXR5LmZvY3VzTW9kYWwoYyl9fWZ1bmN0aW9uIGgoYSxjKXtpZihuW2FdKXt2YXIgZD1uW2FdLiRtb2RhbCxlPWQuZGF0YShcXFwiaW5zdGFuY2VcXFwiKXx8YjtlLmV2ZW50cy5lbmFibGVCbHVyKCksZC5oaWRlKCksbS5oaWRlKCksZS4kZG9jLmZpbmQoXFxcImJvZHlcXFwiKS5yZW1vdmVDbGFzcyhcXFwicHJldmVudC1zY3JvbGwgZnItbW9iaWxlXFxcIiksZC5yZW1vdmVDbGFzcyhcXFwiZnItYWN0aXZlXFxcIiksY3x8KGIuYWNjZXNzaWJpbGl0eS5yZXN0b3JlU2VsZWN0aW9uKGUpLGIuZXZlbnRzLnRyaWdnZXIoXFxcIm1vZGFscy5oaWRlXFxcIikpfX1mdW5jdGlvbiBpKGEpe2lmKG5bYV0pe3ZhciBjPW5bYV0sZD1jLiRtb2RhbCxlPWMuJGJvZHksZj1iLiR3aW4uaGVpZ2h0KCksZz1kLmZpbmQoXFxcIi5mci1tb2RhbC13cmFwcGVyXFxcIiksaD1nLm91dGVySGVpZ2h0KCEwKSxpPWcuaGVpZ2h0KCktKGUub3V0ZXJIZWlnaHQoITApLWUuaGVpZ2h0KCkpLGo9Zi1oK2ksaz1lLmdldCgwKS5zY3JvbGxIZWlnaHQsbD1cXFwiYXV0b1xcXCI7az5qJiYobD1qKSxlLmhlaWdodChsKX19ZnVuY3Rpb24gaihhKXt2YXIgYztpZihcXFwic3RyaW5nXFxcIj09dHlwZW9mIGEpe2lmKCFuW2FdKXJldHVybjtjPW5bYV0uJG1vZGFsfWVsc2UgYz1hO3JldHVybiBjJiZiLm5vZGUuaGFzQ2xhc3MoYyxcXFwiZnItYWN0aXZlXFxcIikmJmIuY29yZS5zYW1lSW5zdGFuY2UoYyl8fCExfWZ1bmN0aW9uIGsoYSl7Zm9yKHZhciBiIGluIG4paWYobi5oYXNPd25Qcm9wZXJ0eShiKSYmaihiKSYmKFxcXCJ1bmRlZmluZWRcXFwiPT10eXBlb2YgYXx8bltiXS4kbW9kYWwuZGF0YShcXFwiaW5zdGFuY2VcXFwiKT09YSkpcmV0dXJuIG5bYl0uJG1vZGFsO3JldHVybiExfWZ1bmN0aW9uIGwoKXtiLmV2ZW50cy5vbihcXFwic2hhcmVkLmRlc3Ryb3lcXFwiLGYsITApfWIuc2hhcmVkLm1vZGFsc3x8KGIuc2hhcmVkLm1vZGFscz17fSk7dmFyIG0sbj1iLnNoYXJlZC5tb2RhbHM7cmV0dXJue19pbml0OmwsZ2V0OmMsY3JlYXRlOmUsc2hvdzpnLGhpZGU6aCxyZXNpemU6aSxpc1Zpc2libGU6aixhcmVWaXNpYmxlOmt9fSxhLkZFLlBPUFVQX1RFTVBMQVRFUz17XFxcInRleHQuZWRpdFxcXCI6XFxcIltfRURJVF9dXFxcIn0sYS5GRS5SZWdpc3RlclRlbXBsYXRlPWZ1bmN0aW9uKGIsYyl7YS5GRS5QT1BVUF9URU1QTEFURVNbYl09Y30sYS5GRS5NT0RVTEVTLnBvcHVwcz1mdW5jdGlvbihiKXtmdW5jdGlvbiBjKGEsYyl7Yy5pcyhcXFwiOnZpc2libGVcXFwiKXx8KGM9Yi4kc2MpLGMuaXMoeFthXS5kYXRhKFxcXCJjb250YWluZXJcXFwiKSl8fCh4W2FdLmRhdGEoXFxcImNvbnRhaW5lclxcXCIsYyksYy5hcHBlbmQoeFthXSkpfWZ1bmN0aW9uIGQoYSxkLGUsaCl7aWYoZygpJiZiLiRlbC5maW5kKFxcXCIuZnItbWFya2VyXFxcIikubGVuZ3RoPjA/KGIuZXZlbnRzLmRpc2FibGVCbHVyKCksYi5zZWxlY3Rpb24ucmVzdG9yZSgpKTooYi5ldmVudHMuZGlzYWJsZUJsdXIoKSxiLmV2ZW50cy5mb2N1cygpLGIuZXZlbnRzLmVuYWJsZUJsdXIoKSksbShbYV0pLCF4W2FdKXJldHVybiExO3ZhciBpPWIuYnV0dG9uLmdldEJ1dHRvbnMoXFxcIi5mci1kcm9wZG93bi5mci1hY3RpdmVcXFwiKTtpLnJlbW92ZUNsYXNzKFxcXCJmci1hY3RpdmVcXFwiKS5hdHRyKFxcXCJhcmlhLWV4cGFuZGVkXFxcIiwhMSkucGFyZW50KFxcXCIuZnItdG9vbGJhclxcXCIpLmNzcyhcXFwiekluZGV4XFxcIixcXFwiXFxcIiksaS5uZXh0KCkuYXR0cihcXFwiYXJpYS1oaWRkZW5cXFwiLCEwKSx4W2FdLmRhdGEoXFxcImluc3RhbmNlXFxcIixiKSxiLiR0YiYmYi4kdGIuZGF0YShcXFwiaW5zdGFuY2VcXFwiLGIpO3ZhciBqPXhbYV0ub3V0ZXJXaWR0aCgpLGs9ZihhKTt4W2FdLmFkZENsYXNzKFxcXCJmci1hY3RpdmVcXFwiKS5yZW1vdmVDbGFzcyhcXFwiZnItaGlkZGVuXFxcIikuZmluZChcXFwiaW5wdXQsIHRleHRhcmVhXFxcIikucmVtb3ZlQXR0cihcXFwiZGlzYWJsZWRcXFwiKTt2YXIgbD14W2FdLmRhdGEoXFxcImNvbnRhaW5lclxcXCIpO2Iub3B0cy50b29sYmFySW5saW5lJiZsJiZiLiR0YiYmbC5nZXQoMCk9PWIuJHRiLmdldCgwKSYmKGMoYSxiLiRzYyksZT1iLiR0Yi5vZmZzZXQoKS50b3AtYi5oZWxwZXJzLmdldFBYKGIuJHRiLmNzcyhcXFwibWFyZ2luLXRvcFxcXCIpKSxkPWIuJHRiLm9mZnNldCgpLmxlZnQrYi4kdGIub3V0ZXJXaWR0aCgpLzIrKHBhcnNlRmxvYXQoYi4kdGIuZmluZChcXFwiLmZyLWFycm93XFxcIikuY3NzKFxcXCJtYXJnaW4tbGVmdFxcXCIpKXx8MCkrYi4kdGIuZmluZChcXFwiLmZyLWFycm93XFxcIikub3V0ZXJXaWR0aCgpLzIsYi5ub2RlLmhhc0NsYXNzKGIuJHRiLmdldCgwKSxcXFwiZnItYWJvdmVcXFwiKSYmZSYmKGUrPWIuJHRiLm91dGVySGVpZ2h0KCkpLGg9MCksbD14W2FdLmRhdGEoXFxcImNvbnRhaW5lclxcXCIpLCFiLm9wdHMuaWZyYW1lfHxofHxrfHwoZCYmKGQtPWIuJGlmcmFtZS5vZmZzZXQoKS5sZWZ0KSxlJiYoZS09Yi4kaWZyYW1lLm9mZnNldCgpLnRvcCkpLGwuaXMoYi4kdGIpP2IuJHRiLmNzcyhcXFwiekluZGV4XFxcIiwoYi5vcHRzLnpJbmRleHx8MSkrNCk6eFthXS5jc3MoXFxcInpJbmRleFxcXCIsKGIub3B0cy56SW5kZXh8fDEpKzQpLGQmJihkLT1qLzIpLGIub3B0cy50b29sYmFyQm90dG9tJiZsJiZiLiR0YiYmbC5nZXQoMCk9PWIuJHRiLmdldCgwKSYmKHhbYV0uYWRkQ2xhc3MoXFxcImZyLWFib3ZlXFxcIiksZSYmKGUtPXhbYV0ub3V0ZXJIZWlnaHQoKSkpLHhbYV0ucmVtb3ZlQ2xhc3MoXFxcImZyLWFjdGl2ZVxcXCIpLGIucG9zaXRpb24uYXQoZCxlLHhbYV0saHx8MCkseFthXS5hZGRDbGFzcyhcXFwiZnItYWN0aXZlXFxcIiksa3x8Yi5hY2Nlc3NpYmlsaXR5LmZvY3VzUG9wdXAoeFthXSksYi5vcHRzLnRvb2xiYXJJbmxpbmUmJmIudG9vbGJhci5oaWRlKCksYi5ldmVudHMudHJpZ2dlcihcXFwicG9wdXBzLnNob3cuXFxcIithKSxzKGEpLl9yZXBvc2l0aW9uUG9wdXAoKSxvKCl9ZnVuY3Rpb24gZShhLGMpe2IuZXZlbnRzLm9uKFxcXCJwb3B1cHMuc2hvdy5cXFwiK2EsYyl9ZnVuY3Rpb24gZihhKXtyZXR1cm4geFthXSYmYi5ub2RlLmhhc0NsYXNzKHhbYV0sXFxcImZyLWFjdGl2ZVxcXCIpJiZiLmNvcmUuc2FtZUluc3RhbmNlKHhbYV0pfHwhMX1mdW5jdGlvbiBnKGEpe2Zvcih2YXIgYiBpbiB4KWlmKHguaGFzT3duUHJvcGVydHkoYikmJmYoYikmJihcXFwidW5kZWZpbmVkXFxcIj09dHlwZW9mIGF8fHhbYl0uZGF0YShcXFwiaW5zdGFuY2VcXFwiKT09YSkpcmV0dXJuIHhbYl07cmV0dXJuITF9ZnVuY3Rpb24gaChhKXt2YXIgYz1udWxsO2M9XFxcInN0cmluZ1xcXCIhPXR5cGVvZiBhP2E6eFthXSxjJiZiLm5vZGUuaGFzQ2xhc3MoYyxcXFwiZnItYWN0aXZlXFxcIikmJihjLnJlbW92ZUNsYXNzKFxcXCJmci1hY3RpdmUgZnItYWJvdmVcXFwiKSxcXG5iLmV2ZW50cy50cmlnZ2VyKFxcXCJwb3B1cHMuaGlkZS5cXFwiK2EpLGIuJHRiJiYoYi5vcHRzLnpJbmRleD4xP2IuJHRiLmNzcyhcXFwiekluZGV4XFxcIixiLm9wdHMuekluZGV4KzEpOmIuJHRiLmNzcyhcXFwiekluZGV4XFxcIixcXFwiXFxcIikpLGIuZXZlbnRzLmRpc2FibGVCbHVyKCksYy5maW5kKFxcXCJpbnB1dCwgdGV4dGFyZWEsIGJ1dHRvblxcXCIpLmZpbHRlcihcXFwiOmZvY3VzXFxcIikuYmx1cigpLGMuZmluZChcXFwiaW5wdXQsIHRleHRhcmVhXFxcIikuYXR0cihcXFwiZGlzYWJsZWRcXFwiLFxcXCJkaXNhYmxlZFxcXCIpKX1mdW5jdGlvbiBpKGEsYyl7Yi5ldmVudHMub24oXFxcInBvcHVwcy5oaWRlLlxcXCIrYSxjKX1mdW5jdGlvbiBqKGEpe3ZhciBjPXhbYV07aWYoYyYmIWMuZGF0YShcXFwiaW5zdFxcXCIrYi5pZCkpe3ZhciBkPXMoYSk7dChkLGEpfXJldHVybiBjfWZ1bmN0aW9uIGsoYSxjKXtiLmV2ZW50cy5vbihcXFwicG9wdXBzLnJlZnJlc2guXFxcIithLGMpfWZ1bmN0aW9uIGwoYyl7Yi5ldmVudHMudHJpZ2dlcihcXFwicG9wdXBzLnJlZnJlc2guXFxcIitjKTtmb3IodmFyIGQ9eFtjXS5maW5kKFxcXCIuZnItY29tbWFuZFxcXCIpLGU9MDtlPGQubGVuZ3RoO2UrKyl7dmFyIGY9YShkW2VdKTswPT09Zi5wYXJlbnRzKFxcXCIuZnItZHJvcGRvd24tbWVudVxcXCIpLmxlbmd0aCYmYi5idXR0b24ucmVmcmVzaChmKX19ZnVuY3Rpb24gbShhKXtcXFwidW5kZWZpbmVkXFxcIj09dHlwZW9mIGEmJihhPVtdKTtmb3IodmFyIGIgaW4geCl4Lmhhc093blByb3BlcnR5KGIpJiZhLmluZGV4T2YoYik8MCYmaChiKX1mdW5jdGlvbiBuKCl7Yi5zaGFyZWQuZXhpdF9mbGFnPSEwfWZ1bmN0aW9uIG8oKXtiLnNoYXJlZC5leGl0X2ZsYWc9ITF9ZnVuY3Rpb24gcCgpe3JldHVybiBiLnNoYXJlZC5leGl0X2ZsYWd9ZnVuY3Rpb24gcShjLGQpe3ZhciBlPWEuRkUuUE9QVVBfVEVNUExBVEVTW2NdO1xcXCJmdW5jdGlvblxcXCI9PXR5cGVvZiBlJiYoZT1lLmFwcGx5KGIpKTtmb3IodmFyIGYgaW4gZClkLmhhc093blByb3BlcnR5KGYpJiYoZT1lLnJlcGxhY2UoXFxcIltfXFxcIitmLnRvVXBwZXJDYXNlKCkrXFxcIl9dXFxcIixkW2ZdKSk7cmV0dXJuIGV9ZnVuY3Rpb24gcihjLGQpe3ZhciBlPXEoYyxkKSxmPWEoJzxkaXYgY2xhc3M9XFxcImZyLXBvcHVwJysoYi5oZWxwZXJzLmlzTW9iaWxlKCk/XFxcIiBmci1tb2JpbGVcXFwiOlxcXCIgZnItZGVza3RvcFxcXCIpKyhiLm9wdHMudG9vbGJhcklubGluZT9cXFwiIGZyLWlubGluZVxcXCI6XFxcIlxcXCIpKydcXFwiPjxzcGFuIGNsYXNzPVxcXCJmci1hcnJvd1xcXCI+PC9zcGFuPicrZStcXFwiPC9kaXY+XFxcIik7Yi5vcHRzLnRoZW1lJiZmLmFkZENsYXNzKGIub3B0cy50aGVtZStcXFwiLXRoZW1lXFxcIiksYi5vcHRzLnpJbmRleD4xJiZiLiR0Yi5jc3MoXFxcInotaW5kZXhcXFwiLGIub3B0cy56SW5kZXgrMiksXFxcImF1dG9cXFwiIT1iLm9wdHMuZGlyZWN0aW9uJiZmLnJlbW92ZUNsYXNzKFxcXCJmci1sdHIgZnItcnRsXFxcIikuYWRkQ2xhc3MoXFxcImZyLVxcXCIrYi5vcHRzLmRpcmVjdGlvbiksZi5maW5kKFxcXCJpbnB1dCwgdGV4dGFyZWFcXFwiKS5hdHRyKFxcXCJkaXJcXFwiLGIub3B0cy5kaXJlY3Rpb24pLmF0dHIoXFxcImRpc2FibGVkXFxcIixcXFwiZGlzYWJsZWRcXFwiKTt2YXIgZz1hKFxcXCJib2R5XFxcIik7cmV0dXJuIGcuYXBwZW5kKGYpLGYuZGF0YShcXFwiY29udGFpbmVyXFxcIixnKSx4W2NdPWYsYi5idXR0b24uYmluZENvbW1hbmRzKGYsITEpLGZ9ZnVuY3Rpb24gcyhjKXt2YXIgZD14W2NdO3JldHVybntfd2luZG93UmVzaXplOmZ1bmN0aW9uKCl7dmFyIGE9ZC5kYXRhKFxcXCJpbnN0YW5jZVxcXCIpfHxiOyFhLmhlbHBlcnMuaXNNb2JpbGUoKSYmZC5pcyhcXFwiOnZpc2libGVcXFwiKSYmKGEuZXZlbnRzLmRpc2FibGVCbHVyKCksYS5wb3B1cHMuaGlkZShjKSxhLmV2ZW50cy5lbmFibGVCbHVyKCkpfSxfaW5wdXRGb2N1czpmdW5jdGlvbihjKXt2YXIgZT1kLmRhdGEoXFxcImluc3RhbmNlXFxcIil8fGIsZj1hKGMuY3VycmVudFRhcmdldCk7aWYoZi5pcyhcXFwiaW5wdXQ6ZmlsZVxcXCIpJiZmLmNsb3Nlc3QoXFxcIi5mci1sYXllclxcXCIpLmFkZENsYXNzKFxcXCJmci1pbnB1dC1mb2N1c1xcXCIpLGMucHJldmVudERlZmF1bHQoKSxjLnN0b3BQcm9wYWdhdGlvbigpLHNldFRpbWVvdXQoZnVuY3Rpb24oKXtlLmV2ZW50cy5lbmFibGVCbHVyKCl9LDApLGUuaGVscGVycy5pc01vYmlsZSgpKXt2YXIgZz1hKGUub193aW4pLnNjcm9sbFRvcCgpO3NldFRpbWVvdXQoZnVuY3Rpb24oKXthKGUub193aW4pLnNjcm9sbFRvcChnKX0sMCl9fSxfaW5wdXRCbHVyOmZ1bmN0aW9uKGMpe3ZhciBlPWQuZGF0YShcXFwiaW5zdGFuY2VcXFwiKXx8YixmPWEoYy5jdXJyZW50VGFyZ2V0KTtmLmlzKFxcXCJpbnB1dDpmaWxlXFxcIikmJmYuY2xvc2VzdChcXFwiLmZyLWxheWVyXFxcIikucmVtb3ZlQ2xhc3MoXFxcImZyLWlucHV0LWZvY3VzXFxcIiksZG9jdW1lbnQuYWN0aXZlRWxlbWVudCE9dGhpcyYmYSh0aGlzKS5pcyhcXFwiOnZpc2libGVcXFwiKSYmKGUuZXZlbnRzLmJsdXJBY3RpdmUoKSYmZS5ldmVudHMudHJpZ2dlcihcXFwiYmx1clxcXCIpLGUuZXZlbnRzLmVuYWJsZUJsdXIoKSl9LF9lZGl0b3JLZXlkb3duOmZ1bmN0aW9uKGUpe3ZhciBnPWQuZGF0YShcXFwiaW5zdGFuY2VcXFwiKXx8YjtnLmtleXMuY3RybEtleShlKXx8ZS53aGljaD09YS5GRS5LRVlDT0RFLkFMVHx8ZS53aGljaD09YS5GRS5LRVlDT0RFLkVTQ3x8KGYoYykmJmQuZmluZChcXFwiLmZyLWJhY2s6dmlzaWJsZVxcXCIpLmxlbmd0aD9nLmJ1dHRvbi5leGVjKGQuZmluZChcXFwiLmZyLWJhY2s6dmlzaWJsZTpmaXJzdFxcXCIpKTplLndoaWNoIT1hLkZFLktFWUNPREUuQUxUJiZnLnBvcHVwcy5oaWRlKGMpKX0sX3ByZXZlbnRGb2N1czpmdW5jdGlvbihjKXt2YXIgZT1kLmRhdGEoXFxcImluc3RhbmNlXFxcIil8fGI7XFxcIm1vdXNldXBcXFwiPT1jLnR5cGUmJmIuYnV0dG9uLmhpZGVBY3RpdmVEcm9wZG93bnMoZCk7dmFyIGY9Yy5vcmlnaW5hbEV2ZW50P2Mub3JpZ2luYWxFdmVudC50YXJnZXR8fGMub3JpZ2luYWxFdmVudC5vcmlnaW5hbFRhcmdldDpudWxsO1xcXCJtb3VzZXVwXFxcIj09Yy50eXBlfHxhKGYpLmlzKFxcXCI6Zm9jdXNcXFwiKXx8ZS5ldmVudHMuZGlzYWJsZUJsdXIoKSxiLmJyb3dzZXIuc2FmYXJpJiZcXFwibW91c2Vkb3duXFxcIj09Yy50eXBlJiZhKGYpLmlzKFxcXCJpbnB1dFt0eXBlPWZpbGVdXFxcIikmJmUuZXZlbnRzLmRpc2FibGVCbHVyKCk7dmFyIGc9XFxcImlucHV0LCB0ZXh0YXJlYSwgYnV0dG9uLCBzZWxlY3QsIGxhYmVsLCAuZnItY29tbWFuZFxcXCI7cmV0dXJuIGYmJiFhKGYpLmlzKGcpJiYwPT09YShmKS5wYXJlbnRzKGcpLmxlbmd0aD8oYy5zdG9wUHJvcGFnYXRpb24oKSwhMSk6KGYmJmEoZikuaXMoZykmJmMuc3RvcFByb3BhZ2F0aW9uKCksdm9pZCBvKCkpfSxfZWRpdG9yTW91c2V1cDpmdW5jdGlvbigpe2QuaXMoXFxcIjp2aXNpYmxlXFxcIikmJnAoKSYmZC5maW5kKFxcXCJpbnB1dDpmb2N1cywgdGV4dGFyZWE6Zm9jdXMsIGJ1dHRvbjpmb2N1cywgc2VsZWN0OmZvY3VzXFxcIikuZmlsdGVyKFxcXCI6dmlzaWJsZVxcXCIpLmxlbmd0aD4wJiZiLmV2ZW50cy5kaXNhYmxlQmx1cigpfSxfd2luZG93TW91c2V1cDpmdW5jdGlvbihhKXtpZighYi5jb3JlLnNhbWVJbnN0YW5jZShkKSlyZXR1cm4hMDt2YXIgZT1kLmRhdGEoXFxcImluc3RhbmNlXFxcIil8fGI7ZC5pcyhcXFwiOnZpc2libGVcXFwiKSYmcCgpJiYoYS5zdG9wUHJvcGFnYXRpb24oKSxlLm1hcmtlcnMucmVtb3ZlKCksZS5wb3B1cHMuaGlkZShjKSxvKCkpfSxfd2luZG93S2V5ZG93bjpmdW5jdGlvbihlKXtpZighYi5jb3JlLnNhbWVJbnN0YW5jZShkKSlyZXR1cm4hMDt2YXIgZj1kLmRhdGEoXFxcImluc3RhbmNlXFxcIil8fGIsZz1lLndoaWNoO2lmKGEuRkUuS0VZQ09ERS5FU0M9PWcpe2lmKGYucG9wdXBzLmlzVmlzaWJsZShjKSYmZi5vcHRzLnRvb2xiYXJJbmxpbmUpcmV0dXJuIGUuc3RvcFByb3BhZ2F0aW9uKCksZi5wb3B1cHMuaXNWaXNpYmxlKGMpJiYoZC5maW5kKFxcXCIuZnItYmFjazp2aXNpYmxlXFxcIikubGVuZ3RoPyhmLmJ1dHRvbi5leGVjKGQuZmluZChcXFwiLmZyLWJhY2s6dmlzaWJsZTpmaXJzdFxcXCIpKSxmLmFjY2Vzc2liaWxpdHkuZm9jdXNQb3B1cEJ1dHRvbihkKSk6ZC5maW5kKFxcXCIuZnItZGlzbWlzczp2aXNpYmxlXFxcIikubGVuZ3RoP2YuYnV0dG9uLmV4ZWMoZC5maW5kKFxcXCIuZnItZGlzbWlzczp2aXNpYmxlOmZpcnN0XFxcIikpOihmLnBvcHVwcy5oaWRlKGMpLGYudG9vbGJhci5zaG93SW5saW5lKG51bGwsITApLGYuYWNjZXNzaWJpbGl0eS5Gb2N1c1BvcHVwQnV0dG9uKGQpKSksITE7aWYoZi5wb3B1cHMuaXNWaXNpYmxlKGMpKXJldHVybiBkLmZpbmQoXFxcIi5mci1iYWNrOnZpc2libGVcXFwiKS5sZW5ndGg/KGYuYnV0dG9uLmV4ZWMoZC5maW5kKFxcXCIuZnItYmFjazp2aXNpYmxlOmZpcnN0XFxcIikpLGYuYWNjZXNzaWJpbGl0eS5mb2N1c1BvcHVwQnV0dG9uKGQpKTpkLmZpbmQoXFxcIi5mci1kaXNtaXNzOnZpc2libGVcXFwiKS5sZW5ndGg/Zi5idXR0b24uZXhlYyhkLmZpbmQoXFxcIi5mci1kaXNtaXNzOnZpc2libGU6Zmlyc3RcXFwiKSk6KGYucG9wdXBzLmhpZGUoYyksZi5hY2Nlc3NpYmlsaXR5LmZvY3VzUG9wdXBCdXR0b24oZCkpLCExfX0sX2RvUGxhY2Vob2xkZXI6ZnVuY3Rpb24oKXt2YXIgYj1hKHRoaXMpLm5leHQoKTswPT09Yi5sZW5ndGgmJmEodGhpcykuYXR0cihcXFwicGxhY2Vob2xkZXJcXFwiKSYmYSh0aGlzKS5hZnRlcignPGxhYmVsIGZvcj1cXFwiJythKHRoaXMpLmF0dHIoXFxcImlkXFxcIikrJ1xcXCI+JythKHRoaXMpLmF0dHIoXFxcInBsYWNlaG9sZGVyXFxcIikrXFxcIjwvbGFiZWw+XFxcIiksYSh0aGlzKS50b2dnbGVDbGFzcyhcXFwiZnItbm90LWVtcHR5XFxcIixcXFwiXFxcIiE9PWEodGhpcykudmFsKCkpfSxfcmVwb3NpdGlvblBvcHVwOmZ1bmN0aW9uKCl7aWYoIWIub3B0cy5oZWlnaHQmJiFiLm9wdHMuaGVpZ2h0TWF4fHxiLm9wdHMudG9vbGJhcklubGluZSlyZXR1cm4hMDtpZihiLiR3cCYmZihjKSYmZC5wYXJlbnQoKS5nZXQoMCk9PWIuJHNjLmdldCgwKSl7dmFyIGE9ZC5vZmZzZXQoKS50b3AtYi4kd3Aub2Zmc2V0KCkudG9wLGU9Yi4kd3Aub3V0ZXJIZWlnaHQoKTtiLm5vZGUuaGFzQ2xhc3MoZC5nZXQoMCksXFxcImZyLWFib3ZlXFxcIikmJihhKz1kLm91dGVySGVpZ2h0KCkpLGE+ZXx8YTwwP2QuYWRkQ2xhc3MoXFxcImZyLWhpZGRlblxcXCIpOmQucmVtb3ZlQ2xhc3MoXFxcImZyLWhpZGRlblxcXCIpfX19fWZ1bmN0aW9uIHQoYSxjKXtiLmV2ZW50cy5vbihcXFwibW91c2V1cFxcXCIsYS5fZWRpdG9yTW91c2V1cCwhMCksYi4kd3AmJmIuZXZlbnRzLm9uKFxcXCJrZXlkb3duXFxcIixhLl9lZGl0b3JLZXlkb3duKSxiLmV2ZW50cy5vbihcXFwiYmx1clxcXCIsZnVuY3Rpb24oKXtnKCkmJmIubWFya2Vycy5yZW1vdmUoKSxtKCl9KSxiLiR3cCYmIWIuaGVscGVycy5pc01vYmlsZSgpJiZiLmV2ZW50cy4kb24oYi4kd3AsXFxcInNjcm9sbC5wb3B1cFxcXCIrYyxhLl9yZXBvc2l0aW9uUG9wdXApLGIuZXZlbnRzLm9uKFxcXCJ3aW5kb3cubW91c2V1cFxcXCIsYS5fd2luZG93TW91c2V1cCwhMCksYi5ldmVudHMub24oXFxcIndpbmRvdy5rZXlkb3duXFxcIixhLl93aW5kb3dLZXlkb3duLCEwKSx4W2NdLmRhdGEoXFxcImluc3RcXFwiK2IuaWQsITApLGIuZXZlbnRzLm9uKFxcXCJkZXN0cm95XFxcIixmdW5jdGlvbigpe2IuY29yZS5zYW1lSW5zdGFuY2UoeFtjXSkmJnhbY10ucmVtb3ZlQ2xhc3MoXFxcImZyLWFjdGl2ZVxcXCIpLmFwcGVuZFRvKFxcXCJib2R5XFxcIil9LCEwKX1mdW5jdGlvbiB1KGMsZCl7dmFyIGU9cihjLGQpLGY9cyhjKTtyZXR1cm4gdChmLGMpLGIuZXZlbnRzLiRvbihlLFxcXCJtb3VzZWRvd24gbW91c2V1cCB0b3VjaHN0YXJ0IHRvdWNoZW5kIHRvdWNoXFxcIixcXFwiKlxcXCIsZi5fcHJldmVudEZvY3VzLCEwKSxiLmV2ZW50cy4kb24oZSxcXFwiZm9jdXNcXFwiLFxcXCJpbnB1dCwgdGV4dGFyZWEsIGJ1dHRvbiwgc2VsZWN0XFxcIixmLl9pbnB1dEZvY3VzLCEwKSxiLmV2ZW50cy4kb24oZSxcXFwiYmx1clxcXCIsXFxcImlucHV0LCB0ZXh0YXJlYSwgYnV0dG9uLCBzZWxlY3RcXFwiLGYuX2lucHV0Qmx1ciwhMCksYi5hY2Nlc3NpYmlsaXR5LnJlZ2lzdGVyUG9wdXAoYyksYi5ldmVudHMuJG9uKGUsXFxcImtleWRvd24ga2V5dXAgY2hhbmdlIGlucHV0XFxcIixcXFwiaW5wdXQsIHRleHRhcmVhXFxcIixmLl9kb1BsYWNlaG9sZGVyLCEwKSxiLmhlbHBlcnMuaXNJT1MoKSYmYi5ldmVudHMuJG9uKGUsXFxcInRvdWNoZW5kXFxcIixcXFwibGFiZWxcXFwiLGZ1bmN0aW9uKCl7YShcXFwiI1xcXCIrYSh0aGlzKS5hdHRyKFxcXCJmb3JcXFwiKSkucHJvcChcXFwiY2hlY2tlZFxcXCIsZnVuY3Rpb24oYSxiKXtyZXR1cm4hYn0pfSwhMCksYi5ldmVudHMuJG9uKGEoYi5vX3dpbiksXFxcInJlc2l6ZVxcXCIsZi5fd2luZG93UmVzaXplLCEwKSxlfWZ1bmN0aW9uIHYoKXtmb3IodmFyIGEgaW4geClpZih4Lmhhc093blByb3BlcnR5KGEpKXt2YXIgYj14W2FdO2IuaHRtbChcXFwiXFxcIikucmVtb3ZlRGF0YSgpLnJlbW92ZSgpLHhbYV09bnVsbH14PVtdfWZ1bmN0aW9uIHcoKXtiLmV2ZW50cy5vbihcXFwic2hhcmVkLmRlc3Ryb3lcXFwiLHYsITApLGIuZXZlbnRzLm9uKFxcXCJ3aW5kb3cubW91c2Vkb3duXFxcIixuKSxiLmV2ZW50cy5vbihcXFwid2luZG93LnRvdWNobW92ZVxcXCIsbyksYi5ldmVudHMub24oXFxcIm1vdXNlZG93blxcXCIsZnVuY3Rpb24oYSl7ZygpJiYoYS5zdG9wUHJvcGFnYXRpb24oKSxiLiRlbC5maW5kKFxcXCIuZnItbWFya2VyXFxcIikucmVtb3ZlKCksbigpLGIuZXZlbnRzLmRpc2FibGVCbHVyKCkpfSl9Yi5zaGFyZWQucG9wdXBzfHwoYi5zaGFyZWQucG9wdXBzPXt9KTt2YXIgeD1iLnNoYXJlZC5wb3B1cHM7cmV0dXJuIGIuc2hhcmVkLmV4aXRfZmxhZz0hMSx7X2luaXQ6dyxjcmVhdGU6dSxnZXQ6aixzaG93OmQsaGlkZTpoLG9uSGlkZTppLGhpZGVBbGw6bSxzZXRDb250YWluZXI6YyxyZWZyZXNoOmwsb25SZWZyZXNoOmssb25TaG93OmUsaXNWaXNpYmxlOmYsYXJlVmlzaWJsZTpnfX0sYS5GRS5NT0RVTEVTLnBvc2l0aW9uPWZ1bmN0aW9uKGIpe2Z1bmN0aW9uIGMoKXt2YXIgYT1iLnNlbGVjdGlvbi5yYW5nZXMoMCksYz1hLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO2lmKDA9PT1jLnRvcCYmMD09PWMubGVmdCYmMD09PWMud2lkdGh8fDA9PT1jLmhlaWdodCl7dmFyIGQ9ITE7MD09PWIuJGVsLmZpbmQoXFxcIi5mci1tYXJrZXJcXFwiKS5sZW5ndGgmJihiLnNlbGVjdGlvbi5zYXZlKCksZD0hMCk7dmFyIGU9Yi4kZWwuZmluZChcXFwiLmZyLW1hcmtlcjpmaXJzdFxcXCIpO2UuY3NzKFxcXCJkaXNwbGF5XFxcIixcXFwiaW5saW5lXFxcIiksZS5jc3MoXFxcImxpbmUtaGVpZ2h0XFxcIixcXFwiXFxcIik7dmFyIGY9ZS5vZmZzZXQoKSxnPWUub3V0ZXJIZWlnaHQoKTtlLmNzcyhcXFwiZGlzcGxheVxcXCIsXFxcIm5vbmVcXFwiKSxlLmNzcyhcXFwibGluZS1oZWlnaHRcXFwiLDApLGM9e30sYy5sZWZ0PWYubGVmdCxjLndpZHRoPTAsYy5oZWlnaHQ9ZyxjLnRvcD1mLnRvcC0oYi5oZWxwZXJzLmlzTW9iaWxlKCk/MDpiLmhlbHBlcnMuc2Nyb2xsVG9wKCkpLGMucmlnaHQ9MSxjLmJvdHRvbT0xLGMub2s9ITAsZCYmYi5zZWxlY3Rpb24ucmVzdG9yZSgpfXJldHVybiBjfWZ1bmN0aW9uIGQoYSxjLGQpe3ZhciBlPWEuZ2V0KDApLm9mZnNldEhlaWdodDtpZighYi5oZWxwZXJzLmlzTW9iaWxlKCkmJmIuJHRiJiZhLnBhcmVudCgpLmdldCgwKSE9Yi4kdGIuZ2V0KDApKXt2YXIgZj1hLnBhcmVudCgpLm9mZnNldCgpLnRvcCxnPWMtZS0oZHx8MCk7YS5wYXJlbnQoKS5nZXQoMCk9PWIuJHNjLmdldCgwKSYmKGYtPWEucGFyZW50KCkucG9zaXRpb24oKS50b3ApO3ZhciBoPWIuJHNjLmdldCgwKS5zY3JvbGxIZWlnaHQ7ZitjK2U+Yi4kc2Mub2Zmc2V0KCkudG9wK2gmJmEucGFyZW50KCkub2Zmc2V0KCkudG9wK2c+MD8oYz1nLGEuYWRkQ2xhc3MoXFxcImZyLWFib3ZlXFxcIikpOmEucmVtb3ZlQ2xhc3MoXFxcImZyLWFib3ZlXFxcIil9cmV0dXJuIGN9ZnVuY3Rpb24gZShhLGMpe3ZhciBkPWEuZ2V0KDApLm9mZnNldFdpZHRoO3JldHVybiBjK2Q+Yi4kc2MuZ2V0KDApLmNsaWVudFdpZHRoLTEwJiYoYz1iLiRzYy5nZXQoMCkuY2xpZW50V2lkdGgtZC0xMCksYzwwJiYoYz0xMCksY31mdW5jdGlvbiBmKGEpe3ZhciBkPWMoKTthLmNzcyh7dG9wOjAsbGVmdDowfSk7dmFyIGU9ZC50b3ArZC5oZWlnaHQsZj1kLmxlZnQrZC53aWR0aC8yLWEuZ2V0KDApLm9mZnNldFdpZHRoLzIrYi5oZWxwZXJzLnNjcm9sbExlZnQoKTtiLm9wdHMuaWZyYW1lfHwoZSs9Yi5oZWxwZXJzLnNjcm9sbFRvcCgpKSxnKGYsZSxhLGQuaGVpZ2h0KX1mdW5jdGlvbiBnKGEsYyxmLGcpe3ZhciBoPWYuZGF0YShcXFwiY29udGFpbmVyXFxcIik7IWh8fFxcXCJCT0RZXFxcIj09PWguZ2V0KDApLnRhZ05hbWUmJlxcXCJzdGF0aWNcXFwiPT1oLmNzcyhcXFwicG9zaXRpb25cXFwiKXx8KGEmJihhLT1oLm9mZnNldCgpLmxlZnQpLGMmJihjLT1oLm9mZnNldCgpLnRvcCksXFxcIkJPRFlcXFwiIT1oLmdldCgwKS50YWdOYW1lPyhhJiYoYSs9aC5nZXQoMCkuc2Nyb2xsTGVmdCksYyYmKGMrPWguZ2V0KDApLnNjcm9sbFRvcCkpOlxcXCJhYnNvbHV0ZVxcXCI9PWguY3NzKFxcXCJwb3NpdGlvblxcXCIpJiYoYSYmKGErPWgucG9zaXRpb24oKS5sZWZ0KSxjJiYoYys9aC5wb3NpdGlvbigpLnRvcCkpKSxiLm9wdHMuaWZyYW1lJiZoJiZiLiR0YiYmaC5nZXQoMCkhPWIuJHRiLmdldCgwKSYmKGEmJihhKz1iLiRpZnJhbWUub2Zmc2V0KCkubGVmdCksYyYmKGMrPWIuJGlmcmFtZS5vZmZzZXQoKS50b3ApKTt2YXIgaT1lKGYsYSk7aWYoYSl7Zi5jc3MoXFxcImxlZnRcXFwiLGkpO3ZhciBqPWYuZGF0YShcXFwiZnItYXJyb3dcXFwiKTtqfHwoaj1mLmZpbmQoXFxcIi5mci1hcnJvd1xcXCIpLGYuZGF0YShcXFwiZnItYXJyb3dcXFwiLGopKSxqLmRhdGEoXFxcIm1hcmdpbi1sZWZ0XFxcIil8fGouZGF0YShcXFwibWFyZ2luLWxlZnRcXFwiLGIuaGVscGVycy5nZXRQWChqLmNzcyhcXFwibWFyZ2luLWxlZnRcXFwiKSkpLGouY3NzKFxcXCJtYXJnaW4tbGVmdFxcXCIsYS1pK2ouZGF0YShcXFwibWFyZ2luLWxlZnRcXFwiKSl9YyYmZi5jc3MoXFxcInRvcFxcXCIsZChmLGMsZykpfWZ1bmN0aW9uIGgoYyl7dmFyIGQ9YShjKSxlPWQuaXMoXFxcIi5mci1zdGlja3ktb25cXFwiKSxmPWQuZGF0YShcXFwic3RpY2t5LXRvcFxcXCIpLGc9ZC5kYXRhKFxcXCJzdGlja3ktc2NoZWR1bGVkXFxcIik7aWYoXFxcInVuZGVmaW5lZFxcXCI9PXR5cGVvZiBmKXtkLmRhdGEoXFxcInN0aWNreS10b3BcXFwiLDApO3ZhciBoPWEoJzxkaXYgY2xhc3M9XFxcImZyLXN0aWNreS1kdW1teVxcXCIgc3R5bGU9XFxcImhlaWdodDogJytkLm91dGVySGVpZ2h0KCkrJ3B4O1xcXCI+PC9kaXY+Jyk7Yi4kYm94LnByZXBlbmQoaCl9ZWxzZSBiLiRib3guZmluZChcXFwiLmZyLXN0aWNreS1kdW1teVxcXCIpLmNzcyhcXFwiaGVpZ2h0XFxcIixkLm91dGVySGVpZ2h0KCkpO2lmKGIuY29yZS5oYXNGb2N1cygpfHxiLiR0Yi5maW5kKFxcXCJpbnB1dDp2aXNpYmxlOmZvY3VzXFxcIikubGVuZ3RoPjApe3ZhciBpPWIuaGVscGVycy5zY3JvbGxUb3AoKSxqPU1hdGgubWluKE1hdGgubWF4KGktYi4kdGIucGFyZW50KCkub2Zmc2V0KCkudG9wLDApLGIuJHRiLnBhcmVudCgpLm91dGVySGVpZ2h0KCktZC5vdXRlckhlaWdodCgpKTtqIT1mJiZqIT1nJiYoY2xlYXJUaW1lb3V0KGQuZGF0YShcXFwic3RpY2t5LXRpbWVvdXRcXFwiKSksZC5kYXRhKFxcXCJzdGlja3ktc2NoZWR1bGVkXFxcIixqKSxkLm91dGVySGVpZ2h0KCk8aS1iLiR0Yi5wYXJlbnQoKS5vZmZzZXQoKS50b3AmJmQuYWRkQ2xhc3MoXFxcImZyLW9wYWNpdHktMFxcXCIpLGQuZGF0YShcXFwic3RpY2t5LXRpbWVvdXRcXFwiLHNldFRpbWVvdXQoZnVuY3Rpb24oKXt2YXIgYT1iLmhlbHBlcnMuc2Nyb2xsVG9wKCksYz1NYXRoLm1pbihNYXRoLm1heChhLWIuJHRiLnBhcmVudCgpLm9mZnNldCgpLnRvcCwwKSxiLiR0Yi5wYXJlbnQoKS5vdXRlckhlaWdodCgpLWQub3V0ZXJIZWlnaHQoKSk7Yz4wJiZcXFwiQk9EWVxcXCI9PWIuJHRiLnBhcmVudCgpLmdldCgwKS50YWdOYW1lJiYoYys9Yi4kdGIucGFyZW50KCkucG9zaXRpb24oKS50b3ApLGMhPWYmJihkLmNzcyhcXFwidG9wXFxcIixNYXRoLm1heChjLDApKSxkLmRhdGEoXFxcInN0aWNreS10b3BcXFwiLGMpLGQuZGF0YShcXFwic3RpY2t5LXNjaGVkdWxlZFxcXCIsYykpLGQucmVtb3ZlQ2xhc3MoXFxcImZyLW9wYWNpdHktMFxcXCIpfSwxMDApKSksZXx8KGQuY3NzKFxcXCJ0b3BcXFwiLFxcXCIwXFxcIiksZC53aWR0aChiLiR0Yi5wYXJlbnQoKS53aWR0aCgpKSxkLmFkZENsYXNzKFxcXCJmci1zdGlja3ktb25cXFwiKSxiLiRib3guYWRkQ2xhc3MoXFxcImZyLXN0aWNreS1ib3hcXFwiKSl9ZWxzZSBjbGVhclRpbWVvdXQoYShjKS5jc3MoXFxcInN0aWNreS10aW1lb3V0XFxcIikpLGQuY3NzKFxcXCJ0b3BcXFwiLFxcXCIwXFxcIiksZC5jc3MoXFxcInBvc2l0aW9uXFxcIixcXFwiXFxcIiksZC53aWR0aChcXFwiXFxcIiksZC5kYXRhKFxcXCJzdGlja3ktdG9wXFxcIiwwKSxkLnJlbW92ZUNsYXNzKFxcXCJmci1zdGlja3ktb25cXFwiKSxiLiRib3gucmVtb3ZlQ2xhc3MoXFxcImZyLXN0aWNreS1ib3hcXFwiKX1mdW5jdGlvbiBpKGMpe2lmKGMub2Zmc2V0V2lkdGgpe3ZhciBkLGUsZj1hKGMpLGc9Zi5vdXRlckhlaWdodCgpLGg9Zi5kYXRhKFxcXCJzdGlja3ktcG9zaXRpb25cXFwiKSxpPWEoXFxcImJvZHlcXFwiPT1iLm9wdHMuc2Nyb2xsYWJsZUNvbnRhaW5lcj9iLm9fd2luOmIub3B0cy5zY3JvbGxhYmxlQ29udGFpbmVyKS5vdXRlckhlaWdodCgpLGo9MCxrPTA7XFxcImJvZHlcXFwiIT09Yi5vcHRzLnNjcm9sbGFibGVDb250YWluZXImJihqPWIuJHNjLm9mZnNldCgpLnRvcCxrPWEoYi5vX3dpbikub3V0ZXJIZWlnaHQoKS1qLWkpO3ZhciBsPVxcXCJib2R5XFxcIj09Yi5vcHRzLnNjcm9sbGFibGVDb250YWluZXI/Yi5oZWxwZXJzLnNjcm9sbFRvcCgpOmosbT1mLmlzKFxcXCIuZnItc3RpY2t5LW9uXFxcIik7Zi5kYXRhKFxcXCJzdGlja3ktcGFyZW50XFxcIil8fGYuZGF0YShcXFwic3RpY2t5LXBhcmVudFxcXCIsZi5wYXJlbnQoKSk7dmFyIG49Zi5kYXRhKFxcXCJzdGlja3ktcGFyZW50XFxcIiksbz1uLm9mZnNldCgpLnRvcCxwPW4ub3V0ZXJIZWlnaHQoKTtpZihmLmRhdGEoXFxcInN0aWNreS1vZmZzZXRcXFwiKXx8KGYuZGF0YShcXFwic3RpY2t5LW9mZnNldFxcXCIsITApLGYuYWZ0ZXIoJzxkaXYgY2xhc3M9XFxcImZyLXN0aWNreS1kdW1teVxcXCIgc3R5bGU9XFxcImhlaWdodDogJytnKydweDtcXFwiPjwvZGl2PicpKSwhaCl7dmFyIHE9XFxcImF1dG9cXFwiIT09Zi5jc3MoXFxcInRvcFxcXCIpfHxcXFwiYXV0b1xcXCIhPT1mLmNzcyhcXFwiYm90dG9tXFxcIik7cXx8Zi5jc3MoXFxcInBvc2l0aW9uXFxcIixcXFwiZml4ZWRcXFwiKSxoPXt0b3A6Yi5ub2RlLmhhc0NsYXNzKGYuZ2V0KDApLFxcXCJmci10b3BcXFwiKSxib3R0b206Yi5ub2RlLmhhc0NsYXNzKGYuZ2V0KDApLFxcXCJmci1ib3R0b21cXFwiKX0scXx8Zi5jc3MoXFxcInBvc2l0aW9uXFxcIixcXFwiXFxcIiksZi5kYXRhKFxcXCJzdGlja3ktcG9zaXRpb25cXFwiLGgpLGYuZGF0YShcXFwidG9wXFxcIixiLm5vZGUuaGFzQ2xhc3MoZi5nZXQoMCksXFxcImZyLXRvcFxcXCIpP2YuY3NzKFxcXCJ0b3BcXFwiKTpcXFwiYXV0b1xcXCIpLGYuZGF0YShcXFwiYm90dG9tXFxcIixiLm5vZGUuaGFzQ2xhc3MoZi5nZXQoMCksXFxcImZyLWJvdHRvbVxcXCIpP2YuY3NzKFxcXCJib3R0b21cXFwiKTpcXFwiYXV0b1xcXCIpfXZhciByPWZ1bmN0aW9uKCl7cmV0dXJuIG88bCtkJiZvK3AtZz49bCtkfSxzPWZ1bmN0aW9uKCl7cmV0dXJuIG8rZzxsK2ktZSYmbytwPmwraS1lfTtkPWIuaGVscGVycy5nZXRQWChmLmRhdGEoXFxcInRvcFxcXCIpKSxlPWIuaGVscGVycy5nZXRQWChmLmRhdGEoXFxcImJvdHRvbVxcXCIpKTt2YXIgdD1oLnRvcCYmcigpLHU9aC5ib3R0b20mJnMoKTt0fHx1PyhmLmNzcyhcXFwid2lkdGhcXFwiLG4ud2lkdGgoKStcXFwicHhcXFwiKSxtfHwoZi5hZGRDbGFzcyhcXFwiZnItc3RpY2t5LW9uXFxcIiksZi5yZW1vdmVDbGFzcyhcXFwiZnItc3RpY2t5LW9mZlxcXCIpLGYuY3NzKFxcXCJ0b3BcXFwiKSYmKFxcXCJhdXRvXFxcIiE9Zi5kYXRhKFxcXCJ0b3BcXFwiKT9mLmNzcyhcXFwidG9wXFxcIixiLmhlbHBlcnMuZ2V0UFgoZi5kYXRhKFxcXCJ0b3BcXFwiKSkraik6Zi5kYXRhKFxcXCJ0b3BcXFwiLFxcXCJhdXRvXFxcIikpLGYuY3NzKFxcXCJib3R0b21cXFwiKSYmKFxcXCJhdXRvXFxcIiE9Zi5kYXRhKFxcXCJib3R0b21cXFwiKT9mLmNzcyhcXFwiYm90dG9tXFxcIixiLmhlbHBlcnMuZ2V0UFgoZi5kYXRhKFxcXCJib3R0b21cXFwiKSkrayk6Zi5jc3MoXFxcImJvdHRvbVxcXCIsXFxcImF1dG9cXFwiKSkpKTpiLm5vZGUuaGFzQ2xhc3MoZi5nZXQoMCksXFxcImZyLXN0aWNreS1vZmZcXFwiKXx8KGYud2lkdGgoXFxcIlxcXCIpLGYucmVtb3ZlQ2xhc3MoXFxcImZyLXN0aWNreS1vblxcXCIpLGYuYWRkQ2xhc3MoXFxcImZyLXN0aWNreS1vZmZcXFwiKSxmLmNzcyhcXFwidG9wXFxcIikmJlxcXCJhdXRvXFxcIiE9Zi5kYXRhKFxcXCJ0b3BcXFwiKSYmaC50b3AmJmYuY3NzKFxcXCJ0b3BcXFwiLDApLGYuY3NzKFxcXCJib3R0b21cXFwiKSYmXFxcImF1dG9cXFwiIT1mLmRhdGEoXFxcImJvdHRvbVxcXCIpJiZoLmJvdHRvbSYmZi5jc3MoXFxcImJvdHRvbVxcXCIsMCkpfX1mdW5jdGlvbiBqKCl7dmFyIGE9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcXFwidGVzdFxcXCIpLGM9YS5zdHlsZTtyZXR1cm4gYy5jc3NUZXh0PVxcXCJwb3NpdGlvbjpcXFwiK1tcXFwiLXdlYmtpdC1cXFwiLFxcXCItbW96LVxcXCIsXFxcIi1tcy1cXFwiLFxcXCItby1cXFwiLFxcXCJcXFwiXS5qb2luKFxcXCJzdGlja3k7IHBvc2l0aW9uOlxcXCIpK1xcXCIgc3RpY2t5O1xcXCIsYy5wb3NpdGlvbi5pbmRleE9mKFxcXCJzdGlja3lcXFwiKSE9PS0xJiYhYi5oZWxwZXJzLmlzSU9TKCkmJiFiLmhlbHBlcnMuaXNBbmRyb2lkKCkmJiFiLmJyb3dzZXIuY2hyb21lfWZ1bmN0aW9uIGsoKXtpZighaigpKWlmKGIuX3N0aWNreUVsZW1lbnRzPVtdLGIuaGVscGVycy5pc0lPUygpKXt2YXIgYz1mdW5jdGlvbigpe2IuaGVscGVycy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKShjKTtmb3IodmFyIGE9MDthPGIuX3N0aWNreUVsZW1lbnRzLmxlbmd0aDthKyspaChiLl9zdGlja3lFbGVtZW50c1thXSl9O2MoKSxiLmV2ZW50cy4kb24oYShiLm9fd2luKSxcXFwic2Nyb2xsXFxcIixmdW5jdGlvbigpe2lmKGIuY29yZS5oYXNGb2N1cygpKWZvcih2YXIgYz0wO2M8Yi5fc3RpY2t5RWxlbWVudHMubGVuZ3RoO2MrKyl7dmFyIGQ9YShiLl9zdGlja3lFbGVtZW50c1tjXSksZT1kLnBhcmVudCgpLGY9Yi5oZWxwZXJzLnNjcm9sbFRvcCgpO2Qub3V0ZXJIZWlnaHQoKTxmLWUub2Zmc2V0KCkudG9wJiYoZC5hZGRDbGFzcyhcXFwiZnItb3BhY2l0eS0wXFxcIiksZC5kYXRhKFxcXCJzdGlja3ktdG9wXFxcIiwtMSksZC5kYXRhKFxcXCJzdGlja3ktc2NoZWR1bGVkXFxcIiwtMSkpfX0sITApfWVsc2UgYi5ldmVudHMuJG9uKGEoXFxcImJvZHlcXFwiPT1iLm9wdHMuc2Nyb2xsYWJsZUNvbnRhaW5lcj9iLm9fd2luOmIub3B0cy5zY3JvbGxhYmxlQ29udGFpbmVyKSxcXFwic2Nyb2xsXFxcIixsLCEwKSxiLmV2ZW50cy4kb24oYShiLm9fd2luKSxcXFwicmVzaXplXFxcIixsLCEwKSxiLmV2ZW50cy5vbihcXFwiaW5pdGlhbGl6ZWRcXFwiLGwpLGIuZXZlbnRzLm9uKFxcXCJmb2N1c1xcXCIsbCksYi5ldmVudHMuJG9uKGEoYi5vX3dpbiksXFxcInJlc2l6ZVxcXCIsXFxcInRleHRhcmVhXFxcIixsLCEwKTtiLmV2ZW50cy5vbihcXFwiZGVzdHJveVxcXCIsZnVuY3Rpb24oKXtiLl9zdGlja3lFbGVtZW50cz1bXX0pfWZ1bmN0aW9uIGwoKXtpZihiLl9zdGlja3lFbGVtZW50cylmb3IodmFyIGE9MDthPGIuX3N0aWNreUVsZW1lbnRzLmxlbmd0aDthKyspaShiLl9zdGlja3lFbGVtZW50c1thXSl9ZnVuY3Rpb24gbShhKXthLmFkZENsYXNzKFxcXCJmci1zdGlja3lcXFwiKSxiLmhlbHBlcnMuaXNJT1MoKSYmYS5hZGRDbGFzcyhcXFwiZnItc3RpY2t5LWlvc1xcXCIpLGooKXx8Yi5fc3RpY2t5RWxlbWVudHMucHVzaChhLmdldCgwKSl9ZnVuY3Rpb24gbigpe2soKX1yZXR1cm57X2luaXQ6bixmb3JTZWxlY3Rpb246ZixhZGRTdGlja3k6bSxyZWZyZXNoOmwsYXQ6ZyxnZXRCb3VuZGluZ1JlY3Q6Y319LGEuRkUuTU9EVUxFUy5yZWZyZXNoPWZ1bmN0aW9uKGIpe2Z1bmN0aW9uIGMoYSl7ZyhhLCFiLnVuZG8uY2FuRG8oKSl9ZnVuY3Rpb24gZChhKXtnKGEsIWIudW5kby5jYW5SZWRvKCkpfWZ1bmN0aW9uIGUoYSl7aWYoYi5ub2RlLmhhc0NsYXNzKGEuZ2V0KDApLFxcXCJmci1uby1yZWZyZXNoXFxcIikpcmV0dXJuITE7Zm9yKHZhciBjPWIuc2VsZWN0aW9uLmJsb2NrcygpLGQ9MDtkPGMubGVuZ3RoO2QrKyl7Zm9yKHZhciBlPWNbZF0ucHJldmlvdXNTaWJsaW5nO2UmJmUubm9kZVR5cGU9PU5vZGUuVEVYVF9OT0RFJiYwPT09ZS50ZXh0Q29udGVudC5sZW5ndGg7KWU9ZS5wcmV2aW91c1NpYmxpbmc7aWYoXFxcIkxJXFxcIiE9Y1tkXS50YWdOYW1lfHxlKXJldHVybiBnKGEsITEpLCEwO2coYSwhMCl9fWZ1bmN0aW9uIGYoYyl7aWYoYi5ub2RlLmhhc0NsYXNzKGMuZ2V0KDApLFxcXCJmci1uby1yZWZyZXNoXFxcIikpcmV0dXJuITE7Zm9yKHZhciBkPWIuc2VsZWN0aW9uLmJsb2NrcygpLGU9MDtlPGQubGVuZ3RoO2UrKyl7dmFyIGY9XFxcInJ0bFxcXCI9PWIub3B0cy5kaXJlY3Rpb258fFxcXCJydGxcXFwiPT1hKGRbZV0pLmNzcyhcXFwiZGlyZWN0aW9uXFxcIik/XFxcIm1hcmdpbi1yaWdodFxcXCI6XFxcIm1hcmdpbi1sZWZ0XFxcIjtpZihcXFwiTElcXFwiPT1kW2VdLnRhZ05hbWV8fFxcXCJMSVxcXCI9PWRbZV0ucGFyZW50Tm9kZS50YWdOYW1lKXJldHVybiBnKGMsITEpLCEwO2lmKGIuaGVscGVycy5nZXRQWChhKGRbZV0pLmNzcyhmKSk+MClyZXR1cm4gZyhjLCExKSwhMH1nKGMsITApfWZ1bmN0aW9uIGcoYSxiKXthLnRvZ2dsZUNsYXNzKFxcXCJmci1kaXNhYmxlZFxcXCIsYikuYXR0cihcXFwiYXJpYS1kaXNhYmxlZFxcXCIsYil9cmV0dXJue3VuZG86YyxyZWRvOmQsb3V0ZGVudDpmLGluZGVudDplfX0sYS5leHRlbmQoYS5GRS5ERUZBVUxUUyx7ZWRpdEluUG9wdXA6ITF9KSxhLkZFLk1PRFVMRVMudGV4dEVkaXQ9ZnVuY3Rpb24oYil7ZnVuY3Rpb24gYygpe3ZhciBhPSc8ZGl2IGlkPVxcXCJmci10ZXh0LWVkaXQtJytiLmlkKydcXFwiIGNsYXNzPVxcXCJmci1sYXllciBmci10ZXh0LWVkaXQtbGF5ZXJcXFwiPjxkaXYgY2xhc3M9XFxcImZyLWlucHV0LWxpbmVcXFwiPjxpbnB1dCB0eXBlPVxcXCJ0ZXh0XFxcIiBwbGFjZWhvbGRlcj1cXFwiJytiLmxhbmd1YWdlLnRyYW5zbGF0ZShcXFwiVGV4dFxcXCIpKydcXFwiIHRhYkluZGV4PVxcXCIxXFxcIj48L2Rpdj48ZGl2IGNsYXNzPVxcXCJmci1hY3Rpb24tYnV0dG9uc1xcXCI+PGJ1dHRvbiB0eXBlPVxcXCJidXR0b25cXFwiIGNsYXNzPVxcXCJmci1jb21tYW5kIGZyLXN1Ym1pdFxcXCIgZGF0YS1jbWQ9XFxcInVwZGF0ZVRleHRcXFwiIHRhYkluZGV4PVxcXCIyXFxcIj4nK2IubGFuZ3VhZ2UudHJhbnNsYXRlKFxcXCJVcGRhdGVcXFwiKStcXFwiPC9idXR0b24+PC9kaXY+PC9kaXY+XFxcIixjPXtlZGl0OmF9O2IucG9wdXBzLmNyZWF0ZShcXFwidGV4dC5lZGl0XFxcIixjKX1mdW5jdGlvbiBkKCl7dmFyIGMsZD1iLnBvcHVwcy5nZXQoXFxcInRleHQuZWRpdFxcXCIpO2M9XFxcIklOUFVUXFxcIj09PWIuJGVsLnByb3AoXFxcInRhZ05hbWVcXFwiKT9iLiRlbC5hdHRyKFxcXCJwbGFjZWhvbGRlclxcXCIpOmIuJGVsLnRleHQoKSxkLmZpbmQoXFxcImlucHV0XFxcIikudmFsKGMpLnRyaWdnZXIoXFxcImNoYW5nZVxcXCIpLGIucG9wdXBzLnNldENvbnRhaW5lcihcXFwidGV4dC5lZGl0XFxcIixhKFxcXCJib2R5XFxcIikpLGIucG9wdXBzLnNob3coXFxcInRleHQuZWRpdFxcXCIsYi4kZWwub2Zmc2V0KCkubGVmdCtiLiRlbC5vdXRlcldpZHRoKCkvMixiLiRlbC5vZmZzZXQoKS50b3ArYi4kZWwub3V0ZXJIZWlnaHQoKSxiLiRlbC5vdXRlckhlaWdodCgpKX1mdW5jdGlvbiBlKCl7Yi5ldmVudHMuJG9uKGIuJGVsLGIuX21vdXNldXAsZnVuY3Rpb24oKXtzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7ZCgpfSwxMCl9KX1mdW5jdGlvbiBmKCl7dmFyIGE9Yi5wb3B1cHMuZ2V0KFxcXCJ0ZXh0LmVkaXRcXFwiKSxjPWEuZmluZChcXFwiaW5wdXRcXFwiKS52YWwoKTswPT09Yy5sZW5ndGgmJihjPWIub3B0cy5wbGFjZWhvbGRlclRleHQpLFxcXCJJTlBVVFxcXCI9PT1iLiRlbC5wcm9wKFxcXCJ0YWdOYW1lXFxcIik/Yi4kZWwuYXR0cihcXFwicGxhY2Vob2xkZXJcXFwiLGMpOmIuJGVsLnRleHQoYyksYi5ldmVudHMudHJpZ2dlcihcXFwiY29udGVudENoYW5nZWRcXFwiKSxiLnBvcHVwcy5oaWRlKFxcXCJ0ZXh0LmVkaXRcXFwiKX1mdW5jdGlvbiBnKCl7Yi5vcHRzLmVkaXRJblBvcHVwJiYoYygpLGUoKSl9cmV0dXJue19pbml0OmcsdXBkYXRlOmZ9fSxhLkZFLlJlZ2lzdGVyQ29tbWFuZChcXFwidXBkYXRlVGV4dFxcXCIse2ZvY3VzOiExLHVuZG86ITEsY2FsbGJhY2s6ZnVuY3Rpb24oKXt0aGlzLnRleHRFZGl0LnVwZGF0ZSgpfX0pLGEuZXh0ZW5kKGEuRkUuREVGQVVMVFMse3Rvb2xiYXJCb3R0b206ITEsdG9vbGJhckJ1dHRvbnM6W1xcXCJmdWxsc2NyZWVuXFxcIixcXFwicHJpbnRcXFwiLFxcXCJib2xkXFxcIixcXFwiaXRhbGljXFxcIixcXFwidW5kZXJsaW5lXFxcIixcXFwic3RyaWtlVGhyb3VnaFxcXCIsXFxcInN1YnNjcmlwdFxcXCIsXFxcInN1cGVyc2NyaXB0XFxcIixcXFwiZm9udEZhbWlseVxcXCIsXFxcImZvbnRTaXplXFxcIixcXFwifFxcXCIsXFxcInNwZWNpYWxDaGFyYWN0ZXJzXFxcIixcXFwiY29sb3JcXFwiLFxcXCJlbW90aWNvbnNcXFwiLFxcXCJpbmxpbmVTdHlsZVxcXCIsXFxcInBhcmFncmFwaFN0eWxlXFxcIixcXFwifFxcXCIsXFxcInBhcmFncmFwaEZvcm1hdFxcXCIsXFxcImFsaWduXFxcIixcXFwiZm9ybWF0T0xcXFwiLFxcXCJmb3JtYXRVTFxcXCIsXFxcIm91dGRlbnRcXFwiLFxcXCJpbmRlbnRcXFwiLFxcXCJxdW90ZVxcXCIsXFxcImluc2VydEhSXFxcIixcXFwiLVxcXCIsXFxcImluc2VydExpbmtcXFwiLFxcXCJpbnNlcnRJbWFnZVxcXCIsXFxcImluc2VydFZpZGVvXFxcIixcXFwiaW5zZXJ0RmlsZVxcXCIsXFxcImluc2VydFRhYmxlXFxcIixcXFwidW5kb1xcXCIsXFxcInJlZG9cXFwiLFxcXCJjbGVhckZvcm1hdHRpbmdcXFwiLFxcXCJzZWxlY3RBbGxcXFwiLFxcXCJodG1sXFxcIixcXFwiYXBwbHlGb3JtYXRcXFwiLFxcXCJyZW1vdmVGb3JtYXRcXFwiLFxcXCJoZWxwXFxcIl0sdG9vbGJhckJ1dHRvbnNYUzpbXFxcImJvbGRcXFwiLFxcXCJpdGFsaWNcXFwiLFxcXCJmb250RmFtaWx5XFxcIixcXFwiZm9udFNpemVcXFwiLFxcXCJ8XFxcIixcXFwidW5kb1xcXCIsXFxcInJlZG9cXFwiXSx0b29sYmFyQnV0dG9uc1NNOltcXFwiYm9sZFxcXCIsXFxcIml0YWxpY1xcXCIsXFxcInVuZGVybGluZVxcXCIsXFxcInxcXFwiLFxcXCJmb250RmFtaWx5XFxcIixcXFwiZm9udFNpemVcXFwiLFxcXCJpbnNlcnRMaW5rXFxcIixcXFwiaW5zZXJ0SW1hZ2VcXFwiLFxcXCJ0YWJsZVxcXCIsXFxcInxcXFwiLFxcXCJ1bmRvXFxcIixcXFwicmVkb1xcXCJdLHRvb2xiYXJCdXR0b25zTUQ6W1xcXCJmdWxsc2NyZWVuXFxcIixcXFwiYm9sZFxcXCIsXFxcIml0YWxpY1xcXCIsXFxcInVuZGVybGluZVxcXCIsXFxcImZvbnRGYW1pbHlcXFwiLFxcXCJmb250U2l6ZVxcXCIsXFxcImNvbG9yXFxcIixcXFwicGFyYWdyYXBoU3R5bGVcXFwiLFxcXCJwYXJhZ3JhcGhGb3JtYXRcXFwiLFxcXCJhbGlnblxcXCIsXFxcImZvcm1hdE9MXFxcIixcXFwiZm9ybWF0VUxcXFwiLFxcXCJvdXRkZW50XFxcIixcXFwiaW5kZW50XFxcIixcXFwicXVvdGVcXFwiLFxcXCJpbnNlcnRIUlxcXCIsXFxcIi1cXFwiLFxcXCJpbnNlcnRMaW5rXFxcIixcXFwiaW5zZXJ0SW1hZ2VcXFwiLFxcXCJpbnNlcnRWaWRlb1xcXCIsXFxcImluc2VydEZpbGVcXFwiLFxcXCJpbnNlcnRUYWJsZVxcXCIsXFxcInVuZG9cXFwiLFxcXCJyZWRvXFxcIixcXFwiY2xlYXJGb3JtYXR0aW5nXFxcIl0sdG9vbGJhckNvbnRhaW5lcjpudWxsLHRvb2xiYXJJbmxpbmU6ITEsdG9vbGJhclN0aWNreTohMCx0b29sYmFyU3RpY2t5T2Zmc2V0OjAsdG9vbGJhclZpc2libGVXaXRob3V0U2VsZWN0aW9uOiExfSksYS5GRS5NT0RVTEVTLnRvb2xiYXI9ZnVuY3Rpb24oYil7ZnVuY3Rpb24gYyhhLGIpe2Zvcih2YXIgYz0wO2M8Yi5sZW5ndGg7YysrKVxcXCItXFxcIiE9YltjXSYmXFxcInxcXFwiIT1iW2NdJiZhLmluZGV4T2YoYltjXSk8MCYmYS5wdXNoKGJbY10pfWZ1bmN0aW9uIGQoKXt2YXIgZD1hLm1lcmdlKFtdLGUoKSk7YyhkLGIub3B0cy50b29sYmFyQnV0dG9uc1hTfHxbXSksYyhkLGIub3B0cy50b29sYmFyQnV0dG9uc1NNfHxbXSksYyhkLGIub3B0cy50b29sYmFyQnV0dG9uc01EfHxbXSksYyhkLGIub3B0cy50b29sYmFyQnV0dG9ucyk7Zm9yKHZhciBmPWQubGVuZ3RoLTE7Zj49MDtmLS0pXFxcIi1cXFwiIT1kW2ZdJiZcXFwifFxcXCIhPWRbZl0mJmQuaW5kZXhPZihkW2ZdKTxmJiZkLnNwbGljZShmLDEpO3ZhciBnPWIuYnV0dG9uLmJ1aWxkTGlzdChkLGUoKSk7Yi4kdGIuYXBwZW5kKGcpLGIuYnV0dG9uLmJpbmRDb21tYW5kcyhiLiR0Yil9ZnVuY3Rpb24gZSgpe3ZhciBhPWIuaGVscGVycy5zY3JlZW5TaXplKCk7cmV0dXJuIHZbYV19ZnVuY3Rpb24gZigpe3ZhciBhPWUoKTtiLiR0Yi5maW5kKFxcXCIuZnItc2VwYXJhdG9yXFxcIikucmVtb3ZlKCksYi4kdGIuZmluZChcXFwiPiAuZnItY29tbWFuZFxcXCIpLmFkZENsYXNzKFxcXCJmci1oaWRkZW5cXFwiKTtmb3IodmFyIGM9MDtjPGEubGVuZ3RoO2MrKylpZihcXFwifFxcXCI9PWFbY118fFxcXCItXFxcIj09YVtjXSliLiR0Yi5hcHBlbmQoYi5idXR0b24uYnVpbGRMaXN0KFthW2NdXSkpO2Vsc2V7dmFyIGQ9Yi4kdGIuZmluZCgnPiAuZnItY29tbWFuZFtkYXRhLWNtZD1cXFwiJythW2NdKydcXFwiXScpLGY9bnVsbDtiLm5vZGUuaGFzQ2xhc3MoZC5uZXh0KCkuZ2V0KDApLFxcXCJmci1kcm9wZG93bi1tZW51XFxcIikmJihmPWQubmV4dCgpKSxkLnJlbW92ZUNsYXNzKFxcXCJmci1oaWRkZW5cXFwiKS5hcHBlbmRUbyhiLiR0YiksZiYmZi5hcHBlbmRUbyhiLiR0Yil9fWZ1bmN0aW9uIGcoKXtiLmV2ZW50cy4kb24oYShiLm9fd2luKSxcXFwicmVzaXplXFxcIixmKSxiLmV2ZW50cy4kb24oYShiLm9fd2luKSxcXFwib3JpZW50YXRpb25jaGFuZ2VcXFwiLGYpfWZ1bmN0aW9uIGgoYyxkKXtzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7aWYoKCFjfHxjLndoaWNoIT1hLkZFLktFWUNPREUuRVNDKSYmYi5zZWxlY3Rpb24uaW5FZGl0b3IoKSYmYi5jb3JlLmhhc0ZvY3VzKCkmJiFiLnBvcHVwcy5hcmVWaXNpYmxlKCkmJihiLm9wdHMudG9vbGJhclZpc2libGVXaXRob3V0U2VsZWN0aW9ufHwhYi5zZWxlY3Rpb24uaXNDb2xsYXBzZWQoKSYmIWIua2V5cy5pc0lNRSgpfHxkKSl7aWYoYi4kdGIuZGF0YShcXFwiaW5zdGFuY2VcXFwiLGIpLGIuZXZlbnRzLnRyaWdnZXIoXFxcInRvb2xiYXIuc2hvd1xcXCIsW2NdKT09PSExKXJldHVybiExO2IuJHRiLnNob3coKSxiLm9wdHMudG9vbGJhckNvbnRhaW5lcnx8Yi5wb3NpdGlvbi5mb3JTZWxlY3Rpb24oYi4kdGIpLGIub3B0cy56SW5kZXg+MT9iLiR0Yi5jc3MoXFxcInotaW5kZXhcXFwiLGIub3B0cy56SW5kZXgrMSk6Yi4kdGIuY3NzKFxcXCJ6LWluZGV4XFxcIixudWxsKX19LDApfWZ1bmN0aW9uIGkoKXt2YXIgYT1iLmJ1dHRvbi5nZXRCdXR0b25zKFxcXCIuZnItZHJvcGRvd24uZnItYWN0aXZlXFxcIik7cmV0dXJuISFhLm5leHQoKS5maW5kKGIub19kb2MuYWN0aXZlRWxlbWVudCkubGVuZ3RofHx2b2lkKGIuZXZlbnRzLnRyaWdnZXIoXFxcInRvb2xiYXIuaGlkZVxcXCIpIT09ITEmJmIuJHRiLmhpZGUoKSl9ZnVuY3Rpb24gaigpe3JldHVybiBiLmV2ZW50cy50cmlnZ2VyKFxcXCJ0b29sYmFyLnNob3dcXFwiKSE9PSExJiZ2b2lkIGIuJHRiLnNob3coKX1mdW5jdGlvbiBrKGMpe2NsZWFyVGltZW91dCh3KSxjJiZjLndoaWNoPT1hLkZFLktFWUNPREUuRVNDfHwodz1zZXRUaW1lb3V0KGgsYi5vcHRzLnR5cGluZ1RpbWVyKSl9ZnVuY3Rpb24gbCgpe2IuZXZlbnRzLm9uKFxcXCJ3aW5kb3cubW91c2Vkb3duXFxcIixpKSxiLmV2ZW50cy5vbihcXFwia2V5ZG93blxcXCIsaSksYi5ldmVudHMub24oXFxcImJsdXJcXFwiLGkpLGIuZXZlbnRzLm9uKFxcXCJ3aW5kb3cubW91c2V1cFxcXCIsaCksYi5oZWxwZXJzLmlzTW9iaWxlKCk/Yi5oZWxwZXJzLmlzSU9TKCl8fChiLmV2ZW50cy5vbihcXFwid2luZG93LnRvdWNoZW5kXFxcIixoKSxiLmJyb3dzZXIubW96aWxsYSYmc2V0SW50ZXJ2YWwoaCwyMDApKTpiLmV2ZW50cy5vbihcXFwid2luZG93LmtleXVwXFxcIixrKSxiLmV2ZW50cy5vbihcXFwia2V5ZG93blxcXCIsZnVuY3Rpb24oYil7YiYmYi53aGljaD09YS5GRS5LRVlDT0RFLkVTQyYmaSgpfSksYi5ldmVudHMub24oXFxcImtleWRvd25cXFwiLGZ1bmN0aW9uKGIpe2lmKGIud2hpY2g9PWEuRkUuS0VZQ09ERS5BTFQpcmV0dXJuIGIuc3RvcFByb3BhZ2F0aW9uKCksITF9LCEwKSxiLmV2ZW50cy4kb24oYi4kd3AsXFxcInNjcm9sbC50b29sYmFyXFxcIixoKSxiLmV2ZW50cy5vbihcXFwiY29tbWFuZHMuYWZ0ZXJcXFwiLGgpLGIuaGVscGVycy5pc01vYmlsZSgpJiYoYi5ldmVudHMuJG9uKGIuJGRvYyxcXFwic2VsZWN0aW9uY2hhbmdlXFxcIixrKSxiLmV2ZW50cy4kb24oYi4kZG9jLFxcXCJvcmllbnRhdGlvbmNoYW5nZVxcXCIsaCkpfWZ1bmN0aW9uIG0oKXtiLm9wdHMudG9vbGJhcklubGluZT8oYi4kc2MuYXBwZW5kKGIuJHRiKSxiLiR0Yi5kYXRhKFxcXCJjb250YWluZXJcXFwiLGIuJHNjKSxiLiR0Yi5hZGRDbGFzcyhcXFwiZnItaW5saW5lXFxcIiksYi4kdGIucHJlcGVuZCgnPHNwYW4gY2xhc3M9XFxcImZyLWFycm93XFxcIj48L3NwYW4+JyksbCgpLGIub3B0cy50b29sYmFyQm90dG9tPSExKTooYi5vcHRzLnRvb2xiYXJCb3R0b20mJiFiLmhlbHBlcnMuaXNJT1MoKT8oYi4kYm94LmFwcGVuZChiLiR0YiksYi4kdGIuYWRkQ2xhc3MoXFxcImZyLWJvdHRvbVxcXCIpLGIuJGJveC5hZGRDbGFzcyhcXFwiZnItYm90dG9tXFxcIikpOihiLm9wdHMudG9vbGJhckJvdHRvbT0hMSxiLiRib3gucHJlcGVuZChiLiR0YiksYi4kdGIuYWRkQ2xhc3MoXFxcImZyLXRvcFxcXCIpLGIuJGJveC5hZGRDbGFzcyhcXFwiZnItdG9wXFxcIikpLGIuJHRiLmFkZENsYXNzKFxcXCJmci1iYXNpY1xcXCIpLGIub3B0cy50b29sYmFyU3RpY2t5JiYoYi5vcHRzLnRvb2xiYXJTdGlja3lPZmZzZXQmJihiLm9wdHMudG9vbGJhckJvdHRvbT9iLiR0Yi5jc3MoXFxcImJvdHRvbVxcXCIsYi5vcHRzLnRvb2xiYXJTdGlja3lPZmZzZXQpOmIuJHRiLmNzcyhcXFwidG9wXFxcIixiLm9wdHMudG9vbGJhclN0aWNreU9mZnNldCkpLGIucG9zaXRpb24uYWRkU3RpY2t5KGIuJHRiKSkpfWZ1bmN0aW9uIG4oKXtiLiR0Yi5odG1sKFxcXCJcXFwiKS5yZW1vdmVEYXRhKCkucmVtb3ZlKCksYi4kdGI9bnVsbH1mdW5jdGlvbiBvKCl7Yi4kYm94LnJlbW92ZUNsYXNzKFxcXCJmci10b3AgZnItYm90dG9tIGZyLWlubGluZSBmci1iYXNpY1xcXCIpLGIuJGJveC5maW5kKFxcXCIuZnItc3RpY2t5LWR1bW15XFxcIikucmVtb3ZlKCl9ZnVuY3Rpb24gcCgpe2Iub3B0cy50aGVtZSYmYi4kdGIuYWRkQ2xhc3MoYi5vcHRzLnRoZW1lK1xcXCItdGhlbWVcXFwiKSxiLm9wdHMuekluZGV4PjEmJmIuJHRiLmNzcyhcXFwiei1pbmRleFxcXCIsYi5vcHRzLnpJbmRleCsxKSxcXFwiYXV0b1xcXCIhPWIub3B0cy5kaXJlY3Rpb24mJmIuJHRiLnJlbW92ZUNsYXNzKFxcXCJmci1sdHIgZnItcnRsXFxcIikuYWRkQ2xhc3MoXFxcImZyLVxcXCIrYi5vcHRzLmRpcmVjdGlvbiksYi5oZWxwZXJzLmlzTW9iaWxlKCk/Yi4kdGIuYWRkQ2xhc3MoXFxcImZyLW1vYmlsZVxcXCIpOmIuJHRiLmFkZENsYXNzKFxcXCJmci1kZXNrdG9wXFxcIiksYi5vcHRzLnRvb2xiYXJDb250YWluZXI/KGIub3B0cy50b29sYmFySW5saW5lJiYobCgpLGkoKSksYi5vcHRzLnRvb2xiYXJCb3R0b20/Yi4kdGIuYWRkQ2xhc3MoXFxcImZyLWJvdHRvbVxcXCIpOmIuJHRiLmFkZENsYXNzKFxcXCJmci10b3BcXFwiKSk6bSgpLHQ9Yi4kdGIuZ2V0KDApLm93bmVyRG9jdW1lbnQsdT1cXFwiZGVmYXVsdFZpZXdcXFwiaW4gdD90LmRlZmF1bHRWaWV3OnQucGFyZW50V2luZG93LGQoKSxnKCksYi5hY2Nlc3NpYmlsaXR5LnJlZ2lzdGVyVG9vbGJhcihiLiR0YiksYi5ldmVudHMuJG9uKGIuJHRiLGIuX21vdXNlZG93bitcXFwiIFxcXCIrYi5fbW91c2V1cCxmdW5jdGlvbihhKXt2YXIgYz1hLm9yaWdpbmFsRXZlbnQ/YS5vcmlnaW5hbEV2ZW50LnRhcmdldHx8YS5vcmlnaW5hbEV2ZW50Lm9yaWdpbmFsVGFyZ2V0Om51bGw7aWYoYyYmXFxcIklOUFVUXFxcIiE9Yy50YWdOYW1lJiYhYi5lZGl0LmlzRGlzYWJsZWQoKSlyZXR1cm4gYS5zdG9wUHJvcGFnYXRpb24oKSxhLnByZXZlbnREZWZhdWx0KCksITF9LCEwKX1mdW5jdGlvbiBxKCl7cmV0dXJuIGIuJHNjPWEoYi5vcHRzLnNjcm9sbGFibGVDb250YWluZXIpLCEhYi4kd3AmJihiLm9wdHMudG9vbGJhckNvbnRhaW5lcj8oYi5zaGFyZWQuJHRiPyhiLiR0Yj1iLnNoYXJlZC4kdGIsYi5vcHRzLnRvb2xiYXJJbmxpbmUmJmwoKSk6KGIuc2hhcmVkLiR0Yj1hKCc8ZGl2IGNsYXNzPVxcXCJmci10b29sYmFyXFxcIj48L2Rpdj4nKSxiLiR0Yj1iLnNoYXJlZC4kdGIsYShiLm9wdHMudG9vbGJhckNvbnRhaW5lcikuYXBwZW5kKGIuJHRiKSxwKCksYi4kdGIuZGF0YShcXFwiaW5zdGFuY2VcXFwiLGIpKSxiLm9wdHMudG9vbGJhcklubGluZT9iLiRib3guYWRkQ2xhc3MoXFxcImZyLWlubGluZVxcXCIpOmIuJGJveC5hZGRDbGFzcyhcXFwiZnItYmFzaWNcXFwiKSxiLmV2ZW50cy5vbihcXFwiZm9jdXNcXFwiLGZ1bmN0aW9uKCl7Yi4kdGIuZGF0YShcXFwiaW5zdGFuY2VcXFwiLGIpfSwhMCksYi5vcHRzLnRvb2xiYXJJbmxpbmU9ITEpOmIub3B0cy50b29sYmFySW5saW5lPyhiLiRib3guYWRkQ2xhc3MoXFxcImZyLWlubGluZVxcXCIpLGIuc2hhcmVkLiR0Yj8oYi4kdGI9Yi5zaGFyZWQuJHRiLGwoKSk6KGIuc2hhcmVkLiR0Yj1hKCc8ZGl2IGNsYXNzPVxcXCJmci10b29sYmFyXFxcIj48L2Rpdj4nKSxiLiR0Yj1iLnNoYXJlZC4kdGIscCgpKSk6KGIuJGJveC5hZGRDbGFzcyhcXFwiZnItYmFzaWNcXFwiKSxiLiR0Yj1hKCc8ZGl2IGNsYXNzPVxcXCJmci10b29sYmFyXFxcIj48L2Rpdj4nKSxwKCksYi4kdGIuZGF0YShcXFwiaW5zdGFuY2VcXFwiLGIpKSxiLmV2ZW50cy5vbihcXFwiZGVzdHJveVxcXCIsbywhMCksdm9pZCBiLmV2ZW50cy5vbihiLm9wdHMudG9vbGJhcklubGluZXx8Yi5vcHRzLnRvb2xiYXJDb250YWluZXI/XFxcInNoYXJlZC5kZXN0cm95XFxcIjpcXFwiZGVzdHJveVxcXCIsbiwhMCkpfWZ1bmN0aW9uIHIoKXsheCYmYi4kdGImJihiLiR0Yi5maW5kKFxcXCI+IC5mci1jb21tYW5kXFxcIikuYWRkQ2xhc3MoXFxcImZyLWRpc2FibGVkIGZyLW5vLXJlZnJlc2hcXFwiKS5hdHRyKFxcXCJhcmlhLWRpc2FibGVkXFxcIiwhMCkseD0hMCl9ZnVuY3Rpb24gcygpe3gmJmIuJHRiJiYoYi4kdGIuZmluZChcXFwiPiAuZnItY29tbWFuZFxcXCIpLnJlbW92ZUNsYXNzKFxcXCJmci1kaXNhYmxlZCBmci1uby1yZWZyZXNoXFxcIikuYXR0cihcXFwiYXJpYS1kaXNhYmxlZFxcXCIsITEpLHg9ITEpLGIuYnV0dG9uLmJ1bGtSZWZyZXNoKCl9dmFyIHQsdSx2PVtdO3ZbYS5GRS5YU109Yi5vcHRzLnRvb2xiYXJCdXR0b25zWFN8fGIub3B0cy50b29sYmFyQnV0dG9ucyx2W2EuRkUuU01dPWIub3B0cy50b29sYmFyQnV0dG9uc1NNfHxiLm9wdHMudG9vbGJhckJ1dHRvbnMsdlthLkZFLk1EXT1iLm9wdHMudG9vbGJhckJ1dHRvbnNNRHx8Yi5vcHRzLnRvb2xiYXJCdXR0b25zLHZbYS5GRS5MR109Yi5vcHRzLnRvb2xiYXJCdXR0b25zO3ZhciB3PW51bGwseD0hMTtyZXR1cm57X2luaXQ6cSxoaWRlOmksc2hvdzpqLHNob3dJbmxpbmU6aCxkaXNhYmxlOnIsZW5hYmxlOnN9fX0pO1wiXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3Jhdy1sb2FkZXIhLi9+L2Zyb2FsYS1lZGl0b3IvanMvZnJvYWxhX2VkaXRvci5taW4uanNcbi8vIG1vZHVsZSBpZCA9IDNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQSIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	eval("__webpack_require__(2)(__webpack_require__(5))//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL34vY29kZW1pcnJvci9saWIvY29kZW1pcnJvci5qcz8yNTI1Il0sInNvdXJjZXNDb250ZW50IjpbInJlcXVpcmUoXCIhIS9Vc2Vycy9qYWt1YmZhamt1cy9Eb2N1bWVudHMvcHJhY2UvdmVuaWNlLWRlbW8vd2ViL2pzL25vZGVfbW9kdWxlcy9zY3JpcHQtbG9hZGVyL2FkZFNjcmlwdC5qc1wiKShyZXF1aXJlKFwiISEvVXNlcnMvamFrdWJmYWprdXMvRG9jdW1lbnRzL3ByYWNlL3ZlbmljZS1kZW1vL3dlYi9qcy9ub2RlX21vZHVsZXMvcmF3LWxvYWRlci9pbmRleC5qcyEvVXNlcnMvamFrdWJmYWprdXMvRG9jdW1lbnRzL3ByYWNlL3ZlbmljZS1kZW1vL3dlYi9qcy9ub2RlX21vZHVsZXMvY29kZW1pcnJvci9saWIvY29kZW1pcnJvci5qc1wiKSlcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vc2NyaXB0LWxvYWRlciEuL34vY29kZW1pcnJvci9saWIvY29kZW1pcnJvci5qc1xuLy8gbW9kdWxlIGlkID0gNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 5 */
/***/ function(module, exports) {

	eval("module.exports = \"// CodeMirror, copyright (c) by Marijn Haverbeke and others\\n// Distributed under an MIT license: http://codemirror.net/LICENSE\\n\\n// This is CodeMirror (http://codemirror.net), a code editor\\n// implemented in JavaScript on top of the browser's DOM.\\n//\\n// You can find some technical background for some of the code below\\n// at http://marijnhaverbeke.nl/blog/#cm-internals .\\n\\n(function (global, factory) {\\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\\n  typeof define === 'function' && define.amd ? define(factory) :\\n  (global.CodeMirror = factory());\\n}(this, (function () { 'use strict';\\n\\n// Kludges for bugs and behavior differences that can't be feature\\n// detected are enabled based on userAgent etc sniffing.\\nvar userAgent = navigator.userAgent\\nvar platform = navigator.platform\\n\\nvar gecko = /gecko\\\\/\\\\d/i.test(userAgent)\\nvar ie_upto10 = /MSIE \\\\d/.test(userAgent)\\nvar ie_11up = /Trident\\\\/(?:[7-9]|\\\\d{2,})\\\\..*rv:(\\\\d+)/.exec(userAgent)\\nvar edge = /Edge\\\\/(\\\\d+)/.exec(userAgent)\\nvar ie = ie_upto10 || ie_11up || edge\\nvar ie_version = ie && (ie_upto10 ? document.documentMode || 6 : +(edge || ie_11up)[1])\\nvar webkit = !edge && /WebKit\\\\//.test(userAgent)\\nvar qtwebkit = webkit && /Qt\\\\/\\\\d+\\\\.\\\\d+/.test(userAgent)\\nvar chrome = !edge && /Chrome\\\\//.test(userAgent)\\nvar presto = /Opera\\\\//.test(userAgent)\\nvar safari = /Apple Computer/.test(navigator.vendor)\\nvar mac_geMountainLion = /Mac OS X 1\\\\d\\\\D([8-9]|\\\\d\\\\d)\\\\D/.test(userAgent)\\nvar phantom = /PhantomJS/.test(userAgent)\\n\\nvar ios = !edge && /AppleWebKit/.test(userAgent) && /Mobile\\\\/\\\\w+/.test(userAgent)\\n// This is woefully incomplete. Suggestions for alternative methods welcome.\\nvar mobile = ios || /Android|webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(userAgent)\\nvar mac = ios || /Mac/.test(platform)\\nvar chromeOS = /\\\\bCrOS\\\\b/.test(userAgent)\\nvar windows = /win/i.test(platform)\\n\\nvar presto_version = presto && userAgent.match(/Version\\\\/(\\\\d*\\\\.\\\\d*)/)\\nif (presto_version) { presto_version = Number(presto_version[1]) }\\nif (presto_version && presto_version >= 15) { presto = false; webkit = true }\\n// Some browsers use the wrong event properties to signal cmd/ctrl on OS X\\nvar flipCtrlCmd = mac && (qtwebkit || presto && (presto_version == null || presto_version < 12.11))\\nvar captureRightClick = gecko || (ie && ie_version >= 9)\\n\\nfunction classTest(cls) { return new RegExp(\\\"(^|\\\\\\\\s)\\\" + cls + \\\"(?:$|\\\\\\\\s)\\\\\\\\s*\\\") }\\n\\nvar rmClass = function(node, cls) {\\n  var current = node.className\\n  var match = classTest(cls).exec(current)\\n  if (match) {\\n    var after = current.slice(match.index + match[0].length)\\n    node.className = current.slice(0, match.index) + (after ? match[1] + after : \\\"\\\")\\n  }\\n}\\n\\nfunction removeChildren(e) {\\n  for (var count = e.childNodes.length; count > 0; --count)\\n    { e.removeChild(e.firstChild) }\\n  return e\\n}\\n\\nfunction removeChildrenAndAdd(parent, e) {\\n  return removeChildren(parent).appendChild(e)\\n}\\n\\nfunction elt(tag, content, className, style) {\\n  var e = document.createElement(tag)\\n  if (className) { e.className = className }\\n  if (style) { e.style.cssText = style }\\n  if (typeof content == \\\"string\\\") { e.appendChild(document.createTextNode(content)) }\\n  else if (content) { for (var i = 0; i < content.length; ++i) { e.appendChild(content[i]) } }\\n  return e\\n}\\n\\nvar range\\nif (document.createRange) { range = function(node, start, end, endNode) {\\n  var r = document.createRange()\\n  r.setEnd(endNode || node, end)\\n  r.setStart(node, start)\\n  return r\\n} }\\nelse { range = function(node, start, end) {\\n  var r = document.body.createTextRange()\\n  try { r.moveToElementText(node.parentNode) }\\n  catch(e) { return r }\\n  r.collapse(true)\\n  r.moveEnd(\\\"character\\\", end)\\n  r.moveStart(\\\"character\\\", start)\\n  return r\\n} }\\n\\nfunction contains(parent, child) {\\n  if (child.nodeType == 3) // Android browser always returns false when child is a textnode\\n    { child = child.parentNode }\\n  if (parent.contains)\\n    { return parent.contains(child) }\\n  do {\\n    if (child.nodeType == 11) { child = child.host }\\n    if (child == parent) { return true }\\n  } while (child = child.parentNode)\\n}\\n\\nfunction activeElt() {\\n  // IE and Edge may throw an \\\"Unspecified Error\\\" when accessing document.activeElement.\\n  // IE < 10 will throw when accessed while the page is loading or in an iframe.\\n  // IE > 9 and Edge will throw when accessed in an iframe if document.body is unavailable.\\n  var activeElement\\n  try {\\n    activeElement = document.activeElement\\n  } catch(e) {\\n    activeElement = document.body || null\\n  }\\n  while (activeElement && activeElement.root && activeElement.root.activeElement)\\n    { activeElement = activeElement.root.activeElement }\\n  return activeElement\\n}\\n\\nfunction addClass(node, cls) {\\n  var current = node.className\\n  if (!classTest(cls).test(current)) { node.className += (current ? \\\" \\\" : \\\"\\\") + cls }\\n}\\nfunction joinClasses(a, b) {\\n  var as = a.split(\\\" \\\")\\n  for (var i = 0; i < as.length; i++)\\n    { if (as[i] && !classTest(as[i]).test(b)) { b += \\\" \\\" + as[i] } }\\n  return b\\n}\\n\\nvar selectInput = function(node) { node.select() }\\nif (ios) // Mobile Safari apparently has a bug where select() is broken.\\n  { selectInput = function(node) { node.selectionStart = 0; node.selectionEnd = node.value.length } }\\nelse if (ie) // Suppress mysterious IE10 errors\\n  { selectInput = function(node) { try { node.select() } catch(_e) {} } }\\n\\nfunction bind(f) {\\n  var args = Array.prototype.slice.call(arguments, 1)\\n  return function(){return f.apply(null, args)}\\n}\\n\\nfunction copyObj(obj, target, overwrite) {\\n  if (!target) { target = {} }\\n  for (var prop in obj)\\n    { if (obj.hasOwnProperty(prop) && (overwrite !== false || !target.hasOwnProperty(prop)))\\n      { target[prop] = obj[prop] } }\\n  return target\\n}\\n\\n// Counts the column offset in a string, taking tabs into account.\\n// Used mostly to find indentation.\\nfunction countColumn(string, end, tabSize, startIndex, startValue) {\\n  if (end == null) {\\n    end = string.search(/[^\\\\s\\\\u00a0]/)\\n    if (end == -1) { end = string.length }\\n  }\\n  for (var i = startIndex || 0, n = startValue || 0;;) {\\n    var nextTab = string.indexOf(\\\"\\\\t\\\", i)\\n    if (nextTab < 0 || nextTab >= end)\\n      { return n + (end - i) }\\n    n += nextTab - i\\n    n += tabSize - (n % tabSize)\\n    i = nextTab + 1\\n  }\\n}\\n\\nvar Delayed = function() {this.id = null};\\nDelayed.prototype.set = function (ms, f) {\\n  clearTimeout(this.id)\\n  this.id = setTimeout(f, ms)\\n};\\n\\nfunction indexOf(array, elt) {\\n  for (var i = 0; i < array.length; ++i)\\n    { if (array[i] == elt) { return i } }\\n  return -1\\n}\\n\\n// Number of pixels added to scroller and sizer to hide scrollbar\\nvar scrollerGap = 30\\n\\n// Returned or thrown by various protocols to signal 'I'm not\\n// handling this'.\\nvar Pass = {toString: function(){return \\\"CodeMirror.Pass\\\"}}\\n\\n// Reused option objects for setSelection & friends\\nvar sel_dontScroll = {scroll: false};\\nvar sel_mouse = {origin: \\\"*mouse\\\"};\\nvar sel_move = {origin: \\\"+move\\\"};\\n// The inverse of countColumn -- find the offset that corresponds to\\n// a particular column.\\nfunction findColumn(string, goal, tabSize) {\\n  for (var pos = 0, col = 0;;) {\\n    var nextTab = string.indexOf(\\\"\\\\t\\\", pos)\\n    if (nextTab == -1) { nextTab = string.length }\\n    var skipped = nextTab - pos\\n    if (nextTab == string.length || col + skipped >= goal)\\n      { return pos + Math.min(skipped, goal - col) }\\n    col += nextTab - pos\\n    col += tabSize - (col % tabSize)\\n    pos = nextTab + 1\\n    if (col >= goal) { return pos }\\n  }\\n}\\n\\nvar spaceStrs = [\\\"\\\"]\\nfunction spaceStr(n) {\\n  while (spaceStrs.length <= n)\\n    { spaceStrs.push(lst(spaceStrs) + \\\" \\\") }\\n  return spaceStrs[n]\\n}\\n\\nfunction lst(arr) { return arr[arr.length-1] }\\n\\nfunction map(array, f) {\\n  var out = []\\n  for (var i = 0; i < array.length; i++) { out[i] = f(array[i], i) }\\n  return out\\n}\\n\\nfunction insertSorted(array, value, score) {\\n  var pos = 0, priority = score(value)\\n  while (pos < array.length && score(array[pos]) <= priority) { pos++ }\\n  array.splice(pos, 0, value)\\n}\\n\\nfunction nothing() {}\\n\\nfunction createObj(base, props) {\\n  var inst\\n  if (Object.create) {\\n    inst = Object.create(base)\\n  } else {\\n    nothing.prototype = base\\n    inst = new nothing()\\n  }\\n  if (props) { copyObj(props, inst) }\\n  return inst\\n}\\n\\nvar nonASCIISingleCaseWordChar = /[\\\\u00df\\\\u0587\\\\u0590-\\\\u05f4\\\\u0600-\\\\u06ff\\\\u3040-\\\\u309f\\\\u30a0-\\\\u30ff\\\\u3400-\\\\u4db5\\\\u4e00-\\\\u9fcc\\\\uac00-\\\\ud7af]/\\nfunction isWordCharBasic(ch) {\\n  return /\\\\w/.test(ch) || ch > \\\"\\\\x80\\\" &&\\n    (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch))\\n}\\nfunction isWordChar(ch, helper) {\\n  if (!helper) { return isWordCharBasic(ch) }\\n  if (helper.source.indexOf(\\\"\\\\\\\\w\\\") > -1 && isWordCharBasic(ch)) { return true }\\n  return helper.test(ch)\\n}\\n\\nfunction isEmpty(obj) {\\n  for (var n in obj) { if (obj.hasOwnProperty(n) && obj[n]) { return false } }\\n  return true\\n}\\n\\n// Extending unicode characters. A series of a non-extending char +\\n// any number of extending chars is treated as a single unit as far\\n// as editing and measuring is concerned. This is not fully correct,\\n// since some scripts/fonts/browsers also treat other configurations\\n// of code points as a group.\\nvar extendingChars = /[\\\\u0300-\\\\u036f\\\\u0483-\\\\u0489\\\\u0591-\\\\u05bd\\\\u05bf\\\\u05c1\\\\u05c2\\\\u05c4\\\\u05c5\\\\u05c7\\\\u0610-\\\\u061a\\\\u064b-\\\\u065e\\\\u0670\\\\u06d6-\\\\u06dc\\\\u06de-\\\\u06e4\\\\u06e7\\\\u06e8\\\\u06ea-\\\\u06ed\\\\u0711\\\\u0730-\\\\u074a\\\\u07a6-\\\\u07b0\\\\u07eb-\\\\u07f3\\\\u0816-\\\\u0819\\\\u081b-\\\\u0823\\\\u0825-\\\\u0827\\\\u0829-\\\\u082d\\\\u0900-\\\\u0902\\\\u093c\\\\u0941-\\\\u0948\\\\u094d\\\\u0951-\\\\u0955\\\\u0962\\\\u0963\\\\u0981\\\\u09bc\\\\u09be\\\\u09c1-\\\\u09c4\\\\u09cd\\\\u09d7\\\\u09e2\\\\u09e3\\\\u0a01\\\\u0a02\\\\u0a3c\\\\u0a41\\\\u0a42\\\\u0a47\\\\u0a48\\\\u0a4b-\\\\u0a4d\\\\u0a51\\\\u0a70\\\\u0a71\\\\u0a75\\\\u0a81\\\\u0a82\\\\u0abc\\\\u0ac1-\\\\u0ac5\\\\u0ac7\\\\u0ac8\\\\u0acd\\\\u0ae2\\\\u0ae3\\\\u0b01\\\\u0b3c\\\\u0b3e\\\\u0b3f\\\\u0b41-\\\\u0b44\\\\u0b4d\\\\u0b56\\\\u0b57\\\\u0b62\\\\u0b63\\\\u0b82\\\\u0bbe\\\\u0bc0\\\\u0bcd\\\\u0bd7\\\\u0c3e-\\\\u0c40\\\\u0c46-\\\\u0c48\\\\u0c4a-\\\\u0c4d\\\\u0c55\\\\u0c56\\\\u0c62\\\\u0c63\\\\u0cbc\\\\u0cbf\\\\u0cc2\\\\u0cc6\\\\u0ccc\\\\u0ccd\\\\u0cd5\\\\u0cd6\\\\u0ce2\\\\u0ce3\\\\u0d3e\\\\u0d41-\\\\u0d44\\\\u0d4d\\\\u0d57\\\\u0d62\\\\u0d63\\\\u0dca\\\\u0dcf\\\\u0dd2-\\\\u0dd4\\\\u0dd6\\\\u0ddf\\\\u0e31\\\\u0e34-\\\\u0e3a\\\\u0e47-\\\\u0e4e\\\\u0eb1\\\\u0eb4-\\\\u0eb9\\\\u0ebb\\\\u0ebc\\\\u0ec8-\\\\u0ecd\\\\u0f18\\\\u0f19\\\\u0f35\\\\u0f37\\\\u0f39\\\\u0f71-\\\\u0f7e\\\\u0f80-\\\\u0f84\\\\u0f86\\\\u0f87\\\\u0f90-\\\\u0f97\\\\u0f99-\\\\u0fbc\\\\u0fc6\\\\u102d-\\\\u1030\\\\u1032-\\\\u1037\\\\u1039\\\\u103a\\\\u103d\\\\u103e\\\\u1058\\\\u1059\\\\u105e-\\\\u1060\\\\u1071-\\\\u1074\\\\u1082\\\\u1085\\\\u1086\\\\u108d\\\\u109d\\\\u135f\\\\u1712-\\\\u1714\\\\u1732-\\\\u1734\\\\u1752\\\\u1753\\\\u1772\\\\u1773\\\\u17b7-\\\\u17bd\\\\u17c6\\\\u17c9-\\\\u17d3\\\\u17dd\\\\u180b-\\\\u180d\\\\u18a9\\\\u1920-\\\\u1922\\\\u1927\\\\u1928\\\\u1932\\\\u1939-\\\\u193b\\\\u1a17\\\\u1a18\\\\u1a56\\\\u1a58-\\\\u1a5e\\\\u1a60\\\\u1a62\\\\u1a65-\\\\u1a6c\\\\u1a73-\\\\u1a7c\\\\u1a7f\\\\u1b00-\\\\u1b03\\\\u1b34\\\\u1b36-\\\\u1b3a\\\\u1b3c\\\\u1b42\\\\u1b6b-\\\\u1b73\\\\u1b80\\\\u1b81\\\\u1ba2-\\\\u1ba5\\\\u1ba8\\\\u1ba9\\\\u1c2c-\\\\u1c33\\\\u1c36\\\\u1c37\\\\u1cd0-\\\\u1cd2\\\\u1cd4-\\\\u1ce0\\\\u1ce2-\\\\u1ce8\\\\u1ced\\\\u1dc0-\\\\u1de6\\\\u1dfd-\\\\u1dff\\\\u200c\\\\u200d\\\\u20d0-\\\\u20f0\\\\u2cef-\\\\u2cf1\\\\u2de0-\\\\u2dff\\\\u302a-\\\\u302f\\\\u3099\\\\u309a\\\\ua66f-\\\\ua672\\\\ua67c\\\\ua67d\\\\ua6f0\\\\ua6f1\\\\ua802\\\\ua806\\\\ua80b\\\\ua825\\\\ua826\\\\ua8c4\\\\ua8e0-\\\\ua8f1\\\\ua926-\\\\ua92d\\\\ua947-\\\\ua951\\\\ua980-\\\\ua982\\\\ua9b3\\\\ua9b6-\\\\ua9b9\\\\ua9bc\\\\uaa29-\\\\uaa2e\\\\uaa31\\\\uaa32\\\\uaa35\\\\uaa36\\\\uaa43\\\\uaa4c\\\\uaab0\\\\uaab2-\\\\uaab4\\\\uaab7\\\\uaab8\\\\uaabe\\\\uaabf\\\\uaac1\\\\uabe5\\\\uabe8\\\\uabed\\\\udc00-\\\\udfff\\\\ufb1e\\\\ufe00-\\\\ufe0f\\\\ufe20-\\\\ufe26\\\\uff9e\\\\uff9f]/\\nfunction isExtendingChar(ch) { return ch.charCodeAt(0) >= 768 && extendingChars.test(ch) }\\n\\n// Returns a number from the range [`0`; `str.length`] unless `pos` is outside that range.\\nfunction skipExtendingChars(str, pos, dir) {\\n  while ((dir < 0 ? pos > 0 : pos < str.length) && isExtendingChar(str.charAt(pos))) { pos += dir }\\n  return pos\\n}\\n\\n// Returns the value from the range [`from`; `to`] that satisfies\\n// `pred` and is closest to `from`. Assumes that at least `to` satisfies `pred`.\\nfunction findFirst(pred, from, to) {\\n  for (;;) {\\n    if (Math.abs(from - to) <= 1) { return pred(from) ? from : to }\\n    var mid = Math.floor((from + to) / 2)\\n    if (pred(mid)) { to = mid }\\n    else { from = mid }\\n  }\\n}\\n\\n// The display handles the DOM integration, both for input reading\\n// and content drawing. It holds references to DOM nodes and\\n// display-related state.\\n\\nfunction Display(place, doc, input) {\\n  var d = this\\n  this.input = input\\n\\n  // Covers bottom-right square when both scrollbars are present.\\n  d.scrollbarFiller = elt(\\\"div\\\", null, \\\"CodeMirror-scrollbar-filler\\\")\\n  d.scrollbarFiller.setAttribute(\\\"cm-not-content\\\", \\\"true\\\")\\n  // Covers bottom of gutter when coverGutterNextToScrollbar is on\\n  // and h scrollbar is present.\\n  d.gutterFiller = elt(\\\"div\\\", null, \\\"CodeMirror-gutter-filler\\\")\\n  d.gutterFiller.setAttribute(\\\"cm-not-content\\\", \\\"true\\\")\\n  // Will contain the actual code, positioned to cover the viewport.\\n  d.lineDiv = elt(\\\"div\\\", null, \\\"CodeMirror-code\\\")\\n  // Elements are added to these to represent selection and cursors.\\n  d.selectionDiv = elt(\\\"div\\\", null, null, \\\"position: relative; z-index: 1\\\")\\n  d.cursorDiv = elt(\\\"div\\\", null, \\\"CodeMirror-cursors\\\")\\n  // A visibility: hidden element used to find the size of things.\\n  d.measure = elt(\\\"div\\\", null, \\\"CodeMirror-measure\\\")\\n  // When lines outside of the viewport are measured, they are drawn in this.\\n  d.lineMeasure = elt(\\\"div\\\", null, \\\"CodeMirror-measure\\\")\\n  // Wraps everything that needs to exist inside the vertically-padded coordinate system\\n  d.lineSpace = elt(\\\"div\\\", [d.measure, d.lineMeasure, d.selectionDiv, d.cursorDiv, d.lineDiv],\\n                    null, \\\"position: relative; outline: none\\\")\\n  // Moved around its parent to cover visible view.\\n  d.mover = elt(\\\"div\\\", [elt(\\\"div\\\", [d.lineSpace], \\\"CodeMirror-lines\\\")], null, \\\"position: relative\\\")\\n  // Set to the height of the document, allowing scrolling.\\n  d.sizer = elt(\\\"div\\\", [d.mover], \\\"CodeMirror-sizer\\\")\\n  d.sizerWidth = null\\n  // Behavior of elts with overflow: auto and padding is\\n  // inconsistent across browsers. This is used to ensure the\\n  // scrollable area is big enough.\\n  d.heightForcer = elt(\\\"div\\\", null, null, \\\"position: absolute; height: \\\" + scrollerGap + \\\"px; width: 1px;\\\")\\n  // Will contain the gutters, if any.\\n  d.gutters = elt(\\\"div\\\", null, \\\"CodeMirror-gutters\\\")\\n  d.lineGutter = null\\n  // Actual scrollable element.\\n  d.scroller = elt(\\\"div\\\", [d.sizer, d.heightForcer, d.gutters], \\\"CodeMirror-scroll\\\")\\n  d.scroller.setAttribute(\\\"tabIndex\\\", \\\"-1\\\")\\n  // The element in which the editor lives.\\n  d.wrapper = elt(\\\"div\\\", [d.scrollbarFiller, d.gutterFiller, d.scroller], \\\"CodeMirror\\\")\\n\\n  // Work around IE7 z-index bug (not perfect, hence IE7 not really being supported)\\n  if (ie && ie_version < 8) { d.gutters.style.zIndex = -1; d.scroller.style.paddingRight = 0 }\\n  if (!webkit && !(gecko && mobile)) { d.scroller.draggable = true }\\n\\n  if (place) {\\n    if (place.appendChild) { place.appendChild(d.wrapper) }\\n    else { place(d.wrapper) }\\n  }\\n\\n  // Current rendered range (may be bigger than the view window).\\n  d.viewFrom = d.viewTo = doc.first\\n  d.reportedViewFrom = d.reportedViewTo = doc.first\\n  // Information about the rendered lines.\\n  d.view = []\\n  d.renderedView = null\\n  // Holds info about a single rendered line when it was rendered\\n  // for measurement, while not in view.\\n  d.externalMeasured = null\\n  // Empty space (in pixels) above the view\\n  d.viewOffset = 0\\n  d.lastWrapHeight = d.lastWrapWidth = 0\\n  d.updateLineNumbers = null\\n\\n  d.nativeBarWidth = d.barHeight = d.barWidth = 0\\n  d.scrollbarsClipped = false\\n\\n  // Used to only resize the line number gutter when necessary (when\\n  // the amount of lines crosses a boundary that makes its width change)\\n  d.lineNumWidth = d.lineNumInnerWidth = d.lineNumChars = null\\n  // Set to true when a non-horizontal-scrolling line widget is\\n  // added. As an optimization, line widget aligning is skipped when\\n  // this is false.\\n  d.alignWidgets = false\\n\\n  d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null\\n\\n  // Tracks the maximum line length so that the horizontal scrollbar\\n  // can be kept static when scrolling.\\n  d.maxLine = null\\n  d.maxLineLength = 0\\n  d.maxLineChanged = false\\n\\n  // Used for measuring wheel scrolling granularity\\n  d.wheelDX = d.wheelDY = d.wheelStartX = d.wheelStartY = null\\n\\n  // True when shift is held down.\\n  d.shift = false\\n\\n  // Used to track whether anything happened since the context menu\\n  // was opened.\\n  d.selForContextMenu = null\\n\\n  d.activeTouch = null\\n\\n  input.init(d)\\n}\\n\\n// Find the line object corresponding to the given line number.\\nfunction getLine(doc, n) {\\n  n -= doc.first\\n  if (n < 0 || n >= doc.size) { throw new Error(\\\"There is no line \\\" + (n + doc.first) + \\\" in the document.\\\") }\\n  var chunk = doc\\n  while (!chunk.lines) {\\n    for (var i = 0;; ++i) {\\n      var child = chunk.children[i], sz = child.chunkSize()\\n      if (n < sz) { chunk = child; break }\\n      n -= sz\\n    }\\n  }\\n  return chunk.lines[n]\\n}\\n\\n// Get the part of a document between two positions, as an array of\\n// strings.\\nfunction getBetween(doc, start, end) {\\n  var out = [], n = start.line\\n  doc.iter(start.line, end.line + 1, function (line) {\\n    var text = line.text\\n    if (n == end.line) { text = text.slice(0, end.ch) }\\n    if (n == start.line) { text = text.slice(start.ch) }\\n    out.push(text)\\n    ++n\\n  })\\n  return out\\n}\\n// Get the lines between from and to, as array of strings.\\nfunction getLines(doc, from, to) {\\n  var out = []\\n  doc.iter(from, to, function (line) { out.push(line.text) }) // iter aborts when callback returns truthy value\\n  return out\\n}\\n\\n// Update the height of a line, propagating the height change\\n// upwards to parent nodes.\\nfunction updateLineHeight(line, height) {\\n  var diff = height - line.height\\n  if (diff) { for (var n = line; n; n = n.parent) { n.height += diff } }\\n}\\n\\n// Given a line object, find its line number by walking up through\\n// its parent links.\\nfunction lineNo(line) {\\n  if (line.parent == null) { return null }\\n  var cur = line.parent, no = indexOf(cur.lines, line)\\n  for (var chunk = cur.parent; chunk; cur = chunk, chunk = chunk.parent) {\\n    for (var i = 0;; ++i) {\\n      if (chunk.children[i] == cur) { break }\\n      no += chunk.children[i].chunkSize()\\n    }\\n  }\\n  return no + cur.first\\n}\\n\\n// Find the line at the given vertical position, using the height\\n// information in the document tree.\\nfunction lineAtHeight(chunk, h) {\\n  var n = chunk.first\\n  outer: do {\\n    for (var i$1 = 0; i$1 < chunk.children.length; ++i$1) {\\n      var child = chunk.children[i$1], ch = child.height\\n      if (h < ch) { chunk = child; continue outer }\\n      h -= ch\\n      n += child.chunkSize()\\n    }\\n    return n\\n  } while (!chunk.lines)\\n  var i = 0\\n  for (; i < chunk.lines.length; ++i) {\\n    var line = chunk.lines[i], lh = line.height\\n    if (h < lh) { break }\\n    h -= lh\\n  }\\n  return n + i\\n}\\n\\nfunction isLine(doc, l) {return l >= doc.first && l < doc.first + doc.size}\\n\\nfunction lineNumberFor(options, i) {\\n  return String(options.lineNumberFormatter(i + options.firstLineNumber))\\n}\\n\\n// A Pos instance represents a position within the text.\\nfunction Pos(line, ch, sticky) {\\n  if ( sticky === void 0 ) sticky = null;\\n\\n  if (!(this instanceof Pos)) { return new Pos(line, ch, sticky) }\\n  this.line = line\\n  this.ch = ch\\n  this.sticky = sticky\\n}\\n\\n// Compare two positions, return 0 if they are the same, a negative\\n// number when a is less, and a positive number otherwise.\\nfunction cmp(a, b) { return a.line - b.line || a.ch - b.ch }\\n\\nfunction equalCursorPos(a, b) { return a.sticky == b.sticky && cmp(a, b) == 0 }\\n\\nfunction copyPos(x) {return Pos(x.line, x.ch)}\\nfunction maxPos(a, b) { return cmp(a, b) < 0 ? b : a }\\nfunction minPos(a, b) { return cmp(a, b) < 0 ? a : b }\\n\\n// Most of the external API clips given positions to make sure they\\n// actually exist within the document.\\nfunction clipLine(doc, n) {return Math.max(doc.first, Math.min(n, doc.first + doc.size - 1))}\\nfunction clipPos(doc, pos) {\\n  if (pos.line < doc.first) { return Pos(doc.first, 0) }\\n  var last = doc.first + doc.size - 1\\n  if (pos.line > last) { return Pos(last, getLine(doc, last).text.length) }\\n  return clipToLen(pos, getLine(doc, pos.line).text.length)\\n}\\nfunction clipToLen(pos, linelen) {\\n  var ch = pos.ch\\n  if (ch == null || ch > linelen) { return Pos(pos.line, linelen) }\\n  else if (ch < 0) { return Pos(pos.line, 0) }\\n  else { return pos }\\n}\\nfunction clipPosArray(doc, array) {\\n  var out = []\\n  for (var i = 0; i < array.length; i++) { out[i] = clipPos(doc, array[i]) }\\n  return out\\n}\\n\\n// Optimize some code when these features are not used.\\nvar sawReadOnlySpans = false;\\nvar sawCollapsedSpans = false;\\nfunction seeReadOnlySpans() {\\n  sawReadOnlySpans = true\\n}\\n\\nfunction seeCollapsedSpans() {\\n  sawCollapsedSpans = true\\n}\\n\\n// TEXTMARKER SPANS\\n\\nfunction MarkedSpan(marker, from, to) {\\n  this.marker = marker\\n  this.from = from; this.to = to\\n}\\n\\n// Search an array of spans for a span matching the given marker.\\nfunction getMarkedSpanFor(spans, marker) {\\n  if (spans) { for (var i = 0; i < spans.length; ++i) {\\n    var span = spans[i]\\n    if (span.marker == marker) { return span }\\n  } }\\n}\\n// Remove a span from an array, returning undefined if no spans are\\n// left (we don't store arrays for lines without spans).\\nfunction removeMarkedSpan(spans, span) {\\n  var r\\n  for (var i = 0; i < spans.length; ++i)\\n    { if (spans[i] != span) { (r || (r = [])).push(spans[i]) } }\\n  return r\\n}\\n// Add a span to a line.\\nfunction addMarkedSpan(line, span) {\\n  line.markedSpans = line.markedSpans ? line.markedSpans.concat([span]) : [span]\\n  span.marker.attachLine(line)\\n}\\n\\n// Used for the algorithm that adjusts markers for a change in the\\n// document. These functions cut an array of spans at a given\\n// character position, returning an array of remaining chunks (or\\n// undefined if nothing remains).\\nfunction markedSpansBefore(old, startCh, isInsert) {\\n  var nw\\n  if (old) { for (var i = 0; i < old.length; ++i) {\\n    var span = old[i], marker = span.marker\\n    var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= startCh : span.from < startCh)\\n    if (startsBefore || span.from == startCh && marker.type == \\\"bookmark\\\" && (!isInsert || !span.marker.insertLeft)) {\\n      var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= startCh : span.to > startCh)\\n      ;(nw || (nw = [])).push(new MarkedSpan(marker, span.from, endsAfter ? null : span.to))\\n    }\\n  } }\\n  return nw\\n}\\nfunction markedSpansAfter(old, endCh, isInsert) {\\n  var nw\\n  if (old) { for (var i = 0; i < old.length; ++i) {\\n    var span = old[i], marker = span.marker\\n    var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= endCh : span.to > endCh)\\n    if (endsAfter || span.from == endCh && marker.type == \\\"bookmark\\\" && (!isInsert || span.marker.insertLeft)) {\\n      var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= endCh : span.from < endCh)\\n      ;(nw || (nw = [])).push(new MarkedSpan(marker, startsBefore ? null : span.from - endCh,\\n                                            span.to == null ? null : span.to - endCh))\\n    }\\n  } }\\n  return nw\\n}\\n\\n// Given a change object, compute the new set of marker spans that\\n// cover the line in which the change took place. Removes spans\\n// entirely within the change, reconnects spans belonging to the\\n// same marker that appear on both sides of the change, and cuts off\\n// spans partially within the change. Returns an array of span\\n// arrays with one element for each line in (after) the change.\\nfunction stretchSpansOverChange(doc, change) {\\n  if (change.full) { return null }\\n  var oldFirst = isLine(doc, change.from.line) && getLine(doc, change.from.line).markedSpans\\n  var oldLast = isLine(doc, change.to.line) && getLine(doc, change.to.line).markedSpans\\n  if (!oldFirst && !oldLast) { return null }\\n\\n  var startCh = change.from.ch, endCh = change.to.ch, isInsert = cmp(change.from, change.to) == 0\\n  // Get the spans that 'stick out' on both sides\\n  var first = markedSpansBefore(oldFirst, startCh, isInsert)\\n  var last = markedSpansAfter(oldLast, endCh, isInsert)\\n\\n  // Next, merge those two ends\\n  var sameLine = change.text.length == 1, offset = lst(change.text).length + (sameLine ? startCh : 0)\\n  if (first) {\\n    // Fix up .to properties of first\\n    for (var i = 0; i < first.length; ++i) {\\n      var span = first[i]\\n      if (span.to == null) {\\n        var found = getMarkedSpanFor(last, span.marker)\\n        if (!found) { span.to = startCh }\\n        else if (sameLine) { span.to = found.to == null ? null : found.to + offset }\\n      }\\n    }\\n  }\\n  if (last) {\\n    // Fix up .from in last (or move them into first in case of sameLine)\\n    for (var i$1 = 0; i$1 < last.length; ++i$1) {\\n      var span$1 = last[i$1]\\n      if (span$1.to != null) { span$1.to += offset }\\n      if (span$1.from == null) {\\n        var found$1 = getMarkedSpanFor(first, span$1.marker)\\n        if (!found$1) {\\n          span$1.from = offset\\n          if (sameLine) { (first || (first = [])).push(span$1) }\\n        }\\n      } else {\\n        span$1.from += offset\\n        if (sameLine) { (first || (first = [])).push(span$1) }\\n      }\\n    }\\n  }\\n  // Make sure we didn't create any zero-length spans\\n  if (first) { first = clearEmptySpans(first) }\\n  if (last && last != first) { last = clearEmptySpans(last) }\\n\\n  var newMarkers = [first]\\n  if (!sameLine) {\\n    // Fill gap with whole-line-spans\\n    var gap = change.text.length - 2, gapMarkers\\n    if (gap > 0 && first)\\n      { for (var i$2 = 0; i$2 < first.length; ++i$2)\\n        { if (first[i$2].to == null)\\n          { (gapMarkers || (gapMarkers = [])).push(new MarkedSpan(first[i$2].marker, null, null)) } } }\\n    for (var i$3 = 0; i$3 < gap; ++i$3)\\n      { newMarkers.push(gapMarkers) }\\n    newMarkers.push(last)\\n  }\\n  return newMarkers\\n}\\n\\n// Remove spans that are empty and don't have a clearWhenEmpty\\n// option of false.\\nfunction clearEmptySpans(spans) {\\n  for (var i = 0; i < spans.length; ++i) {\\n    var span = spans[i]\\n    if (span.from != null && span.from == span.to && span.marker.clearWhenEmpty !== false)\\n      { spans.splice(i--, 1) }\\n  }\\n  if (!spans.length) { return null }\\n  return spans\\n}\\n\\n// Used to 'clip' out readOnly ranges when making a change.\\nfunction removeReadOnlyRanges(doc, from, to) {\\n  var markers = null\\n  doc.iter(from.line, to.line + 1, function (line) {\\n    if (line.markedSpans) { for (var i = 0; i < line.markedSpans.length; ++i) {\\n      var mark = line.markedSpans[i].marker\\n      if (mark.readOnly && (!markers || indexOf(markers, mark) == -1))\\n        { (markers || (markers = [])).push(mark) }\\n    } }\\n  })\\n  if (!markers) { return null }\\n  var parts = [{from: from, to: to}]\\n  for (var i = 0; i < markers.length; ++i) {\\n    var mk = markers[i], m = mk.find(0)\\n    for (var j = 0; j < parts.length; ++j) {\\n      var p = parts[j]\\n      if (cmp(p.to, m.from) < 0 || cmp(p.from, m.to) > 0) { continue }\\n      var newParts = [j, 1], dfrom = cmp(p.from, m.from), dto = cmp(p.to, m.to)\\n      if (dfrom < 0 || !mk.inclusiveLeft && !dfrom)\\n        { newParts.push({from: p.from, to: m.from}) }\\n      if (dto > 0 || !mk.inclusiveRight && !dto)\\n        { newParts.push({from: m.to, to: p.to}) }\\n      parts.splice.apply(parts, newParts)\\n      j += newParts.length - 3\\n    }\\n  }\\n  return parts\\n}\\n\\n// Connect or disconnect spans from a line.\\nfunction detachMarkedSpans(line) {\\n  var spans = line.markedSpans\\n  if (!spans) { return }\\n  for (var i = 0; i < spans.length; ++i)\\n    { spans[i].marker.detachLine(line) }\\n  line.markedSpans = null\\n}\\nfunction attachMarkedSpans(line, spans) {\\n  if (!spans) { return }\\n  for (var i = 0; i < spans.length; ++i)\\n    { spans[i].marker.attachLine(line) }\\n  line.markedSpans = spans\\n}\\n\\n// Helpers used when computing which overlapping collapsed span\\n// counts as the larger one.\\nfunction extraLeft(marker) { return marker.inclusiveLeft ? -1 : 0 }\\nfunction extraRight(marker) { return marker.inclusiveRight ? 1 : 0 }\\n\\n// Returns a number indicating which of two overlapping collapsed\\n// spans is larger (and thus includes the other). Falls back to\\n// comparing ids when the spans cover exactly the same range.\\nfunction compareCollapsedMarkers(a, b) {\\n  var lenDiff = a.lines.length - b.lines.length\\n  if (lenDiff != 0) { return lenDiff }\\n  var aPos = a.find(), bPos = b.find()\\n  var fromCmp = cmp(aPos.from, bPos.from) || extraLeft(a) - extraLeft(b)\\n  if (fromCmp) { return -fromCmp }\\n  var toCmp = cmp(aPos.to, bPos.to) || extraRight(a) - extraRight(b)\\n  if (toCmp) { return toCmp }\\n  return b.id - a.id\\n}\\n\\n// Find out whether a line ends or starts in a collapsed span. If\\n// so, return the marker for that span.\\nfunction collapsedSpanAtSide(line, start) {\\n  var sps = sawCollapsedSpans && line.markedSpans, found\\n  if (sps) { for (var sp = (void 0), i = 0; i < sps.length; ++i) {\\n    sp = sps[i]\\n    if (sp.marker.collapsed && (start ? sp.from : sp.to) == null &&\\n        (!found || compareCollapsedMarkers(found, sp.marker) < 0))\\n      { found = sp.marker }\\n  } }\\n  return found\\n}\\nfunction collapsedSpanAtStart(line) { return collapsedSpanAtSide(line, true) }\\nfunction collapsedSpanAtEnd(line) { return collapsedSpanAtSide(line, false) }\\n\\n// Test whether there exists a collapsed span that partially\\n// overlaps (covers the start or end, but not both) of a new span.\\n// Such overlap is not allowed.\\nfunction conflictingCollapsedRange(doc, lineNo, from, to, marker) {\\n  var line = getLine(doc, lineNo)\\n  var sps = sawCollapsedSpans && line.markedSpans\\n  if (sps) { for (var i = 0; i < sps.length; ++i) {\\n    var sp = sps[i]\\n    if (!sp.marker.collapsed) { continue }\\n    var found = sp.marker.find(0)\\n    var fromCmp = cmp(found.from, from) || extraLeft(sp.marker) - extraLeft(marker)\\n    var toCmp = cmp(found.to, to) || extraRight(sp.marker) - extraRight(marker)\\n    if (fromCmp >= 0 && toCmp <= 0 || fromCmp <= 0 && toCmp >= 0) { continue }\\n    if (fromCmp <= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.to, from) >= 0 : cmp(found.to, from) > 0) ||\\n        fromCmp >= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.from, to) <= 0 : cmp(found.from, to) < 0))\\n      { return true }\\n  } }\\n}\\n\\n// A visual line is a line as drawn on the screen. Folding, for\\n// example, can cause multiple logical lines to appear on the same\\n// visual line. This finds the start of the visual line that the\\n// given line is part of (usually that is the line itself).\\nfunction visualLine(line) {\\n  var merged\\n  while (merged = collapsedSpanAtStart(line))\\n    { line = merged.find(-1, true).line }\\n  return line\\n}\\n\\nfunction visualLineEnd(line) {\\n  var merged\\n  while (merged = collapsedSpanAtEnd(line))\\n    { line = merged.find(1, true).line }\\n  return line\\n}\\n\\n// Returns an array of logical lines that continue the visual line\\n// started by the argument, or undefined if there are no such lines.\\nfunction visualLineContinued(line) {\\n  var merged, lines\\n  while (merged = collapsedSpanAtEnd(line)) {\\n    line = merged.find(1, true).line\\n    ;(lines || (lines = [])).push(line)\\n  }\\n  return lines\\n}\\n\\n// Get the line number of the start of the visual line that the\\n// given line number is part of.\\nfunction visualLineNo(doc, lineN) {\\n  var line = getLine(doc, lineN), vis = visualLine(line)\\n  if (line == vis) { return lineN }\\n  return lineNo(vis)\\n}\\n\\n// Get the line number of the start of the next visual line after\\n// the given line.\\nfunction visualLineEndNo(doc, lineN) {\\n  if (lineN > doc.lastLine()) { return lineN }\\n  var line = getLine(doc, lineN), merged\\n  if (!lineIsHidden(doc, line)) { return lineN }\\n  while (merged = collapsedSpanAtEnd(line))\\n    { line = merged.find(1, true).line }\\n  return lineNo(line) + 1\\n}\\n\\n// Compute whether a line is hidden. Lines count as hidden when they\\n// are part of a visual line that starts with another line, or when\\n// they are entirely covered by collapsed, non-widget span.\\nfunction lineIsHidden(doc, line) {\\n  var sps = sawCollapsedSpans && line.markedSpans\\n  if (sps) { for (var sp = (void 0), i = 0; i < sps.length; ++i) {\\n    sp = sps[i]\\n    if (!sp.marker.collapsed) { continue }\\n    if (sp.from == null) { return true }\\n    if (sp.marker.widgetNode) { continue }\\n    if (sp.from == 0 && sp.marker.inclusiveLeft && lineIsHiddenInner(doc, line, sp))\\n      { return true }\\n  } }\\n}\\nfunction lineIsHiddenInner(doc, line, span) {\\n  if (span.to == null) {\\n    var end = span.marker.find(1, true)\\n    return lineIsHiddenInner(doc, end.line, getMarkedSpanFor(end.line.markedSpans, span.marker))\\n  }\\n  if (span.marker.inclusiveRight && span.to == line.text.length)\\n    { return true }\\n  for (var sp = (void 0), i = 0; i < line.markedSpans.length; ++i) {\\n    sp = line.markedSpans[i]\\n    if (sp.marker.collapsed && !sp.marker.widgetNode && sp.from == span.to &&\\n        (sp.to == null || sp.to != span.from) &&\\n        (sp.marker.inclusiveLeft || span.marker.inclusiveRight) &&\\n        lineIsHiddenInner(doc, line, sp)) { return true }\\n  }\\n}\\n\\n// Find the height above the given line.\\nfunction heightAtLine(lineObj) {\\n  lineObj = visualLine(lineObj)\\n\\n  var h = 0, chunk = lineObj.parent\\n  for (var i = 0; i < chunk.lines.length; ++i) {\\n    var line = chunk.lines[i]\\n    if (line == lineObj) { break }\\n    else { h += line.height }\\n  }\\n  for (var p = chunk.parent; p; chunk = p, p = chunk.parent) {\\n    for (var i$1 = 0; i$1 < p.children.length; ++i$1) {\\n      var cur = p.children[i$1]\\n      if (cur == chunk) { break }\\n      else { h += cur.height }\\n    }\\n  }\\n  return h\\n}\\n\\n// Compute the character length of a line, taking into account\\n// collapsed ranges (see markText) that might hide parts, and join\\n// other lines onto it.\\nfunction lineLength(line) {\\n  if (line.height == 0) { return 0 }\\n  var len = line.text.length, merged, cur = line\\n  while (merged = collapsedSpanAtStart(cur)) {\\n    var found = merged.find(0, true)\\n    cur = found.from.line\\n    len += found.from.ch - found.to.ch\\n  }\\n  cur = line\\n  while (merged = collapsedSpanAtEnd(cur)) {\\n    var found$1 = merged.find(0, true)\\n    len -= cur.text.length - found$1.from.ch\\n    cur = found$1.to.line\\n    len += cur.text.length - found$1.to.ch\\n  }\\n  return len\\n}\\n\\n// Find the longest line in the document.\\nfunction findMaxLine(cm) {\\n  var d = cm.display, doc = cm.doc\\n  d.maxLine = getLine(doc, doc.first)\\n  d.maxLineLength = lineLength(d.maxLine)\\n  d.maxLineChanged = true\\n  doc.iter(function (line) {\\n    var len = lineLength(line)\\n    if (len > d.maxLineLength) {\\n      d.maxLineLength = len\\n      d.maxLine = line\\n    }\\n  })\\n}\\n\\n// BIDI HELPERS\\n\\nfunction iterateBidiSections(order, from, to, f) {\\n  if (!order) { return f(from, to, \\\"ltr\\\") }\\n  var found = false\\n  for (var i = 0; i < order.length; ++i) {\\n    var part = order[i]\\n    if (part.from < to && part.to > from || from == to && part.to == from) {\\n      f(Math.max(part.from, from), Math.min(part.to, to), part.level == 1 ? \\\"rtl\\\" : \\\"ltr\\\")\\n      found = true\\n    }\\n  }\\n  if (!found) { f(from, to, \\\"ltr\\\") }\\n}\\n\\nvar bidiOther = null\\nfunction getBidiPartAt(order, ch, sticky) {\\n  var found\\n  bidiOther = null\\n  for (var i = 0; i < order.length; ++i) {\\n    var cur = order[i]\\n    if (cur.from < ch && cur.to > ch) { return i }\\n    if (cur.to == ch) {\\n      if (cur.from != cur.to && sticky == \\\"before\\\") { found = i }\\n      else { bidiOther = i }\\n    }\\n    if (cur.from == ch) {\\n      if (cur.from != cur.to && sticky != \\\"before\\\") { found = i }\\n      else { bidiOther = i }\\n    }\\n  }\\n  return found != null ? found : bidiOther\\n}\\n\\n// Bidirectional ordering algorithm\\n// See http://unicode.org/reports/tr9/tr9-13.html for the algorithm\\n// that this (partially) implements.\\n\\n// One-char codes used for character types:\\n// L (L):   Left-to-Right\\n// R (R):   Right-to-Left\\n// r (AL):  Right-to-Left Arabic\\n// 1 (EN):  European Number\\n// + (ES):  European Number Separator\\n// % (ET):  European Number Terminator\\n// n (AN):  Arabic Number\\n// , (CS):  Common Number Separator\\n// m (NSM): Non-Spacing Mark\\n// b (BN):  Boundary Neutral\\n// s (B):   Paragraph Separator\\n// t (S):   Segment Separator\\n// w (WS):  Whitespace\\n// N (ON):  Other Neutrals\\n\\n// Returns null if characters are ordered as they appear\\n// (left-to-right), or an array of sections ({from, to, level}\\n// objects) in the order in which they occur visually.\\nvar bidiOrdering = (function() {\\n  // Character types for codepoints 0 to 0xff\\n  var lowTypes = \\\"bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN\\\"\\n  // Character types for codepoints 0x600 to 0x6f9\\n  var arabicTypes = \\\"nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111\\\"\\n  function charType(code) {\\n    if (code <= 0xf7) { return lowTypes.charAt(code) }\\n    else if (0x590 <= code && code <= 0x5f4) { return \\\"R\\\" }\\n    else if (0x600 <= code && code <= 0x6f9) { return arabicTypes.charAt(code - 0x600) }\\n    else if (0x6ee <= code && code <= 0x8ac) { return \\\"r\\\" }\\n    else if (0x2000 <= code && code <= 0x200b) { return \\\"w\\\" }\\n    else if (code == 0x200c) { return \\\"b\\\" }\\n    else { return \\\"L\\\" }\\n  }\\n\\n  var bidiRE = /[\\\\u0590-\\\\u05f4\\\\u0600-\\\\u06ff\\\\u0700-\\\\u08ac]/\\n  var isNeutral = /[stwN]/, isStrong = /[LRr]/, countsAsLeft = /[Lb1n]/, countsAsNum = /[1n]/\\n  // Browsers seem to always treat the boundaries of block elements as being L.\\n  var outerType = \\\"L\\\"\\n\\n  function BidiSpan(level, from, to) {\\n    this.level = level\\n    this.from = from; this.to = to\\n  }\\n\\n  return function(str) {\\n    if (!bidiRE.test(str)) { return false }\\n    var len = str.length, types = []\\n    for (var i = 0; i < len; ++i)\\n      { types.push(charType(str.charCodeAt(i))) }\\n\\n    // W1. Examine each non-spacing mark (NSM) in the level run, and\\n    // change the type of the NSM to the type of the previous\\n    // character. If the NSM is at the start of the level run, it will\\n    // get the type of sor.\\n    for (var i$1 = 0, prev = outerType; i$1 < len; ++i$1) {\\n      var type = types[i$1]\\n      if (type == \\\"m\\\") { types[i$1] = prev }\\n      else { prev = type }\\n    }\\n\\n    // W2. Search backwards from each instance of a European number\\n    // until the first strong type (R, L, AL, or sor) is found. If an\\n    // AL is found, change the type of the European number to Arabic\\n    // number.\\n    // W3. Change all ALs to R.\\n    for (var i$2 = 0, cur = outerType; i$2 < len; ++i$2) {\\n      var type$1 = types[i$2]\\n      if (type$1 == \\\"1\\\" && cur == \\\"r\\\") { types[i$2] = \\\"n\\\" }\\n      else if (isStrong.test(type$1)) { cur = type$1; if (type$1 == \\\"r\\\") { types[i$2] = \\\"R\\\" } }\\n    }\\n\\n    // W4. A single European separator between two European numbers\\n    // changes to a European number. A single common separator between\\n    // two numbers of the same type changes to that type.\\n    for (var i$3 = 1, prev$1 = types[0]; i$3 < len - 1; ++i$3) {\\n      var type$2 = types[i$3]\\n      if (type$2 == \\\"+\\\" && prev$1 == \\\"1\\\" && types[i$3+1] == \\\"1\\\") { types[i$3] = \\\"1\\\" }\\n      else if (type$2 == \\\",\\\" && prev$1 == types[i$3+1] &&\\n               (prev$1 == \\\"1\\\" || prev$1 == \\\"n\\\")) { types[i$3] = prev$1 }\\n      prev$1 = type$2\\n    }\\n\\n    // W5. A sequence of European terminators adjacent to European\\n    // numbers changes to all European numbers.\\n    // W6. Otherwise, separators and terminators change to Other\\n    // Neutral.\\n    for (var i$4 = 0; i$4 < len; ++i$4) {\\n      var type$3 = types[i$4]\\n      if (type$3 == \\\",\\\") { types[i$4] = \\\"N\\\" }\\n      else if (type$3 == \\\"%\\\") {\\n        var end = (void 0)\\n        for (end = i$4 + 1; end < len && types[end] == \\\"%\\\"; ++end) {}\\n        var replace = (i$4 && types[i$4-1] == \\\"!\\\") || (end < len && types[end] == \\\"1\\\") ? \\\"1\\\" : \\\"N\\\"\\n        for (var j = i$4; j < end; ++j) { types[j] = replace }\\n        i$4 = end - 1\\n      }\\n    }\\n\\n    // W7. Search backwards from each instance of a European number\\n    // until the first strong type (R, L, or sor) is found. If an L is\\n    // found, then change the type of the European number to L.\\n    for (var i$5 = 0, cur$1 = outerType; i$5 < len; ++i$5) {\\n      var type$4 = types[i$5]\\n      if (cur$1 == \\\"L\\\" && type$4 == \\\"1\\\") { types[i$5] = \\\"L\\\" }\\n      else if (isStrong.test(type$4)) { cur$1 = type$4 }\\n    }\\n\\n    // N1. A sequence of neutrals takes the direction of the\\n    // surrounding strong text if the text on both sides has the same\\n    // direction. European and Arabic numbers act as if they were R in\\n    // terms of their influence on neutrals. Start-of-level-run (sor)\\n    // and end-of-level-run (eor) are used at level run boundaries.\\n    // N2. Any remaining neutrals take the embedding direction.\\n    for (var i$6 = 0; i$6 < len; ++i$6) {\\n      if (isNeutral.test(types[i$6])) {\\n        var end$1 = (void 0)\\n        for (end$1 = i$6 + 1; end$1 < len && isNeutral.test(types[end$1]); ++end$1) {}\\n        var before = (i$6 ? types[i$6-1] : outerType) == \\\"L\\\"\\n        var after = (end$1 < len ? types[end$1] : outerType) == \\\"L\\\"\\n        var replace$1 = before || after ? \\\"L\\\" : \\\"R\\\"\\n        for (var j$1 = i$6; j$1 < end$1; ++j$1) { types[j$1] = replace$1 }\\n        i$6 = end$1 - 1\\n      }\\n    }\\n\\n    // Here we depart from the documented algorithm, in order to avoid\\n    // building up an actual levels array. Since there are only three\\n    // levels (0, 1, 2) in an implementation that doesn't take\\n    // explicit embedding into account, we can build up the order on\\n    // the fly, without following the level-based algorithm.\\n    var order = [], m\\n    for (var i$7 = 0; i$7 < len;) {\\n      if (countsAsLeft.test(types[i$7])) {\\n        var start = i$7\\n        for (++i$7; i$7 < len && countsAsLeft.test(types[i$7]); ++i$7) {}\\n        order.push(new BidiSpan(0, start, i$7))\\n      } else {\\n        var pos = i$7, at = order.length\\n        for (++i$7; i$7 < len && types[i$7] != \\\"L\\\"; ++i$7) {}\\n        for (var j$2 = pos; j$2 < i$7;) {\\n          if (countsAsNum.test(types[j$2])) {\\n            if (pos < j$2) { order.splice(at, 0, new BidiSpan(1, pos, j$2)) }\\n            var nstart = j$2\\n            for (++j$2; j$2 < i$7 && countsAsNum.test(types[j$2]); ++j$2) {}\\n            order.splice(at, 0, new BidiSpan(2, nstart, j$2))\\n            pos = j$2\\n          } else { ++j$2 }\\n        }\\n        if (pos < i$7) { order.splice(at, 0, new BidiSpan(1, pos, i$7)) }\\n      }\\n    }\\n    if (order[0].level == 1 && (m = str.match(/^\\\\s+/))) {\\n      order[0].from = m[0].length\\n      order.unshift(new BidiSpan(0, 0, m[0].length))\\n    }\\n    if (lst(order).level == 1 && (m = str.match(/\\\\s+$/))) {\\n      lst(order).to -= m[0].length\\n      order.push(new BidiSpan(0, len - m[0].length, len))\\n    }\\n\\n    return order\\n  }\\n})()\\n\\n// Get the bidi ordering for the given line (and cache it). Returns\\n// false for lines that are fully left-to-right, and an array of\\n// BidiSpan objects otherwise.\\nfunction getOrder(line) {\\n  var order = line.order\\n  if (order == null) { order = line.order = bidiOrdering(line.text) }\\n  return order\\n}\\n\\nfunction moveCharLogically(line, ch, dir) {\\n  var target = skipExtendingChars(line.text, ch + dir, dir)\\n  return target < 0 || target > line.text.length ? null : target\\n}\\n\\nfunction moveLogically(line, start, dir) {\\n  var ch = moveCharLogically(line, start.ch, dir)\\n  return ch == null ? null : new Pos(start.line, ch, dir < 0 ? \\\"after\\\" : \\\"before\\\")\\n}\\n\\nfunction endOfLine(visually, cm, lineObj, lineNo, dir) {\\n  if (visually) {\\n    var order = getOrder(lineObj)\\n    if (order) {\\n      var part = dir < 0 ? lst(order) : order[0]\\n      var moveInStorageOrder = (dir < 0) == (part.level == 1)\\n      var sticky = moveInStorageOrder ? \\\"after\\\" : \\\"before\\\"\\n      var ch\\n      // With a wrapped rtl chunk (possibly spanning multiple bidi parts),\\n      // it could be that the last bidi part is not on the last visual line,\\n      // since visual lines contain content order-consecutive chunks.\\n      // Thus, in rtl, we are looking for the first (content-order) character\\n      // in the rtl chunk that is on the last line (that is, the same line\\n      // as the last (content-order) character).\\n      if (part.level > 0) {\\n        var prep = prepareMeasureForLine(cm, lineObj)\\n        ch = dir < 0 ? lineObj.text.length - 1 : 0\\n        var targetTop = measureCharPrepared(cm, prep, ch).top\\n        ch = findFirst(function (ch) { return measureCharPrepared(cm, prep, ch).top == targetTop; }, (dir < 0) == (part.level == 1) ? part.from : part.to - 1, ch)\\n        if (sticky == \\\"before\\\") { ch = moveCharLogically(lineObj, ch, 1, true) }\\n      } else { ch = dir < 0 ? part.to : part.from }\\n      return new Pos(lineNo, ch, sticky)\\n    }\\n  }\\n  return new Pos(lineNo, dir < 0 ? lineObj.text.length : 0, dir < 0 ? \\\"before\\\" : \\\"after\\\")\\n}\\n\\nfunction moveVisually(cm, line, start, dir) {\\n  var bidi = getOrder(line)\\n  if (!bidi) { return moveLogically(line, start, dir) }\\n  if (start.ch >= line.text.length) {\\n    start.ch = line.text.length\\n    start.sticky = \\\"before\\\"\\n  } else if (start.ch <= 0) {\\n    start.ch = 0\\n    start.sticky = \\\"after\\\"\\n  }\\n  var partPos = getBidiPartAt(bidi, start.ch, start.sticky), part = bidi[partPos]\\n  if (part.level % 2 == 0 && (dir > 0 ? part.to > start.ch : part.from < start.ch)) {\\n    // Case 1: We move within an ltr part. Even with wrapped lines,\\n    // nothing interesting happens.\\n    return moveLogically(line, start, dir)\\n  }\\n\\n  var mv = function (pos, dir) { return moveCharLogically(line, pos instanceof Pos ? pos.ch : pos, dir); }\\n  var prep\\n  var getWrappedLineExtent = function (ch) {\\n    if (!cm.options.lineWrapping) { return {begin: 0, end: line.text.length} }\\n    prep = prep || prepareMeasureForLine(cm, line)\\n    return wrappedLineExtentChar(cm, line, prep, ch)\\n  }\\n  var wrappedLineExtent = getWrappedLineExtent(start.sticky == \\\"before\\\" ? mv(start, -1) : start.ch)\\n\\n  if (part.level % 2 == 1) {\\n    var ch = mv(start, -dir)\\n    if (ch != null && (dir > 0 ? ch >= part.from && ch >= wrappedLineExtent.begin : ch <= part.to && ch <= wrappedLineExtent.end)) {\\n      // Case 2: We move within an rtl part on the same visual line\\n      var sticky = dir < 0 ? \\\"before\\\" : \\\"after\\\"\\n      return new Pos(start.line, ch, sticky)\\n    }\\n  }\\n\\n  // Case 3: Could not move within this bidi part in this visual line, so leave\\n  // the current bidi part\\n\\n  var searchInVisualLine = function (partPos, dir, wrappedLineExtent) {\\n    var getRes = function (ch, moveInStorageOrder) { return moveInStorageOrder\\n      ? new Pos(start.line, mv(ch, 1), \\\"before\\\")\\n      : new Pos(start.line, ch, \\\"after\\\"); }\\n\\n    for (; partPos >= 0 && partPos < bidi.length; partPos += dir) {\\n      var part = bidi[partPos]\\n      var moveInStorageOrder = (dir > 0) == (part.level != 1)\\n      var ch = moveInStorageOrder ? wrappedLineExtent.begin : mv(wrappedLineExtent.end, -1)\\n      if (part.from <= ch && ch < part.to) { return getRes(ch, moveInStorageOrder) }\\n      ch = moveInStorageOrder ? part.from : mv(part.to, -1)\\n      if (wrappedLineExtent.begin <= ch && ch < wrappedLineExtent.end) { return getRes(ch, moveInStorageOrder) }\\n    }\\n  }\\n\\n  // Case 3a: Look for other bidi parts on the same visual line\\n  var res = searchInVisualLine(partPos + dir, dir, wrappedLineExtent)\\n  if (res) { return res }\\n\\n  // Case 3b: Look for other bidi parts on the next visual line\\n  var nextCh = dir > 0 ? wrappedLineExtent.end : mv(wrappedLineExtent.begin, -1)\\n  if (nextCh != null && !(dir > 0 && nextCh == line.text.length)) {\\n    res = searchInVisualLine(dir > 0 ? 0 : bidi.length - 1, dir, getWrappedLineExtent(nextCh))\\n    if (res) { return res }\\n  }\\n\\n  // Case 4: Nowhere to move\\n  return null\\n}\\n\\n// EVENT HANDLING\\n\\n// Lightweight event framework. on/off also work on DOM nodes,\\n// registering native DOM handlers.\\n\\nvar noHandlers = []\\n\\nvar on = function(emitter, type, f) {\\n  if (emitter.addEventListener) {\\n    emitter.addEventListener(type, f, false)\\n  } else if (emitter.attachEvent) {\\n    emitter.attachEvent(\\\"on\\\" + type, f)\\n  } else {\\n    var map = emitter._handlers || (emitter._handlers = {})\\n    map[type] = (map[type] || noHandlers).concat(f)\\n  }\\n}\\n\\nfunction getHandlers(emitter, type) {\\n  return emitter._handlers && emitter._handlers[type] || noHandlers\\n}\\n\\nfunction off(emitter, type, f) {\\n  if (emitter.removeEventListener) {\\n    emitter.removeEventListener(type, f, false)\\n  } else if (emitter.detachEvent) {\\n    emitter.detachEvent(\\\"on\\\" + type, f)\\n  } else {\\n    var map = emitter._handlers, arr = map && map[type]\\n    if (arr) {\\n      var index = indexOf(arr, f)\\n      if (index > -1)\\n        { map[type] = arr.slice(0, index).concat(arr.slice(index + 1)) }\\n    }\\n  }\\n}\\n\\nfunction signal(emitter, type /*, values...*/) {\\n  var handlers = getHandlers(emitter, type)\\n  if (!handlers.length) { return }\\n  var args = Array.prototype.slice.call(arguments, 2)\\n  for (var i = 0; i < handlers.length; ++i) { handlers[i].apply(null, args) }\\n}\\n\\n// The DOM events that CodeMirror handles can be overridden by\\n// registering a (non-DOM) handler on the editor for the event name,\\n// and preventDefault-ing the event in that handler.\\nfunction signalDOMEvent(cm, e, override) {\\n  if (typeof e == \\\"string\\\")\\n    { e = {type: e, preventDefault: function() { this.defaultPrevented = true }} }\\n  signal(cm, override || e.type, cm, e)\\n  return e_defaultPrevented(e) || e.codemirrorIgnore\\n}\\n\\nfunction signalCursorActivity(cm) {\\n  var arr = cm._handlers && cm._handlers.cursorActivity\\n  if (!arr) { return }\\n  var set = cm.curOp.cursorActivityHandlers || (cm.curOp.cursorActivityHandlers = [])\\n  for (var i = 0; i < arr.length; ++i) { if (indexOf(set, arr[i]) == -1)\\n    { set.push(arr[i]) } }\\n}\\n\\nfunction hasHandler(emitter, type) {\\n  return getHandlers(emitter, type).length > 0\\n}\\n\\n// Add on and off methods to a constructor's prototype, to make\\n// registering events on such objects more convenient.\\nfunction eventMixin(ctor) {\\n  ctor.prototype.on = function(type, f) {on(this, type, f)}\\n  ctor.prototype.off = function(type, f) {off(this, type, f)}\\n}\\n\\n// Due to the fact that we still support jurassic IE versions, some\\n// compatibility wrappers are needed.\\n\\nfunction e_preventDefault(e) {\\n  if (e.preventDefault) { e.preventDefault() }\\n  else { e.returnValue = false }\\n}\\nfunction e_stopPropagation(e) {\\n  if (e.stopPropagation) { e.stopPropagation() }\\n  else { e.cancelBubble = true }\\n}\\nfunction e_defaultPrevented(e) {\\n  return e.defaultPrevented != null ? e.defaultPrevented : e.returnValue == false\\n}\\nfunction e_stop(e) {e_preventDefault(e); e_stopPropagation(e)}\\n\\nfunction e_target(e) {return e.target || e.srcElement}\\nfunction e_button(e) {\\n  var b = e.which\\n  if (b == null) {\\n    if (e.button & 1) { b = 1 }\\n    else if (e.button & 2) { b = 3 }\\n    else if (e.button & 4) { b = 2 }\\n  }\\n  if (mac && e.ctrlKey && b == 1) { b = 3 }\\n  return b\\n}\\n\\n// Detect drag-and-drop\\nvar dragAndDrop = function() {\\n  // There is *some* kind of drag-and-drop support in IE6-8, but I\\n  // couldn't get it to work yet.\\n  if (ie && ie_version < 9) { return false }\\n  var div = elt('div')\\n  return \\\"draggable\\\" in div || \\\"dragDrop\\\" in div\\n}()\\n\\nvar zwspSupported\\nfunction zeroWidthElement(measure) {\\n  if (zwspSupported == null) {\\n    var test = elt(\\\"span\\\", \\\"\\\\u200b\\\")\\n    removeChildrenAndAdd(measure, elt(\\\"span\\\", [test, document.createTextNode(\\\"x\\\")]))\\n    if (measure.firstChild.offsetHeight != 0)\\n      { zwspSupported = test.offsetWidth <= 1 && test.offsetHeight > 2 && !(ie && ie_version < 8) }\\n  }\\n  var node = zwspSupported ? elt(\\\"span\\\", \\\"\\\\u200b\\\") :\\n    elt(\\\"span\\\", \\\"\\\\u00a0\\\", null, \\\"display: inline-block; width: 1px; margin-right: -1px\\\")\\n  node.setAttribute(\\\"cm-text\\\", \\\"\\\")\\n  return node\\n}\\n\\n// Feature-detect IE's crummy client rect reporting for bidi text\\nvar badBidiRects\\nfunction hasBadBidiRects(measure) {\\n  if (badBidiRects != null) { return badBidiRects }\\n  var txt = removeChildrenAndAdd(measure, document.createTextNode(\\\"A\\\\u062eA\\\"))\\n  var r0 = range(txt, 0, 1).getBoundingClientRect()\\n  var r1 = range(txt, 1, 2).getBoundingClientRect()\\n  removeChildren(measure)\\n  if (!r0 || r0.left == r0.right) { return false } // Safari returns null in some cases (#2780)\\n  return badBidiRects = (r1.right - r0.right < 3)\\n}\\n\\n// See if \\\"\\\".split is the broken IE version, if so, provide an\\n// alternative way to split lines.\\nvar splitLinesAuto = \\\"\\\\n\\\\nb\\\".split(/\\\\n/).length != 3 ? function (string) {\\n  var pos = 0, result = [], l = string.length\\n  while (pos <= l) {\\n    var nl = string.indexOf(\\\"\\\\n\\\", pos)\\n    if (nl == -1) { nl = string.length }\\n    var line = string.slice(pos, string.charAt(nl - 1) == \\\"\\\\r\\\" ? nl - 1 : nl)\\n    var rt = line.indexOf(\\\"\\\\r\\\")\\n    if (rt != -1) {\\n      result.push(line.slice(0, rt))\\n      pos += rt + 1\\n    } else {\\n      result.push(line)\\n      pos = nl + 1\\n    }\\n  }\\n  return result\\n} : function (string) { return string.split(/\\\\r\\\\n?|\\\\n/); }\\n\\nvar hasSelection = window.getSelection ? function (te) {\\n  try { return te.selectionStart != te.selectionEnd }\\n  catch(e) { return false }\\n} : function (te) {\\n  var range\\n  try {range = te.ownerDocument.selection.createRange()}\\n  catch(e) {}\\n  if (!range || range.parentElement() != te) { return false }\\n  return range.compareEndPoints(\\\"StartToEnd\\\", range) != 0\\n}\\n\\nvar hasCopyEvent = (function () {\\n  var e = elt(\\\"div\\\")\\n  if (\\\"oncopy\\\" in e) { return true }\\n  e.setAttribute(\\\"oncopy\\\", \\\"return;\\\")\\n  return typeof e.oncopy == \\\"function\\\"\\n})()\\n\\nvar badZoomedRects = null\\nfunction hasBadZoomedRects(measure) {\\n  if (badZoomedRects != null) { return badZoomedRects }\\n  var node = removeChildrenAndAdd(measure, elt(\\\"span\\\", \\\"x\\\"))\\n  var normal = node.getBoundingClientRect()\\n  var fromRange = range(node, 0, 1).getBoundingClientRect()\\n  return badZoomedRects = Math.abs(normal.left - fromRange.left) > 1\\n}\\n\\nvar modes = {};\\nvar mimeModes = {};\\n// Extra arguments are stored as the mode's dependencies, which is\\n// used by (legacy) mechanisms like loadmode.js to automatically\\n// load a mode. (Preferred mechanism is the require/define calls.)\\nfunction defineMode(name, mode) {\\n  if (arguments.length > 2)\\n    { mode.dependencies = Array.prototype.slice.call(arguments, 2) }\\n  modes[name] = mode\\n}\\n\\nfunction defineMIME(mime, spec) {\\n  mimeModes[mime] = spec\\n}\\n\\n// Given a MIME type, a {name, ...options} config object, or a name\\n// string, return a mode config object.\\nfunction resolveMode(spec) {\\n  if (typeof spec == \\\"string\\\" && mimeModes.hasOwnProperty(spec)) {\\n    spec = mimeModes[spec]\\n  } else if (spec && typeof spec.name == \\\"string\\\" && mimeModes.hasOwnProperty(spec.name)) {\\n    var found = mimeModes[spec.name]\\n    if (typeof found == \\\"string\\\") { found = {name: found} }\\n    spec = createObj(found, spec)\\n    spec.name = found.name\\n  } else if (typeof spec == \\\"string\\\" && /^[\\\\w\\\\-]+\\\\/[\\\\w\\\\-]+\\\\+xml$/.test(spec)) {\\n    return resolveMode(\\\"application/xml\\\")\\n  } else if (typeof spec == \\\"string\\\" && /^[\\\\w\\\\-]+\\\\/[\\\\w\\\\-]+\\\\+json$/.test(spec)) {\\n    return resolveMode(\\\"application/json\\\")\\n  }\\n  if (typeof spec == \\\"string\\\") { return {name: spec} }\\n  else { return spec || {name: \\\"null\\\"} }\\n}\\n\\n// Given a mode spec (anything that resolveMode accepts), find and\\n// initialize an actual mode object.\\nfunction getMode(options, spec) {\\n  spec = resolveMode(spec)\\n  var mfactory = modes[spec.name]\\n  if (!mfactory) { return getMode(options, \\\"text/plain\\\") }\\n  var modeObj = mfactory(options, spec)\\n  if (modeExtensions.hasOwnProperty(spec.name)) {\\n    var exts = modeExtensions[spec.name]\\n    for (var prop in exts) {\\n      if (!exts.hasOwnProperty(prop)) { continue }\\n      if (modeObj.hasOwnProperty(prop)) { modeObj[\\\"_\\\" + prop] = modeObj[prop] }\\n      modeObj[prop] = exts[prop]\\n    }\\n  }\\n  modeObj.name = spec.name\\n  if (spec.helperType) { modeObj.helperType = spec.helperType }\\n  if (spec.modeProps) { for (var prop$1 in spec.modeProps)\\n    { modeObj[prop$1] = spec.modeProps[prop$1] } }\\n\\n  return modeObj\\n}\\n\\n// This can be used to attach properties to mode objects from\\n// outside the actual mode definition.\\nvar modeExtensions = {}\\nfunction extendMode(mode, properties) {\\n  var exts = modeExtensions.hasOwnProperty(mode) ? modeExtensions[mode] : (modeExtensions[mode] = {})\\n  copyObj(properties, exts)\\n}\\n\\nfunction copyState(mode, state) {\\n  if (state === true) { return state }\\n  if (mode.copyState) { return mode.copyState(state) }\\n  var nstate = {}\\n  for (var n in state) {\\n    var val = state[n]\\n    if (val instanceof Array) { val = val.concat([]) }\\n    nstate[n] = val\\n  }\\n  return nstate\\n}\\n\\n// Given a mode and a state (for that mode), find the inner mode and\\n// state at the position that the state refers to.\\nfunction innerMode(mode, state) {\\n  var info\\n  while (mode.innerMode) {\\n    info = mode.innerMode(state)\\n    if (!info || info.mode == mode) { break }\\n    state = info.state\\n    mode = info.mode\\n  }\\n  return info || {mode: mode, state: state}\\n}\\n\\nfunction startState(mode, a1, a2) {\\n  return mode.startState ? mode.startState(a1, a2) : true\\n}\\n\\n// STRING STREAM\\n\\n// Fed to the mode parsers, provides helper functions to make\\n// parsers more succinct.\\n\\nvar StringStream = function(string, tabSize) {\\n  this.pos = this.start = 0\\n  this.string = string\\n  this.tabSize = tabSize || 8\\n  this.lastColumnPos = this.lastColumnValue = 0\\n  this.lineStart = 0\\n};\\n\\nStringStream.prototype.eol = function () {return this.pos >= this.string.length};\\nStringStream.prototype.sol = function () {return this.pos == this.lineStart};\\nStringStream.prototype.peek = function () {return this.string.charAt(this.pos) || undefined};\\nStringStream.prototype.next = function () {\\n  if (this.pos < this.string.length)\\n    { return this.string.charAt(this.pos++) }\\n};\\nStringStream.prototype.eat = function (match) {\\n  var ch = this.string.charAt(this.pos)\\n  var ok\\n  if (typeof match == \\\"string\\\") { ok = ch == match }\\n  else { ok = ch && (match.test ? match.test(ch) : match(ch)) }\\n  if (ok) {++this.pos; return ch}\\n};\\nStringStream.prototype.eatWhile = function (match) {\\n  var start = this.pos\\n  while (this.eat(match)){}\\n  return this.pos > start\\n};\\nStringStream.prototype.eatSpace = function () {\\n    var this$1 = this;\\n\\n  var start = this.pos\\n  while (/[\\\\s\\\\u00a0]/.test(this.string.charAt(this.pos))) { ++this$1.pos }\\n  return this.pos > start\\n};\\nStringStream.prototype.skipToEnd = function () {this.pos = this.string.length};\\nStringStream.prototype.skipTo = function (ch) {\\n  var found = this.string.indexOf(ch, this.pos)\\n  if (found > -1) {this.pos = found; return true}\\n};\\nStringStream.prototype.backUp = function (n) {this.pos -= n};\\nStringStream.prototype.column = function () {\\n  if (this.lastColumnPos < this.start) {\\n    this.lastColumnValue = countColumn(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue)\\n    this.lastColumnPos = this.start\\n  }\\n  return this.lastColumnValue - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0)\\n};\\nStringStream.prototype.indentation = function () {\\n  return countColumn(this.string, null, this.tabSize) -\\n    (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0)\\n};\\nStringStream.prototype.match = function (pattern, consume, caseInsensitive) {\\n  if (typeof pattern == \\\"string\\\") {\\n    var cased = function (str) { return caseInsensitive ? str.toLowerCase() : str; }\\n    var substr = this.string.substr(this.pos, pattern.length)\\n    if (cased(substr) == cased(pattern)) {\\n      if (consume !== false) { this.pos += pattern.length }\\n      return true\\n    }\\n  } else {\\n    var match = this.string.slice(this.pos).match(pattern)\\n    if (match && match.index > 0) { return null }\\n    if (match && consume !== false) { this.pos += match[0].length }\\n    return match\\n  }\\n};\\nStringStream.prototype.current = function (){return this.string.slice(this.start, this.pos)};\\nStringStream.prototype.hideFirstChars = function (n, inner) {\\n  this.lineStart += n\\n  try { return inner() }\\n  finally { this.lineStart -= n }\\n};\\n\\n// Compute a style array (an array starting with a mode generation\\n// -- for invalidation -- followed by pairs of end positions and\\n// style strings), which is used to highlight the tokens on the\\n// line.\\nfunction highlightLine(cm, line, state, forceToEnd) {\\n  // A styles array always starts with a number identifying the\\n  // mode/overlays that it is based on (for easy invalidation).\\n  var st = [cm.state.modeGen], lineClasses = {}\\n  // Compute the base array of styles\\n  runMode(cm, line.text, cm.doc.mode, state, function (end, style) { return st.push(end, style); },\\n    lineClasses, forceToEnd)\\n\\n  // Run overlays, adjust style array.\\n  var loop = function ( o ) {\\n    var overlay = cm.state.overlays[o], i = 1, at = 0\\n    runMode(cm, line.text, overlay.mode, true, function (end, style) {\\n      var start = i\\n      // Ensure there's a token end at the current position, and that i points at it\\n      while (at < end) {\\n        var i_end = st[i]\\n        if (i_end > end)\\n          { st.splice(i, 1, end, st[i+1], i_end) }\\n        i += 2\\n        at = Math.min(end, i_end)\\n      }\\n      if (!style) { return }\\n      if (overlay.opaque) {\\n        st.splice(start, i - start, end, \\\"overlay \\\" + style)\\n        i = start + 2\\n      } else {\\n        for (; start < i; start += 2) {\\n          var cur = st[start+1]\\n          st[start+1] = (cur ? cur + \\\" \\\" : \\\"\\\") + \\\"overlay \\\" + style\\n        }\\n      }\\n    }, lineClasses)\\n  };\\n\\n  for (var o = 0; o < cm.state.overlays.length; ++o) loop( o );\\n\\n  return {styles: st, classes: lineClasses.bgClass || lineClasses.textClass ? lineClasses : null}\\n}\\n\\nfunction getLineStyles(cm, line, updateFrontier) {\\n  if (!line.styles || line.styles[0] != cm.state.modeGen) {\\n    var state = getStateBefore(cm, lineNo(line))\\n    var result = highlightLine(cm, line, line.text.length > cm.options.maxHighlightLength ? copyState(cm.doc.mode, state) : state)\\n    line.stateAfter = state\\n    line.styles = result.styles\\n    if (result.classes) { line.styleClasses = result.classes }\\n    else if (line.styleClasses) { line.styleClasses = null }\\n    if (updateFrontier === cm.doc.frontier) { cm.doc.frontier++ }\\n  }\\n  return line.styles\\n}\\n\\nfunction getStateBefore(cm, n, precise) {\\n  var doc = cm.doc, display = cm.display\\n  if (!doc.mode.startState) { return true }\\n  var pos = findStartLine(cm, n, precise), state = pos > doc.first && getLine(doc, pos-1).stateAfter\\n  if (!state) { state = startState(doc.mode) }\\n  else { state = copyState(doc.mode, state) }\\n  doc.iter(pos, n, function (line) {\\n    processLine(cm, line.text, state)\\n    var save = pos == n - 1 || pos % 5 == 0 || pos >= display.viewFrom && pos < display.viewTo\\n    line.stateAfter = save ? copyState(doc.mode, state) : null\\n    ++pos\\n  })\\n  if (precise) { doc.frontier = pos }\\n  return state\\n}\\n\\n// Lightweight form of highlight -- proceed over this line and\\n// update state, but don't save a style array. Used for lines that\\n// aren't currently visible.\\nfunction processLine(cm, text, state, startAt) {\\n  var mode = cm.doc.mode\\n  var stream = new StringStream(text, cm.options.tabSize)\\n  stream.start = stream.pos = startAt || 0\\n  if (text == \\\"\\\") { callBlankLine(mode, state) }\\n  while (!stream.eol()) {\\n    readToken(mode, stream, state)\\n    stream.start = stream.pos\\n  }\\n}\\n\\nfunction callBlankLine(mode, state) {\\n  if (mode.blankLine) { return mode.blankLine(state) }\\n  if (!mode.innerMode) { return }\\n  var inner = innerMode(mode, state)\\n  if (inner.mode.blankLine) { return inner.mode.blankLine(inner.state) }\\n}\\n\\nfunction readToken(mode, stream, state, inner) {\\n  for (var i = 0; i < 10; i++) {\\n    if (inner) { inner[0] = innerMode(mode, state).mode }\\n    var style = mode.token(stream, state)\\n    if (stream.pos > stream.start) { return style }\\n  }\\n  throw new Error(\\\"Mode \\\" + mode.name + \\\" failed to advance stream.\\\")\\n}\\n\\n// Utility for getTokenAt and getLineTokens\\nfunction takeToken(cm, pos, precise, asArray) {\\n  var getObj = function (copy) { return ({\\n    start: stream.start, end: stream.pos,\\n    string: stream.current(),\\n    type: style || null,\\n    state: copy ? copyState(doc.mode, state) : state\\n  }); }\\n\\n  var doc = cm.doc, mode = doc.mode, style\\n  pos = clipPos(doc, pos)\\n  var line = getLine(doc, pos.line), state = getStateBefore(cm, pos.line, precise)\\n  var stream = new StringStream(line.text, cm.options.tabSize), tokens\\n  if (asArray) { tokens = [] }\\n  while ((asArray || stream.pos < pos.ch) && !stream.eol()) {\\n    stream.start = stream.pos\\n    style = readToken(mode, stream, state)\\n    if (asArray) { tokens.push(getObj(true)) }\\n  }\\n  return asArray ? tokens : getObj()\\n}\\n\\nfunction extractLineClasses(type, output) {\\n  if (type) { for (;;) {\\n    var lineClass = type.match(/(?:^|\\\\s+)line-(background-)?(\\\\S+)/)\\n    if (!lineClass) { break }\\n    type = type.slice(0, lineClass.index) + type.slice(lineClass.index + lineClass[0].length)\\n    var prop = lineClass[1] ? \\\"bgClass\\\" : \\\"textClass\\\"\\n    if (output[prop] == null)\\n      { output[prop] = lineClass[2] }\\n    else if (!(new RegExp(\\\"(?:^|\\\\s)\\\" + lineClass[2] + \\\"(?:$|\\\\s)\\\")).test(output[prop]))\\n      { output[prop] += \\\" \\\" + lineClass[2] }\\n  } }\\n  return type\\n}\\n\\n// Run the given mode's parser over a line, calling f for each token.\\nfunction runMode(cm, text, mode, state, f, lineClasses, forceToEnd) {\\n  var flattenSpans = mode.flattenSpans\\n  if (flattenSpans == null) { flattenSpans = cm.options.flattenSpans }\\n  var curStart = 0, curStyle = null\\n  var stream = new StringStream(text, cm.options.tabSize), style\\n  var inner = cm.options.addModeClass && [null]\\n  if (text == \\\"\\\") { extractLineClasses(callBlankLine(mode, state), lineClasses) }\\n  while (!stream.eol()) {\\n    if (stream.pos > cm.options.maxHighlightLength) {\\n      flattenSpans = false\\n      if (forceToEnd) { processLine(cm, text, state, stream.pos) }\\n      stream.pos = text.length\\n      style = null\\n    } else {\\n      style = extractLineClasses(readToken(mode, stream, state, inner), lineClasses)\\n    }\\n    if (inner) {\\n      var mName = inner[0].name\\n      if (mName) { style = \\\"m-\\\" + (style ? mName + \\\" \\\" + style : mName) }\\n    }\\n    if (!flattenSpans || curStyle != style) {\\n      while (curStart < stream.start) {\\n        curStart = Math.min(stream.start, curStart + 5000)\\n        f(curStart, curStyle)\\n      }\\n      curStyle = style\\n    }\\n    stream.start = stream.pos\\n  }\\n  while (curStart < stream.pos) {\\n    // Webkit seems to refuse to render text nodes longer than 57444\\n    // characters, and returns inaccurate measurements in nodes\\n    // starting around 5000 chars.\\n    var pos = Math.min(stream.pos, curStart + 5000)\\n    f(pos, curStyle)\\n    curStart = pos\\n  }\\n}\\n\\n// Finds the line to start with when starting a parse. Tries to\\n// find a line with a stateAfter, so that it can start with a\\n// valid state. If that fails, it returns the line with the\\n// smallest indentation, which tends to need the least context to\\n// parse correctly.\\nfunction findStartLine(cm, n, precise) {\\n  var minindent, minline, doc = cm.doc\\n  var lim = precise ? -1 : n - (cm.doc.mode.innerMode ? 1000 : 100)\\n  for (var search = n; search > lim; --search) {\\n    if (search <= doc.first) { return doc.first }\\n    var line = getLine(doc, search - 1)\\n    if (line.stateAfter && (!precise || search <= doc.frontier)) { return search }\\n    var indented = countColumn(line.text, null, cm.options.tabSize)\\n    if (minline == null || minindent > indented) {\\n      minline = search - 1\\n      minindent = indented\\n    }\\n  }\\n  return minline\\n}\\n\\n// LINE DATA STRUCTURE\\n\\n// Line objects. These hold state related to a line, including\\n// highlighting info (the styles array).\\nvar Line = function(text, markedSpans, estimateHeight) {\\n  this.text = text\\n  attachMarkedSpans(this, markedSpans)\\n  this.height = estimateHeight ? estimateHeight(this) : 1\\n};\\n\\nLine.prototype.lineNo = function () { return lineNo(this) };\\neventMixin(Line)\\n\\n// Change the content (text, markers) of a line. Automatically\\n// invalidates cached information and tries to re-estimate the\\n// line's height.\\nfunction updateLine(line, text, markedSpans, estimateHeight) {\\n  line.text = text\\n  if (line.stateAfter) { line.stateAfter = null }\\n  if (line.styles) { line.styles = null }\\n  if (line.order != null) { line.order = null }\\n  detachMarkedSpans(line)\\n  attachMarkedSpans(line, markedSpans)\\n  var estHeight = estimateHeight ? estimateHeight(line) : 1\\n  if (estHeight != line.height) { updateLineHeight(line, estHeight) }\\n}\\n\\n// Detach a line from the document tree and its markers.\\nfunction cleanUpLine(line) {\\n  line.parent = null\\n  detachMarkedSpans(line)\\n}\\n\\n// Convert a style as returned by a mode (either null, or a string\\n// containing one or more styles) to a CSS style. This is cached,\\n// and also looks for line-wide styles.\\nvar styleToClassCache = {};\\nvar styleToClassCacheWithMode = {};\\nfunction interpretTokenStyle(style, options) {\\n  if (!style || /^\\\\s*$/.test(style)) { return null }\\n  var cache = options.addModeClass ? styleToClassCacheWithMode : styleToClassCache\\n  return cache[style] ||\\n    (cache[style] = style.replace(/\\\\S+/g, \\\"cm-$&\\\"))\\n}\\n\\n// Render the DOM representation of the text of a line. Also builds\\n// up a 'line map', which points at the DOM nodes that represent\\n// specific stretches of text, and is used by the measuring code.\\n// The returned object contains the DOM node, this map, and\\n// information about line-wide styles that were set by the mode.\\nfunction buildLineContent(cm, lineView) {\\n  // The padding-right forces the element to have a 'border', which\\n  // is needed on Webkit to be able to get line-level bounding\\n  // rectangles for it (in measureChar).\\n  var content = elt(\\\"span\\\", null, null, webkit ? \\\"padding-right: .1px\\\" : null)\\n  var builder = {pre: elt(\\\"pre\\\", [content], \\\"CodeMirror-line\\\"), content: content,\\n                 col: 0, pos: 0, cm: cm,\\n                 trailingSpace: false,\\n                 splitSpaces: (ie || webkit) && cm.getOption(\\\"lineWrapping\\\")}\\n  // hide from accessibility tree\\n  content.setAttribute(\\\"role\\\", \\\"presentation\\\")\\n  builder.pre.setAttribute(\\\"role\\\", \\\"presentation\\\")\\n  lineView.measure = {}\\n\\n  // Iterate over the logical lines that make up this visual line.\\n  for (var i = 0; i <= (lineView.rest ? lineView.rest.length : 0); i++) {\\n    var line = i ? lineView.rest[i - 1] : lineView.line, order = (void 0)\\n    builder.pos = 0\\n    builder.addToken = buildToken\\n    // Optionally wire in some hacks into the token-rendering\\n    // algorithm, to deal with browser quirks.\\n    if (hasBadBidiRects(cm.display.measure) && (order = getOrder(line)))\\n      { builder.addToken = buildTokenBadBidi(builder.addToken, order) }\\n    builder.map = []\\n    var allowFrontierUpdate = lineView != cm.display.externalMeasured && lineNo(line)\\n    insertLineContent(line, builder, getLineStyles(cm, line, allowFrontierUpdate))\\n    if (line.styleClasses) {\\n      if (line.styleClasses.bgClass)\\n        { builder.bgClass = joinClasses(line.styleClasses.bgClass, builder.bgClass || \\\"\\\") }\\n      if (line.styleClasses.textClass)\\n        { builder.textClass = joinClasses(line.styleClasses.textClass, builder.textClass || \\\"\\\") }\\n    }\\n\\n    // Ensure at least a single node is present, for measuring.\\n    if (builder.map.length == 0)\\n      { builder.map.push(0, 0, builder.content.appendChild(zeroWidthElement(cm.display.measure))) }\\n\\n    // Store the map and a cache object for the current logical line\\n    if (i == 0) {\\n      lineView.measure.map = builder.map\\n      lineView.measure.cache = {}\\n    } else {\\n      ;(lineView.measure.maps || (lineView.measure.maps = [])).push(builder.map)\\n      ;(lineView.measure.caches || (lineView.measure.caches = [])).push({})\\n    }\\n  }\\n\\n  // See issue #2901\\n  if (webkit) {\\n    var last = builder.content.lastChild\\n    if (/\\\\bcm-tab\\\\b/.test(last.className) || (last.querySelector && last.querySelector(\\\".cm-tab\\\")))\\n      { builder.content.className = \\\"cm-tab-wrap-hack\\\" }\\n  }\\n\\n  signal(cm, \\\"renderLine\\\", cm, lineView.line, builder.pre)\\n  if (builder.pre.className)\\n    { builder.textClass = joinClasses(builder.pre.className, builder.textClass || \\\"\\\") }\\n\\n  return builder\\n}\\n\\nfunction defaultSpecialCharPlaceholder(ch) {\\n  var token = elt(\\\"span\\\", \\\"\\\\u2022\\\", \\\"cm-invalidchar\\\")\\n  token.title = \\\"\\\\\\\\u\\\" + ch.charCodeAt(0).toString(16)\\n  token.setAttribute(\\\"aria-label\\\", token.title)\\n  return token\\n}\\n\\n// Build up the DOM representation for a single token, and add it to\\n// the line map. Takes care to render special characters separately.\\nfunction buildToken(builder, text, style, startStyle, endStyle, title, css) {\\n  if (!text) { return }\\n  var displayText = builder.splitSpaces ? splitSpaces(text, builder.trailingSpace) : text\\n  var special = builder.cm.state.specialChars, mustWrap = false\\n  var content\\n  if (!special.test(text)) {\\n    builder.col += text.length\\n    content = document.createTextNode(displayText)\\n    builder.map.push(builder.pos, builder.pos + text.length, content)\\n    if (ie && ie_version < 9) { mustWrap = true }\\n    builder.pos += text.length\\n  } else {\\n    content = document.createDocumentFragment()\\n    var pos = 0\\n    while (true) {\\n      special.lastIndex = pos\\n      var m = special.exec(text)\\n      var skipped = m ? m.index - pos : text.length - pos\\n      if (skipped) {\\n        var txt = document.createTextNode(displayText.slice(pos, pos + skipped))\\n        if (ie && ie_version < 9) { content.appendChild(elt(\\\"span\\\", [txt])) }\\n        else { content.appendChild(txt) }\\n        builder.map.push(builder.pos, builder.pos + skipped, txt)\\n        builder.col += skipped\\n        builder.pos += skipped\\n      }\\n      if (!m) { break }\\n      pos += skipped + 1\\n      var txt$1 = (void 0)\\n      if (m[0] == \\\"\\\\t\\\") {\\n        var tabSize = builder.cm.options.tabSize, tabWidth = tabSize - builder.col % tabSize\\n        txt$1 = content.appendChild(elt(\\\"span\\\", spaceStr(tabWidth), \\\"cm-tab\\\"))\\n        txt$1.setAttribute(\\\"role\\\", \\\"presentation\\\")\\n        txt$1.setAttribute(\\\"cm-text\\\", \\\"\\\\t\\\")\\n        builder.col += tabWidth\\n      } else if (m[0] == \\\"\\\\r\\\" || m[0] == \\\"\\\\n\\\") {\\n        txt$1 = content.appendChild(elt(\\\"span\\\", m[0] == \\\"\\\\r\\\" ? \\\"\\\\u240d\\\" : \\\"\\\\u2424\\\", \\\"cm-invalidchar\\\"))\\n        txt$1.setAttribute(\\\"cm-text\\\", m[0])\\n        builder.col += 1\\n      } else {\\n        txt$1 = builder.cm.options.specialCharPlaceholder(m[0])\\n        txt$1.setAttribute(\\\"cm-text\\\", m[0])\\n        if (ie && ie_version < 9) { content.appendChild(elt(\\\"span\\\", [txt$1])) }\\n        else { content.appendChild(txt$1) }\\n        builder.col += 1\\n      }\\n      builder.map.push(builder.pos, builder.pos + 1, txt$1)\\n      builder.pos++\\n    }\\n  }\\n  builder.trailingSpace = displayText.charCodeAt(text.length - 1) == 32\\n  if (style || startStyle || endStyle || mustWrap || css) {\\n    var fullStyle = style || \\\"\\\"\\n    if (startStyle) { fullStyle += startStyle }\\n    if (endStyle) { fullStyle += endStyle }\\n    var token = elt(\\\"span\\\", [content], fullStyle, css)\\n    if (title) { token.title = title }\\n    return builder.content.appendChild(token)\\n  }\\n  builder.content.appendChild(content)\\n}\\n\\nfunction splitSpaces(text, trailingBefore) {\\n  if (text.length > 1 && !/  /.test(text)) { return text }\\n  var spaceBefore = trailingBefore, result = \\\"\\\"\\n  for (var i = 0; i < text.length; i++) {\\n    var ch = text.charAt(i)\\n    if (ch == \\\" \\\" && spaceBefore && (i == text.length - 1 || text.charCodeAt(i + 1) == 32))\\n      { ch = \\\"\\\\u00a0\\\" }\\n    result += ch\\n    spaceBefore = ch == \\\" \\\"\\n  }\\n  return result\\n}\\n\\n// Work around nonsense dimensions being reported for stretches of\\n// right-to-left text.\\nfunction buildTokenBadBidi(inner, order) {\\n  return function (builder, text, style, startStyle, endStyle, title, css) {\\n    style = style ? style + \\\" cm-force-border\\\" : \\\"cm-force-border\\\"\\n    var start = builder.pos, end = start + text.length\\n    for (;;) {\\n      // Find the part that overlaps with the start of this text\\n      var part = (void 0)\\n      for (var i = 0; i < order.length; i++) {\\n        part = order[i]\\n        if (part.to > start && part.from <= start) { break }\\n      }\\n      if (part.to >= end) { return inner(builder, text, style, startStyle, endStyle, title, css) }\\n      inner(builder, text.slice(0, part.to - start), style, startStyle, null, title, css)\\n      startStyle = null\\n      text = text.slice(part.to - start)\\n      start = part.to\\n    }\\n  }\\n}\\n\\nfunction buildCollapsedSpan(builder, size, marker, ignoreWidget) {\\n  var widget = !ignoreWidget && marker.widgetNode\\n  if (widget) { builder.map.push(builder.pos, builder.pos + size, widget) }\\n  if (!ignoreWidget && builder.cm.display.input.needsContentAttribute) {\\n    if (!widget)\\n      { widget = builder.content.appendChild(document.createElement(\\\"span\\\")) }\\n    widget.setAttribute(\\\"cm-marker\\\", marker.id)\\n  }\\n  if (widget) {\\n    builder.cm.display.input.setUneditable(widget)\\n    builder.content.appendChild(widget)\\n  }\\n  builder.pos += size\\n  builder.trailingSpace = false\\n}\\n\\n// Outputs a number of spans to make up a line, taking highlighting\\n// and marked text into account.\\nfunction insertLineContent(line, builder, styles) {\\n  var spans = line.markedSpans, allText = line.text, at = 0\\n  if (!spans) {\\n    for (var i$1 = 1; i$1 < styles.length; i$1+=2)\\n      { builder.addToken(builder, allText.slice(at, at = styles[i$1]), interpretTokenStyle(styles[i$1+1], builder.cm.options)) }\\n    return\\n  }\\n\\n  var len = allText.length, pos = 0, i = 1, text = \\\"\\\", style, css\\n  var nextChange = 0, spanStyle, spanEndStyle, spanStartStyle, title, collapsed\\n  for (;;) {\\n    if (nextChange == pos) { // Update current marker set\\n      spanStyle = spanEndStyle = spanStartStyle = title = css = \\\"\\\"\\n      collapsed = null; nextChange = Infinity\\n      var foundBookmarks = [], endStyles = (void 0)\\n      for (var j = 0; j < spans.length; ++j) {\\n        var sp = spans[j], m = sp.marker\\n        if (m.type == \\\"bookmark\\\" && sp.from == pos && m.widgetNode) {\\n          foundBookmarks.push(m)\\n        } else if (sp.from <= pos && (sp.to == null || sp.to > pos || m.collapsed && sp.to == pos && sp.from == pos)) {\\n          if (sp.to != null && sp.to != pos && nextChange > sp.to) {\\n            nextChange = sp.to\\n            spanEndStyle = \\\"\\\"\\n          }\\n          if (m.className) { spanStyle += \\\" \\\" + m.className }\\n          if (m.css) { css = (css ? css + \\\";\\\" : \\\"\\\") + m.css }\\n          if (m.startStyle && sp.from == pos) { spanStartStyle += \\\" \\\" + m.startStyle }\\n          if (m.endStyle && sp.to == nextChange) { (endStyles || (endStyles = [])).push(m.endStyle, sp.to) }\\n          if (m.title && !title) { title = m.title }\\n          if (m.collapsed && (!collapsed || compareCollapsedMarkers(collapsed.marker, m) < 0))\\n            { collapsed = sp }\\n        } else if (sp.from > pos && nextChange > sp.from) {\\n          nextChange = sp.from\\n        }\\n      }\\n      if (endStyles) { for (var j$1 = 0; j$1 < endStyles.length; j$1 += 2)\\n        { if (endStyles[j$1 + 1] == nextChange) { spanEndStyle += \\\" \\\" + endStyles[j$1] } } }\\n\\n      if (!collapsed || collapsed.from == pos) { for (var j$2 = 0; j$2 < foundBookmarks.length; ++j$2)\\n        { buildCollapsedSpan(builder, 0, foundBookmarks[j$2]) } }\\n      if (collapsed && (collapsed.from || 0) == pos) {\\n        buildCollapsedSpan(builder, (collapsed.to == null ? len + 1 : collapsed.to) - pos,\\n                           collapsed.marker, collapsed.from == null)\\n        if (collapsed.to == null) { return }\\n        if (collapsed.to == pos) { collapsed = false }\\n      }\\n    }\\n    if (pos >= len) { break }\\n\\n    var upto = Math.min(len, nextChange)\\n    while (true) {\\n      if (text) {\\n        var end = pos + text.length\\n        if (!collapsed) {\\n          var tokenText = end > upto ? text.slice(0, upto - pos) : text\\n          builder.addToken(builder, tokenText, style ? style + spanStyle : spanStyle,\\n                           spanStartStyle, pos + tokenText.length == nextChange ? spanEndStyle : \\\"\\\", title, css)\\n        }\\n        if (end >= upto) {text = text.slice(upto - pos); pos = upto; break}\\n        pos = end\\n        spanStartStyle = \\\"\\\"\\n      }\\n      text = allText.slice(at, at = styles[i++])\\n      style = interpretTokenStyle(styles[i++], builder.cm.options)\\n    }\\n  }\\n}\\n\\n\\n// These objects are used to represent the visible (currently drawn)\\n// part of the document. A LineView may correspond to multiple\\n// logical lines, if those are connected by collapsed ranges.\\nfunction LineView(doc, line, lineN) {\\n  // The starting line\\n  this.line = line\\n  // Continuing lines, if any\\n  this.rest = visualLineContinued(line)\\n  // Number of logical lines in this visual line\\n  this.size = this.rest ? lineNo(lst(this.rest)) - lineN + 1 : 1\\n  this.node = this.text = null\\n  this.hidden = lineIsHidden(doc, line)\\n}\\n\\n// Create a range of LineView objects for the given lines.\\nfunction buildViewArray(cm, from, to) {\\n  var array = [], nextPos\\n  for (var pos = from; pos < to; pos = nextPos) {\\n    var view = new LineView(cm.doc, getLine(cm.doc, pos), pos)\\n    nextPos = pos + view.size\\n    array.push(view)\\n  }\\n  return array\\n}\\n\\nvar operationGroup = null\\n\\nfunction pushOperation(op) {\\n  if (operationGroup) {\\n    operationGroup.ops.push(op)\\n  } else {\\n    op.ownsGroup = operationGroup = {\\n      ops: [op],\\n      delayedCallbacks: []\\n    }\\n  }\\n}\\n\\nfunction fireCallbacksForOps(group) {\\n  // Calls delayed callbacks and cursorActivity handlers until no\\n  // new ones appear\\n  var callbacks = group.delayedCallbacks, i = 0\\n  do {\\n    for (; i < callbacks.length; i++)\\n      { callbacks[i].call(null) }\\n    for (var j = 0; j < group.ops.length; j++) {\\n      var op = group.ops[j]\\n      if (op.cursorActivityHandlers)\\n        { while (op.cursorActivityCalled < op.cursorActivityHandlers.length)\\n          { op.cursorActivityHandlers[op.cursorActivityCalled++].call(null, op.cm) } }\\n    }\\n  } while (i < callbacks.length)\\n}\\n\\nfunction finishOperation(op, endCb) {\\n  var group = op.ownsGroup\\n  if (!group) { return }\\n\\n  try { fireCallbacksForOps(group) }\\n  finally {\\n    operationGroup = null\\n    endCb(group)\\n  }\\n}\\n\\nvar orphanDelayedCallbacks = null\\n\\n// Often, we want to signal events at a point where we are in the\\n// middle of some work, but don't want the handler to start calling\\n// other methods on the editor, which might be in an inconsistent\\n// state or simply not expect any other events to happen.\\n// signalLater looks whether there are any handlers, and schedules\\n// them to be executed when the last operation ends, or, if no\\n// operation is active, when a timeout fires.\\nfunction signalLater(emitter, type /*, values...*/) {\\n  var arr = getHandlers(emitter, type)\\n  if (!arr.length) { return }\\n  var args = Array.prototype.slice.call(arguments, 2), list\\n  if (operationGroup) {\\n    list = operationGroup.delayedCallbacks\\n  } else if (orphanDelayedCallbacks) {\\n    list = orphanDelayedCallbacks\\n  } else {\\n    list = orphanDelayedCallbacks = []\\n    setTimeout(fireOrphanDelayed, 0)\\n  }\\n  var loop = function ( i ) {\\n    list.push(function () { return arr[i].apply(null, args); })\\n  };\\n\\n  for (var i = 0; i < arr.length; ++i)\\n    loop( i );\\n}\\n\\nfunction fireOrphanDelayed() {\\n  var delayed = orphanDelayedCallbacks\\n  orphanDelayedCallbacks = null\\n  for (var i = 0; i < delayed.length; ++i) { delayed[i]() }\\n}\\n\\n// When an aspect of a line changes, a string is added to\\n// lineView.changes. This updates the relevant part of the line's\\n// DOM structure.\\nfunction updateLineForChanges(cm, lineView, lineN, dims) {\\n  for (var j = 0; j < lineView.changes.length; j++) {\\n    var type = lineView.changes[j]\\n    if (type == \\\"text\\\") { updateLineText(cm, lineView) }\\n    else if (type == \\\"gutter\\\") { updateLineGutter(cm, lineView, lineN, dims) }\\n    else if (type == \\\"class\\\") { updateLineClasses(lineView) }\\n    else if (type == \\\"widget\\\") { updateLineWidgets(cm, lineView, dims) }\\n  }\\n  lineView.changes = null\\n}\\n\\n// Lines with gutter elements, widgets or a background class need to\\n// be wrapped, and have the extra elements added to the wrapper div\\nfunction ensureLineWrapped(lineView) {\\n  if (lineView.node == lineView.text) {\\n    lineView.node = elt(\\\"div\\\", null, null, \\\"position: relative\\\")\\n    if (lineView.text.parentNode)\\n      { lineView.text.parentNode.replaceChild(lineView.node, lineView.text) }\\n    lineView.node.appendChild(lineView.text)\\n    if (ie && ie_version < 8) { lineView.node.style.zIndex = 2 }\\n  }\\n  return lineView.node\\n}\\n\\nfunction updateLineBackground(lineView) {\\n  var cls = lineView.bgClass ? lineView.bgClass + \\\" \\\" + (lineView.line.bgClass || \\\"\\\") : lineView.line.bgClass\\n  if (cls) { cls += \\\" CodeMirror-linebackground\\\" }\\n  if (lineView.background) {\\n    if (cls) { lineView.background.className = cls }\\n    else { lineView.background.parentNode.removeChild(lineView.background); lineView.background = null }\\n  } else if (cls) {\\n    var wrap = ensureLineWrapped(lineView)\\n    lineView.background = wrap.insertBefore(elt(\\\"div\\\", null, cls), wrap.firstChild)\\n  }\\n}\\n\\n// Wrapper around buildLineContent which will reuse the structure\\n// in display.externalMeasured when possible.\\nfunction getLineContent(cm, lineView) {\\n  var ext = cm.display.externalMeasured\\n  if (ext && ext.line == lineView.line) {\\n    cm.display.externalMeasured = null\\n    lineView.measure = ext.measure\\n    return ext.built\\n  }\\n  return buildLineContent(cm, lineView)\\n}\\n\\n// Redraw the line's text. Interacts with the background and text\\n// classes because the mode may output tokens that influence these\\n// classes.\\nfunction updateLineText(cm, lineView) {\\n  var cls = lineView.text.className\\n  var built = getLineContent(cm, lineView)\\n  if (lineView.text == lineView.node) { lineView.node = built.pre }\\n  lineView.text.parentNode.replaceChild(built.pre, lineView.text)\\n  lineView.text = built.pre\\n  if (built.bgClass != lineView.bgClass || built.textClass != lineView.textClass) {\\n    lineView.bgClass = built.bgClass\\n    lineView.textClass = built.textClass\\n    updateLineClasses(lineView)\\n  } else if (cls) {\\n    lineView.text.className = cls\\n  }\\n}\\n\\nfunction updateLineClasses(lineView) {\\n  updateLineBackground(lineView)\\n  if (lineView.line.wrapClass)\\n    { ensureLineWrapped(lineView).className = lineView.line.wrapClass }\\n  else if (lineView.node != lineView.text)\\n    { lineView.node.className = \\\"\\\" }\\n  var textClass = lineView.textClass ? lineView.textClass + \\\" \\\" + (lineView.line.textClass || \\\"\\\") : lineView.line.textClass\\n  lineView.text.className = textClass || \\\"\\\"\\n}\\n\\nfunction updateLineGutter(cm, lineView, lineN, dims) {\\n  if (lineView.gutter) {\\n    lineView.node.removeChild(lineView.gutter)\\n    lineView.gutter = null\\n  }\\n  if (lineView.gutterBackground) {\\n    lineView.node.removeChild(lineView.gutterBackground)\\n    lineView.gutterBackground = null\\n  }\\n  if (lineView.line.gutterClass) {\\n    var wrap = ensureLineWrapped(lineView)\\n    lineView.gutterBackground = elt(\\\"div\\\", null, \\\"CodeMirror-gutter-background \\\" + lineView.line.gutterClass,\\n                                    (\\\"left: \\\" + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + \\\"px; width: \\\" + (dims.gutterTotalWidth) + \\\"px\\\"))\\n    wrap.insertBefore(lineView.gutterBackground, lineView.text)\\n  }\\n  var markers = lineView.line.gutterMarkers\\n  if (cm.options.lineNumbers || markers) {\\n    var wrap$1 = ensureLineWrapped(lineView)\\n    var gutterWrap = lineView.gutter = elt(\\\"div\\\", null, \\\"CodeMirror-gutter-wrapper\\\", (\\\"left: \\\" + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + \\\"px\\\"))\\n    cm.display.input.setUneditable(gutterWrap)\\n    wrap$1.insertBefore(gutterWrap, lineView.text)\\n    if (lineView.line.gutterClass)\\n      { gutterWrap.className += \\\" \\\" + lineView.line.gutterClass }\\n    if (cm.options.lineNumbers && (!markers || !markers[\\\"CodeMirror-linenumbers\\\"]))\\n      { lineView.lineNumber = gutterWrap.appendChild(\\n        elt(\\\"div\\\", lineNumberFor(cm.options, lineN),\\n            \\\"CodeMirror-linenumber CodeMirror-gutter-elt\\\",\\n            (\\\"left: \\\" + (dims.gutterLeft[\\\"CodeMirror-linenumbers\\\"]) + \\\"px; width: \\\" + (cm.display.lineNumInnerWidth) + \\\"px\\\"))) }\\n    if (markers) { for (var k = 0; k < cm.options.gutters.length; ++k) {\\n      var id = cm.options.gutters[k], found = markers.hasOwnProperty(id) && markers[id]\\n      if (found)\\n        { gutterWrap.appendChild(elt(\\\"div\\\", [found], \\\"CodeMirror-gutter-elt\\\",\\n                                   (\\\"left: \\\" + (dims.gutterLeft[id]) + \\\"px; width: \\\" + (dims.gutterWidth[id]) + \\\"px\\\"))) }\\n    } }\\n  }\\n}\\n\\nfunction updateLineWidgets(cm, lineView, dims) {\\n  if (lineView.alignable) { lineView.alignable = null }\\n  for (var node = lineView.node.firstChild, next = (void 0); node; node = next) {\\n    next = node.nextSibling\\n    if (node.className == \\\"CodeMirror-linewidget\\\")\\n      { lineView.node.removeChild(node) }\\n  }\\n  insertLineWidgets(cm, lineView, dims)\\n}\\n\\n// Build a line's DOM representation from scratch\\nfunction buildLineElement(cm, lineView, lineN, dims) {\\n  var built = getLineContent(cm, lineView)\\n  lineView.text = lineView.node = built.pre\\n  if (built.bgClass) { lineView.bgClass = built.bgClass }\\n  if (built.textClass) { lineView.textClass = built.textClass }\\n\\n  updateLineClasses(lineView)\\n  updateLineGutter(cm, lineView, lineN, dims)\\n  insertLineWidgets(cm, lineView, dims)\\n  return lineView.node\\n}\\n\\n// A lineView may contain multiple logical lines (when merged by\\n// collapsed spans). The widgets for all of them need to be drawn.\\nfunction insertLineWidgets(cm, lineView, dims) {\\n  insertLineWidgetsFor(cm, lineView.line, lineView, dims, true)\\n  if (lineView.rest) { for (var i = 0; i < lineView.rest.length; i++)\\n    { insertLineWidgetsFor(cm, lineView.rest[i], lineView, dims, false) } }\\n}\\n\\nfunction insertLineWidgetsFor(cm, line, lineView, dims, allowAbove) {\\n  if (!line.widgets) { return }\\n  var wrap = ensureLineWrapped(lineView)\\n  for (var i = 0, ws = line.widgets; i < ws.length; ++i) {\\n    var widget = ws[i], node = elt(\\\"div\\\", [widget.node], \\\"CodeMirror-linewidget\\\")\\n    if (!widget.handleMouseEvents) { node.setAttribute(\\\"cm-ignore-events\\\", \\\"true\\\") }\\n    positionLineWidget(widget, node, lineView, dims)\\n    cm.display.input.setUneditable(node)\\n    if (allowAbove && widget.above)\\n      { wrap.insertBefore(node, lineView.gutter || lineView.text) }\\n    else\\n      { wrap.appendChild(node) }\\n    signalLater(widget, \\\"redraw\\\")\\n  }\\n}\\n\\nfunction positionLineWidget(widget, node, lineView, dims) {\\n  if (widget.noHScroll) {\\n    ;(lineView.alignable || (lineView.alignable = [])).push(node)\\n    var width = dims.wrapperWidth\\n    node.style.left = dims.fixedPos + \\\"px\\\"\\n    if (!widget.coverGutter) {\\n      width -= dims.gutterTotalWidth\\n      node.style.paddingLeft = dims.gutterTotalWidth + \\\"px\\\"\\n    }\\n    node.style.width = width + \\\"px\\\"\\n  }\\n  if (widget.coverGutter) {\\n    node.style.zIndex = 5\\n    node.style.position = \\\"relative\\\"\\n    if (!widget.noHScroll) { node.style.marginLeft = -dims.gutterTotalWidth + \\\"px\\\" }\\n  }\\n}\\n\\nfunction widgetHeight(widget) {\\n  if (widget.height != null) { return widget.height }\\n  var cm = widget.doc.cm\\n  if (!cm) { return 0 }\\n  if (!contains(document.body, widget.node)) {\\n    var parentStyle = \\\"position: relative;\\\"\\n    if (widget.coverGutter)\\n      { parentStyle += \\\"margin-left: -\\\" + cm.display.gutters.offsetWidth + \\\"px;\\\" }\\n    if (widget.noHScroll)\\n      { parentStyle += \\\"width: \\\" + cm.display.wrapper.clientWidth + \\\"px;\\\" }\\n    removeChildrenAndAdd(cm.display.measure, elt(\\\"div\\\", [widget.node], null, parentStyle))\\n  }\\n  return widget.height = widget.node.parentNode.offsetHeight\\n}\\n\\n// Return true when the given mouse event happened in a widget\\nfunction eventInWidget(display, e) {\\n  for (var n = e_target(e); n != display.wrapper; n = n.parentNode) {\\n    if (!n || (n.nodeType == 1 && n.getAttribute(\\\"cm-ignore-events\\\") == \\\"true\\\") ||\\n        (n.parentNode == display.sizer && n != display.mover))\\n      { return true }\\n  }\\n}\\n\\n// POSITION MEASUREMENT\\n\\nfunction paddingTop(display) {return display.lineSpace.offsetTop}\\nfunction paddingVert(display) {return display.mover.offsetHeight - display.lineSpace.offsetHeight}\\nfunction paddingH(display) {\\n  if (display.cachedPaddingH) { return display.cachedPaddingH }\\n  var e = removeChildrenAndAdd(display.measure, elt(\\\"pre\\\", \\\"x\\\"))\\n  var style = window.getComputedStyle ? window.getComputedStyle(e) : e.currentStyle\\n  var data = {left: parseInt(style.paddingLeft), right: parseInt(style.paddingRight)}\\n  if (!isNaN(data.left) && !isNaN(data.right)) { display.cachedPaddingH = data }\\n  return data\\n}\\n\\nfunction scrollGap(cm) { return scrollerGap - cm.display.nativeBarWidth }\\nfunction displayWidth(cm) {\\n  return cm.display.scroller.clientWidth - scrollGap(cm) - cm.display.barWidth\\n}\\nfunction displayHeight(cm) {\\n  return cm.display.scroller.clientHeight - scrollGap(cm) - cm.display.barHeight\\n}\\n\\n// Ensure the lineView.wrapping.heights array is populated. This is\\n// an array of bottom offsets for the lines that make up a drawn\\n// line. When lineWrapping is on, there might be more than one\\n// height.\\nfunction ensureLineHeights(cm, lineView, rect) {\\n  var wrapping = cm.options.lineWrapping\\n  var curWidth = wrapping && displayWidth(cm)\\n  if (!lineView.measure.heights || wrapping && lineView.measure.width != curWidth) {\\n    var heights = lineView.measure.heights = []\\n    if (wrapping) {\\n      lineView.measure.width = curWidth\\n      var rects = lineView.text.firstChild.getClientRects()\\n      for (var i = 0; i < rects.length - 1; i++) {\\n        var cur = rects[i], next = rects[i + 1]\\n        if (Math.abs(cur.bottom - next.bottom) > 2)\\n          { heights.push((cur.bottom + next.top) / 2 - rect.top) }\\n      }\\n    }\\n    heights.push(rect.bottom - rect.top)\\n  }\\n}\\n\\n// Find a line map (mapping character offsets to text nodes) and a\\n// measurement cache for the given line number. (A line view might\\n// contain multiple lines when collapsed ranges are present.)\\nfunction mapFromLineView(lineView, line, lineN) {\\n  if (lineView.line == line)\\n    { return {map: lineView.measure.map, cache: lineView.measure.cache} }\\n  for (var i = 0; i < lineView.rest.length; i++)\\n    { if (lineView.rest[i] == line)\\n      { return {map: lineView.measure.maps[i], cache: lineView.measure.caches[i]} } }\\n  for (var i$1 = 0; i$1 < lineView.rest.length; i$1++)\\n    { if (lineNo(lineView.rest[i$1]) > lineN)\\n      { return {map: lineView.measure.maps[i$1], cache: lineView.measure.caches[i$1], before: true} } }\\n}\\n\\n// Render a line into the hidden node display.externalMeasured. Used\\n// when measurement is needed for a line that's not in the viewport.\\nfunction updateExternalMeasurement(cm, line) {\\n  line = visualLine(line)\\n  var lineN = lineNo(line)\\n  var view = cm.display.externalMeasured = new LineView(cm.doc, line, lineN)\\n  view.lineN = lineN\\n  var built = view.built = buildLineContent(cm, view)\\n  view.text = built.pre\\n  removeChildrenAndAdd(cm.display.lineMeasure, built.pre)\\n  return view\\n}\\n\\n// Get a {top, bottom, left, right} box (in line-local coordinates)\\n// for a given character.\\nfunction measureChar(cm, line, ch, bias) {\\n  return measureCharPrepared(cm, prepareMeasureForLine(cm, line), ch, bias)\\n}\\n\\n// Find a line view that corresponds to the given line number.\\nfunction findViewForLine(cm, lineN) {\\n  if (lineN >= cm.display.viewFrom && lineN < cm.display.viewTo)\\n    { return cm.display.view[findViewIndex(cm, lineN)] }\\n  var ext = cm.display.externalMeasured\\n  if (ext && lineN >= ext.lineN && lineN < ext.lineN + ext.size)\\n    { return ext }\\n}\\n\\n// Measurement can be split in two steps, the set-up work that\\n// applies to the whole line, and the measurement of the actual\\n// character. Functions like coordsChar, that need to do a lot of\\n// measurements in a row, can thus ensure that the set-up work is\\n// only done once.\\nfunction prepareMeasureForLine(cm, line) {\\n  var lineN = lineNo(line)\\n  var view = findViewForLine(cm, lineN)\\n  if (view && !view.text) {\\n    view = null\\n  } else if (view && view.changes) {\\n    updateLineForChanges(cm, view, lineN, getDimensions(cm))\\n    cm.curOp.forceUpdate = true\\n  }\\n  if (!view)\\n    { view = updateExternalMeasurement(cm, line) }\\n\\n  var info = mapFromLineView(view, line, lineN)\\n  return {\\n    line: line, view: view, rect: null,\\n    map: info.map, cache: info.cache, before: info.before,\\n    hasHeights: false\\n  }\\n}\\n\\n// Given a prepared measurement object, measures the position of an\\n// actual character (or fetches it from the cache).\\nfunction measureCharPrepared(cm, prepared, ch, bias, varHeight) {\\n  if (prepared.before) { ch = -1 }\\n  var key = ch + (bias || \\\"\\\"), found\\n  if (prepared.cache.hasOwnProperty(key)) {\\n    found = prepared.cache[key]\\n  } else {\\n    if (!prepared.rect)\\n      { prepared.rect = prepared.view.text.getBoundingClientRect() }\\n    if (!prepared.hasHeights) {\\n      ensureLineHeights(cm, prepared.view, prepared.rect)\\n      prepared.hasHeights = true\\n    }\\n    found = measureCharInner(cm, prepared, ch, bias)\\n    if (!found.bogus) { prepared.cache[key] = found }\\n  }\\n  return {left: found.left, right: found.right,\\n          top: varHeight ? found.rtop : found.top,\\n          bottom: varHeight ? found.rbottom : found.bottom}\\n}\\n\\nvar nullRect = {left: 0, right: 0, top: 0, bottom: 0}\\n\\nfunction nodeAndOffsetInLineMap(map, ch, bias) {\\n  var node, start, end, collapse, mStart, mEnd\\n  // First, search the line map for the text node corresponding to,\\n  // or closest to, the target character.\\n  for (var i = 0; i < map.length; i += 3) {\\n    mStart = map[i]\\n    mEnd = map[i + 1]\\n    if (ch < mStart) {\\n      start = 0; end = 1\\n      collapse = \\\"left\\\"\\n    } else if (ch < mEnd) {\\n      start = ch - mStart\\n      end = start + 1\\n    } else if (i == map.length - 3 || ch == mEnd && map[i + 3] > ch) {\\n      end = mEnd - mStart\\n      start = end - 1\\n      if (ch >= mEnd) { collapse = \\\"right\\\" }\\n    }\\n    if (start != null) {\\n      node = map[i + 2]\\n      if (mStart == mEnd && bias == (node.insertLeft ? \\\"left\\\" : \\\"right\\\"))\\n        { collapse = bias }\\n      if (bias == \\\"left\\\" && start == 0)\\n        { while (i && map[i - 2] == map[i - 3] && map[i - 1].insertLeft) {\\n          node = map[(i -= 3) + 2]\\n          collapse = \\\"left\\\"\\n        } }\\n      if (bias == \\\"right\\\" && start == mEnd - mStart)\\n        { while (i < map.length - 3 && map[i + 3] == map[i + 4] && !map[i + 5].insertLeft) {\\n          node = map[(i += 3) + 2]\\n          collapse = \\\"right\\\"\\n        } }\\n      break\\n    }\\n  }\\n  return {node: node, start: start, end: end, collapse: collapse, coverStart: mStart, coverEnd: mEnd}\\n}\\n\\nfunction getUsefulRect(rects, bias) {\\n  var rect = nullRect\\n  if (bias == \\\"left\\\") { for (var i = 0; i < rects.length; i++) {\\n    if ((rect = rects[i]).left != rect.right) { break }\\n  } } else { for (var i$1 = rects.length - 1; i$1 >= 0; i$1--) {\\n    if ((rect = rects[i$1]).left != rect.right) { break }\\n  } }\\n  return rect\\n}\\n\\nfunction measureCharInner(cm, prepared, ch, bias) {\\n  var place = nodeAndOffsetInLineMap(prepared.map, ch, bias)\\n  var node = place.node, start = place.start, end = place.end, collapse = place.collapse\\n\\n  var rect\\n  if (node.nodeType == 3) { // If it is a text node, use a range to retrieve the coordinates.\\n    for (var i$1 = 0; i$1 < 4; i$1++) { // Retry a maximum of 4 times when nonsense rectangles are returned\\n      while (start && isExtendingChar(prepared.line.text.charAt(place.coverStart + start))) { --start }\\n      while (place.coverStart + end < place.coverEnd && isExtendingChar(prepared.line.text.charAt(place.coverStart + end))) { ++end }\\n      if (ie && ie_version < 9 && start == 0 && end == place.coverEnd - place.coverStart)\\n        { rect = node.parentNode.getBoundingClientRect() }\\n      else\\n        { rect = getUsefulRect(range(node, start, end).getClientRects(), bias) }\\n      if (rect.left || rect.right || start == 0) { break }\\n      end = start\\n      start = start - 1\\n      collapse = \\\"right\\\"\\n    }\\n    if (ie && ie_version < 11) { rect = maybeUpdateRectForZooming(cm.display.measure, rect) }\\n  } else { // If it is a widget, simply get the box for the whole widget.\\n    if (start > 0) { collapse = bias = \\\"right\\\" }\\n    var rects\\n    if (cm.options.lineWrapping && (rects = node.getClientRects()).length > 1)\\n      { rect = rects[bias == \\\"right\\\" ? rects.length - 1 : 0] }\\n    else\\n      { rect = node.getBoundingClientRect() }\\n  }\\n  if (ie && ie_version < 9 && !start && (!rect || !rect.left && !rect.right)) {\\n    var rSpan = node.parentNode.getClientRects()[0]\\n    if (rSpan)\\n      { rect = {left: rSpan.left, right: rSpan.left + charWidth(cm.display), top: rSpan.top, bottom: rSpan.bottom} }\\n    else\\n      { rect = nullRect }\\n  }\\n\\n  var rtop = rect.top - prepared.rect.top, rbot = rect.bottom - prepared.rect.top\\n  var mid = (rtop + rbot) / 2\\n  var heights = prepared.view.measure.heights\\n  var i = 0\\n  for (; i < heights.length - 1; i++)\\n    { if (mid < heights[i]) { break } }\\n  var top = i ? heights[i - 1] : 0, bot = heights[i]\\n  var result = {left: (collapse == \\\"right\\\" ? rect.right : rect.left) - prepared.rect.left,\\n                right: (collapse == \\\"left\\\" ? rect.left : rect.right) - prepared.rect.left,\\n                top: top, bottom: bot}\\n  if (!rect.left && !rect.right) { result.bogus = true }\\n  if (!cm.options.singleCursorHeightPerLine) { result.rtop = rtop; result.rbottom = rbot }\\n\\n  return result\\n}\\n\\n// Work around problem with bounding client rects on ranges being\\n// returned incorrectly when zoomed on IE10 and below.\\nfunction maybeUpdateRectForZooming(measure, rect) {\\n  if (!window.screen || screen.logicalXDPI == null ||\\n      screen.logicalXDPI == screen.deviceXDPI || !hasBadZoomedRects(measure))\\n    { return rect }\\n  var scaleX = screen.logicalXDPI / screen.deviceXDPI\\n  var scaleY = screen.logicalYDPI / screen.deviceYDPI\\n  return {left: rect.left * scaleX, right: rect.right * scaleX,\\n          top: rect.top * scaleY, bottom: rect.bottom * scaleY}\\n}\\n\\nfunction clearLineMeasurementCacheFor(lineView) {\\n  if (lineView.measure) {\\n    lineView.measure.cache = {}\\n    lineView.measure.heights = null\\n    if (lineView.rest) { for (var i = 0; i < lineView.rest.length; i++)\\n      { lineView.measure.caches[i] = {} } }\\n  }\\n}\\n\\nfunction clearLineMeasurementCache(cm) {\\n  cm.display.externalMeasure = null\\n  removeChildren(cm.display.lineMeasure)\\n  for (var i = 0; i < cm.display.view.length; i++)\\n    { clearLineMeasurementCacheFor(cm.display.view[i]) }\\n}\\n\\nfunction clearCaches(cm) {\\n  clearLineMeasurementCache(cm)\\n  cm.display.cachedCharWidth = cm.display.cachedTextHeight = cm.display.cachedPaddingH = null\\n  if (!cm.options.lineWrapping) { cm.display.maxLineChanged = true }\\n  cm.display.lineNumChars = null\\n}\\n\\nfunction pageScrollX() { return window.pageXOffset || (document.documentElement || document.body).scrollLeft }\\nfunction pageScrollY() { return window.pageYOffset || (document.documentElement || document.body).scrollTop }\\n\\n// Converts a {top, bottom, left, right} box from line-local\\n// coordinates into another coordinate system. Context may be one of\\n// \\\"line\\\", \\\"div\\\" (display.lineDiv), \\\"local\\\"./null (editor), \\\"window\\\",\\n// or \\\"page\\\".\\nfunction intoCoordSystem(cm, lineObj, rect, context, includeWidgets) {\\n  if (!includeWidgets && lineObj.widgets) { for (var i = 0; i < lineObj.widgets.length; ++i) { if (lineObj.widgets[i].above) {\\n    var size = widgetHeight(lineObj.widgets[i])\\n    rect.top += size; rect.bottom += size\\n  } } }\\n  if (context == \\\"line\\\") { return rect }\\n  if (!context) { context = \\\"local\\\" }\\n  var yOff = heightAtLine(lineObj)\\n  if (context == \\\"local\\\") { yOff += paddingTop(cm.display) }\\n  else { yOff -= cm.display.viewOffset }\\n  if (context == \\\"page\\\" || context == \\\"window\\\") {\\n    var lOff = cm.display.lineSpace.getBoundingClientRect()\\n    yOff += lOff.top + (context == \\\"window\\\" ? 0 : pageScrollY())\\n    var xOff = lOff.left + (context == \\\"window\\\" ? 0 : pageScrollX())\\n    rect.left += xOff; rect.right += xOff\\n  }\\n  rect.top += yOff; rect.bottom += yOff\\n  return rect\\n}\\n\\n// Coverts a box from \\\"div\\\" coords to another coordinate system.\\n// Context may be \\\"window\\\", \\\"page\\\", \\\"div\\\", or \\\"local\\\"./null.\\nfunction fromCoordSystem(cm, coords, context) {\\n  if (context == \\\"div\\\") { return coords }\\n  var left = coords.left, top = coords.top\\n  // First move into \\\"page\\\" coordinate system\\n  if (context == \\\"page\\\") {\\n    left -= pageScrollX()\\n    top -= pageScrollY()\\n  } else if (context == \\\"local\\\" || !context) {\\n    var localBox = cm.display.sizer.getBoundingClientRect()\\n    left += localBox.left\\n    top += localBox.top\\n  }\\n\\n  var lineSpaceBox = cm.display.lineSpace.getBoundingClientRect()\\n  return {left: left - lineSpaceBox.left, top: top - lineSpaceBox.top}\\n}\\n\\nfunction charCoords(cm, pos, context, lineObj, bias) {\\n  if (!lineObj) { lineObj = getLine(cm.doc, pos.line) }\\n  return intoCoordSystem(cm, lineObj, measureChar(cm, lineObj, pos.ch, bias), context)\\n}\\n\\n// Returns a box for a given cursor position, which may have an\\n// 'other' property containing the position of the secondary cursor\\n// on a bidi boundary.\\n// A cursor Pos(line, char, \\\"before\\\") is on the same visual line as `char - 1`\\n// and after `char - 1` in writing order of `char - 1`\\n// A cursor Pos(line, char, \\\"after\\\") is on the same visual line as `char`\\n// and before `char` in writing order of `char`\\n// Examples (upper-case letters are RTL, lower-case are LTR):\\n//     Pos(0, 1, ...)\\n//     before   after\\n// ab     a|b     a|b\\n// aB     a|B     aB|\\n// Ab     |Ab     A|b\\n// AB     B|A     B|A\\n// Every position after the last character on a line is considered to stick\\n// to the last character on the line.\\nfunction cursorCoords(cm, pos, context, lineObj, preparedMeasure, varHeight) {\\n  lineObj = lineObj || getLine(cm.doc, pos.line)\\n  if (!preparedMeasure) { preparedMeasure = prepareMeasureForLine(cm, lineObj) }\\n  function get(ch, right) {\\n    var m = measureCharPrepared(cm, preparedMeasure, ch, right ? \\\"right\\\" : \\\"left\\\", varHeight)\\n    if (right) { m.left = m.right; } else { m.right = m.left }\\n    return intoCoordSystem(cm, lineObj, m, context)\\n  }\\n  var order = getOrder(lineObj), ch = pos.ch, sticky = pos.sticky\\n  if (ch >= lineObj.text.length) {\\n    ch = lineObj.text.length\\n    sticky = \\\"before\\\"\\n  } else if (ch <= 0) {\\n    ch = 0\\n    sticky = \\\"after\\\"\\n  }\\n  if (!order) { return get(sticky == \\\"before\\\" ? ch - 1 : ch, sticky == \\\"before\\\") }\\n\\n  function getBidi(ch, partPos, invert) {\\n    var part = order[partPos], right = (part.level % 2) != 0\\n    return get(invert ? ch - 1 : ch, right != invert)\\n  }\\n  var partPos = getBidiPartAt(order, ch, sticky)\\n  var other = bidiOther\\n  var val = getBidi(ch, partPos, sticky == \\\"before\\\")\\n  if (other != null) { val.other = getBidi(ch, other, sticky != \\\"before\\\") }\\n  return val\\n}\\n\\n// Used to cheaply estimate the coordinates for a position. Used for\\n// intermediate scroll updates.\\nfunction estimateCoords(cm, pos) {\\n  var left = 0\\n  pos = clipPos(cm.doc, pos)\\n  if (!cm.options.lineWrapping) { left = charWidth(cm.display) * pos.ch }\\n  var lineObj = getLine(cm.doc, pos.line)\\n  var top = heightAtLine(lineObj) + paddingTop(cm.display)\\n  return {left: left, right: left, top: top, bottom: top + lineObj.height}\\n}\\n\\n// Positions returned by coordsChar contain some extra information.\\n// xRel is the relative x position of the input coordinates compared\\n// to the found position (so xRel > 0 means the coordinates are to\\n// the right of the character position, for example). When outside\\n// is true, that means the coordinates lie outside the line's\\n// vertical range.\\nfunction PosWithInfo(line, ch, sticky, outside, xRel) {\\n  var pos = Pos(line, ch, sticky)\\n  pos.xRel = xRel\\n  if (outside) { pos.outside = true }\\n  return pos\\n}\\n\\n// Compute the character position closest to the given coordinates.\\n// Input must be lineSpace-local (\\\"div\\\" coordinate system).\\nfunction coordsChar(cm, x, y) {\\n  var doc = cm.doc\\n  y += cm.display.viewOffset\\n  if (y < 0) { return PosWithInfo(doc.first, 0, null, true, -1) }\\n  var lineN = lineAtHeight(doc, y), last = doc.first + doc.size - 1\\n  if (lineN > last)\\n    { return PosWithInfo(doc.first + doc.size - 1, getLine(doc, last).text.length, null, true, 1) }\\n  if (x < 0) { x = 0 }\\n\\n  var lineObj = getLine(doc, lineN)\\n  for (;;) {\\n    var found = coordsCharInner(cm, lineObj, lineN, x, y)\\n    var merged = collapsedSpanAtEnd(lineObj)\\n    var mergedPos = merged && merged.find(0, true)\\n    if (merged && (found.ch > mergedPos.from.ch || found.ch == mergedPos.from.ch && found.xRel > 0))\\n      { lineN = lineNo(lineObj = mergedPos.to.line) }\\n    else\\n      { return found }\\n  }\\n}\\n\\nfunction wrappedLineExtent(cm, lineObj, preparedMeasure, y) {\\n  var measure = function (ch) { return intoCoordSystem(cm, lineObj, measureCharPrepared(cm, preparedMeasure, ch), \\\"line\\\"); }\\n  var end = lineObj.text.length\\n  var begin = findFirst(function (ch) { return measure(ch - 1).bottom <= y; }, end, 0)\\n  end = findFirst(function (ch) { return measure(ch).top > y; }, begin, end)\\n  return {begin: begin, end: end}\\n}\\n\\nfunction wrappedLineExtentChar(cm, lineObj, preparedMeasure, target) {\\n  var targetTop = intoCoordSystem(cm, lineObj, measureCharPrepared(cm, preparedMeasure, target), \\\"line\\\").top\\n  return wrappedLineExtent(cm, lineObj, preparedMeasure, targetTop)\\n}\\n\\nfunction coordsCharInner(cm, lineObj, lineNo, x, y) {\\n  y -= heightAtLine(lineObj)\\n  var begin = 0, end = lineObj.text.length\\n  var preparedMeasure = prepareMeasureForLine(cm, lineObj)\\n  var pos\\n  var order = getOrder(lineObj)\\n  if (order) {\\n    if (cm.options.lineWrapping) {\\n      ;var assign;\\n      ((assign = wrappedLineExtent(cm, lineObj, preparedMeasure, y), begin = assign.begin, end = assign.end, assign))\\n    }\\n    pos = new Pos(lineNo, begin)\\n    var beginLeft = cursorCoords(cm, pos, \\\"line\\\", lineObj, preparedMeasure).left\\n    var dir = beginLeft < x ? 1 : -1\\n    var prevDiff, diff = beginLeft - x, prevPos\\n    do {\\n      prevDiff = diff\\n      prevPos = pos\\n      pos = moveVisually(cm, lineObj, pos, dir)\\n      if (pos == null || pos.ch < begin || end <= (pos.sticky == \\\"before\\\" ? pos.ch - 1 : pos.ch)) {\\n        pos = prevPos\\n        break\\n      }\\n      diff = cursorCoords(cm, pos, \\\"line\\\", lineObj, preparedMeasure).left - x\\n    } while ((dir < 0) != (diff < 0) && (Math.abs(diff) <= Math.abs(prevDiff)))\\n    if (Math.abs(diff) > Math.abs(prevDiff)) {\\n      if ((diff < 0) == (prevDiff < 0)) { throw new Error(\\\"Broke out of infinite loop in coordsCharInner\\\") }\\n      pos = prevPos\\n    }\\n  } else {\\n    var ch = findFirst(function (ch) {\\n      var box = intoCoordSystem(cm, lineObj, measureCharPrepared(cm, preparedMeasure, ch), \\\"line\\\")\\n      if (box.top > y) {\\n        // For the cursor stickiness\\n        end = Math.min(ch, end)\\n        return true\\n      }\\n      else if (box.bottom <= y) { return false }\\n      else if (box.left > x) { return true }\\n      else if (box.right < x) { return false }\\n      else { return (x - box.left < box.right - x) }\\n    }, begin, end)\\n    ch = skipExtendingChars(lineObj.text, ch, 1)\\n    pos = new Pos(lineNo, ch, ch == end ? \\\"before\\\" : \\\"after\\\")\\n  }\\n  var coords = cursorCoords(cm, pos, \\\"line\\\", lineObj, preparedMeasure)\\n  if (y < coords.top || coords.bottom < y) { pos.outside = true }\\n  pos.xRel = x < coords.left ? -1 : (x > coords.right ? 1 : 0)\\n  return pos\\n}\\n\\nvar measureText\\n// Compute the default text height.\\nfunction textHeight(display) {\\n  if (display.cachedTextHeight != null) { return display.cachedTextHeight }\\n  if (measureText == null) {\\n    measureText = elt(\\\"pre\\\")\\n    // Measure a bunch of lines, for browsers that compute\\n    // fractional heights.\\n    for (var i = 0; i < 49; ++i) {\\n      measureText.appendChild(document.createTextNode(\\\"x\\\"))\\n      measureText.appendChild(elt(\\\"br\\\"))\\n    }\\n    measureText.appendChild(document.createTextNode(\\\"x\\\"))\\n  }\\n  removeChildrenAndAdd(display.measure, measureText)\\n  var height = measureText.offsetHeight / 50\\n  if (height > 3) { display.cachedTextHeight = height }\\n  removeChildren(display.measure)\\n  return height || 1\\n}\\n\\n// Compute the default character width.\\nfunction charWidth(display) {\\n  if (display.cachedCharWidth != null) { return display.cachedCharWidth }\\n  var anchor = elt(\\\"span\\\", \\\"xxxxxxxxxx\\\")\\n  var pre = elt(\\\"pre\\\", [anchor])\\n  removeChildrenAndAdd(display.measure, pre)\\n  var rect = anchor.getBoundingClientRect(), width = (rect.right - rect.left) / 10\\n  if (width > 2) { display.cachedCharWidth = width }\\n  return width || 10\\n}\\n\\n// Do a bulk-read of the DOM positions and sizes needed to draw the\\n// view, so that we don't interleave reading and writing to the DOM.\\nfunction getDimensions(cm) {\\n  var d = cm.display, left = {}, width = {}\\n  var gutterLeft = d.gutters.clientLeft\\n  for (var n = d.gutters.firstChild, i = 0; n; n = n.nextSibling, ++i) {\\n    left[cm.options.gutters[i]] = n.offsetLeft + n.clientLeft + gutterLeft\\n    width[cm.options.gutters[i]] = n.clientWidth\\n  }\\n  return {fixedPos: compensateForHScroll(d),\\n          gutterTotalWidth: d.gutters.offsetWidth,\\n          gutterLeft: left,\\n          gutterWidth: width,\\n          wrapperWidth: d.wrapper.clientWidth}\\n}\\n\\n// Computes display.scroller.scrollLeft + display.gutters.offsetWidth,\\n// but using getBoundingClientRect to get a sub-pixel-accurate\\n// result.\\nfunction compensateForHScroll(display) {\\n  return display.scroller.getBoundingClientRect().left - display.sizer.getBoundingClientRect().left\\n}\\n\\n// Returns a function that estimates the height of a line, to use as\\n// first approximation until the line becomes visible (and is thus\\n// properly measurable).\\nfunction estimateHeight(cm) {\\n  var th = textHeight(cm.display), wrapping = cm.options.lineWrapping\\n  var perLine = wrapping && Math.max(5, cm.display.scroller.clientWidth / charWidth(cm.display) - 3)\\n  return function (line) {\\n    if (lineIsHidden(cm.doc, line)) { return 0 }\\n\\n    var widgetsHeight = 0\\n    if (line.widgets) { for (var i = 0; i < line.widgets.length; i++) {\\n      if (line.widgets[i].height) { widgetsHeight += line.widgets[i].height }\\n    } }\\n\\n    if (wrapping)\\n      { return widgetsHeight + (Math.ceil(line.text.length / perLine) || 1) * th }\\n    else\\n      { return widgetsHeight + th }\\n  }\\n}\\n\\nfunction estimateLineHeights(cm) {\\n  var doc = cm.doc, est = estimateHeight(cm)\\n  doc.iter(function (line) {\\n    var estHeight = est(line)\\n    if (estHeight != line.height) { updateLineHeight(line, estHeight) }\\n  })\\n}\\n\\n// Given a mouse event, find the corresponding position. If liberal\\n// is false, it checks whether a gutter or scrollbar was clicked,\\n// and returns null if it was. forRect is used by rectangular\\n// selections, and tries to estimate a character position even for\\n// coordinates beyond the right of the text.\\nfunction posFromMouse(cm, e, liberal, forRect) {\\n  var display = cm.display\\n  if (!liberal && e_target(e).getAttribute(\\\"cm-not-content\\\") == \\\"true\\\") { return null }\\n\\n  var x, y, space = display.lineSpace.getBoundingClientRect()\\n  // Fails unpredictably on IE[67] when mouse is dragged around quickly.\\n  try { x = e.clientX - space.left; y = e.clientY - space.top }\\n  catch (e) { return null }\\n  var coords = coordsChar(cm, x, y), line\\n  if (forRect && coords.xRel == 1 && (line = getLine(cm.doc, coords.line).text).length == coords.ch) {\\n    var colDiff = countColumn(line, line.length, cm.options.tabSize) - line.length\\n    coords = Pos(coords.line, Math.max(0, Math.round((x - paddingH(cm.display).left) / charWidth(cm.display)) - colDiff))\\n  }\\n  return coords\\n}\\n\\n// Find the view element corresponding to a given line. Return null\\n// when the line isn't visible.\\nfunction findViewIndex(cm, n) {\\n  if (n >= cm.display.viewTo) { return null }\\n  n -= cm.display.viewFrom\\n  if (n < 0) { return null }\\n  var view = cm.display.view\\n  for (var i = 0; i < view.length; i++) {\\n    n -= view[i].size\\n    if (n < 0) { return i }\\n  }\\n}\\n\\nfunction updateSelection(cm) {\\n  cm.display.input.showSelection(cm.display.input.prepareSelection())\\n}\\n\\nfunction prepareSelection(cm, primary) {\\n  var doc = cm.doc, result = {}\\n  var curFragment = result.cursors = document.createDocumentFragment()\\n  var selFragment = result.selection = document.createDocumentFragment()\\n\\n  for (var i = 0; i < doc.sel.ranges.length; i++) {\\n    if (primary === false && i == doc.sel.primIndex) { continue }\\n    var range = doc.sel.ranges[i]\\n    if (range.from().line >= cm.display.viewTo || range.to().line < cm.display.viewFrom) { continue }\\n    var collapsed = range.empty()\\n    if (collapsed || cm.options.showCursorWhenSelecting)\\n      { drawSelectionCursor(cm, range.head, curFragment) }\\n    if (!collapsed)\\n      { drawSelectionRange(cm, range, selFragment) }\\n  }\\n  return result\\n}\\n\\n// Draws a cursor for the given range\\nfunction drawSelectionCursor(cm, head, output) {\\n  var pos = cursorCoords(cm, head, \\\"div\\\", null, null, !cm.options.singleCursorHeightPerLine)\\n\\n  var cursor = output.appendChild(elt(\\\"div\\\", \\\"\\\\u00a0\\\", \\\"CodeMirror-cursor\\\"))\\n  cursor.style.left = pos.left + \\\"px\\\"\\n  cursor.style.top = pos.top + \\\"px\\\"\\n  cursor.style.height = Math.max(0, pos.bottom - pos.top) * cm.options.cursorHeight + \\\"px\\\"\\n\\n  if (pos.other) {\\n    // Secondary cursor, shown when on a 'jump' in bi-directional text\\n    var otherCursor = output.appendChild(elt(\\\"div\\\", \\\"\\\\u00a0\\\", \\\"CodeMirror-cursor CodeMirror-secondarycursor\\\"))\\n    otherCursor.style.display = \\\"\\\"\\n    otherCursor.style.left = pos.other.left + \\\"px\\\"\\n    otherCursor.style.top = pos.other.top + \\\"px\\\"\\n    otherCursor.style.height = (pos.other.bottom - pos.other.top) * .85 + \\\"px\\\"\\n  }\\n}\\n\\n// Draws the given range as a highlighted selection\\nfunction drawSelectionRange(cm, range, output) {\\n  var display = cm.display, doc = cm.doc\\n  var fragment = document.createDocumentFragment()\\n  var padding = paddingH(cm.display), leftSide = padding.left\\n  var rightSide = Math.max(display.sizerWidth, displayWidth(cm) - display.sizer.offsetLeft) - padding.right\\n\\n  function add(left, top, width, bottom) {\\n    if (top < 0) { top = 0 }\\n    top = Math.round(top)\\n    bottom = Math.round(bottom)\\n    fragment.appendChild(elt(\\\"div\\\", null, \\\"CodeMirror-selected\\\", (\\\"position: absolute; left: \\\" + left + \\\"px;\\\\n                             top: \\\" + top + \\\"px; width: \\\" + (width == null ? rightSide - left : width) + \\\"px;\\\\n                             height: \\\" + (bottom - top) + \\\"px\\\")))\\n  }\\n\\n  function drawForLine(line, fromArg, toArg) {\\n    var lineObj = getLine(doc, line)\\n    var lineLen = lineObj.text.length\\n    var start, end\\n    function coords(ch, bias) {\\n      return charCoords(cm, Pos(line, ch), \\\"div\\\", lineObj, bias)\\n    }\\n\\n    iterateBidiSections(getOrder(lineObj), fromArg || 0, toArg == null ? lineLen : toArg, function (from, to, dir) {\\n      var leftPos = coords(from, \\\"left\\\"), rightPos, left, right\\n      if (from == to) {\\n        rightPos = leftPos\\n        left = right = leftPos.left\\n      } else {\\n        rightPos = coords(to - 1, \\\"right\\\")\\n        if (dir == \\\"rtl\\\") { var tmp = leftPos; leftPos = rightPos; rightPos = tmp }\\n        left = leftPos.left\\n        right = rightPos.right\\n      }\\n      if (fromArg == null && from == 0) { left = leftSide }\\n      if (rightPos.top - leftPos.top > 3) { // Different lines, draw top part\\n        add(left, leftPos.top, null, leftPos.bottom)\\n        left = leftSide\\n        if (leftPos.bottom < rightPos.top) { add(left, leftPos.bottom, null, rightPos.top) }\\n      }\\n      if (toArg == null && to == lineLen) { right = rightSide }\\n      if (!start || leftPos.top < start.top || leftPos.top == start.top && leftPos.left < start.left)\\n        { start = leftPos }\\n      if (!end || rightPos.bottom > end.bottom || rightPos.bottom == end.bottom && rightPos.right > end.right)\\n        { end = rightPos }\\n      if (left < leftSide + 1) { left = leftSide }\\n      add(left, rightPos.top, right - left, rightPos.bottom)\\n    })\\n    return {start: start, end: end}\\n  }\\n\\n  var sFrom = range.from(), sTo = range.to()\\n  if (sFrom.line == sTo.line) {\\n    drawForLine(sFrom.line, sFrom.ch, sTo.ch)\\n  } else {\\n    var fromLine = getLine(doc, sFrom.line), toLine = getLine(doc, sTo.line)\\n    var singleVLine = visualLine(fromLine) == visualLine(toLine)\\n    var leftEnd = drawForLine(sFrom.line, sFrom.ch, singleVLine ? fromLine.text.length + 1 : null).end\\n    var rightStart = drawForLine(sTo.line, singleVLine ? 0 : null, sTo.ch).start\\n    if (singleVLine) {\\n      if (leftEnd.top < rightStart.top - 2) {\\n        add(leftEnd.right, leftEnd.top, null, leftEnd.bottom)\\n        add(leftSide, rightStart.top, rightStart.left, rightStart.bottom)\\n      } else {\\n        add(leftEnd.right, leftEnd.top, rightStart.left - leftEnd.right, leftEnd.bottom)\\n      }\\n    }\\n    if (leftEnd.bottom < rightStart.top)\\n      { add(leftSide, leftEnd.bottom, null, rightStart.top) }\\n  }\\n\\n  output.appendChild(fragment)\\n}\\n\\n// Cursor-blinking\\nfunction restartBlink(cm) {\\n  if (!cm.state.focused) { return }\\n  var display = cm.display\\n  clearInterval(display.blinker)\\n  var on = true\\n  display.cursorDiv.style.visibility = \\\"\\\"\\n  if (cm.options.cursorBlinkRate > 0)\\n    { display.blinker = setInterval(function () { return display.cursorDiv.style.visibility = (on = !on) ? \\\"\\\" : \\\"hidden\\\"; },\\n      cm.options.cursorBlinkRate) }\\n  else if (cm.options.cursorBlinkRate < 0)\\n    { display.cursorDiv.style.visibility = \\\"hidden\\\" }\\n}\\n\\nfunction ensureFocus(cm) {\\n  if (!cm.state.focused) { cm.display.input.focus(); onFocus(cm) }\\n}\\n\\nfunction delayBlurEvent(cm) {\\n  cm.state.delayingBlurEvent = true\\n  setTimeout(function () { if (cm.state.delayingBlurEvent) {\\n    cm.state.delayingBlurEvent = false\\n    onBlur(cm)\\n  } }, 100)\\n}\\n\\nfunction onFocus(cm, e) {\\n  if (cm.state.delayingBlurEvent) { cm.state.delayingBlurEvent = false }\\n\\n  if (cm.options.readOnly == \\\"nocursor\\\") { return }\\n  if (!cm.state.focused) {\\n    signal(cm, \\\"focus\\\", cm, e)\\n    cm.state.focused = true\\n    addClass(cm.display.wrapper, \\\"CodeMirror-focused\\\")\\n    // This test prevents this from firing when a context\\n    // menu is closed (since the input reset would kill the\\n    // select-all detection hack)\\n    if (!cm.curOp && cm.display.selForContextMenu != cm.doc.sel) {\\n      cm.display.input.reset()\\n      if (webkit) { setTimeout(function () { return cm.display.input.reset(true); }, 20) } // Issue #1730\\n    }\\n    cm.display.input.receivedFocus()\\n  }\\n  restartBlink(cm)\\n}\\nfunction onBlur(cm, e) {\\n  if (cm.state.delayingBlurEvent) { return }\\n\\n  if (cm.state.focused) {\\n    signal(cm, \\\"blur\\\", cm, e)\\n    cm.state.focused = false\\n    rmClass(cm.display.wrapper, \\\"CodeMirror-focused\\\")\\n  }\\n  clearInterval(cm.display.blinker)\\n  setTimeout(function () { if (!cm.state.focused) { cm.display.shift = false } }, 150)\\n}\\n\\n// Re-align line numbers and gutter marks to compensate for\\n// horizontal scrolling.\\nfunction alignHorizontally(cm) {\\n  var display = cm.display, view = display.view\\n  if (!display.alignWidgets && (!display.gutters.firstChild || !cm.options.fixedGutter)) { return }\\n  var comp = compensateForHScroll(display) - display.scroller.scrollLeft + cm.doc.scrollLeft\\n  var gutterW = display.gutters.offsetWidth, left = comp + \\\"px\\\"\\n  for (var i = 0; i < view.length; i++) { if (!view[i].hidden) {\\n    if (cm.options.fixedGutter) {\\n      if (view[i].gutter)\\n        { view[i].gutter.style.left = left }\\n      if (view[i].gutterBackground)\\n        { view[i].gutterBackground.style.left = left }\\n    }\\n    var align = view[i].alignable\\n    if (align) { for (var j = 0; j < align.length; j++)\\n      { align[j].style.left = left } }\\n  } }\\n  if (cm.options.fixedGutter)\\n    { display.gutters.style.left = (comp + gutterW) + \\\"px\\\" }\\n}\\n\\n// Used to ensure that the line number gutter is still the right\\n// size for the current document size. Returns true when an update\\n// is needed.\\nfunction maybeUpdateLineNumberWidth(cm) {\\n  if (!cm.options.lineNumbers) { return false }\\n  var doc = cm.doc, last = lineNumberFor(cm.options, doc.first + doc.size - 1), display = cm.display\\n  if (last.length != display.lineNumChars) {\\n    var test = display.measure.appendChild(elt(\\\"div\\\", [elt(\\\"div\\\", last)],\\n                                               \\\"CodeMirror-linenumber CodeMirror-gutter-elt\\\"))\\n    var innerW = test.firstChild.offsetWidth, padding = test.offsetWidth - innerW\\n    display.lineGutter.style.width = \\\"\\\"\\n    display.lineNumInnerWidth = Math.max(innerW, display.lineGutter.offsetWidth - padding) + 1\\n    display.lineNumWidth = display.lineNumInnerWidth + padding\\n    display.lineNumChars = display.lineNumInnerWidth ? last.length : -1\\n    display.lineGutter.style.width = display.lineNumWidth + \\\"px\\\"\\n    updateGutterSpace(cm)\\n    return true\\n  }\\n  return false\\n}\\n\\n// Read the actual heights of the rendered lines, and update their\\n// stored heights to match.\\nfunction updateHeightsInViewport(cm) {\\n  var display = cm.display\\n  var prevBottom = display.lineDiv.offsetTop\\n  for (var i = 0; i < display.view.length; i++) {\\n    var cur = display.view[i], height = (void 0)\\n    if (cur.hidden) { continue }\\n    if (ie && ie_version < 8) {\\n      var bot = cur.node.offsetTop + cur.node.offsetHeight\\n      height = bot - prevBottom\\n      prevBottom = bot\\n    } else {\\n      var box = cur.node.getBoundingClientRect()\\n      height = box.bottom - box.top\\n    }\\n    var diff = cur.line.height - height\\n    if (height < 2) { height = textHeight(display) }\\n    if (diff > .001 || diff < -.001) {\\n      updateLineHeight(cur.line, height)\\n      updateWidgetHeight(cur.line)\\n      if (cur.rest) { for (var j = 0; j < cur.rest.length; j++)\\n        { updateWidgetHeight(cur.rest[j]) } }\\n    }\\n  }\\n}\\n\\n// Read and store the height of line widgets associated with the\\n// given line.\\nfunction updateWidgetHeight(line) {\\n  if (line.widgets) { for (var i = 0; i < line.widgets.length; ++i)\\n    { line.widgets[i].height = line.widgets[i].node.parentNode.offsetHeight } }\\n}\\n\\n// Compute the lines that are visible in a given viewport (defaults\\n// the the current scroll position). viewport may contain top,\\n// height, and ensure (see op.scrollToPos) properties.\\nfunction visibleLines(display, doc, viewport) {\\n  var top = viewport && viewport.top != null ? Math.max(0, viewport.top) : display.scroller.scrollTop\\n  top = Math.floor(top - paddingTop(display))\\n  var bottom = viewport && viewport.bottom != null ? viewport.bottom : top + display.wrapper.clientHeight\\n\\n  var from = lineAtHeight(doc, top), to = lineAtHeight(doc, bottom)\\n  // Ensure is a {from: {line, ch}, to: {line, ch}} object, and\\n  // forces those lines into the viewport (if possible).\\n  if (viewport && viewport.ensure) {\\n    var ensureFrom = viewport.ensure.from.line, ensureTo = viewport.ensure.to.line\\n    if (ensureFrom < from) {\\n      from = ensureFrom\\n      to = lineAtHeight(doc, heightAtLine(getLine(doc, ensureFrom)) + display.wrapper.clientHeight)\\n    } else if (Math.min(ensureTo, doc.lastLine()) >= to) {\\n      from = lineAtHeight(doc, heightAtLine(getLine(doc, ensureTo)) - display.wrapper.clientHeight)\\n      to = ensureTo\\n    }\\n  }\\n  return {from: from, to: Math.max(to, from + 1)}\\n}\\n\\n// Sync the scrollable area and scrollbars, ensure the viewport\\n// covers the visible area.\\nfunction setScrollTop(cm, val) {\\n  if (Math.abs(cm.doc.scrollTop - val) < 2) { return }\\n  cm.doc.scrollTop = val\\n  if (!gecko) { updateDisplaySimple(cm, {top: val}) }\\n  if (cm.display.scroller.scrollTop != val) { cm.display.scroller.scrollTop = val }\\n  cm.display.scrollbars.setScrollTop(val)\\n  if (gecko) { updateDisplaySimple(cm) }\\n  startWorker(cm, 100)\\n}\\n// Sync scroller and scrollbar, ensure the gutter elements are\\n// aligned.\\nfunction setScrollLeft(cm, val, isScroller) {\\n  if (isScroller ? val == cm.doc.scrollLeft : Math.abs(cm.doc.scrollLeft - val) < 2) { return }\\n  val = Math.min(val, cm.display.scroller.scrollWidth - cm.display.scroller.clientWidth)\\n  cm.doc.scrollLeft = val\\n  alignHorizontally(cm)\\n  if (cm.display.scroller.scrollLeft != val) { cm.display.scroller.scrollLeft = val }\\n  cm.display.scrollbars.setScrollLeft(val)\\n}\\n\\n// Since the delta values reported on mouse wheel events are\\n// unstandardized between browsers and even browser versions, and\\n// generally horribly unpredictable, this code starts by measuring\\n// the scroll effect that the first few mouse wheel events have,\\n// and, from that, detects the way it can convert deltas to pixel\\n// offsets afterwards.\\n//\\n// The reason we want to know the amount a wheel event will scroll\\n// is that it gives us a chance to update the display before the\\n// actual scrolling happens, reducing flickering.\\n\\nvar wheelSamples = 0;\\nvar wheelPixelsPerUnit = null;\\n// Fill in a browser-detected starting value on browsers where we\\n// know one. These don't have to be accurate -- the result of them\\n// being wrong would just be a slight flicker on the first wheel\\n// scroll (if it is large enough).\\nif (ie) { wheelPixelsPerUnit = -.53 }\\nelse if (gecko) { wheelPixelsPerUnit = 15 }\\nelse if (chrome) { wheelPixelsPerUnit = -.7 }\\nelse if (safari) { wheelPixelsPerUnit = -1/3 }\\n\\nfunction wheelEventDelta(e) {\\n  var dx = e.wheelDeltaX, dy = e.wheelDeltaY\\n  if (dx == null && e.detail && e.axis == e.HORIZONTAL_AXIS) { dx = e.detail }\\n  if (dy == null && e.detail && e.axis == e.VERTICAL_AXIS) { dy = e.detail }\\n  else if (dy == null) { dy = e.wheelDelta }\\n  return {x: dx, y: dy}\\n}\\nfunction wheelEventPixels(e) {\\n  var delta = wheelEventDelta(e)\\n  delta.x *= wheelPixelsPerUnit\\n  delta.y *= wheelPixelsPerUnit\\n  return delta\\n}\\n\\nfunction onScrollWheel(cm, e) {\\n  var delta = wheelEventDelta(e), dx = delta.x, dy = delta.y\\n\\n  var display = cm.display, scroll = display.scroller\\n  // Quit if there's nothing to scroll here\\n  var canScrollX = scroll.scrollWidth > scroll.clientWidth\\n  var canScrollY = scroll.scrollHeight > scroll.clientHeight\\n  if (!(dx && canScrollX || dy && canScrollY)) { return }\\n\\n  // Webkit browsers on OS X abort momentum scrolls when the target\\n  // of the scroll event is removed from the scrollable element.\\n  // This hack (see related code in patchDisplay) makes sure the\\n  // element is kept around.\\n  if (dy && mac && webkit) {\\n    outer: for (var cur = e.target, view = display.view; cur != scroll; cur = cur.parentNode) {\\n      for (var i = 0; i < view.length; i++) {\\n        if (view[i].node == cur) {\\n          cm.display.currentWheelTarget = cur\\n          break outer\\n        }\\n      }\\n    }\\n  }\\n\\n  // On some browsers, horizontal scrolling will cause redraws to\\n  // happen before the gutter has been realigned, causing it to\\n  // wriggle around in a most unseemly way. When we have an\\n  // estimated pixels/delta value, we just handle horizontal\\n  // scrolling entirely here. It'll be slightly off from native, but\\n  // better than glitching out.\\n  if (dx && !gecko && !presto && wheelPixelsPerUnit != null) {\\n    if (dy && canScrollY)\\n      { setScrollTop(cm, Math.max(0, Math.min(scroll.scrollTop + dy * wheelPixelsPerUnit, scroll.scrollHeight - scroll.clientHeight))) }\\n    setScrollLeft(cm, Math.max(0, Math.min(scroll.scrollLeft + dx * wheelPixelsPerUnit, scroll.scrollWidth - scroll.clientWidth)))\\n    // Only prevent default scrolling if vertical scrolling is\\n    // actually possible. Otherwise, it causes vertical scroll\\n    // jitter on OSX trackpads when deltaX is small and deltaY\\n    // is large (issue #3579)\\n    if (!dy || (dy && canScrollY))\\n      { e_preventDefault(e) }\\n    display.wheelStartX = null // Abort measurement, if in progress\\n    return\\n  }\\n\\n  // 'Project' the visible viewport to cover the area that is being\\n  // scrolled into view (if we know enough to estimate it).\\n  if (dy && wheelPixelsPerUnit != null) {\\n    var pixels = dy * wheelPixelsPerUnit\\n    var top = cm.doc.scrollTop, bot = top + display.wrapper.clientHeight\\n    if (pixels < 0) { top = Math.max(0, top + pixels - 50) }\\n    else { bot = Math.min(cm.doc.height, bot + pixels + 50) }\\n    updateDisplaySimple(cm, {top: top, bottom: bot})\\n  }\\n\\n  if (wheelSamples < 20) {\\n    if (display.wheelStartX == null) {\\n      display.wheelStartX = scroll.scrollLeft; display.wheelStartY = scroll.scrollTop\\n      display.wheelDX = dx; display.wheelDY = dy\\n      setTimeout(function () {\\n        if (display.wheelStartX == null) { return }\\n        var movedX = scroll.scrollLeft - display.wheelStartX\\n        var movedY = scroll.scrollTop - display.wheelStartY\\n        var sample = (movedY && display.wheelDY && movedY / display.wheelDY) ||\\n          (movedX && display.wheelDX && movedX / display.wheelDX)\\n        display.wheelStartX = display.wheelStartY = null\\n        if (!sample) { return }\\n        wheelPixelsPerUnit = (wheelPixelsPerUnit * wheelSamples + sample) / (wheelSamples + 1)\\n        ++wheelSamples\\n      }, 200)\\n    } else {\\n      display.wheelDX += dx; display.wheelDY += dy\\n    }\\n  }\\n}\\n\\n// SCROLLBARS\\n\\n// Prepare DOM reads needed to update the scrollbars. Done in one\\n// shot to minimize update/measure roundtrips.\\nfunction measureForScrollbars(cm) {\\n  var d = cm.display, gutterW = d.gutters.offsetWidth\\n  var docH = Math.round(cm.doc.height + paddingVert(cm.display))\\n  return {\\n    clientHeight: d.scroller.clientHeight,\\n    viewHeight: d.wrapper.clientHeight,\\n    scrollWidth: d.scroller.scrollWidth, clientWidth: d.scroller.clientWidth,\\n    viewWidth: d.wrapper.clientWidth,\\n    barLeft: cm.options.fixedGutter ? gutterW : 0,\\n    docHeight: docH,\\n    scrollHeight: docH + scrollGap(cm) + d.barHeight,\\n    nativeBarWidth: d.nativeBarWidth,\\n    gutterWidth: gutterW\\n  }\\n}\\n\\nvar NativeScrollbars = function(place, scroll, cm) {\\n  this.cm = cm\\n  var vert = this.vert = elt(\\\"div\\\", [elt(\\\"div\\\", null, null, \\\"min-width: 1px\\\")], \\\"CodeMirror-vscrollbar\\\")\\n  var horiz = this.horiz = elt(\\\"div\\\", [elt(\\\"div\\\", null, null, \\\"height: 100%; min-height: 1px\\\")], \\\"CodeMirror-hscrollbar\\\")\\n  place(vert); place(horiz)\\n\\n  on(vert, \\\"scroll\\\", function () {\\n    if (vert.clientHeight) { scroll(vert.scrollTop, \\\"vertical\\\") }\\n  })\\n  on(horiz, \\\"scroll\\\", function () {\\n    if (horiz.clientWidth) { scroll(horiz.scrollLeft, \\\"horizontal\\\") }\\n  })\\n\\n  this.checkedZeroWidth = false\\n  // Need to set a minimum width to see the scrollbar on IE7 (but must not set it on IE8).\\n  if (ie && ie_version < 8) { this.horiz.style.minHeight = this.vert.style.minWidth = \\\"18px\\\" }\\n};\\n\\nNativeScrollbars.prototype.update = function (measure) {\\n  var needsH = measure.scrollWidth > measure.clientWidth + 1\\n  var needsV = measure.scrollHeight > measure.clientHeight + 1\\n  var sWidth = measure.nativeBarWidth\\n\\n  if (needsV) {\\n    this.vert.style.display = \\\"block\\\"\\n    this.vert.style.bottom = needsH ? sWidth + \\\"px\\\" : \\\"0\\\"\\n    var totalHeight = measure.viewHeight - (needsH ? sWidth : 0)\\n    // A bug in IE8 can cause this value to be negative, so guard it.\\n    this.vert.firstChild.style.height =\\n      Math.max(0, measure.scrollHeight - measure.clientHeight + totalHeight) + \\\"px\\\"\\n  } else {\\n    this.vert.style.display = \\\"\\\"\\n    this.vert.firstChild.style.height = \\\"0\\\"\\n  }\\n\\n  if (needsH) {\\n    this.horiz.style.display = \\\"block\\\"\\n    this.horiz.style.right = needsV ? sWidth + \\\"px\\\" : \\\"0\\\"\\n    this.horiz.style.left = measure.barLeft + \\\"px\\\"\\n    var totalWidth = measure.viewWidth - measure.barLeft - (needsV ? sWidth : 0)\\n    this.horiz.firstChild.style.width =\\n      Math.max(0, measure.scrollWidth - measure.clientWidth + totalWidth) + \\\"px\\\"\\n  } else {\\n    this.horiz.style.display = \\\"\\\"\\n    this.horiz.firstChild.style.width = \\\"0\\\"\\n  }\\n\\n  if (!this.checkedZeroWidth && measure.clientHeight > 0) {\\n    if (sWidth == 0) { this.zeroWidthHack() }\\n    this.checkedZeroWidth = true\\n  }\\n\\n  return {right: needsV ? sWidth : 0, bottom: needsH ? sWidth : 0}\\n};\\n\\nNativeScrollbars.prototype.setScrollLeft = function (pos) {\\n  if (this.horiz.scrollLeft != pos) { this.horiz.scrollLeft = pos }\\n  if (this.disableHoriz) { this.enableZeroWidthBar(this.horiz, this.disableHoriz) }\\n};\\n\\nNativeScrollbars.prototype.setScrollTop = function (pos) {\\n  if (this.vert.scrollTop != pos) { this.vert.scrollTop = pos }\\n  if (this.disableVert) { this.enableZeroWidthBar(this.vert, this.disableVert) }\\n};\\n\\nNativeScrollbars.prototype.zeroWidthHack = function () {\\n  var w = mac && !mac_geMountainLion ? \\\"12px\\\" : \\\"18px\\\"\\n  this.horiz.style.height = this.vert.style.width = w\\n  this.horiz.style.pointerEvents = this.vert.style.pointerEvents = \\\"none\\\"\\n  this.disableHoriz = new Delayed\\n  this.disableVert = new Delayed\\n};\\n\\nNativeScrollbars.prototype.enableZeroWidthBar = function (bar, delay) {\\n  bar.style.pointerEvents = \\\"auto\\\"\\n  function maybeDisable() {\\n    // To find out whether the scrollbar is still visible, we\\n    // check whether the element under the pixel in the bottom\\n    // left corner of the scrollbar box is the scrollbar box\\n    // itself (when the bar is still visible) or its filler child\\n    // (when the bar is hidden). If it is still visible, we keep\\n    // it enabled, if it's hidden, we disable pointer events.\\n    var box = bar.getBoundingClientRect()\\n    var elt = document.elementFromPoint(box.left + 1, box.bottom - 1)\\n    if (elt != bar) { bar.style.pointerEvents = \\\"none\\\" }\\n    else { delay.set(1000, maybeDisable) }\\n  }\\n  delay.set(1000, maybeDisable)\\n};\\n\\nNativeScrollbars.prototype.clear = function () {\\n  var parent = this.horiz.parentNode\\n  parent.removeChild(this.horiz)\\n  parent.removeChild(this.vert)\\n};\\n\\nvar NullScrollbars = function () {};\\n\\nNullScrollbars.prototype.update = function () { return {bottom: 0, right: 0} };\\nNullScrollbars.prototype.setScrollLeft = function () {};\\nNullScrollbars.prototype.setScrollTop = function () {};\\nNullScrollbars.prototype.clear = function () {};\\n\\nfunction updateScrollbars(cm, measure) {\\n  if (!measure) { measure = measureForScrollbars(cm) }\\n  var startWidth = cm.display.barWidth, startHeight = cm.display.barHeight\\n  updateScrollbarsInner(cm, measure)\\n  for (var i = 0; i < 4 && startWidth != cm.display.barWidth || startHeight != cm.display.barHeight; i++) {\\n    if (startWidth != cm.display.barWidth && cm.options.lineWrapping)\\n      { updateHeightsInViewport(cm) }\\n    updateScrollbarsInner(cm, measureForScrollbars(cm))\\n    startWidth = cm.display.barWidth; startHeight = cm.display.barHeight\\n  }\\n}\\n\\n// Re-synchronize the fake scrollbars with the actual size of the\\n// content.\\nfunction updateScrollbarsInner(cm, measure) {\\n  var d = cm.display\\n  var sizes = d.scrollbars.update(measure)\\n\\n  d.sizer.style.paddingRight = (d.barWidth = sizes.right) + \\\"px\\\"\\n  d.sizer.style.paddingBottom = (d.barHeight = sizes.bottom) + \\\"px\\\"\\n  d.heightForcer.style.borderBottom = sizes.bottom + \\\"px solid transparent\\\"\\n\\n  if (sizes.right && sizes.bottom) {\\n    d.scrollbarFiller.style.display = \\\"block\\\"\\n    d.scrollbarFiller.style.height = sizes.bottom + \\\"px\\\"\\n    d.scrollbarFiller.style.width = sizes.right + \\\"px\\\"\\n  } else { d.scrollbarFiller.style.display = \\\"\\\" }\\n  if (sizes.bottom && cm.options.coverGutterNextToScrollbar && cm.options.fixedGutter) {\\n    d.gutterFiller.style.display = \\\"block\\\"\\n    d.gutterFiller.style.height = sizes.bottom + \\\"px\\\"\\n    d.gutterFiller.style.width = measure.gutterWidth + \\\"px\\\"\\n  } else { d.gutterFiller.style.display = \\\"\\\" }\\n}\\n\\nvar scrollbarModel = {\\\"native\\\": NativeScrollbars, \\\"null\\\": NullScrollbars}\\n\\nfunction initScrollbars(cm) {\\n  if (cm.display.scrollbars) {\\n    cm.display.scrollbars.clear()\\n    if (cm.display.scrollbars.addClass)\\n      { rmClass(cm.display.wrapper, cm.display.scrollbars.addClass) }\\n  }\\n\\n  cm.display.scrollbars = new scrollbarModel[cm.options.scrollbarStyle](function (node) {\\n    cm.display.wrapper.insertBefore(node, cm.display.scrollbarFiller)\\n    // Prevent clicks in the scrollbars from killing focus\\n    on(node, \\\"mousedown\\\", function () {\\n      if (cm.state.focused) { setTimeout(function () { return cm.display.input.focus(); }, 0) }\\n    })\\n    node.setAttribute(\\\"cm-not-content\\\", \\\"true\\\")\\n  }, function (pos, axis) {\\n    if (axis == \\\"horizontal\\\") { setScrollLeft(cm, pos) }\\n    else { setScrollTop(cm, pos) }\\n  }, cm)\\n  if (cm.display.scrollbars.addClass)\\n    { addClass(cm.display.wrapper, cm.display.scrollbars.addClass) }\\n}\\n\\n// SCROLLING THINGS INTO VIEW\\n\\n// If an editor sits on the top or bottom of the window, partially\\n// scrolled out of view, this ensures that the cursor is visible.\\nfunction maybeScrollWindow(cm, coords) {\\n  if (signalDOMEvent(cm, \\\"scrollCursorIntoView\\\")) { return }\\n\\n  var display = cm.display, box = display.sizer.getBoundingClientRect(), doScroll = null\\n  if (coords.top + box.top < 0) { doScroll = true }\\n  else if (coords.bottom + box.top > (window.innerHeight || document.documentElement.clientHeight)) { doScroll = false }\\n  if (doScroll != null && !phantom) {\\n    var scrollNode = elt(\\\"div\\\", \\\"\\\\u200b\\\", null, (\\\"position: absolute;\\\\n                         top: \\\" + (coords.top - display.viewOffset - paddingTop(cm.display)) + \\\"px;\\\\n                         height: \\\" + (coords.bottom - coords.top + scrollGap(cm) + display.barHeight) + \\\"px;\\\\n                         left: \\\" + (coords.left) + \\\"px; width: 2px;\\\"))\\n    cm.display.lineSpace.appendChild(scrollNode)\\n    scrollNode.scrollIntoView(doScroll)\\n    cm.display.lineSpace.removeChild(scrollNode)\\n  }\\n}\\n\\n// Scroll a given position into view (immediately), verifying that\\n// it actually became visible (as line heights are accurately\\n// measured, the position of something may 'drift' during drawing).\\nfunction scrollPosIntoView(cm, pos, end, margin) {\\n  if (margin == null) { margin = 0 }\\n  var coords\\n  for (var limit = 0; limit < 5; limit++) {\\n    var changed = false\\n    coords = cursorCoords(cm, pos)\\n    var endCoords = !end || end == pos ? coords : cursorCoords(cm, end)\\n    var scrollPos = calculateScrollPos(cm, Math.min(coords.left, endCoords.left),\\n                                       Math.min(coords.top, endCoords.top) - margin,\\n                                       Math.max(coords.left, endCoords.left),\\n                                       Math.max(coords.bottom, endCoords.bottom) + margin)\\n    var startTop = cm.doc.scrollTop, startLeft = cm.doc.scrollLeft\\n    if (scrollPos.scrollTop != null) {\\n      setScrollTop(cm, scrollPos.scrollTop)\\n      if (Math.abs(cm.doc.scrollTop - startTop) > 1) { changed = true }\\n    }\\n    if (scrollPos.scrollLeft != null) {\\n      setScrollLeft(cm, scrollPos.scrollLeft)\\n      if (Math.abs(cm.doc.scrollLeft - startLeft) > 1) { changed = true }\\n    }\\n    if (!changed) { break }\\n  }\\n  return coords\\n}\\n\\n// Scroll a given set of coordinates into view (immediately).\\nfunction scrollIntoView(cm, x1, y1, x2, y2) {\\n  var scrollPos = calculateScrollPos(cm, x1, y1, x2, y2)\\n  if (scrollPos.scrollTop != null) { setScrollTop(cm, scrollPos.scrollTop) }\\n  if (scrollPos.scrollLeft != null) { setScrollLeft(cm, scrollPos.scrollLeft) }\\n}\\n\\n// Calculate a new scroll position needed to scroll the given\\n// rectangle into view. Returns an object with scrollTop and\\n// scrollLeft properties. When these are undefined, the\\n// vertical/horizontal position does not need to be adjusted.\\nfunction calculateScrollPos(cm, x1, y1, x2, y2) {\\n  var display = cm.display, snapMargin = textHeight(cm.display)\\n  if (y1 < 0) { y1 = 0 }\\n  var screentop = cm.curOp && cm.curOp.scrollTop != null ? cm.curOp.scrollTop : display.scroller.scrollTop\\n  var screen = displayHeight(cm), result = {}\\n  if (y2 - y1 > screen) { y2 = y1 + screen }\\n  var docBottom = cm.doc.height + paddingVert(display)\\n  var atTop = y1 < snapMargin, atBottom = y2 > docBottom - snapMargin\\n  if (y1 < screentop) {\\n    result.scrollTop = atTop ? 0 : y1\\n  } else if (y2 > screentop + screen) {\\n    var newTop = Math.min(y1, (atBottom ? docBottom : y2) - screen)\\n    if (newTop != screentop) { result.scrollTop = newTop }\\n  }\\n\\n  var screenleft = cm.curOp && cm.curOp.scrollLeft != null ? cm.curOp.scrollLeft : display.scroller.scrollLeft\\n  var screenw = displayWidth(cm) - (cm.options.fixedGutter ? display.gutters.offsetWidth : 0)\\n  var tooWide = x2 - x1 > screenw\\n  if (tooWide) { x2 = x1 + screenw }\\n  if (x1 < 10)\\n    { result.scrollLeft = 0 }\\n  else if (x1 < screenleft)\\n    { result.scrollLeft = Math.max(0, x1 - (tooWide ? 0 : 10)) }\\n  else if (x2 > screenw + screenleft - 3)\\n    { result.scrollLeft = x2 + (tooWide ? 0 : 10) - screenw }\\n  return result\\n}\\n\\n// Store a relative adjustment to the scroll position in the current\\n// operation (to be applied when the operation finishes).\\nfunction addToScrollPos(cm, left, top) {\\n  if (left != null || top != null) { resolveScrollToPos(cm) }\\n  if (left != null)\\n    { cm.curOp.scrollLeft = (cm.curOp.scrollLeft == null ? cm.doc.scrollLeft : cm.curOp.scrollLeft) + left }\\n  if (top != null)\\n    { cm.curOp.scrollTop = (cm.curOp.scrollTop == null ? cm.doc.scrollTop : cm.curOp.scrollTop) + top }\\n}\\n\\n// Make sure that at the end of the operation the current cursor is\\n// shown.\\nfunction ensureCursorVisible(cm) {\\n  resolveScrollToPos(cm)\\n  var cur = cm.getCursor(), from = cur, to = cur\\n  if (!cm.options.lineWrapping) {\\n    from = cur.ch ? Pos(cur.line, cur.ch - 1) : cur\\n    to = Pos(cur.line, cur.ch + 1)\\n  }\\n  cm.curOp.scrollToPos = {from: from, to: to, margin: cm.options.cursorScrollMargin, isCursor: true}\\n}\\n\\n// When an operation has its scrollToPos property set, and another\\n// scroll action is applied before the end of the operation, this\\n// 'simulates' scrolling that position into view in a cheap way, so\\n// that the effect of intermediate scroll commands is not ignored.\\nfunction resolveScrollToPos(cm) {\\n  var range = cm.curOp.scrollToPos\\n  if (range) {\\n    cm.curOp.scrollToPos = null\\n    var from = estimateCoords(cm, range.from), to = estimateCoords(cm, range.to)\\n    var sPos = calculateScrollPos(cm, Math.min(from.left, to.left),\\n                                  Math.min(from.top, to.top) - range.margin,\\n                                  Math.max(from.right, to.right),\\n                                  Math.max(from.bottom, to.bottom) + range.margin)\\n    cm.scrollTo(sPos.scrollLeft, sPos.scrollTop)\\n  }\\n}\\n\\n// Operations are used to wrap a series of changes to the editor\\n// state in such a way that each change won't have to update the\\n// cursor and display (which would be awkward, slow, and\\n// error-prone). Instead, display updates are batched and then all\\n// combined and executed at once.\\n\\nvar nextOpId = 0\\n// Start a new operation.\\nfunction startOperation(cm) {\\n  cm.curOp = {\\n    cm: cm,\\n    viewChanged: false,      // Flag that indicates that lines might need to be redrawn\\n    startHeight: cm.doc.height, // Used to detect need to update scrollbar\\n    forceUpdate: false,      // Used to force a redraw\\n    updateInput: null,       // Whether to reset the input textarea\\n    typing: false,           // Whether this reset should be careful to leave existing text (for compositing)\\n    changeObjs: null,        // Accumulated changes, for firing change events\\n    cursorActivityHandlers: null, // Set of handlers to fire cursorActivity on\\n    cursorActivityCalled: 0, // Tracks which cursorActivity handlers have been called already\\n    selectionChanged: false, // Whether the selection needs to be redrawn\\n    updateMaxLine: false,    // Set when the widest line needs to be determined anew\\n    scrollLeft: null, scrollTop: null, // Intermediate scroll position, not pushed to DOM yet\\n    scrollToPos: null,       // Used to scroll to a specific position\\n    focus: false,\\n    id: ++nextOpId           // Unique ID\\n  }\\n  pushOperation(cm.curOp)\\n}\\n\\n// Finish an operation, updating the display and signalling delayed events\\nfunction endOperation(cm) {\\n  var op = cm.curOp\\n  finishOperation(op, function (group) {\\n    for (var i = 0; i < group.ops.length; i++)\\n      { group.ops[i].cm.curOp = null }\\n    endOperations(group)\\n  })\\n}\\n\\n// The DOM updates done when an operation finishes are batched so\\n// that the minimum number of relayouts are required.\\nfunction endOperations(group) {\\n  var ops = group.ops\\n  for (var i = 0; i < ops.length; i++) // Read DOM\\n    { endOperation_R1(ops[i]) }\\n  for (var i$1 = 0; i$1 < ops.length; i$1++) // Write DOM (maybe)\\n    { endOperation_W1(ops[i$1]) }\\n  for (var i$2 = 0; i$2 < ops.length; i$2++) // Read DOM\\n    { endOperation_R2(ops[i$2]) }\\n  for (var i$3 = 0; i$3 < ops.length; i$3++) // Write DOM (maybe)\\n    { endOperation_W2(ops[i$3]) }\\n  for (var i$4 = 0; i$4 < ops.length; i$4++) // Read DOM\\n    { endOperation_finish(ops[i$4]) }\\n}\\n\\nfunction endOperation_R1(op) {\\n  var cm = op.cm, display = cm.display\\n  maybeClipScrollbars(cm)\\n  if (op.updateMaxLine) { findMaxLine(cm) }\\n\\n  op.mustUpdate = op.viewChanged || op.forceUpdate || op.scrollTop != null ||\\n    op.scrollToPos && (op.scrollToPos.from.line < display.viewFrom ||\\n                       op.scrollToPos.to.line >= display.viewTo) ||\\n    display.maxLineChanged && cm.options.lineWrapping\\n  op.update = op.mustUpdate &&\\n    new DisplayUpdate(cm, op.mustUpdate && {top: op.scrollTop, ensure: op.scrollToPos}, op.forceUpdate)\\n}\\n\\nfunction endOperation_W1(op) {\\n  op.updatedDisplay = op.mustUpdate && updateDisplayIfNeeded(op.cm, op.update)\\n}\\n\\nfunction endOperation_R2(op) {\\n  var cm = op.cm, display = cm.display\\n  if (op.updatedDisplay) { updateHeightsInViewport(cm) }\\n\\n  op.barMeasure = measureForScrollbars(cm)\\n\\n  // If the max line changed since it was last measured, measure it,\\n  // and ensure the document's width matches it.\\n  // updateDisplay_W2 will use these properties to do the actual resizing\\n  if (display.maxLineChanged && !cm.options.lineWrapping) {\\n    op.adjustWidthTo = measureChar(cm, display.maxLine, display.maxLine.text.length).left + 3\\n    cm.display.sizerWidth = op.adjustWidthTo\\n    op.barMeasure.scrollWidth =\\n      Math.max(display.scroller.clientWidth, display.sizer.offsetLeft + op.adjustWidthTo + scrollGap(cm) + cm.display.barWidth)\\n    op.maxScrollLeft = Math.max(0, display.sizer.offsetLeft + op.adjustWidthTo - displayWidth(cm))\\n  }\\n\\n  if (op.updatedDisplay || op.selectionChanged)\\n    { op.preparedSelection = display.input.prepareSelection(op.focus) }\\n}\\n\\nfunction endOperation_W2(op) {\\n  var cm = op.cm\\n\\n  if (op.adjustWidthTo != null) {\\n    cm.display.sizer.style.minWidth = op.adjustWidthTo + \\\"px\\\"\\n    if (op.maxScrollLeft < cm.doc.scrollLeft)\\n      { setScrollLeft(cm, Math.min(cm.display.scroller.scrollLeft, op.maxScrollLeft), true) }\\n    cm.display.maxLineChanged = false\\n  }\\n\\n  var takeFocus = op.focus && op.focus == activeElt() && (!document.hasFocus || document.hasFocus())\\n  if (op.preparedSelection)\\n    { cm.display.input.showSelection(op.preparedSelection, takeFocus) }\\n  if (op.updatedDisplay || op.startHeight != cm.doc.height)\\n    { updateScrollbars(cm, op.barMeasure) }\\n  if (op.updatedDisplay)\\n    { setDocumentHeight(cm, op.barMeasure) }\\n\\n  if (op.selectionChanged) { restartBlink(cm) }\\n\\n  if (cm.state.focused && op.updateInput)\\n    { cm.display.input.reset(op.typing) }\\n  if (takeFocus) { ensureFocus(op.cm) }\\n}\\n\\nfunction endOperation_finish(op) {\\n  var cm = op.cm, display = cm.display, doc = cm.doc\\n\\n  if (op.updatedDisplay) { postUpdateDisplay(cm, op.update) }\\n\\n  // Abort mouse wheel delta measurement, when scrolling explicitly\\n  if (display.wheelStartX != null && (op.scrollTop != null || op.scrollLeft != null || op.scrollToPos))\\n    { display.wheelStartX = display.wheelStartY = null }\\n\\n  // Propagate the scroll position to the actual DOM scroller\\n  if (op.scrollTop != null && (display.scroller.scrollTop != op.scrollTop || op.forceScroll)) {\\n    doc.scrollTop = Math.max(0, Math.min(display.scroller.scrollHeight - display.scroller.clientHeight, op.scrollTop))\\n    display.scrollbars.setScrollTop(doc.scrollTop)\\n    display.scroller.scrollTop = doc.scrollTop\\n  }\\n  if (op.scrollLeft != null && (display.scroller.scrollLeft != op.scrollLeft || op.forceScroll)) {\\n    doc.scrollLeft = Math.max(0, Math.min(display.scroller.scrollWidth - display.scroller.clientWidth, op.scrollLeft))\\n    display.scrollbars.setScrollLeft(doc.scrollLeft)\\n    display.scroller.scrollLeft = doc.scrollLeft\\n    alignHorizontally(cm)\\n  }\\n  // If we need to scroll a specific position into view, do so.\\n  if (op.scrollToPos) {\\n    var coords = scrollPosIntoView(cm, clipPos(doc, op.scrollToPos.from),\\n                                   clipPos(doc, op.scrollToPos.to), op.scrollToPos.margin)\\n    if (op.scrollToPos.isCursor && cm.state.focused) { maybeScrollWindow(cm, coords) }\\n  }\\n\\n  // Fire events for markers that are hidden/unidden by editing or\\n  // undoing\\n  var hidden = op.maybeHiddenMarkers, unhidden = op.maybeUnhiddenMarkers\\n  if (hidden) { for (var i = 0; i < hidden.length; ++i)\\n    { if (!hidden[i].lines.length) { signal(hidden[i], \\\"hide\\\") } } }\\n  if (unhidden) { for (var i$1 = 0; i$1 < unhidden.length; ++i$1)\\n    { if (unhidden[i$1].lines.length) { signal(unhidden[i$1], \\\"unhide\\\") } } }\\n\\n  if (display.wrapper.offsetHeight)\\n    { doc.scrollTop = cm.display.scroller.scrollTop }\\n\\n  // Fire change events, and delayed event handlers\\n  if (op.changeObjs)\\n    { signal(cm, \\\"changes\\\", cm, op.changeObjs) }\\n  if (op.update)\\n    { op.update.finish() }\\n}\\n\\n// Run the given function in an operation\\nfunction runInOp(cm, f) {\\n  if (cm.curOp) { return f() }\\n  startOperation(cm)\\n  try { return f() }\\n  finally { endOperation(cm) }\\n}\\n// Wraps a function in an operation. Returns the wrapped function.\\nfunction operation(cm, f) {\\n  return function() {\\n    if (cm.curOp) { return f.apply(cm, arguments) }\\n    startOperation(cm)\\n    try { return f.apply(cm, arguments) }\\n    finally { endOperation(cm) }\\n  }\\n}\\n// Used to add methods to editor and doc instances, wrapping them in\\n// operations.\\nfunction methodOp(f) {\\n  return function() {\\n    if (this.curOp) { return f.apply(this, arguments) }\\n    startOperation(this)\\n    try { return f.apply(this, arguments) }\\n    finally { endOperation(this) }\\n  }\\n}\\nfunction docMethodOp(f) {\\n  return function() {\\n    var cm = this.cm\\n    if (!cm || cm.curOp) { return f.apply(this, arguments) }\\n    startOperation(cm)\\n    try { return f.apply(this, arguments) }\\n    finally { endOperation(cm) }\\n  }\\n}\\n\\n// Updates the display.view data structure for a given change to the\\n// document. From and to are in pre-change coordinates. Lendiff is\\n// the amount of lines added or subtracted by the change. This is\\n// used for changes that span multiple lines, or change the way\\n// lines are divided into visual lines. regLineChange (below)\\n// registers single-line changes.\\nfunction regChange(cm, from, to, lendiff) {\\n  if (from == null) { from = cm.doc.first }\\n  if (to == null) { to = cm.doc.first + cm.doc.size }\\n  if (!lendiff) { lendiff = 0 }\\n\\n  var display = cm.display\\n  if (lendiff && to < display.viewTo &&\\n      (display.updateLineNumbers == null || display.updateLineNumbers > from))\\n    { display.updateLineNumbers = from }\\n\\n  cm.curOp.viewChanged = true\\n\\n  if (from >= display.viewTo) { // Change after\\n    if (sawCollapsedSpans && visualLineNo(cm.doc, from) < display.viewTo)\\n      { resetView(cm) }\\n  } else if (to <= display.viewFrom) { // Change before\\n    if (sawCollapsedSpans && visualLineEndNo(cm.doc, to + lendiff) > display.viewFrom) {\\n      resetView(cm)\\n    } else {\\n      display.viewFrom += lendiff\\n      display.viewTo += lendiff\\n    }\\n  } else if (from <= display.viewFrom && to >= display.viewTo) { // Full overlap\\n    resetView(cm)\\n  } else if (from <= display.viewFrom) { // Top overlap\\n    var cut = viewCuttingPoint(cm, to, to + lendiff, 1)\\n    if (cut) {\\n      display.view = display.view.slice(cut.index)\\n      display.viewFrom = cut.lineN\\n      display.viewTo += lendiff\\n    } else {\\n      resetView(cm)\\n    }\\n  } else if (to >= display.viewTo) { // Bottom overlap\\n    var cut$1 = viewCuttingPoint(cm, from, from, -1)\\n    if (cut$1) {\\n      display.view = display.view.slice(0, cut$1.index)\\n      display.viewTo = cut$1.lineN\\n    } else {\\n      resetView(cm)\\n    }\\n  } else { // Gap in the middle\\n    var cutTop = viewCuttingPoint(cm, from, from, -1)\\n    var cutBot = viewCuttingPoint(cm, to, to + lendiff, 1)\\n    if (cutTop && cutBot) {\\n      display.view = display.view.slice(0, cutTop.index)\\n        .concat(buildViewArray(cm, cutTop.lineN, cutBot.lineN))\\n        .concat(display.view.slice(cutBot.index))\\n      display.viewTo += lendiff\\n    } else {\\n      resetView(cm)\\n    }\\n  }\\n\\n  var ext = display.externalMeasured\\n  if (ext) {\\n    if (to < ext.lineN)\\n      { ext.lineN += lendiff }\\n    else if (from < ext.lineN + ext.size)\\n      { display.externalMeasured = null }\\n  }\\n}\\n\\n// Register a change to a single line. Type must be one of \\\"text\\\",\\n// \\\"gutter\\\", \\\"class\\\", \\\"widget\\\"\\nfunction regLineChange(cm, line, type) {\\n  cm.curOp.viewChanged = true\\n  var display = cm.display, ext = cm.display.externalMeasured\\n  if (ext && line >= ext.lineN && line < ext.lineN + ext.size)\\n    { display.externalMeasured = null }\\n\\n  if (line < display.viewFrom || line >= display.viewTo) { return }\\n  var lineView = display.view[findViewIndex(cm, line)]\\n  if (lineView.node == null) { return }\\n  var arr = lineView.changes || (lineView.changes = [])\\n  if (indexOf(arr, type) == -1) { arr.push(type) }\\n}\\n\\n// Clear the view.\\nfunction resetView(cm) {\\n  cm.display.viewFrom = cm.display.viewTo = cm.doc.first\\n  cm.display.view = []\\n  cm.display.viewOffset = 0\\n}\\n\\nfunction viewCuttingPoint(cm, oldN, newN, dir) {\\n  var index = findViewIndex(cm, oldN), diff, view = cm.display.view\\n  if (!sawCollapsedSpans || newN == cm.doc.first + cm.doc.size)\\n    { return {index: index, lineN: newN} }\\n  var n = cm.display.viewFrom\\n  for (var i = 0; i < index; i++)\\n    { n += view[i].size }\\n  if (n != oldN) {\\n    if (dir > 0) {\\n      if (index == view.length - 1) { return null }\\n      diff = (n + view[index].size) - oldN\\n      index++\\n    } else {\\n      diff = n - oldN\\n    }\\n    oldN += diff; newN += diff\\n  }\\n  while (visualLineNo(cm.doc, newN) != newN) {\\n    if (index == (dir < 0 ? 0 : view.length - 1)) { return null }\\n    newN += dir * view[index - (dir < 0 ? 1 : 0)].size\\n    index += dir\\n  }\\n  return {index: index, lineN: newN}\\n}\\n\\n// Force the view to cover a given range, adding empty view element\\n// or clipping off existing ones as needed.\\nfunction adjustView(cm, from, to) {\\n  var display = cm.display, view = display.view\\n  if (view.length == 0 || from >= display.viewTo || to <= display.viewFrom) {\\n    display.view = buildViewArray(cm, from, to)\\n    display.viewFrom = from\\n  } else {\\n    if (display.viewFrom > from)\\n      { display.view = buildViewArray(cm, from, display.viewFrom).concat(display.view) }\\n    else if (display.viewFrom < from)\\n      { display.view = display.view.slice(findViewIndex(cm, from)) }\\n    display.viewFrom = from\\n    if (display.viewTo < to)\\n      { display.view = display.view.concat(buildViewArray(cm, display.viewTo, to)) }\\n    else if (display.viewTo > to)\\n      { display.view = display.view.slice(0, findViewIndex(cm, to)) }\\n  }\\n  display.viewTo = to\\n}\\n\\n// Count the number of lines in the view whose DOM representation is\\n// out of date (or nonexistent).\\nfunction countDirtyView(cm) {\\n  var view = cm.display.view, dirty = 0\\n  for (var i = 0; i < view.length; i++) {\\n    var lineView = view[i]\\n    if (!lineView.hidden && (!lineView.node || lineView.changes)) { ++dirty }\\n  }\\n  return dirty\\n}\\n\\n// HIGHLIGHT WORKER\\n\\nfunction startWorker(cm, time) {\\n  if (cm.doc.mode.startState && cm.doc.frontier < cm.display.viewTo)\\n    { cm.state.highlight.set(time, bind(highlightWorker, cm)) }\\n}\\n\\nfunction highlightWorker(cm) {\\n  var doc = cm.doc\\n  if (doc.frontier < doc.first) { doc.frontier = doc.first }\\n  if (doc.frontier >= cm.display.viewTo) { return }\\n  var end = +new Date + cm.options.workTime\\n  var state = copyState(doc.mode, getStateBefore(cm, doc.frontier))\\n  var changedLines = []\\n\\n  doc.iter(doc.frontier, Math.min(doc.first + doc.size, cm.display.viewTo + 500), function (line) {\\n    if (doc.frontier >= cm.display.viewFrom) { // Visible\\n      var oldStyles = line.styles, tooLong = line.text.length > cm.options.maxHighlightLength\\n      var highlighted = highlightLine(cm, line, tooLong ? copyState(doc.mode, state) : state, true)\\n      line.styles = highlighted.styles\\n      var oldCls = line.styleClasses, newCls = highlighted.classes\\n      if (newCls) { line.styleClasses = newCls }\\n      else if (oldCls) { line.styleClasses = null }\\n      var ischange = !oldStyles || oldStyles.length != line.styles.length ||\\n        oldCls != newCls && (!oldCls || !newCls || oldCls.bgClass != newCls.bgClass || oldCls.textClass != newCls.textClass)\\n      for (var i = 0; !ischange && i < oldStyles.length; ++i) { ischange = oldStyles[i] != line.styles[i] }\\n      if (ischange) { changedLines.push(doc.frontier) }\\n      line.stateAfter = tooLong ? state : copyState(doc.mode, state)\\n    } else {\\n      if (line.text.length <= cm.options.maxHighlightLength)\\n        { processLine(cm, line.text, state) }\\n      line.stateAfter = doc.frontier % 5 == 0 ? copyState(doc.mode, state) : null\\n    }\\n    ++doc.frontier\\n    if (+new Date > end) {\\n      startWorker(cm, cm.options.workDelay)\\n      return true\\n    }\\n  })\\n  if (changedLines.length) { runInOp(cm, function () {\\n    for (var i = 0; i < changedLines.length; i++)\\n      { regLineChange(cm, changedLines[i], \\\"text\\\") }\\n  }) }\\n}\\n\\n// DISPLAY DRAWING\\n\\nvar DisplayUpdate = function(cm, viewport, force) {\\n  var display = cm.display\\n\\n  this.viewport = viewport\\n  // Store some values that we'll need later (but don't want to force a relayout for)\\n  this.visible = visibleLines(display, cm.doc, viewport)\\n  this.editorIsHidden = !display.wrapper.offsetWidth\\n  this.wrapperHeight = display.wrapper.clientHeight\\n  this.wrapperWidth = display.wrapper.clientWidth\\n  this.oldDisplayWidth = displayWidth(cm)\\n  this.force = force\\n  this.dims = getDimensions(cm)\\n  this.events = []\\n};\\n\\nDisplayUpdate.prototype.signal = function (emitter, type) {\\n  if (hasHandler(emitter, type))\\n    { this.events.push(arguments) }\\n};\\nDisplayUpdate.prototype.finish = function () {\\n    var this$1 = this;\\n\\n  for (var i = 0; i < this.events.length; i++)\\n    { signal.apply(null, this$1.events[i]) }\\n};\\n\\nfunction maybeClipScrollbars(cm) {\\n  var display = cm.display\\n  if (!display.scrollbarsClipped && display.scroller.offsetWidth) {\\n    display.nativeBarWidth = display.scroller.offsetWidth - display.scroller.clientWidth\\n    display.heightForcer.style.height = scrollGap(cm) + \\\"px\\\"\\n    display.sizer.style.marginBottom = -display.nativeBarWidth + \\\"px\\\"\\n    display.sizer.style.borderRightWidth = scrollGap(cm) + \\\"px\\\"\\n    display.scrollbarsClipped = true\\n  }\\n}\\n\\n// Does the actual updating of the line display. Bails out\\n// (returning false) when there is nothing to be done and forced is\\n// false.\\nfunction updateDisplayIfNeeded(cm, update) {\\n  var display = cm.display, doc = cm.doc\\n\\n  if (update.editorIsHidden) {\\n    resetView(cm)\\n    return false\\n  }\\n\\n  // Bail out if the visible area is already rendered and nothing changed.\\n  if (!update.force &&\\n      update.visible.from >= display.viewFrom && update.visible.to <= display.viewTo &&\\n      (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo) &&\\n      display.renderedView == display.view && countDirtyView(cm) == 0)\\n    { return false }\\n\\n  if (maybeUpdateLineNumberWidth(cm)) {\\n    resetView(cm)\\n    update.dims = getDimensions(cm)\\n  }\\n\\n  // Compute a suitable new viewport (from & to)\\n  var end = doc.first + doc.size\\n  var from = Math.max(update.visible.from - cm.options.viewportMargin, doc.first)\\n  var to = Math.min(end, update.visible.to + cm.options.viewportMargin)\\n  if (display.viewFrom < from && from - display.viewFrom < 20) { from = Math.max(doc.first, display.viewFrom) }\\n  if (display.viewTo > to && display.viewTo - to < 20) { to = Math.min(end, display.viewTo) }\\n  if (sawCollapsedSpans) {\\n    from = visualLineNo(cm.doc, from)\\n    to = visualLineEndNo(cm.doc, to)\\n  }\\n\\n  var different = from != display.viewFrom || to != display.viewTo ||\\n    display.lastWrapHeight != update.wrapperHeight || display.lastWrapWidth != update.wrapperWidth\\n  adjustView(cm, from, to)\\n\\n  display.viewOffset = heightAtLine(getLine(cm.doc, display.viewFrom))\\n  // Position the mover div to align with the current scroll position\\n  cm.display.mover.style.top = display.viewOffset + \\\"px\\\"\\n\\n  var toUpdate = countDirtyView(cm)\\n  if (!different && toUpdate == 0 && !update.force && display.renderedView == display.view &&\\n      (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo))\\n    { return false }\\n\\n  // For big changes, we hide the enclosing element during the\\n  // update, since that speeds up the operations on most browsers.\\n  var focused = activeElt()\\n  if (toUpdate > 4) { display.lineDiv.style.display = \\\"none\\\" }\\n  patchDisplay(cm, display.updateLineNumbers, update.dims)\\n  if (toUpdate > 4) { display.lineDiv.style.display = \\\"\\\" }\\n  display.renderedView = display.view\\n  // There might have been a widget with a focused element that got\\n  // hidden or updated, if so re-focus it.\\n  if (focused && activeElt() != focused && focused.offsetHeight) { focused.focus() }\\n\\n  // Prevent selection and cursors from interfering with the scroll\\n  // width and height.\\n  removeChildren(display.cursorDiv)\\n  removeChildren(display.selectionDiv)\\n  display.gutters.style.height = display.sizer.style.minHeight = 0\\n\\n  if (different) {\\n    display.lastWrapHeight = update.wrapperHeight\\n    display.lastWrapWidth = update.wrapperWidth\\n    startWorker(cm, 400)\\n  }\\n\\n  display.updateLineNumbers = null\\n\\n  return true\\n}\\n\\nfunction postUpdateDisplay(cm, update) {\\n  var viewport = update.viewport\\n\\n  for (var first = true;; first = false) {\\n    if (!first || !cm.options.lineWrapping || update.oldDisplayWidth == displayWidth(cm)) {\\n      // Clip forced viewport to actual scrollable area.\\n      if (viewport && viewport.top != null)\\n        { viewport = {top: Math.min(cm.doc.height + paddingVert(cm.display) - displayHeight(cm), viewport.top)} }\\n      // Updated line heights might result in the drawn area not\\n      // actually covering the viewport. Keep looping until it does.\\n      update.visible = visibleLines(cm.display, cm.doc, viewport)\\n      if (update.visible.from >= cm.display.viewFrom && update.visible.to <= cm.display.viewTo)\\n        { break }\\n    }\\n    if (!updateDisplayIfNeeded(cm, update)) { break }\\n    updateHeightsInViewport(cm)\\n    var barMeasure = measureForScrollbars(cm)\\n    updateSelection(cm)\\n    updateScrollbars(cm, barMeasure)\\n    setDocumentHeight(cm, barMeasure)\\n  }\\n\\n  update.signal(cm, \\\"update\\\", cm)\\n  if (cm.display.viewFrom != cm.display.reportedViewFrom || cm.display.viewTo != cm.display.reportedViewTo) {\\n    update.signal(cm, \\\"viewportChange\\\", cm, cm.display.viewFrom, cm.display.viewTo)\\n    cm.display.reportedViewFrom = cm.display.viewFrom; cm.display.reportedViewTo = cm.display.viewTo\\n  }\\n}\\n\\nfunction updateDisplaySimple(cm, viewport) {\\n  var update = new DisplayUpdate(cm, viewport)\\n  if (updateDisplayIfNeeded(cm, update)) {\\n    updateHeightsInViewport(cm)\\n    postUpdateDisplay(cm, update)\\n    var barMeasure = measureForScrollbars(cm)\\n    updateSelection(cm)\\n    updateScrollbars(cm, barMeasure)\\n    setDocumentHeight(cm, barMeasure)\\n    update.finish()\\n  }\\n}\\n\\n// Sync the actual display DOM structure with display.view, removing\\n// nodes for lines that are no longer in view, and creating the ones\\n// that are not there yet, and updating the ones that are out of\\n// date.\\nfunction patchDisplay(cm, updateNumbersFrom, dims) {\\n  var display = cm.display, lineNumbers = cm.options.lineNumbers\\n  var container = display.lineDiv, cur = container.firstChild\\n\\n  function rm(node) {\\n    var next = node.nextSibling\\n    // Works around a throw-scroll bug in OS X Webkit\\n    if (webkit && mac && cm.display.currentWheelTarget == node)\\n      { node.style.display = \\\"none\\\" }\\n    else\\n      { node.parentNode.removeChild(node) }\\n    return next\\n  }\\n\\n  var view = display.view, lineN = display.viewFrom\\n  // Loop over the elements in the view, syncing cur (the DOM nodes\\n  // in display.lineDiv) with the view as we go.\\n  for (var i = 0; i < view.length; i++) {\\n    var lineView = view[i]\\n    if (lineView.hidden) {\\n    } else if (!lineView.node || lineView.node.parentNode != container) { // Not drawn yet\\n      var node = buildLineElement(cm, lineView, lineN, dims)\\n      container.insertBefore(node, cur)\\n    } else { // Already drawn\\n      while (cur != lineView.node) { cur = rm(cur) }\\n      var updateNumber = lineNumbers && updateNumbersFrom != null &&\\n        updateNumbersFrom <= lineN && lineView.lineNumber\\n      if (lineView.changes) {\\n        if (indexOf(lineView.changes, \\\"gutter\\\") > -1) { updateNumber = false }\\n        updateLineForChanges(cm, lineView, lineN, dims)\\n      }\\n      if (updateNumber) {\\n        removeChildren(lineView.lineNumber)\\n        lineView.lineNumber.appendChild(document.createTextNode(lineNumberFor(cm.options, lineN)))\\n      }\\n      cur = lineView.node.nextSibling\\n    }\\n    lineN += lineView.size\\n  }\\n  while (cur) { cur = rm(cur) }\\n}\\n\\nfunction updateGutterSpace(cm) {\\n  var width = cm.display.gutters.offsetWidth\\n  cm.display.sizer.style.marginLeft = width + \\\"px\\\"\\n}\\n\\nfunction setDocumentHeight(cm, measure) {\\n  cm.display.sizer.style.minHeight = measure.docHeight + \\\"px\\\"\\n  cm.display.heightForcer.style.top = measure.docHeight + \\\"px\\\"\\n  cm.display.gutters.style.height = (measure.docHeight + cm.display.barHeight + scrollGap(cm)) + \\\"px\\\"\\n}\\n\\n// Rebuild the gutter elements, ensure the margin to the left of the\\n// code matches their width.\\nfunction updateGutters(cm) {\\n  var gutters = cm.display.gutters, specs = cm.options.gutters\\n  removeChildren(gutters)\\n  var i = 0\\n  for (; i < specs.length; ++i) {\\n    var gutterClass = specs[i]\\n    var gElt = gutters.appendChild(elt(\\\"div\\\", null, \\\"CodeMirror-gutter \\\" + gutterClass))\\n    if (gutterClass == \\\"CodeMirror-linenumbers\\\") {\\n      cm.display.lineGutter = gElt\\n      gElt.style.width = (cm.display.lineNumWidth || 1) + \\\"px\\\"\\n    }\\n  }\\n  gutters.style.display = i ? \\\"\\\" : \\\"none\\\"\\n  updateGutterSpace(cm)\\n}\\n\\n// Make sure the gutters options contains the element\\n// \\\"CodeMirror-linenumbers\\\" when the lineNumbers option is true.\\nfunction setGuttersForLineNumbers(options) {\\n  var found = indexOf(options.gutters, \\\"CodeMirror-linenumbers\\\")\\n  if (found == -1 && options.lineNumbers) {\\n    options.gutters = options.gutters.concat([\\\"CodeMirror-linenumbers\\\"])\\n  } else if (found > -1 && !options.lineNumbers) {\\n    options.gutters = options.gutters.slice(0)\\n    options.gutters.splice(found, 1)\\n  }\\n}\\n\\n// Selection objects are immutable. A new one is created every time\\n// the selection changes. A selection is one or more non-overlapping\\n// (and non-touching) ranges, sorted, and an integer that indicates\\n// which one is the primary selection (the one that's scrolled into\\n// view, that getCursor returns, etc).\\nvar Selection = function(ranges, primIndex) {\\n  this.ranges = ranges\\n  this.primIndex = primIndex\\n};\\n\\nSelection.prototype.primary = function () { return this.ranges[this.primIndex] };\\n\\nSelection.prototype.equals = function (other) {\\n    var this$1 = this;\\n\\n  if (other == this) { return true }\\n  if (other.primIndex != this.primIndex || other.ranges.length != this.ranges.length) { return false }\\n  for (var i = 0; i < this.ranges.length; i++) {\\n    var here = this$1.ranges[i], there = other.ranges[i]\\n    if (!equalCursorPos(here.anchor, there.anchor) || !equalCursorPos(here.head, there.head)) { return false }\\n  }\\n  return true\\n};\\n\\nSelection.prototype.deepCopy = function () {\\n    var this$1 = this;\\n\\n  var out = []\\n  for (var i = 0; i < this.ranges.length; i++)\\n    { out[i] = new Range(copyPos(this$1.ranges[i].anchor), copyPos(this$1.ranges[i].head)) }\\n  return new Selection(out, this.primIndex)\\n};\\n\\nSelection.prototype.somethingSelected = function () {\\n    var this$1 = this;\\n\\n  for (var i = 0; i < this.ranges.length; i++)\\n    { if (!this$1.ranges[i].empty()) { return true } }\\n  return false\\n};\\n\\nSelection.prototype.contains = function (pos, end) {\\n    var this$1 = this;\\n\\n  if (!end) { end = pos }\\n  for (var i = 0; i < this.ranges.length; i++) {\\n    var range = this$1.ranges[i]\\n    if (cmp(end, range.from()) >= 0 && cmp(pos, range.to()) <= 0)\\n      { return i }\\n  }\\n  return -1\\n};\\n\\nvar Range = function(anchor, head) {\\n  this.anchor = anchor; this.head = head\\n};\\n\\nRange.prototype.from = function () { return minPos(this.anchor, this.head) };\\nRange.prototype.to = function () { return maxPos(this.anchor, this.head) };\\nRange.prototype.empty = function () { return this.head.line == this.anchor.line && this.head.ch == this.anchor.ch };\\n\\n// Take an unsorted, potentially overlapping set of ranges, and\\n// build a selection out of it. 'Consumes' ranges array (modifying\\n// it).\\nfunction normalizeSelection(ranges, primIndex) {\\n  var prim = ranges[primIndex]\\n  ranges.sort(function (a, b) { return cmp(a.from(), b.from()); })\\n  primIndex = indexOf(ranges, prim)\\n  for (var i = 1; i < ranges.length; i++) {\\n    var cur = ranges[i], prev = ranges[i - 1]\\n    if (cmp(prev.to(), cur.from()) >= 0) {\\n      var from = minPos(prev.from(), cur.from()), to = maxPos(prev.to(), cur.to())\\n      var inv = prev.empty() ? cur.from() == cur.head : prev.from() == prev.head\\n      if (i <= primIndex) { --primIndex }\\n      ranges.splice(--i, 2, new Range(inv ? to : from, inv ? from : to))\\n    }\\n  }\\n  return new Selection(ranges, primIndex)\\n}\\n\\nfunction simpleSelection(anchor, head) {\\n  return new Selection([new Range(anchor, head || anchor)], 0)\\n}\\n\\n// Compute the position of the end of a change (its 'to' property\\n// refers to the pre-change end).\\nfunction changeEnd(change) {\\n  if (!change.text) { return change.to }\\n  return Pos(change.from.line + change.text.length - 1,\\n             lst(change.text).length + (change.text.length == 1 ? change.from.ch : 0))\\n}\\n\\n// Adjust a position to refer to the post-change position of the\\n// same text, or the end of the change if the change covers it.\\nfunction adjustForChange(pos, change) {\\n  if (cmp(pos, change.from) < 0) { return pos }\\n  if (cmp(pos, change.to) <= 0) { return changeEnd(change) }\\n\\n  var line = pos.line + change.text.length - (change.to.line - change.from.line) - 1, ch = pos.ch\\n  if (pos.line == change.to.line) { ch += changeEnd(change).ch - change.to.ch }\\n  return Pos(line, ch)\\n}\\n\\nfunction computeSelAfterChange(doc, change) {\\n  var out = []\\n  for (var i = 0; i < doc.sel.ranges.length; i++) {\\n    var range = doc.sel.ranges[i]\\n    out.push(new Range(adjustForChange(range.anchor, change),\\n                       adjustForChange(range.head, change)))\\n  }\\n  return normalizeSelection(out, doc.sel.primIndex)\\n}\\n\\nfunction offsetPos(pos, old, nw) {\\n  if (pos.line == old.line)\\n    { return Pos(nw.line, pos.ch - old.ch + nw.ch) }\\n  else\\n    { return Pos(nw.line + (pos.line - old.line), pos.ch) }\\n}\\n\\n// Used by replaceSelections to allow moving the selection to the\\n// start or around the replaced test. Hint may be \\\"start\\\" or \\\"around\\\".\\nfunction computeReplacedSel(doc, changes, hint) {\\n  var out = []\\n  var oldPrev = Pos(doc.first, 0), newPrev = oldPrev\\n  for (var i = 0; i < changes.length; i++) {\\n    var change = changes[i]\\n    var from = offsetPos(change.from, oldPrev, newPrev)\\n    var to = offsetPos(changeEnd(change), oldPrev, newPrev)\\n    oldPrev = change.to\\n    newPrev = to\\n    if (hint == \\\"around\\\") {\\n      var range = doc.sel.ranges[i], inv = cmp(range.head, range.anchor) < 0\\n      out[i] = new Range(inv ? to : from, inv ? from : to)\\n    } else {\\n      out[i] = new Range(from, from)\\n    }\\n  }\\n  return new Selection(out, doc.sel.primIndex)\\n}\\n\\n// Used to get the editor into a consistent state again when options change.\\n\\nfunction loadMode(cm) {\\n  cm.doc.mode = getMode(cm.options, cm.doc.modeOption)\\n  resetModeState(cm)\\n}\\n\\nfunction resetModeState(cm) {\\n  cm.doc.iter(function (line) {\\n    if (line.stateAfter) { line.stateAfter = null }\\n    if (line.styles) { line.styles = null }\\n  })\\n  cm.doc.frontier = cm.doc.first\\n  startWorker(cm, 100)\\n  cm.state.modeGen++\\n  if (cm.curOp) { regChange(cm) }\\n}\\n\\n// DOCUMENT DATA STRUCTURE\\n\\n// By default, updates that start and end at the beginning of a line\\n// are treated specially, in order to make the association of line\\n// widgets and marker elements with the text behave more intuitive.\\nfunction isWholeLineUpdate(doc, change) {\\n  return change.from.ch == 0 && change.to.ch == 0 && lst(change.text) == \\\"\\\" &&\\n    (!doc.cm || doc.cm.options.wholeLineUpdateBefore)\\n}\\n\\n// Perform a change on the document data structure.\\nfunction updateDoc(doc, change, markedSpans, estimateHeight) {\\n  function spansFor(n) {return markedSpans ? markedSpans[n] : null}\\n  function update(line, text, spans) {\\n    updateLine(line, text, spans, estimateHeight)\\n    signalLater(line, \\\"change\\\", line, change)\\n  }\\n  function linesFor(start, end) {\\n    var result = []\\n    for (var i = start; i < end; ++i)\\n      { result.push(new Line(text[i], spansFor(i), estimateHeight)) }\\n    return result\\n  }\\n\\n  var from = change.from, to = change.to, text = change.text\\n  var firstLine = getLine(doc, from.line), lastLine = getLine(doc, to.line)\\n  var lastText = lst(text), lastSpans = spansFor(text.length - 1), nlines = to.line - from.line\\n\\n  // Adjust the line structure\\n  if (change.full) {\\n    doc.insert(0, linesFor(0, text.length))\\n    doc.remove(text.length, doc.size - text.length)\\n  } else if (isWholeLineUpdate(doc, change)) {\\n    // This is a whole-line replace. Treated specially to make\\n    // sure line objects move the way they are supposed to.\\n    var added = linesFor(0, text.length - 1)\\n    update(lastLine, lastLine.text, lastSpans)\\n    if (nlines) { doc.remove(from.line, nlines) }\\n    if (added.length) { doc.insert(from.line, added) }\\n  } else if (firstLine == lastLine) {\\n    if (text.length == 1) {\\n      update(firstLine, firstLine.text.slice(0, from.ch) + lastText + firstLine.text.slice(to.ch), lastSpans)\\n    } else {\\n      var added$1 = linesFor(1, text.length - 1)\\n      added$1.push(new Line(lastText + firstLine.text.slice(to.ch), lastSpans, estimateHeight))\\n      update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0))\\n      doc.insert(from.line + 1, added$1)\\n    }\\n  } else if (text.length == 1) {\\n    update(firstLine, firstLine.text.slice(0, from.ch) + text[0] + lastLine.text.slice(to.ch), spansFor(0))\\n    doc.remove(from.line + 1, nlines)\\n  } else {\\n    update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0))\\n    update(lastLine, lastText + lastLine.text.slice(to.ch), lastSpans)\\n    var added$2 = linesFor(1, text.length - 1)\\n    if (nlines > 1) { doc.remove(from.line + 1, nlines - 1) }\\n    doc.insert(from.line + 1, added$2)\\n  }\\n\\n  signalLater(doc, \\\"change\\\", doc, change)\\n}\\n\\n// Call f for all linked documents.\\nfunction linkedDocs(doc, f, sharedHistOnly) {\\n  function propagate(doc, skip, sharedHist) {\\n    if (doc.linked) { for (var i = 0; i < doc.linked.length; ++i) {\\n      var rel = doc.linked[i]\\n      if (rel.doc == skip) { continue }\\n      var shared = sharedHist && rel.sharedHist\\n      if (sharedHistOnly && !shared) { continue }\\n      f(rel.doc, shared)\\n      propagate(rel.doc, doc, shared)\\n    } }\\n  }\\n  propagate(doc, null, true)\\n}\\n\\n// Attach a document to an editor.\\nfunction attachDoc(cm, doc) {\\n  if (doc.cm) { throw new Error(\\\"This document is already in use.\\\") }\\n  cm.doc = doc\\n  doc.cm = cm\\n  estimateLineHeights(cm)\\n  loadMode(cm)\\n  if (!cm.options.lineWrapping) { findMaxLine(cm) }\\n  cm.options.mode = doc.modeOption\\n  regChange(cm)\\n}\\n\\nfunction History(startGen) {\\n  // Arrays of change events and selections. Doing something adds an\\n  // event to done and clears undo. Undoing moves events from done\\n  // to undone, redoing moves them in the other direction.\\n  this.done = []; this.undone = []\\n  this.undoDepth = Infinity\\n  // Used to track when changes can be merged into a single undo\\n  // event\\n  this.lastModTime = this.lastSelTime = 0\\n  this.lastOp = this.lastSelOp = null\\n  this.lastOrigin = this.lastSelOrigin = null\\n  // Used by the isClean() method\\n  this.generation = this.maxGeneration = startGen || 1\\n}\\n\\n// Create a history change event from an updateDoc-style change\\n// object.\\nfunction historyChangeFromChange(doc, change) {\\n  var histChange = {from: copyPos(change.from), to: changeEnd(change), text: getBetween(doc, change.from, change.to)}\\n  attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1)\\n  linkedDocs(doc, function (doc) { return attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1); }, true)\\n  return histChange\\n}\\n\\n// Pop all selection events off the end of a history array. Stop at\\n// a change event.\\nfunction clearSelectionEvents(array) {\\n  while (array.length) {\\n    var last = lst(array)\\n    if (last.ranges) { array.pop() }\\n    else { break }\\n  }\\n}\\n\\n// Find the top change event in the history. Pop off selection\\n// events that are in the way.\\nfunction lastChangeEvent(hist, force) {\\n  if (force) {\\n    clearSelectionEvents(hist.done)\\n    return lst(hist.done)\\n  } else if (hist.done.length && !lst(hist.done).ranges) {\\n    return lst(hist.done)\\n  } else if (hist.done.length > 1 && !hist.done[hist.done.length - 2].ranges) {\\n    hist.done.pop()\\n    return lst(hist.done)\\n  }\\n}\\n\\n// Register a change in the history. Merges changes that are within\\n// a single operation, or are close together with an origin that\\n// allows merging (starting with \\\"+\\\") into a single event.\\nfunction addChangeToHistory(doc, change, selAfter, opId) {\\n  var hist = doc.history\\n  hist.undone.length = 0\\n  var time = +new Date, cur\\n  var last\\n\\n  if ((hist.lastOp == opId ||\\n       hist.lastOrigin == change.origin && change.origin &&\\n       ((change.origin.charAt(0) == \\\"+\\\" && doc.cm && hist.lastModTime > time - doc.cm.options.historyEventDelay) ||\\n        change.origin.charAt(0) == \\\"*\\\")) &&\\n      (cur = lastChangeEvent(hist, hist.lastOp == opId))) {\\n    // Merge this change into the last event\\n    last = lst(cur.changes)\\n    if (cmp(change.from, change.to) == 0 && cmp(change.from, last.to) == 0) {\\n      // Optimized case for simple insertion -- don't want to add\\n      // new changesets for every character typed\\n      last.to = changeEnd(change)\\n    } else {\\n      // Add new sub-event\\n      cur.changes.push(historyChangeFromChange(doc, change))\\n    }\\n  } else {\\n    // Can not be merged, start a new event.\\n    var before = lst(hist.done)\\n    if (!before || !before.ranges)\\n      { pushSelectionToHistory(doc.sel, hist.done) }\\n    cur = {changes: [historyChangeFromChange(doc, change)],\\n           generation: hist.generation}\\n    hist.done.push(cur)\\n    while (hist.done.length > hist.undoDepth) {\\n      hist.done.shift()\\n      if (!hist.done[0].ranges) { hist.done.shift() }\\n    }\\n  }\\n  hist.done.push(selAfter)\\n  hist.generation = ++hist.maxGeneration\\n  hist.lastModTime = hist.lastSelTime = time\\n  hist.lastOp = hist.lastSelOp = opId\\n  hist.lastOrigin = hist.lastSelOrigin = change.origin\\n\\n  if (!last) { signal(doc, \\\"historyAdded\\\") }\\n}\\n\\nfunction selectionEventCanBeMerged(doc, origin, prev, sel) {\\n  var ch = origin.charAt(0)\\n  return ch == \\\"*\\\" ||\\n    ch == \\\"+\\\" &&\\n    prev.ranges.length == sel.ranges.length &&\\n    prev.somethingSelected() == sel.somethingSelected() &&\\n    new Date - doc.history.lastSelTime <= (doc.cm ? doc.cm.options.historyEventDelay : 500)\\n}\\n\\n// Called whenever the selection changes, sets the new selection as\\n// the pending selection in the history, and pushes the old pending\\n// selection into the 'done' array when it was significantly\\n// different (in number of selected ranges, emptiness, or time).\\nfunction addSelectionToHistory(doc, sel, opId, options) {\\n  var hist = doc.history, origin = options && options.origin\\n\\n  // A new event is started when the previous origin does not match\\n  // the current, or the origins don't allow matching. Origins\\n  // starting with * are always merged, those starting with + are\\n  // merged when similar and close together in time.\\n  if (opId == hist.lastSelOp ||\\n      (origin && hist.lastSelOrigin == origin &&\\n       (hist.lastModTime == hist.lastSelTime && hist.lastOrigin == origin ||\\n        selectionEventCanBeMerged(doc, origin, lst(hist.done), sel))))\\n    { hist.done[hist.done.length - 1] = sel }\\n  else\\n    { pushSelectionToHistory(sel, hist.done) }\\n\\n  hist.lastSelTime = +new Date\\n  hist.lastSelOrigin = origin\\n  hist.lastSelOp = opId\\n  if (options && options.clearRedo !== false)\\n    { clearSelectionEvents(hist.undone) }\\n}\\n\\nfunction pushSelectionToHistory(sel, dest) {\\n  var top = lst(dest)\\n  if (!(top && top.ranges && top.equals(sel)))\\n    { dest.push(sel) }\\n}\\n\\n// Used to store marked span information in the history.\\nfunction attachLocalSpans(doc, change, from, to) {\\n  var existing = change[\\\"spans_\\\" + doc.id], n = 0\\n  doc.iter(Math.max(doc.first, from), Math.min(doc.first + doc.size, to), function (line) {\\n    if (line.markedSpans)\\n      { (existing || (existing = change[\\\"spans_\\\" + doc.id] = {}))[n] = line.markedSpans }\\n    ++n\\n  })\\n}\\n\\n// When un/re-doing restores text containing marked spans, those\\n// that have been explicitly cleared should not be restored.\\nfunction removeClearedSpans(spans) {\\n  if (!spans) { return null }\\n  var out\\n  for (var i = 0; i < spans.length; ++i) {\\n    if (spans[i].marker.explicitlyCleared) { if (!out) { out = spans.slice(0, i) } }\\n    else if (out) { out.push(spans[i]) }\\n  }\\n  return !out ? spans : out.length ? out : null\\n}\\n\\n// Retrieve and filter the old marked spans stored in a change event.\\nfunction getOldSpans(doc, change) {\\n  var found = change[\\\"spans_\\\" + doc.id]\\n  if (!found) { return null }\\n  var nw = []\\n  for (var i = 0; i < change.text.length; ++i)\\n    { nw.push(removeClearedSpans(found[i])) }\\n  return nw\\n}\\n\\n// Used for un/re-doing changes from the history. Combines the\\n// result of computing the existing spans with the set of spans that\\n// existed in the history (so that deleting around a span and then\\n// undoing brings back the span).\\nfunction mergeOldSpans(doc, change) {\\n  var old = getOldSpans(doc, change)\\n  var stretched = stretchSpansOverChange(doc, change)\\n  if (!old) { return stretched }\\n  if (!stretched) { return old }\\n\\n  for (var i = 0; i < old.length; ++i) {\\n    var oldCur = old[i], stretchCur = stretched[i]\\n    if (oldCur && stretchCur) {\\n      spans: for (var j = 0; j < stretchCur.length; ++j) {\\n        var span = stretchCur[j]\\n        for (var k = 0; k < oldCur.length; ++k)\\n          { if (oldCur[k].marker == span.marker) { continue spans } }\\n        oldCur.push(span)\\n      }\\n    } else if (stretchCur) {\\n      old[i] = stretchCur\\n    }\\n  }\\n  return old\\n}\\n\\n// Used both to provide a JSON-safe object in .getHistory, and, when\\n// detaching a document, to split the history in two\\nfunction copyHistoryArray(events, newGroup, instantiateSel) {\\n  var copy = []\\n  for (var i = 0; i < events.length; ++i) {\\n    var event = events[i]\\n    if (event.ranges) {\\n      copy.push(instantiateSel ? Selection.prototype.deepCopy.call(event) : event)\\n      continue\\n    }\\n    var changes = event.changes, newChanges = []\\n    copy.push({changes: newChanges})\\n    for (var j = 0; j < changes.length; ++j) {\\n      var change = changes[j], m = (void 0)\\n      newChanges.push({from: change.from, to: change.to, text: change.text})\\n      if (newGroup) { for (var prop in change) { if (m = prop.match(/^spans_(\\\\d+)$/)) {\\n        if (indexOf(newGroup, Number(m[1])) > -1) {\\n          lst(newChanges)[prop] = change[prop]\\n          delete change[prop]\\n        }\\n      } } }\\n    }\\n  }\\n  return copy\\n}\\n\\n// The 'scroll' parameter given to many of these indicated whether\\n// the new cursor position should be scrolled into view after\\n// modifying the selection.\\n\\n// If shift is held or the extend flag is set, extends a range to\\n// include a given position (and optionally a second position).\\n// Otherwise, simply returns the range between the given positions.\\n// Used for cursor motion and such.\\nfunction extendRange(doc, range, head, other) {\\n  if (doc.cm && doc.cm.display.shift || doc.extend) {\\n    var anchor = range.anchor\\n    if (other) {\\n      var posBefore = cmp(head, anchor) < 0\\n      if (posBefore != (cmp(other, anchor) < 0)) {\\n        anchor = head\\n        head = other\\n      } else if (posBefore != (cmp(head, other) < 0)) {\\n        head = other\\n      }\\n    }\\n    return new Range(anchor, head)\\n  } else {\\n    return new Range(other || head, head)\\n  }\\n}\\n\\n// Extend the primary selection range, discard the rest.\\nfunction extendSelection(doc, head, other, options) {\\n  setSelection(doc, new Selection([extendRange(doc, doc.sel.primary(), head, other)], 0), options)\\n}\\n\\n// Extend all selections (pos is an array of selections with length\\n// equal the number of selections)\\nfunction extendSelections(doc, heads, options) {\\n  var out = []\\n  for (var i = 0; i < doc.sel.ranges.length; i++)\\n    { out[i] = extendRange(doc, doc.sel.ranges[i], heads[i], null) }\\n  var newSel = normalizeSelection(out, doc.sel.primIndex)\\n  setSelection(doc, newSel, options)\\n}\\n\\n// Updates a single range in the selection.\\nfunction replaceOneSelection(doc, i, range, options) {\\n  var ranges = doc.sel.ranges.slice(0)\\n  ranges[i] = range\\n  setSelection(doc, normalizeSelection(ranges, doc.sel.primIndex), options)\\n}\\n\\n// Reset the selection to a single range.\\nfunction setSimpleSelection(doc, anchor, head, options) {\\n  setSelection(doc, simpleSelection(anchor, head), options)\\n}\\n\\n// Give beforeSelectionChange handlers a change to influence a\\n// selection update.\\nfunction filterSelectionChange(doc, sel, options) {\\n  var obj = {\\n    ranges: sel.ranges,\\n    update: function(ranges) {\\n      var this$1 = this;\\n\\n      this.ranges = []\\n      for (var i = 0; i < ranges.length; i++)\\n        { this$1.ranges[i] = new Range(clipPos(doc, ranges[i].anchor),\\n                                   clipPos(doc, ranges[i].head)) }\\n    },\\n    origin: options && options.origin\\n  }\\n  signal(doc, \\\"beforeSelectionChange\\\", doc, obj)\\n  if (doc.cm) { signal(doc.cm, \\\"beforeSelectionChange\\\", doc.cm, obj) }\\n  if (obj.ranges != sel.ranges) { return normalizeSelection(obj.ranges, obj.ranges.length - 1) }\\n  else { return sel }\\n}\\n\\nfunction setSelectionReplaceHistory(doc, sel, options) {\\n  var done = doc.history.done, last = lst(done)\\n  if (last && last.ranges) {\\n    done[done.length - 1] = sel\\n    setSelectionNoUndo(doc, sel, options)\\n  } else {\\n    setSelection(doc, sel, options)\\n  }\\n}\\n\\n// Set a new selection.\\nfunction setSelection(doc, sel, options) {\\n  setSelectionNoUndo(doc, sel, options)\\n  addSelectionToHistory(doc, doc.sel, doc.cm ? doc.cm.curOp.id : NaN, options)\\n}\\n\\nfunction setSelectionNoUndo(doc, sel, options) {\\n  if (hasHandler(doc, \\\"beforeSelectionChange\\\") || doc.cm && hasHandler(doc.cm, \\\"beforeSelectionChange\\\"))\\n    { sel = filterSelectionChange(doc, sel, options) }\\n\\n  var bias = options && options.bias ||\\n    (cmp(sel.primary().head, doc.sel.primary().head) < 0 ? -1 : 1)\\n  setSelectionInner(doc, skipAtomicInSelection(doc, sel, bias, true))\\n\\n  if (!(options && options.scroll === false) && doc.cm)\\n    { ensureCursorVisible(doc.cm) }\\n}\\n\\nfunction setSelectionInner(doc, sel) {\\n  if (sel.equals(doc.sel)) { return }\\n\\n  doc.sel = sel\\n\\n  if (doc.cm) {\\n    doc.cm.curOp.updateInput = doc.cm.curOp.selectionChanged = true\\n    signalCursorActivity(doc.cm)\\n  }\\n  signalLater(doc, \\\"cursorActivity\\\", doc)\\n}\\n\\n// Verify that the selection does not partially select any atomic\\n// marked ranges.\\nfunction reCheckSelection(doc) {\\n  setSelectionInner(doc, skipAtomicInSelection(doc, doc.sel, null, false), sel_dontScroll)\\n}\\n\\n// Return a selection that does not partially select any atomic\\n// ranges.\\nfunction skipAtomicInSelection(doc, sel, bias, mayClear) {\\n  var out\\n  for (var i = 0; i < sel.ranges.length; i++) {\\n    var range = sel.ranges[i]\\n    var old = sel.ranges.length == doc.sel.ranges.length && doc.sel.ranges[i]\\n    var newAnchor = skipAtomic(doc, range.anchor, old && old.anchor, bias, mayClear)\\n    var newHead = skipAtomic(doc, range.head, old && old.head, bias, mayClear)\\n    if (out || newAnchor != range.anchor || newHead != range.head) {\\n      if (!out) { out = sel.ranges.slice(0, i) }\\n      out[i] = new Range(newAnchor, newHead)\\n    }\\n  }\\n  return out ? normalizeSelection(out, sel.primIndex) : sel\\n}\\n\\nfunction skipAtomicInner(doc, pos, oldPos, dir, mayClear) {\\n  var line = getLine(doc, pos.line)\\n  if (line.markedSpans) { for (var i = 0; i < line.markedSpans.length; ++i) {\\n    var sp = line.markedSpans[i], m = sp.marker\\n    if ((sp.from == null || (m.inclusiveLeft ? sp.from <= pos.ch : sp.from < pos.ch)) &&\\n        (sp.to == null || (m.inclusiveRight ? sp.to >= pos.ch : sp.to > pos.ch))) {\\n      if (mayClear) {\\n        signal(m, \\\"beforeCursorEnter\\\")\\n        if (m.explicitlyCleared) {\\n          if (!line.markedSpans) { break }\\n          else {--i; continue}\\n        }\\n      }\\n      if (!m.atomic) { continue }\\n\\n      if (oldPos) {\\n        var near = m.find(dir < 0 ? 1 : -1), diff = (void 0)\\n        if (dir < 0 ? m.inclusiveRight : m.inclusiveLeft)\\n          { near = movePos(doc, near, -dir, near && near.line == pos.line ? line : null) }\\n        if (near && near.line == pos.line && (diff = cmp(near, oldPos)) && (dir < 0 ? diff < 0 : diff > 0))\\n          { return skipAtomicInner(doc, near, pos, dir, mayClear) }\\n      }\\n\\n      var far = m.find(dir < 0 ? -1 : 1)\\n      if (dir < 0 ? m.inclusiveLeft : m.inclusiveRight)\\n        { far = movePos(doc, far, dir, far.line == pos.line ? line : null) }\\n      return far ? skipAtomicInner(doc, far, pos, dir, mayClear) : null\\n    }\\n  } }\\n  return pos\\n}\\n\\n// Ensure a given position is not inside an atomic range.\\nfunction skipAtomic(doc, pos, oldPos, bias, mayClear) {\\n  var dir = bias || 1\\n  var found = skipAtomicInner(doc, pos, oldPos, dir, mayClear) ||\\n      (!mayClear && skipAtomicInner(doc, pos, oldPos, dir, true)) ||\\n      skipAtomicInner(doc, pos, oldPos, -dir, mayClear) ||\\n      (!mayClear && skipAtomicInner(doc, pos, oldPos, -dir, true))\\n  if (!found) {\\n    doc.cantEdit = true\\n    return Pos(doc.first, 0)\\n  }\\n  return found\\n}\\n\\nfunction movePos(doc, pos, dir, line) {\\n  if (dir < 0 && pos.ch == 0) {\\n    if (pos.line > doc.first) { return clipPos(doc, Pos(pos.line - 1)) }\\n    else { return null }\\n  } else if (dir > 0 && pos.ch == (line || getLine(doc, pos.line)).text.length) {\\n    if (pos.line < doc.first + doc.size - 1) { return Pos(pos.line + 1, 0) }\\n    else { return null }\\n  } else {\\n    return new Pos(pos.line, pos.ch + dir)\\n  }\\n}\\n\\nfunction selectAll(cm) {\\n  cm.setSelection(Pos(cm.firstLine(), 0), Pos(cm.lastLine()), sel_dontScroll)\\n}\\n\\n// UPDATING\\n\\n// Allow \\\"beforeChange\\\" event handlers to influence a change\\nfunction filterChange(doc, change, update) {\\n  var obj = {\\n    canceled: false,\\n    from: change.from,\\n    to: change.to,\\n    text: change.text,\\n    origin: change.origin,\\n    cancel: function () { return obj.canceled = true; }\\n  }\\n  if (update) { obj.update = function (from, to, text, origin) {\\n    if (from) { obj.from = clipPos(doc, from) }\\n    if (to) { obj.to = clipPos(doc, to) }\\n    if (text) { obj.text = text }\\n    if (origin !== undefined) { obj.origin = origin }\\n  } }\\n  signal(doc, \\\"beforeChange\\\", doc, obj)\\n  if (doc.cm) { signal(doc.cm, \\\"beforeChange\\\", doc.cm, obj) }\\n\\n  if (obj.canceled) { return null }\\n  return {from: obj.from, to: obj.to, text: obj.text, origin: obj.origin}\\n}\\n\\n// Apply a change to a document, and add it to the document's\\n// history, and propagating it to all linked documents.\\nfunction makeChange(doc, change, ignoreReadOnly) {\\n  if (doc.cm) {\\n    if (!doc.cm.curOp) { return operation(doc.cm, makeChange)(doc, change, ignoreReadOnly) }\\n    if (doc.cm.state.suppressEdits) { return }\\n  }\\n\\n  if (hasHandler(doc, \\\"beforeChange\\\") || doc.cm && hasHandler(doc.cm, \\\"beforeChange\\\")) {\\n    change = filterChange(doc, change, true)\\n    if (!change) { return }\\n  }\\n\\n  // Possibly split or suppress the update based on the presence\\n  // of read-only spans in its range.\\n  var split = sawReadOnlySpans && !ignoreReadOnly && removeReadOnlyRanges(doc, change.from, change.to)\\n  if (split) {\\n    for (var i = split.length - 1; i >= 0; --i)\\n      { makeChangeInner(doc, {from: split[i].from, to: split[i].to, text: i ? [\\\"\\\"] : change.text}) }\\n  } else {\\n    makeChangeInner(doc, change)\\n  }\\n}\\n\\nfunction makeChangeInner(doc, change) {\\n  if (change.text.length == 1 && change.text[0] == \\\"\\\" && cmp(change.from, change.to) == 0) { return }\\n  var selAfter = computeSelAfterChange(doc, change)\\n  addChangeToHistory(doc, change, selAfter, doc.cm ? doc.cm.curOp.id : NaN)\\n\\n  makeChangeSingleDoc(doc, change, selAfter, stretchSpansOverChange(doc, change))\\n  var rebased = []\\n\\n  linkedDocs(doc, function (doc, sharedHist) {\\n    if (!sharedHist && indexOf(rebased, doc.history) == -1) {\\n      rebaseHist(doc.history, change)\\n      rebased.push(doc.history)\\n    }\\n    makeChangeSingleDoc(doc, change, null, stretchSpansOverChange(doc, change))\\n  })\\n}\\n\\n// Revert a change stored in a document's history.\\nfunction makeChangeFromHistory(doc, type, allowSelectionOnly) {\\n  if (doc.cm && doc.cm.state.suppressEdits && !allowSelectionOnly) { return }\\n\\n  var hist = doc.history, event, selAfter = doc.sel\\n  var source = type == \\\"undo\\\" ? hist.done : hist.undone, dest = type == \\\"undo\\\" ? hist.undone : hist.done\\n\\n  // Verify that there is a useable event (so that ctrl-z won't\\n  // needlessly clear selection events)\\n  var i = 0\\n  for (; i < source.length; i++) {\\n    event = source[i]\\n    if (allowSelectionOnly ? event.ranges && !event.equals(doc.sel) : !event.ranges)\\n      { break }\\n  }\\n  if (i == source.length) { return }\\n  hist.lastOrigin = hist.lastSelOrigin = null\\n\\n  for (;;) {\\n    event = source.pop()\\n    if (event.ranges) {\\n      pushSelectionToHistory(event, dest)\\n      if (allowSelectionOnly && !event.equals(doc.sel)) {\\n        setSelection(doc, event, {clearRedo: false})\\n        return\\n      }\\n      selAfter = event\\n    }\\n    else { break }\\n  }\\n\\n  // Build up a reverse change object to add to the opposite history\\n  // stack (redo when undoing, and vice versa).\\n  var antiChanges = []\\n  pushSelectionToHistory(selAfter, dest)\\n  dest.push({changes: antiChanges, generation: hist.generation})\\n  hist.generation = event.generation || ++hist.maxGeneration\\n\\n  var filter = hasHandler(doc, \\\"beforeChange\\\") || doc.cm && hasHandler(doc.cm, \\\"beforeChange\\\")\\n\\n  var loop = function ( i ) {\\n    var change = event.changes[i]\\n    change.origin = type\\n    if (filter && !filterChange(doc, change, false)) {\\n      source.length = 0\\n      return {}\\n    }\\n\\n    antiChanges.push(historyChangeFromChange(doc, change))\\n\\n    var after = i ? computeSelAfterChange(doc, change) : lst(source)\\n    makeChangeSingleDoc(doc, change, after, mergeOldSpans(doc, change))\\n    if (!i && doc.cm) { doc.cm.scrollIntoView({from: change.from, to: changeEnd(change)}) }\\n    var rebased = []\\n\\n    // Propagate to the linked documents\\n    linkedDocs(doc, function (doc, sharedHist) {\\n      if (!sharedHist && indexOf(rebased, doc.history) == -1) {\\n        rebaseHist(doc.history, change)\\n        rebased.push(doc.history)\\n      }\\n      makeChangeSingleDoc(doc, change, null, mergeOldSpans(doc, change))\\n    })\\n  };\\n\\n  for (var i$1 = event.changes.length - 1; i$1 >= 0; --i$1) {\\n    var returned = loop( i$1 );\\n\\n    if ( returned ) return returned.v;\\n  }\\n}\\n\\n// Sub-views need their line numbers shifted when text is added\\n// above or below them in the parent document.\\nfunction shiftDoc(doc, distance) {\\n  if (distance == 0) { return }\\n  doc.first += distance\\n  doc.sel = new Selection(map(doc.sel.ranges, function (range) { return new Range(\\n    Pos(range.anchor.line + distance, range.anchor.ch),\\n    Pos(range.head.line + distance, range.head.ch)\\n  ); }), doc.sel.primIndex)\\n  if (doc.cm) {\\n    regChange(doc.cm, doc.first, doc.first - distance, distance)\\n    for (var d = doc.cm.display, l = d.viewFrom; l < d.viewTo; l++)\\n      { regLineChange(doc.cm, l, \\\"gutter\\\") }\\n  }\\n}\\n\\n// More lower-level change function, handling only a single document\\n// (not linked ones).\\nfunction makeChangeSingleDoc(doc, change, selAfter, spans) {\\n  if (doc.cm && !doc.cm.curOp)\\n    { return operation(doc.cm, makeChangeSingleDoc)(doc, change, selAfter, spans) }\\n\\n  if (change.to.line < doc.first) {\\n    shiftDoc(doc, change.text.length - 1 - (change.to.line - change.from.line))\\n    return\\n  }\\n  if (change.from.line > doc.lastLine()) { return }\\n\\n  // Clip the change to the size of this doc\\n  if (change.from.line < doc.first) {\\n    var shift = change.text.length - 1 - (doc.first - change.from.line)\\n    shiftDoc(doc, shift)\\n    change = {from: Pos(doc.first, 0), to: Pos(change.to.line + shift, change.to.ch),\\n              text: [lst(change.text)], origin: change.origin}\\n  }\\n  var last = doc.lastLine()\\n  if (change.to.line > last) {\\n    change = {from: change.from, to: Pos(last, getLine(doc, last).text.length),\\n              text: [change.text[0]], origin: change.origin}\\n  }\\n\\n  change.removed = getBetween(doc, change.from, change.to)\\n\\n  if (!selAfter) { selAfter = computeSelAfterChange(doc, change) }\\n  if (doc.cm) { makeChangeSingleDocInEditor(doc.cm, change, spans) }\\n  else { updateDoc(doc, change, spans) }\\n  setSelectionNoUndo(doc, selAfter, sel_dontScroll)\\n}\\n\\n// Handle the interaction of a change to a document with the editor\\n// that this document is part of.\\nfunction makeChangeSingleDocInEditor(cm, change, spans) {\\n  var doc = cm.doc, display = cm.display, from = change.from, to = change.to\\n\\n  var recomputeMaxLength = false, checkWidthStart = from.line\\n  if (!cm.options.lineWrapping) {\\n    checkWidthStart = lineNo(visualLine(getLine(doc, from.line)))\\n    doc.iter(checkWidthStart, to.line + 1, function (line) {\\n      if (line == display.maxLine) {\\n        recomputeMaxLength = true\\n        return true\\n      }\\n    })\\n  }\\n\\n  if (doc.sel.contains(change.from, change.to) > -1)\\n    { signalCursorActivity(cm) }\\n\\n  updateDoc(doc, change, spans, estimateHeight(cm))\\n\\n  if (!cm.options.lineWrapping) {\\n    doc.iter(checkWidthStart, from.line + change.text.length, function (line) {\\n      var len = lineLength(line)\\n      if (len > display.maxLineLength) {\\n        display.maxLine = line\\n        display.maxLineLength = len\\n        display.maxLineChanged = true\\n        recomputeMaxLength = false\\n      }\\n    })\\n    if (recomputeMaxLength) { cm.curOp.updateMaxLine = true }\\n  }\\n\\n  // Adjust frontier, schedule worker\\n  doc.frontier = Math.min(doc.frontier, from.line)\\n  startWorker(cm, 400)\\n\\n  var lendiff = change.text.length - (to.line - from.line) - 1\\n  // Remember that these lines changed, for updating the display\\n  if (change.full)\\n    { regChange(cm) }\\n  else if (from.line == to.line && change.text.length == 1 && !isWholeLineUpdate(cm.doc, change))\\n    { regLineChange(cm, from.line, \\\"text\\\") }\\n  else\\n    { regChange(cm, from.line, to.line + 1, lendiff) }\\n\\n  var changesHandler = hasHandler(cm, \\\"changes\\\"), changeHandler = hasHandler(cm, \\\"change\\\")\\n  if (changeHandler || changesHandler) {\\n    var obj = {\\n      from: from, to: to,\\n      text: change.text,\\n      removed: change.removed,\\n      origin: change.origin\\n    }\\n    if (changeHandler) { signalLater(cm, \\\"change\\\", cm, obj) }\\n    if (changesHandler) { (cm.curOp.changeObjs || (cm.curOp.changeObjs = [])).push(obj) }\\n  }\\n  cm.display.selForContextMenu = null\\n}\\n\\nfunction replaceRange(doc, code, from, to, origin) {\\n  if (!to) { to = from }\\n  if (cmp(to, from) < 0) { var tmp = to; to = from; from = tmp }\\n  if (typeof code == \\\"string\\\") { code = doc.splitLines(code) }\\n  makeChange(doc, {from: from, to: to, text: code, origin: origin})\\n}\\n\\n// Rebasing/resetting history to deal with externally-sourced changes\\n\\nfunction rebaseHistSelSingle(pos, from, to, diff) {\\n  if (to < pos.line) {\\n    pos.line += diff\\n  } else if (from < pos.line) {\\n    pos.line = from\\n    pos.ch = 0\\n  }\\n}\\n\\n// Tries to rebase an array of history events given a change in the\\n// document. If the change touches the same lines as the event, the\\n// event, and everything 'behind' it, is discarded. If the change is\\n// before the event, the event's positions are updated. Uses a\\n// copy-on-write scheme for the positions, to avoid having to\\n// reallocate them all on every rebase, but also avoid problems with\\n// shared position objects being unsafely updated.\\nfunction rebaseHistArray(array, from, to, diff) {\\n  for (var i = 0; i < array.length; ++i) {\\n    var sub = array[i], ok = true\\n    if (sub.ranges) {\\n      if (!sub.copied) { sub = array[i] = sub.deepCopy(); sub.copied = true }\\n      for (var j = 0; j < sub.ranges.length; j++) {\\n        rebaseHistSelSingle(sub.ranges[j].anchor, from, to, diff)\\n        rebaseHistSelSingle(sub.ranges[j].head, from, to, diff)\\n      }\\n      continue\\n    }\\n    for (var j$1 = 0; j$1 < sub.changes.length; ++j$1) {\\n      var cur = sub.changes[j$1]\\n      if (to < cur.from.line) {\\n        cur.from = Pos(cur.from.line + diff, cur.from.ch)\\n        cur.to = Pos(cur.to.line + diff, cur.to.ch)\\n      } else if (from <= cur.to.line) {\\n        ok = false\\n        break\\n      }\\n    }\\n    if (!ok) {\\n      array.splice(0, i + 1)\\n      i = 0\\n    }\\n  }\\n}\\n\\nfunction rebaseHist(hist, change) {\\n  var from = change.from.line, to = change.to.line, diff = change.text.length - (to - from) - 1\\n  rebaseHistArray(hist.done, from, to, diff)\\n  rebaseHistArray(hist.undone, from, to, diff)\\n}\\n\\n// Utility for applying a change to a line by handle or number,\\n// returning the number and optionally registering the line as\\n// changed.\\nfunction changeLine(doc, handle, changeType, op) {\\n  var no = handle, line = handle\\n  if (typeof handle == \\\"number\\\") { line = getLine(doc, clipLine(doc, handle)) }\\n  else { no = lineNo(handle) }\\n  if (no == null) { return null }\\n  if (op(line, no) && doc.cm) { regLineChange(doc.cm, no, changeType) }\\n  return line\\n}\\n\\n// The document is represented as a BTree consisting of leaves, with\\n// chunk of lines in them, and branches, with up to ten leaves or\\n// other branch nodes below them. The top node is always a branch\\n// node, and is the document object itself (meaning it has\\n// additional methods and properties).\\n//\\n// All nodes have parent links. The tree is used both to go from\\n// line numbers to line objects, and to go from objects to numbers.\\n// It also indexes by height, and is used to convert between height\\n// and line object, and to find the total height of the document.\\n//\\n// See also http://marijnhaverbeke.nl/blog/codemirror-line-tree.html\\n\\nvar LeafChunk = function(lines) {\\n  var this$1 = this;\\n\\n  this.lines = lines\\n  this.parent = null\\n  var height = 0\\n  for (var i = 0; i < lines.length; ++i) {\\n    lines[i].parent = this$1\\n    height += lines[i].height\\n  }\\n  this.height = height\\n};\\n\\nLeafChunk.prototype.chunkSize = function () { return this.lines.length };\\n\\n// Remove the n lines at offset 'at'.\\nLeafChunk.prototype.removeInner = function (at, n) {\\n    var this$1 = this;\\n\\n  for (var i = at, e = at + n; i < e; ++i) {\\n    var line = this$1.lines[i]\\n    this$1.height -= line.height\\n    cleanUpLine(line)\\n    signalLater(line, \\\"delete\\\")\\n  }\\n  this.lines.splice(at, n)\\n};\\n\\n// Helper used to collapse a small branch into a single leaf.\\nLeafChunk.prototype.collapse = function (lines) {\\n  lines.push.apply(lines, this.lines)\\n};\\n\\n// Insert the given array of lines at offset 'at', count them as\\n// having the given height.\\nLeafChunk.prototype.insertInner = function (at, lines, height) {\\n    var this$1 = this;\\n\\n  this.height += height\\n  this.lines = this.lines.slice(0, at).concat(lines).concat(this.lines.slice(at))\\n  for (var i = 0; i < lines.length; ++i) { lines[i].parent = this$1 }\\n};\\n\\n// Used to iterate over a part of the tree.\\nLeafChunk.prototype.iterN = function (at, n, op) {\\n    var this$1 = this;\\n\\n  for (var e = at + n; at < e; ++at)\\n    { if (op(this$1.lines[at])) { return true } }\\n};\\n\\nvar BranchChunk = function(children) {\\n  var this$1 = this;\\n\\n  this.children = children\\n  var size = 0, height = 0\\n  for (var i = 0; i < children.length; ++i) {\\n    var ch = children[i]\\n    size += ch.chunkSize(); height += ch.height\\n    ch.parent = this$1\\n  }\\n  this.size = size\\n  this.height = height\\n  this.parent = null\\n};\\n\\nBranchChunk.prototype.chunkSize = function () { return this.size };\\n\\nBranchChunk.prototype.removeInner = function (at, n) {\\n    var this$1 = this;\\n\\n  this.size -= n\\n  for (var i = 0; i < this.children.length; ++i) {\\n    var child = this$1.children[i], sz = child.chunkSize()\\n    if (at < sz) {\\n      var rm = Math.min(n, sz - at), oldHeight = child.height\\n      child.removeInner(at, rm)\\n      this$1.height -= oldHeight - child.height\\n      if (sz == rm) { this$1.children.splice(i--, 1); child.parent = null }\\n      if ((n -= rm) == 0) { break }\\n      at = 0\\n    } else { at -= sz }\\n  }\\n  // If the result is smaller than 25 lines, ensure that it is a\\n  // single leaf node.\\n  if (this.size - n < 25 &&\\n      (this.children.length > 1 || !(this.children[0] instanceof LeafChunk))) {\\n    var lines = []\\n    this.collapse(lines)\\n    this.children = [new LeafChunk(lines)]\\n    this.children[0].parent = this\\n  }\\n};\\n\\nBranchChunk.prototype.collapse = function (lines) {\\n    var this$1 = this;\\n\\n  for (var i = 0; i < this.children.length; ++i) { this$1.children[i].collapse(lines) }\\n};\\n\\nBranchChunk.prototype.insertInner = function (at, lines, height) {\\n    var this$1 = this;\\n\\n  this.size += lines.length\\n  this.height += height\\n  for (var i = 0; i < this.children.length; ++i) {\\n    var child = this$1.children[i], sz = child.chunkSize()\\n    if (at <= sz) {\\n      child.insertInner(at, lines, height)\\n      if (child.lines && child.lines.length > 50) {\\n        // To avoid memory thrashing when child.lines is huge (e.g. first view of a large file), it's never spliced.\\n        // Instead, small slices are taken. They're taken in order because sequential memory accesses are fastest.\\n        var remaining = child.lines.length % 25 + 25\\n        for (var pos = remaining; pos < child.lines.length;) {\\n          var leaf = new LeafChunk(child.lines.slice(pos, pos += 25))\\n          child.height -= leaf.height\\n          this$1.children.splice(++i, 0, leaf)\\n          leaf.parent = this$1\\n        }\\n        child.lines = child.lines.slice(0, remaining)\\n        this$1.maybeSpill()\\n      }\\n      break\\n    }\\n    at -= sz\\n  }\\n};\\n\\n// When a node has grown, check whether it should be split.\\nBranchChunk.prototype.maybeSpill = function () {\\n  if (this.children.length <= 10) { return }\\n  var me = this\\n  do {\\n    var spilled = me.children.splice(me.children.length - 5, 5)\\n    var sibling = new BranchChunk(spilled)\\n    if (!me.parent) { // Become the parent node\\n      var copy = new BranchChunk(me.children)\\n      copy.parent = me\\n      me.children = [copy, sibling]\\n      me = copy\\n   } else {\\n      me.size -= sibling.size\\n      me.height -= sibling.height\\n      var myIndex = indexOf(me.parent.children, me)\\n      me.parent.children.splice(myIndex + 1, 0, sibling)\\n    }\\n    sibling.parent = me.parent\\n  } while (me.children.length > 10)\\n  me.parent.maybeSpill()\\n};\\n\\nBranchChunk.prototype.iterN = function (at, n, op) {\\n    var this$1 = this;\\n\\n  for (var i = 0; i < this.children.length; ++i) {\\n    var child = this$1.children[i], sz = child.chunkSize()\\n    if (at < sz) {\\n      var used = Math.min(n, sz - at)\\n      if (child.iterN(at, used, op)) { return true }\\n      if ((n -= used) == 0) { break }\\n      at = 0\\n    } else { at -= sz }\\n  }\\n};\\n\\n// Line widgets are block elements displayed above or below a line.\\n\\nvar LineWidget = function(doc, node, options) {\\n  var this$1 = this;\\n\\n  if (options) { for (var opt in options) { if (options.hasOwnProperty(opt))\\n    { this$1[opt] = options[opt] } } }\\n  this.doc = doc\\n  this.node = node\\n};\\n\\nLineWidget.prototype.clear = function () {\\n    var this$1 = this;\\n\\n  var cm = this.doc.cm, ws = this.line.widgets, line = this.line, no = lineNo(line)\\n  if (no == null || !ws) { return }\\n  for (var i = 0; i < ws.length; ++i) { if (ws[i] == this$1) { ws.splice(i--, 1) } }\\n  if (!ws.length) { line.widgets = null }\\n  var height = widgetHeight(this)\\n  updateLineHeight(line, Math.max(0, line.height - height))\\n  if (cm) {\\n    runInOp(cm, function () {\\n      adjustScrollWhenAboveVisible(cm, line, -height)\\n      regLineChange(cm, no, \\\"widget\\\")\\n    })\\n    signalLater(cm, \\\"lineWidgetCleared\\\", cm, this, no)\\n  }\\n};\\n\\nLineWidget.prototype.changed = function () {\\n    var this$1 = this;\\n\\n  var oldH = this.height, cm = this.doc.cm, line = this.line\\n  this.height = null\\n  var diff = widgetHeight(this) - oldH\\n  if (!diff) { return }\\n  updateLineHeight(line, line.height + diff)\\n  if (cm) {\\n    runInOp(cm, function () {\\n      cm.curOp.forceUpdate = true\\n      adjustScrollWhenAboveVisible(cm, line, diff)\\n      signalLater(cm, \\\"lineWidgetChanged\\\", cm, this$1, lineNo(line))\\n    })\\n  }\\n};\\neventMixin(LineWidget)\\n\\nfunction adjustScrollWhenAboveVisible(cm, line, diff) {\\n  if (heightAtLine(line) < ((cm.curOp && cm.curOp.scrollTop) || cm.doc.scrollTop))\\n    { addToScrollPos(cm, null, diff) }\\n}\\n\\nfunction addLineWidget(doc, handle, node, options) {\\n  var widget = new LineWidget(doc, node, options)\\n  var cm = doc.cm\\n  if (cm && widget.noHScroll) { cm.display.alignWidgets = true }\\n  changeLine(doc, handle, \\\"widget\\\", function (line) {\\n    var widgets = line.widgets || (line.widgets = [])\\n    if (widget.insertAt == null) { widgets.push(widget) }\\n    else { widgets.splice(Math.min(widgets.length - 1, Math.max(0, widget.insertAt)), 0, widget) }\\n    widget.line = line\\n    if (cm && !lineIsHidden(doc, line)) {\\n      var aboveVisible = heightAtLine(line) < doc.scrollTop\\n      updateLineHeight(line, line.height + widgetHeight(widget))\\n      if (aboveVisible) { addToScrollPos(cm, null, widget.height) }\\n      cm.curOp.forceUpdate = true\\n    }\\n    return true\\n  })\\n  signalLater(cm, \\\"lineWidgetAdded\\\", cm, widget, typeof handle == \\\"number\\\" ? handle : lineNo(handle))\\n  return widget\\n}\\n\\n// TEXTMARKERS\\n\\n// Created with markText and setBookmark methods. A TextMarker is a\\n// handle that can be used to clear or find a marked position in the\\n// document. Line objects hold arrays (markedSpans) containing\\n// {from, to, marker} object pointing to such marker objects, and\\n// indicating that such a marker is present on that line. Multiple\\n// lines may point to the same marker when it spans across lines.\\n// The spans will have null for their from/to properties when the\\n// marker continues beyond the start/end of the line. Markers have\\n// links back to the lines they currently touch.\\n\\n// Collapsed markers have unique ids, in order to be able to order\\n// them, which is needed for uniquely determining an outer marker\\n// when they overlap (they may nest, but not partially overlap).\\nvar nextMarkerId = 0\\n\\nvar TextMarker = function(doc, type) {\\n  this.lines = []\\n  this.type = type\\n  this.doc = doc\\n  this.id = ++nextMarkerId\\n};\\n\\n// Clear the marker.\\nTextMarker.prototype.clear = function () {\\n    var this$1 = this;\\n\\n  if (this.explicitlyCleared) { return }\\n  var cm = this.doc.cm, withOp = cm && !cm.curOp\\n  if (withOp) { startOperation(cm) }\\n  if (hasHandler(this, \\\"clear\\\")) {\\n    var found = this.find()\\n    if (found) { signalLater(this, \\\"clear\\\", found.from, found.to) }\\n  }\\n  var min = null, max = null\\n  for (var i = 0; i < this.lines.length; ++i) {\\n    var line = this$1.lines[i]\\n    var span = getMarkedSpanFor(line.markedSpans, this$1)\\n    if (cm && !this$1.collapsed) { regLineChange(cm, lineNo(line), \\\"text\\\") }\\n    else if (cm) {\\n      if (span.to != null) { max = lineNo(line) }\\n      if (span.from != null) { min = lineNo(line) }\\n    }\\n    line.markedSpans = removeMarkedSpan(line.markedSpans, span)\\n    if (span.from == null && this$1.collapsed && !lineIsHidden(this$1.doc, line) && cm)\\n      { updateLineHeight(line, textHeight(cm.display)) }\\n  }\\n  if (cm && this.collapsed && !cm.options.lineWrapping) { for (var i$1 = 0; i$1 < this.lines.length; ++i$1) {\\n    var visual = visualLine(this$1.lines[i$1]), len = lineLength(visual)\\n    if (len > cm.display.maxLineLength) {\\n      cm.display.maxLine = visual\\n      cm.display.maxLineLength = len\\n      cm.display.maxLineChanged = true\\n    }\\n  } }\\n\\n  if (min != null && cm && this.collapsed) { regChange(cm, min, max + 1) }\\n  this.lines.length = 0\\n  this.explicitlyCleared = true\\n  if (this.atomic && this.doc.cantEdit) {\\n    this.doc.cantEdit = false\\n    if (cm) { reCheckSelection(cm.doc) }\\n  }\\n  if (cm) { signalLater(cm, \\\"markerCleared\\\", cm, this, min, max) }\\n  if (withOp) { endOperation(cm) }\\n  if (this.parent) { this.parent.clear() }\\n};\\n\\n// Find the position of the marker in the document. Returns a {from,\\n// to} object by default. Side can be passed to get a specific side\\n// -- 0 (both), -1 (left), or 1 (right). When lineObj is true, the\\n// Pos objects returned contain a line object, rather than a line\\n// number (used to prevent looking up the same line twice).\\nTextMarker.prototype.find = function (side, lineObj) {\\n    var this$1 = this;\\n\\n  if (side == null && this.type == \\\"bookmark\\\") { side = 1 }\\n  var from, to\\n  for (var i = 0; i < this.lines.length; ++i) {\\n    var line = this$1.lines[i]\\n    var span = getMarkedSpanFor(line.markedSpans, this$1)\\n    if (span.from != null) {\\n      from = Pos(lineObj ? line : lineNo(line), span.from)\\n      if (side == -1) { return from }\\n    }\\n    if (span.to != null) {\\n      to = Pos(lineObj ? line : lineNo(line), span.to)\\n      if (side == 1) { return to }\\n    }\\n  }\\n  return from && {from: from, to: to}\\n};\\n\\n// Signals that the marker's widget changed, and surrounding layout\\n// should be recomputed.\\nTextMarker.prototype.changed = function () {\\n    var this$1 = this;\\n\\n  var pos = this.find(-1, true), widget = this, cm = this.doc.cm\\n  if (!pos || !cm) { return }\\n  runInOp(cm, function () {\\n    var line = pos.line, lineN = lineNo(pos.line)\\n    var view = findViewForLine(cm, lineN)\\n    if (view) {\\n      clearLineMeasurementCacheFor(view)\\n      cm.curOp.selectionChanged = cm.curOp.forceUpdate = true\\n    }\\n    cm.curOp.updateMaxLine = true\\n    if (!lineIsHidden(widget.doc, line) && widget.height != null) {\\n      var oldHeight = widget.height\\n      widget.height = null\\n      var dHeight = widgetHeight(widget) - oldHeight\\n      if (dHeight)\\n        { updateLineHeight(line, line.height + dHeight) }\\n    }\\n    signalLater(cm, \\\"markerChanged\\\", cm, this$1)\\n  })\\n};\\n\\nTextMarker.prototype.attachLine = function (line) {\\n  if (!this.lines.length && this.doc.cm) {\\n    var op = this.doc.cm.curOp\\n    if (!op.maybeHiddenMarkers || indexOf(op.maybeHiddenMarkers, this) == -1)\\n      { (op.maybeUnhiddenMarkers || (op.maybeUnhiddenMarkers = [])).push(this) }\\n  }\\n  this.lines.push(line)\\n};\\n\\nTextMarker.prototype.detachLine = function (line) {\\n  this.lines.splice(indexOf(this.lines, line), 1)\\n  if (!this.lines.length && this.doc.cm) {\\n    var op = this.doc.cm.curOp\\n    ;(op.maybeHiddenMarkers || (op.maybeHiddenMarkers = [])).push(this)\\n  }\\n};\\neventMixin(TextMarker)\\n\\n// Create a marker, wire it up to the right lines, and\\nfunction markText(doc, from, to, options, type) {\\n  // Shared markers (across linked documents) are handled separately\\n  // (markTextShared will call out to this again, once per\\n  // document).\\n  if (options && options.shared) { return markTextShared(doc, from, to, options, type) }\\n  // Ensure we are in an operation.\\n  if (doc.cm && !doc.cm.curOp) { return operation(doc.cm, markText)(doc, from, to, options, type) }\\n\\n  var marker = new TextMarker(doc, type), diff = cmp(from, to)\\n  if (options) { copyObj(options, marker, false) }\\n  // Don't connect empty markers unless clearWhenEmpty is false\\n  if (diff > 0 || diff == 0 && marker.clearWhenEmpty !== false)\\n    { return marker }\\n  if (marker.replacedWith) {\\n    // Showing up as a widget implies collapsed (widget replaces text)\\n    marker.collapsed = true\\n    marker.widgetNode = elt(\\\"span\\\", [marker.replacedWith], \\\"CodeMirror-widget\\\")\\n    marker.widgetNode.setAttribute(\\\"role\\\", \\\"presentation\\\") // hide from accessibility tree\\n    if (!options.handleMouseEvents) { marker.widgetNode.setAttribute(\\\"cm-ignore-events\\\", \\\"true\\\") }\\n    if (options.insertLeft) { marker.widgetNode.insertLeft = true }\\n  }\\n  if (marker.collapsed) {\\n    if (conflictingCollapsedRange(doc, from.line, from, to, marker) ||\\n        from.line != to.line && conflictingCollapsedRange(doc, to.line, from, to, marker))\\n      { throw new Error(\\\"Inserting collapsed marker partially overlapping an existing one\\\") }\\n    seeCollapsedSpans()\\n  }\\n\\n  if (marker.addToHistory)\\n    { addChangeToHistory(doc, {from: from, to: to, origin: \\\"markText\\\"}, doc.sel, NaN) }\\n\\n  var curLine = from.line, cm = doc.cm, updateMaxLine\\n  doc.iter(curLine, to.line + 1, function (line) {\\n    if (cm && marker.collapsed && !cm.options.lineWrapping && visualLine(line) == cm.display.maxLine)\\n      { updateMaxLine = true }\\n    if (marker.collapsed && curLine != from.line) { updateLineHeight(line, 0) }\\n    addMarkedSpan(line, new MarkedSpan(marker,\\n                                       curLine == from.line ? from.ch : null,\\n                                       curLine == to.line ? to.ch : null))\\n    ++curLine\\n  })\\n  // lineIsHidden depends on the presence of the spans, so needs a second pass\\n  if (marker.collapsed) { doc.iter(from.line, to.line + 1, function (line) {\\n    if (lineIsHidden(doc, line)) { updateLineHeight(line, 0) }\\n  }) }\\n\\n  if (marker.clearOnEnter) { on(marker, \\\"beforeCursorEnter\\\", function () { return marker.clear(); }) }\\n\\n  if (marker.readOnly) {\\n    seeReadOnlySpans()\\n    if (doc.history.done.length || doc.history.undone.length)\\n      { doc.clearHistory() }\\n  }\\n  if (marker.collapsed) {\\n    marker.id = ++nextMarkerId\\n    marker.atomic = true\\n  }\\n  if (cm) {\\n    // Sync editor state\\n    if (updateMaxLine) { cm.curOp.updateMaxLine = true }\\n    if (marker.collapsed)\\n      { regChange(cm, from.line, to.line + 1) }\\n    else if (marker.className || marker.title || marker.startStyle || marker.endStyle || marker.css)\\n      { for (var i = from.line; i <= to.line; i++) { regLineChange(cm, i, \\\"text\\\") } }\\n    if (marker.atomic) { reCheckSelection(cm.doc) }\\n    signalLater(cm, \\\"markerAdded\\\", cm, marker)\\n  }\\n  return marker\\n}\\n\\n// SHARED TEXTMARKERS\\n\\n// A shared marker spans multiple linked documents. It is\\n// implemented as a meta-marker-object controlling multiple normal\\n// markers.\\nvar SharedTextMarker = function(markers, primary) {\\n  var this$1 = this;\\n\\n  this.markers = markers\\n  this.primary = primary\\n  for (var i = 0; i < markers.length; ++i)\\n    { markers[i].parent = this$1 }\\n};\\n\\nSharedTextMarker.prototype.clear = function () {\\n    var this$1 = this;\\n\\n  if (this.explicitlyCleared) { return }\\n  this.explicitlyCleared = true\\n  for (var i = 0; i < this.markers.length; ++i)\\n    { this$1.markers[i].clear() }\\n  signalLater(this, \\\"clear\\\")\\n};\\n\\nSharedTextMarker.prototype.find = function (side, lineObj) {\\n  return this.primary.find(side, lineObj)\\n};\\neventMixin(SharedTextMarker)\\n\\nfunction markTextShared(doc, from, to, options, type) {\\n  options = copyObj(options)\\n  options.shared = false\\n  var markers = [markText(doc, from, to, options, type)], primary = markers[0]\\n  var widget = options.widgetNode\\n  linkedDocs(doc, function (doc) {\\n    if (widget) { options.widgetNode = widget.cloneNode(true) }\\n    markers.push(markText(doc, clipPos(doc, from), clipPos(doc, to), options, type))\\n    for (var i = 0; i < doc.linked.length; ++i)\\n      { if (doc.linked[i].isParent) { return } }\\n    primary = lst(markers)\\n  })\\n  return new SharedTextMarker(markers, primary)\\n}\\n\\nfunction findSharedMarkers(doc) {\\n  return doc.findMarks(Pos(doc.first, 0), doc.clipPos(Pos(doc.lastLine())), function (m) { return m.parent; })\\n}\\n\\nfunction copySharedMarkers(doc, markers) {\\n  for (var i = 0; i < markers.length; i++) {\\n    var marker = markers[i], pos = marker.find()\\n    var mFrom = doc.clipPos(pos.from), mTo = doc.clipPos(pos.to)\\n    if (cmp(mFrom, mTo)) {\\n      var subMark = markText(doc, mFrom, mTo, marker.primary, marker.primary.type)\\n      marker.markers.push(subMark)\\n      subMark.parent = marker\\n    }\\n  }\\n}\\n\\nfunction detachSharedMarkers(markers) {\\n  var loop = function ( i ) {\\n    var marker = markers[i], linked = [marker.primary.doc]\\n    linkedDocs(marker.primary.doc, function (d) { return linked.push(d); })\\n    for (var j = 0; j < marker.markers.length; j++) {\\n      var subMarker = marker.markers[j]\\n      if (indexOf(linked, subMarker.doc) == -1) {\\n        subMarker.parent = null\\n        marker.markers.splice(j--, 1)\\n      }\\n    }\\n  };\\n\\n  for (var i = 0; i < markers.length; i++) loop( i );\\n}\\n\\nvar nextDocId = 0\\nvar Doc = function(text, mode, firstLine, lineSep) {\\n  if (!(this instanceof Doc)) { return new Doc(text, mode, firstLine, lineSep) }\\n  if (firstLine == null) { firstLine = 0 }\\n\\n  BranchChunk.call(this, [new LeafChunk([new Line(\\\"\\\", null)])])\\n  this.first = firstLine\\n  this.scrollTop = this.scrollLeft = 0\\n  this.cantEdit = false\\n  this.cleanGeneration = 1\\n  this.frontier = firstLine\\n  var start = Pos(firstLine, 0)\\n  this.sel = simpleSelection(start)\\n  this.history = new History(null)\\n  this.id = ++nextDocId\\n  this.modeOption = mode\\n  this.lineSep = lineSep\\n  this.extend = false\\n\\n  if (typeof text == \\\"string\\\") { text = this.splitLines(text) }\\n  updateDoc(this, {from: start, to: start, text: text})\\n  setSelection(this, simpleSelection(start), sel_dontScroll)\\n}\\n\\nDoc.prototype = createObj(BranchChunk.prototype, {\\n  constructor: Doc,\\n  // Iterate over the document. Supports two forms -- with only one\\n  // argument, it calls that for each line in the document. With\\n  // three, it iterates over the range given by the first two (with\\n  // the second being non-inclusive).\\n  iter: function(from, to, op) {\\n    if (op) { this.iterN(from - this.first, to - from, op) }\\n    else { this.iterN(this.first, this.first + this.size, from) }\\n  },\\n\\n  // Non-public interface for adding and removing lines.\\n  insert: function(at, lines) {\\n    var height = 0\\n    for (var i = 0; i < lines.length; ++i) { height += lines[i].height }\\n    this.insertInner(at - this.first, lines, height)\\n  },\\n  remove: function(at, n) { this.removeInner(at - this.first, n) },\\n\\n  // From here, the methods are part of the public interface. Most\\n  // are also available from CodeMirror (editor) instances.\\n\\n  getValue: function(lineSep) {\\n    var lines = getLines(this, this.first, this.first + this.size)\\n    if (lineSep === false) { return lines }\\n    return lines.join(lineSep || this.lineSeparator())\\n  },\\n  setValue: docMethodOp(function(code) {\\n    var top = Pos(this.first, 0), last = this.first + this.size - 1\\n    makeChange(this, {from: top, to: Pos(last, getLine(this, last).text.length),\\n                      text: this.splitLines(code), origin: \\\"setValue\\\", full: true}, true)\\n    setSelection(this, simpleSelection(top))\\n  }),\\n  replaceRange: function(code, from, to, origin) {\\n    from = clipPos(this, from)\\n    to = to ? clipPos(this, to) : from\\n    replaceRange(this, code, from, to, origin)\\n  },\\n  getRange: function(from, to, lineSep) {\\n    var lines = getBetween(this, clipPos(this, from), clipPos(this, to))\\n    if (lineSep === false) { return lines }\\n    return lines.join(lineSep || this.lineSeparator())\\n  },\\n\\n  getLine: function(line) {var l = this.getLineHandle(line); return l && l.text},\\n\\n  getLineHandle: function(line) {if (isLine(this, line)) { return getLine(this, line) }},\\n  getLineNumber: function(line) {return lineNo(line)},\\n\\n  getLineHandleVisualStart: function(line) {\\n    if (typeof line == \\\"number\\\") { line = getLine(this, line) }\\n    return visualLine(line)\\n  },\\n\\n  lineCount: function() {return this.size},\\n  firstLine: function() {return this.first},\\n  lastLine: function() {return this.first + this.size - 1},\\n\\n  clipPos: function(pos) {return clipPos(this, pos)},\\n\\n  getCursor: function(start) {\\n    var range = this.sel.primary(), pos\\n    if (start == null || start == \\\"head\\\") { pos = range.head }\\n    else if (start == \\\"anchor\\\") { pos = range.anchor }\\n    else if (start == \\\"end\\\" || start == \\\"to\\\" || start === false) { pos = range.to() }\\n    else { pos = range.from() }\\n    return pos\\n  },\\n  listSelections: function() { return this.sel.ranges },\\n  somethingSelected: function() {return this.sel.somethingSelected()},\\n\\n  setCursor: docMethodOp(function(line, ch, options) {\\n    setSimpleSelection(this, clipPos(this, typeof line == \\\"number\\\" ? Pos(line, ch || 0) : line), null, options)\\n  }),\\n  setSelection: docMethodOp(function(anchor, head, options) {\\n    setSimpleSelection(this, clipPos(this, anchor), clipPos(this, head || anchor), options)\\n  }),\\n  extendSelection: docMethodOp(function(head, other, options) {\\n    extendSelection(this, clipPos(this, head), other && clipPos(this, other), options)\\n  }),\\n  extendSelections: docMethodOp(function(heads, options) {\\n    extendSelections(this, clipPosArray(this, heads), options)\\n  }),\\n  extendSelectionsBy: docMethodOp(function(f, options) {\\n    var heads = map(this.sel.ranges, f)\\n    extendSelections(this, clipPosArray(this, heads), options)\\n  }),\\n  setSelections: docMethodOp(function(ranges, primary, options) {\\n    var this$1 = this;\\n\\n    if (!ranges.length) { return }\\n    var out = []\\n    for (var i = 0; i < ranges.length; i++)\\n      { out[i] = new Range(clipPos(this$1, ranges[i].anchor),\\n                         clipPos(this$1, ranges[i].head)) }\\n    if (primary == null) { primary = Math.min(ranges.length - 1, this.sel.primIndex) }\\n    setSelection(this, normalizeSelection(out, primary), options)\\n  }),\\n  addSelection: docMethodOp(function(anchor, head, options) {\\n    var ranges = this.sel.ranges.slice(0)\\n    ranges.push(new Range(clipPos(this, anchor), clipPos(this, head || anchor)))\\n    setSelection(this, normalizeSelection(ranges, ranges.length - 1), options)\\n  }),\\n\\n  getSelection: function(lineSep) {\\n    var this$1 = this;\\n\\n    var ranges = this.sel.ranges, lines\\n    for (var i = 0; i < ranges.length; i++) {\\n      var sel = getBetween(this$1, ranges[i].from(), ranges[i].to())\\n      lines = lines ? lines.concat(sel) : sel\\n    }\\n    if (lineSep === false) { return lines }\\n    else { return lines.join(lineSep || this.lineSeparator()) }\\n  },\\n  getSelections: function(lineSep) {\\n    var this$1 = this;\\n\\n    var parts = [], ranges = this.sel.ranges\\n    for (var i = 0; i < ranges.length; i++) {\\n      var sel = getBetween(this$1, ranges[i].from(), ranges[i].to())\\n      if (lineSep !== false) { sel = sel.join(lineSep || this$1.lineSeparator()) }\\n      parts[i] = sel\\n    }\\n    return parts\\n  },\\n  replaceSelection: function(code, collapse, origin) {\\n    var dup = []\\n    for (var i = 0; i < this.sel.ranges.length; i++)\\n      { dup[i] = code }\\n    this.replaceSelections(dup, collapse, origin || \\\"+input\\\")\\n  },\\n  replaceSelections: docMethodOp(function(code, collapse, origin) {\\n    var this$1 = this;\\n\\n    var changes = [], sel = this.sel\\n    for (var i = 0; i < sel.ranges.length; i++) {\\n      var range = sel.ranges[i]\\n      changes[i] = {from: range.from(), to: range.to(), text: this$1.splitLines(code[i]), origin: origin}\\n    }\\n    var newSel = collapse && collapse != \\\"end\\\" && computeReplacedSel(this, changes, collapse)\\n    for (var i$1 = changes.length - 1; i$1 >= 0; i$1--)\\n      { makeChange(this$1, changes[i$1]) }\\n    if (newSel) { setSelectionReplaceHistory(this, newSel) }\\n    else if (this.cm) { ensureCursorVisible(this.cm) }\\n  }),\\n  undo: docMethodOp(function() {makeChangeFromHistory(this, \\\"undo\\\")}),\\n  redo: docMethodOp(function() {makeChangeFromHistory(this, \\\"redo\\\")}),\\n  undoSelection: docMethodOp(function() {makeChangeFromHistory(this, \\\"undo\\\", true)}),\\n  redoSelection: docMethodOp(function() {makeChangeFromHistory(this, \\\"redo\\\", true)}),\\n\\n  setExtending: function(val) {this.extend = val},\\n  getExtending: function() {return this.extend},\\n\\n  historySize: function() {\\n    var hist = this.history, done = 0, undone = 0\\n    for (var i = 0; i < hist.done.length; i++) { if (!hist.done[i].ranges) { ++done } }\\n    for (var i$1 = 0; i$1 < hist.undone.length; i$1++) { if (!hist.undone[i$1].ranges) { ++undone } }\\n    return {undo: done, redo: undone}\\n  },\\n  clearHistory: function() {this.history = new History(this.history.maxGeneration)},\\n\\n  markClean: function() {\\n    this.cleanGeneration = this.changeGeneration(true)\\n  },\\n  changeGeneration: function(forceSplit) {\\n    if (forceSplit)\\n      { this.history.lastOp = this.history.lastSelOp = this.history.lastOrigin = null }\\n    return this.history.generation\\n  },\\n  isClean: function (gen) {\\n    return this.history.generation == (gen || this.cleanGeneration)\\n  },\\n\\n  getHistory: function() {\\n    return {done: copyHistoryArray(this.history.done),\\n            undone: copyHistoryArray(this.history.undone)}\\n  },\\n  setHistory: function(histData) {\\n    var hist = this.history = new History(this.history.maxGeneration)\\n    hist.done = copyHistoryArray(histData.done.slice(0), null, true)\\n    hist.undone = copyHistoryArray(histData.undone.slice(0), null, true)\\n  },\\n\\n  setGutterMarker: docMethodOp(function(line, gutterID, value) {\\n    return changeLine(this, line, \\\"gutter\\\", function (line) {\\n      var markers = line.gutterMarkers || (line.gutterMarkers = {})\\n      markers[gutterID] = value\\n      if (!value && isEmpty(markers)) { line.gutterMarkers = null }\\n      return true\\n    })\\n  }),\\n\\n  clearGutter: docMethodOp(function(gutterID) {\\n    var this$1 = this;\\n\\n    this.iter(function (line) {\\n      if (line.gutterMarkers && line.gutterMarkers[gutterID]) {\\n        changeLine(this$1, line, \\\"gutter\\\", function () {\\n          line.gutterMarkers[gutterID] = null\\n          if (isEmpty(line.gutterMarkers)) { line.gutterMarkers = null }\\n          return true\\n        })\\n      }\\n    })\\n  }),\\n\\n  lineInfo: function(line) {\\n    var n\\n    if (typeof line == \\\"number\\\") {\\n      if (!isLine(this, line)) { return null }\\n      n = line\\n      line = getLine(this, line)\\n      if (!line) { return null }\\n    } else {\\n      n = lineNo(line)\\n      if (n == null) { return null }\\n    }\\n    return {line: n, handle: line, text: line.text, gutterMarkers: line.gutterMarkers,\\n            textClass: line.textClass, bgClass: line.bgClass, wrapClass: line.wrapClass,\\n            widgets: line.widgets}\\n  },\\n\\n  addLineClass: docMethodOp(function(handle, where, cls) {\\n    return changeLine(this, handle, where == \\\"gutter\\\" ? \\\"gutter\\\" : \\\"class\\\", function (line) {\\n      var prop = where == \\\"text\\\" ? \\\"textClass\\\"\\n               : where == \\\"background\\\" ? \\\"bgClass\\\"\\n               : where == \\\"gutter\\\" ? \\\"gutterClass\\\" : \\\"wrapClass\\\"\\n      if (!line[prop]) { line[prop] = cls }\\n      else if (classTest(cls).test(line[prop])) { return false }\\n      else { line[prop] += \\\" \\\" + cls }\\n      return true\\n    })\\n  }),\\n  removeLineClass: docMethodOp(function(handle, where, cls) {\\n    return changeLine(this, handle, where == \\\"gutter\\\" ? \\\"gutter\\\" : \\\"class\\\", function (line) {\\n      var prop = where == \\\"text\\\" ? \\\"textClass\\\"\\n               : where == \\\"background\\\" ? \\\"bgClass\\\"\\n               : where == \\\"gutter\\\" ? \\\"gutterClass\\\" : \\\"wrapClass\\\"\\n      var cur = line[prop]\\n      if (!cur) { return false }\\n      else if (cls == null) { line[prop] = null }\\n      else {\\n        var found = cur.match(classTest(cls))\\n        if (!found) { return false }\\n        var end = found.index + found[0].length\\n        line[prop] = cur.slice(0, found.index) + (!found.index || end == cur.length ? \\\"\\\" : \\\" \\\") + cur.slice(end) || null\\n      }\\n      return true\\n    })\\n  }),\\n\\n  addLineWidget: docMethodOp(function(handle, node, options) {\\n    return addLineWidget(this, handle, node, options)\\n  }),\\n  removeLineWidget: function(widget) { widget.clear() },\\n\\n  markText: function(from, to, options) {\\n    return markText(this, clipPos(this, from), clipPos(this, to), options, options && options.type || \\\"range\\\")\\n  },\\n  setBookmark: function(pos, options) {\\n    var realOpts = {replacedWith: options && (options.nodeType == null ? options.widget : options),\\n                    insertLeft: options && options.insertLeft,\\n                    clearWhenEmpty: false, shared: options && options.shared,\\n                    handleMouseEvents: options && options.handleMouseEvents}\\n    pos = clipPos(this, pos)\\n    return markText(this, pos, pos, realOpts, \\\"bookmark\\\")\\n  },\\n  findMarksAt: function(pos) {\\n    pos = clipPos(this, pos)\\n    var markers = [], spans = getLine(this, pos.line).markedSpans\\n    if (spans) { for (var i = 0; i < spans.length; ++i) {\\n      var span = spans[i]\\n      if ((span.from == null || span.from <= pos.ch) &&\\n          (span.to == null || span.to >= pos.ch))\\n        { markers.push(span.marker.parent || span.marker) }\\n    } }\\n    return markers\\n  },\\n  findMarks: function(from, to, filter) {\\n    from = clipPos(this, from); to = clipPos(this, to)\\n    var found = [], lineNo = from.line\\n    this.iter(from.line, to.line + 1, function (line) {\\n      var spans = line.markedSpans\\n      if (spans) { for (var i = 0; i < spans.length; i++) {\\n        var span = spans[i]\\n        if (!(span.to != null && lineNo == from.line && from.ch >= span.to ||\\n              span.from == null && lineNo != from.line ||\\n              span.from != null && lineNo == to.line && span.from >= to.ch) &&\\n            (!filter || filter(span.marker)))\\n          { found.push(span.marker.parent || span.marker) }\\n      } }\\n      ++lineNo\\n    })\\n    return found\\n  },\\n  getAllMarks: function() {\\n    var markers = []\\n    this.iter(function (line) {\\n      var sps = line.markedSpans\\n      if (sps) { for (var i = 0; i < sps.length; ++i)\\n        { if (sps[i].from != null) { markers.push(sps[i].marker) } } }\\n    })\\n    return markers\\n  },\\n\\n  posFromIndex: function(off) {\\n    var ch, lineNo = this.first, sepSize = this.lineSeparator().length\\n    this.iter(function (line) {\\n      var sz = line.text.length + sepSize\\n      if (sz > off) { ch = off; return true }\\n      off -= sz\\n      ++lineNo\\n    })\\n    return clipPos(this, Pos(lineNo, ch))\\n  },\\n  indexFromPos: function (coords) {\\n    coords = clipPos(this, coords)\\n    var index = coords.ch\\n    if (coords.line < this.first || coords.ch < 0) { return 0 }\\n    var sepSize = this.lineSeparator().length\\n    this.iter(this.first, coords.line, function (line) { // iter aborts when callback returns a truthy value\\n      index += line.text.length + sepSize\\n    })\\n    return index\\n  },\\n\\n  copy: function(copyHistory) {\\n    var doc = new Doc(getLines(this, this.first, this.first + this.size),\\n                      this.modeOption, this.first, this.lineSep)\\n    doc.scrollTop = this.scrollTop; doc.scrollLeft = this.scrollLeft\\n    doc.sel = this.sel\\n    doc.extend = false\\n    if (copyHistory) {\\n      doc.history.undoDepth = this.history.undoDepth\\n      doc.setHistory(this.getHistory())\\n    }\\n    return doc\\n  },\\n\\n  linkedDoc: function(options) {\\n    if (!options) { options = {} }\\n    var from = this.first, to = this.first + this.size\\n    if (options.from != null && options.from > from) { from = options.from }\\n    if (options.to != null && options.to < to) { to = options.to }\\n    var copy = new Doc(getLines(this, from, to), options.mode || this.modeOption, from, this.lineSep)\\n    if (options.sharedHist) { copy.history = this.history\\n    ; }(this.linked || (this.linked = [])).push({doc: copy, sharedHist: options.sharedHist})\\n    copy.linked = [{doc: this, isParent: true, sharedHist: options.sharedHist}]\\n    copySharedMarkers(copy, findSharedMarkers(this))\\n    return copy\\n  },\\n  unlinkDoc: function(other) {\\n    var this$1 = this;\\n\\n    if (other instanceof CodeMirror) { other = other.doc }\\n    if (this.linked) { for (var i = 0; i < this.linked.length; ++i) {\\n      var link = this$1.linked[i]\\n      if (link.doc != other) { continue }\\n      this$1.linked.splice(i, 1)\\n      other.unlinkDoc(this$1)\\n      detachSharedMarkers(findSharedMarkers(this$1))\\n      break\\n    } }\\n    // If the histories were shared, split them again\\n    if (other.history == this.history) {\\n      var splitIds = [other.id]\\n      linkedDocs(other, function (doc) { return splitIds.push(doc.id); }, true)\\n      other.history = new History(null)\\n      other.history.done = copyHistoryArray(this.history.done, splitIds)\\n      other.history.undone = copyHistoryArray(this.history.undone, splitIds)\\n    }\\n  },\\n  iterLinkedDocs: function(f) {linkedDocs(this, f)},\\n\\n  getMode: function() {return this.mode},\\n  getEditor: function() {return this.cm},\\n\\n  splitLines: function(str) {\\n    if (this.lineSep) { return str.split(this.lineSep) }\\n    return splitLinesAuto(str)\\n  },\\n  lineSeparator: function() { return this.lineSep || \\\"\\\\n\\\" }\\n})\\n\\n// Public alias.\\nDoc.prototype.eachLine = Doc.prototype.iter\\n\\n// Kludge to work around strange IE behavior where it'll sometimes\\n// re-fire a series of drag-related events right after the drop (#1551)\\nvar lastDrop = 0\\n\\nfunction onDrop(e) {\\n  var cm = this\\n  clearDragCursor(cm)\\n  if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e))\\n    { return }\\n  e_preventDefault(e)\\n  if (ie) { lastDrop = +new Date }\\n  var pos = posFromMouse(cm, e, true), files = e.dataTransfer.files\\n  if (!pos || cm.isReadOnly()) { return }\\n  // Might be a file drop, in which case we simply extract the text\\n  // and insert it.\\n  if (files && files.length && window.FileReader && window.File) {\\n    var n = files.length, text = Array(n), read = 0\\n    var loadFile = function (file, i) {\\n      if (cm.options.allowDropFileTypes &&\\n          indexOf(cm.options.allowDropFileTypes, file.type) == -1)\\n        { return }\\n\\n      var reader = new FileReader\\n      reader.onload = operation(cm, function () {\\n        var content = reader.result\\n        if (/[\\\\x00-\\\\x08\\\\x0e-\\\\x1f]{2}/.test(content)) { content = \\\"\\\" }\\n        text[i] = content\\n        if (++read == n) {\\n          pos = clipPos(cm.doc, pos)\\n          var change = {from: pos, to: pos,\\n                        text: cm.doc.splitLines(text.join(cm.doc.lineSeparator())),\\n                        origin: \\\"paste\\\"}\\n          makeChange(cm.doc, change)\\n          setSelectionReplaceHistory(cm.doc, simpleSelection(pos, changeEnd(change)))\\n        }\\n      })\\n      reader.readAsText(file)\\n    }\\n    for (var i = 0; i < n; ++i) { loadFile(files[i], i) }\\n  } else { // Normal drop\\n    // Don't do a replace if the drop happened inside of the selected text.\\n    if (cm.state.draggingText && cm.doc.sel.contains(pos) > -1) {\\n      cm.state.draggingText(e)\\n      // Ensure the editor is re-focused\\n      setTimeout(function () { return cm.display.input.focus(); }, 20)\\n      return\\n    }\\n    try {\\n      var text$1 = e.dataTransfer.getData(\\\"Text\\\")\\n      if (text$1) {\\n        var selected\\n        if (cm.state.draggingText && !cm.state.draggingText.copy)\\n          { selected = cm.listSelections() }\\n        setSelectionNoUndo(cm.doc, simpleSelection(pos, pos))\\n        if (selected) { for (var i$1 = 0; i$1 < selected.length; ++i$1)\\n          { replaceRange(cm.doc, \\\"\\\", selected[i$1].anchor, selected[i$1].head, \\\"drag\\\") } }\\n        cm.replaceSelection(text$1, \\\"around\\\", \\\"paste\\\")\\n        cm.display.input.focus()\\n      }\\n    }\\n    catch(e){}\\n  }\\n}\\n\\nfunction onDragStart(cm, e) {\\n  if (ie && (!cm.state.draggingText || +new Date - lastDrop < 100)) { e_stop(e); return }\\n  if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e)) { return }\\n\\n  e.dataTransfer.setData(\\\"Text\\\", cm.getSelection())\\n  e.dataTransfer.effectAllowed = \\\"copyMove\\\"\\n\\n  // Use dummy image instead of default browsers image.\\n  // Recent Safari (~6.0.2) have a tendency to segfault when this happens, so we don't do it there.\\n  if (e.dataTransfer.setDragImage && !safari) {\\n    var img = elt(\\\"img\\\", null, null, \\\"position: fixed; left: 0; top: 0;\\\")\\n    img.src = \\\"data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\\\"\\n    if (presto) {\\n      img.width = img.height = 1\\n      cm.display.wrapper.appendChild(img)\\n      // Force a relayout, or Opera won't use our image for some obscure reason\\n      img._top = img.offsetTop\\n    }\\n    e.dataTransfer.setDragImage(img, 0, 0)\\n    if (presto) { img.parentNode.removeChild(img) }\\n  }\\n}\\n\\nfunction onDragOver(cm, e) {\\n  var pos = posFromMouse(cm, e)\\n  if (!pos) { return }\\n  var frag = document.createDocumentFragment()\\n  drawSelectionCursor(cm, pos, frag)\\n  if (!cm.display.dragCursor) {\\n    cm.display.dragCursor = elt(\\\"div\\\", null, \\\"CodeMirror-cursors CodeMirror-dragcursors\\\")\\n    cm.display.lineSpace.insertBefore(cm.display.dragCursor, cm.display.cursorDiv)\\n  }\\n  removeChildrenAndAdd(cm.display.dragCursor, frag)\\n}\\n\\nfunction clearDragCursor(cm) {\\n  if (cm.display.dragCursor) {\\n    cm.display.lineSpace.removeChild(cm.display.dragCursor)\\n    cm.display.dragCursor = null\\n  }\\n}\\n\\n// These must be handled carefully, because naively registering a\\n// handler for each editor will cause the editors to never be\\n// garbage collected.\\n\\nfunction forEachCodeMirror(f) {\\n  if (!document.body.getElementsByClassName) { return }\\n  var byClass = document.body.getElementsByClassName(\\\"CodeMirror\\\")\\n  for (var i = 0; i < byClass.length; i++) {\\n    var cm = byClass[i].CodeMirror\\n    if (cm) { f(cm) }\\n  }\\n}\\n\\nvar globalsRegistered = false\\nfunction ensureGlobalHandlers() {\\n  if (globalsRegistered) { return }\\n  registerGlobalHandlers()\\n  globalsRegistered = true\\n}\\nfunction registerGlobalHandlers() {\\n  // When the window resizes, we need to refresh active editors.\\n  var resizeTimer\\n  on(window, \\\"resize\\\", function () {\\n    if (resizeTimer == null) { resizeTimer = setTimeout(function () {\\n      resizeTimer = null\\n      forEachCodeMirror(onResize)\\n    }, 100) }\\n  })\\n  // When the window loses focus, we want to show the editor as blurred\\n  on(window, \\\"blur\\\", function () { return forEachCodeMirror(onBlur); })\\n}\\n// Called when the window resizes\\nfunction onResize(cm) {\\n  var d = cm.display\\n  if (d.lastWrapHeight == d.wrapper.clientHeight && d.lastWrapWidth == d.wrapper.clientWidth)\\n    { return }\\n  // Might be a text scaling operation, clear size caches.\\n  d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null\\n  d.scrollbarsClipped = false\\n  cm.setSize()\\n}\\n\\nvar keyNames = {\\n  3: \\\"Enter\\\", 8: \\\"Backspace\\\", 9: \\\"Tab\\\", 13: \\\"Enter\\\", 16: \\\"Shift\\\", 17: \\\"Ctrl\\\", 18: \\\"Alt\\\",\\n  19: \\\"Pause\\\", 20: \\\"CapsLock\\\", 27: \\\"Esc\\\", 32: \\\"Space\\\", 33: \\\"PageUp\\\", 34: \\\"PageDown\\\", 35: \\\"End\\\",\\n  36: \\\"Home\\\", 37: \\\"Left\\\", 38: \\\"Up\\\", 39: \\\"Right\\\", 40: \\\"Down\\\", 44: \\\"PrintScrn\\\", 45: \\\"Insert\\\",\\n  46: \\\"Delete\\\", 59: \\\";\\\", 61: \\\"=\\\", 91: \\\"Mod\\\", 92: \\\"Mod\\\", 93: \\\"Mod\\\",\\n  106: \\\"*\\\", 107: \\\"=\\\", 109: \\\"-\\\", 110: \\\".\\\", 111: \\\"/\\\", 127: \\\"Delete\\\",\\n  173: \\\"-\\\", 186: \\\";\\\", 187: \\\"=\\\", 188: \\\",\\\", 189: \\\"-\\\", 190: \\\".\\\", 191: \\\"/\\\", 192: \\\"`\\\", 219: \\\"[\\\", 220: \\\"\\\\\\\\\\\",\\n  221: \\\"]\\\", 222: \\\"'\\\", 63232: \\\"Up\\\", 63233: \\\"Down\\\", 63234: \\\"Left\\\", 63235: \\\"Right\\\", 63272: \\\"Delete\\\",\\n  63273: \\\"Home\\\", 63275: \\\"End\\\", 63276: \\\"PageUp\\\", 63277: \\\"PageDown\\\", 63302: \\\"Insert\\\"\\n}\\n\\n// Number keys\\nfor (var i = 0; i < 10; i++) { keyNames[i + 48] = keyNames[i + 96] = String(i) }\\n// Alphabetic keys\\nfor (var i$1 = 65; i$1 <= 90; i$1++) { keyNames[i$1] = String.fromCharCode(i$1) }\\n// Function keys\\nfor (var i$2 = 1; i$2 <= 12; i$2++) { keyNames[i$2 + 111] = keyNames[i$2 + 63235] = \\\"F\\\" + i$2 }\\n\\nvar keyMap = {}\\n\\nkeyMap.basic = {\\n  \\\"Left\\\": \\\"goCharLeft\\\", \\\"Right\\\": \\\"goCharRight\\\", \\\"Up\\\": \\\"goLineUp\\\", \\\"Down\\\": \\\"goLineDown\\\",\\n  \\\"End\\\": \\\"goLineEnd\\\", \\\"Home\\\": \\\"goLineStartSmart\\\", \\\"PageUp\\\": \\\"goPageUp\\\", \\\"PageDown\\\": \\\"goPageDown\\\",\\n  \\\"Delete\\\": \\\"delCharAfter\\\", \\\"Backspace\\\": \\\"delCharBefore\\\", \\\"Shift-Backspace\\\": \\\"delCharBefore\\\",\\n  \\\"Tab\\\": \\\"defaultTab\\\", \\\"Shift-Tab\\\": \\\"indentAuto\\\",\\n  \\\"Enter\\\": \\\"newlineAndIndent\\\", \\\"Insert\\\": \\\"toggleOverwrite\\\",\\n  \\\"Esc\\\": \\\"singleSelection\\\"\\n}\\n// Note that the save and find-related commands aren't defined by\\n// default. User code or addons can define them. Unknown commands\\n// are simply ignored.\\nkeyMap.pcDefault = {\\n  \\\"Ctrl-A\\\": \\\"selectAll\\\", \\\"Ctrl-D\\\": \\\"deleteLine\\\", \\\"Ctrl-Z\\\": \\\"undo\\\", \\\"Shift-Ctrl-Z\\\": \\\"redo\\\", \\\"Ctrl-Y\\\": \\\"redo\\\",\\n  \\\"Ctrl-Home\\\": \\\"goDocStart\\\", \\\"Ctrl-End\\\": \\\"goDocEnd\\\", \\\"Ctrl-Up\\\": \\\"goLineUp\\\", \\\"Ctrl-Down\\\": \\\"goLineDown\\\",\\n  \\\"Ctrl-Left\\\": \\\"goGroupLeft\\\", \\\"Ctrl-Right\\\": \\\"goGroupRight\\\", \\\"Alt-Left\\\": \\\"goLineStart\\\", \\\"Alt-Right\\\": \\\"goLineEnd\\\",\\n  \\\"Ctrl-Backspace\\\": \\\"delGroupBefore\\\", \\\"Ctrl-Delete\\\": \\\"delGroupAfter\\\", \\\"Ctrl-S\\\": \\\"save\\\", \\\"Ctrl-F\\\": \\\"find\\\",\\n  \\\"Ctrl-G\\\": \\\"findNext\\\", \\\"Shift-Ctrl-G\\\": \\\"findPrev\\\", \\\"Shift-Ctrl-F\\\": \\\"replace\\\", \\\"Shift-Ctrl-R\\\": \\\"replaceAll\\\",\\n  \\\"Ctrl-[\\\": \\\"indentLess\\\", \\\"Ctrl-]\\\": \\\"indentMore\\\",\\n  \\\"Ctrl-U\\\": \\\"undoSelection\\\", \\\"Shift-Ctrl-U\\\": \\\"redoSelection\\\", \\\"Alt-U\\\": \\\"redoSelection\\\",\\n  fallthrough: \\\"basic\\\"\\n}\\n// Very basic readline/emacs-style bindings, which are standard on Mac.\\nkeyMap.emacsy = {\\n  \\\"Ctrl-F\\\": \\\"goCharRight\\\", \\\"Ctrl-B\\\": \\\"goCharLeft\\\", \\\"Ctrl-P\\\": \\\"goLineUp\\\", \\\"Ctrl-N\\\": \\\"goLineDown\\\",\\n  \\\"Alt-F\\\": \\\"goWordRight\\\", \\\"Alt-B\\\": \\\"goWordLeft\\\", \\\"Ctrl-A\\\": \\\"goLineStart\\\", \\\"Ctrl-E\\\": \\\"goLineEnd\\\",\\n  \\\"Ctrl-V\\\": \\\"goPageDown\\\", \\\"Shift-Ctrl-V\\\": \\\"goPageUp\\\", \\\"Ctrl-D\\\": \\\"delCharAfter\\\", \\\"Ctrl-H\\\": \\\"delCharBefore\\\",\\n  \\\"Alt-D\\\": \\\"delWordAfter\\\", \\\"Alt-Backspace\\\": \\\"delWordBefore\\\", \\\"Ctrl-K\\\": \\\"killLine\\\", \\\"Ctrl-T\\\": \\\"transposeChars\\\",\\n  \\\"Ctrl-O\\\": \\\"openLine\\\"\\n}\\nkeyMap.macDefault = {\\n  \\\"Cmd-A\\\": \\\"selectAll\\\", \\\"Cmd-D\\\": \\\"deleteLine\\\", \\\"Cmd-Z\\\": \\\"undo\\\", \\\"Shift-Cmd-Z\\\": \\\"redo\\\", \\\"Cmd-Y\\\": \\\"redo\\\",\\n  \\\"Cmd-Home\\\": \\\"goDocStart\\\", \\\"Cmd-Up\\\": \\\"goDocStart\\\", \\\"Cmd-End\\\": \\\"goDocEnd\\\", \\\"Cmd-Down\\\": \\\"goDocEnd\\\", \\\"Alt-Left\\\": \\\"goGroupLeft\\\",\\n  \\\"Alt-Right\\\": \\\"goGroupRight\\\", \\\"Cmd-Left\\\": \\\"goLineLeft\\\", \\\"Cmd-Right\\\": \\\"goLineRight\\\", \\\"Alt-Backspace\\\": \\\"delGroupBefore\\\",\\n  \\\"Ctrl-Alt-Backspace\\\": \\\"delGroupAfter\\\", \\\"Alt-Delete\\\": \\\"delGroupAfter\\\", \\\"Cmd-S\\\": \\\"save\\\", \\\"Cmd-F\\\": \\\"find\\\",\\n  \\\"Cmd-G\\\": \\\"findNext\\\", \\\"Shift-Cmd-G\\\": \\\"findPrev\\\", \\\"Cmd-Alt-F\\\": \\\"replace\\\", \\\"Shift-Cmd-Alt-F\\\": \\\"replaceAll\\\",\\n  \\\"Cmd-[\\\": \\\"indentLess\\\", \\\"Cmd-]\\\": \\\"indentMore\\\", \\\"Cmd-Backspace\\\": \\\"delWrappedLineLeft\\\", \\\"Cmd-Delete\\\": \\\"delWrappedLineRight\\\",\\n  \\\"Cmd-U\\\": \\\"undoSelection\\\", \\\"Shift-Cmd-U\\\": \\\"redoSelection\\\", \\\"Ctrl-Up\\\": \\\"goDocStart\\\", \\\"Ctrl-Down\\\": \\\"goDocEnd\\\",\\n  fallthrough: [\\\"basic\\\", \\\"emacsy\\\"]\\n}\\nkeyMap[\\\"default\\\"] = mac ? keyMap.macDefault : keyMap.pcDefault\\n\\n// KEYMAP DISPATCH\\n\\nfunction normalizeKeyName(name) {\\n  var parts = name.split(/-(?!$)/)\\n  name = parts[parts.length - 1]\\n  var alt, ctrl, shift, cmd\\n  for (var i = 0; i < parts.length - 1; i++) {\\n    var mod = parts[i]\\n    if (/^(cmd|meta|m)$/i.test(mod)) { cmd = true }\\n    else if (/^a(lt)?$/i.test(mod)) { alt = true }\\n    else if (/^(c|ctrl|control)$/i.test(mod)) { ctrl = true }\\n    else if (/^s(hift)?$/i.test(mod)) { shift = true }\\n    else { throw new Error(\\\"Unrecognized modifier name: \\\" + mod) }\\n  }\\n  if (alt) { name = \\\"Alt-\\\" + name }\\n  if (ctrl) { name = \\\"Ctrl-\\\" + name }\\n  if (cmd) { name = \\\"Cmd-\\\" + name }\\n  if (shift) { name = \\\"Shift-\\\" + name }\\n  return name\\n}\\n\\n// This is a kludge to keep keymaps mostly working as raw objects\\n// (backwards compatibility) while at the same time support features\\n// like normalization and multi-stroke key bindings. It compiles a\\n// new normalized keymap, and then updates the old object to reflect\\n// this.\\nfunction normalizeKeyMap(keymap) {\\n  var copy = {}\\n  for (var keyname in keymap) { if (keymap.hasOwnProperty(keyname)) {\\n    var value = keymap[keyname]\\n    if (/^(name|fallthrough|(de|at)tach)$/.test(keyname)) { continue }\\n    if (value == \\\"...\\\") { delete keymap[keyname]; continue }\\n\\n    var keys = map(keyname.split(\\\" \\\"), normalizeKeyName)\\n    for (var i = 0; i < keys.length; i++) {\\n      var val = (void 0), name = (void 0)\\n      if (i == keys.length - 1) {\\n        name = keys.join(\\\" \\\")\\n        val = value\\n      } else {\\n        name = keys.slice(0, i + 1).join(\\\" \\\")\\n        val = \\\"...\\\"\\n      }\\n      var prev = copy[name]\\n      if (!prev) { copy[name] = val }\\n      else if (prev != val) { throw new Error(\\\"Inconsistent bindings for \\\" + name) }\\n    }\\n    delete keymap[keyname]\\n  } }\\n  for (var prop in copy) { keymap[prop] = copy[prop] }\\n  return keymap\\n}\\n\\nfunction lookupKey(key, map, handle, context) {\\n  map = getKeyMap(map)\\n  var found = map.call ? map.call(key, context) : map[key]\\n  if (found === false) { return \\\"nothing\\\" }\\n  if (found === \\\"...\\\") { return \\\"multi\\\" }\\n  if (found != null && handle(found)) { return \\\"handled\\\" }\\n\\n  if (map.fallthrough) {\\n    if (Object.prototype.toString.call(map.fallthrough) != \\\"[object Array]\\\")\\n      { return lookupKey(key, map.fallthrough, handle, context) }\\n    for (var i = 0; i < map.fallthrough.length; i++) {\\n      var result = lookupKey(key, map.fallthrough[i], handle, context)\\n      if (result) { return result }\\n    }\\n  }\\n}\\n\\n// Modifier key presses don't count as 'real' key presses for the\\n// purpose of keymap fallthrough.\\nfunction isModifierKey(value) {\\n  var name = typeof value == \\\"string\\\" ? value : keyNames[value.keyCode]\\n  return name == \\\"Ctrl\\\" || name == \\\"Alt\\\" || name == \\\"Shift\\\" || name == \\\"Mod\\\"\\n}\\n\\n// Look up the name of a key as indicated by an event object.\\nfunction keyName(event, noShift) {\\n  if (presto && event.keyCode == 34 && event[\\\"char\\\"]) { return false }\\n  var base = keyNames[event.keyCode], name = base\\n  if (name == null || event.altGraphKey) { return false }\\n  if (event.altKey && base != \\\"Alt\\\") { name = \\\"Alt-\\\" + name }\\n  if ((flipCtrlCmd ? event.metaKey : event.ctrlKey) && base != \\\"Ctrl\\\") { name = \\\"Ctrl-\\\" + name }\\n  if ((flipCtrlCmd ? event.ctrlKey : event.metaKey) && base != \\\"Cmd\\\") { name = \\\"Cmd-\\\" + name }\\n  if (!noShift && event.shiftKey && base != \\\"Shift\\\") { name = \\\"Shift-\\\" + name }\\n  return name\\n}\\n\\nfunction getKeyMap(val) {\\n  return typeof val == \\\"string\\\" ? keyMap[val] : val\\n}\\n\\n// Helper for deleting text near the selection(s), used to implement\\n// backspace, delete, and similar functionality.\\nfunction deleteNearSelection(cm, compute) {\\n  var ranges = cm.doc.sel.ranges, kill = []\\n  // Build up a set of ranges to kill first, merging overlapping\\n  // ranges.\\n  for (var i = 0; i < ranges.length; i++) {\\n    var toKill = compute(ranges[i])\\n    while (kill.length && cmp(toKill.from, lst(kill).to) <= 0) {\\n      var replaced = kill.pop()\\n      if (cmp(replaced.from, toKill.from) < 0) {\\n        toKill.from = replaced.from\\n        break\\n      }\\n    }\\n    kill.push(toKill)\\n  }\\n  // Next, remove those actual ranges.\\n  runInOp(cm, function () {\\n    for (var i = kill.length - 1; i >= 0; i--)\\n      { replaceRange(cm.doc, \\\"\\\", kill[i].from, kill[i].to, \\\"+delete\\\") }\\n    ensureCursorVisible(cm)\\n  })\\n}\\n\\n// Commands are parameter-less actions that can be performed on an\\n// editor, mostly used for keybindings.\\nvar commands = {\\n  selectAll: selectAll,\\n  singleSelection: function (cm) { return cm.setSelection(cm.getCursor(\\\"anchor\\\"), cm.getCursor(\\\"head\\\"), sel_dontScroll); },\\n  killLine: function (cm) { return deleteNearSelection(cm, function (range) {\\n    if (range.empty()) {\\n      var len = getLine(cm.doc, range.head.line).text.length\\n      if (range.head.ch == len && range.head.line < cm.lastLine())\\n        { return {from: range.head, to: Pos(range.head.line + 1, 0)} }\\n      else\\n        { return {from: range.head, to: Pos(range.head.line, len)} }\\n    } else {\\n      return {from: range.from(), to: range.to()}\\n    }\\n  }); },\\n  deleteLine: function (cm) { return deleteNearSelection(cm, function (range) { return ({\\n    from: Pos(range.from().line, 0),\\n    to: clipPos(cm.doc, Pos(range.to().line + 1, 0))\\n  }); }); },\\n  delLineLeft: function (cm) { return deleteNearSelection(cm, function (range) { return ({\\n    from: Pos(range.from().line, 0), to: range.from()\\n  }); }); },\\n  delWrappedLineLeft: function (cm) { return deleteNearSelection(cm, function (range) {\\n    var top = cm.charCoords(range.head, \\\"div\\\").top + 5\\n    var leftPos = cm.coordsChar({left: 0, top: top}, \\\"div\\\")\\n    return {from: leftPos, to: range.from()}\\n  }); },\\n  delWrappedLineRight: function (cm) { return deleteNearSelection(cm, function (range) {\\n    var top = cm.charCoords(range.head, \\\"div\\\").top + 5\\n    var rightPos = cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, \\\"div\\\")\\n    return {from: range.from(), to: rightPos }\\n  }); },\\n  undo: function (cm) { return cm.undo(); },\\n  redo: function (cm) { return cm.redo(); },\\n  undoSelection: function (cm) { return cm.undoSelection(); },\\n  redoSelection: function (cm) { return cm.redoSelection(); },\\n  goDocStart: function (cm) { return cm.extendSelection(Pos(cm.firstLine(), 0)); },\\n  goDocEnd: function (cm) { return cm.extendSelection(Pos(cm.lastLine())); },\\n  goLineStart: function (cm) { return cm.extendSelectionsBy(function (range) { return lineStart(cm, range.head.line); },\\n    {origin: \\\"+move\\\", bias: 1}\\n  ); },\\n  goLineStartSmart: function (cm) { return cm.extendSelectionsBy(function (range) { return lineStartSmart(cm, range.head); },\\n    {origin: \\\"+move\\\", bias: 1}\\n  ); },\\n  goLineEnd: function (cm) { return cm.extendSelectionsBy(function (range) { return lineEnd(cm, range.head.line); },\\n    {origin: \\\"+move\\\", bias: -1}\\n  ); },\\n  goLineRight: function (cm) { return cm.extendSelectionsBy(function (range) {\\n    var top = cm.charCoords(range.head, \\\"div\\\").top + 5\\n    return cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, \\\"div\\\")\\n  }, sel_move); },\\n  goLineLeft: function (cm) { return cm.extendSelectionsBy(function (range) {\\n    var top = cm.charCoords(range.head, \\\"div\\\").top + 5\\n    return cm.coordsChar({left: 0, top: top}, \\\"div\\\")\\n  }, sel_move); },\\n  goLineLeftSmart: function (cm) { return cm.extendSelectionsBy(function (range) {\\n    var top = cm.charCoords(range.head, \\\"div\\\").top + 5\\n    var pos = cm.coordsChar({left: 0, top: top}, \\\"div\\\")\\n    if (pos.ch < cm.getLine(pos.line).search(/\\\\S/)) { return lineStartSmart(cm, range.head) }\\n    return pos\\n  }, sel_move); },\\n  goLineUp: function (cm) { return cm.moveV(-1, \\\"line\\\"); },\\n  goLineDown: function (cm) { return cm.moveV(1, \\\"line\\\"); },\\n  goPageUp: function (cm) { return cm.moveV(-1, \\\"page\\\"); },\\n  goPageDown: function (cm) { return cm.moveV(1, \\\"page\\\"); },\\n  goCharLeft: function (cm) { return cm.moveH(-1, \\\"char\\\"); },\\n  goCharRight: function (cm) { return cm.moveH(1, \\\"char\\\"); },\\n  goColumnLeft: function (cm) { return cm.moveH(-1, \\\"column\\\"); },\\n  goColumnRight: function (cm) { return cm.moveH(1, \\\"column\\\"); },\\n  goWordLeft: function (cm) { return cm.moveH(-1, \\\"word\\\"); },\\n  goGroupRight: function (cm) { return cm.moveH(1, \\\"group\\\"); },\\n  goGroupLeft: function (cm) { return cm.moveH(-1, \\\"group\\\"); },\\n  goWordRight: function (cm) { return cm.moveH(1, \\\"word\\\"); },\\n  delCharBefore: function (cm) { return cm.deleteH(-1, \\\"char\\\"); },\\n  delCharAfter: function (cm) { return cm.deleteH(1, \\\"char\\\"); },\\n  delWordBefore: function (cm) { return cm.deleteH(-1, \\\"word\\\"); },\\n  delWordAfter: function (cm) { return cm.deleteH(1, \\\"word\\\"); },\\n  delGroupBefore: function (cm) { return cm.deleteH(-1, \\\"group\\\"); },\\n  delGroupAfter: function (cm) { return cm.deleteH(1, \\\"group\\\"); },\\n  indentAuto: function (cm) { return cm.indentSelection(\\\"smart\\\"); },\\n  indentMore: function (cm) { return cm.indentSelection(\\\"add\\\"); },\\n  indentLess: function (cm) { return cm.indentSelection(\\\"subtract\\\"); },\\n  insertTab: function (cm) { return cm.replaceSelection(\\\"\\\\t\\\"); },\\n  insertSoftTab: function (cm) {\\n    var spaces = [], ranges = cm.listSelections(), tabSize = cm.options.tabSize\\n    for (var i = 0; i < ranges.length; i++) {\\n      var pos = ranges[i].from()\\n      var col = countColumn(cm.getLine(pos.line), pos.ch, tabSize)\\n      spaces.push(spaceStr(tabSize - col % tabSize))\\n    }\\n    cm.replaceSelections(spaces)\\n  },\\n  defaultTab: function (cm) {\\n    if (cm.somethingSelected()) { cm.indentSelection(\\\"add\\\") }\\n    else { cm.execCommand(\\\"insertTab\\\") }\\n  },\\n  // Swap the two chars left and right of each selection's head.\\n  // Move cursor behind the two swapped characters afterwards.\\n  //\\n  // Doesn't consider line feeds a character.\\n  // Doesn't scan more than one line above to find a character.\\n  // Doesn't do anything on an empty line.\\n  // Doesn't do anything with non-empty selections.\\n  transposeChars: function (cm) { return runInOp(cm, function () {\\n    var ranges = cm.listSelections(), newSel = []\\n    for (var i = 0; i < ranges.length; i++) {\\n      if (!ranges[i].empty()) { continue }\\n      var cur = ranges[i].head, line = getLine(cm.doc, cur.line).text\\n      if (line) {\\n        if (cur.ch == line.length) { cur = new Pos(cur.line, cur.ch - 1) }\\n        if (cur.ch > 0) {\\n          cur = new Pos(cur.line, cur.ch + 1)\\n          cm.replaceRange(line.charAt(cur.ch - 1) + line.charAt(cur.ch - 2),\\n                          Pos(cur.line, cur.ch - 2), cur, \\\"+transpose\\\")\\n        } else if (cur.line > cm.doc.first) {\\n          var prev = getLine(cm.doc, cur.line - 1).text\\n          if (prev) {\\n            cur = new Pos(cur.line, 1)\\n            cm.replaceRange(line.charAt(0) + cm.doc.lineSeparator() +\\n                            prev.charAt(prev.length - 1),\\n                            Pos(cur.line - 1, prev.length - 1), cur, \\\"+transpose\\\")\\n          }\\n        }\\n      }\\n      newSel.push(new Range(cur, cur))\\n    }\\n    cm.setSelections(newSel)\\n  }); },\\n  newlineAndIndent: function (cm) { return runInOp(cm, function () {\\n    var sels = cm.listSelections()\\n    for (var i = sels.length - 1; i >= 0; i--)\\n      { cm.replaceRange(cm.doc.lineSeparator(), sels[i].anchor, sels[i].head, \\\"+input\\\") }\\n    sels = cm.listSelections()\\n    for (var i$1 = 0; i$1 < sels.length; i$1++)\\n      { cm.indentLine(sels[i$1].from().line, null, true) }\\n    ensureCursorVisible(cm)\\n  }); },\\n  openLine: function (cm) { return cm.replaceSelection(\\\"\\\\n\\\", \\\"start\\\"); },\\n  toggleOverwrite: function (cm) { return cm.toggleOverwrite(); }\\n}\\n\\n\\nfunction lineStart(cm, lineN) {\\n  var line = getLine(cm.doc, lineN)\\n  var visual = visualLine(line)\\n  if (visual != line) { lineN = lineNo(visual) }\\n  return endOfLine(true, cm, visual, lineN, 1)\\n}\\nfunction lineEnd(cm, lineN) {\\n  var line = getLine(cm.doc, lineN)\\n  var visual = visualLineEnd(line)\\n  if (visual != line) { lineN = lineNo(visual) }\\n  return endOfLine(true, cm, line, lineN, -1)\\n}\\nfunction lineStartSmart(cm, pos) {\\n  var start = lineStart(cm, pos.line)\\n  var line = getLine(cm.doc, start.line)\\n  var order = getOrder(line)\\n  if (!order || order[0].level == 0) {\\n    var firstNonWS = Math.max(0, line.text.search(/\\\\S/))\\n    var inWS = pos.line == start.line && pos.ch <= firstNonWS && pos.ch\\n    return Pos(start.line, inWS ? 0 : firstNonWS, start.sticky)\\n  }\\n  return start\\n}\\n\\n// Run a handler that was bound to a key.\\nfunction doHandleBinding(cm, bound, dropShift) {\\n  if (typeof bound == \\\"string\\\") {\\n    bound = commands[bound]\\n    if (!bound) { return false }\\n  }\\n  // Ensure previous input has been read, so that the handler sees a\\n  // consistent view of the document\\n  cm.display.input.ensurePolled()\\n  var prevShift = cm.display.shift, done = false\\n  try {\\n    if (cm.isReadOnly()) { cm.state.suppressEdits = true }\\n    if (dropShift) { cm.display.shift = false }\\n    done = bound(cm) != Pass\\n  } finally {\\n    cm.display.shift = prevShift\\n    cm.state.suppressEdits = false\\n  }\\n  return done\\n}\\n\\nfunction lookupKeyForEditor(cm, name, handle) {\\n  for (var i = 0; i < cm.state.keyMaps.length; i++) {\\n    var result = lookupKey(name, cm.state.keyMaps[i], handle, cm)\\n    if (result) { return result }\\n  }\\n  return (cm.options.extraKeys && lookupKey(name, cm.options.extraKeys, handle, cm))\\n    || lookupKey(name, cm.options.keyMap, handle, cm)\\n}\\n\\nvar stopSeq = new Delayed\\nfunction dispatchKey(cm, name, e, handle) {\\n  var seq = cm.state.keySeq\\n  if (seq) {\\n    if (isModifierKey(name)) { return \\\"handled\\\" }\\n    stopSeq.set(50, function () {\\n      if (cm.state.keySeq == seq) {\\n        cm.state.keySeq = null\\n        cm.display.input.reset()\\n      }\\n    })\\n    name = seq + \\\" \\\" + name\\n  }\\n  var result = lookupKeyForEditor(cm, name, handle)\\n\\n  if (result == \\\"multi\\\")\\n    { cm.state.keySeq = name }\\n  if (result == \\\"handled\\\")\\n    { signalLater(cm, \\\"keyHandled\\\", cm, name, e) }\\n\\n  if (result == \\\"handled\\\" || result == \\\"multi\\\") {\\n    e_preventDefault(e)\\n    restartBlink(cm)\\n  }\\n\\n  if (seq && !result && /\\\\'$/.test(name)) {\\n    e_preventDefault(e)\\n    return true\\n  }\\n  return !!result\\n}\\n\\n// Handle a key from the keydown event.\\nfunction handleKeyBinding(cm, e) {\\n  var name = keyName(e, true)\\n  if (!name) { return false }\\n\\n  if (e.shiftKey && !cm.state.keySeq) {\\n    // First try to resolve full name (including 'Shift-'). Failing\\n    // that, see if there is a cursor-motion command (starting with\\n    // 'go') bound to the keyname without 'Shift-'.\\n    return dispatchKey(cm, \\\"Shift-\\\" + name, e, function (b) { return doHandleBinding(cm, b, true); })\\n        || dispatchKey(cm, name, e, function (b) {\\n             if (typeof b == \\\"string\\\" ? /^go[A-Z]/.test(b) : b.motion)\\n               { return doHandleBinding(cm, b) }\\n           })\\n  } else {\\n    return dispatchKey(cm, name, e, function (b) { return doHandleBinding(cm, b); })\\n  }\\n}\\n\\n// Handle a key from the keypress event\\nfunction handleCharBinding(cm, e, ch) {\\n  return dispatchKey(cm, \\\"'\\\" + ch + \\\"'\\\", e, function (b) { return doHandleBinding(cm, b, true); })\\n}\\n\\nvar lastStoppedKey = null\\nfunction onKeyDown(e) {\\n  var cm = this\\n  cm.curOp.focus = activeElt()\\n  if (signalDOMEvent(cm, e)) { return }\\n  // IE does strange things with escape.\\n  if (ie && ie_version < 11 && e.keyCode == 27) { e.returnValue = false }\\n  var code = e.keyCode\\n  cm.display.shift = code == 16 || e.shiftKey\\n  var handled = handleKeyBinding(cm, e)\\n  if (presto) {\\n    lastStoppedKey = handled ? code : null\\n    // Opera has no cut event... we try to at least catch the key combo\\n    if (!handled && code == 88 && !hasCopyEvent && (mac ? e.metaKey : e.ctrlKey))\\n      { cm.replaceSelection(\\\"\\\", null, \\\"cut\\\") }\\n  }\\n\\n  // Turn mouse into crosshair when Alt is held on Mac.\\n  if (code == 18 && !/\\\\bCodeMirror-crosshair\\\\b/.test(cm.display.lineDiv.className))\\n    { showCrossHair(cm) }\\n}\\n\\nfunction showCrossHair(cm) {\\n  var lineDiv = cm.display.lineDiv\\n  addClass(lineDiv, \\\"CodeMirror-crosshair\\\")\\n\\n  function up(e) {\\n    if (e.keyCode == 18 || !e.altKey) {\\n      rmClass(lineDiv, \\\"CodeMirror-crosshair\\\")\\n      off(document, \\\"keyup\\\", up)\\n      off(document, \\\"mouseover\\\", up)\\n    }\\n  }\\n  on(document, \\\"keyup\\\", up)\\n  on(document, \\\"mouseover\\\", up)\\n}\\n\\nfunction onKeyUp(e) {\\n  if (e.keyCode == 16) { this.doc.sel.shift = false }\\n  signalDOMEvent(this, e)\\n}\\n\\nfunction onKeyPress(e) {\\n  var cm = this\\n  if (eventInWidget(cm.display, e) || signalDOMEvent(cm, e) || e.ctrlKey && !e.altKey || mac && e.metaKey) { return }\\n  var keyCode = e.keyCode, charCode = e.charCode\\n  if (presto && keyCode == lastStoppedKey) {lastStoppedKey = null; e_preventDefault(e); return}\\n  if ((presto && (!e.which || e.which < 10)) && handleKeyBinding(cm, e)) { return }\\n  var ch = String.fromCharCode(charCode == null ? keyCode : charCode)\\n  // Some browsers fire keypress events for backspace\\n  if (ch == \\\"\\\\x08\\\") { return }\\n  if (handleCharBinding(cm, e, ch)) { return }\\n  cm.display.input.onKeyPress(e)\\n}\\n\\n// A mouse down can be a single click, double click, triple click,\\n// start of selection drag, start of text drag, new cursor\\n// (ctrl-click), rectangle drag (alt-drag), or xwin\\n// middle-click-paste. Or it might be a click on something we should\\n// not interfere with, such as a scrollbar or widget.\\nfunction onMouseDown(e) {\\n  var cm = this, display = cm.display\\n  if (signalDOMEvent(cm, e) || display.activeTouch && display.input.supportsTouch()) { return }\\n  display.input.ensurePolled()\\n  display.shift = e.shiftKey\\n\\n  if (eventInWidget(display, e)) {\\n    if (!webkit) {\\n      // Briefly turn off draggability, to allow widgets to do\\n      // normal dragging things.\\n      display.scroller.draggable = false\\n      setTimeout(function () { return display.scroller.draggable = true; }, 100)\\n    }\\n    return\\n  }\\n  if (clickInGutter(cm, e)) { return }\\n  var start = posFromMouse(cm, e)\\n  window.focus()\\n\\n  switch (e_button(e)) {\\n  case 1:\\n    // #3261: make sure, that we're not starting a second selection\\n    if (cm.state.selectingText)\\n      { cm.state.selectingText(e) }\\n    else if (start)\\n      { leftButtonDown(cm, e, start) }\\n    else if (e_target(e) == display.scroller)\\n      { e_preventDefault(e) }\\n    break\\n  case 2:\\n    if (webkit) { cm.state.lastMiddleDown = +new Date }\\n    if (start) { extendSelection(cm.doc, start) }\\n    setTimeout(function () { return display.input.focus(); }, 20)\\n    e_preventDefault(e)\\n    break\\n  case 3:\\n    if (captureRightClick) { onContextMenu(cm, e) }\\n    else { delayBlurEvent(cm) }\\n    break\\n  }\\n}\\n\\nvar lastClick;\\nvar lastDoubleClick;\\nfunction leftButtonDown(cm, e, start) {\\n  if (ie) { setTimeout(bind(ensureFocus, cm), 0) }\\n  else { cm.curOp.focus = activeElt() }\\n\\n  var now = +new Date, type\\n  if (lastDoubleClick && lastDoubleClick.time > now - 400 && cmp(lastDoubleClick.pos, start) == 0) {\\n    type = \\\"triple\\\"\\n  } else if (lastClick && lastClick.time > now - 400 && cmp(lastClick.pos, start) == 0) {\\n    type = \\\"double\\\"\\n    lastDoubleClick = {time: now, pos: start}\\n  } else {\\n    type = \\\"single\\\"\\n    lastClick = {time: now, pos: start}\\n  }\\n\\n  var sel = cm.doc.sel, modifier = mac ? e.metaKey : e.ctrlKey, contained\\n  if (cm.options.dragDrop && dragAndDrop && !cm.isReadOnly() &&\\n      type == \\\"single\\\" && (contained = sel.contains(start)) > -1 &&\\n      (cmp((contained = sel.ranges[contained]).from(), start) < 0 || start.xRel > 0) &&\\n      (cmp(contained.to(), start) > 0 || start.xRel < 0))\\n    { leftButtonStartDrag(cm, e, start, modifier) }\\n  else\\n    { leftButtonSelect(cm, e, start, type, modifier) }\\n}\\n\\n// Start a text drag. When it ends, see if any dragging actually\\n// happen, and treat as a click if it didn't.\\nfunction leftButtonStartDrag(cm, e, start, modifier) {\\n  var display = cm.display, startTime = +new Date\\n  var dragEnd = operation(cm, function (e2) {\\n    if (webkit) { display.scroller.draggable = false }\\n    cm.state.draggingText = false\\n    off(document, \\\"mouseup\\\", dragEnd)\\n    off(display.scroller, \\\"drop\\\", dragEnd)\\n    if (Math.abs(e.clientX - e2.clientX) + Math.abs(e.clientY - e2.clientY) < 10) {\\n      e_preventDefault(e2)\\n      if (!modifier && +new Date - 200 < startTime)\\n        { extendSelection(cm.doc, start) }\\n      // Work around unexplainable focus problem in IE9 (#2127) and Chrome (#3081)\\n      if (webkit || ie && ie_version == 9)\\n        { setTimeout(function () {document.body.focus(); display.input.focus()}, 20) }\\n      else\\n        { display.input.focus() }\\n    }\\n  })\\n  // Let the drag handler handle this.\\n  if (webkit) { display.scroller.draggable = true }\\n  cm.state.draggingText = dragEnd\\n  dragEnd.copy = mac ? e.altKey : e.ctrlKey\\n  // IE's approach to draggable\\n  if (display.scroller.dragDrop) { display.scroller.dragDrop() }\\n  on(document, \\\"mouseup\\\", dragEnd)\\n  on(display.scroller, \\\"drop\\\", dragEnd)\\n}\\n\\n// Normal selection, as opposed to text dragging.\\nfunction leftButtonSelect(cm, e, start, type, addNew) {\\n  var display = cm.display, doc = cm.doc\\n  e_preventDefault(e)\\n\\n  var ourRange, ourIndex, startSel = doc.sel, ranges = startSel.ranges\\n  if (addNew && !e.shiftKey) {\\n    ourIndex = doc.sel.contains(start)\\n    if (ourIndex > -1)\\n      { ourRange = ranges[ourIndex] }\\n    else\\n      { ourRange = new Range(start, start) }\\n  } else {\\n    ourRange = doc.sel.primary()\\n    ourIndex = doc.sel.primIndex\\n  }\\n\\n  if (chromeOS ? e.shiftKey && e.metaKey : e.altKey) {\\n    type = \\\"rect\\\"\\n    if (!addNew) { ourRange = new Range(start, start) }\\n    start = posFromMouse(cm, e, true, true)\\n    ourIndex = -1\\n  } else if (type == \\\"double\\\") {\\n    var word = cm.findWordAt(start)\\n    if (cm.display.shift || doc.extend)\\n      { ourRange = extendRange(doc, ourRange, word.anchor, word.head) }\\n    else\\n      { ourRange = word }\\n  } else if (type == \\\"triple\\\") {\\n    var line = new Range(Pos(start.line, 0), clipPos(doc, Pos(start.line + 1, 0)))\\n    if (cm.display.shift || doc.extend)\\n      { ourRange = extendRange(doc, ourRange, line.anchor, line.head) }\\n    else\\n      { ourRange = line }\\n  } else {\\n    ourRange = extendRange(doc, ourRange, start)\\n  }\\n\\n  if (!addNew) {\\n    ourIndex = 0\\n    setSelection(doc, new Selection([ourRange], 0), sel_mouse)\\n    startSel = doc.sel\\n  } else if (ourIndex == -1) {\\n    ourIndex = ranges.length\\n    setSelection(doc, normalizeSelection(ranges.concat([ourRange]), ourIndex),\\n                 {scroll: false, origin: \\\"*mouse\\\"})\\n  } else if (ranges.length > 1 && ranges[ourIndex].empty() && type == \\\"single\\\" && !e.shiftKey) {\\n    setSelection(doc, normalizeSelection(ranges.slice(0, ourIndex).concat(ranges.slice(ourIndex + 1)), 0),\\n                 {scroll: false, origin: \\\"*mouse\\\"})\\n    startSel = doc.sel\\n  } else {\\n    replaceOneSelection(doc, ourIndex, ourRange, sel_mouse)\\n  }\\n\\n  var lastPos = start\\n  function extendTo(pos) {\\n    if (cmp(lastPos, pos) == 0) { return }\\n    lastPos = pos\\n\\n    if (type == \\\"rect\\\") {\\n      var ranges = [], tabSize = cm.options.tabSize\\n      var startCol = countColumn(getLine(doc, start.line).text, start.ch, tabSize)\\n      var posCol = countColumn(getLine(doc, pos.line).text, pos.ch, tabSize)\\n      var left = Math.min(startCol, posCol), right = Math.max(startCol, posCol)\\n      for (var line = Math.min(start.line, pos.line), end = Math.min(cm.lastLine(), Math.max(start.line, pos.line));\\n           line <= end; line++) {\\n        var text = getLine(doc, line).text, leftPos = findColumn(text, left, tabSize)\\n        if (left == right)\\n          { ranges.push(new Range(Pos(line, leftPos), Pos(line, leftPos))) }\\n        else if (text.length > leftPos)\\n          { ranges.push(new Range(Pos(line, leftPos), Pos(line, findColumn(text, right, tabSize)))) }\\n      }\\n      if (!ranges.length) { ranges.push(new Range(start, start)) }\\n      setSelection(doc, normalizeSelection(startSel.ranges.slice(0, ourIndex).concat(ranges), ourIndex),\\n                   {origin: \\\"*mouse\\\", scroll: false})\\n      cm.scrollIntoView(pos)\\n    } else {\\n      var oldRange = ourRange\\n      var anchor = oldRange.anchor, head = pos\\n      if (type != \\\"single\\\") {\\n        var range\\n        if (type == \\\"double\\\")\\n          { range = cm.findWordAt(pos) }\\n        else\\n          { range = new Range(Pos(pos.line, 0), clipPos(doc, Pos(pos.line + 1, 0))) }\\n        if (cmp(range.anchor, anchor) > 0) {\\n          head = range.head\\n          anchor = minPos(oldRange.from(), range.anchor)\\n        } else {\\n          head = range.anchor\\n          anchor = maxPos(oldRange.to(), range.head)\\n        }\\n      }\\n      var ranges$1 = startSel.ranges.slice(0)\\n      ranges$1[ourIndex] = new Range(clipPos(doc, anchor), head)\\n      setSelection(doc, normalizeSelection(ranges$1, ourIndex), sel_mouse)\\n    }\\n  }\\n\\n  var editorSize = display.wrapper.getBoundingClientRect()\\n  // Used to ensure timeout re-tries don't fire when another extend\\n  // happened in the meantime (clearTimeout isn't reliable -- at\\n  // least on Chrome, the timeouts still happen even when cleared,\\n  // if the clear happens after their scheduled firing time).\\n  var counter = 0\\n\\n  function extend(e) {\\n    var curCount = ++counter\\n    var cur = posFromMouse(cm, e, true, type == \\\"rect\\\")\\n    if (!cur) { return }\\n    if (cmp(cur, lastPos) != 0) {\\n      cm.curOp.focus = activeElt()\\n      extendTo(cur)\\n      var visible = visibleLines(display, doc)\\n      if (cur.line >= visible.to || cur.line < visible.from)\\n        { setTimeout(operation(cm, function () {if (counter == curCount) { extend(e) }}), 150) }\\n    } else {\\n      var outside = e.clientY < editorSize.top ? -20 : e.clientY > editorSize.bottom ? 20 : 0\\n      if (outside) { setTimeout(operation(cm, function () {\\n        if (counter != curCount) { return }\\n        display.scroller.scrollTop += outside\\n        extend(e)\\n      }), 50) }\\n    }\\n  }\\n\\n  function done(e) {\\n    cm.state.selectingText = false\\n    counter = Infinity\\n    e_preventDefault(e)\\n    display.input.focus()\\n    off(document, \\\"mousemove\\\", move)\\n    off(document, \\\"mouseup\\\", up)\\n    doc.history.lastSelOrigin = null\\n  }\\n\\n  var move = operation(cm, function (e) {\\n    if (!e_button(e)) { done(e) }\\n    else { extend(e) }\\n  })\\n  var up = operation(cm, done)\\n  cm.state.selectingText = up\\n  on(document, \\\"mousemove\\\", move)\\n  on(document, \\\"mouseup\\\", up)\\n}\\n\\n\\n// Determines whether an event happened in the gutter, and fires the\\n// handlers for the corresponding event.\\nfunction gutterEvent(cm, e, type, prevent) {\\n  var mX, mY\\n  try { mX = e.clientX; mY = e.clientY }\\n  catch(e) { return false }\\n  if (mX >= Math.floor(cm.display.gutters.getBoundingClientRect().right)) { return false }\\n  if (prevent) { e_preventDefault(e) }\\n\\n  var display = cm.display\\n  var lineBox = display.lineDiv.getBoundingClientRect()\\n\\n  if (mY > lineBox.bottom || !hasHandler(cm, type)) { return e_defaultPrevented(e) }\\n  mY -= lineBox.top - display.viewOffset\\n\\n  for (var i = 0; i < cm.options.gutters.length; ++i) {\\n    var g = display.gutters.childNodes[i]\\n    if (g && g.getBoundingClientRect().right >= mX) {\\n      var line = lineAtHeight(cm.doc, mY)\\n      var gutter = cm.options.gutters[i]\\n      signal(cm, type, cm, line, gutter, e)\\n      return e_defaultPrevented(e)\\n    }\\n  }\\n}\\n\\nfunction clickInGutter(cm, e) {\\n  return gutterEvent(cm, e, \\\"gutterClick\\\", true)\\n}\\n\\n// CONTEXT MENU HANDLING\\n\\n// To make the context menu work, we need to briefly unhide the\\n// textarea (making it as unobtrusive as possible) to let the\\n// right-click take effect on it.\\nfunction onContextMenu(cm, e) {\\n  if (eventInWidget(cm.display, e) || contextMenuInGutter(cm, e)) { return }\\n  if (signalDOMEvent(cm, e, \\\"contextmenu\\\")) { return }\\n  cm.display.input.onContextMenu(e)\\n}\\n\\nfunction contextMenuInGutter(cm, e) {\\n  if (!hasHandler(cm, \\\"gutterContextMenu\\\")) { return false }\\n  return gutterEvent(cm, e, \\\"gutterContextMenu\\\", false)\\n}\\n\\nfunction themeChanged(cm) {\\n  cm.display.wrapper.className = cm.display.wrapper.className.replace(/\\\\s*cm-s-\\\\S+/g, \\\"\\\") +\\n    cm.options.theme.replace(/(^|\\\\s)\\\\s*/g, \\\" cm-s-\\\")\\n  clearCaches(cm)\\n}\\n\\nvar Init = {toString: function(){return \\\"CodeMirror.Init\\\"}}\\n\\nvar defaults = {}\\nvar optionHandlers = {}\\n\\nfunction defineOptions(CodeMirror) {\\n  var optionHandlers = CodeMirror.optionHandlers\\n\\n  function option(name, deflt, handle, notOnInit) {\\n    CodeMirror.defaults[name] = deflt\\n    if (handle) { optionHandlers[name] =\\n      notOnInit ? function (cm, val, old) {if (old != Init) { handle(cm, val, old) }} : handle }\\n  }\\n\\n  CodeMirror.defineOption = option\\n\\n  // Passed to option handlers when there is no old value.\\n  CodeMirror.Init = Init\\n\\n  // These two are, on init, called from the constructor because they\\n  // have to be initialized before the editor can start at all.\\n  option(\\\"value\\\", \\\"\\\", function (cm, val) { return cm.setValue(val); }, true)\\n  option(\\\"mode\\\", null, function (cm, val) {\\n    cm.doc.modeOption = val\\n    loadMode(cm)\\n  }, true)\\n\\n  option(\\\"indentUnit\\\", 2, loadMode, true)\\n  option(\\\"indentWithTabs\\\", false)\\n  option(\\\"smartIndent\\\", true)\\n  option(\\\"tabSize\\\", 4, function (cm) {\\n    resetModeState(cm)\\n    clearCaches(cm)\\n    regChange(cm)\\n  }, true)\\n  option(\\\"lineSeparator\\\", null, function (cm, val) {\\n    cm.doc.lineSep = val\\n    if (!val) { return }\\n    var newBreaks = [], lineNo = cm.doc.first\\n    cm.doc.iter(function (line) {\\n      for (var pos = 0;;) {\\n        var found = line.text.indexOf(val, pos)\\n        if (found == -1) { break }\\n        pos = found + val.length\\n        newBreaks.push(Pos(lineNo, found))\\n      }\\n      lineNo++\\n    })\\n    for (var i = newBreaks.length - 1; i >= 0; i--)\\n      { replaceRange(cm.doc, val, newBreaks[i], Pos(newBreaks[i].line, newBreaks[i].ch + val.length)) }\\n  })\\n  option(\\\"specialChars\\\", /[\\\\u0000-\\\\u001f\\\\u007f\\\\u00ad\\\\u061c\\\\u200b-\\\\u200f\\\\u2028\\\\u2029\\\\ufeff]/g, function (cm, val, old) {\\n    cm.state.specialChars = new RegExp(val.source + (val.test(\\\"\\\\t\\\") ? \\\"\\\" : \\\"|\\\\t\\\"), \\\"g\\\")\\n    if (old != Init) { cm.refresh() }\\n  })\\n  option(\\\"specialCharPlaceholder\\\", defaultSpecialCharPlaceholder, function (cm) { return cm.refresh(); }, true)\\n  option(\\\"electricChars\\\", true)\\n  option(\\\"inputStyle\\\", mobile ? \\\"contenteditable\\\" : \\\"textarea\\\", function () {\\n    throw new Error(\\\"inputStyle can not (yet) be changed in a running editor\\\") // FIXME\\n  }, true)\\n  option(\\\"spellcheck\\\", false, function (cm, val) { return cm.getInputField().spellcheck = val; }, true)\\n  option(\\\"rtlMoveVisually\\\", !windows)\\n  option(\\\"wholeLineUpdateBefore\\\", true)\\n\\n  option(\\\"theme\\\", \\\"default\\\", function (cm) {\\n    themeChanged(cm)\\n    guttersChanged(cm)\\n  }, true)\\n  option(\\\"keyMap\\\", \\\"default\\\", function (cm, val, old) {\\n    var next = getKeyMap(val)\\n    var prev = old != Init && getKeyMap(old)\\n    if (prev && prev.detach) { prev.detach(cm, next) }\\n    if (next.attach) { next.attach(cm, prev || null) }\\n  })\\n  option(\\\"extraKeys\\\", null)\\n\\n  option(\\\"lineWrapping\\\", false, wrappingChanged, true)\\n  option(\\\"gutters\\\", [], function (cm) {\\n    setGuttersForLineNumbers(cm.options)\\n    guttersChanged(cm)\\n  }, true)\\n  option(\\\"fixedGutter\\\", true, function (cm, val) {\\n    cm.display.gutters.style.left = val ? compensateForHScroll(cm.display) + \\\"px\\\" : \\\"0\\\"\\n    cm.refresh()\\n  }, true)\\n  option(\\\"coverGutterNextToScrollbar\\\", false, function (cm) { return updateScrollbars(cm); }, true)\\n  option(\\\"scrollbarStyle\\\", \\\"native\\\", function (cm) {\\n    initScrollbars(cm)\\n    updateScrollbars(cm)\\n    cm.display.scrollbars.setScrollTop(cm.doc.scrollTop)\\n    cm.display.scrollbars.setScrollLeft(cm.doc.scrollLeft)\\n  }, true)\\n  option(\\\"lineNumbers\\\", false, function (cm) {\\n    setGuttersForLineNumbers(cm.options)\\n    guttersChanged(cm)\\n  }, true)\\n  option(\\\"firstLineNumber\\\", 1, guttersChanged, true)\\n  option(\\\"lineNumberFormatter\\\", function (integer) { return integer; }, guttersChanged, true)\\n  option(\\\"showCursorWhenSelecting\\\", false, updateSelection, true)\\n\\n  option(\\\"resetSelectionOnContextMenu\\\", true)\\n  option(\\\"lineWiseCopyCut\\\", true)\\n\\n  option(\\\"readOnly\\\", false, function (cm, val) {\\n    if (val == \\\"nocursor\\\") {\\n      onBlur(cm)\\n      cm.display.input.blur()\\n      cm.display.disabled = true\\n    } else {\\n      cm.display.disabled = false\\n    }\\n    cm.display.input.readOnlyChanged(val)\\n  })\\n  option(\\\"disableInput\\\", false, function (cm, val) {if (!val) { cm.display.input.reset() }}, true)\\n  option(\\\"dragDrop\\\", true, dragDropChanged)\\n  option(\\\"allowDropFileTypes\\\", null)\\n\\n  option(\\\"cursorBlinkRate\\\", 530)\\n  option(\\\"cursorScrollMargin\\\", 0)\\n  option(\\\"cursorHeight\\\", 1, updateSelection, true)\\n  option(\\\"singleCursorHeightPerLine\\\", true, updateSelection, true)\\n  option(\\\"workTime\\\", 100)\\n  option(\\\"workDelay\\\", 100)\\n  option(\\\"flattenSpans\\\", true, resetModeState, true)\\n  option(\\\"addModeClass\\\", false, resetModeState, true)\\n  option(\\\"pollInterval\\\", 100)\\n  option(\\\"undoDepth\\\", 200, function (cm, val) { return cm.doc.history.undoDepth = val; })\\n  option(\\\"historyEventDelay\\\", 1250)\\n  option(\\\"viewportMargin\\\", 10, function (cm) { return cm.refresh(); }, true)\\n  option(\\\"maxHighlightLength\\\", 10000, resetModeState, true)\\n  option(\\\"moveInputWithCursor\\\", true, function (cm, val) {\\n    if (!val) { cm.display.input.resetPosition() }\\n  })\\n\\n  option(\\\"tabindex\\\", null, function (cm, val) { return cm.display.input.getField().tabIndex = val || \\\"\\\"; })\\n  option(\\\"autofocus\\\", null)\\n}\\n\\nfunction guttersChanged(cm) {\\n  updateGutters(cm)\\n  regChange(cm)\\n  alignHorizontally(cm)\\n}\\n\\nfunction dragDropChanged(cm, value, old) {\\n  var wasOn = old && old != Init\\n  if (!value != !wasOn) {\\n    var funcs = cm.display.dragFunctions\\n    var toggle = value ? on : off\\n    toggle(cm.display.scroller, \\\"dragstart\\\", funcs.start)\\n    toggle(cm.display.scroller, \\\"dragenter\\\", funcs.enter)\\n    toggle(cm.display.scroller, \\\"dragover\\\", funcs.over)\\n    toggle(cm.display.scroller, \\\"dragleave\\\", funcs.leave)\\n    toggle(cm.display.scroller, \\\"drop\\\", funcs.drop)\\n  }\\n}\\n\\nfunction wrappingChanged(cm) {\\n  if (cm.options.lineWrapping) {\\n    addClass(cm.display.wrapper, \\\"CodeMirror-wrap\\\")\\n    cm.display.sizer.style.minWidth = \\\"\\\"\\n    cm.display.sizerWidth = null\\n  } else {\\n    rmClass(cm.display.wrapper, \\\"CodeMirror-wrap\\\")\\n    findMaxLine(cm)\\n  }\\n  estimateLineHeights(cm)\\n  regChange(cm)\\n  clearCaches(cm)\\n  setTimeout(function () { return updateScrollbars(cm); }, 100)\\n}\\n\\n// A CodeMirror instance represents an editor. This is the object\\n// that user code is usually dealing with.\\n\\nfunction CodeMirror(place, options) {\\n  var this$1 = this;\\n\\n  if (!(this instanceof CodeMirror)) { return new CodeMirror(place, options) }\\n\\n  this.options = options = options ? copyObj(options) : {}\\n  // Determine effective options based on given values and defaults.\\n  copyObj(defaults, options, false)\\n  setGuttersForLineNumbers(options)\\n\\n  var doc = options.value\\n  if (typeof doc == \\\"string\\\") { doc = new Doc(doc, options.mode, null, options.lineSeparator) }\\n  this.doc = doc\\n\\n  var input = new CodeMirror.inputStyles[options.inputStyle](this)\\n  var display = this.display = new Display(place, doc, input)\\n  display.wrapper.CodeMirror = this\\n  updateGutters(this)\\n  themeChanged(this)\\n  if (options.lineWrapping)\\n    { this.display.wrapper.className += \\\" CodeMirror-wrap\\\" }\\n  initScrollbars(this)\\n\\n  this.state = {\\n    keyMaps: [],  // stores maps added by addKeyMap\\n    overlays: [], // highlighting overlays, as added by addOverlay\\n    modeGen: 0,   // bumped when mode/overlay changes, used to invalidate highlighting info\\n    overwrite: false,\\n    delayingBlurEvent: false,\\n    focused: false,\\n    suppressEdits: false, // used to disable editing during key handlers when in readOnly mode\\n    pasteIncoming: false, cutIncoming: false, // help recognize paste/cut edits in input.poll\\n    selectingText: false,\\n    draggingText: false,\\n    highlight: new Delayed(), // stores highlight worker timeout\\n    keySeq: null,  // Unfinished key sequence\\n    specialChars: null\\n  }\\n\\n  if (options.autofocus && !mobile) { display.input.focus() }\\n\\n  // Override magic textarea content restore that IE sometimes does\\n  // on our hidden textarea on reload\\n  if (ie && ie_version < 11) { setTimeout(function () { return this$1.display.input.reset(true); }, 20) }\\n\\n  registerEventHandlers(this)\\n  ensureGlobalHandlers()\\n\\n  startOperation(this)\\n  this.curOp.forceUpdate = true\\n  attachDoc(this, doc)\\n\\n  if ((options.autofocus && !mobile) || this.hasFocus())\\n    { setTimeout(bind(onFocus, this), 20) }\\n  else\\n    { onBlur(this) }\\n\\n  for (var opt in optionHandlers) { if (optionHandlers.hasOwnProperty(opt))\\n    { optionHandlers[opt](this$1, options[opt], Init) } }\\n  maybeUpdateLineNumberWidth(this)\\n  if (options.finishInit) { options.finishInit(this) }\\n  for (var i = 0; i < initHooks.length; ++i) { initHooks[i](this$1) }\\n  endOperation(this)\\n  // Suppress optimizelegibility in Webkit, since it breaks text\\n  // measuring on line wrapping boundaries.\\n  if (webkit && options.lineWrapping &&\\n      getComputedStyle(display.lineDiv).textRendering == \\\"optimizelegibility\\\")\\n    { display.lineDiv.style.textRendering = \\\"auto\\\" }\\n}\\n\\n// The default configuration options.\\nCodeMirror.defaults = defaults\\n// Functions to run when options are changed.\\nCodeMirror.optionHandlers = optionHandlers\\n\\n// Attach the necessary event handlers when initializing the editor\\nfunction registerEventHandlers(cm) {\\n  var d = cm.display\\n  on(d.scroller, \\\"mousedown\\\", operation(cm, onMouseDown))\\n  // Older IE's will not fire a second mousedown for a double click\\n  if (ie && ie_version < 11)\\n    { on(d.scroller, \\\"dblclick\\\", operation(cm, function (e) {\\n      if (signalDOMEvent(cm, e)) { return }\\n      var pos = posFromMouse(cm, e)\\n      if (!pos || clickInGutter(cm, e) || eventInWidget(cm.display, e)) { return }\\n      e_preventDefault(e)\\n      var word = cm.findWordAt(pos)\\n      extendSelection(cm.doc, word.anchor, word.head)\\n    })) }\\n  else\\n    { on(d.scroller, \\\"dblclick\\\", function (e) { return signalDOMEvent(cm, e) || e_preventDefault(e); }) }\\n  // Some browsers fire contextmenu *after* opening the menu, at\\n  // which point we can't mess with it anymore. Context menu is\\n  // handled in onMouseDown for these browsers.\\n  if (!captureRightClick) { on(d.scroller, \\\"contextmenu\\\", function (e) { return onContextMenu(cm, e); }) }\\n\\n  // Used to suppress mouse event handling when a touch happens\\n  var touchFinished, prevTouch = {end: 0}\\n  function finishTouch() {\\n    if (d.activeTouch) {\\n      touchFinished = setTimeout(function () { return d.activeTouch = null; }, 1000)\\n      prevTouch = d.activeTouch\\n      prevTouch.end = +new Date\\n    }\\n  }\\n  function isMouseLikeTouchEvent(e) {\\n    if (e.touches.length != 1) { return false }\\n    var touch = e.touches[0]\\n    return touch.radiusX <= 1 && touch.radiusY <= 1\\n  }\\n  function farAway(touch, other) {\\n    if (other.left == null) { return true }\\n    var dx = other.left - touch.left, dy = other.top - touch.top\\n    return dx * dx + dy * dy > 20 * 20\\n  }\\n  on(d.scroller, \\\"touchstart\\\", function (e) {\\n    if (!signalDOMEvent(cm, e) && !isMouseLikeTouchEvent(e)) {\\n      d.input.ensurePolled()\\n      clearTimeout(touchFinished)\\n      var now = +new Date\\n      d.activeTouch = {start: now, moved: false,\\n                       prev: now - prevTouch.end <= 300 ? prevTouch : null}\\n      if (e.touches.length == 1) {\\n        d.activeTouch.left = e.touches[0].pageX\\n        d.activeTouch.top = e.touches[0].pageY\\n      }\\n    }\\n  })\\n  on(d.scroller, \\\"touchmove\\\", function () {\\n    if (d.activeTouch) { d.activeTouch.moved = true }\\n  })\\n  on(d.scroller, \\\"touchend\\\", function (e) {\\n    var touch = d.activeTouch\\n    if (touch && !eventInWidget(d, e) && touch.left != null &&\\n        !touch.moved && new Date - touch.start < 300) {\\n      var pos = cm.coordsChar(d.activeTouch, \\\"page\\\"), range\\n      if (!touch.prev || farAway(touch, touch.prev)) // Single tap\\n        { range = new Range(pos, pos) }\\n      else if (!touch.prev.prev || farAway(touch, touch.prev.prev)) // Double tap\\n        { range = cm.findWordAt(pos) }\\n      else // Triple tap\\n        { range = new Range(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0))) }\\n      cm.setSelection(range.anchor, range.head)\\n      cm.focus()\\n      e_preventDefault(e)\\n    }\\n    finishTouch()\\n  })\\n  on(d.scroller, \\\"touchcancel\\\", finishTouch)\\n\\n  // Sync scrolling between fake scrollbars and real scrollable\\n  // area, ensure viewport is updated when scrolling.\\n  on(d.scroller, \\\"scroll\\\", function () {\\n    if (d.scroller.clientHeight) {\\n      setScrollTop(cm, d.scroller.scrollTop)\\n      setScrollLeft(cm, d.scroller.scrollLeft, true)\\n      signal(cm, \\\"scroll\\\", cm)\\n    }\\n  })\\n\\n  // Listen to wheel events in order to try and update the viewport on time.\\n  on(d.scroller, \\\"mousewheel\\\", function (e) { return onScrollWheel(cm, e); })\\n  on(d.scroller, \\\"DOMMouseScroll\\\", function (e) { return onScrollWheel(cm, e); })\\n\\n  // Prevent wrapper from ever scrolling\\n  on(d.wrapper, \\\"scroll\\\", function () { return d.wrapper.scrollTop = d.wrapper.scrollLeft = 0; })\\n\\n  d.dragFunctions = {\\n    enter: function (e) {if (!signalDOMEvent(cm, e)) { e_stop(e) }},\\n    over: function (e) {if (!signalDOMEvent(cm, e)) { onDragOver(cm, e); e_stop(e) }},\\n    start: function (e) { return onDragStart(cm, e); },\\n    drop: operation(cm, onDrop),\\n    leave: function (e) {if (!signalDOMEvent(cm, e)) { clearDragCursor(cm) }}\\n  }\\n\\n  var inp = d.input.getField()\\n  on(inp, \\\"keyup\\\", function (e) { return onKeyUp.call(cm, e); })\\n  on(inp, \\\"keydown\\\", operation(cm, onKeyDown))\\n  on(inp, \\\"keypress\\\", operation(cm, onKeyPress))\\n  on(inp, \\\"focus\\\", function (e) { return onFocus(cm, e); })\\n  on(inp, \\\"blur\\\", function (e) { return onBlur(cm, e); })\\n}\\n\\nvar initHooks = []\\nCodeMirror.defineInitHook = function (f) { return initHooks.push(f); }\\n\\n// Indent the given line. The how parameter can be \\\"smart\\\",\\n// \\\"add\\\"/null, \\\"subtract\\\", or \\\"prev\\\". When aggressive is false\\n// (typically set to true for forced single-line indents), empty\\n// lines are not indented, and places where the mode returns Pass\\n// are left alone.\\nfunction indentLine(cm, n, how, aggressive) {\\n  var doc = cm.doc, state\\n  if (how == null) { how = \\\"add\\\" }\\n  if (how == \\\"smart\\\") {\\n    // Fall back to \\\"prev\\\" when the mode doesn't have an indentation\\n    // method.\\n    if (!doc.mode.indent) { how = \\\"prev\\\" }\\n    else { state = getStateBefore(cm, n) }\\n  }\\n\\n  var tabSize = cm.options.tabSize\\n  var line = getLine(doc, n), curSpace = countColumn(line.text, null, tabSize)\\n  if (line.stateAfter) { line.stateAfter = null }\\n  var curSpaceString = line.text.match(/^\\\\s*/)[0], indentation\\n  if (!aggressive && !/\\\\S/.test(line.text)) {\\n    indentation = 0\\n    how = \\\"not\\\"\\n  } else if (how == \\\"smart\\\") {\\n    indentation = doc.mode.indent(state, line.text.slice(curSpaceString.length), line.text)\\n    if (indentation == Pass || indentation > 150) {\\n      if (!aggressive) { return }\\n      how = \\\"prev\\\"\\n    }\\n  }\\n  if (how == \\\"prev\\\") {\\n    if (n > doc.first) { indentation = countColumn(getLine(doc, n-1).text, null, tabSize) }\\n    else { indentation = 0 }\\n  } else if (how == \\\"add\\\") {\\n    indentation = curSpace + cm.options.indentUnit\\n  } else if (how == \\\"subtract\\\") {\\n    indentation = curSpace - cm.options.indentUnit\\n  } else if (typeof how == \\\"number\\\") {\\n    indentation = curSpace + how\\n  }\\n  indentation = Math.max(0, indentation)\\n\\n  var indentString = \\\"\\\", pos = 0\\n  if (cm.options.indentWithTabs)\\n    { for (var i = Math.floor(indentation / tabSize); i; --i) {pos += tabSize; indentString += \\\"\\\\t\\\"} }\\n  if (pos < indentation) { indentString += spaceStr(indentation - pos) }\\n\\n  if (indentString != curSpaceString) {\\n    replaceRange(doc, indentString, Pos(n, 0), Pos(n, curSpaceString.length), \\\"+input\\\")\\n    line.stateAfter = null\\n    return true\\n  } else {\\n    // Ensure that, if the cursor was in the whitespace at the start\\n    // of the line, it is moved to the end of that space.\\n    for (var i$1 = 0; i$1 < doc.sel.ranges.length; i$1++) {\\n      var range = doc.sel.ranges[i$1]\\n      if (range.head.line == n && range.head.ch < curSpaceString.length) {\\n        var pos$1 = Pos(n, curSpaceString.length)\\n        replaceOneSelection(doc, i$1, new Range(pos$1, pos$1))\\n        break\\n      }\\n    }\\n  }\\n}\\n\\n// This will be set to a {lineWise: bool, text: [string]} object, so\\n// that, when pasting, we know what kind of selections the copied\\n// text was made out of.\\nvar lastCopied = null\\n\\nfunction setLastCopied(newLastCopied) {\\n  lastCopied = newLastCopied\\n}\\n\\nfunction applyTextInput(cm, inserted, deleted, sel, origin) {\\n  var doc = cm.doc\\n  cm.display.shift = false\\n  if (!sel) { sel = doc.sel }\\n\\n  var paste = cm.state.pasteIncoming || origin == \\\"paste\\\"\\n  var textLines = splitLinesAuto(inserted), multiPaste = null\\n  // When pasing N lines into N selections, insert one line per selection\\n  if (paste && sel.ranges.length > 1) {\\n    if (lastCopied && lastCopied.text.join(\\\"\\\\n\\\") == inserted) {\\n      if (sel.ranges.length % lastCopied.text.length == 0) {\\n        multiPaste = []\\n        for (var i = 0; i < lastCopied.text.length; i++)\\n          { multiPaste.push(doc.splitLines(lastCopied.text[i])) }\\n      }\\n    } else if (textLines.length == sel.ranges.length) {\\n      multiPaste = map(textLines, function (l) { return [l]; })\\n    }\\n  }\\n\\n  var updateInput\\n  // Normal behavior is to insert the new text into every selection\\n  for (var i$1 = sel.ranges.length - 1; i$1 >= 0; i$1--) {\\n    var range = sel.ranges[i$1]\\n    var from = range.from(), to = range.to()\\n    if (range.empty()) {\\n      if (deleted && deleted > 0) // Handle deletion\\n        { from = Pos(from.line, from.ch - deleted) }\\n      else if (cm.state.overwrite && !paste) // Handle overwrite\\n        { to = Pos(to.line, Math.min(getLine(doc, to.line).text.length, to.ch + lst(textLines).length)) }\\n      else if (lastCopied && lastCopied.lineWise && lastCopied.text.join(\\\"\\\\n\\\") == inserted)\\n        { from = to = Pos(from.line, 0) }\\n    }\\n    updateInput = cm.curOp.updateInput\\n    var changeEvent = {from: from, to: to, text: multiPaste ? multiPaste[i$1 % multiPaste.length] : textLines,\\n                       origin: origin || (paste ? \\\"paste\\\" : cm.state.cutIncoming ? \\\"cut\\\" : \\\"+input\\\")}\\n    makeChange(cm.doc, changeEvent)\\n    signalLater(cm, \\\"inputRead\\\", cm, changeEvent)\\n  }\\n  if (inserted && !paste)\\n    { triggerElectric(cm, inserted) }\\n\\n  ensureCursorVisible(cm)\\n  cm.curOp.updateInput = updateInput\\n  cm.curOp.typing = true\\n  cm.state.pasteIncoming = cm.state.cutIncoming = false\\n}\\n\\nfunction handlePaste(e, cm) {\\n  var pasted = e.clipboardData && e.clipboardData.getData(\\\"Text\\\")\\n  if (pasted) {\\n    e.preventDefault()\\n    if (!cm.isReadOnly() && !cm.options.disableInput)\\n      { runInOp(cm, function () { return applyTextInput(cm, pasted, 0, null, \\\"paste\\\"); }) }\\n    return true\\n  }\\n}\\n\\nfunction triggerElectric(cm, inserted) {\\n  // When an 'electric' character is inserted, immediately trigger a reindent\\n  if (!cm.options.electricChars || !cm.options.smartIndent) { return }\\n  var sel = cm.doc.sel\\n\\n  for (var i = sel.ranges.length - 1; i >= 0; i--) {\\n    var range = sel.ranges[i]\\n    if (range.head.ch > 100 || (i && sel.ranges[i - 1].head.line == range.head.line)) { continue }\\n    var mode = cm.getModeAt(range.head)\\n    var indented = false\\n    if (mode.electricChars) {\\n      for (var j = 0; j < mode.electricChars.length; j++)\\n        { if (inserted.indexOf(mode.electricChars.charAt(j)) > -1) {\\n          indented = indentLine(cm, range.head.line, \\\"smart\\\")\\n          break\\n        } }\\n    } else if (mode.electricInput) {\\n      if (mode.electricInput.test(getLine(cm.doc, range.head.line).text.slice(0, range.head.ch)))\\n        { indented = indentLine(cm, range.head.line, \\\"smart\\\") }\\n    }\\n    if (indented) { signalLater(cm, \\\"electricInput\\\", cm, range.head.line) }\\n  }\\n}\\n\\nfunction copyableRanges(cm) {\\n  var text = [], ranges = []\\n  for (var i = 0; i < cm.doc.sel.ranges.length; i++) {\\n    var line = cm.doc.sel.ranges[i].head.line\\n    var lineRange = {anchor: Pos(line, 0), head: Pos(line + 1, 0)}\\n    ranges.push(lineRange)\\n    text.push(cm.getRange(lineRange.anchor, lineRange.head))\\n  }\\n  return {text: text, ranges: ranges}\\n}\\n\\nfunction disableBrowserMagic(field, spellcheck) {\\n  field.setAttribute(\\\"autocorrect\\\", \\\"off\\\")\\n  field.setAttribute(\\\"autocapitalize\\\", \\\"off\\\")\\n  field.setAttribute(\\\"spellcheck\\\", !!spellcheck)\\n}\\n\\nfunction hiddenTextarea() {\\n  var te = elt(\\\"textarea\\\", null, null, \\\"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none\\\")\\n  var div = elt(\\\"div\\\", [te], null, \\\"overflow: hidden; position: relative; width: 3px; height: 0px;\\\")\\n  // The textarea is kept positioned near the cursor to prevent the\\n  // fact that it'll be scrolled into view on input from scrolling\\n  // our fake cursor out of view. On webkit, when wrap=off, paste is\\n  // very slow. So make the area wide instead.\\n  if (webkit) { te.style.width = \\\"1000px\\\" }\\n  else { te.setAttribute(\\\"wrap\\\", \\\"off\\\") }\\n  // If border: 0; -- iOS fails to open keyboard (issue #1287)\\n  if (ios) { te.style.border = \\\"1px solid black\\\" }\\n  disableBrowserMagic(te)\\n  return div\\n}\\n\\n// The publicly visible API. Note that methodOp(f) means\\n// 'wrap f in an operation, performed on its `this` parameter'.\\n\\n// This is not the complete set of editor methods. Most of the\\n// methods defined on the Doc type are also injected into\\n// CodeMirror.prototype, for backwards compatibility and\\n// convenience.\\n\\nfunction addEditorMethods(CodeMirror) {\\n  var optionHandlers = CodeMirror.optionHandlers\\n\\n  var helpers = CodeMirror.helpers = {}\\n\\n  CodeMirror.prototype = {\\n    constructor: CodeMirror,\\n    focus: function(){window.focus(); this.display.input.focus()},\\n\\n    setOption: function(option, value) {\\n      var options = this.options, old = options[option]\\n      if (options[option] == value && option != \\\"mode\\\") { return }\\n      options[option] = value\\n      if (optionHandlers.hasOwnProperty(option))\\n        { operation(this, optionHandlers[option])(this, value, old) }\\n      signal(this, \\\"optionChange\\\", this, option)\\n    },\\n\\n    getOption: function(option) {return this.options[option]},\\n    getDoc: function() {return this.doc},\\n\\n    addKeyMap: function(map, bottom) {\\n      this.state.keyMaps[bottom ? \\\"push\\\" : \\\"unshift\\\"](getKeyMap(map))\\n    },\\n    removeKeyMap: function(map) {\\n      var maps = this.state.keyMaps\\n      for (var i = 0; i < maps.length; ++i)\\n        { if (maps[i] == map || maps[i].name == map) {\\n          maps.splice(i, 1)\\n          return true\\n        } }\\n    },\\n\\n    addOverlay: methodOp(function(spec, options) {\\n      var mode = spec.token ? spec : CodeMirror.getMode(this.options, spec)\\n      if (mode.startState) { throw new Error(\\\"Overlays may not be stateful.\\\") }\\n      insertSorted(this.state.overlays,\\n                   {mode: mode, modeSpec: spec, opaque: options && options.opaque,\\n                    priority: (options && options.priority) || 0},\\n                   function (overlay) { return overlay.priority; })\\n      this.state.modeGen++\\n      regChange(this)\\n    }),\\n    removeOverlay: methodOp(function(spec) {\\n      var this$1 = this;\\n\\n      var overlays = this.state.overlays\\n      for (var i = 0; i < overlays.length; ++i) {\\n        var cur = overlays[i].modeSpec\\n        if (cur == spec || typeof spec == \\\"string\\\" && cur.name == spec) {\\n          overlays.splice(i, 1)\\n          this$1.state.modeGen++\\n          regChange(this$1)\\n          return\\n        }\\n      }\\n    }),\\n\\n    indentLine: methodOp(function(n, dir, aggressive) {\\n      if (typeof dir != \\\"string\\\" && typeof dir != \\\"number\\\") {\\n        if (dir == null) { dir = this.options.smartIndent ? \\\"smart\\\" : \\\"prev\\\" }\\n        else { dir = dir ? \\\"add\\\" : \\\"subtract\\\" }\\n      }\\n      if (isLine(this.doc, n)) { indentLine(this, n, dir, aggressive) }\\n    }),\\n    indentSelection: methodOp(function(how) {\\n      var this$1 = this;\\n\\n      var ranges = this.doc.sel.ranges, end = -1\\n      for (var i = 0; i < ranges.length; i++) {\\n        var range = ranges[i]\\n        if (!range.empty()) {\\n          var from = range.from(), to = range.to()\\n          var start = Math.max(end, from.line)\\n          end = Math.min(this$1.lastLine(), to.line - (to.ch ? 0 : 1)) + 1\\n          for (var j = start; j < end; ++j)\\n            { indentLine(this$1, j, how) }\\n          var newRanges = this$1.doc.sel.ranges\\n          if (from.ch == 0 && ranges.length == newRanges.length && newRanges[i].from().ch > 0)\\n            { replaceOneSelection(this$1.doc, i, new Range(from, newRanges[i].to()), sel_dontScroll) }\\n        } else if (range.head.line > end) {\\n          indentLine(this$1, range.head.line, how, true)\\n          end = range.head.line\\n          if (i == this$1.doc.sel.primIndex) { ensureCursorVisible(this$1) }\\n        }\\n      }\\n    }),\\n\\n    // Fetch the parser token for a given character. Useful for hacks\\n    // that want to inspect the mode state (say, for completion).\\n    getTokenAt: function(pos, precise) {\\n      return takeToken(this, pos, precise)\\n    },\\n\\n    getLineTokens: function(line, precise) {\\n      return takeToken(this, Pos(line), precise, true)\\n    },\\n\\n    getTokenTypeAt: function(pos) {\\n      pos = clipPos(this.doc, pos)\\n      var styles = getLineStyles(this, getLine(this.doc, pos.line))\\n      var before = 0, after = (styles.length - 1) / 2, ch = pos.ch\\n      var type\\n      if (ch == 0) { type = styles[2] }\\n      else { for (;;) {\\n        var mid = (before + after) >> 1\\n        if ((mid ? styles[mid * 2 - 1] : 0) >= ch) { after = mid }\\n        else if (styles[mid * 2 + 1] < ch) { before = mid + 1 }\\n        else { type = styles[mid * 2 + 2]; break }\\n      } }\\n      var cut = type ? type.indexOf(\\\"overlay \\\") : -1\\n      return cut < 0 ? type : cut == 0 ? null : type.slice(0, cut - 1)\\n    },\\n\\n    getModeAt: function(pos) {\\n      var mode = this.doc.mode\\n      if (!mode.innerMode) { return mode }\\n      return CodeMirror.innerMode(mode, this.getTokenAt(pos).state).mode\\n    },\\n\\n    getHelper: function(pos, type) {\\n      return this.getHelpers(pos, type)[0]\\n    },\\n\\n    getHelpers: function(pos, type) {\\n      var this$1 = this;\\n\\n      var found = []\\n      if (!helpers.hasOwnProperty(type)) { return found }\\n      var help = helpers[type], mode = this.getModeAt(pos)\\n      if (typeof mode[type] == \\\"string\\\") {\\n        if (help[mode[type]]) { found.push(help[mode[type]]) }\\n      } else if (mode[type]) {\\n        for (var i = 0; i < mode[type].length; i++) {\\n          var val = help[mode[type][i]]\\n          if (val) { found.push(val) }\\n        }\\n      } else if (mode.helperType && help[mode.helperType]) {\\n        found.push(help[mode.helperType])\\n      } else if (help[mode.name]) {\\n        found.push(help[mode.name])\\n      }\\n      for (var i$1 = 0; i$1 < help._global.length; i$1++) {\\n        var cur = help._global[i$1]\\n        if (cur.pred(mode, this$1) && indexOf(found, cur.val) == -1)\\n          { found.push(cur.val) }\\n      }\\n      return found\\n    },\\n\\n    getStateAfter: function(line, precise) {\\n      var doc = this.doc\\n      line = clipLine(doc, line == null ? doc.first + doc.size - 1: line)\\n      return getStateBefore(this, line + 1, precise)\\n    },\\n\\n    cursorCoords: function(start, mode) {\\n      var pos, range = this.doc.sel.primary()\\n      if (start == null) { pos = range.head }\\n      else if (typeof start == \\\"object\\\") { pos = clipPos(this.doc, start) }\\n      else { pos = start ? range.from() : range.to() }\\n      return cursorCoords(this, pos, mode || \\\"page\\\")\\n    },\\n\\n    charCoords: function(pos, mode) {\\n      return charCoords(this, clipPos(this.doc, pos), mode || \\\"page\\\")\\n    },\\n\\n    coordsChar: function(coords, mode) {\\n      coords = fromCoordSystem(this, coords, mode || \\\"page\\\")\\n      return coordsChar(this, coords.left, coords.top)\\n    },\\n\\n    lineAtHeight: function(height, mode) {\\n      height = fromCoordSystem(this, {top: height, left: 0}, mode || \\\"page\\\").top\\n      return lineAtHeight(this.doc, height + this.display.viewOffset)\\n    },\\n    heightAtLine: function(line, mode, includeWidgets) {\\n      var end = false, lineObj\\n      if (typeof line == \\\"number\\\") {\\n        var last = this.doc.first + this.doc.size - 1\\n        if (line < this.doc.first) { line = this.doc.first }\\n        else if (line > last) { line = last; end = true }\\n        lineObj = getLine(this.doc, line)\\n      } else {\\n        lineObj = line\\n      }\\n      return intoCoordSystem(this, lineObj, {top: 0, left: 0}, mode || \\\"page\\\", includeWidgets || end).top +\\n        (end ? this.doc.height - heightAtLine(lineObj) : 0)\\n    },\\n\\n    defaultTextHeight: function() { return textHeight(this.display) },\\n    defaultCharWidth: function() { return charWidth(this.display) },\\n\\n    getViewport: function() { return {from: this.display.viewFrom, to: this.display.viewTo}},\\n\\n    addWidget: function(pos, node, scroll, vert, horiz) {\\n      var display = this.display\\n      pos = cursorCoords(this, clipPos(this.doc, pos))\\n      var top = pos.bottom, left = pos.left\\n      node.style.position = \\\"absolute\\\"\\n      node.setAttribute(\\\"cm-ignore-events\\\", \\\"true\\\")\\n      this.display.input.setUneditable(node)\\n      display.sizer.appendChild(node)\\n      if (vert == \\\"over\\\") {\\n        top = pos.top\\n      } else if (vert == \\\"above\\\" || vert == \\\"near\\\") {\\n        var vspace = Math.max(display.wrapper.clientHeight, this.doc.height),\\n        hspace = Math.max(display.sizer.clientWidth, display.lineSpace.clientWidth)\\n        // Default to positioning above (if specified and possible); otherwise default to positioning below\\n        if ((vert == 'above' || pos.bottom + node.offsetHeight > vspace) && pos.top > node.offsetHeight)\\n          { top = pos.top - node.offsetHeight }\\n        else if (pos.bottom + node.offsetHeight <= vspace)\\n          { top = pos.bottom }\\n        if (left + node.offsetWidth > hspace)\\n          { left = hspace - node.offsetWidth }\\n      }\\n      node.style.top = top + \\\"px\\\"\\n      node.style.left = node.style.right = \\\"\\\"\\n      if (horiz == \\\"right\\\") {\\n        left = display.sizer.clientWidth - node.offsetWidth\\n        node.style.right = \\\"0px\\\"\\n      } else {\\n        if (horiz == \\\"left\\\") { left = 0 }\\n        else if (horiz == \\\"middle\\\") { left = (display.sizer.clientWidth - node.offsetWidth) / 2 }\\n        node.style.left = left + \\\"px\\\"\\n      }\\n      if (scroll)\\n        { scrollIntoView(this, left, top, left + node.offsetWidth, top + node.offsetHeight) }\\n    },\\n\\n    triggerOnKeyDown: methodOp(onKeyDown),\\n    triggerOnKeyPress: methodOp(onKeyPress),\\n    triggerOnKeyUp: onKeyUp,\\n\\n    execCommand: function(cmd) {\\n      if (commands.hasOwnProperty(cmd))\\n        { return commands[cmd].call(null, this) }\\n    },\\n\\n    triggerElectric: methodOp(function(text) { triggerElectric(this, text) }),\\n\\n    findPosH: function(from, amount, unit, visually) {\\n      var this$1 = this;\\n\\n      var dir = 1\\n      if (amount < 0) { dir = -1; amount = -amount }\\n      var cur = clipPos(this.doc, from)\\n      for (var i = 0; i < amount; ++i) {\\n        cur = findPosH(this$1.doc, cur, dir, unit, visually)\\n        if (cur.hitSide) { break }\\n      }\\n      return cur\\n    },\\n\\n    moveH: methodOp(function(dir, unit) {\\n      var this$1 = this;\\n\\n      this.extendSelectionsBy(function (range) {\\n        if (this$1.display.shift || this$1.doc.extend || range.empty())\\n          { return findPosH(this$1.doc, range.head, dir, unit, this$1.options.rtlMoveVisually) }\\n        else\\n          { return dir < 0 ? range.from() : range.to() }\\n      }, sel_move)\\n    }),\\n\\n    deleteH: methodOp(function(dir, unit) {\\n      var sel = this.doc.sel, doc = this.doc\\n      if (sel.somethingSelected())\\n        { doc.replaceSelection(\\\"\\\", null, \\\"+delete\\\") }\\n      else\\n        { deleteNearSelection(this, function (range) {\\n          var other = findPosH(doc, range.head, dir, unit, false)\\n          return dir < 0 ? {from: other, to: range.head} : {from: range.head, to: other}\\n        }) }\\n    }),\\n\\n    findPosV: function(from, amount, unit, goalColumn) {\\n      var this$1 = this;\\n\\n      var dir = 1, x = goalColumn\\n      if (amount < 0) { dir = -1; amount = -amount }\\n      var cur = clipPos(this.doc, from)\\n      for (var i = 0; i < amount; ++i) {\\n        var coords = cursorCoords(this$1, cur, \\\"div\\\")\\n        if (x == null) { x = coords.left }\\n        else { coords.left = x }\\n        cur = findPosV(this$1, coords, dir, unit)\\n        if (cur.hitSide) { break }\\n      }\\n      return cur\\n    },\\n\\n    moveV: methodOp(function(dir, unit) {\\n      var this$1 = this;\\n\\n      var doc = this.doc, goals = []\\n      var collapse = !this.display.shift && !doc.extend && doc.sel.somethingSelected()\\n      doc.extendSelectionsBy(function (range) {\\n        if (collapse)\\n          { return dir < 0 ? range.from() : range.to() }\\n        var headPos = cursorCoords(this$1, range.head, \\\"div\\\")\\n        if (range.goalColumn != null) { headPos.left = range.goalColumn }\\n        goals.push(headPos.left)\\n        var pos = findPosV(this$1, headPos, dir, unit)\\n        if (unit == \\\"page\\\" && range == doc.sel.primary())\\n          { addToScrollPos(this$1, null, charCoords(this$1, pos, \\\"div\\\").top - headPos.top) }\\n        return pos\\n      }, sel_move)\\n      if (goals.length) { for (var i = 0; i < doc.sel.ranges.length; i++)\\n        { doc.sel.ranges[i].goalColumn = goals[i] } }\\n    }),\\n\\n    // Find the word at the given position (as returned by coordsChar).\\n    findWordAt: function(pos) {\\n      var doc = this.doc, line = getLine(doc, pos.line).text\\n      var start = pos.ch, end = pos.ch\\n      if (line) {\\n        var helper = this.getHelper(pos, \\\"wordChars\\\")\\n        if ((pos.sticky == \\\"before\\\" || end == line.length) && start) { --start; } else { ++end }\\n        var startChar = line.charAt(start)\\n        var check = isWordChar(startChar, helper)\\n          ? function (ch) { return isWordChar(ch, helper); }\\n          : /\\\\s/.test(startChar) ? function (ch) { return /\\\\s/.test(ch); }\\n          : function (ch) { return (!/\\\\s/.test(ch) && !isWordChar(ch)); }\\n        while (start > 0 && check(line.charAt(start - 1))) { --start }\\n        while (end < line.length && check(line.charAt(end))) { ++end }\\n      }\\n      return new Range(Pos(pos.line, start), Pos(pos.line, end))\\n    },\\n\\n    toggleOverwrite: function(value) {\\n      if (value != null && value == this.state.overwrite) { return }\\n      if (this.state.overwrite = !this.state.overwrite)\\n        { addClass(this.display.cursorDiv, \\\"CodeMirror-overwrite\\\") }\\n      else\\n        { rmClass(this.display.cursorDiv, \\\"CodeMirror-overwrite\\\") }\\n\\n      signal(this, \\\"overwriteToggle\\\", this, this.state.overwrite)\\n    },\\n    hasFocus: function() { return this.display.input.getField() == activeElt() },\\n    isReadOnly: function() { return !!(this.options.readOnly || this.doc.cantEdit) },\\n\\n    scrollTo: methodOp(function(x, y) {\\n      if (x != null || y != null) { resolveScrollToPos(this) }\\n      if (x != null) { this.curOp.scrollLeft = x }\\n      if (y != null) { this.curOp.scrollTop = y }\\n    }),\\n    getScrollInfo: function() {\\n      var scroller = this.display.scroller\\n      return {left: scroller.scrollLeft, top: scroller.scrollTop,\\n              height: scroller.scrollHeight - scrollGap(this) - this.display.barHeight,\\n              width: scroller.scrollWidth - scrollGap(this) - this.display.barWidth,\\n              clientHeight: displayHeight(this), clientWidth: displayWidth(this)}\\n    },\\n\\n    scrollIntoView: methodOp(function(range, margin) {\\n      if (range == null) {\\n        range = {from: this.doc.sel.primary().head, to: null}\\n        if (margin == null) { margin = this.options.cursorScrollMargin }\\n      } else if (typeof range == \\\"number\\\") {\\n        range = {from: Pos(range, 0), to: null}\\n      } else if (range.from == null) {\\n        range = {from: range, to: null}\\n      }\\n      if (!range.to) { range.to = range.from }\\n      range.margin = margin || 0\\n\\n      if (range.from.line != null) {\\n        resolveScrollToPos(this)\\n        this.curOp.scrollToPos = range\\n      } else {\\n        var sPos = calculateScrollPos(this, Math.min(range.from.left, range.to.left),\\n                                      Math.min(range.from.top, range.to.top) - range.margin,\\n                                      Math.max(range.from.right, range.to.right),\\n                                      Math.max(range.from.bottom, range.to.bottom) + range.margin)\\n        this.scrollTo(sPos.scrollLeft, sPos.scrollTop)\\n      }\\n    }),\\n\\n    setSize: methodOp(function(width, height) {\\n      var this$1 = this;\\n\\n      var interpret = function (val) { return typeof val == \\\"number\\\" || /^\\\\d+$/.test(String(val)) ? val + \\\"px\\\" : val; }\\n      if (width != null) { this.display.wrapper.style.width = interpret(width) }\\n      if (height != null) { this.display.wrapper.style.height = interpret(height) }\\n      if (this.options.lineWrapping) { clearLineMeasurementCache(this) }\\n      var lineNo = this.display.viewFrom\\n      this.doc.iter(lineNo, this.display.viewTo, function (line) {\\n        if (line.widgets) { for (var i = 0; i < line.widgets.length; i++)\\n          { if (line.widgets[i].noHScroll) { regLineChange(this$1, lineNo, \\\"widget\\\"); break } } }\\n        ++lineNo\\n      })\\n      this.curOp.forceUpdate = true\\n      signal(this, \\\"refresh\\\", this)\\n    }),\\n\\n    operation: function(f){return runInOp(this, f)},\\n\\n    refresh: methodOp(function() {\\n      var oldHeight = this.display.cachedTextHeight\\n      regChange(this)\\n      this.curOp.forceUpdate = true\\n      clearCaches(this)\\n      this.scrollTo(this.doc.scrollLeft, this.doc.scrollTop)\\n      updateGutterSpace(this)\\n      if (oldHeight == null || Math.abs(oldHeight - textHeight(this.display)) > .5)\\n        { estimateLineHeights(this) }\\n      signal(this, \\\"refresh\\\", this)\\n    }),\\n\\n    swapDoc: methodOp(function(doc) {\\n      var old = this.doc\\n      old.cm = null\\n      attachDoc(this, doc)\\n      clearCaches(this)\\n      this.display.input.reset()\\n      this.scrollTo(doc.scrollLeft, doc.scrollTop)\\n      this.curOp.forceScroll = true\\n      signalLater(this, \\\"swapDoc\\\", this, old)\\n      return old\\n    }),\\n\\n    getInputField: function(){return this.display.input.getField()},\\n    getWrapperElement: function(){return this.display.wrapper},\\n    getScrollerElement: function(){return this.display.scroller},\\n    getGutterElement: function(){return this.display.gutters}\\n  }\\n  eventMixin(CodeMirror)\\n\\n  CodeMirror.registerHelper = function(type, name, value) {\\n    if (!helpers.hasOwnProperty(type)) { helpers[type] = CodeMirror[type] = {_global: []} }\\n    helpers[type][name] = value\\n  }\\n  CodeMirror.registerGlobalHelper = function(type, name, predicate, value) {\\n    CodeMirror.registerHelper(type, name, value)\\n    helpers[type]._global.push({pred: predicate, val: value})\\n  }\\n}\\n\\n// Used for horizontal relative motion. Dir is -1 or 1 (left or\\n// right), unit can be \\\"char\\\", \\\"column\\\" (like char, but doesn't\\n// cross line boundaries), \\\"word\\\" (across next word), or \\\"group\\\" (to\\n// the start of next group of word or non-word-non-whitespace\\n// chars). The visually param controls whether, in right-to-left\\n// text, direction 1 means to move towards the next index in the\\n// string, or towards the character to the right of the current\\n// position. The resulting position will have a hitSide=true\\n// property if it reached the end of the document.\\nfunction findPosH(doc, pos, dir, unit, visually) {\\n  var oldPos = pos\\n  var origDir = dir\\n  var lineObj = getLine(doc, pos.line)\\n  function findNextLine() {\\n    var l = pos.line + dir\\n    if (l < doc.first || l >= doc.first + doc.size) { return false }\\n    pos = new Pos(l, pos.ch, pos.sticky)\\n    return lineObj = getLine(doc, l)\\n  }\\n  function moveOnce(boundToLine) {\\n    var next\\n    if (visually) {\\n      next = moveVisually(doc.cm, lineObj, pos, dir)\\n    } else {\\n      next = moveLogically(lineObj, pos, dir)\\n    }\\n    if (next == null) {\\n      if (!boundToLine && findNextLine())\\n        { pos = endOfLine(visually, doc.cm, lineObj, pos.line, dir) }\\n      else\\n        { return false }\\n    } else {\\n      pos = next\\n    }\\n    return true\\n  }\\n\\n  if (unit == \\\"char\\\") {\\n    moveOnce()\\n  } else if (unit == \\\"column\\\") {\\n    moveOnce(true)\\n  } else if (unit == \\\"word\\\" || unit == \\\"group\\\") {\\n    var sawType = null, group = unit == \\\"group\\\"\\n    var helper = doc.cm && doc.cm.getHelper(pos, \\\"wordChars\\\")\\n    for (var first = true;; first = false) {\\n      if (dir < 0 && !moveOnce(!first)) { break }\\n      var cur = lineObj.text.charAt(pos.ch) || \\\"\\\\n\\\"\\n      var type = isWordChar(cur, helper) ? \\\"w\\\"\\n        : group && cur == \\\"\\\\n\\\" ? \\\"n\\\"\\n        : !group || /\\\\s/.test(cur) ? null\\n        : \\\"p\\\"\\n      if (group && !first && !type) { type = \\\"s\\\" }\\n      if (sawType && sawType != type) {\\n        if (dir < 0) {dir = 1; moveOnce(); pos.sticky = \\\"after\\\"}\\n        break\\n      }\\n\\n      if (type) { sawType = type }\\n      if (dir > 0 && !moveOnce(!first)) { break }\\n    }\\n  }\\n  var result = skipAtomic(doc, pos, oldPos, origDir, true)\\n  if (equalCursorPos(oldPos, result)) { result.hitSide = true }\\n  return result\\n}\\n\\n// For relative vertical movement. Dir may be -1 or 1. Unit can be\\n// \\\"page\\\" or \\\"line\\\". The resulting position will have a hitSide=true\\n// property if it reached the end of the document.\\nfunction findPosV(cm, pos, dir, unit) {\\n  var doc = cm.doc, x = pos.left, y\\n  if (unit == \\\"page\\\") {\\n    var pageSize = Math.min(cm.display.wrapper.clientHeight, window.innerHeight || document.documentElement.clientHeight)\\n    var moveAmount = Math.max(pageSize - .5 * textHeight(cm.display), 3)\\n    y = (dir > 0 ? pos.bottom : pos.top) + dir * moveAmount\\n\\n  } else if (unit == \\\"line\\\") {\\n    y = dir > 0 ? pos.bottom + 3 : pos.top - 3\\n  }\\n  var target\\n  for (;;) {\\n    target = coordsChar(cm, x, y)\\n    if (!target.outside) { break }\\n    if (dir < 0 ? y <= 0 : y >= doc.height) { target.hitSide = true; break }\\n    y += dir * 5\\n  }\\n  return target\\n}\\n\\n// CONTENTEDITABLE INPUT STYLE\\n\\nvar ContentEditableInput = function(cm) {\\n  this.cm = cm\\n  this.lastAnchorNode = this.lastAnchorOffset = this.lastFocusNode = this.lastFocusOffset = null\\n  this.polling = new Delayed()\\n  this.composing = null\\n  this.gracePeriod = false\\n  this.readDOMTimeout = null\\n};\\n\\nContentEditableInput.prototype.init = function (display) {\\n    var this$1 = this;\\n\\n  var input = this, cm = input.cm\\n  var div = input.div = display.lineDiv\\n  disableBrowserMagic(div, cm.options.spellcheck)\\n\\n  on(div, \\\"paste\\\", function (e) {\\n    if (signalDOMEvent(cm, e) || handlePaste(e, cm)) { return }\\n    // IE doesn't fire input events, so we schedule a read for the pasted content in this way\\n    if (ie_version <= 11) { setTimeout(operation(cm, function () {\\n      if (!input.pollContent()) { regChange(cm) }\\n    }), 20) }\\n  })\\n\\n  on(div, \\\"compositionstart\\\", function (e) {\\n    this$1.composing = {data: e.data, done: false}\\n  })\\n  on(div, \\\"compositionupdate\\\", function (e) {\\n    if (!this$1.composing) { this$1.composing = {data: e.data, done: false} }\\n  })\\n  on(div, \\\"compositionend\\\", function (e) {\\n    if (this$1.composing) {\\n      if (e.data != this$1.composing.data) { this$1.readFromDOMSoon() }\\n      this$1.composing.done = true\\n    }\\n  })\\n\\n  on(div, \\\"touchstart\\\", function () { return input.forceCompositionEnd(); })\\n\\n  on(div, \\\"input\\\", function () {\\n    if (!this$1.composing) { this$1.readFromDOMSoon() }\\n  })\\n\\n  function onCopyCut(e) {\\n    if (signalDOMEvent(cm, e)) { return }\\n    if (cm.somethingSelected()) {\\n      setLastCopied({lineWise: false, text: cm.getSelections()})\\n      if (e.type == \\\"cut\\\") { cm.replaceSelection(\\\"\\\", null, \\\"cut\\\") }\\n    } else if (!cm.options.lineWiseCopyCut) {\\n      return\\n    } else {\\n      var ranges = copyableRanges(cm)\\n      setLastCopied({lineWise: true, text: ranges.text})\\n      if (e.type == \\\"cut\\\") {\\n        cm.operation(function () {\\n          cm.setSelections(ranges.ranges, 0, sel_dontScroll)\\n          cm.replaceSelection(\\\"\\\", null, \\\"cut\\\")\\n        })\\n      }\\n    }\\n    if (e.clipboardData) {\\n      e.clipboardData.clearData()\\n      var content = lastCopied.text.join(\\\"\\\\n\\\")\\n      // iOS exposes the clipboard API, but seems to discard content inserted into it\\n      e.clipboardData.setData(\\\"Text\\\", content)\\n      if (e.clipboardData.getData(\\\"Text\\\") == content) {\\n        e.preventDefault()\\n        return\\n      }\\n    }\\n    // Old-fashioned briefly-focus-a-textarea hack\\n    var kludge = hiddenTextarea(), te = kludge.firstChild\\n    cm.display.lineSpace.insertBefore(kludge, cm.display.lineSpace.firstChild)\\n    te.value = lastCopied.text.join(\\\"\\\\n\\\")\\n    var hadFocus = document.activeElement\\n    selectInput(te)\\n    setTimeout(function () {\\n      cm.display.lineSpace.removeChild(kludge)\\n      hadFocus.focus()\\n      if (hadFocus == div) { input.showPrimarySelection() }\\n    }, 50)\\n  }\\n  on(div, \\\"copy\\\", onCopyCut)\\n  on(div, \\\"cut\\\", onCopyCut)\\n};\\n\\nContentEditableInput.prototype.prepareSelection = function () {\\n  var result = prepareSelection(this.cm, false)\\n  result.focus = this.cm.state.focused\\n  return result\\n};\\n\\nContentEditableInput.prototype.showSelection = function (info, takeFocus) {\\n  if (!info || !this.cm.display.view.length) { return }\\n  if (info.focus || takeFocus) { this.showPrimarySelection() }\\n  this.showMultipleSelections(info)\\n};\\n\\nContentEditableInput.prototype.showPrimarySelection = function () {\\n  var sel = window.getSelection(), prim = this.cm.doc.sel.primary()\\n  var curAnchor = domToPos(this.cm, sel.anchorNode, sel.anchorOffset)\\n  var curFocus = domToPos(this.cm, sel.focusNode, sel.focusOffset)\\n  if (curAnchor && !curAnchor.bad && curFocus && !curFocus.bad &&\\n      cmp(minPos(curAnchor, curFocus), prim.from()) == 0 &&\\n      cmp(maxPos(curAnchor, curFocus), prim.to()) == 0)\\n    { return }\\n\\n  var start = posToDOM(this.cm, prim.from())\\n  var end = posToDOM(this.cm, prim.to())\\n  if (!start && !end) { return }\\n\\n  var view = this.cm.display.view\\n  var old = sel.rangeCount && sel.getRangeAt(0)\\n  if (!start) {\\n    start = {node: view[0].measure.map[2], offset: 0}\\n  } else if (!end) { // FIXME dangerously hacky\\n    var measure = view[view.length - 1].measure\\n    var map = measure.maps ? measure.maps[measure.maps.length - 1] : measure.map\\n    end = {node: map[map.length - 1], offset: map[map.length - 2] - map[map.length - 3]}\\n  }\\n\\n  var rng\\n  try { rng = range(start.node, start.offset, end.offset, end.node) }\\n  catch(e) {} // Our model of the DOM might be outdated, in which case the range we try to set can be impossible\\n  if (rng) {\\n    if (!gecko && this.cm.state.focused) {\\n      sel.collapse(start.node, start.offset)\\n      if (!rng.collapsed) {\\n        sel.removeAllRanges()\\n        sel.addRange(rng)\\n      }\\n    } else {\\n      sel.removeAllRanges()\\n      sel.addRange(rng)\\n    }\\n    if (old && sel.anchorNode == null) { sel.addRange(old) }\\n    else if (gecko) { this.startGracePeriod() }\\n  }\\n  this.rememberSelection()\\n};\\n\\nContentEditableInput.prototype.startGracePeriod = function () {\\n    var this$1 = this;\\n\\n  clearTimeout(this.gracePeriod)\\n  this.gracePeriod = setTimeout(function () {\\n    this$1.gracePeriod = false\\n    if (this$1.selectionChanged())\\n      { this$1.cm.operation(function () { return this$1.cm.curOp.selectionChanged = true; }) }\\n  }, 20)\\n};\\n\\nContentEditableInput.prototype.showMultipleSelections = function (info) {\\n  removeChildrenAndAdd(this.cm.display.cursorDiv, info.cursors)\\n  removeChildrenAndAdd(this.cm.display.selectionDiv, info.selection)\\n};\\n\\nContentEditableInput.prototype.rememberSelection = function () {\\n  var sel = window.getSelection()\\n  this.lastAnchorNode = sel.anchorNode; this.lastAnchorOffset = sel.anchorOffset\\n  this.lastFocusNode = sel.focusNode; this.lastFocusOffset = sel.focusOffset\\n};\\n\\nContentEditableInput.prototype.selectionInEditor = function () {\\n  var sel = window.getSelection()\\n  if (!sel.rangeCount) { return false }\\n  var node = sel.getRangeAt(0).commonAncestorContainer\\n  return contains(this.div, node)\\n};\\n\\nContentEditableInput.prototype.focus = function () {\\n  if (this.cm.options.readOnly != \\\"nocursor\\\") {\\n    if (!this.selectionInEditor())\\n      { this.showSelection(this.prepareSelection(), true) }\\n    this.div.focus()\\n  }\\n};\\nContentEditableInput.prototype.blur = function () { this.div.blur() };\\nContentEditableInput.prototype.getField = function () { return this.div };\\n\\nContentEditableInput.prototype.supportsTouch = function () { return true };\\n\\nContentEditableInput.prototype.receivedFocus = function () {\\n  var input = this\\n  if (this.selectionInEditor())\\n    { this.pollSelection() }\\n  else\\n    { runInOp(this.cm, function () { return input.cm.curOp.selectionChanged = true; }) }\\n\\n  function poll() {\\n    if (input.cm.state.focused) {\\n      input.pollSelection()\\n      input.polling.set(input.cm.options.pollInterval, poll)\\n    }\\n  }\\n  this.polling.set(this.cm.options.pollInterval, poll)\\n};\\n\\nContentEditableInput.prototype.selectionChanged = function () {\\n  var sel = window.getSelection()\\n  return sel.anchorNode != this.lastAnchorNode || sel.anchorOffset != this.lastAnchorOffset ||\\n    sel.focusNode != this.lastFocusNode || sel.focusOffset != this.lastFocusOffset\\n};\\n\\nContentEditableInput.prototype.pollSelection = function () {\\n  if (!this.composing && this.readDOMTimeout == null && !this.gracePeriod && this.selectionChanged()) {\\n    var sel = window.getSelection(), cm = this.cm\\n    this.rememberSelection()\\n    var anchor = domToPos(cm, sel.anchorNode, sel.anchorOffset)\\n    var head = domToPos(cm, sel.focusNode, sel.focusOffset)\\n    if (anchor && head) { runInOp(cm, function () {\\n      setSelection(cm.doc, simpleSelection(anchor, head), sel_dontScroll)\\n      if (anchor.bad || head.bad) { cm.curOp.selectionChanged = true }\\n    }) }\\n  }\\n};\\n\\nContentEditableInput.prototype.pollContent = function () {\\n  if (this.readDOMTimeout != null) {\\n    clearTimeout(this.readDOMTimeout)\\n    this.readDOMTimeout = null\\n  }\\n\\n  var cm = this.cm, display = cm.display, sel = cm.doc.sel.primary()\\n  var from = sel.from(), to = sel.to()\\n  if (from.ch == 0 && from.line > cm.firstLine())\\n    { from = Pos(from.line - 1, getLine(cm.doc, from.line - 1).length) }\\n  if (to.ch == getLine(cm.doc, to.line).text.length && to.line < cm.lastLine())\\n    { to = Pos(to.line + 1, 0) }\\n  if (from.line < display.viewFrom || to.line > display.viewTo - 1) { return false }\\n\\n  var fromIndex, fromLine, fromNode\\n  if (from.line == display.viewFrom || (fromIndex = findViewIndex(cm, from.line)) == 0) {\\n    fromLine = lineNo(display.view[0].line)\\n    fromNode = display.view[0].node\\n  } else {\\n    fromLine = lineNo(display.view[fromIndex].line)\\n    fromNode = display.view[fromIndex - 1].node.nextSibling\\n  }\\n  var toIndex = findViewIndex(cm, to.line)\\n  var toLine, toNode\\n  if (toIndex == display.view.length - 1) {\\n    toLine = display.viewTo - 1\\n    toNode = display.lineDiv.lastChild\\n  } else {\\n    toLine = lineNo(display.view[toIndex + 1].line) - 1\\n    toNode = display.view[toIndex + 1].node.previousSibling\\n  }\\n\\n  if (!fromNode) { return false }\\n  var newText = cm.doc.splitLines(domTextBetween(cm, fromNode, toNode, fromLine, toLine))\\n  var oldText = getBetween(cm.doc, Pos(fromLine, 0), Pos(toLine, getLine(cm.doc, toLine).text.length))\\n  while (newText.length > 1 && oldText.length > 1) {\\n    if (lst(newText) == lst(oldText)) { newText.pop(); oldText.pop(); toLine-- }\\n    else if (newText[0] == oldText[0]) { newText.shift(); oldText.shift(); fromLine++ }\\n    else { break }\\n  }\\n\\n  var cutFront = 0, cutEnd = 0\\n  var newTop = newText[0], oldTop = oldText[0], maxCutFront = Math.min(newTop.length, oldTop.length)\\n  while (cutFront < maxCutFront && newTop.charCodeAt(cutFront) == oldTop.charCodeAt(cutFront))\\n    { ++cutFront }\\n  var newBot = lst(newText), oldBot = lst(oldText)\\n  var maxCutEnd = Math.min(newBot.length - (newText.length == 1 ? cutFront : 0),\\n                           oldBot.length - (oldText.length == 1 ? cutFront : 0))\\n  while (cutEnd < maxCutEnd &&\\n         newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1))\\n    { ++cutEnd }\\n\\n  newText[newText.length - 1] = newBot.slice(0, newBot.length - cutEnd).replace(/^\\\\u200b+/, \\\"\\\")\\n  newText[0] = newText[0].slice(cutFront).replace(/\\\\u200b+$/, \\\"\\\")\\n\\n  var chFrom = Pos(fromLine, cutFront)\\n  var chTo = Pos(toLine, oldText.length ? lst(oldText).length - cutEnd : 0)\\n  if (newText.length > 1 || newText[0] || cmp(chFrom, chTo)) {\\n    replaceRange(cm.doc, newText, chFrom, chTo, \\\"+input\\\")\\n    return true\\n  }\\n};\\n\\nContentEditableInput.prototype.ensurePolled = function () {\\n  this.forceCompositionEnd()\\n};\\nContentEditableInput.prototype.reset = function () {\\n  this.forceCompositionEnd()\\n};\\nContentEditableInput.prototype.forceCompositionEnd = function () {\\n  if (!this.composing) { return }\\n  clearTimeout(this.readDOMTimeout)\\n  this.composing = null\\n  if (!this.pollContent()) { regChange(this.cm) }\\n  this.div.blur()\\n  this.div.focus()\\n};\\nContentEditableInput.prototype.readFromDOMSoon = function () {\\n    var this$1 = this;\\n\\n  if (this.readDOMTimeout != null) { return }\\n  this.readDOMTimeout = setTimeout(function () {\\n    this$1.readDOMTimeout = null\\n    if (this$1.composing) {\\n      if (this$1.composing.done) { this$1.composing = null }\\n      else { return }\\n    }\\n    if (this$1.cm.isReadOnly() || !this$1.pollContent())\\n      { runInOp(this$1.cm, function () { return regChange(this$1.cm); }) }\\n  }, 80)\\n};\\n\\nContentEditableInput.prototype.setUneditable = function (node) {\\n  node.contentEditable = \\\"false\\\"\\n};\\n\\nContentEditableInput.prototype.onKeyPress = function (e) {\\n  if (e.charCode == 0) { return }\\n  e.preventDefault()\\n  if (!this.cm.isReadOnly())\\n    { operation(this.cm, applyTextInput)(this.cm, String.fromCharCode(e.charCode == null ? e.keyCode : e.charCode), 0) }\\n};\\n\\nContentEditableInput.prototype.readOnlyChanged = function (val) {\\n  this.div.contentEditable = String(val != \\\"nocursor\\\")\\n};\\n\\nContentEditableInput.prototype.onContextMenu = function () {};\\nContentEditableInput.prototype.resetPosition = function () {};\\n\\nContentEditableInput.prototype.needsContentAttribute = true\\n\\nfunction posToDOM(cm, pos) {\\n  var view = findViewForLine(cm, pos.line)\\n  if (!view || view.hidden) { return null }\\n  var line = getLine(cm.doc, pos.line)\\n  var info = mapFromLineView(view, line, pos.line)\\n\\n  var order = getOrder(line), side = \\\"left\\\"\\n  if (order) {\\n    var partPos = getBidiPartAt(order, pos.ch)\\n    side = partPos % 2 ? \\\"right\\\" : \\\"left\\\"\\n  }\\n  var result = nodeAndOffsetInLineMap(info.map, pos.ch, side)\\n  result.offset = result.collapse == \\\"right\\\" ? result.end : result.start\\n  return result\\n}\\n\\nfunction badPos(pos, bad) { if (bad) { pos.bad = true; } return pos }\\n\\nfunction domTextBetween(cm, from, to, fromLine, toLine) {\\n  var text = \\\"\\\", closing = false, lineSep = cm.doc.lineSeparator()\\n  function recognizeMarker(id) { return function (marker) { return marker.id == id; } }\\n  function walk(node) {\\n    if (node.nodeType == 1) {\\n      var cmText = node.getAttribute(\\\"cm-text\\\")\\n      if (cmText != null) {\\n        if (cmText == \\\"\\\") { text += node.textContent.replace(/\\\\u200b/g, \\\"\\\") }\\n        else { text += cmText }\\n        return\\n      }\\n      var markerID = node.getAttribute(\\\"cm-marker\\\"), range\\n      if (markerID) {\\n        var found = cm.findMarks(Pos(fromLine, 0), Pos(toLine + 1, 0), recognizeMarker(+markerID))\\n        if (found.length && (range = found[0].find()))\\n          { text += getBetween(cm.doc, range.from, range.to).join(lineSep) }\\n        return\\n      }\\n      if (node.getAttribute(\\\"contenteditable\\\") == \\\"false\\\") { return }\\n      for (var i = 0; i < node.childNodes.length; i++)\\n        { walk(node.childNodes[i]) }\\n      if (/^(pre|div|p)$/i.test(node.nodeName))\\n        { closing = true }\\n    } else if (node.nodeType == 3) {\\n      var val = node.nodeValue\\n      if (!val) { return }\\n      if (closing) {\\n        text += lineSep\\n        closing = false\\n      }\\n      text += val\\n    }\\n  }\\n  for (;;) {\\n    walk(from)\\n    if (from == to) { break }\\n    from = from.nextSibling\\n  }\\n  return text\\n}\\n\\nfunction domToPos(cm, node, offset) {\\n  var lineNode\\n  if (node == cm.display.lineDiv) {\\n    lineNode = cm.display.lineDiv.childNodes[offset]\\n    if (!lineNode) { return badPos(cm.clipPos(Pos(cm.display.viewTo - 1)), true) }\\n    node = null; offset = 0\\n  } else {\\n    for (lineNode = node;; lineNode = lineNode.parentNode) {\\n      if (!lineNode || lineNode == cm.display.lineDiv) { return null }\\n      if (lineNode.parentNode && lineNode.parentNode == cm.display.lineDiv) { break }\\n    }\\n  }\\n  for (var i = 0; i < cm.display.view.length; i++) {\\n    var lineView = cm.display.view[i]\\n    if (lineView.node == lineNode)\\n      { return locateNodeInLineView(lineView, node, offset) }\\n  }\\n}\\n\\nfunction locateNodeInLineView(lineView, node, offset) {\\n  var wrapper = lineView.text.firstChild, bad = false\\n  if (!node || !contains(wrapper, node)) { return badPos(Pos(lineNo(lineView.line), 0), true) }\\n  if (node == wrapper) {\\n    bad = true\\n    node = wrapper.childNodes[offset]\\n    offset = 0\\n    if (!node) {\\n      var line = lineView.rest ? lst(lineView.rest) : lineView.line\\n      return badPos(Pos(lineNo(line), line.text.length), bad)\\n    }\\n  }\\n\\n  var textNode = node.nodeType == 3 ? node : null, topNode = node\\n  if (!textNode && node.childNodes.length == 1 && node.firstChild.nodeType == 3) {\\n    textNode = node.firstChild\\n    if (offset) { offset = textNode.nodeValue.length }\\n  }\\n  while (topNode.parentNode != wrapper) { topNode = topNode.parentNode }\\n  var measure = lineView.measure, maps = measure.maps\\n\\n  function find(textNode, topNode, offset) {\\n    for (var i = -1; i < (maps ? maps.length : 0); i++) {\\n      var map = i < 0 ? measure.map : maps[i]\\n      for (var j = 0; j < map.length; j += 3) {\\n        var curNode = map[j + 2]\\n        if (curNode == textNode || curNode == topNode) {\\n          var line = lineNo(i < 0 ? lineView.line : lineView.rest[i])\\n          var ch = map[j] + offset\\n          if (offset < 0 || curNode != textNode) { ch = map[j + (offset ? 1 : 0)] }\\n          return Pos(line, ch)\\n        }\\n      }\\n    }\\n  }\\n  var found = find(textNode, topNode, offset)\\n  if (found) { return badPos(found, bad) }\\n\\n  // FIXME this is all really shaky. might handle the few cases it needs to handle, but likely to cause problems\\n  for (var after = topNode.nextSibling, dist = textNode ? textNode.nodeValue.length - offset : 0; after; after = after.nextSibling) {\\n    found = find(after, after.firstChild, 0)\\n    if (found)\\n      { return badPos(Pos(found.line, found.ch - dist), bad) }\\n    else\\n      { dist += after.textContent.length }\\n  }\\n  for (var before = topNode.previousSibling, dist$1 = offset; before; before = before.previousSibling) {\\n    found = find(before, before.firstChild, -1)\\n    if (found)\\n      { return badPos(Pos(found.line, found.ch + dist$1), bad) }\\n    else\\n      { dist$1 += before.textContent.length }\\n  }\\n}\\n\\n// TEXTAREA INPUT STYLE\\n\\nvar TextareaInput = function(cm) {\\n  this.cm = cm\\n  // See input.poll and input.reset\\n  this.prevInput = \\\"\\\"\\n\\n  // Flag that indicates whether we expect input to appear real soon\\n  // now (after some event like 'keypress' or 'input') and are\\n  // polling intensively.\\n  this.pollingFast = false\\n  // Self-resetting timeout for the poller\\n  this.polling = new Delayed()\\n  // Tracks when input.reset has punted to just putting a short\\n  // string into the textarea instead of the full selection.\\n  this.inaccurateSelection = false\\n  // Used to work around IE issue with selection being forgotten when focus moves away from textarea\\n  this.hasSelection = false\\n  this.composing = null\\n};\\n\\nTextareaInput.prototype.init = function (display) {\\n    var this$1 = this;\\n\\n  var input = this, cm = this.cm\\n\\n  // Wraps and hides input textarea\\n  var div = this.wrapper = hiddenTextarea()\\n  // The semihidden textarea that is focused when the editor is\\n  // focused, and receives input.\\n  var te = this.textarea = div.firstChild\\n  display.wrapper.insertBefore(div, display.wrapper.firstChild)\\n\\n  // Needed to hide big blue blinking cursor on Mobile Safari (doesn't seem to work in iOS 8 anymore)\\n  if (ios) { te.style.width = \\\"0px\\\" }\\n\\n  on(te, \\\"input\\\", function () {\\n    if (ie && ie_version >= 9 && this$1.hasSelection) { this$1.hasSelection = null }\\n    input.poll()\\n  })\\n\\n  on(te, \\\"paste\\\", function (e) {\\n    if (signalDOMEvent(cm, e) || handlePaste(e, cm)) { return }\\n\\n    cm.state.pasteIncoming = true\\n    input.fastPoll()\\n  })\\n\\n  function prepareCopyCut(e) {\\n    if (signalDOMEvent(cm, e)) { return }\\n    if (cm.somethingSelected()) {\\n      setLastCopied({lineWise: false, text: cm.getSelections()})\\n      if (input.inaccurateSelection) {\\n        input.prevInput = \\\"\\\"\\n        input.inaccurateSelection = false\\n        te.value = lastCopied.text.join(\\\"\\\\n\\\")\\n        selectInput(te)\\n      }\\n    } else if (!cm.options.lineWiseCopyCut) {\\n      return\\n    } else {\\n      var ranges = copyableRanges(cm)\\n      setLastCopied({lineWise: true, text: ranges.text})\\n      if (e.type == \\\"cut\\\") {\\n        cm.setSelections(ranges.ranges, null, sel_dontScroll)\\n      } else {\\n        input.prevInput = \\\"\\\"\\n        te.value = ranges.text.join(\\\"\\\\n\\\")\\n        selectInput(te)\\n      }\\n    }\\n    if (e.type == \\\"cut\\\") { cm.state.cutIncoming = true }\\n  }\\n  on(te, \\\"cut\\\", prepareCopyCut)\\n  on(te, \\\"copy\\\", prepareCopyCut)\\n\\n  on(display.scroller, \\\"paste\\\", function (e) {\\n    if (eventInWidget(display, e) || signalDOMEvent(cm, e)) { return }\\n    cm.state.pasteIncoming = true\\n    input.focus()\\n  })\\n\\n  // Prevent normal selection in the editor (we handle our own)\\n  on(display.lineSpace, \\\"selectstart\\\", function (e) {\\n    if (!eventInWidget(display, e)) { e_preventDefault(e) }\\n  })\\n\\n  on(te, \\\"compositionstart\\\", function () {\\n    var start = cm.getCursor(\\\"from\\\")\\n    if (input.composing) { input.composing.range.clear() }\\n    input.composing = {\\n      start: start,\\n      range: cm.markText(start, cm.getCursor(\\\"to\\\"), {className: \\\"CodeMirror-composing\\\"})\\n    }\\n  })\\n  on(te, \\\"compositionend\\\", function () {\\n    if (input.composing) {\\n      input.poll()\\n      input.composing.range.clear()\\n      input.composing = null\\n    }\\n  })\\n};\\n\\nTextareaInput.prototype.prepareSelection = function () {\\n  // Redraw the selection and/or cursor\\n  var cm = this.cm, display = cm.display, doc = cm.doc\\n  var result = prepareSelection(cm)\\n\\n  // Move the hidden textarea near the cursor to prevent scrolling artifacts\\n  if (cm.options.moveInputWithCursor) {\\n    var headPos = cursorCoords(cm, doc.sel.primary().head, \\\"div\\\")\\n    var wrapOff = display.wrapper.getBoundingClientRect(), lineOff = display.lineDiv.getBoundingClientRect()\\n    result.teTop = Math.max(0, Math.min(display.wrapper.clientHeight - 10,\\n                                        headPos.top + lineOff.top - wrapOff.top))\\n    result.teLeft = Math.max(0, Math.min(display.wrapper.clientWidth - 10,\\n                                         headPos.left + lineOff.left - wrapOff.left))\\n  }\\n\\n  return result\\n};\\n\\nTextareaInput.prototype.showSelection = function (drawn) {\\n  var cm = this.cm, display = cm.display\\n  removeChildrenAndAdd(display.cursorDiv, drawn.cursors)\\n  removeChildrenAndAdd(display.selectionDiv, drawn.selection)\\n  if (drawn.teTop != null) {\\n    this.wrapper.style.top = drawn.teTop + \\\"px\\\"\\n    this.wrapper.style.left = drawn.teLeft + \\\"px\\\"\\n  }\\n};\\n\\n// Reset the input to correspond to the selection (or to be empty,\\n// when not typing and nothing is selected)\\nTextareaInput.prototype.reset = function (typing) {\\n  if (this.contextMenuPending) { return }\\n  var minimal, selected, cm = this.cm, doc = cm.doc\\n  if (cm.somethingSelected()) {\\n    this.prevInput = \\\"\\\"\\n    var range = doc.sel.primary()\\n    minimal = hasCopyEvent &&\\n      (range.to().line - range.from().line > 100 || (selected = cm.getSelection()).length > 1000)\\n    var content = minimal ? \\\"-\\\" : selected || cm.getSelection()\\n    this.textarea.value = content\\n    if (cm.state.focused) { selectInput(this.textarea) }\\n    if (ie && ie_version >= 9) { this.hasSelection = content }\\n  } else if (!typing) {\\n    this.prevInput = this.textarea.value = \\\"\\\"\\n    if (ie && ie_version >= 9) { this.hasSelection = null }\\n  }\\n  this.inaccurateSelection = minimal\\n};\\n\\nTextareaInput.prototype.getField = function () { return this.textarea };\\n\\nTextareaInput.prototype.supportsTouch = function () { return false };\\n\\nTextareaInput.prototype.focus = function () {\\n  if (this.cm.options.readOnly != \\\"nocursor\\\" && (!mobile || activeElt() != this.textarea)) {\\n    try { this.textarea.focus() }\\n    catch (e) {} // IE8 will throw if the textarea is display: none or not in DOM\\n  }\\n};\\n\\nTextareaInput.prototype.blur = function () { this.textarea.blur() };\\n\\nTextareaInput.prototype.resetPosition = function () {\\n  this.wrapper.style.top = this.wrapper.style.left = 0\\n};\\n\\nTextareaInput.prototype.receivedFocus = function () { this.slowPoll() };\\n\\n// Poll for input changes, using the normal rate of polling. This\\n// runs as long as the editor is focused.\\nTextareaInput.prototype.slowPoll = function () {\\n    var this$1 = this;\\n\\n  if (this.pollingFast) { return }\\n  this.polling.set(this.cm.options.pollInterval, function () {\\n    this$1.poll()\\n    if (this$1.cm.state.focused) { this$1.slowPoll() }\\n  })\\n};\\n\\n// When an event has just come in that is likely to add or change\\n// something in the input textarea, we poll faster, to ensure that\\n// the change appears on the screen quickly.\\nTextareaInput.prototype.fastPoll = function () {\\n  var missed = false, input = this\\n  input.pollingFast = true\\n  function p() {\\n    var changed = input.poll()\\n    if (!changed && !missed) {missed = true; input.polling.set(60, p)}\\n    else {input.pollingFast = false; input.slowPoll()}\\n  }\\n  input.polling.set(20, p)\\n};\\n\\n// Read input from the textarea, and update the document to match.\\n// When something is selected, it is present in the textarea, and\\n// selected (unless it is huge, in which case a placeholder is\\n// used). When nothing is selected, the cursor sits after previously\\n// seen text (can be empty), which is stored in prevInput (we must\\n// not reset the textarea when typing, because that breaks IME).\\nTextareaInput.prototype.poll = function () {\\n    var this$1 = this;\\n\\n  var cm = this.cm, input = this.textarea, prevInput = this.prevInput\\n  // Since this is called a *lot*, try to bail out as cheaply as\\n  // possible when it is clear that nothing happened. hasSelection\\n  // will be the case when there is a lot of text in the textarea,\\n  // in which case reading its value would be expensive.\\n  if (this.contextMenuPending || !cm.state.focused ||\\n      (hasSelection(input) && !prevInput && !this.composing) ||\\n      cm.isReadOnly() || cm.options.disableInput || cm.state.keySeq)\\n    { return false }\\n\\n  var text = input.value\\n  // If nothing changed, bail.\\n  if (text == prevInput && !cm.somethingSelected()) { return false }\\n  // Work around nonsensical selection resetting in IE9/10, and\\n  // inexplicable appearance of private area unicode characters on\\n  // some key combos in Mac (#2689).\\n  if (ie && ie_version >= 9 && this.hasSelection === text ||\\n      mac && /[\\\\uf700-\\\\uf7ff]/.test(text)) {\\n    cm.display.input.reset()\\n    return false\\n  }\\n\\n  if (cm.doc.sel == cm.display.selForContextMenu) {\\n    var first = text.charCodeAt(0)\\n    if (first == 0x200b && !prevInput) { prevInput = \\\"\\\\u200b\\\" }\\n    if (first == 0x21da) { this.reset(); return this.cm.execCommand(\\\"undo\\\") }\\n  }\\n  // Find the part of the input that is actually new\\n  var same = 0, l = Math.min(prevInput.length, text.length)\\n  while (same < l && prevInput.charCodeAt(same) == text.charCodeAt(same)) { ++same }\\n\\n  runInOp(cm, function () {\\n    applyTextInput(cm, text.slice(same), prevInput.length - same,\\n                   null, this$1.composing ? \\\"*compose\\\" : null)\\n\\n    // Don't leave long text in the textarea, since it makes further polling slow\\n    if (text.length > 1000 || text.indexOf(\\\"\\\\n\\\") > -1) { input.value = this$1.prevInput = \\\"\\\" }\\n    else { this$1.prevInput = text }\\n\\n    if (this$1.composing) {\\n      this$1.composing.range.clear()\\n      this$1.composing.range = cm.markText(this$1.composing.start, cm.getCursor(\\\"to\\\"),\\n                                         {className: \\\"CodeMirror-composing\\\"})\\n    }\\n  })\\n  return true\\n};\\n\\nTextareaInput.prototype.ensurePolled = function () {\\n  if (this.pollingFast && this.poll()) { this.pollingFast = false }\\n};\\n\\nTextareaInput.prototype.onKeyPress = function () {\\n  if (ie && ie_version >= 9) { this.hasSelection = null }\\n  this.fastPoll()\\n};\\n\\nTextareaInput.prototype.onContextMenu = function (e) {\\n  var input = this, cm = input.cm, display = cm.display, te = input.textarea\\n  var pos = posFromMouse(cm, e), scrollPos = display.scroller.scrollTop\\n  if (!pos || presto) { return } // Opera is difficult.\\n\\n  // Reset the current text selection only if the click is done outside of the selection\\n  // and 'resetSelectionOnContextMenu' option is true.\\n  var reset = cm.options.resetSelectionOnContextMenu\\n  if (reset && cm.doc.sel.contains(pos) == -1)\\n    { operation(cm, setSelection)(cm.doc, simpleSelection(pos), sel_dontScroll) }\\n\\n  var oldCSS = te.style.cssText, oldWrapperCSS = input.wrapper.style.cssText\\n  input.wrapper.style.cssText = \\\"position: absolute\\\"\\n  var wrapperBox = input.wrapper.getBoundingClientRect()\\n  te.style.cssText = \\\"position: absolute; width: 30px; height: 30px;\\\\n      top: \\\" + (e.clientY - wrapperBox.top - 5) + \\\"px; left: \\\" + (e.clientX - wrapperBox.left - 5) + \\\"px;\\\\n      z-index: 1000; background: \\\" + (ie ? \\\"rgba(255, 255, 255, .05)\\\" : \\\"transparent\\\") + \\\";\\\\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);\\\"\\n  var oldScrollY\\n  if (webkit) { oldScrollY = window.scrollY } // Work around Chrome issue (#2712)\\n  display.input.focus()\\n  if (webkit) { window.scrollTo(null, oldScrollY) }\\n  display.input.reset()\\n  // Adds \\\"Select all\\\" to context menu in FF\\n  if (!cm.somethingSelected()) { te.value = input.prevInput = \\\" \\\" }\\n  input.contextMenuPending = true\\n  display.selForContextMenu = cm.doc.sel\\n  clearTimeout(display.detectingSelectAll)\\n\\n  // Select-all will be greyed out if there's nothing to select, so\\n  // this adds a zero-width space so that we can later check whether\\n  // it got selected.\\n  function prepareSelectAllHack() {\\n    if (te.selectionStart != null) {\\n      var selected = cm.somethingSelected()\\n      var extval = \\\"\\\\u200b\\\" + (selected ? te.value : \\\"\\\")\\n      te.value = \\\"\\\\u21da\\\" // Used to catch context-menu undo\\n      te.value = extval\\n      input.prevInput = selected ? \\\"\\\" : \\\"\\\\u200b\\\"\\n      te.selectionStart = 1; te.selectionEnd = extval.length\\n      // Re-set this, in case some other handler touched the\\n      // selection in the meantime.\\n      display.selForContextMenu = cm.doc.sel\\n    }\\n  }\\n  function rehide() {\\n    input.contextMenuPending = false\\n    input.wrapper.style.cssText = oldWrapperCSS\\n    te.style.cssText = oldCSS\\n    if (ie && ie_version < 9) { display.scrollbars.setScrollTop(display.scroller.scrollTop = scrollPos) }\\n\\n    // Try to detect the user choosing select-all\\n    if (te.selectionStart != null) {\\n      if (!ie || (ie && ie_version < 9)) { prepareSelectAllHack() }\\n      var i = 0, poll = function () {\\n        if (display.selForContextMenu == cm.doc.sel && te.selectionStart == 0 &&\\n            te.selectionEnd > 0 && input.prevInput == \\\"\\\\u200b\\\") {\\n          operation(cm, selectAll)(cm)\\n        } else if (i++ < 10) {\\n          display.detectingSelectAll = setTimeout(poll, 500)\\n        } else {\\n          display.selForContextMenu = null\\n          display.input.reset()\\n        }\\n      }\\n      display.detectingSelectAll = setTimeout(poll, 200)\\n    }\\n  }\\n\\n  if (ie && ie_version >= 9) { prepareSelectAllHack() }\\n  if (captureRightClick) {\\n    e_stop(e)\\n    var mouseup = function () {\\n      off(window, \\\"mouseup\\\", mouseup)\\n      setTimeout(rehide, 20)\\n    }\\n    on(window, \\\"mouseup\\\", mouseup)\\n  } else {\\n    setTimeout(rehide, 50)\\n  }\\n};\\n\\nTextareaInput.prototype.readOnlyChanged = function (val) {\\n  if (!val) { this.reset() }\\n};\\n\\nTextareaInput.prototype.setUneditable = function () {};\\n\\nTextareaInput.prototype.needsContentAttribute = false\\n\\nfunction fromTextArea(textarea, options) {\\n  options = options ? copyObj(options) : {}\\n  options.value = textarea.value\\n  if (!options.tabindex && textarea.tabIndex)\\n    { options.tabindex = textarea.tabIndex }\\n  if (!options.placeholder && textarea.placeholder)\\n    { options.placeholder = textarea.placeholder }\\n  // Set autofocus to true if this textarea is focused, or if it has\\n  // autofocus and no other element is focused.\\n  if (options.autofocus == null) {\\n    var hasFocus = activeElt()\\n    options.autofocus = hasFocus == textarea ||\\n      textarea.getAttribute(\\\"autofocus\\\") != null && hasFocus == document.body\\n  }\\n\\n  function save() {textarea.value = cm.getValue()}\\n\\n  var realSubmit\\n  if (textarea.form) {\\n    on(textarea.form, \\\"submit\\\", save)\\n    // Deplorable hack to make the submit method do the right thing.\\n    if (!options.leaveSubmitMethodAlone) {\\n      var form = textarea.form\\n      realSubmit = form.submit\\n      try {\\n        var wrappedSubmit = form.submit = function () {\\n          save()\\n          form.submit = realSubmit\\n          form.submit()\\n          form.submit = wrappedSubmit\\n        }\\n      } catch(e) {}\\n    }\\n  }\\n\\n  options.finishInit = function (cm) {\\n    cm.save = save\\n    cm.getTextArea = function () { return textarea; }\\n    cm.toTextArea = function () {\\n      cm.toTextArea = isNaN // Prevent this from being ran twice\\n      save()\\n      textarea.parentNode.removeChild(cm.getWrapperElement())\\n      textarea.style.display = \\\"\\\"\\n      if (textarea.form) {\\n        off(textarea.form, \\\"submit\\\", save)\\n        if (typeof textarea.form.submit == \\\"function\\\")\\n          { textarea.form.submit = realSubmit }\\n      }\\n    }\\n  }\\n\\n  textarea.style.display = \\\"none\\\"\\n  var cm = CodeMirror(function (node) { return textarea.parentNode.insertBefore(node, textarea.nextSibling); },\\n    options)\\n  return cm\\n}\\n\\nfunction addLegacyProps(CodeMirror) {\\n  CodeMirror.off = off\\n  CodeMirror.on = on\\n  CodeMirror.wheelEventPixels = wheelEventPixels\\n  CodeMirror.Doc = Doc\\n  CodeMirror.splitLines = splitLinesAuto\\n  CodeMirror.countColumn = countColumn\\n  CodeMirror.findColumn = findColumn\\n  CodeMirror.isWordChar = isWordCharBasic\\n  CodeMirror.Pass = Pass\\n  CodeMirror.signal = signal\\n  CodeMirror.Line = Line\\n  CodeMirror.changeEnd = changeEnd\\n  CodeMirror.scrollbarModel = scrollbarModel\\n  CodeMirror.Pos = Pos\\n  CodeMirror.cmpPos = cmp\\n  CodeMirror.modes = modes\\n  CodeMirror.mimeModes = mimeModes\\n  CodeMirror.resolveMode = resolveMode\\n  CodeMirror.getMode = getMode\\n  CodeMirror.modeExtensions = modeExtensions\\n  CodeMirror.extendMode = extendMode\\n  CodeMirror.copyState = copyState\\n  CodeMirror.startState = startState\\n  CodeMirror.innerMode = innerMode\\n  CodeMirror.commands = commands\\n  CodeMirror.keyMap = keyMap\\n  CodeMirror.keyName = keyName\\n  CodeMirror.isModifierKey = isModifierKey\\n  CodeMirror.lookupKey = lookupKey\\n  CodeMirror.normalizeKeyMap = normalizeKeyMap\\n  CodeMirror.StringStream = StringStream\\n  CodeMirror.SharedTextMarker = SharedTextMarker\\n  CodeMirror.TextMarker = TextMarker\\n  CodeMirror.LineWidget = LineWidget\\n  CodeMirror.e_preventDefault = e_preventDefault\\n  CodeMirror.e_stopPropagation = e_stopPropagation\\n  CodeMirror.e_stop = e_stop\\n  CodeMirror.addClass = addClass\\n  CodeMirror.contains = contains\\n  CodeMirror.rmClass = rmClass\\n  CodeMirror.keyNames = keyNames\\n}\\n\\n// EDITOR CONSTRUCTOR\\n\\ndefineOptions(CodeMirror)\\n\\naddEditorMethods(CodeMirror)\\n\\n// Set up methods on CodeMirror's prototype to redirect to the editor's document.\\nvar dontDelegate = \\\"iter insert remove copy getEditor constructor\\\".split(\\\" \\\")\\nfor (var prop in Doc.prototype) { if (Doc.prototype.hasOwnProperty(prop) && indexOf(dontDelegate, prop) < 0)\\n  { CodeMirror.prototype[prop] = (function(method) {\\n    return function() {return method.apply(this.doc, arguments)}\\n  })(Doc.prototype[prop]) } }\\n\\neventMixin(Doc)\\n\\n// INPUT HANDLING\\n\\nCodeMirror.inputStyles = {\\\"textarea\\\": TextareaInput, \\\"contenteditable\\\": ContentEditableInput}\\n\\n// MODE DEFINITION AND QUERYING\\n\\n// Extra arguments are stored as the mode's dependencies, which is\\n// used by (legacy) mechanisms like loadmode.js to automatically\\n// load a mode. (Preferred mechanism is the require/define calls.)\\nCodeMirror.defineMode = function(name/*, mode, …*/) {\\n  if (!CodeMirror.defaults.mode && name != \\\"null\\\") { CodeMirror.defaults.mode = name }\\n  defineMode.apply(this, arguments)\\n}\\n\\nCodeMirror.defineMIME = defineMIME\\n\\n// Minimal default mode.\\nCodeMirror.defineMode(\\\"null\\\", function () { return ({token: function (stream) { return stream.skipToEnd(); }}); })\\nCodeMirror.defineMIME(\\\"text/plain\\\", \\\"null\\\")\\n\\n// EXTENSIONS\\n\\nCodeMirror.defineExtension = function (name, func) {\\n  CodeMirror.prototype[name] = func\\n}\\nCodeMirror.defineDocExtension = function (name, func) {\\n  Doc.prototype[name] = func\\n}\\n\\nCodeMirror.fromTextArea = fromTextArea\\n\\naddLegacyProps(CodeMirror)\\n\\nCodeMirror.version = \\\"5.24.2\\\"\\n\\nreturn CodeMirror;\\n\\n})));\"//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL34vY29kZW1pcnJvci9saWIvY29kZW1pcnJvci5qcz9iMGIxIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gXCIvLyBDb2RlTWlycm9yLCBjb3B5cmlnaHQgKGMpIGJ5IE1hcmlqbiBIYXZlcmJla2UgYW5kIG90aGVyc1xcbi8vIERpc3RyaWJ1dGVkIHVuZGVyIGFuIE1JVCBsaWNlbnNlOiBodHRwOi8vY29kZW1pcnJvci5uZXQvTElDRU5TRVxcblxcbi8vIFRoaXMgaXMgQ29kZU1pcnJvciAoaHR0cDovL2NvZGVtaXJyb3IubmV0KSwgYSBjb2RlIGVkaXRvclxcbi8vIGltcGxlbWVudGVkIGluIEphdmFTY3JpcHQgb24gdG9wIG9mIHRoZSBicm93c2VyJ3MgRE9NLlxcbi8vXFxuLy8gWW91IGNhbiBmaW5kIHNvbWUgdGVjaG5pY2FsIGJhY2tncm91bmQgZm9yIHNvbWUgb2YgdGhlIGNvZGUgYmVsb3dcXG4vLyBhdCBodHRwOi8vbWFyaWpuaGF2ZXJiZWtlLm5sL2Jsb2cvI2NtLWludGVybmFscyAuXFxuXFxuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcXG4gIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpIDpcXG4gIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShmYWN0b3J5KSA6XFxuICAoZ2xvYmFsLkNvZGVNaXJyb3IgPSBmYWN0b3J5KCkpO1xcbn0odGhpcywgKGZ1bmN0aW9uICgpIHsgJ3VzZSBzdHJpY3QnO1xcblxcbi8vIEtsdWRnZXMgZm9yIGJ1Z3MgYW5kIGJlaGF2aW9yIGRpZmZlcmVuY2VzIHRoYXQgY2FuJ3QgYmUgZmVhdHVyZVxcbi8vIGRldGVjdGVkIGFyZSBlbmFibGVkIGJhc2VkIG9uIHVzZXJBZ2VudCBldGMgc25pZmZpbmcuXFxudmFyIHVzZXJBZ2VudCA9IG5hdmlnYXRvci51c2VyQWdlbnRcXG52YXIgcGxhdGZvcm0gPSBuYXZpZ2F0b3IucGxhdGZvcm1cXG5cXG52YXIgZ2Vja28gPSAvZ2Vja29cXFxcL1xcXFxkL2kudGVzdCh1c2VyQWdlbnQpXFxudmFyIGllX3VwdG8xMCA9IC9NU0lFIFxcXFxkLy50ZXN0KHVzZXJBZ2VudClcXG52YXIgaWVfMTF1cCA9IC9UcmlkZW50XFxcXC8oPzpbNy05XXxcXFxcZHsyLH0pXFxcXC4uKnJ2OihcXFxcZCspLy5leGVjKHVzZXJBZ2VudClcXG52YXIgZWRnZSA9IC9FZGdlXFxcXC8oXFxcXGQrKS8uZXhlYyh1c2VyQWdlbnQpXFxudmFyIGllID0gaWVfdXB0bzEwIHx8IGllXzExdXAgfHwgZWRnZVxcbnZhciBpZV92ZXJzaW9uID0gaWUgJiYgKGllX3VwdG8xMCA/IGRvY3VtZW50LmRvY3VtZW50TW9kZSB8fCA2IDogKyhlZGdlIHx8IGllXzExdXApWzFdKVxcbnZhciB3ZWJraXQgPSAhZWRnZSAmJiAvV2ViS2l0XFxcXC8vLnRlc3QodXNlckFnZW50KVxcbnZhciBxdHdlYmtpdCA9IHdlYmtpdCAmJiAvUXRcXFxcL1xcXFxkK1xcXFwuXFxcXGQrLy50ZXN0KHVzZXJBZ2VudClcXG52YXIgY2hyb21lID0gIWVkZ2UgJiYgL0Nocm9tZVxcXFwvLy50ZXN0KHVzZXJBZ2VudClcXG52YXIgcHJlc3RvID0gL09wZXJhXFxcXC8vLnRlc3QodXNlckFnZW50KVxcbnZhciBzYWZhcmkgPSAvQXBwbGUgQ29tcHV0ZXIvLnRlc3QobmF2aWdhdG9yLnZlbmRvcilcXG52YXIgbWFjX2dlTW91bnRhaW5MaW9uID0gL01hYyBPUyBYIDFcXFxcZFxcXFxEKFs4LTldfFxcXFxkXFxcXGQpXFxcXEQvLnRlc3QodXNlckFnZW50KVxcbnZhciBwaGFudG9tID0gL1BoYW50b21KUy8udGVzdCh1c2VyQWdlbnQpXFxuXFxudmFyIGlvcyA9ICFlZGdlICYmIC9BcHBsZVdlYktpdC8udGVzdCh1c2VyQWdlbnQpICYmIC9Nb2JpbGVcXFxcL1xcXFx3Ky8udGVzdCh1c2VyQWdlbnQpXFxuLy8gVGhpcyBpcyB3b2VmdWxseSBpbmNvbXBsZXRlLiBTdWdnZXN0aW9ucyBmb3IgYWx0ZXJuYXRpdmUgbWV0aG9kcyB3ZWxjb21lLlxcbnZhciBtb2JpbGUgPSBpb3MgfHwgL0FuZHJvaWR8d2ViT1N8QmxhY2tCZXJyeXxPcGVyYSBNaW5pfE9wZXJhIE1vYml8SUVNb2JpbGUvaS50ZXN0KHVzZXJBZ2VudClcXG52YXIgbWFjID0gaW9zIHx8IC9NYWMvLnRlc3QocGxhdGZvcm0pXFxudmFyIGNocm9tZU9TID0gL1xcXFxiQ3JPU1xcXFxiLy50ZXN0KHVzZXJBZ2VudClcXG52YXIgd2luZG93cyA9IC93aW4vaS50ZXN0KHBsYXRmb3JtKVxcblxcbnZhciBwcmVzdG9fdmVyc2lvbiA9IHByZXN0byAmJiB1c2VyQWdlbnQubWF0Y2goL1ZlcnNpb25cXFxcLyhcXFxcZCpcXFxcLlxcXFxkKikvKVxcbmlmIChwcmVzdG9fdmVyc2lvbikgeyBwcmVzdG9fdmVyc2lvbiA9IE51bWJlcihwcmVzdG9fdmVyc2lvblsxXSkgfVxcbmlmIChwcmVzdG9fdmVyc2lvbiAmJiBwcmVzdG9fdmVyc2lvbiA+PSAxNSkgeyBwcmVzdG8gPSBmYWxzZTsgd2Via2l0ID0gdHJ1ZSB9XFxuLy8gU29tZSBicm93c2VycyB1c2UgdGhlIHdyb25nIGV2ZW50IHByb3BlcnRpZXMgdG8gc2lnbmFsIGNtZC9jdHJsIG9uIE9TIFhcXG52YXIgZmxpcEN0cmxDbWQgPSBtYWMgJiYgKHF0d2Via2l0IHx8IHByZXN0byAmJiAocHJlc3RvX3ZlcnNpb24gPT0gbnVsbCB8fCBwcmVzdG9fdmVyc2lvbiA8IDEyLjExKSlcXG52YXIgY2FwdHVyZVJpZ2h0Q2xpY2sgPSBnZWNrbyB8fCAoaWUgJiYgaWVfdmVyc2lvbiA+PSA5KVxcblxcbmZ1bmN0aW9uIGNsYXNzVGVzdChjbHMpIHsgcmV0dXJuIG5ldyBSZWdFeHAoXFxcIihefFxcXFxcXFxccylcXFwiICsgY2xzICsgXFxcIig/OiR8XFxcXFxcXFxzKVxcXFxcXFxccypcXFwiKSB9XFxuXFxudmFyIHJtQ2xhc3MgPSBmdW5jdGlvbihub2RlLCBjbHMpIHtcXG4gIHZhciBjdXJyZW50ID0gbm9kZS5jbGFzc05hbWVcXG4gIHZhciBtYXRjaCA9IGNsYXNzVGVzdChjbHMpLmV4ZWMoY3VycmVudClcXG4gIGlmIChtYXRjaCkge1xcbiAgICB2YXIgYWZ0ZXIgPSBjdXJyZW50LnNsaWNlKG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoKVxcbiAgICBub2RlLmNsYXNzTmFtZSA9IGN1cnJlbnQuc2xpY2UoMCwgbWF0Y2guaW5kZXgpICsgKGFmdGVyID8gbWF0Y2hbMV0gKyBhZnRlciA6IFxcXCJcXFwiKVxcbiAgfVxcbn1cXG5cXG5mdW5jdGlvbiByZW1vdmVDaGlsZHJlbihlKSB7XFxuICBmb3IgKHZhciBjb3VudCA9IGUuY2hpbGROb2Rlcy5sZW5ndGg7IGNvdW50ID4gMDsgLS1jb3VudClcXG4gICAgeyBlLnJlbW92ZUNoaWxkKGUuZmlyc3RDaGlsZCkgfVxcbiAgcmV0dXJuIGVcXG59XFxuXFxuZnVuY3Rpb24gcmVtb3ZlQ2hpbGRyZW5BbmRBZGQocGFyZW50LCBlKSB7XFxuICByZXR1cm4gcmVtb3ZlQ2hpbGRyZW4ocGFyZW50KS5hcHBlbmRDaGlsZChlKVxcbn1cXG5cXG5mdW5jdGlvbiBlbHQodGFnLCBjb250ZW50LCBjbGFzc05hbWUsIHN0eWxlKSB7XFxuICB2YXIgZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKVxcbiAgaWYgKGNsYXNzTmFtZSkgeyBlLmNsYXNzTmFtZSA9IGNsYXNzTmFtZSB9XFxuICBpZiAoc3R5bGUpIHsgZS5zdHlsZS5jc3NUZXh0ID0gc3R5bGUgfVxcbiAgaWYgKHR5cGVvZiBjb250ZW50ID09IFxcXCJzdHJpbmdcXFwiKSB7IGUuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY29udGVudCkpIH1cXG4gIGVsc2UgaWYgKGNvbnRlbnQpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBjb250ZW50Lmxlbmd0aDsgKytpKSB7IGUuYXBwZW5kQ2hpbGQoY29udGVudFtpXSkgfSB9XFxuICByZXR1cm4gZVxcbn1cXG5cXG52YXIgcmFuZ2VcXG5pZiAoZG9jdW1lbnQuY3JlYXRlUmFuZ2UpIHsgcmFuZ2UgPSBmdW5jdGlvbihub2RlLCBzdGFydCwgZW5kLCBlbmROb2RlKSB7XFxuICB2YXIgciA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKClcXG4gIHIuc2V0RW5kKGVuZE5vZGUgfHwgbm9kZSwgZW5kKVxcbiAgci5zZXRTdGFydChub2RlLCBzdGFydClcXG4gIHJldHVybiByXFxufSB9XFxuZWxzZSB7IHJhbmdlID0gZnVuY3Rpb24obm9kZSwgc3RhcnQsIGVuZCkge1xcbiAgdmFyIHIgPSBkb2N1bWVudC5ib2R5LmNyZWF0ZVRleHRSYW5nZSgpXFxuICB0cnkgeyByLm1vdmVUb0VsZW1lbnRUZXh0KG5vZGUucGFyZW50Tm9kZSkgfVxcbiAgY2F0Y2goZSkgeyByZXR1cm4gciB9XFxuICByLmNvbGxhcHNlKHRydWUpXFxuICByLm1vdmVFbmQoXFxcImNoYXJhY3RlclxcXCIsIGVuZClcXG4gIHIubW92ZVN0YXJ0KFxcXCJjaGFyYWN0ZXJcXFwiLCBzdGFydClcXG4gIHJldHVybiByXFxufSB9XFxuXFxuZnVuY3Rpb24gY29udGFpbnMocGFyZW50LCBjaGlsZCkge1xcbiAgaWYgKGNoaWxkLm5vZGVUeXBlID09IDMpIC8vIEFuZHJvaWQgYnJvd3NlciBhbHdheXMgcmV0dXJucyBmYWxzZSB3aGVuIGNoaWxkIGlzIGEgdGV4dG5vZGVcXG4gICAgeyBjaGlsZCA9IGNoaWxkLnBhcmVudE5vZGUgfVxcbiAgaWYgKHBhcmVudC5jb250YWlucylcXG4gICAgeyByZXR1cm4gcGFyZW50LmNvbnRhaW5zKGNoaWxkKSB9XFxuICBkbyB7XFxuICAgIGlmIChjaGlsZC5ub2RlVHlwZSA9PSAxMSkgeyBjaGlsZCA9IGNoaWxkLmhvc3QgfVxcbiAgICBpZiAoY2hpbGQgPT0gcGFyZW50KSB7IHJldHVybiB0cnVlIH1cXG4gIH0gd2hpbGUgKGNoaWxkID0gY2hpbGQucGFyZW50Tm9kZSlcXG59XFxuXFxuZnVuY3Rpb24gYWN0aXZlRWx0KCkge1xcbiAgLy8gSUUgYW5kIEVkZ2UgbWF5IHRocm93IGFuIFxcXCJVbnNwZWNpZmllZCBFcnJvclxcXCIgd2hlbiBhY2Nlc3NpbmcgZG9jdW1lbnQuYWN0aXZlRWxlbWVudC5cXG4gIC8vIElFIDwgMTAgd2lsbCB0aHJvdyB3aGVuIGFjY2Vzc2VkIHdoaWxlIHRoZSBwYWdlIGlzIGxvYWRpbmcgb3IgaW4gYW4gaWZyYW1lLlxcbiAgLy8gSUUgPiA5IGFuZCBFZGdlIHdpbGwgdGhyb3cgd2hlbiBhY2Nlc3NlZCBpbiBhbiBpZnJhbWUgaWYgZG9jdW1lbnQuYm9keSBpcyB1bmF2YWlsYWJsZS5cXG4gIHZhciBhY3RpdmVFbGVtZW50XFxuICB0cnkge1xcbiAgICBhY3RpdmVFbGVtZW50ID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudFxcbiAgfSBjYXRjaChlKSB7XFxuICAgIGFjdGl2ZUVsZW1lbnQgPSBkb2N1bWVudC5ib2R5IHx8IG51bGxcXG4gIH1cXG4gIHdoaWxlIChhY3RpdmVFbGVtZW50ICYmIGFjdGl2ZUVsZW1lbnQucm9vdCAmJiBhY3RpdmVFbGVtZW50LnJvb3QuYWN0aXZlRWxlbWVudClcXG4gICAgeyBhY3RpdmVFbGVtZW50ID0gYWN0aXZlRWxlbWVudC5yb290LmFjdGl2ZUVsZW1lbnQgfVxcbiAgcmV0dXJuIGFjdGl2ZUVsZW1lbnRcXG59XFxuXFxuZnVuY3Rpb24gYWRkQ2xhc3Mobm9kZSwgY2xzKSB7XFxuICB2YXIgY3VycmVudCA9IG5vZGUuY2xhc3NOYW1lXFxuICBpZiAoIWNsYXNzVGVzdChjbHMpLnRlc3QoY3VycmVudCkpIHsgbm9kZS5jbGFzc05hbWUgKz0gKGN1cnJlbnQgPyBcXFwiIFxcXCIgOiBcXFwiXFxcIikgKyBjbHMgfVxcbn1cXG5mdW5jdGlvbiBqb2luQ2xhc3NlcyhhLCBiKSB7XFxuICB2YXIgYXMgPSBhLnNwbGl0KFxcXCIgXFxcIilcXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXMubGVuZ3RoOyBpKyspXFxuICAgIHsgaWYgKGFzW2ldICYmICFjbGFzc1Rlc3QoYXNbaV0pLnRlc3QoYikpIHsgYiArPSBcXFwiIFxcXCIgKyBhc1tpXSB9IH1cXG4gIHJldHVybiBiXFxufVxcblxcbnZhciBzZWxlY3RJbnB1dCA9IGZ1bmN0aW9uKG5vZGUpIHsgbm9kZS5zZWxlY3QoKSB9XFxuaWYgKGlvcykgLy8gTW9iaWxlIFNhZmFyaSBhcHBhcmVudGx5IGhhcyBhIGJ1ZyB3aGVyZSBzZWxlY3QoKSBpcyBicm9rZW4uXFxuICB7IHNlbGVjdElucHV0ID0gZnVuY3Rpb24obm9kZSkgeyBub2RlLnNlbGVjdGlvblN0YXJ0ID0gMDsgbm9kZS5zZWxlY3Rpb25FbmQgPSBub2RlLnZhbHVlLmxlbmd0aCB9IH1cXG5lbHNlIGlmIChpZSkgLy8gU3VwcHJlc3MgbXlzdGVyaW91cyBJRTEwIGVycm9yc1xcbiAgeyBzZWxlY3RJbnB1dCA9IGZ1bmN0aW9uKG5vZGUpIHsgdHJ5IHsgbm9kZS5zZWxlY3QoKSB9IGNhdGNoKF9lKSB7fSB9IH1cXG5cXG5mdW5jdGlvbiBiaW5kKGYpIHtcXG4gIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKVxcbiAgcmV0dXJuIGZ1bmN0aW9uKCl7cmV0dXJuIGYuYXBwbHkobnVsbCwgYXJncyl9XFxufVxcblxcbmZ1bmN0aW9uIGNvcHlPYmoob2JqLCB0YXJnZXQsIG92ZXJ3cml0ZSkge1xcbiAgaWYgKCF0YXJnZXQpIHsgdGFyZ2V0ID0ge30gfVxcbiAgZm9yICh2YXIgcHJvcCBpbiBvYmopXFxuICAgIHsgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShwcm9wKSAmJiAob3ZlcndyaXRlICE9PSBmYWxzZSB8fCAhdGFyZ2V0Lmhhc093blByb3BlcnR5KHByb3ApKSlcXG4gICAgICB7IHRhcmdldFtwcm9wXSA9IG9ialtwcm9wXSB9IH1cXG4gIHJldHVybiB0YXJnZXRcXG59XFxuXFxuLy8gQ291bnRzIHRoZSBjb2x1bW4gb2Zmc2V0IGluIGEgc3RyaW5nLCB0YWtpbmcgdGFicyBpbnRvIGFjY291bnQuXFxuLy8gVXNlZCBtb3N0bHkgdG8gZmluZCBpbmRlbnRhdGlvbi5cXG5mdW5jdGlvbiBjb3VudENvbHVtbihzdHJpbmcsIGVuZCwgdGFiU2l6ZSwgc3RhcnRJbmRleCwgc3RhcnRWYWx1ZSkge1xcbiAgaWYgKGVuZCA9PSBudWxsKSB7XFxuICAgIGVuZCA9IHN0cmluZy5zZWFyY2goL1teXFxcXHNcXFxcdTAwYTBdLylcXG4gICAgaWYgKGVuZCA9PSAtMSkgeyBlbmQgPSBzdHJpbmcubGVuZ3RoIH1cXG4gIH1cXG4gIGZvciAodmFyIGkgPSBzdGFydEluZGV4IHx8IDAsIG4gPSBzdGFydFZhbHVlIHx8IDA7Oykge1xcbiAgICB2YXIgbmV4dFRhYiA9IHN0cmluZy5pbmRleE9mKFxcXCJcXFxcdFxcXCIsIGkpXFxuICAgIGlmIChuZXh0VGFiIDwgMCB8fCBuZXh0VGFiID49IGVuZClcXG4gICAgICB7IHJldHVybiBuICsgKGVuZCAtIGkpIH1cXG4gICAgbiArPSBuZXh0VGFiIC0gaVxcbiAgICBuICs9IHRhYlNpemUgLSAobiAlIHRhYlNpemUpXFxuICAgIGkgPSBuZXh0VGFiICsgMVxcbiAgfVxcbn1cXG5cXG52YXIgRGVsYXllZCA9IGZ1bmN0aW9uKCkge3RoaXMuaWQgPSBudWxsfTtcXG5EZWxheWVkLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAobXMsIGYpIHtcXG4gIGNsZWFyVGltZW91dCh0aGlzLmlkKVxcbiAgdGhpcy5pZCA9IHNldFRpbWVvdXQoZiwgbXMpXFxufTtcXG5cXG5mdW5jdGlvbiBpbmRleE9mKGFycmF5LCBlbHQpIHtcXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyArK2kpXFxuICAgIHsgaWYgKGFycmF5W2ldID09IGVsdCkgeyByZXR1cm4gaSB9IH1cXG4gIHJldHVybiAtMVxcbn1cXG5cXG4vLyBOdW1iZXIgb2YgcGl4ZWxzIGFkZGVkIHRvIHNjcm9sbGVyIGFuZCBzaXplciB0byBoaWRlIHNjcm9sbGJhclxcbnZhciBzY3JvbGxlckdhcCA9IDMwXFxuXFxuLy8gUmV0dXJuZWQgb3IgdGhyb3duIGJ5IHZhcmlvdXMgcHJvdG9jb2xzIHRvIHNpZ25hbCAnSSdtIG5vdFxcbi8vIGhhbmRsaW5nIHRoaXMnLlxcbnZhciBQYXNzID0ge3RvU3RyaW5nOiBmdW5jdGlvbigpe3JldHVybiBcXFwiQ29kZU1pcnJvci5QYXNzXFxcIn19XFxuXFxuLy8gUmV1c2VkIG9wdGlvbiBvYmplY3RzIGZvciBzZXRTZWxlY3Rpb24gJiBmcmllbmRzXFxudmFyIHNlbF9kb250U2Nyb2xsID0ge3Njcm9sbDogZmFsc2V9O1xcbnZhciBzZWxfbW91c2UgPSB7b3JpZ2luOiBcXFwiKm1vdXNlXFxcIn07XFxudmFyIHNlbF9tb3ZlID0ge29yaWdpbjogXFxcIittb3ZlXFxcIn07XFxuLy8gVGhlIGludmVyc2Ugb2YgY291bnRDb2x1bW4gLS0gZmluZCB0aGUgb2Zmc2V0IHRoYXQgY29ycmVzcG9uZHMgdG9cXG4vLyBhIHBhcnRpY3VsYXIgY29sdW1uLlxcbmZ1bmN0aW9uIGZpbmRDb2x1bW4oc3RyaW5nLCBnb2FsLCB0YWJTaXplKSB7XFxuICBmb3IgKHZhciBwb3MgPSAwLCBjb2wgPSAwOzspIHtcXG4gICAgdmFyIG5leHRUYWIgPSBzdHJpbmcuaW5kZXhPZihcXFwiXFxcXHRcXFwiLCBwb3MpXFxuICAgIGlmIChuZXh0VGFiID09IC0xKSB7IG5leHRUYWIgPSBzdHJpbmcubGVuZ3RoIH1cXG4gICAgdmFyIHNraXBwZWQgPSBuZXh0VGFiIC0gcG9zXFxuICAgIGlmIChuZXh0VGFiID09IHN0cmluZy5sZW5ndGggfHwgY29sICsgc2tpcHBlZCA+PSBnb2FsKVxcbiAgICAgIHsgcmV0dXJuIHBvcyArIE1hdGgubWluKHNraXBwZWQsIGdvYWwgLSBjb2wpIH1cXG4gICAgY29sICs9IG5leHRUYWIgLSBwb3NcXG4gICAgY29sICs9IHRhYlNpemUgLSAoY29sICUgdGFiU2l6ZSlcXG4gICAgcG9zID0gbmV4dFRhYiArIDFcXG4gICAgaWYgKGNvbCA+PSBnb2FsKSB7IHJldHVybiBwb3MgfVxcbiAgfVxcbn1cXG5cXG52YXIgc3BhY2VTdHJzID0gW1xcXCJcXFwiXVxcbmZ1bmN0aW9uIHNwYWNlU3RyKG4pIHtcXG4gIHdoaWxlIChzcGFjZVN0cnMubGVuZ3RoIDw9IG4pXFxuICAgIHsgc3BhY2VTdHJzLnB1c2gobHN0KHNwYWNlU3RycykgKyBcXFwiIFxcXCIpIH1cXG4gIHJldHVybiBzcGFjZVN0cnNbbl1cXG59XFxuXFxuZnVuY3Rpb24gbHN0KGFycikgeyByZXR1cm4gYXJyW2Fyci5sZW5ndGgtMV0gfVxcblxcbmZ1bmN0aW9uIG1hcChhcnJheSwgZikge1xcbiAgdmFyIG91dCA9IFtdXFxuICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7IG91dFtpXSA9IGYoYXJyYXlbaV0sIGkpIH1cXG4gIHJldHVybiBvdXRcXG59XFxuXFxuZnVuY3Rpb24gaW5zZXJ0U29ydGVkKGFycmF5LCB2YWx1ZSwgc2NvcmUpIHtcXG4gIHZhciBwb3MgPSAwLCBwcmlvcml0eSA9IHNjb3JlKHZhbHVlKVxcbiAgd2hpbGUgKHBvcyA8IGFycmF5Lmxlbmd0aCAmJiBzY29yZShhcnJheVtwb3NdKSA8PSBwcmlvcml0eSkgeyBwb3MrKyB9XFxuICBhcnJheS5zcGxpY2UocG9zLCAwLCB2YWx1ZSlcXG59XFxuXFxuZnVuY3Rpb24gbm90aGluZygpIHt9XFxuXFxuZnVuY3Rpb24gY3JlYXRlT2JqKGJhc2UsIHByb3BzKSB7XFxuICB2YXIgaW5zdFxcbiAgaWYgKE9iamVjdC5jcmVhdGUpIHtcXG4gICAgaW5zdCA9IE9iamVjdC5jcmVhdGUoYmFzZSlcXG4gIH0gZWxzZSB7XFxuICAgIG5vdGhpbmcucHJvdG90eXBlID0gYmFzZVxcbiAgICBpbnN0ID0gbmV3IG5vdGhpbmcoKVxcbiAgfVxcbiAgaWYgKHByb3BzKSB7IGNvcHlPYmoocHJvcHMsIGluc3QpIH1cXG4gIHJldHVybiBpbnN0XFxufVxcblxcbnZhciBub25BU0NJSVNpbmdsZUNhc2VXb3JkQ2hhciA9IC9bXFxcXHUwMGRmXFxcXHUwNTg3XFxcXHUwNTkwLVxcXFx1MDVmNFxcXFx1MDYwMC1cXFxcdTA2ZmZcXFxcdTMwNDAtXFxcXHUzMDlmXFxcXHUzMGEwLVxcXFx1MzBmZlxcXFx1MzQwMC1cXFxcdTRkYjVcXFxcdTRlMDAtXFxcXHU5ZmNjXFxcXHVhYzAwLVxcXFx1ZDdhZl0vXFxuZnVuY3Rpb24gaXNXb3JkQ2hhckJhc2ljKGNoKSB7XFxuICByZXR1cm4gL1xcXFx3Ly50ZXN0KGNoKSB8fCBjaCA+IFxcXCJcXFxceDgwXFxcIiAmJlxcbiAgICAoY2gudG9VcHBlckNhc2UoKSAhPSBjaC50b0xvd2VyQ2FzZSgpIHx8IG5vbkFTQ0lJU2luZ2xlQ2FzZVdvcmRDaGFyLnRlc3QoY2gpKVxcbn1cXG5mdW5jdGlvbiBpc1dvcmRDaGFyKGNoLCBoZWxwZXIpIHtcXG4gIGlmICghaGVscGVyKSB7IHJldHVybiBpc1dvcmRDaGFyQmFzaWMoY2gpIH1cXG4gIGlmIChoZWxwZXIuc291cmNlLmluZGV4T2YoXFxcIlxcXFxcXFxcd1xcXCIpID4gLTEgJiYgaXNXb3JkQ2hhckJhc2ljKGNoKSkgeyByZXR1cm4gdHJ1ZSB9XFxuICByZXR1cm4gaGVscGVyLnRlc3QoY2gpXFxufVxcblxcbmZ1bmN0aW9uIGlzRW1wdHkob2JqKSB7XFxuICBmb3IgKHZhciBuIGluIG9iaikgeyBpZiAob2JqLmhhc093blByb3BlcnR5KG4pICYmIG9ialtuXSkgeyByZXR1cm4gZmFsc2UgfSB9XFxuICByZXR1cm4gdHJ1ZVxcbn1cXG5cXG4vLyBFeHRlbmRpbmcgdW5pY29kZSBjaGFyYWN0ZXJzLiBBIHNlcmllcyBvZiBhIG5vbi1leHRlbmRpbmcgY2hhciArXFxuLy8gYW55IG51bWJlciBvZiBleHRlbmRpbmcgY2hhcnMgaXMgdHJlYXRlZCBhcyBhIHNpbmdsZSB1bml0IGFzIGZhclxcbi8vIGFzIGVkaXRpbmcgYW5kIG1lYXN1cmluZyBpcyBjb25jZXJuZWQuIFRoaXMgaXMgbm90IGZ1bGx5IGNvcnJlY3QsXFxuLy8gc2luY2Ugc29tZSBzY3JpcHRzL2ZvbnRzL2Jyb3dzZXJzIGFsc28gdHJlYXQgb3RoZXIgY29uZmlndXJhdGlvbnNcXG4vLyBvZiBjb2RlIHBvaW50cyBhcyBhIGdyb3VwLlxcbnZhciBleHRlbmRpbmdDaGFycyA9IC9bXFxcXHUwMzAwLVxcXFx1MDM2ZlxcXFx1MDQ4My1cXFxcdTA0ODlcXFxcdTA1OTEtXFxcXHUwNWJkXFxcXHUwNWJmXFxcXHUwNWMxXFxcXHUwNWMyXFxcXHUwNWM0XFxcXHUwNWM1XFxcXHUwNWM3XFxcXHUwNjEwLVxcXFx1MDYxYVxcXFx1MDY0Yi1cXFxcdTA2NWVcXFxcdTA2NzBcXFxcdTA2ZDYtXFxcXHUwNmRjXFxcXHUwNmRlLVxcXFx1MDZlNFxcXFx1MDZlN1xcXFx1MDZlOFxcXFx1MDZlYS1cXFxcdTA2ZWRcXFxcdTA3MTFcXFxcdTA3MzAtXFxcXHUwNzRhXFxcXHUwN2E2LVxcXFx1MDdiMFxcXFx1MDdlYi1cXFxcdTA3ZjNcXFxcdTA4MTYtXFxcXHUwODE5XFxcXHUwODFiLVxcXFx1MDgyM1xcXFx1MDgyNS1cXFxcdTA4MjdcXFxcdTA4MjktXFxcXHUwODJkXFxcXHUwOTAwLVxcXFx1MDkwMlxcXFx1MDkzY1xcXFx1MDk0MS1cXFxcdTA5NDhcXFxcdTA5NGRcXFxcdTA5NTEtXFxcXHUwOTU1XFxcXHUwOTYyXFxcXHUwOTYzXFxcXHUwOTgxXFxcXHUwOWJjXFxcXHUwOWJlXFxcXHUwOWMxLVxcXFx1MDljNFxcXFx1MDljZFxcXFx1MDlkN1xcXFx1MDllMlxcXFx1MDllM1xcXFx1MGEwMVxcXFx1MGEwMlxcXFx1MGEzY1xcXFx1MGE0MVxcXFx1MGE0MlxcXFx1MGE0N1xcXFx1MGE0OFxcXFx1MGE0Yi1cXFxcdTBhNGRcXFxcdTBhNTFcXFxcdTBhNzBcXFxcdTBhNzFcXFxcdTBhNzVcXFxcdTBhODFcXFxcdTBhODJcXFxcdTBhYmNcXFxcdTBhYzEtXFxcXHUwYWM1XFxcXHUwYWM3XFxcXHUwYWM4XFxcXHUwYWNkXFxcXHUwYWUyXFxcXHUwYWUzXFxcXHUwYjAxXFxcXHUwYjNjXFxcXHUwYjNlXFxcXHUwYjNmXFxcXHUwYjQxLVxcXFx1MGI0NFxcXFx1MGI0ZFxcXFx1MGI1NlxcXFx1MGI1N1xcXFx1MGI2MlxcXFx1MGI2M1xcXFx1MGI4MlxcXFx1MGJiZVxcXFx1MGJjMFxcXFx1MGJjZFxcXFx1MGJkN1xcXFx1MGMzZS1cXFxcdTBjNDBcXFxcdTBjNDYtXFxcXHUwYzQ4XFxcXHUwYzRhLVxcXFx1MGM0ZFxcXFx1MGM1NVxcXFx1MGM1NlxcXFx1MGM2MlxcXFx1MGM2M1xcXFx1MGNiY1xcXFx1MGNiZlxcXFx1MGNjMlxcXFx1MGNjNlxcXFx1MGNjY1xcXFx1MGNjZFxcXFx1MGNkNVxcXFx1MGNkNlxcXFx1MGNlMlxcXFx1MGNlM1xcXFx1MGQzZVxcXFx1MGQ0MS1cXFxcdTBkNDRcXFxcdTBkNGRcXFxcdTBkNTdcXFxcdTBkNjJcXFxcdTBkNjNcXFxcdTBkY2FcXFxcdTBkY2ZcXFxcdTBkZDItXFxcXHUwZGQ0XFxcXHUwZGQ2XFxcXHUwZGRmXFxcXHUwZTMxXFxcXHUwZTM0LVxcXFx1MGUzYVxcXFx1MGU0Ny1cXFxcdTBlNGVcXFxcdTBlYjFcXFxcdTBlYjQtXFxcXHUwZWI5XFxcXHUwZWJiXFxcXHUwZWJjXFxcXHUwZWM4LVxcXFx1MGVjZFxcXFx1MGYxOFxcXFx1MGYxOVxcXFx1MGYzNVxcXFx1MGYzN1xcXFx1MGYzOVxcXFx1MGY3MS1cXFxcdTBmN2VcXFxcdTBmODAtXFxcXHUwZjg0XFxcXHUwZjg2XFxcXHUwZjg3XFxcXHUwZjkwLVxcXFx1MGY5N1xcXFx1MGY5OS1cXFxcdTBmYmNcXFxcdTBmYzZcXFxcdTEwMmQtXFxcXHUxMDMwXFxcXHUxMDMyLVxcXFx1MTAzN1xcXFx1MTAzOVxcXFx1MTAzYVxcXFx1MTAzZFxcXFx1MTAzZVxcXFx1MTA1OFxcXFx1MTA1OVxcXFx1MTA1ZS1cXFxcdTEwNjBcXFxcdTEwNzEtXFxcXHUxMDc0XFxcXHUxMDgyXFxcXHUxMDg1XFxcXHUxMDg2XFxcXHUxMDhkXFxcXHUxMDlkXFxcXHUxMzVmXFxcXHUxNzEyLVxcXFx1MTcxNFxcXFx1MTczMi1cXFxcdTE3MzRcXFxcdTE3NTJcXFxcdTE3NTNcXFxcdTE3NzJcXFxcdTE3NzNcXFxcdTE3YjctXFxcXHUxN2JkXFxcXHUxN2M2XFxcXHUxN2M5LVxcXFx1MTdkM1xcXFx1MTdkZFxcXFx1MTgwYi1cXFxcdTE4MGRcXFxcdTE4YTlcXFxcdTE5MjAtXFxcXHUxOTIyXFxcXHUxOTI3XFxcXHUxOTI4XFxcXHUxOTMyXFxcXHUxOTM5LVxcXFx1MTkzYlxcXFx1MWExN1xcXFx1MWExOFxcXFx1MWE1NlxcXFx1MWE1OC1cXFxcdTFhNWVcXFxcdTFhNjBcXFxcdTFhNjJcXFxcdTFhNjUtXFxcXHUxYTZjXFxcXHUxYTczLVxcXFx1MWE3Y1xcXFx1MWE3ZlxcXFx1MWIwMC1cXFxcdTFiMDNcXFxcdTFiMzRcXFxcdTFiMzYtXFxcXHUxYjNhXFxcXHUxYjNjXFxcXHUxYjQyXFxcXHUxYjZiLVxcXFx1MWI3M1xcXFx1MWI4MFxcXFx1MWI4MVxcXFx1MWJhMi1cXFxcdTFiYTVcXFxcdTFiYThcXFxcdTFiYTlcXFxcdTFjMmMtXFxcXHUxYzMzXFxcXHUxYzM2XFxcXHUxYzM3XFxcXHUxY2QwLVxcXFx1MWNkMlxcXFx1MWNkNC1cXFxcdTFjZTBcXFxcdTFjZTItXFxcXHUxY2U4XFxcXHUxY2VkXFxcXHUxZGMwLVxcXFx1MWRlNlxcXFx1MWRmZC1cXFxcdTFkZmZcXFxcdTIwMGNcXFxcdTIwMGRcXFxcdTIwZDAtXFxcXHUyMGYwXFxcXHUyY2VmLVxcXFx1MmNmMVxcXFx1MmRlMC1cXFxcdTJkZmZcXFxcdTMwMmEtXFxcXHUzMDJmXFxcXHUzMDk5XFxcXHUzMDlhXFxcXHVhNjZmLVxcXFx1YTY3MlxcXFx1YTY3Y1xcXFx1YTY3ZFxcXFx1YTZmMFxcXFx1YTZmMVxcXFx1YTgwMlxcXFx1YTgwNlxcXFx1YTgwYlxcXFx1YTgyNVxcXFx1YTgyNlxcXFx1YThjNFxcXFx1YThlMC1cXFxcdWE4ZjFcXFxcdWE5MjYtXFxcXHVhOTJkXFxcXHVhOTQ3LVxcXFx1YTk1MVxcXFx1YTk4MC1cXFxcdWE5ODJcXFxcdWE5YjNcXFxcdWE5YjYtXFxcXHVhOWI5XFxcXHVhOWJjXFxcXHVhYTI5LVxcXFx1YWEyZVxcXFx1YWEzMVxcXFx1YWEzMlxcXFx1YWEzNVxcXFx1YWEzNlxcXFx1YWE0M1xcXFx1YWE0Y1xcXFx1YWFiMFxcXFx1YWFiMi1cXFxcdWFhYjRcXFxcdWFhYjdcXFxcdWFhYjhcXFxcdWFhYmVcXFxcdWFhYmZcXFxcdWFhYzFcXFxcdWFiZTVcXFxcdWFiZThcXFxcdWFiZWRcXFxcdWRjMDAtXFxcXHVkZmZmXFxcXHVmYjFlXFxcXHVmZTAwLVxcXFx1ZmUwZlxcXFx1ZmUyMC1cXFxcdWZlMjZcXFxcdWZmOWVcXFxcdWZmOWZdL1xcbmZ1bmN0aW9uIGlzRXh0ZW5kaW5nQ2hhcihjaCkgeyByZXR1cm4gY2guY2hhckNvZGVBdCgwKSA+PSA3NjggJiYgZXh0ZW5kaW5nQ2hhcnMudGVzdChjaCkgfVxcblxcbi8vIFJldHVybnMgYSBudW1iZXIgZnJvbSB0aGUgcmFuZ2UgW2AwYDsgYHN0ci5sZW5ndGhgXSB1bmxlc3MgYHBvc2AgaXMgb3V0c2lkZSB0aGF0IHJhbmdlLlxcbmZ1bmN0aW9uIHNraXBFeHRlbmRpbmdDaGFycyhzdHIsIHBvcywgZGlyKSB7XFxuICB3aGlsZSAoKGRpciA8IDAgPyBwb3MgPiAwIDogcG9zIDwgc3RyLmxlbmd0aCkgJiYgaXNFeHRlbmRpbmdDaGFyKHN0ci5jaGFyQXQocG9zKSkpIHsgcG9zICs9IGRpciB9XFxuICByZXR1cm4gcG9zXFxufVxcblxcbi8vIFJldHVybnMgdGhlIHZhbHVlIGZyb20gdGhlIHJhbmdlIFtgZnJvbWA7IGB0b2BdIHRoYXQgc2F0aXNmaWVzXFxuLy8gYHByZWRgIGFuZCBpcyBjbG9zZXN0IHRvIGBmcm9tYC4gQXNzdW1lcyB0aGF0IGF0IGxlYXN0IGB0b2Agc2F0aXNmaWVzIGBwcmVkYC5cXG5mdW5jdGlvbiBmaW5kRmlyc3QocHJlZCwgZnJvbSwgdG8pIHtcXG4gIGZvciAoOzspIHtcXG4gICAgaWYgKE1hdGguYWJzKGZyb20gLSB0bykgPD0gMSkgeyByZXR1cm4gcHJlZChmcm9tKSA/IGZyb20gOiB0byB9XFxuICAgIHZhciBtaWQgPSBNYXRoLmZsb29yKChmcm9tICsgdG8pIC8gMilcXG4gICAgaWYgKHByZWQobWlkKSkgeyB0byA9IG1pZCB9XFxuICAgIGVsc2UgeyBmcm9tID0gbWlkIH1cXG4gIH1cXG59XFxuXFxuLy8gVGhlIGRpc3BsYXkgaGFuZGxlcyB0aGUgRE9NIGludGVncmF0aW9uLCBib3RoIGZvciBpbnB1dCByZWFkaW5nXFxuLy8gYW5kIGNvbnRlbnQgZHJhd2luZy4gSXQgaG9sZHMgcmVmZXJlbmNlcyB0byBET00gbm9kZXMgYW5kXFxuLy8gZGlzcGxheS1yZWxhdGVkIHN0YXRlLlxcblxcbmZ1bmN0aW9uIERpc3BsYXkocGxhY2UsIGRvYywgaW5wdXQpIHtcXG4gIHZhciBkID0gdGhpc1xcbiAgdGhpcy5pbnB1dCA9IGlucHV0XFxuXFxuICAvLyBDb3ZlcnMgYm90dG9tLXJpZ2h0IHNxdWFyZSB3aGVuIGJvdGggc2Nyb2xsYmFycyBhcmUgcHJlc2VudC5cXG4gIGQuc2Nyb2xsYmFyRmlsbGVyID0gZWx0KFxcXCJkaXZcXFwiLCBudWxsLCBcXFwiQ29kZU1pcnJvci1zY3JvbGxiYXItZmlsbGVyXFxcIilcXG4gIGQuc2Nyb2xsYmFyRmlsbGVyLnNldEF0dHJpYnV0ZShcXFwiY20tbm90LWNvbnRlbnRcXFwiLCBcXFwidHJ1ZVxcXCIpXFxuICAvLyBDb3ZlcnMgYm90dG9tIG9mIGd1dHRlciB3aGVuIGNvdmVyR3V0dGVyTmV4dFRvU2Nyb2xsYmFyIGlzIG9uXFxuICAvLyBhbmQgaCBzY3JvbGxiYXIgaXMgcHJlc2VudC5cXG4gIGQuZ3V0dGVyRmlsbGVyID0gZWx0KFxcXCJkaXZcXFwiLCBudWxsLCBcXFwiQ29kZU1pcnJvci1ndXR0ZXItZmlsbGVyXFxcIilcXG4gIGQuZ3V0dGVyRmlsbGVyLnNldEF0dHJpYnV0ZShcXFwiY20tbm90LWNvbnRlbnRcXFwiLCBcXFwidHJ1ZVxcXCIpXFxuICAvLyBXaWxsIGNvbnRhaW4gdGhlIGFjdHVhbCBjb2RlLCBwb3NpdGlvbmVkIHRvIGNvdmVyIHRoZSB2aWV3cG9ydC5cXG4gIGQubGluZURpdiA9IGVsdChcXFwiZGl2XFxcIiwgbnVsbCwgXFxcIkNvZGVNaXJyb3ItY29kZVxcXCIpXFxuICAvLyBFbGVtZW50cyBhcmUgYWRkZWQgdG8gdGhlc2UgdG8gcmVwcmVzZW50IHNlbGVjdGlvbiBhbmQgY3Vyc29ycy5cXG4gIGQuc2VsZWN0aW9uRGl2ID0gZWx0KFxcXCJkaXZcXFwiLCBudWxsLCBudWxsLCBcXFwicG9zaXRpb246IHJlbGF0aXZlOyB6LWluZGV4OiAxXFxcIilcXG4gIGQuY3Vyc29yRGl2ID0gZWx0KFxcXCJkaXZcXFwiLCBudWxsLCBcXFwiQ29kZU1pcnJvci1jdXJzb3JzXFxcIilcXG4gIC8vIEEgdmlzaWJpbGl0eTogaGlkZGVuIGVsZW1lbnQgdXNlZCB0byBmaW5kIHRoZSBzaXplIG9mIHRoaW5ncy5cXG4gIGQubWVhc3VyZSA9IGVsdChcXFwiZGl2XFxcIiwgbnVsbCwgXFxcIkNvZGVNaXJyb3ItbWVhc3VyZVxcXCIpXFxuICAvLyBXaGVuIGxpbmVzIG91dHNpZGUgb2YgdGhlIHZpZXdwb3J0IGFyZSBtZWFzdXJlZCwgdGhleSBhcmUgZHJhd24gaW4gdGhpcy5cXG4gIGQubGluZU1lYXN1cmUgPSBlbHQoXFxcImRpdlxcXCIsIG51bGwsIFxcXCJDb2RlTWlycm9yLW1lYXN1cmVcXFwiKVxcbiAgLy8gV3JhcHMgZXZlcnl0aGluZyB0aGF0IG5lZWRzIHRvIGV4aXN0IGluc2lkZSB0aGUgdmVydGljYWxseS1wYWRkZWQgY29vcmRpbmF0ZSBzeXN0ZW1cXG4gIGQubGluZVNwYWNlID0gZWx0KFxcXCJkaXZcXFwiLCBbZC5tZWFzdXJlLCBkLmxpbmVNZWFzdXJlLCBkLnNlbGVjdGlvbkRpdiwgZC5jdXJzb3JEaXYsIGQubGluZURpdl0sXFxuICAgICAgICAgICAgICAgICAgICBudWxsLCBcXFwicG9zaXRpb246IHJlbGF0aXZlOyBvdXRsaW5lOiBub25lXFxcIilcXG4gIC8vIE1vdmVkIGFyb3VuZCBpdHMgcGFyZW50IHRvIGNvdmVyIHZpc2libGUgdmlldy5cXG4gIGQubW92ZXIgPSBlbHQoXFxcImRpdlxcXCIsIFtlbHQoXFxcImRpdlxcXCIsIFtkLmxpbmVTcGFjZV0sIFxcXCJDb2RlTWlycm9yLWxpbmVzXFxcIildLCBudWxsLCBcXFwicG9zaXRpb246IHJlbGF0aXZlXFxcIilcXG4gIC8vIFNldCB0byB0aGUgaGVpZ2h0IG9mIHRoZSBkb2N1bWVudCwgYWxsb3dpbmcgc2Nyb2xsaW5nLlxcbiAgZC5zaXplciA9IGVsdChcXFwiZGl2XFxcIiwgW2QubW92ZXJdLCBcXFwiQ29kZU1pcnJvci1zaXplclxcXCIpXFxuICBkLnNpemVyV2lkdGggPSBudWxsXFxuICAvLyBCZWhhdmlvciBvZiBlbHRzIHdpdGggb3ZlcmZsb3c6IGF1dG8gYW5kIHBhZGRpbmcgaXNcXG4gIC8vIGluY29uc2lzdGVudCBhY3Jvc3MgYnJvd3NlcnMuIFRoaXMgaXMgdXNlZCB0byBlbnN1cmUgdGhlXFxuICAvLyBzY3JvbGxhYmxlIGFyZWEgaXMgYmlnIGVub3VnaC5cXG4gIGQuaGVpZ2h0Rm9yY2VyID0gZWx0KFxcXCJkaXZcXFwiLCBudWxsLCBudWxsLCBcXFwicG9zaXRpb246IGFic29sdXRlOyBoZWlnaHQ6IFxcXCIgKyBzY3JvbGxlckdhcCArIFxcXCJweDsgd2lkdGg6IDFweDtcXFwiKVxcbiAgLy8gV2lsbCBjb250YWluIHRoZSBndXR0ZXJzLCBpZiBhbnkuXFxuICBkLmd1dHRlcnMgPSBlbHQoXFxcImRpdlxcXCIsIG51bGwsIFxcXCJDb2RlTWlycm9yLWd1dHRlcnNcXFwiKVxcbiAgZC5saW5lR3V0dGVyID0gbnVsbFxcbiAgLy8gQWN0dWFsIHNjcm9sbGFibGUgZWxlbWVudC5cXG4gIGQuc2Nyb2xsZXIgPSBlbHQoXFxcImRpdlxcXCIsIFtkLnNpemVyLCBkLmhlaWdodEZvcmNlciwgZC5ndXR0ZXJzXSwgXFxcIkNvZGVNaXJyb3Itc2Nyb2xsXFxcIilcXG4gIGQuc2Nyb2xsZXIuc2V0QXR0cmlidXRlKFxcXCJ0YWJJbmRleFxcXCIsIFxcXCItMVxcXCIpXFxuICAvLyBUaGUgZWxlbWVudCBpbiB3aGljaCB0aGUgZWRpdG9yIGxpdmVzLlxcbiAgZC53cmFwcGVyID0gZWx0KFxcXCJkaXZcXFwiLCBbZC5zY3JvbGxiYXJGaWxsZXIsIGQuZ3V0dGVyRmlsbGVyLCBkLnNjcm9sbGVyXSwgXFxcIkNvZGVNaXJyb3JcXFwiKVxcblxcbiAgLy8gV29yayBhcm91bmQgSUU3IHotaW5kZXggYnVnIChub3QgcGVyZmVjdCwgaGVuY2UgSUU3IG5vdCByZWFsbHkgYmVpbmcgc3VwcG9ydGVkKVxcbiAgaWYgKGllICYmIGllX3ZlcnNpb24gPCA4KSB7IGQuZ3V0dGVycy5zdHlsZS56SW5kZXggPSAtMTsgZC5zY3JvbGxlci5zdHlsZS5wYWRkaW5nUmlnaHQgPSAwIH1cXG4gIGlmICghd2Via2l0ICYmICEoZ2Vja28gJiYgbW9iaWxlKSkgeyBkLnNjcm9sbGVyLmRyYWdnYWJsZSA9IHRydWUgfVxcblxcbiAgaWYgKHBsYWNlKSB7XFxuICAgIGlmIChwbGFjZS5hcHBlbmRDaGlsZCkgeyBwbGFjZS5hcHBlbmRDaGlsZChkLndyYXBwZXIpIH1cXG4gICAgZWxzZSB7IHBsYWNlKGQud3JhcHBlcikgfVxcbiAgfVxcblxcbiAgLy8gQ3VycmVudCByZW5kZXJlZCByYW5nZSAobWF5IGJlIGJpZ2dlciB0aGFuIHRoZSB2aWV3IHdpbmRvdykuXFxuICBkLnZpZXdGcm9tID0gZC52aWV3VG8gPSBkb2MuZmlyc3RcXG4gIGQucmVwb3J0ZWRWaWV3RnJvbSA9IGQucmVwb3J0ZWRWaWV3VG8gPSBkb2MuZmlyc3RcXG4gIC8vIEluZm9ybWF0aW9uIGFib3V0IHRoZSByZW5kZXJlZCBsaW5lcy5cXG4gIGQudmlldyA9IFtdXFxuICBkLnJlbmRlcmVkVmlldyA9IG51bGxcXG4gIC8vIEhvbGRzIGluZm8gYWJvdXQgYSBzaW5nbGUgcmVuZGVyZWQgbGluZSB3aGVuIGl0IHdhcyByZW5kZXJlZFxcbiAgLy8gZm9yIG1lYXN1cmVtZW50LCB3aGlsZSBub3QgaW4gdmlldy5cXG4gIGQuZXh0ZXJuYWxNZWFzdXJlZCA9IG51bGxcXG4gIC8vIEVtcHR5IHNwYWNlIChpbiBwaXhlbHMpIGFib3ZlIHRoZSB2aWV3XFxuICBkLnZpZXdPZmZzZXQgPSAwXFxuICBkLmxhc3RXcmFwSGVpZ2h0ID0gZC5sYXN0V3JhcFdpZHRoID0gMFxcbiAgZC51cGRhdGVMaW5lTnVtYmVycyA9IG51bGxcXG5cXG4gIGQubmF0aXZlQmFyV2lkdGggPSBkLmJhckhlaWdodCA9IGQuYmFyV2lkdGggPSAwXFxuICBkLnNjcm9sbGJhcnNDbGlwcGVkID0gZmFsc2VcXG5cXG4gIC8vIFVzZWQgdG8gb25seSByZXNpemUgdGhlIGxpbmUgbnVtYmVyIGd1dHRlciB3aGVuIG5lY2Vzc2FyeSAod2hlblxcbiAgLy8gdGhlIGFtb3VudCBvZiBsaW5lcyBjcm9zc2VzIGEgYm91bmRhcnkgdGhhdCBtYWtlcyBpdHMgd2lkdGggY2hhbmdlKVxcbiAgZC5saW5lTnVtV2lkdGggPSBkLmxpbmVOdW1Jbm5lcldpZHRoID0gZC5saW5lTnVtQ2hhcnMgPSBudWxsXFxuICAvLyBTZXQgdG8gdHJ1ZSB3aGVuIGEgbm9uLWhvcml6b250YWwtc2Nyb2xsaW5nIGxpbmUgd2lkZ2V0IGlzXFxuICAvLyBhZGRlZC4gQXMgYW4gb3B0aW1pemF0aW9uLCBsaW5lIHdpZGdldCBhbGlnbmluZyBpcyBza2lwcGVkIHdoZW5cXG4gIC8vIHRoaXMgaXMgZmFsc2UuXFxuICBkLmFsaWduV2lkZ2V0cyA9IGZhbHNlXFxuXFxuICBkLmNhY2hlZENoYXJXaWR0aCA9IGQuY2FjaGVkVGV4dEhlaWdodCA9IGQuY2FjaGVkUGFkZGluZ0ggPSBudWxsXFxuXFxuICAvLyBUcmFja3MgdGhlIG1heGltdW0gbGluZSBsZW5ndGggc28gdGhhdCB0aGUgaG9yaXpvbnRhbCBzY3JvbGxiYXJcXG4gIC8vIGNhbiBiZSBrZXB0IHN0YXRpYyB3aGVuIHNjcm9sbGluZy5cXG4gIGQubWF4TGluZSA9IG51bGxcXG4gIGQubWF4TGluZUxlbmd0aCA9IDBcXG4gIGQubWF4TGluZUNoYW5nZWQgPSBmYWxzZVxcblxcbiAgLy8gVXNlZCBmb3IgbWVhc3VyaW5nIHdoZWVsIHNjcm9sbGluZyBncmFudWxhcml0eVxcbiAgZC53aGVlbERYID0gZC53aGVlbERZID0gZC53aGVlbFN0YXJ0WCA9IGQud2hlZWxTdGFydFkgPSBudWxsXFxuXFxuICAvLyBUcnVlIHdoZW4gc2hpZnQgaXMgaGVsZCBkb3duLlxcbiAgZC5zaGlmdCA9IGZhbHNlXFxuXFxuICAvLyBVc2VkIHRvIHRyYWNrIHdoZXRoZXIgYW55dGhpbmcgaGFwcGVuZWQgc2luY2UgdGhlIGNvbnRleHQgbWVudVxcbiAgLy8gd2FzIG9wZW5lZC5cXG4gIGQuc2VsRm9yQ29udGV4dE1lbnUgPSBudWxsXFxuXFxuICBkLmFjdGl2ZVRvdWNoID0gbnVsbFxcblxcbiAgaW5wdXQuaW5pdChkKVxcbn1cXG5cXG4vLyBGaW5kIHRoZSBsaW5lIG9iamVjdCBjb3JyZXNwb25kaW5nIHRvIHRoZSBnaXZlbiBsaW5lIG51bWJlci5cXG5mdW5jdGlvbiBnZXRMaW5lKGRvYywgbikge1xcbiAgbiAtPSBkb2MuZmlyc3RcXG4gIGlmIChuIDwgMCB8fCBuID49IGRvYy5zaXplKSB7IHRocm93IG5ldyBFcnJvcihcXFwiVGhlcmUgaXMgbm8gbGluZSBcXFwiICsgKG4gKyBkb2MuZmlyc3QpICsgXFxcIiBpbiB0aGUgZG9jdW1lbnQuXFxcIikgfVxcbiAgdmFyIGNodW5rID0gZG9jXFxuICB3aGlsZSAoIWNodW5rLmxpbmVzKSB7XFxuICAgIGZvciAodmFyIGkgPSAwOzsgKytpKSB7XFxuICAgICAgdmFyIGNoaWxkID0gY2h1bmsuY2hpbGRyZW5baV0sIHN6ID0gY2hpbGQuY2h1bmtTaXplKClcXG4gICAgICBpZiAobiA8IHN6KSB7IGNodW5rID0gY2hpbGQ7IGJyZWFrIH1cXG4gICAgICBuIC09IHN6XFxuICAgIH1cXG4gIH1cXG4gIHJldHVybiBjaHVuay5saW5lc1tuXVxcbn1cXG5cXG4vLyBHZXQgdGhlIHBhcnQgb2YgYSBkb2N1bWVudCBiZXR3ZWVuIHR3byBwb3NpdGlvbnMsIGFzIGFuIGFycmF5IG9mXFxuLy8gc3RyaW5ncy5cXG5mdW5jdGlvbiBnZXRCZXR3ZWVuKGRvYywgc3RhcnQsIGVuZCkge1xcbiAgdmFyIG91dCA9IFtdLCBuID0gc3RhcnQubGluZVxcbiAgZG9jLml0ZXIoc3RhcnQubGluZSwgZW5kLmxpbmUgKyAxLCBmdW5jdGlvbiAobGluZSkge1xcbiAgICB2YXIgdGV4dCA9IGxpbmUudGV4dFxcbiAgICBpZiAobiA9PSBlbmQubGluZSkgeyB0ZXh0ID0gdGV4dC5zbGljZSgwLCBlbmQuY2gpIH1cXG4gICAgaWYgKG4gPT0gc3RhcnQubGluZSkgeyB0ZXh0ID0gdGV4dC5zbGljZShzdGFydC5jaCkgfVxcbiAgICBvdXQucHVzaCh0ZXh0KVxcbiAgICArK25cXG4gIH0pXFxuICByZXR1cm4gb3V0XFxufVxcbi8vIEdldCB0aGUgbGluZXMgYmV0d2VlbiBmcm9tIGFuZCB0bywgYXMgYXJyYXkgb2Ygc3RyaW5ncy5cXG5mdW5jdGlvbiBnZXRMaW5lcyhkb2MsIGZyb20sIHRvKSB7XFxuICB2YXIgb3V0ID0gW11cXG4gIGRvYy5pdGVyKGZyb20sIHRvLCBmdW5jdGlvbiAobGluZSkgeyBvdXQucHVzaChsaW5lLnRleHQpIH0pIC8vIGl0ZXIgYWJvcnRzIHdoZW4gY2FsbGJhY2sgcmV0dXJucyB0cnV0aHkgdmFsdWVcXG4gIHJldHVybiBvdXRcXG59XFxuXFxuLy8gVXBkYXRlIHRoZSBoZWlnaHQgb2YgYSBsaW5lLCBwcm9wYWdhdGluZyB0aGUgaGVpZ2h0IGNoYW5nZVxcbi8vIHVwd2FyZHMgdG8gcGFyZW50IG5vZGVzLlxcbmZ1bmN0aW9uIHVwZGF0ZUxpbmVIZWlnaHQobGluZSwgaGVpZ2h0KSB7XFxuICB2YXIgZGlmZiA9IGhlaWdodCAtIGxpbmUuaGVpZ2h0XFxuICBpZiAoZGlmZikgeyBmb3IgKHZhciBuID0gbGluZTsgbjsgbiA9IG4ucGFyZW50KSB7IG4uaGVpZ2h0ICs9IGRpZmYgfSB9XFxufVxcblxcbi8vIEdpdmVuIGEgbGluZSBvYmplY3QsIGZpbmQgaXRzIGxpbmUgbnVtYmVyIGJ5IHdhbGtpbmcgdXAgdGhyb3VnaFxcbi8vIGl0cyBwYXJlbnQgbGlua3MuXFxuZnVuY3Rpb24gbGluZU5vKGxpbmUpIHtcXG4gIGlmIChsaW5lLnBhcmVudCA9PSBudWxsKSB7IHJldHVybiBudWxsIH1cXG4gIHZhciBjdXIgPSBsaW5lLnBhcmVudCwgbm8gPSBpbmRleE9mKGN1ci5saW5lcywgbGluZSlcXG4gIGZvciAodmFyIGNodW5rID0gY3VyLnBhcmVudDsgY2h1bms7IGN1ciA9IGNodW5rLCBjaHVuayA9IGNodW5rLnBhcmVudCkge1xcbiAgICBmb3IgKHZhciBpID0gMDs7ICsraSkge1xcbiAgICAgIGlmIChjaHVuay5jaGlsZHJlbltpXSA9PSBjdXIpIHsgYnJlYWsgfVxcbiAgICAgIG5vICs9IGNodW5rLmNoaWxkcmVuW2ldLmNodW5rU2l6ZSgpXFxuICAgIH1cXG4gIH1cXG4gIHJldHVybiBubyArIGN1ci5maXJzdFxcbn1cXG5cXG4vLyBGaW5kIHRoZSBsaW5lIGF0IHRoZSBnaXZlbiB2ZXJ0aWNhbCBwb3NpdGlvbiwgdXNpbmcgdGhlIGhlaWdodFxcbi8vIGluZm9ybWF0aW9uIGluIHRoZSBkb2N1bWVudCB0cmVlLlxcbmZ1bmN0aW9uIGxpbmVBdEhlaWdodChjaHVuaywgaCkge1xcbiAgdmFyIG4gPSBjaHVuay5maXJzdFxcbiAgb3V0ZXI6IGRvIHtcXG4gICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgY2h1bmsuY2hpbGRyZW4ubGVuZ3RoOyArK2kkMSkge1xcbiAgICAgIHZhciBjaGlsZCA9IGNodW5rLmNoaWxkcmVuW2kkMV0sIGNoID0gY2hpbGQuaGVpZ2h0XFxuICAgICAgaWYgKGggPCBjaCkgeyBjaHVuayA9IGNoaWxkOyBjb250aW51ZSBvdXRlciB9XFxuICAgICAgaCAtPSBjaFxcbiAgICAgIG4gKz0gY2hpbGQuY2h1bmtTaXplKClcXG4gICAgfVxcbiAgICByZXR1cm4gblxcbiAgfSB3aGlsZSAoIWNodW5rLmxpbmVzKVxcbiAgdmFyIGkgPSAwXFxuICBmb3IgKDsgaSA8IGNodW5rLmxpbmVzLmxlbmd0aDsgKytpKSB7XFxuICAgIHZhciBsaW5lID0gY2h1bmsubGluZXNbaV0sIGxoID0gbGluZS5oZWlnaHRcXG4gICAgaWYgKGggPCBsaCkgeyBicmVhayB9XFxuICAgIGggLT0gbGhcXG4gIH1cXG4gIHJldHVybiBuICsgaVxcbn1cXG5cXG5mdW5jdGlvbiBpc0xpbmUoZG9jLCBsKSB7cmV0dXJuIGwgPj0gZG9jLmZpcnN0ICYmIGwgPCBkb2MuZmlyc3QgKyBkb2Muc2l6ZX1cXG5cXG5mdW5jdGlvbiBsaW5lTnVtYmVyRm9yKG9wdGlvbnMsIGkpIHtcXG4gIHJldHVybiBTdHJpbmcob3B0aW9ucy5saW5lTnVtYmVyRm9ybWF0dGVyKGkgKyBvcHRpb25zLmZpcnN0TGluZU51bWJlcikpXFxufVxcblxcbi8vIEEgUG9zIGluc3RhbmNlIHJlcHJlc2VudHMgYSBwb3NpdGlvbiB3aXRoaW4gdGhlIHRleHQuXFxuZnVuY3Rpb24gUG9zKGxpbmUsIGNoLCBzdGlja3kpIHtcXG4gIGlmICggc3RpY2t5ID09PSB2b2lkIDAgKSBzdGlja3kgPSBudWxsO1xcblxcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFBvcykpIHsgcmV0dXJuIG5ldyBQb3MobGluZSwgY2gsIHN0aWNreSkgfVxcbiAgdGhpcy5saW5lID0gbGluZVxcbiAgdGhpcy5jaCA9IGNoXFxuICB0aGlzLnN0aWNreSA9IHN0aWNreVxcbn1cXG5cXG4vLyBDb21wYXJlIHR3byBwb3NpdGlvbnMsIHJldHVybiAwIGlmIHRoZXkgYXJlIHRoZSBzYW1lLCBhIG5lZ2F0aXZlXFxuLy8gbnVtYmVyIHdoZW4gYSBpcyBsZXNzLCBhbmQgYSBwb3NpdGl2ZSBudW1iZXIgb3RoZXJ3aXNlLlxcbmZ1bmN0aW9uIGNtcChhLCBiKSB7IHJldHVybiBhLmxpbmUgLSBiLmxpbmUgfHwgYS5jaCAtIGIuY2ggfVxcblxcbmZ1bmN0aW9uIGVxdWFsQ3Vyc29yUG9zKGEsIGIpIHsgcmV0dXJuIGEuc3RpY2t5ID09IGIuc3RpY2t5ICYmIGNtcChhLCBiKSA9PSAwIH1cXG5cXG5mdW5jdGlvbiBjb3B5UG9zKHgpIHtyZXR1cm4gUG9zKHgubGluZSwgeC5jaCl9XFxuZnVuY3Rpb24gbWF4UG9zKGEsIGIpIHsgcmV0dXJuIGNtcChhLCBiKSA8IDAgPyBiIDogYSB9XFxuZnVuY3Rpb24gbWluUG9zKGEsIGIpIHsgcmV0dXJuIGNtcChhLCBiKSA8IDAgPyBhIDogYiB9XFxuXFxuLy8gTW9zdCBvZiB0aGUgZXh0ZXJuYWwgQVBJIGNsaXBzIGdpdmVuIHBvc2l0aW9ucyB0byBtYWtlIHN1cmUgdGhleVxcbi8vIGFjdHVhbGx5IGV4aXN0IHdpdGhpbiB0aGUgZG9jdW1lbnQuXFxuZnVuY3Rpb24gY2xpcExpbmUoZG9jLCBuKSB7cmV0dXJuIE1hdGgubWF4KGRvYy5maXJzdCwgTWF0aC5taW4obiwgZG9jLmZpcnN0ICsgZG9jLnNpemUgLSAxKSl9XFxuZnVuY3Rpb24gY2xpcFBvcyhkb2MsIHBvcykge1xcbiAgaWYgKHBvcy5saW5lIDwgZG9jLmZpcnN0KSB7IHJldHVybiBQb3MoZG9jLmZpcnN0LCAwKSB9XFxuICB2YXIgbGFzdCA9IGRvYy5maXJzdCArIGRvYy5zaXplIC0gMVxcbiAgaWYgKHBvcy5saW5lID4gbGFzdCkgeyByZXR1cm4gUG9zKGxhc3QsIGdldExpbmUoZG9jLCBsYXN0KS50ZXh0Lmxlbmd0aCkgfVxcbiAgcmV0dXJuIGNsaXBUb0xlbihwb3MsIGdldExpbmUoZG9jLCBwb3MubGluZSkudGV4dC5sZW5ndGgpXFxufVxcbmZ1bmN0aW9uIGNsaXBUb0xlbihwb3MsIGxpbmVsZW4pIHtcXG4gIHZhciBjaCA9IHBvcy5jaFxcbiAgaWYgKGNoID09IG51bGwgfHwgY2ggPiBsaW5lbGVuKSB7IHJldHVybiBQb3MocG9zLmxpbmUsIGxpbmVsZW4pIH1cXG4gIGVsc2UgaWYgKGNoIDwgMCkgeyByZXR1cm4gUG9zKHBvcy5saW5lLCAwKSB9XFxuICBlbHNlIHsgcmV0dXJuIHBvcyB9XFxufVxcbmZ1bmN0aW9uIGNsaXBQb3NBcnJheShkb2MsIGFycmF5KSB7XFxuICB2YXIgb3V0ID0gW11cXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHsgb3V0W2ldID0gY2xpcFBvcyhkb2MsIGFycmF5W2ldKSB9XFxuICByZXR1cm4gb3V0XFxufVxcblxcbi8vIE9wdGltaXplIHNvbWUgY29kZSB3aGVuIHRoZXNlIGZlYXR1cmVzIGFyZSBub3QgdXNlZC5cXG52YXIgc2F3UmVhZE9ubHlTcGFucyA9IGZhbHNlO1xcbnZhciBzYXdDb2xsYXBzZWRTcGFucyA9IGZhbHNlO1xcbmZ1bmN0aW9uIHNlZVJlYWRPbmx5U3BhbnMoKSB7XFxuICBzYXdSZWFkT25seVNwYW5zID0gdHJ1ZVxcbn1cXG5cXG5mdW5jdGlvbiBzZWVDb2xsYXBzZWRTcGFucygpIHtcXG4gIHNhd0NvbGxhcHNlZFNwYW5zID0gdHJ1ZVxcbn1cXG5cXG4vLyBURVhUTUFSS0VSIFNQQU5TXFxuXFxuZnVuY3Rpb24gTWFya2VkU3BhbihtYXJrZXIsIGZyb20sIHRvKSB7XFxuICB0aGlzLm1hcmtlciA9IG1hcmtlclxcbiAgdGhpcy5mcm9tID0gZnJvbTsgdGhpcy50byA9IHRvXFxufVxcblxcbi8vIFNlYXJjaCBhbiBhcnJheSBvZiBzcGFucyBmb3IgYSBzcGFuIG1hdGNoaW5nIHRoZSBnaXZlbiBtYXJrZXIuXFxuZnVuY3Rpb24gZ2V0TWFya2VkU3BhbkZvcihzcGFucywgbWFya2VyKSB7XFxuICBpZiAoc3BhbnMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBzcGFucy5sZW5ndGg7ICsraSkge1xcbiAgICB2YXIgc3BhbiA9IHNwYW5zW2ldXFxuICAgIGlmIChzcGFuLm1hcmtlciA9PSBtYXJrZXIpIHsgcmV0dXJuIHNwYW4gfVxcbiAgfSB9XFxufVxcbi8vIFJlbW92ZSBhIHNwYW4gZnJvbSBhbiBhcnJheSwgcmV0dXJuaW5nIHVuZGVmaW5lZCBpZiBubyBzcGFucyBhcmVcXG4vLyBsZWZ0ICh3ZSBkb24ndCBzdG9yZSBhcnJheXMgZm9yIGxpbmVzIHdpdGhvdXQgc3BhbnMpLlxcbmZ1bmN0aW9uIHJlbW92ZU1hcmtlZFNwYW4oc3BhbnMsIHNwYW4pIHtcXG4gIHZhciByXFxuICBmb3IgKHZhciBpID0gMDsgaSA8IHNwYW5zLmxlbmd0aDsgKytpKVxcbiAgICB7IGlmIChzcGFuc1tpXSAhPSBzcGFuKSB7IChyIHx8IChyID0gW10pKS5wdXNoKHNwYW5zW2ldKSB9IH1cXG4gIHJldHVybiByXFxufVxcbi8vIEFkZCBhIHNwYW4gdG8gYSBsaW5lLlxcbmZ1bmN0aW9uIGFkZE1hcmtlZFNwYW4obGluZSwgc3Bhbikge1xcbiAgbGluZS5tYXJrZWRTcGFucyA9IGxpbmUubWFya2VkU3BhbnMgPyBsaW5lLm1hcmtlZFNwYW5zLmNvbmNhdChbc3Bhbl0pIDogW3NwYW5dXFxuICBzcGFuLm1hcmtlci5hdHRhY2hMaW5lKGxpbmUpXFxufVxcblxcbi8vIFVzZWQgZm9yIHRoZSBhbGdvcml0aG0gdGhhdCBhZGp1c3RzIG1hcmtlcnMgZm9yIGEgY2hhbmdlIGluIHRoZVxcbi8vIGRvY3VtZW50LiBUaGVzZSBmdW5jdGlvbnMgY3V0IGFuIGFycmF5IG9mIHNwYW5zIGF0IGEgZ2l2ZW5cXG4vLyBjaGFyYWN0ZXIgcG9zaXRpb24sIHJldHVybmluZyBhbiBhcnJheSBvZiByZW1haW5pbmcgY2h1bmtzIChvclxcbi8vIHVuZGVmaW5lZCBpZiBub3RoaW5nIHJlbWFpbnMpLlxcbmZ1bmN0aW9uIG1hcmtlZFNwYW5zQmVmb3JlKG9sZCwgc3RhcnRDaCwgaXNJbnNlcnQpIHtcXG4gIHZhciBud1xcbiAgaWYgKG9sZCkgeyBmb3IgKHZhciBpID0gMDsgaSA8IG9sZC5sZW5ndGg7ICsraSkge1xcbiAgICB2YXIgc3BhbiA9IG9sZFtpXSwgbWFya2VyID0gc3Bhbi5tYXJrZXJcXG4gICAgdmFyIHN0YXJ0c0JlZm9yZSA9IHNwYW4uZnJvbSA9PSBudWxsIHx8IChtYXJrZXIuaW5jbHVzaXZlTGVmdCA/IHNwYW4uZnJvbSA8PSBzdGFydENoIDogc3Bhbi5mcm9tIDwgc3RhcnRDaClcXG4gICAgaWYgKHN0YXJ0c0JlZm9yZSB8fCBzcGFuLmZyb20gPT0gc3RhcnRDaCAmJiBtYXJrZXIudHlwZSA9PSBcXFwiYm9va21hcmtcXFwiICYmICghaXNJbnNlcnQgfHwgIXNwYW4ubWFya2VyLmluc2VydExlZnQpKSB7XFxuICAgICAgdmFyIGVuZHNBZnRlciA9IHNwYW4udG8gPT0gbnVsbCB8fCAobWFya2VyLmluY2x1c2l2ZVJpZ2h0ID8gc3Bhbi50byA+PSBzdGFydENoIDogc3Bhbi50byA+IHN0YXJ0Q2gpXFxuICAgICAgOyhudyB8fCAobncgPSBbXSkpLnB1c2gobmV3IE1hcmtlZFNwYW4obWFya2VyLCBzcGFuLmZyb20sIGVuZHNBZnRlciA/IG51bGwgOiBzcGFuLnRvKSlcXG4gICAgfVxcbiAgfSB9XFxuICByZXR1cm4gbndcXG59XFxuZnVuY3Rpb24gbWFya2VkU3BhbnNBZnRlcihvbGQsIGVuZENoLCBpc0luc2VydCkge1xcbiAgdmFyIG53XFxuICBpZiAob2xkKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgb2xkLmxlbmd0aDsgKytpKSB7XFxuICAgIHZhciBzcGFuID0gb2xkW2ldLCBtYXJrZXIgPSBzcGFuLm1hcmtlclxcbiAgICB2YXIgZW5kc0FmdGVyID0gc3Bhbi50byA9PSBudWxsIHx8IChtYXJrZXIuaW5jbHVzaXZlUmlnaHQgPyBzcGFuLnRvID49IGVuZENoIDogc3Bhbi50byA+IGVuZENoKVxcbiAgICBpZiAoZW5kc0FmdGVyIHx8IHNwYW4uZnJvbSA9PSBlbmRDaCAmJiBtYXJrZXIudHlwZSA9PSBcXFwiYm9va21hcmtcXFwiICYmICghaXNJbnNlcnQgfHwgc3Bhbi5tYXJrZXIuaW5zZXJ0TGVmdCkpIHtcXG4gICAgICB2YXIgc3RhcnRzQmVmb3JlID0gc3Bhbi5mcm9tID09IG51bGwgfHwgKG1hcmtlci5pbmNsdXNpdmVMZWZ0ID8gc3Bhbi5mcm9tIDw9IGVuZENoIDogc3Bhbi5mcm9tIDwgZW5kQ2gpXFxuICAgICAgOyhudyB8fCAobncgPSBbXSkpLnB1c2gobmV3IE1hcmtlZFNwYW4obWFya2VyLCBzdGFydHNCZWZvcmUgPyBudWxsIDogc3Bhbi5mcm9tIC0gZW5kQ2gsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcGFuLnRvID09IG51bGwgPyBudWxsIDogc3Bhbi50byAtIGVuZENoKSlcXG4gICAgfVxcbiAgfSB9XFxuICByZXR1cm4gbndcXG59XFxuXFxuLy8gR2l2ZW4gYSBjaGFuZ2Ugb2JqZWN0LCBjb21wdXRlIHRoZSBuZXcgc2V0IG9mIG1hcmtlciBzcGFucyB0aGF0XFxuLy8gY292ZXIgdGhlIGxpbmUgaW4gd2hpY2ggdGhlIGNoYW5nZSB0b29rIHBsYWNlLiBSZW1vdmVzIHNwYW5zXFxuLy8gZW50aXJlbHkgd2l0aGluIHRoZSBjaGFuZ2UsIHJlY29ubmVjdHMgc3BhbnMgYmVsb25naW5nIHRvIHRoZVxcbi8vIHNhbWUgbWFya2VyIHRoYXQgYXBwZWFyIG9uIGJvdGggc2lkZXMgb2YgdGhlIGNoYW5nZSwgYW5kIGN1dHMgb2ZmXFxuLy8gc3BhbnMgcGFydGlhbGx5IHdpdGhpbiB0aGUgY2hhbmdlLiBSZXR1cm5zIGFuIGFycmF5IG9mIHNwYW5cXG4vLyBhcnJheXMgd2l0aCBvbmUgZWxlbWVudCBmb3IgZWFjaCBsaW5lIGluIChhZnRlcikgdGhlIGNoYW5nZS5cXG5mdW5jdGlvbiBzdHJldGNoU3BhbnNPdmVyQ2hhbmdlKGRvYywgY2hhbmdlKSB7XFxuICBpZiAoY2hhbmdlLmZ1bGwpIHsgcmV0dXJuIG51bGwgfVxcbiAgdmFyIG9sZEZpcnN0ID0gaXNMaW5lKGRvYywgY2hhbmdlLmZyb20ubGluZSkgJiYgZ2V0TGluZShkb2MsIGNoYW5nZS5mcm9tLmxpbmUpLm1hcmtlZFNwYW5zXFxuICB2YXIgb2xkTGFzdCA9IGlzTGluZShkb2MsIGNoYW5nZS50by5saW5lKSAmJiBnZXRMaW5lKGRvYywgY2hhbmdlLnRvLmxpbmUpLm1hcmtlZFNwYW5zXFxuICBpZiAoIW9sZEZpcnN0ICYmICFvbGRMYXN0KSB7IHJldHVybiBudWxsIH1cXG5cXG4gIHZhciBzdGFydENoID0gY2hhbmdlLmZyb20uY2gsIGVuZENoID0gY2hhbmdlLnRvLmNoLCBpc0luc2VydCA9IGNtcChjaGFuZ2UuZnJvbSwgY2hhbmdlLnRvKSA9PSAwXFxuICAvLyBHZXQgdGhlIHNwYW5zIHRoYXQgJ3N0aWNrIG91dCcgb24gYm90aCBzaWRlc1xcbiAgdmFyIGZpcnN0ID0gbWFya2VkU3BhbnNCZWZvcmUob2xkRmlyc3QsIHN0YXJ0Q2gsIGlzSW5zZXJ0KVxcbiAgdmFyIGxhc3QgPSBtYXJrZWRTcGFuc0FmdGVyKG9sZExhc3QsIGVuZENoLCBpc0luc2VydClcXG5cXG4gIC8vIE5leHQsIG1lcmdlIHRob3NlIHR3byBlbmRzXFxuICB2YXIgc2FtZUxpbmUgPSBjaGFuZ2UudGV4dC5sZW5ndGggPT0gMSwgb2Zmc2V0ID0gbHN0KGNoYW5nZS50ZXh0KS5sZW5ndGggKyAoc2FtZUxpbmUgPyBzdGFydENoIDogMClcXG4gIGlmIChmaXJzdCkge1xcbiAgICAvLyBGaXggdXAgLnRvIHByb3BlcnRpZXMgb2YgZmlyc3RcXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmaXJzdC5sZW5ndGg7ICsraSkge1xcbiAgICAgIHZhciBzcGFuID0gZmlyc3RbaV1cXG4gICAgICBpZiAoc3Bhbi50byA9PSBudWxsKSB7XFxuICAgICAgICB2YXIgZm91bmQgPSBnZXRNYXJrZWRTcGFuRm9yKGxhc3QsIHNwYW4ubWFya2VyKVxcbiAgICAgICAgaWYgKCFmb3VuZCkgeyBzcGFuLnRvID0gc3RhcnRDaCB9XFxuICAgICAgICBlbHNlIGlmIChzYW1lTGluZSkgeyBzcGFuLnRvID0gZm91bmQudG8gPT0gbnVsbCA/IG51bGwgOiBmb3VuZC50byArIG9mZnNldCB9XFxuICAgICAgfVxcbiAgICB9XFxuICB9XFxuICBpZiAobGFzdCkge1xcbiAgICAvLyBGaXggdXAgLmZyb20gaW4gbGFzdCAob3IgbW92ZSB0aGVtIGludG8gZmlyc3QgaW4gY2FzZSBvZiBzYW1lTGluZSlcXG4gICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgbGFzdC5sZW5ndGg7ICsraSQxKSB7XFxuICAgICAgdmFyIHNwYW4kMSA9IGxhc3RbaSQxXVxcbiAgICAgIGlmIChzcGFuJDEudG8gIT0gbnVsbCkgeyBzcGFuJDEudG8gKz0gb2Zmc2V0IH1cXG4gICAgICBpZiAoc3BhbiQxLmZyb20gPT0gbnVsbCkge1xcbiAgICAgICAgdmFyIGZvdW5kJDEgPSBnZXRNYXJrZWRTcGFuRm9yKGZpcnN0LCBzcGFuJDEubWFya2VyKVxcbiAgICAgICAgaWYgKCFmb3VuZCQxKSB7XFxuICAgICAgICAgIHNwYW4kMS5mcm9tID0gb2Zmc2V0XFxuICAgICAgICAgIGlmIChzYW1lTGluZSkgeyAoZmlyc3QgfHwgKGZpcnN0ID0gW10pKS5wdXNoKHNwYW4kMSkgfVxcbiAgICAgICAgfVxcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBzcGFuJDEuZnJvbSArPSBvZmZzZXRcXG4gICAgICAgIGlmIChzYW1lTGluZSkgeyAoZmlyc3QgfHwgKGZpcnN0ID0gW10pKS5wdXNoKHNwYW4kMSkgfVxcbiAgICAgIH1cXG4gICAgfVxcbiAgfVxcbiAgLy8gTWFrZSBzdXJlIHdlIGRpZG4ndCBjcmVhdGUgYW55IHplcm8tbGVuZ3RoIHNwYW5zXFxuICBpZiAoZmlyc3QpIHsgZmlyc3QgPSBjbGVhckVtcHR5U3BhbnMoZmlyc3QpIH1cXG4gIGlmIChsYXN0ICYmIGxhc3QgIT0gZmlyc3QpIHsgbGFzdCA9IGNsZWFyRW1wdHlTcGFucyhsYXN0KSB9XFxuXFxuICB2YXIgbmV3TWFya2VycyA9IFtmaXJzdF1cXG4gIGlmICghc2FtZUxpbmUpIHtcXG4gICAgLy8gRmlsbCBnYXAgd2l0aCB3aG9sZS1saW5lLXNwYW5zXFxuICAgIHZhciBnYXAgPSBjaGFuZ2UudGV4dC5sZW5ndGggLSAyLCBnYXBNYXJrZXJzXFxuICAgIGlmIChnYXAgPiAwICYmIGZpcnN0KVxcbiAgICAgIHsgZm9yICh2YXIgaSQyID0gMDsgaSQyIDwgZmlyc3QubGVuZ3RoOyArK2kkMilcXG4gICAgICAgIHsgaWYgKGZpcnN0W2kkMl0udG8gPT0gbnVsbClcXG4gICAgICAgICAgeyAoZ2FwTWFya2VycyB8fCAoZ2FwTWFya2VycyA9IFtdKSkucHVzaChuZXcgTWFya2VkU3BhbihmaXJzdFtpJDJdLm1hcmtlciwgbnVsbCwgbnVsbCkpIH0gfSB9XFxuICAgIGZvciAodmFyIGkkMyA9IDA7IGkkMyA8IGdhcDsgKytpJDMpXFxuICAgICAgeyBuZXdNYXJrZXJzLnB1c2goZ2FwTWFya2VycykgfVxcbiAgICBuZXdNYXJrZXJzLnB1c2gobGFzdClcXG4gIH1cXG4gIHJldHVybiBuZXdNYXJrZXJzXFxufVxcblxcbi8vIFJlbW92ZSBzcGFucyB0aGF0IGFyZSBlbXB0eSBhbmQgZG9uJ3QgaGF2ZSBhIGNsZWFyV2hlbkVtcHR5XFxuLy8gb3B0aW9uIG9mIGZhbHNlLlxcbmZ1bmN0aW9uIGNsZWFyRW1wdHlTcGFucyhzcGFucykge1xcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzcGFucy5sZW5ndGg7ICsraSkge1xcbiAgICB2YXIgc3BhbiA9IHNwYW5zW2ldXFxuICAgIGlmIChzcGFuLmZyb20gIT0gbnVsbCAmJiBzcGFuLmZyb20gPT0gc3Bhbi50byAmJiBzcGFuLm1hcmtlci5jbGVhcldoZW5FbXB0eSAhPT0gZmFsc2UpXFxuICAgICAgeyBzcGFucy5zcGxpY2UoaS0tLCAxKSB9XFxuICB9XFxuICBpZiAoIXNwYW5zLmxlbmd0aCkgeyByZXR1cm4gbnVsbCB9XFxuICByZXR1cm4gc3BhbnNcXG59XFxuXFxuLy8gVXNlZCB0byAnY2xpcCcgb3V0IHJlYWRPbmx5IHJhbmdlcyB3aGVuIG1ha2luZyBhIGNoYW5nZS5cXG5mdW5jdGlvbiByZW1vdmVSZWFkT25seVJhbmdlcyhkb2MsIGZyb20sIHRvKSB7XFxuICB2YXIgbWFya2VycyA9IG51bGxcXG4gIGRvYy5pdGVyKGZyb20ubGluZSwgdG8ubGluZSArIDEsIGZ1bmN0aW9uIChsaW5lKSB7XFxuICAgIGlmIChsaW5lLm1hcmtlZFNwYW5zKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgbGluZS5tYXJrZWRTcGFucy5sZW5ndGg7ICsraSkge1xcbiAgICAgIHZhciBtYXJrID0gbGluZS5tYXJrZWRTcGFuc1tpXS5tYXJrZXJcXG4gICAgICBpZiAobWFyay5yZWFkT25seSAmJiAoIW1hcmtlcnMgfHwgaW5kZXhPZihtYXJrZXJzLCBtYXJrKSA9PSAtMSkpXFxuICAgICAgICB7IChtYXJrZXJzIHx8IChtYXJrZXJzID0gW10pKS5wdXNoKG1hcmspIH1cXG4gICAgfSB9XFxuICB9KVxcbiAgaWYgKCFtYXJrZXJzKSB7IHJldHVybiBudWxsIH1cXG4gIHZhciBwYXJ0cyA9IFt7ZnJvbTogZnJvbSwgdG86IHRvfV1cXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbWFya2Vycy5sZW5ndGg7ICsraSkge1xcbiAgICB2YXIgbWsgPSBtYXJrZXJzW2ldLCBtID0gbWsuZmluZCgwKVxcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IHBhcnRzLmxlbmd0aDsgKytqKSB7XFxuICAgICAgdmFyIHAgPSBwYXJ0c1tqXVxcbiAgICAgIGlmIChjbXAocC50bywgbS5mcm9tKSA8IDAgfHwgY21wKHAuZnJvbSwgbS50bykgPiAwKSB7IGNvbnRpbnVlIH1cXG4gICAgICB2YXIgbmV3UGFydHMgPSBbaiwgMV0sIGRmcm9tID0gY21wKHAuZnJvbSwgbS5mcm9tKSwgZHRvID0gY21wKHAudG8sIG0udG8pXFxuICAgICAgaWYgKGRmcm9tIDwgMCB8fCAhbWsuaW5jbHVzaXZlTGVmdCAmJiAhZGZyb20pXFxuICAgICAgICB7IG5ld1BhcnRzLnB1c2goe2Zyb206IHAuZnJvbSwgdG86IG0uZnJvbX0pIH1cXG4gICAgICBpZiAoZHRvID4gMCB8fCAhbWsuaW5jbHVzaXZlUmlnaHQgJiYgIWR0bylcXG4gICAgICAgIHsgbmV3UGFydHMucHVzaCh7ZnJvbTogbS50bywgdG86IHAudG99KSB9XFxuICAgICAgcGFydHMuc3BsaWNlLmFwcGx5KHBhcnRzLCBuZXdQYXJ0cylcXG4gICAgICBqICs9IG5ld1BhcnRzLmxlbmd0aCAtIDNcXG4gICAgfVxcbiAgfVxcbiAgcmV0dXJuIHBhcnRzXFxufVxcblxcbi8vIENvbm5lY3Qgb3IgZGlzY29ubmVjdCBzcGFucyBmcm9tIGEgbGluZS5cXG5mdW5jdGlvbiBkZXRhY2hNYXJrZWRTcGFucyhsaW5lKSB7XFxuICB2YXIgc3BhbnMgPSBsaW5lLm1hcmtlZFNwYW5zXFxuICBpZiAoIXNwYW5zKSB7IHJldHVybiB9XFxuICBmb3IgKHZhciBpID0gMDsgaSA8IHNwYW5zLmxlbmd0aDsgKytpKVxcbiAgICB7IHNwYW5zW2ldLm1hcmtlci5kZXRhY2hMaW5lKGxpbmUpIH1cXG4gIGxpbmUubWFya2VkU3BhbnMgPSBudWxsXFxufVxcbmZ1bmN0aW9uIGF0dGFjaE1hcmtlZFNwYW5zKGxpbmUsIHNwYW5zKSB7XFxuICBpZiAoIXNwYW5zKSB7IHJldHVybiB9XFxuICBmb3IgKHZhciBpID0gMDsgaSA8IHNwYW5zLmxlbmd0aDsgKytpKVxcbiAgICB7IHNwYW5zW2ldLm1hcmtlci5hdHRhY2hMaW5lKGxpbmUpIH1cXG4gIGxpbmUubWFya2VkU3BhbnMgPSBzcGFuc1xcbn1cXG5cXG4vLyBIZWxwZXJzIHVzZWQgd2hlbiBjb21wdXRpbmcgd2hpY2ggb3ZlcmxhcHBpbmcgY29sbGFwc2VkIHNwYW5cXG4vLyBjb3VudHMgYXMgdGhlIGxhcmdlciBvbmUuXFxuZnVuY3Rpb24gZXh0cmFMZWZ0KG1hcmtlcikgeyByZXR1cm4gbWFya2VyLmluY2x1c2l2ZUxlZnQgPyAtMSA6IDAgfVxcbmZ1bmN0aW9uIGV4dHJhUmlnaHQobWFya2VyKSB7IHJldHVybiBtYXJrZXIuaW5jbHVzaXZlUmlnaHQgPyAxIDogMCB9XFxuXFxuLy8gUmV0dXJucyBhIG51bWJlciBpbmRpY2F0aW5nIHdoaWNoIG9mIHR3byBvdmVybGFwcGluZyBjb2xsYXBzZWRcXG4vLyBzcGFucyBpcyBsYXJnZXIgKGFuZCB0aHVzIGluY2x1ZGVzIHRoZSBvdGhlcikuIEZhbGxzIGJhY2sgdG9cXG4vLyBjb21wYXJpbmcgaWRzIHdoZW4gdGhlIHNwYW5zIGNvdmVyIGV4YWN0bHkgdGhlIHNhbWUgcmFuZ2UuXFxuZnVuY3Rpb24gY29tcGFyZUNvbGxhcHNlZE1hcmtlcnMoYSwgYikge1xcbiAgdmFyIGxlbkRpZmYgPSBhLmxpbmVzLmxlbmd0aCAtIGIubGluZXMubGVuZ3RoXFxuICBpZiAobGVuRGlmZiAhPSAwKSB7IHJldHVybiBsZW5EaWZmIH1cXG4gIHZhciBhUG9zID0gYS5maW5kKCksIGJQb3MgPSBiLmZpbmQoKVxcbiAgdmFyIGZyb21DbXAgPSBjbXAoYVBvcy5mcm9tLCBiUG9zLmZyb20pIHx8IGV4dHJhTGVmdChhKSAtIGV4dHJhTGVmdChiKVxcbiAgaWYgKGZyb21DbXApIHsgcmV0dXJuIC1mcm9tQ21wIH1cXG4gIHZhciB0b0NtcCA9IGNtcChhUG9zLnRvLCBiUG9zLnRvKSB8fCBleHRyYVJpZ2h0KGEpIC0gZXh0cmFSaWdodChiKVxcbiAgaWYgKHRvQ21wKSB7IHJldHVybiB0b0NtcCB9XFxuICByZXR1cm4gYi5pZCAtIGEuaWRcXG59XFxuXFxuLy8gRmluZCBvdXQgd2hldGhlciBhIGxpbmUgZW5kcyBvciBzdGFydHMgaW4gYSBjb2xsYXBzZWQgc3Bhbi4gSWZcXG4vLyBzbywgcmV0dXJuIHRoZSBtYXJrZXIgZm9yIHRoYXQgc3Bhbi5cXG5mdW5jdGlvbiBjb2xsYXBzZWRTcGFuQXRTaWRlKGxpbmUsIHN0YXJ0KSB7XFxuICB2YXIgc3BzID0gc2F3Q29sbGFwc2VkU3BhbnMgJiYgbGluZS5tYXJrZWRTcGFucywgZm91bmRcXG4gIGlmIChzcHMpIHsgZm9yICh2YXIgc3AgPSAodm9pZCAwKSwgaSA9IDA7IGkgPCBzcHMubGVuZ3RoOyArK2kpIHtcXG4gICAgc3AgPSBzcHNbaV1cXG4gICAgaWYgKHNwLm1hcmtlci5jb2xsYXBzZWQgJiYgKHN0YXJ0ID8gc3AuZnJvbSA6IHNwLnRvKSA9PSBudWxsICYmXFxuICAgICAgICAoIWZvdW5kIHx8IGNvbXBhcmVDb2xsYXBzZWRNYXJrZXJzKGZvdW5kLCBzcC5tYXJrZXIpIDwgMCkpXFxuICAgICAgeyBmb3VuZCA9IHNwLm1hcmtlciB9XFxuICB9IH1cXG4gIHJldHVybiBmb3VuZFxcbn1cXG5mdW5jdGlvbiBjb2xsYXBzZWRTcGFuQXRTdGFydChsaW5lKSB7IHJldHVybiBjb2xsYXBzZWRTcGFuQXRTaWRlKGxpbmUsIHRydWUpIH1cXG5mdW5jdGlvbiBjb2xsYXBzZWRTcGFuQXRFbmQobGluZSkgeyByZXR1cm4gY29sbGFwc2VkU3BhbkF0U2lkZShsaW5lLCBmYWxzZSkgfVxcblxcbi8vIFRlc3Qgd2hldGhlciB0aGVyZSBleGlzdHMgYSBjb2xsYXBzZWQgc3BhbiB0aGF0IHBhcnRpYWxseVxcbi8vIG92ZXJsYXBzIChjb3ZlcnMgdGhlIHN0YXJ0IG9yIGVuZCwgYnV0IG5vdCBib3RoKSBvZiBhIG5ldyBzcGFuLlxcbi8vIFN1Y2ggb3ZlcmxhcCBpcyBub3QgYWxsb3dlZC5cXG5mdW5jdGlvbiBjb25mbGljdGluZ0NvbGxhcHNlZFJhbmdlKGRvYywgbGluZU5vLCBmcm9tLCB0bywgbWFya2VyKSB7XFxuICB2YXIgbGluZSA9IGdldExpbmUoZG9jLCBsaW5lTm8pXFxuICB2YXIgc3BzID0gc2F3Q29sbGFwc2VkU3BhbnMgJiYgbGluZS5tYXJrZWRTcGFuc1xcbiAgaWYgKHNwcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHNwcy5sZW5ndGg7ICsraSkge1xcbiAgICB2YXIgc3AgPSBzcHNbaV1cXG4gICAgaWYgKCFzcC5tYXJrZXIuY29sbGFwc2VkKSB7IGNvbnRpbnVlIH1cXG4gICAgdmFyIGZvdW5kID0gc3AubWFya2VyLmZpbmQoMClcXG4gICAgdmFyIGZyb21DbXAgPSBjbXAoZm91bmQuZnJvbSwgZnJvbSkgfHwgZXh0cmFMZWZ0KHNwLm1hcmtlcikgLSBleHRyYUxlZnQobWFya2VyKVxcbiAgICB2YXIgdG9DbXAgPSBjbXAoZm91bmQudG8sIHRvKSB8fCBleHRyYVJpZ2h0KHNwLm1hcmtlcikgLSBleHRyYVJpZ2h0KG1hcmtlcilcXG4gICAgaWYgKGZyb21DbXAgPj0gMCAmJiB0b0NtcCA8PSAwIHx8IGZyb21DbXAgPD0gMCAmJiB0b0NtcCA+PSAwKSB7IGNvbnRpbnVlIH1cXG4gICAgaWYgKGZyb21DbXAgPD0gMCAmJiAoc3AubWFya2VyLmluY2x1c2l2ZVJpZ2h0ICYmIG1hcmtlci5pbmNsdXNpdmVMZWZ0ID8gY21wKGZvdW5kLnRvLCBmcm9tKSA+PSAwIDogY21wKGZvdW5kLnRvLCBmcm9tKSA+IDApIHx8XFxuICAgICAgICBmcm9tQ21wID49IDAgJiYgKHNwLm1hcmtlci5pbmNsdXNpdmVSaWdodCAmJiBtYXJrZXIuaW5jbHVzaXZlTGVmdCA/IGNtcChmb3VuZC5mcm9tLCB0bykgPD0gMCA6IGNtcChmb3VuZC5mcm9tLCB0bykgPCAwKSlcXG4gICAgICB7IHJldHVybiB0cnVlIH1cXG4gIH0gfVxcbn1cXG5cXG4vLyBBIHZpc3VhbCBsaW5lIGlzIGEgbGluZSBhcyBkcmF3biBvbiB0aGUgc2NyZWVuLiBGb2xkaW5nLCBmb3JcXG4vLyBleGFtcGxlLCBjYW4gY2F1c2UgbXVsdGlwbGUgbG9naWNhbCBsaW5lcyB0byBhcHBlYXIgb24gdGhlIHNhbWVcXG4vLyB2aXN1YWwgbGluZS4gVGhpcyBmaW5kcyB0aGUgc3RhcnQgb2YgdGhlIHZpc3VhbCBsaW5lIHRoYXQgdGhlXFxuLy8gZ2l2ZW4gbGluZSBpcyBwYXJ0IG9mICh1c3VhbGx5IHRoYXQgaXMgdGhlIGxpbmUgaXRzZWxmKS5cXG5mdW5jdGlvbiB2aXN1YWxMaW5lKGxpbmUpIHtcXG4gIHZhciBtZXJnZWRcXG4gIHdoaWxlIChtZXJnZWQgPSBjb2xsYXBzZWRTcGFuQXRTdGFydChsaW5lKSlcXG4gICAgeyBsaW5lID0gbWVyZ2VkLmZpbmQoLTEsIHRydWUpLmxpbmUgfVxcbiAgcmV0dXJuIGxpbmVcXG59XFxuXFxuZnVuY3Rpb24gdmlzdWFsTGluZUVuZChsaW5lKSB7XFxuICB2YXIgbWVyZ2VkXFxuICB3aGlsZSAobWVyZ2VkID0gY29sbGFwc2VkU3BhbkF0RW5kKGxpbmUpKVxcbiAgICB7IGxpbmUgPSBtZXJnZWQuZmluZCgxLCB0cnVlKS5saW5lIH1cXG4gIHJldHVybiBsaW5lXFxufVxcblxcbi8vIFJldHVybnMgYW4gYXJyYXkgb2YgbG9naWNhbCBsaW5lcyB0aGF0IGNvbnRpbnVlIHRoZSB2aXN1YWwgbGluZVxcbi8vIHN0YXJ0ZWQgYnkgdGhlIGFyZ3VtZW50LCBvciB1bmRlZmluZWQgaWYgdGhlcmUgYXJlIG5vIHN1Y2ggbGluZXMuXFxuZnVuY3Rpb24gdmlzdWFsTGluZUNvbnRpbnVlZChsaW5lKSB7XFxuICB2YXIgbWVyZ2VkLCBsaW5lc1xcbiAgd2hpbGUgKG1lcmdlZCA9IGNvbGxhcHNlZFNwYW5BdEVuZChsaW5lKSkge1xcbiAgICBsaW5lID0gbWVyZ2VkLmZpbmQoMSwgdHJ1ZSkubGluZVxcbiAgICA7KGxpbmVzIHx8IChsaW5lcyA9IFtdKSkucHVzaChsaW5lKVxcbiAgfVxcbiAgcmV0dXJuIGxpbmVzXFxufVxcblxcbi8vIEdldCB0aGUgbGluZSBudW1iZXIgb2YgdGhlIHN0YXJ0IG9mIHRoZSB2aXN1YWwgbGluZSB0aGF0IHRoZVxcbi8vIGdpdmVuIGxpbmUgbnVtYmVyIGlzIHBhcnQgb2YuXFxuZnVuY3Rpb24gdmlzdWFsTGluZU5vKGRvYywgbGluZU4pIHtcXG4gIHZhciBsaW5lID0gZ2V0TGluZShkb2MsIGxpbmVOKSwgdmlzID0gdmlzdWFsTGluZShsaW5lKVxcbiAgaWYgKGxpbmUgPT0gdmlzKSB7IHJldHVybiBsaW5lTiB9XFxuICByZXR1cm4gbGluZU5vKHZpcylcXG59XFxuXFxuLy8gR2V0IHRoZSBsaW5lIG51bWJlciBvZiB0aGUgc3RhcnQgb2YgdGhlIG5leHQgdmlzdWFsIGxpbmUgYWZ0ZXJcXG4vLyB0aGUgZ2l2ZW4gbGluZS5cXG5mdW5jdGlvbiB2aXN1YWxMaW5lRW5kTm8oZG9jLCBsaW5lTikge1xcbiAgaWYgKGxpbmVOID4gZG9jLmxhc3RMaW5lKCkpIHsgcmV0dXJuIGxpbmVOIH1cXG4gIHZhciBsaW5lID0gZ2V0TGluZShkb2MsIGxpbmVOKSwgbWVyZ2VkXFxuICBpZiAoIWxpbmVJc0hpZGRlbihkb2MsIGxpbmUpKSB7IHJldHVybiBsaW5lTiB9XFxuICB3aGlsZSAobWVyZ2VkID0gY29sbGFwc2VkU3BhbkF0RW5kKGxpbmUpKVxcbiAgICB7IGxpbmUgPSBtZXJnZWQuZmluZCgxLCB0cnVlKS5saW5lIH1cXG4gIHJldHVybiBsaW5lTm8obGluZSkgKyAxXFxufVxcblxcbi8vIENvbXB1dGUgd2hldGhlciBhIGxpbmUgaXMgaGlkZGVuLiBMaW5lcyBjb3VudCBhcyBoaWRkZW4gd2hlbiB0aGV5XFxuLy8gYXJlIHBhcnQgb2YgYSB2aXN1YWwgbGluZSB0aGF0IHN0YXJ0cyB3aXRoIGFub3RoZXIgbGluZSwgb3Igd2hlblxcbi8vIHRoZXkgYXJlIGVudGlyZWx5IGNvdmVyZWQgYnkgY29sbGFwc2VkLCBub24td2lkZ2V0IHNwYW4uXFxuZnVuY3Rpb24gbGluZUlzSGlkZGVuKGRvYywgbGluZSkge1xcbiAgdmFyIHNwcyA9IHNhd0NvbGxhcHNlZFNwYW5zICYmIGxpbmUubWFya2VkU3BhbnNcXG4gIGlmIChzcHMpIHsgZm9yICh2YXIgc3AgPSAodm9pZCAwKSwgaSA9IDA7IGkgPCBzcHMubGVuZ3RoOyArK2kpIHtcXG4gICAgc3AgPSBzcHNbaV1cXG4gICAgaWYgKCFzcC5tYXJrZXIuY29sbGFwc2VkKSB7IGNvbnRpbnVlIH1cXG4gICAgaWYgKHNwLmZyb20gPT0gbnVsbCkgeyByZXR1cm4gdHJ1ZSB9XFxuICAgIGlmIChzcC5tYXJrZXIud2lkZ2V0Tm9kZSkgeyBjb250aW51ZSB9XFxuICAgIGlmIChzcC5mcm9tID09IDAgJiYgc3AubWFya2VyLmluY2x1c2l2ZUxlZnQgJiYgbGluZUlzSGlkZGVuSW5uZXIoZG9jLCBsaW5lLCBzcCkpXFxuICAgICAgeyByZXR1cm4gdHJ1ZSB9XFxuICB9IH1cXG59XFxuZnVuY3Rpb24gbGluZUlzSGlkZGVuSW5uZXIoZG9jLCBsaW5lLCBzcGFuKSB7XFxuICBpZiAoc3Bhbi50byA9PSBudWxsKSB7XFxuICAgIHZhciBlbmQgPSBzcGFuLm1hcmtlci5maW5kKDEsIHRydWUpXFxuICAgIHJldHVybiBsaW5lSXNIaWRkZW5Jbm5lcihkb2MsIGVuZC5saW5lLCBnZXRNYXJrZWRTcGFuRm9yKGVuZC5saW5lLm1hcmtlZFNwYW5zLCBzcGFuLm1hcmtlcikpXFxuICB9XFxuICBpZiAoc3Bhbi5tYXJrZXIuaW5jbHVzaXZlUmlnaHQgJiYgc3Bhbi50byA9PSBsaW5lLnRleHQubGVuZ3RoKVxcbiAgICB7IHJldHVybiB0cnVlIH1cXG4gIGZvciAodmFyIHNwID0gKHZvaWQgMCksIGkgPSAwOyBpIDwgbGluZS5tYXJrZWRTcGFucy5sZW5ndGg7ICsraSkge1xcbiAgICBzcCA9IGxpbmUubWFya2VkU3BhbnNbaV1cXG4gICAgaWYgKHNwLm1hcmtlci5jb2xsYXBzZWQgJiYgIXNwLm1hcmtlci53aWRnZXROb2RlICYmIHNwLmZyb20gPT0gc3Bhbi50byAmJlxcbiAgICAgICAgKHNwLnRvID09IG51bGwgfHwgc3AudG8gIT0gc3Bhbi5mcm9tKSAmJlxcbiAgICAgICAgKHNwLm1hcmtlci5pbmNsdXNpdmVMZWZ0IHx8IHNwYW4ubWFya2VyLmluY2x1c2l2ZVJpZ2h0KSAmJlxcbiAgICAgICAgbGluZUlzSGlkZGVuSW5uZXIoZG9jLCBsaW5lLCBzcCkpIHsgcmV0dXJuIHRydWUgfVxcbiAgfVxcbn1cXG5cXG4vLyBGaW5kIHRoZSBoZWlnaHQgYWJvdmUgdGhlIGdpdmVuIGxpbmUuXFxuZnVuY3Rpb24gaGVpZ2h0QXRMaW5lKGxpbmVPYmopIHtcXG4gIGxpbmVPYmogPSB2aXN1YWxMaW5lKGxpbmVPYmopXFxuXFxuICB2YXIgaCA9IDAsIGNodW5rID0gbGluZU9iai5wYXJlbnRcXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY2h1bmsubGluZXMubGVuZ3RoOyArK2kpIHtcXG4gICAgdmFyIGxpbmUgPSBjaHVuay5saW5lc1tpXVxcbiAgICBpZiAobGluZSA9PSBsaW5lT2JqKSB7IGJyZWFrIH1cXG4gICAgZWxzZSB7IGggKz0gbGluZS5oZWlnaHQgfVxcbiAgfVxcbiAgZm9yICh2YXIgcCA9IGNodW5rLnBhcmVudDsgcDsgY2h1bmsgPSBwLCBwID0gY2h1bmsucGFyZW50KSB7XFxuICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IHAuY2hpbGRyZW4ubGVuZ3RoOyArK2kkMSkge1xcbiAgICAgIHZhciBjdXIgPSBwLmNoaWxkcmVuW2kkMV1cXG4gICAgICBpZiAoY3VyID09IGNodW5rKSB7IGJyZWFrIH1cXG4gICAgICBlbHNlIHsgaCArPSBjdXIuaGVpZ2h0IH1cXG4gICAgfVxcbiAgfVxcbiAgcmV0dXJuIGhcXG59XFxuXFxuLy8gQ29tcHV0ZSB0aGUgY2hhcmFjdGVyIGxlbmd0aCBvZiBhIGxpbmUsIHRha2luZyBpbnRvIGFjY291bnRcXG4vLyBjb2xsYXBzZWQgcmFuZ2VzIChzZWUgbWFya1RleHQpIHRoYXQgbWlnaHQgaGlkZSBwYXJ0cywgYW5kIGpvaW5cXG4vLyBvdGhlciBsaW5lcyBvbnRvIGl0LlxcbmZ1bmN0aW9uIGxpbmVMZW5ndGgobGluZSkge1xcbiAgaWYgKGxpbmUuaGVpZ2h0ID09IDApIHsgcmV0dXJuIDAgfVxcbiAgdmFyIGxlbiA9IGxpbmUudGV4dC5sZW5ndGgsIG1lcmdlZCwgY3VyID0gbGluZVxcbiAgd2hpbGUgKG1lcmdlZCA9IGNvbGxhcHNlZFNwYW5BdFN0YXJ0KGN1cikpIHtcXG4gICAgdmFyIGZvdW5kID0gbWVyZ2VkLmZpbmQoMCwgdHJ1ZSlcXG4gICAgY3VyID0gZm91bmQuZnJvbS5saW5lXFxuICAgIGxlbiArPSBmb3VuZC5mcm9tLmNoIC0gZm91bmQudG8uY2hcXG4gIH1cXG4gIGN1ciA9IGxpbmVcXG4gIHdoaWxlIChtZXJnZWQgPSBjb2xsYXBzZWRTcGFuQXRFbmQoY3VyKSkge1xcbiAgICB2YXIgZm91bmQkMSA9IG1lcmdlZC5maW5kKDAsIHRydWUpXFxuICAgIGxlbiAtPSBjdXIudGV4dC5sZW5ndGggLSBmb3VuZCQxLmZyb20uY2hcXG4gICAgY3VyID0gZm91bmQkMS50by5saW5lXFxuICAgIGxlbiArPSBjdXIudGV4dC5sZW5ndGggLSBmb3VuZCQxLnRvLmNoXFxuICB9XFxuICByZXR1cm4gbGVuXFxufVxcblxcbi8vIEZpbmQgdGhlIGxvbmdlc3QgbGluZSBpbiB0aGUgZG9jdW1lbnQuXFxuZnVuY3Rpb24gZmluZE1heExpbmUoY20pIHtcXG4gIHZhciBkID0gY20uZGlzcGxheSwgZG9jID0gY20uZG9jXFxuICBkLm1heExpbmUgPSBnZXRMaW5lKGRvYywgZG9jLmZpcnN0KVxcbiAgZC5tYXhMaW5lTGVuZ3RoID0gbGluZUxlbmd0aChkLm1heExpbmUpXFxuICBkLm1heExpbmVDaGFuZ2VkID0gdHJ1ZVxcbiAgZG9jLml0ZXIoZnVuY3Rpb24gKGxpbmUpIHtcXG4gICAgdmFyIGxlbiA9IGxpbmVMZW5ndGgobGluZSlcXG4gICAgaWYgKGxlbiA+IGQubWF4TGluZUxlbmd0aCkge1xcbiAgICAgIGQubWF4TGluZUxlbmd0aCA9IGxlblxcbiAgICAgIGQubWF4TGluZSA9IGxpbmVcXG4gICAgfVxcbiAgfSlcXG59XFxuXFxuLy8gQklESSBIRUxQRVJTXFxuXFxuZnVuY3Rpb24gaXRlcmF0ZUJpZGlTZWN0aW9ucyhvcmRlciwgZnJvbSwgdG8sIGYpIHtcXG4gIGlmICghb3JkZXIpIHsgcmV0dXJuIGYoZnJvbSwgdG8sIFxcXCJsdHJcXFwiKSB9XFxuICB2YXIgZm91bmQgPSBmYWxzZVxcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcmRlci5sZW5ndGg7ICsraSkge1xcbiAgICB2YXIgcGFydCA9IG9yZGVyW2ldXFxuICAgIGlmIChwYXJ0LmZyb20gPCB0byAmJiBwYXJ0LnRvID4gZnJvbSB8fCBmcm9tID09IHRvICYmIHBhcnQudG8gPT0gZnJvbSkge1xcbiAgICAgIGYoTWF0aC5tYXgocGFydC5mcm9tLCBmcm9tKSwgTWF0aC5taW4ocGFydC50bywgdG8pLCBwYXJ0LmxldmVsID09IDEgPyBcXFwicnRsXFxcIiA6IFxcXCJsdHJcXFwiKVxcbiAgICAgIGZvdW5kID0gdHJ1ZVxcbiAgICB9XFxuICB9XFxuICBpZiAoIWZvdW5kKSB7IGYoZnJvbSwgdG8sIFxcXCJsdHJcXFwiKSB9XFxufVxcblxcbnZhciBiaWRpT3RoZXIgPSBudWxsXFxuZnVuY3Rpb24gZ2V0QmlkaVBhcnRBdChvcmRlciwgY2gsIHN0aWNreSkge1xcbiAgdmFyIGZvdW5kXFxuICBiaWRpT3RoZXIgPSBudWxsXFxuICBmb3IgKHZhciBpID0gMDsgaSA8IG9yZGVyLmxlbmd0aDsgKytpKSB7XFxuICAgIHZhciBjdXIgPSBvcmRlcltpXVxcbiAgICBpZiAoY3VyLmZyb20gPCBjaCAmJiBjdXIudG8gPiBjaCkgeyByZXR1cm4gaSB9XFxuICAgIGlmIChjdXIudG8gPT0gY2gpIHtcXG4gICAgICBpZiAoY3VyLmZyb20gIT0gY3VyLnRvICYmIHN0aWNreSA9PSBcXFwiYmVmb3JlXFxcIikgeyBmb3VuZCA9IGkgfVxcbiAgICAgIGVsc2UgeyBiaWRpT3RoZXIgPSBpIH1cXG4gICAgfVxcbiAgICBpZiAoY3VyLmZyb20gPT0gY2gpIHtcXG4gICAgICBpZiAoY3VyLmZyb20gIT0gY3VyLnRvICYmIHN0aWNreSAhPSBcXFwiYmVmb3JlXFxcIikgeyBmb3VuZCA9IGkgfVxcbiAgICAgIGVsc2UgeyBiaWRpT3RoZXIgPSBpIH1cXG4gICAgfVxcbiAgfVxcbiAgcmV0dXJuIGZvdW5kICE9IG51bGwgPyBmb3VuZCA6IGJpZGlPdGhlclxcbn1cXG5cXG4vLyBCaWRpcmVjdGlvbmFsIG9yZGVyaW5nIGFsZ29yaXRobVxcbi8vIFNlZSBodHRwOi8vdW5pY29kZS5vcmcvcmVwb3J0cy90cjkvdHI5LTEzLmh0bWwgZm9yIHRoZSBhbGdvcml0aG1cXG4vLyB0aGF0IHRoaXMgKHBhcnRpYWxseSkgaW1wbGVtZW50cy5cXG5cXG4vLyBPbmUtY2hhciBjb2RlcyB1c2VkIGZvciBjaGFyYWN0ZXIgdHlwZXM6XFxuLy8gTCAoTCk6ICAgTGVmdC10by1SaWdodFxcbi8vIFIgKFIpOiAgIFJpZ2h0LXRvLUxlZnRcXG4vLyByIChBTCk6ICBSaWdodC10by1MZWZ0IEFyYWJpY1xcbi8vIDEgKEVOKTogIEV1cm9wZWFuIE51bWJlclxcbi8vICsgKEVTKTogIEV1cm9wZWFuIE51bWJlciBTZXBhcmF0b3JcXG4vLyAlIChFVCk6ICBFdXJvcGVhbiBOdW1iZXIgVGVybWluYXRvclxcbi8vIG4gKEFOKTogIEFyYWJpYyBOdW1iZXJcXG4vLyAsIChDUyk6ICBDb21tb24gTnVtYmVyIFNlcGFyYXRvclxcbi8vIG0gKE5TTSk6IE5vbi1TcGFjaW5nIE1hcmtcXG4vLyBiIChCTik6ICBCb3VuZGFyeSBOZXV0cmFsXFxuLy8gcyAoQik6ICAgUGFyYWdyYXBoIFNlcGFyYXRvclxcbi8vIHQgKFMpOiAgIFNlZ21lbnQgU2VwYXJhdG9yXFxuLy8gdyAoV1MpOiAgV2hpdGVzcGFjZVxcbi8vIE4gKE9OKTogIE90aGVyIE5ldXRyYWxzXFxuXFxuLy8gUmV0dXJucyBudWxsIGlmIGNoYXJhY3RlcnMgYXJlIG9yZGVyZWQgYXMgdGhleSBhcHBlYXJcXG4vLyAobGVmdC10by1yaWdodCksIG9yIGFuIGFycmF5IG9mIHNlY3Rpb25zICh7ZnJvbSwgdG8sIGxldmVsfVxcbi8vIG9iamVjdHMpIGluIHRoZSBvcmRlciBpbiB3aGljaCB0aGV5IG9jY3VyIHZpc3VhbGx5LlxcbnZhciBiaWRpT3JkZXJpbmcgPSAoZnVuY3Rpb24oKSB7XFxuICAvLyBDaGFyYWN0ZXIgdHlwZXMgZm9yIGNvZGVwb2ludHMgMCB0byAweGZmXFxuICB2YXIgbG93VHlwZXMgPSBcXFwiYmJiYmJiYmJidHN0d3NiYmJiYmJiYmJiYmJiYnNzc3R3Tk4lJSVOTk5OTk4sTixOMTExMTExMTExMU5OTk5OTk5MTExMTExMTExMTExMTExMTExMTExMTExMTE5OTk5OTkxMTExMTExMTExMTExMTExMTExMTExMTExMTk5OTmJiYmJiYnNiYmJiYmJiYmJiYmJiYmJiYmJiYmJiYmJiYixOJSUlJU5OTk5MTk5OTk4lJTExTkxOTk4xTE5OTk5OTExMTExMTExMTExMTExMTExMTExMTExOTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTE5cXFwiXFxuICAvLyBDaGFyYWN0ZXIgdHlwZXMgZm9yIGNvZGVwb2ludHMgMHg2MDAgdG8gMHg2ZjlcXG4gIHZhciBhcmFiaWNUeXBlcyA9IFxcXCJubm5ubm5OTnIlJXIsck5ObW1tbW1tbW1tbW1ycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJtbW1tbW1tbW1tbW1tbW1tbW1tbW1ubm5ubm5ubm5uJW5ucnJybXJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJybW1tbW1tbW5ObW1tbW1tcnJtbU5tbW1tcnIxMTExMTExMTExXFxcIlxcbiAgZnVuY3Rpb24gY2hhclR5cGUoY29kZSkge1xcbiAgICBpZiAoY29kZSA8PSAweGY3KSB7IHJldHVybiBsb3dUeXBlcy5jaGFyQXQoY29kZSkgfVxcbiAgICBlbHNlIGlmICgweDU5MCA8PSBjb2RlICYmIGNvZGUgPD0gMHg1ZjQpIHsgcmV0dXJuIFxcXCJSXFxcIiB9XFxuICAgIGVsc2UgaWYgKDB4NjAwIDw9IGNvZGUgJiYgY29kZSA8PSAweDZmOSkgeyByZXR1cm4gYXJhYmljVHlwZXMuY2hhckF0KGNvZGUgLSAweDYwMCkgfVxcbiAgICBlbHNlIGlmICgweDZlZSA8PSBjb2RlICYmIGNvZGUgPD0gMHg4YWMpIHsgcmV0dXJuIFxcXCJyXFxcIiB9XFxuICAgIGVsc2UgaWYgKDB4MjAwMCA8PSBjb2RlICYmIGNvZGUgPD0gMHgyMDBiKSB7IHJldHVybiBcXFwid1xcXCIgfVxcbiAgICBlbHNlIGlmIChjb2RlID09IDB4MjAwYykgeyByZXR1cm4gXFxcImJcXFwiIH1cXG4gICAgZWxzZSB7IHJldHVybiBcXFwiTFxcXCIgfVxcbiAgfVxcblxcbiAgdmFyIGJpZGlSRSA9IC9bXFxcXHUwNTkwLVxcXFx1MDVmNFxcXFx1MDYwMC1cXFxcdTA2ZmZcXFxcdTA3MDAtXFxcXHUwOGFjXS9cXG4gIHZhciBpc05ldXRyYWwgPSAvW3N0d05dLywgaXNTdHJvbmcgPSAvW0xScl0vLCBjb3VudHNBc0xlZnQgPSAvW0xiMW5dLywgY291bnRzQXNOdW0gPSAvWzFuXS9cXG4gIC8vIEJyb3dzZXJzIHNlZW0gdG8gYWx3YXlzIHRyZWF0IHRoZSBib3VuZGFyaWVzIG9mIGJsb2NrIGVsZW1lbnRzIGFzIGJlaW5nIEwuXFxuICB2YXIgb3V0ZXJUeXBlID0gXFxcIkxcXFwiXFxuXFxuICBmdW5jdGlvbiBCaWRpU3BhbihsZXZlbCwgZnJvbSwgdG8pIHtcXG4gICAgdGhpcy5sZXZlbCA9IGxldmVsXFxuICAgIHRoaXMuZnJvbSA9IGZyb207IHRoaXMudG8gPSB0b1xcbiAgfVxcblxcbiAgcmV0dXJuIGZ1bmN0aW9uKHN0cikge1xcbiAgICBpZiAoIWJpZGlSRS50ZXN0KHN0cikpIHsgcmV0dXJuIGZhbHNlIH1cXG4gICAgdmFyIGxlbiA9IHN0ci5sZW5ndGgsIHR5cGVzID0gW11cXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSlcXG4gICAgICB7IHR5cGVzLnB1c2goY2hhclR5cGUoc3RyLmNoYXJDb2RlQXQoaSkpKSB9XFxuXFxuICAgIC8vIFcxLiBFeGFtaW5lIGVhY2ggbm9uLXNwYWNpbmcgbWFyayAoTlNNKSBpbiB0aGUgbGV2ZWwgcnVuLCBhbmRcXG4gICAgLy8gY2hhbmdlIHRoZSB0eXBlIG9mIHRoZSBOU00gdG8gdGhlIHR5cGUgb2YgdGhlIHByZXZpb3VzXFxuICAgIC8vIGNoYXJhY3Rlci4gSWYgdGhlIE5TTSBpcyBhdCB0aGUgc3RhcnQgb2YgdGhlIGxldmVsIHJ1biwgaXQgd2lsbFxcbiAgICAvLyBnZXQgdGhlIHR5cGUgb2Ygc29yLlxcbiAgICBmb3IgKHZhciBpJDEgPSAwLCBwcmV2ID0gb3V0ZXJUeXBlOyBpJDEgPCBsZW47ICsraSQxKSB7XFxuICAgICAgdmFyIHR5cGUgPSB0eXBlc1tpJDFdXFxuICAgICAgaWYgKHR5cGUgPT0gXFxcIm1cXFwiKSB7IHR5cGVzW2kkMV0gPSBwcmV2IH1cXG4gICAgICBlbHNlIHsgcHJldiA9IHR5cGUgfVxcbiAgICB9XFxuXFxuICAgIC8vIFcyLiBTZWFyY2ggYmFja3dhcmRzIGZyb20gZWFjaCBpbnN0YW5jZSBvZiBhIEV1cm9wZWFuIG51bWJlclxcbiAgICAvLyB1bnRpbCB0aGUgZmlyc3Qgc3Ryb25nIHR5cGUgKFIsIEwsIEFMLCBvciBzb3IpIGlzIGZvdW5kLiBJZiBhblxcbiAgICAvLyBBTCBpcyBmb3VuZCwgY2hhbmdlIHRoZSB0eXBlIG9mIHRoZSBFdXJvcGVhbiBudW1iZXIgdG8gQXJhYmljXFxuICAgIC8vIG51bWJlci5cXG4gICAgLy8gVzMuIENoYW5nZSBhbGwgQUxzIHRvIFIuXFxuICAgIGZvciAodmFyIGkkMiA9IDAsIGN1ciA9IG91dGVyVHlwZTsgaSQyIDwgbGVuOyArK2kkMikge1xcbiAgICAgIHZhciB0eXBlJDEgPSB0eXBlc1tpJDJdXFxuICAgICAgaWYgKHR5cGUkMSA9PSBcXFwiMVxcXCIgJiYgY3VyID09IFxcXCJyXFxcIikgeyB0eXBlc1tpJDJdID0gXFxcIm5cXFwiIH1cXG4gICAgICBlbHNlIGlmIChpc1N0cm9uZy50ZXN0KHR5cGUkMSkpIHsgY3VyID0gdHlwZSQxOyBpZiAodHlwZSQxID09IFxcXCJyXFxcIikgeyB0eXBlc1tpJDJdID0gXFxcIlJcXFwiIH0gfVxcbiAgICB9XFxuXFxuICAgIC8vIFc0LiBBIHNpbmdsZSBFdXJvcGVhbiBzZXBhcmF0b3IgYmV0d2VlbiB0d28gRXVyb3BlYW4gbnVtYmVyc1xcbiAgICAvLyBjaGFuZ2VzIHRvIGEgRXVyb3BlYW4gbnVtYmVyLiBBIHNpbmdsZSBjb21tb24gc2VwYXJhdG9yIGJldHdlZW5cXG4gICAgLy8gdHdvIG51bWJlcnMgb2YgdGhlIHNhbWUgdHlwZSBjaGFuZ2VzIHRvIHRoYXQgdHlwZS5cXG4gICAgZm9yICh2YXIgaSQzID0gMSwgcHJldiQxID0gdHlwZXNbMF07IGkkMyA8IGxlbiAtIDE7ICsraSQzKSB7XFxuICAgICAgdmFyIHR5cGUkMiA9IHR5cGVzW2kkM11cXG4gICAgICBpZiAodHlwZSQyID09IFxcXCIrXFxcIiAmJiBwcmV2JDEgPT0gXFxcIjFcXFwiICYmIHR5cGVzW2kkMysxXSA9PSBcXFwiMVxcXCIpIHsgdHlwZXNbaSQzXSA9IFxcXCIxXFxcIiB9XFxuICAgICAgZWxzZSBpZiAodHlwZSQyID09IFxcXCIsXFxcIiAmJiBwcmV2JDEgPT0gdHlwZXNbaSQzKzFdICYmXFxuICAgICAgICAgICAgICAgKHByZXYkMSA9PSBcXFwiMVxcXCIgfHwgcHJldiQxID09IFxcXCJuXFxcIikpIHsgdHlwZXNbaSQzXSA9IHByZXYkMSB9XFxuICAgICAgcHJldiQxID0gdHlwZSQyXFxuICAgIH1cXG5cXG4gICAgLy8gVzUuIEEgc2VxdWVuY2Ugb2YgRXVyb3BlYW4gdGVybWluYXRvcnMgYWRqYWNlbnQgdG8gRXVyb3BlYW5cXG4gICAgLy8gbnVtYmVycyBjaGFuZ2VzIHRvIGFsbCBFdXJvcGVhbiBudW1iZXJzLlxcbiAgICAvLyBXNi4gT3RoZXJ3aXNlLCBzZXBhcmF0b3JzIGFuZCB0ZXJtaW5hdG9ycyBjaGFuZ2UgdG8gT3RoZXJcXG4gICAgLy8gTmV1dHJhbC5cXG4gICAgZm9yICh2YXIgaSQ0ID0gMDsgaSQ0IDwgbGVuOyArK2kkNCkge1xcbiAgICAgIHZhciB0eXBlJDMgPSB0eXBlc1tpJDRdXFxuICAgICAgaWYgKHR5cGUkMyA9PSBcXFwiLFxcXCIpIHsgdHlwZXNbaSQ0XSA9IFxcXCJOXFxcIiB9XFxuICAgICAgZWxzZSBpZiAodHlwZSQzID09IFxcXCIlXFxcIikge1xcbiAgICAgICAgdmFyIGVuZCA9ICh2b2lkIDApXFxuICAgICAgICBmb3IgKGVuZCA9IGkkNCArIDE7IGVuZCA8IGxlbiAmJiB0eXBlc1tlbmRdID09IFxcXCIlXFxcIjsgKytlbmQpIHt9XFxuICAgICAgICB2YXIgcmVwbGFjZSA9IChpJDQgJiYgdHlwZXNbaSQ0LTFdID09IFxcXCIhXFxcIikgfHwgKGVuZCA8IGxlbiAmJiB0eXBlc1tlbmRdID09IFxcXCIxXFxcIikgPyBcXFwiMVxcXCIgOiBcXFwiTlxcXCJcXG4gICAgICAgIGZvciAodmFyIGogPSBpJDQ7IGogPCBlbmQ7ICsraikgeyB0eXBlc1tqXSA9IHJlcGxhY2UgfVxcbiAgICAgICAgaSQ0ID0gZW5kIC0gMVxcbiAgICAgIH1cXG4gICAgfVxcblxcbiAgICAvLyBXNy4gU2VhcmNoIGJhY2t3YXJkcyBmcm9tIGVhY2ggaW5zdGFuY2Ugb2YgYSBFdXJvcGVhbiBudW1iZXJcXG4gICAgLy8gdW50aWwgdGhlIGZpcnN0IHN0cm9uZyB0eXBlIChSLCBMLCBvciBzb3IpIGlzIGZvdW5kLiBJZiBhbiBMIGlzXFxuICAgIC8vIGZvdW5kLCB0aGVuIGNoYW5nZSB0aGUgdHlwZSBvZiB0aGUgRXVyb3BlYW4gbnVtYmVyIHRvIEwuXFxuICAgIGZvciAodmFyIGkkNSA9IDAsIGN1ciQxID0gb3V0ZXJUeXBlOyBpJDUgPCBsZW47ICsraSQ1KSB7XFxuICAgICAgdmFyIHR5cGUkNCA9IHR5cGVzW2kkNV1cXG4gICAgICBpZiAoY3VyJDEgPT0gXFxcIkxcXFwiICYmIHR5cGUkNCA9PSBcXFwiMVxcXCIpIHsgdHlwZXNbaSQ1XSA9IFxcXCJMXFxcIiB9XFxuICAgICAgZWxzZSBpZiAoaXNTdHJvbmcudGVzdCh0eXBlJDQpKSB7IGN1ciQxID0gdHlwZSQ0IH1cXG4gICAgfVxcblxcbiAgICAvLyBOMS4gQSBzZXF1ZW5jZSBvZiBuZXV0cmFscyB0YWtlcyB0aGUgZGlyZWN0aW9uIG9mIHRoZVxcbiAgICAvLyBzdXJyb3VuZGluZyBzdHJvbmcgdGV4dCBpZiB0aGUgdGV4dCBvbiBib3RoIHNpZGVzIGhhcyB0aGUgc2FtZVxcbiAgICAvLyBkaXJlY3Rpb24uIEV1cm9wZWFuIGFuZCBBcmFiaWMgbnVtYmVycyBhY3QgYXMgaWYgdGhleSB3ZXJlIFIgaW5cXG4gICAgLy8gdGVybXMgb2YgdGhlaXIgaW5mbHVlbmNlIG9uIG5ldXRyYWxzLiBTdGFydC1vZi1sZXZlbC1ydW4gKHNvcilcXG4gICAgLy8gYW5kIGVuZC1vZi1sZXZlbC1ydW4gKGVvcikgYXJlIHVzZWQgYXQgbGV2ZWwgcnVuIGJvdW5kYXJpZXMuXFxuICAgIC8vIE4yLiBBbnkgcmVtYWluaW5nIG5ldXRyYWxzIHRha2UgdGhlIGVtYmVkZGluZyBkaXJlY3Rpb24uXFxuICAgIGZvciAodmFyIGkkNiA9IDA7IGkkNiA8IGxlbjsgKytpJDYpIHtcXG4gICAgICBpZiAoaXNOZXV0cmFsLnRlc3QodHlwZXNbaSQ2XSkpIHtcXG4gICAgICAgIHZhciBlbmQkMSA9ICh2b2lkIDApXFxuICAgICAgICBmb3IgKGVuZCQxID0gaSQ2ICsgMTsgZW5kJDEgPCBsZW4gJiYgaXNOZXV0cmFsLnRlc3QodHlwZXNbZW5kJDFdKTsgKytlbmQkMSkge31cXG4gICAgICAgIHZhciBiZWZvcmUgPSAoaSQ2ID8gdHlwZXNbaSQ2LTFdIDogb3V0ZXJUeXBlKSA9PSBcXFwiTFxcXCJcXG4gICAgICAgIHZhciBhZnRlciA9IChlbmQkMSA8IGxlbiA/IHR5cGVzW2VuZCQxXSA6IG91dGVyVHlwZSkgPT0gXFxcIkxcXFwiXFxuICAgICAgICB2YXIgcmVwbGFjZSQxID0gYmVmb3JlIHx8IGFmdGVyID8gXFxcIkxcXFwiIDogXFxcIlJcXFwiXFxuICAgICAgICBmb3IgKHZhciBqJDEgPSBpJDY7IGokMSA8IGVuZCQxOyArK2okMSkgeyB0eXBlc1tqJDFdID0gcmVwbGFjZSQxIH1cXG4gICAgICAgIGkkNiA9IGVuZCQxIC0gMVxcbiAgICAgIH1cXG4gICAgfVxcblxcbiAgICAvLyBIZXJlIHdlIGRlcGFydCBmcm9tIHRoZSBkb2N1bWVudGVkIGFsZ29yaXRobSwgaW4gb3JkZXIgdG8gYXZvaWRcXG4gICAgLy8gYnVpbGRpbmcgdXAgYW4gYWN0dWFsIGxldmVscyBhcnJheS4gU2luY2UgdGhlcmUgYXJlIG9ubHkgdGhyZWVcXG4gICAgLy8gbGV2ZWxzICgwLCAxLCAyKSBpbiBhbiBpbXBsZW1lbnRhdGlvbiB0aGF0IGRvZXNuJ3QgdGFrZVxcbiAgICAvLyBleHBsaWNpdCBlbWJlZGRpbmcgaW50byBhY2NvdW50LCB3ZSBjYW4gYnVpbGQgdXAgdGhlIG9yZGVyIG9uXFxuICAgIC8vIHRoZSBmbHksIHdpdGhvdXQgZm9sbG93aW5nIHRoZSBsZXZlbC1iYXNlZCBhbGdvcml0aG0uXFxuICAgIHZhciBvcmRlciA9IFtdLCBtXFxuICAgIGZvciAodmFyIGkkNyA9IDA7IGkkNyA8IGxlbjspIHtcXG4gICAgICBpZiAoY291bnRzQXNMZWZ0LnRlc3QodHlwZXNbaSQ3XSkpIHtcXG4gICAgICAgIHZhciBzdGFydCA9IGkkN1xcbiAgICAgICAgZm9yICgrK2kkNzsgaSQ3IDwgbGVuICYmIGNvdW50c0FzTGVmdC50ZXN0KHR5cGVzW2kkN10pOyArK2kkNykge31cXG4gICAgICAgIG9yZGVyLnB1c2gobmV3IEJpZGlTcGFuKDAsIHN0YXJ0LCBpJDcpKVxcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICB2YXIgcG9zID0gaSQ3LCBhdCA9IG9yZGVyLmxlbmd0aFxcbiAgICAgICAgZm9yICgrK2kkNzsgaSQ3IDwgbGVuICYmIHR5cGVzW2kkN10gIT0gXFxcIkxcXFwiOyArK2kkNykge31cXG4gICAgICAgIGZvciAodmFyIGokMiA9IHBvczsgaiQyIDwgaSQ3Oykge1xcbiAgICAgICAgICBpZiAoY291bnRzQXNOdW0udGVzdCh0eXBlc1tqJDJdKSkge1xcbiAgICAgICAgICAgIGlmIChwb3MgPCBqJDIpIHsgb3JkZXIuc3BsaWNlKGF0LCAwLCBuZXcgQmlkaVNwYW4oMSwgcG9zLCBqJDIpKSB9XFxuICAgICAgICAgICAgdmFyIG5zdGFydCA9IGokMlxcbiAgICAgICAgICAgIGZvciAoKytqJDI7IGokMiA8IGkkNyAmJiBjb3VudHNBc051bS50ZXN0KHR5cGVzW2okMl0pOyArK2okMikge31cXG4gICAgICAgICAgICBvcmRlci5zcGxpY2UoYXQsIDAsIG5ldyBCaWRpU3BhbigyLCBuc3RhcnQsIGokMikpXFxuICAgICAgICAgICAgcG9zID0gaiQyXFxuICAgICAgICAgIH0gZWxzZSB7ICsraiQyIH1cXG4gICAgICAgIH1cXG4gICAgICAgIGlmIChwb3MgPCBpJDcpIHsgb3JkZXIuc3BsaWNlKGF0LCAwLCBuZXcgQmlkaVNwYW4oMSwgcG9zLCBpJDcpKSB9XFxuICAgICAgfVxcbiAgICB9XFxuICAgIGlmIChvcmRlclswXS5sZXZlbCA9PSAxICYmIChtID0gc3RyLm1hdGNoKC9eXFxcXHMrLykpKSB7XFxuICAgICAgb3JkZXJbMF0uZnJvbSA9IG1bMF0ubGVuZ3RoXFxuICAgICAgb3JkZXIudW5zaGlmdChuZXcgQmlkaVNwYW4oMCwgMCwgbVswXS5sZW5ndGgpKVxcbiAgICB9XFxuICAgIGlmIChsc3Qob3JkZXIpLmxldmVsID09IDEgJiYgKG0gPSBzdHIubWF0Y2goL1xcXFxzKyQvKSkpIHtcXG4gICAgICBsc3Qob3JkZXIpLnRvIC09IG1bMF0ubGVuZ3RoXFxuICAgICAgb3JkZXIucHVzaChuZXcgQmlkaVNwYW4oMCwgbGVuIC0gbVswXS5sZW5ndGgsIGxlbikpXFxuICAgIH1cXG5cXG4gICAgcmV0dXJuIG9yZGVyXFxuICB9XFxufSkoKVxcblxcbi8vIEdldCB0aGUgYmlkaSBvcmRlcmluZyBmb3IgdGhlIGdpdmVuIGxpbmUgKGFuZCBjYWNoZSBpdCkuIFJldHVybnNcXG4vLyBmYWxzZSBmb3IgbGluZXMgdGhhdCBhcmUgZnVsbHkgbGVmdC10by1yaWdodCwgYW5kIGFuIGFycmF5IG9mXFxuLy8gQmlkaVNwYW4gb2JqZWN0cyBvdGhlcndpc2UuXFxuZnVuY3Rpb24gZ2V0T3JkZXIobGluZSkge1xcbiAgdmFyIG9yZGVyID0gbGluZS5vcmRlclxcbiAgaWYgKG9yZGVyID09IG51bGwpIHsgb3JkZXIgPSBsaW5lLm9yZGVyID0gYmlkaU9yZGVyaW5nKGxpbmUudGV4dCkgfVxcbiAgcmV0dXJuIG9yZGVyXFxufVxcblxcbmZ1bmN0aW9uIG1vdmVDaGFyTG9naWNhbGx5KGxpbmUsIGNoLCBkaXIpIHtcXG4gIHZhciB0YXJnZXQgPSBza2lwRXh0ZW5kaW5nQ2hhcnMobGluZS50ZXh0LCBjaCArIGRpciwgZGlyKVxcbiAgcmV0dXJuIHRhcmdldCA8IDAgfHwgdGFyZ2V0ID4gbGluZS50ZXh0Lmxlbmd0aCA/IG51bGwgOiB0YXJnZXRcXG59XFxuXFxuZnVuY3Rpb24gbW92ZUxvZ2ljYWxseShsaW5lLCBzdGFydCwgZGlyKSB7XFxuICB2YXIgY2ggPSBtb3ZlQ2hhckxvZ2ljYWxseShsaW5lLCBzdGFydC5jaCwgZGlyKVxcbiAgcmV0dXJuIGNoID09IG51bGwgPyBudWxsIDogbmV3IFBvcyhzdGFydC5saW5lLCBjaCwgZGlyIDwgMCA/IFxcXCJhZnRlclxcXCIgOiBcXFwiYmVmb3JlXFxcIilcXG59XFxuXFxuZnVuY3Rpb24gZW5kT2ZMaW5lKHZpc3VhbGx5LCBjbSwgbGluZU9iaiwgbGluZU5vLCBkaXIpIHtcXG4gIGlmICh2aXN1YWxseSkge1xcbiAgICB2YXIgb3JkZXIgPSBnZXRPcmRlcihsaW5lT2JqKVxcbiAgICBpZiAob3JkZXIpIHtcXG4gICAgICB2YXIgcGFydCA9IGRpciA8IDAgPyBsc3Qob3JkZXIpIDogb3JkZXJbMF1cXG4gICAgICB2YXIgbW92ZUluU3RvcmFnZU9yZGVyID0gKGRpciA8IDApID09IChwYXJ0LmxldmVsID09IDEpXFxuICAgICAgdmFyIHN0aWNreSA9IG1vdmVJblN0b3JhZ2VPcmRlciA/IFxcXCJhZnRlclxcXCIgOiBcXFwiYmVmb3JlXFxcIlxcbiAgICAgIHZhciBjaFxcbiAgICAgIC8vIFdpdGggYSB3cmFwcGVkIHJ0bCBjaHVuayAocG9zc2libHkgc3Bhbm5pbmcgbXVsdGlwbGUgYmlkaSBwYXJ0cyksXFxuICAgICAgLy8gaXQgY291bGQgYmUgdGhhdCB0aGUgbGFzdCBiaWRpIHBhcnQgaXMgbm90IG9uIHRoZSBsYXN0IHZpc3VhbCBsaW5lLFxcbiAgICAgIC8vIHNpbmNlIHZpc3VhbCBsaW5lcyBjb250YWluIGNvbnRlbnQgb3JkZXItY29uc2VjdXRpdmUgY2h1bmtzLlxcbiAgICAgIC8vIFRodXMsIGluIHJ0bCwgd2UgYXJlIGxvb2tpbmcgZm9yIHRoZSBmaXJzdCAoY29udGVudC1vcmRlcikgY2hhcmFjdGVyXFxuICAgICAgLy8gaW4gdGhlIHJ0bCBjaHVuayB0aGF0IGlzIG9uIHRoZSBsYXN0IGxpbmUgKHRoYXQgaXMsIHRoZSBzYW1lIGxpbmVcXG4gICAgICAvLyBhcyB0aGUgbGFzdCAoY29udGVudC1vcmRlcikgY2hhcmFjdGVyKS5cXG4gICAgICBpZiAocGFydC5sZXZlbCA+IDApIHtcXG4gICAgICAgIHZhciBwcmVwID0gcHJlcGFyZU1lYXN1cmVGb3JMaW5lKGNtLCBsaW5lT2JqKVxcbiAgICAgICAgY2ggPSBkaXIgPCAwID8gbGluZU9iai50ZXh0Lmxlbmd0aCAtIDEgOiAwXFxuICAgICAgICB2YXIgdGFyZ2V0VG9wID0gbWVhc3VyZUNoYXJQcmVwYXJlZChjbSwgcHJlcCwgY2gpLnRvcFxcbiAgICAgICAgY2ggPSBmaW5kRmlyc3QoZnVuY3Rpb24gKGNoKSB7IHJldHVybiBtZWFzdXJlQ2hhclByZXBhcmVkKGNtLCBwcmVwLCBjaCkudG9wID09IHRhcmdldFRvcDsgfSwgKGRpciA8IDApID09IChwYXJ0LmxldmVsID09IDEpID8gcGFydC5mcm9tIDogcGFydC50byAtIDEsIGNoKVxcbiAgICAgICAgaWYgKHN0aWNreSA9PSBcXFwiYmVmb3JlXFxcIikgeyBjaCA9IG1vdmVDaGFyTG9naWNhbGx5KGxpbmVPYmosIGNoLCAxLCB0cnVlKSB9XFxuICAgICAgfSBlbHNlIHsgY2ggPSBkaXIgPCAwID8gcGFydC50byA6IHBhcnQuZnJvbSB9XFxuICAgICAgcmV0dXJuIG5ldyBQb3MobGluZU5vLCBjaCwgc3RpY2t5KVxcbiAgICB9XFxuICB9XFxuICByZXR1cm4gbmV3IFBvcyhsaW5lTm8sIGRpciA8IDAgPyBsaW5lT2JqLnRleHQubGVuZ3RoIDogMCwgZGlyIDwgMCA/IFxcXCJiZWZvcmVcXFwiIDogXFxcImFmdGVyXFxcIilcXG59XFxuXFxuZnVuY3Rpb24gbW92ZVZpc3VhbGx5KGNtLCBsaW5lLCBzdGFydCwgZGlyKSB7XFxuICB2YXIgYmlkaSA9IGdldE9yZGVyKGxpbmUpXFxuICBpZiAoIWJpZGkpIHsgcmV0dXJuIG1vdmVMb2dpY2FsbHkobGluZSwgc3RhcnQsIGRpcikgfVxcbiAgaWYgKHN0YXJ0LmNoID49IGxpbmUudGV4dC5sZW5ndGgpIHtcXG4gICAgc3RhcnQuY2ggPSBsaW5lLnRleHQubGVuZ3RoXFxuICAgIHN0YXJ0LnN0aWNreSA9IFxcXCJiZWZvcmVcXFwiXFxuICB9IGVsc2UgaWYgKHN0YXJ0LmNoIDw9IDApIHtcXG4gICAgc3RhcnQuY2ggPSAwXFxuICAgIHN0YXJ0LnN0aWNreSA9IFxcXCJhZnRlclxcXCJcXG4gIH1cXG4gIHZhciBwYXJ0UG9zID0gZ2V0QmlkaVBhcnRBdChiaWRpLCBzdGFydC5jaCwgc3RhcnQuc3RpY2t5KSwgcGFydCA9IGJpZGlbcGFydFBvc11cXG4gIGlmIChwYXJ0LmxldmVsICUgMiA9PSAwICYmIChkaXIgPiAwID8gcGFydC50byA+IHN0YXJ0LmNoIDogcGFydC5mcm9tIDwgc3RhcnQuY2gpKSB7XFxuICAgIC8vIENhc2UgMTogV2UgbW92ZSB3aXRoaW4gYW4gbHRyIHBhcnQuIEV2ZW4gd2l0aCB3cmFwcGVkIGxpbmVzLFxcbiAgICAvLyBub3RoaW5nIGludGVyZXN0aW5nIGhhcHBlbnMuXFxuICAgIHJldHVybiBtb3ZlTG9naWNhbGx5KGxpbmUsIHN0YXJ0LCBkaXIpXFxuICB9XFxuXFxuICB2YXIgbXYgPSBmdW5jdGlvbiAocG9zLCBkaXIpIHsgcmV0dXJuIG1vdmVDaGFyTG9naWNhbGx5KGxpbmUsIHBvcyBpbnN0YW5jZW9mIFBvcyA/IHBvcy5jaCA6IHBvcywgZGlyKTsgfVxcbiAgdmFyIHByZXBcXG4gIHZhciBnZXRXcmFwcGVkTGluZUV4dGVudCA9IGZ1bmN0aW9uIChjaCkge1xcbiAgICBpZiAoIWNtLm9wdGlvbnMubGluZVdyYXBwaW5nKSB7IHJldHVybiB7YmVnaW46IDAsIGVuZDogbGluZS50ZXh0Lmxlbmd0aH0gfVxcbiAgICBwcmVwID0gcHJlcCB8fCBwcmVwYXJlTWVhc3VyZUZvckxpbmUoY20sIGxpbmUpXFxuICAgIHJldHVybiB3cmFwcGVkTGluZUV4dGVudENoYXIoY20sIGxpbmUsIHByZXAsIGNoKVxcbiAgfVxcbiAgdmFyIHdyYXBwZWRMaW5lRXh0ZW50ID0gZ2V0V3JhcHBlZExpbmVFeHRlbnQoc3RhcnQuc3RpY2t5ID09IFxcXCJiZWZvcmVcXFwiID8gbXYoc3RhcnQsIC0xKSA6IHN0YXJ0LmNoKVxcblxcbiAgaWYgKHBhcnQubGV2ZWwgJSAyID09IDEpIHtcXG4gICAgdmFyIGNoID0gbXYoc3RhcnQsIC1kaXIpXFxuICAgIGlmIChjaCAhPSBudWxsICYmIChkaXIgPiAwID8gY2ggPj0gcGFydC5mcm9tICYmIGNoID49IHdyYXBwZWRMaW5lRXh0ZW50LmJlZ2luIDogY2ggPD0gcGFydC50byAmJiBjaCA8PSB3cmFwcGVkTGluZUV4dGVudC5lbmQpKSB7XFxuICAgICAgLy8gQ2FzZSAyOiBXZSBtb3ZlIHdpdGhpbiBhbiBydGwgcGFydCBvbiB0aGUgc2FtZSB2aXN1YWwgbGluZVxcbiAgICAgIHZhciBzdGlja3kgPSBkaXIgPCAwID8gXFxcImJlZm9yZVxcXCIgOiBcXFwiYWZ0ZXJcXFwiXFxuICAgICAgcmV0dXJuIG5ldyBQb3Moc3RhcnQubGluZSwgY2gsIHN0aWNreSlcXG4gICAgfVxcbiAgfVxcblxcbiAgLy8gQ2FzZSAzOiBDb3VsZCBub3QgbW92ZSB3aXRoaW4gdGhpcyBiaWRpIHBhcnQgaW4gdGhpcyB2aXN1YWwgbGluZSwgc28gbGVhdmVcXG4gIC8vIHRoZSBjdXJyZW50IGJpZGkgcGFydFxcblxcbiAgdmFyIHNlYXJjaEluVmlzdWFsTGluZSA9IGZ1bmN0aW9uIChwYXJ0UG9zLCBkaXIsIHdyYXBwZWRMaW5lRXh0ZW50KSB7XFxuICAgIHZhciBnZXRSZXMgPSBmdW5jdGlvbiAoY2gsIG1vdmVJblN0b3JhZ2VPcmRlcikgeyByZXR1cm4gbW92ZUluU3RvcmFnZU9yZGVyXFxuICAgICAgPyBuZXcgUG9zKHN0YXJ0LmxpbmUsIG12KGNoLCAxKSwgXFxcImJlZm9yZVxcXCIpXFxuICAgICAgOiBuZXcgUG9zKHN0YXJ0LmxpbmUsIGNoLCBcXFwiYWZ0ZXJcXFwiKTsgfVxcblxcbiAgICBmb3IgKDsgcGFydFBvcyA+PSAwICYmIHBhcnRQb3MgPCBiaWRpLmxlbmd0aDsgcGFydFBvcyArPSBkaXIpIHtcXG4gICAgICB2YXIgcGFydCA9IGJpZGlbcGFydFBvc11cXG4gICAgICB2YXIgbW92ZUluU3RvcmFnZU9yZGVyID0gKGRpciA+IDApID09IChwYXJ0LmxldmVsICE9IDEpXFxuICAgICAgdmFyIGNoID0gbW92ZUluU3RvcmFnZU9yZGVyID8gd3JhcHBlZExpbmVFeHRlbnQuYmVnaW4gOiBtdih3cmFwcGVkTGluZUV4dGVudC5lbmQsIC0xKVxcbiAgICAgIGlmIChwYXJ0LmZyb20gPD0gY2ggJiYgY2ggPCBwYXJ0LnRvKSB7IHJldHVybiBnZXRSZXMoY2gsIG1vdmVJblN0b3JhZ2VPcmRlcikgfVxcbiAgICAgIGNoID0gbW92ZUluU3RvcmFnZU9yZGVyID8gcGFydC5mcm9tIDogbXYocGFydC50bywgLTEpXFxuICAgICAgaWYgKHdyYXBwZWRMaW5lRXh0ZW50LmJlZ2luIDw9IGNoICYmIGNoIDwgd3JhcHBlZExpbmVFeHRlbnQuZW5kKSB7IHJldHVybiBnZXRSZXMoY2gsIG1vdmVJblN0b3JhZ2VPcmRlcikgfVxcbiAgICB9XFxuICB9XFxuXFxuICAvLyBDYXNlIDNhOiBMb29rIGZvciBvdGhlciBiaWRpIHBhcnRzIG9uIHRoZSBzYW1lIHZpc3VhbCBsaW5lXFxuICB2YXIgcmVzID0gc2VhcmNoSW5WaXN1YWxMaW5lKHBhcnRQb3MgKyBkaXIsIGRpciwgd3JhcHBlZExpbmVFeHRlbnQpXFxuICBpZiAocmVzKSB7IHJldHVybiByZXMgfVxcblxcbiAgLy8gQ2FzZSAzYjogTG9vayBmb3Igb3RoZXIgYmlkaSBwYXJ0cyBvbiB0aGUgbmV4dCB2aXN1YWwgbGluZVxcbiAgdmFyIG5leHRDaCA9IGRpciA+IDAgPyB3cmFwcGVkTGluZUV4dGVudC5lbmQgOiBtdih3cmFwcGVkTGluZUV4dGVudC5iZWdpbiwgLTEpXFxuICBpZiAobmV4dENoICE9IG51bGwgJiYgIShkaXIgPiAwICYmIG5leHRDaCA9PSBsaW5lLnRleHQubGVuZ3RoKSkge1xcbiAgICByZXMgPSBzZWFyY2hJblZpc3VhbExpbmUoZGlyID4gMCA/IDAgOiBiaWRpLmxlbmd0aCAtIDEsIGRpciwgZ2V0V3JhcHBlZExpbmVFeHRlbnQobmV4dENoKSlcXG4gICAgaWYgKHJlcykgeyByZXR1cm4gcmVzIH1cXG4gIH1cXG5cXG4gIC8vIENhc2UgNDogTm93aGVyZSB0byBtb3ZlXFxuICByZXR1cm4gbnVsbFxcbn1cXG5cXG4vLyBFVkVOVCBIQU5ETElOR1xcblxcbi8vIExpZ2h0d2VpZ2h0IGV2ZW50IGZyYW1ld29yay4gb24vb2ZmIGFsc28gd29yayBvbiBET00gbm9kZXMsXFxuLy8gcmVnaXN0ZXJpbmcgbmF0aXZlIERPTSBoYW5kbGVycy5cXG5cXG52YXIgbm9IYW5kbGVycyA9IFtdXFxuXFxudmFyIG9uID0gZnVuY3Rpb24oZW1pdHRlciwgdHlwZSwgZikge1xcbiAgaWYgKGVtaXR0ZXIuYWRkRXZlbnRMaXN0ZW5lcikge1xcbiAgICBlbWl0dGVyLmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgZiwgZmFsc2UpXFxuICB9IGVsc2UgaWYgKGVtaXR0ZXIuYXR0YWNoRXZlbnQpIHtcXG4gICAgZW1pdHRlci5hdHRhY2hFdmVudChcXFwib25cXFwiICsgdHlwZSwgZilcXG4gIH0gZWxzZSB7XFxuICAgIHZhciBtYXAgPSBlbWl0dGVyLl9oYW5kbGVycyB8fCAoZW1pdHRlci5faGFuZGxlcnMgPSB7fSlcXG4gICAgbWFwW3R5cGVdID0gKG1hcFt0eXBlXSB8fCBub0hhbmRsZXJzKS5jb25jYXQoZilcXG4gIH1cXG59XFxuXFxuZnVuY3Rpb24gZ2V0SGFuZGxlcnMoZW1pdHRlciwgdHlwZSkge1xcbiAgcmV0dXJuIGVtaXR0ZXIuX2hhbmRsZXJzICYmIGVtaXR0ZXIuX2hhbmRsZXJzW3R5cGVdIHx8IG5vSGFuZGxlcnNcXG59XFxuXFxuZnVuY3Rpb24gb2ZmKGVtaXR0ZXIsIHR5cGUsIGYpIHtcXG4gIGlmIChlbWl0dGVyLnJlbW92ZUV2ZW50TGlzdGVuZXIpIHtcXG4gICAgZW1pdHRlci5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGYsIGZhbHNlKVxcbiAgfSBlbHNlIGlmIChlbWl0dGVyLmRldGFjaEV2ZW50KSB7XFxuICAgIGVtaXR0ZXIuZGV0YWNoRXZlbnQoXFxcIm9uXFxcIiArIHR5cGUsIGYpXFxuICB9IGVsc2Uge1xcbiAgICB2YXIgbWFwID0gZW1pdHRlci5faGFuZGxlcnMsIGFyciA9IG1hcCAmJiBtYXBbdHlwZV1cXG4gICAgaWYgKGFycikge1xcbiAgICAgIHZhciBpbmRleCA9IGluZGV4T2YoYXJyLCBmKVxcbiAgICAgIGlmIChpbmRleCA+IC0xKVxcbiAgICAgICAgeyBtYXBbdHlwZV0gPSBhcnIuc2xpY2UoMCwgaW5kZXgpLmNvbmNhdChhcnIuc2xpY2UoaW5kZXggKyAxKSkgfVxcbiAgICB9XFxuICB9XFxufVxcblxcbmZ1bmN0aW9uIHNpZ25hbChlbWl0dGVyLCB0eXBlIC8qLCB2YWx1ZXMuLi4qLykge1xcbiAgdmFyIGhhbmRsZXJzID0gZ2V0SGFuZGxlcnMoZW1pdHRlciwgdHlwZSlcXG4gIGlmICghaGFuZGxlcnMubGVuZ3RoKSB7IHJldHVybiB9XFxuICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMilcXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgaGFuZGxlcnMubGVuZ3RoOyArK2kpIHsgaGFuZGxlcnNbaV0uYXBwbHkobnVsbCwgYXJncykgfVxcbn1cXG5cXG4vLyBUaGUgRE9NIGV2ZW50cyB0aGF0IENvZGVNaXJyb3IgaGFuZGxlcyBjYW4gYmUgb3ZlcnJpZGRlbiBieVxcbi8vIHJlZ2lzdGVyaW5nIGEgKG5vbi1ET00pIGhhbmRsZXIgb24gdGhlIGVkaXRvciBmb3IgdGhlIGV2ZW50IG5hbWUsXFxuLy8gYW5kIHByZXZlbnREZWZhdWx0LWluZyB0aGUgZXZlbnQgaW4gdGhhdCBoYW5kbGVyLlxcbmZ1bmN0aW9uIHNpZ25hbERPTUV2ZW50KGNtLCBlLCBvdmVycmlkZSkge1xcbiAgaWYgKHR5cGVvZiBlID09IFxcXCJzdHJpbmdcXFwiKVxcbiAgICB7IGUgPSB7dHlwZTogZSwgcHJldmVudERlZmF1bHQ6IGZ1bmN0aW9uKCkgeyB0aGlzLmRlZmF1bHRQcmV2ZW50ZWQgPSB0cnVlIH19IH1cXG4gIHNpZ25hbChjbSwgb3ZlcnJpZGUgfHwgZS50eXBlLCBjbSwgZSlcXG4gIHJldHVybiBlX2RlZmF1bHRQcmV2ZW50ZWQoZSkgfHwgZS5jb2RlbWlycm9ySWdub3JlXFxufVxcblxcbmZ1bmN0aW9uIHNpZ25hbEN1cnNvckFjdGl2aXR5KGNtKSB7XFxuICB2YXIgYXJyID0gY20uX2hhbmRsZXJzICYmIGNtLl9oYW5kbGVycy5jdXJzb3JBY3Rpdml0eVxcbiAgaWYgKCFhcnIpIHsgcmV0dXJuIH1cXG4gIHZhciBzZXQgPSBjbS5jdXJPcC5jdXJzb3JBY3Rpdml0eUhhbmRsZXJzIHx8IChjbS5jdXJPcC5jdXJzb3JBY3Rpdml0eUhhbmRsZXJzID0gW10pXFxuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7ICsraSkgeyBpZiAoaW5kZXhPZihzZXQsIGFycltpXSkgPT0gLTEpXFxuICAgIHsgc2V0LnB1c2goYXJyW2ldKSB9IH1cXG59XFxuXFxuZnVuY3Rpb24gaGFzSGFuZGxlcihlbWl0dGVyLCB0eXBlKSB7XFxuICByZXR1cm4gZ2V0SGFuZGxlcnMoZW1pdHRlciwgdHlwZSkubGVuZ3RoID4gMFxcbn1cXG5cXG4vLyBBZGQgb24gYW5kIG9mZiBtZXRob2RzIHRvIGEgY29uc3RydWN0b3IncyBwcm90b3R5cGUsIHRvIG1ha2VcXG4vLyByZWdpc3RlcmluZyBldmVudHMgb24gc3VjaCBvYmplY3RzIG1vcmUgY29udmVuaWVudC5cXG5mdW5jdGlvbiBldmVudE1peGluKGN0b3IpIHtcXG4gIGN0b3IucHJvdG90eXBlLm9uID0gZnVuY3Rpb24odHlwZSwgZikge29uKHRoaXMsIHR5cGUsIGYpfVxcbiAgY3Rvci5wcm90b3R5cGUub2ZmID0gZnVuY3Rpb24odHlwZSwgZikge29mZih0aGlzLCB0eXBlLCBmKX1cXG59XFxuXFxuLy8gRHVlIHRvIHRoZSBmYWN0IHRoYXQgd2Ugc3RpbGwgc3VwcG9ydCBqdXJhc3NpYyBJRSB2ZXJzaW9ucywgc29tZVxcbi8vIGNvbXBhdGliaWxpdHkgd3JhcHBlcnMgYXJlIG5lZWRlZC5cXG5cXG5mdW5jdGlvbiBlX3ByZXZlbnREZWZhdWx0KGUpIHtcXG4gIGlmIChlLnByZXZlbnREZWZhdWx0KSB7IGUucHJldmVudERlZmF1bHQoKSB9XFxuICBlbHNlIHsgZS5yZXR1cm5WYWx1ZSA9IGZhbHNlIH1cXG59XFxuZnVuY3Rpb24gZV9zdG9wUHJvcGFnYXRpb24oZSkge1xcbiAgaWYgKGUuc3RvcFByb3BhZ2F0aW9uKSB7IGUuc3RvcFByb3BhZ2F0aW9uKCkgfVxcbiAgZWxzZSB7IGUuY2FuY2VsQnViYmxlID0gdHJ1ZSB9XFxufVxcbmZ1bmN0aW9uIGVfZGVmYXVsdFByZXZlbnRlZChlKSB7XFxuICByZXR1cm4gZS5kZWZhdWx0UHJldmVudGVkICE9IG51bGwgPyBlLmRlZmF1bHRQcmV2ZW50ZWQgOiBlLnJldHVyblZhbHVlID09IGZhbHNlXFxufVxcbmZ1bmN0aW9uIGVfc3RvcChlKSB7ZV9wcmV2ZW50RGVmYXVsdChlKTsgZV9zdG9wUHJvcGFnYXRpb24oZSl9XFxuXFxuZnVuY3Rpb24gZV90YXJnZXQoZSkge3JldHVybiBlLnRhcmdldCB8fCBlLnNyY0VsZW1lbnR9XFxuZnVuY3Rpb24gZV9idXR0b24oZSkge1xcbiAgdmFyIGIgPSBlLndoaWNoXFxuICBpZiAoYiA9PSBudWxsKSB7XFxuICAgIGlmIChlLmJ1dHRvbiAmIDEpIHsgYiA9IDEgfVxcbiAgICBlbHNlIGlmIChlLmJ1dHRvbiAmIDIpIHsgYiA9IDMgfVxcbiAgICBlbHNlIGlmIChlLmJ1dHRvbiAmIDQpIHsgYiA9IDIgfVxcbiAgfVxcbiAgaWYgKG1hYyAmJiBlLmN0cmxLZXkgJiYgYiA9PSAxKSB7IGIgPSAzIH1cXG4gIHJldHVybiBiXFxufVxcblxcbi8vIERldGVjdCBkcmFnLWFuZC1kcm9wXFxudmFyIGRyYWdBbmREcm9wID0gZnVuY3Rpb24oKSB7XFxuICAvLyBUaGVyZSBpcyAqc29tZSoga2luZCBvZiBkcmFnLWFuZC1kcm9wIHN1cHBvcnQgaW4gSUU2LTgsIGJ1dCBJXFxuICAvLyBjb3VsZG4ndCBnZXQgaXQgdG8gd29yayB5ZXQuXFxuICBpZiAoaWUgJiYgaWVfdmVyc2lvbiA8IDkpIHsgcmV0dXJuIGZhbHNlIH1cXG4gIHZhciBkaXYgPSBlbHQoJ2RpdicpXFxuICByZXR1cm4gXFxcImRyYWdnYWJsZVxcXCIgaW4gZGl2IHx8IFxcXCJkcmFnRHJvcFxcXCIgaW4gZGl2XFxufSgpXFxuXFxudmFyIHp3c3BTdXBwb3J0ZWRcXG5mdW5jdGlvbiB6ZXJvV2lkdGhFbGVtZW50KG1lYXN1cmUpIHtcXG4gIGlmICh6d3NwU3VwcG9ydGVkID09IG51bGwpIHtcXG4gICAgdmFyIHRlc3QgPSBlbHQoXFxcInNwYW5cXFwiLCBcXFwiXFxcXHUyMDBiXFxcIilcXG4gICAgcmVtb3ZlQ2hpbGRyZW5BbmRBZGQobWVhc3VyZSwgZWx0KFxcXCJzcGFuXFxcIiwgW3Rlc3QsIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFxcXCJ4XFxcIildKSlcXG4gICAgaWYgKG1lYXN1cmUuZmlyc3RDaGlsZC5vZmZzZXRIZWlnaHQgIT0gMClcXG4gICAgICB7IHp3c3BTdXBwb3J0ZWQgPSB0ZXN0Lm9mZnNldFdpZHRoIDw9IDEgJiYgdGVzdC5vZmZzZXRIZWlnaHQgPiAyICYmICEoaWUgJiYgaWVfdmVyc2lvbiA8IDgpIH1cXG4gIH1cXG4gIHZhciBub2RlID0gendzcFN1cHBvcnRlZCA/IGVsdChcXFwic3BhblxcXCIsIFxcXCJcXFxcdTIwMGJcXFwiKSA6XFxuICAgIGVsdChcXFwic3BhblxcXCIsIFxcXCJcXFxcdTAwYTBcXFwiLCBudWxsLCBcXFwiZGlzcGxheTogaW5saW5lLWJsb2NrOyB3aWR0aDogMXB4OyBtYXJnaW4tcmlnaHQ6IC0xcHhcXFwiKVxcbiAgbm9kZS5zZXRBdHRyaWJ1dGUoXFxcImNtLXRleHRcXFwiLCBcXFwiXFxcIilcXG4gIHJldHVybiBub2RlXFxufVxcblxcbi8vIEZlYXR1cmUtZGV0ZWN0IElFJ3MgY3J1bW15IGNsaWVudCByZWN0IHJlcG9ydGluZyBmb3IgYmlkaSB0ZXh0XFxudmFyIGJhZEJpZGlSZWN0c1xcbmZ1bmN0aW9uIGhhc0JhZEJpZGlSZWN0cyhtZWFzdXJlKSB7XFxuICBpZiAoYmFkQmlkaVJlY3RzICE9IG51bGwpIHsgcmV0dXJuIGJhZEJpZGlSZWN0cyB9XFxuICB2YXIgdHh0ID0gcmVtb3ZlQ2hpbGRyZW5BbmRBZGQobWVhc3VyZSwgZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXFxcIkFcXFxcdTA2MmVBXFxcIikpXFxuICB2YXIgcjAgPSByYW5nZSh0eHQsIDAsIDEpLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXFxuICB2YXIgcjEgPSByYW5nZSh0eHQsIDEsIDIpLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXFxuICByZW1vdmVDaGlsZHJlbihtZWFzdXJlKVxcbiAgaWYgKCFyMCB8fCByMC5sZWZ0ID09IHIwLnJpZ2h0KSB7IHJldHVybiBmYWxzZSB9IC8vIFNhZmFyaSByZXR1cm5zIG51bGwgaW4gc29tZSBjYXNlcyAoIzI3ODApXFxuICByZXR1cm4gYmFkQmlkaVJlY3RzID0gKHIxLnJpZ2h0IC0gcjAucmlnaHQgPCAzKVxcbn1cXG5cXG4vLyBTZWUgaWYgXFxcIlxcXCIuc3BsaXQgaXMgdGhlIGJyb2tlbiBJRSB2ZXJzaW9uLCBpZiBzbywgcHJvdmlkZSBhblxcbi8vIGFsdGVybmF0aXZlIHdheSB0byBzcGxpdCBsaW5lcy5cXG52YXIgc3BsaXRMaW5lc0F1dG8gPSBcXFwiXFxcXG5cXFxcbmJcXFwiLnNwbGl0KC9cXFxcbi8pLmxlbmd0aCAhPSAzID8gZnVuY3Rpb24gKHN0cmluZykge1xcbiAgdmFyIHBvcyA9IDAsIHJlc3VsdCA9IFtdLCBsID0gc3RyaW5nLmxlbmd0aFxcbiAgd2hpbGUgKHBvcyA8PSBsKSB7XFxuICAgIHZhciBubCA9IHN0cmluZy5pbmRleE9mKFxcXCJcXFxcblxcXCIsIHBvcylcXG4gICAgaWYgKG5sID09IC0xKSB7IG5sID0gc3RyaW5nLmxlbmd0aCB9XFxuICAgIHZhciBsaW5lID0gc3RyaW5nLnNsaWNlKHBvcywgc3RyaW5nLmNoYXJBdChubCAtIDEpID09IFxcXCJcXFxcclxcXCIgPyBubCAtIDEgOiBubClcXG4gICAgdmFyIHJ0ID0gbGluZS5pbmRleE9mKFxcXCJcXFxcclxcXCIpXFxuICAgIGlmIChydCAhPSAtMSkge1xcbiAgICAgIHJlc3VsdC5wdXNoKGxpbmUuc2xpY2UoMCwgcnQpKVxcbiAgICAgIHBvcyArPSBydCArIDFcXG4gICAgfSBlbHNlIHtcXG4gICAgICByZXN1bHQucHVzaChsaW5lKVxcbiAgICAgIHBvcyA9IG5sICsgMVxcbiAgICB9XFxuICB9XFxuICByZXR1cm4gcmVzdWx0XFxufSA6IGZ1bmN0aW9uIChzdHJpbmcpIHsgcmV0dXJuIHN0cmluZy5zcGxpdCgvXFxcXHJcXFxcbj98XFxcXG4vKTsgfVxcblxcbnZhciBoYXNTZWxlY3Rpb24gPSB3aW5kb3cuZ2V0U2VsZWN0aW9uID8gZnVuY3Rpb24gKHRlKSB7XFxuICB0cnkgeyByZXR1cm4gdGUuc2VsZWN0aW9uU3RhcnQgIT0gdGUuc2VsZWN0aW9uRW5kIH1cXG4gIGNhdGNoKGUpIHsgcmV0dXJuIGZhbHNlIH1cXG59IDogZnVuY3Rpb24gKHRlKSB7XFxuICB2YXIgcmFuZ2VcXG4gIHRyeSB7cmFuZ2UgPSB0ZS5vd25lckRvY3VtZW50LnNlbGVjdGlvbi5jcmVhdGVSYW5nZSgpfVxcbiAgY2F0Y2goZSkge31cXG4gIGlmICghcmFuZ2UgfHwgcmFuZ2UucGFyZW50RWxlbWVudCgpICE9IHRlKSB7IHJldHVybiBmYWxzZSB9XFxuICByZXR1cm4gcmFuZ2UuY29tcGFyZUVuZFBvaW50cyhcXFwiU3RhcnRUb0VuZFxcXCIsIHJhbmdlKSAhPSAwXFxufVxcblxcbnZhciBoYXNDb3B5RXZlbnQgPSAoZnVuY3Rpb24gKCkge1xcbiAgdmFyIGUgPSBlbHQoXFxcImRpdlxcXCIpXFxuICBpZiAoXFxcIm9uY29weVxcXCIgaW4gZSkgeyByZXR1cm4gdHJ1ZSB9XFxuICBlLnNldEF0dHJpYnV0ZShcXFwib25jb3B5XFxcIiwgXFxcInJldHVybjtcXFwiKVxcbiAgcmV0dXJuIHR5cGVvZiBlLm9uY29weSA9PSBcXFwiZnVuY3Rpb25cXFwiXFxufSkoKVxcblxcbnZhciBiYWRab29tZWRSZWN0cyA9IG51bGxcXG5mdW5jdGlvbiBoYXNCYWRab29tZWRSZWN0cyhtZWFzdXJlKSB7XFxuICBpZiAoYmFkWm9vbWVkUmVjdHMgIT0gbnVsbCkgeyByZXR1cm4gYmFkWm9vbWVkUmVjdHMgfVxcbiAgdmFyIG5vZGUgPSByZW1vdmVDaGlsZHJlbkFuZEFkZChtZWFzdXJlLCBlbHQoXFxcInNwYW5cXFwiLCBcXFwieFxcXCIpKVxcbiAgdmFyIG5vcm1hbCA9IG5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClcXG4gIHZhciBmcm9tUmFuZ2UgPSByYW5nZShub2RlLCAwLCAxKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxcbiAgcmV0dXJuIGJhZFpvb21lZFJlY3RzID0gTWF0aC5hYnMobm9ybWFsLmxlZnQgLSBmcm9tUmFuZ2UubGVmdCkgPiAxXFxufVxcblxcbnZhciBtb2RlcyA9IHt9O1xcbnZhciBtaW1lTW9kZXMgPSB7fTtcXG4vLyBFeHRyYSBhcmd1bWVudHMgYXJlIHN0b3JlZCBhcyB0aGUgbW9kZSdzIGRlcGVuZGVuY2llcywgd2hpY2ggaXNcXG4vLyB1c2VkIGJ5IChsZWdhY3kpIG1lY2hhbmlzbXMgbGlrZSBsb2FkbW9kZS5qcyB0byBhdXRvbWF0aWNhbGx5XFxuLy8gbG9hZCBhIG1vZGUuIChQcmVmZXJyZWQgbWVjaGFuaXNtIGlzIHRoZSByZXF1aXJlL2RlZmluZSBjYWxscy4pXFxuZnVuY3Rpb24gZGVmaW5lTW9kZShuYW1lLCBtb2RlKSB7XFxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDIpXFxuICAgIHsgbW9kZS5kZXBlbmRlbmNpZXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpIH1cXG4gIG1vZGVzW25hbWVdID0gbW9kZVxcbn1cXG5cXG5mdW5jdGlvbiBkZWZpbmVNSU1FKG1pbWUsIHNwZWMpIHtcXG4gIG1pbWVNb2Rlc1ttaW1lXSA9IHNwZWNcXG59XFxuXFxuLy8gR2l2ZW4gYSBNSU1FIHR5cGUsIGEge25hbWUsIC4uLm9wdGlvbnN9IGNvbmZpZyBvYmplY3QsIG9yIGEgbmFtZVxcbi8vIHN0cmluZywgcmV0dXJuIGEgbW9kZSBjb25maWcgb2JqZWN0LlxcbmZ1bmN0aW9uIHJlc29sdmVNb2RlKHNwZWMpIHtcXG4gIGlmICh0eXBlb2Ygc3BlYyA9PSBcXFwic3RyaW5nXFxcIiAmJiBtaW1lTW9kZXMuaGFzT3duUHJvcGVydHkoc3BlYykpIHtcXG4gICAgc3BlYyA9IG1pbWVNb2Rlc1tzcGVjXVxcbiAgfSBlbHNlIGlmIChzcGVjICYmIHR5cGVvZiBzcGVjLm5hbWUgPT0gXFxcInN0cmluZ1xcXCIgJiYgbWltZU1vZGVzLmhhc093blByb3BlcnR5KHNwZWMubmFtZSkpIHtcXG4gICAgdmFyIGZvdW5kID0gbWltZU1vZGVzW3NwZWMubmFtZV1cXG4gICAgaWYgKHR5cGVvZiBmb3VuZCA9PSBcXFwic3RyaW5nXFxcIikgeyBmb3VuZCA9IHtuYW1lOiBmb3VuZH0gfVxcbiAgICBzcGVjID0gY3JlYXRlT2JqKGZvdW5kLCBzcGVjKVxcbiAgICBzcGVjLm5hbWUgPSBmb3VuZC5uYW1lXFxuICB9IGVsc2UgaWYgKHR5cGVvZiBzcGVjID09IFxcXCJzdHJpbmdcXFwiICYmIC9eW1xcXFx3XFxcXC1dK1xcXFwvW1xcXFx3XFxcXC1dK1xcXFwreG1sJC8udGVzdChzcGVjKSkge1xcbiAgICByZXR1cm4gcmVzb2x2ZU1vZGUoXFxcImFwcGxpY2F0aW9uL3htbFxcXCIpXFxuICB9IGVsc2UgaWYgKHR5cGVvZiBzcGVjID09IFxcXCJzdHJpbmdcXFwiICYmIC9eW1xcXFx3XFxcXC1dK1xcXFwvW1xcXFx3XFxcXC1dK1xcXFwranNvbiQvLnRlc3Qoc3BlYykpIHtcXG4gICAgcmV0dXJuIHJlc29sdmVNb2RlKFxcXCJhcHBsaWNhdGlvbi9qc29uXFxcIilcXG4gIH1cXG4gIGlmICh0eXBlb2Ygc3BlYyA9PSBcXFwic3RyaW5nXFxcIikgeyByZXR1cm4ge25hbWU6IHNwZWN9IH1cXG4gIGVsc2UgeyByZXR1cm4gc3BlYyB8fCB7bmFtZTogXFxcIm51bGxcXFwifSB9XFxufVxcblxcbi8vIEdpdmVuIGEgbW9kZSBzcGVjIChhbnl0aGluZyB0aGF0IHJlc29sdmVNb2RlIGFjY2VwdHMpLCBmaW5kIGFuZFxcbi8vIGluaXRpYWxpemUgYW4gYWN0dWFsIG1vZGUgb2JqZWN0LlxcbmZ1bmN0aW9uIGdldE1vZGUob3B0aW9ucywgc3BlYykge1xcbiAgc3BlYyA9IHJlc29sdmVNb2RlKHNwZWMpXFxuICB2YXIgbWZhY3RvcnkgPSBtb2Rlc1tzcGVjLm5hbWVdXFxuICBpZiAoIW1mYWN0b3J5KSB7IHJldHVybiBnZXRNb2RlKG9wdGlvbnMsIFxcXCJ0ZXh0L3BsYWluXFxcIikgfVxcbiAgdmFyIG1vZGVPYmogPSBtZmFjdG9yeShvcHRpb25zLCBzcGVjKVxcbiAgaWYgKG1vZGVFeHRlbnNpb25zLmhhc093blByb3BlcnR5KHNwZWMubmFtZSkpIHtcXG4gICAgdmFyIGV4dHMgPSBtb2RlRXh0ZW5zaW9uc1tzcGVjLm5hbWVdXFxuICAgIGZvciAodmFyIHByb3AgaW4gZXh0cykge1xcbiAgICAgIGlmICghZXh0cy5oYXNPd25Qcm9wZXJ0eShwcm9wKSkgeyBjb250aW51ZSB9XFxuICAgICAgaWYgKG1vZGVPYmouaGFzT3duUHJvcGVydHkocHJvcCkpIHsgbW9kZU9ialtcXFwiX1xcXCIgKyBwcm9wXSA9IG1vZGVPYmpbcHJvcF0gfVxcbiAgICAgIG1vZGVPYmpbcHJvcF0gPSBleHRzW3Byb3BdXFxuICAgIH1cXG4gIH1cXG4gIG1vZGVPYmoubmFtZSA9IHNwZWMubmFtZVxcbiAgaWYgKHNwZWMuaGVscGVyVHlwZSkgeyBtb2RlT2JqLmhlbHBlclR5cGUgPSBzcGVjLmhlbHBlclR5cGUgfVxcbiAgaWYgKHNwZWMubW9kZVByb3BzKSB7IGZvciAodmFyIHByb3AkMSBpbiBzcGVjLm1vZGVQcm9wcylcXG4gICAgeyBtb2RlT2JqW3Byb3AkMV0gPSBzcGVjLm1vZGVQcm9wc1twcm9wJDFdIH0gfVxcblxcbiAgcmV0dXJuIG1vZGVPYmpcXG59XFxuXFxuLy8gVGhpcyBjYW4gYmUgdXNlZCB0byBhdHRhY2ggcHJvcGVydGllcyB0byBtb2RlIG9iamVjdHMgZnJvbVxcbi8vIG91dHNpZGUgdGhlIGFjdHVhbCBtb2RlIGRlZmluaXRpb24uXFxudmFyIG1vZGVFeHRlbnNpb25zID0ge31cXG5mdW5jdGlvbiBleHRlbmRNb2RlKG1vZGUsIHByb3BlcnRpZXMpIHtcXG4gIHZhciBleHRzID0gbW9kZUV4dGVuc2lvbnMuaGFzT3duUHJvcGVydHkobW9kZSkgPyBtb2RlRXh0ZW5zaW9uc1ttb2RlXSA6IChtb2RlRXh0ZW5zaW9uc1ttb2RlXSA9IHt9KVxcbiAgY29weU9iaihwcm9wZXJ0aWVzLCBleHRzKVxcbn1cXG5cXG5mdW5jdGlvbiBjb3B5U3RhdGUobW9kZSwgc3RhdGUpIHtcXG4gIGlmIChzdGF0ZSA9PT0gdHJ1ZSkgeyByZXR1cm4gc3RhdGUgfVxcbiAgaWYgKG1vZGUuY29weVN0YXRlKSB7IHJldHVybiBtb2RlLmNvcHlTdGF0ZShzdGF0ZSkgfVxcbiAgdmFyIG5zdGF0ZSA9IHt9XFxuICBmb3IgKHZhciBuIGluIHN0YXRlKSB7XFxuICAgIHZhciB2YWwgPSBzdGF0ZVtuXVxcbiAgICBpZiAodmFsIGluc3RhbmNlb2YgQXJyYXkpIHsgdmFsID0gdmFsLmNvbmNhdChbXSkgfVxcbiAgICBuc3RhdGVbbl0gPSB2YWxcXG4gIH1cXG4gIHJldHVybiBuc3RhdGVcXG59XFxuXFxuLy8gR2l2ZW4gYSBtb2RlIGFuZCBhIHN0YXRlIChmb3IgdGhhdCBtb2RlKSwgZmluZCB0aGUgaW5uZXIgbW9kZSBhbmRcXG4vLyBzdGF0ZSBhdCB0aGUgcG9zaXRpb24gdGhhdCB0aGUgc3RhdGUgcmVmZXJzIHRvLlxcbmZ1bmN0aW9uIGlubmVyTW9kZShtb2RlLCBzdGF0ZSkge1xcbiAgdmFyIGluZm9cXG4gIHdoaWxlIChtb2RlLmlubmVyTW9kZSkge1xcbiAgICBpbmZvID0gbW9kZS5pbm5lck1vZGUoc3RhdGUpXFxuICAgIGlmICghaW5mbyB8fCBpbmZvLm1vZGUgPT0gbW9kZSkgeyBicmVhayB9XFxuICAgIHN0YXRlID0gaW5mby5zdGF0ZVxcbiAgICBtb2RlID0gaW5mby5tb2RlXFxuICB9XFxuICByZXR1cm4gaW5mbyB8fCB7bW9kZTogbW9kZSwgc3RhdGU6IHN0YXRlfVxcbn1cXG5cXG5mdW5jdGlvbiBzdGFydFN0YXRlKG1vZGUsIGExLCBhMikge1xcbiAgcmV0dXJuIG1vZGUuc3RhcnRTdGF0ZSA/IG1vZGUuc3RhcnRTdGF0ZShhMSwgYTIpIDogdHJ1ZVxcbn1cXG5cXG4vLyBTVFJJTkcgU1RSRUFNXFxuXFxuLy8gRmVkIHRvIHRoZSBtb2RlIHBhcnNlcnMsIHByb3ZpZGVzIGhlbHBlciBmdW5jdGlvbnMgdG8gbWFrZVxcbi8vIHBhcnNlcnMgbW9yZSBzdWNjaW5jdC5cXG5cXG52YXIgU3RyaW5nU3RyZWFtID0gZnVuY3Rpb24oc3RyaW5nLCB0YWJTaXplKSB7XFxuICB0aGlzLnBvcyA9IHRoaXMuc3RhcnQgPSAwXFxuICB0aGlzLnN0cmluZyA9IHN0cmluZ1xcbiAgdGhpcy50YWJTaXplID0gdGFiU2l6ZSB8fCA4XFxuICB0aGlzLmxhc3RDb2x1bW5Qb3MgPSB0aGlzLmxhc3RDb2x1bW5WYWx1ZSA9IDBcXG4gIHRoaXMubGluZVN0YXJ0ID0gMFxcbn07XFxuXFxuU3RyaW5nU3RyZWFtLnByb3RvdHlwZS5lb2wgPSBmdW5jdGlvbiAoKSB7cmV0dXJuIHRoaXMucG9zID49IHRoaXMuc3RyaW5nLmxlbmd0aH07XFxuU3RyaW5nU3RyZWFtLnByb3RvdHlwZS5zb2wgPSBmdW5jdGlvbiAoKSB7cmV0dXJuIHRoaXMucG9zID09IHRoaXMubGluZVN0YXJ0fTtcXG5TdHJpbmdTdHJlYW0ucHJvdG90eXBlLnBlZWsgPSBmdW5jdGlvbiAoKSB7cmV0dXJuIHRoaXMuc3RyaW5nLmNoYXJBdCh0aGlzLnBvcykgfHwgdW5kZWZpbmVkfTtcXG5TdHJpbmdTdHJlYW0ucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoKSB7XFxuICBpZiAodGhpcy5wb3MgPCB0aGlzLnN0cmluZy5sZW5ndGgpXFxuICAgIHsgcmV0dXJuIHRoaXMuc3RyaW5nLmNoYXJBdCh0aGlzLnBvcysrKSB9XFxufTtcXG5TdHJpbmdTdHJlYW0ucHJvdG90eXBlLmVhdCA9IGZ1bmN0aW9uIChtYXRjaCkge1xcbiAgdmFyIGNoID0gdGhpcy5zdHJpbmcuY2hhckF0KHRoaXMucG9zKVxcbiAgdmFyIG9rXFxuICBpZiAodHlwZW9mIG1hdGNoID09IFxcXCJzdHJpbmdcXFwiKSB7IG9rID0gY2ggPT0gbWF0Y2ggfVxcbiAgZWxzZSB7IG9rID0gY2ggJiYgKG1hdGNoLnRlc3QgPyBtYXRjaC50ZXN0KGNoKSA6IG1hdGNoKGNoKSkgfVxcbiAgaWYgKG9rKSB7Kyt0aGlzLnBvczsgcmV0dXJuIGNofVxcbn07XFxuU3RyaW5nU3RyZWFtLnByb3RvdHlwZS5lYXRXaGlsZSA9IGZ1bmN0aW9uIChtYXRjaCkge1xcbiAgdmFyIHN0YXJ0ID0gdGhpcy5wb3NcXG4gIHdoaWxlICh0aGlzLmVhdChtYXRjaCkpe31cXG4gIHJldHVybiB0aGlzLnBvcyA+IHN0YXJ0XFxufTtcXG5TdHJpbmdTdHJlYW0ucHJvdG90eXBlLmVhdFNwYWNlID0gZnVuY3Rpb24gKCkge1xcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcXG5cXG4gIHZhciBzdGFydCA9IHRoaXMucG9zXFxuICB3aGlsZSAoL1tcXFxcc1xcXFx1MDBhMF0vLnRlc3QodGhpcy5zdHJpbmcuY2hhckF0KHRoaXMucG9zKSkpIHsgKyt0aGlzJDEucG9zIH1cXG4gIHJldHVybiB0aGlzLnBvcyA+IHN0YXJ0XFxufTtcXG5TdHJpbmdTdHJlYW0ucHJvdG90eXBlLnNraXBUb0VuZCA9IGZ1bmN0aW9uICgpIHt0aGlzLnBvcyA9IHRoaXMuc3RyaW5nLmxlbmd0aH07XFxuU3RyaW5nU3RyZWFtLnByb3RvdHlwZS5za2lwVG8gPSBmdW5jdGlvbiAoY2gpIHtcXG4gIHZhciBmb3VuZCA9IHRoaXMuc3RyaW5nLmluZGV4T2YoY2gsIHRoaXMucG9zKVxcbiAgaWYgKGZvdW5kID4gLTEpIHt0aGlzLnBvcyA9IGZvdW5kOyByZXR1cm4gdHJ1ZX1cXG59O1xcblN0cmluZ1N0cmVhbS5wcm90b3R5cGUuYmFja1VwID0gZnVuY3Rpb24gKG4pIHt0aGlzLnBvcyAtPSBufTtcXG5TdHJpbmdTdHJlYW0ucHJvdG90eXBlLmNvbHVtbiA9IGZ1bmN0aW9uICgpIHtcXG4gIGlmICh0aGlzLmxhc3RDb2x1bW5Qb3MgPCB0aGlzLnN0YXJ0KSB7XFxuICAgIHRoaXMubGFzdENvbHVtblZhbHVlID0gY291bnRDb2x1bW4odGhpcy5zdHJpbmcsIHRoaXMuc3RhcnQsIHRoaXMudGFiU2l6ZSwgdGhpcy5sYXN0Q29sdW1uUG9zLCB0aGlzLmxhc3RDb2x1bW5WYWx1ZSlcXG4gICAgdGhpcy5sYXN0Q29sdW1uUG9zID0gdGhpcy5zdGFydFxcbiAgfVxcbiAgcmV0dXJuIHRoaXMubGFzdENvbHVtblZhbHVlIC0gKHRoaXMubGluZVN0YXJ0ID8gY291bnRDb2x1bW4odGhpcy5zdHJpbmcsIHRoaXMubGluZVN0YXJ0LCB0aGlzLnRhYlNpemUpIDogMClcXG59O1xcblN0cmluZ1N0cmVhbS5wcm90b3R5cGUuaW5kZW50YXRpb24gPSBmdW5jdGlvbiAoKSB7XFxuICByZXR1cm4gY291bnRDb2x1bW4odGhpcy5zdHJpbmcsIG51bGwsIHRoaXMudGFiU2l6ZSkgLVxcbiAgICAodGhpcy5saW5lU3RhcnQgPyBjb3VudENvbHVtbih0aGlzLnN0cmluZywgdGhpcy5saW5lU3RhcnQsIHRoaXMudGFiU2l6ZSkgOiAwKVxcbn07XFxuU3RyaW5nU3RyZWFtLnByb3RvdHlwZS5tYXRjaCA9IGZ1bmN0aW9uIChwYXR0ZXJuLCBjb25zdW1lLCBjYXNlSW5zZW5zaXRpdmUpIHtcXG4gIGlmICh0eXBlb2YgcGF0dGVybiA9PSBcXFwic3RyaW5nXFxcIikge1xcbiAgICB2YXIgY2FzZWQgPSBmdW5jdGlvbiAoc3RyKSB7IHJldHVybiBjYXNlSW5zZW5zaXRpdmUgPyBzdHIudG9Mb3dlckNhc2UoKSA6IHN0cjsgfVxcbiAgICB2YXIgc3Vic3RyID0gdGhpcy5zdHJpbmcuc3Vic3RyKHRoaXMucG9zLCBwYXR0ZXJuLmxlbmd0aClcXG4gICAgaWYgKGNhc2VkKHN1YnN0cikgPT0gY2FzZWQocGF0dGVybikpIHtcXG4gICAgICBpZiAoY29uc3VtZSAhPT0gZmFsc2UpIHsgdGhpcy5wb3MgKz0gcGF0dGVybi5sZW5ndGggfVxcbiAgICAgIHJldHVybiB0cnVlXFxuICAgIH1cXG4gIH0gZWxzZSB7XFxuICAgIHZhciBtYXRjaCA9IHRoaXMuc3RyaW5nLnNsaWNlKHRoaXMucG9zKS5tYXRjaChwYXR0ZXJuKVxcbiAgICBpZiAobWF0Y2ggJiYgbWF0Y2guaW5kZXggPiAwKSB7IHJldHVybiBudWxsIH1cXG4gICAgaWYgKG1hdGNoICYmIGNvbnN1bWUgIT09IGZhbHNlKSB7IHRoaXMucG9zICs9IG1hdGNoWzBdLmxlbmd0aCB9XFxuICAgIHJldHVybiBtYXRjaFxcbiAgfVxcbn07XFxuU3RyaW5nU3RyZWFtLnByb3RvdHlwZS5jdXJyZW50ID0gZnVuY3Rpb24gKCl7cmV0dXJuIHRoaXMuc3RyaW5nLnNsaWNlKHRoaXMuc3RhcnQsIHRoaXMucG9zKX07XFxuU3RyaW5nU3RyZWFtLnByb3RvdHlwZS5oaWRlRmlyc3RDaGFycyA9IGZ1bmN0aW9uIChuLCBpbm5lcikge1xcbiAgdGhpcy5saW5lU3RhcnQgKz0gblxcbiAgdHJ5IHsgcmV0dXJuIGlubmVyKCkgfVxcbiAgZmluYWxseSB7IHRoaXMubGluZVN0YXJ0IC09IG4gfVxcbn07XFxuXFxuLy8gQ29tcHV0ZSBhIHN0eWxlIGFycmF5IChhbiBhcnJheSBzdGFydGluZyB3aXRoIGEgbW9kZSBnZW5lcmF0aW9uXFxuLy8gLS0gZm9yIGludmFsaWRhdGlvbiAtLSBmb2xsb3dlZCBieSBwYWlycyBvZiBlbmQgcG9zaXRpb25zIGFuZFxcbi8vIHN0eWxlIHN0cmluZ3MpLCB3aGljaCBpcyB1c2VkIHRvIGhpZ2hsaWdodCB0aGUgdG9rZW5zIG9uIHRoZVxcbi8vIGxpbmUuXFxuZnVuY3Rpb24gaGlnaGxpZ2h0TGluZShjbSwgbGluZSwgc3RhdGUsIGZvcmNlVG9FbmQpIHtcXG4gIC8vIEEgc3R5bGVzIGFycmF5IGFsd2F5cyBzdGFydHMgd2l0aCBhIG51bWJlciBpZGVudGlmeWluZyB0aGVcXG4gIC8vIG1vZGUvb3ZlcmxheXMgdGhhdCBpdCBpcyBiYXNlZCBvbiAoZm9yIGVhc3kgaW52YWxpZGF0aW9uKS5cXG4gIHZhciBzdCA9IFtjbS5zdGF0ZS5tb2RlR2VuXSwgbGluZUNsYXNzZXMgPSB7fVxcbiAgLy8gQ29tcHV0ZSB0aGUgYmFzZSBhcnJheSBvZiBzdHlsZXNcXG4gIHJ1bk1vZGUoY20sIGxpbmUudGV4dCwgY20uZG9jLm1vZGUsIHN0YXRlLCBmdW5jdGlvbiAoZW5kLCBzdHlsZSkgeyByZXR1cm4gc3QucHVzaChlbmQsIHN0eWxlKTsgfSxcXG4gICAgbGluZUNsYXNzZXMsIGZvcmNlVG9FbmQpXFxuXFxuICAvLyBSdW4gb3ZlcmxheXMsIGFkanVzdCBzdHlsZSBhcnJheS5cXG4gIHZhciBsb29wID0gZnVuY3Rpb24gKCBvICkge1xcbiAgICB2YXIgb3ZlcmxheSA9IGNtLnN0YXRlLm92ZXJsYXlzW29dLCBpID0gMSwgYXQgPSAwXFxuICAgIHJ1bk1vZGUoY20sIGxpbmUudGV4dCwgb3ZlcmxheS5tb2RlLCB0cnVlLCBmdW5jdGlvbiAoZW5kLCBzdHlsZSkge1xcbiAgICAgIHZhciBzdGFydCA9IGlcXG4gICAgICAvLyBFbnN1cmUgdGhlcmUncyBhIHRva2VuIGVuZCBhdCB0aGUgY3VycmVudCBwb3NpdGlvbiwgYW5kIHRoYXQgaSBwb2ludHMgYXQgaXRcXG4gICAgICB3aGlsZSAoYXQgPCBlbmQpIHtcXG4gICAgICAgIHZhciBpX2VuZCA9IHN0W2ldXFxuICAgICAgICBpZiAoaV9lbmQgPiBlbmQpXFxuICAgICAgICAgIHsgc3Quc3BsaWNlKGksIDEsIGVuZCwgc3RbaSsxXSwgaV9lbmQpIH1cXG4gICAgICAgIGkgKz0gMlxcbiAgICAgICAgYXQgPSBNYXRoLm1pbihlbmQsIGlfZW5kKVxcbiAgICAgIH1cXG4gICAgICBpZiAoIXN0eWxlKSB7IHJldHVybiB9XFxuICAgICAgaWYgKG92ZXJsYXkub3BhcXVlKSB7XFxuICAgICAgICBzdC5zcGxpY2Uoc3RhcnQsIGkgLSBzdGFydCwgZW5kLCBcXFwib3ZlcmxheSBcXFwiICsgc3R5bGUpXFxuICAgICAgICBpID0gc3RhcnQgKyAyXFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIGZvciAoOyBzdGFydCA8IGk7IHN0YXJ0ICs9IDIpIHtcXG4gICAgICAgICAgdmFyIGN1ciA9IHN0W3N0YXJ0KzFdXFxuICAgICAgICAgIHN0W3N0YXJ0KzFdID0gKGN1ciA/IGN1ciArIFxcXCIgXFxcIiA6IFxcXCJcXFwiKSArIFxcXCJvdmVybGF5IFxcXCIgKyBzdHlsZVxcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgfSwgbGluZUNsYXNzZXMpXFxuICB9O1xcblxcbiAgZm9yICh2YXIgbyA9IDA7IG8gPCBjbS5zdGF0ZS5vdmVybGF5cy5sZW5ndGg7ICsrbykgbG9vcCggbyApO1xcblxcbiAgcmV0dXJuIHtzdHlsZXM6IHN0LCBjbGFzc2VzOiBsaW5lQ2xhc3Nlcy5iZ0NsYXNzIHx8IGxpbmVDbGFzc2VzLnRleHRDbGFzcyA/IGxpbmVDbGFzc2VzIDogbnVsbH1cXG59XFxuXFxuZnVuY3Rpb24gZ2V0TGluZVN0eWxlcyhjbSwgbGluZSwgdXBkYXRlRnJvbnRpZXIpIHtcXG4gIGlmICghbGluZS5zdHlsZXMgfHwgbGluZS5zdHlsZXNbMF0gIT0gY20uc3RhdGUubW9kZUdlbikge1xcbiAgICB2YXIgc3RhdGUgPSBnZXRTdGF0ZUJlZm9yZShjbSwgbGluZU5vKGxpbmUpKVxcbiAgICB2YXIgcmVzdWx0ID0gaGlnaGxpZ2h0TGluZShjbSwgbGluZSwgbGluZS50ZXh0Lmxlbmd0aCA+IGNtLm9wdGlvbnMubWF4SGlnaGxpZ2h0TGVuZ3RoID8gY29weVN0YXRlKGNtLmRvYy5tb2RlLCBzdGF0ZSkgOiBzdGF0ZSlcXG4gICAgbGluZS5zdGF0ZUFmdGVyID0gc3RhdGVcXG4gICAgbGluZS5zdHlsZXMgPSByZXN1bHQuc3R5bGVzXFxuICAgIGlmIChyZXN1bHQuY2xhc3NlcykgeyBsaW5lLnN0eWxlQ2xhc3NlcyA9IHJlc3VsdC5jbGFzc2VzIH1cXG4gICAgZWxzZSBpZiAobGluZS5zdHlsZUNsYXNzZXMpIHsgbGluZS5zdHlsZUNsYXNzZXMgPSBudWxsIH1cXG4gICAgaWYgKHVwZGF0ZUZyb250aWVyID09PSBjbS5kb2MuZnJvbnRpZXIpIHsgY20uZG9jLmZyb250aWVyKysgfVxcbiAgfVxcbiAgcmV0dXJuIGxpbmUuc3R5bGVzXFxufVxcblxcbmZ1bmN0aW9uIGdldFN0YXRlQmVmb3JlKGNtLCBuLCBwcmVjaXNlKSB7XFxuICB2YXIgZG9jID0gY20uZG9jLCBkaXNwbGF5ID0gY20uZGlzcGxheVxcbiAgaWYgKCFkb2MubW9kZS5zdGFydFN0YXRlKSB7IHJldHVybiB0cnVlIH1cXG4gIHZhciBwb3MgPSBmaW5kU3RhcnRMaW5lKGNtLCBuLCBwcmVjaXNlKSwgc3RhdGUgPSBwb3MgPiBkb2MuZmlyc3QgJiYgZ2V0TGluZShkb2MsIHBvcy0xKS5zdGF0ZUFmdGVyXFxuICBpZiAoIXN0YXRlKSB7IHN0YXRlID0gc3RhcnRTdGF0ZShkb2MubW9kZSkgfVxcbiAgZWxzZSB7IHN0YXRlID0gY29weVN0YXRlKGRvYy5tb2RlLCBzdGF0ZSkgfVxcbiAgZG9jLml0ZXIocG9zLCBuLCBmdW5jdGlvbiAobGluZSkge1xcbiAgICBwcm9jZXNzTGluZShjbSwgbGluZS50ZXh0LCBzdGF0ZSlcXG4gICAgdmFyIHNhdmUgPSBwb3MgPT0gbiAtIDEgfHwgcG9zICUgNSA9PSAwIHx8IHBvcyA+PSBkaXNwbGF5LnZpZXdGcm9tICYmIHBvcyA8IGRpc3BsYXkudmlld1RvXFxuICAgIGxpbmUuc3RhdGVBZnRlciA9IHNhdmUgPyBjb3B5U3RhdGUoZG9jLm1vZGUsIHN0YXRlKSA6IG51bGxcXG4gICAgKytwb3NcXG4gIH0pXFxuICBpZiAocHJlY2lzZSkgeyBkb2MuZnJvbnRpZXIgPSBwb3MgfVxcbiAgcmV0dXJuIHN0YXRlXFxufVxcblxcbi8vIExpZ2h0d2VpZ2h0IGZvcm0gb2YgaGlnaGxpZ2h0IC0tIHByb2NlZWQgb3ZlciB0aGlzIGxpbmUgYW5kXFxuLy8gdXBkYXRlIHN0YXRlLCBidXQgZG9uJ3Qgc2F2ZSBhIHN0eWxlIGFycmF5LiBVc2VkIGZvciBsaW5lcyB0aGF0XFxuLy8gYXJlbid0IGN1cnJlbnRseSB2aXNpYmxlLlxcbmZ1bmN0aW9uIHByb2Nlc3NMaW5lKGNtLCB0ZXh0LCBzdGF0ZSwgc3RhcnRBdCkge1xcbiAgdmFyIG1vZGUgPSBjbS5kb2MubW9kZVxcbiAgdmFyIHN0cmVhbSA9IG5ldyBTdHJpbmdTdHJlYW0odGV4dCwgY20ub3B0aW9ucy50YWJTaXplKVxcbiAgc3RyZWFtLnN0YXJ0ID0gc3RyZWFtLnBvcyA9IHN0YXJ0QXQgfHwgMFxcbiAgaWYgKHRleHQgPT0gXFxcIlxcXCIpIHsgY2FsbEJsYW5rTGluZShtb2RlLCBzdGF0ZSkgfVxcbiAgd2hpbGUgKCFzdHJlYW0uZW9sKCkpIHtcXG4gICAgcmVhZFRva2VuKG1vZGUsIHN0cmVhbSwgc3RhdGUpXFxuICAgIHN0cmVhbS5zdGFydCA9IHN0cmVhbS5wb3NcXG4gIH1cXG59XFxuXFxuZnVuY3Rpb24gY2FsbEJsYW5rTGluZShtb2RlLCBzdGF0ZSkge1xcbiAgaWYgKG1vZGUuYmxhbmtMaW5lKSB7IHJldHVybiBtb2RlLmJsYW5rTGluZShzdGF0ZSkgfVxcbiAgaWYgKCFtb2RlLmlubmVyTW9kZSkgeyByZXR1cm4gfVxcbiAgdmFyIGlubmVyID0gaW5uZXJNb2RlKG1vZGUsIHN0YXRlKVxcbiAgaWYgKGlubmVyLm1vZGUuYmxhbmtMaW5lKSB7IHJldHVybiBpbm5lci5tb2RlLmJsYW5rTGluZShpbm5lci5zdGF0ZSkgfVxcbn1cXG5cXG5mdW5jdGlvbiByZWFkVG9rZW4obW9kZSwgc3RyZWFtLCBzdGF0ZSwgaW5uZXIpIHtcXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgMTA7IGkrKykge1xcbiAgICBpZiAoaW5uZXIpIHsgaW5uZXJbMF0gPSBpbm5lck1vZGUobW9kZSwgc3RhdGUpLm1vZGUgfVxcbiAgICB2YXIgc3R5bGUgPSBtb2RlLnRva2VuKHN0cmVhbSwgc3RhdGUpXFxuICAgIGlmIChzdHJlYW0ucG9zID4gc3RyZWFtLnN0YXJ0KSB7IHJldHVybiBzdHlsZSB9XFxuICB9XFxuICB0aHJvdyBuZXcgRXJyb3IoXFxcIk1vZGUgXFxcIiArIG1vZGUubmFtZSArIFxcXCIgZmFpbGVkIHRvIGFkdmFuY2Ugc3RyZWFtLlxcXCIpXFxufVxcblxcbi8vIFV0aWxpdHkgZm9yIGdldFRva2VuQXQgYW5kIGdldExpbmVUb2tlbnNcXG5mdW5jdGlvbiB0YWtlVG9rZW4oY20sIHBvcywgcHJlY2lzZSwgYXNBcnJheSkge1xcbiAgdmFyIGdldE9iaiA9IGZ1bmN0aW9uIChjb3B5KSB7IHJldHVybiAoe1xcbiAgICBzdGFydDogc3RyZWFtLnN0YXJ0LCBlbmQ6IHN0cmVhbS5wb3MsXFxuICAgIHN0cmluZzogc3RyZWFtLmN1cnJlbnQoKSxcXG4gICAgdHlwZTogc3R5bGUgfHwgbnVsbCxcXG4gICAgc3RhdGU6IGNvcHkgPyBjb3B5U3RhdGUoZG9jLm1vZGUsIHN0YXRlKSA6IHN0YXRlXFxuICB9KTsgfVxcblxcbiAgdmFyIGRvYyA9IGNtLmRvYywgbW9kZSA9IGRvYy5tb2RlLCBzdHlsZVxcbiAgcG9zID0gY2xpcFBvcyhkb2MsIHBvcylcXG4gIHZhciBsaW5lID0gZ2V0TGluZShkb2MsIHBvcy5saW5lKSwgc3RhdGUgPSBnZXRTdGF0ZUJlZm9yZShjbSwgcG9zLmxpbmUsIHByZWNpc2UpXFxuICB2YXIgc3RyZWFtID0gbmV3IFN0cmluZ1N0cmVhbShsaW5lLnRleHQsIGNtLm9wdGlvbnMudGFiU2l6ZSksIHRva2Vuc1xcbiAgaWYgKGFzQXJyYXkpIHsgdG9rZW5zID0gW10gfVxcbiAgd2hpbGUgKChhc0FycmF5IHx8IHN0cmVhbS5wb3MgPCBwb3MuY2gpICYmICFzdHJlYW0uZW9sKCkpIHtcXG4gICAgc3RyZWFtLnN0YXJ0ID0gc3RyZWFtLnBvc1xcbiAgICBzdHlsZSA9IHJlYWRUb2tlbihtb2RlLCBzdHJlYW0sIHN0YXRlKVxcbiAgICBpZiAoYXNBcnJheSkgeyB0b2tlbnMucHVzaChnZXRPYmoodHJ1ZSkpIH1cXG4gIH1cXG4gIHJldHVybiBhc0FycmF5ID8gdG9rZW5zIDogZ2V0T2JqKClcXG59XFxuXFxuZnVuY3Rpb24gZXh0cmFjdExpbmVDbGFzc2VzKHR5cGUsIG91dHB1dCkge1xcbiAgaWYgKHR5cGUpIHsgZm9yICg7Oykge1xcbiAgICB2YXIgbGluZUNsYXNzID0gdHlwZS5tYXRjaCgvKD86XnxcXFxccyspbGluZS0oYmFja2dyb3VuZC0pPyhcXFxcUyspLylcXG4gICAgaWYgKCFsaW5lQ2xhc3MpIHsgYnJlYWsgfVxcbiAgICB0eXBlID0gdHlwZS5zbGljZSgwLCBsaW5lQ2xhc3MuaW5kZXgpICsgdHlwZS5zbGljZShsaW5lQ2xhc3MuaW5kZXggKyBsaW5lQ2xhc3NbMF0ubGVuZ3RoKVxcbiAgICB2YXIgcHJvcCA9IGxpbmVDbGFzc1sxXSA/IFxcXCJiZ0NsYXNzXFxcIiA6IFxcXCJ0ZXh0Q2xhc3NcXFwiXFxuICAgIGlmIChvdXRwdXRbcHJvcF0gPT0gbnVsbClcXG4gICAgICB7IG91dHB1dFtwcm9wXSA9IGxpbmVDbGFzc1syXSB9XFxuICAgIGVsc2UgaWYgKCEobmV3IFJlZ0V4cChcXFwiKD86XnxcXFxccylcXFwiICsgbGluZUNsYXNzWzJdICsgXFxcIig/OiR8XFxcXHMpXFxcIikpLnRlc3Qob3V0cHV0W3Byb3BdKSlcXG4gICAgICB7IG91dHB1dFtwcm9wXSArPSBcXFwiIFxcXCIgKyBsaW5lQ2xhc3NbMl0gfVxcbiAgfSB9XFxuICByZXR1cm4gdHlwZVxcbn1cXG5cXG4vLyBSdW4gdGhlIGdpdmVuIG1vZGUncyBwYXJzZXIgb3ZlciBhIGxpbmUsIGNhbGxpbmcgZiBmb3IgZWFjaCB0b2tlbi5cXG5mdW5jdGlvbiBydW5Nb2RlKGNtLCB0ZXh0LCBtb2RlLCBzdGF0ZSwgZiwgbGluZUNsYXNzZXMsIGZvcmNlVG9FbmQpIHtcXG4gIHZhciBmbGF0dGVuU3BhbnMgPSBtb2RlLmZsYXR0ZW5TcGFuc1xcbiAgaWYgKGZsYXR0ZW5TcGFucyA9PSBudWxsKSB7IGZsYXR0ZW5TcGFucyA9IGNtLm9wdGlvbnMuZmxhdHRlblNwYW5zIH1cXG4gIHZhciBjdXJTdGFydCA9IDAsIGN1clN0eWxlID0gbnVsbFxcbiAgdmFyIHN0cmVhbSA9IG5ldyBTdHJpbmdTdHJlYW0odGV4dCwgY20ub3B0aW9ucy50YWJTaXplKSwgc3R5bGVcXG4gIHZhciBpbm5lciA9IGNtLm9wdGlvbnMuYWRkTW9kZUNsYXNzICYmIFtudWxsXVxcbiAgaWYgKHRleHQgPT0gXFxcIlxcXCIpIHsgZXh0cmFjdExpbmVDbGFzc2VzKGNhbGxCbGFua0xpbmUobW9kZSwgc3RhdGUpLCBsaW5lQ2xhc3NlcykgfVxcbiAgd2hpbGUgKCFzdHJlYW0uZW9sKCkpIHtcXG4gICAgaWYgKHN0cmVhbS5wb3MgPiBjbS5vcHRpb25zLm1heEhpZ2hsaWdodExlbmd0aCkge1xcbiAgICAgIGZsYXR0ZW5TcGFucyA9IGZhbHNlXFxuICAgICAgaWYgKGZvcmNlVG9FbmQpIHsgcHJvY2Vzc0xpbmUoY20sIHRleHQsIHN0YXRlLCBzdHJlYW0ucG9zKSB9XFxuICAgICAgc3RyZWFtLnBvcyA9IHRleHQubGVuZ3RoXFxuICAgICAgc3R5bGUgPSBudWxsXFxuICAgIH0gZWxzZSB7XFxuICAgICAgc3R5bGUgPSBleHRyYWN0TGluZUNsYXNzZXMocmVhZFRva2VuKG1vZGUsIHN0cmVhbSwgc3RhdGUsIGlubmVyKSwgbGluZUNsYXNzZXMpXFxuICAgIH1cXG4gICAgaWYgKGlubmVyKSB7XFxuICAgICAgdmFyIG1OYW1lID0gaW5uZXJbMF0ubmFtZVxcbiAgICAgIGlmIChtTmFtZSkgeyBzdHlsZSA9IFxcXCJtLVxcXCIgKyAoc3R5bGUgPyBtTmFtZSArIFxcXCIgXFxcIiArIHN0eWxlIDogbU5hbWUpIH1cXG4gICAgfVxcbiAgICBpZiAoIWZsYXR0ZW5TcGFucyB8fCBjdXJTdHlsZSAhPSBzdHlsZSkge1xcbiAgICAgIHdoaWxlIChjdXJTdGFydCA8IHN0cmVhbS5zdGFydCkge1xcbiAgICAgICAgY3VyU3RhcnQgPSBNYXRoLm1pbihzdHJlYW0uc3RhcnQsIGN1clN0YXJ0ICsgNTAwMClcXG4gICAgICAgIGYoY3VyU3RhcnQsIGN1clN0eWxlKVxcbiAgICAgIH1cXG4gICAgICBjdXJTdHlsZSA9IHN0eWxlXFxuICAgIH1cXG4gICAgc3RyZWFtLnN0YXJ0ID0gc3RyZWFtLnBvc1xcbiAgfVxcbiAgd2hpbGUgKGN1clN0YXJ0IDwgc3RyZWFtLnBvcykge1xcbiAgICAvLyBXZWJraXQgc2VlbXMgdG8gcmVmdXNlIHRvIHJlbmRlciB0ZXh0IG5vZGVzIGxvbmdlciB0aGFuIDU3NDQ0XFxuICAgIC8vIGNoYXJhY3RlcnMsIGFuZCByZXR1cm5zIGluYWNjdXJhdGUgbWVhc3VyZW1lbnRzIGluIG5vZGVzXFxuICAgIC8vIHN0YXJ0aW5nIGFyb3VuZCA1MDAwIGNoYXJzLlxcbiAgICB2YXIgcG9zID0gTWF0aC5taW4oc3RyZWFtLnBvcywgY3VyU3RhcnQgKyA1MDAwKVxcbiAgICBmKHBvcywgY3VyU3R5bGUpXFxuICAgIGN1clN0YXJ0ID0gcG9zXFxuICB9XFxufVxcblxcbi8vIEZpbmRzIHRoZSBsaW5lIHRvIHN0YXJ0IHdpdGggd2hlbiBzdGFydGluZyBhIHBhcnNlLiBUcmllcyB0b1xcbi8vIGZpbmQgYSBsaW5lIHdpdGggYSBzdGF0ZUFmdGVyLCBzbyB0aGF0IGl0IGNhbiBzdGFydCB3aXRoIGFcXG4vLyB2YWxpZCBzdGF0ZS4gSWYgdGhhdCBmYWlscywgaXQgcmV0dXJucyB0aGUgbGluZSB3aXRoIHRoZVxcbi8vIHNtYWxsZXN0IGluZGVudGF0aW9uLCB3aGljaCB0ZW5kcyB0byBuZWVkIHRoZSBsZWFzdCBjb250ZXh0IHRvXFxuLy8gcGFyc2UgY29ycmVjdGx5LlxcbmZ1bmN0aW9uIGZpbmRTdGFydExpbmUoY20sIG4sIHByZWNpc2UpIHtcXG4gIHZhciBtaW5pbmRlbnQsIG1pbmxpbmUsIGRvYyA9IGNtLmRvY1xcbiAgdmFyIGxpbSA9IHByZWNpc2UgPyAtMSA6IG4gLSAoY20uZG9jLm1vZGUuaW5uZXJNb2RlID8gMTAwMCA6IDEwMClcXG4gIGZvciAodmFyIHNlYXJjaCA9IG47IHNlYXJjaCA+IGxpbTsgLS1zZWFyY2gpIHtcXG4gICAgaWYgKHNlYXJjaCA8PSBkb2MuZmlyc3QpIHsgcmV0dXJuIGRvYy5maXJzdCB9XFxuICAgIHZhciBsaW5lID0gZ2V0TGluZShkb2MsIHNlYXJjaCAtIDEpXFxuICAgIGlmIChsaW5lLnN0YXRlQWZ0ZXIgJiYgKCFwcmVjaXNlIHx8IHNlYXJjaCA8PSBkb2MuZnJvbnRpZXIpKSB7IHJldHVybiBzZWFyY2ggfVxcbiAgICB2YXIgaW5kZW50ZWQgPSBjb3VudENvbHVtbihsaW5lLnRleHQsIG51bGwsIGNtLm9wdGlvbnMudGFiU2l6ZSlcXG4gICAgaWYgKG1pbmxpbmUgPT0gbnVsbCB8fCBtaW5pbmRlbnQgPiBpbmRlbnRlZCkge1xcbiAgICAgIG1pbmxpbmUgPSBzZWFyY2ggLSAxXFxuICAgICAgbWluaW5kZW50ID0gaW5kZW50ZWRcXG4gICAgfVxcbiAgfVxcbiAgcmV0dXJuIG1pbmxpbmVcXG59XFxuXFxuLy8gTElORSBEQVRBIFNUUlVDVFVSRVxcblxcbi8vIExpbmUgb2JqZWN0cy4gVGhlc2UgaG9sZCBzdGF0ZSByZWxhdGVkIHRvIGEgbGluZSwgaW5jbHVkaW5nXFxuLy8gaGlnaGxpZ2h0aW5nIGluZm8gKHRoZSBzdHlsZXMgYXJyYXkpLlxcbnZhciBMaW5lID0gZnVuY3Rpb24odGV4dCwgbWFya2VkU3BhbnMsIGVzdGltYXRlSGVpZ2h0KSB7XFxuICB0aGlzLnRleHQgPSB0ZXh0XFxuICBhdHRhY2hNYXJrZWRTcGFucyh0aGlzLCBtYXJrZWRTcGFucylcXG4gIHRoaXMuaGVpZ2h0ID0gZXN0aW1hdGVIZWlnaHQgPyBlc3RpbWF0ZUhlaWdodCh0aGlzKSA6IDFcXG59O1xcblxcbkxpbmUucHJvdG90eXBlLmxpbmVObyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGxpbmVObyh0aGlzKSB9O1xcbmV2ZW50TWl4aW4oTGluZSlcXG5cXG4vLyBDaGFuZ2UgdGhlIGNvbnRlbnQgKHRleHQsIG1hcmtlcnMpIG9mIGEgbGluZS4gQXV0b21hdGljYWxseVxcbi8vIGludmFsaWRhdGVzIGNhY2hlZCBpbmZvcm1hdGlvbiBhbmQgdHJpZXMgdG8gcmUtZXN0aW1hdGUgdGhlXFxuLy8gbGluZSdzIGhlaWdodC5cXG5mdW5jdGlvbiB1cGRhdGVMaW5lKGxpbmUsIHRleHQsIG1hcmtlZFNwYW5zLCBlc3RpbWF0ZUhlaWdodCkge1xcbiAgbGluZS50ZXh0ID0gdGV4dFxcbiAgaWYgKGxpbmUuc3RhdGVBZnRlcikgeyBsaW5lLnN0YXRlQWZ0ZXIgPSBudWxsIH1cXG4gIGlmIChsaW5lLnN0eWxlcykgeyBsaW5lLnN0eWxlcyA9IG51bGwgfVxcbiAgaWYgKGxpbmUub3JkZXIgIT0gbnVsbCkgeyBsaW5lLm9yZGVyID0gbnVsbCB9XFxuICBkZXRhY2hNYXJrZWRTcGFucyhsaW5lKVxcbiAgYXR0YWNoTWFya2VkU3BhbnMobGluZSwgbWFya2VkU3BhbnMpXFxuICB2YXIgZXN0SGVpZ2h0ID0gZXN0aW1hdGVIZWlnaHQgPyBlc3RpbWF0ZUhlaWdodChsaW5lKSA6IDFcXG4gIGlmIChlc3RIZWlnaHQgIT0gbGluZS5oZWlnaHQpIHsgdXBkYXRlTGluZUhlaWdodChsaW5lLCBlc3RIZWlnaHQpIH1cXG59XFxuXFxuLy8gRGV0YWNoIGEgbGluZSBmcm9tIHRoZSBkb2N1bWVudCB0cmVlIGFuZCBpdHMgbWFya2Vycy5cXG5mdW5jdGlvbiBjbGVhblVwTGluZShsaW5lKSB7XFxuICBsaW5lLnBhcmVudCA9IG51bGxcXG4gIGRldGFjaE1hcmtlZFNwYW5zKGxpbmUpXFxufVxcblxcbi8vIENvbnZlcnQgYSBzdHlsZSBhcyByZXR1cm5lZCBieSBhIG1vZGUgKGVpdGhlciBudWxsLCBvciBhIHN0cmluZ1xcbi8vIGNvbnRhaW5pbmcgb25lIG9yIG1vcmUgc3R5bGVzKSB0byBhIENTUyBzdHlsZS4gVGhpcyBpcyBjYWNoZWQsXFxuLy8gYW5kIGFsc28gbG9va3MgZm9yIGxpbmUtd2lkZSBzdHlsZXMuXFxudmFyIHN0eWxlVG9DbGFzc0NhY2hlID0ge307XFxudmFyIHN0eWxlVG9DbGFzc0NhY2hlV2l0aE1vZGUgPSB7fTtcXG5mdW5jdGlvbiBpbnRlcnByZXRUb2tlblN0eWxlKHN0eWxlLCBvcHRpb25zKSB7XFxuICBpZiAoIXN0eWxlIHx8IC9eXFxcXHMqJC8udGVzdChzdHlsZSkpIHsgcmV0dXJuIG51bGwgfVxcbiAgdmFyIGNhY2hlID0gb3B0aW9ucy5hZGRNb2RlQ2xhc3MgPyBzdHlsZVRvQ2xhc3NDYWNoZVdpdGhNb2RlIDogc3R5bGVUb0NsYXNzQ2FjaGVcXG4gIHJldHVybiBjYWNoZVtzdHlsZV0gfHxcXG4gICAgKGNhY2hlW3N0eWxlXSA9IHN0eWxlLnJlcGxhY2UoL1xcXFxTKy9nLCBcXFwiY20tJCZcXFwiKSlcXG59XFxuXFxuLy8gUmVuZGVyIHRoZSBET00gcmVwcmVzZW50YXRpb24gb2YgdGhlIHRleHQgb2YgYSBsaW5lLiBBbHNvIGJ1aWxkc1xcbi8vIHVwIGEgJ2xpbmUgbWFwJywgd2hpY2ggcG9pbnRzIGF0IHRoZSBET00gbm9kZXMgdGhhdCByZXByZXNlbnRcXG4vLyBzcGVjaWZpYyBzdHJldGNoZXMgb2YgdGV4dCwgYW5kIGlzIHVzZWQgYnkgdGhlIG1lYXN1cmluZyBjb2RlLlxcbi8vIFRoZSByZXR1cm5lZCBvYmplY3QgY29udGFpbnMgdGhlIERPTSBub2RlLCB0aGlzIG1hcCwgYW5kXFxuLy8gaW5mb3JtYXRpb24gYWJvdXQgbGluZS13aWRlIHN0eWxlcyB0aGF0IHdlcmUgc2V0IGJ5IHRoZSBtb2RlLlxcbmZ1bmN0aW9uIGJ1aWxkTGluZUNvbnRlbnQoY20sIGxpbmVWaWV3KSB7XFxuICAvLyBUaGUgcGFkZGluZy1yaWdodCBmb3JjZXMgdGhlIGVsZW1lbnQgdG8gaGF2ZSBhICdib3JkZXInLCB3aGljaFxcbiAgLy8gaXMgbmVlZGVkIG9uIFdlYmtpdCB0byBiZSBhYmxlIHRvIGdldCBsaW5lLWxldmVsIGJvdW5kaW5nXFxuICAvLyByZWN0YW5nbGVzIGZvciBpdCAoaW4gbWVhc3VyZUNoYXIpLlxcbiAgdmFyIGNvbnRlbnQgPSBlbHQoXFxcInNwYW5cXFwiLCBudWxsLCBudWxsLCB3ZWJraXQgPyBcXFwicGFkZGluZy1yaWdodDogLjFweFxcXCIgOiBudWxsKVxcbiAgdmFyIGJ1aWxkZXIgPSB7cHJlOiBlbHQoXFxcInByZVxcXCIsIFtjb250ZW50XSwgXFxcIkNvZGVNaXJyb3ItbGluZVxcXCIpLCBjb250ZW50OiBjb250ZW50LFxcbiAgICAgICAgICAgICAgICAgY29sOiAwLCBwb3M6IDAsIGNtOiBjbSxcXG4gICAgICAgICAgICAgICAgIHRyYWlsaW5nU3BhY2U6IGZhbHNlLFxcbiAgICAgICAgICAgICAgICAgc3BsaXRTcGFjZXM6IChpZSB8fCB3ZWJraXQpICYmIGNtLmdldE9wdGlvbihcXFwibGluZVdyYXBwaW5nXFxcIil9XFxuICAvLyBoaWRlIGZyb20gYWNjZXNzaWJpbGl0eSB0cmVlXFxuICBjb250ZW50LnNldEF0dHJpYnV0ZShcXFwicm9sZVxcXCIsIFxcXCJwcmVzZW50YXRpb25cXFwiKVxcbiAgYnVpbGRlci5wcmUuc2V0QXR0cmlidXRlKFxcXCJyb2xlXFxcIiwgXFxcInByZXNlbnRhdGlvblxcXCIpXFxuICBsaW5lVmlldy5tZWFzdXJlID0ge31cXG5cXG4gIC8vIEl0ZXJhdGUgb3ZlciB0aGUgbG9naWNhbCBsaW5lcyB0aGF0IG1ha2UgdXAgdGhpcyB2aXN1YWwgbGluZS5cXG4gIGZvciAodmFyIGkgPSAwOyBpIDw9IChsaW5lVmlldy5yZXN0ID8gbGluZVZpZXcucmVzdC5sZW5ndGggOiAwKTsgaSsrKSB7XFxuICAgIHZhciBsaW5lID0gaSA/IGxpbmVWaWV3LnJlc3RbaSAtIDFdIDogbGluZVZpZXcubGluZSwgb3JkZXIgPSAodm9pZCAwKVxcbiAgICBidWlsZGVyLnBvcyA9IDBcXG4gICAgYnVpbGRlci5hZGRUb2tlbiA9IGJ1aWxkVG9rZW5cXG4gICAgLy8gT3B0aW9uYWxseSB3aXJlIGluIHNvbWUgaGFja3MgaW50byB0aGUgdG9rZW4tcmVuZGVyaW5nXFxuICAgIC8vIGFsZ29yaXRobSwgdG8gZGVhbCB3aXRoIGJyb3dzZXIgcXVpcmtzLlxcbiAgICBpZiAoaGFzQmFkQmlkaVJlY3RzKGNtLmRpc3BsYXkubWVhc3VyZSkgJiYgKG9yZGVyID0gZ2V0T3JkZXIobGluZSkpKVxcbiAgICAgIHsgYnVpbGRlci5hZGRUb2tlbiA9IGJ1aWxkVG9rZW5CYWRCaWRpKGJ1aWxkZXIuYWRkVG9rZW4sIG9yZGVyKSB9XFxuICAgIGJ1aWxkZXIubWFwID0gW11cXG4gICAgdmFyIGFsbG93RnJvbnRpZXJVcGRhdGUgPSBsaW5lVmlldyAhPSBjbS5kaXNwbGF5LmV4dGVybmFsTWVhc3VyZWQgJiYgbGluZU5vKGxpbmUpXFxuICAgIGluc2VydExpbmVDb250ZW50KGxpbmUsIGJ1aWxkZXIsIGdldExpbmVTdHlsZXMoY20sIGxpbmUsIGFsbG93RnJvbnRpZXJVcGRhdGUpKVxcbiAgICBpZiAobGluZS5zdHlsZUNsYXNzZXMpIHtcXG4gICAgICBpZiAobGluZS5zdHlsZUNsYXNzZXMuYmdDbGFzcylcXG4gICAgICAgIHsgYnVpbGRlci5iZ0NsYXNzID0gam9pbkNsYXNzZXMobGluZS5zdHlsZUNsYXNzZXMuYmdDbGFzcywgYnVpbGRlci5iZ0NsYXNzIHx8IFxcXCJcXFwiKSB9XFxuICAgICAgaWYgKGxpbmUuc3R5bGVDbGFzc2VzLnRleHRDbGFzcylcXG4gICAgICAgIHsgYnVpbGRlci50ZXh0Q2xhc3MgPSBqb2luQ2xhc3NlcyhsaW5lLnN0eWxlQ2xhc3Nlcy50ZXh0Q2xhc3MsIGJ1aWxkZXIudGV4dENsYXNzIHx8IFxcXCJcXFwiKSB9XFxuICAgIH1cXG5cXG4gICAgLy8gRW5zdXJlIGF0IGxlYXN0IGEgc2luZ2xlIG5vZGUgaXMgcHJlc2VudCwgZm9yIG1lYXN1cmluZy5cXG4gICAgaWYgKGJ1aWxkZXIubWFwLmxlbmd0aCA9PSAwKVxcbiAgICAgIHsgYnVpbGRlci5tYXAucHVzaCgwLCAwLCBidWlsZGVyLmNvbnRlbnQuYXBwZW5kQ2hpbGQoemVyb1dpZHRoRWxlbWVudChjbS5kaXNwbGF5Lm1lYXN1cmUpKSkgfVxcblxcbiAgICAvLyBTdG9yZSB0aGUgbWFwIGFuZCBhIGNhY2hlIG9iamVjdCBmb3IgdGhlIGN1cnJlbnQgbG9naWNhbCBsaW5lXFxuICAgIGlmIChpID09IDApIHtcXG4gICAgICBsaW5lVmlldy5tZWFzdXJlLm1hcCA9IGJ1aWxkZXIubWFwXFxuICAgICAgbGluZVZpZXcubWVhc3VyZS5jYWNoZSA9IHt9XFxuICAgIH0gZWxzZSB7XFxuICAgICAgOyhsaW5lVmlldy5tZWFzdXJlLm1hcHMgfHwgKGxpbmVWaWV3Lm1lYXN1cmUubWFwcyA9IFtdKSkucHVzaChidWlsZGVyLm1hcClcXG4gICAgICA7KGxpbmVWaWV3Lm1lYXN1cmUuY2FjaGVzIHx8IChsaW5lVmlldy5tZWFzdXJlLmNhY2hlcyA9IFtdKSkucHVzaCh7fSlcXG4gICAgfVxcbiAgfVxcblxcbiAgLy8gU2VlIGlzc3VlICMyOTAxXFxuICBpZiAod2Via2l0KSB7XFxuICAgIHZhciBsYXN0ID0gYnVpbGRlci5jb250ZW50Lmxhc3RDaGlsZFxcbiAgICBpZiAoL1xcXFxiY20tdGFiXFxcXGIvLnRlc3QobGFzdC5jbGFzc05hbWUpIHx8IChsYXN0LnF1ZXJ5U2VsZWN0b3IgJiYgbGFzdC5xdWVyeVNlbGVjdG9yKFxcXCIuY20tdGFiXFxcIikpKVxcbiAgICAgIHsgYnVpbGRlci5jb250ZW50LmNsYXNzTmFtZSA9IFxcXCJjbS10YWItd3JhcC1oYWNrXFxcIiB9XFxuICB9XFxuXFxuICBzaWduYWwoY20sIFxcXCJyZW5kZXJMaW5lXFxcIiwgY20sIGxpbmVWaWV3LmxpbmUsIGJ1aWxkZXIucHJlKVxcbiAgaWYgKGJ1aWxkZXIucHJlLmNsYXNzTmFtZSlcXG4gICAgeyBidWlsZGVyLnRleHRDbGFzcyA9IGpvaW5DbGFzc2VzKGJ1aWxkZXIucHJlLmNsYXNzTmFtZSwgYnVpbGRlci50ZXh0Q2xhc3MgfHwgXFxcIlxcXCIpIH1cXG5cXG4gIHJldHVybiBidWlsZGVyXFxufVxcblxcbmZ1bmN0aW9uIGRlZmF1bHRTcGVjaWFsQ2hhclBsYWNlaG9sZGVyKGNoKSB7XFxuICB2YXIgdG9rZW4gPSBlbHQoXFxcInNwYW5cXFwiLCBcXFwiXFxcXHUyMDIyXFxcIiwgXFxcImNtLWludmFsaWRjaGFyXFxcIilcXG4gIHRva2VuLnRpdGxlID0gXFxcIlxcXFxcXFxcdVxcXCIgKyBjaC5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KVxcbiAgdG9rZW4uc2V0QXR0cmlidXRlKFxcXCJhcmlhLWxhYmVsXFxcIiwgdG9rZW4udGl0bGUpXFxuICByZXR1cm4gdG9rZW5cXG59XFxuXFxuLy8gQnVpbGQgdXAgdGhlIERPTSByZXByZXNlbnRhdGlvbiBmb3IgYSBzaW5nbGUgdG9rZW4sIGFuZCBhZGQgaXQgdG9cXG4vLyB0aGUgbGluZSBtYXAuIFRha2VzIGNhcmUgdG8gcmVuZGVyIHNwZWNpYWwgY2hhcmFjdGVycyBzZXBhcmF0ZWx5LlxcbmZ1bmN0aW9uIGJ1aWxkVG9rZW4oYnVpbGRlciwgdGV4dCwgc3R5bGUsIHN0YXJ0U3R5bGUsIGVuZFN0eWxlLCB0aXRsZSwgY3NzKSB7XFxuICBpZiAoIXRleHQpIHsgcmV0dXJuIH1cXG4gIHZhciBkaXNwbGF5VGV4dCA9IGJ1aWxkZXIuc3BsaXRTcGFjZXMgPyBzcGxpdFNwYWNlcyh0ZXh0LCBidWlsZGVyLnRyYWlsaW5nU3BhY2UpIDogdGV4dFxcbiAgdmFyIHNwZWNpYWwgPSBidWlsZGVyLmNtLnN0YXRlLnNwZWNpYWxDaGFycywgbXVzdFdyYXAgPSBmYWxzZVxcbiAgdmFyIGNvbnRlbnRcXG4gIGlmICghc3BlY2lhbC50ZXN0KHRleHQpKSB7XFxuICAgIGJ1aWxkZXIuY29sICs9IHRleHQubGVuZ3RoXFxuICAgIGNvbnRlbnQgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShkaXNwbGF5VGV4dClcXG4gICAgYnVpbGRlci5tYXAucHVzaChidWlsZGVyLnBvcywgYnVpbGRlci5wb3MgKyB0ZXh0Lmxlbmd0aCwgY29udGVudClcXG4gICAgaWYgKGllICYmIGllX3ZlcnNpb24gPCA5KSB7IG11c3RXcmFwID0gdHJ1ZSB9XFxuICAgIGJ1aWxkZXIucG9zICs9IHRleHQubGVuZ3RoXFxuICB9IGVsc2Uge1xcbiAgICBjb250ZW50ID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpXFxuICAgIHZhciBwb3MgPSAwXFxuICAgIHdoaWxlICh0cnVlKSB7XFxuICAgICAgc3BlY2lhbC5sYXN0SW5kZXggPSBwb3NcXG4gICAgICB2YXIgbSA9IHNwZWNpYWwuZXhlYyh0ZXh0KVxcbiAgICAgIHZhciBza2lwcGVkID0gbSA/IG0uaW5kZXggLSBwb3MgOiB0ZXh0Lmxlbmd0aCAtIHBvc1xcbiAgICAgIGlmIChza2lwcGVkKSB7XFxuICAgICAgICB2YXIgdHh0ID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoZGlzcGxheVRleHQuc2xpY2UocG9zLCBwb3MgKyBza2lwcGVkKSlcXG4gICAgICAgIGlmIChpZSAmJiBpZV92ZXJzaW9uIDwgOSkgeyBjb250ZW50LmFwcGVuZENoaWxkKGVsdChcXFwic3BhblxcXCIsIFt0eHRdKSkgfVxcbiAgICAgICAgZWxzZSB7IGNvbnRlbnQuYXBwZW5kQ2hpbGQodHh0KSB9XFxuICAgICAgICBidWlsZGVyLm1hcC5wdXNoKGJ1aWxkZXIucG9zLCBidWlsZGVyLnBvcyArIHNraXBwZWQsIHR4dClcXG4gICAgICAgIGJ1aWxkZXIuY29sICs9IHNraXBwZWRcXG4gICAgICAgIGJ1aWxkZXIucG9zICs9IHNraXBwZWRcXG4gICAgICB9XFxuICAgICAgaWYgKCFtKSB7IGJyZWFrIH1cXG4gICAgICBwb3MgKz0gc2tpcHBlZCArIDFcXG4gICAgICB2YXIgdHh0JDEgPSAodm9pZCAwKVxcbiAgICAgIGlmIChtWzBdID09IFxcXCJcXFxcdFxcXCIpIHtcXG4gICAgICAgIHZhciB0YWJTaXplID0gYnVpbGRlci5jbS5vcHRpb25zLnRhYlNpemUsIHRhYldpZHRoID0gdGFiU2l6ZSAtIGJ1aWxkZXIuY29sICUgdGFiU2l6ZVxcbiAgICAgICAgdHh0JDEgPSBjb250ZW50LmFwcGVuZENoaWxkKGVsdChcXFwic3BhblxcXCIsIHNwYWNlU3RyKHRhYldpZHRoKSwgXFxcImNtLXRhYlxcXCIpKVxcbiAgICAgICAgdHh0JDEuc2V0QXR0cmlidXRlKFxcXCJyb2xlXFxcIiwgXFxcInByZXNlbnRhdGlvblxcXCIpXFxuICAgICAgICB0eHQkMS5zZXRBdHRyaWJ1dGUoXFxcImNtLXRleHRcXFwiLCBcXFwiXFxcXHRcXFwiKVxcbiAgICAgICAgYnVpbGRlci5jb2wgKz0gdGFiV2lkdGhcXG4gICAgICB9IGVsc2UgaWYgKG1bMF0gPT0gXFxcIlxcXFxyXFxcIiB8fCBtWzBdID09IFxcXCJcXFxcblxcXCIpIHtcXG4gICAgICAgIHR4dCQxID0gY29udGVudC5hcHBlbmRDaGlsZChlbHQoXFxcInNwYW5cXFwiLCBtWzBdID09IFxcXCJcXFxcclxcXCIgPyBcXFwiXFxcXHUyNDBkXFxcIiA6IFxcXCJcXFxcdTI0MjRcXFwiLCBcXFwiY20taW52YWxpZGNoYXJcXFwiKSlcXG4gICAgICAgIHR4dCQxLnNldEF0dHJpYnV0ZShcXFwiY20tdGV4dFxcXCIsIG1bMF0pXFxuICAgICAgICBidWlsZGVyLmNvbCArPSAxXFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIHR4dCQxID0gYnVpbGRlci5jbS5vcHRpb25zLnNwZWNpYWxDaGFyUGxhY2Vob2xkZXIobVswXSlcXG4gICAgICAgIHR4dCQxLnNldEF0dHJpYnV0ZShcXFwiY20tdGV4dFxcXCIsIG1bMF0pXFxuICAgICAgICBpZiAoaWUgJiYgaWVfdmVyc2lvbiA8IDkpIHsgY29udGVudC5hcHBlbmRDaGlsZChlbHQoXFxcInNwYW5cXFwiLCBbdHh0JDFdKSkgfVxcbiAgICAgICAgZWxzZSB7IGNvbnRlbnQuYXBwZW5kQ2hpbGQodHh0JDEpIH1cXG4gICAgICAgIGJ1aWxkZXIuY29sICs9IDFcXG4gICAgICB9XFxuICAgICAgYnVpbGRlci5tYXAucHVzaChidWlsZGVyLnBvcywgYnVpbGRlci5wb3MgKyAxLCB0eHQkMSlcXG4gICAgICBidWlsZGVyLnBvcysrXFxuICAgIH1cXG4gIH1cXG4gIGJ1aWxkZXIudHJhaWxpbmdTcGFjZSA9IGRpc3BsYXlUZXh0LmNoYXJDb2RlQXQodGV4dC5sZW5ndGggLSAxKSA9PSAzMlxcbiAgaWYgKHN0eWxlIHx8IHN0YXJ0U3R5bGUgfHwgZW5kU3R5bGUgfHwgbXVzdFdyYXAgfHwgY3NzKSB7XFxuICAgIHZhciBmdWxsU3R5bGUgPSBzdHlsZSB8fCBcXFwiXFxcIlxcbiAgICBpZiAoc3RhcnRTdHlsZSkgeyBmdWxsU3R5bGUgKz0gc3RhcnRTdHlsZSB9XFxuICAgIGlmIChlbmRTdHlsZSkgeyBmdWxsU3R5bGUgKz0gZW5kU3R5bGUgfVxcbiAgICB2YXIgdG9rZW4gPSBlbHQoXFxcInNwYW5cXFwiLCBbY29udGVudF0sIGZ1bGxTdHlsZSwgY3NzKVxcbiAgICBpZiAodGl0bGUpIHsgdG9rZW4udGl0bGUgPSB0aXRsZSB9XFxuICAgIHJldHVybiBidWlsZGVyLmNvbnRlbnQuYXBwZW5kQ2hpbGQodG9rZW4pXFxuICB9XFxuICBidWlsZGVyLmNvbnRlbnQuYXBwZW5kQ2hpbGQoY29udGVudClcXG59XFxuXFxuZnVuY3Rpb24gc3BsaXRTcGFjZXModGV4dCwgdHJhaWxpbmdCZWZvcmUpIHtcXG4gIGlmICh0ZXh0Lmxlbmd0aCA+IDEgJiYgIS8gIC8udGVzdCh0ZXh0KSkgeyByZXR1cm4gdGV4dCB9XFxuICB2YXIgc3BhY2VCZWZvcmUgPSB0cmFpbGluZ0JlZm9yZSwgcmVzdWx0ID0gXFxcIlxcXCJcXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGV4dC5sZW5ndGg7IGkrKykge1xcbiAgICB2YXIgY2ggPSB0ZXh0LmNoYXJBdChpKVxcbiAgICBpZiAoY2ggPT0gXFxcIiBcXFwiICYmIHNwYWNlQmVmb3JlICYmIChpID09IHRleHQubGVuZ3RoIC0gMSB8fCB0ZXh0LmNoYXJDb2RlQXQoaSArIDEpID09IDMyKSlcXG4gICAgICB7IGNoID0gXFxcIlxcXFx1MDBhMFxcXCIgfVxcbiAgICByZXN1bHQgKz0gY2hcXG4gICAgc3BhY2VCZWZvcmUgPSBjaCA9PSBcXFwiIFxcXCJcXG4gIH1cXG4gIHJldHVybiByZXN1bHRcXG59XFxuXFxuLy8gV29yayBhcm91bmQgbm9uc2Vuc2UgZGltZW5zaW9ucyBiZWluZyByZXBvcnRlZCBmb3Igc3RyZXRjaGVzIG9mXFxuLy8gcmlnaHQtdG8tbGVmdCB0ZXh0LlxcbmZ1bmN0aW9uIGJ1aWxkVG9rZW5CYWRCaWRpKGlubmVyLCBvcmRlcikge1xcbiAgcmV0dXJuIGZ1bmN0aW9uIChidWlsZGVyLCB0ZXh0LCBzdHlsZSwgc3RhcnRTdHlsZSwgZW5kU3R5bGUsIHRpdGxlLCBjc3MpIHtcXG4gICAgc3R5bGUgPSBzdHlsZSA/IHN0eWxlICsgXFxcIiBjbS1mb3JjZS1ib3JkZXJcXFwiIDogXFxcImNtLWZvcmNlLWJvcmRlclxcXCJcXG4gICAgdmFyIHN0YXJ0ID0gYnVpbGRlci5wb3MsIGVuZCA9IHN0YXJ0ICsgdGV4dC5sZW5ndGhcXG4gICAgZm9yICg7Oykge1xcbiAgICAgIC8vIEZpbmQgdGhlIHBhcnQgdGhhdCBvdmVybGFwcyB3aXRoIHRoZSBzdGFydCBvZiB0aGlzIHRleHRcXG4gICAgICB2YXIgcGFydCA9ICh2b2lkIDApXFxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcmRlci5sZW5ndGg7IGkrKykge1xcbiAgICAgICAgcGFydCA9IG9yZGVyW2ldXFxuICAgICAgICBpZiAocGFydC50byA+IHN0YXJ0ICYmIHBhcnQuZnJvbSA8PSBzdGFydCkgeyBicmVhayB9XFxuICAgICAgfVxcbiAgICAgIGlmIChwYXJ0LnRvID49IGVuZCkgeyByZXR1cm4gaW5uZXIoYnVpbGRlciwgdGV4dCwgc3R5bGUsIHN0YXJ0U3R5bGUsIGVuZFN0eWxlLCB0aXRsZSwgY3NzKSB9XFxuICAgICAgaW5uZXIoYnVpbGRlciwgdGV4dC5zbGljZSgwLCBwYXJ0LnRvIC0gc3RhcnQpLCBzdHlsZSwgc3RhcnRTdHlsZSwgbnVsbCwgdGl0bGUsIGNzcylcXG4gICAgICBzdGFydFN0eWxlID0gbnVsbFxcbiAgICAgIHRleHQgPSB0ZXh0LnNsaWNlKHBhcnQudG8gLSBzdGFydClcXG4gICAgICBzdGFydCA9IHBhcnQudG9cXG4gICAgfVxcbiAgfVxcbn1cXG5cXG5mdW5jdGlvbiBidWlsZENvbGxhcHNlZFNwYW4oYnVpbGRlciwgc2l6ZSwgbWFya2VyLCBpZ25vcmVXaWRnZXQpIHtcXG4gIHZhciB3aWRnZXQgPSAhaWdub3JlV2lkZ2V0ICYmIG1hcmtlci53aWRnZXROb2RlXFxuICBpZiAod2lkZ2V0KSB7IGJ1aWxkZXIubWFwLnB1c2goYnVpbGRlci5wb3MsIGJ1aWxkZXIucG9zICsgc2l6ZSwgd2lkZ2V0KSB9XFxuICBpZiAoIWlnbm9yZVdpZGdldCAmJiBidWlsZGVyLmNtLmRpc3BsYXkuaW5wdXQubmVlZHNDb250ZW50QXR0cmlidXRlKSB7XFxuICAgIGlmICghd2lkZ2V0KVxcbiAgICAgIHsgd2lkZ2V0ID0gYnVpbGRlci5jb250ZW50LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXFxcInNwYW5cXFwiKSkgfVxcbiAgICB3aWRnZXQuc2V0QXR0cmlidXRlKFxcXCJjbS1tYXJrZXJcXFwiLCBtYXJrZXIuaWQpXFxuICB9XFxuICBpZiAod2lkZ2V0KSB7XFxuICAgIGJ1aWxkZXIuY20uZGlzcGxheS5pbnB1dC5zZXRVbmVkaXRhYmxlKHdpZGdldClcXG4gICAgYnVpbGRlci5jb250ZW50LmFwcGVuZENoaWxkKHdpZGdldClcXG4gIH1cXG4gIGJ1aWxkZXIucG9zICs9IHNpemVcXG4gIGJ1aWxkZXIudHJhaWxpbmdTcGFjZSA9IGZhbHNlXFxufVxcblxcbi8vIE91dHB1dHMgYSBudW1iZXIgb2Ygc3BhbnMgdG8gbWFrZSB1cCBhIGxpbmUsIHRha2luZyBoaWdobGlnaHRpbmdcXG4vLyBhbmQgbWFya2VkIHRleHQgaW50byBhY2NvdW50LlxcbmZ1bmN0aW9uIGluc2VydExpbmVDb250ZW50KGxpbmUsIGJ1aWxkZXIsIHN0eWxlcykge1xcbiAgdmFyIHNwYW5zID0gbGluZS5tYXJrZWRTcGFucywgYWxsVGV4dCA9IGxpbmUudGV4dCwgYXQgPSAwXFxuICBpZiAoIXNwYW5zKSB7XFxuICAgIGZvciAodmFyIGkkMSA9IDE7IGkkMSA8IHN0eWxlcy5sZW5ndGg7IGkkMSs9MilcXG4gICAgICB7IGJ1aWxkZXIuYWRkVG9rZW4oYnVpbGRlciwgYWxsVGV4dC5zbGljZShhdCwgYXQgPSBzdHlsZXNbaSQxXSksIGludGVycHJldFRva2VuU3R5bGUoc3R5bGVzW2kkMSsxXSwgYnVpbGRlci5jbS5vcHRpb25zKSkgfVxcbiAgICByZXR1cm5cXG4gIH1cXG5cXG4gIHZhciBsZW4gPSBhbGxUZXh0Lmxlbmd0aCwgcG9zID0gMCwgaSA9IDEsIHRleHQgPSBcXFwiXFxcIiwgc3R5bGUsIGNzc1xcbiAgdmFyIG5leHRDaGFuZ2UgPSAwLCBzcGFuU3R5bGUsIHNwYW5FbmRTdHlsZSwgc3BhblN0YXJ0U3R5bGUsIHRpdGxlLCBjb2xsYXBzZWRcXG4gIGZvciAoOzspIHtcXG4gICAgaWYgKG5leHRDaGFuZ2UgPT0gcG9zKSB7IC8vIFVwZGF0ZSBjdXJyZW50IG1hcmtlciBzZXRcXG4gICAgICBzcGFuU3R5bGUgPSBzcGFuRW5kU3R5bGUgPSBzcGFuU3RhcnRTdHlsZSA9IHRpdGxlID0gY3NzID0gXFxcIlxcXCJcXG4gICAgICBjb2xsYXBzZWQgPSBudWxsOyBuZXh0Q2hhbmdlID0gSW5maW5pdHlcXG4gICAgICB2YXIgZm91bmRCb29rbWFya3MgPSBbXSwgZW5kU3R5bGVzID0gKHZvaWQgMClcXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHNwYW5zLmxlbmd0aDsgKytqKSB7XFxuICAgICAgICB2YXIgc3AgPSBzcGFuc1tqXSwgbSA9IHNwLm1hcmtlclxcbiAgICAgICAgaWYgKG0udHlwZSA9PSBcXFwiYm9va21hcmtcXFwiICYmIHNwLmZyb20gPT0gcG9zICYmIG0ud2lkZ2V0Tm9kZSkge1xcbiAgICAgICAgICBmb3VuZEJvb2ttYXJrcy5wdXNoKG0pXFxuICAgICAgICB9IGVsc2UgaWYgKHNwLmZyb20gPD0gcG9zICYmIChzcC50byA9PSBudWxsIHx8IHNwLnRvID4gcG9zIHx8IG0uY29sbGFwc2VkICYmIHNwLnRvID09IHBvcyAmJiBzcC5mcm9tID09IHBvcykpIHtcXG4gICAgICAgICAgaWYgKHNwLnRvICE9IG51bGwgJiYgc3AudG8gIT0gcG9zICYmIG5leHRDaGFuZ2UgPiBzcC50bykge1xcbiAgICAgICAgICAgIG5leHRDaGFuZ2UgPSBzcC50b1xcbiAgICAgICAgICAgIHNwYW5FbmRTdHlsZSA9IFxcXCJcXFwiXFxuICAgICAgICAgIH1cXG4gICAgICAgICAgaWYgKG0uY2xhc3NOYW1lKSB7IHNwYW5TdHlsZSArPSBcXFwiIFxcXCIgKyBtLmNsYXNzTmFtZSB9XFxuICAgICAgICAgIGlmIChtLmNzcykgeyBjc3MgPSAoY3NzID8gY3NzICsgXFxcIjtcXFwiIDogXFxcIlxcXCIpICsgbS5jc3MgfVxcbiAgICAgICAgICBpZiAobS5zdGFydFN0eWxlICYmIHNwLmZyb20gPT0gcG9zKSB7IHNwYW5TdGFydFN0eWxlICs9IFxcXCIgXFxcIiArIG0uc3RhcnRTdHlsZSB9XFxuICAgICAgICAgIGlmIChtLmVuZFN0eWxlICYmIHNwLnRvID09IG5leHRDaGFuZ2UpIHsgKGVuZFN0eWxlcyB8fCAoZW5kU3R5bGVzID0gW10pKS5wdXNoKG0uZW5kU3R5bGUsIHNwLnRvKSB9XFxuICAgICAgICAgIGlmIChtLnRpdGxlICYmICF0aXRsZSkgeyB0aXRsZSA9IG0udGl0bGUgfVxcbiAgICAgICAgICBpZiAobS5jb2xsYXBzZWQgJiYgKCFjb2xsYXBzZWQgfHwgY29tcGFyZUNvbGxhcHNlZE1hcmtlcnMoY29sbGFwc2VkLm1hcmtlciwgbSkgPCAwKSlcXG4gICAgICAgICAgICB7IGNvbGxhcHNlZCA9IHNwIH1cXG4gICAgICAgIH0gZWxzZSBpZiAoc3AuZnJvbSA+IHBvcyAmJiBuZXh0Q2hhbmdlID4gc3AuZnJvbSkge1xcbiAgICAgICAgICBuZXh0Q2hhbmdlID0gc3AuZnJvbVxcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgICBpZiAoZW5kU3R5bGVzKSB7IGZvciAodmFyIGokMSA9IDA7IGokMSA8IGVuZFN0eWxlcy5sZW5ndGg7IGokMSArPSAyKVxcbiAgICAgICAgeyBpZiAoZW5kU3R5bGVzW2okMSArIDFdID09IG5leHRDaGFuZ2UpIHsgc3BhbkVuZFN0eWxlICs9IFxcXCIgXFxcIiArIGVuZFN0eWxlc1tqJDFdIH0gfSB9XFxuXFxuICAgICAgaWYgKCFjb2xsYXBzZWQgfHwgY29sbGFwc2VkLmZyb20gPT0gcG9zKSB7IGZvciAodmFyIGokMiA9IDA7IGokMiA8IGZvdW5kQm9va21hcmtzLmxlbmd0aDsgKytqJDIpXFxuICAgICAgICB7IGJ1aWxkQ29sbGFwc2VkU3BhbihidWlsZGVyLCAwLCBmb3VuZEJvb2ttYXJrc1tqJDJdKSB9IH1cXG4gICAgICBpZiAoY29sbGFwc2VkICYmIChjb2xsYXBzZWQuZnJvbSB8fCAwKSA9PSBwb3MpIHtcXG4gICAgICAgIGJ1aWxkQ29sbGFwc2VkU3BhbihidWlsZGVyLCAoY29sbGFwc2VkLnRvID09IG51bGwgPyBsZW4gKyAxIDogY29sbGFwc2VkLnRvKSAtIHBvcyxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xsYXBzZWQubWFya2VyLCBjb2xsYXBzZWQuZnJvbSA9PSBudWxsKVxcbiAgICAgICAgaWYgKGNvbGxhcHNlZC50byA9PSBudWxsKSB7IHJldHVybiB9XFxuICAgICAgICBpZiAoY29sbGFwc2VkLnRvID09IHBvcykgeyBjb2xsYXBzZWQgPSBmYWxzZSB9XFxuICAgICAgfVxcbiAgICB9XFxuICAgIGlmIChwb3MgPj0gbGVuKSB7IGJyZWFrIH1cXG5cXG4gICAgdmFyIHVwdG8gPSBNYXRoLm1pbihsZW4sIG5leHRDaGFuZ2UpXFxuICAgIHdoaWxlICh0cnVlKSB7XFxuICAgICAgaWYgKHRleHQpIHtcXG4gICAgICAgIHZhciBlbmQgPSBwb3MgKyB0ZXh0Lmxlbmd0aFxcbiAgICAgICAgaWYgKCFjb2xsYXBzZWQpIHtcXG4gICAgICAgICAgdmFyIHRva2VuVGV4dCA9IGVuZCA+IHVwdG8gPyB0ZXh0LnNsaWNlKDAsIHVwdG8gLSBwb3MpIDogdGV4dFxcbiAgICAgICAgICBidWlsZGVyLmFkZFRva2VuKGJ1aWxkZXIsIHRva2VuVGV4dCwgc3R5bGUgPyBzdHlsZSArIHNwYW5TdHlsZSA6IHNwYW5TdHlsZSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBzcGFuU3RhcnRTdHlsZSwgcG9zICsgdG9rZW5UZXh0Lmxlbmd0aCA9PSBuZXh0Q2hhbmdlID8gc3BhbkVuZFN0eWxlIDogXFxcIlxcXCIsIHRpdGxlLCBjc3MpXFxuICAgICAgICB9XFxuICAgICAgICBpZiAoZW5kID49IHVwdG8pIHt0ZXh0ID0gdGV4dC5zbGljZSh1cHRvIC0gcG9zKTsgcG9zID0gdXB0bzsgYnJlYWt9XFxuICAgICAgICBwb3MgPSBlbmRcXG4gICAgICAgIHNwYW5TdGFydFN0eWxlID0gXFxcIlxcXCJcXG4gICAgICB9XFxuICAgICAgdGV4dCA9IGFsbFRleHQuc2xpY2UoYXQsIGF0ID0gc3R5bGVzW2krK10pXFxuICAgICAgc3R5bGUgPSBpbnRlcnByZXRUb2tlblN0eWxlKHN0eWxlc1tpKytdLCBidWlsZGVyLmNtLm9wdGlvbnMpXFxuICAgIH1cXG4gIH1cXG59XFxuXFxuXFxuLy8gVGhlc2Ugb2JqZWN0cyBhcmUgdXNlZCB0byByZXByZXNlbnQgdGhlIHZpc2libGUgKGN1cnJlbnRseSBkcmF3bilcXG4vLyBwYXJ0IG9mIHRoZSBkb2N1bWVudC4gQSBMaW5lVmlldyBtYXkgY29ycmVzcG9uZCB0byBtdWx0aXBsZVxcbi8vIGxvZ2ljYWwgbGluZXMsIGlmIHRob3NlIGFyZSBjb25uZWN0ZWQgYnkgY29sbGFwc2VkIHJhbmdlcy5cXG5mdW5jdGlvbiBMaW5lVmlldyhkb2MsIGxpbmUsIGxpbmVOKSB7XFxuICAvLyBUaGUgc3RhcnRpbmcgbGluZVxcbiAgdGhpcy5saW5lID0gbGluZVxcbiAgLy8gQ29udGludWluZyBsaW5lcywgaWYgYW55XFxuICB0aGlzLnJlc3QgPSB2aXN1YWxMaW5lQ29udGludWVkKGxpbmUpXFxuICAvLyBOdW1iZXIgb2YgbG9naWNhbCBsaW5lcyBpbiB0aGlzIHZpc3VhbCBsaW5lXFxuICB0aGlzLnNpemUgPSB0aGlzLnJlc3QgPyBsaW5lTm8obHN0KHRoaXMucmVzdCkpIC0gbGluZU4gKyAxIDogMVxcbiAgdGhpcy5ub2RlID0gdGhpcy50ZXh0ID0gbnVsbFxcbiAgdGhpcy5oaWRkZW4gPSBsaW5lSXNIaWRkZW4oZG9jLCBsaW5lKVxcbn1cXG5cXG4vLyBDcmVhdGUgYSByYW5nZSBvZiBMaW5lVmlldyBvYmplY3RzIGZvciB0aGUgZ2l2ZW4gbGluZXMuXFxuZnVuY3Rpb24gYnVpbGRWaWV3QXJyYXkoY20sIGZyb20sIHRvKSB7XFxuICB2YXIgYXJyYXkgPSBbXSwgbmV4dFBvc1xcbiAgZm9yICh2YXIgcG9zID0gZnJvbTsgcG9zIDwgdG87IHBvcyA9IG5leHRQb3MpIHtcXG4gICAgdmFyIHZpZXcgPSBuZXcgTGluZVZpZXcoY20uZG9jLCBnZXRMaW5lKGNtLmRvYywgcG9zKSwgcG9zKVxcbiAgICBuZXh0UG9zID0gcG9zICsgdmlldy5zaXplXFxuICAgIGFycmF5LnB1c2godmlldylcXG4gIH1cXG4gIHJldHVybiBhcnJheVxcbn1cXG5cXG52YXIgb3BlcmF0aW9uR3JvdXAgPSBudWxsXFxuXFxuZnVuY3Rpb24gcHVzaE9wZXJhdGlvbihvcCkge1xcbiAgaWYgKG9wZXJhdGlvbkdyb3VwKSB7XFxuICAgIG9wZXJhdGlvbkdyb3VwLm9wcy5wdXNoKG9wKVxcbiAgfSBlbHNlIHtcXG4gICAgb3Aub3duc0dyb3VwID0gb3BlcmF0aW9uR3JvdXAgPSB7XFxuICAgICAgb3BzOiBbb3BdLFxcbiAgICAgIGRlbGF5ZWRDYWxsYmFja3M6IFtdXFxuICAgIH1cXG4gIH1cXG59XFxuXFxuZnVuY3Rpb24gZmlyZUNhbGxiYWNrc0Zvck9wcyhncm91cCkge1xcbiAgLy8gQ2FsbHMgZGVsYXllZCBjYWxsYmFja3MgYW5kIGN1cnNvckFjdGl2aXR5IGhhbmRsZXJzIHVudGlsIG5vXFxuICAvLyBuZXcgb25lcyBhcHBlYXJcXG4gIHZhciBjYWxsYmFja3MgPSBncm91cC5kZWxheWVkQ2FsbGJhY2tzLCBpID0gMFxcbiAgZG8ge1xcbiAgICBmb3IgKDsgaSA8IGNhbGxiYWNrcy5sZW5ndGg7IGkrKylcXG4gICAgICB7IGNhbGxiYWNrc1tpXS5jYWxsKG51bGwpIH1cXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBncm91cC5vcHMubGVuZ3RoOyBqKyspIHtcXG4gICAgICB2YXIgb3AgPSBncm91cC5vcHNbal1cXG4gICAgICBpZiAob3AuY3Vyc29yQWN0aXZpdHlIYW5kbGVycylcXG4gICAgICAgIHsgd2hpbGUgKG9wLmN1cnNvckFjdGl2aXR5Q2FsbGVkIDwgb3AuY3Vyc29yQWN0aXZpdHlIYW5kbGVycy5sZW5ndGgpXFxuICAgICAgICAgIHsgb3AuY3Vyc29yQWN0aXZpdHlIYW5kbGVyc1tvcC5jdXJzb3JBY3Rpdml0eUNhbGxlZCsrXS5jYWxsKG51bGwsIG9wLmNtKSB9IH1cXG4gICAgfVxcbiAgfSB3aGlsZSAoaSA8IGNhbGxiYWNrcy5sZW5ndGgpXFxufVxcblxcbmZ1bmN0aW9uIGZpbmlzaE9wZXJhdGlvbihvcCwgZW5kQ2IpIHtcXG4gIHZhciBncm91cCA9IG9wLm93bnNHcm91cFxcbiAgaWYgKCFncm91cCkgeyByZXR1cm4gfVxcblxcbiAgdHJ5IHsgZmlyZUNhbGxiYWNrc0Zvck9wcyhncm91cCkgfVxcbiAgZmluYWxseSB7XFxuICAgIG9wZXJhdGlvbkdyb3VwID0gbnVsbFxcbiAgICBlbmRDYihncm91cClcXG4gIH1cXG59XFxuXFxudmFyIG9ycGhhbkRlbGF5ZWRDYWxsYmFja3MgPSBudWxsXFxuXFxuLy8gT2Z0ZW4sIHdlIHdhbnQgdG8gc2lnbmFsIGV2ZW50cyBhdCBhIHBvaW50IHdoZXJlIHdlIGFyZSBpbiB0aGVcXG4vLyBtaWRkbGUgb2Ygc29tZSB3b3JrLCBidXQgZG9uJ3Qgd2FudCB0aGUgaGFuZGxlciB0byBzdGFydCBjYWxsaW5nXFxuLy8gb3RoZXIgbWV0aG9kcyBvbiB0aGUgZWRpdG9yLCB3aGljaCBtaWdodCBiZSBpbiBhbiBpbmNvbnNpc3RlbnRcXG4vLyBzdGF0ZSBvciBzaW1wbHkgbm90IGV4cGVjdCBhbnkgb3RoZXIgZXZlbnRzIHRvIGhhcHBlbi5cXG4vLyBzaWduYWxMYXRlciBsb29rcyB3aGV0aGVyIHRoZXJlIGFyZSBhbnkgaGFuZGxlcnMsIGFuZCBzY2hlZHVsZXNcXG4vLyB0aGVtIHRvIGJlIGV4ZWN1dGVkIHdoZW4gdGhlIGxhc3Qgb3BlcmF0aW9uIGVuZHMsIG9yLCBpZiBub1xcbi8vIG9wZXJhdGlvbiBpcyBhY3RpdmUsIHdoZW4gYSB0aW1lb3V0IGZpcmVzLlxcbmZ1bmN0aW9uIHNpZ25hbExhdGVyKGVtaXR0ZXIsIHR5cGUgLyosIHZhbHVlcy4uLiovKSB7XFxuICB2YXIgYXJyID0gZ2V0SGFuZGxlcnMoZW1pdHRlciwgdHlwZSlcXG4gIGlmICghYXJyLmxlbmd0aCkgeyByZXR1cm4gfVxcbiAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpLCBsaXN0XFxuICBpZiAob3BlcmF0aW9uR3JvdXApIHtcXG4gICAgbGlzdCA9IG9wZXJhdGlvbkdyb3VwLmRlbGF5ZWRDYWxsYmFja3NcXG4gIH0gZWxzZSBpZiAob3JwaGFuRGVsYXllZENhbGxiYWNrcykge1xcbiAgICBsaXN0ID0gb3JwaGFuRGVsYXllZENhbGxiYWNrc1xcbiAgfSBlbHNlIHtcXG4gICAgbGlzdCA9IG9ycGhhbkRlbGF5ZWRDYWxsYmFja3MgPSBbXVxcbiAgICBzZXRUaW1lb3V0KGZpcmVPcnBoYW5EZWxheWVkLCAwKVxcbiAgfVxcbiAgdmFyIGxvb3AgPSBmdW5jdGlvbiAoIGkgKSB7XFxuICAgIGxpc3QucHVzaChmdW5jdGlvbiAoKSB7IHJldHVybiBhcnJbaV0uYXBwbHkobnVsbCwgYXJncyk7IH0pXFxuICB9O1xcblxcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyArK2kpXFxuICAgIGxvb3AoIGkgKTtcXG59XFxuXFxuZnVuY3Rpb24gZmlyZU9ycGhhbkRlbGF5ZWQoKSB7XFxuICB2YXIgZGVsYXllZCA9IG9ycGhhbkRlbGF5ZWRDYWxsYmFja3NcXG4gIG9ycGhhbkRlbGF5ZWRDYWxsYmFja3MgPSBudWxsXFxuICBmb3IgKHZhciBpID0gMDsgaSA8IGRlbGF5ZWQubGVuZ3RoOyArK2kpIHsgZGVsYXllZFtpXSgpIH1cXG59XFxuXFxuLy8gV2hlbiBhbiBhc3BlY3Qgb2YgYSBsaW5lIGNoYW5nZXMsIGEgc3RyaW5nIGlzIGFkZGVkIHRvXFxuLy8gbGluZVZpZXcuY2hhbmdlcy4gVGhpcyB1cGRhdGVzIHRoZSByZWxldmFudCBwYXJ0IG9mIHRoZSBsaW5lJ3NcXG4vLyBET00gc3RydWN0dXJlLlxcbmZ1bmN0aW9uIHVwZGF0ZUxpbmVGb3JDaGFuZ2VzKGNtLCBsaW5lVmlldywgbGluZU4sIGRpbXMpIHtcXG4gIGZvciAodmFyIGogPSAwOyBqIDwgbGluZVZpZXcuY2hhbmdlcy5sZW5ndGg7IGorKykge1xcbiAgICB2YXIgdHlwZSA9IGxpbmVWaWV3LmNoYW5nZXNbal1cXG4gICAgaWYgKHR5cGUgPT0gXFxcInRleHRcXFwiKSB7IHVwZGF0ZUxpbmVUZXh0KGNtLCBsaW5lVmlldykgfVxcbiAgICBlbHNlIGlmICh0eXBlID09IFxcXCJndXR0ZXJcXFwiKSB7IHVwZGF0ZUxpbmVHdXR0ZXIoY20sIGxpbmVWaWV3LCBsaW5lTiwgZGltcykgfVxcbiAgICBlbHNlIGlmICh0eXBlID09IFxcXCJjbGFzc1xcXCIpIHsgdXBkYXRlTGluZUNsYXNzZXMobGluZVZpZXcpIH1cXG4gICAgZWxzZSBpZiAodHlwZSA9PSBcXFwid2lkZ2V0XFxcIikgeyB1cGRhdGVMaW5lV2lkZ2V0cyhjbSwgbGluZVZpZXcsIGRpbXMpIH1cXG4gIH1cXG4gIGxpbmVWaWV3LmNoYW5nZXMgPSBudWxsXFxufVxcblxcbi8vIExpbmVzIHdpdGggZ3V0dGVyIGVsZW1lbnRzLCB3aWRnZXRzIG9yIGEgYmFja2dyb3VuZCBjbGFzcyBuZWVkIHRvXFxuLy8gYmUgd3JhcHBlZCwgYW5kIGhhdmUgdGhlIGV4dHJhIGVsZW1lbnRzIGFkZGVkIHRvIHRoZSB3cmFwcGVyIGRpdlxcbmZ1bmN0aW9uIGVuc3VyZUxpbmVXcmFwcGVkKGxpbmVWaWV3KSB7XFxuICBpZiAobGluZVZpZXcubm9kZSA9PSBsaW5lVmlldy50ZXh0KSB7XFxuICAgIGxpbmVWaWV3Lm5vZGUgPSBlbHQoXFxcImRpdlxcXCIsIG51bGwsIG51bGwsIFxcXCJwb3NpdGlvbjogcmVsYXRpdmVcXFwiKVxcbiAgICBpZiAobGluZVZpZXcudGV4dC5wYXJlbnROb2RlKVxcbiAgICAgIHsgbGluZVZpZXcudGV4dC5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZChsaW5lVmlldy5ub2RlLCBsaW5lVmlldy50ZXh0KSB9XFxuICAgIGxpbmVWaWV3Lm5vZGUuYXBwZW5kQ2hpbGQobGluZVZpZXcudGV4dClcXG4gICAgaWYgKGllICYmIGllX3ZlcnNpb24gPCA4KSB7IGxpbmVWaWV3Lm5vZGUuc3R5bGUuekluZGV4ID0gMiB9XFxuICB9XFxuICByZXR1cm4gbGluZVZpZXcubm9kZVxcbn1cXG5cXG5mdW5jdGlvbiB1cGRhdGVMaW5lQmFja2dyb3VuZChsaW5lVmlldykge1xcbiAgdmFyIGNscyA9IGxpbmVWaWV3LmJnQ2xhc3MgPyBsaW5lVmlldy5iZ0NsYXNzICsgXFxcIiBcXFwiICsgKGxpbmVWaWV3LmxpbmUuYmdDbGFzcyB8fCBcXFwiXFxcIikgOiBsaW5lVmlldy5saW5lLmJnQ2xhc3NcXG4gIGlmIChjbHMpIHsgY2xzICs9IFxcXCIgQ29kZU1pcnJvci1saW5lYmFja2dyb3VuZFxcXCIgfVxcbiAgaWYgKGxpbmVWaWV3LmJhY2tncm91bmQpIHtcXG4gICAgaWYgKGNscykgeyBsaW5lVmlldy5iYWNrZ3JvdW5kLmNsYXNzTmFtZSA9IGNscyB9XFxuICAgIGVsc2UgeyBsaW5lVmlldy5iYWNrZ3JvdW5kLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobGluZVZpZXcuYmFja2dyb3VuZCk7IGxpbmVWaWV3LmJhY2tncm91bmQgPSBudWxsIH1cXG4gIH0gZWxzZSBpZiAoY2xzKSB7XFxuICAgIHZhciB3cmFwID0gZW5zdXJlTGluZVdyYXBwZWQobGluZVZpZXcpXFxuICAgIGxpbmVWaWV3LmJhY2tncm91bmQgPSB3cmFwLmluc2VydEJlZm9yZShlbHQoXFxcImRpdlxcXCIsIG51bGwsIGNscyksIHdyYXAuZmlyc3RDaGlsZClcXG4gIH1cXG59XFxuXFxuLy8gV3JhcHBlciBhcm91bmQgYnVpbGRMaW5lQ29udGVudCB3aGljaCB3aWxsIHJldXNlIHRoZSBzdHJ1Y3R1cmVcXG4vLyBpbiBkaXNwbGF5LmV4dGVybmFsTWVhc3VyZWQgd2hlbiBwb3NzaWJsZS5cXG5mdW5jdGlvbiBnZXRMaW5lQ29udGVudChjbSwgbGluZVZpZXcpIHtcXG4gIHZhciBleHQgPSBjbS5kaXNwbGF5LmV4dGVybmFsTWVhc3VyZWRcXG4gIGlmIChleHQgJiYgZXh0LmxpbmUgPT0gbGluZVZpZXcubGluZSkge1xcbiAgICBjbS5kaXNwbGF5LmV4dGVybmFsTWVhc3VyZWQgPSBudWxsXFxuICAgIGxpbmVWaWV3Lm1lYXN1cmUgPSBleHQubWVhc3VyZVxcbiAgICByZXR1cm4gZXh0LmJ1aWx0XFxuICB9XFxuICByZXR1cm4gYnVpbGRMaW5lQ29udGVudChjbSwgbGluZVZpZXcpXFxufVxcblxcbi8vIFJlZHJhdyB0aGUgbGluZSdzIHRleHQuIEludGVyYWN0cyB3aXRoIHRoZSBiYWNrZ3JvdW5kIGFuZCB0ZXh0XFxuLy8gY2xhc3NlcyBiZWNhdXNlIHRoZSBtb2RlIG1heSBvdXRwdXQgdG9rZW5zIHRoYXQgaW5mbHVlbmNlIHRoZXNlXFxuLy8gY2xhc3Nlcy5cXG5mdW5jdGlvbiB1cGRhdGVMaW5lVGV4dChjbSwgbGluZVZpZXcpIHtcXG4gIHZhciBjbHMgPSBsaW5lVmlldy50ZXh0LmNsYXNzTmFtZVxcbiAgdmFyIGJ1aWx0ID0gZ2V0TGluZUNvbnRlbnQoY20sIGxpbmVWaWV3KVxcbiAgaWYgKGxpbmVWaWV3LnRleHQgPT0gbGluZVZpZXcubm9kZSkgeyBsaW5lVmlldy5ub2RlID0gYnVpbHQucHJlIH1cXG4gIGxpbmVWaWV3LnRleHQucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQoYnVpbHQucHJlLCBsaW5lVmlldy50ZXh0KVxcbiAgbGluZVZpZXcudGV4dCA9IGJ1aWx0LnByZVxcbiAgaWYgKGJ1aWx0LmJnQ2xhc3MgIT0gbGluZVZpZXcuYmdDbGFzcyB8fCBidWlsdC50ZXh0Q2xhc3MgIT0gbGluZVZpZXcudGV4dENsYXNzKSB7XFxuICAgIGxpbmVWaWV3LmJnQ2xhc3MgPSBidWlsdC5iZ0NsYXNzXFxuICAgIGxpbmVWaWV3LnRleHRDbGFzcyA9IGJ1aWx0LnRleHRDbGFzc1xcbiAgICB1cGRhdGVMaW5lQ2xhc3NlcyhsaW5lVmlldylcXG4gIH0gZWxzZSBpZiAoY2xzKSB7XFxuICAgIGxpbmVWaWV3LnRleHQuY2xhc3NOYW1lID0gY2xzXFxuICB9XFxufVxcblxcbmZ1bmN0aW9uIHVwZGF0ZUxpbmVDbGFzc2VzKGxpbmVWaWV3KSB7XFxuICB1cGRhdGVMaW5lQmFja2dyb3VuZChsaW5lVmlldylcXG4gIGlmIChsaW5lVmlldy5saW5lLndyYXBDbGFzcylcXG4gICAgeyBlbnN1cmVMaW5lV3JhcHBlZChsaW5lVmlldykuY2xhc3NOYW1lID0gbGluZVZpZXcubGluZS53cmFwQ2xhc3MgfVxcbiAgZWxzZSBpZiAobGluZVZpZXcubm9kZSAhPSBsaW5lVmlldy50ZXh0KVxcbiAgICB7IGxpbmVWaWV3Lm5vZGUuY2xhc3NOYW1lID0gXFxcIlxcXCIgfVxcbiAgdmFyIHRleHRDbGFzcyA9IGxpbmVWaWV3LnRleHRDbGFzcyA/IGxpbmVWaWV3LnRleHRDbGFzcyArIFxcXCIgXFxcIiArIChsaW5lVmlldy5saW5lLnRleHRDbGFzcyB8fCBcXFwiXFxcIikgOiBsaW5lVmlldy5saW5lLnRleHRDbGFzc1xcbiAgbGluZVZpZXcudGV4dC5jbGFzc05hbWUgPSB0ZXh0Q2xhc3MgfHwgXFxcIlxcXCJcXG59XFxuXFxuZnVuY3Rpb24gdXBkYXRlTGluZUd1dHRlcihjbSwgbGluZVZpZXcsIGxpbmVOLCBkaW1zKSB7XFxuICBpZiAobGluZVZpZXcuZ3V0dGVyKSB7XFxuICAgIGxpbmVWaWV3Lm5vZGUucmVtb3ZlQ2hpbGQobGluZVZpZXcuZ3V0dGVyKVxcbiAgICBsaW5lVmlldy5ndXR0ZXIgPSBudWxsXFxuICB9XFxuICBpZiAobGluZVZpZXcuZ3V0dGVyQmFja2dyb3VuZCkge1xcbiAgICBsaW5lVmlldy5ub2RlLnJlbW92ZUNoaWxkKGxpbmVWaWV3Lmd1dHRlckJhY2tncm91bmQpXFxuICAgIGxpbmVWaWV3Lmd1dHRlckJhY2tncm91bmQgPSBudWxsXFxuICB9XFxuICBpZiAobGluZVZpZXcubGluZS5ndXR0ZXJDbGFzcykge1xcbiAgICB2YXIgd3JhcCA9IGVuc3VyZUxpbmVXcmFwcGVkKGxpbmVWaWV3KVxcbiAgICBsaW5lVmlldy5ndXR0ZXJCYWNrZ3JvdW5kID0gZWx0KFxcXCJkaXZcXFwiLCBudWxsLCBcXFwiQ29kZU1pcnJvci1ndXR0ZXItYmFja2dyb3VuZCBcXFwiICsgbGluZVZpZXcubGluZS5ndXR0ZXJDbGFzcyxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoXFxcImxlZnQ6IFxcXCIgKyAoY20ub3B0aW9ucy5maXhlZEd1dHRlciA/IGRpbXMuZml4ZWRQb3MgOiAtZGltcy5ndXR0ZXJUb3RhbFdpZHRoKSArIFxcXCJweDsgd2lkdGg6IFxcXCIgKyAoZGltcy5ndXR0ZXJUb3RhbFdpZHRoKSArIFxcXCJweFxcXCIpKVxcbiAgICB3cmFwLmluc2VydEJlZm9yZShsaW5lVmlldy5ndXR0ZXJCYWNrZ3JvdW5kLCBsaW5lVmlldy50ZXh0KVxcbiAgfVxcbiAgdmFyIG1hcmtlcnMgPSBsaW5lVmlldy5saW5lLmd1dHRlck1hcmtlcnNcXG4gIGlmIChjbS5vcHRpb25zLmxpbmVOdW1iZXJzIHx8IG1hcmtlcnMpIHtcXG4gICAgdmFyIHdyYXAkMSA9IGVuc3VyZUxpbmVXcmFwcGVkKGxpbmVWaWV3KVxcbiAgICB2YXIgZ3V0dGVyV3JhcCA9IGxpbmVWaWV3Lmd1dHRlciA9IGVsdChcXFwiZGl2XFxcIiwgbnVsbCwgXFxcIkNvZGVNaXJyb3ItZ3V0dGVyLXdyYXBwZXJcXFwiLCAoXFxcImxlZnQ6IFxcXCIgKyAoY20ub3B0aW9ucy5maXhlZEd1dHRlciA/IGRpbXMuZml4ZWRQb3MgOiAtZGltcy5ndXR0ZXJUb3RhbFdpZHRoKSArIFxcXCJweFxcXCIpKVxcbiAgICBjbS5kaXNwbGF5LmlucHV0LnNldFVuZWRpdGFibGUoZ3V0dGVyV3JhcClcXG4gICAgd3JhcCQxLmluc2VydEJlZm9yZShndXR0ZXJXcmFwLCBsaW5lVmlldy50ZXh0KVxcbiAgICBpZiAobGluZVZpZXcubGluZS5ndXR0ZXJDbGFzcylcXG4gICAgICB7IGd1dHRlcldyYXAuY2xhc3NOYW1lICs9IFxcXCIgXFxcIiArIGxpbmVWaWV3LmxpbmUuZ3V0dGVyQ2xhc3MgfVxcbiAgICBpZiAoY20ub3B0aW9ucy5saW5lTnVtYmVycyAmJiAoIW1hcmtlcnMgfHwgIW1hcmtlcnNbXFxcIkNvZGVNaXJyb3ItbGluZW51bWJlcnNcXFwiXSkpXFxuICAgICAgeyBsaW5lVmlldy5saW5lTnVtYmVyID0gZ3V0dGVyV3JhcC5hcHBlbmRDaGlsZChcXG4gICAgICAgIGVsdChcXFwiZGl2XFxcIiwgbGluZU51bWJlckZvcihjbS5vcHRpb25zLCBsaW5lTiksXFxuICAgICAgICAgICAgXFxcIkNvZGVNaXJyb3ItbGluZW51bWJlciBDb2RlTWlycm9yLWd1dHRlci1lbHRcXFwiLFxcbiAgICAgICAgICAgIChcXFwibGVmdDogXFxcIiArIChkaW1zLmd1dHRlckxlZnRbXFxcIkNvZGVNaXJyb3ItbGluZW51bWJlcnNcXFwiXSkgKyBcXFwicHg7IHdpZHRoOiBcXFwiICsgKGNtLmRpc3BsYXkubGluZU51bUlubmVyV2lkdGgpICsgXFxcInB4XFxcIikpKSB9XFxuICAgIGlmIChtYXJrZXJzKSB7IGZvciAodmFyIGsgPSAwOyBrIDwgY20ub3B0aW9ucy5ndXR0ZXJzLmxlbmd0aDsgKytrKSB7XFxuICAgICAgdmFyIGlkID0gY20ub3B0aW9ucy5ndXR0ZXJzW2tdLCBmb3VuZCA9IG1hcmtlcnMuaGFzT3duUHJvcGVydHkoaWQpICYmIG1hcmtlcnNbaWRdXFxuICAgICAgaWYgKGZvdW5kKVxcbiAgICAgICAgeyBndXR0ZXJXcmFwLmFwcGVuZENoaWxkKGVsdChcXFwiZGl2XFxcIiwgW2ZvdW5kXSwgXFxcIkNvZGVNaXJyb3ItZ3V0dGVyLWVsdFxcXCIsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoXFxcImxlZnQ6IFxcXCIgKyAoZGltcy5ndXR0ZXJMZWZ0W2lkXSkgKyBcXFwicHg7IHdpZHRoOiBcXFwiICsgKGRpbXMuZ3V0dGVyV2lkdGhbaWRdKSArIFxcXCJweFxcXCIpKSkgfVxcbiAgICB9IH1cXG4gIH1cXG59XFxuXFxuZnVuY3Rpb24gdXBkYXRlTGluZVdpZGdldHMoY20sIGxpbmVWaWV3LCBkaW1zKSB7XFxuICBpZiAobGluZVZpZXcuYWxpZ25hYmxlKSB7IGxpbmVWaWV3LmFsaWduYWJsZSA9IG51bGwgfVxcbiAgZm9yICh2YXIgbm9kZSA9IGxpbmVWaWV3Lm5vZGUuZmlyc3RDaGlsZCwgbmV4dCA9ICh2b2lkIDApOyBub2RlOyBub2RlID0gbmV4dCkge1xcbiAgICBuZXh0ID0gbm9kZS5uZXh0U2libGluZ1xcbiAgICBpZiAobm9kZS5jbGFzc05hbWUgPT0gXFxcIkNvZGVNaXJyb3ItbGluZXdpZGdldFxcXCIpXFxuICAgICAgeyBsaW5lVmlldy5ub2RlLnJlbW92ZUNoaWxkKG5vZGUpIH1cXG4gIH1cXG4gIGluc2VydExpbmVXaWRnZXRzKGNtLCBsaW5lVmlldywgZGltcylcXG59XFxuXFxuLy8gQnVpbGQgYSBsaW5lJ3MgRE9NIHJlcHJlc2VudGF0aW9uIGZyb20gc2NyYXRjaFxcbmZ1bmN0aW9uIGJ1aWxkTGluZUVsZW1lbnQoY20sIGxpbmVWaWV3LCBsaW5lTiwgZGltcykge1xcbiAgdmFyIGJ1aWx0ID0gZ2V0TGluZUNvbnRlbnQoY20sIGxpbmVWaWV3KVxcbiAgbGluZVZpZXcudGV4dCA9IGxpbmVWaWV3Lm5vZGUgPSBidWlsdC5wcmVcXG4gIGlmIChidWlsdC5iZ0NsYXNzKSB7IGxpbmVWaWV3LmJnQ2xhc3MgPSBidWlsdC5iZ0NsYXNzIH1cXG4gIGlmIChidWlsdC50ZXh0Q2xhc3MpIHsgbGluZVZpZXcudGV4dENsYXNzID0gYnVpbHQudGV4dENsYXNzIH1cXG5cXG4gIHVwZGF0ZUxpbmVDbGFzc2VzKGxpbmVWaWV3KVxcbiAgdXBkYXRlTGluZUd1dHRlcihjbSwgbGluZVZpZXcsIGxpbmVOLCBkaW1zKVxcbiAgaW5zZXJ0TGluZVdpZGdldHMoY20sIGxpbmVWaWV3LCBkaW1zKVxcbiAgcmV0dXJuIGxpbmVWaWV3Lm5vZGVcXG59XFxuXFxuLy8gQSBsaW5lVmlldyBtYXkgY29udGFpbiBtdWx0aXBsZSBsb2dpY2FsIGxpbmVzICh3aGVuIG1lcmdlZCBieVxcbi8vIGNvbGxhcHNlZCBzcGFucykuIFRoZSB3aWRnZXRzIGZvciBhbGwgb2YgdGhlbSBuZWVkIHRvIGJlIGRyYXduLlxcbmZ1bmN0aW9uIGluc2VydExpbmVXaWRnZXRzKGNtLCBsaW5lVmlldywgZGltcykge1xcbiAgaW5zZXJ0TGluZVdpZGdldHNGb3IoY20sIGxpbmVWaWV3LmxpbmUsIGxpbmVWaWV3LCBkaW1zLCB0cnVlKVxcbiAgaWYgKGxpbmVWaWV3LnJlc3QpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lVmlldy5yZXN0Lmxlbmd0aDsgaSsrKVxcbiAgICB7IGluc2VydExpbmVXaWRnZXRzRm9yKGNtLCBsaW5lVmlldy5yZXN0W2ldLCBsaW5lVmlldywgZGltcywgZmFsc2UpIH0gfVxcbn1cXG5cXG5mdW5jdGlvbiBpbnNlcnRMaW5lV2lkZ2V0c0ZvcihjbSwgbGluZSwgbGluZVZpZXcsIGRpbXMsIGFsbG93QWJvdmUpIHtcXG4gIGlmICghbGluZS53aWRnZXRzKSB7IHJldHVybiB9XFxuICB2YXIgd3JhcCA9IGVuc3VyZUxpbmVXcmFwcGVkKGxpbmVWaWV3KVxcbiAgZm9yICh2YXIgaSA9IDAsIHdzID0gbGluZS53aWRnZXRzOyBpIDwgd3MubGVuZ3RoOyArK2kpIHtcXG4gICAgdmFyIHdpZGdldCA9IHdzW2ldLCBub2RlID0gZWx0KFxcXCJkaXZcXFwiLCBbd2lkZ2V0Lm5vZGVdLCBcXFwiQ29kZU1pcnJvci1saW5ld2lkZ2V0XFxcIilcXG4gICAgaWYgKCF3aWRnZXQuaGFuZGxlTW91c2VFdmVudHMpIHsgbm9kZS5zZXRBdHRyaWJ1dGUoXFxcImNtLWlnbm9yZS1ldmVudHNcXFwiLCBcXFwidHJ1ZVxcXCIpIH1cXG4gICAgcG9zaXRpb25MaW5lV2lkZ2V0KHdpZGdldCwgbm9kZSwgbGluZVZpZXcsIGRpbXMpXFxuICAgIGNtLmRpc3BsYXkuaW5wdXQuc2V0VW5lZGl0YWJsZShub2RlKVxcbiAgICBpZiAoYWxsb3dBYm92ZSAmJiB3aWRnZXQuYWJvdmUpXFxuICAgICAgeyB3cmFwLmluc2VydEJlZm9yZShub2RlLCBsaW5lVmlldy5ndXR0ZXIgfHwgbGluZVZpZXcudGV4dCkgfVxcbiAgICBlbHNlXFxuICAgICAgeyB3cmFwLmFwcGVuZENoaWxkKG5vZGUpIH1cXG4gICAgc2lnbmFsTGF0ZXIod2lkZ2V0LCBcXFwicmVkcmF3XFxcIilcXG4gIH1cXG59XFxuXFxuZnVuY3Rpb24gcG9zaXRpb25MaW5lV2lkZ2V0KHdpZGdldCwgbm9kZSwgbGluZVZpZXcsIGRpbXMpIHtcXG4gIGlmICh3aWRnZXQubm9IU2Nyb2xsKSB7XFxuICAgIDsobGluZVZpZXcuYWxpZ25hYmxlIHx8IChsaW5lVmlldy5hbGlnbmFibGUgPSBbXSkpLnB1c2gobm9kZSlcXG4gICAgdmFyIHdpZHRoID0gZGltcy53cmFwcGVyV2lkdGhcXG4gICAgbm9kZS5zdHlsZS5sZWZ0ID0gZGltcy5maXhlZFBvcyArIFxcXCJweFxcXCJcXG4gICAgaWYgKCF3aWRnZXQuY292ZXJHdXR0ZXIpIHtcXG4gICAgICB3aWR0aCAtPSBkaW1zLmd1dHRlclRvdGFsV2lkdGhcXG4gICAgICBub2RlLnN0eWxlLnBhZGRpbmdMZWZ0ID0gZGltcy5ndXR0ZXJUb3RhbFdpZHRoICsgXFxcInB4XFxcIlxcbiAgICB9XFxuICAgIG5vZGUuc3R5bGUud2lkdGggPSB3aWR0aCArIFxcXCJweFxcXCJcXG4gIH1cXG4gIGlmICh3aWRnZXQuY292ZXJHdXR0ZXIpIHtcXG4gICAgbm9kZS5zdHlsZS56SW5kZXggPSA1XFxuICAgIG5vZGUuc3R5bGUucG9zaXRpb24gPSBcXFwicmVsYXRpdmVcXFwiXFxuICAgIGlmICghd2lkZ2V0Lm5vSFNjcm9sbCkgeyBub2RlLnN0eWxlLm1hcmdpbkxlZnQgPSAtZGltcy5ndXR0ZXJUb3RhbFdpZHRoICsgXFxcInB4XFxcIiB9XFxuICB9XFxufVxcblxcbmZ1bmN0aW9uIHdpZGdldEhlaWdodCh3aWRnZXQpIHtcXG4gIGlmICh3aWRnZXQuaGVpZ2h0ICE9IG51bGwpIHsgcmV0dXJuIHdpZGdldC5oZWlnaHQgfVxcbiAgdmFyIGNtID0gd2lkZ2V0LmRvYy5jbVxcbiAgaWYgKCFjbSkgeyByZXR1cm4gMCB9XFxuICBpZiAoIWNvbnRhaW5zKGRvY3VtZW50LmJvZHksIHdpZGdldC5ub2RlKSkge1xcbiAgICB2YXIgcGFyZW50U3R5bGUgPSBcXFwicG9zaXRpb246IHJlbGF0aXZlO1xcXCJcXG4gICAgaWYgKHdpZGdldC5jb3Zlckd1dHRlcilcXG4gICAgICB7IHBhcmVudFN0eWxlICs9IFxcXCJtYXJnaW4tbGVmdDogLVxcXCIgKyBjbS5kaXNwbGF5Lmd1dHRlcnMub2Zmc2V0V2lkdGggKyBcXFwicHg7XFxcIiB9XFxuICAgIGlmICh3aWRnZXQubm9IU2Nyb2xsKVxcbiAgICAgIHsgcGFyZW50U3R5bGUgKz0gXFxcIndpZHRoOiBcXFwiICsgY20uZGlzcGxheS53cmFwcGVyLmNsaWVudFdpZHRoICsgXFxcInB4O1xcXCIgfVxcbiAgICByZW1vdmVDaGlsZHJlbkFuZEFkZChjbS5kaXNwbGF5Lm1lYXN1cmUsIGVsdChcXFwiZGl2XFxcIiwgW3dpZGdldC5ub2RlXSwgbnVsbCwgcGFyZW50U3R5bGUpKVxcbiAgfVxcbiAgcmV0dXJuIHdpZGdldC5oZWlnaHQgPSB3aWRnZXQubm9kZS5wYXJlbnROb2RlLm9mZnNldEhlaWdodFxcbn1cXG5cXG4vLyBSZXR1cm4gdHJ1ZSB3aGVuIHRoZSBnaXZlbiBtb3VzZSBldmVudCBoYXBwZW5lZCBpbiBhIHdpZGdldFxcbmZ1bmN0aW9uIGV2ZW50SW5XaWRnZXQoZGlzcGxheSwgZSkge1xcbiAgZm9yICh2YXIgbiA9IGVfdGFyZ2V0KGUpOyBuICE9IGRpc3BsYXkud3JhcHBlcjsgbiA9IG4ucGFyZW50Tm9kZSkge1xcbiAgICBpZiAoIW4gfHwgKG4ubm9kZVR5cGUgPT0gMSAmJiBuLmdldEF0dHJpYnV0ZShcXFwiY20taWdub3JlLWV2ZW50c1xcXCIpID09IFxcXCJ0cnVlXFxcIikgfHxcXG4gICAgICAgIChuLnBhcmVudE5vZGUgPT0gZGlzcGxheS5zaXplciAmJiBuICE9IGRpc3BsYXkubW92ZXIpKVxcbiAgICAgIHsgcmV0dXJuIHRydWUgfVxcbiAgfVxcbn1cXG5cXG4vLyBQT1NJVElPTiBNRUFTVVJFTUVOVFxcblxcbmZ1bmN0aW9uIHBhZGRpbmdUb3AoZGlzcGxheSkge3JldHVybiBkaXNwbGF5LmxpbmVTcGFjZS5vZmZzZXRUb3B9XFxuZnVuY3Rpb24gcGFkZGluZ1ZlcnQoZGlzcGxheSkge3JldHVybiBkaXNwbGF5Lm1vdmVyLm9mZnNldEhlaWdodCAtIGRpc3BsYXkubGluZVNwYWNlLm9mZnNldEhlaWdodH1cXG5mdW5jdGlvbiBwYWRkaW5nSChkaXNwbGF5KSB7XFxuICBpZiAoZGlzcGxheS5jYWNoZWRQYWRkaW5nSCkgeyByZXR1cm4gZGlzcGxheS5jYWNoZWRQYWRkaW5nSCB9XFxuICB2YXIgZSA9IHJlbW92ZUNoaWxkcmVuQW5kQWRkKGRpc3BsYXkubWVhc3VyZSwgZWx0KFxcXCJwcmVcXFwiLCBcXFwieFxcXCIpKVxcbiAgdmFyIHN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUgPyB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlKSA6IGUuY3VycmVudFN0eWxlXFxuICB2YXIgZGF0YSA9IHtsZWZ0OiBwYXJzZUludChzdHlsZS5wYWRkaW5nTGVmdCksIHJpZ2h0OiBwYXJzZUludChzdHlsZS5wYWRkaW5nUmlnaHQpfVxcbiAgaWYgKCFpc05hTihkYXRhLmxlZnQpICYmICFpc05hTihkYXRhLnJpZ2h0KSkgeyBkaXNwbGF5LmNhY2hlZFBhZGRpbmdIID0gZGF0YSB9XFxuICByZXR1cm4gZGF0YVxcbn1cXG5cXG5mdW5jdGlvbiBzY3JvbGxHYXAoY20pIHsgcmV0dXJuIHNjcm9sbGVyR2FwIC0gY20uZGlzcGxheS5uYXRpdmVCYXJXaWR0aCB9XFxuZnVuY3Rpb24gZGlzcGxheVdpZHRoKGNtKSB7XFxuICByZXR1cm4gY20uZGlzcGxheS5zY3JvbGxlci5jbGllbnRXaWR0aCAtIHNjcm9sbEdhcChjbSkgLSBjbS5kaXNwbGF5LmJhcldpZHRoXFxufVxcbmZ1bmN0aW9uIGRpc3BsYXlIZWlnaHQoY20pIHtcXG4gIHJldHVybiBjbS5kaXNwbGF5LnNjcm9sbGVyLmNsaWVudEhlaWdodCAtIHNjcm9sbEdhcChjbSkgLSBjbS5kaXNwbGF5LmJhckhlaWdodFxcbn1cXG5cXG4vLyBFbnN1cmUgdGhlIGxpbmVWaWV3LndyYXBwaW5nLmhlaWdodHMgYXJyYXkgaXMgcG9wdWxhdGVkLiBUaGlzIGlzXFxuLy8gYW4gYXJyYXkgb2YgYm90dG9tIG9mZnNldHMgZm9yIHRoZSBsaW5lcyB0aGF0IG1ha2UgdXAgYSBkcmF3blxcbi8vIGxpbmUuIFdoZW4gbGluZVdyYXBwaW5nIGlzIG9uLCB0aGVyZSBtaWdodCBiZSBtb3JlIHRoYW4gb25lXFxuLy8gaGVpZ2h0LlxcbmZ1bmN0aW9uIGVuc3VyZUxpbmVIZWlnaHRzKGNtLCBsaW5lVmlldywgcmVjdCkge1xcbiAgdmFyIHdyYXBwaW5nID0gY20ub3B0aW9ucy5saW5lV3JhcHBpbmdcXG4gIHZhciBjdXJXaWR0aCA9IHdyYXBwaW5nICYmIGRpc3BsYXlXaWR0aChjbSlcXG4gIGlmICghbGluZVZpZXcubWVhc3VyZS5oZWlnaHRzIHx8IHdyYXBwaW5nICYmIGxpbmVWaWV3Lm1lYXN1cmUud2lkdGggIT0gY3VyV2lkdGgpIHtcXG4gICAgdmFyIGhlaWdodHMgPSBsaW5lVmlldy5tZWFzdXJlLmhlaWdodHMgPSBbXVxcbiAgICBpZiAod3JhcHBpbmcpIHtcXG4gICAgICBsaW5lVmlldy5tZWFzdXJlLndpZHRoID0gY3VyV2lkdGhcXG4gICAgICB2YXIgcmVjdHMgPSBsaW5lVmlldy50ZXh0LmZpcnN0Q2hpbGQuZ2V0Q2xpZW50UmVjdHMoKVxcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVjdHMubGVuZ3RoIC0gMTsgaSsrKSB7XFxuICAgICAgICB2YXIgY3VyID0gcmVjdHNbaV0sIG5leHQgPSByZWN0c1tpICsgMV1cXG4gICAgICAgIGlmIChNYXRoLmFicyhjdXIuYm90dG9tIC0gbmV4dC5ib3R0b20pID4gMilcXG4gICAgICAgICAgeyBoZWlnaHRzLnB1c2goKGN1ci5ib3R0b20gKyBuZXh0LnRvcCkgLyAyIC0gcmVjdC50b3ApIH1cXG4gICAgICB9XFxuICAgIH1cXG4gICAgaGVpZ2h0cy5wdXNoKHJlY3QuYm90dG9tIC0gcmVjdC50b3ApXFxuICB9XFxufVxcblxcbi8vIEZpbmQgYSBsaW5lIG1hcCAobWFwcGluZyBjaGFyYWN0ZXIgb2Zmc2V0cyB0byB0ZXh0IG5vZGVzKSBhbmQgYVxcbi8vIG1lYXN1cmVtZW50IGNhY2hlIGZvciB0aGUgZ2l2ZW4gbGluZSBudW1iZXIuIChBIGxpbmUgdmlldyBtaWdodFxcbi8vIGNvbnRhaW4gbXVsdGlwbGUgbGluZXMgd2hlbiBjb2xsYXBzZWQgcmFuZ2VzIGFyZSBwcmVzZW50LilcXG5mdW5jdGlvbiBtYXBGcm9tTGluZVZpZXcobGluZVZpZXcsIGxpbmUsIGxpbmVOKSB7XFxuICBpZiAobGluZVZpZXcubGluZSA9PSBsaW5lKVxcbiAgICB7IHJldHVybiB7bWFwOiBsaW5lVmlldy5tZWFzdXJlLm1hcCwgY2FjaGU6IGxpbmVWaWV3Lm1lYXN1cmUuY2FjaGV9IH1cXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGluZVZpZXcucmVzdC5sZW5ndGg7IGkrKylcXG4gICAgeyBpZiAobGluZVZpZXcucmVzdFtpXSA9PSBsaW5lKVxcbiAgICAgIHsgcmV0dXJuIHttYXA6IGxpbmVWaWV3Lm1lYXN1cmUubWFwc1tpXSwgY2FjaGU6IGxpbmVWaWV3Lm1lYXN1cmUuY2FjaGVzW2ldfSB9IH1cXG4gIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IGxpbmVWaWV3LnJlc3QubGVuZ3RoOyBpJDErKylcXG4gICAgeyBpZiAobGluZU5vKGxpbmVWaWV3LnJlc3RbaSQxXSkgPiBsaW5lTilcXG4gICAgICB7IHJldHVybiB7bWFwOiBsaW5lVmlldy5tZWFzdXJlLm1hcHNbaSQxXSwgY2FjaGU6IGxpbmVWaWV3Lm1lYXN1cmUuY2FjaGVzW2kkMV0sIGJlZm9yZTogdHJ1ZX0gfSB9XFxufVxcblxcbi8vIFJlbmRlciBhIGxpbmUgaW50byB0aGUgaGlkZGVuIG5vZGUgZGlzcGxheS5leHRlcm5hbE1lYXN1cmVkLiBVc2VkXFxuLy8gd2hlbiBtZWFzdXJlbWVudCBpcyBuZWVkZWQgZm9yIGEgbGluZSB0aGF0J3Mgbm90IGluIHRoZSB2aWV3cG9ydC5cXG5mdW5jdGlvbiB1cGRhdGVFeHRlcm5hbE1lYXN1cmVtZW50KGNtLCBsaW5lKSB7XFxuICBsaW5lID0gdmlzdWFsTGluZShsaW5lKVxcbiAgdmFyIGxpbmVOID0gbGluZU5vKGxpbmUpXFxuICB2YXIgdmlldyA9IGNtLmRpc3BsYXkuZXh0ZXJuYWxNZWFzdXJlZCA9IG5ldyBMaW5lVmlldyhjbS5kb2MsIGxpbmUsIGxpbmVOKVxcbiAgdmlldy5saW5lTiA9IGxpbmVOXFxuICB2YXIgYnVpbHQgPSB2aWV3LmJ1aWx0ID0gYnVpbGRMaW5lQ29udGVudChjbSwgdmlldylcXG4gIHZpZXcudGV4dCA9IGJ1aWx0LnByZVxcbiAgcmVtb3ZlQ2hpbGRyZW5BbmRBZGQoY20uZGlzcGxheS5saW5lTWVhc3VyZSwgYnVpbHQucHJlKVxcbiAgcmV0dXJuIHZpZXdcXG59XFxuXFxuLy8gR2V0IGEge3RvcCwgYm90dG9tLCBsZWZ0LCByaWdodH0gYm94IChpbiBsaW5lLWxvY2FsIGNvb3JkaW5hdGVzKVxcbi8vIGZvciBhIGdpdmVuIGNoYXJhY3Rlci5cXG5mdW5jdGlvbiBtZWFzdXJlQ2hhcihjbSwgbGluZSwgY2gsIGJpYXMpIHtcXG4gIHJldHVybiBtZWFzdXJlQ2hhclByZXBhcmVkKGNtLCBwcmVwYXJlTWVhc3VyZUZvckxpbmUoY20sIGxpbmUpLCBjaCwgYmlhcylcXG59XFxuXFxuLy8gRmluZCBhIGxpbmUgdmlldyB0aGF0IGNvcnJlc3BvbmRzIHRvIHRoZSBnaXZlbiBsaW5lIG51bWJlci5cXG5mdW5jdGlvbiBmaW5kVmlld0ZvckxpbmUoY20sIGxpbmVOKSB7XFxuICBpZiAobGluZU4gPj0gY20uZGlzcGxheS52aWV3RnJvbSAmJiBsaW5lTiA8IGNtLmRpc3BsYXkudmlld1RvKVxcbiAgICB7IHJldHVybiBjbS5kaXNwbGF5LnZpZXdbZmluZFZpZXdJbmRleChjbSwgbGluZU4pXSB9XFxuICB2YXIgZXh0ID0gY20uZGlzcGxheS5leHRlcm5hbE1lYXN1cmVkXFxuICBpZiAoZXh0ICYmIGxpbmVOID49IGV4dC5saW5lTiAmJiBsaW5lTiA8IGV4dC5saW5lTiArIGV4dC5zaXplKVxcbiAgICB7IHJldHVybiBleHQgfVxcbn1cXG5cXG4vLyBNZWFzdXJlbWVudCBjYW4gYmUgc3BsaXQgaW4gdHdvIHN0ZXBzLCB0aGUgc2V0LXVwIHdvcmsgdGhhdFxcbi8vIGFwcGxpZXMgdG8gdGhlIHdob2xlIGxpbmUsIGFuZCB0aGUgbWVhc3VyZW1lbnQgb2YgdGhlIGFjdHVhbFxcbi8vIGNoYXJhY3Rlci4gRnVuY3Rpb25zIGxpa2UgY29vcmRzQ2hhciwgdGhhdCBuZWVkIHRvIGRvIGEgbG90IG9mXFxuLy8gbWVhc3VyZW1lbnRzIGluIGEgcm93LCBjYW4gdGh1cyBlbnN1cmUgdGhhdCB0aGUgc2V0LXVwIHdvcmsgaXNcXG4vLyBvbmx5IGRvbmUgb25jZS5cXG5mdW5jdGlvbiBwcmVwYXJlTWVhc3VyZUZvckxpbmUoY20sIGxpbmUpIHtcXG4gIHZhciBsaW5lTiA9IGxpbmVObyhsaW5lKVxcbiAgdmFyIHZpZXcgPSBmaW5kVmlld0ZvckxpbmUoY20sIGxpbmVOKVxcbiAgaWYgKHZpZXcgJiYgIXZpZXcudGV4dCkge1xcbiAgICB2aWV3ID0gbnVsbFxcbiAgfSBlbHNlIGlmICh2aWV3ICYmIHZpZXcuY2hhbmdlcykge1xcbiAgICB1cGRhdGVMaW5lRm9yQ2hhbmdlcyhjbSwgdmlldywgbGluZU4sIGdldERpbWVuc2lvbnMoY20pKVxcbiAgICBjbS5jdXJPcC5mb3JjZVVwZGF0ZSA9IHRydWVcXG4gIH1cXG4gIGlmICghdmlldylcXG4gICAgeyB2aWV3ID0gdXBkYXRlRXh0ZXJuYWxNZWFzdXJlbWVudChjbSwgbGluZSkgfVxcblxcbiAgdmFyIGluZm8gPSBtYXBGcm9tTGluZVZpZXcodmlldywgbGluZSwgbGluZU4pXFxuICByZXR1cm4ge1xcbiAgICBsaW5lOiBsaW5lLCB2aWV3OiB2aWV3LCByZWN0OiBudWxsLFxcbiAgICBtYXA6IGluZm8ubWFwLCBjYWNoZTogaW5mby5jYWNoZSwgYmVmb3JlOiBpbmZvLmJlZm9yZSxcXG4gICAgaGFzSGVpZ2h0czogZmFsc2VcXG4gIH1cXG59XFxuXFxuLy8gR2l2ZW4gYSBwcmVwYXJlZCBtZWFzdXJlbWVudCBvYmplY3QsIG1lYXN1cmVzIHRoZSBwb3NpdGlvbiBvZiBhblxcbi8vIGFjdHVhbCBjaGFyYWN0ZXIgKG9yIGZldGNoZXMgaXQgZnJvbSB0aGUgY2FjaGUpLlxcbmZ1bmN0aW9uIG1lYXN1cmVDaGFyUHJlcGFyZWQoY20sIHByZXBhcmVkLCBjaCwgYmlhcywgdmFySGVpZ2h0KSB7XFxuICBpZiAocHJlcGFyZWQuYmVmb3JlKSB7IGNoID0gLTEgfVxcbiAgdmFyIGtleSA9IGNoICsgKGJpYXMgfHwgXFxcIlxcXCIpLCBmb3VuZFxcbiAgaWYgKHByZXBhcmVkLmNhY2hlLmhhc093blByb3BlcnR5KGtleSkpIHtcXG4gICAgZm91bmQgPSBwcmVwYXJlZC5jYWNoZVtrZXldXFxuICB9IGVsc2Uge1xcbiAgICBpZiAoIXByZXBhcmVkLnJlY3QpXFxuICAgICAgeyBwcmVwYXJlZC5yZWN0ID0gcHJlcGFyZWQudmlldy50ZXh0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpIH1cXG4gICAgaWYgKCFwcmVwYXJlZC5oYXNIZWlnaHRzKSB7XFxuICAgICAgZW5zdXJlTGluZUhlaWdodHMoY20sIHByZXBhcmVkLnZpZXcsIHByZXBhcmVkLnJlY3QpXFxuICAgICAgcHJlcGFyZWQuaGFzSGVpZ2h0cyA9IHRydWVcXG4gICAgfVxcbiAgICBmb3VuZCA9IG1lYXN1cmVDaGFySW5uZXIoY20sIHByZXBhcmVkLCBjaCwgYmlhcylcXG4gICAgaWYgKCFmb3VuZC5ib2d1cykgeyBwcmVwYXJlZC5jYWNoZVtrZXldID0gZm91bmQgfVxcbiAgfVxcbiAgcmV0dXJuIHtsZWZ0OiBmb3VuZC5sZWZ0LCByaWdodDogZm91bmQucmlnaHQsXFxuICAgICAgICAgIHRvcDogdmFySGVpZ2h0ID8gZm91bmQucnRvcCA6IGZvdW5kLnRvcCxcXG4gICAgICAgICAgYm90dG9tOiB2YXJIZWlnaHQgPyBmb3VuZC5yYm90dG9tIDogZm91bmQuYm90dG9tfVxcbn1cXG5cXG52YXIgbnVsbFJlY3QgPSB7bGVmdDogMCwgcmlnaHQ6IDAsIHRvcDogMCwgYm90dG9tOiAwfVxcblxcbmZ1bmN0aW9uIG5vZGVBbmRPZmZzZXRJbkxpbmVNYXAobWFwLCBjaCwgYmlhcykge1xcbiAgdmFyIG5vZGUsIHN0YXJ0LCBlbmQsIGNvbGxhcHNlLCBtU3RhcnQsIG1FbmRcXG4gIC8vIEZpcnN0LCBzZWFyY2ggdGhlIGxpbmUgbWFwIGZvciB0aGUgdGV4dCBub2RlIGNvcnJlc3BvbmRpbmcgdG8sXFxuICAvLyBvciBjbG9zZXN0IHRvLCB0aGUgdGFyZ2V0IGNoYXJhY3Rlci5cXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbWFwLmxlbmd0aDsgaSArPSAzKSB7XFxuICAgIG1TdGFydCA9IG1hcFtpXVxcbiAgICBtRW5kID0gbWFwW2kgKyAxXVxcbiAgICBpZiAoY2ggPCBtU3RhcnQpIHtcXG4gICAgICBzdGFydCA9IDA7IGVuZCA9IDFcXG4gICAgICBjb2xsYXBzZSA9IFxcXCJsZWZ0XFxcIlxcbiAgICB9IGVsc2UgaWYgKGNoIDwgbUVuZCkge1xcbiAgICAgIHN0YXJ0ID0gY2ggLSBtU3RhcnRcXG4gICAgICBlbmQgPSBzdGFydCArIDFcXG4gICAgfSBlbHNlIGlmIChpID09IG1hcC5sZW5ndGggLSAzIHx8IGNoID09IG1FbmQgJiYgbWFwW2kgKyAzXSA+IGNoKSB7XFxuICAgICAgZW5kID0gbUVuZCAtIG1TdGFydFxcbiAgICAgIHN0YXJ0ID0gZW5kIC0gMVxcbiAgICAgIGlmIChjaCA+PSBtRW5kKSB7IGNvbGxhcHNlID0gXFxcInJpZ2h0XFxcIiB9XFxuICAgIH1cXG4gICAgaWYgKHN0YXJ0ICE9IG51bGwpIHtcXG4gICAgICBub2RlID0gbWFwW2kgKyAyXVxcbiAgICAgIGlmIChtU3RhcnQgPT0gbUVuZCAmJiBiaWFzID09IChub2RlLmluc2VydExlZnQgPyBcXFwibGVmdFxcXCIgOiBcXFwicmlnaHRcXFwiKSlcXG4gICAgICAgIHsgY29sbGFwc2UgPSBiaWFzIH1cXG4gICAgICBpZiAoYmlhcyA9PSBcXFwibGVmdFxcXCIgJiYgc3RhcnQgPT0gMClcXG4gICAgICAgIHsgd2hpbGUgKGkgJiYgbWFwW2kgLSAyXSA9PSBtYXBbaSAtIDNdICYmIG1hcFtpIC0gMV0uaW5zZXJ0TGVmdCkge1xcbiAgICAgICAgICBub2RlID0gbWFwWyhpIC09IDMpICsgMl1cXG4gICAgICAgICAgY29sbGFwc2UgPSBcXFwibGVmdFxcXCJcXG4gICAgICAgIH0gfVxcbiAgICAgIGlmIChiaWFzID09IFxcXCJyaWdodFxcXCIgJiYgc3RhcnQgPT0gbUVuZCAtIG1TdGFydClcXG4gICAgICAgIHsgd2hpbGUgKGkgPCBtYXAubGVuZ3RoIC0gMyAmJiBtYXBbaSArIDNdID09IG1hcFtpICsgNF0gJiYgIW1hcFtpICsgNV0uaW5zZXJ0TGVmdCkge1xcbiAgICAgICAgICBub2RlID0gbWFwWyhpICs9IDMpICsgMl1cXG4gICAgICAgICAgY29sbGFwc2UgPSBcXFwicmlnaHRcXFwiXFxuICAgICAgICB9IH1cXG4gICAgICBicmVha1xcbiAgICB9XFxuICB9XFxuICByZXR1cm4ge25vZGU6IG5vZGUsIHN0YXJ0OiBzdGFydCwgZW5kOiBlbmQsIGNvbGxhcHNlOiBjb2xsYXBzZSwgY292ZXJTdGFydDogbVN0YXJ0LCBjb3ZlckVuZDogbUVuZH1cXG59XFxuXFxuZnVuY3Rpb24gZ2V0VXNlZnVsUmVjdChyZWN0cywgYmlhcykge1xcbiAgdmFyIHJlY3QgPSBudWxsUmVjdFxcbiAgaWYgKGJpYXMgPT0gXFxcImxlZnRcXFwiKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcmVjdHMubGVuZ3RoOyBpKyspIHtcXG4gICAgaWYgKChyZWN0ID0gcmVjdHNbaV0pLmxlZnQgIT0gcmVjdC5yaWdodCkgeyBicmVhayB9XFxuICB9IH0gZWxzZSB7IGZvciAodmFyIGkkMSA9IHJlY3RzLmxlbmd0aCAtIDE7IGkkMSA+PSAwOyBpJDEtLSkge1xcbiAgICBpZiAoKHJlY3QgPSByZWN0c1tpJDFdKS5sZWZ0ICE9IHJlY3QucmlnaHQpIHsgYnJlYWsgfVxcbiAgfSB9XFxuICByZXR1cm4gcmVjdFxcbn1cXG5cXG5mdW5jdGlvbiBtZWFzdXJlQ2hhcklubmVyKGNtLCBwcmVwYXJlZCwgY2gsIGJpYXMpIHtcXG4gIHZhciBwbGFjZSA9IG5vZGVBbmRPZmZzZXRJbkxpbmVNYXAocHJlcGFyZWQubWFwLCBjaCwgYmlhcylcXG4gIHZhciBub2RlID0gcGxhY2Uubm9kZSwgc3RhcnQgPSBwbGFjZS5zdGFydCwgZW5kID0gcGxhY2UuZW5kLCBjb2xsYXBzZSA9IHBsYWNlLmNvbGxhcHNlXFxuXFxuICB2YXIgcmVjdFxcbiAgaWYgKG5vZGUubm9kZVR5cGUgPT0gMykgeyAvLyBJZiBpdCBpcyBhIHRleHQgbm9kZSwgdXNlIGEgcmFuZ2UgdG8gcmV0cmlldmUgdGhlIGNvb3JkaW5hdGVzLlxcbiAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCA0OyBpJDErKykgeyAvLyBSZXRyeSBhIG1heGltdW0gb2YgNCB0aW1lcyB3aGVuIG5vbnNlbnNlIHJlY3RhbmdsZXMgYXJlIHJldHVybmVkXFxuICAgICAgd2hpbGUgKHN0YXJ0ICYmIGlzRXh0ZW5kaW5nQ2hhcihwcmVwYXJlZC5saW5lLnRleHQuY2hhckF0KHBsYWNlLmNvdmVyU3RhcnQgKyBzdGFydCkpKSB7IC0tc3RhcnQgfVxcbiAgICAgIHdoaWxlIChwbGFjZS5jb3ZlclN0YXJ0ICsgZW5kIDwgcGxhY2UuY292ZXJFbmQgJiYgaXNFeHRlbmRpbmdDaGFyKHByZXBhcmVkLmxpbmUudGV4dC5jaGFyQXQocGxhY2UuY292ZXJTdGFydCArIGVuZCkpKSB7ICsrZW5kIH1cXG4gICAgICBpZiAoaWUgJiYgaWVfdmVyc2lvbiA8IDkgJiYgc3RhcnQgPT0gMCAmJiBlbmQgPT0gcGxhY2UuY292ZXJFbmQgLSBwbGFjZS5jb3ZlclN0YXJ0KVxcbiAgICAgICAgeyByZWN0ID0gbm9kZS5wYXJlbnROb2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpIH1cXG4gICAgICBlbHNlXFxuICAgICAgICB7IHJlY3QgPSBnZXRVc2VmdWxSZWN0KHJhbmdlKG5vZGUsIHN0YXJ0LCBlbmQpLmdldENsaWVudFJlY3RzKCksIGJpYXMpIH1cXG4gICAgICBpZiAocmVjdC5sZWZ0IHx8IHJlY3QucmlnaHQgfHwgc3RhcnQgPT0gMCkgeyBicmVhayB9XFxuICAgICAgZW5kID0gc3RhcnRcXG4gICAgICBzdGFydCA9IHN0YXJ0IC0gMVxcbiAgICAgIGNvbGxhcHNlID0gXFxcInJpZ2h0XFxcIlxcbiAgICB9XFxuICAgIGlmIChpZSAmJiBpZV92ZXJzaW9uIDwgMTEpIHsgcmVjdCA9IG1heWJlVXBkYXRlUmVjdEZvclpvb21pbmcoY20uZGlzcGxheS5tZWFzdXJlLCByZWN0KSB9XFxuICB9IGVsc2UgeyAvLyBJZiBpdCBpcyBhIHdpZGdldCwgc2ltcGx5IGdldCB0aGUgYm94IGZvciB0aGUgd2hvbGUgd2lkZ2V0LlxcbiAgICBpZiAoc3RhcnQgPiAwKSB7IGNvbGxhcHNlID0gYmlhcyA9IFxcXCJyaWdodFxcXCIgfVxcbiAgICB2YXIgcmVjdHNcXG4gICAgaWYgKGNtLm9wdGlvbnMubGluZVdyYXBwaW5nICYmIChyZWN0cyA9IG5vZGUuZ2V0Q2xpZW50UmVjdHMoKSkubGVuZ3RoID4gMSlcXG4gICAgICB7IHJlY3QgPSByZWN0c1tiaWFzID09IFxcXCJyaWdodFxcXCIgPyByZWN0cy5sZW5ndGggLSAxIDogMF0gfVxcbiAgICBlbHNlXFxuICAgICAgeyByZWN0ID0gbm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSB9XFxuICB9XFxuICBpZiAoaWUgJiYgaWVfdmVyc2lvbiA8IDkgJiYgIXN0YXJ0ICYmICghcmVjdCB8fCAhcmVjdC5sZWZ0ICYmICFyZWN0LnJpZ2h0KSkge1xcbiAgICB2YXIgclNwYW4gPSBub2RlLnBhcmVudE5vZGUuZ2V0Q2xpZW50UmVjdHMoKVswXVxcbiAgICBpZiAoclNwYW4pXFxuICAgICAgeyByZWN0ID0ge2xlZnQ6IHJTcGFuLmxlZnQsIHJpZ2h0OiByU3Bhbi5sZWZ0ICsgY2hhcldpZHRoKGNtLmRpc3BsYXkpLCB0b3A6IHJTcGFuLnRvcCwgYm90dG9tOiByU3Bhbi5ib3R0b219IH1cXG4gICAgZWxzZVxcbiAgICAgIHsgcmVjdCA9IG51bGxSZWN0IH1cXG4gIH1cXG5cXG4gIHZhciBydG9wID0gcmVjdC50b3AgLSBwcmVwYXJlZC5yZWN0LnRvcCwgcmJvdCA9IHJlY3QuYm90dG9tIC0gcHJlcGFyZWQucmVjdC50b3BcXG4gIHZhciBtaWQgPSAocnRvcCArIHJib3QpIC8gMlxcbiAgdmFyIGhlaWdodHMgPSBwcmVwYXJlZC52aWV3Lm1lYXN1cmUuaGVpZ2h0c1xcbiAgdmFyIGkgPSAwXFxuICBmb3IgKDsgaSA8IGhlaWdodHMubGVuZ3RoIC0gMTsgaSsrKVxcbiAgICB7IGlmIChtaWQgPCBoZWlnaHRzW2ldKSB7IGJyZWFrIH0gfVxcbiAgdmFyIHRvcCA9IGkgPyBoZWlnaHRzW2kgLSAxXSA6IDAsIGJvdCA9IGhlaWdodHNbaV1cXG4gIHZhciByZXN1bHQgPSB7bGVmdDogKGNvbGxhcHNlID09IFxcXCJyaWdodFxcXCIgPyByZWN0LnJpZ2h0IDogcmVjdC5sZWZ0KSAtIHByZXBhcmVkLnJlY3QubGVmdCxcXG4gICAgICAgICAgICAgICAgcmlnaHQ6IChjb2xsYXBzZSA9PSBcXFwibGVmdFxcXCIgPyByZWN0LmxlZnQgOiByZWN0LnJpZ2h0KSAtIHByZXBhcmVkLnJlY3QubGVmdCxcXG4gICAgICAgICAgICAgICAgdG9wOiB0b3AsIGJvdHRvbTogYm90fVxcbiAgaWYgKCFyZWN0LmxlZnQgJiYgIXJlY3QucmlnaHQpIHsgcmVzdWx0LmJvZ3VzID0gdHJ1ZSB9XFxuICBpZiAoIWNtLm9wdGlvbnMuc2luZ2xlQ3Vyc29ySGVpZ2h0UGVyTGluZSkgeyByZXN1bHQucnRvcCA9IHJ0b3A7IHJlc3VsdC5yYm90dG9tID0gcmJvdCB9XFxuXFxuICByZXR1cm4gcmVzdWx0XFxufVxcblxcbi8vIFdvcmsgYXJvdW5kIHByb2JsZW0gd2l0aCBib3VuZGluZyBjbGllbnQgcmVjdHMgb24gcmFuZ2VzIGJlaW5nXFxuLy8gcmV0dXJuZWQgaW5jb3JyZWN0bHkgd2hlbiB6b29tZWQgb24gSUUxMCBhbmQgYmVsb3cuXFxuZnVuY3Rpb24gbWF5YmVVcGRhdGVSZWN0Rm9yWm9vbWluZyhtZWFzdXJlLCByZWN0KSB7XFxuICBpZiAoIXdpbmRvdy5zY3JlZW4gfHwgc2NyZWVuLmxvZ2ljYWxYRFBJID09IG51bGwgfHxcXG4gICAgICBzY3JlZW4ubG9naWNhbFhEUEkgPT0gc2NyZWVuLmRldmljZVhEUEkgfHwgIWhhc0JhZFpvb21lZFJlY3RzKG1lYXN1cmUpKVxcbiAgICB7IHJldHVybiByZWN0IH1cXG4gIHZhciBzY2FsZVggPSBzY3JlZW4ubG9naWNhbFhEUEkgLyBzY3JlZW4uZGV2aWNlWERQSVxcbiAgdmFyIHNjYWxlWSA9IHNjcmVlbi5sb2dpY2FsWURQSSAvIHNjcmVlbi5kZXZpY2VZRFBJXFxuICByZXR1cm4ge2xlZnQ6IHJlY3QubGVmdCAqIHNjYWxlWCwgcmlnaHQ6IHJlY3QucmlnaHQgKiBzY2FsZVgsXFxuICAgICAgICAgIHRvcDogcmVjdC50b3AgKiBzY2FsZVksIGJvdHRvbTogcmVjdC5ib3R0b20gKiBzY2FsZVl9XFxufVxcblxcbmZ1bmN0aW9uIGNsZWFyTGluZU1lYXN1cmVtZW50Q2FjaGVGb3IobGluZVZpZXcpIHtcXG4gIGlmIChsaW5lVmlldy5tZWFzdXJlKSB7XFxuICAgIGxpbmVWaWV3Lm1lYXN1cmUuY2FjaGUgPSB7fVxcbiAgICBsaW5lVmlldy5tZWFzdXJlLmhlaWdodHMgPSBudWxsXFxuICAgIGlmIChsaW5lVmlldy5yZXN0KSB7IGZvciAodmFyIGkgPSAwOyBpIDwgbGluZVZpZXcucmVzdC5sZW5ndGg7IGkrKylcXG4gICAgICB7IGxpbmVWaWV3Lm1lYXN1cmUuY2FjaGVzW2ldID0ge30gfSB9XFxuICB9XFxufVxcblxcbmZ1bmN0aW9uIGNsZWFyTGluZU1lYXN1cmVtZW50Q2FjaGUoY20pIHtcXG4gIGNtLmRpc3BsYXkuZXh0ZXJuYWxNZWFzdXJlID0gbnVsbFxcbiAgcmVtb3ZlQ2hpbGRyZW4oY20uZGlzcGxheS5saW5lTWVhc3VyZSlcXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY20uZGlzcGxheS52aWV3Lmxlbmd0aDsgaSsrKVxcbiAgICB7IGNsZWFyTGluZU1lYXN1cmVtZW50Q2FjaGVGb3IoY20uZGlzcGxheS52aWV3W2ldKSB9XFxufVxcblxcbmZ1bmN0aW9uIGNsZWFyQ2FjaGVzKGNtKSB7XFxuICBjbGVhckxpbmVNZWFzdXJlbWVudENhY2hlKGNtKVxcbiAgY20uZGlzcGxheS5jYWNoZWRDaGFyV2lkdGggPSBjbS5kaXNwbGF5LmNhY2hlZFRleHRIZWlnaHQgPSBjbS5kaXNwbGF5LmNhY2hlZFBhZGRpbmdIID0gbnVsbFxcbiAgaWYgKCFjbS5vcHRpb25zLmxpbmVXcmFwcGluZykgeyBjbS5kaXNwbGF5Lm1heExpbmVDaGFuZ2VkID0gdHJ1ZSB9XFxuICBjbS5kaXNwbGF5LmxpbmVOdW1DaGFycyA9IG51bGxcXG59XFxuXFxuZnVuY3Rpb24gcGFnZVNjcm9sbFgoKSB7IHJldHVybiB3aW5kb3cucGFnZVhPZmZzZXQgfHwgKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCB8fCBkb2N1bWVudC5ib2R5KS5zY3JvbGxMZWZ0IH1cXG5mdW5jdGlvbiBwYWdlU2Nyb2xsWSgpIHsgcmV0dXJuIHdpbmRvdy5wYWdlWU9mZnNldCB8fCAoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50IHx8IGRvY3VtZW50LmJvZHkpLnNjcm9sbFRvcCB9XFxuXFxuLy8gQ29udmVydHMgYSB7dG9wLCBib3R0b20sIGxlZnQsIHJpZ2h0fSBib3ggZnJvbSBsaW5lLWxvY2FsXFxuLy8gY29vcmRpbmF0ZXMgaW50byBhbm90aGVyIGNvb3JkaW5hdGUgc3lzdGVtLiBDb250ZXh0IG1heSBiZSBvbmUgb2ZcXG4vLyBcXFwibGluZVxcXCIsIFxcXCJkaXZcXFwiIChkaXNwbGF5LmxpbmVEaXYpLCBcXFwibG9jYWxcXFwiLi9udWxsIChlZGl0b3IpLCBcXFwid2luZG93XFxcIixcXG4vLyBvciBcXFwicGFnZVxcXCIuXFxuZnVuY3Rpb24gaW50b0Nvb3JkU3lzdGVtKGNtLCBsaW5lT2JqLCByZWN0LCBjb250ZXh0LCBpbmNsdWRlV2lkZ2V0cykge1xcbiAgaWYgKCFpbmNsdWRlV2lkZ2V0cyAmJiBsaW5lT2JqLndpZGdldHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lT2JqLndpZGdldHMubGVuZ3RoOyArK2kpIHsgaWYgKGxpbmVPYmoud2lkZ2V0c1tpXS5hYm92ZSkge1xcbiAgICB2YXIgc2l6ZSA9IHdpZGdldEhlaWdodChsaW5lT2JqLndpZGdldHNbaV0pXFxuICAgIHJlY3QudG9wICs9IHNpemU7IHJlY3QuYm90dG9tICs9IHNpemVcXG4gIH0gfSB9XFxuICBpZiAoY29udGV4dCA9PSBcXFwibGluZVxcXCIpIHsgcmV0dXJuIHJlY3QgfVxcbiAgaWYgKCFjb250ZXh0KSB7IGNvbnRleHQgPSBcXFwibG9jYWxcXFwiIH1cXG4gIHZhciB5T2ZmID0gaGVpZ2h0QXRMaW5lKGxpbmVPYmopXFxuICBpZiAoY29udGV4dCA9PSBcXFwibG9jYWxcXFwiKSB7IHlPZmYgKz0gcGFkZGluZ1RvcChjbS5kaXNwbGF5KSB9XFxuICBlbHNlIHsgeU9mZiAtPSBjbS5kaXNwbGF5LnZpZXdPZmZzZXQgfVxcbiAgaWYgKGNvbnRleHQgPT0gXFxcInBhZ2VcXFwiIHx8IGNvbnRleHQgPT0gXFxcIndpbmRvd1xcXCIpIHtcXG4gICAgdmFyIGxPZmYgPSBjbS5kaXNwbGF5LmxpbmVTcGFjZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxcbiAgICB5T2ZmICs9IGxPZmYudG9wICsgKGNvbnRleHQgPT0gXFxcIndpbmRvd1xcXCIgPyAwIDogcGFnZVNjcm9sbFkoKSlcXG4gICAgdmFyIHhPZmYgPSBsT2ZmLmxlZnQgKyAoY29udGV4dCA9PSBcXFwid2luZG93XFxcIiA/IDAgOiBwYWdlU2Nyb2xsWCgpKVxcbiAgICByZWN0LmxlZnQgKz0geE9mZjsgcmVjdC5yaWdodCArPSB4T2ZmXFxuICB9XFxuICByZWN0LnRvcCArPSB5T2ZmOyByZWN0LmJvdHRvbSArPSB5T2ZmXFxuICByZXR1cm4gcmVjdFxcbn1cXG5cXG4vLyBDb3ZlcnRzIGEgYm94IGZyb20gXFxcImRpdlxcXCIgY29vcmRzIHRvIGFub3RoZXIgY29vcmRpbmF0ZSBzeXN0ZW0uXFxuLy8gQ29udGV4dCBtYXkgYmUgXFxcIndpbmRvd1xcXCIsIFxcXCJwYWdlXFxcIiwgXFxcImRpdlxcXCIsIG9yIFxcXCJsb2NhbFxcXCIuL251bGwuXFxuZnVuY3Rpb24gZnJvbUNvb3JkU3lzdGVtKGNtLCBjb29yZHMsIGNvbnRleHQpIHtcXG4gIGlmIChjb250ZXh0ID09IFxcXCJkaXZcXFwiKSB7IHJldHVybiBjb29yZHMgfVxcbiAgdmFyIGxlZnQgPSBjb29yZHMubGVmdCwgdG9wID0gY29vcmRzLnRvcFxcbiAgLy8gRmlyc3QgbW92ZSBpbnRvIFxcXCJwYWdlXFxcIiBjb29yZGluYXRlIHN5c3RlbVxcbiAgaWYgKGNvbnRleHQgPT0gXFxcInBhZ2VcXFwiKSB7XFxuICAgIGxlZnQgLT0gcGFnZVNjcm9sbFgoKVxcbiAgICB0b3AgLT0gcGFnZVNjcm9sbFkoKVxcbiAgfSBlbHNlIGlmIChjb250ZXh0ID09IFxcXCJsb2NhbFxcXCIgfHwgIWNvbnRleHQpIHtcXG4gICAgdmFyIGxvY2FsQm94ID0gY20uZGlzcGxheS5zaXplci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxcbiAgICBsZWZ0ICs9IGxvY2FsQm94LmxlZnRcXG4gICAgdG9wICs9IGxvY2FsQm94LnRvcFxcbiAgfVxcblxcbiAgdmFyIGxpbmVTcGFjZUJveCA9IGNtLmRpc3BsYXkubGluZVNwYWNlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXFxuICByZXR1cm4ge2xlZnQ6IGxlZnQgLSBsaW5lU3BhY2VCb3gubGVmdCwgdG9wOiB0b3AgLSBsaW5lU3BhY2VCb3gudG9wfVxcbn1cXG5cXG5mdW5jdGlvbiBjaGFyQ29vcmRzKGNtLCBwb3MsIGNvbnRleHQsIGxpbmVPYmosIGJpYXMpIHtcXG4gIGlmICghbGluZU9iaikgeyBsaW5lT2JqID0gZ2V0TGluZShjbS5kb2MsIHBvcy5saW5lKSB9XFxuICByZXR1cm4gaW50b0Nvb3JkU3lzdGVtKGNtLCBsaW5lT2JqLCBtZWFzdXJlQ2hhcihjbSwgbGluZU9iaiwgcG9zLmNoLCBiaWFzKSwgY29udGV4dClcXG59XFxuXFxuLy8gUmV0dXJucyBhIGJveCBmb3IgYSBnaXZlbiBjdXJzb3IgcG9zaXRpb24sIHdoaWNoIG1heSBoYXZlIGFuXFxuLy8gJ290aGVyJyBwcm9wZXJ0eSBjb250YWluaW5nIHRoZSBwb3NpdGlvbiBvZiB0aGUgc2Vjb25kYXJ5IGN1cnNvclxcbi8vIG9uIGEgYmlkaSBib3VuZGFyeS5cXG4vLyBBIGN1cnNvciBQb3MobGluZSwgY2hhciwgXFxcImJlZm9yZVxcXCIpIGlzIG9uIHRoZSBzYW1lIHZpc3VhbCBsaW5lIGFzIGBjaGFyIC0gMWBcXG4vLyBhbmQgYWZ0ZXIgYGNoYXIgLSAxYCBpbiB3cml0aW5nIG9yZGVyIG9mIGBjaGFyIC0gMWBcXG4vLyBBIGN1cnNvciBQb3MobGluZSwgY2hhciwgXFxcImFmdGVyXFxcIikgaXMgb24gdGhlIHNhbWUgdmlzdWFsIGxpbmUgYXMgYGNoYXJgXFxuLy8gYW5kIGJlZm9yZSBgY2hhcmAgaW4gd3JpdGluZyBvcmRlciBvZiBgY2hhcmBcXG4vLyBFeGFtcGxlcyAodXBwZXItY2FzZSBsZXR0ZXJzIGFyZSBSVEwsIGxvd2VyLWNhc2UgYXJlIExUUik6XFxuLy8gICAgIFBvcygwLCAxLCAuLi4pXFxuLy8gICAgIGJlZm9yZSAgIGFmdGVyXFxuLy8gYWIgICAgIGF8YiAgICAgYXxiXFxuLy8gYUIgICAgIGF8QiAgICAgYUJ8XFxuLy8gQWIgICAgIHxBYiAgICAgQXxiXFxuLy8gQUIgICAgIEJ8QSAgICAgQnxBXFxuLy8gRXZlcnkgcG9zaXRpb24gYWZ0ZXIgdGhlIGxhc3QgY2hhcmFjdGVyIG9uIGEgbGluZSBpcyBjb25zaWRlcmVkIHRvIHN0aWNrXFxuLy8gdG8gdGhlIGxhc3QgY2hhcmFjdGVyIG9uIHRoZSBsaW5lLlxcbmZ1bmN0aW9uIGN1cnNvckNvb3JkcyhjbSwgcG9zLCBjb250ZXh0LCBsaW5lT2JqLCBwcmVwYXJlZE1lYXN1cmUsIHZhckhlaWdodCkge1xcbiAgbGluZU9iaiA9IGxpbmVPYmogfHwgZ2V0TGluZShjbS5kb2MsIHBvcy5saW5lKVxcbiAgaWYgKCFwcmVwYXJlZE1lYXN1cmUpIHsgcHJlcGFyZWRNZWFzdXJlID0gcHJlcGFyZU1lYXN1cmVGb3JMaW5lKGNtLCBsaW5lT2JqKSB9XFxuICBmdW5jdGlvbiBnZXQoY2gsIHJpZ2h0KSB7XFxuICAgIHZhciBtID0gbWVhc3VyZUNoYXJQcmVwYXJlZChjbSwgcHJlcGFyZWRNZWFzdXJlLCBjaCwgcmlnaHQgPyBcXFwicmlnaHRcXFwiIDogXFxcImxlZnRcXFwiLCB2YXJIZWlnaHQpXFxuICAgIGlmIChyaWdodCkgeyBtLmxlZnQgPSBtLnJpZ2h0OyB9IGVsc2UgeyBtLnJpZ2h0ID0gbS5sZWZ0IH1cXG4gICAgcmV0dXJuIGludG9Db29yZFN5c3RlbShjbSwgbGluZU9iaiwgbSwgY29udGV4dClcXG4gIH1cXG4gIHZhciBvcmRlciA9IGdldE9yZGVyKGxpbmVPYmopLCBjaCA9IHBvcy5jaCwgc3RpY2t5ID0gcG9zLnN0aWNreVxcbiAgaWYgKGNoID49IGxpbmVPYmoudGV4dC5sZW5ndGgpIHtcXG4gICAgY2ggPSBsaW5lT2JqLnRleHQubGVuZ3RoXFxuICAgIHN0aWNreSA9IFxcXCJiZWZvcmVcXFwiXFxuICB9IGVsc2UgaWYgKGNoIDw9IDApIHtcXG4gICAgY2ggPSAwXFxuICAgIHN0aWNreSA9IFxcXCJhZnRlclxcXCJcXG4gIH1cXG4gIGlmICghb3JkZXIpIHsgcmV0dXJuIGdldChzdGlja3kgPT0gXFxcImJlZm9yZVxcXCIgPyBjaCAtIDEgOiBjaCwgc3RpY2t5ID09IFxcXCJiZWZvcmVcXFwiKSB9XFxuXFxuICBmdW5jdGlvbiBnZXRCaWRpKGNoLCBwYXJ0UG9zLCBpbnZlcnQpIHtcXG4gICAgdmFyIHBhcnQgPSBvcmRlcltwYXJ0UG9zXSwgcmlnaHQgPSAocGFydC5sZXZlbCAlIDIpICE9IDBcXG4gICAgcmV0dXJuIGdldChpbnZlcnQgPyBjaCAtIDEgOiBjaCwgcmlnaHQgIT0gaW52ZXJ0KVxcbiAgfVxcbiAgdmFyIHBhcnRQb3MgPSBnZXRCaWRpUGFydEF0KG9yZGVyLCBjaCwgc3RpY2t5KVxcbiAgdmFyIG90aGVyID0gYmlkaU90aGVyXFxuICB2YXIgdmFsID0gZ2V0QmlkaShjaCwgcGFydFBvcywgc3RpY2t5ID09IFxcXCJiZWZvcmVcXFwiKVxcbiAgaWYgKG90aGVyICE9IG51bGwpIHsgdmFsLm90aGVyID0gZ2V0QmlkaShjaCwgb3RoZXIsIHN0aWNreSAhPSBcXFwiYmVmb3JlXFxcIikgfVxcbiAgcmV0dXJuIHZhbFxcbn1cXG5cXG4vLyBVc2VkIHRvIGNoZWFwbHkgZXN0aW1hdGUgdGhlIGNvb3JkaW5hdGVzIGZvciBhIHBvc2l0aW9uLiBVc2VkIGZvclxcbi8vIGludGVybWVkaWF0ZSBzY3JvbGwgdXBkYXRlcy5cXG5mdW5jdGlvbiBlc3RpbWF0ZUNvb3JkcyhjbSwgcG9zKSB7XFxuICB2YXIgbGVmdCA9IDBcXG4gIHBvcyA9IGNsaXBQb3MoY20uZG9jLCBwb3MpXFxuICBpZiAoIWNtLm9wdGlvbnMubGluZVdyYXBwaW5nKSB7IGxlZnQgPSBjaGFyV2lkdGgoY20uZGlzcGxheSkgKiBwb3MuY2ggfVxcbiAgdmFyIGxpbmVPYmogPSBnZXRMaW5lKGNtLmRvYywgcG9zLmxpbmUpXFxuICB2YXIgdG9wID0gaGVpZ2h0QXRMaW5lKGxpbmVPYmopICsgcGFkZGluZ1RvcChjbS5kaXNwbGF5KVxcbiAgcmV0dXJuIHtsZWZ0OiBsZWZ0LCByaWdodDogbGVmdCwgdG9wOiB0b3AsIGJvdHRvbTogdG9wICsgbGluZU9iai5oZWlnaHR9XFxufVxcblxcbi8vIFBvc2l0aW9ucyByZXR1cm5lZCBieSBjb29yZHNDaGFyIGNvbnRhaW4gc29tZSBleHRyYSBpbmZvcm1hdGlvbi5cXG4vLyB4UmVsIGlzIHRoZSByZWxhdGl2ZSB4IHBvc2l0aW9uIG9mIHRoZSBpbnB1dCBjb29yZGluYXRlcyBjb21wYXJlZFxcbi8vIHRvIHRoZSBmb3VuZCBwb3NpdGlvbiAoc28geFJlbCA+IDAgbWVhbnMgdGhlIGNvb3JkaW5hdGVzIGFyZSB0b1xcbi8vIHRoZSByaWdodCBvZiB0aGUgY2hhcmFjdGVyIHBvc2l0aW9uLCBmb3IgZXhhbXBsZSkuIFdoZW4gb3V0c2lkZVxcbi8vIGlzIHRydWUsIHRoYXQgbWVhbnMgdGhlIGNvb3JkaW5hdGVzIGxpZSBvdXRzaWRlIHRoZSBsaW5lJ3NcXG4vLyB2ZXJ0aWNhbCByYW5nZS5cXG5mdW5jdGlvbiBQb3NXaXRoSW5mbyhsaW5lLCBjaCwgc3RpY2t5LCBvdXRzaWRlLCB4UmVsKSB7XFxuICB2YXIgcG9zID0gUG9zKGxpbmUsIGNoLCBzdGlja3kpXFxuICBwb3MueFJlbCA9IHhSZWxcXG4gIGlmIChvdXRzaWRlKSB7IHBvcy5vdXRzaWRlID0gdHJ1ZSB9XFxuICByZXR1cm4gcG9zXFxufVxcblxcbi8vIENvbXB1dGUgdGhlIGNoYXJhY3RlciBwb3NpdGlvbiBjbG9zZXN0IHRvIHRoZSBnaXZlbiBjb29yZGluYXRlcy5cXG4vLyBJbnB1dCBtdXN0IGJlIGxpbmVTcGFjZS1sb2NhbCAoXFxcImRpdlxcXCIgY29vcmRpbmF0ZSBzeXN0ZW0pLlxcbmZ1bmN0aW9uIGNvb3Jkc0NoYXIoY20sIHgsIHkpIHtcXG4gIHZhciBkb2MgPSBjbS5kb2NcXG4gIHkgKz0gY20uZGlzcGxheS52aWV3T2Zmc2V0XFxuICBpZiAoeSA8IDApIHsgcmV0dXJuIFBvc1dpdGhJbmZvKGRvYy5maXJzdCwgMCwgbnVsbCwgdHJ1ZSwgLTEpIH1cXG4gIHZhciBsaW5lTiA9IGxpbmVBdEhlaWdodChkb2MsIHkpLCBsYXN0ID0gZG9jLmZpcnN0ICsgZG9jLnNpemUgLSAxXFxuICBpZiAobGluZU4gPiBsYXN0KVxcbiAgICB7IHJldHVybiBQb3NXaXRoSW5mbyhkb2MuZmlyc3QgKyBkb2Muc2l6ZSAtIDEsIGdldExpbmUoZG9jLCBsYXN0KS50ZXh0Lmxlbmd0aCwgbnVsbCwgdHJ1ZSwgMSkgfVxcbiAgaWYgKHggPCAwKSB7IHggPSAwIH1cXG5cXG4gIHZhciBsaW5lT2JqID0gZ2V0TGluZShkb2MsIGxpbmVOKVxcbiAgZm9yICg7Oykge1xcbiAgICB2YXIgZm91bmQgPSBjb29yZHNDaGFySW5uZXIoY20sIGxpbmVPYmosIGxpbmVOLCB4LCB5KVxcbiAgICB2YXIgbWVyZ2VkID0gY29sbGFwc2VkU3BhbkF0RW5kKGxpbmVPYmopXFxuICAgIHZhciBtZXJnZWRQb3MgPSBtZXJnZWQgJiYgbWVyZ2VkLmZpbmQoMCwgdHJ1ZSlcXG4gICAgaWYgKG1lcmdlZCAmJiAoZm91bmQuY2ggPiBtZXJnZWRQb3MuZnJvbS5jaCB8fCBmb3VuZC5jaCA9PSBtZXJnZWRQb3MuZnJvbS5jaCAmJiBmb3VuZC54UmVsID4gMCkpXFxuICAgICAgeyBsaW5lTiA9IGxpbmVObyhsaW5lT2JqID0gbWVyZ2VkUG9zLnRvLmxpbmUpIH1cXG4gICAgZWxzZVxcbiAgICAgIHsgcmV0dXJuIGZvdW5kIH1cXG4gIH1cXG59XFxuXFxuZnVuY3Rpb24gd3JhcHBlZExpbmVFeHRlbnQoY20sIGxpbmVPYmosIHByZXBhcmVkTWVhc3VyZSwgeSkge1xcbiAgdmFyIG1lYXN1cmUgPSBmdW5jdGlvbiAoY2gpIHsgcmV0dXJuIGludG9Db29yZFN5c3RlbShjbSwgbGluZU9iaiwgbWVhc3VyZUNoYXJQcmVwYXJlZChjbSwgcHJlcGFyZWRNZWFzdXJlLCBjaCksIFxcXCJsaW5lXFxcIik7IH1cXG4gIHZhciBlbmQgPSBsaW5lT2JqLnRleHQubGVuZ3RoXFxuICB2YXIgYmVnaW4gPSBmaW5kRmlyc3QoZnVuY3Rpb24gKGNoKSB7IHJldHVybiBtZWFzdXJlKGNoIC0gMSkuYm90dG9tIDw9IHk7IH0sIGVuZCwgMClcXG4gIGVuZCA9IGZpbmRGaXJzdChmdW5jdGlvbiAoY2gpIHsgcmV0dXJuIG1lYXN1cmUoY2gpLnRvcCA+IHk7IH0sIGJlZ2luLCBlbmQpXFxuICByZXR1cm4ge2JlZ2luOiBiZWdpbiwgZW5kOiBlbmR9XFxufVxcblxcbmZ1bmN0aW9uIHdyYXBwZWRMaW5lRXh0ZW50Q2hhcihjbSwgbGluZU9iaiwgcHJlcGFyZWRNZWFzdXJlLCB0YXJnZXQpIHtcXG4gIHZhciB0YXJnZXRUb3AgPSBpbnRvQ29vcmRTeXN0ZW0oY20sIGxpbmVPYmosIG1lYXN1cmVDaGFyUHJlcGFyZWQoY20sIHByZXBhcmVkTWVhc3VyZSwgdGFyZ2V0KSwgXFxcImxpbmVcXFwiKS50b3BcXG4gIHJldHVybiB3cmFwcGVkTGluZUV4dGVudChjbSwgbGluZU9iaiwgcHJlcGFyZWRNZWFzdXJlLCB0YXJnZXRUb3ApXFxufVxcblxcbmZ1bmN0aW9uIGNvb3Jkc0NoYXJJbm5lcihjbSwgbGluZU9iaiwgbGluZU5vLCB4LCB5KSB7XFxuICB5IC09IGhlaWdodEF0TGluZShsaW5lT2JqKVxcbiAgdmFyIGJlZ2luID0gMCwgZW5kID0gbGluZU9iai50ZXh0Lmxlbmd0aFxcbiAgdmFyIHByZXBhcmVkTWVhc3VyZSA9IHByZXBhcmVNZWFzdXJlRm9yTGluZShjbSwgbGluZU9iailcXG4gIHZhciBwb3NcXG4gIHZhciBvcmRlciA9IGdldE9yZGVyKGxpbmVPYmopXFxuICBpZiAob3JkZXIpIHtcXG4gICAgaWYgKGNtLm9wdGlvbnMubGluZVdyYXBwaW5nKSB7XFxuICAgICAgO3ZhciBhc3NpZ247XFxuICAgICAgKChhc3NpZ24gPSB3cmFwcGVkTGluZUV4dGVudChjbSwgbGluZU9iaiwgcHJlcGFyZWRNZWFzdXJlLCB5KSwgYmVnaW4gPSBhc3NpZ24uYmVnaW4sIGVuZCA9IGFzc2lnbi5lbmQsIGFzc2lnbikpXFxuICAgIH1cXG4gICAgcG9zID0gbmV3IFBvcyhsaW5lTm8sIGJlZ2luKVxcbiAgICB2YXIgYmVnaW5MZWZ0ID0gY3Vyc29yQ29vcmRzKGNtLCBwb3MsIFxcXCJsaW5lXFxcIiwgbGluZU9iaiwgcHJlcGFyZWRNZWFzdXJlKS5sZWZ0XFxuICAgIHZhciBkaXIgPSBiZWdpbkxlZnQgPCB4ID8gMSA6IC0xXFxuICAgIHZhciBwcmV2RGlmZiwgZGlmZiA9IGJlZ2luTGVmdCAtIHgsIHByZXZQb3NcXG4gICAgZG8ge1xcbiAgICAgIHByZXZEaWZmID0gZGlmZlxcbiAgICAgIHByZXZQb3MgPSBwb3NcXG4gICAgICBwb3MgPSBtb3ZlVmlzdWFsbHkoY20sIGxpbmVPYmosIHBvcywgZGlyKVxcbiAgICAgIGlmIChwb3MgPT0gbnVsbCB8fCBwb3MuY2ggPCBiZWdpbiB8fCBlbmQgPD0gKHBvcy5zdGlja3kgPT0gXFxcImJlZm9yZVxcXCIgPyBwb3MuY2ggLSAxIDogcG9zLmNoKSkge1xcbiAgICAgICAgcG9zID0gcHJldlBvc1xcbiAgICAgICAgYnJlYWtcXG4gICAgICB9XFxuICAgICAgZGlmZiA9IGN1cnNvckNvb3JkcyhjbSwgcG9zLCBcXFwibGluZVxcXCIsIGxpbmVPYmosIHByZXBhcmVkTWVhc3VyZSkubGVmdCAtIHhcXG4gICAgfSB3aGlsZSAoKGRpciA8IDApICE9IChkaWZmIDwgMCkgJiYgKE1hdGguYWJzKGRpZmYpIDw9IE1hdGguYWJzKHByZXZEaWZmKSkpXFxuICAgIGlmIChNYXRoLmFicyhkaWZmKSA+IE1hdGguYWJzKHByZXZEaWZmKSkge1xcbiAgICAgIGlmICgoZGlmZiA8IDApID09IChwcmV2RGlmZiA8IDApKSB7IHRocm93IG5ldyBFcnJvcihcXFwiQnJva2Ugb3V0IG9mIGluZmluaXRlIGxvb3AgaW4gY29vcmRzQ2hhcklubmVyXFxcIikgfVxcbiAgICAgIHBvcyA9IHByZXZQb3NcXG4gICAgfVxcbiAgfSBlbHNlIHtcXG4gICAgdmFyIGNoID0gZmluZEZpcnN0KGZ1bmN0aW9uIChjaCkge1xcbiAgICAgIHZhciBib3ggPSBpbnRvQ29vcmRTeXN0ZW0oY20sIGxpbmVPYmosIG1lYXN1cmVDaGFyUHJlcGFyZWQoY20sIHByZXBhcmVkTWVhc3VyZSwgY2gpLCBcXFwibGluZVxcXCIpXFxuICAgICAgaWYgKGJveC50b3AgPiB5KSB7XFxuICAgICAgICAvLyBGb3IgdGhlIGN1cnNvciBzdGlja2luZXNzXFxuICAgICAgICBlbmQgPSBNYXRoLm1pbihjaCwgZW5kKVxcbiAgICAgICAgcmV0dXJuIHRydWVcXG4gICAgICB9XFxuICAgICAgZWxzZSBpZiAoYm94LmJvdHRvbSA8PSB5KSB7IHJldHVybiBmYWxzZSB9XFxuICAgICAgZWxzZSBpZiAoYm94LmxlZnQgPiB4KSB7IHJldHVybiB0cnVlIH1cXG4gICAgICBlbHNlIGlmIChib3gucmlnaHQgPCB4KSB7IHJldHVybiBmYWxzZSB9XFxuICAgICAgZWxzZSB7IHJldHVybiAoeCAtIGJveC5sZWZ0IDwgYm94LnJpZ2h0IC0geCkgfVxcbiAgICB9LCBiZWdpbiwgZW5kKVxcbiAgICBjaCA9IHNraXBFeHRlbmRpbmdDaGFycyhsaW5lT2JqLnRleHQsIGNoLCAxKVxcbiAgICBwb3MgPSBuZXcgUG9zKGxpbmVObywgY2gsIGNoID09IGVuZCA/IFxcXCJiZWZvcmVcXFwiIDogXFxcImFmdGVyXFxcIilcXG4gIH1cXG4gIHZhciBjb29yZHMgPSBjdXJzb3JDb29yZHMoY20sIHBvcywgXFxcImxpbmVcXFwiLCBsaW5lT2JqLCBwcmVwYXJlZE1lYXN1cmUpXFxuICBpZiAoeSA8IGNvb3Jkcy50b3AgfHwgY29vcmRzLmJvdHRvbSA8IHkpIHsgcG9zLm91dHNpZGUgPSB0cnVlIH1cXG4gIHBvcy54UmVsID0geCA8IGNvb3Jkcy5sZWZ0ID8gLTEgOiAoeCA+IGNvb3Jkcy5yaWdodCA/IDEgOiAwKVxcbiAgcmV0dXJuIHBvc1xcbn1cXG5cXG52YXIgbWVhc3VyZVRleHRcXG4vLyBDb21wdXRlIHRoZSBkZWZhdWx0IHRleHQgaGVpZ2h0LlxcbmZ1bmN0aW9uIHRleHRIZWlnaHQoZGlzcGxheSkge1xcbiAgaWYgKGRpc3BsYXkuY2FjaGVkVGV4dEhlaWdodCAhPSBudWxsKSB7IHJldHVybiBkaXNwbGF5LmNhY2hlZFRleHRIZWlnaHQgfVxcbiAgaWYgKG1lYXN1cmVUZXh0ID09IG51bGwpIHtcXG4gICAgbWVhc3VyZVRleHQgPSBlbHQoXFxcInByZVxcXCIpXFxuICAgIC8vIE1lYXN1cmUgYSBidW5jaCBvZiBsaW5lcywgZm9yIGJyb3dzZXJzIHRoYXQgY29tcHV0ZVxcbiAgICAvLyBmcmFjdGlvbmFsIGhlaWdodHMuXFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNDk7ICsraSkge1xcbiAgICAgIG1lYXN1cmVUZXh0LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFxcXCJ4XFxcIikpXFxuICAgICAgbWVhc3VyZVRleHQuYXBwZW5kQ2hpbGQoZWx0KFxcXCJiclxcXCIpKVxcbiAgICB9XFxuICAgIG1lYXN1cmVUZXh0LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFxcXCJ4XFxcIikpXFxuICB9XFxuICByZW1vdmVDaGlsZHJlbkFuZEFkZChkaXNwbGF5Lm1lYXN1cmUsIG1lYXN1cmVUZXh0KVxcbiAgdmFyIGhlaWdodCA9IG1lYXN1cmVUZXh0Lm9mZnNldEhlaWdodCAvIDUwXFxuICBpZiAoaGVpZ2h0ID4gMykgeyBkaXNwbGF5LmNhY2hlZFRleHRIZWlnaHQgPSBoZWlnaHQgfVxcbiAgcmVtb3ZlQ2hpbGRyZW4oZGlzcGxheS5tZWFzdXJlKVxcbiAgcmV0dXJuIGhlaWdodCB8fCAxXFxufVxcblxcbi8vIENvbXB1dGUgdGhlIGRlZmF1bHQgY2hhcmFjdGVyIHdpZHRoLlxcbmZ1bmN0aW9uIGNoYXJXaWR0aChkaXNwbGF5KSB7XFxuICBpZiAoZGlzcGxheS5jYWNoZWRDaGFyV2lkdGggIT0gbnVsbCkgeyByZXR1cm4gZGlzcGxheS5jYWNoZWRDaGFyV2lkdGggfVxcbiAgdmFyIGFuY2hvciA9IGVsdChcXFwic3BhblxcXCIsIFxcXCJ4eHh4eHh4eHh4XFxcIilcXG4gIHZhciBwcmUgPSBlbHQoXFxcInByZVxcXCIsIFthbmNob3JdKVxcbiAgcmVtb3ZlQ2hpbGRyZW5BbmRBZGQoZGlzcGxheS5tZWFzdXJlLCBwcmUpXFxuICB2YXIgcmVjdCA9IGFuY2hvci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgd2lkdGggPSAocmVjdC5yaWdodCAtIHJlY3QubGVmdCkgLyAxMFxcbiAgaWYgKHdpZHRoID4gMikgeyBkaXNwbGF5LmNhY2hlZENoYXJXaWR0aCA9IHdpZHRoIH1cXG4gIHJldHVybiB3aWR0aCB8fCAxMFxcbn1cXG5cXG4vLyBEbyBhIGJ1bGstcmVhZCBvZiB0aGUgRE9NIHBvc2l0aW9ucyBhbmQgc2l6ZXMgbmVlZGVkIHRvIGRyYXcgdGhlXFxuLy8gdmlldywgc28gdGhhdCB3ZSBkb24ndCBpbnRlcmxlYXZlIHJlYWRpbmcgYW5kIHdyaXRpbmcgdG8gdGhlIERPTS5cXG5mdW5jdGlvbiBnZXREaW1lbnNpb25zKGNtKSB7XFxuICB2YXIgZCA9IGNtLmRpc3BsYXksIGxlZnQgPSB7fSwgd2lkdGggPSB7fVxcbiAgdmFyIGd1dHRlckxlZnQgPSBkLmd1dHRlcnMuY2xpZW50TGVmdFxcbiAgZm9yICh2YXIgbiA9IGQuZ3V0dGVycy5maXJzdENoaWxkLCBpID0gMDsgbjsgbiA9IG4ubmV4dFNpYmxpbmcsICsraSkge1xcbiAgICBsZWZ0W2NtLm9wdGlvbnMuZ3V0dGVyc1tpXV0gPSBuLm9mZnNldExlZnQgKyBuLmNsaWVudExlZnQgKyBndXR0ZXJMZWZ0XFxuICAgIHdpZHRoW2NtLm9wdGlvbnMuZ3V0dGVyc1tpXV0gPSBuLmNsaWVudFdpZHRoXFxuICB9XFxuICByZXR1cm4ge2ZpeGVkUG9zOiBjb21wZW5zYXRlRm9ySFNjcm9sbChkKSxcXG4gICAgICAgICAgZ3V0dGVyVG90YWxXaWR0aDogZC5ndXR0ZXJzLm9mZnNldFdpZHRoLFxcbiAgICAgICAgICBndXR0ZXJMZWZ0OiBsZWZ0LFxcbiAgICAgICAgICBndXR0ZXJXaWR0aDogd2lkdGgsXFxuICAgICAgICAgIHdyYXBwZXJXaWR0aDogZC53cmFwcGVyLmNsaWVudFdpZHRofVxcbn1cXG5cXG4vLyBDb21wdXRlcyBkaXNwbGF5LnNjcm9sbGVyLnNjcm9sbExlZnQgKyBkaXNwbGF5Lmd1dHRlcnMub2Zmc2V0V2lkdGgsXFxuLy8gYnV0IHVzaW5nIGdldEJvdW5kaW5nQ2xpZW50UmVjdCB0byBnZXQgYSBzdWItcGl4ZWwtYWNjdXJhdGVcXG4vLyByZXN1bHQuXFxuZnVuY3Rpb24gY29tcGVuc2F0ZUZvckhTY3JvbGwoZGlzcGxheSkge1xcbiAgcmV0dXJuIGRpc3BsYXkuc2Nyb2xsZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdCAtIGRpc3BsYXkuc2l6ZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdFxcbn1cXG5cXG4vLyBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCBlc3RpbWF0ZXMgdGhlIGhlaWdodCBvZiBhIGxpbmUsIHRvIHVzZSBhc1xcbi8vIGZpcnN0IGFwcHJveGltYXRpb24gdW50aWwgdGhlIGxpbmUgYmVjb21lcyB2aXNpYmxlIChhbmQgaXMgdGh1c1xcbi8vIHByb3Blcmx5IG1lYXN1cmFibGUpLlxcbmZ1bmN0aW9uIGVzdGltYXRlSGVpZ2h0KGNtKSB7XFxuICB2YXIgdGggPSB0ZXh0SGVpZ2h0KGNtLmRpc3BsYXkpLCB3cmFwcGluZyA9IGNtLm9wdGlvbnMubGluZVdyYXBwaW5nXFxuICB2YXIgcGVyTGluZSA9IHdyYXBwaW5nICYmIE1hdGgubWF4KDUsIGNtLmRpc3BsYXkuc2Nyb2xsZXIuY2xpZW50V2lkdGggLyBjaGFyV2lkdGgoY20uZGlzcGxheSkgLSAzKVxcbiAgcmV0dXJuIGZ1bmN0aW9uIChsaW5lKSB7XFxuICAgIGlmIChsaW5lSXNIaWRkZW4oY20uZG9jLCBsaW5lKSkgeyByZXR1cm4gMCB9XFxuXFxuICAgIHZhciB3aWRnZXRzSGVpZ2h0ID0gMFxcbiAgICBpZiAobGluZS53aWRnZXRzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgbGluZS53aWRnZXRzLmxlbmd0aDsgaSsrKSB7XFxuICAgICAgaWYgKGxpbmUud2lkZ2V0c1tpXS5oZWlnaHQpIHsgd2lkZ2V0c0hlaWdodCArPSBsaW5lLndpZGdldHNbaV0uaGVpZ2h0IH1cXG4gICAgfSB9XFxuXFxuICAgIGlmICh3cmFwcGluZylcXG4gICAgICB7IHJldHVybiB3aWRnZXRzSGVpZ2h0ICsgKE1hdGguY2VpbChsaW5lLnRleHQubGVuZ3RoIC8gcGVyTGluZSkgfHwgMSkgKiB0aCB9XFxuICAgIGVsc2VcXG4gICAgICB7IHJldHVybiB3aWRnZXRzSGVpZ2h0ICsgdGggfVxcbiAgfVxcbn1cXG5cXG5mdW5jdGlvbiBlc3RpbWF0ZUxpbmVIZWlnaHRzKGNtKSB7XFxuICB2YXIgZG9jID0gY20uZG9jLCBlc3QgPSBlc3RpbWF0ZUhlaWdodChjbSlcXG4gIGRvYy5pdGVyKGZ1bmN0aW9uIChsaW5lKSB7XFxuICAgIHZhciBlc3RIZWlnaHQgPSBlc3QobGluZSlcXG4gICAgaWYgKGVzdEhlaWdodCAhPSBsaW5lLmhlaWdodCkgeyB1cGRhdGVMaW5lSGVpZ2h0KGxpbmUsIGVzdEhlaWdodCkgfVxcbiAgfSlcXG59XFxuXFxuLy8gR2l2ZW4gYSBtb3VzZSBldmVudCwgZmluZCB0aGUgY29ycmVzcG9uZGluZyBwb3NpdGlvbi4gSWYgbGliZXJhbFxcbi8vIGlzIGZhbHNlLCBpdCBjaGVja3Mgd2hldGhlciBhIGd1dHRlciBvciBzY3JvbGxiYXIgd2FzIGNsaWNrZWQsXFxuLy8gYW5kIHJldHVybnMgbnVsbCBpZiBpdCB3YXMuIGZvclJlY3QgaXMgdXNlZCBieSByZWN0YW5ndWxhclxcbi8vIHNlbGVjdGlvbnMsIGFuZCB0cmllcyB0byBlc3RpbWF0ZSBhIGNoYXJhY3RlciBwb3NpdGlvbiBldmVuIGZvclxcbi8vIGNvb3JkaW5hdGVzIGJleW9uZCB0aGUgcmlnaHQgb2YgdGhlIHRleHQuXFxuZnVuY3Rpb24gcG9zRnJvbU1vdXNlKGNtLCBlLCBsaWJlcmFsLCBmb3JSZWN0KSB7XFxuICB2YXIgZGlzcGxheSA9IGNtLmRpc3BsYXlcXG4gIGlmICghbGliZXJhbCAmJiBlX3RhcmdldChlKS5nZXRBdHRyaWJ1dGUoXFxcImNtLW5vdC1jb250ZW50XFxcIikgPT0gXFxcInRydWVcXFwiKSB7IHJldHVybiBudWxsIH1cXG5cXG4gIHZhciB4LCB5LCBzcGFjZSA9IGRpc3BsYXkubGluZVNwYWNlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXFxuICAvLyBGYWlscyB1bnByZWRpY3RhYmx5IG9uIElFWzY3XSB3aGVuIG1vdXNlIGlzIGRyYWdnZWQgYXJvdW5kIHF1aWNrbHkuXFxuICB0cnkgeyB4ID0gZS5jbGllbnRYIC0gc3BhY2UubGVmdDsgeSA9IGUuY2xpZW50WSAtIHNwYWNlLnRvcCB9XFxuICBjYXRjaCAoZSkgeyByZXR1cm4gbnVsbCB9XFxuICB2YXIgY29vcmRzID0gY29vcmRzQ2hhcihjbSwgeCwgeSksIGxpbmVcXG4gIGlmIChmb3JSZWN0ICYmIGNvb3Jkcy54UmVsID09IDEgJiYgKGxpbmUgPSBnZXRMaW5lKGNtLmRvYywgY29vcmRzLmxpbmUpLnRleHQpLmxlbmd0aCA9PSBjb29yZHMuY2gpIHtcXG4gICAgdmFyIGNvbERpZmYgPSBjb3VudENvbHVtbihsaW5lLCBsaW5lLmxlbmd0aCwgY20ub3B0aW9ucy50YWJTaXplKSAtIGxpbmUubGVuZ3RoXFxuICAgIGNvb3JkcyA9IFBvcyhjb29yZHMubGluZSwgTWF0aC5tYXgoMCwgTWF0aC5yb3VuZCgoeCAtIHBhZGRpbmdIKGNtLmRpc3BsYXkpLmxlZnQpIC8gY2hhcldpZHRoKGNtLmRpc3BsYXkpKSAtIGNvbERpZmYpKVxcbiAgfVxcbiAgcmV0dXJuIGNvb3Jkc1xcbn1cXG5cXG4vLyBGaW5kIHRoZSB2aWV3IGVsZW1lbnQgY29ycmVzcG9uZGluZyB0byBhIGdpdmVuIGxpbmUuIFJldHVybiBudWxsXFxuLy8gd2hlbiB0aGUgbGluZSBpc24ndCB2aXNpYmxlLlxcbmZ1bmN0aW9uIGZpbmRWaWV3SW5kZXgoY20sIG4pIHtcXG4gIGlmIChuID49IGNtLmRpc3BsYXkudmlld1RvKSB7IHJldHVybiBudWxsIH1cXG4gIG4gLT0gY20uZGlzcGxheS52aWV3RnJvbVxcbiAgaWYgKG4gPCAwKSB7IHJldHVybiBudWxsIH1cXG4gIHZhciB2aWV3ID0gY20uZGlzcGxheS52aWV3XFxuICBmb3IgKHZhciBpID0gMDsgaSA8IHZpZXcubGVuZ3RoOyBpKyspIHtcXG4gICAgbiAtPSB2aWV3W2ldLnNpemVcXG4gICAgaWYgKG4gPCAwKSB7IHJldHVybiBpIH1cXG4gIH1cXG59XFxuXFxuZnVuY3Rpb24gdXBkYXRlU2VsZWN0aW9uKGNtKSB7XFxuICBjbS5kaXNwbGF5LmlucHV0LnNob3dTZWxlY3Rpb24oY20uZGlzcGxheS5pbnB1dC5wcmVwYXJlU2VsZWN0aW9uKCkpXFxufVxcblxcbmZ1bmN0aW9uIHByZXBhcmVTZWxlY3Rpb24oY20sIHByaW1hcnkpIHtcXG4gIHZhciBkb2MgPSBjbS5kb2MsIHJlc3VsdCA9IHt9XFxuICB2YXIgY3VyRnJhZ21lbnQgPSByZXN1bHQuY3Vyc29ycyA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKVxcbiAgdmFyIHNlbEZyYWdtZW50ID0gcmVzdWx0LnNlbGVjdGlvbiA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKVxcblxcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBkb2Muc2VsLnJhbmdlcy5sZW5ndGg7IGkrKykge1xcbiAgICBpZiAocHJpbWFyeSA9PT0gZmFsc2UgJiYgaSA9PSBkb2Muc2VsLnByaW1JbmRleCkgeyBjb250aW51ZSB9XFxuICAgIHZhciByYW5nZSA9IGRvYy5zZWwucmFuZ2VzW2ldXFxuICAgIGlmIChyYW5nZS5mcm9tKCkubGluZSA+PSBjbS5kaXNwbGF5LnZpZXdUbyB8fCByYW5nZS50bygpLmxpbmUgPCBjbS5kaXNwbGF5LnZpZXdGcm9tKSB7IGNvbnRpbnVlIH1cXG4gICAgdmFyIGNvbGxhcHNlZCA9IHJhbmdlLmVtcHR5KClcXG4gICAgaWYgKGNvbGxhcHNlZCB8fCBjbS5vcHRpb25zLnNob3dDdXJzb3JXaGVuU2VsZWN0aW5nKVxcbiAgICAgIHsgZHJhd1NlbGVjdGlvbkN1cnNvcihjbSwgcmFuZ2UuaGVhZCwgY3VyRnJhZ21lbnQpIH1cXG4gICAgaWYgKCFjb2xsYXBzZWQpXFxuICAgICAgeyBkcmF3U2VsZWN0aW9uUmFuZ2UoY20sIHJhbmdlLCBzZWxGcmFnbWVudCkgfVxcbiAgfVxcbiAgcmV0dXJuIHJlc3VsdFxcbn1cXG5cXG4vLyBEcmF3cyBhIGN1cnNvciBmb3IgdGhlIGdpdmVuIHJhbmdlXFxuZnVuY3Rpb24gZHJhd1NlbGVjdGlvbkN1cnNvcihjbSwgaGVhZCwgb3V0cHV0KSB7XFxuICB2YXIgcG9zID0gY3Vyc29yQ29vcmRzKGNtLCBoZWFkLCBcXFwiZGl2XFxcIiwgbnVsbCwgbnVsbCwgIWNtLm9wdGlvbnMuc2luZ2xlQ3Vyc29ySGVpZ2h0UGVyTGluZSlcXG5cXG4gIHZhciBjdXJzb3IgPSBvdXRwdXQuYXBwZW5kQ2hpbGQoZWx0KFxcXCJkaXZcXFwiLCBcXFwiXFxcXHUwMGEwXFxcIiwgXFxcIkNvZGVNaXJyb3ItY3Vyc29yXFxcIikpXFxuICBjdXJzb3Iuc3R5bGUubGVmdCA9IHBvcy5sZWZ0ICsgXFxcInB4XFxcIlxcbiAgY3Vyc29yLnN0eWxlLnRvcCA9IHBvcy50b3AgKyBcXFwicHhcXFwiXFxuICBjdXJzb3Iuc3R5bGUuaGVpZ2h0ID0gTWF0aC5tYXgoMCwgcG9zLmJvdHRvbSAtIHBvcy50b3ApICogY20ub3B0aW9ucy5jdXJzb3JIZWlnaHQgKyBcXFwicHhcXFwiXFxuXFxuICBpZiAocG9zLm90aGVyKSB7XFxuICAgIC8vIFNlY29uZGFyeSBjdXJzb3IsIHNob3duIHdoZW4gb24gYSAnanVtcCcgaW4gYmktZGlyZWN0aW9uYWwgdGV4dFxcbiAgICB2YXIgb3RoZXJDdXJzb3IgPSBvdXRwdXQuYXBwZW5kQ2hpbGQoZWx0KFxcXCJkaXZcXFwiLCBcXFwiXFxcXHUwMGEwXFxcIiwgXFxcIkNvZGVNaXJyb3ItY3Vyc29yIENvZGVNaXJyb3Itc2Vjb25kYXJ5Y3Vyc29yXFxcIikpXFxuICAgIG90aGVyQ3Vyc29yLnN0eWxlLmRpc3BsYXkgPSBcXFwiXFxcIlxcbiAgICBvdGhlckN1cnNvci5zdHlsZS5sZWZ0ID0gcG9zLm90aGVyLmxlZnQgKyBcXFwicHhcXFwiXFxuICAgIG90aGVyQ3Vyc29yLnN0eWxlLnRvcCA9IHBvcy5vdGhlci50b3AgKyBcXFwicHhcXFwiXFxuICAgIG90aGVyQ3Vyc29yLnN0eWxlLmhlaWdodCA9IChwb3Mub3RoZXIuYm90dG9tIC0gcG9zLm90aGVyLnRvcCkgKiAuODUgKyBcXFwicHhcXFwiXFxuICB9XFxufVxcblxcbi8vIERyYXdzIHRoZSBnaXZlbiByYW5nZSBhcyBhIGhpZ2hsaWdodGVkIHNlbGVjdGlvblxcbmZ1bmN0aW9uIGRyYXdTZWxlY3Rpb25SYW5nZShjbSwgcmFuZ2UsIG91dHB1dCkge1xcbiAgdmFyIGRpc3BsYXkgPSBjbS5kaXNwbGF5LCBkb2MgPSBjbS5kb2NcXG4gIHZhciBmcmFnbWVudCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKVxcbiAgdmFyIHBhZGRpbmcgPSBwYWRkaW5nSChjbS5kaXNwbGF5KSwgbGVmdFNpZGUgPSBwYWRkaW5nLmxlZnRcXG4gIHZhciByaWdodFNpZGUgPSBNYXRoLm1heChkaXNwbGF5LnNpemVyV2lkdGgsIGRpc3BsYXlXaWR0aChjbSkgLSBkaXNwbGF5LnNpemVyLm9mZnNldExlZnQpIC0gcGFkZGluZy5yaWdodFxcblxcbiAgZnVuY3Rpb24gYWRkKGxlZnQsIHRvcCwgd2lkdGgsIGJvdHRvbSkge1xcbiAgICBpZiAodG9wIDwgMCkgeyB0b3AgPSAwIH1cXG4gICAgdG9wID0gTWF0aC5yb3VuZCh0b3ApXFxuICAgIGJvdHRvbSA9IE1hdGgucm91bmQoYm90dG9tKVxcbiAgICBmcmFnbWVudC5hcHBlbmRDaGlsZChlbHQoXFxcImRpdlxcXCIsIG51bGwsIFxcXCJDb2RlTWlycm9yLXNlbGVjdGVkXFxcIiwgKFxcXCJwb3NpdGlvbjogYWJzb2x1dGU7IGxlZnQ6IFxcXCIgKyBsZWZ0ICsgXFxcInB4O1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b3A6IFxcXCIgKyB0b3AgKyBcXFwicHg7IHdpZHRoOiBcXFwiICsgKHdpZHRoID09IG51bGwgPyByaWdodFNpZGUgLSBsZWZ0IDogd2lkdGgpICsgXFxcInB4O1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IFxcXCIgKyAoYm90dG9tIC0gdG9wKSArIFxcXCJweFxcXCIpKSlcXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIGRyYXdGb3JMaW5lKGxpbmUsIGZyb21BcmcsIHRvQXJnKSB7XFxuICAgIHZhciBsaW5lT2JqID0gZ2V0TGluZShkb2MsIGxpbmUpXFxuICAgIHZhciBsaW5lTGVuID0gbGluZU9iai50ZXh0Lmxlbmd0aFxcbiAgICB2YXIgc3RhcnQsIGVuZFxcbiAgICBmdW5jdGlvbiBjb29yZHMoY2gsIGJpYXMpIHtcXG4gICAgICByZXR1cm4gY2hhckNvb3JkcyhjbSwgUG9zKGxpbmUsIGNoKSwgXFxcImRpdlxcXCIsIGxpbmVPYmosIGJpYXMpXFxuICAgIH1cXG5cXG4gICAgaXRlcmF0ZUJpZGlTZWN0aW9ucyhnZXRPcmRlcihsaW5lT2JqKSwgZnJvbUFyZyB8fCAwLCB0b0FyZyA9PSBudWxsID8gbGluZUxlbiA6IHRvQXJnLCBmdW5jdGlvbiAoZnJvbSwgdG8sIGRpcikge1xcbiAgICAgIHZhciBsZWZ0UG9zID0gY29vcmRzKGZyb20sIFxcXCJsZWZ0XFxcIiksIHJpZ2h0UG9zLCBsZWZ0LCByaWdodFxcbiAgICAgIGlmIChmcm9tID09IHRvKSB7XFxuICAgICAgICByaWdodFBvcyA9IGxlZnRQb3NcXG4gICAgICAgIGxlZnQgPSByaWdodCA9IGxlZnRQb3MubGVmdFxcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICByaWdodFBvcyA9IGNvb3Jkcyh0byAtIDEsIFxcXCJyaWdodFxcXCIpXFxuICAgICAgICBpZiAoZGlyID09IFxcXCJydGxcXFwiKSB7IHZhciB0bXAgPSBsZWZ0UG9zOyBsZWZ0UG9zID0gcmlnaHRQb3M7IHJpZ2h0UG9zID0gdG1wIH1cXG4gICAgICAgIGxlZnQgPSBsZWZ0UG9zLmxlZnRcXG4gICAgICAgIHJpZ2h0ID0gcmlnaHRQb3MucmlnaHRcXG4gICAgICB9XFxuICAgICAgaWYgKGZyb21BcmcgPT0gbnVsbCAmJiBmcm9tID09IDApIHsgbGVmdCA9IGxlZnRTaWRlIH1cXG4gICAgICBpZiAocmlnaHRQb3MudG9wIC0gbGVmdFBvcy50b3AgPiAzKSB7IC8vIERpZmZlcmVudCBsaW5lcywgZHJhdyB0b3AgcGFydFxcbiAgICAgICAgYWRkKGxlZnQsIGxlZnRQb3MudG9wLCBudWxsLCBsZWZ0UG9zLmJvdHRvbSlcXG4gICAgICAgIGxlZnQgPSBsZWZ0U2lkZVxcbiAgICAgICAgaWYgKGxlZnRQb3MuYm90dG9tIDwgcmlnaHRQb3MudG9wKSB7IGFkZChsZWZ0LCBsZWZ0UG9zLmJvdHRvbSwgbnVsbCwgcmlnaHRQb3MudG9wKSB9XFxuICAgICAgfVxcbiAgICAgIGlmICh0b0FyZyA9PSBudWxsICYmIHRvID09IGxpbmVMZW4pIHsgcmlnaHQgPSByaWdodFNpZGUgfVxcbiAgICAgIGlmICghc3RhcnQgfHwgbGVmdFBvcy50b3AgPCBzdGFydC50b3AgfHwgbGVmdFBvcy50b3AgPT0gc3RhcnQudG9wICYmIGxlZnRQb3MubGVmdCA8IHN0YXJ0LmxlZnQpXFxuICAgICAgICB7IHN0YXJ0ID0gbGVmdFBvcyB9XFxuICAgICAgaWYgKCFlbmQgfHwgcmlnaHRQb3MuYm90dG9tID4gZW5kLmJvdHRvbSB8fCByaWdodFBvcy5ib3R0b20gPT0gZW5kLmJvdHRvbSAmJiByaWdodFBvcy5yaWdodCA+IGVuZC5yaWdodClcXG4gICAgICAgIHsgZW5kID0gcmlnaHRQb3MgfVxcbiAgICAgIGlmIChsZWZ0IDwgbGVmdFNpZGUgKyAxKSB7IGxlZnQgPSBsZWZ0U2lkZSB9XFxuICAgICAgYWRkKGxlZnQsIHJpZ2h0UG9zLnRvcCwgcmlnaHQgLSBsZWZ0LCByaWdodFBvcy5ib3R0b20pXFxuICAgIH0pXFxuICAgIHJldHVybiB7c3RhcnQ6IHN0YXJ0LCBlbmQ6IGVuZH1cXG4gIH1cXG5cXG4gIHZhciBzRnJvbSA9IHJhbmdlLmZyb20oKSwgc1RvID0gcmFuZ2UudG8oKVxcbiAgaWYgKHNGcm9tLmxpbmUgPT0gc1RvLmxpbmUpIHtcXG4gICAgZHJhd0ZvckxpbmUoc0Zyb20ubGluZSwgc0Zyb20uY2gsIHNUby5jaClcXG4gIH0gZWxzZSB7XFxuICAgIHZhciBmcm9tTGluZSA9IGdldExpbmUoZG9jLCBzRnJvbS5saW5lKSwgdG9MaW5lID0gZ2V0TGluZShkb2MsIHNUby5saW5lKVxcbiAgICB2YXIgc2luZ2xlVkxpbmUgPSB2aXN1YWxMaW5lKGZyb21MaW5lKSA9PSB2aXN1YWxMaW5lKHRvTGluZSlcXG4gICAgdmFyIGxlZnRFbmQgPSBkcmF3Rm9yTGluZShzRnJvbS5saW5lLCBzRnJvbS5jaCwgc2luZ2xlVkxpbmUgPyBmcm9tTGluZS50ZXh0Lmxlbmd0aCArIDEgOiBudWxsKS5lbmRcXG4gICAgdmFyIHJpZ2h0U3RhcnQgPSBkcmF3Rm9yTGluZShzVG8ubGluZSwgc2luZ2xlVkxpbmUgPyAwIDogbnVsbCwgc1RvLmNoKS5zdGFydFxcbiAgICBpZiAoc2luZ2xlVkxpbmUpIHtcXG4gICAgICBpZiAobGVmdEVuZC50b3AgPCByaWdodFN0YXJ0LnRvcCAtIDIpIHtcXG4gICAgICAgIGFkZChsZWZ0RW5kLnJpZ2h0LCBsZWZ0RW5kLnRvcCwgbnVsbCwgbGVmdEVuZC5ib3R0b20pXFxuICAgICAgICBhZGQobGVmdFNpZGUsIHJpZ2h0U3RhcnQudG9wLCByaWdodFN0YXJ0LmxlZnQsIHJpZ2h0U3RhcnQuYm90dG9tKVxcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBhZGQobGVmdEVuZC5yaWdodCwgbGVmdEVuZC50b3AsIHJpZ2h0U3RhcnQubGVmdCAtIGxlZnRFbmQucmlnaHQsIGxlZnRFbmQuYm90dG9tKVxcbiAgICAgIH1cXG4gICAgfVxcbiAgICBpZiAobGVmdEVuZC5ib3R0b20gPCByaWdodFN0YXJ0LnRvcClcXG4gICAgICB7IGFkZChsZWZ0U2lkZSwgbGVmdEVuZC5ib3R0b20sIG51bGwsIHJpZ2h0U3RhcnQudG9wKSB9XFxuICB9XFxuXFxuICBvdXRwdXQuYXBwZW5kQ2hpbGQoZnJhZ21lbnQpXFxufVxcblxcbi8vIEN1cnNvci1ibGlua2luZ1xcbmZ1bmN0aW9uIHJlc3RhcnRCbGluayhjbSkge1xcbiAgaWYgKCFjbS5zdGF0ZS5mb2N1c2VkKSB7IHJldHVybiB9XFxuICB2YXIgZGlzcGxheSA9IGNtLmRpc3BsYXlcXG4gIGNsZWFySW50ZXJ2YWwoZGlzcGxheS5ibGlua2VyKVxcbiAgdmFyIG9uID0gdHJ1ZVxcbiAgZGlzcGxheS5jdXJzb3JEaXYuc3R5bGUudmlzaWJpbGl0eSA9IFxcXCJcXFwiXFxuICBpZiAoY20ub3B0aW9ucy5jdXJzb3JCbGlua1JhdGUgPiAwKVxcbiAgICB7IGRpc3BsYXkuYmxpbmtlciA9IHNldEludGVydmFsKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRpc3BsYXkuY3Vyc29yRGl2LnN0eWxlLnZpc2liaWxpdHkgPSAob24gPSAhb24pID8gXFxcIlxcXCIgOiBcXFwiaGlkZGVuXFxcIjsgfSxcXG4gICAgICBjbS5vcHRpb25zLmN1cnNvckJsaW5rUmF0ZSkgfVxcbiAgZWxzZSBpZiAoY20ub3B0aW9ucy5jdXJzb3JCbGlua1JhdGUgPCAwKVxcbiAgICB7IGRpc3BsYXkuY3Vyc29yRGl2LnN0eWxlLnZpc2liaWxpdHkgPSBcXFwiaGlkZGVuXFxcIiB9XFxufVxcblxcbmZ1bmN0aW9uIGVuc3VyZUZvY3VzKGNtKSB7XFxuICBpZiAoIWNtLnN0YXRlLmZvY3VzZWQpIHsgY20uZGlzcGxheS5pbnB1dC5mb2N1cygpOyBvbkZvY3VzKGNtKSB9XFxufVxcblxcbmZ1bmN0aW9uIGRlbGF5Qmx1ckV2ZW50KGNtKSB7XFxuICBjbS5zdGF0ZS5kZWxheWluZ0JsdXJFdmVudCA9IHRydWVcXG4gIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyBpZiAoY20uc3RhdGUuZGVsYXlpbmdCbHVyRXZlbnQpIHtcXG4gICAgY20uc3RhdGUuZGVsYXlpbmdCbHVyRXZlbnQgPSBmYWxzZVxcbiAgICBvbkJsdXIoY20pXFxuICB9IH0sIDEwMClcXG59XFxuXFxuZnVuY3Rpb24gb25Gb2N1cyhjbSwgZSkge1xcbiAgaWYgKGNtLnN0YXRlLmRlbGF5aW5nQmx1ckV2ZW50KSB7IGNtLnN0YXRlLmRlbGF5aW5nQmx1ckV2ZW50ID0gZmFsc2UgfVxcblxcbiAgaWYgKGNtLm9wdGlvbnMucmVhZE9ubHkgPT0gXFxcIm5vY3Vyc29yXFxcIikgeyByZXR1cm4gfVxcbiAgaWYgKCFjbS5zdGF0ZS5mb2N1c2VkKSB7XFxuICAgIHNpZ25hbChjbSwgXFxcImZvY3VzXFxcIiwgY20sIGUpXFxuICAgIGNtLnN0YXRlLmZvY3VzZWQgPSB0cnVlXFxuICAgIGFkZENsYXNzKGNtLmRpc3BsYXkud3JhcHBlciwgXFxcIkNvZGVNaXJyb3ItZm9jdXNlZFxcXCIpXFxuICAgIC8vIFRoaXMgdGVzdCBwcmV2ZW50cyB0aGlzIGZyb20gZmlyaW5nIHdoZW4gYSBjb250ZXh0XFxuICAgIC8vIG1lbnUgaXMgY2xvc2VkIChzaW5jZSB0aGUgaW5wdXQgcmVzZXQgd291bGQga2lsbCB0aGVcXG4gICAgLy8gc2VsZWN0LWFsbCBkZXRlY3Rpb24gaGFjaylcXG4gICAgaWYgKCFjbS5jdXJPcCAmJiBjbS5kaXNwbGF5LnNlbEZvckNvbnRleHRNZW51ICE9IGNtLmRvYy5zZWwpIHtcXG4gICAgICBjbS5kaXNwbGF5LmlucHV0LnJlc2V0KClcXG4gICAgICBpZiAod2Via2l0KSB7IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyByZXR1cm4gY20uZGlzcGxheS5pbnB1dC5yZXNldCh0cnVlKTsgfSwgMjApIH0gLy8gSXNzdWUgIzE3MzBcXG4gICAgfVxcbiAgICBjbS5kaXNwbGF5LmlucHV0LnJlY2VpdmVkRm9jdXMoKVxcbiAgfVxcbiAgcmVzdGFydEJsaW5rKGNtKVxcbn1cXG5mdW5jdGlvbiBvbkJsdXIoY20sIGUpIHtcXG4gIGlmIChjbS5zdGF0ZS5kZWxheWluZ0JsdXJFdmVudCkgeyByZXR1cm4gfVxcblxcbiAgaWYgKGNtLnN0YXRlLmZvY3VzZWQpIHtcXG4gICAgc2lnbmFsKGNtLCBcXFwiYmx1clxcXCIsIGNtLCBlKVxcbiAgICBjbS5zdGF0ZS5mb2N1c2VkID0gZmFsc2VcXG4gICAgcm1DbGFzcyhjbS5kaXNwbGF5LndyYXBwZXIsIFxcXCJDb2RlTWlycm9yLWZvY3VzZWRcXFwiKVxcbiAgfVxcbiAgY2xlYXJJbnRlcnZhbChjbS5kaXNwbGF5LmJsaW5rZXIpXFxuICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgaWYgKCFjbS5zdGF0ZS5mb2N1c2VkKSB7IGNtLmRpc3BsYXkuc2hpZnQgPSBmYWxzZSB9IH0sIDE1MClcXG59XFxuXFxuLy8gUmUtYWxpZ24gbGluZSBudW1iZXJzIGFuZCBndXR0ZXIgbWFya3MgdG8gY29tcGVuc2F0ZSBmb3JcXG4vLyBob3Jpem9udGFsIHNjcm9sbGluZy5cXG5mdW5jdGlvbiBhbGlnbkhvcml6b250YWxseShjbSkge1xcbiAgdmFyIGRpc3BsYXkgPSBjbS5kaXNwbGF5LCB2aWV3ID0gZGlzcGxheS52aWV3XFxuICBpZiAoIWRpc3BsYXkuYWxpZ25XaWRnZXRzICYmICghZGlzcGxheS5ndXR0ZXJzLmZpcnN0Q2hpbGQgfHwgIWNtLm9wdGlvbnMuZml4ZWRHdXR0ZXIpKSB7IHJldHVybiB9XFxuICB2YXIgY29tcCA9IGNvbXBlbnNhdGVGb3JIU2Nyb2xsKGRpc3BsYXkpIC0gZGlzcGxheS5zY3JvbGxlci5zY3JvbGxMZWZ0ICsgY20uZG9jLnNjcm9sbExlZnRcXG4gIHZhciBndXR0ZXJXID0gZGlzcGxheS5ndXR0ZXJzLm9mZnNldFdpZHRoLCBsZWZ0ID0gY29tcCArIFxcXCJweFxcXCJcXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdmlldy5sZW5ndGg7IGkrKykgeyBpZiAoIXZpZXdbaV0uaGlkZGVuKSB7XFxuICAgIGlmIChjbS5vcHRpb25zLmZpeGVkR3V0dGVyKSB7XFxuICAgICAgaWYgKHZpZXdbaV0uZ3V0dGVyKVxcbiAgICAgICAgeyB2aWV3W2ldLmd1dHRlci5zdHlsZS5sZWZ0ID0gbGVmdCB9XFxuICAgICAgaWYgKHZpZXdbaV0uZ3V0dGVyQmFja2dyb3VuZClcXG4gICAgICAgIHsgdmlld1tpXS5ndXR0ZXJCYWNrZ3JvdW5kLnN0eWxlLmxlZnQgPSBsZWZ0IH1cXG4gICAgfVxcbiAgICB2YXIgYWxpZ24gPSB2aWV3W2ldLmFsaWduYWJsZVxcbiAgICBpZiAoYWxpZ24pIHsgZm9yICh2YXIgaiA9IDA7IGogPCBhbGlnbi5sZW5ndGg7IGorKylcXG4gICAgICB7IGFsaWduW2pdLnN0eWxlLmxlZnQgPSBsZWZ0IH0gfVxcbiAgfSB9XFxuICBpZiAoY20ub3B0aW9ucy5maXhlZEd1dHRlcilcXG4gICAgeyBkaXNwbGF5Lmd1dHRlcnMuc3R5bGUubGVmdCA9IChjb21wICsgZ3V0dGVyVykgKyBcXFwicHhcXFwiIH1cXG59XFxuXFxuLy8gVXNlZCB0byBlbnN1cmUgdGhhdCB0aGUgbGluZSBudW1iZXIgZ3V0dGVyIGlzIHN0aWxsIHRoZSByaWdodFxcbi8vIHNpemUgZm9yIHRoZSBjdXJyZW50IGRvY3VtZW50IHNpemUuIFJldHVybnMgdHJ1ZSB3aGVuIGFuIHVwZGF0ZVxcbi8vIGlzIG5lZWRlZC5cXG5mdW5jdGlvbiBtYXliZVVwZGF0ZUxpbmVOdW1iZXJXaWR0aChjbSkge1xcbiAgaWYgKCFjbS5vcHRpb25zLmxpbmVOdW1iZXJzKSB7IHJldHVybiBmYWxzZSB9XFxuICB2YXIgZG9jID0gY20uZG9jLCBsYXN0ID0gbGluZU51bWJlckZvcihjbS5vcHRpb25zLCBkb2MuZmlyc3QgKyBkb2Muc2l6ZSAtIDEpLCBkaXNwbGF5ID0gY20uZGlzcGxheVxcbiAgaWYgKGxhc3QubGVuZ3RoICE9IGRpc3BsYXkubGluZU51bUNoYXJzKSB7XFxuICAgIHZhciB0ZXN0ID0gZGlzcGxheS5tZWFzdXJlLmFwcGVuZENoaWxkKGVsdChcXFwiZGl2XFxcIiwgW2VsdChcXFwiZGl2XFxcIiwgbGFzdCldLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxcIkNvZGVNaXJyb3ItbGluZW51bWJlciBDb2RlTWlycm9yLWd1dHRlci1lbHRcXFwiKSlcXG4gICAgdmFyIGlubmVyVyA9IHRlc3QuZmlyc3RDaGlsZC5vZmZzZXRXaWR0aCwgcGFkZGluZyA9IHRlc3Qub2Zmc2V0V2lkdGggLSBpbm5lcldcXG4gICAgZGlzcGxheS5saW5lR3V0dGVyLnN0eWxlLndpZHRoID0gXFxcIlxcXCJcXG4gICAgZGlzcGxheS5saW5lTnVtSW5uZXJXaWR0aCA9IE1hdGgubWF4KGlubmVyVywgZGlzcGxheS5saW5lR3V0dGVyLm9mZnNldFdpZHRoIC0gcGFkZGluZykgKyAxXFxuICAgIGRpc3BsYXkubGluZU51bVdpZHRoID0gZGlzcGxheS5saW5lTnVtSW5uZXJXaWR0aCArIHBhZGRpbmdcXG4gICAgZGlzcGxheS5saW5lTnVtQ2hhcnMgPSBkaXNwbGF5LmxpbmVOdW1Jbm5lcldpZHRoID8gbGFzdC5sZW5ndGggOiAtMVxcbiAgICBkaXNwbGF5LmxpbmVHdXR0ZXIuc3R5bGUud2lkdGggPSBkaXNwbGF5LmxpbmVOdW1XaWR0aCArIFxcXCJweFxcXCJcXG4gICAgdXBkYXRlR3V0dGVyU3BhY2UoY20pXFxuICAgIHJldHVybiB0cnVlXFxuICB9XFxuICByZXR1cm4gZmFsc2VcXG59XFxuXFxuLy8gUmVhZCB0aGUgYWN0dWFsIGhlaWdodHMgb2YgdGhlIHJlbmRlcmVkIGxpbmVzLCBhbmQgdXBkYXRlIHRoZWlyXFxuLy8gc3RvcmVkIGhlaWdodHMgdG8gbWF0Y2guXFxuZnVuY3Rpb24gdXBkYXRlSGVpZ2h0c0luVmlld3BvcnQoY20pIHtcXG4gIHZhciBkaXNwbGF5ID0gY20uZGlzcGxheVxcbiAgdmFyIHByZXZCb3R0b20gPSBkaXNwbGF5LmxpbmVEaXYub2Zmc2V0VG9wXFxuICBmb3IgKHZhciBpID0gMDsgaSA8IGRpc3BsYXkudmlldy5sZW5ndGg7IGkrKykge1xcbiAgICB2YXIgY3VyID0gZGlzcGxheS52aWV3W2ldLCBoZWlnaHQgPSAodm9pZCAwKVxcbiAgICBpZiAoY3VyLmhpZGRlbikgeyBjb250aW51ZSB9XFxuICAgIGlmIChpZSAmJiBpZV92ZXJzaW9uIDwgOCkge1xcbiAgICAgIHZhciBib3QgPSBjdXIubm9kZS5vZmZzZXRUb3AgKyBjdXIubm9kZS5vZmZzZXRIZWlnaHRcXG4gICAgICBoZWlnaHQgPSBib3QgLSBwcmV2Qm90dG9tXFxuICAgICAgcHJldkJvdHRvbSA9IGJvdFxcbiAgICB9IGVsc2Uge1xcbiAgICAgIHZhciBib3ggPSBjdXIubm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxcbiAgICAgIGhlaWdodCA9IGJveC5ib3R0b20gLSBib3gudG9wXFxuICAgIH1cXG4gICAgdmFyIGRpZmYgPSBjdXIubGluZS5oZWlnaHQgLSBoZWlnaHRcXG4gICAgaWYgKGhlaWdodCA8IDIpIHsgaGVpZ2h0ID0gdGV4dEhlaWdodChkaXNwbGF5KSB9XFxuICAgIGlmIChkaWZmID4gLjAwMSB8fCBkaWZmIDwgLS4wMDEpIHtcXG4gICAgICB1cGRhdGVMaW5lSGVpZ2h0KGN1ci5saW5lLCBoZWlnaHQpXFxuICAgICAgdXBkYXRlV2lkZ2V0SGVpZ2h0KGN1ci5saW5lKVxcbiAgICAgIGlmIChjdXIucmVzdCkgeyBmb3IgKHZhciBqID0gMDsgaiA8IGN1ci5yZXN0Lmxlbmd0aDsgaisrKVxcbiAgICAgICAgeyB1cGRhdGVXaWRnZXRIZWlnaHQoY3VyLnJlc3Rbal0pIH0gfVxcbiAgICB9XFxuICB9XFxufVxcblxcbi8vIFJlYWQgYW5kIHN0b3JlIHRoZSBoZWlnaHQgb2YgbGluZSB3aWRnZXRzIGFzc29jaWF0ZWQgd2l0aCB0aGVcXG4vLyBnaXZlbiBsaW5lLlxcbmZ1bmN0aW9uIHVwZGF0ZVdpZGdldEhlaWdodChsaW5lKSB7XFxuICBpZiAobGluZS53aWRnZXRzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgbGluZS53aWRnZXRzLmxlbmd0aDsgKytpKVxcbiAgICB7IGxpbmUud2lkZ2V0c1tpXS5oZWlnaHQgPSBsaW5lLndpZGdldHNbaV0ubm9kZS5wYXJlbnROb2RlLm9mZnNldEhlaWdodCB9IH1cXG59XFxuXFxuLy8gQ29tcHV0ZSB0aGUgbGluZXMgdGhhdCBhcmUgdmlzaWJsZSBpbiBhIGdpdmVuIHZpZXdwb3J0IChkZWZhdWx0c1xcbi8vIHRoZSB0aGUgY3VycmVudCBzY3JvbGwgcG9zaXRpb24pLiB2aWV3cG9ydCBtYXkgY29udGFpbiB0b3AsXFxuLy8gaGVpZ2h0LCBhbmQgZW5zdXJlIChzZWUgb3Auc2Nyb2xsVG9Qb3MpIHByb3BlcnRpZXMuXFxuZnVuY3Rpb24gdmlzaWJsZUxpbmVzKGRpc3BsYXksIGRvYywgdmlld3BvcnQpIHtcXG4gIHZhciB0b3AgPSB2aWV3cG9ydCAmJiB2aWV3cG9ydC50b3AgIT0gbnVsbCA/IE1hdGgubWF4KDAsIHZpZXdwb3J0LnRvcCkgOiBkaXNwbGF5LnNjcm9sbGVyLnNjcm9sbFRvcFxcbiAgdG9wID0gTWF0aC5mbG9vcih0b3AgLSBwYWRkaW5nVG9wKGRpc3BsYXkpKVxcbiAgdmFyIGJvdHRvbSA9IHZpZXdwb3J0ICYmIHZpZXdwb3J0LmJvdHRvbSAhPSBudWxsID8gdmlld3BvcnQuYm90dG9tIDogdG9wICsgZGlzcGxheS53cmFwcGVyLmNsaWVudEhlaWdodFxcblxcbiAgdmFyIGZyb20gPSBsaW5lQXRIZWlnaHQoZG9jLCB0b3ApLCB0byA9IGxpbmVBdEhlaWdodChkb2MsIGJvdHRvbSlcXG4gIC8vIEVuc3VyZSBpcyBhIHtmcm9tOiB7bGluZSwgY2h9LCB0bzoge2xpbmUsIGNofX0gb2JqZWN0LCBhbmRcXG4gIC8vIGZvcmNlcyB0aG9zZSBsaW5lcyBpbnRvIHRoZSB2aWV3cG9ydCAoaWYgcG9zc2libGUpLlxcbiAgaWYgKHZpZXdwb3J0ICYmIHZpZXdwb3J0LmVuc3VyZSkge1xcbiAgICB2YXIgZW5zdXJlRnJvbSA9IHZpZXdwb3J0LmVuc3VyZS5mcm9tLmxpbmUsIGVuc3VyZVRvID0gdmlld3BvcnQuZW5zdXJlLnRvLmxpbmVcXG4gICAgaWYgKGVuc3VyZUZyb20gPCBmcm9tKSB7XFxuICAgICAgZnJvbSA9IGVuc3VyZUZyb21cXG4gICAgICB0byA9IGxpbmVBdEhlaWdodChkb2MsIGhlaWdodEF0TGluZShnZXRMaW5lKGRvYywgZW5zdXJlRnJvbSkpICsgZGlzcGxheS53cmFwcGVyLmNsaWVudEhlaWdodClcXG4gICAgfSBlbHNlIGlmIChNYXRoLm1pbihlbnN1cmVUbywgZG9jLmxhc3RMaW5lKCkpID49IHRvKSB7XFxuICAgICAgZnJvbSA9IGxpbmVBdEhlaWdodChkb2MsIGhlaWdodEF0TGluZShnZXRMaW5lKGRvYywgZW5zdXJlVG8pKSAtIGRpc3BsYXkud3JhcHBlci5jbGllbnRIZWlnaHQpXFxuICAgICAgdG8gPSBlbnN1cmVUb1xcbiAgICB9XFxuICB9XFxuICByZXR1cm4ge2Zyb206IGZyb20sIHRvOiBNYXRoLm1heCh0bywgZnJvbSArIDEpfVxcbn1cXG5cXG4vLyBTeW5jIHRoZSBzY3JvbGxhYmxlIGFyZWEgYW5kIHNjcm9sbGJhcnMsIGVuc3VyZSB0aGUgdmlld3BvcnRcXG4vLyBjb3ZlcnMgdGhlIHZpc2libGUgYXJlYS5cXG5mdW5jdGlvbiBzZXRTY3JvbGxUb3AoY20sIHZhbCkge1xcbiAgaWYgKE1hdGguYWJzKGNtLmRvYy5zY3JvbGxUb3AgLSB2YWwpIDwgMikgeyByZXR1cm4gfVxcbiAgY20uZG9jLnNjcm9sbFRvcCA9IHZhbFxcbiAgaWYgKCFnZWNrbykgeyB1cGRhdGVEaXNwbGF5U2ltcGxlKGNtLCB7dG9wOiB2YWx9KSB9XFxuICBpZiAoY20uZGlzcGxheS5zY3JvbGxlci5zY3JvbGxUb3AgIT0gdmFsKSB7IGNtLmRpc3BsYXkuc2Nyb2xsZXIuc2Nyb2xsVG9wID0gdmFsIH1cXG4gIGNtLmRpc3BsYXkuc2Nyb2xsYmFycy5zZXRTY3JvbGxUb3AodmFsKVxcbiAgaWYgKGdlY2tvKSB7IHVwZGF0ZURpc3BsYXlTaW1wbGUoY20pIH1cXG4gIHN0YXJ0V29ya2VyKGNtLCAxMDApXFxufVxcbi8vIFN5bmMgc2Nyb2xsZXIgYW5kIHNjcm9sbGJhciwgZW5zdXJlIHRoZSBndXR0ZXIgZWxlbWVudHMgYXJlXFxuLy8gYWxpZ25lZC5cXG5mdW5jdGlvbiBzZXRTY3JvbGxMZWZ0KGNtLCB2YWwsIGlzU2Nyb2xsZXIpIHtcXG4gIGlmIChpc1Njcm9sbGVyID8gdmFsID09IGNtLmRvYy5zY3JvbGxMZWZ0IDogTWF0aC5hYnMoY20uZG9jLnNjcm9sbExlZnQgLSB2YWwpIDwgMikgeyByZXR1cm4gfVxcbiAgdmFsID0gTWF0aC5taW4odmFsLCBjbS5kaXNwbGF5LnNjcm9sbGVyLnNjcm9sbFdpZHRoIC0gY20uZGlzcGxheS5zY3JvbGxlci5jbGllbnRXaWR0aClcXG4gIGNtLmRvYy5zY3JvbGxMZWZ0ID0gdmFsXFxuICBhbGlnbkhvcml6b250YWxseShjbSlcXG4gIGlmIChjbS5kaXNwbGF5LnNjcm9sbGVyLnNjcm9sbExlZnQgIT0gdmFsKSB7IGNtLmRpc3BsYXkuc2Nyb2xsZXIuc2Nyb2xsTGVmdCA9IHZhbCB9XFxuICBjbS5kaXNwbGF5LnNjcm9sbGJhcnMuc2V0U2Nyb2xsTGVmdCh2YWwpXFxufVxcblxcbi8vIFNpbmNlIHRoZSBkZWx0YSB2YWx1ZXMgcmVwb3J0ZWQgb24gbW91c2Ugd2hlZWwgZXZlbnRzIGFyZVxcbi8vIHVuc3RhbmRhcmRpemVkIGJldHdlZW4gYnJvd3NlcnMgYW5kIGV2ZW4gYnJvd3NlciB2ZXJzaW9ucywgYW5kXFxuLy8gZ2VuZXJhbGx5IGhvcnJpYmx5IHVucHJlZGljdGFibGUsIHRoaXMgY29kZSBzdGFydHMgYnkgbWVhc3VyaW5nXFxuLy8gdGhlIHNjcm9sbCBlZmZlY3QgdGhhdCB0aGUgZmlyc3QgZmV3IG1vdXNlIHdoZWVsIGV2ZW50cyBoYXZlLFxcbi8vIGFuZCwgZnJvbSB0aGF0LCBkZXRlY3RzIHRoZSB3YXkgaXQgY2FuIGNvbnZlcnQgZGVsdGFzIHRvIHBpeGVsXFxuLy8gb2Zmc2V0cyBhZnRlcndhcmRzLlxcbi8vXFxuLy8gVGhlIHJlYXNvbiB3ZSB3YW50IHRvIGtub3cgdGhlIGFtb3VudCBhIHdoZWVsIGV2ZW50IHdpbGwgc2Nyb2xsXFxuLy8gaXMgdGhhdCBpdCBnaXZlcyB1cyBhIGNoYW5jZSB0byB1cGRhdGUgdGhlIGRpc3BsYXkgYmVmb3JlIHRoZVxcbi8vIGFjdHVhbCBzY3JvbGxpbmcgaGFwcGVucywgcmVkdWNpbmcgZmxpY2tlcmluZy5cXG5cXG52YXIgd2hlZWxTYW1wbGVzID0gMDtcXG52YXIgd2hlZWxQaXhlbHNQZXJVbml0ID0gbnVsbDtcXG4vLyBGaWxsIGluIGEgYnJvd3Nlci1kZXRlY3RlZCBzdGFydGluZyB2YWx1ZSBvbiBicm93c2VycyB3aGVyZSB3ZVxcbi8vIGtub3cgb25lLiBUaGVzZSBkb24ndCBoYXZlIHRvIGJlIGFjY3VyYXRlIC0tIHRoZSByZXN1bHQgb2YgdGhlbVxcbi8vIGJlaW5nIHdyb25nIHdvdWxkIGp1c3QgYmUgYSBzbGlnaHQgZmxpY2tlciBvbiB0aGUgZmlyc3Qgd2hlZWxcXG4vLyBzY3JvbGwgKGlmIGl0IGlzIGxhcmdlIGVub3VnaCkuXFxuaWYgKGllKSB7IHdoZWVsUGl4ZWxzUGVyVW5pdCA9IC0uNTMgfVxcbmVsc2UgaWYgKGdlY2tvKSB7IHdoZWVsUGl4ZWxzUGVyVW5pdCA9IDE1IH1cXG5lbHNlIGlmIChjaHJvbWUpIHsgd2hlZWxQaXhlbHNQZXJVbml0ID0gLS43IH1cXG5lbHNlIGlmIChzYWZhcmkpIHsgd2hlZWxQaXhlbHNQZXJVbml0ID0gLTEvMyB9XFxuXFxuZnVuY3Rpb24gd2hlZWxFdmVudERlbHRhKGUpIHtcXG4gIHZhciBkeCA9IGUud2hlZWxEZWx0YVgsIGR5ID0gZS53aGVlbERlbHRhWVxcbiAgaWYgKGR4ID09IG51bGwgJiYgZS5kZXRhaWwgJiYgZS5heGlzID09IGUuSE9SSVpPTlRBTF9BWElTKSB7IGR4ID0gZS5kZXRhaWwgfVxcbiAgaWYgKGR5ID09IG51bGwgJiYgZS5kZXRhaWwgJiYgZS5heGlzID09IGUuVkVSVElDQUxfQVhJUykgeyBkeSA9IGUuZGV0YWlsIH1cXG4gIGVsc2UgaWYgKGR5ID09IG51bGwpIHsgZHkgPSBlLndoZWVsRGVsdGEgfVxcbiAgcmV0dXJuIHt4OiBkeCwgeTogZHl9XFxufVxcbmZ1bmN0aW9uIHdoZWVsRXZlbnRQaXhlbHMoZSkge1xcbiAgdmFyIGRlbHRhID0gd2hlZWxFdmVudERlbHRhKGUpXFxuICBkZWx0YS54ICo9IHdoZWVsUGl4ZWxzUGVyVW5pdFxcbiAgZGVsdGEueSAqPSB3aGVlbFBpeGVsc1BlclVuaXRcXG4gIHJldHVybiBkZWx0YVxcbn1cXG5cXG5mdW5jdGlvbiBvblNjcm9sbFdoZWVsKGNtLCBlKSB7XFxuICB2YXIgZGVsdGEgPSB3aGVlbEV2ZW50RGVsdGEoZSksIGR4ID0gZGVsdGEueCwgZHkgPSBkZWx0YS55XFxuXFxuICB2YXIgZGlzcGxheSA9IGNtLmRpc3BsYXksIHNjcm9sbCA9IGRpc3BsYXkuc2Nyb2xsZXJcXG4gIC8vIFF1aXQgaWYgdGhlcmUncyBub3RoaW5nIHRvIHNjcm9sbCBoZXJlXFxuICB2YXIgY2FuU2Nyb2xsWCA9IHNjcm9sbC5zY3JvbGxXaWR0aCA+IHNjcm9sbC5jbGllbnRXaWR0aFxcbiAgdmFyIGNhblNjcm9sbFkgPSBzY3JvbGwuc2Nyb2xsSGVpZ2h0ID4gc2Nyb2xsLmNsaWVudEhlaWdodFxcbiAgaWYgKCEoZHggJiYgY2FuU2Nyb2xsWCB8fCBkeSAmJiBjYW5TY3JvbGxZKSkgeyByZXR1cm4gfVxcblxcbiAgLy8gV2Via2l0IGJyb3dzZXJzIG9uIE9TIFggYWJvcnQgbW9tZW50dW0gc2Nyb2xscyB3aGVuIHRoZSB0YXJnZXRcXG4gIC8vIG9mIHRoZSBzY3JvbGwgZXZlbnQgaXMgcmVtb3ZlZCBmcm9tIHRoZSBzY3JvbGxhYmxlIGVsZW1lbnQuXFxuICAvLyBUaGlzIGhhY2sgKHNlZSByZWxhdGVkIGNvZGUgaW4gcGF0Y2hEaXNwbGF5KSBtYWtlcyBzdXJlIHRoZVxcbiAgLy8gZWxlbWVudCBpcyBrZXB0IGFyb3VuZC5cXG4gIGlmIChkeSAmJiBtYWMgJiYgd2Via2l0KSB7XFxuICAgIG91dGVyOiBmb3IgKHZhciBjdXIgPSBlLnRhcmdldCwgdmlldyA9IGRpc3BsYXkudmlldzsgY3VyICE9IHNjcm9sbDsgY3VyID0gY3VyLnBhcmVudE5vZGUpIHtcXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZpZXcubGVuZ3RoOyBpKyspIHtcXG4gICAgICAgIGlmICh2aWV3W2ldLm5vZGUgPT0gY3VyKSB7XFxuICAgICAgICAgIGNtLmRpc3BsYXkuY3VycmVudFdoZWVsVGFyZ2V0ID0gY3VyXFxuICAgICAgICAgIGJyZWFrIG91dGVyXFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICB9XFxuICB9XFxuXFxuICAvLyBPbiBzb21lIGJyb3dzZXJzLCBob3Jpem9udGFsIHNjcm9sbGluZyB3aWxsIGNhdXNlIHJlZHJhd3MgdG9cXG4gIC8vIGhhcHBlbiBiZWZvcmUgdGhlIGd1dHRlciBoYXMgYmVlbiByZWFsaWduZWQsIGNhdXNpbmcgaXQgdG9cXG4gIC8vIHdyaWdnbGUgYXJvdW5kIGluIGEgbW9zdCB1bnNlZW1seSB3YXkuIFdoZW4gd2UgaGF2ZSBhblxcbiAgLy8gZXN0aW1hdGVkIHBpeGVscy9kZWx0YSB2YWx1ZSwgd2UganVzdCBoYW5kbGUgaG9yaXpvbnRhbFxcbiAgLy8gc2Nyb2xsaW5nIGVudGlyZWx5IGhlcmUuIEl0J2xsIGJlIHNsaWdodGx5IG9mZiBmcm9tIG5hdGl2ZSwgYnV0XFxuICAvLyBiZXR0ZXIgdGhhbiBnbGl0Y2hpbmcgb3V0LlxcbiAgaWYgKGR4ICYmICFnZWNrbyAmJiAhcHJlc3RvICYmIHdoZWVsUGl4ZWxzUGVyVW5pdCAhPSBudWxsKSB7XFxuICAgIGlmIChkeSAmJiBjYW5TY3JvbGxZKVxcbiAgICAgIHsgc2V0U2Nyb2xsVG9wKGNtLCBNYXRoLm1heCgwLCBNYXRoLm1pbihzY3JvbGwuc2Nyb2xsVG9wICsgZHkgKiB3aGVlbFBpeGVsc1BlclVuaXQsIHNjcm9sbC5zY3JvbGxIZWlnaHQgLSBzY3JvbGwuY2xpZW50SGVpZ2h0KSkpIH1cXG4gICAgc2V0U2Nyb2xsTGVmdChjbSwgTWF0aC5tYXgoMCwgTWF0aC5taW4oc2Nyb2xsLnNjcm9sbExlZnQgKyBkeCAqIHdoZWVsUGl4ZWxzUGVyVW5pdCwgc2Nyb2xsLnNjcm9sbFdpZHRoIC0gc2Nyb2xsLmNsaWVudFdpZHRoKSkpXFxuICAgIC8vIE9ubHkgcHJldmVudCBkZWZhdWx0IHNjcm9sbGluZyBpZiB2ZXJ0aWNhbCBzY3JvbGxpbmcgaXNcXG4gICAgLy8gYWN0dWFsbHkgcG9zc2libGUuIE90aGVyd2lzZSwgaXQgY2F1c2VzIHZlcnRpY2FsIHNjcm9sbFxcbiAgICAvLyBqaXR0ZXIgb24gT1NYIHRyYWNrcGFkcyB3aGVuIGRlbHRhWCBpcyBzbWFsbCBhbmQgZGVsdGFZXFxuICAgIC8vIGlzIGxhcmdlIChpc3N1ZSAjMzU3OSlcXG4gICAgaWYgKCFkeSB8fCAoZHkgJiYgY2FuU2Nyb2xsWSkpXFxuICAgICAgeyBlX3ByZXZlbnREZWZhdWx0KGUpIH1cXG4gICAgZGlzcGxheS53aGVlbFN0YXJ0WCA9IG51bGwgLy8gQWJvcnQgbWVhc3VyZW1lbnQsIGlmIGluIHByb2dyZXNzXFxuICAgIHJldHVyblxcbiAgfVxcblxcbiAgLy8gJ1Byb2plY3QnIHRoZSB2aXNpYmxlIHZpZXdwb3J0IHRvIGNvdmVyIHRoZSBhcmVhIHRoYXQgaXMgYmVpbmdcXG4gIC8vIHNjcm9sbGVkIGludG8gdmlldyAoaWYgd2Uga25vdyBlbm91Z2ggdG8gZXN0aW1hdGUgaXQpLlxcbiAgaWYgKGR5ICYmIHdoZWVsUGl4ZWxzUGVyVW5pdCAhPSBudWxsKSB7XFxuICAgIHZhciBwaXhlbHMgPSBkeSAqIHdoZWVsUGl4ZWxzUGVyVW5pdFxcbiAgICB2YXIgdG9wID0gY20uZG9jLnNjcm9sbFRvcCwgYm90ID0gdG9wICsgZGlzcGxheS53cmFwcGVyLmNsaWVudEhlaWdodFxcbiAgICBpZiAocGl4ZWxzIDwgMCkgeyB0b3AgPSBNYXRoLm1heCgwLCB0b3AgKyBwaXhlbHMgLSA1MCkgfVxcbiAgICBlbHNlIHsgYm90ID0gTWF0aC5taW4oY20uZG9jLmhlaWdodCwgYm90ICsgcGl4ZWxzICsgNTApIH1cXG4gICAgdXBkYXRlRGlzcGxheVNpbXBsZShjbSwge3RvcDogdG9wLCBib3R0b206IGJvdH0pXFxuICB9XFxuXFxuICBpZiAod2hlZWxTYW1wbGVzIDwgMjApIHtcXG4gICAgaWYgKGRpc3BsYXkud2hlZWxTdGFydFggPT0gbnVsbCkge1xcbiAgICAgIGRpc3BsYXkud2hlZWxTdGFydFggPSBzY3JvbGwuc2Nyb2xsTGVmdDsgZGlzcGxheS53aGVlbFN0YXJ0WSA9IHNjcm9sbC5zY3JvbGxUb3BcXG4gICAgICBkaXNwbGF5LndoZWVsRFggPSBkeDsgZGlzcGxheS53aGVlbERZID0gZHlcXG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIGlmIChkaXNwbGF5LndoZWVsU3RhcnRYID09IG51bGwpIHsgcmV0dXJuIH1cXG4gICAgICAgIHZhciBtb3ZlZFggPSBzY3JvbGwuc2Nyb2xsTGVmdCAtIGRpc3BsYXkud2hlZWxTdGFydFhcXG4gICAgICAgIHZhciBtb3ZlZFkgPSBzY3JvbGwuc2Nyb2xsVG9wIC0gZGlzcGxheS53aGVlbFN0YXJ0WVxcbiAgICAgICAgdmFyIHNhbXBsZSA9IChtb3ZlZFkgJiYgZGlzcGxheS53aGVlbERZICYmIG1vdmVkWSAvIGRpc3BsYXkud2hlZWxEWSkgfHxcXG4gICAgICAgICAgKG1vdmVkWCAmJiBkaXNwbGF5LndoZWVsRFggJiYgbW92ZWRYIC8gZGlzcGxheS53aGVlbERYKVxcbiAgICAgICAgZGlzcGxheS53aGVlbFN0YXJ0WCA9IGRpc3BsYXkud2hlZWxTdGFydFkgPSBudWxsXFxuICAgICAgICBpZiAoIXNhbXBsZSkgeyByZXR1cm4gfVxcbiAgICAgICAgd2hlZWxQaXhlbHNQZXJVbml0ID0gKHdoZWVsUGl4ZWxzUGVyVW5pdCAqIHdoZWVsU2FtcGxlcyArIHNhbXBsZSkgLyAod2hlZWxTYW1wbGVzICsgMSlcXG4gICAgICAgICsrd2hlZWxTYW1wbGVzXFxuICAgICAgfSwgMjAwKVxcbiAgICB9IGVsc2Uge1xcbiAgICAgIGRpc3BsYXkud2hlZWxEWCArPSBkeDsgZGlzcGxheS53aGVlbERZICs9IGR5XFxuICAgIH1cXG4gIH1cXG59XFxuXFxuLy8gU0NST0xMQkFSU1xcblxcbi8vIFByZXBhcmUgRE9NIHJlYWRzIG5lZWRlZCB0byB1cGRhdGUgdGhlIHNjcm9sbGJhcnMuIERvbmUgaW4gb25lXFxuLy8gc2hvdCB0byBtaW5pbWl6ZSB1cGRhdGUvbWVhc3VyZSByb3VuZHRyaXBzLlxcbmZ1bmN0aW9uIG1lYXN1cmVGb3JTY3JvbGxiYXJzKGNtKSB7XFxuICB2YXIgZCA9IGNtLmRpc3BsYXksIGd1dHRlclcgPSBkLmd1dHRlcnMub2Zmc2V0V2lkdGhcXG4gIHZhciBkb2NIID0gTWF0aC5yb3VuZChjbS5kb2MuaGVpZ2h0ICsgcGFkZGluZ1ZlcnQoY20uZGlzcGxheSkpXFxuICByZXR1cm4ge1xcbiAgICBjbGllbnRIZWlnaHQ6IGQuc2Nyb2xsZXIuY2xpZW50SGVpZ2h0LFxcbiAgICB2aWV3SGVpZ2h0OiBkLndyYXBwZXIuY2xpZW50SGVpZ2h0LFxcbiAgICBzY3JvbGxXaWR0aDogZC5zY3JvbGxlci5zY3JvbGxXaWR0aCwgY2xpZW50V2lkdGg6IGQuc2Nyb2xsZXIuY2xpZW50V2lkdGgsXFxuICAgIHZpZXdXaWR0aDogZC53cmFwcGVyLmNsaWVudFdpZHRoLFxcbiAgICBiYXJMZWZ0OiBjbS5vcHRpb25zLmZpeGVkR3V0dGVyID8gZ3V0dGVyVyA6IDAsXFxuICAgIGRvY0hlaWdodDogZG9jSCxcXG4gICAgc2Nyb2xsSGVpZ2h0OiBkb2NIICsgc2Nyb2xsR2FwKGNtKSArIGQuYmFySGVpZ2h0LFxcbiAgICBuYXRpdmVCYXJXaWR0aDogZC5uYXRpdmVCYXJXaWR0aCxcXG4gICAgZ3V0dGVyV2lkdGg6IGd1dHRlcldcXG4gIH1cXG59XFxuXFxudmFyIE5hdGl2ZVNjcm9sbGJhcnMgPSBmdW5jdGlvbihwbGFjZSwgc2Nyb2xsLCBjbSkge1xcbiAgdGhpcy5jbSA9IGNtXFxuICB2YXIgdmVydCA9IHRoaXMudmVydCA9IGVsdChcXFwiZGl2XFxcIiwgW2VsdChcXFwiZGl2XFxcIiwgbnVsbCwgbnVsbCwgXFxcIm1pbi13aWR0aDogMXB4XFxcIildLCBcXFwiQ29kZU1pcnJvci12c2Nyb2xsYmFyXFxcIilcXG4gIHZhciBob3JpeiA9IHRoaXMuaG9yaXogPSBlbHQoXFxcImRpdlxcXCIsIFtlbHQoXFxcImRpdlxcXCIsIG51bGwsIG51bGwsIFxcXCJoZWlnaHQ6IDEwMCU7IG1pbi1oZWlnaHQ6IDFweFxcXCIpXSwgXFxcIkNvZGVNaXJyb3ItaHNjcm9sbGJhclxcXCIpXFxuICBwbGFjZSh2ZXJ0KTsgcGxhY2UoaG9yaXopXFxuXFxuICBvbih2ZXJ0LCBcXFwic2Nyb2xsXFxcIiwgZnVuY3Rpb24gKCkge1xcbiAgICBpZiAodmVydC5jbGllbnRIZWlnaHQpIHsgc2Nyb2xsKHZlcnQuc2Nyb2xsVG9wLCBcXFwidmVydGljYWxcXFwiKSB9XFxuICB9KVxcbiAgb24oaG9yaXosIFxcXCJzY3JvbGxcXFwiLCBmdW5jdGlvbiAoKSB7XFxuICAgIGlmIChob3Jpei5jbGllbnRXaWR0aCkgeyBzY3JvbGwoaG9yaXouc2Nyb2xsTGVmdCwgXFxcImhvcml6b250YWxcXFwiKSB9XFxuICB9KVxcblxcbiAgdGhpcy5jaGVja2VkWmVyb1dpZHRoID0gZmFsc2VcXG4gIC8vIE5lZWQgdG8gc2V0IGEgbWluaW11bSB3aWR0aCB0byBzZWUgdGhlIHNjcm9sbGJhciBvbiBJRTcgKGJ1dCBtdXN0IG5vdCBzZXQgaXQgb24gSUU4KS5cXG4gIGlmIChpZSAmJiBpZV92ZXJzaW9uIDwgOCkgeyB0aGlzLmhvcml6LnN0eWxlLm1pbkhlaWdodCA9IHRoaXMudmVydC5zdHlsZS5taW5XaWR0aCA9IFxcXCIxOHB4XFxcIiB9XFxufTtcXG5cXG5OYXRpdmVTY3JvbGxiYXJzLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAobWVhc3VyZSkge1xcbiAgdmFyIG5lZWRzSCA9IG1lYXN1cmUuc2Nyb2xsV2lkdGggPiBtZWFzdXJlLmNsaWVudFdpZHRoICsgMVxcbiAgdmFyIG5lZWRzViA9IG1lYXN1cmUuc2Nyb2xsSGVpZ2h0ID4gbWVhc3VyZS5jbGllbnRIZWlnaHQgKyAxXFxuICB2YXIgc1dpZHRoID0gbWVhc3VyZS5uYXRpdmVCYXJXaWR0aFxcblxcbiAgaWYgKG5lZWRzVikge1xcbiAgICB0aGlzLnZlcnQuc3R5bGUuZGlzcGxheSA9IFxcXCJibG9ja1xcXCJcXG4gICAgdGhpcy52ZXJ0LnN0eWxlLmJvdHRvbSA9IG5lZWRzSCA/IHNXaWR0aCArIFxcXCJweFxcXCIgOiBcXFwiMFxcXCJcXG4gICAgdmFyIHRvdGFsSGVpZ2h0ID0gbWVhc3VyZS52aWV3SGVpZ2h0IC0gKG5lZWRzSCA/IHNXaWR0aCA6IDApXFxuICAgIC8vIEEgYnVnIGluIElFOCBjYW4gY2F1c2UgdGhpcyB2YWx1ZSB0byBiZSBuZWdhdGl2ZSwgc28gZ3VhcmQgaXQuXFxuICAgIHRoaXMudmVydC5maXJzdENoaWxkLnN0eWxlLmhlaWdodCA9XFxuICAgICAgTWF0aC5tYXgoMCwgbWVhc3VyZS5zY3JvbGxIZWlnaHQgLSBtZWFzdXJlLmNsaWVudEhlaWdodCArIHRvdGFsSGVpZ2h0KSArIFxcXCJweFxcXCJcXG4gIH0gZWxzZSB7XFxuICAgIHRoaXMudmVydC5zdHlsZS5kaXNwbGF5ID0gXFxcIlxcXCJcXG4gICAgdGhpcy52ZXJ0LmZpcnN0Q2hpbGQuc3R5bGUuaGVpZ2h0ID0gXFxcIjBcXFwiXFxuICB9XFxuXFxuICBpZiAobmVlZHNIKSB7XFxuICAgIHRoaXMuaG9yaXouc3R5bGUuZGlzcGxheSA9IFxcXCJibG9ja1xcXCJcXG4gICAgdGhpcy5ob3Jpei5zdHlsZS5yaWdodCA9IG5lZWRzViA/IHNXaWR0aCArIFxcXCJweFxcXCIgOiBcXFwiMFxcXCJcXG4gICAgdGhpcy5ob3Jpei5zdHlsZS5sZWZ0ID0gbWVhc3VyZS5iYXJMZWZ0ICsgXFxcInB4XFxcIlxcbiAgICB2YXIgdG90YWxXaWR0aCA9IG1lYXN1cmUudmlld1dpZHRoIC0gbWVhc3VyZS5iYXJMZWZ0IC0gKG5lZWRzViA/IHNXaWR0aCA6IDApXFxuICAgIHRoaXMuaG9yaXouZmlyc3RDaGlsZC5zdHlsZS53aWR0aCA9XFxuICAgICAgTWF0aC5tYXgoMCwgbWVhc3VyZS5zY3JvbGxXaWR0aCAtIG1lYXN1cmUuY2xpZW50V2lkdGggKyB0b3RhbFdpZHRoKSArIFxcXCJweFxcXCJcXG4gIH0gZWxzZSB7XFxuICAgIHRoaXMuaG9yaXouc3R5bGUuZGlzcGxheSA9IFxcXCJcXFwiXFxuICAgIHRoaXMuaG9yaXouZmlyc3RDaGlsZC5zdHlsZS53aWR0aCA9IFxcXCIwXFxcIlxcbiAgfVxcblxcbiAgaWYgKCF0aGlzLmNoZWNrZWRaZXJvV2lkdGggJiYgbWVhc3VyZS5jbGllbnRIZWlnaHQgPiAwKSB7XFxuICAgIGlmIChzV2lkdGggPT0gMCkgeyB0aGlzLnplcm9XaWR0aEhhY2soKSB9XFxuICAgIHRoaXMuY2hlY2tlZFplcm9XaWR0aCA9IHRydWVcXG4gIH1cXG5cXG4gIHJldHVybiB7cmlnaHQ6IG5lZWRzViA/IHNXaWR0aCA6IDAsIGJvdHRvbTogbmVlZHNIID8gc1dpZHRoIDogMH1cXG59O1xcblxcbk5hdGl2ZVNjcm9sbGJhcnMucHJvdG90eXBlLnNldFNjcm9sbExlZnQgPSBmdW5jdGlvbiAocG9zKSB7XFxuICBpZiAodGhpcy5ob3Jpei5zY3JvbGxMZWZ0ICE9IHBvcykgeyB0aGlzLmhvcml6LnNjcm9sbExlZnQgPSBwb3MgfVxcbiAgaWYgKHRoaXMuZGlzYWJsZUhvcml6KSB7IHRoaXMuZW5hYmxlWmVyb1dpZHRoQmFyKHRoaXMuaG9yaXosIHRoaXMuZGlzYWJsZUhvcml6KSB9XFxufTtcXG5cXG5OYXRpdmVTY3JvbGxiYXJzLnByb3RvdHlwZS5zZXRTY3JvbGxUb3AgPSBmdW5jdGlvbiAocG9zKSB7XFxuICBpZiAodGhpcy52ZXJ0LnNjcm9sbFRvcCAhPSBwb3MpIHsgdGhpcy52ZXJ0LnNjcm9sbFRvcCA9IHBvcyB9XFxuICBpZiAodGhpcy5kaXNhYmxlVmVydCkgeyB0aGlzLmVuYWJsZVplcm9XaWR0aEJhcih0aGlzLnZlcnQsIHRoaXMuZGlzYWJsZVZlcnQpIH1cXG59O1xcblxcbk5hdGl2ZVNjcm9sbGJhcnMucHJvdG90eXBlLnplcm9XaWR0aEhhY2sgPSBmdW5jdGlvbiAoKSB7XFxuICB2YXIgdyA9IG1hYyAmJiAhbWFjX2dlTW91bnRhaW5MaW9uID8gXFxcIjEycHhcXFwiIDogXFxcIjE4cHhcXFwiXFxuICB0aGlzLmhvcml6LnN0eWxlLmhlaWdodCA9IHRoaXMudmVydC5zdHlsZS53aWR0aCA9IHdcXG4gIHRoaXMuaG9yaXouc3R5bGUucG9pbnRlckV2ZW50cyA9IHRoaXMudmVydC5zdHlsZS5wb2ludGVyRXZlbnRzID0gXFxcIm5vbmVcXFwiXFxuICB0aGlzLmRpc2FibGVIb3JpeiA9IG5ldyBEZWxheWVkXFxuICB0aGlzLmRpc2FibGVWZXJ0ID0gbmV3IERlbGF5ZWRcXG59O1xcblxcbk5hdGl2ZVNjcm9sbGJhcnMucHJvdG90eXBlLmVuYWJsZVplcm9XaWR0aEJhciA9IGZ1bmN0aW9uIChiYXIsIGRlbGF5KSB7XFxuICBiYXIuc3R5bGUucG9pbnRlckV2ZW50cyA9IFxcXCJhdXRvXFxcIlxcbiAgZnVuY3Rpb24gbWF5YmVEaXNhYmxlKCkge1xcbiAgICAvLyBUbyBmaW5kIG91dCB3aGV0aGVyIHRoZSBzY3JvbGxiYXIgaXMgc3RpbGwgdmlzaWJsZSwgd2VcXG4gICAgLy8gY2hlY2sgd2hldGhlciB0aGUgZWxlbWVudCB1bmRlciB0aGUgcGl4ZWwgaW4gdGhlIGJvdHRvbVxcbiAgICAvLyBsZWZ0IGNvcm5lciBvZiB0aGUgc2Nyb2xsYmFyIGJveCBpcyB0aGUgc2Nyb2xsYmFyIGJveFxcbiAgICAvLyBpdHNlbGYgKHdoZW4gdGhlIGJhciBpcyBzdGlsbCB2aXNpYmxlKSBvciBpdHMgZmlsbGVyIGNoaWxkXFxuICAgIC8vICh3aGVuIHRoZSBiYXIgaXMgaGlkZGVuKS4gSWYgaXQgaXMgc3RpbGwgdmlzaWJsZSwgd2Uga2VlcFxcbiAgICAvLyBpdCBlbmFibGVkLCBpZiBpdCdzIGhpZGRlbiwgd2UgZGlzYWJsZSBwb2ludGVyIGV2ZW50cy5cXG4gICAgdmFyIGJveCA9IGJhci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxcbiAgICB2YXIgZWx0ID0gZG9jdW1lbnQuZWxlbWVudEZyb21Qb2ludChib3gubGVmdCArIDEsIGJveC5ib3R0b20gLSAxKVxcbiAgICBpZiAoZWx0ICE9IGJhcikgeyBiYXIuc3R5bGUucG9pbnRlckV2ZW50cyA9IFxcXCJub25lXFxcIiB9XFxuICAgIGVsc2UgeyBkZWxheS5zZXQoMTAwMCwgbWF5YmVEaXNhYmxlKSB9XFxuICB9XFxuICBkZWxheS5zZXQoMTAwMCwgbWF5YmVEaXNhYmxlKVxcbn07XFxuXFxuTmF0aXZlU2Nyb2xsYmFycy5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XFxuICB2YXIgcGFyZW50ID0gdGhpcy5ob3Jpei5wYXJlbnROb2RlXFxuICBwYXJlbnQucmVtb3ZlQ2hpbGQodGhpcy5ob3JpeilcXG4gIHBhcmVudC5yZW1vdmVDaGlsZCh0aGlzLnZlcnQpXFxufTtcXG5cXG52YXIgTnVsbFNjcm9sbGJhcnMgPSBmdW5jdGlvbiAoKSB7fTtcXG5cXG5OdWxsU2Nyb2xsYmFycy5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkgeyByZXR1cm4ge2JvdHRvbTogMCwgcmlnaHQ6IDB9IH07XFxuTnVsbFNjcm9sbGJhcnMucHJvdG90eXBlLnNldFNjcm9sbExlZnQgPSBmdW5jdGlvbiAoKSB7fTtcXG5OdWxsU2Nyb2xsYmFycy5wcm90b3R5cGUuc2V0U2Nyb2xsVG9wID0gZnVuY3Rpb24gKCkge307XFxuTnVsbFNjcm9sbGJhcnMucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge307XFxuXFxuZnVuY3Rpb24gdXBkYXRlU2Nyb2xsYmFycyhjbSwgbWVhc3VyZSkge1xcbiAgaWYgKCFtZWFzdXJlKSB7IG1lYXN1cmUgPSBtZWFzdXJlRm9yU2Nyb2xsYmFycyhjbSkgfVxcbiAgdmFyIHN0YXJ0V2lkdGggPSBjbS5kaXNwbGF5LmJhcldpZHRoLCBzdGFydEhlaWdodCA9IGNtLmRpc3BsYXkuYmFySGVpZ2h0XFxuICB1cGRhdGVTY3JvbGxiYXJzSW5uZXIoY20sIG1lYXN1cmUpXFxuICBmb3IgKHZhciBpID0gMDsgaSA8IDQgJiYgc3RhcnRXaWR0aCAhPSBjbS5kaXNwbGF5LmJhcldpZHRoIHx8IHN0YXJ0SGVpZ2h0ICE9IGNtLmRpc3BsYXkuYmFySGVpZ2h0OyBpKyspIHtcXG4gICAgaWYgKHN0YXJ0V2lkdGggIT0gY20uZGlzcGxheS5iYXJXaWR0aCAmJiBjbS5vcHRpb25zLmxpbmVXcmFwcGluZylcXG4gICAgICB7IHVwZGF0ZUhlaWdodHNJblZpZXdwb3J0KGNtKSB9XFxuICAgIHVwZGF0ZVNjcm9sbGJhcnNJbm5lcihjbSwgbWVhc3VyZUZvclNjcm9sbGJhcnMoY20pKVxcbiAgICBzdGFydFdpZHRoID0gY20uZGlzcGxheS5iYXJXaWR0aDsgc3RhcnRIZWlnaHQgPSBjbS5kaXNwbGF5LmJhckhlaWdodFxcbiAgfVxcbn1cXG5cXG4vLyBSZS1zeW5jaHJvbml6ZSB0aGUgZmFrZSBzY3JvbGxiYXJzIHdpdGggdGhlIGFjdHVhbCBzaXplIG9mIHRoZVxcbi8vIGNvbnRlbnQuXFxuZnVuY3Rpb24gdXBkYXRlU2Nyb2xsYmFyc0lubmVyKGNtLCBtZWFzdXJlKSB7XFxuICB2YXIgZCA9IGNtLmRpc3BsYXlcXG4gIHZhciBzaXplcyA9IGQuc2Nyb2xsYmFycy51cGRhdGUobWVhc3VyZSlcXG5cXG4gIGQuc2l6ZXIuc3R5bGUucGFkZGluZ1JpZ2h0ID0gKGQuYmFyV2lkdGggPSBzaXplcy5yaWdodCkgKyBcXFwicHhcXFwiXFxuICBkLnNpemVyLnN0eWxlLnBhZGRpbmdCb3R0b20gPSAoZC5iYXJIZWlnaHQgPSBzaXplcy5ib3R0b20pICsgXFxcInB4XFxcIlxcbiAgZC5oZWlnaHRGb3JjZXIuc3R5bGUuYm9yZGVyQm90dG9tID0gc2l6ZXMuYm90dG9tICsgXFxcInB4IHNvbGlkIHRyYW5zcGFyZW50XFxcIlxcblxcbiAgaWYgKHNpemVzLnJpZ2h0ICYmIHNpemVzLmJvdHRvbSkge1xcbiAgICBkLnNjcm9sbGJhckZpbGxlci5zdHlsZS5kaXNwbGF5ID0gXFxcImJsb2NrXFxcIlxcbiAgICBkLnNjcm9sbGJhckZpbGxlci5zdHlsZS5oZWlnaHQgPSBzaXplcy5ib3R0b20gKyBcXFwicHhcXFwiXFxuICAgIGQuc2Nyb2xsYmFyRmlsbGVyLnN0eWxlLndpZHRoID0gc2l6ZXMucmlnaHQgKyBcXFwicHhcXFwiXFxuICB9IGVsc2UgeyBkLnNjcm9sbGJhckZpbGxlci5zdHlsZS5kaXNwbGF5ID0gXFxcIlxcXCIgfVxcbiAgaWYgKHNpemVzLmJvdHRvbSAmJiBjbS5vcHRpb25zLmNvdmVyR3V0dGVyTmV4dFRvU2Nyb2xsYmFyICYmIGNtLm9wdGlvbnMuZml4ZWRHdXR0ZXIpIHtcXG4gICAgZC5ndXR0ZXJGaWxsZXIuc3R5bGUuZGlzcGxheSA9IFxcXCJibG9ja1xcXCJcXG4gICAgZC5ndXR0ZXJGaWxsZXIuc3R5bGUuaGVpZ2h0ID0gc2l6ZXMuYm90dG9tICsgXFxcInB4XFxcIlxcbiAgICBkLmd1dHRlckZpbGxlci5zdHlsZS53aWR0aCA9IG1lYXN1cmUuZ3V0dGVyV2lkdGggKyBcXFwicHhcXFwiXFxuICB9IGVsc2UgeyBkLmd1dHRlckZpbGxlci5zdHlsZS5kaXNwbGF5ID0gXFxcIlxcXCIgfVxcbn1cXG5cXG52YXIgc2Nyb2xsYmFyTW9kZWwgPSB7XFxcIm5hdGl2ZVxcXCI6IE5hdGl2ZVNjcm9sbGJhcnMsIFxcXCJudWxsXFxcIjogTnVsbFNjcm9sbGJhcnN9XFxuXFxuZnVuY3Rpb24gaW5pdFNjcm9sbGJhcnMoY20pIHtcXG4gIGlmIChjbS5kaXNwbGF5LnNjcm9sbGJhcnMpIHtcXG4gICAgY20uZGlzcGxheS5zY3JvbGxiYXJzLmNsZWFyKClcXG4gICAgaWYgKGNtLmRpc3BsYXkuc2Nyb2xsYmFycy5hZGRDbGFzcylcXG4gICAgICB7IHJtQ2xhc3MoY20uZGlzcGxheS53cmFwcGVyLCBjbS5kaXNwbGF5LnNjcm9sbGJhcnMuYWRkQ2xhc3MpIH1cXG4gIH1cXG5cXG4gIGNtLmRpc3BsYXkuc2Nyb2xsYmFycyA9IG5ldyBzY3JvbGxiYXJNb2RlbFtjbS5vcHRpb25zLnNjcm9sbGJhclN0eWxlXShmdW5jdGlvbiAobm9kZSkge1xcbiAgICBjbS5kaXNwbGF5LndyYXBwZXIuaW5zZXJ0QmVmb3JlKG5vZGUsIGNtLmRpc3BsYXkuc2Nyb2xsYmFyRmlsbGVyKVxcbiAgICAvLyBQcmV2ZW50IGNsaWNrcyBpbiB0aGUgc2Nyb2xsYmFycyBmcm9tIGtpbGxpbmcgZm9jdXNcXG4gICAgb24obm9kZSwgXFxcIm1vdXNlZG93blxcXCIsIGZ1bmN0aW9uICgpIHtcXG4gICAgICBpZiAoY20uc3RhdGUuZm9jdXNlZCkgeyBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNtLmRpc3BsYXkuaW5wdXQuZm9jdXMoKTsgfSwgMCkgfVxcbiAgICB9KVxcbiAgICBub2RlLnNldEF0dHJpYnV0ZShcXFwiY20tbm90LWNvbnRlbnRcXFwiLCBcXFwidHJ1ZVxcXCIpXFxuICB9LCBmdW5jdGlvbiAocG9zLCBheGlzKSB7XFxuICAgIGlmIChheGlzID09IFxcXCJob3Jpem9udGFsXFxcIikgeyBzZXRTY3JvbGxMZWZ0KGNtLCBwb3MpIH1cXG4gICAgZWxzZSB7IHNldFNjcm9sbFRvcChjbSwgcG9zKSB9XFxuICB9LCBjbSlcXG4gIGlmIChjbS5kaXNwbGF5LnNjcm9sbGJhcnMuYWRkQ2xhc3MpXFxuICAgIHsgYWRkQ2xhc3MoY20uZGlzcGxheS53cmFwcGVyLCBjbS5kaXNwbGF5LnNjcm9sbGJhcnMuYWRkQ2xhc3MpIH1cXG59XFxuXFxuLy8gU0NST0xMSU5HIFRISU5HUyBJTlRPIFZJRVdcXG5cXG4vLyBJZiBhbiBlZGl0b3Igc2l0cyBvbiB0aGUgdG9wIG9yIGJvdHRvbSBvZiB0aGUgd2luZG93LCBwYXJ0aWFsbHlcXG4vLyBzY3JvbGxlZCBvdXQgb2YgdmlldywgdGhpcyBlbnN1cmVzIHRoYXQgdGhlIGN1cnNvciBpcyB2aXNpYmxlLlxcbmZ1bmN0aW9uIG1heWJlU2Nyb2xsV2luZG93KGNtLCBjb29yZHMpIHtcXG4gIGlmIChzaWduYWxET01FdmVudChjbSwgXFxcInNjcm9sbEN1cnNvckludG9WaWV3XFxcIikpIHsgcmV0dXJuIH1cXG5cXG4gIHZhciBkaXNwbGF5ID0gY20uZGlzcGxheSwgYm94ID0gZGlzcGxheS5zaXplci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgZG9TY3JvbGwgPSBudWxsXFxuICBpZiAoY29vcmRzLnRvcCArIGJveC50b3AgPCAwKSB7IGRvU2Nyb2xsID0gdHJ1ZSB9XFxuICBlbHNlIGlmIChjb29yZHMuYm90dG9tICsgYm94LnRvcCA+ICh3aW5kb3cuaW5uZXJIZWlnaHQgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodCkpIHsgZG9TY3JvbGwgPSBmYWxzZSB9XFxuICBpZiAoZG9TY3JvbGwgIT0gbnVsbCAmJiAhcGhhbnRvbSkge1xcbiAgICB2YXIgc2Nyb2xsTm9kZSA9IGVsdChcXFwiZGl2XFxcIiwgXFxcIlxcXFx1MjAwYlxcXCIsIG51bGwsIChcXFwicG9zaXRpb246IGFic29sdXRlO1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgIHRvcDogXFxcIiArIChjb29yZHMudG9wIC0gZGlzcGxheS52aWV3T2Zmc2V0IC0gcGFkZGluZ1RvcChjbS5kaXNwbGF5KSkgKyBcXFwicHg7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBcXFwiICsgKGNvb3Jkcy5ib3R0b20gLSBjb29yZHMudG9wICsgc2Nyb2xsR2FwKGNtKSArIGRpc3BsYXkuYmFySGVpZ2h0KSArIFxcXCJweDtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICBsZWZ0OiBcXFwiICsgKGNvb3Jkcy5sZWZ0KSArIFxcXCJweDsgd2lkdGg6IDJweDtcXFwiKSlcXG4gICAgY20uZGlzcGxheS5saW5lU3BhY2UuYXBwZW5kQ2hpbGQoc2Nyb2xsTm9kZSlcXG4gICAgc2Nyb2xsTm9kZS5zY3JvbGxJbnRvVmlldyhkb1Njcm9sbClcXG4gICAgY20uZGlzcGxheS5saW5lU3BhY2UucmVtb3ZlQ2hpbGQoc2Nyb2xsTm9kZSlcXG4gIH1cXG59XFxuXFxuLy8gU2Nyb2xsIGEgZ2l2ZW4gcG9zaXRpb24gaW50byB2aWV3IChpbW1lZGlhdGVseSksIHZlcmlmeWluZyB0aGF0XFxuLy8gaXQgYWN0dWFsbHkgYmVjYW1lIHZpc2libGUgKGFzIGxpbmUgaGVpZ2h0cyBhcmUgYWNjdXJhdGVseVxcbi8vIG1lYXN1cmVkLCB0aGUgcG9zaXRpb24gb2Ygc29tZXRoaW5nIG1heSAnZHJpZnQnIGR1cmluZyBkcmF3aW5nKS5cXG5mdW5jdGlvbiBzY3JvbGxQb3NJbnRvVmlldyhjbSwgcG9zLCBlbmQsIG1hcmdpbikge1xcbiAgaWYgKG1hcmdpbiA9PSBudWxsKSB7IG1hcmdpbiA9IDAgfVxcbiAgdmFyIGNvb3Jkc1xcbiAgZm9yICh2YXIgbGltaXQgPSAwOyBsaW1pdCA8IDU7IGxpbWl0KyspIHtcXG4gICAgdmFyIGNoYW5nZWQgPSBmYWxzZVxcbiAgICBjb29yZHMgPSBjdXJzb3JDb29yZHMoY20sIHBvcylcXG4gICAgdmFyIGVuZENvb3JkcyA9ICFlbmQgfHwgZW5kID09IHBvcyA/IGNvb3JkcyA6IGN1cnNvckNvb3JkcyhjbSwgZW5kKVxcbiAgICB2YXIgc2Nyb2xsUG9zID0gY2FsY3VsYXRlU2Nyb2xsUG9zKGNtLCBNYXRoLm1pbihjb29yZHMubGVmdCwgZW5kQ29vcmRzLmxlZnQpLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1hdGgubWluKGNvb3Jkcy50b3AsIGVuZENvb3Jkcy50b3ApIC0gbWFyZ2luLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1hdGgubWF4KGNvb3Jkcy5sZWZ0LCBlbmRDb29yZHMubGVmdCksXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5tYXgoY29vcmRzLmJvdHRvbSwgZW5kQ29vcmRzLmJvdHRvbSkgKyBtYXJnaW4pXFxuICAgIHZhciBzdGFydFRvcCA9IGNtLmRvYy5zY3JvbGxUb3AsIHN0YXJ0TGVmdCA9IGNtLmRvYy5zY3JvbGxMZWZ0XFxuICAgIGlmIChzY3JvbGxQb3Muc2Nyb2xsVG9wICE9IG51bGwpIHtcXG4gICAgICBzZXRTY3JvbGxUb3AoY20sIHNjcm9sbFBvcy5zY3JvbGxUb3ApXFxuICAgICAgaWYgKE1hdGguYWJzKGNtLmRvYy5zY3JvbGxUb3AgLSBzdGFydFRvcCkgPiAxKSB7IGNoYW5nZWQgPSB0cnVlIH1cXG4gICAgfVxcbiAgICBpZiAoc2Nyb2xsUG9zLnNjcm9sbExlZnQgIT0gbnVsbCkge1xcbiAgICAgIHNldFNjcm9sbExlZnQoY20sIHNjcm9sbFBvcy5zY3JvbGxMZWZ0KVxcbiAgICAgIGlmIChNYXRoLmFicyhjbS5kb2Muc2Nyb2xsTGVmdCAtIHN0YXJ0TGVmdCkgPiAxKSB7IGNoYW5nZWQgPSB0cnVlIH1cXG4gICAgfVxcbiAgICBpZiAoIWNoYW5nZWQpIHsgYnJlYWsgfVxcbiAgfVxcbiAgcmV0dXJuIGNvb3Jkc1xcbn1cXG5cXG4vLyBTY3JvbGwgYSBnaXZlbiBzZXQgb2YgY29vcmRpbmF0ZXMgaW50byB2aWV3IChpbW1lZGlhdGVseSkuXFxuZnVuY3Rpb24gc2Nyb2xsSW50b1ZpZXcoY20sIHgxLCB5MSwgeDIsIHkyKSB7XFxuICB2YXIgc2Nyb2xsUG9zID0gY2FsY3VsYXRlU2Nyb2xsUG9zKGNtLCB4MSwgeTEsIHgyLCB5MilcXG4gIGlmIChzY3JvbGxQb3Muc2Nyb2xsVG9wICE9IG51bGwpIHsgc2V0U2Nyb2xsVG9wKGNtLCBzY3JvbGxQb3Muc2Nyb2xsVG9wKSB9XFxuICBpZiAoc2Nyb2xsUG9zLnNjcm9sbExlZnQgIT0gbnVsbCkgeyBzZXRTY3JvbGxMZWZ0KGNtLCBzY3JvbGxQb3Muc2Nyb2xsTGVmdCkgfVxcbn1cXG5cXG4vLyBDYWxjdWxhdGUgYSBuZXcgc2Nyb2xsIHBvc2l0aW9uIG5lZWRlZCB0byBzY3JvbGwgdGhlIGdpdmVuXFxuLy8gcmVjdGFuZ2xlIGludG8gdmlldy4gUmV0dXJucyBhbiBvYmplY3Qgd2l0aCBzY3JvbGxUb3AgYW5kXFxuLy8gc2Nyb2xsTGVmdCBwcm9wZXJ0aWVzLiBXaGVuIHRoZXNlIGFyZSB1bmRlZmluZWQsIHRoZVxcbi8vIHZlcnRpY2FsL2hvcml6b250YWwgcG9zaXRpb24gZG9lcyBub3QgbmVlZCB0byBiZSBhZGp1c3RlZC5cXG5mdW5jdGlvbiBjYWxjdWxhdGVTY3JvbGxQb3MoY20sIHgxLCB5MSwgeDIsIHkyKSB7XFxuICB2YXIgZGlzcGxheSA9IGNtLmRpc3BsYXksIHNuYXBNYXJnaW4gPSB0ZXh0SGVpZ2h0KGNtLmRpc3BsYXkpXFxuICBpZiAoeTEgPCAwKSB7IHkxID0gMCB9XFxuICB2YXIgc2NyZWVudG9wID0gY20uY3VyT3AgJiYgY20uY3VyT3Auc2Nyb2xsVG9wICE9IG51bGwgPyBjbS5jdXJPcC5zY3JvbGxUb3AgOiBkaXNwbGF5LnNjcm9sbGVyLnNjcm9sbFRvcFxcbiAgdmFyIHNjcmVlbiA9IGRpc3BsYXlIZWlnaHQoY20pLCByZXN1bHQgPSB7fVxcbiAgaWYgKHkyIC0geTEgPiBzY3JlZW4pIHsgeTIgPSB5MSArIHNjcmVlbiB9XFxuICB2YXIgZG9jQm90dG9tID0gY20uZG9jLmhlaWdodCArIHBhZGRpbmdWZXJ0KGRpc3BsYXkpXFxuICB2YXIgYXRUb3AgPSB5MSA8IHNuYXBNYXJnaW4sIGF0Qm90dG9tID0geTIgPiBkb2NCb3R0b20gLSBzbmFwTWFyZ2luXFxuICBpZiAoeTEgPCBzY3JlZW50b3ApIHtcXG4gICAgcmVzdWx0LnNjcm9sbFRvcCA9IGF0VG9wID8gMCA6IHkxXFxuICB9IGVsc2UgaWYgKHkyID4gc2NyZWVudG9wICsgc2NyZWVuKSB7XFxuICAgIHZhciBuZXdUb3AgPSBNYXRoLm1pbih5MSwgKGF0Qm90dG9tID8gZG9jQm90dG9tIDogeTIpIC0gc2NyZWVuKVxcbiAgICBpZiAobmV3VG9wICE9IHNjcmVlbnRvcCkgeyByZXN1bHQuc2Nyb2xsVG9wID0gbmV3VG9wIH1cXG4gIH1cXG5cXG4gIHZhciBzY3JlZW5sZWZ0ID0gY20uY3VyT3AgJiYgY20uY3VyT3Auc2Nyb2xsTGVmdCAhPSBudWxsID8gY20uY3VyT3Auc2Nyb2xsTGVmdCA6IGRpc3BsYXkuc2Nyb2xsZXIuc2Nyb2xsTGVmdFxcbiAgdmFyIHNjcmVlbncgPSBkaXNwbGF5V2lkdGgoY20pIC0gKGNtLm9wdGlvbnMuZml4ZWRHdXR0ZXIgPyBkaXNwbGF5Lmd1dHRlcnMub2Zmc2V0V2lkdGggOiAwKVxcbiAgdmFyIHRvb1dpZGUgPSB4MiAtIHgxID4gc2NyZWVud1xcbiAgaWYgKHRvb1dpZGUpIHsgeDIgPSB4MSArIHNjcmVlbncgfVxcbiAgaWYgKHgxIDwgMTApXFxuICAgIHsgcmVzdWx0LnNjcm9sbExlZnQgPSAwIH1cXG4gIGVsc2UgaWYgKHgxIDwgc2NyZWVubGVmdClcXG4gICAgeyByZXN1bHQuc2Nyb2xsTGVmdCA9IE1hdGgubWF4KDAsIHgxIC0gKHRvb1dpZGUgPyAwIDogMTApKSB9XFxuICBlbHNlIGlmICh4MiA+IHNjcmVlbncgKyBzY3JlZW5sZWZ0IC0gMylcXG4gICAgeyByZXN1bHQuc2Nyb2xsTGVmdCA9IHgyICsgKHRvb1dpZGUgPyAwIDogMTApIC0gc2NyZWVudyB9XFxuICByZXR1cm4gcmVzdWx0XFxufVxcblxcbi8vIFN0b3JlIGEgcmVsYXRpdmUgYWRqdXN0bWVudCB0byB0aGUgc2Nyb2xsIHBvc2l0aW9uIGluIHRoZSBjdXJyZW50XFxuLy8gb3BlcmF0aW9uICh0byBiZSBhcHBsaWVkIHdoZW4gdGhlIG9wZXJhdGlvbiBmaW5pc2hlcykuXFxuZnVuY3Rpb24gYWRkVG9TY3JvbGxQb3MoY20sIGxlZnQsIHRvcCkge1xcbiAgaWYgKGxlZnQgIT0gbnVsbCB8fCB0b3AgIT0gbnVsbCkgeyByZXNvbHZlU2Nyb2xsVG9Qb3MoY20pIH1cXG4gIGlmIChsZWZ0ICE9IG51bGwpXFxuICAgIHsgY20uY3VyT3Auc2Nyb2xsTGVmdCA9IChjbS5jdXJPcC5zY3JvbGxMZWZ0ID09IG51bGwgPyBjbS5kb2Muc2Nyb2xsTGVmdCA6IGNtLmN1ck9wLnNjcm9sbExlZnQpICsgbGVmdCB9XFxuICBpZiAodG9wICE9IG51bGwpXFxuICAgIHsgY20uY3VyT3Auc2Nyb2xsVG9wID0gKGNtLmN1ck9wLnNjcm9sbFRvcCA9PSBudWxsID8gY20uZG9jLnNjcm9sbFRvcCA6IGNtLmN1ck9wLnNjcm9sbFRvcCkgKyB0b3AgfVxcbn1cXG5cXG4vLyBNYWtlIHN1cmUgdGhhdCBhdCB0aGUgZW5kIG9mIHRoZSBvcGVyYXRpb24gdGhlIGN1cnJlbnQgY3Vyc29yIGlzXFxuLy8gc2hvd24uXFxuZnVuY3Rpb24gZW5zdXJlQ3Vyc29yVmlzaWJsZShjbSkge1xcbiAgcmVzb2x2ZVNjcm9sbFRvUG9zKGNtKVxcbiAgdmFyIGN1ciA9IGNtLmdldEN1cnNvcigpLCBmcm9tID0gY3VyLCB0byA9IGN1clxcbiAgaWYgKCFjbS5vcHRpb25zLmxpbmVXcmFwcGluZykge1xcbiAgICBmcm9tID0gY3VyLmNoID8gUG9zKGN1ci5saW5lLCBjdXIuY2ggLSAxKSA6IGN1clxcbiAgICB0byA9IFBvcyhjdXIubGluZSwgY3VyLmNoICsgMSlcXG4gIH1cXG4gIGNtLmN1ck9wLnNjcm9sbFRvUG9zID0ge2Zyb206IGZyb20sIHRvOiB0bywgbWFyZ2luOiBjbS5vcHRpb25zLmN1cnNvclNjcm9sbE1hcmdpbiwgaXNDdXJzb3I6IHRydWV9XFxufVxcblxcbi8vIFdoZW4gYW4gb3BlcmF0aW9uIGhhcyBpdHMgc2Nyb2xsVG9Qb3MgcHJvcGVydHkgc2V0LCBhbmQgYW5vdGhlclxcbi8vIHNjcm9sbCBhY3Rpb24gaXMgYXBwbGllZCBiZWZvcmUgdGhlIGVuZCBvZiB0aGUgb3BlcmF0aW9uLCB0aGlzXFxuLy8gJ3NpbXVsYXRlcycgc2Nyb2xsaW5nIHRoYXQgcG9zaXRpb24gaW50byB2aWV3IGluIGEgY2hlYXAgd2F5LCBzb1xcbi8vIHRoYXQgdGhlIGVmZmVjdCBvZiBpbnRlcm1lZGlhdGUgc2Nyb2xsIGNvbW1hbmRzIGlzIG5vdCBpZ25vcmVkLlxcbmZ1bmN0aW9uIHJlc29sdmVTY3JvbGxUb1BvcyhjbSkge1xcbiAgdmFyIHJhbmdlID0gY20uY3VyT3Auc2Nyb2xsVG9Qb3NcXG4gIGlmIChyYW5nZSkge1xcbiAgICBjbS5jdXJPcC5zY3JvbGxUb1BvcyA9IG51bGxcXG4gICAgdmFyIGZyb20gPSBlc3RpbWF0ZUNvb3JkcyhjbSwgcmFuZ2UuZnJvbSksIHRvID0gZXN0aW1hdGVDb29yZHMoY20sIHJhbmdlLnRvKVxcbiAgICB2YXIgc1BvcyA9IGNhbGN1bGF0ZVNjcm9sbFBvcyhjbSwgTWF0aC5taW4oZnJvbS5sZWZ0LCB0by5sZWZ0KSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5taW4oZnJvbS50b3AsIHRvLnRvcCkgLSByYW5nZS5tYXJnaW4sXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1hdGgubWF4KGZyb20ucmlnaHQsIHRvLnJpZ2h0KSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5tYXgoZnJvbS5ib3R0b20sIHRvLmJvdHRvbSkgKyByYW5nZS5tYXJnaW4pXFxuICAgIGNtLnNjcm9sbFRvKHNQb3Muc2Nyb2xsTGVmdCwgc1Bvcy5zY3JvbGxUb3ApXFxuICB9XFxufVxcblxcbi8vIE9wZXJhdGlvbnMgYXJlIHVzZWQgdG8gd3JhcCBhIHNlcmllcyBvZiBjaGFuZ2VzIHRvIHRoZSBlZGl0b3JcXG4vLyBzdGF0ZSBpbiBzdWNoIGEgd2F5IHRoYXQgZWFjaCBjaGFuZ2Ugd29uJ3QgaGF2ZSB0byB1cGRhdGUgdGhlXFxuLy8gY3Vyc29yIGFuZCBkaXNwbGF5ICh3aGljaCB3b3VsZCBiZSBhd2t3YXJkLCBzbG93LCBhbmRcXG4vLyBlcnJvci1wcm9uZSkuIEluc3RlYWQsIGRpc3BsYXkgdXBkYXRlcyBhcmUgYmF0Y2hlZCBhbmQgdGhlbiBhbGxcXG4vLyBjb21iaW5lZCBhbmQgZXhlY3V0ZWQgYXQgb25jZS5cXG5cXG52YXIgbmV4dE9wSWQgPSAwXFxuLy8gU3RhcnQgYSBuZXcgb3BlcmF0aW9uLlxcbmZ1bmN0aW9uIHN0YXJ0T3BlcmF0aW9uKGNtKSB7XFxuICBjbS5jdXJPcCA9IHtcXG4gICAgY206IGNtLFxcbiAgICB2aWV3Q2hhbmdlZDogZmFsc2UsICAgICAgLy8gRmxhZyB0aGF0IGluZGljYXRlcyB0aGF0IGxpbmVzIG1pZ2h0IG5lZWQgdG8gYmUgcmVkcmF3blxcbiAgICBzdGFydEhlaWdodDogY20uZG9jLmhlaWdodCwgLy8gVXNlZCB0byBkZXRlY3QgbmVlZCB0byB1cGRhdGUgc2Nyb2xsYmFyXFxuICAgIGZvcmNlVXBkYXRlOiBmYWxzZSwgICAgICAvLyBVc2VkIHRvIGZvcmNlIGEgcmVkcmF3XFxuICAgIHVwZGF0ZUlucHV0OiBudWxsLCAgICAgICAvLyBXaGV0aGVyIHRvIHJlc2V0IHRoZSBpbnB1dCB0ZXh0YXJlYVxcbiAgICB0eXBpbmc6IGZhbHNlLCAgICAgICAgICAgLy8gV2hldGhlciB0aGlzIHJlc2V0IHNob3VsZCBiZSBjYXJlZnVsIHRvIGxlYXZlIGV4aXN0aW5nIHRleHQgKGZvciBjb21wb3NpdGluZylcXG4gICAgY2hhbmdlT2JqczogbnVsbCwgICAgICAgIC8vIEFjY3VtdWxhdGVkIGNoYW5nZXMsIGZvciBmaXJpbmcgY2hhbmdlIGV2ZW50c1xcbiAgICBjdXJzb3JBY3Rpdml0eUhhbmRsZXJzOiBudWxsLCAvLyBTZXQgb2YgaGFuZGxlcnMgdG8gZmlyZSBjdXJzb3JBY3Rpdml0eSBvblxcbiAgICBjdXJzb3JBY3Rpdml0eUNhbGxlZDogMCwgLy8gVHJhY2tzIHdoaWNoIGN1cnNvckFjdGl2aXR5IGhhbmRsZXJzIGhhdmUgYmVlbiBjYWxsZWQgYWxyZWFkeVxcbiAgICBzZWxlY3Rpb25DaGFuZ2VkOiBmYWxzZSwgLy8gV2hldGhlciB0aGUgc2VsZWN0aW9uIG5lZWRzIHRvIGJlIHJlZHJhd25cXG4gICAgdXBkYXRlTWF4TGluZTogZmFsc2UsICAgIC8vIFNldCB3aGVuIHRoZSB3aWRlc3QgbGluZSBuZWVkcyB0byBiZSBkZXRlcm1pbmVkIGFuZXdcXG4gICAgc2Nyb2xsTGVmdDogbnVsbCwgc2Nyb2xsVG9wOiBudWxsLCAvLyBJbnRlcm1lZGlhdGUgc2Nyb2xsIHBvc2l0aW9uLCBub3QgcHVzaGVkIHRvIERPTSB5ZXRcXG4gICAgc2Nyb2xsVG9Qb3M6IG51bGwsICAgICAgIC8vIFVzZWQgdG8gc2Nyb2xsIHRvIGEgc3BlY2lmaWMgcG9zaXRpb25cXG4gICAgZm9jdXM6IGZhbHNlLFxcbiAgICBpZDogKytuZXh0T3BJZCAgICAgICAgICAgLy8gVW5pcXVlIElEXFxuICB9XFxuICBwdXNoT3BlcmF0aW9uKGNtLmN1ck9wKVxcbn1cXG5cXG4vLyBGaW5pc2ggYW4gb3BlcmF0aW9uLCB1cGRhdGluZyB0aGUgZGlzcGxheSBhbmQgc2lnbmFsbGluZyBkZWxheWVkIGV2ZW50c1xcbmZ1bmN0aW9uIGVuZE9wZXJhdGlvbihjbSkge1xcbiAgdmFyIG9wID0gY20uY3VyT3BcXG4gIGZpbmlzaE9wZXJhdGlvbihvcCwgZnVuY3Rpb24gKGdyb3VwKSB7XFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ3JvdXAub3BzLmxlbmd0aDsgaSsrKVxcbiAgICAgIHsgZ3JvdXAub3BzW2ldLmNtLmN1ck9wID0gbnVsbCB9XFxuICAgIGVuZE9wZXJhdGlvbnMoZ3JvdXApXFxuICB9KVxcbn1cXG5cXG4vLyBUaGUgRE9NIHVwZGF0ZXMgZG9uZSB3aGVuIGFuIG9wZXJhdGlvbiBmaW5pc2hlcyBhcmUgYmF0Y2hlZCBzb1xcbi8vIHRoYXQgdGhlIG1pbmltdW0gbnVtYmVyIG9mIHJlbGF5b3V0cyBhcmUgcmVxdWlyZWQuXFxuZnVuY3Rpb24gZW5kT3BlcmF0aW9ucyhncm91cCkge1xcbiAgdmFyIG9wcyA9IGdyb3VwLm9wc1xcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcHMubGVuZ3RoOyBpKyspIC8vIFJlYWQgRE9NXFxuICAgIHsgZW5kT3BlcmF0aW9uX1IxKG9wc1tpXSkgfVxcbiAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgb3BzLmxlbmd0aDsgaSQxKyspIC8vIFdyaXRlIERPTSAobWF5YmUpXFxuICAgIHsgZW5kT3BlcmF0aW9uX1cxKG9wc1tpJDFdKSB9XFxuICBmb3IgKHZhciBpJDIgPSAwOyBpJDIgPCBvcHMubGVuZ3RoOyBpJDIrKykgLy8gUmVhZCBET01cXG4gICAgeyBlbmRPcGVyYXRpb25fUjIob3BzW2kkMl0pIH1cXG4gIGZvciAodmFyIGkkMyA9IDA7IGkkMyA8IG9wcy5sZW5ndGg7IGkkMysrKSAvLyBXcml0ZSBET00gKG1heWJlKVxcbiAgICB7IGVuZE9wZXJhdGlvbl9XMihvcHNbaSQzXSkgfVxcbiAgZm9yICh2YXIgaSQ0ID0gMDsgaSQ0IDwgb3BzLmxlbmd0aDsgaSQ0KyspIC8vIFJlYWQgRE9NXFxuICAgIHsgZW5kT3BlcmF0aW9uX2ZpbmlzaChvcHNbaSQ0XSkgfVxcbn1cXG5cXG5mdW5jdGlvbiBlbmRPcGVyYXRpb25fUjEob3ApIHtcXG4gIHZhciBjbSA9IG9wLmNtLCBkaXNwbGF5ID0gY20uZGlzcGxheVxcbiAgbWF5YmVDbGlwU2Nyb2xsYmFycyhjbSlcXG4gIGlmIChvcC51cGRhdGVNYXhMaW5lKSB7IGZpbmRNYXhMaW5lKGNtKSB9XFxuXFxuICBvcC5tdXN0VXBkYXRlID0gb3Audmlld0NoYW5nZWQgfHwgb3AuZm9yY2VVcGRhdGUgfHwgb3Auc2Nyb2xsVG9wICE9IG51bGwgfHxcXG4gICAgb3Auc2Nyb2xsVG9Qb3MgJiYgKG9wLnNjcm9sbFRvUG9zLmZyb20ubGluZSA8IGRpc3BsYXkudmlld0Zyb20gfHxcXG4gICAgICAgICAgICAgICAgICAgICAgIG9wLnNjcm9sbFRvUG9zLnRvLmxpbmUgPj0gZGlzcGxheS52aWV3VG8pIHx8XFxuICAgIGRpc3BsYXkubWF4TGluZUNoYW5nZWQgJiYgY20ub3B0aW9ucy5saW5lV3JhcHBpbmdcXG4gIG9wLnVwZGF0ZSA9IG9wLm11c3RVcGRhdGUgJiZcXG4gICAgbmV3IERpc3BsYXlVcGRhdGUoY20sIG9wLm11c3RVcGRhdGUgJiYge3RvcDogb3Auc2Nyb2xsVG9wLCBlbnN1cmU6IG9wLnNjcm9sbFRvUG9zfSwgb3AuZm9yY2VVcGRhdGUpXFxufVxcblxcbmZ1bmN0aW9uIGVuZE9wZXJhdGlvbl9XMShvcCkge1xcbiAgb3AudXBkYXRlZERpc3BsYXkgPSBvcC5tdXN0VXBkYXRlICYmIHVwZGF0ZURpc3BsYXlJZk5lZWRlZChvcC5jbSwgb3AudXBkYXRlKVxcbn1cXG5cXG5mdW5jdGlvbiBlbmRPcGVyYXRpb25fUjIob3ApIHtcXG4gIHZhciBjbSA9IG9wLmNtLCBkaXNwbGF5ID0gY20uZGlzcGxheVxcbiAgaWYgKG9wLnVwZGF0ZWREaXNwbGF5KSB7IHVwZGF0ZUhlaWdodHNJblZpZXdwb3J0KGNtKSB9XFxuXFxuICBvcC5iYXJNZWFzdXJlID0gbWVhc3VyZUZvclNjcm9sbGJhcnMoY20pXFxuXFxuICAvLyBJZiB0aGUgbWF4IGxpbmUgY2hhbmdlZCBzaW5jZSBpdCB3YXMgbGFzdCBtZWFzdXJlZCwgbWVhc3VyZSBpdCxcXG4gIC8vIGFuZCBlbnN1cmUgdGhlIGRvY3VtZW50J3Mgd2lkdGggbWF0Y2hlcyBpdC5cXG4gIC8vIHVwZGF0ZURpc3BsYXlfVzIgd2lsbCB1c2UgdGhlc2UgcHJvcGVydGllcyB0byBkbyB0aGUgYWN0dWFsIHJlc2l6aW5nXFxuICBpZiAoZGlzcGxheS5tYXhMaW5lQ2hhbmdlZCAmJiAhY20ub3B0aW9ucy5saW5lV3JhcHBpbmcpIHtcXG4gICAgb3AuYWRqdXN0V2lkdGhUbyA9IG1lYXN1cmVDaGFyKGNtLCBkaXNwbGF5Lm1heExpbmUsIGRpc3BsYXkubWF4TGluZS50ZXh0Lmxlbmd0aCkubGVmdCArIDNcXG4gICAgY20uZGlzcGxheS5zaXplcldpZHRoID0gb3AuYWRqdXN0V2lkdGhUb1xcbiAgICBvcC5iYXJNZWFzdXJlLnNjcm9sbFdpZHRoID1cXG4gICAgICBNYXRoLm1heChkaXNwbGF5LnNjcm9sbGVyLmNsaWVudFdpZHRoLCBkaXNwbGF5LnNpemVyLm9mZnNldExlZnQgKyBvcC5hZGp1c3RXaWR0aFRvICsgc2Nyb2xsR2FwKGNtKSArIGNtLmRpc3BsYXkuYmFyV2lkdGgpXFxuICAgIG9wLm1heFNjcm9sbExlZnQgPSBNYXRoLm1heCgwLCBkaXNwbGF5LnNpemVyLm9mZnNldExlZnQgKyBvcC5hZGp1c3RXaWR0aFRvIC0gZGlzcGxheVdpZHRoKGNtKSlcXG4gIH1cXG5cXG4gIGlmIChvcC51cGRhdGVkRGlzcGxheSB8fCBvcC5zZWxlY3Rpb25DaGFuZ2VkKVxcbiAgICB7IG9wLnByZXBhcmVkU2VsZWN0aW9uID0gZGlzcGxheS5pbnB1dC5wcmVwYXJlU2VsZWN0aW9uKG9wLmZvY3VzKSB9XFxufVxcblxcbmZ1bmN0aW9uIGVuZE9wZXJhdGlvbl9XMihvcCkge1xcbiAgdmFyIGNtID0gb3AuY21cXG5cXG4gIGlmIChvcC5hZGp1c3RXaWR0aFRvICE9IG51bGwpIHtcXG4gICAgY20uZGlzcGxheS5zaXplci5zdHlsZS5taW5XaWR0aCA9IG9wLmFkanVzdFdpZHRoVG8gKyBcXFwicHhcXFwiXFxuICAgIGlmIChvcC5tYXhTY3JvbGxMZWZ0IDwgY20uZG9jLnNjcm9sbExlZnQpXFxuICAgICAgeyBzZXRTY3JvbGxMZWZ0KGNtLCBNYXRoLm1pbihjbS5kaXNwbGF5LnNjcm9sbGVyLnNjcm9sbExlZnQsIG9wLm1heFNjcm9sbExlZnQpLCB0cnVlKSB9XFxuICAgIGNtLmRpc3BsYXkubWF4TGluZUNoYW5nZWQgPSBmYWxzZVxcbiAgfVxcblxcbiAgdmFyIHRha2VGb2N1cyA9IG9wLmZvY3VzICYmIG9wLmZvY3VzID09IGFjdGl2ZUVsdCgpICYmICghZG9jdW1lbnQuaGFzRm9jdXMgfHwgZG9jdW1lbnQuaGFzRm9jdXMoKSlcXG4gIGlmIChvcC5wcmVwYXJlZFNlbGVjdGlvbilcXG4gICAgeyBjbS5kaXNwbGF5LmlucHV0LnNob3dTZWxlY3Rpb24ob3AucHJlcGFyZWRTZWxlY3Rpb24sIHRha2VGb2N1cykgfVxcbiAgaWYgKG9wLnVwZGF0ZWREaXNwbGF5IHx8IG9wLnN0YXJ0SGVpZ2h0ICE9IGNtLmRvYy5oZWlnaHQpXFxuICAgIHsgdXBkYXRlU2Nyb2xsYmFycyhjbSwgb3AuYmFyTWVhc3VyZSkgfVxcbiAgaWYgKG9wLnVwZGF0ZWREaXNwbGF5KVxcbiAgICB7IHNldERvY3VtZW50SGVpZ2h0KGNtLCBvcC5iYXJNZWFzdXJlKSB9XFxuXFxuICBpZiAob3Auc2VsZWN0aW9uQ2hhbmdlZCkgeyByZXN0YXJ0QmxpbmsoY20pIH1cXG5cXG4gIGlmIChjbS5zdGF0ZS5mb2N1c2VkICYmIG9wLnVwZGF0ZUlucHV0KVxcbiAgICB7IGNtLmRpc3BsYXkuaW5wdXQucmVzZXQob3AudHlwaW5nKSB9XFxuICBpZiAodGFrZUZvY3VzKSB7IGVuc3VyZUZvY3VzKG9wLmNtKSB9XFxufVxcblxcbmZ1bmN0aW9uIGVuZE9wZXJhdGlvbl9maW5pc2gob3ApIHtcXG4gIHZhciBjbSA9IG9wLmNtLCBkaXNwbGF5ID0gY20uZGlzcGxheSwgZG9jID0gY20uZG9jXFxuXFxuICBpZiAob3AudXBkYXRlZERpc3BsYXkpIHsgcG9zdFVwZGF0ZURpc3BsYXkoY20sIG9wLnVwZGF0ZSkgfVxcblxcbiAgLy8gQWJvcnQgbW91c2Ugd2hlZWwgZGVsdGEgbWVhc3VyZW1lbnQsIHdoZW4gc2Nyb2xsaW5nIGV4cGxpY2l0bHlcXG4gIGlmIChkaXNwbGF5LndoZWVsU3RhcnRYICE9IG51bGwgJiYgKG9wLnNjcm9sbFRvcCAhPSBudWxsIHx8IG9wLnNjcm9sbExlZnQgIT0gbnVsbCB8fCBvcC5zY3JvbGxUb1BvcykpXFxuICAgIHsgZGlzcGxheS53aGVlbFN0YXJ0WCA9IGRpc3BsYXkud2hlZWxTdGFydFkgPSBudWxsIH1cXG5cXG4gIC8vIFByb3BhZ2F0ZSB0aGUgc2Nyb2xsIHBvc2l0aW9uIHRvIHRoZSBhY3R1YWwgRE9NIHNjcm9sbGVyXFxuICBpZiAob3Auc2Nyb2xsVG9wICE9IG51bGwgJiYgKGRpc3BsYXkuc2Nyb2xsZXIuc2Nyb2xsVG9wICE9IG9wLnNjcm9sbFRvcCB8fCBvcC5mb3JjZVNjcm9sbCkpIHtcXG4gICAgZG9jLnNjcm9sbFRvcCA9IE1hdGgubWF4KDAsIE1hdGgubWluKGRpc3BsYXkuc2Nyb2xsZXIuc2Nyb2xsSGVpZ2h0IC0gZGlzcGxheS5zY3JvbGxlci5jbGllbnRIZWlnaHQsIG9wLnNjcm9sbFRvcCkpXFxuICAgIGRpc3BsYXkuc2Nyb2xsYmFycy5zZXRTY3JvbGxUb3AoZG9jLnNjcm9sbFRvcClcXG4gICAgZGlzcGxheS5zY3JvbGxlci5zY3JvbGxUb3AgPSBkb2Muc2Nyb2xsVG9wXFxuICB9XFxuICBpZiAob3Auc2Nyb2xsTGVmdCAhPSBudWxsICYmIChkaXNwbGF5LnNjcm9sbGVyLnNjcm9sbExlZnQgIT0gb3Auc2Nyb2xsTGVmdCB8fCBvcC5mb3JjZVNjcm9sbCkpIHtcXG4gICAgZG9jLnNjcm9sbExlZnQgPSBNYXRoLm1heCgwLCBNYXRoLm1pbihkaXNwbGF5LnNjcm9sbGVyLnNjcm9sbFdpZHRoIC0gZGlzcGxheS5zY3JvbGxlci5jbGllbnRXaWR0aCwgb3Auc2Nyb2xsTGVmdCkpXFxuICAgIGRpc3BsYXkuc2Nyb2xsYmFycy5zZXRTY3JvbGxMZWZ0KGRvYy5zY3JvbGxMZWZ0KVxcbiAgICBkaXNwbGF5LnNjcm9sbGVyLnNjcm9sbExlZnQgPSBkb2Muc2Nyb2xsTGVmdFxcbiAgICBhbGlnbkhvcml6b250YWxseShjbSlcXG4gIH1cXG4gIC8vIElmIHdlIG5lZWQgdG8gc2Nyb2xsIGEgc3BlY2lmaWMgcG9zaXRpb24gaW50byB2aWV3LCBkbyBzby5cXG4gIGlmIChvcC5zY3JvbGxUb1Bvcykge1xcbiAgICB2YXIgY29vcmRzID0gc2Nyb2xsUG9zSW50b1ZpZXcoY20sIGNsaXBQb3MoZG9jLCBvcC5zY3JvbGxUb1Bvcy5mcm9tKSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsaXBQb3MoZG9jLCBvcC5zY3JvbGxUb1Bvcy50byksIG9wLnNjcm9sbFRvUG9zLm1hcmdpbilcXG4gICAgaWYgKG9wLnNjcm9sbFRvUG9zLmlzQ3Vyc29yICYmIGNtLnN0YXRlLmZvY3VzZWQpIHsgbWF5YmVTY3JvbGxXaW5kb3coY20sIGNvb3JkcykgfVxcbiAgfVxcblxcbiAgLy8gRmlyZSBldmVudHMgZm9yIG1hcmtlcnMgdGhhdCBhcmUgaGlkZGVuL3VuaWRkZW4gYnkgZWRpdGluZyBvclxcbiAgLy8gdW5kb2luZ1xcbiAgdmFyIGhpZGRlbiA9IG9wLm1heWJlSGlkZGVuTWFya2VycywgdW5oaWRkZW4gPSBvcC5tYXliZVVuaGlkZGVuTWFya2Vyc1xcbiAgaWYgKGhpZGRlbikgeyBmb3IgKHZhciBpID0gMDsgaSA8IGhpZGRlbi5sZW5ndGg7ICsraSlcXG4gICAgeyBpZiAoIWhpZGRlbltpXS5saW5lcy5sZW5ndGgpIHsgc2lnbmFsKGhpZGRlbltpXSwgXFxcImhpZGVcXFwiKSB9IH0gfVxcbiAgaWYgKHVuaGlkZGVuKSB7IGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IHVuaGlkZGVuLmxlbmd0aDsgKytpJDEpXFxuICAgIHsgaWYgKHVuaGlkZGVuW2kkMV0ubGluZXMubGVuZ3RoKSB7IHNpZ25hbCh1bmhpZGRlbltpJDFdLCBcXFwidW5oaWRlXFxcIikgfSB9IH1cXG5cXG4gIGlmIChkaXNwbGF5LndyYXBwZXIub2Zmc2V0SGVpZ2h0KVxcbiAgICB7IGRvYy5zY3JvbGxUb3AgPSBjbS5kaXNwbGF5LnNjcm9sbGVyLnNjcm9sbFRvcCB9XFxuXFxuICAvLyBGaXJlIGNoYW5nZSBldmVudHMsIGFuZCBkZWxheWVkIGV2ZW50IGhhbmRsZXJzXFxuICBpZiAob3AuY2hhbmdlT2JqcylcXG4gICAgeyBzaWduYWwoY20sIFxcXCJjaGFuZ2VzXFxcIiwgY20sIG9wLmNoYW5nZU9ianMpIH1cXG4gIGlmIChvcC51cGRhdGUpXFxuICAgIHsgb3AudXBkYXRlLmZpbmlzaCgpIH1cXG59XFxuXFxuLy8gUnVuIHRoZSBnaXZlbiBmdW5jdGlvbiBpbiBhbiBvcGVyYXRpb25cXG5mdW5jdGlvbiBydW5Jbk9wKGNtLCBmKSB7XFxuICBpZiAoY20uY3VyT3ApIHsgcmV0dXJuIGYoKSB9XFxuICBzdGFydE9wZXJhdGlvbihjbSlcXG4gIHRyeSB7IHJldHVybiBmKCkgfVxcbiAgZmluYWxseSB7IGVuZE9wZXJhdGlvbihjbSkgfVxcbn1cXG4vLyBXcmFwcyBhIGZ1bmN0aW9uIGluIGFuIG9wZXJhdGlvbi4gUmV0dXJucyB0aGUgd3JhcHBlZCBmdW5jdGlvbi5cXG5mdW5jdGlvbiBvcGVyYXRpb24oY20sIGYpIHtcXG4gIHJldHVybiBmdW5jdGlvbigpIHtcXG4gICAgaWYgKGNtLmN1ck9wKSB7IHJldHVybiBmLmFwcGx5KGNtLCBhcmd1bWVudHMpIH1cXG4gICAgc3RhcnRPcGVyYXRpb24oY20pXFxuICAgIHRyeSB7IHJldHVybiBmLmFwcGx5KGNtLCBhcmd1bWVudHMpIH1cXG4gICAgZmluYWxseSB7IGVuZE9wZXJhdGlvbihjbSkgfVxcbiAgfVxcbn1cXG4vLyBVc2VkIHRvIGFkZCBtZXRob2RzIHRvIGVkaXRvciBhbmQgZG9jIGluc3RhbmNlcywgd3JhcHBpbmcgdGhlbSBpblxcbi8vIG9wZXJhdGlvbnMuXFxuZnVuY3Rpb24gbWV0aG9kT3AoZikge1xcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xcbiAgICBpZiAodGhpcy5jdXJPcCkgeyByZXR1cm4gZi5hcHBseSh0aGlzLCBhcmd1bWVudHMpIH1cXG4gICAgc3RhcnRPcGVyYXRpb24odGhpcylcXG4gICAgdHJ5IHsgcmV0dXJuIGYuYXBwbHkodGhpcywgYXJndW1lbnRzKSB9XFxuICAgIGZpbmFsbHkgeyBlbmRPcGVyYXRpb24odGhpcykgfVxcbiAgfVxcbn1cXG5mdW5jdGlvbiBkb2NNZXRob2RPcChmKSB7XFxuICByZXR1cm4gZnVuY3Rpb24oKSB7XFxuICAgIHZhciBjbSA9IHRoaXMuY21cXG4gICAgaWYgKCFjbSB8fCBjbS5jdXJPcCkgeyByZXR1cm4gZi5hcHBseSh0aGlzLCBhcmd1bWVudHMpIH1cXG4gICAgc3RhcnRPcGVyYXRpb24oY20pXFxuICAgIHRyeSB7IHJldHVybiBmLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfVxcbiAgICBmaW5hbGx5IHsgZW5kT3BlcmF0aW9uKGNtKSB9XFxuICB9XFxufVxcblxcbi8vIFVwZGF0ZXMgdGhlIGRpc3BsYXkudmlldyBkYXRhIHN0cnVjdHVyZSBmb3IgYSBnaXZlbiBjaGFuZ2UgdG8gdGhlXFxuLy8gZG9jdW1lbnQuIEZyb20gYW5kIHRvIGFyZSBpbiBwcmUtY2hhbmdlIGNvb3JkaW5hdGVzLiBMZW5kaWZmIGlzXFxuLy8gdGhlIGFtb3VudCBvZiBsaW5lcyBhZGRlZCBvciBzdWJ0cmFjdGVkIGJ5IHRoZSBjaGFuZ2UuIFRoaXMgaXNcXG4vLyB1c2VkIGZvciBjaGFuZ2VzIHRoYXQgc3BhbiBtdWx0aXBsZSBsaW5lcywgb3IgY2hhbmdlIHRoZSB3YXlcXG4vLyBsaW5lcyBhcmUgZGl2aWRlZCBpbnRvIHZpc3VhbCBsaW5lcy4gcmVnTGluZUNoYW5nZSAoYmVsb3cpXFxuLy8gcmVnaXN0ZXJzIHNpbmdsZS1saW5lIGNoYW5nZXMuXFxuZnVuY3Rpb24gcmVnQ2hhbmdlKGNtLCBmcm9tLCB0bywgbGVuZGlmZikge1xcbiAgaWYgKGZyb20gPT0gbnVsbCkgeyBmcm9tID0gY20uZG9jLmZpcnN0IH1cXG4gIGlmICh0byA9PSBudWxsKSB7IHRvID0gY20uZG9jLmZpcnN0ICsgY20uZG9jLnNpemUgfVxcbiAgaWYgKCFsZW5kaWZmKSB7IGxlbmRpZmYgPSAwIH1cXG5cXG4gIHZhciBkaXNwbGF5ID0gY20uZGlzcGxheVxcbiAgaWYgKGxlbmRpZmYgJiYgdG8gPCBkaXNwbGF5LnZpZXdUbyAmJlxcbiAgICAgIChkaXNwbGF5LnVwZGF0ZUxpbmVOdW1iZXJzID09IG51bGwgfHwgZGlzcGxheS51cGRhdGVMaW5lTnVtYmVycyA+IGZyb20pKVxcbiAgICB7IGRpc3BsYXkudXBkYXRlTGluZU51bWJlcnMgPSBmcm9tIH1cXG5cXG4gIGNtLmN1ck9wLnZpZXdDaGFuZ2VkID0gdHJ1ZVxcblxcbiAgaWYgKGZyb20gPj0gZGlzcGxheS52aWV3VG8pIHsgLy8gQ2hhbmdlIGFmdGVyXFxuICAgIGlmIChzYXdDb2xsYXBzZWRTcGFucyAmJiB2aXN1YWxMaW5lTm8oY20uZG9jLCBmcm9tKSA8IGRpc3BsYXkudmlld1RvKVxcbiAgICAgIHsgcmVzZXRWaWV3KGNtKSB9XFxuICB9IGVsc2UgaWYgKHRvIDw9IGRpc3BsYXkudmlld0Zyb20pIHsgLy8gQ2hhbmdlIGJlZm9yZVxcbiAgICBpZiAoc2F3Q29sbGFwc2VkU3BhbnMgJiYgdmlzdWFsTGluZUVuZE5vKGNtLmRvYywgdG8gKyBsZW5kaWZmKSA+IGRpc3BsYXkudmlld0Zyb20pIHtcXG4gICAgICByZXNldFZpZXcoY20pXFxuICAgIH0gZWxzZSB7XFxuICAgICAgZGlzcGxheS52aWV3RnJvbSArPSBsZW5kaWZmXFxuICAgICAgZGlzcGxheS52aWV3VG8gKz0gbGVuZGlmZlxcbiAgICB9XFxuICB9IGVsc2UgaWYgKGZyb20gPD0gZGlzcGxheS52aWV3RnJvbSAmJiB0byA+PSBkaXNwbGF5LnZpZXdUbykgeyAvLyBGdWxsIG92ZXJsYXBcXG4gICAgcmVzZXRWaWV3KGNtKVxcbiAgfSBlbHNlIGlmIChmcm9tIDw9IGRpc3BsYXkudmlld0Zyb20pIHsgLy8gVG9wIG92ZXJsYXBcXG4gICAgdmFyIGN1dCA9IHZpZXdDdXR0aW5nUG9pbnQoY20sIHRvLCB0byArIGxlbmRpZmYsIDEpXFxuICAgIGlmIChjdXQpIHtcXG4gICAgICBkaXNwbGF5LnZpZXcgPSBkaXNwbGF5LnZpZXcuc2xpY2UoY3V0LmluZGV4KVxcbiAgICAgIGRpc3BsYXkudmlld0Zyb20gPSBjdXQubGluZU5cXG4gICAgICBkaXNwbGF5LnZpZXdUbyArPSBsZW5kaWZmXFxuICAgIH0gZWxzZSB7XFxuICAgICAgcmVzZXRWaWV3KGNtKVxcbiAgICB9XFxuICB9IGVsc2UgaWYgKHRvID49IGRpc3BsYXkudmlld1RvKSB7IC8vIEJvdHRvbSBvdmVybGFwXFxuICAgIHZhciBjdXQkMSA9IHZpZXdDdXR0aW5nUG9pbnQoY20sIGZyb20sIGZyb20sIC0xKVxcbiAgICBpZiAoY3V0JDEpIHtcXG4gICAgICBkaXNwbGF5LnZpZXcgPSBkaXNwbGF5LnZpZXcuc2xpY2UoMCwgY3V0JDEuaW5kZXgpXFxuICAgICAgZGlzcGxheS52aWV3VG8gPSBjdXQkMS5saW5lTlxcbiAgICB9IGVsc2Uge1xcbiAgICAgIHJlc2V0VmlldyhjbSlcXG4gICAgfVxcbiAgfSBlbHNlIHsgLy8gR2FwIGluIHRoZSBtaWRkbGVcXG4gICAgdmFyIGN1dFRvcCA9IHZpZXdDdXR0aW5nUG9pbnQoY20sIGZyb20sIGZyb20sIC0xKVxcbiAgICB2YXIgY3V0Qm90ID0gdmlld0N1dHRpbmdQb2ludChjbSwgdG8sIHRvICsgbGVuZGlmZiwgMSlcXG4gICAgaWYgKGN1dFRvcCAmJiBjdXRCb3QpIHtcXG4gICAgICBkaXNwbGF5LnZpZXcgPSBkaXNwbGF5LnZpZXcuc2xpY2UoMCwgY3V0VG9wLmluZGV4KVxcbiAgICAgICAgLmNvbmNhdChidWlsZFZpZXdBcnJheShjbSwgY3V0VG9wLmxpbmVOLCBjdXRCb3QubGluZU4pKVxcbiAgICAgICAgLmNvbmNhdChkaXNwbGF5LnZpZXcuc2xpY2UoY3V0Qm90LmluZGV4KSlcXG4gICAgICBkaXNwbGF5LnZpZXdUbyArPSBsZW5kaWZmXFxuICAgIH0gZWxzZSB7XFxuICAgICAgcmVzZXRWaWV3KGNtKVxcbiAgICB9XFxuICB9XFxuXFxuICB2YXIgZXh0ID0gZGlzcGxheS5leHRlcm5hbE1lYXN1cmVkXFxuICBpZiAoZXh0KSB7XFxuICAgIGlmICh0byA8IGV4dC5saW5lTilcXG4gICAgICB7IGV4dC5saW5lTiArPSBsZW5kaWZmIH1cXG4gICAgZWxzZSBpZiAoZnJvbSA8IGV4dC5saW5lTiArIGV4dC5zaXplKVxcbiAgICAgIHsgZGlzcGxheS5leHRlcm5hbE1lYXN1cmVkID0gbnVsbCB9XFxuICB9XFxufVxcblxcbi8vIFJlZ2lzdGVyIGEgY2hhbmdlIHRvIGEgc2luZ2xlIGxpbmUuIFR5cGUgbXVzdCBiZSBvbmUgb2YgXFxcInRleHRcXFwiLFxcbi8vIFxcXCJndXR0ZXJcXFwiLCBcXFwiY2xhc3NcXFwiLCBcXFwid2lkZ2V0XFxcIlxcbmZ1bmN0aW9uIHJlZ0xpbmVDaGFuZ2UoY20sIGxpbmUsIHR5cGUpIHtcXG4gIGNtLmN1ck9wLnZpZXdDaGFuZ2VkID0gdHJ1ZVxcbiAgdmFyIGRpc3BsYXkgPSBjbS5kaXNwbGF5LCBleHQgPSBjbS5kaXNwbGF5LmV4dGVybmFsTWVhc3VyZWRcXG4gIGlmIChleHQgJiYgbGluZSA+PSBleHQubGluZU4gJiYgbGluZSA8IGV4dC5saW5lTiArIGV4dC5zaXplKVxcbiAgICB7IGRpc3BsYXkuZXh0ZXJuYWxNZWFzdXJlZCA9IG51bGwgfVxcblxcbiAgaWYgKGxpbmUgPCBkaXNwbGF5LnZpZXdGcm9tIHx8IGxpbmUgPj0gZGlzcGxheS52aWV3VG8pIHsgcmV0dXJuIH1cXG4gIHZhciBsaW5lVmlldyA9IGRpc3BsYXkudmlld1tmaW5kVmlld0luZGV4KGNtLCBsaW5lKV1cXG4gIGlmIChsaW5lVmlldy5ub2RlID09IG51bGwpIHsgcmV0dXJuIH1cXG4gIHZhciBhcnIgPSBsaW5lVmlldy5jaGFuZ2VzIHx8IChsaW5lVmlldy5jaGFuZ2VzID0gW10pXFxuICBpZiAoaW5kZXhPZihhcnIsIHR5cGUpID09IC0xKSB7IGFyci5wdXNoKHR5cGUpIH1cXG59XFxuXFxuLy8gQ2xlYXIgdGhlIHZpZXcuXFxuZnVuY3Rpb24gcmVzZXRWaWV3KGNtKSB7XFxuICBjbS5kaXNwbGF5LnZpZXdGcm9tID0gY20uZGlzcGxheS52aWV3VG8gPSBjbS5kb2MuZmlyc3RcXG4gIGNtLmRpc3BsYXkudmlldyA9IFtdXFxuICBjbS5kaXNwbGF5LnZpZXdPZmZzZXQgPSAwXFxufVxcblxcbmZ1bmN0aW9uIHZpZXdDdXR0aW5nUG9pbnQoY20sIG9sZE4sIG5ld04sIGRpcikge1xcbiAgdmFyIGluZGV4ID0gZmluZFZpZXdJbmRleChjbSwgb2xkTiksIGRpZmYsIHZpZXcgPSBjbS5kaXNwbGF5LnZpZXdcXG4gIGlmICghc2F3Q29sbGFwc2VkU3BhbnMgfHwgbmV3TiA9PSBjbS5kb2MuZmlyc3QgKyBjbS5kb2Muc2l6ZSlcXG4gICAgeyByZXR1cm4ge2luZGV4OiBpbmRleCwgbGluZU46IG5ld059IH1cXG4gIHZhciBuID0gY20uZGlzcGxheS52aWV3RnJvbVxcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbmRleDsgaSsrKVxcbiAgICB7IG4gKz0gdmlld1tpXS5zaXplIH1cXG4gIGlmIChuICE9IG9sZE4pIHtcXG4gICAgaWYgKGRpciA+IDApIHtcXG4gICAgICBpZiAoaW5kZXggPT0gdmlldy5sZW5ndGggLSAxKSB7IHJldHVybiBudWxsIH1cXG4gICAgICBkaWZmID0gKG4gKyB2aWV3W2luZGV4XS5zaXplKSAtIG9sZE5cXG4gICAgICBpbmRleCsrXFxuICAgIH0gZWxzZSB7XFxuICAgICAgZGlmZiA9IG4gLSBvbGROXFxuICAgIH1cXG4gICAgb2xkTiArPSBkaWZmOyBuZXdOICs9IGRpZmZcXG4gIH1cXG4gIHdoaWxlICh2aXN1YWxMaW5lTm8oY20uZG9jLCBuZXdOKSAhPSBuZXdOKSB7XFxuICAgIGlmIChpbmRleCA9PSAoZGlyIDwgMCA/IDAgOiB2aWV3Lmxlbmd0aCAtIDEpKSB7IHJldHVybiBudWxsIH1cXG4gICAgbmV3TiArPSBkaXIgKiB2aWV3W2luZGV4IC0gKGRpciA8IDAgPyAxIDogMCldLnNpemVcXG4gICAgaW5kZXggKz0gZGlyXFxuICB9XFxuICByZXR1cm4ge2luZGV4OiBpbmRleCwgbGluZU46IG5ld059XFxufVxcblxcbi8vIEZvcmNlIHRoZSB2aWV3IHRvIGNvdmVyIGEgZ2l2ZW4gcmFuZ2UsIGFkZGluZyBlbXB0eSB2aWV3IGVsZW1lbnRcXG4vLyBvciBjbGlwcGluZyBvZmYgZXhpc3Rpbmcgb25lcyBhcyBuZWVkZWQuXFxuZnVuY3Rpb24gYWRqdXN0VmlldyhjbSwgZnJvbSwgdG8pIHtcXG4gIHZhciBkaXNwbGF5ID0gY20uZGlzcGxheSwgdmlldyA9IGRpc3BsYXkudmlld1xcbiAgaWYgKHZpZXcubGVuZ3RoID09IDAgfHwgZnJvbSA+PSBkaXNwbGF5LnZpZXdUbyB8fCB0byA8PSBkaXNwbGF5LnZpZXdGcm9tKSB7XFxuICAgIGRpc3BsYXkudmlldyA9IGJ1aWxkVmlld0FycmF5KGNtLCBmcm9tLCB0bylcXG4gICAgZGlzcGxheS52aWV3RnJvbSA9IGZyb21cXG4gIH0gZWxzZSB7XFxuICAgIGlmIChkaXNwbGF5LnZpZXdGcm9tID4gZnJvbSlcXG4gICAgICB7IGRpc3BsYXkudmlldyA9IGJ1aWxkVmlld0FycmF5KGNtLCBmcm9tLCBkaXNwbGF5LnZpZXdGcm9tKS5jb25jYXQoZGlzcGxheS52aWV3KSB9XFxuICAgIGVsc2UgaWYgKGRpc3BsYXkudmlld0Zyb20gPCBmcm9tKVxcbiAgICAgIHsgZGlzcGxheS52aWV3ID0gZGlzcGxheS52aWV3LnNsaWNlKGZpbmRWaWV3SW5kZXgoY20sIGZyb20pKSB9XFxuICAgIGRpc3BsYXkudmlld0Zyb20gPSBmcm9tXFxuICAgIGlmIChkaXNwbGF5LnZpZXdUbyA8IHRvKVxcbiAgICAgIHsgZGlzcGxheS52aWV3ID0gZGlzcGxheS52aWV3LmNvbmNhdChidWlsZFZpZXdBcnJheShjbSwgZGlzcGxheS52aWV3VG8sIHRvKSkgfVxcbiAgICBlbHNlIGlmIChkaXNwbGF5LnZpZXdUbyA+IHRvKVxcbiAgICAgIHsgZGlzcGxheS52aWV3ID0gZGlzcGxheS52aWV3LnNsaWNlKDAsIGZpbmRWaWV3SW5kZXgoY20sIHRvKSkgfVxcbiAgfVxcbiAgZGlzcGxheS52aWV3VG8gPSB0b1xcbn1cXG5cXG4vLyBDb3VudCB0aGUgbnVtYmVyIG9mIGxpbmVzIGluIHRoZSB2aWV3IHdob3NlIERPTSByZXByZXNlbnRhdGlvbiBpc1xcbi8vIG91dCBvZiBkYXRlIChvciBub25leGlzdGVudCkuXFxuZnVuY3Rpb24gY291bnREaXJ0eVZpZXcoY20pIHtcXG4gIHZhciB2aWV3ID0gY20uZGlzcGxheS52aWV3LCBkaXJ0eSA9IDBcXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdmlldy5sZW5ndGg7IGkrKykge1xcbiAgICB2YXIgbGluZVZpZXcgPSB2aWV3W2ldXFxuICAgIGlmICghbGluZVZpZXcuaGlkZGVuICYmICghbGluZVZpZXcubm9kZSB8fCBsaW5lVmlldy5jaGFuZ2VzKSkgeyArK2RpcnR5IH1cXG4gIH1cXG4gIHJldHVybiBkaXJ0eVxcbn1cXG5cXG4vLyBISUdITElHSFQgV09SS0VSXFxuXFxuZnVuY3Rpb24gc3RhcnRXb3JrZXIoY20sIHRpbWUpIHtcXG4gIGlmIChjbS5kb2MubW9kZS5zdGFydFN0YXRlICYmIGNtLmRvYy5mcm9udGllciA8IGNtLmRpc3BsYXkudmlld1RvKVxcbiAgICB7IGNtLnN0YXRlLmhpZ2hsaWdodC5zZXQodGltZSwgYmluZChoaWdobGlnaHRXb3JrZXIsIGNtKSkgfVxcbn1cXG5cXG5mdW5jdGlvbiBoaWdobGlnaHRXb3JrZXIoY20pIHtcXG4gIHZhciBkb2MgPSBjbS5kb2NcXG4gIGlmIChkb2MuZnJvbnRpZXIgPCBkb2MuZmlyc3QpIHsgZG9jLmZyb250aWVyID0gZG9jLmZpcnN0IH1cXG4gIGlmIChkb2MuZnJvbnRpZXIgPj0gY20uZGlzcGxheS52aWV3VG8pIHsgcmV0dXJuIH1cXG4gIHZhciBlbmQgPSArbmV3IERhdGUgKyBjbS5vcHRpb25zLndvcmtUaW1lXFxuICB2YXIgc3RhdGUgPSBjb3B5U3RhdGUoZG9jLm1vZGUsIGdldFN0YXRlQmVmb3JlKGNtLCBkb2MuZnJvbnRpZXIpKVxcbiAgdmFyIGNoYW5nZWRMaW5lcyA9IFtdXFxuXFxuICBkb2MuaXRlcihkb2MuZnJvbnRpZXIsIE1hdGgubWluKGRvYy5maXJzdCArIGRvYy5zaXplLCBjbS5kaXNwbGF5LnZpZXdUbyArIDUwMCksIGZ1bmN0aW9uIChsaW5lKSB7XFxuICAgIGlmIChkb2MuZnJvbnRpZXIgPj0gY20uZGlzcGxheS52aWV3RnJvbSkgeyAvLyBWaXNpYmxlXFxuICAgICAgdmFyIG9sZFN0eWxlcyA9IGxpbmUuc3R5bGVzLCB0b29Mb25nID0gbGluZS50ZXh0Lmxlbmd0aCA+IGNtLm9wdGlvbnMubWF4SGlnaGxpZ2h0TGVuZ3RoXFxuICAgICAgdmFyIGhpZ2hsaWdodGVkID0gaGlnaGxpZ2h0TGluZShjbSwgbGluZSwgdG9vTG9uZyA/IGNvcHlTdGF0ZShkb2MubW9kZSwgc3RhdGUpIDogc3RhdGUsIHRydWUpXFxuICAgICAgbGluZS5zdHlsZXMgPSBoaWdobGlnaHRlZC5zdHlsZXNcXG4gICAgICB2YXIgb2xkQ2xzID0gbGluZS5zdHlsZUNsYXNzZXMsIG5ld0NscyA9IGhpZ2hsaWdodGVkLmNsYXNzZXNcXG4gICAgICBpZiAobmV3Q2xzKSB7IGxpbmUuc3R5bGVDbGFzc2VzID0gbmV3Q2xzIH1cXG4gICAgICBlbHNlIGlmIChvbGRDbHMpIHsgbGluZS5zdHlsZUNsYXNzZXMgPSBudWxsIH1cXG4gICAgICB2YXIgaXNjaGFuZ2UgPSAhb2xkU3R5bGVzIHx8IG9sZFN0eWxlcy5sZW5ndGggIT0gbGluZS5zdHlsZXMubGVuZ3RoIHx8XFxuICAgICAgICBvbGRDbHMgIT0gbmV3Q2xzICYmICghb2xkQ2xzIHx8ICFuZXdDbHMgfHwgb2xkQ2xzLmJnQ2xhc3MgIT0gbmV3Q2xzLmJnQ2xhc3MgfHwgb2xkQ2xzLnRleHRDbGFzcyAhPSBuZXdDbHMudGV4dENsYXNzKVxcbiAgICAgIGZvciAodmFyIGkgPSAwOyAhaXNjaGFuZ2UgJiYgaSA8IG9sZFN0eWxlcy5sZW5ndGg7ICsraSkgeyBpc2NoYW5nZSA9IG9sZFN0eWxlc1tpXSAhPSBsaW5lLnN0eWxlc1tpXSB9XFxuICAgICAgaWYgKGlzY2hhbmdlKSB7IGNoYW5nZWRMaW5lcy5wdXNoKGRvYy5mcm9udGllcikgfVxcbiAgICAgIGxpbmUuc3RhdGVBZnRlciA9IHRvb0xvbmcgPyBzdGF0ZSA6IGNvcHlTdGF0ZShkb2MubW9kZSwgc3RhdGUpXFxuICAgIH0gZWxzZSB7XFxuICAgICAgaWYgKGxpbmUudGV4dC5sZW5ndGggPD0gY20ub3B0aW9ucy5tYXhIaWdobGlnaHRMZW5ndGgpXFxuICAgICAgICB7IHByb2Nlc3NMaW5lKGNtLCBsaW5lLnRleHQsIHN0YXRlKSB9XFxuICAgICAgbGluZS5zdGF0ZUFmdGVyID0gZG9jLmZyb250aWVyICUgNSA9PSAwID8gY29weVN0YXRlKGRvYy5tb2RlLCBzdGF0ZSkgOiBudWxsXFxuICAgIH1cXG4gICAgKytkb2MuZnJvbnRpZXJcXG4gICAgaWYgKCtuZXcgRGF0ZSA+IGVuZCkge1xcbiAgICAgIHN0YXJ0V29ya2VyKGNtLCBjbS5vcHRpb25zLndvcmtEZWxheSlcXG4gICAgICByZXR1cm4gdHJ1ZVxcbiAgICB9XFxuICB9KVxcbiAgaWYgKGNoYW5nZWRMaW5lcy5sZW5ndGgpIHsgcnVuSW5PcChjbSwgZnVuY3Rpb24gKCkge1xcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoYW5nZWRMaW5lcy5sZW5ndGg7IGkrKylcXG4gICAgICB7IHJlZ0xpbmVDaGFuZ2UoY20sIGNoYW5nZWRMaW5lc1tpXSwgXFxcInRleHRcXFwiKSB9XFxuICB9KSB9XFxufVxcblxcbi8vIERJU1BMQVkgRFJBV0lOR1xcblxcbnZhciBEaXNwbGF5VXBkYXRlID0gZnVuY3Rpb24oY20sIHZpZXdwb3J0LCBmb3JjZSkge1xcbiAgdmFyIGRpc3BsYXkgPSBjbS5kaXNwbGF5XFxuXFxuICB0aGlzLnZpZXdwb3J0ID0gdmlld3BvcnRcXG4gIC8vIFN0b3JlIHNvbWUgdmFsdWVzIHRoYXQgd2UnbGwgbmVlZCBsYXRlciAoYnV0IGRvbid0IHdhbnQgdG8gZm9yY2UgYSByZWxheW91dCBmb3IpXFxuICB0aGlzLnZpc2libGUgPSB2aXNpYmxlTGluZXMoZGlzcGxheSwgY20uZG9jLCB2aWV3cG9ydClcXG4gIHRoaXMuZWRpdG9ySXNIaWRkZW4gPSAhZGlzcGxheS53cmFwcGVyLm9mZnNldFdpZHRoXFxuICB0aGlzLndyYXBwZXJIZWlnaHQgPSBkaXNwbGF5LndyYXBwZXIuY2xpZW50SGVpZ2h0XFxuICB0aGlzLndyYXBwZXJXaWR0aCA9IGRpc3BsYXkud3JhcHBlci5jbGllbnRXaWR0aFxcbiAgdGhpcy5vbGREaXNwbGF5V2lkdGggPSBkaXNwbGF5V2lkdGgoY20pXFxuICB0aGlzLmZvcmNlID0gZm9yY2VcXG4gIHRoaXMuZGltcyA9IGdldERpbWVuc2lvbnMoY20pXFxuICB0aGlzLmV2ZW50cyA9IFtdXFxufTtcXG5cXG5EaXNwbGF5VXBkYXRlLnByb3RvdHlwZS5zaWduYWwgPSBmdW5jdGlvbiAoZW1pdHRlciwgdHlwZSkge1xcbiAgaWYgKGhhc0hhbmRsZXIoZW1pdHRlciwgdHlwZSkpXFxuICAgIHsgdGhpcy5ldmVudHMucHVzaChhcmd1bWVudHMpIH1cXG59O1xcbkRpc3BsYXlVcGRhdGUucHJvdG90eXBlLmZpbmlzaCA9IGZ1bmN0aW9uICgpIHtcXG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XFxuXFxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZXZlbnRzLmxlbmd0aDsgaSsrKVxcbiAgICB7IHNpZ25hbC5hcHBseShudWxsLCB0aGlzJDEuZXZlbnRzW2ldKSB9XFxufTtcXG5cXG5mdW5jdGlvbiBtYXliZUNsaXBTY3JvbGxiYXJzKGNtKSB7XFxuICB2YXIgZGlzcGxheSA9IGNtLmRpc3BsYXlcXG4gIGlmICghZGlzcGxheS5zY3JvbGxiYXJzQ2xpcHBlZCAmJiBkaXNwbGF5LnNjcm9sbGVyLm9mZnNldFdpZHRoKSB7XFxuICAgIGRpc3BsYXkubmF0aXZlQmFyV2lkdGggPSBkaXNwbGF5LnNjcm9sbGVyLm9mZnNldFdpZHRoIC0gZGlzcGxheS5zY3JvbGxlci5jbGllbnRXaWR0aFxcbiAgICBkaXNwbGF5LmhlaWdodEZvcmNlci5zdHlsZS5oZWlnaHQgPSBzY3JvbGxHYXAoY20pICsgXFxcInB4XFxcIlxcbiAgICBkaXNwbGF5LnNpemVyLnN0eWxlLm1hcmdpbkJvdHRvbSA9IC1kaXNwbGF5Lm5hdGl2ZUJhcldpZHRoICsgXFxcInB4XFxcIlxcbiAgICBkaXNwbGF5LnNpemVyLnN0eWxlLmJvcmRlclJpZ2h0V2lkdGggPSBzY3JvbGxHYXAoY20pICsgXFxcInB4XFxcIlxcbiAgICBkaXNwbGF5LnNjcm9sbGJhcnNDbGlwcGVkID0gdHJ1ZVxcbiAgfVxcbn1cXG5cXG4vLyBEb2VzIHRoZSBhY3R1YWwgdXBkYXRpbmcgb2YgdGhlIGxpbmUgZGlzcGxheS4gQmFpbHMgb3V0XFxuLy8gKHJldHVybmluZyBmYWxzZSkgd2hlbiB0aGVyZSBpcyBub3RoaW5nIHRvIGJlIGRvbmUgYW5kIGZvcmNlZCBpc1xcbi8vIGZhbHNlLlxcbmZ1bmN0aW9uIHVwZGF0ZURpc3BsYXlJZk5lZWRlZChjbSwgdXBkYXRlKSB7XFxuICB2YXIgZGlzcGxheSA9IGNtLmRpc3BsYXksIGRvYyA9IGNtLmRvY1xcblxcbiAgaWYgKHVwZGF0ZS5lZGl0b3JJc0hpZGRlbikge1xcbiAgICByZXNldFZpZXcoY20pXFxuICAgIHJldHVybiBmYWxzZVxcbiAgfVxcblxcbiAgLy8gQmFpbCBvdXQgaWYgdGhlIHZpc2libGUgYXJlYSBpcyBhbHJlYWR5IHJlbmRlcmVkIGFuZCBub3RoaW5nIGNoYW5nZWQuXFxuICBpZiAoIXVwZGF0ZS5mb3JjZSAmJlxcbiAgICAgIHVwZGF0ZS52aXNpYmxlLmZyb20gPj0gZGlzcGxheS52aWV3RnJvbSAmJiB1cGRhdGUudmlzaWJsZS50byA8PSBkaXNwbGF5LnZpZXdUbyAmJlxcbiAgICAgIChkaXNwbGF5LnVwZGF0ZUxpbmVOdW1iZXJzID09IG51bGwgfHwgZGlzcGxheS51cGRhdGVMaW5lTnVtYmVycyA+PSBkaXNwbGF5LnZpZXdUbykgJiZcXG4gICAgICBkaXNwbGF5LnJlbmRlcmVkVmlldyA9PSBkaXNwbGF5LnZpZXcgJiYgY291bnREaXJ0eVZpZXcoY20pID09IDApXFxuICAgIHsgcmV0dXJuIGZhbHNlIH1cXG5cXG4gIGlmIChtYXliZVVwZGF0ZUxpbmVOdW1iZXJXaWR0aChjbSkpIHtcXG4gICAgcmVzZXRWaWV3KGNtKVxcbiAgICB1cGRhdGUuZGltcyA9IGdldERpbWVuc2lvbnMoY20pXFxuICB9XFxuXFxuICAvLyBDb21wdXRlIGEgc3VpdGFibGUgbmV3IHZpZXdwb3J0IChmcm9tICYgdG8pXFxuICB2YXIgZW5kID0gZG9jLmZpcnN0ICsgZG9jLnNpemVcXG4gIHZhciBmcm9tID0gTWF0aC5tYXgodXBkYXRlLnZpc2libGUuZnJvbSAtIGNtLm9wdGlvbnMudmlld3BvcnRNYXJnaW4sIGRvYy5maXJzdClcXG4gIHZhciB0byA9IE1hdGgubWluKGVuZCwgdXBkYXRlLnZpc2libGUudG8gKyBjbS5vcHRpb25zLnZpZXdwb3J0TWFyZ2luKVxcbiAgaWYgKGRpc3BsYXkudmlld0Zyb20gPCBmcm9tICYmIGZyb20gLSBkaXNwbGF5LnZpZXdGcm9tIDwgMjApIHsgZnJvbSA9IE1hdGgubWF4KGRvYy5maXJzdCwgZGlzcGxheS52aWV3RnJvbSkgfVxcbiAgaWYgKGRpc3BsYXkudmlld1RvID4gdG8gJiYgZGlzcGxheS52aWV3VG8gLSB0byA8IDIwKSB7IHRvID0gTWF0aC5taW4oZW5kLCBkaXNwbGF5LnZpZXdUbykgfVxcbiAgaWYgKHNhd0NvbGxhcHNlZFNwYW5zKSB7XFxuICAgIGZyb20gPSB2aXN1YWxMaW5lTm8oY20uZG9jLCBmcm9tKVxcbiAgICB0byA9IHZpc3VhbExpbmVFbmRObyhjbS5kb2MsIHRvKVxcbiAgfVxcblxcbiAgdmFyIGRpZmZlcmVudCA9IGZyb20gIT0gZGlzcGxheS52aWV3RnJvbSB8fCB0byAhPSBkaXNwbGF5LnZpZXdUbyB8fFxcbiAgICBkaXNwbGF5Lmxhc3RXcmFwSGVpZ2h0ICE9IHVwZGF0ZS53cmFwcGVySGVpZ2h0IHx8IGRpc3BsYXkubGFzdFdyYXBXaWR0aCAhPSB1cGRhdGUud3JhcHBlcldpZHRoXFxuICBhZGp1c3RWaWV3KGNtLCBmcm9tLCB0bylcXG5cXG4gIGRpc3BsYXkudmlld09mZnNldCA9IGhlaWdodEF0TGluZShnZXRMaW5lKGNtLmRvYywgZGlzcGxheS52aWV3RnJvbSkpXFxuICAvLyBQb3NpdGlvbiB0aGUgbW92ZXIgZGl2IHRvIGFsaWduIHdpdGggdGhlIGN1cnJlbnQgc2Nyb2xsIHBvc2l0aW9uXFxuICBjbS5kaXNwbGF5Lm1vdmVyLnN0eWxlLnRvcCA9IGRpc3BsYXkudmlld09mZnNldCArIFxcXCJweFxcXCJcXG5cXG4gIHZhciB0b1VwZGF0ZSA9IGNvdW50RGlydHlWaWV3KGNtKVxcbiAgaWYgKCFkaWZmZXJlbnQgJiYgdG9VcGRhdGUgPT0gMCAmJiAhdXBkYXRlLmZvcmNlICYmIGRpc3BsYXkucmVuZGVyZWRWaWV3ID09IGRpc3BsYXkudmlldyAmJlxcbiAgICAgIChkaXNwbGF5LnVwZGF0ZUxpbmVOdW1iZXJzID09IG51bGwgfHwgZGlzcGxheS51cGRhdGVMaW5lTnVtYmVycyA+PSBkaXNwbGF5LnZpZXdUbykpXFxuICAgIHsgcmV0dXJuIGZhbHNlIH1cXG5cXG4gIC8vIEZvciBiaWcgY2hhbmdlcywgd2UgaGlkZSB0aGUgZW5jbG9zaW5nIGVsZW1lbnQgZHVyaW5nIHRoZVxcbiAgLy8gdXBkYXRlLCBzaW5jZSB0aGF0IHNwZWVkcyB1cCB0aGUgb3BlcmF0aW9ucyBvbiBtb3N0IGJyb3dzZXJzLlxcbiAgdmFyIGZvY3VzZWQgPSBhY3RpdmVFbHQoKVxcbiAgaWYgKHRvVXBkYXRlID4gNCkgeyBkaXNwbGF5LmxpbmVEaXYuc3R5bGUuZGlzcGxheSA9IFxcXCJub25lXFxcIiB9XFxuICBwYXRjaERpc3BsYXkoY20sIGRpc3BsYXkudXBkYXRlTGluZU51bWJlcnMsIHVwZGF0ZS5kaW1zKVxcbiAgaWYgKHRvVXBkYXRlID4gNCkgeyBkaXNwbGF5LmxpbmVEaXYuc3R5bGUuZGlzcGxheSA9IFxcXCJcXFwiIH1cXG4gIGRpc3BsYXkucmVuZGVyZWRWaWV3ID0gZGlzcGxheS52aWV3XFxuICAvLyBUaGVyZSBtaWdodCBoYXZlIGJlZW4gYSB3aWRnZXQgd2l0aCBhIGZvY3VzZWQgZWxlbWVudCB0aGF0IGdvdFxcbiAgLy8gaGlkZGVuIG9yIHVwZGF0ZWQsIGlmIHNvIHJlLWZvY3VzIGl0LlxcbiAgaWYgKGZvY3VzZWQgJiYgYWN0aXZlRWx0KCkgIT0gZm9jdXNlZCAmJiBmb2N1c2VkLm9mZnNldEhlaWdodCkgeyBmb2N1c2VkLmZvY3VzKCkgfVxcblxcbiAgLy8gUHJldmVudCBzZWxlY3Rpb24gYW5kIGN1cnNvcnMgZnJvbSBpbnRlcmZlcmluZyB3aXRoIHRoZSBzY3JvbGxcXG4gIC8vIHdpZHRoIGFuZCBoZWlnaHQuXFxuICByZW1vdmVDaGlsZHJlbihkaXNwbGF5LmN1cnNvckRpdilcXG4gIHJlbW92ZUNoaWxkcmVuKGRpc3BsYXkuc2VsZWN0aW9uRGl2KVxcbiAgZGlzcGxheS5ndXR0ZXJzLnN0eWxlLmhlaWdodCA9IGRpc3BsYXkuc2l6ZXIuc3R5bGUubWluSGVpZ2h0ID0gMFxcblxcbiAgaWYgKGRpZmZlcmVudCkge1xcbiAgICBkaXNwbGF5Lmxhc3RXcmFwSGVpZ2h0ID0gdXBkYXRlLndyYXBwZXJIZWlnaHRcXG4gICAgZGlzcGxheS5sYXN0V3JhcFdpZHRoID0gdXBkYXRlLndyYXBwZXJXaWR0aFxcbiAgICBzdGFydFdvcmtlcihjbSwgNDAwKVxcbiAgfVxcblxcbiAgZGlzcGxheS51cGRhdGVMaW5lTnVtYmVycyA9IG51bGxcXG5cXG4gIHJldHVybiB0cnVlXFxufVxcblxcbmZ1bmN0aW9uIHBvc3RVcGRhdGVEaXNwbGF5KGNtLCB1cGRhdGUpIHtcXG4gIHZhciB2aWV3cG9ydCA9IHVwZGF0ZS52aWV3cG9ydFxcblxcbiAgZm9yICh2YXIgZmlyc3QgPSB0cnVlOzsgZmlyc3QgPSBmYWxzZSkge1xcbiAgICBpZiAoIWZpcnN0IHx8ICFjbS5vcHRpb25zLmxpbmVXcmFwcGluZyB8fCB1cGRhdGUub2xkRGlzcGxheVdpZHRoID09IGRpc3BsYXlXaWR0aChjbSkpIHtcXG4gICAgICAvLyBDbGlwIGZvcmNlZCB2aWV3cG9ydCB0byBhY3R1YWwgc2Nyb2xsYWJsZSBhcmVhLlxcbiAgICAgIGlmICh2aWV3cG9ydCAmJiB2aWV3cG9ydC50b3AgIT0gbnVsbClcXG4gICAgICAgIHsgdmlld3BvcnQgPSB7dG9wOiBNYXRoLm1pbihjbS5kb2MuaGVpZ2h0ICsgcGFkZGluZ1ZlcnQoY20uZGlzcGxheSkgLSBkaXNwbGF5SGVpZ2h0KGNtKSwgdmlld3BvcnQudG9wKX0gfVxcbiAgICAgIC8vIFVwZGF0ZWQgbGluZSBoZWlnaHRzIG1pZ2h0IHJlc3VsdCBpbiB0aGUgZHJhd24gYXJlYSBub3RcXG4gICAgICAvLyBhY3R1YWxseSBjb3ZlcmluZyB0aGUgdmlld3BvcnQuIEtlZXAgbG9vcGluZyB1bnRpbCBpdCBkb2VzLlxcbiAgICAgIHVwZGF0ZS52aXNpYmxlID0gdmlzaWJsZUxpbmVzKGNtLmRpc3BsYXksIGNtLmRvYywgdmlld3BvcnQpXFxuICAgICAgaWYgKHVwZGF0ZS52aXNpYmxlLmZyb20gPj0gY20uZGlzcGxheS52aWV3RnJvbSAmJiB1cGRhdGUudmlzaWJsZS50byA8PSBjbS5kaXNwbGF5LnZpZXdUbylcXG4gICAgICAgIHsgYnJlYWsgfVxcbiAgICB9XFxuICAgIGlmICghdXBkYXRlRGlzcGxheUlmTmVlZGVkKGNtLCB1cGRhdGUpKSB7IGJyZWFrIH1cXG4gICAgdXBkYXRlSGVpZ2h0c0luVmlld3BvcnQoY20pXFxuICAgIHZhciBiYXJNZWFzdXJlID0gbWVhc3VyZUZvclNjcm9sbGJhcnMoY20pXFxuICAgIHVwZGF0ZVNlbGVjdGlvbihjbSlcXG4gICAgdXBkYXRlU2Nyb2xsYmFycyhjbSwgYmFyTWVhc3VyZSlcXG4gICAgc2V0RG9jdW1lbnRIZWlnaHQoY20sIGJhck1lYXN1cmUpXFxuICB9XFxuXFxuICB1cGRhdGUuc2lnbmFsKGNtLCBcXFwidXBkYXRlXFxcIiwgY20pXFxuICBpZiAoY20uZGlzcGxheS52aWV3RnJvbSAhPSBjbS5kaXNwbGF5LnJlcG9ydGVkVmlld0Zyb20gfHwgY20uZGlzcGxheS52aWV3VG8gIT0gY20uZGlzcGxheS5yZXBvcnRlZFZpZXdUbykge1xcbiAgICB1cGRhdGUuc2lnbmFsKGNtLCBcXFwidmlld3BvcnRDaGFuZ2VcXFwiLCBjbSwgY20uZGlzcGxheS52aWV3RnJvbSwgY20uZGlzcGxheS52aWV3VG8pXFxuICAgIGNtLmRpc3BsYXkucmVwb3J0ZWRWaWV3RnJvbSA9IGNtLmRpc3BsYXkudmlld0Zyb207IGNtLmRpc3BsYXkucmVwb3J0ZWRWaWV3VG8gPSBjbS5kaXNwbGF5LnZpZXdUb1xcbiAgfVxcbn1cXG5cXG5mdW5jdGlvbiB1cGRhdGVEaXNwbGF5U2ltcGxlKGNtLCB2aWV3cG9ydCkge1xcbiAgdmFyIHVwZGF0ZSA9IG5ldyBEaXNwbGF5VXBkYXRlKGNtLCB2aWV3cG9ydClcXG4gIGlmICh1cGRhdGVEaXNwbGF5SWZOZWVkZWQoY20sIHVwZGF0ZSkpIHtcXG4gICAgdXBkYXRlSGVpZ2h0c0luVmlld3BvcnQoY20pXFxuICAgIHBvc3RVcGRhdGVEaXNwbGF5KGNtLCB1cGRhdGUpXFxuICAgIHZhciBiYXJNZWFzdXJlID0gbWVhc3VyZUZvclNjcm9sbGJhcnMoY20pXFxuICAgIHVwZGF0ZVNlbGVjdGlvbihjbSlcXG4gICAgdXBkYXRlU2Nyb2xsYmFycyhjbSwgYmFyTWVhc3VyZSlcXG4gICAgc2V0RG9jdW1lbnRIZWlnaHQoY20sIGJhck1lYXN1cmUpXFxuICAgIHVwZGF0ZS5maW5pc2goKVxcbiAgfVxcbn1cXG5cXG4vLyBTeW5jIHRoZSBhY3R1YWwgZGlzcGxheSBET00gc3RydWN0dXJlIHdpdGggZGlzcGxheS52aWV3LCByZW1vdmluZ1xcbi8vIG5vZGVzIGZvciBsaW5lcyB0aGF0IGFyZSBubyBsb25nZXIgaW4gdmlldywgYW5kIGNyZWF0aW5nIHRoZSBvbmVzXFxuLy8gdGhhdCBhcmUgbm90IHRoZXJlIHlldCwgYW5kIHVwZGF0aW5nIHRoZSBvbmVzIHRoYXQgYXJlIG91dCBvZlxcbi8vIGRhdGUuXFxuZnVuY3Rpb24gcGF0Y2hEaXNwbGF5KGNtLCB1cGRhdGVOdW1iZXJzRnJvbSwgZGltcykge1xcbiAgdmFyIGRpc3BsYXkgPSBjbS5kaXNwbGF5LCBsaW5lTnVtYmVycyA9IGNtLm9wdGlvbnMubGluZU51bWJlcnNcXG4gIHZhciBjb250YWluZXIgPSBkaXNwbGF5LmxpbmVEaXYsIGN1ciA9IGNvbnRhaW5lci5maXJzdENoaWxkXFxuXFxuICBmdW5jdGlvbiBybShub2RlKSB7XFxuICAgIHZhciBuZXh0ID0gbm9kZS5uZXh0U2libGluZ1xcbiAgICAvLyBXb3JrcyBhcm91bmQgYSB0aHJvdy1zY3JvbGwgYnVnIGluIE9TIFggV2Via2l0XFxuICAgIGlmICh3ZWJraXQgJiYgbWFjICYmIGNtLmRpc3BsYXkuY3VycmVudFdoZWVsVGFyZ2V0ID09IG5vZGUpXFxuICAgICAgeyBub2RlLnN0eWxlLmRpc3BsYXkgPSBcXFwibm9uZVxcXCIgfVxcbiAgICBlbHNlXFxuICAgICAgeyBub2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobm9kZSkgfVxcbiAgICByZXR1cm4gbmV4dFxcbiAgfVxcblxcbiAgdmFyIHZpZXcgPSBkaXNwbGF5LnZpZXcsIGxpbmVOID0gZGlzcGxheS52aWV3RnJvbVxcbiAgLy8gTG9vcCBvdmVyIHRoZSBlbGVtZW50cyBpbiB0aGUgdmlldywgc3luY2luZyBjdXIgKHRoZSBET00gbm9kZXNcXG4gIC8vIGluIGRpc3BsYXkubGluZURpdikgd2l0aCB0aGUgdmlldyBhcyB3ZSBnby5cXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdmlldy5sZW5ndGg7IGkrKykge1xcbiAgICB2YXIgbGluZVZpZXcgPSB2aWV3W2ldXFxuICAgIGlmIChsaW5lVmlldy5oaWRkZW4pIHtcXG4gICAgfSBlbHNlIGlmICghbGluZVZpZXcubm9kZSB8fCBsaW5lVmlldy5ub2RlLnBhcmVudE5vZGUgIT0gY29udGFpbmVyKSB7IC8vIE5vdCBkcmF3biB5ZXRcXG4gICAgICB2YXIgbm9kZSA9IGJ1aWxkTGluZUVsZW1lbnQoY20sIGxpbmVWaWV3LCBsaW5lTiwgZGltcylcXG4gICAgICBjb250YWluZXIuaW5zZXJ0QmVmb3JlKG5vZGUsIGN1cilcXG4gICAgfSBlbHNlIHsgLy8gQWxyZWFkeSBkcmF3blxcbiAgICAgIHdoaWxlIChjdXIgIT0gbGluZVZpZXcubm9kZSkgeyBjdXIgPSBybShjdXIpIH1cXG4gICAgICB2YXIgdXBkYXRlTnVtYmVyID0gbGluZU51bWJlcnMgJiYgdXBkYXRlTnVtYmVyc0Zyb20gIT0gbnVsbCAmJlxcbiAgICAgICAgdXBkYXRlTnVtYmVyc0Zyb20gPD0gbGluZU4gJiYgbGluZVZpZXcubGluZU51bWJlclxcbiAgICAgIGlmIChsaW5lVmlldy5jaGFuZ2VzKSB7XFxuICAgICAgICBpZiAoaW5kZXhPZihsaW5lVmlldy5jaGFuZ2VzLCBcXFwiZ3V0dGVyXFxcIikgPiAtMSkgeyB1cGRhdGVOdW1iZXIgPSBmYWxzZSB9XFxuICAgICAgICB1cGRhdGVMaW5lRm9yQ2hhbmdlcyhjbSwgbGluZVZpZXcsIGxpbmVOLCBkaW1zKVxcbiAgICAgIH1cXG4gICAgICBpZiAodXBkYXRlTnVtYmVyKSB7XFxuICAgICAgICByZW1vdmVDaGlsZHJlbihsaW5lVmlldy5saW5lTnVtYmVyKVxcbiAgICAgICAgbGluZVZpZXcubGluZU51bWJlci5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShsaW5lTnVtYmVyRm9yKGNtLm9wdGlvbnMsIGxpbmVOKSkpXFxuICAgICAgfVxcbiAgICAgIGN1ciA9IGxpbmVWaWV3Lm5vZGUubmV4dFNpYmxpbmdcXG4gICAgfVxcbiAgICBsaW5lTiArPSBsaW5lVmlldy5zaXplXFxuICB9XFxuICB3aGlsZSAoY3VyKSB7IGN1ciA9IHJtKGN1cikgfVxcbn1cXG5cXG5mdW5jdGlvbiB1cGRhdGVHdXR0ZXJTcGFjZShjbSkge1xcbiAgdmFyIHdpZHRoID0gY20uZGlzcGxheS5ndXR0ZXJzLm9mZnNldFdpZHRoXFxuICBjbS5kaXNwbGF5LnNpemVyLnN0eWxlLm1hcmdpbkxlZnQgPSB3aWR0aCArIFxcXCJweFxcXCJcXG59XFxuXFxuZnVuY3Rpb24gc2V0RG9jdW1lbnRIZWlnaHQoY20sIG1lYXN1cmUpIHtcXG4gIGNtLmRpc3BsYXkuc2l6ZXIuc3R5bGUubWluSGVpZ2h0ID0gbWVhc3VyZS5kb2NIZWlnaHQgKyBcXFwicHhcXFwiXFxuICBjbS5kaXNwbGF5LmhlaWdodEZvcmNlci5zdHlsZS50b3AgPSBtZWFzdXJlLmRvY0hlaWdodCArIFxcXCJweFxcXCJcXG4gIGNtLmRpc3BsYXkuZ3V0dGVycy5zdHlsZS5oZWlnaHQgPSAobWVhc3VyZS5kb2NIZWlnaHQgKyBjbS5kaXNwbGF5LmJhckhlaWdodCArIHNjcm9sbEdhcChjbSkpICsgXFxcInB4XFxcIlxcbn1cXG5cXG4vLyBSZWJ1aWxkIHRoZSBndXR0ZXIgZWxlbWVudHMsIGVuc3VyZSB0aGUgbWFyZ2luIHRvIHRoZSBsZWZ0IG9mIHRoZVxcbi8vIGNvZGUgbWF0Y2hlcyB0aGVpciB3aWR0aC5cXG5mdW5jdGlvbiB1cGRhdGVHdXR0ZXJzKGNtKSB7XFxuICB2YXIgZ3V0dGVycyA9IGNtLmRpc3BsYXkuZ3V0dGVycywgc3BlY3MgPSBjbS5vcHRpb25zLmd1dHRlcnNcXG4gIHJlbW92ZUNoaWxkcmVuKGd1dHRlcnMpXFxuICB2YXIgaSA9IDBcXG4gIGZvciAoOyBpIDwgc3BlY3MubGVuZ3RoOyArK2kpIHtcXG4gICAgdmFyIGd1dHRlckNsYXNzID0gc3BlY3NbaV1cXG4gICAgdmFyIGdFbHQgPSBndXR0ZXJzLmFwcGVuZENoaWxkKGVsdChcXFwiZGl2XFxcIiwgbnVsbCwgXFxcIkNvZGVNaXJyb3ItZ3V0dGVyIFxcXCIgKyBndXR0ZXJDbGFzcykpXFxuICAgIGlmIChndXR0ZXJDbGFzcyA9PSBcXFwiQ29kZU1pcnJvci1saW5lbnVtYmVyc1xcXCIpIHtcXG4gICAgICBjbS5kaXNwbGF5LmxpbmVHdXR0ZXIgPSBnRWx0XFxuICAgICAgZ0VsdC5zdHlsZS53aWR0aCA9IChjbS5kaXNwbGF5LmxpbmVOdW1XaWR0aCB8fCAxKSArIFxcXCJweFxcXCJcXG4gICAgfVxcbiAgfVxcbiAgZ3V0dGVycy5zdHlsZS5kaXNwbGF5ID0gaSA/IFxcXCJcXFwiIDogXFxcIm5vbmVcXFwiXFxuICB1cGRhdGVHdXR0ZXJTcGFjZShjbSlcXG59XFxuXFxuLy8gTWFrZSBzdXJlIHRoZSBndXR0ZXJzIG9wdGlvbnMgY29udGFpbnMgdGhlIGVsZW1lbnRcXG4vLyBcXFwiQ29kZU1pcnJvci1saW5lbnVtYmVyc1xcXCIgd2hlbiB0aGUgbGluZU51bWJlcnMgb3B0aW9uIGlzIHRydWUuXFxuZnVuY3Rpb24gc2V0R3V0dGVyc0ZvckxpbmVOdW1iZXJzKG9wdGlvbnMpIHtcXG4gIHZhciBmb3VuZCA9IGluZGV4T2Yob3B0aW9ucy5ndXR0ZXJzLCBcXFwiQ29kZU1pcnJvci1saW5lbnVtYmVyc1xcXCIpXFxuICBpZiAoZm91bmQgPT0gLTEgJiYgb3B0aW9ucy5saW5lTnVtYmVycykge1xcbiAgICBvcHRpb25zLmd1dHRlcnMgPSBvcHRpb25zLmd1dHRlcnMuY29uY2F0KFtcXFwiQ29kZU1pcnJvci1saW5lbnVtYmVyc1xcXCJdKVxcbiAgfSBlbHNlIGlmIChmb3VuZCA+IC0xICYmICFvcHRpb25zLmxpbmVOdW1iZXJzKSB7XFxuICAgIG9wdGlvbnMuZ3V0dGVycyA9IG9wdGlvbnMuZ3V0dGVycy5zbGljZSgwKVxcbiAgICBvcHRpb25zLmd1dHRlcnMuc3BsaWNlKGZvdW5kLCAxKVxcbiAgfVxcbn1cXG5cXG4vLyBTZWxlY3Rpb24gb2JqZWN0cyBhcmUgaW1tdXRhYmxlLiBBIG5ldyBvbmUgaXMgY3JlYXRlZCBldmVyeSB0aW1lXFxuLy8gdGhlIHNlbGVjdGlvbiBjaGFuZ2VzLiBBIHNlbGVjdGlvbiBpcyBvbmUgb3IgbW9yZSBub24tb3ZlcmxhcHBpbmdcXG4vLyAoYW5kIG5vbi10b3VjaGluZykgcmFuZ2VzLCBzb3J0ZWQsIGFuZCBhbiBpbnRlZ2VyIHRoYXQgaW5kaWNhdGVzXFxuLy8gd2hpY2ggb25lIGlzIHRoZSBwcmltYXJ5IHNlbGVjdGlvbiAodGhlIG9uZSB0aGF0J3Mgc2Nyb2xsZWQgaW50b1xcbi8vIHZpZXcsIHRoYXQgZ2V0Q3Vyc29yIHJldHVybnMsIGV0YykuXFxudmFyIFNlbGVjdGlvbiA9IGZ1bmN0aW9uKHJhbmdlcywgcHJpbUluZGV4KSB7XFxuICB0aGlzLnJhbmdlcyA9IHJhbmdlc1xcbiAgdGhpcy5wcmltSW5kZXggPSBwcmltSW5kZXhcXG59O1xcblxcblNlbGVjdGlvbi5wcm90b3R5cGUucHJpbWFyeSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMucmFuZ2VzW3RoaXMucHJpbUluZGV4XSB9O1xcblxcblNlbGVjdGlvbi5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gKG90aGVyKSB7XFxuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xcblxcbiAgaWYgKG90aGVyID09IHRoaXMpIHsgcmV0dXJuIHRydWUgfVxcbiAgaWYgKG90aGVyLnByaW1JbmRleCAhPSB0aGlzLnByaW1JbmRleCB8fCBvdGhlci5yYW5nZXMubGVuZ3RoICE9IHRoaXMucmFuZ2VzLmxlbmd0aCkgeyByZXR1cm4gZmFsc2UgfVxcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnJhbmdlcy5sZW5ndGg7IGkrKykge1xcbiAgICB2YXIgaGVyZSA9IHRoaXMkMS5yYW5nZXNbaV0sIHRoZXJlID0gb3RoZXIucmFuZ2VzW2ldXFxuICAgIGlmICghZXF1YWxDdXJzb3JQb3MoaGVyZS5hbmNob3IsIHRoZXJlLmFuY2hvcikgfHwgIWVxdWFsQ3Vyc29yUG9zKGhlcmUuaGVhZCwgdGhlcmUuaGVhZCkpIHsgcmV0dXJuIGZhbHNlIH1cXG4gIH1cXG4gIHJldHVybiB0cnVlXFxufTtcXG5cXG5TZWxlY3Rpb24ucHJvdG90eXBlLmRlZXBDb3B5ID0gZnVuY3Rpb24gKCkge1xcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcXG5cXG4gIHZhciBvdXQgPSBbXVxcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnJhbmdlcy5sZW5ndGg7IGkrKylcXG4gICAgeyBvdXRbaV0gPSBuZXcgUmFuZ2UoY29weVBvcyh0aGlzJDEucmFuZ2VzW2ldLmFuY2hvciksIGNvcHlQb3ModGhpcyQxLnJhbmdlc1tpXS5oZWFkKSkgfVxcbiAgcmV0dXJuIG5ldyBTZWxlY3Rpb24ob3V0LCB0aGlzLnByaW1JbmRleClcXG59O1xcblxcblNlbGVjdGlvbi5wcm90b3R5cGUuc29tZXRoaW5nU2VsZWN0ZWQgPSBmdW5jdGlvbiAoKSB7XFxuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xcblxcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnJhbmdlcy5sZW5ndGg7IGkrKylcXG4gICAgeyBpZiAoIXRoaXMkMS5yYW5nZXNbaV0uZW1wdHkoKSkgeyByZXR1cm4gdHJ1ZSB9IH1cXG4gIHJldHVybiBmYWxzZVxcbn07XFxuXFxuU2VsZWN0aW9uLnByb3RvdHlwZS5jb250YWlucyA9IGZ1bmN0aW9uIChwb3MsIGVuZCkge1xcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcXG5cXG4gIGlmICghZW5kKSB7IGVuZCA9IHBvcyB9XFxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucmFuZ2VzLmxlbmd0aDsgaSsrKSB7XFxuICAgIHZhciByYW5nZSA9IHRoaXMkMS5yYW5nZXNbaV1cXG4gICAgaWYgKGNtcChlbmQsIHJhbmdlLmZyb20oKSkgPj0gMCAmJiBjbXAocG9zLCByYW5nZS50bygpKSA8PSAwKVxcbiAgICAgIHsgcmV0dXJuIGkgfVxcbiAgfVxcbiAgcmV0dXJuIC0xXFxufTtcXG5cXG52YXIgUmFuZ2UgPSBmdW5jdGlvbihhbmNob3IsIGhlYWQpIHtcXG4gIHRoaXMuYW5jaG9yID0gYW5jaG9yOyB0aGlzLmhlYWQgPSBoZWFkXFxufTtcXG5cXG5SYW5nZS5wcm90b3R5cGUuZnJvbSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1pblBvcyh0aGlzLmFuY2hvciwgdGhpcy5oZWFkKSB9O1xcblJhbmdlLnByb3RvdHlwZS50byA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1heFBvcyh0aGlzLmFuY2hvciwgdGhpcy5oZWFkKSB9O1xcblJhbmdlLnByb3RvdHlwZS5lbXB0eSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuaGVhZC5saW5lID09IHRoaXMuYW5jaG9yLmxpbmUgJiYgdGhpcy5oZWFkLmNoID09IHRoaXMuYW5jaG9yLmNoIH07XFxuXFxuLy8gVGFrZSBhbiB1bnNvcnRlZCwgcG90ZW50aWFsbHkgb3ZlcmxhcHBpbmcgc2V0IG9mIHJhbmdlcywgYW5kXFxuLy8gYnVpbGQgYSBzZWxlY3Rpb24gb3V0IG9mIGl0LiAnQ29uc3VtZXMnIHJhbmdlcyBhcnJheSAobW9kaWZ5aW5nXFxuLy8gaXQpLlxcbmZ1bmN0aW9uIG5vcm1hbGl6ZVNlbGVjdGlvbihyYW5nZXMsIHByaW1JbmRleCkge1xcbiAgdmFyIHByaW0gPSByYW5nZXNbcHJpbUluZGV4XVxcbiAgcmFuZ2VzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGNtcChhLmZyb20oKSwgYi5mcm9tKCkpOyB9KVxcbiAgcHJpbUluZGV4ID0gaW5kZXhPZihyYW5nZXMsIHByaW0pXFxuICBmb3IgKHZhciBpID0gMTsgaSA8IHJhbmdlcy5sZW5ndGg7IGkrKykge1xcbiAgICB2YXIgY3VyID0gcmFuZ2VzW2ldLCBwcmV2ID0gcmFuZ2VzW2kgLSAxXVxcbiAgICBpZiAoY21wKHByZXYudG8oKSwgY3VyLmZyb20oKSkgPj0gMCkge1xcbiAgICAgIHZhciBmcm9tID0gbWluUG9zKHByZXYuZnJvbSgpLCBjdXIuZnJvbSgpKSwgdG8gPSBtYXhQb3MocHJldi50bygpLCBjdXIudG8oKSlcXG4gICAgICB2YXIgaW52ID0gcHJldi5lbXB0eSgpID8gY3VyLmZyb20oKSA9PSBjdXIuaGVhZCA6IHByZXYuZnJvbSgpID09IHByZXYuaGVhZFxcbiAgICAgIGlmIChpIDw9IHByaW1JbmRleCkgeyAtLXByaW1JbmRleCB9XFxuICAgICAgcmFuZ2VzLnNwbGljZSgtLWksIDIsIG5ldyBSYW5nZShpbnYgPyB0byA6IGZyb20sIGludiA/IGZyb20gOiB0bykpXFxuICAgIH1cXG4gIH1cXG4gIHJldHVybiBuZXcgU2VsZWN0aW9uKHJhbmdlcywgcHJpbUluZGV4KVxcbn1cXG5cXG5mdW5jdGlvbiBzaW1wbGVTZWxlY3Rpb24oYW5jaG9yLCBoZWFkKSB7XFxuICByZXR1cm4gbmV3IFNlbGVjdGlvbihbbmV3IFJhbmdlKGFuY2hvciwgaGVhZCB8fCBhbmNob3IpXSwgMClcXG59XFxuXFxuLy8gQ29tcHV0ZSB0aGUgcG9zaXRpb24gb2YgdGhlIGVuZCBvZiBhIGNoYW5nZSAoaXRzICd0bycgcHJvcGVydHlcXG4vLyByZWZlcnMgdG8gdGhlIHByZS1jaGFuZ2UgZW5kKS5cXG5mdW5jdGlvbiBjaGFuZ2VFbmQoY2hhbmdlKSB7XFxuICBpZiAoIWNoYW5nZS50ZXh0KSB7IHJldHVybiBjaGFuZ2UudG8gfVxcbiAgcmV0dXJuIFBvcyhjaGFuZ2UuZnJvbS5saW5lICsgY2hhbmdlLnRleHQubGVuZ3RoIC0gMSxcXG4gICAgICAgICAgICAgbHN0KGNoYW5nZS50ZXh0KS5sZW5ndGggKyAoY2hhbmdlLnRleHQubGVuZ3RoID09IDEgPyBjaGFuZ2UuZnJvbS5jaCA6IDApKVxcbn1cXG5cXG4vLyBBZGp1c3QgYSBwb3NpdGlvbiB0byByZWZlciB0byB0aGUgcG9zdC1jaGFuZ2UgcG9zaXRpb24gb2YgdGhlXFxuLy8gc2FtZSB0ZXh0LCBvciB0aGUgZW5kIG9mIHRoZSBjaGFuZ2UgaWYgdGhlIGNoYW5nZSBjb3ZlcnMgaXQuXFxuZnVuY3Rpb24gYWRqdXN0Rm9yQ2hhbmdlKHBvcywgY2hhbmdlKSB7XFxuICBpZiAoY21wKHBvcywgY2hhbmdlLmZyb20pIDwgMCkgeyByZXR1cm4gcG9zIH1cXG4gIGlmIChjbXAocG9zLCBjaGFuZ2UudG8pIDw9IDApIHsgcmV0dXJuIGNoYW5nZUVuZChjaGFuZ2UpIH1cXG5cXG4gIHZhciBsaW5lID0gcG9zLmxpbmUgKyBjaGFuZ2UudGV4dC5sZW5ndGggLSAoY2hhbmdlLnRvLmxpbmUgLSBjaGFuZ2UuZnJvbS5saW5lKSAtIDEsIGNoID0gcG9zLmNoXFxuICBpZiAocG9zLmxpbmUgPT0gY2hhbmdlLnRvLmxpbmUpIHsgY2ggKz0gY2hhbmdlRW5kKGNoYW5nZSkuY2ggLSBjaGFuZ2UudG8uY2ggfVxcbiAgcmV0dXJuIFBvcyhsaW5lLCBjaClcXG59XFxuXFxuZnVuY3Rpb24gY29tcHV0ZVNlbEFmdGVyQ2hhbmdlKGRvYywgY2hhbmdlKSB7XFxuICB2YXIgb3V0ID0gW11cXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZG9jLnNlbC5yYW5nZXMubGVuZ3RoOyBpKyspIHtcXG4gICAgdmFyIHJhbmdlID0gZG9jLnNlbC5yYW5nZXNbaV1cXG4gICAgb3V0LnB1c2gobmV3IFJhbmdlKGFkanVzdEZvckNoYW5nZShyYW5nZS5hbmNob3IsIGNoYW5nZSksXFxuICAgICAgICAgICAgICAgICAgICAgICBhZGp1c3RGb3JDaGFuZ2UocmFuZ2UuaGVhZCwgY2hhbmdlKSkpXFxuICB9XFxuICByZXR1cm4gbm9ybWFsaXplU2VsZWN0aW9uKG91dCwgZG9jLnNlbC5wcmltSW5kZXgpXFxufVxcblxcbmZ1bmN0aW9uIG9mZnNldFBvcyhwb3MsIG9sZCwgbncpIHtcXG4gIGlmIChwb3MubGluZSA9PSBvbGQubGluZSlcXG4gICAgeyByZXR1cm4gUG9zKG53LmxpbmUsIHBvcy5jaCAtIG9sZC5jaCArIG53LmNoKSB9XFxuICBlbHNlXFxuICAgIHsgcmV0dXJuIFBvcyhudy5saW5lICsgKHBvcy5saW5lIC0gb2xkLmxpbmUpLCBwb3MuY2gpIH1cXG59XFxuXFxuLy8gVXNlZCBieSByZXBsYWNlU2VsZWN0aW9ucyB0byBhbGxvdyBtb3ZpbmcgdGhlIHNlbGVjdGlvbiB0byB0aGVcXG4vLyBzdGFydCBvciBhcm91bmQgdGhlIHJlcGxhY2VkIHRlc3QuIEhpbnQgbWF5IGJlIFxcXCJzdGFydFxcXCIgb3IgXFxcImFyb3VuZFxcXCIuXFxuZnVuY3Rpb24gY29tcHV0ZVJlcGxhY2VkU2VsKGRvYywgY2hhbmdlcywgaGludCkge1xcbiAgdmFyIG91dCA9IFtdXFxuICB2YXIgb2xkUHJldiA9IFBvcyhkb2MuZmlyc3QsIDApLCBuZXdQcmV2ID0gb2xkUHJldlxcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGFuZ2VzLmxlbmd0aDsgaSsrKSB7XFxuICAgIHZhciBjaGFuZ2UgPSBjaGFuZ2VzW2ldXFxuICAgIHZhciBmcm9tID0gb2Zmc2V0UG9zKGNoYW5nZS5mcm9tLCBvbGRQcmV2LCBuZXdQcmV2KVxcbiAgICB2YXIgdG8gPSBvZmZzZXRQb3MoY2hhbmdlRW5kKGNoYW5nZSksIG9sZFByZXYsIG5ld1ByZXYpXFxuICAgIG9sZFByZXYgPSBjaGFuZ2UudG9cXG4gICAgbmV3UHJldiA9IHRvXFxuICAgIGlmIChoaW50ID09IFxcXCJhcm91bmRcXFwiKSB7XFxuICAgICAgdmFyIHJhbmdlID0gZG9jLnNlbC5yYW5nZXNbaV0sIGludiA9IGNtcChyYW5nZS5oZWFkLCByYW5nZS5hbmNob3IpIDwgMFxcbiAgICAgIG91dFtpXSA9IG5ldyBSYW5nZShpbnYgPyB0byA6IGZyb20sIGludiA/IGZyb20gOiB0bylcXG4gICAgfSBlbHNlIHtcXG4gICAgICBvdXRbaV0gPSBuZXcgUmFuZ2UoZnJvbSwgZnJvbSlcXG4gICAgfVxcbiAgfVxcbiAgcmV0dXJuIG5ldyBTZWxlY3Rpb24ob3V0LCBkb2Muc2VsLnByaW1JbmRleClcXG59XFxuXFxuLy8gVXNlZCB0byBnZXQgdGhlIGVkaXRvciBpbnRvIGEgY29uc2lzdGVudCBzdGF0ZSBhZ2FpbiB3aGVuIG9wdGlvbnMgY2hhbmdlLlxcblxcbmZ1bmN0aW9uIGxvYWRNb2RlKGNtKSB7XFxuICBjbS5kb2MubW9kZSA9IGdldE1vZGUoY20ub3B0aW9ucywgY20uZG9jLm1vZGVPcHRpb24pXFxuICByZXNldE1vZGVTdGF0ZShjbSlcXG59XFxuXFxuZnVuY3Rpb24gcmVzZXRNb2RlU3RhdGUoY20pIHtcXG4gIGNtLmRvYy5pdGVyKGZ1bmN0aW9uIChsaW5lKSB7XFxuICAgIGlmIChsaW5lLnN0YXRlQWZ0ZXIpIHsgbGluZS5zdGF0ZUFmdGVyID0gbnVsbCB9XFxuICAgIGlmIChsaW5lLnN0eWxlcykgeyBsaW5lLnN0eWxlcyA9IG51bGwgfVxcbiAgfSlcXG4gIGNtLmRvYy5mcm9udGllciA9IGNtLmRvYy5maXJzdFxcbiAgc3RhcnRXb3JrZXIoY20sIDEwMClcXG4gIGNtLnN0YXRlLm1vZGVHZW4rK1xcbiAgaWYgKGNtLmN1ck9wKSB7IHJlZ0NoYW5nZShjbSkgfVxcbn1cXG5cXG4vLyBET0NVTUVOVCBEQVRBIFNUUlVDVFVSRVxcblxcbi8vIEJ5IGRlZmF1bHQsIHVwZGF0ZXMgdGhhdCBzdGFydCBhbmQgZW5kIGF0IHRoZSBiZWdpbm5pbmcgb2YgYSBsaW5lXFxuLy8gYXJlIHRyZWF0ZWQgc3BlY2lhbGx5LCBpbiBvcmRlciB0byBtYWtlIHRoZSBhc3NvY2lhdGlvbiBvZiBsaW5lXFxuLy8gd2lkZ2V0cyBhbmQgbWFya2VyIGVsZW1lbnRzIHdpdGggdGhlIHRleHQgYmVoYXZlIG1vcmUgaW50dWl0aXZlLlxcbmZ1bmN0aW9uIGlzV2hvbGVMaW5lVXBkYXRlKGRvYywgY2hhbmdlKSB7XFxuICByZXR1cm4gY2hhbmdlLmZyb20uY2ggPT0gMCAmJiBjaGFuZ2UudG8uY2ggPT0gMCAmJiBsc3QoY2hhbmdlLnRleHQpID09IFxcXCJcXFwiICYmXFxuICAgICghZG9jLmNtIHx8IGRvYy5jbS5vcHRpb25zLndob2xlTGluZVVwZGF0ZUJlZm9yZSlcXG59XFxuXFxuLy8gUGVyZm9ybSBhIGNoYW5nZSBvbiB0aGUgZG9jdW1lbnQgZGF0YSBzdHJ1Y3R1cmUuXFxuZnVuY3Rpb24gdXBkYXRlRG9jKGRvYywgY2hhbmdlLCBtYXJrZWRTcGFucywgZXN0aW1hdGVIZWlnaHQpIHtcXG4gIGZ1bmN0aW9uIHNwYW5zRm9yKG4pIHtyZXR1cm4gbWFya2VkU3BhbnMgPyBtYXJrZWRTcGFuc1tuXSA6IG51bGx9XFxuICBmdW5jdGlvbiB1cGRhdGUobGluZSwgdGV4dCwgc3BhbnMpIHtcXG4gICAgdXBkYXRlTGluZShsaW5lLCB0ZXh0LCBzcGFucywgZXN0aW1hdGVIZWlnaHQpXFxuICAgIHNpZ25hbExhdGVyKGxpbmUsIFxcXCJjaGFuZ2VcXFwiLCBsaW5lLCBjaGFuZ2UpXFxuICB9XFxuICBmdW5jdGlvbiBsaW5lc0ZvcihzdGFydCwgZW5kKSB7XFxuICAgIHZhciByZXN1bHQgPSBbXVxcbiAgICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSlcXG4gICAgICB7IHJlc3VsdC5wdXNoKG5ldyBMaW5lKHRleHRbaV0sIHNwYW5zRm9yKGkpLCBlc3RpbWF0ZUhlaWdodCkpIH1cXG4gICAgcmV0dXJuIHJlc3VsdFxcbiAgfVxcblxcbiAgdmFyIGZyb20gPSBjaGFuZ2UuZnJvbSwgdG8gPSBjaGFuZ2UudG8sIHRleHQgPSBjaGFuZ2UudGV4dFxcbiAgdmFyIGZpcnN0TGluZSA9IGdldExpbmUoZG9jLCBmcm9tLmxpbmUpLCBsYXN0TGluZSA9IGdldExpbmUoZG9jLCB0by5saW5lKVxcbiAgdmFyIGxhc3RUZXh0ID0gbHN0KHRleHQpLCBsYXN0U3BhbnMgPSBzcGFuc0Zvcih0ZXh0Lmxlbmd0aCAtIDEpLCBubGluZXMgPSB0by5saW5lIC0gZnJvbS5saW5lXFxuXFxuICAvLyBBZGp1c3QgdGhlIGxpbmUgc3RydWN0dXJlXFxuICBpZiAoY2hhbmdlLmZ1bGwpIHtcXG4gICAgZG9jLmluc2VydCgwLCBsaW5lc0ZvcigwLCB0ZXh0Lmxlbmd0aCkpXFxuICAgIGRvYy5yZW1vdmUodGV4dC5sZW5ndGgsIGRvYy5zaXplIC0gdGV4dC5sZW5ndGgpXFxuICB9IGVsc2UgaWYgKGlzV2hvbGVMaW5lVXBkYXRlKGRvYywgY2hhbmdlKSkge1xcbiAgICAvLyBUaGlzIGlzIGEgd2hvbGUtbGluZSByZXBsYWNlLiBUcmVhdGVkIHNwZWNpYWxseSB0byBtYWtlXFxuICAgIC8vIHN1cmUgbGluZSBvYmplY3RzIG1vdmUgdGhlIHdheSB0aGV5IGFyZSBzdXBwb3NlZCB0by5cXG4gICAgdmFyIGFkZGVkID0gbGluZXNGb3IoMCwgdGV4dC5sZW5ndGggLSAxKVxcbiAgICB1cGRhdGUobGFzdExpbmUsIGxhc3RMaW5lLnRleHQsIGxhc3RTcGFucylcXG4gICAgaWYgKG5saW5lcykgeyBkb2MucmVtb3ZlKGZyb20ubGluZSwgbmxpbmVzKSB9XFxuICAgIGlmIChhZGRlZC5sZW5ndGgpIHsgZG9jLmluc2VydChmcm9tLmxpbmUsIGFkZGVkKSB9XFxuICB9IGVsc2UgaWYgKGZpcnN0TGluZSA9PSBsYXN0TGluZSkge1xcbiAgICBpZiAodGV4dC5sZW5ndGggPT0gMSkge1xcbiAgICAgIHVwZGF0ZShmaXJzdExpbmUsIGZpcnN0TGluZS50ZXh0LnNsaWNlKDAsIGZyb20uY2gpICsgbGFzdFRleHQgKyBmaXJzdExpbmUudGV4dC5zbGljZSh0by5jaCksIGxhc3RTcGFucylcXG4gICAgfSBlbHNlIHtcXG4gICAgICB2YXIgYWRkZWQkMSA9IGxpbmVzRm9yKDEsIHRleHQubGVuZ3RoIC0gMSlcXG4gICAgICBhZGRlZCQxLnB1c2gobmV3IExpbmUobGFzdFRleHQgKyBmaXJzdExpbmUudGV4dC5zbGljZSh0by5jaCksIGxhc3RTcGFucywgZXN0aW1hdGVIZWlnaHQpKVxcbiAgICAgIHVwZGF0ZShmaXJzdExpbmUsIGZpcnN0TGluZS50ZXh0LnNsaWNlKDAsIGZyb20uY2gpICsgdGV4dFswXSwgc3BhbnNGb3IoMCkpXFxuICAgICAgZG9jLmluc2VydChmcm9tLmxpbmUgKyAxLCBhZGRlZCQxKVxcbiAgICB9XFxuICB9IGVsc2UgaWYgKHRleHQubGVuZ3RoID09IDEpIHtcXG4gICAgdXBkYXRlKGZpcnN0TGluZSwgZmlyc3RMaW5lLnRleHQuc2xpY2UoMCwgZnJvbS5jaCkgKyB0ZXh0WzBdICsgbGFzdExpbmUudGV4dC5zbGljZSh0by5jaCksIHNwYW5zRm9yKDApKVxcbiAgICBkb2MucmVtb3ZlKGZyb20ubGluZSArIDEsIG5saW5lcylcXG4gIH0gZWxzZSB7XFxuICAgIHVwZGF0ZShmaXJzdExpbmUsIGZpcnN0TGluZS50ZXh0LnNsaWNlKDAsIGZyb20uY2gpICsgdGV4dFswXSwgc3BhbnNGb3IoMCkpXFxuICAgIHVwZGF0ZShsYXN0TGluZSwgbGFzdFRleHQgKyBsYXN0TGluZS50ZXh0LnNsaWNlKHRvLmNoKSwgbGFzdFNwYW5zKVxcbiAgICB2YXIgYWRkZWQkMiA9IGxpbmVzRm9yKDEsIHRleHQubGVuZ3RoIC0gMSlcXG4gICAgaWYgKG5saW5lcyA+IDEpIHsgZG9jLnJlbW92ZShmcm9tLmxpbmUgKyAxLCBubGluZXMgLSAxKSB9XFxuICAgIGRvYy5pbnNlcnQoZnJvbS5saW5lICsgMSwgYWRkZWQkMilcXG4gIH1cXG5cXG4gIHNpZ25hbExhdGVyKGRvYywgXFxcImNoYW5nZVxcXCIsIGRvYywgY2hhbmdlKVxcbn1cXG5cXG4vLyBDYWxsIGYgZm9yIGFsbCBsaW5rZWQgZG9jdW1lbnRzLlxcbmZ1bmN0aW9uIGxpbmtlZERvY3MoZG9jLCBmLCBzaGFyZWRIaXN0T25seSkge1xcbiAgZnVuY3Rpb24gcHJvcGFnYXRlKGRvYywgc2tpcCwgc2hhcmVkSGlzdCkge1xcbiAgICBpZiAoZG9jLmxpbmtlZCkgeyBmb3IgKHZhciBpID0gMDsgaSA8IGRvYy5saW5rZWQubGVuZ3RoOyArK2kpIHtcXG4gICAgICB2YXIgcmVsID0gZG9jLmxpbmtlZFtpXVxcbiAgICAgIGlmIChyZWwuZG9jID09IHNraXApIHsgY29udGludWUgfVxcbiAgICAgIHZhciBzaGFyZWQgPSBzaGFyZWRIaXN0ICYmIHJlbC5zaGFyZWRIaXN0XFxuICAgICAgaWYgKHNoYXJlZEhpc3RPbmx5ICYmICFzaGFyZWQpIHsgY29udGludWUgfVxcbiAgICAgIGYocmVsLmRvYywgc2hhcmVkKVxcbiAgICAgIHByb3BhZ2F0ZShyZWwuZG9jLCBkb2MsIHNoYXJlZClcXG4gICAgfSB9XFxuICB9XFxuICBwcm9wYWdhdGUoZG9jLCBudWxsLCB0cnVlKVxcbn1cXG5cXG4vLyBBdHRhY2ggYSBkb2N1bWVudCB0byBhbiBlZGl0b3IuXFxuZnVuY3Rpb24gYXR0YWNoRG9jKGNtLCBkb2MpIHtcXG4gIGlmIChkb2MuY20pIHsgdGhyb3cgbmV3IEVycm9yKFxcXCJUaGlzIGRvY3VtZW50IGlzIGFscmVhZHkgaW4gdXNlLlxcXCIpIH1cXG4gIGNtLmRvYyA9IGRvY1xcbiAgZG9jLmNtID0gY21cXG4gIGVzdGltYXRlTGluZUhlaWdodHMoY20pXFxuICBsb2FkTW9kZShjbSlcXG4gIGlmICghY20ub3B0aW9ucy5saW5lV3JhcHBpbmcpIHsgZmluZE1heExpbmUoY20pIH1cXG4gIGNtLm9wdGlvbnMubW9kZSA9IGRvYy5tb2RlT3B0aW9uXFxuICByZWdDaGFuZ2UoY20pXFxufVxcblxcbmZ1bmN0aW9uIEhpc3Rvcnkoc3RhcnRHZW4pIHtcXG4gIC8vIEFycmF5cyBvZiBjaGFuZ2UgZXZlbnRzIGFuZCBzZWxlY3Rpb25zLiBEb2luZyBzb21ldGhpbmcgYWRkcyBhblxcbiAgLy8gZXZlbnQgdG8gZG9uZSBhbmQgY2xlYXJzIHVuZG8uIFVuZG9pbmcgbW92ZXMgZXZlbnRzIGZyb20gZG9uZVxcbiAgLy8gdG8gdW5kb25lLCByZWRvaW5nIG1vdmVzIHRoZW0gaW4gdGhlIG90aGVyIGRpcmVjdGlvbi5cXG4gIHRoaXMuZG9uZSA9IFtdOyB0aGlzLnVuZG9uZSA9IFtdXFxuICB0aGlzLnVuZG9EZXB0aCA9IEluZmluaXR5XFxuICAvLyBVc2VkIHRvIHRyYWNrIHdoZW4gY2hhbmdlcyBjYW4gYmUgbWVyZ2VkIGludG8gYSBzaW5nbGUgdW5kb1xcbiAgLy8gZXZlbnRcXG4gIHRoaXMubGFzdE1vZFRpbWUgPSB0aGlzLmxhc3RTZWxUaW1lID0gMFxcbiAgdGhpcy5sYXN0T3AgPSB0aGlzLmxhc3RTZWxPcCA9IG51bGxcXG4gIHRoaXMubGFzdE9yaWdpbiA9IHRoaXMubGFzdFNlbE9yaWdpbiA9IG51bGxcXG4gIC8vIFVzZWQgYnkgdGhlIGlzQ2xlYW4oKSBtZXRob2RcXG4gIHRoaXMuZ2VuZXJhdGlvbiA9IHRoaXMubWF4R2VuZXJhdGlvbiA9IHN0YXJ0R2VuIHx8IDFcXG59XFxuXFxuLy8gQ3JlYXRlIGEgaGlzdG9yeSBjaGFuZ2UgZXZlbnQgZnJvbSBhbiB1cGRhdGVEb2Mtc3R5bGUgY2hhbmdlXFxuLy8gb2JqZWN0LlxcbmZ1bmN0aW9uIGhpc3RvcnlDaGFuZ2VGcm9tQ2hhbmdlKGRvYywgY2hhbmdlKSB7XFxuICB2YXIgaGlzdENoYW5nZSA9IHtmcm9tOiBjb3B5UG9zKGNoYW5nZS5mcm9tKSwgdG86IGNoYW5nZUVuZChjaGFuZ2UpLCB0ZXh0OiBnZXRCZXR3ZWVuKGRvYywgY2hhbmdlLmZyb20sIGNoYW5nZS50byl9XFxuICBhdHRhY2hMb2NhbFNwYW5zKGRvYywgaGlzdENoYW5nZSwgY2hhbmdlLmZyb20ubGluZSwgY2hhbmdlLnRvLmxpbmUgKyAxKVxcbiAgbGlua2VkRG9jcyhkb2MsIGZ1bmN0aW9uIChkb2MpIHsgcmV0dXJuIGF0dGFjaExvY2FsU3BhbnMoZG9jLCBoaXN0Q2hhbmdlLCBjaGFuZ2UuZnJvbS5saW5lLCBjaGFuZ2UudG8ubGluZSArIDEpOyB9LCB0cnVlKVxcbiAgcmV0dXJuIGhpc3RDaGFuZ2VcXG59XFxuXFxuLy8gUG9wIGFsbCBzZWxlY3Rpb24gZXZlbnRzIG9mZiB0aGUgZW5kIG9mIGEgaGlzdG9yeSBhcnJheS4gU3RvcCBhdFxcbi8vIGEgY2hhbmdlIGV2ZW50LlxcbmZ1bmN0aW9uIGNsZWFyU2VsZWN0aW9uRXZlbnRzKGFycmF5KSB7XFxuICB3aGlsZSAoYXJyYXkubGVuZ3RoKSB7XFxuICAgIHZhciBsYXN0ID0gbHN0KGFycmF5KVxcbiAgICBpZiAobGFzdC5yYW5nZXMpIHsgYXJyYXkucG9wKCkgfVxcbiAgICBlbHNlIHsgYnJlYWsgfVxcbiAgfVxcbn1cXG5cXG4vLyBGaW5kIHRoZSB0b3AgY2hhbmdlIGV2ZW50IGluIHRoZSBoaXN0b3J5LiBQb3Agb2ZmIHNlbGVjdGlvblxcbi8vIGV2ZW50cyB0aGF0IGFyZSBpbiB0aGUgd2F5LlxcbmZ1bmN0aW9uIGxhc3RDaGFuZ2VFdmVudChoaXN0LCBmb3JjZSkge1xcbiAgaWYgKGZvcmNlKSB7XFxuICAgIGNsZWFyU2VsZWN0aW9uRXZlbnRzKGhpc3QuZG9uZSlcXG4gICAgcmV0dXJuIGxzdChoaXN0LmRvbmUpXFxuICB9IGVsc2UgaWYgKGhpc3QuZG9uZS5sZW5ndGggJiYgIWxzdChoaXN0LmRvbmUpLnJhbmdlcykge1xcbiAgICByZXR1cm4gbHN0KGhpc3QuZG9uZSlcXG4gIH0gZWxzZSBpZiAoaGlzdC5kb25lLmxlbmd0aCA+IDEgJiYgIWhpc3QuZG9uZVtoaXN0LmRvbmUubGVuZ3RoIC0gMl0ucmFuZ2VzKSB7XFxuICAgIGhpc3QuZG9uZS5wb3AoKVxcbiAgICByZXR1cm4gbHN0KGhpc3QuZG9uZSlcXG4gIH1cXG59XFxuXFxuLy8gUmVnaXN0ZXIgYSBjaGFuZ2UgaW4gdGhlIGhpc3RvcnkuIE1lcmdlcyBjaGFuZ2VzIHRoYXQgYXJlIHdpdGhpblxcbi8vIGEgc2luZ2xlIG9wZXJhdGlvbiwgb3IgYXJlIGNsb3NlIHRvZ2V0aGVyIHdpdGggYW4gb3JpZ2luIHRoYXRcXG4vLyBhbGxvd3MgbWVyZ2luZyAoc3RhcnRpbmcgd2l0aCBcXFwiK1xcXCIpIGludG8gYSBzaW5nbGUgZXZlbnQuXFxuZnVuY3Rpb24gYWRkQ2hhbmdlVG9IaXN0b3J5KGRvYywgY2hhbmdlLCBzZWxBZnRlciwgb3BJZCkge1xcbiAgdmFyIGhpc3QgPSBkb2MuaGlzdG9yeVxcbiAgaGlzdC51bmRvbmUubGVuZ3RoID0gMFxcbiAgdmFyIHRpbWUgPSArbmV3IERhdGUsIGN1clxcbiAgdmFyIGxhc3RcXG5cXG4gIGlmICgoaGlzdC5sYXN0T3AgPT0gb3BJZCB8fFxcbiAgICAgICBoaXN0Lmxhc3RPcmlnaW4gPT0gY2hhbmdlLm9yaWdpbiAmJiBjaGFuZ2Uub3JpZ2luICYmXFxuICAgICAgICgoY2hhbmdlLm9yaWdpbi5jaGFyQXQoMCkgPT0gXFxcIitcXFwiICYmIGRvYy5jbSAmJiBoaXN0Lmxhc3RNb2RUaW1lID4gdGltZSAtIGRvYy5jbS5vcHRpb25zLmhpc3RvcnlFdmVudERlbGF5KSB8fFxcbiAgICAgICAgY2hhbmdlLm9yaWdpbi5jaGFyQXQoMCkgPT0gXFxcIipcXFwiKSkgJiZcXG4gICAgICAoY3VyID0gbGFzdENoYW5nZUV2ZW50KGhpc3QsIGhpc3QubGFzdE9wID09IG9wSWQpKSkge1xcbiAgICAvLyBNZXJnZSB0aGlzIGNoYW5nZSBpbnRvIHRoZSBsYXN0IGV2ZW50XFxuICAgIGxhc3QgPSBsc3QoY3VyLmNoYW5nZXMpXFxuICAgIGlmIChjbXAoY2hhbmdlLmZyb20sIGNoYW5nZS50bykgPT0gMCAmJiBjbXAoY2hhbmdlLmZyb20sIGxhc3QudG8pID09IDApIHtcXG4gICAgICAvLyBPcHRpbWl6ZWQgY2FzZSBmb3Igc2ltcGxlIGluc2VydGlvbiAtLSBkb24ndCB3YW50IHRvIGFkZFxcbiAgICAgIC8vIG5ldyBjaGFuZ2VzZXRzIGZvciBldmVyeSBjaGFyYWN0ZXIgdHlwZWRcXG4gICAgICBsYXN0LnRvID0gY2hhbmdlRW5kKGNoYW5nZSlcXG4gICAgfSBlbHNlIHtcXG4gICAgICAvLyBBZGQgbmV3IHN1Yi1ldmVudFxcbiAgICAgIGN1ci5jaGFuZ2VzLnB1c2goaGlzdG9yeUNoYW5nZUZyb21DaGFuZ2UoZG9jLCBjaGFuZ2UpKVxcbiAgICB9XFxuICB9IGVsc2Uge1xcbiAgICAvLyBDYW4gbm90IGJlIG1lcmdlZCwgc3RhcnQgYSBuZXcgZXZlbnQuXFxuICAgIHZhciBiZWZvcmUgPSBsc3QoaGlzdC5kb25lKVxcbiAgICBpZiAoIWJlZm9yZSB8fCAhYmVmb3JlLnJhbmdlcylcXG4gICAgICB7IHB1c2hTZWxlY3Rpb25Ub0hpc3RvcnkoZG9jLnNlbCwgaGlzdC5kb25lKSB9XFxuICAgIGN1ciA9IHtjaGFuZ2VzOiBbaGlzdG9yeUNoYW5nZUZyb21DaGFuZ2UoZG9jLCBjaGFuZ2UpXSxcXG4gICAgICAgICAgIGdlbmVyYXRpb246IGhpc3QuZ2VuZXJhdGlvbn1cXG4gICAgaGlzdC5kb25lLnB1c2goY3VyKVxcbiAgICB3aGlsZSAoaGlzdC5kb25lLmxlbmd0aCA+IGhpc3QudW5kb0RlcHRoKSB7XFxuICAgICAgaGlzdC5kb25lLnNoaWZ0KClcXG4gICAgICBpZiAoIWhpc3QuZG9uZVswXS5yYW5nZXMpIHsgaGlzdC5kb25lLnNoaWZ0KCkgfVxcbiAgICB9XFxuICB9XFxuICBoaXN0LmRvbmUucHVzaChzZWxBZnRlcilcXG4gIGhpc3QuZ2VuZXJhdGlvbiA9ICsraGlzdC5tYXhHZW5lcmF0aW9uXFxuICBoaXN0Lmxhc3RNb2RUaW1lID0gaGlzdC5sYXN0U2VsVGltZSA9IHRpbWVcXG4gIGhpc3QubGFzdE9wID0gaGlzdC5sYXN0U2VsT3AgPSBvcElkXFxuICBoaXN0Lmxhc3RPcmlnaW4gPSBoaXN0Lmxhc3RTZWxPcmlnaW4gPSBjaGFuZ2Uub3JpZ2luXFxuXFxuICBpZiAoIWxhc3QpIHsgc2lnbmFsKGRvYywgXFxcImhpc3RvcnlBZGRlZFxcXCIpIH1cXG59XFxuXFxuZnVuY3Rpb24gc2VsZWN0aW9uRXZlbnRDYW5CZU1lcmdlZChkb2MsIG9yaWdpbiwgcHJldiwgc2VsKSB7XFxuICB2YXIgY2ggPSBvcmlnaW4uY2hhckF0KDApXFxuICByZXR1cm4gY2ggPT0gXFxcIipcXFwiIHx8XFxuICAgIGNoID09IFxcXCIrXFxcIiAmJlxcbiAgICBwcmV2LnJhbmdlcy5sZW5ndGggPT0gc2VsLnJhbmdlcy5sZW5ndGggJiZcXG4gICAgcHJldi5zb21ldGhpbmdTZWxlY3RlZCgpID09IHNlbC5zb21ldGhpbmdTZWxlY3RlZCgpICYmXFxuICAgIG5ldyBEYXRlIC0gZG9jLmhpc3RvcnkubGFzdFNlbFRpbWUgPD0gKGRvYy5jbSA/IGRvYy5jbS5vcHRpb25zLmhpc3RvcnlFdmVudERlbGF5IDogNTAwKVxcbn1cXG5cXG4vLyBDYWxsZWQgd2hlbmV2ZXIgdGhlIHNlbGVjdGlvbiBjaGFuZ2VzLCBzZXRzIHRoZSBuZXcgc2VsZWN0aW9uIGFzXFxuLy8gdGhlIHBlbmRpbmcgc2VsZWN0aW9uIGluIHRoZSBoaXN0b3J5LCBhbmQgcHVzaGVzIHRoZSBvbGQgcGVuZGluZ1xcbi8vIHNlbGVjdGlvbiBpbnRvIHRoZSAnZG9uZScgYXJyYXkgd2hlbiBpdCB3YXMgc2lnbmlmaWNhbnRseVxcbi8vIGRpZmZlcmVudCAoaW4gbnVtYmVyIG9mIHNlbGVjdGVkIHJhbmdlcywgZW1wdGluZXNzLCBvciB0aW1lKS5cXG5mdW5jdGlvbiBhZGRTZWxlY3Rpb25Ub0hpc3RvcnkoZG9jLCBzZWwsIG9wSWQsIG9wdGlvbnMpIHtcXG4gIHZhciBoaXN0ID0gZG9jLmhpc3RvcnksIG9yaWdpbiA9IG9wdGlvbnMgJiYgb3B0aW9ucy5vcmlnaW5cXG5cXG4gIC8vIEEgbmV3IGV2ZW50IGlzIHN0YXJ0ZWQgd2hlbiB0aGUgcHJldmlvdXMgb3JpZ2luIGRvZXMgbm90IG1hdGNoXFxuICAvLyB0aGUgY3VycmVudCwgb3IgdGhlIG9yaWdpbnMgZG9uJ3QgYWxsb3cgbWF0Y2hpbmcuIE9yaWdpbnNcXG4gIC8vIHN0YXJ0aW5nIHdpdGggKiBhcmUgYWx3YXlzIG1lcmdlZCwgdGhvc2Ugc3RhcnRpbmcgd2l0aCArIGFyZVxcbiAgLy8gbWVyZ2VkIHdoZW4gc2ltaWxhciBhbmQgY2xvc2UgdG9nZXRoZXIgaW4gdGltZS5cXG4gIGlmIChvcElkID09IGhpc3QubGFzdFNlbE9wIHx8XFxuICAgICAgKG9yaWdpbiAmJiBoaXN0Lmxhc3RTZWxPcmlnaW4gPT0gb3JpZ2luICYmXFxuICAgICAgIChoaXN0Lmxhc3RNb2RUaW1lID09IGhpc3QubGFzdFNlbFRpbWUgJiYgaGlzdC5sYXN0T3JpZ2luID09IG9yaWdpbiB8fFxcbiAgICAgICAgc2VsZWN0aW9uRXZlbnRDYW5CZU1lcmdlZChkb2MsIG9yaWdpbiwgbHN0KGhpc3QuZG9uZSksIHNlbCkpKSlcXG4gICAgeyBoaXN0LmRvbmVbaGlzdC5kb25lLmxlbmd0aCAtIDFdID0gc2VsIH1cXG4gIGVsc2VcXG4gICAgeyBwdXNoU2VsZWN0aW9uVG9IaXN0b3J5KHNlbCwgaGlzdC5kb25lKSB9XFxuXFxuICBoaXN0Lmxhc3RTZWxUaW1lID0gK25ldyBEYXRlXFxuICBoaXN0Lmxhc3RTZWxPcmlnaW4gPSBvcmlnaW5cXG4gIGhpc3QubGFzdFNlbE9wID0gb3BJZFxcbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5jbGVhclJlZG8gIT09IGZhbHNlKVxcbiAgICB7IGNsZWFyU2VsZWN0aW9uRXZlbnRzKGhpc3QudW5kb25lKSB9XFxufVxcblxcbmZ1bmN0aW9uIHB1c2hTZWxlY3Rpb25Ub0hpc3Rvcnkoc2VsLCBkZXN0KSB7XFxuICB2YXIgdG9wID0gbHN0KGRlc3QpXFxuICBpZiAoISh0b3AgJiYgdG9wLnJhbmdlcyAmJiB0b3AuZXF1YWxzKHNlbCkpKVxcbiAgICB7IGRlc3QucHVzaChzZWwpIH1cXG59XFxuXFxuLy8gVXNlZCB0byBzdG9yZSBtYXJrZWQgc3BhbiBpbmZvcm1hdGlvbiBpbiB0aGUgaGlzdG9yeS5cXG5mdW5jdGlvbiBhdHRhY2hMb2NhbFNwYW5zKGRvYywgY2hhbmdlLCBmcm9tLCB0bykge1xcbiAgdmFyIGV4aXN0aW5nID0gY2hhbmdlW1xcXCJzcGFuc19cXFwiICsgZG9jLmlkXSwgbiA9IDBcXG4gIGRvYy5pdGVyKE1hdGgubWF4KGRvYy5maXJzdCwgZnJvbSksIE1hdGgubWluKGRvYy5maXJzdCArIGRvYy5zaXplLCB0byksIGZ1bmN0aW9uIChsaW5lKSB7XFxuICAgIGlmIChsaW5lLm1hcmtlZFNwYW5zKVxcbiAgICAgIHsgKGV4aXN0aW5nIHx8IChleGlzdGluZyA9IGNoYW5nZVtcXFwic3BhbnNfXFxcIiArIGRvYy5pZF0gPSB7fSkpW25dID0gbGluZS5tYXJrZWRTcGFucyB9XFxuICAgICsrblxcbiAgfSlcXG59XFxuXFxuLy8gV2hlbiB1bi9yZS1kb2luZyByZXN0b3JlcyB0ZXh0IGNvbnRhaW5pbmcgbWFya2VkIHNwYW5zLCB0aG9zZVxcbi8vIHRoYXQgaGF2ZSBiZWVuIGV4cGxpY2l0bHkgY2xlYXJlZCBzaG91bGQgbm90IGJlIHJlc3RvcmVkLlxcbmZ1bmN0aW9uIHJlbW92ZUNsZWFyZWRTcGFucyhzcGFucykge1xcbiAgaWYgKCFzcGFucykgeyByZXR1cm4gbnVsbCB9XFxuICB2YXIgb3V0XFxuICBmb3IgKHZhciBpID0gMDsgaSA8IHNwYW5zLmxlbmd0aDsgKytpKSB7XFxuICAgIGlmIChzcGFuc1tpXS5tYXJrZXIuZXhwbGljaXRseUNsZWFyZWQpIHsgaWYgKCFvdXQpIHsgb3V0ID0gc3BhbnMuc2xpY2UoMCwgaSkgfSB9XFxuICAgIGVsc2UgaWYgKG91dCkgeyBvdXQucHVzaChzcGFuc1tpXSkgfVxcbiAgfVxcbiAgcmV0dXJuICFvdXQgPyBzcGFucyA6IG91dC5sZW5ndGggPyBvdXQgOiBudWxsXFxufVxcblxcbi8vIFJldHJpZXZlIGFuZCBmaWx0ZXIgdGhlIG9sZCBtYXJrZWQgc3BhbnMgc3RvcmVkIGluIGEgY2hhbmdlIGV2ZW50LlxcbmZ1bmN0aW9uIGdldE9sZFNwYW5zKGRvYywgY2hhbmdlKSB7XFxuICB2YXIgZm91bmQgPSBjaGFuZ2VbXFxcInNwYW5zX1xcXCIgKyBkb2MuaWRdXFxuICBpZiAoIWZvdW5kKSB7IHJldHVybiBudWxsIH1cXG4gIHZhciBudyA9IFtdXFxuICBmb3IgKHZhciBpID0gMDsgaSA8IGNoYW5nZS50ZXh0Lmxlbmd0aDsgKytpKVxcbiAgICB7IG53LnB1c2gocmVtb3ZlQ2xlYXJlZFNwYW5zKGZvdW5kW2ldKSkgfVxcbiAgcmV0dXJuIG53XFxufVxcblxcbi8vIFVzZWQgZm9yIHVuL3JlLWRvaW5nIGNoYW5nZXMgZnJvbSB0aGUgaGlzdG9yeS4gQ29tYmluZXMgdGhlXFxuLy8gcmVzdWx0IG9mIGNvbXB1dGluZyB0aGUgZXhpc3Rpbmcgc3BhbnMgd2l0aCB0aGUgc2V0IG9mIHNwYW5zIHRoYXRcXG4vLyBleGlzdGVkIGluIHRoZSBoaXN0b3J5IChzbyB0aGF0IGRlbGV0aW5nIGFyb3VuZCBhIHNwYW4gYW5kIHRoZW5cXG4vLyB1bmRvaW5nIGJyaW5ncyBiYWNrIHRoZSBzcGFuKS5cXG5mdW5jdGlvbiBtZXJnZU9sZFNwYW5zKGRvYywgY2hhbmdlKSB7XFxuICB2YXIgb2xkID0gZ2V0T2xkU3BhbnMoZG9jLCBjaGFuZ2UpXFxuICB2YXIgc3RyZXRjaGVkID0gc3RyZXRjaFNwYW5zT3ZlckNoYW5nZShkb2MsIGNoYW5nZSlcXG4gIGlmICghb2xkKSB7IHJldHVybiBzdHJldGNoZWQgfVxcbiAgaWYgKCFzdHJldGNoZWQpIHsgcmV0dXJuIG9sZCB9XFxuXFxuICBmb3IgKHZhciBpID0gMDsgaSA8IG9sZC5sZW5ndGg7ICsraSkge1xcbiAgICB2YXIgb2xkQ3VyID0gb2xkW2ldLCBzdHJldGNoQ3VyID0gc3RyZXRjaGVkW2ldXFxuICAgIGlmIChvbGRDdXIgJiYgc3RyZXRjaEN1cikge1xcbiAgICAgIHNwYW5zOiBmb3IgKHZhciBqID0gMDsgaiA8IHN0cmV0Y2hDdXIubGVuZ3RoOyArK2opIHtcXG4gICAgICAgIHZhciBzcGFuID0gc3RyZXRjaEN1cltqXVxcbiAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBvbGRDdXIubGVuZ3RoOyArK2spXFxuICAgICAgICAgIHsgaWYgKG9sZEN1cltrXS5tYXJrZXIgPT0gc3Bhbi5tYXJrZXIpIHsgY29udGludWUgc3BhbnMgfSB9XFxuICAgICAgICBvbGRDdXIucHVzaChzcGFuKVxcbiAgICAgIH1cXG4gICAgfSBlbHNlIGlmIChzdHJldGNoQ3VyKSB7XFxuICAgICAgb2xkW2ldID0gc3RyZXRjaEN1clxcbiAgICB9XFxuICB9XFxuICByZXR1cm4gb2xkXFxufVxcblxcbi8vIFVzZWQgYm90aCB0byBwcm92aWRlIGEgSlNPTi1zYWZlIG9iamVjdCBpbiAuZ2V0SGlzdG9yeSwgYW5kLCB3aGVuXFxuLy8gZGV0YWNoaW5nIGEgZG9jdW1lbnQsIHRvIHNwbGl0IHRoZSBoaXN0b3J5IGluIHR3b1xcbmZ1bmN0aW9uIGNvcHlIaXN0b3J5QXJyYXkoZXZlbnRzLCBuZXdHcm91cCwgaW5zdGFudGlhdGVTZWwpIHtcXG4gIHZhciBjb3B5ID0gW11cXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZXZlbnRzLmxlbmd0aDsgKytpKSB7XFxuICAgIHZhciBldmVudCA9IGV2ZW50c1tpXVxcbiAgICBpZiAoZXZlbnQucmFuZ2VzKSB7XFxuICAgICAgY29weS5wdXNoKGluc3RhbnRpYXRlU2VsID8gU2VsZWN0aW9uLnByb3RvdHlwZS5kZWVwQ29weS5jYWxsKGV2ZW50KSA6IGV2ZW50KVxcbiAgICAgIGNvbnRpbnVlXFxuICAgIH1cXG4gICAgdmFyIGNoYW5nZXMgPSBldmVudC5jaGFuZ2VzLCBuZXdDaGFuZ2VzID0gW11cXG4gICAgY29weS5wdXNoKHtjaGFuZ2VzOiBuZXdDaGFuZ2VzfSlcXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBjaGFuZ2VzLmxlbmd0aDsgKytqKSB7XFxuICAgICAgdmFyIGNoYW5nZSA9IGNoYW5nZXNbal0sIG0gPSAodm9pZCAwKVxcbiAgICAgIG5ld0NoYW5nZXMucHVzaCh7ZnJvbTogY2hhbmdlLmZyb20sIHRvOiBjaGFuZ2UudG8sIHRleHQ6IGNoYW5nZS50ZXh0fSlcXG4gICAgICBpZiAobmV3R3JvdXApIHsgZm9yICh2YXIgcHJvcCBpbiBjaGFuZ2UpIHsgaWYgKG0gPSBwcm9wLm1hdGNoKC9ec3BhbnNfKFxcXFxkKykkLykpIHtcXG4gICAgICAgIGlmIChpbmRleE9mKG5ld0dyb3VwLCBOdW1iZXIobVsxXSkpID4gLTEpIHtcXG4gICAgICAgICAgbHN0KG5ld0NoYW5nZXMpW3Byb3BdID0gY2hhbmdlW3Byb3BdXFxuICAgICAgICAgIGRlbGV0ZSBjaGFuZ2VbcHJvcF1cXG4gICAgICAgIH1cXG4gICAgICB9IH0gfVxcbiAgICB9XFxuICB9XFxuICByZXR1cm4gY29weVxcbn1cXG5cXG4vLyBUaGUgJ3Njcm9sbCcgcGFyYW1ldGVyIGdpdmVuIHRvIG1hbnkgb2YgdGhlc2UgaW5kaWNhdGVkIHdoZXRoZXJcXG4vLyB0aGUgbmV3IGN1cnNvciBwb3NpdGlvbiBzaG91bGQgYmUgc2Nyb2xsZWQgaW50byB2aWV3IGFmdGVyXFxuLy8gbW9kaWZ5aW5nIHRoZSBzZWxlY3Rpb24uXFxuXFxuLy8gSWYgc2hpZnQgaXMgaGVsZCBvciB0aGUgZXh0ZW5kIGZsYWcgaXMgc2V0LCBleHRlbmRzIGEgcmFuZ2UgdG9cXG4vLyBpbmNsdWRlIGEgZ2l2ZW4gcG9zaXRpb24gKGFuZCBvcHRpb25hbGx5IGEgc2Vjb25kIHBvc2l0aW9uKS5cXG4vLyBPdGhlcndpc2UsIHNpbXBseSByZXR1cm5zIHRoZSByYW5nZSBiZXR3ZWVuIHRoZSBnaXZlbiBwb3NpdGlvbnMuXFxuLy8gVXNlZCBmb3IgY3Vyc29yIG1vdGlvbiBhbmQgc3VjaC5cXG5mdW5jdGlvbiBleHRlbmRSYW5nZShkb2MsIHJhbmdlLCBoZWFkLCBvdGhlcikge1xcbiAgaWYgKGRvYy5jbSAmJiBkb2MuY20uZGlzcGxheS5zaGlmdCB8fCBkb2MuZXh0ZW5kKSB7XFxuICAgIHZhciBhbmNob3IgPSByYW5nZS5hbmNob3JcXG4gICAgaWYgKG90aGVyKSB7XFxuICAgICAgdmFyIHBvc0JlZm9yZSA9IGNtcChoZWFkLCBhbmNob3IpIDwgMFxcbiAgICAgIGlmIChwb3NCZWZvcmUgIT0gKGNtcChvdGhlciwgYW5jaG9yKSA8IDApKSB7XFxuICAgICAgICBhbmNob3IgPSBoZWFkXFxuICAgICAgICBoZWFkID0gb3RoZXJcXG4gICAgICB9IGVsc2UgaWYgKHBvc0JlZm9yZSAhPSAoY21wKGhlYWQsIG90aGVyKSA8IDApKSB7XFxuICAgICAgICBoZWFkID0gb3RoZXJcXG4gICAgICB9XFxuICAgIH1cXG4gICAgcmV0dXJuIG5ldyBSYW5nZShhbmNob3IsIGhlYWQpXFxuICB9IGVsc2Uge1xcbiAgICByZXR1cm4gbmV3IFJhbmdlKG90aGVyIHx8IGhlYWQsIGhlYWQpXFxuICB9XFxufVxcblxcbi8vIEV4dGVuZCB0aGUgcHJpbWFyeSBzZWxlY3Rpb24gcmFuZ2UsIGRpc2NhcmQgdGhlIHJlc3QuXFxuZnVuY3Rpb24gZXh0ZW5kU2VsZWN0aW9uKGRvYywgaGVhZCwgb3RoZXIsIG9wdGlvbnMpIHtcXG4gIHNldFNlbGVjdGlvbihkb2MsIG5ldyBTZWxlY3Rpb24oW2V4dGVuZFJhbmdlKGRvYywgZG9jLnNlbC5wcmltYXJ5KCksIGhlYWQsIG90aGVyKV0sIDApLCBvcHRpb25zKVxcbn1cXG5cXG4vLyBFeHRlbmQgYWxsIHNlbGVjdGlvbnMgKHBvcyBpcyBhbiBhcnJheSBvZiBzZWxlY3Rpb25zIHdpdGggbGVuZ3RoXFxuLy8gZXF1YWwgdGhlIG51bWJlciBvZiBzZWxlY3Rpb25zKVxcbmZ1bmN0aW9uIGV4dGVuZFNlbGVjdGlvbnMoZG9jLCBoZWFkcywgb3B0aW9ucykge1xcbiAgdmFyIG91dCA9IFtdXFxuICBmb3IgKHZhciBpID0gMDsgaSA8IGRvYy5zZWwucmFuZ2VzLmxlbmd0aDsgaSsrKVxcbiAgICB7IG91dFtpXSA9IGV4dGVuZFJhbmdlKGRvYywgZG9jLnNlbC5yYW5nZXNbaV0sIGhlYWRzW2ldLCBudWxsKSB9XFxuICB2YXIgbmV3U2VsID0gbm9ybWFsaXplU2VsZWN0aW9uKG91dCwgZG9jLnNlbC5wcmltSW5kZXgpXFxuICBzZXRTZWxlY3Rpb24oZG9jLCBuZXdTZWwsIG9wdGlvbnMpXFxufVxcblxcbi8vIFVwZGF0ZXMgYSBzaW5nbGUgcmFuZ2UgaW4gdGhlIHNlbGVjdGlvbi5cXG5mdW5jdGlvbiByZXBsYWNlT25lU2VsZWN0aW9uKGRvYywgaSwgcmFuZ2UsIG9wdGlvbnMpIHtcXG4gIHZhciByYW5nZXMgPSBkb2Muc2VsLnJhbmdlcy5zbGljZSgwKVxcbiAgcmFuZ2VzW2ldID0gcmFuZ2VcXG4gIHNldFNlbGVjdGlvbihkb2MsIG5vcm1hbGl6ZVNlbGVjdGlvbihyYW5nZXMsIGRvYy5zZWwucHJpbUluZGV4KSwgb3B0aW9ucylcXG59XFxuXFxuLy8gUmVzZXQgdGhlIHNlbGVjdGlvbiB0byBhIHNpbmdsZSByYW5nZS5cXG5mdW5jdGlvbiBzZXRTaW1wbGVTZWxlY3Rpb24oZG9jLCBhbmNob3IsIGhlYWQsIG9wdGlvbnMpIHtcXG4gIHNldFNlbGVjdGlvbihkb2MsIHNpbXBsZVNlbGVjdGlvbihhbmNob3IsIGhlYWQpLCBvcHRpb25zKVxcbn1cXG5cXG4vLyBHaXZlIGJlZm9yZVNlbGVjdGlvbkNoYW5nZSBoYW5kbGVycyBhIGNoYW5nZSB0byBpbmZsdWVuY2UgYVxcbi8vIHNlbGVjdGlvbiB1cGRhdGUuXFxuZnVuY3Rpb24gZmlsdGVyU2VsZWN0aW9uQ2hhbmdlKGRvYywgc2VsLCBvcHRpb25zKSB7XFxuICB2YXIgb2JqID0ge1xcbiAgICByYW5nZXM6IHNlbC5yYW5nZXMsXFxuICAgIHVwZGF0ZTogZnVuY3Rpb24ocmFuZ2VzKSB7XFxuICAgICAgdmFyIHRoaXMkMSA9IHRoaXM7XFxuXFxuICAgICAgdGhpcy5yYW5nZXMgPSBbXVxcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmFuZ2VzLmxlbmd0aDsgaSsrKVxcbiAgICAgICAgeyB0aGlzJDEucmFuZ2VzW2ldID0gbmV3IFJhbmdlKGNsaXBQb3MoZG9jLCByYW5nZXNbaV0uYW5jaG9yKSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsaXBQb3MoZG9jLCByYW5nZXNbaV0uaGVhZCkpIH1cXG4gICAgfSxcXG4gICAgb3JpZ2luOiBvcHRpb25zICYmIG9wdGlvbnMub3JpZ2luXFxuICB9XFxuICBzaWduYWwoZG9jLCBcXFwiYmVmb3JlU2VsZWN0aW9uQ2hhbmdlXFxcIiwgZG9jLCBvYmopXFxuICBpZiAoZG9jLmNtKSB7IHNpZ25hbChkb2MuY20sIFxcXCJiZWZvcmVTZWxlY3Rpb25DaGFuZ2VcXFwiLCBkb2MuY20sIG9iaikgfVxcbiAgaWYgKG9iai5yYW5nZXMgIT0gc2VsLnJhbmdlcykgeyByZXR1cm4gbm9ybWFsaXplU2VsZWN0aW9uKG9iai5yYW5nZXMsIG9iai5yYW5nZXMubGVuZ3RoIC0gMSkgfVxcbiAgZWxzZSB7IHJldHVybiBzZWwgfVxcbn1cXG5cXG5mdW5jdGlvbiBzZXRTZWxlY3Rpb25SZXBsYWNlSGlzdG9yeShkb2MsIHNlbCwgb3B0aW9ucykge1xcbiAgdmFyIGRvbmUgPSBkb2MuaGlzdG9yeS5kb25lLCBsYXN0ID0gbHN0KGRvbmUpXFxuICBpZiAobGFzdCAmJiBsYXN0LnJhbmdlcykge1xcbiAgICBkb25lW2RvbmUubGVuZ3RoIC0gMV0gPSBzZWxcXG4gICAgc2V0U2VsZWN0aW9uTm9VbmRvKGRvYywgc2VsLCBvcHRpb25zKVxcbiAgfSBlbHNlIHtcXG4gICAgc2V0U2VsZWN0aW9uKGRvYywgc2VsLCBvcHRpb25zKVxcbiAgfVxcbn1cXG5cXG4vLyBTZXQgYSBuZXcgc2VsZWN0aW9uLlxcbmZ1bmN0aW9uIHNldFNlbGVjdGlvbihkb2MsIHNlbCwgb3B0aW9ucykge1xcbiAgc2V0U2VsZWN0aW9uTm9VbmRvKGRvYywgc2VsLCBvcHRpb25zKVxcbiAgYWRkU2VsZWN0aW9uVG9IaXN0b3J5KGRvYywgZG9jLnNlbCwgZG9jLmNtID8gZG9jLmNtLmN1ck9wLmlkIDogTmFOLCBvcHRpb25zKVxcbn1cXG5cXG5mdW5jdGlvbiBzZXRTZWxlY3Rpb25Ob1VuZG8oZG9jLCBzZWwsIG9wdGlvbnMpIHtcXG4gIGlmIChoYXNIYW5kbGVyKGRvYywgXFxcImJlZm9yZVNlbGVjdGlvbkNoYW5nZVxcXCIpIHx8IGRvYy5jbSAmJiBoYXNIYW5kbGVyKGRvYy5jbSwgXFxcImJlZm9yZVNlbGVjdGlvbkNoYW5nZVxcXCIpKVxcbiAgICB7IHNlbCA9IGZpbHRlclNlbGVjdGlvbkNoYW5nZShkb2MsIHNlbCwgb3B0aW9ucykgfVxcblxcbiAgdmFyIGJpYXMgPSBvcHRpb25zICYmIG9wdGlvbnMuYmlhcyB8fFxcbiAgICAoY21wKHNlbC5wcmltYXJ5KCkuaGVhZCwgZG9jLnNlbC5wcmltYXJ5KCkuaGVhZCkgPCAwID8gLTEgOiAxKVxcbiAgc2V0U2VsZWN0aW9uSW5uZXIoZG9jLCBza2lwQXRvbWljSW5TZWxlY3Rpb24oZG9jLCBzZWwsIGJpYXMsIHRydWUpKVxcblxcbiAgaWYgKCEob3B0aW9ucyAmJiBvcHRpb25zLnNjcm9sbCA9PT0gZmFsc2UpICYmIGRvYy5jbSlcXG4gICAgeyBlbnN1cmVDdXJzb3JWaXNpYmxlKGRvYy5jbSkgfVxcbn1cXG5cXG5mdW5jdGlvbiBzZXRTZWxlY3Rpb25Jbm5lcihkb2MsIHNlbCkge1xcbiAgaWYgKHNlbC5lcXVhbHMoZG9jLnNlbCkpIHsgcmV0dXJuIH1cXG5cXG4gIGRvYy5zZWwgPSBzZWxcXG5cXG4gIGlmIChkb2MuY20pIHtcXG4gICAgZG9jLmNtLmN1ck9wLnVwZGF0ZUlucHV0ID0gZG9jLmNtLmN1ck9wLnNlbGVjdGlvbkNoYW5nZWQgPSB0cnVlXFxuICAgIHNpZ25hbEN1cnNvckFjdGl2aXR5KGRvYy5jbSlcXG4gIH1cXG4gIHNpZ25hbExhdGVyKGRvYywgXFxcImN1cnNvckFjdGl2aXR5XFxcIiwgZG9jKVxcbn1cXG5cXG4vLyBWZXJpZnkgdGhhdCB0aGUgc2VsZWN0aW9uIGRvZXMgbm90IHBhcnRpYWxseSBzZWxlY3QgYW55IGF0b21pY1xcbi8vIG1hcmtlZCByYW5nZXMuXFxuZnVuY3Rpb24gcmVDaGVja1NlbGVjdGlvbihkb2MpIHtcXG4gIHNldFNlbGVjdGlvbklubmVyKGRvYywgc2tpcEF0b21pY0luU2VsZWN0aW9uKGRvYywgZG9jLnNlbCwgbnVsbCwgZmFsc2UpLCBzZWxfZG9udFNjcm9sbClcXG59XFxuXFxuLy8gUmV0dXJuIGEgc2VsZWN0aW9uIHRoYXQgZG9lcyBub3QgcGFydGlhbGx5IHNlbGVjdCBhbnkgYXRvbWljXFxuLy8gcmFuZ2VzLlxcbmZ1bmN0aW9uIHNraXBBdG9taWNJblNlbGVjdGlvbihkb2MsIHNlbCwgYmlhcywgbWF5Q2xlYXIpIHtcXG4gIHZhciBvdXRcXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc2VsLnJhbmdlcy5sZW5ndGg7IGkrKykge1xcbiAgICB2YXIgcmFuZ2UgPSBzZWwucmFuZ2VzW2ldXFxuICAgIHZhciBvbGQgPSBzZWwucmFuZ2VzLmxlbmd0aCA9PSBkb2Muc2VsLnJhbmdlcy5sZW5ndGggJiYgZG9jLnNlbC5yYW5nZXNbaV1cXG4gICAgdmFyIG5ld0FuY2hvciA9IHNraXBBdG9taWMoZG9jLCByYW5nZS5hbmNob3IsIG9sZCAmJiBvbGQuYW5jaG9yLCBiaWFzLCBtYXlDbGVhcilcXG4gICAgdmFyIG5ld0hlYWQgPSBza2lwQXRvbWljKGRvYywgcmFuZ2UuaGVhZCwgb2xkICYmIG9sZC5oZWFkLCBiaWFzLCBtYXlDbGVhcilcXG4gICAgaWYgKG91dCB8fCBuZXdBbmNob3IgIT0gcmFuZ2UuYW5jaG9yIHx8IG5ld0hlYWQgIT0gcmFuZ2UuaGVhZCkge1xcbiAgICAgIGlmICghb3V0KSB7IG91dCA9IHNlbC5yYW5nZXMuc2xpY2UoMCwgaSkgfVxcbiAgICAgIG91dFtpXSA9IG5ldyBSYW5nZShuZXdBbmNob3IsIG5ld0hlYWQpXFxuICAgIH1cXG4gIH1cXG4gIHJldHVybiBvdXQgPyBub3JtYWxpemVTZWxlY3Rpb24ob3V0LCBzZWwucHJpbUluZGV4KSA6IHNlbFxcbn1cXG5cXG5mdW5jdGlvbiBza2lwQXRvbWljSW5uZXIoZG9jLCBwb3MsIG9sZFBvcywgZGlyLCBtYXlDbGVhcikge1xcbiAgdmFyIGxpbmUgPSBnZXRMaW5lKGRvYywgcG9zLmxpbmUpXFxuICBpZiAobGluZS5tYXJrZWRTcGFucykgeyBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmUubWFya2VkU3BhbnMubGVuZ3RoOyArK2kpIHtcXG4gICAgdmFyIHNwID0gbGluZS5tYXJrZWRTcGFuc1tpXSwgbSA9IHNwLm1hcmtlclxcbiAgICBpZiAoKHNwLmZyb20gPT0gbnVsbCB8fCAobS5pbmNsdXNpdmVMZWZ0ID8gc3AuZnJvbSA8PSBwb3MuY2ggOiBzcC5mcm9tIDwgcG9zLmNoKSkgJiZcXG4gICAgICAgIChzcC50byA9PSBudWxsIHx8IChtLmluY2x1c2l2ZVJpZ2h0ID8gc3AudG8gPj0gcG9zLmNoIDogc3AudG8gPiBwb3MuY2gpKSkge1xcbiAgICAgIGlmIChtYXlDbGVhcikge1xcbiAgICAgICAgc2lnbmFsKG0sIFxcXCJiZWZvcmVDdXJzb3JFbnRlclxcXCIpXFxuICAgICAgICBpZiAobS5leHBsaWNpdGx5Q2xlYXJlZCkge1xcbiAgICAgICAgICBpZiAoIWxpbmUubWFya2VkU3BhbnMpIHsgYnJlYWsgfVxcbiAgICAgICAgICBlbHNlIHstLWk7IGNvbnRpbnVlfVxcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgICBpZiAoIW0uYXRvbWljKSB7IGNvbnRpbnVlIH1cXG5cXG4gICAgICBpZiAob2xkUG9zKSB7XFxuICAgICAgICB2YXIgbmVhciA9IG0uZmluZChkaXIgPCAwID8gMSA6IC0xKSwgZGlmZiA9ICh2b2lkIDApXFxuICAgICAgICBpZiAoZGlyIDwgMCA/IG0uaW5jbHVzaXZlUmlnaHQgOiBtLmluY2x1c2l2ZUxlZnQpXFxuICAgICAgICAgIHsgbmVhciA9IG1vdmVQb3MoZG9jLCBuZWFyLCAtZGlyLCBuZWFyICYmIG5lYXIubGluZSA9PSBwb3MubGluZSA/IGxpbmUgOiBudWxsKSB9XFxuICAgICAgICBpZiAobmVhciAmJiBuZWFyLmxpbmUgPT0gcG9zLmxpbmUgJiYgKGRpZmYgPSBjbXAobmVhciwgb2xkUG9zKSkgJiYgKGRpciA8IDAgPyBkaWZmIDwgMCA6IGRpZmYgPiAwKSlcXG4gICAgICAgICAgeyByZXR1cm4gc2tpcEF0b21pY0lubmVyKGRvYywgbmVhciwgcG9zLCBkaXIsIG1heUNsZWFyKSB9XFxuICAgICAgfVxcblxcbiAgICAgIHZhciBmYXIgPSBtLmZpbmQoZGlyIDwgMCA/IC0xIDogMSlcXG4gICAgICBpZiAoZGlyIDwgMCA/IG0uaW5jbHVzaXZlTGVmdCA6IG0uaW5jbHVzaXZlUmlnaHQpXFxuICAgICAgICB7IGZhciA9IG1vdmVQb3MoZG9jLCBmYXIsIGRpciwgZmFyLmxpbmUgPT0gcG9zLmxpbmUgPyBsaW5lIDogbnVsbCkgfVxcbiAgICAgIHJldHVybiBmYXIgPyBza2lwQXRvbWljSW5uZXIoZG9jLCBmYXIsIHBvcywgZGlyLCBtYXlDbGVhcikgOiBudWxsXFxuICAgIH1cXG4gIH0gfVxcbiAgcmV0dXJuIHBvc1xcbn1cXG5cXG4vLyBFbnN1cmUgYSBnaXZlbiBwb3NpdGlvbiBpcyBub3QgaW5zaWRlIGFuIGF0b21pYyByYW5nZS5cXG5mdW5jdGlvbiBza2lwQXRvbWljKGRvYywgcG9zLCBvbGRQb3MsIGJpYXMsIG1heUNsZWFyKSB7XFxuICB2YXIgZGlyID0gYmlhcyB8fCAxXFxuICB2YXIgZm91bmQgPSBza2lwQXRvbWljSW5uZXIoZG9jLCBwb3MsIG9sZFBvcywgZGlyLCBtYXlDbGVhcikgfHxcXG4gICAgICAoIW1heUNsZWFyICYmIHNraXBBdG9taWNJbm5lcihkb2MsIHBvcywgb2xkUG9zLCBkaXIsIHRydWUpKSB8fFxcbiAgICAgIHNraXBBdG9taWNJbm5lcihkb2MsIHBvcywgb2xkUG9zLCAtZGlyLCBtYXlDbGVhcikgfHxcXG4gICAgICAoIW1heUNsZWFyICYmIHNraXBBdG9taWNJbm5lcihkb2MsIHBvcywgb2xkUG9zLCAtZGlyLCB0cnVlKSlcXG4gIGlmICghZm91bmQpIHtcXG4gICAgZG9jLmNhbnRFZGl0ID0gdHJ1ZVxcbiAgICByZXR1cm4gUG9zKGRvYy5maXJzdCwgMClcXG4gIH1cXG4gIHJldHVybiBmb3VuZFxcbn1cXG5cXG5mdW5jdGlvbiBtb3ZlUG9zKGRvYywgcG9zLCBkaXIsIGxpbmUpIHtcXG4gIGlmIChkaXIgPCAwICYmIHBvcy5jaCA9PSAwKSB7XFxuICAgIGlmIChwb3MubGluZSA+IGRvYy5maXJzdCkgeyByZXR1cm4gY2xpcFBvcyhkb2MsIFBvcyhwb3MubGluZSAtIDEpKSB9XFxuICAgIGVsc2UgeyByZXR1cm4gbnVsbCB9XFxuICB9IGVsc2UgaWYgKGRpciA+IDAgJiYgcG9zLmNoID09IChsaW5lIHx8IGdldExpbmUoZG9jLCBwb3MubGluZSkpLnRleHQubGVuZ3RoKSB7XFxuICAgIGlmIChwb3MubGluZSA8IGRvYy5maXJzdCArIGRvYy5zaXplIC0gMSkgeyByZXR1cm4gUG9zKHBvcy5saW5lICsgMSwgMCkgfVxcbiAgICBlbHNlIHsgcmV0dXJuIG51bGwgfVxcbiAgfSBlbHNlIHtcXG4gICAgcmV0dXJuIG5ldyBQb3MocG9zLmxpbmUsIHBvcy5jaCArIGRpcilcXG4gIH1cXG59XFxuXFxuZnVuY3Rpb24gc2VsZWN0QWxsKGNtKSB7XFxuICBjbS5zZXRTZWxlY3Rpb24oUG9zKGNtLmZpcnN0TGluZSgpLCAwKSwgUG9zKGNtLmxhc3RMaW5lKCkpLCBzZWxfZG9udFNjcm9sbClcXG59XFxuXFxuLy8gVVBEQVRJTkdcXG5cXG4vLyBBbGxvdyBcXFwiYmVmb3JlQ2hhbmdlXFxcIiBldmVudCBoYW5kbGVycyB0byBpbmZsdWVuY2UgYSBjaGFuZ2VcXG5mdW5jdGlvbiBmaWx0ZXJDaGFuZ2UoZG9jLCBjaGFuZ2UsIHVwZGF0ZSkge1xcbiAgdmFyIG9iaiA9IHtcXG4gICAgY2FuY2VsZWQ6IGZhbHNlLFxcbiAgICBmcm9tOiBjaGFuZ2UuZnJvbSxcXG4gICAgdG86IGNoYW5nZS50byxcXG4gICAgdGV4dDogY2hhbmdlLnRleHQsXFxuICAgIG9yaWdpbjogY2hhbmdlLm9yaWdpbixcXG4gICAgY2FuY2VsOiBmdW5jdGlvbiAoKSB7IHJldHVybiBvYmouY2FuY2VsZWQgPSB0cnVlOyB9XFxuICB9XFxuICBpZiAodXBkYXRlKSB7IG9iai51cGRhdGUgPSBmdW5jdGlvbiAoZnJvbSwgdG8sIHRleHQsIG9yaWdpbikge1xcbiAgICBpZiAoZnJvbSkgeyBvYmouZnJvbSA9IGNsaXBQb3MoZG9jLCBmcm9tKSB9XFxuICAgIGlmICh0bykgeyBvYmoudG8gPSBjbGlwUG9zKGRvYywgdG8pIH1cXG4gICAgaWYgKHRleHQpIHsgb2JqLnRleHQgPSB0ZXh0IH1cXG4gICAgaWYgKG9yaWdpbiAhPT0gdW5kZWZpbmVkKSB7IG9iai5vcmlnaW4gPSBvcmlnaW4gfVxcbiAgfSB9XFxuICBzaWduYWwoZG9jLCBcXFwiYmVmb3JlQ2hhbmdlXFxcIiwgZG9jLCBvYmopXFxuICBpZiAoZG9jLmNtKSB7IHNpZ25hbChkb2MuY20sIFxcXCJiZWZvcmVDaGFuZ2VcXFwiLCBkb2MuY20sIG9iaikgfVxcblxcbiAgaWYgKG9iai5jYW5jZWxlZCkgeyByZXR1cm4gbnVsbCB9XFxuICByZXR1cm4ge2Zyb206IG9iai5mcm9tLCB0bzogb2JqLnRvLCB0ZXh0OiBvYmoudGV4dCwgb3JpZ2luOiBvYmoub3JpZ2lufVxcbn1cXG5cXG4vLyBBcHBseSBhIGNoYW5nZSB0byBhIGRvY3VtZW50LCBhbmQgYWRkIGl0IHRvIHRoZSBkb2N1bWVudCdzXFxuLy8gaGlzdG9yeSwgYW5kIHByb3BhZ2F0aW5nIGl0IHRvIGFsbCBsaW5rZWQgZG9jdW1lbnRzLlxcbmZ1bmN0aW9uIG1ha2VDaGFuZ2UoZG9jLCBjaGFuZ2UsIGlnbm9yZVJlYWRPbmx5KSB7XFxuICBpZiAoZG9jLmNtKSB7XFxuICAgIGlmICghZG9jLmNtLmN1ck9wKSB7IHJldHVybiBvcGVyYXRpb24oZG9jLmNtLCBtYWtlQ2hhbmdlKShkb2MsIGNoYW5nZSwgaWdub3JlUmVhZE9ubHkpIH1cXG4gICAgaWYgKGRvYy5jbS5zdGF0ZS5zdXBwcmVzc0VkaXRzKSB7IHJldHVybiB9XFxuICB9XFxuXFxuICBpZiAoaGFzSGFuZGxlcihkb2MsIFxcXCJiZWZvcmVDaGFuZ2VcXFwiKSB8fCBkb2MuY20gJiYgaGFzSGFuZGxlcihkb2MuY20sIFxcXCJiZWZvcmVDaGFuZ2VcXFwiKSkge1xcbiAgICBjaGFuZ2UgPSBmaWx0ZXJDaGFuZ2UoZG9jLCBjaGFuZ2UsIHRydWUpXFxuICAgIGlmICghY2hhbmdlKSB7IHJldHVybiB9XFxuICB9XFxuXFxuICAvLyBQb3NzaWJseSBzcGxpdCBvciBzdXBwcmVzcyB0aGUgdXBkYXRlIGJhc2VkIG9uIHRoZSBwcmVzZW5jZVxcbiAgLy8gb2YgcmVhZC1vbmx5IHNwYW5zIGluIGl0cyByYW5nZS5cXG4gIHZhciBzcGxpdCA9IHNhd1JlYWRPbmx5U3BhbnMgJiYgIWlnbm9yZVJlYWRPbmx5ICYmIHJlbW92ZVJlYWRPbmx5UmFuZ2VzKGRvYywgY2hhbmdlLmZyb20sIGNoYW5nZS50bylcXG4gIGlmIChzcGxpdCkge1xcbiAgICBmb3IgKHZhciBpID0gc3BsaXQubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpXFxuICAgICAgeyBtYWtlQ2hhbmdlSW5uZXIoZG9jLCB7ZnJvbTogc3BsaXRbaV0uZnJvbSwgdG86IHNwbGl0W2ldLnRvLCB0ZXh0OiBpID8gW1xcXCJcXFwiXSA6IGNoYW5nZS50ZXh0fSkgfVxcbiAgfSBlbHNlIHtcXG4gICAgbWFrZUNoYW5nZUlubmVyKGRvYywgY2hhbmdlKVxcbiAgfVxcbn1cXG5cXG5mdW5jdGlvbiBtYWtlQ2hhbmdlSW5uZXIoZG9jLCBjaGFuZ2UpIHtcXG4gIGlmIChjaGFuZ2UudGV4dC5sZW5ndGggPT0gMSAmJiBjaGFuZ2UudGV4dFswXSA9PSBcXFwiXFxcIiAmJiBjbXAoY2hhbmdlLmZyb20sIGNoYW5nZS50bykgPT0gMCkgeyByZXR1cm4gfVxcbiAgdmFyIHNlbEFmdGVyID0gY29tcHV0ZVNlbEFmdGVyQ2hhbmdlKGRvYywgY2hhbmdlKVxcbiAgYWRkQ2hhbmdlVG9IaXN0b3J5KGRvYywgY2hhbmdlLCBzZWxBZnRlciwgZG9jLmNtID8gZG9jLmNtLmN1ck9wLmlkIDogTmFOKVxcblxcbiAgbWFrZUNoYW5nZVNpbmdsZURvYyhkb2MsIGNoYW5nZSwgc2VsQWZ0ZXIsIHN0cmV0Y2hTcGFuc092ZXJDaGFuZ2UoZG9jLCBjaGFuZ2UpKVxcbiAgdmFyIHJlYmFzZWQgPSBbXVxcblxcbiAgbGlua2VkRG9jcyhkb2MsIGZ1bmN0aW9uIChkb2MsIHNoYXJlZEhpc3QpIHtcXG4gICAgaWYgKCFzaGFyZWRIaXN0ICYmIGluZGV4T2YocmViYXNlZCwgZG9jLmhpc3RvcnkpID09IC0xKSB7XFxuICAgICAgcmViYXNlSGlzdChkb2MuaGlzdG9yeSwgY2hhbmdlKVxcbiAgICAgIHJlYmFzZWQucHVzaChkb2MuaGlzdG9yeSlcXG4gICAgfVxcbiAgICBtYWtlQ2hhbmdlU2luZ2xlRG9jKGRvYywgY2hhbmdlLCBudWxsLCBzdHJldGNoU3BhbnNPdmVyQ2hhbmdlKGRvYywgY2hhbmdlKSlcXG4gIH0pXFxufVxcblxcbi8vIFJldmVydCBhIGNoYW5nZSBzdG9yZWQgaW4gYSBkb2N1bWVudCdzIGhpc3RvcnkuXFxuZnVuY3Rpb24gbWFrZUNoYW5nZUZyb21IaXN0b3J5KGRvYywgdHlwZSwgYWxsb3dTZWxlY3Rpb25Pbmx5KSB7XFxuICBpZiAoZG9jLmNtICYmIGRvYy5jbS5zdGF0ZS5zdXBwcmVzc0VkaXRzICYmICFhbGxvd1NlbGVjdGlvbk9ubHkpIHsgcmV0dXJuIH1cXG5cXG4gIHZhciBoaXN0ID0gZG9jLmhpc3RvcnksIGV2ZW50LCBzZWxBZnRlciA9IGRvYy5zZWxcXG4gIHZhciBzb3VyY2UgPSB0eXBlID09IFxcXCJ1bmRvXFxcIiA/IGhpc3QuZG9uZSA6IGhpc3QudW5kb25lLCBkZXN0ID0gdHlwZSA9PSBcXFwidW5kb1xcXCIgPyBoaXN0LnVuZG9uZSA6IGhpc3QuZG9uZVxcblxcbiAgLy8gVmVyaWZ5IHRoYXQgdGhlcmUgaXMgYSB1c2VhYmxlIGV2ZW50IChzbyB0aGF0IGN0cmwteiB3b24ndFxcbiAgLy8gbmVlZGxlc3NseSBjbGVhciBzZWxlY3Rpb24gZXZlbnRzKVxcbiAgdmFyIGkgPSAwXFxuICBmb3IgKDsgaSA8IHNvdXJjZS5sZW5ndGg7IGkrKykge1xcbiAgICBldmVudCA9IHNvdXJjZVtpXVxcbiAgICBpZiAoYWxsb3dTZWxlY3Rpb25Pbmx5ID8gZXZlbnQucmFuZ2VzICYmICFldmVudC5lcXVhbHMoZG9jLnNlbCkgOiAhZXZlbnQucmFuZ2VzKVxcbiAgICAgIHsgYnJlYWsgfVxcbiAgfVxcbiAgaWYgKGkgPT0gc291cmNlLmxlbmd0aCkgeyByZXR1cm4gfVxcbiAgaGlzdC5sYXN0T3JpZ2luID0gaGlzdC5sYXN0U2VsT3JpZ2luID0gbnVsbFxcblxcbiAgZm9yICg7Oykge1xcbiAgICBldmVudCA9IHNvdXJjZS5wb3AoKVxcbiAgICBpZiAoZXZlbnQucmFuZ2VzKSB7XFxuICAgICAgcHVzaFNlbGVjdGlvblRvSGlzdG9yeShldmVudCwgZGVzdClcXG4gICAgICBpZiAoYWxsb3dTZWxlY3Rpb25Pbmx5ICYmICFldmVudC5lcXVhbHMoZG9jLnNlbCkpIHtcXG4gICAgICAgIHNldFNlbGVjdGlvbihkb2MsIGV2ZW50LCB7Y2xlYXJSZWRvOiBmYWxzZX0pXFxuICAgICAgICByZXR1cm5cXG4gICAgICB9XFxuICAgICAgc2VsQWZ0ZXIgPSBldmVudFxcbiAgICB9XFxuICAgIGVsc2UgeyBicmVhayB9XFxuICB9XFxuXFxuICAvLyBCdWlsZCB1cCBhIHJldmVyc2UgY2hhbmdlIG9iamVjdCB0byBhZGQgdG8gdGhlIG9wcG9zaXRlIGhpc3RvcnlcXG4gIC8vIHN0YWNrIChyZWRvIHdoZW4gdW5kb2luZywgYW5kIHZpY2UgdmVyc2EpLlxcbiAgdmFyIGFudGlDaGFuZ2VzID0gW11cXG4gIHB1c2hTZWxlY3Rpb25Ub0hpc3Rvcnkoc2VsQWZ0ZXIsIGRlc3QpXFxuICBkZXN0LnB1c2goe2NoYW5nZXM6IGFudGlDaGFuZ2VzLCBnZW5lcmF0aW9uOiBoaXN0LmdlbmVyYXRpb259KVxcbiAgaGlzdC5nZW5lcmF0aW9uID0gZXZlbnQuZ2VuZXJhdGlvbiB8fCArK2hpc3QubWF4R2VuZXJhdGlvblxcblxcbiAgdmFyIGZpbHRlciA9IGhhc0hhbmRsZXIoZG9jLCBcXFwiYmVmb3JlQ2hhbmdlXFxcIikgfHwgZG9jLmNtICYmIGhhc0hhbmRsZXIoZG9jLmNtLCBcXFwiYmVmb3JlQ2hhbmdlXFxcIilcXG5cXG4gIHZhciBsb29wID0gZnVuY3Rpb24gKCBpICkge1xcbiAgICB2YXIgY2hhbmdlID0gZXZlbnQuY2hhbmdlc1tpXVxcbiAgICBjaGFuZ2Uub3JpZ2luID0gdHlwZVxcbiAgICBpZiAoZmlsdGVyICYmICFmaWx0ZXJDaGFuZ2UoZG9jLCBjaGFuZ2UsIGZhbHNlKSkge1xcbiAgICAgIHNvdXJjZS5sZW5ndGggPSAwXFxuICAgICAgcmV0dXJuIHt9XFxuICAgIH1cXG5cXG4gICAgYW50aUNoYW5nZXMucHVzaChoaXN0b3J5Q2hhbmdlRnJvbUNoYW5nZShkb2MsIGNoYW5nZSkpXFxuXFxuICAgIHZhciBhZnRlciA9IGkgPyBjb21wdXRlU2VsQWZ0ZXJDaGFuZ2UoZG9jLCBjaGFuZ2UpIDogbHN0KHNvdXJjZSlcXG4gICAgbWFrZUNoYW5nZVNpbmdsZURvYyhkb2MsIGNoYW5nZSwgYWZ0ZXIsIG1lcmdlT2xkU3BhbnMoZG9jLCBjaGFuZ2UpKVxcbiAgICBpZiAoIWkgJiYgZG9jLmNtKSB7IGRvYy5jbS5zY3JvbGxJbnRvVmlldyh7ZnJvbTogY2hhbmdlLmZyb20sIHRvOiBjaGFuZ2VFbmQoY2hhbmdlKX0pIH1cXG4gICAgdmFyIHJlYmFzZWQgPSBbXVxcblxcbiAgICAvLyBQcm9wYWdhdGUgdG8gdGhlIGxpbmtlZCBkb2N1bWVudHNcXG4gICAgbGlua2VkRG9jcyhkb2MsIGZ1bmN0aW9uIChkb2MsIHNoYXJlZEhpc3QpIHtcXG4gICAgICBpZiAoIXNoYXJlZEhpc3QgJiYgaW5kZXhPZihyZWJhc2VkLCBkb2MuaGlzdG9yeSkgPT0gLTEpIHtcXG4gICAgICAgIHJlYmFzZUhpc3QoZG9jLmhpc3RvcnksIGNoYW5nZSlcXG4gICAgICAgIHJlYmFzZWQucHVzaChkb2MuaGlzdG9yeSlcXG4gICAgICB9XFxuICAgICAgbWFrZUNoYW5nZVNpbmdsZURvYyhkb2MsIGNoYW5nZSwgbnVsbCwgbWVyZ2VPbGRTcGFucyhkb2MsIGNoYW5nZSkpXFxuICAgIH0pXFxuICB9O1xcblxcbiAgZm9yICh2YXIgaSQxID0gZXZlbnQuY2hhbmdlcy5sZW5ndGggLSAxOyBpJDEgPj0gMDsgLS1pJDEpIHtcXG4gICAgdmFyIHJldHVybmVkID0gbG9vcCggaSQxICk7XFxuXFxuICAgIGlmICggcmV0dXJuZWQgKSByZXR1cm4gcmV0dXJuZWQudjtcXG4gIH1cXG59XFxuXFxuLy8gU3ViLXZpZXdzIG5lZWQgdGhlaXIgbGluZSBudW1iZXJzIHNoaWZ0ZWQgd2hlbiB0ZXh0IGlzIGFkZGVkXFxuLy8gYWJvdmUgb3IgYmVsb3cgdGhlbSBpbiB0aGUgcGFyZW50IGRvY3VtZW50LlxcbmZ1bmN0aW9uIHNoaWZ0RG9jKGRvYywgZGlzdGFuY2UpIHtcXG4gIGlmIChkaXN0YW5jZSA9PSAwKSB7IHJldHVybiB9XFxuICBkb2MuZmlyc3QgKz0gZGlzdGFuY2VcXG4gIGRvYy5zZWwgPSBuZXcgU2VsZWN0aW9uKG1hcChkb2Muc2VsLnJhbmdlcywgZnVuY3Rpb24gKHJhbmdlKSB7IHJldHVybiBuZXcgUmFuZ2UoXFxuICAgIFBvcyhyYW5nZS5hbmNob3IubGluZSArIGRpc3RhbmNlLCByYW5nZS5hbmNob3IuY2gpLFxcbiAgICBQb3MocmFuZ2UuaGVhZC5saW5lICsgZGlzdGFuY2UsIHJhbmdlLmhlYWQuY2gpXFxuICApOyB9KSwgZG9jLnNlbC5wcmltSW5kZXgpXFxuICBpZiAoZG9jLmNtKSB7XFxuICAgIHJlZ0NoYW5nZShkb2MuY20sIGRvYy5maXJzdCwgZG9jLmZpcnN0IC0gZGlzdGFuY2UsIGRpc3RhbmNlKVxcbiAgICBmb3IgKHZhciBkID0gZG9jLmNtLmRpc3BsYXksIGwgPSBkLnZpZXdGcm9tOyBsIDwgZC52aWV3VG87IGwrKylcXG4gICAgICB7IHJlZ0xpbmVDaGFuZ2UoZG9jLmNtLCBsLCBcXFwiZ3V0dGVyXFxcIikgfVxcbiAgfVxcbn1cXG5cXG4vLyBNb3JlIGxvd2VyLWxldmVsIGNoYW5nZSBmdW5jdGlvbiwgaGFuZGxpbmcgb25seSBhIHNpbmdsZSBkb2N1bWVudFxcbi8vIChub3QgbGlua2VkIG9uZXMpLlxcbmZ1bmN0aW9uIG1ha2VDaGFuZ2VTaW5nbGVEb2MoZG9jLCBjaGFuZ2UsIHNlbEFmdGVyLCBzcGFucykge1xcbiAgaWYgKGRvYy5jbSAmJiAhZG9jLmNtLmN1ck9wKVxcbiAgICB7IHJldHVybiBvcGVyYXRpb24oZG9jLmNtLCBtYWtlQ2hhbmdlU2luZ2xlRG9jKShkb2MsIGNoYW5nZSwgc2VsQWZ0ZXIsIHNwYW5zKSB9XFxuXFxuICBpZiAoY2hhbmdlLnRvLmxpbmUgPCBkb2MuZmlyc3QpIHtcXG4gICAgc2hpZnREb2MoZG9jLCBjaGFuZ2UudGV4dC5sZW5ndGggLSAxIC0gKGNoYW5nZS50by5saW5lIC0gY2hhbmdlLmZyb20ubGluZSkpXFxuICAgIHJldHVyblxcbiAgfVxcbiAgaWYgKGNoYW5nZS5mcm9tLmxpbmUgPiBkb2MubGFzdExpbmUoKSkgeyByZXR1cm4gfVxcblxcbiAgLy8gQ2xpcCB0aGUgY2hhbmdlIHRvIHRoZSBzaXplIG9mIHRoaXMgZG9jXFxuICBpZiAoY2hhbmdlLmZyb20ubGluZSA8IGRvYy5maXJzdCkge1xcbiAgICB2YXIgc2hpZnQgPSBjaGFuZ2UudGV4dC5sZW5ndGggLSAxIC0gKGRvYy5maXJzdCAtIGNoYW5nZS5mcm9tLmxpbmUpXFxuICAgIHNoaWZ0RG9jKGRvYywgc2hpZnQpXFxuICAgIGNoYW5nZSA9IHtmcm9tOiBQb3MoZG9jLmZpcnN0LCAwKSwgdG86IFBvcyhjaGFuZ2UudG8ubGluZSArIHNoaWZ0LCBjaGFuZ2UudG8uY2gpLFxcbiAgICAgICAgICAgICAgdGV4dDogW2xzdChjaGFuZ2UudGV4dCldLCBvcmlnaW46IGNoYW5nZS5vcmlnaW59XFxuICB9XFxuICB2YXIgbGFzdCA9IGRvYy5sYXN0TGluZSgpXFxuICBpZiAoY2hhbmdlLnRvLmxpbmUgPiBsYXN0KSB7XFxuICAgIGNoYW5nZSA9IHtmcm9tOiBjaGFuZ2UuZnJvbSwgdG86IFBvcyhsYXN0LCBnZXRMaW5lKGRvYywgbGFzdCkudGV4dC5sZW5ndGgpLFxcbiAgICAgICAgICAgICAgdGV4dDogW2NoYW5nZS50ZXh0WzBdXSwgb3JpZ2luOiBjaGFuZ2Uub3JpZ2lufVxcbiAgfVxcblxcbiAgY2hhbmdlLnJlbW92ZWQgPSBnZXRCZXR3ZWVuKGRvYywgY2hhbmdlLmZyb20sIGNoYW5nZS50bylcXG5cXG4gIGlmICghc2VsQWZ0ZXIpIHsgc2VsQWZ0ZXIgPSBjb21wdXRlU2VsQWZ0ZXJDaGFuZ2UoZG9jLCBjaGFuZ2UpIH1cXG4gIGlmIChkb2MuY20pIHsgbWFrZUNoYW5nZVNpbmdsZURvY0luRWRpdG9yKGRvYy5jbSwgY2hhbmdlLCBzcGFucykgfVxcbiAgZWxzZSB7IHVwZGF0ZURvYyhkb2MsIGNoYW5nZSwgc3BhbnMpIH1cXG4gIHNldFNlbGVjdGlvbk5vVW5kbyhkb2MsIHNlbEFmdGVyLCBzZWxfZG9udFNjcm9sbClcXG59XFxuXFxuLy8gSGFuZGxlIHRoZSBpbnRlcmFjdGlvbiBvZiBhIGNoYW5nZSB0byBhIGRvY3VtZW50IHdpdGggdGhlIGVkaXRvclxcbi8vIHRoYXQgdGhpcyBkb2N1bWVudCBpcyBwYXJ0IG9mLlxcbmZ1bmN0aW9uIG1ha2VDaGFuZ2VTaW5nbGVEb2NJbkVkaXRvcihjbSwgY2hhbmdlLCBzcGFucykge1xcbiAgdmFyIGRvYyA9IGNtLmRvYywgZGlzcGxheSA9IGNtLmRpc3BsYXksIGZyb20gPSBjaGFuZ2UuZnJvbSwgdG8gPSBjaGFuZ2UudG9cXG5cXG4gIHZhciByZWNvbXB1dGVNYXhMZW5ndGggPSBmYWxzZSwgY2hlY2tXaWR0aFN0YXJ0ID0gZnJvbS5saW5lXFxuICBpZiAoIWNtLm9wdGlvbnMubGluZVdyYXBwaW5nKSB7XFxuICAgIGNoZWNrV2lkdGhTdGFydCA9IGxpbmVObyh2aXN1YWxMaW5lKGdldExpbmUoZG9jLCBmcm9tLmxpbmUpKSlcXG4gICAgZG9jLml0ZXIoY2hlY2tXaWR0aFN0YXJ0LCB0by5saW5lICsgMSwgZnVuY3Rpb24gKGxpbmUpIHtcXG4gICAgICBpZiAobGluZSA9PSBkaXNwbGF5Lm1heExpbmUpIHtcXG4gICAgICAgIHJlY29tcHV0ZU1heExlbmd0aCA9IHRydWVcXG4gICAgICAgIHJldHVybiB0cnVlXFxuICAgICAgfVxcbiAgICB9KVxcbiAgfVxcblxcbiAgaWYgKGRvYy5zZWwuY29udGFpbnMoY2hhbmdlLmZyb20sIGNoYW5nZS50bykgPiAtMSlcXG4gICAgeyBzaWduYWxDdXJzb3JBY3Rpdml0eShjbSkgfVxcblxcbiAgdXBkYXRlRG9jKGRvYywgY2hhbmdlLCBzcGFucywgZXN0aW1hdGVIZWlnaHQoY20pKVxcblxcbiAgaWYgKCFjbS5vcHRpb25zLmxpbmVXcmFwcGluZykge1xcbiAgICBkb2MuaXRlcihjaGVja1dpZHRoU3RhcnQsIGZyb20ubGluZSArIGNoYW5nZS50ZXh0Lmxlbmd0aCwgZnVuY3Rpb24gKGxpbmUpIHtcXG4gICAgICB2YXIgbGVuID0gbGluZUxlbmd0aChsaW5lKVxcbiAgICAgIGlmIChsZW4gPiBkaXNwbGF5Lm1heExpbmVMZW5ndGgpIHtcXG4gICAgICAgIGRpc3BsYXkubWF4TGluZSA9IGxpbmVcXG4gICAgICAgIGRpc3BsYXkubWF4TGluZUxlbmd0aCA9IGxlblxcbiAgICAgICAgZGlzcGxheS5tYXhMaW5lQ2hhbmdlZCA9IHRydWVcXG4gICAgICAgIHJlY29tcHV0ZU1heExlbmd0aCA9IGZhbHNlXFxuICAgICAgfVxcbiAgICB9KVxcbiAgICBpZiAocmVjb21wdXRlTWF4TGVuZ3RoKSB7IGNtLmN1ck9wLnVwZGF0ZU1heExpbmUgPSB0cnVlIH1cXG4gIH1cXG5cXG4gIC8vIEFkanVzdCBmcm9udGllciwgc2NoZWR1bGUgd29ya2VyXFxuICBkb2MuZnJvbnRpZXIgPSBNYXRoLm1pbihkb2MuZnJvbnRpZXIsIGZyb20ubGluZSlcXG4gIHN0YXJ0V29ya2VyKGNtLCA0MDApXFxuXFxuICB2YXIgbGVuZGlmZiA9IGNoYW5nZS50ZXh0Lmxlbmd0aCAtICh0by5saW5lIC0gZnJvbS5saW5lKSAtIDFcXG4gIC8vIFJlbWVtYmVyIHRoYXQgdGhlc2UgbGluZXMgY2hhbmdlZCwgZm9yIHVwZGF0aW5nIHRoZSBkaXNwbGF5XFxuICBpZiAoY2hhbmdlLmZ1bGwpXFxuICAgIHsgcmVnQ2hhbmdlKGNtKSB9XFxuICBlbHNlIGlmIChmcm9tLmxpbmUgPT0gdG8ubGluZSAmJiBjaGFuZ2UudGV4dC5sZW5ndGggPT0gMSAmJiAhaXNXaG9sZUxpbmVVcGRhdGUoY20uZG9jLCBjaGFuZ2UpKVxcbiAgICB7IHJlZ0xpbmVDaGFuZ2UoY20sIGZyb20ubGluZSwgXFxcInRleHRcXFwiKSB9XFxuICBlbHNlXFxuICAgIHsgcmVnQ2hhbmdlKGNtLCBmcm9tLmxpbmUsIHRvLmxpbmUgKyAxLCBsZW5kaWZmKSB9XFxuXFxuICB2YXIgY2hhbmdlc0hhbmRsZXIgPSBoYXNIYW5kbGVyKGNtLCBcXFwiY2hhbmdlc1xcXCIpLCBjaGFuZ2VIYW5kbGVyID0gaGFzSGFuZGxlcihjbSwgXFxcImNoYW5nZVxcXCIpXFxuICBpZiAoY2hhbmdlSGFuZGxlciB8fCBjaGFuZ2VzSGFuZGxlcikge1xcbiAgICB2YXIgb2JqID0ge1xcbiAgICAgIGZyb206IGZyb20sIHRvOiB0byxcXG4gICAgICB0ZXh0OiBjaGFuZ2UudGV4dCxcXG4gICAgICByZW1vdmVkOiBjaGFuZ2UucmVtb3ZlZCxcXG4gICAgICBvcmlnaW46IGNoYW5nZS5vcmlnaW5cXG4gICAgfVxcbiAgICBpZiAoY2hhbmdlSGFuZGxlcikgeyBzaWduYWxMYXRlcihjbSwgXFxcImNoYW5nZVxcXCIsIGNtLCBvYmopIH1cXG4gICAgaWYgKGNoYW5nZXNIYW5kbGVyKSB7IChjbS5jdXJPcC5jaGFuZ2VPYmpzIHx8IChjbS5jdXJPcC5jaGFuZ2VPYmpzID0gW10pKS5wdXNoKG9iaikgfVxcbiAgfVxcbiAgY20uZGlzcGxheS5zZWxGb3JDb250ZXh0TWVudSA9IG51bGxcXG59XFxuXFxuZnVuY3Rpb24gcmVwbGFjZVJhbmdlKGRvYywgY29kZSwgZnJvbSwgdG8sIG9yaWdpbikge1xcbiAgaWYgKCF0bykgeyB0byA9IGZyb20gfVxcbiAgaWYgKGNtcCh0bywgZnJvbSkgPCAwKSB7IHZhciB0bXAgPSB0bzsgdG8gPSBmcm9tOyBmcm9tID0gdG1wIH1cXG4gIGlmICh0eXBlb2YgY29kZSA9PSBcXFwic3RyaW5nXFxcIikgeyBjb2RlID0gZG9jLnNwbGl0TGluZXMoY29kZSkgfVxcbiAgbWFrZUNoYW5nZShkb2MsIHtmcm9tOiBmcm9tLCB0bzogdG8sIHRleHQ6IGNvZGUsIG9yaWdpbjogb3JpZ2lufSlcXG59XFxuXFxuLy8gUmViYXNpbmcvcmVzZXR0aW5nIGhpc3RvcnkgdG8gZGVhbCB3aXRoIGV4dGVybmFsbHktc291cmNlZCBjaGFuZ2VzXFxuXFxuZnVuY3Rpb24gcmViYXNlSGlzdFNlbFNpbmdsZShwb3MsIGZyb20sIHRvLCBkaWZmKSB7XFxuICBpZiAodG8gPCBwb3MubGluZSkge1xcbiAgICBwb3MubGluZSArPSBkaWZmXFxuICB9IGVsc2UgaWYgKGZyb20gPCBwb3MubGluZSkge1xcbiAgICBwb3MubGluZSA9IGZyb21cXG4gICAgcG9zLmNoID0gMFxcbiAgfVxcbn1cXG5cXG4vLyBUcmllcyB0byByZWJhc2UgYW4gYXJyYXkgb2YgaGlzdG9yeSBldmVudHMgZ2l2ZW4gYSBjaGFuZ2UgaW4gdGhlXFxuLy8gZG9jdW1lbnQuIElmIHRoZSBjaGFuZ2UgdG91Y2hlcyB0aGUgc2FtZSBsaW5lcyBhcyB0aGUgZXZlbnQsIHRoZVxcbi8vIGV2ZW50LCBhbmQgZXZlcnl0aGluZyAnYmVoaW5kJyBpdCwgaXMgZGlzY2FyZGVkLiBJZiB0aGUgY2hhbmdlIGlzXFxuLy8gYmVmb3JlIHRoZSBldmVudCwgdGhlIGV2ZW50J3MgcG9zaXRpb25zIGFyZSB1cGRhdGVkLiBVc2VzIGFcXG4vLyBjb3B5LW9uLXdyaXRlIHNjaGVtZSBmb3IgdGhlIHBvc2l0aW9ucywgdG8gYXZvaWQgaGF2aW5nIHRvXFxuLy8gcmVhbGxvY2F0ZSB0aGVtIGFsbCBvbiBldmVyeSByZWJhc2UsIGJ1dCBhbHNvIGF2b2lkIHByb2JsZW1zIHdpdGhcXG4vLyBzaGFyZWQgcG9zaXRpb24gb2JqZWN0cyBiZWluZyB1bnNhZmVseSB1cGRhdGVkLlxcbmZ1bmN0aW9uIHJlYmFzZUhpc3RBcnJheShhcnJheSwgZnJvbSwgdG8sIGRpZmYpIHtcXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyArK2kpIHtcXG4gICAgdmFyIHN1YiA9IGFycmF5W2ldLCBvayA9IHRydWVcXG4gICAgaWYgKHN1Yi5yYW5nZXMpIHtcXG4gICAgICBpZiAoIXN1Yi5jb3BpZWQpIHsgc3ViID0gYXJyYXlbaV0gPSBzdWIuZGVlcENvcHkoKTsgc3ViLmNvcGllZCA9IHRydWUgfVxcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgc3ViLnJhbmdlcy5sZW5ndGg7IGorKykge1xcbiAgICAgICAgcmViYXNlSGlzdFNlbFNpbmdsZShzdWIucmFuZ2VzW2pdLmFuY2hvciwgZnJvbSwgdG8sIGRpZmYpXFxuICAgICAgICByZWJhc2VIaXN0U2VsU2luZ2xlKHN1Yi5yYW5nZXNbal0uaGVhZCwgZnJvbSwgdG8sIGRpZmYpXFxuICAgICAgfVxcbiAgICAgIGNvbnRpbnVlXFxuICAgIH1cXG4gICAgZm9yICh2YXIgaiQxID0gMDsgaiQxIDwgc3ViLmNoYW5nZXMubGVuZ3RoOyArK2okMSkge1xcbiAgICAgIHZhciBjdXIgPSBzdWIuY2hhbmdlc1tqJDFdXFxuICAgICAgaWYgKHRvIDwgY3VyLmZyb20ubGluZSkge1xcbiAgICAgICAgY3VyLmZyb20gPSBQb3MoY3VyLmZyb20ubGluZSArIGRpZmYsIGN1ci5mcm9tLmNoKVxcbiAgICAgICAgY3VyLnRvID0gUG9zKGN1ci50by5saW5lICsgZGlmZiwgY3VyLnRvLmNoKVxcbiAgICAgIH0gZWxzZSBpZiAoZnJvbSA8PSBjdXIudG8ubGluZSkge1xcbiAgICAgICAgb2sgPSBmYWxzZVxcbiAgICAgICAgYnJlYWtcXG4gICAgICB9XFxuICAgIH1cXG4gICAgaWYgKCFvaykge1xcbiAgICAgIGFycmF5LnNwbGljZSgwLCBpICsgMSlcXG4gICAgICBpID0gMFxcbiAgICB9XFxuICB9XFxufVxcblxcbmZ1bmN0aW9uIHJlYmFzZUhpc3QoaGlzdCwgY2hhbmdlKSB7XFxuICB2YXIgZnJvbSA9IGNoYW5nZS5mcm9tLmxpbmUsIHRvID0gY2hhbmdlLnRvLmxpbmUsIGRpZmYgPSBjaGFuZ2UudGV4dC5sZW5ndGggLSAodG8gLSBmcm9tKSAtIDFcXG4gIHJlYmFzZUhpc3RBcnJheShoaXN0LmRvbmUsIGZyb20sIHRvLCBkaWZmKVxcbiAgcmViYXNlSGlzdEFycmF5KGhpc3QudW5kb25lLCBmcm9tLCB0bywgZGlmZilcXG59XFxuXFxuLy8gVXRpbGl0eSBmb3IgYXBwbHlpbmcgYSBjaGFuZ2UgdG8gYSBsaW5lIGJ5IGhhbmRsZSBvciBudW1iZXIsXFxuLy8gcmV0dXJuaW5nIHRoZSBudW1iZXIgYW5kIG9wdGlvbmFsbHkgcmVnaXN0ZXJpbmcgdGhlIGxpbmUgYXNcXG4vLyBjaGFuZ2VkLlxcbmZ1bmN0aW9uIGNoYW5nZUxpbmUoZG9jLCBoYW5kbGUsIGNoYW5nZVR5cGUsIG9wKSB7XFxuICB2YXIgbm8gPSBoYW5kbGUsIGxpbmUgPSBoYW5kbGVcXG4gIGlmICh0eXBlb2YgaGFuZGxlID09IFxcXCJudW1iZXJcXFwiKSB7IGxpbmUgPSBnZXRMaW5lKGRvYywgY2xpcExpbmUoZG9jLCBoYW5kbGUpKSB9XFxuICBlbHNlIHsgbm8gPSBsaW5lTm8oaGFuZGxlKSB9XFxuICBpZiAobm8gPT0gbnVsbCkgeyByZXR1cm4gbnVsbCB9XFxuICBpZiAob3AobGluZSwgbm8pICYmIGRvYy5jbSkgeyByZWdMaW5lQ2hhbmdlKGRvYy5jbSwgbm8sIGNoYW5nZVR5cGUpIH1cXG4gIHJldHVybiBsaW5lXFxufVxcblxcbi8vIFRoZSBkb2N1bWVudCBpcyByZXByZXNlbnRlZCBhcyBhIEJUcmVlIGNvbnNpc3Rpbmcgb2YgbGVhdmVzLCB3aXRoXFxuLy8gY2h1bmsgb2YgbGluZXMgaW4gdGhlbSwgYW5kIGJyYW5jaGVzLCB3aXRoIHVwIHRvIHRlbiBsZWF2ZXMgb3JcXG4vLyBvdGhlciBicmFuY2ggbm9kZXMgYmVsb3cgdGhlbS4gVGhlIHRvcCBub2RlIGlzIGFsd2F5cyBhIGJyYW5jaFxcbi8vIG5vZGUsIGFuZCBpcyB0aGUgZG9jdW1lbnQgb2JqZWN0IGl0c2VsZiAobWVhbmluZyBpdCBoYXNcXG4vLyBhZGRpdGlvbmFsIG1ldGhvZHMgYW5kIHByb3BlcnRpZXMpLlxcbi8vXFxuLy8gQWxsIG5vZGVzIGhhdmUgcGFyZW50IGxpbmtzLiBUaGUgdHJlZSBpcyB1c2VkIGJvdGggdG8gZ28gZnJvbVxcbi8vIGxpbmUgbnVtYmVycyB0byBsaW5lIG9iamVjdHMsIGFuZCB0byBnbyBmcm9tIG9iamVjdHMgdG8gbnVtYmVycy5cXG4vLyBJdCBhbHNvIGluZGV4ZXMgYnkgaGVpZ2h0LCBhbmQgaXMgdXNlZCB0byBjb252ZXJ0IGJldHdlZW4gaGVpZ2h0XFxuLy8gYW5kIGxpbmUgb2JqZWN0LCBhbmQgdG8gZmluZCB0aGUgdG90YWwgaGVpZ2h0IG9mIHRoZSBkb2N1bWVudC5cXG4vL1xcbi8vIFNlZSBhbHNvIGh0dHA6Ly9tYXJpam5oYXZlcmJla2UubmwvYmxvZy9jb2RlbWlycm9yLWxpbmUtdHJlZS5odG1sXFxuXFxudmFyIExlYWZDaHVuayA9IGZ1bmN0aW9uKGxpbmVzKSB7XFxuICB2YXIgdGhpcyQxID0gdGhpcztcXG5cXG4gIHRoaXMubGluZXMgPSBsaW5lc1xcbiAgdGhpcy5wYXJlbnQgPSBudWxsXFxuICB2YXIgaGVpZ2h0ID0gMFxcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7ICsraSkge1xcbiAgICBsaW5lc1tpXS5wYXJlbnQgPSB0aGlzJDFcXG4gICAgaGVpZ2h0ICs9IGxpbmVzW2ldLmhlaWdodFxcbiAgfVxcbiAgdGhpcy5oZWlnaHQgPSBoZWlnaHRcXG59O1xcblxcbkxlYWZDaHVuay5wcm90b3R5cGUuY2h1bmtTaXplID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5saW5lcy5sZW5ndGggfTtcXG5cXG4vLyBSZW1vdmUgdGhlIG4gbGluZXMgYXQgb2Zmc2V0ICdhdCcuXFxuTGVhZkNodW5rLnByb3RvdHlwZS5yZW1vdmVJbm5lciA9IGZ1bmN0aW9uIChhdCwgbikge1xcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcXG5cXG4gIGZvciAodmFyIGkgPSBhdCwgZSA9IGF0ICsgbjsgaSA8IGU7ICsraSkge1xcbiAgICB2YXIgbGluZSA9IHRoaXMkMS5saW5lc1tpXVxcbiAgICB0aGlzJDEuaGVpZ2h0IC09IGxpbmUuaGVpZ2h0XFxuICAgIGNsZWFuVXBMaW5lKGxpbmUpXFxuICAgIHNpZ25hbExhdGVyKGxpbmUsIFxcXCJkZWxldGVcXFwiKVxcbiAgfVxcbiAgdGhpcy5saW5lcy5zcGxpY2UoYXQsIG4pXFxufTtcXG5cXG4vLyBIZWxwZXIgdXNlZCB0byBjb2xsYXBzZSBhIHNtYWxsIGJyYW5jaCBpbnRvIGEgc2luZ2xlIGxlYWYuXFxuTGVhZkNodW5rLnByb3RvdHlwZS5jb2xsYXBzZSA9IGZ1bmN0aW9uIChsaW5lcykge1xcbiAgbGluZXMucHVzaC5hcHBseShsaW5lcywgdGhpcy5saW5lcylcXG59O1xcblxcbi8vIEluc2VydCB0aGUgZ2l2ZW4gYXJyYXkgb2YgbGluZXMgYXQgb2Zmc2V0ICdhdCcsIGNvdW50IHRoZW0gYXNcXG4vLyBoYXZpbmcgdGhlIGdpdmVuIGhlaWdodC5cXG5MZWFmQ2h1bmsucHJvdG90eXBlLmluc2VydElubmVyID0gZnVuY3Rpb24gKGF0LCBsaW5lcywgaGVpZ2h0KSB7XFxuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xcblxcbiAgdGhpcy5oZWlnaHQgKz0gaGVpZ2h0XFxuICB0aGlzLmxpbmVzID0gdGhpcy5saW5lcy5zbGljZSgwLCBhdCkuY29uY2F0KGxpbmVzKS5jb25jYXQodGhpcy5saW5lcy5zbGljZShhdCkpXFxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgKytpKSB7IGxpbmVzW2ldLnBhcmVudCA9IHRoaXMkMSB9XFxufTtcXG5cXG4vLyBVc2VkIHRvIGl0ZXJhdGUgb3ZlciBhIHBhcnQgb2YgdGhlIHRyZWUuXFxuTGVhZkNodW5rLnByb3RvdHlwZS5pdGVyTiA9IGZ1bmN0aW9uIChhdCwgbiwgb3ApIHtcXG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XFxuXFxuICBmb3IgKHZhciBlID0gYXQgKyBuOyBhdCA8IGU7ICsrYXQpXFxuICAgIHsgaWYgKG9wKHRoaXMkMS5saW5lc1thdF0pKSB7IHJldHVybiB0cnVlIH0gfVxcbn07XFxuXFxudmFyIEJyYW5jaENodW5rID0gZnVuY3Rpb24oY2hpbGRyZW4pIHtcXG4gIHZhciB0aGlzJDEgPSB0aGlzO1xcblxcbiAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuXFxuICB2YXIgc2l6ZSA9IDAsIGhlaWdodCA9IDBcXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyArK2kpIHtcXG4gICAgdmFyIGNoID0gY2hpbGRyZW5baV1cXG4gICAgc2l6ZSArPSBjaC5jaHVua1NpemUoKTsgaGVpZ2h0ICs9IGNoLmhlaWdodFxcbiAgICBjaC5wYXJlbnQgPSB0aGlzJDFcXG4gIH1cXG4gIHRoaXMuc2l6ZSA9IHNpemVcXG4gIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0XFxuICB0aGlzLnBhcmVudCA9IG51bGxcXG59O1xcblxcbkJyYW5jaENodW5rLnByb3RvdHlwZS5jaHVua1NpemUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLnNpemUgfTtcXG5cXG5CcmFuY2hDaHVuay5wcm90b3R5cGUucmVtb3ZlSW5uZXIgPSBmdW5jdGlvbiAoYXQsIG4pIHtcXG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XFxuXFxuICB0aGlzLnNpemUgLT0gblxcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgKytpKSB7XFxuICAgIHZhciBjaGlsZCA9IHRoaXMkMS5jaGlsZHJlbltpXSwgc3ogPSBjaGlsZC5jaHVua1NpemUoKVxcbiAgICBpZiAoYXQgPCBzeikge1xcbiAgICAgIHZhciBybSA9IE1hdGgubWluKG4sIHN6IC0gYXQpLCBvbGRIZWlnaHQgPSBjaGlsZC5oZWlnaHRcXG4gICAgICBjaGlsZC5yZW1vdmVJbm5lcihhdCwgcm0pXFxuICAgICAgdGhpcyQxLmhlaWdodCAtPSBvbGRIZWlnaHQgLSBjaGlsZC5oZWlnaHRcXG4gICAgICBpZiAoc3ogPT0gcm0pIHsgdGhpcyQxLmNoaWxkcmVuLnNwbGljZShpLS0sIDEpOyBjaGlsZC5wYXJlbnQgPSBudWxsIH1cXG4gICAgICBpZiAoKG4gLT0gcm0pID09IDApIHsgYnJlYWsgfVxcbiAgICAgIGF0ID0gMFxcbiAgICB9IGVsc2UgeyBhdCAtPSBzeiB9XFxuICB9XFxuICAvLyBJZiB0aGUgcmVzdWx0IGlzIHNtYWxsZXIgdGhhbiAyNSBsaW5lcywgZW5zdXJlIHRoYXQgaXQgaXMgYVxcbiAgLy8gc2luZ2xlIGxlYWYgbm9kZS5cXG4gIGlmICh0aGlzLnNpemUgLSBuIDwgMjUgJiZcXG4gICAgICAodGhpcy5jaGlsZHJlbi5sZW5ndGggPiAxIHx8ICEodGhpcy5jaGlsZHJlblswXSBpbnN0YW5jZW9mIExlYWZDaHVuaykpKSB7XFxuICAgIHZhciBsaW5lcyA9IFtdXFxuICAgIHRoaXMuY29sbGFwc2UobGluZXMpXFxuICAgIHRoaXMuY2hpbGRyZW4gPSBbbmV3IExlYWZDaHVuayhsaW5lcyldXFxuICAgIHRoaXMuY2hpbGRyZW5bMF0ucGFyZW50ID0gdGhpc1xcbiAgfVxcbn07XFxuXFxuQnJhbmNoQ2h1bmsucHJvdG90eXBlLmNvbGxhcHNlID0gZnVuY3Rpb24gKGxpbmVzKSB7XFxuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xcblxcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgKytpKSB7IHRoaXMkMS5jaGlsZHJlbltpXS5jb2xsYXBzZShsaW5lcykgfVxcbn07XFxuXFxuQnJhbmNoQ2h1bmsucHJvdG90eXBlLmluc2VydElubmVyID0gZnVuY3Rpb24gKGF0LCBsaW5lcywgaGVpZ2h0KSB7XFxuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xcblxcbiAgdGhpcy5zaXplICs9IGxpbmVzLmxlbmd0aFxcbiAgdGhpcy5oZWlnaHQgKz0gaGVpZ2h0XFxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyArK2kpIHtcXG4gICAgdmFyIGNoaWxkID0gdGhpcyQxLmNoaWxkcmVuW2ldLCBzeiA9IGNoaWxkLmNodW5rU2l6ZSgpXFxuICAgIGlmIChhdCA8PSBzeikge1xcbiAgICAgIGNoaWxkLmluc2VydElubmVyKGF0LCBsaW5lcywgaGVpZ2h0KVxcbiAgICAgIGlmIChjaGlsZC5saW5lcyAmJiBjaGlsZC5saW5lcy5sZW5ndGggPiA1MCkge1xcbiAgICAgICAgLy8gVG8gYXZvaWQgbWVtb3J5IHRocmFzaGluZyB3aGVuIGNoaWxkLmxpbmVzIGlzIGh1Z2UgKGUuZy4gZmlyc3QgdmlldyBvZiBhIGxhcmdlIGZpbGUpLCBpdCdzIG5ldmVyIHNwbGljZWQuXFxuICAgICAgICAvLyBJbnN0ZWFkLCBzbWFsbCBzbGljZXMgYXJlIHRha2VuLiBUaGV5J3JlIHRha2VuIGluIG9yZGVyIGJlY2F1c2Ugc2VxdWVudGlhbCBtZW1vcnkgYWNjZXNzZXMgYXJlIGZhc3Rlc3QuXFxuICAgICAgICB2YXIgcmVtYWluaW5nID0gY2hpbGQubGluZXMubGVuZ3RoICUgMjUgKyAyNVxcbiAgICAgICAgZm9yICh2YXIgcG9zID0gcmVtYWluaW5nOyBwb3MgPCBjaGlsZC5saW5lcy5sZW5ndGg7KSB7XFxuICAgICAgICAgIHZhciBsZWFmID0gbmV3IExlYWZDaHVuayhjaGlsZC5saW5lcy5zbGljZShwb3MsIHBvcyArPSAyNSkpXFxuICAgICAgICAgIGNoaWxkLmhlaWdodCAtPSBsZWFmLmhlaWdodFxcbiAgICAgICAgICB0aGlzJDEuY2hpbGRyZW4uc3BsaWNlKCsraSwgMCwgbGVhZilcXG4gICAgICAgICAgbGVhZi5wYXJlbnQgPSB0aGlzJDFcXG4gICAgICAgIH1cXG4gICAgICAgIGNoaWxkLmxpbmVzID0gY2hpbGQubGluZXMuc2xpY2UoMCwgcmVtYWluaW5nKVxcbiAgICAgICAgdGhpcyQxLm1heWJlU3BpbGwoKVxcbiAgICAgIH1cXG4gICAgICBicmVha1xcbiAgICB9XFxuICAgIGF0IC09IHN6XFxuICB9XFxufTtcXG5cXG4vLyBXaGVuIGEgbm9kZSBoYXMgZ3Jvd24sIGNoZWNrIHdoZXRoZXIgaXQgc2hvdWxkIGJlIHNwbGl0LlxcbkJyYW5jaENodW5rLnByb3RvdHlwZS5tYXliZVNwaWxsID0gZnVuY3Rpb24gKCkge1xcbiAgaWYgKHRoaXMuY2hpbGRyZW4ubGVuZ3RoIDw9IDEwKSB7IHJldHVybiB9XFxuICB2YXIgbWUgPSB0aGlzXFxuICBkbyB7XFxuICAgIHZhciBzcGlsbGVkID0gbWUuY2hpbGRyZW4uc3BsaWNlKG1lLmNoaWxkcmVuLmxlbmd0aCAtIDUsIDUpXFxuICAgIHZhciBzaWJsaW5nID0gbmV3IEJyYW5jaENodW5rKHNwaWxsZWQpXFxuICAgIGlmICghbWUucGFyZW50KSB7IC8vIEJlY29tZSB0aGUgcGFyZW50IG5vZGVcXG4gICAgICB2YXIgY29weSA9IG5ldyBCcmFuY2hDaHVuayhtZS5jaGlsZHJlbilcXG4gICAgICBjb3B5LnBhcmVudCA9IG1lXFxuICAgICAgbWUuY2hpbGRyZW4gPSBbY29weSwgc2libGluZ11cXG4gICAgICBtZSA9IGNvcHlcXG4gICB9IGVsc2Uge1xcbiAgICAgIG1lLnNpemUgLT0gc2libGluZy5zaXplXFxuICAgICAgbWUuaGVpZ2h0IC09IHNpYmxpbmcuaGVpZ2h0XFxuICAgICAgdmFyIG15SW5kZXggPSBpbmRleE9mKG1lLnBhcmVudC5jaGlsZHJlbiwgbWUpXFxuICAgICAgbWUucGFyZW50LmNoaWxkcmVuLnNwbGljZShteUluZGV4ICsgMSwgMCwgc2libGluZylcXG4gICAgfVxcbiAgICBzaWJsaW5nLnBhcmVudCA9IG1lLnBhcmVudFxcbiAgfSB3aGlsZSAobWUuY2hpbGRyZW4ubGVuZ3RoID4gMTApXFxuICBtZS5wYXJlbnQubWF5YmVTcGlsbCgpXFxufTtcXG5cXG5CcmFuY2hDaHVuay5wcm90b3R5cGUuaXRlck4gPSBmdW5jdGlvbiAoYXQsIG4sIG9wKSB7XFxuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xcblxcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgKytpKSB7XFxuICAgIHZhciBjaGlsZCA9IHRoaXMkMS5jaGlsZHJlbltpXSwgc3ogPSBjaGlsZC5jaHVua1NpemUoKVxcbiAgICBpZiAoYXQgPCBzeikge1xcbiAgICAgIHZhciB1c2VkID0gTWF0aC5taW4obiwgc3ogLSBhdClcXG4gICAgICBpZiAoY2hpbGQuaXRlck4oYXQsIHVzZWQsIG9wKSkgeyByZXR1cm4gdHJ1ZSB9XFxuICAgICAgaWYgKChuIC09IHVzZWQpID09IDApIHsgYnJlYWsgfVxcbiAgICAgIGF0ID0gMFxcbiAgICB9IGVsc2UgeyBhdCAtPSBzeiB9XFxuICB9XFxufTtcXG5cXG4vLyBMaW5lIHdpZGdldHMgYXJlIGJsb2NrIGVsZW1lbnRzIGRpc3BsYXllZCBhYm92ZSBvciBiZWxvdyBhIGxpbmUuXFxuXFxudmFyIExpbmVXaWRnZXQgPSBmdW5jdGlvbihkb2MsIG5vZGUsIG9wdGlvbnMpIHtcXG4gIHZhciB0aGlzJDEgPSB0aGlzO1xcblxcbiAgaWYgKG9wdGlvbnMpIHsgZm9yICh2YXIgb3B0IGluIG9wdGlvbnMpIHsgaWYgKG9wdGlvbnMuaGFzT3duUHJvcGVydHkob3B0KSlcXG4gICAgeyB0aGlzJDFbb3B0XSA9IG9wdGlvbnNbb3B0XSB9IH0gfVxcbiAgdGhpcy5kb2MgPSBkb2NcXG4gIHRoaXMubm9kZSA9IG5vZGVcXG59O1xcblxcbkxpbmVXaWRnZXQucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcXG5cXG4gIHZhciBjbSA9IHRoaXMuZG9jLmNtLCB3cyA9IHRoaXMubGluZS53aWRnZXRzLCBsaW5lID0gdGhpcy5saW5lLCBubyA9IGxpbmVObyhsaW5lKVxcbiAgaWYgKG5vID09IG51bGwgfHwgIXdzKSB7IHJldHVybiB9XFxuICBmb3IgKHZhciBpID0gMDsgaSA8IHdzLmxlbmd0aDsgKytpKSB7IGlmICh3c1tpXSA9PSB0aGlzJDEpIHsgd3Muc3BsaWNlKGktLSwgMSkgfSB9XFxuICBpZiAoIXdzLmxlbmd0aCkgeyBsaW5lLndpZGdldHMgPSBudWxsIH1cXG4gIHZhciBoZWlnaHQgPSB3aWRnZXRIZWlnaHQodGhpcylcXG4gIHVwZGF0ZUxpbmVIZWlnaHQobGluZSwgTWF0aC5tYXgoMCwgbGluZS5oZWlnaHQgLSBoZWlnaHQpKVxcbiAgaWYgKGNtKSB7XFxuICAgIHJ1bkluT3AoY20sIGZ1bmN0aW9uICgpIHtcXG4gICAgICBhZGp1c3RTY3JvbGxXaGVuQWJvdmVWaXNpYmxlKGNtLCBsaW5lLCAtaGVpZ2h0KVxcbiAgICAgIHJlZ0xpbmVDaGFuZ2UoY20sIG5vLCBcXFwid2lkZ2V0XFxcIilcXG4gICAgfSlcXG4gICAgc2lnbmFsTGF0ZXIoY20sIFxcXCJsaW5lV2lkZ2V0Q2xlYXJlZFxcXCIsIGNtLCB0aGlzLCBubylcXG4gIH1cXG59O1xcblxcbkxpbmVXaWRnZXQucHJvdG90eXBlLmNoYW5nZWQgPSBmdW5jdGlvbiAoKSB7XFxuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xcblxcbiAgdmFyIG9sZEggPSB0aGlzLmhlaWdodCwgY20gPSB0aGlzLmRvYy5jbSwgbGluZSA9IHRoaXMubGluZVxcbiAgdGhpcy5oZWlnaHQgPSBudWxsXFxuICB2YXIgZGlmZiA9IHdpZGdldEhlaWdodCh0aGlzKSAtIG9sZEhcXG4gIGlmICghZGlmZikgeyByZXR1cm4gfVxcbiAgdXBkYXRlTGluZUhlaWdodChsaW5lLCBsaW5lLmhlaWdodCArIGRpZmYpXFxuICBpZiAoY20pIHtcXG4gICAgcnVuSW5PcChjbSwgZnVuY3Rpb24gKCkge1xcbiAgICAgIGNtLmN1ck9wLmZvcmNlVXBkYXRlID0gdHJ1ZVxcbiAgICAgIGFkanVzdFNjcm9sbFdoZW5BYm92ZVZpc2libGUoY20sIGxpbmUsIGRpZmYpXFxuICAgICAgc2lnbmFsTGF0ZXIoY20sIFxcXCJsaW5lV2lkZ2V0Q2hhbmdlZFxcXCIsIGNtLCB0aGlzJDEsIGxpbmVObyhsaW5lKSlcXG4gICAgfSlcXG4gIH1cXG59O1xcbmV2ZW50TWl4aW4oTGluZVdpZGdldClcXG5cXG5mdW5jdGlvbiBhZGp1c3RTY3JvbGxXaGVuQWJvdmVWaXNpYmxlKGNtLCBsaW5lLCBkaWZmKSB7XFxuICBpZiAoaGVpZ2h0QXRMaW5lKGxpbmUpIDwgKChjbS5jdXJPcCAmJiBjbS5jdXJPcC5zY3JvbGxUb3ApIHx8IGNtLmRvYy5zY3JvbGxUb3ApKVxcbiAgICB7IGFkZFRvU2Nyb2xsUG9zKGNtLCBudWxsLCBkaWZmKSB9XFxufVxcblxcbmZ1bmN0aW9uIGFkZExpbmVXaWRnZXQoZG9jLCBoYW5kbGUsIG5vZGUsIG9wdGlvbnMpIHtcXG4gIHZhciB3aWRnZXQgPSBuZXcgTGluZVdpZGdldChkb2MsIG5vZGUsIG9wdGlvbnMpXFxuICB2YXIgY20gPSBkb2MuY21cXG4gIGlmIChjbSAmJiB3aWRnZXQubm9IU2Nyb2xsKSB7IGNtLmRpc3BsYXkuYWxpZ25XaWRnZXRzID0gdHJ1ZSB9XFxuICBjaGFuZ2VMaW5lKGRvYywgaGFuZGxlLCBcXFwid2lkZ2V0XFxcIiwgZnVuY3Rpb24gKGxpbmUpIHtcXG4gICAgdmFyIHdpZGdldHMgPSBsaW5lLndpZGdldHMgfHwgKGxpbmUud2lkZ2V0cyA9IFtdKVxcbiAgICBpZiAod2lkZ2V0Lmluc2VydEF0ID09IG51bGwpIHsgd2lkZ2V0cy5wdXNoKHdpZGdldCkgfVxcbiAgICBlbHNlIHsgd2lkZ2V0cy5zcGxpY2UoTWF0aC5taW4od2lkZ2V0cy5sZW5ndGggLSAxLCBNYXRoLm1heCgwLCB3aWRnZXQuaW5zZXJ0QXQpKSwgMCwgd2lkZ2V0KSB9XFxuICAgIHdpZGdldC5saW5lID0gbGluZVxcbiAgICBpZiAoY20gJiYgIWxpbmVJc0hpZGRlbihkb2MsIGxpbmUpKSB7XFxuICAgICAgdmFyIGFib3ZlVmlzaWJsZSA9IGhlaWdodEF0TGluZShsaW5lKSA8IGRvYy5zY3JvbGxUb3BcXG4gICAgICB1cGRhdGVMaW5lSGVpZ2h0KGxpbmUsIGxpbmUuaGVpZ2h0ICsgd2lkZ2V0SGVpZ2h0KHdpZGdldCkpXFxuICAgICAgaWYgKGFib3ZlVmlzaWJsZSkgeyBhZGRUb1Njcm9sbFBvcyhjbSwgbnVsbCwgd2lkZ2V0LmhlaWdodCkgfVxcbiAgICAgIGNtLmN1ck9wLmZvcmNlVXBkYXRlID0gdHJ1ZVxcbiAgICB9XFxuICAgIHJldHVybiB0cnVlXFxuICB9KVxcbiAgc2lnbmFsTGF0ZXIoY20sIFxcXCJsaW5lV2lkZ2V0QWRkZWRcXFwiLCBjbSwgd2lkZ2V0LCB0eXBlb2YgaGFuZGxlID09IFxcXCJudW1iZXJcXFwiID8gaGFuZGxlIDogbGluZU5vKGhhbmRsZSkpXFxuICByZXR1cm4gd2lkZ2V0XFxufVxcblxcbi8vIFRFWFRNQVJLRVJTXFxuXFxuLy8gQ3JlYXRlZCB3aXRoIG1hcmtUZXh0IGFuZCBzZXRCb29rbWFyayBtZXRob2RzLiBBIFRleHRNYXJrZXIgaXMgYVxcbi8vIGhhbmRsZSB0aGF0IGNhbiBiZSB1c2VkIHRvIGNsZWFyIG9yIGZpbmQgYSBtYXJrZWQgcG9zaXRpb24gaW4gdGhlXFxuLy8gZG9jdW1lbnQuIExpbmUgb2JqZWN0cyBob2xkIGFycmF5cyAobWFya2VkU3BhbnMpIGNvbnRhaW5pbmdcXG4vLyB7ZnJvbSwgdG8sIG1hcmtlcn0gb2JqZWN0IHBvaW50aW5nIHRvIHN1Y2ggbWFya2VyIG9iamVjdHMsIGFuZFxcbi8vIGluZGljYXRpbmcgdGhhdCBzdWNoIGEgbWFya2VyIGlzIHByZXNlbnQgb24gdGhhdCBsaW5lLiBNdWx0aXBsZVxcbi8vIGxpbmVzIG1heSBwb2ludCB0byB0aGUgc2FtZSBtYXJrZXIgd2hlbiBpdCBzcGFucyBhY3Jvc3MgbGluZXMuXFxuLy8gVGhlIHNwYW5zIHdpbGwgaGF2ZSBudWxsIGZvciB0aGVpciBmcm9tL3RvIHByb3BlcnRpZXMgd2hlbiB0aGVcXG4vLyBtYXJrZXIgY29udGludWVzIGJleW9uZCB0aGUgc3RhcnQvZW5kIG9mIHRoZSBsaW5lLiBNYXJrZXJzIGhhdmVcXG4vLyBsaW5rcyBiYWNrIHRvIHRoZSBsaW5lcyB0aGV5IGN1cnJlbnRseSB0b3VjaC5cXG5cXG4vLyBDb2xsYXBzZWQgbWFya2VycyBoYXZlIHVuaXF1ZSBpZHMsIGluIG9yZGVyIHRvIGJlIGFibGUgdG8gb3JkZXJcXG4vLyB0aGVtLCB3aGljaCBpcyBuZWVkZWQgZm9yIHVuaXF1ZWx5IGRldGVybWluaW5nIGFuIG91dGVyIG1hcmtlclxcbi8vIHdoZW4gdGhleSBvdmVybGFwICh0aGV5IG1heSBuZXN0LCBidXQgbm90IHBhcnRpYWxseSBvdmVybGFwKS5cXG52YXIgbmV4dE1hcmtlcklkID0gMFxcblxcbnZhciBUZXh0TWFya2VyID0gZnVuY3Rpb24oZG9jLCB0eXBlKSB7XFxuICB0aGlzLmxpbmVzID0gW11cXG4gIHRoaXMudHlwZSA9IHR5cGVcXG4gIHRoaXMuZG9jID0gZG9jXFxuICB0aGlzLmlkID0gKytuZXh0TWFya2VySWRcXG59O1xcblxcbi8vIENsZWFyIHRoZSBtYXJrZXIuXFxuVGV4dE1hcmtlci5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XFxuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xcblxcbiAgaWYgKHRoaXMuZXhwbGljaXRseUNsZWFyZWQpIHsgcmV0dXJuIH1cXG4gIHZhciBjbSA9IHRoaXMuZG9jLmNtLCB3aXRoT3AgPSBjbSAmJiAhY20uY3VyT3BcXG4gIGlmICh3aXRoT3ApIHsgc3RhcnRPcGVyYXRpb24oY20pIH1cXG4gIGlmIChoYXNIYW5kbGVyKHRoaXMsIFxcXCJjbGVhclxcXCIpKSB7XFxuICAgIHZhciBmb3VuZCA9IHRoaXMuZmluZCgpXFxuICAgIGlmIChmb3VuZCkgeyBzaWduYWxMYXRlcih0aGlzLCBcXFwiY2xlYXJcXFwiLCBmb3VuZC5mcm9tLCBmb3VuZC50bykgfVxcbiAgfVxcbiAgdmFyIG1pbiA9IG51bGwsIG1heCA9IG51bGxcXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5saW5lcy5sZW5ndGg7ICsraSkge1xcbiAgICB2YXIgbGluZSA9IHRoaXMkMS5saW5lc1tpXVxcbiAgICB2YXIgc3BhbiA9IGdldE1hcmtlZFNwYW5Gb3IobGluZS5tYXJrZWRTcGFucywgdGhpcyQxKVxcbiAgICBpZiAoY20gJiYgIXRoaXMkMS5jb2xsYXBzZWQpIHsgcmVnTGluZUNoYW5nZShjbSwgbGluZU5vKGxpbmUpLCBcXFwidGV4dFxcXCIpIH1cXG4gICAgZWxzZSBpZiAoY20pIHtcXG4gICAgICBpZiAoc3Bhbi50byAhPSBudWxsKSB7IG1heCA9IGxpbmVObyhsaW5lKSB9XFxuICAgICAgaWYgKHNwYW4uZnJvbSAhPSBudWxsKSB7IG1pbiA9IGxpbmVObyhsaW5lKSB9XFxuICAgIH1cXG4gICAgbGluZS5tYXJrZWRTcGFucyA9IHJlbW92ZU1hcmtlZFNwYW4obGluZS5tYXJrZWRTcGFucywgc3BhbilcXG4gICAgaWYgKHNwYW4uZnJvbSA9PSBudWxsICYmIHRoaXMkMS5jb2xsYXBzZWQgJiYgIWxpbmVJc0hpZGRlbih0aGlzJDEuZG9jLCBsaW5lKSAmJiBjbSlcXG4gICAgICB7IHVwZGF0ZUxpbmVIZWlnaHQobGluZSwgdGV4dEhlaWdodChjbS5kaXNwbGF5KSkgfVxcbiAgfVxcbiAgaWYgKGNtICYmIHRoaXMuY29sbGFwc2VkICYmICFjbS5vcHRpb25zLmxpbmVXcmFwcGluZykgeyBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCB0aGlzLmxpbmVzLmxlbmd0aDsgKytpJDEpIHtcXG4gICAgdmFyIHZpc3VhbCA9IHZpc3VhbExpbmUodGhpcyQxLmxpbmVzW2kkMV0pLCBsZW4gPSBsaW5lTGVuZ3RoKHZpc3VhbClcXG4gICAgaWYgKGxlbiA+IGNtLmRpc3BsYXkubWF4TGluZUxlbmd0aCkge1xcbiAgICAgIGNtLmRpc3BsYXkubWF4TGluZSA9IHZpc3VhbFxcbiAgICAgIGNtLmRpc3BsYXkubWF4TGluZUxlbmd0aCA9IGxlblxcbiAgICAgIGNtLmRpc3BsYXkubWF4TGluZUNoYW5nZWQgPSB0cnVlXFxuICAgIH1cXG4gIH0gfVxcblxcbiAgaWYgKG1pbiAhPSBudWxsICYmIGNtICYmIHRoaXMuY29sbGFwc2VkKSB7IHJlZ0NoYW5nZShjbSwgbWluLCBtYXggKyAxKSB9XFxuICB0aGlzLmxpbmVzLmxlbmd0aCA9IDBcXG4gIHRoaXMuZXhwbGljaXRseUNsZWFyZWQgPSB0cnVlXFxuICBpZiAodGhpcy5hdG9taWMgJiYgdGhpcy5kb2MuY2FudEVkaXQpIHtcXG4gICAgdGhpcy5kb2MuY2FudEVkaXQgPSBmYWxzZVxcbiAgICBpZiAoY20pIHsgcmVDaGVja1NlbGVjdGlvbihjbS5kb2MpIH1cXG4gIH1cXG4gIGlmIChjbSkgeyBzaWduYWxMYXRlcihjbSwgXFxcIm1hcmtlckNsZWFyZWRcXFwiLCBjbSwgdGhpcywgbWluLCBtYXgpIH1cXG4gIGlmICh3aXRoT3ApIHsgZW5kT3BlcmF0aW9uKGNtKSB9XFxuICBpZiAodGhpcy5wYXJlbnQpIHsgdGhpcy5wYXJlbnQuY2xlYXIoKSB9XFxufTtcXG5cXG4vLyBGaW5kIHRoZSBwb3NpdGlvbiBvZiB0aGUgbWFya2VyIGluIHRoZSBkb2N1bWVudC4gUmV0dXJucyBhIHtmcm9tLFxcbi8vIHRvfSBvYmplY3QgYnkgZGVmYXVsdC4gU2lkZSBjYW4gYmUgcGFzc2VkIHRvIGdldCBhIHNwZWNpZmljIHNpZGVcXG4vLyAtLSAwIChib3RoKSwgLTEgKGxlZnQpLCBvciAxIChyaWdodCkuIFdoZW4gbGluZU9iaiBpcyB0cnVlLCB0aGVcXG4vLyBQb3Mgb2JqZWN0cyByZXR1cm5lZCBjb250YWluIGEgbGluZSBvYmplY3QsIHJhdGhlciB0aGFuIGEgbGluZVxcbi8vIG51bWJlciAodXNlZCB0byBwcmV2ZW50IGxvb2tpbmcgdXAgdGhlIHNhbWUgbGluZSB0d2ljZSkuXFxuVGV4dE1hcmtlci5wcm90b3R5cGUuZmluZCA9IGZ1bmN0aW9uIChzaWRlLCBsaW5lT2JqKSB7XFxuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xcblxcbiAgaWYgKHNpZGUgPT0gbnVsbCAmJiB0aGlzLnR5cGUgPT0gXFxcImJvb2ttYXJrXFxcIikgeyBzaWRlID0gMSB9XFxuICB2YXIgZnJvbSwgdG9cXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5saW5lcy5sZW5ndGg7ICsraSkge1xcbiAgICB2YXIgbGluZSA9IHRoaXMkMS5saW5lc1tpXVxcbiAgICB2YXIgc3BhbiA9IGdldE1hcmtlZFNwYW5Gb3IobGluZS5tYXJrZWRTcGFucywgdGhpcyQxKVxcbiAgICBpZiAoc3Bhbi5mcm9tICE9IG51bGwpIHtcXG4gICAgICBmcm9tID0gUG9zKGxpbmVPYmogPyBsaW5lIDogbGluZU5vKGxpbmUpLCBzcGFuLmZyb20pXFxuICAgICAgaWYgKHNpZGUgPT0gLTEpIHsgcmV0dXJuIGZyb20gfVxcbiAgICB9XFxuICAgIGlmIChzcGFuLnRvICE9IG51bGwpIHtcXG4gICAgICB0byA9IFBvcyhsaW5lT2JqID8gbGluZSA6IGxpbmVObyhsaW5lKSwgc3Bhbi50bylcXG4gICAgICBpZiAoc2lkZSA9PSAxKSB7IHJldHVybiB0byB9XFxuICAgIH1cXG4gIH1cXG4gIHJldHVybiBmcm9tICYmIHtmcm9tOiBmcm9tLCB0bzogdG99XFxufTtcXG5cXG4vLyBTaWduYWxzIHRoYXQgdGhlIG1hcmtlcidzIHdpZGdldCBjaGFuZ2VkLCBhbmQgc3Vycm91bmRpbmcgbGF5b3V0XFxuLy8gc2hvdWxkIGJlIHJlY29tcHV0ZWQuXFxuVGV4dE1hcmtlci5wcm90b3R5cGUuY2hhbmdlZCA9IGZ1bmN0aW9uICgpIHtcXG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XFxuXFxuICB2YXIgcG9zID0gdGhpcy5maW5kKC0xLCB0cnVlKSwgd2lkZ2V0ID0gdGhpcywgY20gPSB0aGlzLmRvYy5jbVxcbiAgaWYgKCFwb3MgfHwgIWNtKSB7IHJldHVybiB9XFxuICBydW5Jbk9wKGNtLCBmdW5jdGlvbiAoKSB7XFxuICAgIHZhciBsaW5lID0gcG9zLmxpbmUsIGxpbmVOID0gbGluZU5vKHBvcy5saW5lKVxcbiAgICB2YXIgdmlldyA9IGZpbmRWaWV3Rm9yTGluZShjbSwgbGluZU4pXFxuICAgIGlmICh2aWV3KSB7XFxuICAgICAgY2xlYXJMaW5lTWVhc3VyZW1lbnRDYWNoZUZvcih2aWV3KVxcbiAgICAgIGNtLmN1ck9wLnNlbGVjdGlvbkNoYW5nZWQgPSBjbS5jdXJPcC5mb3JjZVVwZGF0ZSA9IHRydWVcXG4gICAgfVxcbiAgICBjbS5jdXJPcC51cGRhdGVNYXhMaW5lID0gdHJ1ZVxcbiAgICBpZiAoIWxpbmVJc0hpZGRlbih3aWRnZXQuZG9jLCBsaW5lKSAmJiB3aWRnZXQuaGVpZ2h0ICE9IG51bGwpIHtcXG4gICAgICB2YXIgb2xkSGVpZ2h0ID0gd2lkZ2V0LmhlaWdodFxcbiAgICAgIHdpZGdldC5oZWlnaHQgPSBudWxsXFxuICAgICAgdmFyIGRIZWlnaHQgPSB3aWRnZXRIZWlnaHQod2lkZ2V0KSAtIG9sZEhlaWdodFxcbiAgICAgIGlmIChkSGVpZ2h0KVxcbiAgICAgICAgeyB1cGRhdGVMaW5lSGVpZ2h0KGxpbmUsIGxpbmUuaGVpZ2h0ICsgZEhlaWdodCkgfVxcbiAgICB9XFxuICAgIHNpZ25hbExhdGVyKGNtLCBcXFwibWFya2VyQ2hhbmdlZFxcXCIsIGNtLCB0aGlzJDEpXFxuICB9KVxcbn07XFxuXFxuVGV4dE1hcmtlci5wcm90b3R5cGUuYXR0YWNoTGluZSA9IGZ1bmN0aW9uIChsaW5lKSB7XFxuICBpZiAoIXRoaXMubGluZXMubGVuZ3RoICYmIHRoaXMuZG9jLmNtKSB7XFxuICAgIHZhciBvcCA9IHRoaXMuZG9jLmNtLmN1ck9wXFxuICAgIGlmICghb3AubWF5YmVIaWRkZW5NYXJrZXJzIHx8IGluZGV4T2Yob3AubWF5YmVIaWRkZW5NYXJrZXJzLCB0aGlzKSA9PSAtMSlcXG4gICAgICB7IChvcC5tYXliZVVuaGlkZGVuTWFya2VycyB8fCAob3AubWF5YmVVbmhpZGRlbk1hcmtlcnMgPSBbXSkpLnB1c2godGhpcykgfVxcbiAgfVxcbiAgdGhpcy5saW5lcy5wdXNoKGxpbmUpXFxufTtcXG5cXG5UZXh0TWFya2VyLnByb3RvdHlwZS5kZXRhY2hMaW5lID0gZnVuY3Rpb24gKGxpbmUpIHtcXG4gIHRoaXMubGluZXMuc3BsaWNlKGluZGV4T2YodGhpcy5saW5lcywgbGluZSksIDEpXFxuICBpZiAoIXRoaXMubGluZXMubGVuZ3RoICYmIHRoaXMuZG9jLmNtKSB7XFxuICAgIHZhciBvcCA9IHRoaXMuZG9jLmNtLmN1ck9wXFxuICAgIDsob3AubWF5YmVIaWRkZW5NYXJrZXJzIHx8IChvcC5tYXliZUhpZGRlbk1hcmtlcnMgPSBbXSkpLnB1c2godGhpcylcXG4gIH1cXG59O1xcbmV2ZW50TWl4aW4oVGV4dE1hcmtlcilcXG5cXG4vLyBDcmVhdGUgYSBtYXJrZXIsIHdpcmUgaXQgdXAgdG8gdGhlIHJpZ2h0IGxpbmVzLCBhbmRcXG5mdW5jdGlvbiBtYXJrVGV4dChkb2MsIGZyb20sIHRvLCBvcHRpb25zLCB0eXBlKSB7XFxuICAvLyBTaGFyZWQgbWFya2VycyAoYWNyb3NzIGxpbmtlZCBkb2N1bWVudHMpIGFyZSBoYW5kbGVkIHNlcGFyYXRlbHlcXG4gIC8vIChtYXJrVGV4dFNoYXJlZCB3aWxsIGNhbGwgb3V0IHRvIHRoaXMgYWdhaW4sIG9uY2UgcGVyXFxuICAvLyBkb2N1bWVudCkuXFxuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnNoYXJlZCkgeyByZXR1cm4gbWFya1RleHRTaGFyZWQoZG9jLCBmcm9tLCB0bywgb3B0aW9ucywgdHlwZSkgfVxcbiAgLy8gRW5zdXJlIHdlIGFyZSBpbiBhbiBvcGVyYXRpb24uXFxuICBpZiAoZG9jLmNtICYmICFkb2MuY20uY3VyT3ApIHsgcmV0dXJuIG9wZXJhdGlvbihkb2MuY20sIG1hcmtUZXh0KShkb2MsIGZyb20sIHRvLCBvcHRpb25zLCB0eXBlKSB9XFxuXFxuICB2YXIgbWFya2VyID0gbmV3IFRleHRNYXJrZXIoZG9jLCB0eXBlKSwgZGlmZiA9IGNtcChmcm9tLCB0bylcXG4gIGlmIChvcHRpb25zKSB7IGNvcHlPYmoob3B0aW9ucywgbWFya2VyLCBmYWxzZSkgfVxcbiAgLy8gRG9uJ3QgY29ubmVjdCBlbXB0eSBtYXJrZXJzIHVubGVzcyBjbGVhcldoZW5FbXB0eSBpcyBmYWxzZVxcbiAgaWYgKGRpZmYgPiAwIHx8IGRpZmYgPT0gMCAmJiBtYXJrZXIuY2xlYXJXaGVuRW1wdHkgIT09IGZhbHNlKVxcbiAgICB7IHJldHVybiBtYXJrZXIgfVxcbiAgaWYgKG1hcmtlci5yZXBsYWNlZFdpdGgpIHtcXG4gICAgLy8gU2hvd2luZyB1cCBhcyBhIHdpZGdldCBpbXBsaWVzIGNvbGxhcHNlZCAod2lkZ2V0IHJlcGxhY2VzIHRleHQpXFxuICAgIG1hcmtlci5jb2xsYXBzZWQgPSB0cnVlXFxuICAgIG1hcmtlci53aWRnZXROb2RlID0gZWx0KFxcXCJzcGFuXFxcIiwgW21hcmtlci5yZXBsYWNlZFdpdGhdLCBcXFwiQ29kZU1pcnJvci13aWRnZXRcXFwiKVxcbiAgICBtYXJrZXIud2lkZ2V0Tm9kZS5zZXRBdHRyaWJ1dGUoXFxcInJvbGVcXFwiLCBcXFwicHJlc2VudGF0aW9uXFxcIikgLy8gaGlkZSBmcm9tIGFjY2Vzc2liaWxpdHkgdHJlZVxcbiAgICBpZiAoIW9wdGlvbnMuaGFuZGxlTW91c2VFdmVudHMpIHsgbWFya2VyLndpZGdldE5vZGUuc2V0QXR0cmlidXRlKFxcXCJjbS1pZ25vcmUtZXZlbnRzXFxcIiwgXFxcInRydWVcXFwiKSB9XFxuICAgIGlmIChvcHRpb25zLmluc2VydExlZnQpIHsgbWFya2VyLndpZGdldE5vZGUuaW5zZXJ0TGVmdCA9IHRydWUgfVxcbiAgfVxcbiAgaWYgKG1hcmtlci5jb2xsYXBzZWQpIHtcXG4gICAgaWYgKGNvbmZsaWN0aW5nQ29sbGFwc2VkUmFuZ2UoZG9jLCBmcm9tLmxpbmUsIGZyb20sIHRvLCBtYXJrZXIpIHx8XFxuICAgICAgICBmcm9tLmxpbmUgIT0gdG8ubGluZSAmJiBjb25mbGljdGluZ0NvbGxhcHNlZFJhbmdlKGRvYywgdG8ubGluZSwgZnJvbSwgdG8sIG1hcmtlcikpXFxuICAgICAgeyB0aHJvdyBuZXcgRXJyb3IoXFxcIkluc2VydGluZyBjb2xsYXBzZWQgbWFya2VyIHBhcnRpYWxseSBvdmVybGFwcGluZyBhbiBleGlzdGluZyBvbmVcXFwiKSB9XFxuICAgIHNlZUNvbGxhcHNlZFNwYW5zKClcXG4gIH1cXG5cXG4gIGlmIChtYXJrZXIuYWRkVG9IaXN0b3J5KVxcbiAgICB7IGFkZENoYW5nZVRvSGlzdG9yeShkb2MsIHtmcm9tOiBmcm9tLCB0bzogdG8sIG9yaWdpbjogXFxcIm1hcmtUZXh0XFxcIn0sIGRvYy5zZWwsIE5hTikgfVxcblxcbiAgdmFyIGN1ckxpbmUgPSBmcm9tLmxpbmUsIGNtID0gZG9jLmNtLCB1cGRhdGVNYXhMaW5lXFxuICBkb2MuaXRlcihjdXJMaW5lLCB0by5saW5lICsgMSwgZnVuY3Rpb24gKGxpbmUpIHtcXG4gICAgaWYgKGNtICYmIG1hcmtlci5jb2xsYXBzZWQgJiYgIWNtLm9wdGlvbnMubGluZVdyYXBwaW5nICYmIHZpc3VhbExpbmUobGluZSkgPT0gY20uZGlzcGxheS5tYXhMaW5lKVxcbiAgICAgIHsgdXBkYXRlTWF4TGluZSA9IHRydWUgfVxcbiAgICBpZiAobWFya2VyLmNvbGxhcHNlZCAmJiBjdXJMaW5lICE9IGZyb20ubGluZSkgeyB1cGRhdGVMaW5lSGVpZ2h0KGxpbmUsIDApIH1cXG4gICAgYWRkTWFya2VkU3BhbihsaW5lLCBuZXcgTWFya2VkU3BhbihtYXJrZXIsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VyTGluZSA9PSBmcm9tLmxpbmUgPyBmcm9tLmNoIDogbnVsbCxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJMaW5lID09IHRvLmxpbmUgPyB0by5jaCA6IG51bGwpKVxcbiAgICArK2N1ckxpbmVcXG4gIH0pXFxuICAvLyBsaW5lSXNIaWRkZW4gZGVwZW5kcyBvbiB0aGUgcHJlc2VuY2Ugb2YgdGhlIHNwYW5zLCBzbyBuZWVkcyBhIHNlY29uZCBwYXNzXFxuICBpZiAobWFya2VyLmNvbGxhcHNlZCkgeyBkb2MuaXRlcihmcm9tLmxpbmUsIHRvLmxpbmUgKyAxLCBmdW5jdGlvbiAobGluZSkge1xcbiAgICBpZiAobGluZUlzSGlkZGVuKGRvYywgbGluZSkpIHsgdXBkYXRlTGluZUhlaWdodChsaW5lLCAwKSB9XFxuICB9KSB9XFxuXFxuICBpZiAobWFya2VyLmNsZWFyT25FbnRlcikgeyBvbihtYXJrZXIsIFxcXCJiZWZvcmVDdXJzb3JFbnRlclxcXCIsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1hcmtlci5jbGVhcigpOyB9KSB9XFxuXFxuICBpZiAobWFya2VyLnJlYWRPbmx5KSB7XFxuICAgIHNlZVJlYWRPbmx5U3BhbnMoKVxcbiAgICBpZiAoZG9jLmhpc3RvcnkuZG9uZS5sZW5ndGggfHwgZG9jLmhpc3RvcnkudW5kb25lLmxlbmd0aClcXG4gICAgICB7IGRvYy5jbGVhckhpc3RvcnkoKSB9XFxuICB9XFxuICBpZiAobWFya2VyLmNvbGxhcHNlZCkge1xcbiAgICBtYXJrZXIuaWQgPSArK25leHRNYXJrZXJJZFxcbiAgICBtYXJrZXIuYXRvbWljID0gdHJ1ZVxcbiAgfVxcbiAgaWYgKGNtKSB7XFxuICAgIC8vIFN5bmMgZWRpdG9yIHN0YXRlXFxuICAgIGlmICh1cGRhdGVNYXhMaW5lKSB7IGNtLmN1ck9wLnVwZGF0ZU1heExpbmUgPSB0cnVlIH1cXG4gICAgaWYgKG1hcmtlci5jb2xsYXBzZWQpXFxuICAgICAgeyByZWdDaGFuZ2UoY20sIGZyb20ubGluZSwgdG8ubGluZSArIDEpIH1cXG4gICAgZWxzZSBpZiAobWFya2VyLmNsYXNzTmFtZSB8fCBtYXJrZXIudGl0bGUgfHwgbWFya2VyLnN0YXJ0U3R5bGUgfHwgbWFya2VyLmVuZFN0eWxlIHx8IG1hcmtlci5jc3MpXFxuICAgICAgeyBmb3IgKHZhciBpID0gZnJvbS5saW5lOyBpIDw9IHRvLmxpbmU7IGkrKykgeyByZWdMaW5lQ2hhbmdlKGNtLCBpLCBcXFwidGV4dFxcXCIpIH0gfVxcbiAgICBpZiAobWFya2VyLmF0b21pYykgeyByZUNoZWNrU2VsZWN0aW9uKGNtLmRvYykgfVxcbiAgICBzaWduYWxMYXRlcihjbSwgXFxcIm1hcmtlckFkZGVkXFxcIiwgY20sIG1hcmtlcilcXG4gIH1cXG4gIHJldHVybiBtYXJrZXJcXG59XFxuXFxuLy8gU0hBUkVEIFRFWFRNQVJLRVJTXFxuXFxuLy8gQSBzaGFyZWQgbWFya2VyIHNwYW5zIG11bHRpcGxlIGxpbmtlZCBkb2N1bWVudHMuIEl0IGlzXFxuLy8gaW1wbGVtZW50ZWQgYXMgYSBtZXRhLW1hcmtlci1vYmplY3QgY29udHJvbGxpbmcgbXVsdGlwbGUgbm9ybWFsXFxuLy8gbWFya2Vycy5cXG52YXIgU2hhcmVkVGV4dE1hcmtlciA9IGZ1bmN0aW9uKG1hcmtlcnMsIHByaW1hcnkpIHtcXG4gIHZhciB0aGlzJDEgPSB0aGlzO1xcblxcbiAgdGhpcy5tYXJrZXJzID0gbWFya2Vyc1xcbiAgdGhpcy5wcmltYXJ5ID0gcHJpbWFyeVxcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXJrZXJzLmxlbmd0aDsgKytpKVxcbiAgICB7IG1hcmtlcnNbaV0ucGFyZW50ID0gdGhpcyQxIH1cXG59O1xcblxcblNoYXJlZFRleHRNYXJrZXIucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcXG5cXG4gIGlmICh0aGlzLmV4cGxpY2l0bHlDbGVhcmVkKSB7IHJldHVybiB9XFxuICB0aGlzLmV4cGxpY2l0bHlDbGVhcmVkID0gdHJ1ZVxcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm1hcmtlcnMubGVuZ3RoOyArK2kpXFxuICAgIHsgdGhpcyQxLm1hcmtlcnNbaV0uY2xlYXIoKSB9XFxuICBzaWduYWxMYXRlcih0aGlzLCBcXFwiY2xlYXJcXFwiKVxcbn07XFxuXFxuU2hhcmVkVGV4dE1hcmtlci5wcm90b3R5cGUuZmluZCA9IGZ1bmN0aW9uIChzaWRlLCBsaW5lT2JqKSB7XFxuICByZXR1cm4gdGhpcy5wcmltYXJ5LmZpbmQoc2lkZSwgbGluZU9iailcXG59O1xcbmV2ZW50TWl4aW4oU2hhcmVkVGV4dE1hcmtlcilcXG5cXG5mdW5jdGlvbiBtYXJrVGV4dFNoYXJlZChkb2MsIGZyb20sIHRvLCBvcHRpb25zLCB0eXBlKSB7XFxuICBvcHRpb25zID0gY29weU9iaihvcHRpb25zKVxcbiAgb3B0aW9ucy5zaGFyZWQgPSBmYWxzZVxcbiAgdmFyIG1hcmtlcnMgPSBbbWFya1RleHQoZG9jLCBmcm9tLCB0bywgb3B0aW9ucywgdHlwZSldLCBwcmltYXJ5ID0gbWFya2Vyc1swXVxcbiAgdmFyIHdpZGdldCA9IG9wdGlvbnMud2lkZ2V0Tm9kZVxcbiAgbGlua2VkRG9jcyhkb2MsIGZ1bmN0aW9uIChkb2MpIHtcXG4gICAgaWYgKHdpZGdldCkgeyBvcHRpb25zLndpZGdldE5vZGUgPSB3aWRnZXQuY2xvbmVOb2RlKHRydWUpIH1cXG4gICAgbWFya2Vycy5wdXNoKG1hcmtUZXh0KGRvYywgY2xpcFBvcyhkb2MsIGZyb20pLCBjbGlwUG9zKGRvYywgdG8pLCBvcHRpb25zLCB0eXBlKSlcXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkb2MubGlua2VkLmxlbmd0aDsgKytpKVxcbiAgICAgIHsgaWYgKGRvYy5saW5rZWRbaV0uaXNQYXJlbnQpIHsgcmV0dXJuIH0gfVxcbiAgICBwcmltYXJ5ID0gbHN0KG1hcmtlcnMpXFxuICB9KVxcbiAgcmV0dXJuIG5ldyBTaGFyZWRUZXh0TWFya2VyKG1hcmtlcnMsIHByaW1hcnkpXFxufVxcblxcbmZ1bmN0aW9uIGZpbmRTaGFyZWRNYXJrZXJzKGRvYykge1xcbiAgcmV0dXJuIGRvYy5maW5kTWFya3MoUG9zKGRvYy5maXJzdCwgMCksIGRvYy5jbGlwUG9zKFBvcyhkb2MubGFzdExpbmUoKSkpLCBmdW5jdGlvbiAobSkgeyByZXR1cm4gbS5wYXJlbnQ7IH0pXFxufVxcblxcbmZ1bmN0aW9uIGNvcHlTaGFyZWRNYXJrZXJzKGRvYywgbWFya2Vycykge1xcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXJrZXJzLmxlbmd0aDsgaSsrKSB7XFxuICAgIHZhciBtYXJrZXIgPSBtYXJrZXJzW2ldLCBwb3MgPSBtYXJrZXIuZmluZCgpXFxuICAgIHZhciBtRnJvbSA9IGRvYy5jbGlwUG9zKHBvcy5mcm9tKSwgbVRvID0gZG9jLmNsaXBQb3MocG9zLnRvKVxcbiAgICBpZiAoY21wKG1Gcm9tLCBtVG8pKSB7XFxuICAgICAgdmFyIHN1Yk1hcmsgPSBtYXJrVGV4dChkb2MsIG1Gcm9tLCBtVG8sIG1hcmtlci5wcmltYXJ5LCBtYXJrZXIucHJpbWFyeS50eXBlKVxcbiAgICAgIG1hcmtlci5tYXJrZXJzLnB1c2goc3ViTWFyaylcXG4gICAgICBzdWJNYXJrLnBhcmVudCA9IG1hcmtlclxcbiAgICB9XFxuICB9XFxufVxcblxcbmZ1bmN0aW9uIGRldGFjaFNoYXJlZE1hcmtlcnMobWFya2Vycykge1xcbiAgdmFyIGxvb3AgPSBmdW5jdGlvbiAoIGkgKSB7XFxuICAgIHZhciBtYXJrZXIgPSBtYXJrZXJzW2ldLCBsaW5rZWQgPSBbbWFya2VyLnByaW1hcnkuZG9jXVxcbiAgICBsaW5rZWREb2NzKG1hcmtlci5wcmltYXJ5LmRvYywgZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGxpbmtlZC5wdXNoKGQpOyB9KVxcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IG1hcmtlci5tYXJrZXJzLmxlbmd0aDsgaisrKSB7XFxuICAgICAgdmFyIHN1Yk1hcmtlciA9IG1hcmtlci5tYXJrZXJzW2pdXFxuICAgICAgaWYgKGluZGV4T2YobGlua2VkLCBzdWJNYXJrZXIuZG9jKSA9PSAtMSkge1xcbiAgICAgICAgc3ViTWFya2VyLnBhcmVudCA9IG51bGxcXG4gICAgICAgIG1hcmtlci5tYXJrZXJzLnNwbGljZShqLS0sIDEpXFxuICAgICAgfVxcbiAgICB9XFxuICB9O1xcblxcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXJrZXJzLmxlbmd0aDsgaSsrKSBsb29wKCBpICk7XFxufVxcblxcbnZhciBuZXh0RG9jSWQgPSAwXFxudmFyIERvYyA9IGZ1bmN0aW9uKHRleHQsIG1vZGUsIGZpcnN0TGluZSwgbGluZVNlcCkge1xcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIERvYykpIHsgcmV0dXJuIG5ldyBEb2ModGV4dCwgbW9kZSwgZmlyc3RMaW5lLCBsaW5lU2VwKSB9XFxuICBpZiAoZmlyc3RMaW5lID09IG51bGwpIHsgZmlyc3RMaW5lID0gMCB9XFxuXFxuICBCcmFuY2hDaHVuay5jYWxsKHRoaXMsIFtuZXcgTGVhZkNodW5rKFtuZXcgTGluZShcXFwiXFxcIiwgbnVsbCldKV0pXFxuICB0aGlzLmZpcnN0ID0gZmlyc3RMaW5lXFxuICB0aGlzLnNjcm9sbFRvcCA9IHRoaXMuc2Nyb2xsTGVmdCA9IDBcXG4gIHRoaXMuY2FudEVkaXQgPSBmYWxzZVxcbiAgdGhpcy5jbGVhbkdlbmVyYXRpb24gPSAxXFxuICB0aGlzLmZyb250aWVyID0gZmlyc3RMaW5lXFxuICB2YXIgc3RhcnQgPSBQb3MoZmlyc3RMaW5lLCAwKVxcbiAgdGhpcy5zZWwgPSBzaW1wbGVTZWxlY3Rpb24oc3RhcnQpXFxuICB0aGlzLmhpc3RvcnkgPSBuZXcgSGlzdG9yeShudWxsKVxcbiAgdGhpcy5pZCA9ICsrbmV4dERvY0lkXFxuICB0aGlzLm1vZGVPcHRpb24gPSBtb2RlXFxuICB0aGlzLmxpbmVTZXAgPSBsaW5lU2VwXFxuICB0aGlzLmV4dGVuZCA9IGZhbHNlXFxuXFxuICBpZiAodHlwZW9mIHRleHQgPT0gXFxcInN0cmluZ1xcXCIpIHsgdGV4dCA9IHRoaXMuc3BsaXRMaW5lcyh0ZXh0KSB9XFxuICB1cGRhdGVEb2ModGhpcywge2Zyb206IHN0YXJ0LCB0bzogc3RhcnQsIHRleHQ6IHRleHR9KVxcbiAgc2V0U2VsZWN0aW9uKHRoaXMsIHNpbXBsZVNlbGVjdGlvbihzdGFydCksIHNlbF9kb250U2Nyb2xsKVxcbn1cXG5cXG5Eb2MucHJvdG90eXBlID0gY3JlYXRlT2JqKEJyYW5jaENodW5rLnByb3RvdHlwZSwge1xcbiAgY29uc3RydWN0b3I6IERvYyxcXG4gIC8vIEl0ZXJhdGUgb3ZlciB0aGUgZG9jdW1lbnQuIFN1cHBvcnRzIHR3byBmb3JtcyAtLSB3aXRoIG9ubHkgb25lXFxuICAvLyBhcmd1bWVudCwgaXQgY2FsbHMgdGhhdCBmb3IgZWFjaCBsaW5lIGluIHRoZSBkb2N1bWVudC4gV2l0aFxcbiAgLy8gdGhyZWUsIGl0IGl0ZXJhdGVzIG92ZXIgdGhlIHJhbmdlIGdpdmVuIGJ5IHRoZSBmaXJzdCB0d28gKHdpdGhcXG4gIC8vIHRoZSBzZWNvbmQgYmVpbmcgbm9uLWluY2x1c2l2ZSkuXFxuICBpdGVyOiBmdW5jdGlvbihmcm9tLCB0bywgb3ApIHtcXG4gICAgaWYgKG9wKSB7IHRoaXMuaXRlck4oZnJvbSAtIHRoaXMuZmlyc3QsIHRvIC0gZnJvbSwgb3ApIH1cXG4gICAgZWxzZSB7IHRoaXMuaXRlck4odGhpcy5maXJzdCwgdGhpcy5maXJzdCArIHRoaXMuc2l6ZSwgZnJvbSkgfVxcbiAgfSxcXG5cXG4gIC8vIE5vbi1wdWJsaWMgaW50ZXJmYWNlIGZvciBhZGRpbmcgYW5kIHJlbW92aW5nIGxpbmVzLlxcbiAgaW5zZXJ0OiBmdW5jdGlvbihhdCwgbGluZXMpIHtcXG4gICAgdmFyIGhlaWdodCA9IDBcXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7ICsraSkgeyBoZWlnaHQgKz0gbGluZXNbaV0uaGVpZ2h0IH1cXG4gICAgdGhpcy5pbnNlcnRJbm5lcihhdCAtIHRoaXMuZmlyc3QsIGxpbmVzLCBoZWlnaHQpXFxuICB9LFxcbiAgcmVtb3ZlOiBmdW5jdGlvbihhdCwgbikgeyB0aGlzLnJlbW92ZUlubmVyKGF0IC0gdGhpcy5maXJzdCwgbikgfSxcXG5cXG4gIC8vIEZyb20gaGVyZSwgdGhlIG1ldGhvZHMgYXJlIHBhcnQgb2YgdGhlIHB1YmxpYyBpbnRlcmZhY2UuIE1vc3RcXG4gIC8vIGFyZSBhbHNvIGF2YWlsYWJsZSBmcm9tIENvZGVNaXJyb3IgKGVkaXRvcikgaW5zdGFuY2VzLlxcblxcbiAgZ2V0VmFsdWU6IGZ1bmN0aW9uKGxpbmVTZXApIHtcXG4gICAgdmFyIGxpbmVzID0gZ2V0TGluZXModGhpcywgdGhpcy5maXJzdCwgdGhpcy5maXJzdCArIHRoaXMuc2l6ZSlcXG4gICAgaWYgKGxpbmVTZXAgPT09IGZhbHNlKSB7IHJldHVybiBsaW5lcyB9XFxuICAgIHJldHVybiBsaW5lcy5qb2luKGxpbmVTZXAgfHwgdGhpcy5saW5lU2VwYXJhdG9yKCkpXFxuICB9LFxcbiAgc2V0VmFsdWU6IGRvY01ldGhvZE9wKGZ1bmN0aW9uKGNvZGUpIHtcXG4gICAgdmFyIHRvcCA9IFBvcyh0aGlzLmZpcnN0LCAwKSwgbGFzdCA9IHRoaXMuZmlyc3QgKyB0aGlzLnNpemUgLSAxXFxuICAgIG1ha2VDaGFuZ2UodGhpcywge2Zyb206IHRvcCwgdG86IFBvcyhsYXN0LCBnZXRMaW5lKHRoaXMsIGxhc3QpLnRleHQubGVuZ3RoKSxcXG4gICAgICAgICAgICAgICAgICAgICAgdGV4dDogdGhpcy5zcGxpdExpbmVzKGNvZGUpLCBvcmlnaW46IFxcXCJzZXRWYWx1ZVxcXCIsIGZ1bGw6IHRydWV9LCB0cnVlKVxcbiAgICBzZXRTZWxlY3Rpb24odGhpcywgc2ltcGxlU2VsZWN0aW9uKHRvcCkpXFxuICB9KSxcXG4gIHJlcGxhY2VSYW5nZTogZnVuY3Rpb24oY29kZSwgZnJvbSwgdG8sIG9yaWdpbikge1xcbiAgICBmcm9tID0gY2xpcFBvcyh0aGlzLCBmcm9tKVxcbiAgICB0byA9IHRvID8gY2xpcFBvcyh0aGlzLCB0bykgOiBmcm9tXFxuICAgIHJlcGxhY2VSYW5nZSh0aGlzLCBjb2RlLCBmcm9tLCB0bywgb3JpZ2luKVxcbiAgfSxcXG4gIGdldFJhbmdlOiBmdW5jdGlvbihmcm9tLCB0bywgbGluZVNlcCkge1xcbiAgICB2YXIgbGluZXMgPSBnZXRCZXR3ZWVuKHRoaXMsIGNsaXBQb3ModGhpcywgZnJvbSksIGNsaXBQb3ModGhpcywgdG8pKVxcbiAgICBpZiAobGluZVNlcCA9PT0gZmFsc2UpIHsgcmV0dXJuIGxpbmVzIH1cXG4gICAgcmV0dXJuIGxpbmVzLmpvaW4obGluZVNlcCB8fCB0aGlzLmxpbmVTZXBhcmF0b3IoKSlcXG4gIH0sXFxuXFxuICBnZXRMaW5lOiBmdW5jdGlvbihsaW5lKSB7dmFyIGwgPSB0aGlzLmdldExpbmVIYW5kbGUobGluZSk7IHJldHVybiBsICYmIGwudGV4dH0sXFxuXFxuICBnZXRMaW5lSGFuZGxlOiBmdW5jdGlvbihsaW5lKSB7aWYgKGlzTGluZSh0aGlzLCBsaW5lKSkgeyByZXR1cm4gZ2V0TGluZSh0aGlzLCBsaW5lKSB9fSxcXG4gIGdldExpbmVOdW1iZXI6IGZ1bmN0aW9uKGxpbmUpIHtyZXR1cm4gbGluZU5vKGxpbmUpfSxcXG5cXG4gIGdldExpbmVIYW5kbGVWaXN1YWxTdGFydDogZnVuY3Rpb24obGluZSkge1xcbiAgICBpZiAodHlwZW9mIGxpbmUgPT0gXFxcIm51bWJlclxcXCIpIHsgbGluZSA9IGdldExpbmUodGhpcywgbGluZSkgfVxcbiAgICByZXR1cm4gdmlzdWFsTGluZShsaW5lKVxcbiAgfSxcXG5cXG4gIGxpbmVDb3VudDogZnVuY3Rpb24oKSB7cmV0dXJuIHRoaXMuc2l6ZX0sXFxuICBmaXJzdExpbmU6IGZ1bmN0aW9uKCkge3JldHVybiB0aGlzLmZpcnN0fSxcXG4gIGxhc3RMaW5lOiBmdW5jdGlvbigpIHtyZXR1cm4gdGhpcy5maXJzdCArIHRoaXMuc2l6ZSAtIDF9LFxcblxcbiAgY2xpcFBvczogZnVuY3Rpb24ocG9zKSB7cmV0dXJuIGNsaXBQb3ModGhpcywgcG9zKX0sXFxuXFxuICBnZXRDdXJzb3I6IGZ1bmN0aW9uKHN0YXJ0KSB7XFxuICAgIHZhciByYW5nZSA9IHRoaXMuc2VsLnByaW1hcnkoKSwgcG9zXFxuICAgIGlmIChzdGFydCA9PSBudWxsIHx8IHN0YXJ0ID09IFxcXCJoZWFkXFxcIikgeyBwb3MgPSByYW5nZS5oZWFkIH1cXG4gICAgZWxzZSBpZiAoc3RhcnQgPT0gXFxcImFuY2hvclxcXCIpIHsgcG9zID0gcmFuZ2UuYW5jaG9yIH1cXG4gICAgZWxzZSBpZiAoc3RhcnQgPT0gXFxcImVuZFxcXCIgfHwgc3RhcnQgPT0gXFxcInRvXFxcIiB8fCBzdGFydCA9PT0gZmFsc2UpIHsgcG9zID0gcmFuZ2UudG8oKSB9XFxuICAgIGVsc2UgeyBwb3MgPSByYW5nZS5mcm9tKCkgfVxcbiAgICByZXR1cm4gcG9zXFxuICB9LFxcbiAgbGlzdFNlbGVjdGlvbnM6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5zZWwucmFuZ2VzIH0sXFxuICBzb21ldGhpbmdTZWxlY3RlZDogZnVuY3Rpb24oKSB7cmV0dXJuIHRoaXMuc2VsLnNvbWV0aGluZ1NlbGVjdGVkKCl9LFxcblxcbiAgc2V0Q3Vyc29yOiBkb2NNZXRob2RPcChmdW5jdGlvbihsaW5lLCBjaCwgb3B0aW9ucykge1xcbiAgICBzZXRTaW1wbGVTZWxlY3Rpb24odGhpcywgY2xpcFBvcyh0aGlzLCB0eXBlb2YgbGluZSA9PSBcXFwibnVtYmVyXFxcIiA/IFBvcyhsaW5lLCBjaCB8fCAwKSA6IGxpbmUpLCBudWxsLCBvcHRpb25zKVxcbiAgfSksXFxuICBzZXRTZWxlY3Rpb246IGRvY01ldGhvZE9wKGZ1bmN0aW9uKGFuY2hvciwgaGVhZCwgb3B0aW9ucykge1xcbiAgICBzZXRTaW1wbGVTZWxlY3Rpb24odGhpcywgY2xpcFBvcyh0aGlzLCBhbmNob3IpLCBjbGlwUG9zKHRoaXMsIGhlYWQgfHwgYW5jaG9yKSwgb3B0aW9ucylcXG4gIH0pLFxcbiAgZXh0ZW5kU2VsZWN0aW9uOiBkb2NNZXRob2RPcChmdW5jdGlvbihoZWFkLCBvdGhlciwgb3B0aW9ucykge1xcbiAgICBleHRlbmRTZWxlY3Rpb24odGhpcywgY2xpcFBvcyh0aGlzLCBoZWFkKSwgb3RoZXIgJiYgY2xpcFBvcyh0aGlzLCBvdGhlciksIG9wdGlvbnMpXFxuICB9KSxcXG4gIGV4dGVuZFNlbGVjdGlvbnM6IGRvY01ldGhvZE9wKGZ1bmN0aW9uKGhlYWRzLCBvcHRpb25zKSB7XFxuICAgIGV4dGVuZFNlbGVjdGlvbnModGhpcywgY2xpcFBvc0FycmF5KHRoaXMsIGhlYWRzKSwgb3B0aW9ucylcXG4gIH0pLFxcbiAgZXh0ZW5kU2VsZWN0aW9uc0J5OiBkb2NNZXRob2RPcChmdW5jdGlvbihmLCBvcHRpb25zKSB7XFxuICAgIHZhciBoZWFkcyA9IG1hcCh0aGlzLnNlbC5yYW5nZXMsIGYpXFxuICAgIGV4dGVuZFNlbGVjdGlvbnModGhpcywgY2xpcFBvc0FycmF5KHRoaXMsIGhlYWRzKSwgb3B0aW9ucylcXG4gIH0pLFxcbiAgc2V0U2VsZWN0aW9uczogZG9jTWV0aG9kT3AoZnVuY3Rpb24ocmFuZ2VzLCBwcmltYXJ5LCBvcHRpb25zKSB7XFxuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xcblxcbiAgICBpZiAoIXJhbmdlcy5sZW5ndGgpIHsgcmV0dXJuIH1cXG4gICAgdmFyIG91dCA9IFtdXFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmFuZ2VzLmxlbmd0aDsgaSsrKVxcbiAgICAgIHsgb3V0W2ldID0gbmV3IFJhbmdlKGNsaXBQb3ModGhpcyQxLCByYW5nZXNbaV0uYW5jaG9yKSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgY2xpcFBvcyh0aGlzJDEsIHJhbmdlc1tpXS5oZWFkKSkgfVxcbiAgICBpZiAocHJpbWFyeSA9PSBudWxsKSB7IHByaW1hcnkgPSBNYXRoLm1pbihyYW5nZXMubGVuZ3RoIC0gMSwgdGhpcy5zZWwucHJpbUluZGV4KSB9XFxuICAgIHNldFNlbGVjdGlvbih0aGlzLCBub3JtYWxpemVTZWxlY3Rpb24ob3V0LCBwcmltYXJ5KSwgb3B0aW9ucylcXG4gIH0pLFxcbiAgYWRkU2VsZWN0aW9uOiBkb2NNZXRob2RPcChmdW5jdGlvbihhbmNob3IsIGhlYWQsIG9wdGlvbnMpIHtcXG4gICAgdmFyIHJhbmdlcyA9IHRoaXMuc2VsLnJhbmdlcy5zbGljZSgwKVxcbiAgICByYW5nZXMucHVzaChuZXcgUmFuZ2UoY2xpcFBvcyh0aGlzLCBhbmNob3IpLCBjbGlwUG9zKHRoaXMsIGhlYWQgfHwgYW5jaG9yKSkpXFxuICAgIHNldFNlbGVjdGlvbih0aGlzLCBub3JtYWxpemVTZWxlY3Rpb24ocmFuZ2VzLCByYW5nZXMubGVuZ3RoIC0gMSksIG9wdGlvbnMpXFxuICB9KSxcXG5cXG4gIGdldFNlbGVjdGlvbjogZnVuY3Rpb24obGluZVNlcCkge1xcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcXG5cXG4gICAgdmFyIHJhbmdlcyA9IHRoaXMuc2VsLnJhbmdlcywgbGluZXNcXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCByYW5nZXMubGVuZ3RoOyBpKyspIHtcXG4gICAgICB2YXIgc2VsID0gZ2V0QmV0d2Vlbih0aGlzJDEsIHJhbmdlc1tpXS5mcm9tKCksIHJhbmdlc1tpXS50bygpKVxcbiAgICAgIGxpbmVzID0gbGluZXMgPyBsaW5lcy5jb25jYXQoc2VsKSA6IHNlbFxcbiAgICB9XFxuICAgIGlmIChsaW5lU2VwID09PSBmYWxzZSkgeyByZXR1cm4gbGluZXMgfVxcbiAgICBlbHNlIHsgcmV0dXJuIGxpbmVzLmpvaW4obGluZVNlcCB8fCB0aGlzLmxpbmVTZXBhcmF0b3IoKSkgfVxcbiAgfSxcXG4gIGdldFNlbGVjdGlvbnM6IGZ1bmN0aW9uKGxpbmVTZXApIHtcXG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XFxuXFxuICAgIHZhciBwYXJ0cyA9IFtdLCByYW5nZXMgPSB0aGlzLnNlbC5yYW5nZXNcXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCByYW5nZXMubGVuZ3RoOyBpKyspIHtcXG4gICAgICB2YXIgc2VsID0gZ2V0QmV0d2Vlbih0aGlzJDEsIHJhbmdlc1tpXS5mcm9tKCksIHJhbmdlc1tpXS50bygpKVxcbiAgICAgIGlmIChsaW5lU2VwICE9PSBmYWxzZSkgeyBzZWwgPSBzZWwuam9pbihsaW5lU2VwIHx8IHRoaXMkMS5saW5lU2VwYXJhdG9yKCkpIH1cXG4gICAgICBwYXJ0c1tpXSA9IHNlbFxcbiAgICB9XFxuICAgIHJldHVybiBwYXJ0c1xcbiAgfSxcXG4gIHJlcGxhY2VTZWxlY3Rpb246IGZ1bmN0aW9uKGNvZGUsIGNvbGxhcHNlLCBvcmlnaW4pIHtcXG4gICAgdmFyIGR1cCA9IFtdXFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5zZWwucmFuZ2VzLmxlbmd0aDsgaSsrKVxcbiAgICAgIHsgZHVwW2ldID0gY29kZSB9XFxuICAgIHRoaXMucmVwbGFjZVNlbGVjdGlvbnMoZHVwLCBjb2xsYXBzZSwgb3JpZ2luIHx8IFxcXCIraW5wdXRcXFwiKVxcbiAgfSxcXG4gIHJlcGxhY2VTZWxlY3Rpb25zOiBkb2NNZXRob2RPcChmdW5jdGlvbihjb2RlLCBjb2xsYXBzZSwgb3JpZ2luKSB7XFxuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xcblxcbiAgICB2YXIgY2hhbmdlcyA9IFtdLCBzZWwgPSB0aGlzLnNlbFxcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlbC5yYW5nZXMubGVuZ3RoOyBpKyspIHtcXG4gICAgICB2YXIgcmFuZ2UgPSBzZWwucmFuZ2VzW2ldXFxuICAgICAgY2hhbmdlc1tpXSA9IHtmcm9tOiByYW5nZS5mcm9tKCksIHRvOiByYW5nZS50bygpLCB0ZXh0OiB0aGlzJDEuc3BsaXRMaW5lcyhjb2RlW2ldKSwgb3JpZ2luOiBvcmlnaW59XFxuICAgIH1cXG4gICAgdmFyIG5ld1NlbCA9IGNvbGxhcHNlICYmIGNvbGxhcHNlICE9IFxcXCJlbmRcXFwiICYmIGNvbXB1dGVSZXBsYWNlZFNlbCh0aGlzLCBjaGFuZ2VzLCBjb2xsYXBzZSlcXG4gICAgZm9yICh2YXIgaSQxID0gY2hhbmdlcy5sZW5ndGggLSAxOyBpJDEgPj0gMDsgaSQxLS0pXFxuICAgICAgeyBtYWtlQ2hhbmdlKHRoaXMkMSwgY2hhbmdlc1tpJDFdKSB9XFxuICAgIGlmIChuZXdTZWwpIHsgc2V0U2VsZWN0aW9uUmVwbGFjZUhpc3RvcnkodGhpcywgbmV3U2VsKSB9XFxuICAgIGVsc2UgaWYgKHRoaXMuY20pIHsgZW5zdXJlQ3Vyc29yVmlzaWJsZSh0aGlzLmNtKSB9XFxuICB9KSxcXG4gIHVuZG86IGRvY01ldGhvZE9wKGZ1bmN0aW9uKCkge21ha2VDaGFuZ2VGcm9tSGlzdG9yeSh0aGlzLCBcXFwidW5kb1xcXCIpfSksXFxuICByZWRvOiBkb2NNZXRob2RPcChmdW5jdGlvbigpIHttYWtlQ2hhbmdlRnJvbUhpc3RvcnkodGhpcywgXFxcInJlZG9cXFwiKX0pLFxcbiAgdW5kb1NlbGVjdGlvbjogZG9jTWV0aG9kT3AoZnVuY3Rpb24oKSB7bWFrZUNoYW5nZUZyb21IaXN0b3J5KHRoaXMsIFxcXCJ1bmRvXFxcIiwgdHJ1ZSl9KSxcXG4gIHJlZG9TZWxlY3Rpb246IGRvY01ldGhvZE9wKGZ1bmN0aW9uKCkge21ha2VDaGFuZ2VGcm9tSGlzdG9yeSh0aGlzLCBcXFwicmVkb1xcXCIsIHRydWUpfSksXFxuXFxuICBzZXRFeHRlbmRpbmc6IGZ1bmN0aW9uKHZhbCkge3RoaXMuZXh0ZW5kID0gdmFsfSxcXG4gIGdldEV4dGVuZGluZzogZnVuY3Rpb24oKSB7cmV0dXJuIHRoaXMuZXh0ZW5kfSxcXG5cXG4gIGhpc3RvcnlTaXplOiBmdW5jdGlvbigpIHtcXG4gICAgdmFyIGhpc3QgPSB0aGlzLmhpc3RvcnksIGRvbmUgPSAwLCB1bmRvbmUgPSAwXFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaGlzdC5kb25lLmxlbmd0aDsgaSsrKSB7IGlmICghaGlzdC5kb25lW2ldLnJhbmdlcykgeyArK2RvbmUgfSB9XFxuICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IGhpc3QudW5kb25lLmxlbmd0aDsgaSQxKyspIHsgaWYgKCFoaXN0LnVuZG9uZVtpJDFdLnJhbmdlcykgeyArK3VuZG9uZSB9IH1cXG4gICAgcmV0dXJuIHt1bmRvOiBkb25lLCByZWRvOiB1bmRvbmV9XFxuICB9LFxcbiAgY2xlYXJIaXN0b3J5OiBmdW5jdGlvbigpIHt0aGlzLmhpc3RvcnkgPSBuZXcgSGlzdG9yeSh0aGlzLmhpc3RvcnkubWF4R2VuZXJhdGlvbil9LFxcblxcbiAgbWFya0NsZWFuOiBmdW5jdGlvbigpIHtcXG4gICAgdGhpcy5jbGVhbkdlbmVyYXRpb24gPSB0aGlzLmNoYW5nZUdlbmVyYXRpb24odHJ1ZSlcXG4gIH0sXFxuICBjaGFuZ2VHZW5lcmF0aW9uOiBmdW5jdGlvbihmb3JjZVNwbGl0KSB7XFxuICAgIGlmIChmb3JjZVNwbGl0KVxcbiAgICAgIHsgdGhpcy5oaXN0b3J5Lmxhc3RPcCA9IHRoaXMuaGlzdG9yeS5sYXN0U2VsT3AgPSB0aGlzLmhpc3RvcnkubGFzdE9yaWdpbiA9IG51bGwgfVxcbiAgICByZXR1cm4gdGhpcy5oaXN0b3J5LmdlbmVyYXRpb25cXG4gIH0sXFxuICBpc0NsZWFuOiBmdW5jdGlvbiAoZ2VuKSB7XFxuICAgIHJldHVybiB0aGlzLmhpc3RvcnkuZ2VuZXJhdGlvbiA9PSAoZ2VuIHx8IHRoaXMuY2xlYW5HZW5lcmF0aW9uKVxcbiAgfSxcXG5cXG4gIGdldEhpc3Rvcnk6IGZ1bmN0aW9uKCkge1xcbiAgICByZXR1cm4ge2RvbmU6IGNvcHlIaXN0b3J5QXJyYXkodGhpcy5oaXN0b3J5LmRvbmUpLFxcbiAgICAgICAgICAgIHVuZG9uZTogY29weUhpc3RvcnlBcnJheSh0aGlzLmhpc3RvcnkudW5kb25lKX1cXG4gIH0sXFxuICBzZXRIaXN0b3J5OiBmdW5jdGlvbihoaXN0RGF0YSkge1xcbiAgICB2YXIgaGlzdCA9IHRoaXMuaGlzdG9yeSA9IG5ldyBIaXN0b3J5KHRoaXMuaGlzdG9yeS5tYXhHZW5lcmF0aW9uKVxcbiAgICBoaXN0LmRvbmUgPSBjb3B5SGlzdG9yeUFycmF5KGhpc3REYXRhLmRvbmUuc2xpY2UoMCksIG51bGwsIHRydWUpXFxuICAgIGhpc3QudW5kb25lID0gY29weUhpc3RvcnlBcnJheShoaXN0RGF0YS51bmRvbmUuc2xpY2UoMCksIG51bGwsIHRydWUpXFxuICB9LFxcblxcbiAgc2V0R3V0dGVyTWFya2VyOiBkb2NNZXRob2RPcChmdW5jdGlvbihsaW5lLCBndXR0ZXJJRCwgdmFsdWUpIHtcXG4gICAgcmV0dXJuIGNoYW5nZUxpbmUodGhpcywgbGluZSwgXFxcImd1dHRlclxcXCIsIGZ1bmN0aW9uIChsaW5lKSB7XFxuICAgICAgdmFyIG1hcmtlcnMgPSBsaW5lLmd1dHRlck1hcmtlcnMgfHwgKGxpbmUuZ3V0dGVyTWFya2VycyA9IHt9KVxcbiAgICAgIG1hcmtlcnNbZ3V0dGVySURdID0gdmFsdWVcXG4gICAgICBpZiAoIXZhbHVlICYmIGlzRW1wdHkobWFya2VycykpIHsgbGluZS5ndXR0ZXJNYXJrZXJzID0gbnVsbCB9XFxuICAgICAgcmV0dXJuIHRydWVcXG4gICAgfSlcXG4gIH0pLFxcblxcbiAgY2xlYXJHdXR0ZXI6IGRvY01ldGhvZE9wKGZ1bmN0aW9uKGd1dHRlcklEKSB7XFxuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xcblxcbiAgICB0aGlzLml0ZXIoZnVuY3Rpb24gKGxpbmUpIHtcXG4gICAgICBpZiAobGluZS5ndXR0ZXJNYXJrZXJzICYmIGxpbmUuZ3V0dGVyTWFya2Vyc1tndXR0ZXJJRF0pIHtcXG4gICAgICAgIGNoYW5nZUxpbmUodGhpcyQxLCBsaW5lLCBcXFwiZ3V0dGVyXFxcIiwgZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICBsaW5lLmd1dHRlck1hcmtlcnNbZ3V0dGVySURdID0gbnVsbFxcbiAgICAgICAgICBpZiAoaXNFbXB0eShsaW5lLmd1dHRlck1hcmtlcnMpKSB7IGxpbmUuZ3V0dGVyTWFya2VycyA9IG51bGwgfVxcbiAgICAgICAgICByZXR1cm4gdHJ1ZVxcbiAgICAgICAgfSlcXG4gICAgICB9XFxuICAgIH0pXFxuICB9KSxcXG5cXG4gIGxpbmVJbmZvOiBmdW5jdGlvbihsaW5lKSB7XFxuICAgIHZhciBuXFxuICAgIGlmICh0eXBlb2YgbGluZSA9PSBcXFwibnVtYmVyXFxcIikge1xcbiAgICAgIGlmICghaXNMaW5lKHRoaXMsIGxpbmUpKSB7IHJldHVybiBudWxsIH1cXG4gICAgICBuID0gbGluZVxcbiAgICAgIGxpbmUgPSBnZXRMaW5lKHRoaXMsIGxpbmUpXFxuICAgICAgaWYgKCFsaW5lKSB7IHJldHVybiBudWxsIH1cXG4gICAgfSBlbHNlIHtcXG4gICAgICBuID0gbGluZU5vKGxpbmUpXFxuICAgICAgaWYgKG4gPT0gbnVsbCkgeyByZXR1cm4gbnVsbCB9XFxuICAgIH1cXG4gICAgcmV0dXJuIHtsaW5lOiBuLCBoYW5kbGU6IGxpbmUsIHRleHQ6IGxpbmUudGV4dCwgZ3V0dGVyTWFya2VyczogbGluZS5ndXR0ZXJNYXJrZXJzLFxcbiAgICAgICAgICAgIHRleHRDbGFzczogbGluZS50ZXh0Q2xhc3MsIGJnQ2xhc3M6IGxpbmUuYmdDbGFzcywgd3JhcENsYXNzOiBsaW5lLndyYXBDbGFzcyxcXG4gICAgICAgICAgICB3aWRnZXRzOiBsaW5lLndpZGdldHN9XFxuICB9LFxcblxcbiAgYWRkTGluZUNsYXNzOiBkb2NNZXRob2RPcChmdW5jdGlvbihoYW5kbGUsIHdoZXJlLCBjbHMpIHtcXG4gICAgcmV0dXJuIGNoYW5nZUxpbmUodGhpcywgaGFuZGxlLCB3aGVyZSA9PSBcXFwiZ3V0dGVyXFxcIiA/IFxcXCJndXR0ZXJcXFwiIDogXFxcImNsYXNzXFxcIiwgZnVuY3Rpb24gKGxpbmUpIHtcXG4gICAgICB2YXIgcHJvcCA9IHdoZXJlID09IFxcXCJ0ZXh0XFxcIiA/IFxcXCJ0ZXh0Q2xhc3NcXFwiXFxuICAgICAgICAgICAgICAgOiB3aGVyZSA9PSBcXFwiYmFja2dyb3VuZFxcXCIgPyBcXFwiYmdDbGFzc1xcXCJcXG4gICAgICAgICAgICAgICA6IHdoZXJlID09IFxcXCJndXR0ZXJcXFwiID8gXFxcImd1dHRlckNsYXNzXFxcIiA6IFxcXCJ3cmFwQ2xhc3NcXFwiXFxuICAgICAgaWYgKCFsaW5lW3Byb3BdKSB7IGxpbmVbcHJvcF0gPSBjbHMgfVxcbiAgICAgIGVsc2UgaWYgKGNsYXNzVGVzdChjbHMpLnRlc3QobGluZVtwcm9wXSkpIHsgcmV0dXJuIGZhbHNlIH1cXG4gICAgICBlbHNlIHsgbGluZVtwcm9wXSArPSBcXFwiIFxcXCIgKyBjbHMgfVxcbiAgICAgIHJldHVybiB0cnVlXFxuICAgIH0pXFxuICB9KSxcXG4gIHJlbW92ZUxpbmVDbGFzczogZG9jTWV0aG9kT3AoZnVuY3Rpb24oaGFuZGxlLCB3aGVyZSwgY2xzKSB7XFxuICAgIHJldHVybiBjaGFuZ2VMaW5lKHRoaXMsIGhhbmRsZSwgd2hlcmUgPT0gXFxcImd1dHRlclxcXCIgPyBcXFwiZ3V0dGVyXFxcIiA6IFxcXCJjbGFzc1xcXCIsIGZ1bmN0aW9uIChsaW5lKSB7XFxuICAgICAgdmFyIHByb3AgPSB3aGVyZSA9PSBcXFwidGV4dFxcXCIgPyBcXFwidGV4dENsYXNzXFxcIlxcbiAgICAgICAgICAgICAgIDogd2hlcmUgPT0gXFxcImJhY2tncm91bmRcXFwiID8gXFxcImJnQ2xhc3NcXFwiXFxuICAgICAgICAgICAgICAgOiB3aGVyZSA9PSBcXFwiZ3V0dGVyXFxcIiA/IFxcXCJndXR0ZXJDbGFzc1xcXCIgOiBcXFwid3JhcENsYXNzXFxcIlxcbiAgICAgIHZhciBjdXIgPSBsaW5lW3Byb3BdXFxuICAgICAgaWYgKCFjdXIpIHsgcmV0dXJuIGZhbHNlIH1cXG4gICAgICBlbHNlIGlmIChjbHMgPT0gbnVsbCkgeyBsaW5lW3Byb3BdID0gbnVsbCB9XFxuICAgICAgZWxzZSB7XFxuICAgICAgICB2YXIgZm91bmQgPSBjdXIubWF0Y2goY2xhc3NUZXN0KGNscykpXFxuICAgICAgICBpZiAoIWZvdW5kKSB7IHJldHVybiBmYWxzZSB9XFxuICAgICAgICB2YXIgZW5kID0gZm91bmQuaW5kZXggKyBmb3VuZFswXS5sZW5ndGhcXG4gICAgICAgIGxpbmVbcHJvcF0gPSBjdXIuc2xpY2UoMCwgZm91bmQuaW5kZXgpICsgKCFmb3VuZC5pbmRleCB8fCBlbmQgPT0gY3VyLmxlbmd0aCA/IFxcXCJcXFwiIDogXFxcIiBcXFwiKSArIGN1ci5zbGljZShlbmQpIHx8IG51bGxcXG4gICAgICB9XFxuICAgICAgcmV0dXJuIHRydWVcXG4gICAgfSlcXG4gIH0pLFxcblxcbiAgYWRkTGluZVdpZGdldDogZG9jTWV0aG9kT3AoZnVuY3Rpb24oaGFuZGxlLCBub2RlLCBvcHRpb25zKSB7XFxuICAgIHJldHVybiBhZGRMaW5lV2lkZ2V0KHRoaXMsIGhhbmRsZSwgbm9kZSwgb3B0aW9ucylcXG4gIH0pLFxcbiAgcmVtb3ZlTGluZVdpZGdldDogZnVuY3Rpb24od2lkZ2V0KSB7IHdpZGdldC5jbGVhcigpIH0sXFxuXFxuICBtYXJrVGV4dDogZnVuY3Rpb24oZnJvbSwgdG8sIG9wdGlvbnMpIHtcXG4gICAgcmV0dXJuIG1hcmtUZXh0KHRoaXMsIGNsaXBQb3ModGhpcywgZnJvbSksIGNsaXBQb3ModGhpcywgdG8pLCBvcHRpb25zLCBvcHRpb25zICYmIG9wdGlvbnMudHlwZSB8fCBcXFwicmFuZ2VcXFwiKVxcbiAgfSxcXG4gIHNldEJvb2ttYXJrOiBmdW5jdGlvbihwb3MsIG9wdGlvbnMpIHtcXG4gICAgdmFyIHJlYWxPcHRzID0ge3JlcGxhY2VkV2l0aDogb3B0aW9ucyAmJiAob3B0aW9ucy5ub2RlVHlwZSA9PSBudWxsID8gb3B0aW9ucy53aWRnZXQgOiBvcHRpb25zKSxcXG4gICAgICAgICAgICAgICAgICAgIGluc2VydExlZnQ6IG9wdGlvbnMgJiYgb3B0aW9ucy5pbnNlcnRMZWZ0LFxcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJXaGVuRW1wdHk6IGZhbHNlLCBzaGFyZWQ6IG9wdGlvbnMgJiYgb3B0aW9ucy5zaGFyZWQsXFxuICAgICAgICAgICAgICAgICAgICBoYW5kbGVNb3VzZUV2ZW50czogb3B0aW9ucyAmJiBvcHRpb25zLmhhbmRsZU1vdXNlRXZlbnRzfVxcbiAgICBwb3MgPSBjbGlwUG9zKHRoaXMsIHBvcylcXG4gICAgcmV0dXJuIG1hcmtUZXh0KHRoaXMsIHBvcywgcG9zLCByZWFsT3B0cywgXFxcImJvb2ttYXJrXFxcIilcXG4gIH0sXFxuICBmaW5kTWFya3NBdDogZnVuY3Rpb24ocG9zKSB7XFxuICAgIHBvcyA9IGNsaXBQb3ModGhpcywgcG9zKVxcbiAgICB2YXIgbWFya2VycyA9IFtdLCBzcGFucyA9IGdldExpbmUodGhpcywgcG9zLmxpbmUpLm1hcmtlZFNwYW5zXFxuICAgIGlmIChzcGFucykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHNwYW5zLmxlbmd0aDsgKytpKSB7XFxuICAgICAgdmFyIHNwYW4gPSBzcGFuc1tpXVxcbiAgICAgIGlmICgoc3Bhbi5mcm9tID09IG51bGwgfHwgc3Bhbi5mcm9tIDw9IHBvcy5jaCkgJiZcXG4gICAgICAgICAgKHNwYW4udG8gPT0gbnVsbCB8fCBzcGFuLnRvID49IHBvcy5jaCkpXFxuICAgICAgICB7IG1hcmtlcnMucHVzaChzcGFuLm1hcmtlci5wYXJlbnQgfHwgc3Bhbi5tYXJrZXIpIH1cXG4gICAgfSB9XFxuICAgIHJldHVybiBtYXJrZXJzXFxuICB9LFxcbiAgZmluZE1hcmtzOiBmdW5jdGlvbihmcm9tLCB0bywgZmlsdGVyKSB7XFxuICAgIGZyb20gPSBjbGlwUG9zKHRoaXMsIGZyb20pOyB0byA9IGNsaXBQb3ModGhpcywgdG8pXFxuICAgIHZhciBmb3VuZCA9IFtdLCBsaW5lTm8gPSBmcm9tLmxpbmVcXG4gICAgdGhpcy5pdGVyKGZyb20ubGluZSwgdG8ubGluZSArIDEsIGZ1bmN0aW9uIChsaW5lKSB7XFxuICAgICAgdmFyIHNwYW5zID0gbGluZS5tYXJrZWRTcGFuc1xcbiAgICAgIGlmIChzcGFucykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHNwYW5zLmxlbmd0aDsgaSsrKSB7XFxuICAgICAgICB2YXIgc3BhbiA9IHNwYW5zW2ldXFxuICAgICAgICBpZiAoIShzcGFuLnRvICE9IG51bGwgJiYgbGluZU5vID09IGZyb20ubGluZSAmJiBmcm9tLmNoID49IHNwYW4udG8gfHxcXG4gICAgICAgICAgICAgIHNwYW4uZnJvbSA9PSBudWxsICYmIGxpbmVObyAhPSBmcm9tLmxpbmUgfHxcXG4gICAgICAgICAgICAgIHNwYW4uZnJvbSAhPSBudWxsICYmIGxpbmVObyA9PSB0by5saW5lICYmIHNwYW4uZnJvbSA+PSB0by5jaCkgJiZcXG4gICAgICAgICAgICAoIWZpbHRlciB8fCBmaWx0ZXIoc3Bhbi5tYXJrZXIpKSlcXG4gICAgICAgICAgeyBmb3VuZC5wdXNoKHNwYW4ubWFya2VyLnBhcmVudCB8fCBzcGFuLm1hcmtlcikgfVxcbiAgICAgIH0gfVxcbiAgICAgICsrbGluZU5vXFxuICAgIH0pXFxuICAgIHJldHVybiBmb3VuZFxcbiAgfSxcXG4gIGdldEFsbE1hcmtzOiBmdW5jdGlvbigpIHtcXG4gICAgdmFyIG1hcmtlcnMgPSBbXVxcbiAgICB0aGlzLml0ZXIoZnVuY3Rpb24gKGxpbmUpIHtcXG4gICAgICB2YXIgc3BzID0gbGluZS5tYXJrZWRTcGFuc1xcbiAgICAgIGlmIChzcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBzcHMubGVuZ3RoOyArK2kpXFxuICAgICAgICB7IGlmIChzcHNbaV0uZnJvbSAhPSBudWxsKSB7IG1hcmtlcnMucHVzaChzcHNbaV0ubWFya2VyKSB9IH0gfVxcbiAgICB9KVxcbiAgICByZXR1cm4gbWFya2Vyc1xcbiAgfSxcXG5cXG4gIHBvc0Zyb21JbmRleDogZnVuY3Rpb24ob2ZmKSB7XFxuICAgIHZhciBjaCwgbGluZU5vID0gdGhpcy5maXJzdCwgc2VwU2l6ZSA9IHRoaXMubGluZVNlcGFyYXRvcigpLmxlbmd0aFxcbiAgICB0aGlzLml0ZXIoZnVuY3Rpb24gKGxpbmUpIHtcXG4gICAgICB2YXIgc3ogPSBsaW5lLnRleHQubGVuZ3RoICsgc2VwU2l6ZVxcbiAgICAgIGlmIChzeiA+IG9mZikgeyBjaCA9IG9mZjsgcmV0dXJuIHRydWUgfVxcbiAgICAgIG9mZiAtPSBzelxcbiAgICAgICsrbGluZU5vXFxuICAgIH0pXFxuICAgIHJldHVybiBjbGlwUG9zKHRoaXMsIFBvcyhsaW5lTm8sIGNoKSlcXG4gIH0sXFxuICBpbmRleEZyb21Qb3M6IGZ1bmN0aW9uIChjb29yZHMpIHtcXG4gICAgY29vcmRzID0gY2xpcFBvcyh0aGlzLCBjb29yZHMpXFxuICAgIHZhciBpbmRleCA9IGNvb3Jkcy5jaFxcbiAgICBpZiAoY29vcmRzLmxpbmUgPCB0aGlzLmZpcnN0IHx8IGNvb3Jkcy5jaCA8IDApIHsgcmV0dXJuIDAgfVxcbiAgICB2YXIgc2VwU2l6ZSA9IHRoaXMubGluZVNlcGFyYXRvcigpLmxlbmd0aFxcbiAgICB0aGlzLml0ZXIodGhpcy5maXJzdCwgY29vcmRzLmxpbmUsIGZ1bmN0aW9uIChsaW5lKSB7IC8vIGl0ZXIgYWJvcnRzIHdoZW4gY2FsbGJhY2sgcmV0dXJucyBhIHRydXRoeSB2YWx1ZVxcbiAgICAgIGluZGV4ICs9IGxpbmUudGV4dC5sZW5ndGggKyBzZXBTaXplXFxuICAgIH0pXFxuICAgIHJldHVybiBpbmRleFxcbiAgfSxcXG5cXG4gIGNvcHk6IGZ1bmN0aW9uKGNvcHlIaXN0b3J5KSB7XFxuICAgIHZhciBkb2MgPSBuZXcgRG9jKGdldExpbmVzKHRoaXMsIHRoaXMuZmlyc3QsIHRoaXMuZmlyc3QgKyB0aGlzLnNpemUpLFxcbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1vZGVPcHRpb24sIHRoaXMuZmlyc3QsIHRoaXMubGluZVNlcClcXG4gICAgZG9jLnNjcm9sbFRvcCA9IHRoaXMuc2Nyb2xsVG9wOyBkb2Muc2Nyb2xsTGVmdCA9IHRoaXMuc2Nyb2xsTGVmdFxcbiAgICBkb2Muc2VsID0gdGhpcy5zZWxcXG4gICAgZG9jLmV4dGVuZCA9IGZhbHNlXFxuICAgIGlmIChjb3B5SGlzdG9yeSkge1xcbiAgICAgIGRvYy5oaXN0b3J5LnVuZG9EZXB0aCA9IHRoaXMuaGlzdG9yeS51bmRvRGVwdGhcXG4gICAgICBkb2Muc2V0SGlzdG9yeSh0aGlzLmdldEhpc3RvcnkoKSlcXG4gICAgfVxcbiAgICByZXR1cm4gZG9jXFxuICB9LFxcblxcbiAgbGlua2VkRG9jOiBmdW5jdGlvbihvcHRpb25zKSB7XFxuICAgIGlmICghb3B0aW9ucykgeyBvcHRpb25zID0ge30gfVxcbiAgICB2YXIgZnJvbSA9IHRoaXMuZmlyc3QsIHRvID0gdGhpcy5maXJzdCArIHRoaXMuc2l6ZVxcbiAgICBpZiAob3B0aW9ucy5mcm9tICE9IG51bGwgJiYgb3B0aW9ucy5mcm9tID4gZnJvbSkgeyBmcm9tID0gb3B0aW9ucy5mcm9tIH1cXG4gICAgaWYgKG9wdGlvbnMudG8gIT0gbnVsbCAmJiBvcHRpb25zLnRvIDwgdG8pIHsgdG8gPSBvcHRpb25zLnRvIH1cXG4gICAgdmFyIGNvcHkgPSBuZXcgRG9jKGdldExpbmVzKHRoaXMsIGZyb20sIHRvKSwgb3B0aW9ucy5tb2RlIHx8IHRoaXMubW9kZU9wdGlvbiwgZnJvbSwgdGhpcy5saW5lU2VwKVxcbiAgICBpZiAob3B0aW9ucy5zaGFyZWRIaXN0KSB7IGNvcHkuaGlzdG9yeSA9IHRoaXMuaGlzdG9yeVxcbiAgICA7IH0odGhpcy5saW5rZWQgfHwgKHRoaXMubGlua2VkID0gW10pKS5wdXNoKHtkb2M6IGNvcHksIHNoYXJlZEhpc3Q6IG9wdGlvbnMuc2hhcmVkSGlzdH0pXFxuICAgIGNvcHkubGlua2VkID0gW3tkb2M6IHRoaXMsIGlzUGFyZW50OiB0cnVlLCBzaGFyZWRIaXN0OiBvcHRpb25zLnNoYXJlZEhpc3R9XVxcbiAgICBjb3B5U2hhcmVkTWFya2Vycyhjb3B5LCBmaW5kU2hhcmVkTWFya2Vycyh0aGlzKSlcXG4gICAgcmV0dXJuIGNvcHlcXG4gIH0sXFxuICB1bmxpbmtEb2M6IGZ1bmN0aW9uKG90aGVyKSB7XFxuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xcblxcbiAgICBpZiAob3RoZXIgaW5zdGFuY2VvZiBDb2RlTWlycm9yKSB7IG90aGVyID0gb3RoZXIuZG9jIH1cXG4gICAgaWYgKHRoaXMubGlua2VkKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5saW5rZWQubGVuZ3RoOyArK2kpIHtcXG4gICAgICB2YXIgbGluayA9IHRoaXMkMS5saW5rZWRbaV1cXG4gICAgICBpZiAobGluay5kb2MgIT0gb3RoZXIpIHsgY29udGludWUgfVxcbiAgICAgIHRoaXMkMS5saW5rZWQuc3BsaWNlKGksIDEpXFxuICAgICAgb3RoZXIudW5saW5rRG9jKHRoaXMkMSlcXG4gICAgICBkZXRhY2hTaGFyZWRNYXJrZXJzKGZpbmRTaGFyZWRNYXJrZXJzKHRoaXMkMSkpXFxuICAgICAgYnJlYWtcXG4gICAgfSB9XFxuICAgIC8vIElmIHRoZSBoaXN0b3JpZXMgd2VyZSBzaGFyZWQsIHNwbGl0IHRoZW0gYWdhaW5cXG4gICAgaWYgKG90aGVyLmhpc3RvcnkgPT0gdGhpcy5oaXN0b3J5KSB7XFxuICAgICAgdmFyIHNwbGl0SWRzID0gW290aGVyLmlkXVxcbiAgICAgIGxpbmtlZERvY3Mob3RoZXIsIGZ1bmN0aW9uIChkb2MpIHsgcmV0dXJuIHNwbGl0SWRzLnB1c2goZG9jLmlkKTsgfSwgdHJ1ZSlcXG4gICAgICBvdGhlci5oaXN0b3J5ID0gbmV3IEhpc3RvcnkobnVsbClcXG4gICAgICBvdGhlci5oaXN0b3J5LmRvbmUgPSBjb3B5SGlzdG9yeUFycmF5KHRoaXMuaGlzdG9yeS5kb25lLCBzcGxpdElkcylcXG4gICAgICBvdGhlci5oaXN0b3J5LnVuZG9uZSA9IGNvcHlIaXN0b3J5QXJyYXkodGhpcy5oaXN0b3J5LnVuZG9uZSwgc3BsaXRJZHMpXFxuICAgIH1cXG4gIH0sXFxuICBpdGVyTGlua2VkRG9jczogZnVuY3Rpb24oZikge2xpbmtlZERvY3ModGhpcywgZil9LFxcblxcbiAgZ2V0TW9kZTogZnVuY3Rpb24oKSB7cmV0dXJuIHRoaXMubW9kZX0sXFxuICBnZXRFZGl0b3I6IGZ1bmN0aW9uKCkge3JldHVybiB0aGlzLmNtfSxcXG5cXG4gIHNwbGl0TGluZXM6IGZ1bmN0aW9uKHN0cikge1xcbiAgICBpZiAodGhpcy5saW5lU2VwKSB7IHJldHVybiBzdHIuc3BsaXQodGhpcy5saW5lU2VwKSB9XFxuICAgIHJldHVybiBzcGxpdExpbmVzQXV0byhzdHIpXFxuICB9LFxcbiAgbGluZVNlcGFyYXRvcjogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLmxpbmVTZXAgfHwgXFxcIlxcXFxuXFxcIiB9XFxufSlcXG5cXG4vLyBQdWJsaWMgYWxpYXMuXFxuRG9jLnByb3RvdHlwZS5lYWNoTGluZSA9IERvYy5wcm90b3R5cGUuaXRlclxcblxcbi8vIEtsdWRnZSB0byB3b3JrIGFyb3VuZCBzdHJhbmdlIElFIGJlaGF2aW9yIHdoZXJlIGl0J2xsIHNvbWV0aW1lc1xcbi8vIHJlLWZpcmUgYSBzZXJpZXMgb2YgZHJhZy1yZWxhdGVkIGV2ZW50cyByaWdodCBhZnRlciB0aGUgZHJvcCAoIzE1NTEpXFxudmFyIGxhc3REcm9wID0gMFxcblxcbmZ1bmN0aW9uIG9uRHJvcChlKSB7XFxuICB2YXIgY20gPSB0aGlzXFxuICBjbGVhckRyYWdDdXJzb3IoY20pXFxuICBpZiAoc2lnbmFsRE9NRXZlbnQoY20sIGUpIHx8IGV2ZW50SW5XaWRnZXQoY20uZGlzcGxheSwgZSkpXFxuICAgIHsgcmV0dXJuIH1cXG4gIGVfcHJldmVudERlZmF1bHQoZSlcXG4gIGlmIChpZSkgeyBsYXN0RHJvcCA9ICtuZXcgRGF0ZSB9XFxuICB2YXIgcG9zID0gcG9zRnJvbU1vdXNlKGNtLCBlLCB0cnVlKSwgZmlsZXMgPSBlLmRhdGFUcmFuc2Zlci5maWxlc1xcbiAgaWYgKCFwb3MgfHwgY20uaXNSZWFkT25seSgpKSB7IHJldHVybiB9XFxuICAvLyBNaWdodCBiZSBhIGZpbGUgZHJvcCwgaW4gd2hpY2ggY2FzZSB3ZSBzaW1wbHkgZXh0cmFjdCB0aGUgdGV4dFxcbiAgLy8gYW5kIGluc2VydCBpdC5cXG4gIGlmIChmaWxlcyAmJiBmaWxlcy5sZW5ndGggJiYgd2luZG93LkZpbGVSZWFkZXIgJiYgd2luZG93LkZpbGUpIHtcXG4gICAgdmFyIG4gPSBmaWxlcy5sZW5ndGgsIHRleHQgPSBBcnJheShuKSwgcmVhZCA9IDBcXG4gICAgdmFyIGxvYWRGaWxlID0gZnVuY3Rpb24gKGZpbGUsIGkpIHtcXG4gICAgICBpZiAoY20ub3B0aW9ucy5hbGxvd0Ryb3BGaWxlVHlwZXMgJiZcXG4gICAgICAgICAgaW5kZXhPZihjbS5vcHRpb25zLmFsbG93RHJvcEZpbGVUeXBlcywgZmlsZS50eXBlKSA9PSAtMSlcXG4gICAgICAgIHsgcmV0dXJuIH1cXG5cXG4gICAgICB2YXIgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXJcXG4gICAgICByZWFkZXIub25sb2FkID0gb3BlcmF0aW9uKGNtLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgICB2YXIgY29udGVudCA9IHJlYWRlci5yZXN1bHRcXG4gICAgICAgIGlmICgvW1xcXFx4MDAtXFxcXHgwOFxcXFx4MGUtXFxcXHgxZl17Mn0vLnRlc3QoY29udGVudCkpIHsgY29udGVudCA9IFxcXCJcXFwiIH1cXG4gICAgICAgIHRleHRbaV0gPSBjb250ZW50XFxuICAgICAgICBpZiAoKytyZWFkID09IG4pIHtcXG4gICAgICAgICAgcG9zID0gY2xpcFBvcyhjbS5kb2MsIHBvcylcXG4gICAgICAgICAgdmFyIGNoYW5nZSA9IHtmcm9tOiBwb3MsIHRvOiBwb3MsXFxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogY20uZG9jLnNwbGl0TGluZXModGV4dC5qb2luKGNtLmRvYy5saW5lU2VwYXJhdG9yKCkpKSxcXG4gICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW46IFxcXCJwYXN0ZVxcXCJ9XFxuICAgICAgICAgIG1ha2VDaGFuZ2UoY20uZG9jLCBjaGFuZ2UpXFxuICAgICAgICAgIHNldFNlbGVjdGlvblJlcGxhY2VIaXN0b3J5KGNtLmRvYywgc2ltcGxlU2VsZWN0aW9uKHBvcywgY2hhbmdlRW5kKGNoYW5nZSkpKVxcbiAgICAgICAgfVxcbiAgICAgIH0pXFxuICAgICAgcmVhZGVyLnJlYWRBc1RleHQoZmlsZSlcXG4gICAgfVxcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47ICsraSkgeyBsb2FkRmlsZShmaWxlc1tpXSwgaSkgfVxcbiAgfSBlbHNlIHsgLy8gTm9ybWFsIGRyb3BcXG4gICAgLy8gRG9uJ3QgZG8gYSByZXBsYWNlIGlmIHRoZSBkcm9wIGhhcHBlbmVkIGluc2lkZSBvZiB0aGUgc2VsZWN0ZWQgdGV4dC5cXG4gICAgaWYgKGNtLnN0YXRlLmRyYWdnaW5nVGV4dCAmJiBjbS5kb2Muc2VsLmNvbnRhaW5zKHBvcykgPiAtMSkge1xcbiAgICAgIGNtLnN0YXRlLmRyYWdnaW5nVGV4dChlKVxcbiAgICAgIC8vIEVuc3VyZSB0aGUgZWRpdG9yIGlzIHJlLWZvY3VzZWRcXG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNtLmRpc3BsYXkuaW5wdXQuZm9jdXMoKTsgfSwgMjApXFxuICAgICAgcmV0dXJuXFxuICAgIH1cXG4gICAgdHJ5IHtcXG4gICAgICB2YXIgdGV4dCQxID0gZS5kYXRhVHJhbnNmZXIuZ2V0RGF0YShcXFwiVGV4dFxcXCIpXFxuICAgICAgaWYgKHRleHQkMSkge1xcbiAgICAgICAgdmFyIHNlbGVjdGVkXFxuICAgICAgICBpZiAoY20uc3RhdGUuZHJhZ2dpbmdUZXh0ICYmICFjbS5zdGF0ZS5kcmFnZ2luZ1RleHQuY29weSlcXG4gICAgICAgICAgeyBzZWxlY3RlZCA9IGNtLmxpc3RTZWxlY3Rpb25zKCkgfVxcbiAgICAgICAgc2V0U2VsZWN0aW9uTm9VbmRvKGNtLmRvYywgc2ltcGxlU2VsZWN0aW9uKHBvcywgcG9zKSlcXG4gICAgICAgIGlmIChzZWxlY3RlZCkgeyBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBzZWxlY3RlZC5sZW5ndGg7ICsraSQxKVxcbiAgICAgICAgICB7IHJlcGxhY2VSYW5nZShjbS5kb2MsIFxcXCJcXFwiLCBzZWxlY3RlZFtpJDFdLmFuY2hvciwgc2VsZWN0ZWRbaSQxXS5oZWFkLCBcXFwiZHJhZ1xcXCIpIH0gfVxcbiAgICAgICAgY20ucmVwbGFjZVNlbGVjdGlvbih0ZXh0JDEsIFxcXCJhcm91bmRcXFwiLCBcXFwicGFzdGVcXFwiKVxcbiAgICAgICAgY20uZGlzcGxheS5pbnB1dC5mb2N1cygpXFxuICAgICAgfVxcbiAgICB9XFxuICAgIGNhdGNoKGUpe31cXG4gIH1cXG59XFxuXFxuZnVuY3Rpb24gb25EcmFnU3RhcnQoY20sIGUpIHtcXG4gIGlmIChpZSAmJiAoIWNtLnN0YXRlLmRyYWdnaW5nVGV4dCB8fCArbmV3IERhdGUgLSBsYXN0RHJvcCA8IDEwMCkpIHsgZV9zdG9wKGUpOyByZXR1cm4gfVxcbiAgaWYgKHNpZ25hbERPTUV2ZW50KGNtLCBlKSB8fCBldmVudEluV2lkZ2V0KGNtLmRpc3BsYXksIGUpKSB7IHJldHVybiB9XFxuXFxuICBlLmRhdGFUcmFuc2Zlci5zZXREYXRhKFxcXCJUZXh0XFxcIiwgY20uZ2V0U2VsZWN0aW9uKCkpXFxuICBlLmRhdGFUcmFuc2Zlci5lZmZlY3RBbGxvd2VkID0gXFxcImNvcHlNb3ZlXFxcIlxcblxcbiAgLy8gVXNlIGR1bW15IGltYWdlIGluc3RlYWQgb2YgZGVmYXVsdCBicm93c2VycyBpbWFnZS5cXG4gIC8vIFJlY2VudCBTYWZhcmkgKH42LjAuMikgaGF2ZSBhIHRlbmRlbmN5IHRvIHNlZ2ZhdWx0IHdoZW4gdGhpcyBoYXBwZW5zLCBzbyB3ZSBkb24ndCBkbyBpdCB0aGVyZS5cXG4gIGlmIChlLmRhdGFUcmFuc2Zlci5zZXREcmFnSW1hZ2UgJiYgIXNhZmFyaSkge1xcbiAgICB2YXIgaW1nID0gZWx0KFxcXCJpbWdcXFwiLCBudWxsLCBudWxsLCBcXFwicG9zaXRpb246IGZpeGVkOyBsZWZ0OiAwOyB0b3A6IDA7XFxcIilcXG4gICAgaW1nLnNyYyA9IFxcXCJkYXRhOmltYWdlL2dpZjtiYXNlNjQsUjBsR09EbGhBUUFCQUFBQUFDSDVCQUVLQUFFQUxBQUFBQUFCQUFFQUFBSUNUQUVBT3c9PVxcXCJcXG4gICAgaWYgKHByZXN0bykge1xcbiAgICAgIGltZy53aWR0aCA9IGltZy5oZWlnaHQgPSAxXFxuICAgICAgY20uZGlzcGxheS53cmFwcGVyLmFwcGVuZENoaWxkKGltZylcXG4gICAgICAvLyBGb3JjZSBhIHJlbGF5b3V0LCBvciBPcGVyYSB3b24ndCB1c2Ugb3VyIGltYWdlIGZvciBzb21lIG9ic2N1cmUgcmVhc29uXFxuICAgICAgaW1nLl90b3AgPSBpbWcub2Zmc2V0VG9wXFxuICAgIH1cXG4gICAgZS5kYXRhVHJhbnNmZXIuc2V0RHJhZ0ltYWdlKGltZywgMCwgMClcXG4gICAgaWYgKHByZXN0bykgeyBpbWcucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChpbWcpIH1cXG4gIH1cXG59XFxuXFxuZnVuY3Rpb24gb25EcmFnT3ZlcihjbSwgZSkge1xcbiAgdmFyIHBvcyA9IHBvc0Zyb21Nb3VzZShjbSwgZSlcXG4gIGlmICghcG9zKSB7IHJldHVybiB9XFxuICB2YXIgZnJhZyA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKVxcbiAgZHJhd1NlbGVjdGlvbkN1cnNvcihjbSwgcG9zLCBmcmFnKVxcbiAgaWYgKCFjbS5kaXNwbGF5LmRyYWdDdXJzb3IpIHtcXG4gICAgY20uZGlzcGxheS5kcmFnQ3Vyc29yID0gZWx0KFxcXCJkaXZcXFwiLCBudWxsLCBcXFwiQ29kZU1pcnJvci1jdXJzb3JzIENvZGVNaXJyb3ItZHJhZ2N1cnNvcnNcXFwiKVxcbiAgICBjbS5kaXNwbGF5LmxpbmVTcGFjZS5pbnNlcnRCZWZvcmUoY20uZGlzcGxheS5kcmFnQ3Vyc29yLCBjbS5kaXNwbGF5LmN1cnNvckRpdilcXG4gIH1cXG4gIHJlbW92ZUNoaWxkcmVuQW5kQWRkKGNtLmRpc3BsYXkuZHJhZ0N1cnNvciwgZnJhZylcXG59XFxuXFxuZnVuY3Rpb24gY2xlYXJEcmFnQ3Vyc29yKGNtKSB7XFxuICBpZiAoY20uZGlzcGxheS5kcmFnQ3Vyc29yKSB7XFxuICAgIGNtLmRpc3BsYXkubGluZVNwYWNlLnJlbW92ZUNoaWxkKGNtLmRpc3BsYXkuZHJhZ0N1cnNvcilcXG4gICAgY20uZGlzcGxheS5kcmFnQ3Vyc29yID0gbnVsbFxcbiAgfVxcbn1cXG5cXG4vLyBUaGVzZSBtdXN0IGJlIGhhbmRsZWQgY2FyZWZ1bGx5LCBiZWNhdXNlIG5haXZlbHkgcmVnaXN0ZXJpbmcgYVxcbi8vIGhhbmRsZXIgZm9yIGVhY2ggZWRpdG9yIHdpbGwgY2F1c2UgdGhlIGVkaXRvcnMgdG8gbmV2ZXIgYmVcXG4vLyBnYXJiYWdlIGNvbGxlY3RlZC5cXG5cXG5mdW5jdGlvbiBmb3JFYWNoQ29kZU1pcnJvcihmKSB7XFxuICBpZiAoIWRvY3VtZW50LmJvZHkuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSkgeyByZXR1cm4gfVxcbiAgdmFyIGJ5Q2xhc3MgPSBkb2N1bWVudC5ib2R5LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoXFxcIkNvZGVNaXJyb3JcXFwiKVxcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBieUNsYXNzLmxlbmd0aDsgaSsrKSB7XFxuICAgIHZhciBjbSA9IGJ5Q2xhc3NbaV0uQ29kZU1pcnJvclxcbiAgICBpZiAoY20pIHsgZihjbSkgfVxcbiAgfVxcbn1cXG5cXG52YXIgZ2xvYmFsc1JlZ2lzdGVyZWQgPSBmYWxzZVxcbmZ1bmN0aW9uIGVuc3VyZUdsb2JhbEhhbmRsZXJzKCkge1xcbiAgaWYgKGdsb2JhbHNSZWdpc3RlcmVkKSB7IHJldHVybiB9XFxuICByZWdpc3Rlckdsb2JhbEhhbmRsZXJzKClcXG4gIGdsb2JhbHNSZWdpc3RlcmVkID0gdHJ1ZVxcbn1cXG5mdW5jdGlvbiByZWdpc3Rlckdsb2JhbEhhbmRsZXJzKCkge1xcbiAgLy8gV2hlbiB0aGUgd2luZG93IHJlc2l6ZXMsIHdlIG5lZWQgdG8gcmVmcmVzaCBhY3RpdmUgZWRpdG9ycy5cXG4gIHZhciByZXNpemVUaW1lclxcbiAgb24od2luZG93LCBcXFwicmVzaXplXFxcIiwgZnVuY3Rpb24gKCkge1xcbiAgICBpZiAocmVzaXplVGltZXIgPT0gbnVsbCkgeyByZXNpemVUaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xcbiAgICAgIHJlc2l6ZVRpbWVyID0gbnVsbFxcbiAgICAgIGZvckVhY2hDb2RlTWlycm9yKG9uUmVzaXplKVxcbiAgICB9LCAxMDApIH1cXG4gIH0pXFxuICAvLyBXaGVuIHRoZSB3aW5kb3cgbG9zZXMgZm9jdXMsIHdlIHdhbnQgdG8gc2hvdyB0aGUgZWRpdG9yIGFzIGJsdXJyZWRcXG4gIG9uKHdpbmRvdywgXFxcImJsdXJcXFwiLCBmdW5jdGlvbiAoKSB7IHJldHVybiBmb3JFYWNoQ29kZU1pcnJvcihvbkJsdXIpOyB9KVxcbn1cXG4vLyBDYWxsZWQgd2hlbiB0aGUgd2luZG93IHJlc2l6ZXNcXG5mdW5jdGlvbiBvblJlc2l6ZShjbSkge1xcbiAgdmFyIGQgPSBjbS5kaXNwbGF5XFxuICBpZiAoZC5sYXN0V3JhcEhlaWdodCA9PSBkLndyYXBwZXIuY2xpZW50SGVpZ2h0ICYmIGQubGFzdFdyYXBXaWR0aCA9PSBkLndyYXBwZXIuY2xpZW50V2lkdGgpXFxuICAgIHsgcmV0dXJuIH1cXG4gIC8vIE1pZ2h0IGJlIGEgdGV4dCBzY2FsaW5nIG9wZXJhdGlvbiwgY2xlYXIgc2l6ZSBjYWNoZXMuXFxuICBkLmNhY2hlZENoYXJXaWR0aCA9IGQuY2FjaGVkVGV4dEhlaWdodCA9IGQuY2FjaGVkUGFkZGluZ0ggPSBudWxsXFxuICBkLnNjcm9sbGJhcnNDbGlwcGVkID0gZmFsc2VcXG4gIGNtLnNldFNpemUoKVxcbn1cXG5cXG52YXIga2V5TmFtZXMgPSB7XFxuICAzOiBcXFwiRW50ZXJcXFwiLCA4OiBcXFwiQmFja3NwYWNlXFxcIiwgOTogXFxcIlRhYlxcXCIsIDEzOiBcXFwiRW50ZXJcXFwiLCAxNjogXFxcIlNoaWZ0XFxcIiwgMTc6IFxcXCJDdHJsXFxcIiwgMTg6IFxcXCJBbHRcXFwiLFxcbiAgMTk6IFxcXCJQYXVzZVxcXCIsIDIwOiBcXFwiQ2Fwc0xvY2tcXFwiLCAyNzogXFxcIkVzY1xcXCIsIDMyOiBcXFwiU3BhY2VcXFwiLCAzMzogXFxcIlBhZ2VVcFxcXCIsIDM0OiBcXFwiUGFnZURvd25cXFwiLCAzNTogXFxcIkVuZFxcXCIsXFxuICAzNjogXFxcIkhvbWVcXFwiLCAzNzogXFxcIkxlZnRcXFwiLCAzODogXFxcIlVwXFxcIiwgMzk6IFxcXCJSaWdodFxcXCIsIDQwOiBcXFwiRG93blxcXCIsIDQ0OiBcXFwiUHJpbnRTY3JuXFxcIiwgNDU6IFxcXCJJbnNlcnRcXFwiLFxcbiAgNDY6IFxcXCJEZWxldGVcXFwiLCA1OTogXFxcIjtcXFwiLCA2MTogXFxcIj1cXFwiLCA5MTogXFxcIk1vZFxcXCIsIDkyOiBcXFwiTW9kXFxcIiwgOTM6IFxcXCJNb2RcXFwiLFxcbiAgMTA2OiBcXFwiKlxcXCIsIDEwNzogXFxcIj1cXFwiLCAxMDk6IFxcXCItXFxcIiwgMTEwOiBcXFwiLlxcXCIsIDExMTogXFxcIi9cXFwiLCAxMjc6IFxcXCJEZWxldGVcXFwiLFxcbiAgMTczOiBcXFwiLVxcXCIsIDE4NjogXFxcIjtcXFwiLCAxODc6IFxcXCI9XFxcIiwgMTg4OiBcXFwiLFxcXCIsIDE4OTogXFxcIi1cXFwiLCAxOTA6IFxcXCIuXFxcIiwgMTkxOiBcXFwiL1xcXCIsIDE5MjogXFxcImBcXFwiLCAyMTk6IFxcXCJbXFxcIiwgMjIwOiBcXFwiXFxcXFxcXFxcXFwiLFxcbiAgMjIxOiBcXFwiXVxcXCIsIDIyMjogXFxcIidcXFwiLCA2MzIzMjogXFxcIlVwXFxcIiwgNjMyMzM6IFxcXCJEb3duXFxcIiwgNjMyMzQ6IFxcXCJMZWZ0XFxcIiwgNjMyMzU6IFxcXCJSaWdodFxcXCIsIDYzMjcyOiBcXFwiRGVsZXRlXFxcIixcXG4gIDYzMjczOiBcXFwiSG9tZVxcXCIsIDYzMjc1OiBcXFwiRW5kXFxcIiwgNjMyNzY6IFxcXCJQYWdlVXBcXFwiLCA2MzI3NzogXFxcIlBhZ2VEb3duXFxcIiwgNjMzMDI6IFxcXCJJbnNlcnRcXFwiXFxufVxcblxcbi8vIE51bWJlciBrZXlzXFxuZm9yICh2YXIgaSA9IDA7IGkgPCAxMDsgaSsrKSB7IGtleU5hbWVzW2kgKyA0OF0gPSBrZXlOYW1lc1tpICsgOTZdID0gU3RyaW5nKGkpIH1cXG4vLyBBbHBoYWJldGljIGtleXNcXG5mb3IgKHZhciBpJDEgPSA2NTsgaSQxIDw9IDkwOyBpJDErKykgeyBrZXlOYW1lc1tpJDFdID0gU3RyaW5nLmZyb21DaGFyQ29kZShpJDEpIH1cXG4vLyBGdW5jdGlvbiBrZXlzXFxuZm9yICh2YXIgaSQyID0gMTsgaSQyIDw9IDEyOyBpJDIrKykgeyBrZXlOYW1lc1tpJDIgKyAxMTFdID0ga2V5TmFtZXNbaSQyICsgNjMyMzVdID0gXFxcIkZcXFwiICsgaSQyIH1cXG5cXG52YXIga2V5TWFwID0ge31cXG5cXG5rZXlNYXAuYmFzaWMgPSB7XFxuICBcXFwiTGVmdFxcXCI6IFxcXCJnb0NoYXJMZWZ0XFxcIiwgXFxcIlJpZ2h0XFxcIjogXFxcImdvQ2hhclJpZ2h0XFxcIiwgXFxcIlVwXFxcIjogXFxcImdvTGluZVVwXFxcIiwgXFxcIkRvd25cXFwiOiBcXFwiZ29MaW5lRG93blxcXCIsXFxuICBcXFwiRW5kXFxcIjogXFxcImdvTGluZUVuZFxcXCIsIFxcXCJIb21lXFxcIjogXFxcImdvTGluZVN0YXJ0U21hcnRcXFwiLCBcXFwiUGFnZVVwXFxcIjogXFxcImdvUGFnZVVwXFxcIiwgXFxcIlBhZ2VEb3duXFxcIjogXFxcImdvUGFnZURvd25cXFwiLFxcbiAgXFxcIkRlbGV0ZVxcXCI6IFxcXCJkZWxDaGFyQWZ0ZXJcXFwiLCBcXFwiQmFja3NwYWNlXFxcIjogXFxcImRlbENoYXJCZWZvcmVcXFwiLCBcXFwiU2hpZnQtQmFja3NwYWNlXFxcIjogXFxcImRlbENoYXJCZWZvcmVcXFwiLFxcbiAgXFxcIlRhYlxcXCI6IFxcXCJkZWZhdWx0VGFiXFxcIiwgXFxcIlNoaWZ0LVRhYlxcXCI6IFxcXCJpbmRlbnRBdXRvXFxcIixcXG4gIFxcXCJFbnRlclxcXCI6IFxcXCJuZXdsaW5lQW5kSW5kZW50XFxcIiwgXFxcIkluc2VydFxcXCI6IFxcXCJ0b2dnbGVPdmVyd3JpdGVcXFwiLFxcbiAgXFxcIkVzY1xcXCI6IFxcXCJzaW5nbGVTZWxlY3Rpb25cXFwiXFxufVxcbi8vIE5vdGUgdGhhdCB0aGUgc2F2ZSBhbmQgZmluZC1yZWxhdGVkIGNvbW1hbmRzIGFyZW4ndCBkZWZpbmVkIGJ5XFxuLy8gZGVmYXVsdC4gVXNlciBjb2RlIG9yIGFkZG9ucyBjYW4gZGVmaW5lIHRoZW0uIFVua25vd24gY29tbWFuZHNcXG4vLyBhcmUgc2ltcGx5IGlnbm9yZWQuXFxua2V5TWFwLnBjRGVmYXVsdCA9IHtcXG4gIFxcXCJDdHJsLUFcXFwiOiBcXFwic2VsZWN0QWxsXFxcIiwgXFxcIkN0cmwtRFxcXCI6IFxcXCJkZWxldGVMaW5lXFxcIiwgXFxcIkN0cmwtWlxcXCI6IFxcXCJ1bmRvXFxcIiwgXFxcIlNoaWZ0LUN0cmwtWlxcXCI6IFxcXCJyZWRvXFxcIiwgXFxcIkN0cmwtWVxcXCI6IFxcXCJyZWRvXFxcIixcXG4gIFxcXCJDdHJsLUhvbWVcXFwiOiBcXFwiZ29Eb2NTdGFydFxcXCIsIFxcXCJDdHJsLUVuZFxcXCI6IFxcXCJnb0RvY0VuZFxcXCIsIFxcXCJDdHJsLVVwXFxcIjogXFxcImdvTGluZVVwXFxcIiwgXFxcIkN0cmwtRG93blxcXCI6IFxcXCJnb0xpbmVEb3duXFxcIixcXG4gIFxcXCJDdHJsLUxlZnRcXFwiOiBcXFwiZ29Hcm91cExlZnRcXFwiLCBcXFwiQ3RybC1SaWdodFxcXCI6IFxcXCJnb0dyb3VwUmlnaHRcXFwiLCBcXFwiQWx0LUxlZnRcXFwiOiBcXFwiZ29MaW5lU3RhcnRcXFwiLCBcXFwiQWx0LVJpZ2h0XFxcIjogXFxcImdvTGluZUVuZFxcXCIsXFxuICBcXFwiQ3RybC1CYWNrc3BhY2VcXFwiOiBcXFwiZGVsR3JvdXBCZWZvcmVcXFwiLCBcXFwiQ3RybC1EZWxldGVcXFwiOiBcXFwiZGVsR3JvdXBBZnRlclxcXCIsIFxcXCJDdHJsLVNcXFwiOiBcXFwic2F2ZVxcXCIsIFxcXCJDdHJsLUZcXFwiOiBcXFwiZmluZFxcXCIsXFxuICBcXFwiQ3RybC1HXFxcIjogXFxcImZpbmROZXh0XFxcIiwgXFxcIlNoaWZ0LUN0cmwtR1xcXCI6IFxcXCJmaW5kUHJldlxcXCIsIFxcXCJTaGlmdC1DdHJsLUZcXFwiOiBcXFwicmVwbGFjZVxcXCIsIFxcXCJTaGlmdC1DdHJsLVJcXFwiOiBcXFwicmVwbGFjZUFsbFxcXCIsXFxuICBcXFwiQ3RybC1bXFxcIjogXFxcImluZGVudExlc3NcXFwiLCBcXFwiQ3RybC1dXFxcIjogXFxcImluZGVudE1vcmVcXFwiLFxcbiAgXFxcIkN0cmwtVVxcXCI6IFxcXCJ1bmRvU2VsZWN0aW9uXFxcIiwgXFxcIlNoaWZ0LUN0cmwtVVxcXCI6IFxcXCJyZWRvU2VsZWN0aW9uXFxcIiwgXFxcIkFsdC1VXFxcIjogXFxcInJlZG9TZWxlY3Rpb25cXFwiLFxcbiAgZmFsbHRocm91Z2g6IFxcXCJiYXNpY1xcXCJcXG59XFxuLy8gVmVyeSBiYXNpYyByZWFkbGluZS9lbWFjcy1zdHlsZSBiaW5kaW5ncywgd2hpY2ggYXJlIHN0YW5kYXJkIG9uIE1hYy5cXG5rZXlNYXAuZW1hY3N5ID0ge1xcbiAgXFxcIkN0cmwtRlxcXCI6IFxcXCJnb0NoYXJSaWdodFxcXCIsIFxcXCJDdHJsLUJcXFwiOiBcXFwiZ29DaGFyTGVmdFxcXCIsIFxcXCJDdHJsLVBcXFwiOiBcXFwiZ29MaW5lVXBcXFwiLCBcXFwiQ3RybC1OXFxcIjogXFxcImdvTGluZURvd25cXFwiLFxcbiAgXFxcIkFsdC1GXFxcIjogXFxcImdvV29yZFJpZ2h0XFxcIiwgXFxcIkFsdC1CXFxcIjogXFxcImdvV29yZExlZnRcXFwiLCBcXFwiQ3RybC1BXFxcIjogXFxcImdvTGluZVN0YXJ0XFxcIiwgXFxcIkN0cmwtRVxcXCI6IFxcXCJnb0xpbmVFbmRcXFwiLFxcbiAgXFxcIkN0cmwtVlxcXCI6IFxcXCJnb1BhZ2VEb3duXFxcIiwgXFxcIlNoaWZ0LUN0cmwtVlxcXCI6IFxcXCJnb1BhZ2VVcFxcXCIsIFxcXCJDdHJsLURcXFwiOiBcXFwiZGVsQ2hhckFmdGVyXFxcIiwgXFxcIkN0cmwtSFxcXCI6IFxcXCJkZWxDaGFyQmVmb3JlXFxcIixcXG4gIFxcXCJBbHQtRFxcXCI6IFxcXCJkZWxXb3JkQWZ0ZXJcXFwiLCBcXFwiQWx0LUJhY2tzcGFjZVxcXCI6IFxcXCJkZWxXb3JkQmVmb3JlXFxcIiwgXFxcIkN0cmwtS1xcXCI6IFxcXCJraWxsTGluZVxcXCIsIFxcXCJDdHJsLVRcXFwiOiBcXFwidHJhbnNwb3NlQ2hhcnNcXFwiLFxcbiAgXFxcIkN0cmwtT1xcXCI6IFxcXCJvcGVuTGluZVxcXCJcXG59XFxua2V5TWFwLm1hY0RlZmF1bHQgPSB7XFxuICBcXFwiQ21kLUFcXFwiOiBcXFwic2VsZWN0QWxsXFxcIiwgXFxcIkNtZC1EXFxcIjogXFxcImRlbGV0ZUxpbmVcXFwiLCBcXFwiQ21kLVpcXFwiOiBcXFwidW5kb1xcXCIsIFxcXCJTaGlmdC1DbWQtWlxcXCI6IFxcXCJyZWRvXFxcIiwgXFxcIkNtZC1ZXFxcIjogXFxcInJlZG9cXFwiLFxcbiAgXFxcIkNtZC1Ib21lXFxcIjogXFxcImdvRG9jU3RhcnRcXFwiLCBcXFwiQ21kLVVwXFxcIjogXFxcImdvRG9jU3RhcnRcXFwiLCBcXFwiQ21kLUVuZFxcXCI6IFxcXCJnb0RvY0VuZFxcXCIsIFxcXCJDbWQtRG93blxcXCI6IFxcXCJnb0RvY0VuZFxcXCIsIFxcXCJBbHQtTGVmdFxcXCI6IFxcXCJnb0dyb3VwTGVmdFxcXCIsXFxuICBcXFwiQWx0LVJpZ2h0XFxcIjogXFxcImdvR3JvdXBSaWdodFxcXCIsIFxcXCJDbWQtTGVmdFxcXCI6IFxcXCJnb0xpbmVMZWZ0XFxcIiwgXFxcIkNtZC1SaWdodFxcXCI6IFxcXCJnb0xpbmVSaWdodFxcXCIsIFxcXCJBbHQtQmFja3NwYWNlXFxcIjogXFxcImRlbEdyb3VwQmVmb3JlXFxcIixcXG4gIFxcXCJDdHJsLUFsdC1CYWNrc3BhY2VcXFwiOiBcXFwiZGVsR3JvdXBBZnRlclxcXCIsIFxcXCJBbHQtRGVsZXRlXFxcIjogXFxcImRlbEdyb3VwQWZ0ZXJcXFwiLCBcXFwiQ21kLVNcXFwiOiBcXFwic2F2ZVxcXCIsIFxcXCJDbWQtRlxcXCI6IFxcXCJmaW5kXFxcIixcXG4gIFxcXCJDbWQtR1xcXCI6IFxcXCJmaW5kTmV4dFxcXCIsIFxcXCJTaGlmdC1DbWQtR1xcXCI6IFxcXCJmaW5kUHJldlxcXCIsIFxcXCJDbWQtQWx0LUZcXFwiOiBcXFwicmVwbGFjZVxcXCIsIFxcXCJTaGlmdC1DbWQtQWx0LUZcXFwiOiBcXFwicmVwbGFjZUFsbFxcXCIsXFxuICBcXFwiQ21kLVtcXFwiOiBcXFwiaW5kZW50TGVzc1xcXCIsIFxcXCJDbWQtXVxcXCI6IFxcXCJpbmRlbnRNb3JlXFxcIiwgXFxcIkNtZC1CYWNrc3BhY2VcXFwiOiBcXFwiZGVsV3JhcHBlZExpbmVMZWZ0XFxcIiwgXFxcIkNtZC1EZWxldGVcXFwiOiBcXFwiZGVsV3JhcHBlZExpbmVSaWdodFxcXCIsXFxuICBcXFwiQ21kLVVcXFwiOiBcXFwidW5kb1NlbGVjdGlvblxcXCIsIFxcXCJTaGlmdC1DbWQtVVxcXCI6IFxcXCJyZWRvU2VsZWN0aW9uXFxcIiwgXFxcIkN0cmwtVXBcXFwiOiBcXFwiZ29Eb2NTdGFydFxcXCIsIFxcXCJDdHJsLURvd25cXFwiOiBcXFwiZ29Eb2NFbmRcXFwiLFxcbiAgZmFsbHRocm91Z2g6IFtcXFwiYmFzaWNcXFwiLCBcXFwiZW1hY3N5XFxcIl1cXG59XFxua2V5TWFwW1xcXCJkZWZhdWx0XFxcIl0gPSBtYWMgPyBrZXlNYXAubWFjRGVmYXVsdCA6IGtleU1hcC5wY0RlZmF1bHRcXG5cXG4vLyBLRVlNQVAgRElTUEFUQ0hcXG5cXG5mdW5jdGlvbiBub3JtYWxpemVLZXlOYW1lKG5hbWUpIHtcXG4gIHZhciBwYXJ0cyA9IG5hbWUuc3BsaXQoLy0oPyEkKS8pXFxuICBuYW1lID0gcGFydHNbcGFydHMubGVuZ3RoIC0gMV1cXG4gIHZhciBhbHQsIGN0cmwsIHNoaWZ0LCBjbWRcXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoIC0gMTsgaSsrKSB7XFxuICAgIHZhciBtb2QgPSBwYXJ0c1tpXVxcbiAgICBpZiAoL14oY21kfG1ldGF8bSkkL2kudGVzdChtb2QpKSB7IGNtZCA9IHRydWUgfVxcbiAgICBlbHNlIGlmICgvXmEobHQpPyQvaS50ZXN0KG1vZCkpIHsgYWx0ID0gdHJ1ZSB9XFxuICAgIGVsc2UgaWYgKC9eKGN8Y3RybHxjb250cm9sKSQvaS50ZXN0KG1vZCkpIHsgY3RybCA9IHRydWUgfVxcbiAgICBlbHNlIGlmICgvXnMoaGlmdCk/JC9pLnRlc3QobW9kKSkgeyBzaGlmdCA9IHRydWUgfVxcbiAgICBlbHNlIHsgdGhyb3cgbmV3IEVycm9yKFxcXCJVbnJlY29nbml6ZWQgbW9kaWZpZXIgbmFtZTogXFxcIiArIG1vZCkgfVxcbiAgfVxcbiAgaWYgKGFsdCkgeyBuYW1lID0gXFxcIkFsdC1cXFwiICsgbmFtZSB9XFxuICBpZiAoY3RybCkgeyBuYW1lID0gXFxcIkN0cmwtXFxcIiArIG5hbWUgfVxcbiAgaWYgKGNtZCkgeyBuYW1lID0gXFxcIkNtZC1cXFwiICsgbmFtZSB9XFxuICBpZiAoc2hpZnQpIHsgbmFtZSA9IFxcXCJTaGlmdC1cXFwiICsgbmFtZSB9XFxuICByZXR1cm4gbmFtZVxcbn1cXG5cXG4vLyBUaGlzIGlzIGEga2x1ZGdlIHRvIGtlZXAga2V5bWFwcyBtb3N0bHkgd29ya2luZyBhcyByYXcgb2JqZWN0c1xcbi8vIChiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSkgd2hpbGUgYXQgdGhlIHNhbWUgdGltZSBzdXBwb3J0IGZlYXR1cmVzXFxuLy8gbGlrZSBub3JtYWxpemF0aW9uIGFuZCBtdWx0aS1zdHJva2Uga2V5IGJpbmRpbmdzLiBJdCBjb21waWxlcyBhXFxuLy8gbmV3IG5vcm1hbGl6ZWQga2V5bWFwLCBhbmQgdGhlbiB1cGRhdGVzIHRoZSBvbGQgb2JqZWN0IHRvIHJlZmxlY3RcXG4vLyB0aGlzLlxcbmZ1bmN0aW9uIG5vcm1hbGl6ZUtleU1hcChrZXltYXApIHtcXG4gIHZhciBjb3B5ID0ge31cXG4gIGZvciAodmFyIGtleW5hbWUgaW4ga2V5bWFwKSB7IGlmIChrZXltYXAuaGFzT3duUHJvcGVydHkoa2V5bmFtZSkpIHtcXG4gICAgdmFyIHZhbHVlID0ga2V5bWFwW2tleW5hbWVdXFxuICAgIGlmICgvXihuYW1lfGZhbGx0aHJvdWdofChkZXxhdCl0YWNoKSQvLnRlc3Qoa2V5bmFtZSkpIHsgY29udGludWUgfVxcbiAgICBpZiAodmFsdWUgPT0gXFxcIi4uLlxcXCIpIHsgZGVsZXRlIGtleW1hcFtrZXluYW1lXTsgY29udGludWUgfVxcblxcbiAgICB2YXIga2V5cyA9IG1hcChrZXluYW1lLnNwbGl0KFxcXCIgXFxcIiksIG5vcm1hbGl6ZUtleU5hbWUpXFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xcbiAgICAgIHZhciB2YWwgPSAodm9pZCAwKSwgbmFtZSA9ICh2b2lkIDApXFxuICAgICAgaWYgKGkgPT0ga2V5cy5sZW5ndGggLSAxKSB7XFxuICAgICAgICBuYW1lID0ga2V5cy5qb2luKFxcXCIgXFxcIilcXG4gICAgICAgIHZhbCA9IHZhbHVlXFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIG5hbWUgPSBrZXlzLnNsaWNlKDAsIGkgKyAxKS5qb2luKFxcXCIgXFxcIilcXG4gICAgICAgIHZhbCA9IFxcXCIuLi5cXFwiXFxuICAgICAgfVxcbiAgICAgIHZhciBwcmV2ID0gY29weVtuYW1lXVxcbiAgICAgIGlmICghcHJldikgeyBjb3B5W25hbWVdID0gdmFsIH1cXG4gICAgICBlbHNlIGlmIChwcmV2ICE9IHZhbCkgeyB0aHJvdyBuZXcgRXJyb3IoXFxcIkluY29uc2lzdGVudCBiaW5kaW5ncyBmb3IgXFxcIiArIG5hbWUpIH1cXG4gICAgfVxcbiAgICBkZWxldGUga2V5bWFwW2tleW5hbWVdXFxuICB9IH1cXG4gIGZvciAodmFyIHByb3AgaW4gY29weSkgeyBrZXltYXBbcHJvcF0gPSBjb3B5W3Byb3BdIH1cXG4gIHJldHVybiBrZXltYXBcXG59XFxuXFxuZnVuY3Rpb24gbG9va3VwS2V5KGtleSwgbWFwLCBoYW5kbGUsIGNvbnRleHQpIHtcXG4gIG1hcCA9IGdldEtleU1hcChtYXApXFxuICB2YXIgZm91bmQgPSBtYXAuY2FsbCA/IG1hcC5jYWxsKGtleSwgY29udGV4dCkgOiBtYXBba2V5XVxcbiAgaWYgKGZvdW5kID09PSBmYWxzZSkgeyByZXR1cm4gXFxcIm5vdGhpbmdcXFwiIH1cXG4gIGlmIChmb3VuZCA9PT0gXFxcIi4uLlxcXCIpIHsgcmV0dXJuIFxcXCJtdWx0aVxcXCIgfVxcbiAgaWYgKGZvdW5kICE9IG51bGwgJiYgaGFuZGxlKGZvdW5kKSkgeyByZXR1cm4gXFxcImhhbmRsZWRcXFwiIH1cXG5cXG4gIGlmIChtYXAuZmFsbHRocm91Z2gpIHtcXG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChtYXAuZmFsbHRocm91Z2gpICE9IFxcXCJbb2JqZWN0IEFycmF5XVxcXCIpXFxuICAgICAgeyByZXR1cm4gbG9va3VwS2V5KGtleSwgbWFwLmZhbGx0aHJvdWdoLCBoYW5kbGUsIGNvbnRleHQpIH1cXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXAuZmFsbHRocm91Z2gubGVuZ3RoOyBpKyspIHtcXG4gICAgICB2YXIgcmVzdWx0ID0gbG9va3VwS2V5KGtleSwgbWFwLmZhbGx0aHJvdWdoW2ldLCBoYW5kbGUsIGNvbnRleHQpXFxuICAgICAgaWYgKHJlc3VsdCkgeyByZXR1cm4gcmVzdWx0IH1cXG4gICAgfVxcbiAgfVxcbn1cXG5cXG4vLyBNb2RpZmllciBrZXkgcHJlc3NlcyBkb24ndCBjb3VudCBhcyAncmVhbCcga2V5IHByZXNzZXMgZm9yIHRoZVxcbi8vIHB1cnBvc2Ugb2Yga2V5bWFwIGZhbGx0aHJvdWdoLlxcbmZ1bmN0aW9uIGlzTW9kaWZpZXJLZXkodmFsdWUpIHtcXG4gIHZhciBuYW1lID0gdHlwZW9mIHZhbHVlID09IFxcXCJzdHJpbmdcXFwiID8gdmFsdWUgOiBrZXlOYW1lc1t2YWx1ZS5rZXlDb2RlXVxcbiAgcmV0dXJuIG5hbWUgPT0gXFxcIkN0cmxcXFwiIHx8IG5hbWUgPT0gXFxcIkFsdFxcXCIgfHwgbmFtZSA9PSBcXFwiU2hpZnRcXFwiIHx8IG5hbWUgPT0gXFxcIk1vZFxcXCJcXG59XFxuXFxuLy8gTG9vayB1cCB0aGUgbmFtZSBvZiBhIGtleSBhcyBpbmRpY2F0ZWQgYnkgYW4gZXZlbnQgb2JqZWN0LlxcbmZ1bmN0aW9uIGtleU5hbWUoZXZlbnQsIG5vU2hpZnQpIHtcXG4gIGlmIChwcmVzdG8gJiYgZXZlbnQua2V5Q29kZSA9PSAzNCAmJiBldmVudFtcXFwiY2hhclxcXCJdKSB7IHJldHVybiBmYWxzZSB9XFxuICB2YXIgYmFzZSA9IGtleU5hbWVzW2V2ZW50LmtleUNvZGVdLCBuYW1lID0gYmFzZVxcbiAgaWYgKG5hbWUgPT0gbnVsbCB8fCBldmVudC5hbHRHcmFwaEtleSkgeyByZXR1cm4gZmFsc2UgfVxcbiAgaWYgKGV2ZW50LmFsdEtleSAmJiBiYXNlICE9IFxcXCJBbHRcXFwiKSB7IG5hbWUgPSBcXFwiQWx0LVxcXCIgKyBuYW1lIH1cXG4gIGlmICgoZmxpcEN0cmxDbWQgPyBldmVudC5tZXRhS2V5IDogZXZlbnQuY3RybEtleSkgJiYgYmFzZSAhPSBcXFwiQ3RybFxcXCIpIHsgbmFtZSA9IFxcXCJDdHJsLVxcXCIgKyBuYW1lIH1cXG4gIGlmICgoZmxpcEN0cmxDbWQgPyBldmVudC5jdHJsS2V5IDogZXZlbnQubWV0YUtleSkgJiYgYmFzZSAhPSBcXFwiQ21kXFxcIikgeyBuYW1lID0gXFxcIkNtZC1cXFwiICsgbmFtZSB9XFxuICBpZiAoIW5vU2hpZnQgJiYgZXZlbnQuc2hpZnRLZXkgJiYgYmFzZSAhPSBcXFwiU2hpZnRcXFwiKSB7IG5hbWUgPSBcXFwiU2hpZnQtXFxcIiArIG5hbWUgfVxcbiAgcmV0dXJuIG5hbWVcXG59XFxuXFxuZnVuY3Rpb24gZ2V0S2V5TWFwKHZhbCkge1xcbiAgcmV0dXJuIHR5cGVvZiB2YWwgPT0gXFxcInN0cmluZ1xcXCIgPyBrZXlNYXBbdmFsXSA6IHZhbFxcbn1cXG5cXG4vLyBIZWxwZXIgZm9yIGRlbGV0aW5nIHRleHQgbmVhciB0aGUgc2VsZWN0aW9uKHMpLCB1c2VkIHRvIGltcGxlbWVudFxcbi8vIGJhY2tzcGFjZSwgZGVsZXRlLCBhbmQgc2ltaWxhciBmdW5jdGlvbmFsaXR5LlxcbmZ1bmN0aW9uIGRlbGV0ZU5lYXJTZWxlY3Rpb24oY20sIGNvbXB1dGUpIHtcXG4gIHZhciByYW5nZXMgPSBjbS5kb2Muc2VsLnJhbmdlcywga2lsbCA9IFtdXFxuICAvLyBCdWlsZCB1cCBhIHNldCBvZiByYW5nZXMgdG8ga2lsbCBmaXJzdCwgbWVyZ2luZyBvdmVybGFwcGluZ1xcbiAgLy8gcmFuZ2VzLlxcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCByYW5nZXMubGVuZ3RoOyBpKyspIHtcXG4gICAgdmFyIHRvS2lsbCA9IGNvbXB1dGUocmFuZ2VzW2ldKVxcbiAgICB3aGlsZSAoa2lsbC5sZW5ndGggJiYgY21wKHRvS2lsbC5mcm9tLCBsc3Qoa2lsbCkudG8pIDw9IDApIHtcXG4gICAgICB2YXIgcmVwbGFjZWQgPSBraWxsLnBvcCgpXFxuICAgICAgaWYgKGNtcChyZXBsYWNlZC5mcm9tLCB0b0tpbGwuZnJvbSkgPCAwKSB7XFxuICAgICAgICB0b0tpbGwuZnJvbSA9IHJlcGxhY2VkLmZyb21cXG4gICAgICAgIGJyZWFrXFxuICAgICAgfVxcbiAgICB9XFxuICAgIGtpbGwucHVzaCh0b0tpbGwpXFxuICB9XFxuICAvLyBOZXh0LCByZW1vdmUgdGhvc2UgYWN0dWFsIHJhbmdlcy5cXG4gIHJ1bkluT3AoY20sIGZ1bmN0aW9uICgpIHtcXG4gICAgZm9yICh2YXIgaSA9IGtpbGwubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pXFxuICAgICAgeyByZXBsYWNlUmFuZ2UoY20uZG9jLCBcXFwiXFxcIiwga2lsbFtpXS5mcm9tLCBraWxsW2ldLnRvLCBcXFwiK2RlbGV0ZVxcXCIpIH1cXG4gICAgZW5zdXJlQ3Vyc29yVmlzaWJsZShjbSlcXG4gIH0pXFxufVxcblxcbi8vIENvbW1hbmRzIGFyZSBwYXJhbWV0ZXItbGVzcyBhY3Rpb25zIHRoYXQgY2FuIGJlIHBlcmZvcm1lZCBvbiBhblxcbi8vIGVkaXRvciwgbW9zdGx5IHVzZWQgZm9yIGtleWJpbmRpbmdzLlxcbnZhciBjb21tYW5kcyA9IHtcXG4gIHNlbGVjdEFsbDogc2VsZWN0QWxsLFxcbiAgc2luZ2xlU2VsZWN0aW9uOiBmdW5jdGlvbiAoY20pIHsgcmV0dXJuIGNtLnNldFNlbGVjdGlvbihjbS5nZXRDdXJzb3IoXFxcImFuY2hvclxcXCIpLCBjbS5nZXRDdXJzb3IoXFxcImhlYWRcXFwiKSwgc2VsX2RvbnRTY3JvbGwpOyB9LFxcbiAga2lsbExpbmU6IGZ1bmN0aW9uIChjbSkgeyByZXR1cm4gZGVsZXRlTmVhclNlbGVjdGlvbihjbSwgZnVuY3Rpb24gKHJhbmdlKSB7XFxuICAgIGlmIChyYW5nZS5lbXB0eSgpKSB7XFxuICAgICAgdmFyIGxlbiA9IGdldExpbmUoY20uZG9jLCByYW5nZS5oZWFkLmxpbmUpLnRleHQubGVuZ3RoXFxuICAgICAgaWYgKHJhbmdlLmhlYWQuY2ggPT0gbGVuICYmIHJhbmdlLmhlYWQubGluZSA8IGNtLmxhc3RMaW5lKCkpXFxuICAgICAgICB7IHJldHVybiB7ZnJvbTogcmFuZ2UuaGVhZCwgdG86IFBvcyhyYW5nZS5oZWFkLmxpbmUgKyAxLCAwKX0gfVxcbiAgICAgIGVsc2VcXG4gICAgICAgIHsgcmV0dXJuIHtmcm9tOiByYW5nZS5oZWFkLCB0bzogUG9zKHJhbmdlLmhlYWQubGluZSwgbGVuKX0gfVxcbiAgICB9IGVsc2Uge1xcbiAgICAgIHJldHVybiB7ZnJvbTogcmFuZ2UuZnJvbSgpLCB0bzogcmFuZ2UudG8oKX1cXG4gICAgfVxcbiAgfSk7IH0sXFxuICBkZWxldGVMaW5lOiBmdW5jdGlvbiAoY20pIHsgcmV0dXJuIGRlbGV0ZU5lYXJTZWxlY3Rpb24oY20sIGZ1bmN0aW9uIChyYW5nZSkgeyByZXR1cm4gKHtcXG4gICAgZnJvbTogUG9zKHJhbmdlLmZyb20oKS5saW5lLCAwKSxcXG4gICAgdG86IGNsaXBQb3MoY20uZG9jLCBQb3MocmFuZ2UudG8oKS5saW5lICsgMSwgMCkpXFxuICB9KTsgfSk7IH0sXFxuICBkZWxMaW5lTGVmdDogZnVuY3Rpb24gKGNtKSB7IHJldHVybiBkZWxldGVOZWFyU2VsZWN0aW9uKGNtLCBmdW5jdGlvbiAocmFuZ2UpIHsgcmV0dXJuICh7XFxuICAgIGZyb206IFBvcyhyYW5nZS5mcm9tKCkubGluZSwgMCksIHRvOiByYW5nZS5mcm9tKClcXG4gIH0pOyB9KTsgfSxcXG4gIGRlbFdyYXBwZWRMaW5lTGVmdDogZnVuY3Rpb24gKGNtKSB7IHJldHVybiBkZWxldGVOZWFyU2VsZWN0aW9uKGNtLCBmdW5jdGlvbiAocmFuZ2UpIHtcXG4gICAgdmFyIHRvcCA9IGNtLmNoYXJDb29yZHMocmFuZ2UuaGVhZCwgXFxcImRpdlxcXCIpLnRvcCArIDVcXG4gICAgdmFyIGxlZnRQb3MgPSBjbS5jb29yZHNDaGFyKHtsZWZ0OiAwLCB0b3A6IHRvcH0sIFxcXCJkaXZcXFwiKVxcbiAgICByZXR1cm4ge2Zyb206IGxlZnRQb3MsIHRvOiByYW5nZS5mcm9tKCl9XFxuICB9KTsgfSxcXG4gIGRlbFdyYXBwZWRMaW5lUmlnaHQ6IGZ1bmN0aW9uIChjbSkgeyByZXR1cm4gZGVsZXRlTmVhclNlbGVjdGlvbihjbSwgZnVuY3Rpb24gKHJhbmdlKSB7XFxuICAgIHZhciB0b3AgPSBjbS5jaGFyQ29vcmRzKHJhbmdlLmhlYWQsIFxcXCJkaXZcXFwiKS50b3AgKyA1XFxuICAgIHZhciByaWdodFBvcyA9IGNtLmNvb3Jkc0NoYXIoe2xlZnQ6IGNtLmRpc3BsYXkubGluZURpdi5vZmZzZXRXaWR0aCArIDEwMCwgdG9wOiB0b3B9LCBcXFwiZGl2XFxcIilcXG4gICAgcmV0dXJuIHtmcm9tOiByYW5nZS5mcm9tKCksIHRvOiByaWdodFBvcyB9XFxuICB9KTsgfSxcXG4gIHVuZG86IGZ1bmN0aW9uIChjbSkgeyByZXR1cm4gY20udW5kbygpOyB9LFxcbiAgcmVkbzogZnVuY3Rpb24gKGNtKSB7IHJldHVybiBjbS5yZWRvKCk7IH0sXFxuICB1bmRvU2VsZWN0aW9uOiBmdW5jdGlvbiAoY20pIHsgcmV0dXJuIGNtLnVuZG9TZWxlY3Rpb24oKTsgfSxcXG4gIHJlZG9TZWxlY3Rpb246IGZ1bmN0aW9uIChjbSkgeyByZXR1cm4gY20ucmVkb1NlbGVjdGlvbigpOyB9LFxcbiAgZ29Eb2NTdGFydDogZnVuY3Rpb24gKGNtKSB7IHJldHVybiBjbS5leHRlbmRTZWxlY3Rpb24oUG9zKGNtLmZpcnN0TGluZSgpLCAwKSk7IH0sXFxuICBnb0RvY0VuZDogZnVuY3Rpb24gKGNtKSB7IHJldHVybiBjbS5leHRlbmRTZWxlY3Rpb24oUG9zKGNtLmxhc3RMaW5lKCkpKTsgfSxcXG4gIGdvTGluZVN0YXJ0OiBmdW5jdGlvbiAoY20pIHsgcmV0dXJuIGNtLmV4dGVuZFNlbGVjdGlvbnNCeShmdW5jdGlvbiAocmFuZ2UpIHsgcmV0dXJuIGxpbmVTdGFydChjbSwgcmFuZ2UuaGVhZC5saW5lKTsgfSxcXG4gICAge29yaWdpbjogXFxcIittb3ZlXFxcIiwgYmlhczogMX1cXG4gICk7IH0sXFxuICBnb0xpbmVTdGFydFNtYXJ0OiBmdW5jdGlvbiAoY20pIHsgcmV0dXJuIGNtLmV4dGVuZFNlbGVjdGlvbnNCeShmdW5jdGlvbiAocmFuZ2UpIHsgcmV0dXJuIGxpbmVTdGFydFNtYXJ0KGNtLCByYW5nZS5oZWFkKTsgfSxcXG4gICAge29yaWdpbjogXFxcIittb3ZlXFxcIiwgYmlhczogMX1cXG4gICk7IH0sXFxuICBnb0xpbmVFbmQ6IGZ1bmN0aW9uIChjbSkgeyByZXR1cm4gY20uZXh0ZW5kU2VsZWN0aW9uc0J5KGZ1bmN0aW9uIChyYW5nZSkgeyByZXR1cm4gbGluZUVuZChjbSwgcmFuZ2UuaGVhZC5saW5lKTsgfSxcXG4gICAge29yaWdpbjogXFxcIittb3ZlXFxcIiwgYmlhczogLTF9XFxuICApOyB9LFxcbiAgZ29MaW5lUmlnaHQ6IGZ1bmN0aW9uIChjbSkgeyByZXR1cm4gY20uZXh0ZW5kU2VsZWN0aW9uc0J5KGZ1bmN0aW9uIChyYW5nZSkge1xcbiAgICB2YXIgdG9wID0gY20uY2hhckNvb3JkcyhyYW5nZS5oZWFkLCBcXFwiZGl2XFxcIikudG9wICsgNVxcbiAgICByZXR1cm4gY20uY29vcmRzQ2hhcih7bGVmdDogY20uZGlzcGxheS5saW5lRGl2Lm9mZnNldFdpZHRoICsgMTAwLCB0b3A6IHRvcH0sIFxcXCJkaXZcXFwiKVxcbiAgfSwgc2VsX21vdmUpOyB9LFxcbiAgZ29MaW5lTGVmdDogZnVuY3Rpb24gKGNtKSB7IHJldHVybiBjbS5leHRlbmRTZWxlY3Rpb25zQnkoZnVuY3Rpb24gKHJhbmdlKSB7XFxuICAgIHZhciB0b3AgPSBjbS5jaGFyQ29vcmRzKHJhbmdlLmhlYWQsIFxcXCJkaXZcXFwiKS50b3AgKyA1XFxuICAgIHJldHVybiBjbS5jb29yZHNDaGFyKHtsZWZ0OiAwLCB0b3A6IHRvcH0sIFxcXCJkaXZcXFwiKVxcbiAgfSwgc2VsX21vdmUpOyB9LFxcbiAgZ29MaW5lTGVmdFNtYXJ0OiBmdW5jdGlvbiAoY20pIHsgcmV0dXJuIGNtLmV4dGVuZFNlbGVjdGlvbnNCeShmdW5jdGlvbiAocmFuZ2UpIHtcXG4gICAgdmFyIHRvcCA9IGNtLmNoYXJDb29yZHMocmFuZ2UuaGVhZCwgXFxcImRpdlxcXCIpLnRvcCArIDVcXG4gICAgdmFyIHBvcyA9IGNtLmNvb3Jkc0NoYXIoe2xlZnQ6IDAsIHRvcDogdG9wfSwgXFxcImRpdlxcXCIpXFxuICAgIGlmIChwb3MuY2ggPCBjbS5nZXRMaW5lKHBvcy5saW5lKS5zZWFyY2goL1xcXFxTLykpIHsgcmV0dXJuIGxpbmVTdGFydFNtYXJ0KGNtLCByYW5nZS5oZWFkKSB9XFxuICAgIHJldHVybiBwb3NcXG4gIH0sIHNlbF9tb3ZlKTsgfSxcXG4gIGdvTGluZVVwOiBmdW5jdGlvbiAoY20pIHsgcmV0dXJuIGNtLm1vdmVWKC0xLCBcXFwibGluZVxcXCIpOyB9LFxcbiAgZ29MaW5lRG93bjogZnVuY3Rpb24gKGNtKSB7IHJldHVybiBjbS5tb3ZlVigxLCBcXFwibGluZVxcXCIpOyB9LFxcbiAgZ29QYWdlVXA6IGZ1bmN0aW9uIChjbSkgeyByZXR1cm4gY20ubW92ZVYoLTEsIFxcXCJwYWdlXFxcIik7IH0sXFxuICBnb1BhZ2VEb3duOiBmdW5jdGlvbiAoY20pIHsgcmV0dXJuIGNtLm1vdmVWKDEsIFxcXCJwYWdlXFxcIik7IH0sXFxuICBnb0NoYXJMZWZ0OiBmdW5jdGlvbiAoY20pIHsgcmV0dXJuIGNtLm1vdmVIKC0xLCBcXFwiY2hhclxcXCIpOyB9LFxcbiAgZ29DaGFyUmlnaHQ6IGZ1bmN0aW9uIChjbSkgeyByZXR1cm4gY20ubW92ZUgoMSwgXFxcImNoYXJcXFwiKTsgfSxcXG4gIGdvQ29sdW1uTGVmdDogZnVuY3Rpb24gKGNtKSB7IHJldHVybiBjbS5tb3ZlSCgtMSwgXFxcImNvbHVtblxcXCIpOyB9LFxcbiAgZ29Db2x1bW5SaWdodDogZnVuY3Rpb24gKGNtKSB7IHJldHVybiBjbS5tb3ZlSCgxLCBcXFwiY29sdW1uXFxcIik7IH0sXFxuICBnb1dvcmRMZWZ0OiBmdW5jdGlvbiAoY20pIHsgcmV0dXJuIGNtLm1vdmVIKC0xLCBcXFwid29yZFxcXCIpOyB9LFxcbiAgZ29Hcm91cFJpZ2h0OiBmdW5jdGlvbiAoY20pIHsgcmV0dXJuIGNtLm1vdmVIKDEsIFxcXCJncm91cFxcXCIpOyB9LFxcbiAgZ29Hcm91cExlZnQ6IGZ1bmN0aW9uIChjbSkgeyByZXR1cm4gY20ubW92ZUgoLTEsIFxcXCJncm91cFxcXCIpOyB9LFxcbiAgZ29Xb3JkUmlnaHQ6IGZ1bmN0aW9uIChjbSkgeyByZXR1cm4gY20ubW92ZUgoMSwgXFxcIndvcmRcXFwiKTsgfSxcXG4gIGRlbENoYXJCZWZvcmU6IGZ1bmN0aW9uIChjbSkgeyByZXR1cm4gY20uZGVsZXRlSCgtMSwgXFxcImNoYXJcXFwiKTsgfSxcXG4gIGRlbENoYXJBZnRlcjogZnVuY3Rpb24gKGNtKSB7IHJldHVybiBjbS5kZWxldGVIKDEsIFxcXCJjaGFyXFxcIik7IH0sXFxuICBkZWxXb3JkQmVmb3JlOiBmdW5jdGlvbiAoY20pIHsgcmV0dXJuIGNtLmRlbGV0ZUgoLTEsIFxcXCJ3b3JkXFxcIik7IH0sXFxuICBkZWxXb3JkQWZ0ZXI6IGZ1bmN0aW9uIChjbSkgeyByZXR1cm4gY20uZGVsZXRlSCgxLCBcXFwid29yZFxcXCIpOyB9LFxcbiAgZGVsR3JvdXBCZWZvcmU6IGZ1bmN0aW9uIChjbSkgeyByZXR1cm4gY20uZGVsZXRlSCgtMSwgXFxcImdyb3VwXFxcIik7IH0sXFxuICBkZWxHcm91cEFmdGVyOiBmdW5jdGlvbiAoY20pIHsgcmV0dXJuIGNtLmRlbGV0ZUgoMSwgXFxcImdyb3VwXFxcIik7IH0sXFxuICBpbmRlbnRBdXRvOiBmdW5jdGlvbiAoY20pIHsgcmV0dXJuIGNtLmluZGVudFNlbGVjdGlvbihcXFwic21hcnRcXFwiKTsgfSxcXG4gIGluZGVudE1vcmU6IGZ1bmN0aW9uIChjbSkgeyByZXR1cm4gY20uaW5kZW50U2VsZWN0aW9uKFxcXCJhZGRcXFwiKTsgfSxcXG4gIGluZGVudExlc3M6IGZ1bmN0aW9uIChjbSkgeyByZXR1cm4gY20uaW5kZW50U2VsZWN0aW9uKFxcXCJzdWJ0cmFjdFxcXCIpOyB9LFxcbiAgaW5zZXJ0VGFiOiBmdW5jdGlvbiAoY20pIHsgcmV0dXJuIGNtLnJlcGxhY2VTZWxlY3Rpb24oXFxcIlxcXFx0XFxcIik7IH0sXFxuICBpbnNlcnRTb2Z0VGFiOiBmdW5jdGlvbiAoY20pIHtcXG4gICAgdmFyIHNwYWNlcyA9IFtdLCByYW5nZXMgPSBjbS5saXN0U2VsZWN0aW9ucygpLCB0YWJTaXplID0gY20ub3B0aW9ucy50YWJTaXplXFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmFuZ2VzLmxlbmd0aDsgaSsrKSB7XFxuICAgICAgdmFyIHBvcyA9IHJhbmdlc1tpXS5mcm9tKClcXG4gICAgICB2YXIgY29sID0gY291bnRDb2x1bW4oY20uZ2V0TGluZShwb3MubGluZSksIHBvcy5jaCwgdGFiU2l6ZSlcXG4gICAgICBzcGFjZXMucHVzaChzcGFjZVN0cih0YWJTaXplIC0gY29sICUgdGFiU2l6ZSkpXFxuICAgIH1cXG4gICAgY20ucmVwbGFjZVNlbGVjdGlvbnMoc3BhY2VzKVxcbiAgfSxcXG4gIGRlZmF1bHRUYWI6IGZ1bmN0aW9uIChjbSkge1xcbiAgICBpZiAoY20uc29tZXRoaW5nU2VsZWN0ZWQoKSkgeyBjbS5pbmRlbnRTZWxlY3Rpb24oXFxcImFkZFxcXCIpIH1cXG4gICAgZWxzZSB7IGNtLmV4ZWNDb21tYW5kKFxcXCJpbnNlcnRUYWJcXFwiKSB9XFxuICB9LFxcbiAgLy8gU3dhcCB0aGUgdHdvIGNoYXJzIGxlZnQgYW5kIHJpZ2h0IG9mIGVhY2ggc2VsZWN0aW9uJ3MgaGVhZC5cXG4gIC8vIE1vdmUgY3Vyc29yIGJlaGluZCB0aGUgdHdvIHN3YXBwZWQgY2hhcmFjdGVycyBhZnRlcndhcmRzLlxcbiAgLy9cXG4gIC8vIERvZXNuJ3QgY29uc2lkZXIgbGluZSBmZWVkcyBhIGNoYXJhY3Rlci5cXG4gIC8vIERvZXNuJ3Qgc2NhbiBtb3JlIHRoYW4gb25lIGxpbmUgYWJvdmUgdG8gZmluZCBhIGNoYXJhY3Rlci5cXG4gIC8vIERvZXNuJ3QgZG8gYW55dGhpbmcgb24gYW4gZW1wdHkgbGluZS5cXG4gIC8vIERvZXNuJ3QgZG8gYW55dGhpbmcgd2l0aCBub24tZW1wdHkgc2VsZWN0aW9ucy5cXG4gIHRyYW5zcG9zZUNoYXJzOiBmdW5jdGlvbiAoY20pIHsgcmV0dXJuIHJ1bkluT3AoY20sIGZ1bmN0aW9uICgpIHtcXG4gICAgdmFyIHJhbmdlcyA9IGNtLmxpc3RTZWxlY3Rpb25zKCksIG5ld1NlbCA9IFtdXFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmFuZ2VzLmxlbmd0aDsgaSsrKSB7XFxuICAgICAgaWYgKCFyYW5nZXNbaV0uZW1wdHkoKSkgeyBjb250aW51ZSB9XFxuICAgICAgdmFyIGN1ciA9IHJhbmdlc1tpXS5oZWFkLCBsaW5lID0gZ2V0TGluZShjbS5kb2MsIGN1ci5saW5lKS50ZXh0XFxuICAgICAgaWYgKGxpbmUpIHtcXG4gICAgICAgIGlmIChjdXIuY2ggPT0gbGluZS5sZW5ndGgpIHsgY3VyID0gbmV3IFBvcyhjdXIubGluZSwgY3VyLmNoIC0gMSkgfVxcbiAgICAgICAgaWYgKGN1ci5jaCA+IDApIHtcXG4gICAgICAgICAgY3VyID0gbmV3IFBvcyhjdXIubGluZSwgY3VyLmNoICsgMSlcXG4gICAgICAgICAgY20ucmVwbGFjZVJhbmdlKGxpbmUuY2hhckF0KGN1ci5jaCAtIDEpICsgbGluZS5jaGFyQXQoY3VyLmNoIC0gMiksXFxuICAgICAgICAgICAgICAgICAgICAgICAgICBQb3MoY3VyLmxpbmUsIGN1ci5jaCAtIDIpLCBjdXIsIFxcXCIrdHJhbnNwb3NlXFxcIilcXG4gICAgICAgIH0gZWxzZSBpZiAoY3VyLmxpbmUgPiBjbS5kb2MuZmlyc3QpIHtcXG4gICAgICAgICAgdmFyIHByZXYgPSBnZXRMaW5lKGNtLmRvYywgY3VyLmxpbmUgLSAxKS50ZXh0XFxuICAgICAgICAgIGlmIChwcmV2KSB7XFxuICAgICAgICAgICAgY3VyID0gbmV3IFBvcyhjdXIubGluZSwgMSlcXG4gICAgICAgICAgICBjbS5yZXBsYWNlUmFuZ2UobGluZS5jaGFyQXQoMCkgKyBjbS5kb2MubGluZVNlcGFyYXRvcigpICtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJldi5jaGFyQXQocHJldi5sZW5ndGggLSAxKSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgUG9zKGN1ci5saW5lIC0gMSwgcHJldi5sZW5ndGggLSAxKSwgY3VyLCBcXFwiK3RyYW5zcG9zZVxcXCIpXFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgICAgbmV3U2VsLnB1c2gobmV3IFJhbmdlKGN1ciwgY3VyKSlcXG4gICAgfVxcbiAgICBjbS5zZXRTZWxlY3Rpb25zKG5ld1NlbClcXG4gIH0pOyB9LFxcbiAgbmV3bGluZUFuZEluZGVudDogZnVuY3Rpb24gKGNtKSB7IHJldHVybiBydW5Jbk9wKGNtLCBmdW5jdGlvbiAoKSB7XFxuICAgIHZhciBzZWxzID0gY20ubGlzdFNlbGVjdGlvbnMoKVxcbiAgICBmb3IgKHZhciBpID0gc2Vscy5sZW5ndGggLSAxOyBpID49IDA7IGktLSlcXG4gICAgICB7IGNtLnJlcGxhY2VSYW5nZShjbS5kb2MubGluZVNlcGFyYXRvcigpLCBzZWxzW2ldLmFuY2hvciwgc2Vsc1tpXS5oZWFkLCBcXFwiK2lucHV0XFxcIikgfVxcbiAgICBzZWxzID0gY20ubGlzdFNlbGVjdGlvbnMoKVxcbiAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBzZWxzLmxlbmd0aDsgaSQxKyspXFxuICAgICAgeyBjbS5pbmRlbnRMaW5lKHNlbHNbaSQxXS5mcm9tKCkubGluZSwgbnVsbCwgdHJ1ZSkgfVxcbiAgICBlbnN1cmVDdXJzb3JWaXNpYmxlKGNtKVxcbiAgfSk7IH0sXFxuICBvcGVuTGluZTogZnVuY3Rpb24gKGNtKSB7IHJldHVybiBjbS5yZXBsYWNlU2VsZWN0aW9uKFxcXCJcXFxcblxcXCIsIFxcXCJzdGFydFxcXCIpOyB9LFxcbiAgdG9nZ2xlT3ZlcndyaXRlOiBmdW5jdGlvbiAoY20pIHsgcmV0dXJuIGNtLnRvZ2dsZU92ZXJ3cml0ZSgpOyB9XFxufVxcblxcblxcbmZ1bmN0aW9uIGxpbmVTdGFydChjbSwgbGluZU4pIHtcXG4gIHZhciBsaW5lID0gZ2V0TGluZShjbS5kb2MsIGxpbmVOKVxcbiAgdmFyIHZpc3VhbCA9IHZpc3VhbExpbmUobGluZSlcXG4gIGlmICh2aXN1YWwgIT0gbGluZSkgeyBsaW5lTiA9IGxpbmVObyh2aXN1YWwpIH1cXG4gIHJldHVybiBlbmRPZkxpbmUodHJ1ZSwgY20sIHZpc3VhbCwgbGluZU4sIDEpXFxufVxcbmZ1bmN0aW9uIGxpbmVFbmQoY20sIGxpbmVOKSB7XFxuICB2YXIgbGluZSA9IGdldExpbmUoY20uZG9jLCBsaW5lTilcXG4gIHZhciB2aXN1YWwgPSB2aXN1YWxMaW5lRW5kKGxpbmUpXFxuICBpZiAodmlzdWFsICE9IGxpbmUpIHsgbGluZU4gPSBsaW5lTm8odmlzdWFsKSB9XFxuICByZXR1cm4gZW5kT2ZMaW5lKHRydWUsIGNtLCBsaW5lLCBsaW5lTiwgLTEpXFxufVxcbmZ1bmN0aW9uIGxpbmVTdGFydFNtYXJ0KGNtLCBwb3MpIHtcXG4gIHZhciBzdGFydCA9IGxpbmVTdGFydChjbSwgcG9zLmxpbmUpXFxuICB2YXIgbGluZSA9IGdldExpbmUoY20uZG9jLCBzdGFydC5saW5lKVxcbiAgdmFyIG9yZGVyID0gZ2V0T3JkZXIobGluZSlcXG4gIGlmICghb3JkZXIgfHwgb3JkZXJbMF0ubGV2ZWwgPT0gMCkge1xcbiAgICB2YXIgZmlyc3ROb25XUyA9IE1hdGgubWF4KDAsIGxpbmUudGV4dC5zZWFyY2goL1xcXFxTLykpXFxuICAgIHZhciBpbldTID0gcG9zLmxpbmUgPT0gc3RhcnQubGluZSAmJiBwb3MuY2ggPD0gZmlyc3ROb25XUyAmJiBwb3MuY2hcXG4gICAgcmV0dXJuIFBvcyhzdGFydC5saW5lLCBpbldTID8gMCA6IGZpcnN0Tm9uV1MsIHN0YXJ0LnN0aWNreSlcXG4gIH1cXG4gIHJldHVybiBzdGFydFxcbn1cXG5cXG4vLyBSdW4gYSBoYW5kbGVyIHRoYXQgd2FzIGJvdW5kIHRvIGEga2V5LlxcbmZ1bmN0aW9uIGRvSGFuZGxlQmluZGluZyhjbSwgYm91bmQsIGRyb3BTaGlmdCkge1xcbiAgaWYgKHR5cGVvZiBib3VuZCA9PSBcXFwic3RyaW5nXFxcIikge1xcbiAgICBib3VuZCA9IGNvbW1hbmRzW2JvdW5kXVxcbiAgICBpZiAoIWJvdW5kKSB7IHJldHVybiBmYWxzZSB9XFxuICB9XFxuICAvLyBFbnN1cmUgcHJldmlvdXMgaW5wdXQgaGFzIGJlZW4gcmVhZCwgc28gdGhhdCB0aGUgaGFuZGxlciBzZWVzIGFcXG4gIC8vIGNvbnNpc3RlbnQgdmlldyBvZiB0aGUgZG9jdW1lbnRcXG4gIGNtLmRpc3BsYXkuaW5wdXQuZW5zdXJlUG9sbGVkKClcXG4gIHZhciBwcmV2U2hpZnQgPSBjbS5kaXNwbGF5LnNoaWZ0LCBkb25lID0gZmFsc2VcXG4gIHRyeSB7XFxuICAgIGlmIChjbS5pc1JlYWRPbmx5KCkpIHsgY20uc3RhdGUuc3VwcHJlc3NFZGl0cyA9IHRydWUgfVxcbiAgICBpZiAoZHJvcFNoaWZ0KSB7IGNtLmRpc3BsYXkuc2hpZnQgPSBmYWxzZSB9XFxuICAgIGRvbmUgPSBib3VuZChjbSkgIT0gUGFzc1xcbiAgfSBmaW5hbGx5IHtcXG4gICAgY20uZGlzcGxheS5zaGlmdCA9IHByZXZTaGlmdFxcbiAgICBjbS5zdGF0ZS5zdXBwcmVzc0VkaXRzID0gZmFsc2VcXG4gIH1cXG4gIHJldHVybiBkb25lXFxufVxcblxcbmZ1bmN0aW9uIGxvb2t1cEtleUZvckVkaXRvcihjbSwgbmFtZSwgaGFuZGxlKSB7XFxuICBmb3IgKHZhciBpID0gMDsgaSA8IGNtLnN0YXRlLmtleU1hcHMubGVuZ3RoOyBpKyspIHtcXG4gICAgdmFyIHJlc3VsdCA9IGxvb2t1cEtleShuYW1lLCBjbS5zdGF0ZS5rZXlNYXBzW2ldLCBoYW5kbGUsIGNtKVxcbiAgICBpZiAocmVzdWx0KSB7IHJldHVybiByZXN1bHQgfVxcbiAgfVxcbiAgcmV0dXJuIChjbS5vcHRpb25zLmV4dHJhS2V5cyAmJiBsb29rdXBLZXkobmFtZSwgY20ub3B0aW9ucy5leHRyYUtleXMsIGhhbmRsZSwgY20pKVxcbiAgICB8fCBsb29rdXBLZXkobmFtZSwgY20ub3B0aW9ucy5rZXlNYXAsIGhhbmRsZSwgY20pXFxufVxcblxcbnZhciBzdG9wU2VxID0gbmV3IERlbGF5ZWRcXG5mdW5jdGlvbiBkaXNwYXRjaEtleShjbSwgbmFtZSwgZSwgaGFuZGxlKSB7XFxuICB2YXIgc2VxID0gY20uc3RhdGUua2V5U2VxXFxuICBpZiAoc2VxKSB7XFxuICAgIGlmIChpc01vZGlmaWVyS2V5KG5hbWUpKSB7IHJldHVybiBcXFwiaGFuZGxlZFxcXCIgfVxcbiAgICBzdG9wU2VxLnNldCg1MCwgZnVuY3Rpb24gKCkge1xcbiAgICAgIGlmIChjbS5zdGF0ZS5rZXlTZXEgPT0gc2VxKSB7XFxuICAgICAgICBjbS5zdGF0ZS5rZXlTZXEgPSBudWxsXFxuICAgICAgICBjbS5kaXNwbGF5LmlucHV0LnJlc2V0KClcXG4gICAgICB9XFxuICAgIH0pXFxuICAgIG5hbWUgPSBzZXEgKyBcXFwiIFxcXCIgKyBuYW1lXFxuICB9XFxuICB2YXIgcmVzdWx0ID0gbG9va3VwS2V5Rm9yRWRpdG9yKGNtLCBuYW1lLCBoYW5kbGUpXFxuXFxuICBpZiAocmVzdWx0ID09IFxcXCJtdWx0aVxcXCIpXFxuICAgIHsgY20uc3RhdGUua2V5U2VxID0gbmFtZSB9XFxuICBpZiAocmVzdWx0ID09IFxcXCJoYW5kbGVkXFxcIilcXG4gICAgeyBzaWduYWxMYXRlcihjbSwgXFxcImtleUhhbmRsZWRcXFwiLCBjbSwgbmFtZSwgZSkgfVxcblxcbiAgaWYgKHJlc3VsdCA9PSBcXFwiaGFuZGxlZFxcXCIgfHwgcmVzdWx0ID09IFxcXCJtdWx0aVxcXCIpIHtcXG4gICAgZV9wcmV2ZW50RGVmYXVsdChlKVxcbiAgICByZXN0YXJ0QmxpbmsoY20pXFxuICB9XFxuXFxuICBpZiAoc2VxICYmICFyZXN1bHQgJiYgL1xcXFwnJC8udGVzdChuYW1lKSkge1xcbiAgICBlX3ByZXZlbnREZWZhdWx0KGUpXFxuICAgIHJldHVybiB0cnVlXFxuICB9XFxuICByZXR1cm4gISFyZXN1bHRcXG59XFxuXFxuLy8gSGFuZGxlIGEga2V5IGZyb20gdGhlIGtleWRvd24gZXZlbnQuXFxuZnVuY3Rpb24gaGFuZGxlS2V5QmluZGluZyhjbSwgZSkge1xcbiAgdmFyIG5hbWUgPSBrZXlOYW1lKGUsIHRydWUpXFxuICBpZiAoIW5hbWUpIHsgcmV0dXJuIGZhbHNlIH1cXG5cXG4gIGlmIChlLnNoaWZ0S2V5ICYmICFjbS5zdGF0ZS5rZXlTZXEpIHtcXG4gICAgLy8gRmlyc3QgdHJ5IHRvIHJlc29sdmUgZnVsbCBuYW1lIChpbmNsdWRpbmcgJ1NoaWZ0LScpLiBGYWlsaW5nXFxuICAgIC8vIHRoYXQsIHNlZSBpZiB0aGVyZSBpcyBhIGN1cnNvci1tb3Rpb24gY29tbWFuZCAoc3RhcnRpbmcgd2l0aFxcbiAgICAvLyAnZ28nKSBib3VuZCB0byB0aGUga2V5bmFtZSB3aXRob3V0ICdTaGlmdC0nLlxcbiAgICByZXR1cm4gZGlzcGF0Y2hLZXkoY20sIFxcXCJTaGlmdC1cXFwiICsgbmFtZSwgZSwgZnVuY3Rpb24gKGIpIHsgcmV0dXJuIGRvSGFuZGxlQmluZGluZyhjbSwgYiwgdHJ1ZSk7IH0pXFxuICAgICAgICB8fCBkaXNwYXRjaEtleShjbSwgbmFtZSwgZSwgZnVuY3Rpb24gKGIpIHtcXG4gICAgICAgICAgICAgaWYgKHR5cGVvZiBiID09IFxcXCJzdHJpbmdcXFwiID8gL15nb1tBLVpdLy50ZXN0KGIpIDogYi5tb3Rpb24pXFxuICAgICAgICAgICAgICAgeyByZXR1cm4gZG9IYW5kbGVCaW5kaW5nKGNtLCBiKSB9XFxuICAgICAgICAgICB9KVxcbiAgfSBlbHNlIHtcXG4gICAgcmV0dXJuIGRpc3BhdGNoS2V5KGNtLCBuYW1lLCBlLCBmdW5jdGlvbiAoYikgeyByZXR1cm4gZG9IYW5kbGVCaW5kaW5nKGNtLCBiKTsgfSlcXG4gIH1cXG59XFxuXFxuLy8gSGFuZGxlIGEga2V5IGZyb20gdGhlIGtleXByZXNzIGV2ZW50XFxuZnVuY3Rpb24gaGFuZGxlQ2hhckJpbmRpbmcoY20sIGUsIGNoKSB7XFxuICByZXR1cm4gZGlzcGF0Y2hLZXkoY20sIFxcXCInXFxcIiArIGNoICsgXFxcIidcXFwiLCBlLCBmdW5jdGlvbiAoYikgeyByZXR1cm4gZG9IYW5kbGVCaW5kaW5nKGNtLCBiLCB0cnVlKTsgfSlcXG59XFxuXFxudmFyIGxhc3RTdG9wcGVkS2V5ID0gbnVsbFxcbmZ1bmN0aW9uIG9uS2V5RG93bihlKSB7XFxuICB2YXIgY20gPSB0aGlzXFxuICBjbS5jdXJPcC5mb2N1cyA9IGFjdGl2ZUVsdCgpXFxuICBpZiAoc2lnbmFsRE9NRXZlbnQoY20sIGUpKSB7IHJldHVybiB9XFxuICAvLyBJRSBkb2VzIHN0cmFuZ2UgdGhpbmdzIHdpdGggZXNjYXBlLlxcbiAgaWYgKGllICYmIGllX3ZlcnNpb24gPCAxMSAmJiBlLmtleUNvZGUgPT0gMjcpIHsgZS5yZXR1cm5WYWx1ZSA9IGZhbHNlIH1cXG4gIHZhciBjb2RlID0gZS5rZXlDb2RlXFxuICBjbS5kaXNwbGF5LnNoaWZ0ID0gY29kZSA9PSAxNiB8fCBlLnNoaWZ0S2V5XFxuICB2YXIgaGFuZGxlZCA9IGhhbmRsZUtleUJpbmRpbmcoY20sIGUpXFxuICBpZiAocHJlc3RvKSB7XFxuICAgIGxhc3RTdG9wcGVkS2V5ID0gaGFuZGxlZCA/IGNvZGUgOiBudWxsXFxuICAgIC8vIE9wZXJhIGhhcyBubyBjdXQgZXZlbnQuLi4gd2UgdHJ5IHRvIGF0IGxlYXN0IGNhdGNoIHRoZSBrZXkgY29tYm9cXG4gICAgaWYgKCFoYW5kbGVkICYmIGNvZGUgPT0gODggJiYgIWhhc0NvcHlFdmVudCAmJiAobWFjID8gZS5tZXRhS2V5IDogZS5jdHJsS2V5KSlcXG4gICAgICB7IGNtLnJlcGxhY2VTZWxlY3Rpb24oXFxcIlxcXCIsIG51bGwsIFxcXCJjdXRcXFwiKSB9XFxuICB9XFxuXFxuICAvLyBUdXJuIG1vdXNlIGludG8gY3Jvc3NoYWlyIHdoZW4gQWx0IGlzIGhlbGQgb24gTWFjLlxcbiAgaWYgKGNvZGUgPT0gMTggJiYgIS9cXFxcYkNvZGVNaXJyb3ItY3Jvc3NoYWlyXFxcXGIvLnRlc3QoY20uZGlzcGxheS5saW5lRGl2LmNsYXNzTmFtZSkpXFxuICAgIHsgc2hvd0Nyb3NzSGFpcihjbSkgfVxcbn1cXG5cXG5mdW5jdGlvbiBzaG93Q3Jvc3NIYWlyKGNtKSB7XFxuICB2YXIgbGluZURpdiA9IGNtLmRpc3BsYXkubGluZURpdlxcbiAgYWRkQ2xhc3MobGluZURpdiwgXFxcIkNvZGVNaXJyb3ItY3Jvc3NoYWlyXFxcIilcXG5cXG4gIGZ1bmN0aW9uIHVwKGUpIHtcXG4gICAgaWYgKGUua2V5Q29kZSA9PSAxOCB8fCAhZS5hbHRLZXkpIHtcXG4gICAgICBybUNsYXNzKGxpbmVEaXYsIFxcXCJDb2RlTWlycm9yLWNyb3NzaGFpclxcXCIpXFxuICAgICAgb2ZmKGRvY3VtZW50LCBcXFwia2V5dXBcXFwiLCB1cClcXG4gICAgICBvZmYoZG9jdW1lbnQsIFxcXCJtb3VzZW92ZXJcXFwiLCB1cClcXG4gICAgfVxcbiAgfVxcbiAgb24oZG9jdW1lbnQsIFxcXCJrZXl1cFxcXCIsIHVwKVxcbiAgb24oZG9jdW1lbnQsIFxcXCJtb3VzZW92ZXJcXFwiLCB1cClcXG59XFxuXFxuZnVuY3Rpb24gb25LZXlVcChlKSB7XFxuICBpZiAoZS5rZXlDb2RlID09IDE2KSB7IHRoaXMuZG9jLnNlbC5zaGlmdCA9IGZhbHNlIH1cXG4gIHNpZ25hbERPTUV2ZW50KHRoaXMsIGUpXFxufVxcblxcbmZ1bmN0aW9uIG9uS2V5UHJlc3MoZSkge1xcbiAgdmFyIGNtID0gdGhpc1xcbiAgaWYgKGV2ZW50SW5XaWRnZXQoY20uZGlzcGxheSwgZSkgfHwgc2lnbmFsRE9NRXZlbnQoY20sIGUpIHx8IGUuY3RybEtleSAmJiAhZS5hbHRLZXkgfHwgbWFjICYmIGUubWV0YUtleSkgeyByZXR1cm4gfVxcbiAgdmFyIGtleUNvZGUgPSBlLmtleUNvZGUsIGNoYXJDb2RlID0gZS5jaGFyQ29kZVxcbiAgaWYgKHByZXN0byAmJiBrZXlDb2RlID09IGxhc3RTdG9wcGVkS2V5KSB7bGFzdFN0b3BwZWRLZXkgPSBudWxsOyBlX3ByZXZlbnREZWZhdWx0KGUpOyByZXR1cm59XFxuICBpZiAoKHByZXN0byAmJiAoIWUud2hpY2ggfHwgZS53aGljaCA8IDEwKSkgJiYgaGFuZGxlS2V5QmluZGluZyhjbSwgZSkpIHsgcmV0dXJuIH1cXG4gIHZhciBjaCA9IFN0cmluZy5mcm9tQ2hhckNvZGUoY2hhckNvZGUgPT0gbnVsbCA/IGtleUNvZGUgOiBjaGFyQ29kZSlcXG4gIC8vIFNvbWUgYnJvd3NlcnMgZmlyZSBrZXlwcmVzcyBldmVudHMgZm9yIGJhY2tzcGFjZVxcbiAgaWYgKGNoID09IFxcXCJcXFxceDA4XFxcIikgeyByZXR1cm4gfVxcbiAgaWYgKGhhbmRsZUNoYXJCaW5kaW5nKGNtLCBlLCBjaCkpIHsgcmV0dXJuIH1cXG4gIGNtLmRpc3BsYXkuaW5wdXQub25LZXlQcmVzcyhlKVxcbn1cXG5cXG4vLyBBIG1vdXNlIGRvd24gY2FuIGJlIGEgc2luZ2xlIGNsaWNrLCBkb3VibGUgY2xpY2ssIHRyaXBsZSBjbGljayxcXG4vLyBzdGFydCBvZiBzZWxlY3Rpb24gZHJhZywgc3RhcnQgb2YgdGV4dCBkcmFnLCBuZXcgY3Vyc29yXFxuLy8gKGN0cmwtY2xpY2spLCByZWN0YW5nbGUgZHJhZyAoYWx0LWRyYWcpLCBvciB4d2luXFxuLy8gbWlkZGxlLWNsaWNrLXBhc3RlLiBPciBpdCBtaWdodCBiZSBhIGNsaWNrIG9uIHNvbWV0aGluZyB3ZSBzaG91bGRcXG4vLyBub3QgaW50ZXJmZXJlIHdpdGgsIHN1Y2ggYXMgYSBzY3JvbGxiYXIgb3Igd2lkZ2V0LlxcbmZ1bmN0aW9uIG9uTW91c2VEb3duKGUpIHtcXG4gIHZhciBjbSA9IHRoaXMsIGRpc3BsYXkgPSBjbS5kaXNwbGF5XFxuICBpZiAoc2lnbmFsRE9NRXZlbnQoY20sIGUpIHx8IGRpc3BsYXkuYWN0aXZlVG91Y2ggJiYgZGlzcGxheS5pbnB1dC5zdXBwb3J0c1RvdWNoKCkpIHsgcmV0dXJuIH1cXG4gIGRpc3BsYXkuaW5wdXQuZW5zdXJlUG9sbGVkKClcXG4gIGRpc3BsYXkuc2hpZnQgPSBlLnNoaWZ0S2V5XFxuXFxuICBpZiAoZXZlbnRJbldpZGdldChkaXNwbGF5LCBlKSkge1xcbiAgICBpZiAoIXdlYmtpdCkge1xcbiAgICAgIC8vIEJyaWVmbHkgdHVybiBvZmYgZHJhZ2dhYmlsaXR5LCB0byBhbGxvdyB3aWRnZXRzIHRvIGRvXFxuICAgICAgLy8gbm9ybWFsIGRyYWdnaW5nIHRoaW5ncy5cXG4gICAgICBkaXNwbGF5LnNjcm9sbGVyLmRyYWdnYWJsZSA9IGZhbHNlXFxuICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHJldHVybiBkaXNwbGF5LnNjcm9sbGVyLmRyYWdnYWJsZSA9IHRydWU7IH0sIDEwMClcXG4gICAgfVxcbiAgICByZXR1cm5cXG4gIH1cXG4gIGlmIChjbGlja0luR3V0dGVyKGNtLCBlKSkgeyByZXR1cm4gfVxcbiAgdmFyIHN0YXJ0ID0gcG9zRnJvbU1vdXNlKGNtLCBlKVxcbiAgd2luZG93LmZvY3VzKClcXG5cXG4gIHN3aXRjaCAoZV9idXR0b24oZSkpIHtcXG4gIGNhc2UgMTpcXG4gICAgLy8gIzMyNjE6IG1ha2Ugc3VyZSwgdGhhdCB3ZSdyZSBub3Qgc3RhcnRpbmcgYSBzZWNvbmQgc2VsZWN0aW9uXFxuICAgIGlmIChjbS5zdGF0ZS5zZWxlY3RpbmdUZXh0KVxcbiAgICAgIHsgY20uc3RhdGUuc2VsZWN0aW5nVGV4dChlKSB9XFxuICAgIGVsc2UgaWYgKHN0YXJ0KVxcbiAgICAgIHsgbGVmdEJ1dHRvbkRvd24oY20sIGUsIHN0YXJ0KSB9XFxuICAgIGVsc2UgaWYgKGVfdGFyZ2V0KGUpID09IGRpc3BsYXkuc2Nyb2xsZXIpXFxuICAgICAgeyBlX3ByZXZlbnREZWZhdWx0KGUpIH1cXG4gICAgYnJlYWtcXG4gIGNhc2UgMjpcXG4gICAgaWYgKHdlYmtpdCkgeyBjbS5zdGF0ZS5sYXN0TWlkZGxlRG93biA9ICtuZXcgRGF0ZSB9XFxuICAgIGlmIChzdGFydCkgeyBleHRlbmRTZWxlY3Rpb24oY20uZG9jLCBzdGFydCkgfVxcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRpc3BsYXkuaW5wdXQuZm9jdXMoKTsgfSwgMjApXFxuICAgIGVfcHJldmVudERlZmF1bHQoZSlcXG4gICAgYnJlYWtcXG4gIGNhc2UgMzpcXG4gICAgaWYgKGNhcHR1cmVSaWdodENsaWNrKSB7IG9uQ29udGV4dE1lbnUoY20sIGUpIH1cXG4gICAgZWxzZSB7IGRlbGF5Qmx1ckV2ZW50KGNtKSB9XFxuICAgIGJyZWFrXFxuICB9XFxufVxcblxcbnZhciBsYXN0Q2xpY2s7XFxudmFyIGxhc3REb3VibGVDbGljaztcXG5mdW5jdGlvbiBsZWZ0QnV0dG9uRG93bihjbSwgZSwgc3RhcnQpIHtcXG4gIGlmIChpZSkgeyBzZXRUaW1lb3V0KGJpbmQoZW5zdXJlRm9jdXMsIGNtKSwgMCkgfVxcbiAgZWxzZSB7IGNtLmN1ck9wLmZvY3VzID0gYWN0aXZlRWx0KCkgfVxcblxcbiAgdmFyIG5vdyA9ICtuZXcgRGF0ZSwgdHlwZVxcbiAgaWYgKGxhc3REb3VibGVDbGljayAmJiBsYXN0RG91YmxlQ2xpY2sudGltZSA+IG5vdyAtIDQwMCAmJiBjbXAobGFzdERvdWJsZUNsaWNrLnBvcywgc3RhcnQpID09IDApIHtcXG4gICAgdHlwZSA9IFxcXCJ0cmlwbGVcXFwiXFxuICB9IGVsc2UgaWYgKGxhc3RDbGljayAmJiBsYXN0Q2xpY2sudGltZSA+IG5vdyAtIDQwMCAmJiBjbXAobGFzdENsaWNrLnBvcywgc3RhcnQpID09IDApIHtcXG4gICAgdHlwZSA9IFxcXCJkb3VibGVcXFwiXFxuICAgIGxhc3REb3VibGVDbGljayA9IHt0aW1lOiBub3csIHBvczogc3RhcnR9XFxuICB9IGVsc2Uge1xcbiAgICB0eXBlID0gXFxcInNpbmdsZVxcXCJcXG4gICAgbGFzdENsaWNrID0ge3RpbWU6IG5vdywgcG9zOiBzdGFydH1cXG4gIH1cXG5cXG4gIHZhciBzZWwgPSBjbS5kb2Muc2VsLCBtb2RpZmllciA9IG1hYyA/IGUubWV0YUtleSA6IGUuY3RybEtleSwgY29udGFpbmVkXFxuICBpZiAoY20ub3B0aW9ucy5kcmFnRHJvcCAmJiBkcmFnQW5kRHJvcCAmJiAhY20uaXNSZWFkT25seSgpICYmXFxuICAgICAgdHlwZSA9PSBcXFwic2luZ2xlXFxcIiAmJiAoY29udGFpbmVkID0gc2VsLmNvbnRhaW5zKHN0YXJ0KSkgPiAtMSAmJlxcbiAgICAgIChjbXAoKGNvbnRhaW5lZCA9IHNlbC5yYW5nZXNbY29udGFpbmVkXSkuZnJvbSgpLCBzdGFydCkgPCAwIHx8IHN0YXJ0LnhSZWwgPiAwKSAmJlxcbiAgICAgIChjbXAoY29udGFpbmVkLnRvKCksIHN0YXJ0KSA+IDAgfHwgc3RhcnQueFJlbCA8IDApKVxcbiAgICB7IGxlZnRCdXR0b25TdGFydERyYWcoY20sIGUsIHN0YXJ0LCBtb2RpZmllcikgfVxcbiAgZWxzZVxcbiAgICB7IGxlZnRCdXR0b25TZWxlY3QoY20sIGUsIHN0YXJ0LCB0eXBlLCBtb2RpZmllcikgfVxcbn1cXG5cXG4vLyBTdGFydCBhIHRleHQgZHJhZy4gV2hlbiBpdCBlbmRzLCBzZWUgaWYgYW55IGRyYWdnaW5nIGFjdHVhbGx5XFxuLy8gaGFwcGVuLCBhbmQgdHJlYXQgYXMgYSBjbGljayBpZiBpdCBkaWRuJ3QuXFxuZnVuY3Rpb24gbGVmdEJ1dHRvblN0YXJ0RHJhZyhjbSwgZSwgc3RhcnQsIG1vZGlmaWVyKSB7XFxuICB2YXIgZGlzcGxheSA9IGNtLmRpc3BsYXksIHN0YXJ0VGltZSA9ICtuZXcgRGF0ZVxcbiAgdmFyIGRyYWdFbmQgPSBvcGVyYXRpb24oY20sIGZ1bmN0aW9uIChlMikge1xcbiAgICBpZiAod2Via2l0KSB7IGRpc3BsYXkuc2Nyb2xsZXIuZHJhZ2dhYmxlID0gZmFsc2UgfVxcbiAgICBjbS5zdGF0ZS5kcmFnZ2luZ1RleHQgPSBmYWxzZVxcbiAgICBvZmYoZG9jdW1lbnQsIFxcXCJtb3VzZXVwXFxcIiwgZHJhZ0VuZClcXG4gICAgb2ZmKGRpc3BsYXkuc2Nyb2xsZXIsIFxcXCJkcm9wXFxcIiwgZHJhZ0VuZClcXG4gICAgaWYgKE1hdGguYWJzKGUuY2xpZW50WCAtIGUyLmNsaWVudFgpICsgTWF0aC5hYnMoZS5jbGllbnRZIC0gZTIuY2xpZW50WSkgPCAxMCkge1xcbiAgICAgIGVfcHJldmVudERlZmF1bHQoZTIpXFxuICAgICAgaWYgKCFtb2RpZmllciAmJiArbmV3IERhdGUgLSAyMDAgPCBzdGFydFRpbWUpXFxuICAgICAgICB7IGV4dGVuZFNlbGVjdGlvbihjbS5kb2MsIHN0YXJ0KSB9XFxuICAgICAgLy8gV29yayBhcm91bmQgdW5leHBsYWluYWJsZSBmb2N1cyBwcm9ibGVtIGluIElFOSAoIzIxMjcpIGFuZCBDaHJvbWUgKCMzMDgxKVxcbiAgICAgIGlmICh3ZWJraXQgfHwgaWUgJiYgaWVfdmVyc2lvbiA9PSA5KVxcbiAgICAgICAgeyBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtkb2N1bWVudC5ib2R5LmZvY3VzKCk7IGRpc3BsYXkuaW5wdXQuZm9jdXMoKX0sIDIwKSB9XFxuICAgICAgZWxzZVxcbiAgICAgICAgeyBkaXNwbGF5LmlucHV0LmZvY3VzKCkgfVxcbiAgICB9XFxuICB9KVxcbiAgLy8gTGV0IHRoZSBkcmFnIGhhbmRsZXIgaGFuZGxlIHRoaXMuXFxuICBpZiAod2Via2l0KSB7IGRpc3BsYXkuc2Nyb2xsZXIuZHJhZ2dhYmxlID0gdHJ1ZSB9XFxuICBjbS5zdGF0ZS5kcmFnZ2luZ1RleHQgPSBkcmFnRW5kXFxuICBkcmFnRW5kLmNvcHkgPSBtYWMgPyBlLmFsdEtleSA6IGUuY3RybEtleVxcbiAgLy8gSUUncyBhcHByb2FjaCB0byBkcmFnZ2FibGVcXG4gIGlmIChkaXNwbGF5LnNjcm9sbGVyLmRyYWdEcm9wKSB7IGRpc3BsYXkuc2Nyb2xsZXIuZHJhZ0Ryb3AoKSB9XFxuICBvbihkb2N1bWVudCwgXFxcIm1vdXNldXBcXFwiLCBkcmFnRW5kKVxcbiAgb24oZGlzcGxheS5zY3JvbGxlciwgXFxcImRyb3BcXFwiLCBkcmFnRW5kKVxcbn1cXG5cXG4vLyBOb3JtYWwgc2VsZWN0aW9uLCBhcyBvcHBvc2VkIHRvIHRleHQgZHJhZ2dpbmcuXFxuZnVuY3Rpb24gbGVmdEJ1dHRvblNlbGVjdChjbSwgZSwgc3RhcnQsIHR5cGUsIGFkZE5ldykge1xcbiAgdmFyIGRpc3BsYXkgPSBjbS5kaXNwbGF5LCBkb2MgPSBjbS5kb2NcXG4gIGVfcHJldmVudERlZmF1bHQoZSlcXG5cXG4gIHZhciBvdXJSYW5nZSwgb3VySW5kZXgsIHN0YXJ0U2VsID0gZG9jLnNlbCwgcmFuZ2VzID0gc3RhcnRTZWwucmFuZ2VzXFxuICBpZiAoYWRkTmV3ICYmICFlLnNoaWZ0S2V5KSB7XFxuICAgIG91ckluZGV4ID0gZG9jLnNlbC5jb250YWlucyhzdGFydClcXG4gICAgaWYgKG91ckluZGV4ID4gLTEpXFxuICAgICAgeyBvdXJSYW5nZSA9IHJhbmdlc1tvdXJJbmRleF0gfVxcbiAgICBlbHNlXFxuICAgICAgeyBvdXJSYW5nZSA9IG5ldyBSYW5nZShzdGFydCwgc3RhcnQpIH1cXG4gIH0gZWxzZSB7XFxuICAgIG91clJhbmdlID0gZG9jLnNlbC5wcmltYXJ5KClcXG4gICAgb3VySW5kZXggPSBkb2Muc2VsLnByaW1JbmRleFxcbiAgfVxcblxcbiAgaWYgKGNocm9tZU9TID8gZS5zaGlmdEtleSAmJiBlLm1ldGFLZXkgOiBlLmFsdEtleSkge1xcbiAgICB0eXBlID0gXFxcInJlY3RcXFwiXFxuICAgIGlmICghYWRkTmV3KSB7IG91clJhbmdlID0gbmV3IFJhbmdlKHN0YXJ0LCBzdGFydCkgfVxcbiAgICBzdGFydCA9IHBvc0Zyb21Nb3VzZShjbSwgZSwgdHJ1ZSwgdHJ1ZSlcXG4gICAgb3VySW5kZXggPSAtMVxcbiAgfSBlbHNlIGlmICh0eXBlID09IFxcXCJkb3VibGVcXFwiKSB7XFxuICAgIHZhciB3b3JkID0gY20uZmluZFdvcmRBdChzdGFydClcXG4gICAgaWYgKGNtLmRpc3BsYXkuc2hpZnQgfHwgZG9jLmV4dGVuZClcXG4gICAgICB7IG91clJhbmdlID0gZXh0ZW5kUmFuZ2UoZG9jLCBvdXJSYW5nZSwgd29yZC5hbmNob3IsIHdvcmQuaGVhZCkgfVxcbiAgICBlbHNlXFxuICAgICAgeyBvdXJSYW5nZSA9IHdvcmQgfVxcbiAgfSBlbHNlIGlmICh0eXBlID09IFxcXCJ0cmlwbGVcXFwiKSB7XFxuICAgIHZhciBsaW5lID0gbmV3IFJhbmdlKFBvcyhzdGFydC5saW5lLCAwKSwgY2xpcFBvcyhkb2MsIFBvcyhzdGFydC5saW5lICsgMSwgMCkpKVxcbiAgICBpZiAoY20uZGlzcGxheS5zaGlmdCB8fCBkb2MuZXh0ZW5kKVxcbiAgICAgIHsgb3VyUmFuZ2UgPSBleHRlbmRSYW5nZShkb2MsIG91clJhbmdlLCBsaW5lLmFuY2hvciwgbGluZS5oZWFkKSB9XFxuICAgIGVsc2VcXG4gICAgICB7IG91clJhbmdlID0gbGluZSB9XFxuICB9IGVsc2Uge1xcbiAgICBvdXJSYW5nZSA9IGV4dGVuZFJhbmdlKGRvYywgb3VyUmFuZ2UsIHN0YXJ0KVxcbiAgfVxcblxcbiAgaWYgKCFhZGROZXcpIHtcXG4gICAgb3VySW5kZXggPSAwXFxuICAgIHNldFNlbGVjdGlvbihkb2MsIG5ldyBTZWxlY3Rpb24oW291clJhbmdlXSwgMCksIHNlbF9tb3VzZSlcXG4gICAgc3RhcnRTZWwgPSBkb2Muc2VsXFxuICB9IGVsc2UgaWYgKG91ckluZGV4ID09IC0xKSB7XFxuICAgIG91ckluZGV4ID0gcmFuZ2VzLmxlbmd0aFxcbiAgICBzZXRTZWxlY3Rpb24oZG9jLCBub3JtYWxpemVTZWxlY3Rpb24ocmFuZ2VzLmNvbmNhdChbb3VyUmFuZ2VdKSwgb3VySW5kZXgpLFxcbiAgICAgICAgICAgICAgICAge3Njcm9sbDogZmFsc2UsIG9yaWdpbjogXFxcIiptb3VzZVxcXCJ9KVxcbiAgfSBlbHNlIGlmIChyYW5nZXMubGVuZ3RoID4gMSAmJiByYW5nZXNbb3VySW5kZXhdLmVtcHR5KCkgJiYgdHlwZSA9PSBcXFwic2luZ2xlXFxcIiAmJiAhZS5zaGlmdEtleSkge1xcbiAgICBzZXRTZWxlY3Rpb24oZG9jLCBub3JtYWxpemVTZWxlY3Rpb24ocmFuZ2VzLnNsaWNlKDAsIG91ckluZGV4KS5jb25jYXQocmFuZ2VzLnNsaWNlKG91ckluZGV4ICsgMSkpLCAwKSxcXG4gICAgICAgICAgICAgICAgIHtzY3JvbGw6IGZhbHNlLCBvcmlnaW46IFxcXCIqbW91c2VcXFwifSlcXG4gICAgc3RhcnRTZWwgPSBkb2Muc2VsXFxuICB9IGVsc2Uge1xcbiAgICByZXBsYWNlT25lU2VsZWN0aW9uKGRvYywgb3VySW5kZXgsIG91clJhbmdlLCBzZWxfbW91c2UpXFxuICB9XFxuXFxuICB2YXIgbGFzdFBvcyA9IHN0YXJ0XFxuICBmdW5jdGlvbiBleHRlbmRUbyhwb3MpIHtcXG4gICAgaWYgKGNtcChsYXN0UG9zLCBwb3MpID09IDApIHsgcmV0dXJuIH1cXG4gICAgbGFzdFBvcyA9IHBvc1xcblxcbiAgICBpZiAodHlwZSA9PSBcXFwicmVjdFxcXCIpIHtcXG4gICAgICB2YXIgcmFuZ2VzID0gW10sIHRhYlNpemUgPSBjbS5vcHRpb25zLnRhYlNpemVcXG4gICAgICB2YXIgc3RhcnRDb2wgPSBjb3VudENvbHVtbihnZXRMaW5lKGRvYywgc3RhcnQubGluZSkudGV4dCwgc3RhcnQuY2gsIHRhYlNpemUpXFxuICAgICAgdmFyIHBvc0NvbCA9IGNvdW50Q29sdW1uKGdldExpbmUoZG9jLCBwb3MubGluZSkudGV4dCwgcG9zLmNoLCB0YWJTaXplKVxcbiAgICAgIHZhciBsZWZ0ID0gTWF0aC5taW4oc3RhcnRDb2wsIHBvc0NvbCksIHJpZ2h0ID0gTWF0aC5tYXgoc3RhcnRDb2wsIHBvc0NvbClcXG4gICAgICBmb3IgKHZhciBsaW5lID0gTWF0aC5taW4oc3RhcnQubGluZSwgcG9zLmxpbmUpLCBlbmQgPSBNYXRoLm1pbihjbS5sYXN0TGluZSgpLCBNYXRoLm1heChzdGFydC5saW5lLCBwb3MubGluZSkpO1xcbiAgICAgICAgICAgbGluZSA8PSBlbmQ7IGxpbmUrKykge1xcbiAgICAgICAgdmFyIHRleHQgPSBnZXRMaW5lKGRvYywgbGluZSkudGV4dCwgbGVmdFBvcyA9IGZpbmRDb2x1bW4odGV4dCwgbGVmdCwgdGFiU2l6ZSlcXG4gICAgICAgIGlmIChsZWZ0ID09IHJpZ2h0KVxcbiAgICAgICAgICB7IHJhbmdlcy5wdXNoKG5ldyBSYW5nZShQb3MobGluZSwgbGVmdFBvcyksIFBvcyhsaW5lLCBsZWZ0UG9zKSkpIH1cXG4gICAgICAgIGVsc2UgaWYgKHRleHQubGVuZ3RoID4gbGVmdFBvcylcXG4gICAgICAgICAgeyByYW5nZXMucHVzaChuZXcgUmFuZ2UoUG9zKGxpbmUsIGxlZnRQb3MpLCBQb3MobGluZSwgZmluZENvbHVtbih0ZXh0LCByaWdodCwgdGFiU2l6ZSkpKSkgfVxcbiAgICAgIH1cXG4gICAgICBpZiAoIXJhbmdlcy5sZW5ndGgpIHsgcmFuZ2VzLnB1c2gobmV3IFJhbmdlKHN0YXJ0LCBzdGFydCkpIH1cXG4gICAgICBzZXRTZWxlY3Rpb24oZG9jLCBub3JtYWxpemVTZWxlY3Rpb24oc3RhcnRTZWwucmFuZ2VzLnNsaWNlKDAsIG91ckluZGV4KS5jb25jYXQocmFuZ2VzKSwgb3VySW5kZXgpLFxcbiAgICAgICAgICAgICAgICAgICB7b3JpZ2luOiBcXFwiKm1vdXNlXFxcIiwgc2Nyb2xsOiBmYWxzZX0pXFxuICAgICAgY20uc2Nyb2xsSW50b1ZpZXcocG9zKVxcbiAgICB9IGVsc2Uge1xcbiAgICAgIHZhciBvbGRSYW5nZSA9IG91clJhbmdlXFxuICAgICAgdmFyIGFuY2hvciA9IG9sZFJhbmdlLmFuY2hvciwgaGVhZCA9IHBvc1xcbiAgICAgIGlmICh0eXBlICE9IFxcXCJzaW5nbGVcXFwiKSB7XFxuICAgICAgICB2YXIgcmFuZ2VcXG4gICAgICAgIGlmICh0eXBlID09IFxcXCJkb3VibGVcXFwiKVxcbiAgICAgICAgICB7IHJhbmdlID0gY20uZmluZFdvcmRBdChwb3MpIH1cXG4gICAgICAgIGVsc2VcXG4gICAgICAgICAgeyByYW5nZSA9IG5ldyBSYW5nZShQb3MocG9zLmxpbmUsIDApLCBjbGlwUG9zKGRvYywgUG9zKHBvcy5saW5lICsgMSwgMCkpKSB9XFxuICAgICAgICBpZiAoY21wKHJhbmdlLmFuY2hvciwgYW5jaG9yKSA+IDApIHtcXG4gICAgICAgICAgaGVhZCA9IHJhbmdlLmhlYWRcXG4gICAgICAgICAgYW5jaG9yID0gbWluUG9zKG9sZFJhbmdlLmZyb20oKSwgcmFuZ2UuYW5jaG9yKVxcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgaGVhZCA9IHJhbmdlLmFuY2hvclxcbiAgICAgICAgICBhbmNob3IgPSBtYXhQb3Mob2xkUmFuZ2UudG8oKSwgcmFuZ2UuaGVhZClcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgICAgdmFyIHJhbmdlcyQxID0gc3RhcnRTZWwucmFuZ2VzLnNsaWNlKDApXFxuICAgICAgcmFuZ2VzJDFbb3VySW5kZXhdID0gbmV3IFJhbmdlKGNsaXBQb3MoZG9jLCBhbmNob3IpLCBoZWFkKVxcbiAgICAgIHNldFNlbGVjdGlvbihkb2MsIG5vcm1hbGl6ZVNlbGVjdGlvbihyYW5nZXMkMSwgb3VySW5kZXgpLCBzZWxfbW91c2UpXFxuICAgIH1cXG4gIH1cXG5cXG4gIHZhciBlZGl0b3JTaXplID0gZGlzcGxheS53cmFwcGVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXFxuICAvLyBVc2VkIHRvIGVuc3VyZSB0aW1lb3V0IHJlLXRyaWVzIGRvbid0IGZpcmUgd2hlbiBhbm90aGVyIGV4dGVuZFxcbiAgLy8gaGFwcGVuZWQgaW4gdGhlIG1lYW50aW1lIChjbGVhclRpbWVvdXQgaXNuJ3QgcmVsaWFibGUgLS0gYXRcXG4gIC8vIGxlYXN0IG9uIENocm9tZSwgdGhlIHRpbWVvdXRzIHN0aWxsIGhhcHBlbiBldmVuIHdoZW4gY2xlYXJlZCxcXG4gIC8vIGlmIHRoZSBjbGVhciBoYXBwZW5zIGFmdGVyIHRoZWlyIHNjaGVkdWxlZCBmaXJpbmcgdGltZSkuXFxuICB2YXIgY291bnRlciA9IDBcXG5cXG4gIGZ1bmN0aW9uIGV4dGVuZChlKSB7XFxuICAgIHZhciBjdXJDb3VudCA9ICsrY291bnRlclxcbiAgICB2YXIgY3VyID0gcG9zRnJvbU1vdXNlKGNtLCBlLCB0cnVlLCB0eXBlID09IFxcXCJyZWN0XFxcIilcXG4gICAgaWYgKCFjdXIpIHsgcmV0dXJuIH1cXG4gICAgaWYgKGNtcChjdXIsIGxhc3RQb3MpICE9IDApIHtcXG4gICAgICBjbS5jdXJPcC5mb2N1cyA9IGFjdGl2ZUVsdCgpXFxuICAgICAgZXh0ZW5kVG8oY3VyKVxcbiAgICAgIHZhciB2aXNpYmxlID0gdmlzaWJsZUxpbmVzKGRpc3BsYXksIGRvYylcXG4gICAgICBpZiAoY3VyLmxpbmUgPj0gdmlzaWJsZS50byB8fCBjdXIubGluZSA8IHZpc2libGUuZnJvbSlcXG4gICAgICAgIHsgc2V0VGltZW91dChvcGVyYXRpb24oY20sIGZ1bmN0aW9uICgpIHtpZiAoY291bnRlciA9PSBjdXJDb3VudCkgeyBleHRlbmQoZSkgfX0pLCAxNTApIH1cXG4gICAgfSBlbHNlIHtcXG4gICAgICB2YXIgb3V0c2lkZSA9IGUuY2xpZW50WSA8IGVkaXRvclNpemUudG9wID8gLTIwIDogZS5jbGllbnRZID4gZWRpdG9yU2l6ZS5ib3R0b20gPyAyMCA6IDBcXG4gICAgICBpZiAob3V0c2lkZSkgeyBzZXRUaW1lb3V0KG9wZXJhdGlvbihjbSwgZnVuY3Rpb24gKCkge1xcbiAgICAgICAgaWYgKGNvdW50ZXIgIT0gY3VyQ291bnQpIHsgcmV0dXJuIH1cXG4gICAgICAgIGRpc3BsYXkuc2Nyb2xsZXIuc2Nyb2xsVG9wICs9IG91dHNpZGVcXG4gICAgICAgIGV4dGVuZChlKVxcbiAgICAgIH0pLCA1MCkgfVxcbiAgICB9XFxuICB9XFxuXFxuICBmdW5jdGlvbiBkb25lKGUpIHtcXG4gICAgY20uc3RhdGUuc2VsZWN0aW5nVGV4dCA9IGZhbHNlXFxuICAgIGNvdW50ZXIgPSBJbmZpbml0eVxcbiAgICBlX3ByZXZlbnREZWZhdWx0KGUpXFxuICAgIGRpc3BsYXkuaW5wdXQuZm9jdXMoKVxcbiAgICBvZmYoZG9jdW1lbnQsIFxcXCJtb3VzZW1vdmVcXFwiLCBtb3ZlKVxcbiAgICBvZmYoZG9jdW1lbnQsIFxcXCJtb3VzZXVwXFxcIiwgdXApXFxuICAgIGRvYy5oaXN0b3J5Lmxhc3RTZWxPcmlnaW4gPSBudWxsXFxuICB9XFxuXFxuICB2YXIgbW92ZSA9IG9wZXJhdGlvbihjbSwgZnVuY3Rpb24gKGUpIHtcXG4gICAgaWYgKCFlX2J1dHRvbihlKSkgeyBkb25lKGUpIH1cXG4gICAgZWxzZSB7IGV4dGVuZChlKSB9XFxuICB9KVxcbiAgdmFyIHVwID0gb3BlcmF0aW9uKGNtLCBkb25lKVxcbiAgY20uc3RhdGUuc2VsZWN0aW5nVGV4dCA9IHVwXFxuICBvbihkb2N1bWVudCwgXFxcIm1vdXNlbW92ZVxcXCIsIG1vdmUpXFxuICBvbihkb2N1bWVudCwgXFxcIm1vdXNldXBcXFwiLCB1cClcXG59XFxuXFxuXFxuLy8gRGV0ZXJtaW5lcyB3aGV0aGVyIGFuIGV2ZW50IGhhcHBlbmVkIGluIHRoZSBndXR0ZXIsIGFuZCBmaXJlcyB0aGVcXG4vLyBoYW5kbGVycyBmb3IgdGhlIGNvcnJlc3BvbmRpbmcgZXZlbnQuXFxuZnVuY3Rpb24gZ3V0dGVyRXZlbnQoY20sIGUsIHR5cGUsIHByZXZlbnQpIHtcXG4gIHZhciBtWCwgbVlcXG4gIHRyeSB7IG1YID0gZS5jbGllbnRYOyBtWSA9IGUuY2xpZW50WSB9XFxuICBjYXRjaChlKSB7IHJldHVybiBmYWxzZSB9XFxuICBpZiAobVggPj0gTWF0aC5mbG9vcihjbS5kaXNwbGF5Lmd1dHRlcnMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkucmlnaHQpKSB7IHJldHVybiBmYWxzZSB9XFxuICBpZiAocHJldmVudCkgeyBlX3ByZXZlbnREZWZhdWx0KGUpIH1cXG5cXG4gIHZhciBkaXNwbGF5ID0gY20uZGlzcGxheVxcbiAgdmFyIGxpbmVCb3ggPSBkaXNwbGF5LmxpbmVEaXYuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClcXG5cXG4gIGlmIChtWSA+IGxpbmVCb3guYm90dG9tIHx8ICFoYXNIYW5kbGVyKGNtLCB0eXBlKSkgeyByZXR1cm4gZV9kZWZhdWx0UHJldmVudGVkKGUpIH1cXG4gIG1ZIC09IGxpbmVCb3gudG9wIC0gZGlzcGxheS52aWV3T2Zmc2V0XFxuXFxuICBmb3IgKHZhciBpID0gMDsgaSA8IGNtLm9wdGlvbnMuZ3V0dGVycy5sZW5ndGg7ICsraSkge1xcbiAgICB2YXIgZyA9IGRpc3BsYXkuZ3V0dGVycy5jaGlsZE5vZGVzW2ldXFxuICAgIGlmIChnICYmIGcuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkucmlnaHQgPj0gbVgpIHtcXG4gICAgICB2YXIgbGluZSA9IGxpbmVBdEhlaWdodChjbS5kb2MsIG1ZKVxcbiAgICAgIHZhciBndXR0ZXIgPSBjbS5vcHRpb25zLmd1dHRlcnNbaV1cXG4gICAgICBzaWduYWwoY20sIHR5cGUsIGNtLCBsaW5lLCBndXR0ZXIsIGUpXFxuICAgICAgcmV0dXJuIGVfZGVmYXVsdFByZXZlbnRlZChlKVxcbiAgICB9XFxuICB9XFxufVxcblxcbmZ1bmN0aW9uIGNsaWNrSW5HdXR0ZXIoY20sIGUpIHtcXG4gIHJldHVybiBndXR0ZXJFdmVudChjbSwgZSwgXFxcImd1dHRlckNsaWNrXFxcIiwgdHJ1ZSlcXG59XFxuXFxuLy8gQ09OVEVYVCBNRU5VIEhBTkRMSU5HXFxuXFxuLy8gVG8gbWFrZSB0aGUgY29udGV4dCBtZW51IHdvcmssIHdlIG5lZWQgdG8gYnJpZWZseSB1bmhpZGUgdGhlXFxuLy8gdGV4dGFyZWEgKG1ha2luZyBpdCBhcyB1bm9idHJ1c2l2ZSBhcyBwb3NzaWJsZSkgdG8gbGV0IHRoZVxcbi8vIHJpZ2h0LWNsaWNrIHRha2UgZWZmZWN0IG9uIGl0LlxcbmZ1bmN0aW9uIG9uQ29udGV4dE1lbnUoY20sIGUpIHtcXG4gIGlmIChldmVudEluV2lkZ2V0KGNtLmRpc3BsYXksIGUpIHx8IGNvbnRleHRNZW51SW5HdXR0ZXIoY20sIGUpKSB7IHJldHVybiB9XFxuICBpZiAoc2lnbmFsRE9NRXZlbnQoY20sIGUsIFxcXCJjb250ZXh0bWVudVxcXCIpKSB7IHJldHVybiB9XFxuICBjbS5kaXNwbGF5LmlucHV0Lm9uQ29udGV4dE1lbnUoZSlcXG59XFxuXFxuZnVuY3Rpb24gY29udGV4dE1lbnVJbkd1dHRlcihjbSwgZSkge1xcbiAgaWYgKCFoYXNIYW5kbGVyKGNtLCBcXFwiZ3V0dGVyQ29udGV4dE1lbnVcXFwiKSkgeyByZXR1cm4gZmFsc2UgfVxcbiAgcmV0dXJuIGd1dHRlckV2ZW50KGNtLCBlLCBcXFwiZ3V0dGVyQ29udGV4dE1lbnVcXFwiLCBmYWxzZSlcXG59XFxuXFxuZnVuY3Rpb24gdGhlbWVDaGFuZ2VkKGNtKSB7XFxuICBjbS5kaXNwbGF5LndyYXBwZXIuY2xhc3NOYW1lID0gY20uZGlzcGxheS53cmFwcGVyLmNsYXNzTmFtZS5yZXBsYWNlKC9cXFxccypjbS1zLVxcXFxTKy9nLCBcXFwiXFxcIikgK1xcbiAgICBjbS5vcHRpb25zLnRoZW1lLnJlcGxhY2UoLyhefFxcXFxzKVxcXFxzKi9nLCBcXFwiIGNtLXMtXFxcIilcXG4gIGNsZWFyQ2FjaGVzKGNtKVxcbn1cXG5cXG52YXIgSW5pdCA9IHt0b1N0cmluZzogZnVuY3Rpb24oKXtyZXR1cm4gXFxcIkNvZGVNaXJyb3IuSW5pdFxcXCJ9fVxcblxcbnZhciBkZWZhdWx0cyA9IHt9XFxudmFyIG9wdGlvbkhhbmRsZXJzID0ge31cXG5cXG5mdW5jdGlvbiBkZWZpbmVPcHRpb25zKENvZGVNaXJyb3IpIHtcXG4gIHZhciBvcHRpb25IYW5kbGVycyA9IENvZGVNaXJyb3Iub3B0aW9uSGFuZGxlcnNcXG5cXG4gIGZ1bmN0aW9uIG9wdGlvbihuYW1lLCBkZWZsdCwgaGFuZGxlLCBub3RPbkluaXQpIHtcXG4gICAgQ29kZU1pcnJvci5kZWZhdWx0c1tuYW1lXSA9IGRlZmx0XFxuICAgIGlmIChoYW5kbGUpIHsgb3B0aW9uSGFuZGxlcnNbbmFtZV0gPVxcbiAgICAgIG5vdE9uSW5pdCA/IGZ1bmN0aW9uIChjbSwgdmFsLCBvbGQpIHtpZiAob2xkICE9IEluaXQpIHsgaGFuZGxlKGNtLCB2YWwsIG9sZCkgfX0gOiBoYW5kbGUgfVxcbiAgfVxcblxcbiAgQ29kZU1pcnJvci5kZWZpbmVPcHRpb24gPSBvcHRpb25cXG5cXG4gIC8vIFBhc3NlZCB0byBvcHRpb24gaGFuZGxlcnMgd2hlbiB0aGVyZSBpcyBubyBvbGQgdmFsdWUuXFxuICBDb2RlTWlycm9yLkluaXQgPSBJbml0XFxuXFxuICAvLyBUaGVzZSB0d28gYXJlLCBvbiBpbml0LCBjYWxsZWQgZnJvbSB0aGUgY29uc3RydWN0b3IgYmVjYXVzZSB0aGV5XFxuICAvLyBoYXZlIHRvIGJlIGluaXRpYWxpemVkIGJlZm9yZSB0aGUgZWRpdG9yIGNhbiBzdGFydCBhdCBhbGwuXFxuICBvcHRpb24oXFxcInZhbHVlXFxcIiwgXFxcIlxcXCIsIGZ1bmN0aW9uIChjbSwgdmFsKSB7IHJldHVybiBjbS5zZXRWYWx1ZSh2YWwpOyB9LCB0cnVlKVxcbiAgb3B0aW9uKFxcXCJtb2RlXFxcIiwgbnVsbCwgZnVuY3Rpb24gKGNtLCB2YWwpIHtcXG4gICAgY20uZG9jLm1vZGVPcHRpb24gPSB2YWxcXG4gICAgbG9hZE1vZGUoY20pXFxuICB9LCB0cnVlKVxcblxcbiAgb3B0aW9uKFxcXCJpbmRlbnRVbml0XFxcIiwgMiwgbG9hZE1vZGUsIHRydWUpXFxuICBvcHRpb24oXFxcImluZGVudFdpdGhUYWJzXFxcIiwgZmFsc2UpXFxuICBvcHRpb24oXFxcInNtYXJ0SW5kZW50XFxcIiwgdHJ1ZSlcXG4gIG9wdGlvbihcXFwidGFiU2l6ZVxcXCIsIDQsIGZ1bmN0aW9uIChjbSkge1xcbiAgICByZXNldE1vZGVTdGF0ZShjbSlcXG4gICAgY2xlYXJDYWNoZXMoY20pXFxuICAgIHJlZ0NoYW5nZShjbSlcXG4gIH0sIHRydWUpXFxuICBvcHRpb24oXFxcImxpbmVTZXBhcmF0b3JcXFwiLCBudWxsLCBmdW5jdGlvbiAoY20sIHZhbCkge1xcbiAgICBjbS5kb2MubGluZVNlcCA9IHZhbFxcbiAgICBpZiAoIXZhbCkgeyByZXR1cm4gfVxcbiAgICB2YXIgbmV3QnJlYWtzID0gW10sIGxpbmVObyA9IGNtLmRvYy5maXJzdFxcbiAgICBjbS5kb2MuaXRlcihmdW5jdGlvbiAobGluZSkge1xcbiAgICAgIGZvciAodmFyIHBvcyA9IDA7Oykge1xcbiAgICAgICAgdmFyIGZvdW5kID0gbGluZS50ZXh0LmluZGV4T2YodmFsLCBwb3MpXFxuICAgICAgICBpZiAoZm91bmQgPT0gLTEpIHsgYnJlYWsgfVxcbiAgICAgICAgcG9zID0gZm91bmQgKyB2YWwubGVuZ3RoXFxuICAgICAgICBuZXdCcmVha3MucHVzaChQb3MobGluZU5vLCBmb3VuZCkpXFxuICAgICAgfVxcbiAgICAgIGxpbmVObysrXFxuICAgIH0pXFxuICAgIGZvciAodmFyIGkgPSBuZXdCcmVha3MubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pXFxuICAgICAgeyByZXBsYWNlUmFuZ2UoY20uZG9jLCB2YWwsIG5ld0JyZWFrc1tpXSwgUG9zKG5ld0JyZWFrc1tpXS5saW5lLCBuZXdCcmVha3NbaV0uY2ggKyB2YWwubGVuZ3RoKSkgfVxcbiAgfSlcXG4gIG9wdGlvbihcXFwic3BlY2lhbENoYXJzXFxcIiwgL1tcXFxcdTAwMDAtXFxcXHUwMDFmXFxcXHUwMDdmXFxcXHUwMGFkXFxcXHUwNjFjXFxcXHUyMDBiLVxcXFx1MjAwZlxcXFx1MjAyOFxcXFx1MjAyOVxcXFx1ZmVmZl0vZywgZnVuY3Rpb24gKGNtLCB2YWwsIG9sZCkge1xcbiAgICBjbS5zdGF0ZS5zcGVjaWFsQ2hhcnMgPSBuZXcgUmVnRXhwKHZhbC5zb3VyY2UgKyAodmFsLnRlc3QoXFxcIlxcXFx0XFxcIikgPyBcXFwiXFxcIiA6IFxcXCJ8XFxcXHRcXFwiKSwgXFxcImdcXFwiKVxcbiAgICBpZiAob2xkICE9IEluaXQpIHsgY20ucmVmcmVzaCgpIH1cXG4gIH0pXFxuICBvcHRpb24oXFxcInNwZWNpYWxDaGFyUGxhY2Vob2xkZXJcXFwiLCBkZWZhdWx0U3BlY2lhbENoYXJQbGFjZWhvbGRlciwgZnVuY3Rpb24gKGNtKSB7IHJldHVybiBjbS5yZWZyZXNoKCk7IH0sIHRydWUpXFxuICBvcHRpb24oXFxcImVsZWN0cmljQ2hhcnNcXFwiLCB0cnVlKVxcbiAgb3B0aW9uKFxcXCJpbnB1dFN0eWxlXFxcIiwgbW9iaWxlID8gXFxcImNvbnRlbnRlZGl0YWJsZVxcXCIgOiBcXFwidGV4dGFyZWFcXFwiLCBmdW5jdGlvbiAoKSB7XFxuICAgIHRocm93IG5ldyBFcnJvcihcXFwiaW5wdXRTdHlsZSBjYW4gbm90ICh5ZXQpIGJlIGNoYW5nZWQgaW4gYSBydW5uaW5nIGVkaXRvclxcXCIpIC8vIEZJWE1FXFxuICB9LCB0cnVlKVxcbiAgb3B0aW9uKFxcXCJzcGVsbGNoZWNrXFxcIiwgZmFsc2UsIGZ1bmN0aW9uIChjbSwgdmFsKSB7IHJldHVybiBjbS5nZXRJbnB1dEZpZWxkKCkuc3BlbGxjaGVjayA9IHZhbDsgfSwgdHJ1ZSlcXG4gIG9wdGlvbihcXFwicnRsTW92ZVZpc3VhbGx5XFxcIiwgIXdpbmRvd3MpXFxuICBvcHRpb24oXFxcIndob2xlTGluZVVwZGF0ZUJlZm9yZVxcXCIsIHRydWUpXFxuXFxuICBvcHRpb24oXFxcInRoZW1lXFxcIiwgXFxcImRlZmF1bHRcXFwiLCBmdW5jdGlvbiAoY20pIHtcXG4gICAgdGhlbWVDaGFuZ2VkKGNtKVxcbiAgICBndXR0ZXJzQ2hhbmdlZChjbSlcXG4gIH0sIHRydWUpXFxuICBvcHRpb24oXFxcImtleU1hcFxcXCIsIFxcXCJkZWZhdWx0XFxcIiwgZnVuY3Rpb24gKGNtLCB2YWwsIG9sZCkge1xcbiAgICB2YXIgbmV4dCA9IGdldEtleU1hcCh2YWwpXFxuICAgIHZhciBwcmV2ID0gb2xkICE9IEluaXQgJiYgZ2V0S2V5TWFwKG9sZClcXG4gICAgaWYgKHByZXYgJiYgcHJldi5kZXRhY2gpIHsgcHJldi5kZXRhY2goY20sIG5leHQpIH1cXG4gICAgaWYgKG5leHQuYXR0YWNoKSB7IG5leHQuYXR0YWNoKGNtLCBwcmV2IHx8IG51bGwpIH1cXG4gIH0pXFxuICBvcHRpb24oXFxcImV4dHJhS2V5c1xcXCIsIG51bGwpXFxuXFxuICBvcHRpb24oXFxcImxpbmVXcmFwcGluZ1xcXCIsIGZhbHNlLCB3cmFwcGluZ0NoYW5nZWQsIHRydWUpXFxuICBvcHRpb24oXFxcImd1dHRlcnNcXFwiLCBbXSwgZnVuY3Rpb24gKGNtKSB7XFxuICAgIHNldEd1dHRlcnNGb3JMaW5lTnVtYmVycyhjbS5vcHRpb25zKVxcbiAgICBndXR0ZXJzQ2hhbmdlZChjbSlcXG4gIH0sIHRydWUpXFxuICBvcHRpb24oXFxcImZpeGVkR3V0dGVyXFxcIiwgdHJ1ZSwgZnVuY3Rpb24gKGNtLCB2YWwpIHtcXG4gICAgY20uZGlzcGxheS5ndXR0ZXJzLnN0eWxlLmxlZnQgPSB2YWwgPyBjb21wZW5zYXRlRm9ySFNjcm9sbChjbS5kaXNwbGF5KSArIFxcXCJweFxcXCIgOiBcXFwiMFxcXCJcXG4gICAgY20ucmVmcmVzaCgpXFxuICB9LCB0cnVlKVxcbiAgb3B0aW9uKFxcXCJjb3Zlckd1dHRlck5leHRUb1Njcm9sbGJhclxcXCIsIGZhbHNlLCBmdW5jdGlvbiAoY20pIHsgcmV0dXJuIHVwZGF0ZVNjcm9sbGJhcnMoY20pOyB9LCB0cnVlKVxcbiAgb3B0aW9uKFxcXCJzY3JvbGxiYXJTdHlsZVxcXCIsIFxcXCJuYXRpdmVcXFwiLCBmdW5jdGlvbiAoY20pIHtcXG4gICAgaW5pdFNjcm9sbGJhcnMoY20pXFxuICAgIHVwZGF0ZVNjcm9sbGJhcnMoY20pXFxuICAgIGNtLmRpc3BsYXkuc2Nyb2xsYmFycy5zZXRTY3JvbGxUb3AoY20uZG9jLnNjcm9sbFRvcClcXG4gICAgY20uZGlzcGxheS5zY3JvbGxiYXJzLnNldFNjcm9sbExlZnQoY20uZG9jLnNjcm9sbExlZnQpXFxuICB9LCB0cnVlKVxcbiAgb3B0aW9uKFxcXCJsaW5lTnVtYmVyc1xcXCIsIGZhbHNlLCBmdW5jdGlvbiAoY20pIHtcXG4gICAgc2V0R3V0dGVyc0ZvckxpbmVOdW1iZXJzKGNtLm9wdGlvbnMpXFxuICAgIGd1dHRlcnNDaGFuZ2VkKGNtKVxcbiAgfSwgdHJ1ZSlcXG4gIG9wdGlvbihcXFwiZmlyc3RMaW5lTnVtYmVyXFxcIiwgMSwgZ3V0dGVyc0NoYW5nZWQsIHRydWUpXFxuICBvcHRpb24oXFxcImxpbmVOdW1iZXJGb3JtYXR0ZXJcXFwiLCBmdW5jdGlvbiAoaW50ZWdlcikgeyByZXR1cm4gaW50ZWdlcjsgfSwgZ3V0dGVyc0NoYW5nZWQsIHRydWUpXFxuICBvcHRpb24oXFxcInNob3dDdXJzb3JXaGVuU2VsZWN0aW5nXFxcIiwgZmFsc2UsIHVwZGF0ZVNlbGVjdGlvbiwgdHJ1ZSlcXG5cXG4gIG9wdGlvbihcXFwicmVzZXRTZWxlY3Rpb25PbkNvbnRleHRNZW51XFxcIiwgdHJ1ZSlcXG4gIG9wdGlvbihcXFwibGluZVdpc2VDb3B5Q3V0XFxcIiwgdHJ1ZSlcXG5cXG4gIG9wdGlvbihcXFwicmVhZE9ubHlcXFwiLCBmYWxzZSwgZnVuY3Rpb24gKGNtLCB2YWwpIHtcXG4gICAgaWYgKHZhbCA9PSBcXFwibm9jdXJzb3JcXFwiKSB7XFxuICAgICAgb25CbHVyKGNtKVxcbiAgICAgIGNtLmRpc3BsYXkuaW5wdXQuYmx1cigpXFxuICAgICAgY20uZGlzcGxheS5kaXNhYmxlZCA9IHRydWVcXG4gICAgfSBlbHNlIHtcXG4gICAgICBjbS5kaXNwbGF5LmRpc2FibGVkID0gZmFsc2VcXG4gICAgfVxcbiAgICBjbS5kaXNwbGF5LmlucHV0LnJlYWRPbmx5Q2hhbmdlZCh2YWwpXFxuICB9KVxcbiAgb3B0aW9uKFxcXCJkaXNhYmxlSW5wdXRcXFwiLCBmYWxzZSwgZnVuY3Rpb24gKGNtLCB2YWwpIHtpZiAoIXZhbCkgeyBjbS5kaXNwbGF5LmlucHV0LnJlc2V0KCkgfX0sIHRydWUpXFxuICBvcHRpb24oXFxcImRyYWdEcm9wXFxcIiwgdHJ1ZSwgZHJhZ0Ryb3BDaGFuZ2VkKVxcbiAgb3B0aW9uKFxcXCJhbGxvd0Ryb3BGaWxlVHlwZXNcXFwiLCBudWxsKVxcblxcbiAgb3B0aW9uKFxcXCJjdXJzb3JCbGlua1JhdGVcXFwiLCA1MzApXFxuICBvcHRpb24oXFxcImN1cnNvclNjcm9sbE1hcmdpblxcXCIsIDApXFxuICBvcHRpb24oXFxcImN1cnNvckhlaWdodFxcXCIsIDEsIHVwZGF0ZVNlbGVjdGlvbiwgdHJ1ZSlcXG4gIG9wdGlvbihcXFwic2luZ2xlQ3Vyc29ySGVpZ2h0UGVyTGluZVxcXCIsIHRydWUsIHVwZGF0ZVNlbGVjdGlvbiwgdHJ1ZSlcXG4gIG9wdGlvbihcXFwid29ya1RpbWVcXFwiLCAxMDApXFxuICBvcHRpb24oXFxcIndvcmtEZWxheVxcXCIsIDEwMClcXG4gIG9wdGlvbihcXFwiZmxhdHRlblNwYW5zXFxcIiwgdHJ1ZSwgcmVzZXRNb2RlU3RhdGUsIHRydWUpXFxuICBvcHRpb24oXFxcImFkZE1vZGVDbGFzc1xcXCIsIGZhbHNlLCByZXNldE1vZGVTdGF0ZSwgdHJ1ZSlcXG4gIG9wdGlvbihcXFwicG9sbEludGVydmFsXFxcIiwgMTAwKVxcbiAgb3B0aW9uKFxcXCJ1bmRvRGVwdGhcXFwiLCAyMDAsIGZ1bmN0aW9uIChjbSwgdmFsKSB7IHJldHVybiBjbS5kb2MuaGlzdG9yeS51bmRvRGVwdGggPSB2YWw7IH0pXFxuICBvcHRpb24oXFxcImhpc3RvcnlFdmVudERlbGF5XFxcIiwgMTI1MClcXG4gIG9wdGlvbihcXFwidmlld3BvcnRNYXJnaW5cXFwiLCAxMCwgZnVuY3Rpb24gKGNtKSB7IHJldHVybiBjbS5yZWZyZXNoKCk7IH0sIHRydWUpXFxuICBvcHRpb24oXFxcIm1heEhpZ2hsaWdodExlbmd0aFxcXCIsIDEwMDAwLCByZXNldE1vZGVTdGF0ZSwgdHJ1ZSlcXG4gIG9wdGlvbihcXFwibW92ZUlucHV0V2l0aEN1cnNvclxcXCIsIHRydWUsIGZ1bmN0aW9uIChjbSwgdmFsKSB7XFxuICAgIGlmICghdmFsKSB7IGNtLmRpc3BsYXkuaW5wdXQucmVzZXRQb3NpdGlvbigpIH1cXG4gIH0pXFxuXFxuICBvcHRpb24oXFxcInRhYmluZGV4XFxcIiwgbnVsbCwgZnVuY3Rpb24gKGNtLCB2YWwpIHsgcmV0dXJuIGNtLmRpc3BsYXkuaW5wdXQuZ2V0RmllbGQoKS50YWJJbmRleCA9IHZhbCB8fCBcXFwiXFxcIjsgfSlcXG4gIG9wdGlvbihcXFwiYXV0b2ZvY3VzXFxcIiwgbnVsbClcXG59XFxuXFxuZnVuY3Rpb24gZ3V0dGVyc0NoYW5nZWQoY20pIHtcXG4gIHVwZGF0ZUd1dHRlcnMoY20pXFxuICByZWdDaGFuZ2UoY20pXFxuICBhbGlnbkhvcml6b250YWxseShjbSlcXG59XFxuXFxuZnVuY3Rpb24gZHJhZ0Ryb3BDaGFuZ2VkKGNtLCB2YWx1ZSwgb2xkKSB7XFxuICB2YXIgd2FzT24gPSBvbGQgJiYgb2xkICE9IEluaXRcXG4gIGlmICghdmFsdWUgIT0gIXdhc09uKSB7XFxuICAgIHZhciBmdW5jcyA9IGNtLmRpc3BsYXkuZHJhZ0Z1bmN0aW9uc1xcbiAgICB2YXIgdG9nZ2xlID0gdmFsdWUgPyBvbiA6IG9mZlxcbiAgICB0b2dnbGUoY20uZGlzcGxheS5zY3JvbGxlciwgXFxcImRyYWdzdGFydFxcXCIsIGZ1bmNzLnN0YXJ0KVxcbiAgICB0b2dnbGUoY20uZGlzcGxheS5zY3JvbGxlciwgXFxcImRyYWdlbnRlclxcXCIsIGZ1bmNzLmVudGVyKVxcbiAgICB0b2dnbGUoY20uZGlzcGxheS5zY3JvbGxlciwgXFxcImRyYWdvdmVyXFxcIiwgZnVuY3Mub3ZlcilcXG4gICAgdG9nZ2xlKGNtLmRpc3BsYXkuc2Nyb2xsZXIsIFxcXCJkcmFnbGVhdmVcXFwiLCBmdW5jcy5sZWF2ZSlcXG4gICAgdG9nZ2xlKGNtLmRpc3BsYXkuc2Nyb2xsZXIsIFxcXCJkcm9wXFxcIiwgZnVuY3MuZHJvcClcXG4gIH1cXG59XFxuXFxuZnVuY3Rpb24gd3JhcHBpbmdDaGFuZ2VkKGNtKSB7XFxuICBpZiAoY20ub3B0aW9ucy5saW5lV3JhcHBpbmcpIHtcXG4gICAgYWRkQ2xhc3MoY20uZGlzcGxheS53cmFwcGVyLCBcXFwiQ29kZU1pcnJvci13cmFwXFxcIilcXG4gICAgY20uZGlzcGxheS5zaXplci5zdHlsZS5taW5XaWR0aCA9IFxcXCJcXFwiXFxuICAgIGNtLmRpc3BsYXkuc2l6ZXJXaWR0aCA9IG51bGxcXG4gIH0gZWxzZSB7XFxuICAgIHJtQ2xhc3MoY20uZGlzcGxheS53cmFwcGVyLCBcXFwiQ29kZU1pcnJvci13cmFwXFxcIilcXG4gICAgZmluZE1heExpbmUoY20pXFxuICB9XFxuICBlc3RpbWF0ZUxpbmVIZWlnaHRzKGNtKVxcbiAgcmVnQ2hhbmdlKGNtKVxcbiAgY2xlYXJDYWNoZXMoY20pXFxuICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIHVwZGF0ZVNjcm9sbGJhcnMoY20pOyB9LCAxMDApXFxufVxcblxcbi8vIEEgQ29kZU1pcnJvciBpbnN0YW5jZSByZXByZXNlbnRzIGFuIGVkaXRvci4gVGhpcyBpcyB0aGUgb2JqZWN0XFxuLy8gdGhhdCB1c2VyIGNvZGUgaXMgdXN1YWxseSBkZWFsaW5nIHdpdGguXFxuXFxuZnVuY3Rpb24gQ29kZU1pcnJvcihwbGFjZSwgb3B0aW9ucykge1xcbiAgdmFyIHRoaXMkMSA9IHRoaXM7XFxuXFxuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgQ29kZU1pcnJvcikpIHsgcmV0dXJuIG5ldyBDb2RlTWlycm9yKHBsYWNlLCBvcHRpb25zKSB9XFxuXFxuICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zID0gb3B0aW9ucyA/IGNvcHlPYmoob3B0aW9ucykgOiB7fVxcbiAgLy8gRGV0ZXJtaW5lIGVmZmVjdGl2ZSBvcHRpb25zIGJhc2VkIG9uIGdpdmVuIHZhbHVlcyBhbmQgZGVmYXVsdHMuXFxuICBjb3B5T2JqKGRlZmF1bHRzLCBvcHRpb25zLCBmYWxzZSlcXG4gIHNldEd1dHRlcnNGb3JMaW5lTnVtYmVycyhvcHRpb25zKVxcblxcbiAgdmFyIGRvYyA9IG9wdGlvbnMudmFsdWVcXG4gIGlmICh0eXBlb2YgZG9jID09IFxcXCJzdHJpbmdcXFwiKSB7IGRvYyA9IG5ldyBEb2MoZG9jLCBvcHRpb25zLm1vZGUsIG51bGwsIG9wdGlvbnMubGluZVNlcGFyYXRvcikgfVxcbiAgdGhpcy5kb2MgPSBkb2NcXG5cXG4gIHZhciBpbnB1dCA9IG5ldyBDb2RlTWlycm9yLmlucHV0U3R5bGVzW29wdGlvbnMuaW5wdXRTdHlsZV0odGhpcylcXG4gIHZhciBkaXNwbGF5ID0gdGhpcy5kaXNwbGF5ID0gbmV3IERpc3BsYXkocGxhY2UsIGRvYywgaW5wdXQpXFxuICBkaXNwbGF5LndyYXBwZXIuQ29kZU1pcnJvciA9IHRoaXNcXG4gIHVwZGF0ZUd1dHRlcnModGhpcylcXG4gIHRoZW1lQ2hhbmdlZCh0aGlzKVxcbiAgaWYgKG9wdGlvbnMubGluZVdyYXBwaW5nKVxcbiAgICB7IHRoaXMuZGlzcGxheS53cmFwcGVyLmNsYXNzTmFtZSArPSBcXFwiIENvZGVNaXJyb3Itd3JhcFxcXCIgfVxcbiAgaW5pdFNjcm9sbGJhcnModGhpcylcXG5cXG4gIHRoaXMuc3RhdGUgPSB7XFxuICAgIGtleU1hcHM6IFtdLCAgLy8gc3RvcmVzIG1hcHMgYWRkZWQgYnkgYWRkS2V5TWFwXFxuICAgIG92ZXJsYXlzOiBbXSwgLy8gaGlnaGxpZ2h0aW5nIG92ZXJsYXlzLCBhcyBhZGRlZCBieSBhZGRPdmVybGF5XFxuICAgIG1vZGVHZW46IDAsICAgLy8gYnVtcGVkIHdoZW4gbW9kZS9vdmVybGF5IGNoYW5nZXMsIHVzZWQgdG8gaW52YWxpZGF0ZSBoaWdobGlnaHRpbmcgaW5mb1xcbiAgICBvdmVyd3JpdGU6IGZhbHNlLFxcbiAgICBkZWxheWluZ0JsdXJFdmVudDogZmFsc2UsXFxuICAgIGZvY3VzZWQ6IGZhbHNlLFxcbiAgICBzdXBwcmVzc0VkaXRzOiBmYWxzZSwgLy8gdXNlZCB0byBkaXNhYmxlIGVkaXRpbmcgZHVyaW5nIGtleSBoYW5kbGVycyB3aGVuIGluIHJlYWRPbmx5IG1vZGVcXG4gICAgcGFzdGVJbmNvbWluZzogZmFsc2UsIGN1dEluY29taW5nOiBmYWxzZSwgLy8gaGVscCByZWNvZ25pemUgcGFzdGUvY3V0IGVkaXRzIGluIGlucHV0LnBvbGxcXG4gICAgc2VsZWN0aW5nVGV4dDogZmFsc2UsXFxuICAgIGRyYWdnaW5nVGV4dDogZmFsc2UsXFxuICAgIGhpZ2hsaWdodDogbmV3IERlbGF5ZWQoKSwgLy8gc3RvcmVzIGhpZ2hsaWdodCB3b3JrZXIgdGltZW91dFxcbiAgICBrZXlTZXE6IG51bGwsICAvLyBVbmZpbmlzaGVkIGtleSBzZXF1ZW5jZVxcbiAgICBzcGVjaWFsQ2hhcnM6IG51bGxcXG4gIH1cXG5cXG4gIGlmIChvcHRpb25zLmF1dG9mb2N1cyAmJiAhbW9iaWxlKSB7IGRpc3BsYXkuaW5wdXQuZm9jdXMoKSB9XFxuXFxuICAvLyBPdmVycmlkZSBtYWdpYyB0ZXh0YXJlYSBjb250ZW50IHJlc3RvcmUgdGhhdCBJRSBzb21ldGltZXMgZG9lc1xcbiAgLy8gb24gb3VyIGhpZGRlbiB0ZXh0YXJlYSBvbiByZWxvYWRcXG4gIGlmIChpZSAmJiBpZV92ZXJzaW9uIDwgMTEpIHsgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzJDEuZGlzcGxheS5pbnB1dC5yZXNldCh0cnVlKTsgfSwgMjApIH1cXG5cXG4gIHJlZ2lzdGVyRXZlbnRIYW5kbGVycyh0aGlzKVxcbiAgZW5zdXJlR2xvYmFsSGFuZGxlcnMoKVxcblxcbiAgc3RhcnRPcGVyYXRpb24odGhpcylcXG4gIHRoaXMuY3VyT3AuZm9yY2VVcGRhdGUgPSB0cnVlXFxuICBhdHRhY2hEb2ModGhpcywgZG9jKVxcblxcbiAgaWYgKChvcHRpb25zLmF1dG9mb2N1cyAmJiAhbW9iaWxlKSB8fCB0aGlzLmhhc0ZvY3VzKCkpXFxuICAgIHsgc2V0VGltZW91dChiaW5kKG9uRm9jdXMsIHRoaXMpLCAyMCkgfVxcbiAgZWxzZVxcbiAgICB7IG9uQmx1cih0aGlzKSB9XFxuXFxuICBmb3IgKHZhciBvcHQgaW4gb3B0aW9uSGFuZGxlcnMpIHsgaWYgKG9wdGlvbkhhbmRsZXJzLmhhc093blByb3BlcnR5KG9wdCkpXFxuICAgIHsgb3B0aW9uSGFuZGxlcnNbb3B0XSh0aGlzJDEsIG9wdGlvbnNbb3B0XSwgSW5pdCkgfSB9XFxuICBtYXliZVVwZGF0ZUxpbmVOdW1iZXJXaWR0aCh0aGlzKVxcbiAgaWYgKG9wdGlvbnMuZmluaXNoSW5pdCkgeyBvcHRpb25zLmZpbmlzaEluaXQodGhpcykgfVxcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbml0SG9va3MubGVuZ3RoOyArK2kpIHsgaW5pdEhvb2tzW2ldKHRoaXMkMSkgfVxcbiAgZW5kT3BlcmF0aW9uKHRoaXMpXFxuICAvLyBTdXBwcmVzcyBvcHRpbWl6ZWxlZ2liaWxpdHkgaW4gV2Via2l0LCBzaW5jZSBpdCBicmVha3MgdGV4dFxcbiAgLy8gbWVhc3VyaW5nIG9uIGxpbmUgd3JhcHBpbmcgYm91bmRhcmllcy5cXG4gIGlmICh3ZWJraXQgJiYgb3B0aW9ucy5saW5lV3JhcHBpbmcgJiZcXG4gICAgICBnZXRDb21wdXRlZFN0eWxlKGRpc3BsYXkubGluZURpdikudGV4dFJlbmRlcmluZyA9PSBcXFwib3B0aW1pemVsZWdpYmlsaXR5XFxcIilcXG4gICAgeyBkaXNwbGF5LmxpbmVEaXYuc3R5bGUudGV4dFJlbmRlcmluZyA9IFxcXCJhdXRvXFxcIiB9XFxufVxcblxcbi8vIFRoZSBkZWZhdWx0IGNvbmZpZ3VyYXRpb24gb3B0aW9ucy5cXG5Db2RlTWlycm9yLmRlZmF1bHRzID0gZGVmYXVsdHNcXG4vLyBGdW5jdGlvbnMgdG8gcnVuIHdoZW4gb3B0aW9ucyBhcmUgY2hhbmdlZC5cXG5Db2RlTWlycm9yLm9wdGlvbkhhbmRsZXJzID0gb3B0aW9uSGFuZGxlcnNcXG5cXG4vLyBBdHRhY2ggdGhlIG5lY2Vzc2FyeSBldmVudCBoYW5kbGVycyB3aGVuIGluaXRpYWxpemluZyB0aGUgZWRpdG9yXFxuZnVuY3Rpb24gcmVnaXN0ZXJFdmVudEhhbmRsZXJzKGNtKSB7XFxuICB2YXIgZCA9IGNtLmRpc3BsYXlcXG4gIG9uKGQuc2Nyb2xsZXIsIFxcXCJtb3VzZWRvd25cXFwiLCBvcGVyYXRpb24oY20sIG9uTW91c2VEb3duKSlcXG4gIC8vIE9sZGVyIElFJ3Mgd2lsbCBub3QgZmlyZSBhIHNlY29uZCBtb3VzZWRvd24gZm9yIGEgZG91YmxlIGNsaWNrXFxuICBpZiAoaWUgJiYgaWVfdmVyc2lvbiA8IDExKVxcbiAgICB7IG9uKGQuc2Nyb2xsZXIsIFxcXCJkYmxjbGlja1xcXCIsIG9wZXJhdGlvbihjbSwgZnVuY3Rpb24gKGUpIHtcXG4gICAgICBpZiAoc2lnbmFsRE9NRXZlbnQoY20sIGUpKSB7IHJldHVybiB9XFxuICAgICAgdmFyIHBvcyA9IHBvc0Zyb21Nb3VzZShjbSwgZSlcXG4gICAgICBpZiAoIXBvcyB8fCBjbGlja0luR3V0dGVyKGNtLCBlKSB8fCBldmVudEluV2lkZ2V0KGNtLmRpc3BsYXksIGUpKSB7IHJldHVybiB9XFxuICAgICAgZV9wcmV2ZW50RGVmYXVsdChlKVxcbiAgICAgIHZhciB3b3JkID0gY20uZmluZFdvcmRBdChwb3MpXFxuICAgICAgZXh0ZW5kU2VsZWN0aW9uKGNtLmRvYywgd29yZC5hbmNob3IsIHdvcmQuaGVhZClcXG4gICAgfSkpIH1cXG4gIGVsc2VcXG4gICAgeyBvbihkLnNjcm9sbGVyLCBcXFwiZGJsY2xpY2tcXFwiLCBmdW5jdGlvbiAoZSkgeyByZXR1cm4gc2lnbmFsRE9NRXZlbnQoY20sIGUpIHx8IGVfcHJldmVudERlZmF1bHQoZSk7IH0pIH1cXG4gIC8vIFNvbWUgYnJvd3NlcnMgZmlyZSBjb250ZXh0bWVudSAqYWZ0ZXIqIG9wZW5pbmcgdGhlIG1lbnUsIGF0XFxuICAvLyB3aGljaCBwb2ludCB3ZSBjYW4ndCBtZXNzIHdpdGggaXQgYW55bW9yZS4gQ29udGV4dCBtZW51IGlzXFxuICAvLyBoYW5kbGVkIGluIG9uTW91c2VEb3duIGZvciB0aGVzZSBicm93c2Vycy5cXG4gIGlmICghY2FwdHVyZVJpZ2h0Q2xpY2spIHsgb24oZC5zY3JvbGxlciwgXFxcImNvbnRleHRtZW51XFxcIiwgZnVuY3Rpb24gKGUpIHsgcmV0dXJuIG9uQ29udGV4dE1lbnUoY20sIGUpOyB9KSB9XFxuXFxuICAvLyBVc2VkIHRvIHN1cHByZXNzIG1vdXNlIGV2ZW50IGhhbmRsaW5nIHdoZW4gYSB0b3VjaCBoYXBwZW5zXFxuICB2YXIgdG91Y2hGaW5pc2hlZCwgcHJldlRvdWNoID0ge2VuZDogMH1cXG4gIGZ1bmN0aW9uIGZpbmlzaFRvdWNoKCkge1xcbiAgICBpZiAoZC5hY3RpdmVUb3VjaCkge1xcbiAgICAgIHRvdWNoRmluaXNoZWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIGQuYWN0aXZlVG91Y2ggPSBudWxsOyB9LCAxMDAwKVxcbiAgICAgIHByZXZUb3VjaCA9IGQuYWN0aXZlVG91Y2hcXG4gICAgICBwcmV2VG91Y2guZW5kID0gK25ldyBEYXRlXFxuICAgIH1cXG4gIH1cXG4gIGZ1bmN0aW9uIGlzTW91c2VMaWtlVG91Y2hFdmVudChlKSB7XFxuICAgIGlmIChlLnRvdWNoZXMubGVuZ3RoICE9IDEpIHsgcmV0dXJuIGZhbHNlIH1cXG4gICAgdmFyIHRvdWNoID0gZS50b3VjaGVzWzBdXFxuICAgIHJldHVybiB0b3VjaC5yYWRpdXNYIDw9IDEgJiYgdG91Y2gucmFkaXVzWSA8PSAxXFxuICB9XFxuICBmdW5jdGlvbiBmYXJBd2F5KHRvdWNoLCBvdGhlcikge1xcbiAgICBpZiAob3RoZXIubGVmdCA9PSBudWxsKSB7IHJldHVybiB0cnVlIH1cXG4gICAgdmFyIGR4ID0gb3RoZXIubGVmdCAtIHRvdWNoLmxlZnQsIGR5ID0gb3RoZXIudG9wIC0gdG91Y2gudG9wXFxuICAgIHJldHVybiBkeCAqIGR4ICsgZHkgKiBkeSA+IDIwICogMjBcXG4gIH1cXG4gIG9uKGQuc2Nyb2xsZXIsIFxcXCJ0b3VjaHN0YXJ0XFxcIiwgZnVuY3Rpb24gKGUpIHtcXG4gICAgaWYgKCFzaWduYWxET01FdmVudChjbSwgZSkgJiYgIWlzTW91c2VMaWtlVG91Y2hFdmVudChlKSkge1xcbiAgICAgIGQuaW5wdXQuZW5zdXJlUG9sbGVkKClcXG4gICAgICBjbGVhclRpbWVvdXQodG91Y2hGaW5pc2hlZClcXG4gICAgICB2YXIgbm93ID0gK25ldyBEYXRlXFxuICAgICAgZC5hY3RpdmVUb3VjaCA9IHtzdGFydDogbm93LCBtb3ZlZDogZmFsc2UsXFxuICAgICAgICAgICAgICAgICAgICAgICBwcmV2OiBub3cgLSBwcmV2VG91Y2guZW5kIDw9IDMwMCA/IHByZXZUb3VjaCA6IG51bGx9XFxuICAgICAgaWYgKGUudG91Y2hlcy5sZW5ndGggPT0gMSkge1xcbiAgICAgICAgZC5hY3RpdmVUb3VjaC5sZWZ0ID0gZS50b3VjaGVzWzBdLnBhZ2VYXFxuICAgICAgICBkLmFjdGl2ZVRvdWNoLnRvcCA9IGUudG91Y2hlc1swXS5wYWdlWVxcbiAgICAgIH1cXG4gICAgfVxcbiAgfSlcXG4gIG9uKGQuc2Nyb2xsZXIsIFxcXCJ0b3VjaG1vdmVcXFwiLCBmdW5jdGlvbiAoKSB7XFxuICAgIGlmIChkLmFjdGl2ZVRvdWNoKSB7IGQuYWN0aXZlVG91Y2gubW92ZWQgPSB0cnVlIH1cXG4gIH0pXFxuICBvbihkLnNjcm9sbGVyLCBcXFwidG91Y2hlbmRcXFwiLCBmdW5jdGlvbiAoZSkge1xcbiAgICB2YXIgdG91Y2ggPSBkLmFjdGl2ZVRvdWNoXFxuICAgIGlmICh0b3VjaCAmJiAhZXZlbnRJbldpZGdldChkLCBlKSAmJiB0b3VjaC5sZWZ0ICE9IG51bGwgJiZcXG4gICAgICAgICF0b3VjaC5tb3ZlZCAmJiBuZXcgRGF0ZSAtIHRvdWNoLnN0YXJ0IDwgMzAwKSB7XFxuICAgICAgdmFyIHBvcyA9IGNtLmNvb3Jkc0NoYXIoZC5hY3RpdmVUb3VjaCwgXFxcInBhZ2VcXFwiKSwgcmFuZ2VcXG4gICAgICBpZiAoIXRvdWNoLnByZXYgfHwgZmFyQXdheSh0b3VjaCwgdG91Y2gucHJldikpIC8vIFNpbmdsZSB0YXBcXG4gICAgICAgIHsgcmFuZ2UgPSBuZXcgUmFuZ2UocG9zLCBwb3MpIH1cXG4gICAgICBlbHNlIGlmICghdG91Y2gucHJldi5wcmV2IHx8IGZhckF3YXkodG91Y2gsIHRvdWNoLnByZXYucHJldikpIC8vIERvdWJsZSB0YXBcXG4gICAgICAgIHsgcmFuZ2UgPSBjbS5maW5kV29yZEF0KHBvcykgfVxcbiAgICAgIGVsc2UgLy8gVHJpcGxlIHRhcFxcbiAgICAgICAgeyByYW5nZSA9IG5ldyBSYW5nZShQb3MocG9zLmxpbmUsIDApLCBjbGlwUG9zKGNtLmRvYywgUG9zKHBvcy5saW5lICsgMSwgMCkpKSB9XFxuICAgICAgY20uc2V0U2VsZWN0aW9uKHJhbmdlLmFuY2hvciwgcmFuZ2UuaGVhZClcXG4gICAgICBjbS5mb2N1cygpXFxuICAgICAgZV9wcmV2ZW50RGVmYXVsdChlKVxcbiAgICB9XFxuICAgIGZpbmlzaFRvdWNoKClcXG4gIH0pXFxuICBvbihkLnNjcm9sbGVyLCBcXFwidG91Y2hjYW5jZWxcXFwiLCBmaW5pc2hUb3VjaClcXG5cXG4gIC8vIFN5bmMgc2Nyb2xsaW5nIGJldHdlZW4gZmFrZSBzY3JvbGxiYXJzIGFuZCByZWFsIHNjcm9sbGFibGVcXG4gIC8vIGFyZWEsIGVuc3VyZSB2aWV3cG9ydCBpcyB1cGRhdGVkIHdoZW4gc2Nyb2xsaW5nLlxcbiAgb24oZC5zY3JvbGxlciwgXFxcInNjcm9sbFxcXCIsIGZ1bmN0aW9uICgpIHtcXG4gICAgaWYgKGQuc2Nyb2xsZXIuY2xpZW50SGVpZ2h0KSB7XFxuICAgICAgc2V0U2Nyb2xsVG9wKGNtLCBkLnNjcm9sbGVyLnNjcm9sbFRvcClcXG4gICAgICBzZXRTY3JvbGxMZWZ0KGNtLCBkLnNjcm9sbGVyLnNjcm9sbExlZnQsIHRydWUpXFxuICAgICAgc2lnbmFsKGNtLCBcXFwic2Nyb2xsXFxcIiwgY20pXFxuICAgIH1cXG4gIH0pXFxuXFxuICAvLyBMaXN0ZW4gdG8gd2hlZWwgZXZlbnRzIGluIG9yZGVyIHRvIHRyeSBhbmQgdXBkYXRlIHRoZSB2aWV3cG9ydCBvbiB0aW1lLlxcbiAgb24oZC5zY3JvbGxlciwgXFxcIm1vdXNld2hlZWxcXFwiLCBmdW5jdGlvbiAoZSkgeyByZXR1cm4gb25TY3JvbGxXaGVlbChjbSwgZSk7IH0pXFxuICBvbihkLnNjcm9sbGVyLCBcXFwiRE9NTW91c2VTY3JvbGxcXFwiLCBmdW5jdGlvbiAoZSkgeyByZXR1cm4gb25TY3JvbGxXaGVlbChjbSwgZSk7IH0pXFxuXFxuICAvLyBQcmV2ZW50IHdyYXBwZXIgZnJvbSBldmVyIHNjcm9sbGluZ1xcbiAgb24oZC53cmFwcGVyLCBcXFwic2Nyb2xsXFxcIiwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZC53cmFwcGVyLnNjcm9sbFRvcCA9IGQud3JhcHBlci5zY3JvbGxMZWZ0ID0gMDsgfSlcXG5cXG4gIGQuZHJhZ0Z1bmN0aW9ucyA9IHtcXG4gICAgZW50ZXI6IGZ1bmN0aW9uIChlKSB7aWYgKCFzaWduYWxET01FdmVudChjbSwgZSkpIHsgZV9zdG9wKGUpIH19LFxcbiAgICBvdmVyOiBmdW5jdGlvbiAoZSkge2lmICghc2lnbmFsRE9NRXZlbnQoY20sIGUpKSB7IG9uRHJhZ092ZXIoY20sIGUpOyBlX3N0b3AoZSkgfX0sXFxuICAgIHN0YXJ0OiBmdW5jdGlvbiAoZSkgeyByZXR1cm4gb25EcmFnU3RhcnQoY20sIGUpOyB9LFxcbiAgICBkcm9wOiBvcGVyYXRpb24oY20sIG9uRHJvcCksXFxuICAgIGxlYXZlOiBmdW5jdGlvbiAoZSkge2lmICghc2lnbmFsRE9NRXZlbnQoY20sIGUpKSB7IGNsZWFyRHJhZ0N1cnNvcihjbSkgfX1cXG4gIH1cXG5cXG4gIHZhciBpbnAgPSBkLmlucHV0LmdldEZpZWxkKClcXG4gIG9uKGlucCwgXFxcImtleXVwXFxcIiwgZnVuY3Rpb24gKGUpIHsgcmV0dXJuIG9uS2V5VXAuY2FsbChjbSwgZSk7IH0pXFxuICBvbihpbnAsIFxcXCJrZXlkb3duXFxcIiwgb3BlcmF0aW9uKGNtLCBvbktleURvd24pKVxcbiAgb24oaW5wLCBcXFwia2V5cHJlc3NcXFwiLCBvcGVyYXRpb24oY20sIG9uS2V5UHJlc3MpKVxcbiAgb24oaW5wLCBcXFwiZm9jdXNcXFwiLCBmdW5jdGlvbiAoZSkgeyByZXR1cm4gb25Gb2N1cyhjbSwgZSk7IH0pXFxuICBvbihpbnAsIFxcXCJibHVyXFxcIiwgZnVuY3Rpb24gKGUpIHsgcmV0dXJuIG9uQmx1cihjbSwgZSk7IH0pXFxufVxcblxcbnZhciBpbml0SG9va3MgPSBbXVxcbkNvZGVNaXJyb3IuZGVmaW5lSW5pdEhvb2sgPSBmdW5jdGlvbiAoZikgeyByZXR1cm4gaW5pdEhvb2tzLnB1c2goZik7IH1cXG5cXG4vLyBJbmRlbnQgdGhlIGdpdmVuIGxpbmUuIFRoZSBob3cgcGFyYW1ldGVyIGNhbiBiZSBcXFwic21hcnRcXFwiLFxcbi8vIFxcXCJhZGRcXFwiL251bGwsIFxcXCJzdWJ0cmFjdFxcXCIsIG9yIFxcXCJwcmV2XFxcIi4gV2hlbiBhZ2dyZXNzaXZlIGlzIGZhbHNlXFxuLy8gKHR5cGljYWxseSBzZXQgdG8gdHJ1ZSBmb3IgZm9yY2VkIHNpbmdsZS1saW5lIGluZGVudHMpLCBlbXB0eVxcbi8vIGxpbmVzIGFyZSBub3QgaW5kZW50ZWQsIGFuZCBwbGFjZXMgd2hlcmUgdGhlIG1vZGUgcmV0dXJucyBQYXNzXFxuLy8gYXJlIGxlZnQgYWxvbmUuXFxuZnVuY3Rpb24gaW5kZW50TGluZShjbSwgbiwgaG93LCBhZ2dyZXNzaXZlKSB7XFxuICB2YXIgZG9jID0gY20uZG9jLCBzdGF0ZVxcbiAgaWYgKGhvdyA9PSBudWxsKSB7IGhvdyA9IFxcXCJhZGRcXFwiIH1cXG4gIGlmIChob3cgPT0gXFxcInNtYXJ0XFxcIikge1xcbiAgICAvLyBGYWxsIGJhY2sgdG8gXFxcInByZXZcXFwiIHdoZW4gdGhlIG1vZGUgZG9lc24ndCBoYXZlIGFuIGluZGVudGF0aW9uXFxuICAgIC8vIG1ldGhvZC5cXG4gICAgaWYgKCFkb2MubW9kZS5pbmRlbnQpIHsgaG93ID0gXFxcInByZXZcXFwiIH1cXG4gICAgZWxzZSB7IHN0YXRlID0gZ2V0U3RhdGVCZWZvcmUoY20sIG4pIH1cXG4gIH1cXG5cXG4gIHZhciB0YWJTaXplID0gY20ub3B0aW9ucy50YWJTaXplXFxuICB2YXIgbGluZSA9IGdldExpbmUoZG9jLCBuKSwgY3VyU3BhY2UgPSBjb3VudENvbHVtbihsaW5lLnRleHQsIG51bGwsIHRhYlNpemUpXFxuICBpZiAobGluZS5zdGF0ZUFmdGVyKSB7IGxpbmUuc3RhdGVBZnRlciA9IG51bGwgfVxcbiAgdmFyIGN1clNwYWNlU3RyaW5nID0gbGluZS50ZXh0Lm1hdGNoKC9eXFxcXHMqLylbMF0sIGluZGVudGF0aW9uXFxuICBpZiAoIWFnZ3Jlc3NpdmUgJiYgIS9cXFxcUy8udGVzdChsaW5lLnRleHQpKSB7XFxuICAgIGluZGVudGF0aW9uID0gMFxcbiAgICBob3cgPSBcXFwibm90XFxcIlxcbiAgfSBlbHNlIGlmIChob3cgPT0gXFxcInNtYXJ0XFxcIikge1xcbiAgICBpbmRlbnRhdGlvbiA9IGRvYy5tb2RlLmluZGVudChzdGF0ZSwgbGluZS50ZXh0LnNsaWNlKGN1clNwYWNlU3RyaW5nLmxlbmd0aCksIGxpbmUudGV4dClcXG4gICAgaWYgKGluZGVudGF0aW9uID09IFBhc3MgfHwgaW5kZW50YXRpb24gPiAxNTApIHtcXG4gICAgICBpZiAoIWFnZ3Jlc3NpdmUpIHsgcmV0dXJuIH1cXG4gICAgICBob3cgPSBcXFwicHJldlxcXCJcXG4gICAgfVxcbiAgfVxcbiAgaWYgKGhvdyA9PSBcXFwicHJldlxcXCIpIHtcXG4gICAgaWYgKG4gPiBkb2MuZmlyc3QpIHsgaW5kZW50YXRpb24gPSBjb3VudENvbHVtbihnZXRMaW5lKGRvYywgbi0xKS50ZXh0LCBudWxsLCB0YWJTaXplKSB9XFxuICAgIGVsc2UgeyBpbmRlbnRhdGlvbiA9IDAgfVxcbiAgfSBlbHNlIGlmIChob3cgPT0gXFxcImFkZFxcXCIpIHtcXG4gICAgaW5kZW50YXRpb24gPSBjdXJTcGFjZSArIGNtLm9wdGlvbnMuaW5kZW50VW5pdFxcbiAgfSBlbHNlIGlmIChob3cgPT0gXFxcInN1YnRyYWN0XFxcIikge1xcbiAgICBpbmRlbnRhdGlvbiA9IGN1clNwYWNlIC0gY20ub3B0aW9ucy5pbmRlbnRVbml0XFxuICB9IGVsc2UgaWYgKHR5cGVvZiBob3cgPT0gXFxcIm51bWJlclxcXCIpIHtcXG4gICAgaW5kZW50YXRpb24gPSBjdXJTcGFjZSArIGhvd1xcbiAgfVxcbiAgaW5kZW50YXRpb24gPSBNYXRoLm1heCgwLCBpbmRlbnRhdGlvbilcXG5cXG4gIHZhciBpbmRlbnRTdHJpbmcgPSBcXFwiXFxcIiwgcG9zID0gMFxcbiAgaWYgKGNtLm9wdGlvbnMuaW5kZW50V2l0aFRhYnMpXFxuICAgIHsgZm9yICh2YXIgaSA9IE1hdGguZmxvb3IoaW5kZW50YXRpb24gLyB0YWJTaXplKTsgaTsgLS1pKSB7cG9zICs9IHRhYlNpemU7IGluZGVudFN0cmluZyArPSBcXFwiXFxcXHRcXFwifSB9XFxuICBpZiAocG9zIDwgaW5kZW50YXRpb24pIHsgaW5kZW50U3RyaW5nICs9IHNwYWNlU3RyKGluZGVudGF0aW9uIC0gcG9zKSB9XFxuXFxuICBpZiAoaW5kZW50U3RyaW5nICE9IGN1clNwYWNlU3RyaW5nKSB7XFxuICAgIHJlcGxhY2VSYW5nZShkb2MsIGluZGVudFN0cmluZywgUG9zKG4sIDApLCBQb3MobiwgY3VyU3BhY2VTdHJpbmcubGVuZ3RoKSwgXFxcIitpbnB1dFxcXCIpXFxuICAgIGxpbmUuc3RhdGVBZnRlciA9IG51bGxcXG4gICAgcmV0dXJuIHRydWVcXG4gIH0gZWxzZSB7XFxuICAgIC8vIEVuc3VyZSB0aGF0LCBpZiB0aGUgY3Vyc29yIHdhcyBpbiB0aGUgd2hpdGVzcGFjZSBhdCB0aGUgc3RhcnRcXG4gICAgLy8gb2YgdGhlIGxpbmUsIGl0IGlzIG1vdmVkIHRvIHRoZSBlbmQgb2YgdGhhdCBzcGFjZS5cXG4gICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgZG9jLnNlbC5yYW5nZXMubGVuZ3RoOyBpJDErKykge1xcbiAgICAgIHZhciByYW5nZSA9IGRvYy5zZWwucmFuZ2VzW2kkMV1cXG4gICAgICBpZiAocmFuZ2UuaGVhZC5saW5lID09IG4gJiYgcmFuZ2UuaGVhZC5jaCA8IGN1clNwYWNlU3RyaW5nLmxlbmd0aCkge1xcbiAgICAgICAgdmFyIHBvcyQxID0gUG9zKG4sIGN1clNwYWNlU3RyaW5nLmxlbmd0aClcXG4gICAgICAgIHJlcGxhY2VPbmVTZWxlY3Rpb24oZG9jLCBpJDEsIG5ldyBSYW5nZShwb3MkMSwgcG9zJDEpKVxcbiAgICAgICAgYnJlYWtcXG4gICAgICB9XFxuICAgIH1cXG4gIH1cXG59XFxuXFxuLy8gVGhpcyB3aWxsIGJlIHNldCB0byBhIHtsaW5lV2lzZTogYm9vbCwgdGV4dDogW3N0cmluZ119IG9iamVjdCwgc29cXG4vLyB0aGF0LCB3aGVuIHBhc3RpbmcsIHdlIGtub3cgd2hhdCBraW5kIG9mIHNlbGVjdGlvbnMgdGhlIGNvcGllZFxcbi8vIHRleHQgd2FzIG1hZGUgb3V0IG9mLlxcbnZhciBsYXN0Q29waWVkID0gbnVsbFxcblxcbmZ1bmN0aW9uIHNldExhc3RDb3BpZWQobmV3TGFzdENvcGllZCkge1xcbiAgbGFzdENvcGllZCA9IG5ld0xhc3RDb3BpZWRcXG59XFxuXFxuZnVuY3Rpb24gYXBwbHlUZXh0SW5wdXQoY20sIGluc2VydGVkLCBkZWxldGVkLCBzZWwsIG9yaWdpbikge1xcbiAgdmFyIGRvYyA9IGNtLmRvY1xcbiAgY20uZGlzcGxheS5zaGlmdCA9IGZhbHNlXFxuICBpZiAoIXNlbCkgeyBzZWwgPSBkb2Muc2VsIH1cXG5cXG4gIHZhciBwYXN0ZSA9IGNtLnN0YXRlLnBhc3RlSW5jb21pbmcgfHwgb3JpZ2luID09IFxcXCJwYXN0ZVxcXCJcXG4gIHZhciB0ZXh0TGluZXMgPSBzcGxpdExpbmVzQXV0byhpbnNlcnRlZCksIG11bHRpUGFzdGUgPSBudWxsXFxuICAvLyBXaGVuIHBhc2luZyBOIGxpbmVzIGludG8gTiBzZWxlY3Rpb25zLCBpbnNlcnQgb25lIGxpbmUgcGVyIHNlbGVjdGlvblxcbiAgaWYgKHBhc3RlICYmIHNlbC5yYW5nZXMubGVuZ3RoID4gMSkge1xcbiAgICBpZiAobGFzdENvcGllZCAmJiBsYXN0Q29waWVkLnRleHQuam9pbihcXFwiXFxcXG5cXFwiKSA9PSBpbnNlcnRlZCkge1xcbiAgICAgIGlmIChzZWwucmFuZ2VzLmxlbmd0aCAlIGxhc3RDb3BpZWQudGV4dC5sZW5ndGggPT0gMCkge1xcbiAgICAgICAgbXVsdGlQYXN0ZSA9IFtdXFxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxhc3RDb3BpZWQudGV4dC5sZW5ndGg7IGkrKylcXG4gICAgICAgICAgeyBtdWx0aVBhc3RlLnB1c2goZG9jLnNwbGl0TGluZXMobGFzdENvcGllZC50ZXh0W2ldKSkgfVxcbiAgICAgIH1cXG4gICAgfSBlbHNlIGlmICh0ZXh0TGluZXMubGVuZ3RoID09IHNlbC5yYW5nZXMubGVuZ3RoKSB7XFxuICAgICAgbXVsdGlQYXN0ZSA9IG1hcCh0ZXh0TGluZXMsIGZ1bmN0aW9uIChsKSB7IHJldHVybiBbbF07IH0pXFxuICAgIH1cXG4gIH1cXG5cXG4gIHZhciB1cGRhdGVJbnB1dFxcbiAgLy8gTm9ybWFsIGJlaGF2aW9yIGlzIHRvIGluc2VydCB0aGUgbmV3IHRleHQgaW50byBldmVyeSBzZWxlY3Rpb25cXG4gIGZvciAodmFyIGkkMSA9IHNlbC5yYW5nZXMubGVuZ3RoIC0gMTsgaSQxID49IDA7IGkkMS0tKSB7XFxuICAgIHZhciByYW5nZSA9IHNlbC5yYW5nZXNbaSQxXVxcbiAgICB2YXIgZnJvbSA9IHJhbmdlLmZyb20oKSwgdG8gPSByYW5nZS50bygpXFxuICAgIGlmIChyYW5nZS5lbXB0eSgpKSB7XFxuICAgICAgaWYgKGRlbGV0ZWQgJiYgZGVsZXRlZCA+IDApIC8vIEhhbmRsZSBkZWxldGlvblxcbiAgICAgICAgeyBmcm9tID0gUG9zKGZyb20ubGluZSwgZnJvbS5jaCAtIGRlbGV0ZWQpIH1cXG4gICAgICBlbHNlIGlmIChjbS5zdGF0ZS5vdmVyd3JpdGUgJiYgIXBhc3RlKSAvLyBIYW5kbGUgb3ZlcndyaXRlXFxuICAgICAgICB7IHRvID0gUG9zKHRvLmxpbmUsIE1hdGgubWluKGdldExpbmUoZG9jLCB0by5saW5lKS50ZXh0Lmxlbmd0aCwgdG8uY2ggKyBsc3QodGV4dExpbmVzKS5sZW5ndGgpKSB9XFxuICAgICAgZWxzZSBpZiAobGFzdENvcGllZCAmJiBsYXN0Q29waWVkLmxpbmVXaXNlICYmIGxhc3RDb3BpZWQudGV4dC5qb2luKFxcXCJcXFxcblxcXCIpID09IGluc2VydGVkKVxcbiAgICAgICAgeyBmcm9tID0gdG8gPSBQb3MoZnJvbS5saW5lLCAwKSB9XFxuICAgIH1cXG4gICAgdXBkYXRlSW5wdXQgPSBjbS5jdXJPcC51cGRhdGVJbnB1dFxcbiAgICB2YXIgY2hhbmdlRXZlbnQgPSB7ZnJvbTogZnJvbSwgdG86IHRvLCB0ZXh0OiBtdWx0aVBhc3RlID8gbXVsdGlQYXN0ZVtpJDEgJSBtdWx0aVBhc3RlLmxlbmd0aF0gOiB0ZXh0TGluZXMsXFxuICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW46IG9yaWdpbiB8fCAocGFzdGUgPyBcXFwicGFzdGVcXFwiIDogY20uc3RhdGUuY3V0SW5jb21pbmcgPyBcXFwiY3V0XFxcIiA6IFxcXCIraW5wdXRcXFwiKX1cXG4gICAgbWFrZUNoYW5nZShjbS5kb2MsIGNoYW5nZUV2ZW50KVxcbiAgICBzaWduYWxMYXRlcihjbSwgXFxcImlucHV0UmVhZFxcXCIsIGNtLCBjaGFuZ2VFdmVudClcXG4gIH1cXG4gIGlmIChpbnNlcnRlZCAmJiAhcGFzdGUpXFxuICAgIHsgdHJpZ2dlckVsZWN0cmljKGNtLCBpbnNlcnRlZCkgfVxcblxcbiAgZW5zdXJlQ3Vyc29yVmlzaWJsZShjbSlcXG4gIGNtLmN1ck9wLnVwZGF0ZUlucHV0ID0gdXBkYXRlSW5wdXRcXG4gIGNtLmN1ck9wLnR5cGluZyA9IHRydWVcXG4gIGNtLnN0YXRlLnBhc3RlSW5jb21pbmcgPSBjbS5zdGF0ZS5jdXRJbmNvbWluZyA9IGZhbHNlXFxufVxcblxcbmZ1bmN0aW9uIGhhbmRsZVBhc3RlKGUsIGNtKSB7XFxuICB2YXIgcGFzdGVkID0gZS5jbGlwYm9hcmREYXRhICYmIGUuY2xpcGJvYXJkRGF0YS5nZXREYXRhKFxcXCJUZXh0XFxcIilcXG4gIGlmIChwYXN0ZWQpIHtcXG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpXFxuICAgIGlmICghY20uaXNSZWFkT25seSgpICYmICFjbS5vcHRpb25zLmRpc2FibGVJbnB1dClcXG4gICAgICB7IHJ1bkluT3AoY20sIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGFwcGx5VGV4dElucHV0KGNtLCBwYXN0ZWQsIDAsIG51bGwsIFxcXCJwYXN0ZVxcXCIpOyB9KSB9XFxuICAgIHJldHVybiB0cnVlXFxuICB9XFxufVxcblxcbmZ1bmN0aW9uIHRyaWdnZXJFbGVjdHJpYyhjbSwgaW5zZXJ0ZWQpIHtcXG4gIC8vIFdoZW4gYW4gJ2VsZWN0cmljJyBjaGFyYWN0ZXIgaXMgaW5zZXJ0ZWQsIGltbWVkaWF0ZWx5IHRyaWdnZXIgYSByZWluZGVudFxcbiAgaWYgKCFjbS5vcHRpb25zLmVsZWN0cmljQ2hhcnMgfHwgIWNtLm9wdGlvbnMuc21hcnRJbmRlbnQpIHsgcmV0dXJuIH1cXG4gIHZhciBzZWwgPSBjbS5kb2Muc2VsXFxuXFxuICBmb3IgKHZhciBpID0gc2VsLnJhbmdlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xcbiAgICB2YXIgcmFuZ2UgPSBzZWwucmFuZ2VzW2ldXFxuICAgIGlmIChyYW5nZS5oZWFkLmNoID4gMTAwIHx8IChpICYmIHNlbC5yYW5nZXNbaSAtIDFdLmhlYWQubGluZSA9PSByYW5nZS5oZWFkLmxpbmUpKSB7IGNvbnRpbnVlIH1cXG4gICAgdmFyIG1vZGUgPSBjbS5nZXRNb2RlQXQocmFuZ2UuaGVhZClcXG4gICAgdmFyIGluZGVudGVkID0gZmFsc2VcXG4gICAgaWYgKG1vZGUuZWxlY3RyaWNDaGFycykge1xcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbW9kZS5lbGVjdHJpY0NoYXJzLmxlbmd0aDsgaisrKVxcbiAgICAgICAgeyBpZiAoaW5zZXJ0ZWQuaW5kZXhPZihtb2RlLmVsZWN0cmljQ2hhcnMuY2hhckF0KGopKSA+IC0xKSB7XFxuICAgICAgICAgIGluZGVudGVkID0gaW5kZW50TGluZShjbSwgcmFuZ2UuaGVhZC5saW5lLCBcXFwic21hcnRcXFwiKVxcbiAgICAgICAgICBicmVha1xcbiAgICAgICAgfSB9XFxuICAgIH0gZWxzZSBpZiAobW9kZS5lbGVjdHJpY0lucHV0KSB7XFxuICAgICAgaWYgKG1vZGUuZWxlY3RyaWNJbnB1dC50ZXN0KGdldExpbmUoY20uZG9jLCByYW5nZS5oZWFkLmxpbmUpLnRleHQuc2xpY2UoMCwgcmFuZ2UuaGVhZC5jaCkpKVxcbiAgICAgICAgeyBpbmRlbnRlZCA9IGluZGVudExpbmUoY20sIHJhbmdlLmhlYWQubGluZSwgXFxcInNtYXJ0XFxcIikgfVxcbiAgICB9XFxuICAgIGlmIChpbmRlbnRlZCkgeyBzaWduYWxMYXRlcihjbSwgXFxcImVsZWN0cmljSW5wdXRcXFwiLCBjbSwgcmFuZ2UuaGVhZC5saW5lKSB9XFxuICB9XFxufVxcblxcbmZ1bmN0aW9uIGNvcHlhYmxlUmFuZ2VzKGNtKSB7XFxuICB2YXIgdGV4dCA9IFtdLCByYW5nZXMgPSBbXVxcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjbS5kb2Muc2VsLnJhbmdlcy5sZW5ndGg7IGkrKykge1xcbiAgICB2YXIgbGluZSA9IGNtLmRvYy5zZWwucmFuZ2VzW2ldLmhlYWQubGluZVxcbiAgICB2YXIgbGluZVJhbmdlID0ge2FuY2hvcjogUG9zKGxpbmUsIDApLCBoZWFkOiBQb3MobGluZSArIDEsIDApfVxcbiAgICByYW5nZXMucHVzaChsaW5lUmFuZ2UpXFxuICAgIHRleHQucHVzaChjbS5nZXRSYW5nZShsaW5lUmFuZ2UuYW5jaG9yLCBsaW5lUmFuZ2UuaGVhZCkpXFxuICB9XFxuICByZXR1cm4ge3RleHQ6IHRleHQsIHJhbmdlczogcmFuZ2VzfVxcbn1cXG5cXG5mdW5jdGlvbiBkaXNhYmxlQnJvd3Nlck1hZ2ljKGZpZWxkLCBzcGVsbGNoZWNrKSB7XFxuICBmaWVsZC5zZXRBdHRyaWJ1dGUoXFxcImF1dG9jb3JyZWN0XFxcIiwgXFxcIm9mZlxcXCIpXFxuICBmaWVsZC5zZXRBdHRyaWJ1dGUoXFxcImF1dG9jYXBpdGFsaXplXFxcIiwgXFxcIm9mZlxcXCIpXFxuICBmaWVsZC5zZXRBdHRyaWJ1dGUoXFxcInNwZWxsY2hlY2tcXFwiLCAhIXNwZWxsY2hlY2spXFxufVxcblxcbmZ1bmN0aW9uIGhpZGRlblRleHRhcmVhKCkge1xcbiAgdmFyIHRlID0gZWx0KFxcXCJ0ZXh0YXJlYVxcXCIsIG51bGwsIG51bGwsIFxcXCJwb3NpdGlvbjogYWJzb2x1dGU7IGJvdHRvbTogLTFlbTsgcGFkZGluZzogMDsgd2lkdGg6IDFweDsgaGVpZ2h0OiAxZW07IG91dGxpbmU6IG5vbmVcXFwiKVxcbiAgdmFyIGRpdiA9IGVsdChcXFwiZGl2XFxcIiwgW3RlXSwgbnVsbCwgXFxcIm92ZXJmbG93OiBoaWRkZW47IHBvc2l0aW9uOiByZWxhdGl2ZTsgd2lkdGg6IDNweDsgaGVpZ2h0OiAwcHg7XFxcIilcXG4gIC8vIFRoZSB0ZXh0YXJlYSBpcyBrZXB0IHBvc2l0aW9uZWQgbmVhciB0aGUgY3Vyc29yIHRvIHByZXZlbnQgdGhlXFxuICAvLyBmYWN0IHRoYXQgaXQnbGwgYmUgc2Nyb2xsZWQgaW50byB2aWV3IG9uIGlucHV0IGZyb20gc2Nyb2xsaW5nXFxuICAvLyBvdXIgZmFrZSBjdXJzb3Igb3V0IG9mIHZpZXcuIE9uIHdlYmtpdCwgd2hlbiB3cmFwPW9mZiwgcGFzdGUgaXNcXG4gIC8vIHZlcnkgc2xvdy4gU28gbWFrZSB0aGUgYXJlYSB3aWRlIGluc3RlYWQuXFxuICBpZiAod2Via2l0KSB7IHRlLnN0eWxlLndpZHRoID0gXFxcIjEwMDBweFxcXCIgfVxcbiAgZWxzZSB7IHRlLnNldEF0dHJpYnV0ZShcXFwid3JhcFxcXCIsIFxcXCJvZmZcXFwiKSB9XFxuICAvLyBJZiBib3JkZXI6IDA7IC0tIGlPUyBmYWlscyB0byBvcGVuIGtleWJvYXJkIChpc3N1ZSAjMTI4NylcXG4gIGlmIChpb3MpIHsgdGUuc3R5bGUuYm9yZGVyID0gXFxcIjFweCBzb2xpZCBibGFja1xcXCIgfVxcbiAgZGlzYWJsZUJyb3dzZXJNYWdpYyh0ZSlcXG4gIHJldHVybiBkaXZcXG59XFxuXFxuLy8gVGhlIHB1YmxpY2x5IHZpc2libGUgQVBJLiBOb3RlIHRoYXQgbWV0aG9kT3AoZikgbWVhbnNcXG4vLyAnd3JhcCBmIGluIGFuIG9wZXJhdGlvbiwgcGVyZm9ybWVkIG9uIGl0cyBgdGhpc2AgcGFyYW1ldGVyJy5cXG5cXG4vLyBUaGlzIGlzIG5vdCB0aGUgY29tcGxldGUgc2V0IG9mIGVkaXRvciBtZXRob2RzLiBNb3N0IG9mIHRoZVxcbi8vIG1ldGhvZHMgZGVmaW5lZCBvbiB0aGUgRG9jIHR5cGUgYXJlIGFsc28gaW5qZWN0ZWQgaW50b1xcbi8vIENvZGVNaXJyb3IucHJvdG90eXBlLCBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkgYW5kXFxuLy8gY29udmVuaWVuY2UuXFxuXFxuZnVuY3Rpb24gYWRkRWRpdG9yTWV0aG9kcyhDb2RlTWlycm9yKSB7XFxuICB2YXIgb3B0aW9uSGFuZGxlcnMgPSBDb2RlTWlycm9yLm9wdGlvbkhhbmRsZXJzXFxuXFxuICB2YXIgaGVscGVycyA9IENvZGVNaXJyb3IuaGVscGVycyA9IHt9XFxuXFxuICBDb2RlTWlycm9yLnByb3RvdHlwZSA9IHtcXG4gICAgY29uc3RydWN0b3I6IENvZGVNaXJyb3IsXFxuICAgIGZvY3VzOiBmdW5jdGlvbigpe3dpbmRvdy5mb2N1cygpOyB0aGlzLmRpc3BsYXkuaW5wdXQuZm9jdXMoKX0sXFxuXFxuICAgIHNldE9wdGlvbjogZnVuY3Rpb24ob3B0aW9uLCB2YWx1ZSkge1xcbiAgICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zLCBvbGQgPSBvcHRpb25zW29wdGlvbl1cXG4gICAgICBpZiAob3B0aW9uc1tvcHRpb25dID09IHZhbHVlICYmIG9wdGlvbiAhPSBcXFwibW9kZVxcXCIpIHsgcmV0dXJuIH1cXG4gICAgICBvcHRpb25zW29wdGlvbl0gPSB2YWx1ZVxcbiAgICAgIGlmIChvcHRpb25IYW5kbGVycy5oYXNPd25Qcm9wZXJ0eShvcHRpb24pKVxcbiAgICAgICAgeyBvcGVyYXRpb24odGhpcywgb3B0aW9uSGFuZGxlcnNbb3B0aW9uXSkodGhpcywgdmFsdWUsIG9sZCkgfVxcbiAgICAgIHNpZ25hbCh0aGlzLCBcXFwib3B0aW9uQ2hhbmdlXFxcIiwgdGhpcywgb3B0aW9uKVxcbiAgICB9LFxcblxcbiAgICBnZXRPcHRpb246IGZ1bmN0aW9uKG9wdGlvbikge3JldHVybiB0aGlzLm9wdGlvbnNbb3B0aW9uXX0sXFxuICAgIGdldERvYzogZnVuY3Rpb24oKSB7cmV0dXJuIHRoaXMuZG9jfSxcXG5cXG4gICAgYWRkS2V5TWFwOiBmdW5jdGlvbihtYXAsIGJvdHRvbSkge1xcbiAgICAgIHRoaXMuc3RhdGUua2V5TWFwc1tib3R0b20gPyBcXFwicHVzaFxcXCIgOiBcXFwidW5zaGlmdFxcXCJdKGdldEtleU1hcChtYXApKVxcbiAgICB9LFxcbiAgICByZW1vdmVLZXlNYXA6IGZ1bmN0aW9uKG1hcCkge1xcbiAgICAgIHZhciBtYXBzID0gdGhpcy5zdGF0ZS5rZXlNYXBzXFxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXBzLmxlbmd0aDsgKytpKVxcbiAgICAgICAgeyBpZiAobWFwc1tpXSA9PSBtYXAgfHwgbWFwc1tpXS5uYW1lID09IG1hcCkge1xcbiAgICAgICAgICBtYXBzLnNwbGljZShpLCAxKVxcbiAgICAgICAgICByZXR1cm4gdHJ1ZVxcbiAgICAgICAgfSB9XFxuICAgIH0sXFxuXFxuICAgIGFkZE92ZXJsYXk6IG1ldGhvZE9wKGZ1bmN0aW9uKHNwZWMsIG9wdGlvbnMpIHtcXG4gICAgICB2YXIgbW9kZSA9IHNwZWMudG9rZW4gPyBzcGVjIDogQ29kZU1pcnJvci5nZXRNb2RlKHRoaXMub3B0aW9ucywgc3BlYylcXG4gICAgICBpZiAobW9kZS5zdGFydFN0YXRlKSB7IHRocm93IG5ldyBFcnJvcihcXFwiT3ZlcmxheXMgbWF5IG5vdCBiZSBzdGF0ZWZ1bC5cXFwiKSB9XFxuICAgICAgaW5zZXJ0U29ydGVkKHRoaXMuc3RhdGUub3ZlcmxheXMsXFxuICAgICAgICAgICAgICAgICAgIHttb2RlOiBtb2RlLCBtb2RlU3BlYzogc3BlYywgb3BhcXVlOiBvcHRpb25zICYmIG9wdGlvbnMub3BhcXVlLFxcbiAgICAgICAgICAgICAgICAgICAgcHJpb3JpdHk6IChvcHRpb25zICYmIG9wdGlvbnMucHJpb3JpdHkpIHx8IDB9LFxcbiAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAob3ZlcmxheSkgeyByZXR1cm4gb3ZlcmxheS5wcmlvcml0eTsgfSlcXG4gICAgICB0aGlzLnN0YXRlLm1vZGVHZW4rK1xcbiAgICAgIHJlZ0NoYW5nZSh0aGlzKVxcbiAgICB9KSxcXG4gICAgcmVtb3ZlT3ZlcmxheTogbWV0aG9kT3AoZnVuY3Rpb24oc3BlYykge1xcbiAgICAgIHZhciB0aGlzJDEgPSB0aGlzO1xcblxcbiAgICAgIHZhciBvdmVybGF5cyA9IHRoaXMuc3RhdGUub3ZlcmxheXNcXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG92ZXJsYXlzLmxlbmd0aDsgKytpKSB7XFxuICAgICAgICB2YXIgY3VyID0gb3ZlcmxheXNbaV0ubW9kZVNwZWNcXG4gICAgICAgIGlmIChjdXIgPT0gc3BlYyB8fCB0eXBlb2Ygc3BlYyA9PSBcXFwic3RyaW5nXFxcIiAmJiBjdXIubmFtZSA9PSBzcGVjKSB7XFxuICAgICAgICAgIG92ZXJsYXlzLnNwbGljZShpLCAxKVxcbiAgICAgICAgICB0aGlzJDEuc3RhdGUubW9kZUdlbisrXFxuICAgICAgICAgIHJlZ0NoYW5nZSh0aGlzJDEpXFxuICAgICAgICAgIHJldHVyblxcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgfSksXFxuXFxuICAgIGluZGVudExpbmU6IG1ldGhvZE9wKGZ1bmN0aW9uKG4sIGRpciwgYWdncmVzc2l2ZSkge1xcbiAgICAgIGlmICh0eXBlb2YgZGlyICE9IFxcXCJzdHJpbmdcXFwiICYmIHR5cGVvZiBkaXIgIT0gXFxcIm51bWJlclxcXCIpIHtcXG4gICAgICAgIGlmIChkaXIgPT0gbnVsbCkgeyBkaXIgPSB0aGlzLm9wdGlvbnMuc21hcnRJbmRlbnQgPyBcXFwic21hcnRcXFwiIDogXFxcInByZXZcXFwiIH1cXG4gICAgICAgIGVsc2UgeyBkaXIgPSBkaXIgPyBcXFwiYWRkXFxcIiA6IFxcXCJzdWJ0cmFjdFxcXCIgfVxcbiAgICAgIH1cXG4gICAgICBpZiAoaXNMaW5lKHRoaXMuZG9jLCBuKSkgeyBpbmRlbnRMaW5lKHRoaXMsIG4sIGRpciwgYWdncmVzc2l2ZSkgfVxcbiAgICB9KSxcXG4gICAgaW5kZW50U2VsZWN0aW9uOiBtZXRob2RPcChmdW5jdGlvbihob3cpIHtcXG4gICAgICB2YXIgdGhpcyQxID0gdGhpcztcXG5cXG4gICAgICB2YXIgcmFuZ2VzID0gdGhpcy5kb2Muc2VsLnJhbmdlcywgZW5kID0gLTFcXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJhbmdlcy5sZW5ndGg7IGkrKykge1xcbiAgICAgICAgdmFyIHJhbmdlID0gcmFuZ2VzW2ldXFxuICAgICAgICBpZiAoIXJhbmdlLmVtcHR5KCkpIHtcXG4gICAgICAgICAgdmFyIGZyb20gPSByYW5nZS5mcm9tKCksIHRvID0gcmFuZ2UudG8oKVxcbiAgICAgICAgICB2YXIgc3RhcnQgPSBNYXRoLm1heChlbmQsIGZyb20ubGluZSlcXG4gICAgICAgICAgZW5kID0gTWF0aC5taW4odGhpcyQxLmxhc3RMaW5lKCksIHRvLmxpbmUgLSAodG8uY2ggPyAwIDogMSkpICsgMVxcbiAgICAgICAgICBmb3IgKHZhciBqID0gc3RhcnQ7IGogPCBlbmQ7ICsrailcXG4gICAgICAgICAgICB7IGluZGVudExpbmUodGhpcyQxLCBqLCBob3cpIH1cXG4gICAgICAgICAgdmFyIG5ld1JhbmdlcyA9IHRoaXMkMS5kb2Muc2VsLnJhbmdlc1xcbiAgICAgICAgICBpZiAoZnJvbS5jaCA9PSAwICYmIHJhbmdlcy5sZW5ndGggPT0gbmV3UmFuZ2VzLmxlbmd0aCAmJiBuZXdSYW5nZXNbaV0uZnJvbSgpLmNoID4gMClcXG4gICAgICAgICAgICB7IHJlcGxhY2VPbmVTZWxlY3Rpb24odGhpcyQxLmRvYywgaSwgbmV3IFJhbmdlKGZyb20sIG5ld1Jhbmdlc1tpXS50bygpKSwgc2VsX2RvbnRTY3JvbGwpIH1cXG4gICAgICAgIH0gZWxzZSBpZiAocmFuZ2UuaGVhZC5saW5lID4gZW5kKSB7XFxuICAgICAgICAgIGluZGVudExpbmUodGhpcyQxLCByYW5nZS5oZWFkLmxpbmUsIGhvdywgdHJ1ZSlcXG4gICAgICAgICAgZW5kID0gcmFuZ2UuaGVhZC5saW5lXFxuICAgICAgICAgIGlmIChpID09IHRoaXMkMS5kb2Muc2VsLnByaW1JbmRleCkgeyBlbnN1cmVDdXJzb3JWaXNpYmxlKHRoaXMkMSkgfVxcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgfSksXFxuXFxuICAgIC8vIEZldGNoIHRoZSBwYXJzZXIgdG9rZW4gZm9yIGEgZ2l2ZW4gY2hhcmFjdGVyLiBVc2VmdWwgZm9yIGhhY2tzXFxuICAgIC8vIHRoYXQgd2FudCB0byBpbnNwZWN0IHRoZSBtb2RlIHN0YXRlIChzYXksIGZvciBjb21wbGV0aW9uKS5cXG4gICAgZ2V0VG9rZW5BdDogZnVuY3Rpb24ocG9zLCBwcmVjaXNlKSB7XFxuICAgICAgcmV0dXJuIHRha2VUb2tlbih0aGlzLCBwb3MsIHByZWNpc2UpXFxuICAgIH0sXFxuXFxuICAgIGdldExpbmVUb2tlbnM6IGZ1bmN0aW9uKGxpbmUsIHByZWNpc2UpIHtcXG4gICAgICByZXR1cm4gdGFrZVRva2VuKHRoaXMsIFBvcyhsaW5lKSwgcHJlY2lzZSwgdHJ1ZSlcXG4gICAgfSxcXG5cXG4gICAgZ2V0VG9rZW5UeXBlQXQ6IGZ1bmN0aW9uKHBvcykge1xcbiAgICAgIHBvcyA9IGNsaXBQb3ModGhpcy5kb2MsIHBvcylcXG4gICAgICB2YXIgc3R5bGVzID0gZ2V0TGluZVN0eWxlcyh0aGlzLCBnZXRMaW5lKHRoaXMuZG9jLCBwb3MubGluZSkpXFxuICAgICAgdmFyIGJlZm9yZSA9IDAsIGFmdGVyID0gKHN0eWxlcy5sZW5ndGggLSAxKSAvIDIsIGNoID0gcG9zLmNoXFxuICAgICAgdmFyIHR5cGVcXG4gICAgICBpZiAoY2ggPT0gMCkgeyB0eXBlID0gc3R5bGVzWzJdIH1cXG4gICAgICBlbHNlIHsgZm9yICg7Oykge1xcbiAgICAgICAgdmFyIG1pZCA9IChiZWZvcmUgKyBhZnRlcikgPj4gMVxcbiAgICAgICAgaWYgKChtaWQgPyBzdHlsZXNbbWlkICogMiAtIDFdIDogMCkgPj0gY2gpIHsgYWZ0ZXIgPSBtaWQgfVxcbiAgICAgICAgZWxzZSBpZiAoc3R5bGVzW21pZCAqIDIgKyAxXSA8IGNoKSB7IGJlZm9yZSA9IG1pZCArIDEgfVxcbiAgICAgICAgZWxzZSB7IHR5cGUgPSBzdHlsZXNbbWlkICogMiArIDJdOyBicmVhayB9XFxuICAgICAgfSB9XFxuICAgICAgdmFyIGN1dCA9IHR5cGUgPyB0eXBlLmluZGV4T2YoXFxcIm92ZXJsYXkgXFxcIikgOiAtMVxcbiAgICAgIHJldHVybiBjdXQgPCAwID8gdHlwZSA6IGN1dCA9PSAwID8gbnVsbCA6IHR5cGUuc2xpY2UoMCwgY3V0IC0gMSlcXG4gICAgfSxcXG5cXG4gICAgZ2V0TW9kZUF0OiBmdW5jdGlvbihwb3MpIHtcXG4gICAgICB2YXIgbW9kZSA9IHRoaXMuZG9jLm1vZGVcXG4gICAgICBpZiAoIW1vZGUuaW5uZXJNb2RlKSB7IHJldHVybiBtb2RlIH1cXG4gICAgICByZXR1cm4gQ29kZU1pcnJvci5pbm5lck1vZGUobW9kZSwgdGhpcy5nZXRUb2tlbkF0KHBvcykuc3RhdGUpLm1vZGVcXG4gICAgfSxcXG5cXG4gICAgZ2V0SGVscGVyOiBmdW5jdGlvbihwb3MsIHR5cGUpIHtcXG4gICAgICByZXR1cm4gdGhpcy5nZXRIZWxwZXJzKHBvcywgdHlwZSlbMF1cXG4gICAgfSxcXG5cXG4gICAgZ2V0SGVscGVyczogZnVuY3Rpb24ocG9zLCB0eXBlKSB7XFxuICAgICAgdmFyIHRoaXMkMSA9IHRoaXM7XFxuXFxuICAgICAgdmFyIGZvdW5kID0gW11cXG4gICAgICBpZiAoIWhlbHBlcnMuaGFzT3duUHJvcGVydHkodHlwZSkpIHsgcmV0dXJuIGZvdW5kIH1cXG4gICAgICB2YXIgaGVscCA9IGhlbHBlcnNbdHlwZV0sIG1vZGUgPSB0aGlzLmdldE1vZGVBdChwb3MpXFxuICAgICAgaWYgKHR5cGVvZiBtb2RlW3R5cGVdID09IFxcXCJzdHJpbmdcXFwiKSB7XFxuICAgICAgICBpZiAoaGVscFttb2RlW3R5cGVdXSkgeyBmb3VuZC5wdXNoKGhlbHBbbW9kZVt0eXBlXV0pIH1cXG4gICAgICB9IGVsc2UgaWYgKG1vZGVbdHlwZV0pIHtcXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbW9kZVt0eXBlXS5sZW5ndGg7IGkrKykge1xcbiAgICAgICAgICB2YXIgdmFsID0gaGVscFttb2RlW3R5cGVdW2ldXVxcbiAgICAgICAgICBpZiAodmFsKSB7IGZvdW5kLnB1c2godmFsKSB9XFxuICAgICAgICB9XFxuICAgICAgfSBlbHNlIGlmIChtb2RlLmhlbHBlclR5cGUgJiYgaGVscFttb2RlLmhlbHBlclR5cGVdKSB7XFxuICAgICAgICBmb3VuZC5wdXNoKGhlbHBbbW9kZS5oZWxwZXJUeXBlXSlcXG4gICAgICB9IGVsc2UgaWYgKGhlbHBbbW9kZS5uYW1lXSkge1xcbiAgICAgICAgZm91bmQucHVzaChoZWxwW21vZGUubmFtZV0pXFxuICAgICAgfVxcbiAgICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IGhlbHAuX2dsb2JhbC5sZW5ndGg7IGkkMSsrKSB7XFxuICAgICAgICB2YXIgY3VyID0gaGVscC5fZ2xvYmFsW2kkMV1cXG4gICAgICAgIGlmIChjdXIucHJlZChtb2RlLCB0aGlzJDEpICYmIGluZGV4T2YoZm91bmQsIGN1ci52YWwpID09IC0xKVxcbiAgICAgICAgICB7IGZvdW5kLnB1c2goY3VyLnZhbCkgfVxcbiAgICAgIH1cXG4gICAgICByZXR1cm4gZm91bmRcXG4gICAgfSxcXG5cXG4gICAgZ2V0U3RhdGVBZnRlcjogZnVuY3Rpb24obGluZSwgcHJlY2lzZSkge1xcbiAgICAgIHZhciBkb2MgPSB0aGlzLmRvY1xcbiAgICAgIGxpbmUgPSBjbGlwTGluZShkb2MsIGxpbmUgPT0gbnVsbCA/IGRvYy5maXJzdCArIGRvYy5zaXplIC0gMTogbGluZSlcXG4gICAgICByZXR1cm4gZ2V0U3RhdGVCZWZvcmUodGhpcywgbGluZSArIDEsIHByZWNpc2UpXFxuICAgIH0sXFxuXFxuICAgIGN1cnNvckNvb3JkczogZnVuY3Rpb24oc3RhcnQsIG1vZGUpIHtcXG4gICAgICB2YXIgcG9zLCByYW5nZSA9IHRoaXMuZG9jLnNlbC5wcmltYXJ5KClcXG4gICAgICBpZiAoc3RhcnQgPT0gbnVsbCkgeyBwb3MgPSByYW5nZS5oZWFkIH1cXG4gICAgICBlbHNlIGlmICh0eXBlb2Ygc3RhcnQgPT0gXFxcIm9iamVjdFxcXCIpIHsgcG9zID0gY2xpcFBvcyh0aGlzLmRvYywgc3RhcnQpIH1cXG4gICAgICBlbHNlIHsgcG9zID0gc3RhcnQgPyByYW5nZS5mcm9tKCkgOiByYW5nZS50bygpIH1cXG4gICAgICByZXR1cm4gY3Vyc29yQ29vcmRzKHRoaXMsIHBvcywgbW9kZSB8fCBcXFwicGFnZVxcXCIpXFxuICAgIH0sXFxuXFxuICAgIGNoYXJDb29yZHM6IGZ1bmN0aW9uKHBvcywgbW9kZSkge1xcbiAgICAgIHJldHVybiBjaGFyQ29vcmRzKHRoaXMsIGNsaXBQb3ModGhpcy5kb2MsIHBvcyksIG1vZGUgfHwgXFxcInBhZ2VcXFwiKVxcbiAgICB9LFxcblxcbiAgICBjb29yZHNDaGFyOiBmdW5jdGlvbihjb29yZHMsIG1vZGUpIHtcXG4gICAgICBjb29yZHMgPSBmcm9tQ29vcmRTeXN0ZW0odGhpcywgY29vcmRzLCBtb2RlIHx8IFxcXCJwYWdlXFxcIilcXG4gICAgICByZXR1cm4gY29vcmRzQ2hhcih0aGlzLCBjb29yZHMubGVmdCwgY29vcmRzLnRvcClcXG4gICAgfSxcXG5cXG4gICAgbGluZUF0SGVpZ2h0OiBmdW5jdGlvbihoZWlnaHQsIG1vZGUpIHtcXG4gICAgICBoZWlnaHQgPSBmcm9tQ29vcmRTeXN0ZW0odGhpcywge3RvcDogaGVpZ2h0LCBsZWZ0OiAwfSwgbW9kZSB8fCBcXFwicGFnZVxcXCIpLnRvcFxcbiAgICAgIHJldHVybiBsaW5lQXRIZWlnaHQodGhpcy5kb2MsIGhlaWdodCArIHRoaXMuZGlzcGxheS52aWV3T2Zmc2V0KVxcbiAgICB9LFxcbiAgICBoZWlnaHRBdExpbmU6IGZ1bmN0aW9uKGxpbmUsIG1vZGUsIGluY2x1ZGVXaWRnZXRzKSB7XFxuICAgICAgdmFyIGVuZCA9IGZhbHNlLCBsaW5lT2JqXFxuICAgICAgaWYgKHR5cGVvZiBsaW5lID09IFxcXCJudW1iZXJcXFwiKSB7XFxuICAgICAgICB2YXIgbGFzdCA9IHRoaXMuZG9jLmZpcnN0ICsgdGhpcy5kb2Muc2l6ZSAtIDFcXG4gICAgICAgIGlmIChsaW5lIDwgdGhpcy5kb2MuZmlyc3QpIHsgbGluZSA9IHRoaXMuZG9jLmZpcnN0IH1cXG4gICAgICAgIGVsc2UgaWYgKGxpbmUgPiBsYXN0KSB7IGxpbmUgPSBsYXN0OyBlbmQgPSB0cnVlIH1cXG4gICAgICAgIGxpbmVPYmogPSBnZXRMaW5lKHRoaXMuZG9jLCBsaW5lKVxcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBsaW5lT2JqID0gbGluZVxcbiAgICAgIH1cXG4gICAgICByZXR1cm4gaW50b0Nvb3JkU3lzdGVtKHRoaXMsIGxpbmVPYmosIHt0b3A6IDAsIGxlZnQ6IDB9LCBtb2RlIHx8IFxcXCJwYWdlXFxcIiwgaW5jbHVkZVdpZGdldHMgfHwgZW5kKS50b3AgK1xcbiAgICAgICAgKGVuZCA/IHRoaXMuZG9jLmhlaWdodCAtIGhlaWdodEF0TGluZShsaW5lT2JqKSA6IDApXFxuICAgIH0sXFxuXFxuICAgIGRlZmF1bHRUZXh0SGVpZ2h0OiBmdW5jdGlvbigpIHsgcmV0dXJuIHRleHRIZWlnaHQodGhpcy5kaXNwbGF5KSB9LFxcbiAgICBkZWZhdWx0Q2hhcldpZHRoOiBmdW5jdGlvbigpIHsgcmV0dXJuIGNoYXJXaWR0aCh0aGlzLmRpc3BsYXkpIH0sXFxuXFxuICAgIGdldFZpZXdwb3J0OiBmdW5jdGlvbigpIHsgcmV0dXJuIHtmcm9tOiB0aGlzLmRpc3BsYXkudmlld0Zyb20sIHRvOiB0aGlzLmRpc3BsYXkudmlld1RvfX0sXFxuXFxuICAgIGFkZFdpZGdldDogZnVuY3Rpb24ocG9zLCBub2RlLCBzY3JvbGwsIHZlcnQsIGhvcml6KSB7XFxuICAgICAgdmFyIGRpc3BsYXkgPSB0aGlzLmRpc3BsYXlcXG4gICAgICBwb3MgPSBjdXJzb3JDb29yZHModGhpcywgY2xpcFBvcyh0aGlzLmRvYywgcG9zKSlcXG4gICAgICB2YXIgdG9wID0gcG9zLmJvdHRvbSwgbGVmdCA9IHBvcy5sZWZ0XFxuICAgICAgbm9kZS5zdHlsZS5wb3NpdGlvbiA9IFxcXCJhYnNvbHV0ZVxcXCJcXG4gICAgICBub2RlLnNldEF0dHJpYnV0ZShcXFwiY20taWdub3JlLWV2ZW50c1xcXCIsIFxcXCJ0cnVlXFxcIilcXG4gICAgICB0aGlzLmRpc3BsYXkuaW5wdXQuc2V0VW5lZGl0YWJsZShub2RlKVxcbiAgICAgIGRpc3BsYXkuc2l6ZXIuYXBwZW5kQ2hpbGQobm9kZSlcXG4gICAgICBpZiAodmVydCA9PSBcXFwib3ZlclxcXCIpIHtcXG4gICAgICAgIHRvcCA9IHBvcy50b3BcXG4gICAgICB9IGVsc2UgaWYgKHZlcnQgPT0gXFxcImFib3ZlXFxcIiB8fCB2ZXJ0ID09IFxcXCJuZWFyXFxcIikge1xcbiAgICAgICAgdmFyIHZzcGFjZSA9IE1hdGgubWF4KGRpc3BsYXkud3JhcHBlci5jbGllbnRIZWlnaHQsIHRoaXMuZG9jLmhlaWdodCksXFxuICAgICAgICBoc3BhY2UgPSBNYXRoLm1heChkaXNwbGF5LnNpemVyLmNsaWVudFdpZHRoLCBkaXNwbGF5LmxpbmVTcGFjZS5jbGllbnRXaWR0aClcXG4gICAgICAgIC8vIERlZmF1bHQgdG8gcG9zaXRpb25pbmcgYWJvdmUgKGlmIHNwZWNpZmllZCBhbmQgcG9zc2libGUpOyBvdGhlcndpc2UgZGVmYXVsdCB0byBwb3NpdGlvbmluZyBiZWxvd1xcbiAgICAgICAgaWYgKCh2ZXJ0ID09ICdhYm92ZScgfHwgcG9zLmJvdHRvbSArIG5vZGUub2Zmc2V0SGVpZ2h0ID4gdnNwYWNlKSAmJiBwb3MudG9wID4gbm9kZS5vZmZzZXRIZWlnaHQpXFxuICAgICAgICAgIHsgdG9wID0gcG9zLnRvcCAtIG5vZGUub2Zmc2V0SGVpZ2h0IH1cXG4gICAgICAgIGVsc2UgaWYgKHBvcy5ib3R0b20gKyBub2RlLm9mZnNldEhlaWdodCA8PSB2c3BhY2UpXFxuICAgICAgICAgIHsgdG9wID0gcG9zLmJvdHRvbSB9XFxuICAgICAgICBpZiAobGVmdCArIG5vZGUub2Zmc2V0V2lkdGggPiBoc3BhY2UpXFxuICAgICAgICAgIHsgbGVmdCA9IGhzcGFjZSAtIG5vZGUub2Zmc2V0V2lkdGggfVxcbiAgICAgIH1cXG4gICAgICBub2RlLnN0eWxlLnRvcCA9IHRvcCArIFxcXCJweFxcXCJcXG4gICAgICBub2RlLnN0eWxlLmxlZnQgPSBub2RlLnN0eWxlLnJpZ2h0ID0gXFxcIlxcXCJcXG4gICAgICBpZiAoaG9yaXogPT0gXFxcInJpZ2h0XFxcIikge1xcbiAgICAgICAgbGVmdCA9IGRpc3BsYXkuc2l6ZXIuY2xpZW50V2lkdGggLSBub2RlLm9mZnNldFdpZHRoXFxuICAgICAgICBub2RlLnN0eWxlLnJpZ2h0ID0gXFxcIjBweFxcXCJcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgaWYgKGhvcml6ID09IFxcXCJsZWZ0XFxcIikgeyBsZWZ0ID0gMCB9XFxuICAgICAgICBlbHNlIGlmIChob3JpeiA9PSBcXFwibWlkZGxlXFxcIikgeyBsZWZ0ID0gKGRpc3BsYXkuc2l6ZXIuY2xpZW50V2lkdGggLSBub2RlLm9mZnNldFdpZHRoKSAvIDIgfVxcbiAgICAgICAgbm9kZS5zdHlsZS5sZWZ0ID0gbGVmdCArIFxcXCJweFxcXCJcXG4gICAgICB9XFxuICAgICAgaWYgKHNjcm9sbClcXG4gICAgICAgIHsgc2Nyb2xsSW50b1ZpZXcodGhpcywgbGVmdCwgdG9wLCBsZWZ0ICsgbm9kZS5vZmZzZXRXaWR0aCwgdG9wICsgbm9kZS5vZmZzZXRIZWlnaHQpIH1cXG4gICAgfSxcXG5cXG4gICAgdHJpZ2dlck9uS2V5RG93bjogbWV0aG9kT3Aob25LZXlEb3duKSxcXG4gICAgdHJpZ2dlck9uS2V5UHJlc3M6IG1ldGhvZE9wKG9uS2V5UHJlc3MpLFxcbiAgICB0cmlnZ2VyT25LZXlVcDogb25LZXlVcCxcXG5cXG4gICAgZXhlY0NvbW1hbmQ6IGZ1bmN0aW9uKGNtZCkge1xcbiAgICAgIGlmIChjb21tYW5kcy5oYXNPd25Qcm9wZXJ0eShjbWQpKVxcbiAgICAgICAgeyByZXR1cm4gY29tbWFuZHNbY21kXS5jYWxsKG51bGwsIHRoaXMpIH1cXG4gICAgfSxcXG5cXG4gICAgdHJpZ2dlckVsZWN0cmljOiBtZXRob2RPcChmdW5jdGlvbih0ZXh0KSB7IHRyaWdnZXJFbGVjdHJpYyh0aGlzLCB0ZXh0KSB9KSxcXG5cXG4gICAgZmluZFBvc0g6IGZ1bmN0aW9uKGZyb20sIGFtb3VudCwgdW5pdCwgdmlzdWFsbHkpIHtcXG4gICAgICB2YXIgdGhpcyQxID0gdGhpcztcXG5cXG4gICAgICB2YXIgZGlyID0gMVxcbiAgICAgIGlmIChhbW91bnQgPCAwKSB7IGRpciA9IC0xOyBhbW91bnQgPSAtYW1vdW50IH1cXG4gICAgICB2YXIgY3VyID0gY2xpcFBvcyh0aGlzLmRvYywgZnJvbSlcXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFtb3VudDsgKytpKSB7XFxuICAgICAgICBjdXIgPSBmaW5kUG9zSCh0aGlzJDEuZG9jLCBjdXIsIGRpciwgdW5pdCwgdmlzdWFsbHkpXFxuICAgICAgICBpZiAoY3VyLmhpdFNpZGUpIHsgYnJlYWsgfVxcbiAgICAgIH1cXG4gICAgICByZXR1cm4gY3VyXFxuICAgIH0sXFxuXFxuICAgIG1vdmVIOiBtZXRob2RPcChmdW5jdGlvbihkaXIsIHVuaXQpIHtcXG4gICAgICB2YXIgdGhpcyQxID0gdGhpcztcXG5cXG4gICAgICB0aGlzLmV4dGVuZFNlbGVjdGlvbnNCeShmdW5jdGlvbiAocmFuZ2UpIHtcXG4gICAgICAgIGlmICh0aGlzJDEuZGlzcGxheS5zaGlmdCB8fCB0aGlzJDEuZG9jLmV4dGVuZCB8fCByYW5nZS5lbXB0eSgpKVxcbiAgICAgICAgICB7IHJldHVybiBmaW5kUG9zSCh0aGlzJDEuZG9jLCByYW5nZS5oZWFkLCBkaXIsIHVuaXQsIHRoaXMkMS5vcHRpb25zLnJ0bE1vdmVWaXN1YWxseSkgfVxcbiAgICAgICAgZWxzZVxcbiAgICAgICAgICB7IHJldHVybiBkaXIgPCAwID8gcmFuZ2UuZnJvbSgpIDogcmFuZ2UudG8oKSB9XFxuICAgICAgfSwgc2VsX21vdmUpXFxuICAgIH0pLFxcblxcbiAgICBkZWxldGVIOiBtZXRob2RPcChmdW5jdGlvbihkaXIsIHVuaXQpIHtcXG4gICAgICB2YXIgc2VsID0gdGhpcy5kb2Muc2VsLCBkb2MgPSB0aGlzLmRvY1xcbiAgICAgIGlmIChzZWwuc29tZXRoaW5nU2VsZWN0ZWQoKSlcXG4gICAgICAgIHsgZG9jLnJlcGxhY2VTZWxlY3Rpb24oXFxcIlxcXCIsIG51bGwsIFxcXCIrZGVsZXRlXFxcIikgfVxcbiAgICAgIGVsc2VcXG4gICAgICAgIHsgZGVsZXRlTmVhclNlbGVjdGlvbih0aGlzLCBmdW5jdGlvbiAocmFuZ2UpIHtcXG4gICAgICAgICAgdmFyIG90aGVyID0gZmluZFBvc0goZG9jLCByYW5nZS5oZWFkLCBkaXIsIHVuaXQsIGZhbHNlKVxcbiAgICAgICAgICByZXR1cm4gZGlyIDwgMCA/IHtmcm9tOiBvdGhlciwgdG86IHJhbmdlLmhlYWR9IDoge2Zyb206IHJhbmdlLmhlYWQsIHRvOiBvdGhlcn1cXG4gICAgICAgIH0pIH1cXG4gICAgfSksXFxuXFxuICAgIGZpbmRQb3NWOiBmdW5jdGlvbihmcm9tLCBhbW91bnQsIHVuaXQsIGdvYWxDb2x1bW4pIHtcXG4gICAgICB2YXIgdGhpcyQxID0gdGhpcztcXG5cXG4gICAgICB2YXIgZGlyID0gMSwgeCA9IGdvYWxDb2x1bW5cXG4gICAgICBpZiAoYW1vdW50IDwgMCkgeyBkaXIgPSAtMTsgYW1vdW50ID0gLWFtb3VudCB9XFxuICAgICAgdmFyIGN1ciA9IGNsaXBQb3ModGhpcy5kb2MsIGZyb20pXFxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbW91bnQ7ICsraSkge1xcbiAgICAgICAgdmFyIGNvb3JkcyA9IGN1cnNvckNvb3Jkcyh0aGlzJDEsIGN1ciwgXFxcImRpdlxcXCIpXFxuICAgICAgICBpZiAoeCA9PSBudWxsKSB7IHggPSBjb29yZHMubGVmdCB9XFxuICAgICAgICBlbHNlIHsgY29vcmRzLmxlZnQgPSB4IH1cXG4gICAgICAgIGN1ciA9IGZpbmRQb3NWKHRoaXMkMSwgY29vcmRzLCBkaXIsIHVuaXQpXFxuICAgICAgICBpZiAoY3VyLmhpdFNpZGUpIHsgYnJlYWsgfVxcbiAgICAgIH1cXG4gICAgICByZXR1cm4gY3VyXFxuICAgIH0sXFxuXFxuICAgIG1vdmVWOiBtZXRob2RPcChmdW5jdGlvbihkaXIsIHVuaXQpIHtcXG4gICAgICB2YXIgdGhpcyQxID0gdGhpcztcXG5cXG4gICAgICB2YXIgZG9jID0gdGhpcy5kb2MsIGdvYWxzID0gW11cXG4gICAgICB2YXIgY29sbGFwc2UgPSAhdGhpcy5kaXNwbGF5LnNoaWZ0ICYmICFkb2MuZXh0ZW5kICYmIGRvYy5zZWwuc29tZXRoaW5nU2VsZWN0ZWQoKVxcbiAgICAgIGRvYy5leHRlbmRTZWxlY3Rpb25zQnkoZnVuY3Rpb24gKHJhbmdlKSB7XFxuICAgICAgICBpZiAoY29sbGFwc2UpXFxuICAgICAgICAgIHsgcmV0dXJuIGRpciA8IDAgPyByYW5nZS5mcm9tKCkgOiByYW5nZS50bygpIH1cXG4gICAgICAgIHZhciBoZWFkUG9zID0gY3Vyc29yQ29vcmRzKHRoaXMkMSwgcmFuZ2UuaGVhZCwgXFxcImRpdlxcXCIpXFxuICAgICAgICBpZiAocmFuZ2UuZ29hbENvbHVtbiAhPSBudWxsKSB7IGhlYWRQb3MubGVmdCA9IHJhbmdlLmdvYWxDb2x1bW4gfVxcbiAgICAgICAgZ29hbHMucHVzaChoZWFkUG9zLmxlZnQpXFxuICAgICAgICB2YXIgcG9zID0gZmluZFBvc1YodGhpcyQxLCBoZWFkUG9zLCBkaXIsIHVuaXQpXFxuICAgICAgICBpZiAodW5pdCA9PSBcXFwicGFnZVxcXCIgJiYgcmFuZ2UgPT0gZG9jLnNlbC5wcmltYXJ5KCkpXFxuICAgICAgICAgIHsgYWRkVG9TY3JvbGxQb3ModGhpcyQxLCBudWxsLCBjaGFyQ29vcmRzKHRoaXMkMSwgcG9zLCBcXFwiZGl2XFxcIikudG9wIC0gaGVhZFBvcy50b3ApIH1cXG4gICAgICAgIHJldHVybiBwb3NcXG4gICAgICB9LCBzZWxfbW92ZSlcXG4gICAgICBpZiAoZ29hbHMubGVuZ3RoKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgZG9jLnNlbC5yYW5nZXMubGVuZ3RoOyBpKyspXFxuICAgICAgICB7IGRvYy5zZWwucmFuZ2VzW2ldLmdvYWxDb2x1bW4gPSBnb2Fsc1tpXSB9IH1cXG4gICAgfSksXFxuXFxuICAgIC8vIEZpbmQgdGhlIHdvcmQgYXQgdGhlIGdpdmVuIHBvc2l0aW9uIChhcyByZXR1cm5lZCBieSBjb29yZHNDaGFyKS5cXG4gICAgZmluZFdvcmRBdDogZnVuY3Rpb24ocG9zKSB7XFxuICAgICAgdmFyIGRvYyA9IHRoaXMuZG9jLCBsaW5lID0gZ2V0TGluZShkb2MsIHBvcy5saW5lKS50ZXh0XFxuICAgICAgdmFyIHN0YXJ0ID0gcG9zLmNoLCBlbmQgPSBwb3MuY2hcXG4gICAgICBpZiAobGluZSkge1xcbiAgICAgICAgdmFyIGhlbHBlciA9IHRoaXMuZ2V0SGVscGVyKHBvcywgXFxcIndvcmRDaGFyc1xcXCIpXFxuICAgICAgICBpZiAoKHBvcy5zdGlja3kgPT0gXFxcImJlZm9yZVxcXCIgfHwgZW5kID09IGxpbmUubGVuZ3RoKSAmJiBzdGFydCkgeyAtLXN0YXJ0OyB9IGVsc2UgeyArK2VuZCB9XFxuICAgICAgICB2YXIgc3RhcnRDaGFyID0gbGluZS5jaGFyQXQoc3RhcnQpXFxuICAgICAgICB2YXIgY2hlY2sgPSBpc1dvcmRDaGFyKHN0YXJ0Q2hhciwgaGVscGVyKVxcbiAgICAgICAgICA/IGZ1bmN0aW9uIChjaCkgeyByZXR1cm4gaXNXb3JkQ2hhcihjaCwgaGVscGVyKTsgfVxcbiAgICAgICAgICA6IC9cXFxccy8udGVzdChzdGFydENoYXIpID8gZnVuY3Rpb24gKGNoKSB7IHJldHVybiAvXFxcXHMvLnRlc3QoY2gpOyB9XFxuICAgICAgICAgIDogZnVuY3Rpb24gKGNoKSB7IHJldHVybiAoIS9cXFxccy8udGVzdChjaCkgJiYgIWlzV29yZENoYXIoY2gpKTsgfVxcbiAgICAgICAgd2hpbGUgKHN0YXJ0ID4gMCAmJiBjaGVjayhsaW5lLmNoYXJBdChzdGFydCAtIDEpKSkgeyAtLXN0YXJ0IH1cXG4gICAgICAgIHdoaWxlIChlbmQgPCBsaW5lLmxlbmd0aCAmJiBjaGVjayhsaW5lLmNoYXJBdChlbmQpKSkgeyArK2VuZCB9XFxuICAgICAgfVxcbiAgICAgIHJldHVybiBuZXcgUmFuZ2UoUG9zKHBvcy5saW5lLCBzdGFydCksIFBvcyhwb3MubGluZSwgZW5kKSlcXG4gICAgfSxcXG5cXG4gICAgdG9nZ2xlT3ZlcndyaXRlOiBmdW5jdGlvbih2YWx1ZSkge1xcbiAgICAgIGlmICh2YWx1ZSAhPSBudWxsICYmIHZhbHVlID09IHRoaXMuc3RhdGUub3ZlcndyaXRlKSB7IHJldHVybiB9XFxuICAgICAgaWYgKHRoaXMuc3RhdGUub3ZlcndyaXRlID0gIXRoaXMuc3RhdGUub3ZlcndyaXRlKVxcbiAgICAgICAgeyBhZGRDbGFzcyh0aGlzLmRpc3BsYXkuY3Vyc29yRGl2LCBcXFwiQ29kZU1pcnJvci1vdmVyd3JpdGVcXFwiKSB9XFxuICAgICAgZWxzZVxcbiAgICAgICAgeyBybUNsYXNzKHRoaXMuZGlzcGxheS5jdXJzb3JEaXYsIFxcXCJDb2RlTWlycm9yLW92ZXJ3cml0ZVxcXCIpIH1cXG5cXG4gICAgICBzaWduYWwodGhpcywgXFxcIm92ZXJ3cml0ZVRvZ2dsZVxcXCIsIHRoaXMsIHRoaXMuc3RhdGUub3ZlcndyaXRlKVxcbiAgICB9LFxcbiAgICBoYXNGb2N1czogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLmRpc3BsYXkuaW5wdXQuZ2V0RmllbGQoKSA9PSBhY3RpdmVFbHQoKSB9LFxcbiAgICBpc1JlYWRPbmx5OiBmdW5jdGlvbigpIHsgcmV0dXJuICEhKHRoaXMub3B0aW9ucy5yZWFkT25seSB8fCB0aGlzLmRvYy5jYW50RWRpdCkgfSxcXG5cXG4gICAgc2Nyb2xsVG86IG1ldGhvZE9wKGZ1bmN0aW9uKHgsIHkpIHtcXG4gICAgICBpZiAoeCAhPSBudWxsIHx8IHkgIT0gbnVsbCkgeyByZXNvbHZlU2Nyb2xsVG9Qb3ModGhpcykgfVxcbiAgICAgIGlmICh4ICE9IG51bGwpIHsgdGhpcy5jdXJPcC5zY3JvbGxMZWZ0ID0geCB9XFxuICAgICAgaWYgKHkgIT0gbnVsbCkgeyB0aGlzLmN1ck9wLnNjcm9sbFRvcCA9IHkgfVxcbiAgICB9KSxcXG4gICAgZ2V0U2Nyb2xsSW5mbzogZnVuY3Rpb24oKSB7XFxuICAgICAgdmFyIHNjcm9sbGVyID0gdGhpcy5kaXNwbGF5LnNjcm9sbGVyXFxuICAgICAgcmV0dXJuIHtsZWZ0OiBzY3JvbGxlci5zY3JvbGxMZWZ0LCB0b3A6IHNjcm9sbGVyLnNjcm9sbFRvcCxcXG4gICAgICAgICAgICAgIGhlaWdodDogc2Nyb2xsZXIuc2Nyb2xsSGVpZ2h0IC0gc2Nyb2xsR2FwKHRoaXMpIC0gdGhpcy5kaXNwbGF5LmJhckhlaWdodCxcXG4gICAgICAgICAgICAgIHdpZHRoOiBzY3JvbGxlci5zY3JvbGxXaWR0aCAtIHNjcm9sbEdhcCh0aGlzKSAtIHRoaXMuZGlzcGxheS5iYXJXaWR0aCxcXG4gICAgICAgICAgICAgIGNsaWVudEhlaWdodDogZGlzcGxheUhlaWdodCh0aGlzKSwgY2xpZW50V2lkdGg6IGRpc3BsYXlXaWR0aCh0aGlzKX1cXG4gICAgfSxcXG5cXG4gICAgc2Nyb2xsSW50b1ZpZXc6IG1ldGhvZE9wKGZ1bmN0aW9uKHJhbmdlLCBtYXJnaW4pIHtcXG4gICAgICBpZiAocmFuZ2UgPT0gbnVsbCkge1xcbiAgICAgICAgcmFuZ2UgPSB7ZnJvbTogdGhpcy5kb2Muc2VsLnByaW1hcnkoKS5oZWFkLCB0bzogbnVsbH1cXG4gICAgICAgIGlmIChtYXJnaW4gPT0gbnVsbCkgeyBtYXJnaW4gPSB0aGlzLm9wdGlvbnMuY3Vyc29yU2Nyb2xsTWFyZ2luIH1cXG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiByYW5nZSA9PSBcXFwibnVtYmVyXFxcIikge1xcbiAgICAgICAgcmFuZ2UgPSB7ZnJvbTogUG9zKHJhbmdlLCAwKSwgdG86IG51bGx9XFxuICAgICAgfSBlbHNlIGlmIChyYW5nZS5mcm9tID09IG51bGwpIHtcXG4gICAgICAgIHJhbmdlID0ge2Zyb206IHJhbmdlLCB0bzogbnVsbH1cXG4gICAgICB9XFxuICAgICAgaWYgKCFyYW5nZS50bykgeyByYW5nZS50byA9IHJhbmdlLmZyb20gfVxcbiAgICAgIHJhbmdlLm1hcmdpbiA9IG1hcmdpbiB8fCAwXFxuXFxuICAgICAgaWYgKHJhbmdlLmZyb20ubGluZSAhPSBudWxsKSB7XFxuICAgICAgICByZXNvbHZlU2Nyb2xsVG9Qb3ModGhpcylcXG4gICAgICAgIHRoaXMuY3VyT3Auc2Nyb2xsVG9Qb3MgPSByYW5nZVxcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICB2YXIgc1BvcyA9IGNhbGN1bGF0ZVNjcm9sbFBvcyh0aGlzLCBNYXRoLm1pbihyYW5nZS5mcm9tLmxlZnQsIHJhbmdlLnRvLmxlZnQpLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5taW4ocmFuZ2UuZnJvbS50b3AsIHJhbmdlLnRvLnRvcCkgLSByYW5nZS5tYXJnaW4sXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBNYXRoLm1heChyYW5nZS5mcm9tLnJpZ2h0LCByYW5nZS50by5yaWdodCksXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBNYXRoLm1heChyYW5nZS5mcm9tLmJvdHRvbSwgcmFuZ2UudG8uYm90dG9tKSArIHJhbmdlLm1hcmdpbilcXG4gICAgICAgIHRoaXMuc2Nyb2xsVG8oc1Bvcy5zY3JvbGxMZWZ0LCBzUG9zLnNjcm9sbFRvcClcXG4gICAgICB9XFxuICAgIH0pLFxcblxcbiAgICBzZXRTaXplOiBtZXRob2RPcChmdW5jdGlvbih3aWR0aCwgaGVpZ2h0KSB7XFxuICAgICAgdmFyIHRoaXMkMSA9IHRoaXM7XFxuXFxuICAgICAgdmFyIGludGVycHJldCA9IGZ1bmN0aW9uICh2YWwpIHsgcmV0dXJuIHR5cGVvZiB2YWwgPT0gXFxcIm51bWJlclxcXCIgfHwgL15cXFxcZCskLy50ZXN0KFN0cmluZyh2YWwpKSA/IHZhbCArIFxcXCJweFxcXCIgOiB2YWw7IH1cXG4gICAgICBpZiAod2lkdGggIT0gbnVsbCkgeyB0aGlzLmRpc3BsYXkud3JhcHBlci5zdHlsZS53aWR0aCA9IGludGVycHJldCh3aWR0aCkgfVxcbiAgICAgIGlmIChoZWlnaHQgIT0gbnVsbCkgeyB0aGlzLmRpc3BsYXkud3JhcHBlci5zdHlsZS5oZWlnaHQgPSBpbnRlcnByZXQoaGVpZ2h0KSB9XFxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5saW5lV3JhcHBpbmcpIHsgY2xlYXJMaW5lTWVhc3VyZW1lbnRDYWNoZSh0aGlzKSB9XFxuICAgICAgdmFyIGxpbmVObyA9IHRoaXMuZGlzcGxheS52aWV3RnJvbVxcbiAgICAgIHRoaXMuZG9jLml0ZXIobGluZU5vLCB0aGlzLmRpc3BsYXkudmlld1RvLCBmdW5jdGlvbiAobGluZSkge1xcbiAgICAgICAgaWYgKGxpbmUud2lkZ2V0cykgeyBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmUud2lkZ2V0cy5sZW5ndGg7IGkrKylcXG4gICAgICAgICAgeyBpZiAobGluZS53aWRnZXRzW2ldLm5vSFNjcm9sbCkgeyByZWdMaW5lQ2hhbmdlKHRoaXMkMSwgbGluZU5vLCBcXFwid2lkZ2V0XFxcIik7IGJyZWFrIH0gfSB9XFxuICAgICAgICArK2xpbmVOb1xcbiAgICAgIH0pXFxuICAgICAgdGhpcy5jdXJPcC5mb3JjZVVwZGF0ZSA9IHRydWVcXG4gICAgICBzaWduYWwodGhpcywgXFxcInJlZnJlc2hcXFwiLCB0aGlzKVxcbiAgICB9KSxcXG5cXG4gICAgb3BlcmF0aW9uOiBmdW5jdGlvbihmKXtyZXR1cm4gcnVuSW5PcCh0aGlzLCBmKX0sXFxuXFxuICAgIHJlZnJlc2g6IG1ldGhvZE9wKGZ1bmN0aW9uKCkge1xcbiAgICAgIHZhciBvbGRIZWlnaHQgPSB0aGlzLmRpc3BsYXkuY2FjaGVkVGV4dEhlaWdodFxcbiAgICAgIHJlZ0NoYW5nZSh0aGlzKVxcbiAgICAgIHRoaXMuY3VyT3AuZm9yY2VVcGRhdGUgPSB0cnVlXFxuICAgICAgY2xlYXJDYWNoZXModGhpcylcXG4gICAgICB0aGlzLnNjcm9sbFRvKHRoaXMuZG9jLnNjcm9sbExlZnQsIHRoaXMuZG9jLnNjcm9sbFRvcClcXG4gICAgICB1cGRhdGVHdXR0ZXJTcGFjZSh0aGlzKVxcbiAgICAgIGlmIChvbGRIZWlnaHQgPT0gbnVsbCB8fCBNYXRoLmFicyhvbGRIZWlnaHQgLSB0ZXh0SGVpZ2h0KHRoaXMuZGlzcGxheSkpID4gLjUpXFxuICAgICAgICB7IGVzdGltYXRlTGluZUhlaWdodHModGhpcykgfVxcbiAgICAgIHNpZ25hbCh0aGlzLCBcXFwicmVmcmVzaFxcXCIsIHRoaXMpXFxuICAgIH0pLFxcblxcbiAgICBzd2FwRG9jOiBtZXRob2RPcChmdW5jdGlvbihkb2MpIHtcXG4gICAgICB2YXIgb2xkID0gdGhpcy5kb2NcXG4gICAgICBvbGQuY20gPSBudWxsXFxuICAgICAgYXR0YWNoRG9jKHRoaXMsIGRvYylcXG4gICAgICBjbGVhckNhY2hlcyh0aGlzKVxcbiAgICAgIHRoaXMuZGlzcGxheS5pbnB1dC5yZXNldCgpXFxuICAgICAgdGhpcy5zY3JvbGxUbyhkb2Muc2Nyb2xsTGVmdCwgZG9jLnNjcm9sbFRvcClcXG4gICAgICB0aGlzLmN1ck9wLmZvcmNlU2Nyb2xsID0gdHJ1ZVxcbiAgICAgIHNpZ25hbExhdGVyKHRoaXMsIFxcXCJzd2FwRG9jXFxcIiwgdGhpcywgb2xkKVxcbiAgICAgIHJldHVybiBvbGRcXG4gICAgfSksXFxuXFxuICAgIGdldElucHV0RmllbGQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZGlzcGxheS5pbnB1dC5nZXRGaWVsZCgpfSxcXG4gICAgZ2V0V3JhcHBlckVsZW1lbnQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZGlzcGxheS53cmFwcGVyfSxcXG4gICAgZ2V0U2Nyb2xsZXJFbGVtZW50OiBmdW5jdGlvbigpe3JldHVybiB0aGlzLmRpc3BsYXkuc2Nyb2xsZXJ9LFxcbiAgICBnZXRHdXR0ZXJFbGVtZW50OiBmdW5jdGlvbigpe3JldHVybiB0aGlzLmRpc3BsYXkuZ3V0dGVyc31cXG4gIH1cXG4gIGV2ZW50TWl4aW4oQ29kZU1pcnJvcilcXG5cXG4gIENvZGVNaXJyb3IucmVnaXN0ZXJIZWxwZXIgPSBmdW5jdGlvbih0eXBlLCBuYW1lLCB2YWx1ZSkge1xcbiAgICBpZiAoIWhlbHBlcnMuaGFzT3duUHJvcGVydHkodHlwZSkpIHsgaGVscGVyc1t0eXBlXSA9IENvZGVNaXJyb3JbdHlwZV0gPSB7X2dsb2JhbDogW119IH1cXG4gICAgaGVscGVyc1t0eXBlXVtuYW1lXSA9IHZhbHVlXFxuICB9XFxuICBDb2RlTWlycm9yLnJlZ2lzdGVyR2xvYmFsSGVscGVyID0gZnVuY3Rpb24odHlwZSwgbmFtZSwgcHJlZGljYXRlLCB2YWx1ZSkge1xcbiAgICBDb2RlTWlycm9yLnJlZ2lzdGVySGVscGVyKHR5cGUsIG5hbWUsIHZhbHVlKVxcbiAgICBoZWxwZXJzW3R5cGVdLl9nbG9iYWwucHVzaCh7cHJlZDogcHJlZGljYXRlLCB2YWw6IHZhbHVlfSlcXG4gIH1cXG59XFxuXFxuLy8gVXNlZCBmb3IgaG9yaXpvbnRhbCByZWxhdGl2ZSBtb3Rpb24uIERpciBpcyAtMSBvciAxIChsZWZ0IG9yXFxuLy8gcmlnaHQpLCB1bml0IGNhbiBiZSBcXFwiY2hhclxcXCIsIFxcXCJjb2x1bW5cXFwiIChsaWtlIGNoYXIsIGJ1dCBkb2Vzbid0XFxuLy8gY3Jvc3MgbGluZSBib3VuZGFyaWVzKSwgXFxcIndvcmRcXFwiIChhY3Jvc3MgbmV4dCB3b3JkKSwgb3IgXFxcImdyb3VwXFxcIiAodG9cXG4vLyB0aGUgc3RhcnQgb2YgbmV4dCBncm91cCBvZiB3b3JkIG9yIG5vbi13b3JkLW5vbi13aGl0ZXNwYWNlXFxuLy8gY2hhcnMpLiBUaGUgdmlzdWFsbHkgcGFyYW0gY29udHJvbHMgd2hldGhlciwgaW4gcmlnaHQtdG8tbGVmdFxcbi8vIHRleHQsIGRpcmVjdGlvbiAxIG1lYW5zIHRvIG1vdmUgdG93YXJkcyB0aGUgbmV4dCBpbmRleCBpbiB0aGVcXG4vLyBzdHJpbmcsIG9yIHRvd2FyZHMgdGhlIGNoYXJhY3RlciB0byB0aGUgcmlnaHQgb2YgdGhlIGN1cnJlbnRcXG4vLyBwb3NpdGlvbi4gVGhlIHJlc3VsdGluZyBwb3NpdGlvbiB3aWxsIGhhdmUgYSBoaXRTaWRlPXRydWVcXG4vLyBwcm9wZXJ0eSBpZiBpdCByZWFjaGVkIHRoZSBlbmQgb2YgdGhlIGRvY3VtZW50LlxcbmZ1bmN0aW9uIGZpbmRQb3NIKGRvYywgcG9zLCBkaXIsIHVuaXQsIHZpc3VhbGx5KSB7XFxuICB2YXIgb2xkUG9zID0gcG9zXFxuICB2YXIgb3JpZ0RpciA9IGRpclxcbiAgdmFyIGxpbmVPYmogPSBnZXRMaW5lKGRvYywgcG9zLmxpbmUpXFxuICBmdW5jdGlvbiBmaW5kTmV4dExpbmUoKSB7XFxuICAgIHZhciBsID0gcG9zLmxpbmUgKyBkaXJcXG4gICAgaWYgKGwgPCBkb2MuZmlyc3QgfHwgbCA+PSBkb2MuZmlyc3QgKyBkb2Muc2l6ZSkgeyByZXR1cm4gZmFsc2UgfVxcbiAgICBwb3MgPSBuZXcgUG9zKGwsIHBvcy5jaCwgcG9zLnN0aWNreSlcXG4gICAgcmV0dXJuIGxpbmVPYmogPSBnZXRMaW5lKGRvYywgbClcXG4gIH1cXG4gIGZ1bmN0aW9uIG1vdmVPbmNlKGJvdW5kVG9MaW5lKSB7XFxuICAgIHZhciBuZXh0XFxuICAgIGlmICh2aXN1YWxseSkge1xcbiAgICAgIG5leHQgPSBtb3ZlVmlzdWFsbHkoZG9jLmNtLCBsaW5lT2JqLCBwb3MsIGRpcilcXG4gICAgfSBlbHNlIHtcXG4gICAgICBuZXh0ID0gbW92ZUxvZ2ljYWxseShsaW5lT2JqLCBwb3MsIGRpcilcXG4gICAgfVxcbiAgICBpZiAobmV4dCA9PSBudWxsKSB7XFxuICAgICAgaWYgKCFib3VuZFRvTGluZSAmJiBmaW5kTmV4dExpbmUoKSlcXG4gICAgICAgIHsgcG9zID0gZW5kT2ZMaW5lKHZpc3VhbGx5LCBkb2MuY20sIGxpbmVPYmosIHBvcy5saW5lLCBkaXIpIH1cXG4gICAgICBlbHNlXFxuICAgICAgICB7IHJldHVybiBmYWxzZSB9XFxuICAgIH0gZWxzZSB7XFxuICAgICAgcG9zID0gbmV4dFxcbiAgICB9XFxuICAgIHJldHVybiB0cnVlXFxuICB9XFxuXFxuICBpZiAodW5pdCA9PSBcXFwiY2hhclxcXCIpIHtcXG4gICAgbW92ZU9uY2UoKVxcbiAgfSBlbHNlIGlmICh1bml0ID09IFxcXCJjb2x1bW5cXFwiKSB7XFxuICAgIG1vdmVPbmNlKHRydWUpXFxuICB9IGVsc2UgaWYgKHVuaXQgPT0gXFxcIndvcmRcXFwiIHx8IHVuaXQgPT0gXFxcImdyb3VwXFxcIikge1xcbiAgICB2YXIgc2F3VHlwZSA9IG51bGwsIGdyb3VwID0gdW5pdCA9PSBcXFwiZ3JvdXBcXFwiXFxuICAgIHZhciBoZWxwZXIgPSBkb2MuY20gJiYgZG9jLmNtLmdldEhlbHBlcihwb3MsIFxcXCJ3b3JkQ2hhcnNcXFwiKVxcbiAgICBmb3IgKHZhciBmaXJzdCA9IHRydWU7OyBmaXJzdCA9IGZhbHNlKSB7XFxuICAgICAgaWYgKGRpciA8IDAgJiYgIW1vdmVPbmNlKCFmaXJzdCkpIHsgYnJlYWsgfVxcbiAgICAgIHZhciBjdXIgPSBsaW5lT2JqLnRleHQuY2hhckF0KHBvcy5jaCkgfHwgXFxcIlxcXFxuXFxcIlxcbiAgICAgIHZhciB0eXBlID0gaXNXb3JkQ2hhcihjdXIsIGhlbHBlcikgPyBcXFwid1xcXCJcXG4gICAgICAgIDogZ3JvdXAgJiYgY3VyID09IFxcXCJcXFxcblxcXCIgPyBcXFwiblxcXCJcXG4gICAgICAgIDogIWdyb3VwIHx8IC9cXFxccy8udGVzdChjdXIpID8gbnVsbFxcbiAgICAgICAgOiBcXFwicFxcXCJcXG4gICAgICBpZiAoZ3JvdXAgJiYgIWZpcnN0ICYmICF0eXBlKSB7IHR5cGUgPSBcXFwic1xcXCIgfVxcbiAgICAgIGlmIChzYXdUeXBlICYmIHNhd1R5cGUgIT0gdHlwZSkge1xcbiAgICAgICAgaWYgKGRpciA8IDApIHtkaXIgPSAxOyBtb3ZlT25jZSgpOyBwb3Muc3RpY2t5ID0gXFxcImFmdGVyXFxcIn1cXG4gICAgICAgIGJyZWFrXFxuICAgICAgfVxcblxcbiAgICAgIGlmICh0eXBlKSB7IHNhd1R5cGUgPSB0eXBlIH1cXG4gICAgICBpZiAoZGlyID4gMCAmJiAhbW92ZU9uY2UoIWZpcnN0KSkgeyBicmVhayB9XFxuICAgIH1cXG4gIH1cXG4gIHZhciByZXN1bHQgPSBza2lwQXRvbWljKGRvYywgcG9zLCBvbGRQb3MsIG9yaWdEaXIsIHRydWUpXFxuICBpZiAoZXF1YWxDdXJzb3JQb3Mob2xkUG9zLCByZXN1bHQpKSB7IHJlc3VsdC5oaXRTaWRlID0gdHJ1ZSB9XFxuICByZXR1cm4gcmVzdWx0XFxufVxcblxcbi8vIEZvciByZWxhdGl2ZSB2ZXJ0aWNhbCBtb3ZlbWVudC4gRGlyIG1heSBiZSAtMSBvciAxLiBVbml0IGNhbiBiZVxcbi8vIFxcXCJwYWdlXFxcIiBvciBcXFwibGluZVxcXCIuIFRoZSByZXN1bHRpbmcgcG9zaXRpb24gd2lsbCBoYXZlIGEgaGl0U2lkZT10cnVlXFxuLy8gcHJvcGVydHkgaWYgaXQgcmVhY2hlZCB0aGUgZW5kIG9mIHRoZSBkb2N1bWVudC5cXG5mdW5jdGlvbiBmaW5kUG9zVihjbSwgcG9zLCBkaXIsIHVuaXQpIHtcXG4gIHZhciBkb2MgPSBjbS5kb2MsIHggPSBwb3MubGVmdCwgeVxcbiAgaWYgKHVuaXQgPT0gXFxcInBhZ2VcXFwiKSB7XFxuICAgIHZhciBwYWdlU2l6ZSA9IE1hdGgubWluKGNtLmRpc3BsYXkud3JhcHBlci5jbGllbnRIZWlnaHQsIHdpbmRvdy5pbm5lckhlaWdodCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0KVxcbiAgICB2YXIgbW92ZUFtb3VudCA9IE1hdGgubWF4KHBhZ2VTaXplIC0gLjUgKiB0ZXh0SGVpZ2h0KGNtLmRpc3BsYXkpLCAzKVxcbiAgICB5ID0gKGRpciA+IDAgPyBwb3MuYm90dG9tIDogcG9zLnRvcCkgKyBkaXIgKiBtb3ZlQW1vdW50XFxuXFxuICB9IGVsc2UgaWYgKHVuaXQgPT0gXFxcImxpbmVcXFwiKSB7XFxuICAgIHkgPSBkaXIgPiAwID8gcG9zLmJvdHRvbSArIDMgOiBwb3MudG9wIC0gM1xcbiAgfVxcbiAgdmFyIHRhcmdldFxcbiAgZm9yICg7Oykge1xcbiAgICB0YXJnZXQgPSBjb29yZHNDaGFyKGNtLCB4LCB5KVxcbiAgICBpZiAoIXRhcmdldC5vdXRzaWRlKSB7IGJyZWFrIH1cXG4gICAgaWYgKGRpciA8IDAgPyB5IDw9IDAgOiB5ID49IGRvYy5oZWlnaHQpIHsgdGFyZ2V0LmhpdFNpZGUgPSB0cnVlOyBicmVhayB9XFxuICAgIHkgKz0gZGlyICogNVxcbiAgfVxcbiAgcmV0dXJuIHRhcmdldFxcbn1cXG5cXG4vLyBDT05URU5URURJVEFCTEUgSU5QVVQgU1RZTEVcXG5cXG52YXIgQ29udGVudEVkaXRhYmxlSW5wdXQgPSBmdW5jdGlvbihjbSkge1xcbiAgdGhpcy5jbSA9IGNtXFxuICB0aGlzLmxhc3RBbmNob3JOb2RlID0gdGhpcy5sYXN0QW5jaG9yT2Zmc2V0ID0gdGhpcy5sYXN0Rm9jdXNOb2RlID0gdGhpcy5sYXN0Rm9jdXNPZmZzZXQgPSBudWxsXFxuICB0aGlzLnBvbGxpbmcgPSBuZXcgRGVsYXllZCgpXFxuICB0aGlzLmNvbXBvc2luZyA9IG51bGxcXG4gIHRoaXMuZ3JhY2VQZXJpb2QgPSBmYWxzZVxcbiAgdGhpcy5yZWFkRE9NVGltZW91dCA9IG51bGxcXG59O1xcblxcbkNvbnRlbnRFZGl0YWJsZUlucHV0LnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKGRpc3BsYXkpIHtcXG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XFxuXFxuICB2YXIgaW5wdXQgPSB0aGlzLCBjbSA9IGlucHV0LmNtXFxuICB2YXIgZGl2ID0gaW5wdXQuZGl2ID0gZGlzcGxheS5saW5lRGl2XFxuICBkaXNhYmxlQnJvd3Nlck1hZ2ljKGRpdiwgY20ub3B0aW9ucy5zcGVsbGNoZWNrKVxcblxcbiAgb24oZGl2LCBcXFwicGFzdGVcXFwiLCBmdW5jdGlvbiAoZSkge1xcbiAgICBpZiAoc2lnbmFsRE9NRXZlbnQoY20sIGUpIHx8IGhhbmRsZVBhc3RlKGUsIGNtKSkgeyByZXR1cm4gfVxcbiAgICAvLyBJRSBkb2Vzbid0IGZpcmUgaW5wdXQgZXZlbnRzLCBzbyB3ZSBzY2hlZHVsZSBhIHJlYWQgZm9yIHRoZSBwYXN0ZWQgY29udGVudCBpbiB0aGlzIHdheVxcbiAgICBpZiAoaWVfdmVyc2lvbiA8PSAxMSkgeyBzZXRUaW1lb3V0KG9wZXJhdGlvbihjbSwgZnVuY3Rpb24gKCkge1xcbiAgICAgIGlmICghaW5wdXQucG9sbENvbnRlbnQoKSkgeyByZWdDaGFuZ2UoY20pIH1cXG4gICAgfSksIDIwKSB9XFxuICB9KVxcblxcbiAgb24oZGl2LCBcXFwiY29tcG9zaXRpb25zdGFydFxcXCIsIGZ1bmN0aW9uIChlKSB7XFxuICAgIHRoaXMkMS5jb21wb3NpbmcgPSB7ZGF0YTogZS5kYXRhLCBkb25lOiBmYWxzZX1cXG4gIH0pXFxuICBvbihkaXYsIFxcXCJjb21wb3NpdGlvbnVwZGF0ZVxcXCIsIGZ1bmN0aW9uIChlKSB7XFxuICAgIGlmICghdGhpcyQxLmNvbXBvc2luZykgeyB0aGlzJDEuY29tcG9zaW5nID0ge2RhdGE6IGUuZGF0YSwgZG9uZTogZmFsc2V9IH1cXG4gIH0pXFxuICBvbihkaXYsIFxcXCJjb21wb3NpdGlvbmVuZFxcXCIsIGZ1bmN0aW9uIChlKSB7XFxuICAgIGlmICh0aGlzJDEuY29tcG9zaW5nKSB7XFxuICAgICAgaWYgKGUuZGF0YSAhPSB0aGlzJDEuY29tcG9zaW5nLmRhdGEpIHsgdGhpcyQxLnJlYWRGcm9tRE9NU29vbigpIH1cXG4gICAgICB0aGlzJDEuY29tcG9zaW5nLmRvbmUgPSB0cnVlXFxuICAgIH1cXG4gIH0pXFxuXFxuICBvbihkaXYsIFxcXCJ0b3VjaHN0YXJ0XFxcIiwgZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5wdXQuZm9yY2VDb21wb3NpdGlvbkVuZCgpOyB9KVxcblxcbiAgb24oZGl2LCBcXFwiaW5wdXRcXFwiLCBmdW5jdGlvbiAoKSB7XFxuICAgIGlmICghdGhpcyQxLmNvbXBvc2luZykgeyB0aGlzJDEucmVhZEZyb21ET01Tb29uKCkgfVxcbiAgfSlcXG5cXG4gIGZ1bmN0aW9uIG9uQ29weUN1dChlKSB7XFxuICAgIGlmIChzaWduYWxET01FdmVudChjbSwgZSkpIHsgcmV0dXJuIH1cXG4gICAgaWYgKGNtLnNvbWV0aGluZ1NlbGVjdGVkKCkpIHtcXG4gICAgICBzZXRMYXN0Q29waWVkKHtsaW5lV2lzZTogZmFsc2UsIHRleHQ6IGNtLmdldFNlbGVjdGlvbnMoKX0pXFxuICAgICAgaWYgKGUudHlwZSA9PSBcXFwiY3V0XFxcIikgeyBjbS5yZXBsYWNlU2VsZWN0aW9uKFxcXCJcXFwiLCBudWxsLCBcXFwiY3V0XFxcIikgfVxcbiAgICB9IGVsc2UgaWYgKCFjbS5vcHRpb25zLmxpbmVXaXNlQ29weUN1dCkge1xcbiAgICAgIHJldHVyblxcbiAgICB9IGVsc2Uge1xcbiAgICAgIHZhciByYW5nZXMgPSBjb3B5YWJsZVJhbmdlcyhjbSlcXG4gICAgICBzZXRMYXN0Q29waWVkKHtsaW5lV2lzZTogdHJ1ZSwgdGV4dDogcmFuZ2VzLnRleHR9KVxcbiAgICAgIGlmIChlLnR5cGUgPT0gXFxcImN1dFxcXCIpIHtcXG4gICAgICAgIGNtLm9wZXJhdGlvbihmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgIGNtLnNldFNlbGVjdGlvbnMocmFuZ2VzLnJhbmdlcywgMCwgc2VsX2RvbnRTY3JvbGwpXFxuICAgICAgICAgIGNtLnJlcGxhY2VTZWxlY3Rpb24oXFxcIlxcXCIsIG51bGwsIFxcXCJjdXRcXFwiKVxcbiAgICAgICAgfSlcXG4gICAgICB9XFxuICAgIH1cXG4gICAgaWYgKGUuY2xpcGJvYXJkRGF0YSkge1xcbiAgICAgIGUuY2xpcGJvYXJkRGF0YS5jbGVhckRhdGEoKVxcbiAgICAgIHZhciBjb250ZW50ID0gbGFzdENvcGllZC50ZXh0LmpvaW4oXFxcIlxcXFxuXFxcIilcXG4gICAgICAvLyBpT1MgZXhwb3NlcyB0aGUgY2xpcGJvYXJkIEFQSSwgYnV0IHNlZW1zIHRvIGRpc2NhcmQgY29udGVudCBpbnNlcnRlZCBpbnRvIGl0XFxuICAgICAgZS5jbGlwYm9hcmREYXRhLnNldERhdGEoXFxcIlRleHRcXFwiLCBjb250ZW50KVxcbiAgICAgIGlmIChlLmNsaXBib2FyZERhdGEuZ2V0RGF0YShcXFwiVGV4dFxcXCIpID09IGNvbnRlbnQpIHtcXG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKVxcbiAgICAgICAgcmV0dXJuXFxuICAgICAgfVxcbiAgICB9XFxuICAgIC8vIE9sZC1mYXNoaW9uZWQgYnJpZWZseS1mb2N1cy1hLXRleHRhcmVhIGhhY2tcXG4gICAgdmFyIGtsdWRnZSA9IGhpZGRlblRleHRhcmVhKCksIHRlID0ga2x1ZGdlLmZpcnN0Q2hpbGRcXG4gICAgY20uZGlzcGxheS5saW5lU3BhY2UuaW5zZXJ0QmVmb3JlKGtsdWRnZSwgY20uZGlzcGxheS5saW5lU3BhY2UuZmlyc3RDaGlsZClcXG4gICAgdGUudmFsdWUgPSBsYXN0Q29waWVkLnRleHQuam9pbihcXFwiXFxcXG5cXFwiKVxcbiAgICB2YXIgaGFkRm9jdXMgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50XFxuICAgIHNlbGVjdElucHV0KHRlKVxcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcXG4gICAgICBjbS5kaXNwbGF5LmxpbmVTcGFjZS5yZW1vdmVDaGlsZChrbHVkZ2UpXFxuICAgICAgaGFkRm9jdXMuZm9jdXMoKVxcbiAgICAgIGlmIChoYWRGb2N1cyA9PSBkaXYpIHsgaW5wdXQuc2hvd1ByaW1hcnlTZWxlY3Rpb24oKSB9XFxuICAgIH0sIDUwKVxcbiAgfVxcbiAgb24oZGl2LCBcXFwiY29weVxcXCIsIG9uQ29weUN1dClcXG4gIG9uKGRpdiwgXFxcImN1dFxcXCIsIG9uQ29weUN1dClcXG59O1xcblxcbkNvbnRlbnRFZGl0YWJsZUlucHV0LnByb3RvdHlwZS5wcmVwYXJlU2VsZWN0aW9uID0gZnVuY3Rpb24gKCkge1xcbiAgdmFyIHJlc3VsdCA9IHByZXBhcmVTZWxlY3Rpb24odGhpcy5jbSwgZmFsc2UpXFxuICByZXN1bHQuZm9jdXMgPSB0aGlzLmNtLnN0YXRlLmZvY3VzZWRcXG4gIHJldHVybiByZXN1bHRcXG59O1xcblxcbkNvbnRlbnRFZGl0YWJsZUlucHV0LnByb3RvdHlwZS5zaG93U2VsZWN0aW9uID0gZnVuY3Rpb24gKGluZm8sIHRha2VGb2N1cykge1xcbiAgaWYgKCFpbmZvIHx8ICF0aGlzLmNtLmRpc3BsYXkudmlldy5sZW5ndGgpIHsgcmV0dXJuIH1cXG4gIGlmIChpbmZvLmZvY3VzIHx8IHRha2VGb2N1cykgeyB0aGlzLnNob3dQcmltYXJ5U2VsZWN0aW9uKCkgfVxcbiAgdGhpcy5zaG93TXVsdGlwbGVTZWxlY3Rpb25zKGluZm8pXFxufTtcXG5cXG5Db250ZW50RWRpdGFibGVJbnB1dC5wcm90b3R5cGUuc2hvd1ByaW1hcnlTZWxlY3Rpb24gPSBmdW5jdGlvbiAoKSB7XFxuICB2YXIgc2VsID0gd2luZG93LmdldFNlbGVjdGlvbigpLCBwcmltID0gdGhpcy5jbS5kb2Muc2VsLnByaW1hcnkoKVxcbiAgdmFyIGN1ckFuY2hvciA9IGRvbVRvUG9zKHRoaXMuY20sIHNlbC5hbmNob3JOb2RlLCBzZWwuYW5jaG9yT2Zmc2V0KVxcbiAgdmFyIGN1ckZvY3VzID0gZG9tVG9Qb3ModGhpcy5jbSwgc2VsLmZvY3VzTm9kZSwgc2VsLmZvY3VzT2Zmc2V0KVxcbiAgaWYgKGN1ckFuY2hvciAmJiAhY3VyQW5jaG9yLmJhZCAmJiBjdXJGb2N1cyAmJiAhY3VyRm9jdXMuYmFkICYmXFxuICAgICAgY21wKG1pblBvcyhjdXJBbmNob3IsIGN1ckZvY3VzKSwgcHJpbS5mcm9tKCkpID09IDAgJiZcXG4gICAgICBjbXAobWF4UG9zKGN1ckFuY2hvciwgY3VyRm9jdXMpLCBwcmltLnRvKCkpID09IDApXFxuICAgIHsgcmV0dXJuIH1cXG5cXG4gIHZhciBzdGFydCA9IHBvc1RvRE9NKHRoaXMuY20sIHByaW0uZnJvbSgpKVxcbiAgdmFyIGVuZCA9IHBvc1RvRE9NKHRoaXMuY20sIHByaW0udG8oKSlcXG4gIGlmICghc3RhcnQgJiYgIWVuZCkgeyByZXR1cm4gfVxcblxcbiAgdmFyIHZpZXcgPSB0aGlzLmNtLmRpc3BsYXkudmlld1xcbiAgdmFyIG9sZCA9IHNlbC5yYW5nZUNvdW50ICYmIHNlbC5nZXRSYW5nZUF0KDApXFxuICBpZiAoIXN0YXJ0KSB7XFxuICAgIHN0YXJ0ID0ge25vZGU6IHZpZXdbMF0ubWVhc3VyZS5tYXBbMl0sIG9mZnNldDogMH1cXG4gIH0gZWxzZSBpZiAoIWVuZCkgeyAvLyBGSVhNRSBkYW5nZXJvdXNseSBoYWNreVxcbiAgICB2YXIgbWVhc3VyZSA9IHZpZXdbdmlldy5sZW5ndGggLSAxXS5tZWFzdXJlXFxuICAgIHZhciBtYXAgPSBtZWFzdXJlLm1hcHMgPyBtZWFzdXJlLm1hcHNbbWVhc3VyZS5tYXBzLmxlbmd0aCAtIDFdIDogbWVhc3VyZS5tYXBcXG4gICAgZW5kID0ge25vZGU6IG1hcFttYXAubGVuZ3RoIC0gMV0sIG9mZnNldDogbWFwW21hcC5sZW5ndGggLSAyXSAtIG1hcFttYXAubGVuZ3RoIC0gM119XFxuICB9XFxuXFxuICB2YXIgcm5nXFxuICB0cnkgeyBybmcgPSByYW5nZShzdGFydC5ub2RlLCBzdGFydC5vZmZzZXQsIGVuZC5vZmZzZXQsIGVuZC5ub2RlKSB9XFxuICBjYXRjaChlKSB7fSAvLyBPdXIgbW9kZWwgb2YgdGhlIERPTSBtaWdodCBiZSBvdXRkYXRlZCwgaW4gd2hpY2ggY2FzZSB0aGUgcmFuZ2Ugd2UgdHJ5IHRvIHNldCBjYW4gYmUgaW1wb3NzaWJsZVxcbiAgaWYgKHJuZykge1xcbiAgICBpZiAoIWdlY2tvICYmIHRoaXMuY20uc3RhdGUuZm9jdXNlZCkge1xcbiAgICAgIHNlbC5jb2xsYXBzZShzdGFydC5ub2RlLCBzdGFydC5vZmZzZXQpXFxuICAgICAgaWYgKCFybmcuY29sbGFwc2VkKSB7XFxuICAgICAgICBzZWwucmVtb3ZlQWxsUmFuZ2VzKClcXG4gICAgICAgIHNlbC5hZGRSYW5nZShybmcpXFxuICAgICAgfVxcbiAgICB9IGVsc2Uge1xcbiAgICAgIHNlbC5yZW1vdmVBbGxSYW5nZXMoKVxcbiAgICAgIHNlbC5hZGRSYW5nZShybmcpXFxuICAgIH1cXG4gICAgaWYgKG9sZCAmJiBzZWwuYW5jaG9yTm9kZSA9PSBudWxsKSB7IHNlbC5hZGRSYW5nZShvbGQpIH1cXG4gICAgZWxzZSBpZiAoZ2Vja28pIHsgdGhpcy5zdGFydEdyYWNlUGVyaW9kKCkgfVxcbiAgfVxcbiAgdGhpcy5yZW1lbWJlclNlbGVjdGlvbigpXFxufTtcXG5cXG5Db250ZW50RWRpdGFibGVJbnB1dC5wcm90b3R5cGUuc3RhcnRHcmFjZVBlcmlvZCA9IGZ1bmN0aW9uICgpIHtcXG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XFxuXFxuICBjbGVhclRpbWVvdXQodGhpcy5ncmFjZVBlcmlvZClcXG4gIHRoaXMuZ3JhY2VQZXJpb2QgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcXG4gICAgdGhpcyQxLmdyYWNlUGVyaW9kID0gZmFsc2VcXG4gICAgaWYgKHRoaXMkMS5zZWxlY3Rpb25DaGFuZ2VkKCkpXFxuICAgICAgeyB0aGlzJDEuY20ub3BlcmF0aW9uKGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMkMS5jbS5jdXJPcC5zZWxlY3Rpb25DaGFuZ2VkID0gdHJ1ZTsgfSkgfVxcbiAgfSwgMjApXFxufTtcXG5cXG5Db250ZW50RWRpdGFibGVJbnB1dC5wcm90b3R5cGUuc2hvd011bHRpcGxlU2VsZWN0aW9ucyA9IGZ1bmN0aW9uIChpbmZvKSB7XFxuICByZW1vdmVDaGlsZHJlbkFuZEFkZCh0aGlzLmNtLmRpc3BsYXkuY3Vyc29yRGl2LCBpbmZvLmN1cnNvcnMpXFxuICByZW1vdmVDaGlsZHJlbkFuZEFkZCh0aGlzLmNtLmRpc3BsYXkuc2VsZWN0aW9uRGl2LCBpbmZvLnNlbGVjdGlvbilcXG59O1xcblxcbkNvbnRlbnRFZGl0YWJsZUlucHV0LnByb3RvdHlwZS5yZW1lbWJlclNlbGVjdGlvbiA9IGZ1bmN0aW9uICgpIHtcXG4gIHZhciBzZWwgPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKClcXG4gIHRoaXMubGFzdEFuY2hvck5vZGUgPSBzZWwuYW5jaG9yTm9kZTsgdGhpcy5sYXN0QW5jaG9yT2Zmc2V0ID0gc2VsLmFuY2hvck9mZnNldFxcbiAgdGhpcy5sYXN0Rm9jdXNOb2RlID0gc2VsLmZvY3VzTm9kZTsgdGhpcy5sYXN0Rm9jdXNPZmZzZXQgPSBzZWwuZm9jdXNPZmZzZXRcXG59O1xcblxcbkNvbnRlbnRFZGl0YWJsZUlucHV0LnByb3RvdHlwZS5zZWxlY3Rpb25JbkVkaXRvciA9IGZ1bmN0aW9uICgpIHtcXG4gIHZhciBzZWwgPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKClcXG4gIGlmICghc2VsLnJhbmdlQ291bnQpIHsgcmV0dXJuIGZhbHNlIH1cXG4gIHZhciBub2RlID0gc2VsLmdldFJhbmdlQXQoMCkuY29tbW9uQW5jZXN0b3JDb250YWluZXJcXG4gIHJldHVybiBjb250YWlucyh0aGlzLmRpdiwgbm9kZSlcXG59O1xcblxcbkNvbnRlbnRFZGl0YWJsZUlucHV0LnByb3RvdHlwZS5mb2N1cyA9IGZ1bmN0aW9uICgpIHtcXG4gIGlmICh0aGlzLmNtLm9wdGlvbnMucmVhZE9ubHkgIT0gXFxcIm5vY3Vyc29yXFxcIikge1xcbiAgICBpZiAoIXRoaXMuc2VsZWN0aW9uSW5FZGl0b3IoKSlcXG4gICAgICB7IHRoaXMuc2hvd1NlbGVjdGlvbih0aGlzLnByZXBhcmVTZWxlY3Rpb24oKSwgdHJ1ZSkgfVxcbiAgICB0aGlzLmRpdi5mb2N1cygpXFxuICB9XFxufTtcXG5Db250ZW50RWRpdGFibGVJbnB1dC5wcm90b3R5cGUuYmx1ciA9IGZ1bmN0aW9uICgpIHsgdGhpcy5kaXYuYmx1cigpIH07XFxuQ29udGVudEVkaXRhYmxlSW5wdXQucHJvdG90eXBlLmdldEZpZWxkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5kaXYgfTtcXG5cXG5Db250ZW50RWRpdGFibGVJbnB1dC5wcm90b3R5cGUuc3VwcG9ydHNUb3VjaCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRydWUgfTtcXG5cXG5Db250ZW50RWRpdGFibGVJbnB1dC5wcm90b3R5cGUucmVjZWl2ZWRGb2N1cyA9IGZ1bmN0aW9uICgpIHtcXG4gIHZhciBpbnB1dCA9IHRoaXNcXG4gIGlmICh0aGlzLnNlbGVjdGlvbkluRWRpdG9yKCkpXFxuICAgIHsgdGhpcy5wb2xsU2VsZWN0aW9uKCkgfVxcbiAgZWxzZVxcbiAgICB7IHJ1bkluT3AodGhpcy5jbSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5wdXQuY20uY3VyT3Auc2VsZWN0aW9uQ2hhbmdlZCA9IHRydWU7IH0pIH1cXG5cXG4gIGZ1bmN0aW9uIHBvbGwoKSB7XFxuICAgIGlmIChpbnB1dC5jbS5zdGF0ZS5mb2N1c2VkKSB7XFxuICAgICAgaW5wdXQucG9sbFNlbGVjdGlvbigpXFxuICAgICAgaW5wdXQucG9sbGluZy5zZXQoaW5wdXQuY20ub3B0aW9ucy5wb2xsSW50ZXJ2YWwsIHBvbGwpXFxuICAgIH1cXG4gIH1cXG4gIHRoaXMucG9sbGluZy5zZXQodGhpcy5jbS5vcHRpb25zLnBvbGxJbnRlcnZhbCwgcG9sbClcXG59O1xcblxcbkNvbnRlbnRFZGl0YWJsZUlucHV0LnByb3RvdHlwZS5zZWxlY3Rpb25DaGFuZ2VkID0gZnVuY3Rpb24gKCkge1xcbiAgdmFyIHNlbCA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKVxcbiAgcmV0dXJuIHNlbC5hbmNob3JOb2RlICE9IHRoaXMubGFzdEFuY2hvck5vZGUgfHwgc2VsLmFuY2hvck9mZnNldCAhPSB0aGlzLmxhc3RBbmNob3JPZmZzZXQgfHxcXG4gICAgc2VsLmZvY3VzTm9kZSAhPSB0aGlzLmxhc3RGb2N1c05vZGUgfHwgc2VsLmZvY3VzT2Zmc2V0ICE9IHRoaXMubGFzdEZvY3VzT2Zmc2V0XFxufTtcXG5cXG5Db250ZW50RWRpdGFibGVJbnB1dC5wcm90b3R5cGUucG9sbFNlbGVjdGlvbiA9IGZ1bmN0aW9uICgpIHtcXG4gIGlmICghdGhpcy5jb21wb3NpbmcgJiYgdGhpcy5yZWFkRE9NVGltZW91dCA9PSBudWxsICYmICF0aGlzLmdyYWNlUGVyaW9kICYmIHRoaXMuc2VsZWN0aW9uQ2hhbmdlZCgpKSB7XFxuICAgIHZhciBzZWwgPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCksIGNtID0gdGhpcy5jbVxcbiAgICB0aGlzLnJlbWVtYmVyU2VsZWN0aW9uKClcXG4gICAgdmFyIGFuY2hvciA9IGRvbVRvUG9zKGNtLCBzZWwuYW5jaG9yTm9kZSwgc2VsLmFuY2hvck9mZnNldClcXG4gICAgdmFyIGhlYWQgPSBkb21Ub1BvcyhjbSwgc2VsLmZvY3VzTm9kZSwgc2VsLmZvY3VzT2Zmc2V0KVxcbiAgICBpZiAoYW5jaG9yICYmIGhlYWQpIHsgcnVuSW5PcChjbSwgZnVuY3Rpb24gKCkge1xcbiAgICAgIHNldFNlbGVjdGlvbihjbS5kb2MsIHNpbXBsZVNlbGVjdGlvbihhbmNob3IsIGhlYWQpLCBzZWxfZG9udFNjcm9sbClcXG4gICAgICBpZiAoYW5jaG9yLmJhZCB8fCBoZWFkLmJhZCkgeyBjbS5jdXJPcC5zZWxlY3Rpb25DaGFuZ2VkID0gdHJ1ZSB9XFxuICAgIH0pIH1cXG4gIH1cXG59O1xcblxcbkNvbnRlbnRFZGl0YWJsZUlucHV0LnByb3RvdHlwZS5wb2xsQ29udGVudCA9IGZ1bmN0aW9uICgpIHtcXG4gIGlmICh0aGlzLnJlYWRET01UaW1lb3V0ICE9IG51bGwpIHtcXG4gICAgY2xlYXJUaW1lb3V0KHRoaXMucmVhZERPTVRpbWVvdXQpXFxuICAgIHRoaXMucmVhZERPTVRpbWVvdXQgPSBudWxsXFxuICB9XFxuXFxuICB2YXIgY20gPSB0aGlzLmNtLCBkaXNwbGF5ID0gY20uZGlzcGxheSwgc2VsID0gY20uZG9jLnNlbC5wcmltYXJ5KClcXG4gIHZhciBmcm9tID0gc2VsLmZyb20oKSwgdG8gPSBzZWwudG8oKVxcbiAgaWYgKGZyb20uY2ggPT0gMCAmJiBmcm9tLmxpbmUgPiBjbS5maXJzdExpbmUoKSlcXG4gICAgeyBmcm9tID0gUG9zKGZyb20ubGluZSAtIDEsIGdldExpbmUoY20uZG9jLCBmcm9tLmxpbmUgLSAxKS5sZW5ndGgpIH1cXG4gIGlmICh0by5jaCA9PSBnZXRMaW5lKGNtLmRvYywgdG8ubGluZSkudGV4dC5sZW5ndGggJiYgdG8ubGluZSA8IGNtLmxhc3RMaW5lKCkpXFxuICAgIHsgdG8gPSBQb3ModG8ubGluZSArIDEsIDApIH1cXG4gIGlmIChmcm9tLmxpbmUgPCBkaXNwbGF5LnZpZXdGcm9tIHx8IHRvLmxpbmUgPiBkaXNwbGF5LnZpZXdUbyAtIDEpIHsgcmV0dXJuIGZhbHNlIH1cXG5cXG4gIHZhciBmcm9tSW5kZXgsIGZyb21MaW5lLCBmcm9tTm9kZVxcbiAgaWYgKGZyb20ubGluZSA9PSBkaXNwbGF5LnZpZXdGcm9tIHx8IChmcm9tSW5kZXggPSBmaW5kVmlld0luZGV4KGNtLCBmcm9tLmxpbmUpKSA9PSAwKSB7XFxuICAgIGZyb21MaW5lID0gbGluZU5vKGRpc3BsYXkudmlld1swXS5saW5lKVxcbiAgICBmcm9tTm9kZSA9IGRpc3BsYXkudmlld1swXS5ub2RlXFxuICB9IGVsc2Uge1xcbiAgICBmcm9tTGluZSA9IGxpbmVObyhkaXNwbGF5LnZpZXdbZnJvbUluZGV4XS5saW5lKVxcbiAgICBmcm9tTm9kZSA9IGRpc3BsYXkudmlld1tmcm9tSW5kZXggLSAxXS5ub2RlLm5leHRTaWJsaW5nXFxuICB9XFxuICB2YXIgdG9JbmRleCA9IGZpbmRWaWV3SW5kZXgoY20sIHRvLmxpbmUpXFxuICB2YXIgdG9MaW5lLCB0b05vZGVcXG4gIGlmICh0b0luZGV4ID09IGRpc3BsYXkudmlldy5sZW5ndGggLSAxKSB7XFxuICAgIHRvTGluZSA9IGRpc3BsYXkudmlld1RvIC0gMVxcbiAgICB0b05vZGUgPSBkaXNwbGF5LmxpbmVEaXYubGFzdENoaWxkXFxuICB9IGVsc2Uge1xcbiAgICB0b0xpbmUgPSBsaW5lTm8oZGlzcGxheS52aWV3W3RvSW5kZXggKyAxXS5saW5lKSAtIDFcXG4gICAgdG9Ob2RlID0gZGlzcGxheS52aWV3W3RvSW5kZXggKyAxXS5ub2RlLnByZXZpb3VzU2libGluZ1xcbiAgfVxcblxcbiAgaWYgKCFmcm9tTm9kZSkgeyByZXR1cm4gZmFsc2UgfVxcbiAgdmFyIG5ld1RleHQgPSBjbS5kb2Muc3BsaXRMaW5lcyhkb21UZXh0QmV0d2VlbihjbSwgZnJvbU5vZGUsIHRvTm9kZSwgZnJvbUxpbmUsIHRvTGluZSkpXFxuICB2YXIgb2xkVGV4dCA9IGdldEJldHdlZW4oY20uZG9jLCBQb3MoZnJvbUxpbmUsIDApLCBQb3ModG9MaW5lLCBnZXRMaW5lKGNtLmRvYywgdG9MaW5lKS50ZXh0Lmxlbmd0aCkpXFxuICB3aGlsZSAobmV3VGV4dC5sZW5ndGggPiAxICYmIG9sZFRleHQubGVuZ3RoID4gMSkge1xcbiAgICBpZiAobHN0KG5ld1RleHQpID09IGxzdChvbGRUZXh0KSkgeyBuZXdUZXh0LnBvcCgpOyBvbGRUZXh0LnBvcCgpOyB0b0xpbmUtLSB9XFxuICAgIGVsc2UgaWYgKG5ld1RleHRbMF0gPT0gb2xkVGV4dFswXSkgeyBuZXdUZXh0LnNoaWZ0KCk7IG9sZFRleHQuc2hpZnQoKTsgZnJvbUxpbmUrKyB9XFxuICAgIGVsc2UgeyBicmVhayB9XFxuICB9XFxuXFxuICB2YXIgY3V0RnJvbnQgPSAwLCBjdXRFbmQgPSAwXFxuICB2YXIgbmV3VG9wID0gbmV3VGV4dFswXSwgb2xkVG9wID0gb2xkVGV4dFswXSwgbWF4Q3V0RnJvbnQgPSBNYXRoLm1pbihuZXdUb3AubGVuZ3RoLCBvbGRUb3AubGVuZ3RoKVxcbiAgd2hpbGUgKGN1dEZyb250IDwgbWF4Q3V0RnJvbnQgJiYgbmV3VG9wLmNoYXJDb2RlQXQoY3V0RnJvbnQpID09IG9sZFRvcC5jaGFyQ29kZUF0KGN1dEZyb250KSlcXG4gICAgeyArK2N1dEZyb250IH1cXG4gIHZhciBuZXdCb3QgPSBsc3QobmV3VGV4dCksIG9sZEJvdCA9IGxzdChvbGRUZXh0KVxcbiAgdmFyIG1heEN1dEVuZCA9IE1hdGgubWluKG5ld0JvdC5sZW5ndGggLSAobmV3VGV4dC5sZW5ndGggPT0gMSA/IGN1dEZyb250IDogMCksXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgb2xkQm90Lmxlbmd0aCAtIChvbGRUZXh0Lmxlbmd0aCA9PSAxID8gY3V0RnJvbnQgOiAwKSlcXG4gIHdoaWxlIChjdXRFbmQgPCBtYXhDdXRFbmQgJiZcXG4gICAgICAgICBuZXdCb3QuY2hhckNvZGVBdChuZXdCb3QubGVuZ3RoIC0gY3V0RW5kIC0gMSkgPT0gb2xkQm90LmNoYXJDb2RlQXQob2xkQm90Lmxlbmd0aCAtIGN1dEVuZCAtIDEpKVxcbiAgICB7ICsrY3V0RW5kIH1cXG5cXG4gIG5ld1RleHRbbmV3VGV4dC5sZW5ndGggLSAxXSA9IG5ld0JvdC5zbGljZSgwLCBuZXdCb3QubGVuZ3RoIC0gY3V0RW5kKS5yZXBsYWNlKC9eXFxcXHUyMDBiKy8sIFxcXCJcXFwiKVxcbiAgbmV3VGV4dFswXSA9IG5ld1RleHRbMF0uc2xpY2UoY3V0RnJvbnQpLnJlcGxhY2UoL1xcXFx1MjAwYiskLywgXFxcIlxcXCIpXFxuXFxuICB2YXIgY2hGcm9tID0gUG9zKGZyb21MaW5lLCBjdXRGcm9udClcXG4gIHZhciBjaFRvID0gUG9zKHRvTGluZSwgb2xkVGV4dC5sZW5ndGggPyBsc3Qob2xkVGV4dCkubGVuZ3RoIC0gY3V0RW5kIDogMClcXG4gIGlmIChuZXdUZXh0Lmxlbmd0aCA+IDEgfHwgbmV3VGV4dFswXSB8fCBjbXAoY2hGcm9tLCBjaFRvKSkge1xcbiAgICByZXBsYWNlUmFuZ2UoY20uZG9jLCBuZXdUZXh0LCBjaEZyb20sIGNoVG8sIFxcXCIraW5wdXRcXFwiKVxcbiAgICByZXR1cm4gdHJ1ZVxcbiAgfVxcbn07XFxuXFxuQ29udGVudEVkaXRhYmxlSW5wdXQucHJvdG90eXBlLmVuc3VyZVBvbGxlZCA9IGZ1bmN0aW9uICgpIHtcXG4gIHRoaXMuZm9yY2VDb21wb3NpdGlvbkVuZCgpXFxufTtcXG5Db250ZW50RWRpdGFibGVJbnB1dC5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoKSB7XFxuICB0aGlzLmZvcmNlQ29tcG9zaXRpb25FbmQoKVxcbn07XFxuQ29udGVudEVkaXRhYmxlSW5wdXQucHJvdG90eXBlLmZvcmNlQ29tcG9zaXRpb25FbmQgPSBmdW5jdGlvbiAoKSB7XFxuICBpZiAoIXRoaXMuY29tcG9zaW5nKSB7IHJldHVybiB9XFxuICBjbGVhclRpbWVvdXQodGhpcy5yZWFkRE9NVGltZW91dClcXG4gIHRoaXMuY29tcG9zaW5nID0gbnVsbFxcbiAgaWYgKCF0aGlzLnBvbGxDb250ZW50KCkpIHsgcmVnQ2hhbmdlKHRoaXMuY20pIH1cXG4gIHRoaXMuZGl2LmJsdXIoKVxcbiAgdGhpcy5kaXYuZm9jdXMoKVxcbn07XFxuQ29udGVudEVkaXRhYmxlSW5wdXQucHJvdG90eXBlLnJlYWRGcm9tRE9NU29vbiA9IGZ1bmN0aW9uICgpIHtcXG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XFxuXFxuICBpZiAodGhpcy5yZWFkRE9NVGltZW91dCAhPSBudWxsKSB7IHJldHVybiB9XFxuICB0aGlzLnJlYWRET01UaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XFxuICAgIHRoaXMkMS5yZWFkRE9NVGltZW91dCA9IG51bGxcXG4gICAgaWYgKHRoaXMkMS5jb21wb3NpbmcpIHtcXG4gICAgICBpZiAodGhpcyQxLmNvbXBvc2luZy5kb25lKSB7IHRoaXMkMS5jb21wb3NpbmcgPSBudWxsIH1cXG4gICAgICBlbHNlIHsgcmV0dXJuIH1cXG4gICAgfVxcbiAgICBpZiAodGhpcyQxLmNtLmlzUmVhZE9ubHkoKSB8fCAhdGhpcyQxLnBvbGxDb250ZW50KCkpXFxuICAgICAgeyBydW5Jbk9wKHRoaXMkMS5jbSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVnQ2hhbmdlKHRoaXMkMS5jbSk7IH0pIH1cXG4gIH0sIDgwKVxcbn07XFxuXFxuQ29udGVudEVkaXRhYmxlSW5wdXQucHJvdG90eXBlLnNldFVuZWRpdGFibGUgPSBmdW5jdGlvbiAobm9kZSkge1xcbiAgbm9kZS5jb250ZW50RWRpdGFibGUgPSBcXFwiZmFsc2VcXFwiXFxufTtcXG5cXG5Db250ZW50RWRpdGFibGVJbnB1dC5wcm90b3R5cGUub25LZXlQcmVzcyA9IGZ1bmN0aW9uIChlKSB7XFxuICBpZiAoZS5jaGFyQ29kZSA9PSAwKSB7IHJldHVybiB9XFxuICBlLnByZXZlbnREZWZhdWx0KClcXG4gIGlmICghdGhpcy5jbS5pc1JlYWRPbmx5KCkpXFxuICAgIHsgb3BlcmF0aW9uKHRoaXMuY20sIGFwcGx5VGV4dElucHV0KSh0aGlzLmNtLCBTdHJpbmcuZnJvbUNoYXJDb2RlKGUuY2hhckNvZGUgPT0gbnVsbCA/IGUua2V5Q29kZSA6IGUuY2hhckNvZGUpLCAwKSB9XFxufTtcXG5cXG5Db250ZW50RWRpdGFibGVJbnB1dC5wcm90b3R5cGUucmVhZE9ubHlDaGFuZ2VkID0gZnVuY3Rpb24gKHZhbCkge1xcbiAgdGhpcy5kaXYuY29udGVudEVkaXRhYmxlID0gU3RyaW5nKHZhbCAhPSBcXFwibm9jdXJzb3JcXFwiKVxcbn07XFxuXFxuQ29udGVudEVkaXRhYmxlSW5wdXQucHJvdG90eXBlLm9uQ29udGV4dE1lbnUgPSBmdW5jdGlvbiAoKSB7fTtcXG5Db250ZW50RWRpdGFibGVJbnB1dC5wcm90b3R5cGUucmVzZXRQb3NpdGlvbiA9IGZ1bmN0aW9uICgpIHt9O1xcblxcbkNvbnRlbnRFZGl0YWJsZUlucHV0LnByb3RvdHlwZS5uZWVkc0NvbnRlbnRBdHRyaWJ1dGUgPSB0cnVlXFxuXFxuZnVuY3Rpb24gcG9zVG9ET00oY20sIHBvcykge1xcbiAgdmFyIHZpZXcgPSBmaW5kVmlld0ZvckxpbmUoY20sIHBvcy5saW5lKVxcbiAgaWYgKCF2aWV3IHx8IHZpZXcuaGlkZGVuKSB7IHJldHVybiBudWxsIH1cXG4gIHZhciBsaW5lID0gZ2V0TGluZShjbS5kb2MsIHBvcy5saW5lKVxcbiAgdmFyIGluZm8gPSBtYXBGcm9tTGluZVZpZXcodmlldywgbGluZSwgcG9zLmxpbmUpXFxuXFxuICB2YXIgb3JkZXIgPSBnZXRPcmRlcihsaW5lKSwgc2lkZSA9IFxcXCJsZWZ0XFxcIlxcbiAgaWYgKG9yZGVyKSB7XFxuICAgIHZhciBwYXJ0UG9zID0gZ2V0QmlkaVBhcnRBdChvcmRlciwgcG9zLmNoKVxcbiAgICBzaWRlID0gcGFydFBvcyAlIDIgPyBcXFwicmlnaHRcXFwiIDogXFxcImxlZnRcXFwiXFxuICB9XFxuICB2YXIgcmVzdWx0ID0gbm9kZUFuZE9mZnNldEluTGluZU1hcChpbmZvLm1hcCwgcG9zLmNoLCBzaWRlKVxcbiAgcmVzdWx0Lm9mZnNldCA9IHJlc3VsdC5jb2xsYXBzZSA9PSBcXFwicmlnaHRcXFwiID8gcmVzdWx0LmVuZCA6IHJlc3VsdC5zdGFydFxcbiAgcmV0dXJuIHJlc3VsdFxcbn1cXG5cXG5mdW5jdGlvbiBiYWRQb3MocG9zLCBiYWQpIHsgaWYgKGJhZCkgeyBwb3MuYmFkID0gdHJ1ZTsgfSByZXR1cm4gcG9zIH1cXG5cXG5mdW5jdGlvbiBkb21UZXh0QmV0d2VlbihjbSwgZnJvbSwgdG8sIGZyb21MaW5lLCB0b0xpbmUpIHtcXG4gIHZhciB0ZXh0ID0gXFxcIlxcXCIsIGNsb3NpbmcgPSBmYWxzZSwgbGluZVNlcCA9IGNtLmRvYy5saW5lU2VwYXJhdG9yKClcXG4gIGZ1bmN0aW9uIHJlY29nbml6ZU1hcmtlcihpZCkgeyByZXR1cm4gZnVuY3Rpb24gKG1hcmtlcikgeyByZXR1cm4gbWFya2VyLmlkID09IGlkOyB9IH1cXG4gIGZ1bmN0aW9uIHdhbGsobm9kZSkge1xcbiAgICBpZiAobm9kZS5ub2RlVHlwZSA9PSAxKSB7XFxuICAgICAgdmFyIGNtVGV4dCA9IG5vZGUuZ2V0QXR0cmlidXRlKFxcXCJjbS10ZXh0XFxcIilcXG4gICAgICBpZiAoY21UZXh0ICE9IG51bGwpIHtcXG4gICAgICAgIGlmIChjbVRleHQgPT0gXFxcIlxcXCIpIHsgdGV4dCArPSBub2RlLnRleHRDb250ZW50LnJlcGxhY2UoL1xcXFx1MjAwYi9nLCBcXFwiXFxcIikgfVxcbiAgICAgICAgZWxzZSB7IHRleHQgKz0gY21UZXh0IH1cXG4gICAgICAgIHJldHVyblxcbiAgICAgIH1cXG4gICAgICB2YXIgbWFya2VySUQgPSBub2RlLmdldEF0dHJpYnV0ZShcXFwiY20tbWFya2VyXFxcIiksIHJhbmdlXFxuICAgICAgaWYgKG1hcmtlcklEKSB7XFxuICAgICAgICB2YXIgZm91bmQgPSBjbS5maW5kTWFya3MoUG9zKGZyb21MaW5lLCAwKSwgUG9zKHRvTGluZSArIDEsIDApLCByZWNvZ25pemVNYXJrZXIoK21hcmtlcklEKSlcXG4gICAgICAgIGlmIChmb3VuZC5sZW5ndGggJiYgKHJhbmdlID0gZm91bmRbMF0uZmluZCgpKSlcXG4gICAgICAgICAgeyB0ZXh0ICs9IGdldEJldHdlZW4oY20uZG9jLCByYW5nZS5mcm9tLCByYW5nZS50bykuam9pbihsaW5lU2VwKSB9XFxuICAgICAgICByZXR1cm5cXG4gICAgICB9XFxuICAgICAgaWYgKG5vZGUuZ2V0QXR0cmlidXRlKFxcXCJjb250ZW50ZWRpdGFibGVcXFwiKSA9PSBcXFwiZmFsc2VcXFwiKSB7IHJldHVybiB9XFxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLmNoaWxkTm9kZXMubGVuZ3RoOyBpKyspXFxuICAgICAgICB7IHdhbGsobm9kZS5jaGlsZE5vZGVzW2ldKSB9XFxuICAgICAgaWYgKC9eKHByZXxkaXZ8cCkkL2kudGVzdChub2RlLm5vZGVOYW1lKSlcXG4gICAgICAgIHsgY2xvc2luZyA9IHRydWUgfVxcbiAgICB9IGVsc2UgaWYgKG5vZGUubm9kZVR5cGUgPT0gMykge1xcbiAgICAgIHZhciB2YWwgPSBub2RlLm5vZGVWYWx1ZVxcbiAgICAgIGlmICghdmFsKSB7IHJldHVybiB9XFxuICAgICAgaWYgKGNsb3NpbmcpIHtcXG4gICAgICAgIHRleHQgKz0gbGluZVNlcFxcbiAgICAgICAgY2xvc2luZyA9IGZhbHNlXFxuICAgICAgfVxcbiAgICAgIHRleHQgKz0gdmFsXFxuICAgIH1cXG4gIH1cXG4gIGZvciAoOzspIHtcXG4gICAgd2Fsayhmcm9tKVxcbiAgICBpZiAoZnJvbSA9PSB0bykgeyBicmVhayB9XFxuICAgIGZyb20gPSBmcm9tLm5leHRTaWJsaW5nXFxuICB9XFxuICByZXR1cm4gdGV4dFxcbn1cXG5cXG5mdW5jdGlvbiBkb21Ub1BvcyhjbSwgbm9kZSwgb2Zmc2V0KSB7XFxuICB2YXIgbGluZU5vZGVcXG4gIGlmIChub2RlID09IGNtLmRpc3BsYXkubGluZURpdikge1xcbiAgICBsaW5lTm9kZSA9IGNtLmRpc3BsYXkubGluZURpdi5jaGlsZE5vZGVzW29mZnNldF1cXG4gICAgaWYgKCFsaW5lTm9kZSkgeyByZXR1cm4gYmFkUG9zKGNtLmNsaXBQb3MoUG9zKGNtLmRpc3BsYXkudmlld1RvIC0gMSkpLCB0cnVlKSB9XFxuICAgIG5vZGUgPSBudWxsOyBvZmZzZXQgPSAwXFxuICB9IGVsc2Uge1xcbiAgICBmb3IgKGxpbmVOb2RlID0gbm9kZTs7IGxpbmVOb2RlID0gbGluZU5vZGUucGFyZW50Tm9kZSkge1xcbiAgICAgIGlmICghbGluZU5vZGUgfHwgbGluZU5vZGUgPT0gY20uZGlzcGxheS5saW5lRGl2KSB7IHJldHVybiBudWxsIH1cXG4gICAgICBpZiAobGluZU5vZGUucGFyZW50Tm9kZSAmJiBsaW5lTm9kZS5wYXJlbnROb2RlID09IGNtLmRpc3BsYXkubGluZURpdikgeyBicmVhayB9XFxuICAgIH1cXG4gIH1cXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY20uZGlzcGxheS52aWV3Lmxlbmd0aDsgaSsrKSB7XFxuICAgIHZhciBsaW5lVmlldyA9IGNtLmRpc3BsYXkudmlld1tpXVxcbiAgICBpZiAobGluZVZpZXcubm9kZSA9PSBsaW5lTm9kZSlcXG4gICAgICB7IHJldHVybiBsb2NhdGVOb2RlSW5MaW5lVmlldyhsaW5lVmlldywgbm9kZSwgb2Zmc2V0KSB9XFxuICB9XFxufVxcblxcbmZ1bmN0aW9uIGxvY2F0ZU5vZGVJbkxpbmVWaWV3KGxpbmVWaWV3LCBub2RlLCBvZmZzZXQpIHtcXG4gIHZhciB3cmFwcGVyID0gbGluZVZpZXcudGV4dC5maXJzdENoaWxkLCBiYWQgPSBmYWxzZVxcbiAgaWYgKCFub2RlIHx8ICFjb250YWlucyh3cmFwcGVyLCBub2RlKSkgeyByZXR1cm4gYmFkUG9zKFBvcyhsaW5lTm8obGluZVZpZXcubGluZSksIDApLCB0cnVlKSB9XFxuICBpZiAobm9kZSA9PSB3cmFwcGVyKSB7XFxuICAgIGJhZCA9IHRydWVcXG4gICAgbm9kZSA9IHdyYXBwZXIuY2hpbGROb2Rlc1tvZmZzZXRdXFxuICAgIG9mZnNldCA9IDBcXG4gICAgaWYgKCFub2RlKSB7XFxuICAgICAgdmFyIGxpbmUgPSBsaW5lVmlldy5yZXN0ID8gbHN0KGxpbmVWaWV3LnJlc3QpIDogbGluZVZpZXcubGluZVxcbiAgICAgIHJldHVybiBiYWRQb3MoUG9zKGxpbmVObyhsaW5lKSwgbGluZS50ZXh0Lmxlbmd0aCksIGJhZClcXG4gICAgfVxcbiAgfVxcblxcbiAgdmFyIHRleHROb2RlID0gbm9kZS5ub2RlVHlwZSA9PSAzID8gbm9kZSA6IG51bGwsIHRvcE5vZGUgPSBub2RlXFxuICBpZiAoIXRleHROb2RlICYmIG5vZGUuY2hpbGROb2Rlcy5sZW5ndGggPT0gMSAmJiBub2RlLmZpcnN0Q2hpbGQubm9kZVR5cGUgPT0gMykge1xcbiAgICB0ZXh0Tm9kZSA9IG5vZGUuZmlyc3RDaGlsZFxcbiAgICBpZiAob2Zmc2V0KSB7IG9mZnNldCA9IHRleHROb2RlLm5vZGVWYWx1ZS5sZW5ndGggfVxcbiAgfVxcbiAgd2hpbGUgKHRvcE5vZGUucGFyZW50Tm9kZSAhPSB3cmFwcGVyKSB7IHRvcE5vZGUgPSB0b3BOb2RlLnBhcmVudE5vZGUgfVxcbiAgdmFyIG1lYXN1cmUgPSBsaW5lVmlldy5tZWFzdXJlLCBtYXBzID0gbWVhc3VyZS5tYXBzXFxuXFxuICBmdW5jdGlvbiBmaW5kKHRleHROb2RlLCB0b3BOb2RlLCBvZmZzZXQpIHtcXG4gICAgZm9yICh2YXIgaSA9IC0xOyBpIDwgKG1hcHMgPyBtYXBzLmxlbmd0aCA6IDApOyBpKyspIHtcXG4gICAgICB2YXIgbWFwID0gaSA8IDAgPyBtZWFzdXJlLm1hcCA6IG1hcHNbaV1cXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG1hcC5sZW5ndGg7IGogKz0gMykge1xcbiAgICAgICAgdmFyIGN1ck5vZGUgPSBtYXBbaiArIDJdXFxuICAgICAgICBpZiAoY3VyTm9kZSA9PSB0ZXh0Tm9kZSB8fCBjdXJOb2RlID09IHRvcE5vZGUpIHtcXG4gICAgICAgICAgdmFyIGxpbmUgPSBsaW5lTm8oaSA8IDAgPyBsaW5lVmlldy5saW5lIDogbGluZVZpZXcucmVzdFtpXSlcXG4gICAgICAgICAgdmFyIGNoID0gbWFwW2pdICsgb2Zmc2V0XFxuICAgICAgICAgIGlmIChvZmZzZXQgPCAwIHx8IGN1ck5vZGUgIT0gdGV4dE5vZGUpIHsgY2ggPSBtYXBbaiArIChvZmZzZXQgPyAxIDogMCldIH1cXG4gICAgICAgICAgcmV0dXJuIFBvcyhsaW5lLCBjaClcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIH1cXG4gIH1cXG4gIHZhciBmb3VuZCA9IGZpbmQodGV4dE5vZGUsIHRvcE5vZGUsIG9mZnNldClcXG4gIGlmIChmb3VuZCkgeyByZXR1cm4gYmFkUG9zKGZvdW5kLCBiYWQpIH1cXG5cXG4gIC8vIEZJWE1FIHRoaXMgaXMgYWxsIHJlYWxseSBzaGFreS4gbWlnaHQgaGFuZGxlIHRoZSBmZXcgY2FzZXMgaXQgbmVlZHMgdG8gaGFuZGxlLCBidXQgbGlrZWx5IHRvIGNhdXNlIHByb2JsZW1zXFxuICBmb3IgKHZhciBhZnRlciA9IHRvcE5vZGUubmV4dFNpYmxpbmcsIGRpc3QgPSB0ZXh0Tm9kZSA/IHRleHROb2RlLm5vZGVWYWx1ZS5sZW5ndGggLSBvZmZzZXQgOiAwOyBhZnRlcjsgYWZ0ZXIgPSBhZnRlci5uZXh0U2libGluZykge1xcbiAgICBmb3VuZCA9IGZpbmQoYWZ0ZXIsIGFmdGVyLmZpcnN0Q2hpbGQsIDApXFxuICAgIGlmIChmb3VuZClcXG4gICAgICB7IHJldHVybiBiYWRQb3MoUG9zKGZvdW5kLmxpbmUsIGZvdW5kLmNoIC0gZGlzdCksIGJhZCkgfVxcbiAgICBlbHNlXFxuICAgICAgeyBkaXN0ICs9IGFmdGVyLnRleHRDb250ZW50Lmxlbmd0aCB9XFxuICB9XFxuICBmb3IgKHZhciBiZWZvcmUgPSB0b3BOb2RlLnByZXZpb3VzU2libGluZywgZGlzdCQxID0gb2Zmc2V0OyBiZWZvcmU7IGJlZm9yZSA9IGJlZm9yZS5wcmV2aW91c1NpYmxpbmcpIHtcXG4gICAgZm91bmQgPSBmaW5kKGJlZm9yZSwgYmVmb3JlLmZpcnN0Q2hpbGQsIC0xKVxcbiAgICBpZiAoZm91bmQpXFxuICAgICAgeyByZXR1cm4gYmFkUG9zKFBvcyhmb3VuZC5saW5lLCBmb3VuZC5jaCArIGRpc3QkMSksIGJhZCkgfVxcbiAgICBlbHNlXFxuICAgICAgeyBkaXN0JDEgKz0gYmVmb3JlLnRleHRDb250ZW50Lmxlbmd0aCB9XFxuICB9XFxufVxcblxcbi8vIFRFWFRBUkVBIElOUFVUIFNUWUxFXFxuXFxudmFyIFRleHRhcmVhSW5wdXQgPSBmdW5jdGlvbihjbSkge1xcbiAgdGhpcy5jbSA9IGNtXFxuICAvLyBTZWUgaW5wdXQucG9sbCBhbmQgaW5wdXQucmVzZXRcXG4gIHRoaXMucHJldklucHV0ID0gXFxcIlxcXCJcXG5cXG4gIC8vIEZsYWcgdGhhdCBpbmRpY2F0ZXMgd2hldGhlciB3ZSBleHBlY3QgaW5wdXQgdG8gYXBwZWFyIHJlYWwgc29vblxcbiAgLy8gbm93IChhZnRlciBzb21lIGV2ZW50IGxpa2UgJ2tleXByZXNzJyBvciAnaW5wdXQnKSBhbmQgYXJlXFxuICAvLyBwb2xsaW5nIGludGVuc2l2ZWx5LlxcbiAgdGhpcy5wb2xsaW5nRmFzdCA9IGZhbHNlXFxuICAvLyBTZWxmLXJlc2V0dGluZyB0aW1lb3V0IGZvciB0aGUgcG9sbGVyXFxuICB0aGlzLnBvbGxpbmcgPSBuZXcgRGVsYXllZCgpXFxuICAvLyBUcmFja3Mgd2hlbiBpbnB1dC5yZXNldCBoYXMgcHVudGVkIHRvIGp1c3QgcHV0dGluZyBhIHNob3J0XFxuICAvLyBzdHJpbmcgaW50byB0aGUgdGV4dGFyZWEgaW5zdGVhZCBvZiB0aGUgZnVsbCBzZWxlY3Rpb24uXFxuICB0aGlzLmluYWNjdXJhdGVTZWxlY3Rpb24gPSBmYWxzZVxcbiAgLy8gVXNlZCB0byB3b3JrIGFyb3VuZCBJRSBpc3N1ZSB3aXRoIHNlbGVjdGlvbiBiZWluZyBmb3Jnb3R0ZW4gd2hlbiBmb2N1cyBtb3ZlcyBhd2F5IGZyb20gdGV4dGFyZWFcXG4gIHRoaXMuaGFzU2VsZWN0aW9uID0gZmFsc2VcXG4gIHRoaXMuY29tcG9zaW5nID0gbnVsbFxcbn07XFxuXFxuVGV4dGFyZWFJbnB1dC5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uIChkaXNwbGF5KSB7XFxuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xcblxcbiAgdmFyIGlucHV0ID0gdGhpcywgY20gPSB0aGlzLmNtXFxuXFxuICAvLyBXcmFwcyBhbmQgaGlkZXMgaW5wdXQgdGV4dGFyZWFcXG4gIHZhciBkaXYgPSB0aGlzLndyYXBwZXIgPSBoaWRkZW5UZXh0YXJlYSgpXFxuICAvLyBUaGUgc2VtaWhpZGRlbiB0ZXh0YXJlYSB0aGF0IGlzIGZvY3VzZWQgd2hlbiB0aGUgZWRpdG9yIGlzXFxuICAvLyBmb2N1c2VkLCBhbmQgcmVjZWl2ZXMgaW5wdXQuXFxuICB2YXIgdGUgPSB0aGlzLnRleHRhcmVhID0gZGl2LmZpcnN0Q2hpbGRcXG4gIGRpc3BsYXkud3JhcHBlci5pbnNlcnRCZWZvcmUoZGl2LCBkaXNwbGF5LndyYXBwZXIuZmlyc3RDaGlsZClcXG5cXG4gIC8vIE5lZWRlZCB0byBoaWRlIGJpZyBibHVlIGJsaW5raW5nIGN1cnNvciBvbiBNb2JpbGUgU2FmYXJpIChkb2Vzbid0IHNlZW0gdG8gd29yayBpbiBpT1MgOCBhbnltb3JlKVxcbiAgaWYgKGlvcykgeyB0ZS5zdHlsZS53aWR0aCA9IFxcXCIwcHhcXFwiIH1cXG5cXG4gIG9uKHRlLCBcXFwiaW5wdXRcXFwiLCBmdW5jdGlvbiAoKSB7XFxuICAgIGlmIChpZSAmJiBpZV92ZXJzaW9uID49IDkgJiYgdGhpcyQxLmhhc1NlbGVjdGlvbikgeyB0aGlzJDEuaGFzU2VsZWN0aW9uID0gbnVsbCB9XFxuICAgIGlucHV0LnBvbGwoKVxcbiAgfSlcXG5cXG4gIG9uKHRlLCBcXFwicGFzdGVcXFwiLCBmdW5jdGlvbiAoZSkge1xcbiAgICBpZiAoc2lnbmFsRE9NRXZlbnQoY20sIGUpIHx8IGhhbmRsZVBhc3RlKGUsIGNtKSkgeyByZXR1cm4gfVxcblxcbiAgICBjbS5zdGF0ZS5wYXN0ZUluY29taW5nID0gdHJ1ZVxcbiAgICBpbnB1dC5mYXN0UG9sbCgpXFxuICB9KVxcblxcbiAgZnVuY3Rpb24gcHJlcGFyZUNvcHlDdXQoZSkge1xcbiAgICBpZiAoc2lnbmFsRE9NRXZlbnQoY20sIGUpKSB7IHJldHVybiB9XFxuICAgIGlmIChjbS5zb21ldGhpbmdTZWxlY3RlZCgpKSB7XFxuICAgICAgc2V0TGFzdENvcGllZCh7bGluZVdpc2U6IGZhbHNlLCB0ZXh0OiBjbS5nZXRTZWxlY3Rpb25zKCl9KVxcbiAgICAgIGlmIChpbnB1dC5pbmFjY3VyYXRlU2VsZWN0aW9uKSB7XFxuICAgICAgICBpbnB1dC5wcmV2SW5wdXQgPSBcXFwiXFxcIlxcbiAgICAgICAgaW5wdXQuaW5hY2N1cmF0ZVNlbGVjdGlvbiA9IGZhbHNlXFxuICAgICAgICB0ZS52YWx1ZSA9IGxhc3RDb3BpZWQudGV4dC5qb2luKFxcXCJcXFxcblxcXCIpXFxuICAgICAgICBzZWxlY3RJbnB1dCh0ZSlcXG4gICAgICB9XFxuICAgIH0gZWxzZSBpZiAoIWNtLm9wdGlvbnMubGluZVdpc2VDb3B5Q3V0KSB7XFxuICAgICAgcmV0dXJuXFxuICAgIH0gZWxzZSB7XFxuICAgICAgdmFyIHJhbmdlcyA9IGNvcHlhYmxlUmFuZ2VzKGNtKVxcbiAgICAgIHNldExhc3RDb3BpZWQoe2xpbmVXaXNlOiB0cnVlLCB0ZXh0OiByYW5nZXMudGV4dH0pXFxuICAgICAgaWYgKGUudHlwZSA9PSBcXFwiY3V0XFxcIikge1xcbiAgICAgICAgY20uc2V0U2VsZWN0aW9ucyhyYW5nZXMucmFuZ2VzLCBudWxsLCBzZWxfZG9udFNjcm9sbClcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgaW5wdXQucHJldklucHV0ID0gXFxcIlxcXCJcXG4gICAgICAgIHRlLnZhbHVlID0gcmFuZ2VzLnRleHQuam9pbihcXFwiXFxcXG5cXFwiKVxcbiAgICAgICAgc2VsZWN0SW5wdXQodGUpXFxuICAgICAgfVxcbiAgICB9XFxuICAgIGlmIChlLnR5cGUgPT0gXFxcImN1dFxcXCIpIHsgY20uc3RhdGUuY3V0SW5jb21pbmcgPSB0cnVlIH1cXG4gIH1cXG4gIG9uKHRlLCBcXFwiY3V0XFxcIiwgcHJlcGFyZUNvcHlDdXQpXFxuICBvbih0ZSwgXFxcImNvcHlcXFwiLCBwcmVwYXJlQ29weUN1dClcXG5cXG4gIG9uKGRpc3BsYXkuc2Nyb2xsZXIsIFxcXCJwYXN0ZVxcXCIsIGZ1bmN0aW9uIChlKSB7XFxuICAgIGlmIChldmVudEluV2lkZ2V0KGRpc3BsYXksIGUpIHx8IHNpZ25hbERPTUV2ZW50KGNtLCBlKSkgeyByZXR1cm4gfVxcbiAgICBjbS5zdGF0ZS5wYXN0ZUluY29taW5nID0gdHJ1ZVxcbiAgICBpbnB1dC5mb2N1cygpXFxuICB9KVxcblxcbiAgLy8gUHJldmVudCBub3JtYWwgc2VsZWN0aW9uIGluIHRoZSBlZGl0b3IgKHdlIGhhbmRsZSBvdXIgb3duKVxcbiAgb24oZGlzcGxheS5saW5lU3BhY2UsIFxcXCJzZWxlY3RzdGFydFxcXCIsIGZ1bmN0aW9uIChlKSB7XFxuICAgIGlmICghZXZlbnRJbldpZGdldChkaXNwbGF5LCBlKSkgeyBlX3ByZXZlbnREZWZhdWx0KGUpIH1cXG4gIH0pXFxuXFxuICBvbih0ZSwgXFxcImNvbXBvc2l0aW9uc3RhcnRcXFwiLCBmdW5jdGlvbiAoKSB7XFxuICAgIHZhciBzdGFydCA9IGNtLmdldEN1cnNvcihcXFwiZnJvbVxcXCIpXFxuICAgIGlmIChpbnB1dC5jb21wb3NpbmcpIHsgaW5wdXQuY29tcG9zaW5nLnJhbmdlLmNsZWFyKCkgfVxcbiAgICBpbnB1dC5jb21wb3NpbmcgPSB7XFxuICAgICAgc3RhcnQ6IHN0YXJ0LFxcbiAgICAgIHJhbmdlOiBjbS5tYXJrVGV4dChzdGFydCwgY20uZ2V0Q3Vyc29yKFxcXCJ0b1xcXCIpLCB7Y2xhc3NOYW1lOiBcXFwiQ29kZU1pcnJvci1jb21wb3NpbmdcXFwifSlcXG4gICAgfVxcbiAgfSlcXG4gIG9uKHRlLCBcXFwiY29tcG9zaXRpb25lbmRcXFwiLCBmdW5jdGlvbiAoKSB7XFxuICAgIGlmIChpbnB1dC5jb21wb3NpbmcpIHtcXG4gICAgICBpbnB1dC5wb2xsKClcXG4gICAgICBpbnB1dC5jb21wb3NpbmcucmFuZ2UuY2xlYXIoKVxcbiAgICAgIGlucHV0LmNvbXBvc2luZyA9IG51bGxcXG4gICAgfVxcbiAgfSlcXG59O1xcblxcblRleHRhcmVhSW5wdXQucHJvdG90eXBlLnByZXBhcmVTZWxlY3Rpb24gPSBmdW5jdGlvbiAoKSB7XFxuICAvLyBSZWRyYXcgdGhlIHNlbGVjdGlvbiBhbmQvb3IgY3Vyc29yXFxuICB2YXIgY20gPSB0aGlzLmNtLCBkaXNwbGF5ID0gY20uZGlzcGxheSwgZG9jID0gY20uZG9jXFxuICB2YXIgcmVzdWx0ID0gcHJlcGFyZVNlbGVjdGlvbihjbSlcXG5cXG4gIC8vIE1vdmUgdGhlIGhpZGRlbiB0ZXh0YXJlYSBuZWFyIHRoZSBjdXJzb3IgdG8gcHJldmVudCBzY3JvbGxpbmcgYXJ0aWZhY3RzXFxuICBpZiAoY20ub3B0aW9ucy5tb3ZlSW5wdXRXaXRoQ3Vyc29yKSB7XFxuICAgIHZhciBoZWFkUG9zID0gY3Vyc29yQ29vcmRzKGNtLCBkb2Muc2VsLnByaW1hcnkoKS5oZWFkLCBcXFwiZGl2XFxcIilcXG4gICAgdmFyIHdyYXBPZmYgPSBkaXNwbGF5LndyYXBwZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIGxpbmVPZmYgPSBkaXNwbGF5LmxpbmVEaXYuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClcXG4gICAgcmVzdWx0LnRlVG9wID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oZGlzcGxheS53cmFwcGVyLmNsaWVudEhlaWdodCAtIDEwLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWFkUG9zLnRvcCArIGxpbmVPZmYudG9wIC0gd3JhcE9mZi50b3ApKVxcbiAgICByZXN1bHQudGVMZWZ0ID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oZGlzcGxheS53cmFwcGVyLmNsaWVudFdpZHRoIC0gMTAsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWFkUG9zLmxlZnQgKyBsaW5lT2ZmLmxlZnQgLSB3cmFwT2ZmLmxlZnQpKVxcbiAgfVxcblxcbiAgcmV0dXJuIHJlc3VsdFxcbn07XFxuXFxuVGV4dGFyZWFJbnB1dC5wcm90b3R5cGUuc2hvd1NlbGVjdGlvbiA9IGZ1bmN0aW9uIChkcmF3bikge1xcbiAgdmFyIGNtID0gdGhpcy5jbSwgZGlzcGxheSA9IGNtLmRpc3BsYXlcXG4gIHJlbW92ZUNoaWxkcmVuQW5kQWRkKGRpc3BsYXkuY3Vyc29yRGl2LCBkcmF3bi5jdXJzb3JzKVxcbiAgcmVtb3ZlQ2hpbGRyZW5BbmRBZGQoZGlzcGxheS5zZWxlY3Rpb25EaXYsIGRyYXduLnNlbGVjdGlvbilcXG4gIGlmIChkcmF3bi50ZVRvcCAhPSBudWxsKSB7XFxuICAgIHRoaXMud3JhcHBlci5zdHlsZS50b3AgPSBkcmF3bi50ZVRvcCArIFxcXCJweFxcXCJcXG4gICAgdGhpcy53cmFwcGVyLnN0eWxlLmxlZnQgPSBkcmF3bi50ZUxlZnQgKyBcXFwicHhcXFwiXFxuICB9XFxufTtcXG5cXG4vLyBSZXNldCB0aGUgaW5wdXQgdG8gY29ycmVzcG9uZCB0byB0aGUgc2VsZWN0aW9uIChvciB0byBiZSBlbXB0eSxcXG4vLyB3aGVuIG5vdCB0eXBpbmcgYW5kIG5vdGhpbmcgaXMgc2VsZWN0ZWQpXFxuVGV4dGFyZWFJbnB1dC5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAodHlwaW5nKSB7XFxuICBpZiAodGhpcy5jb250ZXh0TWVudVBlbmRpbmcpIHsgcmV0dXJuIH1cXG4gIHZhciBtaW5pbWFsLCBzZWxlY3RlZCwgY20gPSB0aGlzLmNtLCBkb2MgPSBjbS5kb2NcXG4gIGlmIChjbS5zb21ldGhpbmdTZWxlY3RlZCgpKSB7XFxuICAgIHRoaXMucHJldklucHV0ID0gXFxcIlxcXCJcXG4gICAgdmFyIHJhbmdlID0gZG9jLnNlbC5wcmltYXJ5KClcXG4gICAgbWluaW1hbCA9IGhhc0NvcHlFdmVudCAmJlxcbiAgICAgIChyYW5nZS50bygpLmxpbmUgLSByYW5nZS5mcm9tKCkubGluZSA+IDEwMCB8fCAoc2VsZWN0ZWQgPSBjbS5nZXRTZWxlY3Rpb24oKSkubGVuZ3RoID4gMTAwMClcXG4gICAgdmFyIGNvbnRlbnQgPSBtaW5pbWFsID8gXFxcIi1cXFwiIDogc2VsZWN0ZWQgfHwgY20uZ2V0U2VsZWN0aW9uKClcXG4gICAgdGhpcy50ZXh0YXJlYS52YWx1ZSA9IGNvbnRlbnRcXG4gICAgaWYgKGNtLnN0YXRlLmZvY3VzZWQpIHsgc2VsZWN0SW5wdXQodGhpcy50ZXh0YXJlYSkgfVxcbiAgICBpZiAoaWUgJiYgaWVfdmVyc2lvbiA+PSA5KSB7IHRoaXMuaGFzU2VsZWN0aW9uID0gY29udGVudCB9XFxuICB9IGVsc2UgaWYgKCF0eXBpbmcpIHtcXG4gICAgdGhpcy5wcmV2SW5wdXQgPSB0aGlzLnRleHRhcmVhLnZhbHVlID0gXFxcIlxcXCJcXG4gICAgaWYgKGllICYmIGllX3ZlcnNpb24gPj0gOSkgeyB0aGlzLmhhc1NlbGVjdGlvbiA9IG51bGwgfVxcbiAgfVxcbiAgdGhpcy5pbmFjY3VyYXRlU2VsZWN0aW9uID0gbWluaW1hbFxcbn07XFxuXFxuVGV4dGFyZWFJbnB1dC5wcm90b3R5cGUuZ2V0RmllbGQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLnRleHRhcmVhIH07XFxuXFxuVGV4dGFyZWFJbnB1dC5wcm90b3R5cGUuc3VwcG9ydHNUb3VjaCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZhbHNlIH07XFxuXFxuVGV4dGFyZWFJbnB1dC5wcm90b3R5cGUuZm9jdXMgPSBmdW5jdGlvbiAoKSB7XFxuICBpZiAodGhpcy5jbS5vcHRpb25zLnJlYWRPbmx5ICE9IFxcXCJub2N1cnNvclxcXCIgJiYgKCFtb2JpbGUgfHwgYWN0aXZlRWx0KCkgIT0gdGhpcy50ZXh0YXJlYSkpIHtcXG4gICAgdHJ5IHsgdGhpcy50ZXh0YXJlYS5mb2N1cygpIH1cXG4gICAgY2F0Y2ggKGUpIHt9IC8vIElFOCB3aWxsIHRocm93IGlmIHRoZSB0ZXh0YXJlYSBpcyBkaXNwbGF5OiBub25lIG9yIG5vdCBpbiBET01cXG4gIH1cXG59O1xcblxcblRleHRhcmVhSW5wdXQucHJvdG90eXBlLmJsdXIgPSBmdW5jdGlvbiAoKSB7IHRoaXMudGV4dGFyZWEuYmx1cigpIH07XFxuXFxuVGV4dGFyZWFJbnB1dC5wcm90b3R5cGUucmVzZXRQb3NpdGlvbiA9IGZ1bmN0aW9uICgpIHtcXG4gIHRoaXMud3JhcHBlci5zdHlsZS50b3AgPSB0aGlzLndyYXBwZXIuc3R5bGUubGVmdCA9IDBcXG59O1xcblxcblRleHRhcmVhSW5wdXQucHJvdG90eXBlLnJlY2VpdmVkRm9jdXMgPSBmdW5jdGlvbiAoKSB7IHRoaXMuc2xvd1BvbGwoKSB9O1xcblxcbi8vIFBvbGwgZm9yIGlucHV0IGNoYW5nZXMsIHVzaW5nIHRoZSBub3JtYWwgcmF0ZSBvZiBwb2xsaW5nLiBUaGlzXFxuLy8gcnVucyBhcyBsb25nIGFzIHRoZSBlZGl0b3IgaXMgZm9jdXNlZC5cXG5UZXh0YXJlYUlucHV0LnByb3RvdHlwZS5zbG93UG9sbCA9IGZ1bmN0aW9uICgpIHtcXG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XFxuXFxuICBpZiAodGhpcy5wb2xsaW5nRmFzdCkgeyByZXR1cm4gfVxcbiAgdGhpcy5wb2xsaW5nLnNldCh0aGlzLmNtLm9wdGlvbnMucG9sbEludGVydmFsLCBmdW5jdGlvbiAoKSB7XFxuICAgIHRoaXMkMS5wb2xsKClcXG4gICAgaWYgKHRoaXMkMS5jbS5zdGF0ZS5mb2N1c2VkKSB7IHRoaXMkMS5zbG93UG9sbCgpIH1cXG4gIH0pXFxufTtcXG5cXG4vLyBXaGVuIGFuIGV2ZW50IGhhcyBqdXN0IGNvbWUgaW4gdGhhdCBpcyBsaWtlbHkgdG8gYWRkIG9yIGNoYW5nZVxcbi8vIHNvbWV0aGluZyBpbiB0aGUgaW5wdXQgdGV4dGFyZWEsIHdlIHBvbGwgZmFzdGVyLCB0byBlbnN1cmUgdGhhdFxcbi8vIHRoZSBjaGFuZ2UgYXBwZWFycyBvbiB0aGUgc2NyZWVuIHF1aWNrbHkuXFxuVGV4dGFyZWFJbnB1dC5wcm90b3R5cGUuZmFzdFBvbGwgPSBmdW5jdGlvbiAoKSB7XFxuICB2YXIgbWlzc2VkID0gZmFsc2UsIGlucHV0ID0gdGhpc1xcbiAgaW5wdXQucG9sbGluZ0Zhc3QgPSB0cnVlXFxuICBmdW5jdGlvbiBwKCkge1xcbiAgICB2YXIgY2hhbmdlZCA9IGlucHV0LnBvbGwoKVxcbiAgICBpZiAoIWNoYW5nZWQgJiYgIW1pc3NlZCkge21pc3NlZCA9IHRydWU7IGlucHV0LnBvbGxpbmcuc2V0KDYwLCBwKX1cXG4gICAgZWxzZSB7aW5wdXQucG9sbGluZ0Zhc3QgPSBmYWxzZTsgaW5wdXQuc2xvd1BvbGwoKX1cXG4gIH1cXG4gIGlucHV0LnBvbGxpbmcuc2V0KDIwLCBwKVxcbn07XFxuXFxuLy8gUmVhZCBpbnB1dCBmcm9tIHRoZSB0ZXh0YXJlYSwgYW5kIHVwZGF0ZSB0aGUgZG9jdW1lbnQgdG8gbWF0Y2guXFxuLy8gV2hlbiBzb21ldGhpbmcgaXMgc2VsZWN0ZWQsIGl0IGlzIHByZXNlbnQgaW4gdGhlIHRleHRhcmVhLCBhbmRcXG4vLyBzZWxlY3RlZCAodW5sZXNzIGl0IGlzIGh1Z2UsIGluIHdoaWNoIGNhc2UgYSBwbGFjZWhvbGRlciBpc1xcbi8vIHVzZWQpLiBXaGVuIG5vdGhpbmcgaXMgc2VsZWN0ZWQsIHRoZSBjdXJzb3Igc2l0cyBhZnRlciBwcmV2aW91c2x5XFxuLy8gc2VlbiB0ZXh0IChjYW4gYmUgZW1wdHkpLCB3aGljaCBpcyBzdG9yZWQgaW4gcHJldklucHV0ICh3ZSBtdXN0XFxuLy8gbm90IHJlc2V0IHRoZSB0ZXh0YXJlYSB3aGVuIHR5cGluZywgYmVjYXVzZSB0aGF0IGJyZWFrcyBJTUUpLlxcblRleHRhcmVhSW5wdXQucHJvdG90eXBlLnBvbGwgPSBmdW5jdGlvbiAoKSB7XFxuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xcblxcbiAgdmFyIGNtID0gdGhpcy5jbSwgaW5wdXQgPSB0aGlzLnRleHRhcmVhLCBwcmV2SW5wdXQgPSB0aGlzLnByZXZJbnB1dFxcbiAgLy8gU2luY2UgdGhpcyBpcyBjYWxsZWQgYSAqbG90KiwgdHJ5IHRvIGJhaWwgb3V0IGFzIGNoZWFwbHkgYXNcXG4gIC8vIHBvc3NpYmxlIHdoZW4gaXQgaXMgY2xlYXIgdGhhdCBub3RoaW5nIGhhcHBlbmVkLiBoYXNTZWxlY3Rpb25cXG4gIC8vIHdpbGwgYmUgdGhlIGNhc2Ugd2hlbiB0aGVyZSBpcyBhIGxvdCBvZiB0ZXh0IGluIHRoZSB0ZXh0YXJlYSxcXG4gIC8vIGluIHdoaWNoIGNhc2UgcmVhZGluZyBpdHMgdmFsdWUgd291bGQgYmUgZXhwZW5zaXZlLlxcbiAgaWYgKHRoaXMuY29udGV4dE1lbnVQZW5kaW5nIHx8ICFjbS5zdGF0ZS5mb2N1c2VkIHx8XFxuICAgICAgKGhhc1NlbGVjdGlvbihpbnB1dCkgJiYgIXByZXZJbnB1dCAmJiAhdGhpcy5jb21wb3NpbmcpIHx8XFxuICAgICAgY20uaXNSZWFkT25seSgpIHx8IGNtLm9wdGlvbnMuZGlzYWJsZUlucHV0IHx8IGNtLnN0YXRlLmtleVNlcSlcXG4gICAgeyByZXR1cm4gZmFsc2UgfVxcblxcbiAgdmFyIHRleHQgPSBpbnB1dC52YWx1ZVxcbiAgLy8gSWYgbm90aGluZyBjaGFuZ2VkLCBiYWlsLlxcbiAgaWYgKHRleHQgPT0gcHJldklucHV0ICYmICFjbS5zb21ldGhpbmdTZWxlY3RlZCgpKSB7IHJldHVybiBmYWxzZSB9XFxuICAvLyBXb3JrIGFyb3VuZCBub25zZW5zaWNhbCBzZWxlY3Rpb24gcmVzZXR0aW5nIGluIElFOS8xMCwgYW5kXFxuICAvLyBpbmV4cGxpY2FibGUgYXBwZWFyYW5jZSBvZiBwcml2YXRlIGFyZWEgdW5pY29kZSBjaGFyYWN0ZXJzIG9uXFxuICAvLyBzb21lIGtleSBjb21ib3MgaW4gTWFjICgjMjY4OSkuXFxuICBpZiAoaWUgJiYgaWVfdmVyc2lvbiA+PSA5ICYmIHRoaXMuaGFzU2VsZWN0aW9uID09PSB0ZXh0IHx8XFxuICAgICAgbWFjICYmIC9bXFxcXHVmNzAwLVxcXFx1ZjdmZl0vLnRlc3QodGV4dCkpIHtcXG4gICAgY20uZGlzcGxheS5pbnB1dC5yZXNldCgpXFxuICAgIHJldHVybiBmYWxzZVxcbiAgfVxcblxcbiAgaWYgKGNtLmRvYy5zZWwgPT0gY20uZGlzcGxheS5zZWxGb3JDb250ZXh0TWVudSkge1xcbiAgICB2YXIgZmlyc3QgPSB0ZXh0LmNoYXJDb2RlQXQoMClcXG4gICAgaWYgKGZpcnN0ID09IDB4MjAwYiAmJiAhcHJldklucHV0KSB7IHByZXZJbnB1dCA9IFxcXCJcXFxcdTIwMGJcXFwiIH1cXG4gICAgaWYgKGZpcnN0ID09IDB4MjFkYSkgeyB0aGlzLnJlc2V0KCk7IHJldHVybiB0aGlzLmNtLmV4ZWNDb21tYW5kKFxcXCJ1bmRvXFxcIikgfVxcbiAgfVxcbiAgLy8gRmluZCB0aGUgcGFydCBvZiB0aGUgaW5wdXQgdGhhdCBpcyBhY3R1YWxseSBuZXdcXG4gIHZhciBzYW1lID0gMCwgbCA9IE1hdGgubWluKHByZXZJbnB1dC5sZW5ndGgsIHRleHQubGVuZ3RoKVxcbiAgd2hpbGUgKHNhbWUgPCBsICYmIHByZXZJbnB1dC5jaGFyQ29kZUF0KHNhbWUpID09IHRleHQuY2hhckNvZGVBdChzYW1lKSkgeyArK3NhbWUgfVxcblxcbiAgcnVuSW5PcChjbSwgZnVuY3Rpb24gKCkge1xcbiAgICBhcHBseVRleHRJbnB1dChjbSwgdGV4dC5zbGljZShzYW1lKSwgcHJldklucHV0Lmxlbmd0aCAtIHNhbWUsXFxuICAgICAgICAgICAgICAgICAgIG51bGwsIHRoaXMkMS5jb21wb3NpbmcgPyBcXFwiKmNvbXBvc2VcXFwiIDogbnVsbClcXG5cXG4gICAgLy8gRG9uJ3QgbGVhdmUgbG9uZyB0ZXh0IGluIHRoZSB0ZXh0YXJlYSwgc2luY2UgaXQgbWFrZXMgZnVydGhlciBwb2xsaW5nIHNsb3dcXG4gICAgaWYgKHRleHQubGVuZ3RoID4gMTAwMCB8fCB0ZXh0LmluZGV4T2YoXFxcIlxcXFxuXFxcIikgPiAtMSkgeyBpbnB1dC52YWx1ZSA9IHRoaXMkMS5wcmV2SW5wdXQgPSBcXFwiXFxcIiB9XFxuICAgIGVsc2UgeyB0aGlzJDEucHJldklucHV0ID0gdGV4dCB9XFxuXFxuICAgIGlmICh0aGlzJDEuY29tcG9zaW5nKSB7XFxuICAgICAgdGhpcyQxLmNvbXBvc2luZy5yYW5nZS5jbGVhcigpXFxuICAgICAgdGhpcyQxLmNvbXBvc2luZy5yYW5nZSA9IGNtLm1hcmtUZXh0KHRoaXMkMS5jb21wb3Npbmcuc3RhcnQsIGNtLmdldEN1cnNvcihcXFwidG9cXFwiKSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtjbGFzc05hbWU6IFxcXCJDb2RlTWlycm9yLWNvbXBvc2luZ1xcXCJ9KVxcbiAgICB9XFxuICB9KVxcbiAgcmV0dXJuIHRydWVcXG59O1xcblxcblRleHRhcmVhSW5wdXQucHJvdG90eXBlLmVuc3VyZVBvbGxlZCA9IGZ1bmN0aW9uICgpIHtcXG4gIGlmICh0aGlzLnBvbGxpbmdGYXN0ICYmIHRoaXMucG9sbCgpKSB7IHRoaXMucG9sbGluZ0Zhc3QgPSBmYWxzZSB9XFxufTtcXG5cXG5UZXh0YXJlYUlucHV0LnByb3RvdHlwZS5vbktleVByZXNzID0gZnVuY3Rpb24gKCkge1xcbiAgaWYgKGllICYmIGllX3ZlcnNpb24gPj0gOSkgeyB0aGlzLmhhc1NlbGVjdGlvbiA9IG51bGwgfVxcbiAgdGhpcy5mYXN0UG9sbCgpXFxufTtcXG5cXG5UZXh0YXJlYUlucHV0LnByb3RvdHlwZS5vbkNvbnRleHRNZW51ID0gZnVuY3Rpb24gKGUpIHtcXG4gIHZhciBpbnB1dCA9IHRoaXMsIGNtID0gaW5wdXQuY20sIGRpc3BsYXkgPSBjbS5kaXNwbGF5LCB0ZSA9IGlucHV0LnRleHRhcmVhXFxuICB2YXIgcG9zID0gcG9zRnJvbU1vdXNlKGNtLCBlKSwgc2Nyb2xsUG9zID0gZGlzcGxheS5zY3JvbGxlci5zY3JvbGxUb3BcXG4gIGlmICghcG9zIHx8IHByZXN0bykgeyByZXR1cm4gfSAvLyBPcGVyYSBpcyBkaWZmaWN1bHQuXFxuXFxuICAvLyBSZXNldCB0aGUgY3VycmVudCB0ZXh0IHNlbGVjdGlvbiBvbmx5IGlmIHRoZSBjbGljayBpcyBkb25lIG91dHNpZGUgb2YgdGhlIHNlbGVjdGlvblxcbiAgLy8gYW5kICdyZXNldFNlbGVjdGlvbk9uQ29udGV4dE1lbnUnIG9wdGlvbiBpcyB0cnVlLlxcbiAgdmFyIHJlc2V0ID0gY20ub3B0aW9ucy5yZXNldFNlbGVjdGlvbk9uQ29udGV4dE1lbnVcXG4gIGlmIChyZXNldCAmJiBjbS5kb2Muc2VsLmNvbnRhaW5zKHBvcykgPT0gLTEpXFxuICAgIHsgb3BlcmF0aW9uKGNtLCBzZXRTZWxlY3Rpb24pKGNtLmRvYywgc2ltcGxlU2VsZWN0aW9uKHBvcyksIHNlbF9kb250U2Nyb2xsKSB9XFxuXFxuICB2YXIgb2xkQ1NTID0gdGUuc3R5bGUuY3NzVGV4dCwgb2xkV3JhcHBlckNTUyA9IGlucHV0LndyYXBwZXIuc3R5bGUuY3NzVGV4dFxcbiAgaW5wdXQud3JhcHBlci5zdHlsZS5jc3NUZXh0ID0gXFxcInBvc2l0aW9uOiBhYnNvbHV0ZVxcXCJcXG4gIHZhciB3cmFwcGVyQm94ID0gaW5wdXQud3JhcHBlci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxcbiAgdGUuc3R5bGUuY3NzVGV4dCA9IFxcXCJwb3NpdGlvbjogYWJzb2x1dGU7IHdpZHRoOiAzMHB4OyBoZWlnaHQ6IDMwcHg7XFxcXG4gICAgICB0b3A6IFxcXCIgKyAoZS5jbGllbnRZIC0gd3JhcHBlckJveC50b3AgLSA1KSArIFxcXCJweDsgbGVmdDogXFxcIiArIChlLmNsaWVudFggLSB3cmFwcGVyQm94LmxlZnQgLSA1KSArIFxcXCJweDtcXFxcbiAgICAgIHotaW5kZXg6IDEwMDA7IGJhY2tncm91bmQ6IFxcXCIgKyAoaWUgPyBcXFwicmdiYSgyNTUsIDI1NSwgMjU1LCAuMDUpXFxcIiA6IFxcXCJ0cmFuc3BhcmVudFxcXCIpICsgXFxcIjtcXFxcbiAgICAgIG91dGxpbmU6IG5vbmU7IGJvcmRlci13aWR0aDogMDsgb3V0bGluZTogbm9uZTsgb3ZlcmZsb3c6IGhpZGRlbjsgb3BhY2l0eTogLjA1OyBmaWx0ZXI6IGFscGhhKG9wYWNpdHk9NSk7XFxcIlxcbiAgdmFyIG9sZFNjcm9sbFlcXG4gIGlmICh3ZWJraXQpIHsgb2xkU2Nyb2xsWSA9IHdpbmRvdy5zY3JvbGxZIH0gLy8gV29yayBhcm91bmQgQ2hyb21lIGlzc3VlICgjMjcxMilcXG4gIGRpc3BsYXkuaW5wdXQuZm9jdXMoKVxcbiAgaWYgKHdlYmtpdCkgeyB3aW5kb3cuc2Nyb2xsVG8obnVsbCwgb2xkU2Nyb2xsWSkgfVxcbiAgZGlzcGxheS5pbnB1dC5yZXNldCgpXFxuICAvLyBBZGRzIFxcXCJTZWxlY3QgYWxsXFxcIiB0byBjb250ZXh0IG1lbnUgaW4gRkZcXG4gIGlmICghY20uc29tZXRoaW5nU2VsZWN0ZWQoKSkgeyB0ZS52YWx1ZSA9IGlucHV0LnByZXZJbnB1dCA9IFxcXCIgXFxcIiB9XFxuICBpbnB1dC5jb250ZXh0TWVudVBlbmRpbmcgPSB0cnVlXFxuICBkaXNwbGF5LnNlbEZvckNvbnRleHRNZW51ID0gY20uZG9jLnNlbFxcbiAgY2xlYXJUaW1lb3V0KGRpc3BsYXkuZGV0ZWN0aW5nU2VsZWN0QWxsKVxcblxcbiAgLy8gU2VsZWN0LWFsbCB3aWxsIGJlIGdyZXllZCBvdXQgaWYgdGhlcmUncyBub3RoaW5nIHRvIHNlbGVjdCwgc29cXG4gIC8vIHRoaXMgYWRkcyBhIHplcm8td2lkdGggc3BhY2Ugc28gdGhhdCB3ZSBjYW4gbGF0ZXIgY2hlY2sgd2hldGhlclxcbiAgLy8gaXQgZ290IHNlbGVjdGVkLlxcbiAgZnVuY3Rpb24gcHJlcGFyZVNlbGVjdEFsbEhhY2soKSB7XFxuICAgIGlmICh0ZS5zZWxlY3Rpb25TdGFydCAhPSBudWxsKSB7XFxuICAgICAgdmFyIHNlbGVjdGVkID0gY20uc29tZXRoaW5nU2VsZWN0ZWQoKVxcbiAgICAgIHZhciBleHR2YWwgPSBcXFwiXFxcXHUyMDBiXFxcIiArIChzZWxlY3RlZCA/IHRlLnZhbHVlIDogXFxcIlxcXCIpXFxuICAgICAgdGUudmFsdWUgPSBcXFwiXFxcXHUyMWRhXFxcIiAvLyBVc2VkIHRvIGNhdGNoIGNvbnRleHQtbWVudSB1bmRvXFxuICAgICAgdGUudmFsdWUgPSBleHR2YWxcXG4gICAgICBpbnB1dC5wcmV2SW5wdXQgPSBzZWxlY3RlZCA/IFxcXCJcXFwiIDogXFxcIlxcXFx1MjAwYlxcXCJcXG4gICAgICB0ZS5zZWxlY3Rpb25TdGFydCA9IDE7IHRlLnNlbGVjdGlvbkVuZCA9IGV4dHZhbC5sZW5ndGhcXG4gICAgICAvLyBSZS1zZXQgdGhpcywgaW4gY2FzZSBzb21lIG90aGVyIGhhbmRsZXIgdG91Y2hlZCB0aGVcXG4gICAgICAvLyBzZWxlY3Rpb24gaW4gdGhlIG1lYW50aW1lLlxcbiAgICAgIGRpc3BsYXkuc2VsRm9yQ29udGV4dE1lbnUgPSBjbS5kb2Muc2VsXFxuICAgIH1cXG4gIH1cXG4gIGZ1bmN0aW9uIHJlaGlkZSgpIHtcXG4gICAgaW5wdXQuY29udGV4dE1lbnVQZW5kaW5nID0gZmFsc2VcXG4gICAgaW5wdXQud3JhcHBlci5zdHlsZS5jc3NUZXh0ID0gb2xkV3JhcHBlckNTU1xcbiAgICB0ZS5zdHlsZS5jc3NUZXh0ID0gb2xkQ1NTXFxuICAgIGlmIChpZSAmJiBpZV92ZXJzaW9uIDwgOSkgeyBkaXNwbGF5LnNjcm9sbGJhcnMuc2V0U2Nyb2xsVG9wKGRpc3BsYXkuc2Nyb2xsZXIuc2Nyb2xsVG9wID0gc2Nyb2xsUG9zKSB9XFxuXFxuICAgIC8vIFRyeSB0byBkZXRlY3QgdGhlIHVzZXIgY2hvb3Npbmcgc2VsZWN0LWFsbFxcbiAgICBpZiAodGUuc2VsZWN0aW9uU3RhcnQgIT0gbnVsbCkge1xcbiAgICAgIGlmICghaWUgfHwgKGllICYmIGllX3ZlcnNpb24gPCA5KSkgeyBwcmVwYXJlU2VsZWN0QWxsSGFjaygpIH1cXG4gICAgICB2YXIgaSA9IDAsIHBvbGwgPSBmdW5jdGlvbiAoKSB7XFxuICAgICAgICBpZiAoZGlzcGxheS5zZWxGb3JDb250ZXh0TWVudSA9PSBjbS5kb2Muc2VsICYmIHRlLnNlbGVjdGlvblN0YXJ0ID09IDAgJiZcXG4gICAgICAgICAgICB0ZS5zZWxlY3Rpb25FbmQgPiAwICYmIGlucHV0LnByZXZJbnB1dCA9PSBcXFwiXFxcXHUyMDBiXFxcIikge1xcbiAgICAgICAgICBvcGVyYXRpb24oY20sIHNlbGVjdEFsbCkoY20pXFxuICAgICAgICB9IGVsc2UgaWYgKGkrKyA8IDEwKSB7XFxuICAgICAgICAgIGRpc3BsYXkuZGV0ZWN0aW5nU2VsZWN0QWxsID0gc2V0VGltZW91dChwb2xsLCA1MDApXFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICBkaXNwbGF5LnNlbEZvckNvbnRleHRNZW51ID0gbnVsbFxcbiAgICAgICAgICBkaXNwbGF5LmlucHV0LnJlc2V0KClcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgICAgZGlzcGxheS5kZXRlY3RpbmdTZWxlY3RBbGwgPSBzZXRUaW1lb3V0KHBvbGwsIDIwMClcXG4gICAgfVxcbiAgfVxcblxcbiAgaWYgKGllICYmIGllX3ZlcnNpb24gPj0gOSkgeyBwcmVwYXJlU2VsZWN0QWxsSGFjaygpIH1cXG4gIGlmIChjYXB0dXJlUmlnaHRDbGljaykge1xcbiAgICBlX3N0b3AoZSlcXG4gICAgdmFyIG1vdXNldXAgPSBmdW5jdGlvbiAoKSB7XFxuICAgICAgb2ZmKHdpbmRvdywgXFxcIm1vdXNldXBcXFwiLCBtb3VzZXVwKVxcbiAgICAgIHNldFRpbWVvdXQocmVoaWRlLCAyMClcXG4gICAgfVxcbiAgICBvbih3aW5kb3csIFxcXCJtb3VzZXVwXFxcIiwgbW91c2V1cClcXG4gIH0gZWxzZSB7XFxuICAgIHNldFRpbWVvdXQocmVoaWRlLCA1MClcXG4gIH1cXG59O1xcblxcblRleHRhcmVhSW5wdXQucHJvdG90eXBlLnJlYWRPbmx5Q2hhbmdlZCA9IGZ1bmN0aW9uICh2YWwpIHtcXG4gIGlmICghdmFsKSB7IHRoaXMucmVzZXQoKSB9XFxufTtcXG5cXG5UZXh0YXJlYUlucHV0LnByb3RvdHlwZS5zZXRVbmVkaXRhYmxlID0gZnVuY3Rpb24gKCkge307XFxuXFxuVGV4dGFyZWFJbnB1dC5wcm90b3R5cGUubmVlZHNDb250ZW50QXR0cmlidXRlID0gZmFsc2VcXG5cXG5mdW5jdGlvbiBmcm9tVGV4dEFyZWEodGV4dGFyZWEsIG9wdGlvbnMpIHtcXG4gIG9wdGlvbnMgPSBvcHRpb25zID8gY29weU9iaihvcHRpb25zKSA6IHt9XFxuICBvcHRpb25zLnZhbHVlID0gdGV4dGFyZWEudmFsdWVcXG4gIGlmICghb3B0aW9ucy50YWJpbmRleCAmJiB0ZXh0YXJlYS50YWJJbmRleClcXG4gICAgeyBvcHRpb25zLnRhYmluZGV4ID0gdGV4dGFyZWEudGFiSW5kZXggfVxcbiAgaWYgKCFvcHRpb25zLnBsYWNlaG9sZGVyICYmIHRleHRhcmVhLnBsYWNlaG9sZGVyKVxcbiAgICB7IG9wdGlvbnMucGxhY2Vob2xkZXIgPSB0ZXh0YXJlYS5wbGFjZWhvbGRlciB9XFxuICAvLyBTZXQgYXV0b2ZvY3VzIHRvIHRydWUgaWYgdGhpcyB0ZXh0YXJlYSBpcyBmb2N1c2VkLCBvciBpZiBpdCBoYXNcXG4gIC8vIGF1dG9mb2N1cyBhbmQgbm8gb3RoZXIgZWxlbWVudCBpcyBmb2N1c2VkLlxcbiAgaWYgKG9wdGlvbnMuYXV0b2ZvY3VzID09IG51bGwpIHtcXG4gICAgdmFyIGhhc0ZvY3VzID0gYWN0aXZlRWx0KClcXG4gICAgb3B0aW9ucy5hdXRvZm9jdXMgPSBoYXNGb2N1cyA9PSB0ZXh0YXJlYSB8fFxcbiAgICAgIHRleHRhcmVhLmdldEF0dHJpYnV0ZShcXFwiYXV0b2ZvY3VzXFxcIikgIT0gbnVsbCAmJiBoYXNGb2N1cyA9PSBkb2N1bWVudC5ib2R5XFxuICB9XFxuXFxuICBmdW5jdGlvbiBzYXZlKCkge3RleHRhcmVhLnZhbHVlID0gY20uZ2V0VmFsdWUoKX1cXG5cXG4gIHZhciByZWFsU3VibWl0XFxuICBpZiAodGV4dGFyZWEuZm9ybSkge1xcbiAgICBvbih0ZXh0YXJlYS5mb3JtLCBcXFwic3VibWl0XFxcIiwgc2F2ZSlcXG4gICAgLy8gRGVwbG9yYWJsZSBoYWNrIHRvIG1ha2UgdGhlIHN1Ym1pdCBtZXRob2QgZG8gdGhlIHJpZ2h0IHRoaW5nLlxcbiAgICBpZiAoIW9wdGlvbnMubGVhdmVTdWJtaXRNZXRob2RBbG9uZSkge1xcbiAgICAgIHZhciBmb3JtID0gdGV4dGFyZWEuZm9ybVxcbiAgICAgIHJlYWxTdWJtaXQgPSBmb3JtLnN1Ym1pdFxcbiAgICAgIHRyeSB7XFxuICAgICAgICB2YXIgd3JhcHBlZFN1Ym1pdCA9IGZvcm0uc3VibWl0ID0gZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICBzYXZlKClcXG4gICAgICAgICAgZm9ybS5zdWJtaXQgPSByZWFsU3VibWl0XFxuICAgICAgICAgIGZvcm0uc3VibWl0KClcXG4gICAgICAgICAgZm9ybS5zdWJtaXQgPSB3cmFwcGVkU3VibWl0XFxuICAgICAgICB9XFxuICAgICAgfSBjYXRjaChlKSB7fVxcbiAgICB9XFxuICB9XFxuXFxuICBvcHRpb25zLmZpbmlzaEluaXQgPSBmdW5jdGlvbiAoY20pIHtcXG4gICAgY20uc2F2ZSA9IHNhdmVcXG4gICAgY20uZ2V0VGV4dEFyZWEgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0ZXh0YXJlYTsgfVxcbiAgICBjbS50b1RleHRBcmVhID0gZnVuY3Rpb24gKCkge1xcbiAgICAgIGNtLnRvVGV4dEFyZWEgPSBpc05hTiAvLyBQcmV2ZW50IHRoaXMgZnJvbSBiZWluZyByYW4gdHdpY2VcXG4gICAgICBzYXZlKClcXG4gICAgICB0ZXh0YXJlYS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGNtLmdldFdyYXBwZXJFbGVtZW50KCkpXFxuICAgICAgdGV4dGFyZWEuc3R5bGUuZGlzcGxheSA9IFxcXCJcXFwiXFxuICAgICAgaWYgKHRleHRhcmVhLmZvcm0pIHtcXG4gICAgICAgIG9mZih0ZXh0YXJlYS5mb3JtLCBcXFwic3VibWl0XFxcIiwgc2F2ZSlcXG4gICAgICAgIGlmICh0eXBlb2YgdGV4dGFyZWEuZm9ybS5zdWJtaXQgPT0gXFxcImZ1bmN0aW9uXFxcIilcXG4gICAgICAgICAgeyB0ZXh0YXJlYS5mb3JtLnN1Ym1pdCA9IHJlYWxTdWJtaXQgfVxcbiAgICAgIH1cXG4gICAgfVxcbiAgfVxcblxcbiAgdGV4dGFyZWEuc3R5bGUuZGlzcGxheSA9IFxcXCJub25lXFxcIlxcbiAgdmFyIGNtID0gQ29kZU1pcnJvcihmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gdGV4dGFyZWEucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUobm9kZSwgdGV4dGFyZWEubmV4dFNpYmxpbmcpOyB9LFxcbiAgICBvcHRpb25zKVxcbiAgcmV0dXJuIGNtXFxufVxcblxcbmZ1bmN0aW9uIGFkZExlZ2FjeVByb3BzKENvZGVNaXJyb3IpIHtcXG4gIENvZGVNaXJyb3Iub2ZmID0gb2ZmXFxuICBDb2RlTWlycm9yLm9uID0gb25cXG4gIENvZGVNaXJyb3Iud2hlZWxFdmVudFBpeGVscyA9IHdoZWVsRXZlbnRQaXhlbHNcXG4gIENvZGVNaXJyb3IuRG9jID0gRG9jXFxuICBDb2RlTWlycm9yLnNwbGl0TGluZXMgPSBzcGxpdExpbmVzQXV0b1xcbiAgQ29kZU1pcnJvci5jb3VudENvbHVtbiA9IGNvdW50Q29sdW1uXFxuICBDb2RlTWlycm9yLmZpbmRDb2x1bW4gPSBmaW5kQ29sdW1uXFxuICBDb2RlTWlycm9yLmlzV29yZENoYXIgPSBpc1dvcmRDaGFyQmFzaWNcXG4gIENvZGVNaXJyb3IuUGFzcyA9IFBhc3NcXG4gIENvZGVNaXJyb3Iuc2lnbmFsID0gc2lnbmFsXFxuICBDb2RlTWlycm9yLkxpbmUgPSBMaW5lXFxuICBDb2RlTWlycm9yLmNoYW5nZUVuZCA9IGNoYW5nZUVuZFxcbiAgQ29kZU1pcnJvci5zY3JvbGxiYXJNb2RlbCA9IHNjcm9sbGJhck1vZGVsXFxuICBDb2RlTWlycm9yLlBvcyA9IFBvc1xcbiAgQ29kZU1pcnJvci5jbXBQb3MgPSBjbXBcXG4gIENvZGVNaXJyb3IubW9kZXMgPSBtb2Rlc1xcbiAgQ29kZU1pcnJvci5taW1lTW9kZXMgPSBtaW1lTW9kZXNcXG4gIENvZGVNaXJyb3IucmVzb2x2ZU1vZGUgPSByZXNvbHZlTW9kZVxcbiAgQ29kZU1pcnJvci5nZXRNb2RlID0gZ2V0TW9kZVxcbiAgQ29kZU1pcnJvci5tb2RlRXh0ZW5zaW9ucyA9IG1vZGVFeHRlbnNpb25zXFxuICBDb2RlTWlycm9yLmV4dGVuZE1vZGUgPSBleHRlbmRNb2RlXFxuICBDb2RlTWlycm9yLmNvcHlTdGF0ZSA9IGNvcHlTdGF0ZVxcbiAgQ29kZU1pcnJvci5zdGFydFN0YXRlID0gc3RhcnRTdGF0ZVxcbiAgQ29kZU1pcnJvci5pbm5lck1vZGUgPSBpbm5lck1vZGVcXG4gIENvZGVNaXJyb3IuY29tbWFuZHMgPSBjb21tYW5kc1xcbiAgQ29kZU1pcnJvci5rZXlNYXAgPSBrZXlNYXBcXG4gIENvZGVNaXJyb3Iua2V5TmFtZSA9IGtleU5hbWVcXG4gIENvZGVNaXJyb3IuaXNNb2RpZmllcktleSA9IGlzTW9kaWZpZXJLZXlcXG4gIENvZGVNaXJyb3IubG9va3VwS2V5ID0gbG9va3VwS2V5XFxuICBDb2RlTWlycm9yLm5vcm1hbGl6ZUtleU1hcCA9IG5vcm1hbGl6ZUtleU1hcFxcbiAgQ29kZU1pcnJvci5TdHJpbmdTdHJlYW0gPSBTdHJpbmdTdHJlYW1cXG4gIENvZGVNaXJyb3IuU2hhcmVkVGV4dE1hcmtlciA9IFNoYXJlZFRleHRNYXJrZXJcXG4gIENvZGVNaXJyb3IuVGV4dE1hcmtlciA9IFRleHRNYXJrZXJcXG4gIENvZGVNaXJyb3IuTGluZVdpZGdldCA9IExpbmVXaWRnZXRcXG4gIENvZGVNaXJyb3IuZV9wcmV2ZW50RGVmYXVsdCA9IGVfcHJldmVudERlZmF1bHRcXG4gIENvZGVNaXJyb3IuZV9zdG9wUHJvcGFnYXRpb24gPSBlX3N0b3BQcm9wYWdhdGlvblxcbiAgQ29kZU1pcnJvci5lX3N0b3AgPSBlX3N0b3BcXG4gIENvZGVNaXJyb3IuYWRkQ2xhc3MgPSBhZGRDbGFzc1xcbiAgQ29kZU1pcnJvci5jb250YWlucyA9IGNvbnRhaW5zXFxuICBDb2RlTWlycm9yLnJtQ2xhc3MgPSBybUNsYXNzXFxuICBDb2RlTWlycm9yLmtleU5hbWVzID0ga2V5TmFtZXNcXG59XFxuXFxuLy8gRURJVE9SIENPTlNUUlVDVE9SXFxuXFxuZGVmaW5lT3B0aW9ucyhDb2RlTWlycm9yKVxcblxcbmFkZEVkaXRvck1ldGhvZHMoQ29kZU1pcnJvcilcXG5cXG4vLyBTZXQgdXAgbWV0aG9kcyBvbiBDb2RlTWlycm9yJ3MgcHJvdG90eXBlIHRvIHJlZGlyZWN0IHRvIHRoZSBlZGl0b3IncyBkb2N1bWVudC5cXG52YXIgZG9udERlbGVnYXRlID0gXFxcIml0ZXIgaW5zZXJ0IHJlbW92ZSBjb3B5IGdldEVkaXRvciBjb25zdHJ1Y3RvclxcXCIuc3BsaXQoXFxcIiBcXFwiKVxcbmZvciAodmFyIHByb3AgaW4gRG9jLnByb3RvdHlwZSkgeyBpZiAoRG9jLnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eShwcm9wKSAmJiBpbmRleE9mKGRvbnREZWxlZ2F0ZSwgcHJvcCkgPCAwKVxcbiAgeyBDb2RlTWlycm9yLnByb3RvdHlwZVtwcm9wXSA9IChmdW5jdGlvbihtZXRob2QpIHtcXG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge3JldHVybiBtZXRob2QuYXBwbHkodGhpcy5kb2MsIGFyZ3VtZW50cyl9XFxuICB9KShEb2MucHJvdG90eXBlW3Byb3BdKSB9IH1cXG5cXG5ldmVudE1peGluKERvYylcXG5cXG4vLyBJTlBVVCBIQU5ETElOR1xcblxcbkNvZGVNaXJyb3IuaW5wdXRTdHlsZXMgPSB7XFxcInRleHRhcmVhXFxcIjogVGV4dGFyZWFJbnB1dCwgXFxcImNvbnRlbnRlZGl0YWJsZVxcXCI6IENvbnRlbnRFZGl0YWJsZUlucHV0fVxcblxcbi8vIE1PREUgREVGSU5JVElPTiBBTkQgUVVFUllJTkdcXG5cXG4vLyBFeHRyYSBhcmd1bWVudHMgYXJlIHN0b3JlZCBhcyB0aGUgbW9kZSdzIGRlcGVuZGVuY2llcywgd2hpY2ggaXNcXG4vLyB1c2VkIGJ5IChsZWdhY3kpIG1lY2hhbmlzbXMgbGlrZSBsb2FkbW9kZS5qcyB0byBhdXRvbWF0aWNhbGx5XFxuLy8gbG9hZCBhIG1vZGUuIChQcmVmZXJyZWQgbWVjaGFuaXNtIGlzIHRoZSByZXF1aXJlL2RlZmluZSBjYWxscy4pXFxuQ29kZU1pcnJvci5kZWZpbmVNb2RlID0gZnVuY3Rpb24obmFtZS8qLCBtb2RlLCDigKYqLykge1xcbiAgaWYgKCFDb2RlTWlycm9yLmRlZmF1bHRzLm1vZGUgJiYgbmFtZSAhPSBcXFwibnVsbFxcXCIpIHsgQ29kZU1pcnJvci5kZWZhdWx0cy5tb2RlID0gbmFtZSB9XFxuICBkZWZpbmVNb2RlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcXG59XFxuXFxuQ29kZU1pcnJvci5kZWZpbmVNSU1FID0gZGVmaW5lTUlNRVxcblxcbi8vIE1pbmltYWwgZGVmYXVsdCBtb2RlLlxcbkNvZGVNaXJyb3IuZGVmaW5lTW9kZShcXFwibnVsbFxcXCIsIGZ1bmN0aW9uICgpIHsgcmV0dXJuICh7dG9rZW46IGZ1bmN0aW9uIChzdHJlYW0pIHsgcmV0dXJuIHN0cmVhbS5za2lwVG9FbmQoKTsgfX0pOyB9KVxcbkNvZGVNaXJyb3IuZGVmaW5lTUlNRShcXFwidGV4dC9wbGFpblxcXCIsIFxcXCJudWxsXFxcIilcXG5cXG4vLyBFWFRFTlNJT05TXFxuXFxuQ29kZU1pcnJvci5kZWZpbmVFeHRlbnNpb24gPSBmdW5jdGlvbiAobmFtZSwgZnVuYykge1xcbiAgQ29kZU1pcnJvci5wcm90b3R5cGVbbmFtZV0gPSBmdW5jXFxufVxcbkNvZGVNaXJyb3IuZGVmaW5lRG9jRXh0ZW5zaW9uID0gZnVuY3Rpb24gKG5hbWUsIGZ1bmMpIHtcXG4gIERvYy5wcm90b3R5cGVbbmFtZV0gPSBmdW5jXFxufVxcblxcbkNvZGVNaXJyb3IuZnJvbVRleHRBcmVhID0gZnJvbVRleHRBcmVhXFxuXFxuYWRkTGVnYWN5UHJvcHMoQ29kZU1pcnJvcilcXG5cXG5Db2RlTWlycm9yLnZlcnNpb24gPSBcXFwiNS4yNC4yXFxcIlxcblxcbnJldHVybiBDb2RlTWlycm9yO1xcblxcbn0pKSk7XCJcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcmF3LWxvYWRlciEuL34vY29kZW1pcnJvci9saWIvY29kZW1pcnJvci5qc1xuLy8gbW9kdWxlIGlkID0gNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	eval("__webpack_require__(2)(__webpack_require__(7))//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL34vY29kZW1pcnJvci9tb2RlL3htbC94bWwuanM/ODBhNyJdLCJzb3VyY2VzQ29udGVudCI6WyJyZXF1aXJlKFwiISEvVXNlcnMvamFrdWJmYWprdXMvRG9jdW1lbnRzL3ByYWNlL3ZlbmljZS1kZW1vL3dlYi9qcy9ub2RlX21vZHVsZXMvc2NyaXB0LWxvYWRlci9hZGRTY3JpcHQuanNcIikocmVxdWlyZShcIiEhL1VzZXJzL2pha3ViZmFqa3VzL0RvY3VtZW50cy9wcmFjZS92ZW5pY2UtZGVtby93ZWIvanMvbm9kZV9tb2R1bGVzL3Jhdy1sb2FkZXIvaW5kZXguanMhL1VzZXJzL2pha3ViZmFqa3VzL0RvY3VtZW50cy9wcmFjZS92ZW5pY2UtZGVtby93ZWIvanMvbm9kZV9tb2R1bGVzL2NvZGVtaXJyb3IvbW9kZS94bWwveG1sLmpzXCIpKVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9zY3JpcHQtbG9hZGVyIS4vfi9jb2RlbWlycm9yL21vZGUveG1sL3htbC5qc1xuLy8gbW9kdWxlIGlkID0gNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 7 */
/***/ function(module, exports) {

	eval("module.exports = \"// CodeMirror, copyright (c) by Marijn Haverbeke and others\\n// Distributed under an MIT license: http://codemirror.net/LICENSE\\n\\n(function(mod) {\\n  if (typeof exports == \\\"object\\\" && typeof module == \\\"object\\\") // CommonJS\\n    mod(require(\\\"../../lib/codemirror\\\"));\\n  else if (typeof define == \\\"function\\\" && define.amd) // AMD\\n    define([\\\"../../lib/codemirror\\\"], mod);\\n  else // Plain browser env\\n    mod(CodeMirror);\\n})(function(CodeMirror) {\\n\\\"use strict\\\";\\n\\nvar htmlConfig = {\\n  autoSelfClosers: {'area': true, 'base': true, 'br': true, 'col': true, 'command': true,\\n                    'embed': true, 'frame': true, 'hr': true, 'img': true, 'input': true,\\n                    'keygen': true, 'link': true, 'meta': true, 'param': true, 'source': true,\\n                    'track': true, 'wbr': true, 'menuitem': true},\\n  implicitlyClosed: {'dd': true, 'li': true, 'optgroup': true, 'option': true, 'p': true,\\n                     'rp': true, 'rt': true, 'tbody': true, 'td': true, 'tfoot': true,\\n                     'th': true, 'tr': true},\\n  contextGrabbers: {\\n    'dd': {'dd': true, 'dt': true},\\n    'dt': {'dd': true, 'dt': true},\\n    'li': {'li': true},\\n    'option': {'option': true, 'optgroup': true},\\n    'optgroup': {'optgroup': true},\\n    'p': {'address': true, 'article': true, 'aside': true, 'blockquote': true, 'dir': true,\\n          'div': true, 'dl': true, 'fieldset': true, 'footer': true, 'form': true,\\n          'h1': true, 'h2': true, 'h3': true, 'h4': true, 'h5': true, 'h6': true,\\n          'header': true, 'hgroup': true, 'hr': true, 'menu': true, 'nav': true, 'ol': true,\\n          'p': true, 'pre': true, 'section': true, 'table': true, 'ul': true},\\n    'rp': {'rp': true, 'rt': true},\\n    'rt': {'rp': true, 'rt': true},\\n    'tbody': {'tbody': true, 'tfoot': true},\\n    'td': {'td': true, 'th': true},\\n    'tfoot': {'tbody': true},\\n    'th': {'td': true, 'th': true},\\n    'thead': {'tbody': true, 'tfoot': true},\\n    'tr': {'tr': true}\\n  },\\n  doNotIndent: {\\\"pre\\\": true},\\n  allowUnquoted: true,\\n  allowMissing: true,\\n  caseFold: true\\n}\\n\\nvar xmlConfig = {\\n  autoSelfClosers: {},\\n  implicitlyClosed: {},\\n  contextGrabbers: {},\\n  doNotIndent: {},\\n  allowUnquoted: false,\\n  allowMissing: false,\\n  caseFold: false\\n}\\n\\nCodeMirror.defineMode(\\\"xml\\\", function(editorConf, config_) {\\n  var indentUnit = editorConf.indentUnit\\n  var config = {}\\n  var defaults = config_.htmlMode ? htmlConfig : xmlConfig\\n  for (var prop in defaults) config[prop] = defaults[prop]\\n  for (var prop in config_) config[prop] = config_[prop]\\n\\n  // Return variables for tokenizers\\n  var type, setStyle;\\n\\n  function inText(stream, state) {\\n    function chain(parser) {\\n      state.tokenize = parser;\\n      return parser(stream, state);\\n    }\\n\\n    var ch = stream.next();\\n    if (ch == \\\"<\\\") {\\n      if (stream.eat(\\\"!\\\")) {\\n        if (stream.eat(\\\"[\\\")) {\\n          if (stream.match(\\\"CDATA[\\\")) return chain(inBlock(\\\"atom\\\", \\\"]]>\\\"));\\n          else return null;\\n        } else if (stream.match(\\\"--\\\")) {\\n          return chain(inBlock(\\\"comment\\\", \\\"-->\\\"));\\n        } else if (stream.match(\\\"DOCTYPE\\\", true, true)) {\\n          stream.eatWhile(/[\\\\w\\\\._\\\\-]/);\\n          return chain(doctype(1));\\n        } else {\\n          return null;\\n        }\\n      } else if (stream.eat(\\\"?\\\")) {\\n        stream.eatWhile(/[\\\\w\\\\._\\\\-]/);\\n        state.tokenize = inBlock(\\\"meta\\\", \\\"?>\\\");\\n        return \\\"meta\\\";\\n      } else {\\n        type = stream.eat(\\\"/\\\") ? \\\"closeTag\\\" : \\\"openTag\\\";\\n        state.tokenize = inTag;\\n        return \\\"tag bracket\\\";\\n      }\\n    } else if (ch == \\\"&\\\") {\\n      var ok;\\n      if (stream.eat(\\\"#\\\")) {\\n        if (stream.eat(\\\"x\\\")) {\\n          ok = stream.eatWhile(/[a-fA-F\\\\d]/) && stream.eat(\\\";\\\");\\n        } else {\\n          ok = stream.eatWhile(/[\\\\d]/) && stream.eat(\\\";\\\");\\n        }\\n      } else {\\n        ok = stream.eatWhile(/[\\\\w\\\\.\\\\-:]/) && stream.eat(\\\";\\\");\\n      }\\n      return ok ? \\\"atom\\\" : \\\"error\\\";\\n    } else {\\n      stream.eatWhile(/[^&<]/);\\n      return null;\\n    }\\n  }\\n  inText.isInText = true;\\n\\n  function inTag(stream, state) {\\n    var ch = stream.next();\\n    if (ch == \\\">\\\" || (ch == \\\"/\\\" && stream.eat(\\\">\\\"))) {\\n      state.tokenize = inText;\\n      type = ch == \\\">\\\" ? \\\"endTag\\\" : \\\"selfcloseTag\\\";\\n      return \\\"tag bracket\\\";\\n    } else if (ch == \\\"=\\\") {\\n      type = \\\"equals\\\";\\n      return null;\\n    } else if (ch == \\\"<\\\") {\\n      state.tokenize = inText;\\n      state.state = baseState;\\n      state.tagName = state.tagStart = null;\\n      var next = state.tokenize(stream, state);\\n      return next ? next + \\\" tag error\\\" : \\\"tag error\\\";\\n    } else if (/[\\\\'\\\\\\\"]/.test(ch)) {\\n      state.tokenize = inAttribute(ch);\\n      state.stringStartCol = stream.column();\\n      return state.tokenize(stream, state);\\n    } else {\\n      stream.match(/^[^\\\\s\\\\u00a0=<>\\\\\\\"\\\\']*[^\\\\s\\\\u00a0=<>\\\\\\\"\\\\'\\\\/]/);\\n      return \\\"word\\\";\\n    }\\n  }\\n\\n  function inAttribute(quote) {\\n    var closure = function(stream, state) {\\n      while (!stream.eol()) {\\n        if (stream.next() == quote) {\\n          state.tokenize = inTag;\\n          break;\\n        }\\n      }\\n      return \\\"string\\\";\\n    };\\n    closure.isInAttribute = true;\\n    return closure;\\n  }\\n\\n  function inBlock(style, terminator) {\\n    return function(stream, state) {\\n      while (!stream.eol()) {\\n        if (stream.match(terminator)) {\\n          state.tokenize = inText;\\n          break;\\n        }\\n        stream.next();\\n      }\\n      return style;\\n    };\\n  }\\n  function doctype(depth) {\\n    return function(stream, state) {\\n      var ch;\\n      while ((ch = stream.next()) != null) {\\n        if (ch == \\\"<\\\") {\\n          state.tokenize = doctype(depth + 1);\\n          return state.tokenize(stream, state);\\n        } else if (ch == \\\">\\\") {\\n          if (depth == 1) {\\n            state.tokenize = inText;\\n            break;\\n          } else {\\n            state.tokenize = doctype(depth - 1);\\n            return state.tokenize(stream, state);\\n          }\\n        }\\n      }\\n      return \\\"meta\\\";\\n    };\\n  }\\n\\n  function Context(state, tagName, startOfLine) {\\n    this.prev = state.context;\\n    this.tagName = tagName;\\n    this.indent = state.indented;\\n    this.startOfLine = startOfLine;\\n    if (config.doNotIndent.hasOwnProperty(tagName) || (state.context && state.context.noIndent))\\n      this.noIndent = true;\\n  }\\n  function popContext(state) {\\n    if (state.context) state.context = state.context.prev;\\n  }\\n  function maybePopContext(state, nextTagName) {\\n    var parentTagName;\\n    while (true) {\\n      if (!state.context) {\\n        return;\\n      }\\n      parentTagName = state.context.tagName;\\n      if (!config.contextGrabbers.hasOwnProperty(parentTagName) ||\\n          !config.contextGrabbers[parentTagName].hasOwnProperty(nextTagName)) {\\n        return;\\n      }\\n      popContext(state);\\n    }\\n  }\\n\\n  function baseState(type, stream, state) {\\n    if (type == \\\"openTag\\\") {\\n      state.tagStart = stream.column();\\n      return tagNameState;\\n    } else if (type == \\\"closeTag\\\") {\\n      return closeTagNameState;\\n    } else {\\n      return baseState;\\n    }\\n  }\\n  function tagNameState(type, stream, state) {\\n    if (type == \\\"word\\\") {\\n      state.tagName = stream.current();\\n      setStyle = \\\"tag\\\";\\n      return attrState;\\n    } else {\\n      setStyle = \\\"error\\\";\\n      return tagNameState;\\n    }\\n  }\\n  function closeTagNameState(type, stream, state) {\\n    if (type == \\\"word\\\") {\\n      var tagName = stream.current();\\n      if (state.context && state.context.tagName != tagName &&\\n          config.implicitlyClosed.hasOwnProperty(state.context.tagName))\\n        popContext(state);\\n      if ((state.context && state.context.tagName == tagName) || config.matchClosing === false) {\\n        setStyle = \\\"tag\\\";\\n        return closeState;\\n      } else {\\n        setStyle = \\\"tag error\\\";\\n        return closeStateErr;\\n      }\\n    } else {\\n      setStyle = \\\"error\\\";\\n      return closeStateErr;\\n    }\\n  }\\n\\n  function closeState(type, _stream, state) {\\n    if (type != \\\"endTag\\\") {\\n      setStyle = \\\"error\\\";\\n      return closeState;\\n    }\\n    popContext(state);\\n    return baseState;\\n  }\\n  function closeStateErr(type, stream, state) {\\n    setStyle = \\\"error\\\";\\n    return closeState(type, stream, state);\\n  }\\n\\n  function attrState(type, _stream, state) {\\n    if (type == \\\"word\\\") {\\n      setStyle = \\\"attribute\\\";\\n      return attrEqState;\\n    } else if (type == \\\"endTag\\\" || type == \\\"selfcloseTag\\\") {\\n      var tagName = state.tagName, tagStart = state.tagStart;\\n      state.tagName = state.tagStart = null;\\n      if (type == \\\"selfcloseTag\\\" ||\\n          config.autoSelfClosers.hasOwnProperty(tagName)) {\\n        maybePopContext(state, tagName);\\n      } else {\\n        maybePopContext(state, tagName);\\n        state.context = new Context(state, tagName, tagStart == state.indented);\\n      }\\n      return baseState;\\n    }\\n    setStyle = \\\"error\\\";\\n    return attrState;\\n  }\\n  function attrEqState(type, stream, state) {\\n    if (type == \\\"equals\\\") return attrValueState;\\n    if (!config.allowMissing) setStyle = \\\"error\\\";\\n    return attrState(type, stream, state);\\n  }\\n  function attrValueState(type, stream, state) {\\n    if (type == \\\"string\\\") return attrContinuedState;\\n    if (type == \\\"word\\\" && config.allowUnquoted) {setStyle = \\\"string\\\"; return attrState;}\\n    setStyle = \\\"error\\\";\\n    return attrState(type, stream, state);\\n  }\\n  function attrContinuedState(type, stream, state) {\\n    if (type == \\\"string\\\") return attrContinuedState;\\n    return attrState(type, stream, state);\\n  }\\n\\n  return {\\n    startState: function(baseIndent) {\\n      var state = {tokenize: inText,\\n                   state: baseState,\\n                   indented: baseIndent || 0,\\n                   tagName: null, tagStart: null,\\n                   context: null}\\n      if (baseIndent != null) state.baseIndent = baseIndent\\n      return state\\n    },\\n\\n    token: function(stream, state) {\\n      if (!state.tagName && stream.sol())\\n        state.indented = stream.indentation();\\n\\n      if (stream.eatSpace()) return null;\\n      type = null;\\n      var style = state.tokenize(stream, state);\\n      if ((style || type) && style != \\\"comment\\\") {\\n        setStyle = null;\\n        state.state = state.state(type || style, stream, state);\\n        if (setStyle)\\n          style = setStyle == \\\"error\\\" ? style + \\\" error\\\" : setStyle;\\n      }\\n      return style;\\n    },\\n\\n    indent: function(state, textAfter, fullLine) {\\n      var context = state.context;\\n      // Indent multi-line strings (e.g. css).\\n      if (state.tokenize.isInAttribute) {\\n        if (state.tagStart == state.indented)\\n          return state.stringStartCol + 1;\\n        else\\n          return state.indented + indentUnit;\\n      }\\n      if (context && context.noIndent) return CodeMirror.Pass;\\n      if (state.tokenize != inTag && state.tokenize != inText)\\n        return fullLine ? fullLine.match(/^(\\\\s*)/)[0].length : 0;\\n      // Indent the starts of attribute names.\\n      if (state.tagName) {\\n        if (config.multilineTagIndentPastTag !== false)\\n          return state.tagStart + state.tagName.length + 2;\\n        else\\n          return state.tagStart + indentUnit * (config.multilineTagIndentFactor || 1);\\n      }\\n      if (config.alignCDATA && /<!\\\\[CDATA\\\\[/.test(textAfter)) return 0;\\n      var tagAfter = textAfter && /^<(\\\\/)?([\\\\w_:\\\\.-]*)/.exec(textAfter);\\n      if (tagAfter && tagAfter[1]) { // Closing tag spotted\\n        while (context) {\\n          if (context.tagName == tagAfter[2]) {\\n            context = context.prev;\\n            break;\\n          } else if (config.implicitlyClosed.hasOwnProperty(context.tagName)) {\\n            context = context.prev;\\n          } else {\\n            break;\\n          }\\n        }\\n      } else if (tagAfter) { // Opening tag spotted\\n        while (context) {\\n          var grabbers = config.contextGrabbers[context.tagName];\\n          if (grabbers && grabbers.hasOwnProperty(tagAfter[2]))\\n            context = context.prev;\\n          else\\n            break;\\n        }\\n      }\\n      while (context && context.prev && !context.startOfLine)\\n        context = context.prev;\\n      if (context) return context.indent + indentUnit;\\n      else return state.baseIndent || 0;\\n    },\\n\\n    electricInput: /<\\\\/[\\\\s\\\\w:]+>$/,\\n    blockCommentStart: \\\"<!--\\\",\\n    blockCommentEnd: \\\"-->\\\",\\n\\n    configuration: config.htmlMode ? \\\"html\\\" : \\\"xml\\\",\\n    helperType: config.htmlMode ? \\\"html\\\" : \\\"xml\\\",\\n\\n    skipAttribute: function(state) {\\n      if (state.state == attrValueState)\\n        state.state = attrState\\n    }\\n  };\\n});\\n\\nCodeMirror.defineMIME(\\\"text/xml\\\", \\\"xml\\\");\\nCodeMirror.defineMIME(\\\"application/xml\\\", \\\"xml\\\");\\nif (!CodeMirror.mimeModes.hasOwnProperty(\\\"text/html\\\"))\\n  CodeMirror.defineMIME(\\\"text/html\\\", {name: \\\"xml\\\", htmlMode: true});\\n\\n});\\n\"//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL34vY29kZW1pcnJvci9tb2RlL3htbC94bWwuanM/Y2MzNSJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IFwiLy8gQ29kZU1pcnJvciwgY29weXJpZ2h0IChjKSBieSBNYXJpam4gSGF2ZXJiZWtlIGFuZCBvdGhlcnNcXG4vLyBEaXN0cmlidXRlZCB1bmRlciBhbiBNSVQgbGljZW5zZTogaHR0cDovL2NvZGVtaXJyb3IubmV0L0xJQ0VOU0VcXG5cXG4oZnVuY3Rpb24obW9kKSB7XFxuICBpZiAodHlwZW9mIGV4cG9ydHMgPT0gXFxcIm9iamVjdFxcXCIgJiYgdHlwZW9mIG1vZHVsZSA9PSBcXFwib2JqZWN0XFxcIikgLy8gQ29tbW9uSlNcXG4gICAgbW9kKHJlcXVpcmUoXFxcIi4uLy4uL2xpYi9jb2RlbWlycm9yXFxcIikpO1xcbiAgZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PSBcXFwiZnVuY3Rpb25cXFwiICYmIGRlZmluZS5hbWQpIC8vIEFNRFxcbiAgICBkZWZpbmUoW1xcXCIuLi8uLi9saWIvY29kZW1pcnJvclxcXCJdLCBtb2QpO1xcbiAgZWxzZSAvLyBQbGFpbiBicm93c2VyIGVudlxcbiAgICBtb2QoQ29kZU1pcnJvcik7XFxufSkoZnVuY3Rpb24oQ29kZU1pcnJvcikge1xcblxcXCJ1c2Ugc3RyaWN0XFxcIjtcXG5cXG52YXIgaHRtbENvbmZpZyA9IHtcXG4gIGF1dG9TZWxmQ2xvc2VyczogeydhcmVhJzogdHJ1ZSwgJ2Jhc2UnOiB0cnVlLCAnYnInOiB0cnVlLCAnY29sJzogdHJ1ZSwgJ2NvbW1hbmQnOiB0cnVlLFxcbiAgICAgICAgICAgICAgICAgICAgJ2VtYmVkJzogdHJ1ZSwgJ2ZyYW1lJzogdHJ1ZSwgJ2hyJzogdHJ1ZSwgJ2ltZyc6IHRydWUsICdpbnB1dCc6IHRydWUsXFxuICAgICAgICAgICAgICAgICAgICAna2V5Z2VuJzogdHJ1ZSwgJ2xpbmsnOiB0cnVlLCAnbWV0YSc6IHRydWUsICdwYXJhbSc6IHRydWUsICdzb3VyY2UnOiB0cnVlLFxcbiAgICAgICAgICAgICAgICAgICAgJ3RyYWNrJzogdHJ1ZSwgJ3dicic6IHRydWUsICdtZW51aXRlbSc6IHRydWV9LFxcbiAgaW1wbGljaXRseUNsb3NlZDogeydkZCc6IHRydWUsICdsaSc6IHRydWUsICdvcHRncm91cCc6IHRydWUsICdvcHRpb24nOiB0cnVlLCAncCc6IHRydWUsXFxuICAgICAgICAgICAgICAgICAgICAgJ3JwJzogdHJ1ZSwgJ3J0JzogdHJ1ZSwgJ3Rib2R5JzogdHJ1ZSwgJ3RkJzogdHJ1ZSwgJ3Rmb290JzogdHJ1ZSxcXG4gICAgICAgICAgICAgICAgICAgICAndGgnOiB0cnVlLCAndHInOiB0cnVlfSxcXG4gIGNvbnRleHRHcmFiYmVyczoge1xcbiAgICAnZGQnOiB7J2RkJzogdHJ1ZSwgJ2R0JzogdHJ1ZX0sXFxuICAgICdkdCc6IHsnZGQnOiB0cnVlLCAnZHQnOiB0cnVlfSxcXG4gICAgJ2xpJzogeydsaSc6IHRydWV9LFxcbiAgICAnb3B0aW9uJzogeydvcHRpb24nOiB0cnVlLCAnb3B0Z3JvdXAnOiB0cnVlfSxcXG4gICAgJ29wdGdyb3VwJzogeydvcHRncm91cCc6IHRydWV9LFxcbiAgICAncCc6IHsnYWRkcmVzcyc6IHRydWUsICdhcnRpY2xlJzogdHJ1ZSwgJ2FzaWRlJzogdHJ1ZSwgJ2Jsb2NrcXVvdGUnOiB0cnVlLCAnZGlyJzogdHJ1ZSxcXG4gICAgICAgICAgJ2Rpdic6IHRydWUsICdkbCc6IHRydWUsICdmaWVsZHNldCc6IHRydWUsICdmb290ZXInOiB0cnVlLCAnZm9ybSc6IHRydWUsXFxuICAgICAgICAgICdoMSc6IHRydWUsICdoMic6IHRydWUsICdoMyc6IHRydWUsICdoNCc6IHRydWUsICdoNSc6IHRydWUsICdoNic6IHRydWUsXFxuICAgICAgICAgICdoZWFkZXInOiB0cnVlLCAnaGdyb3VwJzogdHJ1ZSwgJ2hyJzogdHJ1ZSwgJ21lbnUnOiB0cnVlLCAnbmF2JzogdHJ1ZSwgJ29sJzogdHJ1ZSxcXG4gICAgICAgICAgJ3AnOiB0cnVlLCAncHJlJzogdHJ1ZSwgJ3NlY3Rpb24nOiB0cnVlLCAndGFibGUnOiB0cnVlLCAndWwnOiB0cnVlfSxcXG4gICAgJ3JwJzogeydycCc6IHRydWUsICdydCc6IHRydWV9LFxcbiAgICAncnQnOiB7J3JwJzogdHJ1ZSwgJ3J0JzogdHJ1ZX0sXFxuICAgICd0Ym9keSc6IHsndGJvZHknOiB0cnVlLCAndGZvb3QnOiB0cnVlfSxcXG4gICAgJ3RkJzogeyd0ZCc6IHRydWUsICd0aCc6IHRydWV9LFxcbiAgICAndGZvb3QnOiB7J3Rib2R5JzogdHJ1ZX0sXFxuICAgICd0aCc6IHsndGQnOiB0cnVlLCAndGgnOiB0cnVlfSxcXG4gICAgJ3RoZWFkJzogeyd0Ym9keSc6IHRydWUsICd0Zm9vdCc6IHRydWV9LFxcbiAgICAndHInOiB7J3RyJzogdHJ1ZX1cXG4gIH0sXFxuICBkb05vdEluZGVudDoge1xcXCJwcmVcXFwiOiB0cnVlfSxcXG4gIGFsbG93VW5xdW90ZWQ6IHRydWUsXFxuICBhbGxvd01pc3Npbmc6IHRydWUsXFxuICBjYXNlRm9sZDogdHJ1ZVxcbn1cXG5cXG52YXIgeG1sQ29uZmlnID0ge1xcbiAgYXV0b1NlbGZDbG9zZXJzOiB7fSxcXG4gIGltcGxpY2l0bHlDbG9zZWQ6IHt9LFxcbiAgY29udGV4dEdyYWJiZXJzOiB7fSxcXG4gIGRvTm90SW5kZW50OiB7fSxcXG4gIGFsbG93VW5xdW90ZWQ6IGZhbHNlLFxcbiAgYWxsb3dNaXNzaW5nOiBmYWxzZSxcXG4gIGNhc2VGb2xkOiBmYWxzZVxcbn1cXG5cXG5Db2RlTWlycm9yLmRlZmluZU1vZGUoXFxcInhtbFxcXCIsIGZ1bmN0aW9uKGVkaXRvckNvbmYsIGNvbmZpZ18pIHtcXG4gIHZhciBpbmRlbnRVbml0ID0gZWRpdG9yQ29uZi5pbmRlbnRVbml0XFxuICB2YXIgY29uZmlnID0ge31cXG4gIHZhciBkZWZhdWx0cyA9IGNvbmZpZ18uaHRtbE1vZGUgPyBodG1sQ29uZmlnIDogeG1sQ29uZmlnXFxuICBmb3IgKHZhciBwcm9wIGluIGRlZmF1bHRzKSBjb25maWdbcHJvcF0gPSBkZWZhdWx0c1twcm9wXVxcbiAgZm9yICh2YXIgcHJvcCBpbiBjb25maWdfKSBjb25maWdbcHJvcF0gPSBjb25maWdfW3Byb3BdXFxuXFxuICAvLyBSZXR1cm4gdmFyaWFibGVzIGZvciB0b2tlbml6ZXJzXFxuICB2YXIgdHlwZSwgc2V0U3R5bGU7XFxuXFxuICBmdW5jdGlvbiBpblRleHQoc3RyZWFtLCBzdGF0ZSkge1xcbiAgICBmdW5jdGlvbiBjaGFpbihwYXJzZXIpIHtcXG4gICAgICBzdGF0ZS50b2tlbml6ZSA9IHBhcnNlcjtcXG4gICAgICByZXR1cm4gcGFyc2VyKHN0cmVhbSwgc3RhdGUpO1xcbiAgICB9XFxuXFxuICAgIHZhciBjaCA9IHN0cmVhbS5uZXh0KCk7XFxuICAgIGlmIChjaCA9PSBcXFwiPFxcXCIpIHtcXG4gICAgICBpZiAoc3RyZWFtLmVhdChcXFwiIVxcXCIpKSB7XFxuICAgICAgICBpZiAoc3RyZWFtLmVhdChcXFwiW1xcXCIpKSB7XFxuICAgICAgICAgIGlmIChzdHJlYW0ubWF0Y2goXFxcIkNEQVRBW1xcXCIpKSByZXR1cm4gY2hhaW4oaW5CbG9jayhcXFwiYXRvbVxcXCIsIFxcXCJdXT5cXFwiKSk7XFxuICAgICAgICAgIGVsc2UgcmV0dXJuIG51bGw7XFxuICAgICAgICB9IGVsc2UgaWYgKHN0cmVhbS5tYXRjaChcXFwiLS1cXFwiKSkge1xcbiAgICAgICAgICByZXR1cm4gY2hhaW4oaW5CbG9jayhcXFwiY29tbWVudFxcXCIsIFxcXCItLT5cXFwiKSk7XFxuICAgICAgICB9IGVsc2UgaWYgKHN0cmVhbS5tYXRjaChcXFwiRE9DVFlQRVxcXCIsIHRydWUsIHRydWUpKSB7XFxuICAgICAgICAgIHN0cmVhbS5lYXRXaGlsZSgvW1xcXFx3XFxcXC5fXFxcXC1dLyk7XFxuICAgICAgICAgIHJldHVybiBjaGFpbihkb2N0eXBlKDEpKTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIHJldHVybiBudWxsO1xcbiAgICAgICAgfVxcbiAgICAgIH0gZWxzZSBpZiAoc3RyZWFtLmVhdChcXFwiP1xcXCIpKSB7XFxuICAgICAgICBzdHJlYW0uZWF0V2hpbGUoL1tcXFxcd1xcXFwuX1xcXFwtXS8pO1xcbiAgICAgICAgc3RhdGUudG9rZW5pemUgPSBpbkJsb2NrKFxcXCJtZXRhXFxcIiwgXFxcIj8+XFxcIik7XFxuICAgICAgICByZXR1cm4gXFxcIm1ldGFcXFwiO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICB0eXBlID0gc3RyZWFtLmVhdChcXFwiL1xcXCIpID8gXFxcImNsb3NlVGFnXFxcIiA6IFxcXCJvcGVuVGFnXFxcIjtcXG4gICAgICAgIHN0YXRlLnRva2VuaXplID0gaW5UYWc7XFxuICAgICAgICByZXR1cm4gXFxcInRhZyBicmFja2V0XFxcIjtcXG4gICAgICB9XFxuICAgIH0gZWxzZSBpZiAoY2ggPT0gXFxcIiZcXFwiKSB7XFxuICAgICAgdmFyIG9rO1xcbiAgICAgIGlmIChzdHJlYW0uZWF0KFxcXCIjXFxcIikpIHtcXG4gICAgICAgIGlmIChzdHJlYW0uZWF0KFxcXCJ4XFxcIikpIHtcXG4gICAgICAgICAgb2sgPSBzdHJlYW0uZWF0V2hpbGUoL1thLWZBLUZcXFxcZF0vKSAmJiBzdHJlYW0uZWF0KFxcXCI7XFxcIik7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICBvayA9IHN0cmVhbS5lYXRXaGlsZSgvW1xcXFxkXS8pICYmIHN0cmVhbS5lYXQoXFxcIjtcXFwiKTtcXG4gICAgICAgIH1cXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgb2sgPSBzdHJlYW0uZWF0V2hpbGUoL1tcXFxcd1xcXFwuXFxcXC06XS8pICYmIHN0cmVhbS5lYXQoXFxcIjtcXFwiKTtcXG4gICAgICB9XFxuICAgICAgcmV0dXJuIG9rID8gXFxcImF0b21cXFwiIDogXFxcImVycm9yXFxcIjtcXG4gICAgfSBlbHNlIHtcXG4gICAgICBzdHJlYW0uZWF0V2hpbGUoL1teJjxdLyk7XFxuICAgICAgcmV0dXJuIG51bGw7XFxuICAgIH1cXG4gIH1cXG4gIGluVGV4dC5pc0luVGV4dCA9IHRydWU7XFxuXFxuICBmdW5jdGlvbiBpblRhZyhzdHJlYW0sIHN0YXRlKSB7XFxuICAgIHZhciBjaCA9IHN0cmVhbS5uZXh0KCk7XFxuICAgIGlmIChjaCA9PSBcXFwiPlxcXCIgfHwgKGNoID09IFxcXCIvXFxcIiAmJiBzdHJlYW0uZWF0KFxcXCI+XFxcIikpKSB7XFxuICAgICAgc3RhdGUudG9rZW5pemUgPSBpblRleHQ7XFxuICAgICAgdHlwZSA9IGNoID09IFxcXCI+XFxcIiA/IFxcXCJlbmRUYWdcXFwiIDogXFxcInNlbGZjbG9zZVRhZ1xcXCI7XFxuICAgICAgcmV0dXJuIFxcXCJ0YWcgYnJhY2tldFxcXCI7XFxuICAgIH0gZWxzZSBpZiAoY2ggPT0gXFxcIj1cXFwiKSB7XFxuICAgICAgdHlwZSA9IFxcXCJlcXVhbHNcXFwiO1xcbiAgICAgIHJldHVybiBudWxsO1xcbiAgICB9IGVsc2UgaWYgKGNoID09IFxcXCI8XFxcIikge1xcbiAgICAgIHN0YXRlLnRva2VuaXplID0gaW5UZXh0O1xcbiAgICAgIHN0YXRlLnN0YXRlID0gYmFzZVN0YXRlO1xcbiAgICAgIHN0YXRlLnRhZ05hbWUgPSBzdGF0ZS50YWdTdGFydCA9IG51bGw7XFxuICAgICAgdmFyIG5leHQgPSBzdGF0ZS50b2tlbml6ZShzdHJlYW0sIHN0YXRlKTtcXG4gICAgICByZXR1cm4gbmV4dCA/IG5leHQgKyBcXFwiIHRhZyBlcnJvclxcXCIgOiBcXFwidGFnIGVycm9yXFxcIjtcXG4gICAgfSBlbHNlIGlmICgvW1xcXFwnXFxcXFxcXCJdLy50ZXN0KGNoKSkge1xcbiAgICAgIHN0YXRlLnRva2VuaXplID0gaW5BdHRyaWJ1dGUoY2gpO1xcbiAgICAgIHN0YXRlLnN0cmluZ1N0YXJ0Q29sID0gc3RyZWFtLmNvbHVtbigpO1xcbiAgICAgIHJldHVybiBzdGF0ZS50b2tlbml6ZShzdHJlYW0sIHN0YXRlKTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICBzdHJlYW0ubWF0Y2goL15bXlxcXFxzXFxcXHUwMGEwPTw+XFxcXFxcXCJcXFxcJ10qW15cXFxcc1xcXFx1MDBhMD08PlxcXFxcXFwiXFxcXCdcXFxcL10vKTtcXG4gICAgICByZXR1cm4gXFxcIndvcmRcXFwiO1xcbiAgICB9XFxuICB9XFxuXFxuICBmdW5jdGlvbiBpbkF0dHJpYnV0ZShxdW90ZSkge1xcbiAgICB2YXIgY2xvc3VyZSA9IGZ1bmN0aW9uKHN0cmVhbSwgc3RhdGUpIHtcXG4gICAgICB3aGlsZSAoIXN0cmVhbS5lb2woKSkge1xcbiAgICAgICAgaWYgKHN0cmVhbS5uZXh0KCkgPT0gcXVvdGUpIHtcXG4gICAgICAgICAgc3RhdGUudG9rZW5pemUgPSBpblRhZztcXG4gICAgICAgICAgYnJlYWs7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICAgIHJldHVybiBcXFwic3RyaW5nXFxcIjtcXG4gICAgfTtcXG4gICAgY2xvc3VyZS5pc0luQXR0cmlidXRlID0gdHJ1ZTtcXG4gICAgcmV0dXJuIGNsb3N1cmU7XFxuICB9XFxuXFxuICBmdW5jdGlvbiBpbkJsb2NrKHN0eWxlLCB0ZXJtaW5hdG9yKSB7XFxuICAgIHJldHVybiBmdW5jdGlvbihzdHJlYW0sIHN0YXRlKSB7XFxuICAgICAgd2hpbGUgKCFzdHJlYW0uZW9sKCkpIHtcXG4gICAgICAgIGlmIChzdHJlYW0ubWF0Y2godGVybWluYXRvcikpIHtcXG4gICAgICAgICAgc3RhdGUudG9rZW5pemUgPSBpblRleHQ7XFxuICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgfVxcbiAgICAgICAgc3RyZWFtLm5leHQoKTtcXG4gICAgICB9XFxuICAgICAgcmV0dXJuIHN0eWxlO1xcbiAgICB9O1xcbiAgfVxcbiAgZnVuY3Rpb24gZG9jdHlwZShkZXB0aCkge1xcbiAgICByZXR1cm4gZnVuY3Rpb24oc3RyZWFtLCBzdGF0ZSkge1xcbiAgICAgIHZhciBjaDtcXG4gICAgICB3aGlsZSAoKGNoID0gc3RyZWFtLm5leHQoKSkgIT0gbnVsbCkge1xcbiAgICAgICAgaWYgKGNoID09IFxcXCI8XFxcIikge1xcbiAgICAgICAgICBzdGF0ZS50b2tlbml6ZSA9IGRvY3R5cGUoZGVwdGggKyAxKTtcXG4gICAgICAgICAgcmV0dXJuIHN0YXRlLnRva2VuaXplKHN0cmVhbSwgc3RhdGUpO1xcbiAgICAgICAgfSBlbHNlIGlmIChjaCA9PSBcXFwiPlxcXCIpIHtcXG4gICAgICAgICAgaWYgKGRlcHRoID09IDEpIHtcXG4gICAgICAgICAgICBzdGF0ZS50b2tlbml6ZSA9IGluVGV4dDtcXG4gICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICBzdGF0ZS50b2tlbml6ZSA9IGRvY3R5cGUoZGVwdGggLSAxKTtcXG4gICAgICAgICAgICByZXR1cm4gc3RhdGUudG9rZW5pemUoc3RyZWFtLCBzdGF0ZSk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgICAgcmV0dXJuIFxcXCJtZXRhXFxcIjtcXG4gICAgfTtcXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIENvbnRleHQoc3RhdGUsIHRhZ05hbWUsIHN0YXJ0T2ZMaW5lKSB7XFxuICAgIHRoaXMucHJldiA9IHN0YXRlLmNvbnRleHQ7XFxuICAgIHRoaXMudGFnTmFtZSA9IHRhZ05hbWU7XFxuICAgIHRoaXMuaW5kZW50ID0gc3RhdGUuaW5kZW50ZWQ7XFxuICAgIHRoaXMuc3RhcnRPZkxpbmUgPSBzdGFydE9mTGluZTtcXG4gICAgaWYgKGNvbmZpZy5kb05vdEluZGVudC5oYXNPd25Qcm9wZXJ0eSh0YWdOYW1lKSB8fCAoc3RhdGUuY29udGV4dCAmJiBzdGF0ZS5jb250ZXh0Lm5vSW5kZW50KSlcXG4gICAgICB0aGlzLm5vSW5kZW50ID0gdHJ1ZTtcXG4gIH1cXG4gIGZ1bmN0aW9uIHBvcENvbnRleHQoc3RhdGUpIHtcXG4gICAgaWYgKHN0YXRlLmNvbnRleHQpIHN0YXRlLmNvbnRleHQgPSBzdGF0ZS5jb250ZXh0LnByZXY7XFxuICB9XFxuICBmdW5jdGlvbiBtYXliZVBvcENvbnRleHQoc3RhdGUsIG5leHRUYWdOYW1lKSB7XFxuICAgIHZhciBwYXJlbnRUYWdOYW1lO1xcbiAgICB3aGlsZSAodHJ1ZSkge1xcbiAgICAgIGlmICghc3RhdGUuY29udGV4dCkge1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICAgIH1cXG4gICAgICBwYXJlbnRUYWdOYW1lID0gc3RhdGUuY29udGV4dC50YWdOYW1lO1xcbiAgICAgIGlmICghY29uZmlnLmNvbnRleHRHcmFiYmVycy5oYXNPd25Qcm9wZXJ0eShwYXJlbnRUYWdOYW1lKSB8fFxcbiAgICAgICAgICAhY29uZmlnLmNvbnRleHRHcmFiYmVyc1twYXJlbnRUYWdOYW1lXS5oYXNPd25Qcm9wZXJ0eShuZXh0VGFnTmFtZSkpIHtcXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9XFxuICAgICAgcG9wQ29udGV4dChzdGF0ZSk7XFxuICAgIH1cXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIGJhc2VTdGF0ZSh0eXBlLCBzdHJlYW0sIHN0YXRlKSB7XFxuICAgIGlmICh0eXBlID09IFxcXCJvcGVuVGFnXFxcIikge1xcbiAgICAgIHN0YXRlLnRhZ1N0YXJ0ID0gc3RyZWFtLmNvbHVtbigpO1xcbiAgICAgIHJldHVybiB0YWdOYW1lU3RhdGU7XFxuICAgIH0gZWxzZSBpZiAodHlwZSA9PSBcXFwiY2xvc2VUYWdcXFwiKSB7XFxuICAgICAgcmV0dXJuIGNsb3NlVGFnTmFtZVN0YXRlO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIHJldHVybiBiYXNlU3RhdGU7XFxuICAgIH1cXG4gIH1cXG4gIGZ1bmN0aW9uIHRhZ05hbWVTdGF0ZSh0eXBlLCBzdHJlYW0sIHN0YXRlKSB7XFxuICAgIGlmICh0eXBlID09IFxcXCJ3b3JkXFxcIikge1xcbiAgICAgIHN0YXRlLnRhZ05hbWUgPSBzdHJlYW0uY3VycmVudCgpO1xcbiAgICAgIHNldFN0eWxlID0gXFxcInRhZ1xcXCI7XFxuICAgICAgcmV0dXJuIGF0dHJTdGF0ZTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICBzZXRTdHlsZSA9IFxcXCJlcnJvclxcXCI7XFxuICAgICAgcmV0dXJuIHRhZ05hbWVTdGF0ZTtcXG4gICAgfVxcbiAgfVxcbiAgZnVuY3Rpb24gY2xvc2VUYWdOYW1lU3RhdGUodHlwZSwgc3RyZWFtLCBzdGF0ZSkge1xcbiAgICBpZiAodHlwZSA9PSBcXFwid29yZFxcXCIpIHtcXG4gICAgICB2YXIgdGFnTmFtZSA9IHN0cmVhbS5jdXJyZW50KCk7XFxuICAgICAgaWYgKHN0YXRlLmNvbnRleHQgJiYgc3RhdGUuY29udGV4dC50YWdOYW1lICE9IHRhZ05hbWUgJiZcXG4gICAgICAgICAgY29uZmlnLmltcGxpY2l0bHlDbG9zZWQuaGFzT3duUHJvcGVydHkoc3RhdGUuY29udGV4dC50YWdOYW1lKSlcXG4gICAgICAgIHBvcENvbnRleHQoc3RhdGUpO1xcbiAgICAgIGlmICgoc3RhdGUuY29udGV4dCAmJiBzdGF0ZS5jb250ZXh0LnRhZ05hbWUgPT0gdGFnTmFtZSkgfHwgY29uZmlnLm1hdGNoQ2xvc2luZyA9PT0gZmFsc2UpIHtcXG4gICAgICAgIHNldFN0eWxlID0gXFxcInRhZ1xcXCI7XFxuICAgICAgICByZXR1cm4gY2xvc2VTdGF0ZTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgc2V0U3R5bGUgPSBcXFwidGFnIGVycm9yXFxcIjtcXG4gICAgICAgIHJldHVybiBjbG9zZVN0YXRlRXJyO1xcbiAgICAgIH1cXG4gICAgfSBlbHNlIHtcXG4gICAgICBzZXRTdHlsZSA9IFxcXCJlcnJvclxcXCI7XFxuICAgICAgcmV0dXJuIGNsb3NlU3RhdGVFcnI7XFxuICAgIH1cXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIGNsb3NlU3RhdGUodHlwZSwgX3N0cmVhbSwgc3RhdGUpIHtcXG4gICAgaWYgKHR5cGUgIT0gXFxcImVuZFRhZ1xcXCIpIHtcXG4gICAgICBzZXRTdHlsZSA9IFxcXCJlcnJvclxcXCI7XFxuICAgICAgcmV0dXJuIGNsb3NlU3RhdGU7XFxuICAgIH1cXG4gICAgcG9wQ29udGV4dChzdGF0ZSk7XFxuICAgIHJldHVybiBiYXNlU3RhdGU7XFxuICB9XFxuICBmdW5jdGlvbiBjbG9zZVN0YXRlRXJyKHR5cGUsIHN0cmVhbSwgc3RhdGUpIHtcXG4gICAgc2V0U3R5bGUgPSBcXFwiZXJyb3JcXFwiO1xcbiAgICByZXR1cm4gY2xvc2VTdGF0ZSh0eXBlLCBzdHJlYW0sIHN0YXRlKTtcXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIGF0dHJTdGF0ZSh0eXBlLCBfc3RyZWFtLCBzdGF0ZSkge1xcbiAgICBpZiAodHlwZSA9PSBcXFwid29yZFxcXCIpIHtcXG4gICAgICBzZXRTdHlsZSA9IFxcXCJhdHRyaWJ1dGVcXFwiO1xcbiAgICAgIHJldHVybiBhdHRyRXFTdGF0ZTtcXG4gICAgfSBlbHNlIGlmICh0eXBlID09IFxcXCJlbmRUYWdcXFwiIHx8IHR5cGUgPT0gXFxcInNlbGZjbG9zZVRhZ1xcXCIpIHtcXG4gICAgICB2YXIgdGFnTmFtZSA9IHN0YXRlLnRhZ05hbWUsIHRhZ1N0YXJ0ID0gc3RhdGUudGFnU3RhcnQ7XFxuICAgICAgc3RhdGUudGFnTmFtZSA9IHN0YXRlLnRhZ1N0YXJ0ID0gbnVsbDtcXG4gICAgICBpZiAodHlwZSA9PSBcXFwic2VsZmNsb3NlVGFnXFxcIiB8fFxcbiAgICAgICAgICBjb25maWcuYXV0b1NlbGZDbG9zZXJzLmhhc093blByb3BlcnR5KHRhZ05hbWUpKSB7XFxuICAgICAgICBtYXliZVBvcENvbnRleHQoc3RhdGUsIHRhZ05hbWUpO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBtYXliZVBvcENvbnRleHQoc3RhdGUsIHRhZ05hbWUpO1xcbiAgICAgICAgc3RhdGUuY29udGV4dCA9IG5ldyBDb250ZXh0KHN0YXRlLCB0YWdOYW1lLCB0YWdTdGFydCA9PSBzdGF0ZS5pbmRlbnRlZCk7XFxuICAgICAgfVxcbiAgICAgIHJldHVybiBiYXNlU3RhdGU7XFxuICAgIH1cXG4gICAgc2V0U3R5bGUgPSBcXFwiZXJyb3JcXFwiO1xcbiAgICByZXR1cm4gYXR0clN0YXRlO1xcbiAgfVxcbiAgZnVuY3Rpb24gYXR0ckVxU3RhdGUodHlwZSwgc3RyZWFtLCBzdGF0ZSkge1xcbiAgICBpZiAodHlwZSA9PSBcXFwiZXF1YWxzXFxcIikgcmV0dXJuIGF0dHJWYWx1ZVN0YXRlO1xcbiAgICBpZiAoIWNvbmZpZy5hbGxvd01pc3NpbmcpIHNldFN0eWxlID0gXFxcImVycm9yXFxcIjtcXG4gICAgcmV0dXJuIGF0dHJTdGF0ZSh0eXBlLCBzdHJlYW0sIHN0YXRlKTtcXG4gIH1cXG4gIGZ1bmN0aW9uIGF0dHJWYWx1ZVN0YXRlKHR5cGUsIHN0cmVhbSwgc3RhdGUpIHtcXG4gICAgaWYgKHR5cGUgPT0gXFxcInN0cmluZ1xcXCIpIHJldHVybiBhdHRyQ29udGludWVkU3RhdGU7XFxuICAgIGlmICh0eXBlID09IFxcXCJ3b3JkXFxcIiAmJiBjb25maWcuYWxsb3dVbnF1b3RlZCkge3NldFN0eWxlID0gXFxcInN0cmluZ1xcXCI7IHJldHVybiBhdHRyU3RhdGU7fVxcbiAgICBzZXRTdHlsZSA9IFxcXCJlcnJvclxcXCI7XFxuICAgIHJldHVybiBhdHRyU3RhdGUodHlwZSwgc3RyZWFtLCBzdGF0ZSk7XFxuICB9XFxuICBmdW5jdGlvbiBhdHRyQ29udGludWVkU3RhdGUodHlwZSwgc3RyZWFtLCBzdGF0ZSkge1xcbiAgICBpZiAodHlwZSA9PSBcXFwic3RyaW5nXFxcIikgcmV0dXJuIGF0dHJDb250aW51ZWRTdGF0ZTtcXG4gICAgcmV0dXJuIGF0dHJTdGF0ZSh0eXBlLCBzdHJlYW0sIHN0YXRlKTtcXG4gIH1cXG5cXG4gIHJldHVybiB7XFxuICAgIHN0YXJ0U3RhdGU6IGZ1bmN0aW9uKGJhc2VJbmRlbnQpIHtcXG4gICAgICB2YXIgc3RhdGUgPSB7dG9rZW5pemU6IGluVGV4dCxcXG4gICAgICAgICAgICAgICAgICAgc3RhdGU6IGJhc2VTdGF0ZSxcXG4gICAgICAgICAgICAgICAgICAgaW5kZW50ZWQ6IGJhc2VJbmRlbnQgfHwgMCxcXG4gICAgICAgICAgICAgICAgICAgdGFnTmFtZTogbnVsbCwgdGFnU3RhcnQ6IG51bGwsXFxuICAgICAgICAgICAgICAgICAgIGNvbnRleHQ6IG51bGx9XFxuICAgICAgaWYgKGJhc2VJbmRlbnQgIT0gbnVsbCkgc3RhdGUuYmFzZUluZGVudCA9IGJhc2VJbmRlbnRcXG4gICAgICByZXR1cm4gc3RhdGVcXG4gICAgfSxcXG5cXG4gICAgdG9rZW46IGZ1bmN0aW9uKHN0cmVhbSwgc3RhdGUpIHtcXG4gICAgICBpZiAoIXN0YXRlLnRhZ05hbWUgJiYgc3RyZWFtLnNvbCgpKVxcbiAgICAgICAgc3RhdGUuaW5kZW50ZWQgPSBzdHJlYW0uaW5kZW50YXRpb24oKTtcXG5cXG4gICAgICBpZiAoc3RyZWFtLmVhdFNwYWNlKCkpIHJldHVybiBudWxsO1xcbiAgICAgIHR5cGUgPSBudWxsO1xcbiAgICAgIHZhciBzdHlsZSA9IHN0YXRlLnRva2VuaXplKHN0cmVhbSwgc3RhdGUpO1xcbiAgICAgIGlmICgoc3R5bGUgfHwgdHlwZSkgJiYgc3R5bGUgIT0gXFxcImNvbW1lbnRcXFwiKSB7XFxuICAgICAgICBzZXRTdHlsZSA9IG51bGw7XFxuICAgICAgICBzdGF0ZS5zdGF0ZSA9IHN0YXRlLnN0YXRlKHR5cGUgfHwgc3R5bGUsIHN0cmVhbSwgc3RhdGUpO1xcbiAgICAgICAgaWYgKHNldFN0eWxlKVxcbiAgICAgICAgICBzdHlsZSA9IHNldFN0eWxlID09IFxcXCJlcnJvclxcXCIgPyBzdHlsZSArIFxcXCIgZXJyb3JcXFwiIDogc2V0U3R5bGU7XFxuICAgICAgfVxcbiAgICAgIHJldHVybiBzdHlsZTtcXG4gICAgfSxcXG5cXG4gICAgaW5kZW50OiBmdW5jdGlvbihzdGF0ZSwgdGV4dEFmdGVyLCBmdWxsTGluZSkge1xcbiAgICAgIHZhciBjb250ZXh0ID0gc3RhdGUuY29udGV4dDtcXG4gICAgICAvLyBJbmRlbnQgbXVsdGktbGluZSBzdHJpbmdzIChlLmcuIGNzcykuXFxuICAgICAgaWYgKHN0YXRlLnRva2VuaXplLmlzSW5BdHRyaWJ1dGUpIHtcXG4gICAgICAgIGlmIChzdGF0ZS50YWdTdGFydCA9PSBzdGF0ZS5pbmRlbnRlZClcXG4gICAgICAgICAgcmV0dXJuIHN0YXRlLnN0cmluZ1N0YXJ0Q29sICsgMTtcXG4gICAgICAgIGVsc2VcXG4gICAgICAgICAgcmV0dXJuIHN0YXRlLmluZGVudGVkICsgaW5kZW50VW5pdDtcXG4gICAgICB9XFxuICAgICAgaWYgKGNvbnRleHQgJiYgY29udGV4dC5ub0luZGVudCkgcmV0dXJuIENvZGVNaXJyb3IuUGFzcztcXG4gICAgICBpZiAoc3RhdGUudG9rZW5pemUgIT0gaW5UYWcgJiYgc3RhdGUudG9rZW5pemUgIT0gaW5UZXh0KVxcbiAgICAgICAgcmV0dXJuIGZ1bGxMaW5lID8gZnVsbExpbmUubWF0Y2goL14oXFxcXHMqKS8pWzBdLmxlbmd0aCA6IDA7XFxuICAgICAgLy8gSW5kZW50IHRoZSBzdGFydHMgb2YgYXR0cmlidXRlIG5hbWVzLlxcbiAgICAgIGlmIChzdGF0ZS50YWdOYW1lKSB7XFxuICAgICAgICBpZiAoY29uZmlnLm11bHRpbGluZVRhZ0luZGVudFBhc3RUYWcgIT09IGZhbHNlKVxcbiAgICAgICAgICByZXR1cm4gc3RhdGUudGFnU3RhcnQgKyBzdGF0ZS50YWdOYW1lLmxlbmd0aCArIDI7XFxuICAgICAgICBlbHNlXFxuICAgICAgICAgIHJldHVybiBzdGF0ZS50YWdTdGFydCArIGluZGVudFVuaXQgKiAoY29uZmlnLm11bHRpbGluZVRhZ0luZGVudEZhY3RvciB8fCAxKTtcXG4gICAgICB9XFxuICAgICAgaWYgKGNvbmZpZy5hbGlnbkNEQVRBICYmIC88IVxcXFxbQ0RBVEFcXFxcWy8udGVzdCh0ZXh0QWZ0ZXIpKSByZXR1cm4gMDtcXG4gICAgICB2YXIgdGFnQWZ0ZXIgPSB0ZXh0QWZ0ZXIgJiYgL148KFxcXFwvKT8oW1xcXFx3XzpcXFxcLi1dKikvLmV4ZWModGV4dEFmdGVyKTtcXG4gICAgICBpZiAodGFnQWZ0ZXIgJiYgdGFnQWZ0ZXJbMV0pIHsgLy8gQ2xvc2luZyB0YWcgc3BvdHRlZFxcbiAgICAgICAgd2hpbGUgKGNvbnRleHQpIHtcXG4gICAgICAgICAgaWYgKGNvbnRleHQudGFnTmFtZSA9PSB0YWdBZnRlclsyXSkge1xcbiAgICAgICAgICAgIGNvbnRleHQgPSBjb250ZXh0LnByZXY7XFxuICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgIH0gZWxzZSBpZiAoY29uZmlnLmltcGxpY2l0bHlDbG9zZWQuaGFzT3duUHJvcGVydHkoY29udGV4dC50YWdOYW1lKSkge1xcbiAgICAgICAgICAgIGNvbnRleHQgPSBjb250ZXh0LnByZXY7XFxuICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICB9IGVsc2UgaWYgKHRhZ0FmdGVyKSB7IC8vIE9wZW5pbmcgdGFnIHNwb3R0ZWRcXG4gICAgICAgIHdoaWxlIChjb250ZXh0KSB7XFxuICAgICAgICAgIHZhciBncmFiYmVycyA9IGNvbmZpZy5jb250ZXh0R3JhYmJlcnNbY29udGV4dC50YWdOYW1lXTtcXG4gICAgICAgICAgaWYgKGdyYWJiZXJzICYmIGdyYWJiZXJzLmhhc093blByb3BlcnR5KHRhZ0FmdGVyWzJdKSlcXG4gICAgICAgICAgICBjb250ZXh0ID0gY29udGV4dC5wcmV2O1xcbiAgICAgICAgICBlbHNlXFxuICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICAgIHdoaWxlIChjb250ZXh0ICYmIGNvbnRleHQucHJldiAmJiAhY29udGV4dC5zdGFydE9mTGluZSlcXG4gICAgICAgIGNvbnRleHQgPSBjb250ZXh0LnByZXY7XFxuICAgICAgaWYgKGNvbnRleHQpIHJldHVybiBjb250ZXh0LmluZGVudCArIGluZGVudFVuaXQ7XFxuICAgICAgZWxzZSByZXR1cm4gc3RhdGUuYmFzZUluZGVudCB8fCAwO1xcbiAgICB9LFxcblxcbiAgICBlbGVjdHJpY0lucHV0OiAvPFxcXFwvW1xcXFxzXFxcXHc6XSs+JC8sXFxuICAgIGJsb2NrQ29tbWVudFN0YXJ0OiBcXFwiPCEtLVxcXCIsXFxuICAgIGJsb2NrQ29tbWVudEVuZDogXFxcIi0tPlxcXCIsXFxuXFxuICAgIGNvbmZpZ3VyYXRpb246IGNvbmZpZy5odG1sTW9kZSA/IFxcXCJodG1sXFxcIiA6IFxcXCJ4bWxcXFwiLFxcbiAgICBoZWxwZXJUeXBlOiBjb25maWcuaHRtbE1vZGUgPyBcXFwiaHRtbFxcXCIgOiBcXFwieG1sXFxcIixcXG5cXG4gICAgc2tpcEF0dHJpYnV0ZTogZnVuY3Rpb24oc3RhdGUpIHtcXG4gICAgICBpZiAoc3RhdGUuc3RhdGUgPT0gYXR0clZhbHVlU3RhdGUpXFxuICAgICAgICBzdGF0ZS5zdGF0ZSA9IGF0dHJTdGF0ZVxcbiAgICB9XFxuICB9O1xcbn0pO1xcblxcbkNvZGVNaXJyb3IuZGVmaW5lTUlNRShcXFwidGV4dC94bWxcXFwiLCBcXFwieG1sXFxcIik7XFxuQ29kZU1pcnJvci5kZWZpbmVNSU1FKFxcXCJhcHBsaWNhdGlvbi94bWxcXFwiLCBcXFwieG1sXFxcIik7XFxuaWYgKCFDb2RlTWlycm9yLm1pbWVNb2Rlcy5oYXNPd25Qcm9wZXJ0eShcXFwidGV4dC9odG1sXFxcIikpXFxuICBDb2RlTWlycm9yLmRlZmluZU1JTUUoXFxcInRleHQvaHRtbFxcXCIsIHtuYW1lOiBcXFwieG1sXFxcIiwgaHRtbE1vZGU6IHRydWV9KTtcXG5cXG59KTtcXG5cIlxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yYXctbG9hZGVyIS4vfi9jb2RlbWlycm9yL21vZGUveG1sL3htbC5qc1xuLy8gbW9kdWxlIGlkID0gN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	eval("__webpack_require__(2)(__webpack_require__(9))//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL34vZnJvYWxhLWVkaXRvci9qcy9wbHVnaW5zL2FsaWduLm1pbi5qcz9jYzMxIl0sInNvdXJjZXNDb250ZW50IjpbInJlcXVpcmUoXCIhIS9Vc2Vycy9qYWt1YmZhamt1cy9Eb2N1bWVudHMvcHJhY2UvdmVuaWNlLWRlbW8vd2ViL2pzL25vZGVfbW9kdWxlcy9zY3JpcHQtbG9hZGVyL2FkZFNjcmlwdC5qc1wiKShyZXF1aXJlKFwiISEvVXNlcnMvamFrdWJmYWprdXMvRG9jdW1lbnRzL3ByYWNlL3ZlbmljZS1kZW1vL3dlYi9qcy9ub2RlX21vZHVsZXMvcmF3LWxvYWRlci9pbmRleC5qcyEvVXNlcnMvamFrdWJmYWprdXMvRG9jdW1lbnRzL3ByYWNlL3ZlbmljZS1kZW1vL3dlYi9qcy9ub2RlX21vZHVsZXMvZnJvYWxhLWVkaXRvci9qcy9wbHVnaW5zL2FsaWduLm1pbi5qc1wiKSlcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vc2NyaXB0LWxvYWRlciEuL34vZnJvYWxhLWVkaXRvci9qcy9wbHVnaW5zL2FsaWduLm1pbi5qc1xuLy8gbW9kdWxlIGlkID0gOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 9 */
/***/ function(module, exports) {

	eval("module.exports = \"/*!\\n * froala_editor v2.5.0 (https://www.froala.com/wysiwyg-editor)\\n * License https://froala.com/wysiwyg-editor/terms/\\n * Copyright 2014-2017 Froala Labs\\n */\\n\\n!function(a){\\\"function\\\"==typeof define&&define.amd?define([\\\"jquery\\\"],a):\\\"object\\\"==typeof module&&module.exports?module.exports=function(b,c){return void 0===c&&(c=\\\"undefined\\\"!=typeof window?require(\\\"jquery\\\"):require(\\\"jquery\\\")(b)),a(c)}:a(window.jQuery)}(function(a){a.FE.PLUGINS.align=function(b){function c(c){b.selection.save(),b.html.wrap(!0,!0,!0,!0),b.selection.restore();for(var d=b.selection.blocks(),e=0;e<d.length;e++)b.helpers.getAlignment(a(d[e].parentNode))==c?a(d[e]).css(\\\"text-align\\\",\\\"\\\").removeClass(\\\"fr-temp-div\\\"):a(d[e]).css(\\\"text-align\\\",c).removeClass(\\\"fr-temp-div\\\"),\\\"\\\"===a(d[e]).attr(\\\"class\\\")&&a(d[e]).removeAttr(\\\"class\\\"),\\\"\\\"===a(d[e]).attr(\\\"style\\\")&&a(d[e]).removeAttr(\\\"style\\\");b.selection.save(),b.html.unwrap(),b.selection.restore()}function d(c){var d=b.selection.blocks();if(d.length){var e=b.helpers.getAlignment(a(d[0]));c.find(\\\"> *:first\\\").replaceWith(b.icon.create(\\\"align-\\\"+e))}}function e(c,d){var e=b.selection.blocks();if(e.length){var f=b.helpers.getAlignment(a(e[0]));d.find('a.fr-command[data-param1=\\\"'+f+'\\\"]').addClass(\\\"fr-active\\\").attr(\\\"aria-selected\\\",!0)}}return{apply:c,refresh:d,refreshOnShow:e}},a.FE.DefineIcon(\\\"align\\\",{NAME:\\\"align-left\\\"}),a.FE.DefineIcon(\\\"align-left\\\",{NAME:\\\"align-left\\\"}),a.FE.DefineIcon(\\\"align-right\\\",{NAME:\\\"align-right\\\"}),a.FE.DefineIcon(\\\"align-center\\\",{NAME:\\\"align-center\\\"}),a.FE.DefineIcon(\\\"align-justify\\\",{NAME:\\\"align-justify\\\"}),a.FE.RegisterCommand(\\\"align\\\",{type:\\\"dropdown\\\",title:\\\"Align\\\",options:{left:\\\"Align Left\\\",center:\\\"Align Center\\\",right:\\\"Align Right\\\",justify:\\\"Align Justify\\\"},html:function(){var b='<ul class=\\\"fr-dropdown-list\\\" role=\\\"presentation\\\">',c=a.FE.COMMANDS.align.options;for(var d in c)c.hasOwnProperty(d)&&(b+='<li role=\\\"presentation\\\"><a class=\\\"fr-command fr-title\\\" tabIndex=\\\"-1\\\" role=\\\"option\\\" data-cmd=\\\"align\\\" data-param1=\\\"'+d+'\\\" title=\\\"'+this.language.translate(c[d])+'\\\">'+this.icon.create(\\\"align-\\\"+d)+'<span class=\\\"fr-sr-only\\\">'+this.language.translate(c[d])+\\\"</span></a></li>\\\");return b+=\\\"</ul>\\\"},callback:function(a,b){this.align.apply(b)},refresh:function(a){this.align.refresh(a)},refreshOnShow:function(a,b){this.align.refreshOnShow(a,b)},plugin:\\\"align\\\"})});\"//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL34vZnJvYWxhLWVkaXRvci9qcy9wbHVnaW5zL2FsaWduLm1pbi5qcz9iYmFkIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gXCIvKiFcXG4gKiBmcm9hbGFfZWRpdG9yIHYyLjUuMCAoaHR0cHM6Ly93d3cuZnJvYWxhLmNvbS93eXNpd3lnLWVkaXRvcilcXG4gKiBMaWNlbnNlIGh0dHBzOi8vZnJvYWxhLmNvbS93eXNpd3lnLWVkaXRvci90ZXJtcy9cXG4gKiBDb3B5cmlnaHQgMjAxNC0yMDE3IEZyb2FsYSBMYWJzXFxuICovXFxuXFxuIWZ1bmN0aW9uKGEpe1xcXCJmdW5jdGlvblxcXCI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQ/ZGVmaW5lKFtcXFwianF1ZXJ5XFxcIl0sYSk6XFxcIm9iamVjdFxcXCI9PXR5cGVvZiBtb2R1bGUmJm1vZHVsZS5leHBvcnRzP21vZHVsZS5leHBvcnRzPWZ1bmN0aW9uKGIsYyl7cmV0dXJuIHZvaWQgMD09PWMmJihjPVxcXCJ1bmRlZmluZWRcXFwiIT10eXBlb2Ygd2luZG93P3JlcXVpcmUoXFxcImpxdWVyeVxcXCIpOnJlcXVpcmUoXFxcImpxdWVyeVxcXCIpKGIpKSxhKGMpfTphKHdpbmRvdy5qUXVlcnkpfShmdW5jdGlvbihhKXthLkZFLlBMVUdJTlMuYWxpZ249ZnVuY3Rpb24oYil7ZnVuY3Rpb24gYyhjKXtiLnNlbGVjdGlvbi5zYXZlKCksYi5odG1sLndyYXAoITAsITAsITAsITApLGIuc2VsZWN0aW9uLnJlc3RvcmUoKTtmb3IodmFyIGQ9Yi5zZWxlY3Rpb24uYmxvY2tzKCksZT0wO2U8ZC5sZW5ndGg7ZSsrKWIuaGVscGVycy5nZXRBbGlnbm1lbnQoYShkW2VdLnBhcmVudE5vZGUpKT09Yz9hKGRbZV0pLmNzcyhcXFwidGV4dC1hbGlnblxcXCIsXFxcIlxcXCIpLnJlbW92ZUNsYXNzKFxcXCJmci10ZW1wLWRpdlxcXCIpOmEoZFtlXSkuY3NzKFxcXCJ0ZXh0LWFsaWduXFxcIixjKS5yZW1vdmVDbGFzcyhcXFwiZnItdGVtcC1kaXZcXFwiKSxcXFwiXFxcIj09PWEoZFtlXSkuYXR0cihcXFwiY2xhc3NcXFwiKSYmYShkW2VdKS5yZW1vdmVBdHRyKFxcXCJjbGFzc1xcXCIpLFxcXCJcXFwiPT09YShkW2VdKS5hdHRyKFxcXCJzdHlsZVxcXCIpJiZhKGRbZV0pLnJlbW92ZUF0dHIoXFxcInN0eWxlXFxcIik7Yi5zZWxlY3Rpb24uc2F2ZSgpLGIuaHRtbC51bndyYXAoKSxiLnNlbGVjdGlvbi5yZXN0b3JlKCl9ZnVuY3Rpb24gZChjKXt2YXIgZD1iLnNlbGVjdGlvbi5ibG9ja3MoKTtpZihkLmxlbmd0aCl7dmFyIGU9Yi5oZWxwZXJzLmdldEFsaWdubWVudChhKGRbMF0pKTtjLmZpbmQoXFxcIj4gKjpmaXJzdFxcXCIpLnJlcGxhY2VXaXRoKGIuaWNvbi5jcmVhdGUoXFxcImFsaWduLVxcXCIrZSkpfX1mdW5jdGlvbiBlKGMsZCl7dmFyIGU9Yi5zZWxlY3Rpb24uYmxvY2tzKCk7aWYoZS5sZW5ndGgpe3ZhciBmPWIuaGVscGVycy5nZXRBbGlnbm1lbnQoYShlWzBdKSk7ZC5maW5kKCdhLmZyLWNvbW1hbmRbZGF0YS1wYXJhbTE9XFxcIicrZisnXFxcIl0nKS5hZGRDbGFzcyhcXFwiZnItYWN0aXZlXFxcIikuYXR0cihcXFwiYXJpYS1zZWxlY3RlZFxcXCIsITApfX1yZXR1cm57YXBwbHk6YyxyZWZyZXNoOmQscmVmcmVzaE9uU2hvdzplfX0sYS5GRS5EZWZpbmVJY29uKFxcXCJhbGlnblxcXCIse05BTUU6XFxcImFsaWduLWxlZnRcXFwifSksYS5GRS5EZWZpbmVJY29uKFxcXCJhbGlnbi1sZWZ0XFxcIix7TkFNRTpcXFwiYWxpZ24tbGVmdFxcXCJ9KSxhLkZFLkRlZmluZUljb24oXFxcImFsaWduLXJpZ2h0XFxcIix7TkFNRTpcXFwiYWxpZ24tcmlnaHRcXFwifSksYS5GRS5EZWZpbmVJY29uKFxcXCJhbGlnbi1jZW50ZXJcXFwiLHtOQU1FOlxcXCJhbGlnbi1jZW50ZXJcXFwifSksYS5GRS5EZWZpbmVJY29uKFxcXCJhbGlnbi1qdXN0aWZ5XFxcIix7TkFNRTpcXFwiYWxpZ24tanVzdGlmeVxcXCJ9KSxhLkZFLlJlZ2lzdGVyQ29tbWFuZChcXFwiYWxpZ25cXFwiLHt0eXBlOlxcXCJkcm9wZG93blxcXCIsdGl0bGU6XFxcIkFsaWduXFxcIixvcHRpb25zOntsZWZ0OlxcXCJBbGlnbiBMZWZ0XFxcIixjZW50ZXI6XFxcIkFsaWduIENlbnRlclxcXCIscmlnaHQ6XFxcIkFsaWduIFJpZ2h0XFxcIixqdXN0aWZ5OlxcXCJBbGlnbiBKdXN0aWZ5XFxcIn0saHRtbDpmdW5jdGlvbigpe3ZhciBiPSc8dWwgY2xhc3M9XFxcImZyLWRyb3Bkb3duLWxpc3RcXFwiIHJvbGU9XFxcInByZXNlbnRhdGlvblxcXCI+JyxjPWEuRkUuQ09NTUFORFMuYWxpZ24ub3B0aW9ucztmb3IodmFyIGQgaW4gYyljLmhhc093blByb3BlcnR5KGQpJiYoYis9JzxsaSByb2xlPVxcXCJwcmVzZW50YXRpb25cXFwiPjxhIGNsYXNzPVxcXCJmci1jb21tYW5kIGZyLXRpdGxlXFxcIiB0YWJJbmRleD1cXFwiLTFcXFwiIHJvbGU9XFxcIm9wdGlvblxcXCIgZGF0YS1jbWQ9XFxcImFsaWduXFxcIiBkYXRhLXBhcmFtMT1cXFwiJytkKydcXFwiIHRpdGxlPVxcXCInK3RoaXMubGFuZ3VhZ2UudHJhbnNsYXRlKGNbZF0pKydcXFwiPicrdGhpcy5pY29uLmNyZWF0ZShcXFwiYWxpZ24tXFxcIitkKSsnPHNwYW4gY2xhc3M9XFxcImZyLXNyLW9ubHlcXFwiPicrdGhpcy5sYW5ndWFnZS50cmFuc2xhdGUoY1tkXSkrXFxcIjwvc3Bhbj48L2E+PC9saT5cXFwiKTtyZXR1cm4gYis9XFxcIjwvdWw+XFxcIn0sY2FsbGJhY2s6ZnVuY3Rpb24oYSxiKXt0aGlzLmFsaWduLmFwcGx5KGIpfSxyZWZyZXNoOmZ1bmN0aW9uKGEpe3RoaXMuYWxpZ24ucmVmcmVzaChhKX0scmVmcmVzaE9uU2hvdzpmdW5jdGlvbihhLGIpe3RoaXMuYWxpZ24ucmVmcmVzaE9uU2hvdyhhLGIpfSxwbHVnaW46XFxcImFsaWduXFxcIn0pfSk7XCJcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcmF3LWxvYWRlciEuL34vZnJvYWxhLWVkaXRvci9qcy9wbHVnaW5zL2FsaWduLm1pbi5qc1xuLy8gbW9kdWxlIGlkID0gOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	eval("__webpack_require__(2)(__webpack_require__(11))//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTAuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2Zyb2FsYS1lZGl0b3IvanMvcGx1Z2lucy9jaGFyX2NvdW50ZXIubWluLmpzPzc3YjEiXSwic291cmNlc0NvbnRlbnQiOlsicmVxdWlyZShcIiEhL1VzZXJzL2pha3ViZmFqa3VzL0RvY3VtZW50cy9wcmFjZS92ZW5pY2UtZGVtby93ZWIvanMvbm9kZV9tb2R1bGVzL3NjcmlwdC1sb2FkZXIvYWRkU2NyaXB0LmpzXCIpKHJlcXVpcmUoXCIhIS9Vc2Vycy9qYWt1YmZhamt1cy9Eb2N1bWVudHMvcHJhY2UvdmVuaWNlLWRlbW8vd2ViL2pzL25vZGVfbW9kdWxlcy9yYXctbG9hZGVyL2luZGV4LmpzIS9Vc2Vycy9qYWt1YmZhamt1cy9Eb2N1bWVudHMvcHJhY2UvdmVuaWNlLWRlbW8vd2ViL2pzL25vZGVfbW9kdWxlcy9mcm9hbGEtZWRpdG9yL2pzL3BsdWdpbnMvY2hhcl9jb3VudGVyLm1pbi5qc1wiKSlcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vc2NyaXB0LWxvYWRlciEuL34vZnJvYWxhLWVkaXRvci9qcy9wbHVnaW5zL2NoYXJfY291bnRlci5taW4uanNcbi8vIG1vZHVsZSBpZCA9IDEwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 11 */
/***/ function(module, exports) {

	eval("module.exports = \"/*!\\n * froala_editor v2.5.0 (https://www.froala.com/wysiwyg-editor)\\n * License https://froala.com/wysiwyg-editor/terms/\\n * Copyright 2014-2017 Froala Labs\\n */\\n\\n!function(a){\\\"function\\\"==typeof define&&define.amd?define([\\\"jquery\\\"],a):\\\"object\\\"==typeof module&&module.exports?module.exports=function(b,c){return void 0===c&&(c=\\\"undefined\\\"!=typeof window?require(\\\"jquery\\\"):require(\\\"jquery\\\")(b)),a(c)}:a(window.jQuery)}(function(a){a.extend(a.FE.DEFAULTS,{charCounterMax:-1,charCounterCount:!0}),a.FE.PLUGINS.charCounter=function(b){function c(){return b.el.textContent.length}function d(a){if(b.opts.charCounterMax<0)return!0;if(c()<b.opts.charCounterMax)return!0;var d=a.which;return!(!b.keys.ctrlKey(a)&&b.keys.isCharacter(d))||(a.preventDefault(),a.stopPropagation(),b.events.trigger(\\\"charCounter.exceeded\\\"),!1)}function e(d){if(b.opts.charCounterMax<0)return d;var e=a(\\\"<div>\\\").html(d).text().length;return e+c()<=b.opts.charCounterMax?d:(b.events.trigger(\\\"charCounter.exceeded\\\"),\\\"\\\")}function f(){if(b.opts.charCounterCount){var a=c()+(b.opts.charCounterMax>0?\\\"/\\\"+b.opts.charCounterMax:\\\"\\\");h.text(a),b.opts.toolbarBottom&&h.css(\\\"margin-bottom\\\",b.$tb.outerHeight(!0));var d=b.$wp.get(0).offsetWidth-b.$wp.get(0).clientWidth;d>=0&&(\\\"rtl\\\"==b.opts.direction?h.css(\\\"margin-left\\\",d):h.css(\\\"margin-right\\\",d))}}function g(){return!!b.$wp&&(!!b.opts.charCounterCount&&(h=a('<span class=\\\"fr-counter\\\"></span>'),h.css(\\\"bottom\\\",b.$wp.css(\\\"border-bottom-width\\\")),b.$box.append(h),b.events.on(\\\"keydown\\\",d,!0),b.events.on(\\\"paste.afterCleanup\\\",e),b.events.on(\\\"keyup contentChanged input\\\",function(){b.events.trigger(\\\"charCounter.update\\\")}),b.events.on(\\\"charCounter.update\\\",f),b.events.trigger(\\\"charCounter.update\\\"),void b.events.on(\\\"destroy\\\",function(){a(b.o_win).off(\\\"resize.char\\\"+b.id),h.removeData().remove(),h=null})))}var h;return{_init:g,count:c}}});\"//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTEuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2Zyb2FsYS1lZGl0b3IvanMvcGx1Z2lucy9jaGFyX2NvdW50ZXIubWluLmpzPzUwMWQiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBcIi8qIVxcbiAqIGZyb2FsYV9lZGl0b3IgdjIuNS4wIChodHRwczovL3d3dy5mcm9hbGEuY29tL3d5c2l3eWctZWRpdG9yKVxcbiAqIExpY2Vuc2UgaHR0cHM6Ly9mcm9hbGEuY29tL3d5c2l3eWctZWRpdG9yL3Rlcm1zL1xcbiAqIENvcHlyaWdodCAyMDE0LTIwMTcgRnJvYWxhIExhYnNcXG4gKi9cXG5cXG4hZnVuY3Rpb24oYSl7XFxcImZ1bmN0aW9uXFxcIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUoW1xcXCJqcXVlcnlcXFwiXSxhKTpcXFwib2JqZWN0XFxcIj09dHlwZW9mIG1vZHVsZSYmbW9kdWxlLmV4cG9ydHM/bW9kdWxlLmV4cG9ydHM9ZnVuY3Rpb24oYixjKXtyZXR1cm4gdm9pZCAwPT09YyYmKGM9XFxcInVuZGVmaW5lZFxcXCIhPXR5cGVvZiB3aW5kb3c/cmVxdWlyZShcXFwianF1ZXJ5XFxcIik6cmVxdWlyZShcXFwianF1ZXJ5XFxcIikoYikpLGEoYyl9OmEod2luZG93LmpRdWVyeSl9KGZ1bmN0aW9uKGEpe2EuZXh0ZW5kKGEuRkUuREVGQVVMVFMse2NoYXJDb3VudGVyTWF4Oi0xLGNoYXJDb3VudGVyQ291bnQ6ITB9KSxhLkZFLlBMVUdJTlMuY2hhckNvdW50ZXI9ZnVuY3Rpb24oYil7ZnVuY3Rpb24gYygpe3JldHVybiBiLmVsLnRleHRDb250ZW50Lmxlbmd0aH1mdW5jdGlvbiBkKGEpe2lmKGIub3B0cy5jaGFyQ291bnRlck1heDwwKXJldHVybiEwO2lmKGMoKTxiLm9wdHMuY2hhckNvdW50ZXJNYXgpcmV0dXJuITA7dmFyIGQ9YS53aGljaDtyZXR1cm4hKCFiLmtleXMuY3RybEtleShhKSYmYi5rZXlzLmlzQ2hhcmFjdGVyKGQpKXx8KGEucHJldmVudERlZmF1bHQoKSxhLnN0b3BQcm9wYWdhdGlvbigpLGIuZXZlbnRzLnRyaWdnZXIoXFxcImNoYXJDb3VudGVyLmV4Y2VlZGVkXFxcIiksITEpfWZ1bmN0aW9uIGUoZCl7aWYoYi5vcHRzLmNoYXJDb3VudGVyTWF4PDApcmV0dXJuIGQ7dmFyIGU9YShcXFwiPGRpdj5cXFwiKS5odG1sKGQpLnRleHQoKS5sZW5ndGg7cmV0dXJuIGUrYygpPD1iLm9wdHMuY2hhckNvdW50ZXJNYXg/ZDooYi5ldmVudHMudHJpZ2dlcihcXFwiY2hhckNvdW50ZXIuZXhjZWVkZWRcXFwiKSxcXFwiXFxcIil9ZnVuY3Rpb24gZigpe2lmKGIub3B0cy5jaGFyQ291bnRlckNvdW50KXt2YXIgYT1jKCkrKGIub3B0cy5jaGFyQ291bnRlck1heD4wP1xcXCIvXFxcIitiLm9wdHMuY2hhckNvdW50ZXJNYXg6XFxcIlxcXCIpO2gudGV4dChhKSxiLm9wdHMudG9vbGJhckJvdHRvbSYmaC5jc3MoXFxcIm1hcmdpbi1ib3R0b21cXFwiLGIuJHRiLm91dGVySGVpZ2h0KCEwKSk7dmFyIGQ9Yi4kd3AuZ2V0KDApLm9mZnNldFdpZHRoLWIuJHdwLmdldCgwKS5jbGllbnRXaWR0aDtkPj0wJiYoXFxcInJ0bFxcXCI9PWIub3B0cy5kaXJlY3Rpb24/aC5jc3MoXFxcIm1hcmdpbi1sZWZ0XFxcIixkKTpoLmNzcyhcXFwibWFyZ2luLXJpZ2h0XFxcIixkKSl9fWZ1bmN0aW9uIGcoKXtyZXR1cm4hIWIuJHdwJiYoISFiLm9wdHMuY2hhckNvdW50ZXJDb3VudCYmKGg9YSgnPHNwYW4gY2xhc3M9XFxcImZyLWNvdW50ZXJcXFwiPjwvc3Bhbj4nKSxoLmNzcyhcXFwiYm90dG9tXFxcIixiLiR3cC5jc3MoXFxcImJvcmRlci1ib3R0b20td2lkdGhcXFwiKSksYi4kYm94LmFwcGVuZChoKSxiLmV2ZW50cy5vbihcXFwia2V5ZG93blxcXCIsZCwhMCksYi5ldmVudHMub24oXFxcInBhc3RlLmFmdGVyQ2xlYW51cFxcXCIsZSksYi5ldmVudHMub24oXFxcImtleXVwIGNvbnRlbnRDaGFuZ2VkIGlucHV0XFxcIixmdW5jdGlvbigpe2IuZXZlbnRzLnRyaWdnZXIoXFxcImNoYXJDb3VudGVyLnVwZGF0ZVxcXCIpfSksYi5ldmVudHMub24oXFxcImNoYXJDb3VudGVyLnVwZGF0ZVxcXCIsZiksYi5ldmVudHMudHJpZ2dlcihcXFwiY2hhckNvdW50ZXIudXBkYXRlXFxcIiksdm9pZCBiLmV2ZW50cy5vbihcXFwiZGVzdHJveVxcXCIsZnVuY3Rpb24oKXthKGIub193aW4pLm9mZihcXFwicmVzaXplLmNoYXJcXFwiK2IuaWQpLGgucmVtb3ZlRGF0YSgpLnJlbW92ZSgpLGg9bnVsbH0pKSl9dmFyIGg7cmV0dXJue19pbml0OmcsY291bnQ6Y319fSk7XCJcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcmF3LWxvYWRlciEuL34vZnJvYWxhLWVkaXRvci9qcy9wbHVnaW5zL2NoYXJfY291bnRlci5taW4uanNcbi8vIG1vZHVsZSBpZCA9IDExXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	eval("__webpack_require__(2)(__webpack_require__(13))//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTIuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2Zyb2FsYS1lZGl0b3IvanMvcGx1Z2lucy9jb2RlX3ZpZXcubWluLmpzPzljNWIiXSwic291cmNlc0NvbnRlbnQiOlsicmVxdWlyZShcIiEhL1VzZXJzL2pha3ViZmFqa3VzL0RvY3VtZW50cy9wcmFjZS92ZW5pY2UtZGVtby93ZWIvanMvbm9kZV9tb2R1bGVzL3NjcmlwdC1sb2FkZXIvYWRkU2NyaXB0LmpzXCIpKHJlcXVpcmUoXCIhIS9Vc2Vycy9qYWt1YmZhamt1cy9Eb2N1bWVudHMvcHJhY2UvdmVuaWNlLWRlbW8vd2ViL2pzL25vZGVfbW9kdWxlcy9yYXctbG9hZGVyL2luZGV4LmpzIS9Vc2Vycy9qYWt1YmZhamt1cy9Eb2N1bWVudHMvcHJhY2UvdmVuaWNlLWRlbW8vd2ViL2pzL25vZGVfbW9kdWxlcy9mcm9hbGEtZWRpdG9yL2pzL3BsdWdpbnMvY29kZV92aWV3Lm1pbi5qc1wiKSlcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vc2NyaXB0LWxvYWRlciEuL34vZnJvYWxhLWVkaXRvci9qcy9wbHVnaW5zL2NvZGVfdmlldy5taW4uanNcbi8vIG1vZHVsZSBpZCA9IDEyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 13 */
/***/ function(module, exports) {

	eval("module.exports = \"/*!\\n * froala_editor v2.5.0 (https://www.froala.com/wysiwyg-editor)\\n * License https://froala.com/wysiwyg-editor/terms/\\n * Copyright 2014-2017 Froala Labs\\n */\\n\\n!function(a){\\\"function\\\"==typeof define&&define.amd?define([\\\"jquery\\\"],a):\\\"object\\\"==typeof module&&module.exports?module.exports=function(b,c){return void 0===c&&(c=\\\"undefined\\\"!=typeof window?require(\\\"jquery\\\"):require(\\\"jquery\\\")(b)),a(c)}:a(window.jQuery)}(function(a){a.extend(a.FE.DEFAULTS,{codeMirror:!0,codeMirrorOptions:{lineNumbers:!0,tabMode:\\\"indent\\\",indentWithTabs:!0,lineWrapping:!0,mode:\\\"text/html\\\",tabSize:2},codeBeautifierOptions:{end_with_newline:!0,indent_inner_html:!0,extra_liners:[\\\"p\\\",\\\"h1\\\",\\\"h2\\\",\\\"h3\\\",\\\"h4\\\",\\\"h5\\\",\\\"h6\\\",\\\"blockquote\\\",\\\"pre\\\",\\\"ul\\\",\\\"ol\\\",\\\"table\\\",\\\"dl\\\"],brace_style:\\\"expand\\\",indent_char:\\\"\\\\t\\\",indent_size:1,wrap_line_length:0},codeViewKeepActiveButtons:[\\\"fullscreen\\\"]}),a.FE.PLUGINS.codeView=function(b){function c(){return b.$box.hasClass(\\\"fr-code-view\\\")}function d(){return l?l.getValue():k.val()}function e(a){var c=d();b.html.set(c),b.$el.blur(),b.$tb.find(\\\" > .fr-command\\\").not(a).removeClass(\\\"fr-disabled\\\").attr(\\\"aria-disabled\\\",!1),a.removeClass(\\\"fr-active\\\").attr(\\\"aria-pressed\\\",!1),b.events.focus(!0),b.placeholder.refresh(),b.undo.saveStep()}function f(c){k||(i(),!l&&b.opts.codeMirror&&\\\"undefined\\\"!=typeof CodeMirror?l=CodeMirror.fromTextArea(k.get(0),b.opts.codeMirrorOptions):b.events.$on(k,\\\"keydown keyup change input\\\",function(){if(b.opts.height)this.removeAttribute(\\\"rows\\\");else if(this.rows||(this.rows=1),0===this.value.length)this.rows=1;else{for(this.style.height=\\\"auto\\\";this.rows>1&&this.scrollHeight<=this.offsetHeight;)this.rows-=1;for(;this.scrollHeight>this.offsetHeight&&(!b.opts.heightMax||this.offsetHeight<b.opts.heightMax);)this.rows+=1}})),b.undo.saveStep(),b.html.cleanEmptyTags(),b.html.cleanWhiteTags(!0),b.core.hasFocus()&&(b.core.isEmpty()||(b.selection.save(),b.$el.find('.fr-marker[data-type=\\\"true\\\"]:first').replaceWith('<span class=\\\"fr-tmp fr-sm\\\">F</span>'),b.$el.find('.fr-marker[data-type=\\\"false\\\"]:last').replaceWith('<span class=\\\"fr-tmp fr-em\\\">F</span>')));var d=b.html.get(!1,!0);b.$el.find(\\\"span.fr-tmp\\\").remove(),b.$box.toggleClass(\\\"fr-code-view\\\",!0),b.core.hasFocus()&&b.$el.blur(),d=d.replace(/<span class=\\\"fr-tmp fr-sm\\\">F<\\\\/span>/,\\\"FROALA-SM\\\"),d=d.replace(/<span class=\\\"fr-tmp fr-em\\\">F<\\\\/span>/,\\\"FROALA-EM\\\"),b.codeBeautifier&&(d=b.codeBeautifier.run(d,b.opts.codeBeautifierOptions));var e,f;if(l){e=d.indexOf(\\\"FROALA-SM\\\"),f=d.indexOf(\\\"FROALA-EM\\\"),e>f?e=f:f-=9,d=d.replace(/FROALA-SM/g,\\\"\\\").replace(/FROALA-EM/g,\\\"\\\");var g=d.substring(0,e).length-d.substring(0,e).replace(/\\\\n/g,\\\"\\\").length,h=d.substring(0,f).length-d.substring(0,f).replace(/\\\\n/g,\\\"\\\").length;e=d.substring(0,e).length-d.substring(0,d.substring(0,e).lastIndexOf(\\\"\\\\n\\\")+1).length,f=d.substring(0,f).length-d.substring(0,d.substring(0,f).lastIndexOf(\\\"\\\\n\\\")+1).length,l.setSize(null,b.opts.height?b.opts.height:\\\"auto\\\"),b.opts.heightMin&&b.$box.find(\\\".CodeMirror-scroll\\\").css(\\\"min-height\\\",b.opts.heightMin),l.setValue(d),l.focus(),l.setSelection({line:g,ch:e},{line:h,ch:f}),l.refresh(),l.clearHistory()}else{e=d.indexOf(\\\"FROALA-SM\\\"),f=d.indexOf(\\\"FROALA-EM\\\")-9,b.opts.heightMin&&k.css(\\\"min-height\\\",b.opts.heightMin),b.opts.height&&k.css(\\\"height\\\",b.opts.height),b.opts.heightMax&&k.css(\\\"max-height\\\",b.opts.height||b.opts.heightMax),k.val(d.replace(/FROALA-SM/g,\\\"\\\").replace(/FROALA-EM/g,\\\"\\\")).trigger(\\\"change\\\");var j=a(b.o_doc).scrollTop();k.focus(),k.get(0).setSelectionRange(e,f),a(b.o_doc).scrollTop(j)}b.$tb.find(\\\" > .fr-command\\\").not(c).filter(function(){return b.opts.codeViewKeepActiveButtons.indexOf(a(this).data(\\\"cmd\\\"))<0}).addClass(\\\"fr-disabled\\\").attr(\\\"aria-disabled\\\",!0),c.addClass(\\\"fr-active\\\").attr(\\\"aria-pressed\\\",!0),!b.helpers.isMobile()&&b.opts.toolbarInline&&b.toolbar.hide()}function g(a){\\\"undefined\\\"==typeof a&&(a=!c());var d=b.$tb.find('.fr-command[data-cmd=\\\"html\\\"]');a?(b.popups.hideAll(),f(d)):(b.$box.toggleClass(\\\"fr-code-view\\\",!1),e(d))}function h(){c()&&g(b.$tb.find('button[data-cmd=\\\"html\\\"]')),l&&l.toTextArea(),k.val(\\\"\\\").removeData().remove(),k=null,m&&(m.remove(),m=null)}function i(){k=a('<textarea class=\\\"fr-code\\\" tabIndex=\\\"-1\\\">'),b.$wp.append(k),k.attr(\\\"dir\\\",b.opts.direction),b.$box.hasClass(\\\"fr-basic\\\")||(m=a('<a data-cmd=\\\"html\\\" title=\\\"Code View\\\" class=\\\"fr-command fr-btn html-switch'+(b.helpers.isMobile()?\\\"\\\":\\\" fr-desktop\\\")+'\\\" role=\\\"button\\\" tabIndex=\\\"-1\\\"><i class=\\\"fa fa-code\\\"></i></button>'),b.$box.append(m),b.events.bindClick(b.$box,\\\"a.html-switch\\\",function(){g(!1)}));var e=function(){return!c()};b.events.on(\\\"buttons.refresh\\\",e),b.events.on(\\\"copy\\\",e,!0),b.events.on(\\\"cut\\\",e,!0),b.events.on(\\\"paste\\\",e,!0),b.events.on(\\\"destroy\\\",h,!0),b.events.on(\\\"html.set\\\",function(){c()&&g(!0)}),b.events.on(\\\"form.submit\\\",function(){c()&&(b.html.set(d()),b.events.trigger(\\\"contentChanged\\\",[],!0))},!0)}function j(){if(!b.$wp)return!1}var k,l,m;return{_init:j,toggle:g,isActive:c,get:d}},a.FE.RegisterCommand(\\\"html\\\",{title:\\\"Code View\\\",undo:!1,focus:!1,forcedRefresh:!0,toggle:!0,callback:function(){this.codeView.toggle()},plugin:\\\"codeView\\\"}),a.FE.DefineIcon(\\\"html\\\",{NAME:\\\"code\\\"})});\"//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2Zyb2FsYS1lZGl0b3IvanMvcGx1Z2lucy9jb2RlX3ZpZXcubWluLmpzPzg0ZjMiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBcIi8qIVxcbiAqIGZyb2FsYV9lZGl0b3IgdjIuNS4wIChodHRwczovL3d3dy5mcm9hbGEuY29tL3d5c2l3eWctZWRpdG9yKVxcbiAqIExpY2Vuc2UgaHR0cHM6Ly9mcm9hbGEuY29tL3d5c2l3eWctZWRpdG9yL3Rlcm1zL1xcbiAqIENvcHlyaWdodCAyMDE0LTIwMTcgRnJvYWxhIExhYnNcXG4gKi9cXG5cXG4hZnVuY3Rpb24oYSl7XFxcImZ1bmN0aW9uXFxcIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUoW1xcXCJqcXVlcnlcXFwiXSxhKTpcXFwib2JqZWN0XFxcIj09dHlwZW9mIG1vZHVsZSYmbW9kdWxlLmV4cG9ydHM/bW9kdWxlLmV4cG9ydHM9ZnVuY3Rpb24oYixjKXtyZXR1cm4gdm9pZCAwPT09YyYmKGM9XFxcInVuZGVmaW5lZFxcXCIhPXR5cGVvZiB3aW5kb3c/cmVxdWlyZShcXFwianF1ZXJ5XFxcIik6cmVxdWlyZShcXFwianF1ZXJ5XFxcIikoYikpLGEoYyl9OmEod2luZG93LmpRdWVyeSl9KGZ1bmN0aW9uKGEpe2EuZXh0ZW5kKGEuRkUuREVGQVVMVFMse2NvZGVNaXJyb3I6ITAsY29kZU1pcnJvck9wdGlvbnM6e2xpbmVOdW1iZXJzOiEwLHRhYk1vZGU6XFxcImluZGVudFxcXCIsaW5kZW50V2l0aFRhYnM6ITAsbGluZVdyYXBwaW5nOiEwLG1vZGU6XFxcInRleHQvaHRtbFxcXCIsdGFiU2l6ZToyfSxjb2RlQmVhdXRpZmllck9wdGlvbnM6e2VuZF93aXRoX25ld2xpbmU6ITAsaW5kZW50X2lubmVyX2h0bWw6ITAsZXh0cmFfbGluZXJzOltcXFwicFxcXCIsXFxcImgxXFxcIixcXFwiaDJcXFwiLFxcXCJoM1xcXCIsXFxcImg0XFxcIixcXFwiaDVcXFwiLFxcXCJoNlxcXCIsXFxcImJsb2NrcXVvdGVcXFwiLFxcXCJwcmVcXFwiLFxcXCJ1bFxcXCIsXFxcIm9sXFxcIixcXFwidGFibGVcXFwiLFxcXCJkbFxcXCJdLGJyYWNlX3N0eWxlOlxcXCJleHBhbmRcXFwiLGluZGVudF9jaGFyOlxcXCJcXFxcdFxcXCIsaW5kZW50X3NpemU6MSx3cmFwX2xpbmVfbGVuZ3RoOjB9LGNvZGVWaWV3S2VlcEFjdGl2ZUJ1dHRvbnM6W1xcXCJmdWxsc2NyZWVuXFxcIl19KSxhLkZFLlBMVUdJTlMuY29kZVZpZXc9ZnVuY3Rpb24oYil7ZnVuY3Rpb24gYygpe3JldHVybiBiLiRib3guaGFzQ2xhc3MoXFxcImZyLWNvZGUtdmlld1xcXCIpfWZ1bmN0aW9uIGQoKXtyZXR1cm4gbD9sLmdldFZhbHVlKCk6ay52YWwoKX1mdW5jdGlvbiBlKGEpe3ZhciBjPWQoKTtiLmh0bWwuc2V0KGMpLGIuJGVsLmJsdXIoKSxiLiR0Yi5maW5kKFxcXCIgPiAuZnItY29tbWFuZFxcXCIpLm5vdChhKS5yZW1vdmVDbGFzcyhcXFwiZnItZGlzYWJsZWRcXFwiKS5hdHRyKFxcXCJhcmlhLWRpc2FibGVkXFxcIiwhMSksYS5yZW1vdmVDbGFzcyhcXFwiZnItYWN0aXZlXFxcIikuYXR0cihcXFwiYXJpYS1wcmVzc2VkXFxcIiwhMSksYi5ldmVudHMuZm9jdXMoITApLGIucGxhY2Vob2xkZXIucmVmcmVzaCgpLGIudW5kby5zYXZlU3RlcCgpfWZ1bmN0aW9uIGYoYyl7a3x8KGkoKSwhbCYmYi5vcHRzLmNvZGVNaXJyb3ImJlxcXCJ1bmRlZmluZWRcXFwiIT10eXBlb2YgQ29kZU1pcnJvcj9sPUNvZGVNaXJyb3IuZnJvbVRleHRBcmVhKGsuZ2V0KDApLGIub3B0cy5jb2RlTWlycm9yT3B0aW9ucyk6Yi5ldmVudHMuJG9uKGssXFxcImtleWRvd24ga2V5dXAgY2hhbmdlIGlucHV0XFxcIixmdW5jdGlvbigpe2lmKGIub3B0cy5oZWlnaHQpdGhpcy5yZW1vdmVBdHRyaWJ1dGUoXFxcInJvd3NcXFwiKTtlbHNlIGlmKHRoaXMucm93c3x8KHRoaXMucm93cz0xKSwwPT09dGhpcy52YWx1ZS5sZW5ndGgpdGhpcy5yb3dzPTE7ZWxzZXtmb3IodGhpcy5zdHlsZS5oZWlnaHQ9XFxcImF1dG9cXFwiO3RoaXMucm93cz4xJiZ0aGlzLnNjcm9sbEhlaWdodDw9dGhpcy5vZmZzZXRIZWlnaHQ7KXRoaXMucm93cy09MTtmb3IoO3RoaXMuc2Nyb2xsSGVpZ2h0PnRoaXMub2Zmc2V0SGVpZ2h0JiYoIWIub3B0cy5oZWlnaHRNYXh8fHRoaXMub2Zmc2V0SGVpZ2h0PGIub3B0cy5oZWlnaHRNYXgpOyl0aGlzLnJvd3MrPTF9fSkpLGIudW5kby5zYXZlU3RlcCgpLGIuaHRtbC5jbGVhbkVtcHR5VGFncygpLGIuaHRtbC5jbGVhbldoaXRlVGFncyghMCksYi5jb3JlLmhhc0ZvY3VzKCkmJihiLmNvcmUuaXNFbXB0eSgpfHwoYi5zZWxlY3Rpb24uc2F2ZSgpLGIuJGVsLmZpbmQoJy5mci1tYXJrZXJbZGF0YS10eXBlPVxcXCJ0cnVlXFxcIl06Zmlyc3QnKS5yZXBsYWNlV2l0aCgnPHNwYW4gY2xhc3M9XFxcImZyLXRtcCBmci1zbVxcXCI+Rjwvc3Bhbj4nKSxiLiRlbC5maW5kKCcuZnItbWFya2VyW2RhdGEtdHlwZT1cXFwiZmFsc2VcXFwiXTpsYXN0JykucmVwbGFjZVdpdGgoJzxzcGFuIGNsYXNzPVxcXCJmci10bXAgZnItZW1cXFwiPkY8L3NwYW4+JykpKTt2YXIgZD1iLmh0bWwuZ2V0KCExLCEwKTtiLiRlbC5maW5kKFxcXCJzcGFuLmZyLXRtcFxcXCIpLnJlbW92ZSgpLGIuJGJveC50b2dnbGVDbGFzcyhcXFwiZnItY29kZS12aWV3XFxcIiwhMCksYi5jb3JlLmhhc0ZvY3VzKCkmJmIuJGVsLmJsdXIoKSxkPWQucmVwbGFjZSgvPHNwYW4gY2xhc3M9XFxcImZyLXRtcCBmci1zbVxcXCI+RjxcXFxcL3NwYW4+LyxcXFwiRlJPQUxBLVNNXFxcIiksZD1kLnJlcGxhY2UoLzxzcGFuIGNsYXNzPVxcXCJmci10bXAgZnItZW1cXFwiPkY8XFxcXC9zcGFuPi8sXFxcIkZST0FMQS1FTVxcXCIpLGIuY29kZUJlYXV0aWZpZXImJihkPWIuY29kZUJlYXV0aWZpZXIucnVuKGQsYi5vcHRzLmNvZGVCZWF1dGlmaWVyT3B0aW9ucykpO3ZhciBlLGY7aWYobCl7ZT1kLmluZGV4T2YoXFxcIkZST0FMQS1TTVxcXCIpLGY9ZC5pbmRleE9mKFxcXCJGUk9BTEEtRU1cXFwiKSxlPmY/ZT1mOmYtPTksZD1kLnJlcGxhY2UoL0ZST0FMQS1TTS9nLFxcXCJcXFwiKS5yZXBsYWNlKC9GUk9BTEEtRU0vZyxcXFwiXFxcIik7dmFyIGc9ZC5zdWJzdHJpbmcoMCxlKS5sZW5ndGgtZC5zdWJzdHJpbmcoMCxlKS5yZXBsYWNlKC9cXFxcbi9nLFxcXCJcXFwiKS5sZW5ndGgsaD1kLnN1YnN0cmluZygwLGYpLmxlbmd0aC1kLnN1YnN0cmluZygwLGYpLnJlcGxhY2UoL1xcXFxuL2csXFxcIlxcXCIpLmxlbmd0aDtlPWQuc3Vic3RyaW5nKDAsZSkubGVuZ3RoLWQuc3Vic3RyaW5nKDAsZC5zdWJzdHJpbmcoMCxlKS5sYXN0SW5kZXhPZihcXFwiXFxcXG5cXFwiKSsxKS5sZW5ndGgsZj1kLnN1YnN0cmluZygwLGYpLmxlbmd0aC1kLnN1YnN0cmluZygwLGQuc3Vic3RyaW5nKDAsZikubGFzdEluZGV4T2YoXFxcIlxcXFxuXFxcIikrMSkubGVuZ3RoLGwuc2V0U2l6ZShudWxsLGIub3B0cy5oZWlnaHQ/Yi5vcHRzLmhlaWdodDpcXFwiYXV0b1xcXCIpLGIub3B0cy5oZWlnaHRNaW4mJmIuJGJveC5maW5kKFxcXCIuQ29kZU1pcnJvci1zY3JvbGxcXFwiKS5jc3MoXFxcIm1pbi1oZWlnaHRcXFwiLGIub3B0cy5oZWlnaHRNaW4pLGwuc2V0VmFsdWUoZCksbC5mb2N1cygpLGwuc2V0U2VsZWN0aW9uKHtsaW5lOmcsY2g6ZX0se2xpbmU6aCxjaDpmfSksbC5yZWZyZXNoKCksbC5jbGVhckhpc3RvcnkoKX1lbHNle2U9ZC5pbmRleE9mKFxcXCJGUk9BTEEtU01cXFwiKSxmPWQuaW5kZXhPZihcXFwiRlJPQUxBLUVNXFxcIiktOSxiLm9wdHMuaGVpZ2h0TWluJiZrLmNzcyhcXFwibWluLWhlaWdodFxcXCIsYi5vcHRzLmhlaWdodE1pbiksYi5vcHRzLmhlaWdodCYmay5jc3MoXFxcImhlaWdodFxcXCIsYi5vcHRzLmhlaWdodCksYi5vcHRzLmhlaWdodE1heCYmay5jc3MoXFxcIm1heC1oZWlnaHRcXFwiLGIub3B0cy5oZWlnaHR8fGIub3B0cy5oZWlnaHRNYXgpLGsudmFsKGQucmVwbGFjZSgvRlJPQUxBLVNNL2csXFxcIlxcXCIpLnJlcGxhY2UoL0ZST0FMQS1FTS9nLFxcXCJcXFwiKSkudHJpZ2dlcihcXFwiY2hhbmdlXFxcIik7dmFyIGo9YShiLm9fZG9jKS5zY3JvbGxUb3AoKTtrLmZvY3VzKCksay5nZXQoMCkuc2V0U2VsZWN0aW9uUmFuZ2UoZSxmKSxhKGIub19kb2MpLnNjcm9sbFRvcChqKX1iLiR0Yi5maW5kKFxcXCIgPiAuZnItY29tbWFuZFxcXCIpLm5vdChjKS5maWx0ZXIoZnVuY3Rpb24oKXtyZXR1cm4gYi5vcHRzLmNvZGVWaWV3S2VlcEFjdGl2ZUJ1dHRvbnMuaW5kZXhPZihhKHRoaXMpLmRhdGEoXFxcImNtZFxcXCIpKTwwfSkuYWRkQ2xhc3MoXFxcImZyLWRpc2FibGVkXFxcIikuYXR0cihcXFwiYXJpYS1kaXNhYmxlZFxcXCIsITApLGMuYWRkQ2xhc3MoXFxcImZyLWFjdGl2ZVxcXCIpLmF0dHIoXFxcImFyaWEtcHJlc3NlZFxcXCIsITApLCFiLmhlbHBlcnMuaXNNb2JpbGUoKSYmYi5vcHRzLnRvb2xiYXJJbmxpbmUmJmIudG9vbGJhci5oaWRlKCl9ZnVuY3Rpb24gZyhhKXtcXFwidW5kZWZpbmVkXFxcIj09dHlwZW9mIGEmJihhPSFjKCkpO3ZhciBkPWIuJHRiLmZpbmQoJy5mci1jb21tYW5kW2RhdGEtY21kPVxcXCJodG1sXFxcIl0nKTthPyhiLnBvcHVwcy5oaWRlQWxsKCksZihkKSk6KGIuJGJveC50b2dnbGVDbGFzcyhcXFwiZnItY29kZS12aWV3XFxcIiwhMSksZShkKSl9ZnVuY3Rpb24gaCgpe2MoKSYmZyhiLiR0Yi5maW5kKCdidXR0b25bZGF0YS1jbWQ9XFxcImh0bWxcXFwiXScpKSxsJiZsLnRvVGV4dEFyZWEoKSxrLnZhbChcXFwiXFxcIikucmVtb3ZlRGF0YSgpLnJlbW92ZSgpLGs9bnVsbCxtJiYobS5yZW1vdmUoKSxtPW51bGwpfWZ1bmN0aW9uIGkoKXtrPWEoJzx0ZXh0YXJlYSBjbGFzcz1cXFwiZnItY29kZVxcXCIgdGFiSW5kZXg9XFxcIi0xXFxcIj4nKSxiLiR3cC5hcHBlbmQoayksay5hdHRyKFxcXCJkaXJcXFwiLGIub3B0cy5kaXJlY3Rpb24pLGIuJGJveC5oYXNDbGFzcyhcXFwiZnItYmFzaWNcXFwiKXx8KG09YSgnPGEgZGF0YS1jbWQ9XFxcImh0bWxcXFwiIHRpdGxlPVxcXCJDb2RlIFZpZXdcXFwiIGNsYXNzPVxcXCJmci1jb21tYW5kIGZyLWJ0biBodG1sLXN3aXRjaCcrKGIuaGVscGVycy5pc01vYmlsZSgpP1xcXCJcXFwiOlxcXCIgZnItZGVza3RvcFxcXCIpKydcXFwiIHJvbGU9XFxcImJ1dHRvblxcXCIgdGFiSW5kZXg9XFxcIi0xXFxcIj48aSBjbGFzcz1cXFwiZmEgZmEtY29kZVxcXCI+PC9pPjwvYnV0dG9uPicpLGIuJGJveC5hcHBlbmQobSksYi5ldmVudHMuYmluZENsaWNrKGIuJGJveCxcXFwiYS5odG1sLXN3aXRjaFxcXCIsZnVuY3Rpb24oKXtnKCExKX0pKTt2YXIgZT1mdW5jdGlvbigpe3JldHVybiFjKCl9O2IuZXZlbnRzLm9uKFxcXCJidXR0b25zLnJlZnJlc2hcXFwiLGUpLGIuZXZlbnRzLm9uKFxcXCJjb3B5XFxcIixlLCEwKSxiLmV2ZW50cy5vbihcXFwiY3V0XFxcIixlLCEwKSxiLmV2ZW50cy5vbihcXFwicGFzdGVcXFwiLGUsITApLGIuZXZlbnRzLm9uKFxcXCJkZXN0cm95XFxcIixoLCEwKSxiLmV2ZW50cy5vbihcXFwiaHRtbC5zZXRcXFwiLGZ1bmN0aW9uKCl7YygpJiZnKCEwKX0pLGIuZXZlbnRzLm9uKFxcXCJmb3JtLnN1Ym1pdFxcXCIsZnVuY3Rpb24oKXtjKCkmJihiLmh0bWwuc2V0KGQoKSksYi5ldmVudHMudHJpZ2dlcihcXFwiY29udGVudENoYW5nZWRcXFwiLFtdLCEwKSl9LCEwKX1mdW5jdGlvbiBqKCl7aWYoIWIuJHdwKXJldHVybiExfXZhciBrLGwsbTtyZXR1cm57X2luaXQ6aix0b2dnbGU6Zyxpc0FjdGl2ZTpjLGdldDpkfX0sYS5GRS5SZWdpc3RlckNvbW1hbmQoXFxcImh0bWxcXFwiLHt0aXRsZTpcXFwiQ29kZSBWaWV3XFxcIix1bmRvOiExLGZvY3VzOiExLGZvcmNlZFJlZnJlc2g6ITAsdG9nZ2xlOiEwLGNhbGxiYWNrOmZ1bmN0aW9uKCl7dGhpcy5jb2RlVmlldy50b2dnbGUoKX0scGx1Z2luOlxcXCJjb2RlVmlld1xcXCJ9KSxhLkZFLkRlZmluZUljb24oXFxcImh0bWxcXFwiLHtOQU1FOlxcXCJjb2RlXFxcIn0pfSk7XCJcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcmF3LWxvYWRlciEuL34vZnJvYWxhLWVkaXRvci9qcy9wbHVnaW5zL2NvZGVfdmlldy5taW4uanNcbi8vIG1vZHVsZSBpZCA9IDEzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

	eval("__webpack_require__(2)(__webpack_require__(15))//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTQuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2Zyb2FsYS1lZGl0b3IvanMvcGx1Z2lucy9lbnRpdGllcy5taW4uanM/OTY4OCJdLCJzb3VyY2VzQ29udGVudCI6WyJyZXF1aXJlKFwiISEvVXNlcnMvamFrdWJmYWprdXMvRG9jdW1lbnRzL3ByYWNlL3ZlbmljZS1kZW1vL3dlYi9qcy9ub2RlX21vZHVsZXMvc2NyaXB0LWxvYWRlci9hZGRTY3JpcHQuanNcIikocmVxdWlyZShcIiEhL1VzZXJzL2pha3ViZmFqa3VzL0RvY3VtZW50cy9wcmFjZS92ZW5pY2UtZGVtby93ZWIvanMvbm9kZV9tb2R1bGVzL3Jhdy1sb2FkZXIvaW5kZXguanMhL1VzZXJzL2pha3ViZmFqa3VzL0RvY3VtZW50cy9wcmFjZS92ZW5pY2UtZGVtby93ZWIvanMvbm9kZV9tb2R1bGVzL2Zyb2FsYS1lZGl0b3IvanMvcGx1Z2lucy9lbnRpdGllcy5taW4uanNcIikpXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3NjcmlwdC1sb2FkZXIhLi9+L2Zyb2FsYS1lZGl0b3IvanMvcGx1Z2lucy9lbnRpdGllcy5taW4uanNcbi8vIG1vZHVsZSBpZCA9IDE0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 15 */
/***/ function(module, exports) {

	eval("module.exports = \"/*!\\n * froala_editor v2.5.0 (https://www.froala.com/wysiwyg-editor)\\n * License https://froala.com/wysiwyg-editor/terms/\\n * Copyright 2014-2017 Froala Labs\\n */\\n\\n!function(a){\\\"function\\\"==typeof define&&define.amd?define([\\\"jquery\\\"],a):\\\"object\\\"==typeof module&&module.exports?module.exports=function(b,c){return void 0===c&&(c=\\\"undefined\\\"!=typeof window?require(\\\"jquery\\\"):require(\\\"jquery\\\")(b)),a(c)}:a(window.jQuery)}(function(a){a.extend(a.FE.DEFAULTS,{entities:\\\"&quot;&#39;&iexcl;&cent;&pound;&curren;&yen;&brvbar;&sect;&uml;&copy;&ordf;&laquo;&not;&shy;&reg;&macr;&deg;&plusmn;&sup2;&sup3;&acute;&micro;&para;&middot;&cedil;&sup1;&ordm;&raquo;&frac14;&frac12;&frac34;&iquest;&Agrave;&Aacute;&Acirc;&Atilde;&Auml;&Aring;&AElig;&Ccedil;&Egrave;&Eacute;&Ecirc;&Euml;&Igrave;&Iacute;&Icirc;&Iuml;&ETH;&Ntilde;&Ograve;&Oacute;&Ocirc;&Otilde;&Ouml;&times;&Oslash;&Ugrave;&Uacute;&Ucirc;&Uuml;&Yacute;&THORN;&szlig;&agrave;&aacute;&acirc;&atilde;&auml;&aring;&aelig;&ccedil;&egrave;&eacute;&ecirc;&euml;&igrave;&iacute;&icirc;&iuml;&eth;&ntilde;&ograve;&oacute;&ocirc;&otilde;&ouml;&divide;&oslash;&ugrave;&uacute;&ucirc;&uuml;&yacute;&thorn;&yuml;&OElig;&oelig;&Scaron;&scaron;&Yuml;&fnof;&circ;&tilde;&Alpha;&Beta;&Gamma;&Delta;&Epsilon;&Zeta;&Eta;&Theta;&Iota;&Kappa;&Lambda;&Mu;&Nu;&Xi;&Omicron;&Pi;&Rho;&Sigma;&Tau;&Upsilon;&Phi;&Chi;&Psi;&Omega;&alpha;&beta;&gamma;&delta;&epsilon;&zeta;&eta;&theta;&iota;&kappa;&lambda;&mu;&nu;&xi;&omicron;&pi;&rho;&sigmaf;&sigma;&tau;&upsilon;&phi;&chi;&psi;&omega;&thetasym;&upsih;&piv;&ensp;&emsp;&thinsp;&zwnj;&zwj;&lrm;&rlm;&ndash;&mdash;&lsquo;&rsquo;&sbquo;&ldquo;&rdquo;&bdquo;&dagger;&Dagger;&bull;&hellip;&permil;&prime;&Prime;&lsaquo;&rsaquo;&oline;&frasl;&euro;&image;&weierp;&real;&trade;&alefsym;&larr;&uarr;&rarr;&darr;&harr;&crarr;&lArr;&uArr;&rArr;&dArr;&hArr;&forall;&part;&exist;&empty;&nabla;&isin;&notin;&ni;&prod;&sum;&minus;&lowast;&radic;&prop;&infin;&ang;&and;&or;&cap;&cup;&int;&there4;&sim;&cong;&asymp;&ne;&equiv;&le;&ge;&sub;&sup;&nsub;&sube;&supe;&oplus;&otimes;&perp;&sdot;&lceil;&rceil;&lfloor;&rfloor;&lang;&rang;&loz;&spades;&clubs;&hearts;&diams;\\\"}),a.FE.PLUGINS.entities=function(b){function c(a){var b=a.textContent;if(b.match(g)){for(var c=\\\"\\\",d=0;d<b.length;d++)c+=h[b[d]]?h[b[d]]:b[d];a.textContent=c}}function d(a){if(a&&[\\\"STYLE\\\",\\\"SCRIPT\\\",\\\"svg\\\"].indexOf(a.tagName)>=0)return!0;for(var e=b.node.contents(a),f=0;f<e.length;f++)e[f].nodeType==Node.TEXT_NODE?c(e[f]):d(e[f]);a.nodeType==Node.TEXT_NODE&&c(a)}function e(a){if(0===a.length)return\\\"\\\";var c=b.clean.exec(a,d).replace(/\\\\&amp;/g,\\\"&\\\");return c}function f(){b.opts.htmlSimpleAmpersand||(b.opts.entities=b.opts.entities+\\\"&amp;\\\");var c=a(\\\"<div>\\\").html(b.opts.entities).text(),d=b.opts.entities.split(\\\";\\\");h={},g=\\\"\\\";for(var f=0;f<c.length;f++){var i=c.charAt(f);h[i]=d[f]+\\\";\\\",g+=\\\"\\\\\\\\\\\"+i+(f<c.length-1?\\\"|\\\":\\\"\\\")}g=new RegExp(\\\"(\\\"+g+\\\")\\\",\\\"g\\\"),b.events.on(\\\"html.get\\\",e,!0)}var g,h;return{_init:f}}});\"//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTUuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2Zyb2FsYS1lZGl0b3IvanMvcGx1Z2lucy9lbnRpdGllcy5taW4uanM/ODViMiJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IFwiLyohXFxuICogZnJvYWxhX2VkaXRvciB2Mi41LjAgKGh0dHBzOi8vd3d3LmZyb2FsYS5jb20vd3lzaXd5Zy1lZGl0b3IpXFxuICogTGljZW5zZSBodHRwczovL2Zyb2FsYS5jb20vd3lzaXd5Zy1lZGl0b3IvdGVybXMvXFxuICogQ29weXJpZ2h0IDIwMTQtMjAxNyBGcm9hbGEgTGFic1xcbiAqL1xcblxcbiFmdW5jdGlvbihhKXtcXFwiZnVuY3Rpb25cXFwiPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZShbXFxcImpxdWVyeVxcXCJdLGEpOlxcXCJvYmplY3RcXFwiPT10eXBlb2YgbW9kdWxlJiZtb2R1bGUuZXhwb3J0cz9tb2R1bGUuZXhwb3J0cz1mdW5jdGlvbihiLGMpe3JldHVybiB2b2lkIDA9PT1jJiYoYz1cXFwidW5kZWZpbmVkXFxcIiE9dHlwZW9mIHdpbmRvdz9yZXF1aXJlKFxcXCJqcXVlcnlcXFwiKTpyZXF1aXJlKFxcXCJqcXVlcnlcXFwiKShiKSksYShjKX06YSh3aW5kb3cualF1ZXJ5KX0oZnVuY3Rpb24oYSl7YS5leHRlbmQoYS5GRS5ERUZBVUxUUyx7ZW50aXRpZXM6XFxcIiZxdW90OyYjMzk7JmlleGNsOyZjZW50OyZwb3VuZDsmY3VycmVuOyZ5ZW47JmJydmJhcjsmc2VjdDsmdW1sOyZjb3B5OyZvcmRmOyZsYXF1bzsmbm90OyZzaHk7JnJlZzsmbWFjcjsmZGVnOyZwbHVzbW47JnN1cDI7JnN1cDM7JmFjdXRlOyZtaWNybzsmcGFyYTsmbWlkZG90OyZjZWRpbDsmc3VwMTsmb3JkbTsmcmFxdW87JmZyYWMxNDsmZnJhYzEyOyZmcmFjMzQ7JmlxdWVzdDsmQWdyYXZlOyZBYWN1dGU7JkFjaXJjOyZBdGlsZGU7JkF1bWw7JkFyaW5nOyZBRWxpZzsmQ2NlZGlsOyZFZ3JhdmU7JkVhY3V0ZTsmRWNpcmM7JkV1bWw7JklncmF2ZTsmSWFjdXRlOyZJY2lyYzsmSXVtbDsmRVRIOyZOdGlsZGU7Jk9ncmF2ZTsmT2FjdXRlOyZPY2lyYzsmT3RpbGRlOyZPdW1sOyZ0aW1lczsmT3NsYXNoOyZVZ3JhdmU7JlVhY3V0ZTsmVWNpcmM7JlV1bWw7JllhY3V0ZTsmVEhPUk47JnN6bGlnOyZhZ3JhdmU7JmFhY3V0ZTsmYWNpcmM7JmF0aWxkZTsmYXVtbDsmYXJpbmc7JmFlbGlnOyZjY2VkaWw7JmVncmF2ZTsmZWFjdXRlOyZlY2lyYzsmZXVtbDsmaWdyYXZlOyZpYWN1dGU7JmljaXJjOyZpdW1sOyZldGg7Jm50aWxkZTsmb2dyYXZlOyZvYWN1dGU7Jm9jaXJjOyZvdGlsZGU7Jm91bWw7JmRpdmlkZTsmb3NsYXNoOyZ1Z3JhdmU7JnVhY3V0ZTsmdWNpcmM7JnV1bWw7JnlhY3V0ZTsmdGhvcm47Jnl1bWw7Jk9FbGlnOyZvZWxpZzsmU2Nhcm9uOyZzY2Fyb247Jll1bWw7JmZub2Y7JmNpcmM7JnRpbGRlOyZBbHBoYTsmQmV0YTsmR2FtbWE7JkRlbHRhOyZFcHNpbG9uOyZaZXRhOyZFdGE7JlRoZXRhOyZJb3RhOyZLYXBwYTsmTGFtYmRhOyZNdTsmTnU7JlhpOyZPbWljcm9uOyZQaTsmUmhvOyZTaWdtYTsmVGF1OyZVcHNpbG9uOyZQaGk7JkNoaTsmUHNpOyZPbWVnYTsmYWxwaGE7JmJldGE7JmdhbW1hOyZkZWx0YTsmZXBzaWxvbjsmemV0YTsmZXRhOyZ0aGV0YTsmaW90YTsma2FwcGE7JmxhbWJkYTsmbXU7Jm51OyZ4aTsmb21pY3JvbjsmcGk7JnJobzsmc2lnbWFmOyZzaWdtYTsmdGF1OyZ1cHNpbG9uOyZwaGk7JmNoaTsmcHNpOyZvbWVnYTsmdGhldGFzeW07JnVwc2loOyZwaXY7JmVuc3A7JmVtc3A7JnRoaW5zcDsmenduajsmendqOyZscm07JnJsbTsmbmRhc2g7Jm1kYXNoOyZsc3F1bzsmcnNxdW87JnNicXVvOyZsZHF1bzsmcmRxdW87JmJkcXVvOyZkYWdnZXI7JkRhZ2dlcjsmYnVsbDsmaGVsbGlwOyZwZXJtaWw7JnByaW1lOyZQcmltZTsmbHNhcXVvOyZyc2FxdW87Jm9saW5lOyZmcmFzbDsmZXVybzsmaW1hZ2U7JndlaWVycDsmcmVhbDsmdHJhZGU7JmFsZWZzeW07JmxhcnI7JnVhcnI7JnJhcnI7JmRhcnI7JmhhcnI7JmNyYXJyOyZsQXJyOyZ1QXJyOyZyQXJyOyZkQXJyOyZoQXJyOyZmb3JhbGw7JnBhcnQ7JmV4aXN0OyZlbXB0eTsmbmFibGE7JmlzaW47Jm5vdGluOyZuaTsmcHJvZDsmc3VtOyZtaW51czsmbG93YXN0OyZyYWRpYzsmcHJvcDsmaW5maW47JmFuZzsmYW5kOyZvcjsmY2FwOyZjdXA7JmludDsmdGhlcmU0OyZzaW07JmNvbmc7JmFzeW1wOyZuZTsmZXF1aXY7JmxlOyZnZTsmc3ViOyZzdXA7Jm5zdWI7JnN1YmU7JnN1cGU7Jm9wbHVzOyZvdGltZXM7JnBlcnA7JnNkb3Q7JmxjZWlsOyZyY2VpbDsmbGZsb29yOyZyZmxvb3I7Jmxhbmc7JnJhbmc7Jmxvejsmc3BhZGVzOyZjbHViczsmaGVhcnRzOyZkaWFtcztcXFwifSksYS5GRS5QTFVHSU5TLmVudGl0aWVzPWZ1bmN0aW9uKGIpe2Z1bmN0aW9uIGMoYSl7dmFyIGI9YS50ZXh0Q29udGVudDtpZihiLm1hdGNoKGcpKXtmb3IodmFyIGM9XFxcIlxcXCIsZD0wO2Q8Yi5sZW5ndGg7ZCsrKWMrPWhbYltkXV0/aFtiW2RdXTpiW2RdO2EudGV4dENvbnRlbnQ9Y319ZnVuY3Rpb24gZChhKXtpZihhJiZbXFxcIlNUWUxFXFxcIixcXFwiU0NSSVBUXFxcIixcXFwic3ZnXFxcIl0uaW5kZXhPZihhLnRhZ05hbWUpPj0wKXJldHVybiEwO2Zvcih2YXIgZT1iLm5vZGUuY29udGVudHMoYSksZj0wO2Y8ZS5sZW5ndGg7ZisrKWVbZl0ubm9kZVR5cGU9PU5vZGUuVEVYVF9OT0RFP2MoZVtmXSk6ZChlW2ZdKTthLm5vZGVUeXBlPT1Ob2RlLlRFWFRfTk9ERSYmYyhhKX1mdW5jdGlvbiBlKGEpe2lmKDA9PT1hLmxlbmd0aClyZXR1cm5cXFwiXFxcIjt2YXIgYz1iLmNsZWFuLmV4ZWMoYSxkKS5yZXBsYWNlKC9cXFxcJmFtcDsvZyxcXFwiJlxcXCIpO3JldHVybiBjfWZ1bmN0aW9uIGYoKXtiLm9wdHMuaHRtbFNpbXBsZUFtcGVyc2FuZHx8KGIub3B0cy5lbnRpdGllcz1iLm9wdHMuZW50aXRpZXMrXFxcIiZhbXA7XFxcIik7dmFyIGM9YShcXFwiPGRpdj5cXFwiKS5odG1sKGIub3B0cy5lbnRpdGllcykudGV4dCgpLGQ9Yi5vcHRzLmVudGl0aWVzLnNwbGl0KFxcXCI7XFxcIik7aD17fSxnPVxcXCJcXFwiO2Zvcih2YXIgZj0wO2Y8Yy5sZW5ndGg7ZisrKXt2YXIgaT1jLmNoYXJBdChmKTtoW2ldPWRbZl0rXFxcIjtcXFwiLGcrPVxcXCJcXFxcXFxcXFxcXCIraSsoZjxjLmxlbmd0aC0xP1xcXCJ8XFxcIjpcXFwiXFxcIil9Zz1uZXcgUmVnRXhwKFxcXCIoXFxcIitnK1xcXCIpXFxcIixcXFwiZ1xcXCIpLGIuZXZlbnRzLm9uKFxcXCJodG1sLmdldFxcXCIsZSwhMCl9dmFyIGcsaDtyZXR1cm57X2luaXQ6Zn19fSk7XCJcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcmF3LWxvYWRlciEuL34vZnJvYWxhLWVkaXRvci9qcy9wbHVnaW5zL2VudGl0aWVzLm1pbi5qc1xuLy8gbW9kdWxlIGlkID0gMTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQSIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

	eval("__webpack_require__(2)(__webpack_require__(17))//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTYuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2Zyb2FsYS1lZGl0b3IvanMvcGx1Z2lucy9saW5rLm1pbi5qcz9lNGE2Il0sInNvdXJjZXNDb250ZW50IjpbInJlcXVpcmUoXCIhIS9Vc2Vycy9qYWt1YmZhamt1cy9Eb2N1bWVudHMvcHJhY2UvdmVuaWNlLWRlbW8vd2ViL2pzL25vZGVfbW9kdWxlcy9zY3JpcHQtbG9hZGVyL2FkZFNjcmlwdC5qc1wiKShyZXF1aXJlKFwiISEvVXNlcnMvamFrdWJmYWprdXMvRG9jdW1lbnRzL3ByYWNlL3ZlbmljZS1kZW1vL3dlYi9qcy9ub2RlX21vZHVsZXMvcmF3LWxvYWRlci9pbmRleC5qcyEvVXNlcnMvamFrdWJmYWprdXMvRG9jdW1lbnRzL3ByYWNlL3ZlbmljZS1kZW1vL3dlYi9qcy9ub2RlX21vZHVsZXMvZnJvYWxhLWVkaXRvci9qcy9wbHVnaW5zL2xpbmsubWluLmpzXCIpKVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9zY3JpcHQtbG9hZGVyIS4vfi9mcm9hbGEtZWRpdG9yL2pzL3BsdWdpbnMvbGluay5taW4uanNcbi8vIG1vZHVsZSBpZCA9IDE2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 17 */
/***/ function(module, exports) {

	eval("module.exports = \"/*!\\n * froala_editor v2.5.0 (https://www.froala.com/wysiwyg-editor)\\n * License https://froala.com/wysiwyg-editor/terms/\\n * Copyright 2014-2017 Froala Labs\\n */\\n\\n!function(a){\\\"function\\\"==typeof define&&define.amd?define([\\\"jquery\\\"],a):\\\"object\\\"==typeof module&&module.exports?module.exports=function(b,c){return void 0===c&&(c=\\\"undefined\\\"!=typeof window?require(\\\"jquery\\\"):require(\\\"jquery\\\")(b)),a(c)}:a(window.jQuery)}(function(a){a.extend(a.FE.POPUP_TEMPLATES,{\\\"link.edit\\\":\\\"[_BUTTONS_]\\\",\\\"link.insert\\\":\\\"[_BUTTONS_][_INPUT_LAYER_]\\\"}),a.extend(a.FE.DEFAULTS,{linkEditButtons:[\\\"linkOpen\\\",\\\"linkStyle\\\",\\\"linkEdit\\\",\\\"linkRemove\\\"],linkInsertButtons:[\\\"linkBack\\\",\\\"|\\\",\\\"linkList\\\"],linkAttributes:{},linkAutoPrefix:\\\"http://\\\",linkStyles:{\\\"fr-green\\\":\\\"Green\\\",\\\"fr-strong\\\":\\\"Thick\\\"},linkMultipleStyles:!0,linkConvertEmailAddress:!0,linkAlwaysBlank:!1,linkAlwaysNoFollow:!1,linkList:[{text:\\\"Froala\\\",href:\\\"https://froala.com\\\",target:\\\"_blank\\\"},{text:\\\"Google\\\",href:\\\"https://google.com\\\",target:\\\"_blank\\\"},{displayText:\\\"Facebook\\\",href:\\\"https://facebook.com\\\"}],linkText:!0}),a.FE.PLUGINS.link=function(b){function c(){var c=b.image?b.image.get():null;if(!c&&b.$wp){var d=b.selection.ranges(0).commonAncestorContainer;if(d&&(d.contains&&d.contains(b.el)||!b.el.contains(d)||b.el==d)&&(d=null),d&&\\\"A\\\"===d.tagName)return d;var e=b.selection.element(),f=b.selection.endElement();return\\\"A\\\"==e.tagName||b.node.isElement(e)||(e=a(e).parentsUntil(b.$el,\\\"a:first\\\").get(0)),\\\"A\\\"==f.tagName||b.node.isElement(f)||(f=a(f).parentsUntil(b.$el,\\\"a:first\\\").get(0)),f&&(f.contains&&f.contains(b.el)||!b.el.contains(f)||b.el==f)&&(f=null),e&&(e.contains&&e.contains(b.el)||!b.el.contains(e)||b.el==e)&&(e=null),f&&f==e&&\\\"A\\\"==f.tagName?e:null}return\\\"A\\\"==b.el.tagName?b.el:c&&c.get(0).parentNode&&\\\"A\\\"==c.get(0).parentNode.tagName?c.get(0).parentNode:void 0}function d(){var a=b.image?b.image.get():null,c=[];if(a)\\\"A\\\"==a.get(0).parentNode.tagName&&c.push(a.get(0).parentNode);else{var d,e,f,g;if(b.win.getSelection){var h=b.win.getSelection();if(h.getRangeAt&&h.rangeCount){g=b.doc.createRange();for(var i=0;i<h.rangeCount;++i)if(d=h.getRangeAt(i),e=d.commonAncestorContainer,e&&1!=e.nodeType&&(e=e.parentNode),e&&\\\"a\\\"==e.nodeName.toLowerCase())c.push(e);else{f=e.getElementsByTagName(\\\"a\\\");for(var j=0;j<f.length;++j)g.selectNodeContents(f[j]),g.compareBoundaryPoints(d.END_TO_START,d)<1&&g.compareBoundaryPoints(d.START_TO_END,d)>-1&&c.push(f[j])}}}else if(b.doc.selection&&\\\"Control\\\"!=b.doc.selection.type)if(d=b.doc.selection.createRange(),e=d.parentElement(),\\\"a\\\"==e.nodeName.toLowerCase())c.push(e);else{f=e.getElementsByTagName(\\\"a\\\"),g=b.doc.body.createTextRange();for(var k=0;k<f.length;++k)g.moveToElementText(f[k]),g.compareEndPoints(\\\"StartToEnd\\\",d)>-1&&g.compareEndPoints(\\\"EndToStart\\\",d)<1&&c.push(f[k])}}return c}function e(d){g(),setTimeout(function(){if(!d||d&&(1==d.which||\\\"mouseup\\\"!=d.type)){var e=c(),g=b.image?b.image.get():null;if(e&&!g){if(b.image){var h=b.node.contents(e);if(1==h.length&&\\\"IMG\\\"==h[0].tagName){var i=b.selection.ranges(0);return 0===i.startOffset&&0===i.endOffset?a(e).before(a.FE.MARKERS):a(e).after(a.FE.MARKERS),b.selection.restore(),!1}}d&&d.stopPropagation(),f(e)}}},b.helpers.isIOS()?100:0)}function f(c){var d=b.popups.get(\\\"link.edit\\\");d||(d=h());var e=a(c);b.popups.isVisible(\\\"link.edit\\\")||b.popups.refresh(\\\"link.edit\\\"),b.popups.setContainer(\\\"link.edit\\\",b.$sc);var f=e.offset().left+a(c).outerWidth()/2,g=e.offset().top+e.outerHeight();b.popups.show(\\\"link.edit\\\",f,g,e.outerHeight())}function g(){b.popups.hide(\\\"link.edit\\\")}function h(){var a=\\\"\\\";b.opts.linkEditButtons.length>1&&(\\\"A\\\"==b.el.tagName&&b.opts.linkEditButtons.indexOf(\\\"linkRemove\\\")>=0&&b.opts.linkEditButtons.splice(b.opts.linkEditButtons.indexOf(\\\"linkRemove\\\"),1),a='<div class=\\\"fr-buttons\\\">'+b.button.buildList(b.opts.linkEditButtons)+\\\"</div>\\\");var d={buttons:a},e=b.popups.create(\\\"link.edit\\\",d);return b.$wp&&b.events.$on(b.$wp,\\\"scroll.link-edit\\\",function(){c()&&b.popups.isVisible(\\\"link.edit\\\")&&f(c())}),e}function i(){}function j(){var d=b.popups.get(\\\"link.insert\\\"),e=c();if(e){var f,g,h=a(e),i=d.find('input.fr-link-attr[type=\\\"text\\\"]'),j=d.find('input.fr-link-attr[type=\\\"checkbox\\\"]');for(f=0;f<i.length;f++)g=a(i[f]),g.val(h.attr(g.attr(\\\"name\\\")||\\\"\\\"));for(j.prop(\\\"checked\\\",!1),f=0;f<j.length;f++)g=a(j[f]),h.attr(g.attr(\\\"name\\\"))==g.data(\\\"checked\\\")&&g.prop(\\\"checked\\\",!0);d.find('input.fr-link-attr[type=\\\"text\\\"][name=\\\"text\\\"]').val(h.text())}else d.find('input.fr-link-attr[type=\\\"text\\\"]').val(\\\"\\\"),d.find('input.fr-link-attr[type=\\\"checkbox\\\"]').prop(\\\"checked\\\",!1),d.find('input.fr-link-attr[type=\\\"text\\\"][name=\\\"text\\\"]').val(b.selection.text());d.find(\\\"input.fr-link-attr\\\").trigger(\\\"change\\\");var k=b.image?b.image.get():null;k?d.find('.fr-link-attr[name=\\\"text\\\"]').parent().hide():d.find('.fr-link-attr[name=\\\"text\\\"]').parent().show()}function k(){var a=b.$tb.find('.fr-command[data-cmd=\\\"insertLink\\\"]'),c=b.popups.get(\\\"link.insert\\\");if(c||(c=l()),!c.hasClass(\\\"fr-active\\\"))if(b.popups.refresh(\\\"link.insert\\\"),b.popups.setContainer(\\\"link.insert\\\",b.$tb||b.$sc),a.is(\\\":visible\\\")){var d=a.offset().left+a.outerWidth()/2,e=a.offset().top+(b.opts.toolbarBottom?10:a.outerHeight()-10);b.popups.show(\\\"link.insert\\\",d,e,a.outerHeight())}else b.position.forSelection(c),b.popups.show(\\\"link.insert\\\")}function l(a){if(a)return b.popups.onRefresh(\\\"link.insert\\\",j),b.popups.onHide(\\\"link.insert\\\",i),!0;var d=\\\"\\\";b.opts.linkInsertButtons.length>=1&&(d='<div class=\\\"fr-buttons\\\">'+b.button.buildList(b.opts.linkInsertButtons)+\\\"</div>\\\");var e='<svg version=\\\"1.1\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\" xmlns:xlink=\\\"http://www.w3.org/1999/xlink\\\" width=\\\"10\\\" height=\\\"10\\\" viewBox=\\\"0 0 32 32\\\"><path d=\\\"M27 4l-15 15-7-7-5 5 12 12 20-20z\\\" fill=\\\"#FFF\\\"></path></svg>',f=\\\"\\\",g=0;f='<div class=\\\"fr-link-insert-layer fr-layer fr-active\\\" id=\\\"fr-link-insert-layer-'+b.id+'\\\">',f+='<div class=\\\"fr-input-line\\\"><input id=\\\"fr-link-insert-layer-url-'+b.id+'\\\" name=\\\"href\\\" type=\\\"text\\\" class=\\\"fr-link-attr\\\" placeholder=\\\"URL\\\" tabIndex=\\\"'+ ++g+'\\\"></div>',b.opts.linkText&&(f+='<div class=\\\"fr-input-line\\\"><input id=\\\"fr-link-insert-layer-text-'+b.id+'\\\" name=\\\"text\\\" type=\\\"text\\\" class=\\\"fr-link-attr\\\" placeholder=\\\"'+b.language.translate(\\\"Text\\\")+'\\\" tabIndex=\\\"'+ ++g+'\\\"></div>');for(var h in b.opts.linkAttributes)if(b.opts.linkAttributes.hasOwnProperty(h)){var k=b.opts.linkAttributes[h];f+='<div class=\\\"fr-input-line\\\"><input name=\\\"'+h+'\\\" type=\\\"text\\\" class=\\\"fr-link-attr\\\" placeholder=\\\"'+b.language.translate(k)+'\\\" tabIndex=\\\"'+ ++g+'\\\"></div>'}b.opts.linkAlwaysBlank||(f+='<div class=\\\"fr-checkbox-line\\\"><span class=\\\"fr-checkbox\\\"><input name=\\\"target\\\" class=\\\"fr-link-attr\\\" data-checked=\\\"_blank\\\" type=\\\"checkbox\\\" id=\\\"fr-link-target-'+b.id+'\\\" tabIndex=\\\"'+ ++g+'\\\"><span>'+e+'</span></span><label for=\\\"fr-link-target-'+b.id+'\\\">'+b.language.translate(\\\"Open in new tab\\\")+\\\"</label></div>\\\"),f+='<div class=\\\"fr-action-buttons\\\"><button class=\\\"fr-command fr-submit\\\" role=\\\"button\\\" data-cmd=\\\"linkInsert\\\" href=\\\"#\\\" tabIndex=\\\"'+ ++g+'\\\" type=\\\"button\\\">'+b.language.translate(\\\"Insert\\\")+\\\"</button></div></div>\\\";var l={buttons:d,input_layer:f},m=b.popups.create(\\\"link.insert\\\",l);return b.$wp&&b.events.$on(b.$wp,\\\"scroll.link-insert\\\",function(){var a=b.image?b.image.get():null;a&&b.popups.isVisible(\\\"link.insert\\\")&&u(),c&&b.popups.isVisible(\\\"link.insert\\\")&&s()}),m}function m(){var d=c(),e=b.image?b.image.get():null;return b.events.trigger(\\\"link.beforeRemove\\\",[d])!==!1&&void(e&&d?(e.unwrap(),b.image.edit(e)):d&&(b.selection.save(),a(d).replaceWith(a(d).html()),b.selection.restore(),g()))}function n(){b.events.on(\\\"keyup\\\",function(b){b.which!=a.FE.KEYCODE.ESC&&e(b)}),b.events.on(\\\"window.mouseup\\\",e),b.helpers.isMobile()&&b.events.$on(b.$doc,\\\"selectionchange\\\",e),l(!0),\\\"A\\\"==b.el.tagName&&b.$el.addClass(\\\"fr-view\\\"),b.events.on(\\\"toolbar.esc\\\",function(){if(b.popups.isVisible(\\\"link.edit\\\"))return b.events.disableBlur(),b.events.focus(),!1},!0)}function o(c){var d,e,f=b.opts.linkList[c],g=b.popups.get(\\\"link.insert\\\"),h=g.find('input.fr-link-attr[type=\\\"text\\\"]'),i=g.find('input.fr-link-attr[type=\\\"checkbox\\\"]');for(e=0;e<h.length;e++)d=a(h[e]),f[d.attr(\\\"name\\\")]?d.val(f[d.attr(\\\"name\\\")]):\\\"text\\\"!=d.attr(\\\"name\\\")&&d.val(\\\"\\\");for(e=0;e<i.length;e++)d=a(i[e]),d.prop(\\\"checked\\\",d.data(\\\"checked\\\")==f[d.attr(\\\"name\\\")]);b.accessibility.focusPopup(g)}function p(){var c,d,e=b.popups.get(\\\"link.insert\\\"),f=e.find('input.fr-link-attr[type=\\\"text\\\"]'),g=e.find('input.fr-link-attr[type=\\\"checkbox\\\"]'),h=f.filter('[name=\\\"href\\\"]').val(),i=f.filter('[name=\\\"text\\\"]').val(),j={};for(d=0;d<f.length;d++)c=a(f[d]),[\\\"href\\\",\\\"text\\\"].indexOf(c.attr(\\\"name\\\"))<0&&(j[c.attr(\\\"name\\\")]=c.val());for(d=0;d<g.length;d++)c=a(g[d]),c.is(\\\":checked\\\")?j[c.attr(\\\"name\\\")]=c.data(\\\"checked\\\"):j[c.attr(\\\"name\\\")]=c.data(\\\"unchecked\\\")||null;var k=b.helpers.scrollTop();r(h,i,j),a(b.o_win).scrollTop(k)}function q(){if(!b.selection.isCollapsed()){b.selection.save();for(var c=b.$el.find(\\\".fr-marker\\\").addClass(\\\"fr-unprocessed\\\").toArray();c.length;){var d=a(c.pop());d.removeClass(\\\"fr-unprocessed\\\");var e=b.node.deepestParent(d.get(0));if(e){var f=d.get(0),g=\\\"\\\",h=\\\"\\\";do f=f.parentNode,b.node.isBlock(f)||(g+=b.node.closeTagString(f),h=b.node.openTagString(f)+h);while(f!=e);var i=b.node.openTagString(d.get(0))+d.html()+b.node.closeTagString(d.get(0));d.replaceWith('<span id=\\\"fr-break\\\"></span>');var j=a(e).html();j=j.replace(/<span id=\\\"fr-break\\\"><\\\\/span>/g,g+i+h),a(e).html(j)}c=b.$el.find(\\\".fr-marker.fr-unprocessed\\\").toArray()}b.selection.restore()}}function r(f,g,h){if(\\\"undefined\\\"==typeof h&&(h={}),b.events.trigger(\\\"link.beforeInsert\\\",[f,g,h])===!1)return!1;var i=b.image?b.image.get():null;i||\\\"A\\\"==b.el.tagName?\\\"A\\\"==b.el.tagName&&b.$el.focus():(b.selection.restore(),b.popups.hide(\\\"link.insert\\\"));var j=f;if(b.opts.linkConvertEmailAddress){var k=/^[\\\\w._]+@[a-z\\\\u00a1-\\\\uffff0-9_-]+?\\\\.[a-z\\\\u00a1-\\\\uffff0-9]{2,}$/i;k.test(f)&&!/^mailto:.*/i.test(f)&&(f=\\\"mailto:\\\"+f)}if(\\\"\\\"===b.opts.linkAutoPrefix||/^(mailto|tel|sms|notes|data):.*/i.test(f)||/^data:image.*/i.test(f)||/^(https?:|ftps?:|file:|)\\\\/\\\\//i.test(f)||[\\\"/\\\",\\\"{\\\",\\\"[\\\",\\\"#\\\",\\\"(\\\"].indexOf((f||\\\"\\\")[0])<0&&(f=b.opts.linkAutoPrefix+f),f=b.helpers.sanitizeURL(f),b.opts.linkAlwaysBlank&&(h.target=\\\"_blank\\\"),b.opts.linkAlwaysNoFollow&&(h.rel=\\\"nofollow\\\"),\\\"_blank\\\"==h.target&&(h.rel?h.rel+=\\\" noopener noreferrer\\\":h.rel=\\\"noopener noreferrer\\\"),g=g||\\\"\\\",f===b.opts.linkAutoPrefix){var l=b.popups.get(\\\"link.insert\\\");return l.find('input[name=\\\"href\\\"]').addClass(\\\"fr-error\\\"),b.events.trigger(\\\"link.bad\\\",[j]),!1}var m,n=c();if(n)m=a(n),m.attr(\\\"href\\\",f),g.length>0&&m.text()!=g&&!i&&m.text(g),i||m.prepend(a.FE.START_MARKER).append(a.FE.END_MARKER),m.attr(h),i||b.selection.restore();else{i?i.wrap('<a href=\\\"'+f+'\\\"></a>'):(b.format.remove(\\\"a\\\"),b.selection.isCollapsed()?(g=0===g.length?j:g,b.html.insert('<a href=\\\"'+f+'\\\">'+a.FE.START_MARKER+g+a.FE.END_MARKER+\\\"</a>\\\"),b.selection.restore()):g.length>0&&g!=b.selection.text().replace(/\\\\n/g,\\\"\\\")?(b.selection.remove(),b.html.insert('<a href=\\\"'+f+'\\\">'+a.FE.START_MARKER+g+a.FE.END_MARKER+\\\"</a>\\\"),b.selection.restore()):(q(),b.format.apply(\\\"a\\\",{href:f})));for(var o=d(),p=0;p<o.length;p++)m=a(o[p]),m.attr(h),m.removeAttr(\\\"_moz_dirty\\\");1==o.length&&b.$wp&&!i&&(a(o[0]).prepend(a.FE.START_MARKER).append(a.FE.END_MARKER),b.selection.restore())}if(i){var r=b.popups.get(\\\"link.insert\\\");r.find(\\\"input:focus\\\").blur(),b.image.edit(i)}else e()}function s(){g();var d=c();if(d){var e=b.popups.get(\\\"link.insert\\\");e||(e=l()),b.popups.isVisible(\\\"link.insert\\\")||(b.popups.refresh(\\\"link.insert\\\"),b.selection.save(),b.helpers.isMobile()&&(b.events.disableBlur(),b.$el.blur(),b.events.enableBlur())),b.popups.setContainer(\\\"link.insert\\\",b.$sc);var f=(b.image?b.image.get():null)||a(d),h=f.offset().left+f.outerWidth()/2,i=f.offset().top+f.outerHeight();b.popups.show(\\\"link.insert\\\",h,i,f.outerHeight())}}function t(){var a=b.image?b.image.get():null;if(a)b.image.back();else{b.events.disableBlur(),b.selection.restore(),b.events.enableBlur();var d=c();d&&b.$wp?(b.selection.restore(),g(),e()):\\\"A\\\"==b.el.tagName?(b.$el.focus(),e()):(b.popups.hide(\\\"link.insert\\\"),b.toolbar.showInline())}}function u(){var a=b.image?b.image.get():null;if(a){var c=b.popups.get(\\\"link.insert\\\");c||(c=l()),j(!0),b.popups.setContainer(\\\"link.insert\\\",b.$sc);var d=a.offset().left+a.outerWidth()/2,e=a.offset().top+a.outerHeight();b.popups.show(\\\"link.insert\\\",d,e,a.outerHeight())}}function v(d,f,g){\\\"undefined\\\"==typeof g&&(g=b.opts.linkMultipleStyles),\\\"undefined\\\"==typeof f&&(f=b.opts.linkStyles);var h=c();if(!h)return!1;if(!g){var i=Object.keys(f);i.splice(i.indexOf(d),1),a(h).removeClass(i.join(\\\" \\\"))}a(h).toggleClass(d),e()}return{_init:n,remove:m,showInsertPopup:k,usePredefined:o,insertCallback:p,insert:r,update:s,get:c,allSelected:d,back:t,imageLink:u,applyStyle:v}},a.FE.DefineIcon(\\\"insertLink\\\",{NAME:\\\"link\\\"}),a.FE.RegisterShortcut(a.FE.KEYCODE.K,\\\"insertLink\\\",null,\\\"K\\\"),a.FE.RegisterCommand(\\\"insertLink\\\",{title:\\\"Insert Link\\\",undo:!1,focus:!0,refreshOnCallback:!1,popup:!0,callback:function(){this.popups.isVisible(\\\"link.insert\\\")?(this.$el.find(\\\".fr-marker\\\").length&&(this.events.disableBlur(),this.selection.restore()),this.popups.hide(\\\"link.insert\\\")):this.link.showInsertPopup()},plugin:\\\"link\\\"}),a.FE.DefineIcon(\\\"linkOpen\\\",{NAME:\\\"external-link\\\"}),a.FE.RegisterCommand(\\\"linkOpen\\\",{title:\\\"Open Link\\\",undo:!1,refresh:function(a){var b=this.link.get();b?a.removeClass(\\\"fr-hidden\\\"):a.addClass(\\\"fr-hidden\\\")},callback:function(){var a=this.link.get();a&&this.o_win.open(a.href)}}),a.FE.DefineIcon(\\\"linkEdit\\\",{NAME:\\\"edit\\\"}),a.FE.RegisterCommand(\\\"linkEdit\\\",{title:\\\"Edit Link\\\",undo:!1,refreshAfterCallback:!1,popup:!0,callback:function(){this.link.update()},refresh:function(a){var b=this.link.get();b?a.removeClass(\\\"fr-hidden\\\"):a.addClass(\\\"fr-hidden\\\")}}),a.FE.DefineIcon(\\\"linkRemove\\\",{NAME:\\\"unlink\\\"}),a.FE.RegisterCommand(\\\"linkRemove\\\",{title:\\\"Unlink\\\",callback:function(){this.link.remove()},refresh:function(a){var b=this.link.get();b?a.removeClass(\\\"fr-hidden\\\"):a.addClass(\\\"fr-hidden\\\")}}),a.FE.DefineIcon(\\\"linkBack\\\",{NAME:\\\"arrow-left\\\"}),a.FE.RegisterCommand(\\\"linkBack\\\",{title:\\\"Back\\\",undo:!1,focus:!1,back:!0,refreshAfterCallback:!1,callback:function(){this.link.back()},refresh:function(a){var b=this.link.get()&&this.doc.hasFocus(),c=this.image?this.image.get():null;c||b||this.opts.toolbarInline?(a.removeClass(\\\"fr-hidden\\\"),a.next(\\\".fr-separator\\\").removeClass(\\\"fr-hidden\\\")):(a.addClass(\\\"fr-hidden\\\"),a.next(\\\".fr-separator\\\").addClass(\\\"fr-hidden\\\"))}}),a.FE.DefineIcon(\\\"linkList\\\",{NAME:\\\"search\\\"}),a.FE.RegisterCommand(\\\"linkList\\\",{title:\\\"Choose Link\\\",type:\\\"dropdown\\\",focus:!1,undo:!1,refreshAfterCallback:!1,html:function(){for(var a='<ul class=\\\"fr-dropdown-list\\\" role=\\\"presentation\\\">',b=this.opts.linkList,c=0;c<b.length;c++)a+='<li role=\\\"presentation\\\"><a class=\\\"fr-command\\\" tabIndex=\\\"-1\\\" role=\\\"option\\\" data-cmd=\\\"linkList\\\" data-param1=\\\"'+c+'\\\">'+(b[c].displayText||b[c].text)+\\\"</a></li>\\\";return a+=\\\"</ul>\\\"},callback:function(a,b){this.link.usePredefined(b)}}),a.FE.RegisterCommand(\\\"linkInsert\\\",{focus:!1,refreshAfterCallback:!1,callback:function(){this.link.insertCallback()},refresh:function(a){var b=this.link.get();b?a.text(this.language.translate(\\\"Update\\\")):a.text(this.language.translate(\\\"Insert\\\"))}}),a.FE.DefineIcon(\\\"imageLink\\\",{NAME:\\\"link\\\"}),a.FE.RegisterCommand(\\\"imageLink\\\",{title:\\\"Insert Link\\\",undo:!1,focus:!1,popup:!0,callback:function(){this.link.imageLink()},refresh:function(a){var b,c=this.link.get();c?(b=a.prev(),b.hasClass(\\\"fr-separator\\\")&&b.removeClass(\\\"fr-hidden\\\"),a.addClass(\\\"fr-hidden\\\")):(b=a.prev(),b.hasClass(\\\"fr-separator\\\")&&b.addClass(\\\"fr-hidden\\\"),a.removeClass(\\\"fr-hidden\\\"))}}),a.FE.DefineIcon(\\\"linkStyle\\\",{NAME:\\\"magic\\\"}),a.FE.RegisterCommand(\\\"linkStyle\\\",{title:\\\"Style\\\",type:\\\"dropdown\\\",html:function(){var a='<ul class=\\\"fr-dropdown-list\\\" role=\\\"presentation\\\">',b=this.opts.linkStyles;for(var c in b)b.hasOwnProperty(c)&&(a+='<li role=\\\"presentation\\\"><a class=\\\"fr-command\\\" tabIndex=\\\"-1\\\" role=\\\"option\\\" data-cmd=\\\"linkStyle\\\" data-param1=\\\"'+c+'\\\">'+this.language.translate(b[c])+\\\"</a></li>\\\");return a+=\\\"</ul>\\\"},callback:function(a,b){this.link.applyStyle(b)},refreshOnShow:function(b,c){var d=this.link.get();if(d){var e=a(d);c.find(\\\".fr-command\\\").each(function(){var b=a(this).data(\\\"param1\\\"),c=e.hasClass(b);a(this).toggleClass(\\\"fr-active\\\",c).attr(\\\"aria-selected\\\",c)})}}})});\"//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTcuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2Zyb2FsYS1lZGl0b3IvanMvcGx1Z2lucy9saW5rLm1pbi5qcz81MmY1Il0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gXCIvKiFcXG4gKiBmcm9hbGFfZWRpdG9yIHYyLjUuMCAoaHR0cHM6Ly93d3cuZnJvYWxhLmNvbS93eXNpd3lnLWVkaXRvcilcXG4gKiBMaWNlbnNlIGh0dHBzOi8vZnJvYWxhLmNvbS93eXNpd3lnLWVkaXRvci90ZXJtcy9cXG4gKiBDb3B5cmlnaHQgMjAxNC0yMDE3IEZyb2FsYSBMYWJzXFxuICovXFxuXFxuIWZ1bmN0aW9uKGEpe1xcXCJmdW5jdGlvblxcXCI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQ/ZGVmaW5lKFtcXFwianF1ZXJ5XFxcIl0sYSk6XFxcIm9iamVjdFxcXCI9PXR5cGVvZiBtb2R1bGUmJm1vZHVsZS5leHBvcnRzP21vZHVsZS5leHBvcnRzPWZ1bmN0aW9uKGIsYyl7cmV0dXJuIHZvaWQgMD09PWMmJihjPVxcXCJ1bmRlZmluZWRcXFwiIT10eXBlb2Ygd2luZG93P3JlcXVpcmUoXFxcImpxdWVyeVxcXCIpOnJlcXVpcmUoXFxcImpxdWVyeVxcXCIpKGIpKSxhKGMpfTphKHdpbmRvdy5qUXVlcnkpfShmdW5jdGlvbihhKXthLmV4dGVuZChhLkZFLlBPUFVQX1RFTVBMQVRFUyx7XFxcImxpbmsuZWRpdFxcXCI6XFxcIltfQlVUVE9OU19dXFxcIixcXFwibGluay5pbnNlcnRcXFwiOlxcXCJbX0JVVFRPTlNfXVtfSU5QVVRfTEFZRVJfXVxcXCJ9KSxhLmV4dGVuZChhLkZFLkRFRkFVTFRTLHtsaW5rRWRpdEJ1dHRvbnM6W1xcXCJsaW5rT3BlblxcXCIsXFxcImxpbmtTdHlsZVxcXCIsXFxcImxpbmtFZGl0XFxcIixcXFwibGlua1JlbW92ZVxcXCJdLGxpbmtJbnNlcnRCdXR0b25zOltcXFwibGlua0JhY2tcXFwiLFxcXCJ8XFxcIixcXFwibGlua0xpc3RcXFwiXSxsaW5rQXR0cmlidXRlczp7fSxsaW5rQXV0b1ByZWZpeDpcXFwiaHR0cDovL1xcXCIsbGlua1N0eWxlczp7XFxcImZyLWdyZWVuXFxcIjpcXFwiR3JlZW5cXFwiLFxcXCJmci1zdHJvbmdcXFwiOlxcXCJUaGlja1xcXCJ9LGxpbmtNdWx0aXBsZVN0eWxlczohMCxsaW5rQ29udmVydEVtYWlsQWRkcmVzczohMCxsaW5rQWx3YXlzQmxhbms6ITEsbGlua0Fsd2F5c05vRm9sbG93OiExLGxpbmtMaXN0Olt7dGV4dDpcXFwiRnJvYWxhXFxcIixocmVmOlxcXCJodHRwczovL2Zyb2FsYS5jb21cXFwiLHRhcmdldDpcXFwiX2JsYW5rXFxcIn0se3RleHQ6XFxcIkdvb2dsZVxcXCIsaHJlZjpcXFwiaHR0cHM6Ly9nb29nbGUuY29tXFxcIix0YXJnZXQ6XFxcIl9ibGFua1xcXCJ9LHtkaXNwbGF5VGV4dDpcXFwiRmFjZWJvb2tcXFwiLGhyZWY6XFxcImh0dHBzOi8vZmFjZWJvb2suY29tXFxcIn1dLGxpbmtUZXh0OiEwfSksYS5GRS5QTFVHSU5TLmxpbms9ZnVuY3Rpb24oYil7ZnVuY3Rpb24gYygpe3ZhciBjPWIuaW1hZ2U/Yi5pbWFnZS5nZXQoKTpudWxsO2lmKCFjJiZiLiR3cCl7dmFyIGQ9Yi5zZWxlY3Rpb24ucmFuZ2VzKDApLmNvbW1vbkFuY2VzdG9yQ29udGFpbmVyO2lmKGQmJihkLmNvbnRhaW5zJiZkLmNvbnRhaW5zKGIuZWwpfHwhYi5lbC5jb250YWlucyhkKXx8Yi5lbD09ZCkmJihkPW51bGwpLGQmJlxcXCJBXFxcIj09PWQudGFnTmFtZSlyZXR1cm4gZDt2YXIgZT1iLnNlbGVjdGlvbi5lbGVtZW50KCksZj1iLnNlbGVjdGlvbi5lbmRFbGVtZW50KCk7cmV0dXJuXFxcIkFcXFwiPT1lLnRhZ05hbWV8fGIubm9kZS5pc0VsZW1lbnQoZSl8fChlPWEoZSkucGFyZW50c1VudGlsKGIuJGVsLFxcXCJhOmZpcnN0XFxcIikuZ2V0KDApKSxcXFwiQVxcXCI9PWYudGFnTmFtZXx8Yi5ub2RlLmlzRWxlbWVudChmKXx8KGY9YShmKS5wYXJlbnRzVW50aWwoYi4kZWwsXFxcImE6Zmlyc3RcXFwiKS5nZXQoMCkpLGYmJihmLmNvbnRhaW5zJiZmLmNvbnRhaW5zKGIuZWwpfHwhYi5lbC5jb250YWlucyhmKXx8Yi5lbD09ZikmJihmPW51bGwpLGUmJihlLmNvbnRhaW5zJiZlLmNvbnRhaW5zKGIuZWwpfHwhYi5lbC5jb250YWlucyhlKXx8Yi5lbD09ZSkmJihlPW51bGwpLGYmJmY9PWUmJlxcXCJBXFxcIj09Zi50YWdOYW1lP2U6bnVsbH1yZXR1cm5cXFwiQVxcXCI9PWIuZWwudGFnTmFtZT9iLmVsOmMmJmMuZ2V0KDApLnBhcmVudE5vZGUmJlxcXCJBXFxcIj09Yy5nZXQoMCkucGFyZW50Tm9kZS50YWdOYW1lP2MuZ2V0KDApLnBhcmVudE5vZGU6dm9pZCAwfWZ1bmN0aW9uIGQoKXt2YXIgYT1iLmltYWdlP2IuaW1hZ2UuZ2V0KCk6bnVsbCxjPVtdO2lmKGEpXFxcIkFcXFwiPT1hLmdldCgwKS5wYXJlbnROb2RlLnRhZ05hbWUmJmMucHVzaChhLmdldCgwKS5wYXJlbnROb2RlKTtlbHNle3ZhciBkLGUsZixnO2lmKGIud2luLmdldFNlbGVjdGlvbil7dmFyIGg9Yi53aW4uZ2V0U2VsZWN0aW9uKCk7aWYoaC5nZXRSYW5nZUF0JiZoLnJhbmdlQ291bnQpe2c9Yi5kb2MuY3JlYXRlUmFuZ2UoKTtmb3IodmFyIGk9MDtpPGgucmFuZ2VDb3VudDsrK2kpaWYoZD1oLmdldFJhbmdlQXQoaSksZT1kLmNvbW1vbkFuY2VzdG9yQ29udGFpbmVyLGUmJjEhPWUubm9kZVR5cGUmJihlPWUucGFyZW50Tm9kZSksZSYmXFxcImFcXFwiPT1lLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkpYy5wdXNoKGUpO2Vsc2V7Zj1lLmdldEVsZW1lbnRzQnlUYWdOYW1lKFxcXCJhXFxcIik7Zm9yKHZhciBqPTA7ajxmLmxlbmd0aDsrK2opZy5zZWxlY3ROb2RlQ29udGVudHMoZltqXSksZy5jb21wYXJlQm91bmRhcnlQb2ludHMoZC5FTkRfVE9fU1RBUlQsZCk8MSYmZy5jb21wYXJlQm91bmRhcnlQb2ludHMoZC5TVEFSVF9UT19FTkQsZCk+LTEmJmMucHVzaChmW2pdKX19fWVsc2UgaWYoYi5kb2Muc2VsZWN0aW9uJiZcXFwiQ29udHJvbFxcXCIhPWIuZG9jLnNlbGVjdGlvbi50eXBlKWlmKGQ9Yi5kb2Muc2VsZWN0aW9uLmNyZWF0ZVJhbmdlKCksZT1kLnBhcmVudEVsZW1lbnQoKSxcXFwiYVxcXCI9PWUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSljLnB1c2goZSk7ZWxzZXtmPWUuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXFxcImFcXFwiKSxnPWIuZG9jLmJvZHkuY3JlYXRlVGV4dFJhbmdlKCk7Zm9yKHZhciBrPTA7azxmLmxlbmd0aDsrK2spZy5tb3ZlVG9FbGVtZW50VGV4dChmW2tdKSxnLmNvbXBhcmVFbmRQb2ludHMoXFxcIlN0YXJ0VG9FbmRcXFwiLGQpPi0xJiZnLmNvbXBhcmVFbmRQb2ludHMoXFxcIkVuZFRvU3RhcnRcXFwiLGQpPDEmJmMucHVzaChmW2tdKX19cmV0dXJuIGN9ZnVuY3Rpb24gZShkKXtnKCksc2V0VGltZW91dChmdW5jdGlvbigpe2lmKCFkfHxkJiYoMT09ZC53aGljaHx8XFxcIm1vdXNldXBcXFwiIT1kLnR5cGUpKXt2YXIgZT1jKCksZz1iLmltYWdlP2IuaW1hZ2UuZ2V0KCk6bnVsbDtpZihlJiYhZyl7aWYoYi5pbWFnZSl7dmFyIGg9Yi5ub2RlLmNvbnRlbnRzKGUpO2lmKDE9PWgubGVuZ3RoJiZcXFwiSU1HXFxcIj09aFswXS50YWdOYW1lKXt2YXIgaT1iLnNlbGVjdGlvbi5yYW5nZXMoMCk7cmV0dXJuIDA9PT1pLnN0YXJ0T2Zmc2V0JiYwPT09aS5lbmRPZmZzZXQ/YShlKS5iZWZvcmUoYS5GRS5NQVJLRVJTKTphKGUpLmFmdGVyKGEuRkUuTUFSS0VSUyksYi5zZWxlY3Rpb24ucmVzdG9yZSgpLCExfX1kJiZkLnN0b3BQcm9wYWdhdGlvbigpLGYoZSl9fX0sYi5oZWxwZXJzLmlzSU9TKCk/MTAwOjApfWZ1bmN0aW9uIGYoYyl7dmFyIGQ9Yi5wb3B1cHMuZ2V0KFxcXCJsaW5rLmVkaXRcXFwiKTtkfHwoZD1oKCkpO3ZhciBlPWEoYyk7Yi5wb3B1cHMuaXNWaXNpYmxlKFxcXCJsaW5rLmVkaXRcXFwiKXx8Yi5wb3B1cHMucmVmcmVzaChcXFwibGluay5lZGl0XFxcIiksYi5wb3B1cHMuc2V0Q29udGFpbmVyKFxcXCJsaW5rLmVkaXRcXFwiLGIuJHNjKTt2YXIgZj1lLm9mZnNldCgpLmxlZnQrYShjKS5vdXRlcldpZHRoKCkvMixnPWUub2Zmc2V0KCkudG9wK2Uub3V0ZXJIZWlnaHQoKTtiLnBvcHVwcy5zaG93KFxcXCJsaW5rLmVkaXRcXFwiLGYsZyxlLm91dGVySGVpZ2h0KCkpfWZ1bmN0aW9uIGcoKXtiLnBvcHVwcy5oaWRlKFxcXCJsaW5rLmVkaXRcXFwiKX1mdW5jdGlvbiBoKCl7dmFyIGE9XFxcIlxcXCI7Yi5vcHRzLmxpbmtFZGl0QnV0dG9ucy5sZW5ndGg+MSYmKFxcXCJBXFxcIj09Yi5lbC50YWdOYW1lJiZiLm9wdHMubGlua0VkaXRCdXR0b25zLmluZGV4T2YoXFxcImxpbmtSZW1vdmVcXFwiKT49MCYmYi5vcHRzLmxpbmtFZGl0QnV0dG9ucy5zcGxpY2UoYi5vcHRzLmxpbmtFZGl0QnV0dG9ucy5pbmRleE9mKFxcXCJsaW5rUmVtb3ZlXFxcIiksMSksYT0nPGRpdiBjbGFzcz1cXFwiZnItYnV0dG9uc1xcXCI+JytiLmJ1dHRvbi5idWlsZExpc3QoYi5vcHRzLmxpbmtFZGl0QnV0dG9ucykrXFxcIjwvZGl2PlxcXCIpO3ZhciBkPXtidXR0b25zOmF9LGU9Yi5wb3B1cHMuY3JlYXRlKFxcXCJsaW5rLmVkaXRcXFwiLGQpO3JldHVybiBiLiR3cCYmYi5ldmVudHMuJG9uKGIuJHdwLFxcXCJzY3JvbGwubGluay1lZGl0XFxcIixmdW5jdGlvbigpe2MoKSYmYi5wb3B1cHMuaXNWaXNpYmxlKFxcXCJsaW5rLmVkaXRcXFwiKSYmZihjKCkpfSksZX1mdW5jdGlvbiBpKCl7fWZ1bmN0aW9uIGooKXt2YXIgZD1iLnBvcHVwcy5nZXQoXFxcImxpbmsuaW5zZXJ0XFxcIiksZT1jKCk7aWYoZSl7dmFyIGYsZyxoPWEoZSksaT1kLmZpbmQoJ2lucHV0LmZyLWxpbmstYXR0clt0eXBlPVxcXCJ0ZXh0XFxcIl0nKSxqPWQuZmluZCgnaW5wdXQuZnItbGluay1hdHRyW3R5cGU9XFxcImNoZWNrYm94XFxcIl0nKTtmb3IoZj0wO2Y8aS5sZW5ndGg7ZisrKWc9YShpW2ZdKSxnLnZhbChoLmF0dHIoZy5hdHRyKFxcXCJuYW1lXFxcIil8fFxcXCJcXFwiKSk7Zm9yKGoucHJvcChcXFwiY2hlY2tlZFxcXCIsITEpLGY9MDtmPGoubGVuZ3RoO2YrKylnPWEoaltmXSksaC5hdHRyKGcuYXR0cihcXFwibmFtZVxcXCIpKT09Zy5kYXRhKFxcXCJjaGVja2VkXFxcIikmJmcucHJvcChcXFwiY2hlY2tlZFxcXCIsITApO2QuZmluZCgnaW5wdXQuZnItbGluay1hdHRyW3R5cGU9XFxcInRleHRcXFwiXVtuYW1lPVxcXCJ0ZXh0XFxcIl0nKS52YWwoaC50ZXh0KCkpfWVsc2UgZC5maW5kKCdpbnB1dC5mci1saW5rLWF0dHJbdHlwZT1cXFwidGV4dFxcXCJdJykudmFsKFxcXCJcXFwiKSxkLmZpbmQoJ2lucHV0LmZyLWxpbmstYXR0clt0eXBlPVxcXCJjaGVja2JveFxcXCJdJykucHJvcChcXFwiY2hlY2tlZFxcXCIsITEpLGQuZmluZCgnaW5wdXQuZnItbGluay1hdHRyW3R5cGU9XFxcInRleHRcXFwiXVtuYW1lPVxcXCJ0ZXh0XFxcIl0nKS52YWwoYi5zZWxlY3Rpb24udGV4dCgpKTtkLmZpbmQoXFxcImlucHV0LmZyLWxpbmstYXR0clxcXCIpLnRyaWdnZXIoXFxcImNoYW5nZVxcXCIpO3ZhciBrPWIuaW1hZ2U/Yi5pbWFnZS5nZXQoKTpudWxsO2s/ZC5maW5kKCcuZnItbGluay1hdHRyW25hbWU9XFxcInRleHRcXFwiXScpLnBhcmVudCgpLmhpZGUoKTpkLmZpbmQoJy5mci1saW5rLWF0dHJbbmFtZT1cXFwidGV4dFxcXCJdJykucGFyZW50KCkuc2hvdygpfWZ1bmN0aW9uIGsoKXt2YXIgYT1iLiR0Yi5maW5kKCcuZnItY29tbWFuZFtkYXRhLWNtZD1cXFwiaW5zZXJ0TGlua1xcXCJdJyksYz1iLnBvcHVwcy5nZXQoXFxcImxpbmsuaW5zZXJ0XFxcIik7aWYoY3x8KGM9bCgpKSwhYy5oYXNDbGFzcyhcXFwiZnItYWN0aXZlXFxcIikpaWYoYi5wb3B1cHMucmVmcmVzaChcXFwibGluay5pbnNlcnRcXFwiKSxiLnBvcHVwcy5zZXRDb250YWluZXIoXFxcImxpbmsuaW5zZXJ0XFxcIixiLiR0Ynx8Yi4kc2MpLGEuaXMoXFxcIjp2aXNpYmxlXFxcIikpe3ZhciBkPWEub2Zmc2V0KCkubGVmdCthLm91dGVyV2lkdGgoKS8yLGU9YS5vZmZzZXQoKS50b3ArKGIub3B0cy50b29sYmFyQm90dG9tPzEwOmEub3V0ZXJIZWlnaHQoKS0xMCk7Yi5wb3B1cHMuc2hvdyhcXFwibGluay5pbnNlcnRcXFwiLGQsZSxhLm91dGVySGVpZ2h0KCkpfWVsc2UgYi5wb3NpdGlvbi5mb3JTZWxlY3Rpb24oYyksYi5wb3B1cHMuc2hvdyhcXFwibGluay5pbnNlcnRcXFwiKX1mdW5jdGlvbiBsKGEpe2lmKGEpcmV0dXJuIGIucG9wdXBzLm9uUmVmcmVzaChcXFwibGluay5pbnNlcnRcXFwiLGopLGIucG9wdXBzLm9uSGlkZShcXFwibGluay5pbnNlcnRcXFwiLGkpLCEwO3ZhciBkPVxcXCJcXFwiO2Iub3B0cy5saW5rSW5zZXJ0QnV0dG9ucy5sZW5ndGg+PTEmJihkPSc8ZGl2IGNsYXNzPVxcXCJmci1idXR0b25zXFxcIj4nK2IuYnV0dG9uLmJ1aWxkTGlzdChiLm9wdHMubGlua0luc2VydEJ1dHRvbnMpK1xcXCI8L2Rpdj5cXFwiKTt2YXIgZT0nPHN2ZyB2ZXJzaW9uPVxcXCIxLjFcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCIgeG1sbnM6eGxpbms9XFxcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmtcXFwiIHdpZHRoPVxcXCIxMFxcXCIgaGVpZ2h0PVxcXCIxMFxcXCIgdmlld0JveD1cXFwiMCAwIDMyIDMyXFxcIj48cGF0aCBkPVxcXCJNMjcgNGwtMTUgMTUtNy03LTUgNSAxMiAxMiAyMC0yMHpcXFwiIGZpbGw9XFxcIiNGRkZcXFwiPjwvcGF0aD48L3N2Zz4nLGY9XFxcIlxcXCIsZz0wO2Y9JzxkaXYgY2xhc3M9XFxcImZyLWxpbmstaW5zZXJ0LWxheWVyIGZyLWxheWVyIGZyLWFjdGl2ZVxcXCIgaWQ9XFxcImZyLWxpbmstaW5zZXJ0LWxheWVyLScrYi5pZCsnXFxcIj4nLGYrPSc8ZGl2IGNsYXNzPVxcXCJmci1pbnB1dC1saW5lXFxcIj48aW5wdXQgaWQ9XFxcImZyLWxpbmstaW5zZXJ0LWxheWVyLXVybC0nK2IuaWQrJ1xcXCIgbmFtZT1cXFwiaHJlZlxcXCIgdHlwZT1cXFwidGV4dFxcXCIgY2xhc3M9XFxcImZyLWxpbmstYXR0clxcXCIgcGxhY2Vob2xkZXI9XFxcIlVSTFxcXCIgdGFiSW5kZXg9XFxcIicrICsrZysnXFxcIj48L2Rpdj4nLGIub3B0cy5saW5rVGV4dCYmKGYrPSc8ZGl2IGNsYXNzPVxcXCJmci1pbnB1dC1saW5lXFxcIj48aW5wdXQgaWQ9XFxcImZyLWxpbmstaW5zZXJ0LWxheWVyLXRleHQtJytiLmlkKydcXFwiIG5hbWU9XFxcInRleHRcXFwiIHR5cGU9XFxcInRleHRcXFwiIGNsYXNzPVxcXCJmci1saW5rLWF0dHJcXFwiIHBsYWNlaG9sZGVyPVxcXCInK2IubGFuZ3VhZ2UudHJhbnNsYXRlKFxcXCJUZXh0XFxcIikrJ1xcXCIgdGFiSW5kZXg9XFxcIicrICsrZysnXFxcIj48L2Rpdj4nKTtmb3IodmFyIGggaW4gYi5vcHRzLmxpbmtBdHRyaWJ1dGVzKWlmKGIub3B0cy5saW5rQXR0cmlidXRlcy5oYXNPd25Qcm9wZXJ0eShoKSl7dmFyIGs9Yi5vcHRzLmxpbmtBdHRyaWJ1dGVzW2hdO2YrPSc8ZGl2IGNsYXNzPVxcXCJmci1pbnB1dC1saW5lXFxcIj48aW5wdXQgbmFtZT1cXFwiJytoKydcXFwiIHR5cGU9XFxcInRleHRcXFwiIGNsYXNzPVxcXCJmci1saW5rLWF0dHJcXFwiIHBsYWNlaG9sZGVyPVxcXCInK2IubGFuZ3VhZ2UudHJhbnNsYXRlKGspKydcXFwiIHRhYkluZGV4PVxcXCInKyArK2crJ1xcXCI+PC9kaXY+J31iLm9wdHMubGlua0Fsd2F5c0JsYW5rfHwoZis9JzxkaXYgY2xhc3M9XFxcImZyLWNoZWNrYm94LWxpbmVcXFwiPjxzcGFuIGNsYXNzPVxcXCJmci1jaGVja2JveFxcXCI+PGlucHV0IG5hbWU9XFxcInRhcmdldFxcXCIgY2xhc3M9XFxcImZyLWxpbmstYXR0clxcXCIgZGF0YS1jaGVja2VkPVxcXCJfYmxhbmtcXFwiIHR5cGU9XFxcImNoZWNrYm94XFxcIiBpZD1cXFwiZnItbGluay10YXJnZXQtJytiLmlkKydcXFwiIHRhYkluZGV4PVxcXCInKyArK2crJ1xcXCI+PHNwYW4+JytlKyc8L3NwYW4+PC9zcGFuPjxsYWJlbCBmb3I9XFxcImZyLWxpbmstdGFyZ2V0LScrYi5pZCsnXFxcIj4nK2IubGFuZ3VhZ2UudHJhbnNsYXRlKFxcXCJPcGVuIGluIG5ldyB0YWJcXFwiKStcXFwiPC9sYWJlbD48L2Rpdj5cXFwiKSxmKz0nPGRpdiBjbGFzcz1cXFwiZnItYWN0aW9uLWJ1dHRvbnNcXFwiPjxidXR0b24gY2xhc3M9XFxcImZyLWNvbW1hbmQgZnItc3VibWl0XFxcIiByb2xlPVxcXCJidXR0b25cXFwiIGRhdGEtY21kPVxcXCJsaW5rSW5zZXJ0XFxcIiBocmVmPVxcXCIjXFxcIiB0YWJJbmRleD1cXFwiJysgKytnKydcXFwiIHR5cGU9XFxcImJ1dHRvblxcXCI+JytiLmxhbmd1YWdlLnRyYW5zbGF0ZShcXFwiSW5zZXJ0XFxcIikrXFxcIjwvYnV0dG9uPjwvZGl2PjwvZGl2PlxcXCI7dmFyIGw9e2J1dHRvbnM6ZCxpbnB1dF9sYXllcjpmfSxtPWIucG9wdXBzLmNyZWF0ZShcXFwibGluay5pbnNlcnRcXFwiLGwpO3JldHVybiBiLiR3cCYmYi5ldmVudHMuJG9uKGIuJHdwLFxcXCJzY3JvbGwubGluay1pbnNlcnRcXFwiLGZ1bmN0aW9uKCl7dmFyIGE9Yi5pbWFnZT9iLmltYWdlLmdldCgpOm51bGw7YSYmYi5wb3B1cHMuaXNWaXNpYmxlKFxcXCJsaW5rLmluc2VydFxcXCIpJiZ1KCksYyYmYi5wb3B1cHMuaXNWaXNpYmxlKFxcXCJsaW5rLmluc2VydFxcXCIpJiZzKCl9KSxtfWZ1bmN0aW9uIG0oKXt2YXIgZD1jKCksZT1iLmltYWdlP2IuaW1hZ2UuZ2V0KCk6bnVsbDtyZXR1cm4gYi5ldmVudHMudHJpZ2dlcihcXFwibGluay5iZWZvcmVSZW1vdmVcXFwiLFtkXSkhPT0hMSYmdm9pZChlJiZkPyhlLnVud3JhcCgpLGIuaW1hZ2UuZWRpdChlKSk6ZCYmKGIuc2VsZWN0aW9uLnNhdmUoKSxhKGQpLnJlcGxhY2VXaXRoKGEoZCkuaHRtbCgpKSxiLnNlbGVjdGlvbi5yZXN0b3JlKCksZygpKSl9ZnVuY3Rpb24gbigpe2IuZXZlbnRzLm9uKFxcXCJrZXl1cFxcXCIsZnVuY3Rpb24oYil7Yi53aGljaCE9YS5GRS5LRVlDT0RFLkVTQyYmZShiKX0pLGIuZXZlbnRzLm9uKFxcXCJ3aW5kb3cubW91c2V1cFxcXCIsZSksYi5oZWxwZXJzLmlzTW9iaWxlKCkmJmIuZXZlbnRzLiRvbihiLiRkb2MsXFxcInNlbGVjdGlvbmNoYW5nZVxcXCIsZSksbCghMCksXFxcIkFcXFwiPT1iLmVsLnRhZ05hbWUmJmIuJGVsLmFkZENsYXNzKFxcXCJmci12aWV3XFxcIiksYi5ldmVudHMub24oXFxcInRvb2xiYXIuZXNjXFxcIixmdW5jdGlvbigpe2lmKGIucG9wdXBzLmlzVmlzaWJsZShcXFwibGluay5lZGl0XFxcIikpcmV0dXJuIGIuZXZlbnRzLmRpc2FibGVCbHVyKCksYi5ldmVudHMuZm9jdXMoKSwhMX0sITApfWZ1bmN0aW9uIG8oYyl7dmFyIGQsZSxmPWIub3B0cy5saW5rTGlzdFtjXSxnPWIucG9wdXBzLmdldChcXFwibGluay5pbnNlcnRcXFwiKSxoPWcuZmluZCgnaW5wdXQuZnItbGluay1hdHRyW3R5cGU9XFxcInRleHRcXFwiXScpLGk9Zy5maW5kKCdpbnB1dC5mci1saW5rLWF0dHJbdHlwZT1cXFwiY2hlY2tib3hcXFwiXScpO2ZvcihlPTA7ZTxoLmxlbmd0aDtlKyspZD1hKGhbZV0pLGZbZC5hdHRyKFxcXCJuYW1lXFxcIildP2QudmFsKGZbZC5hdHRyKFxcXCJuYW1lXFxcIildKTpcXFwidGV4dFxcXCIhPWQuYXR0cihcXFwibmFtZVxcXCIpJiZkLnZhbChcXFwiXFxcIik7Zm9yKGU9MDtlPGkubGVuZ3RoO2UrKylkPWEoaVtlXSksZC5wcm9wKFxcXCJjaGVja2VkXFxcIixkLmRhdGEoXFxcImNoZWNrZWRcXFwiKT09ZltkLmF0dHIoXFxcIm5hbWVcXFwiKV0pO2IuYWNjZXNzaWJpbGl0eS5mb2N1c1BvcHVwKGcpfWZ1bmN0aW9uIHAoKXt2YXIgYyxkLGU9Yi5wb3B1cHMuZ2V0KFxcXCJsaW5rLmluc2VydFxcXCIpLGY9ZS5maW5kKCdpbnB1dC5mci1saW5rLWF0dHJbdHlwZT1cXFwidGV4dFxcXCJdJyksZz1lLmZpbmQoJ2lucHV0LmZyLWxpbmstYXR0clt0eXBlPVxcXCJjaGVja2JveFxcXCJdJyksaD1mLmZpbHRlcignW25hbWU9XFxcImhyZWZcXFwiXScpLnZhbCgpLGk9Zi5maWx0ZXIoJ1tuYW1lPVxcXCJ0ZXh0XFxcIl0nKS52YWwoKSxqPXt9O2ZvcihkPTA7ZDxmLmxlbmd0aDtkKyspYz1hKGZbZF0pLFtcXFwiaHJlZlxcXCIsXFxcInRleHRcXFwiXS5pbmRleE9mKGMuYXR0cihcXFwibmFtZVxcXCIpKTwwJiYoaltjLmF0dHIoXFxcIm5hbWVcXFwiKV09Yy52YWwoKSk7Zm9yKGQ9MDtkPGcubGVuZ3RoO2QrKyljPWEoZ1tkXSksYy5pcyhcXFwiOmNoZWNrZWRcXFwiKT9qW2MuYXR0cihcXFwibmFtZVxcXCIpXT1jLmRhdGEoXFxcImNoZWNrZWRcXFwiKTpqW2MuYXR0cihcXFwibmFtZVxcXCIpXT1jLmRhdGEoXFxcInVuY2hlY2tlZFxcXCIpfHxudWxsO3ZhciBrPWIuaGVscGVycy5zY3JvbGxUb3AoKTtyKGgsaSxqKSxhKGIub193aW4pLnNjcm9sbFRvcChrKX1mdW5jdGlvbiBxKCl7aWYoIWIuc2VsZWN0aW9uLmlzQ29sbGFwc2VkKCkpe2Iuc2VsZWN0aW9uLnNhdmUoKTtmb3IodmFyIGM9Yi4kZWwuZmluZChcXFwiLmZyLW1hcmtlclxcXCIpLmFkZENsYXNzKFxcXCJmci11bnByb2Nlc3NlZFxcXCIpLnRvQXJyYXkoKTtjLmxlbmd0aDspe3ZhciBkPWEoYy5wb3AoKSk7ZC5yZW1vdmVDbGFzcyhcXFwiZnItdW5wcm9jZXNzZWRcXFwiKTt2YXIgZT1iLm5vZGUuZGVlcGVzdFBhcmVudChkLmdldCgwKSk7aWYoZSl7dmFyIGY9ZC5nZXQoMCksZz1cXFwiXFxcIixoPVxcXCJcXFwiO2RvIGY9Zi5wYXJlbnROb2RlLGIubm9kZS5pc0Jsb2NrKGYpfHwoZys9Yi5ub2RlLmNsb3NlVGFnU3RyaW5nKGYpLGg9Yi5ub2RlLm9wZW5UYWdTdHJpbmcoZikraCk7d2hpbGUoZiE9ZSk7dmFyIGk9Yi5ub2RlLm9wZW5UYWdTdHJpbmcoZC5nZXQoMCkpK2QuaHRtbCgpK2Iubm9kZS5jbG9zZVRhZ1N0cmluZyhkLmdldCgwKSk7ZC5yZXBsYWNlV2l0aCgnPHNwYW4gaWQ9XFxcImZyLWJyZWFrXFxcIj48L3NwYW4+Jyk7dmFyIGo9YShlKS5odG1sKCk7aj1qLnJlcGxhY2UoLzxzcGFuIGlkPVxcXCJmci1icmVha1xcXCI+PFxcXFwvc3Bhbj4vZyxnK2kraCksYShlKS5odG1sKGopfWM9Yi4kZWwuZmluZChcXFwiLmZyLW1hcmtlci5mci11bnByb2Nlc3NlZFxcXCIpLnRvQXJyYXkoKX1iLnNlbGVjdGlvbi5yZXN0b3JlKCl9fWZ1bmN0aW9uIHIoZixnLGgpe2lmKFxcXCJ1bmRlZmluZWRcXFwiPT10eXBlb2YgaCYmKGg9e30pLGIuZXZlbnRzLnRyaWdnZXIoXFxcImxpbmsuYmVmb3JlSW5zZXJ0XFxcIixbZixnLGhdKT09PSExKXJldHVybiExO3ZhciBpPWIuaW1hZ2U/Yi5pbWFnZS5nZXQoKTpudWxsO2l8fFxcXCJBXFxcIj09Yi5lbC50YWdOYW1lP1xcXCJBXFxcIj09Yi5lbC50YWdOYW1lJiZiLiRlbC5mb2N1cygpOihiLnNlbGVjdGlvbi5yZXN0b3JlKCksYi5wb3B1cHMuaGlkZShcXFwibGluay5pbnNlcnRcXFwiKSk7dmFyIGo9ZjtpZihiLm9wdHMubGlua0NvbnZlcnRFbWFpbEFkZHJlc3Mpe3ZhciBrPS9eW1xcXFx3Ll9dK0BbYS16XFxcXHUwMGExLVxcXFx1ZmZmZjAtOV8tXSs/XFxcXC5bYS16XFxcXHUwMGExLVxcXFx1ZmZmZjAtOV17Mix9JC9pO2sudGVzdChmKSYmIS9ebWFpbHRvOi4qL2kudGVzdChmKSYmKGY9XFxcIm1haWx0bzpcXFwiK2YpfWlmKFxcXCJcXFwiPT09Yi5vcHRzLmxpbmtBdXRvUHJlZml4fHwvXihtYWlsdG98dGVsfHNtc3xub3Rlc3xkYXRhKTouKi9pLnRlc3QoZil8fC9eZGF0YTppbWFnZS4qL2kudGVzdChmKXx8L14oaHR0cHM/OnxmdHBzPzp8ZmlsZTp8KVxcXFwvXFxcXC8vaS50ZXN0KGYpfHxbXFxcIi9cXFwiLFxcXCJ7XFxcIixcXFwiW1xcXCIsXFxcIiNcXFwiLFxcXCIoXFxcIl0uaW5kZXhPZigoZnx8XFxcIlxcXCIpWzBdKTwwJiYoZj1iLm9wdHMubGlua0F1dG9QcmVmaXgrZiksZj1iLmhlbHBlcnMuc2FuaXRpemVVUkwoZiksYi5vcHRzLmxpbmtBbHdheXNCbGFuayYmKGgudGFyZ2V0PVxcXCJfYmxhbmtcXFwiKSxiLm9wdHMubGlua0Fsd2F5c05vRm9sbG93JiYoaC5yZWw9XFxcIm5vZm9sbG93XFxcIiksXFxcIl9ibGFua1xcXCI9PWgudGFyZ2V0JiYoaC5yZWw/aC5yZWwrPVxcXCIgbm9vcGVuZXIgbm9yZWZlcnJlclxcXCI6aC5yZWw9XFxcIm5vb3BlbmVyIG5vcmVmZXJyZXJcXFwiKSxnPWd8fFxcXCJcXFwiLGY9PT1iLm9wdHMubGlua0F1dG9QcmVmaXgpe3ZhciBsPWIucG9wdXBzLmdldChcXFwibGluay5pbnNlcnRcXFwiKTtyZXR1cm4gbC5maW5kKCdpbnB1dFtuYW1lPVxcXCJocmVmXFxcIl0nKS5hZGRDbGFzcyhcXFwiZnItZXJyb3JcXFwiKSxiLmV2ZW50cy50cmlnZ2VyKFxcXCJsaW5rLmJhZFxcXCIsW2pdKSwhMX12YXIgbSxuPWMoKTtpZihuKW09YShuKSxtLmF0dHIoXFxcImhyZWZcXFwiLGYpLGcubGVuZ3RoPjAmJm0udGV4dCgpIT1nJiYhaSYmbS50ZXh0KGcpLGl8fG0ucHJlcGVuZChhLkZFLlNUQVJUX01BUktFUikuYXBwZW5kKGEuRkUuRU5EX01BUktFUiksbS5hdHRyKGgpLGl8fGIuc2VsZWN0aW9uLnJlc3RvcmUoKTtlbHNle2k/aS53cmFwKCc8YSBocmVmPVxcXCInK2YrJ1xcXCI+PC9hPicpOihiLmZvcm1hdC5yZW1vdmUoXFxcImFcXFwiKSxiLnNlbGVjdGlvbi5pc0NvbGxhcHNlZCgpPyhnPTA9PT1nLmxlbmd0aD9qOmcsYi5odG1sLmluc2VydCgnPGEgaHJlZj1cXFwiJytmKydcXFwiPicrYS5GRS5TVEFSVF9NQVJLRVIrZythLkZFLkVORF9NQVJLRVIrXFxcIjwvYT5cXFwiKSxiLnNlbGVjdGlvbi5yZXN0b3JlKCkpOmcubGVuZ3RoPjAmJmchPWIuc2VsZWN0aW9uLnRleHQoKS5yZXBsYWNlKC9cXFxcbi9nLFxcXCJcXFwiKT8oYi5zZWxlY3Rpb24ucmVtb3ZlKCksYi5odG1sLmluc2VydCgnPGEgaHJlZj1cXFwiJytmKydcXFwiPicrYS5GRS5TVEFSVF9NQVJLRVIrZythLkZFLkVORF9NQVJLRVIrXFxcIjwvYT5cXFwiKSxiLnNlbGVjdGlvbi5yZXN0b3JlKCkpOihxKCksYi5mb3JtYXQuYXBwbHkoXFxcImFcXFwiLHtocmVmOmZ9KSkpO2Zvcih2YXIgbz1kKCkscD0wO3A8by5sZW5ndGg7cCsrKW09YShvW3BdKSxtLmF0dHIoaCksbS5yZW1vdmVBdHRyKFxcXCJfbW96X2RpcnR5XFxcIik7MT09by5sZW5ndGgmJmIuJHdwJiYhaSYmKGEob1swXSkucHJlcGVuZChhLkZFLlNUQVJUX01BUktFUikuYXBwZW5kKGEuRkUuRU5EX01BUktFUiksYi5zZWxlY3Rpb24ucmVzdG9yZSgpKX1pZihpKXt2YXIgcj1iLnBvcHVwcy5nZXQoXFxcImxpbmsuaW5zZXJ0XFxcIik7ci5maW5kKFxcXCJpbnB1dDpmb2N1c1xcXCIpLmJsdXIoKSxiLmltYWdlLmVkaXQoaSl9ZWxzZSBlKCl9ZnVuY3Rpb24gcygpe2coKTt2YXIgZD1jKCk7aWYoZCl7dmFyIGU9Yi5wb3B1cHMuZ2V0KFxcXCJsaW5rLmluc2VydFxcXCIpO2V8fChlPWwoKSksYi5wb3B1cHMuaXNWaXNpYmxlKFxcXCJsaW5rLmluc2VydFxcXCIpfHwoYi5wb3B1cHMucmVmcmVzaChcXFwibGluay5pbnNlcnRcXFwiKSxiLnNlbGVjdGlvbi5zYXZlKCksYi5oZWxwZXJzLmlzTW9iaWxlKCkmJihiLmV2ZW50cy5kaXNhYmxlQmx1cigpLGIuJGVsLmJsdXIoKSxiLmV2ZW50cy5lbmFibGVCbHVyKCkpKSxiLnBvcHVwcy5zZXRDb250YWluZXIoXFxcImxpbmsuaW5zZXJ0XFxcIixiLiRzYyk7dmFyIGY9KGIuaW1hZ2U/Yi5pbWFnZS5nZXQoKTpudWxsKXx8YShkKSxoPWYub2Zmc2V0KCkubGVmdCtmLm91dGVyV2lkdGgoKS8yLGk9Zi5vZmZzZXQoKS50b3ArZi5vdXRlckhlaWdodCgpO2IucG9wdXBzLnNob3coXFxcImxpbmsuaW5zZXJ0XFxcIixoLGksZi5vdXRlckhlaWdodCgpKX19ZnVuY3Rpb24gdCgpe3ZhciBhPWIuaW1hZ2U/Yi5pbWFnZS5nZXQoKTpudWxsO2lmKGEpYi5pbWFnZS5iYWNrKCk7ZWxzZXtiLmV2ZW50cy5kaXNhYmxlQmx1cigpLGIuc2VsZWN0aW9uLnJlc3RvcmUoKSxiLmV2ZW50cy5lbmFibGVCbHVyKCk7dmFyIGQ9YygpO2QmJmIuJHdwPyhiLnNlbGVjdGlvbi5yZXN0b3JlKCksZygpLGUoKSk6XFxcIkFcXFwiPT1iLmVsLnRhZ05hbWU/KGIuJGVsLmZvY3VzKCksZSgpKTooYi5wb3B1cHMuaGlkZShcXFwibGluay5pbnNlcnRcXFwiKSxiLnRvb2xiYXIuc2hvd0lubGluZSgpKX19ZnVuY3Rpb24gdSgpe3ZhciBhPWIuaW1hZ2U/Yi5pbWFnZS5nZXQoKTpudWxsO2lmKGEpe3ZhciBjPWIucG9wdXBzLmdldChcXFwibGluay5pbnNlcnRcXFwiKTtjfHwoYz1sKCkpLGooITApLGIucG9wdXBzLnNldENvbnRhaW5lcihcXFwibGluay5pbnNlcnRcXFwiLGIuJHNjKTt2YXIgZD1hLm9mZnNldCgpLmxlZnQrYS5vdXRlcldpZHRoKCkvMixlPWEub2Zmc2V0KCkudG9wK2Eub3V0ZXJIZWlnaHQoKTtiLnBvcHVwcy5zaG93KFxcXCJsaW5rLmluc2VydFxcXCIsZCxlLGEub3V0ZXJIZWlnaHQoKSl9fWZ1bmN0aW9uIHYoZCxmLGcpe1xcXCJ1bmRlZmluZWRcXFwiPT10eXBlb2YgZyYmKGc9Yi5vcHRzLmxpbmtNdWx0aXBsZVN0eWxlcyksXFxcInVuZGVmaW5lZFxcXCI9PXR5cGVvZiBmJiYoZj1iLm9wdHMubGlua1N0eWxlcyk7dmFyIGg9YygpO2lmKCFoKXJldHVybiExO2lmKCFnKXt2YXIgaT1PYmplY3Qua2V5cyhmKTtpLnNwbGljZShpLmluZGV4T2YoZCksMSksYShoKS5yZW1vdmVDbGFzcyhpLmpvaW4oXFxcIiBcXFwiKSl9YShoKS50b2dnbGVDbGFzcyhkKSxlKCl9cmV0dXJue19pbml0Om4scmVtb3ZlOm0sc2hvd0luc2VydFBvcHVwOmssdXNlUHJlZGVmaW5lZDpvLGluc2VydENhbGxiYWNrOnAsaW5zZXJ0OnIsdXBkYXRlOnMsZ2V0OmMsYWxsU2VsZWN0ZWQ6ZCxiYWNrOnQsaW1hZ2VMaW5rOnUsYXBwbHlTdHlsZTp2fX0sYS5GRS5EZWZpbmVJY29uKFxcXCJpbnNlcnRMaW5rXFxcIix7TkFNRTpcXFwibGlua1xcXCJ9KSxhLkZFLlJlZ2lzdGVyU2hvcnRjdXQoYS5GRS5LRVlDT0RFLkssXFxcImluc2VydExpbmtcXFwiLG51bGwsXFxcIktcXFwiKSxhLkZFLlJlZ2lzdGVyQ29tbWFuZChcXFwiaW5zZXJ0TGlua1xcXCIse3RpdGxlOlxcXCJJbnNlcnQgTGlua1xcXCIsdW5kbzohMSxmb2N1czohMCxyZWZyZXNoT25DYWxsYmFjazohMSxwb3B1cDohMCxjYWxsYmFjazpmdW5jdGlvbigpe3RoaXMucG9wdXBzLmlzVmlzaWJsZShcXFwibGluay5pbnNlcnRcXFwiKT8odGhpcy4kZWwuZmluZChcXFwiLmZyLW1hcmtlclxcXCIpLmxlbmd0aCYmKHRoaXMuZXZlbnRzLmRpc2FibGVCbHVyKCksdGhpcy5zZWxlY3Rpb24ucmVzdG9yZSgpKSx0aGlzLnBvcHVwcy5oaWRlKFxcXCJsaW5rLmluc2VydFxcXCIpKTp0aGlzLmxpbmsuc2hvd0luc2VydFBvcHVwKCl9LHBsdWdpbjpcXFwibGlua1xcXCJ9KSxhLkZFLkRlZmluZUljb24oXFxcImxpbmtPcGVuXFxcIix7TkFNRTpcXFwiZXh0ZXJuYWwtbGlua1xcXCJ9KSxhLkZFLlJlZ2lzdGVyQ29tbWFuZChcXFwibGlua09wZW5cXFwiLHt0aXRsZTpcXFwiT3BlbiBMaW5rXFxcIix1bmRvOiExLHJlZnJlc2g6ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5saW5rLmdldCgpO2I/YS5yZW1vdmVDbGFzcyhcXFwiZnItaGlkZGVuXFxcIik6YS5hZGRDbGFzcyhcXFwiZnItaGlkZGVuXFxcIil9LGNhbGxiYWNrOmZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5saW5rLmdldCgpO2EmJnRoaXMub193aW4ub3BlbihhLmhyZWYpfX0pLGEuRkUuRGVmaW5lSWNvbihcXFwibGlua0VkaXRcXFwiLHtOQU1FOlxcXCJlZGl0XFxcIn0pLGEuRkUuUmVnaXN0ZXJDb21tYW5kKFxcXCJsaW5rRWRpdFxcXCIse3RpdGxlOlxcXCJFZGl0IExpbmtcXFwiLHVuZG86ITEscmVmcmVzaEFmdGVyQ2FsbGJhY2s6ITEscG9wdXA6ITAsY2FsbGJhY2s6ZnVuY3Rpb24oKXt0aGlzLmxpbmsudXBkYXRlKCl9LHJlZnJlc2g6ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5saW5rLmdldCgpO2I/YS5yZW1vdmVDbGFzcyhcXFwiZnItaGlkZGVuXFxcIik6YS5hZGRDbGFzcyhcXFwiZnItaGlkZGVuXFxcIil9fSksYS5GRS5EZWZpbmVJY29uKFxcXCJsaW5rUmVtb3ZlXFxcIix7TkFNRTpcXFwidW5saW5rXFxcIn0pLGEuRkUuUmVnaXN0ZXJDb21tYW5kKFxcXCJsaW5rUmVtb3ZlXFxcIix7dGl0bGU6XFxcIlVubGlua1xcXCIsY2FsbGJhY2s6ZnVuY3Rpb24oKXt0aGlzLmxpbmsucmVtb3ZlKCl9LHJlZnJlc2g6ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5saW5rLmdldCgpO2I/YS5yZW1vdmVDbGFzcyhcXFwiZnItaGlkZGVuXFxcIik6YS5hZGRDbGFzcyhcXFwiZnItaGlkZGVuXFxcIil9fSksYS5GRS5EZWZpbmVJY29uKFxcXCJsaW5rQmFja1xcXCIse05BTUU6XFxcImFycm93LWxlZnRcXFwifSksYS5GRS5SZWdpc3RlckNvbW1hbmQoXFxcImxpbmtCYWNrXFxcIix7dGl0bGU6XFxcIkJhY2tcXFwiLHVuZG86ITEsZm9jdXM6ITEsYmFjazohMCxyZWZyZXNoQWZ0ZXJDYWxsYmFjazohMSxjYWxsYmFjazpmdW5jdGlvbigpe3RoaXMubGluay5iYWNrKCl9LHJlZnJlc2g6ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5saW5rLmdldCgpJiZ0aGlzLmRvYy5oYXNGb2N1cygpLGM9dGhpcy5pbWFnZT90aGlzLmltYWdlLmdldCgpOm51bGw7Y3x8Ynx8dGhpcy5vcHRzLnRvb2xiYXJJbmxpbmU/KGEucmVtb3ZlQ2xhc3MoXFxcImZyLWhpZGRlblxcXCIpLGEubmV4dChcXFwiLmZyLXNlcGFyYXRvclxcXCIpLnJlbW92ZUNsYXNzKFxcXCJmci1oaWRkZW5cXFwiKSk6KGEuYWRkQ2xhc3MoXFxcImZyLWhpZGRlblxcXCIpLGEubmV4dChcXFwiLmZyLXNlcGFyYXRvclxcXCIpLmFkZENsYXNzKFxcXCJmci1oaWRkZW5cXFwiKSl9fSksYS5GRS5EZWZpbmVJY29uKFxcXCJsaW5rTGlzdFxcXCIse05BTUU6XFxcInNlYXJjaFxcXCJ9KSxhLkZFLlJlZ2lzdGVyQ29tbWFuZChcXFwibGlua0xpc3RcXFwiLHt0aXRsZTpcXFwiQ2hvb3NlIExpbmtcXFwiLHR5cGU6XFxcImRyb3Bkb3duXFxcIixmb2N1czohMSx1bmRvOiExLHJlZnJlc2hBZnRlckNhbGxiYWNrOiExLGh0bWw6ZnVuY3Rpb24oKXtmb3IodmFyIGE9Jzx1bCBjbGFzcz1cXFwiZnItZHJvcGRvd24tbGlzdFxcXCIgcm9sZT1cXFwicHJlc2VudGF0aW9uXFxcIj4nLGI9dGhpcy5vcHRzLmxpbmtMaXN0LGM9MDtjPGIubGVuZ3RoO2MrKylhKz0nPGxpIHJvbGU9XFxcInByZXNlbnRhdGlvblxcXCI+PGEgY2xhc3M9XFxcImZyLWNvbW1hbmRcXFwiIHRhYkluZGV4PVxcXCItMVxcXCIgcm9sZT1cXFwib3B0aW9uXFxcIiBkYXRhLWNtZD1cXFwibGlua0xpc3RcXFwiIGRhdGEtcGFyYW0xPVxcXCInK2MrJ1xcXCI+JysoYltjXS5kaXNwbGF5VGV4dHx8YltjXS50ZXh0KStcXFwiPC9hPjwvbGk+XFxcIjtyZXR1cm4gYSs9XFxcIjwvdWw+XFxcIn0sY2FsbGJhY2s6ZnVuY3Rpb24oYSxiKXt0aGlzLmxpbmsudXNlUHJlZGVmaW5lZChiKX19KSxhLkZFLlJlZ2lzdGVyQ29tbWFuZChcXFwibGlua0luc2VydFxcXCIse2ZvY3VzOiExLHJlZnJlc2hBZnRlckNhbGxiYWNrOiExLGNhbGxiYWNrOmZ1bmN0aW9uKCl7dGhpcy5saW5rLmluc2VydENhbGxiYWNrKCl9LHJlZnJlc2g6ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5saW5rLmdldCgpO2I/YS50ZXh0KHRoaXMubGFuZ3VhZ2UudHJhbnNsYXRlKFxcXCJVcGRhdGVcXFwiKSk6YS50ZXh0KHRoaXMubGFuZ3VhZ2UudHJhbnNsYXRlKFxcXCJJbnNlcnRcXFwiKSl9fSksYS5GRS5EZWZpbmVJY29uKFxcXCJpbWFnZUxpbmtcXFwiLHtOQU1FOlxcXCJsaW5rXFxcIn0pLGEuRkUuUmVnaXN0ZXJDb21tYW5kKFxcXCJpbWFnZUxpbmtcXFwiLHt0aXRsZTpcXFwiSW5zZXJ0IExpbmtcXFwiLHVuZG86ITEsZm9jdXM6ITEscG9wdXA6ITAsY2FsbGJhY2s6ZnVuY3Rpb24oKXt0aGlzLmxpbmsuaW1hZ2VMaW5rKCl9LHJlZnJlc2g6ZnVuY3Rpb24oYSl7dmFyIGIsYz10aGlzLmxpbmsuZ2V0KCk7Yz8oYj1hLnByZXYoKSxiLmhhc0NsYXNzKFxcXCJmci1zZXBhcmF0b3JcXFwiKSYmYi5yZW1vdmVDbGFzcyhcXFwiZnItaGlkZGVuXFxcIiksYS5hZGRDbGFzcyhcXFwiZnItaGlkZGVuXFxcIikpOihiPWEucHJldigpLGIuaGFzQ2xhc3MoXFxcImZyLXNlcGFyYXRvclxcXCIpJiZiLmFkZENsYXNzKFxcXCJmci1oaWRkZW5cXFwiKSxhLnJlbW92ZUNsYXNzKFxcXCJmci1oaWRkZW5cXFwiKSl9fSksYS5GRS5EZWZpbmVJY29uKFxcXCJsaW5rU3R5bGVcXFwiLHtOQU1FOlxcXCJtYWdpY1xcXCJ9KSxhLkZFLlJlZ2lzdGVyQ29tbWFuZChcXFwibGlua1N0eWxlXFxcIix7dGl0bGU6XFxcIlN0eWxlXFxcIix0eXBlOlxcXCJkcm9wZG93blxcXCIsaHRtbDpmdW5jdGlvbigpe3ZhciBhPSc8dWwgY2xhc3M9XFxcImZyLWRyb3Bkb3duLWxpc3RcXFwiIHJvbGU9XFxcInByZXNlbnRhdGlvblxcXCI+JyxiPXRoaXMub3B0cy5saW5rU3R5bGVzO2Zvcih2YXIgYyBpbiBiKWIuaGFzT3duUHJvcGVydHkoYykmJihhKz0nPGxpIHJvbGU9XFxcInByZXNlbnRhdGlvblxcXCI+PGEgY2xhc3M9XFxcImZyLWNvbW1hbmRcXFwiIHRhYkluZGV4PVxcXCItMVxcXCIgcm9sZT1cXFwib3B0aW9uXFxcIiBkYXRhLWNtZD1cXFwibGlua1N0eWxlXFxcIiBkYXRhLXBhcmFtMT1cXFwiJytjKydcXFwiPicrdGhpcy5sYW5ndWFnZS50cmFuc2xhdGUoYltjXSkrXFxcIjwvYT48L2xpPlxcXCIpO3JldHVybiBhKz1cXFwiPC91bD5cXFwifSxjYWxsYmFjazpmdW5jdGlvbihhLGIpe3RoaXMubGluay5hcHBseVN0eWxlKGIpfSxyZWZyZXNoT25TaG93OmZ1bmN0aW9uKGIsYyl7dmFyIGQ9dGhpcy5saW5rLmdldCgpO2lmKGQpe3ZhciBlPWEoZCk7Yy5maW5kKFxcXCIuZnItY29tbWFuZFxcXCIpLmVhY2goZnVuY3Rpb24oKXt2YXIgYj1hKHRoaXMpLmRhdGEoXFxcInBhcmFtMVxcXCIpLGM9ZS5oYXNDbGFzcyhiKTthKHRoaXMpLnRvZ2dsZUNsYXNzKFxcXCJmci1hY3RpdmVcXFwiLGMpLmF0dHIoXFxcImFyaWEtc2VsZWN0ZWRcXFwiLGMpfSl9fX0pfSk7XCJcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcmF3LWxvYWRlciEuL34vZnJvYWxhLWVkaXRvci9qcy9wbHVnaW5zL2xpbmsubWluLmpzXG4vLyBtb2R1bGUgaWQgPSAxN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

	eval("__webpack_require__(2)(__webpack_require__(19))//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTguanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2Zyb2FsYS1lZGl0b3IvanMvcGx1Z2lucy91cmwubWluLmpzPzY2NWYiXSwic291cmNlc0NvbnRlbnQiOlsicmVxdWlyZShcIiEhL1VzZXJzL2pha3ViZmFqa3VzL0RvY3VtZW50cy9wcmFjZS92ZW5pY2UtZGVtby93ZWIvanMvbm9kZV9tb2R1bGVzL3NjcmlwdC1sb2FkZXIvYWRkU2NyaXB0LmpzXCIpKHJlcXVpcmUoXCIhIS9Vc2Vycy9qYWt1YmZhamt1cy9Eb2N1bWVudHMvcHJhY2UvdmVuaWNlLWRlbW8vd2ViL2pzL25vZGVfbW9kdWxlcy9yYXctbG9hZGVyL2luZGV4LmpzIS9Vc2Vycy9qYWt1YmZhamt1cy9Eb2N1bWVudHMvcHJhY2UvdmVuaWNlLWRlbW8vd2ViL2pzL25vZGVfbW9kdWxlcy9mcm9hbGEtZWRpdG9yL2pzL3BsdWdpbnMvdXJsLm1pbi5qc1wiKSlcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vc2NyaXB0LWxvYWRlciEuL34vZnJvYWxhLWVkaXRvci9qcy9wbHVnaW5zL3VybC5taW4uanNcbi8vIG1vZHVsZSBpZCA9IDE4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 19 */
/***/ function(module, exports) {

	eval("module.exports = \"/*!\\n * froala_editor v2.5.0 (https://www.froala.com/wysiwyg-editor)\\n * License https://froala.com/wysiwyg-editor/terms/\\n * Copyright 2014-2017 Froala Labs\\n */\\n\\n!function(a){\\\"function\\\"==typeof define&&define.amd?define([\\\"jquery\\\"],a):\\\"object\\\"==typeof module&&module.exports?module.exports=function(b,c){return void 0===c&&(c=\\\"undefined\\\"!=typeof window?require(\\\"jquery\\\"):require(\\\"jquery\\\")(b)),a(c)}:a(window.jQuery)}(function(a){a.extend(a.FE.DEFAULTS,{}),a.FE.URLRegEx=/(\\\\s|^|>)(((http|https|ftp|ftps)\\\\:\\\\/\\\\/)?[a-zA-Z0-9\\\\-\\\\.]+(\\\\.[a-zA-Z]{2,3})(:\\\\d*)?(\\\\/[^\\\\s<]*)?)(\\\\s|$|<)/gi,a.FE.PLUGINS.url=function(b){function c(a){for(;a.parentNode;)if(a=a.parentNode,[\\\"A\\\",\\\"BUTTON\\\",\\\"TEXTAREA\\\"].indexOf(a.tagName)>=0)return!0;return!1}function d(){for(var d,e=b.doc.createTreeWalker(b.el,NodeFilter.SHOW_TEXT,b.node.filter(function(b){return a.FE.URLRegEx.test(b.textContent.replace(/&nbsp;/gi,\\\" \\\"))&&!c(b)}),!1),f=[];e.nextNode();)d=e.currentNode,f.push(d);for(var g=0;g<f.length;g++){d=f[g];var h=null;b.opts.linkAlwaysNoFollow&&(h=\\\"nofollow\\\"),b.opts.linkAlwaysBlank&&(h?h+=\\\" noopener noreferrer\\\":h=\\\"noopener noreferrer\\\"),a(d).before(d.textContent.replace(a.FE.URLRegEx,\\\"$1<a\\\"+(b.opts.linkAlwaysBlank?' target=\\\"_blank\\\"':\\\"\\\")+(h?' rel=\\\"'+h+'\\\"':\\\"\\\")+' href=\\\"$2\\\">$2</a>$8')),d.parentNode.removeChild(d)}}function e(){b.events.on(\\\"paste.afterCleanup\\\",function(c){if(a.FE.URLRegEx.test(c))return c.replace(a.FE.URLRegEx,\\\"$1<a\\\"+(b.opts.linkAlwaysBlank?' target=\\\"_blank\\\"':\\\"\\\")+(b.opts.linkAlwaysNoFollow?' rel=\\\"nofollow\\\"':\\\"\\\")+' href=\\\"$2\\\">$2</a>$8')}),b.events.on(\\\"keyup\\\",function(c){var e=c.which;e!=a.FE.KEYCODE.ENTER&&e!=a.FE.KEYCODE.SPACE||d(b.node.contents(b.el))}),b.events.on(\\\"keydown\\\",function(c){var d=c.which;if(d==a.FE.KEYCODE.ENTER){var e=b.selection.element();if((\\\"A\\\"==e.tagName||a(e).parents(\\\"a\\\").length)&&b.selection.info(e).atEnd)return c.stopImmediatePropagation(),\\\"A\\\"!==e.tagName&&(e=a(e).parents(\\\"a\\\")[0]),a(e).after(\\\"&nbsp;\\\"+a.FE.MARKERS),b.selection.restore(),!1}})}return{_init:e}}});\"//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTkuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2Zyb2FsYS1lZGl0b3IvanMvcGx1Z2lucy91cmwubWluLmpzP2E1NmIiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBcIi8qIVxcbiAqIGZyb2FsYV9lZGl0b3IgdjIuNS4wIChodHRwczovL3d3dy5mcm9hbGEuY29tL3d5c2l3eWctZWRpdG9yKVxcbiAqIExpY2Vuc2UgaHR0cHM6Ly9mcm9hbGEuY29tL3d5c2l3eWctZWRpdG9yL3Rlcm1zL1xcbiAqIENvcHlyaWdodCAyMDE0LTIwMTcgRnJvYWxhIExhYnNcXG4gKi9cXG5cXG4hZnVuY3Rpb24oYSl7XFxcImZ1bmN0aW9uXFxcIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUoW1xcXCJqcXVlcnlcXFwiXSxhKTpcXFwib2JqZWN0XFxcIj09dHlwZW9mIG1vZHVsZSYmbW9kdWxlLmV4cG9ydHM/bW9kdWxlLmV4cG9ydHM9ZnVuY3Rpb24oYixjKXtyZXR1cm4gdm9pZCAwPT09YyYmKGM9XFxcInVuZGVmaW5lZFxcXCIhPXR5cGVvZiB3aW5kb3c/cmVxdWlyZShcXFwianF1ZXJ5XFxcIik6cmVxdWlyZShcXFwianF1ZXJ5XFxcIikoYikpLGEoYyl9OmEod2luZG93LmpRdWVyeSl9KGZ1bmN0aW9uKGEpe2EuZXh0ZW5kKGEuRkUuREVGQVVMVFMse30pLGEuRkUuVVJMUmVnRXg9LyhcXFxcc3xefD4pKCgoaHR0cHxodHRwc3xmdHB8ZnRwcylcXFxcOlxcXFwvXFxcXC8pP1thLXpBLVowLTlcXFxcLVxcXFwuXSsoXFxcXC5bYS16QS1aXXsyLDN9KSg6XFxcXGQqKT8oXFxcXC9bXlxcXFxzPF0qKT8pKFxcXFxzfCR8PCkvZ2ksYS5GRS5QTFVHSU5TLnVybD1mdW5jdGlvbihiKXtmdW5jdGlvbiBjKGEpe2Zvcig7YS5wYXJlbnROb2RlOylpZihhPWEucGFyZW50Tm9kZSxbXFxcIkFcXFwiLFxcXCJCVVRUT05cXFwiLFxcXCJURVhUQVJFQVxcXCJdLmluZGV4T2YoYS50YWdOYW1lKT49MClyZXR1cm4hMDtyZXR1cm4hMX1mdW5jdGlvbiBkKCl7Zm9yKHZhciBkLGU9Yi5kb2MuY3JlYXRlVHJlZVdhbGtlcihiLmVsLE5vZGVGaWx0ZXIuU0hPV19URVhULGIubm9kZS5maWx0ZXIoZnVuY3Rpb24oYil7cmV0dXJuIGEuRkUuVVJMUmVnRXgudGVzdChiLnRleHRDb250ZW50LnJlcGxhY2UoLyZuYnNwOy9naSxcXFwiIFxcXCIpKSYmIWMoYil9KSwhMSksZj1bXTtlLm5leHROb2RlKCk7KWQ9ZS5jdXJyZW50Tm9kZSxmLnB1c2goZCk7Zm9yKHZhciBnPTA7ZzxmLmxlbmd0aDtnKyspe2Q9ZltnXTt2YXIgaD1udWxsO2Iub3B0cy5saW5rQWx3YXlzTm9Gb2xsb3cmJihoPVxcXCJub2ZvbGxvd1xcXCIpLGIub3B0cy5saW5rQWx3YXlzQmxhbmsmJihoP2grPVxcXCIgbm9vcGVuZXIgbm9yZWZlcnJlclxcXCI6aD1cXFwibm9vcGVuZXIgbm9yZWZlcnJlclxcXCIpLGEoZCkuYmVmb3JlKGQudGV4dENvbnRlbnQucmVwbGFjZShhLkZFLlVSTFJlZ0V4LFxcXCIkMTxhXFxcIisoYi5vcHRzLmxpbmtBbHdheXNCbGFuaz8nIHRhcmdldD1cXFwiX2JsYW5rXFxcIic6XFxcIlxcXCIpKyhoPycgcmVsPVxcXCInK2grJ1xcXCInOlxcXCJcXFwiKSsnIGhyZWY9XFxcIiQyXFxcIj4kMjwvYT4kOCcpKSxkLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZCl9fWZ1bmN0aW9uIGUoKXtiLmV2ZW50cy5vbihcXFwicGFzdGUuYWZ0ZXJDbGVhbnVwXFxcIixmdW5jdGlvbihjKXtpZihhLkZFLlVSTFJlZ0V4LnRlc3QoYykpcmV0dXJuIGMucmVwbGFjZShhLkZFLlVSTFJlZ0V4LFxcXCIkMTxhXFxcIisoYi5vcHRzLmxpbmtBbHdheXNCbGFuaz8nIHRhcmdldD1cXFwiX2JsYW5rXFxcIic6XFxcIlxcXCIpKyhiLm9wdHMubGlua0Fsd2F5c05vRm9sbG93PycgcmVsPVxcXCJub2ZvbGxvd1xcXCInOlxcXCJcXFwiKSsnIGhyZWY9XFxcIiQyXFxcIj4kMjwvYT4kOCcpfSksYi5ldmVudHMub24oXFxcImtleXVwXFxcIixmdW5jdGlvbihjKXt2YXIgZT1jLndoaWNoO2UhPWEuRkUuS0VZQ09ERS5FTlRFUiYmZSE9YS5GRS5LRVlDT0RFLlNQQUNFfHxkKGIubm9kZS5jb250ZW50cyhiLmVsKSl9KSxiLmV2ZW50cy5vbihcXFwia2V5ZG93blxcXCIsZnVuY3Rpb24oYyl7dmFyIGQ9Yy53aGljaDtpZihkPT1hLkZFLktFWUNPREUuRU5URVIpe3ZhciBlPWIuc2VsZWN0aW9uLmVsZW1lbnQoKTtpZigoXFxcIkFcXFwiPT1lLnRhZ05hbWV8fGEoZSkucGFyZW50cyhcXFwiYVxcXCIpLmxlbmd0aCkmJmIuc2VsZWN0aW9uLmluZm8oZSkuYXRFbmQpcmV0dXJuIGMuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCksXFxcIkFcXFwiIT09ZS50YWdOYW1lJiYoZT1hKGUpLnBhcmVudHMoXFxcImFcXFwiKVswXSksYShlKS5hZnRlcihcXFwiJm5ic3A7XFxcIithLkZFLk1BUktFUlMpLGIuc2VsZWN0aW9uLnJlc3RvcmUoKSwhMX19KX1yZXR1cm57X2luaXQ6ZX19fSk7XCJcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcmF3LWxvYWRlciEuL34vZnJvYWxhLWVkaXRvci9qcy9wbHVnaW5zL3VybC5taW4uanNcbi8vIG1vZHVsZSBpZCA9IDE5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {

	eval("__webpack_require__(2)(__webpack_require__(21))//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjAuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2Zyb2FsYS1lZGl0b3IvanMvcGx1Z2lucy9pbWFnZS5taW4uanM/ZDZmOCJdLCJzb3VyY2VzQ29udGVudCI6WyJyZXF1aXJlKFwiISEvVXNlcnMvamFrdWJmYWprdXMvRG9jdW1lbnRzL3ByYWNlL3ZlbmljZS1kZW1vL3dlYi9qcy9ub2RlX21vZHVsZXMvc2NyaXB0LWxvYWRlci9hZGRTY3JpcHQuanNcIikocmVxdWlyZShcIiEhL1VzZXJzL2pha3ViZmFqa3VzL0RvY3VtZW50cy9wcmFjZS92ZW5pY2UtZGVtby93ZWIvanMvbm9kZV9tb2R1bGVzL3Jhdy1sb2FkZXIvaW5kZXguanMhL1VzZXJzL2pha3ViZmFqa3VzL0RvY3VtZW50cy9wcmFjZS92ZW5pY2UtZGVtby93ZWIvanMvbm9kZV9tb2R1bGVzL2Zyb2FsYS1lZGl0b3IvanMvcGx1Z2lucy9pbWFnZS5taW4uanNcIikpXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3NjcmlwdC1sb2FkZXIhLi9+L2Zyb2FsYS1lZGl0b3IvanMvcGx1Z2lucy9pbWFnZS5taW4uanNcbi8vIG1vZHVsZSBpZCA9IDIwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 21 */
/***/ function(module, exports) {

	eval("module.exports = \"/*!\\n * froala_editor v2.5.0 (https://www.froala.com/wysiwyg-editor)\\n * License https://froala.com/wysiwyg-editor/terms/\\n * Copyright 2014-2017 Froala Labs\\n */\\n\\n!function(a){\\\"function\\\"==typeof define&&define.amd?define([\\\"jquery\\\"],a):\\\"object\\\"==typeof module&&module.exports?module.exports=function(b,c){return void 0===c&&(c=\\\"undefined\\\"!=typeof window?require(\\\"jquery\\\"):require(\\\"jquery\\\")(b)),a(c)}:a(window.jQuery)}(function(a){a.extend(a.FE.POPUP_TEMPLATES,{\\\"image.insert\\\":\\\"[_BUTTONS_][_UPLOAD_LAYER_][_BY_URL_LAYER_][_PROGRESS_BAR_]\\\",\\\"image.edit\\\":\\\"[_BUTTONS_]\\\",\\\"image.alt\\\":\\\"[_BUTTONS_][_ALT_LAYER_]\\\",\\\"image.size\\\":\\\"[_BUTTONS_][_SIZE_LAYER_]\\\"}),a.extend(a.FE.DEFAULTS,{imageInsertButtons:[\\\"imageBack\\\",\\\"|\\\",\\\"imageUpload\\\",\\\"imageByURL\\\"],imageEditButtons:[\\\"imageReplace\\\",\\\"imageAlign\\\",\\\"imageRemove\\\",\\\"|\\\",\\\"imageLink\\\",\\\"linkOpen\\\",\\\"linkEdit\\\",\\\"linkRemove\\\",\\\"-\\\",\\\"imageDisplay\\\",\\\"imageStyle\\\",\\\"imageAlt\\\",\\\"imageSize\\\"],imageAltButtons:[\\\"imageBack\\\",\\\"|\\\"],imageSizeButtons:[\\\"imageBack\\\",\\\"|\\\"],imageUploadURL:\\\"https://i.froala.com/upload\\\",imageUploadParam:\\\"file\\\",imageUploadParams:{},imageUploadToS3:!1,imageUploadMethod:\\\"POST\\\",imageMaxSize:10485760,imageAllowedTypes:[\\\"jpeg\\\",\\\"jpg\\\",\\\"png\\\",\\\"gif\\\",\\\"svg+xml\\\"],imageResize:!0,imageResizeWithPercent:!1,imageRoundPercent:!1,imageDefaultWidth:300,imageDefaultAlign:\\\"center\\\",imageDefaultDisplay:\\\"block\\\",imageSplitHTML:!1,imageStyles:{\\\"fr-rounded\\\":\\\"Rounded\\\",\\\"fr-bordered\\\":\\\"Bordered\\\"},imageMove:!0,imageMultipleStyles:!0,imageTextNear:!0,imagePaste:!0,imagePasteProcess:!1,imageMinWidth:16,imageOutputSize:!1,imageDefaultMargin:5}),a.FE.PLUGINS.image=function(b){function c(){var a=b.popups.get(\\\"image.insert\\\"),c=a.find(\\\".fr-image-by-url-layer input\\\");c.val(\\\"\\\"),xa&&c.val(xa.attr(\\\"src\\\")),c.trigger(\\\"change\\\")}function d(){var a=b.$tb.find('.fr-command[data-cmd=\\\"insertImage\\\"]'),c=b.popups.get(\\\"image.insert\\\");if(c||(c=M()),s(),!c.hasClass(\\\"fr-active\\\"))if(b.popups.refresh(\\\"image.insert\\\"),b.popups.setContainer(\\\"image.insert\\\",b.$tb),a.is(\\\":visible\\\")){var d=a.offset().left+a.outerWidth()/2,e=a.offset().top+(b.opts.toolbarBottom?10:a.outerHeight()-10);b.popups.show(\\\"image.insert\\\",d,e,a.outerHeight())}else b.position.forSelection(c),b.popups.show(\\\"image.insert\\\")}function e(){var a=b.popups.get(\\\"image.edit\\\");if(a||(a=q()),a){b.popups.setContainer(\\\"image.edit\\\",b.$sc),b.popups.refresh(\\\"image.edit\\\");var c=xa.offset().left+xa.outerWidth()/2,d=xa.offset().top+xa.outerHeight();b.popups.show(\\\"image.edit\\\",c,d,xa.outerHeight())}}function f(){s()}function g(a){a.hasClass(\\\"fr-dii\\\")||a.hasClass(\\\"fr-dib\\\")||(a.addClass(\\\"fr-fi\\\"+ma(a)[0]),a.addClass(\\\"fr-di\\\"+na(a)[0]),a.css(\\\"margin\\\",\\\"\\\"),a.css(\\\"float\\\",\\\"\\\"),a.css(\\\"display\\\",\\\"\\\"),a.css(\\\"z-index\\\",\\\"\\\"),a.css(\\\"position\\\",\\\"\\\"),a.css(\\\"overflow\\\",\\\"\\\"),a.css(\\\"vertical-align\\\",\\\"\\\"))}function h(a){var b=a.hasClass(\\\"fr-dib\\\")?\\\"block\\\":a.hasClass(\\\"fr-dii\\\")?\\\"inline\\\":null,c=a.hasClass(\\\"fr-fil\\\")?\\\"left\\\":a.hasClass(\\\"fr-fir\\\")?\\\"right\\\":ma(a);ka(a,b,c),a.removeClass(\\\"fr-dib fr-dii fr-fir fr-fil\\\")}function i(){for(var c=\\\"IMG\\\"==b.el.tagName?[b.el]:b.el.querySelectorAll(\\\"img\\\"),d=0;d<c.length;d++){var e=a(c[d]);!b.opts.htmlUntouched&&b.opts.useClasses?((b.opts.imageEditButtons.indexOf(\\\"imageAlign\\\")>=0||b.opts.imageEditButtons.indexOf(\\\"imageDisplay\\\")>=0)&&g(e),b.opts.imageTextNear||e.removeClass(\\\"fr-dii\\\").addClass(\\\"fr-dib\\\")):b.opts.htmlUntouched||b.opts.useClasses||(b.opts.imageEditButtons.indexOf(\\\"imageAlign\\\")>=0||b.opts.imageEditButtons.indexOf(\\\"imageDisplay\\\")>=0)&&h(e),b.opts.iframe&&e.on(\\\"load\\\",b.size.syncIframe)}}function j(){var c,d=Array.prototype.slice.call(b.el.querySelectorAll(\\\"img\\\")),e=[];for(c=0;c<d.length;c++)e.push(d[c].getAttribute(\\\"src\\\")),a(d[c]).toggleClass(\\\"fr-draggable\\\",b.opts.imageMove),\\\"\\\"===d[c].getAttribute(\\\"class\\\")&&d[c].removeAttribute(\\\"class\\\"),\\\"\\\"===d[c].getAttribute(\\\"style\\\")&&d[c].removeAttribute(\\\"style\\\");if(Ka)for(c=0;c<Ka.length;c++)e.indexOf(Ka[c].getAttribute(\\\"src\\\"))<0&&b.events.trigger(\\\"image.removed\\\",[a(Ka[c])]);Ka=d}function k(){ya||Z();var a=b.$wp||b.$sc;a.append(ya),ya.data(\\\"instance\\\",b);var c=a.scrollTop()-(\\\"static\\\"!=a.css(\\\"position\\\")?a.offset().top:0),d=a.scrollLeft()-(\\\"static\\\"!=a.css(\\\"position\\\")?a.offset().left:0);d-=b.helpers.getPX(a.css(\\\"border-left-width\\\")),c-=b.helpers.getPX(a.css(\\\"border-top-width\\\")),b.$el.is(\\\"img\\\")&&(c=0,d=0),ya.css(\\\"top\\\",(b.opts.iframe?xa.offset().top:xa.offset().top+c)-1).css(\\\"left\\\",(b.opts.iframe?xa.offset().left:xa.offset().left+d)-1).css(\\\"width\\\",xa.get(0).getBoundingClientRect().width).css(\\\"height\\\",xa.get(0).getBoundingClientRect().height).addClass(\\\"fr-active\\\")}function l(a){return'<div class=\\\"fr-handler fr-h'+a+'\\\"></div>'}function m(c){if(!b.core.sameInstance(ya))return!0;if(c.preventDefault(),c.stopPropagation(),b.$el.find(\\\"img.fr-error\\\").left)return!1;b.undo.canDo()||b.undo.saveStep();var d=c.pageX||c.originalEvent.touches[0].pageX,e=b.$oel.get(0),f=e.ownerDocument,g=f.defaultView||f.parentWindow,h=g.location!=g.parent.location;h&&(d+=g.frameElement.offsetLeft+g.frameElement.clientLeft),za=a(this),za.data(\\\"start-x\\\",d),za.data(\\\"start-width\\\",xa.width()),za.data(\\\"start-height\\\",xa.height());var i=xa.width();if(b.opts.imageResizeWithPercent){var j=xa.parentsUntil(b.$el,b.html.blockTagsQuery()).get(0)||b.el;xa.css(\\\"width\\\",(i/a(j).outerWidth()*100).toFixed(2)+\\\"%\\\")}else xa.css(\\\"width\\\",i);Aa.show(),b.popups.hideAll(),ia()}function n(c){if(!b.core.sameInstance(ya))return!0;var d;if(za&&xa){if(c.preventDefault(),b.$el.find(\\\"img.fr-error\\\").left)return!1;var e=c.pageX||(c.originalEvent.touches?c.originalEvent.touches[0].pageX:null);if(!e)return!1;var f=za.data(\\\"start-x\\\"),g=e-f,h=za.data(\\\"start-width\\\");if((za.hasClass(\\\"fr-hnw\\\")||za.hasClass(\\\"fr-hsw\\\"))&&(g=0-g),b.opts.imageResizeWithPercent){var i=xa.parentsUntil(b.$el,b.html.blockTagsQuery()).get(0)||b.el;h=((h+g)/a(i).outerWidth()*100).toFixed(2),b.opts.imageRoundPercent&&(h=Math.round(h)),xa.css(\\\"width\\\",h+\\\"%\\\"),d=(b.helpers.getPX(xa.css(\\\"width\\\"))/a(i).outerWidth()*100).toFixed(2),d!==h&&xa.css(\\\"width\\\",d+\\\"%\\\"),xa.css(\\\"height\\\",\\\"\\\").removeAttr(\\\"height\\\")}else h+g>=b.opts.imageMinWidth&&xa.css(\\\"width\\\",h+g),d=b.helpers.getPX(xa.css(\\\"width\\\")),d!==h+g&&xa.css(\\\"width\\\",d),xa.css(\\\"height\\\",za.data(\\\"start-height\\\")*xa.width()/za.data(\\\"start-width\\\"));k(),b.events.trigger(\\\"image.resize\\\",[va()])}}function o(a){if(!b.core.sameInstance(ya))return!0;if(za&&xa){if(a&&a.stopPropagation(),b.$el.find(\\\"img.fr-error\\\").left)return!1;za=null,Aa.hide(),k(),e(),b.undo.saveStep(),b.events.trigger(\\\"image.resizeEnd\\\",[va()])}}function p(a,c){b.edit.on(),xa&&xa.addClass(\\\"fr-error\\\"),u(b.language.translate(\\\"Something went wrong. Please try again.\\\")),b.events.trigger(\\\"image.error\\\",[{code:a,message:Ja[a]},c])}function q(a){if(a)return b.$wp&&b.events.$on(b.$wp,\\\"scroll\\\",function(){xa&&b.popups.isVisible(\\\"image.edit\\\")&&(b.events.disableBlur(),w(xa))}),!0;var c=\\\"\\\";if(b.opts.imageEditButtons.length>0){c+='<div class=\\\"fr-buttons\\\">',c+=b.button.buildList(b.opts.imageEditButtons),c+=\\\"</div>\\\";var d={buttons:c},e=b.popups.create(\\\"image.edit\\\",d);return e}return!1}function r(a){var c=b.popups.get(\\\"image.insert\\\");if(c||(c=M()),c.find(\\\".fr-layer.fr-active\\\").removeClass(\\\"fr-active\\\").addClass(\\\"fr-pactive\\\"),c.find(\\\".fr-image-progress-bar-layer\\\").addClass(\\\"fr-active\\\"),c.find(\\\".fr-buttons\\\").hide(),xa){b.popups.setContainer(\\\"image.insert\\\",b.$sc);var d=xa.offset().left+xa.width()/2,e=xa.offset().top+xa.height();b.popups.show(\\\"image.insert\\\",d,e,xa.outerHeight())}\\\"undefined\\\"==typeof a&&t(\\\"Uploading\\\",0)}function s(a){var c=b.popups.get(\\\"image.insert\\\");if(c&&(c.find(\\\".fr-layer.fr-pactive\\\").addClass(\\\"fr-active\\\").removeClass(\\\"fr-pactive\\\"),c.find(\\\".fr-image-progress-bar-layer\\\").removeClass(\\\"fr-active\\\"),c.find(\\\".fr-buttons\\\").show(),a||b.$el.find(\\\"img.fr-error\\\").length)){if(b.events.focus(),b.$el.find(\\\"img.fr-error\\\").length&&(b.$el.find(\\\"img.fr-error\\\").remove(),b.undo.saveStep(),b.undo.run(),b.undo.dropRedo()),!b.$wp&&xa){var d=xa;ga(!0),b.selection.setAfter(d.get(0)),b.selection.restore()}b.popups.hide(\\\"image.insert\\\")}}function t(a,c){var d=b.popups.get(\\\"image.insert\\\");if(d){var e=d.find(\\\".fr-image-progress-bar-layer\\\");e.find(\\\"h3\\\").text(a+(c?\\\" \\\"+c+\\\"%\\\":\\\"\\\")),e.removeClass(\\\"fr-error\\\"),c?(e.find(\\\"div\\\").removeClass(\\\"fr-indeterminate\\\"),e.find(\\\"div > span\\\").css(\\\"width\\\",c+\\\"%\\\")):e.find(\\\"div\\\").addClass(\\\"fr-indeterminate\\\")}}function u(a){r();var c=b.popups.get(\\\"image.insert\\\"),d=c.find(\\\".fr-image-progress-bar-layer\\\");d.addClass(\\\"fr-error\\\");var e=d.find(\\\"h3\\\");e.text(a),b.events.disableBlur(),e.focus()}function v(){var a=b.popups.get(\\\"image.insert\\\"),c=a.find(\\\".fr-image-by-url-layer input\\\");c.val().length>0&&(r(),t(\\\"Loading image\\\"),y(c.val(),!0,[],xa),c.val(\\\"\\\"),c.blur())}function w(a){fa.call(a.get(0))}function x(){var c=a(this);b.popups.hide(\\\"image.insert\\\"),c.removeClass(\\\"fr-uploading\\\"),c.next().is(\\\"br\\\")&&c.next().remove(),w(c),b.events.trigger(\\\"image.loaded\\\",[c])}function y(a,c,d,e,f){b.edit.off(),t(\\\"Loading image\\\"),c&&(a=b.helpers.sanitizeURL(a));var g=new Image;g.onload=function(){var c,g;if(e){b.undo.canDo()||e.hasClass(\\\"fr-uploading\\\")||b.undo.saveStep();var h=e.data(\\\"fr-old-src\\\");b.$wp?(c=e.clone().removeData(\\\"fr-old-src\\\").removeClass(\\\"fr-uploading\\\"),c.off(\\\"load\\\"),h&&e.attr(\\\"src\\\",h),e.replaceWith(c)):c=e;for(var i=c.get(0).attributes,k=0;k<i.length;k++){var l=i[k];0===l.nodeName.indexOf(\\\"data-\\\")&&c.removeAttr(l.nodeName)}if(\\\"undefined\\\"!=typeof d)for(g in d)d.hasOwnProperty(g)&&\\\"link\\\"!=g&&c.attr(\\\"data-\\\"+g,d[g]);c.on(\\\"load\\\",x),c.attr(\\\"src\\\",a),b.edit.on(),j(),b.undo.saveStep(),b.$el.blur(),b.events.trigger(h?\\\"image.replaced\\\":\\\"image.inserted\\\",[c,f])}else c=E(a,d,x),j(),b.undo.saveStep(),b.events.trigger(\\\"image.inserted\\\",[c,f])},g.onerror=function(){p(Ca)},r(\\\"Loading image\\\"),g.src=a}function z(c){try{if(b.events.trigger(\\\"image.uploaded\\\",[c],!0)===!1)return b.edit.on(),!1;var d=a.parseJSON(c);return d.link?d:(p(Da,c),!1)}catch(e){return p(Fa,c),!1}}function A(c){try{var d=a(c).find(\\\"Location\\\").text(),e=a(c).find(\\\"Key\\\").text();return b.events.trigger(\\\"image.uploadedToS3\\\",[d,e,c],!0)===!1?(b.edit.on(),!1):d}catch(f){return p(Fa,c),!1}}function B(a){t(\\\"Loading image\\\");var c=this.status,d=this.response,e=this.responseXML,f=this.responseText;try{if(b.opts.imageUploadToS3)if(201==c){var g=A(e);g&&y(g,!1,[],a,d||e)}else p(Fa,d||e);else if(c>=200&&c<300){var h=z(f);h&&y(h.link,!1,h,a,d||f)}else p(Ea,d||f)}catch(i){p(Fa,d||f)}}function C(){p(Fa,this.response||this.responseText||this.responseXML)}function D(a){if(a.lengthComputable){var b=a.loaded/a.total*100|0;t(\\\"Uploading\\\",b)}}function E(c,d,e){var f,g=\\\"\\\";if(d&&\\\"undefined\\\"!=typeof d)for(f in d)d.hasOwnProperty(f)&&\\\"link\\\"!=f&&(g+=\\\" data-\\\"+f+'=\\\"'+d[f]+'\\\"');var h=b.opts.imageDefaultWidth;h&&\\\"auto\\\"!=h&&(h+=b.opts.imageResizeWithPercent?\\\"%\\\":\\\"px\\\");var i=a('<img src=\\\"'+c+'\\\"'+g+(h?' style=\\\"width: '+h+';\\\"':\\\"\\\")+\\\">\\\");ka(i,b.opts.imageDefaultDisplay,b.opts.imageDefaultAlign),i.on(\\\"load\\\",e),b.edit.on(),b.events.focus(!0),b.selection.restore(),b.undo.saveStep(),b.opts.imageSplitHTML?b.markers.split():b.markers.insert();var j=b.$el.find(\\\".fr-marker\\\");return j.replaceWith(i),b.html.wrap(),b.selection.clear(),i}function F(){b.edit.on(),s(!0)}function G(c,d,e){function f(){var e=a(this);e.off(\\\"load\\\"),e.addClass(\\\"fr-uploading\\\"),e.next().is(\\\"br\\\")&&e.next().remove(),b.placeholder.refresh(),e.is(xa)||w(e),k(),r(),b.edit.off(),c.onload=function(){B.call(c,e)},c.onerror=C,c.upload.onprogress=D,c.onabort=F,e.off(\\\"abortUpload\\\").on(\\\"abortUpload\\\",function(){4!=c.readyState&&c.abort()}),c.send(d)}var g,h=new FileReader;h.addEventListener(\\\"load\\\",function(){var a=h.result;if(h.result.indexOf(\\\"svg+xml\\\")<0){for(var c=atob(h.result.split(\\\",\\\")[1]),d=[],e=0;e<c.length;e++)d.push(c.charCodeAt(e));a=window.URL.createObjectURL(new Blob([new Uint8Array(d)],{type:\\\"image/jpeg\\\"}))}xa?(xa.on(\\\"load\\\",f),b.edit.on(),b.undo.saveStep(),xa.data(\\\"fr-old-src\\\",xa.attr(\\\"src\\\")),xa.attr(\\\"src\\\",a)):g=E(a,null,f)},!1),h.readAsDataURL(e)}function H(a){if(\\\"undefined\\\"!=typeof a&&a.length>0){if(b.events.trigger(\\\"image.beforeUpload\\\",[a])===!1)return!1;var c=a[0];if(c.size>b.opts.imageMaxSize)return p(Ga),!1;if(b.opts.imageAllowedTypes.indexOf(c.type.replace(/image\\\\//g,\\\"\\\"))<0)return p(Ha),!1;var d;if(b.drag_support.formdata&&(d=b.drag_support.formdata?new FormData:null),d){var e;if(b.opts.imageUploadToS3!==!1){d.append(\\\"key\\\",b.opts.imageUploadToS3.keyStart+(new Date).getTime()+\\\"-\\\"+(c.name||\\\"untitled\\\")),d.append(\\\"success_action_status\\\",\\\"201\\\"),d.append(\\\"X-Requested-With\\\",\\\"xhr\\\"),d.append(\\\"Content-Type\\\",c.type);for(e in b.opts.imageUploadToS3.params)b.opts.imageUploadToS3.params.hasOwnProperty(e)&&d.append(e,b.opts.imageUploadToS3.params[e])}for(e in b.opts.imageUploadParams)b.opts.imageUploadParams.hasOwnProperty(e)&&d.append(e,b.opts.imageUploadParams[e]);d.append(b.opts.imageUploadParam,c);var f=b.opts.imageUploadURL;b.opts.imageUploadToS3&&(f=b.opts.imageUploadToS3.uploadURL?b.opts.imageUploadToS3.uploadURL:\\\"https://\\\"+b.opts.imageUploadToS3.region+\\\".amazonaws.com/\\\"+b.opts.imageUploadToS3.bucket);var g=b.core.getXHR(f,b.opts.imageUploadMethod);G(g,d,c)}}}function I(c){b.events.$on(c,\\\"dragover dragenter\\\",\\\".fr-image-upload-layer\\\",function(){return a(this).addClass(\\\"fr-drop\\\"),!1}),b.events.$on(c,\\\"dragleave dragend\\\",\\\".fr-image-upload-layer\\\",function(){return a(this).removeClass(\\\"fr-drop\\\"),!1}),b.events.$on(c,\\\"drop\\\",\\\".fr-image-upload-layer\\\",function(d){d.preventDefault(),d.stopPropagation(),a(this).removeClass(\\\"fr-drop\\\");var e=d.originalEvent.dataTransfer;if(e&&e.files){var f=c.data(\\\"instance\\\")||b;f.events.disableBlur(),f.image.upload(e.files),f.events.enableBlur()}}),b.events.$on(c,\\\"change\\\",'.fr-image-upload-layer input[type=\\\"file\\\"]',function(){if(this.files){var d=c.data(\\\"instance\\\")||b;d.events.disableBlur(),c.find(\\\"input:focus\\\").blur(),d.events.enableBlur(),d.image.upload(this.files)}a(this).val(\\\"\\\")})}function J(c){var d=c.originalEvent.dataTransfer;if(d&&d.files&&d.files.length){var e=d.files[0];if(e&&e.type&&e.type.indexOf(\\\"image\\\")!==-1){b.markers.remove(),b.markers.insertAtPoint(c.originalEvent),b.$el.find(\\\".fr-marker\\\").replaceWith(a.FE.MARKERS),b.popups.hideAll();var f=b.popups.get(\\\"image.insert\\\");return f||(f=M()),b.popups.setContainer(\\\"image.insert\\\",b.$sc),b.popups.show(\\\"image.insert\\\",c.originalEvent.pageX,c.originalEvent.pageY),r(),b.opts.imageAllowedTypes.indexOf(e.type.replace(/image\\\\//g,\\\"\\\"))>=0?H(d.files):p(Ha),c.preventDefault(),c.stopPropagation(),!1}}}function K(){var c,d,e=b.selection.ranges(0);e.collapsed&&e.startContainer.nodeType==Node.ELEMENT_NODE&&(e.startContainer.childNodes.length==e.startOffset?(c=e.startContainer.childNodes[e.startOffset-1],c&&\\\"IMG\\\"==c.tagName&&\\\"block\\\"==a(c).css(\\\"display\\\")&&(d=b.node.blockParent(c),d&&b.html.defaultTag()?d.nextSibling||([\\\"TD\\\",\\\"TH\\\"].indexOf(d.tagName)<0?a(d).after(\\\"<\\\"+b.html.defaultTag()+\\\"><br>\\\"+a.FE.MARKERS+\\\"</\\\"+b.html.defaultTag()+\\\">\\\"):a(c).after(\\\"<br>\\\"+a.FE.MARKERS),b.selection.restore()):d||(a(c).after(\\\"<br>\\\"+a.FE.MARKERS),b.selection.restore()))):0===e.startOffset&&e.startContainer.childNodes.length>e.startOffset&&(c=e.startContainer.childNodes[e.startOffset],c&&\\\"IMG\\\"==c.tagName&&\\\"block\\\"==a(c).css(\\\"display\\\")&&(d=b.node.blockParent(c),d&&b.html.defaultTag()?d.previousSibling||([\\\"TD\\\",\\\"TH\\\"].indexOf(d.tagName)<0?a(d).before(\\\"<\\\"+b.html.defaultTag()+\\\"><br>\\\"+a.FE.MARKERS+\\\"</\\\"+b.html.defaultTag()+\\\">\\\"):a(c).before(\\\"<br>\\\"+a.FE.MARKERS),b.selection.restore()):d||(a(c).before(a.FE.MARKERS+\\\"<br>\\\"),b.selection.restore()))))}function L(){b.events.$on(b.$el,b._mousedown,\\\"IMG\\\"==b.el.tagName?null:'img:not([contenteditable=\\\"false\\\"])',function(c){return\\\"false\\\"==a(this).parents(\\\"[contenteditable]:not(.fr-element):not(body):first\\\").attr(\\\"contenteditable\\\")||(b.helpers.isMobile()||b.selection.clear(),Ba=!0,b.popups.areVisible()&&b.events.disableBlur(),b.browser.msie&&(b.events.disableBlur(),b.$el.attr(\\\"contenteditable\\\",!1)),b.draggable||c.preventDefault(),void c.stopPropagation())}),b.events.$on(b.$el,b._mouseup,\\\"IMG\\\"==b.el.tagName?null:'img:not([contenteditable=\\\"false\\\"])',function(c){return\\\"false\\\"==a(this).parents(\\\"[contenteditable]:not(.fr-element):not(body):first\\\").attr(\\\"contenteditable\\\")||void(Ba&&(Ba=!1,c.stopPropagation(),b.browser.msie&&(b.$el.attr(\\\"contenteditable\\\",!0),b.events.enableBlur())))}),b.events.on(\\\"keyup\\\",function(c){if(c.shiftKey&&\\\"\\\"===b.selection.text().replace(/\\\\n/g,\\\"\\\")){var d=b.selection.element(),e=b.selection.endElement();d&&\\\"IMG\\\"==d.tagName?w(a(d)):e&&\\\"IMG\\\"==e.tagName&&w(a(e))}},!0),b.events.on(\\\"drop\\\",J),b.events.on(\\\"mousedown window.mousedown\\\",ha),b.events.on(\\\"window.touchmove\\\",ia),b.events.on(\\\"mouseup window.mouseup\\\",function(){return xa?(ga(),!1):void ia()}),b.events.on(\\\"commands.mousedown\\\",function(a){a.parents(\\\".fr-toolbar\\\").length>0&&ga()}),b.browser.edge||b.events.on(\\\"mouseup\\\",K),b.events.on(\\\"blur image.hideResizer commands.undo commands.redo element.dropped\\\",function(){Ba=!1,ga(!0)}),b.events.on(\\\"modals.hide\\\",function(){xa&&(ta(),b.selection.clear())})}function M(a){if(a)return b.popups.onRefresh(\\\"image.insert\\\",c),b.popups.onHide(\\\"image.insert\\\",f),!0;var d,e=\\\"\\\";b.opts.imageInsertButtons.length>1&&(e='<div class=\\\"fr-buttons\\\">'+b.button.buildList(b.opts.imageInsertButtons)+\\\"</div>\\\");var g=b.opts.imageInsertButtons.indexOf(\\\"imageUpload\\\"),h=b.opts.imageInsertButtons.indexOf(\\\"imageByURL\\\"),i=\\\"\\\";g>=0&&(d=\\\" fr-active\\\",h>=0&&g>h&&(d=\\\"\\\"),i='<div class=\\\"fr-image-upload-layer'+d+' fr-layer\\\" id=\\\"fr-image-upload-layer-'+b.id+'\\\"><strong>'+b.language.translate(\\\"Drop image\\\")+\\\"</strong><br>(\\\"+b.language.translate(\\\"or click\\\")+')<div class=\\\"fr-form\\\"><input type=\\\"file\\\" accept=\\\"image/'+b.opts.imageAllowedTypes.join(\\\", image/\\\").toLowerCase()+'\\\" tabIndex=\\\"-1\\\" aria-labelledby=\\\"fr-image-upload-layer-'+b.id+'\\\" role=\\\"button\\\"></div></div>');var j=\\\"\\\";h>=0&&(d=\\\" fr-active\\\",g>=0&&h>g&&(d=\\\"\\\"),j='<div class=\\\"fr-image-by-url-layer'+d+' fr-layer\\\" id=\\\"fr-image-by-url-layer-'+b.id+'\\\"><div class=\\\"fr-input-line\\\"><input id=\\\"fr-image-by-url-layer-text-'+b.id+'\\\" type=\\\"text\\\" placeholder=\\\"http://\\\" tabIndex=\\\"1\\\" aria-required=\\\"true\\\"></div><div class=\\\"fr-action-buttons\\\"><button type=\\\"button\\\" class=\\\"fr-command fr-submit\\\" data-cmd=\\\"imageInsertByURL\\\" tabIndex=\\\"2\\\" role=\\\"button\\\">'+b.language.translate(\\\"Insert\\\")+\\\"</button></div></div>\\\");var k='<div class=\\\"fr-image-progress-bar-layer fr-layer\\\"><h3 tabIndex=\\\"-1\\\" class=\\\"fr-message\\\">Uploading</h3><div class=\\\"fr-loader\\\"><span class=\\\"fr-progress\\\"></span></div><div class=\\\"fr-action-buttons\\\"><button type=\\\"button\\\" class=\\\"fr-command fr-dismiss\\\" data-cmd=\\\"imageDismissError\\\" tabIndex=\\\"2\\\" role=\\\"button\\\">OK</button></div></div>',l={buttons:e,upload_layer:i,by_url_layer:j,progress_bar:k},m=b.popups.create(\\\"image.insert\\\",l);return b.$wp&&b.events.$on(b.$wp,\\\"scroll\\\",function(){xa&&b.popups.isVisible(\\\"image.insert\\\")&&sa()}),I(m),m}function N(){if(xa){var a=b.popups.get(\\\"image.alt\\\");a.find(\\\"input\\\").val(xa.attr(\\\"alt\\\")||\\\"\\\").trigger(\\\"change\\\")}}function O(){var a=b.popups.get(\\\"image.alt\\\");a||(a=P()),s(),b.popups.refresh(\\\"image.alt\\\"),b.popups.setContainer(\\\"image.alt\\\",b.$sc);var c=xa.offset().left+xa.width()/2,d=xa.offset().top+xa.height();b.popups.show(\\\"image.alt\\\",c,d,xa.outerHeight())}function P(a){if(a)return b.popups.onRefresh(\\\"image.alt\\\",N),!0;var c=\\\"\\\";c='<div class=\\\"fr-buttons\\\">'+b.button.buildList(b.opts.imageAltButtons)+\\\"</div>\\\";var d=\\\"\\\";d='<div class=\\\"fr-image-alt-layer fr-layer fr-active\\\" id=\\\"fr-image-alt-layer-'+b.id+'\\\"><div class=\\\"fr-input-line\\\"><input id=\\\"fr-image-alt-layer-text-'+b.id+'\\\" type=\\\"text\\\" placeholder=\\\"'+b.language.translate(\\\"Alternate Text\\\")+'\\\" tabIndex=\\\"1\\\"></div><div class=\\\"fr-action-buttons\\\"><button type=\\\"button\\\" class=\\\"fr-command fr-submit\\\" data-cmd=\\\"imageSetAlt\\\" tabIndex=\\\"2\\\" role=\\\"button\\\">'+b.language.translate(\\\"Update\\\")+\\\"</button></div></div>\\\";var e={buttons:c,alt_layer:d},f=b.popups.create(\\\"image.alt\\\",e);return b.$wp&&b.events.$on(b.$wp,\\\"scroll.image-alt\\\",function(){xa&&b.popups.isVisible(\\\"image.alt\\\")&&O()}),f}function Q(a){if(xa){var c=b.popups.get(\\\"image.alt\\\");xa.attr(\\\"alt\\\",a||c.find(\\\"input\\\").val()||\\\"\\\"),c.find(\\\"input:focus\\\").blur(),w(xa)}}function R(){if(xa){var a=b.popups.get(\\\"image.size\\\");a.find('input[name=\\\"width\\\"]').val(xa.get(0).style.width).trigger(\\\"change\\\"),a.find('input[name=\\\"height\\\"]').val(xa.get(0).style.height).trigger(\\\"change\\\")}}function S(){var a=b.popups.get(\\\"image.size\\\");a||(a=T()),s(),b.popups.refresh(\\\"image.size\\\"),b.popups.setContainer(\\\"image.size\\\",b.$sc);var c=xa.offset().left+xa.width()/2,d=xa.offset().top+xa.height();b.popups.show(\\\"image.size\\\",c,d,xa.outerHeight())}function T(a){if(a)return b.popups.onRefresh(\\\"image.size\\\",R),!0;var c=\\\"\\\";c='<div class=\\\"fr-buttons\\\">'+b.button.buildList(b.opts.imageSizeButtons)+\\\"</div>\\\";var d=\\\"\\\";d='<div class=\\\"fr-image-size-layer fr-layer fr-active\\\" id=\\\"fr-image-size-layer-'+b.id+'\\\"><div class=\\\"fr-image-group\\\"><div class=\\\"fr-input-line\\\"><input id=\\\"fr-image-size-layer-width-'+b.id+'\\\" type=\\\"text\\\" name=\\\"width\\\" placeholder=\\\"'+b.language.translate(\\\"Width\\\")+'\\\" tabIndex=\\\"1\\\"></div><div class=\\\"fr-input-line\\\"><input id=\\\"fr-image-size-layer-height'+b.id+'\\\" type=\\\"text\\\" name=\\\"height\\\" placeholder=\\\"'+b.language.translate(\\\"Height\\\")+'\\\" tabIndex=\\\"1\\\"></div></div><div class=\\\"fr-action-buttons\\\"><button type=\\\"button\\\" class=\\\"fr-command fr-submit\\\" data-cmd=\\\"imageSetSize\\\" tabIndex=\\\"2\\\" role=\\\"button\\\">'+b.language.translate(\\\"Update\\\")+\\\"</button></div></div>\\\";var e={buttons:c,size_layer:d},f=b.popups.create(\\\"image.size\\\",e);return b.$wp&&b.events.$on(b.$wp,\\\"scroll.image-size\\\",function(){xa&&b.popups.isVisible(\\\"image.size\\\")&&S()}),f}function U(a,c){if(xa){var d=b.popups.get(\\\"image.size\\\");a=a||d.find('input[name=\\\"width\\\"]').val()||\\\"\\\",c=c||d.find('input[name=\\\"height\\\"]').val()||\\\"\\\";var e=/^[\\\\d]+((px)|%)*$/g;a.match(e)&&xa.css(\\\"width\\\",a),c.match(e)&&xa.css(\\\"height\\\",c),d.find(\\\"input:focus\\\").blur(),w(xa)}}function V(a){var c,d,e=b.popups.get(\\\"image.insert\\\");if(xa||b.opts.toolbarInline)xa&&(d=xa.offset().top+xa.outerHeight());else{var f=b.$tb.find('.fr-command[data-cmd=\\\"insertImage\\\"]');c=f.offset().left+f.outerWidth()/2,d=f.offset().top+(b.opts.toolbarBottom?10:f.outerHeight()-10)}!xa&&b.opts.toolbarInline&&(d=e.offset().top-b.helpers.getPX(e.css(\\\"margin-top\\\")),e.hasClass(\\\"fr-above\\\")&&(d+=e.outerHeight())),e.find(\\\".fr-layer\\\").removeClass(\\\"fr-active\\\"),e.find(\\\".fr-\\\"+a+\\\"-layer\\\").addClass(\\\"fr-active\\\"),b.popups.show(\\\"image.insert\\\",c,d,xa?xa.outerHeight():0),b.accessibility.focusPopup(e)}function W(a){var c=b.popups.get(\\\"image.insert\\\");c.find(\\\".fr-image-upload-layer\\\").hasClass(\\\"fr-active\\\")&&a.addClass(\\\"fr-active\\\").attr(\\\"aria-pressed\\\",!0)}function X(a){var c=b.popups.get(\\\"image.insert\\\");c.find(\\\".fr-image-by-url-layer\\\").hasClass(\\\"fr-active\\\")&&a.addClass(\\\"fr-active\\\").attr(\\\"aria-pressed\\\",!0)}function Y(a,b,c,d){return a.pageX=b,m.call(this,a),a.pageX=a.pageX+c*Math.floor(Math.pow(1.1,d)),n.call(this,a),o.call(this,a),++d}function Z(){var c;if(b.shared.$image_resizer?(ya=b.shared.$image_resizer,Aa=b.shared.$img_overlay,b.events.on(\\\"destroy\\\",function(){ya.removeClass(\\\"fr-active\\\").appendTo(a(\\\"body\\\"))},!0)):(b.shared.$image_resizer=a('<div class=\\\"fr-image-resizer\\\"></div>'),ya=b.shared.$image_resizer,b.events.$on(ya,\\\"mousedown\\\",function(a){a.stopPropagation()},!0),b.opts.imageResize&&(ya.append(l(\\\"nw\\\")+l(\\\"ne\\\")+l(\\\"sw\\\")+l(\\\"se\\\")),b.shared.$img_overlay=a('<div class=\\\"fr-image-overlay\\\"></div>'),Aa=b.shared.$img_overlay,c=ya.get(0).ownerDocument,a(c).find(\\\"body\\\").append(Aa))),b.events.on(\\\"shared.destroy\\\",function(){ya.html(\\\"\\\").removeData().remove(),ya=null,b.opts.imageResize&&(Aa.remove(),Aa=null)},!0),b.helpers.isMobile()||b.events.$on(a(b.o_win),\\\"resize\\\",function(){xa&&!xa.hasClass(\\\"fr-uploading\\\")?ga(!0):xa&&(k(),sa(),r(!1))}),b.opts.imageResize){c=ya.get(0).ownerDocument,b.events.$on(ya,b._mousedown,\\\".fr-handler\\\",m),b.events.$on(a(c),b._mousemove,n),b.events.$on(a(c.defaultView||c.parentWindow),b._mouseup,o),b.events.$on(Aa,\\\"mouseleave\\\",o);var d=1,e=null,f=0;b.events.on(\\\"keydown\\\",function(c){if(xa){var g=navigator.userAgent.indexOf(\\\"Mac OS X\\\")!=-1?c.metaKey:c.ctrlKey,h=c.which;(h!==e||c.timeStamp-f>200)&&(d=1),(h==a.FE.KEYCODE.EQUALS||b.browser.mozilla&&h==a.FE.KEYCODE.FF_EQUALS)&&g&&!c.altKey?d=Y.call(this,c,1,1,d):(h==a.FE.KEYCODE.HYPHEN||b.browser.mozilla&&h==a.FE.KEYCODE.FF_HYPHEN)&&g&&!c.altKey?d=Y.call(this,c,2,-1,d):b.keys.ctrlKey(c)||h!=a.FE.KEYCODE.ENTER||(xa.before(\\\"<br>\\\"),w(xa)),e=h,f=c.timeStamp}},!0),b.events.on(\\\"keyup\\\",function(){d=1})}}function $(c){c=c||xa,c&&b.events.trigger(\\\"image.beforeRemove\\\",[c])!==!1&&(b.popups.hideAll(),ta(),ga(!0),b.undo.canDo()||b.undo.saveStep(),c.get(0)==b.el?c.removeAttr(\\\"src\\\"):(\\\"A\\\"==c.get(0).parentNode.tagName?(b.selection.setBefore(c.get(0).parentNode)||b.selection.setAfter(c.get(0).parentNode)||c.parent().after(a.FE.MARKERS),a(c.get(0).parentNode).remove()):(b.selection.setBefore(c.get(0))||b.selection.setAfter(c.get(0))||c.after(a.FE.MARKERS),c.remove()),b.html.fillEmptyBlocks(),b.selection.restore()),b.undo.saveStep())}function _(c){var d=c.which;if(xa&&(d==a.FE.KEYCODE.BACKSPACE||d==a.FE.KEYCODE.DELETE))return c.preventDefault(),c.stopPropagation(),$(),!1;if(xa&&d==a.FE.KEYCODE.ESC){var e=xa;return ga(!0),b.selection.setAfter(e.get(0)),b.selection.restore(),c.preventDefault(),!1}if(xa&&(d==a.FE.KEYCODE.ARROW_LEFT||d==a.FE.KEYCODE.ARROW_RIGHT)){var f=xa.get(0);return ga(!0),d==a.FE.KEYCODE.ARROW_LEFT?b.selection.setBefore(f):b.selection.setAfter(f),b.selection.restore(),c.preventDefault(),!1}return xa&&d!=a.FE.KEYCODE.F10&&!b.keys.isBrowserAction(c)?(c.preventDefault(),c.stopPropagation(),!1):void 0}function aa(a){if(a&&\\\"IMG\\\"==a.tagName)b.node.hasClass(a,\\\"fr-uploading\\\")||b.node.hasClass(a,\\\"fr-error\\\")?a.parentNode.removeChild(a):b.node.hasClass(a,\\\"fr-draggable\\\")&&a.classList.remove(\\\"fr-draggable\\\");else if(a&&a.nodeType==Node.ELEMENT_NODE)for(var c=a.querySelectorAll(\\\"img.fr-uploading, img.fr-error, img.fr-draggable\\\"),d=0;d<c.length;d++)aa(c[d])}function ba(){if(L(),\\\"IMG\\\"==b.el.tagName&&b.$el.addClass(\\\"fr-view\\\"),b.events.$on(b.$el,b.helpers.isMobile()&&!b.helpers.isWindowsPhone()?\\\"touchend\\\":\\\"click\\\",\\\"IMG\\\"==b.el.tagName?null:'img:not([contenteditable=\\\"false\\\"])',fa),b.helpers.isMobile()&&(b.events.$on(b.$el,\\\"touchstart\\\",\\\"IMG\\\"==b.el.tagName?null:'img:not([contenteditable=\\\"false\\\"])',function(){La=!1}),b.events.$on(b.$el,\\\"touchmove\\\",function(){La=!0})),b.$wp?(b.events.on(\\\"window.keydown keydown\\\",_,!0),b.events.on(\\\"keyup\\\",function(b){if(b.which==a.FE.KEYCODE.ENTER)return!1},!0)):b.events.$on(b.$win,\\\"keydown\\\",_),b.events.on(\\\"toolbar.esc\\\",function(){if(xa){if(b.$wp)b.events.disableBlur(),b.events.focus();else{var a=xa;ga(!0),b.selection.setAfter(a.get(0)),b.selection.restore()}return!1}},!0),b.events.on(\\\"toolbar.focusEditor\\\",function(){if(xa)return!1},!0),b.events.on(\\\"window.cut window.copy\\\",function(c){xa&&b.popups.isVisible(\\\"image.edit\\\")&&!b.popups.get(\\\"image.edit\\\").find(\\\":focus\\\").length&&(ta(),a.FE.copied_text=\\\"\\\\n\\\",a.FE.copied_html=xa.get(0).outerHTML,\\\"copy\\\"==c.type?setTimeout(function(){w(xa)}):(ga(!0),b.undo.saveStep(),setTimeout(function(){b.undo.saveStep()},0)))},!0),b.events.$on(a(b.o_win),\\\"keydown\\\",function(b){var c=b.which;if(xa&&c==a.FE.KEYCODE.BACKSPACE)return b.preventDefault(),!1}),b.events.$on(b.$win,\\\"keydown\\\",function(b){var c=b.which;xa&&xa.hasClass(\\\"fr-uploading\\\")&&c==a.FE.KEYCODE.ESC&&xa.trigger(\\\"abortUpload\\\")}),b.events.on(\\\"destroy\\\",function(){xa&&xa.hasClass(\\\"fr-uploading\\\")&&xa.trigger(\\\"abortUpload\\\")}),b.events.on(\\\"paste.before\\\",da),b.events.on(\\\"paste.beforeCleanup\\\",ea),b.events.on(\\\"paste.after\\\",ca),b.events.on(\\\"html.set\\\",i),b.events.on(\\\"html.inserted\\\",i),i(),b.events.on(\\\"destroy\\\",function(){Ka=[]}),b.events.on(\\\"html.processGet\\\",aa),b.opts.imageOutputSize){var c;b.events.on(\\\"html.beforeGet\\\",function(){c=b.el.querySelectorAll(\\\"img\\\");for(var d=0;d<c.length;d++){var e=c[d].style.width||a(c[d]).width(),f=c[d].style.height||a(c[d]).height();e&&c[d].setAttribute(\\\"width\\\",(\\\"\\\"+e).replace(/px/,\\\"\\\")),f&&c[d].setAttribute(\\\"height\\\",(\\\"\\\"+f).replace(/px/,\\\"\\\"))}}),b.events.on(\\\"html.afterGet\\\",function(){for(var a=0;a<c.length;a++)c[a].removeAttribute(\\\"width\\\"),c[a].removeAttribute(\\\"height\\\")})}b.opts.iframe&&b.events.on(\\\"image.loaded\\\",b.size.syncIframe),b.$wp&&(j(),b.events.on(\\\"contentChanged\\\",j)),b.events.$on(a(b.o_win),\\\"orientationchange.image\\\",function(){setTimeout(function(){xa&&w(xa)},100)}),q(!0),M(!0),T(!0),P(!0),b.events.on(\\\"node.remove\\\",function(a){if(\\\"IMG\\\"==a.get(0).tagName)return $(a),!1})}function ca(){b.opts.imagePaste?b.$el.find(\\\"img[data-fr-image-pasted]\\\").each(function(c,d){if(b.opts.imagePasteProcess){var f=b.opts.imageDefaultWidth;f&&\\\"auto\\\"!=f&&(f+=b.opts.imageResizeWithPercent?\\\"%\\\":\\\"px\\\"),a(d).css(\\\"width\\\",f),a(d).removeClass(\\\"fr-dii fr-dib fr-fir fr-fil\\\").addClass((b.opts.imageDefaultDisplay?\\\"fr-di\\\"+b.opts.imageDefaultDisplay[0]:\\\"\\\")+(b.opts.imageDefaultAlign&&\\\"center\\\"!=b.opts.imageDefaultAlign?\\\" fr-fi\\\"+b.opts.imageDefaultAlign[0]:\\\"\\\"))}if(0===d.src.indexOf(\\\"data:\\\")){if(b.events.trigger(\\\"image.beforePasteUpload\\\",[d])===!1)return!1;xa=a(d),k(),e(),sa(),r(),b.edit.off();for(var g=atob(a(d).attr(\\\"src\\\").split(\\\",\\\")[1]),h=[],i=0;i<g.length;i++)h.push(g.charCodeAt(i));var j=new Blob([new Uint8Array(h)],{type:\\\"image/jpeg\\\"});H([j]),a(d).removeAttr(\\\"data-fr-image-pasted\\\")}else 0!==d.src.indexOf(\\\"http\\\")||0===d.src.indexOf(\\\"https://mail.google.com/mail\\\")?(b.selection.save(),a(d).remove(),b.selection.restore()):a(d).removeAttr(\\\"data-fr-image-pasted\\\")}):b.$el.find(\\\"img[data-fr-image-pasted]\\\").remove()}function da(a){if(a&&a.clipboardData&&a.clipboardData.items&&a.clipboardData.items[0]){var c=a.clipboardData.items[0].getAsFile();if(c){var d=new FileReader;return d.onload=function(a){var c=a.target.result,d=b.opts.imageDefaultWidth;d&&\\\"auto\\\"!=d&&(d+=b.opts.imageResizeWithPercent?\\\"%\\\":\\\"px\\\"),b.html.insert('<img data-fr-image-pasted=\\\"true\\\" class=\\\"'+(b.opts.imageDefaultDisplay?\\\"fr-di\\\"+b.opts.imageDefaultDisplay[0]:\\\"\\\")+(b.opts.imageDefaultAlign&&\\\"center\\\"!=b.opts.imageDefaultAlign?\\\" fr-fi\\\"+b.opts.imageDefaultAlign[0]:\\\"\\\")+'\\\" src=\\\"'+c+'\\\"'+(d?' style=\\\"width: '+d+';\\\"':\\\"\\\")+\\\">\\\"),b.events.trigger(\\\"paste.after\\\")},d.readAsDataURL(c),!1}}}function ea(a){return a=a.replace(/<img /gi,'<img data-fr-image-pasted=\\\"true\\\" ')}function fa(c){if(\\\"false\\\"==a(this).parents(\\\"[contenteditable]:not(.fr-element):not(body):first\\\").attr(\\\"contenteditable\\\"))return!0;if(c&&\\\"touchend\\\"==c.type&&La)return!0;if(c&&b.edit.isDisabled())return c.stopPropagation(),c.preventDefault(),!1;for(var d=0;d<a.FE.INSTANCES.length;d++)a.FE.INSTANCES[d]!=b&&a.FE.INSTANCES[d].events.trigger(\\\"image.hideResizer\\\");b.toolbar.disable(),c&&(c.stopPropagation(),c.preventDefault()),b.helpers.isMobile()&&(b.events.disableBlur(),b.$el.blur(),b.events.enableBlur()),b.opts.iframe&&b.size.syncIframe(),xa=a(this),ta(),k(),e(),b.selection.clear(),b.button.bulkRefresh(),b.events.trigger(\\\"video.hideResizer\\\")}function ga(a){xa&&(ja()||a===!0)&&(b.toolbar.enable(),ya.removeClass(\\\"fr-active\\\"),b.popups.hide(\\\"image.edit\\\"),xa=null,ia())}function ha(){Ma=!0}function ia(){Ma=!1}function ja(){return Ma}function ka(a,c,d){!b.opts.htmlUntouched&&b.opts.useClasses?(a.removeClass(\\\"fr-fil fr-fir fr-dib fr-dii\\\"),a.addClass(\\\"fr-fi\\\"+d[0]+\\\" fr-di\\\"+c[0])):\\\"inline\\\"==c?(a.css({display:\\\"inline-block\\\",verticalAlign:\\\"bottom\\\",margin:b.opts.imageDefaultMargin}),\\\"center\\\"==d?a.css({float:\\\"none\\\",marginBottom:\\\"\\\",marginTop:\\\"\\\",maxWidth:\\\"calc(100% - \\\"+2*b.opts.imageDefaultMargin+\\\"px)\\\"}):\\\"left\\\"==d?a.css({float:\\\"left\\\",marginLeft:0,maxWidth:\\\"calc(100% - \\\"+b.opts.imageDefaultMargin+\\\"px)\\\"}):a.css({float:\\\"right\\\",marginRight:0,maxWidth:\\\"calc(100% - \\\"+b.opts.imageDefaultMargin+\\\"px)\\\"})):\\\"block\\\"==c&&(a.css({display:\\\"block\\\",float:\\\"none\\\",verticalAlign:\\\"top\\\",margin:b.opts.imageDefaultMargin+\\\"px auto\\\"}),\\\"left\\\"==d?a.css({marginLeft:0}):\\\"right\\\"==d&&a.css({marginRight:0}))}function la(a){xa.removeClass(\\\"fr-fir fr-fil\\\"),!b.opts.htmlUntouched&&b.opts.useClasses?\\\"left\\\"==a?xa.addClass(\\\"fr-fil\\\"):\\\"right\\\"==a&&xa.addClass(\\\"fr-fir\\\"):ka(xa,na(),a),k(),e()}function ma(a){if(\\\"undefined\\\"==typeof a&&(a=xa),a){if(a.hasClass(\\\"fr-fil\\\"))return\\\"left\\\";if(a.hasClass(\\\"fr-fir\\\"))return\\\"right\\\";if(a.hasClass(\\\"fr-dib\\\")||a.hasClass(\\\"fr-dii\\\"))return\\\"center\\\";var b=a.css(\\\"float\\\");if(a.css(\\\"float\\\",\\\"none\\\"),\\\"block\\\"==a.css(\\\"display\\\")){if(a.css(\\\"float\\\",\\\"\\\"),a.css(\\\"float\\\")!=b&&a.css(\\\"float\\\",b),0===parseInt(a.css(\\\"margin-left\\\"),10))return\\\"left\\\";if(0===parseInt(a.css(\\\"margin-right\\\"),10))return\\\"right\\\"}else{if(a.css(\\\"float\\\",\\\"\\\"),a.css(\\\"float\\\")!=b&&a.css(\\\"float\\\",b),\\\"left\\\"==a.css(\\\"float\\\"))return\\\"left\\\";if(\\\"right\\\"==a.css(\\\"float\\\"))return\\\"right\\\"}}return\\\"center\\\"}function na(a){\\\"undefined\\\"==typeof a&&(a=xa);var b=a.css(\\\"float\\\");return a.css(\\\"float\\\",\\\"none\\\"),\\n\\\"block\\\"==a.css(\\\"display\\\")?(a.css(\\\"float\\\",\\\"\\\"),a.css(\\\"float\\\")!=b&&a.css(\\\"float\\\",b),\\\"block\\\"):(a.css(\\\"float\\\",\\\"\\\"),a.css(\\\"float\\\")!=b&&a.css(\\\"float\\\",b),\\\"inline\\\")}function oa(a){xa&&a.find(\\\"> *:first\\\").replaceWith(b.icon.create(\\\"image-align-\\\"+ma()))}function pa(a,b){xa&&b.find('.fr-command[data-param1=\\\"'+ma()+'\\\"]').addClass(\\\"fr-active\\\").attr(\\\"aria-selected\\\",!0)}function qa(a){xa.removeClass(\\\"fr-dii fr-dib\\\"),!b.opts.htmlUntouched&&b.opts.useClasses?\\\"inline\\\"==a?xa.addClass(\\\"fr-dii\\\"):\\\"block\\\"==a&&xa.addClass(\\\"fr-dib\\\"):ka(xa,a,ma()),k(),e()}function ra(a,b){xa&&b.find('.fr-command[data-param1=\\\"'+na()+'\\\"]').addClass(\\\"fr-active\\\").attr(\\\"aria-selected\\\",!0)}function sa(){var a=b.popups.get(\\\"image.insert\\\");a||(a=M()),b.popups.isVisible(\\\"image.insert\\\")||(s(),b.popups.refresh(\\\"image.insert\\\"),b.popups.setContainer(\\\"image.insert\\\",b.$sc));var c=xa.offset().left+xa.width()/2,d=xa.offset().top+xa.height();b.popups.show(\\\"image.insert\\\",c,d,xa.outerHeight())}function ta(){if(xa){b.selection.clear();var a=b.doc.createRange();a.selectNode(xa.get(0));var c=b.selection.get();c.addRange(a)}}function ua(){xa?(b.events.disableBlur(),a(\\\".fr-popup input:focus\\\").blur(),w(xa)):(b.events.disableBlur(),b.selection.restore(),b.events.enableBlur(),b.popups.hide(\\\"image.insert\\\"),b.toolbar.showInline())}function va(){return xa}function wa(a,c,d){if(\\\"undefined\\\"==typeof c&&(c=b.opts.imageStyles),\\\"undefined\\\"==typeof d&&(d=b.opts.imageMultipleStyles),!xa)return!1;if(!d){var e=Object.keys(c);e.splice(e.indexOf(a),1),xa.removeClass(e.join(\\\" \\\"))}\\\"object\\\"==typeof c[a]?(xa.removeAttr(\\\"style\\\"),xa.css(c[a].style)):xa.toggleClass(a),w(xa)}var xa,ya,za,Aa,Ba=!1,Ca=1,Da=2,Ea=3,Fa=4,Ga=5,Ha=6,Ia=7,Ja={};Ja[Ca]=\\\"Image cannot be loaded from the passed link.\\\",Ja[Da]=\\\"No link in upload response.\\\",Ja[Ea]=\\\"Error during file upload.\\\",Ja[Fa]=\\\"Parsing response failed.\\\",Ja[Ga]=\\\"File is too large.\\\",Ja[Ha]=\\\"Image file type is invalid.\\\",Ja[Ia]=\\\"Files can be uploaded only to same domain in IE 8 and IE 9.\\\";var Ka,La,Ma=!1;return{_init:ba,showInsertPopup:d,showLayer:V,refreshUploadButton:W,refreshByURLButton:X,upload:H,insertByURL:v,align:la,refreshAlign:oa,refreshAlignOnShow:pa,display:qa,refreshDisplayOnShow:ra,replace:sa,back:ua,get:va,insert:y,showProgressBar:r,remove:$,hideProgressBar:s,applyStyle:wa,showAltPopup:O,showSizePopup:S,setAlt:Q,setSize:U,exitEdit:ga,edit:w}},a.FE.DefineIcon(\\\"insertImage\\\",{NAME:\\\"image\\\"}),a.FE.RegisterShortcut(a.FE.KEYCODE.P,\\\"insertImage\\\",null,\\\"P\\\"),a.FE.RegisterCommand(\\\"insertImage\\\",{title:\\\"Insert Image\\\",undo:!1,focus:!0,refreshAfterCallback:!1,popup:!0,callback:function(){this.popups.isVisible(\\\"image.insert\\\")?(this.$el.find(\\\".fr-marker\\\").length&&(this.events.disableBlur(),this.selection.restore()),this.popups.hide(\\\"image.insert\\\")):this.image.showInsertPopup()},plugin:\\\"image\\\"}),a.FE.DefineIcon(\\\"imageUpload\\\",{NAME:\\\"upload\\\"}),a.FE.RegisterCommand(\\\"imageUpload\\\",{title:\\\"Upload Image\\\",undo:!1,focus:!1,toggle:!0,callback:function(){this.image.showLayer(\\\"image-upload\\\")},refresh:function(a){this.image.refreshUploadButton(a)}}),a.FE.DefineIcon(\\\"imageByURL\\\",{NAME:\\\"link\\\"}),a.FE.RegisterCommand(\\\"imageByURL\\\",{title:\\\"By URL\\\",undo:!1,focus:!1,toggle:!0,callback:function(){this.image.showLayer(\\\"image-by-url\\\")},refresh:function(a){this.image.refreshByURLButton(a)}}),a.FE.RegisterCommand(\\\"imageInsertByURL\\\",{title:\\\"Insert Image\\\",undo:!0,refreshAfterCallback:!1,callback:function(){this.image.insertByURL()},refresh:function(a){var b=this.image.get();b?a.text(this.language.translate(\\\"Replace\\\")):a.text(this.language.translate(\\\"Insert\\\"))}}),a.FE.DefineIcon(\\\"imageDisplay\\\",{NAME:\\\"star\\\"}),a.FE.RegisterCommand(\\\"imageDisplay\\\",{title:\\\"Display\\\",type:\\\"dropdown\\\",options:{inline:\\\"Inline\\\",block:\\\"Break Text\\\"},callback:function(a,b){this.image.display(b)},refresh:function(a){this.opts.imageTextNear||a.addClass(\\\"fr-hidden\\\")},refreshOnShow:function(a,b){this.image.refreshDisplayOnShow(a,b)}}),a.FE.DefineIcon(\\\"image-align\\\",{NAME:\\\"align-left\\\"}),a.FE.DefineIcon(\\\"image-align-left\\\",{NAME:\\\"align-left\\\"}),a.FE.DefineIcon(\\\"image-align-right\\\",{NAME:\\\"align-right\\\"}),a.FE.DefineIcon(\\\"image-align-center\\\",{NAME:\\\"align-justify\\\"}),a.FE.DefineIcon(\\\"imageAlign\\\",{NAME:\\\"align-justify\\\"}),a.FE.RegisterCommand(\\\"imageAlign\\\",{type:\\\"dropdown\\\",title:\\\"Align\\\",options:{left:\\\"Align Left\\\",center:\\\"None\\\",right:\\\"Align Right\\\"},html:function(){var b='<ul class=\\\"fr-dropdown-list\\\" role=\\\"presentation\\\">',c=a.FE.COMMANDS.imageAlign.options;for(var d in c)c.hasOwnProperty(d)&&(b+='<li role=\\\"presentation\\\"><a class=\\\"fr-command fr-title\\\" tabIndex=\\\"-1\\\" role=\\\"option\\\" data-cmd=\\\"imageAlign\\\" data-param1=\\\"'+d+'\\\" title=\\\"'+this.language.translate(c[d])+'\\\">'+this.icon.create(\\\"image-align-\\\"+d)+'<span class=\\\"fr-sr-only\\\">'+this.language.translate(c[d])+\\\"</span></a></li>\\\");return b+=\\\"</ul>\\\"},callback:function(a,b){this.image.align(b)},refresh:function(a){this.image.refreshAlign(a)},refreshOnShow:function(a,b){this.image.refreshAlignOnShow(a,b)}}),a.FE.DefineIcon(\\\"imageReplace\\\",{NAME:\\\"exchange\\\"}),a.FE.RegisterCommand(\\\"imageReplace\\\",{title:\\\"Replace\\\",undo:!1,focus:!1,popup:!0,refreshAfterCallback:!1,callback:function(){this.image.replace()}}),a.FE.DefineIcon(\\\"imageRemove\\\",{NAME:\\\"trash\\\"}),a.FE.RegisterCommand(\\\"imageRemove\\\",{title:\\\"Remove\\\",callback:function(){this.image.remove()}}),a.FE.DefineIcon(\\\"imageBack\\\",{NAME:\\\"arrow-left\\\"}),a.FE.RegisterCommand(\\\"imageBack\\\",{title:\\\"Back\\\",undo:!1,focus:!1,back:!0,callback:function(){this.image.back()},refresh:function(a){var b=this.image.get();b||this.opts.toolbarInline?(a.removeClass(\\\"fr-hidden\\\"),a.next(\\\".fr-separator\\\").removeClass(\\\"fr-hidden\\\")):(a.addClass(\\\"fr-hidden\\\"),a.next(\\\".fr-separator\\\").addClass(\\\"fr-hidden\\\"))}}),a.FE.RegisterCommand(\\\"imageDismissError\\\",{title:\\\"OK\\\",undo:!1,callback:function(){this.image.hideProgressBar(!0)}}),a.FE.DefineIcon(\\\"imageStyle\\\",{NAME:\\\"magic\\\"}),a.FE.RegisterCommand(\\\"imageStyle\\\",{title:\\\"Style\\\",type:\\\"dropdown\\\",html:function(){var a='<ul class=\\\"fr-dropdown-list\\\" role=\\\"presentation\\\">',b=this.opts.imageStyles;for(var c in b)if(b.hasOwnProperty(c)){var d=b[c];\\\"object\\\"==typeof d&&(d=d.title),a+='<li role=\\\"presentation\\\"><a class=\\\"fr-command\\\" tabIndex=\\\"-1\\\" role=\\\"option\\\" data-cmd=\\\"imageStyle\\\" data-param1=\\\"'+c+'\\\">'+this.language.translate(d)+\\\"</a></li>\\\"}return a+=\\\"</ul>\\\"},callback:function(a,b){this.image.applyStyle(b)},refreshOnShow:function(b,c){var d=this.image.get();d&&c.find(\\\".fr-command\\\").each(function(){var b=a(this).data(\\\"param1\\\"),c=d.hasClass(b);a(this).toggleClass(\\\"fr-active\\\",c).attr(\\\"aria-selected\\\",c)})}}),a.FE.DefineIcon(\\\"imageAlt\\\",{NAME:\\\"info\\\"}),a.FE.RegisterCommand(\\\"imageAlt\\\",{undo:!1,focus:!1,popup:!0,title:\\\"Alternate Text\\\",callback:function(){this.image.showAltPopup()}}),a.FE.RegisterCommand(\\\"imageSetAlt\\\",{undo:!0,focus:!1,title:\\\"Update\\\",refreshAfterCallback:!1,callback:function(){this.image.setAlt()}}),a.FE.DefineIcon(\\\"imageSize\\\",{NAME:\\\"arrows-alt\\\"}),a.FE.RegisterCommand(\\\"imageSize\\\",{undo:!1,focus:!1,popup:!0,title:\\\"Change Size\\\",callback:function(){this.image.showSizePopup()}}),a.FE.RegisterCommand(\\\"imageSetSize\\\",{undo:!0,focus:!1,title:\\\"Update\\\",refreshAfterCallback:!1,callback:function(){this.image.setSize()}})});\"//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjEuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2Zyb2FsYS1lZGl0b3IvanMvcGx1Z2lucy9pbWFnZS5taW4uanM/ZDNiYiJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IFwiLyohXFxuICogZnJvYWxhX2VkaXRvciB2Mi41LjAgKGh0dHBzOi8vd3d3LmZyb2FsYS5jb20vd3lzaXd5Zy1lZGl0b3IpXFxuICogTGljZW5zZSBodHRwczovL2Zyb2FsYS5jb20vd3lzaXd5Zy1lZGl0b3IvdGVybXMvXFxuICogQ29weXJpZ2h0IDIwMTQtMjAxNyBGcm9hbGEgTGFic1xcbiAqL1xcblxcbiFmdW5jdGlvbihhKXtcXFwiZnVuY3Rpb25cXFwiPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZShbXFxcImpxdWVyeVxcXCJdLGEpOlxcXCJvYmplY3RcXFwiPT10eXBlb2YgbW9kdWxlJiZtb2R1bGUuZXhwb3J0cz9tb2R1bGUuZXhwb3J0cz1mdW5jdGlvbihiLGMpe3JldHVybiB2b2lkIDA9PT1jJiYoYz1cXFwidW5kZWZpbmVkXFxcIiE9dHlwZW9mIHdpbmRvdz9yZXF1aXJlKFxcXCJqcXVlcnlcXFwiKTpyZXF1aXJlKFxcXCJqcXVlcnlcXFwiKShiKSksYShjKX06YSh3aW5kb3cualF1ZXJ5KX0oZnVuY3Rpb24oYSl7YS5leHRlbmQoYS5GRS5QT1BVUF9URU1QTEFURVMse1xcXCJpbWFnZS5pbnNlcnRcXFwiOlxcXCJbX0JVVFRPTlNfXVtfVVBMT0FEX0xBWUVSX11bX0JZX1VSTF9MQVlFUl9dW19QUk9HUkVTU19CQVJfXVxcXCIsXFxcImltYWdlLmVkaXRcXFwiOlxcXCJbX0JVVFRPTlNfXVxcXCIsXFxcImltYWdlLmFsdFxcXCI6XFxcIltfQlVUVE9OU19dW19BTFRfTEFZRVJfXVxcXCIsXFxcImltYWdlLnNpemVcXFwiOlxcXCJbX0JVVFRPTlNfXVtfU0laRV9MQVlFUl9dXFxcIn0pLGEuZXh0ZW5kKGEuRkUuREVGQVVMVFMse2ltYWdlSW5zZXJ0QnV0dG9uczpbXFxcImltYWdlQmFja1xcXCIsXFxcInxcXFwiLFxcXCJpbWFnZVVwbG9hZFxcXCIsXFxcImltYWdlQnlVUkxcXFwiXSxpbWFnZUVkaXRCdXR0b25zOltcXFwiaW1hZ2VSZXBsYWNlXFxcIixcXFwiaW1hZ2VBbGlnblxcXCIsXFxcImltYWdlUmVtb3ZlXFxcIixcXFwifFxcXCIsXFxcImltYWdlTGlua1xcXCIsXFxcImxpbmtPcGVuXFxcIixcXFwibGlua0VkaXRcXFwiLFxcXCJsaW5rUmVtb3ZlXFxcIixcXFwiLVxcXCIsXFxcImltYWdlRGlzcGxheVxcXCIsXFxcImltYWdlU3R5bGVcXFwiLFxcXCJpbWFnZUFsdFxcXCIsXFxcImltYWdlU2l6ZVxcXCJdLGltYWdlQWx0QnV0dG9uczpbXFxcImltYWdlQmFja1xcXCIsXFxcInxcXFwiXSxpbWFnZVNpemVCdXR0b25zOltcXFwiaW1hZ2VCYWNrXFxcIixcXFwifFxcXCJdLGltYWdlVXBsb2FkVVJMOlxcXCJodHRwczovL2kuZnJvYWxhLmNvbS91cGxvYWRcXFwiLGltYWdlVXBsb2FkUGFyYW06XFxcImZpbGVcXFwiLGltYWdlVXBsb2FkUGFyYW1zOnt9LGltYWdlVXBsb2FkVG9TMzohMSxpbWFnZVVwbG9hZE1ldGhvZDpcXFwiUE9TVFxcXCIsaW1hZ2VNYXhTaXplOjEwNDg1NzYwLGltYWdlQWxsb3dlZFR5cGVzOltcXFwianBlZ1xcXCIsXFxcImpwZ1xcXCIsXFxcInBuZ1xcXCIsXFxcImdpZlxcXCIsXFxcInN2Zyt4bWxcXFwiXSxpbWFnZVJlc2l6ZTohMCxpbWFnZVJlc2l6ZVdpdGhQZXJjZW50OiExLGltYWdlUm91bmRQZXJjZW50OiExLGltYWdlRGVmYXVsdFdpZHRoOjMwMCxpbWFnZURlZmF1bHRBbGlnbjpcXFwiY2VudGVyXFxcIixpbWFnZURlZmF1bHREaXNwbGF5OlxcXCJibG9ja1xcXCIsaW1hZ2VTcGxpdEhUTUw6ITEsaW1hZ2VTdHlsZXM6e1xcXCJmci1yb3VuZGVkXFxcIjpcXFwiUm91bmRlZFxcXCIsXFxcImZyLWJvcmRlcmVkXFxcIjpcXFwiQm9yZGVyZWRcXFwifSxpbWFnZU1vdmU6ITAsaW1hZ2VNdWx0aXBsZVN0eWxlczohMCxpbWFnZVRleHROZWFyOiEwLGltYWdlUGFzdGU6ITAsaW1hZ2VQYXN0ZVByb2Nlc3M6ITEsaW1hZ2VNaW5XaWR0aDoxNixpbWFnZU91dHB1dFNpemU6ITEsaW1hZ2VEZWZhdWx0TWFyZ2luOjV9KSxhLkZFLlBMVUdJTlMuaW1hZ2U9ZnVuY3Rpb24oYil7ZnVuY3Rpb24gYygpe3ZhciBhPWIucG9wdXBzLmdldChcXFwiaW1hZ2UuaW5zZXJ0XFxcIiksYz1hLmZpbmQoXFxcIi5mci1pbWFnZS1ieS11cmwtbGF5ZXIgaW5wdXRcXFwiKTtjLnZhbChcXFwiXFxcIikseGEmJmMudmFsKHhhLmF0dHIoXFxcInNyY1xcXCIpKSxjLnRyaWdnZXIoXFxcImNoYW5nZVxcXCIpfWZ1bmN0aW9uIGQoKXt2YXIgYT1iLiR0Yi5maW5kKCcuZnItY29tbWFuZFtkYXRhLWNtZD1cXFwiaW5zZXJ0SW1hZ2VcXFwiXScpLGM9Yi5wb3B1cHMuZ2V0KFxcXCJpbWFnZS5pbnNlcnRcXFwiKTtpZihjfHwoYz1NKCkpLHMoKSwhYy5oYXNDbGFzcyhcXFwiZnItYWN0aXZlXFxcIikpaWYoYi5wb3B1cHMucmVmcmVzaChcXFwiaW1hZ2UuaW5zZXJ0XFxcIiksYi5wb3B1cHMuc2V0Q29udGFpbmVyKFxcXCJpbWFnZS5pbnNlcnRcXFwiLGIuJHRiKSxhLmlzKFxcXCI6dmlzaWJsZVxcXCIpKXt2YXIgZD1hLm9mZnNldCgpLmxlZnQrYS5vdXRlcldpZHRoKCkvMixlPWEub2Zmc2V0KCkudG9wKyhiLm9wdHMudG9vbGJhckJvdHRvbT8xMDphLm91dGVySGVpZ2h0KCktMTApO2IucG9wdXBzLnNob3coXFxcImltYWdlLmluc2VydFxcXCIsZCxlLGEub3V0ZXJIZWlnaHQoKSl9ZWxzZSBiLnBvc2l0aW9uLmZvclNlbGVjdGlvbihjKSxiLnBvcHVwcy5zaG93KFxcXCJpbWFnZS5pbnNlcnRcXFwiKX1mdW5jdGlvbiBlKCl7dmFyIGE9Yi5wb3B1cHMuZ2V0KFxcXCJpbWFnZS5lZGl0XFxcIik7aWYoYXx8KGE9cSgpKSxhKXtiLnBvcHVwcy5zZXRDb250YWluZXIoXFxcImltYWdlLmVkaXRcXFwiLGIuJHNjKSxiLnBvcHVwcy5yZWZyZXNoKFxcXCJpbWFnZS5lZGl0XFxcIik7dmFyIGM9eGEub2Zmc2V0KCkubGVmdCt4YS5vdXRlcldpZHRoKCkvMixkPXhhLm9mZnNldCgpLnRvcCt4YS5vdXRlckhlaWdodCgpO2IucG9wdXBzLnNob3coXFxcImltYWdlLmVkaXRcXFwiLGMsZCx4YS5vdXRlckhlaWdodCgpKX19ZnVuY3Rpb24gZigpe3MoKX1mdW5jdGlvbiBnKGEpe2EuaGFzQ2xhc3MoXFxcImZyLWRpaVxcXCIpfHxhLmhhc0NsYXNzKFxcXCJmci1kaWJcXFwiKXx8KGEuYWRkQ2xhc3MoXFxcImZyLWZpXFxcIittYShhKVswXSksYS5hZGRDbGFzcyhcXFwiZnItZGlcXFwiK25hKGEpWzBdKSxhLmNzcyhcXFwibWFyZ2luXFxcIixcXFwiXFxcIiksYS5jc3MoXFxcImZsb2F0XFxcIixcXFwiXFxcIiksYS5jc3MoXFxcImRpc3BsYXlcXFwiLFxcXCJcXFwiKSxhLmNzcyhcXFwiei1pbmRleFxcXCIsXFxcIlxcXCIpLGEuY3NzKFxcXCJwb3NpdGlvblxcXCIsXFxcIlxcXCIpLGEuY3NzKFxcXCJvdmVyZmxvd1xcXCIsXFxcIlxcXCIpLGEuY3NzKFxcXCJ2ZXJ0aWNhbC1hbGlnblxcXCIsXFxcIlxcXCIpKX1mdW5jdGlvbiBoKGEpe3ZhciBiPWEuaGFzQ2xhc3MoXFxcImZyLWRpYlxcXCIpP1xcXCJibG9ja1xcXCI6YS5oYXNDbGFzcyhcXFwiZnItZGlpXFxcIik/XFxcImlubGluZVxcXCI6bnVsbCxjPWEuaGFzQ2xhc3MoXFxcImZyLWZpbFxcXCIpP1xcXCJsZWZ0XFxcIjphLmhhc0NsYXNzKFxcXCJmci1maXJcXFwiKT9cXFwicmlnaHRcXFwiOm1hKGEpO2thKGEsYixjKSxhLnJlbW92ZUNsYXNzKFxcXCJmci1kaWIgZnItZGlpIGZyLWZpciBmci1maWxcXFwiKX1mdW5jdGlvbiBpKCl7Zm9yKHZhciBjPVxcXCJJTUdcXFwiPT1iLmVsLnRhZ05hbWU/W2IuZWxdOmIuZWwucXVlcnlTZWxlY3RvckFsbChcXFwiaW1nXFxcIiksZD0wO2Q8Yy5sZW5ndGg7ZCsrKXt2YXIgZT1hKGNbZF0pOyFiLm9wdHMuaHRtbFVudG91Y2hlZCYmYi5vcHRzLnVzZUNsYXNzZXM/KChiLm9wdHMuaW1hZ2VFZGl0QnV0dG9ucy5pbmRleE9mKFxcXCJpbWFnZUFsaWduXFxcIik+PTB8fGIub3B0cy5pbWFnZUVkaXRCdXR0b25zLmluZGV4T2YoXFxcImltYWdlRGlzcGxheVxcXCIpPj0wKSYmZyhlKSxiLm9wdHMuaW1hZ2VUZXh0TmVhcnx8ZS5yZW1vdmVDbGFzcyhcXFwiZnItZGlpXFxcIikuYWRkQ2xhc3MoXFxcImZyLWRpYlxcXCIpKTpiLm9wdHMuaHRtbFVudG91Y2hlZHx8Yi5vcHRzLnVzZUNsYXNzZXN8fChiLm9wdHMuaW1hZ2VFZGl0QnV0dG9ucy5pbmRleE9mKFxcXCJpbWFnZUFsaWduXFxcIik+PTB8fGIub3B0cy5pbWFnZUVkaXRCdXR0b25zLmluZGV4T2YoXFxcImltYWdlRGlzcGxheVxcXCIpPj0wKSYmaChlKSxiLm9wdHMuaWZyYW1lJiZlLm9uKFxcXCJsb2FkXFxcIixiLnNpemUuc3luY0lmcmFtZSl9fWZ1bmN0aW9uIGooKXt2YXIgYyxkPUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGIuZWwucXVlcnlTZWxlY3RvckFsbChcXFwiaW1nXFxcIikpLGU9W107Zm9yKGM9MDtjPGQubGVuZ3RoO2MrKyllLnB1c2goZFtjXS5nZXRBdHRyaWJ1dGUoXFxcInNyY1xcXCIpKSxhKGRbY10pLnRvZ2dsZUNsYXNzKFxcXCJmci1kcmFnZ2FibGVcXFwiLGIub3B0cy5pbWFnZU1vdmUpLFxcXCJcXFwiPT09ZFtjXS5nZXRBdHRyaWJ1dGUoXFxcImNsYXNzXFxcIikmJmRbY10ucmVtb3ZlQXR0cmlidXRlKFxcXCJjbGFzc1xcXCIpLFxcXCJcXFwiPT09ZFtjXS5nZXRBdHRyaWJ1dGUoXFxcInN0eWxlXFxcIikmJmRbY10ucmVtb3ZlQXR0cmlidXRlKFxcXCJzdHlsZVxcXCIpO2lmKEthKWZvcihjPTA7YzxLYS5sZW5ndGg7YysrKWUuaW5kZXhPZihLYVtjXS5nZXRBdHRyaWJ1dGUoXFxcInNyY1xcXCIpKTwwJiZiLmV2ZW50cy50cmlnZ2VyKFxcXCJpbWFnZS5yZW1vdmVkXFxcIixbYShLYVtjXSldKTtLYT1kfWZ1bmN0aW9uIGsoKXt5YXx8WigpO3ZhciBhPWIuJHdwfHxiLiRzYzthLmFwcGVuZCh5YSkseWEuZGF0YShcXFwiaW5zdGFuY2VcXFwiLGIpO3ZhciBjPWEuc2Nyb2xsVG9wKCktKFxcXCJzdGF0aWNcXFwiIT1hLmNzcyhcXFwicG9zaXRpb25cXFwiKT9hLm9mZnNldCgpLnRvcDowKSxkPWEuc2Nyb2xsTGVmdCgpLShcXFwic3RhdGljXFxcIiE9YS5jc3MoXFxcInBvc2l0aW9uXFxcIik/YS5vZmZzZXQoKS5sZWZ0OjApO2QtPWIuaGVscGVycy5nZXRQWChhLmNzcyhcXFwiYm9yZGVyLWxlZnQtd2lkdGhcXFwiKSksYy09Yi5oZWxwZXJzLmdldFBYKGEuY3NzKFxcXCJib3JkZXItdG9wLXdpZHRoXFxcIikpLGIuJGVsLmlzKFxcXCJpbWdcXFwiKSYmKGM9MCxkPTApLHlhLmNzcyhcXFwidG9wXFxcIiwoYi5vcHRzLmlmcmFtZT94YS5vZmZzZXQoKS50b3A6eGEub2Zmc2V0KCkudG9wK2MpLTEpLmNzcyhcXFwibGVmdFxcXCIsKGIub3B0cy5pZnJhbWU/eGEub2Zmc2V0KCkubGVmdDp4YS5vZmZzZXQoKS5sZWZ0K2QpLTEpLmNzcyhcXFwid2lkdGhcXFwiLHhhLmdldCgwKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aCkuY3NzKFxcXCJoZWlnaHRcXFwiLHhhLmdldCgwKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHQpLmFkZENsYXNzKFxcXCJmci1hY3RpdmVcXFwiKX1mdW5jdGlvbiBsKGEpe3JldHVybic8ZGl2IGNsYXNzPVxcXCJmci1oYW5kbGVyIGZyLWgnK2ErJ1xcXCI+PC9kaXY+J31mdW5jdGlvbiBtKGMpe2lmKCFiLmNvcmUuc2FtZUluc3RhbmNlKHlhKSlyZXR1cm4hMDtpZihjLnByZXZlbnREZWZhdWx0KCksYy5zdG9wUHJvcGFnYXRpb24oKSxiLiRlbC5maW5kKFxcXCJpbWcuZnItZXJyb3JcXFwiKS5sZWZ0KXJldHVybiExO2IudW5kby5jYW5EbygpfHxiLnVuZG8uc2F2ZVN0ZXAoKTt2YXIgZD1jLnBhZ2VYfHxjLm9yaWdpbmFsRXZlbnQudG91Y2hlc1swXS5wYWdlWCxlPWIuJG9lbC5nZXQoMCksZj1lLm93bmVyRG9jdW1lbnQsZz1mLmRlZmF1bHRWaWV3fHxmLnBhcmVudFdpbmRvdyxoPWcubG9jYXRpb24hPWcucGFyZW50LmxvY2F0aW9uO2gmJihkKz1nLmZyYW1lRWxlbWVudC5vZmZzZXRMZWZ0K2cuZnJhbWVFbGVtZW50LmNsaWVudExlZnQpLHphPWEodGhpcyksemEuZGF0YShcXFwic3RhcnQteFxcXCIsZCksemEuZGF0YShcXFwic3RhcnQtd2lkdGhcXFwiLHhhLndpZHRoKCkpLHphLmRhdGEoXFxcInN0YXJ0LWhlaWdodFxcXCIseGEuaGVpZ2h0KCkpO3ZhciBpPXhhLndpZHRoKCk7aWYoYi5vcHRzLmltYWdlUmVzaXplV2l0aFBlcmNlbnQpe3ZhciBqPXhhLnBhcmVudHNVbnRpbChiLiRlbCxiLmh0bWwuYmxvY2tUYWdzUXVlcnkoKSkuZ2V0KDApfHxiLmVsO3hhLmNzcyhcXFwid2lkdGhcXFwiLChpL2Eoaikub3V0ZXJXaWR0aCgpKjEwMCkudG9GaXhlZCgyKStcXFwiJVxcXCIpfWVsc2UgeGEuY3NzKFxcXCJ3aWR0aFxcXCIsaSk7QWEuc2hvdygpLGIucG9wdXBzLmhpZGVBbGwoKSxpYSgpfWZ1bmN0aW9uIG4oYyl7aWYoIWIuY29yZS5zYW1lSW5zdGFuY2UoeWEpKXJldHVybiEwO3ZhciBkO2lmKHphJiZ4YSl7aWYoYy5wcmV2ZW50RGVmYXVsdCgpLGIuJGVsLmZpbmQoXFxcImltZy5mci1lcnJvclxcXCIpLmxlZnQpcmV0dXJuITE7dmFyIGU9Yy5wYWdlWHx8KGMub3JpZ2luYWxFdmVudC50b3VjaGVzP2Mub3JpZ2luYWxFdmVudC50b3VjaGVzWzBdLnBhZ2VYOm51bGwpO2lmKCFlKXJldHVybiExO3ZhciBmPXphLmRhdGEoXFxcInN0YXJ0LXhcXFwiKSxnPWUtZixoPXphLmRhdGEoXFxcInN0YXJ0LXdpZHRoXFxcIik7aWYoKHphLmhhc0NsYXNzKFxcXCJmci1obndcXFwiKXx8emEuaGFzQ2xhc3MoXFxcImZyLWhzd1xcXCIpKSYmKGc9MC1nKSxiLm9wdHMuaW1hZ2VSZXNpemVXaXRoUGVyY2VudCl7dmFyIGk9eGEucGFyZW50c1VudGlsKGIuJGVsLGIuaHRtbC5ibG9ja1RhZ3NRdWVyeSgpKS5nZXQoMCl8fGIuZWw7aD0oKGgrZykvYShpKS5vdXRlcldpZHRoKCkqMTAwKS50b0ZpeGVkKDIpLGIub3B0cy5pbWFnZVJvdW5kUGVyY2VudCYmKGg9TWF0aC5yb3VuZChoKSkseGEuY3NzKFxcXCJ3aWR0aFxcXCIsaCtcXFwiJVxcXCIpLGQ9KGIuaGVscGVycy5nZXRQWCh4YS5jc3MoXFxcIndpZHRoXFxcIikpL2EoaSkub3V0ZXJXaWR0aCgpKjEwMCkudG9GaXhlZCgyKSxkIT09aCYmeGEuY3NzKFxcXCJ3aWR0aFxcXCIsZCtcXFwiJVxcXCIpLHhhLmNzcyhcXFwiaGVpZ2h0XFxcIixcXFwiXFxcIikucmVtb3ZlQXR0cihcXFwiaGVpZ2h0XFxcIil9ZWxzZSBoK2c+PWIub3B0cy5pbWFnZU1pbldpZHRoJiZ4YS5jc3MoXFxcIndpZHRoXFxcIixoK2cpLGQ9Yi5oZWxwZXJzLmdldFBYKHhhLmNzcyhcXFwid2lkdGhcXFwiKSksZCE9PWgrZyYmeGEuY3NzKFxcXCJ3aWR0aFxcXCIsZCkseGEuY3NzKFxcXCJoZWlnaHRcXFwiLHphLmRhdGEoXFxcInN0YXJ0LWhlaWdodFxcXCIpKnhhLndpZHRoKCkvemEuZGF0YShcXFwic3RhcnQtd2lkdGhcXFwiKSk7aygpLGIuZXZlbnRzLnRyaWdnZXIoXFxcImltYWdlLnJlc2l6ZVxcXCIsW3ZhKCldKX19ZnVuY3Rpb24gbyhhKXtpZighYi5jb3JlLnNhbWVJbnN0YW5jZSh5YSkpcmV0dXJuITA7aWYoemEmJnhhKXtpZihhJiZhLnN0b3BQcm9wYWdhdGlvbigpLGIuJGVsLmZpbmQoXFxcImltZy5mci1lcnJvclxcXCIpLmxlZnQpcmV0dXJuITE7emE9bnVsbCxBYS5oaWRlKCksaygpLGUoKSxiLnVuZG8uc2F2ZVN0ZXAoKSxiLmV2ZW50cy50cmlnZ2VyKFxcXCJpbWFnZS5yZXNpemVFbmRcXFwiLFt2YSgpXSl9fWZ1bmN0aW9uIHAoYSxjKXtiLmVkaXQub24oKSx4YSYmeGEuYWRkQ2xhc3MoXFxcImZyLWVycm9yXFxcIiksdShiLmxhbmd1YWdlLnRyYW5zbGF0ZShcXFwiU29tZXRoaW5nIHdlbnQgd3JvbmcuIFBsZWFzZSB0cnkgYWdhaW4uXFxcIikpLGIuZXZlbnRzLnRyaWdnZXIoXFxcImltYWdlLmVycm9yXFxcIixbe2NvZGU6YSxtZXNzYWdlOkphW2FdfSxjXSl9ZnVuY3Rpb24gcShhKXtpZihhKXJldHVybiBiLiR3cCYmYi5ldmVudHMuJG9uKGIuJHdwLFxcXCJzY3JvbGxcXFwiLGZ1bmN0aW9uKCl7eGEmJmIucG9wdXBzLmlzVmlzaWJsZShcXFwiaW1hZ2UuZWRpdFxcXCIpJiYoYi5ldmVudHMuZGlzYWJsZUJsdXIoKSx3KHhhKSl9KSwhMDt2YXIgYz1cXFwiXFxcIjtpZihiLm9wdHMuaW1hZ2VFZGl0QnV0dG9ucy5sZW5ndGg+MCl7Yys9JzxkaXYgY2xhc3M9XFxcImZyLWJ1dHRvbnNcXFwiPicsYys9Yi5idXR0b24uYnVpbGRMaXN0KGIub3B0cy5pbWFnZUVkaXRCdXR0b25zKSxjKz1cXFwiPC9kaXY+XFxcIjt2YXIgZD17YnV0dG9uczpjfSxlPWIucG9wdXBzLmNyZWF0ZShcXFwiaW1hZ2UuZWRpdFxcXCIsZCk7cmV0dXJuIGV9cmV0dXJuITF9ZnVuY3Rpb24gcihhKXt2YXIgYz1iLnBvcHVwcy5nZXQoXFxcImltYWdlLmluc2VydFxcXCIpO2lmKGN8fChjPU0oKSksYy5maW5kKFxcXCIuZnItbGF5ZXIuZnItYWN0aXZlXFxcIikucmVtb3ZlQ2xhc3MoXFxcImZyLWFjdGl2ZVxcXCIpLmFkZENsYXNzKFxcXCJmci1wYWN0aXZlXFxcIiksYy5maW5kKFxcXCIuZnItaW1hZ2UtcHJvZ3Jlc3MtYmFyLWxheWVyXFxcIikuYWRkQ2xhc3MoXFxcImZyLWFjdGl2ZVxcXCIpLGMuZmluZChcXFwiLmZyLWJ1dHRvbnNcXFwiKS5oaWRlKCkseGEpe2IucG9wdXBzLnNldENvbnRhaW5lcihcXFwiaW1hZ2UuaW5zZXJ0XFxcIixiLiRzYyk7dmFyIGQ9eGEub2Zmc2V0KCkubGVmdCt4YS53aWR0aCgpLzIsZT14YS5vZmZzZXQoKS50b3AreGEuaGVpZ2h0KCk7Yi5wb3B1cHMuc2hvdyhcXFwiaW1hZ2UuaW5zZXJ0XFxcIixkLGUseGEub3V0ZXJIZWlnaHQoKSl9XFxcInVuZGVmaW5lZFxcXCI9PXR5cGVvZiBhJiZ0KFxcXCJVcGxvYWRpbmdcXFwiLDApfWZ1bmN0aW9uIHMoYSl7dmFyIGM9Yi5wb3B1cHMuZ2V0KFxcXCJpbWFnZS5pbnNlcnRcXFwiKTtpZihjJiYoYy5maW5kKFxcXCIuZnItbGF5ZXIuZnItcGFjdGl2ZVxcXCIpLmFkZENsYXNzKFxcXCJmci1hY3RpdmVcXFwiKS5yZW1vdmVDbGFzcyhcXFwiZnItcGFjdGl2ZVxcXCIpLGMuZmluZChcXFwiLmZyLWltYWdlLXByb2dyZXNzLWJhci1sYXllclxcXCIpLnJlbW92ZUNsYXNzKFxcXCJmci1hY3RpdmVcXFwiKSxjLmZpbmQoXFxcIi5mci1idXR0b25zXFxcIikuc2hvdygpLGF8fGIuJGVsLmZpbmQoXFxcImltZy5mci1lcnJvclxcXCIpLmxlbmd0aCkpe2lmKGIuZXZlbnRzLmZvY3VzKCksYi4kZWwuZmluZChcXFwiaW1nLmZyLWVycm9yXFxcIikubGVuZ3RoJiYoYi4kZWwuZmluZChcXFwiaW1nLmZyLWVycm9yXFxcIikucmVtb3ZlKCksYi51bmRvLnNhdmVTdGVwKCksYi51bmRvLnJ1bigpLGIudW5kby5kcm9wUmVkbygpKSwhYi4kd3AmJnhhKXt2YXIgZD14YTtnYSghMCksYi5zZWxlY3Rpb24uc2V0QWZ0ZXIoZC5nZXQoMCkpLGIuc2VsZWN0aW9uLnJlc3RvcmUoKX1iLnBvcHVwcy5oaWRlKFxcXCJpbWFnZS5pbnNlcnRcXFwiKX19ZnVuY3Rpb24gdChhLGMpe3ZhciBkPWIucG9wdXBzLmdldChcXFwiaW1hZ2UuaW5zZXJ0XFxcIik7aWYoZCl7dmFyIGU9ZC5maW5kKFxcXCIuZnItaW1hZ2UtcHJvZ3Jlc3MtYmFyLWxheWVyXFxcIik7ZS5maW5kKFxcXCJoM1xcXCIpLnRleHQoYSsoYz9cXFwiIFxcXCIrYytcXFwiJVxcXCI6XFxcIlxcXCIpKSxlLnJlbW92ZUNsYXNzKFxcXCJmci1lcnJvclxcXCIpLGM/KGUuZmluZChcXFwiZGl2XFxcIikucmVtb3ZlQ2xhc3MoXFxcImZyLWluZGV0ZXJtaW5hdGVcXFwiKSxlLmZpbmQoXFxcImRpdiA+IHNwYW5cXFwiKS5jc3MoXFxcIndpZHRoXFxcIixjK1xcXCIlXFxcIikpOmUuZmluZChcXFwiZGl2XFxcIikuYWRkQ2xhc3MoXFxcImZyLWluZGV0ZXJtaW5hdGVcXFwiKX19ZnVuY3Rpb24gdShhKXtyKCk7dmFyIGM9Yi5wb3B1cHMuZ2V0KFxcXCJpbWFnZS5pbnNlcnRcXFwiKSxkPWMuZmluZChcXFwiLmZyLWltYWdlLXByb2dyZXNzLWJhci1sYXllclxcXCIpO2QuYWRkQ2xhc3MoXFxcImZyLWVycm9yXFxcIik7dmFyIGU9ZC5maW5kKFxcXCJoM1xcXCIpO2UudGV4dChhKSxiLmV2ZW50cy5kaXNhYmxlQmx1cigpLGUuZm9jdXMoKX1mdW5jdGlvbiB2KCl7dmFyIGE9Yi5wb3B1cHMuZ2V0KFxcXCJpbWFnZS5pbnNlcnRcXFwiKSxjPWEuZmluZChcXFwiLmZyLWltYWdlLWJ5LXVybC1sYXllciBpbnB1dFxcXCIpO2MudmFsKCkubGVuZ3RoPjAmJihyKCksdChcXFwiTG9hZGluZyBpbWFnZVxcXCIpLHkoYy52YWwoKSwhMCxbXSx4YSksYy52YWwoXFxcIlxcXCIpLGMuYmx1cigpKX1mdW5jdGlvbiB3KGEpe2ZhLmNhbGwoYS5nZXQoMCkpfWZ1bmN0aW9uIHgoKXt2YXIgYz1hKHRoaXMpO2IucG9wdXBzLmhpZGUoXFxcImltYWdlLmluc2VydFxcXCIpLGMucmVtb3ZlQ2xhc3MoXFxcImZyLXVwbG9hZGluZ1xcXCIpLGMubmV4dCgpLmlzKFxcXCJiclxcXCIpJiZjLm5leHQoKS5yZW1vdmUoKSx3KGMpLGIuZXZlbnRzLnRyaWdnZXIoXFxcImltYWdlLmxvYWRlZFxcXCIsW2NdKX1mdW5jdGlvbiB5KGEsYyxkLGUsZil7Yi5lZGl0Lm9mZigpLHQoXFxcIkxvYWRpbmcgaW1hZ2VcXFwiKSxjJiYoYT1iLmhlbHBlcnMuc2FuaXRpemVVUkwoYSkpO3ZhciBnPW5ldyBJbWFnZTtnLm9ubG9hZD1mdW5jdGlvbigpe3ZhciBjLGc7aWYoZSl7Yi51bmRvLmNhbkRvKCl8fGUuaGFzQ2xhc3MoXFxcImZyLXVwbG9hZGluZ1xcXCIpfHxiLnVuZG8uc2F2ZVN0ZXAoKTt2YXIgaD1lLmRhdGEoXFxcImZyLW9sZC1zcmNcXFwiKTtiLiR3cD8oYz1lLmNsb25lKCkucmVtb3ZlRGF0YShcXFwiZnItb2xkLXNyY1xcXCIpLnJlbW92ZUNsYXNzKFxcXCJmci11cGxvYWRpbmdcXFwiKSxjLm9mZihcXFwibG9hZFxcXCIpLGgmJmUuYXR0cihcXFwic3JjXFxcIixoKSxlLnJlcGxhY2VXaXRoKGMpKTpjPWU7Zm9yKHZhciBpPWMuZ2V0KDApLmF0dHJpYnV0ZXMsaz0wO2s8aS5sZW5ndGg7aysrKXt2YXIgbD1pW2tdOzA9PT1sLm5vZGVOYW1lLmluZGV4T2YoXFxcImRhdGEtXFxcIikmJmMucmVtb3ZlQXR0cihsLm5vZGVOYW1lKX1pZihcXFwidW5kZWZpbmVkXFxcIiE9dHlwZW9mIGQpZm9yKGcgaW4gZClkLmhhc093blByb3BlcnR5KGcpJiZcXFwibGlua1xcXCIhPWcmJmMuYXR0cihcXFwiZGF0YS1cXFwiK2csZFtnXSk7Yy5vbihcXFwibG9hZFxcXCIseCksYy5hdHRyKFxcXCJzcmNcXFwiLGEpLGIuZWRpdC5vbigpLGooKSxiLnVuZG8uc2F2ZVN0ZXAoKSxiLiRlbC5ibHVyKCksYi5ldmVudHMudHJpZ2dlcihoP1xcXCJpbWFnZS5yZXBsYWNlZFxcXCI6XFxcImltYWdlLmluc2VydGVkXFxcIixbYyxmXSl9ZWxzZSBjPUUoYSxkLHgpLGooKSxiLnVuZG8uc2F2ZVN0ZXAoKSxiLmV2ZW50cy50cmlnZ2VyKFxcXCJpbWFnZS5pbnNlcnRlZFxcXCIsW2MsZl0pfSxnLm9uZXJyb3I9ZnVuY3Rpb24oKXtwKENhKX0scihcXFwiTG9hZGluZyBpbWFnZVxcXCIpLGcuc3JjPWF9ZnVuY3Rpb24geihjKXt0cnl7aWYoYi5ldmVudHMudHJpZ2dlcihcXFwiaW1hZ2UudXBsb2FkZWRcXFwiLFtjXSwhMCk9PT0hMSlyZXR1cm4gYi5lZGl0Lm9uKCksITE7dmFyIGQ9YS5wYXJzZUpTT04oYyk7cmV0dXJuIGQubGluaz9kOihwKERhLGMpLCExKX1jYXRjaChlKXtyZXR1cm4gcChGYSxjKSwhMX19ZnVuY3Rpb24gQShjKXt0cnl7dmFyIGQ9YShjKS5maW5kKFxcXCJMb2NhdGlvblxcXCIpLnRleHQoKSxlPWEoYykuZmluZChcXFwiS2V5XFxcIikudGV4dCgpO3JldHVybiBiLmV2ZW50cy50cmlnZ2VyKFxcXCJpbWFnZS51cGxvYWRlZFRvUzNcXFwiLFtkLGUsY10sITApPT09ITE/KGIuZWRpdC5vbigpLCExKTpkfWNhdGNoKGYpe3JldHVybiBwKEZhLGMpLCExfX1mdW5jdGlvbiBCKGEpe3QoXFxcIkxvYWRpbmcgaW1hZ2VcXFwiKTt2YXIgYz10aGlzLnN0YXR1cyxkPXRoaXMucmVzcG9uc2UsZT10aGlzLnJlc3BvbnNlWE1MLGY9dGhpcy5yZXNwb25zZVRleHQ7dHJ5e2lmKGIub3B0cy5pbWFnZVVwbG9hZFRvUzMpaWYoMjAxPT1jKXt2YXIgZz1BKGUpO2cmJnkoZywhMSxbXSxhLGR8fGUpfWVsc2UgcChGYSxkfHxlKTtlbHNlIGlmKGM+PTIwMCYmYzwzMDApe3ZhciBoPXooZik7aCYmeShoLmxpbmssITEsaCxhLGR8fGYpfWVsc2UgcChFYSxkfHxmKX1jYXRjaChpKXtwKEZhLGR8fGYpfX1mdW5jdGlvbiBDKCl7cChGYSx0aGlzLnJlc3BvbnNlfHx0aGlzLnJlc3BvbnNlVGV4dHx8dGhpcy5yZXNwb25zZVhNTCl9ZnVuY3Rpb24gRChhKXtpZihhLmxlbmd0aENvbXB1dGFibGUpe3ZhciBiPWEubG9hZGVkL2EudG90YWwqMTAwfDA7dChcXFwiVXBsb2FkaW5nXFxcIixiKX19ZnVuY3Rpb24gRShjLGQsZSl7dmFyIGYsZz1cXFwiXFxcIjtpZihkJiZcXFwidW5kZWZpbmVkXFxcIiE9dHlwZW9mIGQpZm9yKGYgaW4gZClkLmhhc093blByb3BlcnR5KGYpJiZcXFwibGlua1xcXCIhPWYmJihnKz1cXFwiIGRhdGEtXFxcIitmKyc9XFxcIicrZFtmXSsnXFxcIicpO3ZhciBoPWIub3B0cy5pbWFnZURlZmF1bHRXaWR0aDtoJiZcXFwiYXV0b1xcXCIhPWgmJihoKz1iLm9wdHMuaW1hZ2VSZXNpemVXaXRoUGVyY2VudD9cXFwiJVxcXCI6XFxcInB4XFxcIik7dmFyIGk9YSgnPGltZyBzcmM9XFxcIicrYysnXFxcIicrZysoaD8nIHN0eWxlPVxcXCJ3aWR0aDogJytoKyc7XFxcIic6XFxcIlxcXCIpK1xcXCI+XFxcIik7a2EoaSxiLm9wdHMuaW1hZ2VEZWZhdWx0RGlzcGxheSxiLm9wdHMuaW1hZ2VEZWZhdWx0QWxpZ24pLGkub24oXFxcImxvYWRcXFwiLGUpLGIuZWRpdC5vbigpLGIuZXZlbnRzLmZvY3VzKCEwKSxiLnNlbGVjdGlvbi5yZXN0b3JlKCksYi51bmRvLnNhdmVTdGVwKCksYi5vcHRzLmltYWdlU3BsaXRIVE1MP2IubWFya2Vycy5zcGxpdCgpOmIubWFya2Vycy5pbnNlcnQoKTt2YXIgaj1iLiRlbC5maW5kKFxcXCIuZnItbWFya2VyXFxcIik7cmV0dXJuIGoucmVwbGFjZVdpdGgoaSksYi5odG1sLndyYXAoKSxiLnNlbGVjdGlvbi5jbGVhcigpLGl9ZnVuY3Rpb24gRigpe2IuZWRpdC5vbigpLHMoITApfWZ1bmN0aW9uIEcoYyxkLGUpe2Z1bmN0aW9uIGYoKXt2YXIgZT1hKHRoaXMpO2Uub2ZmKFxcXCJsb2FkXFxcIiksZS5hZGRDbGFzcyhcXFwiZnItdXBsb2FkaW5nXFxcIiksZS5uZXh0KCkuaXMoXFxcImJyXFxcIikmJmUubmV4dCgpLnJlbW92ZSgpLGIucGxhY2Vob2xkZXIucmVmcmVzaCgpLGUuaXMoeGEpfHx3KGUpLGsoKSxyKCksYi5lZGl0Lm9mZigpLGMub25sb2FkPWZ1bmN0aW9uKCl7Qi5jYWxsKGMsZSl9LGMub25lcnJvcj1DLGMudXBsb2FkLm9ucHJvZ3Jlc3M9RCxjLm9uYWJvcnQ9RixlLm9mZihcXFwiYWJvcnRVcGxvYWRcXFwiKS5vbihcXFwiYWJvcnRVcGxvYWRcXFwiLGZ1bmN0aW9uKCl7NCE9Yy5yZWFkeVN0YXRlJiZjLmFib3J0KCl9KSxjLnNlbmQoZCl9dmFyIGcsaD1uZXcgRmlsZVJlYWRlcjtoLmFkZEV2ZW50TGlzdGVuZXIoXFxcImxvYWRcXFwiLGZ1bmN0aW9uKCl7dmFyIGE9aC5yZXN1bHQ7aWYoaC5yZXN1bHQuaW5kZXhPZihcXFwic3ZnK3htbFxcXCIpPDApe2Zvcih2YXIgYz1hdG9iKGgucmVzdWx0LnNwbGl0KFxcXCIsXFxcIilbMV0pLGQ9W10sZT0wO2U8Yy5sZW5ndGg7ZSsrKWQucHVzaChjLmNoYXJDb2RlQXQoZSkpO2E9d2luZG93LlVSTC5jcmVhdGVPYmplY3RVUkwobmV3IEJsb2IoW25ldyBVaW50OEFycmF5KGQpXSx7dHlwZTpcXFwiaW1hZ2UvanBlZ1xcXCJ9KSl9eGE/KHhhLm9uKFxcXCJsb2FkXFxcIixmKSxiLmVkaXQub24oKSxiLnVuZG8uc2F2ZVN0ZXAoKSx4YS5kYXRhKFxcXCJmci1vbGQtc3JjXFxcIix4YS5hdHRyKFxcXCJzcmNcXFwiKSkseGEuYXR0cihcXFwic3JjXFxcIixhKSk6Zz1FKGEsbnVsbCxmKX0sITEpLGgucmVhZEFzRGF0YVVSTChlKX1mdW5jdGlvbiBIKGEpe2lmKFxcXCJ1bmRlZmluZWRcXFwiIT10eXBlb2YgYSYmYS5sZW5ndGg+MCl7aWYoYi5ldmVudHMudHJpZ2dlcihcXFwiaW1hZ2UuYmVmb3JlVXBsb2FkXFxcIixbYV0pPT09ITEpcmV0dXJuITE7dmFyIGM9YVswXTtpZihjLnNpemU+Yi5vcHRzLmltYWdlTWF4U2l6ZSlyZXR1cm4gcChHYSksITE7aWYoYi5vcHRzLmltYWdlQWxsb3dlZFR5cGVzLmluZGV4T2YoYy50eXBlLnJlcGxhY2UoL2ltYWdlXFxcXC8vZyxcXFwiXFxcIikpPDApcmV0dXJuIHAoSGEpLCExO3ZhciBkO2lmKGIuZHJhZ19zdXBwb3J0LmZvcm1kYXRhJiYoZD1iLmRyYWdfc3VwcG9ydC5mb3JtZGF0YT9uZXcgRm9ybURhdGE6bnVsbCksZCl7dmFyIGU7aWYoYi5vcHRzLmltYWdlVXBsb2FkVG9TMyE9PSExKXtkLmFwcGVuZChcXFwia2V5XFxcIixiLm9wdHMuaW1hZ2VVcGxvYWRUb1MzLmtleVN0YXJ0KyhuZXcgRGF0ZSkuZ2V0VGltZSgpK1xcXCItXFxcIisoYy5uYW1lfHxcXFwidW50aXRsZWRcXFwiKSksZC5hcHBlbmQoXFxcInN1Y2Nlc3NfYWN0aW9uX3N0YXR1c1xcXCIsXFxcIjIwMVxcXCIpLGQuYXBwZW5kKFxcXCJYLVJlcXVlc3RlZC1XaXRoXFxcIixcXFwieGhyXFxcIiksZC5hcHBlbmQoXFxcIkNvbnRlbnQtVHlwZVxcXCIsYy50eXBlKTtmb3IoZSBpbiBiLm9wdHMuaW1hZ2VVcGxvYWRUb1MzLnBhcmFtcyliLm9wdHMuaW1hZ2VVcGxvYWRUb1MzLnBhcmFtcy5oYXNPd25Qcm9wZXJ0eShlKSYmZC5hcHBlbmQoZSxiLm9wdHMuaW1hZ2VVcGxvYWRUb1MzLnBhcmFtc1tlXSl9Zm9yKGUgaW4gYi5vcHRzLmltYWdlVXBsb2FkUGFyYW1zKWIub3B0cy5pbWFnZVVwbG9hZFBhcmFtcy5oYXNPd25Qcm9wZXJ0eShlKSYmZC5hcHBlbmQoZSxiLm9wdHMuaW1hZ2VVcGxvYWRQYXJhbXNbZV0pO2QuYXBwZW5kKGIub3B0cy5pbWFnZVVwbG9hZFBhcmFtLGMpO3ZhciBmPWIub3B0cy5pbWFnZVVwbG9hZFVSTDtiLm9wdHMuaW1hZ2VVcGxvYWRUb1MzJiYoZj1iLm9wdHMuaW1hZ2VVcGxvYWRUb1MzLnVwbG9hZFVSTD9iLm9wdHMuaW1hZ2VVcGxvYWRUb1MzLnVwbG9hZFVSTDpcXFwiaHR0cHM6Ly9cXFwiK2Iub3B0cy5pbWFnZVVwbG9hZFRvUzMucmVnaW9uK1xcXCIuYW1hem9uYXdzLmNvbS9cXFwiK2Iub3B0cy5pbWFnZVVwbG9hZFRvUzMuYnVja2V0KTt2YXIgZz1iLmNvcmUuZ2V0WEhSKGYsYi5vcHRzLmltYWdlVXBsb2FkTWV0aG9kKTtHKGcsZCxjKX19fWZ1bmN0aW9uIEkoYyl7Yi5ldmVudHMuJG9uKGMsXFxcImRyYWdvdmVyIGRyYWdlbnRlclxcXCIsXFxcIi5mci1pbWFnZS11cGxvYWQtbGF5ZXJcXFwiLGZ1bmN0aW9uKCl7cmV0dXJuIGEodGhpcykuYWRkQ2xhc3MoXFxcImZyLWRyb3BcXFwiKSwhMX0pLGIuZXZlbnRzLiRvbihjLFxcXCJkcmFnbGVhdmUgZHJhZ2VuZFxcXCIsXFxcIi5mci1pbWFnZS11cGxvYWQtbGF5ZXJcXFwiLGZ1bmN0aW9uKCl7cmV0dXJuIGEodGhpcykucmVtb3ZlQ2xhc3MoXFxcImZyLWRyb3BcXFwiKSwhMX0pLGIuZXZlbnRzLiRvbihjLFxcXCJkcm9wXFxcIixcXFwiLmZyLWltYWdlLXVwbG9hZC1sYXllclxcXCIsZnVuY3Rpb24oZCl7ZC5wcmV2ZW50RGVmYXVsdCgpLGQuc3RvcFByb3BhZ2F0aW9uKCksYSh0aGlzKS5yZW1vdmVDbGFzcyhcXFwiZnItZHJvcFxcXCIpO3ZhciBlPWQub3JpZ2luYWxFdmVudC5kYXRhVHJhbnNmZXI7aWYoZSYmZS5maWxlcyl7dmFyIGY9Yy5kYXRhKFxcXCJpbnN0YW5jZVxcXCIpfHxiO2YuZXZlbnRzLmRpc2FibGVCbHVyKCksZi5pbWFnZS51cGxvYWQoZS5maWxlcyksZi5ldmVudHMuZW5hYmxlQmx1cigpfX0pLGIuZXZlbnRzLiRvbihjLFxcXCJjaGFuZ2VcXFwiLCcuZnItaW1hZ2UtdXBsb2FkLWxheWVyIGlucHV0W3R5cGU9XFxcImZpbGVcXFwiXScsZnVuY3Rpb24oKXtpZih0aGlzLmZpbGVzKXt2YXIgZD1jLmRhdGEoXFxcImluc3RhbmNlXFxcIil8fGI7ZC5ldmVudHMuZGlzYWJsZUJsdXIoKSxjLmZpbmQoXFxcImlucHV0OmZvY3VzXFxcIikuYmx1cigpLGQuZXZlbnRzLmVuYWJsZUJsdXIoKSxkLmltYWdlLnVwbG9hZCh0aGlzLmZpbGVzKX1hKHRoaXMpLnZhbChcXFwiXFxcIil9KX1mdW5jdGlvbiBKKGMpe3ZhciBkPWMub3JpZ2luYWxFdmVudC5kYXRhVHJhbnNmZXI7aWYoZCYmZC5maWxlcyYmZC5maWxlcy5sZW5ndGgpe3ZhciBlPWQuZmlsZXNbMF07aWYoZSYmZS50eXBlJiZlLnR5cGUuaW5kZXhPZihcXFwiaW1hZ2VcXFwiKSE9PS0xKXtiLm1hcmtlcnMucmVtb3ZlKCksYi5tYXJrZXJzLmluc2VydEF0UG9pbnQoYy5vcmlnaW5hbEV2ZW50KSxiLiRlbC5maW5kKFxcXCIuZnItbWFya2VyXFxcIikucmVwbGFjZVdpdGgoYS5GRS5NQVJLRVJTKSxiLnBvcHVwcy5oaWRlQWxsKCk7dmFyIGY9Yi5wb3B1cHMuZ2V0KFxcXCJpbWFnZS5pbnNlcnRcXFwiKTtyZXR1cm4gZnx8KGY9TSgpKSxiLnBvcHVwcy5zZXRDb250YWluZXIoXFxcImltYWdlLmluc2VydFxcXCIsYi4kc2MpLGIucG9wdXBzLnNob3coXFxcImltYWdlLmluc2VydFxcXCIsYy5vcmlnaW5hbEV2ZW50LnBhZ2VYLGMub3JpZ2luYWxFdmVudC5wYWdlWSkscigpLGIub3B0cy5pbWFnZUFsbG93ZWRUeXBlcy5pbmRleE9mKGUudHlwZS5yZXBsYWNlKC9pbWFnZVxcXFwvL2csXFxcIlxcXCIpKT49MD9IKGQuZmlsZXMpOnAoSGEpLGMucHJldmVudERlZmF1bHQoKSxjLnN0b3BQcm9wYWdhdGlvbigpLCExfX19ZnVuY3Rpb24gSygpe3ZhciBjLGQsZT1iLnNlbGVjdGlvbi5yYW5nZXMoMCk7ZS5jb2xsYXBzZWQmJmUuc3RhcnRDb250YWluZXIubm9kZVR5cGU9PU5vZGUuRUxFTUVOVF9OT0RFJiYoZS5zdGFydENvbnRhaW5lci5jaGlsZE5vZGVzLmxlbmd0aD09ZS5zdGFydE9mZnNldD8oYz1lLnN0YXJ0Q29udGFpbmVyLmNoaWxkTm9kZXNbZS5zdGFydE9mZnNldC0xXSxjJiZcXFwiSU1HXFxcIj09Yy50YWdOYW1lJiZcXFwiYmxvY2tcXFwiPT1hKGMpLmNzcyhcXFwiZGlzcGxheVxcXCIpJiYoZD1iLm5vZGUuYmxvY2tQYXJlbnQoYyksZCYmYi5odG1sLmRlZmF1bHRUYWcoKT9kLm5leHRTaWJsaW5nfHwoW1xcXCJURFxcXCIsXFxcIlRIXFxcIl0uaW5kZXhPZihkLnRhZ05hbWUpPDA/YShkKS5hZnRlcihcXFwiPFxcXCIrYi5odG1sLmRlZmF1bHRUYWcoKStcXFwiPjxicj5cXFwiK2EuRkUuTUFSS0VSUytcXFwiPC9cXFwiK2IuaHRtbC5kZWZhdWx0VGFnKCkrXFxcIj5cXFwiKTphKGMpLmFmdGVyKFxcXCI8YnI+XFxcIithLkZFLk1BUktFUlMpLGIuc2VsZWN0aW9uLnJlc3RvcmUoKSk6ZHx8KGEoYykuYWZ0ZXIoXFxcIjxicj5cXFwiK2EuRkUuTUFSS0VSUyksYi5zZWxlY3Rpb24ucmVzdG9yZSgpKSkpOjA9PT1lLnN0YXJ0T2Zmc2V0JiZlLnN0YXJ0Q29udGFpbmVyLmNoaWxkTm9kZXMubGVuZ3RoPmUuc3RhcnRPZmZzZXQmJihjPWUuc3RhcnRDb250YWluZXIuY2hpbGROb2Rlc1tlLnN0YXJ0T2Zmc2V0XSxjJiZcXFwiSU1HXFxcIj09Yy50YWdOYW1lJiZcXFwiYmxvY2tcXFwiPT1hKGMpLmNzcyhcXFwiZGlzcGxheVxcXCIpJiYoZD1iLm5vZGUuYmxvY2tQYXJlbnQoYyksZCYmYi5odG1sLmRlZmF1bHRUYWcoKT9kLnByZXZpb3VzU2libGluZ3x8KFtcXFwiVERcXFwiLFxcXCJUSFxcXCJdLmluZGV4T2YoZC50YWdOYW1lKTwwP2EoZCkuYmVmb3JlKFxcXCI8XFxcIitiLmh0bWwuZGVmYXVsdFRhZygpK1xcXCI+PGJyPlxcXCIrYS5GRS5NQVJLRVJTK1xcXCI8L1xcXCIrYi5odG1sLmRlZmF1bHRUYWcoKStcXFwiPlxcXCIpOmEoYykuYmVmb3JlKFxcXCI8YnI+XFxcIithLkZFLk1BUktFUlMpLGIuc2VsZWN0aW9uLnJlc3RvcmUoKSk6ZHx8KGEoYykuYmVmb3JlKGEuRkUuTUFSS0VSUytcXFwiPGJyPlxcXCIpLGIuc2VsZWN0aW9uLnJlc3RvcmUoKSkpKSl9ZnVuY3Rpb24gTCgpe2IuZXZlbnRzLiRvbihiLiRlbCxiLl9tb3VzZWRvd24sXFxcIklNR1xcXCI9PWIuZWwudGFnTmFtZT9udWxsOidpbWc6bm90KFtjb250ZW50ZWRpdGFibGU9XFxcImZhbHNlXFxcIl0pJyxmdW5jdGlvbihjKXtyZXR1cm5cXFwiZmFsc2VcXFwiPT1hKHRoaXMpLnBhcmVudHMoXFxcIltjb250ZW50ZWRpdGFibGVdOm5vdCguZnItZWxlbWVudCk6bm90KGJvZHkpOmZpcnN0XFxcIikuYXR0cihcXFwiY29udGVudGVkaXRhYmxlXFxcIil8fChiLmhlbHBlcnMuaXNNb2JpbGUoKXx8Yi5zZWxlY3Rpb24uY2xlYXIoKSxCYT0hMCxiLnBvcHVwcy5hcmVWaXNpYmxlKCkmJmIuZXZlbnRzLmRpc2FibGVCbHVyKCksYi5icm93c2VyLm1zaWUmJihiLmV2ZW50cy5kaXNhYmxlQmx1cigpLGIuJGVsLmF0dHIoXFxcImNvbnRlbnRlZGl0YWJsZVxcXCIsITEpKSxiLmRyYWdnYWJsZXx8Yy5wcmV2ZW50RGVmYXVsdCgpLHZvaWQgYy5zdG9wUHJvcGFnYXRpb24oKSl9KSxiLmV2ZW50cy4kb24oYi4kZWwsYi5fbW91c2V1cCxcXFwiSU1HXFxcIj09Yi5lbC50YWdOYW1lP251bGw6J2ltZzpub3QoW2NvbnRlbnRlZGl0YWJsZT1cXFwiZmFsc2VcXFwiXSknLGZ1bmN0aW9uKGMpe3JldHVyblxcXCJmYWxzZVxcXCI9PWEodGhpcykucGFyZW50cyhcXFwiW2NvbnRlbnRlZGl0YWJsZV06bm90KC5mci1lbGVtZW50KTpub3QoYm9keSk6Zmlyc3RcXFwiKS5hdHRyKFxcXCJjb250ZW50ZWRpdGFibGVcXFwiKXx8dm9pZChCYSYmKEJhPSExLGMuc3RvcFByb3BhZ2F0aW9uKCksYi5icm93c2VyLm1zaWUmJihiLiRlbC5hdHRyKFxcXCJjb250ZW50ZWRpdGFibGVcXFwiLCEwKSxiLmV2ZW50cy5lbmFibGVCbHVyKCkpKSl9KSxiLmV2ZW50cy5vbihcXFwia2V5dXBcXFwiLGZ1bmN0aW9uKGMpe2lmKGMuc2hpZnRLZXkmJlxcXCJcXFwiPT09Yi5zZWxlY3Rpb24udGV4dCgpLnJlcGxhY2UoL1xcXFxuL2csXFxcIlxcXCIpKXt2YXIgZD1iLnNlbGVjdGlvbi5lbGVtZW50KCksZT1iLnNlbGVjdGlvbi5lbmRFbGVtZW50KCk7ZCYmXFxcIklNR1xcXCI9PWQudGFnTmFtZT93KGEoZCkpOmUmJlxcXCJJTUdcXFwiPT1lLnRhZ05hbWUmJncoYShlKSl9fSwhMCksYi5ldmVudHMub24oXFxcImRyb3BcXFwiLEopLGIuZXZlbnRzLm9uKFxcXCJtb3VzZWRvd24gd2luZG93Lm1vdXNlZG93blxcXCIsaGEpLGIuZXZlbnRzLm9uKFxcXCJ3aW5kb3cudG91Y2htb3ZlXFxcIixpYSksYi5ldmVudHMub24oXFxcIm1vdXNldXAgd2luZG93Lm1vdXNldXBcXFwiLGZ1bmN0aW9uKCl7cmV0dXJuIHhhPyhnYSgpLCExKTp2b2lkIGlhKCl9KSxiLmV2ZW50cy5vbihcXFwiY29tbWFuZHMubW91c2Vkb3duXFxcIixmdW5jdGlvbihhKXthLnBhcmVudHMoXFxcIi5mci10b29sYmFyXFxcIikubGVuZ3RoPjAmJmdhKCl9KSxiLmJyb3dzZXIuZWRnZXx8Yi5ldmVudHMub24oXFxcIm1vdXNldXBcXFwiLEspLGIuZXZlbnRzLm9uKFxcXCJibHVyIGltYWdlLmhpZGVSZXNpemVyIGNvbW1hbmRzLnVuZG8gY29tbWFuZHMucmVkbyBlbGVtZW50LmRyb3BwZWRcXFwiLGZ1bmN0aW9uKCl7QmE9ITEsZ2EoITApfSksYi5ldmVudHMub24oXFxcIm1vZGFscy5oaWRlXFxcIixmdW5jdGlvbigpe3hhJiYodGEoKSxiLnNlbGVjdGlvbi5jbGVhcigpKX0pfWZ1bmN0aW9uIE0oYSl7aWYoYSlyZXR1cm4gYi5wb3B1cHMub25SZWZyZXNoKFxcXCJpbWFnZS5pbnNlcnRcXFwiLGMpLGIucG9wdXBzLm9uSGlkZShcXFwiaW1hZ2UuaW5zZXJ0XFxcIixmKSwhMDt2YXIgZCxlPVxcXCJcXFwiO2Iub3B0cy5pbWFnZUluc2VydEJ1dHRvbnMubGVuZ3RoPjEmJihlPSc8ZGl2IGNsYXNzPVxcXCJmci1idXR0b25zXFxcIj4nK2IuYnV0dG9uLmJ1aWxkTGlzdChiLm9wdHMuaW1hZ2VJbnNlcnRCdXR0b25zKStcXFwiPC9kaXY+XFxcIik7dmFyIGc9Yi5vcHRzLmltYWdlSW5zZXJ0QnV0dG9ucy5pbmRleE9mKFxcXCJpbWFnZVVwbG9hZFxcXCIpLGg9Yi5vcHRzLmltYWdlSW5zZXJ0QnV0dG9ucy5pbmRleE9mKFxcXCJpbWFnZUJ5VVJMXFxcIiksaT1cXFwiXFxcIjtnPj0wJiYoZD1cXFwiIGZyLWFjdGl2ZVxcXCIsaD49MCYmZz5oJiYoZD1cXFwiXFxcIiksaT0nPGRpdiBjbGFzcz1cXFwiZnItaW1hZ2UtdXBsb2FkLWxheWVyJytkKycgZnItbGF5ZXJcXFwiIGlkPVxcXCJmci1pbWFnZS11cGxvYWQtbGF5ZXItJytiLmlkKydcXFwiPjxzdHJvbmc+JytiLmxhbmd1YWdlLnRyYW5zbGF0ZShcXFwiRHJvcCBpbWFnZVxcXCIpK1xcXCI8L3N0cm9uZz48YnI+KFxcXCIrYi5sYW5ndWFnZS50cmFuc2xhdGUoXFxcIm9yIGNsaWNrXFxcIikrJyk8ZGl2IGNsYXNzPVxcXCJmci1mb3JtXFxcIj48aW5wdXQgdHlwZT1cXFwiZmlsZVxcXCIgYWNjZXB0PVxcXCJpbWFnZS8nK2Iub3B0cy5pbWFnZUFsbG93ZWRUeXBlcy5qb2luKFxcXCIsIGltYWdlL1xcXCIpLnRvTG93ZXJDYXNlKCkrJ1xcXCIgdGFiSW5kZXg9XFxcIi0xXFxcIiBhcmlhLWxhYmVsbGVkYnk9XFxcImZyLWltYWdlLXVwbG9hZC1sYXllci0nK2IuaWQrJ1xcXCIgcm9sZT1cXFwiYnV0dG9uXFxcIj48L2Rpdj48L2Rpdj4nKTt2YXIgaj1cXFwiXFxcIjtoPj0wJiYoZD1cXFwiIGZyLWFjdGl2ZVxcXCIsZz49MCYmaD5nJiYoZD1cXFwiXFxcIiksaj0nPGRpdiBjbGFzcz1cXFwiZnItaW1hZ2UtYnktdXJsLWxheWVyJytkKycgZnItbGF5ZXJcXFwiIGlkPVxcXCJmci1pbWFnZS1ieS11cmwtbGF5ZXItJytiLmlkKydcXFwiPjxkaXYgY2xhc3M9XFxcImZyLWlucHV0LWxpbmVcXFwiPjxpbnB1dCBpZD1cXFwiZnItaW1hZ2UtYnktdXJsLWxheWVyLXRleHQtJytiLmlkKydcXFwiIHR5cGU9XFxcInRleHRcXFwiIHBsYWNlaG9sZGVyPVxcXCJodHRwOi8vXFxcIiB0YWJJbmRleD1cXFwiMVxcXCIgYXJpYS1yZXF1aXJlZD1cXFwidHJ1ZVxcXCI+PC9kaXY+PGRpdiBjbGFzcz1cXFwiZnItYWN0aW9uLWJ1dHRvbnNcXFwiPjxidXR0b24gdHlwZT1cXFwiYnV0dG9uXFxcIiBjbGFzcz1cXFwiZnItY29tbWFuZCBmci1zdWJtaXRcXFwiIGRhdGEtY21kPVxcXCJpbWFnZUluc2VydEJ5VVJMXFxcIiB0YWJJbmRleD1cXFwiMlxcXCIgcm9sZT1cXFwiYnV0dG9uXFxcIj4nK2IubGFuZ3VhZ2UudHJhbnNsYXRlKFxcXCJJbnNlcnRcXFwiKStcXFwiPC9idXR0b24+PC9kaXY+PC9kaXY+XFxcIik7dmFyIGs9JzxkaXYgY2xhc3M9XFxcImZyLWltYWdlLXByb2dyZXNzLWJhci1sYXllciBmci1sYXllclxcXCI+PGgzIHRhYkluZGV4PVxcXCItMVxcXCIgY2xhc3M9XFxcImZyLW1lc3NhZ2VcXFwiPlVwbG9hZGluZzwvaDM+PGRpdiBjbGFzcz1cXFwiZnItbG9hZGVyXFxcIj48c3BhbiBjbGFzcz1cXFwiZnItcHJvZ3Jlc3NcXFwiPjwvc3Bhbj48L2Rpdj48ZGl2IGNsYXNzPVxcXCJmci1hY3Rpb24tYnV0dG9uc1xcXCI+PGJ1dHRvbiB0eXBlPVxcXCJidXR0b25cXFwiIGNsYXNzPVxcXCJmci1jb21tYW5kIGZyLWRpc21pc3NcXFwiIGRhdGEtY21kPVxcXCJpbWFnZURpc21pc3NFcnJvclxcXCIgdGFiSW5kZXg9XFxcIjJcXFwiIHJvbGU9XFxcImJ1dHRvblxcXCI+T0s8L2J1dHRvbj48L2Rpdj48L2Rpdj4nLGw9e2J1dHRvbnM6ZSx1cGxvYWRfbGF5ZXI6aSxieV91cmxfbGF5ZXI6aixwcm9ncmVzc19iYXI6a30sbT1iLnBvcHVwcy5jcmVhdGUoXFxcImltYWdlLmluc2VydFxcXCIsbCk7cmV0dXJuIGIuJHdwJiZiLmV2ZW50cy4kb24oYi4kd3AsXFxcInNjcm9sbFxcXCIsZnVuY3Rpb24oKXt4YSYmYi5wb3B1cHMuaXNWaXNpYmxlKFxcXCJpbWFnZS5pbnNlcnRcXFwiKSYmc2EoKX0pLEkobSksbX1mdW5jdGlvbiBOKCl7aWYoeGEpe3ZhciBhPWIucG9wdXBzLmdldChcXFwiaW1hZ2UuYWx0XFxcIik7YS5maW5kKFxcXCJpbnB1dFxcXCIpLnZhbCh4YS5hdHRyKFxcXCJhbHRcXFwiKXx8XFxcIlxcXCIpLnRyaWdnZXIoXFxcImNoYW5nZVxcXCIpfX1mdW5jdGlvbiBPKCl7dmFyIGE9Yi5wb3B1cHMuZ2V0KFxcXCJpbWFnZS5hbHRcXFwiKTthfHwoYT1QKCkpLHMoKSxiLnBvcHVwcy5yZWZyZXNoKFxcXCJpbWFnZS5hbHRcXFwiKSxiLnBvcHVwcy5zZXRDb250YWluZXIoXFxcImltYWdlLmFsdFxcXCIsYi4kc2MpO3ZhciBjPXhhLm9mZnNldCgpLmxlZnQreGEud2lkdGgoKS8yLGQ9eGEub2Zmc2V0KCkudG9wK3hhLmhlaWdodCgpO2IucG9wdXBzLnNob3coXFxcImltYWdlLmFsdFxcXCIsYyxkLHhhLm91dGVySGVpZ2h0KCkpfWZ1bmN0aW9uIFAoYSl7aWYoYSlyZXR1cm4gYi5wb3B1cHMub25SZWZyZXNoKFxcXCJpbWFnZS5hbHRcXFwiLE4pLCEwO3ZhciBjPVxcXCJcXFwiO2M9JzxkaXYgY2xhc3M9XFxcImZyLWJ1dHRvbnNcXFwiPicrYi5idXR0b24uYnVpbGRMaXN0KGIub3B0cy5pbWFnZUFsdEJ1dHRvbnMpK1xcXCI8L2Rpdj5cXFwiO3ZhciBkPVxcXCJcXFwiO2Q9JzxkaXYgY2xhc3M9XFxcImZyLWltYWdlLWFsdC1sYXllciBmci1sYXllciBmci1hY3RpdmVcXFwiIGlkPVxcXCJmci1pbWFnZS1hbHQtbGF5ZXItJytiLmlkKydcXFwiPjxkaXYgY2xhc3M9XFxcImZyLWlucHV0LWxpbmVcXFwiPjxpbnB1dCBpZD1cXFwiZnItaW1hZ2UtYWx0LWxheWVyLXRleHQtJytiLmlkKydcXFwiIHR5cGU9XFxcInRleHRcXFwiIHBsYWNlaG9sZGVyPVxcXCInK2IubGFuZ3VhZ2UudHJhbnNsYXRlKFxcXCJBbHRlcm5hdGUgVGV4dFxcXCIpKydcXFwiIHRhYkluZGV4PVxcXCIxXFxcIj48L2Rpdj48ZGl2IGNsYXNzPVxcXCJmci1hY3Rpb24tYnV0dG9uc1xcXCI+PGJ1dHRvbiB0eXBlPVxcXCJidXR0b25cXFwiIGNsYXNzPVxcXCJmci1jb21tYW5kIGZyLXN1Ym1pdFxcXCIgZGF0YS1jbWQ9XFxcImltYWdlU2V0QWx0XFxcIiB0YWJJbmRleD1cXFwiMlxcXCIgcm9sZT1cXFwiYnV0dG9uXFxcIj4nK2IubGFuZ3VhZ2UudHJhbnNsYXRlKFxcXCJVcGRhdGVcXFwiKStcXFwiPC9idXR0b24+PC9kaXY+PC9kaXY+XFxcIjt2YXIgZT17YnV0dG9uczpjLGFsdF9sYXllcjpkfSxmPWIucG9wdXBzLmNyZWF0ZShcXFwiaW1hZ2UuYWx0XFxcIixlKTtyZXR1cm4gYi4kd3AmJmIuZXZlbnRzLiRvbihiLiR3cCxcXFwic2Nyb2xsLmltYWdlLWFsdFxcXCIsZnVuY3Rpb24oKXt4YSYmYi5wb3B1cHMuaXNWaXNpYmxlKFxcXCJpbWFnZS5hbHRcXFwiKSYmTygpfSksZn1mdW5jdGlvbiBRKGEpe2lmKHhhKXt2YXIgYz1iLnBvcHVwcy5nZXQoXFxcImltYWdlLmFsdFxcXCIpO3hhLmF0dHIoXFxcImFsdFxcXCIsYXx8Yy5maW5kKFxcXCJpbnB1dFxcXCIpLnZhbCgpfHxcXFwiXFxcIiksYy5maW5kKFxcXCJpbnB1dDpmb2N1c1xcXCIpLmJsdXIoKSx3KHhhKX19ZnVuY3Rpb24gUigpe2lmKHhhKXt2YXIgYT1iLnBvcHVwcy5nZXQoXFxcImltYWdlLnNpemVcXFwiKTthLmZpbmQoJ2lucHV0W25hbWU9XFxcIndpZHRoXFxcIl0nKS52YWwoeGEuZ2V0KDApLnN0eWxlLndpZHRoKS50cmlnZ2VyKFxcXCJjaGFuZ2VcXFwiKSxhLmZpbmQoJ2lucHV0W25hbWU9XFxcImhlaWdodFxcXCJdJykudmFsKHhhLmdldCgwKS5zdHlsZS5oZWlnaHQpLnRyaWdnZXIoXFxcImNoYW5nZVxcXCIpfX1mdW5jdGlvbiBTKCl7dmFyIGE9Yi5wb3B1cHMuZ2V0KFxcXCJpbWFnZS5zaXplXFxcIik7YXx8KGE9VCgpKSxzKCksYi5wb3B1cHMucmVmcmVzaChcXFwiaW1hZ2Uuc2l6ZVxcXCIpLGIucG9wdXBzLnNldENvbnRhaW5lcihcXFwiaW1hZ2Uuc2l6ZVxcXCIsYi4kc2MpO3ZhciBjPXhhLm9mZnNldCgpLmxlZnQreGEud2lkdGgoKS8yLGQ9eGEub2Zmc2V0KCkudG9wK3hhLmhlaWdodCgpO2IucG9wdXBzLnNob3coXFxcImltYWdlLnNpemVcXFwiLGMsZCx4YS5vdXRlckhlaWdodCgpKX1mdW5jdGlvbiBUKGEpe2lmKGEpcmV0dXJuIGIucG9wdXBzLm9uUmVmcmVzaChcXFwiaW1hZ2Uuc2l6ZVxcXCIsUiksITA7dmFyIGM9XFxcIlxcXCI7Yz0nPGRpdiBjbGFzcz1cXFwiZnItYnV0dG9uc1xcXCI+JytiLmJ1dHRvbi5idWlsZExpc3QoYi5vcHRzLmltYWdlU2l6ZUJ1dHRvbnMpK1xcXCI8L2Rpdj5cXFwiO3ZhciBkPVxcXCJcXFwiO2Q9JzxkaXYgY2xhc3M9XFxcImZyLWltYWdlLXNpemUtbGF5ZXIgZnItbGF5ZXIgZnItYWN0aXZlXFxcIiBpZD1cXFwiZnItaW1hZ2Utc2l6ZS1sYXllci0nK2IuaWQrJ1xcXCI+PGRpdiBjbGFzcz1cXFwiZnItaW1hZ2UtZ3JvdXBcXFwiPjxkaXYgY2xhc3M9XFxcImZyLWlucHV0LWxpbmVcXFwiPjxpbnB1dCBpZD1cXFwiZnItaW1hZ2Utc2l6ZS1sYXllci13aWR0aC0nK2IuaWQrJ1xcXCIgdHlwZT1cXFwidGV4dFxcXCIgbmFtZT1cXFwid2lkdGhcXFwiIHBsYWNlaG9sZGVyPVxcXCInK2IubGFuZ3VhZ2UudHJhbnNsYXRlKFxcXCJXaWR0aFxcXCIpKydcXFwiIHRhYkluZGV4PVxcXCIxXFxcIj48L2Rpdj48ZGl2IGNsYXNzPVxcXCJmci1pbnB1dC1saW5lXFxcIj48aW5wdXQgaWQ9XFxcImZyLWltYWdlLXNpemUtbGF5ZXItaGVpZ2h0JytiLmlkKydcXFwiIHR5cGU9XFxcInRleHRcXFwiIG5hbWU9XFxcImhlaWdodFxcXCIgcGxhY2Vob2xkZXI9XFxcIicrYi5sYW5ndWFnZS50cmFuc2xhdGUoXFxcIkhlaWdodFxcXCIpKydcXFwiIHRhYkluZGV4PVxcXCIxXFxcIj48L2Rpdj48L2Rpdj48ZGl2IGNsYXNzPVxcXCJmci1hY3Rpb24tYnV0dG9uc1xcXCI+PGJ1dHRvbiB0eXBlPVxcXCJidXR0b25cXFwiIGNsYXNzPVxcXCJmci1jb21tYW5kIGZyLXN1Ym1pdFxcXCIgZGF0YS1jbWQ9XFxcImltYWdlU2V0U2l6ZVxcXCIgdGFiSW5kZXg9XFxcIjJcXFwiIHJvbGU9XFxcImJ1dHRvblxcXCI+JytiLmxhbmd1YWdlLnRyYW5zbGF0ZShcXFwiVXBkYXRlXFxcIikrXFxcIjwvYnV0dG9uPjwvZGl2PjwvZGl2PlxcXCI7dmFyIGU9e2J1dHRvbnM6YyxzaXplX2xheWVyOmR9LGY9Yi5wb3B1cHMuY3JlYXRlKFxcXCJpbWFnZS5zaXplXFxcIixlKTtyZXR1cm4gYi4kd3AmJmIuZXZlbnRzLiRvbihiLiR3cCxcXFwic2Nyb2xsLmltYWdlLXNpemVcXFwiLGZ1bmN0aW9uKCl7eGEmJmIucG9wdXBzLmlzVmlzaWJsZShcXFwiaW1hZ2Uuc2l6ZVxcXCIpJiZTKCl9KSxmfWZ1bmN0aW9uIFUoYSxjKXtpZih4YSl7dmFyIGQ9Yi5wb3B1cHMuZ2V0KFxcXCJpbWFnZS5zaXplXFxcIik7YT1hfHxkLmZpbmQoJ2lucHV0W25hbWU9XFxcIndpZHRoXFxcIl0nKS52YWwoKXx8XFxcIlxcXCIsYz1jfHxkLmZpbmQoJ2lucHV0W25hbWU9XFxcImhlaWdodFxcXCJdJykudmFsKCl8fFxcXCJcXFwiO3ZhciBlPS9eW1xcXFxkXSsoKHB4KXwlKSokL2c7YS5tYXRjaChlKSYmeGEuY3NzKFxcXCJ3aWR0aFxcXCIsYSksYy5tYXRjaChlKSYmeGEuY3NzKFxcXCJoZWlnaHRcXFwiLGMpLGQuZmluZChcXFwiaW5wdXQ6Zm9jdXNcXFwiKS5ibHVyKCksdyh4YSl9fWZ1bmN0aW9uIFYoYSl7dmFyIGMsZCxlPWIucG9wdXBzLmdldChcXFwiaW1hZ2UuaW5zZXJ0XFxcIik7aWYoeGF8fGIub3B0cy50b29sYmFySW5saW5lKXhhJiYoZD14YS5vZmZzZXQoKS50b3AreGEub3V0ZXJIZWlnaHQoKSk7ZWxzZXt2YXIgZj1iLiR0Yi5maW5kKCcuZnItY29tbWFuZFtkYXRhLWNtZD1cXFwiaW5zZXJ0SW1hZ2VcXFwiXScpO2M9Zi5vZmZzZXQoKS5sZWZ0K2Yub3V0ZXJXaWR0aCgpLzIsZD1mLm9mZnNldCgpLnRvcCsoYi5vcHRzLnRvb2xiYXJCb3R0b20/MTA6Zi5vdXRlckhlaWdodCgpLTEwKX0heGEmJmIub3B0cy50b29sYmFySW5saW5lJiYoZD1lLm9mZnNldCgpLnRvcC1iLmhlbHBlcnMuZ2V0UFgoZS5jc3MoXFxcIm1hcmdpbi10b3BcXFwiKSksZS5oYXNDbGFzcyhcXFwiZnItYWJvdmVcXFwiKSYmKGQrPWUub3V0ZXJIZWlnaHQoKSkpLGUuZmluZChcXFwiLmZyLWxheWVyXFxcIikucmVtb3ZlQ2xhc3MoXFxcImZyLWFjdGl2ZVxcXCIpLGUuZmluZChcXFwiLmZyLVxcXCIrYStcXFwiLWxheWVyXFxcIikuYWRkQ2xhc3MoXFxcImZyLWFjdGl2ZVxcXCIpLGIucG9wdXBzLnNob3coXFxcImltYWdlLmluc2VydFxcXCIsYyxkLHhhP3hhLm91dGVySGVpZ2h0KCk6MCksYi5hY2Nlc3NpYmlsaXR5LmZvY3VzUG9wdXAoZSl9ZnVuY3Rpb24gVyhhKXt2YXIgYz1iLnBvcHVwcy5nZXQoXFxcImltYWdlLmluc2VydFxcXCIpO2MuZmluZChcXFwiLmZyLWltYWdlLXVwbG9hZC1sYXllclxcXCIpLmhhc0NsYXNzKFxcXCJmci1hY3RpdmVcXFwiKSYmYS5hZGRDbGFzcyhcXFwiZnItYWN0aXZlXFxcIikuYXR0cihcXFwiYXJpYS1wcmVzc2VkXFxcIiwhMCl9ZnVuY3Rpb24gWChhKXt2YXIgYz1iLnBvcHVwcy5nZXQoXFxcImltYWdlLmluc2VydFxcXCIpO2MuZmluZChcXFwiLmZyLWltYWdlLWJ5LXVybC1sYXllclxcXCIpLmhhc0NsYXNzKFxcXCJmci1hY3RpdmVcXFwiKSYmYS5hZGRDbGFzcyhcXFwiZnItYWN0aXZlXFxcIikuYXR0cihcXFwiYXJpYS1wcmVzc2VkXFxcIiwhMCl9ZnVuY3Rpb24gWShhLGIsYyxkKXtyZXR1cm4gYS5wYWdlWD1iLG0uY2FsbCh0aGlzLGEpLGEucGFnZVg9YS5wYWdlWCtjKk1hdGguZmxvb3IoTWF0aC5wb3coMS4xLGQpKSxuLmNhbGwodGhpcyxhKSxvLmNhbGwodGhpcyxhKSwrK2R9ZnVuY3Rpb24gWigpe3ZhciBjO2lmKGIuc2hhcmVkLiRpbWFnZV9yZXNpemVyPyh5YT1iLnNoYXJlZC4kaW1hZ2VfcmVzaXplcixBYT1iLnNoYXJlZC4kaW1nX292ZXJsYXksYi5ldmVudHMub24oXFxcImRlc3Ryb3lcXFwiLGZ1bmN0aW9uKCl7eWEucmVtb3ZlQ2xhc3MoXFxcImZyLWFjdGl2ZVxcXCIpLmFwcGVuZFRvKGEoXFxcImJvZHlcXFwiKSl9LCEwKSk6KGIuc2hhcmVkLiRpbWFnZV9yZXNpemVyPWEoJzxkaXYgY2xhc3M9XFxcImZyLWltYWdlLXJlc2l6ZXJcXFwiPjwvZGl2PicpLHlhPWIuc2hhcmVkLiRpbWFnZV9yZXNpemVyLGIuZXZlbnRzLiRvbih5YSxcXFwibW91c2Vkb3duXFxcIixmdW5jdGlvbihhKXthLnN0b3BQcm9wYWdhdGlvbigpfSwhMCksYi5vcHRzLmltYWdlUmVzaXplJiYoeWEuYXBwZW5kKGwoXFxcIm53XFxcIikrbChcXFwibmVcXFwiKStsKFxcXCJzd1xcXCIpK2woXFxcInNlXFxcIikpLGIuc2hhcmVkLiRpbWdfb3ZlcmxheT1hKCc8ZGl2IGNsYXNzPVxcXCJmci1pbWFnZS1vdmVybGF5XFxcIj48L2Rpdj4nKSxBYT1iLnNoYXJlZC4kaW1nX292ZXJsYXksYz15YS5nZXQoMCkub3duZXJEb2N1bWVudCxhKGMpLmZpbmQoXFxcImJvZHlcXFwiKS5hcHBlbmQoQWEpKSksYi5ldmVudHMub24oXFxcInNoYXJlZC5kZXN0cm95XFxcIixmdW5jdGlvbigpe3lhLmh0bWwoXFxcIlxcXCIpLnJlbW92ZURhdGEoKS5yZW1vdmUoKSx5YT1udWxsLGIub3B0cy5pbWFnZVJlc2l6ZSYmKEFhLnJlbW92ZSgpLEFhPW51bGwpfSwhMCksYi5oZWxwZXJzLmlzTW9iaWxlKCl8fGIuZXZlbnRzLiRvbihhKGIub193aW4pLFxcXCJyZXNpemVcXFwiLGZ1bmN0aW9uKCl7eGEmJiF4YS5oYXNDbGFzcyhcXFwiZnItdXBsb2FkaW5nXFxcIik/Z2EoITApOnhhJiYoaygpLHNhKCkscighMSkpfSksYi5vcHRzLmltYWdlUmVzaXplKXtjPXlhLmdldCgwKS5vd25lckRvY3VtZW50LGIuZXZlbnRzLiRvbih5YSxiLl9tb3VzZWRvd24sXFxcIi5mci1oYW5kbGVyXFxcIixtKSxiLmV2ZW50cy4kb24oYShjKSxiLl9tb3VzZW1vdmUsbiksYi5ldmVudHMuJG9uKGEoYy5kZWZhdWx0Vmlld3x8Yy5wYXJlbnRXaW5kb3cpLGIuX21vdXNldXAsbyksYi5ldmVudHMuJG9uKEFhLFxcXCJtb3VzZWxlYXZlXFxcIixvKTt2YXIgZD0xLGU9bnVsbCxmPTA7Yi5ldmVudHMub24oXFxcImtleWRvd25cXFwiLGZ1bmN0aW9uKGMpe2lmKHhhKXt2YXIgZz1uYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoXFxcIk1hYyBPUyBYXFxcIikhPS0xP2MubWV0YUtleTpjLmN0cmxLZXksaD1jLndoaWNoOyhoIT09ZXx8Yy50aW1lU3RhbXAtZj4yMDApJiYoZD0xKSwoaD09YS5GRS5LRVlDT0RFLkVRVUFMU3x8Yi5icm93c2VyLm1vemlsbGEmJmg9PWEuRkUuS0VZQ09ERS5GRl9FUVVBTFMpJiZnJiYhYy5hbHRLZXk/ZD1ZLmNhbGwodGhpcyxjLDEsMSxkKTooaD09YS5GRS5LRVlDT0RFLkhZUEhFTnx8Yi5icm93c2VyLm1vemlsbGEmJmg9PWEuRkUuS0VZQ09ERS5GRl9IWVBIRU4pJiZnJiYhYy5hbHRLZXk/ZD1ZLmNhbGwodGhpcyxjLDIsLTEsZCk6Yi5rZXlzLmN0cmxLZXkoYyl8fGghPWEuRkUuS0VZQ09ERS5FTlRFUnx8KHhhLmJlZm9yZShcXFwiPGJyPlxcXCIpLHcoeGEpKSxlPWgsZj1jLnRpbWVTdGFtcH19LCEwKSxiLmV2ZW50cy5vbihcXFwia2V5dXBcXFwiLGZ1bmN0aW9uKCl7ZD0xfSl9fWZ1bmN0aW9uICQoYyl7Yz1jfHx4YSxjJiZiLmV2ZW50cy50cmlnZ2VyKFxcXCJpbWFnZS5iZWZvcmVSZW1vdmVcXFwiLFtjXSkhPT0hMSYmKGIucG9wdXBzLmhpZGVBbGwoKSx0YSgpLGdhKCEwKSxiLnVuZG8uY2FuRG8oKXx8Yi51bmRvLnNhdmVTdGVwKCksYy5nZXQoMCk9PWIuZWw/Yy5yZW1vdmVBdHRyKFxcXCJzcmNcXFwiKTooXFxcIkFcXFwiPT1jLmdldCgwKS5wYXJlbnROb2RlLnRhZ05hbWU/KGIuc2VsZWN0aW9uLnNldEJlZm9yZShjLmdldCgwKS5wYXJlbnROb2RlKXx8Yi5zZWxlY3Rpb24uc2V0QWZ0ZXIoYy5nZXQoMCkucGFyZW50Tm9kZSl8fGMucGFyZW50KCkuYWZ0ZXIoYS5GRS5NQVJLRVJTKSxhKGMuZ2V0KDApLnBhcmVudE5vZGUpLnJlbW92ZSgpKTooYi5zZWxlY3Rpb24uc2V0QmVmb3JlKGMuZ2V0KDApKXx8Yi5zZWxlY3Rpb24uc2V0QWZ0ZXIoYy5nZXQoMCkpfHxjLmFmdGVyKGEuRkUuTUFSS0VSUyksYy5yZW1vdmUoKSksYi5odG1sLmZpbGxFbXB0eUJsb2NrcygpLGIuc2VsZWN0aW9uLnJlc3RvcmUoKSksYi51bmRvLnNhdmVTdGVwKCkpfWZ1bmN0aW9uIF8oYyl7dmFyIGQ9Yy53aGljaDtpZih4YSYmKGQ9PWEuRkUuS0VZQ09ERS5CQUNLU1BBQ0V8fGQ9PWEuRkUuS0VZQ09ERS5ERUxFVEUpKXJldHVybiBjLnByZXZlbnREZWZhdWx0KCksYy5zdG9wUHJvcGFnYXRpb24oKSwkKCksITE7aWYoeGEmJmQ9PWEuRkUuS0VZQ09ERS5FU0Mpe3ZhciBlPXhhO3JldHVybiBnYSghMCksYi5zZWxlY3Rpb24uc2V0QWZ0ZXIoZS5nZXQoMCkpLGIuc2VsZWN0aW9uLnJlc3RvcmUoKSxjLnByZXZlbnREZWZhdWx0KCksITF9aWYoeGEmJihkPT1hLkZFLktFWUNPREUuQVJST1dfTEVGVHx8ZD09YS5GRS5LRVlDT0RFLkFSUk9XX1JJR0hUKSl7dmFyIGY9eGEuZ2V0KDApO3JldHVybiBnYSghMCksZD09YS5GRS5LRVlDT0RFLkFSUk9XX0xFRlQ/Yi5zZWxlY3Rpb24uc2V0QmVmb3JlKGYpOmIuc2VsZWN0aW9uLnNldEFmdGVyKGYpLGIuc2VsZWN0aW9uLnJlc3RvcmUoKSxjLnByZXZlbnREZWZhdWx0KCksITF9cmV0dXJuIHhhJiZkIT1hLkZFLktFWUNPREUuRjEwJiYhYi5rZXlzLmlzQnJvd3NlckFjdGlvbihjKT8oYy5wcmV2ZW50RGVmYXVsdCgpLGMuc3RvcFByb3BhZ2F0aW9uKCksITEpOnZvaWQgMH1mdW5jdGlvbiBhYShhKXtpZihhJiZcXFwiSU1HXFxcIj09YS50YWdOYW1lKWIubm9kZS5oYXNDbGFzcyhhLFxcXCJmci11cGxvYWRpbmdcXFwiKXx8Yi5ub2RlLmhhc0NsYXNzKGEsXFxcImZyLWVycm9yXFxcIik/YS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGEpOmIubm9kZS5oYXNDbGFzcyhhLFxcXCJmci1kcmFnZ2FibGVcXFwiKSYmYS5jbGFzc0xpc3QucmVtb3ZlKFxcXCJmci1kcmFnZ2FibGVcXFwiKTtlbHNlIGlmKGEmJmEubm9kZVR5cGU9PU5vZGUuRUxFTUVOVF9OT0RFKWZvcih2YXIgYz1hLnF1ZXJ5U2VsZWN0b3JBbGwoXFxcImltZy5mci11cGxvYWRpbmcsIGltZy5mci1lcnJvciwgaW1nLmZyLWRyYWdnYWJsZVxcXCIpLGQ9MDtkPGMubGVuZ3RoO2QrKylhYShjW2RdKX1mdW5jdGlvbiBiYSgpe2lmKEwoKSxcXFwiSU1HXFxcIj09Yi5lbC50YWdOYW1lJiZiLiRlbC5hZGRDbGFzcyhcXFwiZnItdmlld1xcXCIpLGIuZXZlbnRzLiRvbihiLiRlbCxiLmhlbHBlcnMuaXNNb2JpbGUoKSYmIWIuaGVscGVycy5pc1dpbmRvd3NQaG9uZSgpP1xcXCJ0b3VjaGVuZFxcXCI6XFxcImNsaWNrXFxcIixcXFwiSU1HXFxcIj09Yi5lbC50YWdOYW1lP251bGw6J2ltZzpub3QoW2NvbnRlbnRlZGl0YWJsZT1cXFwiZmFsc2VcXFwiXSknLGZhKSxiLmhlbHBlcnMuaXNNb2JpbGUoKSYmKGIuZXZlbnRzLiRvbihiLiRlbCxcXFwidG91Y2hzdGFydFxcXCIsXFxcIklNR1xcXCI9PWIuZWwudGFnTmFtZT9udWxsOidpbWc6bm90KFtjb250ZW50ZWRpdGFibGU9XFxcImZhbHNlXFxcIl0pJyxmdW5jdGlvbigpe0xhPSExfSksYi5ldmVudHMuJG9uKGIuJGVsLFxcXCJ0b3VjaG1vdmVcXFwiLGZ1bmN0aW9uKCl7TGE9ITB9KSksYi4kd3A/KGIuZXZlbnRzLm9uKFxcXCJ3aW5kb3cua2V5ZG93biBrZXlkb3duXFxcIixfLCEwKSxiLmV2ZW50cy5vbihcXFwia2V5dXBcXFwiLGZ1bmN0aW9uKGIpe2lmKGIud2hpY2g9PWEuRkUuS0VZQ09ERS5FTlRFUilyZXR1cm4hMX0sITApKTpiLmV2ZW50cy4kb24oYi4kd2luLFxcXCJrZXlkb3duXFxcIixfKSxiLmV2ZW50cy5vbihcXFwidG9vbGJhci5lc2NcXFwiLGZ1bmN0aW9uKCl7aWYoeGEpe2lmKGIuJHdwKWIuZXZlbnRzLmRpc2FibGVCbHVyKCksYi5ldmVudHMuZm9jdXMoKTtlbHNle3ZhciBhPXhhO2dhKCEwKSxiLnNlbGVjdGlvbi5zZXRBZnRlcihhLmdldCgwKSksYi5zZWxlY3Rpb24ucmVzdG9yZSgpfXJldHVybiExfX0sITApLGIuZXZlbnRzLm9uKFxcXCJ0b29sYmFyLmZvY3VzRWRpdG9yXFxcIixmdW5jdGlvbigpe2lmKHhhKXJldHVybiExfSwhMCksYi5ldmVudHMub24oXFxcIndpbmRvdy5jdXQgd2luZG93LmNvcHlcXFwiLGZ1bmN0aW9uKGMpe3hhJiZiLnBvcHVwcy5pc1Zpc2libGUoXFxcImltYWdlLmVkaXRcXFwiKSYmIWIucG9wdXBzLmdldChcXFwiaW1hZ2UuZWRpdFxcXCIpLmZpbmQoXFxcIjpmb2N1c1xcXCIpLmxlbmd0aCYmKHRhKCksYS5GRS5jb3BpZWRfdGV4dD1cXFwiXFxcXG5cXFwiLGEuRkUuY29waWVkX2h0bWw9eGEuZ2V0KDApLm91dGVySFRNTCxcXFwiY29weVxcXCI9PWMudHlwZT9zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7dyh4YSl9KTooZ2EoITApLGIudW5kby5zYXZlU3RlcCgpLHNldFRpbWVvdXQoZnVuY3Rpb24oKXtiLnVuZG8uc2F2ZVN0ZXAoKX0sMCkpKX0sITApLGIuZXZlbnRzLiRvbihhKGIub193aW4pLFxcXCJrZXlkb3duXFxcIixmdW5jdGlvbihiKXt2YXIgYz1iLndoaWNoO2lmKHhhJiZjPT1hLkZFLktFWUNPREUuQkFDS1NQQUNFKXJldHVybiBiLnByZXZlbnREZWZhdWx0KCksITF9KSxiLmV2ZW50cy4kb24oYi4kd2luLFxcXCJrZXlkb3duXFxcIixmdW5jdGlvbihiKXt2YXIgYz1iLndoaWNoO3hhJiZ4YS5oYXNDbGFzcyhcXFwiZnItdXBsb2FkaW5nXFxcIikmJmM9PWEuRkUuS0VZQ09ERS5FU0MmJnhhLnRyaWdnZXIoXFxcImFib3J0VXBsb2FkXFxcIil9KSxiLmV2ZW50cy5vbihcXFwiZGVzdHJveVxcXCIsZnVuY3Rpb24oKXt4YSYmeGEuaGFzQ2xhc3MoXFxcImZyLXVwbG9hZGluZ1xcXCIpJiZ4YS50cmlnZ2VyKFxcXCJhYm9ydFVwbG9hZFxcXCIpfSksYi5ldmVudHMub24oXFxcInBhc3RlLmJlZm9yZVxcXCIsZGEpLGIuZXZlbnRzLm9uKFxcXCJwYXN0ZS5iZWZvcmVDbGVhbnVwXFxcIixlYSksYi5ldmVudHMub24oXFxcInBhc3RlLmFmdGVyXFxcIixjYSksYi5ldmVudHMub24oXFxcImh0bWwuc2V0XFxcIixpKSxiLmV2ZW50cy5vbihcXFwiaHRtbC5pbnNlcnRlZFxcXCIsaSksaSgpLGIuZXZlbnRzLm9uKFxcXCJkZXN0cm95XFxcIixmdW5jdGlvbigpe0thPVtdfSksYi5ldmVudHMub24oXFxcImh0bWwucHJvY2Vzc0dldFxcXCIsYWEpLGIub3B0cy5pbWFnZU91dHB1dFNpemUpe3ZhciBjO2IuZXZlbnRzLm9uKFxcXCJodG1sLmJlZm9yZUdldFxcXCIsZnVuY3Rpb24oKXtjPWIuZWwucXVlcnlTZWxlY3RvckFsbChcXFwiaW1nXFxcIik7Zm9yKHZhciBkPTA7ZDxjLmxlbmd0aDtkKyspe3ZhciBlPWNbZF0uc3R5bGUud2lkdGh8fGEoY1tkXSkud2lkdGgoKSxmPWNbZF0uc3R5bGUuaGVpZ2h0fHxhKGNbZF0pLmhlaWdodCgpO2UmJmNbZF0uc2V0QXR0cmlidXRlKFxcXCJ3aWR0aFxcXCIsKFxcXCJcXFwiK2UpLnJlcGxhY2UoL3B4LyxcXFwiXFxcIikpLGYmJmNbZF0uc2V0QXR0cmlidXRlKFxcXCJoZWlnaHRcXFwiLChcXFwiXFxcIitmKS5yZXBsYWNlKC9weC8sXFxcIlxcXCIpKX19KSxiLmV2ZW50cy5vbihcXFwiaHRtbC5hZnRlckdldFxcXCIsZnVuY3Rpb24oKXtmb3IodmFyIGE9MDthPGMubGVuZ3RoO2ErKyljW2FdLnJlbW92ZUF0dHJpYnV0ZShcXFwid2lkdGhcXFwiKSxjW2FdLnJlbW92ZUF0dHJpYnV0ZShcXFwiaGVpZ2h0XFxcIil9KX1iLm9wdHMuaWZyYW1lJiZiLmV2ZW50cy5vbihcXFwiaW1hZ2UubG9hZGVkXFxcIixiLnNpemUuc3luY0lmcmFtZSksYi4kd3AmJihqKCksYi5ldmVudHMub24oXFxcImNvbnRlbnRDaGFuZ2VkXFxcIixqKSksYi5ldmVudHMuJG9uKGEoYi5vX3dpbiksXFxcIm9yaWVudGF0aW9uY2hhbmdlLmltYWdlXFxcIixmdW5jdGlvbigpe3NldFRpbWVvdXQoZnVuY3Rpb24oKXt4YSYmdyh4YSl9LDEwMCl9KSxxKCEwKSxNKCEwKSxUKCEwKSxQKCEwKSxiLmV2ZW50cy5vbihcXFwibm9kZS5yZW1vdmVcXFwiLGZ1bmN0aW9uKGEpe2lmKFxcXCJJTUdcXFwiPT1hLmdldCgwKS50YWdOYW1lKXJldHVybiAkKGEpLCExfSl9ZnVuY3Rpb24gY2EoKXtiLm9wdHMuaW1hZ2VQYXN0ZT9iLiRlbC5maW5kKFxcXCJpbWdbZGF0YS1mci1pbWFnZS1wYXN0ZWRdXFxcIikuZWFjaChmdW5jdGlvbihjLGQpe2lmKGIub3B0cy5pbWFnZVBhc3RlUHJvY2Vzcyl7dmFyIGY9Yi5vcHRzLmltYWdlRGVmYXVsdFdpZHRoO2YmJlxcXCJhdXRvXFxcIiE9ZiYmKGYrPWIub3B0cy5pbWFnZVJlc2l6ZVdpdGhQZXJjZW50P1xcXCIlXFxcIjpcXFwicHhcXFwiKSxhKGQpLmNzcyhcXFwid2lkdGhcXFwiLGYpLGEoZCkucmVtb3ZlQ2xhc3MoXFxcImZyLWRpaSBmci1kaWIgZnItZmlyIGZyLWZpbFxcXCIpLmFkZENsYXNzKChiLm9wdHMuaW1hZ2VEZWZhdWx0RGlzcGxheT9cXFwiZnItZGlcXFwiK2Iub3B0cy5pbWFnZURlZmF1bHREaXNwbGF5WzBdOlxcXCJcXFwiKSsoYi5vcHRzLmltYWdlRGVmYXVsdEFsaWduJiZcXFwiY2VudGVyXFxcIiE9Yi5vcHRzLmltYWdlRGVmYXVsdEFsaWduP1xcXCIgZnItZmlcXFwiK2Iub3B0cy5pbWFnZURlZmF1bHRBbGlnblswXTpcXFwiXFxcIikpfWlmKDA9PT1kLnNyYy5pbmRleE9mKFxcXCJkYXRhOlxcXCIpKXtpZihiLmV2ZW50cy50cmlnZ2VyKFxcXCJpbWFnZS5iZWZvcmVQYXN0ZVVwbG9hZFxcXCIsW2RdKT09PSExKXJldHVybiExO3hhPWEoZCksaygpLGUoKSxzYSgpLHIoKSxiLmVkaXQub2ZmKCk7Zm9yKHZhciBnPWF0b2IoYShkKS5hdHRyKFxcXCJzcmNcXFwiKS5zcGxpdChcXFwiLFxcXCIpWzFdKSxoPVtdLGk9MDtpPGcubGVuZ3RoO2krKyloLnB1c2goZy5jaGFyQ29kZUF0KGkpKTt2YXIgaj1uZXcgQmxvYihbbmV3IFVpbnQ4QXJyYXkoaCldLHt0eXBlOlxcXCJpbWFnZS9qcGVnXFxcIn0pO0goW2pdKSxhKGQpLnJlbW92ZUF0dHIoXFxcImRhdGEtZnItaW1hZ2UtcGFzdGVkXFxcIil9ZWxzZSAwIT09ZC5zcmMuaW5kZXhPZihcXFwiaHR0cFxcXCIpfHwwPT09ZC5zcmMuaW5kZXhPZihcXFwiaHR0cHM6Ly9tYWlsLmdvb2dsZS5jb20vbWFpbFxcXCIpPyhiLnNlbGVjdGlvbi5zYXZlKCksYShkKS5yZW1vdmUoKSxiLnNlbGVjdGlvbi5yZXN0b3JlKCkpOmEoZCkucmVtb3ZlQXR0cihcXFwiZGF0YS1mci1pbWFnZS1wYXN0ZWRcXFwiKX0pOmIuJGVsLmZpbmQoXFxcImltZ1tkYXRhLWZyLWltYWdlLXBhc3RlZF1cXFwiKS5yZW1vdmUoKX1mdW5jdGlvbiBkYShhKXtpZihhJiZhLmNsaXBib2FyZERhdGEmJmEuY2xpcGJvYXJkRGF0YS5pdGVtcyYmYS5jbGlwYm9hcmREYXRhLml0ZW1zWzBdKXt2YXIgYz1hLmNsaXBib2FyZERhdGEuaXRlbXNbMF0uZ2V0QXNGaWxlKCk7aWYoYyl7dmFyIGQ9bmV3IEZpbGVSZWFkZXI7cmV0dXJuIGQub25sb2FkPWZ1bmN0aW9uKGEpe3ZhciBjPWEudGFyZ2V0LnJlc3VsdCxkPWIub3B0cy5pbWFnZURlZmF1bHRXaWR0aDtkJiZcXFwiYXV0b1xcXCIhPWQmJihkKz1iLm9wdHMuaW1hZ2VSZXNpemVXaXRoUGVyY2VudD9cXFwiJVxcXCI6XFxcInB4XFxcIiksYi5odG1sLmluc2VydCgnPGltZyBkYXRhLWZyLWltYWdlLXBhc3RlZD1cXFwidHJ1ZVxcXCIgY2xhc3M9XFxcIicrKGIub3B0cy5pbWFnZURlZmF1bHREaXNwbGF5P1xcXCJmci1kaVxcXCIrYi5vcHRzLmltYWdlRGVmYXVsdERpc3BsYXlbMF06XFxcIlxcXCIpKyhiLm9wdHMuaW1hZ2VEZWZhdWx0QWxpZ24mJlxcXCJjZW50ZXJcXFwiIT1iLm9wdHMuaW1hZ2VEZWZhdWx0QWxpZ24/XFxcIiBmci1maVxcXCIrYi5vcHRzLmltYWdlRGVmYXVsdEFsaWduWzBdOlxcXCJcXFwiKSsnXFxcIiBzcmM9XFxcIicrYysnXFxcIicrKGQ/JyBzdHlsZT1cXFwid2lkdGg6ICcrZCsnO1xcXCInOlxcXCJcXFwiKStcXFwiPlxcXCIpLGIuZXZlbnRzLnRyaWdnZXIoXFxcInBhc3RlLmFmdGVyXFxcIil9LGQucmVhZEFzRGF0YVVSTChjKSwhMX19fWZ1bmN0aW9uIGVhKGEpe3JldHVybiBhPWEucmVwbGFjZSgvPGltZyAvZ2ksJzxpbWcgZGF0YS1mci1pbWFnZS1wYXN0ZWQ9XFxcInRydWVcXFwiICcpfWZ1bmN0aW9uIGZhKGMpe2lmKFxcXCJmYWxzZVxcXCI9PWEodGhpcykucGFyZW50cyhcXFwiW2NvbnRlbnRlZGl0YWJsZV06bm90KC5mci1lbGVtZW50KTpub3QoYm9keSk6Zmlyc3RcXFwiKS5hdHRyKFxcXCJjb250ZW50ZWRpdGFibGVcXFwiKSlyZXR1cm4hMDtpZihjJiZcXFwidG91Y2hlbmRcXFwiPT1jLnR5cGUmJkxhKXJldHVybiEwO2lmKGMmJmIuZWRpdC5pc0Rpc2FibGVkKCkpcmV0dXJuIGMuc3RvcFByb3BhZ2F0aW9uKCksYy5wcmV2ZW50RGVmYXVsdCgpLCExO2Zvcih2YXIgZD0wO2Q8YS5GRS5JTlNUQU5DRVMubGVuZ3RoO2QrKylhLkZFLklOU1RBTkNFU1tkXSE9YiYmYS5GRS5JTlNUQU5DRVNbZF0uZXZlbnRzLnRyaWdnZXIoXFxcImltYWdlLmhpZGVSZXNpemVyXFxcIik7Yi50b29sYmFyLmRpc2FibGUoKSxjJiYoYy5zdG9wUHJvcGFnYXRpb24oKSxjLnByZXZlbnREZWZhdWx0KCkpLGIuaGVscGVycy5pc01vYmlsZSgpJiYoYi5ldmVudHMuZGlzYWJsZUJsdXIoKSxiLiRlbC5ibHVyKCksYi5ldmVudHMuZW5hYmxlQmx1cigpKSxiLm9wdHMuaWZyYW1lJiZiLnNpemUuc3luY0lmcmFtZSgpLHhhPWEodGhpcyksdGEoKSxrKCksZSgpLGIuc2VsZWN0aW9uLmNsZWFyKCksYi5idXR0b24uYnVsa1JlZnJlc2goKSxiLmV2ZW50cy50cmlnZ2VyKFxcXCJ2aWRlby5oaWRlUmVzaXplclxcXCIpfWZ1bmN0aW9uIGdhKGEpe3hhJiYoamEoKXx8YT09PSEwKSYmKGIudG9vbGJhci5lbmFibGUoKSx5YS5yZW1vdmVDbGFzcyhcXFwiZnItYWN0aXZlXFxcIiksYi5wb3B1cHMuaGlkZShcXFwiaW1hZ2UuZWRpdFxcXCIpLHhhPW51bGwsaWEoKSl9ZnVuY3Rpb24gaGEoKXtNYT0hMH1mdW5jdGlvbiBpYSgpe01hPSExfWZ1bmN0aW9uIGphKCl7cmV0dXJuIE1hfWZ1bmN0aW9uIGthKGEsYyxkKXshYi5vcHRzLmh0bWxVbnRvdWNoZWQmJmIub3B0cy51c2VDbGFzc2VzPyhhLnJlbW92ZUNsYXNzKFxcXCJmci1maWwgZnItZmlyIGZyLWRpYiBmci1kaWlcXFwiKSxhLmFkZENsYXNzKFxcXCJmci1maVxcXCIrZFswXStcXFwiIGZyLWRpXFxcIitjWzBdKSk6XFxcImlubGluZVxcXCI9PWM/KGEuY3NzKHtkaXNwbGF5OlxcXCJpbmxpbmUtYmxvY2tcXFwiLHZlcnRpY2FsQWxpZ246XFxcImJvdHRvbVxcXCIsbWFyZ2luOmIub3B0cy5pbWFnZURlZmF1bHRNYXJnaW59KSxcXFwiY2VudGVyXFxcIj09ZD9hLmNzcyh7ZmxvYXQ6XFxcIm5vbmVcXFwiLG1hcmdpbkJvdHRvbTpcXFwiXFxcIixtYXJnaW5Ub3A6XFxcIlxcXCIsbWF4V2lkdGg6XFxcImNhbGMoMTAwJSAtIFxcXCIrMipiLm9wdHMuaW1hZ2VEZWZhdWx0TWFyZ2luK1xcXCJweClcXFwifSk6XFxcImxlZnRcXFwiPT1kP2EuY3NzKHtmbG9hdDpcXFwibGVmdFxcXCIsbWFyZ2luTGVmdDowLG1heFdpZHRoOlxcXCJjYWxjKDEwMCUgLSBcXFwiK2Iub3B0cy5pbWFnZURlZmF1bHRNYXJnaW4rXFxcInB4KVxcXCJ9KTphLmNzcyh7ZmxvYXQ6XFxcInJpZ2h0XFxcIixtYXJnaW5SaWdodDowLG1heFdpZHRoOlxcXCJjYWxjKDEwMCUgLSBcXFwiK2Iub3B0cy5pbWFnZURlZmF1bHRNYXJnaW4rXFxcInB4KVxcXCJ9KSk6XFxcImJsb2NrXFxcIj09YyYmKGEuY3NzKHtkaXNwbGF5OlxcXCJibG9ja1xcXCIsZmxvYXQ6XFxcIm5vbmVcXFwiLHZlcnRpY2FsQWxpZ246XFxcInRvcFxcXCIsbWFyZ2luOmIub3B0cy5pbWFnZURlZmF1bHRNYXJnaW4rXFxcInB4IGF1dG9cXFwifSksXFxcImxlZnRcXFwiPT1kP2EuY3NzKHttYXJnaW5MZWZ0OjB9KTpcXFwicmlnaHRcXFwiPT1kJiZhLmNzcyh7bWFyZ2luUmlnaHQ6MH0pKX1mdW5jdGlvbiBsYShhKXt4YS5yZW1vdmVDbGFzcyhcXFwiZnItZmlyIGZyLWZpbFxcXCIpLCFiLm9wdHMuaHRtbFVudG91Y2hlZCYmYi5vcHRzLnVzZUNsYXNzZXM/XFxcImxlZnRcXFwiPT1hP3hhLmFkZENsYXNzKFxcXCJmci1maWxcXFwiKTpcXFwicmlnaHRcXFwiPT1hJiZ4YS5hZGRDbGFzcyhcXFwiZnItZmlyXFxcIik6a2EoeGEsbmEoKSxhKSxrKCksZSgpfWZ1bmN0aW9uIG1hKGEpe2lmKFxcXCJ1bmRlZmluZWRcXFwiPT10eXBlb2YgYSYmKGE9eGEpLGEpe2lmKGEuaGFzQ2xhc3MoXFxcImZyLWZpbFxcXCIpKXJldHVyblxcXCJsZWZ0XFxcIjtpZihhLmhhc0NsYXNzKFxcXCJmci1maXJcXFwiKSlyZXR1cm5cXFwicmlnaHRcXFwiO2lmKGEuaGFzQ2xhc3MoXFxcImZyLWRpYlxcXCIpfHxhLmhhc0NsYXNzKFxcXCJmci1kaWlcXFwiKSlyZXR1cm5cXFwiY2VudGVyXFxcIjt2YXIgYj1hLmNzcyhcXFwiZmxvYXRcXFwiKTtpZihhLmNzcyhcXFwiZmxvYXRcXFwiLFxcXCJub25lXFxcIiksXFxcImJsb2NrXFxcIj09YS5jc3MoXFxcImRpc3BsYXlcXFwiKSl7aWYoYS5jc3MoXFxcImZsb2F0XFxcIixcXFwiXFxcIiksYS5jc3MoXFxcImZsb2F0XFxcIikhPWImJmEuY3NzKFxcXCJmbG9hdFxcXCIsYiksMD09PXBhcnNlSW50KGEuY3NzKFxcXCJtYXJnaW4tbGVmdFxcXCIpLDEwKSlyZXR1cm5cXFwibGVmdFxcXCI7aWYoMD09PXBhcnNlSW50KGEuY3NzKFxcXCJtYXJnaW4tcmlnaHRcXFwiKSwxMCkpcmV0dXJuXFxcInJpZ2h0XFxcIn1lbHNle2lmKGEuY3NzKFxcXCJmbG9hdFxcXCIsXFxcIlxcXCIpLGEuY3NzKFxcXCJmbG9hdFxcXCIpIT1iJiZhLmNzcyhcXFwiZmxvYXRcXFwiLGIpLFxcXCJsZWZ0XFxcIj09YS5jc3MoXFxcImZsb2F0XFxcIikpcmV0dXJuXFxcImxlZnRcXFwiO2lmKFxcXCJyaWdodFxcXCI9PWEuY3NzKFxcXCJmbG9hdFxcXCIpKXJldHVyblxcXCJyaWdodFxcXCJ9fXJldHVyblxcXCJjZW50ZXJcXFwifWZ1bmN0aW9uIG5hKGEpe1xcXCJ1bmRlZmluZWRcXFwiPT10eXBlb2YgYSYmKGE9eGEpO3ZhciBiPWEuY3NzKFxcXCJmbG9hdFxcXCIpO3JldHVybiBhLmNzcyhcXFwiZmxvYXRcXFwiLFxcXCJub25lXFxcIiksXFxuXFxcImJsb2NrXFxcIj09YS5jc3MoXFxcImRpc3BsYXlcXFwiKT8oYS5jc3MoXFxcImZsb2F0XFxcIixcXFwiXFxcIiksYS5jc3MoXFxcImZsb2F0XFxcIikhPWImJmEuY3NzKFxcXCJmbG9hdFxcXCIsYiksXFxcImJsb2NrXFxcIik6KGEuY3NzKFxcXCJmbG9hdFxcXCIsXFxcIlxcXCIpLGEuY3NzKFxcXCJmbG9hdFxcXCIpIT1iJiZhLmNzcyhcXFwiZmxvYXRcXFwiLGIpLFxcXCJpbmxpbmVcXFwiKX1mdW5jdGlvbiBvYShhKXt4YSYmYS5maW5kKFxcXCI+ICo6Zmlyc3RcXFwiKS5yZXBsYWNlV2l0aChiLmljb24uY3JlYXRlKFxcXCJpbWFnZS1hbGlnbi1cXFwiK21hKCkpKX1mdW5jdGlvbiBwYShhLGIpe3hhJiZiLmZpbmQoJy5mci1jb21tYW5kW2RhdGEtcGFyYW0xPVxcXCInK21hKCkrJ1xcXCJdJykuYWRkQ2xhc3MoXFxcImZyLWFjdGl2ZVxcXCIpLmF0dHIoXFxcImFyaWEtc2VsZWN0ZWRcXFwiLCEwKX1mdW5jdGlvbiBxYShhKXt4YS5yZW1vdmVDbGFzcyhcXFwiZnItZGlpIGZyLWRpYlxcXCIpLCFiLm9wdHMuaHRtbFVudG91Y2hlZCYmYi5vcHRzLnVzZUNsYXNzZXM/XFxcImlubGluZVxcXCI9PWE/eGEuYWRkQ2xhc3MoXFxcImZyLWRpaVxcXCIpOlxcXCJibG9ja1xcXCI9PWEmJnhhLmFkZENsYXNzKFxcXCJmci1kaWJcXFwiKTprYSh4YSxhLG1hKCkpLGsoKSxlKCl9ZnVuY3Rpb24gcmEoYSxiKXt4YSYmYi5maW5kKCcuZnItY29tbWFuZFtkYXRhLXBhcmFtMT1cXFwiJytuYSgpKydcXFwiXScpLmFkZENsYXNzKFxcXCJmci1hY3RpdmVcXFwiKS5hdHRyKFxcXCJhcmlhLXNlbGVjdGVkXFxcIiwhMCl9ZnVuY3Rpb24gc2EoKXt2YXIgYT1iLnBvcHVwcy5nZXQoXFxcImltYWdlLmluc2VydFxcXCIpO2F8fChhPU0oKSksYi5wb3B1cHMuaXNWaXNpYmxlKFxcXCJpbWFnZS5pbnNlcnRcXFwiKXx8KHMoKSxiLnBvcHVwcy5yZWZyZXNoKFxcXCJpbWFnZS5pbnNlcnRcXFwiKSxiLnBvcHVwcy5zZXRDb250YWluZXIoXFxcImltYWdlLmluc2VydFxcXCIsYi4kc2MpKTt2YXIgYz14YS5vZmZzZXQoKS5sZWZ0K3hhLndpZHRoKCkvMixkPXhhLm9mZnNldCgpLnRvcCt4YS5oZWlnaHQoKTtiLnBvcHVwcy5zaG93KFxcXCJpbWFnZS5pbnNlcnRcXFwiLGMsZCx4YS5vdXRlckhlaWdodCgpKX1mdW5jdGlvbiB0YSgpe2lmKHhhKXtiLnNlbGVjdGlvbi5jbGVhcigpO3ZhciBhPWIuZG9jLmNyZWF0ZVJhbmdlKCk7YS5zZWxlY3ROb2RlKHhhLmdldCgwKSk7dmFyIGM9Yi5zZWxlY3Rpb24uZ2V0KCk7Yy5hZGRSYW5nZShhKX19ZnVuY3Rpb24gdWEoKXt4YT8oYi5ldmVudHMuZGlzYWJsZUJsdXIoKSxhKFxcXCIuZnItcG9wdXAgaW5wdXQ6Zm9jdXNcXFwiKS5ibHVyKCksdyh4YSkpOihiLmV2ZW50cy5kaXNhYmxlQmx1cigpLGIuc2VsZWN0aW9uLnJlc3RvcmUoKSxiLmV2ZW50cy5lbmFibGVCbHVyKCksYi5wb3B1cHMuaGlkZShcXFwiaW1hZ2UuaW5zZXJ0XFxcIiksYi50b29sYmFyLnNob3dJbmxpbmUoKSl9ZnVuY3Rpb24gdmEoKXtyZXR1cm4geGF9ZnVuY3Rpb24gd2EoYSxjLGQpe2lmKFxcXCJ1bmRlZmluZWRcXFwiPT10eXBlb2YgYyYmKGM9Yi5vcHRzLmltYWdlU3R5bGVzKSxcXFwidW5kZWZpbmVkXFxcIj09dHlwZW9mIGQmJihkPWIub3B0cy5pbWFnZU11bHRpcGxlU3R5bGVzKSwheGEpcmV0dXJuITE7aWYoIWQpe3ZhciBlPU9iamVjdC5rZXlzKGMpO2Uuc3BsaWNlKGUuaW5kZXhPZihhKSwxKSx4YS5yZW1vdmVDbGFzcyhlLmpvaW4oXFxcIiBcXFwiKSl9XFxcIm9iamVjdFxcXCI9PXR5cGVvZiBjW2FdPyh4YS5yZW1vdmVBdHRyKFxcXCJzdHlsZVxcXCIpLHhhLmNzcyhjW2FdLnN0eWxlKSk6eGEudG9nZ2xlQ2xhc3MoYSksdyh4YSl9dmFyIHhhLHlhLHphLEFhLEJhPSExLENhPTEsRGE9MixFYT0zLEZhPTQsR2E9NSxIYT02LElhPTcsSmE9e307SmFbQ2FdPVxcXCJJbWFnZSBjYW5ub3QgYmUgbG9hZGVkIGZyb20gdGhlIHBhc3NlZCBsaW5rLlxcXCIsSmFbRGFdPVxcXCJObyBsaW5rIGluIHVwbG9hZCByZXNwb25zZS5cXFwiLEphW0VhXT1cXFwiRXJyb3IgZHVyaW5nIGZpbGUgdXBsb2FkLlxcXCIsSmFbRmFdPVxcXCJQYXJzaW5nIHJlc3BvbnNlIGZhaWxlZC5cXFwiLEphW0dhXT1cXFwiRmlsZSBpcyB0b28gbGFyZ2UuXFxcIixKYVtIYV09XFxcIkltYWdlIGZpbGUgdHlwZSBpcyBpbnZhbGlkLlxcXCIsSmFbSWFdPVxcXCJGaWxlcyBjYW4gYmUgdXBsb2FkZWQgb25seSB0byBzYW1lIGRvbWFpbiBpbiBJRSA4IGFuZCBJRSA5LlxcXCI7dmFyIEthLExhLE1hPSExO3JldHVybntfaW5pdDpiYSxzaG93SW5zZXJ0UG9wdXA6ZCxzaG93TGF5ZXI6VixyZWZyZXNoVXBsb2FkQnV0dG9uOlcscmVmcmVzaEJ5VVJMQnV0dG9uOlgsdXBsb2FkOkgsaW5zZXJ0QnlVUkw6dixhbGlnbjpsYSxyZWZyZXNoQWxpZ246b2EscmVmcmVzaEFsaWduT25TaG93OnBhLGRpc3BsYXk6cWEscmVmcmVzaERpc3BsYXlPblNob3c6cmEscmVwbGFjZTpzYSxiYWNrOnVhLGdldDp2YSxpbnNlcnQ6eSxzaG93UHJvZ3Jlc3NCYXI6cixyZW1vdmU6JCxoaWRlUHJvZ3Jlc3NCYXI6cyxhcHBseVN0eWxlOndhLHNob3dBbHRQb3B1cDpPLHNob3dTaXplUG9wdXA6UyxzZXRBbHQ6USxzZXRTaXplOlUsZXhpdEVkaXQ6Z2EsZWRpdDp3fX0sYS5GRS5EZWZpbmVJY29uKFxcXCJpbnNlcnRJbWFnZVxcXCIse05BTUU6XFxcImltYWdlXFxcIn0pLGEuRkUuUmVnaXN0ZXJTaG9ydGN1dChhLkZFLktFWUNPREUuUCxcXFwiaW5zZXJ0SW1hZ2VcXFwiLG51bGwsXFxcIlBcXFwiKSxhLkZFLlJlZ2lzdGVyQ29tbWFuZChcXFwiaW5zZXJ0SW1hZ2VcXFwiLHt0aXRsZTpcXFwiSW5zZXJ0IEltYWdlXFxcIix1bmRvOiExLGZvY3VzOiEwLHJlZnJlc2hBZnRlckNhbGxiYWNrOiExLHBvcHVwOiEwLGNhbGxiYWNrOmZ1bmN0aW9uKCl7dGhpcy5wb3B1cHMuaXNWaXNpYmxlKFxcXCJpbWFnZS5pbnNlcnRcXFwiKT8odGhpcy4kZWwuZmluZChcXFwiLmZyLW1hcmtlclxcXCIpLmxlbmd0aCYmKHRoaXMuZXZlbnRzLmRpc2FibGVCbHVyKCksdGhpcy5zZWxlY3Rpb24ucmVzdG9yZSgpKSx0aGlzLnBvcHVwcy5oaWRlKFxcXCJpbWFnZS5pbnNlcnRcXFwiKSk6dGhpcy5pbWFnZS5zaG93SW5zZXJ0UG9wdXAoKX0scGx1Z2luOlxcXCJpbWFnZVxcXCJ9KSxhLkZFLkRlZmluZUljb24oXFxcImltYWdlVXBsb2FkXFxcIix7TkFNRTpcXFwidXBsb2FkXFxcIn0pLGEuRkUuUmVnaXN0ZXJDb21tYW5kKFxcXCJpbWFnZVVwbG9hZFxcXCIse3RpdGxlOlxcXCJVcGxvYWQgSW1hZ2VcXFwiLHVuZG86ITEsZm9jdXM6ITEsdG9nZ2xlOiEwLGNhbGxiYWNrOmZ1bmN0aW9uKCl7dGhpcy5pbWFnZS5zaG93TGF5ZXIoXFxcImltYWdlLXVwbG9hZFxcXCIpfSxyZWZyZXNoOmZ1bmN0aW9uKGEpe3RoaXMuaW1hZ2UucmVmcmVzaFVwbG9hZEJ1dHRvbihhKX19KSxhLkZFLkRlZmluZUljb24oXFxcImltYWdlQnlVUkxcXFwiLHtOQU1FOlxcXCJsaW5rXFxcIn0pLGEuRkUuUmVnaXN0ZXJDb21tYW5kKFxcXCJpbWFnZUJ5VVJMXFxcIix7dGl0bGU6XFxcIkJ5IFVSTFxcXCIsdW5kbzohMSxmb2N1czohMSx0b2dnbGU6ITAsY2FsbGJhY2s6ZnVuY3Rpb24oKXt0aGlzLmltYWdlLnNob3dMYXllcihcXFwiaW1hZ2UtYnktdXJsXFxcIil9LHJlZnJlc2g6ZnVuY3Rpb24oYSl7dGhpcy5pbWFnZS5yZWZyZXNoQnlVUkxCdXR0b24oYSl9fSksYS5GRS5SZWdpc3RlckNvbW1hbmQoXFxcImltYWdlSW5zZXJ0QnlVUkxcXFwiLHt0aXRsZTpcXFwiSW5zZXJ0IEltYWdlXFxcIix1bmRvOiEwLHJlZnJlc2hBZnRlckNhbGxiYWNrOiExLGNhbGxiYWNrOmZ1bmN0aW9uKCl7dGhpcy5pbWFnZS5pbnNlcnRCeVVSTCgpfSxyZWZyZXNoOmZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMuaW1hZ2UuZ2V0KCk7Yj9hLnRleHQodGhpcy5sYW5ndWFnZS50cmFuc2xhdGUoXFxcIlJlcGxhY2VcXFwiKSk6YS50ZXh0KHRoaXMubGFuZ3VhZ2UudHJhbnNsYXRlKFxcXCJJbnNlcnRcXFwiKSl9fSksYS5GRS5EZWZpbmVJY29uKFxcXCJpbWFnZURpc3BsYXlcXFwiLHtOQU1FOlxcXCJzdGFyXFxcIn0pLGEuRkUuUmVnaXN0ZXJDb21tYW5kKFxcXCJpbWFnZURpc3BsYXlcXFwiLHt0aXRsZTpcXFwiRGlzcGxheVxcXCIsdHlwZTpcXFwiZHJvcGRvd25cXFwiLG9wdGlvbnM6e2lubGluZTpcXFwiSW5saW5lXFxcIixibG9jazpcXFwiQnJlYWsgVGV4dFxcXCJ9LGNhbGxiYWNrOmZ1bmN0aW9uKGEsYil7dGhpcy5pbWFnZS5kaXNwbGF5KGIpfSxyZWZyZXNoOmZ1bmN0aW9uKGEpe3RoaXMub3B0cy5pbWFnZVRleHROZWFyfHxhLmFkZENsYXNzKFxcXCJmci1oaWRkZW5cXFwiKX0scmVmcmVzaE9uU2hvdzpmdW5jdGlvbihhLGIpe3RoaXMuaW1hZ2UucmVmcmVzaERpc3BsYXlPblNob3coYSxiKX19KSxhLkZFLkRlZmluZUljb24oXFxcImltYWdlLWFsaWduXFxcIix7TkFNRTpcXFwiYWxpZ24tbGVmdFxcXCJ9KSxhLkZFLkRlZmluZUljb24oXFxcImltYWdlLWFsaWduLWxlZnRcXFwiLHtOQU1FOlxcXCJhbGlnbi1sZWZ0XFxcIn0pLGEuRkUuRGVmaW5lSWNvbihcXFwiaW1hZ2UtYWxpZ24tcmlnaHRcXFwiLHtOQU1FOlxcXCJhbGlnbi1yaWdodFxcXCJ9KSxhLkZFLkRlZmluZUljb24oXFxcImltYWdlLWFsaWduLWNlbnRlclxcXCIse05BTUU6XFxcImFsaWduLWp1c3RpZnlcXFwifSksYS5GRS5EZWZpbmVJY29uKFxcXCJpbWFnZUFsaWduXFxcIix7TkFNRTpcXFwiYWxpZ24tanVzdGlmeVxcXCJ9KSxhLkZFLlJlZ2lzdGVyQ29tbWFuZChcXFwiaW1hZ2VBbGlnblxcXCIse3R5cGU6XFxcImRyb3Bkb3duXFxcIix0aXRsZTpcXFwiQWxpZ25cXFwiLG9wdGlvbnM6e2xlZnQ6XFxcIkFsaWduIExlZnRcXFwiLGNlbnRlcjpcXFwiTm9uZVxcXCIscmlnaHQ6XFxcIkFsaWduIFJpZ2h0XFxcIn0saHRtbDpmdW5jdGlvbigpe3ZhciBiPSc8dWwgY2xhc3M9XFxcImZyLWRyb3Bkb3duLWxpc3RcXFwiIHJvbGU9XFxcInByZXNlbnRhdGlvblxcXCI+JyxjPWEuRkUuQ09NTUFORFMuaW1hZ2VBbGlnbi5vcHRpb25zO2Zvcih2YXIgZCBpbiBjKWMuaGFzT3duUHJvcGVydHkoZCkmJihiKz0nPGxpIHJvbGU9XFxcInByZXNlbnRhdGlvblxcXCI+PGEgY2xhc3M9XFxcImZyLWNvbW1hbmQgZnItdGl0bGVcXFwiIHRhYkluZGV4PVxcXCItMVxcXCIgcm9sZT1cXFwib3B0aW9uXFxcIiBkYXRhLWNtZD1cXFwiaW1hZ2VBbGlnblxcXCIgZGF0YS1wYXJhbTE9XFxcIicrZCsnXFxcIiB0aXRsZT1cXFwiJyt0aGlzLmxhbmd1YWdlLnRyYW5zbGF0ZShjW2RdKSsnXFxcIj4nK3RoaXMuaWNvbi5jcmVhdGUoXFxcImltYWdlLWFsaWduLVxcXCIrZCkrJzxzcGFuIGNsYXNzPVxcXCJmci1zci1vbmx5XFxcIj4nK3RoaXMubGFuZ3VhZ2UudHJhbnNsYXRlKGNbZF0pK1xcXCI8L3NwYW4+PC9hPjwvbGk+XFxcIik7cmV0dXJuIGIrPVxcXCI8L3VsPlxcXCJ9LGNhbGxiYWNrOmZ1bmN0aW9uKGEsYil7dGhpcy5pbWFnZS5hbGlnbihiKX0scmVmcmVzaDpmdW5jdGlvbihhKXt0aGlzLmltYWdlLnJlZnJlc2hBbGlnbihhKX0scmVmcmVzaE9uU2hvdzpmdW5jdGlvbihhLGIpe3RoaXMuaW1hZ2UucmVmcmVzaEFsaWduT25TaG93KGEsYil9fSksYS5GRS5EZWZpbmVJY29uKFxcXCJpbWFnZVJlcGxhY2VcXFwiLHtOQU1FOlxcXCJleGNoYW5nZVxcXCJ9KSxhLkZFLlJlZ2lzdGVyQ29tbWFuZChcXFwiaW1hZ2VSZXBsYWNlXFxcIix7dGl0bGU6XFxcIlJlcGxhY2VcXFwiLHVuZG86ITEsZm9jdXM6ITEscG9wdXA6ITAscmVmcmVzaEFmdGVyQ2FsbGJhY2s6ITEsY2FsbGJhY2s6ZnVuY3Rpb24oKXt0aGlzLmltYWdlLnJlcGxhY2UoKX19KSxhLkZFLkRlZmluZUljb24oXFxcImltYWdlUmVtb3ZlXFxcIix7TkFNRTpcXFwidHJhc2hcXFwifSksYS5GRS5SZWdpc3RlckNvbW1hbmQoXFxcImltYWdlUmVtb3ZlXFxcIix7dGl0bGU6XFxcIlJlbW92ZVxcXCIsY2FsbGJhY2s6ZnVuY3Rpb24oKXt0aGlzLmltYWdlLnJlbW92ZSgpfX0pLGEuRkUuRGVmaW5lSWNvbihcXFwiaW1hZ2VCYWNrXFxcIix7TkFNRTpcXFwiYXJyb3ctbGVmdFxcXCJ9KSxhLkZFLlJlZ2lzdGVyQ29tbWFuZChcXFwiaW1hZ2VCYWNrXFxcIix7dGl0bGU6XFxcIkJhY2tcXFwiLHVuZG86ITEsZm9jdXM6ITEsYmFjazohMCxjYWxsYmFjazpmdW5jdGlvbigpe3RoaXMuaW1hZ2UuYmFjaygpfSxyZWZyZXNoOmZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMuaW1hZ2UuZ2V0KCk7Ynx8dGhpcy5vcHRzLnRvb2xiYXJJbmxpbmU/KGEucmVtb3ZlQ2xhc3MoXFxcImZyLWhpZGRlblxcXCIpLGEubmV4dChcXFwiLmZyLXNlcGFyYXRvclxcXCIpLnJlbW92ZUNsYXNzKFxcXCJmci1oaWRkZW5cXFwiKSk6KGEuYWRkQ2xhc3MoXFxcImZyLWhpZGRlblxcXCIpLGEubmV4dChcXFwiLmZyLXNlcGFyYXRvclxcXCIpLmFkZENsYXNzKFxcXCJmci1oaWRkZW5cXFwiKSl9fSksYS5GRS5SZWdpc3RlckNvbW1hbmQoXFxcImltYWdlRGlzbWlzc0Vycm9yXFxcIix7dGl0bGU6XFxcIk9LXFxcIix1bmRvOiExLGNhbGxiYWNrOmZ1bmN0aW9uKCl7dGhpcy5pbWFnZS5oaWRlUHJvZ3Jlc3NCYXIoITApfX0pLGEuRkUuRGVmaW5lSWNvbihcXFwiaW1hZ2VTdHlsZVxcXCIse05BTUU6XFxcIm1hZ2ljXFxcIn0pLGEuRkUuUmVnaXN0ZXJDb21tYW5kKFxcXCJpbWFnZVN0eWxlXFxcIix7dGl0bGU6XFxcIlN0eWxlXFxcIix0eXBlOlxcXCJkcm9wZG93blxcXCIsaHRtbDpmdW5jdGlvbigpe3ZhciBhPSc8dWwgY2xhc3M9XFxcImZyLWRyb3Bkb3duLWxpc3RcXFwiIHJvbGU9XFxcInByZXNlbnRhdGlvblxcXCI+JyxiPXRoaXMub3B0cy5pbWFnZVN0eWxlcztmb3IodmFyIGMgaW4gYilpZihiLmhhc093blByb3BlcnR5KGMpKXt2YXIgZD1iW2NdO1xcXCJvYmplY3RcXFwiPT10eXBlb2YgZCYmKGQ9ZC50aXRsZSksYSs9JzxsaSByb2xlPVxcXCJwcmVzZW50YXRpb25cXFwiPjxhIGNsYXNzPVxcXCJmci1jb21tYW5kXFxcIiB0YWJJbmRleD1cXFwiLTFcXFwiIHJvbGU9XFxcIm9wdGlvblxcXCIgZGF0YS1jbWQ9XFxcImltYWdlU3R5bGVcXFwiIGRhdGEtcGFyYW0xPVxcXCInK2MrJ1xcXCI+Jyt0aGlzLmxhbmd1YWdlLnRyYW5zbGF0ZShkKStcXFwiPC9hPjwvbGk+XFxcIn1yZXR1cm4gYSs9XFxcIjwvdWw+XFxcIn0sY2FsbGJhY2s6ZnVuY3Rpb24oYSxiKXt0aGlzLmltYWdlLmFwcGx5U3R5bGUoYil9LHJlZnJlc2hPblNob3c6ZnVuY3Rpb24oYixjKXt2YXIgZD10aGlzLmltYWdlLmdldCgpO2QmJmMuZmluZChcXFwiLmZyLWNvbW1hbmRcXFwiKS5lYWNoKGZ1bmN0aW9uKCl7dmFyIGI9YSh0aGlzKS5kYXRhKFxcXCJwYXJhbTFcXFwiKSxjPWQuaGFzQ2xhc3MoYik7YSh0aGlzKS50b2dnbGVDbGFzcyhcXFwiZnItYWN0aXZlXFxcIixjKS5hdHRyKFxcXCJhcmlhLXNlbGVjdGVkXFxcIixjKX0pfX0pLGEuRkUuRGVmaW5lSWNvbihcXFwiaW1hZ2VBbHRcXFwiLHtOQU1FOlxcXCJpbmZvXFxcIn0pLGEuRkUuUmVnaXN0ZXJDb21tYW5kKFxcXCJpbWFnZUFsdFxcXCIse3VuZG86ITEsZm9jdXM6ITEscG9wdXA6ITAsdGl0bGU6XFxcIkFsdGVybmF0ZSBUZXh0XFxcIixjYWxsYmFjazpmdW5jdGlvbigpe3RoaXMuaW1hZ2Uuc2hvd0FsdFBvcHVwKCl9fSksYS5GRS5SZWdpc3RlckNvbW1hbmQoXFxcImltYWdlU2V0QWx0XFxcIix7dW5kbzohMCxmb2N1czohMSx0aXRsZTpcXFwiVXBkYXRlXFxcIixyZWZyZXNoQWZ0ZXJDYWxsYmFjazohMSxjYWxsYmFjazpmdW5jdGlvbigpe3RoaXMuaW1hZ2Uuc2V0QWx0KCl9fSksYS5GRS5EZWZpbmVJY29uKFxcXCJpbWFnZVNpemVcXFwiLHtOQU1FOlxcXCJhcnJvd3MtYWx0XFxcIn0pLGEuRkUuUmVnaXN0ZXJDb21tYW5kKFxcXCJpbWFnZVNpemVcXFwiLHt1bmRvOiExLGZvY3VzOiExLHBvcHVwOiEwLHRpdGxlOlxcXCJDaGFuZ2UgU2l6ZVxcXCIsY2FsbGJhY2s6ZnVuY3Rpb24oKXt0aGlzLmltYWdlLnNob3dTaXplUG9wdXAoKX19KSxhLkZFLlJlZ2lzdGVyQ29tbWFuZChcXFwiaW1hZ2VTZXRTaXplXFxcIix7dW5kbzohMCxmb2N1czohMSx0aXRsZTpcXFwiVXBkYXRlXFxcIixyZWZyZXNoQWZ0ZXJDYWxsYmFjazohMSxjYWxsYmFjazpmdW5jdGlvbigpe3RoaXMuaW1hZ2Uuc2V0U2l6ZSgpfX0pfSk7XCJcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcmF3LWxvYWRlciEuL34vZnJvYWxhLWVkaXRvci9qcy9wbHVnaW5zL2ltYWdlLm1pbi5qc1xuLy8gbW9kdWxlIGlkID0gMjFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQSIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 22 */
/***/ function(module, exports, __webpack_require__) {

	eval("__webpack_require__(2)(__webpack_require__(23))//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjIuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2Zyb2FsYS1lZGl0b3IvanMvbGFuZ3VhZ2VzL2VuX2diLmpzPzczYTgiXSwic291cmNlc0NvbnRlbnQiOlsicmVxdWlyZShcIiEhL1VzZXJzL2pha3ViZmFqa3VzL0RvY3VtZW50cy9wcmFjZS92ZW5pY2UtZGVtby93ZWIvanMvbm9kZV9tb2R1bGVzL3NjcmlwdC1sb2FkZXIvYWRkU2NyaXB0LmpzXCIpKHJlcXVpcmUoXCIhIS9Vc2Vycy9qYWt1YmZhamt1cy9Eb2N1bWVudHMvcHJhY2UvdmVuaWNlLWRlbW8vd2ViL2pzL25vZGVfbW9kdWxlcy9yYXctbG9hZGVyL2luZGV4LmpzIS9Vc2Vycy9qYWt1YmZhamt1cy9Eb2N1bWVudHMvcHJhY2UvdmVuaWNlLWRlbW8vd2ViL2pzL25vZGVfbW9kdWxlcy9mcm9hbGEtZWRpdG9yL2pzL2xhbmd1YWdlcy9lbl9nYi5qc1wiKSlcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vc2NyaXB0LWxvYWRlciEuL34vZnJvYWxhLWVkaXRvci9qcy9sYW5ndWFnZXMvZW5fZ2IuanNcbi8vIG1vZHVsZSBpZCA9IDIyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 23 */
/***/ function(module, exports) {

	eval("module.exports = \"/*!\\n * froala_editor v2.5.0 (https://www.froala.com/wysiwyg-editor)\\n * License https://froala.com/wysiwyg-editor/terms/\\n * Copyright 2014-2017 Froala Labs\\n */\\n\\n/**\\n * English spoken in Great Britain\\n */\\n\\n$.FE.LANGUAGE['en_gb'] = {\\n  translation: {\\n    // Place holder\\n    \\\"Type something\\\": \\\"Type something\\\",\\n\\n    // Basic formatting\\n    \\\"Bold\\\": \\\"Bold\\\",\\n    \\\"Italic\\\": \\\"Italic\\\",\\n    \\\"Underline\\\": \\\"Underline\\\",\\n    \\\"Strikethrough\\\": \\\"Strikethrough\\\",\\n\\n    // Main buttons\\n    \\\"Insert\\\": \\\"Insert\\\",\\n    \\\"Delete\\\": \\\"Delete\\\",\\n    \\\"Cancel\\\": \\\"Cancel\\\",\\n    \\\"OK\\\": \\\"OK\\\",\\n    \\\"Back\\\": \\\"Back\\\",\\n    \\\"Remove\\\": \\\"Remove\\\",\\n    \\\"More\\\": \\\"More\\\",\\n    \\\"Update\\\": \\\"Update\\\",\\n    \\\"Style\\\": \\\"Style\\\",\\n\\n    // Font\\n    \\\"Font Family\\\": \\\"Font Family\\\",\\n    \\\"Font Size\\\": \\\"Font Size\\\",\\n\\n    // Colors\\n    \\\"Colors\\\": \\\"Colours\\\",\\n    \\\"Background\\\": \\\"Background\\\",\\n    \\\"Text\\\": \\\"Text\\\",\\n\\n    // Paragraphs\\n    \\\"Paragraph Format\\\": \\\"Paragraph Format\\\",\\n    \\\"Normal\\\": \\\"Normal\\\",\\n    \\\"Code\\\": \\\"Code\\\",\\n    \\\"Heading 1\\\": \\\"Heading 1\\\",\\n    \\\"Heading 2\\\": \\\"Heading 2\\\",\\n    \\\"Heading 3\\\": \\\"Heading 3\\\",\\n    \\\"Heading 4\\\": \\\"Heading 4\\\",\\n\\n    // Style\\n    \\\"Paragraph Style\\\": \\\"Paragraph Style\\\",\\n    \\\"Inline Style\\\": \\\"Inline Style\\\",\\n\\n    // Alignment\\n    \\\"Align\\\": \\\"Align\\\",\\n    \\\"Align Left\\\": \\\"Align Left\\\",\\n    \\\"Align Center\\\": \\\"Align Centre\\\",\\n    \\\"Align Right\\\": \\\"Alight Right\\\",\\n    \\\"Align Justify\\\": \\\"Align Justify\\\",\\n    \\\"None\\\": \\\"None\\\",\\n\\n    // Lists\\n    \\\"Ordered List\\\": \\\"Ordered List\\\",\\n    \\\"Unordered List\\\": \\\"Unordered List\\\",\\n\\n    // Indent\\n    \\\"Decrease Indent\\\": \\\"Decrease Indent\\\",\\n    \\\"Increase Indent\\\": \\\"Increase Indent\\\",\\n\\n    // Links\\n    \\\"Insert Link\\\": \\\"Insert Link\\\",\\n    \\\"Open in new tab\\\": \\\"Open in new tab\\\",\\n    \\\"Open Link\\\": \\\"Open Link\\\",\\n    \\\"Edit Link\\\": \\\"Edit Link\\\",\\n    \\\"Unlink\\\": \\\"Unlink\\\",\\n    \\\"Choose Link\\\": \\\"Choose Link\\\",\\n\\n    // Images\\n    \\\"Insert Image\\\": \\\"Insert Image\\\",\\n    \\\"Upload Image\\\": \\\"Upload Image\\\",\\n    \\\"By URL\\\": \\\"By URL\\\",\\n    \\\"Browse\\\": \\\"Browse\\\",\\n    \\\"Drop image\\\": \\\"Drop image\\\",\\n    \\\"or click\\\": \\\"or click\\\",\\n    \\\"Manage Images\\\": \\\"Manage Images\\\",\\n    \\\"Loading\\\": \\\"Loading\\\",\\n    \\\"Deleting\\\": \\\"Deleting\\\",\\n    \\\"Tags\\\": \\\"Tags\\\",\\n    \\\"Are you sure? Image will be deleted.\\\": \\\"Are you sure? Image will be deleted.\\\",\\n    \\\"Replace\\\": \\\"Replace\\\",\\n    \\\"Uploading\\\": \\\"Uploading\\\",\\n    \\\"Loading image\\\": \\\"Loading image\\\",\\n    \\\"Display\\\": \\\"Display\\\",\\n    \\\"Inline\\\": \\\"Inline\\\",\\n    \\\"Break Text\\\": \\\"Break Text\\\",\\n    \\\"Alternate Text\\\": \\\"Alternate Text\\\",\\n    \\\"Change Size\\\": \\\"Change Size\\\",\\n    \\\"Width\\\": \\\"Width\\\",\\n    \\\"Height\\\": \\\"Height\\\",\\n    \\\"Something went wrong. Please try again.\\\": \\\"Something went wrong. Please try again.\\\",\\n\\n    // Video\\n    \\\"Insert Video\\\": \\\"Insert Video\\\",\\n    \\\"Embedded Code\\\": \\\"Embedded Code\\\",\\n\\n    // Tables\\n    \\\"Insert Table\\\": \\\"Insert Table\\\",\\n    \\\"Table Header\\\": \\\"Table Header\\\",\\n    \\\"Remove Table\\\": \\\"Remove Table\\\",\\n    \\\"Table Style\\\": \\\"Table Style\\\",\\n    \\\"Horizontal Align\\\": \\\"Horizontal Align\\\",\\n    \\\"Row\\\": \\\"Row\\\",\\n    \\\"Insert row above\\\": \\\"Insert row above\\\",\\n    \\\"Insert row below\\\": \\\"Insert row below\\\",\\n    \\\"Delete row\\\": \\\"Delete row\\\",\\n    \\\"Column\\\": \\\"Column\\\",\\n    \\\"Insert column before\\\": \\\"Insert column before\\\",\\n    \\\"Insert column after\\\": \\\"Insert column after\\\",\\n    \\\"Delete column\\\": \\\"Delete column\\\",\\n    \\\"Cell\\\": \\\"Cell\\\",\\n    \\\"Merge cells\\\": \\\"Merge cells\\\",\\n    \\\"Horizontal split\\\": \\\"Horizontal split\\\",\\n    \\\"Vertical split\\\": \\\"Vertical split\\\",\\n    \\\"Cell Background\\\": \\\"Cell Background\\\",\\n    \\\"Vertical Align\\\": \\\"Vertical Align\\\",\\n    \\\"Top\\\": \\\"Top\\\",\\n    \\\"Middle\\\": \\\"Middle\\\",\\n    \\\"Bottom\\\": \\\"Bottom\\\",\\n    \\\"Align Top\\\": \\\"Align Top\\\",\\n    \\\"Align Middle\\\": \\\"Align Middle\\\",\\n    \\\"Align Bottom\\\": \\\"Align Bottom\\\",\\n    \\\"Cell Style\\\": \\\"Cell Style\\\",\\n\\n    // Files\\n    \\\"Upload File\\\": \\\"Upload File\\\",\\n    \\\"Drop file\\\": \\\"Drop file\\\",\\n\\n    // Emoticons\\n    \\\"Emoticons\\\": \\\"Emoticons\\\",\\n\\n    // Line breaker\\n    \\\"Break\\\": \\\"Break\\\",\\n\\n    // Math\\n    \\\"Subscript\\\": \\\"Subscript\\\",\\n    \\\"Superscript\\\": \\\"Superscript\\\",\\n\\n    // Full screen\\n    \\\"Fullscreen\\\": \\\"Fullscreen\\\",\\n\\n    // Horizontal line\\n    \\\"Insert Horizontal Line\\\": \\\"Insert Horizontal Line\\\",\\n\\n    // Clear formatting\\n    \\\"Clear Formatting\\\": \\\"Cell Formatting\\\",\\n\\n    // Undo, redo\\n    \\\"Undo\\\": \\\"Undo\\\",\\n    \\\"Redo\\\": \\\"Redo\\\",\\n\\n    // Select all\\n    \\\"Select All\\\": \\\"Select All\\\",\\n\\n    // Code view\\n    \\\"Code View\\\": \\\"Code View\\\",\\n\\n    // Quote\\n    \\\"Quote\\\": \\\"Quote\\\",\\n    \\\"Increase\\\": \\\"Increase\\\",\\n    \\\"Decrease\\\": \\\"Decrease\\\",\\n\\n    // Quick Insert\\n    \\\"Quick Insert\\\": \\\"Quick Insert\\\"\\n  },\\n  direction: \\\"ltr\\\"\\n};\\n\"//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2Zyb2FsYS1lZGl0b3IvanMvbGFuZ3VhZ2VzL2VuX2diLmpzP2U4NTUiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBcIi8qIVxcbiAqIGZyb2FsYV9lZGl0b3IgdjIuNS4wIChodHRwczovL3d3dy5mcm9hbGEuY29tL3d5c2l3eWctZWRpdG9yKVxcbiAqIExpY2Vuc2UgaHR0cHM6Ly9mcm9hbGEuY29tL3d5c2l3eWctZWRpdG9yL3Rlcm1zL1xcbiAqIENvcHlyaWdodCAyMDE0LTIwMTcgRnJvYWxhIExhYnNcXG4gKi9cXG5cXG4vKipcXG4gKiBFbmdsaXNoIHNwb2tlbiBpbiBHcmVhdCBCcml0YWluXFxuICovXFxuXFxuJC5GRS5MQU5HVUFHRVsnZW5fZ2InXSA9IHtcXG4gIHRyYW5zbGF0aW9uOiB7XFxuICAgIC8vIFBsYWNlIGhvbGRlclxcbiAgICBcXFwiVHlwZSBzb21ldGhpbmdcXFwiOiBcXFwiVHlwZSBzb21ldGhpbmdcXFwiLFxcblxcbiAgICAvLyBCYXNpYyBmb3JtYXR0aW5nXFxuICAgIFxcXCJCb2xkXFxcIjogXFxcIkJvbGRcXFwiLFxcbiAgICBcXFwiSXRhbGljXFxcIjogXFxcIkl0YWxpY1xcXCIsXFxuICAgIFxcXCJVbmRlcmxpbmVcXFwiOiBcXFwiVW5kZXJsaW5lXFxcIixcXG4gICAgXFxcIlN0cmlrZXRocm91Z2hcXFwiOiBcXFwiU3RyaWtldGhyb3VnaFxcXCIsXFxuXFxuICAgIC8vIE1haW4gYnV0dG9uc1xcbiAgICBcXFwiSW5zZXJ0XFxcIjogXFxcIkluc2VydFxcXCIsXFxuICAgIFxcXCJEZWxldGVcXFwiOiBcXFwiRGVsZXRlXFxcIixcXG4gICAgXFxcIkNhbmNlbFxcXCI6IFxcXCJDYW5jZWxcXFwiLFxcbiAgICBcXFwiT0tcXFwiOiBcXFwiT0tcXFwiLFxcbiAgICBcXFwiQmFja1xcXCI6IFxcXCJCYWNrXFxcIixcXG4gICAgXFxcIlJlbW92ZVxcXCI6IFxcXCJSZW1vdmVcXFwiLFxcbiAgICBcXFwiTW9yZVxcXCI6IFxcXCJNb3JlXFxcIixcXG4gICAgXFxcIlVwZGF0ZVxcXCI6IFxcXCJVcGRhdGVcXFwiLFxcbiAgICBcXFwiU3R5bGVcXFwiOiBcXFwiU3R5bGVcXFwiLFxcblxcbiAgICAvLyBGb250XFxuICAgIFxcXCJGb250IEZhbWlseVxcXCI6IFxcXCJGb250IEZhbWlseVxcXCIsXFxuICAgIFxcXCJGb250IFNpemVcXFwiOiBcXFwiRm9udCBTaXplXFxcIixcXG5cXG4gICAgLy8gQ29sb3JzXFxuICAgIFxcXCJDb2xvcnNcXFwiOiBcXFwiQ29sb3Vyc1xcXCIsXFxuICAgIFxcXCJCYWNrZ3JvdW5kXFxcIjogXFxcIkJhY2tncm91bmRcXFwiLFxcbiAgICBcXFwiVGV4dFxcXCI6IFxcXCJUZXh0XFxcIixcXG5cXG4gICAgLy8gUGFyYWdyYXBoc1xcbiAgICBcXFwiUGFyYWdyYXBoIEZvcm1hdFxcXCI6IFxcXCJQYXJhZ3JhcGggRm9ybWF0XFxcIixcXG4gICAgXFxcIk5vcm1hbFxcXCI6IFxcXCJOb3JtYWxcXFwiLFxcbiAgICBcXFwiQ29kZVxcXCI6IFxcXCJDb2RlXFxcIixcXG4gICAgXFxcIkhlYWRpbmcgMVxcXCI6IFxcXCJIZWFkaW5nIDFcXFwiLFxcbiAgICBcXFwiSGVhZGluZyAyXFxcIjogXFxcIkhlYWRpbmcgMlxcXCIsXFxuICAgIFxcXCJIZWFkaW5nIDNcXFwiOiBcXFwiSGVhZGluZyAzXFxcIixcXG4gICAgXFxcIkhlYWRpbmcgNFxcXCI6IFxcXCJIZWFkaW5nIDRcXFwiLFxcblxcbiAgICAvLyBTdHlsZVxcbiAgICBcXFwiUGFyYWdyYXBoIFN0eWxlXFxcIjogXFxcIlBhcmFncmFwaCBTdHlsZVxcXCIsXFxuICAgIFxcXCJJbmxpbmUgU3R5bGVcXFwiOiBcXFwiSW5saW5lIFN0eWxlXFxcIixcXG5cXG4gICAgLy8gQWxpZ25tZW50XFxuICAgIFxcXCJBbGlnblxcXCI6IFxcXCJBbGlnblxcXCIsXFxuICAgIFxcXCJBbGlnbiBMZWZ0XFxcIjogXFxcIkFsaWduIExlZnRcXFwiLFxcbiAgICBcXFwiQWxpZ24gQ2VudGVyXFxcIjogXFxcIkFsaWduIENlbnRyZVxcXCIsXFxuICAgIFxcXCJBbGlnbiBSaWdodFxcXCI6IFxcXCJBbGlnaHQgUmlnaHRcXFwiLFxcbiAgICBcXFwiQWxpZ24gSnVzdGlmeVxcXCI6IFxcXCJBbGlnbiBKdXN0aWZ5XFxcIixcXG4gICAgXFxcIk5vbmVcXFwiOiBcXFwiTm9uZVxcXCIsXFxuXFxuICAgIC8vIExpc3RzXFxuICAgIFxcXCJPcmRlcmVkIExpc3RcXFwiOiBcXFwiT3JkZXJlZCBMaXN0XFxcIixcXG4gICAgXFxcIlVub3JkZXJlZCBMaXN0XFxcIjogXFxcIlVub3JkZXJlZCBMaXN0XFxcIixcXG5cXG4gICAgLy8gSW5kZW50XFxuICAgIFxcXCJEZWNyZWFzZSBJbmRlbnRcXFwiOiBcXFwiRGVjcmVhc2UgSW5kZW50XFxcIixcXG4gICAgXFxcIkluY3JlYXNlIEluZGVudFxcXCI6IFxcXCJJbmNyZWFzZSBJbmRlbnRcXFwiLFxcblxcbiAgICAvLyBMaW5rc1xcbiAgICBcXFwiSW5zZXJ0IExpbmtcXFwiOiBcXFwiSW5zZXJ0IExpbmtcXFwiLFxcbiAgICBcXFwiT3BlbiBpbiBuZXcgdGFiXFxcIjogXFxcIk9wZW4gaW4gbmV3IHRhYlxcXCIsXFxuICAgIFxcXCJPcGVuIExpbmtcXFwiOiBcXFwiT3BlbiBMaW5rXFxcIixcXG4gICAgXFxcIkVkaXQgTGlua1xcXCI6IFxcXCJFZGl0IExpbmtcXFwiLFxcbiAgICBcXFwiVW5saW5rXFxcIjogXFxcIlVubGlua1xcXCIsXFxuICAgIFxcXCJDaG9vc2UgTGlua1xcXCI6IFxcXCJDaG9vc2UgTGlua1xcXCIsXFxuXFxuICAgIC8vIEltYWdlc1xcbiAgICBcXFwiSW5zZXJ0IEltYWdlXFxcIjogXFxcIkluc2VydCBJbWFnZVxcXCIsXFxuICAgIFxcXCJVcGxvYWQgSW1hZ2VcXFwiOiBcXFwiVXBsb2FkIEltYWdlXFxcIixcXG4gICAgXFxcIkJ5IFVSTFxcXCI6IFxcXCJCeSBVUkxcXFwiLFxcbiAgICBcXFwiQnJvd3NlXFxcIjogXFxcIkJyb3dzZVxcXCIsXFxuICAgIFxcXCJEcm9wIGltYWdlXFxcIjogXFxcIkRyb3AgaW1hZ2VcXFwiLFxcbiAgICBcXFwib3IgY2xpY2tcXFwiOiBcXFwib3IgY2xpY2tcXFwiLFxcbiAgICBcXFwiTWFuYWdlIEltYWdlc1xcXCI6IFxcXCJNYW5hZ2UgSW1hZ2VzXFxcIixcXG4gICAgXFxcIkxvYWRpbmdcXFwiOiBcXFwiTG9hZGluZ1xcXCIsXFxuICAgIFxcXCJEZWxldGluZ1xcXCI6IFxcXCJEZWxldGluZ1xcXCIsXFxuICAgIFxcXCJUYWdzXFxcIjogXFxcIlRhZ3NcXFwiLFxcbiAgICBcXFwiQXJlIHlvdSBzdXJlPyBJbWFnZSB3aWxsIGJlIGRlbGV0ZWQuXFxcIjogXFxcIkFyZSB5b3Ugc3VyZT8gSW1hZ2Ugd2lsbCBiZSBkZWxldGVkLlxcXCIsXFxuICAgIFxcXCJSZXBsYWNlXFxcIjogXFxcIlJlcGxhY2VcXFwiLFxcbiAgICBcXFwiVXBsb2FkaW5nXFxcIjogXFxcIlVwbG9hZGluZ1xcXCIsXFxuICAgIFxcXCJMb2FkaW5nIGltYWdlXFxcIjogXFxcIkxvYWRpbmcgaW1hZ2VcXFwiLFxcbiAgICBcXFwiRGlzcGxheVxcXCI6IFxcXCJEaXNwbGF5XFxcIixcXG4gICAgXFxcIklubGluZVxcXCI6IFxcXCJJbmxpbmVcXFwiLFxcbiAgICBcXFwiQnJlYWsgVGV4dFxcXCI6IFxcXCJCcmVhayBUZXh0XFxcIixcXG4gICAgXFxcIkFsdGVybmF0ZSBUZXh0XFxcIjogXFxcIkFsdGVybmF0ZSBUZXh0XFxcIixcXG4gICAgXFxcIkNoYW5nZSBTaXplXFxcIjogXFxcIkNoYW5nZSBTaXplXFxcIixcXG4gICAgXFxcIldpZHRoXFxcIjogXFxcIldpZHRoXFxcIixcXG4gICAgXFxcIkhlaWdodFxcXCI6IFxcXCJIZWlnaHRcXFwiLFxcbiAgICBcXFwiU29tZXRoaW5nIHdlbnQgd3JvbmcuIFBsZWFzZSB0cnkgYWdhaW4uXFxcIjogXFxcIlNvbWV0aGluZyB3ZW50IHdyb25nLiBQbGVhc2UgdHJ5IGFnYWluLlxcXCIsXFxuXFxuICAgIC8vIFZpZGVvXFxuICAgIFxcXCJJbnNlcnQgVmlkZW9cXFwiOiBcXFwiSW5zZXJ0IFZpZGVvXFxcIixcXG4gICAgXFxcIkVtYmVkZGVkIENvZGVcXFwiOiBcXFwiRW1iZWRkZWQgQ29kZVxcXCIsXFxuXFxuICAgIC8vIFRhYmxlc1xcbiAgICBcXFwiSW5zZXJ0IFRhYmxlXFxcIjogXFxcIkluc2VydCBUYWJsZVxcXCIsXFxuICAgIFxcXCJUYWJsZSBIZWFkZXJcXFwiOiBcXFwiVGFibGUgSGVhZGVyXFxcIixcXG4gICAgXFxcIlJlbW92ZSBUYWJsZVxcXCI6IFxcXCJSZW1vdmUgVGFibGVcXFwiLFxcbiAgICBcXFwiVGFibGUgU3R5bGVcXFwiOiBcXFwiVGFibGUgU3R5bGVcXFwiLFxcbiAgICBcXFwiSG9yaXpvbnRhbCBBbGlnblxcXCI6IFxcXCJIb3Jpem9udGFsIEFsaWduXFxcIixcXG4gICAgXFxcIlJvd1xcXCI6IFxcXCJSb3dcXFwiLFxcbiAgICBcXFwiSW5zZXJ0IHJvdyBhYm92ZVxcXCI6IFxcXCJJbnNlcnQgcm93IGFib3ZlXFxcIixcXG4gICAgXFxcIkluc2VydCByb3cgYmVsb3dcXFwiOiBcXFwiSW5zZXJ0IHJvdyBiZWxvd1xcXCIsXFxuICAgIFxcXCJEZWxldGUgcm93XFxcIjogXFxcIkRlbGV0ZSByb3dcXFwiLFxcbiAgICBcXFwiQ29sdW1uXFxcIjogXFxcIkNvbHVtblxcXCIsXFxuICAgIFxcXCJJbnNlcnQgY29sdW1uIGJlZm9yZVxcXCI6IFxcXCJJbnNlcnQgY29sdW1uIGJlZm9yZVxcXCIsXFxuICAgIFxcXCJJbnNlcnQgY29sdW1uIGFmdGVyXFxcIjogXFxcIkluc2VydCBjb2x1bW4gYWZ0ZXJcXFwiLFxcbiAgICBcXFwiRGVsZXRlIGNvbHVtblxcXCI6IFxcXCJEZWxldGUgY29sdW1uXFxcIixcXG4gICAgXFxcIkNlbGxcXFwiOiBcXFwiQ2VsbFxcXCIsXFxuICAgIFxcXCJNZXJnZSBjZWxsc1xcXCI6IFxcXCJNZXJnZSBjZWxsc1xcXCIsXFxuICAgIFxcXCJIb3Jpem9udGFsIHNwbGl0XFxcIjogXFxcIkhvcml6b250YWwgc3BsaXRcXFwiLFxcbiAgICBcXFwiVmVydGljYWwgc3BsaXRcXFwiOiBcXFwiVmVydGljYWwgc3BsaXRcXFwiLFxcbiAgICBcXFwiQ2VsbCBCYWNrZ3JvdW5kXFxcIjogXFxcIkNlbGwgQmFja2dyb3VuZFxcXCIsXFxuICAgIFxcXCJWZXJ0aWNhbCBBbGlnblxcXCI6IFxcXCJWZXJ0aWNhbCBBbGlnblxcXCIsXFxuICAgIFxcXCJUb3BcXFwiOiBcXFwiVG9wXFxcIixcXG4gICAgXFxcIk1pZGRsZVxcXCI6IFxcXCJNaWRkbGVcXFwiLFxcbiAgICBcXFwiQm90dG9tXFxcIjogXFxcIkJvdHRvbVxcXCIsXFxuICAgIFxcXCJBbGlnbiBUb3BcXFwiOiBcXFwiQWxpZ24gVG9wXFxcIixcXG4gICAgXFxcIkFsaWduIE1pZGRsZVxcXCI6IFxcXCJBbGlnbiBNaWRkbGVcXFwiLFxcbiAgICBcXFwiQWxpZ24gQm90dG9tXFxcIjogXFxcIkFsaWduIEJvdHRvbVxcXCIsXFxuICAgIFxcXCJDZWxsIFN0eWxlXFxcIjogXFxcIkNlbGwgU3R5bGVcXFwiLFxcblxcbiAgICAvLyBGaWxlc1xcbiAgICBcXFwiVXBsb2FkIEZpbGVcXFwiOiBcXFwiVXBsb2FkIEZpbGVcXFwiLFxcbiAgICBcXFwiRHJvcCBmaWxlXFxcIjogXFxcIkRyb3AgZmlsZVxcXCIsXFxuXFxuICAgIC8vIEVtb3RpY29uc1xcbiAgICBcXFwiRW1vdGljb25zXFxcIjogXFxcIkVtb3RpY29uc1xcXCIsXFxuXFxuICAgIC8vIExpbmUgYnJlYWtlclxcbiAgICBcXFwiQnJlYWtcXFwiOiBcXFwiQnJlYWtcXFwiLFxcblxcbiAgICAvLyBNYXRoXFxuICAgIFxcXCJTdWJzY3JpcHRcXFwiOiBcXFwiU3Vic2NyaXB0XFxcIixcXG4gICAgXFxcIlN1cGVyc2NyaXB0XFxcIjogXFxcIlN1cGVyc2NyaXB0XFxcIixcXG5cXG4gICAgLy8gRnVsbCBzY3JlZW5cXG4gICAgXFxcIkZ1bGxzY3JlZW5cXFwiOiBcXFwiRnVsbHNjcmVlblxcXCIsXFxuXFxuICAgIC8vIEhvcml6b250YWwgbGluZVxcbiAgICBcXFwiSW5zZXJ0IEhvcml6b250YWwgTGluZVxcXCI6IFxcXCJJbnNlcnQgSG9yaXpvbnRhbCBMaW5lXFxcIixcXG5cXG4gICAgLy8gQ2xlYXIgZm9ybWF0dGluZ1xcbiAgICBcXFwiQ2xlYXIgRm9ybWF0dGluZ1xcXCI6IFxcXCJDZWxsIEZvcm1hdHRpbmdcXFwiLFxcblxcbiAgICAvLyBVbmRvLCByZWRvXFxuICAgIFxcXCJVbmRvXFxcIjogXFxcIlVuZG9cXFwiLFxcbiAgICBcXFwiUmVkb1xcXCI6IFxcXCJSZWRvXFxcIixcXG5cXG4gICAgLy8gU2VsZWN0IGFsbFxcbiAgICBcXFwiU2VsZWN0IEFsbFxcXCI6IFxcXCJTZWxlY3QgQWxsXFxcIixcXG5cXG4gICAgLy8gQ29kZSB2aWV3XFxuICAgIFxcXCJDb2RlIFZpZXdcXFwiOiBcXFwiQ29kZSBWaWV3XFxcIixcXG5cXG4gICAgLy8gUXVvdGVcXG4gICAgXFxcIlF1b3RlXFxcIjogXFxcIlF1b3RlXFxcIixcXG4gICAgXFxcIkluY3JlYXNlXFxcIjogXFxcIkluY3JlYXNlXFxcIixcXG4gICAgXFxcIkRlY3JlYXNlXFxcIjogXFxcIkRlY3JlYXNlXFxcIixcXG5cXG4gICAgLy8gUXVpY2sgSW5zZXJ0XFxuICAgIFxcXCJRdWljayBJbnNlcnRcXFwiOiBcXFwiUXVpY2sgSW5zZXJ0XFxcIlxcbiAgfSxcXG4gIGRpcmVjdGlvbjogXFxcImx0clxcXCJcXG59O1xcblwiXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3Jhdy1sb2FkZXIhLi9+L2Zyb2FsYS1lZGl0b3IvanMvbGFuZ3VhZ2VzL2VuX2diLmpzXG4vLyBtb2R1bGUgaWQgPSAyM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9");

/***/ }
]);