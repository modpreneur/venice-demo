webpackJsonp([0],[
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\n__webpack_require__(1);\n\n__webpack_require__(4);\n\n__webpack_require__(6);\n\n__webpack_require__(8);\n\n__webpack_require__(10);\n\n__webpack_require__(12);\n\n__webpack_require__(14);\n\n__webpack_require__(16);\n\n__webpack_require__(18);\n\n__webpack_require__(20);//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9ub2RlX21vZHVsZXMvdmVuaWNlLWpzL21haW5Gcm9hbGEuanM/NWM3MyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENyZWF0ZWQgYnkgYnVyMDEgb24gOS8xMi8xNi5cbiAqL1xuaW1wb3J0ICdzY3JpcHQhZnJvYWxhLWVkaXRvci9qcy9mcm9hbGFfZWRpdG9yLm1pbi5qcyc7XG5pbXBvcnQgJ3NjcmlwdCFjb2RlbWlycm9yL2xpYi9jb2RlbWlycm9yLmpzJztcbmltcG9ydCAnc2NyaXB0IWNvZGVtaXJyb3IvbW9kZS94bWwveG1sLmpzJztcbmltcG9ydCAnc2NyaXB0IWZyb2FsYS1lZGl0b3IvanMvcGx1Z2lucy9hbGlnbi5taW4uanMnO1xuaW1wb3J0ICdzY3JpcHQhZnJvYWxhLWVkaXRvci9qcy9wbHVnaW5zL2NoYXJfY291bnRlci5taW4uanMnO1xuaW1wb3J0ICdzY3JpcHQhZnJvYWxhLWVkaXRvci9qcy9wbHVnaW5zL2NvZGVfdmlldy5taW4uanMnO1xuaW1wb3J0ICdzY3JpcHQhZnJvYWxhLWVkaXRvci9qcy9wbHVnaW5zL2VudGl0aWVzLm1pbi5qcyc7XG5pbXBvcnQgJ3NjcmlwdCFmcm9hbGEtZWRpdG9yL2pzL3BsdWdpbnMvbGluay5taW4uanMnO1xuaW1wb3J0ICdzY3JpcHQhZnJvYWxhLWVkaXRvci9qcy9wbHVnaW5zL3VybC5taW4uanMnO1xuaW1wb3J0ICdzY3JpcHQhZnJvYWxhLWVkaXRvci9qcy9sYW5ndWFnZXMvZW5fZ2IuanMnO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIG5vZGVfbW9kdWxlcy92ZW5pY2UtanMvbWFpbkZyb2FsYS5qcyJdLCJtYXBwaW5ncyI6Ijs7QUFHQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQSIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	eval("__webpack_require__(2)(__webpack_require__(3))//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL34vZnJvYWxhLWVkaXRvci9qcy9mcm9hbGFfZWRpdG9yLm1pbi5qcz9hOWQwIl0sInNvdXJjZXNDb250ZW50IjpbInJlcXVpcmUoXCIhIS92YXIvYXBwL3dlYi9qcy9ub2RlX21vZHVsZXMvc2NyaXB0LWxvYWRlci9hZGRTY3JpcHQuanNcIikocmVxdWlyZShcIiEhL3Zhci9hcHAvd2ViL2pzL25vZGVfbW9kdWxlcy9yYXctbG9hZGVyL2luZGV4LmpzIS92YXIvYXBwL3dlYi9qcy9ub2RlX21vZHVsZXMvZnJvYWxhLWVkaXRvci9qcy9mcm9hbGFfZWRpdG9yLm1pbi5qc1wiKSlcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vc2NyaXB0LWxvYWRlciEuL34vZnJvYWxhLWVkaXRvci9qcy9mcm9hbGFfZWRpdG9yLm1pbi5qc1xuLy8gbW9kdWxlIGlkID0gMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 2 */
/***/ function(module, exports) {

	eval("/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\r\nmodule.exports = function(src) {\r\n\tif (typeof execScript !== \"undefined\")\r\n\t\texecScript(src);\r\n\telse\r\n\t\teval.call(null, src);\r\n}\r\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL34vc2NyaXB0LWxvYWRlci9hZGRTY3JpcHQuanM/ODEwNyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxyXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXHJcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxyXG4qL1xyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHNyYykge1xyXG5cdGlmICh0eXBlb2YgZXhlY1NjcmlwdCAhPT0gXCJ1bmRlZmluZWRcIilcclxuXHRcdGV4ZWNTY3JpcHQoc3JjKTtcclxuXHRlbHNlXHJcblx0XHRldmFsLmNhbGwobnVsbCwgc3JjKTtcclxufVxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vc2NyaXB0LWxvYWRlci9hZGRTY3JpcHQuanNcbi8vIG1vZHVsZSBpZCA9IDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 3 */
/***/ function(module, exports) {

	eval("module.exports = \"/*!\\n * froala_editor v2.3.5 (https://www.froala.com/wysiwyg-editor)\\n * License https://froala.com/wysiwyg-editor/terms/\\n * Copyright 2014-2016 Froala Labs\\n */\\n\\n!function(a){\\\"function\\\"==typeof define&&define.amd?define([\\\"jquery\\\"],a):\\\"object\\\"==typeof module&&module.exports?module.exports=function(b,c){return void 0===c&&(c=\\\"undefined\\\"!=typeof window?require(\\\"jquery\\\"):require(\\\"jquery\\\")(b)),a(c),c}:a(jQuery)}(function(a){var b=function(c,d){this.id=++a.FE.ID,this.opts=a.extend(!0,{},a.extend({},b.DEFAULTS,\\\"object\\\"==typeof d&&d));var e=JSON.stringify(this.opts);a.FE.OPTS_MAPPING[e]=a.FE.OPTS_MAPPING[e]||this.id,this.sid=a.FE.OPTS_MAPPING[e],a.FE.SHARED[this.sid]=a.FE.SHARED[this.sid]||{},this.shared=a.FE.SHARED[this.sid],this.shared.count=(this.shared.count||0)+1,this.$oel=a(c),this.$oel.data(\\\"froala.editor\\\",this),this.o_doc=c.ownerDocument,this.o_win=\\\"defaultView\\\"in this.o_doc?this.o_doc.defaultView:this.o_doc.parentWindow;var f=a(this.o_win).scrollTop();this.$oel.on(\\\"froala.doInit\\\",a.proxy(function(){this.$oel.off(\\\"froala.doInit\\\"),this.doc=this.$el.get(0).ownerDocument,this.win=\\\"defaultView\\\"in this.doc?this.doc.defaultView:this.doc.parentWindow,this.$doc=a(this.doc),this.$win=a(this.win),this.opts.pluginsEnabled||(this.opts.pluginsEnabled=Object.keys(a.FE.PLUGINS)),this.opts.initOnClick?(this.load(a.FE.MODULES),this.$el.on(\\\"touchstart.init\\\",function(){a(this).data(\\\"touched\\\",!0)}),this.$el.on(\\\"touchmove.init\\\",function(){a(this).removeData(\\\"touched\\\")}),this.$el.on(\\\"mousedown.init touchend.init dragenter.init focus.init\\\",a.proxy(function(b){if(\\\"touchend\\\"==b.type&&!this.$el.data(\\\"touched\\\"))return!0;if(1===b.which||!b.which){this.$el.off(\\\"mousedown.init touchstart.init touchmove.init touchend.init dragenter.init focus.init\\\"),this.load(a.FE.MODULES),this.load(a.FE.PLUGINS);var c=b.originalEvent&&b.originalEvent.originalTarget;c&&\\\"IMG\\\"==c.tagName&&a(c).trigger(\\\"mousedown\\\"),\\\"undefined\\\"==typeof this.ul&&this.destroy(),\\\"touchend\\\"==b.type&&this.image&&b.originalEvent&&b.originalEvent.target&&a(b.originalEvent.target).is(\\\"img\\\")&&setTimeout(a.proxy(function(){this.image.edit(a(b.originalEvent.target))},this),100),this.events.trigger(\\\"initialized\\\")}},this))):(this.load(a.FE.MODULES),this.load(a.FE.PLUGINS),a(this.o_win).scrollTop(f),\\\"undefined\\\"==typeof this.ul&&this.destroy(),this.events.trigger(\\\"initialized\\\"))},this)),this._init()};b.DEFAULTS={initOnClick:!1,pluginsEnabled:null},b.MODULES={},b.PLUGINS={},b.VERSION=\\\"2.3.5\\\",b.INSTANCES=[],b.OPTS_MAPPING={},b.SHARED={},b.ID=0,b.prototype._init=function(){var b=this.$oel.prop(\\\"tagName\\\"),c=a.proxy(function(){this._original_html=this._original_html||this.$oel.html(),this.$box=this.$box||this.$oel,this.opts.fullPage&&(this.opts.iframe=!0),this.opts.iframe?(this.$iframe=a('<iframe src=\\\"about:blank\\\" frameBorder=\\\"0\\\">'),this.$wp=a(\\\"<div></div>\\\"),this.$box.html(this.$wp),this.$wp.append(this.$iframe),this.$iframe.get(0).contentWindow.document.open(),this.$iframe.get(0).contentWindow.document.write(\\\"<!DOCTYPE html>\\\"),this.$iframe.get(0).contentWindow.document.write(\\\"<html><head></head><body></body></html>\\\"),this.$iframe.get(0).contentWindow.document.close(),this.$el=this.$iframe.contents().find(\\\"body\\\"),this.$head=this.$iframe.contents().find(\\\"head\\\"),this.$html=this.$iframe.contents().find(\\\"html\\\"),this.iframe_document=this.$iframe.get(0).contentWindow.document,this.$oel.trigger(\\\"froala.doInit\\\")):(this.$el=a(\\\"<div></div>\\\"),this.$wp=a(\\\"<div></div>\\\").append(this.$el),this.$box.html(this.$wp),this.$oel.trigger(\\\"froala.doInit\\\"))},this),d=a.proxy(function(){this.$box=a(\\\"<div>\\\"),this.$oel.before(this.$box).hide(),this._original_html=this.$oel.val(),this.$oel.parents(\\\"form\\\").on(\\\"submit.\\\"+this.id,a.proxy(function(){this.events.trigger(\\\"form.submit\\\")},this)),this.$oel.parents(\\\"form\\\").on(\\\"reset.\\\"+this.id,a.proxy(function(){this.events.trigger(\\\"form.reset\\\")},this)),c()},this),e=a.proxy(function(){this.$el=this.$oel,this.$el.attr(\\\"contenteditable\\\",!0).css(\\\"outline\\\",\\\"none\\\").css(\\\"display\\\",\\\"inline-block\\\"),this.opts.multiLine=!1,this.opts.toolbarInline=!1,this.$oel.trigger(\\\"froala.doInit\\\")},this),f=a.proxy(function(){this.$el=this.$oel,this.opts.toolbarInline=!1,this.$oel.trigger(\\\"froala.doInit\\\")},this),g=a.proxy(function(){this.$el=this.$oel,this.opts.toolbarInline=!1,this.$oel.on(\\\"click.popup\\\",function(a){a.preventDefault()}),this.$oel.trigger(\\\"froala.doInit\\\")},this);this.opts.editInPopup?g():\\\"TEXTAREA\\\"==b?d():\\\"A\\\"==b?e():\\\"IMG\\\"==b?f():\\\"BUTTON\\\"==b||\\\"INPUT\\\"==b?(this.opts.editInPopup=!0,this.opts.toolbarInline=!1,g()):c()},b.prototype.load=function(b){for(var c in b)if(b.hasOwnProperty(c)){if(this[c])continue;if(a.FE.PLUGINS[c]&&this.opts.pluginsEnabled.indexOf(c)<0)continue;if(this[c]=new b[c](this),this[c]._init&&(this[c]._init(),this.opts.initOnClick&&\\\"core\\\"==c))return!1}},b.prototype.destroy=function(){this.shared.count--,this.events.$off();var b=this.html.get();if(this.events.trigger(\\\"destroy\\\",[],!0),this.events.trigger(\\\"shared.destroy\\\",void 0,!0),0===this.shared.count){for(var c in this.shared)this.shared.hasOwnProperty(c)&&(null==this.shared[c],a.FE.SHARED[this.sid][c]=null);a.FE.SHARED[this.sid]={}}this.$oel.parents(\\\"form\\\").off(\\\".\\\"+this.id),this.$oel.off(\\\"click.popup\\\"),this.$oel.removeData(\\\"froala.editor\\\"),this.$oel.off(\\\"froalaEditor\\\"),this.core.destroy(b),a.FE.INSTANCES.splice(a.FE.INSTANCES.indexOf(this),1)},a.fn.froalaEditor=function(c){for(var d=[],e=0;e<arguments.length;e++)d.push(arguments[e]);if(\\\"string\\\"==typeof c){var f=[];return this.each(function(){var b=a(this),e=b.data(\\\"froala.editor\\\");if(e){var g,h;if(c.indexOf(\\\".\\\")>0&&e[c.split(\\\".\\\")[0]]?(e[c.split(\\\".\\\")[0]]&&(g=e[c.split(\\\".\\\")[0]]),h=c.split(\\\".\\\")[1]):(g=e,h=c.split(\\\".\\\")[0]),!g[h])return a.error(\\\"Method \\\"+c+\\\" does not exist in Froala Editor.\\\");var i=g[h].apply(e,d.slice(1));void 0===i?f.push(this):0===f.length&&f.push(i)}}),1==f.length?f[0]:f}return\\\"object\\\"!=typeof c&&c?void 0:this.each(function(){var d=a(this).data(\\\"froala.editor\\\");if(!d){var e=this;new b(e,c)}})},a.fn.froalaEditor.Constructor=b,a.FroalaEditor=b,a.FE=b,a.FE.MODULES.node=function(b){function c(b){return b&&\\\"IFRAME\\\"!=b.tagName?a(b).contents():[]}function d(b){return b?b.nodeType!=Node.ELEMENT_NODE?!1:a.FE.BLOCK_TAGS.indexOf(b.tagName.toLowerCase())>=0:!1}function e(e,f){if(a(e).find(\\\"table\\\").length>0)return!1;if(e.querySelectorAll(a.FE.VOID_ELEMENTS.join(\\\",\\\")).length-e.querySelectorAll(\\\"br\\\").length)return!1;if(e.querySelectorAll(b.opts.htmlAllowedEmptyTags.join(\\\":not(.fr-marker),\\\")+\\\":not(.fr-marker)\\\").length)return!1;if(e.querySelectorAll(a.FE.BLOCK_TAGS.join(\\\",\\\")).length>1)return!1;if(e.querySelectorAll(b.opts.htmlDoNotWrapTags.join(\\\":not(.fr-marker),\\\")+\\\":not(.fr-marker)\\\").length)return!1;var g=c(e);1==g.length&&d(g[0])&&(g=c(g[0]));for(var h=!1,i=0;i<g.length;i++){var j=g[i];if(!(f&&a(j).hasClass(\\\"fr-marker\\\")||j.nodeType==Node.TEXT_NODE&&0==j.textContent.length)){if(\\\"BR\\\"!=j.tagName&&(j.textContent||\\\"\\\").replace(/\\\\u200B/gi,\\\"\\\").replace(/\\\\n/g,\\\"\\\").length>0)return!1;if(h)return!1;\\\"BR\\\"==j.tagName&&(h=!0)}}return!0}function f(c){for(;c&&c.parentNode!==b.$el.get(0)&&(!c.parentNode||!a(c.parentNode).hasClass(\\\"fr-inner\\\"));)if(c=c.parentNode,d(c))return c;return null}function g(c,e,f){if(\\\"undefined\\\"==typeof e&&(e=[]),\\\"undefined\\\"==typeof f&&(f=!0),e.push(b.$el.get(0)),e.indexOf(c.parentNode)>=0||c.parentNode&&a(c.parentNode).hasClass(\\\"fr-inner\\\")||c.parentNode&&a.FE.SIMPLE_ENTER_TAGS.indexOf(c.parentNode.tagName)>=0&&f)return null;for(;e.indexOf(c.parentNode)<0&&c.parentNode&&!a(c.parentNode).hasClass(\\\"fr-inner\\\")&&(a.FE.SIMPLE_ENTER_TAGS.indexOf(c.parentNode.tagName)<0||!f)&&(!d(c)||!d(c.parentNode)||!f);)c=c.parentNode;return c}function h(a){var b={},c=a.attributes;if(c)for(var d=0;d<c.length;d++){var e=c[d];b[e.nodeName]=e.value}return b}function i(a){for(var b=\\\"\\\",c=h(a),d=Object.keys(c).sort(),e=0;e<d.length;e++){var f=d[e],g=c[f];b+=g.indexOf('\\\"')<0?\\\" \\\"+f+'=\\\"'+g+'\\\"':\\\" \\\"+f+\\\"='\\\"+g+\\\"'\\\"}return b}function j(a){for(var b=a.attributes,c=0;c<b.length;c++){var d=b[c];a.removeAttribute(d.nodeName)}}function k(a){return\\\"<\\\"+a.tagName.toLowerCase()+i(a)+\\\">\\\"}function l(a){return\\\"</\\\"+a.tagName.toLowerCase()+\\\">\\\"}function m(b,c){\\\"undefined\\\"==typeof c&&(c=!0);for(var d=b.previousSibling;d&&c&&a(d).hasClass(\\\"fr-marker\\\");)d=d.previousSibling;return d?d.nodeType==Node.TEXT_NODE&&\\\"\\\"===d.textContent?m(d):!1:!0}function n(b,c){\\\"undefined\\\"==typeof c&&(c=!0);for(var d=b.nextSibling;d&&c&&a(d).hasClass(\\\"fr-marker\\\");)d=d.nextSibling;return d?d.nodeType==Node.TEXT_NODE&&\\\"\\\"===d.textContent?n(d):!1:!0}function o(b){return b&&b.nodeType==Node.ELEMENT_NODE&&a.FE.VOID_ELEMENTS.indexOf((b.tagName||\\\"\\\").toLowerCase())>=0}function p(a){return a?[\\\"UL\\\",\\\"OL\\\"].indexOf(a.tagName)>=0:!1}function q(a){return a===b.$el.get(0)}function r(a){return a&&a.nodeType==Node.ELEMENT_NODE&&a.getAttribute(\\\"class\\\")&&(a.getAttribute(\\\"class\\\")||\\\"\\\").indexOf(\\\"fr-deletable\\\")>=0}function s(a){return a===b.doc.activeElement&&(!b.doc.hasFocus||b.doc.hasFocus())&&!!(q(a)||a.type||a.href||~a.tabIndex)}function t(a){return(!a.getAttribute||\\\"false\\\"!=a.getAttribute(\\\"contenteditable\\\"))&&[\\\"STYLE\\\",\\\"SCRIPT\\\"].indexOf(a.tagName)<0}return{isBlock:d,isEmpty:e,blockParent:f,deepestParent:g,rawAttributes:h,attributes:i,clearAttributes:j,openTagString:k,closeTagString:l,isFirstSibling:m,isLastSibling:n,isList:p,isElement:q,contents:c,isVoid:o,hasFocus:s,isEditable:t,isDeletable:r}},a.extend(a.FE.DEFAULTS,{htmlAllowedTags:[\\\"a\\\",\\\"abbr\\\",\\\"address\\\",\\\"area\\\",\\\"article\\\",\\\"aside\\\",\\\"audio\\\",\\\"b\\\",\\\"base\\\",\\\"bdi\\\",\\\"bdo\\\",\\\"blockquote\\\",\\\"br\\\",\\\"button\\\",\\\"canvas\\\",\\\"caption\\\",\\\"cite\\\",\\\"code\\\",\\\"col\\\",\\\"colgroup\\\",\\\"datalist\\\",\\\"dd\\\",\\\"del\\\",\\\"details\\\",\\\"dfn\\\",\\\"dialog\\\",\\\"div\\\",\\\"dl\\\",\\\"dt\\\",\\\"em\\\",\\\"embed\\\",\\\"fieldset\\\",\\\"figcaption\\\",\\\"figure\\\",\\\"footer\\\",\\\"form\\\",\\\"h1\\\",\\\"h2\\\",\\\"h3\\\",\\\"h4\\\",\\\"h5\\\",\\\"h6\\\",\\\"header\\\",\\\"hgroup\\\",\\\"hr\\\",\\\"i\\\",\\\"iframe\\\",\\\"img\\\",\\\"input\\\",\\\"ins\\\",\\\"kbd\\\",\\\"keygen\\\",\\\"label\\\",\\\"legend\\\",\\\"li\\\",\\\"link\\\",\\\"main\\\",\\\"map\\\",\\\"mark\\\",\\\"menu\\\",\\\"menuitem\\\",\\\"meter\\\",\\\"nav\\\",\\\"noscript\\\",\\\"object\\\",\\\"ol\\\",\\\"optgroup\\\",\\\"option\\\",\\\"output\\\",\\\"p\\\",\\\"param\\\",\\\"pre\\\",\\\"progress\\\",\\\"queue\\\",\\\"rp\\\",\\\"rt\\\",\\\"ruby\\\",\\\"s\\\",\\\"samp\\\",\\\"script\\\",\\\"style\\\",\\\"section\\\",\\\"select\\\",\\\"small\\\",\\\"source\\\",\\\"span\\\",\\\"strike\\\",\\\"strong\\\",\\\"sub\\\",\\\"summary\\\",\\\"sup\\\",\\\"table\\\",\\\"tbody\\\",\\\"td\\\",\\\"textarea\\\",\\\"tfoot\\\",\\\"th\\\",\\\"thead\\\",\\\"time\\\",\\\"tr\\\",\\\"track\\\",\\\"u\\\",\\\"ul\\\",\\\"var\\\",\\\"video\\\",\\\"wbr\\\"],htmlRemoveTags:[\\\"script\\\",\\\"style\\\"],htmlAllowedAttrs:[\\\"accept\\\",\\\"accept-charset\\\",\\\"accesskey\\\",\\\"action\\\",\\\"align\\\",\\\"allowfullscreen\\\",\\\"allowtransparency\\\",\\\"alt\\\",\\\"async\\\",\\\"autocomplete\\\",\\\"autofocus\\\",\\\"autoplay\\\",\\\"autosave\\\",\\\"background\\\",\\\"bgcolor\\\",\\\"border\\\",\\\"charset\\\",\\\"cellpadding\\\",\\\"cellspacing\\\",\\\"checked\\\",\\\"cite\\\",\\\"class\\\",\\\"color\\\",\\\"cols\\\",\\\"colspan\\\",\\\"content\\\",\\\"contenteditable\\\",\\\"contextmenu\\\",\\\"controls\\\",\\\"coords\\\",\\\"data\\\",\\\"data-.*\\\",\\\"datetime\\\",\\\"default\\\",\\\"defer\\\",\\\"dir\\\",\\\"dirname\\\",\\\"disabled\\\",\\\"download\\\",\\\"draggable\\\",\\\"dropzone\\\",\\\"enctype\\\",\\\"for\\\",\\\"form\\\",\\\"formaction\\\",\\\"frameborder\\\",\\\"headers\\\",\\\"height\\\",\\\"hidden\\\",\\\"high\\\",\\\"href\\\",\\\"hreflang\\\",\\\"http-equiv\\\",\\\"icon\\\",\\\"id\\\",\\\"ismap\\\",\\\"itemprop\\\",\\\"keytype\\\",\\\"kind\\\",\\\"label\\\",\\\"lang\\\",\\\"language\\\",\\\"list\\\",\\\"loop\\\",\\\"low\\\",\\\"max\\\",\\\"maxlength\\\",\\\"media\\\",\\\"method\\\",\\\"min\\\",\\\"mozallowfullscreen\\\",\\\"multiple\\\",\\\"name\\\",\\\"novalidate\\\",\\\"open\\\",\\\"optimum\\\",\\\"pattern\\\",\\\"ping\\\",\\\"placeholder\\\",\\\"poster\\\",\\\"preload\\\",\\\"pubdate\\\",\\\"radiogroup\\\",\\\"readonly\\\",\\\"rel\\\",\\\"required\\\",\\\"reversed\\\",\\\"rows\\\",\\\"rowspan\\\",\\\"sandbox\\\",\\\"scope\\\",\\\"scoped\\\",\\\"scrolling\\\",\\\"seamless\\\",\\\"selected\\\",\\\"shape\\\",\\\"size\\\",\\\"sizes\\\",\\\"span\\\",\\\"src\\\",\\\"srcdoc\\\",\\\"srclang\\\",\\\"srcset\\\",\\\"start\\\",\\\"step\\\",\\\"summary\\\",\\\"spellcheck\\\",\\\"style\\\",\\\"tabindex\\\",\\\"target\\\",\\\"title\\\",\\\"type\\\",\\\"translate\\\",\\\"usemap\\\",\\\"value\\\",\\\"valign\\\",\\\"webkitallowfullscreen\\\",\\\"width\\\",\\\"wrap\\\"],htmlAllowComments:!0,fullPage:!1}),a.FE.HTML5Map={B:\\\"STRONG\\\",I:\\\"EM\\\",STRIKE:\\\"S\\\"},a.FE.MODULES.clean=function(b){function c(a){if(a.nodeType==Node.ELEMENT_NODE&&a.getAttribute(\\\"class\\\")&&a.getAttribute(\\\"class\\\").indexOf(\\\"fr-marker\\\")>=0)return!1;var d,e=b.node.contents(a),f=[];for(d=0;d<e.length;d++)e[d].nodeType!=Node.ELEMENT_NODE||b.node.isVoid(e[d])?e[d].nodeType==Node.TEXT_NODE&&(e[d].textContent=e[d].textContent.replace(/\\\\u200b/g,\\\"\\\").replace(/&/g,\\\"&amp;\\\")):e[d].textContent.replace(/\\\\u200b/g,\\\"\\\").length!=e[d].textContent.length&&c(e[d]);if(a.nodeType==Node.ELEMENT_NODE&&!b.node.isVoid(a)&&(a.normalize(),e=b.node.contents(a),f=a.querySelectorAll(\\\".fr-marker\\\"),e.length-f.length==0)){for(d=0;d<e.length;d++)if((e[d].getAttribute(\\\"class\\\")||\\\"\\\").indexOf(\\\"fr-marker\\\")<0)return!1;for(d=0;d<f.length;d++)a.parentNode.insertBefore(f[d].cloneNode(!0),a);return a.parentNode.removeChild(a),!1}}function d(a){if(a.nodeType==Node.COMMENT_NODE)return\\\"<!--\\\"+a.nodeValue+\\\"-->\\\";if(a.nodeType==Node.TEXT_NODE)return a.textContent.replace(/\\\\&/g,\\\"&amp;\\\").replace(/\\\\</g,\\\"&lt;\\\").replace(/\\\\>/g,\\\"&gt;\\\").replace(/\\\\u00A0/g,\\\"&nbsp;\\\");if(a.nodeType!=Node.ELEMENT_NODE)return a.outerHTML;if(a.nodeType==Node.ELEMENT_NODE&&[\\\"STYLE\\\",\\\"SCRIPT\\\"].indexOf(a.tagName)>=0)return a.outerHTML;if(\\\"IFRAME\\\"==a.tagName)return a.outerHTML;var c=a.childNodes;if(0===c.length)return a.outerHTML;for(var e=\\\"\\\",f=0;f<c.length;f++)e+=d(c[f]);return b.node.openTagString(a)+e+b.node.closeTagString(a)}function e(a){return H=[],a=a.replace(/<script\\\\b[^<]*(?:(?!<\\\\/script>)<[^<]*)*<\\\\/script>/gi,function(a){return H.push(a),\\\"[FROALA.EDITOR.SCRIPT \\\"+(H.length-1)+\\\"]\\\"}),a=a.replace(/<img((?:[\\\\w\\\\W]*?)) src=\\\"/g,'<img$1 data-fr-src=\\\"')}function f(a){return a=a.replace(/\\\\[FROALA\\\\.EDITOR\\\\.SCRIPT ([\\\\d]*)\\\\]/gi,function(a,c){return b.opts.htmlRemoveTags.indexOf(\\\"script\\\")>=0?\\\"\\\":H[parseInt(c,10)]}),a=a.replace(/<img((?:[\\\\w\\\\W]*?)) data-fr-src=\\\"/g,'<img$1 src=\\\"')}function g(a){var b;for(b in a)a.hasOwnProperty(b)&&(b.match(G)||delete a[b]);for(var c=\\\"\\\",d=Object.keys(a).sort(),e=0;e<d.length;e++)b=d[e],c+=a[b].indexOf('\\\"')<0?\\\" \\\"+b+'=\\\"'+a[b]+'\\\"':\\\" \\\"+b+\\\"='\\\"+a[b]+\\\"'\\\";return c}function h(a,c,d){if(b.opts.fullPage){var e=b.html.extractDoctype(d),f=g(b.html.extractNodeAttrs(d,\\\"html\\\"));c=null==c?b.html.extractNode(d,\\\"head\\\")||\\\"<title></title>\\\":c;var h=g(b.html.extractNodeAttrs(d,\\\"head\\\")),i=g(b.html.extractNodeAttrs(d,\\\"body\\\"));return e+\\\"<html\\\"+f+\\\"><head\\\"+h+\\\">\\\"+c+\\\"</head><body\\\"+i+\\\">\\\"+a+\\\"</body></html>\\\"}return a}function i(c,e){var f=a(\\\"<div>\\\"+c+\\\"</div>\\\"),g=\\\"\\\";if(f){for(var h=b.node.contents(f.get(0)),i=0;i<h.length;i++)e(h[i]);h=b.node.contents(f.get(0));for(var i=0;i<h.length;i++)g+=d(h[i])}return g}function j(a,c,d){a=e(a);var g=a,j=null;if(b.opts.fullPage){var g=b.html.extractNode(a,\\\"body\\\")||(a.indexOf(\\\"<body\\\")>=0?\\\"\\\":a);d&&(j=b.html.extractNode(a,\\\"head\\\")||\\\"\\\")}g=i(g,c),j&&(j=i(j,c));var k=h(g,j,a);return f(k)}function k(a){return a.replace(/\\\\u200b/g,\\\"\\\").length==a.length?a:b.clean.exec(a,c)}function l(){var c=b.$el.get(0).querySelectorAll(Object.keys(a.FE.HTML5Map).join(\\\",\\\"));if(c.length){var d=!1;0==b.$el.get(0).querySelectorAll(\\\".fr-marker\\\").length&&(b.selection.save(),d=!0);for(var e=0;e<c.length;e++)\\\"\\\"===b.node.attributes(c[e])&&a(c[e]).replaceWith(\\\"<\\\"+a.FE.HTML5Map[c[e].tagName]+\\\">\\\"+c[e].innerHTML+\\\"</\\\"+a.FE.HTML5Map[c[e].tagName]+\\\">\\\");d&&b.selection.restore()}}function m(c){if(\\\"SPAN\\\"==c.tagName&&(c.getAttribute(\\\"class\\\")||\\\"\\\").indexOf(\\\"fr-marker\\\")>=0)return!1;if(\\\"PRE\\\"==c.tagName&&o(c),c.nodeType==Node.ELEMENT_NODE&&(c.getAttribute(\\\"data-fr-src\\\")&&c.setAttribute(\\\"data-fr-src\\\",b.helpers.sanitizeURL(c.getAttribute(\\\"data-fr-src\\\"))),c.getAttribute(\\\"href\\\")&&c.setAttribute(\\\"href\\\",b.helpers.sanitizeURL(c.getAttribute(\\\"href\\\"))),[\\\"TABLE\\\",\\\"TBODY\\\",\\\"TFOOT\\\",\\\"TR\\\"].indexOf(c.tagName)>=0&&(c.innerHTML=c.innerHTML.trim())),!b.opts.pasteAllowLocalImages&&c.nodeType==Node.ELEMENT_NODE&&\\\"IMG\\\"==c.tagName&&c.getAttribute(\\\"data-fr-src\\\")&&0==c.getAttribute(\\\"data-fr-src\\\").indexOf(\\\"file://\\\"))return c.parentNode.removeChild(c),!1;if(c.nodeType==Node.ELEMENT_NODE&&a.FE.HTML5Map[c.tagName]&&\\\"\\\"===b.node.attributes(c)){var d=a.FE.HTML5Map[c.tagName],e=\\\"<\\\"+d+\\\">\\\"+c.innerHTML+\\\"</\\\"+d+\\\">\\\";c.insertAdjacentHTML(\\\"beforebegin\\\",e),c=c.previousSibling,c.parentNode.removeChild(c.nextSibling)}if(b.opts.htmlAllowComments||c.nodeType!=Node.COMMENT_NODE)if(c.tagName&&c.tagName.match(F))c.parentNode.removeChild(c);else if(c.tagName&&!c.tagName.match(E))c.outerHTML=c.innerHTML;else{var f=c.attributes;if(f)for(var g=f.length-1;g>=0;g--){var h=f[g];h.nodeName.match(G)||c.removeAttribute(h.nodeName)}}else 0!==c.data.indexOf(\\\"[FROALA.EDITOR\\\")&&c.parentNode.removeChild(c)}function n(a){for(var c=b.node.contents(a),d=0;d<c.length;d++)c[d].nodeType!=Node.TEXT_NODE&&n(c[d]);m(a)}function o(a){var b=a.innerHTML;b.indexOf(\\\"\\\\n\\\")>=0&&(a.innerHTML=b.replace(/\\\\n/g,\\\"<br>\\\"))}function p(c,d,e,f){\\\"undefined\\\"==typeof d&&(d=[]),\\\"undefined\\\"==typeof e&&(e=[]),\\\"undefined\\\"==typeof f&&(f=!1),c=c.replace(/\\\\u0009/g,\\\"\\\");var g,h=a.merge([],b.opts.htmlAllowedTags);for(g=0;g<d.length;g++)h.indexOf(d[g])>=0&&h.splice(h.indexOf(d[g]),1);var i=a.merge([],b.opts.htmlAllowedAttrs);for(g=0;g<e.length;g++)i.indexOf(e[g])>=0&&i.splice(i.indexOf(e[g]),1);return i.push(\\\"data-fr-.*\\\"),i.push(\\\"fr-.*\\\"),E=new RegExp(\\\"^\\\"+h.join(\\\"$|^\\\")+\\\"$\\\",\\\"gi\\\"),G=new RegExp(\\\"^\\\"+i.join(\\\"$|^\\\")+\\\"$\\\",\\\"gi\\\"),F=new RegExp(\\\"^\\\"+b.opts.htmlRemoveTags.join(\\\"$|^\\\")+\\\"$\\\",\\\"gi\\\"),c=j(c,n,!0)}function q(){for(var c=b.$el.get(0).querySelectorAll(\\\"blockquote + blockquote\\\"),d=0;d<c.length;d++){var e=c[d];b.node.attributes(e)==b.node.attributes(e.previousSibling)&&(a(e).prev().append(a(e).html()),a(e).remove())}}function r(){for(var a=b.$el.get(0).querySelectorAll(\\\"tr\\\"),c=0;c<a.length;c++){for(var d=a[c].children,e=!0,f=0;f<d.length;f++)if(\\\"TH\\\"!=d[f].tagName){e=!1;break}if(0!=e&&0!=d.length){for(var g=a[c];g&&\\\"TABLE\\\"!=g.tagName&&\\\"THEAD\\\"!=g.tagName;)g=g.parentNode;var h=g;\\\"THEAD\\\"!=h.tagName&&(h=b.doc.createElement(\\\"THEAD\\\"),g.insertBefore(h,g.firstChild)),h.appendChild(a[c])}}}function s(){var c=b.html.defaultTag();if(c)for(var d=b.$el.get(0).querySelectorAll(\\\"td > \\\"+c+\\\", th > \\\"+c),e=0;e<d.length;e++)\\\"\\\"===b.node.attributes(d[e])&&a(d[e]).replaceWith(d[e].innerHTML+\\\"<br>\\\")}function t(){r(),s()}function u(){var a=[],c=function(a){return!b.node.isList(a.parentNode)};do{if(a.length){var d=a[0],e=b.doc.createElement(\\\"ul\\\");d.parentNode.insertBefore(e,d);do{var f=d;d=d.nextSibling,e.appendChild(f)}while(d&&\\\"LI\\\"==d.tagName)}a=[];for(var g=b.$el.get(0).querySelectorAll(\\\"li\\\"),h=0;h<g.length;h++)c(g[h])&&a.push(g[h])}while(a.length>0)}function v(){for(var a=b.$el.get(0).querySelectorAll(\\\"ol + ol, ul + ul\\\"),c=0;c<a.length;c++){var d=a[c];if(b.node.isList(d.previousSibling)&&b.node.openTagString(d)==b.node.openTagString(d.previousSibling)){for(var e=b.node.contents(d),f=0;f<e.length;f++)d.previousSibling.appendChild(e[f]);d.parentNode.removeChild(d)}}}function w(){var a,c=function(b){0===b.querySelectorAll(\\\"LI\\\").length&&(a=!0,b.parentNode.removeChild(b))};do{a=!1;for(var d=b.$el.get(0).querySelectorAll(\\\"li:empty\\\"),e=0;e<d.length;e++)d[e].parentNode.removeChild(d[e]);for(var f=b.$el.get(0).querySelectorAll(\\\"ul, ol\\\"),e=0;e<f.length;e++)c(f[e])}while(a===!0)}function x(){for(var c=b.$el.get(0).querySelectorAll(\\\"ul > ul, ol > ol, ul > ol, ol > ul\\\"),d=0;d<c.length;d++){var e=c[d],f=e.previousSibling;f&&(\\\"LI\\\"==f.tagName?f.appendChild(e):a(e).wrap(\\\"<li></li>\\\"))}}function y(){for(var c=b.$el.get(0).querySelectorAll(\\\"li > ul, li > ol\\\"),d=0;d<c.length;d++){var e=c[d];if(e.nextSibling){var f=e.nextSibling,g=a(\\\"<li>\\\");a(e.parentNode).after(g);do{var h=f;f=f.nextSibling,g.append(h)}while(f)}}}function z(){for(var c=b.$el.get(0).querySelectorAll(\\\"li > ul, li > ol\\\"),d=0;d<c.length;d++){var e=c[d];if(b.node.isFirstSibling(e))a(e).before(\\\"<br/>\\\");else if(e.previousSibling&&\\\"BR\\\"==e.previousSibling.tagName){for(var f=e.previousSibling.previousSibling;f&&a(f).hasClass(\\\"fr-marker\\\");)f=f.previousSibling;f&&\\\"BR\\\"!=f.tagName&&a(e.previousSibling).remove()}}}function A(){for(var c=b.$el.get(0).querySelectorAll(\\\"li:empty\\\"),d=0;d<c.length;d++)a(c[d]).remove()}function B(){for(var c=b.$el.get(0).querySelectorAll(\\\"ul, ol\\\"),d=0;d<c.length;d++)for(var e=b.node.contents(c[d]),f=null,g=e.length-1;g>=0;g--)\\\"LI\\\"!=e[g].tagName?(f||(f=a(\\\"<li>\\\"),f.insertBefore(e[g])),f.prepend(e[g])):f=null}function C(){u(),v(),w(),x(),y(),z(),B(),A()}function D(){b.opts.fullPage&&a.merge(b.opts.htmlAllowedTags,[\\\"head\\\",\\\"title\\\",\\\"style\\\",\\\"link\\\",\\\"base\\\",\\\"body\\\",\\\"html\\\",\\\"meta\\\"])}var E,F,G,H=[],H=[];return{_init:D,html:p,toHTML5:l,tables:t,lists:C,quotes:q,invisibleSpaces:k,exec:j}},a.FE.XS=0,a.FE.SM=1,a.FE.MD=2,a.FE.LG=3,a.FE.MODULES.helpers=function(b){function c(){var a,b,c=-1;return\\\"Microsoft Internet Explorer\\\"==navigator.appName?(a=navigator.userAgent,b=new RegExp(\\\"MSIE ([0-9]{1,}[\\\\\\\\.0-9]{0,})\\\"),null!==b.exec(a)&&(c=parseFloat(RegExp.$1))):\\\"Netscape\\\"==navigator.appName&&(a=navigator.userAgent,b=new RegExp(\\\"Trident/.*rv:([0-9]{1,}[\\\\\\\\.0-9]{0,})\\\"),null!==b.exec(a)&&(c=parseFloat(RegExp.$1))),c}function d(){var a={},b=c();if(b>0)a.msie=!0;else{var d=navigator.userAgent.toLowerCase(),e=/(edge)[ \\\\/]([\\\\w.]+)/.exec(d)||/(chrome)[ \\\\/]([\\\\w.]+)/.exec(d)||/(webkit)[ \\\\/]([\\\\w.]+)/.exec(d)||/(opera)(?:.*version|)[ \\\\/]([\\\\w.]+)/.exec(d)||/(msie) ([\\\\w.]+)/.exec(d)||d.indexOf(\\\"compatible\\\")<0&&/(mozilla)(?:.*? rv:([\\\\w.]+)|)/.exec(d)||[],f={browser:e[1]||\\\"\\\",version:e[2]||\\\"0\\\"};e[1]&&(a[f.browser]=!0),a.chrome?a.webkit=!0:a.webkit&&(a.safari=!0)}return a.msie&&(a.version=b),a}function e(){return/(iPad|iPhone|iPod)/g.test(navigator.userAgent)&&!h()}function f(){return/(Android)/g.test(navigator.userAgent)&&!h()}function g(){return/(Blackberry)/g.test(navigator.userAgent)}function h(){return/(Windows Phone)/gi.test(navigator.userAgent)}function i(){return f()||e()||g()}function j(){return window.requestAnimationFrame||window.webkitRequestAnimationFrame||window.mozRequestAnimationFrame||function(a){window.setTimeout(a,1e3/60)}}function k(a){return parseInt(a,10)||0}function l(){var b=a('<div class=\\\"fr-visibility-helper\\\"></div>').appendTo(\\\"body\\\"),c=k(b.css(\\\"margin-left\\\"));return b.remove(),c}function m(){return\\\"ontouchstart\\\"in window||window.DocumentTouch&&document instanceof DocumentTouch}function n(a){if(!/^(https?:|ftps?:|)\\\\/\\\\//i.test(a))return!1;a=String(a).replace(/</g,\\\"%3C\\\").replace(/>/g,\\\"%3E\\\").replace(/\\\"/g,\\\"%22\\\").replace(/ /g,\\\"%20\\\");var b=/(http|ftp|https):\\\\/\\\\/[a-z\\\\u00a1-\\\\uffff0-9{}]+(\\\\.[a-z\\\\u00a1-\\\\uffff0-9{}]*)*([a-z\\\\u00a1-\\\\uffff0-9.,@?^=%&amp;:\\\\/~+#-_{}]*[a-z\\\\u00a1-\\\\uffff0-9@?^=%&amp;\\\\/~+#-_{}])?/gi;return b.test(a)}function o(a){if(/^(https?:|ftps?:|)\\\\/\\\\//i.test(a)){if(!n(a)&&!n(\\\"http:\\\"+a))return\\\"\\\"}else a=encodeURIComponent(a).replace(/%23/g,\\\"#\\\").replace(/%2F/g,\\\"/\\\").replace(/%25/g,\\\"%\\\").replace(/mailto%3A/gi,\\\"mailto:\\\").replace(/file%3A/gi,\\\"file:\\\").replace(/sms%3A/gi,\\\"sms:\\\").replace(/tel%3A/gi,\\\"tel:\\\").replace(/notes%3A/gi,\\\"notes:\\\").replace(/data%3Aimage/gi,\\\"data:image\\\").replace(/blob%3A/gi,\\\"blob:\\\").replace(/webkit-fake-url%3A/gi,\\\"webkit-fake-url:\\\").replace(/%3F/g,\\\"?\\\").replace(/%3D/g,\\\"=\\\").replace(/%26/g,\\\"&\\\").replace(/&amp;/g,\\\"&\\\").replace(/%2C/g,\\\",\\\").replace(/%3B/g,\\\";\\\").replace(/%2B/g,\\\"+\\\").replace(/%40/g,\\\"@\\\").replace(/%5B/g,\\\"[\\\").replace(/%5D/g,\\\"]\\\").replace(/%7B/g,\\\"{\\\").replace(/%7D/g,\\\"}\\\");return a}function p(a){return a&&!a.propertyIsEnumerable(\\\"length\\\")&&\\\"object\\\"==typeof a&&\\\"number\\\"==typeof a.length}function q(a){function b(a){return(\\\"0\\\"+parseInt(a,10).toString(16)).slice(-2)}try{return a&&\\\"transparent\\\"!==a?/^#[0-9A-F]{6}$/i.test(a)?a:(a=a.match(/^rgb\\\\((\\\\d+),\\\\s*(\\\\d+),\\\\s*(\\\\d+)\\\\)$/),(\\\"#\\\"+b(a[1])+b(a[2])+b(a[3])).toUpperCase()):\\\"\\\"}catch(c){return null}}function r(a){var b=/^#?([a-f\\\\d])([a-f\\\\d])([a-f\\\\d])$/i;a=a.replace(b,function(a,b,c,d){return b+b+c+c+d+d});var c=/^#?([a-f\\\\d]{2})([a-f\\\\d]{2})([a-f\\\\d]{2})$/i.exec(a);return c?\\\"rgb(\\\"+parseInt(c[1],16)+\\\", \\\"+parseInt(c[2],16)+\\\", \\\"+parseInt(c[3],16)+\\\")\\\":\\\"\\\"}function s(b){var c=(b.css(\\\"text-align\\\")||\\\"\\\").replace(/-(.*)-/g,\\\"\\\");if([\\\"left\\\",\\\"right\\\",\\\"justify\\\",\\\"center\\\"].indexOf(c)<0){if(!v){var d=a('<div dir=\\\"auto\\\" style=\\\"text-align: initial; position: fixed; left: -3000px;\\\"><span id=\\\"s1\\\">.</span><span id=\\\"s2\\\">.</span></div>');a(\\\"body\\\").append(d);var e=d.find(\\\"#s1\\\").get(0).getBoundingClientRect().left,f=d.find(\\\"#s2\\\").get(0).getBoundingClientRect().left;d.remove(),v=f>e?\\\"left\\\":\\\"right\\\"}c=v}return c}function t(){return null==w&&(w=navigator.platform.toUpperCase().indexOf(\\\"MAC\\\")>=0),w}function u(){b.browser=d()}var v,w=null;return{_init:u,isIOS:e,isMac:t,isAndroid:f,isBlackberry:g,isWindowsPhone:h,isMobile:i,requestAnimationFrame:j,getPX:k,screenSize:l,isTouch:m,sanitizeURL:o,isArray:p,RGBToHex:q,HEXtoRGB:r,isURL:n,getAlignment:s}},a.FE.MODULES.events=function(b){function c(a,b,c){s(a,b,c)}function d(){c(b.$el,\\\"cut copy paste beforepaste\\\",function(a){v(a.type,[a])})}function e(){c(b.$el,\\\"click mouseup mousedown touchstart touchend dragenter dragover dragleave dragend drop dragstart\\\",function(a){v(a.type,[a])}),r(\\\"mousedown\\\",function(){for(var c=0;c<a.FE.INSTANCES.length;c++)a.FE.INSTANCES[c]!=b&&a.FE.INSTANCES[c].popups&&a.FE.INSTANCES[c].popups.areVisible()&&a.FE.INSTANCES[c].$el.find(\\\".fr-marker\\\").remove()})}function f(){c(b.$el,\\\"keydown keypress keyup input\\\",function(a){v(a.type,[a])})}function g(){c(b.$win,b._mousedown,function(a){v(\\\"window.mousedown\\\",[a]),n()}),c(b.$win,b._mouseup,function(a){v(\\\"window.mouseup\\\",[a])}),c(b.$win,\\\"cut copy keydown keyup touchmove touchend\\\",function(a){v(\\\"window.\\\"+a.type,[a])})}function h(){c(b.$doc,\\\"dragend drop\\\",function(a){v(\\\"document.\\\"+a.type,[a])})}function i(c){if(\\\"undefined\\\"==typeof c&&(c=!0),!b.$wp)return!1;if(b.helpers.isIOS()&&b.$win.get(0).focus(),!b.core.hasFocus()&&c){var d=b.$win.scrollTop();return b.$el.focus(),d!=b.$win.scrollTop()&&b.$win.scrollTop(d),!1}if(!b.core.hasFocus()||b.$el.find(\\\".fr-marker\\\").length>0)return!1;var e=b.selection.info(b.$el.get(0));if(e.atStart&&b.selection.isCollapsed()&&null!=b.html.defaultTag()){var f=b.markers.insert();if(f&&!b.node.blockParent(f)){a(f).remove();var g=b.$el.find(b.html.blockTagsQuery()).get(0);g&&(a(g).prepend(a.FE.MARKERS),b.selection.restore())}else f&&a(f).remove()}}function j(){c(b.$el,\\\"focus\\\",function(a){p()&&(i(!1),C===!1&&v(a.type,[a]))}),c(b.$el,\\\"blur\\\",function(a){p()&&C===!0&&(v(a.type,[a]),n())}),r(\\\"focus\\\",function(){C=!0}),r(\\\"blur\\\",function(){C=!1})}function k(){b.helpers.isMobile()?(b._mousedown=\\\"touchstart\\\",b._mouseup=\\\"touchend\\\",b._move=\\\"touchmove\\\",b._mousemove=\\\"touchmove\\\"):(b._mousedown=\\\"mousedown\\\",b._mouseup=\\\"mouseup\\\",b._move=\\\"\\\",b._mousemove=\\\"mousemove\\\")}function l(c){var d=a(c.currentTarget);return b.edit.isDisabled()||d.hasClass(\\\"fr-disabled\\\")?(c.preventDefault(),!1):\\\"mousedown\\\"===c.type&&1!==c.which?!0:(b.helpers.isMobile()||c.preventDefault(),(b.helpers.isAndroid()||b.helpers.isWindowsPhone())&&0===d.parents(\\\".fr-dropdown-menu\\\").length&&(c.preventDefault(),c.stopPropagation()),d.addClass(\\\"fr-selected\\\"),void b.events.trigger(\\\"commands.mousedown\\\",[d]))}function m(c,d){var e=a(c.currentTarget);if(b.edit.isDisabled()||e.hasClass(\\\"fr-disabled\\\"))return c.preventDefault(),!1;if(\\\"mouseup\\\"===c.type&&1!==c.which)return!0;if(!e.hasClass(\\\"fr-selected\\\"))return!0;if(\\\"touchmove\\\"!=c.type){if(c.stopPropagation(),c.stopImmediatePropagation(),c.preventDefault(),!e.hasClass(\\\"fr-selected\\\"))return a(\\\".fr-selected\\\").removeClass(\\\"fr-selected\\\"),!1;if(a(\\\".fr-selected\\\").removeClass(\\\"fr-selected\\\"),e.data(\\\"dragging\\\")||e.attr(\\\"disabled\\\"))return e.removeData(\\\"dragging\\\"),!1;var f=e.data(\\\"timeout\\\");f&&(clearTimeout(f),e.removeData(\\\"timeout\\\")),d.apply(b,[c])}else e.data(\\\"timeout\\\")||e.data(\\\"timeout\\\",setTimeout(function(){e.data(\\\"dragging\\\",!0)},100))}function n(){A=!0}function o(){A=!1}function p(){return A}function q(a,c,d){s(a,b._mousedown,c,function(a){b.edit.isDisabled()||l(a)},!0),s(a,b._mouseup+\\\" \\\"+b._move,c,function(a){b.edit.isDisabled()||m(a,d)},!0),s(a,\\\"mousedown click mouseup\\\",c,function(a){b.edit.isDisabled()||a.stopPropagation()},!0),r(\\\"window.mouseup\\\",function(){b.edit.isDisabled()||(a.find(c).removeClass(\\\"fr-selected\\\"),n())})}function r(a,c,d){var e=a.split(\\\" \\\");if(e.length>1){for(var f=0;f<e.length;f++)r(e[f],c,d);return!0}\\\"undefined\\\"==typeof d&&(d=!1);var g;g=0!=a.indexOf(\\\"shared.\\\")?B[a]=B[a]||[]:b.shared._events[a]=b.shared._events[a]||[],d?g.unshift(c):g.push(c)}function s(a,c,d,e,f){\\\"function\\\"==typeof d&&(f=e,e=d,d=!1);var g=f?b.shared.$_events:D,h=f?b.sid:b.id;d?a.on(c.split(\\\" \\\").join(\\\".ed\\\"+h+\\\" \\\")+\\\".ed\\\"+h,d,e):a.on(c.split(\\\" \\\").join(\\\".ed\\\"+h+\\\" \\\")+\\\".ed\\\"+h,e),g.indexOf(a.get(0))<0&&g.push(a.get(0))}function t(b,c){for(var d=0;d<b.length;d++)a(b[d]).off(\\\".ed\\\"+c)}function u(){t(D,b.id),D=[],0==b.shared.count&&(t(b.shared.$_events,b.sid),b.shared.$_events=null)}function v(c,d,e){if(!b.edit.isDisabled()||e){var f;if(0!=c.indexOf(\\\"shared.\\\"))f=B[c];else{if(b.shared.count>0)return!1;f=b.shared._events[c]}var g;if(f)for(var h=0;h<f.length;h++)if(g=f[h].apply(b,d),g===!1)return!1;return g=b.$oel.triggerHandler(\\\"froalaEditor.\\\"+c,a.merge([b],d||[])),g===!1?!1:g}}function w(c,d,e){if(!b.edit.isDisabled()||e){var f;if(0!=c.indexOf(\\\"shared.\\\"))f=B[c];else{if(b.shared.count>0)return!1;f=b.shared._events[c]}var g;if(f)for(var h=0;h<f.length;h++)g=f[h].apply(b,[d]),\\\"undefined\\\"!=typeof g&&(d=g);return g=b.$oel.triggerHandler(\\\"froalaEditor.\\\"+c,a.merge([b],[d])),\\\"undefined\\\"!=typeof g&&(d=g),d}}function x(){for(var a in B)B.hasOwnProperty(a)&&delete B[a]}function y(){for(var a in b.shared._events)b.shared._events.hasOwnProperty(a)&&delete b.shared._events[a]}function z(){b.shared.$_events=b.shared.$_events||[],b.shared._events={},k(),e(),g(),h(),f(),j(),n(),d(),r(\\\"destroy\\\",x),r(\\\"shared.destroy\\\",y)}var A,B={},C=!1,D=[];return{_init:z,on:r,trigger:v,bindClick:q,disableBlur:o,enableBlur:n,blurActive:p,focus:i,chainTrigger:w,$on:s,$off:u}},a.FE.INVISIBLE_SPACE=\\\"&#8203;\\\",a.FE.START_MARKER='<span class=\\\"fr-marker\\\" data-id=\\\"0\\\" data-type=\\\"true\\\" style=\\\"display: none; line-height: 0;\\\">'+a.FE.INVISIBLE_SPACE+\\\"</span>\\\",a.FE.END_MARKER='<span class=\\\"fr-marker\\\" data-id=\\\"0\\\" data-type=\\\"false\\\" style=\\\"display: none; line-height: 0;\\\">'+a.FE.INVISIBLE_SPACE+\\\"</span>\\\",a.FE.MARKERS=a.FE.START_MARKER+a.FE.END_MARKER,a.FE.MODULES.markers=function(b){function c(c,d){return a('<span class=\\\"fr-marker\\\" data-id=\\\"'+d+'\\\" data-type=\\\"'+c+'\\\" style=\\\"display: '+(b.browser.safari?\\\"none\\\":\\\"inline-block\\\")+'; line-height: 0;\\\">'+a.FE.INVISIBLE_SPACE+\\\"</span>\\\",b.doc)[0]}function d(d,e,f){try{var g=d.cloneRange();if(g.collapse(e),g.insertNode(c(e,f)),e===!0&&d.collapsed)for(var h=b.$el.find('span.fr-marker[data-type=\\\"true\\\"][data-id=\\\"'+f+'\\\"]'),i=h.get(0).nextSibling;i&&i.nodeType===Node.TEXT_NODE&&0===i.textContent.length;)a(i).remove(),i=h.nextSibling;if(e===!0&&!d.collapsed){var h=b.$el.find('span.fr-marker[data-type=\\\"true\\\"][data-id=\\\"'+f+'\\\"]').get(0),i=h.nextSibling;if(i&&i.nodeType===Node.ELEMENT_NODE&&b.node.isBlock(i)){var j=[i];do i=j[0],j=b.node.contents(i);while(j[0]&&b.node.isBlock(j[0]));a(i).prepend(a(h))}}if(e===!1&&!d.collapsed){var h=b.$el.find('span.fr-marker[data-type=\\\"false\\\"][data-id=\\\"'+f+'\\\"]').get(0),i=h.previousSibling;if(i&&i.nodeType===Node.ELEMENT_NODE&&b.node.isBlock(i)){var j=[i];do i=j[j.length-1],j=b.node.contents(i);while(j[j.length-1]&&b.node.isBlock(j[j.length-1]));a(i).append(a(h))}h.parentNode&&[\\\"TD\\\",\\\"TH\\\"].indexOf(h.parentNode.tagName)>=0&&h.parentNode.previousSibling&&!h.previousSibling&&a(h.parentNode.previousSibling).append(h)}var k=b.$el.find('span.fr-marker[data-type=\\\"'+e+'\\\"][data-id=\\\"'+f+'\\\"]').get(0);return k&&(k.style.display=\\\"none\\\"),k}catch(l){return null}}function e(){if(!b.$wp)return null;try{var c=b.selection.ranges(0),d=c.commonAncestorContainer;if(d!=b.$el.get(0)&&0==b.$el.find(d).length)return null;var e=c.cloneRange(),f=c.cloneRange();e.collapse(!0);var g=a('<span class=\\\"fr-marker\\\" style=\\\"display: none; line-height: 0;\\\">'+a.FE.INVISIBLE_SPACE+\\\"</span>\\\",b.doc)[0];if(e.insertNode(g),g=b.$el.find(\\\"span.fr-marker\\\").get(0)){for(var h=g.nextSibling;h&&h.nodeType===Node.TEXT_NODE&&0===h.textContent.length;)a(h).remove(),h=b.$el.find(\\\"span.fr-marker\\\").get(0).nextSibling;return b.selection.clear(),b.selection.get().addRange(f),g}return null}catch(i){}}function f(){b.selection.isCollapsed()||b.selection.remove();var c=b.$el.find(\\\".fr-marker\\\").get(0);if(null==c&&(c=e()),null==c)return null;var d;if(d=b.node.deepestParent(c))if(b.node.isBlock(d)&&b.node.isEmpty(d))a(d).replaceWith('<span class=\\\"fr-marker\\\"></span>');else{var f=c,g=\\\"\\\",h=\\\"\\\";do f=f.parentNode,g+=b.node.closeTagString(f),h=b.node.openTagString(f)+h;while(f!=d);a(c).replaceWith('<span id=\\\"fr-break\\\"></span>');var i=b.node.openTagString(d)+a(d).html()+b.node.closeTagString(d);i=i.replace(/<span id=\\\"fr-break\\\"><\\\\/span>/g,g+'<span class=\\\"fr-marker\\\"></span>'+h),a(d).replaceWith(i)}return b.$el.find(\\\".fr-marker\\\").get(0)}function g(a){var c=a.clientX,d=a.clientY;h();var f,g=null;if(\\\"undefined\\\"!=typeof b.doc.caretPositionFromPoint?(f=b.doc.caretPositionFromPoint(c,d),\\ng=b.doc.createRange(),g.setStart(f.offsetNode,f.offset),g.setEnd(f.offsetNode,f.offset)):\\\"undefined\\\"!=typeof b.doc.caretRangeFromPoint&&(f=b.doc.caretRangeFromPoint(c,d),g=b.doc.createRange(),g.setStart(f.startContainer,f.startOffset),g.setEnd(f.startContainer,f.startOffset)),null!==g&&\\\"undefined\\\"!=typeof b.win.getSelection){var i=b.win.getSelection();i.removeAllRanges(),i.addRange(g)}else if(\\\"undefined\\\"!=typeof b.doc.body.createTextRange)try{g=b.doc.body.createTextRange(),g.moveToPoint(c,d);var j=g.duplicate();j.moveToPoint(c,d),g.setEndPoint(\\\"EndToEnd\\\",j),g.select()}catch(k){return!1}e()}function h(){b.$el.find(\\\".fr-marker\\\").remove()}return{place:d,insert:e,split:f,insertAtPoint:g,remove:h}},a.FE.MODULES.selection=function(b){function c(){var a=\\\"\\\";return b.win.getSelection?a=b.win.getSelection():b.doc.getSelection?a=b.doc.getSelection():b.doc.selection&&(a=b.doc.selection.createRange().text),a.toString()}function d(){var a=\\\"\\\";return a=b.win.getSelection?b.win.getSelection():b.doc.getSelection?b.doc.getSelection():b.doc.selection.createRange()}function e(a){var c=d(),e=[];if(c&&c.getRangeAt&&c.rangeCount)for(var e=[],f=0;f<c.rangeCount;f++)e.push(c.getRangeAt(f));else e=b.doc.createRange?[b.doc.createRange()]:[];return\\\"undefined\\\"!=typeof a?e[a]:e}function f(){var a=d();try{a.removeAllRanges?a.removeAllRanges():a.empty?a.empty():a.clear&&a.clear()}catch(b){}}function g(){var f=d();try{if(f.rangeCount){var g=e(0),h=g.startContainer;if(h.nodeType==Node.TEXT_NODE&&g.startOffset==(h.textContent||\\\"\\\").length&&h.nextSibling&&(h=h.nextSibling),h.nodeType==Node.ELEMENT_NODE){var i=!1;if(h.childNodes.length>0&&h.childNodes[g.startOffset]){for(var j=h.childNodes[g.startOffset];j&&j.nodeType==Node.TEXT_NODE&&0==j.textContent.length;)j=j.nextSibling;if(j&&j.textContent.replace(/\\\\u200B/g,\\\"\\\")===c().replace(/\\\\u200B/g,\\\"\\\")&&(h=j,i=!0),!i&&h.childNodes.length>1&&g.startOffset>0&&h.childNodes[g.startOffset-1]){for(var j=h.childNodes[g.startOffset-1];j&&j.nodeType==Node.TEXT_NODE&&0==j.textContent.length;)j=j.nextSibling;j&&j.textContent.replace(/\\\\u200B/g,\\\"\\\")===c().replace(/\\\\u200B/g,\\\"\\\")&&(h=j,i=!0)}}else if(!g.collapsed&&h.nextSibling&&h.nextSibling.nodeType==Node.ELEMENT_NODE){var j=h.nextSibling;j&&j.textContent.replace(/\\\\u200B/g,\\\"\\\")===c().replace(/\\\\u200B/g,\\\"\\\")&&(h=j,i=!0)}!i&&h.childNodes.length>0&&a(h.childNodes[0]).text().replace(/\\\\u200B/g,\\\"\\\")===c().replace(/\\\\u200B/g,\\\"\\\")&&[\\\"BR\\\",\\\"IMG\\\",\\\"HR\\\"].indexOf(h.childNodes[0].tagName)<0&&(h=h.childNodes[0])}for(;h.nodeType!=Node.ELEMENT_NODE&&h.parentNode;)h=h.parentNode;for(var k=h;k&&\\\"HTML\\\"!=k.tagName;){if(k==b.$el.get(0))return h;k=a(k).parent()[0]}}}catch(l){}return b.$el.get(0)}function h(){var f=d();try{if(f.rangeCount){var g=e(0),h=g.endContainer;if(h.nodeType==Node.ELEMENT_NODE){var i=!1;if(h.childNodes.length>0&&h.childNodes[g.endOffset]&&a(h.childNodes[g.endOffset]).text()===c())h=h.childNodes[g.endOffset],i=!0;else if(!g.collapsed&&h.previousSibling&&h.previousSibling.nodeType==Node.ELEMENT_NODE){var j=h.previousSibling;j&&j.textContent.replace(/\\\\u200B/g,\\\"\\\")===c().replace(/\\\\u200B/g,\\\"\\\")&&(h=j,i=!0)}else if(!g.collapsed&&h.childNodes.length>0&&h.childNodes[g.endOffset]){var j=h.childNodes[g.endOffset].previousSibling;j.nodeType==Node.ELEMENT_NODE&&j&&j.textContent.replace(/\\\\u200B/g,\\\"\\\")===c().replace(/\\\\u200B/g,\\\"\\\")&&(h=j,i=!0)}!i&&h.childNodes.length>0&&a(h.childNodes[h.childNodes.length-1]).text()===c()&&[\\\"BR\\\",\\\"IMG\\\",\\\"HR\\\"].indexOf(h.childNodes[h.childNodes.length-1].tagName)<0&&(h=h.childNodes[h.childNodes.length-1])}for(h.nodeType==Node.TEXT_NODE&&0==g.endOffset&&h.previousSibling&&h.previousSibling.nodeType==Node.ELEMENT_NODE&&(h=h.previousSibling);h.nodeType!=Node.ELEMENT_NODE&&h.parentNode;)h=h.parentNode;for(var k=h;k&&\\\"HTML\\\"!=k.tagName;){if(k==b.$el.get(0))return h;k=a(k).parent()[0]}}}catch(l){}return b.$el.get(0)}function i(a,b){var c=a;return c.nodeType==Node.ELEMENT_NODE&&c.childNodes.length>0&&c.childNodes[b]&&(c=c.childNodes[b]),c.nodeType==Node.TEXT_NODE&&(c=c.parentNode),c}function j(){var c=[],f=d();if(t()&&f.rangeCount)for(var g=e(),h=0;h<g.length;h++){var j=g[h],k=i(j.startContainer,j.startOffset),l=i(j.endContainer,j.endOffset);b.node.isBlock(k)&&c.indexOf(k)<0&&c.push(k);var m=b.node.blockParent(k);m&&c.indexOf(m)<0&&c.push(m);for(var n=[],o=k;o!==l&&o!==b.$el.get(0);)n.indexOf(o)<0&&o.children&&o.children.length?(n.push(o),o=o.children[0]):o.nextSibling?o=o.nextSibling:o.parentNode&&(o=o.parentNode,n.push(o)),b.node.isBlock(o)&&n.indexOf(o)<0&&c.indexOf(o)<0&&(o!==l||j.endOffset>0)&&c.push(o);b.node.isBlock(l)&&c.indexOf(l)<0&&j.endOffset>0&&c.push(l);var m=b.node.blockParent(l);m&&c.indexOf(m)<0&&c.push(m)}for(var h=c.length-1;h>0;h--)a(c[h]).find(c).length&&\\\"LI\\\"!=c[h].tagName&&c.splice(h,1);return c}function k(){if(b.$wp){b.markers.remove();for(var a=e(),c=[],d=0;d<a.length;d++)if(a[d].startContainer!==b.doc){var f=a[d],g=f.collapsed,h=b.markers.place(f,!0,d),i=b.markers.place(f,!1,d);if(b.$el.get(0).normalize(),b.browser.safari&&!g){var f=b.doc.createRange();f.setStartAfter(h),f.setEndBefore(i),c.push(f)}}if(b.browser.safari&&c.length){b.selection.clear();for(var d=0;d<c.length;d++)b.selection.get().addRange(c[d])}}}function l(){var c=b.$el.get(0).querySelectorAll('.fr-marker[data-type=\\\"true\\\"]');if(!b.$wp)return b.markers.remove(),!1;if(0===c.length)return!1;if(b.browser.msie||b.browser.edge)for(var e=0;e<c.length;e++)c[e].style.display=\\\"inline-block\\\";b.core.hasFocus()||b.browser.msie||b.browser.webkit||b.$el.focus(),f();for(var g=d(),e=0;e<c.length;e++){var h=a(c[e]).data(\\\"id\\\"),i=c[e],j=b.doc.createRange(),k=b.$el.find('.fr-marker[data-type=\\\"false\\\"][data-id=\\\"'+h+'\\\"]');(b.browser.msie||b.browser.edge)&&k.css(\\\"display\\\",\\\"inline-block\\\");var l=null;if(k.length>0){k=k[0];try{for(var n=!1,o=i.nextSibling;o&&o.nodeType==Node.TEXT_NODE&&0==o.textContent.length;){var p=o;o=o.nextSibling,a(p).remove()}for(var q=k.nextSibling;q&&q.nodeType==Node.TEXT_NODE&&0==q.textContent.length;){var p=q;q=q.nextSibling,a(p).remove()}if(i.nextSibling==k||k.nextSibling==i){for(var r=i.nextSibling==k?i:k,s=r==i?k:i,t=r.previousSibling;t&&t.nodeType==Node.TEXT_NODE&&0==t.length;){var p=t;t=t.previousSibling,a(p).remove()}if(t&&t.nodeType==Node.TEXT_NODE)for(;t&&t.previousSibling&&t.previousSibling.nodeType==Node.TEXT_NODE;)t.previousSibling.textContent=t.previousSibling.textContent+t.textContent,t=t.previousSibling,a(t.nextSibling).remove();for(var u=s.nextSibling;u&&u.nodeType==Node.TEXT_NODE&&0==u.length;){var p=u;u=u.nextSibling,a(p).remove()}if(u&&u.nodeType==Node.TEXT_NODE)for(;u&&u.nextSibling&&u.nextSibling.nodeType==Node.TEXT_NODE;)u.nextSibling.textContent=u.textContent+u.nextSibling.textContent,u=u.nextSibling,a(u.previousSibling).remove();if(t&&(b.node.isVoid(t)||b.node.isBlock(t))&&(t=null),u&&(b.node.isVoid(u)||b.node.isBlock(u))&&(u=null),t&&u&&t.nodeType==Node.TEXT_NODE&&u.nodeType==Node.TEXT_NODE){a(i).remove(),a(k).remove();var v=t.textContent.length;t.textContent=t.textContent+u.textContent,a(u).remove(),b.spaces.normalize(t),j.setStart(t,v),j.setEnd(t,v),n=!0}else!t&&u&&u.nodeType==Node.TEXT_NODE?(a(i).remove(),a(k).remove(),b.spaces.normalize(u),l=a(b.doc.createTextNode(\\\"\\\\u200b\\\")),a(u).before(l),j.setStart(u,0),j.setEnd(u,0),n=!0):!u&&t&&t.nodeType==Node.TEXT_NODE&&(a(i).remove(),a(k).remove(),b.spaces.normalize(t),l=a(b.doc.createTextNode(\\\"\\\\u200b\\\")),a(t).after(l),j.setStart(t,t.textContent.length),j.setEnd(t,t.textContent.length),n=!0)}if(!n){var w,x;if(b.browser.chrome&&i.nextSibling==k)w=m(k,j,!0)||j.setStartAfter(k),x=m(i,j,!1)||j.setEndBefore(i);else{i.previousSibling==k&&(i=k,k=i.nextSibling),k.nextSibling&&\\\"BR\\\"===k.nextSibling.tagName||!k.nextSibling&&b.node.isBlock(i.previousSibling)||i.previousSibling&&\\\"BR\\\"==i.previousSibling.tagName||(i.style.display=\\\"inline\\\",k.style.display=\\\"inline\\\",l=a(b.doc.createTextNode(\\\"\\\\u200b\\\")));var y=i.previousSibling;y&&y.style&&\\\"block\\\"==b.win.getComputedStyle(y).display&&!b.opts.enter==a.FE.ENTER_BR?(j.setEndAfter(y),j.setStartAfter(y)):(w=m(i,j,!0)||a(i).before(l)&&j.setStartBefore(i),x=m(k,j,!1)||a(k).after(l)&&j.setEndAfter(k))}\\\"function\\\"==typeof w&&w(),\\\"function\\\"==typeof x&&x()}}catch(z){}}l&&l.remove();try{g.addRange(j)}catch(z){}}b.markers.remove()}function m(c,d,e){var f=c.previousSibling,g=c.nextSibling;if(f&&g&&f.nodeType==Node.TEXT_NODE&&g.nodeType==Node.TEXT_NODE){var h=f.textContent.length;return e?(g.textContent=f.textContent+g.textContent,a(f).remove(),a(c).remove(),b.spaces.normalize(g),function(){d.setStart(g,h)}):(f.textContent=f.textContent+g.textContent,a(g).remove(),a(c).remove(),b.spaces.normalize(f),function(){d.setEnd(f,h)})}if(f&&!g&&f.nodeType==Node.TEXT_NODE){var h=f.textContent.length;return e?(b.spaces.normalize(f),function(){d.setStart(f,h)}):(b.spaces.normalize(f),function(){d.setEnd(f,h)})}return g&&!f&&g.nodeType==Node.TEXT_NODE?e?(b.spaces.normalize(g),function(){d.setStart(g,0)}):(b.spaces.normalize(g),function(){d.setEnd(g,0)}):!1}function n(){return!0}function o(){for(var a=e(),b=0;b<a.length;b++)if(!a[b].collapsed)return!1;return!0}function p(a){var c,d,e=!1,f=!1;if(b.win.getSelection){var g=b.win.getSelection();g.rangeCount&&(c=g.getRangeAt(0),d=c.cloneRange(),d.selectNodeContents(a),d.setEnd(c.startContainer,c.startOffset),e=\\\"\\\"===d.toString(),d.selectNodeContents(a),d.setStart(c.endContainer,c.endOffset),f=\\\"\\\"===d.toString())}else b.doc.selection&&\\\"Control\\\"!=b.doc.selection.type&&(c=b.doc.selection.createRange(),d=c.duplicate(),d.moveToElementText(a),d.setEndPoint(\\\"EndToStart\\\",c),e=\\\"\\\"===d.text,d.moveToElementText(a),d.setEndPoint(\\\"StartToEnd\\\",c),f=\\\"\\\"===d.text);return{atStart:e,atEnd:f}}function q(){if(o())return!1;b.$el.find(\\\"td, th, img\\\").prepend('<span class=\\\"fr-mk\\\">'+a.FE.INVISIBLE_SPACE+\\\"</span>\\\");var c=!1,d=p(b.$el.get(0));return d.atStart&&d.atEnd&&(c=!0),b.$el.find(\\\".fr-mk\\\").remove(),c}function r(c,d){\\\"undefined\\\"==typeof d&&(d=!0);var e=a(c).html();e&&e.replace(/\\\\u200b/g,\\\"\\\").length!=e.length&&a(c).html(e.replace(/\\\\u200b/g,\\\"\\\"));for(var f=b.node.contents(c),g=0;g<f.length;g++)f[g].nodeType!=Node.ELEMENT_NODE?a(f[g]).remove():(r(f[g],0==g),0==g&&(d=!1));c.nodeType==Node.TEXT_NODE?a(c).replaceWith('<span data-first=\\\"true\\\" data-text=\\\"true\\\"></span>'):d&&a(c).attr(\\\"data-first\\\",!0)}function s(c,d){var e=b.node.contents(c.get(0));[\\\"TD\\\",\\\"TH\\\"].indexOf(c.get(0).tagName)>=0&&1==c.find(\\\".fr-marker\\\").length&&a(e[0]).hasClass(\\\"fr-marker\\\")&&c.attr(\\\"data-del-cell\\\",!0);for(var f=0;f<e.length;f++){var g=e[f];a(g).hasClass(\\\"fr-marker\\\")?d=(d+1)%2:d?a(g).find(\\\".fr-marker\\\").length>0?d=s(a(g),d):[\\\"TD\\\",\\\"TH\\\"].indexOf(g.tagName)<0&&!a(g).hasClass(\\\"fr-inner\\\")?!b.opts.keepFormatOnDelete||b.$el.find(\\\"[data-first]\\\").length>0?a(g).remove():r(g):a(g).hasClass(\\\"fr-inner\\\")?0==a(g).find(\\\".fr-inner\\\").length?a(g).html(\\\"<br>\\\"):a(g).find(\\\".fr-inner\\\").filter(function(){return 0==a(this).find(\\\"fr-inner\\\").length}).html(\\\"<br>\\\"):(a(g).empty(),a(g).attr(\\\"data-del-cell\\\",!0)):a(g).find(\\\".fr-marker\\\").length>0&&(d=s(a(g),d))}return d}function t(){try{if(!b.$wp)return!1;for(var a=e(0),c=a.commonAncestorContainer;c&&!b.node.isElement(c);)c=c.parentNode;return b.node.isElement(c)?!0:!1}catch(d){return!1}}function u(){if(o())return!0;k();for(var c=function(b){for(var c=b.previousSibling;c&&c.nodeType==Node.TEXT_NODE&&0==c.textContent.length;){var d=c,c=c.previousSibling;a(d).remove()}return c},d=function(b){for(var c=b.nextSibling;c&&c.nodeType==Node.TEXT_NODE&&0==c.textContent.length;){var d=c,c=c.nextSibling;a(d).remove()}return c},e=b.$el.find('.fr-marker[data-type=\\\"true\\\"]'),f=0;f<e.length;f++)for(var g=e[f];!c(g)&&!b.node.isBlock(g.parentNode)&&!b.$el.is(g.parentNode);)a(g.parentNode).before(g);for(var h=b.$el.find('.fr-marker[data-type=\\\"false\\\"]'),f=0;f<h.length;f++){for(var i=h[f];!d(i)&&!b.node.isBlock(i.parentNode)&&!b.$el.is(i.parentNode);)a(i.parentNode).after(i);i.parentNode&&b.node.isBlock(i.parentNode)&&b.node.isEmpty(i.parentNode)&&!b.$el.is(i.parentNode)&&b.opts.keepFormatOnDelete&&a(i.parentNode).after(i)}if(n()){s(b.$el,0);var j=b.$el.find('[data-first=\\\"true\\\"]');if(j.length)b.$el.find(\\\".fr-marker\\\").remove(),j.append(a.FE.INVISIBLE_SPACE+a.FE.MARKERS).removeAttr(\\\"data-first\\\"),j.attr(\\\"data-text\\\")&&j.replaceWith(j.html());else{b.$el.find(\\\"table\\\").filter(function(){var b=a(this).find(\\\"[data-del-cell]\\\").length>0&&a(this).find(\\\"[data-del-cell]\\\").length==a(this).find(\\\"td, th\\\").length;return b}).remove(),b.$el.find(\\\"[data-del-cell]\\\").removeAttr(\\\"data-del-cell\\\");for(var e=b.$el.find('.fr-marker[data-type=\\\"true\\\"]'),f=0;f<e.length;f++){var m=e[f],p=m.nextSibling,q=b.$el.find('.fr-marker[data-type=\\\"false\\\"][data-id=\\\"'+a(m).data(\\\"id\\\")+'\\\"]').get(0);if(q){if(p&&p==q);else if(m){var r=b.node.blockParent(m),t=b.node.blockParent(q),u=!1,v=!1;if(r&&[\\\"UL\\\",\\\"OL\\\"].indexOf(r.tagName)>=0&&(r=null,u=!0),t&&[\\\"UL\\\",\\\"OL\\\"].indexOf(t.tagName)>=0&&(t=null,v=!0),a(m).after(q),r==t);else if(null!=r||u)if(null!=t||v||0!=a(r).parentsUntil(b.$el,\\\"table\\\").length)r&&t&&0==a(r).parentsUntil(b.$el,\\\"table\\\").length&&0==a(t).parentsUntil(b.$el,\\\"table\\\").length&&(a(r).append(a(t).html()),a(t).remove());else{for(var p=r;!p.nextSibling&&p.parentNode!=b.$el.get(0);)p=p.parentNode;for(p=p.nextSibling;p&&\\\"BR\\\"!=p.tagName;){var w=p.nextSibling;a(r).append(p),p=w}p&&\\\"BR\\\"==p.tagName&&a(p).remove()}else{var x=b.node.deepestParent(m);x?(a(x).after(a(t).html()),a(t).remove()):0==a(t).parentsUntil(b.$el,\\\"table\\\").length&&(a(m).next().after(a(t).html()),a(t).remove())}}}else q=a(m).clone().attr(\\\"data-type\\\",!1),a(m).after(q)}}}b.opts.keepFormatOnDelete||b.html.fillEmptyBlocks(),b.html.cleanEmptyTags(!0),b.clean.lists(),b.spaces.normalize();var y=b.$el.find(\\\".fr-marker:last\\\").get(0),z=b.$el.find(\\\".fr-marker:first\\\").get(0);!y.nextSibling&&z.previousSibling&&\\\"BR\\\"==z.previousSibling.tagName&&b.node.isElement(y.parentNode)&&b.node.isElement(z.parentNode)&&b.$el.append(\\\"<br>\\\"),l()}function v(c){if(a(c).find(\\\".fr-marker\\\").length>0)return!1;for(var d=b.node.contents(c);d.length&&b.node.isBlock(d[0]);)c=d[0],d=b.node.contents(c);a(c).prepend(a.FE.MARKERS)}function w(c){if(a(c).find(\\\".fr-marker\\\").length>0)return!1;for(var d=b.node.contents(c);d.length&&b.node.isBlock(d[d.length-1]);)c=d[d.length-1],d=b.node.contents(c);a(c).append(a.FE.MARKERS)}function x(c){for(var d=c.previousSibling;d&&d.nodeType==Node.TEXT_NODE&&0==d.textContent.length;)d=d.previousSibling;return d?(b.node.isBlock(d)?w(d):\\\"BR\\\"==d.tagName?a(d).before(a.FE.MARKERS):a(d).after(a.FE.MARKERS),!0):!1}function y(c){for(var d=c.nextSibling;d&&d.nodeType==Node.TEXT_NODE&&0==d.textContent.length;)d=d.nextSibling;return d?(b.node.isBlock(d)?v(d):a(d).before(a.FE.MARKERS),!0):!1}return{text:c,get:d,ranges:e,clear:f,element:g,endElement:h,save:k,restore:l,isCollapsed:o,isFull:q,inEditor:t,remove:u,blocks:j,info:p,setAtEnd:w,setAtStart:v,setBefore:x,setAfter:y,rangeElement:i}},a.FE.MODULES.spaces=function(b){function c(a){var b=a.nextSibling||a.parentNode;return a.parentNode.removeChild(a),b}function d(a,b){return a&&a.parentNode===b||\\\"PRE\\\"===b.nodeName?b.nextSibling||b.parentNode:b.firstChild||b.nextSibling||b.parentNode}function e(a){if(a.firstChild&&\\\"PRE\\\"!==a.nodeName&&!([\\\"STYLE\\\",\\\"SCRIPT\\\"].indexOf(a.tagName)>=0)){for(var e=null,f=null,g=d(f,a);g!==a&&\\\"PRE\\\"!==g.nodeName&&[\\\"STYLE\\\",\\\"SCRIPT\\\"].indexOf(g.tagName)<0;){if(g.nodeType===Node.TEXT_NODE){var h=g.data.replace(/[ \\\\r\\\\n\\\\t]+/g,\\\" \\\");if(e&&!/ $/.test(e.data)||\\\" \\\"!==h[0]||g.previousSibling&&b.node.isVoid(g.previousSibling)&&\\\"BR\\\"!==g.previousSibling.tagName||(h=h.substr(1)),!h||0==h.length){g=c(g);continue}g.data=h,e=g}else g.nodeType===Node.ELEMENT_NODE&&(b.node.isBlock(g)||b.node.isVoid(g)?(e&&e.data&&(b.node.isBlock(g)||\\\"BR\\\"===g.tagName)&&(e.data=e.data.replace(/ $/,\\\"\\\")),e=null):0==g.textContent.length&&(e=g));var i=d(f,g);f=g,g=i}e&&e.data&&(e.data=e.data.replace(/ $/,\\\"\\\"),e.data||c(e))}}function f(c,d){if(\\\"undefined\\\"!=typeof c&&c||(c=b.$el.get(0)),\\\"undefined\\\"==typeof d&&(d=!1),d&&e(c),!c.getAttribute||\\\"false\\\"!=c.getAttribute(\\\"contenteditable\\\"))if(c.nodeType==Node.ELEMENT_NODE&&[\\\"STYLE\\\",\\\"SCRIPT\\\",\\\"HEAD\\\"].indexOf(c.tagName)<0)for(var g=b.node.contents(c),h=g.length-1;h>=0;h--)(g[h].tagName!=Node.ELEMENT_NODE||(g[h].getAttribute(\\\"class\\\")||\\\"\\\").indexOf(\\\"fr-marker\\\")<0)&&f(g[h]);else if(c.nodeType==Node.TEXT_NODE&&c.textContent.length>0){var i=(c.previousSibling,c.nextSibling,c.textContent);i=i.replace(new RegExp(a.FE.UNICODE_NBSP,\\\"g\\\"),\\\" \\\");for(var j=\\\"\\\",k=0;k<i.length;k++)j+=32!=i.charCodeAt(k)||0!==k&&32!=j.charCodeAt(k-1)?i[k]:a.FE.UNICODE_NBSP;(!c.nextSibling||b.node.isBlock(c.nextSibling)||c.nextSibling.nodeType==Node.ELEMENT_NODE&&b.win.getComputedStyle(c.nextSibling)&&\\\"block\\\"==b.win.getComputedStyle(c.nextSibling).display)&&(j=j.replace(/ $/,a.FE.UNICODE_NBSP)),!c.previousSibling||b.node.isVoid(c.previousSibling)||b.node.isBlock(c.previousSibling)||(j=j.replace(/^\\\\u00A0([^ $])/,\\\" $1\\\"),1!==j.length||160!==j.charCodeAt(0)||!c.nextSibling||b.node.isVoid(c.nextSibling)||b.node.isBlock(c.nextSibling)||(j=\\\" \\\")),j=j.replace(/([^ \\\\u00A0])\\\\u00A0([^ \\\\u00A0])/g,\\\"$1 $2\\\"),c.textContent!=j&&(c.textContent=j)}}return{normalize:f}},a.FE.UNICODE_NBSP=String.fromCharCode(160),a.FE.VOID_ELEMENTS=[\\\"area\\\",\\\"base\\\",\\\"br\\\",\\\"col\\\",\\\"embed\\\",\\\"hr\\\",\\\"img\\\",\\\"input\\\",\\\"keygen\\\",\\\"link\\\",\\\"menuitem\\\",\\\"meta\\\",\\\"param\\\",\\\"source\\\",\\\"track\\\",\\\"wbr\\\"],a.FE.BLOCK_TAGS=[\\\"address\\\",\\\"article\\\",\\\"aside\\\",\\\"audio\\\",\\\"blockquote\\\",\\\"canvas\\\",\\\"dd\\\",\\\"div\\\",\\\"dl\\\",\\\"dt\\\",\\\"fieldset\\\",\\\"figcaption\\\",\\\"figure\\\",\\\"footer\\\",\\\"form\\\",\\\"h1\\\",\\\"h2\\\",\\\"h3\\\",\\\"h4\\\",\\\"h5\\\",\\\"h6\\\",\\\"header\\\",\\\"hgroup\\\",\\\"hr\\\",\\\"li\\\",\\\"main\\\",\\\"nav\\\",\\\"noscript\\\",\\\"ol\\\",\\\"output\\\",\\\"p\\\",\\\"pre\\\",\\\"section\\\",\\\"table\\\",\\\"tbody\\\",\\\"td\\\",\\\"tfoot\\\",\\\"th\\\",\\\"thead\\\",\\\"tr\\\",\\\"ul\\\",\\\"video\\\"],a.extend(a.FE.DEFAULTS,{htmlAllowedEmptyTags:[\\\"textarea\\\",\\\"a\\\",\\\"iframe\\\",\\\"object\\\",\\\"video\\\",\\\"style\\\",\\\"script\\\",\\\".fa\\\",\\\".fr-emoticon\\\"],htmlDoNotWrapTags:[\\\"script\\\",\\\"style\\\"],htmlSimpleAmpersand:!1,htmlIgnoreCSSProperties:[]}),a.FE.MODULES.html=function(b){function c(){return b.opts.enter==a.FE.ENTER_P?\\\"p\\\":b.opts.enter==a.FE.ENTER_DIV?\\\"div\\\":b.opts.enter==a.FE.ENTER_BR?null:void 0}function d(){var c=[],d=b.$el.get(0).querySelectorAll(f()),e=f();e+=\\\",\\\"+a.FE.VOID_ELEMENTS.join(\\\",\\\"),e+=\\\",\\\"+b.opts.htmlAllowedEmptyTags.join(\\\":not(.fr-marker),\\\")+\\\":not(.fr-marker)\\\";for(var g=d.length-1;g>=0;g--)if(!(d[g].querySelectorAll(e).length>0||d[g].textContent&&d[g].textContent.replace(/\\\\u200B|\\\\n/g,\\\"\\\").length>0)){for(var h=b.node.contents(d[g]),i=!1,j=0;j<h.length;j++)if(h[j].nodeType!=Node.COMMENT_NODE&&h[j].textContent&&h[j].textContent.replace(/\\\\u200B|\\\\n/g,\\\"\\\").length>0){i=!0;break}i||c.push(d[g])}return c}function e(){return a.FE.BLOCK_TAGS.join(\\\":empty, \\\")+\\\":empty\\\"}function f(){return a.FE.BLOCK_TAGS.join(\\\", \\\")}function g(c){var d=a.merge([],a.FE.VOID_ELEMENTS);d=a.merge(d,b.opts.htmlAllowedEmptyTags),\\\"undefined\\\"==typeof c&&(d=a.merge(d,a.FE.BLOCK_TAGS));var e,f;do{f=!1,e=b.$el.get(0).querySelectorAll(\\\"*:empty:not(\\\"+d.join(\\\"):not(\\\")+\\\"):not(.fr-marker)\\\");for(var g=0;g<e.length;g++)(0===e[g].attributes.length||\\\"undefined\\\"!=typeof e[g].getAttribute(\\\"href\\\"))&&(a(e[g]).remove(),f=!0);e=b.$el.get(0).querySelectorAll(\\\"*:empty:not(\\\"+d.join(\\\"):not(\\\")+\\\"):not(.fr-marker)\\\")}while(e.length&&f)}function h(d,e){var f=c();if(e&&(f='div class=\\\"fr-temp-div\\\"'),f)for(var g=b.node.contents(d.get(0)),h=null,i=0;i<g.length;i++){var j=g[i];if(j.nodeType==Node.ELEMENT_NODE&&(b.node.isBlock(j)||a(j).is(b.opts.htmlDoNotWrapTags.join(\\\",\\\"))&&!a(j).hasClass(\\\"fr-marker\\\")))h=null;else if(j.nodeType!=Node.ELEMENT_NODE&&j.nodeType!=Node.TEXT_NODE)h=null;else if(j.nodeType==Node.ELEMENT_NODE&&\\\"BR\\\"==j.tagName)if(null==h)e?a(j).replaceWith(\\\"<\\\"+f+' data-empty=\\\"true\\\"><br></div>'):a(j).replaceWith(\\\"<\\\"+f+\\\"><br></\\\"+f+\\\">\\\");else{a(j).remove();for(var k=b.node.contents(h),l=!1,m=0;m<k.length;m++)if(!a(k[m]).hasClass(\\\"fr-marker\\\")&&(k[m].nodeType!=Node.TEXT_NODE||0!==k[m].textContent.replace(/ /g,\\\"\\\").length)){l=!0;break}l===!1&&(h.append(\\\"<br>\\\"),h.data(\\\"empty\\\",!0)),h=null}else j.nodeType==Node.TEXT_NODE&&0==j.textContent.replace(/\\\\n/g,\\\"\\\").replace(/(^ *)|( *$)/g,\\\"\\\").length?a(j).remove():(null==h&&(h=a(\\\"<\\\"+f+\\\">\\\"),a(j).before(h)),j.nodeType==Node.TEXT_NODE&&a(j).text().trim().length>0?(h.append(a(j).clone()),a(j).remove()):h.append(a(j)))}}function i(c,d,e,f){return b.$wp?(\\\"undefined\\\"==typeof c&&(c=!1),\\\"undefined\\\"==typeof d&&(d=!1),\\\"undefined\\\"==typeof e&&(e=!1),\\\"undefined\\\"==typeof f&&(f=!1),h(b.$el,c),f&&b.$el.find(\\\".fr-inner\\\").each(function(){h(a(this),c)}),d&&b.$el.find(\\\"td, th\\\").each(function(){h(a(this),c)}),void(e&&b.$el.find(\\\"blockquote\\\").each(function(){h(a(this),c)}))):!1}function j(){b.$el.find(\\\"div.fr-temp-div\\\").each(function(){a(this).data(\\\"empty\\\")||\\\"LI\\\"==this.parentNode.tagName||b.node.isBlock(this.previousSibling)?a(this).replaceWith(a(this).html()):a(this).replaceWith(a(this).html()+\\\"<br>\\\")}),b.$el.find(\\\".fr-temp-div\\\").removeClass(\\\"fr-temp-div\\\").filter(function(){return\\\"\\\"==a(this).attr(\\\"class\\\")}).removeAttr(\\\"class\\\")}function k(){for(var c=d(),e=0;e<c.length;e++){var f=c[e];\\\"false\\\"==f.getAttribute(\\\"contenteditable\\\")||0!=f.querySelectorAll(b.opts.htmlAllowedEmptyTags.join(\\\":not(.fr-marker),\\\")+\\\":not(.fr-marker)\\\").length||b.node.isVoid(f)||\\\"TABLE\\\"!=f.tagName&&\\\"TBODY\\\"!=f.tagName&&\\\"TR\\\"!=f.tagName&&f.appendChild(b.doc.createElement(\\\"br\\\"))}if(b.browser.msie&&b.opts.enter==a.FE.ENTER_BR){var g=b.node.contents(b.$el.get(0));g.length&&g[g.length-1].nodeType==Node.TEXT_NODE&&b.$el.append(\\\"<br>\\\")}}function l(){return b.$el.find(f())}function m(a){if(\\\"undefined\\\"==typeof a&&(a=b.$el.get(0)),a&&[\\\"SCRIPT\\\",\\\"STYLE\\\",\\\"PRE\\\"].indexOf(a.tagName)>=0)return!1;for(var c=b.node.contents(a),d=c.length-1;d>=0;d--)if(c[d].nodeType==Node.TEXT_NODE){c[d].textContent=c[d].textContent.replace(/(?!^)( ){2,}(?!$)/g,\\\" \\\"),c[d].textContent=c[d].textContent.replace(/\\\\n/g,\\\" \\\"),c[d].textContent=c[d].textContent.replace(/^[ ]{2,}/g,\\\" \\\"),c[d].textContent=c[d].textContent.replace(/[ ]{2,}$/g,\\\" \\\"),(b.node.isBlock(a)||b.node.isElement(a))&&(c[d].previousSibling||(c[d].textContent=c[d].textContent.replace(/^ */,\\\"\\\")),c[d].nextSibling||(c[d].textContent=c[d].textContent.replace(/ *$/,\\\"\\\")),c[d].previousSibling&&c[d].nextSibling&&\\\" \\\"==c[d].textContent&&(c[d].previousSibling&&c[d].nextSibling&&b.node.isBlock(c[d].previousSibling)&&b.node.isBlock(c[d].nextSibling)?c[d].textContent=\\\"\\\":c[d].textContent=\\\"\\\\n\\\"))}else m(c[d])}function n(a){return a&&(b.node.isBlock(a)||[\\\"STYLE\\\",\\\"SCRIPT\\\",\\\"HEAD\\\",\\\"BR\\\",\\\"HR\\\"].indexOf(a.tagName)>=0||a.nodeType==Node.COMMENT_NODE)}function o(c){if(\\\"undefined\\\"==typeof c&&(c=b.$el.get(0)),c.nodeType==Node.ELEMENT_NODE&&[\\\"STYLE\\\",\\\"SCRIPT\\\",\\\"HEAD\\\"].indexOf(c.tagName)<0){for(var d=b.node.contents(c),e=d.length-1;e>=0;e--)if(!a(d[e]).hasClass(\\\"fr-marker\\\")){var f=o(d[e]);if(1==f)return!0}}else if(c.nodeType==Node.TEXT_NODE&&c.textContent.length>0){var g=c.previousSibling,h=c.nextSibling;if(n(g)&&n(h)&&0===c.textContent.trim().length)return!0;var i=c.textContent;i=i.replace(new RegExp(a.FE.UNICODE_NBSP,\\\"g\\\"),\\\" \\\");for(var j=\\\"\\\",k=0;k<i.length;k++)j+=32!=i.charCodeAt(k)||0!==k&&32!=j.charCodeAt(k-1)?i[k]:a.FE.UNICODE_NBSP;if(c.nextSibling||(j=j.replace(/ $/,a.FE.UNICODE_NBSP)),c.previousSibling&&!b.node.isVoid(c.previousSibling)&&(j=j.replace(/^\\\\u00A0([^ $])/,\\\" $1\\\")),j=j.replace(/([^ \\\\u00A0])\\\\u00A0([^ \\\\u00A0])/g,\\\"$1 $2\\\"),c.textContent!=j)return!0}return!1}function p(a,b,c){var d=new RegExp(b,\\\"gi\\\"),e=d.exec(a);return e?e[c]:null}function q(a,b){var c=a.match(/<!DOCTYPE ?([^ ]*) ?([^ ]*) ?\\\"?([^\\\"]*)\\\"? ?\\\"?([^\\\"]*)\\\"?>/i);return c?b.implementation.createDocumentType(c[1],c[3],c[4]):b.implementation.createDocumentType(\\\"html\\\")}function r(a){var b=a.doctype,c=\\\"<!DOCTYPE html>\\\";return b&&(c=\\\"<!DOCTYPE \\\"+b.name+(b.publicId?' PUBLIC \\\"'+b.publicId+'\\\"':\\\"\\\")+(!b.publicId&&b.systemId?\\\" SYSTEM\\\":\\\"\\\")+(b.systemId?' \\\"'+b.systemId+'\\\"':\\\"\\\")+\\\">\\\"),c}function s(){g(),i(),m(),b.spaces.normalize(null,!0),b.html.fillEmptyBlocks(),b.clean.quotes(),b.clean.lists(),b.clean.tables(),b.clean.toHTML5(),b.selection.restore(),t(),b.placeholder.refresh()}function t(){b.core.isEmpty()&&(null!=c()?0===b.$el.get(0).querySelectorAll(f()).length&&0===b.$el.get(0).querySelectorAll(b.opts.htmlDoNotWrapTags.join(\\\":not(.fr-marker),\\\")+\\\":not(.fr-marker)\\\").length&&(b.core.hasFocus()?(b.$el.html(\\\"<\\\"+c()+\\\">\\\"+a.FE.MARKERS+\\\"<br/></\\\"+c()+\\\">\\\"),b.selection.restore()):b.$el.html(\\\"<\\\"+c()+\\\"><br/></\\\"+c()+\\\">\\\")):0===b.$el.get(0).querySelectorAll(\\\"*:not(.fr-marker):not(br)\\\").length&&(b.core.hasFocus()?(b.$el.html(a.FE.MARKERS+\\\"<br/>\\\"),b.selection.restore()):b.$el.html(\\\"<br/>\\\")))}function u(a,b){return p(a,\\\"<\\\"+b+\\\"[^>]*?>([\\\\\\\\w\\\\\\\\W]*)</\\\"+b+\\\">\\\",1)}function v(c,d){var e=a(\\\"<div \\\"+(p(c,\\\"<\\\"+d+\\\"([^>]*?)>\\\",1)||\\\"\\\")+\\\">\\\");return b.node.rawAttributes(e.get(0))}function w(a){return p(a,\\\"<!DOCTYPE([^>]*?)>\\\",0)||\\\"<!DOCTYPE html>\\\"}function x(c){var d=b.clean.html(c||\\\"\\\",[],[],b.opts.fullPage);if(b.opts.fullPage){var e=u(d,\\\"body\\\")||(d.indexOf(\\\"<body\\\")>=0?\\\"\\\":d),f=v(d,\\\"body\\\"),g=u(d,\\\"head\\\")||\\\"<title></title>\\\",h=v(d,\\\"head\\\"),i=a(\\\"<div>\\\").append(g).contents().each(function(){(this.nodeType==Node.COMMENT_NODE||[\\\"BASE\\\",\\\"LINK\\\",\\\"META\\\",\\\"NOSCRIPT\\\",\\\"SCRIPT\\\",\\\"STYLE\\\",\\\"TEMPLATE\\\",\\\"TITLE\\\"].indexOf(this.tagName)>=0)&&this.parentNode.removeChild(this)}).end().html().trim();g=a(\\\"<div>\\\").append(g).contents().map(function(){return this.nodeType==Node.COMMENT_NODE?\\\"<!--\\\"+this.nodeValue+\\\"-->\\\":[\\\"BASE\\\",\\\"LINK\\\",\\\"META\\\",\\\"NOSCRIPT\\\",\\\"SCRIPT\\\",\\\"STYLE\\\",\\\"TEMPLATE\\\",\\\"TITLE\\\"].indexOf(this.tagName)>=0?this.outerHTML:\\\"\\\"}).toArray().join(\\\"\\\");var j=w(d),k=v(d,\\\"html\\\");b.$el.html(i+\\\"\\\\n\\\"+e),b.node.clearAttributes(b.$el.get(0)),b.$el.attr(f),b.$el.addClass(\\\"fr-view\\\"),b.$el.attr(\\\"spellcheck\\\",b.opts.spellcheck),b.$el.attr(\\\"dir\\\",b.opts.direction),b.$head.html(g),b.node.clearAttributes(b.$head.get(0)),b.$head.attr(h),b.node.clearAttributes(b.$html.get(0)),b.$html.attr(k),b.iframe_document.doctype.parentNode.replaceChild(q(j,b.iframe_document),b.iframe_document.doctype)}else b.$el.html(d);var l=b.edit.isDisabled();b.edit.on(),b.core.injectStyle(b.opts.iframeStyle),s(),b.opts.useClasses||(b.$el.find(\\\"[fr-original-class]\\\").each(function(){this.setAttribute(\\\"class\\\",this.getAttribute(\\\"fr-original-class\\\")),this.removeAttribute(\\\"fr-original-class\\\")}),b.$el.find(\\\"[fr-original-style]\\\").each(function(){this.setAttribute(\\\"style\\\",this.getAttribute(\\\"fr-original-style\\\")),this.removeAttribute(\\\"fr-original-style\\\")})),l&&b.edit.off(),b.events.trigger(\\\"html.set\\\")}function y(a,c){if(!b.$wp)return b.$oel.clone().removeClass(\\\"fr-view\\\").removeAttr(\\\"contenteditable\\\").get(0).outerHTML;var d=\\\"\\\";b.events.trigger(\\\"html.beforeGet\\\");var e,f=function(a){var b=/(#[^\\\\s\\\\+>~\\\\.\\\\[:]+)/g,c=/(\\\\[[^\\\\]]+\\\\])/g,d=/(\\\\.[^\\\\s\\\\+>~\\\\.\\\\[:]+)/g,e=/(::[^\\\\s\\\\+>~\\\\.\\\\[:]+|:first-line|:first-letter|:before|:after)/gi,f=/(:[\\\\w-]+\\\\([^\\\\)]*\\\\))/gi,g=/(:[^\\\\s\\\\+>~\\\\.\\\\[:]+)/g,h=/([^\\\\s\\\\+>~\\\\.\\\\[:]+)/g;!function(){var b=/:not\\\\(([^\\\\)]*)\\\\)/g;b.test(a)&&(a=a.replace(b,\\\"     $1 \\\"))}();var i=100*(a.match(b)||[]).length+10*(a.match(c)||[]).length+10*(a.match(d)||[]).length+10*(a.match(f)||[]).length+10*(a.match(g)||[]).length+(a.match(e)||[]).length;return a=a.replace(/[\\\\*\\\\s\\\\+>~]/g,\\\" \\\"),a=a.replace(/[#\\\\.]/g,\\\" \\\"),i+=(a.match(h)||[]).length},g=[],h={};if(!b.opts.useClasses&&!c){var i=new RegExp(\\\"^\\\"+b.opts.htmlIgnoreCSSProperties.join(\\\"$|^\\\")+\\\"$\\\",\\\"gi\\\");for(e=0;e<b.doc.styleSheets.length;e++){var j,k=0;try{j=b.doc.styleSheets[e].cssRules,b.doc.styleSheets[e].ownerNode&&\\\"STYLE\\\"==b.doc.styleSheets[e].ownerNode.nodeType&&(k=1)}catch(l){}if(j)for(var m=0,n=j.length;n>m;m++)if(j[m].selectorText&&j[m].style.cssText.length>0){var o,p=j[m].selectorText.replace(/body |\\\\.fr-view /g,\\\"\\\").replace(/::/g,\\\":\\\");try{o=b.$el.get(0).querySelectorAll(p)}catch(l){o=[]}for(var q=0;q<o.length;q++){!o[q].getAttribute(\\\"fr-original-style\\\")&&o[q].getAttribute(\\\"style\\\")?(o[q].setAttribute(\\\"fr-original-style\\\",o[q].getAttribute(\\\"style\\\")),g.push(o[q])):o[q].getAttribute(\\\"fr-original-style\\\")||g.push(o[q]),h[o[q]]||(h[o[q]]={});for(var s=1e3*k+f(j[m].selectorText),t=j[m].style.cssText.split(\\\";\\\"),u=0;u<t.length;u++){var v=t[u].trim().split(\\\":\\\")[0];v.match(i)||(h[o[q]][v]||(h[o[q]][v]=0,(o[q].getAttribute(\\\"fr-original-style\\\")||\\\"\\\").indexOf(v+\\\":\\\")>=0&&(h[o[q]][v]=1e4)),s>=h[o[q]][v]&&(h[o[q]][v]=s,t[u].trim().length&&(o[q].style[v.trim()]=t[u].trim().split(\\\":\\\")[1].trim())))}}}}for(e=0;e<g.length;e++)if(g[e].getAttribute(\\\"class\\\")&&(g[e].setAttribute(\\\"fr-original-class\\\",g[e].getAttribute(\\\"class\\\")),g[e].removeAttribute(\\\"class\\\")),(g[e].getAttribute(\\\"fr-original-style\\\")||\\\"\\\").trim().length>0)for(var w=g[e].getAttribute(\\\"fr-original-style\\\").split(\\\";\\\"),q=0;q<w.length;q++)w[q].indexOf(\\\":\\\")>0&&(g[e].style[w[q].split(\\\":\\\")[0].trim()]=w[q].split(\\\":\\\")[1].trim())}if(b.core.isEmpty()?b.opts.fullPage&&(d=r(b.iframe_document),d+=\\\"<html\\\"+b.node.attributes(b.$html.get(0))+\\\">\\\"+b.$html.find(\\\"head\\\").get(0).outerHTML+\\\"<body></body></html>\\\"):(\\\"undefined\\\"==typeof a&&(a=!1),b.opts.fullPage?(d=r(b.iframe_document),b.$el.removeClass(\\\"fr-view\\\"),d+=\\\"<html\\\"+b.node.attributes(b.$html.get(0))+\\\">\\\"+b.$html.html()+\\\"</html>\\\",b.$el.addClass(\\\"fr-view\\\")):d=b.$el.html()),!b.opts.useClasses&&!c)for(e=0;e<g.length;e++)g[e].getAttribute(\\\"fr-original-class\\\")&&(g[e].setAttribute(\\\"class\\\",g[e].getAttribute(\\\"fr-original-class\\\")),g[e].removeAttribute(\\\"fr-original-class\\\")),g[e].getAttribute(\\\"fr-original-style\\\")?(g[e].setAttribute(\\\"style\\\",g[e].getAttribute(\\\"fr-original-style\\\")),g[e].removeAttribute(\\\"fr-original-style\\\")):g[e].removeAttribute(\\\"style\\\");b.opts.fullPage&&(d=d.replace(/<style data-fr-style=\\\"true\\\">(?:[\\\\w\\\\W]*?)<\\\\/style>/g,\\\"\\\"),d=d.replace(/<link([^>]*)data-fr-style=\\\"true\\\"([^>]*)>/g,\\\"\\\"),d=d.replace(/<style(?:[\\\\w\\\\W]*?)class=\\\"firebugResetStyles\\\"(?:[\\\\w\\\\W]*?)>(?:[\\\\w\\\\W]*?)<\\\\/style>/g,\\\"\\\"),d=d.replace(/<body((?:[\\\\w\\\\W]*?)) spellcheck=\\\"true\\\"((?:[\\\\w\\\\W]*?))>((?:[\\\\w\\\\W]*?))<\\\\/body>/g,\\\"<body$1$2>$3</body>\\\"),d=d.replace(/<body((?:[\\\\w\\\\W]*?)) contenteditable=\\\"(true|false)\\\"((?:[\\\\w\\\\W]*?))>((?:[\\\\w\\\\W]*?))<\\\\/body>/g,\\\"<body$1$3>$4</body>\\\"),d=d.replace(/<body((?:[\\\\w\\\\W]*?)) dir=\\\"([\\\\w]*)\\\"((?:[\\\\w\\\\W]*?))>((?:[\\\\w\\\\W]*?))<\\\\/body>/g,\\\"<body$1$3>$4</body>\\\"),d=d.replace(/<body((?:[\\\\w\\\\W]*?))class=\\\"([\\\\w\\\\W]*?)(fr-rtl|fr-ltr)([\\\\w\\\\W]*?)\\\"((?:[\\\\w\\\\W]*?))>((?:[\\\\w\\\\W]*?))<\\\\/body>/g,'<body$1class=\\\"$2$4\\\"$5>$6</body>'),d=d.replace(/<body((?:[\\\\w\\\\W]*?)) class=\\\"\\\"((?:[\\\\w\\\\W]*?))>((?:[\\\\w\\\\W]*?))<\\\\/body>/g,\\\"<body$1$2>$3</body>\\\")),b.opts.htmlSimpleAmpersand&&(d=d.replace(/\\\\&amp;/gi,\\\"&\\\")),b.events.trigger(\\\"html.afterGet\\\"),a||(d=d.replace(/<span[^>]*? class\\\\s*=\\\\s*[\\\"']?fr-marker[\\\"']?[^>]+>\\\\u200b<\\\\/span>/gi,\\\"\\\")),d=b.clean.invisibleSpaces(d);var x=b.events.chainTrigger(\\\"html.get\\\",d);return\\\"string\\\"==typeof x&&(d=x),d=d.replace(/<pre(?:[\\\\w\\\\W]*?)>(?:[\\\\w\\\\W]*?)<\\\\/pre>/g,function(a){return a.replace(/<br>/g,\\\"\\\\n\\\")})}function z(){var c=function(c,d){for(;d&&(d.nodeType==Node.TEXT_NODE||!b.node.isBlock(d))&&!b.node.isElement(d);)d&&d.nodeType!=Node.TEXT_NODE&&a(c).wrapInner(b.node.openTagString(d)+b.node.closeTagString(d)),d=d.parentNode;d&&c.innerHTML==d.innerHTML&&(c.innerHTML=d.outerHTML)},d=function(){var c,d=null;return b.win.getSelection?(c=b.win.getSelection(),c&&c.rangeCount&&(d=c.getRangeAt(0).commonAncestorContainer,d.nodeType!=Node.ELEMENT_NODE&&(d=d.parentNode))):(c=b.doc.selection)&&\\\"Control\\\"!=c.type&&(d=c.createRange().parentElement()),null!=d&&(a.inArray(b.$el.get(0),a(d).parents())>=0||d==b.$el.get(0))?d:null},e=\\\"\\\";if(\\\"undefined\\\"!=typeof b.win.getSelection){b.browser.mozilla&&(b.selection.save(),b.$el.find('.fr-marker[data-type=\\\"false\\\"]').length>1&&(b.$el.find('.fr-marker[data-type=\\\"false\\\"][data-id=\\\"0\\\"]').remove(),b.$el.find('.fr-marker[data-type=\\\"false\\\"]:last').attr(\\\"data-id\\\",\\\"0\\\"),b.$el.find(\\\".fr-marker\\\").not('[data-id=\\\"0\\\"]').remove()),b.selection.restore());for(var f=b.selection.ranges(),g=0;g<f.length;g++){var h=document.createElement(\\\"div\\\");h.appendChild(f[g].cloneContents()),c(h,d()),a(h).find(\\\".fr-element\\\").length>0&&(h=b.$el.get(0)),e+=h.innerHTML}}else\\\"undefined\\\"!=typeof b.doc.selection&&\\\"Text\\\"==b.doc.selection.type&&(e=b.doc.selection.createRange().htmlText);return e}function A(b){var c=a(\\\"<div>\\\").html(b);return c.find(f()).length>0}function B(a){var c=b.doc.createElement(\\\"div\\\");return c.innerHTML=a,b.selection.setAtEnd(c),c.innerHTML}function C(a){return a.replace(/</gi,\\\"&lt;\\\").replace(/>/gi,\\\"&gt;\\\").replace(/\\\"/gi,\\\"&quot;\\\").replace(/'/gi,\\\"&#39;\\\")}function D(c,d,e){b.selection.isCollapsed()||b.selection.remove();var f;if(f=d?c:b.clean.html(c),f=f.replace(/\\\\r|\\\\n/g,\\\" \\\"),c.indexOf('class=\\\"fr-marker\\\"')<0&&(f=B(f)),\\nb.core.isEmpty())b.$el.html(f);else{var g=b.markers.insert();if(g){var h;if((A(f)||e)&&(h=b.node.deepestParent(g))){var g=b.markers.split();if(!g)return!1;a(g).replaceWith(f)}else a(g).replaceWith(f)}else b.$el.append(f)}s(),b.events.trigger(\\\"html.inserted\\\")}function E(c){var d=null;\\\"undefined\\\"==typeof c&&(d=b.selection.element());var e,f;do{f=!1,e=b.$el.get(0).querySelectorAll(\\\"*:not(.fr-marker)\\\");for(var g=0;g<e.length;g++){var h=e[g];if(d!=h){var i=h.textContent;0===h.children.length&&1===i.length&&8203==i.charCodeAt(0)&&(a(h).remove(),f=!0)}}}while(f)}function F(){var a=function(){E(),b.placeholder&&b.placeholder.refresh()};b.events.on(\\\"mouseup\\\",a),b.events.on(\\\"keydown\\\",a),b.events.on(\\\"contentChanged\\\",t)}return{defaultTag:c,emptyBlocks:d,emptyBlockTagsQuery:e,blockTagsQuery:f,fillEmptyBlocks:k,cleanEmptyTags:g,cleanWhiteTags:E,doNormalize:o,cleanBlankSpaces:m,blocks:l,getDoctype:r,set:x,get:y,getSelected:z,insert:D,wrap:i,unwrap:j,escapeEntities:C,checkIfEmpty:t,extractNode:u,extractNodeAttrs:v,extractDoctype:w,_init:F}},a.extend(a.FE.DEFAULTS,{height:null,heightMax:null,heightMin:null,width:null}),a.FE.MODULES.size=function(a){function b(){c(),a.opts.height&&a.$el.css(\\\"minHeight\\\",a.opts.height-a.helpers.getPX(a.$el.css(\\\"padding-top\\\"))-a.helpers.getPX(a.$el.css(\\\"padding-bottom\\\"))),a.$iframe.height(a.$el.outerHeight(!0))}function c(){a.opts.heightMin?a.$el.css(\\\"minHeight\\\",a.opts.heightMin):a.$el.css(\\\"minHeight\\\",\\\"\\\"),a.opts.heightMax?(a.$wp.css(\\\"maxHeight\\\",a.opts.heightMax),a.$wp.css(\\\"overflow\\\",\\\"auto\\\")):(a.$wp.css(\\\"maxHeight\\\",\\\"\\\"),a.$wp.css(\\\"overflow\\\",\\\"\\\")),a.opts.height?(a.$wp.height(a.opts.height),a.$el.css(\\\"minHeight\\\",a.opts.height-a.helpers.getPX(a.$el.css(\\\"padding-top\\\"))-a.helpers.getPX(a.$el.css(\\\"padding-bottom\\\"))),a.$wp.css(\\\"overflow\\\",\\\"auto\\\")):(a.$wp.css(\\\"height\\\",\\\"\\\"),a.opts.heightMin||a.$el.css(\\\"minHeight\\\",\\\"\\\"),a.opts.heightMax||a.$wp.css(\\\"overflow\\\",\\\"\\\")),a.opts.width&&a.$box.width(a.opts.width)}function d(){return a.$wp?(c(),void(a.$iframe&&(a.events.on(\\\"keyup\\\",b),a.events.on(\\\"commands.after\\\",b),a.events.on(\\\"html.set\\\",b),a.events.on(\\\"init\\\",b),a.events.on(\\\"initialized\\\",b)))):!1}return{_init:d,syncIframe:b,refresh:c}},a.extend(a.FE.DEFAULTS,{language:null}),a.FE.LANGUAGE={},a.FE.MODULES.language=function(b){function c(a){return e&&e.translation[a]?e.translation[a]:a}function d(){a.FE.LANGUAGE&&(e=a.FE.LANGUAGE[b.opts.language]),e&&e.direction&&(b.opts.direction=e.direction)}var e;return{_init:d,translate:c}},a.extend(a.FE.DEFAULTS,{placeholderText:\\\"Type something\\\"}),a.FE.MODULES.placeholder=function(b){function c(){b.$placeholder||g();var c=0,d=0,e=0,f=0,h=b.node.contents(b.$el.get(0));if(h.length&&h[0].nodeType==Node.ELEMENT_NODE){var i=a(h[0]);b.opts.toolbarInline||(c=b.helpers.getPX(i.css(\\\"margin-top\\\")),e=b.helpers.getPX(i.css(\\\"padding-top\\\")),d=b.helpers.getPX(i.css(\\\"margin-left\\\")),f=b.helpers.getPX(i.css(\\\"padding-left\\\"))),b.$placeholder.css(\\\"font-size\\\",i.css(\\\"font-size\\\")),b.$placeholder.css(\\\"line-height\\\",i.css(\\\"line-height\\\"))}else b.$placeholder.css(\\\"font-size\\\",b.$el.css(\\\"font-size\\\")),b.$placeholder.css(\\\"line-height\\\",b.$el.css(\\\"line-height\\\"));b.$wp.addClass(\\\"show-placeholder\\\"),b.$placeholder.css({marginTop:Math.max(b.helpers.getPX(b.$el.css(\\\"margin-top\\\")),c),paddingTop:Math.max(b.helpers.getPX(b.$el.css(\\\"padding-top\\\")),e),paddingLeft:Math.max(b.helpers.getPX(b.$el.css(\\\"padding-left\\\")),f),marginLeft:Math.max(b.helpers.getPX(b.$el.css(\\\"margin-left\\\")),d)}).text(b.language.translate(b.opts.placeholderText||b.$oel.attr(\\\"placeholder\\\")||\\\"\\\")),b.$placeholder.html(b.$placeholder.text().replace(/\\\\n/g,\\\"<br>\\\"))}function d(){b.$wp.removeClass(\\\"show-placeholder\\\")}function e(){return b.$wp?b.$wp.hasClass(\\\"show-placeholder\\\"):!0}function f(){return b.$wp?void(b.core.isEmpty()?c():d()):!1}function g(){b.$placeholder=a('<span class=\\\"fr-placeholder\\\"></span>'),b.$wp.append(b.$placeholder)}function h(){return b.$wp?void b.events.on(\\\"init input keydown keyup contentChanged initialized\\\",f):!1}return{_init:h,show:c,hide:d,refresh:f,isVisible:e}},a.FE.MODULES.edit=function(a){function b(){if(a.browser.mozilla)try{a.doc.execCommand(\\\"enableObjectResizing\\\",!1,\\\"false\\\"),a.doc.execCommand(\\\"enableInlineTableEditing\\\",!1,\\\"false\\\")}catch(b){}if(a.browser.msie)try{a.doc.body.addEventListener(\\\"mscontrolselect\\\",function(a){return a.preventDefault(),!1})}catch(b){}}function c(){a.$wp?(a.$el.attr(\\\"contenteditable\\\",!0),a.$el.removeClass(\\\"fr-disabled\\\"),a.$tb&&a.$tb.removeClass(\\\"fr-disabled\\\"),b()):a.$el.is(\\\"a\\\")&&a.$el.attr(\\\"contenteditable\\\",!0),f=!1}function d(){a.$wp?(a.$el.attr(\\\"contenteditable\\\",!1),a.$el.addClass(\\\"fr-disabled\\\"),a.$tb&&a.$tb.addClass(\\\"fr-disabled\\\")):a.$el.is(\\\"a\\\")&&a.$el.attr(\\\"contenteditable\\\",!1),f=!0}function e(){return f}var f=!1;return{on:c,off:d,disableDesign:b,isDisabled:e}},a.extend(a.FE.DEFAULTS,{editorClass:null,typingTimer:500,iframe:!1,requestWithCORS:!0,requestWithCredentials:!1,requestHeaders:{},useClasses:!0,spellcheck:!0,iframeStyle:'html{margin:0px;height:auto;}body{height:auto;padding:10px;background:transparent;color:#000000;position:relative;z-index: 2;-webkit-user-select:auto;margin:0px;overflow:hidden;min-height:20px;}body:after{content:\\\"\\\";display:block;clear:both;}',iframeStyleFiles:[],direction:\\\"auto\\\",zIndex:1,disableRightClick:!1,scrollableContainer:\\\"body\\\",keepFormatOnDelete:!1,theme:null}),a.FE.MODULES.core=function(b){function c(c){if(b.opts.iframe){b.$head.find(\\\"style[data-fr-style], link[data-fr-style]\\\").remove(),b.$head.append('<style data-fr-style=\\\"true\\\">'+c+\\\"</style>\\\");for(var d=0;d<b.opts.iframeStyleFiles.length;d++){var e=a('<link data-fr-style=\\\"true\\\" rel=\\\"stylesheet\\\" href=\\\"'+b.opts.iframeStyleFiles[d]+'\\\">');e.get(0).addEventListener(\\\"load\\\",b.size.syncIframe),b.$head.append(e)}}}function d(){b.opts.iframe||b.$el.addClass(\\\"fr-element fr-view\\\")}function e(){if(b.$box.addClass(\\\"fr-box\\\"+(b.opts.editorClass?\\\" \\\"+b.opts.editorClass:\\\"\\\")),b.$wp.addClass(\\\"fr-wrapper\\\"),d(),b.opts.iframe){b.$iframe.addClass(\\\"fr-iframe\\\"),b.$el.addClass(\\\"fr-view\\\");for(var a=0;a<b.o_doc.styleSheets.length;a++){var c;try{c=b.o_doc.styleSheets[a].cssRules}catch(e){}if(c)for(var f=0,g=c.length;g>f;f++)!c[f].selectorText||0!==c[f].selectorText.indexOf(\\\".fr-view\\\")&&0!==c[f].selectorText.indexOf(\\\".fr-element\\\")||c[f].style.cssText.length>0&&(0===c[f].selectorText.indexOf(\\\".fr-view\\\")?b.opts.iframeStyle+=c[f].selectorText.replace(/\\\\.fr-view/g,\\\"body\\\")+\\\"{\\\"+c[f].style.cssText+\\\"}\\\":b.opts.iframeStyle+=c[f].selectorText.replace(/\\\\.fr-element/g,\\\"body\\\")+\\\"{\\\"+c[f].style.cssText+\\\"}\\\")}}\\\"auto\\\"!=b.opts.direction&&b.$box.removeClass(\\\"fr-ltr fr-rtl\\\").addClass(\\\"fr-\\\"+b.opts.direction),b.$el.attr(\\\"dir\\\",b.opts.direction),b.$wp.attr(\\\"dir\\\",b.opts.direction),b.opts.zIndex>1&&b.$box.css(\\\"z-index\\\",b.opts.zIndex),b.opts.theme&&b.$box.addClass(b.opts.theme+\\\"-theme\\\")}function f(){return b.node.isEmpty(b.$el.get(0))}function g(){b.drag_support={filereader:\\\"undefined\\\"!=typeof FileReader,formdata:!!b.win.FormData,progress:\\\"upload\\\"in new XMLHttpRequest}}function h(a,c){var d=new XMLHttpRequest;d.open(c,a,!0),b.opts.requestWithCredentials&&(d.withCredentials=!0);for(var e in b.opts.requestHeaders)b.opts.requestHeaders.hasOwnProperty(e)&&d.setRequestHeader(e,b.opts.requestHeaders[e]);return d}function i(a){\\\"TEXTAREA\\\"==b.$oel.get(0).tagName&&b.$oel.val(a),b.$wp&&(\\\"TEXTAREA\\\"==b.$oel.get(0).tagName?(b.$el.html(\\\"\\\"),b.$wp.html(\\\"\\\"),b.$box.replaceWith(b.$oel),b.$oel.show()):(b.$wp.replaceWith(a),b.$el.html(\\\"\\\"),b.$box.removeClass(\\\"fr-view fr-ltr fr-box \\\"+(b.opts.editorClass||\\\"\\\")),b.opts.theme&&b.$box.addClass(b.opts.theme+\\\"-theme\\\"))),this.$wp=null,this.$el=null,this.$box=null}function j(){return b.browser.mozilla&&b.helpers.isMobile()?b.selection.inEditor():b.node.hasFocus(b.$el.get(0))||b.$el.find(\\\"*:focus\\\").length>0}function k(a){if(!a)return!1;var c=a.data(\\\"instance\\\");return c?c.id==b.id:!1}function l(){if(a.FE.INSTANCES.push(b),g(),b.$wp){e(),b.html.set(b._original_html),b.$el.attr(\\\"spellcheck\\\",b.opts.spellcheck),b.helpers.isMobile()&&(b.$el.attr(\\\"autocomplete\\\",b.opts.spellcheck?\\\"on\\\":\\\"off\\\"),b.$el.attr(\\\"autocorrect\\\",b.opts.spellcheck?\\\"on\\\":\\\"off\\\"),b.$el.attr(\\\"autocapitalize\\\",b.opts.spellcheck?\\\"on\\\":\\\"off\\\")),b.opts.disableRightClick&&b.events.$on(b.$el,\\\"contextmenu\\\",function(a){return 2==a.button?!1:void 0});try{b.doc.execCommand(\\\"styleWithCSS\\\",!1,!1)}catch(c){}}b.events.on(\\\"drop\\\",function(a){a.preventDefault(),a.stopPropagation()}),\\\"TEXTAREA\\\"==b.$oel.get(0).tagName&&(b.events.on(\\\"contentChanged\\\",function(){b.$oel.val(b.html.get())}),b.events.on(\\\"form.submit\\\",function(){b.$oel.val(b.html.get())}),b.events.on(\\\"form.reset\\\",function(){b.html.set(b._original_html)}),b.$oel.val(b.html.get())),b.helpers.isIOS()&&b.events.$on(b.$doc,\\\"selectionchange\\\",function(){b.$doc.get(0).hasFocus()||b.$win.get(0).focus()}),b.events.trigger(\\\"init\\\")}return{_init:l,destroy:i,isEmpty:f,getXHR:h,injectStyle:c,hasFocus:j,sameInstance:k}},a.FE.MODULES.format=function(b){function c(a,b){var c=\\\"<\\\"+a;for(var d in b)b.hasOwnProperty(d)&&(c+=\\\" \\\"+d+'=\\\"'+b[d]+'\\\"');return c+=\\\">\\\"}function d(a){return\\\"</\\\"+a+\\\">\\\"}function e(a,b){var c=a;for(var d in b)b.hasOwnProperty(d)&&(a+=\\\"id\\\"==d?\\\"#\\\"+b[d]:\\\"class\\\"==d?\\\".\\\"+b[d]:\\\"[\\\"+d+'=\\\"'+b[d]+'\\\"]');return c}function f(a,b){return a&&a.nodeType==Node.ELEMENT_NODE?(a.matches||a.matchesSelector||a.msMatchesSelector||a.mozMatchesSelector||a.webkitMatchesSelector||a.oMatchesSelector).call(a,b):!1}function g(d,e,f){if(d){if(b.node.isBlock(d))return g(d.firstChild,e,f),!1;for(var h=a(c(e,f)).insertBefore(d),i=d;i&&!a(i).is(\\\".fr-marker\\\")&&0==a(i).find(\\\".fr-marker\\\").length;){var j=i;i=i.nextSibling,h.append(j)}if(i)a(i).find(\\\".fr-marker\\\").length&&g(i.firstChild,e,f);else{for(var k=h.get(0).parentNode;k&&!k.nextSibling&&!b.node.isElement(k);)k=k.parentNode;if(k){var l=k.nextSibling;l&&(b.node.isBlock(l)?g(l.firstChild,e,f):g(l,e,f))}}h.is(\\\":empty\\\")&&h.remove()}}function h(h,i){if(\\\"undefined\\\"==typeof i&&(i={}),i.style&&delete i.style,b.selection.isCollapsed()){b.markers.insert();var j=b.$el.find(\\\".fr-marker\\\");j.replaceWith(c(h,i)+a.FE.INVISIBLE_SPACE+a.FE.MARKERS+d(h)),b.selection.restore()}else{b.selection.save();var k=b.$el.find('.fr-marker[data-type=\\\"true\\\"]').get(0).nextSibling;g(k,h,i);var l;do l=b.$el.find(e(h,i)+\\\" > \\\"+e(h,i)),l.each(function(){a(this).replaceWith(this.innerHTML)});while(l.length);b.$el.get(0).normalize();for(var m=b.$el.get(0).querySelectorAll(\\\".fr-marker\\\"),n=0;n<m.length;n++){var o=a(m[n]);1==o.data(\\\"type\\\")?f(o.get(0).nextSibling,e(h,i))&&o.next().prepend(o):f(o.get(0).previousSibling,e(h,i))&&o.prev().append(o)}b.selection.restore()}}function i(a,c,d,g){if(!g){var h=!1;if(a.data(\\\"type\\\")===!0)for(;b.node.isFirstSibling(a.get(0))&&!a.parent().is(b.$el);)a.parent().before(a),h=!0;else if(a.data(\\\"type\\\")===!1)for(;b.node.isLastSibling(a.get(0))&&!a.parent().is(b.$el);)a.parent().after(a),h=!0;if(h)return!0}if(a.parents(c).length||\\\"undefined\\\"==typeof c){var i=\\\"\\\",j=\\\"\\\",k=a.parent();if(k.is(b.$el)||b.node.isBlock(k.get(0)))return!1;for(;\\\"undefined\\\"==typeof c&&!b.node.isBlock(k.parent().get(0))||\\\"undefined\\\"!=typeof c&&!f(k.get(0),e(c,d));)i+=b.node.closeTagString(k.get(0)),j=b.node.openTagString(k.get(0))+j,k=k.parent();var l=a.get(0).outerHTML;a.replaceWith('<span id=\\\"mark\\\"></span>');var m=k.html().replace(/<span id=\\\"mark\\\"><\\\\/span>/,i+b.node.closeTagString(k.get(0))+j+l+i+b.node.openTagString(k.get(0))+j);return k.replaceWith(b.node.openTagString(k.get(0))+m+b.node.closeTagString(k.get(0))),!0}return!1}function j(c,d,g,h){for(var i=b.node.contents(c.get(0)),k=0;k<i.length;k++){var l=i[k];a(l).hasClass(\\\"fr-marker\\\")?d=(d+1)%2:d?a(l).find(\\\".fr-marker\\\").length>0?d=j(a(l),d,g,h):(a(a(l).find(g||\\\"*\\\").get().reverse()).each(function(){b.node.isBlock(this)||b.node.isVoid(this)||a(this).replaceWith(this.innerHTML)}),(\\\"undefined\\\"==typeof g&&l.nodeType==Node.ELEMENT_NODE&&!b.node.isVoid(l)&&!b.node.isBlock(l)||f(l,e(g,h)))&&a(l).replaceWith(l.innerHTML)):a(l).find(\\\".fr-marker\\\").length>0&&(d=j(a(l),d,g,h))}return d}function k(c,d){\\\"undefined\\\"==typeof d&&(d={}),d.style&&delete d.style;var e=b.selection.isCollapsed();b.selection.save();for(var f=!0;f;){f=!1;for(var g=b.$el.find(\\\".fr-marker\\\"),h=0;h<g.length;h++)if(i(a(g[h]),c,d,e)){f=!0;break}}j(b.$el,0,c,d),e&&b.$el.find(\\\".fr-marker\\\").before(a.FE.INVISIBLE_SPACE).after(a.FE.INVISIBLE_SPACE),b.html.cleanEmptyTags(),b.$el.get(0).normalize(),b.selection.restore()}function l(a,b){q(a,b)?k(a,b):h(a,b)}function m(b,c){var d=a(b);d.css(c,\\\"\\\"),\\\"\\\"===d.attr(\\\"style\\\")&&d.replaceWith(d.html())}function n(b,c){return 0===a(b).attr(\\\"style\\\").indexOf(c+\\\":\\\")||a(b).attr(\\\"style\\\").indexOf(\\\";\\\"+c+\\\":\\\")>=0||a(b).attr(\\\"style\\\").indexOf(\\\"; \\\"+c+\\\":\\\")>=0}function o(c,d){if(b.selection.isCollapsed()){b.markers.insert();var e=b.$el.find(\\\".fr-marker\\\"),f=e.parent();if(b.node.openTagString(f.get(0))=='<span style=\\\"'+c+\\\": \\\"+f.css(c)+';\\\">')if(b.node.isEmpty(f.get(0)))f.replaceWith('<span style=\\\"'+c+\\\": \\\"+d+';\\\">'+a.FE.INVISIBLE_SPACE+a.FE.MARKERS+\\\"</span>\\\");else{var h={};h[c]=d,i(e,\\\"span\\\",h,!0),e=b.$el.find(\\\".fr-marker\\\"),e.replaceWith('<span style=\\\"'+c+\\\": \\\"+d+';\\\">'+a.FE.INVISIBLE_SPACE+a.FE.MARKERS+\\\"</span>\\\")}else b.node.isEmpty(f.get(0))&&f.is(\\\"span\\\")?(e.replaceWith(a.FE.MARKERS),f.css(c,d)):e.replaceWith('<span style=\\\"'+c+\\\": \\\"+d+';\\\">'+a.FE.INVISIBLE_SPACE+a.FE.MARKERS+\\\"</span>\\\");b.selection.restore()}else{b.selection.save();for(var j=b.$el.find(\\\".fr-marker\\\"),k=0;k<j.length;k++){var e=a(j[k]);if(e.data(\\\"type\\\")===!0)for(;b.node.isFirstSibling(e.get(0))&&!e.parent().is(b.$el);)e.parent().before(e);else for(;b.node.isLastSibling(e.get(0))&&!e.parent().is(b.$el);)e.parent().after(e)}var l=b.$el.find('.fr-marker[data-type=\\\"true\\\"]').get(0).nextSibling,o={\\\"class\\\":\\\"fr-unprocessed\\\"};for(d&&(o.style=c+\\\": \\\"+d+\\\";\\\"),g(l,\\\"span\\\",o),b.$el.find(\\\".fr-marker + .fr-unprocessed\\\").each(function(){a(this).prepend(a(this).prev())}),b.$el.find(\\\".fr-unprocessed + .fr-marker\\\").each(function(){a(this).prev().append(this)});b.$el.find(\\\"span.fr-unprocessed\\\").length>0;){var p=b.$el.find(\\\"span.fr-unprocessed:first\\\").removeClass(\\\"fr-unprocessed\\\");if(p.parent().get(0).normalize(),p.parent().is(\\\"span\\\")&&1==p.parent().get(0).childNodes.length){p.parent().css(c,d);var q=p;p=p.parent(),q.replaceWith(q.html())}for(var r=p.find(\\\"span\\\"),k=r.length-1;k>=0;k--)m(r[k],c);var s=p.parentsUntil(b.$el,\\\"span[style]\\\").filter(function(){return n(this,c)});if(s.length){var t=\\\"\\\",u=\\\"\\\",v=\\\"\\\",w=\\\"\\\",x=p.get(0);do x=x.parentNode,a(x).addClass(\\\"fr-split\\\"),t+=b.node.closeTagString(x),u=b.node.openTagString(a(x).clone().addClass(\\\"fr-split\\\").get(0))+u,s.get(0)!=x&&(v+=b.node.closeTagString(x),w=b.node.openTagString(a(x).clone().addClass(\\\"fr-split\\\").get(0))+w);while(s.get(0)!=x);var y=t+b.node.openTagString(a(s.get(0)).clone().css(c,d||\\\"\\\").get(0))+w+p.css(c,\\\"\\\").get(0).outerHTML+v+\\\"</span>\\\"+u;p.replaceWith('<span id=\\\"fr-break\\\"></span>');var z=s.get(0).outerHTML;a(s.get(0)).replaceWith(z.replace(/<span id=\\\"fr-break\\\"><\\\\/span>/g,y))}}for(;b.$el.find(\\\".fr-split:empty\\\").length>0;)b.$el.find(\\\".fr-split:empty\\\").remove();b.$el.find(\\\".fr-split\\\").removeClass(\\\"fr-split\\\"),b.$el.find('span[style=\\\"\\\"]').removeAttr(\\\"style\\\"),b.$el.find('span[class=\\\"\\\"]').removeAttr(\\\"class\\\"),b.html.cleanEmptyTags(),a(b.$el.find(\\\"span\\\").get().reverse()).each(function(){this.attributes&&0!=this.attributes.length||a(this).replaceWith(this.innerHTML)}),b.$el.get(0).normalize();var A=b.$el.find(\\\"span[style] + span[style]\\\");for(k=0;k<A.length;k++){var B=a(A[k]),C=a(A[k]).prev();B.get(0).previousSibling==C.get(0)&&b.node.openTagString(B.get(0))==b.node.openTagString(C.get(0))&&(B.prepend(C.html()),C.remove())}b.$el.get(0).normalize(),b.selection.restore()}}function p(a){o(a,null)}function q(a,c){\\\"undefined\\\"==typeof c&&(c={}),c.style&&delete c.style;var d=b.selection.ranges(0),g=d.startContainer;g.nodeType==Node.ELEMENT_NODE&&g.childNodes.length>0&&g.childNodes[d.startOffset]&&(g=g.childNodes[d.startOffset]);for(var h=g;h&&h.nodeType==Node.ELEMENT_NODE&&!f(h,e(a,c));)h=h.firstChild;if(h&&h.nodeType==Node.ELEMENT_NODE&&f(h,e(a,c)))return!0;var i=g;for(i&&i.nodeType!=Node.ELEMENT_NODE&&(i=i.parentNode);i&&i.nodeType==Node.ELEMENT_NODE&&i!=b.$el.get(0)&&!f(i,e(a,c));)i=i.parentNode;return i&&i.nodeType==Node.ELEMENT_NODE&&i!=b.$el.get(0)&&f(i,e(a,c))?!0:!1}return{is:q,toggle:l,apply:h,remove:k,applyStyle:o,removeStyle:p}},a.FE.COMMANDS={bold:{title:\\\"Bold\\\",refresh:function(a){a.toggleClass(\\\"fr-active\\\",this.format.is(\\\"strong\\\"))}},italic:{title:\\\"Italic\\\",refresh:function(a){a.toggleClass(\\\"fr-active\\\",this.format.is(\\\"em\\\"))}},underline:{title:\\\"Underline\\\",refresh:function(a){a.toggleClass(\\\"fr-active\\\",this.format.is(\\\"u\\\"))}},strikeThrough:{title:\\\"Strikethrough\\\",refresh:function(a){a.toggleClass(\\\"fr-active\\\",this.format.is(\\\"s\\\"))}},subscript:{title:\\\"Subscript\\\",refresh:function(a){a.toggleClass(\\\"fr-active\\\",this.format.is(\\\"sub\\\"))}},superscript:{title:\\\"Superscript\\\",refresh:function(a){a.toggleClass(\\\"fr-active\\\",this.format.is(\\\"sup\\\"))}},outdent:{title:\\\"Decrease Indent\\\"},indent:{title:\\\"Increase Indent\\\"},undo:{title:\\\"Undo\\\",undo:!1,forcedRefresh:!0,disabled:!0},redo:{title:\\\"Redo\\\",undo:!1,forcedRefresh:!0,disabled:!0},insertHR:{title:\\\"Insert Horizontal Line\\\"},clearFormatting:{title:\\\"Clear Formatting\\\"},selectAll:{title:\\\"Select All\\\",undo:!1}},a.FE.RegisterCommand=function(b,c){a.FE.COMMANDS[b]=c},a.FE.MODULES.commands=function(b){function c(c,d){if(b.events.trigger(\\\"commands.before\\\",a.merge([c],d||[]))!==!1){var e=a.FE.COMMANDS[c]&&a.FE.COMMANDS[c].callback||h[c],f=!0;a.FE.COMMANDS[c]&&\\\"undefined\\\"!=typeof a.FE.COMMANDS[c].focus&&(f=a.FE.COMMANDS[c].focus),b.core.hasFocus()||!f||b.popups.areVisible()||b.events.focus(!0),a.FE.COMMANDS[c]&&a.FE.COMMANDS[c].undo!==!1&&b.undo.saveStep(),e&&e.apply(b,a.merge([c],d||[])),b.events.trigger(\\\"commands.after\\\",a.merge([c],d||[])),a.FE.COMMANDS[c]&&a.FE.COMMANDS[c].undo!==!1&&b.undo.saveStep()}}function d(a,c){b.format.toggle(c)}function e(c){b.selection.save(),b.html.wrap(!0,!0,!0,!0),b.selection.restore();for(var d=b.selection.blocks(),e=0;e<d.length;e++)if(\\\"LI\\\"!=d[e].tagName&&\\\"LI\\\"!=d[e].parentNode.tagName){var f=a(d[e]),g=\\\"rtl\\\"==b.opts.direction||\\\"rtl\\\"==f.css(\\\"direction\\\")?\\\"margin-right\\\":\\\"margin-left\\\",h=b.helpers.getPX(f.css(g));f.css(g,Math.max(h+20*c,0)||\\\"\\\"),f.removeClass(\\\"fr-temp-div\\\")}b.selection.save(),b.html.unwrap(),b.selection.restore()}function f(a){return function(){c(a)}}function g(){b.events.on(\\\"keydown\\\",function(a){var c=b.selection.element();return c&&\\\"HR\\\"==c.tagName&&!b.keys.isArrow(a.which)?(a.preventDefault(),!1):void 0}),b.events.on(\\\"keyup\\\",function(c){var d=b.selection.element();if(d&&\\\"HR\\\"==d.tagName)if(c.which==a.FE.KEYCODE.ARROW_LEFT||c.which==a.FE.KEYCODE.ARROW_UP){if(d.previousSibling)return b.node.isBlock(d.previousSibling)?b.selection.setAtEnd(d.previousSibling):a(d).before(a.FE.MARKERS),b.selection.restore(),!1}else if((c.which==a.FE.KEYCODE.ARROW_RIGHT||c.which==a.FE.KEYCODE.ARROW_DOWN)&&d.nextSibling)return b.node.isBlock(d.nextSibling)?b.selection.setAtStart(d.nextSibling):a(d).after(a.FE.MARKERS),b.selection.restore(),!1}),b.events.on(\\\"mousedown\\\",function(a){return a.target&&\\\"HR\\\"==a.target.tagName?(a.preventDefault(),a.stopPropagation(),!1):void 0}),b.events.on(\\\"mouseup\\\",function(c){var d=b.selection.element(),e=b.selection.endElement();d==e&&d&&\\\"HR\\\"==d.tagName&&(d.nextSibling&&(b.node.isBlock(d.nextSibling)?b.selection.setAtStart(d.nextSibling):a(d).after(a.FE.MARKERS)),b.selection.restore())})}var h={bold:function(){d(\\\"bold\\\",\\\"strong\\\")},subscript:function(){d(\\\"subscript\\\",\\\"sub\\\")},superscript:function(){d(\\\"superscript\\\",\\\"sup\\\")},italic:function(){d(\\\"italic\\\",\\\"em\\\")},strikeThrough:function(){d(\\\"strikeThrough\\\",\\\"s\\\")},underline:function(){d(\\\"underline\\\",\\\"u\\\")},undo:function(){b.undo.run()},redo:function(){b.undo.redo()},indent:function(){e(1)},outdent:function(){e(-1)},show:function(){b.opts.toolbarInline&&b.toolbar.showInline(null,!0)},insertHR:function(){b.selection.remove();var a=\\\"\\\";b.core.isEmpty()&&(a=\\\"<br>\\\",b.html.defaultTag()&&(a=\\\"<\\\"+b.html.defaultTag()+\\\">\\\"+a+\\\"</\\\"+b.html.defaultTag()+\\\">\\\")),b.html.insert('<hr id=\\\"fr-just\\\">'+a);var c=b.$el.find(\\\"hr#fr-just\\\");c.removeAttr(\\\"id\\\"),b.selection.setAfter(c.get(0))||b.selection.setBefore(c.get(0)),b.selection.restore()},clearFormatting:function(){b.format.remove()},selectAll:function(){b.doc.execCommand(\\\"selectAll\\\",!1,!1)}},i={};for(var j in h)h.hasOwnProperty(j)&&(i[j]=f(j));return a.extend(i,{exec:c,_init:g})},a.FE.MODULES.cursorLists=function(b){function c(a){for(var b=a;\\\"LI\\\"!=b.tagName;)b=b.parentNode;return b}function d(a){for(var c=a;!b.node.isList(c);)c=c.parentNode;return c}function e(e){var f,g=c(e),h=g.nextSibling,i=g.previousSibling,j=b.html.defaultTag();if(b.node.isEmpty(g,!0)&&h){for(var k=\\\"\\\",l=\\\"\\\",m=e.parentNode;!b.node.isList(m)&&m.parentNode&&\\\"LI\\\"!==m.parentNode.tagName;)k=b.node.openTagString(m)+k,l+=b.node.closeTagString(m),m=m.parentNode;k=b.node.openTagString(m)+k,l+=b.node.closeTagString(m);var n=\\\"\\\";for(n=m.parentNode&&\\\"LI\\\"==m.parentNode.tagName?l+\\\"<li>\\\"+a.FE.MARKERS+\\\"<br>\\\"+k:j?l+\\\"<\\\"+j+\\\">\\\"+a.FE.MARKERS+\\\"<br></\\\"+j+\\\">\\\"+k:l+a.FE.MARKERS+\\\"<br>\\\"+k,a(g).html('<span id=\\\"fr-break\\\"></span>');[\\\"UL\\\",\\\"OL\\\"].indexOf(m.tagName)<0||m.parentNode&&\\\"LI\\\"===m.parentNode.tagName;)m=m.parentNode;var o=b.node.openTagString(m)+a(m).html()+b.node.closeTagString(m);o=o.replace(/<span id=\\\"fr-break\\\"><\\\\/span>/g,n),a(m).replaceWith(o),b.$el.find(\\\"li:empty\\\").remove()}else i&&h||!b.node.isEmpty(g,!0)?(a(g).before(\\\"<li><br></li>\\\"),a(e).remove()):i?(f=d(g),f.parentNode&&\\\"LI\\\"==f.parentNode.tagName?a(f.parentNode).after(\\\"<li>\\\"+a.FE.MARKERS+\\\"<br></li>\\\"):j?a(f).after(\\\"<\\\"+j+\\\">\\\"+a.FE.MARKERS+\\\"<br></\\\"+j+\\\">\\\"):a(f).after(a.FE.MARKERS+\\\"<br>\\\"),a(g).remove()):(f=d(g),f.parentNode&&\\\"LI\\\"==f.parentNode.tagName?h?a(f.parentNode).before(\\\"<li>\\\"+a.FE.MARKERS+\\\"<br></li>\\\"):a(f.parentNode).after(\\\"<li>\\\"+a.FE.MARKERS+\\\"<br></li>\\\"):j?a(f).before(\\\"<\\\"+j+\\\">\\\"+a.FE.MARKERS+\\\"<br></\\\"+j+\\\">\\\"):a(f).before(a.FE.MARKERS+\\\"<br>\\\"),a(g).remove())}function f(d){for(var e=c(d),f=\\\"\\\",g=d,h=\\\"\\\",i=\\\"\\\";g!=e;){g=g.parentNode;var j=\\\"A\\\"==g.tagName&&b.cursor.isAtEnd(d,g)?\\\"fr-to-remove\\\":\\\"\\\";h=b.node.openTagString(a(g).clone().addClass(j).get(0))+h,i=b.node.closeTagString(g)+i}f=i+f+h+a.FE.MARKERS,a(d).replaceWith('<span id=\\\"fr-break\\\"></span>');var k=b.node.openTagString(e)+a(e).html()+b.node.closeTagString(e);k=k.replace(/<span id=\\\"fr-break\\\"><\\\\/span>/g,f),a(e).replaceWith(k)}function g(d){for(var e=c(d),f=a.FE.MARKERS,g=\\\"\\\",h=d,i=!1;h!=e;){h=h.parentNode;var j=\\\"A\\\"==h.tagName&&b.cursor.isAtEnd(d,h)?\\\"fr-to-remove\\\":\\\"\\\";i||h==e||b.node.isBlock(h)||(i=!0,g+=a.FE.INVISIBLE_SPACE),g=b.node.openTagString(a(h).clone().addClass(j).get(0))+g,f+=b.node.closeTagString(h)}var k=g+f;a(d).remove(),a(e).after(k)}function h(e){var f=c(e),g=f.previousSibling;if(g){g=a(g).find(b.html.blockTagsQuery()).get(-1)||g,a(e).replaceWith(a.FE.MARKERS);var h=b.node.contents(g);h.length&&\\\"BR\\\"==h[h.length-1].tagName&&a(h[h.length-1]).remove(),a(f).find(b.html.blockTagsQuery()).not(\\\"ol, ul, table\\\").each(function(){this.parentNode==f&&a(this).replaceWith(a(this).html()+(b.node.isEmpty(this)?\\\"\\\":\\\"<br>\\\"))});for(var i,j=b.node.contents(f)[0];j&&!b.node.isList(j);)i=j.nextSibling,a(g).append(j),j=i;for(g=f.previousSibling;j;)i=j.nextSibling,a(g).append(j),j=i;a(f).remove()}else{var k=d(f);if(a(e).replaceWith(a.FE.MARKERS),k.parentNode&&\\\"LI\\\"==k.parentNode.tagName){var l=k.previousSibling;b.node.isBlock(l)?(a(f).find(b.html.blockTagsQuery()).not(\\\"ol, ul, table\\\").each(function(){this.parentNode==f&&a(this).replaceWith(a(this).html()+(b.node.isEmpty(this)?\\\"\\\":\\\"<br>\\\"))}),a(l).append(a(f).html())):a(k).before(a(f).html())}else{var m=b.html.defaultTag();m&&0===a(f).find(b.html.blockTagsQuery()).length?a(k).before(\\\"<\\\"+m+\\\">\\\"+a(f).html()+\\\"</\\\"+m+\\\">\\\"):a(k).before(a(f).html())}a(f).remove(),0===a(k).find(\\\"li\\\").length&&a(k).remove()}}function i(d){var e,f=c(d),g=f.nextSibling;if(g){e=b.node.contents(g),e.length&&\\\"BR\\\"==e[0].tagName&&a(e[0]).remove(),a(g).find(b.html.blockTagsQuery()).not(\\\"ol, ul, table\\\").each(function(){this.parentNode==g&&a(this).replaceWith(a(this).html()+(b.node.isEmpty(this)?\\\"\\\":\\\"<br>\\\"))});for(var h,i=d,j=b.node.contents(g)[0];j&&!b.node.isList(j);)h=j.nextSibling,a(i).after(j),i=j,j=h;for(;j;)h=j.nextSibling,a(f).append(j),j=h;a(d).replaceWith(a.FE.MARKERS),a(g).remove()}else{for(var k=f;!k.nextSibling&&k!=b.$el.get(0);)k=k.parentNode;if(k==b.$el.get(0))return!1;if(k=k.nextSibling,b.node.isBlock(k))a.FE.NO_DELETE_TAGS.indexOf(k.tagName)<0&&(a(d).replaceWith(a.FE.MARKERS),e=b.node.contents(f),e.length&&\\\"BR\\\"==e[e.length-1].tagName&&a(e[e.length-1]).remove(),a(f).append(a(k).html()),a(k).remove());else for(e=b.node.contents(f),e.length&&\\\"BR\\\"==e[e.length-1].tagName&&a(e[e.length-1]).remove(),a(d).replaceWith(a.FE.MARKERS);k&&!b.node.isBlock(k)&&\\\"BR\\\"!=k.tagName;)a(f).append(a(k)),k=k.nextSibling}}return{_startEnter:e,_middleEnter:f,_endEnter:g,_backspace:h,_del:i}},a.FE.NO_DELETE_TAGS=[\\\"TH\\\",\\\"TD\\\",\\\"TR\\\",\\\"TABLE\\\",\\\"FORM\\\"],a.FE.SIMPLE_ENTER_TAGS=[\\\"TH\\\",\\\"TD\\\",\\\"LI\\\",\\\"DL\\\",\\\"DT\\\",\\\"FORM\\\"],a.FE.MODULES.cursor=function(b){function c(a){return a?b.node.isBlock(a)?!0:a.nextSibling&&a.nextSibling.nodeType==Node.TEXT_NODE&&0==a.nextSibling.textContent.replace(/\\\\u200b/g,\\\"\\\").length?c(a.nextSibling):a.nextSibling?!1:c(a.parentNode):!1}function d(a){return a?b.node.isBlock(a)?!0:a.previousSibling&&a.previousSibling.nodeType==Node.TEXT_NODE&&0==a.previousSibling.textContent.replace(/\\\\u200b/g,\\\"\\\").length?d(a.previousSibling):a.previousSibling?!1:d(a.parentNode):!1}function e(a,c){return a?a==b.$wp.get(0)?!1:a.previousSibling&&a.previousSibling.nodeType==Node.TEXT_NODE&&0==a.previousSibling.textContent.replace(/\\\\u200b/g,\\\"\\\").length?e(a.previousSibling,c):a.previousSibling?!1:a.parentNode==c?!0:e(a.parentNode,c):!1}function f(a,c){return a?a==b.$wp.get(0)?!1:a.nextSibling&&a.nextSibling.nodeType==Node.TEXT_NODE&&0==a.nextSibling.textContent.replace(/\\\\u200b/g,\\\"\\\").length?f(a.nextSibling,c):a.nextSibling?!1:a.parentNode==c?!0:f(a.parentNode,c):!1}function g(c){return a(c).parentsUntil(b.$el,\\\"LI\\\").length>0&&0===a(c).parentsUntil(\\\"LI\\\",\\\"TABLE\\\").length}function h(c){var d=a(c).parentsUntil(b.$el,\\\"BLOCKQUOTE\\\").length>0,e=b.node.deepestParent(c,[],!d);if(e&&\\\"BLOCKQUOTE\\\"==e.tagName){var f=b.node.deepestParent(c,[a(c).parentsUntil(b.$el,\\\"BLOCKQUOTE\\\").get(0)]);f&&f.previousSibling&&(e=f)}if(null!==e){var g,h=e.previousSibling;if(b.node.isBlock(e)&&b.node.isEditable(e)&&h&&a.FE.NO_DELETE_TAGS.indexOf(h.tagName)<0)if(b.node.isDeletable(h))a(h).remove(),a(c).replaceWith(a.FE.MARKERS);else if(b.node.isEditable(h))if(b.node.isBlock(h))if(b.node.isEmpty(h)&&!b.node.isList(h))a(h).remove();else{if(b.node.isList(h)&&(h=a(h).find(\\\"li:last\\\").get(0)),g=b.node.contents(h),g.length&&\\\"BR\\\"==g[g.length-1].tagName&&a(g[g.length-1]).remove(),\\\"BLOCKQUOTE\\\"==h.tagName&&\\\"BLOCKQUOTE\\\"!=e.tagName)for(g=b.node.contents(h);g.length&&b.node.isBlock(g[g.length-1]);)h=g[g.length-1],g=b.node.contents(h);else if(\\\"BLOCKQUOTE\\\"!=h.tagName&&\\\"BLOCKQUOTE\\\"==e.tagName)for(g=b.node.contents(e);g.length&&b.node.isBlock(g[0]);)e=g[0],g=b.node.contents(e);a(c).replaceWith(a.FE.MARKERS),a(h).append(b.node.isEmpty(e)?a.FE.MARKERS:e.innerHTML),a(e).remove()}else a(c).replaceWith(a.FE.MARKERS),\\\"BLOCKQUOTE\\\"==e.tagName&&h.nodeType==Node.ELEMENT_NODE?a(h).remove():(a(h).after(b.node.isEmpty(e)?\\\"\\\":a(e).html()),a(e).remove(),\\\"BR\\\"==h.tagName&&a(h).remove())}}function i(c){for(var d=c;!d.previousSibling;)if(d=d.parentNode,b.node.isElement(d))return!1;d=d.previousSibling;var e;if(!b.node.isBlock(d)&&b.node.isEditable(d)){for(e=b.node.contents(d);d.nodeType!=Node.TEXT_NODE&&!b.node.isDeletable(d)&&e.length&&b.node.isEditable(d);)d=e[e.length-1],e=b.node.contents(d);if(d.nodeType==Node.TEXT_NODE){if(b.helpers.isIOS())return!0;var f=d.textContent,g=f.length-1;if(b.opts.tabSpaces&&f.length>=b.opts.tabSpaces){var h=f.substr(f.length-b.opts.tabSpaces,f.length-1);0==h.replace(/ /g,\\\"\\\").replace(new RegExp(a.FE.UNICODE_NBSP,\\\"g\\\"),\\\"\\\").length&&(g=f.length-b.opts.tabSpaces)}d.textContent=f.substring(0,g),d.textContent.length&&55357==d.textContent.charCodeAt(d.textContent.length-1)&&(d.textContent=d.textContent.substr(0,d.textContent.length-1));var i=f.length!=d.textContent.length;0==d.textContent.length?i&&b.opts.keepFormatOnDelete?a(d).after(a.FE.INVISIBLE_SPACE+a.FE.MARKERS):2!=d.parentNode.childNodes.length||d.parentNode!=c.parentNode||b.node.isBlock(d.parentNode)||b.node.isElement(d.parentNode)?(a(d).after(a.FE.MARKERS),b.node.isElement(d.parentNode)&&!c.nextSibling&&d.previousSibling&&\\\"BR\\\"==d.previousSibling.tagName&&a(c).after(\\\"<br>\\\"),d.parentNode.removeChild(d)):(a(d.parentNode).after(a.FE.MARKERS),a(d.parentNode).remove()):a(d).after(a.FE.MARKERS)}else b.node.isDeletable(d)?(a(d).after(a.FE.MARKERS),a(d).remove()):b.events.trigger(\\\"node.remove\\\",[a(d)])!==!1&&(a(d).after(a.FE.MARKERS),a(d).remove())}else if(a.FE.NO_DELETE_TAGS.indexOf(d.tagName)<0&&b.node.isEditable(d))if(b.node.isEmpty(d)&&!b.node.isList(d))a(d).remove(),a(c).replaceWith(a.FE.MARKERS);else{for(b.node.isList(d)&&(d=a(d).find(\\\"li:last\\\").get(0)),e=b.node.contents(d),e&&\\\"BR\\\"==e[e.length-1].tagName&&a(e[e.length-1]).remove(),e=b.node.contents(d);e&&b.node.isBlock(e[e.length-1]);)d=e[e.length-1],e=b.node.contents(d);a(d).append(a.FE.MARKERS);for(var j=c;!j.previousSibling;)j=j.parentNode;for(;j&&\\\"BR\\\"!==j.tagName&&!b.node.isBlock(j);){var k=j;j=j.nextSibling,a(d).append(k)}j&&\\\"BR\\\"==j.tagName&&a(j).remove(),a(c).remove()}else c.nextSibling&&\\\"BR\\\"==c.nextSibling.tagName&&a(c.nextSibling).remove()}function j(){var f=!1,j=b.markers.insert();if(!j)return!0;b.$el.get(0).normalize();var k=j.previousSibling;if(k){var l=k.textContent;l&&l.length&&8203==l.charCodeAt(l.length-1)&&(1==l.length?a(k).remove():(k.textContent=k.textContent.substr(0,l.length-1),k.textContent.length&&55357==k.textContent.charCodeAt(k.textContent.length-1)&&(k.textContent=k.textContent.substr(0,k.textContent.length-1))))}return c(j)?f=i(j):d(j)?g(j)&&e(j,a(j).parents(\\\"li:first\\\").get(0))?b.cursorLists._backspace(j):h(j):f=i(j),a(j).remove(),b.$el.find(\\\"blockquote:empty\\\").remove(),b.html.fillEmptyBlocks(),b.html.cleanEmptyTags(),b.clean.quotes(),b.clean.lists(),b.spaces.normalize(),b.selection.restore(),f}function k(c){var d=a(c).parentsUntil(b.$el,\\\"BLOCKQUOTE\\\").length>0,e=b.node.deepestParent(c,[],!d);if(e&&\\\"BLOCKQUOTE\\\"==e.tagName){var f=b.node.deepestParent(c,[a(c).parentsUntil(b.$el,\\\"BLOCKQUOTE\\\").get(0)]);f&&f.nextSibling&&(e=f)}if(null!==e){var g,h=e.nextSibling;if(b.node.isBlock(e)&&(b.node.isEditable(e)||b.node.isDeletable(e))&&h&&a.FE.NO_DELETE_TAGS.indexOf(h.tagName)<0)if(b.node.isDeletable(h))a(h).remove(),a(c).replaceWith(a.FE.MARKERS);else if(b.node.isBlock(h)&&b.node.isEditable(h))if(b.node.isList(h))if(b.node.isEmpty(e,!0))a(e).remove(),a(h).find(\\\"li:first\\\").prepend(a.FE.MARKERS);else{var i=a(h).find(\\\"li:first\\\");\\\"BLOCKQUOTE\\\"==e.tagName&&(g=b.node.contents(e),g.length&&b.node.isBlock(g[g.length-1])&&(e=g[g.length-1])),0===i.find(\\\"ul, ol\\\").length&&(a(c).replaceWith(a.FE.MARKERS),i.find(b.html.blockTagsQuery()).not(\\\"ol, ul, table\\\").each(function(){this.parentNode==i.get(0)&&a(this).replaceWith(a(this).html()+(b.node.isEmpty(this)?\\\"\\\":\\\"<br>\\\"))}),a(e).append(b.node.contents(i.get(0))),i.remove(),0===a(h).find(\\\"li\\\").length&&a(h).remove())}else{if(g=b.node.contents(h),g.length&&\\\"BR\\\"==g[0].tagName&&a(g[0]).remove(),\\\"BLOCKQUOTE\\\"!=h.tagName&&\\\"BLOCKQUOTE\\\"==e.tagName)for(g=b.node.contents(e);g.length&&b.node.isBlock(g[g.length-1]);)e=g[g.length-1],g=b.node.contents(e);else if(\\\"BLOCKQUOTE\\\"==h.tagName&&\\\"BLOCKQUOTE\\\"!=e.tagName)for(g=b.node.contents(h);g.length&&b.node.isBlock(g[0]);)h=g[0],g=b.node.contents(h);a(c).replaceWith(a.FE.MARKERS),a(e).append(h.innerHTML),a(h).remove()}else{for(a(c).replaceWith(a.FE.MARKERS);h&&\\\"BR\\\"!==h.tagName&&!b.node.isBlock(h)&&b.node.isEditable(h);){var j=h;h=h.nextSibling,a(e).append(j)}h&&\\\"BR\\\"==h.tagName&&b.node.isEditable(h)&&a(h).remove()}}}function l(d){for(var e=d;!e.nextSibling;)if(e=e.parentNode,b.node.isElement(e))return!1;if(e=e.nextSibling,\\\"BR\\\"==e.tagName&&b.node.isEditable(e))if(e.nextSibling){if(b.node.isBlock(e.nextSibling)&&b.node.isEditable(e.nextSibling)){if(!(a.FE.NO_DELETE_TAGS.indexOf(e.nextSibling.tagName)<0))return void a(e).remove();e=e.nextSibling,a(e.previousSibling).remove()}}else if(c(e)){if(g(d))b.cursorLists._del(d);else{\\nvar f=b.node.deepestParent(e);f&&(a(e).remove(),k(d))}return}var h;if(!b.node.isBlock(e)&&b.node.isEditable(e)){for(h=b.node.contents(e);e.nodeType!=Node.TEXT_NODE&&h.length&&!b.node.isDeletable(e)&&b.node.isEditable(e);)e=h[0],h=b.node.contents(e);e.nodeType==Node.TEXT_NODE?(a(e).before(a.FE.MARKERS),e.textContent.length&&55357==e.textContent.charCodeAt(0)?e.textContent=e.textContent.substring(2,e.textContent.length):e.textContent=e.textContent.substring(1,e.textContent.length)):b.node.isDeletable(e)?(a(e).before(a.FE.MARKERS),a(e).remove()):b.events.trigger(\\\"node.remove\\\",[a(e)])!==!1&&(a(e).before(a.FE.MARKERS),a(e).remove()),a(d).remove()}else if(a.FE.NO_DELETE_TAGS.indexOf(e.tagName)<0&&(b.node.isEditable(e)||b.node.isDeletable(e)))if(b.node.isDeletable(e))a(d).replaceWith(a.FE.MARKERS),a(e).remove();else if(b.node.isList(e))d.previousSibling?(a(e).find(\\\"li:first\\\").prepend(d),b.cursorLists._backspace(d)):(a(e).find(\\\"li:first\\\").prepend(a.FE.MARKERS),a(d).remove());else if(h=b.node.contents(e),h&&\\\"BR\\\"==h[0].tagName&&a(h[0]).remove(),h&&\\\"BLOCKQUOTE\\\"==e.tagName){var i=h[0];for(a(d).before(a.FE.MARKERS);i&&\\\"BR\\\"!=i.tagName;){var j=i;i=i.nextSibling,a(d).before(j)}i&&\\\"BR\\\"==i.tagName&&a(i).remove()}else a(d).after(a(e).html()).after(a.FE.MARKERS),a(e).remove()}function m(){var e=b.markers.insert();if(!e)return!1;if(b.$el.get(0).normalize(),c(e))if(g(e))if(0===a(e).parents(\\\"li:first\\\").find(\\\"ul, ol\\\").length)b.cursorLists._del(e);else{var f=a(e).parents(\\\"li:first\\\").find(\\\"ul:first, ol:first\\\").find(\\\"li:first\\\");f=f.find(b.html.blockTagsQuery()).get(-1)||f,f.prepend(e),b.cursorLists._backspace(e)}else k(e);else l(d(e)?e:e);a(e).remove(),b.$el.find(\\\"blockquote:empty\\\").remove(),b.html.fillEmptyBlocks(),b.html.cleanEmptyTags(),b.clean.quotes(),b.clean.lists(),b.spaces.normalize(),b.selection.restore()}function n(){b.$el.find(\\\".fr-to-remove\\\").each(function(){for(var c=b.node.contents(this),d=0;d<c.length;d++)c[d].nodeType==Node.TEXT_NODE&&(c[d].textContent=c[d].textContent.replace(/\\\\u200B/g,\\\"\\\"));a(this).replaceWith(this.innerHTML)})}function o(c,d,e){var g,h=b.node.deepestParent(c,[],!e);if(h&&\\\"BLOCKQUOTE\\\"==h.tagName)return f(c,h)?(g=b.html.defaultTag(),g?a(h).after(\\\"<\\\"+g+\\\">\\\"+a.FE.MARKERS+\\\"<br></\\\"+g+\\\">\\\"):a(h).after(a.FE.MARKERS+\\\"<br>\\\"),a(c).remove(),!1):(q(c,d,e),!1);if(null==h)g=b.html.defaultTag(),g&&b.node.isElement(c.parentNode)?a(c).replaceWith(\\\"<\\\"+g+\\\">\\\"+a.FE.MARKERS+\\\"<br></\\\"+g+\\\">\\\"):a(c).replaceWith(\\\"<br/>\\\"+a.FE.MARKERS+\\\"<br/>\\\");else{var i=c,j=\\\"\\\";(!b.node.isBlock(h)||d)&&(j=\\\"<br/>\\\");var k=\\\"\\\",l=\\\"\\\";g=b.html.defaultTag();var m=\\\"\\\",n=\\\"\\\";g&&b.node.isBlock(h)&&(m=\\\"<\\\"+g+\\\">\\\",n=\\\"</\\\"+g+\\\">\\\",h.tagName==g.toUpperCase()&&(m=b.node.openTagString(a(h).clone().removeAttr(\\\"id\\\").get(0))));do if(i=i.parentNode,!d||i!=h||d&&!b.node.isBlock(h))if(k+=b.node.closeTagString(i),i==h&&b.node.isBlock(h))l=m+l;else{var o=\\\"A\\\"==i.tagName&&f(c,i)?\\\"fr-to-remove\\\":\\\"\\\";l=b.node.openTagString(a(i).clone().addClass(o).get(0))+l}while(i!=h);j=k+j+l+(c.parentNode==h&&b.node.isBlock(h)?\\\"\\\":a.FE.INVISIBLE_SPACE)+a.FE.MARKERS,b.node.isBlock(h)&&!a(h).find(\\\"*:last\\\").is(\\\"br\\\")&&a(h).append(\\\"<br/>\\\"),a(c).after('<span id=\\\"fr-break\\\"></span>'),a(c).remove(),h.nextSibling&&!b.node.isBlock(h.nextSibling)||b.node.isBlock(h)||a(h).after(\\\"<br>\\\");var p;p=!d&&b.node.isBlock(h)?b.node.openTagString(h)+a(h).html()+n:b.node.openTagString(h)+a(h).html()+b.node.closeTagString(h),p=p.replace(/<span id=\\\"fr-break\\\"><\\\\/span>/g,j),a(h).replaceWith(p)}}function p(c,d,g){var h,i=b.node.deepestParent(c,[],!g);if(i&&\\\"BLOCKQUOTE\\\"==i.tagName){if(e(c,i))return h=b.html.defaultTag(),h?a(i).before(\\\"<\\\"+h+\\\">\\\"+a.FE.MARKERS+\\\"<br></\\\"+h+\\\">\\\"):a(i).before(a.FE.MARKERS+\\\"<br>\\\"),a(c).remove(),!1;f(c,i)?o(c,d,!0):q(c,d,!0)}if(null==i)h=b.html.defaultTag(),h&&b.node.isElement(c.parentNode)?a(c).replaceWith(\\\"<\\\"+h+\\\">\\\"+a.FE.MARKERS+\\\"<br></\\\"+h+\\\">\\\"):a(c).replaceWith(\\\"<br>\\\"+a.FE.MARKERS);else{if(b.node.isBlock(i))if(d)a(c).remove(),a(i).prepend(\\\"<br>\\\"+a.FE.MARKERS);else{if(b.node.isEmpty(i,!0))return o(c,d,g);a(i).before(b.node.openTagString(a(i).clone().removeAttr(\\\"id\\\").get(0))+\\\"<br>\\\"+b.node.closeTagString(i))}else a(i).before(\\\"<br>\\\");a(c).remove()}}function q(c,d,g){var h=b.node.deepestParent(c,[],!g);if(null==h)b.html.defaultTag()&&c.parentNode===b.$el.get(0)?a(c).replaceWith(\\\"<\\\"+b.html.defaultTag()+\\\">\\\"+a.FE.MARKERS+\\\"<br></\\\"+b.html.defaultTag()+\\\">\\\"):((!c.nextSibling||b.node.isBlock(c.nextSibling))&&a(c).after(\\\"<br>\\\"),a(c).replaceWith(\\\"<br>\\\"+a.FE.MARKERS));else{var i=c,j=\\\"\\\";\\\"PRE\\\"==h.tagName&&(d=!0),(!b.node.isBlock(h)||d)&&(j=\\\"<br>\\\");var k=\\\"\\\",l=\\\"\\\";do{var m=i;if(i=i.parentNode,\\\"BLOCKQUOTE\\\"==h.tagName&&b.node.isEmpty(m)&&!a(m).hasClass(\\\"fr-marker\\\")&&a(m).find(c).length>0&&a(m).after(c),(\\\"BLOCKQUOTE\\\"!=h.tagName||!f(c,i)&&!e(c,i))&&(!d||i!=h||d&&!b.node.isBlock(h))){k+=b.node.closeTagString(i);var n=\\\"A\\\"==i.tagName&&f(c,i)?\\\"fr-to-remove\\\":\\\"\\\";l=b.node.openTagString(a(i).clone().addClass(n).removeAttr(\\\"id\\\").get(0))+l}}while(i!=h);var o=h==c.parentNode&&b.node.isBlock(h)||c.nextSibling;if(\\\"BLOCKQUOTE\\\"==h.tagName){c.previousSibling&&b.node.isBlock(c.previousSibling)&&c.nextSibling&&\\\"BR\\\"==c.nextSibling.tagName&&(a(c.nextSibling).after(c),c.nextSibling&&\\\"BR\\\"==c.nextSibling.tagName&&a(c.nextSibling).remove());var p=b.html.defaultTag();j=k+j+(p?\\\"<\\\"+p+\\\">\\\":\\\"\\\")+a.FE.MARKERS+\\\"<br>\\\"+(p?\\\"</\\\"+p+\\\">\\\":\\\"\\\")+l}else j=k+j+l+(o?\\\"\\\":a.FE.INVISIBLE_SPACE)+a.FE.MARKERS;a(c).replaceWith('<span id=\\\"fr-break\\\"></span>');var q=b.node.openTagString(h)+a(h).html()+b.node.closeTagString(h);q=q.replace(/<span id=\\\"fr-break\\\"><\\\\/span>/g,j),a(h).replaceWith(q)}}function r(e){var f=b.markers.insert();if(!f)return!0;b.$el.get(0).normalize();var h=!1;a(f).parentsUntil(b.$el,\\\"BLOCKQUOTE\\\").length>0&&(e=!1,h=!0),a(f).parentsUntil(b.$el,\\\"TD, TH\\\").length&&(h=!1),c(f)?!g(f)||e||h?o(f,e,h):b.cursorLists._endEnter(f):d(f)?!g(f)||e||h?p(f,e,h):b.cursorLists._startEnter(f):!g(f)||e||h?q(f,e,h):b.cursorLists._middleEnter(f),n(),b.html.fillEmptyBlocks(),b.html.cleanEmptyTags(),b.clean.lists(),b.spaces.normalize(),b.selection.restore()}return{enter:r,backspace:j,del:m,isAtEnd:f}},a.FE.MODULES.data=function(a){function b(a){return a}function c(a){if(!a)return a;for(var c=\\\"\\\",f=b(\\\"charCodeAt\\\"),g=b(\\\"fromCharCode\\\"),h=l.indexOf(a[0]),i=1;i<a.length-2;i++){for(var j=d(++h),k=a[f](i),m=\\\"\\\";/[0-9-]/.test(a[i+1]);)m+=a[++i];m=parseInt(m,10)||0,k=e(k,j,m),k^=h-1&31,c+=String[g](k)}return c}function d(a){for(var b=a.toString(),c=0,d=0;d<b.length;d++)c+=parseInt(b.charAt(d),10);return c>10?c%9+1:c}function e(a,b,c){for(var d=Math.abs(c);d-- >0;)a-=b;return 0>c&&(a+=123),a}function f(a){return a&&\\\"none\\\"==a.css(\\\"display\\\")?(a.remove(),!0):!1}function g(){return f(j)||f(k)}function h(){return a.$box?(a.$box.append(n(b(n(\\\"kTDD4spmKD1klaMB1C7A5RA1G3RA10YA5qhrjuvnmE1D3FD2bcG-7noHE6B2JB4C3xXA8WF6F-10RG2C3G3B-21zZE3C3H3xCA16NC4DC1f1hOF1MB3B-21whzQH5UA2WB10kc1C2F4D3XC2YD4D1C4F3GF2eJ2lfcD-13HF1IE1TC11TC7WE4TA4d1A2YA6XA4d1A3yCG2qmB-13GF4A1B1KH1HD2fzfbeQC3TD9VE4wd1H2A20A2B-22ujB3nBG2A13jBC10D3C2HD5D1H1KB11uD-16uWF2D4A3F-7C9D-17c1E4D4B3d1D2CA6B2B-13qlwzJF2NC2C-13E-11ND1A3xqUA8UE6bsrrF-7C-22ia1D2CF2H1E2akCD2OE1HH1dlKA6PA5jcyfzB-22cXB4f1C3qvdiC4gjGG2H2gklC3D-16wJC1UG4dgaWE2D5G4g1I2H3B7vkqrxH1H2EC9C3E4gdgzKF1OA1A5PF5C4WWC3VA6XA4e1E3YA2YA5HE4oGH4F2H2IB10D3D2NC5G1B1qWA9PD6PG5fQA13A10XA4C4A3e1H2BA17kC-22cmOB1lmoA2fyhcptwWA3RA8A-13xB-11nf1I3f1B7GB3aD3pavFC10D5gLF2OG1LSB2D9E7fQC1F4F3wpSB5XD3NkklhhaE-11naKA9BnIA6D1F5bQA3A10c1QC6Kjkvitc2B6BE3AF3E2DA6A4JD2IC1jgA-64MB11D6C4==\\\")))),j=a.$box.find(\\\"> div:last\\\"),k=j.find(\\\"> a\\\"),void(\\\"rtl\\\"==a.opts.direction&&j.css(\\\"left\\\",\\\"auto\\\").css(\\\"right\\\",0))):!1}function i(){var c=a.opts.key||[\\\"\\\"];\\\"string\\\"==typeof c&&(c=[c]),a.ul=!0;for(var d=0;d<c.length;d++){var e=n(c[d])||\\\"\\\";if(!(e!==n(b(n(\\\"mcVRDoB1BGILD7YFe1BTXBA7B6==\\\")))&&e.indexOf(m,e.length-m.length)<0&&[n(\\\"9qqG-7amjlwq==\\\"),n(\\\"KA3B3C2A6D1D5H5H1A3==\\\"),n(\\\"QzbzvxyB2yA-9m==\\\"),n(\\\"naamngiA3dA-16xtE-11C-9B1H-8sc==\\\")].indexOf(m)<0)){a.ul=!1;break}}a.ul===!0&&h(),a.events.on(\\\"contentChanged\\\",function(){a.ul===!0&&g()&&h()}),a.events.on(\\\"destroy\\\",function(){j&&j.length&&j.remove()},!0)}var j,k,l=\\\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\\\",m=function(){for(var a=0,b=document.domain,c=b.split(\\\".\\\"),d=\\\"_gd\\\"+(new Date).getTime();a<c.length-1&&-1==document.cookie.indexOf(d+\\\"=\\\"+d);)b=c.slice(-1-++a).join(\\\".\\\"),document.cookie=d+\\\"=\\\"+d+\\\";domain=\\\"+b+\\\";\\\";return document.cookie=d+\\\"=;expires=Thu, 01 Jan 1970 00:00:01 GMT;domain=\\\"+b+\\\";\\\",(b||\\\"\\\").replace(/(^\\\\.*)|(\\\\.*$)/g,\\\"\\\")}(),n=b(c);return{_init:i}},a.FE.ENTER_P=0,a.FE.ENTER_DIV=1,a.FE.ENTER_BR=2,a.FE.KEYCODE={BACKSPACE:8,TAB:9,ENTER:13,SHIFT:16,CTRL:17,ALT:18,ESC:27,SPACE:32,ARROW_LEFT:37,ARROW_UP:38,ARROW_RIGHT:39,ARROW_DOWN:40,DELETE:46,ZERO:48,ONE:49,TWO:50,THREE:51,FOUR:52,FIVE:53,SIX:54,SEVEN:55,EIGHT:56,NINE:57,FF_SEMICOLON:59,FF_EQUALS:61,QUESTION_MARK:63,A:65,B:66,C:67,D:68,E:69,F:70,G:71,H:72,I:73,J:74,K:75,L:76,M:77,N:78,O:79,P:80,Q:81,R:82,S:83,T:84,U:85,V:86,W:87,X:88,Y:89,Z:90,META:91,NUM_ZERO:96,NUM_ONE:97,NUM_TWO:98,NUM_THREE:99,NUM_FOUR:100,NUM_FIVE:101,NUM_SIX:102,NUM_SEVEN:103,NUM_EIGHT:104,NUM_NINE:105,NUM_MULTIPLY:106,NUM_PLUS:107,NUM_MINUS:109,NUM_PERIOD:110,NUM_DIVISION:111,SEMICOLON:186,DASH:189,EQUALS:187,COMMA:188,PERIOD:190,SLASH:191,APOSTROPHE:192,TILDE:192,SINGLE_QUOTE:222,OPEN_SQUARE_BRACKET:219,BACKSLASH:220,CLOSE_SQUARE_BRACKET:221},a.extend(a.FE.DEFAULTS,{enter:a.FE.ENTER_P,multiLine:!0,tabSpaces:0}),a.FE.MODULES.keys=function(b){function c(a){b.opts.multiLine?b.helpers.isIOS()||(a.preventDefault(),a.stopPropagation(),b.selection.isCollapsed()||b.selection.remove(),b.cursor.enter()):(a.preventDefault(),a.stopPropagation())}function d(a){a.preventDefault(),a.stopPropagation(),b.opts.multiLine&&(b.selection.isCollapsed()||b.selection.remove(),b.cursor.enter(!0))}function e(a){b.selection.isCollapsed()?b.cursor.backspace()||(a.preventDefault(),a.stopPropagation(),y=!1):(a.preventDefault(),a.stopPropagation(),b.selection.remove(),b.html.fillEmptyBlocks(),y=!1),b.placeholder.refresh()}function f(a){a.preventDefault(),a.stopPropagation(),\\\"\\\"===b.selection.text()?b.cursor.del():b.selection.remove(),b.placeholder.refresh()}function g(c){if(b.browser.mozilla){c.preventDefault(),c.stopPropagation(),b.selection.isCollapsed()||b.selection.remove(),b.markers.insert();var d=b.$el.find(\\\".fr-marker\\\").get(0),e=d.previousSibling,f=d.nextSibling;!f&&d.parentNode&&\\\"A\\\"==d.parentNode.tagName?(a(d).parent().after(\\\"&nbsp;\\\"+a.FE.MARKERS),a(d).remove()):(e&&e.nodeType==Node.TEXT_NODE&&1==e.textContent.length&&160==e.textContent.charCodeAt(0)?a(e).after(\\\" \\\"):a(d).before(\\\"&nbsp;\\\"),a(d).replaceWith(a.FE.MARKERS)),b.selection.restore()}}function h(){if(b.browser.mozilla&&b.selection.isCollapsed()&&!B){var a=b.selection.ranges(0),c=a.startContainer,d=a.startOffset;c&&c.nodeType==Node.TEXT_NODE&&d<=c.textContent.length&&d>0&&32==c.textContent.charCodeAt(d-1)&&(b.selection.save(),b.spaces.normalize(),b.selection.restore())}}function i(){b.selection.isFull()&&setTimeout(function(){var c=b.html.defaultTag();c?b.$el.html(\\\"<\\\"+c+\\\">\\\"+a.FE.MARKERS+\\\"<br/></\\\"+c+\\\">\\\"):b.$el.html(a.FE.MARKERS+\\\"<br/>\\\"),b.selection.restore(),b.placeholder.refresh(),b.button.bulkRefresh(),b.undo.saveStep()},0)}function j(a){if(b.opts.tabSpaces>0)if(b.selection.isCollapsed()){b.undo.saveStep(),a.preventDefault(),a.stopPropagation();for(var c=\\\"\\\",d=0;d<b.opts.tabSpaces;d++)c+=\\\"&nbsp;\\\";b.html.insert(c),b.placeholder.refresh(),b.undo.saveStep()}else a.preventDefault(),a.stopPropagation(),a.shiftKey?b.commands.outdent():b.commands.indent()}function k(a){B=!1}function l(){return B}function m(h){b.events.disableBlur(),y=!0;var i=h.which;if(16===i)return!0;if(229===i)return B=!0,!0;B=!1;var k=t(i)&&!r(h),l=i==a.FE.KEYCODE.BACKSPACE||i==a.FE.KEYCODE.DELETE;if((b.selection.isFull()&&!b.opts.keepFormatOnDelete&&!b.placeholder.isVisible()||l&&b.placeholder.isVisible()&&b.opts.keepFormatOnDelete)&&(k||l)){var m=b.html.defaultTag();if(m?b.$el.html(\\\"<\\\"+m+\\\">\\\"+a.FE.MARKERS+\\\"<br/></\\\"+m+\\\">\\\"):b.$el.html(a.FE.MARKERS+\\\"<br/>\\\"),b.selection.restore(),!t(i))return h.preventDefault(),!0}i==a.FE.KEYCODE.ENTER?h.shiftKey?d(h):c(h):i!=a.FE.KEYCODE.BACKSPACE||r(h)||h.altKey?i!=a.FE.KEYCODE.DELETE||r(h)||h.altKey?i==a.FE.KEYCODE.SPACE?g(h):i==a.FE.KEYCODE.TAB?j(h):r(h)||!t(h.which)||b.selection.isCollapsed()||h.ctrlKey||b.selection.remove():b.placeholder.isVisible()?(h.preventDefault(),h.stopPropagation()):f(h):b.placeholder.isVisible()?(h.preventDefault(),h.stopPropagation()):e(h),b.events.enableBlur()}function n(c){for(var d=0;d<c.length;d++)c[d].nodeType==Node.TEXT_NODE&&/\\\\u200B/gi.test(c[d].textContent)?(c[d].textContent=c[d].textContent.replace(/\\\\u200B/gi,\\\"\\\"),0===c[d].textContent.length&&a(c[d]).remove()):c[d].nodeType==Node.ELEMENT_NODE&&\\\"IFRAME\\\"!=c[d].nodeType&&n(b.node.contents(c[d]))}function o(){if(!b.$wp)return!0;var c;b.opts.height||b.opts.heightMax?(c=b.position.getBoundingRect().top,b.helpers.isIOS()&&(c-=a(b.o_win).scrollTop()),b.opts.iframe&&(c+=b.$iframe.offset().top),c>b.$wp.offset().top-a(b.o_win).scrollTop()+b.$wp.height()-20&&b.$wp.scrollTop(c+b.$wp.scrollTop()-(b.$wp.height()+b.$wp.offset().top)+a(b.o_win).scrollTop()+20)):(c=b.position.getBoundingRect().top,b.opts.toolbarBottom&&(c+=b.opts.toolbarStickyOffset),b.helpers.isIOS()&&(c-=a(b.o_win).scrollTop()),b.opts.iframe&&(c+=b.$iframe.offset().top),c+=b.opts.toolbarStickyOffset,c>b.o_win.innerHeight-20&&a(b.o_win).scrollTop(c+a(b.o_win).scrollTop()-b.o_win.innerHeight+20),c=b.position.getBoundingRect().top,b.opts.toolbarBottom||(c-=b.opts.toolbarStickyOffset),b.helpers.isIOS()&&(c-=a(b.o_win).scrollTop()),b.opts.iframe&&(c+=b.$iframe.offset().top),c<b.$tb.height()+20&&a(b.o_win).scrollTop(c+a(b.o_win).scrollTop()-b.$tb.height()-20))}function p(){var c=b.selection.element(),d=b.node.blockParent(c);if(d&&\\\"DIV\\\"==d.tagName&&b.selection.info(d).atStart){var e=b.html.defaultTag();d.previousSibling&&\\\"DIV\\\"!=d.previousSibling.tagName&&e&&\\\"div\\\"!=e&&(b.selection.save(),a(d).replaceWith(\\\"<\\\"+e+\\\">\\\"+d.innerHTML+\\\"</\\\"+e+\\\">\\\"),b.selection.restore())}}function q(c){if(B)return B=!1,!1;if(!b.selection.isCollapsed())return!0;if(c&&(c.which===a.FE.KEYCODE.META||c.which==a.FE.KEYCODE.CTRL))return!0;if(c&&s(c.which))return!0;c&&c.which==a.FE.KEYCODE.ENTER&&b.helpers.isIOS()&&p(),c&&(c.which==a.FE.KEYCODE.ENTER||c.which==a.FE.KEYCODE.BACKSPACE||c.which>=37&&c.which<=40&&!b.browser.msie)&&(c.which==a.FE.KEYCODE.BACKSPACE&&y||o());var d=Array.prototype.slice.call(b.$el.get(0).querySelectorAll(b.html.blockTagsQuery()),0);d.push(b.$el.get(0));for(var e=[],f=0;f<d.length;f++)if([\\\"TD\\\",\\\"TH\\\"].indexOf(d[f].tagName)<0)for(var g=d[f].children,h=0;h<g.length;h++)\\\"BR\\\"==g[h].tagName&&e.push(g[h]);for(var d=[],f=0;f<e.length;f++){var i=e[f],j=i.previousSibling,k=i.nextSibling,l=b.node.blockParent(i)||b.$el.get(0);j&&l&&\\\"BR\\\"!=j.tagName&&!b.node.isBlock(j)&&!k&&a(l).text().replace(/\\\\u200B/g,\\\"\\\").length>0&&a(j).text().length>0&&(b.$el.is(l)&&!k&&b.opts.enter==a.FE.ENTER_BR&&b.browser.msie||(b.selection.save(),a(i).remove(),b.selection.restore()))}e=[];var m=function(b){if(!b)return!1;var c=a(b).html();return c=c.replace(/<span[^>]*? class\\\\s*=\\\\s*[\\\"']?fr-marker[\\\"']?[^>]+>\\\\u200b<\\\\/span>/gi,\\\"\\\"),c&&/\\\\u200B/.test(c)&&c.replace(/\\\\u200B/gi,\\\"\\\").length>0?!0:!1},q=function(a){var c=/[\\\\u3041-\\\\u3096\\\\u30A0-\\\\u30FF\\\\u4E00-\\\\u9FFF\\\\u3130-\\\\u318F\\\\uAC00-\\\\uD7AF]/gi;return!b.helpers.isIOS()||0===((a.textContent||\\\"\\\").match(c)||[]).length},r=b.selection.element();m(r)&&0===a(r).find(\\\"li\\\").length&&!a(r).hasClass(\\\"fr-marker\\\")&&\\\"IFRAME\\\"!=r.tagName&&q(r)&&(b.selection.save(),n(b.node.contents(r)),b.selection.restore()),!b.browser.mozilla&&b.html.doNormalize(r)&&(b.selection.save(),b.spaces.normalize(),b.selection.restore())}function r(a){if(-1!=navigator.userAgent.indexOf(\\\"Mac OS X\\\")){if(a.metaKey&&!a.altKey)return!0}else if(a.ctrlKey&&!a.altKey)return!0;return!1}function s(b){return b>=a.FE.KEYCODE.ARROW_LEFT&&b<=a.FE.KEYCODE.ARROW_DOWN?!0:void 0}function t(c){if(c>=a.FE.KEYCODE.ZERO&&c<=a.FE.KEYCODE.NINE)return!0;if(c>=a.FE.KEYCODE.NUM_ZERO&&c<=a.FE.KEYCODE.NUM_MULTIPLY)return!0;if(c>=a.FE.KEYCODE.A&&c<=a.FE.KEYCODE.Z)return!0;if(b.browser.webkit&&0===c)return!0;switch(c){case a.FE.KEYCODE.SPACE:case a.FE.KEYCODE.QUESTION_MARK:case a.FE.KEYCODE.NUM_PLUS:case a.FE.KEYCODE.NUM_MINUS:case a.FE.KEYCODE.NUM_PERIOD:case a.FE.KEYCODE.NUM_DIVISION:case a.FE.KEYCODE.SEMICOLON:case a.FE.KEYCODE.FF_SEMICOLON:case a.FE.KEYCODE.DASH:case a.FE.KEYCODE.EQUALS:case a.FE.KEYCODE.FF_EQUALS:case a.FE.KEYCODE.COMMA:case a.FE.KEYCODE.PERIOD:case a.FE.KEYCODE.SLASH:case a.FE.KEYCODE.APOSTROPHE:case a.FE.KEYCODE.SINGLE_QUOTE:case a.FE.KEYCODE.OPEN_SQUARE_BRACKET:case a.FE.KEYCODE.BACKSLASH:case a.FE.KEYCODE.CLOSE_SQUARE_BRACKET:return!0;default:return!1}}function u(c){var d=c.which;return r(c)||d>=37&&40>=d||!t(d)&&d!=a.FE.KEYCODE.DELETE&&d!=a.FE.KEYCODE.BACKSPACE&&d!=a.FE.KEYCODE.ENTER?!0:(z||(A=b.snapshot.get()),clearTimeout(z),void(z=setTimeout(function(){z=null,b.undo.saveStep()},Math.max(250,b.opts.typingTimer))))}function v(a){return r(a)?!0:void(A&&z&&(b.undo.saveStep(A),A=null))}function w(){z&&(clearTimeout(z),b.undo.saveStep(),A=null)}function x(){if(b.events.on(\\\"keydown\\\",u),b.events.on(\\\"input\\\",h),b.events.on(\\\"keyup input\\\",v),b.events.on(\\\"keypress\\\",k),b.events.on(\\\"keydown\\\",m),b.events.on(\\\"keyup\\\",q),b.events.on(\\\"html.inserted\\\",q),b.events.on(\\\"cut\\\",i),b.$el.get(0).msGetInputContext)try{b.$el.get(0).msGetInputContext().addEventListener(\\\"MSCandidateWindowShow\\\",function(){B=!0}),b.$el.get(0).msGetInputContext().addEventListener(\\\"MSCandidateWindowHide\\\",function(){B=!1,q()})}catch(a){}}var y,z,A,B=!1;return{_init:x,ctrlKey:r,isCharacter:t,isArrow:s,forceUndo:w,isIME:l}},a.extend(a.FE.DEFAULTS,{pastePlain:!1,pasteDeniedTags:[\\\"colgroup\\\",\\\"col\\\"],pasteDeniedAttrs:[\\\"class\\\",\\\"id\\\",\\\"style\\\"],pasteAllowLocalImages:!1}),a.FE.MODULES.paste=function(b){function c(c){a.FE.copied_html=b.html.getSelected(),a.FE.copied_text=a(\\\"<div>\\\").html(a.FE.copied_html).text(),\\\"cut\\\"==c.type&&(b.undo.saveStep(),setTimeout(function(){b.html.wrap(),b.events.focus(),b.undo.saveStep()},0))}function d(a){if(o)return!1;if(a.originalEvent&&(a=a.originalEvent),b.events.trigger(\\\"paste.before\\\",[a])===!1)return!1;if(l=b.$win.scrollTop(),a&&a.clipboardData&&a.clipboardData.getData){var c=\\\"\\\",d=a.clipboardData.types;if(b.helpers.isArray(d))for(var f=0;f<d.length;f++)c+=d[f]+\\\";\\\";else c=d;if(m=\\\"\\\",/text\\\\/html/.test(c)?m=a.clipboardData.getData(\\\"text/html\\\"):/text\\\\/rtf/.test(c)&&b.browser.safari?m=a.clipboardData.getData(\\\"text/rtf\\\"):/text\\\\/plain/.test(c)&&!this.browser.mozilla&&(m=b.html.escapeEntities(a.clipboardData.getData(\\\"text/plain\\\")).replace(/\\\\n/g,\\\"<br>\\\")),\\\"\\\"!==m)return h(),a.preventDefault&&(a.stopPropagation(),a.preventDefault()),!1;m=null}e()}function e(){b.selection.save(),b.events.disableBlur(),m=null,n?n.html(\\\"\\\"):(n=a('<div contenteditable=\\\"true\\\" style=\\\"position: fixed; top: 0; left: -9999px; height: 100%; width: 0; word-break: break-all; overflow:hidden; z-index: 9999; line-height: 140%;\\\" tabindex=\\\"-1\\\"></div>'),b.$box.after(n),b.events.on(\\\"destroy\\\",function(){n.remove()})),n.focus(),b.win.setTimeout(h,1)}function f(c){c=c.replace(/<p(.*?)class=\\\"?'?MsoListParagraph\\\"?'? ([\\\\s\\\\S]*?)>([\\\\s\\\\S]*?)<\\\\/p>/gi,\\\"<ul><li>$3</li></ul>\\\"),c=c.replace(/<p(.*?)class=\\\"?'?NumberedText\\\"?'? ([\\\\s\\\\S]*?)>([\\\\s\\\\S]*?)<\\\\/p>/gi,\\\"<ol><li>$3</li></ol>\\\"),c=c.replace(/<p(.*?)class=\\\"?'?MsoListParagraphCxSpFirst\\\"?'?([\\\\s\\\\S]*?)(level\\\\d)?([\\\\s\\\\S]*?)>([\\\\s\\\\S]*?)<\\\\/p>/gi,\\\"<ul><li$3>$5</li>\\\"),c=c.replace(/<p(.*?)class=\\\"?'?NumberedTextCxSpFirst\\\"?'?([\\\\s\\\\S]*?)(level\\\\d)?([\\\\s\\\\S]*?)>([\\\\s\\\\S]*?)<\\\\/p>/gi,\\\"<ol><li$3>$5</li>\\\"),c=c.replace(/<p(.*?)class=\\\"?'?MsoListParagraphCxSpMiddle\\\"?'?([\\\\s\\\\S]*?)(level\\\\d)?([\\\\s\\\\S]*?)>([\\\\s\\\\S]*?)<\\\\/p>/gi,\\\"<li$3>$5</li>\\\"),c=c.replace(/<p(.*?)class=\\\"?'?NumberedTextCxSpMiddle\\\"?'?([\\\\s\\\\S]*?)(level\\\\d)?([\\\\s\\\\S]*?)>([\\\\s\\\\S]*?)<\\\\/p>/gi,\\\"<li$3>$5</li>\\\"),c=c.replace(/<p(.*?)class=\\\"?'?MsoListBullet\\\"?'?([\\\\s\\\\S]*?)(level\\\\d)?([\\\\s\\\\S]*?)>([\\\\s\\\\S]*?)<\\\\/p>/gi,\\\"<li$3>$5</li>\\\"),c=c.replace(/<p(.*?)class=\\\"?'?MsoListParagraphCxSpLast\\\"?'?([\\\\s\\\\S]*?)(level\\\\d)?([\\\\s\\\\S]*?)>([\\\\s\\\\S]*?)<\\\\/p>/gi,\\\"<li$3>$5</li></ul>\\\"),c=c.replace(/<p(.*?)class=\\\"?'?NumberedTextCxSpLast\\\"?'?([\\\\s\\\\S]*?)(level\\\\d)?([\\\\s\\\\S]*?)>([\\\\s\\\\S]*?)<\\\\/p>/gi,\\\"<li$3>$5</li></ol>\\\"),c=c.replace(/<span([^<]*?)style=\\\"?'?mso-list:Ignore\\\"?'?([\\\\s\\\\S]*?)>([\\\\s\\\\S]*?)<span/gi,\\\"<span><span\\\"),c=c.replace(/<!--\\\\[if \\\\!supportLists\\\\]-->([\\\\s\\\\S]*?)<!--\\\\[endif\\\\]-->/gi,\\\"\\\"),c=c.replace(/<!\\\\[if \\\\!supportLists\\\\]>([\\\\s\\\\S]*?)<!\\\\[endif\\\\]>/gi,\\\"\\\"),c=c.replace(/(\\\\n|\\\\r| class=(\\\")?Mso[a-zA-Z0-9]+(\\\")?)/gi,\\\" \\\"),c=c.replace(/<!--[\\\\s\\\\S]*?-->/gi,\\\"\\\"),c=c.replace(/<(\\\\/)*(meta|link|span|\\\\\\\\?xml:|st1:|o:|font)(.*?)>/gi,\\\"\\\");for(var d=[\\\"style\\\",\\\"script\\\",\\\"applet\\\",\\\"embed\\\",\\\"noframes\\\",\\\"noscript\\\"],e=0;e<d.length;e++){var f=new RegExp(\\\"<\\\"+d[e]+\\\".*?\\\"+d[e]+\\\"(.*?)>\\\",\\\"gi\\\");c=c.replace(f,\\\"\\\")}c=c.replace(/&nbsp;/gi,\\\" \\\"),c=c.replace(/<td([^>]*)><\\\\/td>/g,\\\"<td$1><br></td>\\\"),c=c.replace(/<th([^>]*)><\\\\/th>/g,\\\"<th$1><br></th>\\\");var g;do g=c,c=c.replace(/<[^\\\\/>][^>]*><\\\\/[^>]+>/gi,\\\"\\\");while(c!=g);c=c.replace(/<lilevel([^1])([^>]*)>/gi,'<li data-indent=\\\"true\\\"$2>'),c=c.replace(/<lilevel1([^>]*)>/gi,\\\"<li$1>\\\"),c=b.clean.html(c,b.opts.pasteDeniedTags,b.opts.pasteDeniedAttrs),c=c.replace(/<a>(.[^<]+)<\\\\/a>/gi,\\\"$1\\\"),c=c.replace(/<br> */g,\\\"<br>\\\");var h=a(\\\"<div>\\\").html(c);return h.find(\\\"li[data-indent]\\\").each(function(b,c){var d=a(c);if(d.prev(\\\"li\\\").length>0){var e=d.prev(\\\"li\\\").find(\\\"> ul, > ol\\\");0===e.length&&(e=a(\\\"ul\\\"),d.prev(\\\"li\\\").append(e)),e.append(c)}else d.removeAttr(\\\"data-indent\\\")}),b.html.cleanBlankSpaces(h.get(0)),c=h.html()}function g(c){var d=a(\\\"<div>\\\").html(c);d.find(\\\"p, div, h1, h2, h3, h4, h5, h6, pre, blockquote\\\").each(function(c,d){a(d).replaceWith(\\\"<\\\"+(b.html.defaultTag()||\\\"DIV\\\")+\\\">\\\"+a(d).html()+\\\"</\\\"+(b.html.defaultTag()||\\\"DIV\\\")+\\\">\\\")}),a(d.find(\\\"*\\\").not(\\\"p, div, h1, h2, h3, h4, h5, h6, pre, blockquote, ul, ol, li, table, tbody, thead, tr, td, br, img\\\").get().reverse()).each(function(){a(this).replaceWith(a(this).html())});var e=function(c){for(var d=b.node.contents(c),f=0;f<d.length;f++)3!=d[f].nodeType&&1!=d[f].nodeType?a(d[f]).remove():e(d[f])};return e(d.get(0)),d.html()}function h(){b.keys.forceUndo();var c=b.snapshot.get();null===m&&(m=n.html(),b.selection.restore(),b.events.enableBlur());var d=b.events.chainTrigger(\\\"paste.beforeCleanup\\\",m);\\\"string\\\"==typeof d&&(m=d);var e=!1;m.match(/(class=\\\\\\\"?Mso|class=\\\\'?Mso|style=\\\\\\\"[^\\\\\\\"]*\\\\bmso\\\\-|style=\\\\'[^\\\\']*\\\\bmso\\\\-|w:WordDocument)/gi)&&(e=!0),m.indexOf(\\\"<body\\\")>=0&&(m=m.replace(/[.\\\\s\\\\S\\\\w\\\\W<>]*<body[^>]*>([.\\\\s\\\\S\\\\w\\\\W<>]*)<\\\\/body>[.\\\\s\\\\S\\\\w\\\\W<>]*/g,\\\"$1\\\"));var h=!1;if(m.indexOf('id=\\\"docs-internal-guid')>=0&&(m=m.replace(/^.* id=\\\"docs-internal-guid[^>]*>(.*)<\\\\/b>.*$/,\\\"$1\\\"),h=!0),e?(m=m.replace(/^\\\\n*/g,\\\"\\\").replace(/^ /g,\\\"\\\"),0===m.indexOf(\\\"<colgroup>\\\")&&(m=\\\"<table>\\\"+m+\\\"</table>\\\"),m=f(m),m=j(m)):(b.opts.htmlAllowComments=!1,m=b.clean.html(m,b.opts.pasteDeniedTags,b.opts.pasteDeniedAttrs),b.opts.htmlAllowComments=!0,m=j(m),m=m.replace(/\\\\r|\\\\n|\\\\t/g,\\\"\\\"),a.FE.copied_text&&a(\\\"<div>\\\").html(m).text().replace(/(\\\\u00A0)/gi,\\\" \\\").replace(/\\\\r|\\\\n/gi,\\\"\\\")==a.FE.copied_text.replace(/(\\\\u00A0)/gi,\\\" \\\").replace(/\\\\r|\\\\n/gi,\\\"\\\")&&(m=a.FE.copied_html),m=m.replace(/^ */g,\\\"\\\").replace(/ *$/g,\\\"\\\")),b.opts.pastePlain&&(m=g(m)),d=b.events.chainTrigger(\\\"paste.afterCleanup\\\",m),\\\"string\\\"==typeof d&&(m=d),\\\"\\\"!==m){var k=a(\\\"<div>\\\").html(m);b.spaces.normalize(k.get(0)),k.find(\\\"span\\\").each(function(){0==this.attributes.length&&a(this).replaceWith(this.innerHTML)}),h||k.find(\\\"br\\\").each(function(){this.previousSibling&&b.node.isBlock(this.previousSibling)&&a(this).remove()}),b.opts.enter==a.FE.ENTER_BR?k.find(\\\"p, div\\\").each(function(b,c){a(c).replaceWith(a(c).html()+(c.nextSibling?\\\"<br>\\\":\\\"\\\"))}):b.opts.enter==a.FE.ENTER_DIV&&k.find(\\\"p\\\").each(function(b,c){a(c).replaceWith(\\\"<div>\\\"+c.innerHTML+\\\"</div>\\\")}),m=k.html(),b.html.insert(m,!0)}i(),b.undo.saveStep(c),b.undo.saveStep()}function i(){b.events.trigger(\\\"paste.after\\\")}function j(c){for(var d,e=a(\\\"<div>\\\").html(c),f=e.find(\\\"*:empty:not(br, img, td, th)\\\");f.length;){for(d=0;d<f.length;d++)a(f[d]).remove();f=e.find(\\\"*:empty:not(br, img, td, th)\\\")}for(var g=e.find(\\\"> div:not([style]), td > div, th > div, li > div\\\");g.length&&d++<100;){var h=a(g[g.length-1]);b.html.defaultTag()&&\\\"div\\\"!=b.html.defaultTag()?h.replaceWith(\\\"<\\\"+b.html.defaultTag()+\\\">\\\"+h.html()+\\\"</\\\"+b.html.defaultTag()+\\\">\\\"):h.find(\\\"*:last\\\").is(\\\"br\\\")?h.replaceWith(h.html()):h.replaceWith(h.html()+\\\"<br>\\\"),g=e.find(\\\"> div:not([style]), td > div, th > div, li > div\\\")}for(g=e.find(\\\"div:not([style])\\\");g.length;){for(d=0;d<g.length;d++){var i=a(g[d]),j=i.html().replace(/\\\\u0009/gi,\\\"\\\").trim();i.replaceWith(j)}g=e.find(\\\"div:not([style])\\\")}return e.html()}function k(){b.events.on(\\\"copy\\\",c),b.events.on(\\\"cut\\\",c),b.events.on(\\\"paste\\\",d),b.browser.msie&&b.browser.version<11&&(b.events.on(\\\"mouseup\\\",function(a){2==a.button&&(setTimeout(function(){o=!1},50),o=!0)},!0),b.events.on(\\\"beforepaste\\\",d))}var l,m,n,o=!1;return{_init:k}},a.extend(a.FE.DEFAULTS,{shortcutsEnabled:[\\\"show\\\",\\\"bold\\\",\\\"italic\\\",\\\"underline\\\",\\\"strikeThrough\\\",\\\"indent\\\",\\\"outdent\\\",\\\"undo\\\",\\\"redo\\\"],shortcutsHint:!0}),a.FE.SHORTCUTS_MAP={},a.FE.RegisterShortcut=function(b,c,d,e,f,g){a.FE.SHORTCUTS_MAP[(f?\\\"^\\\":\\\"\\\")+(g?\\\"@\\\":\\\"\\\")+b]={cmd:c,val:d,letter:e,shift:f,option:g},a.FE.DEFAULTS.shortcutsEnabled.push(c)},a.FE.RegisterShortcut(a.FE.KEYCODE.E,\\\"show\\\",null,\\\"E\\\",!1,!1),a.FE.RegisterShortcut(a.FE.KEYCODE.B,\\\"bold\\\",null,\\\"B\\\",!1,!1),a.FE.RegisterShortcut(a.FE.KEYCODE.I,\\\"italic\\\",null,\\\"I\\\",!1,!1),a.FE.RegisterShortcut(a.FE.KEYCODE.U,\\\"underline\\\",null,\\\"U\\\",!1,!1),a.FE.RegisterShortcut(a.FE.KEYCODE.S,\\\"strikeThrough\\\",null,\\\"S\\\",!1,!1),a.FE.RegisterShortcut(a.FE.KEYCODE.CLOSE_SQUARE_BRACKET,\\\"indent\\\",null,\\\"]\\\",!1,!1),a.FE.RegisterShortcut(a.FE.KEYCODE.OPEN_SQUARE_BRACKET,\\\"outdent\\\",null,\\\"[\\\",!1,!1),a.FE.RegisterShortcut(a.FE.KEYCODE.Z,\\\"undo\\\",null,\\\"Z\\\",!1,!1),a.FE.RegisterShortcut(a.FE.KEYCODE.Z,\\\"redo\\\",null,\\\"Z\\\",!0,!1),a.FE.MODULES.shortcuts=function(b){function c(c){if(!b.opts.shortcutsHint)return null;if(!f){f={};for(var d in a.FE.SHORTCUTS_MAP)a.FE.SHORTCUTS_MAP.hasOwnProperty(d)&&b.opts.shortcutsEnabled.indexOf(a.FE.SHORTCUTS_MAP[d].cmd)>=0&&(f[a.FE.SHORTCUTS_MAP[d].cmd+\\\".\\\"+(a.FE.SHORTCUTS_MAP[d].val||\\\"\\\")]={shift:a.FE.SHORTCUTS_MAP[d].shift,option:a.FE.SHORTCUTS_MAP[d].option,letter:a.FE.SHORTCUTS_MAP[d].letter})}var e=f[c];return e?(b.helpers.isMac()?String.fromCharCode(8984):\\\"Ctrl+\\\")+(e.shift?b.helpers.isMac()?String.fromCharCode(8679):\\\"Shift+\\\":\\\"\\\")+(e.option?b.helpers.isMac()?String.fromCharCode(8997):\\\"Alt+\\\":\\\"\\\")+e.letter:null}function d(c){if(!b.core.hasFocus())return!0;var d=c.which,e=-1!=navigator.userAgent.indexOf(\\\"Mac OS X\\\")?c.metaKey:c.ctrlKey,f=(c.shiftKey?\\\"^\\\":\\\"\\\")+(c.altKey?\\\"@\\\":\\\"\\\")+d;if(e&&a.FE.SHORTCUTS_MAP[f]){var g=a.FE.SHORTCUTS_MAP[f].cmd;if(g&&b.opts.shortcutsEnabled.indexOf(g)>=0){var h,i=a.FE.SHORTCUTS_MAP[f].val;if(g&&!i?h=b.$tb.find('.fr-command[data-cmd=\\\"'+g+'\\\"]'):g&&i&&(h=b.$tb.find('.fr-command[data-cmd=\\\"'+g+'\\\"][data-param1=\\\"'+i+'\\\"]')),h.length)return c.preventDefault(),c.stopPropagation(),h.parents(\\\".fr-toolbar\\\").data(\\\"instance\\\",b),\\\"keydown\\\"==c.type&&b.button.exec(h),!1;if(g&&b.commands[g])return c.preventDefault(),c.stopPropagation(),\\\"keydown\\\"==c.type&&b.commands[g](),!1}}}function e(){b.events.on(\\\"keydown\\\",d,!0),b.events.on(\\\"keyup\\\",d,!0)}var f=null;return{_init:e,get:c}},a.FE.MODULES.snapshot=function(a){function b(a){for(var b=a.parentNode.childNodes,c=0,d=null,e=0;e<b.length;e++){if(d){var f=b[e].nodeType===Node.TEXT_NODE&&\\\"\\\"===b[e].textContent,g=d.nodeType===Node.TEXT_NODE&&b[e].nodeType===Node.TEXT_NODE;f||g||c++}if(b[e]==a)return c;d=b[e]}}function c(c){var d=[];if(!c.parentNode)return[];for(;!a.node.isElement(c);)d.push(b(c)),c=c.parentNode;return d.reverse()}function d(a,b){for(;a&&a.nodeType===Node.TEXT_NODE;){var c=a.previousSibling;c&&c.nodeType==Node.TEXT_NODE&&(b+=c.textContent.length),a=c}return b}function e(a){return{scLoc:c(a.startContainer),scOffset:d(a.startContainer,a.startOffset),ecLoc:c(a.endContainer),ecOffset:d(a.endContainer,a.endOffset)}}function f(){var b={};if(a.events.trigger(\\\"snapshot.before\\\"),b.html=(a.$wp?a.$el.html():a.$oel.get(0).outerHTML).replace(/ style=\\\"\\\"/g,\\\"\\\"),b.ranges=[],a.$wp&&a.selection.inEditor()&&a.core.hasFocus())for(var c=a.selection.ranges(),d=0;d<c.length;d++)b.ranges.push(e(c[d]));return a.events.trigger(\\\"snapshot.after\\\"),b}function g(b){for(var c=a.$el.get(0),d=0;d<b.length;d++)c=c.childNodes[b[d]];return c}function h(b,c){try{var d=g(c.scLoc),e=c.scOffset,f=g(c.ecLoc),h=c.ecOffset,i=a.doc.createRange();i.setStart(d,e),i.setEnd(f,h),b.addRange(i)}catch(j){}}function i(b){a.$el.html()!=b.html&&a.$el.html(b.html);var c=a.selection.get();a.selection.clear(),a.events.focus(!0);for(var d=0;d<b.ranges.length;d++)h(c,b.ranges[d])}function j(b,c){return b.html!=c.html?!1:a.core.hasFocus()&&JSON.stringify(b.ranges)!=JSON.stringify(c.ranges)?!1:!0}return{get:f,restore:i,equal:j}},a.FE.MODULES.undo=function(a){function b(b){var c=b.which,d=a.keys.ctrlKey(b);d&&(90==c&&b.shiftKey&&b.preventDefault(),90==c&&b.preventDefault())}function c(){return 0===a.undo_stack.length||a.undo_index<=1?!1:!0}function d(){return a.undo_index==a.undo_stack.length?!1:!0}function e(b){return!a.undo_stack||a.undoing||a.$el.get(0).querySelectorAll(\\\".fr-marker\\\").length?!1:void(\\\"undefined\\\"==typeof b?(b=a.snapshot.get(),a.undo_stack[a.undo_index-1]&&a.snapshot.equal(a.undo_stack[a.undo_index-1],b)||(f(),a.undo_stack.push(b),a.undo_index++,b.html!=l&&(a.events.trigger(\\\"contentChanged\\\"),l=b.html))):(f(),a.undo_index>0?a.undo_stack[a.undo_index-1]=b:(a.undo_stack.push(b),a.undo_index++)))}function f(){if(!a.undo_stack||a.undoing)return!1;for(;a.undo_stack.length>a.undo_index;)a.undo_stack.pop()}function g(){if(a.undo_index>1){a.undoing=!0;var b=a.undo_stack[--a.undo_index-1];clearTimeout(a._content_changed_timer),a.snapshot.restore(b),l=b.html,a.popups.hideAll(),a.toolbar.enable(),a.events.trigger(\\\"contentChanged\\\"),a.events.trigger(\\\"commands.undo\\\"),a.undoing=!1}}function h(){if(a.undo_index<a.undo_stack.length){a.undoing=!0;var b=a.undo_stack[a.undo_index++];clearTimeout(a._content_changed_timer),a.snapshot.restore(b),l=b.html,a.popups.hideAll(),a.toolbar.enable(),a.events.trigger(\\\"contentChanged\\\"),a.events.trigger(\\\"commands.redo\\\"),a.undoing=!1}}function i(){a.undo_index=0,a.undo_stack=[]}function j(){a.undo_stack=[]}function k(){i(),a.events.on(\\\"initialized\\\",function(){l=(a.$wp?a.$el.html():a.$oel.get(0).outerHTML).replace(/ style=\\\"\\\"/g,\\\"\\\")}),a.events.on(\\\"blur\\\",function(){a.undo.saveStep()}),a.events.on(\\\"keydown\\\",b),a.events.on(\\\"destroy\\\",j)}var l=null;return{_init:k,run:g,redo:h,canDo:c,canRedo:d,dropRedo:f,reset:i,saveStep:e}},a.FE.ICON_DEFAULT_TEMPLATE=\\\"font_awesome\\\",a.FE.ICON_TEMPLATES={font_awesome:'<i class=\\\"fa fa-[NAME]\\\"></i>',text:'<span style=\\\"text-align: center;\\\">[NAME]</span>',image:\\\"<img src=[SRC] alt=[ALT] />\\\",svg:'<svg viewBox=\\\"0 0 32 32\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\">[PATH]</svg>'},a.FE.ICONS={bold:{NAME:\\\"bold\\\"},italic:{NAME:\\\"italic\\\"},underline:{NAME:\\\"underline\\\"},strikeThrough:{NAME:\\\"strikethrough\\\"},subscript:{NAME:\\\"subscript\\\"},superscript:{NAME:\\\"superscript\\\"},color:{NAME:\\\"tint\\\"},outdent:{NAME:\\\"outdent\\\"},indent:{NAME:\\\"indent\\\"},undo:{NAME:\\\"rotate-left\\\"},redo:{NAME:\\\"rotate-right\\\"},insertHR:{NAME:\\\"minus\\\"},clearFormatting:{NAME:\\\"eraser\\\"},selectAll:{NAME:\\\"mouse-pointer\\\"}},a.FE.DefineIconTemplate=function(b,c){a.FE.ICON_TEMPLATES[b]=c},a.FE.DefineIcon=function(b,c){a.FE.ICONS[b]=c},a.FE.MODULES.icon=function(b){function c(b){var c=null,d=a.FE.ICONS[b];if(\\\"undefined\\\"!=typeof d){var e=d.template||a.FE.ICON_DEFAULT_TEMPLATE;e&&(e=a.FE.ICON_TEMPLATES[e])&&(c=e.replace(/\\\\[([a-zA-Z]*)\\\\]/g,function(a,c){return\\\"NAME\\\"==c?d[c]||b:d[c]}))}return c||b}function d(b){var c=a.FE.ICONS[b],d=\\\"\\\";if(\\\"undefined\\\"!=typeof c){var d=c.template||a.FE.ICON_DEFAULT_TEMPLATE;return d}return d}return{create:c,getTemplate:d}},a.extend(a.FE.DEFAULTS,{tooltips:!0}),a.FE.MODULES.tooltip=function(b){function c(){b.$tooltip&&b.$tooltip.removeClass(\\\"fr-visible\\\").css(\\\"left\\\",\\\"-3000px\\\").css(\\\"position\\\",\\\"fixed\\\")}function d(c,d){if(c.data(\\\"title\\\")||c.data(\\\"title\\\",c.attr(\\\"title\\\")),!c.data(\\\"title\\\"))return!1;b.$tooltip||f(),c.removeAttr(\\\"title\\\"),b.$tooltip.text(c.data(\\\"title\\\")),b.$tooltip.addClass(\\\"fr-visible\\\");var e=c.offset().left+(c.outerWidth()-b.$tooltip.outerWidth())/2;\\n0>e&&(e=0),e+b.$tooltip.outerWidth()>a(b.o_win).width()&&(e=a(b.o_win).width()-b.$tooltip.outerWidth()),\\\"undefined\\\"==typeof d&&(d=b.opts.toolbarBottom);var g=d?c.offset().top-b.$tooltip.height():c.offset().top+c.outerHeight();b.$tooltip.css(\\\"position\\\",\\\"\\\"),b.$tooltip.css(\\\"left\\\",e),b.$tooltip.css(\\\"top\\\",Math.ceil(g)),\\\"static\\\"!=a(b.o_doc).find(\\\"body\\\").css(\\\"position\\\")?(b.$tooltip.css(\\\"margin-left\\\",-a(b.o_doc).find(\\\"body\\\").offset().left),b.$tooltip.css(\\\"margin-top\\\",-a(b.o_doc).find(\\\"body\\\").offset().top)):(b.$tooltip.css(\\\"margin-left\\\",\\\"\\\"),b.$tooltip.css(\\\"margin-top\\\",\\\"\\\"))}function e(e,f,g){b.opts.tooltips&&!b.helpers.isMobile()&&(b.events.$on(e,\\\"mouseenter\\\",f,function(c){a(c.currentTarget).hasClass(\\\"fr-disabled\\\")||b.edit.isDisabled()||d(a(c.currentTarget),g)},!0),b.events.$on(e,\\\"mouseleave \\\"+b._mousedown+\\\" \\\"+b._mouseup,f,function(a){c()},!0))}function f(){b.opts.tooltips&&!b.helpers.isMobile()&&(b.shared.$tooltip?b.$tooltip=b.shared.$tooltip:(b.shared.$tooltip=a('<div class=\\\"fr-tooltip\\\"></div>'),b.$tooltip=b.shared.$tooltip,b.opts.theme&&b.$tooltip.addClass(b.opts.theme+\\\"-theme\\\"),a(b.o_doc).find(\\\"body\\\").append(b.$tooltip)),b.events.on(\\\"shared.destroy\\\",function(){b.$tooltip.html(\\\"\\\").removeData().remove(),b.$tooltip=null},!0))}return{hide:c,to:d,bind:e}},a.FE.MODULES.button=function(b){function c(c){var d=a(c.currentTarget),e=d.next(),f=d.hasClass(\\\"fr-active\\\"),g=(b.helpers.isMobile(),a(\\\".fr-dropdown.fr-active\\\").not(d)),h=d.parents(\\\".fr-toolbar, .fr-popup\\\").data(\\\"instance\\\")||b;if(h.helpers.isIOS()&&0==h.$el.get(0).querySelectorAll(\\\".fr-marker\\\").length&&(h.selection.save(),h.selection.clear(),h.selection.restore()),!f){var i=d.data(\\\"cmd\\\");e.find(\\\".fr-command\\\").removeClass(\\\"fr-active\\\"),a.FE.COMMANDS[i]&&a.FE.COMMANDS[i].refreshOnShow&&a.FE.COMMANDS[i].refreshOnShow.apply(h,[d,e]),e.css(\\\"left\\\",d.offset().left-d.parent().offset().left-(\\\"rtl\\\"==b.opts.direction?e.width()-d.outerWidth():0)),b.opts.toolbarBottom?e.css(\\\"bottom\\\",b.$tb.height()-d.position().top):e.css(\\\"top\\\",d.position().top+d.outerHeight())}d.addClass(\\\"fr-blink\\\").toggleClass(\\\"fr-active\\\"),setTimeout(function(){d.removeClass(\\\"fr-blink\\\")},300),e.offset().left+e.outerWidth()>a(b.opts.scrollableContainer).offset().left+a(b.opts.scrollableContainer).outerWidth()&&e.css(\\\"margin-left\\\",-(e.offset().left+e.outerWidth()-a(b.opts.scrollableContainer).offset().left-a(b.opts.scrollableContainer).outerWidth())),g.removeClass(\\\"fr-active\\\"),g.parent(\\\".fr-toolbar:not(.fr-inline)\\\").css(\\\"zIndex\\\",\\\"\\\"),0!=d.parents(\\\".fr-popup\\\").length||b.opts.toolbarInline||(d.hasClass(\\\"fr-active\\\")?b.$tb.css(\\\"zIndex\\\",(b.opts.zIndex||1)+4):b.$tb.css(\\\"zIndex\\\",\\\"\\\"))}function d(b){b.addClass(\\\"fr-blink\\\"),setTimeout(function(){b.removeClass(\\\"fr-blink\\\")},500);for(var c=b.data(\\\"cmd\\\"),d=[];\\\"undefined\\\"!=typeof b.data(\\\"param\\\"+(d.length+1));)d.push(b.data(\\\"param\\\"+(d.length+1)));var e=a(\\\".fr-dropdown.fr-active\\\");e.length&&(e.removeClass(\\\"fr-active\\\"),e.parent(\\\".fr-toolbar:not(.fr-inline)\\\").css(\\\"zIndex\\\",\\\"\\\")),b.parents(\\\".fr-popup, .fr-toolbar\\\").data(\\\"instance\\\").commands.exec(c,d)}function e(b){var c=a(b.currentTarget);d(c)}function f(b){var d=a(b.currentTarget),f=d.parents(\\\".fr-popup, .fr-toolbar\\\").data(\\\"instance\\\");if(0!=d.parents(\\\".fr-popup\\\").length||d.data(\\\"popup\\\")||f.popups.hideAll(),f.popups.areVisible()&&!f.popups.areVisible(f)){for(var g=0;g<a.FE.INSTANCES.length;g++)a.FE.INSTANCES[g]!=f&&a.FE.INSTANCES[g].popups&&a.FE.INSTANCES[g].popups.areVisible()&&a.FE.INSTANCES[g].$el.find(\\\".fr-marker\\\").remove();f.popups.hideAll()}d.hasClass(\\\"fr-dropdown\\\")?c(b):(e(b),a.FE.COMMANDS[d.data(\\\"cmd\\\")]&&0!=a.FE.COMMANDS[d.data(\\\"cmd\\\")].refreshAfterCallback&&f.button.bulkRefresh())}function g(a){var b=a.find(\\\".fr-dropdown.fr-active\\\");b.length&&(b.removeClass(\\\"fr-active\\\"),b.parent(\\\".fr-toolbar:not(.fr-inline)\\\").css(\\\"zIndex\\\",\\\"\\\"))}function h(a){a.preventDefault(),a.stopPropagation()}function i(a){return a.stopPropagation(),b.helpers.isMobile()?void 0:!1}function j(c,d){b.events.bindClick(c,\\\".fr-command:not(.fr-disabled)\\\",f),b.events.$on(c,b._mousedown+\\\" \\\"+b._mouseup+\\\" \\\"+b._move,\\\".fr-dropdown-menu\\\",h,!0),b.events.$on(c,b._mousedown+\\\" \\\"+b._mouseup+\\\" \\\"+b._move,\\\".fr-dropdown-menu .fr-dropdown-wrapper\\\",i,!0);var e=c.get(0).ownerDocument,j=\\\"defaultView\\\"in e?e.defaultView:e.parentWindow,k=function(d){(!d||d.type==b._mouseup&&d.target!=a(\\\"html\\\").get(0)||\\\"keydown\\\"==d.type&&(b.keys.isCharacter(d.which)&&!b.keys.ctrlKey(d)||d.which==a.FE.KEYCODE.ESC))&&g(c)};b.events.$on(a(j),b._mouseup+\\\" resize keydown\\\",k,!0),b.opts.iframe&&b.events.$on(b.$win,b._mouseup,k,!0),c.hasClass(\\\"fr-popup\\\")?a.merge(t,c.find(\\\".fr-btn\\\").toArray()):a.merge(s,c.find(\\\".fr-btn\\\").toArray()),b.tooltip.bind(c,\\\".fr-btn, .fr-title\\\",d)}function k(a,c){var d=\\\"\\\";if(c.html)d+=\\\"function\\\"==typeof c.html?c.html.call(b):c.html;else{var e=c.options;\\\"function\\\"==typeof e&&(e=e()),d+='<ul class=\\\"fr-dropdown-list\\\">';for(var f in e)if(e.hasOwnProperty(f)){var g=b.shortcuts.get(a+\\\".\\\"+f);g=g?'<span class=\\\"fr-shortcut\\\">'+g+\\\"</span>\\\":\\\"\\\",d+='<li><a class=\\\"fr-command\\\" data-cmd=\\\"'+a+'\\\" data-param1=\\\"'+f+'\\\" title=\\\"'+e[f]+'\\\">'+b.language.translate(e[f])+\\\"</a></li>\\\"}d+=\\\"</ul>\\\"}return d}function l(a,c,d){var e=c.displaySelection;\\\"function\\\"==typeof e&&(e=e(b));var f;if(e){var g=\\\"function\\\"==typeof c.defaultSelection?c.defaultSelection(b):c.defaultSelection;f='<span style=\\\"width:'+(c.displaySelectionWidth||100)+'px\\\">'+(g||b.language.translate(c.title))+\\\"</span>\\\"}else f=b.icon.create(c.icon||a);var h=c.popup?' data-popup=\\\"true\\\"':\\\"\\\",i=b.shortcuts.get(a+\\\".\\\");i=i?\\\" (\\\"+i+\\\")\\\":\\\"\\\";var j='<button type=\\\"button\\\" tabindex=\\\"-1\\\" aria-label=\\\"'+(b.language.translate(c.title)||\\\"\\\")+'\\\" title=\\\"'+(b.language.translate(c.title)||\\\"\\\")+i+'\\\" class=\\\"fr-command fr-btn'+(\\\"dropdown\\\"==c.type?\\\" fr-dropdown\\\":\\\"\\\")+(\\\" fr-btn-\\\"+b.icon.getTemplate(c.icon))+(c.displaySelection?\\\" fr-selection\\\":\\\"\\\")+(c.back?\\\" fr-back\\\":\\\"\\\")+(c.disabled?\\\" fr-disabled\\\":\\\"\\\")+(d?\\\"\\\":\\\" fr-hidden\\\")+'\\\" data-cmd=\\\"'+a+'\\\"'+h+\\\">\\\"+f+\\\"</button>\\\";if(\\\"dropdown\\\"==c.type){var l='<div class=\\\"fr-dropdown-menu\\\"><div class=\\\"fr-dropdown-wrapper\\\"><div class=\\\"fr-dropdown-content\\\">';l+=k(a,c),l+=\\\"</div></div></div>\\\",j+=l}return j}function m(c,d){for(var e=\\\"\\\",f=0;f<c.length;f++){var g=c[f],h=a.FE.COMMANDS[g];if(!(h&&\\\"undefined\\\"!=typeof h.plugin&&b.opts.pluginsEnabled.indexOf(h.plugin)<0))if(h){var i=\\\"undefined\\\"!=typeof d?d.indexOf(g)>=0:!0;e+=l(g,h,i)}else\\\"|\\\"==g?e+='<div class=\\\"fr-separator fr-vs\\\"></div>':\\\"-\\\"==g&&(e+='<div class=\\\"fr-separator fr-hs\\\"></div>')}return e}function n(c){var d,e=c.parents(\\\".fr-popup, .fr-toolbar\\\").data(\\\"instance\\\")||b,f=c.data(\\\"cmd\\\");c.hasClass(\\\"fr-dropdown\\\")?d=c.next():c.removeClass(\\\"fr-active\\\"),a.FE.COMMANDS[f]&&a.FE.COMMANDS[f].refresh?a.FE.COMMANDS[f].refresh.apply(e,[c,d]):b.refresh[f]&&e.refresh[f](c,d)}function o(c){var d=b.$tb?b.$tb.data(\\\"instance\\\")||b:b;return 0==b.events.trigger(\\\"buttons.refresh\\\")?!0:void setTimeout(function(){for(var b=d.selection.inEditor()&&d.core.hasFocus(),e=0;e<c.length;e++){var f=a(c[e]),g=f.data(\\\"cmd\\\");0==f.parents(\\\".fr-popup\\\").length?b||a.FE.COMMANDS[g]&&a.FE.COMMANDS[g].forcedRefresh?d.button.refresh(f):f.hasClass(\\\"fr-dropdown\\\")||f.removeClass(\\\"fr-active\\\"):f.parents(\\\".fr-popup\\\").is(\\\":visible\\\")&&d.button.refresh(f)}},0)}function p(){o(s),o(t)}function q(){s=[],t=[]}function r(){b.opts.toolbarInline?b.events.on(\\\"toolbar.show\\\",p):(b.events.on(\\\"mouseup\\\",p),b.events.on(\\\"keyup\\\",p),b.events.on(\\\"blur\\\",p),b.events.on(\\\"focus\\\",p),b.events.on(\\\"contentChanged\\\",p)),b.events.on(\\\"shared.destroy\\\",q)}var s=[];(b.opts.toolbarInline||b.opts.toolbarContainer)&&(b.shared.buttons||(b.shared.buttons=[]),s=b.shared.buttons);var t=[];return b.shared.popup_buttons||(b.shared.popup_buttons=[]),t=b.shared.popup_buttons,{_init:r,buildList:m,bindCommands:j,refresh:n,bulkRefresh:p,exec:d}},a.FE.POPUP_TEMPLATES={\\\"text.edit\\\":\\\"[_EDIT_]\\\"},a.FE.RegisterTemplate=function(b,c){a.FE.POPUP_TEMPLATES[b]=c},a.FE.MODULES.popups=function(b){function c(c,d){d.is(\\\":visible\\\")||(d=a(b.opts.scrollableContainer)),d.is(x[c].data(\\\"container\\\"))||(x[c].data(\\\"container\\\",d),d.append(x[c]))}function d(d,e,h,i){if(g()&&b.$el.find(\\\".fr-marker\\\").length>0&&(b.events.disableBlur(),b.selection.restore()),m([d]),!x[d])return!1;a(\\\".fr-dropdown.fr-active\\\").removeClass(\\\"fr-active\\\").parent(\\\".fr-toolbar\\\").css(\\\"zIndex\\\",\\\"\\\"),x[d].data(\\\"instance\\\",b),b.$tb&&b.$tb.data(\\\"instance\\\",b);var j=x[d].outerWidth(),k=(x[d].outerHeight(),f(d));x[d].addClass(\\\"fr-active\\\").removeClass(\\\"fr-hidden\\\").find(\\\"input, textarea\\\").removeAttr(\\\"disabled\\\");var l=x[d].data(\\\"container\\\");b.opts.toolbarInline&&l&&b.$tb&&l.get(0)==b.$tb.get(0)&&(c(d,a(b.opts.scrollableContainer)),h=b.$tb.offset().top-b.helpers.getPX(b.$tb.css(\\\"margin-top\\\")),e=b.$tb.offset().left+b.$tb.outerWidth()/2+(parseFloat(b.$tb.find(\\\".fr-arrow\\\").css(\\\"margin-left\\\"))||0)+b.$tb.find(\\\".fr-arrow\\\").outerWidth()/2,b.$tb.hasClass(\\\"fr-above\\\")&&h&&(h+=b.$tb.outerHeight()),i=0),l=x[d].data(\\\"container\\\"),!b.opts.iframe||i||k||(e&&(e-=b.$iframe.offset().left),h&&(h-=b.$iframe.offset().top)),l.is(b.$tb)?b.$tb.css(\\\"zIndex\\\",(b.opts.zIndex||1)+4):x[d].css(\\\"zIndex\\\",(b.opts.zIndex||1)+4),e&&(e-=j/2),b.opts.toolbarBottom&&l&&b.$tb&&l.get(0)==b.$tb.get(0)&&(x[d].addClass(\\\"fr-above\\\"),h&&(h-=x[d].outerHeight())),x[d].removeClass(\\\"fr-active\\\"),b.position.at(e,h,x[d],i||0),x[d].addClass(\\\"fr-active\\\");var n=x[d].find(\\\"input:visible, textarea:visible\\\").get(0);n&&(0==b.$el.find(\\\".fr-marker\\\").length&&b.core.hasFocus()&&b.selection.save(),b.events.disableBlur(),a(n).select().focus()),b.opts.toolbarInline&&b.toolbar.hide(),b.events.trigger(\\\"popups.show.\\\"+d),s(d)._repositionPopup(),o()}function e(a,c){b.events.on(\\\"popups.show.\\\"+a,c)}function f(a){return x[a]&&x[a].hasClass(\\\"fr-active\\\")&&b.core.sameInstance(x[a])||!1}function g(a){for(var b in x)if(x.hasOwnProperty(b)&&f(b)&&(\\\"undefined\\\"==typeof a||x[b].data(\\\"instance\\\")==a))return!0;return!1}function h(a){x[a]&&x[a].hasClass(\\\"fr-active\\\")&&(x[a].removeClass(\\\"fr-active fr-above\\\"),b.events.trigger(\\\"popups.hide.\\\"+a),b.$tb&&(b.opts.zIndex>1?b.$tb.css(\\\"zIndex\\\",b.opts.zIndex+1):b.$tb.css(\\\"zIndex\\\",\\\"\\\")),b.events.disableBlur(),x[a].find(\\\"input, textarea, button\\\").filter(\\\":focus\\\").blur(),x[a].find(\\\"input, textarea\\\").attr(\\\"disabled\\\",\\\"disabled\\\"))}function i(a,c){b.events.on(\\\"popups.hide.\\\"+a,c)}function j(a){var c=x[a];if(c&&!c.data(\\\"inst\\\"+b.id)){var d=s(a);t(d,a)}return c}function k(a,c){b.events.on(\\\"popups.refresh.\\\"+a,c)}function l(c){b.events.trigger(\\\"popups.refresh.\\\"+c);for(var d=x[c].find(\\\".fr-command\\\"),e=0;e<d.length;e++){var f=a(d[e]);0==f.parents(\\\".fr-dropdown-menu\\\").length&&b.button.refresh(f)}}function m(a){\\\"undefined\\\"==typeof a&&(a=[]);for(var b in x)x.hasOwnProperty(b)&&a.indexOf(b)<0&&h(b)}function n(){b.shared.exit_flag=!0}function o(){b.shared.exit_flag=!1}function p(){return b.shared.exit_flag}function q(c,d){var e=a.FE.POPUP_TEMPLATES[c];\\\"function\\\"==typeof e&&(e=e.apply(b));for(var f in d)d.hasOwnProperty(f)&&(e=e.replace(\\\"[_\\\"+f.toUpperCase()+\\\"_]\\\",d[f]));return e}function r(c,d){var e=q(c,d),f=a('<div class=\\\"fr-popup'+(b.helpers.isMobile()?\\\" fr-mobile\\\":\\\" fr-desktop\\\")+(b.opts.toolbarInline?\\\" fr-inline\\\":\\\"\\\")+'\\\"><span class=\\\"fr-arrow\\\"></span>'+e+\\\"</div>\\\");b.opts.theme&&f.addClass(b.opts.theme+\\\"-theme\\\"),b.opts.zIndex>1&&b.$tb.css(\\\"z-index\\\",b.opts.zIndex+2),\\\"auto\\\"!=b.opts.direction&&f.removeClass(\\\"fr-ltr fr-rtl\\\").addClass(\\\"fr-\\\"+b.opts.direction),f.find(\\\"input, textarea\\\").attr(\\\"dir\\\",b.opts.direction).attr(\\\"disabled\\\",\\\"disabled\\\");var g=a(\\\"body\\\");return g.append(f),f.data(\\\"container\\\",g),x[c]=f,b.button.bindCommands(f,!1),f}function s(c){var d=x[c];return{_windowResize:function(){var a=d.data(\\\"instance\\\")||b;!a.helpers.isMobile()&&d.is(\\\":visible\\\")&&(a.events.disableBlur(),a.popups.hide(c),a.events.enableBlur())},_inputFocus:function(c){var e=d.data(\\\"instance\\\")||b;if(c.preventDefault(),c.stopPropagation(),setTimeout(function(){e.events.enableBlur()},0),e.helpers.isMobile()){var f=a(e.o_win).scrollTop();setTimeout(function(){a(e.o_win).scrollTop(f)},0)}},_inputBlur:function(c){var e=d.data(\\\"instance\\\")||b;document.activeElement!=this&&a(this).is(\\\":visible\\\")&&(e.events.blurActive()&&e.events.trigger(\\\"blur\\\"),e.events.enableBlur())},_inputKeydown:function(e){var g=d.data(\\\"instance\\\")||b,h=e.which;if(a.FE.KEYCODE.TAB==h){e.preventDefault();var i=d.find(\\\"input, textarea, button, select\\\").filter(\\\":visible\\\").not(\\\":disabled\\\").toArray();i.sort(function(b,c){return e.shiftKey?a(b).attr(\\\"tabIndex\\\")<a(c).attr(\\\"tabIndex\\\"):a(b).attr(\\\"tabIndex\\\")>a(c).attr(\\\"tabIndex\\\")}),g.events.disableBlur();var j=i.indexOf(this)+1;j==i.length&&(j=0),a(i[j]).focus()}else if(a.FE.KEYCODE.ENTER==h)d.find(\\\".fr-submit:visible\\\").length>0&&(e.preventDefault(),e.stopPropagation(),g.events.disableBlur(),g.button.exec(d.find(\\\".fr-submit:visible:first\\\")));else{if(a.FE.KEYCODE.ESC==h)return e.preventDefault(),e.stopPropagation(),g.$el.find(\\\".fr-marker\\\")&&(g.events.disableBlur(),a(this).data(\\\"skip\\\",!0),g.selection.restore(),g.events.enableBlur()),f(c)&&d.find(\\\".fr-back:visible\\\").length?g.button.exec(d.find(\\\".fr-back:visible:first\\\")):g.popups.hide(c),g.opts.toolbarInline&&g.toolbar.showInline(null,!0),!1;e.stopPropagation()}},_windowKeydown:function(e){if(!b.core.sameInstance(d))return!0;var g=d.data(\\\"instance\\\")||b,h=e.which;if(a.FE.KEYCODE.ESC==h){if(f(c)&&g.opts.toolbarInline)return e.stopPropagation(),f(c)&&d.find(\\\".fr-back:visible\\\").length?g.button.exec(d.find(\\\".fr-back:visible:first\\\")):(g.popups.hide(c),g.toolbar.showInline(null,!0)),!1;f(c)&&d.find(\\\".fr-back:visible\\\").length?g.button.exec(d.find(\\\".fr-back:visible:first\\\")):g.popups.hide(c)}},_editorKeydown:function(e){var g=d.data(\\\"instance\\\")||b;g.keys.ctrlKey(e)||e.which==a.FE.KEYCODE.ESC||(f(c)&&d.find(\\\".fr-back:visible\\\").length?g.button.exec(d.find(\\\".fr-back:visible:first\\\")):g.popups.hide(c))},_preventFocus:function(c){var e=d.data(\\\"instance\\\")||b;e.events.disableBlur();var f=c.originalEvent?c.originalEvent.target||c.originalEvent.originalTarget:null,g=\\\"input, textarea, button, select, label, .fr-command\\\";return f&&!a(f).is(g)&&0===a(f).parents(g).length?(c.stopPropagation(),!1):(f&&a(f).is(g)&&c.stopPropagation(),void o())},_editorMouseup:function(a){d.is(\\\":visible\\\")&&p()&&d.find(\\\"input:focus, textarea:focus, button:focus, select:focus\\\").filter(\\\":visible\\\").length>0&&b.events.disableBlur()},_windowMouseup:function(a){if(!b.core.sameInstance(d))return!0;var e=d.data(\\\"instance\\\")||b;d.is(\\\":visible\\\")&&p()&&(a.stopPropagation(),e.markers.remove(),e.popups.hide(c),o())},_doPlaceholder:function(b){var c=a(this).next();0==c.length&&a(this).after(\\\"<label>\\\"+a(this).attr(\\\"placeholder\\\")+\\\"</label>\\\"),a(this).toggleClass(\\\"fr-not-empty\\\",\\\"\\\"!=a(this).val())},_repositionPopup:function(e){if(!b.opts.height&&!b.opts.heightMax||b.opts.toolbarInline)return!0;if(b.$wp&&f(c)&&d.parent().get(0)==a(b.opts.scrollableContainer).get(0)){var g=d.offset().top-b.$wp.offset().top,h=b.$wp.outerHeight();d.hasClass(\\\"fr-above\\\")&&(g+=d.outerHeight()),g>h||0>g?d.addClass(\\\"fr-hidden\\\"):d.removeClass(\\\"fr-hidden\\\")}}}}function t(a,c){b.events.on(\\\"mouseup\\\",a._editorMouseup,!0),b.$wp&&b.events.on(\\\"keydown\\\",a._editorKeydown),b.events.on(\\\"blur\\\",function(a){g()&&b.markers.remove(),m()}),b.$wp&&!b.helpers.isMobile()&&b.events.$on(b.$wp,\\\"scroll.popup\\\"+c,a._repositionPopup),b.events.on(\\\"window.keydown\\\",a._windowKeydown),b.events.on(\\\"window.mouseup\\\",a._windowMouseup,!0),x[c].data(\\\"inst\\\"+b.id,!0),b.events.on(\\\"destroy\\\",function(){b.core.sameInstance(x[c])&&x[c].removeClass(\\\"fr-active\\\").appendTo(\\\"body\\\")},!0)}function u(c,d){var e=r(c,d),f=s(c);return t(f,c),b.events.$on(e,\\\"mousedown mouseup touchstart touchend touch\\\",\\\"*\\\",f._preventFocus,!0),b.events.$on(e,\\\"focus\\\",\\\"input, textarea, button, select\\\",f._inputFocus,!0),b.events.$on(e,\\\"blur\\\",\\\"input, textarea, button, select\\\",f._inputBlur,!0),b.events.$on(e,\\\"keydown\\\",\\\"input, textarea, button, select\\\",f._inputKeydown,!0),b.events.$on(e,\\\"keydown keyup change input\\\",\\\"input, textarea\\\",f._doPlaceholder,!0),b.helpers.isIOS()&&b.events.$on(e,\\\"touchend\\\",\\\"label\\\",function(){a(\\\"#\\\"+a(this).attr(\\\"for\\\")).prop(\\\"checked\\\",function(a,b){return!b})},!0),b.events.$on(a(b.o_win),\\\"resize\\\",f._windowResize,!0),e}function v(){for(var a in x)if(x.hasOwnProperty(a)){var b=x[a];b.html(\\\"\\\").removeData().remove(),x[a]=null}x=[]}function w(){b.events.on(\\\"shared.destroy\\\",v,!0),b.events.on(\\\"window.mousedown\\\",n),b.events.on(\\\"window.touchmove\\\",o),b.events.on(\\\"mousedown\\\",function(a){g()&&(a.stopPropagation(),b.$el.find(\\\".fr-marker\\\").remove(),n(),b.events.disableBlur())})}b.shared.popups||(b.shared.popups={});var x=b.shared.popups;return b.shared.exit_flag=!1,{_init:w,create:u,get:j,show:d,hide:h,onHide:i,hideAll:m,setContainer:c,refresh:l,onRefresh:k,onShow:e,isVisible:f,areVisible:g}},a.FE.MODULES.position=function(b){function c(){var c,d=b.selection.ranges(0);if(d&&d.collapsed&&b.selection.inEditor()){var e=!1;0==b.$el.find(\\\".fr-marker\\\").length&&(b.selection.save(),e=!0);var f=b.$el.find(\\\".fr-marker:first\\\");f.css(\\\"display\\\",\\\"inline\\\"),f.css(\\\"line-height\\\",\\\"\\\");var g=f.offset(),h=f.outerHeight();f.css(\\\"display\\\",\\\"none\\\"),f.css(\\\"line-height\\\",0),c={},c.left=g.left,c.width=0,c.height=h,c.top=g.top-(b.helpers.isIOS()?0:a(b.o_win).scrollTop()),c.right=1,c.bottom=1,c.ok=!0,e&&b.selection.restore()}else d&&(c=d.getBoundingClientRect());return c}function d(c,d,e){var f=c.outerHeight();if(!b.helpers.isMobile()&&b.$tb&&c.parent().get(0)!=b.$tb.get(0)){var g=(c.parent().height()-20-(b.opts.toolbarBottom?b.$tb.outerHeight():0),c.parent().offset().top),h=d-f-(e||0);c.parent().get(0)==a(b.opts.scrollableContainer).get(0)&&(g-=c.parent().position().top);var i=a(b.opts.scrollableContainer).get(0).scrollHeight;g+d+f>a(b.opts.scrollableContainer).offset().top+i&&c.parent().offset().top+h>0?(d=h,c.addClass(\\\"fr-above\\\")):c.removeClass(\\\"fr-above\\\")}return d}function e(c,d){var e=c.outerWidth();return d+e>a(b.opts.scrollableContainer).width()-10&&(d=a(b.opts.scrollableContainer).width()-e-10),0>d&&(d=10),d}function f(d){var e=c();d.css(\\\"top\\\",0).css(\\\"left\\\",0);var f=e.top+e.height,h=e.left+e.width/2-d.outerWidth()/2+a(b.o_win).scrollLeft();b.opts.iframe||(f+=a(b.o_win).scrollTop()),g(h,f,d,e.height)}function g(a,c,f,g){var h=f.data(\\\"container\\\");!h||h.is(\\\"body\\\")&&\\\"static\\\"==h.css(\\\"position\\\")||(a&&(a-=h.offset().left),c&&(c-=h.offset().top),\\\"BODY\\\"!=h.get(0).tagName?(a&&(a+=h.scrollLeft()),c&&(c+=h.scrollTop())):\\\"absolute\\\"==h.css(\\\"position\\\")&&(a&&(a+=h.position().left),c&&(c+=h.position().top))),b.opts.iframe&&h&&b.$tb&&h.get(0)!=b.$tb.get(0)&&(a&&(a+=b.$iframe.offset().left),c&&(c+=b.$iframe.offset().top));var i=e(f,a);if(a){f.css(\\\"left\\\",i);var j=f.find(\\\".fr-arrow\\\");j.data(\\\"margin-left\\\")||j.data(\\\"margin-left\\\",b.helpers.getPX(j.css(\\\"margin-left\\\"))),j.css(\\\"margin-left\\\",a-i+j.data(\\\"margin-left\\\"))}c&&f.css(\\\"top\\\",d(f,c,g))}function h(c){var d=a(c),e=d.is(\\\".fr-sticky-on\\\"),f=d.data(\\\"sticky-top\\\"),g=d.data(\\\"sticky-scheduled\\\");if(\\\"undefined\\\"==typeof f){d.data(\\\"sticky-top\\\",0);var h=a('<div class=\\\"fr-sticky-dummy\\\" style=\\\"height: '+d.outerHeight()+'px;\\\"></div>');b.$box.prepend(h)}else b.$box.find(\\\".fr-sticky-dummy\\\").css(\\\"height\\\",d.outerHeight());if(b.core.hasFocus()||b.$tb.find(\\\"input:visible:focus\\\").length>0){var i=a(window).scrollTop(),j=Math.min(Math.max(i-b.$tb.parent().offset().top,0),b.$tb.parent().outerHeight()-d.outerHeight());j!=f&&j!=g&&(clearTimeout(d.data(\\\"sticky-timeout\\\")),d.data(\\\"sticky-scheduled\\\",j),d.outerHeight()<i-b.$tb.parent().offset().top&&d.addClass(\\\"fr-opacity-0\\\"),d.data(\\\"sticky-timeout\\\",setTimeout(function(){var c=a(window).scrollTop(),e=Math.min(Math.max(c-b.$tb.parent().offset().top,0),b.$tb.parent().outerHeight()-d.outerHeight());e>0&&\\\"BODY\\\"==b.$tb.parent().get(0).tagName&&(e+=b.$tb.parent().position().top),e!=f&&(d.css(\\\"top\\\",Math.max(e,0)),d.data(\\\"sticky-top\\\",e),d.data(\\\"sticky-scheduled\\\",e)),d.removeClass(\\\"fr-opacity-0\\\")},100))),e||(d.css(\\\"top\\\",\\\"0\\\"),d.width(b.$tb.parent().width()),d.addClass(\\\"fr-sticky-on\\\"),b.$box.addClass(\\\"fr-sticky-box\\\"))}else clearTimeout(a(c).css(\\\"sticky-timeout\\\")),d.css(\\\"top\\\",\\\"0\\\"),d.css(\\\"position\\\",\\\"\\\"),d.width(\\\"\\\"),d.data(\\\"sticky-top\\\",0),d.removeClass(\\\"fr-sticky-on\\\"),b.$box.removeClass(\\\"fr-sticky-box\\\")}function i(c){if(c.offsetWidth){var d,e,f=a(c),g=f.outerHeight(),h=f.data(\\\"sticky-position\\\"),i=a(\\\"body\\\"==b.opts.scrollableContainer?b.o_win:b.opts.scrollableContainer).outerHeight(),j=0,k=0;\\\"body\\\"!==b.opts.scrollableContainer&&(j=a(b.opts.scrollableContainer).offset().top,k=a(b.o_win).outerHeight()-j-i);var l=\\\"body\\\"==b.opts.scrollableContainer?a(b.o_win).scrollTop():j,m=f.is(\\\".fr-sticky-on\\\");f.data(\\\"sticky-parent\\\")||f.data(\\\"sticky-parent\\\",f.parent());var n=f.data(\\\"sticky-parent\\\"),o=n.offset().top,p=n.outerHeight();if(f.data(\\\"sticky-offset\\\")||(f.data(\\\"sticky-offset\\\",!0),f.after('<div class=\\\"fr-sticky-dummy\\\" style=\\\"height: '+g+'px;\\\"></div>')),!h){var q=\\\"auto\\\"!==f.css(\\\"top\\\")||\\\"auto\\\"!==f.css(\\\"bottom\\\");q||f.css(\\\"position\\\",\\\"fixed\\\"),h={top:f.hasClass(\\\"fr-top\\\"),bottom:f.hasClass(\\\"fr-bottom\\\")},q||f.css(\\\"position\\\",\\\"\\\"),f.data(\\\"sticky-position\\\",h),f.data(\\\"top\\\",f.hasClass(\\\"fr-top\\\")?f.css(\\\"top\\\"):\\\"auto\\\"),f.data(\\\"bottom\\\",f.hasClass(\\\"fr-bottom\\\")?f.css(\\\"bottom\\\"):\\\"auto\\\")}var r=function(){return l+d>o&&o+p-g>=l+d},s=function(){return l+i-e>o+g&&o+p>l+i-e};d=b.helpers.getPX(f.data(\\\"top\\\")),e=b.helpers.getPX(f.data(\\\"bottom\\\"));var t=h.top&&r(),u=h.bottom&&s();t||u?(f.css(\\\"width\\\",n.width()+\\\"px\\\"),m||(f.addClass(\\\"fr-sticky-on\\\"),f.removeClass(\\\"fr-sticky-off\\\"),f.css(\\\"top\\\")&&(\\\"auto\\\"!=f.data(\\\"top\\\")?f.css(\\\"top\\\",b.helpers.getPX(f.data(\\\"top\\\"))+j):f.data(\\\"top\\\",\\\"auto\\\")),f.css(\\\"bottom\\\")&&(\\\"auto\\\"!=f.data(\\\"bottom\\\")?f.css(\\\"bottom\\\",b.helpers.getPX(f.data(\\\"bottom\\\"))+k):f.css(\\\"bottom\\\",\\\"auto\\\")))):f.hasClass(\\\"fr-sticky-off\\\")||(f.width(\\\"\\\"),f.removeClass(\\\"fr-sticky-on\\\"),f.addClass(\\\"fr-sticky-off\\\"),f.css(\\\"top\\\")&&\\\"auto\\\"!=f.data(\\\"top\\\")&&h.top&&f.css(\\\"top\\\",0),f.css(\\\"bottom\\\")&&\\\"auto\\\"!=f.data(\\\"bottom\\\")&&h.bottom&&f.css(\\\"bottom\\\",0))}}function j(){var a=document.createElement(\\\"test\\\"),c=a.style;return c.cssText=\\\"position:\\\"+[\\\"-webkit-\\\",\\\"-moz-\\\",\\\"-ms-\\\",\\\"-o-\\\",\\\"\\\"].join(\\\"sticky; position:\\\")+\\\" sticky;\\\",-1!==c.position.indexOf(\\\"sticky\\\")&&!b.helpers.isIOS()&&!b.helpers.isAndroid()}function k(){if(!j())if(b._stickyElements=[],b.helpers.isIOS()){var c=function(){b.helpers.requestAnimationFrame()(c);for(var a=0;a<b._stickyElements.length;a++)h(b._stickyElements[a])};c(),b.events.$on(a(b.o_win),\\\"scroll\\\",function(){if(b.core.hasFocus())for(var c=0;c<b._stickyElements.length;c++){var d=a(b._stickyElements[c]),e=d.parent(),f=a(window).scrollTop();d.outerHeight()<f-e.offset().top&&(d.addClass(\\\"fr-opacity-0\\\"),d.data(\\\"sticky-top\\\",-1),d.data(\\\"sticky-scheduled\\\",-1))}},!0)}else b.events.$on(a(\\\"body\\\"==b.opts.scrollableContainer?b.o_win:b.opts.scrollableContainer),\\\"scroll\\\",l,!0),b.events.$on(a(b.o_win),\\\"resize\\\",l,!0),b.events.on(\\\"initialized\\\",l),b.events.on(\\\"focus\\\",l),b.events.$on(a(b.o_win),\\\"resize\\\",\\\"textarea\\\",l,!0);b.events.on(\\\"destroy\\\",function(a){b._stickyElements=[]})}function l(){for(var a=0;a<b._stickyElements.length;a++)i(b._stickyElements[a])}function m(a){a.addClass(\\\"fr-sticky\\\"),b.helpers.isIOS()&&a.addClass(\\\"fr-sticky-ios\\\"),j()||b._stickyElements.push(a.get(0))}function n(){k()}return{_init:n,forSelection:f,addSticky:m,refresh:l,at:g,getBoundingRect:c}},a.FE.MODULES.refresh=function(b){function c(a){a.toggleClass(\\\"fr-disabled\\\",!b.undo.canDo())}function d(a){a.toggleClass(\\\"fr-disabled\\\",!b.undo.canRedo())}function e(a){if(a.hasClass(\\\"fr-no-refresh\\\"))return!1;for(var c=b.selection.blocks(),d=0;d<c.length;d++){for(var e=c[d].previousSibling;e&&e.nodeType==Node.TEXT_NODE&&0===e.textContent.length;)e=e.previousSibling;if(\\\"LI\\\"!=c[d].tagName||e)return a.removeClass(\\\"fr-disabled\\\"),!0;a.addClass(\\\"fr-disabled\\\")}}function f(c){if(c.hasClass(\\\"fr-no-refresh\\\"))return!1;for(var d=b.selection.blocks(),e=0;e<d.length;e++){var f=\\\"rtl\\\"==b.opts.direction||\\\"rtl\\\"==a(d[e]).css(\\\"direction\\\")?\\\"margin-right\\\":\\\"margin-left\\\";if(\\\"LI\\\"==d[e].tagName||\\\"LI\\\"==d[e].parentNode.tagName)return c.removeClass(\\\"fr-disabled\\\"),!0;if(b.helpers.getPX(a(d[e]).css(f))>0)return c.removeClass(\\\"fr-disabled\\\"),!0}c.addClass(\\\"fr-disabled\\\")}return{undo:c,redo:d,outdent:f,indent:e}},a.extend(a.FE.DEFAULTS,{editInPopup:!1}),a.FE.MODULES.textEdit=function(b){function c(){var a='<div id=\\\"fr-text-edit-'+b.id+'\\\" class=\\\"fr-layer fr-text-edit-layer\\\"><div class=\\\"fr-input-line\\\"><input type=\\\"text\\\" placeholder=\\\"'+b.language.translate(\\\"Text\\\")+'\\\" tabIndex=\\\"1\\\"></div><div class=\\\"fr-action-buttons\\\"><button type=\\\"button\\\" class=\\\"fr-command fr-submit\\\" data-cmd=\\\"updateText\\\" tabIndex=\\\"2\\\">'+b.language.translate(\\\"Update\\\")+\\\"</button></div></div>\\\",c={edit:a};b.popups.create(\\\"text.edit\\\",c)}function d(){var c,d=b.popups.get(\\\"text.edit\\\");c=\\\"INPUT\\\"===b.$el.prop(\\\"tagName\\\")?b.$el.attr(\\\"placeholder\\\"):b.$el.text(),d.find(\\\"input\\\").val(c).trigger(\\\"change\\\"),b.popups.setContainer(\\\"text.edit\\\",a(\\\"body\\\")),b.popups.show(\\\"text.edit\\\",b.$el.offset().left+b.$el.outerWidth()/2,b.$el.offset().top+b.$el.outerHeight(),b.$el.outerHeight())}function e(){b.events.$on(b.$el,b._mouseup,function(a){setTimeout(function(){d()},10)})}function f(){var a=b.popups.get(\\\"text.edit\\\"),c=a.find(\\\"input\\\").val();0==c.length&&(c=b.opts.placeholderText),\\\"INPUT\\\"===b.$el.prop(\\\"tagName\\\")?b.$el.attr(\\\"placeholder\\\",c):b.$el.text(c),b.events.trigger(\\\"contentChanged\\\"),b.popups.hide(\\\"text.edit\\\")}function g(){b.opts.editInPopup&&(c(),e())}return{_init:g,update:f}},a.FE.RegisterCommand(\\\"updateText\\\",{focus:!1,undo:!1,callback:function(){this.textEdit.update()}}),a.extend(a.FE.DEFAULTS,{toolbarBottom:!1,toolbarButtons:[\\\"fullscreen\\\",\\\"bold\\\",\\\"italic\\\",\\\"underline\\\",\\\"strikeThrough\\\",\\\"subscript\\\",\\\"superscript\\\",\\\"fontFamily\\\",\\\"fontSize\\\",\\\"|\\\",\\\"color\\\",\\\"emoticons\\\",\\\"inlineStyle\\\",\\\"paragraphStyle\\\",\\\"|\\\",\\\"paragraphFormat\\\",\\\"align\\\",\\\"formatOL\\\",\\\"formatUL\\\",\\\"outdent\\\",\\\"indent\\\",\\\"quote\\\",\\\"insertHR\\\",\\\"-\\\",\\\"insertLink\\\",\\\"insertImage\\\",\\\"insertVideo\\\",\\\"insertFile\\\",\\\"insertTable\\\",\\\"undo\\\",\\\"redo\\\",\\\"clearFormatting\\\",\\\"selectAll\\\",\\\"html\\\",\\\"applyFormat\\\",\\\"removeFormat\\\"],toolbarButtonsXS:[\\\"bold\\\",\\\"italic\\\",\\\"fontFamily\\\",\\\"fontSize\\\",\\\"|\\\",\\\"undo\\\",\\\"redo\\\"],toolbarButtonsSM:[\\\"bold\\\",\\\"italic\\\",\\\"underline\\\",\\\"|\\\",\\\"fontFamily\\\",\\\"fontSize\\\",\\\"insertLink\\\",\\\"insertImage\\\",\\\"table\\\",\\\"|\\\",\\\"undo\\\",\\\"redo\\\"],toolbarButtonsMD:[\\\"fullscreen\\\",\\\"bold\\\",\\\"italic\\\",\\\"underline\\\",\\\"fontFamily\\\",\\\"fontSize\\\",\\\"color\\\",\\\"paragraphStyle\\\",\\\"paragraphFormat\\\",\\\"align\\\",\\\"formatOL\\\",\\\"formatUL\\\",\\\"outdent\\\",\\\"indent\\\",\\\"quote\\\",\\\"insertHR\\\",\\\"-\\\",\\\"insertLink\\\",\\\"insertImage\\\",\\\"insertVideo\\\",\\\"insertFile\\\",\\\"insertTable\\\",\\\"undo\\\",\\\"redo\\\",\\\"clearFormatting\\\"],toolbarContainer:null,toolbarInline:!1,toolbarSticky:!0,toolbarStickyOffset:0,toolbarVisibleWithoutSelection:!1}),a.FE.MODULES.toolbar=function(b){function c(a,b){for(var c=0;c<b.length;c++)\\\"-\\\"!=b[c]&&\\\"|\\\"!=b[c]&&a.indexOf(b[c])<0&&a.push(b[c])}function d(){var d=a.merge([],e());c(d,b.opts.toolbarButtonsXS||[]),c(d,b.opts.toolbarButtonsSM||[]),c(d,b.opts.toolbarButtonsMD||[]),c(d,b.opts.toolbarButtons);for(var f=d.length-1;f>=0;f--)\\\"-\\\"!=d[f]&&\\\"|\\\"!=d[f]&&d.indexOf(d[f])<f&&d.splice(f,1);var g=b.button.buildList(d,e());b.$tb.append(g),b.button.bindCommands(b.$tb)}function e(){var a=b.helpers.screenSize();return u[a]}function f(){var a=e();b.$tb.find(\\\".fr-separator\\\").remove(),b.$tb.find(\\\"> .fr-command\\\").addClass(\\\"fr-hidden\\\");for(var c=0;c<a.length;c++)if(\\\"|\\\"==a[c]||\\\"-\\\"==a[c])b.$tb.append(b.button.buildList([a[c]]));else{var d=b.$tb.find('> .fr-command[data-cmd=\\\"'+a[c]+'\\\"]'),f=null;d.next().hasClass(\\\"fr-dropdown-menu\\\")&&(f=d.next()),d.removeClass(\\\"fr-hidden\\\").appendTo(b.$tb),f&&f.appendTo(b.$tb)}}function g(){b.events.$on(a(b.o_win),\\\"resize\\\",f),b.events.$on(a(b.o_win),\\\"orientationchange\\\",f)}function h(c,d){setTimeout(function(){if(c&&c.which==a.FE.KEYCODE.ESC);else if(b.selection.inEditor()&&b.core.hasFocus()&&!b.popups.areVisible()&&(b.opts.toolbarVisibleWithoutSelection&&c&&\\\"keyup\\\"!=c.type||!b.selection.isCollapsed()&&!b.keys.isIME()||d)){if(b.$tb.data(\\\"instance\\\",b),0==b.events.trigger(\\\"toolbar.show\\\",[c]))return!1;b.opts.toolbarContainer||b.position.forSelection(b.$tb),b.$tb.show()}},0)}function i(c){var d=a(\\\".fr-dropdown.fr-active\\\");return d.next().find(b.o_doc.activeElement).length?!0:void(b.events.trigger(\\\"toolbar.hide\\\")!==!1&&b.$tb.hide())}function j(){return 0==b.events.trigger(\\\"toolbar.show\\\")?!1:void b.$tb.show()}function k(){b.events.on(\\\"window.mousedown\\\",i),b.events.on(\\\"keydown\\\",i),b.events.on(\\\"blur\\\",i),b.events.on(\\\"window.mouseup\\\",h),b.helpers.isMobile()?b.helpers.isIOS()||(b.events.on(\\\"window.touchend\\\",h),b.browser.mozilla&&setInterval(h,200)):b.events.on(\\\"window.keyup\\\",h),b.events.on(\\\"keydown\\\",function(b){b&&b.which==a.FE.KEYCODE.ESC&&i()}),b.events.$on(b.$wp,\\\"scroll.toolbar\\\",h),b.events.on(\\\"commands.after\\\",h),b.helpers.isMobile()&&(b.events.$on(b.$doc,\\\"selectionchange\\\",h),b.events.$on(b.$doc,\\\"orientationchange\\\",h))}function l(){b.opts.toolbarInline?(a(b.opts.scrollableContainer).append(b.$tb),b.$tb.data(\\\"container\\\",a(b.opts.scrollableContainer)),b.$tb.addClass(\\\"fr-inline\\\"),b.$tb.prepend('<span class=\\\"fr-arrow\\\"></span>'),k(),b.opts.toolbarBottom=!1):(b.opts.toolbarBottom&&!b.helpers.isIOS()?(b.$box.append(b.$tb),b.$tb.addClass(\\\"fr-bottom\\\"),b.$box.addClass(\\\"fr-bottom\\\")):(b.opts.toolbarBottom=!1,b.$box.prepend(b.$tb),b.$tb.addClass(\\\"fr-top\\\"),b.$box.addClass(\\\"fr-top\\\")),b.$tb.addClass(\\\"fr-basic\\\"),b.opts.toolbarSticky&&(b.opts.toolbarStickyOffset&&(b.opts.toolbarBottom?b.$tb.css(\\\"bottom\\\",b.opts.toolbarStickyOffset):b.$tb.css(\\\"top\\\",b.opts.toolbarStickyOffset)),b.position.addSticky(b.$tb)))}function m(){b.$tb.html(\\\"\\\").removeData().remove(),b.$tb=null}function n(){b.$box.removeClass(\\\"fr-top fr-bottom fr-inline fr-basic\\\"),b.$box.find(\\\".fr-sticky-dummy\\\").remove()}function o(){b.opts.theme&&b.$tb.addClass(b.opts.theme+\\\"-theme\\\"),b.opts.zIndex>1&&b.$tb.css(\\\"z-index\\\",b.opts.zIndex+1),\\\"auto\\\"!=b.opts.direction&&b.$tb.removeClass(\\\"fr-ltr fr-rtl\\\").addClass(\\\"fr-\\\"+b.opts.direction),b.helpers.isMobile()?b.$tb.addClass(\\\"fr-mobile\\\"):b.$tb.addClass(\\\"fr-desktop\\\"),b.opts.toolbarContainer?(b.opts.toolbarInline&&(k(),i()),b.opts.toolbarBottom?b.$tb.addClass(\\\"fr-bottom\\\"):b.$tb.addClass(\\\"fr-top\\\")):l(),s=b.$tb.get(0).ownerDocument,t=\\\"defaultView\\\"in s?s.defaultView:s.parentWindow,d(),g(),b.events.$on(b.$tb,b._mousedown+\\\" \\\"+b._mouseup,function(a){var c=a.originalEvent?a.originalEvent.target||a.originalEvent.originalTarget:null;return c&&\\\"INPUT\\\"!=c.tagName&&!b.edit.isDisabled()?(a.stopPropagation(),a.preventDefault(),!1):void 0},!0)}function p(){return b.$wp?(b.opts.toolbarContainer?(b.shared.$tb?(b.$tb=b.shared.$tb,b.opts.toolbarInline&&k()):(b.shared.$tb=a('<div class=\\\"fr-toolbar\\\"></div>'),b.$tb=b.shared.$tb,a(b.opts.toolbarContainer).append(b.$tb),o(),b.$tb.data(\\\"instance\\\",b)),b.opts.toolbarInline?b.$box.addClass(\\\"fr-inline\\\"):b.$box.addClass(\\\"fr-basic\\\"),b.events.on(\\\"focus\\\",function(){b.$tb.data(\\\"instance\\\",b)},!0),b.opts.toolbarInline=!1):b.opts.toolbarInline?(b.$box.addClass(\\\"fr-inline\\\"),b.shared.$tb?(b.$tb=b.shared.$tb,k()):(b.shared.$tb=a('<div class=\\\"fr-toolbar\\\"></div>'),b.$tb=b.shared.$tb,o())):(b.$box.addClass(\\\"fr-basic\\\"),b.$tb=a('<div class=\\\"fr-toolbar\\\"></div>'),o(),b.$tb.data(\\\"instance\\\",b)),b.events.on(\\\"destroy\\\",n,!0),void b.events.on(b.opts.toolbarInline?\\\"shared.destroy\\\":\\\"destroy\\\",m,!0)):!1}function q(){!v&&b.$tb&&(b.$tb.find(\\\"> .fr-command\\\").addClass(\\\"fr-disabled fr-no-refresh\\\"),v=!0)}function r(){v&&b.$tb&&(b.$tb.find(\\\"> .fr-command\\\").removeClass(\\\"fr-disabled fr-no-refresh\\\"),v=!1),b.button.bulkRefresh()}var s,t,u=[];u[a.FE.XS]=b.opts.toolbarButtonsXS||b.opts.toolbarButtons,u[a.FE.SM]=b.opts.toolbarButtonsSM||b.opts.toolbarButtons,u[a.FE.MD]=b.opts.toolbarButtonsMD||b.opts.toolbarButtons,u[a.FE.LG]=b.opts.toolbarButtons;var v=!1;return{_init:p,hide:i,show:j,showInline:h,disable:q,enable:r}}});\"//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL34vZnJvYWxhLWVkaXRvci9qcy9mcm9hbGFfZWRpdG9yLm1pbi5qcz81NDRiIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gXCIvKiFcXG4gKiBmcm9hbGFfZWRpdG9yIHYyLjMuNSAoaHR0cHM6Ly93d3cuZnJvYWxhLmNvbS93eXNpd3lnLWVkaXRvcilcXG4gKiBMaWNlbnNlIGh0dHBzOi8vZnJvYWxhLmNvbS93eXNpd3lnLWVkaXRvci90ZXJtcy9cXG4gKiBDb3B5cmlnaHQgMjAxNC0yMDE2IEZyb2FsYSBMYWJzXFxuICovXFxuXFxuIWZ1bmN0aW9uKGEpe1xcXCJmdW5jdGlvblxcXCI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQ/ZGVmaW5lKFtcXFwianF1ZXJ5XFxcIl0sYSk6XFxcIm9iamVjdFxcXCI9PXR5cGVvZiBtb2R1bGUmJm1vZHVsZS5leHBvcnRzP21vZHVsZS5leHBvcnRzPWZ1bmN0aW9uKGIsYyl7cmV0dXJuIHZvaWQgMD09PWMmJihjPVxcXCJ1bmRlZmluZWRcXFwiIT10eXBlb2Ygd2luZG93P3JlcXVpcmUoXFxcImpxdWVyeVxcXCIpOnJlcXVpcmUoXFxcImpxdWVyeVxcXCIpKGIpKSxhKGMpLGN9OmEoalF1ZXJ5KX0oZnVuY3Rpb24oYSl7dmFyIGI9ZnVuY3Rpb24oYyxkKXt0aGlzLmlkPSsrYS5GRS5JRCx0aGlzLm9wdHM9YS5leHRlbmQoITAse30sYS5leHRlbmQoe30sYi5ERUZBVUxUUyxcXFwib2JqZWN0XFxcIj09dHlwZW9mIGQmJmQpKTt2YXIgZT1KU09OLnN0cmluZ2lmeSh0aGlzLm9wdHMpO2EuRkUuT1BUU19NQVBQSU5HW2VdPWEuRkUuT1BUU19NQVBQSU5HW2VdfHx0aGlzLmlkLHRoaXMuc2lkPWEuRkUuT1BUU19NQVBQSU5HW2VdLGEuRkUuU0hBUkVEW3RoaXMuc2lkXT1hLkZFLlNIQVJFRFt0aGlzLnNpZF18fHt9LHRoaXMuc2hhcmVkPWEuRkUuU0hBUkVEW3RoaXMuc2lkXSx0aGlzLnNoYXJlZC5jb3VudD0odGhpcy5zaGFyZWQuY291bnR8fDApKzEsdGhpcy4kb2VsPWEoYyksdGhpcy4kb2VsLmRhdGEoXFxcImZyb2FsYS5lZGl0b3JcXFwiLHRoaXMpLHRoaXMub19kb2M9Yy5vd25lckRvY3VtZW50LHRoaXMub193aW49XFxcImRlZmF1bHRWaWV3XFxcImluIHRoaXMub19kb2M/dGhpcy5vX2RvYy5kZWZhdWx0Vmlldzp0aGlzLm9fZG9jLnBhcmVudFdpbmRvdzt2YXIgZj1hKHRoaXMub193aW4pLnNjcm9sbFRvcCgpO3RoaXMuJG9lbC5vbihcXFwiZnJvYWxhLmRvSW5pdFxcXCIsYS5wcm94eShmdW5jdGlvbigpe3RoaXMuJG9lbC5vZmYoXFxcImZyb2FsYS5kb0luaXRcXFwiKSx0aGlzLmRvYz10aGlzLiRlbC5nZXQoMCkub3duZXJEb2N1bWVudCx0aGlzLndpbj1cXFwiZGVmYXVsdFZpZXdcXFwiaW4gdGhpcy5kb2M/dGhpcy5kb2MuZGVmYXVsdFZpZXc6dGhpcy5kb2MucGFyZW50V2luZG93LHRoaXMuJGRvYz1hKHRoaXMuZG9jKSx0aGlzLiR3aW49YSh0aGlzLndpbiksdGhpcy5vcHRzLnBsdWdpbnNFbmFibGVkfHwodGhpcy5vcHRzLnBsdWdpbnNFbmFibGVkPU9iamVjdC5rZXlzKGEuRkUuUExVR0lOUykpLHRoaXMub3B0cy5pbml0T25DbGljaz8odGhpcy5sb2FkKGEuRkUuTU9EVUxFUyksdGhpcy4kZWwub24oXFxcInRvdWNoc3RhcnQuaW5pdFxcXCIsZnVuY3Rpb24oKXthKHRoaXMpLmRhdGEoXFxcInRvdWNoZWRcXFwiLCEwKX0pLHRoaXMuJGVsLm9uKFxcXCJ0b3VjaG1vdmUuaW5pdFxcXCIsZnVuY3Rpb24oKXthKHRoaXMpLnJlbW92ZURhdGEoXFxcInRvdWNoZWRcXFwiKX0pLHRoaXMuJGVsLm9uKFxcXCJtb3VzZWRvd24uaW5pdCB0b3VjaGVuZC5pbml0IGRyYWdlbnRlci5pbml0IGZvY3VzLmluaXRcXFwiLGEucHJveHkoZnVuY3Rpb24oYil7aWYoXFxcInRvdWNoZW5kXFxcIj09Yi50eXBlJiYhdGhpcy4kZWwuZGF0YShcXFwidG91Y2hlZFxcXCIpKXJldHVybiEwO2lmKDE9PT1iLndoaWNofHwhYi53aGljaCl7dGhpcy4kZWwub2ZmKFxcXCJtb3VzZWRvd24uaW5pdCB0b3VjaHN0YXJ0LmluaXQgdG91Y2htb3ZlLmluaXQgdG91Y2hlbmQuaW5pdCBkcmFnZW50ZXIuaW5pdCBmb2N1cy5pbml0XFxcIiksdGhpcy5sb2FkKGEuRkUuTU9EVUxFUyksdGhpcy5sb2FkKGEuRkUuUExVR0lOUyk7dmFyIGM9Yi5vcmlnaW5hbEV2ZW50JiZiLm9yaWdpbmFsRXZlbnQub3JpZ2luYWxUYXJnZXQ7YyYmXFxcIklNR1xcXCI9PWMudGFnTmFtZSYmYShjKS50cmlnZ2VyKFxcXCJtb3VzZWRvd25cXFwiKSxcXFwidW5kZWZpbmVkXFxcIj09dHlwZW9mIHRoaXMudWwmJnRoaXMuZGVzdHJveSgpLFxcXCJ0b3VjaGVuZFxcXCI9PWIudHlwZSYmdGhpcy5pbWFnZSYmYi5vcmlnaW5hbEV2ZW50JiZiLm9yaWdpbmFsRXZlbnQudGFyZ2V0JiZhKGIub3JpZ2luYWxFdmVudC50YXJnZXQpLmlzKFxcXCJpbWdcXFwiKSYmc2V0VGltZW91dChhLnByb3h5KGZ1bmN0aW9uKCl7dGhpcy5pbWFnZS5lZGl0KGEoYi5vcmlnaW5hbEV2ZW50LnRhcmdldCkpfSx0aGlzKSwxMDApLHRoaXMuZXZlbnRzLnRyaWdnZXIoXFxcImluaXRpYWxpemVkXFxcIil9fSx0aGlzKSkpOih0aGlzLmxvYWQoYS5GRS5NT0RVTEVTKSx0aGlzLmxvYWQoYS5GRS5QTFVHSU5TKSxhKHRoaXMub193aW4pLnNjcm9sbFRvcChmKSxcXFwidW5kZWZpbmVkXFxcIj09dHlwZW9mIHRoaXMudWwmJnRoaXMuZGVzdHJveSgpLHRoaXMuZXZlbnRzLnRyaWdnZXIoXFxcImluaXRpYWxpemVkXFxcIikpfSx0aGlzKSksdGhpcy5faW5pdCgpfTtiLkRFRkFVTFRTPXtpbml0T25DbGljazohMSxwbHVnaW5zRW5hYmxlZDpudWxsfSxiLk1PRFVMRVM9e30sYi5QTFVHSU5TPXt9LGIuVkVSU0lPTj1cXFwiMi4zLjVcXFwiLGIuSU5TVEFOQ0VTPVtdLGIuT1BUU19NQVBQSU5HPXt9LGIuU0hBUkVEPXt9LGIuSUQ9MCxiLnByb3RvdHlwZS5faW5pdD1mdW5jdGlvbigpe3ZhciBiPXRoaXMuJG9lbC5wcm9wKFxcXCJ0YWdOYW1lXFxcIiksYz1hLnByb3h5KGZ1bmN0aW9uKCl7dGhpcy5fb3JpZ2luYWxfaHRtbD10aGlzLl9vcmlnaW5hbF9odG1sfHx0aGlzLiRvZWwuaHRtbCgpLHRoaXMuJGJveD10aGlzLiRib3h8fHRoaXMuJG9lbCx0aGlzLm9wdHMuZnVsbFBhZ2UmJih0aGlzLm9wdHMuaWZyYW1lPSEwKSx0aGlzLm9wdHMuaWZyYW1lPyh0aGlzLiRpZnJhbWU9YSgnPGlmcmFtZSBzcmM9XFxcImFib3V0OmJsYW5rXFxcIiBmcmFtZUJvcmRlcj1cXFwiMFxcXCI+JyksdGhpcy4kd3A9YShcXFwiPGRpdj48L2Rpdj5cXFwiKSx0aGlzLiRib3guaHRtbCh0aGlzLiR3cCksdGhpcy4kd3AuYXBwZW5kKHRoaXMuJGlmcmFtZSksdGhpcy4kaWZyYW1lLmdldCgwKS5jb250ZW50V2luZG93LmRvY3VtZW50Lm9wZW4oKSx0aGlzLiRpZnJhbWUuZ2V0KDApLmNvbnRlbnRXaW5kb3cuZG9jdW1lbnQud3JpdGUoXFxcIjwhRE9DVFlQRSBodG1sPlxcXCIpLHRoaXMuJGlmcmFtZS5nZXQoMCkuY29udGVudFdpbmRvdy5kb2N1bWVudC53cml0ZShcXFwiPGh0bWw+PGhlYWQ+PC9oZWFkPjxib2R5PjwvYm9keT48L2h0bWw+XFxcIiksdGhpcy4kaWZyYW1lLmdldCgwKS5jb250ZW50V2luZG93LmRvY3VtZW50LmNsb3NlKCksdGhpcy4kZWw9dGhpcy4kaWZyYW1lLmNvbnRlbnRzKCkuZmluZChcXFwiYm9keVxcXCIpLHRoaXMuJGhlYWQ9dGhpcy4kaWZyYW1lLmNvbnRlbnRzKCkuZmluZChcXFwiaGVhZFxcXCIpLHRoaXMuJGh0bWw9dGhpcy4kaWZyYW1lLmNvbnRlbnRzKCkuZmluZChcXFwiaHRtbFxcXCIpLHRoaXMuaWZyYW1lX2RvY3VtZW50PXRoaXMuJGlmcmFtZS5nZXQoMCkuY29udGVudFdpbmRvdy5kb2N1bWVudCx0aGlzLiRvZWwudHJpZ2dlcihcXFwiZnJvYWxhLmRvSW5pdFxcXCIpKToodGhpcy4kZWw9YShcXFwiPGRpdj48L2Rpdj5cXFwiKSx0aGlzLiR3cD1hKFxcXCI8ZGl2PjwvZGl2PlxcXCIpLmFwcGVuZCh0aGlzLiRlbCksdGhpcy4kYm94Lmh0bWwodGhpcy4kd3ApLHRoaXMuJG9lbC50cmlnZ2VyKFxcXCJmcm9hbGEuZG9Jbml0XFxcIikpfSx0aGlzKSxkPWEucHJveHkoZnVuY3Rpb24oKXt0aGlzLiRib3g9YShcXFwiPGRpdj5cXFwiKSx0aGlzLiRvZWwuYmVmb3JlKHRoaXMuJGJveCkuaGlkZSgpLHRoaXMuX29yaWdpbmFsX2h0bWw9dGhpcy4kb2VsLnZhbCgpLHRoaXMuJG9lbC5wYXJlbnRzKFxcXCJmb3JtXFxcIikub24oXFxcInN1Ym1pdC5cXFwiK3RoaXMuaWQsYS5wcm94eShmdW5jdGlvbigpe3RoaXMuZXZlbnRzLnRyaWdnZXIoXFxcImZvcm0uc3VibWl0XFxcIil9LHRoaXMpKSx0aGlzLiRvZWwucGFyZW50cyhcXFwiZm9ybVxcXCIpLm9uKFxcXCJyZXNldC5cXFwiK3RoaXMuaWQsYS5wcm94eShmdW5jdGlvbigpe3RoaXMuZXZlbnRzLnRyaWdnZXIoXFxcImZvcm0ucmVzZXRcXFwiKX0sdGhpcykpLGMoKX0sdGhpcyksZT1hLnByb3h5KGZ1bmN0aW9uKCl7dGhpcy4kZWw9dGhpcy4kb2VsLHRoaXMuJGVsLmF0dHIoXFxcImNvbnRlbnRlZGl0YWJsZVxcXCIsITApLmNzcyhcXFwib3V0bGluZVxcXCIsXFxcIm5vbmVcXFwiKS5jc3MoXFxcImRpc3BsYXlcXFwiLFxcXCJpbmxpbmUtYmxvY2tcXFwiKSx0aGlzLm9wdHMubXVsdGlMaW5lPSExLHRoaXMub3B0cy50b29sYmFySW5saW5lPSExLHRoaXMuJG9lbC50cmlnZ2VyKFxcXCJmcm9hbGEuZG9Jbml0XFxcIil9LHRoaXMpLGY9YS5wcm94eShmdW5jdGlvbigpe3RoaXMuJGVsPXRoaXMuJG9lbCx0aGlzLm9wdHMudG9vbGJhcklubGluZT0hMSx0aGlzLiRvZWwudHJpZ2dlcihcXFwiZnJvYWxhLmRvSW5pdFxcXCIpfSx0aGlzKSxnPWEucHJveHkoZnVuY3Rpb24oKXt0aGlzLiRlbD10aGlzLiRvZWwsdGhpcy5vcHRzLnRvb2xiYXJJbmxpbmU9ITEsdGhpcy4kb2VsLm9uKFxcXCJjbGljay5wb3B1cFxcXCIsZnVuY3Rpb24oYSl7YS5wcmV2ZW50RGVmYXVsdCgpfSksdGhpcy4kb2VsLnRyaWdnZXIoXFxcImZyb2FsYS5kb0luaXRcXFwiKX0sdGhpcyk7dGhpcy5vcHRzLmVkaXRJblBvcHVwP2coKTpcXFwiVEVYVEFSRUFcXFwiPT1iP2QoKTpcXFwiQVxcXCI9PWI/ZSgpOlxcXCJJTUdcXFwiPT1iP2YoKTpcXFwiQlVUVE9OXFxcIj09Ynx8XFxcIklOUFVUXFxcIj09Yj8odGhpcy5vcHRzLmVkaXRJblBvcHVwPSEwLHRoaXMub3B0cy50b29sYmFySW5saW5lPSExLGcoKSk6YygpfSxiLnByb3RvdHlwZS5sb2FkPWZ1bmN0aW9uKGIpe2Zvcih2YXIgYyBpbiBiKWlmKGIuaGFzT3duUHJvcGVydHkoYykpe2lmKHRoaXNbY10pY29udGludWU7aWYoYS5GRS5QTFVHSU5TW2NdJiZ0aGlzLm9wdHMucGx1Z2luc0VuYWJsZWQuaW5kZXhPZihjKTwwKWNvbnRpbnVlO2lmKHRoaXNbY109bmV3IGJbY10odGhpcyksdGhpc1tjXS5faW5pdCYmKHRoaXNbY10uX2luaXQoKSx0aGlzLm9wdHMuaW5pdE9uQ2xpY2smJlxcXCJjb3JlXFxcIj09YykpcmV0dXJuITF9fSxiLnByb3RvdHlwZS5kZXN0cm95PWZ1bmN0aW9uKCl7dGhpcy5zaGFyZWQuY291bnQtLSx0aGlzLmV2ZW50cy4kb2ZmKCk7dmFyIGI9dGhpcy5odG1sLmdldCgpO2lmKHRoaXMuZXZlbnRzLnRyaWdnZXIoXFxcImRlc3Ryb3lcXFwiLFtdLCEwKSx0aGlzLmV2ZW50cy50cmlnZ2VyKFxcXCJzaGFyZWQuZGVzdHJveVxcXCIsdm9pZCAwLCEwKSwwPT09dGhpcy5zaGFyZWQuY291bnQpe2Zvcih2YXIgYyBpbiB0aGlzLnNoYXJlZCl0aGlzLnNoYXJlZC5oYXNPd25Qcm9wZXJ0eShjKSYmKG51bGw9PXRoaXMuc2hhcmVkW2NdLGEuRkUuU0hBUkVEW3RoaXMuc2lkXVtjXT1udWxsKTthLkZFLlNIQVJFRFt0aGlzLnNpZF09e319dGhpcy4kb2VsLnBhcmVudHMoXFxcImZvcm1cXFwiKS5vZmYoXFxcIi5cXFwiK3RoaXMuaWQpLHRoaXMuJG9lbC5vZmYoXFxcImNsaWNrLnBvcHVwXFxcIiksdGhpcy4kb2VsLnJlbW92ZURhdGEoXFxcImZyb2FsYS5lZGl0b3JcXFwiKSx0aGlzLiRvZWwub2ZmKFxcXCJmcm9hbGFFZGl0b3JcXFwiKSx0aGlzLmNvcmUuZGVzdHJveShiKSxhLkZFLklOU1RBTkNFUy5zcGxpY2UoYS5GRS5JTlNUQU5DRVMuaW5kZXhPZih0aGlzKSwxKX0sYS5mbi5mcm9hbGFFZGl0b3I9ZnVuY3Rpb24oYyl7Zm9yKHZhciBkPVtdLGU9MDtlPGFyZ3VtZW50cy5sZW5ndGg7ZSsrKWQucHVzaChhcmd1bWVudHNbZV0pO2lmKFxcXCJzdHJpbmdcXFwiPT10eXBlb2YgYyl7dmFyIGY9W107cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpe3ZhciBiPWEodGhpcyksZT1iLmRhdGEoXFxcImZyb2FsYS5lZGl0b3JcXFwiKTtpZihlKXt2YXIgZyxoO2lmKGMuaW5kZXhPZihcXFwiLlxcXCIpPjAmJmVbYy5zcGxpdChcXFwiLlxcXCIpWzBdXT8oZVtjLnNwbGl0KFxcXCIuXFxcIilbMF1dJiYoZz1lW2Muc3BsaXQoXFxcIi5cXFwiKVswXV0pLGg9Yy5zcGxpdChcXFwiLlxcXCIpWzFdKTooZz1lLGg9Yy5zcGxpdChcXFwiLlxcXCIpWzBdKSwhZ1toXSlyZXR1cm4gYS5lcnJvcihcXFwiTWV0aG9kIFxcXCIrYytcXFwiIGRvZXMgbm90IGV4aXN0IGluIEZyb2FsYSBFZGl0b3IuXFxcIik7dmFyIGk9Z1toXS5hcHBseShlLGQuc2xpY2UoMSkpO3ZvaWQgMD09PWk/Zi5wdXNoKHRoaXMpOjA9PT1mLmxlbmd0aCYmZi5wdXNoKGkpfX0pLDE9PWYubGVuZ3RoP2ZbMF06Zn1yZXR1cm5cXFwib2JqZWN0XFxcIiE9dHlwZW9mIGMmJmM/dm9pZCAwOnRoaXMuZWFjaChmdW5jdGlvbigpe3ZhciBkPWEodGhpcykuZGF0YShcXFwiZnJvYWxhLmVkaXRvclxcXCIpO2lmKCFkKXt2YXIgZT10aGlzO25ldyBiKGUsYyl9fSl9LGEuZm4uZnJvYWxhRWRpdG9yLkNvbnN0cnVjdG9yPWIsYS5Gcm9hbGFFZGl0b3I9YixhLkZFPWIsYS5GRS5NT0RVTEVTLm5vZGU9ZnVuY3Rpb24oYil7ZnVuY3Rpb24gYyhiKXtyZXR1cm4gYiYmXFxcIklGUkFNRVxcXCIhPWIudGFnTmFtZT9hKGIpLmNvbnRlbnRzKCk6W119ZnVuY3Rpb24gZChiKXtyZXR1cm4gYj9iLm5vZGVUeXBlIT1Ob2RlLkVMRU1FTlRfTk9ERT8hMTphLkZFLkJMT0NLX1RBR1MuaW5kZXhPZihiLnRhZ05hbWUudG9Mb3dlckNhc2UoKSk+PTA6ITF9ZnVuY3Rpb24gZShlLGYpe2lmKGEoZSkuZmluZChcXFwidGFibGVcXFwiKS5sZW5ndGg+MClyZXR1cm4hMTtpZihlLnF1ZXJ5U2VsZWN0b3JBbGwoYS5GRS5WT0lEX0VMRU1FTlRTLmpvaW4oXFxcIixcXFwiKSkubGVuZ3RoLWUucXVlcnlTZWxlY3RvckFsbChcXFwiYnJcXFwiKS5sZW5ndGgpcmV0dXJuITE7aWYoZS5xdWVyeVNlbGVjdG9yQWxsKGIub3B0cy5odG1sQWxsb3dlZEVtcHR5VGFncy5qb2luKFxcXCI6bm90KC5mci1tYXJrZXIpLFxcXCIpK1xcXCI6bm90KC5mci1tYXJrZXIpXFxcIikubGVuZ3RoKXJldHVybiExO2lmKGUucXVlcnlTZWxlY3RvckFsbChhLkZFLkJMT0NLX1RBR1Muam9pbihcXFwiLFxcXCIpKS5sZW5ndGg+MSlyZXR1cm4hMTtpZihlLnF1ZXJ5U2VsZWN0b3JBbGwoYi5vcHRzLmh0bWxEb05vdFdyYXBUYWdzLmpvaW4oXFxcIjpub3QoLmZyLW1hcmtlciksXFxcIikrXFxcIjpub3QoLmZyLW1hcmtlcilcXFwiKS5sZW5ndGgpcmV0dXJuITE7dmFyIGc9YyhlKTsxPT1nLmxlbmd0aCYmZChnWzBdKSYmKGc9YyhnWzBdKSk7Zm9yKHZhciBoPSExLGk9MDtpPGcubGVuZ3RoO2krKyl7dmFyIGo9Z1tpXTtpZighKGYmJmEoaikuaGFzQ2xhc3MoXFxcImZyLW1hcmtlclxcXCIpfHxqLm5vZGVUeXBlPT1Ob2RlLlRFWFRfTk9ERSYmMD09ai50ZXh0Q29udGVudC5sZW5ndGgpKXtpZihcXFwiQlJcXFwiIT1qLnRhZ05hbWUmJihqLnRleHRDb250ZW50fHxcXFwiXFxcIikucmVwbGFjZSgvXFxcXHUyMDBCL2dpLFxcXCJcXFwiKS5yZXBsYWNlKC9cXFxcbi9nLFxcXCJcXFwiKS5sZW5ndGg+MClyZXR1cm4hMTtpZihoKXJldHVybiExO1xcXCJCUlxcXCI9PWoudGFnTmFtZSYmKGg9ITApfX1yZXR1cm4hMH1mdW5jdGlvbiBmKGMpe2Zvcig7YyYmYy5wYXJlbnROb2RlIT09Yi4kZWwuZ2V0KDApJiYoIWMucGFyZW50Tm9kZXx8IWEoYy5wYXJlbnROb2RlKS5oYXNDbGFzcyhcXFwiZnItaW5uZXJcXFwiKSk7KWlmKGM9Yy5wYXJlbnROb2RlLGQoYykpcmV0dXJuIGM7cmV0dXJuIG51bGx9ZnVuY3Rpb24gZyhjLGUsZil7aWYoXFxcInVuZGVmaW5lZFxcXCI9PXR5cGVvZiBlJiYoZT1bXSksXFxcInVuZGVmaW5lZFxcXCI9PXR5cGVvZiBmJiYoZj0hMCksZS5wdXNoKGIuJGVsLmdldCgwKSksZS5pbmRleE9mKGMucGFyZW50Tm9kZSk+PTB8fGMucGFyZW50Tm9kZSYmYShjLnBhcmVudE5vZGUpLmhhc0NsYXNzKFxcXCJmci1pbm5lclxcXCIpfHxjLnBhcmVudE5vZGUmJmEuRkUuU0lNUExFX0VOVEVSX1RBR1MuaW5kZXhPZihjLnBhcmVudE5vZGUudGFnTmFtZSk+PTAmJmYpcmV0dXJuIG51bGw7Zm9yKDtlLmluZGV4T2YoYy5wYXJlbnROb2RlKTwwJiZjLnBhcmVudE5vZGUmJiFhKGMucGFyZW50Tm9kZSkuaGFzQ2xhc3MoXFxcImZyLWlubmVyXFxcIikmJihhLkZFLlNJTVBMRV9FTlRFUl9UQUdTLmluZGV4T2YoYy5wYXJlbnROb2RlLnRhZ05hbWUpPDB8fCFmKSYmKCFkKGMpfHwhZChjLnBhcmVudE5vZGUpfHwhZik7KWM9Yy5wYXJlbnROb2RlO3JldHVybiBjfWZ1bmN0aW9uIGgoYSl7dmFyIGI9e30sYz1hLmF0dHJpYnV0ZXM7aWYoYylmb3IodmFyIGQ9MDtkPGMubGVuZ3RoO2QrKyl7dmFyIGU9Y1tkXTtiW2Uubm9kZU5hbWVdPWUudmFsdWV9cmV0dXJuIGJ9ZnVuY3Rpb24gaShhKXtmb3IodmFyIGI9XFxcIlxcXCIsYz1oKGEpLGQ9T2JqZWN0LmtleXMoYykuc29ydCgpLGU9MDtlPGQubGVuZ3RoO2UrKyl7dmFyIGY9ZFtlXSxnPWNbZl07Yis9Zy5pbmRleE9mKCdcXFwiJyk8MD9cXFwiIFxcXCIrZisnPVxcXCInK2crJ1xcXCInOlxcXCIgXFxcIitmK1xcXCI9J1xcXCIrZytcXFwiJ1xcXCJ9cmV0dXJuIGJ9ZnVuY3Rpb24gaihhKXtmb3IodmFyIGI9YS5hdHRyaWJ1dGVzLGM9MDtjPGIubGVuZ3RoO2MrKyl7dmFyIGQ9YltjXTthLnJlbW92ZUF0dHJpYnV0ZShkLm5vZGVOYW1lKX19ZnVuY3Rpb24gayhhKXtyZXR1cm5cXFwiPFxcXCIrYS50YWdOYW1lLnRvTG93ZXJDYXNlKCkraShhKStcXFwiPlxcXCJ9ZnVuY3Rpb24gbChhKXtyZXR1cm5cXFwiPC9cXFwiK2EudGFnTmFtZS50b0xvd2VyQ2FzZSgpK1xcXCI+XFxcIn1mdW5jdGlvbiBtKGIsYyl7XFxcInVuZGVmaW5lZFxcXCI9PXR5cGVvZiBjJiYoYz0hMCk7Zm9yKHZhciBkPWIucHJldmlvdXNTaWJsaW5nO2QmJmMmJmEoZCkuaGFzQ2xhc3MoXFxcImZyLW1hcmtlclxcXCIpOylkPWQucHJldmlvdXNTaWJsaW5nO3JldHVybiBkP2Qubm9kZVR5cGU9PU5vZGUuVEVYVF9OT0RFJiZcXFwiXFxcIj09PWQudGV4dENvbnRlbnQ/bShkKTohMTohMH1mdW5jdGlvbiBuKGIsYyl7XFxcInVuZGVmaW5lZFxcXCI9PXR5cGVvZiBjJiYoYz0hMCk7Zm9yKHZhciBkPWIubmV4dFNpYmxpbmc7ZCYmYyYmYShkKS5oYXNDbGFzcyhcXFwiZnItbWFya2VyXFxcIik7KWQ9ZC5uZXh0U2libGluZztyZXR1cm4gZD9kLm5vZGVUeXBlPT1Ob2RlLlRFWFRfTk9ERSYmXFxcIlxcXCI9PT1kLnRleHRDb250ZW50P24oZCk6ITE6ITB9ZnVuY3Rpb24gbyhiKXtyZXR1cm4gYiYmYi5ub2RlVHlwZT09Tm9kZS5FTEVNRU5UX05PREUmJmEuRkUuVk9JRF9FTEVNRU5UUy5pbmRleE9mKChiLnRhZ05hbWV8fFxcXCJcXFwiKS50b0xvd2VyQ2FzZSgpKT49MH1mdW5jdGlvbiBwKGEpe3JldHVybiBhP1tcXFwiVUxcXFwiLFxcXCJPTFxcXCJdLmluZGV4T2YoYS50YWdOYW1lKT49MDohMX1mdW5jdGlvbiBxKGEpe3JldHVybiBhPT09Yi4kZWwuZ2V0KDApfWZ1bmN0aW9uIHIoYSl7cmV0dXJuIGEmJmEubm9kZVR5cGU9PU5vZGUuRUxFTUVOVF9OT0RFJiZhLmdldEF0dHJpYnV0ZShcXFwiY2xhc3NcXFwiKSYmKGEuZ2V0QXR0cmlidXRlKFxcXCJjbGFzc1xcXCIpfHxcXFwiXFxcIikuaW5kZXhPZihcXFwiZnItZGVsZXRhYmxlXFxcIik+PTB9ZnVuY3Rpb24gcyhhKXtyZXR1cm4gYT09PWIuZG9jLmFjdGl2ZUVsZW1lbnQmJighYi5kb2MuaGFzRm9jdXN8fGIuZG9jLmhhc0ZvY3VzKCkpJiYhIShxKGEpfHxhLnR5cGV8fGEuaHJlZnx8fmEudGFiSW5kZXgpfWZ1bmN0aW9uIHQoYSl7cmV0dXJuKCFhLmdldEF0dHJpYnV0ZXx8XFxcImZhbHNlXFxcIiE9YS5nZXRBdHRyaWJ1dGUoXFxcImNvbnRlbnRlZGl0YWJsZVxcXCIpKSYmW1xcXCJTVFlMRVxcXCIsXFxcIlNDUklQVFxcXCJdLmluZGV4T2YoYS50YWdOYW1lKTwwfXJldHVybntpc0Jsb2NrOmQsaXNFbXB0eTplLGJsb2NrUGFyZW50OmYsZGVlcGVzdFBhcmVudDpnLHJhd0F0dHJpYnV0ZXM6aCxhdHRyaWJ1dGVzOmksY2xlYXJBdHRyaWJ1dGVzOmosb3BlblRhZ1N0cmluZzprLGNsb3NlVGFnU3RyaW5nOmwsaXNGaXJzdFNpYmxpbmc6bSxpc0xhc3RTaWJsaW5nOm4saXNMaXN0OnAsaXNFbGVtZW50OnEsY29udGVudHM6Yyxpc1ZvaWQ6byxoYXNGb2N1czpzLGlzRWRpdGFibGU6dCxpc0RlbGV0YWJsZTpyfX0sYS5leHRlbmQoYS5GRS5ERUZBVUxUUyx7aHRtbEFsbG93ZWRUYWdzOltcXFwiYVxcXCIsXFxcImFiYnJcXFwiLFxcXCJhZGRyZXNzXFxcIixcXFwiYXJlYVxcXCIsXFxcImFydGljbGVcXFwiLFxcXCJhc2lkZVxcXCIsXFxcImF1ZGlvXFxcIixcXFwiYlxcXCIsXFxcImJhc2VcXFwiLFxcXCJiZGlcXFwiLFxcXCJiZG9cXFwiLFxcXCJibG9ja3F1b3RlXFxcIixcXFwiYnJcXFwiLFxcXCJidXR0b25cXFwiLFxcXCJjYW52YXNcXFwiLFxcXCJjYXB0aW9uXFxcIixcXFwiY2l0ZVxcXCIsXFxcImNvZGVcXFwiLFxcXCJjb2xcXFwiLFxcXCJjb2xncm91cFxcXCIsXFxcImRhdGFsaXN0XFxcIixcXFwiZGRcXFwiLFxcXCJkZWxcXFwiLFxcXCJkZXRhaWxzXFxcIixcXFwiZGZuXFxcIixcXFwiZGlhbG9nXFxcIixcXFwiZGl2XFxcIixcXFwiZGxcXFwiLFxcXCJkdFxcXCIsXFxcImVtXFxcIixcXFwiZW1iZWRcXFwiLFxcXCJmaWVsZHNldFxcXCIsXFxcImZpZ2NhcHRpb25cXFwiLFxcXCJmaWd1cmVcXFwiLFxcXCJmb290ZXJcXFwiLFxcXCJmb3JtXFxcIixcXFwiaDFcXFwiLFxcXCJoMlxcXCIsXFxcImgzXFxcIixcXFwiaDRcXFwiLFxcXCJoNVxcXCIsXFxcImg2XFxcIixcXFwiaGVhZGVyXFxcIixcXFwiaGdyb3VwXFxcIixcXFwiaHJcXFwiLFxcXCJpXFxcIixcXFwiaWZyYW1lXFxcIixcXFwiaW1nXFxcIixcXFwiaW5wdXRcXFwiLFxcXCJpbnNcXFwiLFxcXCJrYmRcXFwiLFxcXCJrZXlnZW5cXFwiLFxcXCJsYWJlbFxcXCIsXFxcImxlZ2VuZFxcXCIsXFxcImxpXFxcIixcXFwibGlua1xcXCIsXFxcIm1haW5cXFwiLFxcXCJtYXBcXFwiLFxcXCJtYXJrXFxcIixcXFwibWVudVxcXCIsXFxcIm1lbnVpdGVtXFxcIixcXFwibWV0ZXJcXFwiLFxcXCJuYXZcXFwiLFxcXCJub3NjcmlwdFxcXCIsXFxcIm9iamVjdFxcXCIsXFxcIm9sXFxcIixcXFwib3B0Z3JvdXBcXFwiLFxcXCJvcHRpb25cXFwiLFxcXCJvdXRwdXRcXFwiLFxcXCJwXFxcIixcXFwicGFyYW1cXFwiLFxcXCJwcmVcXFwiLFxcXCJwcm9ncmVzc1xcXCIsXFxcInF1ZXVlXFxcIixcXFwicnBcXFwiLFxcXCJydFxcXCIsXFxcInJ1YnlcXFwiLFxcXCJzXFxcIixcXFwic2FtcFxcXCIsXFxcInNjcmlwdFxcXCIsXFxcInN0eWxlXFxcIixcXFwic2VjdGlvblxcXCIsXFxcInNlbGVjdFxcXCIsXFxcInNtYWxsXFxcIixcXFwic291cmNlXFxcIixcXFwic3BhblxcXCIsXFxcInN0cmlrZVxcXCIsXFxcInN0cm9uZ1xcXCIsXFxcInN1YlxcXCIsXFxcInN1bW1hcnlcXFwiLFxcXCJzdXBcXFwiLFxcXCJ0YWJsZVxcXCIsXFxcInRib2R5XFxcIixcXFwidGRcXFwiLFxcXCJ0ZXh0YXJlYVxcXCIsXFxcInRmb290XFxcIixcXFwidGhcXFwiLFxcXCJ0aGVhZFxcXCIsXFxcInRpbWVcXFwiLFxcXCJ0clxcXCIsXFxcInRyYWNrXFxcIixcXFwidVxcXCIsXFxcInVsXFxcIixcXFwidmFyXFxcIixcXFwidmlkZW9cXFwiLFxcXCJ3YnJcXFwiXSxodG1sUmVtb3ZlVGFnczpbXFxcInNjcmlwdFxcXCIsXFxcInN0eWxlXFxcIl0saHRtbEFsbG93ZWRBdHRyczpbXFxcImFjY2VwdFxcXCIsXFxcImFjY2VwdC1jaGFyc2V0XFxcIixcXFwiYWNjZXNza2V5XFxcIixcXFwiYWN0aW9uXFxcIixcXFwiYWxpZ25cXFwiLFxcXCJhbGxvd2Z1bGxzY3JlZW5cXFwiLFxcXCJhbGxvd3RyYW5zcGFyZW5jeVxcXCIsXFxcImFsdFxcXCIsXFxcImFzeW5jXFxcIixcXFwiYXV0b2NvbXBsZXRlXFxcIixcXFwiYXV0b2ZvY3VzXFxcIixcXFwiYXV0b3BsYXlcXFwiLFxcXCJhdXRvc2F2ZVxcXCIsXFxcImJhY2tncm91bmRcXFwiLFxcXCJiZ2NvbG9yXFxcIixcXFwiYm9yZGVyXFxcIixcXFwiY2hhcnNldFxcXCIsXFxcImNlbGxwYWRkaW5nXFxcIixcXFwiY2VsbHNwYWNpbmdcXFwiLFxcXCJjaGVja2VkXFxcIixcXFwiY2l0ZVxcXCIsXFxcImNsYXNzXFxcIixcXFwiY29sb3JcXFwiLFxcXCJjb2xzXFxcIixcXFwiY29sc3BhblxcXCIsXFxcImNvbnRlbnRcXFwiLFxcXCJjb250ZW50ZWRpdGFibGVcXFwiLFxcXCJjb250ZXh0bWVudVxcXCIsXFxcImNvbnRyb2xzXFxcIixcXFwiY29vcmRzXFxcIixcXFwiZGF0YVxcXCIsXFxcImRhdGEtLipcXFwiLFxcXCJkYXRldGltZVxcXCIsXFxcImRlZmF1bHRcXFwiLFxcXCJkZWZlclxcXCIsXFxcImRpclxcXCIsXFxcImRpcm5hbWVcXFwiLFxcXCJkaXNhYmxlZFxcXCIsXFxcImRvd25sb2FkXFxcIixcXFwiZHJhZ2dhYmxlXFxcIixcXFwiZHJvcHpvbmVcXFwiLFxcXCJlbmN0eXBlXFxcIixcXFwiZm9yXFxcIixcXFwiZm9ybVxcXCIsXFxcImZvcm1hY3Rpb25cXFwiLFxcXCJmcmFtZWJvcmRlclxcXCIsXFxcImhlYWRlcnNcXFwiLFxcXCJoZWlnaHRcXFwiLFxcXCJoaWRkZW5cXFwiLFxcXCJoaWdoXFxcIixcXFwiaHJlZlxcXCIsXFxcImhyZWZsYW5nXFxcIixcXFwiaHR0cC1lcXVpdlxcXCIsXFxcImljb25cXFwiLFxcXCJpZFxcXCIsXFxcImlzbWFwXFxcIixcXFwiaXRlbXByb3BcXFwiLFxcXCJrZXl0eXBlXFxcIixcXFwia2luZFxcXCIsXFxcImxhYmVsXFxcIixcXFwibGFuZ1xcXCIsXFxcImxhbmd1YWdlXFxcIixcXFwibGlzdFxcXCIsXFxcImxvb3BcXFwiLFxcXCJsb3dcXFwiLFxcXCJtYXhcXFwiLFxcXCJtYXhsZW5ndGhcXFwiLFxcXCJtZWRpYVxcXCIsXFxcIm1ldGhvZFxcXCIsXFxcIm1pblxcXCIsXFxcIm1vemFsbG93ZnVsbHNjcmVlblxcXCIsXFxcIm11bHRpcGxlXFxcIixcXFwibmFtZVxcXCIsXFxcIm5vdmFsaWRhdGVcXFwiLFxcXCJvcGVuXFxcIixcXFwib3B0aW11bVxcXCIsXFxcInBhdHRlcm5cXFwiLFxcXCJwaW5nXFxcIixcXFwicGxhY2Vob2xkZXJcXFwiLFxcXCJwb3N0ZXJcXFwiLFxcXCJwcmVsb2FkXFxcIixcXFwicHViZGF0ZVxcXCIsXFxcInJhZGlvZ3JvdXBcXFwiLFxcXCJyZWFkb25seVxcXCIsXFxcInJlbFxcXCIsXFxcInJlcXVpcmVkXFxcIixcXFwicmV2ZXJzZWRcXFwiLFxcXCJyb3dzXFxcIixcXFwicm93c3BhblxcXCIsXFxcInNhbmRib3hcXFwiLFxcXCJzY29wZVxcXCIsXFxcInNjb3BlZFxcXCIsXFxcInNjcm9sbGluZ1xcXCIsXFxcInNlYW1sZXNzXFxcIixcXFwic2VsZWN0ZWRcXFwiLFxcXCJzaGFwZVxcXCIsXFxcInNpemVcXFwiLFxcXCJzaXplc1xcXCIsXFxcInNwYW5cXFwiLFxcXCJzcmNcXFwiLFxcXCJzcmNkb2NcXFwiLFxcXCJzcmNsYW5nXFxcIixcXFwic3Jjc2V0XFxcIixcXFwic3RhcnRcXFwiLFxcXCJzdGVwXFxcIixcXFwic3VtbWFyeVxcXCIsXFxcInNwZWxsY2hlY2tcXFwiLFxcXCJzdHlsZVxcXCIsXFxcInRhYmluZGV4XFxcIixcXFwidGFyZ2V0XFxcIixcXFwidGl0bGVcXFwiLFxcXCJ0eXBlXFxcIixcXFwidHJhbnNsYXRlXFxcIixcXFwidXNlbWFwXFxcIixcXFwidmFsdWVcXFwiLFxcXCJ2YWxpZ25cXFwiLFxcXCJ3ZWJraXRhbGxvd2Z1bGxzY3JlZW5cXFwiLFxcXCJ3aWR0aFxcXCIsXFxcIndyYXBcXFwiXSxodG1sQWxsb3dDb21tZW50czohMCxmdWxsUGFnZTohMX0pLGEuRkUuSFRNTDVNYXA9e0I6XFxcIlNUUk9OR1xcXCIsSTpcXFwiRU1cXFwiLFNUUklLRTpcXFwiU1xcXCJ9LGEuRkUuTU9EVUxFUy5jbGVhbj1mdW5jdGlvbihiKXtmdW5jdGlvbiBjKGEpe2lmKGEubm9kZVR5cGU9PU5vZGUuRUxFTUVOVF9OT0RFJiZhLmdldEF0dHJpYnV0ZShcXFwiY2xhc3NcXFwiKSYmYS5nZXRBdHRyaWJ1dGUoXFxcImNsYXNzXFxcIikuaW5kZXhPZihcXFwiZnItbWFya2VyXFxcIik+PTApcmV0dXJuITE7dmFyIGQsZT1iLm5vZGUuY29udGVudHMoYSksZj1bXTtmb3IoZD0wO2Q8ZS5sZW5ndGg7ZCsrKWVbZF0ubm9kZVR5cGUhPU5vZGUuRUxFTUVOVF9OT0RFfHxiLm5vZGUuaXNWb2lkKGVbZF0pP2VbZF0ubm9kZVR5cGU9PU5vZGUuVEVYVF9OT0RFJiYoZVtkXS50ZXh0Q29udGVudD1lW2RdLnRleHRDb250ZW50LnJlcGxhY2UoL1xcXFx1MjAwYi9nLFxcXCJcXFwiKS5yZXBsYWNlKC8mL2csXFxcIiZhbXA7XFxcIikpOmVbZF0udGV4dENvbnRlbnQucmVwbGFjZSgvXFxcXHUyMDBiL2csXFxcIlxcXCIpLmxlbmd0aCE9ZVtkXS50ZXh0Q29udGVudC5sZW5ndGgmJmMoZVtkXSk7aWYoYS5ub2RlVHlwZT09Tm9kZS5FTEVNRU5UX05PREUmJiFiLm5vZGUuaXNWb2lkKGEpJiYoYS5ub3JtYWxpemUoKSxlPWIubm9kZS5jb250ZW50cyhhKSxmPWEucXVlcnlTZWxlY3RvckFsbChcXFwiLmZyLW1hcmtlclxcXCIpLGUubGVuZ3RoLWYubGVuZ3RoPT0wKSl7Zm9yKGQ9MDtkPGUubGVuZ3RoO2QrKylpZigoZVtkXS5nZXRBdHRyaWJ1dGUoXFxcImNsYXNzXFxcIil8fFxcXCJcXFwiKS5pbmRleE9mKFxcXCJmci1tYXJrZXJcXFwiKTwwKXJldHVybiExO2ZvcihkPTA7ZDxmLmxlbmd0aDtkKyspYS5wYXJlbnROb2RlLmluc2VydEJlZm9yZShmW2RdLmNsb25lTm9kZSghMCksYSk7cmV0dXJuIGEucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChhKSwhMX19ZnVuY3Rpb24gZChhKXtpZihhLm5vZGVUeXBlPT1Ob2RlLkNPTU1FTlRfTk9ERSlyZXR1cm5cXFwiPCEtLVxcXCIrYS5ub2RlVmFsdWUrXFxcIi0tPlxcXCI7aWYoYS5ub2RlVHlwZT09Tm9kZS5URVhUX05PREUpcmV0dXJuIGEudGV4dENvbnRlbnQucmVwbGFjZSgvXFxcXCYvZyxcXFwiJmFtcDtcXFwiKS5yZXBsYWNlKC9cXFxcPC9nLFxcXCImbHQ7XFxcIikucmVwbGFjZSgvXFxcXD4vZyxcXFwiJmd0O1xcXCIpLnJlcGxhY2UoL1xcXFx1MDBBMC9nLFxcXCImbmJzcDtcXFwiKTtpZihhLm5vZGVUeXBlIT1Ob2RlLkVMRU1FTlRfTk9ERSlyZXR1cm4gYS5vdXRlckhUTUw7aWYoYS5ub2RlVHlwZT09Tm9kZS5FTEVNRU5UX05PREUmJltcXFwiU1RZTEVcXFwiLFxcXCJTQ1JJUFRcXFwiXS5pbmRleE9mKGEudGFnTmFtZSk+PTApcmV0dXJuIGEub3V0ZXJIVE1MO2lmKFxcXCJJRlJBTUVcXFwiPT1hLnRhZ05hbWUpcmV0dXJuIGEub3V0ZXJIVE1MO3ZhciBjPWEuY2hpbGROb2RlcztpZigwPT09Yy5sZW5ndGgpcmV0dXJuIGEub3V0ZXJIVE1MO2Zvcih2YXIgZT1cXFwiXFxcIixmPTA7ZjxjLmxlbmd0aDtmKyspZSs9ZChjW2ZdKTtyZXR1cm4gYi5ub2RlLm9wZW5UYWdTdHJpbmcoYSkrZStiLm5vZGUuY2xvc2VUYWdTdHJpbmcoYSl9ZnVuY3Rpb24gZShhKXtyZXR1cm4gSD1bXSxhPWEucmVwbGFjZSgvPHNjcmlwdFxcXFxiW148XSooPzooPyE8XFxcXC9zY3JpcHQ+KTxbXjxdKikqPFxcXFwvc2NyaXB0Pi9naSxmdW5jdGlvbihhKXtyZXR1cm4gSC5wdXNoKGEpLFxcXCJbRlJPQUxBLkVESVRPUi5TQ1JJUFQgXFxcIisoSC5sZW5ndGgtMSkrXFxcIl1cXFwifSksYT1hLnJlcGxhY2UoLzxpbWcoKD86W1xcXFx3XFxcXFddKj8pKSBzcmM9XFxcIi9nLCc8aW1nJDEgZGF0YS1mci1zcmM9XFxcIicpfWZ1bmN0aW9uIGYoYSl7cmV0dXJuIGE9YS5yZXBsYWNlKC9cXFxcW0ZST0FMQVxcXFwuRURJVE9SXFxcXC5TQ1JJUFQgKFtcXFxcZF0qKVxcXFxdL2dpLGZ1bmN0aW9uKGEsYyl7cmV0dXJuIGIub3B0cy5odG1sUmVtb3ZlVGFncy5pbmRleE9mKFxcXCJzY3JpcHRcXFwiKT49MD9cXFwiXFxcIjpIW3BhcnNlSW50KGMsMTApXX0pLGE9YS5yZXBsYWNlKC88aW1nKCg/OltcXFxcd1xcXFxXXSo/KSkgZGF0YS1mci1zcmM9XFxcIi9nLCc8aW1nJDEgc3JjPVxcXCInKX1mdW5jdGlvbiBnKGEpe3ZhciBiO2ZvcihiIGluIGEpYS5oYXNPd25Qcm9wZXJ0eShiKSYmKGIubWF0Y2goRyl8fGRlbGV0ZSBhW2JdKTtmb3IodmFyIGM9XFxcIlxcXCIsZD1PYmplY3Qua2V5cyhhKS5zb3J0KCksZT0wO2U8ZC5sZW5ndGg7ZSsrKWI9ZFtlXSxjKz1hW2JdLmluZGV4T2YoJ1xcXCInKTwwP1xcXCIgXFxcIitiKyc9XFxcIicrYVtiXSsnXFxcIic6XFxcIiBcXFwiK2IrXFxcIj0nXFxcIithW2JdK1xcXCInXFxcIjtyZXR1cm4gY31mdW5jdGlvbiBoKGEsYyxkKXtpZihiLm9wdHMuZnVsbFBhZ2Upe3ZhciBlPWIuaHRtbC5leHRyYWN0RG9jdHlwZShkKSxmPWcoYi5odG1sLmV4dHJhY3ROb2RlQXR0cnMoZCxcXFwiaHRtbFxcXCIpKTtjPW51bGw9PWM/Yi5odG1sLmV4dHJhY3ROb2RlKGQsXFxcImhlYWRcXFwiKXx8XFxcIjx0aXRsZT48L3RpdGxlPlxcXCI6Yzt2YXIgaD1nKGIuaHRtbC5leHRyYWN0Tm9kZUF0dHJzKGQsXFxcImhlYWRcXFwiKSksaT1nKGIuaHRtbC5leHRyYWN0Tm9kZUF0dHJzKGQsXFxcImJvZHlcXFwiKSk7cmV0dXJuIGUrXFxcIjxodG1sXFxcIitmK1xcXCI+PGhlYWRcXFwiK2grXFxcIj5cXFwiK2MrXFxcIjwvaGVhZD48Ym9keVxcXCIraStcXFwiPlxcXCIrYStcXFwiPC9ib2R5PjwvaHRtbD5cXFwifXJldHVybiBhfWZ1bmN0aW9uIGkoYyxlKXt2YXIgZj1hKFxcXCI8ZGl2PlxcXCIrYytcXFwiPC9kaXY+XFxcIiksZz1cXFwiXFxcIjtpZihmKXtmb3IodmFyIGg9Yi5ub2RlLmNvbnRlbnRzKGYuZ2V0KDApKSxpPTA7aTxoLmxlbmd0aDtpKyspZShoW2ldKTtoPWIubm9kZS5jb250ZW50cyhmLmdldCgwKSk7Zm9yKHZhciBpPTA7aTxoLmxlbmd0aDtpKyspZys9ZChoW2ldKX1yZXR1cm4gZ31mdW5jdGlvbiBqKGEsYyxkKXthPWUoYSk7dmFyIGc9YSxqPW51bGw7aWYoYi5vcHRzLmZ1bGxQYWdlKXt2YXIgZz1iLmh0bWwuZXh0cmFjdE5vZGUoYSxcXFwiYm9keVxcXCIpfHwoYS5pbmRleE9mKFxcXCI8Ym9keVxcXCIpPj0wP1xcXCJcXFwiOmEpO2QmJihqPWIuaHRtbC5leHRyYWN0Tm9kZShhLFxcXCJoZWFkXFxcIil8fFxcXCJcXFwiKX1nPWkoZyxjKSxqJiYoaj1pKGosYykpO3ZhciBrPWgoZyxqLGEpO3JldHVybiBmKGspfWZ1bmN0aW9uIGsoYSl7cmV0dXJuIGEucmVwbGFjZSgvXFxcXHUyMDBiL2csXFxcIlxcXCIpLmxlbmd0aD09YS5sZW5ndGg/YTpiLmNsZWFuLmV4ZWMoYSxjKX1mdW5jdGlvbiBsKCl7dmFyIGM9Yi4kZWwuZ2V0KDApLnF1ZXJ5U2VsZWN0b3JBbGwoT2JqZWN0LmtleXMoYS5GRS5IVE1MNU1hcCkuam9pbihcXFwiLFxcXCIpKTtpZihjLmxlbmd0aCl7dmFyIGQ9ITE7MD09Yi4kZWwuZ2V0KDApLnF1ZXJ5U2VsZWN0b3JBbGwoXFxcIi5mci1tYXJrZXJcXFwiKS5sZW5ndGgmJihiLnNlbGVjdGlvbi5zYXZlKCksZD0hMCk7Zm9yKHZhciBlPTA7ZTxjLmxlbmd0aDtlKyspXFxcIlxcXCI9PT1iLm5vZGUuYXR0cmlidXRlcyhjW2VdKSYmYShjW2VdKS5yZXBsYWNlV2l0aChcXFwiPFxcXCIrYS5GRS5IVE1MNU1hcFtjW2VdLnRhZ05hbWVdK1xcXCI+XFxcIitjW2VdLmlubmVySFRNTCtcXFwiPC9cXFwiK2EuRkUuSFRNTDVNYXBbY1tlXS50YWdOYW1lXStcXFwiPlxcXCIpO2QmJmIuc2VsZWN0aW9uLnJlc3RvcmUoKX19ZnVuY3Rpb24gbShjKXtpZihcXFwiU1BBTlxcXCI9PWMudGFnTmFtZSYmKGMuZ2V0QXR0cmlidXRlKFxcXCJjbGFzc1xcXCIpfHxcXFwiXFxcIikuaW5kZXhPZihcXFwiZnItbWFya2VyXFxcIik+PTApcmV0dXJuITE7aWYoXFxcIlBSRVxcXCI9PWMudGFnTmFtZSYmbyhjKSxjLm5vZGVUeXBlPT1Ob2RlLkVMRU1FTlRfTk9ERSYmKGMuZ2V0QXR0cmlidXRlKFxcXCJkYXRhLWZyLXNyY1xcXCIpJiZjLnNldEF0dHJpYnV0ZShcXFwiZGF0YS1mci1zcmNcXFwiLGIuaGVscGVycy5zYW5pdGl6ZVVSTChjLmdldEF0dHJpYnV0ZShcXFwiZGF0YS1mci1zcmNcXFwiKSkpLGMuZ2V0QXR0cmlidXRlKFxcXCJocmVmXFxcIikmJmMuc2V0QXR0cmlidXRlKFxcXCJocmVmXFxcIixiLmhlbHBlcnMuc2FuaXRpemVVUkwoYy5nZXRBdHRyaWJ1dGUoXFxcImhyZWZcXFwiKSkpLFtcXFwiVEFCTEVcXFwiLFxcXCJUQk9EWVxcXCIsXFxcIlRGT09UXFxcIixcXFwiVFJcXFwiXS5pbmRleE9mKGMudGFnTmFtZSk+PTAmJihjLmlubmVySFRNTD1jLmlubmVySFRNTC50cmltKCkpKSwhYi5vcHRzLnBhc3RlQWxsb3dMb2NhbEltYWdlcyYmYy5ub2RlVHlwZT09Tm9kZS5FTEVNRU5UX05PREUmJlxcXCJJTUdcXFwiPT1jLnRhZ05hbWUmJmMuZ2V0QXR0cmlidXRlKFxcXCJkYXRhLWZyLXNyY1xcXCIpJiYwPT1jLmdldEF0dHJpYnV0ZShcXFwiZGF0YS1mci1zcmNcXFwiKS5pbmRleE9mKFxcXCJmaWxlOi8vXFxcIikpcmV0dXJuIGMucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChjKSwhMTtpZihjLm5vZGVUeXBlPT1Ob2RlLkVMRU1FTlRfTk9ERSYmYS5GRS5IVE1MNU1hcFtjLnRhZ05hbWVdJiZcXFwiXFxcIj09PWIubm9kZS5hdHRyaWJ1dGVzKGMpKXt2YXIgZD1hLkZFLkhUTUw1TWFwW2MudGFnTmFtZV0sZT1cXFwiPFxcXCIrZCtcXFwiPlxcXCIrYy5pbm5lckhUTUwrXFxcIjwvXFxcIitkK1xcXCI+XFxcIjtjLmluc2VydEFkamFjZW50SFRNTChcXFwiYmVmb3JlYmVnaW5cXFwiLGUpLGM9Yy5wcmV2aW91c1NpYmxpbmcsYy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGMubmV4dFNpYmxpbmcpfWlmKGIub3B0cy5odG1sQWxsb3dDb21tZW50c3x8Yy5ub2RlVHlwZSE9Tm9kZS5DT01NRU5UX05PREUpaWYoYy50YWdOYW1lJiZjLnRhZ05hbWUubWF0Y2goRikpYy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGMpO2Vsc2UgaWYoYy50YWdOYW1lJiYhYy50YWdOYW1lLm1hdGNoKEUpKWMub3V0ZXJIVE1MPWMuaW5uZXJIVE1MO2Vsc2V7dmFyIGY9Yy5hdHRyaWJ1dGVzO2lmKGYpZm9yKHZhciBnPWYubGVuZ3RoLTE7Zz49MDtnLS0pe3ZhciBoPWZbZ107aC5ub2RlTmFtZS5tYXRjaChHKXx8Yy5yZW1vdmVBdHRyaWJ1dGUoaC5ub2RlTmFtZSl9fWVsc2UgMCE9PWMuZGF0YS5pbmRleE9mKFxcXCJbRlJPQUxBLkVESVRPUlxcXCIpJiZjLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoYyl9ZnVuY3Rpb24gbihhKXtmb3IodmFyIGM9Yi5ub2RlLmNvbnRlbnRzKGEpLGQ9MDtkPGMubGVuZ3RoO2QrKyljW2RdLm5vZGVUeXBlIT1Ob2RlLlRFWFRfTk9ERSYmbihjW2RdKTttKGEpfWZ1bmN0aW9uIG8oYSl7dmFyIGI9YS5pbm5lckhUTUw7Yi5pbmRleE9mKFxcXCJcXFxcblxcXCIpPj0wJiYoYS5pbm5lckhUTUw9Yi5yZXBsYWNlKC9cXFxcbi9nLFxcXCI8YnI+XFxcIikpfWZ1bmN0aW9uIHAoYyxkLGUsZil7XFxcInVuZGVmaW5lZFxcXCI9PXR5cGVvZiBkJiYoZD1bXSksXFxcInVuZGVmaW5lZFxcXCI9PXR5cGVvZiBlJiYoZT1bXSksXFxcInVuZGVmaW5lZFxcXCI9PXR5cGVvZiBmJiYoZj0hMSksYz1jLnJlcGxhY2UoL1xcXFx1MDAwOS9nLFxcXCJcXFwiKTt2YXIgZyxoPWEubWVyZ2UoW10sYi5vcHRzLmh0bWxBbGxvd2VkVGFncyk7Zm9yKGc9MDtnPGQubGVuZ3RoO2crKyloLmluZGV4T2YoZFtnXSk+PTAmJmguc3BsaWNlKGguaW5kZXhPZihkW2ddKSwxKTt2YXIgaT1hLm1lcmdlKFtdLGIub3B0cy5odG1sQWxsb3dlZEF0dHJzKTtmb3IoZz0wO2c8ZS5sZW5ndGg7ZysrKWkuaW5kZXhPZihlW2ddKT49MCYmaS5zcGxpY2UoaS5pbmRleE9mKGVbZ10pLDEpO3JldHVybiBpLnB1c2goXFxcImRhdGEtZnItLipcXFwiKSxpLnB1c2goXFxcImZyLS4qXFxcIiksRT1uZXcgUmVnRXhwKFxcXCJeXFxcIitoLmpvaW4oXFxcIiR8XlxcXCIpK1xcXCIkXFxcIixcXFwiZ2lcXFwiKSxHPW5ldyBSZWdFeHAoXFxcIl5cXFwiK2kuam9pbihcXFwiJHxeXFxcIikrXFxcIiRcXFwiLFxcXCJnaVxcXCIpLEY9bmV3IFJlZ0V4cChcXFwiXlxcXCIrYi5vcHRzLmh0bWxSZW1vdmVUYWdzLmpvaW4oXFxcIiR8XlxcXCIpK1xcXCIkXFxcIixcXFwiZ2lcXFwiKSxjPWooYyxuLCEwKX1mdW5jdGlvbiBxKCl7Zm9yKHZhciBjPWIuJGVsLmdldCgwKS5xdWVyeVNlbGVjdG9yQWxsKFxcXCJibG9ja3F1b3RlICsgYmxvY2txdW90ZVxcXCIpLGQ9MDtkPGMubGVuZ3RoO2QrKyl7dmFyIGU9Y1tkXTtiLm5vZGUuYXR0cmlidXRlcyhlKT09Yi5ub2RlLmF0dHJpYnV0ZXMoZS5wcmV2aW91c1NpYmxpbmcpJiYoYShlKS5wcmV2KCkuYXBwZW5kKGEoZSkuaHRtbCgpKSxhKGUpLnJlbW92ZSgpKX19ZnVuY3Rpb24gcigpe2Zvcih2YXIgYT1iLiRlbC5nZXQoMCkucXVlcnlTZWxlY3RvckFsbChcXFwidHJcXFwiKSxjPTA7YzxhLmxlbmd0aDtjKyspe2Zvcih2YXIgZD1hW2NdLmNoaWxkcmVuLGU9ITAsZj0wO2Y8ZC5sZW5ndGg7ZisrKWlmKFxcXCJUSFxcXCIhPWRbZl0udGFnTmFtZSl7ZT0hMTticmVha31pZigwIT1lJiYwIT1kLmxlbmd0aCl7Zm9yKHZhciBnPWFbY107ZyYmXFxcIlRBQkxFXFxcIiE9Zy50YWdOYW1lJiZcXFwiVEhFQURcXFwiIT1nLnRhZ05hbWU7KWc9Zy5wYXJlbnROb2RlO3ZhciBoPWc7XFxcIlRIRUFEXFxcIiE9aC50YWdOYW1lJiYoaD1iLmRvYy5jcmVhdGVFbGVtZW50KFxcXCJUSEVBRFxcXCIpLGcuaW5zZXJ0QmVmb3JlKGgsZy5maXJzdENoaWxkKSksaC5hcHBlbmRDaGlsZChhW2NdKX19fWZ1bmN0aW9uIHMoKXt2YXIgYz1iLmh0bWwuZGVmYXVsdFRhZygpO2lmKGMpZm9yKHZhciBkPWIuJGVsLmdldCgwKS5xdWVyeVNlbGVjdG9yQWxsKFxcXCJ0ZCA+IFxcXCIrYytcXFwiLCB0aCA+IFxcXCIrYyksZT0wO2U8ZC5sZW5ndGg7ZSsrKVxcXCJcXFwiPT09Yi5ub2RlLmF0dHJpYnV0ZXMoZFtlXSkmJmEoZFtlXSkucmVwbGFjZVdpdGgoZFtlXS5pbm5lckhUTUwrXFxcIjxicj5cXFwiKX1mdW5jdGlvbiB0KCl7cigpLHMoKX1mdW5jdGlvbiB1KCl7dmFyIGE9W10sYz1mdW5jdGlvbihhKXtyZXR1cm4hYi5ub2RlLmlzTGlzdChhLnBhcmVudE5vZGUpfTtkb3tpZihhLmxlbmd0aCl7dmFyIGQ9YVswXSxlPWIuZG9jLmNyZWF0ZUVsZW1lbnQoXFxcInVsXFxcIik7ZC5wYXJlbnROb2RlLmluc2VydEJlZm9yZShlLGQpO2Rve3ZhciBmPWQ7ZD1kLm5leHRTaWJsaW5nLGUuYXBwZW5kQ2hpbGQoZil9d2hpbGUoZCYmXFxcIkxJXFxcIj09ZC50YWdOYW1lKX1hPVtdO2Zvcih2YXIgZz1iLiRlbC5nZXQoMCkucXVlcnlTZWxlY3RvckFsbChcXFwibGlcXFwiKSxoPTA7aDxnLmxlbmd0aDtoKyspYyhnW2hdKSYmYS5wdXNoKGdbaF0pfXdoaWxlKGEubGVuZ3RoPjApfWZ1bmN0aW9uIHYoKXtmb3IodmFyIGE9Yi4kZWwuZ2V0KDApLnF1ZXJ5U2VsZWN0b3JBbGwoXFxcIm9sICsgb2wsIHVsICsgdWxcXFwiKSxjPTA7YzxhLmxlbmd0aDtjKyspe3ZhciBkPWFbY107aWYoYi5ub2RlLmlzTGlzdChkLnByZXZpb3VzU2libGluZykmJmIubm9kZS5vcGVuVGFnU3RyaW5nKGQpPT1iLm5vZGUub3BlblRhZ1N0cmluZyhkLnByZXZpb3VzU2libGluZykpe2Zvcih2YXIgZT1iLm5vZGUuY29udGVudHMoZCksZj0wO2Y8ZS5sZW5ndGg7ZisrKWQucHJldmlvdXNTaWJsaW5nLmFwcGVuZENoaWxkKGVbZl0pO2QucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChkKX19fWZ1bmN0aW9uIHcoKXt2YXIgYSxjPWZ1bmN0aW9uKGIpezA9PT1iLnF1ZXJ5U2VsZWN0b3JBbGwoXFxcIkxJXFxcIikubGVuZ3RoJiYoYT0hMCxiLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoYikpfTtkb3thPSExO2Zvcih2YXIgZD1iLiRlbC5nZXQoMCkucXVlcnlTZWxlY3RvckFsbChcXFwibGk6ZW1wdHlcXFwiKSxlPTA7ZTxkLmxlbmd0aDtlKyspZFtlXS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGRbZV0pO2Zvcih2YXIgZj1iLiRlbC5nZXQoMCkucXVlcnlTZWxlY3RvckFsbChcXFwidWwsIG9sXFxcIiksZT0wO2U8Zi5sZW5ndGg7ZSsrKWMoZltlXSl9d2hpbGUoYT09PSEwKX1mdW5jdGlvbiB4KCl7Zm9yKHZhciBjPWIuJGVsLmdldCgwKS5xdWVyeVNlbGVjdG9yQWxsKFxcXCJ1bCA+IHVsLCBvbCA+IG9sLCB1bCA+IG9sLCBvbCA+IHVsXFxcIiksZD0wO2Q8Yy5sZW5ndGg7ZCsrKXt2YXIgZT1jW2RdLGY9ZS5wcmV2aW91c1NpYmxpbmc7ZiYmKFxcXCJMSVxcXCI9PWYudGFnTmFtZT9mLmFwcGVuZENoaWxkKGUpOmEoZSkud3JhcChcXFwiPGxpPjwvbGk+XFxcIikpfX1mdW5jdGlvbiB5KCl7Zm9yKHZhciBjPWIuJGVsLmdldCgwKS5xdWVyeVNlbGVjdG9yQWxsKFxcXCJsaSA+IHVsLCBsaSA+IG9sXFxcIiksZD0wO2Q8Yy5sZW5ndGg7ZCsrKXt2YXIgZT1jW2RdO2lmKGUubmV4dFNpYmxpbmcpe3ZhciBmPWUubmV4dFNpYmxpbmcsZz1hKFxcXCI8bGk+XFxcIik7YShlLnBhcmVudE5vZGUpLmFmdGVyKGcpO2Rve3ZhciBoPWY7Zj1mLm5leHRTaWJsaW5nLGcuYXBwZW5kKGgpfXdoaWxlKGYpfX19ZnVuY3Rpb24geigpe2Zvcih2YXIgYz1iLiRlbC5nZXQoMCkucXVlcnlTZWxlY3RvckFsbChcXFwibGkgPiB1bCwgbGkgPiBvbFxcXCIpLGQ9MDtkPGMubGVuZ3RoO2QrKyl7dmFyIGU9Y1tkXTtpZihiLm5vZGUuaXNGaXJzdFNpYmxpbmcoZSkpYShlKS5iZWZvcmUoXFxcIjxici8+XFxcIik7ZWxzZSBpZihlLnByZXZpb3VzU2libGluZyYmXFxcIkJSXFxcIj09ZS5wcmV2aW91c1NpYmxpbmcudGFnTmFtZSl7Zm9yKHZhciBmPWUucHJldmlvdXNTaWJsaW5nLnByZXZpb3VzU2libGluZztmJiZhKGYpLmhhc0NsYXNzKFxcXCJmci1tYXJrZXJcXFwiKTspZj1mLnByZXZpb3VzU2libGluZztmJiZcXFwiQlJcXFwiIT1mLnRhZ05hbWUmJmEoZS5wcmV2aW91c1NpYmxpbmcpLnJlbW92ZSgpfX19ZnVuY3Rpb24gQSgpe2Zvcih2YXIgYz1iLiRlbC5nZXQoMCkucXVlcnlTZWxlY3RvckFsbChcXFwibGk6ZW1wdHlcXFwiKSxkPTA7ZDxjLmxlbmd0aDtkKyspYShjW2RdKS5yZW1vdmUoKX1mdW5jdGlvbiBCKCl7Zm9yKHZhciBjPWIuJGVsLmdldCgwKS5xdWVyeVNlbGVjdG9yQWxsKFxcXCJ1bCwgb2xcXFwiKSxkPTA7ZDxjLmxlbmd0aDtkKyspZm9yKHZhciBlPWIubm9kZS5jb250ZW50cyhjW2RdKSxmPW51bGwsZz1lLmxlbmd0aC0xO2c+PTA7Zy0tKVxcXCJMSVxcXCIhPWVbZ10udGFnTmFtZT8oZnx8KGY9YShcXFwiPGxpPlxcXCIpLGYuaW5zZXJ0QmVmb3JlKGVbZ10pKSxmLnByZXBlbmQoZVtnXSkpOmY9bnVsbH1mdW5jdGlvbiBDKCl7dSgpLHYoKSx3KCkseCgpLHkoKSx6KCksQigpLEEoKX1mdW5jdGlvbiBEKCl7Yi5vcHRzLmZ1bGxQYWdlJiZhLm1lcmdlKGIub3B0cy5odG1sQWxsb3dlZFRhZ3MsW1xcXCJoZWFkXFxcIixcXFwidGl0bGVcXFwiLFxcXCJzdHlsZVxcXCIsXFxcImxpbmtcXFwiLFxcXCJiYXNlXFxcIixcXFwiYm9keVxcXCIsXFxcImh0bWxcXFwiLFxcXCJtZXRhXFxcIl0pfXZhciBFLEYsRyxIPVtdLEg9W107cmV0dXJue19pbml0OkQsaHRtbDpwLHRvSFRNTDU6bCx0YWJsZXM6dCxsaXN0czpDLHF1b3RlczpxLGludmlzaWJsZVNwYWNlczprLGV4ZWM6an19LGEuRkUuWFM9MCxhLkZFLlNNPTEsYS5GRS5NRD0yLGEuRkUuTEc9MyxhLkZFLk1PRFVMRVMuaGVscGVycz1mdW5jdGlvbihiKXtmdW5jdGlvbiBjKCl7dmFyIGEsYixjPS0xO3JldHVyblxcXCJNaWNyb3NvZnQgSW50ZXJuZXQgRXhwbG9yZXJcXFwiPT1uYXZpZ2F0b3IuYXBwTmFtZT8oYT1uYXZpZ2F0b3IudXNlckFnZW50LGI9bmV3IFJlZ0V4cChcXFwiTVNJRSAoWzAtOV17MSx9W1xcXFxcXFxcLjAtOV17MCx9KVxcXCIpLG51bGwhPT1iLmV4ZWMoYSkmJihjPXBhcnNlRmxvYXQoUmVnRXhwLiQxKSkpOlxcXCJOZXRzY2FwZVxcXCI9PW5hdmlnYXRvci5hcHBOYW1lJiYoYT1uYXZpZ2F0b3IudXNlckFnZW50LGI9bmV3IFJlZ0V4cChcXFwiVHJpZGVudC8uKnJ2OihbMC05XXsxLH1bXFxcXFxcXFwuMC05XXswLH0pXFxcIiksbnVsbCE9PWIuZXhlYyhhKSYmKGM9cGFyc2VGbG9hdChSZWdFeHAuJDEpKSksY31mdW5jdGlvbiBkKCl7dmFyIGE9e30sYj1jKCk7aWYoYj4wKWEubXNpZT0hMDtlbHNle3ZhciBkPW5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKSxlPS8oZWRnZSlbIFxcXFwvXShbXFxcXHcuXSspLy5leGVjKGQpfHwvKGNocm9tZSlbIFxcXFwvXShbXFxcXHcuXSspLy5leGVjKGQpfHwvKHdlYmtpdClbIFxcXFwvXShbXFxcXHcuXSspLy5leGVjKGQpfHwvKG9wZXJhKSg/Oi4qdmVyc2lvbnwpWyBcXFxcL10oW1xcXFx3Ll0rKS8uZXhlYyhkKXx8Lyhtc2llKSAoW1xcXFx3Ll0rKS8uZXhlYyhkKXx8ZC5pbmRleE9mKFxcXCJjb21wYXRpYmxlXFxcIik8MCYmLyhtb3ppbGxhKSg/Oi4qPyBydjooW1xcXFx3Ll0rKXwpLy5leGVjKGQpfHxbXSxmPXticm93c2VyOmVbMV18fFxcXCJcXFwiLHZlcnNpb246ZVsyXXx8XFxcIjBcXFwifTtlWzFdJiYoYVtmLmJyb3dzZXJdPSEwKSxhLmNocm9tZT9hLndlYmtpdD0hMDphLndlYmtpdCYmKGEuc2FmYXJpPSEwKX1yZXR1cm4gYS5tc2llJiYoYS52ZXJzaW9uPWIpLGF9ZnVuY3Rpb24gZSgpe3JldHVybi8oaVBhZHxpUGhvbmV8aVBvZCkvZy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpJiYhaCgpfWZ1bmN0aW9uIGYoKXtyZXR1cm4vKEFuZHJvaWQpL2cudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSYmIWgoKX1mdW5jdGlvbiBnKCl7cmV0dXJuLyhCbGFja2JlcnJ5KS9nLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCl9ZnVuY3Rpb24gaCgpe3JldHVybi8oV2luZG93cyBQaG9uZSkvZ2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KX1mdW5jdGlvbiBpKCl7cmV0dXJuIGYoKXx8ZSgpfHxnKCl9ZnVuY3Rpb24gaigpe3JldHVybiB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lfHx3aW5kb3cud2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lfHx3aW5kb3cubW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lfHxmdW5jdGlvbihhKXt3aW5kb3cuc2V0VGltZW91dChhLDFlMy82MCl9fWZ1bmN0aW9uIGsoYSl7cmV0dXJuIHBhcnNlSW50KGEsMTApfHwwfWZ1bmN0aW9uIGwoKXt2YXIgYj1hKCc8ZGl2IGNsYXNzPVxcXCJmci12aXNpYmlsaXR5LWhlbHBlclxcXCI+PC9kaXY+JykuYXBwZW5kVG8oXFxcImJvZHlcXFwiKSxjPWsoYi5jc3MoXFxcIm1hcmdpbi1sZWZ0XFxcIikpO3JldHVybiBiLnJlbW92ZSgpLGN9ZnVuY3Rpb24gbSgpe3JldHVyblxcXCJvbnRvdWNoc3RhcnRcXFwiaW4gd2luZG93fHx3aW5kb3cuRG9jdW1lbnRUb3VjaCYmZG9jdW1lbnQgaW5zdGFuY2VvZiBEb2N1bWVudFRvdWNofWZ1bmN0aW9uIG4oYSl7aWYoIS9eKGh0dHBzPzp8ZnRwcz86fClcXFxcL1xcXFwvL2kudGVzdChhKSlyZXR1cm4hMTthPVN0cmluZyhhKS5yZXBsYWNlKC88L2csXFxcIiUzQ1xcXCIpLnJlcGxhY2UoLz4vZyxcXFwiJTNFXFxcIikucmVwbGFjZSgvXFxcIi9nLFxcXCIlMjJcXFwiKS5yZXBsYWNlKC8gL2csXFxcIiUyMFxcXCIpO3ZhciBiPS8oaHR0cHxmdHB8aHR0cHMpOlxcXFwvXFxcXC9bYS16XFxcXHUwMGExLVxcXFx1ZmZmZjAtOXt9XSsoXFxcXC5bYS16XFxcXHUwMGExLVxcXFx1ZmZmZjAtOXt9XSopKihbYS16XFxcXHUwMGExLVxcXFx1ZmZmZjAtOS4sQD9ePSUmYW1wOzpcXFxcL34rIy1fe31dKlthLXpcXFxcdTAwYTEtXFxcXHVmZmZmMC05QD9ePSUmYW1wO1xcXFwvfisjLV97fV0pPy9naTtyZXR1cm4gYi50ZXN0KGEpfWZ1bmN0aW9uIG8oYSl7aWYoL14oaHR0cHM/OnxmdHBzPzp8KVxcXFwvXFxcXC8vaS50ZXN0KGEpKXtpZighbihhKSYmIW4oXFxcImh0dHA6XFxcIithKSlyZXR1cm5cXFwiXFxcIn1lbHNlIGE9ZW5jb2RlVVJJQ29tcG9uZW50KGEpLnJlcGxhY2UoLyUyMy9nLFxcXCIjXFxcIikucmVwbGFjZSgvJTJGL2csXFxcIi9cXFwiKS5yZXBsYWNlKC8lMjUvZyxcXFwiJVxcXCIpLnJlcGxhY2UoL21haWx0byUzQS9naSxcXFwibWFpbHRvOlxcXCIpLnJlcGxhY2UoL2ZpbGUlM0EvZ2ksXFxcImZpbGU6XFxcIikucmVwbGFjZSgvc21zJTNBL2dpLFxcXCJzbXM6XFxcIikucmVwbGFjZSgvdGVsJTNBL2dpLFxcXCJ0ZWw6XFxcIikucmVwbGFjZSgvbm90ZXMlM0EvZ2ksXFxcIm5vdGVzOlxcXCIpLnJlcGxhY2UoL2RhdGElM0FpbWFnZS9naSxcXFwiZGF0YTppbWFnZVxcXCIpLnJlcGxhY2UoL2Jsb2IlM0EvZ2ksXFxcImJsb2I6XFxcIikucmVwbGFjZSgvd2Via2l0LWZha2UtdXJsJTNBL2dpLFxcXCJ3ZWJraXQtZmFrZS11cmw6XFxcIikucmVwbGFjZSgvJTNGL2csXFxcIj9cXFwiKS5yZXBsYWNlKC8lM0QvZyxcXFwiPVxcXCIpLnJlcGxhY2UoLyUyNi9nLFxcXCImXFxcIikucmVwbGFjZSgvJmFtcDsvZyxcXFwiJlxcXCIpLnJlcGxhY2UoLyUyQy9nLFxcXCIsXFxcIikucmVwbGFjZSgvJTNCL2csXFxcIjtcXFwiKS5yZXBsYWNlKC8lMkIvZyxcXFwiK1xcXCIpLnJlcGxhY2UoLyU0MC9nLFxcXCJAXFxcIikucmVwbGFjZSgvJTVCL2csXFxcIltcXFwiKS5yZXBsYWNlKC8lNUQvZyxcXFwiXVxcXCIpLnJlcGxhY2UoLyU3Qi9nLFxcXCJ7XFxcIikucmVwbGFjZSgvJTdEL2csXFxcIn1cXFwiKTtyZXR1cm4gYX1mdW5jdGlvbiBwKGEpe3JldHVybiBhJiYhYS5wcm9wZXJ0eUlzRW51bWVyYWJsZShcXFwibGVuZ3RoXFxcIikmJlxcXCJvYmplY3RcXFwiPT10eXBlb2YgYSYmXFxcIm51bWJlclxcXCI9PXR5cGVvZiBhLmxlbmd0aH1mdW5jdGlvbiBxKGEpe2Z1bmN0aW9uIGIoYSl7cmV0dXJuKFxcXCIwXFxcIitwYXJzZUludChhLDEwKS50b1N0cmluZygxNikpLnNsaWNlKC0yKX10cnl7cmV0dXJuIGEmJlxcXCJ0cmFuc3BhcmVudFxcXCIhPT1hPy9eI1swLTlBLUZdezZ9JC9pLnRlc3QoYSk/YTooYT1hLm1hdGNoKC9ecmdiXFxcXCgoXFxcXGQrKSxcXFxccyooXFxcXGQrKSxcXFxccyooXFxcXGQrKVxcXFwpJC8pLChcXFwiI1xcXCIrYihhWzFdKStiKGFbMl0pK2IoYVszXSkpLnRvVXBwZXJDYXNlKCkpOlxcXCJcXFwifWNhdGNoKGMpe3JldHVybiBudWxsfX1mdW5jdGlvbiByKGEpe3ZhciBiPS9eIz8oW2EtZlxcXFxkXSkoW2EtZlxcXFxkXSkoW2EtZlxcXFxkXSkkL2k7YT1hLnJlcGxhY2UoYixmdW5jdGlvbihhLGIsYyxkKXtyZXR1cm4gYitiK2MrYytkK2R9KTt2YXIgYz0vXiM/KFthLWZcXFxcZF17Mn0pKFthLWZcXFxcZF17Mn0pKFthLWZcXFxcZF17Mn0pJC9pLmV4ZWMoYSk7cmV0dXJuIGM/XFxcInJnYihcXFwiK3BhcnNlSW50KGNbMV0sMTYpK1xcXCIsIFxcXCIrcGFyc2VJbnQoY1syXSwxNikrXFxcIiwgXFxcIitwYXJzZUludChjWzNdLDE2KStcXFwiKVxcXCI6XFxcIlxcXCJ9ZnVuY3Rpb24gcyhiKXt2YXIgYz0oYi5jc3MoXFxcInRleHQtYWxpZ25cXFwiKXx8XFxcIlxcXCIpLnJlcGxhY2UoLy0oLiopLS9nLFxcXCJcXFwiKTtpZihbXFxcImxlZnRcXFwiLFxcXCJyaWdodFxcXCIsXFxcImp1c3RpZnlcXFwiLFxcXCJjZW50ZXJcXFwiXS5pbmRleE9mKGMpPDApe2lmKCF2KXt2YXIgZD1hKCc8ZGl2IGRpcj1cXFwiYXV0b1xcXCIgc3R5bGU9XFxcInRleHQtYWxpZ246IGluaXRpYWw7IHBvc2l0aW9uOiBmaXhlZDsgbGVmdDogLTMwMDBweDtcXFwiPjxzcGFuIGlkPVxcXCJzMVxcXCI+Ljwvc3Bhbj48c3BhbiBpZD1cXFwiczJcXFwiPi48L3NwYW4+PC9kaXY+Jyk7YShcXFwiYm9keVxcXCIpLmFwcGVuZChkKTt2YXIgZT1kLmZpbmQoXFxcIiNzMVxcXCIpLmdldCgwKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0LGY9ZC5maW5kKFxcXCIjczJcXFwiKS5nZXQoMCkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdDtkLnJlbW92ZSgpLHY9Zj5lP1xcXCJsZWZ0XFxcIjpcXFwicmlnaHRcXFwifWM9dn1yZXR1cm4gY31mdW5jdGlvbiB0KCl7cmV0dXJuIG51bGw9PXcmJih3PW5hdmlnYXRvci5wbGF0Zm9ybS50b1VwcGVyQ2FzZSgpLmluZGV4T2YoXFxcIk1BQ1xcXCIpPj0wKSx3fWZ1bmN0aW9uIHUoKXtiLmJyb3dzZXI9ZCgpfXZhciB2LHc9bnVsbDtyZXR1cm57X2luaXQ6dSxpc0lPUzplLGlzTWFjOnQsaXNBbmRyb2lkOmYsaXNCbGFja2JlcnJ5OmcsaXNXaW5kb3dzUGhvbmU6aCxpc01vYmlsZTppLHJlcXVlc3RBbmltYXRpb25GcmFtZTpqLGdldFBYOmssc2NyZWVuU2l6ZTpsLGlzVG91Y2g6bSxzYW5pdGl6ZVVSTDpvLGlzQXJyYXk6cCxSR0JUb0hleDpxLEhFWHRvUkdCOnIsaXNVUkw6bixnZXRBbGlnbm1lbnQ6c319LGEuRkUuTU9EVUxFUy5ldmVudHM9ZnVuY3Rpb24oYil7ZnVuY3Rpb24gYyhhLGIsYyl7cyhhLGIsYyl9ZnVuY3Rpb24gZCgpe2MoYi4kZWwsXFxcImN1dCBjb3B5IHBhc3RlIGJlZm9yZXBhc3RlXFxcIixmdW5jdGlvbihhKXt2KGEudHlwZSxbYV0pfSl9ZnVuY3Rpb24gZSgpe2MoYi4kZWwsXFxcImNsaWNrIG1vdXNldXAgbW91c2Vkb3duIHRvdWNoc3RhcnQgdG91Y2hlbmQgZHJhZ2VudGVyIGRyYWdvdmVyIGRyYWdsZWF2ZSBkcmFnZW5kIGRyb3AgZHJhZ3N0YXJ0XFxcIixmdW5jdGlvbihhKXt2KGEudHlwZSxbYV0pfSkscihcXFwibW91c2Vkb3duXFxcIixmdW5jdGlvbigpe2Zvcih2YXIgYz0wO2M8YS5GRS5JTlNUQU5DRVMubGVuZ3RoO2MrKylhLkZFLklOU1RBTkNFU1tjXSE9YiYmYS5GRS5JTlNUQU5DRVNbY10ucG9wdXBzJiZhLkZFLklOU1RBTkNFU1tjXS5wb3B1cHMuYXJlVmlzaWJsZSgpJiZhLkZFLklOU1RBTkNFU1tjXS4kZWwuZmluZChcXFwiLmZyLW1hcmtlclxcXCIpLnJlbW92ZSgpfSl9ZnVuY3Rpb24gZigpe2MoYi4kZWwsXFxcImtleWRvd24ga2V5cHJlc3Mga2V5dXAgaW5wdXRcXFwiLGZ1bmN0aW9uKGEpe3YoYS50eXBlLFthXSl9KX1mdW5jdGlvbiBnKCl7YyhiLiR3aW4sYi5fbW91c2Vkb3duLGZ1bmN0aW9uKGEpe3YoXFxcIndpbmRvdy5tb3VzZWRvd25cXFwiLFthXSksbigpfSksYyhiLiR3aW4sYi5fbW91c2V1cCxmdW5jdGlvbihhKXt2KFxcXCJ3aW5kb3cubW91c2V1cFxcXCIsW2FdKX0pLGMoYi4kd2luLFxcXCJjdXQgY29weSBrZXlkb3duIGtleXVwIHRvdWNobW92ZSB0b3VjaGVuZFxcXCIsZnVuY3Rpb24oYSl7dihcXFwid2luZG93LlxcXCIrYS50eXBlLFthXSl9KX1mdW5jdGlvbiBoKCl7YyhiLiRkb2MsXFxcImRyYWdlbmQgZHJvcFxcXCIsZnVuY3Rpb24oYSl7dihcXFwiZG9jdW1lbnQuXFxcIithLnR5cGUsW2FdKX0pfWZ1bmN0aW9uIGkoYyl7aWYoXFxcInVuZGVmaW5lZFxcXCI9PXR5cGVvZiBjJiYoYz0hMCksIWIuJHdwKXJldHVybiExO2lmKGIuaGVscGVycy5pc0lPUygpJiZiLiR3aW4uZ2V0KDApLmZvY3VzKCksIWIuY29yZS5oYXNGb2N1cygpJiZjKXt2YXIgZD1iLiR3aW4uc2Nyb2xsVG9wKCk7cmV0dXJuIGIuJGVsLmZvY3VzKCksZCE9Yi4kd2luLnNjcm9sbFRvcCgpJiZiLiR3aW4uc2Nyb2xsVG9wKGQpLCExfWlmKCFiLmNvcmUuaGFzRm9jdXMoKXx8Yi4kZWwuZmluZChcXFwiLmZyLW1hcmtlclxcXCIpLmxlbmd0aD4wKXJldHVybiExO3ZhciBlPWIuc2VsZWN0aW9uLmluZm8oYi4kZWwuZ2V0KDApKTtpZihlLmF0U3RhcnQmJmIuc2VsZWN0aW9uLmlzQ29sbGFwc2VkKCkmJm51bGwhPWIuaHRtbC5kZWZhdWx0VGFnKCkpe3ZhciBmPWIubWFya2Vycy5pbnNlcnQoKTtpZihmJiYhYi5ub2RlLmJsb2NrUGFyZW50KGYpKXthKGYpLnJlbW92ZSgpO3ZhciBnPWIuJGVsLmZpbmQoYi5odG1sLmJsb2NrVGFnc1F1ZXJ5KCkpLmdldCgwKTtnJiYoYShnKS5wcmVwZW5kKGEuRkUuTUFSS0VSUyksYi5zZWxlY3Rpb24ucmVzdG9yZSgpKX1lbHNlIGYmJmEoZikucmVtb3ZlKCl9fWZ1bmN0aW9uIGooKXtjKGIuJGVsLFxcXCJmb2N1c1xcXCIsZnVuY3Rpb24oYSl7cCgpJiYoaSghMSksQz09PSExJiZ2KGEudHlwZSxbYV0pKX0pLGMoYi4kZWwsXFxcImJsdXJcXFwiLGZ1bmN0aW9uKGEpe3AoKSYmQz09PSEwJiYodihhLnR5cGUsW2FdKSxuKCkpfSkscihcXFwiZm9jdXNcXFwiLGZ1bmN0aW9uKCl7Qz0hMH0pLHIoXFxcImJsdXJcXFwiLGZ1bmN0aW9uKCl7Qz0hMX0pfWZ1bmN0aW9uIGsoKXtiLmhlbHBlcnMuaXNNb2JpbGUoKT8oYi5fbW91c2Vkb3duPVxcXCJ0b3VjaHN0YXJ0XFxcIixiLl9tb3VzZXVwPVxcXCJ0b3VjaGVuZFxcXCIsYi5fbW92ZT1cXFwidG91Y2htb3ZlXFxcIixiLl9tb3VzZW1vdmU9XFxcInRvdWNobW92ZVxcXCIpOihiLl9tb3VzZWRvd249XFxcIm1vdXNlZG93blxcXCIsYi5fbW91c2V1cD1cXFwibW91c2V1cFxcXCIsYi5fbW92ZT1cXFwiXFxcIixiLl9tb3VzZW1vdmU9XFxcIm1vdXNlbW92ZVxcXCIpfWZ1bmN0aW9uIGwoYyl7dmFyIGQ9YShjLmN1cnJlbnRUYXJnZXQpO3JldHVybiBiLmVkaXQuaXNEaXNhYmxlZCgpfHxkLmhhc0NsYXNzKFxcXCJmci1kaXNhYmxlZFxcXCIpPyhjLnByZXZlbnREZWZhdWx0KCksITEpOlxcXCJtb3VzZWRvd25cXFwiPT09Yy50eXBlJiYxIT09Yy53aGljaD8hMDooYi5oZWxwZXJzLmlzTW9iaWxlKCl8fGMucHJldmVudERlZmF1bHQoKSwoYi5oZWxwZXJzLmlzQW5kcm9pZCgpfHxiLmhlbHBlcnMuaXNXaW5kb3dzUGhvbmUoKSkmJjA9PT1kLnBhcmVudHMoXFxcIi5mci1kcm9wZG93bi1tZW51XFxcIikubGVuZ3RoJiYoYy5wcmV2ZW50RGVmYXVsdCgpLGMuc3RvcFByb3BhZ2F0aW9uKCkpLGQuYWRkQ2xhc3MoXFxcImZyLXNlbGVjdGVkXFxcIiksdm9pZCBiLmV2ZW50cy50cmlnZ2VyKFxcXCJjb21tYW5kcy5tb3VzZWRvd25cXFwiLFtkXSkpfWZ1bmN0aW9uIG0oYyxkKXt2YXIgZT1hKGMuY3VycmVudFRhcmdldCk7aWYoYi5lZGl0LmlzRGlzYWJsZWQoKXx8ZS5oYXNDbGFzcyhcXFwiZnItZGlzYWJsZWRcXFwiKSlyZXR1cm4gYy5wcmV2ZW50RGVmYXVsdCgpLCExO2lmKFxcXCJtb3VzZXVwXFxcIj09PWMudHlwZSYmMSE9PWMud2hpY2gpcmV0dXJuITA7aWYoIWUuaGFzQ2xhc3MoXFxcImZyLXNlbGVjdGVkXFxcIikpcmV0dXJuITA7aWYoXFxcInRvdWNobW92ZVxcXCIhPWMudHlwZSl7aWYoYy5zdG9wUHJvcGFnYXRpb24oKSxjLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpLGMucHJldmVudERlZmF1bHQoKSwhZS5oYXNDbGFzcyhcXFwiZnItc2VsZWN0ZWRcXFwiKSlyZXR1cm4gYShcXFwiLmZyLXNlbGVjdGVkXFxcIikucmVtb3ZlQ2xhc3MoXFxcImZyLXNlbGVjdGVkXFxcIiksITE7aWYoYShcXFwiLmZyLXNlbGVjdGVkXFxcIikucmVtb3ZlQ2xhc3MoXFxcImZyLXNlbGVjdGVkXFxcIiksZS5kYXRhKFxcXCJkcmFnZ2luZ1xcXCIpfHxlLmF0dHIoXFxcImRpc2FibGVkXFxcIikpcmV0dXJuIGUucmVtb3ZlRGF0YShcXFwiZHJhZ2dpbmdcXFwiKSwhMTt2YXIgZj1lLmRhdGEoXFxcInRpbWVvdXRcXFwiKTtmJiYoY2xlYXJUaW1lb3V0KGYpLGUucmVtb3ZlRGF0YShcXFwidGltZW91dFxcXCIpKSxkLmFwcGx5KGIsW2NdKX1lbHNlIGUuZGF0YShcXFwidGltZW91dFxcXCIpfHxlLmRhdGEoXFxcInRpbWVvdXRcXFwiLHNldFRpbWVvdXQoZnVuY3Rpb24oKXtlLmRhdGEoXFxcImRyYWdnaW5nXFxcIiwhMCl9LDEwMCkpfWZ1bmN0aW9uIG4oKXtBPSEwfWZ1bmN0aW9uIG8oKXtBPSExfWZ1bmN0aW9uIHAoKXtyZXR1cm4gQX1mdW5jdGlvbiBxKGEsYyxkKXtzKGEsYi5fbW91c2Vkb3duLGMsZnVuY3Rpb24oYSl7Yi5lZGl0LmlzRGlzYWJsZWQoKXx8bChhKX0sITApLHMoYSxiLl9tb3VzZXVwK1xcXCIgXFxcIitiLl9tb3ZlLGMsZnVuY3Rpb24oYSl7Yi5lZGl0LmlzRGlzYWJsZWQoKXx8bShhLGQpfSwhMCkscyhhLFxcXCJtb3VzZWRvd24gY2xpY2sgbW91c2V1cFxcXCIsYyxmdW5jdGlvbihhKXtiLmVkaXQuaXNEaXNhYmxlZCgpfHxhLnN0b3BQcm9wYWdhdGlvbigpfSwhMCkscihcXFwid2luZG93Lm1vdXNldXBcXFwiLGZ1bmN0aW9uKCl7Yi5lZGl0LmlzRGlzYWJsZWQoKXx8KGEuZmluZChjKS5yZW1vdmVDbGFzcyhcXFwiZnItc2VsZWN0ZWRcXFwiKSxuKCkpfSl9ZnVuY3Rpb24gcihhLGMsZCl7dmFyIGU9YS5zcGxpdChcXFwiIFxcXCIpO2lmKGUubGVuZ3RoPjEpe2Zvcih2YXIgZj0wO2Y8ZS5sZW5ndGg7ZisrKXIoZVtmXSxjLGQpO3JldHVybiEwfVxcXCJ1bmRlZmluZWRcXFwiPT10eXBlb2YgZCYmKGQ9ITEpO3ZhciBnO2c9MCE9YS5pbmRleE9mKFxcXCJzaGFyZWQuXFxcIik/QlthXT1CW2FdfHxbXTpiLnNoYXJlZC5fZXZlbnRzW2FdPWIuc2hhcmVkLl9ldmVudHNbYV18fFtdLGQ/Zy51bnNoaWZ0KGMpOmcucHVzaChjKX1mdW5jdGlvbiBzKGEsYyxkLGUsZil7XFxcImZ1bmN0aW9uXFxcIj09dHlwZW9mIGQmJihmPWUsZT1kLGQ9ITEpO3ZhciBnPWY/Yi5zaGFyZWQuJF9ldmVudHM6RCxoPWY/Yi5zaWQ6Yi5pZDtkP2Eub24oYy5zcGxpdChcXFwiIFxcXCIpLmpvaW4oXFxcIi5lZFxcXCIraCtcXFwiIFxcXCIpK1xcXCIuZWRcXFwiK2gsZCxlKTphLm9uKGMuc3BsaXQoXFxcIiBcXFwiKS5qb2luKFxcXCIuZWRcXFwiK2grXFxcIiBcXFwiKStcXFwiLmVkXFxcIitoLGUpLGcuaW5kZXhPZihhLmdldCgwKSk8MCYmZy5wdXNoKGEuZ2V0KDApKX1mdW5jdGlvbiB0KGIsYyl7Zm9yKHZhciBkPTA7ZDxiLmxlbmd0aDtkKyspYShiW2RdKS5vZmYoXFxcIi5lZFxcXCIrYyl9ZnVuY3Rpb24gdSgpe3QoRCxiLmlkKSxEPVtdLDA9PWIuc2hhcmVkLmNvdW50JiYodChiLnNoYXJlZC4kX2V2ZW50cyxiLnNpZCksYi5zaGFyZWQuJF9ldmVudHM9bnVsbCl9ZnVuY3Rpb24gdihjLGQsZSl7aWYoIWIuZWRpdC5pc0Rpc2FibGVkKCl8fGUpe3ZhciBmO2lmKDAhPWMuaW5kZXhPZihcXFwic2hhcmVkLlxcXCIpKWY9QltjXTtlbHNle2lmKGIuc2hhcmVkLmNvdW50PjApcmV0dXJuITE7Zj1iLnNoYXJlZC5fZXZlbnRzW2NdfXZhciBnO2lmKGYpZm9yKHZhciBoPTA7aDxmLmxlbmd0aDtoKyspaWYoZz1mW2hdLmFwcGx5KGIsZCksZz09PSExKXJldHVybiExO3JldHVybiBnPWIuJG9lbC50cmlnZ2VySGFuZGxlcihcXFwiZnJvYWxhRWRpdG9yLlxcXCIrYyxhLm1lcmdlKFtiXSxkfHxbXSkpLGc9PT0hMT8hMTpnfX1mdW5jdGlvbiB3KGMsZCxlKXtpZighYi5lZGl0LmlzRGlzYWJsZWQoKXx8ZSl7dmFyIGY7aWYoMCE9Yy5pbmRleE9mKFxcXCJzaGFyZWQuXFxcIikpZj1CW2NdO2Vsc2V7aWYoYi5zaGFyZWQuY291bnQ+MClyZXR1cm4hMTtmPWIuc2hhcmVkLl9ldmVudHNbY119dmFyIGc7aWYoZilmb3IodmFyIGg9MDtoPGYubGVuZ3RoO2grKylnPWZbaF0uYXBwbHkoYixbZF0pLFxcXCJ1bmRlZmluZWRcXFwiIT10eXBlb2YgZyYmKGQ9Zyk7cmV0dXJuIGc9Yi4kb2VsLnRyaWdnZXJIYW5kbGVyKFxcXCJmcm9hbGFFZGl0b3IuXFxcIitjLGEubWVyZ2UoW2JdLFtkXSkpLFxcXCJ1bmRlZmluZWRcXFwiIT10eXBlb2YgZyYmKGQ9ZyksZH19ZnVuY3Rpb24geCgpe2Zvcih2YXIgYSBpbiBCKUIuaGFzT3duUHJvcGVydHkoYSkmJmRlbGV0ZSBCW2FdfWZ1bmN0aW9uIHkoKXtmb3IodmFyIGEgaW4gYi5zaGFyZWQuX2V2ZW50cyliLnNoYXJlZC5fZXZlbnRzLmhhc093blByb3BlcnR5KGEpJiZkZWxldGUgYi5zaGFyZWQuX2V2ZW50c1thXX1mdW5jdGlvbiB6KCl7Yi5zaGFyZWQuJF9ldmVudHM9Yi5zaGFyZWQuJF9ldmVudHN8fFtdLGIuc2hhcmVkLl9ldmVudHM9e30saygpLGUoKSxnKCksaCgpLGYoKSxqKCksbigpLGQoKSxyKFxcXCJkZXN0cm95XFxcIix4KSxyKFxcXCJzaGFyZWQuZGVzdHJveVxcXCIseSl9dmFyIEEsQj17fSxDPSExLEQ9W107cmV0dXJue19pbml0Onosb246cix0cmlnZ2VyOnYsYmluZENsaWNrOnEsZGlzYWJsZUJsdXI6byxlbmFibGVCbHVyOm4sYmx1ckFjdGl2ZTpwLGZvY3VzOmksY2hhaW5UcmlnZ2VyOncsJG9uOnMsJG9mZjp1fX0sYS5GRS5JTlZJU0lCTEVfU1BBQ0U9XFxcIiYjODIwMztcXFwiLGEuRkUuU1RBUlRfTUFSS0VSPSc8c3BhbiBjbGFzcz1cXFwiZnItbWFya2VyXFxcIiBkYXRhLWlkPVxcXCIwXFxcIiBkYXRhLXR5cGU9XFxcInRydWVcXFwiIHN0eWxlPVxcXCJkaXNwbGF5OiBub25lOyBsaW5lLWhlaWdodDogMDtcXFwiPicrYS5GRS5JTlZJU0lCTEVfU1BBQ0UrXFxcIjwvc3Bhbj5cXFwiLGEuRkUuRU5EX01BUktFUj0nPHNwYW4gY2xhc3M9XFxcImZyLW1hcmtlclxcXCIgZGF0YS1pZD1cXFwiMFxcXCIgZGF0YS10eXBlPVxcXCJmYWxzZVxcXCIgc3R5bGU9XFxcImRpc3BsYXk6IG5vbmU7IGxpbmUtaGVpZ2h0OiAwO1xcXCI+JythLkZFLklOVklTSUJMRV9TUEFDRStcXFwiPC9zcGFuPlxcXCIsYS5GRS5NQVJLRVJTPWEuRkUuU1RBUlRfTUFSS0VSK2EuRkUuRU5EX01BUktFUixhLkZFLk1PRFVMRVMubWFya2Vycz1mdW5jdGlvbihiKXtmdW5jdGlvbiBjKGMsZCl7cmV0dXJuIGEoJzxzcGFuIGNsYXNzPVxcXCJmci1tYXJrZXJcXFwiIGRhdGEtaWQ9XFxcIicrZCsnXFxcIiBkYXRhLXR5cGU9XFxcIicrYysnXFxcIiBzdHlsZT1cXFwiZGlzcGxheTogJysoYi5icm93c2VyLnNhZmFyaT9cXFwibm9uZVxcXCI6XFxcImlubGluZS1ibG9ja1xcXCIpKyc7IGxpbmUtaGVpZ2h0OiAwO1xcXCI+JythLkZFLklOVklTSUJMRV9TUEFDRStcXFwiPC9zcGFuPlxcXCIsYi5kb2MpWzBdfWZ1bmN0aW9uIGQoZCxlLGYpe3RyeXt2YXIgZz1kLmNsb25lUmFuZ2UoKTtpZihnLmNvbGxhcHNlKGUpLGcuaW5zZXJ0Tm9kZShjKGUsZikpLGU9PT0hMCYmZC5jb2xsYXBzZWQpZm9yKHZhciBoPWIuJGVsLmZpbmQoJ3NwYW4uZnItbWFya2VyW2RhdGEtdHlwZT1cXFwidHJ1ZVxcXCJdW2RhdGEtaWQ9XFxcIicrZisnXFxcIl0nKSxpPWguZ2V0KDApLm5leHRTaWJsaW5nO2kmJmkubm9kZVR5cGU9PT1Ob2RlLlRFWFRfTk9ERSYmMD09PWkudGV4dENvbnRlbnQubGVuZ3RoOylhKGkpLnJlbW92ZSgpLGk9aC5uZXh0U2libGluZztpZihlPT09ITAmJiFkLmNvbGxhcHNlZCl7dmFyIGg9Yi4kZWwuZmluZCgnc3Bhbi5mci1tYXJrZXJbZGF0YS10eXBlPVxcXCJ0cnVlXFxcIl1bZGF0YS1pZD1cXFwiJytmKydcXFwiXScpLmdldCgwKSxpPWgubmV4dFNpYmxpbmc7aWYoaSYmaS5ub2RlVHlwZT09PU5vZGUuRUxFTUVOVF9OT0RFJiZiLm5vZGUuaXNCbG9jayhpKSl7dmFyIGo9W2ldO2RvIGk9alswXSxqPWIubm9kZS5jb250ZW50cyhpKTt3aGlsZShqWzBdJiZiLm5vZGUuaXNCbG9jayhqWzBdKSk7YShpKS5wcmVwZW5kKGEoaCkpfX1pZihlPT09ITEmJiFkLmNvbGxhcHNlZCl7dmFyIGg9Yi4kZWwuZmluZCgnc3Bhbi5mci1tYXJrZXJbZGF0YS10eXBlPVxcXCJmYWxzZVxcXCJdW2RhdGEtaWQ9XFxcIicrZisnXFxcIl0nKS5nZXQoMCksaT1oLnByZXZpb3VzU2libGluZztpZihpJiZpLm5vZGVUeXBlPT09Tm9kZS5FTEVNRU5UX05PREUmJmIubm9kZS5pc0Jsb2NrKGkpKXt2YXIgaj1baV07ZG8gaT1qW2oubGVuZ3RoLTFdLGo9Yi5ub2RlLmNvbnRlbnRzKGkpO3doaWxlKGpbai5sZW5ndGgtMV0mJmIubm9kZS5pc0Jsb2NrKGpbai5sZW5ndGgtMV0pKTthKGkpLmFwcGVuZChhKGgpKX1oLnBhcmVudE5vZGUmJltcXFwiVERcXFwiLFxcXCJUSFxcXCJdLmluZGV4T2YoaC5wYXJlbnROb2RlLnRhZ05hbWUpPj0wJiZoLnBhcmVudE5vZGUucHJldmlvdXNTaWJsaW5nJiYhaC5wcmV2aW91c1NpYmxpbmcmJmEoaC5wYXJlbnROb2RlLnByZXZpb3VzU2libGluZykuYXBwZW5kKGgpfXZhciBrPWIuJGVsLmZpbmQoJ3NwYW4uZnItbWFya2VyW2RhdGEtdHlwZT1cXFwiJytlKydcXFwiXVtkYXRhLWlkPVxcXCInK2YrJ1xcXCJdJykuZ2V0KDApO3JldHVybiBrJiYoay5zdHlsZS5kaXNwbGF5PVxcXCJub25lXFxcIiksa31jYXRjaChsKXtyZXR1cm4gbnVsbH19ZnVuY3Rpb24gZSgpe2lmKCFiLiR3cClyZXR1cm4gbnVsbDt0cnl7dmFyIGM9Yi5zZWxlY3Rpb24ucmFuZ2VzKDApLGQ9Yy5jb21tb25BbmNlc3RvckNvbnRhaW5lcjtpZihkIT1iLiRlbC5nZXQoMCkmJjA9PWIuJGVsLmZpbmQoZCkubGVuZ3RoKXJldHVybiBudWxsO3ZhciBlPWMuY2xvbmVSYW5nZSgpLGY9Yy5jbG9uZVJhbmdlKCk7ZS5jb2xsYXBzZSghMCk7dmFyIGc9YSgnPHNwYW4gY2xhc3M9XFxcImZyLW1hcmtlclxcXCIgc3R5bGU9XFxcImRpc3BsYXk6IG5vbmU7IGxpbmUtaGVpZ2h0OiAwO1xcXCI+JythLkZFLklOVklTSUJMRV9TUEFDRStcXFwiPC9zcGFuPlxcXCIsYi5kb2MpWzBdO2lmKGUuaW5zZXJ0Tm9kZShnKSxnPWIuJGVsLmZpbmQoXFxcInNwYW4uZnItbWFya2VyXFxcIikuZ2V0KDApKXtmb3IodmFyIGg9Zy5uZXh0U2libGluZztoJiZoLm5vZGVUeXBlPT09Tm9kZS5URVhUX05PREUmJjA9PT1oLnRleHRDb250ZW50Lmxlbmd0aDspYShoKS5yZW1vdmUoKSxoPWIuJGVsLmZpbmQoXFxcInNwYW4uZnItbWFya2VyXFxcIikuZ2V0KDApLm5leHRTaWJsaW5nO3JldHVybiBiLnNlbGVjdGlvbi5jbGVhcigpLGIuc2VsZWN0aW9uLmdldCgpLmFkZFJhbmdlKGYpLGd9cmV0dXJuIG51bGx9Y2F0Y2goaSl7fX1mdW5jdGlvbiBmKCl7Yi5zZWxlY3Rpb24uaXNDb2xsYXBzZWQoKXx8Yi5zZWxlY3Rpb24ucmVtb3ZlKCk7dmFyIGM9Yi4kZWwuZmluZChcXFwiLmZyLW1hcmtlclxcXCIpLmdldCgwKTtpZihudWxsPT1jJiYoYz1lKCkpLG51bGw9PWMpcmV0dXJuIG51bGw7dmFyIGQ7aWYoZD1iLm5vZGUuZGVlcGVzdFBhcmVudChjKSlpZihiLm5vZGUuaXNCbG9jayhkKSYmYi5ub2RlLmlzRW1wdHkoZCkpYShkKS5yZXBsYWNlV2l0aCgnPHNwYW4gY2xhc3M9XFxcImZyLW1hcmtlclxcXCI+PC9zcGFuPicpO2Vsc2V7dmFyIGY9YyxnPVxcXCJcXFwiLGg9XFxcIlxcXCI7ZG8gZj1mLnBhcmVudE5vZGUsZys9Yi5ub2RlLmNsb3NlVGFnU3RyaW5nKGYpLGg9Yi5ub2RlLm9wZW5UYWdTdHJpbmcoZikraDt3aGlsZShmIT1kKTthKGMpLnJlcGxhY2VXaXRoKCc8c3BhbiBpZD1cXFwiZnItYnJlYWtcXFwiPjwvc3Bhbj4nKTt2YXIgaT1iLm5vZGUub3BlblRhZ1N0cmluZyhkKSthKGQpLmh0bWwoKStiLm5vZGUuY2xvc2VUYWdTdHJpbmcoZCk7aT1pLnJlcGxhY2UoLzxzcGFuIGlkPVxcXCJmci1icmVha1xcXCI+PFxcXFwvc3Bhbj4vZyxnKyc8c3BhbiBjbGFzcz1cXFwiZnItbWFya2VyXFxcIj48L3NwYW4+JytoKSxhKGQpLnJlcGxhY2VXaXRoKGkpfXJldHVybiBiLiRlbC5maW5kKFxcXCIuZnItbWFya2VyXFxcIikuZ2V0KDApfWZ1bmN0aW9uIGcoYSl7dmFyIGM9YS5jbGllbnRYLGQ9YS5jbGllbnRZO2goKTt2YXIgZixnPW51bGw7aWYoXFxcInVuZGVmaW5lZFxcXCIhPXR5cGVvZiBiLmRvYy5jYXJldFBvc2l0aW9uRnJvbVBvaW50PyhmPWIuZG9jLmNhcmV0UG9zaXRpb25Gcm9tUG9pbnQoYyxkKSxcXG5nPWIuZG9jLmNyZWF0ZVJhbmdlKCksZy5zZXRTdGFydChmLm9mZnNldE5vZGUsZi5vZmZzZXQpLGcuc2V0RW5kKGYub2Zmc2V0Tm9kZSxmLm9mZnNldCkpOlxcXCJ1bmRlZmluZWRcXFwiIT10eXBlb2YgYi5kb2MuY2FyZXRSYW5nZUZyb21Qb2ludCYmKGY9Yi5kb2MuY2FyZXRSYW5nZUZyb21Qb2ludChjLGQpLGc9Yi5kb2MuY3JlYXRlUmFuZ2UoKSxnLnNldFN0YXJ0KGYuc3RhcnRDb250YWluZXIsZi5zdGFydE9mZnNldCksZy5zZXRFbmQoZi5zdGFydENvbnRhaW5lcixmLnN0YXJ0T2Zmc2V0KSksbnVsbCE9PWcmJlxcXCJ1bmRlZmluZWRcXFwiIT10eXBlb2YgYi53aW4uZ2V0U2VsZWN0aW9uKXt2YXIgaT1iLndpbi5nZXRTZWxlY3Rpb24oKTtpLnJlbW92ZUFsbFJhbmdlcygpLGkuYWRkUmFuZ2UoZyl9ZWxzZSBpZihcXFwidW5kZWZpbmVkXFxcIiE9dHlwZW9mIGIuZG9jLmJvZHkuY3JlYXRlVGV4dFJhbmdlKXRyeXtnPWIuZG9jLmJvZHkuY3JlYXRlVGV4dFJhbmdlKCksZy5tb3ZlVG9Qb2ludChjLGQpO3ZhciBqPWcuZHVwbGljYXRlKCk7ai5tb3ZlVG9Qb2ludChjLGQpLGcuc2V0RW5kUG9pbnQoXFxcIkVuZFRvRW5kXFxcIixqKSxnLnNlbGVjdCgpfWNhdGNoKGspe3JldHVybiExfWUoKX1mdW5jdGlvbiBoKCl7Yi4kZWwuZmluZChcXFwiLmZyLW1hcmtlclxcXCIpLnJlbW92ZSgpfXJldHVybntwbGFjZTpkLGluc2VydDplLHNwbGl0OmYsaW5zZXJ0QXRQb2ludDpnLHJlbW92ZTpofX0sYS5GRS5NT0RVTEVTLnNlbGVjdGlvbj1mdW5jdGlvbihiKXtmdW5jdGlvbiBjKCl7dmFyIGE9XFxcIlxcXCI7cmV0dXJuIGIud2luLmdldFNlbGVjdGlvbj9hPWIud2luLmdldFNlbGVjdGlvbigpOmIuZG9jLmdldFNlbGVjdGlvbj9hPWIuZG9jLmdldFNlbGVjdGlvbigpOmIuZG9jLnNlbGVjdGlvbiYmKGE9Yi5kb2Muc2VsZWN0aW9uLmNyZWF0ZVJhbmdlKCkudGV4dCksYS50b1N0cmluZygpfWZ1bmN0aW9uIGQoKXt2YXIgYT1cXFwiXFxcIjtyZXR1cm4gYT1iLndpbi5nZXRTZWxlY3Rpb24/Yi53aW4uZ2V0U2VsZWN0aW9uKCk6Yi5kb2MuZ2V0U2VsZWN0aW9uP2IuZG9jLmdldFNlbGVjdGlvbigpOmIuZG9jLnNlbGVjdGlvbi5jcmVhdGVSYW5nZSgpfWZ1bmN0aW9uIGUoYSl7dmFyIGM9ZCgpLGU9W107aWYoYyYmYy5nZXRSYW5nZUF0JiZjLnJhbmdlQ291bnQpZm9yKHZhciBlPVtdLGY9MDtmPGMucmFuZ2VDb3VudDtmKyspZS5wdXNoKGMuZ2V0UmFuZ2VBdChmKSk7ZWxzZSBlPWIuZG9jLmNyZWF0ZVJhbmdlP1tiLmRvYy5jcmVhdGVSYW5nZSgpXTpbXTtyZXR1cm5cXFwidW5kZWZpbmVkXFxcIiE9dHlwZW9mIGE/ZVthXTplfWZ1bmN0aW9uIGYoKXt2YXIgYT1kKCk7dHJ5e2EucmVtb3ZlQWxsUmFuZ2VzP2EucmVtb3ZlQWxsUmFuZ2VzKCk6YS5lbXB0eT9hLmVtcHR5KCk6YS5jbGVhciYmYS5jbGVhcigpfWNhdGNoKGIpe319ZnVuY3Rpb24gZygpe3ZhciBmPWQoKTt0cnl7aWYoZi5yYW5nZUNvdW50KXt2YXIgZz1lKDApLGg9Zy5zdGFydENvbnRhaW5lcjtpZihoLm5vZGVUeXBlPT1Ob2RlLlRFWFRfTk9ERSYmZy5zdGFydE9mZnNldD09KGgudGV4dENvbnRlbnR8fFxcXCJcXFwiKS5sZW5ndGgmJmgubmV4dFNpYmxpbmcmJihoPWgubmV4dFNpYmxpbmcpLGgubm9kZVR5cGU9PU5vZGUuRUxFTUVOVF9OT0RFKXt2YXIgaT0hMTtpZihoLmNoaWxkTm9kZXMubGVuZ3RoPjAmJmguY2hpbGROb2Rlc1tnLnN0YXJ0T2Zmc2V0XSl7Zm9yKHZhciBqPWguY2hpbGROb2Rlc1tnLnN0YXJ0T2Zmc2V0XTtqJiZqLm5vZGVUeXBlPT1Ob2RlLlRFWFRfTk9ERSYmMD09ai50ZXh0Q29udGVudC5sZW5ndGg7KWo9ai5uZXh0U2libGluZztpZihqJiZqLnRleHRDb250ZW50LnJlcGxhY2UoL1xcXFx1MjAwQi9nLFxcXCJcXFwiKT09PWMoKS5yZXBsYWNlKC9cXFxcdTIwMEIvZyxcXFwiXFxcIikmJihoPWosaT0hMCksIWkmJmguY2hpbGROb2Rlcy5sZW5ndGg+MSYmZy5zdGFydE9mZnNldD4wJiZoLmNoaWxkTm9kZXNbZy5zdGFydE9mZnNldC0xXSl7Zm9yKHZhciBqPWguY2hpbGROb2Rlc1tnLnN0YXJ0T2Zmc2V0LTFdO2omJmoubm9kZVR5cGU9PU5vZGUuVEVYVF9OT0RFJiYwPT1qLnRleHRDb250ZW50Lmxlbmd0aDspaj1qLm5leHRTaWJsaW5nO2omJmoudGV4dENvbnRlbnQucmVwbGFjZSgvXFxcXHUyMDBCL2csXFxcIlxcXCIpPT09YygpLnJlcGxhY2UoL1xcXFx1MjAwQi9nLFxcXCJcXFwiKSYmKGg9aixpPSEwKX19ZWxzZSBpZighZy5jb2xsYXBzZWQmJmgubmV4dFNpYmxpbmcmJmgubmV4dFNpYmxpbmcubm9kZVR5cGU9PU5vZGUuRUxFTUVOVF9OT0RFKXt2YXIgaj1oLm5leHRTaWJsaW5nO2omJmoudGV4dENvbnRlbnQucmVwbGFjZSgvXFxcXHUyMDBCL2csXFxcIlxcXCIpPT09YygpLnJlcGxhY2UoL1xcXFx1MjAwQi9nLFxcXCJcXFwiKSYmKGg9aixpPSEwKX0haSYmaC5jaGlsZE5vZGVzLmxlbmd0aD4wJiZhKGguY2hpbGROb2Rlc1swXSkudGV4dCgpLnJlcGxhY2UoL1xcXFx1MjAwQi9nLFxcXCJcXFwiKT09PWMoKS5yZXBsYWNlKC9cXFxcdTIwMEIvZyxcXFwiXFxcIikmJltcXFwiQlJcXFwiLFxcXCJJTUdcXFwiLFxcXCJIUlxcXCJdLmluZGV4T2YoaC5jaGlsZE5vZGVzWzBdLnRhZ05hbWUpPDAmJihoPWguY2hpbGROb2Rlc1swXSl9Zm9yKDtoLm5vZGVUeXBlIT1Ob2RlLkVMRU1FTlRfTk9ERSYmaC5wYXJlbnROb2RlOyloPWgucGFyZW50Tm9kZTtmb3IodmFyIGs9aDtrJiZcXFwiSFRNTFxcXCIhPWsudGFnTmFtZTspe2lmKGs9PWIuJGVsLmdldCgwKSlyZXR1cm4gaDtrPWEoaykucGFyZW50KClbMF19fX1jYXRjaChsKXt9cmV0dXJuIGIuJGVsLmdldCgwKX1mdW5jdGlvbiBoKCl7dmFyIGY9ZCgpO3RyeXtpZihmLnJhbmdlQ291bnQpe3ZhciBnPWUoMCksaD1nLmVuZENvbnRhaW5lcjtpZihoLm5vZGVUeXBlPT1Ob2RlLkVMRU1FTlRfTk9ERSl7dmFyIGk9ITE7aWYoaC5jaGlsZE5vZGVzLmxlbmd0aD4wJiZoLmNoaWxkTm9kZXNbZy5lbmRPZmZzZXRdJiZhKGguY2hpbGROb2Rlc1tnLmVuZE9mZnNldF0pLnRleHQoKT09PWMoKSloPWguY2hpbGROb2Rlc1tnLmVuZE9mZnNldF0saT0hMDtlbHNlIGlmKCFnLmNvbGxhcHNlZCYmaC5wcmV2aW91c1NpYmxpbmcmJmgucHJldmlvdXNTaWJsaW5nLm5vZGVUeXBlPT1Ob2RlLkVMRU1FTlRfTk9ERSl7dmFyIGo9aC5wcmV2aW91c1NpYmxpbmc7aiYmai50ZXh0Q29udGVudC5yZXBsYWNlKC9cXFxcdTIwMEIvZyxcXFwiXFxcIik9PT1jKCkucmVwbGFjZSgvXFxcXHUyMDBCL2csXFxcIlxcXCIpJiYoaD1qLGk9ITApfWVsc2UgaWYoIWcuY29sbGFwc2VkJiZoLmNoaWxkTm9kZXMubGVuZ3RoPjAmJmguY2hpbGROb2Rlc1tnLmVuZE9mZnNldF0pe3ZhciBqPWguY2hpbGROb2Rlc1tnLmVuZE9mZnNldF0ucHJldmlvdXNTaWJsaW5nO2oubm9kZVR5cGU9PU5vZGUuRUxFTUVOVF9OT0RFJiZqJiZqLnRleHRDb250ZW50LnJlcGxhY2UoL1xcXFx1MjAwQi9nLFxcXCJcXFwiKT09PWMoKS5yZXBsYWNlKC9cXFxcdTIwMEIvZyxcXFwiXFxcIikmJihoPWosaT0hMCl9IWkmJmguY2hpbGROb2Rlcy5sZW5ndGg+MCYmYShoLmNoaWxkTm9kZXNbaC5jaGlsZE5vZGVzLmxlbmd0aC0xXSkudGV4dCgpPT09YygpJiZbXFxcIkJSXFxcIixcXFwiSU1HXFxcIixcXFwiSFJcXFwiXS5pbmRleE9mKGguY2hpbGROb2Rlc1toLmNoaWxkTm9kZXMubGVuZ3RoLTFdLnRhZ05hbWUpPDAmJihoPWguY2hpbGROb2Rlc1toLmNoaWxkTm9kZXMubGVuZ3RoLTFdKX1mb3IoaC5ub2RlVHlwZT09Tm9kZS5URVhUX05PREUmJjA9PWcuZW5kT2Zmc2V0JiZoLnByZXZpb3VzU2libGluZyYmaC5wcmV2aW91c1NpYmxpbmcubm9kZVR5cGU9PU5vZGUuRUxFTUVOVF9OT0RFJiYoaD1oLnByZXZpb3VzU2libGluZyk7aC5ub2RlVHlwZSE9Tm9kZS5FTEVNRU5UX05PREUmJmgucGFyZW50Tm9kZTspaD1oLnBhcmVudE5vZGU7Zm9yKHZhciBrPWg7ayYmXFxcIkhUTUxcXFwiIT1rLnRhZ05hbWU7KXtpZihrPT1iLiRlbC5nZXQoMCkpcmV0dXJuIGg7az1hKGspLnBhcmVudCgpWzBdfX19Y2F0Y2gobCl7fXJldHVybiBiLiRlbC5nZXQoMCl9ZnVuY3Rpb24gaShhLGIpe3ZhciBjPWE7cmV0dXJuIGMubm9kZVR5cGU9PU5vZGUuRUxFTUVOVF9OT0RFJiZjLmNoaWxkTm9kZXMubGVuZ3RoPjAmJmMuY2hpbGROb2Rlc1tiXSYmKGM9Yy5jaGlsZE5vZGVzW2JdKSxjLm5vZGVUeXBlPT1Ob2RlLlRFWFRfTk9ERSYmKGM9Yy5wYXJlbnROb2RlKSxjfWZ1bmN0aW9uIGooKXt2YXIgYz1bXSxmPWQoKTtpZih0KCkmJmYucmFuZ2VDb3VudClmb3IodmFyIGc9ZSgpLGg9MDtoPGcubGVuZ3RoO2grKyl7dmFyIGo9Z1toXSxrPWkoai5zdGFydENvbnRhaW5lcixqLnN0YXJ0T2Zmc2V0KSxsPWkoai5lbmRDb250YWluZXIsai5lbmRPZmZzZXQpO2Iubm9kZS5pc0Jsb2NrKGspJiZjLmluZGV4T2Yoayk8MCYmYy5wdXNoKGspO3ZhciBtPWIubm9kZS5ibG9ja1BhcmVudChrKTttJiZjLmluZGV4T2YobSk8MCYmYy5wdXNoKG0pO2Zvcih2YXIgbj1bXSxvPWs7byE9PWwmJm8hPT1iLiRlbC5nZXQoMCk7KW4uaW5kZXhPZihvKTwwJiZvLmNoaWxkcmVuJiZvLmNoaWxkcmVuLmxlbmd0aD8obi5wdXNoKG8pLG89by5jaGlsZHJlblswXSk6by5uZXh0U2libGluZz9vPW8ubmV4dFNpYmxpbmc6by5wYXJlbnROb2RlJiYobz1vLnBhcmVudE5vZGUsbi5wdXNoKG8pKSxiLm5vZGUuaXNCbG9jayhvKSYmbi5pbmRleE9mKG8pPDAmJmMuaW5kZXhPZihvKTwwJiYobyE9PWx8fGouZW5kT2Zmc2V0PjApJiZjLnB1c2gobyk7Yi5ub2RlLmlzQmxvY2sobCkmJmMuaW5kZXhPZihsKTwwJiZqLmVuZE9mZnNldD4wJiZjLnB1c2gobCk7dmFyIG09Yi5ub2RlLmJsb2NrUGFyZW50KGwpO20mJmMuaW5kZXhPZihtKTwwJiZjLnB1c2gobSl9Zm9yKHZhciBoPWMubGVuZ3RoLTE7aD4wO2gtLSlhKGNbaF0pLmZpbmQoYykubGVuZ3RoJiZcXFwiTElcXFwiIT1jW2hdLnRhZ05hbWUmJmMuc3BsaWNlKGgsMSk7cmV0dXJuIGN9ZnVuY3Rpb24gaygpe2lmKGIuJHdwKXtiLm1hcmtlcnMucmVtb3ZlKCk7Zm9yKHZhciBhPWUoKSxjPVtdLGQ9MDtkPGEubGVuZ3RoO2QrKylpZihhW2RdLnN0YXJ0Q29udGFpbmVyIT09Yi5kb2Mpe3ZhciBmPWFbZF0sZz1mLmNvbGxhcHNlZCxoPWIubWFya2Vycy5wbGFjZShmLCEwLGQpLGk9Yi5tYXJrZXJzLnBsYWNlKGYsITEsZCk7aWYoYi4kZWwuZ2V0KDApLm5vcm1hbGl6ZSgpLGIuYnJvd3Nlci5zYWZhcmkmJiFnKXt2YXIgZj1iLmRvYy5jcmVhdGVSYW5nZSgpO2Yuc2V0U3RhcnRBZnRlcihoKSxmLnNldEVuZEJlZm9yZShpKSxjLnB1c2goZil9fWlmKGIuYnJvd3Nlci5zYWZhcmkmJmMubGVuZ3RoKXtiLnNlbGVjdGlvbi5jbGVhcigpO2Zvcih2YXIgZD0wO2Q8Yy5sZW5ndGg7ZCsrKWIuc2VsZWN0aW9uLmdldCgpLmFkZFJhbmdlKGNbZF0pfX19ZnVuY3Rpb24gbCgpe3ZhciBjPWIuJGVsLmdldCgwKS5xdWVyeVNlbGVjdG9yQWxsKCcuZnItbWFya2VyW2RhdGEtdHlwZT1cXFwidHJ1ZVxcXCJdJyk7aWYoIWIuJHdwKXJldHVybiBiLm1hcmtlcnMucmVtb3ZlKCksITE7aWYoMD09PWMubGVuZ3RoKXJldHVybiExO2lmKGIuYnJvd3Nlci5tc2llfHxiLmJyb3dzZXIuZWRnZSlmb3IodmFyIGU9MDtlPGMubGVuZ3RoO2UrKyljW2VdLnN0eWxlLmRpc3BsYXk9XFxcImlubGluZS1ibG9ja1xcXCI7Yi5jb3JlLmhhc0ZvY3VzKCl8fGIuYnJvd3Nlci5tc2llfHxiLmJyb3dzZXIud2Via2l0fHxiLiRlbC5mb2N1cygpLGYoKTtmb3IodmFyIGc9ZCgpLGU9MDtlPGMubGVuZ3RoO2UrKyl7dmFyIGg9YShjW2VdKS5kYXRhKFxcXCJpZFxcXCIpLGk9Y1tlXSxqPWIuZG9jLmNyZWF0ZVJhbmdlKCksaz1iLiRlbC5maW5kKCcuZnItbWFya2VyW2RhdGEtdHlwZT1cXFwiZmFsc2VcXFwiXVtkYXRhLWlkPVxcXCInK2grJ1xcXCJdJyk7KGIuYnJvd3Nlci5tc2llfHxiLmJyb3dzZXIuZWRnZSkmJmsuY3NzKFxcXCJkaXNwbGF5XFxcIixcXFwiaW5saW5lLWJsb2NrXFxcIik7dmFyIGw9bnVsbDtpZihrLmxlbmd0aD4wKXtrPWtbMF07dHJ5e2Zvcih2YXIgbj0hMSxvPWkubmV4dFNpYmxpbmc7byYmby5ub2RlVHlwZT09Tm9kZS5URVhUX05PREUmJjA9PW8udGV4dENvbnRlbnQubGVuZ3RoOyl7dmFyIHA9bztvPW8ubmV4dFNpYmxpbmcsYShwKS5yZW1vdmUoKX1mb3IodmFyIHE9ay5uZXh0U2libGluZztxJiZxLm5vZGVUeXBlPT1Ob2RlLlRFWFRfTk9ERSYmMD09cS50ZXh0Q29udGVudC5sZW5ndGg7KXt2YXIgcD1xO3E9cS5uZXh0U2libGluZyxhKHApLnJlbW92ZSgpfWlmKGkubmV4dFNpYmxpbmc9PWt8fGsubmV4dFNpYmxpbmc9PWkpe2Zvcih2YXIgcj1pLm5leHRTaWJsaW5nPT1rP2k6ayxzPXI9PWk/azppLHQ9ci5wcmV2aW91c1NpYmxpbmc7dCYmdC5ub2RlVHlwZT09Tm9kZS5URVhUX05PREUmJjA9PXQubGVuZ3RoOyl7dmFyIHA9dDt0PXQucHJldmlvdXNTaWJsaW5nLGEocCkucmVtb3ZlKCl9aWYodCYmdC5ub2RlVHlwZT09Tm9kZS5URVhUX05PREUpZm9yKDt0JiZ0LnByZXZpb3VzU2libGluZyYmdC5wcmV2aW91c1NpYmxpbmcubm9kZVR5cGU9PU5vZGUuVEVYVF9OT0RFOyl0LnByZXZpb3VzU2libGluZy50ZXh0Q29udGVudD10LnByZXZpb3VzU2libGluZy50ZXh0Q29udGVudCt0LnRleHRDb250ZW50LHQ9dC5wcmV2aW91c1NpYmxpbmcsYSh0Lm5leHRTaWJsaW5nKS5yZW1vdmUoKTtmb3IodmFyIHU9cy5uZXh0U2libGluZzt1JiZ1Lm5vZGVUeXBlPT1Ob2RlLlRFWFRfTk9ERSYmMD09dS5sZW5ndGg7KXt2YXIgcD11O3U9dS5uZXh0U2libGluZyxhKHApLnJlbW92ZSgpfWlmKHUmJnUubm9kZVR5cGU9PU5vZGUuVEVYVF9OT0RFKWZvcig7dSYmdS5uZXh0U2libGluZyYmdS5uZXh0U2libGluZy5ub2RlVHlwZT09Tm9kZS5URVhUX05PREU7KXUubmV4dFNpYmxpbmcudGV4dENvbnRlbnQ9dS50ZXh0Q29udGVudCt1Lm5leHRTaWJsaW5nLnRleHRDb250ZW50LHU9dS5uZXh0U2libGluZyxhKHUucHJldmlvdXNTaWJsaW5nKS5yZW1vdmUoKTtpZih0JiYoYi5ub2RlLmlzVm9pZCh0KXx8Yi5ub2RlLmlzQmxvY2sodCkpJiYodD1udWxsKSx1JiYoYi5ub2RlLmlzVm9pZCh1KXx8Yi5ub2RlLmlzQmxvY2sodSkpJiYodT1udWxsKSx0JiZ1JiZ0Lm5vZGVUeXBlPT1Ob2RlLlRFWFRfTk9ERSYmdS5ub2RlVHlwZT09Tm9kZS5URVhUX05PREUpe2EoaSkucmVtb3ZlKCksYShrKS5yZW1vdmUoKTt2YXIgdj10LnRleHRDb250ZW50Lmxlbmd0aDt0LnRleHRDb250ZW50PXQudGV4dENvbnRlbnQrdS50ZXh0Q29udGVudCxhKHUpLnJlbW92ZSgpLGIuc3BhY2VzLm5vcm1hbGl6ZSh0KSxqLnNldFN0YXJ0KHQsdiksai5zZXRFbmQodCx2KSxuPSEwfWVsc2UhdCYmdSYmdS5ub2RlVHlwZT09Tm9kZS5URVhUX05PREU/KGEoaSkucmVtb3ZlKCksYShrKS5yZW1vdmUoKSxiLnNwYWNlcy5ub3JtYWxpemUodSksbD1hKGIuZG9jLmNyZWF0ZVRleHROb2RlKFxcXCJcXFxcdTIwMGJcXFwiKSksYSh1KS5iZWZvcmUobCksai5zZXRTdGFydCh1LDApLGouc2V0RW5kKHUsMCksbj0hMCk6IXUmJnQmJnQubm9kZVR5cGU9PU5vZGUuVEVYVF9OT0RFJiYoYShpKS5yZW1vdmUoKSxhKGspLnJlbW92ZSgpLGIuc3BhY2VzLm5vcm1hbGl6ZSh0KSxsPWEoYi5kb2MuY3JlYXRlVGV4dE5vZGUoXFxcIlxcXFx1MjAwYlxcXCIpKSxhKHQpLmFmdGVyKGwpLGouc2V0U3RhcnQodCx0LnRleHRDb250ZW50Lmxlbmd0aCksai5zZXRFbmQodCx0LnRleHRDb250ZW50Lmxlbmd0aCksbj0hMCl9aWYoIW4pe3ZhciB3LHg7aWYoYi5icm93c2VyLmNocm9tZSYmaS5uZXh0U2libGluZz09ayl3PW0oayxqLCEwKXx8ai5zZXRTdGFydEFmdGVyKGspLHg9bShpLGosITEpfHxqLnNldEVuZEJlZm9yZShpKTtlbHNle2kucHJldmlvdXNTaWJsaW5nPT1rJiYoaT1rLGs9aS5uZXh0U2libGluZyksay5uZXh0U2libGluZyYmXFxcIkJSXFxcIj09PWsubmV4dFNpYmxpbmcudGFnTmFtZXx8IWsubmV4dFNpYmxpbmcmJmIubm9kZS5pc0Jsb2NrKGkucHJldmlvdXNTaWJsaW5nKXx8aS5wcmV2aW91c1NpYmxpbmcmJlxcXCJCUlxcXCI9PWkucHJldmlvdXNTaWJsaW5nLnRhZ05hbWV8fChpLnN0eWxlLmRpc3BsYXk9XFxcImlubGluZVxcXCIsay5zdHlsZS5kaXNwbGF5PVxcXCJpbmxpbmVcXFwiLGw9YShiLmRvYy5jcmVhdGVUZXh0Tm9kZShcXFwiXFxcXHUyMDBiXFxcIikpKTt2YXIgeT1pLnByZXZpb3VzU2libGluZzt5JiZ5LnN0eWxlJiZcXFwiYmxvY2tcXFwiPT1iLndpbi5nZXRDb21wdXRlZFN0eWxlKHkpLmRpc3BsYXkmJiFiLm9wdHMuZW50ZXI9PWEuRkUuRU5URVJfQlI/KGouc2V0RW5kQWZ0ZXIoeSksai5zZXRTdGFydEFmdGVyKHkpKToodz1tKGksaiwhMCl8fGEoaSkuYmVmb3JlKGwpJiZqLnNldFN0YXJ0QmVmb3JlKGkpLHg9bShrLGosITEpfHxhKGspLmFmdGVyKGwpJiZqLnNldEVuZEFmdGVyKGspKX1cXFwiZnVuY3Rpb25cXFwiPT10eXBlb2YgdyYmdygpLFxcXCJmdW5jdGlvblxcXCI9PXR5cGVvZiB4JiZ4KCl9fWNhdGNoKHope319bCYmbC5yZW1vdmUoKTt0cnl7Zy5hZGRSYW5nZShqKX1jYXRjaCh6KXt9fWIubWFya2Vycy5yZW1vdmUoKX1mdW5jdGlvbiBtKGMsZCxlKXt2YXIgZj1jLnByZXZpb3VzU2libGluZyxnPWMubmV4dFNpYmxpbmc7aWYoZiYmZyYmZi5ub2RlVHlwZT09Tm9kZS5URVhUX05PREUmJmcubm9kZVR5cGU9PU5vZGUuVEVYVF9OT0RFKXt2YXIgaD1mLnRleHRDb250ZW50Lmxlbmd0aDtyZXR1cm4gZT8oZy50ZXh0Q29udGVudD1mLnRleHRDb250ZW50K2cudGV4dENvbnRlbnQsYShmKS5yZW1vdmUoKSxhKGMpLnJlbW92ZSgpLGIuc3BhY2VzLm5vcm1hbGl6ZShnKSxmdW5jdGlvbigpe2Quc2V0U3RhcnQoZyxoKX0pOihmLnRleHRDb250ZW50PWYudGV4dENvbnRlbnQrZy50ZXh0Q29udGVudCxhKGcpLnJlbW92ZSgpLGEoYykucmVtb3ZlKCksYi5zcGFjZXMubm9ybWFsaXplKGYpLGZ1bmN0aW9uKCl7ZC5zZXRFbmQoZixoKX0pfWlmKGYmJiFnJiZmLm5vZGVUeXBlPT1Ob2RlLlRFWFRfTk9ERSl7dmFyIGg9Zi50ZXh0Q29udGVudC5sZW5ndGg7cmV0dXJuIGU/KGIuc3BhY2VzLm5vcm1hbGl6ZShmKSxmdW5jdGlvbigpe2Quc2V0U3RhcnQoZixoKX0pOihiLnNwYWNlcy5ub3JtYWxpemUoZiksZnVuY3Rpb24oKXtkLnNldEVuZChmLGgpfSl9cmV0dXJuIGcmJiFmJiZnLm5vZGVUeXBlPT1Ob2RlLlRFWFRfTk9ERT9lPyhiLnNwYWNlcy5ub3JtYWxpemUoZyksZnVuY3Rpb24oKXtkLnNldFN0YXJ0KGcsMCl9KTooYi5zcGFjZXMubm9ybWFsaXplKGcpLGZ1bmN0aW9uKCl7ZC5zZXRFbmQoZywwKX0pOiExfWZ1bmN0aW9uIG4oKXtyZXR1cm4hMH1mdW5jdGlvbiBvKCl7Zm9yKHZhciBhPWUoKSxiPTA7YjxhLmxlbmd0aDtiKyspaWYoIWFbYl0uY29sbGFwc2VkKXJldHVybiExO3JldHVybiEwfWZ1bmN0aW9uIHAoYSl7dmFyIGMsZCxlPSExLGY9ITE7aWYoYi53aW4uZ2V0U2VsZWN0aW9uKXt2YXIgZz1iLndpbi5nZXRTZWxlY3Rpb24oKTtnLnJhbmdlQ291bnQmJihjPWcuZ2V0UmFuZ2VBdCgwKSxkPWMuY2xvbmVSYW5nZSgpLGQuc2VsZWN0Tm9kZUNvbnRlbnRzKGEpLGQuc2V0RW5kKGMuc3RhcnRDb250YWluZXIsYy5zdGFydE9mZnNldCksZT1cXFwiXFxcIj09PWQudG9TdHJpbmcoKSxkLnNlbGVjdE5vZGVDb250ZW50cyhhKSxkLnNldFN0YXJ0KGMuZW5kQ29udGFpbmVyLGMuZW5kT2Zmc2V0KSxmPVxcXCJcXFwiPT09ZC50b1N0cmluZygpKX1lbHNlIGIuZG9jLnNlbGVjdGlvbiYmXFxcIkNvbnRyb2xcXFwiIT1iLmRvYy5zZWxlY3Rpb24udHlwZSYmKGM9Yi5kb2Muc2VsZWN0aW9uLmNyZWF0ZVJhbmdlKCksZD1jLmR1cGxpY2F0ZSgpLGQubW92ZVRvRWxlbWVudFRleHQoYSksZC5zZXRFbmRQb2ludChcXFwiRW5kVG9TdGFydFxcXCIsYyksZT1cXFwiXFxcIj09PWQudGV4dCxkLm1vdmVUb0VsZW1lbnRUZXh0KGEpLGQuc2V0RW5kUG9pbnQoXFxcIlN0YXJ0VG9FbmRcXFwiLGMpLGY9XFxcIlxcXCI9PT1kLnRleHQpO3JldHVybnthdFN0YXJ0OmUsYXRFbmQ6Zn19ZnVuY3Rpb24gcSgpe2lmKG8oKSlyZXR1cm4hMTtiLiRlbC5maW5kKFxcXCJ0ZCwgdGgsIGltZ1xcXCIpLnByZXBlbmQoJzxzcGFuIGNsYXNzPVxcXCJmci1ta1xcXCI+JythLkZFLklOVklTSUJMRV9TUEFDRStcXFwiPC9zcGFuPlxcXCIpO3ZhciBjPSExLGQ9cChiLiRlbC5nZXQoMCkpO3JldHVybiBkLmF0U3RhcnQmJmQuYXRFbmQmJihjPSEwKSxiLiRlbC5maW5kKFxcXCIuZnItbWtcXFwiKS5yZW1vdmUoKSxjfWZ1bmN0aW9uIHIoYyxkKXtcXFwidW5kZWZpbmVkXFxcIj09dHlwZW9mIGQmJihkPSEwKTt2YXIgZT1hKGMpLmh0bWwoKTtlJiZlLnJlcGxhY2UoL1xcXFx1MjAwYi9nLFxcXCJcXFwiKS5sZW5ndGghPWUubGVuZ3RoJiZhKGMpLmh0bWwoZS5yZXBsYWNlKC9cXFxcdTIwMGIvZyxcXFwiXFxcIikpO2Zvcih2YXIgZj1iLm5vZGUuY29udGVudHMoYyksZz0wO2c8Zi5sZW5ndGg7ZysrKWZbZ10ubm9kZVR5cGUhPU5vZGUuRUxFTUVOVF9OT0RFP2EoZltnXSkucmVtb3ZlKCk6KHIoZltnXSwwPT1nKSwwPT1nJiYoZD0hMSkpO2Mubm9kZVR5cGU9PU5vZGUuVEVYVF9OT0RFP2EoYykucmVwbGFjZVdpdGgoJzxzcGFuIGRhdGEtZmlyc3Q9XFxcInRydWVcXFwiIGRhdGEtdGV4dD1cXFwidHJ1ZVxcXCI+PC9zcGFuPicpOmQmJmEoYykuYXR0cihcXFwiZGF0YS1maXJzdFxcXCIsITApfWZ1bmN0aW9uIHMoYyxkKXt2YXIgZT1iLm5vZGUuY29udGVudHMoYy5nZXQoMCkpO1tcXFwiVERcXFwiLFxcXCJUSFxcXCJdLmluZGV4T2YoYy5nZXQoMCkudGFnTmFtZSk+PTAmJjE9PWMuZmluZChcXFwiLmZyLW1hcmtlclxcXCIpLmxlbmd0aCYmYShlWzBdKS5oYXNDbGFzcyhcXFwiZnItbWFya2VyXFxcIikmJmMuYXR0cihcXFwiZGF0YS1kZWwtY2VsbFxcXCIsITApO2Zvcih2YXIgZj0wO2Y8ZS5sZW5ndGg7ZisrKXt2YXIgZz1lW2ZdO2EoZykuaGFzQ2xhc3MoXFxcImZyLW1hcmtlclxcXCIpP2Q9KGQrMSklMjpkP2EoZykuZmluZChcXFwiLmZyLW1hcmtlclxcXCIpLmxlbmd0aD4wP2Q9cyhhKGcpLGQpOltcXFwiVERcXFwiLFxcXCJUSFxcXCJdLmluZGV4T2YoZy50YWdOYW1lKTwwJiYhYShnKS5oYXNDbGFzcyhcXFwiZnItaW5uZXJcXFwiKT8hYi5vcHRzLmtlZXBGb3JtYXRPbkRlbGV0ZXx8Yi4kZWwuZmluZChcXFwiW2RhdGEtZmlyc3RdXFxcIikubGVuZ3RoPjA/YShnKS5yZW1vdmUoKTpyKGcpOmEoZykuaGFzQ2xhc3MoXFxcImZyLWlubmVyXFxcIik/MD09YShnKS5maW5kKFxcXCIuZnItaW5uZXJcXFwiKS5sZW5ndGg/YShnKS5odG1sKFxcXCI8YnI+XFxcIik6YShnKS5maW5kKFxcXCIuZnItaW5uZXJcXFwiKS5maWx0ZXIoZnVuY3Rpb24oKXtyZXR1cm4gMD09YSh0aGlzKS5maW5kKFxcXCJmci1pbm5lclxcXCIpLmxlbmd0aH0pLmh0bWwoXFxcIjxicj5cXFwiKTooYShnKS5lbXB0eSgpLGEoZykuYXR0cihcXFwiZGF0YS1kZWwtY2VsbFxcXCIsITApKTphKGcpLmZpbmQoXFxcIi5mci1tYXJrZXJcXFwiKS5sZW5ndGg+MCYmKGQ9cyhhKGcpLGQpKX1yZXR1cm4gZH1mdW5jdGlvbiB0KCl7dHJ5e2lmKCFiLiR3cClyZXR1cm4hMTtmb3IodmFyIGE9ZSgwKSxjPWEuY29tbW9uQW5jZXN0b3JDb250YWluZXI7YyYmIWIubm9kZS5pc0VsZW1lbnQoYyk7KWM9Yy5wYXJlbnROb2RlO3JldHVybiBiLm5vZGUuaXNFbGVtZW50KGMpPyEwOiExfWNhdGNoKGQpe3JldHVybiExfX1mdW5jdGlvbiB1KCl7aWYobygpKXJldHVybiEwO2soKTtmb3IodmFyIGM9ZnVuY3Rpb24oYil7Zm9yKHZhciBjPWIucHJldmlvdXNTaWJsaW5nO2MmJmMubm9kZVR5cGU9PU5vZGUuVEVYVF9OT0RFJiYwPT1jLnRleHRDb250ZW50Lmxlbmd0aDspe3ZhciBkPWMsYz1jLnByZXZpb3VzU2libGluZzthKGQpLnJlbW92ZSgpfXJldHVybiBjfSxkPWZ1bmN0aW9uKGIpe2Zvcih2YXIgYz1iLm5leHRTaWJsaW5nO2MmJmMubm9kZVR5cGU9PU5vZGUuVEVYVF9OT0RFJiYwPT1jLnRleHRDb250ZW50Lmxlbmd0aDspe3ZhciBkPWMsYz1jLm5leHRTaWJsaW5nO2EoZCkucmVtb3ZlKCl9cmV0dXJuIGN9LGU9Yi4kZWwuZmluZCgnLmZyLW1hcmtlcltkYXRhLXR5cGU9XFxcInRydWVcXFwiXScpLGY9MDtmPGUubGVuZ3RoO2YrKylmb3IodmFyIGc9ZVtmXTshYyhnKSYmIWIubm9kZS5pc0Jsb2NrKGcucGFyZW50Tm9kZSkmJiFiLiRlbC5pcyhnLnBhcmVudE5vZGUpOylhKGcucGFyZW50Tm9kZSkuYmVmb3JlKGcpO2Zvcih2YXIgaD1iLiRlbC5maW5kKCcuZnItbWFya2VyW2RhdGEtdHlwZT1cXFwiZmFsc2VcXFwiXScpLGY9MDtmPGgubGVuZ3RoO2YrKyl7Zm9yKHZhciBpPWhbZl07IWQoaSkmJiFiLm5vZGUuaXNCbG9jayhpLnBhcmVudE5vZGUpJiYhYi4kZWwuaXMoaS5wYXJlbnROb2RlKTspYShpLnBhcmVudE5vZGUpLmFmdGVyKGkpO2kucGFyZW50Tm9kZSYmYi5ub2RlLmlzQmxvY2soaS5wYXJlbnROb2RlKSYmYi5ub2RlLmlzRW1wdHkoaS5wYXJlbnROb2RlKSYmIWIuJGVsLmlzKGkucGFyZW50Tm9kZSkmJmIub3B0cy5rZWVwRm9ybWF0T25EZWxldGUmJmEoaS5wYXJlbnROb2RlKS5hZnRlcihpKX1pZihuKCkpe3MoYi4kZWwsMCk7dmFyIGo9Yi4kZWwuZmluZCgnW2RhdGEtZmlyc3Q9XFxcInRydWVcXFwiXScpO2lmKGoubGVuZ3RoKWIuJGVsLmZpbmQoXFxcIi5mci1tYXJrZXJcXFwiKS5yZW1vdmUoKSxqLmFwcGVuZChhLkZFLklOVklTSUJMRV9TUEFDRSthLkZFLk1BUktFUlMpLnJlbW92ZUF0dHIoXFxcImRhdGEtZmlyc3RcXFwiKSxqLmF0dHIoXFxcImRhdGEtdGV4dFxcXCIpJiZqLnJlcGxhY2VXaXRoKGouaHRtbCgpKTtlbHNle2IuJGVsLmZpbmQoXFxcInRhYmxlXFxcIikuZmlsdGVyKGZ1bmN0aW9uKCl7dmFyIGI9YSh0aGlzKS5maW5kKFxcXCJbZGF0YS1kZWwtY2VsbF1cXFwiKS5sZW5ndGg+MCYmYSh0aGlzKS5maW5kKFxcXCJbZGF0YS1kZWwtY2VsbF1cXFwiKS5sZW5ndGg9PWEodGhpcykuZmluZChcXFwidGQsIHRoXFxcIikubGVuZ3RoO3JldHVybiBifSkucmVtb3ZlKCksYi4kZWwuZmluZChcXFwiW2RhdGEtZGVsLWNlbGxdXFxcIikucmVtb3ZlQXR0cihcXFwiZGF0YS1kZWwtY2VsbFxcXCIpO2Zvcih2YXIgZT1iLiRlbC5maW5kKCcuZnItbWFya2VyW2RhdGEtdHlwZT1cXFwidHJ1ZVxcXCJdJyksZj0wO2Y8ZS5sZW5ndGg7ZisrKXt2YXIgbT1lW2ZdLHA9bS5uZXh0U2libGluZyxxPWIuJGVsLmZpbmQoJy5mci1tYXJrZXJbZGF0YS10eXBlPVxcXCJmYWxzZVxcXCJdW2RhdGEtaWQ9XFxcIicrYShtKS5kYXRhKFxcXCJpZFxcXCIpKydcXFwiXScpLmdldCgwKTtpZihxKXtpZihwJiZwPT1xKTtlbHNlIGlmKG0pe3ZhciByPWIubm9kZS5ibG9ja1BhcmVudChtKSx0PWIubm9kZS5ibG9ja1BhcmVudChxKSx1PSExLHY9ITE7aWYociYmW1xcXCJVTFxcXCIsXFxcIk9MXFxcIl0uaW5kZXhPZihyLnRhZ05hbWUpPj0wJiYocj1udWxsLHU9ITApLHQmJltcXFwiVUxcXFwiLFxcXCJPTFxcXCJdLmluZGV4T2YodC50YWdOYW1lKT49MCYmKHQ9bnVsbCx2PSEwKSxhKG0pLmFmdGVyKHEpLHI9PXQpO2Vsc2UgaWYobnVsbCE9cnx8dSlpZihudWxsIT10fHx2fHwwIT1hKHIpLnBhcmVudHNVbnRpbChiLiRlbCxcXFwidGFibGVcXFwiKS5sZW5ndGgpciYmdCYmMD09YShyKS5wYXJlbnRzVW50aWwoYi4kZWwsXFxcInRhYmxlXFxcIikubGVuZ3RoJiYwPT1hKHQpLnBhcmVudHNVbnRpbChiLiRlbCxcXFwidGFibGVcXFwiKS5sZW5ndGgmJihhKHIpLmFwcGVuZChhKHQpLmh0bWwoKSksYSh0KS5yZW1vdmUoKSk7ZWxzZXtmb3IodmFyIHA9cjshcC5uZXh0U2libGluZyYmcC5wYXJlbnROb2RlIT1iLiRlbC5nZXQoMCk7KXA9cC5wYXJlbnROb2RlO2ZvcihwPXAubmV4dFNpYmxpbmc7cCYmXFxcIkJSXFxcIiE9cC50YWdOYW1lOyl7dmFyIHc9cC5uZXh0U2libGluZzthKHIpLmFwcGVuZChwKSxwPXd9cCYmXFxcIkJSXFxcIj09cC50YWdOYW1lJiZhKHApLnJlbW92ZSgpfWVsc2V7dmFyIHg9Yi5ub2RlLmRlZXBlc3RQYXJlbnQobSk7eD8oYSh4KS5hZnRlcihhKHQpLmh0bWwoKSksYSh0KS5yZW1vdmUoKSk6MD09YSh0KS5wYXJlbnRzVW50aWwoYi4kZWwsXFxcInRhYmxlXFxcIikubGVuZ3RoJiYoYShtKS5uZXh0KCkuYWZ0ZXIoYSh0KS5odG1sKCkpLGEodCkucmVtb3ZlKCkpfX19ZWxzZSBxPWEobSkuY2xvbmUoKS5hdHRyKFxcXCJkYXRhLXR5cGVcXFwiLCExKSxhKG0pLmFmdGVyKHEpfX19Yi5vcHRzLmtlZXBGb3JtYXRPbkRlbGV0ZXx8Yi5odG1sLmZpbGxFbXB0eUJsb2NrcygpLGIuaHRtbC5jbGVhbkVtcHR5VGFncyghMCksYi5jbGVhbi5saXN0cygpLGIuc3BhY2VzLm5vcm1hbGl6ZSgpO3ZhciB5PWIuJGVsLmZpbmQoXFxcIi5mci1tYXJrZXI6bGFzdFxcXCIpLmdldCgwKSx6PWIuJGVsLmZpbmQoXFxcIi5mci1tYXJrZXI6Zmlyc3RcXFwiKS5nZXQoMCk7IXkubmV4dFNpYmxpbmcmJnoucHJldmlvdXNTaWJsaW5nJiZcXFwiQlJcXFwiPT16LnByZXZpb3VzU2libGluZy50YWdOYW1lJiZiLm5vZGUuaXNFbGVtZW50KHkucGFyZW50Tm9kZSkmJmIubm9kZS5pc0VsZW1lbnQoei5wYXJlbnROb2RlKSYmYi4kZWwuYXBwZW5kKFxcXCI8YnI+XFxcIiksbCgpfWZ1bmN0aW9uIHYoYyl7aWYoYShjKS5maW5kKFxcXCIuZnItbWFya2VyXFxcIikubGVuZ3RoPjApcmV0dXJuITE7Zm9yKHZhciBkPWIubm9kZS5jb250ZW50cyhjKTtkLmxlbmd0aCYmYi5ub2RlLmlzQmxvY2soZFswXSk7KWM9ZFswXSxkPWIubm9kZS5jb250ZW50cyhjKTthKGMpLnByZXBlbmQoYS5GRS5NQVJLRVJTKX1mdW5jdGlvbiB3KGMpe2lmKGEoYykuZmluZChcXFwiLmZyLW1hcmtlclxcXCIpLmxlbmd0aD4wKXJldHVybiExO2Zvcih2YXIgZD1iLm5vZGUuY29udGVudHMoYyk7ZC5sZW5ndGgmJmIubm9kZS5pc0Jsb2NrKGRbZC5sZW5ndGgtMV0pOyljPWRbZC5sZW5ndGgtMV0sZD1iLm5vZGUuY29udGVudHMoYyk7YShjKS5hcHBlbmQoYS5GRS5NQVJLRVJTKX1mdW5jdGlvbiB4KGMpe2Zvcih2YXIgZD1jLnByZXZpb3VzU2libGluZztkJiZkLm5vZGVUeXBlPT1Ob2RlLlRFWFRfTk9ERSYmMD09ZC50ZXh0Q29udGVudC5sZW5ndGg7KWQ9ZC5wcmV2aW91c1NpYmxpbmc7cmV0dXJuIGQ/KGIubm9kZS5pc0Jsb2NrKGQpP3coZCk6XFxcIkJSXFxcIj09ZC50YWdOYW1lP2EoZCkuYmVmb3JlKGEuRkUuTUFSS0VSUyk6YShkKS5hZnRlcihhLkZFLk1BUktFUlMpLCEwKTohMX1mdW5jdGlvbiB5KGMpe2Zvcih2YXIgZD1jLm5leHRTaWJsaW5nO2QmJmQubm9kZVR5cGU9PU5vZGUuVEVYVF9OT0RFJiYwPT1kLnRleHRDb250ZW50Lmxlbmd0aDspZD1kLm5leHRTaWJsaW5nO3JldHVybiBkPyhiLm5vZGUuaXNCbG9jayhkKT92KGQpOmEoZCkuYmVmb3JlKGEuRkUuTUFSS0VSUyksITApOiExfXJldHVybnt0ZXh0OmMsZ2V0OmQscmFuZ2VzOmUsY2xlYXI6ZixlbGVtZW50OmcsZW5kRWxlbWVudDpoLHNhdmU6ayxyZXN0b3JlOmwsaXNDb2xsYXBzZWQ6byxpc0Z1bGw6cSxpbkVkaXRvcjp0LHJlbW92ZTp1LGJsb2NrczpqLGluZm86cCxzZXRBdEVuZDp3LHNldEF0U3RhcnQ6dixzZXRCZWZvcmU6eCxzZXRBZnRlcjp5LHJhbmdlRWxlbWVudDppfX0sYS5GRS5NT0RVTEVTLnNwYWNlcz1mdW5jdGlvbihiKXtmdW5jdGlvbiBjKGEpe3ZhciBiPWEubmV4dFNpYmxpbmd8fGEucGFyZW50Tm9kZTtyZXR1cm4gYS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGEpLGJ9ZnVuY3Rpb24gZChhLGIpe3JldHVybiBhJiZhLnBhcmVudE5vZGU9PT1ifHxcXFwiUFJFXFxcIj09PWIubm9kZU5hbWU/Yi5uZXh0U2libGluZ3x8Yi5wYXJlbnROb2RlOmIuZmlyc3RDaGlsZHx8Yi5uZXh0U2libGluZ3x8Yi5wYXJlbnROb2RlfWZ1bmN0aW9uIGUoYSl7aWYoYS5maXJzdENoaWxkJiZcXFwiUFJFXFxcIiE9PWEubm9kZU5hbWUmJiEoW1xcXCJTVFlMRVxcXCIsXFxcIlNDUklQVFxcXCJdLmluZGV4T2YoYS50YWdOYW1lKT49MCkpe2Zvcih2YXIgZT1udWxsLGY9bnVsbCxnPWQoZixhKTtnIT09YSYmXFxcIlBSRVxcXCIhPT1nLm5vZGVOYW1lJiZbXFxcIlNUWUxFXFxcIixcXFwiU0NSSVBUXFxcIl0uaW5kZXhPZihnLnRhZ05hbWUpPDA7KXtpZihnLm5vZGVUeXBlPT09Tm9kZS5URVhUX05PREUpe3ZhciBoPWcuZGF0YS5yZXBsYWNlKC9bIFxcXFxyXFxcXG5cXFxcdF0rL2csXFxcIiBcXFwiKTtpZihlJiYhLyAkLy50ZXN0KGUuZGF0YSl8fFxcXCIgXFxcIiE9PWhbMF18fGcucHJldmlvdXNTaWJsaW5nJiZiLm5vZGUuaXNWb2lkKGcucHJldmlvdXNTaWJsaW5nKSYmXFxcIkJSXFxcIiE9PWcucHJldmlvdXNTaWJsaW5nLnRhZ05hbWV8fChoPWguc3Vic3RyKDEpKSwhaHx8MD09aC5sZW5ndGgpe2c9YyhnKTtjb250aW51ZX1nLmRhdGE9aCxlPWd9ZWxzZSBnLm5vZGVUeXBlPT09Tm9kZS5FTEVNRU5UX05PREUmJihiLm5vZGUuaXNCbG9jayhnKXx8Yi5ub2RlLmlzVm9pZChnKT8oZSYmZS5kYXRhJiYoYi5ub2RlLmlzQmxvY2soZyl8fFxcXCJCUlxcXCI9PT1nLnRhZ05hbWUpJiYoZS5kYXRhPWUuZGF0YS5yZXBsYWNlKC8gJC8sXFxcIlxcXCIpKSxlPW51bGwpOjA9PWcudGV4dENvbnRlbnQubGVuZ3RoJiYoZT1nKSk7dmFyIGk9ZChmLGcpO2Y9ZyxnPWl9ZSYmZS5kYXRhJiYoZS5kYXRhPWUuZGF0YS5yZXBsYWNlKC8gJC8sXFxcIlxcXCIpLGUuZGF0YXx8YyhlKSl9fWZ1bmN0aW9uIGYoYyxkKXtpZihcXFwidW5kZWZpbmVkXFxcIiE9dHlwZW9mIGMmJmN8fChjPWIuJGVsLmdldCgwKSksXFxcInVuZGVmaW5lZFxcXCI9PXR5cGVvZiBkJiYoZD0hMSksZCYmZShjKSwhYy5nZXRBdHRyaWJ1dGV8fFxcXCJmYWxzZVxcXCIhPWMuZ2V0QXR0cmlidXRlKFxcXCJjb250ZW50ZWRpdGFibGVcXFwiKSlpZihjLm5vZGVUeXBlPT1Ob2RlLkVMRU1FTlRfTk9ERSYmW1xcXCJTVFlMRVxcXCIsXFxcIlNDUklQVFxcXCIsXFxcIkhFQURcXFwiXS5pbmRleE9mKGMudGFnTmFtZSk8MClmb3IodmFyIGc9Yi5ub2RlLmNvbnRlbnRzKGMpLGg9Zy5sZW5ndGgtMTtoPj0wO2gtLSkoZ1toXS50YWdOYW1lIT1Ob2RlLkVMRU1FTlRfTk9ERXx8KGdbaF0uZ2V0QXR0cmlidXRlKFxcXCJjbGFzc1xcXCIpfHxcXFwiXFxcIikuaW5kZXhPZihcXFwiZnItbWFya2VyXFxcIik8MCkmJmYoZ1toXSk7ZWxzZSBpZihjLm5vZGVUeXBlPT1Ob2RlLlRFWFRfTk9ERSYmYy50ZXh0Q29udGVudC5sZW5ndGg+MCl7dmFyIGk9KGMucHJldmlvdXNTaWJsaW5nLGMubmV4dFNpYmxpbmcsYy50ZXh0Q29udGVudCk7aT1pLnJlcGxhY2UobmV3IFJlZ0V4cChhLkZFLlVOSUNPREVfTkJTUCxcXFwiZ1xcXCIpLFxcXCIgXFxcIik7Zm9yKHZhciBqPVxcXCJcXFwiLGs9MDtrPGkubGVuZ3RoO2srKylqKz0zMiE9aS5jaGFyQ29kZUF0KGspfHwwIT09ayYmMzIhPWouY2hhckNvZGVBdChrLTEpP2lba106YS5GRS5VTklDT0RFX05CU1A7KCFjLm5leHRTaWJsaW5nfHxiLm5vZGUuaXNCbG9jayhjLm5leHRTaWJsaW5nKXx8Yy5uZXh0U2libGluZy5ub2RlVHlwZT09Tm9kZS5FTEVNRU5UX05PREUmJmIud2luLmdldENvbXB1dGVkU3R5bGUoYy5uZXh0U2libGluZykmJlxcXCJibG9ja1xcXCI9PWIud2luLmdldENvbXB1dGVkU3R5bGUoYy5uZXh0U2libGluZykuZGlzcGxheSkmJihqPWoucmVwbGFjZSgvICQvLGEuRkUuVU5JQ09ERV9OQlNQKSksIWMucHJldmlvdXNTaWJsaW5nfHxiLm5vZGUuaXNWb2lkKGMucHJldmlvdXNTaWJsaW5nKXx8Yi5ub2RlLmlzQmxvY2soYy5wcmV2aW91c1NpYmxpbmcpfHwoaj1qLnJlcGxhY2UoL15cXFxcdTAwQTAoW14gJF0pLyxcXFwiICQxXFxcIiksMSE9PWoubGVuZ3RofHwxNjAhPT1qLmNoYXJDb2RlQXQoMCl8fCFjLm5leHRTaWJsaW5nfHxiLm5vZGUuaXNWb2lkKGMubmV4dFNpYmxpbmcpfHxiLm5vZGUuaXNCbG9jayhjLm5leHRTaWJsaW5nKXx8KGo9XFxcIiBcXFwiKSksaj1qLnJlcGxhY2UoLyhbXiBcXFxcdTAwQTBdKVxcXFx1MDBBMChbXiBcXFxcdTAwQTBdKS9nLFxcXCIkMSAkMlxcXCIpLGMudGV4dENvbnRlbnQhPWomJihjLnRleHRDb250ZW50PWopfX1yZXR1cm57bm9ybWFsaXplOmZ9fSxhLkZFLlVOSUNPREVfTkJTUD1TdHJpbmcuZnJvbUNoYXJDb2RlKDE2MCksYS5GRS5WT0lEX0VMRU1FTlRTPVtcXFwiYXJlYVxcXCIsXFxcImJhc2VcXFwiLFxcXCJiclxcXCIsXFxcImNvbFxcXCIsXFxcImVtYmVkXFxcIixcXFwiaHJcXFwiLFxcXCJpbWdcXFwiLFxcXCJpbnB1dFxcXCIsXFxcImtleWdlblxcXCIsXFxcImxpbmtcXFwiLFxcXCJtZW51aXRlbVxcXCIsXFxcIm1ldGFcXFwiLFxcXCJwYXJhbVxcXCIsXFxcInNvdXJjZVxcXCIsXFxcInRyYWNrXFxcIixcXFwid2JyXFxcIl0sYS5GRS5CTE9DS19UQUdTPVtcXFwiYWRkcmVzc1xcXCIsXFxcImFydGljbGVcXFwiLFxcXCJhc2lkZVxcXCIsXFxcImF1ZGlvXFxcIixcXFwiYmxvY2txdW90ZVxcXCIsXFxcImNhbnZhc1xcXCIsXFxcImRkXFxcIixcXFwiZGl2XFxcIixcXFwiZGxcXFwiLFxcXCJkdFxcXCIsXFxcImZpZWxkc2V0XFxcIixcXFwiZmlnY2FwdGlvblxcXCIsXFxcImZpZ3VyZVxcXCIsXFxcImZvb3RlclxcXCIsXFxcImZvcm1cXFwiLFxcXCJoMVxcXCIsXFxcImgyXFxcIixcXFwiaDNcXFwiLFxcXCJoNFxcXCIsXFxcImg1XFxcIixcXFwiaDZcXFwiLFxcXCJoZWFkZXJcXFwiLFxcXCJoZ3JvdXBcXFwiLFxcXCJoclxcXCIsXFxcImxpXFxcIixcXFwibWFpblxcXCIsXFxcIm5hdlxcXCIsXFxcIm5vc2NyaXB0XFxcIixcXFwib2xcXFwiLFxcXCJvdXRwdXRcXFwiLFxcXCJwXFxcIixcXFwicHJlXFxcIixcXFwic2VjdGlvblxcXCIsXFxcInRhYmxlXFxcIixcXFwidGJvZHlcXFwiLFxcXCJ0ZFxcXCIsXFxcInRmb290XFxcIixcXFwidGhcXFwiLFxcXCJ0aGVhZFxcXCIsXFxcInRyXFxcIixcXFwidWxcXFwiLFxcXCJ2aWRlb1xcXCJdLGEuZXh0ZW5kKGEuRkUuREVGQVVMVFMse2h0bWxBbGxvd2VkRW1wdHlUYWdzOltcXFwidGV4dGFyZWFcXFwiLFxcXCJhXFxcIixcXFwiaWZyYW1lXFxcIixcXFwib2JqZWN0XFxcIixcXFwidmlkZW9cXFwiLFxcXCJzdHlsZVxcXCIsXFxcInNjcmlwdFxcXCIsXFxcIi5mYVxcXCIsXFxcIi5mci1lbW90aWNvblxcXCJdLGh0bWxEb05vdFdyYXBUYWdzOltcXFwic2NyaXB0XFxcIixcXFwic3R5bGVcXFwiXSxodG1sU2ltcGxlQW1wZXJzYW5kOiExLGh0bWxJZ25vcmVDU1NQcm9wZXJ0aWVzOltdfSksYS5GRS5NT0RVTEVTLmh0bWw9ZnVuY3Rpb24oYil7ZnVuY3Rpb24gYygpe3JldHVybiBiLm9wdHMuZW50ZXI9PWEuRkUuRU5URVJfUD9cXFwicFxcXCI6Yi5vcHRzLmVudGVyPT1hLkZFLkVOVEVSX0RJVj9cXFwiZGl2XFxcIjpiLm9wdHMuZW50ZXI9PWEuRkUuRU5URVJfQlI/bnVsbDp2b2lkIDB9ZnVuY3Rpb24gZCgpe3ZhciBjPVtdLGQ9Yi4kZWwuZ2V0KDApLnF1ZXJ5U2VsZWN0b3JBbGwoZigpKSxlPWYoKTtlKz1cXFwiLFxcXCIrYS5GRS5WT0lEX0VMRU1FTlRTLmpvaW4oXFxcIixcXFwiKSxlKz1cXFwiLFxcXCIrYi5vcHRzLmh0bWxBbGxvd2VkRW1wdHlUYWdzLmpvaW4oXFxcIjpub3QoLmZyLW1hcmtlciksXFxcIikrXFxcIjpub3QoLmZyLW1hcmtlcilcXFwiO2Zvcih2YXIgZz1kLmxlbmd0aC0xO2c+PTA7Zy0tKWlmKCEoZFtnXS5xdWVyeVNlbGVjdG9yQWxsKGUpLmxlbmd0aD4wfHxkW2ddLnRleHRDb250ZW50JiZkW2ddLnRleHRDb250ZW50LnJlcGxhY2UoL1xcXFx1MjAwQnxcXFxcbi9nLFxcXCJcXFwiKS5sZW5ndGg+MCkpe2Zvcih2YXIgaD1iLm5vZGUuY29udGVudHMoZFtnXSksaT0hMSxqPTA7ajxoLmxlbmd0aDtqKyspaWYoaFtqXS5ub2RlVHlwZSE9Tm9kZS5DT01NRU5UX05PREUmJmhbal0udGV4dENvbnRlbnQmJmhbal0udGV4dENvbnRlbnQucmVwbGFjZSgvXFxcXHUyMDBCfFxcXFxuL2csXFxcIlxcXCIpLmxlbmd0aD4wKXtpPSEwO2JyZWFrfWl8fGMucHVzaChkW2ddKX1yZXR1cm4gY31mdW5jdGlvbiBlKCl7cmV0dXJuIGEuRkUuQkxPQ0tfVEFHUy5qb2luKFxcXCI6ZW1wdHksIFxcXCIpK1xcXCI6ZW1wdHlcXFwifWZ1bmN0aW9uIGYoKXtyZXR1cm4gYS5GRS5CTE9DS19UQUdTLmpvaW4oXFxcIiwgXFxcIil9ZnVuY3Rpb24gZyhjKXt2YXIgZD1hLm1lcmdlKFtdLGEuRkUuVk9JRF9FTEVNRU5UUyk7ZD1hLm1lcmdlKGQsYi5vcHRzLmh0bWxBbGxvd2VkRW1wdHlUYWdzKSxcXFwidW5kZWZpbmVkXFxcIj09dHlwZW9mIGMmJihkPWEubWVyZ2UoZCxhLkZFLkJMT0NLX1RBR1MpKTt2YXIgZSxmO2Rve2Y9ITEsZT1iLiRlbC5nZXQoMCkucXVlcnlTZWxlY3RvckFsbChcXFwiKjplbXB0eTpub3QoXFxcIitkLmpvaW4oXFxcIik6bm90KFxcXCIpK1xcXCIpOm5vdCguZnItbWFya2VyKVxcXCIpO2Zvcih2YXIgZz0wO2c8ZS5sZW5ndGg7ZysrKSgwPT09ZVtnXS5hdHRyaWJ1dGVzLmxlbmd0aHx8XFxcInVuZGVmaW5lZFxcXCIhPXR5cGVvZiBlW2ddLmdldEF0dHJpYnV0ZShcXFwiaHJlZlxcXCIpKSYmKGEoZVtnXSkucmVtb3ZlKCksZj0hMCk7ZT1iLiRlbC5nZXQoMCkucXVlcnlTZWxlY3RvckFsbChcXFwiKjplbXB0eTpub3QoXFxcIitkLmpvaW4oXFxcIik6bm90KFxcXCIpK1xcXCIpOm5vdCguZnItbWFya2VyKVxcXCIpfXdoaWxlKGUubGVuZ3RoJiZmKX1mdW5jdGlvbiBoKGQsZSl7dmFyIGY9YygpO2lmKGUmJihmPSdkaXYgY2xhc3M9XFxcImZyLXRlbXAtZGl2XFxcIicpLGYpZm9yKHZhciBnPWIubm9kZS5jb250ZW50cyhkLmdldCgwKSksaD1udWxsLGk9MDtpPGcubGVuZ3RoO2krKyl7dmFyIGo9Z1tpXTtpZihqLm5vZGVUeXBlPT1Ob2RlLkVMRU1FTlRfTk9ERSYmKGIubm9kZS5pc0Jsb2NrKGopfHxhKGopLmlzKGIub3B0cy5odG1sRG9Ob3RXcmFwVGFncy5qb2luKFxcXCIsXFxcIikpJiYhYShqKS5oYXNDbGFzcyhcXFwiZnItbWFya2VyXFxcIikpKWg9bnVsbDtlbHNlIGlmKGoubm9kZVR5cGUhPU5vZGUuRUxFTUVOVF9OT0RFJiZqLm5vZGVUeXBlIT1Ob2RlLlRFWFRfTk9ERSloPW51bGw7ZWxzZSBpZihqLm5vZGVUeXBlPT1Ob2RlLkVMRU1FTlRfTk9ERSYmXFxcIkJSXFxcIj09ai50YWdOYW1lKWlmKG51bGw9PWgpZT9hKGopLnJlcGxhY2VXaXRoKFxcXCI8XFxcIitmKycgZGF0YS1lbXB0eT1cXFwidHJ1ZVxcXCI+PGJyPjwvZGl2PicpOmEoaikucmVwbGFjZVdpdGgoXFxcIjxcXFwiK2YrXFxcIj48YnI+PC9cXFwiK2YrXFxcIj5cXFwiKTtlbHNle2EoaikucmVtb3ZlKCk7Zm9yKHZhciBrPWIubm9kZS5jb250ZW50cyhoKSxsPSExLG09MDttPGsubGVuZ3RoO20rKylpZighYShrW21dKS5oYXNDbGFzcyhcXFwiZnItbWFya2VyXFxcIikmJihrW21dLm5vZGVUeXBlIT1Ob2RlLlRFWFRfTk9ERXx8MCE9PWtbbV0udGV4dENvbnRlbnQucmVwbGFjZSgvIC9nLFxcXCJcXFwiKS5sZW5ndGgpKXtsPSEwO2JyZWFrfWw9PT0hMSYmKGguYXBwZW5kKFxcXCI8YnI+XFxcIiksaC5kYXRhKFxcXCJlbXB0eVxcXCIsITApKSxoPW51bGx9ZWxzZSBqLm5vZGVUeXBlPT1Ob2RlLlRFWFRfTk9ERSYmMD09ai50ZXh0Q29udGVudC5yZXBsYWNlKC9cXFxcbi9nLFxcXCJcXFwiKS5yZXBsYWNlKC8oXiAqKXwoICokKS9nLFxcXCJcXFwiKS5sZW5ndGg/YShqKS5yZW1vdmUoKToobnVsbD09aCYmKGg9YShcXFwiPFxcXCIrZitcXFwiPlxcXCIpLGEoaikuYmVmb3JlKGgpKSxqLm5vZGVUeXBlPT1Ob2RlLlRFWFRfTk9ERSYmYShqKS50ZXh0KCkudHJpbSgpLmxlbmd0aD4wPyhoLmFwcGVuZChhKGopLmNsb25lKCkpLGEoaikucmVtb3ZlKCkpOmguYXBwZW5kKGEoaikpKX19ZnVuY3Rpb24gaShjLGQsZSxmKXtyZXR1cm4gYi4kd3A/KFxcXCJ1bmRlZmluZWRcXFwiPT10eXBlb2YgYyYmKGM9ITEpLFxcXCJ1bmRlZmluZWRcXFwiPT10eXBlb2YgZCYmKGQ9ITEpLFxcXCJ1bmRlZmluZWRcXFwiPT10eXBlb2YgZSYmKGU9ITEpLFxcXCJ1bmRlZmluZWRcXFwiPT10eXBlb2YgZiYmKGY9ITEpLGgoYi4kZWwsYyksZiYmYi4kZWwuZmluZChcXFwiLmZyLWlubmVyXFxcIikuZWFjaChmdW5jdGlvbigpe2goYSh0aGlzKSxjKX0pLGQmJmIuJGVsLmZpbmQoXFxcInRkLCB0aFxcXCIpLmVhY2goZnVuY3Rpb24oKXtoKGEodGhpcyksYyl9KSx2b2lkKGUmJmIuJGVsLmZpbmQoXFxcImJsb2NrcXVvdGVcXFwiKS5lYWNoKGZ1bmN0aW9uKCl7aChhKHRoaXMpLGMpfSkpKTohMX1mdW5jdGlvbiBqKCl7Yi4kZWwuZmluZChcXFwiZGl2LmZyLXRlbXAtZGl2XFxcIikuZWFjaChmdW5jdGlvbigpe2EodGhpcykuZGF0YShcXFwiZW1wdHlcXFwiKXx8XFxcIkxJXFxcIj09dGhpcy5wYXJlbnROb2RlLnRhZ05hbWV8fGIubm9kZS5pc0Jsb2NrKHRoaXMucHJldmlvdXNTaWJsaW5nKT9hKHRoaXMpLnJlcGxhY2VXaXRoKGEodGhpcykuaHRtbCgpKTphKHRoaXMpLnJlcGxhY2VXaXRoKGEodGhpcykuaHRtbCgpK1xcXCI8YnI+XFxcIil9KSxiLiRlbC5maW5kKFxcXCIuZnItdGVtcC1kaXZcXFwiKS5yZW1vdmVDbGFzcyhcXFwiZnItdGVtcC1kaXZcXFwiKS5maWx0ZXIoZnVuY3Rpb24oKXtyZXR1cm5cXFwiXFxcIj09YSh0aGlzKS5hdHRyKFxcXCJjbGFzc1xcXCIpfSkucmVtb3ZlQXR0cihcXFwiY2xhc3NcXFwiKX1mdW5jdGlvbiBrKCl7Zm9yKHZhciBjPWQoKSxlPTA7ZTxjLmxlbmd0aDtlKyspe3ZhciBmPWNbZV07XFxcImZhbHNlXFxcIj09Zi5nZXRBdHRyaWJ1dGUoXFxcImNvbnRlbnRlZGl0YWJsZVxcXCIpfHwwIT1mLnF1ZXJ5U2VsZWN0b3JBbGwoYi5vcHRzLmh0bWxBbGxvd2VkRW1wdHlUYWdzLmpvaW4oXFxcIjpub3QoLmZyLW1hcmtlciksXFxcIikrXFxcIjpub3QoLmZyLW1hcmtlcilcXFwiKS5sZW5ndGh8fGIubm9kZS5pc1ZvaWQoZil8fFxcXCJUQUJMRVxcXCIhPWYudGFnTmFtZSYmXFxcIlRCT0RZXFxcIiE9Zi50YWdOYW1lJiZcXFwiVFJcXFwiIT1mLnRhZ05hbWUmJmYuYXBwZW5kQ2hpbGQoYi5kb2MuY3JlYXRlRWxlbWVudChcXFwiYnJcXFwiKSl9aWYoYi5icm93c2VyLm1zaWUmJmIub3B0cy5lbnRlcj09YS5GRS5FTlRFUl9CUil7dmFyIGc9Yi5ub2RlLmNvbnRlbnRzKGIuJGVsLmdldCgwKSk7Zy5sZW5ndGgmJmdbZy5sZW5ndGgtMV0ubm9kZVR5cGU9PU5vZGUuVEVYVF9OT0RFJiZiLiRlbC5hcHBlbmQoXFxcIjxicj5cXFwiKX19ZnVuY3Rpb24gbCgpe3JldHVybiBiLiRlbC5maW5kKGYoKSl9ZnVuY3Rpb24gbShhKXtpZihcXFwidW5kZWZpbmVkXFxcIj09dHlwZW9mIGEmJihhPWIuJGVsLmdldCgwKSksYSYmW1xcXCJTQ1JJUFRcXFwiLFxcXCJTVFlMRVxcXCIsXFxcIlBSRVxcXCJdLmluZGV4T2YoYS50YWdOYW1lKT49MClyZXR1cm4hMTtmb3IodmFyIGM9Yi5ub2RlLmNvbnRlbnRzKGEpLGQ9Yy5sZW5ndGgtMTtkPj0wO2QtLSlpZihjW2RdLm5vZGVUeXBlPT1Ob2RlLlRFWFRfTk9ERSl7Y1tkXS50ZXh0Q29udGVudD1jW2RdLnRleHRDb250ZW50LnJlcGxhY2UoLyg/IV4pKCApezIsfSg/ISQpL2csXFxcIiBcXFwiKSxjW2RdLnRleHRDb250ZW50PWNbZF0udGV4dENvbnRlbnQucmVwbGFjZSgvXFxcXG4vZyxcXFwiIFxcXCIpLGNbZF0udGV4dENvbnRlbnQ9Y1tkXS50ZXh0Q29udGVudC5yZXBsYWNlKC9eWyBdezIsfS9nLFxcXCIgXFxcIiksY1tkXS50ZXh0Q29udGVudD1jW2RdLnRleHRDb250ZW50LnJlcGxhY2UoL1sgXXsyLH0kL2csXFxcIiBcXFwiKSwoYi5ub2RlLmlzQmxvY2soYSl8fGIubm9kZS5pc0VsZW1lbnQoYSkpJiYoY1tkXS5wcmV2aW91c1NpYmxpbmd8fChjW2RdLnRleHRDb250ZW50PWNbZF0udGV4dENvbnRlbnQucmVwbGFjZSgvXiAqLyxcXFwiXFxcIikpLGNbZF0ubmV4dFNpYmxpbmd8fChjW2RdLnRleHRDb250ZW50PWNbZF0udGV4dENvbnRlbnQucmVwbGFjZSgvICokLyxcXFwiXFxcIikpLGNbZF0ucHJldmlvdXNTaWJsaW5nJiZjW2RdLm5leHRTaWJsaW5nJiZcXFwiIFxcXCI9PWNbZF0udGV4dENvbnRlbnQmJihjW2RdLnByZXZpb3VzU2libGluZyYmY1tkXS5uZXh0U2libGluZyYmYi5ub2RlLmlzQmxvY2soY1tkXS5wcmV2aW91c1NpYmxpbmcpJiZiLm5vZGUuaXNCbG9jayhjW2RdLm5leHRTaWJsaW5nKT9jW2RdLnRleHRDb250ZW50PVxcXCJcXFwiOmNbZF0udGV4dENvbnRlbnQ9XFxcIlxcXFxuXFxcIikpfWVsc2UgbShjW2RdKX1mdW5jdGlvbiBuKGEpe3JldHVybiBhJiYoYi5ub2RlLmlzQmxvY2soYSl8fFtcXFwiU1RZTEVcXFwiLFxcXCJTQ1JJUFRcXFwiLFxcXCJIRUFEXFxcIixcXFwiQlJcXFwiLFxcXCJIUlxcXCJdLmluZGV4T2YoYS50YWdOYW1lKT49MHx8YS5ub2RlVHlwZT09Tm9kZS5DT01NRU5UX05PREUpfWZ1bmN0aW9uIG8oYyl7aWYoXFxcInVuZGVmaW5lZFxcXCI9PXR5cGVvZiBjJiYoYz1iLiRlbC5nZXQoMCkpLGMubm9kZVR5cGU9PU5vZGUuRUxFTUVOVF9OT0RFJiZbXFxcIlNUWUxFXFxcIixcXFwiU0NSSVBUXFxcIixcXFwiSEVBRFxcXCJdLmluZGV4T2YoYy50YWdOYW1lKTwwKXtmb3IodmFyIGQ9Yi5ub2RlLmNvbnRlbnRzKGMpLGU9ZC5sZW5ndGgtMTtlPj0wO2UtLSlpZighYShkW2VdKS5oYXNDbGFzcyhcXFwiZnItbWFya2VyXFxcIikpe3ZhciBmPW8oZFtlXSk7aWYoMT09ZilyZXR1cm4hMH19ZWxzZSBpZihjLm5vZGVUeXBlPT1Ob2RlLlRFWFRfTk9ERSYmYy50ZXh0Q29udGVudC5sZW5ndGg+MCl7dmFyIGc9Yy5wcmV2aW91c1NpYmxpbmcsaD1jLm5leHRTaWJsaW5nO2lmKG4oZykmJm4oaCkmJjA9PT1jLnRleHRDb250ZW50LnRyaW0oKS5sZW5ndGgpcmV0dXJuITA7dmFyIGk9Yy50ZXh0Q29udGVudDtpPWkucmVwbGFjZShuZXcgUmVnRXhwKGEuRkUuVU5JQ09ERV9OQlNQLFxcXCJnXFxcIiksXFxcIiBcXFwiKTtmb3IodmFyIGo9XFxcIlxcXCIsaz0wO2s8aS5sZW5ndGg7aysrKWorPTMyIT1pLmNoYXJDb2RlQXQoayl8fDAhPT1rJiYzMiE9ai5jaGFyQ29kZUF0KGstMSk/aVtrXTphLkZFLlVOSUNPREVfTkJTUDtpZihjLm5leHRTaWJsaW5nfHwoaj1qLnJlcGxhY2UoLyAkLyxhLkZFLlVOSUNPREVfTkJTUCkpLGMucHJldmlvdXNTaWJsaW5nJiYhYi5ub2RlLmlzVm9pZChjLnByZXZpb3VzU2libGluZykmJihqPWoucmVwbGFjZSgvXlxcXFx1MDBBMChbXiAkXSkvLFxcXCIgJDFcXFwiKSksaj1qLnJlcGxhY2UoLyhbXiBcXFxcdTAwQTBdKVxcXFx1MDBBMChbXiBcXFxcdTAwQTBdKS9nLFxcXCIkMSAkMlxcXCIpLGMudGV4dENvbnRlbnQhPWopcmV0dXJuITB9cmV0dXJuITF9ZnVuY3Rpb24gcChhLGIsYyl7dmFyIGQ9bmV3IFJlZ0V4cChiLFxcXCJnaVxcXCIpLGU9ZC5leGVjKGEpO3JldHVybiBlP2VbY106bnVsbH1mdW5jdGlvbiBxKGEsYil7dmFyIGM9YS5tYXRjaCgvPCFET0NUWVBFID8oW14gXSopID8oW14gXSopID9cXFwiPyhbXlxcXCJdKilcXFwiPyA/XFxcIj8oW15cXFwiXSopXFxcIj8+L2kpO3JldHVybiBjP2IuaW1wbGVtZW50YXRpb24uY3JlYXRlRG9jdW1lbnRUeXBlKGNbMV0sY1szXSxjWzRdKTpiLmltcGxlbWVudGF0aW9uLmNyZWF0ZURvY3VtZW50VHlwZShcXFwiaHRtbFxcXCIpfWZ1bmN0aW9uIHIoYSl7dmFyIGI9YS5kb2N0eXBlLGM9XFxcIjwhRE9DVFlQRSBodG1sPlxcXCI7cmV0dXJuIGImJihjPVxcXCI8IURPQ1RZUEUgXFxcIitiLm5hbWUrKGIucHVibGljSWQ/JyBQVUJMSUMgXFxcIicrYi5wdWJsaWNJZCsnXFxcIic6XFxcIlxcXCIpKyghYi5wdWJsaWNJZCYmYi5zeXN0ZW1JZD9cXFwiIFNZU1RFTVxcXCI6XFxcIlxcXCIpKyhiLnN5c3RlbUlkPycgXFxcIicrYi5zeXN0ZW1JZCsnXFxcIic6XFxcIlxcXCIpK1xcXCI+XFxcIiksY31mdW5jdGlvbiBzKCl7ZygpLGkoKSxtKCksYi5zcGFjZXMubm9ybWFsaXplKG51bGwsITApLGIuaHRtbC5maWxsRW1wdHlCbG9ja3MoKSxiLmNsZWFuLnF1b3RlcygpLGIuY2xlYW4ubGlzdHMoKSxiLmNsZWFuLnRhYmxlcygpLGIuY2xlYW4udG9IVE1MNSgpLGIuc2VsZWN0aW9uLnJlc3RvcmUoKSx0KCksYi5wbGFjZWhvbGRlci5yZWZyZXNoKCl9ZnVuY3Rpb24gdCgpe2IuY29yZS5pc0VtcHR5KCkmJihudWxsIT1jKCk/MD09PWIuJGVsLmdldCgwKS5xdWVyeVNlbGVjdG9yQWxsKGYoKSkubGVuZ3RoJiYwPT09Yi4kZWwuZ2V0KDApLnF1ZXJ5U2VsZWN0b3JBbGwoYi5vcHRzLmh0bWxEb05vdFdyYXBUYWdzLmpvaW4oXFxcIjpub3QoLmZyLW1hcmtlciksXFxcIikrXFxcIjpub3QoLmZyLW1hcmtlcilcXFwiKS5sZW5ndGgmJihiLmNvcmUuaGFzRm9jdXMoKT8oYi4kZWwuaHRtbChcXFwiPFxcXCIrYygpK1xcXCI+XFxcIithLkZFLk1BUktFUlMrXFxcIjxici8+PC9cXFwiK2MoKStcXFwiPlxcXCIpLGIuc2VsZWN0aW9uLnJlc3RvcmUoKSk6Yi4kZWwuaHRtbChcXFwiPFxcXCIrYygpK1xcXCI+PGJyLz48L1xcXCIrYygpK1xcXCI+XFxcIikpOjA9PT1iLiRlbC5nZXQoMCkucXVlcnlTZWxlY3RvckFsbChcXFwiKjpub3QoLmZyLW1hcmtlcik6bm90KGJyKVxcXCIpLmxlbmd0aCYmKGIuY29yZS5oYXNGb2N1cygpPyhiLiRlbC5odG1sKGEuRkUuTUFSS0VSUytcXFwiPGJyLz5cXFwiKSxiLnNlbGVjdGlvbi5yZXN0b3JlKCkpOmIuJGVsLmh0bWwoXFxcIjxici8+XFxcIikpKX1mdW5jdGlvbiB1KGEsYil7cmV0dXJuIHAoYSxcXFwiPFxcXCIrYitcXFwiW14+XSo/PihbXFxcXFxcXFx3XFxcXFxcXFxXXSopPC9cXFwiK2IrXFxcIj5cXFwiLDEpfWZ1bmN0aW9uIHYoYyxkKXt2YXIgZT1hKFxcXCI8ZGl2IFxcXCIrKHAoYyxcXFwiPFxcXCIrZCtcXFwiKFtePl0qPyk+XFxcIiwxKXx8XFxcIlxcXCIpK1xcXCI+XFxcIik7cmV0dXJuIGIubm9kZS5yYXdBdHRyaWJ1dGVzKGUuZ2V0KDApKX1mdW5jdGlvbiB3KGEpe3JldHVybiBwKGEsXFxcIjwhRE9DVFlQRShbXj5dKj8pPlxcXCIsMCl8fFxcXCI8IURPQ1RZUEUgaHRtbD5cXFwifWZ1bmN0aW9uIHgoYyl7dmFyIGQ9Yi5jbGVhbi5odG1sKGN8fFxcXCJcXFwiLFtdLFtdLGIub3B0cy5mdWxsUGFnZSk7aWYoYi5vcHRzLmZ1bGxQYWdlKXt2YXIgZT11KGQsXFxcImJvZHlcXFwiKXx8KGQuaW5kZXhPZihcXFwiPGJvZHlcXFwiKT49MD9cXFwiXFxcIjpkKSxmPXYoZCxcXFwiYm9keVxcXCIpLGc9dShkLFxcXCJoZWFkXFxcIil8fFxcXCI8dGl0bGU+PC90aXRsZT5cXFwiLGg9dihkLFxcXCJoZWFkXFxcIiksaT1hKFxcXCI8ZGl2PlxcXCIpLmFwcGVuZChnKS5jb250ZW50cygpLmVhY2goZnVuY3Rpb24oKXsodGhpcy5ub2RlVHlwZT09Tm9kZS5DT01NRU5UX05PREV8fFtcXFwiQkFTRVxcXCIsXFxcIkxJTktcXFwiLFxcXCJNRVRBXFxcIixcXFwiTk9TQ1JJUFRcXFwiLFxcXCJTQ1JJUFRcXFwiLFxcXCJTVFlMRVxcXCIsXFxcIlRFTVBMQVRFXFxcIixcXFwiVElUTEVcXFwiXS5pbmRleE9mKHRoaXMudGFnTmFtZSk+PTApJiZ0aGlzLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcyl9KS5lbmQoKS5odG1sKCkudHJpbSgpO2c9YShcXFwiPGRpdj5cXFwiKS5hcHBlbmQoZykuY29udGVudHMoKS5tYXAoZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5ub2RlVHlwZT09Tm9kZS5DT01NRU5UX05PREU/XFxcIjwhLS1cXFwiK3RoaXMubm9kZVZhbHVlK1xcXCItLT5cXFwiOltcXFwiQkFTRVxcXCIsXFxcIkxJTktcXFwiLFxcXCJNRVRBXFxcIixcXFwiTk9TQ1JJUFRcXFwiLFxcXCJTQ1JJUFRcXFwiLFxcXCJTVFlMRVxcXCIsXFxcIlRFTVBMQVRFXFxcIixcXFwiVElUTEVcXFwiXS5pbmRleE9mKHRoaXMudGFnTmFtZSk+PTA/dGhpcy5vdXRlckhUTUw6XFxcIlxcXCJ9KS50b0FycmF5KCkuam9pbihcXFwiXFxcIik7dmFyIGo9dyhkKSxrPXYoZCxcXFwiaHRtbFxcXCIpO2IuJGVsLmh0bWwoaStcXFwiXFxcXG5cXFwiK2UpLGIubm9kZS5jbGVhckF0dHJpYnV0ZXMoYi4kZWwuZ2V0KDApKSxiLiRlbC5hdHRyKGYpLGIuJGVsLmFkZENsYXNzKFxcXCJmci12aWV3XFxcIiksYi4kZWwuYXR0cihcXFwic3BlbGxjaGVja1xcXCIsYi5vcHRzLnNwZWxsY2hlY2spLGIuJGVsLmF0dHIoXFxcImRpclxcXCIsYi5vcHRzLmRpcmVjdGlvbiksYi4kaGVhZC5odG1sKGcpLGIubm9kZS5jbGVhckF0dHJpYnV0ZXMoYi4kaGVhZC5nZXQoMCkpLGIuJGhlYWQuYXR0cihoKSxiLm5vZGUuY2xlYXJBdHRyaWJ1dGVzKGIuJGh0bWwuZ2V0KDApKSxiLiRodG1sLmF0dHIoayksYi5pZnJhbWVfZG9jdW1lbnQuZG9jdHlwZS5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZChxKGosYi5pZnJhbWVfZG9jdW1lbnQpLGIuaWZyYW1lX2RvY3VtZW50LmRvY3R5cGUpfWVsc2UgYi4kZWwuaHRtbChkKTt2YXIgbD1iLmVkaXQuaXNEaXNhYmxlZCgpO2IuZWRpdC5vbigpLGIuY29yZS5pbmplY3RTdHlsZShiLm9wdHMuaWZyYW1lU3R5bGUpLHMoKSxiLm9wdHMudXNlQ2xhc3Nlc3x8KGIuJGVsLmZpbmQoXFxcIltmci1vcmlnaW5hbC1jbGFzc11cXFwiKS5lYWNoKGZ1bmN0aW9uKCl7dGhpcy5zZXRBdHRyaWJ1dGUoXFxcImNsYXNzXFxcIix0aGlzLmdldEF0dHJpYnV0ZShcXFwiZnItb3JpZ2luYWwtY2xhc3NcXFwiKSksdGhpcy5yZW1vdmVBdHRyaWJ1dGUoXFxcImZyLW9yaWdpbmFsLWNsYXNzXFxcIil9KSxiLiRlbC5maW5kKFxcXCJbZnItb3JpZ2luYWwtc3R5bGVdXFxcIikuZWFjaChmdW5jdGlvbigpe3RoaXMuc2V0QXR0cmlidXRlKFxcXCJzdHlsZVxcXCIsdGhpcy5nZXRBdHRyaWJ1dGUoXFxcImZyLW9yaWdpbmFsLXN0eWxlXFxcIikpLHRoaXMucmVtb3ZlQXR0cmlidXRlKFxcXCJmci1vcmlnaW5hbC1zdHlsZVxcXCIpfSkpLGwmJmIuZWRpdC5vZmYoKSxiLmV2ZW50cy50cmlnZ2VyKFxcXCJodG1sLnNldFxcXCIpfWZ1bmN0aW9uIHkoYSxjKXtpZighYi4kd3ApcmV0dXJuIGIuJG9lbC5jbG9uZSgpLnJlbW92ZUNsYXNzKFxcXCJmci12aWV3XFxcIikucmVtb3ZlQXR0cihcXFwiY29udGVudGVkaXRhYmxlXFxcIikuZ2V0KDApLm91dGVySFRNTDt2YXIgZD1cXFwiXFxcIjtiLmV2ZW50cy50cmlnZ2VyKFxcXCJodG1sLmJlZm9yZUdldFxcXCIpO3ZhciBlLGY9ZnVuY3Rpb24oYSl7dmFyIGI9LygjW15cXFxcc1xcXFwrPn5cXFxcLlxcXFxbOl0rKS9nLGM9LyhcXFxcW1teXFxcXF1dK1xcXFxdKS9nLGQ9LyhcXFxcLlteXFxcXHNcXFxcKz5+XFxcXC5cXFxcWzpdKykvZyxlPS8oOjpbXlxcXFxzXFxcXCs+flxcXFwuXFxcXFs6XSt8OmZpcnN0LWxpbmV8OmZpcnN0LWxldHRlcnw6YmVmb3JlfDphZnRlcikvZ2ksZj0vKDpbXFxcXHctXStcXFxcKFteXFxcXCldKlxcXFwpKS9naSxnPS8oOlteXFxcXHNcXFxcKz5+XFxcXC5cXFxcWzpdKykvZyxoPS8oW15cXFxcc1xcXFwrPn5cXFxcLlxcXFxbOl0rKS9nOyFmdW5jdGlvbigpe3ZhciBiPS86bm90XFxcXCgoW15cXFxcKV0qKVxcXFwpL2c7Yi50ZXN0KGEpJiYoYT1hLnJlcGxhY2UoYixcXFwiICAgICAkMSBcXFwiKSl9KCk7dmFyIGk9MTAwKihhLm1hdGNoKGIpfHxbXSkubGVuZ3RoKzEwKihhLm1hdGNoKGMpfHxbXSkubGVuZ3RoKzEwKihhLm1hdGNoKGQpfHxbXSkubGVuZ3RoKzEwKihhLm1hdGNoKGYpfHxbXSkubGVuZ3RoKzEwKihhLm1hdGNoKGcpfHxbXSkubGVuZ3RoKyhhLm1hdGNoKGUpfHxbXSkubGVuZ3RoO3JldHVybiBhPWEucmVwbGFjZSgvW1xcXFwqXFxcXHNcXFxcKz5+XS9nLFxcXCIgXFxcIiksYT1hLnJlcGxhY2UoL1sjXFxcXC5dL2csXFxcIiBcXFwiKSxpKz0oYS5tYXRjaChoKXx8W10pLmxlbmd0aH0sZz1bXSxoPXt9O2lmKCFiLm9wdHMudXNlQ2xhc3NlcyYmIWMpe3ZhciBpPW5ldyBSZWdFeHAoXFxcIl5cXFwiK2Iub3B0cy5odG1sSWdub3JlQ1NTUHJvcGVydGllcy5qb2luKFxcXCIkfF5cXFwiKStcXFwiJFxcXCIsXFxcImdpXFxcIik7Zm9yKGU9MDtlPGIuZG9jLnN0eWxlU2hlZXRzLmxlbmd0aDtlKyspe3ZhciBqLGs9MDt0cnl7aj1iLmRvYy5zdHlsZVNoZWV0c1tlXS5jc3NSdWxlcyxiLmRvYy5zdHlsZVNoZWV0c1tlXS5vd25lck5vZGUmJlxcXCJTVFlMRVxcXCI9PWIuZG9jLnN0eWxlU2hlZXRzW2VdLm93bmVyTm9kZS5ub2RlVHlwZSYmKGs9MSl9Y2F0Y2gobCl7fWlmKGopZm9yKHZhciBtPTAsbj1qLmxlbmd0aDtuPm07bSsrKWlmKGpbbV0uc2VsZWN0b3JUZXh0JiZqW21dLnN0eWxlLmNzc1RleHQubGVuZ3RoPjApe3ZhciBvLHA9alttXS5zZWxlY3RvclRleHQucmVwbGFjZSgvYm9keSB8XFxcXC5mci12aWV3IC9nLFxcXCJcXFwiKS5yZXBsYWNlKC86Oi9nLFxcXCI6XFxcIik7dHJ5e289Yi4kZWwuZ2V0KDApLnF1ZXJ5U2VsZWN0b3JBbGwocCl9Y2F0Y2gobCl7bz1bXX1mb3IodmFyIHE9MDtxPG8ubGVuZ3RoO3ErKyl7IW9bcV0uZ2V0QXR0cmlidXRlKFxcXCJmci1vcmlnaW5hbC1zdHlsZVxcXCIpJiZvW3FdLmdldEF0dHJpYnV0ZShcXFwic3R5bGVcXFwiKT8ob1txXS5zZXRBdHRyaWJ1dGUoXFxcImZyLW9yaWdpbmFsLXN0eWxlXFxcIixvW3FdLmdldEF0dHJpYnV0ZShcXFwic3R5bGVcXFwiKSksZy5wdXNoKG9bcV0pKTpvW3FdLmdldEF0dHJpYnV0ZShcXFwiZnItb3JpZ2luYWwtc3R5bGVcXFwiKXx8Zy5wdXNoKG9bcV0pLGhbb1txXV18fChoW29bcV1dPXt9KTtmb3IodmFyIHM9MWUzKmsrZihqW21dLnNlbGVjdG9yVGV4dCksdD1qW21dLnN0eWxlLmNzc1RleHQuc3BsaXQoXFxcIjtcXFwiKSx1PTA7dTx0Lmxlbmd0aDt1Kyspe3ZhciB2PXRbdV0udHJpbSgpLnNwbGl0KFxcXCI6XFxcIilbMF07di5tYXRjaChpKXx8KGhbb1txXV1bdl18fChoW29bcV1dW3ZdPTAsKG9bcV0uZ2V0QXR0cmlidXRlKFxcXCJmci1vcmlnaW5hbC1zdHlsZVxcXCIpfHxcXFwiXFxcIikuaW5kZXhPZih2K1xcXCI6XFxcIik+PTAmJihoW29bcV1dW3ZdPTFlNCkpLHM+PWhbb1txXV1bdl0mJihoW29bcV1dW3ZdPXMsdFt1XS50cmltKCkubGVuZ3RoJiYob1txXS5zdHlsZVt2LnRyaW0oKV09dFt1XS50cmltKCkuc3BsaXQoXFxcIjpcXFwiKVsxXS50cmltKCkpKSl9fX19Zm9yKGU9MDtlPGcubGVuZ3RoO2UrKylpZihnW2VdLmdldEF0dHJpYnV0ZShcXFwiY2xhc3NcXFwiKSYmKGdbZV0uc2V0QXR0cmlidXRlKFxcXCJmci1vcmlnaW5hbC1jbGFzc1xcXCIsZ1tlXS5nZXRBdHRyaWJ1dGUoXFxcImNsYXNzXFxcIikpLGdbZV0ucmVtb3ZlQXR0cmlidXRlKFxcXCJjbGFzc1xcXCIpKSwoZ1tlXS5nZXRBdHRyaWJ1dGUoXFxcImZyLW9yaWdpbmFsLXN0eWxlXFxcIil8fFxcXCJcXFwiKS50cmltKCkubGVuZ3RoPjApZm9yKHZhciB3PWdbZV0uZ2V0QXR0cmlidXRlKFxcXCJmci1vcmlnaW5hbC1zdHlsZVxcXCIpLnNwbGl0KFxcXCI7XFxcIikscT0wO3E8dy5sZW5ndGg7cSsrKXdbcV0uaW5kZXhPZihcXFwiOlxcXCIpPjAmJihnW2VdLnN0eWxlW3dbcV0uc3BsaXQoXFxcIjpcXFwiKVswXS50cmltKCldPXdbcV0uc3BsaXQoXFxcIjpcXFwiKVsxXS50cmltKCkpfWlmKGIuY29yZS5pc0VtcHR5KCk/Yi5vcHRzLmZ1bGxQYWdlJiYoZD1yKGIuaWZyYW1lX2RvY3VtZW50KSxkKz1cXFwiPGh0bWxcXFwiK2Iubm9kZS5hdHRyaWJ1dGVzKGIuJGh0bWwuZ2V0KDApKStcXFwiPlxcXCIrYi4kaHRtbC5maW5kKFxcXCJoZWFkXFxcIikuZ2V0KDApLm91dGVySFRNTCtcXFwiPGJvZHk+PC9ib2R5PjwvaHRtbD5cXFwiKTooXFxcInVuZGVmaW5lZFxcXCI9PXR5cGVvZiBhJiYoYT0hMSksYi5vcHRzLmZ1bGxQYWdlPyhkPXIoYi5pZnJhbWVfZG9jdW1lbnQpLGIuJGVsLnJlbW92ZUNsYXNzKFxcXCJmci12aWV3XFxcIiksZCs9XFxcIjxodG1sXFxcIitiLm5vZGUuYXR0cmlidXRlcyhiLiRodG1sLmdldCgwKSkrXFxcIj5cXFwiK2IuJGh0bWwuaHRtbCgpK1xcXCI8L2h0bWw+XFxcIixiLiRlbC5hZGRDbGFzcyhcXFwiZnItdmlld1xcXCIpKTpkPWIuJGVsLmh0bWwoKSksIWIub3B0cy51c2VDbGFzc2VzJiYhYylmb3IoZT0wO2U8Zy5sZW5ndGg7ZSsrKWdbZV0uZ2V0QXR0cmlidXRlKFxcXCJmci1vcmlnaW5hbC1jbGFzc1xcXCIpJiYoZ1tlXS5zZXRBdHRyaWJ1dGUoXFxcImNsYXNzXFxcIixnW2VdLmdldEF0dHJpYnV0ZShcXFwiZnItb3JpZ2luYWwtY2xhc3NcXFwiKSksZ1tlXS5yZW1vdmVBdHRyaWJ1dGUoXFxcImZyLW9yaWdpbmFsLWNsYXNzXFxcIikpLGdbZV0uZ2V0QXR0cmlidXRlKFxcXCJmci1vcmlnaW5hbC1zdHlsZVxcXCIpPyhnW2VdLnNldEF0dHJpYnV0ZShcXFwic3R5bGVcXFwiLGdbZV0uZ2V0QXR0cmlidXRlKFxcXCJmci1vcmlnaW5hbC1zdHlsZVxcXCIpKSxnW2VdLnJlbW92ZUF0dHJpYnV0ZShcXFwiZnItb3JpZ2luYWwtc3R5bGVcXFwiKSk6Z1tlXS5yZW1vdmVBdHRyaWJ1dGUoXFxcInN0eWxlXFxcIik7Yi5vcHRzLmZ1bGxQYWdlJiYoZD1kLnJlcGxhY2UoLzxzdHlsZSBkYXRhLWZyLXN0eWxlPVxcXCJ0cnVlXFxcIj4oPzpbXFxcXHdcXFxcV10qPyk8XFxcXC9zdHlsZT4vZyxcXFwiXFxcIiksZD1kLnJlcGxhY2UoLzxsaW5rKFtePl0qKWRhdGEtZnItc3R5bGU9XFxcInRydWVcXFwiKFtePl0qKT4vZyxcXFwiXFxcIiksZD1kLnJlcGxhY2UoLzxzdHlsZSg/OltcXFxcd1xcXFxXXSo/KWNsYXNzPVxcXCJmaXJlYnVnUmVzZXRTdHlsZXNcXFwiKD86W1xcXFx3XFxcXFddKj8pPig/OltcXFxcd1xcXFxXXSo/KTxcXFxcL3N0eWxlPi9nLFxcXCJcXFwiKSxkPWQucmVwbGFjZSgvPGJvZHkoKD86W1xcXFx3XFxcXFddKj8pKSBzcGVsbGNoZWNrPVxcXCJ0cnVlXFxcIigoPzpbXFxcXHdcXFxcV10qPykpPigoPzpbXFxcXHdcXFxcV10qPykpPFxcXFwvYm9keT4vZyxcXFwiPGJvZHkkMSQyPiQzPC9ib2R5PlxcXCIpLGQ9ZC5yZXBsYWNlKC88Ym9keSgoPzpbXFxcXHdcXFxcV10qPykpIGNvbnRlbnRlZGl0YWJsZT1cXFwiKHRydWV8ZmFsc2UpXFxcIigoPzpbXFxcXHdcXFxcV10qPykpPigoPzpbXFxcXHdcXFxcV10qPykpPFxcXFwvYm9keT4vZyxcXFwiPGJvZHkkMSQzPiQ0PC9ib2R5PlxcXCIpLGQ9ZC5yZXBsYWNlKC88Ym9keSgoPzpbXFxcXHdcXFxcV10qPykpIGRpcj1cXFwiKFtcXFxcd10qKVxcXCIoKD86W1xcXFx3XFxcXFddKj8pKT4oKD86W1xcXFx3XFxcXFddKj8pKTxcXFxcL2JvZHk+L2csXFxcIjxib2R5JDEkMz4kNDwvYm9keT5cXFwiKSxkPWQucmVwbGFjZSgvPGJvZHkoKD86W1xcXFx3XFxcXFddKj8pKWNsYXNzPVxcXCIoW1xcXFx3XFxcXFddKj8pKGZyLXJ0bHxmci1sdHIpKFtcXFxcd1xcXFxXXSo/KVxcXCIoKD86W1xcXFx3XFxcXFddKj8pKT4oKD86W1xcXFx3XFxcXFddKj8pKTxcXFxcL2JvZHk+L2csJzxib2R5JDFjbGFzcz1cXFwiJDIkNFxcXCIkNT4kNjwvYm9keT4nKSxkPWQucmVwbGFjZSgvPGJvZHkoKD86W1xcXFx3XFxcXFddKj8pKSBjbGFzcz1cXFwiXFxcIigoPzpbXFxcXHdcXFxcV10qPykpPigoPzpbXFxcXHdcXFxcV10qPykpPFxcXFwvYm9keT4vZyxcXFwiPGJvZHkkMSQyPiQzPC9ib2R5PlxcXCIpKSxiLm9wdHMuaHRtbFNpbXBsZUFtcGVyc2FuZCYmKGQ9ZC5yZXBsYWNlKC9cXFxcJmFtcDsvZ2ksXFxcIiZcXFwiKSksYi5ldmVudHMudHJpZ2dlcihcXFwiaHRtbC5hZnRlckdldFxcXCIpLGF8fChkPWQucmVwbGFjZSgvPHNwYW5bXj5dKj8gY2xhc3NcXFxccyo9XFxcXHMqW1xcXCInXT9mci1tYXJrZXJbXFxcIiddP1tePl0rPlxcXFx1MjAwYjxcXFxcL3NwYW4+L2dpLFxcXCJcXFwiKSksZD1iLmNsZWFuLmludmlzaWJsZVNwYWNlcyhkKTt2YXIgeD1iLmV2ZW50cy5jaGFpblRyaWdnZXIoXFxcImh0bWwuZ2V0XFxcIixkKTtyZXR1cm5cXFwic3RyaW5nXFxcIj09dHlwZW9mIHgmJihkPXgpLGQ9ZC5yZXBsYWNlKC88cHJlKD86W1xcXFx3XFxcXFddKj8pPig/OltcXFxcd1xcXFxXXSo/KTxcXFxcL3ByZT4vZyxmdW5jdGlvbihhKXtyZXR1cm4gYS5yZXBsYWNlKC88YnI+L2csXFxcIlxcXFxuXFxcIil9KX1mdW5jdGlvbiB6KCl7dmFyIGM9ZnVuY3Rpb24oYyxkKXtmb3IoO2QmJihkLm5vZGVUeXBlPT1Ob2RlLlRFWFRfTk9ERXx8IWIubm9kZS5pc0Jsb2NrKGQpKSYmIWIubm9kZS5pc0VsZW1lbnQoZCk7KWQmJmQubm9kZVR5cGUhPU5vZGUuVEVYVF9OT0RFJiZhKGMpLndyYXBJbm5lcihiLm5vZGUub3BlblRhZ1N0cmluZyhkKStiLm5vZGUuY2xvc2VUYWdTdHJpbmcoZCkpLGQ9ZC5wYXJlbnROb2RlO2QmJmMuaW5uZXJIVE1MPT1kLmlubmVySFRNTCYmKGMuaW5uZXJIVE1MPWQub3V0ZXJIVE1MKX0sZD1mdW5jdGlvbigpe3ZhciBjLGQ9bnVsbDtyZXR1cm4gYi53aW4uZ2V0U2VsZWN0aW9uPyhjPWIud2luLmdldFNlbGVjdGlvbigpLGMmJmMucmFuZ2VDb3VudCYmKGQ9Yy5nZXRSYW5nZUF0KDApLmNvbW1vbkFuY2VzdG9yQ29udGFpbmVyLGQubm9kZVR5cGUhPU5vZGUuRUxFTUVOVF9OT0RFJiYoZD1kLnBhcmVudE5vZGUpKSk6KGM9Yi5kb2Muc2VsZWN0aW9uKSYmXFxcIkNvbnRyb2xcXFwiIT1jLnR5cGUmJihkPWMuY3JlYXRlUmFuZ2UoKS5wYXJlbnRFbGVtZW50KCkpLG51bGwhPWQmJihhLmluQXJyYXkoYi4kZWwuZ2V0KDApLGEoZCkucGFyZW50cygpKT49MHx8ZD09Yi4kZWwuZ2V0KDApKT9kOm51bGx9LGU9XFxcIlxcXCI7aWYoXFxcInVuZGVmaW5lZFxcXCIhPXR5cGVvZiBiLndpbi5nZXRTZWxlY3Rpb24pe2IuYnJvd3Nlci5tb3ppbGxhJiYoYi5zZWxlY3Rpb24uc2F2ZSgpLGIuJGVsLmZpbmQoJy5mci1tYXJrZXJbZGF0YS10eXBlPVxcXCJmYWxzZVxcXCJdJykubGVuZ3RoPjEmJihiLiRlbC5maW5kKCcuZnItbWFya2VyW2RhdGEtdHlwZT1cXFwiZmFsc2VcXFwiXVtkYXRhLWlkPVxcXCIwXFxcIl0nKS5yZW1vdmUoKSxiLiRlbC5maW5kKCcuZnItbWFya2VyW2RhdGEtdHlwZT1cXFwiZmFsc2VcXFwiXTpsYXN0JykuYXR0cihcXFwiZGF0YS1pZFxcXCIsXFxcIjBcXFwiKSxiLiRlbC5maW5kKFxcXCIuZnItbWFya2VyXFxcIikubm90KCdbZGF0YS1pZD1cXFwiMFxcXCJdJykucmVtb3ZlKCkpLGIuc2VsZWN0aW9uLnJlc3RvcmUoKSk7Zm9yKHZhciBmPWIuc2VsZWN0aW9uLnJhbmdlcygpLGc9MDtnPGYubGVuZ3RoO2crKyl7dmFyIGg9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcXFwiZGl2XFxcIik7aC5hcHBlbmRDaGlsZChmW2ddLmNsb25lQ29udGVudHMoKSksYyhoLGQoKSksYShoKS5maW5kKFxcXCIuZnItZWxlbWVudFxcXCIpLmxlbmd0aD4wJiYoaD1iLiRlbC5nZXQoMCkpLGUrPWguaW5uZXJIVE1MfX1lbHNlXFxcInVuZGVmaW5lZFxcXCIhPXR5cGVvZiBiLmRvYy5zZWxlY3Rpb24mJlxcXCJUZXh0XFxcIj09Yi5kb2Muc2VsZWN0aW9uLnR5cGUmJihlPWIuZG9jLnNlbGVjdGlvbi5jcmVhdGVSYW5nZSgpLmh0bWxUZXh0KTtyZXR1cm4gZX1mdW5jdGlvbiBBKGIpe3ZhciBjPWEoXFxcIjxkaXY+XFxcIikuaHRtbChiKTtyZXR1cm4gYy5maW5kKGYoKSkubGVuZ3RoPjB9ZnVuY3Rpb24gQihhKXt2YXIgYz1iLmRvYy5jcmVhdGVFbGVtZW50KFxcXCJkaXZcXFwiKTtyZXR1cm4gYy5pbm5lckhUTUw9YSxiLnNlbGVjdGlvbi5zZXRBdEVuZChjKSxjLmlubmVySFRNTH1mdW5jdGlvbiBDKGEpe3JldHVybiBhLnJlcGxhY2UoLzwvZ2ksXFxcIiZsdDtcXFwiKS5yZXBsYWNlKC8+L2dpLFxcXCImZ3Q7XFxcIikucmVwbGFjZSgvXFxcIi9naSxcXFwiJnF1b3Q7XFxcIikucmVwbGFjZSgvJy9naSxcXFwiJiMzOTtcXFwiKX1mdW5jdGlvbiBEKGMsZCxlKXtiLnNlbGVjdGlvbi5pc0NvbGxhcHNlZCgpfHxiLnNlbGVjdGlvbi5yZW1vdmUoKTt2YXIgZjtpZihmPWQ/YzpiLmNsZWFuLmh0bWwoYyksZj1mLnJlcGxhY2UoL1xcXFxyfFxcXFxuL2csXFxcIiBcXFwiKSxjLmluZGV4T2YoJ2NsYXNzPVxcXCJmci1tYXJrZXJcXFwiJyk8MCYmKGY9QihmKSksXFxuYi5jb3JlLmlzRW1wdHkoKSliLiRlbC5odG1sKGYpO2Vsc2V7dmFyIGc9Yi5tYXJrZXJzLmluc2VydCgpO2lmKGcpe3ZhciBoO2lmKChBKGYpfHxlKSYmKGg9Yi5ub2RlLmRlZXBlc3RQYXJlbnQoZykpKXt2YXIgZz1iLm1hcmtlcnMuc3BsaXQoKTtpZighZylyZXR1cm4hMTthKGcpLnJlcGxhY2VXaXRoKGYpfWVsc2UgYShnKS5yZXBsYWNlV2l0aChmKX1lbHNlIGIuJGVsLmFwcGVuZChmKX1zKCksYi5ldmVudHMudHJpZ2dlcihcXFwiaHRtbC5pbnNlcnRlZFxcXCIpfWZ1bmN0aW9uIEUoYyl7dmFyIGQ9bnVsbDtcXFwidW5kZWZpbmVkXFxcIj09dHlwZW9mIGMmJihkPWIuc2VsZWN0aW9uLmVsZW1lbnQoKSk7dmFyIGUsZjtkb3tmPSExLGU9Yi4kZWwuZ2V0KDApLnF1ZXJ5U2VsZWN0b3JBbGwoXFxcIio6bm90KC5mci1tYXJrZXIpXFxcIik7Zm9yKHZhciBnPTA7ZzxlLmxlbmd0aDtnKyspe3ZhciBoPWVbZ107aWYoZCE9aCl7dmFyIGk9aC50ZXh0Q29udGVudDswPT09aC5jaGlsZHJlbi5sZW5ndGgmJjE9PT1pLmxlbmd0aCYmODIwMz09aS5jaGFyQ29kZUF0KDApJiYoYShoKS5yZW1vdmUoKSxmPSEwKX19fXdoaWxlKGYpfWZ1bmN0aW9uIEYoKXt2YXIgYT1mdW5jdGlvbigpe0UoKSxiLnBsYWNlaG9sZGVyJiZiLnBsYWNlaG9sZGVyLnJlZnJlc2goKX07Yi5ldmVudHMub24oXFxcIm1vdXNldXBcXFwiLGEpLGIuZXZlbnRzLm9uKFxcXCJrZXlkb3duXFxcIixhKSxiLmV2ZW50cy5vbihcXFwiY29udGVudENoYW5nZWRcXFwiLHQpfXJldHVybntkZWZhdWx0VGFnOmMsZW1wdHlCbG9ja3M6ZCxlbXB0eUJsb2NrVGFnc1F1ZXJ5OmUsYmxvY2tUYWdzUXVlcnk6ZixmaWxsRW1wdHlCbG9ja3M6ayxjbGVhbkVtcHR5VGFnczpnLGNsZWFuV2hpdGVUYWdzOkUsZG9Ob3JtYWxpemU6byxjbGVhbkJsYW5rU3BhY2VzOm0sYmxvY2tzOmwsZ2V0RG9jdHlwZTpyLHNldDp4LGdldDp5LGdldFNlbGVjdGVkOnosaW5zZXJ0OkQsd3JhcDppLHVud3JhcDpqLGVzY2FwZUVudGl0aWVzOkMsY2hlY2tJZkVtcHR5OnQsZXh0cmFjdE5vZGU6dSxleHRyYWN0Tm9kZUF0dHJzOnYsZXh0cmFjdERvY3R5cGU6dyxfaW5pdDpGfX0sYS5leHRlbmQoYS5GRS5ERUZBVUxUUyx7aGVpZ2h0Om51bGwsaGVpZ2h0TWF4Om51bGwsaGVpZ2h0TWluOm51bGwsd2lkdGg6bnVsbH0pLGEuRkUuTU9EVUxFUy5zaXplPWZ1bmN0aW9uKGEpe2Z1bmN0aW9uIGIoKXtjKCksYS5vcHRzLmhlaWdodCYmYS4kZWwuY3NzKFxcXCJtaW5IZWlnaHRcXFwiLGEub3B0cy5oZWlnaHQtYS5oZWxwZXJzLmdldFBYKGEuJGVsLmNzcyhcXFwicGFkZGluZy10b3BcXFwiKSktYS5oZWxwZXJzLmdldFBYKGEuJGVsLmNzcyhcXFwicGFkZGluZy1ib3R0b21cXFwiKSkpLGEuJGlmcmFtZS5oZWlnaHQoYS4kZWwub3V0ZXJIZWlnaHQoITApKX1mdW5jdGlvbiBjKCl7YS5vcHRzLmhlaWdodE1pbj9hLiRlbC5jc3MoXFxcIm1pbkhlaWdodFxcXCIsYS5vcHRzLmhlaWdodE1pbik6YS4kZWwuY3NzKFxcXCJtaW5IZWlnaHRcXFwiLFxcXCJcXFwiKSxhLm9wdHMuaGVpZ2h0TWF4PyhhLiR3cC5jc3MoXFxcIm1heEhlaWdodFxcXCIsYS5vcHRzLmhlaWdodE1heCksYS4kd3AuY3NzKFxcXCJvdmVyZmxvd1xcXCIsXFxcImF1dG9cXFwiKSk6KGEuJHdwLmNzcyhcXFwibWF4SGVpZ2h0XFxcIixcXFwiXFxcIiksYS4kd3AuY3NzKFxcXCJvdmVyZmxvd1xcXCIsXFxcIlxcXCIpKSxhLm9wdHMuaGVpZ2h0PyhhLiR3cC5oZWlnaHQoYS5vcHRzLmhlaWdodCksYS4kZWwuY3NzKFxcXCJtaW5IZWlnaHRcXFwiLGEub3B0cy5oZWlnaHQtYS5oZWxwZXJzLmdldFBYKGEuJGVsLmNzcyhcXFwicGFkZGluZy10b3BcXFwiKSktYS5oZWxwZXJzLmdldFBYKGEuJGVsLmNzcyhcXFwicGFkZGluZy1ib3R0b21cXFwiKSkpLGEuJHdwLmNzcyhcXFwib3ZlcmZsb3dcXFwiLFxcXCJhdXRvXFxcIikpOihhLiR3cC5jc3MoXFxcImhlaWdodFxcXCIsXFxcIlxcXCIpLGEub3B0cy5oZWlnaHRNaW58fGEuJGVsLmNzcyhcXFwibWluSGVpZ2h0XFxcIixcXFwiXFxcIiksYS5vcHRzLmhlaWdodE1heHx8YS4kd3AuY3NzKFxcXCJvdmVyZmxvd1xcXCIsXFxcIlxcXCIpKSxhLm9wdHMud2lkdGgmJmEuJGJveC53aWR0aChhLm9wdHMud2lkdGgpfWZ1bmN0aW9uIGQoKXtyZXR1cm4gYS4kd3A/KGMoKSx2b2lkKGEuJGlmcmFtZSYmKGEuZXZlbnRzLm9uKFxcXCJrZXl1cFxcXCIsYiksYS5ldmVudHMub24oXFxcImNvbW1hbmRzLmFmdGVyXFxcIixiKSxhLmV2ZW50cy5vbihcXFwiaHRtbC5zZXRcXFwiLGIpLGEuZXZlbnRzLm9uKFxcXCJpbml0XFxcIixiKSxhLmV2ZW50cy5vbihcXFwiaW5pdGlhbGl6ZWRcXFwiLGIpKSkpOiExfXJldHVybntfaW5pdDpkLHN5bmNJZnJhbWU6YixyZWZyZXNoOmN9fSxhLmV4dGVuZChhLkZFLkRFRkFVTFRTLHtsYW5ndWFnZTpudWxsfSksYS5GRS5MQU5HVUFHRT17fSxhLkZFLk1PRFVMRVMubGFuZ3VhZ2U9ZnVuY3Rpb24oYil7ZnVuY3Rpb24gYyhhKXtyZXR1cm4gZSYmZS50cmFuc2xhdGlvblthXT9lLnRyYW5zbGF0aW9uW2FdOmF9ZnVuY3Rpb24gZCgpe2EuRkUuTEFOR1VBR0UmJihlPWEuRkUuTEFOR1VBR0VbYi5vcHRzLmxhbmd1YWdlXSksZSYmZS5kaXJlY3Rpb24mJihiLm9wdHMuZGlyZWN0aW9uPWUuZGlyZWN0aW9uKX12YXIgZTtyZXR1cm57X2luaXQ6ZCx0cmFuc2xhdGU6Y319LGEuZXh0ZW5kKGEuRkUuREVGQVVMVFMse3BsYWNlaG9sZGVyVGV4dDpcXFwiVHlwZSBzb21ldGhpbmdcXFwifSksYS5GRS5NT0RVTEVTLnBsYWNlaG9sZGVyPWZ1bmN0aW9uKGIpe2Z1bmN0aW9uIGMoKXtiLiRwbGFjZWhvbGRlcnx8ZygpO3ZhciBjPTAsZD0wLGU9MCxmPTAsaD1iLm5vZGUuY29udGVudHMoYi4kZWwuZ2V0KDApKTtpZihoLmxlbmd0aCYmaFswXS5ub2RlVHlwZT09Tm9kZS5FTEVNRU5UX05PREUpe3ZhciBpPWEoaFswXSk7Yi5vcHRzLnRvb2xiYXJJbmxpbmV8fChjPWIuaGVscGVycy5nZXRQWChpLmNzcyhcXFwibWFyZ2luLXRvcFxcXCIpKSxlPWIuaGVscGVycy5nZXRQWChpLmNzcyhcXFwicGFkZGluZy10b3BcXFwiKSksZD1iLmhlbHBlcnMuZ2V0UFgoaS5jc3MoXFxcIm1hcmdpbi1sZWZ0XFxcIikpLGY9Yi5oZWxwZXJzLmdldFBYKGkuY3NzKFxcXCJwYWRkaW5nLWxlZnRcXFwiKSkpLGIuJHBsYWNlaG9sZGVyLmNzcyhcXFwiZm9udC1zaXplXFxcIixpLmNzcyhcXFwiZm9udC1zaXplXFxcIikpLGIuJHBsYWNlaG9sZGVyLmNzcyhcXFwibGluZS1oZWlnaHRcXFwiLGkuY3NzKFxcXCJsaW5lLWhlaWdodFxcXCIpKX1lbHNlIGIuJHBsYWNlaG9sZGVyLmNzcyhcXFwiZm9udC1zaXplXFxcIixiLiRlbC5jc3MoXFxcImZvbnQtc2l6ZVxcXCIpKSxiLiRwbGFjZWhvbGRlci5jc3MoXFxcImxpbmUtaGVpZ2h0XFxcIixiLiRlbC5jc3MoXFxcImxpbmUtaGVpZ2h0XFxcIikpO2IuJHdwLmFkZENsYXNzKFxcXCJzaG93LXBsYWNlaG9sZGVyXFxcIiksYi4kcGxhY2Vob2xkZXIuY3NzKHttYXJnaW5Ub3A6TWF0aC5tYXgoYi5oZWxwZXJzLmdldFBYKGIuJGVsLmNzcyhcXFwibWFyZ2luLXRvcFxcXCIpKSxjKSxwYWRkaW5nVG9wOk1hdGgubWF4KGIuaGVscGVycy5nZXRQWChiLiRlbC5jc3MoXFxcInBhZGRpbmctdG9wXFxcIikpLGUpLHBhZGRpbmdMZWZ0Ok1hdGgubWF4KGIuaGVscGVycy5nZXRQWChiLiRlbC5jc3MoXFxcInBhZGRpbmctbGVmdFxcXCIpKSxmKSxtYXJnaW5MZWZ0Ok1hdGgubWF4KGIuaGVscGVycy5nZXRQWChiLiRlbC5jc3MoXFxcIm1hcmdpbi1sZWZ0XFxcIikpLGQpfSkudGV4dChiLmxhbmd1YWdlLnRyYW5zbGF0ZShiLm9wdHMucGxhY2Vob2xkZXJUZXh0fHxiLiRvZWwuYXR0cihcXFwicGxhY2Vob2xkZXJcXFwiKXx8XFxcIlxcXCIpKSxiLiRwbGFjZWhvbGRlci5odG1sKGIuJHBsYWNlaG9sZGVyLnRleHQoKS5yZXBsYWNlKC9cXFxcbi9nLFxcXCI8YnI+XFxcIikpfWZ1bmN0aW9uIGQoKXtiLiR3cC5yZW1vdmVDbGFzcyhcXFwic2hvdy1wbGFjZWhvbGRlclxcXCIpfWZ1bmN0aW9uIGUoKXtyZXR1cm4gYi4kd3A/Yi4kd3AuaGFzQ2xhc3MoXFxcInNob3ctcGxhY2Vob2xkZXJcXFwiKTohMH1mdW5jdGlvbiBmKCl7cmV0dXJuIGIuJHdwP3ZvaWQoYi5jb3JlLmlzRW1wdHkoKT9jKCk6ZCgpKTohMX1mdW5jdGlvbiBnKCl7Yi4kcGxhY2Vob2xkZXI9YSgnPHNwYW4gY2xhc3M9XFxcImZyLXBsYWNlaG9sZGVyXFxcIj48L3NwYW4+JyksYi4kd3AuYXBwZW5kKGIuJHBsYWNlaG9sZGVyKX1mdW5jdGlvbiBoKCl7cmV0dXJuIGIuJHdwP3ZvaWQgYi5ldmVudHMub24oXFxcImluaXQgaW5wdXQga2V5ZG93biBrZXl1cCBjb250ZW50Q2hhbmdlZCBpbml0aWFsaXplZFxcXCIsZik6ITF9cmV0dXJue19pbml0Omgsc2hvdzpjLGhpZGU6ZCxyZWZyZXNoOmYsaXNWaXNpYmxlOmV9fSxhLkZFLk1PRFVMRVMuZWRpdD1mdW5jdGlvbihhKXtmdW5jdGlvbiBiKCl7aWYoYS5icm93c2VyLm1vemlsbGEpdHJ5e2EuZG9jLmV4ZWNDb21tYW5kKFxcXCJlbmFibGVPYmplY3RSZXNpemluZ1xcXCIsITEsXFxcImZhbHNlXFxcIiksYS5kb2MuZXhlY0NvbW1hbmQoXFxcImVuYWJsZUlubGluZVRhYmxlRWRpdGluZ1xcXCIsITEsXFxcImZhbHNlXFxcIil9Y2F0Y2goYil7fWlmKGEuYnJvd3Nlci5tc2llKXRyeXthLmRvYy5ib2R5LmFkZEV2ZW50TGlzdGVuZXIoXFxcIm1zY29udHJvbHNlbGVjdFxcXCIsZnVuY3Rpb24oYSl7cmV0dXJuIGEucHJldmVudERlZmF1bHQoKSwhMX0pfWNhdGNoKGIpe319ZnVuY3Rpb24gYygpe2EuJHdwPyhhLiRlbC5hdHRyKFxcXCJjb250ZW50ZWRpdGFibGVcXFwiLCEwKSxhLiRlbC5yZW1vdmVDbGFzcyhcXFwiZnItZGlzYWJsZWRcXFwiKSxhLiR0YiYmYS4kdGIucmVtb3ZlQ2xhc3MoXFxcImZyLWRpc2FibGVkXFxcIiksYigpKTphLiRlbC5pcyhcXFwiYVxcXCIpJiZhLiRlbC5hdHRyKFxcXCJjb250ZW50ZWRpdGFibGVcXFwiLCEwKSxmPSExfWZ1bmN0aW9uIGQoKXthLiR3cD8oYS4kZWwuYXR0cihcXFwiY29udGVudGVkaXRhYmxlXFxcIiwhMSksYS4kZWwuYWRkQ2xhc3MoXFxcImZyLWRpc2FibGVkXFxcIiksYS4kdGImJmEuJHRiLmFkZENsYXNzKFxcXCJmci1kaXNhYmxlZFxcXCIpKTphLiRlbC5pcyhcXFwiYVxcXCIpJiZhLiRlbC5hdHRyKFxcXCJjb250ZW50ZWRpdGFibGVcXFwiLCExKSxmPSEwfWZ1bmN0aW9uIGUoKXtyZXR1cm4gZn12YXIgZj0hMTtyZXR1cm57b246YyxvZmY6ZCxkaXNhYmxlRGVzaWduOmIsaXNEaXNhYmxlZDplfX0sYS5leHRlbmQoYS5GRS5ERUZBVUxUUyx7ZWRpdG9yQ2xhc3M6bnVsbCx0eXBpbmdUaW1lcjo1MDAsaWZyYW1lOiExLHJlcXVlc3RXaXRoQ09SUzohMCxyZXF1ZXN0V2l0aENyZWRlbnRpYWxzOiExLHJlcXVlc3RIZWFkZXJzOnt9LHVzZUNsYXNzZXM6ITAsc3BlbGxjaGVjazohMCxpZnJhbWVTdHlsZTonaHRtbHttYXJnaW46MHB4O2hlaWdodDphdXRvO31ib2R5e2hlaWdodDphdXRvO3BhZGRpbmc6MTBweDtiYWNrZ3JvdW5kOnRyYW5zcGFyZW50O2NvbG9yOiMwMDAwMDA7cG9zaXRpb246cmVsYXRpdmU7ei1pbmRleDogMjstd2Via2l0LXVzZXItc2VsZWN0OmF1dG87bWFyZ2luOjBweDtvdmVyZmxvdzpoaWRkZW47bWluLWhlaWdodDoyMHB4O31ib2R5OmFmdGVye2NvbnRlbnQ6XFxcIlxcXCI7ZGlzcGxheTpibG9jaztjbGVhcjpib3RoO30nLGlmcmFtZVN0eWxlRmlsZXM6W10sZGlyZWN0aW9uOlxcXCJhdXRvXFxcIix6SW5kZXg6MSxkaXNhYmxlUmlnaHRDbGljazohMSxzY3JvbGxhYmxlQ29udGFpbmVyOlxcXCJib2R5XFxcIixrZWVwRm9ybWF0T25EZWxldGU6ITEsdGhlbWU6bnVsbH0pLGEuRkUuTU9EVUxFUy5jb3JlPWZ1bmN0aW9uKGIpe2Z1bmN0aW9uIGMoYyl7aWYoYi5vcHRzLmlmcmFtZSl7Yi4kaGVhZC5maW5kKFxcXCJzdHlsZVtkYXRhLWZyLXN0eWxlXSwgbGlua1tkYXRhLWZyLXN0eWxlXVxcXCIpLnJlbW92ZSgpLGIuJGhlYWQuYXBwZW5kKCc8c3R5bGUgZGF0YS1mci1zdHlsZT1cXFwidHJ1ZVxcXCI+JytjK1xcXCI8L3N0eWxlPlxcXCIpO2Zvcih2YXIgZD0wO2Q8Yi5vcHRzLmlmcmFtZVN0eWxlRmlsZXMubGVuZ3RoO2QrKyl7dmFyIGU9YSgnPGxpbmsgZGF0YS1mci1zdHlsZT1cXFwidHJ1ZVxcXCIgcmVsPVxcXCJzdHlsZXNoZWV0XFxcIiBocmVmPVxcXCInK2Iub3B0cy5pZnJhbWVTdHlsZUZpbGVzW2RdKydcXFwiPicpO2UuZ2V0KDApLmFkZEV2ZW50TGlzdGVuZXIoXFxcImxvYWRcXFwiLGIuc2l6ZS5zeW5jSWZyYW1lKSxiLiRoZWFkLmFwcGVuZChlKX19fWZ1bmN0aW9uIGQoKXtiLm9wdHMuaWZyYW1lfHxiLiRlbC5hZGRDbGFzcyhcXFwiZnItZWxlbWVudCBmci12aWV3XFxcIil9ZnVuY3Rpb24gZSgpe2lmKGIuJGJveC5hZGRDbGFzcyhcXFwiZnItYm94XFxcIisoYi5vcHRzLmVkaXRvckNsYXNzP1xcXCIgXFxcIitiLm9wdHMuZWRpdG9yQ2xhc3M6XFxcIlxcXCIpKSxiLiR3cC5hZGRDbGFzcyhcXFwiZnItd3JhcHBlclxcXCIpLGQoKSxiLm9wdHMuaWZyYW1lKXtiLiRpZnJhbWUuYWRkQ2xhc3MoXFxcImZyLWlmcmFtZVxcXCIpLGIuJGVsLmFkZENsYXNzKFxcXCJmci12aWV3XFxcIik7Zm9yKHZhciBhPTA7YTxiLm9fZG9jLnN0eWxlU2hlZXRzLmxlbmd0aDthKyspe3ZhciBjO3RyeXtjPWIub19kb2Muc3R5bGVTaGVldHNbYV0uY3NzUnVsZXN9Y2F0Y2goZSl7fWlmKGMpZm9yKHZhciBmPTAsZz1jLmxlbmd0aDtnPmY7ZisrKSFjW2ZdLnNlbGVjdG9yVGV4dHx8MCE9PWNbZl0uc2VsZWN0b3JUZXh0LmluZGV4T2YoXFxcIi5mci12aWV3XFxcIikmJjAhPT1jW2ZdLnNlbGVjdG9yVGV4dC5pbmRleE9mKFxcXCIuZnItZWxlbWVudFxcXCIpfHxjW2ZdLnN0eWxlLmNzc1RleHQubGVuZ3RoPjAmJigwPT09Y1tmXS5zZWxlY3RvclRleHQuaW5kZXhPZihcXFwiLmZyLXZpZXdcXFwiKT9iLm9wdHMuaWZyYW1lU3R5bGUrPWNbZl0uc2VsZWN0b3JUZXh0LnJlcGxhY2UoL1xcXFwuZnItdmlldy9nLFxcXCJib2R5XFxcIikrXFxcIntcXFwiK2NbZl0uc3R5bGUuY3NzVGV4dCtcXFwifVxcXCI6Yi5vcHRzLmlmcmFtZVN0eWxlKz1jW2ZdLnNlbGVjdG9yVGV4dC5yZXBsYWNlKC9cXFxcLmZyLWVsZW1lbnQvZyxcXFwiYm9keVxcXCIpK1xcXCJ7XFxcIitjW2ZdLnN0eWxlLmNzc1RleHQrXFxcIn1cXFwiKX19XFxcImF1dG9cXFwiIT1iLm9wdHMuZGlyZWN0aW9uJiZiLiRib3gucmVtb3ZlQ2xhc3MoXFxcImZyLWx0ciBmci1ydGxcXFwiKS5hZGRDbGFzcyhcXFwiZnItXFxcIitiLm9wdHMuZGlyZWN0aW9uKSxiLiRlbC5hdHRyKFxcXCJkaXJcXFwiLGIub3B0cy5kaXJlY3Rpb24pLGIuJHdwLmF0dHIoXFxcImRpclxcXCIsYi5vcHRzLmRpcmVjdGlvbiksYi5vcHRzLnpJbmRleD4xJiZiLiRib3guY3NzKFxcXCJ6LWluZGV4XFxcIixiLm9wdHMuekluZGV4KSxiLm9wdHMudGhlbWUmJmIuJGJveC5hZGRDbGFzcyhiLm9wdHMudGhlbWUrXFxcIi10aGVtZVxcXCIpfWZ1bmN0aW9uIGYoKXtyZXR1cm4gYi5ub2RlLmlzRW1wdHkoYi4kZWwuZ2V0KDApKX1mdW5jdGlvbiBnKCl7Yi5kcmFnX3N1cHBvcnQ9e2ZpbGVyZWFkZXI6XFxcInVuZGVmaW5lZFxcXCIhPXR5cGVvZiBGaWxlUmVhZGVyLGZvcm1kYXRhOiEhYi53aW4uRm9ybURhdGEscHJvZ3Jlc3M6XFxcInVwbG9hZFxcXCJpbiBuZXcgWE1MSHR0cFJlcXVlc3R9fWZ1bmN0aW9uIGgoYSxjKXt2YXIgZD1uZXcgWE1MSHR0cFJlcXVlc3Q7ZC5vcGVuKGMsYSwhMCksYi5vcHRzLnJlcXVlc3RXaXRoQ3JlZGVudGlhbHMmJihkLndpdGhDcmVkZW50aWFscz0hMCk7Zm9yKHZhciBlIGluIGIub3B0cy5yZXF1ZXN0SGVhZGVycyliLm9wdHMucmVxdWVzdEhlYWRlcnMuaGFzT3duUHJvcGVydHkoZSkmJmQuc2V0UmVxdWVzdEhlYWRlcihlLGIub3B0cy5yZXF1ZXN0SGVhZGVyc1tlXSk7cmV0dXJuIGR9ZnVuY3Rpb24gaShhKXtcXFwiVEVYVEFSRUFcXFwiPT1iLiRvZWwuZ2V0KDApLnRhZ05hbWUmJmIuJG9lbC52YWwoYSksYi4kd3AmJihcXFwiVEVYVEFSRUFcXFwiPT1iLiRvZWwuZ2V0KDApLnRhZ05hbWU/KGIuJGVsLmh0bWwoXFxcIlxcXCIpLGIuJHdwLmh0bWwoXFxcIlxcXCIpLGIuJGJveC5yZXBsYWNlV2l0aChiLiRvZWwpLGIuJG9lbC5zaG93KCkpOihiLiR3cC5yZXBsYWNlV2l0aChhKSxiLiRlbC5odG1sKFxcXCJcXFwiKSxiLiRib3gucmVtb3ZlQ2xhc3MoXFxcImZyLXZpZXcgZnItbHRyIGZyLWJveCBcXFwiKyhiLm9wdHMuZWRpdG9yQ2xhc3N8fFxcXCJcXFwiKSksYi5vcHRzLnRoZW1lJiZiLiRib3guYWRkQ2xhc3MoYi5vcHRzLnRoZW1lK1xcXCItdGhlbWVcXFwiKSkpLHRoaXMuJHdwPW51bGwsdGhpcy4kZWw9bnVsbCx0aGlzLiRib3g9bnVsbH1mdW5jdGlvbiBqKCl7cmV0dXJuIGIuYnJvd3Nlci5tb3ppbGxhJiZiLmhlbHBlcnMuaXNNb2JpbGUoKT9iLnNlbGVjdGlvbi5pbkVkaXRvcigpOmIubm9kZS5oYXNGb2N1cyhiLiRlbC5nZXQoMCkpfHxiLiRlbC5maW5kKFxcXCIqOmZvY3VzXFxcIikubGVuZ3RoPjB9ZnVuY3Rpb24gayhhKXtpZighYSlyZXR1cm4hMTt2YXIgYz1hLmRhdGEoXFxcImluc3RhbmNlXFxcIik7cmV0dXJuIGM/Yy5pZD09Yi5pZDohMX1mdW5jdGlvbiBsKCl7aWYoYS5GRS5JTlNUQU5DRVMucHVzaChiKSxnKCksYi4kd3Ape2UoKSxiLmh0bWwuc2V0KGIuX29yaWdpbmFsX2h0bWwpLGIuJGVsLmF0dHIoXFxcInNwZWxsY2hlY2tcXFwiLGIub3B0cy5zcGVsbGNoZWNrKSxiLmhlbHBlcnMuaXNNb2JpbGUoKSYmKGIuJGVsLmF0dHIoXFxcImF1dG9jb21wbGV0ZVxcXCIsYi5vcHRzLnNwZWxsY2hlY2s/XFxcIm9uXFxcIjpcXFwib2ZmXFxcIiksYi4kZWwuYXR0cihcXFwiYXV0b2NvcnJlY3RcXFwiLGIub3B0cy5zcGVsbGNoZWNrP1xcXCJvblxcXCI6XFxcIm9mZlxcXCIpLGIuJGVsLmF0dHIoXFxcImF1dG9jYXBpdGFsaXplXFxcIixiLm9wdHMuc3BlbGxjaGVjaz9cXFwib25cXFwiOlxcXCJvZmZcXFwiKSksYi5vcHRzLmRpc2FibGVSaWdodENsaWNrJiZiLmV2ZW50cy4kb24oYi4kZWwsXFxcImNvbnRleHRtZW51XFxcIixmdW5jdGlvbihhKXtyZXR1cm4gMj09YS5idXR0b24/ITE6dm9pZCAwfSk7dHJ5e2IuZG9jLmV4ZWNDb21tYW5kKFxcXCJzdHlsZVdpdGhDU1NcXFwiLCExLCExKX1jYXRjaChjKXt9fWIuZXZlbnRzLm9uKFxcXCJkcm9wXFxcIixmdW5jdGlvbihhKXthLnByZXZlbnREZWZhdWx0KCksYS5zdG9wUHJvcGFnYXRpb24oKX0pLFxcXCJURVhUQVJFQVxcXCI9PWIuJG9lbC5nZXQoMCkudGFnTmFtZSYmKGIuZXZlbnRzLm9uKFxcXCJjb250ZW50Q2hhbmdlZFxcXCIsZnVuY3Rpb24oKXtiLiRvZWwudmFsKGIuaHRtbC5nZXQoKSl9KSxiLmV2ZW50cy5vbihcXFwiZm9ybS5zdWJtaXRcXFwiLGZ1bmN0aW9uKCl7Yi4kb2VsLnZhbChiLmh0bWwuZ2V0KCkpfSksYi5ldmVudHMub24oXFxcImZvcm0ucmVzZXRcXFwiLGZ1bmN0aW9uKCl7Yi5odG1sLnNldChiLl9vcmlnaW5hbF9odG1sKX0pLGIuJG9lbC52YWwoYi5odG1sLmdldCgpKSksYi5oZWxwZXJzLmlzSU9TKCkmJmIuZXZlbnRzLiRvbihiLiRkb2MsXFxcInNlbGVjdGlvbmNoYW5nZVxcXCIsZnVuY3Rpb24oKXtiLiRkb2MuZ2V0KDApLmhhc0ZvY3VzKCl8fGIuJHdpbi5nZXQoMCkuZm9jdXMoKX0pLGIuZXZlbnRzLnRyaWdnZXIoXFxcImluaXRcXFwiKX1yZXR1cm57X2luaXQ6bCxkZXN0cm95OmksaXNFbXB0eTpmLGdldFhIUjpoLGluamVjdFN0eWxlOmMsaGFzRm9jdXM6aixzYW1lSW5zdGFuY2U6a319LGEuRkUuTU9EVUxFUy5mb3JtYXQ9ZnVuY3Rpb24oYil7ZnVuY3Rpb24gYyhhLGIpe3ZhciBjPVxcXCI8XFxcIithO2Zvcih2YXIgZCBpbiBiKWIuaGFzT3duUHJvcGVydHkoZCkmJihjKz1cXFwiIFxcXCIrZCsnPVxcXCInK2JbZF0rJ1xcXCInKTtyZXR1cm4gYys9XFxcIj5cXFwifWZ1bmN0aW9uIGQoYSl7cmV0dXJuXFxcIjwvXFxcIithK1xcXCI+XFxcIn1mdW5jdGlvbiBlKGEsYil7dmFyIGM9YTtmb3IodmFyIGQgaW4gYiliLmhhc093blByb3BlcnR5KGQpJiYoYSs9XFxcImlkXFxcIj09ZD9cXFwiI1xcXCIrYltkXTpcXFwiY2xhc3NcXFwiPT1kP1xcXCIuXFxcIitiW2RdOlxcXCJbXFxcIitkKyc9XFxcIicrYltkXSsnXFxcIl0nKTtyZXR1cm4gY31mdW5jdGlvbiBmKGEsYil7cmV0dXJuIGEmJmEubm9kZVR5cGU9PU5vZGUuRUxFTUVOVF9OT0RFPyhhLm1hdGNoZXN8fGEubWF0Y2hlc1NlbGVjdG9yfHxhLm1zTWF0Y2hlc1NlbGVjdG9yfHxhLm1vek1hdGNoZXNTZWxlY3Rvcnx8YS53ZWJraXRNYXRjaGVzU2VsZWN0b3J8fGEub01hdGNoZXNTZWxlY3RvcikuY2FsbChhLGIpOiExfWZ1bmN0aW9uIGcoZCxlLGYpe2lmKGQpe2lmKGIubm9kZS5pc0Jsb2NrKGQpKXJldHVybiBnKGQuZmlyc3RDaGlsZCxlLGYpLCExO2Zvcih2YXIgaD1hKGMoZSxmKSkuaW5zZXJ0QmVmb3JlKGQpLGk9ZDtpJiYhYShpKS5pcyhcXFwiLmZyLW1hcmtlclxcXCIpJiYwPT1hKGkpLmZpbmQoXFxcIi5mci1tYXJrZXJcXFwiKS5sZW5ndGg7KXt2YXIgaj1pO2k9aS5uZXh0U2libGluZyxoLmFwcGVuZChqKX1pZihpKWEoaSkuZmluZChcXFwiLmZyLW1hcmtlclxcXCIpLmxlbmd0aCYmZyhpLmZpcnN0Q2hpbGQsZSxmKTtlbHNle2Zvcih2YXIgaz1oLmdldCgwKS5wYXJlbnROb2RlO2smJiFrLm5leHRTaWJsaW5nJiYhYi5ub2RlLmlzRWxlbWVudChrKTspaz1rLnBhcmVudE5vZGU7aWYoayl7dmFyIGw9ay5uZXh0U2libGluZztsJiYoYi5ub2RlLmlzQmxvY2sobCk/ZyhsLmZpcnN0Q2hpbGQsZSxmKTpnKGwsZSxmKSl9fWguaXMoXFxcIjplbXB0eVxcXCIpJiZoLnJlbW92ZSgpfX1mdW5jdGlvbiBoKGgsaSl7aWYoXFxcInVuZGVmaW5lZFxcXCI9PXR5cGVvZiBpJiYoaT17fSksaS5zdHlsZSYmZGVsZXRlIGkuc3R5bGUsYi5zZWxlY3Rpb24uaXNDb2xsYXBzZWQoKSl7Yi5tYXJrZXJzLmluc2VydCgpO3ZhciBqPWIuJGVsLmZpbmQoXFxcIi5mci1tYXJrZXJcXFwiKTtqLnJlcGxhY2VXaXRoKGMoaCxpKSthLkZFLklOVklTSUJMRV9TUEFDRSthLkZFLk1BUktFUlMrZChoKSksYi5zZWxlY3Rpb24ucmVzdG9yZSgpfWVsc2V7Yi5zZWxlY3Rpb24uc2F2ZSgpO3ZhciBrPWIuJGVsLmZpbmQoJy5mci1tYXJrZXJbZGF0YS10eXBlPVxcXCJ0cnVlXFxcIl0nKS5nZXQoMCkubmV4dFNpYmxpbmc7ZyhrLGgsaSk7dmFyIGw7ZG8gbD1iLiRlbC5maW5kKGUoaCxpKStcXFwiID4gXFxcIitlKGgsaSkpLGwuZWFjaChmdW5jdGlvbigpe2EodGhpcykucmVwbGFjZVdpdGgodGhpcy5pbm5lckhUTUwpfSk7d2hpbGUobC5sZW5ndGgpO2IuJGVsLmdldCgwKS5ub3JtYWxpemUoKTtmb3IodmFyIG09Yi4kZWwuZ2V0KDApLnF1ZXJ5U2VsZWN0b3JBbGwoXFxcIi5mci1tYXJrZXJcXFwiKSxuPTA7bjxtLmxlbmd0aDtuKyspe3ZhciBvPWEobVtuXSk7MT09by5kYXRhKFxcXCJ0eXBlXFxcIik/ZihvLmdldCgwKS5uZXh0U2libGluZyxlKGgsaSkpJiZvLm5leHQoKS5wcmVwZW5kKG8pOmYoby5nZXQoMCkucHJldmlvdXNTaWJsaW5nLGUoaCxpKSkmJm8ucHJldigpLmFwcGVuZChvKX1iLnNlbGVjdGlvbi5yZXN0b3JlKCl9fWZ1bmN0aW9uIGkoYSxjLGQsZyl7aWYoIWcpe3ZhciBoPSExO2lmKGEuZGF0YShcXFwidHlwZVxcXCIpPT09ITApZm9yKDtiLm5vZGUuaXNGaXJzdFNpYmxpbmcoYS5nZXQoMCkpJiYhYS5wYXJlbnQoKS5pcyhiLiRlbCk7KWEucGFyZW50KCkuYmVmb3JlKGEpLGg9ITA7ZWxzZSBpZihhLmRhdGEoXFxcInR5cGVcXFwiKT09PSExKWZvcig7Yi5ub2RlLmlzTGFzdFNpYmxpbmcoYS5nZXQoMCkpJiYhYS5wYXJlbnQoKS5pcyhiLiRlbCk7KWEucGFyZW50KCkuYWZ0ZXIoYSksaD0hMDtpZihoKXJldHVybiEwfWlmKGEucGFyZW50cyhjKS5sZW5ndGh8fFxcXCJ1bmRlZmluZWRcXFwiPT10eXBlb2YgYyl7dmFyIGk9XFxcIlxcXCIsaj1cXFwiXFxcIixrPWEucGFyZW50KCk7aWYoay5pcyhiLiRlbCl8fGIubm9kZS5pc0Jsb2NrKGsuZ2V0KDApKSlyZXR1cm4hMTtmb3IoO1xcXCJ1bmRlZmluZWRcXFwiPT10eXBlb2YgYyYmIWIubm9kZS5pc0Jsb2NrKGsucGFyZW50KCkuZ2V0KDApKXx8XFxcInVuZGVmaW5lZFxcXCIhPXR5cGVvZiBjJiYhZihrLmdldCgwKSxlKGMsZCkpOylpKz1iLm5vZGUuY2xvc2VUYWdTdHJpbmcoay5nZXQoMCkpLGo9Yi5ub2RlLm9wZW5UYWdTdHJpbmcoay5nZXQoMCkpK2osaz1rLnBhcmVudCgpO3ZhciBsPWEuZ2V0KDApLm91dGVySFRNTDthLnJlcGxhY2VXaXRoKCc8c3BhbiBpZD1cXFwibWFya1xcXCI+PC9zcGFuPicpO3ZhciBtPWsuaHRtbCgpLnJlcGxhY2UoLzxzcGFuIGlkPVxcXCJtYXJrXFxcIj48XFxcXC9zcGFuPi8saStiLm5vZGUuY2xvc2VUYWdTdHJpbmcoay5nZXQoMCkpK2orbCtpK2Iubm9kZS5vcGVuVGFnU3RyaW5nKGsuZ2V0KDApKStqKTtyZXR1cm4gay5yZXBsYWNlV2l0aChiLm5vZGUub3BlblRhZ1N0cmluZyhrLmdldCgwKSkrbStiLm5vZGUuY2xvc2VUYWdTdHJpbmcoay5nZXQoMCkpKSwhMH1yZXR1cm4hMX1mdW5jdGlvbiBqKGMsZCxnLGgpe2Zvcih2YXIgaT1iLm5vZGUuY29udGVudHMoYy5nZXQoMCkpLGs9MDtrPGkubGVuZ3RoO2srKyl7dmFyIGw9aVtrXTthKGwpLmhhc0NsYXNzKFxcXCJmci1tYXJrZXJcXFwiKT9kPShkKzEpJTI6ZD9hKGwpLmZpbmQoXFxcIi5mci1tYXJrZXJcXFwiKS5sZW5ndGg+MD9kPWooYShsKSxkLGcsaCk6KGEoYShsKS5maW5kKGd8fFxcXCIqXFxcIikuZ2V0KCkucmV2ZXJzZSgpKS5lYWNoKGZ1bmN0aW9uKCl7Yi5ub2RlLmlzQmxvY2sodGhpcyl8fGIubm9kZS5pc1ZvaWQodGhpcyl8fGEodGhpcykucmVwbGFjZVdpdGgodGhpcy5pbm5lckhUTUwpfSksKFxcXCJ1bmRlZmluZWRcXFwiPT10eXBlb2YgZyYmbC5ub2RlVHlwZT09Tm9kZS5FTEVNRU5UX05PREUmJiFiLm5vZGUuaXNWb2lkKGwpJiYhYi5ub2RlLmlzQmxvY2sobCl8fGYobCxlKGcsaCkpKSYmYShsKS5yZXBsYWNlV2l0aChsLmlubmVySFRNTCkpOmEobCkuZmluZChcXFwiLmZyLW1hcmtlclxcXCIpLmxlbmd0aD4wJiYoZD1qKGEobCksZCxnLGgpKX1yZXR1cm4gZH1mdW5jdGlvbiBrKGMsZCl7XFxcInVuZGVmaW5lZFxcXCI9PXR5cGVvZiBkJiYoZD17fSksZC5zdHlsZSYmZGVsZXRlIGQuc3R5bGU7dmFyIGU9Yi5zZWxlY3Rpb24uaXNDb2xsYXBzZWQoKTtiLnNlbGVjdGlvbi5zYXZlKCk7Zm9yKHZhciBmPSEwO2Y7KXtmPSExO2Zvcih2YXIgZz1iLiRlbC5maW5kKFxcXCIuZnItbWFya2VyXFxcIiksaD0wO2g8Zy5sZW5ndGg7aCsrKWlmKGkoYShnW2hdKSxjLGQsZSkpe2Y9ITA7YnJlYWt9fWooYi4kZWwsMCxjLGQpLGUmJmIuJGVsLmZpbmQoXFxcIi5mci1tYXJrZXJcXFwiKS5iZWZvcmUoYS5GRS5JTlZJU0lCTEVfU1BBQ0UpLmFmdGVyKGEuRkUuSU5WSVNJQkxFX1NQQUNFKSxiLmh0bWwuY2xlYW5FbXB0eVRhZ3MoKSxiLiRlbC5nZXQoMCkubm9ybWFsaXplKCksYi5zZWxlY3Rpb24ucmVzdG9yZSgpfWZ1bmN0aW9uIGwoYSxiKXtxKGEsYik/ayhhLGIpOmgoYSxiKX1mdW5jdGlvbiBtKGIsYyl7dmFyIGQ9YShiKTtkLmNzcyhjLFxcXCJcXFwiKSxcXFwiXFxcIj09PWQuYXR0cihcXFwic3R5bGVcXFwiKSYmZC5yZXBsYWNlV2l0aChkLmh0bWwoKSl9ZnVuY3Rpb24gbihiLGMpe3JldHVybiAwPT09YShiKS5hdHRyKFxcXCJzdHlsZVxcXCIpLmluZGV4T2YoYytcXFwiOlxcXCIpfHxhKGIpLmF0dHIoXFxcInN0eWxlXFxcIikuaW5kZXhPZihcXFwiO1xcXCIrYytcXFwiOlxcXCIpPj0wfHxhKGIpLmF0dHIoXFxcInN0eWxlXFxcIikuaW5kZXhPZihcXFwiOyBcXFwiK2MrXFxcIjpcXFwiKT49MH1mdW5jdGlvbiBvKGMsZCl7aWYoYi5zZWxlY3Rpb24uaXNDb2xsYXBzZWQoKSl7Yi5tYXJrZXJzLmluc2VydCgpO3ZhciBlPWIuJGVsLmZpbmQoXFxcIi5mci1tYXJrZXJcXFwiKSxmPWUucGFyZW50KCk7aWYoYi5ub2RlLm9wZW5UYWdTdHJpbmcoZi5nZXQoMCkpPT0nPHNwYW4gc3R5bGU9XFxcIicrYytcXFwiOiBcXFwiK2YuY3NzKGMpKyc7XFxcIj4nKWlmKGIubm9kZS5pc0VtcHR5KGYuZ2V0KDApKSlmLnJlcGxhY2VXaXRoKCc8c3BhbiBzdHlsZT1cXFwiJytjK1xcXCI6IFxcXCIrZCsnO1xcXCI+JythLkZFLklOVklTSUJMRV9TUEFDRSthLkZFLk1BUktFUlMrXFxcIjwvc3Bhbj5cXFwiKTtlbHNle3ZhciBoPXt9O2hbY109ZCxpKGUsXFxcInNwYW5cXFwiLGgsITApLGU9Yi4kZWwuZmluZChcXFwiLmZyLW1hcmtlclxcXCIpLGUucmVwbGFjZVdpdGgoJzxzcGFuIHN0eWxlPVxcXCInK2MrXFxcIjogXFxcIitkKyc7XFxcIj4nK2EuRkUuSU5WSVNJQkxFX1NQQUNFK2EuRkUuTUFSS0VSUytcXFwiPC9zcGFuPlxcXCIpfWVsc2UgYi5ub2RlLmlzRW1wdHkoZi5nZXQoMCkpJiZmLmlzKFxcXCJzcGFuXFxcIik/KGUucmVwbGFjZVdpdGgoYS5GRS5NQVJLRVJTKSxmLmNzcyhjLGQpKTplLnJlcGxhY2VXaXRoKCc8c3BhbiBzdHlsZT1cXFwiJytjK1xcXCI6IFxcXCIrZCsnO1xcXCI+JythLkZFLklOVklTSUJMRV9TUEFDRSthLkZFLk1BUktFUlMrXFxcIjwvc3Bhbj5cXFwiKTtiLnNlbGVjdGlvbi5yZXN0b3JlKCl9ZWxzZXtiLnNlbGVjdGlvbi5zYXZlKCk7Zm9yKHZhciBqPWIuJGVsLmZpbmQoXFxcIi5mci1tYXJrZXJcXFwiKSxrPTA7azxqLmxlbmd0aDtrKyspe3ZhciBlPWEoaltrXSk7aWYoZS5kYXRhKFxcXCJ0eXBlXFxcIik9PT0hMClmb3IoO2Iubm9kZS5pc0ZpcnN0U2libGluZyhlLmdldCgwKSkmJiFlLnBhcmVudCgpLmlzKGIuJGVsKTspZS5wYXJlbnQoKS5iZWZvcmUoZSk7ZWxzZSBmb3IoO2Iubm9kZS5pc0xhc3RTaWJsaW5nKGUuZ2V0KDApKSYmIWUucGFyZW50KCkuaXMoYi4kZWwpOyllLnBhcmVudCgpLmFmdGVyKGUpfXZhciBsPWIuJGVsLmZpbmQoJy5mci1tYXJrZXJbZGF0YS10eXBlPVxcXCJ0cnVlXFxcIl0nKS5nZXQoMCkubmV4dFNpYmxpbmcsbz17XFxcImNsYXNzXFxcIjpcXFwiZnItdW5wcm9jZXNzZWRcXFwifTtmb3IoZCYmKG8uc3R5bGU9YytcXFwiOiBcXFwiK2QrXFxcIjtcXFwiKSxnKGwsXFxcInNwYW5cXFwiLG8pLGIuJGVsLmZpbmQoXFxcIi5mci1tYXJrZXIgKyAuZnItdW5wcm9jZXNzZWRcXFwiKS5lYWNoKGZ1bmN0aW9uKCl7YSh0aGlzKS5wcmVwZW5kKGEodGhpcykucHJldigpKX0pLGIuJGVsLmZpbmQoXFxcIi5mci11bnByb2Nlc3NlZCArIC5mci1tYXJrZXJcXFwiKS5lYWNoKGZ1bmN0aW9uKCl7YSh0aGlzKS5wcmV2KCkuYXBwZW5kKHRoaXMpfSk7Yi4kZWwuZmluZChcXFwic3Bhbi5mci11bnByb2Nlc3NlZFxcXCIpLmxlbmd0aD4wOyl7dmFyIHA9Yi4kZWwuZmluZChcXFwic3Bhbi5mci11bnByb2Nlc3NlZDpmaXJzdFxcXCIpLnJlbW92ZUNsYXNzKFxcXCJmci11bnByb2Nlc3NlZFxcXCIpO2lmKHAucGFyZW50KCkuZ2V0KDApLm5vcm1hbGl6ZSgpLHAucGFyZW50KCkuaXMoXFxcInNwYW5cXFwiKSYmMT09cC5wYXJlbnQoKS5nZXQoMCkuY2hpbGROb2Rlcy5sZW5ndGgpe3AucGFyZW50KCkuY3NzKGMsZCk7dmFyIHE9cDtwPXAucGFyZW50KCkscS5yZXBsYWNlV2l0aChxLmh0bWwoKSl9Zm9yKHZhciByPXAuZmluZChcXFwic3BhblxcXCIpLGs9ci5sZW5ndGgtMTtrPj0wO2stLSltKHJba10sYyk7dmFyIHM9cC5wYXJlbnRzVW50aWwoYi4kZWwsXFxcInNwYW5bc3R5bGVdXFxcIikuZmlsdGVyKGZ1bmN0aW9uKCl7cmV0dXJuIG4odGhpcyxjKX0pO2lmKHMubGVuZ3RoKXt2YXIgdD1cXFwiXFxcIix1PVxcXCJcXFwiLHY9XFxcIlxcXCIsdz1cXFwiXFxcIix4PXAuZ2V0KDApO2RvIHg9eC5wYXJlbnROb2RlLGEoeCkuYWRkQ2xhc3MoXFxcImZyLXNwbGl0XFxcIiksdCs9Yi5ub2RlLmNsb3NlVGFnU3RyaW5nKHgpLHU9Yi5ub2RlLm9wZW5UYWdTdHJpbmcoYSh4KS5jbG9uZSgpLmFkZENsYXNzKFxcXCJmci1zcGxpdFxcXCIpLmdldCgwKSkrdSxzLmdldCgwKSE9eCYmKHYrPWIubm9kZS5jbG9zZVRhZ1N0cmluZyh4KSx3PWIubm9kZS5vcGVuVGFnU3RyaW5nKGEoeCkuY2xvbmUoKS5hZGRDbGFzcyhcXFwiZnItc3BsaXRcXFwiKS5nZXQoMCkpK3cpO3doaWxlKHMuZ2V0KDApIT14KTt2YXIgeT10K2Iubm9kZS5vcGVuVGFnU3RyaW5nKGEocy5nZXQoMCkpLmNsb25lKCkuY3NzKGMsZHx8XFxcIlxcXCIpLmdldCgwKSkrdytwLmNzcyhjLFxcXCJcXFwiKS5nZXQoMCkub3V0ZXJIVE1MK3YrXFxcIjwvc3Bhbj5cXFwiK3U7cC5yZXBsYWNlV2l0aCgnPHNwYW4gaWQ9XFxcImZyLWJyZWFrXFxcIj48L3NwYW4+Jyk7dmFyIHo9cy5nZXQoMCkub3V0ZXJIVE1MO2Eocy5nZXQoMCkpLnJlcGxhY2VXaXRoKHoucmVwbGFjZSgvPHNwYW4gaWQ9XFxcImZyLWJyZWFrXFxcIj48XFxcXC9zcGFuPi9nLHkpKX19Zm9yKDtiLiRlbC5maW5kKFxcXCIuZnItc3BsaXQ6ZW1wdHlcXFwiKS5sZW5ndGg+MDspYi4kZWwuZmluZChcXFwiLmZyLXNwbGl0OmVtcHR5XFxcIikucmVtb3ZlKCk7Yi4kZWwuZmluZChcXFwiLmZyLXNwbGl0XFxcIikucmVtb3ZlQ2xhc3MoXFxcImZyLXNwbGl0XFxcIiksYi4kZWwuZmluZCgnc3BhbltzdHlsZT1cXFwiXFxcIl0nKS5yZW1vdmVBdHRyKFxcXCJzdHlsZVxcXCIpLGIuJGVsLmZpbmQoJ3NwYW5bY2xhc3M9XFxcIlxcXCJdJykucmVtb3ZlQXR0cihcXFwiY2xhc3NcXFwiKSxiLmh0bWwuY2xlYW5FbXB0eVRhZ3MoKSxhKGIuJGVsLmZpbmQoXFxcInNwYW5cXFwiKS5nZXQoKS5yZXZlcnNlKCkpLmVhY2goZnVuY3Rpb24oKXt0aGlzLmF0dHJpYnV0ZXMmJjAhPXRoaXMuYXR0cmlidXRlcy5sZW5ndGh8fGEodGhpcykucmVwbGFjZVdpdGgodGhpcy5pbm5lckhUTUwpfSksYi4kZWwuZ2V0KDApLm5vcm1hbGl6ZSgpO3ZhciBBPWIuJGVsLmZpbmQoXFxcInNwYW5bc3R5bGVdICsgc3BhbltzdHlsZV1cXFwiKTtmb3Ioaz0wO2s8QS5sZW5ndGg7aysrKXt2YXIgQj1hKEFba10pLEM9YShBW2tdKS5wcmV2KCk7Qi5nZXQoMCkucHJldmlvdXNTaWJsaW5nPT1DLmdldCgwKSYmYi5ub2RlLm9wZW5UYWdTdHJpbmcoQi5nZXQoMCkpPT1iLm5vZGUub3BlblRhZ1N0cmluZyhDLmdldCgwKSkmJihCLnByZXBlbmQoQy5odG1sKCkpLEMucmVtb3ZlKCkpfWIuJGVsLmdldCgwKS5ub3JtYWxpemUoKSxiLnNlbGVjdGlvbi5yZXN0b3JlKCl9fWZ1bmN0aW9uIHAoYSl7byhhLG51bGwpfWZ1bmN0aW9uIHEoYSxjKXtcXFwidW5kZWZpbmVkXFxcIj09dHlwZW9mIGMmJihjPXt9KSxjLnN0eWxlJiZkZWxldGUgYy5zdHlsZTt2YXIgZD1iLnNlbGVjdGlvbi5yYW5nZXMoMCksZz1kLnN0YXJ0Q29udGFpbmVyO2cubm9kZVR5cGU9PU5vZGUuRUxFTUVOVF9OT0RFJiZnLmNoaWxkTm9kZXMubGVuZ3RoPjAmJmcuY2hpbGROb2Rlc1tkLnN0YXJ0T2Zmc2V0XSYmKGc9Zy5jaGlsZE5vZGVzW2Quc3RhcnRPZmZzZXRdKTtmb3IodmFyIGg9ZztoJiZoLm5vZGVUeXBlPT1Ob2RlLkVMRU1FTlRfTk9ERSYmIWYoaCxlKGEsYykpOyloPWguZmlyc3RDaGlsZDtpZihoJiZoLm5vZGVUeXBlPT1Ob2RlLkVMRU1FTlRfTk9ERSYmZihoLGUoYSxjKSkpcmV0dXJuITA7dmFyIGk9Zztmb3IoaSYmaS5ub2RlVHlwZSE9Tm9kZS5FTEVNRU5UX05PREUmJihpPWkucGFyZW50Tm9kZSk7aSYmaS5ub2RlVHlwZT09Tm9kZS5FTEVNRU5UX05PREUmJmkhPWIuJGVsLmdldCgwKSYmIWYoaSxlKGEsYykpOylpPWkucGFyZW50Tm9kZTtyZXR1cm4gaSYmaS5ub2RlVHlwZT09Tm9kZS5FTEVNRU5UX05PREUmJmkhPWIuJGVsLmdldCgwKSYmZihpLGUoYSxjKSk/ITA6ITF9cmV0dXJue2lzOnEsdG9nZ2xlOmwsYXBwbHk6aCxyZW1vdmU6ayxhcHBseVN0eWxlOm8scmVtb3ZlU3R5bGU6cH19LGEuRkUuQ09NTUFORFM9e2JvbGQ6e3RpdGxlOlxcXCJCb2xkXFxcIixyZWZyZXNoOmZ1bmN0aW9uKGEpe2EudG9nZ2xlQ2xhc3MoXFxcImZyLWFjdGl2ZVxcXCIsdGhpcy5mb3JtYXQuaXMoXFxcInN0cm9uZ1xcXCIpKX19LGl0YWxpYzp7dGl0bGU6XFxcIkl0YWxpY1xcXCIscmVmcmVzaDpmdW5jdGlvbihhKXthLnRvZ2dsZUNsYXNzKFxcXCJmci1hY3RpdmVcXFwiLHRoaXMuZm9ybWF0LmlzKFxcXCJlbVxcXCIpKX19LHVuZGVybGluZTp7dGl0bGU6XFxcIlVuZGVybGluZVxcXCIscmVmcmVzaDpmdW5jdGlvbihhKXthLnRvZ2dsZUNsYXNzKFxcXCJmci1hY3RpdmVcXFwiLHRoaXMuZm9ybWF0LmlzKFxcXCJ1XFxcIikpfX0sc3RyaWtlVGhyb3VnaDp7dGl0bGU6XFxcIlN0cmlrZXRocm91Z2hcXFwiLHJlZnJlc2g6ZnVuY3Rpb24oYSl7YS50b2dnbGVDbGFzcyhcXFwiZnItYWN0aXZlXFxcIix0aGlzLmZvcm1hdC5pcyhcXFwic1xcXCIpKX19LHN1YnNjcmlwdDp7dGl0bGU6XFxcIlN1YnNjcmlwdFxcXCIscmVmcmVzaDpmdW5jdGlvbihhKXthLnRvZ2dsZUNsYXNzKFxcXCJmci1hY3RpdmVcXFwiLHRoaXMuZm9ybWF0LmlzKFxcXCJzdWJcXFwiKSl9fSxzdXBlcnNjcmlwdDp7dGl0bGU6XFxcIlN1cGVyc2NyaXB0XFxcIixyZWZyZXNoOmZ1bmN0aW9uKGEpe2EudG9nZ2xlQ2xhc3MoXFxcImZyLWFjdGl2ZVxcXCIsdGhpcy5mb3JtYXQuaXMoXFxcInN1cFxcXCIpKX19LG91dGRlbnQ6e3RpdGxlOlxcXCJEZWNyZWFzZSBJbmRlbnRcXFwifSxpbmRlbnQ6e3RpdGxlOlxcXCJJbmNyZWFzZSBJbmRlbnRcXFwifSx1bmRvOnt0aXRsZTpcXFwiVW5kb1xcXCIsdW5kbzohMSxmb3JjZWRSZWZyZXNoOiEwLGRpc2FibGVkOiEwfSxyZWRvOnt0aXRsZTpcXFwiUmVkb1xcXCIsdW5kbzohMSxmb3JjZWRSZWZyZXNoOiEwLGRpc2FibGVkOiEwfSxpbnNlcnRIUjp7dGl0bGU6XFxcIkluc2VydCBIb3Jpem9udGFsIExpbmVcXFwifSxjbGVhckZvcm1hdHRpbmc6e3RpdGxlOlxcXCJDbGVhciBGb3JtYXR0aW5nXFxcIn0sc2VsZWN0QWxsOnt0aXRsZTpcXFwiU2VsZWN0IEFsbFxcXCIsdW5kbzohMX19LGEuRkUuUmVnaXN0ZXJDb21tYW5kPWZ1bmN0aW9uKGIsYyl7YS5GRS5DT01NQU5EU1tiXT1jfSxhLkZFLk1PRFVMRVMuY29tbWFuZHM9ZnVuY3Rpb24oYil7ZnVuY3Rpb24gYyhjLGQpe2lmKGIuZXZlbnRzLnRyaWdnZXIoXFxcImNvbW1hbmRzLmJlZm9yZVxcXCIsYS5tZXJnZShbY10sZHx8W10pKSE9PSExKXt2YXIgZT1hLkZFLkNPTU1BTkRTW2NdJiZhLkZFLkNPTU1BTkRTW2NdLmNhbGxiYWNrfHxoW2NdLGY9ITA7YS5GRS5DT01NQU5EU1tjXSYmXFxcInVuZGVmaW5lZFxcXCIhPXR5cGVvZiBhLkZFLkNPTU1BTkRTW2NdLmZvY3VzJiYoZj1hLkZFLkNPTU1BTkRTW2NdLmZvY3VzKSxiLmNvcmUuaGFzRm9jdXMoKXx8IWZ8fGIucG9wdXBzLmFyZVZpc2libGUoKXx8Yi5ldmVudHMuZm9jdXMoITApLGEuRkUuQ09NTUFORFNbY10mJmEuRkUuQ09NTUFORFNbY10udW5kbyE9PSExJiZiLnVuZG8uc2F2ZVN0ZXAoKSxlJiZlLmFwcGx5KGIsYS5tZXJnZShbY10sZHx8W10pKSxiLmV2ZW50cy50cmlnZ2VyKFxcXCJjb21tYW5kcy5hZnRlclxcXCIsYS5tZXJnZShbY10sZHx8W10pKSxhLkZFLkNPTU1BTkRTW2NdJiZhLkZFLkNPTU1BTkRTW2NdLnVuZG8hPT0hMSYmYi51bmRvLnNhdmVTdGVwKCl9fWZ1bmN0aW9uIGQoYSxjKXtiLmZvcm1hdC50b2dnbGUoYyl9ZnVuY3Rpb24gZShjKXtiLnNlbGVjdGlvbi5zYXZlKCksYi5odG1sLndyYXAoITAsITAsITAsITApLGIuc2VsZWN0aW9uLnJlc3RvcmUoKTtmb3IodmFyIGQ9Yi5zZWxlY3Rpb24uYmxvY2tzKCksZT0wO2U8ZC5sZW5ndGg7ZSsrKWlmKFxcXCJMSVxcXCIhPWRbZV0udGFnTmFtZSYmXFxcIkxJXFxcIiE9ZFtlXS5wYXJlbnROb2RlLnRhZ05hbWUpe3ZhciBmPWEoZFtlXSksZz1cXFwicnRsXFxcIj09Yi5vcHRzLmRpcmVjdGlvbnx8XFxcInJ0bFxcXCI9PWYuY3NzKFxcXCJkaXJlY3Rpb25cXFwiKT9cXFwibWFyZ2luLXJpZ2h0XFxcIjpcXFwibWFyZ2luLWxlZnRcXFwiLGg9Yi5oZWxwZXJzLmdldFBYKGYuY3NzKGcpKTtmLmNzcyhnLE1hdGgubWF4KGgrMjAqYywwKXx8XFxcIlxcXCIpLGYucmVtb3ZlQ2xhc3MoXFxcImZyLXRlbXAtZGl2XFxcIil9Yi5zZWxlY3Rpb24uc2F2ZSgpLGIuaHRtbC51bndyYXAoKSxiLnNlbGVjdGlvbi5yZXN0b3JlKCl9ZnVuY3Rpb24gZihhKXtyZXR1cm4gZnVuY3Rpb24oKXtjKGEpfX1mdW5jdGlvbiBnKCl7Yi5ldmVudHMub24oXFxcImtleWRvd25cXFwiLGZ1bmN0aW9uKGEpe3ZhciBjPWIuc2VsZWN0aW9uLmVsZW1lbnQoKTtyZXR1cm4gYyYmXFxcIkhSXFxcIj09Yy50YWdOYW1lJiYhYi5rZXlzLmlzQXJyb3coYS53aGljaCk/KGEucHJldmVudERlZmF1bHQoKSwhMSk6dm9pZCAwfSksYi5ldmVudHMub24oXFxcImtleXVwXFxcIixmdW5jdGlvbihjKXt2YXIgZD1iLnNlbGVjdGlvbi5lbGVtZW50KCk7aWYoZCYmXFxcIkhSXFxcIj09ZC50YWdOYW1lKWlmKGMud2hpY2g9PWEuRkUuS0VZQ09ERS5BUlJPV19MRUZUfHxjLndoaWNoPT1hLkZFLktFWUNPREUuQVJST1dfVVApe2lmKGQucHJldmlvdXNTaWJsaW5nKXJldHVybiBiLm5vZGUuaXNCbG9jayhkLnByZXZpb3VzU2libGluZyk/Yi5zZWxlY3Rpb24uc2V0QXRFbmQoZC5wcmV2aW91c1NpYmxpbmcpOmEoZCkuYmVmb3JlKGEuRkUuTUFSS0VSUyksYi5zZWxlY3Rpb24ucmVzdG9yZSgpLCExfWVsc2UgaWYoKGMud2hpY2g9PWEuRkUuS0VZQ09ERS5BUlJPV19SSUdIVHx8Yy53aGljaD09YS5GRS5LRVlDT0RFLkFSUk9XX0RPV04pJiZkLm5leHRTaWJsaW5nKXJldHVybiBiLm5vZGUuaXNCbG9jayhkLm5leHRTaWJsaW5nKT9iLnNlbGVjdGlvbi5zZXRBdFN0YXJ0KGQubmV4dFNpYmxpbmcpOmEoZCkuYWZ0ZXIoYS5GRS5NQVJLRVJTKSxiLnNlbGVjdGlvbi5yZXN0b3JlKCksITF9KSxiLmV2ZW50cy5vbihcXFwibW91c2Vkb3duXFxcIixmdW5jdGlvbihhKXtyZXR1cm4gYS50YXJnZXQmJlxcXCJIUlxcXCI9PWEudGFyZ2V0LnRhZ05hbWU/KGEucHJldmVudERlZmF1bHQoKSxhLnN0b3BQcm9wYWdhdGlvbigpLCExKTp2b2lkIDB9KSxiLmV2ZW50cy5vbihcXFwibW91c2V1cFxcXCIsZnVuY3Rpb24oYyl7dmFyIGQ9Yi5zZWxlY3Rpb24uZWxlbWVudCgpLGU9Yi5zZWxlY3Rpb24uZW5kRWxlbWVudCgpO2Q9PWUmJmQmJlxcXCJIUlxcXCI9PWQudGFnTmFtZSYmKGQubmV4dFNpYmxpbmcmJihiLm5vZGUuaXNCbG9jayhkLm5leHRTaWJsaW5nKT9iLnNlbGVjdGlvbi5zZXRBdFN0YXJ0KGQubmV4dFNpYmxpbmcpOmEoZCkuYWZ0ZXIoYS5GRS5NQVJLRVJTKSksYi5zZWxlY3Rpb24ucmVzdG9yZSgpKX0pfXZhciBoPXtib2xkOmZ1bmN0aW9uKCl7ZChcXFwiYm9sZFxcXCIsXFxcInN0cm9uZ1xcXCIpfSxzdWJzY3JpcHQ6ZnVuY3Rpb24oKXtkKFxcXCJzdWJzY3JpcHRcXFwiLFxcXCJzdWJcXFwiKX0sc3VwZXJzY3JpcHQ6ZnVuY3Rpb24oKXtkKFxcXCJzdXBlcnNjcmlwdFxcXCIsXFxcInN1cFxcXCIpfSxpdGFsaWM6ZnVuY3Rpb24oKXtkKFxcXCJpdGFsaWNcXFwiLFxcXCJlbVxcXCIpfSxzdHJpa2VUaHJvdWdoOmZ1bmN0aW9uKCl7ZChcXFwic3RyaWtlVGhyb3VnaFxcXCIsXFxcInNcXFwiKX0sdW5kZXJsaW5lOmZ1bmN0aW9uKCl7ZChcXFwidW5kZXJsaW5lXFxcIixcXFwidVxcXCIpfSx1bmRvOmZ1bmN0aW9uKCl7Yi51bmRvLnJ1bigpfSxyZWRvOmZ1bmN0aW9uKCl7Yi51bmRvLnJlZG8oKX0saW5kZW50OmZ1bmN0aW9uKCl7ZSgxKX0sb3V0ZGVudDpmdW5jdGlvbigpe2UoLTEpfSxzaG93OmZ1bmN0aW9uKCl7Yi5vcHRzLnRvb2xiYXJJbmxpbmUmJmIudG9vbGJhci5zaG93SW5saW5lKG51bGwsITApfSxpbnNlcnRIUjpmdW5jdGlvbigpe2Iuc2VsZWN0aW9uLnJlbW92ZSgpO3ZhciBhPVxcXCJcXFwiO2IuY29yZS5pc0VtcHR5KCkmJihhPVxcXCI8YnI+XFxcIixiLmh0bWwuZGVmYXVsdFRhZygpJiYoYT1cXFwiPFxcXCIrYi5odG1sLmRlZmF1bHRUYWcoKStcXFwiPlxcXCIrYStcXFwiPC9cXFwiK2IuaHRtbC5kZWZhdWx0VGFnKCkrXFxcIj5cXFwiKSksYi5odG1sLmluc2VydCgnPGhyIGlkPVxcXCJmci1qdXN0XFxcIj4nK2EpO3ZhciBjPWIuJGVsLmZpbmQoXFxcImhyI2ZyLWp1c3RcXFwiKTtjLnJlbW92ZUF0dHIoXFxcImlkXFxcIiksYi5zZWxlY3Rpb24uc2V0QWZ0ZXIoYy5nZXQoMCkpfHxiLnNlbGVjdGlvbi5zZXRCZWZvcmUoYy5nZXQoMCkpLGIuc2VsZWN0aW9uLnJlc3RvcmUoKX0sY2xlYXJGb3JtYXR0aW5nOmZ1bmN0aW9uKCl7Yi5mb3JtYXQucmVtb3ZlKCl9LHNlbGVjdEFsbDpmdW5jdGlvbigpe2IuZG9jLmV4ZWNDb21tYW5kKFxcXCJzZWxlY3RBbGxcXFwiLCExLCExKX19LGk9e307Zm9yKHZhciBqIGluIGgpaC5oYXNPd25Qcm9wZXJ0eShqKSYmKGlbal09ZihqKSk7cmV0dXJuIGEuZXh0ZW5kKGkse2V4ZWM6YyxfaW5pdDpnfSl9LGEuRkUuTU9EVUxFUy5jdXJzb3JMaXN0cz1mdW5jdGlvbihiKXtmdW5jdGlvbiBjKGEpe2Zvcih2YXIgYj1hO1xcXCJMSVxcXCIhPWIudGFnTmFtZTspYj1iLnBhcmVudE5vZGU7cmV0dXJuIGJ9ZnVuY3Rpb24gZChhKXtmb3IodmFyIGM9YTshYi5ub2RlLmlzTGlzdChjKTspYz1jLnBhcmVudE5vZGU7cmV0dXJuIGN9ZnVuY3Rpb24gZShlKXt2YXIgZixnPWMoZSksaD1nLm5leHRTaWJsaW5nLGk9Zy5wcmV2aW91c1NpYmxpbmcsaj1iLmh0bWwuZGVmYXVsdFRhZygpO2lmKGIubm9kZS5pc0VtcHR5KGcsITApJiZoKXtmb3IodmFyIGs9XFxcIlxcXCIsbD1cXFwiXFxcIixtPWUucGFyZW50Tm9kZTshYi5ub2RlLmlzTGlzdChtKSYmbS5wYXJlbnROb2RlJiZcXFwiTElcXFwiIT09bS5wYXJlbnROb2RlLnRhZ05hbWU7KWs9Yi5ub2RlLm9wZW5UYWdTdHJpbmcobSkrayxsKz1iLm5vZGUuY2xvc2VUYWdTdHJpbmcobSksbT1tLnBhcmVudE5vZGU7az1iLm5vZGUub3BlblRhZ1N0cmluZyhtKStrLGwrPWIubm9kZS5jbG9zZVRhZ1N0cmluZyhtKTt2YXIgbj1cXFwiXFxcIjtmb3Iobj1tLnBhcmVudE5vZGUmJlxcXCJMSVxcXCI9PW0ucGFyZW50Tm9kZS50YWdOYW1lP2wrXFxcIjxsaT5cXFwiK2EuRkUuTUFSS0VSUytcXFwiPGJyPlxcXCIrazpqP2wrXFxcIjxcXFwiK2orXFxcIj5cXFwiK2EuRkUuTUFSS0VSUytcXFwiPGJyPjwvXFxcIitqK1xcXCI+XFxcIitrOmwrYS5GRS5NQVJLRVJTK1xcXCI8YnI+XFxcIitrLGEoZykuaHRtbCgnPHNwYW4gaWQ9XFxcImZyLWJyZWFrXFxcIj48L3NwYW4+Jyk7W1xcXCJVTFxcXCIsXFxcIk9MXFxcIl0uaW5kZXhPZihtLnRhZ05hbWUpPDB8fG0ucGFyZW50Tm9kZSYmXFxcIkxJXFxcIj09PW0ucGFyZW50Tm9kZS50YWdOYW1lOyltPW0ucGFyZW50Tm9kZTt2YXIgbz1iLm5vZGUub3BlblRhZ1N0cmluZyhtKSthKG0pLmh0bWwoKStiLm5vZGUuY2xvc2VUYWdTdHJpbmcobSk7bz1vLnJlcGxhY2UoLzxzcGFuIGlkPVxcXCJmci1icmVha1xcXCI+PFxcXFwvc3Bhbj4vZyxuKSxhKG0pLnJlcGxhY2VXaXRoKG8pLGIuJGVsLmZpbmQoXFxcImxpOmVtcHR5XFxcIikucmVtb3ZlKCl9ZWxzZSBpJiZofHwhYi5ub2RlLmlzRW1wdHkoZywhMCk/KGEoZykuYmVmb3JlKFxcXCI8bGk+PGJyPjwvbGk+XFxcIiksYShlKS5yZW1vdmUoKSk6aT8oZj1kKGcpLGYucGFyZW50Tm9kZSYmXFxcIkxJXFxcIj09Zi5wYXJlbnROb2RlLnRhZ05hbWU/YShmLnBhcmVudE5vZGUpLmFmdGVyKFxcXCI8bGk+XFxcIithLkZFLk1BUktFUlMrXFxcIjxicj48L2xpPlxcXCIpOmo/YShmKS5hZnRlcihcXFwiPFxcXCIraitcXFwiPlxcXCIrYS5GRS5NQVJLRVJTK1xcXCI8YnI+PC9cXFwiK2orXFxcIj5cXFwiKTphKGYpLmFmdGVyKGEuRkUuTUFSS0VSUytcXFwiPGJyPlxcXCIpLGEoZykucmVtb3ZlKCkpOihmPWQoZyksZi5wYXJlbnROb2RlJiZcXFwiTElcXFwiPT1mLnBhcmVudE5vZGUudGFnTmFtZT9oP2EoZi5wYXJlbnROb2RlKS5iZWZvcmUoXFxcIjxsaT5cXFwiK2EuRkUuTUFSS0VSUytcXFwiPGJyPjwvbGk+XFxcIik6YShmLnBhcmVudE5vZGUpLmFmdGVyKFxcXCI8bGk+XFxcIithLkZFLk1BUktFUlMrXFxcIjxicj48L2xpPlxcXCIpOmo/YShmKS5iZWZvcmUoXFxcIjxcXFwiK2orXFxcIj5cXFwiK2EuRkUuTUFSS0VSUytcXFwiPGJyPjwvXFxcIitqK1xcXCI+XFxcIik6YShmKS5iZWZvcmUoYS5GRS5NQVJLRVJTK1xcXCI8YnI+XFxcIiksYShnKS5yZW1vdmUoKSl9ZnVuY3Rpb24gZihkKXtmb3IodmFyIGU9YyhkKSxmPVxcXCJcXFwiLGc9ZCxoPVxcXCJcXFwiLGk9XFxcIlxcXCI7ZyE9ZTspe2c9Zy5wYXJlbnROb2RlO3ZhciBqPVxcXCJBXFxcIj09Zy50YWdOYW1lJiZiLmN1cnNvci5pc0F0RW5kKGQsZyk/XFxcImZyLXRvLXJlbW92ZVxcXCI6XFxcIlxcXCI7aD1iLm5vZGUub3BlblRhZ1N0cmluZyhhKGcpLmNsb25lKCkuYWRkQ2xhc3MoaikuZ2V0KDApKStoLGk9Yi5ub2RlLmNsb3NlVGFnU3RyaW5nKGcpK2l9Zj1pK2YraCthLkZFLk1BUktFUlMsYShkKS5yZXBsYWNlV2l0aCgnPHNwYW4gaWQ9XFxcImZyLWJyZWFrXFxcIj48L3NwYW4+Jyk7dmFyIGs9Yi5ub2RlLm9wZW5UYWdTdHJpbmcoZSkrYShlKS5odG1sKCkrYi5ub2RlLmNsb3NlVGFnU3RyaW5nKGUpO2s9ay5yZXBsYWNlKC88c3BhbiBpZD1cXFwiZnItYnJlYWtcXFwiPjxcXFxcL3NwYW4+L2csZiksYShlKS5yZXBsYWNlV2l0aChrKX1mdW5jdGlvbiBnKGQpe2Zvcih2YXIgZT1jKGQpLGY9YS5GRS5NQVJLRVJTLGc9XFxcIlxcXCIsaD1kLGk9ITE7aCE9ZTspe2g9aC5wYXJlbnROb2RlO3ZhciBqPVxcXCJBXFxcIj09aC50YWdOYW1lJiZiLmN1cnNvci5pc0F0RW5kKGQsaCk/XFxcImZyLXRvLXJlbW92ZVxcXCI6XFxcIlxcXCI7aXx8aD09ZXx8Yi5ub2RlLmlzQmxvY2soaCl8fChpPSEwLGcrPWEuRkUuSU5WSVNJQkxFX1NQQUNFKSxnPWIubm9kZS5vcGVuVGFnU3RyaW5nKGEoaCkuY2xvbmUoKS5hZGRDbGFzcyhqKS5nZXQoMCkpK2csZis9Yi5ub2RlLmNsb3NlVGFnU3RyaW5nKGgpfXZhciBrPWcrZjthKGQpLnJlbW92ZSgpLGEoZSkuYWZ0ZXIoayl9ZnVuY3Rpb24gaChlKXt2YXIgZj1jKGUpLGc9Zi5wcmV2aW91c1NpYmxpbmc7aWYoZyl7Zz1hKGcpLmZpbmQoYi5odG1sLmJsb2NrVGFnc1F1ZXJ5KCkpLmdldCgtMSl8fGcsYShlKS5yZXBsYWNlV2l0aChhLkZFLk1BUktFUlMpO3ZhciBoPWIubm9kZS5jb250ZW50cyhnKTtoLmxlbmd0aCYmXFxcIkJSXFxcIj09aFtoLmxlbmd0aC0xXS50YWdOYW1lJiZhKGhbaC5sZW5ndGgtMV0pLnJlbW92ZSgpLGEoZikuZmluZChiLmh0bWwuYmxvY2tUYWdzUXVlcnkoKSkubm90KFxcXCJvbCwgdWwsIHRhYmxlXFxcIikuZWFjaChmdW5jdGlvbigpe3RoaXMucGFyZW50Tm9kZT09ZiYmYSh0aGlzKS5yZXBsYWNlV2l0aChhKHRoaXMpLmh0bWwoKSsoYi5ub2RlLmlzRW1wdHkodGhpcyk/XFxcIlxcXCI6XFxcIjxicj5cXFwiKSl9KTtmb3IodmFyIGksaj1iLm5vZGUuY29udGVudHMoZilbMF07aiYmIWIubm9kZS5pc0xpc3Qoaik7KWk9ai5uZXh0U2libGluZyxhKGcpLmFwcGVuZChqKSxqPWk7Zm9yKGc9Zi5wcmV2aW91c1NpYmxpbmc7ajspaT1qLm5leHRTaWJsaW5nLGEoZykuYXBwZW5kKGopLGo9aTthKGYpLnJlbW92ZSgpfWVsc2V7dmFyIGs9ZChmKTtpZihhKGUpLnJlcGxhY2VXaXRoKGEuRkUuTUFSS0VSUyksay5wYXJlbnROb2RlJiZcXFwiTElcXFwiPT1rLnBhcmVudE5vZGUudGFnTmFtZSl7dmFyIGw9ay5wcmV2aW91c1NpYmxpbmc7Yi5ub2RlLmlzQmxvY2sobCk/KGEoZikuZmluZChiLmh0bWwuYmxvY2tUYWdzUXVlcnkoKSkubm90KFxcXCJvbCwgdWwsIHRhYmxlXFxcIikuZWFjaChmdW5jdGlvbigpe3RoaXMucGFyZW50Tm9kZT09ZiYmYSh0aGlzKS5yZXBsYWNlV2l0aChhKHRoaXMpLmh0bWwoKSsoYi5ub2RlLmlzRW1wdHkodGhpcyk/XFxcIlxcXCI6XFxcIjxicj5cXFwiKSl9KSxhKGwpLmFwcGVuZChhKGYpLmh0bWwoKSkpOmEoaykuYmVmb3JlKGEoZikuaHRtbCgpKX1lbHNle3ZhciBtPWIuaHRtbC5kZWZhdWx0VGFnKCk7bSYmMD09PWEoZikuZmluZChiLmh0bWwuYmxvY2tUYWdzUXVlcnkoKSkubGVuZ3RoP2EoaykuYmVmb3JlKFxcXCI8XFxcIittK1xcXCI+XFxcIithKGYpLmh0bWwoKStcXFwiPC9cXFwiK20rXFxcIj5cXFwiKTphKGspLmJlZm9yZShhKGYpLmh0bWwoKSl9YShmKS5yZW1vdmUoKSwwPT09YShrKS5maW5kKFxcXCJsaVxcXCIpLmxlbmd0aCYmYShrKS5yZW1vdmUoKX19ZnVuY3Rpb24gaShkKXt2YXIgZSxmPWMoZCksZz1mLm5leHRTaWJsaW5nO2lmKGcpe2U9Yi5ub2RlLmNvbnRlbnRzKGcpLGUubGVuZ3RoJiZcXFwiQlJcXFwiPT1lWzBdLnRhZ05hbWUmJmEoZVswXSkucmVtb3ZlKCksYShnKS5maW5kKGIuaHRtbC5ibG9ja1RhZ3NRdWVyeSgpKS5ub3QoXFxcIm9sLCB1bCwgdGFibGVcXFwiKS5lYWNoKGZ1bmN0aW9uKCl7dGhpcy5wYXJlbnROb2RlPT1nJiZhKHRoaXMpLnJlcGxhY2VXaXRoKGEodGhpcykuaHRtbCgpKyhiLm5vZGUuaXNFbXB0eSh0aGlzKT9cXFwiXFxcIjpcXFwiPGJyPlxcXCIpKX0pO2Zvcih2YXIgaCxpPWQsaj1iLm5vZGUuY29udGVudHMoZylbMF07aiYmIWIubm9kZS5pc0xpc3Qoaik7KWg9ai5uZXh0U2libGluZyxhKGkpLmFmdGVyKGopLGk9aixqPWg7Zm9yKDtqOyloPWoubmV4dFNpYmxpbmcsYShmKS5hcHBlbmQoaiksaj1oO2EoZCkucmVwbGFjZVdpdGgoYS5GRS5NQVJLRVJTKSxhKGcpLnJlbW92ZSgpfWVsc2V7Zm9yKHZhciBrPWY7IWsubmV4dFNpYmxpbmcmJmshPWIuJGVsLmdldCgwKTspaz1rLnBhcmVudE5vZGU7aWYoaz09Yi4kZWwuZ2V0KDApKXJldHVybiExO2lmKGs9ay5uZXh0U2libGluZyxiLm5vZGUuaXNCbG9jayhrKSlhLkZFLk5PX0RFTEVURV9UQUdTLmluZGV4T2Yoay50YWdOYW1lKTwwJiYoYShkKS5yZXBsYWNlV2l0aChhLkZFLk1BUktFUlMpLGU9Yi5ub2RlLmNvbnRlbnRzKGYpLGUubGVuZ3RoJiZcXFwiQlJcXFwiPT1lW2UubGVuZ3RoLTFdLnRhZ05hbWUmJmEoZVtlLmxlbmd0aC0xXSkucmVtb3ZlKCksYShmKS5hcHBlbmQoYShrKS5odG1sKCkpLGEoaykucmVtb3ZlKCkpO2Vsc2UgZm9yKGU9Yi5ub2RlLmNvbnRlbnRzKGYpLGUubGVuZ3RoJiZcXFwiQlJcXFwiPT1lW2UubGVuZ3RoLTFdLnRhZ05hbWUmJmEoZVtlLmxlbmd0aC0xXSkucmVtb3ZlKCksYShkKS5yZXBsYWNlV2l0aChhLkZFLk1BUktFUlMpO2smJiFiLm5vZGUuaXNCbG9jayhrKSYmXFxcIkJSXFxcIiE9ay50YWdOYW1lOylhKGYpLmFwcGVuZChhKGspKSxrPWsubmV4dFNpYmxpbmd9fXJldHVybntfc3RhcnRFbnRlcjplLF9taWRkbGVFbnRlcjpmLF9lbmRFbnRlcjpnLF9iYWNrc3BhY2U6aCxfZGVsOml9fSxhLkZFLk5PX0RFTEVURV9UQUdTPVtcXFwiVEhcXFwiLFxcXCJURFxcXCIsXFxcIlRSXFxcIixcXFwiVEFCTEVcXFwiLFxcXCJGT1JNXFxcIl0sYS5GRS5TSU1QTEVfRU5URVJfVEFHUz1bXFxcIlRIXFxcIixcXFwiVERcXFwiLFxcXCJMSVxcXCIsXFxcIkRMXFxcIixcXFwiRFRcXFwiLFxcXCJGT1JNXFxcIl0sYS5GRS5NT0RVTEVTLmN1cnNvcj1mdW5jdGlvbihiKXtmdW5jdGlvbiBjKGEpe3JldHVybiBhP2Iubm9kZS5pc0Jsb2NrKGEpPyEwOmEubmV4dFNpYmxpbmcmJmEubmV4dFNpYmxpbmcubm9kZVR5cGU9PU5vZGUuVEVYVF9OT0RFJiYwPT1hLm5leHRTaWJsaW5nLnRleHRDb250ZW50LnJlcGxhY2UoL1xcXFx1MjAwYi9nLFxcXCJcXFwiKS5sZW5ndGg/YyhhLm5leHRTaWJsaW5nKTphLm5leHRTaWJsaW5nPyExOmMoYS5wYXJlbnROb2RlKTohMX1mdW5jdGlvbiBkKGEpe3JldHVybiBhP2Iubm9kZS5pc0Jsb2NrKGEpPyEwOmEucHJldmlvdXNTaWJsaW5nJiZhLnByZXZpb3VzU2libGluZy5ub2RlVHlwZT09Tm9kZS5URVhUX05PREUmJjA9PWEucHJldmlvdXNTaWJsaW5nLnRleHRDb250ZW50LnJlcGxhY2UoL1xcXFx1MjAwYi9nLFxcXCJcXFwiKS5sZW5ndGg/ZChhLnByZXZpb3VzU2libGluZyk6YS5wcmV2aW91c1NpYmxpbmc/ITE6ZChhLnBhcmVudE5vZGUpOiExfWZ1bmN0aW9uIGUoYSxjKXtyZXR1cm4gYT9hPT1iLiR3cC5nZXQoMCk/ITE6YS5wcmV2aW91c1NpYmxpbmcmJmEucHJldmlvdXNTaWJsaW5nLm5vZGVUeXBlPT1Ob2RlLlRFWFRfTk9ERSYmMD09YS5wcmV2aW91c1NpYmxpbmcudGV4dENvbnRlbnQucmVwbGFjZSgvXFxcXHUyMDBiL2csXFxcIlxcXCIpLmxlbmd0aD9lKGEucHJldmlvdXNTaWJsaW5nLGMpOmEucHJldmlvdXNTaWJsaW5nPyExOmEucGFyZW50Tm9kZT09Yz8hMDplKGEucGFyZW50Tm9kZSxjKTohMX1mdW5jdGlvbiBmKGEsYyl7cmV0dXJuIGE/YT09Yi4kd3AuZ2V0KDApPyExOmEubmV4dFNpYmxpbmcmJmEubmV4dFNpYmxpbmcubm9kZVR5cGU9PU5vZGUuVEVYVF9OT0RFJiYwPT1hLm5leHRTaWJsaW5nLnRleHRDb250ZW50LnJlcGxhY2UoL1xcXFx1MjAwYi9nLFxcXCJcXFwiKS5sZW5ndGg/ZihhLm5leHRTaWJsaW5nLGMpOmEubmV4dFNpYmxpbmc/ITE6YS5wYXJlbnROb2RlPT1jPyEwOmYoYS5wYXJlbnROb2RlLGMpOiExfWZ1bmN0aW9uIGcoYyl7cmV0dXJuIGEoYykucGFyZW50c1VudGlsKGIuJGVsLFxcXCJMSVxcXCIpLmxlbmd0aD4wJiYwPT09YShjKS5wYXJlbnRzVW50aWwoXFxcIkxJXFxcIixcXFwiVEFCTEVcXFwiKS5sZW5ndGh9ZnVuY3Rpb24gaChjKXt2YXIgZD1hKGMpLnBhcmVudHNVbnRpbChiLiRlbCxcXFwiQkxPQ0tRVU9URVxcXCIpLmxlbmd0aD4wLGU9Yi5ub2RlLmRlZXBlc3RQYXJlbnQoYyxbXSwhZCk7aWYoZSYmXFxcIkJMT0NLUVVPVEVcXFwiPT1lLnRhZ05hbWUpe3ZhciBmPWIubm9kZS5kZWVwZXN0UGFyZW50KGMsW2EoYykucGFyZW50c1VudGlsKGIuJGVsLFxcXCJCTE9DS1FVT1RFXFxcIikuZ2V0KDApXSk7ZiYmZi5wcmV2aW91c1NpYmxpbmcmJihlPWYpfWlmKG51bGwhPT1lKXt2YXIgZyxoPWUucHJldmlvdXNTaWJsaW5nO2lmKGIubm9kZS5pc0Jsb2NrKGUpJiZiLm5vZGUuaXNFZGl0YWJsZShlKSYmaCYmYS5GRS5OT19ERUxFVEVfVEFHUy5pbmRleE9mKGgudGFnTmFtZSk8MClpZihiLm5vZGUuaXNEZWxldGFibGUoaCkpYShoKS5yZW1vdmUoKSxhKGMpLnJlcGxhY2VXaXRoKGEuRkUuTUFSS0VSUyk7ZWxzZSBpZihiLm5vZGUuaXNFZGl0YWJsZShoKSlpZihiLm5vZGUuaXNCbG9jayhoKSlpZihiLm5vZGUuaXNFbXB0eShoKSYmIWIubm9kZS5pc0xpc3QoaCkpYShoKS5yZW1vdmUoKTtlbHNle2lmKGIubm9kZS5pc0xpc3QoaCkmJihoPWEoaCkuZmluZChcXFwibGk6bGFzdFxcXCIpLmdldCgwKSksZz1iLm5vZGUuY29udGVudHMoaCksZy5sZW5ndGgmJlxcXCJCUlxcXCI9PWdbZy5sZW5ndGgtMV0udGFnTmFtZSYmYShnW2cubGVuZ3RoLTFdKS5yZW1vdmUoKSxcXFwiQkxPQ0tRVU9URVxcXCI9PWgudGFnTmFtZSYmXFxcIkJMT0NLUVVPVEVcXFwiIT1lLnRhZ05hbWUpZm9yKGc9Yi5ub2RlLmNvbnRlbnRzKGgpO2cubGVuZ3RoJiZiLm5vZGUuaXNCbG9jayhnW2cubGVuZ3RoLTFdKTspaD1nW2cubGVuZ3RoLTFdLGc9Yi5ub2RlLmNvbnRlbnRzKGgpO2Vsc2UgaWYoXFxcIkJMT0NLUVVPVEVcXFwiIT1oLnRhZ05hbWUmJlxcXCJCTE9DS1FVT1RFXFxcIj09ZS50YWdOYW1lKWZvcihnPWIubm9kZS5jb250ZW50cyhlKTtnLmxlbmd0aCYmYi5ub2RlLmlzQmxvY2soZ1swXSk7KWU9Z1swXSxnPWIubm9kZS5jb250ZW50cyhlKTthKGMpLnJlcGxhY2VXaXRoKGEuRkUuTUFSS0VSUyksYShoKS5hcHBlbmQoYi5ub2RlLmlzRW1wdHkoZSk/YS5GRS5NQVJLRVJTOmUuaW5uZXJIVE1MKSxhKGUpLnJlbW92ZSgpfWVsc2UgYShjKS5yZXBsYWNlV2l0aChhLkZFLk1BUktFUlMpLFxcXCJCTE9DS1FVT1RFXFxcIj09ZS50YWdOYW1lJiZoLm5vZGVUeXBlPT1Ob2RlLkVMRU1FTlRfTk9ERT9hKGgpLnJlbW92ZSgpOihhKGgpLmFmdGVyKGIubm9kZS5pc0VtcHR5KGUpP1xcXCJcXFwiOmEoZSkuaHRtbCgpKSxhKGUpLnJlbW92ZSgpLFxcXCJCUlxcXCI9PWgudGFnTmFtZSYmYShoKS5yZW1vdmUoKSl9fWZ1bmN0aW9uIGkoYyl7Zm9yKHZhciBkPWM7IWQucHJldmlvdXNTaWJsaW5nOylpZihkPWQucGFyZW50Tm9kZSxiLm5vZGUuaXNFbGVtZW50KGQpKXJldHVybiExO2Q9ZC5wcmV2aW91c1NpYmxpbmc7dmFyIGU7aWYoIWIubm9kZS5pc0Jsb2NrKGQpJiZiLm5vZGUuaXNFZGl0YWJsZShkKSl7Zm9yKGU9Yi5ub2RlLmNvbnRlbnRzKGQpO2Qubm9kZVR5cGUhPU5vZGUuVEVYVF9OT0RFJiYhYi5ub2RlLmlzRGVsZXRhYmxlKGQpJiZlLmxlbmd0aCYmYi5ub2RlLmlzRWRpdGFibGUoZCk7KWQ9ZVtlLmxlbmd0aC0xXSxlPWIubm9kZS5jb250ZW50cyhkKTtpZihkLm5vZGVUeXBlPT1Ob2RlLlRFWFRfTk9ERSl7aWYoYi5oZWxwZXJzLmlzSU9TKCkpcmV0dXJuITA7dmFyIGY9ZC50ZXh0Q29udGVudCxnPWYubGVuZ3RoLTE7aWYoYi5vcHRzLnRhYlNwYWNlcyYmZi5sZW5ndGg+PWIub3B0cy50YWJTcGFjZXMpe3ZhciBoPWYuc3Vic3RyKGYubGVuZ3RoLWIub3B0cy50YWJTcGFjZXMsZi5sZW5ndGgtMSk7MD09aC5yZXBsYWNlKC8gL2csXFxcIlxcXCIpLnJlcGxhY2UobmV3IFJlZ0V4cChhLkZFLlVOSUNPREVfTkJTUCxcXFwiZ1xcXCIpLFxcXCJcXFwiKS5sZW5ndGgmJihnPWYubGVuZ3RoLWIub3B0cy50YWJTcGFjZXMpfWQudGV4dENvbnRlbnQ9Zi5zdWJzdHJpbmcoMCxnKSxkLnRleHRDb250ZW50Lmxlbmd0aCYmNTUzNTc9PWQudGV4dENvbnRlbnQuY2hhckNvZGVBdChkLnRleHRDb250ZW50Lmxlbmd0aC0xKSYmKGQudGV4dENvbnRlbnQ9ZC50ZXh0Q29udGVudC5zdWJzdHIoMCxkLnRleHRDb250ZW50Lmxlbmd0aC0xKSk7dmFyIGk9Zi5sZW5ndGghPWQudGV4dENvbnRlbnQubGVuZ3RoOzA9PWQudGV4dENvbnRlbnQubGVuZ3RoP2kmJmIub3B0cy5rZWVwRm9ybWF0T25EZWxldGU/YShkKS5hZnRlcihhLkZFLklOVklTSUJMRV9TUEFDRSthLkZFLk1BUktFUlMpOjIhPWQucGFyZW50Tm9kZS5jaGlsZE5vZGVzLmxlbmd0aHx8ZC5wYXJlbnROb2RlIT1jLnBhcmVudE5vZGV8fGIubm9kZS5pc0Jsb2NrKGQucGFyZW50Tm9kZSl8fGIubm9kZS5pc0VsZW1lbnQoZC5wYXJlbnROb2RlKT8oYShkKS5hZnRlcihhLkZFLk1BUktFUlMpLGIubm9kZS5pc0VsZW1lbnQoZC5wYXJlbnROb2RlKSYmIWMubmV4dFNpYmxpbmcmJmQucHJldmlvdXNTaWJsaW5nJiZcXFwiQlJcXFwiPT1kLnByZXZpb3VzU2libGluZy50YWdOYW1lJiZhKGMpLmFmdGVyKFxcXCI8YnI+XFxcIiksZC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGQpKTooYShkLnBhcmVudE5vZGUpLmFmdGVyKGEuRkUuTUFSS0VSUyksYShkLnBhcmVudE5vZGUpLnJlbW92ZSgpKTphKGQpLmFmdGVyKGEuRkUuTUFSS0VSUyl9ZWxzZSBiLm5vZGUuaXNEZWxldGFibGUoZCk/KGEoZCkuYWZ0ZXIoYS5GRS5NQVJLRVJTKSxhKGQpLnJlbW92ZSgpKTpiLmV2ZW50cy50cmlnZ2VyKFxcXCJub2RlLnJlbW92ZVxcXCIsW2EoZCldKSE9PSExJiYoYShkKS5hZnRlcihhLkZFLk1BUktFUlMpLGEoZCkucmVtb3ZlKCkpfWVsc2UgaWYoYS5GRS5OT19ERUxFVEVfVEFHUy5pbmRleE9mKGQudGFnTmFtZSk8MCYmYi5ub2RlLmlzRWRpdGFibGUoZCkpaWYoYi5ub2RlLmlzRW1wdHkoZCkmJiFiLm5vZGUuaXNMaXN0KGQpKWEoZCkucmVtb3ZlKCksYShjKS5yZXBsYWNlV2l0aChhLkZFLk1BUktFUlMpO2Vsc2V7Zm9yKGIubm9kZS5pc0xpc3QoZCkmJihkPWEoZCkuZmluZChcXFwibGk6bGFzdFxcXCIpLmdldCgwKSksZT1iLm5vZGUuY29udGVudHMoZCksZSYmXFxcIkJSXFxcIj09ZVtlLmxlbmd0aC0xXS50YWdOYW1lJiZhKGVbZS5sZW5ndGgtMV0pLnJlbW92ZSgpLGU9Yi5ub2RlLmNvbnRlbnRzKGQpO2UmJmIubm9kZS5pc0Jsb2NrKGVbZS5sZW5ndGgtMV0pOylkPWVbZS5sZW5ndGgtMV0sZT1iLm5vZGUuY29udGVudHMoZCk7YShkKS5hcHBlbmQoYS5GRS5NQVJLRVJTKTtmb3IodmFyIGo9Yzshai5wcmV2aW91c1NpYmxpbmc7KWo9ai5wYXJlbnROb2RlO2Zvcig7aiYmXFxcIkJSXFxcIiE9PWoudGFnTmFtZSYmIWIubm9kZS5pc0Jsb2NrKGopOyl7dmFyIGs9ajtqPWoubmV4dFNpYmxpbmcsYShkKS5hcHBlbmQoayl9aiYmXFxcIkJSXFxcIj09ai50YWdOYW1lJiZhKGopLnJlbW92ZSgpLGEoYykucmVtb3ZlKCl9ZWxzZSBjLm5leHRTaWJsaW5nJiZcXFwiQlJcXFwiPT1jLm5leHRTaWJsaW5nLnRhZ05hbWUmJmEoYy5uZXh0U2libGluZykucmVtb3ZlKCl9ZnVuY3Rpb24gaigpe3ZhciBmPSExLGo9Yi5tYXJrZXJzLmluc2VydCgpO2lmKCFqKXJldHVybiEwO2IuJGVsLmdldCgwKS5ub3JtYWxpemUoKTt2YXIgaz1qLnByZXZpb3VzU2libGluZztpZihrKXt2YXIgbD1rLnRleHRDb250ZW50O2wmJmwubGVuZ3RoJiY4MjAzPT1sLmNoYXJDb2RlQXQobC5sZW5ndGgtMSkmJigxPT1sLmxlbmd0aD9hKGspLnJlbW92ZSgpOihrLnRleHRDb250ZW50PWsudGV4dENvbnRlbnQuc3Vic3RyKDAsbC5sZW5ndGgtMSksay50ZXh0Q29udGVudC5sZW5ndGgmJjU1MzU3PT1rLnRleHRDb250ZW50LmNoYXJDb2RlQXQoay50ZXh0Q29udGVudC5sZW5ndGgtMSkmJihrLnRleHRDb250ZW50PWsudGV4dENvbnRlbnQuc3Vic3RyKDAsay50ZXh0Q29udGVudC5sZW5ndGgtMSkpKSl9cmV0dXJuIGMoaik/Zj1pKGopOmQoaik/ZyhqKSYmZShqLGEoaikucGFyZW50cyhcXFwibGk6Zmlyc3RcXFwiKS5nZXQoMCkpP2IuY3Vyc29yTGlzdHMuX2JhY2tzcGFjZShqKTpoKGopOmY9aShqKSxhKGopLnJlbW92ZSgpLGIuJGVsLmZpbmQoXFxcImJsb2NrcXVvdGU6ZW1wdHlcXFwiKS5yZW1vdmUoKSxiLmh0bWwuZmlsbEVtcHR5QmxvY2tzKCksYi5odG1sLmNsZWFuRW1wdHlUYWdzKCksYi5jbGVhbi5xdW90ZXMoKSxiLmNsZWFuLmxpc3RzKCksYi5zcGFjZXMubm9ybWFsaXplKCksYi5zZWxlY3Rpb24ucmVzdG9yZSgpLGZ9ZnVuY3Rpb24gayhjKXt2YXIgZD1hKGMpLnBhcmVudHNVbnRpbChiLiRlbCxcXFwiQkxPQ0tRVU9URVxcXCIpLmxlbmd0aD4wLGU9Yi5ub2RlLmRlZXBlc3RQYXJlbnQoYyxbXSwhZCk7aWYoZSYmXFxcIkJMT0NLUVVPVEVcXFwiPT1lLnRhZ05hbWUpe3ZhciBmPWIubm9kZS5kZWVwZXN0UGFyZW50KGMsW2EoYykucGFyZW50c1VudGlsKGIuJGVsLFxcXCJCTE9DS1FVT1RFXFxcIikuZ2V0KDApXSk7ZiYmZi5uZXh0U2libGluZyYmKGU9Zil9aWYobnVsbCE9PWUpe3ZhciBnLGg9ZS5uZXh0U2libGluZztpZihiLm5vZGUuaXNCbG9jayhlKSYmKGIubm9kZS5pc0VkaXRhYmxlKGUpfHxiLm5vZGUuaXNEZWxldGFibGUoZSkpJiZoJiZhLkZFLk5PX0RFTEVURV9UQUdTLmluZGV4T2YoaC50YWdOYW1lKTwwKWlmKGIubm9kZS5pc0RlbGV0YWJsZShoKSlhKGgpLnJlbW92ZSgpLGEoYykucmVwbGFjZVdpdGgoYS5GRS5NQVJLRVJTKTtlbHNlIGlmKGIubm9kZS5pc0Jsb2NrKGgpJiZiLm5vZGUuaXNFZGl0YWJsZShoKSlpZihiLm5vZGUuaXNMaXN0KGgpKWlmKGIubm9kZS5pc0VtcHR5KGUsITApKWEoZSkucmVtb3ZlKCksYShoKS5maW5kKFxcXCJsaTpmaXJzdFxcXCIpLnByZXBlbmQoYS5GRS5NQVJLRVJTKTtlbHNle3ZhciBpPWEoaCkuZmluZChcXFwibGk6Zmlyc3RcXFwiKTtcXFwiQkxPQ0tRVU9URVxcXCI9PWUudGFnTmFtZSYmKGc9Yi5ub2RlLmNvbnRlbnRzKGUpLGcubGVuZ3RoJiZiLm5vZGUuaXNCbG9jayhnW2cubGVuZ3RoLTFdKSYmKGU9Z1tnLmxlbmd0aC0xXSkpLDA9PT1pLmZpbmQoXFxcInVsLCBvbFxcXCIpLmxlbmd0aCYmKGEoYykucmVwbGFjZVdpdGgoYS5GRS5NQVJLRVJTKSxpLmZpbmQoYi5odG1sLmJsb2NrVGFnc1F1ZXJ5KCkpLm5vdChcXFwib2wsIHVsLCB0YWJsZVxcXCIpLmVhY2goZnVuY3Rpb24oKXt0aGlzLnBhcmVudE5vZGU9PWkuZ2V0KDApJiZhKHRoaXMpLnJlcGxhY2VXaXRoKGEodGhpcykuaHRtbCgpKyhiLm5vZGUuaXNFbXB0eSh0aGlzKT9cXFwiXFxcIjpcXFwiPGJyPlxcXCIpKX0pLGEoZSkuYXBwZW5kKGIubm9kZS5jb250ZW50cyhpLmdldCgwKSkpLGkucmVtb3ZlKCksMD09PWEoaCkuZmluZChcXFwibGlcXFwiKS5sZW5ndGgmJmEoaCkucmVtb3ZlKCkpfWVsc2V7aWYoZz1iLm5vZGUuY29udGVudHMoaCksZy5sZW5ndGgmJlxcXCJCUlxcXCI9PWdbMF0udGFnTmFtZSYmYShnWzBdKS5yZW1vdmUoKSxcXFwiQkxPQ0tRVU9URVxcXCIhPWgudGFnTmFtZSYmXFxcIkJMT0NLUVVPVEVcXFwiPT1lLnRhZ05hbWUpZm9yKGc9Yi5ub2RlLmNvbnRlbnRzKGUpO2cubGVuZ3RoJiZiLm5vZGUuaXNCbG9jayhnW2cubGVuZ3RoLTFdKTspZT1nW2cubGVuZ3RoLTFdLGc9Yi5ub2RlLmNvbnRlbnRzKGUpO2Vsc2UgaWYoXFxcIkJMT0NLUVVPVEVcXFwiPT1oLnRhZ05hbWUmJlxcXCJCTE9DS1FVT1RFXFxcIiE9ZS50YWdOYW1lKWZvcihnPWIubm9kZS5jb250ZW50cyhoKTtnLmxlbmd0aCYmYi5ub2RlLmlzQmxvY2soZ1swXSk7KWg9Z1swXSxnPWIubm9kZS5jb250ZW50cyhoKTthKGMpLnJlcGxhY2VXaXRoKGEuRkUuTUFSS0VSUyksYShlKS5hcHBlbmQoaC5pbm5lckhUTUwpLGEoaCkucmVtb3ZlKCl9ZWxzZXtmb3IoYShjKS5yZXBsYWNlV2l0aChhLkZFLk1BUktFUlMpO2gmJlxcXCJCUlxcXCIhPT1oLnRhZ05hbWUmJiFiLm5vZGUuaXNCbG9jayhoKSYmYi5ub2RlLmlzRWRpdGFibGUoaCk7KXt2YXIgaj1oO2g9aC5uZXh0U2libGluZyxhKGUpLmFwcGVuZChqKX1oJiZcXFwiQlJcXFwiPT1oLnRhZ05hbWUmJmIubm9kZS5pc0VkaXRhYmxlKGgpJiZhKGgpLnJlbW92ZSgpfX19ZnVuY3Rpb24gbChkKXtmb3IodmFyIGU9ZDshZS5uZXh0U2libGluZzspaWYoZT1lLnBhcmVudE5vZGUsYi5ub2RlLmlzRWxlbWVudChlKSlyZXR1cm4hMTtpZihlPWUubmV4dFNpYmxpbmcsXFxcIkJSXFxcIj09ZS50YWdOYW1lJiZiLm5vZGUuaXNFZGl0YWJsZShlKSlpZihlLm5leHRTaWJsaW5nKXtpZihiLm5vZGUuaXNCbG9jayhlLm5leHRTaWJsaW5nKSYmYi5ub2RlLmlzRWRpdGFibGUoZS5uZXh0U2libGluZykpe2lmKCEoYS5GRS5OT19ERUxFVEVfVEFHUy5pbmRleE9mKGUubmV4dFNpYmxpbmcudGFnTmFtZSk8MCkpcmV0dXJuIHZvaWQgYShlKS5yZW1vdmUoKTtlPWUubmV4dFNpYmxpbmcsYShlLnByZXZpb3VzU2libGluZykucmVtb3ZlKCl9fWVsc2UgaWYoYyhlKSl7aWYoZyhkKSliLmN1cnNvckxpc3RzLl9kZWwoZCk7ZWxzZXtcXG52YXIgZj1iLm5vZGUuZGVlcGVzdFBhcmVudChlKTtmJiYoYShlKS5yZW1vdmUoKSxrKGQpKX1yZXR1cm59dmFyIGg7aWYoIWIubm9kZS5pc0Jsb2NrKGUpJiZiLm5vZGUuaXNFZGl0YWJsZShlKSl7Zm9yKGg9Yi5ub2RlLmNvbnRlbnRzKGUpO2Uubm9kZVR5cGUhPU5vZGUuVEVYVF9OT0RFJiZoLmxlbmd0aCYmIWIubm9kZS5pc0RlbGV0YWJsZShlKSYmYi5ub2RlLmlzRWRpdGFibGUoZSk7KWU9aFswXSxoPWIubm9kZS5jb250ZW50cyhlKTtlLm5vZGVUeXBlPT1Ob2RlLlRFWFRfTk9ERT8oYShlKS5iZWZvcmUoYS5GRS5NQVJLRVJTKSxlLnRleHRDb250ZW50Lmxlbmd0aCYmNTUzNTc9PWUudGV4dENvbnRlbnQuY2hhckNvZGVBdCgwKT9lLnRleHRDb250ZW50PWUudGV4dENvbnRlbnQuc3Vic3RyaW5nKDIsZS50ZXh0Q29udGVudC5sZW5ndGgpOmUudGV4dENvbnRlbnQ9ZS50ZXh0Q29udGVudC5zdWJzdHJpbmcoMSxlLnRleHRDb250ZW50Lmxlbmd0aCkpOmIubm9kZS5pc0RlbGV0YWJsZShlKT8oYShlKS5iZWZvcmUoYS5GRS5NQVJLRVJTKSxhKGUpLnJlbW92ZSgpKTpiLmV2ZW50cy50cmlnZ2VyKFxcXCJub2RlLnJlbW92ZVxcXCIsW2EoZSldKSE9PSExJiYoYShlKS5iZWZvcmUoYS5GRS5NQVJLRVJTKSxhKGUpLnJlbW92ZSgpKSxhKGQpLnJlbW92ZSgpfWVsc2UgaWYoYS5GRS5OT19ERUxFVEVfVEFHUy5pbmRleE9mKGUudGFnTmFtZSk8MCYmKGIubm9kZS5pc0VkaXRhYmxlKGUpfHxiLm5vZGUuaXNEZWxldGFibGUoZSkpKWlmKGIubm9kZS5pc0RlbGV0YWJsZShlKSlhKGQpLnJlcGxhY2VXaXRoKGEuRkUuTUFSS0VSUyksYShlKS5yZW1vdmUoKTtlbHNlIGlmKGIubm9kZS5pc0xpc3QoZSkpZC5wcmV2aW91c1NpYmxpbmc/KGEoZSkuZmluZChcXFwibGk6Zmlyc3RcXFwiKS5wcmVwZW5kKGQpLGIuY3Vyc29yTGlzdHMuX2JhY2tzcGFjZShkKSk6KGEoZSkuZmluZChcXFwibGk6Zmlyc3RcXFwiKS5wcmVwZW5kKGEuRkUuTUFSS0VSUyksYShkKS5yZW1vdmUoKSk7ZWxzZSBpZihoPWIubm9kZS5jb250ZW50cyhlKSxoJiZcXFwiQlJcXFwiPT1oWzBdLnRhZ05hbWUmJmEoaFswXSkucmVtb3ZlKCksaCYmXFxcIkJMT0NLUVVPVEVcXFwiPT1lLnRhZ05hbWUpe3ZhciBpPWhbMF07Zm9yKGEoZCkuYmVmb3JlKGEuRkUuTUFSS0VSUyk7aSYmXFxcIkJSXFxcIiE9aS50YWdOYW1lOyl7dmFyIGo9aTtpPWkubmV4dFNpYmxpbmcsYShkKS5iZWZvcmUoail9aSYmXFxcIkJSXFxcIj09aS50YWdOYW1lJiZhKGkpLnJlbW92ZSgpfWVsc2UgYShkKS5hZnRlcihhKGUpLmh0bWwoKSkuYWZ0ZXIoYS5GRS5NQVJLRVJTKSxhKGUpLnJlbW92ZSgpfWZ1bmN0aW9uIG0oKXt2YXIgZT1iLm1hcmtlcnMuaW5zZXJ0KCk7aWYoIWUpcmV0dXJuITE7aWYoYi4kZWwuZ2V0KDApLm5vcm1hbGl6ZSgpLGMoZSkpaWYoZyhlKSlpZigwPT09YShlKS5wYXJlbnRzKFxcXCJsaTpmaXJzdFxcXCIpLmZpbmQoXFxcInVsLCBvbFxcXCIpLmxlbmd0aCliLmN1cnNvckxpc3RzLl9kZWwoZSk7ZWxzZXt2YXIgZj1hKGUpLnBhcmVudHMoXFxcImxpOmZpcnN0XFxcIikuZmluZChcXFwidWw6Zmlyc3QsIG9sOmZpcnN0XFxcIikuZmluZChcXFwibGk6Zmlyc3RcXFwiKTtmPWYuZmluZChiLmh0bWwuYmxvY2tUYWdzUXVlcnkoKSkuZ2V0KC0xKXx8ZixmLnByZXBlbmQoZSksYi5jdXJzb3JMaXN0cy5fYmFja3NwYWNlKGUpfWVsc2UgayhlKTtlbHNlIGwoZChlKT9lOmUpO2EoZSkucmVtb3ZlKCksYi4kZWwuZmluZChcXFwiYmxvY2txdW90ZTplbXB0eVxcXCIpLnJlbW92ZSgpLGIuaHRtbC5maWxsRW1wdHlCbG9ja3MoKSxiLmh0bWwuY2xlYW5FbXB0eVRhZ3MoKSxiLmNsZWFuLnF1b3RlcygpLGIuY2xlYW4ubGlzdHMoKSxiLnNwYWNlcy5ub3JtYWxpemUoKSxiLnNlbGVjdGlvbi5yZXN0b3JlKCl9ZnVuY3Rpb24gbigpe2IuJGVsLmZpbmQoXFxcIi5mci10by1yZW1vdmVcXFwiKS5lYWNoKGZ1bmN0aW9uKCl7Zm9yKHZhciBjPWIubm9kZS5jb250ZW50cyh0aGlzKSxkPTA7ZDxjLmxlbmd0aDtkKyspY1tkXS5ub2RlVHlwZT09Tm9kZS5URVhUX05PREUmJihjW2RdLnRleHRDb250ZW50PWNbZF0udGV4dENvbnRlbnQucmVwbGFjZSgvXFxcXHUyMDBCL2csXFxcIlxcXCIpKTthKHRoaXMpLnJlcGxhY2VXaXRoKHRoaXMuaW5uZXJIVE1MKX0pfWZ1bmN0aW9uIG8oYyxkLGUpe3ZhciBnLGg9Yi5ub2RlLmRlZXBlc3RQYXJlbnQoYyxbXSwhZSk7aWYoaCYmXFxcIkJMT0NLUVVPVEVcXFwiPT1oLnRhZ05hbWUpcmV0dXJuIGYoYyxoKT8oZz1iLmh0bWwuZGVmYXVsdFRhZygpLGc/YShoKS5hZnRlcihcXFwiPFxcXCIrZytcXFwiPlxcXCIrYS5GRS5NQVJLRVJTK1xcXCI8YnI+PC9cXFwiK2crXFxcIj5cXFwiKTphKGgpLmFmdGVyKGEuRkUuTUFSS0VSUytcXFwiPGJyPlxcXCIpLGEoYykucmVtb3ZlKCksITEpOihxKGMsZCxlKSwhMSk7aWYobnVsbD09aClnPWIuaHRtbC5kZWZhdWx0VGFnKCksZyYmYi5ub2RlLmlzRWxlbWVudChjLnBhcmVudE5vZGUpP2EoYykucmVwbGFjZVdpdGgoXFxcIjxcXFwiK2crXFxcIj5cXFwiK2EuRkUuTUFSS0VSUytcXFwiPGJyPjwvXFxcIitnK1xcXCI+XFxcIik6YShjKS5yZXBsYWNlV2l0aChcXFwiPGJyLz5cXFwiK2EuRkUuTUFSS0VSUytcXFwiPGJyLz5cXFwiKTtlbHNle3ZhciBpPWMsaj1cXFwiXFxcIjsoIWIubm9kZS5pc0Jsb2NrKGgpfHxkKSYmKGo9XFxcIjxici8+XFxcIik7dmFyIGs9XFxcIlxcXCIsbD1cXFwiXFxcIjtnPWIuaHRtbC5kZWZhdWx0VGFnKCk7dmFyIG09XFxcIlxcXCIsbj1cXFwiXFxcIjtnJiZiLm5vZGUuaXNCbG9jayhoKSYmKG09XFxcIjxcXFwiK2crXFxcIj5cXFwiLG49XFxcIjwvXFxcIitnK1xcXCI+XFxcIixoLnRhZ05hbWU9PWcudG9VcHBlckNhc2UoKSYmKG09Yi5ub2RlLm9wZW5UYWdTdHJpbmcoYShoKS5jbG9uZSgpLnJlbW92ZUF0dHIoXFxcImlkXFxcIikuZ2V0KDApKSkpO2RvIGlmKGk9aS5wYXJlbnROb2RlLCFkfHxpIT1ofHxkJiYhYi5ub2RlLmlzQmxvY2soaCkpaWYoays9Yi5ub2RlLmNsb3NlVGFnU3RyaW5nKGkpLGk9PWgmJmIubm9kZS5pc0Jsb2NrKGgpKWw9bStsO2Vsc2V7dmFyIG89XFxcIkFcXFwiPT1pLnRhZ05hbWUmJmYoYyxpKT9cXFwiZnItdG8tcmVtb3ZlXFxcIjpcXFwiXFxcIjtsPWIubm9kZS5vcGVuVGFnU3RyaW5nKGEoaSkuY2xvbmUoKS5hZGRDbGFzcyhvKS5nZXQoMCkpK2x9d2hpbGUoaSE9aCk7aj1rK2orbCsoYy5wYXJlbnROb2RlPT1oJiZiLm5vZGUuaXNCbG9jayhoKT9cXFwiXFxcIjphLkZFLklOVklTSUJMRV9TUEFDRSkrYS5GRS5NQVJLRVJTLGIubm9kZS5pc0Jsb2NrKGgpJiYhYShoKS5maW5kKFxcXCIqOmxhc3RcXFwiKS5pcyhcXFwiYnJcXFwiKSYmYShoKS5hcHBlbmQoXFxcIjxici8+XFxcIiksYShjKS5hZnRlcignPHNwYW4gaWQ9XFxcImZyLWJyZWFrXFxcIj48L3NwYW4+JyksYShjKS5yZW1vdmUoKSxoLm5leHRTaWJsaW5nJiYhYi5ub2RlLmlzQmxvY2soaC5uZXh0U2libGluZyl8fGIubm9kZS5pc0Jsb2NrKGgpfHxhKGgpLmFmdGVyKFxcXCI8YnI+XFxcIik7dmFyIHA7cD0hZCYmYi5ub2RlLmlzQmxvY2soaCk/Yi5ub2RlLm9wZW5UYWdTdHJpbmcoaCkrYShoKS5odG1sKCkrbjpiLm5vZGUub3BlblRhZ1N0cmluZyhoKSthKGgpLmh0bWwoKStiLm5vZGUuY2xvc2VUYWdTdHJpbmcoaCkscD1wLnJlcGxhY2UoLzxzcGFuIGlkPVxcXCJmci1icmVha1xcXCI+PFxcXFwvc3Bhbj4vZyxqKSxhKGgpLnJlcGxhY2VXaXRoKHApfX1mdW5jdGlvbiBwKGMsZCxnKXt2YXIgaCxpPWIubm9kZS5kZWVwZXN0UGFyZW50KGMsW10sIWcpO2lmKGkmJlxcXCJCTE9DS1FVT1RFXFxcIj09aS50YWdOYW1lKXtpZihlKGMsaSkpcmV0dXJuIGg9Yi5odG1sLmRlZmF1bHRUYWcoKSxoP2EoaSkuYmVmb3JlKFxcXCI8XFxcIitoK1xcXCI+XFxcIithLkZFLk1BUktFUlMrXFxcIjxicj48L1xcXCIraCtcXFwiPlxcXCIpOmEoaSkuYmVmb3JlKGEuRkUuTUFSS0VSUytcXFwiPGJyPlxcXCIpLGEoYykucmVtb3ZlKCksITE7ZihjLGkpP28oYyxkLCEwKTpxKGMsZCwhMCl9aWYobnVsbD09aSloPWIuaHRtbC5kZWZhdWx0VGFnKCksaCYmYi5ub2RlLmlzRWxlbWVudChjLnBhcmVudE5vZGUpP2EoYykucmVwbGFjZVdpdGgoXFxcIjxcXFwiK2grXFxcIj5cXFwiK2EuRkUuTUFSS0VSUytcXFwiPGJyPjwvXFxcIitoK1xcXCI+XFxcIik6YShjKS5yZXBsYWNlV2l0aChcXFwiPGJyPlxcXCIrYS5GRS5NQVJLRVJTKTtlbHNle2lmKGIubm9kZS5pc0Jsb2NrKGkpKWlmKGQpYShjKS5yZW1vdmUoKSxhKGkpLnByZXBlbmQoXFxcIjxicj5cXFwiK2EuRkUuTUFSS0VSUyk7ZWxzZXtpZihiLm5vZGUuaXNFbXB0eShpLCEwKSlyZXR1cm4gbyhjLGQsZyk7YShpKS5iZWZvcmUoYi5ub2RlLm9wZW5UYWdTdHJpbmcoYShpKS5jbG9uZSgpLnJlbW92ZUF0dHIoXFxcImlkXFxcIikuZ2V0KDApKStcXFwiPGJyPlxcXCIrYi5ub2RlLmNsb3NlVGFnU3RyaW5nKGkpKX1lbHNlIGEoaSkuYmVmb3JlKFxcXCI8YnI+XFxcIik7YShjKS5yZW1vdmUoKX19ZnVuY3Rpb24gcShjLGQsZyl7dmFyIGg9Yi5ub2RlLmRlZXBlc3RQYXJlbnQoYyxbXSwhZyk7aWYobnVsbD09aCliLmh0bWwuZGVmYXVsdFRhZygpJiZjLnBhcmVudE5vZGU9PT1iLiRlbC5nZXQoMCk/YShjKS5yZXBsYWNlV2l0aChcXFwiPFxcXCIrYi5odG1sLmRlZmF1bHRUYWcoKStcXFwiPlxcXCIrYS5GRS5NQVJLRVJTK1xcXCI8YnI+PC9cXFwiK2IuaHRtbC5kZWZhdWx0VGFnKCkrXFxcIj5cXFwiKTooKCFjLm5leHRTaWJsaW5nfHxiLm5vZGUuaXNCbG9jayhjLm5leHRTaWJsaW5nKSkmJmEoYykuYWZ0ZXIoXFxcIjxicj5cXFwiKSxhKGMpLnJlcGxhY2VXaXRoKFxcXCI8YnI+XFxcIithLkZFLk1BUktFUlMpKTtlbHNle3ZhciBpPWMsaj1cXFwiXFxcIjtcXFwiUFJFXFxcIj09aC50YWdOYW1lJiYoZD0hMCksKCFiLm5vZGUuaXNCbG9jayhoKXx8ZCkmJihqPVxcXCI8YnI+XFxcIik7dmFyIGs9XFxcIlxcXCIsbD1cXFwiXFxcIjtkb3t2YXIgbT1pO2lmKGk9aS5wYXJlbnROb2RlLFxcXCJCTE9DS1FVT1RFXFxcIj09aC50YWdOYW1lJiZiLm5vZGUuaXNFbXB0eShtKSYmIWEobSkuaGFzQ2xhc3MoXFxcImZyLW1hcmtlclxcXCIpJiZhKG0pLmZpbmQoYykubGVuZ3RoPjAmJmEobSkuYWZ0ZXIoYyksKFxcXCJCTE9DS1FVT1RFXFxcIiE9aC50YWdOYW1lfHwhZihjLGkpJiYhZShjLGkpKSYmKCFkfHxpIT1ofHxkJiYhYi5ub2RlLmlzQmxvY2soaCkpKXtrKz1iLm5vZGUuY2xvc2VUYWdTdHJpbmcoaSk7dmFyIG49XFxcIkFcXFwiPT1pLnRhZ05hbWUmJmYoYyxpKT9cXFwiZnItdG8tcmVtb3ZlXFxcIjpcXFwiXFxcIjtsPWIubm9kZS5vcGVuVGFnU3RyaW5nKGEoaSkuY2xvbmUoKS5hZGRDbGFzcyhuKS5yZW1vdmVBdHRyKFxcXCJpZFxcXCIpLmdldCgwKSkrbH19d2hpbGUoaSE9aCk7dmFyIG89aD09Yy5wYXJlbnROb2RlJiZiLm5vZGUuaXNCbG9jayhoKXx8Yy5uZXh0U2libGluZztpZihcXFwiQkxPQ0tRVU9URVxcXCI9PWgudGFnTmFtZSl7Yy5wcmV2aW91c1NpYmxpbmcmJmIubm9kZS5pc0Jsb2NrKGMucHJldmlvdXNTaWJsaW5nKSYmYy5uZXh0U2libGluZyYmXFxcIkJSXFxcIj09Yy5uZXh0U2libGluZy50YWdOYW1lJiYoYShjLm5leHRTaWJsaW5nKS5hZnRlcihjKSxjLm5leHRTaWJsaW5nJiZcXFwiQlJcXFwiPT1jLm5leHRTaWJsaW5nLnRhZ05hbWUmJmEoYy5uZXh0U2libGluZykucmVtb3ZlKCkpO3ZhciBwPWIuaHRtbC5kZWZhdWx0VGFnKCk7aj1rK2orKHA/XFxcIjxcXFwiK3ArXFxcIj5cXFwiOlxcXCJcXFwiKSthLkZFLk1BUktFUlMrXFxcIjxicj5cXFwiKyhwP1xcXCI8L1xcXCIrcCtcXFwiPlxcXCI6XFxcIlxcXCIpK2x9ZWxzZSBqPWsraitsKyhvP1xcXCJcXFwiOmEuRkUuSU5WSVNJQkxFX1NQQUNFKSthLkZFLk1BUktFUlM7YShjKS5yZXBsYWNlV2l0aCgnPHNwYW4gaWQ9XFxcImZyLWJyZWFrXFxcIj48L3NwYW4+Jyk7dmFyIHE9Yi5ub2RlLm9wZW5UYWdTdHJpbmcoaCkrYShoKS5odG1sKCkrYi5ub2RlLmNsb3NlVGFnU3RyaW5nKGgpO3E9cS5yZXBsYWNlKC88c3BhbiBpZD1cXFwiZnItYnJlYWtcXFwiPjxcXFxcL3NwYW4+L2csaiksYShoKS5yZXBsYWNlV2l0aChxKX19ZnVuY3Rpb24gcihlKXt2YXIgZj1iLm1hcmtlcnMuaW5zZXJ0KCk7aWYoIWYpcmV0dXJuITA7Yi4kZWwuZ2V0KDApLm5vcm1hbGl6ZSgpO3ZhciBoPSExO2EoZikucGFyZW50c1VudGlsKGIuJGVsLFxcXCJCTE9DS1FVT1RFXFxcIikubGVuZ3RoPjAmJihlPSExLGg9ITApLGEoZikucGFyZW50c1VudGlsKGIuJGVsLFxcXCJURCwgVEhcXFwiKS5sZW5ndGgmJihoPSExKSxjKGYpPyFnKGYpfHxlfHxoP28oZixlLGgpOmIuY3Vyc29yTGlzdHMuX2VuZEVudGVyKGYpOmQoZik/IWcoZil8fGV8fGg/cChmLGUsaCk6Yi5jdXJzb3JMaXN0cy5fc3RhcnRFbnRlcihmKTohZyhmKXx8ZXx8aD9xKGYsZSxoKTpiLmN1cnNvckxpc3RzLl9taWRkbGVFbnRlcihmKSxuKCksYi5odG1sLmZpbGxFbXB0eUJsb2NrcygpLGIuaHRtbC5jbGVhbkVtcHR5VGFncygpLGIuY2xlYW4ubGlzdHMoKSxiLnNwYWNlcy5ub3JtYWxpemUoKSxiLnNlbGVjdGlvbi5yZXN0b3JlKCl9cmV0dXJue2VudGVyOnIsYmFja3NwYWNlOmosZGVsOm0saXNBdEVuZDpmfX0sYS5GRS5NT0RVTEVTLmRhdGE9ZnVuY3Rpb24oYSl7ZnVuY3Rpb24gYihhKXtyZXR1cm4gYX1mdW5jdGlvbiBjKGEpe2lmKCFhKXJldHVybiBhO2Zvcih2YXIgYz1cXFwiXFxcIixmPWIoXFxcImNoYXJDb2RlQXRcXFwiKSxnPWIoXFxcImZyb21DaGFyQ29kZVxcXCIpLGg9bC5pbmRleE9mKGFbMF0pLGk9MTtpPGEubGVuZ3RoLTI7aSsrKXtmb3IodmFyIGo9ZCgrK2gpLGs9YVtmXShpKSxtPVxcXCJcXFwiOy9bMC05LV0vLnRlc3QoYVtpKzFdKTspbSs9YVsrK2ldO209cGFyc2VJbnQobSwxMCl8fDAsaz1lKGssaixtKSxrXj1oLTEmMzEsYys9U3RyaW5nW2ddKGspfXJldHVybiBjfWZ1bmN0aW9uIGQoYSl7Zm9yKHZhciBiPWEudG9TdHJpbmcoKSxjPTAsZD0wO2Q8Yi5sZW5ndGg7ZCsrKWMrPXBhcnNlSW50KGIuY2hhckF0KGQpLDEwKTtyZXR1cm4gYz4xMD9jJTkrMTpjfWZ1bmN0aW9uIGUoYSxiLGMpe2Zvcih2YXIgZD1NYXRoLmFicyhjKTtkLS0gPjA7KWEtPWI7cmV0dXJuIDA+YyYmKGErPTEyMyksYX1mdW5jdGlvbiBmKGEpe3JldHVybiBhJiZcXFwibm9uZVxcXCI9PWEuY3NzKFxcXCJkaXNwbGF5XFxcIik/KGEucmVtb3ZlKCksITApOiExfWZ1bmN0aW9uIGcoKXtyZXR1cm4gZihqKXx8ZihrKX1mdW5jdGlvbiBoKCl7cmV0dXJuIGEuJGJveD8oYS4kYm94LmFwcGVuZChuKGIobihcXFwia1RERDRzcG1LRDFrbGFNQjFDN0E1UkExRzNSQTEwWUE1cWhyanV2bm1FMUQzRkQyYmNHLTdub0hFNkIySkI0QzN4WEE4V0Y2Ri0xMFJHMkMzRzNCLTIxelpFM0MzSDN4Q0ExNk5DNERDMWYxaE9GMU1CM0ItMjF3aHpRSDVVQTJXQjEwa2MxQzJGNEQzWEMyWUQ0RDFDNEYzR0YyZUoybGZjRC0xM0hGMUlFMVRDMTFUQzdXRTRUQTRkMUEyWUE2WEE0ZDFBM3lDRzJxbUItMTNHRjRBMUIxS0gxSEQyZnpmYmVRQzNURDlWRTR3ZDFIMkEyMEEyQi0yMnVqQjNuQkcyQTEzakJDMTBEM0MySEQ1RDFIMUtCMTF1RC0xNnVXRjJENEEzRi03QzlELTE3YzFFNEQ0QjNkMUQyQ0E2QjJCLTEzcWx3ekpGMk5DMkMtMTNFLTExTkQxQTN4cVVBOFVFNmJzcnJGLTdDLTIyaWExRDJDRjJIMUUyYWtDRDJPRTFISDFkbEtBNlBBNWpjeWZ6Qi0yMmNYQjRmMUMzcXZkaUM0Z2pHRzJIMmdrbEMzRC0xNndKQzFVRzRkZ2FXRTJENUc0ZzFJMkgzQjd2a3FyeEgxSDJFQzlDM0U0Z2RnektGMU9BMUE1UEY1QzRXV0MzVkE2WEE0ZTFFM1lBMllBNUhFNG9HSDRGMkgySUIxMEQzRDJOQzVHMUIxcVdBOVBENlBHNWZRQTEzQTEwWEE0QzRBM2UxSDJCQTE3a0MtMjJjbU9CMWxtb0EyZnloY3B0d1dBM1JBOEEtMTN4Qi0xMW5mMUkzZjFCN0dCM2FEM3BhdkZDMTBENWdMRjJPRzFMU0IyRDlFN2ZRQzFGNEYzd3BTQjVYRDNOa2tsaGhhRS0xMW5hS0E5Qm5JQTZEMUY1YlFBM0ExMGMxUUM2S2prdml0YzJCNkJFM0FGM0UyREE2QTRKRDJJQzFqZ0EtNjRNQjExRDZDND09XFxcIikpKSksaj1hLiRib3guZmluZChcXFwiPiBkaXY6bGFzdFxcXCIpLGs9ai5maW5kKFxcXCI+IGFcXFwiKSx2b2lkKFxcXCJydGxcXFwiPT1hLm9wdHMuZGlyZWN0aW9uJiZqLmNzcyhcXFwibGVmdFxcXCIsXFxcImF1dG9cXFwiKS5jc3MoXFxcInJpZ2h0XFxcIiwwKSkpOiExfWZ1bmN0aW9uIGkoKXt2YXIgYz1hLm9wdHMua2V5fHxbXFxcIlxcXCJdO1xcXCJzdHJpbmdcXFwiPT10eXBlb2YgYyYmKGM9W2NdKSxhLnVsPSEwO2Zvcih2YXIgZD0wO2Q8Yy5sZW5ndGg7ZCsrKXt2YXIgZT1uKGNbZF0pfHxcXFwiXFxcIjtpZighKGUhPT1uKGIobihcXFwibWNWUkRvQjFCR0lMRDdZRmUxQlRYQkE3QjY9PVxcXCIpKSkmJmUuaW5kZXhPZihtLGUubGVuZ3RoLW0ubGVuZ3RoKTwwJiZbbihcXFwiOXFxRy03YW1qbHdxPT1cXFwiKSxuKFxcXCJLQTNCM0MyQTZEMUQ1SDVIMUEzPT1cXFwiKSxuKFxcXCJRemJ6dnh5QjJ5QS05bT09XFxcIiksbihcXFwibmFhbW5naUEzZEEtMTZ4dEUtMTFDLTlCMUgtOHNjPT1cXFwiKV0uaW5kZXhPZihtKTwwKSl7YS51bD0hMTticmVha319YS51bD09PSEwJiZoKCksYS5ldmVudHMub24oXFxcImNvbnRlbnRDaGFuZ2VkXFxcIixmdW5jdGlvbigpe2EudWw9PT0hMCYmZygpJiZoKCl9KSxhLmV2ZW50cy5vbihcXFwiZGVzdHJveVxcXCIsZnVuY3Rpb24oKXtqJiZqLmxlbmd0aCYmai5yZW1vdmUoKX0sITApfXZhciBqLGssbD1cXFwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODlcXFwiLG09ZnVuY3Rpb24oKXtmb3IodmFyIGE9MCxiPWRvY3VtZW50LmRvbWFpbixjPWIuc3BsaXQoXFxcIi5cXFwiKSxkPVxcXCJfZ2RcXFwiKyhuZXcgRGF0ZSkuZ2V0VGltZSgpO2E8Yy5sZW5ndGgtMSYmLTE9PWRvY3VtZW50LmNvb2tpZS5pbmRleE9mKGQrXFxcIj1cXFwiK2QpOyliPWMuc2xpY2UoLTEtKythKS5qb2luKFxcXCIuXFxcIiksZG9jdW1lbnQuY29va2llPWQrXFxcIj1cXFwiK2QrXFxcIjtkb21haW49XFxcIitiK1xcXCI7XFxcIjtyZXR1cm4gZG9jdW1lbnQuY29va2llPWQrXFxcIj07ZXhwaXJlcz1UaHUsIDAxIEphbiAxOTcwIDAwOjAwOjAxIEdNVDtkb21haW49XFxcIitiK1xcXCI7XFxcIiwoYnx8XFxcIlxcXCIpLnJlcGxhY2UoLyheXFxcXC4qKXwoXFxcXC4qJCkvZyxcXFwiXFxcIil9KCksbj1iKGMpO3JldHVybntfaW5pdDppfX0sYS5GRS5FTlRFUl9QPTAsYS5GRS5FTlRFUl9ESVY9MSxhLkZFLkVOVEVSX0JSPTIsYS5GRS5LRVlDT0RFPXtCQUNLU1BBQ0U6OCxUQUI6OSxFTlRFUjoxMyxTSElGVDoxNixDVFJMOjE3LEFMVDoxOCxFU0M6MjcsU1BBQ0U6MzIsQVJST1dfTEVGVDozNyxBUlJPV19VUDozOCxBUlJPV19SSUdIVDozOSxBUlJPV19ET1dOOjQwLERFTEVURTo0NixaRVJPOjQ4LE9ORTo0OSxUV086NTAsVEhSRUU6NTEsRk9VUjo1MixGSVZFOjUzLFNJWDo1NCxTRVZFTjo1NSxFSUdIVDo1NixOSU5FOjU3LEZGX1NFTUlDT0xPTjo1OSxGRl9FUVVBTFM6NjEsUVVFU1RJT05fTUFSSzo2MyxBOjY1LEI6NjYsQzo2NyxEOjY4LEU6NjksRjo3MCxHOjcxLEg6NzIsSTo3MyxKOjc0LEs6NzUsTDo3NixNOjc3LE46NzgsTzo3OSxQOjgwLFE6ODEsUjo4MixTOjgzLFQ6ODQsVTo4NSxWOjg2LFc6ODcsWDo4OCxZOjg5LFo6OTAsTUVUQTo5MSxOVU1fWkVSTzo5NixOVU1fT05FOjk3LE5VTV9UV086OTgsTlVNX1RIUkVFOjk5LE5VTV9GT1VSOjEwMCxOVU1fRklWRToxMDEsTlVNX1NJWDoxMDIsTlVNX1NFVkVOOjEwMyxOVU1fRUlHSFQ6MTA0LE5VTV9OSU5FOjEwNSxOVU1fTVVMVElQTFk6MTA2LE5VTV9QTFVTOjEwNyxOVU1fTUlOVVM6MTA5LE5VTV9QRVJJT0Q6MTEwLE5VTV9ESVZJU0lPTjoxMTEsU0VNSUNPTE9OOjE4NixEQVNIOjE4OSxFUVVBTFM6MTg3LENPTU1BOjE4OCxQRVJJT0Q6MTkwLFNMQVNIOjE5MSxBUE9TVFJPUEhFOjE5MixUSUxERToxOTIsU0lOR0xFX1FVT1RFOjIyMixPUEVOX1NRVUFSRV9CUkFDS0VUOjIxOSxCQUNLU0xBU0g6MjIwLENMT1NFX1NRVUFSRV9CUkFDS0VUOjIyMX0sYS5leHRlbmQoYS5GRS5ERUZBVUxUUyx7ZW50ZXI6YS5GRS5FTlRFUl9QLG11bHRpTGluZTohMCx0YWJTcGFjZXM6MH0pLGEuRkUuTU9EVUxFUy5rZXlzPWZ1bmN0aW9uKGIpe2Z1bmN0aW9uIGMoYSl7Yi5vcHRzLm11bHRpTGluZT9iLmhlbHBlcnMuaXNJT1MoKXx8KGEucHJldmVudERlZmF1bHQoKSxhLnN0b3BQcm9wYWdhdGlvbigpLGIuc2VsZWN0aW9uLmlzQ29sbGFwc2VkKCl8fGIuc2VsZWN0aW9uLnJlbW92ZSgpLGIuY3Vyc29yLmVudGVyKCkpOihhLnByZXZlbnREZWZhdWx0KCksYS5zdG9wUHJvcGFnYXRpb24oKSl9ZnVuY3Rpb24gZChhKXthLnByZXZlbnREZWZhdWx0KCksYS5zdG9wUHJvcGFnYXRpb24oKSxiLm9wdHMubXVsdGlMaW5lJiYoYi5zZWxlY3Rpb24uaXNDb2xsYXBzZWQoKXx8Yi5zZWxlY3Rpb24ucmVtb3ZlKCksYi5jdXJzb3IuZW50ZXIoITApKX1mdW5jdGlvbiBlKGEpe2Iuc2VsZWN0aW9uLmlzQ29sbGFwc2VkKCk/Yi5jdXJzb3IuYmFja3NwYWNlKCl8fChhLnByZXZlbnREZWZhdWx0KCksYS5zdG9wUHJvcGFnYXRpb24oKSx5PSExKTooYS5wcmV2ZW50RGVmYXVsdCgpLGEuc3RvcFByb3BhZ2F0aW9uKCksYi5zZWxlY3Rpb24ucmVtb3ZlKCksYi5odG1sLmZpbGxFbXB0eUJsb2NrcygpLHk9ITEpLGIucGxhY2Vob2xkZXIucmVmcmVzaCgpfWZ1bmN0aW9uIGYoYSl7YS5wcmV2ZW50RGVmYXVsdCgpLGEuc3RvcFByb3BhZ2F0aW9uKCksXFxcIlxcXCI9PT1iLnNlbGVjdGlvbi50ZXh0KCk/Yi5jdXJzb3IuZGVsKCk6Yi5zZWxlY3Rpb24ucmVtb3ZlKCksYi5wbGFjZWhvbGRlci5yZWZyZXNoKCl9ZnVuY3Rpb24gZyhjKXtpZihiLmJyb3dzZXIubW96aWxsYSl7Yy5wcmV2ZW50RGVmYXVsdCgpLGMuc3RvcFByb3BhZ2F0aW9uKCksYi5zZWxlY3Rpb24uaXNDb2xsYXBzZWQoKXx8Yi5zZWxlY3Rpb24ucmVtb3ZlKCksYi5tYXJrZXJzLmluc2VydCgpO3ZhciBkPWIuJGVsLmZpbmQoXFxcIi5mci1tYXJrZXJcXFwiKS5nZXQoMCksZT1kLnByZXZpb3VzU2libGluZyxmPWQubmV4dFNpYmxpbmc7IWYmJmQucGFyZW50Tm9kZSYmXFxcIkFcXFwiPT1kLnBhcmVudE5vZGUudGFnTmFtZT8oYShkKS5wYXJlbnQoKS5hZnRlcihcXFwiJm5ic3A7XFxcIithLkZFLk1BUktFUlMpLGEoZCkucmVtb3ZlKCkpOihlJiZlLm5vZGVUeXBlPT1Ob2RlLlRFWFRfTk9ERSYmMT09ZS50ZXh0Q29udGVudC5sZW5ndGgmJjE2MD09ZS50ZXh0Q29udGVudC5jaGFyQ29kZUF0KDApP2EoZSkuYWZ0ZXIoXFxcIiBcXFwiKTphKGQpLmJlZm9yZShcXFwiJm5ic3A7XFxcIiksYShkKS5yZXBsYWNlV2l0aChhLkZFLk1BUktFUlMpKSxiLnNlbGVjdGlvbi5yZXN0b3JlKCl9fWZ1bmN0aW9uIGgoKXtpZihiLmJyb3dzZXIubW96aWxsYSYmYi5zZWxlY3Rpb24uaXNDb2xsYXBzZWQoKSYmIUIpe3ZhciBhPWIuc2VsZWN0aW9uLnJhbmdlcygwKSxjPWEuc3RhcnRDb250YWluZXIsZD1hLnN0YXJ0T2Zmc2V0O2MmJmMubm9kZVR5cGU9PU5vZGUuVEVYVF9OT0RFJiZkPD1jLnRleHRDb250ZW50Lmxlbmd0aCYmZD4wJiYzMj09Yy50ZXh0Q29udGVudC5jaGFyQ29kZUF0KGQtMSkmJihiLnNlbGVjdGlvbi5zYXZlKCksYi5zcGFjZXMubm9ybWFsaXplKCksYi5zZWxlY3Rpb24ucmVzdG9yZSgpKX19ZnVuY3Rpb24gaSgpe2Iuc2VsZWN0aW9uLmlzRnVsbCgpJiZzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7dmFyIGM9Yi5odG1sLmRlZmF1bHRUYWcoKTtjP2IuJGVsLmh0bWwoXFxcIjxcXFwiK2MrXFxcIj5cXFwiK2EuRkUuTUFSS0VSUytcXFwiPGJyLz48L1xcXCIrYytcXFwiPlxcXCIpOmIuJGVsLmh0bWwoYS5GRS5NQVJLRVJTK1xcXCI8YnIvPlxcXCIpLGIuc2VsZWN0aW9uLnJlc3RvcmUoKSxiLnBsYWNlaG9sZGVyLnJlZnJlc2goKSxiLmJ1dHRvbi5idWxrUmVmcmVzaCgpLGIudW5kby5zYXZlU3RlcCgpfSwwKX1mdW5jdGlvbiBqKGEpe2lmKGIub3B0cy50YWJTcGFjZXM+MClpZihiLnNlbGVjdGlvbi5pc0NvbGxhcHNlZCgpKXtiLnVuZG8uc2F2ZVN0ZXAoKSxhLnByZXZlbnREZWZhdWx0KCksYS5zdG9wUHJvcGFnYXRpb24oKTtmb3IodmFyIGM9XFxcIlxcXCIsZD0wO2Q8Yi5vcHRzLnRhYlNwYWNlcztkKyspYys9XFxcIiZuYnNwO1xcXCI7Yi5odG1sLmluc2VydChjKSxiLnBsYWNlaG9sZGVyLnJlZnJlc2goKSxiLnVuZG8uc2F2ZVN0ZXAoKX1lbHNlIGEucHJldmVudERlZmF1bHQoKSxhLnN0b3BQcm9wYWdhdGlvbigpLGEuc2hpZnRLZXk/Yi5jb21tYW5kcy5vdXRkZW50KCk6Yi5jb21tYW5kcy5pbmRlbnQoKX1mdW5jdGlvbiBrKGEpe0I9ITF9ZnVuY3Rpb24gbCgpe3JldHVybiBCfWZ1bmN0aW9uIG0oaCl7Yi5ldmVudHMuZGlzYWJsZUJsdXIoKSx5PSEwO3ZhciBpPWgud2hpY2g7aWYoMTY9PT1pKXJldHVybiEwO2lmKDIyOT09PWkpcmV0dXJuIEI9ITAsITA7Qj0hMTt2YXIgaz10KGkpJiYhcihoKSxsPWk9PWEuRkUuS0VZQ09ERS5CQUNLU1BBQ0V8fGk9PWEuRkUuS0VZQ09ERS5ERUxFVEU7aWYoKGIuc2VsZWN0aW9uLmlzRnVsbCgpJiYhYi5vcHRzLmtlZXBGb3JtYXRPbkRlbGV0ZSYmIWIucGxhY2Vob2xkZXIuaXNWaXNpYmxlKCl8fGwmJmIucGxhY2Vob2xkZXIuaXNWaXNpYmxlKCkmJmIub3B0cy5rZWVwRm9ybWF0T25EZWxldGUpJiYoa3x8bCkpe3ZhciBtPWIuaHRtbC5kZWZhdWx0VGFnKCk7aWYobT9iLiRlbC5odG1sKFxcXCI8XFxcIittK1xcXCI+XFxcIithLkZFLk1BUktFUlMrXFxcIjxici8+PC9cXFwiK20rXFxcIj5cXFwiKTpiLiRlbC5odG1sKGEuRkUuTUFSS0VSUytcXFwiPGJyLz5cXFwiKSxiLnNlbGVjdGlvbi5yZXN0b3JlKCksIXQoaSkpcmV0dXJuIGgucHJldmVudERlZmF1bHQoKSwhMH1pPT1hLkZFLktFWUNPREUuRU5URVI/aC5zaGlmdEtleT9kKGgpOmMoaCk6aSE9YS5GRS5LRVlDT0RFLkJBQ0tTUEFDRXx8cihoKXx8aC5hbHRLZXk/aSE9YS5GRS5LRVlDT0RFLkRFTEVURXx8cihoKXx8aC5hbHRLZXk/aT09YS5GRS5LRVlDT0RFLlNQQUNFP2coaCk6aT09YS5GRS5LRVlDT0RFLlRBQj9qKGgpOnIoaCl8fCF0KGgud2hpY2gpfHxiLnNlbGVjdGlvbi5pc0NvbGxhcHNlZCgpfHxoLmN0cmxLZXl8fGIuc2VsZWN0aW9uLnJlbW92ZSgpOmIucGxhY2Vob2xkZXIuaXNWaXNpYmxlKCk/KGgucHJldmVudERlZmF1bHQoKSxoLnN0b3BQcm9wYWdhdGlvbigpKTpmKGgpOmIucGxhY2Vob2xkZXIuaXNWaXNpYmxlKCk/KGgucHJldmVudERlZmF1bHQoKSxoLnN0b3BQcm9wYWdhdGlvbigpKTplKGgpLGIuZXZlbnRzLmVuYWJsZUJsdXIoKX1mdW5jdGlvbiBuKGMpe2Zvcih2YXIgZD0wO2Q8Yy5sZW5ndGg7ZCsrKWNbZF0ubm9kZVR5cGU9PU5vZGUuVEVYVF9OT0RFJiYvXFxcXHUyMDBCL2dpLnRlc3QoY1tkXS50ZXh0Q29udGVudCk/KGNbZF0udGV4dENvbnRlbnQ9Y1tkXS50ZXh0Q29udGVudC5yZXBsYWNlKC9cXFxcdTIwMEIvZ2ksXFxcIlxcXCIpLDA9PT1jW2RdLnRleHRDb250ZW50Lmxlbmd0aCYmYShjW2RdKS5yZW1vdmUoKSk6Y1tkXS5ub2RlVHlwZT09Tm9kZS5FTEVNRU5UX05PREUmJlxcXCJJRlJBTUVcXFwiIT1jW2RdLm5vZGVUeXBlJiZuKGIubm9kZS5jb250ZW50cyhjW2RdKSl9ZnVuY3Rpb24gbygpe2lmKCFiLiR3cClyZXR1cm4hMDt2YXIgYztiLm9wdHMuaGVpZ2h0fHxiLm9wdHMuaGVpZ2h0TWF4PyhjPWIucG9zaXRpb24uZ2V0Qm91bmRpbmdSZWN0KCkudG9wLGIuaGVscGVycy5pc0lPUygpJiYoYy09YShiLm9fd2luKS5zY3JvbGxUb3AoKSksYi5vcHRzLmlmcmFtZSYmKGMrPWIuJGlmcmFtZS5vZmZzZXQoKS50b3ApLGM+Yi4kd3Aub2Zmc2V0KCkudG9wLWEoYi5vX3dpbikuc2Nyb2xsVG9wKCkrYi4kd3AuaGVpZ2h0KCktMjAmJmIuJHdwLnNjcm9sbFRvcChjK2IuJHdwLnNjcm9sbFRvcCgpLShiLiR3cC5oZWlnaHQoKStiLiR3cC5vZmZzZXQoKS50b3ApK2EoYi5vX3dpbikuc2Nyb2xsVG9wKCkrMjApKTooYz1iLnBvc2l0aW9uLmdldEJvdW5kaW5nUmVjdCgpLnRvcCxiLm9wdHMudG9vbGJhckJvdHRvbSYmKGMrPWIub3B0cy50b29sYmFyU3RpY2t5T2Zmc2V0KSxiLmhlbHBlcnMuaXNJT1MoKSYmKGMtPWEoYi5vX3dpbikuc2Nyb2xsVG9wKCkpLGIub3B0cy5pZnJhbWUmJihjKz1iLiRpZnJhbWUub2Zmc2V0KCkudG9wKSxjKz1iLm9wdHMudG9vbGJhclN0aWNreU9mZnNldCxjPmIub193aW4uaW5uZXJIZWlnaHQtMjAmJmEoYi5vX3dpbikuc2Nyb2xsVG9wKGMrYShiLm9fd2luKS5zY3JvbGxUb3AoKS1iLm9fd2luLmlubmVySGVpZ2h0KzIwKSxjPWIucG9zaXRpb24uZ2V0Qm91bmRpbmdSZWN0KCkudG9wLGIub3B0cy50b29sYmFyQm90dG9tfHwoYy09Yi5vcHRzLnRvb2xiYXJTdGlja3lPZmZzZXQpLGIuaGVscGVycy5pc0lPUygpJiYoYy09YShiLm9fd2luKS5zY3JvbGxUb3AoKSksYi5vcHRzLmlmcmFtZSYmKGMrPWIuJGlmcmFtZS5vZmZzZXQoKS50b3ApLGM8Yi4kdGIuaGVpZ2h0KCkrMjAmJmEoYi5vX3dpbikuc2Nyb2xsVG9wKGMrYShiLm9fd2luKS5zY3JvbGxUb3AoKS1iLiR0Yi5oZWlnaHQoKS0yMCkpfWZ1bmN0aW9uIHAoKXt2YXIgYz1iLnNlbGVjdGlvbi5lbGVtZW50KCksZD1iLm5vZGUuYmxvY2tQYXJlbnQoYyk7aWYoZCYmXFxcIkRJVlxcXCI9PWQudGFnTmFtZSYmYi5zZWxlY3Rpb24uaW5mbyhkKS5hdFN0YXJ0KXt2YXIgZT1iLmh0bWwuZGVmYXVsdFRhZygpO2QucHJldmlvdXNTaWJsaW5nJiZcXFwiRElWXFxcIiE9ZC5wcmV2aW91c1NpYmxpbmcudGFnTmFtZSYmZSYmXFxcImRpdlxcXCIhPWUmJihiLnNlbGVjdGlvbi5zYXZlKCksYShkKS5yZXBsYWNlV2l0aChcXFwiPFxcXCIrZStcXFwiPlxcXCIrZC5pbm5lckhUTUwrXFxcIjwvXFxcIitlK1xcXCI+XFxcIiksYi5zZWxlY3Rpb24ucmVzdG9yZSgpKX19ZnVuY3Rpb24gcShjKXtpZihCKXJldHVybiBCPSExLCExO2lmKCFiLnNlbGVjdGlvbi5pc0NvbGxhcHNlZCgpKXJldHVybiEwO2lmKGMmJihjLndoaWNoPT09YS5GRS5LRVlDT0RFLk1FVEF8fGMud2hpY2g9PWEuRkUuS0VZQ09ERS5DVFJMKSlyZXR1cm4hMDtpZihjJiZzKGMud2hpY2gpKXJldHVybiEwO2MmJmMud2hpY2g9PWEuRkUuS0VZQ09ERS5FTlRFUiYmYi5oZWxwZXJzLmlzSU9TKCkmJnAoKSxjJiYoYy53aGljaD09YS5GRS5LRVlDT0RFLkVOVEVSfHxjLndoaWNoPT1hLkZFLktFWUNPREUuQkFDS1NQQUNFfHxjLndoaWNoPj0zNyYmYy53aGljaDw9NDAmJiFiLmJyb3dzZXIubXNpZSkmJihjLndoaWNoPT1hLkZFLktFWUNPREUuQkFDS1NQQUNFJiZ5fHxvKCkpO3ZhciBkPUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGIuJGVsLmdldCgwKS5xdWVyeVNlbGVjdG9yQWxsKGIuaHRtbC5ibG9ja1RhZ3NRdWVyeSgpKSwwKTtkLnB1c2goYi4kZWwuZ2V0KDApKTtmb3IodmFyIGU9W10sZj0wO2Y8ZC5sZW5ndGg7ZisrKWlmKFtcXFwiVERcXFwiLFxcXCJUSFxcXCJdLmluZGV4T2YoZFtmXS50YWdOYW1lKTwwKWZvcih2YXIgZz1kW2ZdLmNoaWxkcmVuLGg9MDtoPGcubGVuZ3RoO2grKylcXFwiQlJcXFwiPT1nW2hdLnRhZ05hbWUmJmUucHVzaChnW2hdKTtmb3IodmFyIGQ9W10sZj0wO2Y8ZS5sZW5ndGg7ZisrKXt2YXIgaT1lW2ZdLGo9aS5wcmV2aW91c1NpYmxpbmcsaz1pLm5leHRTaWJsaW5nLGw9Yi5ub2RlLmJsb2NrUGFyZW50KGkpfHxiLiRlbC5nZXQoMCk7aiYmbCYmXFxcIkJSXFxcIiE9ai50YWdOYW1lJiYhYi5ub2RlLmlzQmxvY2soaikmJiFrJiZhKGwpLnRleHQoKS5yZXBsYWNlKC9cXFxcdTIwMEIvZyxcXFwiXFxcIikubGVuZ3RoPjAmJmEoaikudGV4dCgpLmxlbmd0aD4wJiYoYi4kZWwuaXMobCkmJiFrJiZiLm9wdHMuZW50ZXI9PWEuRkUuRU5URVJfQlImJmIuYnJvd3Nlci5tc2llfHwoYi5zZWxlY3Rpb24uc2F2ZSgpLGEoaSkucmVtb3ZlKCksYi5zZWxlY3Rpb24ucmVzdG9yZSgpKSl9ZT1bXTt2YXIgbT1mdW5jdGlvbihiKXtpZighYilyZXR1cm4hMTt2YXIgYz1hKGIpLmh0bWwoKTtyZXR1cm4gYz1jLnJlcGxhY2UoLzxzcGFuW14+XSo/IGNsYXNzXFxcXHMqPVxcXFxzKltcXFwiJ10/ZnItbWFya2VyW1xcXCInXT9bXj5dKz5cXFxcdTIwMGI8XFxcXC9zcGFuPi9naSxcXFwiXFxcIiksYyYmL1xcXFx1MjAwQi8udGVzdChjKSYmYy5yZXBsYWNlKC9cXFxcdTIwMEIvZ2ksXFxcIlxcXCIpLmxlbmd0aD4wPyEwOiExfSxxPWZ1bmN0aW9uKGEpe3ZhciBjPS9bXFxcXHUzMDQxLVxcXFx1MzA5NlxcXFx1MzBBMC1cXFxcdTMwRkZcXFxcdTRFMDAtXFxcXHU5RkZGXFxcXHUzMTMwLVxcXFx1MzE4RlxcXFx1QUMwMC1cXFxcdUQ3QUZdL2dpO3JldHVybiFiLmhlbHBlcnMuaXNJT1MoKXx8MD09PSgoYS50ZXh0Q29udGVudHx8XFxcIlxcXCIpLm1hdGNoKGMpfHxbXSkubGVuZ3RofSxyPWIuc2VsZWN0aW9uLmVsZW1lbnQoKTttKHIpJiYwPT09YShyKS5maW5kKFxcXCJsaVxcXCIpLmxlbmd0aCYmIWEocikuaGFzQ2xhc3MoXFxcImZyLW1hcmtlclxcXCIpJiZcXFwiSUZSQU1FXFxcIiE9ci50YWdOYW1lJiZxKHIpJiYoYi5zZWxlY3Rpb24uc2F2ZSgpLG4oYi5ub2RlLmNvbnRlbnRzKHIpKSxiLnNlbGVjdGlvbi5yZXN0b3JlKCkpLCFiLmJyb3dzZXIubW96aWxsYSYmYi5odG1sLmRvTm9ybWFsaXplKHIpJiYoYi5zZWxlY3Rpb24uc2F2ZSgpLGIuc3BhY2VzLm5vcm1hbGl6ZSgpLGIuc2VsZWN0aW9uLnJlc3RvcmUoKSl9ZnVuY3Rpb24gcihhKXtpZigtMSE9bmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKFxcXCJNYWMgT1MgWFxcXCIpKXtpZihhLm1ldGFLZXkmJiFhLmFsdEtleSlyZXR1cm4hMH1lbHNlIGlmKGEuY3RybEtleSYmIWEuYWx0S2V5KXJldHVybiEwO3JldHVybiExfWZ1bmN0aW9uIHMoYil7cmV0dXJuIGI+PWEuRkUuS0VZQ09ERS5BUlJPV19MRUZUJiZiPD1hLkZFLktFWUNPREUuQVJST1dfRE9XTj8hMDp2b2lkIDB9ZnVuY3Rpb24gdChjKXtpZihjPj1hLkZFLktFWUNPREUuWkVSTyYmYzw9YS5GRS5LRVlDT0RFLk5JTkUpcmV0dXJuITA7aWYoYz49YS5GRS5LRVlDT0RFLk5VTV9aRVJPJiZjPD1hLkZFLktFWUNPREUuTlVNX01VTFRJUExZKXJldHVybiEwO2lmKGM+PWEuRkUuS0VZQ09ERS5BJiZjPD1hLkZFLktFWUNPREUuWilyZXR1cm4hMDtpZihiLmJyb3dzZXIud2Via2l0JiYwPT09YylyZXR1cm4hMDtzd2l0Y2goYyl7Y2FzZSBhLkZFLktFWUNPREUuU1BBQ0U6Y2FzZSBhLkZFLktFWUNPREUuUVVFU1RJT05fTUFSSzpjYXNlIGEuRkUuS0VZQ09ERS5OVU1fUExVUzpjYXNlIGEuRkUuS0VZQ09ERS5OVU1fTUlOVVM6Y2FzZSBhLkZFLktFWUNPREUuTlVNX1BFUklPRDpjYXNlIGEuRkUuS0VZQ09ERS5OVU1fRElWSVNJT046Y2FzZSBhLkZFLktFWUNPREUuU0VNSUNPTE9OOmNhc2UgYS5GRS5LRVlDT0RFLkZGX1NFTUlDT0xPTjpjYXNlIGEuRkUuS0VZQ09ERS5EQVNIOmNhc2UgYS5GRS5LRVlDT0RFLkVRVUFMUzpjYXNlIGEuRkUuS0VZQ09ERS5GRl9FUVVBTFM6Y2FzZSBhLkZFLktFWUNPREUuQ09NTUE6Y2FzZSBhLkZFLktFWUNPREUuUEVSSU9EOmNhc2UgYS5GRS5LRVlDT0RFLlNMQVNIOmNhc2UgYS5GRS5LRVlDT0RFLkFQT1NUUk9QSEU6Y2FzZSBhLkZFLktFWUNPREUuU0lOR0xFX1FVT1RFOmNhc2UgYS5GRS5LRVlDT0RFLk9QRU5fU1FVQVJFX0JSQUNLRVQ6Y2FzZSBhLkZFLktFWUNPREUuQkFDS1NMQVNIOmNhc2UgYS5GRS5LRVlDT0RFLkNMT1NFX1NRVUFSRV9CUkFDS0VUOnJldHVybiEwO2RlZmF1bHQ6cmV0dXJuITF9fWZ1bmN0aW9uIHUoYyl7dmFyIGQ9Yy53aGljaDtyZXR1cm4gcihjKXx8ZD49MzcmJjQwPj1kfHwhdChkKSYmZCE9YS5GRS5LRVlDT0RFLkRFTEVURSYmZCE9YS5GRS5LRVlDT0RFLkJBQ0tTUEFDRSYmZCE9YS5GRS5LRVlDT0RFLkVOVEVSPyEwOih6fHwoQT1iLnNuYXBzaG90LmdldCgpKSxjbGVhclRpbWVvdXQoeiksdm9pZCh6PXNldFRpbWVvdXQoZnVuY3Rpb24oKXt6PW51bGwsYi51bmRvLnNhdmVTdGVwKCl9LE1hdGgubWF4KDI1MCxiLm9wdHMudHlwaW5nVGltZXIpKSkpfWZ1bmN0aW9uIHYoYSl7cmV0dXJuIHIoYSk/ITA6dm9pZChBJiZ6JiYoYi51bmRvLnNhdmVTdGVwKEEpLEE9bnVsbCkpfWZ1bmN0aW9uIHcoKXt6JiYoY2xlYXJUaW1lb3V0KHopLGIudW5kby5zYXZlU3RlcCgpLEE9bnVsbCl9ZnVuY3Rpb24geCgpe2lmKGIuZXZlbnRzLm9uKFxcXCJrZXlkb3duXFxcIix1KSxiLmV2ZW50cy5vbihcXFwiaW5wdXRcXFwiLGgpLGIuZXZlbnRzLm9uKFxcXCJrZXl1cCBpbnB1dFxcXCIsdiksYi5ldmVudHMub24oXFxcImtleXByZXNzXFxcIixrKSxiLmV2ZW50cy5vbihcXFwia2V5ZG93blxcXCIsbSksYi5ldmVudHMub24oXFxcImtleXVwXFxcIixxKSxiLmV2ZW50cy5vbihcXFwiaHRtbC5pbnNlcnRlZFxcXCIscSksYi5ldmVudHMub24oXFxcImN1dFxcXCIsaSksYi4kZWwuZ2V0KDApLm1zR2V0SW5wdXRDb250ZXh0KXRyeXtiLiRlbC5nZXQoMCkubXNHZXRJbnB1dENvbnRleHQoKS5hZGRFdmVudExpc3RlbmVyKFxcXCJNU0NhbmRpZGF0ZVdpbmRvd1Nob3dcXFwiLGZ1bmN0aW9uKCl7Qj0hMH0pLGIuJGVsLmdldCgwKS5tc0dldElucHV0Q29udGV4dCgpLmFkZEV2ZW50TGlzdGVuZXIoXFxcIk1TQ2FuZGlkYXRlV2luZG93SGlkZVxcXCIsZnVuY3Rpb24oKXtCPSExLHEoKX0pfWNhdGNoKGEpe319dmFyIHkseixBLEI9ITE7cmV0dXJue19pbml0OngsY3RybEtleTpyLGlzQ2hhcmFjdGVyOnQsaXNBcnJvdzpzLGZvcmNlVW5kbzp3LGlzSU1FOmx9fSxhLmV4dGVuZChhLkZFLkRFRkFVTFRTLHtwYXN0ZVBsYWluOiExLHBhc3RlRGVuaWVkVGFnczpbXFxcImNvbGdyb3VwXFxcIixcXFwiY29sXFxcIl0scGFzdGVEZW5pZWRBdHRyczpbXFxcImNsYXNzXFxcIixcXFwiaWRcXFwiLFxcXCJzdHlsZVxcXCJdLHBhc3RlQWxsb3dMb2NhbEltYWdlczohMX0pLGEuRkUuTU9EVUxFUy5wYXN0ZT1mdW5jdGlvbihiKXtmdW5jdGlvbiBjKGMpe2EuRkUuY29waWVkX2h0bWw9Yi5odG1sLmdldFNlbGVjdGVkKCksYS5GRS5jb3BpZWRfdGV4dD1hKFxcXCI8ZGl2PlxcXCIpLmh0bWwoYS5GRS5jb3BpZWRfaHRtbCkudGV4dCgpLFxcXCJjdXRcXFwiPT1jLnR5cGUmJihiLnVuZG8uc2F2ZVN0ZXAoKSxzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7Yi5odG1sLndyYXAoKSxiLmV2ZW50cy5mb2N1cygpLGIudW5kby5zYXZlU3RlcCgpfSwwKSl9ZnVuY3Rpb24gZChhKXtpZihvKXJldHVybiExO2lmKGEub3JpZ2luYWxFdmVudCYmKGE9YS5vcmlnaW5hbEV2ZW50KSxiLmV2ZW50cy50cmlnZ2VyKFxcXCJwYXN0ZS5iZWZvcmVcXFwiLFthXSk9PT0hMSlyZXR1cm4hMTtpZihsPWIuJHdpbi5zY3JvbGxUb3AoKSxhJiZhLmNsaXBib2FyZERhdGEmJmEuY2xpcGJvYXJkRGF0YS5nZXREYXRhKXt2YXIgYz1cXFwiXFxcIixkPWEuY2xpcGJvYXJkRGF0YS50eXBlcztpZihiLmhlbHBlcnMuaXNBcnJheShkKSlmb3IodmFyIGY9MDtmPGQubGVuZ3RoO2YrKyljKz1kW2ZdK1xcXCI7XFxcIjtlbHNlIGM9ZDtpZihtPVxcXCJcXFwiLC90ZXh0XFxcXC9odG1sLy50ZXN0KGMpP209YS5jbGlwYm9hcmREYXRhLmdldERhdGEoXFxcInRleHQvaHRtbFxcXCIpOi90ZXh0XFxcXC9ydGYvLnRlc3QoYykmJmIuYnJvd3Nlci5zYWZhcmk/bT1hLmNsaXBib2FyZERhdGEuZ2V0RGF0YShcXFwidGV4dC9ydGZcXFwiKTovdGV4dFxcXFwvcGxhaW4vLnRlc3QoYykmJiF0aGlzLmJyb3dzZXIubW96aWxsYSYmKG09Yi5odG1sLmVzY2FwZUVudGl0aWVzKGEuY2xpcGJvYXJkRGF0YS5nZXREYXRhKFxcXCJ0ZXh0L3BsYWluXFxcIikpLnJlcGxhY2UoL1xcXFxuL2csXFxcIjxicj5cXFwiKSksXFxcIlxcXCIhPT1tKXJldHVybiBoKCksYS5wcmV2ZW50RGVmYXVsdCYmKGEuc3RvcFByb3BhZ2F0aW9uKCksYS5wcmV2ZW50RGVmYXVsdCgpKSwhMTttPW51bGx9ZSgpfWZ1bmN0aW9uIGUoKXtiLnNlbGVjdGlvbi5zYXZlKCksYi5ldmVudHMuZGlzYWJsZUJsdXIoKSxtPW51bGwsbj9uLmh0bWwoXFxcIlxcXCIpOihuPWEoJzxkaXYgY29udGVudGVkaXRhYmxlPVxcXCJ0cnVlXFxcIiBzdHlsZT1cXFwicG9zaXRpb246IGZpeGVkOyB0b3A6IDA7IGxlZnQ6IC05OTk5cHg7IGhlaWdodDogMTAwJTsgd2lkdGg6IDA7IHdvcmQtYnJlYWs6IGJyZWFrLWFsbDsgb3ZlcmZsb3c6aGlkZGVuOyB6LWluZGV4OiA5OTk5OyBsaW5lLWhlaWdodDogMTQwJTtcXFwiIHRhYmluZGV4PVxcXCItMVxcXCI+PC9kaXY+JyksYi4kYm94LmFmdGVyKG4pLGIuZXZlbnRzLm9uKFxcXCJkZXN0cm95XFxcIixmdW5jdGlvbigpe24ucmVtb3ZlKCl9KSksbi5mb2N1cygpLGIud2luLnNldFRpbWVvdXQoaCwxKX1mdW5jdGlvbiBmKGMpe2M9Yy5yZXBsYWNlKC88cCguKj8pY2xhc3M9XFxcIj8nP01zb0xpc3RQYXJhZ3JhcGhcXFwiPyc/IChbXFxcXHNcXFxcU10qPyk+KFtcXFxcc1xcXFxTXSo/KTxcXFxcL3A+L2dpLFxcXCI8dWw+PGxpPiQzPC9saT48L3VsPlxcXCIpLGM9Yy5yZXBsYWNlKC88cCguKj8pY2xhc3M9XFxcIj8nP051bWJlcmVkVGV4dFxcXCI/Jz8gKFtcXFxcc1xcXFxTXSo/KT4oW1xcXFxzXFxcXFNdKj8pPFxcXFwvcD4vZ2ksXFxcIjxvbD48bGk+JDM8L2xpPjwvb2w+XFxcIiksYz1jLnJlcGxhY2UoLzxwKC4qPyljbGFzcz1cXFwiPyc/TXNvTGlzdFBhcmFncmFwaEN4U3BGaXJzdFxcXCI/Jz8oW1xcXFxzXFxcXFNdKj8pKGxldmVsXFxcXGQpPyhbXFxcXHNcXFxcU10qPyk+KFtcXFxcc1xcXFxTXSo/KTxcXFxcL3A+L2dpLFxcXCI8dWw+PGxpJDM+JDU8L2xpPlxcXCIpLGM9Yy5yZXBsYWNlKC88cCguKj8pY2xhc3M9XFxcIj8nP051bWJlcmVkVGV4dEN4U3BGaXJzdFxcXCI/Jz8oW1xcXFxzXFxcXFNdKj8pKGxldmVsXFxcXGQpPyhbXFxcXHNcXFxcU10qPyk+KFtcXFxcc1xcXFxTXSo/KTxcXFxcL3A+L2dpLFxcXCI8b2w+PGxpJDM+JDU8L2xpPlxcXCIpLGM9Yy5yZXBsYWNlKC88cCguKj8pY2xhc3M9XFxcIj8nP01zb0xpc3RQYXJhZ3JhcGhDeFNwTWlkZGxlXFxcIj8nPyhbXFxcXHNcXFxcU10qPykobGV2ZWxcXFxcZCk/KFtcXFxcc1xcXFxTXSo/KT4oW1xcXFxzXFxcXFNdKj8pPFxcXFwvcD4vZ2ksXFxcIjxsaSQzPiQ1PC9saT5cXFwiKSxjPWMucmVwbGFjZSgvPHAoLio/KWNsYXNzPVxcXCI/Jz9OdW1iZXJlZFRleHRDeFNwTWlkZGxlXFxcIj8nPyhbXFxcXHNcXFxcU10qPykobGV2ZWxcXFxcZCk/KFtcXFxcc1xcXFxTXSo/KT4oW1xcXFxzXFxcXFNdKj8pPFxcXFwvcD4vZ2ksXFxcIjxsaSQzPiQ1PC9saT5cXFwiKSxjPWMucmVwbGFjZSgvPHAoLio/KWNsYXNzPVxcXCI/Jz9Nc29MaXN0QnVsbGV0XFxcIj8nPyhbXFxcXHNcXFxcU10qPykobGV2ZWxcXFxcZCk/KFtcXFxcc1xcXFxTXSo/KT4oW1xcXFxzXFxcXFNdKj8pPFxcXFwvcD4vZ2ksXFxcIjxsaSQzPiQ1PC9saT5cXFwiKSxjPWMucmVwbGFjZSgvPHAoLio/KWNsYXNzPVxcXCI/Jz9Nc29MaXN0UGFyYWdyYXBoQ3hTcExhc3RcXFwiPyc/KFtcXFxcc1xcXFxTXSo/KShsZXZlbFxcXFxkKT8oW1xcXFxzXFxcXFNdKj8pPihbXFxcXHNcXFxcU10qPyk8XFxcXC9wPi9naSxcXFwiPGxpJDM+JDU8L2xpPjwvdWw+XFxcIiksYz1jLnJlcGxhY2UoLzxwKC4qPyljbGFzcz1cXFwiPyc/TnVtYmVyZWRUZXh0Q3hTcExhc3RcXFwiPyc/KFtcXFxcc1xcXFxTXSo/KShsZXZlbFxcXFxkKT8oW1xcXFxzXFxcXFNdKj8pPihbXFxcXHNcXFxcU10qPyk8XFxcXC9wPi9naSxcXFwiPGxpJDM+JDU8L2xpPjwvb2w+XFxcIiksYz1jLnJlcGxhY2UoLzxzcGFuKFtePF0qPylzdHlsZT1cXFwiPyc/bXNvLWxpc3Q6SWdub3JlXFxcIj8nPyhbXFxcXHNcXFxcU10qPyk+KFtcXFxcc1xcXFxTXSo/KTxzcGFuL2dpLFxcXCI8c3Bhbj48c3BhblxcXCIpLGM9Yy5yZXBsYWNlKC88IS0tXFxcXFtpZiBcXFxcIXN1cHBvcnRMaXN0c1xcXFxdLS0+KFtcXFxcc1xcXFxTXSo/KTwhLS1cXFxcW2VuZGlmXFxcXF0tLT4vZ2ksXFxcIlxcXCIpLGM9Yy5yZXBsYWNlKC88IVxcXFxbaWYgXFxcXCFzdXBwb3J0TGlzdHNcXFxcXT4oW1xcXFxzXFxcXFNdKj8pPCFcXFxcW2VuZGlmXFxcXF0+L2dpLFxcXCJcXFwiKSxjPWMucmVwbGFjZSgvKFxcXFxufFxcXFxyfCBjbGFzcz0oXFxcIik/TXNvW2EtekEtWjAtOV0rKFxcXCIpPykvZ2ksXFxcIiBcXFwiKSxjPWMucmVwbGFjZSgvPCEtLVtcXFxcc1xcXFxTXSo/LS0+L2dpLFxcXCJcXFwiKSxjPWMucmVwbGFjZSgvPChcXFxcLykqKG1ldGF8bGlua3xzcGFufFxcXFxcXFxcP3htbDp8c3QxOnxvOnxmb250KSguKj8pPi9naSxcXFwiXFxcIik7Zm9yKHZhciBkPVtcXFwic3R5bGVcXFwiLFxcXCJzY3JpcHRcXFwiLFxcXCJhcHBsZXRcXFwiLFxcXCJlbWJlZFxcXCIsXFxcIm5vZnJhbWVzXFxcIixcXFwibm9zY3JpcHRcXFwiXSxlPTA7ZTxkLmxlbmd0aDtlKyspe3ZhciBmPW5ldyBSZWdFeHAoXFxcIjxcXFwiK2RbZV0rXFxcIi4qP1xcXCIrZFtlXStcXFwiKC4qPyk+XFxcIixcXFwiZ2lcXFwiKTtjPWMucmVwbGFjZShmLFxcXCJcXFwiKX1jPWMucmVwbGFjZSgvJm5ic3A7L2dpLFxcXCIgXFxcIiksYz1jLnJlcGxhY2UoLzx0ZChbXj5dKik+PFxcXFwvdGQ+L2csXFxcIjx0ZCQxPjxicj48L3RkPlxcXCIpLGM9Yy5yZXBsYWNlKC88dGgoW14+XSopPjxcXFxcL3RoPi9nLFxcXCI8dGgkMT48YnI+PC90aD5cXFwiKTt2YXIgZztkbyBnPWMsYz1jLnJlcGxhY2UoLzxbXlxcXFwvPl1bXj5dKj48XFxcXC9bXj5dKz4vZ2ksXFxcIlxcXCIpO3doaWxlKGMhPWcpO2M9Yy5yZXBsYWNlKC88bGlsZXZlbChbXjFdKShbXj5dKik+L2dpLCc8bGkgZGF0YS1pbmRlbnQ9XFxcInRydWVcXFwiJDI+JyksYz1jLnJlcGxhY2UoLzxsaWxldmVsMShbXj5dKik+L2dpLFxcXCI8bGkkMT5cXFwiKSxjPWIuY2xlYW4uaHRtbChjLGIub3B0cy5wYXN0ZURlbmllZFRhZ3MsYi5vcHRzLnBhc3RlRGVuaWVkQXR0cnMpLGM9Yy5yZXBsYWNlKC88YT4oLltePF0rKTxcXFxcL2E+L2dpLFxcXCIkMVxcXCIpLGM9Yy5yZXBsYWNlKC88YnI+ICovZyxcXFwiPGJyPlxcXCIpO3ZhciBoPWEoXFxcIjxkaXY+XFxcIikuaHRtbChjKTtyZXR1cm4gaC5maW5kKFxcXCJsaVtkYXRhLWluZGVudF1cXFwiKS5lYWNoKGZ1bmN0aW9uKGIsYyl7dmFyIGQ9YShjKTtpZihkLnByZXYoXFxcImxpXFxcIikubGVuZ3RoPjApe3ZhciBlPWQucHJldihcXFwibGlcXFwiKS5maW5kKFxcXCI+IHVsLCA+IG9sXFxcIik7MD09PWUubGVuZ3RoJiYoZT1hKFxcXCJ1bFxcXCIpLGQucHJldihcXFwibGlcXFwiKS5hcHBlbmQoZSkpLGUuYXBwZW5kKGMpfWVsc2UgZC5yZW1vdmVBdHRyKFxcXCJkYXRhLWluZGVudFxcXCIpfSksYi5odG1sLmNsZWFuQmxhbmtTcGFjZXMoaC5nZXQoMCkpLGM9aC5odG1sKCl9ZnVuY3Rpb24gZyhjKXt2YXIgZD1hKFxcXCI8ZGl2PlxcXCIpLmh0bWwoYyk7ZC5maW5kKFxcXCJwLCBkaXYsIGgxLCBoMiwgaDMsIGg0LCBoNSwgaDYsIHByZSwgYmxvY2txdW90ZVxcXCIpLmVhY2goZnVuY3Rpb24oYyxkKXthKGQpLnJlcGxhY2VXaXRoKFxcXCI8XFxcIisoYi5odG1sLmRlZmF1bHRUYWcoKXx8XFxcIkRJVlxcXCIpK1xcXCI+XFxcIithKGQpLmh0bWwoKStcXFwiPC9cXFwiKyhiLmh0bWwuZGVmYXVsdFRhZygpfHxcXFwiRElWXFxcIikrXFxcIj5cXFwiKX0pLGEoZC5maW5kKFxcXCIqXFxcIikubm90KFxcXCJwLCBkaXYsIGgxLCBoMiwgaDMsIGg0LCBoNSwgaDYsIHByZSwgYmxvY2txdW90ZSwgdWwsIG9sLCBsaSwgdGFibGUsIHRib2R5LCB0aGVhZCwgdHIsIHRkLCBiciwgaW1nXFxcIikuZ2V0KCkucmV2ZXJzZSgpKS5lYWNoKGZ1bmN0aW9uKCl7YSh0aGlzKS5yZXBsYWNlV2l0aChhKHRoaXMpLmh0bWwoKSl9KTt2YXIgZT1mdW5jdGlvbihjKXtmb3IodmFyIGQ9Yi5ub2RlLmNvbnRlbnRzKGMpLGY9MDtmPGQubGVuZ3RoO2YrKykzIT1kW2ZdLm5vZGVUeXBlJiYxIT1kW2ZdLm5vZGVUeXBlP2EoZFtmXSkucmVtb3ZlKCk6ZShkW2ZdKX07cmV0dXJuIGUoZC5nZXQoMCkpLGQuaHRtbCgpfWZ1bmN0aW9uIGgoKXtiLmtleXMuZm9yY2VVbmRvKCk7dmFyIGM9Yi5zbmFwc2hvdC5nZXQoKTtudWxsPT09bSYmKG09bi5odG1sKCksYi5zZWxlY3Rpb24ucmVzdG9yZSgpLGIuZXZlbnRzLmVuYWJsZUJsdXIoKSk7dmFyIGQ9Yi5ldmVudHMuY2hhaW5UcmlnZ2VyKFxcXCJwYXN0ZS5iZWZvcmVDbGVhbnVwXFxcIixtKTtcXFwic3RyaW5nXFxcIj09dHlwZW9mIGQmJihtPWQpO3ZhciBlPSExO20ubWF0Y2goLyhjbGFzcz1cXFxcXFxcIj9Nc298Y2xhc3M9XFxcXCc/TXNvfHN0eWxlPVxcXFxcXFwiW15cXFxcXFxcIl0qXFxcXGJtc29cXFxcLXxzdHlsZT1cXFxcJ1teXFxcXCddKlxcXFxibXNvXFxcXC18dzpXb3JkRG9jdW1lbnQpL2dpKSYmKGU9ITApLG0uaW5kZXhPZihcXFwiPGJvZHlcXFwiKT49MCYmKG09bS5yZXBsYWNlKC9bLlxcXFxzXFxcXFNcXFxcd1xcXFxXPD5dKjxib2R5W14+XSo+KFsuXFxcXHNcXFxcU1xcXFx3XFxcXFc8Pl0qKTxcXFxcL2JvZHk+Wy5cXFxcc1xcXFxTXFxcXHdcXFxcVzw+XSovZyxcXFwiJDFcXFwiKSk7dmFyIGg9ITE7aWYobS5pbmRleE9mKCdpZD1cXFwiZG9jcy1pbnRlcm5hbC1ndWlkJyk+PTAmJihtPW0ucmVwbGFjZSgvXi4qIGlkPVxcXCJkb2NzLWludGVybmFsLWd1aWRbXj5dKj4oLiopPFxcXFwvYj4uKiQvLFxcXCIkMVxcXCIpLGg9ITApLGU/KG09bS5yZXBsYWNlKC9eXFxcXG4qL2csXFxcIlxcXCIpLnJlcGxhY2UoL14gL2csXFxcIlxcXCIpLDA9PT1tLmluZGV4T2YoXFxcIjxjb2xncm91cD5cXFwiKSYmKG09XFxcIjx0YWJsZT5cXFwiK20rXFxcIjwvdGFibGU+XFxcIiksbT1mKG0pLG09aihtKSk6KGIub3B0cy5odG1sQWxsb3dDb21tZW50cz0hMSxtPWIuY2xlYW4uaHRtbChtLGIub3B0cy5wYXN0ZURlbmllZFRhZ3MsYi5vcHRzLnBhc3RlRGVuaWVkQXR0cnMpLGIub3B0cy5odG1sQWxsb3dDb21tZW50cz0hMCxtPWoobSksbT1tLnJlcGxhY2UoL1xcXFxyfFxcXFxufFxcXFx0L2csXFxcIlxcXCIpLGEuRkUuY29waWVkX3RleHQmJmEoXFxcIjxkaXY+XFxcIikuaHRtbChtKS50ZXh0KCkucmVwbGFjZSgvKFxcXFx1MDBBMCkvZ2ksXFxcIiBcXFwiKS5yZXBsYWNlKC9cXFxccnxcXFxcbi9naSxcXFwiXFxcIik9PWEuRkUuY29waWVkX3RleHQucmVwbGFjZSgvKFxcXFx1MDBBMCkvZ2ksXFxcIiBcXFwiKS5yZXBsYWNlKC9cXFxccnxcXFxcbi9naSxcXFwiXFxcIikmJihtPWEuRkUuY29waWVkX2h0bWwpLG09bS5yZXBsYWNlKC9eICovZyxcXFwiXFxcIikucmVwbGFjZSgvICokL2csXFxcIlxcXCIpKSxiLm9wdHMucGFzdGVQbGFpbiYmKG09ZyhtKSksZD1iLmV2ZW50cy5jaGFpblRyaWdnZXIoXFxcInBhc3RlLmFmdGVyQ2xlYW51cFxcXCIsbSksXFxcInN0cmluZ1xcXCI9PXR5cGVvZiBkJiYobT1kKSxcXFwiXFxcIiE9PW0pe3ZhciBrPWEoXFxcIjxkaXY+XFxcIikuaHRtbChtKTtiLnNwYWNlcy5ub3JtYWxpemUoay5nZXQoMCkpLGsuZmluZChcXFwic3BhblxcXCIpLmVhY2goZnVuY3Rpb24oKXswPT10aGlzLmF0dHJpYnV0ZXMubGVuZ3RoJiZhKHRoaXMpLnJlcGxhY2VXaXRoKHRoaXMuaW5uZXJIVE1MKX0pLGh8fGsuZmluZChcXFwiYnJcXFwiKS5lYWNoKGZ1bmN0aW9uKCl7dGhpcy5wcmV2aW91c1NpYmxpbmcmJmIubm9kZS5pc0Jsb2NrKHRoaXMucHJldmlvdXNTaWJsaW5nKSYmYSh0aGlzKS5yZW1vdmUoKX0pLGIub3B0cy5lbnRlcj09YS5GRS5FTlRFUl9CUj9rLmZpbmQoXFxcInAsIGRpdlxcXCIpLmVhY2goZnVuY3Rpb24oYixjKXthKGMpLnJlcGxhY2VXaXRoKGEoYykuaHRtbCgpKyhjLm5leHRTaWJsaW5nP1xcXCI8YnI+XFxcIjpcXFwiXFxcIikpfSk6Yi5vcHRzLmVudGVyPT1hLkZFLkVOVEVSX0RJViYmay5maW5kKFxcXCJwXFxcIikuZWFjaChmdW5jdGlvbihiLGMpe2EoYykucmVwbGFjZVdpdGgoXFxcIjxkaXY+XFxcIitjLmlubmVySFRNTCtcXFwiPC9kaXY+XFxcIil9KSxtPWsuaHRtbCgpLGIuaHRtbC5pbnNlcnQobSwhMCl9aSgpLGIudW5kby5zYXZlU3RlcChjKSxiLnVuZG8uc2F2ZVN0ZXAoKX1mdW5jdGlvbiBpKCl7Yi5ldmVudHMudHJpZ2dlcihcXFwicGFzdGUuYWZ0ZXJcXFwiKX1mdW5jdGlvbiBqKGMpe2Zvcih2YXIgZCxlPWEoXFxcIjxkaXY+XFxcIikuaHRtbChjKSxmPWUuZmluZChcXFwiKjplbXB0eTpub3QoYnIsIGltZywgdGQsIHRoKVxcXCIpO2YubGVuZ3RoOyl7Zm9yKGQ9MDtkPGYubGVuZ3RoO2QrKylhKGZbZF0pLnJlbW92ZSgpO2Y9ZS5maW5kKFxcXCIqOmVtcHR5Om5vdChiciwgaW1nLCB0ZCwgdGgpXFxcIil9Zm9yKHZhciBnPWUuZmluZChcXFwiPiBkaXY6bm90KFtzdHlsZV0pLCB0ZCA+IGRpdiwgdGggPiBkaXYsIGxpID4gZGl2XFxcIik7Zy5sZW5ndGgmJmQrKzwxMDA7KXt2YXIgaD1hKGdbZy5sZW5ndGgtMV0pO2IuaHRtbC5kZWZhdWx0VGFnKCkmJlxcXCJkaXZcXFwiIT1iLmh0bWwuZGVmYXVsdFRhZygpP2gucmVwbGFjZVdpdGgoXFxcIjxcXFwiK2IuaHRtbC5kZWZhdWx0VGFnKCkrXFxcIj5cXFwiK2guaHRtbCgpK1xcXCI8L1xcXCIrYi5odG1sLmRlZmF1bHRUYWcoKStcXFwiPlxcXCIpOmguZmluZChcXFwiKjpsYXN0XFxcIikuaXMoXFxcImJyXFxcIik/aC5yZXBsYWNlV2l0aChoLmh0bWwoKSk6aC5yZXBsYWNlV2l0aChoLmh0bWwoKStcXFwiPGJyPlxcXCIpLGc9ZS5maW5kKFxcXCI+IGRpdjpub3QoW3N0eWxlXSksIHRkID4gZGl2LCB0aCA+IGRpdiwgbGkgPiBkaXZcXFwiKX1mb3IoZz1lLmZpbmQoXFxcImRpdjpub3QoW3N0eWxlXSlcXFwiKTtnLmxlbmd0aDspe2ZvcihkPTA7ZDxnLmxlbmd0aDtkKyspe3ZhciBpPWEoZ1tkXSksaj1pLmh0bWwoKS5yZXBsYWNlKC9cXFxcdTAwMDkvZ2ksXFxcIlxcXCIpLnRyaW0oKTtpLnJlcGxhY2VXaXRoKGopfWc9ZS5maW5kKFxcXCJkaXY6bm90KFtzdHlsZV0pXFxcIil9cmV0dXJuIGUuaHRtbCgpfWZ1bmN0aW9uIGsoKXtiLmV2ZW50cy5vbihcXFwiY29weVxcXCIsYyksYi5ldmVudHMub24oXFxcImN1dFxcXCIsYyksYi5ldmVudHMub24oXFxcInBhc3RlXFxcIixkKSxiLmJyb3dzZXIubXNpZSYmYi5icm93c2VyLnZlcnNpb248MTEmJihiLmV2ZW50cy5vbihcXFwibW91c2V1cFxcXCIsZnVuY3Rpb24oYSl7Mj09YS5idXR0b24mJihzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7bz0hMX0sNTApLG89ITApfSwhMCksYi5ldmVudHMub24oXFxcImJlZm9yZXBhc3RlXFxcIixkKSl9dmFyIGwsbSxuLG89ITE7cmV0dXJue19pbml0Omt9fSxhLmV4dGVuZChhLkZFLkRFRkFVTFRTLHtzaG9ydGN1dHNFbmFibGVkOltcXFwic2hvd1xcXCIsXFxcImJvbGRcXFwiLFxcXCJpdGFsaWNcXFwiLFxcXCJ1bmRlcmxpbmVcXFwiLFxcXCJzdHJpa2VUaHJvdWdoXFxcIixcXFwiaW5kZW50XFxcIixcXFwib3V0ZGVudFxcXCIsXFxcInVuZG9cXFwiLFxcXCJyZWRvXFxcIl0sc2hvcnRjdXRzSGludDohMH0pLGEuRkUuU0hPUlRDVVRTX01BUD17fSxhLkZFLlJlZ2lzdGVyU2hvcnRjdXQ9ZnVuY3Rpb24oYixjLGQsZSxmLGcpe2EuRkUuU0hPUlRDVVRTX01BUFsoZj9cXFwiXlxcXCI6XFxcIlxcXCIpKyhnP1xcXCJAXFxcIjpcXFwiXFxcIikrYl09e2NtZDpjLHZhbDpkLGxldHRlcjplLHNoaWZ0OmYsb3B0aW9uOmd9LGEuRkUuREVGQVVMVFMuc2hvcnRjdXRzRW5hYmxlZC5wdXNoKGMpfSxhLkZFLlJlZ2lzdGVyU2hvcnRjdXQoYS5GRS5LRVlDT0RFLkUsXFxcInNob3dcXFwiLG51bGwsXFxcIkVcXFwiLCExLCExKSxhLkZFLlJlZ2lzdGVyU2hvcnRjdXQoYS5GRS5LRVlDT0RFLkIsXFxcImJvbGRcXFwiLG51bGwsXFxcIkJcXFwiLCExLCExKSxhLkZFLlJlZ2lzdGVyU2hvcnRjdXQoYS5GRS5LRVlDT0RFLkksXFxcIml0YWxpY1xcXCIsbnVsbCxcXFwiSVxcXCIsITEsITEpLGEuRkUuUmVnaXN0ZXJTaG9ydGN1dChhLkZFLktFWUNPREUuVSxcXFwidW5kZXJsaW5lXFxcIixudWxsLFxcXCJVXFxcIiwhMSwhMSksYS5GRS5SZWdpc3RlclNob3J0Y3V0KGEuRkUuS0VZQ09ERS5TLFxcXCJzdHJpa2VUaHJvdWdoXFxcIixudWxsLFxcXCJTXFxcIiwhMSwhMSksYS5GRS5SZWdpc3RlclNob3J0Y3V0KGEuRkUuS0VZQ09ERS5DTE9TRV9TUVVBUkVfQlJBQ0tFVCxcXFwiaW5kZW50XFxcIixudWxsLFxcXCJdXFxcIiwhMSwhMSksYS5GRS5SZWdpc3RlclNob3J0Y3V0KGEuRkUuS0VZQ09ERS5PUEVOX1NRVUFSRV9CUkFDS0VULFxcXCJvdXRkZW50XFxcIixudWxsLFxcXCJbXFxcIiwhMSwhMSksYS5GRS5SZWdpc3RlclNob3J0Y3V0KGEuRkUuS0VZQ09ERS5aLFxcXCJ1bmRvXFxcIixudWxsLFxcXCJaXFxcIiwhMSwhMSksYS5GRS5SZWdpc3RlclNob3J0Y3V0KGEuRkUuS0VZQ09ERS5aLFxcXCJyZWRvXFxcIixudWxsLFxcXCJaXFxcIiwhMCwhMSksYS5GRS5NT0RVTEVTLnNob3J0Y3V0cz1mdW5jdGlvbihiKXtmdW5jdGlvbiBjKGMpe2lmKCFiLm9wdHMuc2hvcnRjdXRzSGludClyZXR1cm4gbnVsbDtpZighZil7Zj17fTtmb3IodmFyIGQgaW4gYS5GRS5TSE9SVENVVFNfTUFQKWEuRkUuU0hPUlRDVVRTX01BUC5oYXNPd25Qcm9wZXJ0eShkKSYmYi5vcHRzLnNob3J0Y3V0c0VuYWJsZWQuaW5kZXhPZihhLkZFLlNIT1JUQ1VUU19NQVBbZF0uY21kKT49MCYmKGZbYS5GRS5TSE9SVENVVFNfTUFQW2RdLmNtZCtcXFwiLlxcXCIrKGEuRkUuU0hPUlRDVVRTX01BUFtkXS52YWx8fFxcXCJcXFwiKV09e3NoaWZ0OmEuRkUuU0hPUlRDVVRTX01BUFtkXS5zaGlmdCxvcHRpb246YS5GRS5TSE9SVENVVFNfTUFQW2RdLm9wdGlvbixsZXR0ZXI6YS5GRS5TSE9SVENVVFNfTUFQW2RdLmxldHRlcn0pfXZhciBlPWZbY107cmV0dXJuIGU/KGIuaGVscGVycy5pc01hYygpP1N0cmluZy5mcm9tQ2hhckNvZGUoODk4NCk6XFxcIkN0cmwrXFxcIikrKGUuc2hpZnQ/Yi5oZWxwZXJzLmlzTWFjKCk/U3RyaW5nLmZyb21DaGFyQ29kZSg4Njc5KTpcXFwiU2hpZnQrXFxcIjpcXFwiXFxcIikrKGUub3B0aW9uP2IuaGVscGVycy5pc01hYygpP1N0cmluZy5mcm9tQ2hhckNvZGUoODk5Nyk6XFxcIkFsdCtcXFwiOlxcXCJcXFwiKStlLmxldHRlcjpudWxsfWZ1bmN0aW9uIGQoYyl7aWYoIWIuY29yZS5oYXNGb2N1cygpKXJldHVybiEwO3ZhciBkPWMud2hpY2gsZT0tMSE9bmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKFxcXCJNYWMgT1MgWFxcXCIpP2MubWV0YUtleTpjLmN0cmxLZXksZj0oYy5zaGlmdEtleT9cXFwiXlxcXCI6XFxcIlxcXCIpKyhjLmFsdEtleT9cXFwiQFxcXCI6XFxcIlxcXCIpK2Q7aWYoZSYmYS5GRS5TSE9SVENVVFNfTUFQW2ZdKXt2YXIgZz1hLkZFLlNIT1JUQ1VUU19NQVBbZl0uY21kO2lmKGcmJmIub3B0cy5zaG9ydGN1dHNFbmFibGVkLmluZGV4T2YoZyk+PTApe3ZhciBoLGk9YS5GRS5TSE9SVENVVFNfTUFQW2ZdLnZhbDtpZihnJiYhaT9oPWIuJHRiLmZpbmQoJy5mci1jb21tYW5kW2RhdGEtY21kPVxcXCInK2crJ1xcXCJdJyk6ZyYmaSYmKGg9Yi4kdGIuZmluZCgnLmZyLWNvbW1hbmRbZGF0YS1jbWQ9XFxcIicrZysnXFxcIl1bZGF0YS1wYXJhbTE9XFxcIicraSsnXFxcIl0nKSksaC5sZW5ndGgpcmV0dXJuIGMucHJldmVudERlZmF1bHQoKSxjLnN0b3BQcm9wYWdhdGlvbigpLGgucGFyZW50cyhcXFwiLmZyLXRvb2xiYXJcXFwiKS5kYXRhKFxcXCJpbnN0YW5jZVxcXCIsYiksXFxcImtleWRvd25cXFwiPT1jLnR5cGUmJmIuYnV0dG9uLmV4ZWMoaCksITE7aWYoZyYmYi5jb21tYW5kc1tnXSlyZXR1cm4gYy5wcmV2ZW50RGVmYXVsdCgpLGMuc3RvcFByb3BhZ2F0aW9uKCksXFxcImtleWRvd25cXFwiPT1jLnR5cGUmJmIuY29tbWFuZHNbZ10oKSwhMX19fWZ1bmN0aW9uIGUoKXtiLmV2ZW50cy5vbihcXFwia2V5ZG93blxcXCIsZCwhMCksYi5ldmVudHMub24oXFxcImtleXVwXFxcIixkLCEwKX12YXIgZj1udWxsO3JldHVybntfaW5pdDplLGdldDpjfX0sYS5GRS5NT0RVTEVTLnNuYXBzaG90PWZ1bmN0aW9uKGEpe2Z1bmN0aW9uIGIoYSl7Zm9yKHZhciBiPWEucGFyZW50Tm9kZS5jaGlsZE5vZGVzLGM9MCxkPW51bGwsZT0wO2U8Yi5sZW5ndGg7ZSsrKXtpZihkKXt2YXIgZj1iW2VdLm5vZGVUeXBlPT09Tm9kZS5URVhUX05PREUmJlxcXCJcXFwiPT09YltlXS50ZXh0Q29udGVudCxnPWQubm9kZVR5cGU9PT1Ob2RlLlRFWFRfTk9ERSYmYltlXS5ub2RlVHlwZT09PU5vZGUuVEVYVF9OT0RFO2Z8fGd8fGMrK31pZihiW2VdPT1hKXJldHVybiBjO2Q9YltlXX19ZnVuY3Rpb24gYyhjKXt2YXIgZD1bXTtpZighYy5wYXJlbnROb2RlKXJldHVybltdO2Zvcig7IWEubm9kZS5pc0VsZW1lbnQoYyk7KWQucHVzaChiKGMpKSxjPWMucGFyZW50Tm9kZTtyZXR1cm4gZC5yZXZlcnNlKCl9ZnVuY3Rpb24gZChhLGIpe2Zvcig7YSYmYS5ub2RlVHlwZT09PU5vZGUuVEVYVF9OT0RFOyl7dmFyIGM9YS5wcmV2aW91c1NpYmxpbmc7YyYmYy5ub2RlVHlwZT09Tm9kZS5URVhUX05PREUmJihiKz1jLnRleHRDb250ZW50Lmxlbmd0aCksYT1jfXJldHVybiBifWZ1bmN0aW9uIGUoYSl7cmV0dXJue3NjTG9jOmMoYS5zdGFydENvbnRhaW5lciksc2NPZmZzZXQ6ZChhLnN0YXJ0Q29udGFpbmVyLGEuc3RhcnRPZmZzZXQpLGVjTG9jOmMoYS5lbmRDb250YWluZXIpLGVjT2Zmc2V0OmQoYS5lbmRDb250YWluZXIsYS5lbmRPZmZzZXQpfX1mdW5jdGlvbiBmKCl7dmFyIGI9e307aWYoYS5ldmVudHMudHJpZ2dlcihcXFwic25hcHNob3QuYmVmb3JlXFxcIiksYi5odG1sPShhLiR3cD9hLiRlbC5odG1sKCk6YS4kb2VsLmdldCgwKS5vdXRlckhUTUwpLnJlcGxhY2UoLyBzdHlsZT1cXFwiXFxcIi9nLFxcXCJcXFwiKSxiLnJhbmdlcz1bXSxhLiR3cCYmYS5zZWxlY3Rpb24uaW5FZGl0b3IoKSYmYS5jb3JlLmhhc0ZvY3VzKCkpZm9yKHZhciBjPWEuc2VsZWN0aW9uLnJhbmdlcygpLGQ9MDtkPGMubGVuZ3RoO2QrKyliLnJhbmdlcy5wdXNoKGUoY1tkXSkpO3JldHVybiBhLmV2ZW50cy50cmlnZ2VyKFxcXCJzbmFwc2hvdC5hZnRlclxcXCIpLGJ9ZnVuY3Rpb24gZyhiKXtmb3IodmFyIGM9YS4kZWwuZ2V0KDApLGQ9MDtkPGIubGVuZ3RoO2QrKyljPWMuY2hpbGROb2Rlc1tiW2RdXTtyZXR1cm4gY31mdW5jdGlvbiBoKGIsYyl7dHJ5e3ZhciBkPWcoYy5zY0xvYyksZT1jLnNjT2Zmc2V0LGY9ZyhjLmVjTG9jKSxoPWMuZWNPZmZzZXQsaT1hLmRvYy5jcmVhdGVSYW5nZSgpO2kuc2V0U3RhcnQoZCxlKSxpLnNldEVuZChmLGgpLGIuYWRkUmFuZ2UoaSl9Y2F0Y2goail7fX1mdW5jdGlvbiBpKGIpe2EuJGVsLmh0bWwoKSE9Yi5odG1sJiZhLiRlbC5odG1sKGIuaHRtbCk7dmFyIGM9YS5zZWxlY3Rpb24uZ2V0KCk7YS5zZWxlY3Rpb24uY2xlYXIoKSxhLmV2ZW50cy5mb2N1cyghMCk7Zm9yKHZhciBkPTA7ZDxiLnJhbmdlcy5sZW5ndGg7ZCsrKWgoYyxiLnJhbmdlc1tkXSl9ZnVuY3Rpb24gaihiLGMpe3JldHVybiBiLmh0bWwhPWMuaHRtbD8hMTphLmNvcmUuaGFzRm9jdXMoKSYmSlNPTi5zdHJpbmdpZnkoYi5yYW5nZXMpIT1KU09OLnN0cmluZ2lmeShjLnJhbmdlcyk/ITE6ITB9cmV0dXJue2dldDpmLHJlc3RvcmU6aSxlcXVhbDpqfX0sYS5GRS5NT0RVTEVTLnVuZG89ZnVuY3Rpb24oYSl7ZnVuY3Rpb24gYihiKXt2YXIgYz1iLndoaWNoLGQ9YS5rZXlzLmN0cmxLZXkoYik7ZCYmKDkwPT1jJiZiLnNoaWZ0S2V5JiZiLnByZXZlbnREZWZhdWx0KCksOTA9PWMmJmIucHJldmVudERlZmF1bHQoKSl9ZnVuY3Rpb24gYygpe3JldHVybiAwPT09YS51bmRvX3N0YWNrLmxlbmd0aHx8YS51bmRvX2luZGV4PD0xPyExOiEwfWZ1bmN0aW9uIGQoKXtyZXR1cm4gYS51bmRvX2luZGV4PT1hLnVuZG9fc3RhY2subGVuZ3RoPyExOiEwfWZ1bmN0aW9uIGUoYil7cmV0dXJuIWEudW5kb19zdGFja3x8YS51bmRvaW5nfHxhLiRlbC5nZXQoMCkucXVlcnlTZWxlY3RvckFsbChcXFwiLmZyLW1hcmtlclxcXCIpLmxlbmd0aD8hMTp2b2lkKFxcXCJ1bmRlZmluZWRcXFwiPT10eXBlb2YgYj8oYj1hLnNuYXBzaG90LmdldCgpLGEudW5kb19zdGFja1thLnVuZG9faW5kZXgtMV0mJmEuc25hcHNob3QuZXF1YWwoYS51bmRvX3N0YWNrW2EudW5kb19pbmRleC0xXSxiKXx8KGYoKSxhLnVuZG9fc3RhY2sucHVzaChiKSxhLnVuZG9faW5kZXgrKyxiLmh0bWwhPWwmJihhLmV2ZW50cy50cmlnZ2VyKFxcXCJjb250ZW50Q2hhbmdlZFxcXCIpLGw9Yi5odG1sKSkpOihmKCksYS51bmRvX2luZGV4PjA/YS51bmRvX3N0YWNrW2EudW5kb19pbmRleC0xXT1iOihhLnVuZG9fc3RhY2sucHVzaChiKSxhLnVuZG9faW5kZXgrKykpKX1mdW5jdGlvbiBmKCl7aWYoIWEudW5kb19zdGFja3x8YS51bmRvaW5nKXJldHVybiExO2Zvcig7YS51bmRvX3N0YWNrLmxlbmd0aD5hLnVuZG9faW5kZXg7KWEudW5kb19zdGFjay5wb3AoKX1mdW5jdGlvbiBnKCl7aWYoYS51bmRvX2luZGV4PjEpe2EudW5kb2luZz0hMDt2YXIgYj1hLnVuZG9fc3RhY2tbLS1hLnVuZG9faW5kZXgtMV07Y2xlYXJUaW1lb3V0KGEuX2NvbnRlbnRfY2hhbmdlZF90aW1lciksYS5zbmFwc2hvdC5yZXN0b3JlKGIpLGw9Yi5odG1sLGEucG9wdXBzLmhpZGVBbGwoKSxhLnRvb2xiYXIuZW5hYmxlKCksYS5ldmVudHMudHJpZ2dlcihcXFwiY29udGVudENoYW5nZWRcXFwiKSxhLmV2ZW50cy50cmlnZ2VyKFxcXCJjb21tYW5kcy51bmRvXFxcIiksYS51bmRvaW5nPSExfX1mdW5jdGlvbiBoKCl7aWYoYS51bmRvX2luZGV4PGEudW5kb19zdGFjay5sZW5ndGgpe2EudW5kb2luZz0hMDt2YXIgYj1hLnVuZG9fc3RhY2tbYS51bmRvX2luZGV4KytdO2NsZWFyVGltZW91dChhLl9jb250ZW50X2NoYW5nZWRfdGltZXIpLGEuc25hcHNob3QucmVzdG9yZShiKSxsPWIuaHRtbCxhLnBvcHVwcy5oaWRlQWxsKCksYS50b29sYmFyLmVuYWJsZSgpLGEuZXZlbnRzLnRyaWdnZXIoXFxcImNvbnRlbnRDaGFuZ2VkXFxcIiksYS5ldmVudHMudHJpZ2dlcihcXFwiY29tbWFuZHMucmVkb1xcXCIpLGEudW5kb2luZz0hMX19ZnVuY3Rpb24gaSgpe2EudW5kb19pbmRleD0wLGEudW5kb19zdGFjaz1bXX1mdW5jdGlvbiBqKCl7YS51bmRvX3N0YWNrPVtdfWZ1bmN0aW9uIGsoKXtpKCksYS5ldmVudHMub24oXFxcImluaXRpYWxpemVkXFxcIixmdW5jdGlvbigpe2w9KGEuJHdwP2EuJGVsLmh0bWwoKTphLiRvZWwuZ2V0KDApLm91dGVySFRNTCkucmVwbGFjZSgvIHN0eWxlPVxcXCJcXFwiL2csXFxcIlxcXCIpfSksYS5ldmVudHMub24oXFxcImJsdXJcXFwiLGZ1bmN0aW9uKCl7YS51bmRvLnNhdmVTdGVwKCl9KSxhLmV2ZW50cy5vbihcXFwia2V5ZG93blxcXCIsYiksYS5ldmVudHMub24oXFxcImRlc3Ryb3lcXFwiLGopfXZhciBsPW51bGw7cmV0dXJue19pbml0OmsscnVuOmcscmVkbzpoLGNhbkRvOmMsY2FuUmVkbzpkLGRyb3BSZWRvOmYscmVzZXQ6aSxzYXZlU3RlcDplfX0sYS5GRS5JQ09OX0RFRkFVTFRfVEVNUExBVEU9XFxcImZvbnRfYXdlc29tZVxcXCIsYS5GRS5JQ09OX1RFTVBMQVRFUz17Zm9udF9hd2Vzb21lOic8aSBjbGFzcz1cXFwiZmEgZmEtW05BTUVdXFxcIj48L2k+Jyx0ZXh0Oic8c3BhbiBzdHlsZT1cXFwidGV4dC1hbGlnbjogY2VudGVyO1xcXCI+W05BTUVdPC9zcGFuPicsaW1hZ2U6XFxcIjxpbWcgc3JjPVtTUkNdIGFsdD1bQUxUXSAvPlxcXCIsc3ZnOic8c3ZnIHZpZXdCb3g9XFxcIjAgMCAzMiAzMlxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj5bUEFUSF08L3N2Zz4nfSxhLkZFLklDT05TPXtib2xkOntOQU1FOlxcXCJib2xkXFxcIn0saXRhbGljOntOQU1FOlxcXCJpdGFsaWNcXFwifSx1bmRlcmxpbmU6e05BTUU6XFxcInVuZGVybGluZVxcXCJ9LHN0cmlrZVRocm91Z2g6e05BTUU6XFxcInN0cmlrZXRocm91Z2hcXFwifSxzdWJzY3JpcHQ6e05BTUU6XFxcInN1YnNjcmlwdFxcXCJ9LHN1cGVyc2NyaXB0OntOQU1FOlxcXCJzdXBlcnNjcmlwdFxcXCJ9LGNvbG9yOntOQU1FOlxcXCJ0aW50XFxcIn0sb3V0ZGVudDp7TkFNRTpcXFwib3V0ZGVudFxcXCJ9LGluZGVudDp7TkFNRTpcXFwiaW5kZW50XFxcIn0sdW5kbzp7TkFNRTpcXFwicm90YXRlLWxlZnRcXFwifSxyZWRvOntOQU1FOlxcXCJyb3RhdGUtcmlnaHRcXFwifSxpbnNlcnRIUjp7TkFNRTpcXFwibWludXNcXFwifSxjbGVhckZvcm1hdHRpbmc6e05BTUU6XFxcImVyYXNlclxcXCJ9LHNlbGVjdEFsbDp7TkFNRTpcXFwibW91c2UtcG9pbnRlclxcXCJ9fSxhLkZFLkRlZmluZUljb25UZW1wbGF0ZT1mdW5jdGlvbihiLGMpe2EuRkUuSUNPTl9URU1QTEFURVNbYl09Y30sYS5GRS5EZWZpbmVJY29uPWZ1bmN0aW9uKGIsYyl7YS5GRS5JQ09OU1tiXT1jfSxhLkZFLk1PRFVMRVMuaWNvbj1mdW5jdGlvbihiKXtmdW5jdGlvbiBjKGIpe3ZhciBjPW51bGwsZD1hLkZFLklDT05TW2JdO2lmKFxcXCJ1bmRlZmluZWRcXFwiIT10eXBlb2YgZCl7dmFyIGU9ZC50ZW1wbGF0ZXx8YS5GRS5JQ09OX0RFRkFVTFRfVEVNUExBVEU7ZSYmKGU9YS5GRS5JQ09OX1RFTVBMQVRFU1tlXSkmJihjPWUucmVwbGFjZSgvXFxcXFsoW2EtekEtWl0qKVxcXFxdL2csZnVuY3Rpb24oYSxjKXtyZXR1cm5cXFwiTkFNRVxcXCI9PWM/ZFtjXXx8YjpkW2NdfSkpfXJldHVybiBjfHxifWZ1bmN0aW9uIGQoYil7dmFyIGM9YS5GRS5JQ09OU1tiXSxkPVxcXCJcXFwiO2lmKFxcXCJ1bmRlZmluZWRcXFwiIT10eXBlb2YgYyl7dmFyIGQ9Yy50ZW1wbGF0ZXx8YS5GRS5JQ09OX0RFRkFVTFRfVEVNUExBVEU7cmV0dXJuIGR9cmV0dXJuIGR9cmV0dXJue2NyZWF0ZTpjLGdldFRlbXBsYXRlOmR9fSxhLmV4dGVuZChhLkZFLkRFRkFVTFRTLHt0b29sdGlwczohMH0pLGEuRkUuTU9EVUxFUy50b29sdGlwPWZ1bmN0aW9uKGIpe2Z1bmN0aW9uIGMoKXtiLiR0b29sdGlwJiZiLiR0b29sdGlwLnJlbW92ZUNsYXNzKFxcXCJmci12aXNpYmxlXFxcIikuY3NzKFxcXCJsZWZ0XFxcIixcXFwiLTMwMDBweFxcXCIpLmNzcyhcXFwicG9zaXRpb25cXFwiLFxcXCJmaXhlZFxcXCIpfWZ1bmN0aW9uIGQoYyxkKXtpZihjLmRhdGEoXFxcInRpdGxlXFxcIil8fGMuZGF0YShcXFwidGl0bGVcXFwiLGMuYXR0cihcXFwidGl0bGVcXFwiKSksIWMuZGF0YShcXFwidGl0bGVcXFwiKSlyZXR1cm4hMTtiLiR0b29sdGlwfHxmKCksYy5yZW1vdmVBdHRyKFxcXCJ0aXRsZVxcXCIpLGIuJHRvb2x0aXAudGV4dChjLmRhdGEoXFxcInRpdGxlXFxcIikpLGIuJHRvb2x0aXAuYWRkQ2xhc3MoXFxcImZyLXZpc2libGVcXFwiKTt2YXIgZT1jLm9mZnNldCgpLmxlZnQrKGMub3V0ZXJXaWR0aCgpLWIuJHRvb2x0aXAub3V0ZXJXaWR0aCgpKS8yO1xcbjA+ZSYmKGU9MCksZStiLiR0b29sdGlwLm91dGVyV2lkdGgoKT5hKGIub193aW4pLndpZHRoKCkmJihlPWEoYi5vX3dpbikud2lkdGgoKS1iLiR0b29sdGlwLm91dGVyV2lkdGgoKSksXFxcInVuZGVmaW5lZFxcXCI9PXR5cGVvZiBkJiYoZD1iLm9wdHMudG9vbGJhckJvdHRvbSk7dmFyIGc9ZD9jLm9mZnNldCgpLnRvcC1iLiR0b29sdGlwLmhlaWdodCgpOmMub2Zmc2V0KCkudG9wK2Mub3V0ZXJIZWlnaHQoKTtiLiR0b29sdGlwLmNzcyhcXFwicG9zaXRpb25cXFwiLFxcXCJcXFwiKSxiLiR0b29sdGlwLmNzcyhcXFwibGVmdFxcXCIsZSksYi4kdG9vbHRpcC5jc3MoXFxcInRvcFxcXCIsTWF0aC5jZWlsKGcpKSxcXFwic3RhdGljXFxcIiE9YShiLm9fZG9jKS5maW5kKFxcXCJib2R5XFxcIikuY3NzKFxcXCJwb3NpdGlvblxcXCIpPyhiLiR0b29sdGlwLmNzcyhcXFwibWFyZ2luLWxlZnRcXFwiLC1hKGIub19kb2MpLmZpbmQoXFxcImJvZHlcXFwiKS5vZmZzZXQoKS5sZWZ0KSxiLiR0b29sdGlwLmNzcyhcXFwibWFyZ2luLXRvcFxcXCIsLWEoYi5vX2RvYykuZmluZChcXFwiYm9keVxcXCIpLm9mZnNldCgpLnRvcCkpOihiLiR0b29sdGlwLmNzcyhcXFwibWFyZ2luLWxlZnRcXFwiLFxcXCJcXFwiKSxiLiR0b29sdGlwLmNzcyhcXFwibWFyZ2luLXRvcFxcXCIsXFxcIlxcXCIpKX1mdW5jdGlvbiBlKGUsZixnKXtiLm9wdHMudG9vbHRpcHMmJiFiLmhlbHBlcnMuaXNNb2JpbGUoKSYmKGIuZXZlbnRzLiRvbihlLFxcXCJtb3VzZWVudGVyXFxcIixmLGZ1bmN0aW9uKGMpe2EoYy5jdXJyZW50VGFyZ2V0KS5oYXNDbGFzcyhcXFwiZnItZGlzYWJsZWRcXFwiKXx8Yi5lZGl0LmlzRGlzYWJsZWQoKXx8ZChhKGMuY3VycmVudFRhcmdldCksZyl9LCEwKSxiLmV2ZW50cy4kb24oZSxcXFwibW91c2VsZWF2ZSBcXFwiK2IuX21vdXNlZG93bitcXFwiIFxcXCIrYi5fbW91c2V1cCxmLGZ1bmN0aW9uKGEpe2MoKX0sITApKX1mdW5jdGlvbiBmKCl7Yi5vcHRzLnRvb2x0aXBzJiYhYi5oZWxwZXJzLmlzTW9iaWxlKCkmJihiLnNoYXJlZC4kdG9vbHRpcD9iLiR0b29sdGlwPWIuc2hhcmVkLiR0b29sdGlwOihiLnNoYXJlZC4kdG9vbHRpcD1hKCc8ZGl2IGNsYXNzPVxcXCJmci10b29sdGlwXFxcIj48L2Rpdj4nKSxiLiR0b29sdGlwPWIuc2hhcmVkLiR0b29sdGlwLGIub3B0cy50aGVtZSYmYi4kdG9vbHRpcC5hZGRDbGFzcyhiLm9wdHMudGhlbWUrXFxcIi10aGVtZVxcXCIpLGEoYi5vX2RvYykuZmluZChcXFwiYm9keVxcXCIpLmFwcGVuZChiLiR0b29sdGlwKSksYi5ldmVudHMub24oXFxcInNoYXJlZC5kZXN0cm95XFxcIixmdW5jdGlvbigpe2IuJHRvb2x0aXAuaHRtbChcXFwiXFxcIikucmVtb3ZlRGF0YSgpLnJlbW92ZSgpLGIuJHRvb2x0aXA9bnVsbH0sITApKX1yZXR1cm57aGlkZTpjLHRvOmQsYmluZDplfX0sYS5GRS5NT0RVTEVTLmJ1dHRvbj1mdW5jdGlvbihiKXtmdW5jdGlvbiBjKGMpe3ZhciBkPWEoYy5jdXJyZW50VGFyZ2V0KSxlPWQubmV4dCgpLGY9ZC5oYXNDbGFzcyhcXFwiZnItYWN0aXZlXFxcIiksZz0oYi5oZWxwZXJzLmlzTW9iaWxlKCksYShcXFwiLmZyLWRyb3Bkb3duLmZyLWFjdGl2ZVxcXCIpLm5vdChkKSksaD1kLnBhcmVudHMoXFxcIi5mci10b29sYmFyLCAuZnItcG9wdXBcXFwiKS5kYXRhKFxcXCJpbnN0YW5jZVxcXCIpfHxiO2lmKGguaGVscGVycy5pc0lPUygpJiYwPT1oLiRlbC5nZXQoMCkucXVlcnlTZWxlY3RvckFsbChcXFwiLmZyLW1hcmtlclxcXCIpLmxlbmd0aCYmKGguc2VsZWN0aW9uLnNhdmUoKSxoLnNlbGVjdGlvbi5jbGVhcigpLGguc2VsZWN0aW9uLnJlc3RvcmUoKSksIWYpe3ZhciBpPWQuZGF0YShcXFwiY21kXFxcIik7ZS5maW5kKFxcXCIuZnItY29tbWFuZFxcXCIpLnJlbW92ZUNsYXNzKFxcXCJmci1hY3RpdmVcXFwiKSxhLkZFLkNPTU1BTkRTW2ldJiZhLkZFLkNPTU1BTkRTW2ldLnJlZnJlc2hPblNob3cmJmEuRkUuQ09NTUFORFNbaV0ucmVmcmVzaE9uU2hvdy5hcHBseShoLFtkLGVdKSxlLmNzcyhcXFwibGVmdFxcXCIsZC5vZmZzZXQoKS5sZWZ0LWQucGFyZW50KCkub2Zmc2V0KCkubGVmdC0oXFxcInJ0bFxcXCI9PWIub3B0cy5kaXJlY3Rpb24/ZS53aWR0aCgpLWQub3V0ZXJXaWR0aCgpOjApKSxiLm9wdHMudG9vbGJhckJvdHRvbT9lLmNzcyhcXFwiYm90dG9tXFxcIixiLiR0Yi5oZWlnaHQoKS1kLnBvc2l0aW9uKCkudG9wKTplLmNzcyhcXFwidG9wXFxcIixkLnBvc2l0aW9uKCkudG9wK2Qub3V0ZXJIZWlnaHQoKSl9ZC5hZGRDbGFzcyhcXFwiZnItYmxpbmtcXFwiKS50b2dnbGVDbGFzcyhcXFwiZnItYWN0aXZlXFxcIiksc2V0VGltZW91dChmdW5jdGlvbigpe2QucmVtb3ZlQ2xhc3MoXFxcImZyLWJsaW5rXFxcIil9LDMwMCksZS5vZmZzZXQoKS5sZWZ0K2Uub3V0ZXJXaWR0aCgpPmEoYi5vcHRzLnNjcm9sbGFibGVDb250YWluZXIpLm9mZnNldCgpLmxlZnQrYShiLm9wdHMuc2Nyb2xsYWJsZUNvbnRhaW5lcikub3V0ZXJXaWR0aCgpJiZlLmNzcyhcXFwibWFyZ2luLWxlZnRcXFwiLC0oZS5vZmZzZXQoKS5sZWZ0K2Uub3V0ZXJXaWR0aCgpLWEoYi5vcHRzLnNjcm9sbGFibGVDb250YWluZXIpLm9mZnNldCgpLmxlZnQtYShiLm9wdHMuc2Nyb2xsYWJsZUNvbnRhaW5lcikub3V0ZXJXaWR0aCgpKSksZy5yZW1vdmVDbGFzcyhcXFwiZnItYWN0aXZlXFxcIiksZy5wYXJlbnQoXFxcIi5mci10b29sYmFyOm5vdCguZnItaW5saW5lKVxcXCIpLmNzcyhcXFwiekluZGV4XFxcIixcXFwiXFxcIiksMCE9ZC5wYXJlbnRzKFxcXCIuZnItcG9wdXBcXFwiKS5sZW5ndGh8fGIub3B0cy50b29sYmFySW5saW5lfHwoZC5oYXNDbGFzcyhcXFwiZnItYWN0aXZlXFxcIik/Yi4kdGIuY3NzKFxcXCJ6SW5kZXhcXFwiLChiLm9wdHMuekluZGV4fHwxKSs0KTpiLiR0Yi5jc3MoXFxcInpJbmRleFxcXCIsXFxcIlxcXCIpKX1mdW5jdGlvbiBkKGIpe2IuYWRkQ2xhc3MoXFxcImZyLWJsaW5rXFxcIiksc2V0VGltZW91dChmdW5jdGlvbigpe2IucmVtb3ZlQ2xhc3MoXFxcImZyLWJsaW5rXFxcIil9LDUwMCk7Zm9yKHZhciBjPWIuZGF0YShcXFwiY21kXFxcIiksZD1bXTtcXFwidW5kZWZpbmVkXFxcIiE9dHlwZW9mIGIuZGF0YShcXFwicGFyYW1cXFwiKyhkLmxlbmd0aCsxKSk7KWQucHVzaChiLmRhdGEoXFxcInBhcmFtXFxcIisoZC5sZW5ndGgrMSkpKTt2YXIgZT1hKFxcXCIuZnItZHJvcGRvd24uZnItYWN0aXZlXFxcIik7ZS5sZW5ndGgmJihlLnJlbW92ZUNsYXNzKFxcXCJmci1hY3RpdmVcXFwiKSxlLnBhcmVudChcXFwiLmZyLXRvb2xiYXI6bm90KC5mci1pbmxpbmUpXFxcIikuY3NzKFxcXCJ6SW5kZXhcXFwiLFxcXCJcXFwiKSksYi5wYXJlbnRzKFxcXCIuZnItcG9wdXAsIC5mci10b29sYmFyXFxcIikuZGF0YShcXFwiaW5zdGFuY2VcXFwiKS5jb21tYW5kcy5leGVjKGMsZCl9ZnVuY3Rpb24gZShiKXt2YXIgYz1hKGIuY3VycmVudFRhcmdldCk7ZChjKX1mdW5jdGlvbiBmKGIpe3ZhciBkPWEoYi5jdXJyZW50VGFyZ2V0KSxmPWQucGFyZW50cyhcXFwiLmZyLXBvcHVwLCAuZnItdG9vbGJhclxcXCIpLmRhdGEoXFxcImluc3RhbmNlXFxcIik7aWYoMCE9ZC5wYXJlbnRzKFxcXCIuZnItcG9wdXBcXFwiKS5sZW5ndGh8fGQuZGF0YShcXFwicG9wdXBcXFwiKXx8Zi5wb3B1cHMuaGlkZUFsbCgpLGYucG9wdXBzLmFyZVZpc2libGUoKSYmIWYucG9wdXBzLmFyZVZpc2libGUoZikpe2Zvcih2YXIgZz0wO2c8YS5GRS5JTlNUQU5DRVMubGVuZ3RoO2crKylhLkZFLklOU1RBTkNFU1tnXSE9ZiYmYS5GRS5JTlNUQU5DRVNbZ10ucG9wdXBzJiZhLkZFLklOU1RBTkNFU1tnXS5wb3B1cHMuYXJlVmlzaWJsZSgpJiZhLkZFLklOU1RBTkNFU1tnXS4kZWwuZmluZChcXFwiLmZyLW1hcmtlclxcXCIpLnJlbW92ZSgpO2YucG9wdXBzLmhpZGVBbGwoKX1kLmhhc0NsYXNzKFxcXCJmci1kcm9wZG93blxcXCIpP2MoYik6KGUoYiksYS5GRS5DT01NQU5EU1tkLmRhdGEoXFxcImNtZFxcXCIpXSYmMCE9YS5GRS5DT01NQU5EU1tkLmRhdGEoXFxcImNtZFxcXCIpXS5yZWZyZXNoQWZ0ZXJDYWxsYmFjayYmZi5idXR0b24uYnVsa1JlZnJlc2goKSl9ZnVuY3Rpb24gZyhhKXt2YXIgYj1hLmZpbmQoXFxcIi5mci1kcm9wZG93bi5mci1hY3RpdmVcXFwiKTtiLmxlbmd0aCYmKGIucmVtb3ZlQ2xhc3MoXFxcImZyLWFjdGl2ZVxcXCIpLGIucGFyZW50KFxcXCIuZnItdG9vbGJhcjpub3QoLmZyLWlubGluZSlcXFwiKS5jc3MoXFxcInpJbmRleFxcXCIsXFxcIlxcXCIpKX1mdW5jdGlvbiBoKGEpe2EucHJldmVudERlZmF1bHQoKSxhLnN0b3BQcm9wYWdhdGlvbigpfWZ1bmN0aW9uIGkoYSl7cmV0dXJuIGEuc3RvcFByb3BhZ2F0aW9uKCksYi5oZWxwZXJzLmlzTW9iaWxlKCk/dm9pZCAwOiExfWZ1bmN0aW9uIGooYyxkKXtiLmV2ZW50cy5iaW5kQ2xpY2soYyxcXFwiLmZyLWNvbW1hbmQ6bm90KC5mci1kaXNhYmxlZClcXFwiLGYpLGIuZXZlbnRzLiRvbihjLGIuX21vdXNlZG93bitcXFwiIFxcXCIrYi5fbW91c2V1cCtcXFwiIFxcXCIrYi5fbW92ZSxcXFwiLmZyLWRyb3Bkb3duLW1lbnVcXFwiLGgsITApLGIuZXZlbnRzLiRvbihjLGIuX21vdXNlZG93bitcXFwiIFxcXCIrYi5fbW91c2V1cCtcXFwiIFxcXCIrYi5fbW92ZSxcXFwiLmZyLWRyb3Bkb3duLW1lbnUgLmZyLWRyb3Bkb3duLXdyYXBwZXJcXFwiLGksITApO3ZhciBlPWMuZ2V0KDApLm93bmVyRG9jdW1lbnQsaj1cXFwiZGVmYXVsdFZpZXdcXFwiaW4gZT9lLmRlZmF1bHRWaWV3OmUucGFyZW50V2luZG93LGs9ZnVuY3Rpb24oZCl7KCFkfHxkLnR5cGU9PWIuX21vdXNldXAmJmQudGFyZ2V0IT1hKFxcXCJodG1sXFxcIikuZ2V0KDApfHxcXFwia2V5ZG93blxcXCI9PWQudHlwZSYmKGIua2V5cy5pc0NoYXJhY3RlcihkLndoaWNoKSYmIWIua2V5cy5jdHJsS2V5KGQpfHxkLndoaWNoPT1hLkZFLktFWUNPREUuRVNDKSkmJmcoYyl9O2IuZXZlbnRzLiRvbihhKGopLGIuX21vdXNldXArXFxcIiByZXNpemUga2V5ZG93blxcXCIsaywhMCksYi5vcHRzLmlmcmFtZSYmYi5ldmVudHMuJG9uKGIuJHdpbixiLl9tb3VzZXVwLGssITApLGMuaGFzQ2xhc3MoXFxcImZyLXBvcHVwXFxcIik/YS5tZXJnZSh0LGMuZmluZChcXFwiLmZyLWJ0blxcXCIpLnRvQXJyYXkoKSk6YS5tZXJnZShzLGMuZmluZChcXFwiLmZyLWJ0blxcXCIpLnRvQXJyYXkoKSksYi50b29sdGlwLmJpbmQoYyxcXFwiLmZyLWJ0biwgLmZyLXRpdGxlXFxcIixkKX1mdW5jdGlvbiBrKGEsYyl7dmFyIGQ9XFxcIlxcXCI7aWYoYy5odG1sKWQrPVxcXCJmdW5jdGlvblxcXCI9PXR5cGVvZiBjLmh0bWw/Yy5odG1sLmNhbGwoYik6Yy5odG1sO2Vsc2V7dmFyIGU9Yy5vcHRpb25zO1xcXCJmdW5jdGlvblxcXCI9PXR5cGVvZiBlJiYoZT1lKCkpLGQrPSc8dWwgY2xhc3M9XFxcImZyLWRyb3Bkb3duLWxpc3RcXFwiPic7Zm9yKHZhciBmIGluIGUpaWYoZS5oYXNPd25Qcm9wZXJ0eShmKSl7dmFyIGc9Yi5zaG9ydGN1dHMuZ2V0KGErXFxcIi5cXFwiK2YpO2c9Zz8nPHNwYW4gY2xhc3M9XFxcImZyLXNob3J0Y3V0XFxcIj4nK2crXFxcIjwvc3Bhbj5cXFwiOlxcXCJcXFwiLGQrPSc8bGk+PGEgY2xhc3M9XFxcImZyLWNvbW1hbmRcXFwiIGRhdGEtY21kPVxcXCInK2ErJ1xcXCIgZGF0YS1wYXJhbTE9XFxcIicrZisnXFxcIiB0aXRsZT1cXFwiJytlW2ZdKydcXFwiPicrYi5sYW5ndWFnZS50cmFuc2xhdGUoZVtmXSkrXFxcIjwvYT48L2xpPlxcXCJ9ZCs9XFxcIjwvdWw+XFxcIn1yZXR1cm4gZH1mdW5jdGlvbiBsKGEsYyxkKXt2YXIgZT1jLmRpc3BsYXlTZWxlY3Rpb247XFxcImZ1bmN0aW9uXFxcIj09dHlwZW9mIGUmJihlPWUoYikpO3ZhciBmO2lmKGUpe3ZhciBnPVxcXCJmdW5jdGlvblxcXCI9PXR5cGVvZiBjLmRlZmF1bHRTZWxlY3Rpb24/Yy5kZWZhdWx0U2VsZWN0aW9uKGIpOmMuZGVmYXVsdFNlbGVjdGlvbjtmPSc8c3BhbiBzdHlsZT1cXFwid2lkdGg6JysoYy5kaXNwbGF5U2VsZWN0aW9uV2lkdGh8fDEwMCkrJ3B4XFxcIj4nKyhnfHxiLmxhbmd1YWdlLnRyYW5zbGF0ZShjLnRpdGxlKSkrXFxcIjwvc3Bhbj5cXFwifWVsc2UgZj1iLmljb24uY3JlYXRlKGMuaWNvbnx8YSk7dmFyIGg9Yy5wb3B1cD8nIGRhdGEtcG9wdXA9XFxcInRydWVcXFwiJzpcXFwiXFxcIixpPWIuc2hvcnRjdXRzLmdldChhK1xcXCIuXFxcIik7aT1pP1xcXCIgKFxcXCIraStcXFwiKVxcXCI6XFxcIlxcXCI7dmFyIGo9JzxidXR0b24gdHlwZT1cXFwiYnV0dG9uXFxcIiB0YWJpbmRleD1cXFwiLTFcXFwiIGFyaWEtbGFiZWw9XFxcIicrKGIubGFuZ3VhZ2UudHJhbnNsYXRlKGMudGl0bGUpfHxcXFwiXFxcIikrJ1xcXCIgdGl0bGU9XFxcIicrKGIubGFuZ3VhZ2UudHJhbnNsYXRlKGMudGl0bGUpfHxcXFwiXFxcIikraSsnXFxcIiBjbGFzcz1cXFwiZnItY29tbWFuZCBmci1idG4nKyhcXFwiZHJvcGRvd25cXFwiPT1jLnR5cGU/XFxcIiBmci1kcm9wZG93blxcXCI6XFxcIlxcXCIpKyhcXFwiIGZyLWJ0bi1cXFwiK2IuaWNvbi5nZXRUZW1wbGF0ZShjLmljb24pKSsoYy5kaXNwbGF5U2VsZWN0aW9uP1xcXCIgZnItc2VsZWN0aW9uXFxcIjpcXFwiXFxcIikrKGMuYmFjaz9cXFwiIGZyLWJhY2tcXFwiOlxcXCJcXFwiKSsoYy5kaXNhYmxlZD9cXFwiIGZyLWRpc2FibGVkXFxcIjpcXFwiXFxcIikrKGQ/XFxcIlxcXCI6XFxcIiBmci1oaWRkZW5cXFwiKSsnXFxcIiBkYXRhLWNtZD1cXFwiJythKydcXFwiJytoK1xcXCI+XFxcIitmK1xcXCI8L2J1dHRvbj5cXFwiO2lmKFxcXCJkcm9wZG93blxcXCI9PWMudHlwZSl7dmFyIGw9JzxkaXYgY2xhc3M9XFxcImZyLWRyb3Bkb3duLW1lbnVcXFwiPjxkaXYgY2xhc3M9XFxcImZyLWRyb3Bkb3duLXdyYXBwZXJcXFwiPjxkaXYgY2xhc3M9XFxcImZyLWRyb3Bkb3duLWNvbnRlbnRcXFwiPic7bCs9ayhhLGMpLGwrPVxcXCI8L2Rpdj48L2Rpdj48L2Rpdj5cXFwiLGorPWx9cmV0dXJuIGp9ZnVuY3Rpb24gbShjLGQpe2Zvcih2YXIgZT1cXFwiXFxcIixmPTA7ZjxjLmxlbmd0aDtmKyspe3ZhciBnPWNbZl0saD1hLkZFLkNPTU1BTkRTW2ddO2lmKCEoaCYmXFxcInVuZGVmaW5lZFxcXCIhPXR5cGVvZiBoLnBsdWdpbiYmYi5vcHRzLnBsdWdpbnNFbmFibGVkLmluZGV4T2YoaC5wbHVnaW4pPDApKWlmKGgpe3ZhciBpPVxcXCJ1bmRlZmluZWRcXFwiIT10eXBlb2YgZD9kLmluZGV4T2YoZyk+PTA6ITA7ZSs9bChnLGgsaSl9ZWxzZVxcXCJ8XFxcIj09Zz9lKz0nPGRpdiBjbGFzcz1cXFwiZnItc2VwYXJhdG9yIGZyLXZzXFxcIj48L2Rpdj4nOlxcXCItXFxcIj09ZyYmKGUrPSc8ZGl2IGNsYXNzPVxcXCJmci1zZXBhcmF0b3IgZnItaHNcXFwiPjwvZGl2PicpfXJldHVybiBlfWZ1bmN0aW9uIG4oYyl7dmFyIGQsZT1jLnBhcmVudHMoXFxcIi5mci1wb3B1cCwgLmZyLXRvb2xiYXJcXFwiKS5kYXRhKFxcXCJpbnN0YW5jZVxcXCIpfHxiLGY9Yy5kYXRhKFxcXCJjbWRcXFwiKTtjLmhhc0NsYXNzKFxcXCJmci1kcm9wZG93blxcXCIpP2Q9Yy5uZXh0KCk6Yy5yZW1vdmVDbGFzcyhcXFwiZnItYWN0aXZlXFxcIiksYS5GRS5DT01NQU5EU1tmXSYmYS5GRS5DT01NQU5EU1tmXS5yZWZyZXNoP2EuRkUuQ09NTUFORFNbZl0ucmVmcmVzaC5hcHBseShlLFtjLGRdKTpiLnJlZnJlc2hbZl0mJmUucmVmcmVzaFtmXShjLGQpfWZ1bmN0aW9uIG8oYyl7dmFyIGQ9Yi4kdGI/Yi4kdGIuZGF0YShcXFwiaW5zdGFuY2VcXFwiKXx8YjpiO3JldHVybiAwPT1iLmV2ZW50cy50cmlnZ2VyKFxcXCJidXR0b25zLnJlZnJlc2hcXFwiKT8hMDp2b2lkIHNldFRpbWVvdXQoZnVuY3Rpb24oKXtmb3IodmFyIGI9ZC5zZWxlY3Rpb24uaW5FZGl0b3IoKSYmZC5jb3JlLmhhc0ZvY3VzKCksZT0wO2U8Yy5sZW5ndGg7ZSsrKXt2YXIgZj1hKGNbZV0pLGc9Zi5kYXRhKFxcXCJjbWRcXFwiKTswPT1mLnBhcmVudHMoXFxcIi5mci1wb3B1cFxcXCIpLmxlbmd0aD9ifHxhLkZFLkNPTU1BTkRTW2ddJiZhLkZFLkNPTU1BTkRTW2ddLmZvcmNlZFJlZnJlc2g/ZC5idXR0b24ucmVmcmVzaChmKTpmLmhhc0NsYXNzKFxcXCJmci1kcm9wZG93blxcXCIpfHxmLnJlbW92ZUNsYXNzKFxcXCJmci1hY3RpdmVcXFwiKTpmLnBhcmVudHMoXFxcIi5mci1wb3B1cFxcXCIpLmlzKFxcXCI6dmlzaWJsZVxcXCIpJiZkLmJ1dHRvbi5yZWZyZXNoKGYpfX0sMCl9ZnVuY3Rpb24gcCgpe28ocyksbyh0KX1mdW5jdGlvbiBxKCl7cz1bXSx0PVtdfWZ1bmN0aW9uIHIoKXtiLm9wdHMudG9vbGJhcklubGluZT9iLmV2ZW50cy5vbihcXFwidG9vbGJhci5zaG93XFxcIixwKTooYi5ldmVudHMub24oXFxcIm1vdXNldXBcXFwiLHApLGIuZXZlbnRzLm9uKFxcXCJrZXl1cFxcXCIscCksYi5ldmVudHMub24oXFxcImJsdXJcXFwiLHApLGIuZXZlbnRzLm9uKFxcXCJmb2N1c1xcXCIscCksYi5ldmVudHMub24oXFxcImNvbnRlbnRDaGFuZ2VkXFxcIixwKSksYi5ldmVudHMub24oXFxcInNoYXJlZC5kZXN0cm95XFxcIixxKX12YXIgcz1bXTsoYi5vcHRzLnRvb2xiYXJJbmxpbmV8fGIub3B0cy50b29sYmFyQ29udGFpbmVyKSYmKGIuc2hhcmVkLmJ1dHRvbnN8fChiLnNoYXJlZC5idXR0b25zPVtdKSxzPWIuc2hhcmVkLmJ1dHRvbnMpO3ZhciB0PVtdO3JldHVybiBiLnNoYXJlZC5wb3B1cF9idXR0b25zfHwoYi5zaGFyZWQucG9wdXBfYnV0dG9ucz1bXSksdD1iLnNoYXJlZC5wb3B1cF9idXR0b25zLHtfaW5pdDpyLGJ1aWxkTGlzdDptLGJpbmRDb21tYW5kczpqLHJlZnJlc2g6bixidWxrUmVmcmVzaDpwLGV4ZWM6ZH19LGEuRkUuUE9QVVBfVEVNUExBVEVTPXtcXFwidGV4dC5lZGl0XFxcIjpcXFwiW19FRElUX11cXFwifSxhLkZFLlJlZ2lzdGVyVGVtcGxhdGU9ZnVuY3Rpb24oYixjKXthLkZFLlBPUFVQX1RFTVBMQVRFU1tiXT1jfSxhLkZFLk1PRFVMRVMucG9wdXBzPWZ1bmN0aW9uKGIpe2Z1bmN0aW9uIGMoYyxkKXtkLmlzKFxcXCI6dmlzaWJsZVxcXCIpfHwoZD1hKGIub3B0cy5zY3JvbGxhYmxlQ29udGFpbmVyKSksZC5pcyh4W2NdLmRhdGEoXFxcImNvbnRhaW5lclxcXCIpKXx8KHhbY10uZGF0YShcXFwiY29udGFpbmVyXFxcIixkKSxkLmFwcGVuZCh4W2NdKSl9ZnVuY3Rpb24gZChkLGUsaCxpKXtpZihnKCkmJmIuJGVsLmZpbmQoXFxcIi5mci1tYXJrZXJcXFwiKS5sZW5ndGg+MCYmKGIuZXZlbnRzLmRpc2FibGVCbHVyKCksYi5zZWxlY3Rpb24ucmVzdG9yZSgpKSxtKFtkXSksIXhbZF0pcmV0dXJuITE7YShcXFwiLmZyLWRyb3Bkb3duLmZyLWFjdGl2ZVxcXCIpLnJlbW92ZUNsYXNzKFxcXCJmci1hY3RpdmVcXFwiKS5wYXJlbnQoXFxcIi5mci10b29sYmFyXFxcIikuY3NzKFxcXCJ6SW5kZXhcXFwiLFxcXCJcXFwiKSx4W2RdLmRhdGEoXFxcImluc3RhbmNlXFxcIixiKSxiLiR0YiYmYi4kdGIuZGF0YShcXFwiaW5zdGFuY2VcXFwiLGIpO3ZhciBqPXhbZF0ub3V0ZXJXaWR0aCgpLGs9KHhbZF0ub3V0ZXJIZWlnaHQoKSxmKGQpKTt4W2RdLmFkZENsYXNzKFxcXCJmci1hY3RpdmVcXFwiKS5yZW1vdmVDbGFzcyhcXFwiZnItaGlkZGVuXFxcIikuZmluZChcXFwiaW5wdXQsIHRleHRhcmVhXFxcIikucmVtb3ZlQXR0cihcXFwiZGlzYWJsZWRcXFwiKTt2YXIgbD14W2RdLmRhdGEoXFxcImNvbnRhaW5lclxcXCIpO2Iub3B0cy50b29sYmFySW5saW5lJiZsJiZiLiR0YiYmbC5nZXQoMCk9PWIuJHRiLmdldCgwKSYmKGMoZCxhKGIub3B0cy5zY3JvbGxhYmxlQ29udGFpbmVyKSksaD1iLiR0Yi5vZmZzZXQoKS50b3AtYi5oZWxwZXJzLmdldFBYKGIuJHRiLmNzcyhcXFwibWFyZ2luLXRvcFxcXCIpKSxlPWIuJHRiLm9mZnNldCgpLmxlZnQrYi4kdGIub3V0ZXJXaWR0aCgpLzIrKHBhcnNlRmxvYXQoYi4kdGIuZmluZChcXFwiLmZyLWFycm93XFxcIikuY3NzKFxcXCJtYXJnaW4tbGVmdFxcXCIpKXx8MCkrYi4kdGIuZmluZChcXFwiLmZyLWFycm93XFxcIikub3V0ZXJXaWR0aCgpLzIsYi4kdGIuaGFzQ2xhc3MoXFxcImZyLWFib3ZlXFxcIikmJmgmJihoKz1iLiR0Yi5vdXRlckhlaWdodCgpKSxpPTApLGw9eFtkXS5kYXRhKFxcXCJjb250YWluZXJcXFwiKSwhYi5vcHRzLmlmcmFtZXx8aXx8a3x8KGUmJihlLT1iLiRpZnJhbWUub2Zmc2V0KCkubGVmdCksaCYmKGgtPWIuJGlmcmFtZS5vZmZzZXQoKS50b3ApKSxsLmlzKGIuJHRiKT9iLiR0Yi5jc3MoXFxcInpJbmRleFxcXCIsKGIub3B0cy56SW5kZXh8fDEpKzQpOnhbZF0uY3NzKFxcXCJ6SW5kZXhcXFwiLChiLm9wdHMuekluZGV4fHwxKSs0KSxlJiYoZS09ai8yKSxiLm9wdHMudG9vbGJhckJvdHRvbSYmbCYmYi4kdGImJmwuZ2V0KDApPT1iLiR0Yi5nZXQoMCkmJih4W2RdLmFkZENsYXNzKFxcXCJmci1hYm92ZVxcXCIpLGgmJihoLT14W2RdLm91dGVySGVpZ2h0KCkpKSx4W2RdLnJlbW92ZUNsYXNzKFxcXCJmci1hY3RpdmVcXFwiKSxiLnBvc2l0aW9uLmF0KGUsaCx4W2RdLGl8fDApLHhbZF0uYWRkQ2xhc3MoXFxcImZyLWFjdGl2ZVxcXCIpO3ZhciBuPXhbZF0uZmluZChcXFwiaW5wdXQ6dmlzaWJsZSwgdGV4dGFyZWE6dmlzaWJsZVxcXCIpLmdldCgwKTtuJiYoMD09Yi4kZWwuZmluZChcXFwiLmZyLW1hcmtlclxcXCIpLmxlbmd0aCYmYi5jb3JlLmhhc0ZvY3VzKCkmJmIuc2VsZWN0aW9uLnNhdmUoKSxiLmV2ZW50cy5kaXNhYmxlQmx1cigpLGEobikuc2VsZWN0KCkuZm9jdXMoKSksYi5vcHRzLnRvb2xiYXJJbmxpbmUmJmIudG9vbGJhci5oaWRlKCksYi5ldmVudHMudHJpZ2dlcihcXFwicG9wdXBzLnNob3cuXFxcIitkKSxzKGQpLl9yZXBvc2l0aW9uUG9wdXAoKSxvKCl9ZnVuY3Rpb24gZShhLGMpe2IuZXZlbnRzLm9uKFxcXCJwb3B1cHMuc2hvdy5cXFwiK2EsYyl9ZnVuY3Rpb24gZihhKXtyZXR1cm4geFthXSYmeFthXS5oYXNDbGFzcyhcXFwiZnItYWN0aXZlXFxcIikmJmIuY29yZS5zYW1lSW5zdGFuY2UoeFthXSl8fCExfWZ1bmN0aW9uIGcoYSl7Zm9yKHZhciBiIGluIHgpaWYoeC5oYXNPd25Qcm9wZXJ0eShiKSYmZihiKSYmKFxcXCJ1bmRlZmluZWRcXFwiPT10eXBlb2YgYXx8eFtiXS5kYXRhKFxcXCJpbnN0YW5jZVxcXCIpPT1hKSlyZXR1cm4hMDtyZXR1cm4hMX1mdW5jdGlvbiBoKGEpe3hbYV0mJnhbYV0uaGFzQ2xhc3MoXFxcImZyLWFjdGl2ZVxcXCIpJiYoeFthXS5yZW1vdmVDbGFzcyhcXFwiZnItYWN0aXZlIGZyLWFib3ZlXFxcIiksYi5ldmVudHMudHJpZ2dlcihcXFwicG9wdXBzLmhpZGUuXFxcIithKSxiLiR0YiYmKGIub3B0cy56SW5kZXg+MT9iLiR0Yi5jc3MoXFxcInpJbmRleFxcXCIsYi5vcHRzLnpJbmRleCsxKTpiLiR0Yi5jc3MoXFxcInpJbmRleFxcXCIsXFxcIlxcXCIpKSxiLmV2ZW50cy5kaXNhYmxlQmx1cigpLHhbYV0uZmluZChcXFwiaW5wdXQsIHRleHRhcmVhLCBidXR0b25cXFwiKS5maWx0ZXIoXFxcIjpmb2N1c1xcXCIpLmJsdXIoKSx4W2FdLmZpbmQoXFxcImlucHV0LCB0ZXh0YXJlYVxcXCIpLmF0dHIoXFxcImRpc2FibGVkXFxcIixcXFwiZGlzYWJsZWRcXFwiKSl9ZnVuY3Rpb24gaShhLGMpe2IuZXZlbnRzLm9uKFxcXCJwb3B1cHMuaGlkZS5cXFwiK2EsYyl9ZnVuY3Rpb24gaihhKXt2YXIgYz14W2FdO2lmKGMmJiFjLmRhdGEoXFxcImluc3RcXFwiK2IuaWQpKXt2YXIgZD1zKGEpO3QoZCxhKX1yZXR1cm4gY31mdW5jdGlvbiBrKGEsYyl7Yi5ldmVudHMub24oXFxcInBvcHVwcy5yZWZyZXNoLlxcXCIrYSxjKX1mdW5jdGlvbiBsKGMpe2IuZXZlbnRzLnRyaWdnZXIoXFxcInBvcHVwcy5yZWZyZXNoLlxcXCIrYyk7Zm9yKHZhciBkPXhbY10uZmluZChcXFwiLmZyLWNvbW1hbmRcXFwiKSxlPTA7ZTxkLmxlbmd0aDtlKyspe3ZhciBmPWEoZFtlXSk7MD09Zi5wYXJlbnRzKFxcXCIuZnItZHJvcGRvd24tbWVudVxcXCIpLmxlbmd0aCYmYi5idXR0b24ucmVmcmVzaChmKX19ZnVuY3Rpb24gbShhKXtcXFwidW5kZWZpbmVkXFxcIj09dHlwZW9mIGEmJihhPVtdKTtmb3IodmFyIGIgaW4geCl4Lmhhc093blByb3BlcnR5KGIpJiZhLmluZGV4T2YoYik8MCYmaChiKX1mdW5jdGlvbiBuKCl7Yi5zaGFyZWQuZXhpdF9mbGFnPSEwfWZ1bmN0aW9uIG8oKXtiLnNoYXJlZC5leGl0X2ZsYWc9ITF9ZnVuY3Rpb24gcCgpe3JldHVybiBiLnNoYXJlZC5leGl0X2ZsYWd9ZnVuY3Rpb24gcShjLGQpe3ZhciBlPWEuRkUuUE9QVVBfVEVNUExBVEVTW2NdO1xcXCJmdW5jdGlvblxcXCI9PXR5cGVvZiBlJiYoZT1lLmFwcGx5KGIpKTtmb3IodmFyIGYgaW4gZClkLmhhc093blByb3BlcnR5KGYpJiYoZT1lLnJlcGxhY2UoXFxcIltfXFxcIitmLnRvVXBwZXJDYXNlKCkrXFxcIl9dXFxcIixkW2ZdKSk7cmV0dXJuIGV9ZnVuY3Rpb24gcihjLGQpe3ZhciBlPXEoYyxkKSxmPWEoJzxkaXYgY2xhc3M9XFxcImZyLXBvcHVwJysoYi5oZWxwZXJzLmlzTW9iaWxlKCk/XFxcIiBmci1tb2JpbGVcXFwiOlxcXCIgZnItZGVza3RvcFxcXCIpKyhiLm9wdHMudG9vbGJhcklubGluZT9cXFwiIGZyLWlubGluZVxcXCI6XFxcIlxcXCIpKydcXFwiPjxzcGFuIGNsYXNzPVxcXCJmci1hcnJvd1xcXCI+PC9zcGFuPicrZStcXFwiPC9kaXY+XFxcIik7Yi5vcHRzLnRoZW1lJiZmLmFkZENsYXNzKGIub3B0cy50aGVtZStcXFwiLXRoZW1lXFxcIiksYi5vcHRzLnpJbmRleD4xJiZiLiR0Yi5jc3MoXFxcInotaW5kZXhcXFwiLGIub3B0cy56SW5kZXgrMiksXFxcImF1dG9cXFwiIT1iLm9wdHMuZGlyZWN0aW9uJiZmLnJlbW92ZUNsYXNzKFxcXCJmci1sdHIgZnItcnRsXFxcIikuYWRkQ2xhc3MoXFxcImZyLVxcXCIrYi5vcHRzLmRpcmVjdGlvbiksZi5maW5kKFxcXCJpbnB1dCwgdGV4dGFyZWFcXFwiKS5hdHRyKFxcXCJkaXJcXFwiLGIub3B0cy5kaXJlY3Rpb24pLmF0dHIoXFxcImRpc2FibGVkXFxcIixcXFwiZGlzYWJsZWRcXFwiKTt2YXIgZz1hKFxcXCJib2R5XFxcIik7cmV0dXJuIGcuYXBwZW5kKGYpLGYuZGF0YShcXFwiY29udGFpbmVyXFxcIixnKSx4W2NdPWYsYi5idXR0b24uYmluZENvbW1hbmRzKGYsITEpLGZ9ZnVuY3Rpb24gcyhjKXt2YXIgZD14W2NdO3JldHVybntfd2luZG93UmVzaXplOmZ1bmN0aW9uKCl7dmFyIGE9ZC5kYXRhKFxcXCJpbnN0YW5jZVxcXCIpfHxiOyFhLmhlbHBlcnMuaXNNb2JpbGUoKSYmZC5pcyhcXFwiOnZpc2libGVcXFwiKSYmKGEuZXZlbnRzLmRpc2FibGVCbHVyKCksYS5wb3B1cHMuaGlkZShjKSxhLmV2ZW50cy5lbmFibGVCbHVyKCkpfSxfaW5wdXRGb2N1czpmdW5jdGlvbihjKXt2YXIgZT1kLmRhdGEoXFxcImluc3RhbmNlXFxcIil8fGI7aWYoYy5wcmV2ZW50RGVmYXVsdCgpLGMuc3RvcFByb3BhZ2F0aW9uKCksc2V0VGltZW91dChmdW5jdGlvbigpe2UuZXZlbnRzLmVuYWJsZUJsdXIoKX0sMCksZS5oZWxwZXJzLmlzTW9iaWxlKCkpe3ZhciBmPWEoZS5vX3dpbikuc2Nyb2xsVG9wKCk7c2V0VGltZW91dChmdW5jdGlvbigpe2EoZS5vX3dpbikuc2Nyb2xsVG9wKGYpfSwwKX19LF9pbnB1dEJsdXI6ZnVuY3Rpb24oYyl7dmFyIGU9ZC5kYXRhKFxcXCJpbnN0YW5jZVxcXCIpfHxiO2RvY3VtZW50LmFjdGl2ZUVsZW1lbnQhPXRoaXMmJmEodGhpcykuaXMoXFxcIjp2aXNpYmxlXFxcIikmJihlLmV2ZW50cy5ibHVyQWN0aXZlKCkmJmUuZXZlbnRzLnRyaWdnZXIoXFxcImJsdXJcXFwiKSxlLmV2ZW50cy5lbmFibGVCbHVyKCkpfSxfaW5wdXRLZXlkb3duOmZ1bmN0aW9uKGUpe3ZhciBnPWQuZGF0YShcXFwiaW5zdGFuY2VcXFwiKXx8YixoPWUud2hpY2g7aWYoYS5GRS5LRVlDT0RFLlRBQj09aCl7ZS5wcmV2ZW50RGVmYXVsdCgpO3ZhciBpPWQuZmluZChcXFwiaW5wdXQsIHRleHRhcmVhLCBidXR0b24sIHNlbGVjdFxcXCIpLmZpbHRlcihcXFwiOnZpc2libGVcXFwiKS5ub3QoXFxcIjpkaXNhYmxlZFxcXCIpLnRvQXJyYXkoKTtpLnNvcnQoZnVuY3Rpb24oYixjKXtyZXR1cm4gZS5zaGlmdEtleT9hKGIpLmF0dHIoXFxcInRhYkluZGV4XFxcIik8YShjKS5hdHRyKFxcXCJ0YWJJbmRleFxcXCIpOmEoYikuYXR0cihcXFwidGFiSW5kZXhcXFwiKT5hKGMpLmF0dHIoXFxcInRhYkluZGV4XFxcIil9KSxnLmV2ZW50cy5kaXNhYmxlQmx1cigpO3ZhciBqPWkuaW5kZXhPZih0aGlzKSsxO2o9PWkubGVuZ3RoJiYoaj0wKSxhKGlbal0pLmZvY3VzKCl9ZWxzZSBpZihhLkZFLktFWUNPREUuRU5URVI9PWgpZC5maW5kKFxcXCIuZnItc3VibWl0OnZpc2libGVcXFwiKS5sZW5ndGg+MCYmKGUucHJldmVudERlZmF1bHQoKSxlLnN0b3BQcm9wYWdhdGlvbigpLGcuZXZlbnRzLmRpc2FibGVCbHVyKCksZy5idXR0b24uZXhlYyhkLmZpbmQoXFxcIi5mci1zdWJtaXQ6dmlzaWJsZTpmaXJzdFxcXCIpKSk7ZWxzZXtpZihhLkZFLktFWUNPREUuRVNDPT1oKXJldHVybiBlLnByZXZlbnREZWZhdWx0KCksZS5zdG9wUHJvcGFnYXRpb24oKSxnLiRlbC5maW5kKFxcXCIuZnItbWFya2VyXFxcIikmJihnLmV2ZW50cy5kaXNhYmxlQmx1cigpLGEodGhpcykuZGF0YShcXFwic2tpcFxcXCIsITApLGcuc2VsZWN0aW9uLnJlc3RvcmUoKSxnLmV2ZW50cy5lbmFibGVCbHVyKCkpLGYoYykmJmQuZmluZChcXFwiLmZyLWJhY2s6dmlzaWJsZVxcXCIpLmxlbmd0aD9nLmJ1dHRvbi5leGVjKGQuZmluZChcXFwiLmZyLWJhY2s6dmlzaWJsZTpmaXJzdFxcXCIpKTpnLnBvcHVwcy5oaWRlKGMpLGcub3B0cy50b29sYmFySW5saW5lJiZnLnRvb2xiYXIuc2hvd0lubGluZShudWxsLCEwKSwhMTtlLnN0b3BQcm9wYWdhdGlvbigpfX0sX3dpbmRvd0tleWRvd246ZnVuY3Rpb24oZSl7aWYoIWIuY29yZS5zYW1lSW5zdGFuY2UoZCkpcmV0dXJuITA7dmFyIGc9ZC5kYXRhKFxcXCJpbnN0YW5jZVxcXCIpfHxiLGg9ZS53aGljaDtpZihhLkZFLktFWUNPREUuRVNDPT1oKXtpZihmKGMpJiZnLm9wdHMudG9vbGJhcklubGluZSlyZXR1cm4gZS5zdG9wUHJvcGFnYXRpb24oKSxmKGMpJiZkLmZpbmQoXFxcIi5mci1iYWNrOnZpc2libGVcXFwiKS5sZW5ndGg/Zy5idXR0b24uZXhlYyhkLmZpbmQoXFxcIi5mci1iYWNrOnZpc2libGU6Zmlyc3RcXFwiKSk6KGcucG9wdXBzLmhpZGUoYyksZy50b29sYmFyLnNob3dJbmxpbmUobnVsbCwhMCkpLCExO2YoYykmJmQuZmluZChcXFwiLmZyLWJhY2s6dmlzaWJsZVxcXCIpLmxlbmd0aD9nLmJ1dHRvbi5leGVjKGQuZmluZChcXFwiLmZyLWJhY2s6dmlzaWJsZTpmaXJzdFxcXCIpKTpnLnBvcHVwcy5oaWRlKGMpfX0sX2VkaXRvcktleWRvd246ZnVuY3Rpb24oZSl7dmFyIGc9ZC5kYXRhKFxcXCJpbnN0YW5jZVxcXCIpfHxiO2cua2V5cy5jdHJsS2V5KGUpfHxlLndoaWNoPT1hLkZFLktFWUNPREUuRVNDfHwoZihjKSYmZC5maW5kKFxcXCIuZnItYmFjazp2aXNpYmxlXFxcIikubGVuZ3RoP2cuYnV0dG9uLmV4ZWMoZC5maW5kKFxcXCIuZnItYmFjazp2aXNpYmxlOmZpcnN0XFxcIikpOmcucG9wdXBzLmhpZGUoYykpfSxfcHJldmVudEZvY3VzOmZ1bmN0aW9uKGMpe3ZhciBlPWQuZGF0YShcXFwiaW5zdGFuY2VcXFwiKXx8YjtlLmV2ZW50cy5kaXNhYmxlQmx1cigpO3ZhciBmPWMub3JpZ2luYWxFdmVudD9jLm9yaWdpbmFsRXZlbnQudGFyZ2V0fHxjLm9yaWdpbmFsRXZlbnQub3JpZ2luYWxUYXJnZXQ6bnVsbCxnPVxcXCJpbnB1dCwgdGV4dGFyZWEsIGJ1dHRvbiwgc2VsZWN0LCBsYWJlbCwgLmZyLWNvbW1hbmRcXFwiO3JldHVybiBmJiYhYShmKS5pcyhnKSYmMD09PWEoZikucGFyZW50cyhnKS5sZW5ndGg/KGMuc3RvcFByb3BhZ2F0aW9uKCksITEpOihmJiZhKGYpLmlzKGcpJiZjLnN0b3BQcm9wYWdhdGlvbigpLHZvaWQgbygpKX0sX2VkaXRvck1vdXNldXA6ZnVuY3Rpb24oYSl7ZC5pcyhcXFwiOnZpc2libGVcXFwiKSYmcCgpJiZkLmZpbmQoXFxcImlucHV0OmZvY3VzLCB0ZXh0YXJlYTpmb2N1cywgYnV0dG9uOmZvY3VzLCBzZWxlY3Q6Zm9jdXNcXFwiKS5maWx0ZXIoXFxcIjp2aXNpYmxlXFxcIikubGVuZ3RoPjAmJmIuZXZlbnRzLmRpc2FibGVCbHVyKCl9LF93aW5kb3dNb3VzZXVwOmZ1bmN0aW9uKGEpe2lmKCFiLmNvcmUuc2FtZUluc3RhbmNlKGQpKXJldHVybiEwO3ZhciBlPWQuZGF0YShcXFwiaW5zdGFuY2VcXFwiKXx8YjtkLmlzKFxcXCI6dmlzaWJsZVxcXCIpJiZwKCkmJihhLnN0b3BQcm9wYWdhdGlvbigpLGUubWFya2Vycy5yZW1vdmUoKSxlLnBvcHVwcy5oaWRlKGMpLG8oKSl9LF9kb1BsYWNlaG9sZGVyOmZ1bmN0aW9uKGIpe3ZhciBjPWEodGhpcykubmV4dCgpOzA9PWMubGVuZ3RoJiZhKHRoaXMpLmFmdGVyKFxcXCI8bGFiZWw+XFxcIithKHRoaXMpLmF0dHIoXFxcInBsYWNlaG9sZGVyXFxcIikrXFxcIjwvbGFiZWw+XFxcIiksYSh0aGlzKS50b2dnbGVDbGFzcyhcXFwiZnItbm90LWVtcHR5XFxcIixcXFwiXFxcIiE9YSh0aGlzKS52YWwoKSl9LF9yZXBvc2l0aW9uUG9wdXA6ZnVuY3Rpb24oZSl7aWYoIWIub3B0cy5oZWlnaHQmJiFiLm9wdHMuaGVpZ2h0TWF4fHxiLm9wdHMudG9vbGJhcklubGluZSlyZXR1cm4hMDtpZihiLiR3cCYmZihjKSYmZC5wYXJlbnQoKS5nZXQoMCk9PWEoYi5vcHRzLnNjcm9sbGFibGVDb250YWluZXIpLmdldCgwKSl7dmFyIGc9ZC5vZmZzZXQoKS50b3AtYi4kd3Aub2Zmc2V0KCkudG9wLGg9Yi4kd3Aub3V0ZXJIZWlnaHQoKTtkLmhhc0NsYXNzKFxcXCJmci1hYm92ZVxcXCIpJiYoZys9ZC5vdXRlckhlaWdodCgpKSxnPmh8fDA+Zz9kLmFkZENsYXNzKFxcXCJmci1oaWRkZW5cXFwiKTpkLnJlbW92ZUNsYXNzKFxcXCJmci1oaWRkZW5cXFwiKX19fX1mdW5jdGlvbiB0KGEsYyl7Yi5ldmVudHMub24oXFxcIm1vdXNldXBcXFwiLGEuX2VkaXRvck1vdXNldXAsITApLGIuJHdwJiZiLmV2ZW50cy5vbihcXFwia2V5ZG93blxcXCIsYS5fZWRpdG9yS2V5ZG93biksYi5ldmVudHMub24oXFxcImJsdXJcXFwiLGZ1bmN0aW9uKGEpe2coKSYmYi5tYXJrZXJzLnJlbW92ZSgpLG0oKX0pLGIuJHdwJiYhYi5oZWxwZXJzLmlzTW9iaWxlKCkmJmIuZXZlbnRzLiRvbihiLiR3cCxcXFwic2Nyb2xsLnBvcHVwXFxcIitjLGEuX3JlcG9zaXRpb25Qb3B1cCksYi5ldmVudHMub24oXFxcIndpbmRvdy5rZXlkb3duXFxcIixhLl93aW5kb3dLZXlkb3duKSxiLmV2ZW50cy5vbihcXFwid2luZG93Lm1vdXNldXBcXFwiLGEuX3dpbmRvd01vdXNldXAsITApLHhbY10uZGF0YShcXFwiaW5zdFxcXCIrYi5pZCwhMCksYi5ldmVudHMub24oXFxcImRlc3Ryb3lcXFwiLGZ1bmN0aW9uKCl7Yi5jb3JlLnNhbWVJbnN0YW5jZSh4W2NdKSYmeFtjXS5yZW1vdmVDbGFzcyhcXFwiZnItYWN0aXZlXFxcIikuYXBwZW5kVG8oXFxcImJvZHlcXFwiKX0sITApfWZ1bmN0aW9uIHUoYyxkKXt2YXIgZT1yKGMsZCksZj1zKGMpO3JldHVybiB0KGYsYyksYi5ldmVudHMuJG9uKGUsXFxcIm1vdXNlZG93biBtb3VzZXVwIHRvdWNoc3RhcnQgdG91Y2hlbmQgdG91Y2hcXFwiLFxcXCIqXFxcIixmLl9wcmV2ZW50Rm9jdXMsITApLGIuZXZlbnRzLiRvbihlLFxcXCJmb2N1c1xcXCIsXFxcImlucHV0LCB0ZXh0YXJlYSwgYnV0dG9uLCBzZWxlY3RcXFwiLGYuX2lucHV0Rm9jdXMsITApLGIuZXZlbnRzLiRvbihlLFxcXCJibHVyXFxcIixcXFwiaW5wdXQsIHRleHRhcmVhLCBidXR0b24sIHNlbGVjdFxcXCIsZi5faW5wdXRCbHVyLCEwKSxiLmV2ZW50cy4kb24oZSxcXFwia2V5ZG93blxcXCIsXFxcImlucHV0LCB0ZXh0YXJlYSwgYnV0dG9uLCBzZWxlY3RcXFwiLGYuX2lucHV0S2V5ZG93biwhMCksYi5ldmVudHMuJG9uKGUsXFxcImtleWRvd24ga2V5dXAgY2hhbmdlIGlucHV0XFxcIixcXFwiaW5wdXQsIHRleHRhcmVhXFxcIixmLl9kb1BsYWNlaG9sZGVyLCEwKSxiLmhlbHBlcnMuaXNJT1MoKSYmYi5ldmVudHMuJG9uKGUsXFxcInRvdWNoZW5kXFxcIixcXFwibGFiZWxcXFwiLGZ1bmN0aW9uKCl7YShcXFwiI1xcXCIrYSh0aGlzKS5hdHRyKFxcXCJmb3JcXFwiKSkucHJvcChcXFwiY2hlY2tlZFxcXCIsZnVuY3Rpb24oYSxiKXtyZXR1cm4hYn0pfSwhMCksYi5ldmVudHMuJG9uKGEoYi5vX3dpbiksXFxcInJlc2l6ZVxcXCIsZi5fd2luZG93UmVzaXplLCEwKSxlfWZ1bmN0aW9uIHYoKXtmb3IodmFyIGEgaW4geClpZih4Lmhhc093blByb3BlcnR5KGEpKXt2YXIgYj14W2FdO2IuaHRtbChcXFwiXFxcIikucmVtb3ZlRGF0YSgpLnJlbW92ZSgpLHhbYV09bnVsbH14PVtdfWZ1bmN0aW9uIHcoKXtiLmV2ZW50cy5vbihcXFwic2hhcmVkLmRlc3Ryb3lcXFwiLHYsITApLGIuZXZlbnRzLm9uKFxcXCJ3aW5kb3cubW91c2Vkb3duXFxcIixuKSxiLmV2ZW50cy5vbihcXFwid2luZG93LnRvdWNobW92ZVxcXCIsbyksYi5ldmVudHMub24oXFxcIm1vdXNlZG93blxcXCIsZnVuY3Rpb24oYSl7ZygpJiYoYS5zdG9wUHJvcGFnYXRpb24oKSxiLiRlbC5maW5kKFxcXCIuZnItbWFya2VyXFxcIikucmVtb3ZlKCksbigpLGIuZXZlbnRzLmRpc2FibGVCbHVyKCkpfSl9Yi5zaGFyZWQucG9wdXBzfHwoYi5zaGFyZWQucG9wdXBzPXt9KTt2YXIgeD1iLnNoYXJlZC5wb3B1cHM7cmV0dXJuIGIuc2hhcmVkLmV4aXRfZmxhZz0hMSx7X2luaXQ6dyxjcmVhdGU6dSxnZXQ6aixzaG93OmQsaGlkZTpoLG9uSGlkZTppLGhpZGVBbGw6bSxzZXRDb250YWluZXI6YyxyZWZyZXNoOmwsb25SZWZyZXNoOmssb25TaG93OmUsaXNWaXNpYmxlOmYsYXJlVmlzaWJsZTpnfX0sYS5GRS5NT0RVTEVTLnBvc2l0aW9uPWZ1bmN0aW9uKGIpe2Z1bmN0aW9uIGMoKXt2YXIgYyxkPWIuc2VsZWN0aW9uLnJhbmdlcygwKTtpZihkJiZkLmNvbGxhcHNlZCYmYi5zZWxlY3Rpb24uaW5FZGl0b3IoKSl7dmFyIGU9ITE7MD09Yi4kZWwuZmluZChcXFwiLmZyLW1hcmtlclxcXCIpLmxlbmd0aCYmKGIuc2VsZWN0aW9uLnNhdmUoKSxlPSEwKTt2YXIgZj1iLiRlbC5maW5kKFxcXCIuZnItbWFya2VyOmZpcnN0XFxcIik7Zi5jc3MoXFxcImRpc3BsYXlcXFwiLFxcXCJpbmxpbmVcXFwiKSxmLmNzcyhcXFwibGluZS1oZWlnaHRcXFwiLFxcXCJcXFwiKTt2YXIgZz1mLm9mZnNldCgpLGg9Zi5vdXRlckhlaWdodCgpO2YuY3NzKFxcXCJkaXNwbGF5XFxcIixcXFwibm9uZVxcXCIpLGYuY3NzKFxcXCJsaW5lLWhlaWdodFxcXCIsMCksYz17fSxjLmxlZnQ9Zy5sZWZ0LGMud2lkdGg9MCxjLmhlaWdodD1oLGMudG9wPWcudG9wLShiLmhlbHBlcnMuaXNJT1MoKT8wOmEoYi5vX3dpbikuc2Nyb2xsVG9wKCkpLGMucmlnaHQ9MSxjLmJvdHRvbT0xLGMub2s9ITAsZSYmYi5zZWxlY3Rpb24ucmVzdG9yZSgpfWVsc2UgZCYmKGM9ZC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSk7cmV0dXJuIGN9ZnVuY3Rpb24gZChjLGQsZSl7dmFyIGY9Yy5vdXRlckhlaWdodCgpO2lmKCFiLmhlbHBlcnMuaXNNb2JpbGUoKSYmYi4kdGImJmMucGFyZW50KCkuZ2V0KDApIT1iLiR0Yi5nZXQoMCkpe3ZhciBnPShjLnBhcmVudCgpLmhlaWdodCgpLTIwLShiLm9wdHMudG9vbGJhckJvdHRvbT9iLiR0Yi5vdXRlckhlaWdodCgpOjApLGMucGFyZW50KCkub2Zmc2V0KCkudG9wKSxoPWQtZi0oZXx8MCk7Yy5wYXJlbnQoKS5nZXQoMCk9PWEoYi5vcHRzLnNjcm9sbGFibGVDb250YWluZXIpLmdldCgwKSYmKGctPWMucGFyZW50KCkucG9zaXRpb24oKS50b3ApO3ZhciBpPWEoYi5vcHRzLnNjcm9sbGFibGVDb250YWluZXIpLmdldCgwKS5zY3JvbGxIZWlnaHQ7ZytkK2Y+YShiLm9wdHMuc2Nyb2xsYWJsZUNvbnRhaW5lcikub2Zmc2V0KCkudG9wK2kmJmMucGFyZW50KCkub2Zmc2V0KCkudG9wK2g+MD8oZD1oLGMuYWRkQ2xhc3MoXFxcImZyLWFib3ZlXFxcIikpOmMucmVtb3ZlQ2xhc3MoXFxcImZyLWFib3ZlXFxcIil9cmV0dXJuIGR9ZnVuY3Rpb24gZShjLGQpe3ZhciBlPWMub3V0ZXJXaWR0aCgpO3JldHVybiBkK2U+YShiLm9wdHMuc2Nyb2xsYWJsZUNvbnRhaW5lcikud2lkdGgoKS0xMCYmKGQ9YShiLm9wdHMuc2Nyb2xsYWJsZUNvbnRhaW5lcikud2lkdGgoKS1lLTEwKSwwPmQmJihkPTEwKSxkfWZ1bmN0aW9uIGYoZCl7dmFyIGU9YygpO2QuY3NzKFxcXCJ0b3BcXFwiLDApLmNzcyhcXFwibGVmdFxcXCIsMCk7dmFyIGY9ZS50b3ArZS5oZWlnaHQsaD1lLmxlZnQrZS53aWR0aC8yLWQub3V0ZXJXaWR0aCgpLzIrYShiLm9fd2luKS5zY3JvbGxMZWZ0KCk7Yi5vcHRzLmlmcmFtZXx8KGYrPWEoYi5vX3dpbikuc2Nyb2xsVG9wKCkpLGcoaCxmLGQsZS5oZWlnaHQpfWZ1bmN0aW9uIGcoYSxjLGYsZyl7dmFyIGg9Zi5kYXRhKFxcXCJjb250YWluZXJcXFwiKTshaHx8aC5pcyhcXFwiYm9keVxcXCIpJiZcXFwic3RhdGljXFxcIj09aC5jc3MoXFxcInBvc2l0aW9uXFxcIil8fChhJiYoYS09aC5vZmZzZXQoKS5sZWZ0KSxjJiYoYy09aC5vZmZzZXQoKS50b3ApLFxcXCJCT0RZXFxcIiE9aC5nZXQoMCkudGFnTmFtZT8oYSYmKGErPWguc2Nyb2xsTGVmdCgpKSxjJiYoYys9aC5zY3JvbGxUb3AoKSkpOlxcXCJhYnNvbHV0ZVxcXCI9PWguY3NzKFxcXCJwb3NpdGlvblxcXCIpJiYoYSYmKGErPWgucG9zaXRpb24oKS5sZWZ0KSxjJiYoYys9aC5wb3NpdGlvbigpLnRvcCkpKSxiLm9wdHMuaWZyYW1lJiZoJiZiLiR0YiYmaC5nZXQoMCkhPWIuJHRiLmdldCgwKSYmKGEmJihhKz1iLiRpZnJhbWUub2Zmc2V0KCkubGVmdCksYyYmKGMrPWIuJGlmcmFtZS5vZmZzZXQoKS50b3ApKTt2YXIgaT1lKGYsYSk7aWYoYSl7Zi5jc3MoXFxcImxlZnRcXFwiLGkpO3ZhciBqPWYuZmluZChcXFwiLmZyLWFycm93XFxcIik7ai5kYXRhKFxcXCJtYXJnaW4tbGVmdFxcXCIpfHxqLmRhdGEoXFxcIm1hcmdpbi1sZWZ0XFxcIixiLmhlbHBlcnMuZ2V0UFgoai5jc3MoXFxcIm1hcmdpbi1sZWZ0XFxcIikpKSxqLmNzcyhcXFwibWFyZ2luLWxlZnRcXFwiLGEtaStqLmRhdGEoXFxcIm1hcmdpbi1sZWZ0XFxcIikpfWMmJmYuY3NzKFxcXCJ0b3BcXFwiLGQoZixjLGcpKX1mdW5jdGlvbiBoKGMpe3ZhciBkPWEoYyksZT1kLmlzKFxcXCIuZnItc3RpY2t5LW9uXFxcIiksZj1kLmRhdGEoXFxcInN0aWNreS10b3BcXFwiKSxnPWQuZGF0YShcXFwic3RpY2t5LXNjaGVkdWxlZFxcXCIpO2lmKFxcXCJ1bmRlZmluZWRcXFwiPT10eXBlb2YgZil7ZC5kYXRhKFxcXCJzdGlja3ktdG9wXFxcIiwwKTt2YXIgaD1hKCc8ZGl2IGNsYXNzPVxcXCJmci1zdGlja3ktZHVtbXlcXFwiIHN0eWxlPVxcXCJoZWlnaHQ6ICcrZC5vdXRlckhlaWdodCgpKydweDtcXFwiPjwvZGl2PicpO2IuJGJveC5wcmVwZW5kKGgpfWVsc2UgYi4kYm94LmZpbmQoXFxcIi5mci1zdGlja3ktZHVtbXlcXFwiKS5jc3MoXFxcImhlaWdodFxcXCIsZC5vdXRlckhlaWdodCgpKTtpZihiLmNvcmUuaGFzRm9jdXMoKXx8Yi4kdGIuZmluZChcXFwiaW5wdXQ6dmlzaWJsZTpmb2N1c1xcXCIpLmxlbmd0aD4wKXt2YXIgaT1hKHdpbmRvdykuc2Nyb2xsVG9wKCksaj1NYXRoLm1pbihNYXRoLm1heChpLWIuJHRiLnBhcmVudCgpLm9mZnNldCgpLnRvcCwwKSxiLiR0Yi5wYXJlbnQoKS5vdXRlckhlaWdodCgpLWQub3V0ZXJIZWlnaHQoKSk7aiE9ZiYmaiE9ZyYmKGNsZWFyVGltZW91dChkLmRhdGEoXFxcInN0aWNreS10aW1lb3V0XFxcIikpLGQuZGF0YShcXFwic3RpY2t5LXNjaGVkdWxlZFxcXCIsaiksZC5vdXRlckhlaWdodCgpPGktYi4kdGIucGFyZW50KCkub2Zmc2V0KCkudG9wJiZkLmFkZENsYXNzKFxcXCJmci1vcGFjaXR5LTBcXFwiKSxkLmRhdGEoXFxcInN0aWNreS10aW1lb3V0XFxcIixzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7dmFyIGM9YSh3aW5kb3cpLnNjcm9sbFRvcCgpLGU9TWF0aC5taW4oTWF0aC5tYXgoYy1iLiR0Yi5wYXJlbnQoKS5vZmZzZXQoKS50b3AsMCksYi4kdGIucGFyZW50KCkub3V0ZXJIZWlnaHQoKS1kLm91dGVySGVpZ2h0KCkpO2U+MCYmXFxcIkJPRFlcXFwiPT1iLiR0Yi5wYXJlbnQoKS5nZXQoMCkudGFnTmFtZSYmKGUrPWIuJHRiLnBhcmVudCgpLnBvc2l0aW9uKCkudG9wKSxlIT1mJiYoZC5jc3MoXFxcInRvcFxcXCIsTWF0aC5tYXgoZSwwKSksZC5kYXRhKFxcXCJzdGlja3ktdG9wXFxcIixlKSxkLmRhdGEoXFxcInN0aWNreS1zY2hlZHVsZWRcXFwiLGUpKSxkLnJlbW92ZUNsYXNzKFxcXCJmci1vcGFjaXR5LTBcXFwiKX0sMTAwKSkpLGV8fChkLmNzcyhcXFwidG9wXFxcIixcXFwiMFxcXCIpLGQud2lkdGgoYi4kdGIucGFyZW50KCkud2lkdGgoKSksZC5hZGRDbGFzcyhcXFwiZnItc3RpY2t5LW9uXFxcIiksYi4kYm94LmFkZENsYXNzKFxcXCJmci1zdGlja3ktYm94XFxcIikpfWVsc2UgY2xlYXJUaW1lb3V0KGEoYykuY3NzKFxcXCJzdGlja3ktdGltZW91dFxcXCIpKSxkLmNzcyhcXFwidG9wXFxcIixcXFwiMFxcXCIpLGQuY3NzKFxcXCJwb3NpdGlvblxcXCIsXFxcIlxcXCIpLGQud2lkdGgoXFxcIlxcXCIpLGQuZGF0YShcXFwic3RpY2t5LXRvcFxcXCIsMCksZC5yZW1vdmVDbGFzcyhcXFwiZnItc3RpY2t5LW9uXFxcIiksYi4kYm94LnJlbW92ZUNsYXNzKFxcXCJmci1zdGlja3ktYm94XFxcIil9ZnVuY3Rpb24gaShjKXtpZihjLm9mZnNldFdpZHRoKXt2YXIgZCxlLGY9YShjKSxnPWYub3V0ZXJIZWlnaHQoKSxoPWYuZGF0YShcXFwic3RpY2t5LXBvc2l0aW9uXFxcIiksaT1hKFxcXCJib2R5XFxcIj09Yi5vcHRzLnNjcm9sbGFibGVDb250YWluZXI/Yi5vX3dpbjpiLm9wdHMuc2Nyb2xsYWJsZUNvbnRhaW5lcikub3V0ZXJIZWlnaHQoKSxqPTAsaz0wO1xcXCJib2R5XFxcIiE9PWIub3B0cy5zY3JvbGxhYmxlQ29udGFpbmVyJiYoaj1hKGIub3B0cy5zY3JvbGxhYmxlQ29udGFpbmVyKS5vZmZzZXQoKS50b3Asaz1hKGIub193aW4pLm91dGVySGVpZ2h0KCktai1pKTt2YXIgbD1cXFwiYm9keVxcXCI9PWIub3B0cy5zY3JvbGxhYmxlQ29udGFpbmVyP2EoYi5vX3dpbikuc2Nyb2xsVG9wKCk6aixtPWYuaXMoXFxcIi5mci1zdGlja3ktb25cXFwiKTtmLmRhdGEoXFxcInN0aWNreS1wYXJlbnRcXFwiKXx8Zi5kYXRhKFxcXCJzdGlja3ktcGFyZW50XFxcIixmLnBhcmVudCgpKTt2YXIgbj1mLmRhdGEoXFxcInN0aWNreS1wYXJlbnRcXFwiKSxvPW4ub2Zmc2V0KCkudG9wLHA9bi5vdXRlckhlaWdodCgpO2lmKGYuZGF0YShcXFwic3RpY2t5LW9mZnNldFxcXCIpfHwoZi5kYXRhKFxcXCJzdGlja3ktb2Zmc2V0XFxcIiwhMCksZi5hZnRlcignPGRpdiBjbGFzcz1cXFwiZnItc3RpY2t5LWR1bW15XFxcIiBzdHlsZT1cXFwiaGVpZ2h0OiAnK2crJ3B4O1xcXCI+PC9kaXY+JykpLCFoKXt2YXIgcT1cXFwiYXV0b1xcXCIhPT1mLmNzcyhcXFwidG9wXFxcIil8fFxcXCJhdXRvXFxcIiE9PWYuY3NzKFxcXCJib3R0b21cXFwiKTtxfHxmLmNzcyhcXFwicG9zaXRpb25cXFwiLFxcXCJmaXhlZFxcXCIpLGg9e3RvcDpmLmhhc0NsYXNzKFxcXCJmci10b3BcXFwiKSxib3R0b206Zi5oYXNDbGFzcyhcXFwiZnItYm90dG9tXFxcIil9LHF8fGYuY3NzKFxcXCJwb3NpdGlvblxcXCIsXFxcIlxcXCIpLGYuZGF0YShcXFwic3RpY2t5LXBvc2l0aW9uXFxcIixoKSxmLmRhdGEoXFxcInRvcFxcXCIsZi5oYXNDbGFzcyhcXFwiZnItdG9wXFxcIik/Zi5jc3MoXFxcInRvcFxcXCIpOlxcXCJhdXRvXFxcIiksZi5kYXRhKFxcXCJib3R0b21cXFwiLGYuaGFzQ2xhc3MoXFxcImZyLWJvdHRvbVxcXCIpP2YuY3NzKFxcXCJib3R0b21cXFwiKTpcXFwiYXV0b1xcXCIpfXZhciByPWZ1bmN0aW9uKCl7cmV0dXJuIGwrZD5vJiZvK3AtZz49bCtkfSxzPWZ1bmN0aW9uKCl7cmV0dXJuIGwraS1lPm8rZyYmbytwPmwraS1lfTtkPWIuaGVscGVycy5nZXRQWChmLmRhdGEoXFxcInRvcFxcXCIpKSxlPWIuaGVscGVycy5nZXRQWChmLmRhdGEoXFxcImJvdHRvbVxcXCIpKTt2YXIgdD1oLnRvcCYmcigpLHU9aC5ib3R0b20mJnMoKTt0fHx1PyhmLmNzcyhcXFwid2lkdGhcXFwiLG4ud2lkdGgoKStcXFwicHhcXFwiKSxtfHwoZi5hZGRDbGFzcyhcXFwiZnItc3RpY2t5LW9uXFxcIiksZi5yZW1vdmVDbGFzcyhcXFwiZnItc3RpY2t5LW9mZlxcXCIpLGYuY3NzKFxcXCJ0b3BcXFwiKSYmKFxcXCJhdXRvXFxcIiE9Zi5kYXRhKFxcXCJ0b3BcXFwiKT9mLmNzcyhcXFwidG9wXFxcIixiLmhlbHBlcnMuZ2V0UFgoZi5kYXRhKFxcXCJ0b3BcXFwiKSkraik6Zi5kYXRhKFxcXCJ0b3BcXFwiLFxcXCJhdXRvXFxcIikpLGYuY3NzKFxcXCJib3R0b21cXFwiKSYmKFxcXCJhdXRvXFxcIiE9Zi5kYXRhKFxcXCJib3R0b21cXFwiKT9mLmNzcyhcXFwiYm90dG9tXFxcIixiLmhlbHBlcnMuZ2V0UFgoZi5kYXRhKFxcXCJib3R0b21cXFwiKSkrayk6Zi5jc3MoXFxcImJvdHRvbVxcXCIsXFxcImF1dG9cXFwiKSkpKTpmLmhhc0NsYXNzKFxcXCJmci1zdGlja3ktb2ZmXFxcIil8fChmLndpZHRoKFxcXCJcXFwiKSxmLnJlbW92ZUNsYXNzKFxcXCJmci1zdGlja3ktb25cXFwiKSxmLmFkZENsYXNzKFxcXCJmci1zdGlja3ktb2ZmXFxcIiksZi5jc3MoXFxcInRvcFxcXCIpJiZcXFwiYXV0b1xcXCIhPWYuZGF0YShcXFwidG9wXFxcIikmJmgudG9wJiZmLmNzcyhcXFwidG9wXFxcIiwwKSxmLmNzcyhcXFwiYm90dG9tXFxcIikmJlxcXCJhdXRvXFxcIiE9Zi5kYXRhKFxcXCJib3R0b21cXFwiKSYmaC5ib3R0b20mJmYuY3NzKFxcXCJib3R0b21cXFwiLDApKX19ZnVuY3Rpb24gaigpe3ZhciBhPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXFxcInRlc3RcXFwiKSxjPWEuc3R5bGU7cmV0dXJuIGMuY3NzVGV4dD1cXFwicG9zaXRpb246XFxcIitbXFxcIi13ZWJraXQtXFxcIixcXFwiLW1vei1cXFwiLFxcXCItbXMtXFxcIixcXFwiLW8tXFxcIixcXFwiXFxcIl0uam9pbihcXFwic3RpY2t5OyBwb3NpdGlvbjpcXFwiKStcXFwiIHN0aWNreTtcXFwiLC0xIT09Yy5wb3NpdGlvbi5pbmRleE9mKFxcXCJzdGlja3lcXFwiKSYmIWIuaGVscGVycy5pc0lPUygpJiYhYi5oZWxwZXJzLmlzQW5kcm9pZCgpfWZ1bmN0aW9uIGsoKXtpZighaigpKWlmKGIuX3N0aWNreUVsZW1lbnRzPVtdLGIuaGVscGVycy5pc0lPUygpKXt2YXIgYz1mdW5jdGlvbigpe2IuaGVscGVycy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKShjKTtmb3IodmFyIGE9MDthPGIuX3N0aWNreUVsZW1lbnRzLmxlbmd0aDthKyspaChiLl9zdGlja3lFbGVtZW50c1thXSl9O2MoKSxiLmV2ZW50cy4kb24oYShiLm9fd2luKSxcXFwic2Nyb2xsXFxcIixmdW5jdGlvbigpe2lmKGIuY29yZS5oYXNGb2N1cygpKWZvcih2YXIgYz0wO2M8Yi5fc3RpY2t5RWxlbWVudHMubGVuZ3RoO2MrKyl7dmFyIGQ9YShiLl9zdGlja3lFbGVtZW50c1tjXSksZT1kLnBhcmVudCgpLGY9YSh3aW5kb3cpLnNjcm9sbFRvcCgpO2Qub3V0ZXJIZWlnaHQoKTxmLWUub2Zmc2V0KCkudG9wJiYoZC5hZGRDbGFzcyhcXFwiZnItb3BhY2l0eS0wXFxcIiksZC5kYXRhKFxcXCJzdGlja3ktdG9wXFxcIiwtMSksZC5kYXRhKFxcXCJzdGlja3ktc2NoZWR1bGVkXFxcIiwtMSkpfX0sITApfWVsc2UgYi5ldmVudHMuJG9uKGEoXFxcImJvZHlcXFwiPT1iLm9wdHMuc2Nyb2xsYWJsZUNvbnRhaW5lcj9iLm9fd2luOmIub3B0cy5zY3JvbGxhYmxlQ29udGFpbmVyKSxcXFwic2Nyb2xsXFxcIixsLCEwKSxiLmV2ZW50cy4kb24oYShiLm9fd2luKSxcXFwicmVzaXplXFxcIixsLCEwKSxiLmV2ZW50cy5vbihcXFwiaW5pdGlhbGl6ZWRcXFwiLGwpLGIuZXZlbnRzLm9uKFxcXCJmb2N1c1xcXCIsbCksYi5ldmVudHMuJG9uKGEoYi5vX3dpbiksXFxcInJlc2l6ZVxcXCIsXFxcInRleHRhcmVhXFxcIixsLCEwKTtiLmV2ZW50cy5vbihcXFwiZGVzdHJveVxcXCIsZnVuY3Rpb24oYSl7Yi5fc3RpY2t5RWxlbWVudHM9W119KX1mdW5jdGlvbiBsKCl7Zm9yKHZhciBhPTA7YTxiLl9zdGlja3lFbGVtZW50cy5sZW5ndGg7YSsrKWkoYi5fc3RpY2t5RWxlbWVudHNbYV0pfWZ1bmN0aW9uIG0oYSl7YS5hZGRDbGFzcyhcXFwiZnItc3RpY2t5XFxcIiksYi5oZWxwZXJzLmlzSU9TKCkmJmEuYWRkQ2xhc3MoXFxcImZyLXN0aWNreS1pb3NcXFwiKSxqKCl8fGIuX3N0aWNreUVsZW1lbnRzLnB1c2goYS5nZXQoMCkpfWZ1bmN0aW9uIG4oKXtrKCl9cmV0dXJue19pbml0Om4sZm9yU2VsZWN0aW9uOmYsYWRkU3RpY2t5Om0scmVmcmVzaDpsLGF0OmcsZ2V0Qm91bmRpbmdSZWN0OmN9fSxhLkZFLk1PRFVMRVMucmVmcmVzaD1mdW5jdGlvbihiKXtmdW5jdGlvbiBjKGEpe2EudG9nZ2xlQ2xhc3MoXFxcImZyLWRpc2FibGVkXFxcIiwhYi51bmRvLmNhbkRvKCkpfWZ1bmN0aW9uIGQoYSl7YS50b2dnbGVDbGFzcyhcXFwiZnItZGlzYWJsZWRcXFwiLCFiLnVuZG8uY2FuUmVkbygpKX1mdW5jdGlvbiBlKGEpe2lmKGEuaGFzQ2xhc3MoXFxcImZyLW5vLXJlZnJlc2hcXFwiKSlyZXR1cm4hMTtmb3IodmFyIGM9Yi5zZWxlY3Rpb24uYmxvY2tzKCksZD0wO2Q8Yy5sZW5ndGg7ZCsrKXtmb3IodmFyIGU9Y1tkXS5wcmV2aW91c1NpYmxpbmc7ZSYmZS5ub2RlVHlwZT09Tm9kZS5URVhUX05PREUmJjA9PT1lLnRleHRDb250ZW50Lmxlbmd0aDspZT1lLnByZXZpb3VzU2libGluZztpZihcXFwiTElcXFwiIT1jW2RdLnRhZ05hbWV8fGUpcmV0dXJuIGEucmVtb3ZlQ2xhc3MoXFxcImZyLWRpc2FibGVkXFxcIiksITA7YS5hZGRDbGFzcyhcXFwiZnItZGlzYWJsZWRcXFwiKX19ZnVuY3Rpb24gZihjKXtpZihjLmhhc0NsYXNzKFxcXCJmci1uby1yZWZyZXNoXFxcIikpcmV0dXJuITE7Zm9yKHZhciBkPWIuc2VsZWN0aW9uLmJsb2NrcygpLGU9MDtlPGQubGVuZ3RoO2UrKyl7dmFyIGY9XFxcInJ0bFxcXCI9PWIub3B0cy5kaXJlY3Rpb258fFxcXCJydGxcXFwiPT1hKGRbZV0pLmNzcyhcXFwiZGlyZWN0aW9uXFxcIik/XFxcIm1hcmdpbi1yaWdodFxcXCI6XFxcIm1hcmdpbi1sZWZ0XFxcIjtpZihcXFwiTElcXFwiPT1kW2VdLnRhZ05hbWV8fFxcXCJMSVxcXCI9PWRbZV0ucGFyZW50Tm9kZS50YWdOYW1lKXJldHVybiBjLnJlbW92ZUNsYXNzKFxcXCJmci1kaXNhYmxlZFxcXCIpLCEwO2lmKGIuaGVscGVycy5nZXRQWChhKGRbZV0pLmNzcyhmKSk+MClyZXR1cm4gYy5yZW1vdmVDbGFzcyhcXFwiZnItZGlzYWJsZWRcXFwiKSwhMH1jLmFkZENsYXNzKFxcXCJmci1kaXNhYmxlZFxcXCIpfXJldHVybnt1bmRvOmMscmVkbzpkLG91dGRlbnQ6ZixpbmRlbnQ6ZX19LGEuZXh0ZW5kKGEuRkUuREVGQVVMVFMse2VkaXRJblBvcHVwOiExfSksYS5GRS5NT0RVTEVTLnRleHRFZGl0PWZ1bmN0aW9uKGIpe2Z1bmN0aW9uIGMoKXt2YXIgYT0nPGRpdiBpZD1cXFwiZnItdGV4dC1lZGl0LScrYi5pZCsnXFxcIiBjbGFzcz1cXFwiZnItbGF5ZXIgZnItdGV4dC1lZGl0LWxheWVyXFxcIj48ZGl2IGNsYXNzPVxcXCJmci1pbnB1dC1saW5lXFxcIj48aW5wdXQgdHlwZT1cXFwidGV4dFxcXCIgcGxhY2Vob2xkZXI9XFxcIicrYi5sYW5ndWFnZS50cmFuc2xhdGUoXFxcIlRleHRcXFwiKSsnXFxcIiB0YWJJbmRleD1cXFwiMVxcXCI+PC9kaXY+PGRpdiBjbGFzcz1cXFwiZnItYWN0aW9uLWJ1dHRvbnNcXFwiPjxidXR0b24gdHlwZT1cXFwiYnV0dG9uXFxcIiBjbGFzcz1cXFwiZnItY29tbWFuZCBmci1zdWJtaXRcXFwiIGRhdGEtY21kPVxcXCJ1cGRhdGVUZXh0XFxcIiB0YWJJbmRleD1cXFwiMlxcXCI+JytiLmxhbmd1YWdlLnRyYW5zbGF0ZShcXFwiVXBkYXRlXFxcIikrXFxcIjwvYnV0dG9uPjwvZGl2PjwvZGl2PlxcXCIsYz17ZWRpdDphfTtiLnBvcHVwcy5jcmVhdGUoXFxcInRleHQuZWRpdFxcXCIsYyl9ZnVuY3Rpb24gZCgpe3ZhciBjLGQ9Yi5wb3B1cHMuZ2V0KFxcXCJ0ZXh0LmVkaXRcXFwiKTtjPVxcXCJJTlBVVFxcXCI9PT1iLiRlbC5wcm9wKFxcXCJ0YWdOYW1lXFxcIik/Yi4kZWwuYXR0cihcXFwicGxhY2Vob2xkZXJcXFwiKTpiLiRlbC50ZXh0KCksZC5maW5kKFxcXCJpbnB1dFxcXCIpLnZhbChjKS50cmlnZ2VyKFxcXCJjaGFuZ2VcXFwiKSxiLnBvcHVwcy5zZXRDb250YWluZXIoXFxcInRleHQuZWRpdFxcXCIsYShcXFwiYm9keVxcXCIpKSxiLnBvcHVwcy5zaG93KFxcXCJ0ZXh0LmVkaXRcXFwiLGIuJGVsLm9mZnNldCgpLmxlZnQrYi4kZWwub3V0ZXJXaWR0aCgpLzIsYi4kZWwub2Zmc2V0KCkudG9wK2IuJGVsLm91dGVySGVpZ2h0KCksYi4kZWwub3V0ZXJIZWlnaHQoKSl9ZnVuY3Rpb24gZSgpe2IuZXZlbnRzLiRvbihiLiRlbCxiLl9tb3VzZXVwLGZ1bmN0aW9uKGEpe3NldFRpbWVvdXQoZnVuY3Rpb24oKXtkKCl9LDEwKX0pfWZ1bmN0aW9uIGYoKXt2YXIgYT1iLnBvcHVwcy5nZXQoXFxcInRleHQuZWRpdFxcXCIpLGM9YS5maW5kKFxcXCJpbnB1dFxcXCIpLnZhbCgpOzA9PWMubGVuZ3RoJiYoYz1iLm9wdHMucGxhY2Vob2xkZXJUZXh0KSxcXFwiSU5QVVRcXFwiPT09Yi4kZWwucHJvcChcXFwidGFnTmFtZVxcXCIpP2IuJGVsLmF0dHIoXFxcInBsYWNlaG9sZGVyXFxcIixjKTpiLiRlbC50ZXh0KGMpLGIuZXZlbnRzLnRyaWdnZXIoXFxcImNvbnRlbnRDaGFuZ2VkXFxcIiksYi5wb3B1cHMuaGlkZShcXFwidGV4dC5lZGl0XFxcIil9ZnVuY3Rpb24gZygpe2Iub3B0cy5lZGl0SW5Qb3B1cCYmKGMoKSxlKCkpfXJldHVybntfaW5pdDpnLHVwZGF0ZTpmfX0sYS5GRS5SZWdpc3RlckNvbW1hbmQoXFxcInVwZGF0ZVRleHRcXFwiLHtmb2N1czohMSx1bmRvOiExLGNhbGxiYWNrOmZ1bmN0aW9uKCl7dGhpcy50ZXh0RWRpdC51cGRhdGUoKX19KSxhLmV4dGVuZChhLkZFLkRFRkFVTFRTLHt0b29sYmFyQm90dG9tOiExLHRvb2xiYXJCdXR0b25zOltcXFwiZnVsbHNjcmVlblxcXCIsXFxcImJvbGRcXFwiLFxcXCJpdGFsaWNcXFwiLFxcXCJ1bmRlcmxpbmVcXFwiLFxcXCJzdHJpa2VUaHJvdWdoXFxcIixcXFwic3Vic2NyaXB0XFxcIixcXFwic3VwZXJzY3JpcHRcXFwiLFxcXCJmb250RmFtaWx5XFxcIixcXFwiZm9udFNpemVcXFwiLFxcXCJ8XFxcIixcXFwiY29sb3JcXFwiLFxcXCJlbW90aWNvbnNcXFwiLFxcXCJpbmxpbmVTdHlsZVxcXCIsXFxcInBhcmFncmFwaFN0eWxlXFxcIixcXFwifFxcXCIsXFxcInBhcmFncmFwaEZvcm1hdFxcXCIsXFxcImFsaWduXFxcIixcXFwiZm9ybWF0T0xcXFwiLFxcXCJmb3JtYXRVTFxcXCIsXFxcIm91dGRlbnRcXFwiLFxcXCJpbmRlbnRcXFwiLFxcXCJxdW90ZVxcXCIsXFxcImluc2VydEhSXFxcIixcXFwiLVxcXCIsXFxcImluc2VydExpbmtcXFwiLFxcXCJpbnNlcnRJbWFnZVxcXCIsXFxcImluc2VydFZpZGVvXFxcIixcXFwiaW5zZXJ0RmlsZVxcXCIsXFxcImluc2VydFRhYmxlXFxcIixcXFwidW5kb1xcXCIsXFxcInJlZG9cXFwiLFxcXCJjbGVhckZvcm1hdHRpbmdcXFwiLFxcXCJzZWxlY3RBbGxcXFwiLFxcXCJodG1sXFxcIixcXFwiYXBwbHlGb3JtYXRcXFwiLFxcXCJyZW1vdmVGb3JtYXRcXFwiXSx0b29sYmFyQnV0dG9uc1hTOltcXFwiYm9sZFxcXCIsXFxcIml0YWxpY1xcXCIsXFxcImZvbnRGYW1pbHlcXFwiLFxcXCJmb250U2l6ZVxcXCIsXFxcInxcXFwiLFxcXCJ1bmRvXFxcIixcXFwicmVkb1xcXCJdLHRvb2xiYXJCdXR0b25zU006W1xcXCJib2xkXFxcIixcXFwiaXRhbGljXFxcIixcXFwidW5kZXJsaW5lXFxcIixcXFwifFxcXCIsXFxcImZvbnRGYW1pbHlcXFwiLFxcXCJmb250U2l6ZVxcXCIsXFxcImluc2VydExpbmtcXFwiLFxcXCJpbnNlcnRJbWFnZVxcXCIsXFxcInRhYmxlXFxcIixcXFwifFxcXCIsXFxcInVuZG9cXFwiLFxcXCJyZWRvXFxcIl0sdG9vbGJhckJ1dHRvbnNNRDpbXFxcImZ1bGxzY3JlZW5cXFwiLFxcXCJib2xkXFxcIixcXFwiaXRhbGljXFxcIixcXFwidW5kZXJsaW5lXFxcIixcXFwiZm9udEZhbWlseVxcXCIsXFxcImZvbnRTaXplXFxcIixcXFwiY29sb3JcXFwiLFxcXCJwYXJhZ3JhcGhTdHlsZVxcXCIsXFxcInBhcmFncmFwaEZvcm1hdFxcXCIsXFxcImFsaWduXFxcIixcXFwiZm9ybWF0T0xcXFwiLFxcXCJmb3JtYXRVTFxcXCIsXFxcIm91dGRlbnRcXFwiLFxcXCJpbmRlbnRcXFwiLFxcXCJxdW90ZVxcXCIsXFxcImluc2VydEhSXFxcIixcXFwiLVxcXCIsXFxcImluc2VydExpbmtcXFwiLFxcXCJpbnNlcnRJbWFnZVxcXCIsXFxcImluc2VydFZpZGVvXFxcIixcXFwiaW5zZXJ0RmlsZVxcXCIsXFxcImluc2VydFRhYmxlXFxcIixcXFwidW5kb1xcXCIsXFxcInJlZG9cXFwiLFxcXCJjbGVhckZvcm1hdHRpbmdcXFwiXSx0b29sYmFyQ29udGFpbmVyOm51bGwsdG9vbGJhcklubGluZTohMSx0b29sYmFyU3RpY2t5OiEwLHRvb2xiYXJTdGlja3lPZmZzZXQ6MCx0b29sYmFyVmlzaWJsZVdpdGhvdXRTZWxlY3Rpb246ITF9KSxhLkZFLk1PRFVMRVMudG9vbGJhcj1mdW5jdGlvbihiKXtmdW5jdGlvbiBjKGEsYil7Zm9yKHZhciBjPTA7YzxiLmxlbmd0aDtjKyspXFxcIi1cXFwiIT1iW2NdJiZcXFwifFxcXCIhPWJbY10mJmEuaW5kZXhPZihiW2NdKTwwJiZhLnB1c2goYltjXSl9ZnVuY3Rpb24gZCgpe3ZhciBkPWEubWVyZ2UoW10sZSgpKTtjKGQsYi5vcHRzLnRvb2xiYXJCdXR0b25zWFN8fFtdKSxjKGQsYi5vcHRzLnRvb2xiYXJCdXR0b25zU018fFtdKSxjKGQsYi5vcHRzLnRvb2xiYXJCdXR0b25zTUR8fFtdKSxjKGQsYi5vcHRzLnRvb2xiYXJCdXR0b25zKTtmb3IodmFyIGY9ZC5sZW5ndGgtMTtmPj0wO2YtLSlcXFwiLVxcXCIhPWRbZl0mJlxcXCJ8XFxcIiE9ZFtmXSYmZC5pbmRleE9mKGRbZl0pPGYmJmQuc3BsaWNlKGYsMSk7dmFyIGc9Yi5idXR0b24uYnVpbGRMaXN0KGQsZSgpKTtiLiR0Yi5hcHBlbmQoZyksYi5idXR0b24uYmluZENvbW1hbmRzKGIuJHRiKX1mdW5jdGlvbiBlKCl7dmFyIGE9Yi5oZWxwZXJzLnNjcmVlblNpemUoKTtyZXR1cm4gdVthXX1mdW5jdGlvbiBmKCl7dmFyIGE9ZSgpO2IuJHRiLmZpbmQoXFxcIi5mci1zZXBhcmF0b3JcXFwiKS5yZW1vdmUoKSxiLiR0Yi5maW5kKFxcXCI+IC5mci1jb21tYW5kXFxcIikuYWRkQ2xhc3MoXFxcImZyLWhpZGRlblxcXCIpO2Zvcih2YXIgYz0wO2M8YS5sZW5ndGg7YysrKWlmKFxcXCJ8XFxcIj09YVtjXXx8XFxcIi1cXFwiPT1hW2NdKWIuJHRiLmFwcGVuZChiLmJ1dHRvbi5idWlsZExpc3QoW2FbY11dKSk7ZWxzZXt2YXIgZD1iLiR0Yi5maW5kKCc+IC5mci1jb21tYW5kW2RhdGEtY21kPVxcXCInK2FbY10rJ1xcXCJdJyksZj1udWxsO2QubmV4dCgpLmhhc0NsYXNzKFxcXCJmci1kcm9wZG93bi1tZW51XFxcIikmJihmPWQubmV4dCgpKSxkLnJlbW92ZUNsYXNzKFxcXCJmci1oaWRkZW5cXFwiKS5hcHBlbmRUbyhiLiR0YiksZiYmZi5hcHBlbmRUbyhiLiR0Yil9fWZ1bmN0aW9uIGcoKXtiLmV2ZW50cy4kb24oYShiLm9fd2luKSxcXFwicmVzaXplXFxcIixmKSxiLmV2ZW50cy4kb24oYShiLm9fd2luKSxcXFwib3JpZW50YXRpb25jaGFuZ2VcXFwiLGYpfWZ1bmN0aW9uIGgoYyxkKXtzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7aWYoYyYmYy53aGljaD09YS5GRS5LRVlDT0RFLkVTQyk7ZWxzZSBpZihiLnNlbGVjdGlvbi5pbkVkaXRvcigpJiZiLmNvcmUuaGFzRm9jdXMoKSYmIWIucG9wdXBzLmFyZVZpc2libGUoKSYmKGIub3B0cy50b29sYmFyVmlzaWJsZVdpdGhvdXRTZWxlY3Rpb24mJmMmJlxcXCJrZXl1cFxcXCIhPWMudHlwZXx8IWIuc2VsZWN0aW9uLmlzQ29sbGFwc2VkKCkmJiFiLmtleXMuaXNJTUUoKXx8ZCkpe2lmKGIuJHRiLmRhdGEoXFxcImluc3RhbmNlXFxcIixiKSwwPT1iLmV2ZW50cy50cmlnZ2VyKFxcXCJ0b29sYmFyLnNob3dcXFwiLFtjXSkpcmV0dXJuITE7Yi5vcHRzLnRvb2xiYXJDb250YWluZXJ8fGIucG9zaXRpb24uZm9yU2VsZWN0aW9uKGIuJHRiKSxiLiR0Yi5zaG93KCl9fSwwKX1mdW5jdGlvbiBpKGMpe3ZhciBkPWEoXFxcIi5mci1kcm9wZG93bi5mci1hY3RpdmVcXFwiKTtyZXR1cm4gZC5uZXh0KCkuZmluZChiLm9fZG9jLmFjdGl2ZUVsZW1lbnQpLmxlbmd0aD8hMDp2b2lkKGIuZXZlbnRzLnRyaWdnZXIoXFxcInRvb2xiYXIuaGlkZVxcXCIpIT09ITEmJmIuJHRiLmhpZGUoKSl9ZnVuY3Rpb24gaigpe3JldHVybiAwPT1iLmV2ZW50cy50cmlnZ2VyKFxcXCJ0b29sYmFyLnNob3dcXFwiKT8hMTp2b2lkIGIuJHRiLnNob3coKX1mdW5jdGlvbiBrKCl7Yi5ldmVudHMub24oXFxcIndpbmRvdy5tb3VzZWRvd25cXFwiLGkpLGIuZXZlbnRzLm9uKFxcXCJrZXlkb3duXFxcIixpKSxiLmV2ZW50cy5vbihcXFwiYmx1clxcXCIsaSksYi5ldmVudHMub24oXFxcIndpbmRvdy5tb3VzZXVwXFxcIixoKSxiLmhlbHBlcnMuaXNNb2JpbGUoKT9iLmhlbHBlcnMuaXNJT1MoKXx8KGIuZXZlbnRzLm9uKFxcXCJ3aW5kb3cudG91Y2hlbmRcXFwiLGgpLGIuYnJvd3Nlci5tb3ppbGxhJiZzZXRJbnRlcnZhbChoLDIwMCkpOmIuZXZlbnRzLm9uKFxcXCJ3aW5kb3cua2V5dXBcXFwiLGgpLGIuZXZlbnRzLm9uKFxcXCJrZXlkb3duXFxcIixmdW5jdGlvbihiKXtiJiZiLndoaWNoPT1hLkZFLktFWUNPREUuRVNDJiZpKCl9KSxiLmV2ZW50cy4kb24oYi4kd3AsXFxcInNjcm9sbC50b29sYmFyXFxcIixoKSxiLmV2ZW50cy5vbihcXFwiY29tbWFuZHMuYWZ0ZXJcXFwiLGgpLGIuaGVscGVycy5pc01vYmlsZSgpJiYoYi5ldmVudHMuJG9uKGIuJGRvYyxcXFwic2VsZWN0aW9uY2hhbmdlXFxcIixoKSxiLmV2ZW50cy4kb24oYi4kZG9jLFxcXCJvcmllbnRhdGlvbmNoYW5nZVxcXCIsaCkpfWZ1bmN0aW9uIGwoKXtiLm9wdHMudG9vbGJhcklubGluZT8oYShiLm9wdHMuc2Nyb2xsYWJsZUNvbnRhaW5lcikuYXBwZW5kKGIuJHRiKSxiLiR0Yi5kYXRhKFxcXCJjb250YWluZXJcXFwiLGEoYi5vcHRzLnNjcm9sbGFibGVDb250YWluZXIpKSxiLiR0Yi5hZGRDbGFzcyhcXFwiZnItaW5saW5lXFxcIiksYi4kdGIucHJlcGVuZCgnPHNwYW4gY2xhc3M9XFxcImZyLWFycm93XFxcIj48L3NwYW4+JyksaygpLGIub3B0cy50b29sYmFyQm90dG9tPSExKTooYi5vcHRzLnRvb2xiYXJCb3R0b20mJiFiLmhlbHBlcnMuaXNJT1MoKT8oYi4kYm94LmFwcGVuZChiLiR0YiksYi4kdGIuYWRkQ2xhc3MoXFxcImZyLWJvdHRvbVxcXCIpLGIuJGJveC5hZGRDbGFzcyhcXFwiZnItYm90dG9tXFxcIikpOihiLm9wdHMudG9vbGJhckJvdHRvbT0hMSxiLiRib3gucHJlcGVuZChiLiR0YiksYi4kdGIuYWRkQ2xhc3MoXFxcImZyLXRvcFxcXCIpLGIuJGJveC5hZGRDbGFzcyhcXFwiZnItdG9wXFxcIikpLGIuJHRiLmFkZENsYXNzKFxcXCJmci1iYXNpY1xcXCIpLGIub3B0cy50b29sYmFyU3RpY2t5JiYoYi5vcHRzLnRvb2xiYXJTdGlja3lPZmZzZXQmJihiLm9wdHMudG9vbGJhckJvdHRvbT9iLiR0Yi5jc3MoXFxcImJvdHRvbVxcXCIsYi5vcHRzLnRvb2xiYXJTdGlja3lPZmZzZXQpOmIuJHRiLmNzcyhcXFwidG9wXFxcIixiLm9wdHMudG9vbGJhclN0aWNreU9mZnNldCkpLGIucG9zaXRpb24uYWRkU3RpY2t5KGIuJHRiKSkpfWZ1bmN0aW9uIG0oKXtiLiR0Yi5odG1sKFxcXCJcXFwiKS5yZW1vdmVEYXRhKCkucmVtb3ZlKCksYi4kdGI9bnVsbH1mdW5jdGlvbiBuKCl7Yi4kYm94LnJlbW92ZUNsYXNzKFxcXCJmci10b3AgZnItYm90dG9tIGZyLWlubGluZSBmci1iYXNpY1xcXCIpLGIuJGJveC5maW5kKFxcXCIuZnItc3RpY2t5LWR1bW15XFxcIikucmVtb3ZlKCl9ZnVuY3Rpb24gbygpe2Iub3B0cy50aGVtZSYmYi4kdGIuYWRkQ2xhc3MoYi5vcHRzLnRoZW1lK1xcXCItdGhlbWVcXFwiKSxiLm9wdHMuekluZGV4PjEmJmIuJHRiLmNzcyhcXFwiei1pbmRleFxcXCIsYi5vcHRzLnpJbmRleCsxKSxcXFwiYXV0b1xcXCIhPWIub3B0cy5kaXJlY3Rpb24mJmIuJHRiLnJlbW92ZUNsYXNzKFxcXCJmci1sdHIgZnItcnRsXFxcIikuYWRkQ2xhc3MoXFxcImZyLVxcXCIrYi5vcHRzLmRpcmVjdGlvbiksYi5oZWxwZXJzLmlzTW9iaWxlKCk/Yi4kdGIuYWRkQ2xhc3MoXFxcImZyLW1vYmlsZVxcXCIpOmIuJHRiLmFkZENsYXNzKFxcXCJmci1kZXNrdG9wXFxcIiksYi5vcHRzLnRvb2xiYXJDb250YWluZXI/KGIub3B0cy50b29sYmFySW5saW5lJiYoaygpLGkoKSksYi5vcHRzLnRvb2xiYXJCb3R0b20/Yi4kdGIuYWRkQ2xhc3MoXFxcImZyLWJvdHRvbVxcXCIpOmIuJHRiLmFkZENsYXNzKFxcXCJmci10b3BcXFwiKSk6bCgpLHM9Yi4kdGIuZ2V0KDApLm93bmVyRG9jdW1lbnQsdD1cXFwiZGVmYXVsdFZpZXdcXFwiaW4gcz9zLmRlZmF1bHRWaWV3OnMucGFyZW50V2luZG93LGQoKSxnKCksYi5ldmVudHMuJG9uKGIuJHRiLGIuX21vdXNlZG93bitcXFwiIFxcXCIrYi5fbW91c2V1cCxmdW5jdGlvbihhKXt2YXIgYz1hLm9yaWdpbmFsRXZlbnQ/YS5vcmlnaW5hbEV2ZW50LnRhcmdldHx8YS5vcmlnaW5hbEV2ZW50Lm9yaWdpbmFsVGFyZ2V0Om51bGw7cmV0dXJuIGMmJlxcXCJJTlBVVFxcXCIhPWMudGFnTmFtZSYmIWIuZWRpdC5pc0Rpc2FibGVkKCk/KGEuc3RvcFByb3BhZ2F0aW9uKCksYS5wcmV2ZW50RGVmYXVsdCgpLCExKTp2b2lkIDB9LCEwKX1mdW5jdGlvbiBwKCl7cmV0dXJuIGIuJHdwPyhiLm9wdHMudG9vbGJhckNvbnRhaW5lcj8oYi5zaGFyZWQuJHRiPyhiLiR0Yj1iLnNoYXJlZC4kdGIsYi5vcHRzLnRvb2xiYXJJbmxpbmUmJmsoKSk6KGIuc2hhcmVkLiR0Yj1hKCc8ZGl2IGNsYXNzPVxcXCJmci10b29sYmFyXFxcIj48L2Rpdj4nKSxiLiR0Yj1iLnNoYXJlZC4kdGIsYShiLm9wdHMudG9vbGJhckNvbnRhaW5lcikuYXBwZW5kKGIuJHRiKSxvKCksYi4kdGIuZGF0YShcXFwiaW5zdGFuY2VcXFwiLGIpKSxiLm9wdHMudG9vbGJhcklubGluZT9iLiRib3guYWRkQ2xhc3MoXFxcImZyLWlubGluZVxcXCIpOmIuJGJveC5hZGRDbGFzcyhcXFwiZnItYmFzaWNcXFwiKSxiLmV2ZW50cy5vbihcXFwiZm9jdXNcXFwiLGZ1bmN0aW9uKCl7Yi4kdGIuZGF0YShcXFwiaW5zdGFuY2VcXFwiLGIpfSwhMCksYi5vcHRzLnRvb2xiYXJJbmxpbmU9ITEpOmIub3B0cy50b29sYmFySW5saW5lPyhiLiRib3guYWRkQ2xhc3MoXFxcImZyLWlubGluZVxcXCIpLGIuc2hhcmVkLiR0Yj8oYi4kdGI9Yi5zaGFyZWQuJHRiLGsoKSk6KGIuc2hhcmVkLiR0Yj1hKCc8ZGl2IGNsYXNzPVxcXCJmci10b29sYmFyXFxcIj48L2Rpdj4nKSxiLiR0Yj1iLnNoYXJlZC4kdGIsbygpKSk6KGIuJGJveC5hZGRDbGFzcyhcXFwiZnItYmFzaWNcXFwiKSxiLiR0Yj1hKCc8ZGl2IGNsYXNzPVxcXCJmci10b29sYmFyXFxcIj48L2Rpdj4nKSxvKCksYi4kdGIuZGF0YShcXFwiaW5zdGFuY2VcXFwiLGIpKSxiLmV2ZW50cy5vbihcXFwiZGVzdHJveVxcXCIsbiwhMCksdm9pZCBiLmV2ZW50cy5vbihiLm9wdHMudG9vbGJhcklubGluZT9cXFwic2hhcmVkLmRlc3Ryb3lcXFwiOlxcXCJkZXN0cm95XFxcIixtLCEwKSk6ITF9ZnVuY3Rpb24gcSgpeyF2JiZiLiR0YiYmKGIuJHRiLmZpbmQoXFxcIj4gLmZyLWNvbW1hbmRcXFwiKS5hZGRDbGFzcyhcXFwiZnItZGlzYWJsZWQgZnItbm8tcmVmcmVzaFxcXCIpLHY9ITApfWZ1bmN0aW9uIHIoKXt2JiZiLiR0YiYmKGIuJHRiLmZpbmQoXFxcIj4gLmZyLWNvbW1hbmRcXFwiKS5yZW1vdmVDbGFzcyhcXFwiZnItZGlzYWJsZWQgZnItbm8tcmVmcmVzaFxcXCIpLHY9ITEpLGIuYnV0dG9uLmJ1bGtSZWZyZXNoKCl9dmFyIHMsdCx1PVtdO3VbYS5GRS5YU109Yi5vcHRzLnRvb2xiYXJCdXR0b25zWFN8fGIub3B0cy50b29sYmFyQnV0dG9ucyx1W2EuRkUuU01dPWIub3B0cy50b29sYmFyQnV0dG9uc1NNfHxiLm9wdHMudG9vbGJhckJ1dHRvbnMsdVthLkZFLk1EXT1iLm9wdHMudG9vbGJhckJ1dHRvbnNNRHx8Yi5vcHRzLnRvb2xiYXJCdXR0b25zLHVbYS5GRS5MR109Yi5vcHRzLnRvb2xiYXJCdXR0b25zO3ZhciB2PSExO3JldHVybntfaW5pdDpwLGhpZGU6aSxzaG93Omosc2hvd0lubGluZTpoLGRpc2FibGU6cSxlbmFibGU6cn19fSk7XCJcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcmF3LWxvYWRlciEuL34vZnJvYWxhLWVkaXRvci9qcy9mcm9hbGFfZWRpdG9yLm1pbi5qc1xuLy8gbW9kdWxlIGlkID0gM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	eval("__webpack_require__(2)(__webpack_require__(5))//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL34vY29kZW1pcnJvci9saWIvY29kZW1pcnJvci5qcz8yNTI1Il0sInNvdXJjZXNDb250ZW50IjpbInJlcXVpcmUoXCIhIS92YXIvYXBwL3dlYi9qcy9ub2RlX21vZHVsZXMvc2NyaXB0LWxvYWRlci9hZGRTY3JpcHQuanNcIikocmVxdWlyZShcIiEhL3Zhci9hcHAvd2ViL2pzL25vZGVfbW9kdWxlcy9yYXctbG9hZGVyL2luZGV4LmpzIS92YXIvYXBwL3dlYi9qcy9ub2RlX21vZHVsZXMvY29kZW1pcnJvci9saWIvY29kZW1pcnJvci5qc1wiKSlcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vc2NyaXB0LWxvYWRlciEuL34vY29kZW1pcnJvci9saWIvY29kZW1pcnJvci5qc1xuLy8gbW9kdWxlIGlkID0gNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 5 */
/***/ function(module, exports) {

	eval("module.exports = \"// CodeMirror, copyright (c) by Marijn Haverbeke and others\\n// Distributed under an MIT license: http://codemirror.net/LICENSE\\n\\n// This is CodeMirror (http://codemirror.net), a code editor\\n// implemented in JavaScript on top of the browser's DOM.\\n//\\n// You can find some technical background for some of the code below\\n// at http://marijnhaverbeke.nl/blog/#cm-internals .\\n\\n(function (global, factory) {\\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\\n  typeof define === 'function' && define.amd ? define(factory) :\\n  (global.CodeMirror = factory());\\n}(this, (function () { 'use strict';\\n\\n// Kludges for bugs and behavior differences that can't be feature\\n// detected are enabled based on userAgent etc sniffing.\\nvar userAgent = navigator.userAgent\\nvar platform = navigator.platform\\n\\nvar gecko = /gecko\\\\/\\\\d/i.test(userAgent)\\nvar ie_upto10 = /MSIE \\\\d/.test(userAgent)\\nvar ie_11up = /Trident\\\\/(?:[7-9]|\\\\d{2,})\\\\..*rv:(\\\\d+)/.exec(userAgent)\\nvar ie = ie_upto10 || ie_11up\\nvar ie_version = ie && (ie_upto10 ? document.documentMode || 6 : ie_11up[1])\\nvar webkit = /WebKit\\\\//.test(userAgent)\\nvar qtwebkit = webkit && /Qt\\\\/\\\\d+\\\\.\\\\d+/.test(userAgent)\\nvar chrome = /Chrome\\\\//.test(userAgent)\\nvar presto = /Opera\\\\//.test(userAgent)\\nvar safari = /Apple Computer/.test(navigator.vendor)\\nvar mac_geMountainLion = /Mac OS X 1\\\\d\\\\D([8-9]|\\\\d\\\\d)\\\\D/.test(userAgent)\\nvar phantom = /PhantomJS/.test(userAgent)\\n\\nvar ios = /AppleWebKit/.test(userAgent) && /Mobile\\\\/\\\\w+/.test(userAgent)\\n// This is woefully incomplete. Suggestions for alternative methods welcome.\\nvar mobile = ios || /Android|webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(userAgent)\\nvar mac = ios || /Mac/.test(platform)\\nvar chromeOS = /\\\\bCrOS\\\\b/.test(userAgent)\\nvar windows = /win/i.test(platform)\\n\\nvar presto_version = presto && userAgent.match(/Version\\\\/(\\\\d*\\\\.\\\\d*)/)\\nif (presto_version) { presto_version = Number(presto_version[1]) }\\nif (presto_version && presto_version >= 15) { presto = false; webkit = true }\\n// Some browsers use the wrong event properties to signal cmd/ctrl on OS X\\nvar flipCtrlCmd = mac && (qtwebkit || presto && (presto_version == null || presto_version < 12.11))\\nvar captureRightClick = gecko || (ie && ie_version >= 9)\\n\\nfunction classTest(cls) { return new RegExp(\\\"(^|\\\\\\\\s)\\\" + cls + \\\"(?:$|\\\\\\\\s)\\\\\\\\s*\\\") }\\n\\nvar rmClass = function(node, cls) {\\n  var current = node.className\\n  var match = classTest(cls).exec(current)\\n  if (match) {\\n    var after = current.slice(match.index + match[0].length)\\n    node.className = current.slice(0, match.index) + (after ? match[1] + after : \\\"\\\")\\n  }\\n}\\n\\nfunction removeChildren(e) {\\n  for (var count = e.childNodes.length; count > 0; --count)\\n    { e.removeChild(e.firstChild) }\\n  return e\\n}\\n\\nfunction removeChildrenAndAdd(parent, e) {\\n  return removeChildren(parent).appendChild(e)\\n}\\n\\nfunction elt(tag, content, className, style) {\\n  var e = document.createElement(tag)\\n  if (className) { e.className = className }\\n  if (style) { e.style.cssText = style }\\n  if (typeof content == \\\"string\\\") { e.appendChild(document.createTextNode(content)) }\\n  else if (content) { for (var i = 0; i < content.length; ++i) { e.appendChild(content[i]) } }\\n  return e\\n}\\n\\nvar range\\nif (document.createRange) { range = function(node, start, end, endNode) {\\n  var r = document.createRange()\\n  r.setEnd(endNode || node, end)\\n  r.setStart(node, start)\\n  return r\\n} }\\nelse { range = function(node, start, end) {\\n  var r = document.body.createTextRange()\\n  try { r.moveToElementText(node.parentNode) }\\n  catch(e) { return r }\\n  r.collapse(true)\\n  r.moveEnd(\\\"character\\\", end)\\n  r.moveStart(\\\"character\\\", start)\\n  return r\\n} }\\n\\nfunction contains(parent, child) {\\n  if (child.nodeType == 3) // Android browser always returns false when child is a textnode\\n    { child = child.parentNode }\\n  if (parent.contains)\\n    { return parent.contains(child) }\\n  do {\\n    if (child.nodeType == 11) { child = child.host }\\n    if (child == parent) { return true }\\n  } while (child = child.parentNode)\\n}\\n\\nvar activeElt = function() {\\n  var activeElement = document.activeElement\\n  while (activeElement && activeElement.root && activeElement.root.activeElement)\\n    { activeElement = activeElement.root.activeElement }\\n  return activeElement\\n}\\n// Older versions of IE throws unspecified error when touching\\n// document.activeElement in some cases (during loading, in iframe)\\nif (ie && ie_version < 11) { activeElt = function() {\\n  try { return document.activeElement }\\n  catch(e) { return document.body }\\n} }\\n\\nfunction addClass(node, cls) {\\n  var current = node.className\\n  if (!classTest(cls).test(current)) { node.className += (current ? \\\" \\\" : \\\"\\\") + cls }\\n}\\nfunction joinClasses(a, b) {\\n  var as = a.split(\\\" \\\")\\n  for (var i = 0; i < as.length; i++)\\n    { if (as[i] && !classTest(as[i]).test(b)) { b += \\\" \\\" + as[i] } }\\n  return b\\n}\\n\\nvar selectInput = function(node) { node.select() }\\nif (ios) // Mobile Safari apparently has a bug where select() is broken.\\n  { selectInput = function(node) { node.selectionStart = 0; node.selectionEnd = node.value.length } }\\nelse if (ie) // Suppress mysterious IE10 errors\\n  { selectInput = function(node) { try { node.select() } catch(_e) {} } }\\n\\nfunction bind(f) {\\n  var args = Array.prototype.slice.call(arguments, 1)\\n  return function(){return f.apply(null, args)}\\n}\\n\\nfunction copyObj(obj, target, overwrite) {\\n  if (!target) { target = {} }\\n  for (var prop in obj)\\n    { if (obj.hasOwnProperty(prop) && (overwrite !== false || !target.hasOwnProperty(prop)))\\n      { target[prop] = obj[prop] } }\\n  return target\\n}\\n\\n// Counts the column offset in a string, taking tabs into account.\\n// Used mostly to find indentation.\\nfunction countColumn(string, end, tabSize, startIndex, startValue) {\\n  if (end == null) {\\n    end = string.search(/[^\\\\s\\\\u00a0]/)\\n    if (end == -1) { end = string.length }\\n  }\\n  for (var i = startIndex || 0, n = startValue || 0;;) {\\n    var nextTab = string.indexOf(\\\"\\\\t\\\", i)\\n    if (nextTab < 0 || nextTab >= end)\\n      { return n + (end - i) }\\n    n += nextTab - i\\n    n += tabSize - (n % tabSize)\\n    i = nextTab + 1\\n  }\\n}\\n\\nfunction Delayed() {this.id = null}\\nDelayed.prototype.set = function(ms, f) {\\n  clearTimeout(this.id)\\n  this.id = setTimeout(f, ms)\\n}\\n\\nfunction indexOf(array, elt) {\\n  for (var i = 0; i < array.length; ++i)\\n    { if (array[i] == elt) { return i } }\\n  return -1\\n}\\n\\n// Number of pixels added to scroller and sizer to hide scrollbar\\nvar scrollerGap = 30\\n\\n// Returned or thrown by various protocols to signal 'I'm not\\n// handling this'.\\nvar Pass = {toString: function(){return \\\"CodeMirror.Pass\\\"}}\\n\\n// Reused option objects for setSelection & friends\\nvar sel_dontScroll = {scroll: false};\\nvar sel_mouse = {origin: \\\"*mouse\\\"};\\nvar sel_move = {origin: \\\"+move\\\"};\\n// The inverse of countColumn -- find the offset that corresponds to\\n// a particular column.\\nfunction findColumn(string, goal, tabSize) {\\n  for (var pos = 0, col = 0;;) {\\n    var nextTab = string.indexOf(\\\"\\\\t\\\", pos)\\n    if (nextTab == -1) { nextTab = string.length }\\n    var skipped = nextTab - pos\\n    if (nextTab == string.length || col + skipped >= goal)\\n      { return pos + Math.min(skipped, goal - col) }\\n    col += nextTab - pos\\n    col += tabSize - (col % tabSize)\\n    pos = nextTab + 1\\n    if (col >= goal) { return pos }\\n  }\\n}\\n\\nvar spaceStrs = [\\\"\\\"]\\nfunction spaceStr(n) {\\n  while (spaceStrs.length <= n)\\n    { spaceStrs.push(lst(spaceStrs) + \\\" \\\") }\\n  return spaceStrs[n]\\n}\\n\\nfunction lst(arr) { return arr[arr.length-1] }\\n\\nfunction map(array, f) {\\n  var out = []\\n  for (var i = 0; i < array.length; i++) { out[i] = f(array[i], i) }\\n  return out\\n}\\n\\nfunction insertSorted(array, value, score) {\\n  var pos = 0, priority = score(value)\\n  while (pos < array.length && score(array[pos]) <= priority) { pos++ }\\n  array.splice(pos, 0, value)\\n}\\n\\nfunction nothing() {}\\n\\nfunction createObj(base, props) {\\n  var inst\\n  if (Object.create) {\\n    inst = Object.create(base)\\n  } else {\\n    nothing.prototype = base\\n    inst = new nothing()\\n  }\\n  if (props) { copyObj(props, inst) }\\n  return inst\\n}\\n\\nvar nonASCIISingleCaseWordChar = /[\\\\u00df\\\\u0587\\\\u0590-\\\\u05f4\\\\u0600-\\\\u06ff\\\\u3040-\\\\u309f\\\\u30a0-\\\\u30ff\\\\u3400-\\\\u4db5\\\\u4e00-\\\\u9fcc\\\\uac00-\\\\ud7af]/\\nfunction isWordCharBasic(ch) {\\n  return /\\\\w/.test(ch) || ch > \\\"\\\\x80\\\" &&\\n    (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch))\\n}\\nfunction isWordChar(ch, helper) {\\n  if (!helper) { return isWordCharBasic(ch) }\\n  if (helper.source.indexOf(\\\"\\\\\\\\w\\\") > -1 && isWordCharBasic(ch)) { return true }\\n  return helper.test(ch)\\n}\\n\\nfunction isEmpty(obj) {\\n  for (var n in obj) { if (obj.hasOwnProperty(n) && obj[n]) { return false } }\\n  return true\\n}\\n\\n// Extending unicode characters. A series of a non-extending char +\\n// any number of extending chars is treated as a single unit as far\\n// as editing and measuring is concerned. This is not fully correct,\\n// since some scripts/fonts/browsers also treat other configurations\\n// of code points as a group.\\nvar extendingChars = /[\\\\u0300-\\\\u036f\\\\u0483-\\\\u0489\\\\u0591-\\\\u05bd\\\\u05bf\\\\u05c1\\\\u05c2\\\\u05c4\\\\u05c5\\\\u05c7\\\\u0610-\\\\u061a\\\\u064b-\\\\u065e\\\\u0670\\\\u06d6-\\\\u06dc\\\\u06de-\\\\u06e4\\\\u06e7\\\\u06e8\\\\u06ea-\\\\u06ed\\\\u0711\\\\u0730-\\\\u074a\\\\u07a6-\\\\u07b0\\\\u07eb-\\\\u07f3\\\\u0816-\\\\u0819\\\\u081b-\\\\u0823\\\\u0825-\\\\u0827\\\\u0829-\\\\u082d\\\\u0900-\\\\u0902\\\\u093c\\\\u0941-\\\\u0948\\\\u094d\\\\u0951-\\\\u0955\\\\u0962\\\\u0963\\\\u0981\\\\u09bc\\\\u09be\\\\u09c1-\\\\u09c4\\\\u09cd\\\\u09d7\\\\u09e2\\\\u09e3\\\\u0a01\\\\u0a02\\\\u0a3c\\\\u0a41\\\\u0a42\\\\u0a47\\\\u0a48\\\\u0a4b-\\\\u0a4d\\\\u0a51\\\\u0a70\\\\u0a71\\\\u0a75\\\\u0a81\\\\u0a82\\\\u0abc\\\\u0ac1-\\\\u0ac5\\\\u0ac7\\\\u0ac8\\\\u0acd\\\\u0ae2\\\\u0ae3\\\\u0b01\\\\u0b3c\\\\u0b3e\\\\u0b3f\\\\u0b41-\\\\u0b44\\\\u0b4d\\\\u0b56\\\\u0b57\\\\u0b62\\\\u0b63\\\\u0b82\\\\u0bbe\\\\u0bc0\\\\u0bcd\\\\u0bd7\\\\u0c3e-\\\\u0c40\\\\u0c46-\\\\u0c48\\\\u0c4a-\\\\u0c4d\\\\u0c55\\\\u0c56\\\\u0c62\\\\u0c63\\\\u0cbc\\\\u0cbf\\\\u0cc2\\\\u0cc6\\\\u0ccc\\\\u0ccd\\\\u0cd5\\\\u0cd6\\\\u0ce2\\\\u0ce3\\\\u0d3e\\\\u0d41-\\\\u0d44\\\\u0d4d\\\\u0d57\\\\u0d62\\\\u0d63\\\\u0dca\\\\u0dcf\\\\u0dd2-\\\\u0dd4\\\\u0dd6\\\\u0ddf\\\\u0e31\\\\u0e34-\\\\u0e3a\\\\u0e47-\\\\u0e4e\\\\u0eb1\\\\u0eb4-\\\\u0eb9\\\\u0ebb\\\\u0ebc\\\\u0ec8-\\\\u0ecd\\\\u0f18\\\\u0f19\\\\u0f35\\\\u0f37\\\\u0f39\\\\u0f71-\\\\u0f7e\\\\u0f80-\\\\u0f84\\\\u0f86\\\\u0f87\\\\u0f90-\\\\u0f97\\\\u0f99-\\\\u0fbc\\\\u0fc6\\\\u102d-\\\\u1030\\\\u1032-\\\\u1037\\\\u1039\\\\u103a\\\\u103d\\\\u103e\\\\u1058\\\\u1059\\\\u105e-\\\\u1060\\\\u1071-\\\\u1074\\\\u1082\\\\u1085\\\\u1086\\\\u108d\\\\u109d\\\\u135f\\\\u1712-\\\\u1714\\\\u1732-\\\\u1734\\\\u1752\\\\u1753\\\\u1772\\\\u1773\\\\u17b7-\\\\u17bd\\\\u17c6\\\\u17c9-\\\\u17d3\\\\u17dd\\\\u180b-\\\\u180d\\\\u18a9\\\\u1920-\\\\u1922\\\\u1927\\\\u1928\\\\u1932\\\\u1939-\\\\u193b\\\\u1a17\\\\u1a18\\\\u1a56\\\\u1a58-\\\\u1a5e\\\\u1a60\\\\u1a62\\\\u1a65-\\\\u1a6c\\\\u1a73-\\\\u1a7c\\\\u1a7f\\\\u1b00-\\\\u1b03\\\\u1b34\\\\u1b36-\\\\u1b3a\\\\u1b3c\\\\u1b42\\\\u1b6b-\\\\u1b73\\\\u1b80\\\\u1b81\\\\u1ba2-\\\\u1ba5\\\\u1ba8\\\\u1ba9\\\\u1c2c-\\\\u1c33\\\\u1c36\\\\u1c37\\\\u1cd0-\\\\u1cd2\\\\u1cd4-\\\\u1ce0\\\\u1ce2-\\\\u1ce8\\\\u1ced\\\\u1dc0-\\\\u1de6\\\\u1dfd-\\\\u1dff\\\\u200c\\\\u200d\\\\u20d0-\\\\u20f0\\\\u2cef-\\\\u2cf1\\\\u2de0-\\\\u2dff\\\\u302a-\\\\u302f\\\\u3099\\\\u309a\\\\ua66f-\\\\ua672\\\\ua67c\\\\ua67d\\\\ua6f0\\\\ua6f1\\\\ua802\\\\ua806\\\\ua80b\\\\ua825\\\\ua826\\\\ua8c4\\\\ua8e0-\\\\ua8f1\\\\ua926-\\\\ua92d\\\\ua947-\\\\ua951\\\\ua980-\\\\ua982\\\\ua9b3\\\\ua9b6-\\\\ua9b9\\\\ua9bc\\\\uaa29-\\\\uaa2e\\\\uaa31\\\\uaa32\\\\uaa35\\\\uaa36\\\\uaa43\\\\uaa4c\\\\uaab0\\\\uaab2-\\\\uaab4\\\\uaab7\\\\uaab8\\\\uaabe\\\\uaabf\\\\uaac1\\\\uabe5\\\\uabe8\\\\uabed\\\\udc00-\\\\udfff\\\\ufb1e\\\\ufe00-\\\\ufe0f\\\\ufe20-\\\\ufe26\\\\uff9e\\\\uff9f]/\\nfunction isExtendingChar(ch) { return ch.charCodeAt(0) >= 768 && extendingChars.test(ch) }\\n\\n// The display handles the DOM integration, both for input reading\\n// and content drawing. It holds references to DOM nodes and\\n// display-related state.\\n\\nfunction Display(place, doc, input) {\\n  var d = this\\n  this.input = input\\n\\n  // Covers bottom-right square when both scrollbars are present.\\n  d.scrollbarFiller = elt(\\\"div\\\", null, \\\"CodeMirror-scrollbar-filler\\\")\\n  d.scrollbarFiller.setAttribute(\\\"cm-not-content\\\", \\\"true\\\")\\n  // Covers bottom of gutter when coverGutterNextToScrollbar is on\\n  // and h scrollbar is present.\\n  d.gutterFiller = elt(\\\"div\\\", null, \\\"CodeMirror-gutter-filler\\\")\\n  d.gutterFiller.setAttribute(\\\"cm-not-content\\\", \\\"true\\\")\\n  // Will contain the actual code, positioned to cover the viewport.\\n  d.lineDiv = elt(\\\"div\\\", null, \\\"CodeMirror-code\\\")\\n  // Elements are added to these to represent selection and cursors.\\n  d.selectionDiv = elt(\\\"div\\\", null, null, \\\"position: relative; z-index: 1\\\")\\n  d.cursorDiv = elt(\\\"div\\\", null, \\\"CodeMirror-cursors\\\")\\n  // A visibility: hidden element used to find the size of things.\\n  d.measure = elt(\\\"div\\\", null, \\\"CodeMirror-measure\\\")\\n  // When lines outside of the viewport are measured, they are drawn in this.\\n  d.lineMeasure = elt(\\\"div\\\", null, \\\"CodeMirror-measure\\\")\\n  // Wraps everything that needs to exist inside the vertically-padded coordinate system\\n  d.lineSpace = elt(\\\"div\\\", [d.measure, d.lineMeasure, d.selectionDiv, d.cursorDiv, d.lineDiv],\\n                    null, \\\"position: relative; outline: none\\\")\\n  // Moved around its parent to cover visible view.\\n  d.mover = elt(\\\"div\\\", [elt(\\\"div\\\", [d.lineSpace], \\\"CodeMirror-lines\\\")], null, \\\"position: relative\\\")\\n  // Set to the height of the document, allowing scrolling.\\n  d.sizer = elt(\\\"div\\\", [d.mover], \\\"CodeMirror-sizer\\\")\\n  d.sizerWidth = null\\n  // Behavior of elts with overflow: auto and padding is\\n  // inconsistent across browsers. This is used to ensure the\\n  // scrollable area is big enough.\\n  d.heightForcer = elt(\\\"div\\\", null, null, \\\"position: absolute; height: \\\" + scrollerGap + \\\"px; width: 1px;\\\")\\n  // Will contain the gutters, if any.\\n  d.gutters = elt(\\\"div\\\", null, \\\"CodeMirror-gutters\\\")\\n  d.lineGutter = null\\n  // Actual scrollable element.\\n  d.scroller = elt(\\\"div\\\", [d.sizer, d.heightForcer, d.gutters], \\\"CodeMirror-scroll\\\")\\n  d.scroller.setAttribute(\\\"tabIndex\\\", \\\"-1\\\")\\n  // The element in which the editor lives.\\n  d.wrapper = elt(\\\"div\\\", [d.scrollbarFiller, d.gutterFiller, d.scroller], \\\"CodeMirror\\\")\\n\\n  // Work around IE7 z-index bug (not perfect, hence IE7 not really being supported)\\n  if (ie && ie_version < 8) { d.gutters.style.zIndex = -1; d.scroller.style.paddingRight = 0 }\\n  if (!webkit && !(gecko && mobile)) { d.scroller.draggable = true }\\n\\n  if (place) {\\n    if (place.appendChild) { place.appendChild(d.wrapper) }\\n    else { place(d.wrapper) }\\n  }\\n\\n  // Current rendered range (may be bigger than the view window).\\n  d.viewFrom = d.viewTo = doc.first\\n  d.reportedViewFrom = d.reportedViewTo = doc.first\\n  // Information about the rendered lines.\\n  d.view = []\\n  d.renderedView = null\\n  // Holds info about a single rendered line when it was rendered\\n  // for measurement, while not in view.\\n  d.externalMeasured = null\\n  // Empty space (in pixels) above the view\\n  d.viewOffset = 0\\n  d.lastWrapHeight = d.lastWrapWidth = 0\\n  d.updateLineNumbers = null\\n\\n  d.nativeBarWidth = d.barHeight = d.barWidth = 0\\n  d.scrollbarsClipped = false\\n\\n  // Used to only resize the line number gutter when necessary (when\\n  // the amount of lines crosses a boundary that makes its width change)\\n  d.lineNumWidth = d.lineNumInnerWidth = d.lineNumChars = null\\n  // Set to true when a non-horizontal-scrolling line widget is\\n  // added. As an optimization, line widget aligning is skipped when\\n  // this is false.\\n  d.alignWidgets = false\\n\\n  d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null\\n\\n  // Tracks the maximum line length so that the horizontal scrollbar\\n  // can be kept static when scrolling.\\n  d.maxLine = null\\n  d.maxLineLength = 0\\n  d.maxLineChanged = false\\n\\n  // Used for measuring wheel scrolling granularity\\n  d.wheelDX = d.wheelDY = d.wheelStartX = d.wheelStartY = null\\n\\n  // True when shift is held down.\\n  d.shift = false\\n\\n  // Used to track whether anything happened since the context menu\\n  // was opened.\\n  d.selForContextMenu = null\\n\\n  d.activeTouch = null\\n\\n  input.init(d)\\n}\\n\\n// Find the line object corresponding to the given line number.\\nfunction getLine(doc, n) {\\n  n -= doc.first\\n  if (n < 0 || n >= doc.size) { throw new Error(\\\"There is no line \\\" + (n + doc.first) + \\\" in the document.\\\") }\\n  var chunk = doc\\n  while (!chunk.lines) {\\n    for (var i = 0;; ++i) {\\n      var child = chunk.children[i], sz = child.chunkSize()\\n      if (n < sz) { chunk = child; break }\\n      n -= sz\\n    }\\n  }\\n  return chunk.lines[n]\\n}\\n\\n// Get the part of a document between two positions, as an array of\\n// strings.\\nfunction getBetween(doc, start, end) {\\n  var out = [], n = start.line\\n  doc.iter(start.line, end.line + 1, function (line) {\\n    var text = line.text\\n    if (n == end.line) { text = text.slice(0, end.ch) }\\n    if (n == start.line) { text = text.slice(start.ch) }\\n    out.push(text)\\n    ++n\\n  })\\n  return out\\n}\\n// Get the lines between from and to, as array of strings.\\nfunction getLines(doc, from, to) {\\n  var out = []\\n  doc.iter(from, to, function (line) { out.push(line.text) }) // iter aborts when callback returns truthy value\\n  return out\\n}\\n\\n// Update the height of a line, propagating the height change\\n// upwards to parent nodes.\\nfunction updateLineHeight(line, height) {\\n  var diff = height - line.height\\n  if (diff) { for (var n = line; n; n = n.parent) { n.height += diff } }\\n}\\n\\n// Given a line object, find its line number by walking up through\\n// its parent links.\\nfunction lineNo(line) {\\n  if (line.parent == null) { return null }\\n  var cur = line.parent, no = indexOf(cur.lines, line)\\n  for (var chunk = cur.parent; chunk; cur = chunk, chunk = chunk.parent) {\\n    for (var i = 0;; ++i) {\\n      if (chunk.children[i] == cur) { break }\\n      no += chunk.children[i].chunkSize()\\n    }\\n  }\\n  return no + cur.first\\n}\\n\\n// Find the line at the given vertical position, using the height\\n// information in the document tree.\\nfunction lineAtHeight(chunk, h) {\\n  var n = chunk.first\\n  outer: do {\\n    for (var i$1 = 0; i$1 < chunk.children.length; ++i$1) {\\n      var child = chunk.children[i$1], ch = child.height\\n      if (h < ch) { chunk = child; continue outer }\\n      h -= ch\\n      n += child.chunkSize()\\n    }\\n    return n\\n  } while (!chunk.lines)\\n  var i = 0\\n  for (; i < chunk.lines.length; ++i) {\\n    var line = chunk.lines[i], lh = line.height\\n    if (h < lh) { break }\\n    h -= lh\\n  }\\n  return n + i\\n}\\n\\nfunction isLine(doc, l) {return l >= doc.first && l < doc.first + doc.size}\\n\\nfunction lineNumberFor(options, i) {\\n  return String(options.lineNumberFormatter(i + options.firstLineNumber))\\n}\\n\\n// A Pos instance represents a position within the text.\\nfunction Pos (line, ch) {\\n  if (!(this instanceof Pos)) { return new Pos(line, ch) }\\n  this.line = line; this.ch = ch\\n}\\n\\n// Compare two positions, return 0 if they are the same, a negative\\n// number when a is less, and a positive number otherwise.\\nfunction cmp(a, b) { return a.line - b.line || a.ch - b.ch }\\n\\nfunction copyPos(x) {return Pos(x.line, x.ch)}\\nfunction maxPos(a, b) { return cmp(a, b) < 0 ? b : a }\\nfunction minPos(a, b) { return cmp(a, b) < 0 ? a : b }\\n\\n// Most of the external API clips given positions to make sure they\\n// actually exist within the document.\\nfunction clipLine(doc, n) {return Math.max(doc.first, Math.min(n, doc.first + doc.size - 1))}\\nfunction clipPos(doc, pos) {\\n  if (pos.line < doc.first) { return Pos(doc.first, 0) }\\n  var last = doc.first + doc.size - 1\\n  if (pos.line > last) { return Pos(last, getLine(doc, last).text.length) }\\n  return clipToLen(pos, getLine(doc, pos.line).text.length)\\n}\\nfunction clipToLen(pos, linelen) {\\n  var ch = pos.ch\\n  if (ch == null || ch > linelen) { return Pos(pos.line, linelen) }\\n  else if (ch < 0) { return Pos(pos.line, 0) }\\n  else { return pos }\\n}\\nfunction clipPosArray(doc, array) {\\n  var out = []\\n  for (var i = 0; i < array.length; i++) { out[i] = clipPos(doc, array[i]) }\\n  return out\\n}\\n\\n// Optimize some code when these features are not used.\\nvar sawReadOnlySpans = false;\\nvar sawCollapsedSpans = false;\\nfunction seeReadOnlySpans() {\\n  sawReadOnlySpans = true\\n}\\n\\nfunction seeCollapsedSpans() {\\n  sawCollapsedSpans = true\\n}\\n\\n// TEXTMARKER SPANS\\n\\nfunction MarkedSpan(marker, from, to) {\\n  this.marker = marker\\n  this.from = from; this.to = to\\n}\\n\\n// Search an array of spans for a span matching the given marker.\\nfunction getMarkedSpanFor(spans, marker) {\\n  if (spans) { for (var i = 0; i < spans.length; ++i) {\\n    var span = spans[i]\\n    if (span.marker == marker) { return span }\\n  } }\\n}\\n// Remove a span from an array, returning undefined if no spans are\\n// left (we don't store arrays for lines without spans).\\nfunction removeMarkedSpan(spans, span) {\\n  var r\\n  for (var i = 0; i < spans.length; ++i)\\n    { if (spans[i] != span) { (r || (r = [])).push(spans[i]) } }\\n  return r\\n}\\n// Add a span to a line.\\nfunction addMarkedSpan(line, span) {\\n  line.markedSpans = line.markedSpans ? line.markedSpans.concat([span]) : [span]\\n  span.marker.attachLine(line)\\n}\\n\\n// Used for the algorithm that adjusts markers for a change in the\\n// document. These functions cut an array of spans at a given\\n// character position, returning an array of remaining chunks (or\\n// undefined if nothing remains).\\nfunction markedSpansBefore(old, startCh, isInsert) {\\n  var nw\\n  if (old) { for (var i = 0; i < old.length; ++i) {\\n    var span = old[i], marker = span.marker\\n    var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= startCh : span.from < startCh)\\n    if (startsBefore || span.from == startCh && marker.type == \\\"bookmark\\\" && (!isInsert || !span.marker.insertLeft)) {\\n      var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= startCh : span.to > startCh)\\n      ;(nw || (nw = [])).push(new MarkedSpan(marker, span.from, endsAfter ? null : span.to))\\n    }\\n  } }\\n  return nw\\n}\\nfunction markedSpansAfter(old, endCh, isInsert) {\\n  var nw\\n  if (old) { for (var i = 0; i < old.length; ++i) {\\n    var span = old[i], marker = span.marker\\n    var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= endCh : span.to > endCh)\\n    if (endsAfter || span.from == endCh && marker.type == \\\"bookmark\\\" && (!isInsert || span.marker.insertLeft)) {\\n      var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= endCh : span.from < endCh)\\n      ;(nw || (nw = [])).push(new MarkedSpan(marker, startsBefore ? null : span.from - endCh,\\n                                            span.to == null ? null : span.to - endCh))\\n    }\\n  } }\\n  return nw\\n}\\n\\n// Given a change object, compute the new set of marker spans that\\n// cover the line in which the change took place. Removes spans\\n// entirely within the change, reconnects spans belonging to the\\n// same marker that appear on both sides of the change, and cuts off\\n// spans partially within the change. Returns an array of span\\n// arrays with one element for each line in (after) the change.\\nfunction stretchSpansOverChange(doc, change) {\\n  if (change.full) { return null }\\n  var oldFirst = isLine(doc, change.from.line) && getLine(doc, change.from.line).markedSpans\\n  var oldLast = isLine(doc, change.to.line) && getLine(doc, change.to.line).markedSpans\\n  if (!oldFirst && !oldLast) { return null }\\n\\n  var startCh = change.from.ch, endCh = change.to.ch, isInsert = cmp(change.from, change.to) == 0\\n  // Get the spans that 'stick out' on both sides\\n  var first = markedSpansBefore(oldFirst, startCh, isInsert)\\n  var last = markedSpansAfter(oldLast, endCh, isInsert)\\n\\n  // Next, merge those two ends\\n  var sameLine = change.text.length == 1, offset = lst(change.text).length + (sameLine ? startCh : 0)\\n  if (first) {\\n    // Fix up .to properties of first\\n    for (var i = 0; i < first.length; ++i) {\\n      var span = first[i]\\n      if (span.to == null) {\\n        var found = getMarkedSpanFor(last, span.marker)\\n        if (!found) { span.to = startCh }\\n        else if (sameLine) { span.to = found.to == null ? null : found.to + offset }\\n      }\\n    }\\n  }\\n  if (last) {\\n    // Fix up .from in last (or move them into first in case of sameLine)\\n    for (var i$1 = 0; i$1 < last.length; ++i$1) {\\n      var span$1 = last[i$1]\\n      if (span$1.to != null) { span$1.to += offset }\\n      if (span$1.from == null) {\\n        var found$1 = getMarkedSpanFor(first, span$1.marker)\\n        if (!found$1) {\\n          span$1.from = offset\\n          if (sameLine) { (first || (first = [])).push(span$1) }\\n        }\\n      } else {\\n        span$1.from += offset\\n        if (sameLine) { (first || (first = [])).push(span$1) }\\n      }\\n    }\\n  }\\n  // Make sure we didn't create any zero-length spans\\n  if (first) { first = clearEmptySpans(first) }\\n  if (last && last != first) { last = clearEmptySpans(last) }\\n\\n  var newMarkers = [first]\\n  if (!sameLine) {\\n    // Fill gap with whole-line-spans\\n    var gap = change.text.length - 2, gapMarkers\\n    if (gap > 0 && first)\\n      { for (var i$2 = 0; i$2 < first.length; ++i$2)\\n        { if (first[i$2].to == null)\\n          { (gapMarkers || (gapMarkers = [])).push(new MarkedSpan(first[i$2].marker, null, null)) } } }\\n    for (var i$3 = 0; i$3 < gap; ++i$3)\\n      { newMarkers.push(gapMarkers) }\\n    newMarkers.push(last)\\n  }\\n  return newMarkers\\n}\\n\\n// Remove spans that are empty and don't have a clearWhenEmpty\\n// option of false.\\nfunction clearEmptySpans(spans) {\\n  for (var i = 0; i < spans.length; ++i) {\\n    var span = spans[i]\\n    if (span.from != null && span.from == span.to && span.marker.clearWhenEmpty !== false)\\n      { spans.splice(i--, 1) }\\n  }\\n  if (!spans.length) { return null }\\n  return spans\\n}\\n\\n// Used to 'clip' out readOnly ranges when making a change.\\nfunction removeReadOnlyRanges(doc, from, to) {\\n  var markers = null\\n  doc.iter(from.line, to.line + 1, function (line) {\\n    if (line.markedSpans) { for (var i = 0; i < line.markedSpans.length; ++i) {\\n      var mark = line.markedSpans[i].marker\\n      if (mark.readOnly && (!markers || indexOf(markers, mark) == -1))\\n        { (markers || (markers = [])).push(mark) }\\n    } }\\n  })\\n  if (!markers) { return null }\\n  var parts = [{from: from, to: to}]\\n  for (var i = 0; i < markers.length; ++i) {\\n    var mk = markers[i], m = mk.find(0)\\n    for (var j = 0; j < parts.length; ++j) {\\n      var p = parts[j]\\n      if (cmp(p.to, m.from) < 0 || cmp(p.from, m.to) > 0) { continue }\\n      var newParts = [j, 1], dfrom = cmp(p.from, m.from), dto = cmp(p.to, m.to)\\n      if (dfrom < 0 || !mk.inclusiveLeft && !dfrom)\\n        { newParts.push({from: p.from, to: m.from}) }\\n      if (dto > 0 || !mk.inclusiveRight && !dto)\\n        { newParts.push({from: m.to, to: p.to}) }\\n      parts.splice.apply(parts, newParts)\\n      j += newParts.length - 1\\n    }\\n  }\\n  return parts\\n}\\n\\n// Connect or disconnect spans from a line.\\nfunction detachMarkedSpans(line) {\\n  var spans = line.markedSpans\\n  if (!spans) { return }\\n  for (var i = 0; i < spans.length; ++i)\\n    { spans[i].marker.detachLine(line) }\\n  line.markedSpans = null\\n}\\nfunction attachMarkedSpans(line, spans) {\\n  if (!spans) { return }\\n  for (var i = 0; i < spans.length; ++i)\\n    { spans[i].marker.attachLine(line) }\\n  line.markedSpans = spans\\n}\\n\\n// Helpers used when computing which overlapping collapsed span\\n// counts as the larger one.\\nfunction extraLeft(marker) { return marker.inclusiveLeft ? -1 : 0 }\\nfunction extraRight(marker) { return marker.inclusiveRight ? 1 : 0 }\\n\\n// Returns a number indicating which of two overlapping collapsed\\n// spans is larger (and thus includes the other). Falls back to\\n// comparing ids when the spans cover exactly the same range.\\nfunction compareCollapsedMarkers(a, b) {\\n  var lenDiff = a.lines.length - b.lines.length\\n  if (lenDiff != 0) { return lenDiff }\\n  var aPos = a.find(), bPos = b.find()\\n  var fromCmp = cmp(aPos.from, bPos.from) || extraLeft(a) - extraLeft(b)\\n  if (fromCmp) { return -fromCmp }\\n  var toCmp = cmp(aPos.to, bPos.to) || extraRight(a) - extraRight(b)\\n  if (toCmp) { return toCmp }\\n  return b.id - a.id\\n}\\n\\n// Find out whether a line ends or starts in a collapsed span. If\\n// so, return the marker for that span.\\nfunction collapsedSpanAtSide(line, start) {\\n  var sps = sawCollapsedSpans && line.markedSpans, found\\n  if (sps) { for (var sp = void 0, i = 0; i < sps.length; ++i) {\\n    sp = sps[i]\\n    if (sp.marker.collapsed && (start ? sp.from : sp.to) == null &&\\n        (!found || compareCollapsedMarkers(found, sp.marker) < 0))\\n      { found = sp.marker }\\n  } }\\n  return found\\n}\\nfunction collapsedSpanAtStart(line) { return collapsedSpanAtSide(line, true) }\\nfunction collapsedSpanAtEnd(line) { return collapsedSpanAtSide(line, false) }\\n\\n// Test whether there exists a collapsed span that partially\\n// overlaps (covers the start or end, but not both) of a new span.\\n// Such overlap is not allowed.\\nfunction conflictingCollapsedRange(doc, lineNo, from, to, marker) {\\n  var line = getLine(doc, lineNo)\\n  var sps = sawCollapsedSpans && line.markedSpans\\n  if (sps) { for (var i = 0; i < sps.length; ++i) {\\n    var sp = sps[i]\\n    if (!sp.marker.collapsed) { continue }\\n    var found = sp.marker.find(0)\\n    var fromCmp = cmp(found.from, from) || extraLeft(sp.marker) - extraLeft(marker)\\n    var toCmp = cmp(found.to, to) || extraRight(sp.marker) - extraRight(marker)\\n    if (fromCmp >= 0 && toCmp <= 0 || fromCmp <= 0 && toCmp >= 0) { continue }\\n    if (fromCmp <= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.to, from) >= 0 : cmp(found.to, from) > 0) ||\\n        fromCmp >= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.from, to) <= 0 : cmp(found.from, to) < 0))\\n      { return true }\\n  } }\\n}\\n\\n// A visual line is a line as drawn on the screen. Folding, for\\n// example, can cause multiple logical lines to appear on the same\\n// visual line. This finds the start of the visual line that the\\n// given line is part of (usually that is the line itself).\\nfunction visualLine(line) {\\n  var merged\\n  while (merged = collapsedSpanAtStart(line))\\n    { line = merged.find(-1, true).line }\\n  return line\\n}\\n\\n// Returns an array of logical lines that continue the visual line\\n// started by the argument, or undefined if there are no such lines.\\nfunction visualLineContinued(line) {\\n  var merged, lines\\n  while (merged = collapsedSpanAtEnd(line)) {\\n    line = merged.find(1, true).line\\n    ;(lines || (lines = [])).push(line)\\n  }\\n  return lines\\n}\\n\\n// Get the line number of the start of the visual line that the\\n// given line number is part of.\\nfunction visualLineNo(doc, lineN) {\\n  var line = getLine(doc, lineN), vis = visualLine(line)\\n  if (line == vis) { return lineN }\\n  return lineNo(vis)\\n}\\n\\n// Get the line number of the start of the next visual line after\\n// the given line.\\nfunction visualLineEndNo(doc, lineN) {\\n  if (lineN > doc.lastLine()) { return lineN }\\n  var line = getLine(doc, lineN), merged\\n  if (!lineIsHidden(doc, line)) { return lineN }\\n  while (merged = collapsedSpanAtEnd(line))\\n    { line = merged.find(1, true).line }\\n  return lineNo(line) + 1\\n}\\n\\n// Compute whether a line is hidden. Lines count as hidden when they\\n// are part of a visual line that starts with another line, or when\\n// they are entirely covered by collapsed, non-widget span.\\nfunction lineIsHidden(doc, line) {\\n  var sps = sawCollapsedSpans && line.markedSpans\\n  if (sps) { for (var sp = void 0, i = 0; i < sps.length; ++i) {\\n    sp = sps[i]\\n    if (!sp.marker.collapsed) { continue }\\n    if (sp.from == null) { return true }\\n    if (sp.marker.widgetNode) { continue }\\n    if (sp.from == 0 && sp.marker.inclusiveLeft && lineIsHiddenInner(doc, line, sp))\\n      { return true }\\n  } }\\n}\\nfunction lineIsHiddenInner(doc, line, span) {\\n  if (span.to == null) {\\n    var end = span.marker.find(1, true)\\n    return lineIsHiddenInner(doc, end.line, getMarkedSpanFor(end.line.markedSpans, span.marker))\\n  }\\n  if (span.marker.inclusiveRight && span.to == line.text.length)\\n    { return true }\\n  for (var sp = void 0, i = 0; i < line.markedSpans.length; ++i) {\\n    sp = line.markedSpans[i]\\n    if (sp.marker.collapsed && !sp.marker.widgetNode && sp.from == span.to &&\\n        (sp.to == null || sp.to != span.from) &&\\n        (sp.marker.inclusiveLeft || span.marker.inclusiveRight) &&\\n        lineIsHiddenInner(doc, line, sp)) { return true }\\n  }\\n}\\n\\n// Find the height above the given line.\\nfunction heightAtLine(lineObj) {\\n  lineObj = visualLine(lineObj)\\n\\n  var h = 0, chunk = lineObj.parent\\n  for (var i = 0; i < chunk.lines.length; ++i) {\\n    var line = chunk.lines[i]\\n    if (line == lineObj) { break }\\n    else { h += line.height }\\n  }\\n  for (var p = chunk.parent; p; chunk = p, p = chunk.parent) {\\n    for (var i$1 = 0; i$1 < p.children.length; ++i$1) {\\n      var cur = p.children[i$1]\\n      if (cur == chunk) { break }\\n      else { h += cur.height }\\n    }\\n  }\\n  return h\\n}\\n\\n// Compute the character length of a line, taking into account\\n// collapsed ranges (see markText) that might hide parts, and join\\n// other lines onto it.\\nfunction lineLength(line) {\\n  if (line.height == 0) { return 0 }\\n  var len = line.text.length, merged, cur = line\\n  while (merged = collapsedSpanAtStart(cur)) {\\n    var found = merged.find(0, true)\\n    cur = found.from.line\\n    len += found.from.ch - found.to.ch\\n  }\\n  cur = line\\n  while (merged = collapsedSpanAtEnd(cur)) {\\n    var found$1 = merged.find(0, true)\\n    len -= cur.text.length - found$1.from.ch\\n    cur = found$1.to.line\\n    len += cur.text.length - found$1.to.ch\\n  }\\n  return len\\n}\\n\\n// Find the longest line in the document.\\nfunction findMaxLine(cm) {\\n  var d = cm.display, doc = cm.doc\\n  d.maxLine = getLine(doc, doc.first)\\n  d.maxLineLength = lineLength(d.maxLine)\\n  d.maxLineChanged = true\\n  doc.iter(function (line) {\\n    var len = lineLength(line)\\n    if (len > d.maxLineLength) {\\n      d.maxLineLength = len\\n      d.maxLine = line\\n    }\\n  })\\n}\\n\\n// BIDI HELPERS\\n\\nfunction iterateBidiSections(order, from, to, f) {\\n  if (!order) { return f(from, to, \\\"ltr\\\") }\\n  var found = false\\n  for (var i = 0; i < order.length; ++i) {\\n    var part = order[i]\\n    if (part.from < to && part.to > from || from == to && part.to == from) {\\n      f(Math.max(part.from, from), Math.min(part.to, to), part.level == 1 ? \\\"rtl\\\" : \\\"ltr\\\")\\n      found = true\\n    }\\n  }\\n  if (!found) { f(from, to, \\\"ltr\\\") }\\n}\\n\\nfunction bidiLeft(part) { return part.level % 2 ? part.to : part.from }\\nfunction bidiRight(part) { return part.level % 2 ? part.from : part.to }\\n\\nfunction lineLeft(line) { var order = getOrder(line); return order ? bidiLeft(order[0]) : 0 }\\nfunction lineRight(line) {\\n  var order = getOrder(line)\\n  if (!order) { return line.text.length }\\n  return bidiRight(lst(order))\\n}\\n\\nfunction compareBidiLevel(order, a, b) {\\n  var linedir = order[0].level\\n  if (a == linedir) { return true }\\n  if (b == linedir) { return false }\\n  return a < b\\n}\\n\\nvar bidiOther = null\\nfunction getBidiPartAt(order, pos) {\\n  var found\\n  bidiOther = null\\n  for (var i = 0; i < order.length; ++i) {\\n    var cur = order[i]\\n    if (cur.from < pos && cur.to > pos) { return i }\\n    if ((cur.from == pos || cur.to == pos)) {\\n      if (found == null) {\\n        found = i\\n      } else if (compareBidiLevel(order, cur.level, order[found].level)) {\\n        if (cur.from != cur.to) { bidiOther = found }\\n        return i\\n      } else {\\n        if (cur.from != cur.to) { bidiOther = i }\\n        return found\\n      }\\n    }\\n  }\\n  return found\\n}\\n\\nfunction moveInLine(line, pos, dir, byUnit) {\\n  if (!byUnit) { return pos + dir }\\n  do { pos += dir }\\n  while (pos > 0 && isExtendingChar(line.text.charAt(pos)))\\n  return pos\\n}\\n\\n// This is needed in order to move 'visually' through bi-directional\\n// text -- i.e., pressing left should make the cursor go left, even\\n// when in RTL text. The tricky part is the 'jumps', where RTL and\\n// LTR text touch each other. This often requires the cursor offset\\n// to move more than one unit, in order to visually move one unit.\\nfunction moveVisually(line, start, dir, byUnit) {\\n  var bidi = getOrder(line)\\n  if (!bidi) { return moveLogically(line, start, dir, byUnit) }\\n  var pos = getBidiPartAt(bidi, start), part = bidi[pos]\\n  var target = moveInLine(line, start, part.level % 2 ? -dir : dir, byUnit)\\n\\n  for (;;) {\\n    if (target > part.from && target < part.to) { return target }\\n    if (target == part.from || target == part.to) {\\n      if (getBidiPartAt(bidi, target) == pos) { return target }\\n      part = bidi[pos += dir]\\n      return (dir > 0) == part.level % 2 ? part.to : part.from\\n    } else {\\n      part = bidi[pos += dir]\\n      if (!part) { return null }\\n      if ((dir > 0) == part.level % 2)\\n        { target = moveInLine(line, part.to, -1, byUnit) }\\n      else\\n        { target = moveInLine(line, part.from, 1, byUnit) }\\n    }\\n  }\\n}\\n\\nfunction moveLogically(line, start, dir, byUnit) {\\n  var target = start + dir\\n  if (byUnit) { while (target > 0 && isExtendingChar(line.text.charAt(target))) { target += dir } }\\n  return target < 0 || target > line.text.length ? null : target\\n}\\n\\n// Bidirectional ordering algorithm\\n// See http://unicode.org/reports/tr9/tr9-13.html for the algorithm\\n// that this (partially) implements.\\n\\n// One-char codes used for character types:\\n// L (L):   Left-to-Right\\n// R (R):   Right-to-Left\\n// r (AL):  Right-to-Left Arabic\\n// 1 (EN):  European Number\\n// + (ES):  European Number Separator\\n// % (ET):  European Number Terminator\\n// n (AN):  Arabic Number\\n// , (CS):  Common Number Separator\\n// m (NSM): Non-Spacing Mark\\n// b (BN):  Boundary Neutral\\n// s (B):   Paragraph Separator\\n// t (S):   Segment Separator\\n// w (WS):  Whitespace\\n// N (ON):  Other Neutrals\\n\\n// Returns null if characters are ordered as they appear\\n// (left-to-right), or an array of sections ({from, to, level}\\n// objects) in the order in which they occur visually.\\nvar bidiOrdering = (function() {\\n  // Character types for codepoints 0 to 0xff\\n  var lowTypes = \\\"bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN\\\"\\n  // Character types for codepoints 0x600 to 0x6ff\\n  var arabicTypes = \\\"rrrrrrrrrrrr,rNNmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmrrrrrrrnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmNmmmm\\\"\\n  function charType(code) {\\n    if (code <= 0xf7) { return lowTypes.charAt(code) }\\n    else if (0x590 <= code && code <= 0x5f4) { return \\\"R\\\" }\\n    else if (0x600 <= code && code <= 0x6ed) { return arabicTypes.charAt(code - 0x600) }\\n    else if (0x6ee <= code && code <= 0x8ac) { return \\\"r\\\" }\\n    else if (0x2000 <= code && code <= 0x200b) { return \\\"w\\\" }\\n    else if (code == 0x200c) { return \\\"b\\\" }\\n    else { return \\\"L\\\" }\\n  }\\n\\n  var bidiRE = /[\\\\u0590-\\\\u05f4\\\\u0600-\\\\u06ff\\\\u0700-\\\\u08ac]/\\n  var isNeutral = /[stwN]/, isStrong = /[LRr]/, countsAsLeft = /[Lb1n]/, countsAsNum = /[1n]/\\n  // Browsers seem to always treat the boundaries of block elements as being L.\\n  var outerType = \\\"L\\\"\\n\\n  function BidiSpan(level, from, to) {\\n    this.level = level\\n    this.from = from; this.to = to\\n  }\\n\\n  return function(str) {\\n    if (!bidiRE.test(str)) { return false }\\n    var len = str.length, types = []\\n    for (var i = 0; i < len; ++i)\\n      { types.push(charType(str.charCodeAt(i))) }\\n\\n    // W1. Examine each non-spacing mark (NSM) in the level run, and\\n    // change the type of the NSM to the type of the previous\\n    // character. If the NSM is at the start of the level run, it will\\n    // get the type of sor.\\n    for (var i$1 = 0, prev = outerType; i$1 < len; ++i$1) {\\n      var type = types[i$1]\\n      if (type == \\\"m\\\") { types[i$1] = prev }\\n      else { prev = type }\\n    }\\n\\n    // W2. Search backwards from each instance of a European number\\n    // until the first strong type (R, L, AL, or sor) is found. If an\\n    // AL is found, change the type of the European number to Arabic\\n    // number.\\n    // W3. Change all ALs to R.\\n    for (var i$2 = 0, cur = outerType; i$2 < len; ++i$2) {\\n      var type$1 = types[i$2]\\n      if (type$1 == \\\"1\\\" && cur == \\\"r\\\") { types[i$2] = \\\"n\\\" }\\n      else if (isStrong.test(type$1)) { cur = type$1; if (type$1 == \\\"r\\\") { types[i$2] = \\\"R\\\" } }\\n    }\\n\\n    // W4. A single European separator between two European numbers\\n    // changes to a European number. A single common separator between\\n    // two numbers of the same type changes to that type.\\n    for (var i$3 = 1, prev$1 = types[0]; i$3 < len - 1; ++i$3) {\\n      var type$2 = types[i$3]\\n      if (type$2 == \\\"+\\\" && prev$1 == \\\"1\\\" && types[i$3+1] == \\\"1\\\") { types[i$3] = \\\"1\\\" }\\n      else if (type$2 == \\\",\\\" && prev$1 == types[i$3+1] &&\\n               (prev$1 == \\\"1\\\" || prev$1 == \\\"n\\\")) { types[i$3] = prev$1 }\\n      prev$1 = type$2\\n    }\\n\\n    // W5. A sequence of European terminators adjacent to European\\n    // numbers changes to all European numbers.\\n    // W6. Otherwise, separators and terminators change to Other\\n    // Neutral.\\n    for (var i$4 = 0; i$4 < len; ++i$4) {\\n      var type$3 = types[i$4]\\n      if (type$3 == \\\",\\\") { types[i$4] = \\\"N\\\" }\\n      else if (type$3 == \\\"%\\\") {\\n        var end = void 0\\n        for (end = i$4 + 1; end < len && types[end] == \\\"%\\\"; ++end) {}\\n        var replace = (i$4 && types[i$4-1] == \\\"!\\\") || (end < len && types[end] == \\\"1\\\") ? \\\"1\\\" : \\\"N\\\"\\n        for (var j = i$4; j < end; ++j) { types[j] = replace }\\n        i$4 = end - 1\\n      }\\n    }\\n\\n    // W7. Search backwards from each instance of a European number\\n    // until the first strong type (R, L, or sor) is found. If an L is\\n    // found, then change the type of the European number to L.\\n    for (var i$5 = 0, cur$1 = outerType; i$5 < len; ++i$5) {\\n      var type$4 = types[i$5]\\n      if (cur$1 == \\\"L\\\" && type$4 == \\\"1\\\") { types[i$5] = \\\"L\\\" }\\n      else if (isStrong.test(type$4)) { cur$1 = type$4 }\\n    }\\n\\n    // N1. A sequence of neutrals takes the direction of the\\n    // surrounding strong text if the text on both sides has the same\\n    // direction. European and Arabic numbers act as if they were R in\\n    // terms of their influence on neutrals. Start-of-level-run (sor)\\n    // and end-of-level-run (eor) are used at level run boundaries.\\n    // N2. Any remaining neutrals take the embedding direction.\\n    for (var i$6 = 0; i$6 < len; ++i$6) {\\n      if (isNeutral.test(types[i$6])) {\\n        var end$1 = void 0\\n        for (end$1 = i$6 + 1; end$1 < len && isNeutral.test(types[end$1]); ++end$1) {}\\n        var before = (i$6 ? types[i$6-1] : outerType) == \\\"L\\\"\\n        var after = (end$1 < len ? types[end$1] : outerType) == \\\"L\\\"\\n        var replace$1 = before || after ? \\\"L\\\" : \\\"R\\\"\\n        for (var j$1 = i$6; j$1 < end$1; ++j$1) { types[j$1] = replace$1 }\\n        i$6 = end$1 - 1\\n      }\\n    }\\n\\n    // Here we depart from the documented algorithm, in order to avoid\\n    // building up an actual levels array. Since there are only three\\n    // levels (0, 1, 2) in an implementation that doesn't take\\n    // explicit embedding into account, we can build up the order on\\n    // the fly, without following the level-based algorithm.\\n    var order = [], m\\n    for (var i$7 = 0; i$7 < len;) {\\n      if (countsAsLeft.test(types[i$7])) {\\n        var start = i$7\\n        for (++i$7; i$7 < len && countsAsLeft.test(types[i$7]); ++i$7) {}\\n        order.push(new BidiSpan(0, start, i$7))\\n      } else {\\n        var pos = i$7, at = order.length\\n        for (++i$7; i$7 < len && types[i$7] != \\\"L\\\"; ++i$7) {}\\n        for (var j$2 = pos; j$2 < i$7;) {\\n          if (countsAsNum.test(types[j$2])) {\\n            if (pos < j$2) { order.splice(at, 0, new BidiSpan(1, pos, j$2)) }\\n            var nstart = j$2\\n            for (++j$2; j$2 < i$7 && countsAsNum.test(types[j$2]); ++j$2) {}\\n            order.splice(at, 0, new BidiSpan(2, nstart, j$2))\\n            pos = j$2\\n          } else { ++j$2 }\\n        }\\n        if (pos < i$7) { order.splice(at, 0, new BidiSpan(1, pos, i$7)) }\\n      }\\n    }\\n    if (order[0].level == 1 && (m = str.match(/^\\\\s+/))) {\\n      order[0].from = m[0].length\\n      order.unshift(new BidiSpan(0, 0, m[0].length))\\n    }\\n    if (lst(order).level == 1 && (m = str.match(/\\\\s+$/))) {\\n      lst(order).to -= m[0].length\\n      order.push(new BidiSpan(0, len - m[0].length, len))\\n    }\\n    if (order[0].level == 2)\\n      { order.unshift(new BidiSpan(1, order[0].to, order[0].to)) }\\n    if (order[0].level != lst(order).level)\\n      { order.push(new BidiSpan(order[0].level, len, len)) }\\n\\n    return order\\n  }\\n})()\\n\\n// Get the bidi ordering for the given line (and cache it). Returns\\n// false for lines that are fully left-to-right, and an array of\\n// BidiSpan objects otherwise.\\nfunction getOrder(line) {\\n  var order = line.order\\n  if (order == null) { order = line.order = bidiOrdering(line.text) }\\n  return order\\n}\\n\\n// EVENT HANDLING\\n\\n// Lightweight event framework. on/off also work on DOM nodes,\\n// registering native DOM handlers.\\n\\nvar on = function(emitter, type, f) {\\n  if (emitter.addEventListener)\\n    { emitter.addEventListener(type, f, false) }\\n  else if (emitter.attachEvent)\\n    { emitter.attachEvent(\\\"on\\\" + type, f) }\\n  else {\\n    var map = emitter._handlers || (emitter._handlers = {})\\n    var arr = map[type] || (map[type] = [])\\n    arr.push(f)\\n  }\\n}\\n\\nvar noHandlers = []\\nfunction getHandlers(emitter, type, copy) {\\n  var arr = emitter._handlers && emitter._handlers[type]\\n  if (copy) { return arr && arr.length > 0 ? arr.slice() : noHandlers }\\n  else { return arr || noHandlers }\\n}\\n\\nfunction off(emitter, type, f) {\\n  if (emitter.removeEventListener)\\n    { emitter.removeEventListener(type, f, false) }\\n  else if (emitter.detachEvent)\\n    { emitter.detachEvent(\\\"on\\\" + type, f) }\\n  else {\\n    var handlers = getHandlers(emitter, type, false)\\n    for (var i = 0; i < handlers.length; ++i)\\n      { if (handlers[i] == f) { handlers.splice(i, 1); break } }\\n  }\\n}\\n\\nfunction signal(emitter, type /*, values...*/) {\\n  var handlers = getHandlers(emitter, type, true)\\n  if (!handlers.length) { return }\\n  var args = Array.prototype.slice.call(arguments, 2)\\n  for (var i = 0; i < handlers.length; ++i) { handlers[i].apply(null, args) }\\n}\\n\\n// The DOM events that CodeMirror handles can be overridden by\\n// registering a (non-DOM) handler on the editor for the event name,\\n// and preventDefault-ing the event in that handler.\\nfunction signalDOMEvent(cm, e, override) {\\n  if (typeof e == \\\"string\\\")\\n    { e = {type: e, preventDefault: function() { this.defaultPrevented = true }} }\\n  signal(cm, override || e.type, cm, e)\\n  return e_defaultPrevented(e) || e.codemirrorIgnore\\n}\\n\\nfunction signalCursorActivity(cm) {\\n  var arr = cm._handlers && cm._handlers.cursorActivity\\n  if (!arr) { return }\\n  var set = cm.curOp.cursorActivityHandlers || (cm.curOp.cursorActivityHandlers = [])\\n  for (var i = 0; i < arr.length; ++i) { if (indexOf(set, arr[i]) == -1)\\n    { set.push(arr[i]) } }\\n}\\n\\nfunction hasHandler(emitter, type) {\\n  return getHandlers(emitter, type).length > 0\\n}\\n\\n// Add on and off methods to a constructor's prototype, to make\\n// registering events on such objects more convenient.\\nfunction eventMixin(ctor) {\\n  ctor.prototype.on = function(type, f) {on(this, type, f)}\\n  ctor.prototype.off = function(type, f) {off(this, type, f)}\\n}\\n\\n// Due to the fact that we still support jurassic IE versions, some\\n// compatibility wrappers are needed.\\n\\nfunction e_preventDefault(e) {\\n  if (e.preventDefault) { e.preventDefault() }\\n  else { e.returnValue = false }\\n}\\nfunction e_stopPropagation(e) {\\n  if (e.stopPropagation) { e.stopPropagation() }\\n  else { e.cancelBubble = true }\\n}\\nfunction e_defaultPrevented(e) {\\n  return e.defaultPrevented != null ? e.defaultPrevented : e.returnValue == false\\n}\\nfunction e_stop(e) {e_preventDefault(e); e_stopPropagation(e)}\\n\\nfunction e_target(e) {return e.target || e.srcElement}\\nfunction e_button(e) {\\n  var b = e.which\\n  if (b == null) {\\n    if (e.button & 1) { b = 1 }\\n    else if (e.button & 2) { b = 3 }\\n    else if (e.button & 4) { b = 2 }\\n  }\\n  if (mac && e.ctrlKey && b == 1) { b = 3 }\\n  return b\\n}\\n\\n// Detect drag-and-drop\\nvar dragAndDrop = function() {\\n  // There is *some* kind of drag-and-drop support in IE6-8, but I\\n  // couldn't get it to work yet.\\n  if (ie && ie_version < 9) { return false }\\n  var div = elt('div')\\n  return \\\"draggable\\\" in div || \\\"dragDrop\\\" in div\\n}()\\n\\nvar zwspSupported\\nfunction zeroWidthElement(measure) {\\n  if (zwspSupported == null) {\\n    var test = elt(\\\"span\\\", \\\"\\\\u200b\\\")\\n    removeChildrenAndAdd(measure, elt(\\\"span\\\", [test, document.createTextNode(\\\"x\\\")]))\\n    if (measure.firstChild.offsetHeight != 0)\\n      { zwspSupported = test.offsetWidth <= 1 && test.offsetHeight > 2 && !(ie && ie_version < 8) }\\n  }\\n  var node = zwspSupported ? elt(\\\"span\\\", \\\"\\\\u200b\\\") :\\n    elt(\\\"span\\\", \\\"\\\\u00a0\\\", null, \\\"display: inline-block; width: 1px; margin-right: -1px\\\")\\n  node.setAttribute(\\\"cm-text\\\", \\\"\\\")\\n  return node\\n}\\n\\n// Feature-detect IE's crummy client rect reporting for bidi text\\nvar badBidiRects\\nfunction hasBadBidiRects(measure) {\\n  if (badBidiRects != null) { return badBidiRects }\\n  var txt = removeChildrenAndAdd(measure, document.createTextNode(\\\"A\\\\u062eA\\\"))\\n  var r0 = range(txt, 0, 1).getBoundingClientRect()\\n  var r1 = range(txt, 1, 2).getBoundingClientRect()\\n  removeChildren(measure)\\n  if (!r0 || r0.left == r0.right) { return false } // Safari returns null in some cases (#2780)\\n  return badBidiRects = (r1.right - r0.right < 3)\\n}\\n\\n// See if \\\"\\\".split is the broken IE version, if so, provide an\\n// alternative way to split lines.\\nvar splitLinesAuto = \\\"\\\\n\\\\nb\\\".split(/\\\\n/).length != 3 ? function (string) {\\n  var pos = 0, result = [], l = string.length\\n  while (pos <= l) {\\n    var nl = string.indexOf(\\\"\\\\n\\\", pos)\\n    if (nl == -1) { nl = string.length }\\n    var line = string.slice(pos, string.charAt(nl - 1) == \\\"\\\\r\\\" ? nl - 1 : nl)\\n    var rt = line.indexOf(\\\"\\\\r\\\")\\n    if (rt != -1) {\\n      result.push(line.slice(0, rt))\\n      pos += rt + 1\\n    } else {\\n      result.push(line)\\n      pos = nl + 1\\n    }\\n  }\\n  return result\\n} : function (string) { return string.split(/\\\\r\\\\n?|\\\\n/); }\\n\\nvar hasSelection = window.getSelection ? function (te) {\\n  try { return te.selectionStart != te.selectionEnd }\\n  catch(e) { return false }\\n} : function (te) {\\n  var range\\n  try {range = te.ownerDocument.selection.createRange()}\\n  catch(e) {}\\n  if (!range || range.parentElement() != te) { return false }\\n  return range.compareEndPoints(\\\"StartToEnd\\\", range) != 0\\n}\\n\\nvar hasCopyEvent = (function () {\\n  var e = elt(\\\"div\\\")\\n  if (\\\"oncopy\\\" in e) { return true }\\n  e.setAttribute(\\\"oncopy\\\", \\\"return;\\\")\\n  return typeof e.oncopy == \\\"function\\\"\\n})()\\n\\nvar badZoomedRects = null\\nfunction hasBadZoomedRects(measure) {\\n  if (badZoomedRects != null) { return badZoomedRects }\\n  var node = removeChildrenAndAdd(measure, elt(\\\"span\\\", \\\"x\\\"))\\n  var normal = node.getBoundingClientRect()\\n  var fromRange = range(node, 0, 1).getBoundingClientRect()\\n  return badZoomedRects = Math.abs(normal.left - fromRange.left) > 1\\n}\\n\\nvar modes = {};\\nvar mimeModes = {};\\n// Extra arguments are stored as the mode's dependencies, which is\\n// used by (legacy) mechanisms like loadmode.js to automatically\\n// load a mode. (Preferred mechanism is the require/define calls.)\\nfunction defineMode(name, mode) {\\n  if (arguments.length > 2)\\n    { mode.dependencies = Array.prototype.slice.call(arguments, 2) }\\n  modes[name] = mode\\n}\\n\\nfunction defineMIME(mime, spec) {\\n  mimeModes[mime] = spec\\n}\\n\\n// Given a MIME type, a {name, ...options} config object, or a name\\n// string, return a mode config object.\\nfunction resolveMode(spec) {\\n  if (typeof spec == \\\"string\\\" && mimeModes.hasOwnProperty(spec)) {\\n    spec = mimeModes[spec]\\n  } else if (spec && typeof spec.name == \\\"string\\\" && mimeModes.hasOwnProperty(spec.name)) {\\n    var found = mimeModes[spec.name]\\n    if (typeof found == \\\"string\\\") { found = {name: found} }\\n    spec = createObj(found, spec)\\n    spec.name = found.name\\n  } else if (typeof spec == \\\"string\\\" && /^[\\\\w\\\\-]+\\\\/[\\\\w\\\\-]+\\\\+xml$/.test(spec)) {\\n    return resolveMode(\\\"application/xml\\\")\\n  } else if (typeof spec == \\\"string\\\" && /^[\\\\w\\\\-]+\\\\/[\\\\w\\\\-]+\\\\+json$/.test(spec)) {\\n    return resolveMode(\\\"application/json\\\")\\n  }\\n  if (typeof spec == \\\"string\\\") { return {name: spec} }\\n  else { return spec || {name: \\\"null\\\"} }\\n}\\n\\n// Given a mode spec (anything that resolveMode accepts), find and\\n// initialize an actual mode object.\\nfunction getMode(options, spec) {\\n  spec = resolveMode(spec)\\n  var mfactory = modes[spec.name]\\n  if (!mfactory) { return getMode(options, \\\"text/plain\\\") }\\n  var modeObj = mfactory(options, spec)\\n  if (modeExtensions.hasOwnProperty(spec.name)) {\\n    var exts = modeExtensions[spec.name]\\n    for (var prop in exts) {\\n      if (!exts.hasOwnProperty(prop)) { continue }\\n      if (modeObj.hasOwnProperty(prop)) { modeObj[\\\"_\\\" + prop] = modeObj[prop] }\\n      modeObj[prop] = exts[prop]\\n    }\\n  }\\n  modeObj.name = spec.name\\n  if (spec.helperType) { modeObj.helperType = spec.helperType }\\n  if (spec.modeProps) { for (var prop$1 in spec.modeProps)\\n    { modeObj[prop$1] = spec.modeProps[prop$1] } }\\n\\n  return modeObj\\n}\\n\\n// This can be used to attach properties to mode objects from\\n// outside the actual mode definition.\\nvar modeExtensions = {}\\nfunction extendMode(mode, properties) {\\n  var exts = modeExtensions.hasOwnProperty(mode) ? modeExtensions[mode] : (modeExtensions[mode] = {})\\n  copyObj(properties, exts)\\n}\\n\\nfunction copyState(mode, state) {\\n  if (state === true) { return state }\\n  if (mode.copyState) { return mode.copyState(state) }\\n  var nstate = {}\\n  for (var n in state) {\\n    var val = state[n]\\n    if (val instanceof Array) { val = val.concat([]) }\\n    nstate[n] = val\\n  }\\n  return nstate\\n}\\n\\n// Given a mode and a state (for that mode), find the inner mode and\\n// state at the position that the state refers to.\\nfunction innerMode(mode, state) {\\n  var info\\n  while (mode.innerMode) {\\n    info = mode.innerMode(state)\\n    if (!info || info.mode == mode) { break }\\n    state = info.state\\n    mode = info.mode\\n  }\\n  return info || {mode: mode, state: state}\\n}\\n\\nfunction startState(mode, a1, a2) {\\n  return mode.startState ? mode.startState(a1, a2) : true\\n}\\n\\n// STRING STREAM\\n\\n// Fed to the mode parsers, provides helper functions to make\\n// parsers more succinct.\\n\\nvar StringStream = function(string, tabSize) {\\n  this.pos = this.start = 0\\n  this.string = string\\n  this.tabSize = tabSize || 8\\n  this.lastColumnPos = this.lastColumnValue = 0\\n  this.lineStart = 0\\n}\\n\\nStringStream.prototype = {\\n  eol: function() {return this.pos >= this.string.length},\\n  sol: function() {return this.pos == this.lineStart},\\n  peek: function() {return this.string.charAt(this.pos) || undefined},\\n  next: function() {\\n    if (this.pos < this.string.length)\\n      { return this.string.charAt(this.pos++) }\\n  },\\n  eat: function(match) {\\n    var ch = this.string.charAt(this.pos)\\n    var ok\\n    if (typeof match == \\\"string\\\") { ok = ch == match }\\n    else { ok = ch && (match.test ? match.test(ch) : match(ch)) }\\n    if (ok) {++this.pos; return ch}\\n  },\\n  eatWhile: function(match) {\\n    var start = this.pos\\n    while (this.eat(match)){}\\n    return this.pos > start\\n  },\\n  eatSpace: function() {\\n    var this$1 = this;\\n\\n    var start = this.pos\\n    while (/[\\\\s\\\\u00a0]/.test(this.string.charAt(this.pos))) { ++this$1.pos }\\n    return this.pos > start\\n  },\\n  skipToEnd: function() {this.pos = this.string.length},\\n  skipTo: function(ch) {\\n    var found = this.string.indexOf(ch, this.pos)\\n    if (found > -1) {this.pos = found; return true}\\n  },\\n  backUp: function(n) {this.pos -= n},\\n  column: function() {\\n    if (this.lastColumnPos < this.start) {\\n      this.lastColumnValue = countColumn(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue)\\n      this.lastColumnPos = this.start\\n    }\\n    return this.lastColumnValue - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0)\\n  },\\n  indentation: function() {\\n    return countColumn(this.string, null, this.tabSize) -\\n      (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0)\\n  },\\n  match: function(pattern, consume, caseInsensitive) {\\n    if (typeof pattern == \\\"string\\\") {\\n      var cased = function (str) { return caseInsensitive ? str.toLowerCase() : str; }\\n      var substr = this.string.substr(this.pos, pattern.length)\\n      if (cased(substr) == cased(pattern)) {\\n        if (consume !== false) { this.pos += pattern.length }\\n        return true\\n      }\\n    } else {\\n      var match = this.string.slice(this.pos).match(pattern)\\n      if (match && match.index > 0) { return null }\\n      if (match && consume !== false) { this.pos += match[0].length }\\n      return match\\n    }\\n  },\\n  current: function(){return this.string.slice(this.start, this.pos)},\\n  hideFirstChars: function(n, inner) {\\n    this.lineStart += n\\n    try { return inner() }\\n    finally { this.lineStart -= n }\\n  }\\n}\\n\\n// Compute a style array (an array starting with a mode generation\\n// -- for invalidation -- followed by pairs of end positions and\\n// style strings), which is used to highlight the tokens on the\\n// line.\\nfunction highlightLine(cm, line, state, forceToEnd) {\\n  // A styles array always starts with a number identifying the\\n  // mode/overlays that it is based on (for easy invalidation).\\n  var st = [cm.state.modeGen], lineClasses = {}\\n  // Compute the base array of styles\\n  runMode(cm, line.text, cm.doc.mode, state, function (end, style) { return st.push(end, style); },\\n    lineClasses, forceToEnd)\\n\\n  // Run overlays, adjust style array.\\n  var loop = function ( o ) {\\n    var overlay = cm.state.overlays[o], i = 1, at = 0\\n    runMode(cm, line.text, overlay.mode, true, function (end, style) {\\n      var start = i\\n      // Ensure there's a token end at the current position, and that i points at it\\n      while (at < end) {\\n        var i_end = st[i]\\n        if (i_end > end)\\n          { st.splice(i, 1, end, st[i+1], i_end) }\\n        i += 2\\n        at = Math.min(end, i_end)\\n      }\\n      if (!style) { return }\\n      if (overlay.opaque) {\\n        st.splice(start, i - start, end, \\\"overlay \\\" + style)\\n        i = start + 2\\n      } else {\\n        for (; start < i; start += 2) {\\n          var cur = st[start+1]\\n          st[start+1] = (cur ? cur + \\\" \\\" : \\\"\\\") + \\\"overlay \\\" + style\\n        }\\n      }\\n    }, lineClasses)\\n  };\\n\\n  for (var o = 0; o < cm.state.overlays.length; ++o) loop( o );\\n\\n  return {styles: st, classes: lineClasses.bgClass || lineClasses.textClass ? lineClasses : null}\\n}\\n\\nfunction getLineStyles(cm, line, updateFrontier) {\\n  if (!line.styles || line.styles[0] != cm.state.modeGen) {\\n    var state = getStateBefore(cm, lineNo(line))\\n    var result = highlightLine(cm, line, line.text.length > cm.options.maxHighlightLength ? copyState(cm.doc.mode, state) : state)\\n    line.stateAfter = state\\n    line.styles = result.styles\\n    if (result.classes) { line.styleClasses = result.classes }\\n    else if (line.styleClasses) { line.styleClasses = null }\\n    if (updateFrontier === cm.doc.frontier) { cm.doc.frontier++ }\\n  }\\n  return line.styles\\n}\\n\\nfunction getStateBefore(cm, n, precise) {\\n  var doc = cm.doc, display = cm.display\\n  if (!doc.mode.startState) { return true }\\n  var pos = findStartLine(cm, n, precise), state = pos > doc.first && getLine(doc, pos-1).stateAfter\\n  if (!state) { state = startState(doc.mode) }\\n  else { state = copyState(doc.mode, state) }\\n  doc.iter(pos, n, function (line) {\\n    processLine(cm, line.text, state)\\n    var save = pos == n - 1 || pos % 5 == 0 || pos >= display.viewFrom && pos < display.viewTo\\n    line.stateAfter = save ? copyState(doc.mode, state) : null\\n    ++pos\\n  })\\n  if (precise) { doc.frontier = pos }\\n  return state\\n}\\n\\n// Lightweight form of highlight -- proceed over this line and\\n// update state, but don't save a style array. Used for lines that\\n// aren't currently visible.\\nfunction processLine(cm, text, state, startAt) {\\n  var mode = cm.doc.mode\\n  var stream = new StringStream(text, cm.options.tabSize)\\n  stream.start = stream.pos = startAt || 0\\n  if (text == \\\"\\\") { callBlankLine(mode, state) }\\n  while (!stream.eol()) {\\n    readToken(mode, stream, state)\\n    stream.start = stream.pos\\n  }\\n}\\n\\nfunction callBlankLine(mode, state) {\\n  if (mode.blankLine) { return mode.blankLine(state) }\\n  if (!mode.innerMode) { return }\\n  var inner = innerMode(mode, state)\\n  if (inner.mode.blankLine) { return inner.mode.blankLine(inner.state) }\\n}\\n\\nfunction readToken(mode, stream, state, inner) {\\n  for (var i = 0; i < 10; i++) {\\n    if (inner) { inner[0] = innerMode(mode, state).mode }\\n    var style = mode.token(stream, state)\\n    if (stream.pos > stream.start) { return style }\\n  }\\n  throw new Error(\\\"Mode \\\" + mode.name + \\\" failed to advance stream.\\\")\\n}\\n\\n// Utility for getTokenAt and getLineTokens\\nfunction takeToken(cm, pos, precise, asArray) {\\n  var getObj = function (copy) { return ({\\n    start: stream.start, end: stream.pos,\\n    string: stream.current(),\\n    type: style || null,\\n    state: copy ? copyState(doc.mode, state) : state\\n  }); }\\n\\n  var doc = cm.doc, mode = doc.mode, style\\n  pos = clipPos(doc, pos)\\n  var line = getLine(doc, pos.line), state = getStateBefore(cm, pos.line, precise)\\n  var stream = new StringStream(line.text, cm.options.tabSize), tokens\\n  if (asArray) { tokens = [] }\\n  while ((asArray || stream.pos < pos.ch) && !stream.eol()) {\\n    stream.start = stream.pos\\n    style = readToken(mode, stream, state)\\n    if (asArray) { tokens.push(getObj(true)) }\\n  }\\n  return asArray ? tokens : getObj()\\n}\\n\\nfunction extractLineClasses(type, output) {\\n  if (type) { for (;;) {\\n    var lineClass = type.match(/(?:^|\\\\s+)line-(background-)?(\\\\S+)/)\\n    if (!lineClass) { break }\\n    type = type.slice(0, lineClass.index) + type.slice(lineClass.index + lineClass[0].length)\\n    var prop = lineClass[1] ? \\\"bgClass\\\" : \\\"textClass\\\"\\n    if (output[prop] == null)\\n      { output[prop] = lineClass[2] }\\n    else if (!(new RegExp(\\\"(?:^|\\\\s)\\\" + lineClass[2] + \\\"(?:$|\\\\s)\\\")).test(output[prop]))\\n      { output[prop] += \\\" \\\" + lineClass[2] }\\n  } }\\n  return type\\n}\\n\\n// Run the given mode's parser over a line, calling f for each token.\\nfunction runMode(cm, text, mode, state, f, lineClasses, forceToEnd) {\\n  var flattenSpans = mode.flattenSpans\\n  if (flattenSpans == null) { flattenSpans = cm.options.flattenSpans }\\n  var curStart = 0, curStyle = null\\n  var stream = new StringStream(text, cm.options.tabSize), style\\n  var inner = cm.options.addModeClass && [null]\\n  if (text == \\\"\\\") { extractLineClasses(callBlankLine(mode, state), lineClasses) }\\n  while (!stream.eol()) {\\n    if (stream.pos > cm.options.maxHighlightLength) {\\n      flattenSpans = false\\n      if (forceToEnd) { processLine(cm, text, state, stream.pos) }\\n      stream.pos = text.length\\n      style = null\\n    } else {\\n      style = extractLineClasses(readToken(mode, stream, state, inner), lineClasses)\\n    }\\n    if (inner) {\\n      var mName = inner[0].name\\n      if (mName) { style = \\\"m-\\\" + (style ? mName + \\\" \\\" + style : mName) }\\n    }\\n    if (!flattenSpans || curStyle != style) {\\n      while (curStart < stream.start) {\\n        curStart = Math.min(stream.start, curStart + 5000)\\n        f(curStart, curStyle)\\n      }\\n      curStyle = style\\n    }\\n    stream.start = stream.pos\\n  }\\n  while (curStart < stream.pos) {\\n    // Webkit seems to refuse to render text nodes longer than 57444\\n    // characters, and returns inaccurate measurements in nodes\\n    // starting around 5000 chars.\\n    var pos = Math.min(stream.pos, curStart + 5000)\\n    f(pos, curStyle)\\n    curStart = pos\\n  }\\n}\\n\\n// Finds the line to start with when starting a parse. Tries to\\n// find a line with a stateAfter, so that it can start with a\\n// valid state. If that fails, it returns the line with the\\n// smallest indentation, which tends to need the least context to\\n// parse correctly.\\nfunction findStartLine(cm, n, precise) {\\n  var minindent, minline, doc = cm.doc\\n  var lim = precise ? -1 : n - (cm.doc.mode.innerMode ? 1000 : 100)\\n  for (var search = n; search > lim; --search) {\\n    if (search <= doc.first) { return doc.first }\\n    var line = getLine(doc, search - 1)\\n    if (line.stateAfter && (!precise || search <= doc.frontier)) { return search }\\n    var indented = countColumn(line.text, null, cm.options.tabSize)\\n    if (minline == null || minindent > indented) {\\n      minline = search - 1\\n      minindent = indented\\n    }\\n  }\\n  return minline\\n}\\n\\n// LINE DATA STRUCTURE\\n\\n// Line objects. These hold state related to a line, including\\n// highlighting info (the styles array).\\nfunction Line(text, markedSpans, estimateHeight) {\\n  this.text = text\\n  attachMarkedSpans(this, markedSpans)\\n  this.height = estimateHeight ? estimateHeight(this) : 1\\n}\\neventMixin(Line)\\nLine.prototype.lineNo = function() { return lineNo(this) }\\n\\n// Change the content (text, markers) of a line. Automatically\\n// invalidates cached information and tries to re-estimate the\\n// line's height.\\nfunction updateLine(line, text, markedSpans, estimateHeight) {\\n  line.text = text\\n  if (line.stateAfter) { line.stateAfter = null }\\n  if (line.styles) { line.styles = null }\\n  if (line.order != null) { line.order = null }\\n  detachMarkedSpans(line)\\n  attachMarkedSpans(line, markedSpans)\\n  var estHeight = estimateHeight ? estimateHeight(line) : 1\\n  if (estHeight != line.height) { updateLineHeight(line, estHeight) }\\n}\\n\\n// Detach a line from the document tree and its markers.\\nfunction cleanUpLine(line) {\\n  line.parent = null\\n  detachMarkedSpans(line)\\n}\\n\\n// Convert a style as returned by a mode (either null, or a string\\n// containing one or more styles) to a CSS style. This is cached,\\n// and also looks for line-wide styles.\\nvar styleToClassCache = {};\\nvar styleToClassCacheWithMode = {};\\nfunction interpretTokenStyle(style, options) {\\n  if (!style || /^\\\\s*$/.test(style)) { return null }\\n  var cache = options.addModeClass ? styleToClassCacheWithMode : styleToClassCache\\n  return cache[style] ||\\n    (cache[style] = style.replace(/\\\\S+/g, \\\"cm-$&\\\"))\\n}\\n\\n// Render the DOM representation of the text of a line. Also builds\\n// up a 'line map', which points at the DOM nodes that represent\\n// specific stretches of text, and is used by the measuring code.\\n// The returned object contains the DOM node, this map, and\\n// information about line-wide styles that were set by the mode.\\nfunction buildLineContent(cm, lineView) {\\n  // The padding-right forces the element to have a 'border', which\\n  // is needed on Webkit to be able to get line-level bounding\\n  // rectangles for it (in measureChar).\\n  var content = elt(\\\"span\\\", null, null, webkit ? \\\"padding-right: .1px\\\" : null)\\n  var builder = {pre: elt(\\\"pre\\\", [content], \\\"CodeMirror-line\\\"), content: content,\\n                 col: 0, pos: 0, cm: cm,\\n                 trailingSpace: false,\\n                 splitSpaces: (ie || webkit) && cm.getOption(\\\"lineWrapping\\\")}\\n  lineView.measure = {}\\n\\n  // Iterate over the logical lines that make up this visual line.\\n  for (var i = 0; i <= (lineView.rest ? lineView.rest.length : 0); i++) {\\n    var line = i ? lineView.rest[i - 1] : lineView.line, order = void 0\\n    builder.pos = 0\\n    builder.addToken = buildToken\\n    // Optionally wire in some hacks into the token-rendering\\n    // algorithm, to deal with browser quirks.\\n    if (hasBadBidiRects(cm.display.measure) && (order = getOrder(line)))\\n      { builder.addToken = buildTokenBadBidi(builder.addToken, order) }\\n    builder.map = []\\n    var allowFrontierUpdate = lineView != cm.display.externalMeasured && lineNo(line)\\n    insertLineContent(line, builder, getLineStyles(cm, line, allowFrontierUpdate))\\n    if (line.styleClasses) {\\n      if (line.styleClasses.bgClass)\\n        { builder.bgClass = joinClasses(line.styleClasses.bgClass, builder.bgClass || \\\"\\\") }\\n      if (line.styleClasses.textClass)\\n        { builder.textClass = joinClasses(line.styleClasses.textClass, builder.textClass || \\\"\\\") }\\n    }\\n\\n    // Ensure at least a single node is present, for measuring.\\n    if (builder.map.length == 0)\\n      { builder.map.push(0, 0, builder.content.appendChild(zeroWidthElement(cm.display.measure))) }\\n\\n    // Store the map and a cache object for the current logical line\\n    if (i == 0) {\\n      lineView.measure.map = builder.map\\n      lineView.measure.cache = {}\\n    } else {\\n      ;(lineView.measure.maps || (lineView.measure.maps = [])).push(builder.map)\\n      ;(lineView.measure.caches || (lineView.measure.caches = [])).push({})\\n    }\\n  }\\n\\n  // See issue #2901\\n  if (webkit) {\\n    var last = builder.content.lastChild\\n    if (/\\\\bcm-tab\\\\b/.test(last.className) || (last.querySelector && last.querySelector(\\\".cm-tab\\\")))\\n      { builder.content.className = \\\"cm-tab-wrap-hack\\\" }\\n  }\\n\\n  signal(cm, \\\"renderLine\\\", cm, lineView.line, builder.pre)\\n  if (builder.pre.className)\\n    { builder.textClass = joinClasses(builder.pre.className, builder.textClass || \\\"\\\") }\\n\\n  return builder\\n}\\n\\nfunction defaultSpecialCharPlaceholder(ch) {\\n  var token = elt(\\\"span\\\", \\\"\\\\u2022\\\", \\\"cm-invalidchar\\\")\\n  token.title = \\\"\\\\\\\\u\\\" + ch.charCodeAt(0).toString(16)\\n  token.setAttribute(\\\"aria-label\\\", token.title)\\n  return token\\n}\\n\\n// Build up the DOM representation for a single token, and add it to\\n// the line map. Takes care to render special characters separately.\\nfunction buildToken(builder, text, style, startStyle, endStyle, title, css) {\\n  if (!text) { return }\\n  var displayText = builder.splitSpaces ? splitSpaces(text, builder.trailingSpace) : text\\n  var special = builder.cm.state.specialChars, mustWrap = false\\n  var content\\n  if (!special.test(text)) {\\n    builder.col += text.length\\n    content = document.createTextNode(displayText)\\n    builder.map.push(builder.pos, builder.pos + text.length, content)\\n    if (ie && ie_version < 9) { mustWrap = true }\\n    builder.pos += text.length\\n  } else {\\n    content = document.createDocumentFragment()\\n    var pos = 0\\n    while (true) {\\n      special.lastIndex = pos\\n      var m = special.exec(text)\\n      var skipped = m ? m.index - pos : text.length - pos\\n      if (skipped) {\\n        var txt = document.createTextNode(displayText.slice(pos, pos + skipped))\\n        if (ie && ie_version < 9) { content.appendChild(elt(\\\"span\\\", [txt])) }\\n        else { content.appendChild(txt) }\\n        builder.map.push(builder.pos, builder.pos + skipped, txt)\\n        builder.col += skipped\\n        builder.pos += skipped\\n      }\\n      if (!m) { break }\\n      pos += skipped + 1\\n      var txt$1 = void 0\\n      if (m[0] == \\\"\\\\t\\\") {\\n        var tabSize = builder.cm.options.tabSize, tabWidth = tabSize - builder.col % tabSize\\n        txt$1 = content.appendChild(elt(\\\"span\\\", spaceStr(tabWidth), \\\"cm-tab\\\"))\\n        txt$1.setAttribute(\\\"role\\\", \\\"presentation\\\")\\n        txt$1.setAttribute(\\\"cm-text\\\", \\\"\\\\t\\\")\\n        builder.col += tabWidth\\n      } else if (m[0] == \\\"\\\\r\\\" || m[0] == \\\"\\\\n\\\") {\\n        txt$1 = content.appendChild(elt(\\\"span\\\", m[0] == \\\"\\\\r\\\" ? \\\"\\\\u240d\\\" : \\\"\\\\u2424\\\", \\\"cm-invalidchar\\\"))\\n        txt$1.setAttribute(\\\"cm-text\\\", m[0])\\n        builder.col += 1\\n      } else {\\n        txt$1 = builder.cm.options.specialCharPlaceholder(m[0])\\n        txt$1.setAttribute(\\\"cm-text\\\", m[0])\\n        if (ie && ie_version < 9) { content.appendChild(elt(\\\"span\\\", [txt$1])) }\\n        else { content.appendChild(txt$1) }\\n        builder.col += 1\\n      }\\n      builder.map.push(builder.pos, builder.pos + 1, txt$1)\\n      builder.pos++\\n    }\\n  }\\n  builder.trailingSpace = displayText.charCodeAt(text.length - 1) == 32\\n  if (style || startStyle || endStyle || mustWrap || css) {\\n    var fullStyle = style || \\\"\\\"\\n    if (startStyle) { fullStyle += startStyle }\\n    if (endStyle) { fullStyle += endStyle }\\n    var token = elt(\\\"span\\\", [content], fullStyle, css)\\n    if (title) { token.title = title }\\n    return builder.content.appendChild(token)\\n  }\\n  builder.content.appendChild(content)\\n}\\n\\nfunction splitSpaces(text, trailingBefore) {\\n  if (text.length > 1 && !/  /.test(text)) { return text }\\n  var spaceBefore = trailingBefore, result = \\\"\\\"\\n  for (var i = 0; i < text.length; i++) {\\n    var ch = text.charAt(i)\\n    if (ch == \\\" \\\" && spaceBefore && (i == text.length - 1 || text.charCodeAt(i + 1) == 32))\\n      { ch = \\\"\\\\u00a0\\\" }\\n    result += ch\\n    spaceBefore = ch == \\\" \\\"\\n  }\\n  return result\\n}\\n\\n// Work around nonsense dimensions being reported for stretches of\\n// right-to-left text.\\nfunction buildTokenBadBidi(inner, order) {\\n  return function (builder, text, style, startStyle, endStyle, title, css) {\\n    style = style ? style + \\\" cm-force-border\\\" : \\\"cm-force-border\\\"\\n    var start = builder.pos, end = start + text.length\\n    for (;;) {\\n      // Find the part that overlaps with the start of this text\\n      var part = void 0\\n      for (var i = 0; i < order.length; i++) {\\n        part = order[i]\\n        if (part.to > start && part.from <= start) { break }\\n      }\\n      if (part.to >= end) { return inner(builder, text, style, startStyle, endStyle, title, css) }\\n      inner(builder, text.slice(0, part.to - start), style, startStyle, null, title, css)\\n      startStyle = null\\n      text = text.slice(part.to - start)\\n      start = part.to\\n    }\\n  }\\n}\\n\\nfunction buildCollapsedSpan(builder, size, marker, ignoreWidget) {\\n  var widget = !ignoreWidget && marker.widgetNode\\n  if (widget) { builder.map.push(builder.pos, builder.pos + size, widget) }\\n  if (!ignoreWidget && builder.cm.display.input.needsContentAttribute) {\\n    if (!widget)\\n      { widget = builder.content.appendChild(document.createElement(\\\"span\\\")) }\\n    widget.setAttribute(\\\"cm-marker\\\", marker.id)\\n  }\\n  if (widget) {\\n    builder.cm.display.input.setUneditable(widget)\\n    builder.content.appendChild(widget)\\n  }\\n  builder.pos += size\\n  builder.trailingSpace = false\\n}\\n\\n// Outputs a number of spans to make up a line, taking highlighting\\n// and marked text into account.\\nfunction insertLineContent(line, builder, styles) {\\n  var spans = line.markedSpans, allText = line.text, at = 0\\n  if (!spans) {\\n    for (var i$1 = 1; i$1 < styles.length; i$1+=2)\\n      { builder.addToken(builder, allText.slice(at, at = styles[i$1]), interpretTokenStyle(styles[i$1+1], builder.cm.options)) }\\n    return\\n  }\\n\\n  var len = allText.length, pos = 0, i = 1, text = \\\"\\\", style, css\\n  var nextChange = 0, spanStyle, spanEndStyle, spanStartStyle, title, collapsed\\n  for (;;) {\\n    if (nextChange == pos) { // Update current marker set\\n      spanStyle = spanEndStyle = spanStartStyle = title = css = \\\"\\\"\\n      collapsed = null; nextChange = Infinity\\n      var foundBookmarks = [], endStyles = void 0\\n      for (var j = 0; j < spans.length; ++j) {\\n        var sp = spans[j], m = sp.marker\\n        if (m.type == \\\"bookmark\\\" && sp.from == pos && m.widgetNode) {\\n          foundBookmarks.push(m)\\n        } else if (sp.from <= pos && (sp.to == null || sp.to > pos || m.collapsed && sp.to == pos && sp.from == pos)) {\\n          if (sp.to != null && sp.to != pos && nextChange > sp.to) {\\n            nextChange = sp.to\\n            spanEndStyle = \\\"\\\"\\n          }\\n          if (m.className) { spanStyle += \\\" \\\" + m.className }\\n          if (m.css) { css = (css ? css + \\\";\\\" : \\\"\\\") + m.css }\\n          if (m.startStyle && sp.from == pos) { spanStartStyle += \\\" \\\" + m.startStyle }\\n          if (m.endStyle && sp.to == nextChange) { (endStyles || (endStyles = [])).push(m.endStyle, sp.to) }\\n          if (m.title && !title) { title = m.title }\\n          if (m.collapsed && (!collapsed || compareCollapsedMarkers(collapsed.marker, m) < 0))\\n            { collapsed = sp }\\n        } else if (sp.from > pos && nextChange > sp.from) {\\n          nextChange = sp.from\\n        }\\n      }\\n      if (endStyles) { for (var j$1 = 0; j$1 < endStyles.length; j$1 += 2)\\n        { if (endStyles[j$1 + 1] == nextChange) { spanEndStyle += \\\" \\\" + endStyles[j$1] } } }\\n\\n      if (!collapsed || collapsed.from == pos) { for (var j$2 = 0; j$2 < foundBookmarks.length; ++j$2)\\n        { buildCollapsedSpan(builder, 0, foundBookmarks[j$2]) } }\\n      if (collapsed && (collapsed.from || 0) == pos) {\\n        buildCollapsedSpan(builder, (collapsed.to == null ? len + 1 : collapsed.to) - pos,\\n                           collapsed.marker, collapsed.from == null)\\n        if (collapsed.to == null) { return }\\n        if (collapsed.to == pos) { collapsed = false }\\n      }\\n    }\\n    if (pos >= len) { break }\\n\\n    var upto = Math.min(len, nextChange)\\n    while (true) {\\n      if (text) {\\n        var end = pos + text.length\\n        if (!collapsed) {\\n          var tokenText = end > upto ? text.slice(0, upto - pos) : text\\n          builder.addToken(builder, tokenText, style ? style + spanStyle : spanStyle,\\n                           spanStartStyle, pos + tokenText.length == nextChange ? spanEndStyle : \\\"\\\", title, css)\\n        }\\n        if (end >= upto) {text = text.slice(upto - pos); pos = upto; break}\\n        pos = end\\n        spanStartStyle = \\\"\\\"\\n      }\\n      text = allText.slice(at, at = styles[i++])\\n      style = interpretTokenStyle(styles[i++], builder.cm.options)\\n    }\\n  }\\n}\\n\\n\\n// These objects are used to represent the visible (currently drawn)\\n// part of the document. A LineView may correspond to multiple\\n// logical lines, if those are connected by collapsed ranges.\\nfunction LineView(doc, line, lineN) {\\n  // The starting line\\n  this.line = line\\n  // Continuing lines, if any\\n  this.rest = visualLineContinued(line)\\n  // Number of logical lines in this visual line\\n  this.size = this.rest ? lineNo(lst(this.rest)) - lineN + 1 : 1\\n  this.node = this.text = null\\n  this.hidden = lineIsHidden(doc, line)\\n}\\n\\n// Create a range of LineView objects for the given lines.\\nfunction buildViewArray(cm, from, to) {\\n  var array = [], nextPos\\n  for (var pos = from; pos < to; pos = nextPos) {\\n    var view = new LineView(cm.doc, getLine(cm.doc, pos), pos)\\n    nextPos = pos + view.size\\n    array.push(view)\\n  }\\n  return array\\n}\\n\\nvar operationGroup = null\\n\\nfunction pushOperation(op) {\\n  if (operationGroup) {\\n    operationGroup.ops.push(op)\\n  } else {\\n    op.ownsGroup = operationGroup = {\\n      ops: [op],\\n      delayedCallbacks: []\\n    }\\n  }\\n}\\n\\nfunction fireCallbacksForOps(group) {\\n  // Calls delayed callbacks and cursorActivity handlers until no\\n  // new ones appear\\n  var callbacks = group.delayedCallbacks, i = 0\\n  do {\\n    for (; i < callbacks.length; i++)\\n      { callbacks[i].call(null) }\\n    for (var j = 0; j < group.ops.length; j++) {\\n      var op = group.ops[j]\\n      if (op.cursorActivityHandlers)\\n        { while (op.cursorActivityCalled < op.cursorActivityHandlers.length)\\n          { op.cursorActivityHandlers[op.cursorActivityCalled++].call(null, op.cm) } }\\n    }\\n  } while (i < callbacks.length)\\n}\\n\\nfunction finishOperation(op, endCb) {\\n  var group = op.ownsGroup\\n  if (!group) { return }\\n\\n  try { fireCallbacksForOps(group) }\\n  finally {\\n    operationGroup = null\\n    endCb(group)\\n  }\\n}\\n\\nvar orphanDelayedCallbacks = null\\n\\n// Often, we want to signal events at a point where we are in the\\n// middle of some work, but don't want the handler to start calling\\n// other methods on the editor, which might be in an inconsistent\\n// state or simply not expect any other events to happen.\\n// signalLater looks whether there are any handlers, and schedules\\n// them to be executed when the last operation ends, or, if no\\n// operation is active, when a timeout fires.\\nfunction signalLater(emitter, type /*, values...*/) {\\n  var arr = getHandlers(emitter, type, false)\\n  if (!arr.length) { return }\\n  var args = Array.prototype.slice.call(arguments, 2), list\\n  if (operationGroup) {\\n    list = operationGroup.delayedCallbacks\\n  } else if (orphanDelayedCallbacks) {\\n    list = orphanDelayedCallbacks\\n  } else {\\n    list = orphanDelayedCallbacks = []\\n    setTimeout(fireOrphanDelayed, 0)\\n  }\\n  var loop = function ( i ) {\\n    list.push(function () { return arr[i].apply(null, args); })\\n  };\\n\\n  for (var i = 0; i < arr.length; ++i)\\n    loop( i );\\n}\\n\\nfunction fireOrphanDelayed() {\\n  var delayed = orphanDelayedCallbacks\\n  orphanDelayedCallbacks = null\\n  for (var i = 0; i < delayed.length; ++i) { delayed[i]() }\\n}\\n\\n// When an aspect of a line changes, a string is added to\\n// lineView.changes. This updates the relevant part of the line's\\n// DOM structure.\\nfunction updateLineForChanges(cm, lineView, lineN, dims) {\\n  for (var j = 0; j < lineView.changes.length; j++) {\\n    var type = lineView.changes[j]\\n    if (type == \\\"text\\\") { updateLineText(cm, lineView) }\\n    else if (type == \\\"gutter\\\") { updateLineGutter(cm, lineView, lineN, dims) }\\n    else if (type == \\\"class\\\") { updateLineClasses(lineView) }\\n    else if (type == \\\"widget\\\") { updateLineWidgets(cm, lineView, dims) }\\n  }\\n  lineView.changes = null\\n}\\n\\n// Lines with gutter elements, widgets or a background class need to\\n// be wrapped, and have the extra elements added to the wrapper div\\nfunction ensureLineWrapped(lineView) {\\n  if (lineView.node == lineView.text) {\\n    lineView.node = elt(\\\"div\\\", null, null, \\\"position: relative\\\")\\n    if (lineView.text.parentNode)\\n      { lineView.text.parentNode.replaceChild(lineView.node, lineView.text) }\\n    lineView.node.appendChild(lineView.text)\\n    if (ie && ie_version < 8) { lineView.node.style.zIndex = 2 }\\n  }\\n  return lineView.node\\n}\\n\\nfunction updateLineBackground(lineView) {\\n  var cls = lineView.bgClass ? lineView.bgClass + \\\" \\\" + (lineView.line.bgClass || \\\"\\\") : lineView.line.bgClass\\n  if (cls) { cls += \\\" CodeMirror-linebackground\\\" }\\n  if (lineView.background) {\\n    if (cls) { lineView.background.className = cls }\\n    else { lineView.background.parentNode.removeChild(lineView.background); lineView.background = null }\\n  } else if (cls) {\\n    var wrap = ensureLineWrapped(lineView)\\n    lineView.background = wrap.insertBefore(elt(\\\"div\\\", null, cls), wrap.firstChild)\\n  }\\n}\\n\\n// Wrapper around buildLineContent which will reuse the structure\\n// in display.externalMeasured when possible.\\nfunction getLineContent(cm, lineView) {\\n  var ext = cm.display.externalMeasured\\n  if (ext && ext.line == lineView.line) {\\n    cm.display.externalMeasured = null\\n    lineView.measure = ext.measure\\n    return ext.built\\n  }\\n  return buildLineContent(cm, lineView)\\n}\\n\\n// Redraw the line's text. Interacts with the background and text\\n// classes because the mode may output tokens that influence these\\n// classes.\\nfunction updateLineText(cm, lineView) {\\n  var cls = lineView.text.className\\n  var built = getLineContent(cm, lineView)\\n  if (lineView.text == lineView.node) { lineView.node = built.pre }\\n  lineView.text.parentNode.replaceChild(built.pre, lineView.text)\\n  lineView.text = built.pre\\n  if (built.bgClass != lineView.bgClass || built.textClass != lineView.textClass) {\\n    lineView.bgClass = built.bgClass\\n    lineView.textClass = built.textClass\\n    updateLineClasses(lineView)\\n  } else if (cls) {\\n    lineView.text.className = cls\\n  }\\n}\\n\\nfunction updateLineClasses(lineView) {\\n  updateLineBackground(lineView)\\n  if (lineView.line.wrapClass)\\n    { ensureLineWrapped(lineView).className = lineView.line.wrapClass }\\n  else if (lineView.node != lineView.text)\\n    { lineView.node.className = \\\"\\\" }\\n  var textClass = lineView.textClass ? lineView.textClass + \\\" \\\" + (lineView.line.textClass || \\\"\\\") : lineView.line.textClass\\n  lineView.text.className = textClass || \\\"\\\"\\n}\\n\\nfunction updateLineGutter(cm, lineView, lineN, dims) {\\n  if (lineView.gutter) {\\n    lineView.node.removeChild(lineView.gutter)\\n    lineView.gutter = null\\n  }\\n  if (lineView.gutterBackground) {\\n    lineView.node.removeChild(lineView.gutterBackground)\\n    lineView.gutterBackground = null\\n  }\\n  if (lineView.line.gutterClass) {\\n    var wrap = ensureLineWrapped(lineView)\\n    lineView.gutterBackground = elt(\\\"div\\\", null, \\\"CodeMirror-gutter-background \\\" + lineView.line.gutterClass,\\n                                    (\\\"left: \\\" + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + \\\"px; width: \\\" + (dims.gutterTotalWidth) + \\\"px\\\"))\\n    wrap.insertBefore(lineView.gutterBackground, lineView.text)\\n  }\\n  var markers = lineView.line.gutterMarkers\\n  if (cm.options.lineNumbers || markers) {\\n    var wrap$1 = ensureLineWrapped(lineView)\\n    var gutterWrap = lineView.gutter = elt(\\\"div\\\", null, \\\"CodeMirror-gutter-wrapper\\\", (\\\"left: \\\" + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + \\\"px\\\"))\\n    cm.display.input.setUneditable(gutterWrap)\\n    wrap$1.insertBefore(gutterWrap, lineView.text)\\n    if (lineView.line.gutterClass)\\n      { gutterWrap.className += \\\" \\\" + lineView.line.gutterClass }\\n    if (cm.options.lineNumbers && (!markers || !markers[\\\"CodeMirror-linenumbers\\\"]))\\n      { lineView.lineNumber = gutterWrap.appendChild(\\n        elt(\\\"div\\\", lineNumberFor(cm.options, lineN),\\n            \\\"CodeMirror-linenumber CodeMirror-gutter-elt\\\",\\n            (\\\"left: \\\" + (dims.gutterLeft[\\\"CodeMirror-linenumbers\\\"]) + \\\"px; width: \\\" + (cm.display.lineNumInnerWidth) + \\\"px\\\"))) }\\n    if (markers) { for (var k = 0; k < cm.options.gutters.length; ++k) {\\n      var id = cm.options.gutters[k], found = markers.hasOwnProperty(id) && markers[id]\\n      if (found)\\n        { gutterWrap.appendChild(elt(\\\"div\\\", [found], \\\"CodeMirror-gutter-elt\\\",\\n                                   (\\\"left: \\\" + (dims.gutterLeft[id]) + \\\"px; width: \\\" + (dims.gutterWidth[id]) + \\\"px\\\"))) }\\n    } }\\n  }\\n}\\n\\nfunction updateLineWidgets(cm, lineView, dims) {\\n  if (lineView.alignable) { lineView.alignable = null }\\n  for (var node = lineView.node.firstChild, next = void 0; node; node = next) {\\n    next = node.nextSibling\\n    if (node.className == \\\"CodeMirror-linewidget\\\")\\n      { lineView.node.removeChild(node) }\\n  }\\n  insertLineWidgets(cm, lineView, dims)\\n}\\n\\n// Build a line's DOM representation from scratch\\nfunction buildLineElement(cm, lineView, lineN, dims) {\\n  var built = getLineContent(cm, lineView)\\n  lineView.text = lineView.node = built.pre\\n  if (built.bgClass) { lineView.bgClass = built.bgClass }\\n  if (built.textClass) { lineView.textClass = built.textClass }\\n\\n  updateLineClasses(lineView)\\n  updateLineGutter(cm, lineView, lineN, dims)\\n  insertLineWidgets(cm, lineView, dims)\\n  return lineView.node\\n}\\n\\n// A lineView may contain multiple logical lines (when merged by\\n// collapsed spans). The widgets for all of them need to be drawn.\\nfunction insertLineWidgets(cm, lineView, dims) {\\n  insertLineWidgetsFor(cm, lineView.line, lineView, dims, true)\\n  if (lineView.rest) { for (var i = 0; i < lineView.rest.length; i++)\\n    { insertLineWidgetsFor(cm, lineView.rest[i], lineView, dims, false) } }\\n}\\n\\nfunction insertLineWidgetsFor(cm, line, lineView, dims, allowAbove) {\\n  if (!line.widgets) { return }\\n  var wrap = ensureLineWrapped(lineView)\\n  for (var i = 0, ws = line.widgets; i < ws.length; ++i) {\\n    var widget = ws[i], node = elt(\\\"div\\\", [widget.node], \\\"CodeMirror-linewidget\\\")\\n    if (!widget.handleMouseEvents) { node.setAttribute(\\\"cm-ignore-events\\\", \\\"true\\\") }\\n    positionLineWidget(widget, node, lineView, dims)\\n    cm.display.input.setUneditable(node)\\n    if (allowAbove && widget.above)\\n      { wrap.insertBefore(node, lineView.gutter || lineView.text) }\\n    else\\n      { wrap.appendChild(node) }\\n    signalLater(widget, \\\"redraw\\\")\\n  }\\n}\\n\\nfunction positionLineWidget(widget, node, lineView, dims) {\\n  if (widget.noHScroll) {\\n    ;(lineView.alignable || (lineView.alignable = [])).push(node)\\n    var width = dims.wrapperWidth\\n    node.style.left = dims.fixedPos + \\\"px\\\"\\n    if (!widget.coverGutter) {\\n      width -= dims.gutterTotalWidth\\n      node.style.paddingLeft = dims.gutterTotalWidth + \\\"px\\\"\\n    }\\n    node.style.width = width + \\\"px\\\"\\n  }\\n  if (widget.coverGutter) {\\n    node.style.zIndex = 5\\n    node.style.position = \\\"relative\\\"\\n    if (!widget.noHScroll) { node.style.marginLeft = -dims.gutterTotalWidth + \\\"px\\\" }\\n  }\\n}\\n\\nfunction widgetHeight(widget) {\\n  if (widget.height != null) { return widget.height }\\n  var cm = widget.doc.cm\\n  if (!cm) { return 0 }\\n  if (!contains(document.body, widget.node)) {\\n    var parentStyle = \\\"position: relative;\\\"\\n    if (widget.coverGutter)\\n      { parentStyle += \\\"margin-left: -\\\" + cm.display.gutters.offsetWidth + \\\"px;\\\" }\\n    if (widget.noHScroll)\\n      { parentStyle += \\\"width: \\\" + cm.display.wrapper.clientWidth + \\\"px;\\\" }\\n    removeChildrenAndAdd(cm.display.measure, elt(\\\"div\\\", [widget.node], null, parentStyle))\\n  }\\n  return widget.height = widget.node.parentNode.offsetHeight\\n}\\n\\n// Return true when the given mouse event happened in a widget\\nfunction eventInWidget(display, e) {\\n  for (var n = e_target(e); n != display.wrapper; n = n.parentNode) {\\n    if (!n || (n.nodeType == 1 && n.getAttribute(\\\"cm-ignore-events\\\") == \\\"true\\\") ||\\n        (n.parentNode == display.sizer && n != display.mover))\\n      { return true }\\n  }\\n}\\n\\n// POSITION MEASUREMENT\\n\\nfunction paddingTop(display) {return display.lineSpace.offsetTop}\\nfunction paddingVert(display) {return display.mover.offsetHeight - display.lineSpace.offsetHeight}\\nfunction paddingH(display) {\\n  if (display.cachedPaddingH) { return display.cachedPaddingH }\\n  var e = removeChildrenAndAdd(display.measure, elt(\\\"pre\\\", \\\"x\\\"))\\n  var style = window.getComputedStyle ? window.getComputedStyle(e) : e.currentStyle\\n  var data = {left: parseInt(style.paddingLeft), right: parseInt(style.paddingRight)}\\n  if (!isNaN(data.left) && !isNaN(data.right)) { display.cachedPaddingH = data }\\n  return data\\n}\\n\\nfunction scrollGap(cm) { return scrollerGap - cm.display.nativeBarWidth }\\nfunction displayWidth(cm) {\\n  return cm.display.scroller.clientWidth - scrollGap(cm) - cm.display.barWidth\\n}\\nfunction displayHeight(cm) {\\n  return cm.display.scroller.clientHeight - scrollGap(cm) - cm.display.barHeight\\n}\\n\\n// Ensure the lineView.wrapping.heights array is populated. This is\\n// an array of bottom offsets for the lines that make up a drawn\\n// line. When lineWrapping is on, there might be more than one\\n// height.\\nfunction ensureLineHeights(cm, lineView, rect) {\\n  var wrapping = cm.options.lineWrapping\\n  var curWidth = wrapping && displayWidth(cm)\\n  if (!lineView.measure.heights || wrapping && lineView.measure.width != curWidth) {\\n    var heights = lineView.measure.heights = []\\n    if (wrapping) {\\n      lineView.measure.width = curWidth\\n      var rects = lineView.text.firstChild.getClientRects()\\n      for (var i = 0; i < rects.length - 1; i++) {\\n        var cur = rects[i], next = rects[i + 1]\\n        if (Math.abs(cur.bottom - next.bottom) > 2)\\n          { heights.push((cur.bottom + next.top) / 2 - rect.top) }\\n      }\\n    }\\n    heights.push(rect.bottom - rect.top)\\n  }\\n}\\n\\n// Find a line map (mapping character offsets to text nodes) and a\\n// measurement cache for the given line number. (A line view might\\n// contain multiple lines when collapsed ranges are present.)\\nfunction mapFromLineView(lineView, line, lineN) {\\n  if (lineView.line == line)\\n    { return {map: lineView.measure.map, cache: lineView.measure.cache} }\\n  for (var i = 0; i < lineView.rest.length; i++)\\n    { if (lineView.rest[i] == line)\\n      { return {map: lineView.measure.maps[i], cache: lineView.measure.caches[i]} } }\\n  for (var i$1 = 0; i$1 < lineView.rest.length; i$1++)\\n    { if (lineNo(lineView.rest[i$1]) > lineN)\\n      { return {map: lineView.measure.maps[i$1], cache: lineView.measure.caches[i$1], before: true} } }\\n}\\n\\n// Render a line into the hidden node display.externalMeasured. Used\\n// when measurement is needed for a line that's not in the viewport.\\nfunction updateExternalMeasurement(cm, line) {\\n  line = visualLine(line)\\n  var lineN = lineNo(line)\\n  var view = cm.display.externalMeasured = new LineView(cm.doc, line, lineN)\\n  view.lineN = lineN\\n  var built = view.built = buildLineContent(cm, view)\\n  view.text = built.pre\\n  removeChildrenAndAdd(cm.display.lineMeasure, built.pre)\\n  return view\\n}\\n\\n// Get a {top, bottom, left, right} box (in line-local coordinates)\\n// for a given character.\\nfunction measureChar(cm, line, ch, bias) {\\n  return measureCharPrepared(cm, prepareMeasureForLine(cm, line), ch, bias)\\n}\\n\\n// Find a line view that corresponds to the given line number.\\nfunction findViewForLine(cm, lineN) {\\n  if (lineN >= cm.display.viewFrom && lineN < cm.display.viewTo)\\n    { return cm.display.view[findViewIndex(cm, lineN)] }\\n  var ext = cm.display.externalMeasured\\n  if (ext && lineN >= ext.lineN && lineN < ext.lineN + ext.size)\\n    { return ext }\\n}\\n\\n// Measurement can be split in two steps, the set-up work that\\n// applies to the whole line, and the measurement of the actual\\n// character. Functions like coordsChar, that need to do a lot of\\n// measurements in a row, can thus ensure that the set-up work is\\n// only done once.\\nfunction prepareMeasureForLine(cm, line) {\\n  var lineN = lineNo(line)\\n  var view = findViewForLine(cm, lineN)\\n  if (view && !view.text) {\\n    view = null\\n  } else if (view && view.changes) {\\n    updateLineForChanges(cm, view, lineN, getDimensions(cm))\\n    cm.curOp.forceUpdate = true\\n  }\\n  if (!view)\\n    { view = updateExternalMeasurement(cm, line) }\\n\\n  var info = mapFromLineView(view, line, lineN)\\n  return {\\n    line: line, view: view, rect: null,\\n    map: info.map, cache: info.cache, before: info.before,\\n    hasHeights: false\\n  }\\n}\\n\\n// Given a prepared measurement object, measures the position of an\\n// actual character (or fetches it from the cache).\\nfunction measureCharPrepared(cm, prepared, ch, bias, varHeight) {\\n  if (prepared.before) { ch = -1 }\\n  var key = ch + (bias || \\\"\\\"), found\\n  if (prepared.cache.hasOwnProperty(key)) {\\n    found = prepared.cache[key]\\n  } else {\\n    if (!prepared.rect)\\n      { prepared.rect = prepared.view.text.getBoundingClientRect() }\\n    if (!prepared.hasHeights) {\\n      ensureLineHeights(cm, prepared.view, prepared.rect)\\n      prepared.hasHeights = true\\n    }\\n    found = measureCharInner(cm, prepared, ch, bias)\\n    if (!found.bogus) { prepared.cache[key] = found }\\n  }\\n  return {left: found.left, right: found.right,\\n          top: varHeight ? found.rtop : found.top,\\n          bottom: varHeight ? found.rbottom : found.bottom}\\n}\\n\\nvar nullRect = {left: 0, right: 0, top: 0, bottom: 0}\\n\\nfunction nodeAndOffsetInLineMap(map, ch, bias) {\\n  var node, start, end, collapse, mStart, mEnd\\n  // First, search the line map for the text node corresponding to,\\n  // or closest to, the target character.\\n  for (var i = 0; i < map.length; i += 3) {\\n    mStart = map[i]\\n    mEnd = map[i + 1]\\n    if (ch < mStart) {\\n      start = 0; end = 1\\n      collapse = \\\"left\\\"\\n    } else if (ch < mEnd) {\\n      start = ch - mStart\\n      end = start + 1\\n    } else if (i == map.length - 3 || ch == mEnd && map[i + 3] > ch) {\\n      end = mEnd - mStart\\n      start = end - 1\\n      if (ch >= mEnd) { collapse = \\\"right\\\" }\\n    }\\n    if (start != null) {\\n      node = map[i + 2]\\n      if (mStart == mEnd && bias == (node.insertLeft ? \\\"left\\\" : \\\"right\\\"))\\n        { collapse = bias }\\n      if (bias == \\\"left\\\" && start == 0)\\n        { while (i && map[i - 2] == map[i - 3] && map[i - 1].insertLeft) {\\n          node = map[(i -= 3) + 2]\\n          collapse = \\\"left\\\"\\n        } }\\n      if (bias == \\\"right\\\" && start == mEnd - mStart)\\n        { while (i < map.length - 3 && map[i + 3] == map[i + 4] && !map[i + 5].insertLeft) {\\n          node = map[(i += 3) + 2]\\n          collapse = \\\"right\\\"\\n        } }\\n      break\\n    }\\n  }\\n  return {node: node, start: start, end: end, collapse: collapse, coverStart: mStart, coverEnd: mEnd}\\n}\\n\\nfunction getUsefulRect(rects, bias) {\\n  var rect = nullRect\\n  if (bias == \\\"left\\\") { for (var i = 0; i < rects.length; i++) {\\n    if ((rect = rects[i]).left != rect.right) { break }\\n  } } else { for (var i$1 = rects.length - 1; i$1 >= 0; i$1--) {\\n    if ((rect = rects[i$1]).left != rect.right) { break }\\n  } }\\n  return rect\\n}\\n\\nfunction measureCharInner(cm, prepared, ch, bias) {\\n  var place = nodeAndOffsetInLineMap(prepared.map, ch, bias)\\n  var node = place.node, start = place.start, end = place.end, collapse = place.collapse\\n\\n  var rect\\n  if (node.nodeType == 3) { // If it is a text node, use a range to retrieve the coordinates.\\n    for (var i$1 = 0; i$1 < 4; i$1++) { // Retry a maximum of 4 times when nonsense rectangles are returned\\n      while (start && isExtendingChar(prepared.line.text.charAt(place.coverStart + start))) { --start }\\n      while (place.coverStart + end < place.coverEnd && isExtendingChar(prepared.line.text.charAt(place.coverStart + end))) { ++end }\\n      if (ie && ie_version < 9 && start == 0 && end == place.coverEnd - place.coverStart)\\n        { rect = node.parentNode.getBoundingClientRect() }\\n      else\\n        { rect = getUsefulRect(range(node, start, end).getClientRects(), bias) }\\n      if (rect.left || rect.right || start == 0) { break }\\n      end = start\\n      start = start - 1\\n      collapse = \\\"right\\\"\\n    }\\n    if (ie && ie_version < 11) { rect = maybeUpdateRectForZooming(cm.display.measure, rect) }\\n  } else { // If it is a widget, simply get the box for the whole widget.\\n    if (start > 0) { collapse = bias = \\\"right\\\" }\\n    var rects\\n    if (cm.options.lineWrapping && (rects = node.getClientRects()).length > 1)\\n      { rect = rects[bias == \\\"right\\\" ? rects.length - 1 : 0] }\\n    else\\n      { rect = node.getBoundingClientRect() }\\n  }\\n  if (ie && ie_version < 9 && !start && (!rect || !rect.left && !rect.right)) {\\n    var rSpan = node.parentNode.getClientRects()[0]\\n    if (rSpan)\\n      { rect = {left: rSpan.left, right: rSpan.left + charWidth(cm.display), top: rSpan.top, bottom: rSpan.bottom} }\\n    else\\n      { rect = nullRect }\\n  }\\n\\n  var rtop = rect.top - prepared.rect.top, rbot = rect.bottom - prepared.rect.top\\n  var mid = (rtop + rbot) / 2\\n  var heights = prepared.view.measure.heights\\n  var i = 0\\n  for (; i < heights.length - 1; i++)\\n    { if (mid < heights[i]) { break } }\\n  var top = i ? heights[i - 1] : 0, bot = heights[i]\\n  var result = {left: (collapse == \\\"right\\\" ? rect.right : rect.left) - prepared.rect.left,\\n                right: (collapse == \\\"left\\\" ? rect.left : rect.right) - prepared.rect.left,\\n                top: top, bottom: bot}\\n  if (!rect.left && !rect.right) { result.bogus = true }\\n  if (!cm.options.singleCursorHeightPerLine) { result.rtop = rtop; result.rbottom = rbot }\\n\\n  return result\\n}\\n\\n// Work around problem with bounding client rects on ranges being\\n// returned incorrectly when zoomed on IE10 and below.\\nfunction maybeUpdateRectForZooming(measure, rect) {\\n  if (!window.screen || screen.logicalXDPI == null ||\\n      screen.logicalXDPI == screen.deviceXDPI || !hasBadZoomedRects(measure))\\n    { return rect }\\n  var scaleX = screen.logicalXDPI / screen.deviceXDPI\\n  var scaleY = screen.logicalYDPI / screen.deviceYDPI\\n  return {left: rect.left * scaleX, right: rect.right * scaleX,\\n          top: rect.top * scaleY, bottom: rect.bottom * scaleY}\\n}\\n\\nfunction clearLineMeasurementCacheFor(lineView) {\\n  if (lineView.measure) {\\n    lineView.measure.cache = {}\\n    lineView.measure.heights = null\\n    if (lineView.rest) { for (var i = 0; i < lineView.rest.length; i++)\\n      { lineView.measure.caches[i] = {} } }\\n  }\\n}\\n\\nfunction clearLineMeasurementCache(cm) {\\n  cm.display.externalMeasure = null\\n  removeChildren(cm.display.lineMeasure)\\n  for (var i = 0; i < cm.display.view.length; i++)\\n    { clearLineMeasurementCacheFor(cm.display.view[i]) }\\n}\\n\\nfunction clearCaches(cm) {\\n  clearLineMeasurementCache(cm)\\n  cm.display.cachedCharWidth = cm.display.cachedTextHeight = cm.display.cachedPaddingH = null\\n  if (!cm.options.lineWrapping) { cm.display.maxLineChanged = true }\\n  cm.display.lineNumChars = null\\n}\\n\\nfunction pageScrollX() { return window.pageXOffset || (document.documentElement || document.body).scrollLeft }\\nfunction pageScrollY() { return window.pageYOffset || (document.documentElement || document.body).scrollTop }\\n\\n// Converts a {top, bottom, left, right} box from line-local\\n// coordinates into another coordinate system. Context may be one of\\n// \\\"line\\\", \\\"div\\\" (display.lineDiv), \\\"local\\\"./null (editor), \\\"window\\\",\\n// or \\\"page\\\".\\nfunction intoCoordSystem(cm, lineObj, rect, context) {\\n  if (lineObj.widgets) { for (var i = 0; i < lineObj.widgets.length; ++i) { if (lineObj.widgets[i].above) {\\n    var size = widgetHeight(lineObj.widgets[i])\\n    rect.top += size; rect.bottom += size\\n  } } }\\n  if (context == \\\"line\\\") { return rect }\\n  if (!context) { context = \\\"local\\\" }\\n  var yOff = heightAtLine(lineObj)\\n  if (context == \\\"local\\\") { yOff += paddingTop(cm.display) }\\n  else { yOff -= cm.display.viewOffset }\\n  if (context == \\\"page\\\" || context == \\\"window\\\") {\\n    var lOff = cm.display.lineSpace.getBoundingClientRect()\\n    yOff += lOff.top + (context == \\\"window\\\" ? 0 : pageScrollY())\\n    var xOff = lOff.left + (context == \\\"window\\\" ? 0 : pageScrollX())\\n    rect.left += xOff; rect.right += xOff\\n  }\\n  rect.top += yOff; rect.bottom += yOff\\n  return rect\\n}\\n\\n// Coverts a box from \\\"div\\\" coords to another coordinate system.\\n// Context may be \\\"window\\\", \\\"page\\\", \\\"div\\\", or \\\"local\\\"./null.\\nfunction fromCoordSystem(cm, coords, context) {\\n  if (context == \\\"div\\\") { return coords }\\n  var left = coords.left, top = coords.top\\n  // First move into \\\"page\\\" coordinate system\\n  if (context == \\\"page\\\") {\\n    left -= pageScrollX()\\n    top -= pageScrollY()\\n  } else if (context == \\\"local\\\" || !context) {\\n    var localBox = cm.display.sizer.getBoundingClientRect()\\n    left += localBox.left\\n    top += localBox.top\\n  }\\n\\n  var lineSpaceBox = cm.display.lineSpace.getBoundingClientRect()\\n  return {left: left - lineSpaceBox.left, top: top - lineSpaceBox.top}\\n}\\n\\nfunction charCoords(cm, pos, context, lineObj, bias) {\\n  if (!lineObj) { lineObj = getLine(cm.doc, pos.line) }\\n  return intoCoordSystem(cm, lineObj, measureChar(cm, lineObj, pos.ch, bias), context)\\n}\\n\\n// Returns a box for a given cursor position, which may have an\\n// 'other' property containing the position of the secondary cursor\\n// on a bidi boundary.\\nfunction cursorCoords(cm, pos, context, lineObj, preparedMeasure, varHeight) {\\n  lineObj = lineObj || getLine(cm.doc, pos.line)\\n  if (!preparedMeasure) { preparedMeasure = prepareMeasureForLine(cm, lineObj) }\\n  function get(ch, right) {\\n    var m = measureCharPrepared(cm, preparedMeasure, ch, right ? \\\"right\\\" : \\\"left\\\", varHeight)\\n    if (right) { m.left = m.right; } else { m.right = m.left }\\n    return intoCoordSystem(cm, lineObj, m, context)\\n  }\\n  function getBidi(ch, partPos) {\\n    var part = order[partPos], right = part.level % 2\\n    if (ch == bidiLeft(part) && partPos && part.level < order[partPos - 1].level) {\\n      part = order[--partPos]\\n      ch = bidiRight(part) - (part.level % 2 ? 0 : 1)\\n      right = true\\n    } else if (ch == bidiRight(part) && partPos < order.length - 1 && part.level < order[partPos + 1].level) {\\n      part = order[++partPos]\\n      ch = bidiLeft(part) - part.level % 2\\n      right = false\\n    }\\n    if (right && ch == part.to && ch > part.from) { return get(ch - 1) }\\n    return get(ch, right)\\n  }\\n  var order = getOrder(lineObj), ch = pos.ch\\n  if (!order) { return get(ch) }\\n  var partPos = getBidiPartAt(order, ch)\\n  var val = getBidi(ch, partPos)\\n  if (bidiOther != null) { val.other = getBidi(ch, bidiOther) }\\n  return val\\n}\\n\\n// Used to cheaply estimate the coordinates for a position. Used for\\n// intermediate scroll updates.\\nfunction estimateCoords(cm, pos) {\\n  var left = 0\\n  pos = clipPos(cm.doc, pos)\\n  if (!cm.options.lineWrapping) { left = charWidth(cm.display) * pos.ch }\\n  var lineObj = getLine(cm.doc, pos.line)\\n  var top = heightAtLine(lineObj) + paddingTop(cm.display)\\n  return {left: left, right: left, top: top, bottom: top + lineObj.height}\\n}\\n\\n// Positions returned by coordsChar contain some extra information.\\n// xRel is the relative x position of the input coordinates compared\\n// to the found position (so xRel > 0 means the coordinates are to\\n// the right of the character position, for example). When outside\\n// is true, that means the coordinates lie outside the line's\\n// vertical range.\\nfunction PosWithInfo(line, ch, outside, xRel) {\\n  var pos = Pos(line, ch)\\n  pos.xRel = xRel\\n  if (outside) { pos.outside = true }\\n  return pos\\n}\\n\\n// Compute the character position closest to the given coordinates.\\n// Input must be lineSpace-local (\\\"div\\\" coordinate system).\\nfunction coordsChar(cm, x, y) {\\n  var doc = cm.doc\\n  y += cm.display.viewOffset\\n  if (y < 0) { return PosWithInfo(doc.first, 0, true, -1) }\\n  var lineN = lineAtHeight(doc, y), last = doc.first + doc.size - 1\\n  if (lineN > last)\\n    { return PosWithInfo(doc.first + doc.size - 1, getLine(doc, last).text.length, true, 1) }\\n  if (x < 0) { x = 0 }\\n\\n  var lineObj = getLine(doc, lineN)\\n  for (;;) {\\n    var found = coordsCharInner(cm, lineObj, lineN, x, y)\\n    var merged = collapsedSpanAtEnd(lineObj)\\n    var mergedPos = merged && merged.find(0, true)\\n    if (merged && (found.ch > mergedPos.from.ch || found.ch == mergedPos.from.ch && found.xRel > 0))\\n      { lineN = lineNo(lineObj = mergedPos.to.line) }\\n    else\\n      { return found }\\n  }\\n}\\n\\nfunction coordsCharInner(cm, lineObj, lineNo, x, y) {\\n  var innerOff = y - heightAtLine(lineObj)\\n  var wrongLine = false, adjust = 2 * cm.display.wrapper.clientWidth\\n  var preparedMeasure = prepareMeasureForLine(cm, lineObj)\\n\\n  function getX(ch) {\\n    var sp = cursorCoords(cm, Pos(lineNo, ch), \\\"line\\\", lineObj, preparedMeasure)\\n    wrongLine = true\\n    if (innerOff > sp.bottom) { return sp.left - adjust }\\n    else if (innerOff < sp.top) { return sp.left + adjust }\\n    else { wrongLine = false }\\n    return sp.left\\n  }\\n\\n  var bidi = getOrder(lineObj), dist = lineObj.text.length\\n  var from = lineLeft(lineObj), to = lineRight(lineObj)\\n  var fromX = getX(from), fromOutside = wrongLine, toX = getX(to), toOutside = wrongLine\\n\\n  if (x > toX) { return PosWithInfo(lineNo, to, toOutside, 1) }\\n  // Do a binary search between these bounds.\\n  for (;;) {\\n    if (bidi ? to == from || to == moveVisually(lineObj, from, 1) : to - from <= 1) {\\n      var ch = x < fromX || x - fromX <= toX - x ? from : to\\n      var outside = ch == from ? fromOutside : toOutside\\n      var xDiff = x - (ch == from ? fromX : toX)\\n      // This is a kludge to handle the case where the coordinates\\n      // are after a line-wrapped line. We should replace it with a\\n      // more general handling of cursor positions around line\\n      // breaks. (Issue #4078)\\n      if (toOutside && !bidi && !/\\\\s/.test(lineObj.text.charAt(ch)) && xDiff > 0 &&\\n          ch < lineObj.text.length && preparedMeasure.view.measure.heights.length > 1) {\\n        var charSize = measureCharPrepared(cm, preparedMeasure, ch, \\\"right\\\")\\n        if (innerOff <= charSize.bottom && innerOff >= charSize.top && Math.abs(x - charSize.right) < xDiff) {\\n          outside = false\\n          ch++\\n          xDiff = x - charSize.right\\n        }\\n      }\\n      while (isExtendingChar(lineObj.text.charAt(ch))) { ++ch }\\n      var pos = PosWithInfo(lineNo, ch, outside, xDiff < -1 ? -1 : xDiff > 1 ? 1 : 0)\\n      return pos\\n    }\\n    var step = Math.ceil(dist / 2), middle = from + step\\n    if (bidi) {\\n      middle = from\\n      for (var i = 0; i < step; ++i) { middle = moveVisually(lineObj, middle, 1) }\\n    }\\n    var middleX = getX(middle)\\n    if (middleX > x) {to = middle; toX = middleX; if (toOutside = wrongLine) { toX += 1000; } dist = step}\\n    else {from = middle; fromX = middleX; fromOutside = wrongLine; dist -= step}\\n  }\\n}\\n\\nvar measureText\\n// Compute the default text height.\\nfunction textHeight(display) {\\n  if (display.cachedTextHeight != null) { return display.cachedTextHeight }\\n  if (measureText == null) {\\n    measureText = elt(\\\"pre\\\")\\n    // Measure a bunch of lines, for browsers that compute\\n    // fractional heights.\\n    for (var i = 0; i < 49; ++i) {\\n      measureText.appendChild(document.createTextNode(\\\"x\\\"))\\n      measureText.appendChild(elt(\\\"br\\\"))\\n    }\\n    measureText.appendChild(document.createTextNode(\\\"x\\\"))\\n  }\\n  removeChildrenAndAdd(display.measure, measureText)\\n  var height = measureText.offsetHeight / 50\\n  if (height > 3) { display.cachedTextHeight = height }\\n  removeChildren(display.measure)\\n  return height || 1\\n}\\n\\n// Compute the default character width.\\nfunction charWidth(display) {\\n  if (display.cachedCharWidth != null) { return display.cachedCharWidth }\\n  var anchor = elt(\\\"span\\\", \\\"xxxxxxxxxx\\\")\\n  var pre = elt(\\\"pre\\\", [anchor])\\n  removeChildrenAndAdd(display.measure, pre)\\n  var rect = anchor.getBoundingClientRect(), width = (rect.right - rect.left) / 10\\n  if (width > 2) { display.cachedCharWidth = width }\\n  return width || 10\\n}\\n\\n// Do a bulk-read of the DOM positions and sizes needed to draw the\\n// view, so that we don't interleave reading and writing to the DOM.\\nfunction getDimensions(cm) {\\n  var d = cm.display, left = {}, width = {}\\n  var gutterLeft = d.gutters.clientLeft\\n  for (var n = d.gutters.firstChild, i = 0; n; n = n.nextSibling, ++i) {\\n    left[cm.options.gutters[i]] = n.offsetLeft + n.clientLeft + gutterLeft\\n    width[cm.options.gutters[i]] = n.clientWidth\\n  }\\n  return {fixedPos: compensateForHScroll(d),\\n          gutterTotalWidth: d.gutters.offsetWidth,\\n          gutterLeft: left,\\n          gutterWidth: width,\\n          wrapperWidth: d.wrapper.clientWidth}\\n}\\n\\n// Computes display.scroller.scrollLeft + display.gutters.offsetWidth,\\n// but using getBoundingClientRect to get a sub-pixel-accurate\\n// result.\\nfunction compensateForHScroll(display) {\\n  return display.scroller.getBoundingClientRect().left - display.sizer.getBoundingClientRect().left\\n}\\n\\n// Returns a function that estimates the height of a line, to use as\\n// first approximation until the line becomes visible (and is thus\\n// properly measurable).\\nfunction estimateHeight(cm) {\\n  var th = textHeight(cm.display), wrapping = cm.options.lineWrapping\\n  var perLine = wrapping && Math.max(5, cm.display.scroller.clientWidth / charWidth(cm.display) - 3)\\n  return function (line) {\\n    if (lineIsHidden(cm.doc, line)) { return 0 }\\n\\n    var widgetsHeight = 0\\n    if (line.widgets) { for (var i = 0; i < line.widgets.length; i++) {\\n      if (line.widgets[i].height) { widgetsHeight += line.widgets[i].height }\\n    } }\\n\\n    if (wrapping)\\n      { return widgetsHeight + (Math.ceil(line.text.length / perLine) || 1) * th }\\n    else\\n      { return widgetsHeight + th }\\n  }\\n}\\n\\nfunction estimateLineHeights(cm) {\\n  var doc = cm.doc, est = estimateHeight(cm)\\n  doc.iter(function (line) {\\n    var estHeight = est(line)\\n    if (estHeight != line.height) { updateLineHeight(line, estHeight) }\\n  })\\n}\\n\\n// Given a mouse event, find the corresponding position. If liberal\\n// is false, it checks whether a gutter or scrollbar was clicked,\\n// and returns null if it was. forRect is used by rectangular\\n// selections, and tries to estimate a character position even for\\n// coordinates beyond the right of the text.\\nfunction posFromMouse(cm, e, liberal, forRect) {\\n  var display = cm.display\\n  if (!liberal && e_target(e).getAttribute(\\\"cm-not-content\\\") == \\\"true\\\") { return null }\\n\\n  var x, y, space = display.lineSpace.getBoundingClientRect()\\n  // Fails unpredictably on IE[67] when mouse is dragged around quickly.\\n  try { x = e.clientX - space.left; y = e.clientY - space.top }\\n  catch (e) { return null }\\n  var coords = coordsChar(cm, x, y), line\\n  if (forRect && coords.xRel == 1 && (line = getLine(cm.doc, coords.line).text).length == coords.ch) {\\n    var colDiff = countColumn(line, line.length, cm.options.tabSize) - line.length\\n    coords = Pos(coords.line, Math.max(0, Math.round((x - paddingH(cm.display).left) / charWidth(cm.display)) - colDiff))\\n  }\\n  return coords\\n}\\n\\n// Find the view element corresponding to a given line. Return null\\n// when the line isn't visible.\\nfunction findViewIndex(cm, n) {\\n  if (n >= cm.display.viewTo) { return null }\\n  n -= cm.display.viewFrom\\n  if (n < 0) { return null }\\n  var view = cm.display.view\\n  for (var i = 0; i < view.length; i++) {\\n    n -= view[i].size\\n    if (n < 0) { return i }\\n  }\\n}\\n\\nfunction updateSelection(cm) {\\n  cm.display.input.showSelection(cm.display.input.prepareSelection())\\n}\\n\\nfunction prepareSelection(cm, primary) {\\n  var doc = cm.doc, result = {}\\n  var curFragment = result.cursors = document.createDocumentFragment()\\n  var selFragment = result.selection = document.createDocumentFragment()\\n\\n  for (var i = 0; i < doc.sel.ranges.length; i++) {\\n    if (primary === false && i == doc.sel.primIndex) { continue }\\n    var range = doc.sel.ranges[i]\\n    if (range.from().line >= cm.display.viewTo || range.to().line < cm.display.viewFrom) { continue }\\n    var collapsed = range.empty()\\n    if (collapsed || cm.options.showCursorWhenSelecting)\\n      { drawSelectionCursor(cm, range.head, curFragment) }\\n    if (!collapsed)\\n      { drawSelectionRange(cm, range, selFragment) }\\n  }\\n  return result\\n}\\n\\n// Draws a cursor for the given range\\nfunction drawSelectionCursor(cm, head, output) {\\n  var pos = cursorCoords(cm, head, \\\"div\\\", null, null, !cm.options.singleCursorHeightPerLine)\\n\\n  var cursor = output.appendChild(elt(\\\"div\\\", \\\"\\\\u00a0\\\", \\\"CodeMirror-cursor\\\"))\\n  cursor.style.left = pos.left + \\\"px\\\"\\n  cursor.style.top = pos.top + \\\"px\\\"\\n  cursor.style.height = Math.max(0, pos.bottom - pos.top) * cm.options.cursorHeight + \\\"px\\\"\\n\\n  if (pos.other) {\\n    // Secondary cursor, shown when on a 'jump' in bi-directional text\\n    var otherCursor = output.appendChild(elt(\\\"div\\\", \\\"\\\\u00a0\\\", \\\"CodeMirror-cursor CodeMirror-secondarycursor\\\"))\\n    otherCursor.style.display = \\\"\\\"\\n    otherCursor.style.left = pos.other.left + \\\"px\\\"\\n    otherCursor.style.top = pos.other.top + \\\"px\\\"\\n    otherCursor.style.height = (pos.other.bottom - pos.other.top) * .85 + \\\"px\\\"\\n  }\\n}\\n\\n// Draws the given range as a highlighted selection\\nfunction drawSelectionRange(cm, range, output) {\\n  var display = cm.display, doc = cm.doc\\n  var fragment = document.createDocumentFragment()\\n  var padding = paddingH(cm.display), leftSide = padding.left\\n  var rightSide = Math.max(display.sizerWidth, displayWidth(cm) - display.sizer.offsetLeft) - padding.right\\n\\n  function add(left, top, width, bottom) {\\n    if (top < 0) { top = 0 }\\n    top = Math.round(top)\\n    bottom = Math.round(bottom)\\n    fragment.appendChild(elt(\\\"div\\\", null, \\\"CodeMirror-selected\\\", (\\\"position: absolute; left: \\\" + left + \\\"px;\\\\n                             top: \\\" + top + \\\"px; width: \\\" + (width == null ? rightSide - left : width) + \\\"px;\\\\n                             height: \\\" + (bottom - top) + \\\"px\\\")))\\n  }\\n\\n  function drawForLine(line, fromArg, toArg) {\\n    var lineObj = getLine(doc, line)\\n    var lineLen = lineObj.text.length\\n    var start, end\\n    function coords(ch, bias) {\\n      return charCoords(cm, Pos(line, ch), \\\"div\\\", lineObj, bias)\\n    }\\n\\n    iterateBidiSections(getOrder(lineObj), fromArg || 0, toArg == null ? lineLen : toArg, function (from, to, dir) {\\n      var leftPos = coords(from, \\\"left\\\"), rightPos, left, right\\n      if (from == to) {\\n        rightPos = leftPos\\n        left = right = leftPos.left\\n      } else {\\n        rightPos = coords(to - 1, \\\"right\\\")\\n        if (dir == \\\"rtl\\\") { var tmp = leftPos; leftPos = rightPos; rightPos = tmp }\\n        left = leftPos.left\\n        right = rightPos.right\\n      }\\n      if (fromArg == null && from == 0) { left = leftSide }\\n      if (rightPos.top - leftPos.top > 3) { // Different lines, draw top part\\n        add(left, leftPos.top, null, leftPos.bottom)\\n        left = leftSide\\n        if (leftPos.bottom < rightPos.top) { add(left, leftPos.bottom, null, rightPos.top) }\\n      }\\n      if (toArg == null && to == lineLen) { right = rightSide }\\n      if (!start || leftPos.top < start.top || leftPos.top == start.top && leftPos.left < start.left)\\n        { start = leftPos }\\n      if (!end || rightPos.bottom > end.bottom || rightPos.bottom == end.bottom && rightPos.right > end.right)\\n        { end = rightPos }\\n      if (left < leftSide + 1) { left = leftSide }\\n      add(left, rightPos.top, right - left, rightPos.bottom)\\n    })\\n    return {start: start, end: end}\\n  }\\n\\n  var sFrom = range.from(), sTo = range.to()\\n  if (sFrom.line == sTo.line) {\\n    drawForLine(sFrom.line, sFrom.ch, sTo.ch)\\n  } else {\\n    var fromLine = getLine(doc, sFrom.line), toLine = getLine(doc, sTo.line)\\n    var singleVLine = visualLine(fromLine) == visualLine(toLine)\\n    var leftEnd = drawForLine(sFrom.line, sFrom.ch, singleVLine ? fromLine.text.length + 1 : null).end\\n    var rightStart = drawForLine(sTo.line, singleVLine ? 0 : null, sTo.ch).start\\n    if (singleVLine) {\\n      if (leftEnd.top < rightStart.top - 2) {\\n        add(leftEnd.right, leftEnd.top, null, leftEnd.bottom)\\n        add(leftSide, rightStart.top, rightStart.left, rightStart.bottom)\\n      } else {\\n        add(leftEnd.right, leftEnd.top, rightStart.left - leftEnd.right, leftEnd.bottom)\\n      }\\n    }\\n    if (leftEnd.bottom < rightStart.top)\\n      { add(leftSide, leftEnd.bottom, null, rightStart.top) }\\n  }\\n\\n  output.appendChild(fragment)\\n}\\n\\n// Cursor-blinking\\nfunction restartBlink(cm) {\\n  if (!cm.state.focused) { return }\\n  var display = cm.display\\n  clearInterval(display.blinker)\\n  var on = true\\n  display.cursorDiv.style.visibility = \\\"\\\"\\n  if (cm.options.cursorBlinkRate > 0)\\n    { display.blinker = setInterval(function () { return display.cursorDiv.style.visibility = (on = !on) ? \\\"\\\" : \\\"hidden\\\"; },\\n      cm.options.cursorBlinkRate) }\\n  else if (cm.options.cursorBlinkRate < 0)\\n    { display.cursorDiv.style.visibility = \\\"hidden\\\" }\\n}\\n\\nfunction ensureFocus(cm) {\\n  if (!cm.state.focused) { cm.display.input.focus(); onFocus(cm) }\\n}\\n\\nfunction delayBlurEvent(cm) {\\n  cm.state.delayingBlurEvent = true\\n  setTimeout(function () { if (cm.state.delayingBlurEvent) {\\n    cm.state.delayingBlurEvent = false\\n    onBlur(cm)\\n  } }, 100)\\n}\\n\\nfunction onFocus(cm, e) {\\n  if (cm.state.delayingBlurEvent) { cm.state.delayingBlurEvent = false }\\n\\n  if (cm.options.readOnly == \\\"nocursor\\\") { return }\\n  if (!cm.state.focused) {\\n    signal(cm, \\\"focus\\\", cm, e)\\n    cm.state.focused = true\\n    addClass(cm.display.wrapper, \\\"CodeMirror-focused\\\")\\n    // This test prevents this from firing when a context\\n    // menu is closed (since the input reset would kill the\\n    // select-all detection hack)\\n    if (!cm.curOp && cm.display.selForContextMenu != cm.doc.sel) {\\n      cm.display.input.reset()\\n      if (webkit) { setTimeout(function () { return cm.display.input.reset(true); }, 20) } // Issue #1730\\n    }\\n    cm.display.input.receivedFocus()\\n  }\\n  restartBlink(cm)\\n}\\nfunction onBlur(cm, e) {\\n  if (cm.state.delayingBlurEvent) { return }\\n\\n  if (cm.state.focused) {\\n    signal(cm, \\\"blur\\\", cm, e)\\n    cm.state.focused = false\\n    rmClass(cm.display.wrapper, \\\"CodeMirror-focused\\\")\\n  }\\n  clearInterval(cm.display.blinker)\\n  setTimeout(function () { if (!cm.state.focused) { cm.display.shift = false } }, 150)\\n}\\n\\n// Re-align line numbers and gutter marks to compensate for\\n// horizontal scrolling.\\nfunction alignHorizontally(cm) {\\n  var display = cm.display, view = display.view\\n  if (!display.alignWidgets && (!display.gutters.firstChild || !cm.options.fixedGutter)) { return }\\n  var comp = compensateForHScroll(display) - display.scroller.scrollLeft + cm.doc.scrollLeft\\n  var gutterW = display.gutters.offsetWidth, left = comp + \\\"px\\\"\\n  for (var i = 0; i < view.length; i++) { if (!view[i].hidden) {\\n    if (cm.options.fixedGutter) {\\n      if (view[i].gutter)\\n        { view[i].gutter.style.left = left }\\n      if (view[i].gutterBackground)\\n        { view[i].gutterBackground.style.left = left }\\n    }\\n    var align = view[i].alignable\\n    if (align) { for (var j = 0; j < align.length; j++)\\n      { align[j].style.left = left } }\\n  } }\\n  if (cm.options.fixedGutter)\\n    { display.gutters.style.left = (comp + gutterW) + \\\"px\\\" }\\n}\\n\\n// Used to ensure that the line number gutter is still the right\\n// size for the current document size. Returns true when an update\\n// is needed.\\nfunction maybeUpdateLineNumberWidth(cm) {\\n  if (!cm.options.lineNumbers) { return false }\\n  var doc = cm.doc, last = lineNumberFor(cm.options, doc.first + doc.size - 1), display = cm.display\\n  if (last.length != display.lineNumChars) {\\n    var test = display.measure.appendChild(elt(\\\"div\\\", [elt(\\\"div\\\", last)],\\n                                               \\\"CodeMirror-linenumber CodeMirror-gutter-elt\\\"))\\n    var innerW = test.firstChild.offsetWidth, padding = test.offsetWidth - innerW\\n    display.lineGutter.style.width = \\\"\\\"\\n    display.lineNumInnerWidth = Math.max(innerW, display.lineGutter.offsetWidth - padding) + 1\\n    display.lineNumWidth = display.lineNumInnerWidth + padding\\n    display.lineNumChars = display.lineNumInnerWidth ? last.length : -1\\n    display.lineGutter.style.width = display.lineNumWidth + \\\"px\\\"\\n    updateGutterSpace(cm)\\n    return true\\n  }\\n  return false\\n}\\n\\n// Read the actual heights of the rendered lines, and update their\\n// stored heights to match.\\nfunction updateHeightsInViewport(cm) {\\n  var display = cm.display\\n  var prevBottom = display.lineDiv.offsetTop\\n  for (var i = 0; i < display.view.length; i++) {\\n    var cur = display.view[i], height = void 0\\n    if (cur.hidden) { continue }\\n    if (ie && ie_version < 8) {\\n      var bot = cur.node.offsetTop + cur.node.offsetHeight\\n      height = bot - prevBottom\\n      prevBottom = bot\\n    } else {\\n      var box = cur.node.getBoundingClientRect()\\n      height = box.bottom - box.top\\n    }\\n    var diff = cur.line.height - height\\n    if (height < 2) { height = textHeight(display) }\\n    if (diff > .001 || diff < -.001) {\\n      updateLineHeight(cur.line, height)\\n      updateWidgetHeight(cur.line)\\n      if (cur.rest) { for (var j = 0; j < cur.rest.length; j++)\\n        { updateWidgetHeight(cur.rest[j]) } }\\n    }\\n  }\\n}\\n\\n// Read and store the height of line widgets associated with the\\n// given line.\\nfunction updateWidgetHeight(line) {\\n  if (line.widgets) { for (var i = 0; i < line.widgets.length; ++i)\\n    { line.widgets[i].height = line.widgets[i].node.parentNode.offsetHeight } }\\n}\\n\\n// Compute the lines that are visible in a given viewport (defaults\\n// the the current scroll position). viewport may contain top,\\n// height, and ensure (see op.scrollToPos) properties.\\nfunction visibleLines(display, doc, viewport) {\\n  var top = viewport && viewport.top != null ? Math.max(0, viewport.top) : display.scroller.scrollTop\\n  top = Math.floor(top - paddingTop(display))\\n  var bottom = viewport && viewport.bottom != null ? viewport.bottom : top + display.wrapper.clientHeight\\n\\n  var from = lineAtHeight(doc, top), to = lineAtHeight(doc, bottom)\\n  // Ensure is a {from: {line, ch}, to: {line, ch}} object, and\\n  // forces those lines into the viewport (if possible).\\n  if (viewport && viewport.ensure) {\\n    var ensureFrom = viewport.ensure.from.line, ensureTo = viewport.ensure.to.line\\n    if (ensureFrom < from) {\\n      from = ensureFrom\\n      to = lineAtHeight(doc, heightAtLine(getLine(doc, ensureFrom)) + display.wrapper.clientHeight)\\n    } else if (Math.min(ensureTo, doc.lastLine()) >= to) {\\n      from = lineAtHeight(doc, heightAtLine(getLine(doc, ensureTo)) - display.wrapper.clientHeight)\\n      to = ensureTo\\n    }\\n  }\\n  return {from: from, to: Math.max(to, from + 1)}\\n}\\n\\n// Sync the scrollable area and scrollbars, ensure the viewport\\n// covers the visible area.\\nfunction setScrollTop(cm, val) {\\n  if (Math.abs(cm.doc.scrollTop - val) < 2) { return }\\n  cm.doc.scrollTop = val\\n  if (!gecko) { updateDisplaySimple(cm, {top: val}) }\\n  if (cm.display.scroller.scrollTop != val) { cm.display.scroller.scrollTop = val }\\n  cm.display.scrollbars.setScrollTop(val)\\n  if (gecko) { updateDisplaySimple(cm) }\\n  startWorker(cm, 100)\\n}\\n// Sync scroller and scrollbar, ensure the gutter elements are\\n// aligned.\\nfunction setScrollLeft(cm, val, isScroller) {\\n  if (isScroller ? val == cm.doc.scrollLeft : Math.abs(cm.doc.scrollLeft - val) < 2) { return }\\n  val = Math.min(val, cm.display.scroller.scrollWidth - cm.display.scroller.clientWidth)\\n  cm.doc.scrollLeft = val\\n  alignHorizontally(cm)\\n  if (cm.display.scroller.scrollLeft != val) { cm.display.scroller.scrollLeft = val }\\n  cm.display.scrollbars.setScrollLeft(val)\\n}\\n\\n// Since the delta values reported on mouse wheel events are\\n// unstandardized between browsers and even browser versions, and\\n// generally horribly unpredictable, this code starts by measuring\\n// the scroll effect that the first few mouse wheel events have,\\n// and, from that, detects the way it can convert deltas to pixel\\n// offsets afterwards.\\n//\\n// The reason we want to know the amount a wheel event will scroll\\n// is that it gives us a chance to update the display before the\\n// actual scrolling happens, reducing flickering.\\n\\nvar wheelSamples = 0;\\nvar wheelPixelsPerUnit = null;\\n// Fill in a browser-detected starting value on browsers where we\\n// know one. These don't have to be accurate -- the result of them\\n// being wrong would just be a slight flicker on the first wheel\\n// scroll (if it is large enough).\\nif (ie) { wheelPixelsPerUnit = -.53 }\\nelse if (gecko) { wheelPixelsPerUnit = 15 }\\nelse if (chrome) { wheelPixelsPerUnit = -.7 }\\nelse if (safari) { wheelPixelsPerUnit = -1/3 }\\n\\nfunction wheelEventDelta(e) {\\n  var dx = e.wheelDeltaX, dy = e.wheelDeltaY\\n  if (dx == null && e.detail && e.axis == e.HORIZONTAL_AXIS) { dx = e.detail }\\n  if (dy == null && e.detail && e.axis == e.VERTICAL_AXIS) { dy = e.detail }\\n  else if (dy == null) { dy = e.wheelDelta }\\n  return {x: dx, y: dy}\\n}\\nfunction wheelEventPixels(e) {\\n  var delta = wheelEventDelta(e)\\n  delta.x *= wheelPixelsPerUnit\\n  delta.y *= wheelPixelsPerUnit\\n  return delta\\n}\\n\\nfunction onScrollWheel(cm, e) {\\n  var delta = wheelEventDelta(e), dx = delta.x, dy = delta.y\\n\\n  var display = cm.display, scroll = display.scroller\\n  // Quit if there's nothing to scroll here\\n  var canScrollX = scroll.scrollWidth > scroll.clientWidth\\n  var canScrollY = scroll.scrollHeight > scroll.clientHeight\\n  if (!(dx && canScrollX || dy && canScrollY)) { return }\\n\\n  // Webkit browsers on OS X abort momentum scrolls when the target\\n  // of the scroll event is removed from the scrollable element.\\n  // This hack (see related code in patchDisplay) makes sure the\\n  // element is kept around.\\n  if (dy && mac && webkit) {\\n    outer: for (var cur = e.target, view = display.view; cur != scroll; cur = cur.parentNode) {\\n      for (var i = 0; i < view.length; i++) {\\n        if (view[i].node == cur) {\\n          cm.display.currentWheelTarget = cur\\n          break outer\\n        }\\n      }\\n    }\\n  }\\n\\n  // On some browsers, horizontal scrolling will cause redraws to\\n  // happen before the gutter has been realigned, causing it to\\n  // wriggle around in a most unseemly way. When we have an\\n  // estimated pixels/delta value, we just handle horizontal\\n  // scrolling entirely here. It'll be slightly off from native, but\\n  // better than glitching out.\\n  if (dx && !gecko && !presto && wheelPixelsPerUnit != null) {\\n    if (dy && canScrollY)\\n      { setScrollTop(cm, Math.max(0, Math.min(scroll.scrollTop + dy * wheelPixelsPerUnit, scroll.scrollHeight - scroll.clientHeight))) }\\n    setScrollLeft(cm, Math.max(0, Math.min(scroll.scrollLeft + dx * wheelPixelsPerUnit, scroll.scrollWidth - scroll.clientWidth)))\\n    // Only prevent default scrolling if vertical scrolling is\\n    // actually possible. Otherwise, it causes vertical scroll\\n    // jitter on OSX trackpads when deltaX is small and deltaY\\n    // is large (issue #3579)\\n    if (!dy || (dy && canScrollY))\\n      { e_preventDefault(e) }\\n    display.wheelStartX = null // Abort measurement, if in progress\\n    return\\n  }\\n\\n  // 'Project' the visible viewport to cover the area that is being\\n  // scrolled into view (if we know enough to estimate it).\\n  if (dy && wheelPixelsPerUnit != null) {\\n    var pixels = dy * wheelPixelsPerUnit\\n    var top = cm.doc.scrollTop, bot = top + display.wrapper.clientHeight\\n    if (pixels < 0) { top = Math.max(0, top + pixels - 50) }\\n    else { bot = Math.min(cm.doc.height, bot + pixels + 50) }\\n    updateDisplaySimple(cm, {top: top, bottom: bot})\\n  }\\n\\n  if (wheelSamples < 20) {\\n    if (display.wheelStartX == null) {\\n      display.wheelStartX = scroll.scrollLeft; display.wheelStartY = scroll.scrollTop\\n      display.wheelDX = dx; display.wheelDY = dy\\n      setTimeout(function () {\\n        if (display.wheelStartX == null) { return }\\n        var movedX = scroll.scrollLeft - display.wheelStartX\\n        var movedY = scroll.scrollTop - display.wheelStartY\\n        var sample = (movedY && display.wheelDY && movedY / display.wheelDY) ||\\n          (movedX && display.wheelDX && movedX / display.wheelDX)\\n        display.wheelStartX = display.wheelStartY = null\\n        if (!sample) { return }\\n        wheelPixelsPerUnit = (wheelPixelsPerUnit * wheelSamples + sample) / (wheelSamples + 1)\\n        ++wheelSamples\\n      }, 200)\\n    } else {\\n      display.wheelDX += dx; display.wheelDY += dy\\n    }\\n  }\\n}\\n\\n// SCROLLBARS\\n\\n// Prepare DOM reads needed to update the scrollbars. Done in one\\n// shot to minimize update/measure roundtrips.\\nfunction measureForScrollbars(cm) {\\n  var d = cm.display, gutterW = d.gutters.offsetWidth\\n  var docH = Math.round(cm.doc.height + paddingVert(cm.display))\\n  return {\\n    clientHeight: d.scroller.clientHeight,\\n    viewHeight: d.wrapper.clientHeight,\\n    scrollWidth: d.scroller.scrollWidth, clientWidth: d.scroller.clientWidth,\\n    viewWidth: d.wrapper.clientWidth,\\n    barLeft: cm.options.fixedGutter ? gutterW : 0,\\n    docHeight: docH,\\n    scrollHeight: docH + scrollGap(cm) + d.barHeight,\\n    nativeBarWidth: d.nativeBarWidth,\\n    gutterWidth: gutterW\\n  }\\n}\\n\\nfunction NativeScrollbars(place, scroll, cm) {\\n  this.cm = cm\\n  var vert = this.vert = elt(\\\"div\\\", [elt(\\\"div\\\", null, null, \\\"min-width: 1px\\\")], \\\"CodeMirror-vscrollbar\\\")\\n  var horiz = this.horiz = elt(\\\"div\\\", [elt(\\\"div\\\", null, null, \\\"height: 100%; min-height: 1px\\\")], \\\"CodeMirror-hscrollbar\\\")\\n  place(vert); place(horiz)\\n\\n  on(vert, \\\"scroll\\\", function () {\\n    if (vert.clientHeight) { scroll(vert.scrollTop, \\\"vertical\\\") }\\n  })\\n  on(horiz, \\\"scroll\\\", function () {\\n    if (horiz.clientWidth) { scroll(horiz.scrollLeft, \\\"horizontal\\\") }\\n  })\\n\\n  this.checkedZeroWidth = false\\n  // Need to set a minimum width to see the scrollbar on IE7 (but must not set it on IE8).\\n  if (ie && ie_version < 8) { this.horiz.style.minHeight = this.vert.style.minWidth = \\\"18px\\\" }\\n}\\n\\nNativeScrollbars.prototype = copyObj({\\n  update: function(measure) {\\n    var needsH = measure.scrollWidth > measure.clientWidth + 1\\n    var needsV = measure.scrollHeight > measure.clientHeight + 1\\n    var sWidth = measure.nativeBarWidth\\n\\n    if (needsV) {\\n      this.vert.style.display = \\\"block\\\"\\n      this.vert.style.bottom = needsH ? sWidth + \\\"px\\\" : \\\"0\\\"\\n      var totalHeight = measure.viewHeight - (needsH ? sWidth : 0)\\n      // A bug in IE8 can cause this value to be negative, so guard it.\\n      this.vert.firstChild.style.height =\\n        Math.max(0, measure.scrollHeight - measure.clientHeight + totalHeight) + \\\"px\\\"\\n    } else {\\n      this.vert.style.display = \\\"\\\"\\n      this.vert.firstChild.style.height = \\\"0\\\"\\n    }\\n\\n    if (needsH) {\\n      this.horiz.style.display = \\\"block\\\"\\n      this.horiz.style.right = needsV ? sWidth + \\\"px\\\" : \\\"0\\\"\\n      this.horiz.style.left = measure.barLeft + \\\"px\\\"\\n      var totalWidth = measure.viewWidth - measure.barLeft - (needsV ? sWidth : 0)\\n      this.horiz.firstChild.style.width =\\n        (measure.scrollWidth - measure.clientWidth + totalWidth) + \\\"px\\\"\\n    } else {\\n      this.horiz.style.display = \\\"\\\"\\n      this.horiz.firstChild.style.width = \\\"0\\\"\\n    }\\n\\n    if (!this.checkedZeroWidth && measure.clientHeight > 0) {\\n      if (sWidth == 0) { this.zeroWidthHack() }\\n      this.checkedZeroWidth = true\\n    }\\n\\n    return {right: needsV ? sWidth : 0, bottom: needsH ? sWidth : 0}\\n  },\\n  setScrollLeft: function(pos) {\\n    if (this.horiz.scrollLeft != pos) { this.horiz.scrollLeft = pos }\\n    if (this.disableHoriz) { this.enableZeroWidthBar(this.horiz, this.disableHoriz) }\\n  },\\n  setScrollTop: function(pos) {\\n    if (this.vert.scrollTop != pos) { this.vert.scrollTop = pos }\\n    if (this.disableVert) { this.enableZeroWidthBar(this.vert, this.disableVert) }\\n  },\\n  zeroWidthHack: function() {\\n    var w = mac && !mac_geMountainLion ? \\\"12px\\\" : \\\"18px\\\"\\n    this.horiz.style.height = this.vert.style.width = w\\n    this.horiz.style.pointerEvents = this.vert.style.pointerEvents = \\\"none\\\"\\n    this.disableHoriz = new Delayed\\n    this.disableVert = new Delayed\\n  },\\n  enableZeroWidthBar: function(bar, delay) {\\n    bar.style.pointerEvents = \\\"auto\\\"\\n    function maybeDisable() {\\n      // To find out whether the scrollbar is still visible, we\\n      // check whether the element under the pixel in the bottom\\n      // left corner of the scrollbar box is the scrollbar box\\n      // itself (when the bar is still visible) or its filler child\\n      // (when the bar is hidden). If it is still visible, we keep\\n      // it enabled, if it's hidden, we disable pointer events.\\n      var box = bar.getBoundingClientRect()\\n      var elt = document.elementFromPoint(box.left + 1, box.bottom - 1)\\n      if (elt != bar) { bar.style.pointerEvents = \\\"none\\\" }\\n      else { delay.set(1000, maybeDisable) }\\n    }\\n    delay.set(1000, maybeDisable)\\n  },\\n  clear: function() {\\n    var parent = this.horiz.parentNode\\n    parent.removeChild(this.horiz)\\n    parent.removeChild(this.vert)\\n  }\\n}, NativeScrollbars.prototype)\\n\\nfunction NullScrollbars() {}\\n\\nNullScrollbars.prototype = copyObj({\\n  update: function() { return {bottom: 0, right: 0} },\\n  setScrollLeft: function() {},\\n  setScrollTop: function() {},\\n  clear: function() {}\\n}, NullScrollbars.prototype)\\n\\nfunction updateScrollbars(cm, measure) {\\n  if (!measure) { measure = measureForScrollbars(cm) }\\n  var startWidth = cm.display.barWidth, startHeight = cm.display.barHeight\\n  updateScrollbarsInner(cm, measure)\\n  for (var i = 0; i < 4 && startWidth != cm.display.barWidth || startHeight != cm.display.barHeight; i++) {\\n    if (startWidth != cm.display.barWidth && cm.options.lineWrapping)\\n      { updateHeightsInViewport(cm) }\\n    updateScrollbarsInner(cm, measureForScrollbars(cm))\\n    startWidth = cm.display.barWidth; startHeight = cm.display.barHeight\\n  }\\n}\\n\\n// Re-synchronize the fake scrollbars with the actual size of the\\n// content.\\nfunction updateScrollbarsInner(cm, measure) {\\n  var d = cm.display\\n  var sizes = d.scrollbars.update(measure)\\n\\n  d.sizer.style.paddingRight = (d.barWidth = sizes.right) + \\\"px\\\"\\n  d.sizer.style.paddingBottom = (d.barHeight = sizes.bottom) + \\\"px\\\"\\n  d.heightForcer.style.borderBottom = sizes.bottom + \\\"px solid transparent\\\"\\n\\n  if (sizes.right && sizes.bottom) {\\n    d.scrollbarFiller.style.display = \\\"block\\\"\\n    d.scrollbarFiller.style.height = sizes.bottom + \\\"px\\\"\\n    d.scrollbarFiller.style.width = sizes.right + \\\"px\\\"\\n  } else { d.scrollbarFiller.style.display = \\\"\\\" }\\n  if (sizes.bottom && cm.options.coverGutterNextToScrollbar && cm.options.fixedGutter) {\\n    d.gutterFiller.style.display = \\\"block\\\"\\n    d.gutterFiller.style.height = sizes.bottom + \\\"px\\\"\\n    d.gutterFiller.style.width = measure.gutterWidth + \\\"px\\\"\\n  } else { d.gutterFiller.style.display = \\\"\\\" }\\n}\\n\\nvar scrollbarModel = {\\\"native\\\": NativeScrollbars, \\\"null\\\": NullScrollbars}\\n\\nfunction initScrollbars(cm) {\\n  if (cm.display.scrollbars) {\\n    cm.display.scrollbars.clear()\\n    if (cm.display.scrollbars.addClass)\\n      { rmClass(cm.display.wrapper, cm.display.scrollbars.addClass) }\\n  }\\n\\n  cm.display.scrollbars = new scrollbarModel[cm.options.scrollbarStyle](function (node) {\\n    cm.display.wrapper.insertBefore(node, cm.display.scrollbarFiller)\\n    // Prevent clicks in the scrollbars from killing focus\\n    on(node, \\\"mousedown\\\", function () {\\n      if (cm.state.focused) { setTimeout(function () { return cm.display.input.focus(); }, 0) }\\n    })\\n    node.setAttribute(\\\"cm-not-content\\\", \\\"true\\\")\\n  }, function (pos, axis) {\\n    if (axis == \\\"horizontal\\\") { setScrollLeft(cm, pos) }\\n    else { setScrollTop(cm, pos) }\\n  }, cm)\\n  if (cm.display.scrollbars.addClass)\\n    { addClass(cm.display.wrapper, cm.display.scrollbars.addClass) }\\n}\\n\\n// SCROLLING THINGS INTO VIEW\\n\\n// If an editor sits on the top or bottom of the window, partially\\n// scrolled out of view, this ensures that the cursor is visible.\\nfunction maybeScrollWindow(cm, coords) {\\n  if (signalDOMEvent(cm, \\\"scrollCursorIntoView\\\")) { return }\\n\\n  var display = cm.display, box = display.sizer.getBoundingClientRect(), doScroll = null\\n  if (coords.top + box.top < 0) { doScroll = true }\\n  else if (coords.bottom + box.top > (window.innerHeight || document.documentElement.clientHeight)) { doScroll = false }\\n  if (doScroll != null && !phantom) {\\n    var scrollNode = elt(\\\"div\\\", \\\"\\\\u200b\\\", null, (\\\"position: absolute;\\\\n                         top: \\\" + (coords.top - display.viewOffset - paddingTop(cm.display)) + \\\"px;\\\\n                         height: \\\" + (coords.bottom - coords.top + scrollGap(cm) + display.barHeight) + \\\"px;\\\\n                         left: \\\" + (coords.left) + \\\"px; width: 2px;\\\"))\\n    cm.display.lineSpace.appendChild(scrollNode)\\n    scrollNode.scrollIntoView(doScroll)\\n    cm.display.lineSpace.removeChild(scrollNode)\\n  }\\n}\\n\\n// Scroll a given position into view (immediately), verifying that\\n// it actually became visible (as line heights are accurately\\n// measured, the position of something may 'drift' during drawing).\\nfunction scrollPosIntoView(cm, pos, end, margin) {\\n  if (margin == null) { margin = 0 }\\n  var coords\\n  for (var limit = 0; limit < 5; limit++) {\\n    var changed = false\\n    coords = cursorCoords(cm, pos)\\n    var endCoords = !end || end == pos ? coords : cursorCoords(cm, end)\\n    var scrollPos = calculateScrollPos(cm, Math.min(coords.left, endCoords.left),\\n                                       Math.min(coords.top, endCoords.top) - margin,\\n                                       Math.max(coords.left, endCoords.left),\\n                                       Math.max(coords.bottom, endCoords.bottom) + margin)\\n    var startTop = cm.doc.scrollTop, startLeft = cm.doc.scrollLeft\\n    if (scrollPos.scrollTop != null) {\\n      setScrollTop(cm, scrollPos.scrollTop)\\n      if (Math.abs(cm.doc.scrollTop - startTop) > 1) { changed = true }\\n    }\\n    if (scrollPos.scrollLeft != null) {\\n      setScrollLeft(cm, scrollPos.scrollLeft)\\n      if (Math.abs(cm.doc.scrollLeft - startLeft) > 1) { changed = true }\\n    }\\n    if (!changed) { break }\\n  }\\n  return coords\\n}\\n\\n// Scroll a given set of coordinates into view (immediately).\\nfunction scrollIntoView(cm, x1, y1, x2, y2) {\\n  var scrollPos = calculateScrollPos(cm, x1, y1, x2, y2)\\n  if (scrollPos.scrollTop != null) { setScrollTop(cm, scrollPos.scrollTop) }\\n  if (scrollPos.scrollLeft != null) { setScrollLeft(cm, scrollPos.scrollLeft) }\\n}\\n\\n// Calculate a new scroll position needed to scroll the given\\n// rectangle into view. Returns an object with scrollTop and\\n// scrollLeft properties. When these are undefined, the\\n// vertical/horizontal position does not need to be adjusted.\\nfunction calculateScrollPos(cm, x1, y1, x2, y2) {\\n  var display = cm.display, snapMargin = textHeight(cm.display)\\n  if (y1 < 0) { y1 = 0 }\\n  var screentop = cm.curOp && cm.curOp.scrollTop != null ? cm.curOp.scrollTop : display.scroller.scrollTop\\n  var screen = displayHeight(cm), result = {}\\n  if (y2 - y1 > screen) { y2 = y1 + screen }\\n  var docBottom = cm.doc.height + paddingVert(display)\\n  var atTop = y1 < snapMargin, atBottom = y2 > docBottom - snapMargin\\n  if (y1 < screentop) {\\n    result.scrollTop = atTop ? 0 : y1\\n  } else if (y2 > screentop + screen) {\\n    var newTop = Math.min(y1, (atBottom ? docBottom : y2) - screen)\\n    if (newTop != screentop) { result.scrollTop = newTop }\\n  }\\n\\n  var screenleft = cm.curOp && cm.curOp.scrollLeft != null ? cm.curOp.scrollLeft : display.scroller.scrollLeft\\n  var screenw = displayWidth(cm) - (cm.options.fixedGutter ? display.gutters.offsetWidth : 0)\\n  var tooWide = x2 - x1 > screenw\\n  if (tooWide) { x2 = x1 + screenw }\\n  if (x1 < 10)\\n    { result.scrollLeft = 0 }\\n  else if (x1 < screenleft)\\n    { result.scrollLeft = Math.max(0, x1 - (tooWide ? 0 : 10)) }\\n  else if (x2 > screenw + screenleft - 3)\\n    { result.scrollLeft = x2 + (tooWide ? 0 : 10) - screenw }\\n  return result\\n}\\n\\n// Store a relative adjustment to the scroll position in the current\\n// operation (to be applied when the operation finishes).\\nfunction addToScrollPos(cm, left, top) {\\n  if (left != null || top != null) { resolveScrollToPos(cm) }\\n  if (left != null)\\n    { cm.curOp.scrollLeft = (cm.curOp.scrollLeft == null ? cm.doc.scrollLeft : cm.curOp.scrollLeft) + left }\\n  if (top != null)\\n    { cm.curOp.scrollTop = (cm.curOp.scrollTop == null ? cm.doc.scrollTop : cm.curOp.scrollTop) + top }\\n}\\n\\n// Make sure that at the end of the operation the current cursor is\\n// shown.\\nfunction ensureCursorVisible(cm) {\\n  resolveScrollToPos(cm)\\n  var cur = cm.getCursor(), from = cur, to = cur\\n  if (!cm.options.lineWrapping) {\\n    from = cur.ch ? Pos(cur.line, cur.ch - 1) : cur\\n    to = Pos(cur.line, cur.ch + 1)\\n  }\\n  cm.curOp.scrollToPos = {from: from, to: to, margin: cm.options.cursorScrollMargin, isCursor: true}\\n}\\n\\n// When an operation has its scrollToPos property set, and another\\n// scroll action is applied before the end of the operation, this\\n// 'simulates' scrolling that position into view in a cheap way, so\\n// that the effect of intermediate scroll commands is not ignored.\\nfunction resolveScrollToPos(cm) {\\n  var range = cm.curOp.scrollToPos\\n  if (range) {\\n    cm.curOp.scrollToPos = null\\n    var from = estimateCoords(cm, range.from), to = estimateCoords(cm, range.to)\\n    var sPos = calculateScrollPos(cm, Math.min(from.left, to.left),\\n                                  Math.min(from.top, to.top) - range.margin,\\n                                  Math.max(from.right, to.right),\\n                                  Math.max(from.bottom, to.bottom) + range.margin)\\n    cm.scrollTo(sPos.scrollLeft, sPos.scrollTop)\\n  }\\n}\\n\\n// Operations are used to wrap a series of changes to the editor\\n// state in such a way that each change won't have to update the\\n// cursor and display (which would be awkward, slow, and\\n// error-prone). Instead, display updates are batched and then all\\n// combined and executed at once.\\n\\nvar nextOpId = 0\\n// Start a new operation.\\nfunction startOperation(cm) {\\n  cm.curOp = {\\n    cm: cm,\\n    viewChanged: false,      // Flag that indicates that lines might need to be redrawn\\n    startHeight: cm.doc.height, // Used to detect need to update scrollbar\\n    forceUpdate: false,      // Used to force a redraw\\n    updateInput: null,       // Whether to reset the input textarea\\n    typing: false,           // Whether this reset should be careful to leave existing text (for compositing)\\n    changeObjs: null,        // Accumulated changes, for firing change events\\n    cursorActivityHandlers: null, // Set of handlers to fire cursorActivity on\\n    cursorActivityCalled: 0, // Tracks which cursorActivity handlers have been called already\\n    selectionChanged: false, // Whether the selection needs to be redrawn\\n    updateMaxLine: false,    // Set when the widest line needs to be determined anew\\n    scrollLeft: null, scrollTop: null, // Intermediate scroll position, not pushed to DOM yet\\n    scrollToPos: null,       // Used to scroll to a specific position\\n    focus: false,\\n    id: ++nextOpId           // Unique ID\\n  }\\n  pushOperation(cm.curOp)\\n}\\n\\n// Finish an operation, updating the display and signalling delayed events\\nfunction endOperation(cm) {\\n  var op = cm.curOp\\n  finishOperation(op, function (group) {\\n    for (var i = 0; i < group.ops.length; i++)\\n      { group.ops[i].cm.curOp = null }\\n    endOperations(group)\\n  })\\n}\\n\\n// The DOM updates done when an operation finishes are batched so\\n// that the minimum number of relayouts are required.\\nfunction endOperations(group) {\\n  var ops = group.ops\\n  for (var i = 0; i < ops.length; i++) // Read DOM\\n    { endOperation_R1(ops[i]) }\\n  for (var i$1 = 0; i$1 < ops.length; i$1++) // Write DOM (maybe)\\n    { endOperation_W1(ops[i$1]) }\\n  for (var i$2 = 0; i$2 < ops.length; i$2++) // Read DOM\\n    { endOperation_R2(ops[i$2]) }\\n  for (var i$3 = 0; i$3 < ops.length; i$3++) // Write DOM (maybe)\\n    { endOperation_W2(ops[i$3]) }\\n  for (var i$4 = 0; i$4 < ops.length; i$4++) // Read DOM\\n    { endOperation_finish(ops[i$4]) }\\n}\\n\\nfunction endOperation_R1(op) {\\n  var cm = op.cm, display = cm.display\\n  maybeClipScrollbars(cm)\\n  if (op.updateMaxLine) { findMaxLine(cm) }\\n\\n  op.mustUpdate = op.viewChanged || op.forceUpdate || op.scrollTop != null ||\\n    op.scrollToPos && (op.scrollToPos.from.line < display.viewFrom ||\\n                       op.scrollToPos.to.line >= display.viewTo) ||\\n    display.maxLineChanged && cm.options.lineWrapping\\n  op.update = op.mustUpdate &&\\n    new DisplayUpdate(cm, op.mustUpdate && {top: op.scrollTop, ensure: op.scrollToPos}, op.forceUpdate)\\n}\\n\\nfunction endOperation_W1(op) {\\n  op.updatedDisplay = op.mustUpdate && updateDisplayIfNeeded(op.cm, op.update)\\n}\\n\\nfunction endOperation_R2(op) {\\n  var cm = op.cm, display = cm.display\\n  if (op.updatedDisplay) { updateHeightsInViewport(cm) }\\n\\n  op.barMeasure = measureForScrollbars(cm)\\n\\n  // If the max line changed since it was last measured, measure it,\\n  // and ensure the document's width matches it.\\n  // updateDisplay_W2 will use these properties to do the actual resizing\\n  if (display.maxLineChanged && !cm.options.lineWrapping) {\\n    op.adjustWidthTo = measureChar(cm, display.maxLine, display.maxLine.text.length).left + 3\\n    cm.display.sizerWidth = op.adjustWidthTo\\n    op.barMeasure.scrollWidth =\\n      Math.max(display.scroller.clientWidth, display.sizer.offsetLeft + op.adjustWidthTo + scrollGap(cm) + cm.display.barWidth)\\n    op.maxScrollLeft = Math.max(0, display.sizer.offsetLeft + op.adjustWidthTo - displayWidth(cm))\\n  }\\n\\n  if (op.updatedDisplay || op.selectionChanged)\\n    { op.preparedSelection = display.input.prepareSelection(op.focus) }\\n}\\n\\nfunction endOperation_W2(op) {\\n  var cm = op.cm\\n\\n  if (op.adjustWidthTo != null) {\\n    cm.display.sizer.style.minWidth = op.adjustWidthTo + \\\"px\\\"\\n    if (op.maxScrollLeft < cm.doc.scrollLeft)\\n      { setScrollLeft(cm, Math.min(cm.display.scroller.scrollLeft, op.maxScrollLeft), true) }\\n    cm.display.maxLineChanged = false\\n  }\\n\\n  var takeFocus = op.focus && op.focus == activeElt() && (!document.hasFocus || document.hasFocus())\\n  if (op.preparedSelection)\\n    { cm.display.input.showSelection(op.preparedSelection, takeFocus) }\\n  if (op.updatedDisplay || op.startHeight != cm.doc.height)\\n    { updateScrollbars(cm, op.barMeasure) }\\n  if (op.updatedDisplay)\\n    { setDocumentHeight(cm, op.barMeasure) }\\n\\n  if (op.selectionChanged) { restartBlink(cm) }\\n\\n  if (cm.state.focused && op.updateInput)\\n    { cm.display.input.reset(op.typing) }\\n  if (takeFocus) { ensureFocus(op.cm) }\\n}\\n\\nfunction endOperation_finish(op) {\\n  var cm = op.cm, display = cm.display, doc = cm.doc\\n\\n  if (op.updatedDisplay) { postUpdateDisplay(cm, op.update) }\\n\\n  // Abort mouse wheel delta measurement, when scrolling explicitly\\n  if (display.wheelStartX != null && (op.scrollTop != null || op.scrollLeft != null || op.scrollToPos))\\n    { display.wheelStartX = display.wheelStartY = null }\\n\\n  // Propagate the scroll position to the actual DOM scroller\\n  if (op.scrollTop != null && (display.scroller.scrollTop != op.scrollTop || op.forceScroll)) {\\n    doc.scrollTop = Math.max(0, Math.min(display.scroller.scrollHeight - display.scroller.clientHeight, op.scrollTop))\\n    display.scrollbars.setScrollTop(doc.scrollTop)\\n    display.scroller.scrollTop = doc.scrollTop\\n  }\\n  if (op.scrollLeft != null && (display.scroller.scrollLeft != op.scrollLeft || op.forceScroll)) {\\n    doc.scrollLeft = Math.max(0, Math.min(display.scroller.scrollWidth - display.scroller.clientWidth, op.scrollLeft))\\n    display.scrollbars.setScrollLeft(doc.scrollLeft)\\n    display.scroller.scrollLeft = doc.scrollLeft\\n    alignHorizontally(cm)\\n  }\\n  // If we need to scroll a specific position into view, do so.\\n  if (op.scrollToPos) {\\n    var coords = scrollPosIntoView(cm, clipPos(doc, op.scrollToPos.from),\\n                                   clipPos(doc, op.scrollToPos.to), op.scrollToPos.margin)\\n    if (op.scrollToPos.isCursor && cm.state.focused) { maybeScrollWindow(cm, coords) }\\n  }\\n\\n  // Fire events for markers that are hidden/unidden by editing or\\n  // undoing\\n  var hidden = op.maybeHiddenMarkers, unhidden = op.maybeUnhiddenMarkers\\n  if (hidden) { for (var i = 0; i < hidden.length; ++i)\\n    { if (!hidden[i].lines.length) { signal(hidden[i], \\\"hide\\\") } } }\\n  if (unhidden) { for (var i$1 = 0; i$1 < unhidden.length; ++i$1)\\n    { if (unhidden[i$1].lines.length) { signal(unhidden[i$1], \\\"unhide\\\") } } }\\n\\n  if (display.wrapper.offsetHeight)\\n    { doc.scrollTop = cm.display.scroller.scrollTop }\\n\\n  // Fire change events, and delayed event handlers\\n  if (op.changeObjs)\\n    { signal(cm, \\\"changes\\\", cm, op.changeObjs) }\\n  if (op.update)\\n    { op.update.finish() }\\n}\\n\\n// Run the given function in an operation\\nfunction runInOp(cm, f) {\\n  if (cm.curOp) { return f() }\\n  startOperation(cm)\\n  try { return f() }\\n  finally { endOperation(cm) }\\n}\\n// Wraps a function in an operation. Returns the wrapped function.\\nfunction operation(cm, f) {\\n  return function() {\\n    if (cm.curOp) { return f.apply(cm, arguments) }\\n    startOperation(cm)\\n    try { return f.apply(cm, arguments) }\\n    finally { endOperation(cm) }\\n  }\\n}\\n// Used to add methods to editor and doc instances, wrapping them in\\n// operations.\\nfunction methodOp(f) {\\n  return function() {\\n    if (this.curOp) { return f.apply(this, arguments) }\\n    startOperation(this)\\n    try { return f.apply(this, arguments) }\\n    finally { endOperation(this) }\\n  }\\n}\\nfunction docMethodOp(f) {\\n  return function() {\\n    var cm = this.cm\\n    if (!cm || cm.curOp) { return f.apply(this, arguments) }\\n    startOperation(cm)\\n    try { return f.apply(this, arguments) }\\n    finally { endOperation(cm) }\\n  }\\n}\\n\\n// Updates the display.view data structure for a given change to the\\n// document. From and to are in pre-change coordinates. Lendiff is\\n// the amount of lines added or subtracted by the change. This is\\n// used for changes that span multiple lines, or change the way\\n// lines are divided into visual lines. regLineChange (below)\\n// registers single-line changes.\\nfunction regChange(cm, from, to, lendiff) {\\n  if (from == null) { from = cm.doc.first }\\n  if (to == null) { to = cm.doc.first + cm.doc.size }\\n  if (!lendiff) { lendiff = 0 }\\n\\n  var display = cm.display\\n  if (lendiff && to < display.viewTo &&\\n      (display.updateLineNumbers == null || display.updateLineNumbers > from))\\n    { display.updateLineNumbers = from }\\n\\n  cm.curOp.viewChanged = true\\n\\n  if (from >= display.viewTo) { // Change after\\n    if (sawCollapsedSpans && visualLineNo(cm.doc, from) < display.viewTo)\\n      { resetView(cm) }\\n  } else if (to <= display.viewFrom) { // Change before\\n    if (sawCollapsedSpans && visualLineEndNo(cm.doc, to + lendiff) > display.viewFrom) {\\n      resetView(cm)\\n    } else {\\n      display.viewFrom += lendiff\\n      display.viewTo += lendiff\\n    }\\n  } else if (from <= display.viewFrom && to >= display.viewTo) { // Full overlap\\n    resetView(cm)\\n  } else if (from <= display.viewFrom) { // Top overlap\\n    var cut = viewCuttingPoint(cm, to, to + lendiff, 1)\\n    if (cut) {\\n      display.view = display.view.slice(cut.index)\\n      display.viewFrom = cut.lineN\\n      display.viewTo += lendiff\\n    } else {\\n      resetView(cm)\\n    }\\n  } else if (to >= display.viewTo) { // Bottom overlap\\n    var cut$1 = viewCuttingPoint(cm, from, from, -1)\\n    if (cut$1) {\\n      display.view = display.view.slice(0, cut$1.index)\\n      display.viewTo = cut$1.lineN\\n    } else {\\n      resetView(cm)\\n    }\\n  } else { // Gap in the middle\\n    var cutTop = viewCuttingPoint(cm, from, from, -1)\\n    var cutBot = viewCuttingPoint(cm, to, to + lendiff, 1)\\n    if (cutTop && cutBot) {\\n      display.view = display.view.slice(0, cutTop.index)\\n        .concat(buildViewArray(cm, cutTop.lineN, cutBot.lineN))\\n        .concat(display.view.slice(cutBot.index))\\n      display.viewTo += lendiff\\n    } else {\\n      resetView(cm)\\n    }\\n  }\\n\\n  var ext = display.externalMeasured\\n  if (ext) {\\n    if (to < ext.lineN)\\n      { ext.lineN += lendiff }\\n    else if (from < ext.lineN + ext.size)\\n      { display.externalMeasured = null }\\n  }\\n}\\n\\n// Register a change to a single line. Type must be one of \\\"text\\\",\\n// \\\"gutter\\\", \\\"class\\\", \\\"widget\\\"\\nfunction regLineChange(cm, line, type) {\\n  cm.curOp.viewChanged = true\\n  var display = cm.display, ext = cm.display.externalMeasured\\n  if (ext && line >= ext.lineN && line < ext.lineN + ext.size)\\n    { display.externalMeasured = null }\\n\\n  if (line < display.viewFrom || line >= display.viewTo) { return }\\n  var lineView = display.view[findViewIndex(cm, line)]\\n  if (lineView.node == null) { return }\\n  var arr = lineView.changes || (lineView.changes = [])\\n  if (indexOf(arr, type) == -1) { arr.push(type) }\\n}\\n\\n// Clear the view.\\nfunction resetView(cm) {\\n  cm.display.viewFrom = cm.display.viewTo = cm.doc.first\\n  cm.display.view = []\\n  cm.display.viewOffset = 0\\n}\\n\\nfunction viewCuttingPoint(cm, oldN, newN, dir) {\\n  var index = findViewIndex(cm, oldN), diff, view = cm.display.view\\n  if (!sawCollapsedSpans || newN == cm.doc.first + cm.doc.size)\\n    { return {index: index, lineN: newN} }\\n  var n = cm.display.viewFrom\\n  for (var i = 0; i < index; i++)\\n    { n += view[i].size }\\n  if (n != oldN) {\\n    if (dir > 0) {\\n      if (index == view.length - 1) { return null }\\n      diff = (n + view[index].size) - oldN\\n      index++\\n    } else {\\n      diff = n - oldN\\n    }\\n    oldN += diff; newN += diff\\n  }\\n  while (visualLineNo(cm.doc, newN) != newN) {\\n    if (index == (dir < 0 ? 0 : view.length - 1)) { return null }\\n    newN += dir * view[index - (dir < 0 ? 1 : 0)].size\\n    index += dir\\n  }\\n  return {index: index, lineN: newN}\\n}\\n\\n// Force the view to cover a given range, adding empty view element\\n// or clipping off existing ones as needed.\\nfunction adjustView(cm, from, to) {\\n  var display = cm.display, view = display.view\\n  if (view.length == 0 || from >= display.viewTo || to <= display.viewFrom) {\\n    display.view = buildViewArray(cm, from, to)\\n    display.viewFrom = from\\n  } else {\\n    if (display.viewFrom > from)\\n      { display.view = buildViewArray(cm, from, display.viewFrom).concat(display.view) }\\n    else if (display.viewFrom < from)\\n      { display.view = display.view.slice(findViewIndex(cm, from)) }\\n    display.viewFrom = from\\n    if (display.viewTo < to)\\n      { display.view = display.view.concat(buildViewArray(cm, display.viewTo, to)) }\\n    else if (display.viewTo > to)\\n      { display.view = display.view.slice(0, findViewIndex(cm, to)) }\\n  }\\n  display.viewTo = to\\n}\\n\\n// Count the number of lines in the view whose DOM representation is\\n// out of date (or nonexistent).\\nfunction countDirtyView(cm) {\\n  var view = cm.display.view, dirty = 0\\n  for (var i = 0; i < view.length; i++) {\\n    var lineView = view[i]\\n    if (!lineView.hidden && (!lineView.node || lineView.changes)) { ++dirty }\\n  }\\n  return dirty\\n}\\n\\n// HIGHLIGHT WORKER\\n\\nfunction startWorker(cm, time) {\\n  if (cm.doc.mode.startState && cm.doc.frontier < cm.display.viewTo)\\n    { cm.state.highlight.set(time, bind(highlightWorker, cm)) }\\n}\\n\\nfunction highlightWorker(cm) {\\n  var doc = cm.doc\\n  if (doc.frontier < doc.first) { doc.frontier = doc.first }\\n  if (doc.frontier >= cm.display.viewTo) { return }\\n  var end = +new Date + cm.options.workTime\\n  var state = copyState(doc.mode, getStateBefore(cm, doc.frontier))\\n  var changedLines = []\\n\\n  doc.iter(doc.frontier, Math.min(doc.first + doc.size, cm.display.viewTo + 500), function (line) {\\n    if (doc.frontier >= cm.display.viewFrom) { // Visible\\n      var oldStyles = line.styles, tooLong = line.text.length > cm.options.maxHighlightLength\\n      var highlighted = highlightLine(cm, line, tooLong ? copyState(doc.mode, state) : state, true)\\n      line.styles = highlighted.styles\\n      var oldCls = line.styleClasses, newCls = highlighted.classes\\n      if (newCls) { line.styleClasses = newCls }\\n      else if (oldCls) { line.styleClasses = null }\\n      var ischange = !oldStyles || oldStyles.length != line.styles.length ||\\n        oldCls != newCls && (!oldCls || !newCls || oldCls.bgClass != newCls.bgClass || oldCls.textClass != newCls.textClass)\\n      for (var i = 0; !ischange && i < oldStyles.length; ++i) { ischange = oldStyles[i] != line.styles[i] }\\n      if (ischange) { changedLines.push(doc.frontier) }\\n      line.stateAfter = tooLong ? state : copyState(doc.mode, state)\\n    } else {\\n      if (line.text.length <= cm.options.maxHighlightLength)\\n        { processLine(cm, line.text, state) }\\n      line.stateAfter = doc.frontier % 5 == 0 ? copyState(doc.mode, state) : null\\n    }\\n    ++doc.frontier\\n    if (+new Date > end) {\\n      startWorker(cm, cm.options.workDelay)\\n      return true\\n    }\\n  })\\n  if (changedLines.length) { runInOp(cm, function () {\\n    for (var i = 0; i < changedLines.length; i++)\\n      { regLineChange(cm, changedLines[i], \\\"text\\\") }\\n  }) }\\n}\\n\\n// DISPLAY DRAWING\\n\\nfunction DisplayUpdate(cm, viewport, force) {\\n  var display = cm.display\\n\\n  this.viewport = viewport\\n  // Store some values that we'll need later (but don't want to force a relayout for)\\n  this.visible = visibleLines(display, cm.doc, viewport)\\n  this.editorIsHidden = !display.wrapper.offsetWidth\\n  this.wrapperHeight = display.wrapper.clientHeight\\n  this.wrapperWidth = display.wrapper.clientWidth\\n  this.oldDisplayWidth = displayWidth(cm)\\n  this.force = force\\n  this.dims = getDimensions(cm)\\n  this.events = []\\n}\\n\\nDisplayUpdate.prototype.signal = function(emitter, type) {\\n  if (hasHandler(emitter, type))\\n    { this.events.push(arguments) }\\n}\\nDisplayUpdate.prototype.finish = function() {\\n  var this$1 = this;\\n\\n  for (var i = 0; i < this.events.length; i++)\\n    { signal.apply(null, this$1.events[i]) }\\n}\\n\\nfunction maybeClipScrollbars(cm) {\\n  var display = cm.display\\n  if (!display.scrollbarsClipped && display.scroller.offsetWidth) {\\n    display.nativeBarWidth = display.scroller.offsetWidth - display.scroller.clientWidth\\n    display.heightForcer.style.height = scrollGap(cm) + \\\"px\\\"\\n    display.sizer.style.marginBottom = -display.nativeBarWidth + \\\"px\\\"\\n    display.sizer.style.borderRightWidth = scrollGap(cm) + \\\"px\\\"\\n    display.scrollbarsClipped = true\\n  }\\n}\\n\\n// Does the actual updating of the line display. Bails out\\n// (returning false) when there is nothing to be done and forced is\\n// false.\\nfunction updateDisplayIfNeeded(cm, update) {\\n  var display = cm.display, doc = cm.doc\\n\\n  if (update.editorIsHidden) {\\n    resetView(cm)\\n    return false\\n  }\\n\\n  // Bail out if the visible area is already rendered and nothing changed.\\n  if (!update.force &&\\n      update.visible.from >= display.viewFrom && update.visible.to <= display.viewTo &&\\n      (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo) &&\\n      display.renderedView == display.view && countDirtyView(cm) == 0)\\n    { return false }\\n\\n  if (maybeUpdateLineNumberWidth(cm)) {\\n    resetView(cm)\\n    update.dims = getDimensions(cm)\\n  }\\n\\n  // Compute a suitable new viewport (from & to)\\n  var end = doc.first + doc.size\\n  var from = Math.max(update.visible.from - cm.options.viewportMargin, doc.first)\\n  var to = Math.min(end, update.visible.to + cm.options.viewportMargin)\\n  if (display.viewFrom < from && from - display.viewFrom < 20) { from = Math.max(doc.first, display.viewFrom) }\\n  if (display.viewTo > to && display.viewTo - to < 20) { to = Math.min(end, display.viewTo) }\\n  if (sawCollapsedSpans) {\\n    from = visualLineNo(cm.doc, from)\\n    to = visualLineEndNo(cm.doc, to)\\n  }\\n\\n  var different = from != display.viewFrom || to != display.viewTo ||\\n    display.lastWrapHeight != update.wrapperHeight || display.lastWrapWidth != update.wrapperWidth\\n  adjustView(cm, from, to)\\n\\n  display.viewOffset = heightAtLine(getLine(cm.doc, display.viewFrom))\\n  // Position the mover div to align with the current scroll position\\n  cm.display.mover.style.top = display.viewOffset + \\\"px\\\"\\n\\n  var toUpdate = countDirtyView(cm)\\n  if (!different && toUpdate == 0 && !update.force && display.renderedView == display.view &&\\n      (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo))\\n    { return false }\\n\\n  // For big changes, we hide the enclosing element during the\\n  // update, since that speeds up the operations on most browsers.\\n  var focused = activeElt()\\n  if (toUpdate > 4) { display.lineDiv.style.display = \\\"none\\\" }\\n  patchDisplay(cm, display.updateLineNumbers, update.dims)\\n  if (toUpdate > 4) { display.lineDiv.style.display = \\\"\\\" }\\n  display.renderedView = display.view\\n  // There might have been a widget with a focused element that got\\n  // hidden or updated, if so re-focus it.\\n  if (focused && activeElt() != focused && focused.offsetHeight) { focused.focus() }\\n\\n  // Prevent selection and cursors from interfering with the scroll\\n  // width and height.\\n  removeChildren(display.cursorDiv)\\n  removeChildren(display.selectionDiv)\\n  display.gutters.style.height = display.sizer.style.minHeight = 0\\n\\n  if (different) {\\n    display.lastWrapHeight = update.wrapperHeight\\n    display.lastWrapWidth = update.wrapperWidth\\n    startWorker(cm, 400)\\n  }\\n\\n  display.updateLineNumbers = null\\n\\n  return true\\n}\\n\\nfunction postUpdateDisplay(cm, update) {\\n  var viewport = update.viewport\\n\\n  for (var first = true;; first = false) {\\n    if (!first || !cm.options.lineWrapping || update.oldDisplayWidth == displayWidth(cm)) {\\n      // Clip forced viewport to actual scrollable area.\\n      if (viewport && viewport.top != null)\\n        { viewport = {top: Math.min(cm.doc.height + paddingVert(cm.display) - displayHeight(cm), viewport.top)} }\\n      // Updated line heights might result in the drawn area not\\n      // actually covering the viewport. Keep looping until it does.\\n      update.visible = visibleLines(cm.display, cm.doc, viewport)\\n      if (update.visible.from >= cm.display.viewFrom && update.visible.to <= cm.display.viewTo)\\n        { break }\\n    }\\n    if (!updateDisplayIfNeeded(cm, update)) { break }\\n    updateHeightsInViewport(cm)\\n    var barMeasure = measureForScrollbars(cm)\\n    updateSelection(cm)\\n    updateScrollbars(cm, barMeasure)\\n    setDocumentHeight(cm, barMeasure)\\n  }\\n\\n  update.signal(cm, \\\"update\\\", cm)\\n  if (cm.display.viewFrom != cm.display.reportedViewFrom || cm.display.viewTo != cm.display.reportedViewTo) {\\n    update.signal(cm, \\\"viewportChange\\\", cm, cm.display.viewFrom, cm.display.viewTo)\\n    cm.display.reportedViewFrom = cm.display.viewFrom; cm.display.reportedViewTo = cm.display.viewTo\\n  }\\n}\\n\\nfunction updateDisplaySimple(cm, viewport) {\\n  var update = new DisplayUpdate(cm, viewport)\\n  if (updateDisplayIfNeeded(cm, update)) {\\n    updateHeightsInViewport(cm)\\n    postUpdateDisplay(cm, update)\\n    var barMeasure = measureForScrollbars(cm)\\n    updateSelection(cm)\\n    updateScrollbars(cm, barMeasure)\\n    setDocumentHeight(cm, barMeasure)\\n    update.finish()\\n  }\\n}\\n\\n// Sync the actual display DOM structure with display.view, removing\\n// nodes for lines that are no longer in view, and creating the ones\\n// that are not there yet, and updating the ones that are out of\\n// date.\\nfunction patchDisplay(cm, updateNumbersFrom, dims) {\\n  var display = cm.display, lineNumbers = cm.options.lineNumbers\\n  var container = display.lineDiv, cur = container.firstChild\\n\\n  function rm(node) {\\n    var next = node.nextSibling\\n    // Works around a throw-scroll bug in OS X Webkit\\n    if (webkit && mac && cm.display.currentWheelTarget == node)\\n      { node.style.display = \\\"none\\\" }\\n    else\\n      { node.parentNode.removeChild(node) }\\n    return next\\n  }\\n\\n  var view = display.view, lineN = display.viewFrom\\n  // Loop over the elements in the view, syncing cur (the DOM nodes\\n  // in display.lineDiv) with the view as we go.\\n  for (var i = 0; i < view.length; i++) {\\n    var lineView = view[i]\\n    if (lineView.hidden) {\\n    } else if (!lineView.node || lineView.node.parentNode != container) { // Not drawn yet\\n      var node = buildLineElement(cm, lineView, lineN, dims)\\n      container.insertBefore(node, cur)\\n    } else { // Already drawn\\n      while (cur != lineView.node) { cur = rm(cur) }\\n      var updateNumber = lineNumbers && updateNumbersFrom != null &&\\n        updateNumbersFrom <= lineN && lineView.lineNumber\\n      if (lineView.changes) {\\n        if (indexOf(lineView.changes, \\\"gutter\\\") > -1) { updateNumber = false }\\n        updateLineForChanges(cm, lineView, lineN, dims)\\n      }\\n      if (updateNumber) {\\n        removeChildren(lineView.lineNumber)\\n        lineView.lineNumber.appendChild(document.createTextNode(lineNumberFor(cm.options, lineN)))\\n      }\\n      cur = lineView.node.nextSibling\\n    }\\n    lineN += lineView.size\\n  }\\n  while (cur) { cur = rm(cur) }\\n}\\n\\nfunction updateGutterSpace(cm) {\\n  var width = cm.display.gutters.offsetWidth\\n  cm.display.sizer.style.marginLeft = width + \\\"px\\\"\\n}\\n\\nfunction setDocumentHeight(cm, measure) {\\n  cm.display.sizer.style.minHeight = measure.docHeight + \\\"px\\\"\\n  cm.display.heightForcer.style.top = measure.docHeight + \\\"px\\\"\\n  cm.display.gutters.style.height = (measure.docHeight + cm.display.barHeight + scrollGap(cm)) + \\\"px\\\"\\n}\\n\\n// Rebuild the gutter elements, ensure the margin to the left of the\\n// code matches their width.\\nfunction updateGutters(cm) {\\n  var gutters = cm.display.gutters, specs = cm.options.gutters\\n  removeChildren(gutters)\\n  var i = 0\\n  for (; i < specs.length; ++i) {\\n    var gutterClass = specs[i]\\n    var gElt = gutters.appendChild(elt(\\\"div\\\", null, \\\"CodeMirror-gutter \\\" + gutterClass))\\n    if (gutterClass == \\\"CodeMirror-linenumbers\\\") {\\n      cm.display.lineGutter = gElt\\n      gElt.style.width = (cm.display.lineNumWidth || 1) + \\\"px\\\"\\n    }\\n  }\\n  gutters.style.display = i ? \\\"\\\" : \\\"none\\\"\\n  updateGutterSpace(cm)\\n}\\n\\n// Make sure the gutters options contains the element\\n// \\\"CodeMirror-linenumbers\\\" when the lineNumbers option is true.\\nfunction setGuttersForLineNumbers(options) {\\n  var found = indexOf(options.gutters, \\\"CodeMirror-linenumbers\\\")\\n  if (found == -1 && options.lineNumbers) {\\n    options.gutters = options.gutters.concat([\\\"CodeMirror-linenumbers\\\"])\\n  } else if (found > -1 && !options.lineNumbers) {\\n    options.gutters = options.gutters.slice(0)\\n    options.gutters.splice(found, 1)\\n  }\\n}\\n\\n// Selection objects are immutable. A new one is created every time\\n// the selection changes. A selection is one or more non-overlapping\\n// (and non-touching) ranges, sorted, and an integer that indicates\\n// which one is the primary selection (the one that's scrolled into\\n// view, that getCursor returns, etc).\\nfunction Selection(ranges, primIndex) {\\n  this.ranges = ranges\\n  this.primIndex = primIndex\\n}\\n\\nSelection.prototype = {\\n  primary: function() { return this.ranges[this.primIndex] },\\n  equals: function(other) {\\n    var this$1 = this;\\n\\n    if (other == this) { return true }\\n    if (other.primIndex != this.primIndex || other.ranges.length != this.ranges.length) { return false }\\n    for (var i = 0; i < this.ranges.length; i++) {\\n      var here = this$1.ranges[i], there = other.ranges[i]\\n      if (cmp(here.anchor, there.anchor) != 0 || cmp(here.head, there.head) != 0) { return false }\\n    }\\n    return true\\n  },\\n  deepCopy: function() {\\n    var this$1 = this;\\n\\n    var out = []\\n    for (var i = 0; i < this.ranges.length; i++)\\n      { out[i] = new Range(copyPos(this$1.ranges[i].anchor), copyPos(this$1.ranges[i].head)) }\\n    return new Selection(out, this.primIndex)\\n  },\\n  somethingSelected: function() {\\n    var this$1 = this;\\n\\n    for (var i = 0; i < this.ranges.length; i++)\\n      { if (!this$1.ranges[i].empty()) { return true } }\\n    return false\\n  },\\n  contains: function(pos, end) {\\n    var this$1 = this;\\n\\n    if (!end) { end = pos }\\n    for (var i = 0; i < this.ranges.length; i++) {\\n      var range = this$1.ranges[i]\\n      if (cmp(end, range.from()) >= 0 && cmp(pos, range.to()) <= 0)\\n        { return i }\\n    }\\n    return -1\\n  }\\n}\\n\\nfunction Range(anchor, head) {\\n  this.anchor = anchor; this.head = head\\n}\\n\\nRange.prototype = {\\n  from: function() { return minPos(this.anchor, this.head) },\\n  to: function() { return maxPos(this.anchor, this.head) },\\n  empty: function() {\\n    return this.head.line == this.anchor.line && this.head.ch == this.anchor.ch\\n  }\\n}\\n\\n// Take an unsorted, potentially overlapping set of ranges, and\\n// build a selection out of it. 'Consumes' ranges array (modifying\\n// it).\\nfunction normalizeSelection(ranges, primIndex) {\\n  var prim = ranges[primIndex]\\n  ranges.sort(function (a, b) { return cmp(a.from(), b.from()); })\\n  primIndex = indexOf(ranges, prim)\\n  for (var i = 1; i < ranges.length; i++) {\\n    var cur = ranges[i], prev = ranges[i - 1]\\n    if (cmp(prev.to(), cur.from()) >= 0) {\\n      var from = minPos(prev.from(), cur.from()), to = maxPos(prev.to(), cur.to())\\n      var inv = prev.empty() ? cur.from() == cur.head : prev.from() == prev.head\\n      if (i <= primIndex) { --primIndex }\\n      ranges.splice(--i, 2, new Range(inv ? to : from, inv ? from : to))\\n    }\\n  }\\n  return new Selection(ranges, primIndex)\\n}\\n\\nfunction simpleSelection(anchor, head) {\\n  return new Selection([new Range(anchor, head || anchor)], 0)\\n}\\n\\n// Compute the position of the end of a change (its 'to' property\\n// refers to the pre-change end).\\nfunction changeEnd(change) {\\n  if (!change.text) { return change.to }\\n  return Pos(change.from.line + change.text.length - 1,\\n             lst(change.text).length + (change.text.length == 1 ? change.from.ch : 0))\\n}\\n\\n// Adjust a position to refer to the post-change position of the\\n// same text, or the end of the change if the change covers it.\\nfunction adjustForChange(pos, change) {\\n  if (cmp(pos, change.from) < 0) { return pos }\\n  if (cmp(pos, change.to) <= 0) { return changeEnd(change) }\\n\\n  var line = pos.line + change.text.length - (change.to.line - change.from.line) - 1, ch = pos.ch\\n  if (pos.line == change.to.line) { ch += changeEnd(change).ch - change.to.ch }\\n  return Pos(line, ch)\\n}\\n\\nfunction computeSelAfterChange(doc, change) {\\n  var out = []\\n  for (var i = 0; i < doc.sel.ranges.length; i++) {\\n    var range = doc.sel.ranges[i]\\n    out.push(new Range(adjustForChange(range.anchor, change),\\n                       adjustForChange(range.head, change)))\\n  }\\n  return normalizeSelection(out, doc.sel.primIndex)\\n}\\n\\nfunction offsetPos(pos, old, nw) {\\n  if (pos.line == old.line)\\n    { return Pos(nw.line, pos.ch - old.ch + nw.ch) }\\n  else\\n    { return Pos(nw.line + (pos.line - old.line), pos.ch) }\\n}\\n\\n// Used by replaceSelections to allow moving the selection to the\\n// start or around the replaced test. Hint may be \\\"start\\\" or \\\"around\\\".\\nfunction computeReplacedSel(doc, changes, hint) {\\n  var out = []\\n  var oldPrev = Pos(doc.first, 0), newPrev = oldPrev\\n  for (var i = 0; i < changes.length; i++) {\\n    var change = changes[i]\\n    var from = offsetPos(change.from, oldPrev, newPrev)\\n    var to = offsetPos(changeEnd(change), oldPrev, newPrev)\\n    oldPrev = change.to\\n    newPrev = to\\n    if (hint == \\\"around\\\") {\\n      var range = doc.sel.ranges[i], inv = cmp(range.head, range.anchor) < 0\\n      out[i] = new Range(inv ? to : from, inv ? from : to)\\n    } else {\\n      out[i] = new Range(from, from)\\n    }\\n  }\\n  return new Selection(out, doc.sel.primIndex)\\n}\\n\\n// Used to get the editor into a consistent state again when options change.\\n\\nfunction loadMode(cm) {\\n  cm.doc.mode = getMode(cm.options, cm.doc.modeOption)\\n  resetModeState(cm)\\n}\\n\\nfunction resetModeState(cm) {\\n  cm.doc.iter(function (line) {\\n    if (line.stateAfter) { line.stateAfter = null }\\n    if (line.styles) { line.styles = null }\\n  })\\n  cm.doc.frontier = cm.doc.first\\n  startWorker(cm, 100)\\n  cm.state.modeGen++\\n  if (cm.curOp) { regChange(cm) }\\n}\\n\\n// DOCUMENT DATA STRUCTURE\\n\\n// By default, updates that start and end at the beginning of a line\\n// are treated specially, in order to make the association of line\\n// widgets and marker elements with the text behave more intuitive.\\nfunction isWholeLineUpdate(doc, change) {\\n  return change.from.ch == 0 && change.to.ch == 0 && lst(change.text) == \\\"\\\" &&\\n    (!doc.cm || doc.cm.options.wholeLineUpdateBefore)\\n}\\n\\n// Perform a change on the document data structure.\\nfunction updateDoc(doc, change, markedSpans, estimateHeight) {\\n  function spansFor(n) {return markedSpans ? markedSpans[n] : null}\\n  function update(line, text, spans) {\\n    updateLine(line, text, spans, estimateHeight)\\n    signalLater(line, \\\"change\\\", line, change)\\n  }\\n  function linesFor(start, end) {\\n    var result = []\\n    for (var i = start; i < end; ++i)\\n      { result.push(new Line(text[i], spansFor(i), estimateHeight)) }\\n    return result\\n  }\\n\\n  var from = change.from, to = change.to, text = change.text\\n  var firstLine = getLine(doc, from.line), lastLine = getLine(doc, to.line)\\n  var lastText = lst(text), lastSpans = spansFor(text.length - 1), nlines = to.line - from.line\\n\\n  // Adjust the line structure\\n  if (change.full) {\\n    doc.insert(0, linesFor(0, text.length))\\n    doc.remove(text.length, doc.size - text.length)\\n  } else if (isWholeLineUpdate(doc, change)) {\\n    // This is a whole-line replace. Treated specially to make\\n    // sure line objects move the way they are supposed to.\\n    var added = linesFor(0, text.length - 1)\\n    update(lastLine, lastLine.text, lastSpans)\\n    if (nlines) { doc.remove(from.line, nlines) }\\n    if (added.length) { doc.insert(from.line, added) }\\n  } else if (firstLine == lastLine) {\\n    if (text.length == 1) {\\n      update(firstLine, firstLine.text.slice(0, from.ch) + lastText + firstLine.text.slice(to.ch), lastSpans)\\n    } else {\\n      var added$1 = linesFor(1, text.length - 1)\\n      added$1.push(new Line(lastText + firstLine.text.slice(to.ch), lastSpans, estimateHeight))\\n      update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0))\\n      doc.insert(from.line + 1, added$1)\\n    }\\n  } else if (text.length == 1) {\\n    update(firstLine, firstLine.text.slice(0, from.ch) + text[0] + lastLine.text.slice(to.ch), spansFor(0))\\n    doc.remove(from.line + 1, nlines)\\n  } else {\\n    update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0))\\n    update(lastLine, lastText + lastLine.text.slice(to.ch), lastSpans)\\n    var added$2 = linesFor(1, text.length - 1)\\n    if (nlines > 1) { doc.remove(from.line + 1, nlines - 1) }\\n    doc.insert(from.line + 1, added$2)\\n  }\\n\\n  signalLater(doc, \\\"change\\\", doc, change)\\n}\\n\\n// Call f for all linked documents.\\nfunction linkedDocs(doc, f, sharedHistOnly) {\\n  function propagate(doc, skip, sharedHist) {\\n    if (doc.linked) { for (var i = 0; i < doc.linked.length; ++i) {\\n      var rel = doc.linked[i]\\n      if (rel.doc == skip) { continue }\\n      var shared = sharedHist && rel.sharedHist\\n      if (sharedHistOnly && !shared) { continue }\\n      f(rel.doc, shared)\\n      propagate(rel.doc, doc, shared)\\n    } }\\n  }\\n  propagate(doc, null, true)\\n}\\n\\n// Attach a document to an editor.\\nfunction attachDoc(cm, doc) {\\n  if (doc.cm) { throw new Error(\\\"This document is already in use.\\\") }\\n  cm.doc = doc\\n  doc.cm = cm\\n  estimateLineHeights(cm)\\n  loadMode(cm)\\n  if (!cm.options.lineWrapping) { findMaxLine(cm) }\\n  cm.options.mode = doc.modeOption\\n  regChange(cm)\\n}\\n\\nfunction History(startGen) {\\n  // Arrays of change events and selections. Doing something adds an\\n  // event to done and clears undo. Undoing moves events from done\\n  // to undone, redoing moves them in the other direction.\\n  this.done = []; this.undone = []\\n  this.undoDepth = Infinity\\n  // Used to track when changes can be merged into a single undo\\n  // event\\n  this.lastModTime = this.lastSelTime = 0\\n  this.lastOp = this.lastSelOp = null\\n  this.lastOrigin = this.lastSelOrigin = null\\n  // Used by the isClean() method\\n  this.generation = this.maxGeneration = startGen || 1\\n}\\n\\n// Create a history change event from an updateDoc-style change\\n// object.\\nfunction historyChangeFromChange(doc, change) {\\n  var histChange = {from: copyPos(change.from), to: changeEnd(change), text: getBetween(doc, change.from, change.to)}\\n  attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1)\\n  linkedDocs(doc, function (doc) { return attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1); }, true)\\n  return histChange\\n}\\n\\n// Pop all selection events off the end of a history array. Stop at\\n// a change event.\\nfunction clearSelectionEvents(array) {\\n  while (array.length) {\\n    var last = lst(array)\\n    if (last.ranges) { array.pop() }\\n    else { break }\\n  }\\n}\\n\\n// Find the top change event in the history. Pop off selection\\n// events that are in the way.\\nfunction lastChangeEvent(hist, force) {\\n  if (force) {\\n    clearSelectionEvents(hist.done)\\n    return lst(hist.done)\\n  } else if (hist.done.length && !lst(hist.done).ranges) {\\n    return lst(hist.done)\\n  } else if (hist.done.length > 1 && !hist.done[hist.done.length - 2].ranges) {\\n    hist.done.pop()\\n    return lst(hist.done)\\n  }\\n}\\n\\n// Register a change in the history. Merges changes that are within\\n// a single operation, or are close together with an origin that\\n// allows merging (starting with \\\"+\\\") into a single event.\\nfunction addChangeToHistory(doc, change, selAfter, opId) {\\n  var hist = doc.history\\n  hist.undone.length = 0\\n  var time = +new Date, cur\\n  var last\\n\\n  if ((hist.lastOp == opId ||\\n       hist.lastOrigin == change.origin && change.origin &&\\n       ((change.origin.charAt(0) == \\\"+\\\" && doc.cm && hist.lastModTime > time - doc.cm.options.historyEventDelay) ||\\n        change.origin.charAt(0) == \\\"*\\\")) &&\\n      (cur = lastChangeEvent(hist, hist.lastOp == opId))) {\\n    // Merge this change into the last event\\n    last = lst(cur.changes)\\n    if (cmp(change.from, change.to) == 0 && cmp(change.from, last.to) == 0) {\\n      // Optimized case for simple insertion -- don't want to add\\n      // new changesets for every character typed\\n      last.to = changeEnd(change)\\n    } else {\\n      // Add new sub-event\\n      cur.changes.push(historyChangeFromChange(doc, change))\\n    }\\n  } else {\\n    // Can not be merged, start a new event.\\n    var before = lst(hist.done)\\n    if (!before || !before.ranges)\\n      { pushSelectionToHistory(doc.sel, hist.done) }\\n    cur = {changes: [historyChangeFromChange(doc, change)],\\n           generation: hist.generation}\\n    hist.done.push(cur)\\n    while (hist.done.length > hist.undoDepth) {\\n      hist.done.shift()\\n      if (!hist.done[0].ranges) { hist.done.shift() }\\n    }\\n  }\\n  hist.done.push(selAfter)\\n  hist.generation = ++hist.maxGeneration\\n  hist.lastModTime = hist.lastSelTime = time\\n  hist.lastOp = hist.lastSelOp = opId\\n  hist.lastOrigin = hist.lastSelOrigin = change.origin\\n\\n  if (!last) { signal(doc, \\\"historyAdded\\\") }\\n}\\n\\nfunction selectionEventCanBeMerged(doc, origin, prev, sel) {\\n  var ch = origin.charAt(0)\\n  return ch == \\\"*\\\" ||\\n    ch == \\\"+\\\" &&\\n    prev.ranges.length == sel.ranges.length &&\\n    prev.somethingSelected() == sel.somethingSelected() &&\\n    new Date - doc.history.lastSelTime <= (doc.cm ? doc.cm.options.historyEventDelay : 500)\\n}\\n\\n// Called whenever the selection changes, sets the new selection as\\n// the pending selection in the history, and pushes the old pending\\n// selection into the 'done' array when it was significantly\\n// different (in number of selected ranges, emptiness, or time).\\nfunction addSelectionToHistory(doc, sel, opId, options) {\\n  var hist = doc.history, origin = options && options.origin\\n\\n  // A new event is started when the previous origin does not match\\n  // the current, or the origins don't allow matching. Origins\\n  // starting with * are always merged, those starting with + are\\n  // merged when similar and close together in time.\\n  if (opId == hist.lastSelOp ||\\n      (origin && hist.lastSelOrigin == origin &&\\n       (hist.lastModTime == hist.lastSelTime && hist.lastOrigin == origin ||\\n        selectionEventCanBeMerged(doc, origin, lst(hist.done), sel))))\\n    { hist.done[hist.done.length - 1] = sel }\\n  else\\n    { pushSelectionToHistory(sel, hist.done) }\\n\\n  hist.lastSelTime = +new Date\\n  hist.lastSelOrigin = origin\\n  hist.lastSelOp = opId\\n  if (options && options.clearRedo !== false)\\n    { clearSelectionEvents(hist.undone) }\\n}\\n\\nfunction pushSelectionToHistory(sel, dest) {\\n  var top = lst(dest)\\n  if (!(top && top.ranges && top.equals(sel)))\\n    { dest.push(sel) }\\n}\\n\\n// Used to store marked span information in the history.\\nfunction attachLocalSpans(doc, change, from, to) {\\n  var existing = change[\\\"spans_\\\" + doc.id], n = 0\\n  doc.iter(Math.max(doc.first, from), Math.min(doc.first + doc.size, to), function (line) {\\n    if (line.markedSpans)\\n      { (existing || (existing = change[\\\"spans_\\\" + doc.id] = {}))[n] = line.markedSpans }\\n    ++n\\n  })\\n}\\n\\n// When un/re-doing restores text containing marked spans, those\\n// that have been explicitly cleared should not be restored.\\nfunction removeClearedSpans(spans) {\\n  if (!spans) { return null }\\n  var out\\n  for (var i = 0; i < spans.length; ++i) {\\n    if (spans[i].marker.explicitlyCleared) { if (!out) { out = spans.slice(0, i) } }\\n    else if (out) { out.push(spans[i]) }\\n  }\\n  return !out ? spans : out.length ? out : null\\n}\\n\\n// Retrieve and filter the old marked spans stored in a change event.\\nfunction getOldSpans(doc, change) {\\n  var found = change[\\\"spans_\\\" + doc.id]\\n  if (!found) { return null }\\n  var nw = []\\n  for (var i = 0; i < change.text.length; ++i)\\n    { nw.push(removeClearedSpans(found[i])) }\\n  return nw\\n}\\n\\n// Used for un/re-doing changes from the history. Combines the\\n// result of computing the existing spans with the set of spans that\\n// existed in the history (so that deleting around a span and then\\n// undoing brings back the span).\\nfunction mergeOldSpans(doc, change) {\\n  var old = getOldSpans(doc, change)\\n  var stretched = stretchSpansOverChange(doc, change)\\n  if (!old) { return stretched }\\n  if (!stretched) { return old }\\n\\n  for (var i = 0; i < old.length; ++i) {\\n    var oldCur = old[i], stretchCur = stretched[i]\\n    if (oldCur && stretchCur) {\\n      spans: for (var j = 0; j < stretchCur.length; ++j) {\\n        var span = stretchCur[j]\\n        for (var k = 0; k < oldCur.length; ++k)\\n          { if (oldCur[k].marker == span.marker) { continue spans } }\\n        oldCur.push(span)\\n      }\\n    } else if (stretchCur) {\\n      old[i] = stretchCur\\n    }\\n  }\\n  return old\\n}\\n\\n// Used both to provide a JSON-safe object in .getHistory, and, when\\n// detaching a document, to split the history in two\\nfunction copyHistoryArray(events, newGroup, instantiateSel) {\\n  var copy = []\\n  for (var i = 0; i < events.length; ++i) {\\n    var event = events[i]\\n    if (event.ranges) {\\n      copy.push(instantiateSel ? Selection.prototype.deepCopy.call(event) : event)\\n      continue\\n    }\\n    var changes = event.changes, newChanges = []\\n    copy.push({changes: newChanges})\\n    for (var j = 0; j < changes.length; ++j) {\\n      var change = changes[j], m = void 0\\n      newChanges.push({from: change.from, to: change.to, text: change.text})\\n      if (newGroup) { for (var prop in change) { if (m = prop.match(/^spans_(\\\\d+)$/)) {\\n        if (indexOf(newGroup, Number(m[1])) > -1) {\\n          lst(newChanges)[prop] = change[prop]\\n          delete change[prop]\\n        }\\n      } } }\\n    }\\n  }\\n  return copy\\n}\\n\\n// The 'scroll' parameter given to many of these indicated whether\\n// the new cursor position should be scrolled into view after\\n// modifying the selection.\\n\\n// If shift is held or the extend flag is set, extends a range to\\n// include a given position (and optionally a second position).\\n// Otherwise, simply returns the range between the given positions.\\n// Used for cursor motion and such.\\nfunction extendRange(doc, range, head, other) {\\n  if (doc.cm && doc.cm.display.shift || doc.extend) {\\n    var anchor = range.anchor\\n    if (other) {\\n      var posBefore = cmp(head, anchor) < 0\\n      if (posBefore != (cmp(other, anchor) < 0)) {\\n        anchor = head\\n        head = other\\n      } else if (posBefore != (cmp(head, other) < 0)) {\\n        head = other\\n      }\\n    }\\n    return new Range(anchor, head)\\n  } else {\\n    return new Range(other || head, head)\\n  }\\n}\\n\\n// Extend the primary selection range, discard the rest.\\nfunction extendSelection(doc, head, other, options) {\\n  setSelection(doc, new Selection([extendRange(doc, doc.sel.primary(), head, other)], 0), options)\\n}\\n\\n// Extend all selections (pos is an array of selections with length\\n// equal the number of selections)\\nfunction extendSelections(doc, heads, options) {\\n  var out = []\\n  for (var i = 0; i < doc.sel.ranges.length; i++)\\n    { out[i] = extendRange(doc, doc.sel.ranges[i], heads[i], null) }\\n  var newSel = normalizeSelection(out, doc.sel.primIndex)\\n  setSelection(doc, newSel, options)\\n}\\n\\n// Updates a single range in the selection.\\nfunction replaceOneSelection(doc, i, range, options) {\\n  var ranges = doc.sel.ranges.slice(0)\\n  ranges[i] = range\\n  setSelection(doc, normalizeSelection(ranges, doc.sel.primIndex), options)\\n}\\n\\n// Reset the selection to a single range.\\nfunction setSimpleSelection(doc, anchor, head, options) {\\n  setSelection(doc, simpleSelection(anchor, head), options)\\n}\\n\\n// Give beforeSelectionChange handlers a change to influence a\\n// selection update.\\nfunction filterSelectionChange(doc, sel, options) {\\n  var obj = {\\n    ranges: sel.ranges,\\n    update: function(ranges) {\\n      var this$1 = this;\\n\\n      this.ranges = []\\n      for (var i = 0; i < ranges.length; i++)\\n        { this$1.ranges[i] = new Range(clipPos(doc, ranges[i].anchor),\\n                                   clipPos(doc, ranges[i].head)) }\\n    },\\n    origin: options && options.origin\\n  }\\n  signal(doc, \\\"beforeSelectionChange\\\", doc, obj)\\n  if (doc.cm) { signal(doc.cm, \\\"beforeSelectionChange\\\", doc.cm, obj) }\\n  if (obj.ranges != sel.ranges) { return normalizeSelection(obj.ranges, obj.ranges.length - 1) }\\n  else { return sel }\\n}\\n\\nfunction setSelectionReplaceHistory(doc, sel, options) {\\n  var done = doc.history.done, last = lst(done)\\n  if (last && last.ranges) {\\n    done[done.length - 1] = sel\\n    setSelectionNoUndo(doc, sel, options)\\n  } else {\\n    setSelection(doc, sel, options)\\n  }\\n}\\n\\n// Set a new selection.\\nfunction setSelection(doc, sel, options) {\\n  setSelectionNoUndo(doc, sel, options)\\n  addSelectionToHistory(doc, doc.sel, doc.cm ? doc.cm.curOp.id : NaN, options)\\n}\\n\\nfunction setSelectionNoUndo(doc, sel, options) {\\n  if (hasHandler(doc, \\\"beforeSelectionChange\\\") || doc.cm && hasHandler(doc.cm, \\\"beforeSelectionChange\\\"))\\n    { sel = filterSelectionChange(doc, sel, options) }\\n\\n  var bias = options && options.bias ||\\n    (cmp(sel.primary().head, doc.sel.primary().head) < 0 ? -1 : 1)\\n  setSelectionInner(doc, skipAtomicInSelection(doc, sel, bias, true))\\n\\n  if (!(options && options.scroll === false) && doc.cm)\\n    { ensureCursorVisible(doc.cm) }\\n}\\n\\nfunction setSelectionInner(doc, sel) {\\n  if (sel.equals(doc.sel)) { return }\\n\\n  doc.sel = sel\\n\\n  if (doc.cm) {\\n    doc.cm.curOp.updateInput = doc.cm.curOp.selectionChanged = true\\n    signalCursorActivity(doc.cm)\\n  }\\n  signalLater(doc, \\\"cursorActivity\\\", doc)\\n}\\n\\n// Verify that the selection does not partially select any atomic\\n// marked ranges.\\nfunction reCheckSelection(doc) {\\n  setSelectionInner(doc, skipAtomicInSelection(doc, doc.sel, null, false), sel_dontScroll)\\n}\\n\\n// Return a selection that does not partially select any atomic\\n// ranges.\\nfunction skipAtomicInSelection(doc, sel, bias, mayClear) {\\n  var out\\n  for (var i = 0; i < sel.ranges.length; i++) {\\n    var range = sel.ranges[i]\\n    var old = sel.ranges.length == doc.sel.ranges.length && doc.sel.ranges[i]\\n    var newAnchor = skipAtomic(doc, range.anchor, old && old.anchor, bias, mayClear)\\n    var newHead = skipAtomic(doc, range.head, old && old.head, bias, mayClear)\\n    if (out || newAnchor != range.anchor || newHead != range.head) {\\n      if (!out) { out = sel.ranges.slice(0, i) }\\n      out[i] = new Range(newAnchor, newHead)\\n    }\\n  }\\n  return out ? normalizeSelection(out, sel.primIndex) : sel\\n}\\n\\nfunction skipAtomicInner(doc, pos, oldPos, dir, mayClear) {\\n  var line = getLine(doc, pos.line)\\n  if (line.markedSpans) { for (var i = 0; i < line.markedSpans.length; ++i) {\\n    var sp = line.markedSpans[i], m = sp.marker\\n    if ((sp.from == null || (m.inclusiveLeft ? sp.from <= pos.ch : sp.from < pos.ch)) &&\\n        (sp.to == null || (m.inclusiveRight ? sp.to >= pos.ch : sp.to > pos.ch))) {\\n      if (mayClear) {\\n        signal(m, \\\"beforeCursorEnter\\\")\\n        if (m.explicitlyCleared) {\\n          if (!line.markedSpans) { break }\\n          else {--i; continue}\\n        }\\n      }\\n      if (!m.atomic) { continue }\\n\\n      if (oldPos) {\\n        var near = m.find(dir < 0 ? 1 : -1), diff = void 0\\n        if (dir < 0 ? m.inclusiveRight : m.inclusiveLeft)\\n          { near = movePos(doc, near, -dir, near && near.line == pos.line ? line : null) }\\n        if (near && near.line == pos.line && (diff = cmp(near, oldPos)) && (dir < 0 ? diff < 0 : diff > 0))\\n          { return skipAtomicInner(doc, near, pos, dir, mayClear) }\\n      }\\n\\n      var far = m.find(dir < 0 ? -1 : 1)\\n      if (dir < 0 ? m.inclusiveLeft : m.inclusiveRight)\\n        { far = movePos(doc, far, dir, far.line == pos.line ? line : null) }\\n      return far ? skipAtomicInner(doc, far, pos, dir, mayClear) : null\\n    }\\n  } }\\n  return pos\\n}\\n\\n// Ensure a given position is not inside an atomic range.\\nfunction skipAtomic(doc, pos, oldPos, bias, mayClear) {\\n  var dir = bias || 1\\n  var found = skipAtomicInner(doc, pos, oldPos, dir, mayClear) ||\\n      (!mayClear && skipAtomicInner(doc, pos, oldPos, dir, true)) ||\\n      skipAtomicInner(doc, pos, oldPos, -dir, mayClear) ||\\n      (!mayClear && skipAtomicInner(doc, pos, oldPos, -dir, true))\\n  if (!found) {\\n    doc.cantEdit = true\\n    return Pos(doc.first, 0)\\n  }\\n  return found\\n}\\n\\nfunction movePos(doc, pos, dir, line) {\\n  if (dir < 0 && pos.ch == 0) {\\n    if (pos.line > doc.first) { return clipPos(doc, Pos(pos.line - 1)) }\\n    else { return null }\\n  } else if (dir > 0 && pos.ch == (line || getLine(doc, pos.line)).text.length) {\\n    if (pos.line < doc.first + doc.size - 1) { return Pos(pos.line + 1, 0) }\\n    else { return null }\\n  } else {\\n    return new Pos(pos.line, pos.ch + dir)\\n  }\\n}\\n\\nfunction selectAll(cm) {\\n  cm.setSelection(Pos(cm.firstLine(), 0), Pos(cm.lastLine()), sel_dontScroll)\\n}\\n\\n// UPDATING\\n\\n// Allow \\\"beforeChange\\\" event handlers to influence a change\\nfunction filterChange(doc, change, update) {\\n  var obj = {\\n    canceled: false,\\n    from: change.from,\\n    to: change.to,\\n    text: change.text,\\n    origin: change.origin,\\n    cancel: function () { return obj.canceled = true; }\\n  }\\n  if (update) { obj.update = function (from, to, text, origin) {\\n    if (from) { obj.from = clipPos(doc, from) }\\n    if (to) { obj.to = clipPos(doc, to) }\\n    if (text) { obj.text = text }\\n    if (origin !== undefined) { obj.origin = origin }\\n  } }\\n  signal(doc, \\\"beforeChange\\\", doc, obj)\\n  if (doc.cm) { signal(doc.cm, \\\"beforeChange\\\", doc.cm, obj) }\\n\\n  if (obj.canceled) { return null }\\n  return {from: obj.from, to: obj.to, text: obj.text, origin: obj.origin}\\n}\\n\\n// Apply a change to a document, and add it to the document's\\n// history, and propagating it to all linked documents.\\nfunction makeChange(doc, change, ignoreReadOnly) {\\n  if (doc.cm) {\\n    if (!doc.cm.curOp) { return operation(doc.cm, makeChange)(doc, change, ignoreReadOnly) }\\n    if (doc.cm.state.suppressEdits) { return }\\n  }\\n\\n  if (hasHandler(doc, \\\"beforeChange\\\") || doc.cm && hasHandler(doc.cm, \\\"beforeChange\\\")) {\\n    change = filterChange(doc, change, true)\\n    if (!change) { return }\\n  }\\n\\n  // Possibly split or suppress the update based on the presence\\n  // of read-only spans in its range.\\n  var split = sawReadOnlySpans && !ignoreReadOnly && removeReadOnlyRanges(doc, change.from, change.to)\\n  if (split) {\\n    for (var i = split.length - 1; i >= 0; --i)\\n      { makeChangeInner(doc, {from: split[i].from, to: split[i].to, text: i ? [\\\"\\\"] : change.text}) }\\n  } else {\\n    makeChangeInner(doc, change)\\n  }\\n}\\n\\nfunction makeChangeInner(doc, change) {\\n  if (change.text.length == 1 && change.text[0] == \\\"\\\" && cmp(change.from, change.to) == 0) { return }\\n  var selAfter = computeSelAfterChange(doc, change)\\n  addChangeToHistory(doc, change, selAfter, doc.cm ? doc.cm.curOp.id : NaN)\\n\\n  makeChangeSingleDoc(doc, change, selAfter, stretchSpansOverChange(doc, change))\\n  var rebased = []\\n\\n  linkedDocs(doc, function (doc, sharedHist) {\\n    if (!sharedHist && indexOf(rebased, doc.history) == -1) {\\n      rebaseHist(doc.history, change)\\n      rebased.push(doc.history)\\n    }\\n    makeChangeSingleDoc(doc, change, null, stretchSpansOverChange(doc, change))\\n  })\\n}\\n\\n// Revert a change stored in a document's history.\\nfunction makeChangeFromHistory(doc, type, allowSelectionOnly) {\\n  if (doc.cm && doc.cm.state.suppressEdits && !allowSelectionOnly) { return }\\n\\n  var hist = doc.history, event, selAfter = doc.sel\\n  var source = type == \\\"undo\\\" ? hist.done : hist.undone, dest = type == \\\"undo\\\" ? hist.undone : hist.done\\n\\n  // Verify that there is a useable event (so that ctrl-z won't\\n  // needlessly clear selection events)\\n  var i = 0\\n  for (; i < source.length; i++) {\\n    event = source[i]\\n    if (allowSelectionOnly ? event.ranges && !event.equals(doc.sel) : !event.ranges)\\n      { break }\\n  }\\n  if (i == source.length) { return }\\n  hist.lastOrigin = hist.lastSelOrigin = null\\n\\n  for (;;) {\\n    event = source.pop()\\n    if (event.ranges) {\\n      pushSelectionToHistory(event, dest)\\n      if (allowSelectionOnly && !event.equals(doc.sel)) {\\n        setSelection(doc, event, {clearRedo: false})\\n        return\\n      }\\n      selAfter = event\\n    }\\n    else { break }\\n  }\\n\\n  // Build up a reverse change object to add to the opposite history\\n  // stack (redo when undoing, and vice versa).\\n  var antiChanges = []\\n  pushSelectionToHistory(selAfter, dest)\\n  dest.push({changes: antiChanges, generation: hist.generation})\\n  hist.generation = event.generation || ++hist.maxGeneration\\n\\n  var filter = hasHandler(doc, \\\"beforeChange\\\") || doc.cm && hasHandler(doc.cm, \\\"beforeChange\\\")\\n\\n  var loop = function ( i ) {\\n    var change = event.changes[i]\\n    change.origin = type\\n    if (filter && !filterChange(doc, change, false)) {\\n      source.length = 0\\n      return {}\\n    }\\n\\n    antiChanges.push(historyChangeFromChange(doc, change))\\n\\n    var after = i ? computeSelAfterChange(doc, change) : lst(source)\\n    makeChangeSingleDoc(doc, change, after, mergeOldSpans(doc, change))\\n    if (!i && doc.cm) { doc.cm.scrollIntoView({from: change.from, to: changeEnd(change)}) }\\n    var rebased = []\\n\\n    // Propagate to the linked documents\\n    linkedDocs(doc, function (doc, sharedHist) {\\n      if (!sharedHist && indexOf(rebased, doc.history) == -1) {\\n        rebaseHist(doc.history, change)\\n        rebased.push(doc.history)\\n      }\\n      makeChangeSingleDoc(doc, change, null, mergeOldSpans(doc, change))\\n    })\\n  };\\n\\n  for (var i$1 = event.changes.length - 1; i$1 >= 0; --i$1) {\\n    var returned = loop( i$1 );\\n\\n    if ( returned ) return returned.v;\\n  }\\n}\\n\\n// Sub-views need their line numbers shifted when text is added\\n// above or below them in the parent document.\\nfunction shiftDoc(doc, distance) {\\n  if (distance == 0) { return }\\n  doc.first += distance\\n  doc.sel = new Selection(map(doc.sel.ranges, function (range) { return new Range(\\n    Pos(range.anchor.line + distance, range.anchor.ch),\\n    Pos(range.head.line + distance, range.head.ch)\\n  ); }), doc.sel.primIndex)\\n  if (doc.cm) {\\n    regChange(doc.cm, doc.first, doc.first - distance, distance)\\n    for (var d = doc.cm.display, l = d.viewFrom; l < d.viewTo; l++)\\n      { regLineChange(doc.cm, l, \\\"gutter\\\") }\\n  }\\n}\\n\\n// More lower-level change function, handling only a single document\\n// (not linked ones).\\nfunction makeChangeSingleDoc(doc, change, selAfter, spans) {\\n  if (doc.cm && !doc.cm.curOp)\\n    { return operation(doc.cm, makeChangeSingleDoc)(doc, change, selAfter, spans) }\\n\\n  if (change.to.line < doc.first) {\\n    shiftDoc(doc, change.text.length - 1 - (change.to.line - change.from.line))\\n    return\\n  }\\n  if (change.from.line > doc.lastLine()) { return }\\n\\n  // Clip the change to the size of this doc\\n  if (change.from.line < doc.first) {\\n    var shift = change.text.length - 1 - (doc.first - change.from.line)\\n    shiftDoc(doc, shift)\\n    change = {from: Pos(doc.first, 0), to: Pos(change.to.line + shift, change.to.ch),\\n              text: [lst(change.text)], origin: change.origin}\\n  }\\n  var last = doc.lastLine()\\n  if (change.to.line > last) {\\n    change = {from: change.from, to: Pos(last, getLine(doc, last).text.length),\\n              text: [change.text[0]], origin: change.origin}\\n  }\\n\\n  change.removed = getBetween(doc, change.from, change.to)\\n\\n  if (!selAfter) { selAfter = computeSelAfterChange(doc, change) }\\n  if (doc.cm) { makeChangeSingleDocInEditor(doc.cm, change, spans) }\\n  else { updateDoc(doc, change, spans) }\\n  setSelectionNoUndo(doc, selAfter, sel_dontScroll)\\n}\\n\\n// Handle the interaction of a change to a document with the editor\\n// that this document is part of.\\nfunction makeChangeSingleDocInEditor(cm, change, spans) {\\n  var doc = cm.doc, display = cm.display, from = change.from, to = change.to\\n\\n  var recomputeMaxLength = false, checkWidthStart = from.line\\n  if (!cm.options.lineWrapping) {\\n    checkWidthStart = lineNo(visualLine(getLine(doc, from.line)))\\n    doc.iter(checkWidthStart, to.line + 1, function (line) {\\n      if (line == display.maxLine) {\\n        recomputeMaxLength = true\\n        return true\\n      }\\n    })\\n  }\\n\\n  if (doc.sel.contains(change.from, change.to) > -1)\\n    { signalCursorActivity(cm) }\\n\\n  updateDoc(doc, change, spans, estimateHeight(cm))\\n\\n  if (!cm.options.lineWrapping) {\\n    doc.iter(checkWidthStart, from.line + change.text.length, function (line) {\\n      var len = lineLength(line)\\n      if (len > display.maxLineLength) {\\n        display.maxLine = line\\n        display.maxLineLength = len\\n        display.maxLineChanged = true\\n        recomputeMaxLength = false\\n      }\\n    })\\n    if (recomputeMaxLength) { cm.curOp.updateMaxLine = true }\\n  }\\n\\n  // Adjust frontier, schedule worker\\n  doc.frontier = Math.min(doc.frontier, from.line)\\n  startWorker(cm, 400)\\n\\n  var lendiff = change.text.length - (to.line - from.line) - 1\\n  // Remember that these lines changed, for updating the display\\n  if (change.full)\\n    { regChange(cm) }\\n  else if (from.line == to.line && change.text.length == 1 && !isWholeLineUpdate(cm.doc, change))\\n    { regLineChange(cm, from.line, \\\"text\\\") }\\n  else\\n    { regChange(cm, from.line, to.line + 1, lendiff) }\\n\\n  var changesHandler = hasHandler(cm, \\\"changes\\\"), changeHandler = hasHandler(cm, \\\"change\\\")\\n  if (changeHandler || changesHandler) {\\n    var obj = {\\n      from: from, to: to,\\n      text: change.text,\\n      removed: change.removed,\\n      origin: change.origin\\n    }\\n    if (changeHandler) { signalLater(cm, \\\"change\\\", cm, obj) }\\n    if (changesHandler) { (cm.curOp.changeObjs || (cm.curOp.changeObjs = [])).push(obj) }\\n  }\\n  cm.display.selForContextMenu = null\\n}\\n\\nfunction replaceRange(doc, code, from, to, origin) {\\n  if (!to) { to = from }\\n  if (cmp(to, from) < 0) { var tmp = to; to = from; from = tmp }\\n  if (typeof code == \\\"string\\\") { code = doc.splitLines(code) }\\n  makeChange(doc, {from: from, to: to, text: code, origin: origin})\\n}\\n\\n// Rebasing/resetting history to deal with externally-sourced changes\\n\\nfunction rebaseHistSelSingle(pos, from, to, diff) {\\n  if (to < pos.line) {\\n    pos.line += diff\\n  } else if (from < pos.line) {\\n    pos.line = from\\n    pos.ch = 0\\n  }\\n}\\n\\n// Tries to rebase an array of history events given a change in the\\n// document. If the change touches the same lines as the event, the\\n// event, and everything 'behind' it, is discarded. If the change is\\n// before the event, the event's positions are updated. Uses a\\n// copy-on-write scheme for the positions, to avoid having to\\n// reallocate them all on every rebase, but also avoid problems with\\n// shared position objects being unsafely updated.\\nfunction rebaseHistArray(array, from, to, diff) {\\n  for (var i = 0; i < array.length; ++i) {\\n    var sub = array[i], ok = true\\n    if (sub.ranges) {\\n      if (!sub.copied) { sub = array[i] = sub.deepCopy(); sub.copied = true }\\n      for (var j = 0; j < sub.ranges.length; j++) {\\n        rebaseHistSelSingle(sub.ranges[j].anchor, from, to, diff)\\n        rebaseHistSelSingle(sub.ranges[j].head, from, to, diff)\\n      }\\n      continue\\n    }\\n    for (var j$1 = 0; j$1 < sub.changes.length; ++j$1) {\\n      var cur = sub.changes[j$1]\\n      if (to < cur.from.line) {\\n        cur.from = Pos(cur.from.line + diff, cur.from.ch)\\n        cur.to = Pos(cur.to.line + diff, cur.to.ch)\\n      } else if (from <= cur.to.line) {\\n        ok = false\\n        break\\n      }\\n    }\\n    if (!ok) {\\n      array.splice(0, i + 1)\\n      i = 0\\n    }\\n  }\\n}\\n\\nfunction rebaseHist(hist, change) {\\n  var from = change.from.line, to = change.to.line, diff = change.text.length - (to - from) - 1\\n  rebaseHistArray(hist.done, from, to, diff)\\n  rebaseHistArray(hist.undone, from, to, diff)\\n}\\n\\n// Utility for applying a change to a line by handle or number,\\n// returning the number and optionally registering the line as\\n// changed.\\nfunction changeLine(doc, handle, changeType, op) {\\n  var no = handle, line = handle\\n  if (typeof handle == \\\"number\\\") { line = getLine(doc, clipLine(doc, handle)) }\\n  else { no = lineNo(handle) }\\n  if (no == null) { return null }\\n  if (op(line, no) && doc.cm) { regLineChange(doc.cm, no, changeType) }\\n  return line\\n}\\n\\n// The document is represented as a BTree consisting of leaves, with\\n// chunk of lines in them, and branches, with up to ten leaves or\\n// other branch nodes below them. The top node is always a branch\\n// node, and is the document object itself (meaning it has\\n// additional methods and properties).\\n//\\n// All nodes have parent links. The tree is used both to go from\\n// line numbers to line objects, and to go from objects to numbers.\\n// It also indexes by height, and is used to convert between height\\n// and line object, and to find the total height of the document.\\n//\\n// See also http://marijnhaverbeke.nl/blog/codemirror-line-tree.html\\n\\nfunction LeafChunk(lines) {\\n  var this$1 = this;\\n\\n  this.lines = lines\\n  this.parent = null\\n  var height = 0\\n  for (var i = 0; i < lines.length; ++i) {\\n    lines[i].parent = this$1\\n    height += lines[i].height\\n  }\\n  this.height = height\\n}\\n\\nLeafChunk.prototype = {\\n  chunkSize: function() { return this.lines.length },\\n  // Remove the n lines at offset 'at'.\\n  removeInner: function(at, n) {\\n    var this$1 = this;\\n\\n    for (var i = at, e = at + n; i < e; ++i) {\\n      var line = this$1.lines[i]\\n      this$1.height -= line.height\\n      cleanUpLine(line)\\n      signalLater(line, \\\"delete\\\")\\n    }\\n    this.lines.splice(at, n)\\n  },\\n  // Helper used to collapse a small branch into a single leaf.\\n  collapse: function(lines) {\\n    lines.push.apply(lines, this.lines)\\n  },\\n  // Insert the given array of lines at offset 'at', count them as\\n  // having the given height.\\n  insertInner: function(at, lines, height) {\\n    var this$1 = this;\\n\\n    this.height += height\\n    this.lines = this.lines.slice(0, at).concat(lines).concat(this.lines.slice(at))\\n    for (var i = 0; i < lines.length; ++i) { lines[i].parent = this$1 }\\n  },\\n  // Used to iterate over a part of the tree.\\n  iterN: function(at, n, op) {\\n    var this$1 = this;\\n\\n    for (var e = at + n; at < e; ++at)\\n      { if (op(this$1.lines[at])) { return true } }\\n  }\\n}\\n\\nfunction BranchChunk(children) {\\n  var this$1 = this;\\n\\n  this.children = children\\n  var size = 0, height = 0\\n  for (var i = 0; i < children.length; ++i) {\\n    var ch = children[i]\\n    size += ch.chunkSize(); height += ch.height\\n    ch.parent = this$1\\n  }\\n  this.size = size\\n  this.height = height\\n  this.parent = null\\n}\\n\\nBranchChunk.prototype = {\\n  chunkSize: function() { return this.size },\\n  removeInner: function(at, n) {\\n    var this$1 = this;\\n\\n    this.size -= n\\n    for (var i = 0; i < this.children.length; ++i) {\\n      var child = this$1.children[i], sz = child.chunkSize()\\n      if (at < sz) {\\n        var rm = Math.min(n, sz - at), oldHeight = child.height\\n        child.removeInner(at, rm)\\n        this$1.height -= oldHeight - child.height\\n        if (sz == rm) { this$1.children.splice(i--, 1); child.parent = null }\\n        if ((n -= rm) == 0) { break }\\n        at = 0\\n      } else { at -= sz }\\n    }\\n    // If the result is smaller than 25 lines, ensure that it is a\\n    // single leaf node.\\n    if (this.size - n < 25 &&\\n        (this.children.length > 1 || !(this.children[0] instanceof LeafChunk))) {\\n      var lines = []\\n      this.collapse(lines)\\n      this.children = [new LeafChunk(lines)]\\n      this.children[0].parent = this\\n    }\\n  },\\n  collapse: function(lines) {\\n    var this$1 = this;\\n\\n    for (var i = 0; i < this.children.length; ++i) { this$1.children[i].collapse(lines) }\\n  },\\n  insertInner: function(at, lines, height) {\\n    var this$1 = this;\\n\\n    this.size += lines.length\\n    this.height += height\\n    for (var i = 0; i < this.children.length; ++i) {\\n      var child = this$1.children[i], sz = child.chunkSize()\\n      if (at <= sz) {\\n        child.insertInner(at, lines, height)\\n        if (child.lines && child.lines.length > 50) {\\n          // To avoid memory thrashing when child.lines is huge (e.g. first view of a large file), it's never spliced.\\n          // Instead, small slices are taken. They're taken in order because sequential memory accesses are fastest.\\n          var remaining = child.lines.length % 25 + 25\\n          for (var pos = remaining; pos < child.lines.length;) {\\n            var leaf = new LeafChunk(child.lines.slice(pos, pos += 25))\\n            child.height -= leaf.height\\n            this$1.children.splice(++i, 0, leaf)\\n            leaf.parent = this$1\\n          }\\n          child.lines = child.lines.slice(0, remaining)\\n          this$1.maybeSpill()\\n        }\\n        break\\n      }\\n      at -= sz\\n    }\\n  },\\n  // When a node has grown, check whether it should be split.\\n  maybeSpill: function() {\\n    if (this.children.length <= 10) { return }\\n    var me = this\\n    do {\\n      var spilled = me.children.splice(me.children.length - 5, 5)\\n      var sibling = new BranchChunk(spilled)\\n      if (!me.parent) { // Become the parent node\\n        var copy = new BranchChunk(me.children)\\n        copy.parent = me\\n        me.children = [copy, sibling]\\n        me = copy\\n     } else {\\n        me.size -= sibling.size\\n        me.height -= sibling.height\\n        var myIndex = indexOf(me.parent.children, me)\\n        me.parent.children.splice(myIndex + 1, 0, sibling)\\n      }\\n      sibling.parent = me.parent\\n    } while (me.children.length > 10)\\n    me.parent.maybeSpill()\\n  },\\n  iterN: function(at, n, op) {\\n    var this$1 = this;\\n\\n    for (var i = 0; i < this.children.length; ++i) {\\n      var child = this$1.children[i], sz = child.chunkSize()\\n      if (at < sz) {\\n        var used = Math.min(n, sz - at)\\n        if (child.iterN(at, used, op)) { return true }\\n        if ((n -= used) == 0) { break }\\n        at = 0\\n      } else { at -= sz }\\n    }\\n  }\\n}\\n\\n// Line widgets are block elements displayed above or below a line.\\n\\nfunction LineWidget(doc, node, options) {\\n  var this$1 = this;\\n\\n  if (options) { for (var opt in options) { if (options.hasOwnProperty(opt))\\n    { this$1[opt] = options[opt] } } }\\n  this.doc = doc\\n  this.node = node\\n}\\neventMixin(LineWidget)\\n\\nfunction adjustScrollWhenAboveVisible(cm, line, diff) {\\n  if (heightAtLine(line) < ((cm.curOp && cm.curOp.scrollTop) || cm.doc.scrollTop))\\n    { addToScrollPos(cm, null, diff) }\\n}\\n\\nLineWidget.prototype.clear = function() {\\n  var this$1 = this;\\n\\n  var cm = this.doc.cm, ws = this.line.widgets, line = this.line, no = lineNo(line)\\n  if (no == null || !ws) { return }\\n  for (var i = 0; i < ws.length; ++i) { if (ws[i] == this$1) { ws.splice(i--, 1) } }\\n  if (!ws.length) { line.widgets = null }\\n  var height = widgetHeight(this)\\n  updateLineHeight(line, Math.max(0, line.height - height))\\n  if (cm) { runInOp(cm, function () {\\n    adjustScrollWhenAboveVisible(cm, line, -height)\\n    regLineChange(cm, no, \\\"widget\\\")\\n  }) }\\n}\\nLineWidget.prototype.changed = function() {\\n  var oldH = this.height, cm = this.doc.cm, line = this.line\\n  this.height = null\\n  var diff = widgetHeight(this) - oldH\\n  if (!diff) { return }\\n  updateLineHeight(line, line.height + diff)\\n  if (cm) { runInOp(cm, function () {\\n    cm.curOp.forceUpdate = true\\n    adjustScrollWhenAboveVisible(cm, line, diff)\\n  }) }\\n}\\n\\nfunction addLineWidget(doc, handle, node, options) {\\n  var widget = new LineWidget(doc, node, options)\\n  var cm = doc.cm\\n  if (cm && widget.noHScroll) { cm.display.alignWidgets = true }\\n  changeLine(doc, handle, \\\"widget\\\", function (line) {\\n    var widgets = line.widgets || (line.widgets = [])\\n    if (widget.insertAt == null) { widgets.push(widget) }\\n    else { widgets.splice(Math.min(widgets.length - 1, Math.max(0, widget.insertAt)), 0, widget) }\\n    widget.line = line\\n    if (cm && !lineIsHidden(doc, line)) {\\n      var aboveVisible = heightAtLine(line) < doc.scrollTop\\n      updateLineHeight(line, line.height + widgetHeight(widget))\\n      if (aboveVisible) { addToScrollPos(cm, null, widget.height) }\\n      cm.curOp.forceUpdate = true\\n    }\\n    return true\\n  })\\n  return widget\\n}\\n\\n// TEXTMARKERS\\n\\n// Created with markText and setBookmark methods. A TextMarker is a\\n// handle that can be used to clear or find a marked position in the\\n// document. Line objects hold arrays (markedSpans) containing\\n// {from, to, marker} object pointing to such marker objects, and\\n// indicating that such a marker is present on that line. Multiple\\n// lines may point to the same marker when it spans across lines.\\n// The spans will have null for their from/to properties when the\\n// marker continues beyond the start/end of the line. Markers have\\n// links back to the lines they currently touch.\\n\\n// Collapsed markers have unique ids, in order to be able to order\\n// them, which is needed for uniquely determining an outer marker\\n// when they overlap (they may nest, but not partially overlap).\\nvar nextMarkerId = 0\\n\\nfunction TextMarker(doc, type) {\\n  this.lines = []\\n  this.type = type\\n  this.doc = doc\\n  this.id = ++nextMarkerId\\n}\\neventMixin(TextMarker)\\n\\n// Clear the marker.\\nTextMarker.prototype.clear = function() {\\n  var this$1 = this;\\n\\n  if (this.explicitlyCleared) { return }\\n  var cm = this.doc.cm, withOp = cm && !cm.curOp\\n  if (withOp) { startOperation(cm) }\\n  if (hasHandler(this, \\\"clear\\\")) {\\n    var found = this.find()\\n    if (found) { signalLater(this, \\\"clear\\\", found.from, found.to) }\\n  }\\n  var min = null, max = null\\n  for (var i = 0; i < this.lines.length; ++i) {\\n    var line = this$1.lines[i]\\n    var span = getMarkedSpanFor(line.markedSpans, this$1)\\n    if (cm && !this$1.collapsed) { regLineChange(cm, lineNo(line), \\\"text\\\") }\\n    else if (cm) {\\n      if (span.to != null) { max = lineNo(line) }\\n      if (span.from != null) { min = lineNo(line) }\\n    }\\n    line.markedSpans = removeMarkedSpan(line.markedSpans, span)\\n    if (span.from == null && this$1.collapsed && !lineIsHidden(this$1.doc, line) && cm)\\n      { updateLineHeight(line, textHeight(cm.display)) }\\n  }\\n  if (cm && this.collapsed && !cm.options.lineWrapping) { for (var i$1 = 0; i$1 < this.lines.length; ++i$1) {\\n    var visual = visualLine(this$1.lines[i$1]), len = lineLength(visual)\\n    if (len > cm.display.maxLineLength) {\\n      cm.display.maxLine = visual\\n      cm.display.maxLineLength = len\\n      cm.display.maxLineChanged = true\\n    }\\n  } }\\n\\n  if (min != null && cm && this.collapsed) { regChange(cm, min, max + 1) }\\n  this.lines.length = 0\\n  this.explicitlyCleared = true\\n  if (this.atomic && this.doc.cantEdit) {\\n    this.doc.cantEdit = false\\n    if (cm) { reCheckSelection(cm.doc) }\\n  }\\n  if (cm) { signalLater(cm, \\\"markerCleared\\\", cm, this) }\\n  if (withOp) { endOperation(cm) }\\n  if (this.parent) { this.parent.clear() }\\n}\\n\\n// Find the position of the marker in the document. Returns a {from,\\n// to} object by default. Side can be passed to get a specific side\\n// -- 0 (both), -1 (left), or 1 (right). When lineObj is true, the\\n// Pos objects returned contain a line object, rather than a line\\n// number (used to prevent looking up the same line twice).\\nTextMarker.prototype.find = function(side, lineObj) {\\n  var this$1 = this;\\n\\n  if (side == null && this.type == \\\"bookmark\\\") { side = 1 }\\n  var from, to\\n  for (var i = 0; i < this.lines.length; ++i) {\\n    var line = this$1.lines[i]\\n    var span = getMarkedSpanFor(line.markedSpans, this$1)\\n    if (span.from != null) {\\n      from = Pos(lineObj ? line : lineNo(line), span.from)\\n      if (side == -1) { return from }\\n    }\\n    if (span.to != null) {\\n      to = Pos(lineObj ? line : lineNo(line), span.to)\\n      if (side == 1) { return to }\\n    }\\n  }\\n  return from && {from: from, to: to}\\n}\\n\\n// Signals that the marker's widget changed, and surrounding layout\\n// should be recomputed.\\nTextMarker.prototype.changed = function() {\\n  var pos = this.find(-1, true), widget = this, cm = this.doc.cm\\n  if (!pos || !cm) { return }\\n  runInOp(cm, function () {\\n    var line = pos.line, lineN = lineNo(pos.line)\\n    var view = findViewForLine(cm, lineN)\\n    if (view) {\\n      clearLineMeasurementCacheFor(view)\\n      cm.curOp.selectionChanged = cm.curOp.forceUpdate = true\\n    }\\n    cm.curOp.updateMaxLine = true\\n    if (!lineIsHidden(widget.doc, line) && widget.height != null) {\\n      var oldHeight = widget.height\\n      widget.height = null\\n      var dHeight = widgetHeight(widget) - oldHeight\\n      if (dHeight)\\n        { updateLineHeight(line, line.height + dHeight) }\\n    }\\n  })\\n}\\n\\nTextMarker.prototype.attachLine = function(line) {\\n  if (!this.lines.length && this.doc.cm) {\\n    var op = this.doc.cm.curOp\\n    if (!op.maybeHiddenMarkers || indexOf(op.maybeHiddenMarkers, this) == -1)\\n      { (op.maybeUnhiddenMarkers || (op.maybeUnhiddenMarkers = [])).push(this) }\\n  }\\n  this.lines.push(line)\\n}\\nTextMarker.prototype.detachLine = function(line) {\\n  this.lines.splice(indexOf(this.lines, line), 1)\\n  if (!this.lines.length && this.doc.cm) {\\n    var op = this.doc.cm.curOp\\n    ;(op.maybeHiddenMarkers || (op.maybeHiddenMarkers = [])).push(this)\\n  }\\n}\\n\\n// Create a marker, wire it up to the right lines, and\\nfunction markText(doc, from, to, options, type) {\\n  // Shared markers (across linked documents) are handled separately\\n  // (markTextShared will call out to this again, once per\\n  // document).\\n  if (options && options.shared) { return markTextShared(doc, from, to, options, type) }\\n  // Ensure we are in an operation.\\n  if (doc.cm && !doc.cm.curOp) { return operation(doc.cm, markText)(doc, from, to, options, type) }\\n\\n  var marker = new TextMarker(doc, type), diff = cmp(from, to)\\n  if (options) { copyObj(options, marker, false) }\\n  // Don't connect empty markers unless clearWhenEmpty is false\\n  if (diff > 0 || diff == 0 && marker.clearWhenEmpty !== false)\\n    { return marker }\\n  if (marker.replacedWith) {\\n    // Showing up as a widget implies collapsed (widget replaces text)\\n    marker.collapsed = true\\n    marker.widgetNode = elt(\\\"span\\\", [marker.replacedWith], \\\"CodeMirror-widget\\\")\\n    if (!options.handleMouseEvents) { marker.widgetNode.setAttribute(\\\"cm-ignore-events\\\", \\\"true\\\") }\\n    if (options.insertLeft) { marker.widgetNode.insertLeft = true }\\n  }\\n  if (marker.collapsed) {\\n    if (conflictingCollapsedRange(doc, from.line, from, to, marker) ||\\n        from.line != to.line && conflictingCollapsedRange(doc, to.line, from, to, marker))\\n      { throw new Error(\\\"Inserting collapsed marker partially overlapping an existing one\\\") }\\n    seeCollapsedSpans()\\n  }\\n\\n  if (marker.addToHistory)\\n    { addChangeToHistory(doc, {from: from, to: to, origin: \\\"markText\\\"}, doc.sel, NaN) }\\n\\n  var curLine = from.line, cm = doc.cm, updateMaxLine\\n  doc.iter(curLine, to.line + 1, function (line) {\\n    if (cm && marker.collapsed && !cm.options.lineWrapping && visualLine(line) == cm.display.maxLine)\\n      { updateMaxLine = true }\\n    if (marker.collapsed && curLine != from.line) { updateLineHeight(line, 0) }\\n    addMarkedSpan(line, new MarkedSpan(marker,\\n                                       curLine == from.line ? from.ch : null,\\n                                       curLine == to.line ? to.ch : null))\\n    ++curLine\\n  })\\n  // lineIsHidden depends on the presence of the spans, so needs a second pass\\n  if (marker.collapsed) { doc.iter(from.line, to.line + 1, function (line) {\\n    if (lineIsHidden(doc, line)) { updateLineHeight(line, 0) }\\n  }) }\\n\\n  if (marker.clearOnEnter) { on(marker, \\\"beforeCursorEnter\\\", function () { return marker.clear(); }) }\\n\\n  if (marker.readOnly) {\\n    seeReadOnlySpans()\\n    if (doc.history.done.length || doc.history.undone.length)\\n      { doc.clearHistory() }\\n  }\\n  if (marker.collapsed) {\\n    marker.id = ++nextMarkerId\\n    marker.atomic = true\\n  }\\n  if (cm) {\\n    // Sync editor state\\n    if (updateMaxLine) { cm.curOp.updateMaxLine = true }\\n    if (marker.collapsed)\\n      { regChange(cm, from.line, to.line + 1) }\\n    else if (marker.className || marker.title || marker.startStyle || marker.endStyle || marker.css)\\n      { for (var i = from.line; i <= to.line; i++) { regLineChange(cm, i, \\\"text\\\") } }\\n    if (marker.atomic) { reCheckSelection(cm.doc) }\\n    signalLater(cm, \\\"markerAdded\\\", cm, marker)\\n  }\\n  return marker\\n}\\n\\n// SHARED TEXTMARKERS\\n\\n// A shared marker spans multiple linked documents. It is\\n// implemented as a meta-marker-object controlling multiple normal\\n// markers.\\nfunction SharedTextMarker(markers, primary) {\\n  var this$1 = this;\\n\\n  this.markers = markers\\n  this.primary = primary\\n  for (var i = 0; i < markers.length; ++i)\\n    { markers[i].parent = this$1 }\\n}\\neventMixin(SharedTextMarker)\\n\\nSharedTextMarker.prototype.clear = function() {\\n  var this$1 = this;\\n\\n  if (this.explicitlyCleared) { return }\\n  this.explicitlyCleared = true\\n  for (var i = 0; i < this.markers.length; ++i)\\n    { this$1.markers[i].clear() }\\n  signalLater(this, \\\"clear\\\")\\n}\\nSharedTextMarker.prototype.find = function(side, lineObj) {\\n  return this.primary.find(side, lineObj)\\n}\\n\\nfunction markTextShared(doc, from, to, options, type) {\\n  options = copyObj(options)\\n  options.shared = false\\n  var markers = [markText(doc, from, to, options, type)], primary = markers[0]\\n  var widget = options.widgetNode\\n  linkedDocs(doc, function (doc) {\\n    if (widget) { options.widgetNode = widget.cloneNode(true) }\\n    markers.push(markText(doc, clipPos(doc, from), clipPos(doc, to), options, type))\\n    for (var i = 0; i < doc.linked.length; ++i)\\n      { if (doc.linked[i].isParent) { return } }\\n    primary = lst(markers)\\n  })\\n  return new SharedTextMarker(markers, primary)\\n}\\n\\nfunction findSharedMarkers(doc) {\\n  return doc.findMarks(Pos(doc.first, 0), doc.clipPos(Pos(doc.lastLine())), function (m) { return m.parent; })\\n}\\n\\nfunction copySharedMarkers(doc, markers) {\\n  for (var i = 0; i < markers.length; i++) {\\n    var marker = markers[i], pos = marker.find()\\n    var mFrom = doc.clipPos(pos.from), mTo = doc.clipPos(pos.to)\\n    if (cmp(mFrom, mTo)) {\\n      var subMark = markText(doc, mFrom, mTo, marker.primary, marker.primary.type)\\n      marker.markers.push(subMark)\\n      subMark.parent = marker\\n    }\\n  }\\n}\\n\\nfunction detachSharedMarkers(markers) {\\n  var loop = function ( i ) {\\n    var marker = markers[i], linked = [marker.primary.doc]\\n    linkedDocs(marker.primary.doc, function (d) { return linked.push(d); })\\n    for (var j = 0; j < marker.markers.length; j++) {\\n      var subMarker = marker.markers[j]\\n      if (indexOf(linked, subMarker.doc) == -1) {\\n        subMarker.parent = null\\n        marker.markers.splice(j--, 1)\\n      }\\n    }\\n  };\\n\\n  for (var i = 0; i < markers.length; i++) loop( i );\\n}\\n\\nvar nextDocId = 0\\nvar Doc = function(text, mode, firstLine, lineSep) {\\n  if (!(this instanceof Doc)) { return new Doc(text, mode, firstLine, lineSep) }\\n  if (firstLine == null) { firstLine = 0 }\\n\\n  BranchChunk.call(this, [new LeafChunk([new Line(\\\"\\\", null)])])\\n  this.first = firstLine\\n  this.scrollTop = this.scrollLeft = 0\\n  this.cantEdit = false\\n  this.cleanGeneration = 1\\n  this.frontier = firstLine\\n  var start = Pos(firstLine, 0)\\n  this.sel = simpleSelection(start)\\n  this.history = new History(null)\\n  this.id = ++nextDocId\\n  this.modeOption = mode\\n  this.lineSep = lineSep\\n  this.extend = false\\n\\n  if (typeof text == \\\"string\\\") { text = this.splitLines(text) }\\n  updateDoc(this, {from: start, to: start, text: text})\\n  setSelection(this, simpleSelection(start), sel_dontScroll)\\n}\\n\\nDoc.prototype = createObj(BranchChunk.prototype, {\\n  constructor: Doc,\\n  // Iterate over the document. Supports two forms -- with only one\\n  // argument, it calls that for each line in the document. With\\n  // three, it iterates over the range given by the first two (with\\n  // the second being non-inclusive).\\n  iter: function(from, to, op) {\\n    if (op) { this.iterN(from - this.first, to - from, op) }\\n    else { this.iterN(this.first, this.first + this.size, from) }\\n  },\\n\\n  // Non-public interface for adding and removing lines.\\n  insert: function(at, lines) {\\n    var height = 0\\n    for (var i = 0; i < lines.length; ++i) { height += lines[i].height }\\n    this.insertInner(at - this.first, lines, height)\\n  },\\n  remove: function(at, n) { this.removeInner(at - this.first, n) },\\n\\n  // From here, the methods are part of the public interface. Most\\n  // are also available from CodeMirror (editor) instances.\\n\\n  getValue: function(lineSep) {\\n    var lines = getLines(this, this.first, this.first + this.size)\\n    if (lineSep === false) { return lines }\\n    return lines.join(lineSep || this.lineSeparator())\\n  },\\n  setValue: docMethodOp(function(code) {\\n    var top = Pos(this.first, 0), last = this.first + this.size - 1\\n    makeChange(this, {from: top, to: Pos(last, getLine(this, last).text.length),\\n                      text: this.splitLines(code), origin: \\\"setValue\\\", full: true}, true)\\n    setSelection(this, simpleSelection(top))\\n  }),\\n  replaceRange: function(code, from, to, origin) {\\n    from = clipPos(this, from)\\n    to = to ? clipPos(this, to) : from\\n    replaceRange(this, code, from, to, origin)\\n  },\\n  getRange: function(from, to, lineSep) {\\n    var lines = getBetween(this, clipPos(this, from), clipPos(this, to))\\n    if (lineSep === false) { return lines }\\n    return lines.join(lineSep || this.lineSeparator())\\n  },\\n\\n  getLine: function(line) {var l = this.getLineHandle(line); return l && l.text},\\n\\n  getLineHandle: function(line) {if (isLine(this, line)) { return getLine(this, line) }},\\n  getLineNumber: function(line) {return lineNo(line)},\\n\\n  getLineHandleVisualStart: function(line) {\\n    if (typeof line == \\\"number\\\") { line = getLine(this, line) }\\n    return visualLine(line)\\n  },\\n\\n  lineCount: function() {return this.size},\\n  firstLine: function() {return this.first},\\n  lastLine: function() {return this.first + this.size - 1},\\n\\n  clipPos: function(pos) {return clipPos(this, pos)},\\n\\n  getCursor: function(start) {\\n    var range = this.sel.primary(), pos\\n    if (start == null || start == \\\"head\\\") { pos = range.head }\\n    else if (start == \\\"anchor\\\") { pos = range.anchor }\\n    else if (start == \\\"end\\\" || start == \\\"to\\\" || start === false) { pos = range.to() }\\n    else { pos = range.from() }\\n    return pos\\n  },\\n  listSelections: function() { return this.sel.ranges },\\n  somethingSelected: function() {return this.sel.somethingSelected()},\\n\\n  setCursor: docMethodOp(function(line, ch, options) {\\n    setSimpleSelection(this, clipPos(this, typeof line == \\\"number\\\" ? Pos(line, ch || 0) : line), null, options)\\n  }),\\n  setSelection: docMethodOp(function(anchor, head, options) {\\n    setSimpleSelection(this, clipPos(this, anchor), clipPos(this, head || anchor), options)\\n  }),\\n  extendSelection: docMethodOp(function(head, other, options) {\\n    extendSelection(this, clipPos(this, head), other && clipPos(this, other), options)\\n  }),\\n  extendSelections: docMethodOp(function(heads, options) {\\n    extendSelections(this, clipPosArray(this, heads), options)\\n  }),\\n  extendSelectionsBy: docMethodOp(function(f, options) {\\n    var heads = map(this.sel.ranges, f)\\n    extendSelections(this, clipPosArray(this, heads), options)\\n  }),\\n  setSelections: docMethodOp(function(ranges, primary, options) {\\n    var this$1 = this;\\n\\n    if (!ranges.length) { return }\\n    var out = []\\n    for (var i = 0; i < ranges.length; i++)\\n      { out[i] = new Range(clipPos(this$1, ranges[i].anchor),\\n                         clipPos(this$1, ranges[i].head)) }\\n    if (primary == null) { primary = Math.min(ranges.length - 1, this.sel.primIndex) }\\n    setSelection(this, normalizeSelection(out, primary), options)\\n  }),\\n  addSelection: docMethodOp(function(anchor, head, options) {\\n    var ranges = this.sel.ranges.slice(0)\\n    ranges.push(new Range(clipPos(this, anchor), clipPos(this, head || anchor)))\\n    setSelection(this, normalizeSelection(ranges, ranges.length - 1), options)\\n  }),\\n\\n  getSelection: function(lineSep) {\\n    var this$1 = this;\\n\\n    var ranges = this.sel.ranges, lines\\n    for (var i = 0; i < ranges.length; i++) {\\n      var sel = getBetween(this$1, ranges[i].from(), ranges[i].to())\\n      lines = lines ? lines.concat(sel) : sel\\n    }\\n    if (lineSep === false) { return lines }\\n    else { return lines.join(lineSep || this.lineSeparator()) }\\n  },\\n  getSelections: function(lineSep) {\\n    var this$1 = this;\\n\\n    var parts = [], ranges = this.sel.ranges\\n    for (var i = 0; i < ranges.length; i++) {\\n      var sel = getBetween(this$1, ranges[i].from(), ranges[i].to())\\n      if (lineSep !== false) { sel = sel.join(lineSep || this$1.lineSeparator()) }\\n      parts[i] = sel\\n    }\\n    return parts\\n  },\\n  replaceSelection: function(code, collapse, origin) {\\n    var dup = []\\n    for (var i = 0; i < this.sel.ranges.length; i++)\\n      { dup[i] = code }\\n    this.replaceSelections(dup, collapse, origin || \\\"+input\\\")\\n  },\\n  replaceSelections: docMethodOp(function(code, collapse, origin) {\\n    var this$1 = this;\\n\\n    var changes = [], sel = this.sel\\n    for (var i = 0; i < sel.ranges.length; i++) {\\n      var range = sel.ranges[i]\\n      changes[i] = {from: range.from(), to: range.to(), text: this$1.splitLines(code[i]), origin: origin}\\n    }\\n    var newSel = collapse && collapse != \\\"end\\\" && computeReplacedSel(this, changes, collapse)\\n    for (var i$1 = changes.length - 1; i$1 >= 0; i$1--)\\n      { makeChange(this$1, changes[i$1]) }\\n    if (newSel) { setSelectionReplaceHistory(this, newSel) }\\n    else if (this.cm) { ensureCursorVisible(this.cm) }\\n  }),\\n  undo: docMethodOp(function() {makeChangeFromHistory(this, \\\"undo\\\")}),\\n  redo: docMethodOp(function() {makeChangeFromHistory(this, \\\"redo\\\")}),\\n  undoSelection: docMethodOp(function() {makeChangeFromHistory(this, \\\"undo\\\", true)}),\\n  redoSelection: docMethodOp(function() {makeChangeFromHistory(this, \\\"redo\\\", true)}),\\n\\n  setExtending: function(val) {this.extend = val},\\n  getExtending: function() {return this.extend},\\n\\n  historySize: function() {\\n    var hist = this.history, done = 0, undone = 0\\n    for (var i = 0; i < hist.done.length; i++) { if (!hist.done[i].ranges) { ++done } }\\n    for (var i$1 = 0; i$1 < hist.undone.length; i$1++) { if (!hist.undone[i$1].ranges) { ++undone } }\\n    return {undo: done, redo: undone}\\n  },\\n  clearHistory: function() {this.history = new History(this.history.maxGeneration)},\\n\\n  markClean: function() {\\n    this.cleanGeneration = this.changeGeneration(true)\\n  },\\n  changeGeneration: function(forceSplit) {\\n    if (forceSplit)\\n      { this.history.lastOp = this.history.lastSelOp = this.history.lastOrigin = null }\\n    return this.history.generation\\n  },\\n  isClean: function (gen) {\\n    return this.history.generation == (gen || this.cleanGeneration)\\n  },\\n\\n  getHistory: function() {\\n    return {done: copyHistoryArray(this.history.done),\\n            undone: copyHistoryArray(this.history.undone)}\\n  },\\n  setHistory: function(histData) {\\n    var hist = this.history = new History(this.history.maxGeneration)\\n    hist.done = copyHistoryArray(histData.done.slice(0), null, true)\\n    hist.undone = copyHistoryArray(histData.undone.slice(0), null, true)\\n  },\\n\\n  addLineClass: docMethodOp(function(handle, where, cls) {\\n    return changeLine(this, handle, where == \\\"gutter\\\" ? \\\"gutter\\\" : \\\"class\\\", function (line) {\\n      var prop = where == \\\"text\\\" ? \\\"textClass\\\"\\n               : where == \\\"background\\\" ? \\\"bgClass\\\"\\n               : where == \\\"gutter\\\" ? \\\"gutterClass\\\" : \\\"wrapClass\\\"\\n      if (!line[prop]) { line[prop] = cls }\\n      else if (classTest(cls).test(line[prop])) { return false }\\n      else { line[prop] += \\\" \\\" + cls }\\n      return true\\n    })\\n  }),\\n  removeLineClass: docMethodOp(function(handle, where, cls) {\\n    return changeLine(this, handle, where == \\\"gutter\\\" ? \\\"gutter\\\" : \\\"class\\\", function (line) {\\n      var prop = where == \\\"text\\\" ? \\\"textClass\\\"\\n               : where == \\\"background\\\" ? \\\"bgClass\\\"\\n               : where == \\\"gutter\\\" ? \\\"gutterClass\\\" : \\\"wrapClass\\\"\\n      var cur = line[prop]\\n      if (!cur) { return false }\\n      else if (cls == null) { line[prop] = null }\\n      else {\\n        var found = cur.match(classTest(cls))\\n        if (!found) { return false }\\n        var end = found.index + found[0].length\\n        line[prop] = cur.slice(0, found.index) + (!found.index || end == cur.length ? \\\"\\\" : \\\" \\\") + cur.slice(end) || null\\n      }\\n      return true\\n    })\\n  }),\\n\\n  addLineWidget: docMethodOp(function(handle, node, options) {\\n    return addLineWidget(this, handle, node, options)\\n  }),\\n  removeLineWidget: function(widget) { widget.clear() },\\n\\n  markText: function(from, to, options) {\\n    return markText(this, clipPos(this, from), clipPos(this, to), options, options && options.type || \\\"range\\\")\\n  },\\n  setBookmark: function(pos, options) {\\n    var realOpts = {replacedWith: options && (options.nodeType == null ? options.widget : options),\\n                    insertLeft: options && options.insertLeft,\\n                    clearWhenEmpty: false, shared: options && options.shared,\\n                    handleMouseEvents: options && options.handleMouseEvents}\\n    pos = clipPos(this, pos)\\n    return markText(this, pos, pos, realOpts, \\\"bookmark\\\")\\n  },\\n  findMarksAt: function(pos) {\\n    pos = clipPos(this, pos)\\n    var markers = [], spans = getLine(this, pos.line).markedSpans\\n    if (spans) { for (var i = 0; i < spans.length; ++i) {\\n      var span = spans[i]\\n      if ((span.from == null || span.from <= pos.ch) &&\\n          (span.to == null || span.to >= pos.ch))\\n        { markers.push(span.marker.parent || span.marker) }\\n    } }\\n    return markers\\n  },\\n  findMarks: function(from, to, filter) {\\n    from = clipPos(this, from); to = clipPos(this, to)\\n    var found = [], lineNo = from.line\\n    this.iter(from.line, to.line + 1, function (line) {\\n      var spans = line.markedSpans\\n      if (spans) { for (var i = 0; i < spans.length; i++) {\\n        var span = spans[i]\\n        if (!(span.to != null && lineNo == from.line && from.ch >= span.to ||\\n              span.from == null && lineNo != from.line ||\\n              span.from != null && lineNo == to.line && span.from >= to.ch) &&\\n            (!filter || filter(span.marker)))\\n          { found.push(span.marker.parent || span.marker) }\\n      } }\\n      ++lineNo\\n    })\\n    return found\\n  },\\n  getAllMarks: function() {\\n    var markers = []\\n    this.iter(function (line) {\\n      var sps = line.markedSpans\\n      if (sps) { for (var i = 0; i < sps.length; ++i)\\n        { if (sps[i].from != null) { markers.push(sps[i].marker) } } }\\n    })\\n    return markers\\n  },\\n\\n  posFromIndex: function(off) {\\n    var ch, lineNo = this.first, sepSize = this.lineSeparator().length\\n    this.iter(function (line) {\\n      var sz = line.text.length + sepSize\\n      if (sz > off) { ch = off; return true }\\n      off -= sz\\n      ++lineNo\\n    })\\n    return clipPos(this, Pos(lineNo, ch))\\n  },\\n  indexFromPos: function (coords) {\\n    coords = clipPos(this, coords)\\n    var index = coords.ch\\n    if (coords.line < this.first || coords.ch < 0) { return 0 }\\n    var sepSize = this.lineSeparator().length\\n    this.iter(this.first, coords.line, function (line) { // iter aborts when callback returns a truthy value\\n      index += line.text.length + sepSize\\n    })\\n    return index\\n  },\\n\\n  copy: function(copyHistory) {\\n    var doc = new Doc(getLines(this, this.first, this.first + this.size),\\n                      this.modeOption, this.first, this.lineSep)\\n    doc.scrollTop = this.scrollTop; doc.scrollLeft = this.scrollLeft\\n    doc.sel = this.sel\\n    doc.extend = false\\n    if (copyHistory) {\\n      doc.history.undoDepth = this.history.undoDepth\\n      doc.setHistory(this.getHistory())\\n    }\\n    return doc\\n  },\\n\\n  linkedDoc: function(options) {\\n    if (!options) { options = {} }\\n    var from = this.first, to = this.first + this.size\\n    if (options.from != null && options.from > from) { from = options.from }\\n    if (options.to != null && options.to < to) { to = options.to }\\n    var copy = new Doc(getLines(this, from, to), options.mode || this.modeOption, from, this.lineSep)\\n    if (options.sharedHist) { copy.history = this.history\\n    ; }(this.linked || (this.linked = [])).push({doc: copy, sharedHist: options.sharedHist})\\n    copy.linked = [{doc: this, isParent: true, sharedHist: options.sharedHist}]\\n    copySharedMarkers(copy, findSharedMarkers(this))\\n    return copy\\n  },\\n  unlinkDoc: function(other) {\\n    var this$1 = this;\\n\\n    if (other instanceof CodeMirror) { other = other.doc }\\n    if (this.linked) { for (var i = 0; i < this.linked.length; ++i) {\\n      var link = this$1.linked[i]\\n      if (link.doc != other) { continue }\\n      this$1.linked.splice(i, 1)\\n      other.unlinkDoc(this$1)\\n      detachSharedMarkers(findSharedMarkers(this$1))\\n      break\\n    } }\\n    // If the histories were shared, split them again\\n    if (other.history == this.history) {\\n      var splitIds = [other.id]\\n      linkedDocs(other, function (doc) { return splitIds.push(doc.id); }, true)\\n      other.history = new History(null)\\n      other.history.done = copyHistoryArray(this.history.done, splitIds)\\n      other.history.undone = copyHistoryArray(this.history.undone, splitIds)\\n    }\\n  },\\n  iterLinkedDocs: function(f) {linkedDocs(this, f)},\\n\\n  getMode: function() {return this.mode},\\n  getEditor: function() {return this.cm},\\n\\n  splitLines: function(str) {\\n    if (this.lineSep) { return str.split(this.lineSep) }\\n    return splitLinesAuto(str)\\n  },\\n  lineSeparator: function() { return this.lineSep || \\\"\\\\n\\\" }\\n})\\n\\n// Public alias.\\nDoc.prototype.eachLine = Doc.prototype.iter\\n\\n// Kludge to work around strange IE behavior where it'll sometimes\\n// re-fire a series of drag-related events right after the drop (#1551)\\nvar lastDrop = 0\\n\\nfunction onDrop(e) {\\n  var cm = this\\n  clearDragCursor(cm)\\n  if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e))\\n    { return }\\n  e_preventDefault(e)\\n  if (ie) { lastDrop = +new Date }\\n  var pos = posFromMouse(cm, e, true), files = e.dataTransfer.files\\n  if (!pos || cm.isReadOnly()) { return }\\n  // Might be a file drop, in which case we simply extract the text\\n  // and insert it.\\n  if (files && files.length && window.FileReader && window.File) {\\n    var n = files.length, text = Array(n), read = 0\\n    var loadFile = function (file, i) {\\n      if (cm.options.allowDropFileTypes &&\\n          indexOf(cm.options.allowDropFileTypes, file.type) == -1)\\n        { return }\\n\\n      var reader = new FileReader\\n      reader.onload = operation(cm, function () {\\n        var content = reader.result\\n        if (/[\\\\x00-\\\\x08\\\\x0e-\\\\x1f]{2}/.test(content)) { content = \\\"\\\" }\\n        text[i] = content\\n        if (++read == n) {\\n          pos = clipPos(cm.doc, pos)\\n          var change = {from: pos, to: pos,\\n                        text: cm.doc.splitLines(text.join(cm.doc.lineSeparator())),\\n                        origin: \\\"paste\\\"}\\n          makeChange(cm.doc, change)\\n          setSelectionReplaceHistory(cm.doc, simpleSelection(pos, changeEnd(change)))\\n        }\\n      })\\n      reader.readAsText(file)\\n    }\\n    for (var i = 0; i < n; ++i) { loadFile(files[i], i) }\\n  } else { // Normal drop\\n    // Don't do a replace if the drop happened inside of the selected text.\\n    if (cm.state.draggingText && cm.doc.sel.contains(pos) > -1) {\\n      cm.state.draggingText(e)\\n      // Ensure the editor is re-focused\\n      setTimeout(function () { return cm.display.input.focus(); }, 20)\\n      return\\n    }\\n    try {\\n      var text$1 = e.dataTransfer.getData(\\\"Text\\\")\\n      if (text$1) {\\n        var selected\\n        if (cm.state.draggingText && !cm.state.draggingText.copy)\\n          { selected = cm.listSelections() }\\n        setSelectionNoUndo(cm.doc, simpleSelection(pos, pos))\\n        if (selected) { for (var i$1 = 0; i$1 < selected.length; ++i$1)\\n          { replaceRange(cm.doc, \\\"\\\", selected[i$1].anchor, selected[i$1].head, \\\"drag\\\") } }\\n        cm.replaceSelection(text$1, \\\"around\\\", \\\"paste\\\")\\n        cm.display.input.focus()\\n      }\\n    }\\n    catch(e){}\\n  }\\n}\\n\\nfunction onDragStart(cm, e) {\\n  if (ie && (!cm.state.draggingText || +new Date - lastDrop < 100)) { e_stop(e); return }\\n  if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e)) { return }\\n\\n  e.dataTransfer.setData(\\\"Text\\\", cm.getSelection())\\n  e.dataTransfer.effectAllowed = \\\"copyMove\\\"\\n\\n  // Use dummy image instead of default browsers image.\\n  // Recent Safari (~6.0.2) have a tendency to segfault when this happens, so we don't do it there.\\n  if (e.dataTransfer.setDragImage && !safari) {\\n    var img = elt(\\\"img\\\", null, null, \\\"position: fixed; left: 0; top: 0;\\\")\\n    img.src = \\\"data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\\\"\\n    if (presto) {\\n      img.width = img.height = 1\\n      cm.display.wrapper.appendChild(img)\\n      // Force a relayout, or Opera won't use our image for some obscure reason\\n      img._top = img.offsetTop\\n    }\\n    e.dataTransfer.setDragImage(img, 0, 0)\\n    if (presto) { img.parentNode.removeChild(img) }\\n  }\\n}\\n\\nfunction onDragOver(cm, e) {\\n  var pos = posFromMouse(cm, e)\\n  if (!pos) { return }\\n  var frag = document.createDocumentFragment()\\n  drawSelectionCursor(cm, pos, frag)\\n  if (!cm.display.dragCursor) {\\n    cm.display.dragCursor = elt(\\\"div\\\", null, \\\"CodeMirror-cursors CodeMirror-dragcursors\\\")\\n    cm.display.lineSpace.insertBefore(cm.display.dragCursor, cm.display.cursorDiv)\\n  }\\n  removeChildrenAndAdd(cm.display.dragCursor, frag)\\n}\\n\\nfunction clearDragCursor(cm) {\\n  if (cm.display.dragCursor) {\\n    cm.display.lineSpace.removeChild(cm.display.dragCursor)\\n    cm.display.dragCursor = null\\n  }\\n}\\n\\n// These must be handled carefully, because naively registering a\\n// handler for each editor will cause the editors to never be\\n// garbage collected.\\n\\nfunction forEachCodeMirror(f) {\\n  if (!document.body.getElementsByClassName) { return }\\n  var byClass = document.body.getElementsByClassName(\\\"CodeMirror\\\")\\n  for (var i = 0; i < byClass.length; i++) {\\n    var cm = byClass[i].CodeMirror\\n    if (cm) { f(cm) }\\n  }\\n}\\n\\nvar globalsRegistered = false\\nfunction ensureGlobalHandlers() {\\n  if (globalsRegistered) { return }\\n  registerGlobalHandlers()\\n  globalsRegistered = true\\n}\\nfunction registerGlobalHandlers() {\\n  // When the window resizes, we need to refresh active editors.\\n  var resizeTimer\\n  on(window, \\\"resize\\\", function () {\\n    if (resizeTimer == null) { resizeTimer = setTimeout(function () {\\n      resizeTimer = null\\n      forEachCodeMirror(onResize)\\n    }, 100) }\\n  })\\n  // When the window loses focus, we want to show the editor as blurred\\n  on(window, \\\"blur\\\", function () { return forEachCodeMirror(onBlur); })\\n}\\n// Called when the window resizes\\nfunction onResize(cm) {\\n  var d = cm.display\\n  if (d.lastWrapHeight == d.wrapper.clientHeight && d.lastWrapWidth == d.wrapper.clientWidth)\\n    { return }\\n  // Might be a text scaling operation, clear size caches.\\n  d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null\\n  d.scrollbarsClipped = false\\n  cm.setSize()\\n}\\n\\nvar keyNames = {\\n  3: \\\"Enter\\\", 8: \\\"Backspace\\\", 9: \\\"Tab\\\", 13: \\\"Enter\\\", 16: \\\"Shift\\\", 17: \\\"Ctrl\\\", 18: \\\"Alt\\\",\\n  19: \\\"Pause\\\", 20: \\\"CapsLock\\\", 27: \\\"Esc\\\", 32: \\\"Space\\\", 33: \\\"PageUp\\\", 34: \\\"PageDown\\\", 35: \\\"End\\\",\\n  36: \\\"Home\\\", 37: \\\"Left\\\", 38: \\\"Up\\\", 39: \\\"Right\\\", 40: \\\"Down\\\", 44: \\\"PrintScrn\\\", 45: \\\"Insert\\\",\\n  46: \\\"Delete\\\", 59: \\\";\\\", 61: \\\"=\\\", 91: \\\"Mod\\\", 92: \\\"Mod\\\", 93: \\\"Mod\\\",\\n  106: \\\"*\\\", 107: \\\"=\\\", 109: \\\"-\\\", 110: \\\".\\\", 111: \\\"/\\\", 127: \\\"Delete\\\",\\n  173: \\\"-\\\", 186: \\\";\\\", 187: \\\"=\\\", 188: \\\",\\\", 189: \\\"-\\\", 190: \\\".\\\", 191: \\\"/\\\", 192: \\\"`\\\", 219: \\\"[\\\", 220: \\\"\\\\\\\\\\\",\\n  221: \\\"]\\\", 222: \\\"'\\\", 63232: \\\"Up\\\", 63233: \\\"Down\\\", 63234: \\\"Left\\\", 63235: \\\"Right\\\", 63272: \\\"Delete\\\",\\n  63273: \\\"Home\\\", 63275: \\\"End\\\", 63276: \\\"PageUp\\\", 63277: \\\"PageDown\\\", 63302: \\\"Insert\\\"\\n}\\n\\n// Number keys\\nfor (var i = 0; i < 10; i++) { keyNames[i + 48] = keyNames[i + 96] = String(i) }\\n// Alphabetic keys\\nfor (var i$1 = 65; i$1 <= 90; i$1++) { keyNames[i$1] = String.fromCharCode(i$1) }\\n// Function keys\\nfor (var i$2 = 1; i$2 <= 12; i$2++) { keyNames[i$2 + 111] = keyNames[i$2 + 63235] = \\\"F\\\" + i$2 }\\n\\nvar keyMap = {}\\n\\nkeyMap.basic = {\\n  \\\"Left\\\": \\\"goCharLeft\\\", \\\"Right\\\": \\\"goCharRight\\\", \\\"Up\\\": \\\"goLineUp\\\", \\\"Down\\\": \\\"goLineDown\\\",\\n  \\\"End\\\": \\\"goLineEnd\\\", \\\"Home\\\": \\\"goLineStartSmart\\\", \\\"PageUp\\\": \\\"goPageUp\\\", \\\"PageDown\\\": \\\"goPageDown\\\",\\n  \\\"Delete\\\": \\\"delCharAfter\\\", \\\"Backspace\\\": \\\"delCharBefore\\\", \\\"Shift-Backspace\\\": \\\"delCharBefore\\\",\\n  \\\"Tab\\\": \\\"defaultTab\\\", \\\"Shift-Tab\\\": \\\"indentAuto\\\",\\n  \\\"Enter\\\": \\\"newlineAndIndent\\\", \\\"Insert\\\": \\\"toggleOverwrite\\\",\\n  \\\"Esc\\\": \\\"singleSelection\\\"\\n}\\n// Note that the save and find-related commands aren't defined by\\n// default. User code or addons can define them. Unknown commands\\n// are simply ignored.\\nkeyMap.pcDefault = {\\n  \\\"Ctrl-A\\\": \\\"selectAll\\\", \\\"Ctrl-D\\\": \\\"deleteLine\\\", \\\"Ctrl-Z\\\": \\\"undo\\\", \\\"Shift-Ctrl-Z\\\": \\\"redo\\\", \\\"Ctrl-Y\\\": \\\"redo\\\",\\n  \\\"Ctrl-Home\\\": \\\"goDocStart\\\", \\\"Ctrl-End\\\": \\\"goDocEnd\\\", \\\"Ctrl-Up\\\": \\\"goLineUp\\\", \\\"Ctrl-Down\\\": \\\"goLineDown\\\",\\n  \\\"Ctrl-Left\\\": \\\"goGroupLeft\\\", \\\"Ctrl-Right\\\": \\\"goGroupRight\\\", \\\"Alt-Left\\\": \\\"goLineStart\\\", \\\"Alt-Right\\\": \\\"goLineEnd\\\",\\n  \\\"Ctrl-Backspace\\\": \\\"delGroupBefore\\\", \\\"Ctrl-Delete\\\": \\\"delGroupAfter\\\", \\\"Ctrl-S\\\": \\\"save\\\", \\\"Ctrl-F\\\": \\\"find\\\",\\n  \\\"Ctrl-G\\\": \\\"findNext\\\", \\\"Shift-Ctrl-G\\\": \\\"findPrev\\\", \\\"Shift-Ctrl-F\\\": \\\"replace\\\", \\\"Shift-Ctrl-R\\\": \\\"replaceAll\\\",\\n  \\\"Ctrl-[\\\": \\\"indentLess\\\", \\\"Ctrl-]\\\": \\\"indentMore\\\",\\n  \\\"Ctrl-U\\\": \\\"undoSelection\\\", \\\"Shift-Ctrl-U\\\": \\\"redoSelection\\\", \\\"Alt-U\\\": \\\"redoSelection\\\",\\n  fallthrough: \\\"basic\\\"\\n}\\n// Very basic readline/emacs-style bindings, which are standard on Mac.\\nkeyMap.emacsy = {\\n  \\\"Ctrl-F\\\": \\\"goCharRight\\\", \\\"Ctrl-B\\\": \\\"goCharLeft\\\", \\\"Ctrl-P\\\": \\\"goLineUp\\\", \\\"Ctrl-N\\\": \\\"goLineDown\\\",\\n  \\\"Alt-F\\\": \\\"goWordRight\\\", \\\"Alt-B\\\": \\\"goWordLeft\\\", \\\"Ctrl-A\\\": \\\"goLineStart\\\", \\\"Ctrl-E\\\": \\\"goLineEnd\\\",\\n  \\\"Ctrl-V\\\": \\\"goPageDown\\\", \\\"Shift-Ctrl-V\\\": \\\"goPageUp\\\", \\\"Ctrl-D\\\": \\\"delCharAfter\\\", \\\"Ctrl-H\\\": \\\"delCharBefore\\\",\\n  \\\"Alt-D\\\": \\\"delWordAfter\\\", \\\"Alt-Backspace\\\": \\\"delWordBefore\\\", \\\"Ctrl-K\\\": \\\"killLine\\\", \\\"Ctrl-T\\\": \\\"transposeChars\\\",\\n  \\\"Ctrl-O\\\": \\\"openLine\\\"\\n}\\nkeyMap.macDefault = {\\n  \\\"Cmd-A\\\": \\\"selectAll\\\", \\\"Cmd-D\\\": \\\"deleteLine\\\", \\\"Cmd-Z\\\": \\\"undo\\\", \\\"Shift-Cmd-Z\\\": \\\"redo\\\", \\\"Cmd-Y\\\": \\\"redo\\\",\\n  \\\"Cmd-Home\\\": \\\"goDocStart\\\", \\\"Cmd-Up\\\": \\\"goDocStart\\\", \\\"Cmd-End\\\": \\\"goDocEnd\\\", \\\"Cmd-Down\\\": \\\"goDocEnd\\\", \\\"Alt-Left\\\": \\\"goGroupLeft\\\",\\n  \\\"Alt-Right\\\": \\\"goGroupRight\\\", \\\"Cmd-Left\\\": \\\"goLineLeft\\\", \\\"Cmd-Right\\\": \\\"goLineRight\\\", \\\"Alt-Backspace\\\": \\\"delGroupBefore\\\",\\n  \\\"Ctrl-Alt-Backspace\\\": \\\"delGroupAfter\\\", \\\"Alt-Delete\\\": \\\"delGroupAfter\\\", \\\"Cmd-S\\\": \\\"save\\\", \\\"Cmd-F\\\": \\\"find\\\",\\n  \\\"Cmd-G\\\": \\\"findNext\\\", \\\"Shift-Cmd-G\\\": \\\"findPrev\\\", \\\"Cmd-Alt-F\\\": \\\"replace\\\", \\\"Shift-Cmd-Alt-F\\\": \\\"replaceAll\\\",\\n  \\\"Cmd-[\\\": \\\"indentLess\\\", \\\"Cmd-]\\\": \\\"indentMore\\\", \\\"Cmd-Backspace\\\": \\\"delWrappedLineLeft\\\", \\\"Cmd-Delete\\\": \\\"delWrappedLineRight\\\",\\n  \\\"Cmd-U\\\": \\\"undoSelection\\\", \\\"Shift-Cmd-U\\\": \\\"redoSelection\\\", \\\"Ctrl-Up\\\": \\\"goDocStart\\\", \\\"Ctrl-Down\\\": \\\"goDocEnd\\\",\\n  fallthrough: [\\\"basic\\\", \\\"emacsy\\\"]\\n}\\nkeyMap[\\\"default\\\"] = mac ? keyMap.macDefault : keyMap.pcDefault\\n\\n// KEYMAP DISPATCH\\n\\nfunction normalizeKeyName(name) {\\n  var parts = name.split(/-(?!$)/)\\n  name = parts[parts.length - 1]\\n  var alt, ctrl, shift, cmd\\n  for (var i = 0; i < parts.length - 1; i++) {\\n    var mod = parts[i]\\n    if (/^(cmd|meta|m)$/i.test(mod)) { cmd = true }\\n    else if (/^a(lt)?$/i.test(mod)) { alt = true }\\n    else if (/^(c|ctrl|control)$/i.test(mod)) { ctrl = true }\\n    else if (/^s(hift)?$/i.test(mod)) { shift = true }\\n    else { throw new Error(\\\"Unrecognized modifier name: \\\" + mod) }\\n  }\\n  if (alt) { name = \\\"Alt-\\\" + name }\\n  if (ctrl) { name = \\\"Ctrl-\\\" + name }\\n  if (cmd) { name = \\\"Cmd-\\\" + name }\\n  if (shift) { name = \\\"Shift-\\\" + name }\\n  return name\\n}\\n\\n// This is a kludge to keep keymaps mostly working as raw objects\\n// (backwards compatibility) while at the same time support features\\n// like normalization and multi-stroke key bindings. It compiles a\\n// new normalized keymap, and then updates the old object to reflect\\n// this.\\nfunction normalizeKeyMap(keymap) {\\n  var copy = {}\\n  for (var keyname in keymap) { if (keymap.hasOwnProperty(keyname)) {\\n    var value = keymap[keyname]\\n    if (/^(name|fallthrough|(de|at)tach)$/.test(keyname)) { continue }\\n    if (value == \\\"...\\\") { delete keymap[keyname]; continue }\\n\\n    var keys = map(keyname.split(\\\" \\\"), normalizeKeyName)\\n    for (var i = 0; i < keys.length; i++) {\\n      var val = void 0, name = void 0\\n      if (i == keys.length - 1) {\\n        name = keys.join(\\\" \\\")\\n        val = value\\n      } else {\\n        name = keys.slice(0, i + 1).join(\\\" \\\")\\n        val = \\\"...\\\"\\n      }\\n      var prev = copy[name]\\n      if (!prev) { copy[name] = val }\\n      else if (prev != val) { throw new Error(\\\"Inconsistent bindings for \\\" + name) }\\n    }\\n    delete keymap[keyname]\\n  } }\\n  for (var prop in copy) { keymap[prop] = copy[prop] }\\n  return keymap\\n}\\n\\nfunction lookupKey(key, map, handle, context) {\\n  map = getKeyMap(map)\\n  var found = map.call ? map.call(key, context) : map[key]\\n  if (found === false) { return \\\"nothing\\\" }\\n  if (found === \\\"...\\\") { return \\\"multi\\\" }\\n  if (found != null && handle(found)) { return \\\"handled\\\" }\\n\\n  if (map.fallthrough) {\\n    if (Object.prototype.toString.call(map.fallthrough) != \\\"[object Array]\\\")\\n      { return lookupKey(key, map.fallthrough, handle, context) }\\n    for (var i = 0; i < map.fallthrough.length; i++) {\\n      var result = lookupKey(key, map.fallthrough[i], handle, context)\\n      if (result) { return result }\\n    }\\n  }\\n}\\n\\n// Modifier key presses don't count as 'real' key presses for the\\n// purpose of keymap fallthrough.\\nfunction isModifierKey(value) {\\n  var name = typeof value == \\\"string\\\" ? value : keyNames[value.keyCode]\\n  return name == \\\"Ctrl\\\" || name == \\\"Alt\\\" || name == \\\"Shift\\\" || name == \\\"Mod\\\"\\n}\\n\\n// Look up the name of a key as indicated by an event object.\\nfunction keyName(event, noShift) {\\n  if (presto && event.keyCode == 34 && event[\\\"char\\\"]) { return false }\\n  var base = keyNames[event.keyCode], name = base\\n  if (name == null || event.altGraphKey) { return false }\\n  if (event.altKey && base != \\\"Alt\\\") { name = \\\"Alt-\\\" + name }\\n  if ((flipCtrlCmd ? event.metaKey : event.ctrlKey) && base != \\\"Ctrl\\\") { name = \\\"Ctrl-\\\" + name }\\n  if ((flipCtrlCmd ? event.ctrlKey : event.metaKey) && base != \\\"Cmd\\\") { name = \\\"Cmd-\\\" + name }\\n  if (!noShift && event.shiftKey && base != \\\"Shift\\\") { name = \\\"Shift-\\\" + name }\\n  return name\\n}\\n\\nfunction getKeyMap(val) {\\n  return typeof val == \\\"string\\\" ? keyMap[val] : val\\n}\\n\\n// Helper for deleting text near the selection(s), used to implement\\n// backspace, delete, and similar functionality.\\nfunction deleteNearSelection(cm, compute) {\\n  var ranges = cm.doc.sel.ranges, kill = []\\n  // Build up a set of ranges to kill first, merging overlapping\\n  // ranges.\\n  for (var i = 0; i < ranges.length; i++) {\\n    var toKill = compute(ranges[i])\\n    while (kill.length && cmp(toKill.from, lst(kill).to) <= 0) {\\n      var replaced = kill.pop()\\n      if (cmp(replaced.from, toKill.from) < 0) {\\n        toKill.from = replaced.from\\n        break\\n      }\\n    }\\n    kill.push(toKill)\\n  }\\n  // Next, remove those actual ranges.\\n  runInOp(cm, function () {\\n    for (var i = kill.length - 1; i >= 0; i--)\\n      { replaceRange(cm.doc, \\\"\\\", kill[i].from, kill[i].to, \\\"+delete\\\") }\\n    ensureCursorVisible(cm)\\n  })\\n}\\n\\n// Commands are parameter-less actions that can be performed on an\\n// editor, mostly used for keybindings.\\nvar commands = {\\n  selectAll: selectAll,\\n  singleSelection: function (cm) { return cm.setSelection(cm.getCursor(\\\"anchor\\\"), cm.getCursor(\\\"head\\\"), sel_dontScroll); },\\n  killLine: function (cm) { return deleteNearSelection(cm, function (range) {\\n    if (range.empty()) {\\n      var len = getLine(cm.doc, range.head.line).text.length\\n      if (range.head.ch == len && range.head.line < cm.lastLine())\\n        { return {from: range.head, to: Pos(range.head.line + 1, 0)} }\\n      else\\n        { return {from: range.head, to: Pos(range.head.line, len)} }\\n    } else {\\n      return {from: range.from(), to: range.to()}\\n    }\\n  }); },\\n  deleteLine: function (cm) { return deleteNearSelection(cm, function (range) { return ({\\n    from: Pos(range.from().line, 0),\\n    to: clipPos(cm.doc, Pos(range.to().line + 1, 0))\\n  }); }); },\\n  delLineLeft: function (cm) { return deleteNearSelection(cm, function (range) { return ({\\n    from: Pos(range.from().line, 0), to: range.from()\\n  }); }); },\\n  delWrappedLineLeft: function (cm) { return deleteNearSelection(cm, function (range) {\\n    var top = cm.charCoords(range.head, \\\"div\\\").top + 5\\n    var leftPos = cm.coordsChar({left: 0, top: top}, \\\"div\\\")\\n    return {from: leftPos, to: range.from()}\\n  }); },\\n  delWrappedLineRight: function (cm) { return deleteNearSelection(cm, function (range) {\\n    var top = cm.charCoords(range.head, \\\"div\\\").top + 5\\n    var rightPos = cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, \\\"div\\\")\\n    return {from: range.from(), to: rightPos }\\n  }); },\\n  undo: function (cm) { return cm.undo(); },\\n  redo: function (cm) { return cm.redo(); },\\n  undoSelection: function (cm) { return cm.undoSelection(); },\\n  redoSelection: function (cm) { return cm.redoSelection(); },\\n  goDocStart: function (cm) { return cm.extendSelection(Pos(cm.firstLine(), 0)); },\\n  goDocEnd: function (cm) { return cm.extendSelection(Pos(cm.lastLine())); },\\n  goLineStart: function (cm) { return cm.extendSelectionsBy(function (range) { return lineStart(cm, range.head.line); },\\n    {origin: \\\"+move\\\", bias: 1}\\n  ); },\\n  goLineStartSmart: function (cm) { return cm.extendSelectionsBy(function (range) { return lineStartSmart(cm, range.head); },\\n    {origin: \\\"+move\\\", bias: 1}\\n  ); },\\n  goLineEnd: function (cm) { return cm.extendSelectionsBy(function (range) { return lineEnd(cm, range.head.line); },\\n    {origin: \\\"+move\\\", bias: -1}\\n  ); },\\n  goLineRight: function (cm) { return cm.extendSelectionsBy(function (range) {\\n    var top = cm.charCoords(range.head, \\\"div\\\").top + 5\\n    return cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, \\\"div\\\")\\n  }, sel_move); },\\n  goLineLeft: function (cm) { return cm.extendSelectionsBy(function (range) {\\n    var top = cm.charCoords(range.head, \\\"div\\\").top + 5\\n    return cm.coordsChar({left: 0, top: top}, \\\"div\\\")\\n  }, sel_move); },\\n  goLineLeftSmart: function (cm) { return cm.extendSelectionsBy(function (range) {\\n    var top = cm.charCoords(range.head, \\\"div\\\").top + 5\\n    var pos = cm.coordsChar({left: 0, top: top}, \\\"div\\\")\\n    if (pos.ch < cm.getLine(pos.line).search(/\\\\S/)) { return lineStartSmart(cm, range.head) }\\n    return pos\\n  }, sel_move); },\\n  goLineUp: function (cm) { return cm.moveV(-1, \\\"line\\\"); },\\n  goLineDown: function (cm) { return cm.moveV(1, \\\"line\\\"); },\\n  goPageUp: function (cm) { return cm.moveV(-1, \\\"page\\\"); },\\n  goPageDown: function (cm) { return cm.moveV(1, \\\"page\\\"); },\\n  goCharLeft: function (cm) { return cm.moveH(-1, \\\"char\\\"); },\\n  goCharRight: function (cm) { return cm.moveH(1, \\\"char\\\"); },\\n  goColumnLeft: function (cm) { return cm.moveH(-1, \\\"column\\\"); },\\n  goColumnRight: function (cm) { return cm.moveH(1, \\\"column\\\"); },\\n  goWordLeft: function (cm) { return cm.moveH(-1, \\\"word\\\"); },\\n  goGroupRight: function (cm) { return cm.moveH(1, \\\"group\\\"); },\\n  goGroupLeft: function (cm) { return cm.moveH(-1, \\\"group\\\"); },\\n  goWordRight: function (cm) { return cm.moveH(1, \\\"word\\\"); },\\n  delCharBefore: function (cm) { return cm.deleteH(-1, \\\"char\\\"); },\\n  delCharAfter: function (cm) { return cm.deleteH(1, \\\"char\\\"); },\\n  delWordBefore: function (cm) { return cm.deleteH(-1, \\\"word\\\"); },\\n  delWordAfter: function (cm) { return cm.deleteH(1, \\\"word\\\"); },\\n  delGroupBefore: function (cm) { return cm.deleteH(-1, \\\"group\\\"); },\\n  delGroupAfter: function (cm) { return cm.deleteH(1, \\\"group\\\"); },\\n  indentAuto: function (cm) { return cm.indentSelection(\\\"smart\\\"); },\\n  indentMore: function (cm) { return cm.indentSelection(\\\"add\\\"); },\\n  indentLess: function (cm) { return cm.indentSelection(\\\"subtract\\\"); },\\n  insertTab: function (cm) { return cm.replaceSelection(\\\"\\\\t\\\"); },\\n  insertSoftTab: function (cm) {\\n    var spaces = [], ranges = cm.listSelections(), tabSize = cm.options.tabSize\\n    for (var i = 0; i < ranges.length; i++) {\\n      var pos = ranges[i].from()\\n      var col = countColumn(cm.getLine(pos.line), pos.ch, tabSize)\\n      spaces.push(spaceStr(tabSize - col % tabSize))\\n    }\\n    cm.replaceSelections(spaces)\\n  },\\n  defaultTab: function (cm) {\\n    if (cm.somethingSelected()) { cm.indentSelection(\\\"add\\\") }\\n    else { cm.execCommand(\\\"insertTab\\\") }\\n  },\\n  // Swap the two chars left and right of each selection's head.\\n  // Move cursor behind the two swapped characters afterwards.\\n  //\\n  // Doesn't consider line feeds a character.\\n  // Doesn't scan more than one line above to find a character.\\n  // Doesn't do anything on an empty line.\\n  // Doesn't do anything with non-empty selections.\\n  transposeChars: function (cm) { return runInOp(cm, function () {\\n    var ranges = cm.listSelections(), newSel = []\\n    for (var i = 0; i < ranges.length; i++) {\\n      if (!ranges[i].empty()) { continue }\\n      var cur = ranges[i].head, line = getLine(cm.doc, cur.line).text\\n      if (line) {\\n        if (cur.ch == line.length) { cur = new Pos(cur.line, cur.ch - 1) }\\n        if (cur.ch > 0) {\\n          cur = new Pos(cur.line, cur.ch + 1)\\n          cm.replaceRange(line.charAt(cur.ch - 1) + line.charAt(cur.ch - 2),\\n                          Pos(cur.line, cur.ch - 2), cur, \\\"+transpose\\\")\\n        } else if (cur.line > cm.doc.first) {\\n          var prev = getLine(cm.doc, cur.line - 1).text\\n          if (prev) {\\n            cur = new Pos(cur.line, 1)\\n            cm.replaceRange(line.charAt(0) + cm.doc.lineSeparator() +\\n                            prev.charAt(prev.length - 1),\\n                            Pos(cur.line - 1, prev.length - 1), cur, \\\"+transpose\\\")\\n          }\\n        }\\n      }\\n      newSel.push(new Range(cur, cur))\\n    }\\n    cm.setSelections(newSel)\\n  }); },\\n  newlineAndIndent: function (cm) { return runInOp(cm, function () {\\n    var sels = cm.listSelections()\\n    for (var i = sels.length - 1; i >= 0; i--)\\n      { cm.replaceRange(cm.doc.lineSeparator(), sels[i].anchor, sels[i].head, \\\"+input\\\") }\\n    sels = cm.listSelections()\\n    for (var i$1 = 0; i$1 < sels.length; i$1++)\\n      { cm.indentLine(sels[i$1].from().line, null, true) }\\n    ensureCursorVisible(cm)\\n  }); },\\n  openLine: function (cm) { return cm.replaceSelection(\\\"\\\\n\\\", \\\"start\\\"); },\\n  toggleOverwrite: function (cm) { return cm.toggleOverwrite(); }\\n}\\n\\n\\nfunction lineStart(cm, lineN) {\\n  var line = getLine(cm.doc, lineN)\\n  var visual = visualLine(line)\\n  if (visual != line) { lineN = lineNo(visual) }\\n  var order = getOrder(visual)\\n  var ch = !order ? 0 : order[0].level % 2 ? lineRight(visual) : lineLeft(visual)\\n  return Pos(lineN, ch)\\n}\\nfunction lineEnd(cm, lineN) {\\n  var merged, line = getLine(cm.doc, lineN)\\n  while (merged = collapsedSpanAtEnd(line)) {\\n    line = merged.find(1, true).line\\n    lineN = null\\n  }\\n  var order = getOrder(line)\\n  var ch = !order ? line.text.length : order[0].level % 2 ? lineLeft(line) : lineRight(line)\\n  return Pos(lineN == null ? lineNo(line) : lineN, ch)\\n}\\nfunction lineStartSmart(cm, pos) {\\n  var start = lineStart(cm, pos.line)\\n  var line = getLine(cm.doc, start.line)\\n  var order = getOrder(line)\\n  if (!order || order[0].level == 0) {\\n    var firstNonWS = Math.max(0, line.text.search(/\\\\S/))\\n    var inWS = pos.line == start.line && pos.ch <= firstNonWS && pos.ch\\n    return Pos(start.line, inWS ? 0 : firstNonWS)\\n  }\\n  return start\\n}\\n\\n// Run a handler that was bound to a key.\\nfunction doHandleBinding(cm, bound, dropShift) {\\n  if (typeof bound == \\\"string\\\") {\\n    bound = commands[bound]\\n    if (!bound) { return false }\\n  }\\n  // Ensure previous input has been read, so that the handler sees a\\n  // consistent view of the document\\n  cm.display.input.ensurePolled()\\n  var prevShift = cm.display.shift, done = false\\n  try {\\n    if (cm.isReadOnly()) { cm.state.suppressEdits = true }\\n    if (dropShift) { cm.display.shift = false }\\n    done = bound(cm) != Pass\\n  } finally {\\n    cm.display.shift = prevShift\\n    cm.state.suppressEdits = false\\n  }\\n  return done\\n}\\n\\nfunction lookupKeyForEditor(cm, name, handle) {\\n  for (var i = 0; i < cm.state.keyMaps.length; i++) {\\n    var result = lookupKey(name, cm.state.keyMaps[i], handle, cm)\\n    if (result) { return result }\\n  }\\n  return (cm.options.extraKeys && lookupKey(name, cm.options.extraKeys, handle, cm))\\n    || lookupKey(name, cm.options.keyMap, handle, cm)\\n}\\n\\nvar stopSeq = new Delayed\\nfunction dispatchKey(cm, name, e, handle) {\\n  var seq = cm.state.keySeq\\n  if (seq) {\\n    if (isModifierKey(name)) { return \\\"handled\\\" }\\n    stopSeq.set(50, function () {\\n      if (cm.state.keySeq == seq) {\\n        cm.state.keySeq = null\\n        cm.display.input.reset()\\n      }\\n    })\\n    name = seq + \\\" \\\" + name\\n  }\\n  var result = lookupKeyForEditor(cm, name, handle)\\n\\n  if (result == \\\"multi\\\")\\n    { cm.state.keySeq = name }\\n  if (result == \\\"handled\\\")\\n    { signalLater(cm, \\\"keyHandled\\\", cm, name, e) }\\n\\n  if (result == \\\"handled\\\" || result == \\\"multi\\\") {\\n    e_preventDefault(e)\\n    restartBlink(cm)\\n  }\\n\\n  if (seq && !result && /\\\\'$/.test(name)) {\\n    e_preventDefault(e)\\n    return true\\n  }\\n  return !!result\\n}\\n\\n// Handle a key from the keydown event.\\nfunction handleKeyBinding(cm, e) {\\n  var name = keyName(e, true)\\n  if (!name) { return false }\\n\\n  if (e.shiftKey && !cm.state.keySeq) {\\n    // First try to resolve full name (including 'Shift-'). Failing\\n    // that, see if there is a cursor-motion command (starting with\\n    // 'go') bound to the keyname without 'Shift-'.\\n    return dispatchKey(cm, \\\"Shift-\\\" + name, e, function (b) { return doHandleBinding(cm, b, true); })\\n        || dispatchKey(cm, name, e, function (b) {\\n             if (typeof b == \\\"string\\\" ? /^go[A-Z]/.test(b) : b.motion)\\n               { return doHandleBinding(cm, b) }\\n           })\\n  } else {\\n    return dispatchKey(cm, name, e, function (b) { return doHandleBinding(cm, b); })\\n  }\\n}\\n\\n// Handle a key from the keypress event\\nfunction handleCharBinding(cm, e, ch) {\\n  return dispatchKey(cm, \\\"'\\\" + ch + \\\"'\\\", e, function (b) { return doHandleBinding(cm, b, true); })\\n}\\n\\nvar lastStoppedKey = null\\nfunction onKeyDown(e) {\\n  var cm = this\\n  cm.curOp.focus = activeElt()\\n  if (signalDOMEvent(cm, e)) { return }\\n  // IE does strange things with escape.\\n  if (ie && ie_version < 11 && e.keyCode == 27) { e.returnValue = false }\\n  var code = e.keyCode\\n  cm.display.shift = code == 16 || e.shiftKey\\n  var handled = handleKeyBinding(cm, e)\\n  if (presto) {\\n    lastStoppedKey = handled ? code : null\\n    // Opera has no cut event... we try to at least catch the key combo\\n    if (!handled && code == 88 && !hasCopyEvent && (mac ? e.metaKey : e.ctrlKey))\\n      { cm.replaceSelection(\\\"\\\", null, \\\"cut\\\") }\\n  }\\n\\n  // Turn mouse into crosshair when Alt is held on Mac.\\n  if (code == 18 && !/\\\\bCodeMirror-crosshair\\\\b/.test(cm.display.lineDiv.className))\\n    { showCrossHair(cm) }\\n}\\n\\nfunction showCrossHair(cm) {\\n  var lineDiv = cm.display.lineDiv\\n  addClass(lineDiv, \\\"CodeMirror-crosshair\\\")\\n\\n  function up(e) {\\n    if (e.keyCode == 18 || !e.altKey) {\\n      rmClass(lineDiv, \\\"CodeMirror-crosshair\\\")\\n      off(document, \\\"keyup\\\", up)\\n      off(document, \\\"mouseover\\\", up)\\n    }\\n  }\\n  on(document, \\\"keyup\\\", up)\\n  on(document, \\\"mouseover\\\", up)\\n}\\n\\nfunction onKeyUp(e) {\\n  if (e.keyCode == 16) { this.doc.sel.shift = false }\\n  signalDOMEvent(this, e)\\n}\\n\\nfunction onKeyPress(e) {\\n  var cm = this\\n  if (eventInWidget(cm.display, e) || signalDOMEvent(cm, e) || e.ctrlKey && !e.altKey || mac && e.metaKey) { return }\\n  var keyCode = e.keyCode, charCode = e.charCode\\n  if (presto && keyCode == lastStoppedKey) {lastStoppedKey = null; e_preventDefault(e); return}\\n  if ((presto && (!e.which || e.which < 10)) && handleKeyBinding(cm, e)) { return }\\n  var ch = String.fromCharCode(charCode == null ? keyCode : charCode)\\n  // Some browsers fire keypress events for backspace\\n  if (ch == \\\"\\\\x08\\\") { return }\\n  if (handleCharBinding(cm, e, ch)) { return }\\n  cm.display.input.onKeyPress(e)\\n}\\n\\n// A mouse down can be a single click, double click, triple click,\\n// start of selection drag, start of text drag, new cursor\\n// (ctrl-click), rectangle drag (alt-drag), or xwin\\n// middle-click-paste. Or it might be a click on something we should\\n// not interfere with, such as a scrollbar or widget.\\nfunction onMouseDown(e) {\\n  var cm = this, display = cm.display\\n  if (signalDOMEvent(cm, e) || display.activeTouch && display.input.supportsTouch()) { return }\\n  display.shift = e.shiftKey\\n\\n  if (eventInWidget(display, e)) {\\n    if (!webkit) {\\n      // Briefly turn off draggability, to allow widgets to do\\n      // normal dragging things.\\n      display.scroller.draggable = false\\n      setTimeout(function () { return display.scroller.draggable = true; }, 100)\\n    }\\n    return\\n  }\\n  if (clickInGutter(cm, e)) { return }\\n  var start = posFromMouse(cm, e)\\n  window.focus()\\n\\n  switch (e_button(e)) {\\n  case 1:\\n    // #3261: make sure, that we're not starting a second selection\\n    if (cm.state.selectingText)\\n      { cm.state.selectingText(e) }\\n    else if (start)\\n      { leftButtonDown(cm, e, start) }\\n    else if (e_target(e) == display.scroller)\\n      { e_preventDefault(e) }\\n    break\\n  case 2:\\n    if (webkit) { cm.state.lastMiddleDown = +new Date }\\n    if (start) { extendSelection(cm.doc, start) }\\n    setTimeout(function () { return display.input.focus(); }, 20)\\n    e_preventDefault(e)\\n    break\\n  case 3:\\n    if (captureRightClick) { onContextMenu(cm, e) }\\n    else { delayBlurEvent(cm) }\\n    break\\n  }\\n}\\n\\nvar lastClick;\\nvar lastDoubleClick;\\nfunction leftButtonDown(cm, e, start) {\\n  if (ie) { setTimeout(bind(ensureFocus, cm), 0) }\\n  else { cm.curOp.focus = activeElt() }\\n\\n  var now = +new Date, type\\n  if (lastDoubleClick && lastDoubleClick.time > now - 400 && cmp(lastDoubleClick.pos, start) == 0) {\\n    type = \\\"triple\\\"\\n  } else if (lastClick && lastClick.time > now - 400 && cmp(lastClick.pos, start) == 0) {\\n    type = \\\"double\\\"\\n    lastDoubleClick = {time: now, pos: start}\\n  } else {\\n    type = \\\"single\\\"\\n    lastClick = {time: now, pos: start}\\n  }\\n\\n  var sel = cm.doc.sel, modifier = mac ? e.metaKey : e.ctrlKey, contained\\n  if (cm.options.dragDrop && dragAndDrop && !cm.isReadOnly() &&\\n      type == \\\"single\\\" && (contained = sel.contains(start)) > -1 &&\\n      (cmp((contained = sel.ranges[contained]).from(), start) < 0 || start.xRel > 0) &&\\n      (cmp(contained.to(), start) > 0 || start.xRel < 0))\\n    { leftButtonStartDrag(cm, e, start, modifier) }\\n  else\\n    { leftButtonSelect(cm, e, start, type, modifier) }\\n}\\n\\n// Start a text drag. When it ends, see if any dragging actually\\n// happen, and treat as a click if it didn't.\\nfunction leftButtonStartDrag(cm, e, start, modifier) {\\n  var display = cm.display, startTime = +new Date\\n  var dragEnd = operation(cm, function (e2) {\\n    if (webkit) { display.scroller.draggable = false }\\n    cm.state.draggingText = false\\n    off(document, \\\"mouseup\\\", dragEnd)\\n    off(display.scroller, \\\"drop\\\", dragEnd)\\n    if (Math.abs(e.clientX - e2.clientX) + Math.abs(e.clientY - e2.clientY) < 10) {\\n      e_preventDefault(e2)\\n      if (!modifier && +new Date - 200 < startTime)\\n        { extendSelection(cm.doc, start) }\\n      // Work around unexplainable focus problem in IE9 (#2127) and Chrome (#3081)\\n      if (webkit || ie && ie_version == 9)\\n        { setTimeout(function () {document.body.focus(); display.input.focus()}, 20) }\\n      else\\n        { display.input.focus() }\\n    }\\n  })\\n  // Let the drag handler handle this.\\n  if (webkit) { display.scroller.draggable = true }\\n  cm.state.draggingText = dragEnd\\n  dragEnd.copy = mac ? e.altKey : e.ctrlKey\\n  // IE's approach to draggable\\n  if (display.scroller.dragDrop) { display.scroller.dragDrop() }\\n  on(document, \\\"mouseup\\\", dragEnd)\\n  on(display.scroller, \\\"drop\\\", dragEnd)\\n}\\n\\n// Normal selection, as opposed to text dragging.\\nfunction leftButtonSelect(cm, e, start, type, addNew) {\\n  var display = cm.display, doc = cm.doc\\n  e_preventDefault(e)\\n\\n  var ourRange, ourIndex, startSel = doc.sel, ranges = startSel.ranges\\n  if (addNew && !e.shiftKey) {\\n    ourIndex = doc.sel.contains(start)\\n    if (ourIndex > -1)\\n      { ourRange = ranges[ourIndex] }\\n    else\\n      { ourRange = new Range(start, start) }\\n  } else {\\n    ourRange = doc.sel.primary()\\n    ourIndex = doc.sel.primIndex\\n  }\\n\\n  if (chromeOS ? e.shiftKey && e.metaKey : e.altKey) {\\n    type = \\\"rect\\\"\\n    if (!addNew) { ourRange = new Range(start, start) }\\n    start = posFromMouse(cm, e, true, true)\\n    ourIndex = -1\\n  } else if (type == \\\"double\\\") {\\n    var word = cm.findWordAt(start)\\n    if (cm.display.shift || doc.extend)\\n      { ourRange = extendRange(doc, ourRange, word.anchor, word.head) }\\n    else\\n      { ourRange = word }\\n  } else if (type == \\\"triple\\\") {\\n    var line = new Range(Pos(start.line, 0), clipPos(doc, Pos(start.line + 1, 0)))\\n    if (cm.display.shift || doc.extend)\\n      { ourRange = extendRange(doc, ourRange, line.anchor, line.head) }\\n    else\\n      { ourRange = line }\\n  } else {\\n    ourRange = extendRange(doc, ourRange, start)\\n  }\\n\\n  if (!addNew) {\\n    ourIndex = 0\\n    setSelection(doc, new Selection([ourRange], 0), sel_mouse)\\n    startSel = doc.sel\\n  } else if (ourIndex == -1) {\\n    ourIndex = ranges.length\\n    setSelection(doc, normalizeSelection(ranges.concat([ourRange]), ourIndex),\\n                 {scroll: false, origin: \\\"*mouse\\\"})\\n  } else if (ranges.length > 1 && ranges[ourIndex].empty() && type == \\\"single\\\" && !e.shiftKey) {\\n    setSelection(doc, normalizeSelection(ranges.slice(0, ourIndex).concat(ranges.slice(ourIndex + 1)), 0),\\n                 {scroll: false, origin: \\\"*mouse\\\"})\\n    startSel = doc.sel\\n  } else {\\n    replaceOneSelection(doc, ourIndex, ourRange, sel_mouse)\\n  }\\n\\n  var lastPos = start\\n  function extendTo(pos) {\\n    if (cmp(lastPos, pos) == 0) { return }\\n    lastPos = pos\\n\\n    if (type == \\\"rect\\\") {\\n      var ranges = [], tabSize = cm.options.tabSize\\n      var startCol = countColumn(getLine(doc, start.line).text, start.ch, tabSize)\\n      var posCol = countColumn(getLine(doc, pos.line).text, pos.ch, tabSize)\\n      var left = Math.min(startCol, posCol), right = Math.max(startCol, posCol)\\n      for (var line = Math.min(start.line, pos.line), end = Math.min(cm.lastLine(), Math.max(start.line, pos.line));\\n           line <= end; line++) {\\n        var text = getLine(doc, line).text, leftPos = findColumn(text, left, tabSize)\\n        if (left == right)\\n          { ranges.push(new Range(Pos(line, leftPos), Pos(line, leftPos))) }\\n        else if (text.length > leftPos)\\n          { ranges.push(new Range(Pos(line, leftPos), Pos(line, findColumn(text, right, tabSize)))) }\\n      }\\n      if (!ranges.length) { ranges.push(new Range(start, start)) }\\n      setSelection(doc, normalizeSelection(startSel.ranges.slice(0, ourIndex).concat(ranges), ourIndex),\\n                   {origin: \\\"*mouse\\\", scroll: false})\\n      cm.scrollIntoView(pos)\\n    } else {\\n      var oldRange = ourRange\\n      var anchor = oldRange.anchor, head = pos\\n      if (type != \\\"single\\\") {\\n        var range\\n        if (type == \\\"double\\\")\\n          { range = cm.findWordAt(pos) }\\n        else\\n          { range = new Range(Pos(pos.line, 0), clipPos(doc, Pos(pos.line + 1, 0))) }\\n        if (cmp(range.anchor, anchor) > 0) {\\n          head = range.head\\n          anchor = minPos(oldRange.from(), range.anchor)\\n        } else {\\n          head = range.anchor\\n          anchor = maxPos(oldRange.to(), range.head)\\n        }\\n      }\\n      var ranges$1 = startSel.ranges.slice(0)\\n      ranges$1[ourIndex] = new Range(clipPos(doc, anchor), head)\\n      setSelection(doc, normalizeSelection(ranges$1, ourIndex), sel_mouse)\\n    }\\n  }\\n\\n  var editorSize = display.wrapper.getBoundingClientRect()\\n  // Used to ensure timeout re-tries don't fire when another extend\\n  // happened in the meantime (clearTimeout isn't reliable -- at\\n  // least on Chrome, the timeouts still happen even when cleared,\\n  // if the clear happens after their scheduled firing time).\\n  var counter = 0\\n\\n  function extend(e) {\\n    var curCount = ++counter\\n    var cur = posFromMouse(cm, e, true, type == \\\"rect\\\")\\n    if (!cur) { return }\\n    if (cmp(cur, lastPos) != 0) {\\n      cm.curOp.focus = activeElt()\\n      extendTo(cur)\\n      var visible = visibleLines(display, doc)\\n      if (cur.line >= visible.to || cur.line < visible.from)\\n        { setTimeout(operation(cm, function () {if (counter == curCount) { extend(e) }}), 150) }\\n    } else {\\n      var outside = e.clientY < editorSize.top ? -20 : e.clientY > editorSize.bottom ? 20 : 0\\n      if (outside) { setTimeout(operation(cm, function () {\\n        if (counter != curCount) { return }\\n        display.scroller.scrollTop += outside\\n        extend(e)\\n      }), 50) }\\n    }\\n  }\\n\\n  function done(e) {\\n    cm.state.selectingText = false\\n    counter = Infinity\\n    e_preventDefault(e)\\n    display.input.focus()\\n    off(document, \\\"mousemove\\\", move)\\n    off(document, \\\"mouseup\\\", up)\\n    doc.history.lastSelOrigin = null\\n  }\\n\\n  var move = operation(cm, function (e) {\\n    if (!e_button(e)) { done(e) }\\n    else { extend(e) }\\n  })\\n  var up = operation(cm, done)\\n  cm.state.selectingText = up\\n  on(document, \\\"mousemove\\\", move)\\n  on(document, \\\"mouseup\\\", up)\\n}\\n\\n\\n// Determines whether an event happened in the gutter, and fires the\\n// handlers for the corresponding event.\\nfunction gutterEvent(cm, e, type, prevent) {\\n  var mX, mY\\n  try { mX = e.clientX; mY = e.clientY }\\n  catch(e) { return false }\\n  if (mX >= Math.floor(cm.display.gutters.getBoundingClientRect().right)) { return false }\\n  if (prevent) { e_preventDefault(e) }\\n\\n  var display = cm.display\\n  var lineBox = display.lineDiv.getBoundingClientRect()\\n\\n  if (mY > lineBox.bottom || !hasHandler(cm, type)) { return e_defaultPrevented(e) }\\n  mY -= lineBox.top - display.viewOffset\\n\\n  for (var i = 0; i < cm.options.gutters.length; ++i) {\\n    var g = display.gutters.childNodes[i]\\n    if (g && g.getBoundingClientRect().right >= mX) {\\n      var line = lineAtHeight(cm.doc, mY)\\n      var gutter = cm.options.gutters[i]\\n      signal(cm, type, cm, line, gutter, e)\\n      return e_defaultPrevented(e)\\n    }\\n  }\\n}\\n\\nfunction clickInGutter(cm, e) {\\n  return gutterEvent(cm, e, \\\"gutterClick\\\", true)\\n}\\n\\n// CONTEXT MENU HANDLING\\n\\n// To make the context menu work, we need to briefly unhide the\\n// textarea (making it as unobtrusive as possible) to let the\\n// right-click take effect on it.\\nfunction onContextMenu(cm, e) {\\n  if (eventInWidget(cm.display, e) || contextMenuInGutter(cm, e)) { return }\\n  if (signalDOMEvent(cm, e, \\\"contextmenu\\\")) { return }\\n  cm.display.input.onContextMenu(e)\\n}\\n\\nfunction contextMenuInGutter(cm, e) {\\n  if (!hasHandler(cm, \\\"gutterContextMenu\\\")) { return false }\\n  return gutterEvent(cm, e, \\\"gutterContextMenu\\\", false)\\n}\\n\\nfunction themeChanged(cm) {\\n  cm.display.wrapper.className = cm.display.wrapper.className.replace(/\\\\s*cm-s-\\\\S+/g, \\\"\\\") +\\n    cm.options.theme.replace(/(^|\\\\s)\\\\s*/g, \\\" cm-s-\\\")\\n  clearCaches(cm)\\n}\\n\\nvar Init = {toString: function(){return \\\"CodeMirror.Init\\\"}}\\n\\nvar defaults = {}\\nvar optionHandlers = {}\\n\\nfunction defineOptions(CodeMirror) {\\n  var optionHandlers = CodeMirror.optionHandlers\\n\\n  function option(name, deflt, handle, notOnInit) {\\n    CodeMirror.defaults[name] = deflt\\n    if (handle) { optionHandlers[name] =\\n      notOnInit ? function (cm, val, old) {if (old != Init) { handle(cm, val, old) }} : handle }\\n  }\\n\\n  CodeMirror.defineOption = option\\n\\n  // Passed to option handlers when there is no old value.\\n  CodeMirror.Init = Init\\n\\n  // These two are, on init, called from the constructor because they\\n  // have to be initialized before the editor can start at all.\\n  option(\\\"value\\\", \\\"\\\", function (cm, val) { return cm.setValue(val); }, true)\\n  option(\\\"mode\\\", null, function (cm, val) {\\n    cm.doc.modeOption = val\\n    loadMode(cm)\\n  }, true)\\n\\n  option(\\\"indentUnit\\\", 2, loadMode, true)\\n  option(\\\"indentWithTabs\\\", false)\\n  option(\\\"smartIndent\\\", true)\\n  option(\\\"tabSize\\\", 4, function (cm) {\\n    resetModeState(cm)\\n    clearCaches(cm)\\n    regChange(cm)\\n  }, true)\\n  option(\\\"lineSeparator\\\", null, function (cm, val) {\\n    cm.doc.lineSep = val\\n    if (!val) { return }\\n    var newBreaks = [], lineNo = cm.doc.first\\n    cm.doc.iter(function (line) {\\n      for (var pos = 0;;) {\\n        var found = line.text.indexOf(val, pos)\\n        if (found == -1) { break }\\n        pos = found + val.length\\n        newBreaks.push(Pos(lineNo, found))\\n      }\\n      lineNo++\\n    })\\n    for (var i = newBreaks.length - 1; i >= 0; i--)\\n      { replaceRange(cm.doc, val, newBreaks[i], Pos(newBreaks[i].line, newBreaks[i].ch + val.length)) }\\n  })\\n  option(\\\"specialChars\\\", /[\\\\u0000-\\\\u001f\\\\u007f\\\\u00ad\\\\u200b-\\\\u200f\\\\u2028\\\\u2029\\\\ufeff]/g, function (cm, val, old) {\\n    cm.state.specialChars = new RegExp(val.source + (val.test(\\\"\\\\t\\\") ? \\\"\\\" : \\\"|\\\\t\\\"), \\\"g\\\")\\n    if (old != Init) { cm.refresh() }\\n  })\\n  option(\\\"specialCharPlaceholder\\\", defaultSpecialCharPlaceholder, function (cm) { return cm.refresh(); }, true)\\n  option(\\\"electricChars\\\", true)\\n  option(\\\"inputStyle\\\", mobile ? \\\"contenteditable\\\" : \\\"textarea\\\", function () {\\n    throw new Error(\\\"inputStyle can not (yet) be changed in a running editor\\\") // FIXME\\n  }, true)\\n  option(\\\"spellcheck\\\", false, function (cm, val) { return cm.getInputField().spellcheck = val; }, true)\\n  option(\\\"rtlMoveVisually\\\", !windows)\\n  option(\\\"wholeLineUpdateBefore\\\", true)\\n\\n  option(\\\"theme\\\", \\\"default\\\", function (cm) {\\n    themeChanged(cm)\\n    guttersChanged(cm)\\n  }, true)\\n  option(\\\"keyMap\\\", \\\"default\\\", function (cm, val, old) {\\n    var next = getKeyMap(val)\\n    var prev = old != Init && getKeyMap(old)\\n    if (prev && prev.detach) { prev.detach(cm, next) }\\n    if (next.attach) { next.attach(cm, prev || null) }\\n  })\\n  option(\\\"extraKeys\\\", null)\\n\\n  option(\\\"lineWrapping\\\", false, wrappingChanged, true)\\n  option(\\\"gutters\\\", [], function (cm) {\\n    setGuttersForLineNumbers(cm.options)\\n    guttersChanged(cm)\\n  }, true)\\n  option(\\\"fixedGutter\\\", true, function (cm, val) {\\n    cm.display.gutters.style.left = val ? compensateForHScroll(cm.display) + \\\"px\\\" : \\\"0\\\"\\n    cm.refresh()\\n  }, true)\\n  option(\\\"coverGutterNextToScrollbar\\\", false, function (cm) { return updateScrollbars(cm); }, true)\\n  option(\\\"scrollbarStyle\\\", \\\"native\\\", function (cm) {\\n    initScrollbars(cm)\\n    updateScrollbars(cm)\\n    cm.display.scrollbars.setScrollTop(cm.doc.scrollTop)\\n    cm.display.scrollbars.setScrollLeft(cm.doc.scrollLeft)\\n  }, true)\\n  option(\\\"lineNumbers\\\", false, function (cm) {\\n    setGuttersForLineNumbers(cm.options)\\n    guttersChanged(cm)\\n  }, true)\\n  option(\\\"firstLineNumber\\\", 1, guttersChanged, true)\\n  option(\\\"lineNumberFormatter\\\", function (integer) { return integer; }, guttersChanged, true)\\n  option(\\\"showCursorWhenSelecting\\\", false, updateSelection, true)\\n\\n  option(\\\"resetSelectionOnContextMenu\\\", true)\\n  option(\\\"lineWiseCopyCut\\\", true)\\n\\n  option(\\\"readOnly\\\", false, function (cm, val) {\\n    if (val == \\\"nocursor\\\") {\\n      onBlur(cm)\\n      cm.display.input.blur()\\n      cm.display.disabled = true\\n    } else {\\n      cm.display.disabled = false\\n    }\\n    cm.display.input.readOnlyChanged(val)\\n  })\\n  option(\\\"disableInput\\\", false, function (cm, val) {if (!val) { cm.display.input.reset() }}, true)\\n  option(\\\"dragDrop\\\", true, dragDropChanged)\\n  option(\\\"allowDropFileTypes\\\", null)\\n\\n  option(\\\"cursorBlinkRate\\\", 530)\\n  option(\\\"cursorScrollMargin\\\", 0)\\n  option(\\\"cursorHeight\\\", 1, updateSelection, true)\\n  option(\\\"singleCursorHeightPerLine\\\", true, updateSelection, true)\\n  option(\\\"workTime\\\", 100)\\n  option(\\\"workDelay\\\", 100)\\n  option(\\\"flattenSpans\\\", true, resetModeState, true)\\n  option(\\\"addModeClass\\\", false, resetModeState, true)\\n  option(\\\"pollInterval\\\", 100)\\n  option(\\\"undoDepth\\\", 200, function (cm, val) { return cm.doc.history.undoDepth = val; })\\n  option(\\\"historyEventDelay\\\", 1250)\\n  option(\\\"viewportMargin\\\", 10, function (cm) { return cm.refresh(); }, true)\\n  option(\\\"maxHighlightLength\\\", 10000, resetModeState, true)\\n  option(\\\"moveInputWithCursor\\\", true, function (cm, val) {\\n    if (!val) { cm.display.input.resetPosition() }\\n  })\\n\\n  option(\\\"tabindex\\\", null, function (cm, val) { return cm.display.input.getField().tabIndex = val || \\\"\\\"; })\\n  option(\\\"autofocus\\\", null)\\n}\\n\\nfunction guttersChanged(cm) {\\n  updateGutters(cm)\\n  regChange(cm)\\n  setTimeout(function () { return alignHorizontally(cm); }, 20)\\n}\\n\\nfunction dragDropChanged(cm, value, old) {\\n  var wasOn = old && old != Init\\n  if (!value != !wasOn) {\\n    var funcs = cm.display.dragFunctions\\n    var toggle = value ? on : off\\n    toggle(cm.display.scroller, \\\"dragstart\\\", funcs.start)\\n    toggle(cm.display.scroller, \\\"dragenter\\\", funcs.enter)\\n    toggle(cm.display.scroller, \\\"dragover\\\", funcs.over)\\n    toggle(cm.display.scroller, \\\"dragleave\\\", funcs.leave)\\n    toggle(cm.display.scroller, \\\"drop\\\", funcs.drop)\\n  }\\n}\\n\\nfunction wrappingChanged(cm) {\\n  if (cm.options.lineWrapping) {\\n    addClass(cm.display.wrapper, \\\"CodeMirror-wrap\\\")\\n    cm.display.sizer.style.minWidth = \\\"\\\"\\n    cm.display.sizerWidth = null\\n  } else {\\n    rmClass(cm.display.wrapper, \\\"CodeMirror-wrap\\\")\\n    findMaxLine(cm)\\n  }\\n  estimateLineHeights(cm)\\n  regChange(cm)\\n  clearCaches(cm)\\n  setTimeout(function () { return updateScrollbars(cm); }, 100)\\n}\\n\\n// A CodeMirror instance represents an editor. This is the object\\n// that user code is usually dealing with.\\n\\nfunction CodeMirror(place, options) {\\n  var this$1 = this;\\n\\n  if (!(this instanceof CodeMirror)) { return new CodeMirror(place, options) }\\n\\n  this.options = options = options ? copyObj(options) : {}\\n  // Determine effective options based on given values and defaults.\\n  copyObj(defaults, options, false)\\n  setGuttersForLineNumbers(options)\\n\\n  var doc = options.value\\n  if (typeof doc == \\\"string\\\") { doc = new Doc(doc, options.mode, null, options.lineSeparator) }\\n  this.doc = doc\\n\\n  var input = new CodeMirror.inputStyles[options.inputStyle](this)\\n  var display = this.display = new Display(place, doc, input)\\n  display.wrapper.CodeMirror = this\\n  updateGutters(this)\\n  themeChanged(this)\\n  if (options.lineWrapping)\\n    { this.display.wrapper.className += \\\" CodeMirror-wrap\\\" }\\n  if (options.autofocus && !mobile) { display.input.focus() }\\n  initScrollbars(this)\\n\\n  this.state = {\\n    keyMaps: [],  // stores maps added by addKeyMap\\n    overlays: [], // highlighting overlays, as added by addOverlay\\n    modeGen: 0,   // bumped when mode/overlay changes, used to invalidate highlighting info\\n    overwrite: false,\\n    delayingBlurEvent: false,\\n    focused: false,\\n    suppressEdits: false, // used to disable editing during key handlers when in readOnly mode\\n    pasteIncoming: false, cutIncoming: false, // help recognize paste/cut edits in input.poll\\n    selectingText: false,\\n    draggingText: false,\\n    highlight: new Delayed(), // stores highlight worker timeout\\n    keySeq: null,  // Unfinished key sequence\\n    specialChars: null\\n  }\\n\\n  // Override magic textarea content restore that IE sometimes does\\n  // on our hidden textarea on reload\\n  if (ie && ie_version < 11) { setTimeout(function () { return this$1.display.input.reset(true); }, 20) }\\n\\n  registerEventHandlers(this)\\n  ensureGlobalHandlers()\\n\\n  startOperation(this)\\n  this.curOp.forceUpdate = true\\n  attachDoc(this, doc)\\n\\n  if ((options.autofocus && !mobile) || this.hasFocus())\\n    { setTimeout(bind(onFocus, this), 20) }\\n  else\\n    { onBlur(this) }\\n\\n  for (var opt in optionHandlers) { if (optionHandlers.hasOwnProperty(opt))\\n    { optionHandlers[opt](this$1, options[opt], Init) } }\\n  maybeUpdateLineNumberWidth(this)\\n  if (options.finishInit) { options.finishInit(this) }\\n  for (var i = 0; i < initHooks.length; ++i) { initHooks[i](this$1) }\\n  endOperation(this)\\n  // Suppress optimizelegibility in Webkit, since it breaks text\\n  // measuring on line wrapping boundaries.\\n  if (webkit && options.lineWrapping &&\\n      getComputedStyle(display.lineDiv).textRendering == \\\"optimizelegibility\\\")\\n    { display.lineDiv.style.textRendering = \\\"auto\\\" }\\n}\\n\\n// The default configuration options.\\nCodeMirror.defaults = defaults\\n// Functions to run when options are changed.\\nCodeMirror.optionHandlers = optionHandlers\\n\\n// Attach the necessary event handlers when initializing the editor\\nfunction registerEventHandlers(cm) {\\n  var d = cm.display\\n  on(d.scroller, \\\"mousedown\\\", operation(cm, onMouseDown))\\n  // Older IE's will not fire a second mousedown for a double click\\n  if (ie && ie_version < 11)\\n    { on(d.scroller, \\\"dblclick\\\", operation(cm, function (e) {\\n      if (signalDOMEvent(cm, e)) { return }\\n      var pos = posFromMouse(cm, e)\\n      if (!pos || clickInGutter(cm, e) || eventInWidget(cm.display, e)) { return }\\n      e_preventDefault(e)\\n      var word = cm.findWordAt(pos)\\n      extendSelection(cm.doc, word.anchor, word.head)\\n    })) }\\n  else\\n    { on(d.scroller, \\\"dblclick\\\", function (e) { return signalDOMEvent(cm, e) || e_preventDefault(e); }) }\\n  // Some browsers fire contextmenu *after* opening the menu, at\\n  // which point we can't mess with it anymore. Context menu is\\n  // handled in onMouseDown for these browsers.\\n  if (!captureRightClick) { on(d.scroller, \\\"contextmenu\\\", function (e) { return onContextMenu(cm, e); }) }\\n\\n  // Used to suppress mouse event handling when a touch happens\\n  var touchFinished, prevTouch = {end: 0}\\n  function finishTouch() {\\n    if (d.activeTouch) {\\n      touchFinished = setTimeout(function () { return d.activeTouch = null; }, 1000)\\n      prevTouch = d.activeTouch\\n      prevTouch.end = +new Date\\n    }\\n  }\\n  function isMouseLikeTouchEvent(e) {\\n    if (e.touches.length != 1) { return false }\\n    var touch = e.touches[0]\\n    return touch.radiusX <= 1 && touch.radiusY <= 1\\n  }\\n  function farAway(touch, other) {\\n    if (other.left == null) { return true }\\n    var dx = other.left - touch.left, dy = other.top - touch.top\\n    return dx * dx + dy * dy > 20 * 20\\n  }\\n  on(d.scroller, \\\"touchstart\\\", function (e) {\\n    if (!signalDOMEvent(cm, e) && !isMouseLikeTouchEvent(e)) {\\n      clearTimeout(touchFinished)\\n      var now = +new Date\\n      d.activeTouch = {start: now, moved: false,\\n                       prev: now - prevTouch.end <= 300 ? prevTouch : null}\\n      if (e.touches.length == 1) {\\n        d.activeTouch.left = e.touches[0].pageX\\n        d.activeTouch.top = e.touches[0].pageY\\n      }\\n    }\\n  })\\n  on(d.scroller, \\\"touchmove\\\", function () {\\n    if (d.activeTouch) { d.activeTouch.moved = true }\\n  })\\n  on(d.scroller, \\\"touchend\\\", function (e) {\\n    var touch = d.activeTouch\\n    if (touch && !eventInWidget(d, e) && touch.left != null &&\\n        !touch.moved && new Date - touch.start < 300) {\\n      var pos = cm.coordsChar(d.activeTouch, \\\"page\\\"), range\\n      if (!touch.prev || farAway(touch, touch.prev)) // Single tap\\n        { range = new Range(pos, pos) }\\n      else if (!touch.prev.prev || farAway(touch, touch.prev.prev)) // Double tap\\n        { range = cm.findWordAt(pos) }\\n      else // Triple tap\\n        { range = new Range(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0))) }\\n      cm.setSelection(range.anchor, range.head)\\n      cm.focus()\\n      e_preventDefault(e)\\n    }\\n    finishTouch()\\n  })\\n  on(d.scroller, \\\"touchcancel\\\", finishTouch)\\n\\n  // Sync scrolling between fake scrollbars and real scrollable\\n  // area, ensure viewport is updated when scrolling.\\n  on(d.scroller, \\\"scroll\\\", function () {\\n    if (d.scroller.clientHeight) {\\n      setScrollTop(cm, d.scroller.scrollTop)\\n      setScrollLeft(cm, d.scroller.scrollLeft, true)\\n      signal(cm, \\\"scroll\\\", cm)\\n    }\\n  })\\n\\n  // Listen to wheel events in order to try and update the viewport on time.\\n  on(d.scroller, \\\"mousewheel\\\", function (e) { return onScrollWheel(cm, e); })\\n  on(d.scroller, \\\"DOMMouseScroll\\\", function (e) { return onScrollWheel(cm, e); })\\n\\n  // Prevent wrapper from ever scrolling\\n  on(d.wrapper, \\\"scroll\\\", function () { return d.wrapper.scrollTop = d.wrapper.scrollLeft = 0; })\\n\\n  d.dragFunctions = {\\n    enter: function (e) {if (!signalDOMEvent(cm, e)) { e_stop(e) }},\\n    over: function (e) {if (!signalDOMEvent(cm, e)) { onDragOver(cm, e); e_stop(e) }},\\n    start: function (e) { return onDragStart(cm, e); },\\n    drop: operation(cm, onDrop),\\n    leave: function (e) {if (!signalDOMEvent(cm, e)) { clearDragCursor(cm) }}\\n  }\\n\\n  var inp = d.input.getField()\\n  on(inp, \\\"keyup\\\", function (e) { return onKeyUp.call(cm, e); })\\n  on(inp, \\\"keydown\\\", operation(cm, onKeyDown))\\n  on(inp, \\\"keypress\\\", operation(cm, onKeyPress))\\n  on(inp, \\\"focus\\\", function (e) { return onFocus(cm, e); })\\n  on(inp, \\\"blur\\\", function (e) { return onBlur(cm, e); })\\n}\\n\\nvar initHooks = []\\nCodeMirror.defineInitHook = function (f) { return initHooks.push(f); }\\n\\n// Indent the given line. The how parameter can be \\\"smart\\\",\\n// \\\"add\\\"/null, \\\"subtract\\\", or \\\"prev\\\". When aggressive is false\\n// (typically set to true for forced single-line indents), empty\\n// lines are not indented, and places where the mode returns Pass\\n// are left alone.\\nfunction indentLine(cm, n, how, aggressive) {\\n  var doc = cm.doc, state\\n  if (how == null) { how = \\\"add\\\" }\\n  if (how == \\\"smart\\\") {\\n    // Fall back to \\\"prev\\\" when the mode doesn't have an indentation\\n    // method.\\n    if (!doc.mode.indent) { how = \\\"prev\\\" }\\n    else { state = getStateBefore(cm, n) }\\n  }\\n\\n  var tabSize = cm.options.tabSize\\n  var line = getLine(doc, n), curSpace = countColumn(line.text, null, tabSize)\\n  if (line.stateAfter) { line.stateAfter = null }\\n  var curSpaceString = line.text.match(/^\\\\s*/)[0], indentation\\n  if (!aggressive && !/\\\\S/.test(line.text)) {\\n    indentation = 0\\n    how = \\\"not\\\"\\n  } else if (how == \\\"smart\\\") {\\n    indentation = doc.mode.indent(state, line.text.slice(curSpaceString.length), line.text)\\n    if (indentation == Pass || indentation > 150) {\\n      if (!aggressive) { return }\\n      how = \\\"prev\\\"\\n    }\\n  }\\n  if (how == \\\"prev\\\") {\\n    if (n > doc.first) { indentation = countColumn(getLine(doc, n-1).text, null, tabSize) }\\n    else { indentation = 0 }\\n  } else if (how == \\\"add\\\") {\\n    indentation = curSpace + cm.options.indentUnit\\n  } else if (how == \\\"subtract\\\") {\\n    indentation = curSpace - cm.options.indentUnit\\n  } else if (typeof how == \\\"number\\\") {\\n    indentation = curSpace + how\\n  }\\n  indentation = Math.max(0, indentation)\\n\\n  var indentString = \\\"\\\", pos = 0\\n  if (cm.options.indentWithTabs)\\n    { for (var i = Math.floor(indentation / tabSize); i; --i) {pos += tabSize; indentString += \\\"\\\\t\\\"} }\\n  if (pos < indentation) { indentString += spaceStr(indentation - pos) }\\n\\n  if (indentString != curSpaceString) {\\n    replaceRange(doc, indentString, Pos(n, 0), Pos(n, curSpaceString.length), \\\"+input\\\")\\n    line.stateAfter = null\\n    return true\\n  } else {\\n    // Ensure that, if the cursor was in the whitespace at the start\\n    // of the line, it is moved to the end of that space.\\n    for (var i$1 = 0; i$1 < doc.sel.ranges.length; i$1++) {\\n      var range = doc.sel.ranges[i$1]\\n      if (range.head.line == n && range.head.ch < curSpaceString.length) {\\n        var pos$1 = Pos(n, curSpaceString.length)\\n        replaceOneSelection(doc, i$1, new Range(pos$1, pos$1))\\n        break\\n      }\\n    }\\n  }\\n}\\n\\n// This will be set to a {lineWise: bool, text: [string]} object, so\\n// that, when pasting, we know what kind of selections the copied\\n// text was made out of.\\nvar lastCopied = null\\n\\nfunction setLastCopied(newLastCopied) {\\n  lastCopied = newLastCopied\\n}\\n\\nfunction applyTextInput(cm, inserted, deleted, sel, origin) {\\n  var doc = cm.doc\\n  cm.display.shift = false\\n  if (!sel) { sel = doc.sel }\\n\\n  var paste = cm.state.pasteIncoming || origin == \\\"paste\\\"\\n  var textLines = splitLinesAuto(inserted), multiPaste = null\\n  // When pasing N lines into N selections, insert one line per selection\\n  if (paste && sel.ranges.length > 1) {\\n    if (lastCopied && lastCopied.text.join(\\\"\\\\n\\\") == inserted) {\\n      if (sel.ranges.length % lastCopied.text.length == 0) {\\n        multiPaste = []\\n        for (var i = 0; i < lastCopied.text.length; i++)\\n          { multiPaste.push(doc.splitLines(lastCopied.text[i])) }\\n      }\\n    } else if (textLines.length == sel.ranges.length) {\\n      multiPaste = map(textLines, function (l) { return [l]; })\\n    }\\n  }\\n\\n  var updateInput\\n  // Normal behavior is to insert the new text into every selection\\n  for (var i$1 = sel.ranges.length - 1; i$1 >= 0; i$1--) {\\n    var range = sel.ranges[i$1]\\n    var from = range.from(), to = range.to()\\n    if (range.empty()) {\\n      if (deleted && deleted > 0) // Handle deletion\\n        { from = Pos(from.line, from.ch - deleted) }\\n      else if (cm.state.overwrite && !paste) // Handle overwrite\\n        { to = Pos(to.line, Math.min(getLine(doc, to.line).text.length, to.ch + lst(textLines).length)) }\\n      else if (lastCopied && lastCopied.lineWise && lastCopied.text.join(\\\"\\\\n\\\") == inserted)\\n        { from = to = Pos(from.line, 0) }\\n    }\\n    updateInput = cm.curOp.updateInput\\n    var changeEvent = {from: from, to: to, text: multiPaste ? multiPaste[i$1 % multiPaste.length] : textLines,\\n                       origin: origin || (paste ? \\\"paste\\\" : cm.state.cutIncoming ? \\\"cut\\\" : \\\"+input\\\")}\\n    makeChange(cm.doc, changeEvent)\\n    signalLater(cm, \\\"inputRead\\\", cm, changeEvent)\\n  }\\n  if (inserted && !paste)\\n    { triggerElectric(cm, inserted) }\\n\\n  ensureCursorVisible(cm)\\n  cm.curOp.updateInput = updateInput\\n  cm.curOp.typing = true\\n  cm.state.pasteIncoming = cm.state.cutIncoming = false\\n}\\n\\nfunction handlePaste(e, cm) {\\n  var pasted = e.clipboardData && e.clipboardData.getData(\\\"Text\\\")\\n  if (pasted) {\\n    e.preventDefault()\\n    if (!cm.isReadOnly() && !cm.options.disableInput)\\n      { runInOp(cm, function () { return applyTextInput(cm, pasted, 0, null, \\\"paste\\\"); }) }\\n    return true\\n  }\\n}\\n\\nfunction triggerElectric(cm, inserted) {\\n  // When an 'electric' character is inserted, immediately trigger a reindent\\n  if (!cm.options.electricChars || !cm.options.smartIndent) { return }\\n  var sel = cm.doc.sel\\n\\n  for (var i = sel.ranges.length - 1; i >= 0; i--) {\\n    var range = sel.ranges[i]\\n    if (range.head.ch > 100 || (i && sel.ranges[i - 1].head.line == range.head.line)) { continue }\\n    var mode = cm.getModeAt(range.head)\\n    var indented = false\\n    if (mode.electricChars) {\\n      for (var j = 0; j < mode.electricChars.length; j++)\\n        { if (inserted.indexOf(mode.electricChars.charAt(j)) > -1) {\\n          indented = indentLine(cm, range.head.line, \\\"smart\\\")\\n          break\\n        } }\\n    } else if (mode.electricInput) {\\n      if (mode.electricInput.test(getLine(cm.doc, range.head.line).text.slice(0, range.head.ch)))\\n        { indented = indentLine(cm, range.head.line, \\\"smart\\\") }\\n    }\\n    if (indented) { signalLater(cm, \\\"electricInput\\\", cm, range.head.line) }\\n  }\\n}\\n\\nfunction copyableRanges(cm) {\\n  var text = [], ranges = []\\n  for (var i = 0; i < cm.doc.sel.ranges.length; i++) {\\n    var line = cm.doc.sel.ranges[i].head.line\\n    var lineRange = {anchor: Pos(line, 0), head: Pos(line + 1, 0)}\\n    ranges.push(lineRange)\\n    text.push(cm.getRange(lineRange.anchor, lineRange.head))\\n  }\\n  return {text: text, ranges: ranges}\\n}\\n\\nfunction disableBrowserMagic(field, spellcheck) {\\n  field.setAttribute(\\\"autocorrect\\\", \\\"off\\\")\\n  field.setAttribute(\\\"autocapitalize\\\", \\\"off\\\")\\n  field.setAttribute(\\\"spellcheck\\\", !!spellcheck)\\n}\\n\\nfunction hiddenTextarea() {\\n  var te = elt(\\\"textarea\\\", null, null, \\\"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none\\\")\\n  var div = elt(\\\"div\\\", [te], null, \\\"overflow: hidden; position: relative; width: 3px; height: 0px;\\\")\\n  // The textarea is kept positioned near the cursor to prevent the\\n  // fact that it'll be scrolled into view on input from scrolling\\n  // our fake cursor out of view. On webkit, when wrap=off, paste is\\n  // very slow. So make the area wide instead.\\n  if (webkit) { te.style.width = \\\"1000px\\\" }\\n  else { te.setAttribute(\\\"wrap\\\", \\\"off\\\") }\\n  // If border: 0; -- iOS fails to open keyboard (issue #1287)\\n  if (ios) { te.style.border = \\\"1px solid black\\\" }\\n  disableBrowserMagic(te)\\n  return div\\n}\\n\\n// The publicly visible API. Note that methodOp(f) means\\n// 'wrap f in an operation, performed on its `this` parameter'.\\n\\n// This is not the complete set of editor methods. Most of the\\n// methods defined on the Doc type are also injected into\\n// CodeMirror.prototype, for backwards compatibility and\\n// convenience.\\n\\nfunction addEditorMethods(CodeMirror) {\\n  var optionHandlers = CodeMirror.optionHandlers\\n\\n  var helpers = CodeMirror.helpers = {}\\n\\n  CodeMirror.prototype = {\\n    constructor: CodeMirror,\\n    focus: function(){window.focus(); this.display.input.focus()},\\n\\n    setOption: function(option, value) {\\n      var options = this.options, old = options[option]\\n      if (options[option] == value && option != \\\"mode\\\") { return }\\n      options[option] = value\\n      if (optionHandlers.hasOwnProperty(option))\\n        { operation(this, optionHandlers[option])(this, value, old) }\\n    },\\n\\n    getOption: function(option) {return this.options[option]},\\n    getDoc: function() {return this.doc},\\n\\n    addKeyMap: function(map, bottom) {\\n      this.state.keyMaps[bottom ? \\\"push\\\" : \\\"unshift\\\"](getKeyMap(map))\\n    },\\n    removeKeyMap: function(map) {\\n      var maps = this.state.keyMaps\\n      for (var i = 0; i < maps.length; ++i)\\n        { if (maps[i] == map || maps[i].name == map) {\\n          maps.splice(i, 1)\\n          return true\\n        } }\\n    },\\n\\n    addOverlay: methodOp(function(spec, options) {\\n      var mode = spec.token ? spec : CodeMirror.getMode(this.options, spec)\\n      if (mode.startState) { throw new Error(\\\"Overlays may not be stateful.\\\") }\\n      insertSorted(this.state.overlays,\\n                   {mode: mode, modeSpec: spec, opaque: options && options.opaque,\\n                    priority: (options && options.priority) || 0},\\n                   function (overlay) { return overlay.priority; })\\n      this.state.modeGen++\\n      regChange(this)\\n    }),\\n    removeOverlay: methodOp(function(spec) {\\n      var this$1 = this;\\n\\n      var overlays = this.state.overlays\\n      for (var i = 0; i < overlays.length; ++i) {\\n        var cur = overlays[i].modeSpec\\n        if (cur == spec || typeof spec == \\\"string\\\" && cur.name == spec) {\\n          overlays.splice(i, 1)\\n          this$1.state.modeGen++\\n          regChange(this$1)\\n          return\\n        }\\n      }\\n    }),\\n\\n    indentLine: methodOp(function(n, dir, aggressive) {\\n      if (typeof dir != \\\"string\\\" && typeof dir != \\\"number\\\") {\\n        if (dir == null) { dir = this.options.smartIndent ? \\\"smart\\\" : \\\"prev\\\" }\\n        else { dir = dir ? \\\"add\\\" : \\\"subtract\\\" }\\n      }\\n      if (isLine(this.doc, n)) { indentLine(this, n, dir, aggressive) }\\n    }),\\n    indentSelection: methodOp(function(how) {\\n      var this$1 = this;\\n\\n      var ranges = this.doc.sel.ranges, end = -1\\n      for (var i = 0; i < ranges.length; i++) {\\n        var range = ranges[i]\\n        if (!range.empty()) {\\n          var from = range.from(), to = range.to()\\n          var start = Math.max(end, from.line)\\n          end = Math.min(this$1.lastLine(), to.line - (to.ch ? 0 : 1)) + 1\\n          for (var j = start; j < end; ++j)\\n            { indentLine(this$1, j, how) }\\n          var newRanges = this$1.doc.sel.ranges\\n          if (from.ch == 0 && ranges.length == newRanges.length && newRanges[i].from().ch > 0)\\n            { replaceOneSelection(this$1.doc, i, new Range(from, newRanges[i].to()), sel_dontScroll) }\\n        } else if (range.head.line > end) {\\n          indentLine(this$1, range.head.line, how, true)\\n          end = range.head.line\\n          if (i == this$1.doc.sel.primIndex) { ensureCursorVisible(this$1) }\\n        }\\n      }\\n    }),\\n\\n    // Fetch the parser token for a given character. Useful for hacks\\n    // that want to inspect the mode state (say, for completion).\\n    getTokenAt: function(pos, precise) {\\n      return takeToken(this, pos, precise)\\n    },\\n\\n    getLineTokens: function(line, precise) {\\n      return takeToken(this, Pos(line), precise, true)\\n    },\\n\\n    getTokenTypeAt: function(pos) {\\n      pos = clipPos(this.doc, pos)\\n      var styles = getLineStyles(this, getLine(this.doc, pos.line))\\n      var before = 0, after = (styles.length - 1) / 2, ch = pos.ch\\n      var type\\n      if (ch == 0) { type = styles[2] }\\n      else { for (;;) {\\n        var mid = (before + after) >> 1\\n        if ((mid ? styles[mid * 2 - 1] : 0) >= ch) { after = mid }\\n        else if (styles[mid * 2 + 1] < ch) { before = mid + 1 }\\n        else { type = styles[mid * 2 + 2]; break }\\n      } }\\n      var cut = type ? type.indexOf(\\\"overlay \\\") : -1\\n      return cut < 0 ? type : cut == 0 ? null : type.slice(0, cut - 1)\\n    },\\n\\n    getModeAt: function(pos) {\\n      var mode = this.doc.mode\\n      if (!mode.innerMode) { return mode }\\n      return CodeMirror.innerMode(mode, this.getTokenAt(pos).state).mode\\n    },\\n\\n    getHelper: function(pos, type) {\\n      return this.getHelpers(pos, type)[0]\\n    },\\n\\n    getHelpers: function(pos, type) {\\n      var this$1 = this;\\n\\n      var found = []\\n      if (!helpers.hasOwnProperty(type)) { return found }\\n      var help = helpers[type], mode = this.getModeAt(pos)\\n      if (typeof mode[type] == \\\"string\\\") {\\n        if (help[mode[type]]) { found.push(help[mode[type]]) }\\n      } else if (mode[type]) {\\n        for (var i = 0; i < mode[type].length; i++) {\\n          var val = help[mode[type][i]]\\n          if (val) { found.push(val) }\\n        }\\n      } else if (mode.helperType && help[mode.helperType]) {\\n        found.push(help[mode.helperType])\\n      } else if (help[mode.name]) {\\n        found.push(help[mode.name])\\n      }\\n      for (var i$1 = 0; i$1 < help._global.length; i$1++) {\\n        var cur = help._global[i$1]\\n        if (cur.pred(mode, this$1) && indexOf(found, cur.val) == -1)\\n          { found.push(cur.val) }\\n      }\\n      return found\\n    },\\n\\n    getStateAfter: function(line, precise) {\\n      var doc = this.doc\\n      line = clipLine(doc, line == null ? doc.first + doc.size - 1: line)\\n      return getStateBefore(this, line + 1, precise)\\n    },\\n\\n    cursorCoords: function(start, mode) {\\n      var pos, range = this.doc.sel.primary()\\n      if (start == null) { pos = range.head }\\n      else if (typeof start == \\\"object\\\") { pos = clipPos(this.doc, start) }\\n      else { pos = start ? range.from() : range.to() }\\n      return cursorCoords(this, pos, mode || \\\"page\\\")\\n    },\\n\\n    charCoords: function(pos, mode) {\\n      return charCoords(this, clipPos(this.doc, pos), mode || \\\"page\\\")\\n    },\\n\\n    coordsChar: function(coords, mode) {\\n      coords = fromCoordSystem(this, coords, mode || \\\"page\\\")\\n      return coordsChar(this, coords.left, coords.top)\\n    },\\n\\n    lineAtHeight: function(height, mode) {\\n      height = fromCoordSystem(this, {top: height, left: 0}, mode || \\\"page\\\").top\\n      return lineAtHeight(this.doc, height + this.display.viewOffset)\\n    },\\n    heightAtLine: function(line, mode) {\\n      var end = false, lineObj\\n      if (typeof line == \\\"number\\\") {\\n        var last = this.doc.first + this.doc.size - 1\\n        if (line < this.doc.first) { line = this.doc.first }\\n        else if (line > last) { line = last; end = true }\\n        lineObj = getLine(this.doc, line)\\n      } else {\\n        lineObj = line\\n      }\\n      return intoCoordSystem(this, lineObj, {top: 0, left: 0}, mode || \\\"page\\\").top +\\n        (end ? this.doc.height - heightAtLine(lineObj) : 0)\\n    },\\n\\n    defaultTextHeight: function() { return textHeight(this.display) },\\n    defaultCharWidth: function() { return charWidth(this.display) },\\n\\n    setGutterMarker: methodOp(function(line, gutterID, value) {\\n      return changeLine(this.doc, line, \\\"gutter\\\", function (line) {\\n        var markers = line.gutterMarkers || (line.gutterMarkers = {})\\n        markers[gutterID] = value\\n        if (!value && isEmpty(markers)) { line.gutterMarkers = null }\\n        return true\\n      })\\n    }),\\n\\n    clearGutter: methodOp(function(gutterID) {\\n      var this$1 = this;\\n\\n      var doc = this.doc, i = doc.first\\n      doc.iter(function (line) {\\n        if (line.gutterMarkers && line.gutterMarkers[gutterID]) {\\n          line.gutterMarkers[gutterID] = null\\n          regLineChange(this$1, i, \\\"gutter\\\")\\n          if (isEmpty(line.gutterMarkers)) { line.gutterMarkers = null }\\n        }\\n        ++i\\n      })\\n    }),\\n\\n    lineInfo: function(line) {\\n      var n\\n      if (typeof line == \\\"number\\\") {\\n        if (!isLine(this.doc, line)) { return null }\\n        n = line\\n        line = getLine(this.doc, line)\\n        if (!line) { return null }\\n      } else {\\n        n = lineNo(line)\\n        if (n == null) { return null }\\n      }\\n      return {line: n, handle: line, text: line.text, gutterMarkers: line.gutterMarkers,\\n              textClass: line.textClass, bgClass: line.bgClass, wrapClass: line.wrapClass,\\n              widgets: line.widgets}\\n    },\\n\\n    getViewport: function() { return {from: this.display.viewFrom, to: this.display.viewTo}},\\n\\n    addWidget: function(pos, node, scroll, vert, horiz) {\\n      var display = this.display\\n      pos = cursorCoords(this, clipPos(this.doc, pos))\\n      var top = pos.bottom, left = pos.left\\n      node.style.position = \\\"absolute\\\"\\n      node.setAttribute(\\\"cm-ignore-events\\\", \\\"true\\\")\\n      this.display.input.setUneditable(node)\\n      display.sizer.appendChild(node)\\n      if (vert == \\\"over\\\") {\\n        top = pos.top\\n      } else if (vert == \\\"above\\\" || vert == \\\"near\\\") {\\n        var vspace = Math.max(display.wrapper.clientHeight, this.doc.height),\\n        hspace = Math.max(display.sizer.clientWidth, display.lineSpace.clientWidth)\\n        // Default to positioning above (if specified and possible); otherwise default to positioning below\\n        if ((vert == 'above' || pos.bottom + node.offsetHeight > vspace) && pos.top > node.offsetHeight)\\n          { top = pos.top - node.offsetHeight }\\n        else if (pos.bottom + node.offsetHeight <= vspace)\\n          { top = pos.bottom }\\n        if (left + node.offsetWidth > hspace)\\n          { left = hspace - node.offsetWidth }\\n      }\\n      node.style.top = top + \\\"px\\\"\\n      node.style.left = node.style.right = \\\"\\\"\\n      if (horiz == \\\"right\\\") {\\n        left = display.sizer.clientWidth - node.offsetWidth\\n        node.style.right = \\\"0px\\\"\\n      } else {\\n        if (horiz == \\\"left\\\") { left = 0 }\\n        else if (horiz == \\\"middle\\\") { left = (display.sizer.clientWidth - node.offsetWidth) / 2 }\\n        node.style.left = left + \\\"px\\\"\\n      }\\n      if (scroll)\\n        { scrollIntoView(this, left, top, left + node.offsetWidth, top + node.offsetHeight) }\\n    },\\n\\n    triggerOnKeyDown: methodOp(onKeyDown),\\n    triggerOnKeyPress: methodOp(onKeyPress),\\n    triggerOnKeyUp: onKeyUp,\\n\\n    execCommand: function(cmd) {\\n      if (commands.hasOwnProperty(cmd))\\n        { return commands[cmd].call(null, this) }\\n    },\\n\\n    triggerElectric: methodOp(function(text) { triggerElectric(this, text) }),\\n\\n    findPosH: function(from, amount, unit, visually) {\\n      var this$1 = this;\\n\\n      var dir = 1\\n      if (amount < 0) { dir = -1; amount = -amount }\\n      var cur = clipPos(this.doc, from)\\n      for (var i = 0; i < amount; ++i) {\\n        cur = findPosH(this$1.doc, cur, dir, unit, visually)\\n        if (cur.hitSide) { break }\\n      }\\n      return cur\\n    },\\n\\n    moveH: methodOp(function(dir, unit) {\\n      var this$1 = this;\\n\\n      this.extendSelectionsBy(function (range) {\\n        if (this$1.display.shift || this$1.doc.extend || range.empty())\\n          { return findPosH(this$1.doc, range.head, dir, unit, this$1.options.rtlMoveVisually) }\\n        else\\n          { return dir < 0 ? range.from() : range.to() }\\n      }, sel_move)\\n    }),\\n\\n    deleteH: methodOp(function(dir, unit) {\\n      var sel = this.doc.sel, doc = this.doc\\n      if (sel.somethingSelected())\\n        { doc.replaceSelection(\\\"\\\", null, \\\"+delete\\\") }\\n      else\\n        { deleteNearSelection(this, function (range) {\\n          var other = findPosH(doc, range.head, dir, unit, false)\\n          return dir < 0 ? {from: other, to: range.head} : {from: range.head, to: other}\\n        }) }\\n    }),\\n\\n    findPosV: function(from, amount, unit, goalColumn) {\\n      var this$1 = this;\\n\\n      var dir = 1, x = goalColumn\\n      if (amount < 0) { dir = -1; amount = -amount }\\n      var cur = clipPos(this.doc, from)\\n      for (var i = 0; i < amount; ++i) {\\n        var coords = cursorCoords(this$1, cur, \\\"div\\\")\\n        if (x == null) { x = coords.left }\\n        else { coords.left = x }\\n        cur = findPosV(this$1, coords, dir, unit)\\n        if (cur.hitSide) { break }\\n      }\\n      return cur\\n    },\\n\\n    moveV: methodOp(function(dir, unit) {\\n      var this$1 = this;\\n\\n      var doc = this.doc, goals = []\\n      var collapse = !this.display.shift && !doc.extend && doc.sel.somethingSelected()\\n      doc.extendSelectionsBy(function (range) {\\n        if (collapse)\\n          { return dir < 0 ? range.from() : range.to() }\\n        var headPos = cursorCoords(this$1, range.head, \\\"div\\\")\\n        if (range.goalColumn != null) { headPos.left = range.goalColumn }\\n        goals.push(headPos.left)\\n        var pos = findPosV(this$1, headPos, dir, unit)\\n        if (unit == \\\"page\\\" && range == doc.sel.primary())\\n          { addToScrollPos(this$1, null, charCoords(this$1, pos, \\\"div\\\").top - headPos.top) }\\n        return pos\\n      }, sel_move)\\n      if (goals.length) { for (var i = 0; i < doc.sel.ranges.length; i++)\\n        { doc.sel.ranges[i].goalColumn = goals[i] } }\\n    }),\\n\\n    // Find the word at the given position (as returned by coordsChar).\\n    findWordAt: function(pos) {\\n      var doc = this.doc, line = getLine(doc, pos.line).text\\n      var start = pos.ch, end = pos.ch\\n      if (line) {\\n        var helper = this.getHelper(pos, \\\"wordChars\\\")\\n        if ((pos.xRel < 0 || end == line.length) && start) { --start; } else { ++end }\\n        var startChar = line.charAt(start)\\n        var check = isWordChar(startChar, helper)\\n          ? function (ch) { return isWordChar(ch, helper); }\\n          : /\\\\s/.test(startChar) ? function (ch) { return /\\\\s/.test(ch); }\\n          : function (ch) { return (!/\\\\s/.test(ch) && !isWordChar(ch)); }\\n        while (start > 0 && check(line.charAt(start - 1))) { --start }\\n        while (end < line.length && check(line.charAt(end))) { ++end }\\n      }\\n      return new Range(Pos(pos.line, start), Pos(pos.line, end))\\n    },\\n\\n    toggleOverwrite: function(value) {\\n      if (value != null && value == this.state.overwrite) { return }\\n      if (this.state.overwrite = !this.state.overwrite)\\n        { addClass(this.display.cursorDiv, \\\"CodeMirror-overwrite\\\") }\\n      else\\n        { rmClass(this.display.cursorDiv, \\\"CodeMirror-overwrite\\\") }\\n\\n      signal(this, \\\"overwriteToggle\\\", this, this.state.overwrite)\\n    },\\n    hasFocus: function() { return this.display.input.getField() == activeElt() },\\n    isReadOnly: function() { return !!(this.options.readOnly || this.doc.cantEdit) },\\n\\n    scrollTo: methodOp(function(x, y) {\\n      if (x != null || y != null) { resolveScrollToPos(this) }\\n      if (x != null) { this.curOp.scrollLeft = x }\\n      if (y != null) { this.curOp.scrollTop = y }\\n    }),\\n    getScrollInfo: function() {\\n      var scroller = this.display.scroller\\n      return {left: scroller.scrollLeft, top: scroller.scrollTop,\\n              height: scroller.scrollHeight - scrollGap(this) - this.display.barHeight,\\n              width: scroller.scrollWidth - scrollGap(this) - this.display.barWidth,\\n              clientHeight: displayHeight(this), clientWidth: displayWidth(this)}\\n    },\\n\\n    scrollIntoView: methodOp(function(range, margin) {\\n      if (range == null) {\\n        range = {from: this.doc.sel.primary().head, to: null}\\n        if (margin == null) { margin = this.options.cursorScrollMargin }\\n      } else if (typeof range == \\\"number\\\") {\\n        range = {from: Pos(range, 0), to: null}\\n      } else if (range.from == null) {\\n        range = {from: range, to: null}\\n      }\\n      if (!range.to) { range.to = range.from }\\n      range.margin = margin || 0\\n\\n      if (range.from.line != null) {\\n        resolveScrollToPos(this)\\n        this.curOp.scrollToPos = range\\n      } else {\\n        var sPos = calculateScrollPos(this, Math.min(range.from.left, range.to.left),\\n                                      Math.min(range.from.top, range.to.top) - range.margin,\\n                                      Math.max(range.from.right, range.to.right),\\n                                      Math.max(range.from.bottom, range.to.bottom) + range.margin)\\n        this.scrollTo(sPos.scrollLeft, sPos.scrollTop)\\n      }\\n    }),\\n\\n    setSize: methodOp(function(width, height) {\\n      var this$1 = this;\\n\\n      var interpret = function (val) { return typeof val == \\\"number\\\" || /^\\\\d+$/.test(String(val)) ? val + \\\"px\\\" : val; }\\n      if (width != null) { this.display.wrapper.style.width = interpret(width) }\\n      if (height != null) { this.display.wrapper.style.height = interpret(height) }\\n      if (this.options.lineWrapping) { clearLineMeasurementCache(this) }\\n      var lineNo = this.display.viewFrom\\n      this.doc.iter(lineNo, this.display.viewTo, function (line) {\\n        if (line.widgets) { for (var i = 0; i < line.widgets.length; i++)\\n          { if (line.widgets[i].noHScroll) { regLineChange(this$1, lineNo, \\\"widget\\\"); break } } }\\n        ++lineNo\\n      })\\n      this.curOp.forceUpdate = true\\n      signal(this, \\\"refresh\\\", this)\\n    }),\\n\\n    operation: function(f){return runInOp(this, f)},\\n\\n    refresh: methodOp(function() {\\n      var oldHeight = this.display.cachedTextHeight\\n      regChange(this)\\n      this.curOp.forceUpdate = true\\n      clearCaches(this)\\n      this.scrollTo(this.doc.scrollLeft, this.doc.scrollTop)\\n      updateGutterSpace(this)\\n      if (oldHeight == null || Math.abs(oldHeight - textHeight(this.display)) > .5)\\n        { estimateLineHeights(this) }\\n      signal(this, \\\"refresh\\\", this)\\n    }),\\n\\n    swapDoc: methodOp(function(doc) {\\n      var old = this.doc\\n      old.cm = null\\n      attachDoc(this, doc)\\n      clearCaches(this)\\n      this.display.input.reset()\\n      this.scrollTo(doc.scrollLeft, doc.scrollTop)\\n      this.curOp.forceScroll = true\\n      signalLater(this, \\\"swapDoc\\\", this, old)\\n      return old\\n    }),\\n\\n    getInputField: function(){return this.display.input.getField()},\\n    getWrapperElement: function(){return this.display.wrapper},\\n    getScrollerElement: function(){return this.display.scroller},\\n    getGutterElement: function(){return this.display.gutters}\\n  }\\n  eventMixin(CodeMirror)\\n\\n  CodeMirror.registerHelper = function(type, name, value) {\\n    if (!helpers.hasOwnProperty(type)) { helpers[type] = CodeMirror[type] = {_global: []} }\\n    helpers[type][name] = value\\n  }\\n  CodeMirror.registerGlobalHelper = function(type, name, predicate, value) {\\n    CodeMirror.registerHelper(type, name, value)\\n    helpers[type]._global.push({pred: predicate, val: value})\\n  }\\n}\\n\\n// Used for horizontal relative motion. Dir is -1 or 1 (left or\\n// right), unit can be \\\"char\\\", \\\"column\\\" (like char, but doesn't\\n// cross line boundaries), \\\"word\\\" (across next word), or \\\"group\\\" (to\\n// the start of next group of word or non-word-non-whitespace\\n// chars). The visually param controls whether, in right-to-left\\n// text, direction 1 means to move towards the next index in the\\n// string, or towards the character to the right of the current\\n// position. The resulting position will have a hitSide=true\\n// property if it reached the end of the document.\\nfunction findPosH(doc, pos, dir, unit, visually) {\\n  var line = pos.line, ch = pos.ch, origDir = dir\\n  var lineObj = getLine(doc, line)\\n  function findNextLine() {\\n    var l = line + dir\\n    if (l < doc.first || l >= doc.first + doc.size) { return false }\\n    line = l\\n    return lineObj = getLine(doc, l)\\n  }\\n  function moveOnce(boundToLine) {\\n    var next = (visually ? moveVisually : moveLogically)(lineObj, ch, dir, true)\\n    if (next == null) {\\n      if (!boundToLine && findNextLine()) {\\n        if (visually) { ch = (dir < 0 ? lineRight : lineLeft)(lineObj) }\\n        else { ch = dir < 0 ? lineObj.text.length : 0 }\\n      } else { return false }\\n    } else { ch = next }\\n    return true\\n  }\\n\\n  if (unit == \\\"char\\\") {\\n    moveOnce()\\n  } else if (unit == \\\"column\\\") {\\n    moveOnce(true)\\n  } else if (unit == \\\"word\\\" || unit == \\\"group\\\") {\\n    var sawType = null, group = unit == \\\"group\\\"\\n    var helper = doc.cm && doc.cm.getHelper(pos, \\\"wordChars\\\")\\n    for (var first = true;; first = false) {\\n      if (dir < 0 && !moveOnce(!first)) { break }\\n      var cur = lineObj.text.charAt(ch) || \\\"\\\\n\\\"\\n      var type = isWordChar(cur, helper) ? \\\"w\\\"\\n        : group && cur == \\\"\\\\n\\\" ? \\\"n\\\"\\n        : !group || /\\\\s/.test(cur) ? null\\n        : \\\"p\\\"\\n      if (group && !first && !type) { type = \\\"s\\\" }\\n      if (sawType && sawType != type) {\\n        if (dir < 0) {dir = 1; moveOnce()}\\n        break\\n      }\\n\\n      if (type) { sawType = type }\\n      if (dir > 0 && !moveOnce(!first)) { break }\\n    }\\n  }\\n  var result = skipAtomic(doc, Pos(line, ch), pos, origDir, true)\\n  if (!cmp(pos, result)) { result.hitSide = true }\\n  return result\\n}\\n\\n// For relative vertical movement. Dir may be -1 or 1. Unit can be\\n// \\\"page\\\" or \\\"line\\\". The resulting position will have a hitSide=true\\n// property if it reached the end of the document.\\nfunction findPosV(cm, pos, dir, unit) {\\n  var doc = cm.doc, x = pos.left, y\\n  if (unit == \\\"page\\\") {\\n    var pageSize = Math.min(cm.display.wrapper.clientHeight, window.innerHeight || document.documentElement.clientHeight)\\n    var moveAmount = Math.max(pageSize - .5 * textHeight(cm.display), 3)\\n    y = (dir > 0 ? pos.bottom : pos.top) + dir * moveAmount\\n\\n  } else if (unit == \\\"line\\\") {\\n    y = dir > 0 ? pos.bottom + 3 : pos.top - 3\\n  }\\n  var target\\n  for (;;) {\\n    target = coordsChar(cm, x, y)\\n    if (!target.outside) { break }\\n    if (dir < 0 ? y <= 0 : y >= doc.height) { target.hitSide = true; break }\\n    y += dir * 5\\n  }\\n  return target\\n}\\n\\n// CONTENTEDITABLE INPUT STYLE\\n\\nfunction ContentEditableInput(cm) {\\n  this.cm = cm\\n  this.lastAnchorNode = this.lastAnchorOffset = this.lastFocusNode = this.lastFocusOffset = null\\n  this.polling = new Delayed()\\n  this.gracePeriod = false\\n}\\n\\nContentEditableInput.prototype = copyObj({\\n  init: function(display) {\\n    var input = this, cm = input.cm\\n    var div = input.div = display.lineDiv\\n    disableBrowserMagic(div, cm.options.spellcheck)\\n\\n    on(div, \\\"paste\\\", function (e) {\\n      if (signalDOMEvent(cm, e) || handlePaste(e, cm)) { return }\\n      // IE doesn't fire input events, so we schedule a read for the pasted content in this way\\n      if (ie_version <= 11) { setTimeout(operation(cm, function () {\\n        if (!input.pollContent()) { regChange(cm) }\\n      }), 20) }\\n    })\\n\\n    on(div, \\\"compositionstart\\\", function (e) {\\n      var data = e.data\\n      input.composing = {sel: cm.doc.sel, data: data, startData: data}\\n      if (!data) { return }\\n      var prim = cm.doc.sel.primary()\\n      var line = cm.getLine(prim.head.line)\\n      var found = line.indexOf(data, Math.max(0, prim.head.ch - data.length))\\n      if (found > -1 && found <= prim.head.ch)\\n        { input.composing.sel = simpleSelection(Pos(prim.head.line, found),\\n                                              Pos(prim.head.line, found + data.length)) }\\n    })\\n    on(div, \\\"compositionupdate\\\", function (e) { return input.composing.data = e.data; })\\n    on(div, \\\"compositionend\\\", function (e) {\\n      var ours = input.composing\\n      if (!ours) { return }\\n      if (e.data != ours.startData && !/\\\\u200b/.test(e.data))\\n        { ours.data = e.data }\\n      // Need a small delay to prevent other code (input event,\\n      // selection polling) from doing damage when fired right after\\n      // compositionend.\\n      setTimeout(function () {\\n        if (!ours.handled)\\n          { input.applyComposition(ours) }\\n        if (input.composing == ours)\\n          { input.composing = null }\\n      }, 50)\\n    })\\n\\n    on(div, \\\"touchstart\\\", function () { return input.forceCompositionEnd(); })\\n\\n    on(div, \\\"input\\\", function () {\\n      if (input.composing) { return }\\n      if (cm.isReadOnly() || !input.pollContent())\\n        { runInOp(input.cm, function () { return regChange(cm); }) }\\n    })\\n\\n    function onCopyCut(e) {\\n      if (signalDOMEvent(cm, e)) { return }\\n      if (cm.somethingSelected()) {\\n        setLastCopied({lineWise: false, text: cm.getSelections()})\\n        if (e.type == \\\"cut\\\") { cm.replaceSelection(\\\"\\\", null, \\\"cut\\\") }\\n      } else if (!cm.options.lineWiseCopyCut) {\\n        return\\n      } else {\\n        var ranges = copyableRanges(cm)\\n        setLastCopied({lineWise: true, text: ranges.text})\\n        if (e.type == \\\"cut\\\") {\\n          cm.operation(function () {\\n            cm.setSelections(ranges.ranges, 0, sel_dontScroll)\\n            cm.replaceSelection(\\\"\\\", null, \\\"cut\\\")\\n          })\\n        }\\n      }\\n      if (e.clipboardData) {\\n        e.clipboardData.clearData()\\n        var content = lastCopied.text.join(\\\"\\\\n\\\")\\n        // iOS exposes the clipboard API, but seems to discard content inserted into it\\n        e.clipboardData.setData(\\\"Text\\\", content)\\n        if (e.clipboardData.getData(\\\"Text\\\") == content) {\\n          e.preventDefault()\\n          return\\n        }\\n      }\\n      // Old-fashioned briefly-focus-a-textarea hack\\n      var kludge = hiddenTextarea(), te = kludge.firstChild\\n      cm.display.lineSpace.insertBefore(kludge, cm.display.lineSpace.firstChild)\\n      te.value = lastCopied.text.join(\\\"\\\\n\\\")\\n      var hadFocus = document.activeElement\\n      selectInput(te)\\n      setTimeout(function () {\\n        cm.display.lineSpace.removeChild(kludge)\\n        hadFocus.focus()\\n        if (hadFocus == div) { input.showPrimarySelection() }\\n      }, 50)\\n    }\\n    on(div, \\\"copy\\\", onCopyCut)\\n    on(div, \\\"cut\\\", onCopyCut)\\n  },\\n\\n  prepareSelection: function() {\\n    var result = prepareSelection(this.cm, false)\\n    result.focus = this.cm.state.focused\\n    return result\\n  },\\n\\n  showSelection: function(info, takeFocus) {\\n    if (!info || !this.cm.display.view.length) { return }\\n    if (info.focus || takeFocus) { this.showPrimarySelection() }\\n    this.showMultipleSelections(info)\\n  },\\n\\n  showPrimarySelection: function() {\\n    var sel = window.getSelection(), prim = this.cm.doc.sel.primary()\\n    var curAnchor = domToPos(this.cm, sel.anchorNode, sel.anchorOffset)\\n    var curFocus = domToPos(this.cm, sel.focusNode, sel.focusOffset)\\n    if (curAnchor && !curAnchor.bad && curFocus && !curFocus.bad &&\\n        cmp(minPos(curAnchor, curFocus), prim.from()) == 0 &&\\n        cmp(maxPos(curAnchor, curFocus), prim.to()) == 0)\\n      { return }\\n\\n    var start = posToDOM(this.cm, prim.from())\\n    var end = posToDOM(this.cm, prim.to())\\n    if (!start && !end) { return }\\n\\n    var view = this.cm.display.view\\n    var old = sel.rangeCount && sel.getRangeAt(0)\\n    if (!start) {\\n      start = {node: view[0].measure.map[2], offset: 0}\\n    } else if (!end) { // FIXME dangerously hacky\\n      var measure = view[view.length - 1].measure\\n      var map = measure.maps ? measure.maps[measure.maps.length - 1] : measure.map\\n      end = {node: map[map.length - 1], offset: map[map.length - 2] - map[map.length - 3]}\\n    }\\n\\n    var rng\\n    try { rng = range(start.node, start.offset, end.offset, end.node) }\\n    catch(e) {} // Our model of the DOM might be outdated, in which case the range we try to set can be impossible\\n    if (rng) {\\n      if (!gecko && this.cm.state.focused) {\\n        sel.collapse(start.node, start.offset)\\n        if (!rng.collapsed) {\\n          sel.removeAllRanges()\\n          sel.addRange(rng)\\n        }\\n      } else {\\n        sel.removeAllRanges()\\n        sel.addRange(rng)\\n      }\\n      if (old && sel.anchorNode == null) { sel.addRange(old) }\\n      else if (gecko) { this.startGracePeriod() }\\n    }\\n    this.rememberSelection()\\n  },\\n\\n  startGracePeriod: function() {\\n    var this$1 = this;\\n\\n    clearTimeout(this.gracePeriod)\\n    this.gracePeriod = setTimeout(function () {\\n      this$1.gracePeriod = false\\n      if (this$1.selectionChanged())\\n        { this$1.cm.operation(function () { return this$1.cm.curOp.selectionChanged = true; }) }\\n    }, 20)\\n  },\\n\\n  showMultipleSelections: function(info) {\\n    removeChildrenAndAdd(this.cm.display.cursorDiv, info.cursors)\\n    removeChildrenAndAdd(this.cm.display.selectionDiv, info.selection)\\n  },\\n\\n  rememberSelection: function() {\\n    var sel = window.getSelection()\\n    this.lastAnchorNode = sel.anchorNode; this.lastAnchorOffset = sel.anchorOffset\\n    this.lastFocusNode = sel.focusNode; this.lastFocusOffset = sel.focusOffset\\n  },\\n\\n  selectionInEditor: function() {\\n    var sel = window.getSelection()\\n    if (!sel.rangeCount) { return false }\\n    var node = sel.getRangeAt(0).commonAncestorContainer\\n    return contains(this.div, node)\\n  },\\n\\n  focus: function() {\\n    if (this.cm.options.readOnly != \\\"nocursor\\\") { this.div.focus() }\\n  },\\n  blur: function() { this.div.blur() },\\n  getField: function() { return this.div },\\n\\n  supportsTouch: function() { return true },\\n\\n  receivedFocus: function() {\\n    var input = this\\n    if (this.selectionInEditor())\\n      { this.pollSelection() }\\n    else\\n      { runInOp(this.cm, function () { return input.cm.curOp.selectionChanged = true; }) }\\n\\n    function poll() {\\n      if (input.cm.state.focused) {\\n        input.pollSelection()\\n        input.polling.set(input.cm.options.pollInterval, poll)\\n      }\\n    }\\n    this.polling.set(this.cm.options.pollInterval, poll)\\n  },\\n\\n  selectionChanged: function() {\\n    var sel = window.getSelection()\\n    return sel.anchorNode != this.lastAnchorNode || sel.anchorOffset != this.lastAnchorOffset ||\\n      sel.focusNode != this.lastFocusNode || sel.focusOffset != this.lastFocusOffset\\n  },\\n\\n  pollSelection: function() {\\n    if (!this.composing && !this.gracePeriod && this.selectionChanged()) {\\n      var sel = window.getSelection(), cm = this.cm\\n      this.rememberSelection()\\n      var anchor = domToPos(cm, sel.anchorNode, sel.anchorOffset)\\n      var head = domToPos(cm, sel.focusNode, sel.focusOffset)\\n      if (anchor && head) { runInOp(cm, function () {\\n        setSelection(cm.doc, simpleSelection(anchor, head), sel_dontScroll)\\n        if (anchor.bad || head.bad) { cm.curOp.selectionChanged = true }\\n      }) }\\n    }\\n  },\\n\\n  pollContent: function() {\\n    var cm = this.cm, display = cm.display, sel = cm.doc.sel.primary()\\n    var from = sel.from(), to = sel.to()\\n    if (from.line < display.viewFrom || to.line > display.viewTo - 1) { return false }\\n\\n    var fromIndex, fromLine, fromNode\\n    if (from.line == display.viewFrom || (fromIndex = findViewIndex(cm, from.line)) == 0) {\\n      fromLine = lineNo(display.view[0].line)\\n      fromNode = display.view[0].node\\n    } else {\\n      fromLine = lineNo(display.view[fromIndex].line)\\n      fromNode = display.view[fromIndex - 1].node.nextSibling\\n    }\\n    var toIndex = findViewIndex(cm, to.line)\\n    var toLine, toNode\\n    if (toIndex == display.view.length - 1) {\\n      toLine = display.viewTo - 1\\n      toNode = display.lineDiv.lastChild\\n    } else {\\n      toLine = lineNo(display.view[toIndex + 1].line) - 1\\n      toNode = display.view[toIndex + 1].node.previousSibling\\n    }\\n\\n    var newText = cm.doc.splitLines(domTextBetween(cm, fromNode, toNode, fromLine, toLine))\\n    var oldText = getBetween(cm.doc, Pos(fromLine, 0), Pos(toLine, getLine(cm.doc, toLine).text.length))\\n    while (newText.length > 1 && oldText.length > 1) {\\n      if (lst(newText) == lst(oldText)) { newText.pop(); oldText.pop(); toLine-- }\\n      else if (newText[0] == oldText[0]) { newText.shift(); oldText.shift(); fromLine++ }\\n      else { break }\\n    }\\n\\n    var cutFront = 0, cutEnd = 0\\n    var newTop = newText[0], oldTop = oldText[0], maxCutFront = Math.min(newTop.length, oldTop.length)\\n    while (cutFront < maxCutFront && newTop.charCodeAt(cutFront) == oldTop.charCodeAt(cutFront))\\n      { ++cutFront }\\n    var newBot = lst(newText), oldBot = lst(oldText)\\n    var maxCutEnd = Math.min(newBot.length - (newText.length == 1 ? cutFront : 0),\\n                             oldBot.length - (oldText.length == 1 ? cutFront : 0))\\n    while (cutEnd < maxCutEnd &&\\n           newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1))\\n      { ++cutEnd }\\n\\n    newText[newText.length - 1] = newBot.slice(0, newBot.length - cutEnd)\\n    newText[0] = newText[0].slice(cutFront)\\n\\n    var chFrom = Pos(fromLine, cutFront)\\n    var chTo = Pos(toLine, oldText.length ? lst(oldText).length - cutEnd : 0)\\n    if (newText.length > 1 || newText[0] || cmp(chFrom, chTo)) {\\n      replaceRange(cm.doc, newText, chFrom, chTo, \\\"+input\\\")\\n      return true\\n    }\\n  },\\n\\n  ensurePolled: function() {\\n    this.forceCompositionEnd()\\n  },\\n  reset: function() {\\n    this.forceCompositionEnd()\\n  },\\n  forceCompositionEnd: function() {\\n    if (!this.composing || this.composing.handled) { return }\\n    this.applyComposition(this.composing)\\n    this.composing.handled = true\\n    this.div.blur()\\n    this.div.focus()\\n  },\\n  applyComposition: function(composing) {\\n    if (this.cm.isReadOnly())\\n      { operation(this.cm, regChange)(this.cm) }\\n    else if (composing.data && composing.data != composing.startData)\\n      { operation(this.cm, applyTextInput)(this.cm, composing.data, 0, composing.sel) }\\n  },\\n\\n  setUneditable: function(node) {\\n    node.contentEditable = \\\"false\\\"\\n  },\\n\\n  onKeyPress: function(e) {\\n    e.preventDefault()\\n    if (!this.cm.isReadOnly())\\n      { operation(this.cm, applyTextInput)(this.cm, String.fromCharCode(e.charCode == null ? e.keyCode : e.charCode), 0) }\\n  },\\n\\n  readOnlyChanged: function(val) {\\n    this.div.contentEditable = String(val != \\\"nocursor\\\")\\n  },\\n\\n  onContextMenu: nothing,\\n  resetPosition: nothing,\\n\\n  needsContentAttribute: true\\n  }, ContentEditableInput.prototype)\\n\\nfunction posToDOM(cm, pos) {\\n  var view = findViewForLine(cm, pos.line)\\n  if (!view || view.hidden) { return null }\\n  var line = getLine(cm.doc, pos.line)\\n  var info = mapFromLineView(view, line, pos.line)\\n\\n  var order = getOrder(line), side = \\\"left\\\"\\n  if (order) {\\n    var partPos = getBidiPartAt(order, pos.ch)\\n    side = partPos % 2 ? \\\"right\\\" : \\\"left\\\"\\n  }\\n  var result = nodeAndOffsetInLineMap(info.map, pos.ch, side)\\n  result.offset = result.collapse == \\\"right\\\" ? result.end : result.start\\n  return result\\n}\\n\\nfunction badPos(pos, bad) { if (bad) { pos.bad = true; } return pos }\\n\\nfunction domTextBetween(cm, from, to, fromLine, toLine) {\\n  var text = \\\"\\\", closing = false, lineSep = cm.doc.lineSeparator()\\n  function recognizeMarker(id) { return function (marker) { return marker.id == id; } }\\n  function walk(node) {\\n    if (node.nodeType == 1) {\\n      var cmText = node.getAttribute(\\\"cm-text\\\")\\n      if (cmText != null) {\\n        if (cmText == \\\"\\\") { cmText = node.textContent.replace(/\\\\u200b/g, \\\"\\\") }\\n        text += cmText\\n        return\\n      }\\n      var markerID = node.getAttribute(\\\"cm-marker\\\"), range\\n      if (markerID) {\\n        var found = cm.findMarks(Pos(fromLine, 0), Pos(toLine + 1, 0), recognizeMarker(+markerID))\\n        if (found.length && (range = found[0].find()))\\n          { text += getBetween(cm.doc, range.from, range.to).join(lineSep) }\\n        return\\n      }\\n      if (node.getAttribute(\\\"contenteditable\\\") == \\\"false\\\") { return }\\n      for (var i = 0; i < node.childNodes.length; i++)\\n        { walk(node.childNodes[i]) }\\n      if (/^(pre|div|p)$/i.test(node.nodeName))\\n        { closing = true }\\n    } else if (node.nodeType == 3) {\\n      var val = node.nodeValue\\n      if (!val) { return }\\n      if (closing) {\\n        text += lineSep\\n        closing = false\\n      }\\n      text += val\\n    }\\n  }\\n  for (;;) {\\n    walk(from)\\n    if (from == to) { break }\\n    from = from.nextSibling\\n  }\\n  return text\\n}\\n\\nfunction domToPos(cm, node, offset) {\\n  var lineNode\\n  if (node == cm.display.lineDiv) {\\n    lineNode = cm.display.lineDiv.childNodes[offset]\\n    if (!lineNode) { return badPos(cm.clipPos(Pos(cm.display.viewTo - 1)), true) }\\n    node = null; offset = 0\\n  } else {\\n    for (lineNode = node;; lineNode = lineNode.parentNode) {\\n      if (!lineNode || lineNode == cm.display.lineDiv) { return null }\\n      if (lineNode.parentNode && lineNode.parentNode == cm.display.lineDiv) { break }\\n    }\\n  }\\n  for (var i = 0; i < cm.display.view.length; i++) {\\n    var lineView = cm.display.view[i]\\n    if (lineView.node == lineNode)\\n      { return locateNodeInLineView(lineView, node, offset) }\\n  }\\n}\\n\\nfunction locateNodeInLineView(lineView, node, offset) {\\n  var wrapper = lineView.text.firstChild, bad = false\\n  if (!node || !contains(wrapper, node)) { return badPos(Pos(lineNo(lineView.line), 0), true) }\\n  if (node == wrapper) {\\n    bad = true\\n    node = wrapper.childNodes[offset]\\n    offset = 0\\n    if (!node) {\\n      var line = lineView.rest ? lst(lineView.rest) : lineView.line\\n      return badPos(Pos(lineNo(line), line.text.length), bad)\\n    }\\n  }\\n\\n  var textNode = node.nodeType == 3 ? node : null, topNode = node\\n  if (!textNode && node.childNodes.length == 1 && node.firstChild.nodeType == 3) {\\n    textNode = node.firstChild\\n    if (offset) { offset = textNode.nodeValue.length }\\n  }\\n  while (topNode.parentNode != wrapper) { topNode = topNode.parentNode }\\n  var measure = lineView.measure, maps = measure.maps\\n\\n  function find(textNode, topNode, offset) {\\n    for (var i = -1; i < (maps ? maps.length : 0); i++) {\\n      var map = i < 0 ? measure.map : maps[i]\\n      for (var j = 0; j < map.length; j += 3) {\\n        var curNode = map[j + 2]\\n        if (curNode == textNode || curNode == topNode) {\\n          var line = lineNo(i < 0 ? lineView.line : lineView.rest[i])\\n          var ch = map[j] + offset\\n          if (offset < 0 || curNode != textNode) { ch = map[j + (offset ? 1 : 0)] }\\n          return Pos(line, ch)\\n        }\\n      }\\n    }\\n  }\\n  var found = find(textNode, topNode, offset)\\n  if (found) { return badPos(found, bad) }\\n\\n  // FIXME this is all really shaky. might handle the few cases it needs to handle, but likely to cause problems\\n  for (var after = topNode.nextSibling, dist = textNode ? textNode.nodeValue.length - offset : 0; after; after = after.nextSibling) {\\n    found = find(after, after.firstChild, 0)\\n    if (found)\\n      { return badPos(Pos(found.line, found.ch - dist), bad) }\\n    else\\n      { dist += after.textContent.length }\\n  }\\n  for (var before = topNode.previousSibling, dist$1 = offset; before; before = before.previousSibling) {\\n    found = find(before, before.firstChild, -1)\\n    if (found)\\n      { return badPos(Pos(found.line, found.ch + dist$1), bad) }\\n    else\\n      { dist$1 += before.textContent.length }\\n  }\\n}\\n\\n// TEXTAREA INPUT STYLE\\n\\nfunction TextareaInput(cm) {\\n  this.cm = cm\\n  // See input.poll and input.reset\\n  this.prevInput = \\\"\\\"\\n\\n  // Flag that indicates whether we expect input to appear real soon\\n  // now (after some event like 'keypress' or 'input') and are\\n  // polling intensively.\\n  this.pollingFast = false\\n  // Self-resetting timeout for the poller\\n  this.polling = new Delayed()\\n  // Tracks when input.reset has punted to just putting a short\\n  // string into the textarea instead of the full selection.\\n  this.inaccurateSelection = false\\n  // Used to work around IE issue with selection being forgotten when focus moves away from textarea\\n  this.hasSelection = false\\n  this.composing = null\\n}\\n\\nTextareaInput.prototype = copyObj({\\n  init: function(display) {\\n    var this$1 = this;\\n\\n    var input = this, cm = this.cm\\n\\n    // Wraps and hides input textarea\\n    var div = this.wrapper = hiddenTextarea()\\n    // The semihidden textarea that is focused when the editor is\\n    // focused, and receives input.\\n    var te = this.textarea = div.firstChild\\n    display.wrapper.insertBefore(div, display.wrapper.firstChild)\\n\\n    // Needed to hide big blue blinking cursor on Mobile Safari (doesn't seem to work in iOS 8 anymore)\\n    if (ios) { te.style.width = \\\"0px\\\" }\\n\\n    on(te, \\\"input\\\", function () {\\n      if (ie && ie_version >= 9 && this$1.hasSelection) { this$1.hasSelection = null }\\n      input.poll()\\n    })\\n\\n    on(te, \\\"paste\\\", function (e) {\\n      if (signalDOMEvent(cm, e) || handlePaste(e, cm)) { return }\\n\\n      cm.state.pasteIncoming = true\\n      input.fastPoll()\\n    })\\n\\n    function prepareCopyCut(e) {\\n      if (signalDOMEvent(cm, e)) { return }\\n      if (cm.somethingSelected()) {\\n        setLastCopied({lineWise: false, text: cm.getSelections()})\\n        if (input.inaccurateSelection) {\\n          input.prevInput = \\\"\\\"\\n          input.inaccurateSelection = false\\n          te.value = lastCopied.text.join(\\\"\\\\n\\\")\\n          selectInput(te)\\n        }\\n      } else if (!cm.options.lineWiseCopyCut) {\\n        return\\n      } else {\\n        var ranges = copyableRanges(cm)\\n        setLastCopied({lineWise: true, text: ranges.text})\\n        if (e.type == \\\"cut\\\") {\\n          cm.setSelections(ranges.ranges, null, sel_dontScroll)\\n        } else {\\n          input.prevInput = \\\"\\\"\\n          te.value = ranges.text.join(\\\"\\\\n\\\")\\n          selectInput(te)\\n        }\\n      }\\n      if (e.type == \\\"cut\\\") { cm.state.cutIncoming = true }\\n    }\\n    on(te, \\\"cut\\\", prepareCopyCut)\\n    on(te, \\\"copy\\\", prepareCopyCut)\\n\\n    on(display.scroller, \\\"paste\\\", function (e) {\\n      if (eventInWidget(display, e) || signalDOMEvent(cm, e)) { return }\\n      cm.state.pasteIncoming = true\\n      input.focus()\\n    })\\n\\n    // Prevent normal selection in the editor (we handle our own)\\n    on(display.lineSpace, \\\"selectstart\\\", function (e) {\\n      if (!eventInWidget(display, e)) { e_preventDefault(e) }\\n    })\\n\\n    on(te, \\\"compositionstart\\\", function () {\\n      var start = cm.getCursor(\\\"from\\\")\\n      if (input.composing) { input.composing.range.clear() }\\n      input.composing = {\\n        start: start,\\n        range: cm.markText(start, cm.getCursor(\\\"to\\\"), {className: \\\"CodeMirror-composing\\\"})\\n      }\\n    })\\n    on(te, \\\"compositionend\\\", function () {\\n      if (input.composing) {\\n        input.poll()\\n        input.composing.range.clear()\\n        input.composing = null\\n      }\\n    })\\n  },\\n\\n  prepareSelection: function() {\\n    // Redraw the selection and/or cursor\\n    var cm = this.cm, display = cm.display, doc = cm.doc\\n    var result = prepareSelection(cm)\\n\\n    // Move the hidden textarea near the cursor to prevent scrolling artifacts\\n    if (cm.options.moveInputWithCursor) {\\n      var headPos = cursorCoords(cm, doc.sel.primary().head, \\\"div\\\")\\n      var wrapOff = display.wrapper.getBoundingClientRect(), lineOff = display.lineDiv.getBoundingClientRect()\\n      result.teTop = Math.max(0, Math.min(display.wrapper.clientHeight - 10,\\n                                          headPos.top + lineOff.top - wrapOff.top))\\n      result.teLeft = Math.max(0, Math.min(display.wrapper.clientWidth - 10,\\n                                           headPos.left + lineOff.left - wrapOff.left))\\n    }\\n\\n    return result\\n  },\\n\\n  showSelection: function(drawn) {\\n    var cm = this.cm, display = cm.display\\n    removeChildrenAndAdd(display.cursorDiv, drawn.cursors)\\n    removeChildrenAndAdd(display.selectionDiv, drawn.selection)\\n    if (drawn.teTop != null) {\\n      this.wrapper.style.top = drawn.teTop + \\\"px\\\"\\n      this.wrapper.style.left = drawn.teLeft + \\\"px\\\"\\n    }\\n  },\\n\\n  // Reset the input to correspond to the selection (or to be empty,\\n  // when not typing and nothing is selected)\\n  reset: function(typing) {\\n    if (this.contextMenuPending) { return }\\n    var minimal, selected, cm = this.cm, doc = cm.doc\\n    if (cm.somethingSelected()) {\\n      this.prevInput = \\\"\\\"\\n      var range = doc.sel.primary()\\n      minimal = hasCopyEvent &&\\n        (range.to().line - range.from().line > 100 || (selected = cm.getSelection()).length > 1000)\\n      var content = minimal ? \\\"-\\\" : selected || cm.getSelection()\\n      this.textarea.value = content\\n      if (cm.state.focused) { selectInput(this.textarea) }\\n      if (ie && ie_version >= 9) { this.hasSelection = content }\\n    } else if (!typing) {\\n      this.prevInput = this.textarea.value = \\\"\\\"\\n      if (ie && ie_version >= 9) { this.hasSelection = null }\\n    }\\n    this.inaccurateSelection = minimal\\n  },\\n\\n  getField: function() { return this.textarea },\\n\\n  supportsTouch: function() { return false },\\n\\n  focus: function() {\\n    if (this.cm.options.readOnly != \\\"nocursor\\\" && (!mobile || activeElt() != this.textarea)) {\\n      try { this.textarea.focus() }\\n      catch (e) {} // IE8 will throw if the textarea is display: none or not in DOM\\n    }\\n  },\\n\\n  blur: function() { this.textarea.blur() },\\n\\n  resetPosition: function() {\\n    this.wrapper.style.top = this.wrapper.style.left = 0\\n  },\\n\\n  receivedFocus: function() { this.slowPoll() },\\n\\n  // Poll for input changes, using the normal rate of polling. This\\n  // runs as long as the editor is focused.\\n  slowPoll: function() {\\n    var this$1 = this;\\n\\n    if (this.pollingFast) { return }\\n    this.polling.set(this.cm.options.pollInterval, function () {\\n      this$1.poll()\\n      if (this$1.cm.state.focused) { this$1.slowPoll() }\\n    })\\n  },\\n\\n  // When an event has just come in that is likely to add or change\\n  // something in the input textarea, we poll faster, to ensure that\\n  // the change appears on the screen quickly.\\n  fastPoll: function() {\\n    var missed = false, input = this\\n    input.pollingFast = true\\n    function p() {\\n      var changed = input.poll()\\n      if (!changed && !missed) {missed = true; input.polling.set(60, p)}\\n      else {input.pollingFast = false; input.slowPoll()}\\n    }\\n    input.polling.set(20, p)\\n  },\\n\\n  // Read input from the textarea, and update the document to match.\\n  // When something is selected, it is present in the textarea, and\\n  // selected (unless it is huge, in which case a placeholder is\\n  // used). When nothing is selected, the cursor sits after previously\\n  // seen text (can be empty), which is stored in prevInput (we must\\n  // not reset the textarea when typing, because that breaks IME).\\n  poll: function() {\\n    var this$1 = this;\\n\\n    var cm = this.cm, input = this.textarea, prevInput = this.prevInput\\n    // Since this is called a *lot*, try to bail out as cheaply as\\n    // possible when it is clear that nothing happened. hasSelection\\n    // will be the case when there is a lot of text in the textarea,\\n    // in which case reading its value would be expensive.\\n    if (this.contextMenuPending || !cm.state.focused ||\\n        (hasSelection(input) && !prevInput && !this.composing) ||\\n        cm.isReadOnly() || cm.options.disableInput || cm.state.keySeq)\\n      { return false }\\n\\n    var text = input.value\\n    // If nothing changed, bail.\\n    if (text == prevInput && !cm.somethingSelected()) { return false }\\n    // Work around nonsensical selection resetting in IE9/10, and\\n    // inexplicable appearance of private area unicode characters on\\n    // some key combos in Mac (#2689).\\n    if (ie && ie_version >= 9 && this.hasSelection === text ||\\n        mac && /[\\\\uf700-\\\\uf7ff]/.test(text)) {\\n      cm.display.input.reset()\\n      return false\\n    }\\n\\n    if (cm.doc.sel == cm.display.selForContextMenu) {\\n      var first = text.charCodeAt(0)\\n      if (first == 0x200b && !prevInput) { prevInput = \\\"\\\\u200b\\\" }\\n      if (first == 0x21da) { this.reset(); return this.cm.execCommand(\\\"undo\\\") }\\n    }\\n    // Find the part of the input that is actually new\\n    var same = 0, l = Math.min(prevInput.length, text.length)\\n    while (same < l && prevInput.charCodeAt(same) == text.charCodeAt(same)) { ++same }\\n\\n    runInOp(cm, function () {\\n      applyTextInput(cm, text.slice(same), prevInput.length - same,\\n                     null, this$1.composing ? \\\"*compose\\\" : null)\\n\\n      // Don't leave long text in the textarea, since it makes further polling slow\\n      if (text.length > 1000 || text.indexOf(\\\"\\\\n\\\") > -1) { input.value = this$1.prevInput = \\\"\\\" }\\n      else { this$1.prevInput = text }\\n\\n      if (this$1.composing) {\\n        this$1.composing.range.clear()\\n        this$1.composing.range = cm.markText(this$1.composing.start, cm.getCursor(\\\"to\\\"),\\n                                           {className: \\\"CodeMirror-composing\\\"})\\n      }\\n    })\\n    return true\\n  },\\n\\n  ensurePolled: function() {\\n    if (this.pollingFast && this.poll()) { this.pollingFast = false }\\n  },\\n\\n  onKeyPress: function() {\\n    if (ie && ie_version >= 9) { this.hasSelection = null }\\n    this.fastPoll()\\n  },\\n\\n  onContextMenu: function(e) {\\n    var input = this, cm = input.cm, display = cm.display, te = input.textarea\\n    var pos = posFromMouse(cm, e), scrollPos = display.scroller.scrollTop\\n    if (!pos || presto) { return } // Opera is difficult.\\n\\n    // Reset the current text selection only if the click is done outside of the selection\\n    // and 'resetSelectionOnContextMenu' option is true.\\n    var reset = cm.options.resetSelectionOnContextMenu\\n    if (reset && cm.doc.sel.contains(pos) == -1)\\n      { operation(cm, setSelection)(cm.doc, simpleSelection(pos), sel_dontScroll) }\\n\\n    var oldCSS = te.style.cssText, oldWrapperCSS = input.wrapper.style.cssText\\n    input.wrapper.style.cssText = \\\"position: absolute\\\"\\n    var wrapperBox = input.wrapper.getBoundingClientRect()\\n    te.style.cssText = \\\"position: absolute; width: 30px; height: 30px;\\\\n      top: \\\" + (e.clientY - wrapperBox.top - 5) + \\\"px; left: \\\" + (e.clientX - wrapperBox.left - 5) + \\\"px;\\\\n      z-index: 1000; background: \\\" + (ie ? \\\"rgba(255, 255, 255, .05)\\\" : \\\"transparent\\\") + \\\";\\\\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);\\\"\\n    var oldScrollY\\n    if (webkit) { oldScrollY = window.scrollY } // Work around Chrome issue (#2712)\\n    display.input.focus()\\n    if (webkit) { window.scrollTo(null, oldScrollY) }\\n    display.input.reset()\\n    // Adds \\\"Select all\\\" to context menu in FF\\n    if (!cm.somethingSelected()) { te.value = input.prevInput = \\\" \\\" }\\n    input.contextMenuPending = true\\n    display.selForContextMenu = cm.doc.sel\\n    clearTimeout(display.detectingSelectAll)\\n\\n    // Select-all will be greyed out if there's nothing to select, so\\n    // this adds a zero-width space so that we can later check whether\\n    // it got selected.\\n    function prepareSelectAllHack() {\\n      if (te.selectionStart != null) {\\n        var selected = cm.somethingSelected()\\n        var extval = \\\"\\\\u200b\\\" + (selected ? te.value : \\\"\\\")\\n        te.value = \\\"\\\\u21da\\\" // Used to catch context-menu undo\\n        te.value = extval\\n        input.prevInput = selected ? \\\"\\\" : \\\"\\\\u200b\\\"\\n        te.selectionStart = 1; te.selectionEnd = extval.length\\n        // Re-set this, in case some other handler touched the\\n        // selection in the meantime.\\n        display.selForContextMenu = cm.doc.sel\\n      }\\n    }\\n    function rehide() {\\n      input.contextMenuPending = false\\n      input.wrapper.style.cssText = oldWrapperCSS\\n      te.style.cssText = oldCSS\\n      if (ie && ie_version < 9) { display.scrollbars.setScrollTop(display.scroller.scrollTop = scrollPos) }\\n\\n      // Try to detect the user choosing select-all\\n      if (te.selectionStart != null) {\\n        if (!ie || (ie && ie_version < 9)) { prepareSelectAllHack() }\\n        var i = 0, poll = function () {\\n          if (display.selForContextMenu == cm.doc.sel && te.selectionStart == 0 &&\\n              te.selectionEnd > 0 && input.prevInput == \\\"\\\\u200b\\\")\\n            { operation(cm, selectAll)(cm) }\\n          else if (i++ < 10) { display.detectingSelectAll = setTimeout(poll, 500) }\\n          else { display.input.reset() }\\n        }\\n        display.detectingSelectAll = setTimeout(poll, 200)\\n      }\\n    }\\n\\n    if (ie && ie_version >= 9) { prepareSelectAllHack() }\\n    if (captureRightClick) {\\n      e_stop(e)\\n      var mouseup = function () {\\n        off(window, \\\"mouseup\\\", mouseup)\\n        setTimeout(rehide, 20)\\n      }\\n      on(window, \\\"mouseup\\\", mouseup)\\n    } else {\\n      setTimeout(rehide, 50)\\n    }\\n  },\\n\\n  readOnlyChanged: function(val) {\\n    if (!val) { this.reset() }\\n  },\\n\\n  setUneditable: nothing,\\n\\n  needsContentAttribute: false\\n}, TextareaInput.prototype)\\n\\nfunction fromTextArea(textarea, options) {\\n  options = options ? copyObj(options) : {}\\n  options.value = textarea.value\\n  if (!options.tabindex && textarea.tabIndex)\\n    { options.tabindex = textarea.tabIndex }\\n  if (!options.placeholder && textarea.placeholder)\\n    { options.placeholder = textarea.placeholder }\\n  // Set autofocus to true if this textarea is focused, or if it has\\n  // autofocus and no other element is focused.\\n  if (options.autofocus == null) {\\n    var hasFocus = activeElt()\\n    options.autofocus = hasFocus == textarea ||\\n      textarea.getAttribute(\\\"autofocus\\\") != null && hasFocus == document.body\\n  }\\n\\n  function save() {textarea.value = cm.getValue()}\\n\\n  var realSubmit\\n  if (textarea.form) {\\n    on(textarea.form, \\\"submit\\\", save)\\n    // Deplorable hack to make the submit method do the right thing.\\n    if (!options.leaveSubmitMethodAlone) {\\n      var form = textarea.form\\n      realSubmit = form.submit\\n      try {\\n        var wrappedSubmit = form.submit = function () {\\n          save()\\n          form.submit = realSubmit\\n          form.submit()\\n          form.submit = wrappedSubmit\\n        }\\n      } catch(e) {}\\n    }\\n  }\\n\\n  options.finishInit = function (cm) {\\n    cm.save = save\\n    cm.getTextArea = function () { return textarea; }\\n    cm.toTextArea = function () {\\n      cm.toTextArea = isNaN // Prevent this from being ran twice\\n      save()\\n      textarea.parentNode.removeChild(cm.getWrapperElement())\\n      textarea.style.display = \\\"\\\"\\n      if (textarea.form) {\\n        off(textarea.form, \\\"submit\\\", save)\\n        if (typeof textarea.form.submit == \\\"function\\\")\\n          { textarea.form.submit = realSubmit }\\n      }\\n    }\\n  }\\n\\n  textarea.style.display = \\\"none\\\"\\n  var cm = CodeMirror(function (node) { return textarea.parentNode.insertBefore(node, textarea.nextSibling); },\\n    options)\\n  return cm\\n}\\n\\nfunction addLegacyProps(CodeMirror) {\\n  CodeMirror.off = off\\n  CodeMirror.on = on\\n  CodeMirror.wheelEventPixels = wheelEventPixels\\n  CodeMirror.Doc = Doc\\n  CodeMirror.splitLines = splitLinesAuto\\n  CodeMirror.countColumn = countColumn\\n  CodeMirror.findColumn = findColumn\\n  CodeMirror.isWordChar = isWordCharBasic\\n  CodeMirror.Pass = Pass\\n  CodeMirror.signal = signal\\n  CodeMirror.Line = Line\\n  CodeMirror.changeEnd = changeEnd\\n  CodeMirror.scrollbarModel = scrollbarModel\\n  CodeMirror.Pos = Pos\\n  CodeMirror.cmpPos = cmp\\n  CodeMirror.modes = modes\\n  CodeMirror.mimeModes = mimeModes\\n  CodeMirror.resolveMode = resolveMode\\n  CodeMirror.getMode = getMode\\n  CodeMirror.modeExtensions = modeExtensions\\n  CodeMirror.extendMode = extendMode\\n  CodeMirror.copyState = copyState\\n  CodeMirror.startState = startState\\n  CodeMirror.innerMode = innerMode\\n  CodeMirror.commands = commands\\n  CodeMirror.keyMap = keyMap\\n  CodeMirror.keyName = keyName\\n  CodeMirror.isModifierKey = isModifierKey\\n  CodeMirror.lookupKey = lookupKey\\n  CodeMirror.normalizeKeyMap = normalizeKeyMap\\n  CodeMirror.StringStream = StringStream\\n  CodeMirror.SharedTextMarker = SharedTextMarker\\n  CodeMirror.TextMarker = TextMarker\\n  CodeMirror.LineWidget = LineWidget\\n  CodeMirror.e_preventDefault = e_preventDefault\\n  CodeMirror.e_stopPropagation = e_stopPropagation\\n  CodeMirror.e_stop = e_stop\\n  CodeMirror.addClass = addClass\\n  CodeMirror.contains = contains\\n  CodeMirror.rmClass = rmClass\\n  CodeMirror.keyNames = keyNames\\n}\\n\\n// EDITOR CONSTRUCTOR\\n\\ndefineOptions(CodeMirror)\\n\\naddEditorMethods(CodeMirror)\\n\\n// Set up methods on CodeMirror's prototype to redirect to the editor's document.\\nvar dontDelegate = \\\"iter insert remove copy getEditor constructor\\\".split(\\\" \\\")\\nfor (var prop in Doc.prototype) { if (Doc.prototype.hasOwnProperty(prop) && indexOf(dontDelegate, prop) < 0)\\n  { CodeMirror.prototype[prop] = (function(method) {\\n    return function() {return method.apply(this.doc, arguments)}\\n  })(Doc.prototype[prop]) } }\\n\\neventMixin(Doc)\\n\\n// INPUT HANDLING\\n\\nCodeMirror.inputStyles = {\\\"textarea\\\": TextareaInput, \\\"contenteditable\\\": ContentEditableInput}\\n\\n// MODE DEFINITION AND QUERYING\\n\\n// Extra arguments are stored as the mode's dependencies, which is\\n// used by (legacy) mechanisms like loadmode.js to automatically\\n// load a mode. (Preferred mechanism is the require/define calls.)\\nCodeMirror.defineMode = function(name/*, mode, …*/) {\\n  if (!CodeMirror.defaults.mode && name != \\\"null\\\") { CodeMirror.defaults.mode = name }\\n  defineMode.apply(this, arguments)\\n}\\n\\nCodeMirror.defineMIME = defineMIME\\n\\n// Minimal default mode.\\nCodeMirror.defineMode(\\\"null\\\", function () { return ({token: function (stream) { return stream.skipToEnd(); }}); })\\nCodeMirror.defineMIME(\\\"text/plain\\\", \\\"null\\\")\\n\\n// EXTENSIONS\\n\\nCodeMirror.defineExtension = function (name, func) {\\n  CodeMirror.prototype[name] = func\\n}\\nCodeMirror.defineDocExtension = function (name, func) {\\n  Doc.prototype[name] = func\\n}\\n\\nCodeMirror.fromTextArea = fromTextArea\\n\\naddLegacyProps(CodeMirror)\\n\\nCodeMirror.version = \\\"5.20.2\\\"\\n\\nreturn CodeMirror;\\n\\n})));\"//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL34vY29kZW1pcnJvci9saWIvY29kZW1pcnJvci5qcz9iMGIxIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gXCIvLyBDb2RlTWlycm9yLCBjb3B5cmlnaHQgKGMpIGJ5IE1hcmlqbiBIYXZlcmJla2UgYW5kIG90aGVyc1xcbi8vIERpc3RyaWJ1dGVkIHVuZGVyIGFuIE1JVCBsaWNlbnNlOiBodHRwOi8vY29kZW1pcnJvci5uZXQvTElDRU5TRVxcblxcbi8vIFRoaXMgaXMgQ29kZU1pcnJvciAoaHR0cDovL2NvZGVtaXJyb3IubmV0KSwgYSBjb2RlIGVkaXRvclxcbi8vIGltcGxlbWVudGVkIGluIEphdmFTY3JpcHQgb24gdG9wIG9mIHRoZSBicm93c2VyJ3MgRE9NLlxcbi8vXFxuLy8gWW91IGNhbiBmaW5kIHNvbWUgdGVjaG5pY2FsIGJhY2tncm91bmQgZm9yIHNvbWUgb2YgdGhlIGNvZGUgYmVsb3dcXG4vLyBhdCBodHRwOi8vbWFyaWpuaGF2ZXJiZWtlLm5sL2Jsb2cvI2NtLWludGVybmFscyAuXFxuXFxuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcXG4gIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpIDpcXG4gIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShmYWN0b3J5KSA6XFxuICAoZ2xvYmFsLkNvZGVNaXJyb3IgPSBmYWN0b3J5KCkpO1xcbn0odGhpcywgKGZ1bmN0aW9uICgpIHsgJ3VzZSBzdHJpY3QnO1xcblxcbi8vIEtsdWRnZXMgZm9yIGJ1Z3MgYW5kIGJlaGF2aW9yIGRpZmZlcmVuY2VzIHRoYXQgY2FuJ3QgYmUgZmVhdHVyZVxcbi8vIGRldGVjdGVkIGFyZSBlbmFibGVkIGJhc2VkIG9uIHVzZXJBZ2VudCBldGMgc25pZmZpbmcuXFxudmFyIHVzZXJBZ2VudCA9IG5hdmlnYXRvci51c2VyQWdlbnRcXG52YXIgcGxhdGZvcm0gPSBuYXZpZ2F0b3IucGxhdGZvcm1cXG5cXG52YXIgZ2Vja28gPSAvZ2Vja29cXFxcL1xcXFxkL2kudGVzdCh1c2VyQWdlbnQpXFxudmFyIGllX3VwdG8xMCA9IC9NU0lFIFxcXFxkLy50ZXN0KHVzZXJBZ2VudClcXG52YXIgaWVfMTF1cCA9IC9UcmlkZW50XFxcXC8oPzpbNy05XXxcXFxcZHsyLH0pXFxcXC4uKnJ2OihcXFxcZCspLy5leGVjKHVzZXJBZ2VudClcXG52YXIgaWUgPSBpZV91cHRvMTAgfHwgaWVfMTF1cFxcbnZhciBpZV92ZXJzaW9uID0gaWUgJiYgKGllX3VwdG8xMCA/IGRvY3VtZW50LmRvY3VtZW50TW9kZSB8fCA2IDogaWVfMTF1cFsxXSlcXG52YXIgd2Via2l0ID0gL1dlYktpdFxcXFwvLy50ZXN0KHVzZXJBZ2VudClcXG52YXIgcXR3ZWJraXQgPSB3ZWJraXQgJiYgL1F0XFxcXC9cXFxcZCtcXFxcLlxcXFxkKy8udGVzdCh1c2VyQWdlbnQpXFxudmFyIGNocm9tZSA9IC9DaHJvbWVcXFxcLy8udGVzdCh1c2VyQWdlbnQpXFxudmFyIHByZXN0byA9IC9PcGVyYVxcXFwvLy50ZXN0KHVzZXJBZ2VudClcXG52YXIgc2FmYXJpID0gL0FwcGxlIENvbXB1dGVyLy50ZXN0KG5hdmlnYXRvci52ZW5kb3IpXFxudmFyIG1hY19nZU1vdW50YWluTGlvbiA9IC9NYWMgT1MgWCAxXFxcXGRcXFxcRChbOC05XXxcXFxcZFxcXFxkKVxcXFxELy50ZXN0KHVzZXJBZ2VudClcXG52YXIgcGhhbnRvbSA9IC9QaGFudG9tSlMvLnRlc3QodXNlckFnZW50KVxcblxcbnZhciBpb3MgPSAvQXBwbGVXZWJLaXQvLnRlc3QodXNlckFnZW50KSAmJiAvTW9iaWxlXFxcXC9cXFxcdysvLnRlc3QodXNlckFnZW50KVxcbi8vIFRoaXMgaXMgd29lZnVsbHkgaW5jb21wbGV0ZS4gU3VnZ2VzdGlvbnMgZm9yIGFsdGVybmF0aXZlIG1ldGhvZHMgd2VsY29tZS5cXG52YXIgbW9iaWxlID0gaW9zIHx8IC9BbmRyb2lkfHdlYk9TfEJsYWNrQmVycnl8T3BlcmEgTWluaXxPcGVyYSBNb2JpfElFTW9iaWxlL2kudGVzdCh1c2VyQWdlbnQpXFxudmFyIG1hYyA9IGlvcyB8fCAvTWFjLy50ZXN0KHBsYXRmb3JtKVxcbnZhciBjaHJvbWVPUyA9IC9cXFxcYkNyT1NcXFxcYi8udGVzdCh1c2VyQWdlbnQpXFxudmFyIHdpbmRvd3MgPSAvd2luL2kudGVzdChwbGF0Zm9ybSlcXG5cXG52YXIgcHJlc3RvX3ZlcnNpb24gPSBwcmVzdG8gJiYgdXNlckFnZW50Lm1hdGNoKC9WZXJzaW9uXFxcXC8oXFxcXGQqXFxcXC5cXFxcZCopLylcXG5pZiAocHJlc3RvX3ZlcnNpb24pIHsgcHJlc3RvX3ZlcnNpb24gPSBOdW1iZXIocHJlc3RvX3ZlcnNpb25bMV0pIH1cXG5pZiAocHJlc3RvX3ZlcnNpb24gJiYgcHJlc3RvX3ZlcnNpb24gPj0gMTUpIHsgcHJlc3RvID0gZmFsc2U7IHdlYmtpdCA9IHRydWUgfVxcbi8vIFNvbWUgYnJvd3NlcnMgdXNlIHRoZSB3cm9uZyBldmVudCBwcm9wZXJ0aWVzIHRvIHNpZ25hbCBjbWQvY3RybCBvbiBPUyBYXFxudmFyIGZsaXBDdHJsQ21kID0gbWFjICYmIChxdHdlYmtpdCB8fCBwcmVzdG8gJiYgKHByZXN0b192ZXJzaW9uID09IG51bGwgfHwgcHJlc3RvX3ZlcnNpb24gPCAxMi4xMSkpXFxudmFyIGNhcHR1cmVSaWdodENsaWNrID0gZ2Vja28gfHwgKGllICYmIGllX3ZlcnNpb24gPj0gOSlcXG5cXG5mdW5jdGlvbiBjbGFzc1Rlc3QoY2xzKSB7IHJldHVybiBuZXcgUmVnRXhwKFxcXCIoXnxcXFxcXFxcXHMpXFxcIiArIGNscyArIFxcXCIoPzokfFxcXFxcXFxccylcXFxcXFxcXHMqXFxcIikgfVxcblxcbnZhciBybUNsYXNzID0gZnVuY3Rpb24obm9kZSwgY2xzKSB7XFxuICB2YXIgY3VycmVudCA9IG5vZGUuY2xhc3NOYW1lXFxuICB2YXIgbWF0Y2ggPSBjbGFzc1Rlc3QoY2xzKS5leGVjKGN1cnJlbnQpXFxuICBpZiAobWF0Y2gpIHtcXG4gICAgdmFyIGFmdGVyID0gY3VycmVudC5zbGljZShtYXRjaC5pbmRleCArIG1hdGNoWzBdLmxlbmd0aClcXG4gICAgbm9kZS5jbGFzc05hbWUgPSBjdXJyZW50LnNsaWNlKDAsIG1hdGNoLmluZGV4KSArIChhZnRlciA/IG1hdGNoWzFdICsgYWZ0ZXIgOiBcXFwiXFxcIilcXG4gIH1cXG59XFxuXFxuZnVuY3Rpb24gcmVtb3ZlQ2hpbGRyZW4oZSkge1xcbiAgZm9yICh2YXIgY291bnQgPSBlLmNoaWxkTm9kZXMubGVuZ3RoOyBjb3VudCA+IDA7IC0tY291bnQpXFxuICAgIHsgZS5yZW1vdmVDaGlsZChlLmZpcnN0Q2hpbGQpIH1cXG4gIHJldHVybiBlXFxufVxcblxcbmZ1bmN0aW9uIHJlbW92ZUNoaWxkcmVuQW5kQWRkKHBhcmVudCwgZSkge1xcbiAgcmV0dXJuIHJlbW92ZUNoaWxkcmVuKHBhcmVudCkuYXBwZW5kQ2hpbGQoZSlcXG59XFxuXFxuZnVuY3Rpb24gZWx0KHRhZywgY29udGVudCwgY2xhc3NOYW1lLCBzdHlsZSkge1xcbiAgdmFyIGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZylcXG4gIGlmIChjbGFzc05hbWUpIHsgZS5jbGFzc05hbWUgPSBjbGFzc05hbWUgfVxcbiAgaWYgKHN0eWxlKSB7IGUuc3R5bGUuY3NzVGV4dCA9IHN0eWxlIH1cXG4gIGlmICh0eXBlb2YgY29udGVudCA9PSBcXFwic3RyaW5nXFxcIikgeyBlLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNvbnRlbnQpKSB9XFxuICBlbHNlIGlmIChjb250ZW50KSB7IGZvciAodmFyIGkgPSAwOyBpIDwgY29udGVudC5sZW5ndGg7ICsraSkgeyBlLmFwcGVuZENoaWxkKGNvbnRlbnRbaV0pIH0gfVxcbiAgcmV0dXJuIGVcXG59XFxuXFxudmFyIHJhbmdlXFxuaWYgKGRvY3VtZW50LmNyZWF0ZVJhbmdlKSB7IHJhbmdlID0gZnVuY3Rpb24obm9kZSwgc3RhcnQsIGVuZCwgZW5kTm9kZSkge1xcbiAgdmFyIHIgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpXFxuICByLnNldEVuZChlbmROb2RlIHx8IG5vZGUsIGVuZClcXG4gIHIuc2V0U3RhcnQobm9kZSwgc3RhcnQpXFxuICByZXR1cm4gclxcbn0gfVxcbmVsc2UgeyByYW5nZSA9IGZ1bmN0aW9uKG5vZGUsIHN0YXJ0LCBlbmQpIHtcXG4gIHZhciByID0gZG9jdW1lbnQuYm9keS5jcmVhdGVUZXh0UmFuZ2UoKVxcbiAgdHJ5IHsgci5tb3ZlVG9FbGVtZW50VGV4dChub2RlLnBhcmVudE5vZGUpIH1cXG4gIGNhdGNoKGUpIHsgcmV0dXJuIHIgfVxcbiAgci5jb2xsYXBzZSh0cnVlKVxcbiAgci5tb3ZlRW5kKFxcXCJjaGFyYWN0ZXJcXFwiLCBlbmQpXFxuICByLm1vdmVTdGFydChcXFwiY2hhcmFjdGVyXFxcIiwgc3RhcnQpXFxuICByZXR1cm4gclxcbn0gfVxcblxcbmZ1bmN0aW9uIGNvbnRhaW5zKHBhcmVudCwgY2hpbGQpIHtcXG4gIGlmIChjaGlsZC5ub2RlVHlwZSA9PSAzKSAvLyBBbmRyb2lkIGJyb3dzZXIgYWx3YXlzIHJldHVybnMgZmFsc2Ugd2hlbiBjaGlsZCBpcyBhIHRleHRub2RlXFxuICAgIHsgY2hpbGQgPSBjaGlsZC5wYXJlbnROb2RlIH1cXG4gIGlmIChwYXJlbnQuY29udGFpbnMpXFxuICAgIHsgcmV0dXJuIHBhcmVudC5jb250YWlucyhjaGlsZCkgfVxcbiAgZG8ge1xcbiAgICBpZiAoY2hpbGQubm9kZVR5cGUgPT0gMTEpIHsgY2hpbGQgPSBjaGlsZC5ob3N0IH1cXG4gICAgaWYgKGNoaWxkID09IHBhcmVudCkgeyByZXR1cm4gdHJ1ZSB9XFxuICB9IHdoaWxlIChjaGlsZCA9IGNoaWxkLnBhcmVudE5vZGUpXFxufVxcblxcbnZhciBhY3RpdmVFbHQgPSBmdW5jdGlvbigpIHtcXG4gIHZhciBhY3RpdmVFbGVtZW50ID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudFxcbiAgd2hpbGUgKGFjdGl2ZUVsZW1lbnQgJiYgYWN0aXZlRWxlbWVudC5yb290ICYmIGFjdGl2ZUVsZW1lbnQucm9vdC5hY3RpdmVFbGVtZW50KVxcbiAgICB7IGFjdGl2ZUVsZW1lbnQgPSBhY3RpdmVFbGVtZW50LnJvb3QuYWN0aXZlRWxlbWVudCB9XFxuICByZXR1cm4gYWN0aXZlRWxlbWVudFxcbn1cXG4vLyBPbGRlciB2ZXJzaW9ucyBvZiBJRSB0aHJvd3MgdW5zcGVjaWZpZWQgZXJyb3Igd2hlbiB0b3VjaGluZ1xcbi8vIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgaW4gc29tZSBjYXNlcyAoZHVyaW5nIGxvYWRpbmcsIGluIGlmcmFtZSlcXG5pZiAoaWUgJiYgaWVfdmVyc2lvbiA8IDExKSB7IGFjdGl2ZUVsdCA9IGZ1bmN0aW9uKCkge1xcbiAgdHJ5IHsgcmV0dXJuIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgfVxcbiAgY2F0Y2goZSkgeyByZXR1cm4gZG9jdW1lbnQuYm9keSB9XFxufSB9XFxuXFxuZnVuY3Rpb24gYWRkQ2xhc3Mobm9kZSwgY2xzKSB7XFxuICB2YXIgY3VycmVudCA9IG5vZGUuY2xhc3NOYW1lXFxuICBpZiAoIWNsYXNzVGVzdChjbHMpLnRlc3QoY3VycmVudCkpIHsgbm9kZS5jbGFzc05hbWUgKz0gKGN1cnJlbnQgPyBcXFwiIFxcXCIgOiBcXFwiXFxcIikgKyBjbHMgfVxcbn1cXG5mdW5jdGlvbiBqb2luQ2xhc3NlcyhhLCBiKSB7XFxuICB2YXIgYXMgPSBhLnNwbGl0KFxcXCIgXFxcIilcXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXMubGVuZ3RoOyBpKyspXFxuICAgIHsgaWYgKGFzW2ldICYmICFjbGFzc1Rlc3QoYXNbaV0pLnRlc3QoYikpIHsgYiArPSBcXFwiIFxcXCIgKyBhc1tpXSB9IH1cXG4gIHJldHVybiBiXFxufVxcblxcbnZhciBzZWxlY3RJbnB1dCA9IGZ1bmN0aW9uKG5vZGUpIHsgbm9kZS5zZWxlY3QoKSB9XFxuaWYgKGlvcykgLy8gTW9iaWxlIFNhZmFyaSBhcHBhcmVudGx5IGhhcyBhIGJ1ZyB3aGVyZSBzZWxlY3QoKSBpcyBicm9rZW4uXFxuICB7IHNlbGVjdElucHV0ID0gZnVuY3Rpb24obm9kZSkgeyBub2RlLnNlbGVjdGlvblN0YXJ0ID0gMDsgbm9kZS5zZWxlY3Rpb25FbmQgPSBub2RlLnZhbHVlLmxlbmd0aCB9IH1cXG5lbHNlIGlmIChpZSkgLy8gU3VwcHJlc3MgbXlzdGVyaW91cyBJRTEwIGVycm9yc1xcbiAgeyBzZWxlY3RJbnB1dCA9IGZ1bmN0aW9uKG5vZGUpIHsgdHJ5IHsgbm9kZS5zZWxlY3QoKSB9IGNhdGNoKF9lKSB7fSB9IH1cXG5cXG5mdW5jdGlvbiBiaW5kKGYpIHtcXG4gIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKVxcbiAgcmV0dXJuIGZ1bmN0aW9uKCl7cmV0dXJuIGYuYXBwbHkobnVsbCwgYXJncyl9XFxufVxcblxcbmZ1bmN0aW9uIGNvcHlPYmoob2JqLCB0YXJnZXQsIG92ZXJ3cml0ZSkge1xcbiAgaWYgKCF0YXJnZXQpIHsgdGFyZ2V0ID0ge30gfVxcbiAgZm9yICh2YXIgcHJvcCBpbiBvYmopXFxuICAgIHsgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShwcm9wKSAmJiAob3ZlcndyaXRlICE9PSBmYWxzZSB8fCAhdGFyZ2V0Lmhhc093blByb3BlcnR5KHByb3ApKSlcXG4gICAgICB7IHRhcmdldFtwcm9wXSA9IG9ialtwcm9wXSB9IH1cXG4gIHJldHVybiB0YXJnZXRcXG59XFxuXFxuLy8gQ291bnRzIHRoZSBjb2x1bW4gb2Zmc2V0IGluIGEgc3RyaW5nLCB0YWtpbmcgdGFicyBpbnRvIGFjY291bnQuXFxuLy8gVXNlZCBtb3N0bHkgdG8gZmluZCBpbmRlbnRhdGlvbi5cXG5mdW5jdGlvbiBjb3VudENvbHVtbihzdHJpbmcsIGVuZCwgdGFiU2l6ZSwgc3RhcnRJbmRleCwgc3RhcnRWYWx1ZSkge1xcbiAgaWYgKGVuZCA9PSBudWxsKSB7XFxuICAgIGVuZCA9IHN0cmluZy5zZWFyY2goL1teXFxcXHNcXFxcdTAwYTBdLylcXG4gICAgaWYgKGVuZCA9PSAtMSkgeyBlbmQgPSBzdHJpbmcubGVuZ3RoIH1cXG4gIH1cXG4gIGZvciAodmFyIGkgPSBzdGFydEluZGV4IHx8IDAsIG4gPSBzdGFydFZhbHVlIHx8IDA7Oykge1xcbiAgICB2YXIgbmV4dFRhYiA9IHN0cmluZy5pbmRleE9mKFxcXCJcXFxcdFxcXCIsIGkpXFxuICAgIGlmIChuZXh0VGFiIDwgMCB8fCBuZXh0VGFiID49IGVuZClcXG4gICAgICB7IHJldHVybiBuICsgKGVuZCAtIGkpIH1cXG4gICAgbiArPSBuZXh0VGFiIC0gaVxcbiAgICBuICs9IHRhYlNpemUgLSAobiAlIHRhYlNpemUpXFxuICAgIGkgPSBuZXh0VGFiICsgMVxcbiAgfVxcbn1cXG5cXG5mdW5jdGlvbiBEZWxheWVkKCkge3RoaXMuaWQgPSBudWxsfVxcbkRlbGF5ZWQucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uKG1zLCBmKSB7XFxuICBjbGVhclRpbWVvdXQodGhpcy5pZClcXG4gIHRoaXMuaWQgPSBzZXRUaW1lb3V0KGYsIG1zKVxcbn1cXG5cXG5mdW5jdGlvbiBpbmRleE9mKGFycmF5LCBlbHQpIHtcXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyArK2kpXFxuICAgIHsgaWYgKGFycmF5W2ldID09IGVsdCkgeyByZXR1cm4gaSB9IH1cXG4gIHJldHVybiAtMVxcbn1cXG5cXG4vLyBOdW1iZXIgb2YgcGl4ZWxzIGFkZGVkIHRvIHNjcm9sbGVyIGFuZCBzaXplciB0byBoaWRlIHNjcm9sbGJhclxcbnZhciBzY3JvbGxlckdhcCA9IDMwXFxuXFxuLy8gUmV0dXJuZWQgb3IgdGhyb3duIGJ5IHZhcmlvdXMgcHJvdG9jb2xzIHRvIHNpZ25hbCAnSSdtIG5vdFxcbi8vIGhhbmRsaW5nIHRoaXMnLlxcbnZhciBQYXNzID0ge3RvU3RyaW5nOiBmdW5jdGlvbigpe3JldHVybiBcXFwiQ29kZU1pcnJvci5QYXNzXFxcIn19XFxuXFxuLy8gUmV1c2VkIG9wdGlvbiBvYmplY3RzIGZvciBzZXRTZWxlY3Rpb24gJiBmcmllbmRzXFxudmFyIHNlbF9kb250U2Nyb2xsID0ge3Njcm9sbDogZmFsc2V9O1xcbnZhciBzZWxfbW91c2UgPSB7b3JpZ2luOiBcXFwiKm1vdXNlXFxcIn07XFxudmFyIHNlbF9tb3ZlID0ge29yaWdpbjogXFxcIittb3ZlXFxcIn07XFxuLy8gVGhlIGludmVyc2Ugb2YgY291bnRDb2x1bW4gLS0gZmluZCB0aGUgb2Zmc2V0IHRoYXQgY29ycmVzcG9uZHMgdG9cXG4vLyBhIHBhcnRpY3VsYXIgY29sdW1uLlxcbmZ1bmN0aW9uIGZpbmRDb2x1bW4oc3RyaW5nLCBnb2FsLCB0YWJTaXplKSB7XFxuICBmb3IgKHZhciBwb3MgPSAwLCBjb2wgPSAwOzspIHtcXG4gICAgdmFyIG5leHRUYWIgPSBzdHJpbmcuaW5kZXhPZihcXFwiXFxcXHRcXFwiLCBwb3MpXFxuICAgIGlmIChuZXh0VGFiID09IC0xKSB7IG5leHRUYWIgPSBzdHJpbmcubGVuZ3RoIH1cXG4gICAgdmFyIHNraXBwZWQgPSBuZXh0VGFiIC0gcG9zXFxuICAgIGlmIChuZXh0VGFiID09IHN0cmluZy5sZW5ndGggfHwgY29sICsgc2tpcHBlZCA+PSBnb2FsKVxcbiAgICAgIHsgcmV0dXJuIHBvcyArIE1hdGgubWluKHNraXBwZWQsIGdvYWwgLSBjb2wpIH1cXG4gICAgY29sICs9IG5leHRUYWIgLSBwb3NcXG4gICAgY29sICs9IHRhYlNpemUgLSAoY29sICUgdGFiU2l6ZSlcXG4gICAgcG9zID0gbmV4dFRhYiArIDFcXG4gICAgaWYgKGNvbCA+PSBnb2FsKSB7IHJldHVybiBwb3MgfVxcbiAgfVxcbn1cXG5cXG52YXIgc3BhY2VTdHJzID0gW1xcXCJcXFwiXVxcbmZ1bmN0aW9uIHNwYWNlU3RyKG4pIHtcXG4gIHdoaWxlIChzcGFjZVN0cnMubGVuZ3RoIDw9IG4pXFxuICAgIHsgc3BhY2VTdHJzLnB1c2gobHN0KHNwYWNlU3RycykgKyBcXFwiIFxcXCIpIH1cXG4gIHJldHVybiBzcGFjZVN0cnNbbl1cXG59XFxuXFxuZnVuY3Rpb24gbHN0KGFycikgeyByZXR1cm4gYXJyW2Fyci5sZW5ndGgtMV0gfVxcblxcbmZ1bmN0aW9uIG1hcChhcnJheSwgZikge1xcbiAgdmFyIG91dCA9IFtdXFxuICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7IG91dFtpXSA9IGYoYXJyYXlbaV0sIGkpIH1cXG4gIHJldHVybiBvdXRcXG59XFxuXFxuZnVuY3Rpb24gaW5zZXJ0U29ydGVkKGFycmF5LCB2YWx1ZSwgc2NvcmUpIHtcXG4gIHZhciBwb3MgPSAwLCBwcmlvcml0eSA9IHNjb3JlKHZhbHVlKVxcbiAgd2hpbGUgKHBvcyA8IGFycmF5Lmxlbmd0aCAmJiBzY29yZShhcnJheVtwb3NdKSA8PSBwcmlvcml0eSkgeyBwb3MrKyB9XFxuICBhcnJheS5zcGxpY2UocG9zLCAwLCB2YWx1ZSlcXG59XFxuXFxuZnVuY3Rpb24gbm90aGluZygpIHt9XFxuXFxuZnVuY3Rpb24gY3JlYXRlT2JqKGJhc2UsIHByb3BzKSB7XFxuICB2YXIgaW5zdFxcbiAgaWYgKE9iamVjdC5jcmVhdGUpIHtcXG4gICAgaW5zdCA9IE9iamVjdC5jcmVhdGUoYmFzZSlcXG4gIH0gZWxzZSB7XFxuICAgIG5vdGhpbmcucHJvdG90eXBlID0gYmFzZVxcbiAgICBpbnN0ID0gbmV3IG5vdGhpbmcoKVxcbiAgfVxcbiAgaWYgKHByb3BzKSB7IGNvcHlPYmoocHJvcHMsIGluc3QpIH1cXG4gIHJldHVybiBpbnN0XFxufVxcblxcbnZhciBub25BU0NJSVNpbmdsZUNhc2VXb3JkQ2hhciA9IC9bXFxcXHUwMGRmXFxcXHUwNTg3XFxcXHUwNTkwLVxcXFx1MDVmNFxcXFx1MDYwMC1cXFxcdTA2ZmZcXFxcdTMwNDAtXFxcXHUzMDlmXFxcXHUzMGEwLVxcXFx1MzBmZlxcXFx1MzQwMC1cXFxcdTRkYjVcXFxcdTRlMDAtXFxcXHU5ZmNjXFxcXHVhYzAwLVxcXFx1ZDdhZl0vXFxuZnVuY3Rpb24gaXNXb3JkQ2hhckJhc2ljKGNoKSB7XFxuICByZXR1cm4gL1xcXFx3Ly50ZXN0KGNoKSB8fCBjaCA+IFxcXCJcXFxceDgwXFxcIiAmJlxcbiAgICAoY2gudG9VcHBlckNhc2UoKSAhPSBjaC50b0xvd2VyQ2FzZSgpIHx8IG5vbkFTQ0lJU2luZ2xlQ2FzZVdvcmRDaGFyLnRlc3QoY2gpKVxcbn1cXG5mdW5jdGlvbiBpc1dvcmRDaGFyKGNoLCBoZWxwZXIpIHtcXG4gIGlmICghaGVscGVyKSB7IHJldHVybiBpc1dvcmRDaGFyQmFzaWMoY2gpIH1cXG4gIGlmIChoZWxwZXIuc291cmNlLmluZGV4T2YoXFxcIlxcXFxcXFxcd1xcXCIpID4gLTEgJiYgaXNXb3JkQ2hhckJhc2ljKGNoKSkgeyByZXR1cm4gdHJ1ZSB9XFxuICByZXR1cm4gaGVscGVyLnRlc3QoY2gpXFxufVxcblxcbmZ1bmN0aW9uIGlzRW1wdHkob2JqKSB7XFxuICBmb3IgKHZhciBuIGluIG9iaikgeyBpZiAob2JqLmhhc093blByb3BlcnR5KG4pICYmIG9ialtuXSkgeyByZXR1cm4gZmFsc2UgfSB9XFxuICByZXR1cm4gdHJ1ZVxcbn1cXG5cXG4vLyBFeHRlbmRpbmcgdW5pY29kZSBjaGFyYWN0ZXJzLiBBIHNlcmllcyBvZiBhIG5vbi1leHRlbmRpbmcgY2hhciArXFxuLy8gYW55IG51bWJlciBvZiBleHRlbmRpbmcgY2hhcnMgaXMgdHJlYXRlZCBhcyBhIHNpbmdsZSB1bml0IGFzIGZhclxcbi8vIGFzIGVkaXRpbmcgYW5kIG1lYXN1cmluZyBpcyBjb25jZXJuZWQuIFRoaXMgaXMgbm90IGZ1bGx5IGNvcnJlY3QsXFxuLy8gc2luY2Ugc29tZSBzY3JpcHRzL2ZvbnRzL2Jyb3dzZXJzIGFsc28gdHJlYXQgb3RoZXIgY29uZmlndXJhdGlvbnNcXG4vLyBvZiBjb2RlIHBvaW50cyBhcyBhIGdyb3VwLlxcbnZhciBleHRlbmRpbmdDaGFycyA9IC9bXFxcXHUwMzAwLVxcXFx1MDM2ZlxcXFx1MDQ4My1cXFxcdTA0ODlcXFxcdTA1OTEtXFxcXHUwNWJkXFxcXHUwNWJmXFxcXHUwNWMxXFxcXHUwNWMyXFxcXHUwNWM0XFxcXHUwNWM1XFxcXHUwNWM3XFxcXHUwNjEwLVxcXFx1MDYxYVxcXFx1MDY0Yi1cXFxcdTA2NWVcXFxcdTA2NzBcXFxcdTA2ZDYtXFxcXHUwNmRjXFxcXHUwNmRlLVxcXFx1MDZlNFxcXFx1MDZlN1xcXFx1MDZlOFxcXFx1MDZlYS1cXFxcdTA2ZWRcXFxcdTA3MTFcXFxcdTA3MzAtXFxcXHUwNzRhXFxcXHUwN2E2LVxcXFx1MDdiMFxcXFx1MDdlYi1cXFxcdTA3ZjNcXFxcdTA4MTYtXFxcXHUwODE5XFxcXHUwODFiLVxcXFx1MDgyM1xcXFx1MDgyNS1cXFxcdTA4MjdcXFxcdTA4MjktXFxcXHUwODJkXFxcXHUwOTAwLVxcXFx1MDkwMlxcXFx1MDkzY1xcXFx1MDk0MS1cXFxcdTA5NDhcXFxcdTA5NGRcXFxcdTA5NTEtXFxcXHUwOTU1XFxcXHUwOTYyXFxcXHUwOTYzXFxcXHUwOTgxXFxcXHUwOWJjXFxcXHUwOWJlXFxcXHUwOWMxLVxcXFx1MDljNFxcXFx1MDljZFxcXFx1MDlkN1xcXFx1MDllMlxcXFx1MDllM1xcXFx1MGEwMVxcXFx1MGEwMlxcXFx1MGEzY1xcXFx1MGE0MVxcXFx1MGE0MlxcXFx1MGE0N1xcXFx1MGE0OFxcXFx1MGE0Yi1cXFxcdTBhNGRcXFxcdTBhNTFcXFxcdTBhNzBcXFxcdTBhNzFcXFxcdTBhNzVcXFxcdTBhODFcXFxcdTBhODJcXFxcdTBhYmNcXFxcdTBhYzEtXFxcXHUwYWM1XFxcXHUwYWM3XFxcXHUwYWM4XFxcXHUwYWNkXFxcXHUwYWUyXFxcXHUwYWUzXFxcXHUwYjAxXFxcXHUwYjNjXFxcXHUwYjNlXFxcXHUwYjNmXFxcXHUwYjQxLVxcXFx1MGI0NFxcXFx1MGI0ZFxcXFx1MGI1NlxcXFx1MGI1N1xcXFx1MGI2MlxcXFx1MGI2M1xcXFx1MGI4MlxcXFx1MGJiZVxcXFx1MGJjMFxcXFx1MGJjZFxcXFx1MGJkN1xcXFx1MGMzZS1cXFxcdTBjNDBcXFxcdTBjNDYtXFxcXHUwYzQ4XFxcXHUwYzRhLVxcXFx1MGM0ZFxcXFx1MGM1NVxcXFx1MGM1NlxcXFx1MGM2MlxcXFx1MGM2M1xcXFx1MGNiY1xcXFx1MGNiZlxcXFx1MGNjMlxcXFx1MGNjNlxcXFx1MGNjY1xcXFx1MGNjZFxcXFx1MGNkNVxcXFx1MGNkNlxcXFx1MGNlMlxcXFx1MGNlM1xcXFx1MGQzZVxcXFx1MGQ0MS1cXFxcdTBkNDRcXFxcdTBkNGRcXFxcdTBkNTdcXFxcdTBkNjJcXFxcdTBkNjNcXFxcdTBkY2FcXFxcdTBkY2ZcXFxcdTBkZDItXFxcXHUwZGQ0XFxcXHUwZGQ2XFxcXHUwZGRmXFxcXHUwZTMxXFxcXHUwZTM0LVxcXFx1MGUzYVxcXFx1MGU0Ny1cXFxcdTBlNGVcXFxcdTBlYjFcXFxcdTBlYjQtXFxcXHUwZWI5XFxcXHUwZWJiXFxcXHUwZWJjXFxcXHUwZWM4LVxcXFx1MGVjZFxcXFx1MGYxOFxcXFx1MGYxOVxcXFx1MGYzNVxcXFx1MGYzN1xcXFx1MGYzOVxcXFx1MGY3MS1cXFxcdTBmN2VcXFxcdTBmODAtXFxcXHUwZjg0XFxcXHUwZjg2XFxcXHUwZjg3XFxcXHUwZjkwLVxcXFx1MGY5N1xcXFx1MGY5OS1cXFxcdTBmYmNcXFxcdTBmYzZcXFxcdTEwMmQtXFxcXHUxMDMwXFxcXHUxMDMyLVxcXFx1MTAzN1xcXFx1MTAzOVxcXFx1MTAzYVxcXFx1MTAzZFxcXFx1MTAzZVxcXFx1MTA1OFxcXFx1MTA1OVxcXFx1MTA1ZS1cXFxcdTEwNjBcXFxcdTEwNzEtXFxcXHUxMDc0XFxcXHUxMDgyXFxcXHUxMDg1XFxcXHUxMDg2XFxcXHUxMDhkXFxcXHUxMDlkXFxcXHUxMzVmXFxcXHUxNzEyLVxcXFx1MTcxNFxcXFx1MTczMi1cXFxcdTE3MzRcXFxcdTE3NTJcXFxcdTE3NTNcXFxcdTE3NzJcXFxcdTE3NzNcXFxcdTE3YjctXFxcXHUxN2JkXFxcXHUxN2M2XFxcXHUxN2M5LVxcXFx1MTdkM1xcXFx1MTdkZFxcXFx1MTgwYi1cXFxcdTE4MGRcXFxcdTE4YTlcXFxcdTE5MjAtXFxcXHUxOTIyXFxcXHUxOTI3XFxcXHUxOTI4XFxcXHUxOTMyXFxcXHUxOTM5LVxcXFx1MTkzYlxcXFx1MWExN1xcXFx1MWExOFxcXFx1MWE1NlxcXFx1MWE1OC1cXFxcdTFhNWVcXFxcdTFhNjBcXFxcdTFhNjJcXFxcdTFhNjUtXFxcXHUxYTZjXFxcXHUxYTczLVxcXFx1MWE3Y1xcXFx1MWE3ZlxcXFx1MWIwMC1cXFxcdTFiMDNcXFxcdTFiMzRcXFxcdTFiMzYtXFxcXHUxYjNhXFxcXHUxYjNjXFxcXHUxYjQyXFxcXHUxYjZiLVxcXFx1MWI3M1xcXFx1MWI4MFxcXFx1MWI4MVxcXFx1MWJhMi1cXFxcdTFiYTVcXFxcdTFiYThcXFxcdTFiYTlcXFxcdTFjMmMtXFxcXHUxYzMzXFxcXHUxYzM2XFxcXHUxYzM3XFxcXHUxY2QwLVxcXFx1MWNkMlxcXFx1MWNkNC1cXFxcdTFjZTBcXFxcdTFjZTItXFxcXHUxY2U4XFxcXHUxY2VkXFxcXHUxZGMwLVxcXFx1MWRlNlxcXFx1MWRmZC1cXFxcdTFkZmZcXFxcdTIwMGNcXFxcdTIwMGRcXFxcdTIwZDAtXFxcXHUyMGYwXFxcXHUyY2VmLVxcXFx1MmNmMVxcXFx1MmRlMC1cXFxcdTJkZmZcXFxcdTMwMmEtXFxcXHUzMDJmXFxcXHUzMDk5XFxcXHUzMDlhXFxcXHVhNjZmLVxcXFx1YTY3MlxcXFx1YTY3Y1xcXFx1YTY3ZFxcXFx1YTZmMFxcXFx1YTZmMVxcXFx1YTgwMlxcXFx1YTgwNlxcXFx1YTgwYlxcXFx1YTgyNVxcXFx1YTgyNlxcXFx1YThjNFxcXFx1YThlMC1cXFxcdWE4ZjFcXFxcdWE5MjYtXFxcXHVhOTJkXFxcXHVhOTQ3LVxcXFx1YTk1MVxcXFx1YTk4MC1cXFxcdWE5ODJcXFxcdWE5YjNcXFxcdWE5YjYtXFxcXHVhOWI5XFxcXHVhOWJjXFxcXHVhYTI5LVxcXFx1YWEyZVxcXFx1YWEzMVxcXFx1YWEzMlxcXFx1YWEzNVxcXFx1YWEzNlxcXFx1YWE0M1xcXFx1YWE0Y1xcXFx1YWFiMFxcXFx1YWFiMi1cXFxcdWFhYjRcXFxcdWFhYjdcXFxcdWFhYjhcXFxcdWFhYmVcXFxcdWFhYmZcXFxcdWFhYzFcXFxcdWFiZTVcXFxcdWFiZThcXFxcdWFiZWRcXFxcdWRjMDAtXFxcXHVkZmZmXFxcXHVmYjFlXFxcXHVmZTAwLVxcXFx1ZmUwZlxcXFx1ZmUyMC1cXFxcdWZlMjZcXFxcdWZmOWVcXFxcdWZmOWZdL1xcbmZ1bmN0aW9uIGlzRXh0ZW5kaW5nQ2hhcihjaCkgeyByZXR1cm4gY2guY2hhckNvZGVBdCgwKSA+PSA3NjggJiYgZXh0ZW5kaW5nQ2hhcnMudGVzdChjaCkgfVxcblxcbi8vIFRoZSBkaXNwbGF5IGhhbmRsZXMgdGhlIERPTSBpbnRlZ3JhdGlvbiwgYm90aCBmb3IgaW5wdXQgcmVhZGluZ1xcbi8vIGFuZCBjb250ZW50IGRyYXdpbmcuIEl0IGhvbGRzIHJlZmVyZW5jZXMgdG8gRE9NIG5vZGVzIGFuZFxcbi8vIGRpc3BsYXktcmVsYXRlZCBzdGF0ZS5cXG5cXG5mdW5jdGlvbiBEaXNwbGF5KHBsYWNlLCBkb2MsIGlucHV0KSB7XFxuICB2YXIgZCA9IHRoaXNcXG4gIHRoaXMuaW5wdXQgPSBpbnB1dFxcblxcbiAgLy8gQ292ZXJzIGJvdHRvbS1yaWdodCBzcXVhcmUgd2hlbiBib3RoIHNjcm9sbGJhcnMgYXJlIHByZXNlbnQuXFxuICBkLnNjcm9sbGJhckZpbGxlciA9IGVsdChcXFwiZGl2XFxcIiwgbnVsbCwgXFxcIkNvZGVNaXJyb3Itc2Nyb2xsYmFyLWZpbGxlclxcXCIpXFxuICBkLnNjcm9sbGJhckZpbGxlci5zZXRBdHRyaWJ1dGUoXFxcImNtLW5vdC1jb250ZW50XFxcIiwgXFxcInRydWVcXFwiKVxcbiAgLy8gQ292ZXJzIGJvdHRvbSBvZiBndXR0ZXIgd2hlbiBjb3Zlckd1dHRlck5leHRUb1Njcm9sbGJhciBpcyBvblxcbiAgLy8gYW5kIGggc2Nyb2xsYmFyIGlzIHByZXNlbnQuXFxuICBkLmd1dHRlckZpbGxlciA9IGVsdChcXFwiZGl2XFxcIiwgbnVsbCwgXFxcIkNvZGVNaXJyb3ItZ3V0dGVyLWZpbGxlclxcXCIpXFxuICBkLmd1dHRlckZpbGxlci5zZXRBdHRyaWJ1dGUoXFxcImNtLW5vdC1jb250ZW50XFxcIiwgXFxcInRydWVcXFwiKVxcbiAgLy8gV2lsbCBjb250YWluIHRoZSBhY3R1YWwgY29kZSwgcG9zaXRpb25lZCB0byBjb3ZlciB0aGUgdmlld3BvcnQuXFxuICBkLmxpbmVEaXYgPSBlbHQoXFxcImRpdlxcXCIsIG51bGwsIFxcXCJDb2RlTWlycm9yLWNvZGVcXFwiKVxcbiAgLy8gRWxlbWVudHMgYXJlIGFkZGVkIHRvIHRoZXNlIHRvIHJlcHJlc2VudCBzZWxlY3Rpb24gYW5kIGN1cnNvcnMuXFxuICBkLnNlbGVjdGlvbkRpdiA9IGVsdChcXFwiZGl2XFxcIiwgbnVsbCwgbnVsbCwgXFxcInBvc2l0aW9uOiByZWxhdGl2ZTsgei1pbmRleDogMVxcXCIpXFxuICBkLmN1cnNvckRpdiA9IGVsdChcXFwiZGl2XFxcIiwgbnVsbCwgXFxcIkNvZGVNaXJyb3ItY3Vyc29yc1xcXCIpXFxuICAvLyBBIHZpc2liaWxpdHk6IGhpZGRlbiBlbGVtZW50IHVzZWQgdG8gZmluZCB0aGUgc2l6ZSBvZiB0aGluZ3MuXFxuICBkLm1lYXN1cmUgPSBlbHQoXFxcImRpdlxcXCIsIG51bGwsIFxcXCJDb2RlTWlycm9yLW1lYXN1cmVcXFwiKVxcbiAgLy8gV2hlbiBsaW5lcyBvdXRzaWRlIG9mIHRoZSB2aWV3cG9ydCBhcmUgbWVhc3VyZWQsIHRoZXkgYXJlIGRyYXduIGluIHRoaXMuXFxuICBkLmxpbmVNZWFzdXJlID0gZWx0KFxcXCJkaXZcXFwiLCBudWxsLCBcXFwiQ29kZU1pcnJvci1tZWFzdXJlXFxcIilcXG4gIC8vIFdyYXBzIGV2ZXJ5dGhpbmcgdGhhdCBuZWVkcyB0byBleGlzdCBpbnNpZGUgdGhlIHZlcnRpY2FsbHktcGFkZGVkIGNvb3JkaW5hdGUgc3lzdGVtXFxuICBkLmxpbmVTcGFjZSA9IGVsdChcXFwiZGl2XFxcIiwgW2QubWVhc3VyZSwgZC5saW5lTWVhc3VyZSwgZC5zZWxlY3Rpb25EaXYsIGQuY3Vyc29yRGl2LCBkLmxpbmVEaXZdLFxcbiAgICAgICAgICAgICAgICAgICAgbnVsbCwgXFxcInBvc2l0aW9uOiByZWxhdGl2ZTsgb3V0bGluZTogbm9uZVxcXCIpXFxuICAvLyBNb3ZlZCBhcm91bmQgaXRzIHBhcmVudCB0byBjb3ZlciB2aXNpYmxlIHZpZXcuXFxuICBkLm1vdmVyID0gZWx0KFxcXCJkaXZcXFwiLCBbZWx0KFxcXCJkaXZcXFwiLCBbZC5saW5lU3BhY2VdLCBcXFwiQ29kZU1pcnJvci1saW5lc1xcXCIpXSwgbnVsbCwgXFxcInBvc2l0aW9uOiByZWxhdGl2ZVxcXCIpXFxuICAvLyBTZXQgdG8gdGhlIGhlaWdodCBvZiB0aGUgZG9jdW1lbnQsIGFsbG93aW5nIHNjcm9sbGluZy5cXG4gIGQuc2l6ZXIgPSBlbHQoXFxcImRpdlxcXCIsIFtkLm1vdmVyXSwgXFxcIkNvZGVNaXJyb3Itc2l6ZXJcXFwiKVxcbiAgZC5zaXplcldpZHRoID0gbnVsbFxcbiAgLy8gQmVoYXZpb3Igb2YgZWx0cyB3aXRoIG92ZXJmbG93OiBhdXRvIGFuZCBwYWRkaW5nIGlzXFxuICAvLyBpbmNvbnNpc3RlbnQgYWNyb3NzIGJyb3dzZXJzLiBUaGlzIGlzIHVzZWQgdG8gZW5zdXJlIHRoZVxcbiAgLy8gc2Nyb2xsYWJsZSBhcmVhIGlzIGJpZyBlbm91Z2guXFxuICBkLmhlaWdodEZvcmNlciA9IGVsdChcXFwiZGl2XFxcIiwgbnVsbCwgbnVsbCwgXFxcInBvc2l0aW9uOiBhYnNvbHV0ZTsgaGVpZ2h0OiBcXFwiICsgc2Nyb2xsZXJHYXAgKyBcXFwicHg7IHdpZHRoOiAxcHg7XFxcIilcXG4gIC8vIFdpbGwgY29udGFpbiB0aGUgZ3V0dGVycywgaWYgYW55LlxcbiAgZC5ndXR0ZXJzID0gZWx0KFxcXCJkaXZcXFwiLCBudWxsLCBcXFwiQ29kZU1pcnJvci1ndXR0ZXJzXFxcIilcXG4gIGQubGluZUd1dHRlciA9IG51bGxcXG4gIC8vIEFjdHVhbCBzY3JvbGxhYmxlIGVsZW1lbnQuXFxuICBkLnNjcm9sbGVyID0gZWx0KFxcXCJkaXZcXFwiLCBbZC5zaXplciwgZC5oZWlnaHRGb3JjZXIsIGQuZ3V0dGVyc10sIFxcXCJDb2RlTWlycm9yLXNjcm9sbFxcXCIpXFxuICBkLnNjcm9sbGVyLnNldEF0dHJpYnV0ZShcXFwidGFiSW5kZXhcXFwiLCBcXFwiLTFcXFwiKVxcbiAgLy8gVGhlIGVsZW1lbnQgaW4gd2hpY2ggdGhlIGVkaXRvciBsaXZlcy5cXG4gIGQud3JhcHBlciA9IGVsdChcXFwiZGl2XFxcIiwgW2Quc2Nyb2xsYmFyRmlsbGVyLCBkLmd1dHRlckZpbGxlciwgZC5zY3JvbGxlcl0sIFxcXCJDb2RlTWlycm9yXFxcIilcXG5cXG4gIC8vIFdvcmsgYXJvdW5kIElFNyB6LWluZGV4IGJ1ZyAobm90IHBlcmZlY3QsIGhlbmNlIElFNyBub3QgcmVhbGx5IGJlaW5nIHN1cHBvcnRlZClcXG4gIGlmIChpZSAmJiBpZV92ZXJzaW9uIDwgOCkgeyBkLmd1dHRlcnMuc3R5bGUuekluZGV4ID0gLTE7IGQuc2Nyb2xsZXIuc3R5bGUucGFkZGluZ1JpZ2h0ID0gMCB9XFxuICBpZiAoIXdlYmtpdCAmJiAhKGdlY2tvICYmIG1vYmlsZSkpIHsgZC5zY3JvbGxlci5kcmFnZ2FibGUgPSB0cnVlIH1cXG5cXG4gIGlmIChwbGFjZSkge1xcbiAgICBpZiAocGxhY2UuYXBwZW5kQ2hpbGQpIHsgcGxhY2UuYXBwZW5kQ2hpbGQoZC53cmFwcGVyKSB9XFxuICAgIGVsc2UgeyBwbGFjZShkLndyYXBwZXIpIH1cXG4gIH1cXG5cXG4gIC8vIEN1cnJlbnQgcmVuZGVyZWQgcmFuZ2UgKG1heSBiZSBiaWdnZXIgdGhhbiB0aGUgdmlldyB3aW5kb3cpLlxcbiAgZC52aWV3RnJvbSA9IGQudmlld1RvID0gZG9jLmZpcnN0XFxuICBkLnJlcG9ydGVkVmlld0Zyb20gPSBkLnJlcG9ydGVkVmlld1RvID0gZG9jLmZpcnN0XFxuICAvLyBJbmZvcm1hdGlvbiBhYm91dCB0aGUgcmVuZGVyZWQgbGluZXMuXFxuICBkLnZpZXcgPSBbXVxcbiAgZC5yZW5kZXJlZFZpZXcgPSBudWxsXFxuICAvLyBIb2xkcyBpbmZvIGFib3V0IGEgc2luZ2xlIHJlbmRlcmVkIGxpbmUgd2hlbiBpdCB3YXMgcmVuZGVyZWRcXG4gIC8vIGZvciBtZWFzdXJlbWVudCwgd2hpbGUgbm90IGluIHZpZXcuXFxuICBkLmV4dGVybmFsTWVhc3VyZWQgPSBudWxsXFxuICAvLyBFbXB0eSBzcGFjZSAoaW4gcGl4ZWxzKSBhYm92ZSB0aGUgdmlld1xcbiAgZC52aWV3T2Zmc2V0ID0gMFxcbiAgZC5sYXN0V3JhcEhlaWdodCA9IGQubGFzdFdyYXBXaWR0aCA9IDBcXG4gIGQudXBkYXRlTGluZU51bWJlcnMgPSBudWxsXFxuXFxuICBkLm5hdGl2ZUJhcldpZHRoID0gZC5iYXJIZWlnaHQgPSBkLmJhcldpZHRoID0gMFxcbiAgZC5zY3JvbGxiYXJzQ2xpcHBlZCA9IGZhbHNlXFxuXFxuICAvLyBVc2VkIHRvIG9ubHkgcmVzaXplIHRoZSBsaW5lIG51bWJlciBndXR0ZXIgd2hlbiBuZWNlc3NhcnkgKHdoZW5cXG4gIC8vIHRoZSBhbW91bnQgb2YgbGluZXMgY3Jvc3NlcyBhIGJvdW5kYXJ5IHRoYXQgbWFrZXMgaXRzIHdpZHRoIGNoYW5nZSlcXG4gIGQubGluZU51bVdpZHRoID0gZC5saW5lTnVtSW5uZXJXaWR0aCA9IGQubGluZU51bUNoYXJzID0gbnVsbFxcbiAgLy8gU2V0IHRvIHRydWUgd2hlbiBhIG5vbi1ob3Jpem9udGFsLXNjcm9sbGluZyBsaW5lIHdpZGdldCBpc1xcbiAgLy8gYWRkZWQuIEFzIGFuIG9wdGltaXphdGlvbiwgbGluZSB3aWRnZXQgYWxpZ25pbmcgaXMgc2tpcHBlZCB3aGVuXFxuICAvLyB0aGlzIGlzIGZhbHNlLlxcbiAgZC5hbGlnbldpZGdldHMgPSBmYWxzZVxcblxcbiAgZC5jYWNoZWRDaGFyV2lkdGggPSBkLmNhY2hlZFRleHRIZWlnaHQgPSBkLmNhY2hlZFBhZGRpbmdIID0gbnVsbFxcblxcbiAgLy8gVHJhY2tzIHRoZSBtYXhpbXVtIGxpbmUgbGVuZ3RoIHNvIHRoYXQgdGhlIGhvcml6b250YWwgc2Nyb2xsYmFyXFxuICAvLyBjYW4gYmUga2VwdCBzdGF0aWMgd2hlbiBzY3JvbGxpbmcuXFxuICBkLm1heExpbmUgPSBudWxsXFxuICBkLm1heExpbmVMZW5ndGggPSAwXFxuICBkLm1heExpbmVDaGFuZ2VkID0gZmFsc2VcXG5cXG4gIC8vIFVzZWQgZm9yIG1lYXN1cmluZyB3aGVlbCBzY3JvbGxpbmcgZ3JhbnVsYXJpdHlcXG4gIGQud2hlZWxEWCA9IGQud2hlZWxEWSA9IGQud2hlZWxTdGFydFggPSBkLndoZWVsU3RhcnRZID0gbnVsbFxcblxcbiAgLy8gVHJ1ZSB3aGVuIHNoaWZ0IGlzIGhlbGQgZG93bi5cXG4gIGQuc2hpZnQgPSBmYWxzZVxcblxcbiAgLy8gVXNlZCB0byB0cmFjayB3aGV0aGVyIGFueXRoaW5nIGhhcHBlbmVkIHNpbmNlIHRoZSBjb250ZXh0IG1lbnVcXG4gIC8vIHdhcyBvcGVuZWQuXFxuICBkLnNlbEZvckNvbnRleHRNZW51ID0gbnVsbFxcblxcbiAgZC5hY3RpdmVUb3VjaCA9IG51bGxcXG5cXG4gIGlucHV0LmluaXQoZClcXG59XFxuXFxuLy8gRmluZCB0aGUgbGluZSBvYmplY3QgY29ycmVzcG9uZGluZyB0byB0aGUgZ2l2ZW4gbGluZSBudW1iZXIuXFxuZnVuY3Rpb24gZ2V0TGluZShkb2MsIG4pIHtcXG4gIG4gLT0gZG9jLmZpcnN0XFxuICBpZiAobiA8IDAgfHwgbiA+PSBkb2Muc2l6ZSkgeyB0aHJvdyBuZXcgRXJyb3IoXFxcIlRoZXJlIGlzIG5vIGxpbmUgXFxcIiArIChuICsgZG9jLmZpcnN0KSArIFxcXCIgaW4gdGhlIGRvY3VtZW50LlxcXCIpIH1cXG4gIHZhciBjaHVuayA9IGRvY1xcbiAgd2hpbGUgKCFjaHVuay5saW5lcykge1xcbiAgICBmb3IgKHZhciBpID0gMDs7ICsraSkge1xcbiAgICAgIHZhciBjaGlsZCA9IGNodW5rLmNoaWxkcmVuW2ldLCBzeiA9IGNoaWxkLmNodW5rU2l6ZSgpXFxuICAgICAgaWYgKG4gPCBzeikgeyBjaHVuayA9IGNoaWxkOyBicmVhayB9XFxuICAgICAgbiAtPSBzelxcbiAgICB9XFxuICB9XFxuICByZXR1cm4gY2h1bmsubGluZXNbbl1cXG59XFxuXFxuLy8gR2V0IHRoZSBwYXJ0IG9mIGEgZG9jdW1lbnQgYmV0d2VlbiB0d28gcG9zaXRpb25zLCBhcyBhbiBhcnJheSBvZlxcbi8vIHN0cmluZ3MuXFxuZnVuY3Rpb24gZ2V0QmV0d2Vlbihkb2MsIHN0YXJ0LCBlbmQpIHtcXG4gIHZhciBvdXQgPSBbXSwgbiA9IHN0YXJ0LmxpbmVcXG4gIGRvYy5pdGVyKHN0YXJ0LmxpbmUsIGVuZC5saW5lICsgMSwgZnVuY3Rpb24gKGxpbmUpIHtcXG4gICAgdmFyIHRleHQgPSBsaW5lLnRleHRcXG4gICAgaWYgKG4gPT0gZW5kLmxpbmUpIHsgdGV4dCA9IHRleHQuc2xpY2UoMCwgZW5kLmNoKSB9XFxuICAgIGlmIChuID09IHN0YXJ0LmxpbmUpIHsgdGV4dCA9IHRleHQuc2xpY2Uoc3RhcnQuY2gpIH1cXG4gICAgb3V0LnB1c2godGV4dClcXG4gICAgKytuXFxuICB9KVxcbiAgcmV0dXJuIG91dFxcbn1cXG4vLyBHZXQgdGhlIGxpbmVzIGJldHdlZW4gZnJvbSBhbmQgdG8sIGFzIGFycmF5IG9mIHN0cmluZ3MuXFxuZnVuY3Rpb24gZ2V0TGluZXMoZG9jLCBmcm9tLCB0bykge1xcbiAgdmFyIG91dCA9IFtdXFxuICBkb2MuaXRlcihmcm9tLCB0bywgZnVuY3Rpb24gKGxpbmUpIHsgb3V0LnB1c2gobGluZS50ZXh0KSB9KSAvLyBpdGVyIGFib3J0cyB3aGVuIGNhbGxiYWNrIHJldHVybnMgdHJ1dGh5IHZhbHVlXFxuICByZXR1cm4gb3V0XFxufVxcblxcbi8vIFVwZGF0ZSB0aGUgaGVpZ2h0IG9mIGEgbGluZSwgcHJvcGFnYXRpbmcgdGhlIGhlaWdodCBjaGFuZ2VcXG4vLyB1cHdhcmRzIHRvIHBhcmVudCBub2Rlcy5cXG5mdW5jdGlvbiB1cGRhdGVMaW5lSGVpZ2h0KGxpbmUsIGhlaWdodCkge1xcbiAgdmFyIGRpZmYgPSBoZWlnaHQgLSBsaW5lLmhlaWdodFxcbiAgaWYgKGRpZmYpIHsgZm9yICh2YXIgbiA9IGxpbmU7IG47IG4gPSBuLnBhcmVudCkgeyBuLmhlaWdodCArPSBkaWZmIH0gfVxcbn1cXG5cXG4vLyBHaXZlbiBhIGxpbmUgb2JqZWN0LCBmaW5kIGl0cyBsaW5lIG51bWJlciBieSB3YWxraW5nIHVwIHRocm91Z2hcXG4vLyBpdHMgcGFyZW50IGxpbmtzLlxcbmZ1bmN0aW9uIGxpbmVObyhsaW5lKSB7XFxuICBpZiAobGluZS5wYXJlbnQgPT0gbnVsbCkgeyByZXR1cm4gbnVsbCB9XFxuICB2YXIgY3VyID0gbGluZS5wYXJlbnQsIG5vID0gaW5kZXhPZihjdXIubGluZXMsIGxpbmUpXFxuICBmb3IgKHZhciBjaHVuayA9IGN1ci5wYXJlbnQ7IGNodW5rOyBjdXIgPSBjaHVuaywgY2h1bmsgPSBjaHVuay5wYXJlbnQpIHtcXG4gICAgZm9yICh2YXIgaSA9IDA7OyArK2kpIHtcXG4gICAgICBpZiAoY2h1bmsuY2hpbGRyZW5baV0gPT0gY3VyKSB7IGJyZWFrIH1cXG4gICAgICBubyArPSBjaHVuay5jaGlsZHJlbltpXS5jaHVua1NpemUoKVxcbiAgICB9XFxuICB9XFxuICByZXR1cm4gbm8gKyBjdXIuZmlyc3RcXG59XFxuXFxuLy8gRmluZCB0aGUgbGluZSBhdCB0aGUgZ2l2ZW4gdmVydGljYWwgcG9zaXRpb24sIHVzaW5nIHRoZSBoZWlnaHRcXG4vLyBpbmZvcm1hdGlvbiBpbiB0aGUgZG9jdW1lbnQgdHJlZS5cXG5mdW5jdGlvbiBsaW5lQXRIZWlnaHQoY2h1bmssIGgpIHtcXG4gIHZhciBuID0gY2h1bmsuZmlyc3RcXG4gIG91dGVyOiBkbyB7XFxuICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IGNodW5rLmNoaWxkcmVuLmxlbmd0aDsgKytpJDEpIHtcXG4gICAgICB2YXIgY2hpbGQgPSBjaHVuay5jaGlsZHJlbltpJDFdLCBjaCA9IGNoaWxkLmhlaWdodFxcbiAgICAgIGlmIChoIDwgY2gpIHsgY2h1bmsgPSBjaGlsZDsgY29udGludWUgb3V0ZXIgfVxcbiAgICAgIGggLT0gY2hcXG4gICAgICBuICs9IGNoaWxkLmNodW5rU2l6ZSgpXFxuICAgIH1cXG4gICAgcmV0dXJuIG5cXG4gIH0gd2hpbGUgKCFjaHVuay5saW5lcylcXG4gIHZhciBpID0gMFxcbiAgZm9yICg7IGkgPCBjaHVuay5saW5lcy5sZW5ndGg7ICsraSkge1xcbiAgICB2YXIgbGluZSA9IGNodW5rLmxpbmVzW2ldLCBsaCA9IGxpbmUuaGVpZ2h0XFxuICAgIGlmIChoIDwgbGgpIHsgYnJlYWsgfVxcbiAgICBoIC09IGxoXFxuICB9XFxuICByZXR1cm4gbiArIGlcXG59XFxuXFxuZnVuY3Rpb24gaXNMaW5lKGRvYywgbCkge3JldHVybiBsID49IGRvYy5maXJzdCAmJiBsIDwgZG9jLmZpcnN0ICsgZG9jLnNpemV9XFxuXFxuZnVuY3Rpb24gbGluZU51bWJlckZvcihvcHRpb25zLCBpKSB7XFxuICByZXR1cm4gU3RyaW5nKG9wdGlvbnMubGluZU51bWJlckZvcm1hdHRlcihpICsgb3B0aW9ucy5maXJzdExpbmVOdW1iZXIpKVxcbn1cXG5cXG4vLyBBIFBvcyBpbnN0YW5jZSByZXByZXNlbnRzIGEgcG9zaXRpb24gd2l0aGluIHRoZSB0ZXh0LlxcbmZ1bmN0aW9uIFBvcyAobGluZSwgY2gpIHtcXG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBQb3MpKSB7IHJldHVybiBuZXcgUG9zKGxpbmUsIGNoKSB9XFxuICB0aGlzLmxpbmUgPSBsaW5lOyB0aGlzLmNoID0gY2hcXG59XFxuXFxuLy8gQ29tcGFyZSB0d28gcG9zaXRpb25zLCByZXR1cm4gMCBpZiB0aGV5IGFyZSB0aGUgc2FtZSwgYSBuZWdhdGl2ZVxcbi8vIG51bWJlciB3aGVuIGEgaXMgbGVzcywgYW5kIGEgcG9zaXRpdmUgbnVtYmVyIG90aGVyd2lzZS5cXG5mdW5jdGlvbiBjbXAoYSwgYikgeyByZXR1cm4gYS5saW5lIC0gYi5saW5lIHx8IGEuY2ggLSBiLmNoIH1cXG5cXG5mdW5jdGlvbiBjb3B5UG9zKHgpIHtyZXR1cm4gUG9zKHgubGluZSwgeC5jaCl9XFxuZnVuY3Rpb24gbWF4UG9zKGEsIGIpIHsgcmV0dXJuIGNtcChhLCBiKSA8IDAgPyBiIDogYSB9XFxuZnVuY3Rpb24gbWluUG9zKGEsIGIpIHsgcmV0dXJuIGNtcChhLCBiKSA8IDAgPyBhIDogYiB9XFxuXFxuLy8gTW9zdCBvZiB0aGUgZXh0ZXJuYWwgQVBJIGNsaXBzIGdpdmVuIHBvc2l0aW9ucyB0byBtYWtlIHN1cmUgdGhleVxcbi8vIGFjdHVhbGx5IGV4aXN0IHdpdGhpbiB0aGUgZG9jdW1lbnQuXFxuZnVuY3Rpb24gY2xpcExpbmUoZG9jLCBuKSB7cmV0dXJuIE1hdGgubWF4KGRvYy5maXJzdCwgTWF0aC5taW4obiwgZG9jLmZpcnN0ICsgZG9jLnNpemUgLSAxKSl9XFxuZnVuY3Rpb24gY2xpcFBvcyhkb2MsIHBvcykge1xcbiAgaWYgKHBvcy5saW5lIDwgZG9jLmZpcnN0KSB7IHJldHVybiBQb3MoZG9jLmZpcnN0LCAwKSB9XFxuICB2YXIgbGFzdCA9IGRvYy5maXJzdCArIGRvYy5zaXplIC0gMVxcbiAgaWYgKHBvcy5saW5lID4gbGFzdCkgeyByZXR1cm4gUG9zKGxhc3QsIGdldExpbmUoZG9jLCBsYXN0KS50ZXh0Lmxlbmd0aCkgfVxcbiAgcmV0dXJuIGNsaXBUb0xlbihwb3MsIGdldExpbmUoZG9jLCBwb3MubGluZSkudGV4dC5sZW5ndGgpXFxufVxcbmZ1bmN0aW9uIGNsaXBUb0xlbihwb3MsIGxpbmVsZW4pIHtcXG4gIHZhciBjaCA9IHBvcy5jaFxcbiAgaWYgKGNoID09IG51bGwgfHwgY2ggPiBsaW5lbGVuKSB7IHJldHVybiBQb3MocG9zLmxpbmUsIGxpbmVsZW4pIH1cXG4gIGVsc2UgaWYgKGNoIDwgMCkgeyByZXR1cm4gUG9zKHBvcy5saW5lLCAwKSB9XFxuICBlbHNlIHsgcmV0dXJuIHBvcyB9XFxufVxcbmZ1bmN0aW9uIGNsaXBQb3NBcnJheShkb2MsIGFycmF5KSB7XFxuICB2YXIgb3V0ID0gW11cXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHsgb3V0W2ldID0gY2xpcFBvcyhkb2MsIGFycmF5W2ldKSB9XFxuICByZXR1cm4gb3V0XFxufVxcblxcbi8vIE9wdGltaXplIHNvbWUgY29kZSB3aGVuIHRoZXNlIGZlYXR1cmVzIGFyZSBub3QgdXNlZC5cXG52YXIgc2F3UmVhZE9ubHlTcGFucyA9IGZhbHNlO1xcbnZhciBzYXdDb2xsYXBzZWRTcGFucyA9IGZhbHNlO1xcbmZ1bmN0aW9uIHNlZVJlYWRPbmx5U3BhbnMoKSB7XFxuICBzYXdSZWFkT25seVNwYW5zID0gdHJ1ZVxcbn1cXG5cXG5mdW5jdGlvbiBzZWVDb2xsYXBzZWRTcGFucygpIHtcXG4gIHNhd0NvbGxhcHNlZFNwYW5zID0gdHJ1ZVxcbn1cXG5cXG4vLyBURVhUTUFSS0VSIFNQQU5TXFxuXFxuZnVuY3Rpb24gTWFya2VkU3BhbihtYXJrZXIsIGZyb20sIHRvKSB7XFxuICB0aGlzLm1hcmtlciA9IG1hcmtlclxcbiAgdGhpcy5mcm9tID0gZnJvbTsgdGhpcy50byA9IHRvXFxufVxcblxcbi8vIFNlYXJjaCBhbiBhcnJheSBvZiBzcGFucyBmb3IgYSBzcGFuIG1hdGNoaW5nIHRoZSBnaXZlbiBtYXJrZXIuXFxuZnVuY3Rpb24gZ2V0TWFya2VkU3BhbkZvcihzcGFucywgbWFya2VyKSB7XFxuICBpZiAoc3BhbnMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBzcGFucy5sZW5ndGg7ICsraSkge1xcbiAgICB2YXIgc3BhbiA9IHNwYW5zW2ldXFxuICAgIGlmIChzcGFuLm1hcmtlciA9PSBtYXJrZXIpIHsgcmV0dXJuIHNwYW4gfVxcbiAgfSB9XFxufVxcbi8vIFJlbW92ZSBhIHNwYW4gZnJvbSBhbiBhcnJheSwgcmV0dXJuaW5nIHVuZGVmaW5lZCBpZiBubyBzcGFucyBhcmVcXG4vLyBsZWZ0ICh3ZSBkb24ndCBzdG9yZSBhcnJheXMgZm9yIGxpbmVzIHdpdGhvdXQgc3BhbnMpLlxcbmZ1bmN0aW9uIHJlbW92ZU1hcmtlZFNwYW4oc3BhbnMsIHNwYW4pIHtcXG4gIHZhciByXFxuICBmb3IgKHZhciBpID0gMDsgaSA8IHNwYW5zLmxlbmd0aDsgKytpKVxcbiAgICB7IGlmIChzcGFuc1tpXSAhPSBzcGFuKSB7IChyIHx8IChyID0gW10pKS5wdXNoKHNwYW5zW2ldKSB9IH1cXG4gIHJldHVybiByXFxufVxcbi8vIEFkZCBhIHNwYW4gdG8gYSBsaW5lLlxcbmZ1bmN0aW9uIGFkZE1hcmtlZFNwYW4obGluZSwgc3Bhbikge1xcbiAgbGluZS5tYXJrZWRTcGFucyA9IGxpbmUubWFya2VkU3BhbnMgPyBsaW5lLm1hcmtlZFNwYW5zLmNvbmNhdChbc3Bhbl0pIDogW3NwYW5dXFxuICBzcGFuLm1hcmtlci5hdHRhY2hMaW5lKGxpbmUpXFxufVxcblxcbi8vIFVzZWQgZm9yIHRoZSBhbGdvcml0aG0gdGhhdCBhZGp1c3RzIG1hcmtlcnMgZm9yIGEgY2hhbmdlIGluIHRoZVxcbi8vIGRvY3VtZW50LiBUaGVzZSBmdW5jdGlvbnMgY3V0IGFuIGFycmF5IG9mIHNwYW5zIGF0IGEgZ2l2ZW5cXG4vLyBjaGFyYWN0ZXIgcG9zaXRpb24sIHJldHVybmluZyBhbiBhcnJheSBvZiByZW1haW5pbmcgY2h1bmtzIChvclxcbi8vIHVuZGVmaW5lZCBpZiBub3RoaW5nIHJlbWFpbnMpLlxcbmZ1bmN0aW9uIG1hcmtlZFNwYW5zQmVmb3JlKG9sZCwgc3RhcnRDaCwgaXNJbnNlcnQpIHtcXG4gIHZhciBud1xcbiAgaWYgKG9sZCkgeyBmb3IgKHZhciBpID0gMDsgaSA8IG9sZC5sZW5ndGg7ICsraSkge1xcbiAgICB2YXIgc3BhbiA9IG9sZFtpXSwgbWFya2VyID0gc3Bhbi5tYXJrZXJcXG4gICAgdmFyIHN0YXJ0c0JlZm9yZSA9IHNwYW4uZnJvbSA9PSBudWxsIHx8IChtYXJrZXIuaW5jbHVzaXZlTGVmdCA/IHNwYW4uZnJvbSA8PSBzdGFydENoIDogc3Bhbi5mcm9tIDwgc3RhcnRDaClcXG4gICAgaWYgKHN0YXJ0c0JlZm9yZSB8fCBzcGFuLmZyb20gPT0gc3RhcnRDaCAmJiBtYXJrZXIudHlwZSA9PSBcXFwiYm9va21hcmtcXFwiICYmICghaXNJbnNlcnQgfHwgIXNwYW4ubWFya2VyLmluc2VydExlZnQpKSB7XFxuICAgICAgdmFyIGVuZHNBZnRlciA9IHNwYW4udG8gPT0gbnVsbCB8fCAobWFya2VyLmluY2x1c2l2ZVJpZ2h0ID8gc3Bhbi50byA+PSBzdGFydENoIDogc3Bhbi50byA+IHN0YXJ0Q2gpXFxuICAgICAgOyhudyB8fCAobncgPSBbXSkpLnB1c2gobmV3IE1hcmtlZFNwYW4obWFya2VyLCBzcGFuLmZyb20sIGVuZHNBZnRlciA/IG51bGwgOiBzcGFuLnRvKSlcXG4gICAgfVxcbiAgfSB9XFxuICByZXR1cm4gbndcXG59XFxuZnVuY3Rpb24gbWFya2VkU3BhbnNBZnRlcihvbGQsIGVuZENoLCBpc0luc2VydCkge1xcbiAgdmFyIG53XFxuICBpZiAob2xkKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgb2xkLmxlbmd0aDsgKytpKSB7XFxuICAgIHZhciBzcGFuID0gb2xkW2ldLCBtYXJrZXIgPSBzcGFuLm1hcmtlclxcbiAgICB2YXIgZW5kc0FmdGVyID0gc3Bhbi50byA9PSBudWxsIHx8IChtYXJrZXIuaW5jbHVzaXZlUmlnaHQgPyBzcGFuLnRvID49IGVuZENoIDogc3Bhbi50byA+IGVuZENoKVxcbiAgICBpZiAoZW5kc0FmdGVyIHx8IHNwYW4uZnJvbSA9PSBlbmRDaCAmJiBtYXJrZXIudHlwZSA9PSBcXFwiYm9va21hcmtcXFwiICYmICghaXNJbnNlcnQgfHwgc3Bhbi5tYXJrZXIuaW5zZXJ0TGVmdCkpIHtcXG4gICAgICB2YXIgc3RhcnRzQmVmb3JlID0gc3Bhbi5mcm9tID09IG51bGwgfHwgKG1hcmtlci5pbmNsdXNpdmVMZWZ0ID8gc3Bhbi5mcm9tIDw9IGVuZENoIDogc3Bhbi5mcm9tIDwgZW5kQ2gpXFxuICAgICAgOyhudyB8fCAobncgPSBbXSkpLnB1c2gobmV3IE1hcmtlZFNwYW4obWFya2VyLCBzdGFydHNCZWZvcmUgPyBudWxsIDogc3Bhbi5mcm9tIC0gZW5kQ2gsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcGFuLnRvID09IG51bGwgPyBudWxsIDogc3Bhbi50byAtIGVuZENoKSlcXG4gICAgfVxcbiAgfSB9XFxuICByZXR1cm4gbndcXG59XFxuXFxuLy8gR2l2ZW4gYSBjaGFuZ2Ugb2JqZWN0LCBjb21wdXRlIHRoZSBuZXcgc2V0IG9mIG1hcmtlciBzcGFucyB0aGF0XFxuLy8gY292ZXIgdGhlIGxpbmUgaW4gd2hpY2ggdGhlIGNoYW5nZSB0b29rIHBsYWNlLiBSZW1vdmVzIHNwYW5zXFxuLy8gZW50aXJlbHkgd2l0aGluIHRoZSBjaGFuZ2UsIHJlY29ubmVjdHMgc3BhbnMgYmVsb25naW5nIHRvIHRoZVxcbi8vIHNhbWUgbWFya2VyIHRoYXQgYXBwZWFyIG9uIGJvdGggc2lkZXMgb2YgdGhlIGNoYW5nZSwgYW5kIGN1dHMgb2ZmXFxuLy8gc3BhbnMgcGFydGlhbGx5IHdpdGhpbiB0aGUgY2hhbmdlLiBSZXR1cm5zIGFuIGFycmF5IG9mIHNwYW5cXG4vLyBhcnJheXMgd2l0aCBvbmUgZWxlbWVudCBmb3IgZWFjaCBsaW5lIGluIChhZnRlcikgdGhlIGNoYW5nZS5cXG5mdW5jdGlvbiBzdHJldGNoU3BhbnNPdmVyQ2hhbmdlKGRvYywgY2hhbmdlKSB7XFxuICBpZiAoY2hhbmdlLmZ1bGwpIHsgcmV0dXJuIG51bGwgfVxcbiAgdmFyIG9sZEZpcnN0ID0gaXNMaW5lKGRvYywgY2hhbmdlLmZyb20ubGluZSkgJiYgZ2V0TGluZShkb2MsIGNoYW5nZS5mcm9tLmxpbmUpLm1hcmtlZFNwYW5zXFxuICB2YXIgb2xkTGFzdCA9IGlzTGluZShkb2MsIGNoYW5nZS50by5saW5lKSAmJiBnZXRMaW5lKGRvYywgY2hhbmdlLnRvLmxpbmUpLm1hcmtlZFNwYW5zXFxuICBpZiAoIW9sZEZpcnN0ICYmICFvbGRMYXN0KSB7IHJldHVybiBudWxsIH1cXG5cXG4gIHZhciBzdGFydENoID0gY2hhbmdlLmZyb20uY2gsIGVuZENoID0gY2hhbmdlLnRvLmNoLCBpc0luc2VydCA9IGNtcChjaGFuZ2UuZnJvbSwgY2hhbmdlLnRvKSA9PSAwXFxuICAvLyBHZXQgdGhlIHNwYW5zIHRoYXQgJ3N0aWNrIG91dCcgb24gYm90aCBzaWRlc1xcbiAgdmFyIGZpcnN0ID0gbWFya2VkU3BhbnNCZWZvcmUob2xkRmlyc3QsIHN0YXJ0Q2gsIGlzSW5zZXJ0KVxcbiAgdmFyIGxhc3QgPSBtYXJrZWRTcGFuc0FmdGVyKG9sZExhc3QsIGVuZENoLCBpc0luc2VydClcXG5cXG4gIC8vIE5leHQsIG1lcmdlIHRob3NlIHR3byBlbmRzXFxuICB2YXIgc2FtZUxpbmUgPSBjaGFuZ2UudGV4dC5sZW5ndGggPT0gMSwgb2Zmc2V0ID0gbHN0KGNoYW5nZS50ZXh0KS5sZW5ndGggKyAoc2FtZUxpbmUgPyBzdGFydENoIDogMClcXG4gIGlmIChmaXJzdCkge1xcbiAgICAvLyBGaXggdXAgLnRvIHByb3BlcnRpZXMgb2YgZmlyc3RcXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmaXJzdC5sZW5ndGg7ICsraSkge1xcbiAgICAgIHZhciBzcGFuID0gZmlyc3RbaV1cXG4gICAgICBpZiAoc3Bhbi50byA9PSBudWxsKSB7XFxuICAgICAgICB2YXIgZm91bmQgPSBnZXRNYXJrZWRTcGFuRm9yKGxhc3QsIHNwYW4ubWFya2VyKVxcbiAgICAgICAgaWYgKCFmb3VuZCkgeyBzcGFuLnRvID0gc3RhcnRDaCB9XFxuICAgICAgICBlbHNlIGlmIChzYW1lTGluZSkgeyBzcGFuLnRvID0gZm91bmQudG8gPT0gbnVsbCA/IG51bGwgOiBmb3VuZC50byArIG9mZnNldCB9XFxuICAgICAgfVxcbiAgICB9XFxuICB9XFxuICBpZiAobGFzdCkge1xcbiAgICAvLyBGaXggdXAgLmZyb20gaW4gbGFzdCAob3IgbW92ZSB0aGVtIGludG8gZmlyc3QgaW4gY2FzZSBvZiBzYW1lTGluZSlcXG4gICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgbGFzdC5sZW5ndGg7ICsraSQxKSB7XFxuICAgICAgdmFyIHNwYW4kMSA9IGxhc3RbaSQxXVxcbiAgICAgIGlmIChzcGFuJDEudG8gIT0gbnVsbCkgeyBzcGFuJDEudG8gKz0gb2Zmc2V0IH1cXG4gICAgICBpZiAoc3BhbiQxLmZyb20gPT0gbnVsbCkge1xcbiAgICAgICAgdmFyIGZvdW5kJDEgPSBnZXRNYXJrZWRTcGFuRm9yKGZpcnN0LCBzcGFuJDEubWFya2VyKVxcbiAgICAgICAgaWYgKCFmb3VuZCQxKSB7XFxuICAgICAgICAgIHNwYW4kMS5mcm9tID0gb2Zmc2V0XFxuICAgICAgICAgIGlmIChzYW1lTGluZSkgeyAoZmlyc3QgfHwgKGZpcnN0ID0gW10pKS5wdXNoKHNwYW4kMSkgfVxcbiAgICAgICAgfVxcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBzcGFuJDEuZnJvbSArPSBvZmZzZXRcXG4gICAgICAgIGlmIChzYW1lTGluZSkgeyAoZmlyc3QgfHwgKGZpcnN0ID0gW10pKS5wdXNoKHNwYW4kMSkgfVxcbiAgICAgIH1cXG4gICAgfVxcbiAgfVxcbiAgLy8gTWFrZSBzdXJlIHdlIGRpZG4ndCBjcmVhdGUgYW55IHplcm8tbGVuZ3RoIHNwYW5zXFxuICBpZiAoZmlyc3QpIHsgZmlyc3QgPSBjbGVhckVtcHR5U3BhbnMoZmlyc3QpIH1cXG4gIGlmIChsYXN0ICYmIGxhc3QgIT0gZmlyc3QpIHsgbGFzdCA9IGNsZWFyRW1wdHlTcGFucyhsYXN0KSB9XFxuXFxuICB2YXIgbmV3TWFya2VycyA9IFtmaXJzdF1cXG4gIGlmICghc2FtZUxpbmUpIHtcXG4gICAgLy8gRmlsbCBnYXAgd2l0aCB3aG9sZS1saW5lLXNwYW5zXFxuICAgIHZhciBnYXAgPSBjaGFuZ2UudGV4dC5sZW5ndGggLSAyLCBnYXBNYXJrZXJzXFxuICAgIGlmIChnYXAgPiAwICYmIGZpcnN0KVxcbiAgICAgIHsgZm9yICh2YXIgaSQyID0gMDsgaSQyIDwgZmlyc3QubGVuZ3RoOyArK2kkMilcXG4gICAgICAgIHsgaWYgKGZpcnN0W2kkMl0udG8gPT0gbnVsbClcXG4gICAgICAgICAgeyAoZ2FwTWFya2VycyB8fCAoZ2FwTWFya2VycyA9IFtdKSkucHVzaChuZXcgTWFya2VkU3BhbihmaXJzdFtpJDJdLm1hcmtlciwgbnVsbCwgbnVsbCkpIH0gfSB9XFxuICAgIGZvciAodmFyIGkkMyA9IDA7IGkkMyA8IGdhcDsgKytpJDMpXFxuICAgICAgeyBuZXdNYXJrZXJzLnB1c2goZ2FwTWFya2VycykgfVxcbiAgICBuZXdNYXJrZXJzLnB1c2gobGFzdClcXG4gIH1cXG4gIHJldHVybiBuZXdNYXJrZXJzXFxufVxcblxcbi8vIFJlbW92ZSBzcGFucyB0aGF0IGFyZSBlbXB0eSBhbmQgZG9uJ3QgaGF2ZSBhIGNsZWFyV2hlbkVtcHR5XFxuLy8gb3B0aW9uIG9mIGZhbHNlLlxcbmZ1bmN0aW9uIGNsZWFyRW1wdHlTcGFucyhzcGFucykge1xcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzcGFucy5sZW5ndGg7ICsraSkge1xcbiAgICB2YXIgc3BhbiA9IHNwYW5zW2ldXFxuICAgIGlmIChzcGFuLmZyb20gIT0gbnVsbCAmJiBzcGFuLmZyb20gPT0gc3Bhbi50byAmJiBzcGFuLm1hcmtlci5jbGVhcldoZW5FbXB0eSAhPT0gZmFsc2UpXFxuICAgICAgeyBzcGFucy5zcGxpY2UoaS0tLCAxKSB9XFxuICB9XFxuICBpZiAoIXNwYW5zLmxlbmd0aCkgeyByZXR1cm4gbnVsbCB9XFxuICByZXR1cm4gc3BhbnNcXG59XFxuXFxuLy8gVXNlZCB0byAnY2xpcCcgb3V0IHJlYWRPbmx5IHJhbmdlcyB3aGVuIG1ha2luZyBhIGNoYW5nZS5cXG5mdW5jdGlvbiByZW1vdmVSZWFkT25seVJhbmdlcyhkb2MsIGZyb20sIHRvKSB7XFxuICB2YXIgbWFya2VycyA9IG51bGxcXG4gIGRvYy5pdGVyKGZyb20ubGluZSwgdG8ubGluZSArIDEsIGZ1bmN0aW9uIChsaW5lKSB7XFxuICAgIGlmIChsaW5lLm1hcmtlZFNwYW5zKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgbGluZS5tYXJrZWRTcGFucy5sZW5ndGg7ICsraSkge1xcbiAgICAgIHZhciBtYXJrID0gbGluZS5tYXJrZWRTcGFuc1tpXS5tYXJrZXJcXG4gICAgICBpZiAobWFyay5yZWFkT25seSAmJiAoIW1hcmtlcnMgfHwgaW5kZXhPZihtYXJrZXJzLCBtYXJrKSA9PSAtMSkpXFxuICAgICAgICB7IChtYXJrZXJzIHx8IChtYXJrZXJzID0gW10pKS5wdXNoKG1hcmspIH1cXG4gICAgfSB9XFxuICB9KVxcbiAgaWYgKCFtYXJrZXJzKSB7IHJldHVybiBudWxsIH1cXG4gIHZhciBwYXJ0cyA9IFt7ZnJvbTogZnJvbSwgdG86IHRvfV1cXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbWFya2Vycy5sZW5ndGg7ICsraSkge1xcbiAgICB2YXIgbWsgPSBtYXJrZXJzW2ldLCBtID0gbWsuZmluZCgwKVxcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IHBhcnRzLmxlbmd0aDsgKytqKSB7XFxuICAgICAgdmFyIHAgPSBwYXJ0c1tqXVxcbiAgICAgIGlmIChjbXAocC50bywgbS5mcm9tKSA8IDAgfHwgY21wKHAuZnJvbSwgbS50bykgPiAwKSB7IGNvbnRpbnVlIH1cXG4gICAgICB2YXIgbmV3UGFydHMgPSBbaiwgMV0sIGRmcm9tID0gY21wKHAuZnJvbSwgbS5mcm9tKSwgZHRvID0gY21wKHAudG8sIG0udG8pXFxuICAgICAgaWYgKGRmcm9tIDwgMCB8fCAhbWsuaW5jbHVzaXZlTGVmdCAmJiAhZGZyb20pXFxuICAgICAgICB7IG5ld1BhcnRzLnB1c2goe2Zyb206IHAuZnJvbSwgdG86IG0uZnJvbX0pIH1cXG4gICAgICBpZiAoZHRvID4gMCB8fCAhbWsuaW5jbHVzaXZlUmlnaHQgJiYgIWR0bylcXG4gICAgICAgIHsgbmV3UGFydHMucHVzaCh7ZnJvbTogbS50bywgdG86IHAudG99KSB9XFxuICAgICAgcGFydHMuc3BsaWNlLmFwcGx5KHBhcnRzLCBuZXdQYXJ0cylcXG4gICAgICBqICs9IG5ld1BhcnRzLmxlbmd0aCAtIDFcXG4gICAgfVxcbiAgfVxcbiAgcmV0dXJuIHBhcnRzXFxufVxcblxcbi8vIENvbm5lY3Qgb3IgZGlzY29ubmVjdCBzcGFucyBmcm9tIGEgbGluZS5cXG5mdW5jdGlvbiBkZXRhY2hNYXJrZWRTcGFucyhsaW5lKSB7XFxuICB2YXIgc3BhbnMgPSBsaW5lLm1hcmtlZFNwYW5zXFxuICBpZiAoIXNwYW5zKSB7IHJldHVybiB9XFxuICBmb3IgKHZhciBpID0gMDsgaSA8IHNwYW5zLmxlbmd0aDsgKytpKVxcbiAgICB7IHNwYW5zW2ldLm1hcmtlci5kZXRhY2hMaW5lKGxpbmUpIH1cXG4gIGxpbmUubWFya2VkU3BhbnMgPSBudWxsXFxufVxcbmZ1bmN0aW9uIGF0dGFjaE1hcmtlZFNwYW5zKGxpbmUsIHNwYW5zKSB7XFxuICBpZiAoIXNwYW5zKSB7IHJldHVybiB9XFxuICBmb3IgKHZhciBpID0gMDsgaSA8IHNwYW5zLmxlbmd0aDsgKytpKVxcbiAgICB7IHNwYW5zW2ldLm1hcmtlci5hdHRhY2hMaW5lKGxpbmUpIH1cXG4gIGxpbmUubWFya2VkU3BhbnMgPSBzcGFuc1xcbn1cXG5cXG4vLyBIZWxwZXJzIHVzZWQgd2hlbiBjb21wdXRpbmcgd2hpY2ggb3ZlcmxhcHBpbmcgY29sbGFwc2VkIHNwYW5cXG4vLyBjb3VudHMgYXMgdGhlIGxhcmdlciBvbmUuXFxuZnVuY3Rpb24gZXh0cmFMZWZ0KG1hcmtlcikgeyByZXR1cm4gbWFya2VyLmluY2x1c2l2ZUxlZnQgPyAtMSA6IDAgfVxcbmZ1bmN0aW9uIGV4dHJhUmlnaHQobWFya2VyKSB7IHJldHVybiBtYXJrZXIuaW5jbHVzaXZlUmlnaHQgPyAxIDogMCB9XFxuXFxuLy8gUmV0dXJucyBhIG51bWJlciBpbmRpY2F0aW5nIHdoaWNoIG9mIHR3byBvdmVybGFwcGluZyBjb2xsYXBzZWRcXG4vLyBzcGFucyBpcyBsYXJnZXIgKGFuZCB0aHVzIGluY2x1ZGVzIHRoZSBvdGhlcikuIEZhbGxzIGJhY2sgdG9cXG4vLyBjb21wYXJpbmcgaWRzIHdoZW4gdGhlIHNwYW5zIGNvdmVyIGV4YWN0bHkgdGhlIHNhbWUgcmFuZ2UuXFxuZnVuY3Rpb24gY29tcGFyZUNvbGxhcHNlZE1hcmtlcnMoYSwgYikge1xcbiAgdmFyIGxlbkRpZmYgPSBhLmxpbmVzLmxlbmd0aCAtIGIubGluZXMubGVuZ3RoXFxuICBpZiAobGVuRGlmZiAhPSAwKSB7IHJldHVybiBsZW5EaWZmIH1cXG4gIHZhciBhUG9zID0gYS5maW5kKCksIGJQb3MgPSBiLmZpbmQoKVxcbiAgdmFyIGZyb21DbXAgPSBjbXAoYVBvcy5mcm9tLCBiUG9zLmZyb20pIHx8IGV4dHJhTGVmdChhKSAtIGV4dHJhTGVmdChiKVxcbiAgaWYgKGZyb21DbXApIHsgcmV0dXJuIC1mcm9tQ21wIH1cXG4gIHZhciB0b0NtcCA9IGNtcChhUG9zLnRvLCBiUG9zLnRvKSB8fCBleHRyYVJpZ2h0KGEpIC0gZXh0cmFSaWdodChiKVxcbiAgaWYgKHRvQ21wKSB7IHJldHVybiB0b0NtcCB9XFxuICByZXR1cm4gYi5pZCAtIGEuaWRcXG59XFxuXFxuLy8gRmluZCBvdXQgd2hldGhlciBhIGxpbmUgZW5kcyBvciBzdGFydHMgaW4gYSBjb2xsYXBzZWQgc3Bhbi4gSWZcXG4vLyBzbywgcmV0dXJuIHRoZSBtYXJrZXIgZm9yIHRoYXQgc3Bhbi5cXG5mdW5jdGlvbiBjb2xsYXBzZWRTcGFuQXRTaWRlKGxpbmUsIHN0YXJ0KSB7XFxuICB2YXIgc3BzID0gc2F3Q29sbGFwc2VkU3BhbnMgJiYgbGluZS5tYXJrZWRTcGFucywgZm91bmRcXG4gIGlmIChzcHMpIHsgZm9yICh2YXIgc3AgPSB2b2lkIDAsIGkgPSAwOyBpIDwgc3BzLmxlbmd0aDsgKytpKSB7XFxuICAgIHNwID0gc3BzW2ldXFxuICAgIGlmIChzcC5tYXJrZXIuY29sbGFwc2VkICYmIChzdGFydCA/IHNwLmZyb20gOiBzcC50bykgPT0gbnVsbCAmJlxcbiAgICAgICAgKCFmb3VuZCB8fCBjb21wYXJlQ29sbGFwc2VkTWFya2Vycyhmb3VuZCwgc3AubWFya2VyKSA8IDApKVxcbiAgICAgIHsgZm91bmQgPSBzcC5tYXJrZXIgfVxcbiAgfSB9XFxuICByZXR1cm4gZm91bmRcXG59XFxuZnVuY3Rpb24gY29sbGFwc2VkU3BhbkF0U3RhcnQobGluZSkgeyByZXR1cm4gY29sbGFwc2VkU3BhbkF0U2lkZShsaW5lLCB0cnVlKSB9XFxuZnVuY3Rpb24gY29sbGFwc2VkU3BhbkF0RW5kKGxpbmUpIHsgcmV0dXJuIGNvbGxhcHNlZFNwYW5BdFNpZGUobGluZSwgZmFsc2UpIH1cXG5cXG4vLyBUZXN0IHdoZXRoZXIgdGhlcmUgZXhpc3RzIGEgY29sbGFwc2VkIHNwYW4gdGhhdCBwYXJ0aWFsbHlcXG4vLyBvdmVybGFwcyAoY292ZXJzIHRoZSBzdGFydCBvciBlbmQsIGJ1dCBub3QgYm90aCkgb2YgYSBuZXcgc3Bhbi5cXG4vLyBTdWNoIG92ZXJsYXAgaXMgbm90IGFsbG93ZWQuXFxuZnVuY3Rpb24gY29uZmxpY3RpbmdDb2xsYXBzZWRSYW5nZShkb2MsIGxpbmVObywgZnJvbSwgdG8sIG1hcmtlcikge1xcbiAgdmFyIGxpbmUgPSBnZXRMaW5lKGRvYywgbGluZU5vKVxcbiAgdmFyIHNwcyA9IHNhd0NvbGxhcHNlZFNwYW5zICYmIGxpbmUubWFya2VkU3BhbnNcXG4gIGlmIChzcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBzcHMubGVuZ3RoOyArK2kpIHtcXG4gICAgdmFyIHNwID0gc3BzW2ldXFxuICAgIGlmICghc3AubWFya2VyLmNvbGxhcHNlZCkgeyBjb250aW51ZSB9XFxuICAgIHZhciBmb3VuZCA9IHNwLm1hcmtlci5maW5kKDApXFxuICAgIHZhciBmcm9tQ21wID0gY21wKGZvdW5kLmZyb20sIGZyb20pIHx8IGV4dHJhTGVmdChzcC5tYXJrZXIpIC0gZXh0cmFMZWZ0KG1hcmtlcilcXG4gICAgdmFyIHRvQ21wID0gY21wKGZvdW5kLnRvLCB0bykgfHwgZXh0cmFSaWdodChzcC5tYXJrZXIpIC0gZXh0cmFSaWdodChtYXJrZXIpXFxuICAgIGlmIChmcm9tQ21wID49IDAgJiYgdG9DbXAgPD0gMCB8fCBmcm9tQ21wIDw9IDAgJiYgdG9DbXAgPj0gMCkgeyBjb250aW51ZSB9XFxuICAgIGlmIChmcm9tQ21wIDw9IDAgJiYgKHNwLm1hcmtlci5pbmNsdXNpdmVSaWdodCAmJiBtYXJrZXIuaW5jbHVzaXZlTGVmdCA/IGNtcChmb3VuZC50bywgZnJvbSkgPj0gMCA6IGNtcChmb3VuZC50bywgZnJvbSkgPiAwKSB8fFxcbiAgICAgICAgZnJvbUNtcCA+PSAwICYmIChzcC5tYXJrZXIuaW5jbHVzaXZlUmlnaHQgJiYgbWFya2VyLmluY2x1c2l2ZUxlZnQgPyBjbXAoZm91bmQuZnJvbSwgdG8pIDw9IDAgOiBjbXAoZm91bmQuZnJvbSwgdG8pIDwgMCkpXFxuICAgICAgeyByZXR1cm4gdHJ1ZSB9XFxuICB9IH1cXG59XFxuXFxuLy8gQSB2aXN1YWwgbGluZSBpcyBhIGxpbmUgYXMgZHJhd24gb24gdGhlIHNjcmVlbi4gRm9sZGluZywgZm9yXFxuLy8gZXhhbXBsZSwgY2FuIGNhdXNlIG11bHRpcGxlIGxvZ2ljYWwgbGluZXMgdG8gYXBwZWFyIG9uIHRoZSBzYW1lXFxuLy8gdmlzdWFsIGxpbmUuIFRoaXMgZmluZHMgdGhlIHN0YXJ0IG9mIHRoZSB2aXN1YWwgbGluZSB0aGF0IHRoZVxcbi8vIGdpdmVuIGxpbmUgaXMgcGFydCBvZiAodXN1YWxseSB0aGF0IGlzIHRoZSBsaW5lIGl0c2VsZikuXFxuZnVuY3Rpb24gdmlzdWFsTGluZShsaW5lKSB7XFxuICB2YXIgbWVyZ2VkXFxuICB3aGlsZSAobWVyZ2VkID0gY29sbGFwc2VkU3BhbkF0U3RhcnQobGluZSkpXFxuICAgIHsgbGluZSA9IG1lcmdlZC5maW5kKC0xLCB0cnVlKS5saW5lIH1cXG4gIHJldHVybiBsaW5lXFxufVxcblxcbi8vIFJldHVybnMgYW4gYXJyYXkgb2YgbG9naWNhbCBsaW5lcyB0aGF0IGNvbnRpbnVlIHRoZSB2aXN1YWwgbGluZVxcbi8vIHN0YXJ0ZWQgYnkgdGhlIGFyZ3VtZW50LCBvciB1bmRlZmluZWQgaWYgdGhlcmUgYXJlIG5vIHN1Y2ggbGluZXMuXFxuZnVuY3Rpb24gdmlzdWFsTGluZUNvbnRpbnVlZChsaW5lKSB7XFxuICB2YXIgbWVyZ2VkLCBsaW5lc1xcbiAgd2hpbGUgKG1lcmdlZCA9IGNvbGxhcHNlZFNwYW5BdEVuZChsaW5lKSkge1xcbiAgICBsaW5lID0gbWVyZ2VkLmZpbmQoMSwgdHJ1ZSkubGluZVxcbiAgICA7KGxpbmVzIHx8IChsaW5lcyA9IFtdKSkucHVzaChsaW5lKVxcbiAgfVxcbiAgcmV0dXJuIGxpbmVzXFxufVxcblxcbi8vIEdldCB0aGUgbGluZSBudW1iZXIgb2YgdGhlIHN0YXJ0IG9mIHRoZSB2aXN1YWwgbGluZSB0aGF0IHRoZVxcbi8vIGdpdmVuIGxpbmUgbnVtYmVyIGlzIHBhcnQgb2YuXFxuZnVuY3Rpb24gdmlzdWFsTGluZU5vKGRvYywgbGluZU4pIHtcXG4gIHZhciBsaW5lID0gZ2V0TGluZShkb2MsIGxpbmVOKSwgdmlzID0gdmlzdWFsTGluZShsaW5lKVxcbiAgaWYgKGxpbmUgPT0gdmlzKSB7IHJldHVybiBsaW5lTiB9XFxuICByZXR1cm4gbGluZU5vKHZpcylcXG59XFxuXFxuLy8gR2V0IHRoZSBsaW5lIG51bWJlciBvZiB0aGUgc3RhcnQgb2YgdGhlIG5leHQgdmlzdWFsIGxpbmUgYWZ0ZXJcXG4vLyB0aGUgZ2l2ZW4gbGluZS5cXG5mdW5jdGlvbiB2aXN1YWxMaW5lRW5kTm8oZG9jLCBsaW5lTikge1xcbiAgaWYgKGxpbmVOID4gZG9jLmxhc3RMaW5lKCkpIHsgcmV0dXJuIGxpbmVOIH1cXG4gIHZhciBsaW5lID0gZ2V0TGluZShkb2MsIGxpbmVOKSwgbWVyZ2VkXFxuICBpZiAoIWxpbmVJc0hpZGRlbihkb2MsIGxpbmUpKSB7IHJldHVybiBsaW5lTiB9XFxuICB3aGlsZSAobWVyZ2VkID0gY29sbGFwc2VkU3BhbkF0RW5kKGxpbmUpKVxcbiAgICB7IGxpbmUgPSBtZXJnZWQuZmluZCgxLCB0cnVlKS5saW5lIH1cXG4gIHJldHVybiBsaW5lTm8obGluZSkgKyAxXFxufVxcblxcbi8vIENvbXB1dGUgd2hldGhlciBhIGxpbmUgaXMgaGlkZGVuLiBMaW5lcyBjb3VudCBhcyBoaWRkZW4gd2hlbiB0aGV5XFxuLy8gYXJlIHBhcnQgb2YgYSB2aXN1YWwgbGluZSB0aGF0IHN0YXJ0cyB3aXRoIGFub3RoZXIgbGluZSwgb3Igd2hlblxcbi8vIHRoZXkgYXJlIGVudGlyZWx5IGNvdmVyZWQgYnkgY29sbGFwc2VkLCBub24td2lkZ2V0IHNwYW4uXFxuZnVuY3Rpb24gbGluZUlzSGlkZGVuKGRvYywgbGluZSkge1xcbiAgdmFyIHNwcyA9IHNhd0NvbGxhcHNlZFNwYW5zICYmIGxpbmUubWFya2VkU3BhbnNcXG4gIGlmIChzcHMpIHsgZm9yICh2YXIgc3AgPSB2b2lkIDAsIGkgPSAwOyBpIDwgc3BzLmxlbmd0aDsgKytpKSB7XFxuICAgIHNwID0gc3BzW2ldXFxuICAgIGlmICghc3AubWFya2VyLmNvbGxhcHNlZCkgeyBjb250aW51ZSB9XFxuICAgIGlmIChzcC5mcm9tID09IG51bGwpIHsgcmV0dXJuIHRydWUgfVxcbiAgICBpZiAoc3AubWFya2VyLndpZGdldE5vZGUpIHsgY29udGludWUgfVxcbiAgICBpZiAoc3AuZnJvbSA9PSAwICYmIHNwLm1hcmtlci5pbmNsdXNpdmVMZWZ0ICYmIGxpbmVJc0hpZGRlbklubmVyKGRvYywgbGluZSwgc3ApKVxcbiAgICAgIHsgcmV0dXJuIHRydWUgfVxcbiAgfSB9XFxufVxcbmZ1bmN0aW9uIGxpbmVJc0hpZGRlbklubmVyKGRvYywgbGluZSwgc3Bhbikge1xcbiAgaWYgKHNwYW4udG8gPT0gbnVsbCkge1xcbiAgICB2YXIgZW5kID0gc3Bhbi5tYXJrZXIuZmluZCgxLCB0cnVlKVxcbiAgICByZXR1cm4gbGluZUlzSGlkZGVuSW5uZXIoZG9jLCBlbmQubGluZSwgZ2V0TWFya2VkU3BhbkZvcihlbmQubGluZS5tYXJrZWRTcGFucywgc3Bhbi5tYXJrZXIpKVxcbiAgfVxcbiAgaWYgKHNwYW4ubWFya2VyLmluY2x1c2l2ZVJpZ2h0ICYmIHNwYW4udG8gPT0gbGluZS50ZXh0Lmxlbmd0aClcXG4gICAgeyByZXR1cm4gdHJ1ZSB9XFxuICBmb3IgKHZhciBzcCA9IHZvaWQgMCwgaSA9IDA7IGkgPCBsaW5lLm1hcmtlZFNwYW5zLmxlbmd0aDsgKytpKSB7XFxuICAgIHNwID0gbGluZS5tYXJrZWRTcGFuc1tpXVxcbiAgICBpZiAoc3AubWFya2VyLmNvbGxhcHNlZCAmJiAhc3AubWFya2VyLndpZGdldE5vZGUgJiYgc3AuZnJvbSA9PSBzcGFuLnRvICYmXFxuICAgICAgICAoc3AudG8gPT0gbnVsbCB8fCBzcC50byAhPSBzcGFuLmZyb20pICYmXFxuICAgICAgICAoc3AubWFya2VyLmluY2x1c2l2ZUxlZnQgfHwgc3Bhbi5tYXJrZXIuaW5jbHVzaXZlUmlnaHQpICYmXFxuICAgICAgICBsaW5lSXNIaWRkZW5Jbm5lcihkb2MsIGxpbmUsIHNwKSkgeyByZXR1cm4gdHJ1ZSB9XFxuICB9XFxufVxcblxcbi8vIEZpbmQgdGhlIGhlaWdodCBhYm92ZSB0aGUgZ2l2ZW4gbGluZS5cXG5mdW5jdGlvbiBoZWlnaHRBdExpbmUobGluZU9iaikge1xcbiAgbGluZU9iaiA9IHZpc3VhbExpbmUobGluZU9iailcXG5cXG4gIHZhciBoID0gMCwgY2h1bmsgPSBsaW5lT2JqLnBhcmVudFxcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaHVuay5saW5lcy5sZW5ndGg7ICsraSkge1xcbiAgICB2YXIgbGluZSA9IGNodW5rLmxpbmVzW2ldXFxuICAgIGlmIChsaW5lID09IGxpbmVPYmopIHsgYnJlYWsgfVxcbiAgICBlbHNlIHsgaCArPSBsaW5lLmhlaWdodCB9XFxuICB9XFxuICBmb3IgKHZhciBwID0gY2h1bmsucGFyZW50OyBwOyBjaHVuayA9IHAsIHAgPSBjaHVuay5wYXJlbnQpIHtcXG4gICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgcC5jaGlsZHJlbi5sZW5ndGg7ICsraSQxKSB7XFxuICAgICAgdmFyIGN1ciA9IHAuY2hpbGRyZW5baSQxXVxcbiAgICAgIGlmIChjdXIgPT0gY2h1bmspIHsgYnJlYWsgfVxcbiAgICAgIGVsc2UgeyBoICs9IGN1ci5oZWlnaHQgfVxcbiAgICB9XFxuICB9XFxuICByZXR1cm4gaFxcbn1cXG5cXG4vLyBDb21wdXRlIHRoZSBjaGFyYWN0ZXIgbGVuZ3RoIG9mIGEgbGluZSwgdGFraW5nIGludG8gYWNjb3VudFxcbi8vIGNvbGxhcHNlZCByYW5nZXMgKHNlZSBtYXJrVGV4dCkgdGhhdCBtaWdodCBoaWRlIHBhcnRzLCBhbmQgam9pblxcbi8vIG90aGVyIGxpbmVzIG9udG8gaXQuXFxuZnVuY3Rpb24gbGluZUxlbmd0aChsaW5lKSB7XFxuICBpZiAobGluZS5oZWlnaHQgPT0gMCkgeyByZXR1cm4gMCB9XFxuICB2YXIgbGVuID0gbGluZS50ZXh0Lmxlbmd0aCwgbWVyZ2VkLCBjdXIgPSBsaW5lXFxuICB3aGlsZSAobWVyZ2VkID0gY29sbGFwc2VkU3BhbkF0U3RhcnQoY3VyKSkge1xcbiAgICB2YXIgZm91bmQgPSBtZXJnZWQuZmluZCgwLCB0cnVlKVxcbiAgICBjdXIgPSBmb3VuZC5mcm9tLmxpbmVcXG4gICAgbGVuICs9IGZvdW5kLmZyb20uY2ggLSBmb3VuZC50by5jaFxcbiAgfVxcbiAgY3VyID0gbGluZVxcbiAgd2hpbGUgKG1lcmdlZCA9IGNvbGxhcHNlZFNwYW5BdEVuZChjdXIpKSB7XFxuICAgIHZhciBmb3VuZCQxID0gbWVyZ2VkLmZpbmQoMCwgdHJ1ZSlcXG4gICAgbGVuIC09IGN1ci50ZXh0Lmxlbmd0aCAtIGZvdW5kJDEuZnJvbS5jaFxcbiAgICBjdXIgPSBmb3VuZCQxLnRvLmxpbmVcXG4gICAgbGVuICs9IGN1ci50ZXh0Lmxlbmd0aCAtIGZvdW5kJDEudG8uY2hcXG4gIH1cXG4gIHJldHVybiBsZW5cXG59XFxuXFxuLy8gRmluZCB0aGUgbG9uZ2VzdCBsaW5lIGluIHRoZSBkb2N1bWVudC5cXG5mdW5jdGlvbiBmaW5kTWF4TGluZShjbSkge1xcbiAgdmFyIGQgPSBjbS5kaXNwbGF5LCBkb2MgPSBjbS5kb2NcXG4gIGQubWF4TGluZSA9IGdldExpbmUoZG9jLCBkb2MuZmlyc3QpXFxuICBkLm1heExpbmVMZW5ndGggPSBsaW5lTGVuZ3RoKGQubWF4TGluZSlcXG4gIGQubWF4TGluZUNoYW5nZWQgPSB0cnVlXFxuICBkb2MuaXRlcihmdW5jdGlvbiAobGluZSkge1xcbiAgICB2YXIgbGVuID0gbGluZUxlbmd0aChsaW5lKVxcbiAgICBpZiAobGVuID4gZC5tYXhMaW5lTGVuZ3RoKSB7XFxuICAgICAgZC5tYXhMaW5lTGVuZ3RoID0gbGVuXFxuICAgICAgZC5tYXhMaW5lID0gbGluZVxcbiAgICB9XFxuICB9KVxcbn1cXG5cXG4vLyBCSURJIEhFTFBFUlNcXG5cXG5mdW5jdGlvbiBpdGVyYXRlQmlkaVNlY3Rpb25zKG9yZGVyLCBmcm9tLCB0bywgZikge1xcbiAgaWYgKCFvcmRlcikgeyByZXR1cm4gZihmcm9tLCB0bywgXFxcImx0clxcXCIpIH1cXG4gIHZhciBmb3VuZCA9IGZhbHNlXFxuICBmb3IgKHZhciBpID0gMDsgaSA8IG9yZGVyLmxlbmd0aDsgKytpKSB7XFxuICAgIHZhciBwYXJ0ID0gb3JkZXJbaV1cXG4gICAgaWYgKHBhcnQuZnJvbSA8IHRvICYmIHBhcnQudG8gPiBmcm9tIHx8IGZyb20gPT0gdG8gJiYgcGFydC50byA9PSBmcm9tKSB7XFxuICAgICAgZihNYXRoLm1heChwYXJ0LmZyb20sIGZyb20pLCBNYXRoLm1pbihwYXJ0LnRvLCB0byksIHBhcnQubGV2ZWwgPT0gMSA/IFxcXCJydGxcXFwiIDogXFxcImx0clxcXCIpXFxuICAgICAgZm91bmQgPSB0cnVlXFxuICAgIH1cXG4gIH1cXG4gIGlmICghZm91bmQpIHsgZihmcm9tLCB0bywgXFxcImx0clxcXCIpIH1cXG59XFxuXFxuZnVuY3Rpb24gYmlkaUxlZnQocGFydCkgeyByZXR1cm4gcGFydC5sZXZlbCAlIDIgPyBwYXJ0LnRvIDogcGFydC5mcm9tIH1cXG5mdW5jdGlvbiBiaWRpUmlnaHQocGFydCkgeyByZXR1cm4gcGFydC5sZXZlbCAlIDIgPyBwYXJ0LmZyb20gOiBwYXJ0LnRvIH1cXG5cXG5mdW5jdGlvbiBsaW5lTGVmdChsaW5lKSB7IHZhciBvcmRlciA9IGdldE9yZGVyKGxpbmUpOyByZXR1cm4gb3JkZXIgPyBiaWRpTGVmdChvcmRlclswXSkgOiAwIH1cXG5mdW5jdGlvbiBsaW5lUmlnaHQobGluZSkge1xcbiAgdmFyIG9yZGVyID0gZ2V0T3JkZXIobGluZSlcXG4gIGlmICghb3JkZXIpIHsgcmV0dXJuIGxpbmUudGV4dC5sZW5ndGggfVxcbiAgcmV0dXJuIGJpZGlSaWdodChsc3Qob3JkZXIpKVxcbn1cXG5cXG5mdW5jdGlvbiBjb21wYXJlQmlkaUxldmVsKG9yZGVyLCBhLCBiKSB7XFxuICB2YXIgbGluZWRpciA9IG9yZGVyWzBdLmxldmVsXFxuICBpZiAoYSA9PSBsaW5lZGlyKSB7IHJldHVybiB0cnVlIH1cXG4gIGlmIChiID09IGxpbmVkaXIpIHsgcmV0dXJuIGZhbHNlIH1cXG4gIHJldHVybiBhIDwgYlxcbn1cXG5cXG52YXIgYmlkaU90aGVyID0gbnVsbFxcbmZ1bmN0aW9uIGdldEJpZGlQYXJ0QXQob3JkZXIsIHBvcykge1xcbiAgdmFyIGZvdW5kXFxuICBiaWRpT3RoZXIgPSBudWxsXFxuICBmb3IgKHZhciBpID0gMDsgaSA8IG9yZGVyLmxlbmd0aDsgKytpKSB7XFxuICAgIHZhciBjdXIgPSBvcmRlcltpXVxcbiAgICBpZiAoY3VyLmZyb20gPCBwb3MgJiYgY3VyLnRvID4gcG9zKSB7IHJldHVybiBpIH1cXG4gICAgaWYgKChjdXIuZnJvbSA9PSBwb3MgfHwgY3VyLnRvID09IHBvcykpIHtcXG4gICAgICBpZiAoZm91bmQgPT0gbnVsbCkge1xcbiAgICAgICAgZm91bmQgPSBpXFxuICAgICAgfSBlbHNlIGlmIChjb21wYXJlQmlkaUxldmVsKG9yZGVyLCBjdXIubGV2ZWwsIG9yZGVyW2ZvdW5kXS5sZXZlbCkpIHtcXG4gICAgICAgIGlmIChjdXIuZnJvbSAhPSBjdXIudG8pIHsgYmlkaU90aGVyID0gZm91bmQgfVxcbiAgICAgICAgcmV0dXJuIGlcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgaWYgKGN1ci5mcm9tICE9IGN1ci50bykgeyBiaWRpT3RoZXIgPSBpIH1cXG4gICAgICAgIHJldHVybiBmb3VuZFxcbiAgICAgIH1cXG4gICAgfVxcbiAgfVxcbiAgcmV0dXJuIGZvdW5kXFxufVxcblxcbmZ1bmN0aW9uIG1vdmVJbkxpbmUobGluZSwgcG9zLCBkaXIsIGJ5VW5pdCkge1xcbiAgaWYgKCFieVVuaXQpIHsgcmV0dXJuIHBvcyArIGRpciB9XFxuICBkbyB7IHBvcyArPSBkaXIgfVxcbiAgd2hpbGUgKHBvcyA+IDAgJiYgaXNFeHRlbmRpbmdDaGFyKGxpbmUudGV4dC5jaGFyQXQocG9zKSkpXFxuICByZXR1cm4gcG9zXFxufVxcblxcbi8vIFRoaXMgaXMgbmVlZGVkIGluIG9yZGVyIHRvIG1vdmUgJ3Zpc3VhbGx5JyB0aHJvdWdoIGJpLWRpcmVjdGlvbmFsXFxuLy8gdGV4dCAtLSBpLmUuLCBwcmVzc2luZyBsZWZ0IHNob3VsZCBtYWtlIHRoZSBjdXJzb3IgZ28gbGVmdCwgZXZlblxcbi8vIHdoZW4gaW4gUlRMIHRleHQuIFRoZSB0cmlja3kgcGFydCBpcyB0aGUgJ2p1bXBzJywgd2hlcmUgUlRMIGFuZFxcbi8vIExUUiB0ZXh0IHRvdWNoIGVhY2ggb3RoZXIuIFRoaXMgb2Z0ZW4gcmVxdWlyZXMgdGhlIGN1cnNvciBvZmZzZXRcXG4vLyB0byBtb3ZlIG1vcmUgdGhhbiBvbmUgdW5pdCwgaW4gb3JkZXIgdG8gdmlzdWFsbHkgbW92ZSBvbmUgdW5pdC5cXG5mdW5jdGlvbiBtb3ZlVmlzdWFsbHkobGluZSwgc3RhcnQsIGRpciwgYnlVbml0KSB7XFxuICB2YXIgYmlkaSA9IGdldE9yZGVyKGxpbmUpXFxuICBpZiAoIWJpZGkpIHsgcmV0dXJuIG1vdmVMb2dpY2FsbHkobGluZSwgc3RhcnQsIGRpciwgYnlVbml0KSB9XFxuICB2YXIgcG9zID0gZ2V0QmlkaVBhcnRBdChiaWRpLCBzdGFydCksIHBhcnQgPSBiaWRpW3Bvc11cXG4gIHZhciB0YXJnZXQgPSBtb3ZlSW5MaW5lKGxpbmUsIHN0YXJ0LCBwYXJ0LmxldmVsICUgMiA/IC1kaXIgOiBkaXIsIGJ5VW5pdClcXG5cXG4gIGZvciAoOzspIHtcXG4gICAgaWYgKHRhcmdldCA+IHBhcnQuZnJvbSAmJiB0YXJnZXQgPCBwYXJ0LnRvKSB7IHJldHVybiB0YXJnZXQgfVxcbiAgICBpZiAodGFyZ2V0ID09IHBhcnQuZnJvbSB8fCB0YXJnZXQgPT0gcGFydC50bykge1xcbiAgICAgIGlmIChnZXRCaWRpUGFydEF0KGJpZGksIHRhcmdldCkgPT0gcG9zKSB7IHJldHVybiB0YXJnZXQgfVxcbiAgICAgIHBhcnQgPSBiaWRpW3BvcyArPSBkaXJdXFxuICAgICAgcmV0dXJuIChkaXIgPiAwKSA9PSBwYXJ0LmxldmVsICUgMiA/IHBhcnQudG8gOiBwYXJ0LmZyb21cXG4gICAgfSBlbHNlIHtcXG4gICAgICBwYXJ0ID0gYmlkaVtwb3MgKz0gZGlyXVxcbiAgICAgIGlmICghcGFydCkgeyByZXR1cm4gbnVsbCB9XFxuICAgICAgaWYgKChkaXIgPiAwKSA9PSBwYXJ0LmxldmVsICUgMilcXG4gICAgICAgIHsgdGFyZ2V0ID0gbW92ZUluTGluZShsaW5lLCBwYXJ0LnRvLCAtMSwgYnlVbml0KSB9XFxuICAgICAgZWxzZVxcbiAgICAgICAgeyB0YXJnZXQgPSBtb3ZlSW5MaW5lKGxpbmUsIHBhcnQuZnJvbSwgMSwgYnlVbml0KSB9XFxuICAgIH1cXG4gIH1cXG59XFxuXFxuZnVuY3Rpb24gbW92ZUxvZ2ljYWxseShsaW5lLCBzdGFydCwgZGlyLCBieVVuaXQpIHtcXG4gIHZhciB0YXJnZXQgPSBzdGFydCArIGRpclxcbiAgaWYgKGJ5VW5pdCkgeyB3aGlsZSAodGFyZ2V0ID4gMCAmJiBpc0V4dGVuZGluZ0NoYXIobGluZS50ZXh0LmNoYXJBdCh0YXJnZXQpKSkgeyB0YXJnZXQgKz0gZGlyIH0gfVxcbiAgcmV0dXJuIHRhcmdldCA8IDAgfHwgdGFyZ2V0ID4gbGluZS50ZXh0Lmxlbmd0aCA/IG51bGwgOiB0YXJnZXRcXG59XFxuXFxuLy8gQmlkaXJlY3Rpb25hbCBvcmRlcmluZyBhbGdvcml0aG1cXG4vLyBTZWUgaHR0cDovL3VuaWNvZGUub3JnL3JlcG9ydHMvdHI5L3RyOS0xMy5odG1sIGZvciB0aGUgYWxnb3JpdGhtXFxuLy8gdGhhdCB0aGlzIChwYXJ0aWFsbHkpIGltcGxlbWVudHMuXFxuXFxuLy8gT25lLWNoYXIgY29kZXMgdXNlZCBmb3IgY2hhcmFjdGVyIHR5cGVzOlxcbi8vIEwgKEwpOiAgIExlZnQtdG8tUmlnaHRcXG4vLyBSIChSKTogICBSaWdodC10by1MZWZ0XFxuLy8gciAoQUwpOiAgUmlnaHQtdG8tTGVmdCBBcmFiaWNcXG4vLyAxIChFTik6ICBFdXJvcGVhbiBOdW1iZXJcXG4vLyArIChFUyk6ICBFdXJvcGVhbiBOdW1iZXIgU2VwYXJhdG9yXFxuLy8gJSAoRVQpOiAgRXVyb3BlYW4gTnVtYmVyIFRlcm1pbmF0b3JcXG4vLyBuIChBTik6ICBBcmFiaWMgTnVtYmVyXFxuLy8gLCAoQ1MpOiAgQ29tbW9uIE51bWJlciBTZXBhcmF0b3JcXG4vLyBtIChOU00pOiBOb24tU3BhY2luZyBNYXJrXFxuLy8gYiAoQk4pOiAgQm91bmRhcnkgTmV1dHJhbFxcbi8vIHMgKEIpOiAgIFBhcmFncmFwaCBTZXBhcmF0b3JcXG4vLyB0IChTKTogICBTZWdtZW50IFNlcGFyYXRvclxcbi8vIHcgKFdTKTogIFdoaXRlc3BhY2VcXG4vLyBOIChPTik6ICBPdGhlciBOZXV0cmFsc1xcblxcbi8vIFJldHVybnMgbnVsbCBpZiBjaGFyYWN0ZXJzIGFyZSBvcmRlcmVkIGFzIHRoZXkgYXBwZWFyXFxuLy8gKGxlZnQtdG8tcmlnaHQpLCBvciBhbiBhcnJheSBvZiBzZWN0aW9ucyAoe2Zyb20sIHRvLCBsZXZlbH1cXG4vLyBvYmplY3RzKSBpbiB0aGUgb3JkZXIgaW4gd2hpY2ggdGhleSBvY2N1ciB2aXN1YWxseS5cXG52YXIgYmlkaU9yZGVyaW5nID0gKGZ1bmN0aW9uKCkge1xcbiAgLy8gQ2hhcmFjdGVyIHR5cGVzIGZvciBjb2RlcG9pbnRzIDAgdG8gMHhmZlxcbiAgdmFyIGxvd1R5cGVzID0gXFxcImJiYmJiYmJiYnRzdHdzYmJiYmJiYmJiYmJiYmJzc3N0d05OJSUlTk5OTk5OLE4sTjExMTExMTExMTFOTk5OTk5OTExMTExMTExMTExMTExMTExMTExMTExMTExOTk5OTk5MTExMTExMTExMTExMTExMTExMTExMTExMTE5OTk5iYmJiYmJzYmJiYmJiYmJiYmJiYmJiYmJiYmJiYmJiYmIsTiUlJSVOTk5OTE5OTk5OJSUxMU5MTk5OMUxOTk5OTkxMTExMTExMTExMTExMTExMTExMTExMTkxMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExOXFxcIlxcbiAgLy8gQ2hhcmFjdGVyIHR5cGVzIGZvciBjb2RlcG9pbnRzIDB4NjAwIHRvIDB4NmZmXFxuICB2YXIgYXJhYmljVHlwZXMgPSBcXFwicnJycnJycnJycnJyLHJOTm1tbW1tbXJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJybW1tbW1tbW1tbW1tbW1ycnJycnJybm5ubm5ubm5ubiVubnJycm1ycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycm1tbW1tbW1tbW1tbW1tbW1tbW1ObW1tbVxcXCJcXG4gIGZ1bmN0aW9uIGNoYXJUeXBlKGNvZGUpIHtcXG4gICAgaWYgKGNvZGUgPD0gMHhmNykgeyByZXR1cm4gbG93VHlwZXMuY2hhckF0KGNvZGUpIH1cXG4gICAgZWxzZSBpZiAoMHg1OTAgPD0gY29kZSAmJiBjb2RlIDw9IDB4NWY0KSB7IHJldHVybiBcXFwiUlxcXCIgfVxcbiAgICBlbHNlIGlmICgweDYwMCA8PSBjb2RlICYmIGNvZGUgPD0gMHg2ZWQpIHsgcmV0dXJuIGFyYWJpY1R5cGVzLmNoYXJBdChjb2RlIC0gMHg2MDApIH1cXG4gICAgZWxzZSBpZiAoMHg2ZWUgPD0gY29kZSAmJiBjb2RlIDw9IDB4OGFjKSB7IHJldHVybiBcXFwiclxcXCIgfVxcbiAgICBlbHNlIGlmICgweDIwMDAgPD0gY29kZSAmJiBjb2RlIDw9IDB4MjAwYikgeyByZXR1cm4gXFxcIndcXFwiIH1cXG4gICAgZWxzZSBpZiAoY29kZSA9PSAweDIwMGMpIHsgcmV0dXJuIFxcXCJiXFxcIiB9XFxuICAgIGVsc2UgeyByZXR1cm4gXFxcIkxcXFwiIH1cXG4gIH1cXG5cXG4gIHZhciBiaWRpUkUgPSAvW1xcXFx1MDU5MC1cXFxcdTA1ZjRcXFxcdTA2MDAtXFxcXHUwNmZmXFxcXHUwNzAwLVxcXFx1MDhhY10vXFxuICB2YXIgaXNOZXV0cmFsID0gL1tzdHdOXS8sIGlzU3Ryb25nID0gL1tMUnJdLywgY291bnRzQXNMZWZ0ID0gL1tMYjFuXS8sIGNvdW50c0FzTnVtID0gL1sxbl0vXFxuICAvLyBCcm93c2VycyBzZWVtIHRvIGFsd2F5cyB0cmVhdCB0aGUgYm91bmRhcmllcyBvZiBibG9jayBlbGVtZW50cyBhcyBiZWluZyBMLlxcbiAgdmFyIG91dGVyVHlwZSA9IFxcXCJMXFxcIlxcblxcbiAgZnVuY3Rpb24gQmlkaVNwYW4obGV2ZWwsIGZyb20sIHRvKSB7XFxuICAgIHRoaXMubGV2ZWwgPSBsZXZlbFxcbiAgICB0aGlzLmZyb20gPSBmcm9tOyB0aGlzLnRvID0gdG9cXG4gIH1cXG5cXG4gIHJldHVybiBmdW5jdGlvbihzdHIpIHtcXG4gICAgaWYgKCFiaWRpUkUudGVzdChzdHIpKSB7IHJldHVybiBmYWxzZSB9XFxuICAgIHZhciBsZW4gPSBzdHIubGVuZ3RoLCB0eXBlcyA9IFtdXFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpXFxuICAgICAgeyB0eXBlcy5wdXNoKGNoYXJUeXBlKHN0ci5jaGFyQ29kZUF0KGkpKSkgfVxcblxcbiAgICAvLyBXMS4gRXhhbWluZSBlYWNoIG5vbi1zcGFjaW5nIG1hcmsgKE5TTSkgaW4gdGhlIGxldmVsIHJ1biwgYW5kXFxuICAgIC8vIGNoYW5nZSB0aGUgdHlwZSBvZiB0aGUgTlNNIHRvIHRoZSB0eXBlIG9mIHRoZSBwcmV2aW91c1xcbiAgICAvLyBjaGFyYWN0ZXIuIElmIHRoZSBOU00gaXMgYXQgdGhlIHN0YXJ0IG9mIHRoZSBsZXZlbCBydW4sIGl0IHdpbGxcXG4gICAgLy8gZ2V0IHRoZSB0eXBlIG9mIHNvci5cXG4gICAgZm9yICh2YXIgaSQxID0gMCwgcHJldiA9IG91dGVyVHlwZTsgaSQxIDwgbGVuOyArK2kkMSkge1xcbiAgICAgIHZhciB0eXBlID0gdHlwZXNbaSQxXVxcbiAgICAgIGlmICh0eXBlID09IFxcXCJtXFxcIikgeyB0eXBlc1tpJDFdID0gcHJldiB9XFxuICAgICAgZWxzZSB7IHByZXYgPSB0eXBlIH1cXG4gICAgfVxcblxcbiAgICAvLyBXMi4gU2VhcmNoIGJhY2t3YXJkcyBmcm9tIGVhY2ggaW5zdGFuY2Ugb2YgYSBFdXJvcGVhbiBudW1iZXJcXG4gICAgLy8gdW50aWwgdGhlIGZpcnN0IHN0cm9uZyB0eXBlIChSLCBMLCBBTCwgb3Igc29yKSBpcyBmb3VuZC4gSWYgYW5cXG4gICAgLy8gQUwgaXMgZm91bmQsIGNoYW5nZSB0aGUgdHlwZSBvZiB0aGUgRXVyb3BlYW4gbnVtYmVyIHRvIEFyYWJpY1xcbiAgICAvLyBudW1iZXIuXFxuICAgIC8vIFczLiBDaGFuZ2UgYWxsIEFMcyB0byBSLlxcbiAgICBmb3IgKHZhciBpJDIgPSAwLCBjdXIgPSBvdXRlclR5cGU7IGkkMiA8IGxlbjsgKytpJDIpIHtcXG4gICAgICB2YXIgdHlwZSQxID0gdHlwZXNbaSQyXVxcbiAgICAgIGlmICh0eXBlJDEgPT0gXFxcIjFcXFwiICYmIGN1ciA9PSBcXFwiclxcXCIpIHsgdHlwZXNbaSQyXSA9IFxcXCJuXFxcIiB9XFxuICAgICAgZWxzZSBpZiAoaXNTdHJvbmcudGVzdCh0eXBlJDEpKSB7IGN1ciA9IHR5cGUkMTsgaWYgKHR5cGUkMSA9PSBcXFwiclxcXCIpIHsgdHlwZXNbaSQyXSA9IFxcXCJSXFxcIiB9IH1cXG4gICAgfVxcblxcbiAgICAvLyBXNC4gQSBzaW5nbGUgRXVyb3BlYW4gc2VwYXJhdG9yIGJldHdlZW4gdHdvIEV1cm9wZWFuIG51bWJlcnNcXG4gICAgLy8gY2hhbmdlcyB0byBhIEV1cm9wZWFuIG51bWJlci4gQSBzaW5nbGUgY29tbW9uIHNlcGFyYXRvciBiZXR3ZWVuXFxuICAgIC8vIHR3byBudW1iZXJzIG9mIHRoZSBzYW1lIHR5cGUgY2hhbmdlcyB0byB0aGF0IHR5cGUuXFxuICAgIGZvciAodmFyIGkkMyA9IDEsIHByZXYkMSA9IHR5cGVzWzBdOyBpJDMgPCBsZW4gLSAxOyArK2kkMykge1xcbiAgICAgIHZhciB0eXBlJDIgPSB0eXBlc1tpJDNdXFxuICAgICAgaWYgKHR5cGUkMiA9PSBcXFwiK1xcXCIgJiYgcHJldiQxID09IFxcXCIxXFxcIiAmJiB0eXBlc1tpJDMrMV0gPT0gXFxcIjFcXFwiKSB7IHR5cGVzW2kkM10gPSBcXFwiMVxcXCIgfVxcbiAgICAgIGVsc2UgaWYgKHR5cGUkMiA9PSBcXFwiLFxcXCIgJiYgcHJldiQxID09IHR5cGVzW2kkMysxXSAmJlxcbiAgICAgICAgICAgICAgIChwcmV2JDEgPT0gXFxcIjFcXFwiIHx8IHByZXYkMSA9PSBcXFwiblxcXCIpKSB7IHR5cGVzW2kkM10gPSBwcmV2JDEgfVxcbiAgICAgIHByZXYkMSA9IHR5cGUkMlxcbiAgICB9XFxuXFxuICAgIC8vIFc1LiBBIHNlcXVlbmNlIG9mIEV1cm9wZWFuIHRlcm1pbmF0b3JzIGFkamFjZW50IHRvIEV1cm9wZWFuXFxuICAgIC8vIG51bWJlcnMgY2hhbmdlcyB0byBhbGwgRXVyb3BlYW4gbnVtYmVycy5cXG4gICAgLy8gVzYuIE90aGVyd2lzZSwgc2VwYXJhdG9ycyBhbmQgdGVybWluYXRvcnMgY2hhbmdlIHRvIE90aGVyXFxuICAgIC8vIE5ldXRyYWwuXFxuICAgIGZvciAodmFyIGkkNCA9IDA7IGkkNCA8IGxlbjsgKytpJDQpIHtcXG4gICAgICB2YXIgdHlwZSQzID0gdHlwZXNbaSQ0XVxcbiAgICAgIGlmICh0eXBlJDMgPT0gXFxcIixcXFwiKSB7IHR5cGVzW2kkNF0gPSBcXFwiTlxcXCIgfVxcbiAgICAgIGVsc2UgaWYgKHR5cGUkMyA9PSBcXFwiJVxcXCIpIHtcXG4gICAgICAgIHZhciBlbmQgPSB2b2lkIDBcXG4gICAgICAgIGZvciAoZW5kID0gaSQ0ICsgMTsgZW5kIDwgbGVuICYmIHR5cGVzW2VuZF0gPT0gXFxcIiVcXFwiOyArK2VuZCkge31cXG4gICAgICAgIHZhciByZXBsYWNlID0gKGkkNCAmJiB0eXBlc1tpJDQtMV0gPT0gXFxcIiFcXFwiKSB8fCAoZW5kIDwgbGVuICYmIHR5cGVzW2VuZF0gPT0gXFxcIjFcXFwiKSA/IFxcXCIxXFxcIiA6IFxcXCJOXFxcIlxcbiAgICAgICAgZm9yICh2YXIgaiA9IGkkNDsgaiA8IGVuZDsgKytqKSB7IHR5cGVzW2pdID0gcmVwbGFjZSB9XFxuICAgICAgICBpJDQgPSBlbmQgLSAxXFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIC8vIFc3LiBTZWFyY2ggYmFja3dhcmRzIGZyb20gZWFjaCBpbnN0YW5jZSBvZiBhIEV1cm9wZWFuIG51bWJlclxcbiAgICAvLyB1bnRpbCB0aGUgZmlyc3Qgc3Ryb25nIHR5cGUgKFIsIEwsIG9yIHNvcikgaXMgZm91bmQuIElmIGFuIEwgaXNcXG4gICAgLy8gZm91bmQsIHRoZW4gY2hhbmdlIHRoZSB0eXBlIG9mIHRoZSBFdXJvcGVhbiBudW1iZXIgdG8gTC5cXG4gICAgZm9yICh2YXIgaSQ1ID0gMCwgY3VyJDEgPSBvdXRlclR5cGU7IGkkNSA8IGxlbjsgKytpJDUpIHtcXG4gICAgICB2YXIgdHlwZSQ0ID0gdHlwZXNbaSQ1XVxcbiAgICAgIGlmIChjdXIkMSA9PSBcXFwiTFxcXCIgJiYgdHlwZSQ0ID09IFxcXCIxXFxcIikgeyB0eXBlc1tpJDVdID0gXFxcIkxcXFwiIH1cXG4gICAgICBlbHNlIGlmIChpc1N0cm9uZy50ZXN0KHR5cGUkNCkpIHsgY3VyJDEgPSB0eXBlJDQgfVxcbiAgICB9XFxuXFxuICAgIC8vIE4xLiBBIHNlcXVlbmNlIG9mIG5ldXRyYWxzIHRha2VzIHRoZSBkaXJlY3Rpb24gb2YgdGhlXFxuICAgIC8vIHN1cnJvdW5kaW5nIHN0cm9uZyB0ZXh0IGlmIHRoZSB0ZXh0IG9uIGJvdGggc2lkZXMgaGFzIHRoZSBzYW1lXFxuICAgIC8vIGRpcmVjdGlvbi4gRXVyb3BlYW4gYW5kIEFyYWJpYyBudW1iZXJzIGFjdCBhcyBpZiB0aGV5IHdlcmUgUiBpblxcbiAgICAvLyB0ZXJtcyBvZiB0aGVpciBpbmZsdWVuY2Ugb24gbmV1dHJhbHMuIFN0YXJ0LW9mLWxldmVsLXJ1biAoc29yKVxcbiAgICAvLyBhbmQgZW5kLW9mLWxldmVsLXJ1biAoZW9yKSBhcmUgdXNlZCBhdCBsZXZlbCBydW4gYm91bmRhcmllcy5cXG4gICAgLy8gTjIuIEFueSByZW1haW5pbmcgbmV1dHJhbHMgdGFrZSB0aGUgZW1iZWRkaW5nIGRpcmVjdGlvbi5cXG4gICAgZm9yICh2YXIgaSQ2ID0gMDsgaSQ2IDwgbGVuOyArK2kkNikge1xcbiAgICAgIGlmIChpc05ldXRyYWwudGVzdCh0eXBlc1tpJDZdKSkge1xcbiAgICAgICAgdmFyIGVuZCQxID0gdm9pZCAwXFxuICAgICAgICBmb3IgKGVuZCQxID0gaSQ2ICsgMTsgZW5kJDEgPCBsZW4gJiYgaXNOZXV0cmFsLnRlc3QodHlwZXNbZW5kJDFdKTsgKytlbmQkMSkge31cXG4gICAgICAgIHZhciBiZWZvcmUgPSAoaSQ2ID8gdHlwZXNbaSQ2LTFdIDogb3V0ZXJUeXBlKSA9PSBcXFwiTFxcXCJcXG4gICAgICAgIHZhciBhZnRlciA9IChlbmQkMSA8IGxlbiA/IHR5cGVzW2VuZCQxXSA6IG91dGVyVHlwZSkgPT0gXFxcIkxcXFwiXFxuICAgICAgICB2YXIgcmVwbGFjZSQxID0gYmVmb3JlIHx8IGFmdGVyID8gXFxcIkxcXFwiIDogXFxcIlJcXFwiXFxuICAgICAgICBmb3IgKHZhciBqJDEgPSBpJDY7IGokMSA8IGVuZCQxOyArK2okMSkgeyB0eXBlc1tqJDFdID0gcmVwbGFjZSQxIH1cXG4gICAgICAgIGkkNiA9IGVuZCQxIC0gMVxcbiAgICAgIH1cXG4gICAgfVxcblxcbiAgICAvLyBIZXJlIHdlIGRlcGFydCBmcm9tIHRoZSBkb2N1bWVudGVkIGFsZ29yaXRobSwgaW4gb3JkZXIgdG8gYXZvaWRcXG4gICAgLy8gYnVpbGRpbmcgdXAgYW4gYWN0dWFsIGxldmVscyBhcnJheS4gU2luY2UgdGhlcmUgYXJlIG9ubHkgdGhyZWVcXG4gICAgLy8gbGV2ZWxzICgwLCAxLCAyKSBpbiBhbiBpbXBsZW1lbnRhdGlvbiB0aGF0IGRvZXNuJ3QgdGFrZVxcbiAgICAvLyBleHBsaWNpdCBlbWJlZGRpbmcgaW50byBhY2NvdW50LCB3ZSBjYW4gYnVpbGQgdXAgdGhlIG9yZGVyIG9uXFxuICAgIC8vIHRoZSBmbHksIHdpdGhvdXQgZm9sbG93aW5nIHRoZSBsZXZlbC1iYXNlZCBhbGdvcml0aG0uXFxuICAgIHZhciBvcmRlciA9IFtdLCBtXFxuICAgIGZvciAodmFyIGkkNyA9IDA7IGkkNyA8IGxlbjspIHtcXG4gICAgICBpZiAoY291bnRzQXNMZWZ0LnRlc3QodHlwZXNbaSQ3XSkpIHtcXG4gICAgICAgIHZhciBzdGFydCA9IGkkN1xcbiAgICAgICAgZm9yICgrK2kkNzsgaSQ3IDwgbGVuICYmIGNvdW50c0FzTGVmdC50ZXN0KHR5cGVzW2kkN10pOyArK2kkNykge31cXG4gICAgICAgIG9yZGVyLnB1c2gobmV3IEJpZGlTcGFuKDAsIHN0YXJ0LCBpJDcpKVxcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICB2YXIgcG9zID0gaSQ3LCBhdCA9IG9yZGVyLmxlbmd0aFxcbiAgICAgICAgZm9yICgrK2kkNzsgaSQ3IDwgbGVuICYmIHR5cGVzW2kkN10gIT0gXFxcIkxcXFwiOyArK2kkNykge31cXG4gICAgICAgIGZvciAodmFyIGokMiA9IHBvczsgaiQyIDwgaSQ3Oykge1xcbiAgICAgICAgICBpZiAoY291bnRzQXNOdW0udGVzdCh0eXBlc1tqJDJdKSkge1xcbiAgICAgICAgICAgIGlmIChwb3MgPCBqJDIpIHsgb3JkZXIuc3BsaWNlKGF0LCAwLCBuZXcgQmlkaVNwYW4oMSwgcG9zLCBqJDIpKSB9XFxuICAgICAgICAgICAgdmFyIG5zdGFydCA9IGokMlxcbiAgICAgICAgICAgIGZvciAoKytqJDI7IGokMiA8IGkkNyAmJiBjb3VudHNBc051bS50ZXN0KHR5cGVzW2okMl0pOyArK2okMikge31cXG4gICAgICAgICAgICBvcmRlci5zcGxpY2UoYXQsIDAsIG5ldyBCaWRpU3BhbigyLCBuc3RhcnQsIGokMikpXFxuICAgICAgICAgICAgcG9zID0gaiQyXFxuICAgICAgICAgIH0gZWxzZSB7ICsraiQyIH1cXG4gICAgICAgIH1cXG4gICAgICAgIGlmIChwb3MgPCBpJDcpIHsgb3JkZXIuc3BsaWNlKGF0LCAwLCBuZXcgQmlkaVNwYW4oMSwgcG9zLCBpJDcpKSB9XFxuICAgICAgfVxcbiAgICB9XFxuICAgIGlmIChvcmRlclswXS5sZXZlbCA9PSAxICYmIChtID0gc3RyLm1hdGNoKC9eXFxcXHMrLykpKSB7XFxuICAgICAgb3JkZXJbMF0uZnJvbSA9IG1bMF0ubGVuZ3RoXFxuICAgICAgb3JkZXIudW5zaGlmdChuZXcgQmlkaVNwYW4oMCwgMCwgbVswXS5sZW5ndGgpKVxcbiAgICB9XFxuICAgIGlmIChsc3Qob3JkZXIpLmxldmVsID09IDEgJiYgKG0gPSBzdHIubWF0Y2goL1xcXFxzKyQvKSkpIHtcXG4gICAgICBsc3Qob3JkZXIpLnRvIC09IG1bMF0ubGVuZ3RoXFxuICAgICAgb3JkZXIucHVzaChuZXcgQmlkaVNwYW4oMCwgbGVuIC0gbVswXS5sZW5ndGgsIGxlbikpXFxuICAgIH1cXG4gICAgaWYgKG9yZGVyWzBdLmxldmVsID09IDIpXFxuICAgICAgeyBvcmRlci51bnNoaWZ0KG5ldyBCaWRpU3BhbigxLCBvcmRlclswXS50bywgb3JkZXJbMF0udG8pKSB9XFxuICAgIGlmIChvcmRlclswXS5sZXZlbCAhPSBsc3Qob3JkZXIpLmxldmVsKVxcbiAgICAgIHsgb3JkZXIucHVzaChuZXcgQmlkaVNwYW4ob3JkZXJbMF0ubGV2ZWwsIGxlbiwgbGVuKSkgfVxcblxcbiAgICByZXR1cm4gb3JkZXJcXG4gIH1cXG59KSgpXFxuXFxuLy8gR2V0IHRoZSBiaWRpIG9yZGVyaW5nIGZvciB0aGUgZ2l2ZW4gbGluZSAoYW5kIGNhY2hlIGl0KS4gUmV0dXJuc1xcbi8vIGZhbHNlIGZvciBsaW5lcyB0aGF0IGFyZSBmdWxseSBsZWZ0LXRvLXJpZ2h0LCBhbmQgYW4gYXJyYXkgb2ZcXG4vLyBCaWRpU3BhbiBvYmplY3RzIG90aGVyd2lzZS5cXG5mdW5jdGlvbiBnZXRPcmRlcihsaW5lKSB7XFxuICB2YXIgb3JkZXIgPSBsaW5lLm9yZGVyXFxuICBpZiAob3JkZXIgPT0gbnVsbCkgeyBvcmRlciA9IGxpbmUub3JkZXIgPSBiaWRpT3JkZXJpbmcobGluZS50ZXh0KSB9XFxuICByZXR1cm4gb3JkZXJcXG59XFxuXFxuLy8gRVZFTlQgSEFORExJTkdcXG5cXG4vLyBMaWdodHdlaWdodCBldmVudCBmcmFtZXdvcmsuIG9uL29mZiBhbHNvIHdvcmsgb24gRE9NIG5vZGVzLFxcbi8vIHJlZ2lzdGVyaW5nIG5hdGl2ZSBET00gaGFuZGxlcnMuXFxuXFxudmFyIG9uID0gZnVuY3Rpb24oZW1pdHRlciwgdHlwZSwgZikge1xcbiAgaWYgKGVtaXR0ZXIuYWRkRXZlbnRMaXN0ZW5lcilcXG4gICAgeyBlbWl0dGVyLmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgZiwgZmFsc2UpIH1cXG4gIGVsc2UgaWYgKGVtaXR0ZXIuYXR0YWNoRXZlbnQpXFxuICAgIHsgZW1pdHRlci5hdHRhY2hFdmVudChcXFwib25cXFwiICsgdHlwZSwgZikgfVxcbiAgZWxzZSB7XFxuICAgIHZhciBtYXAgPSBlbWl0dGVyLl9oYW5kbGVycyB8fCAoZW1pdHRlci5faGFuZGxlcnMgPSB7fSlcXG4gICAgdmFyIGFyciA9IG1hcFt0eXBlXSB8fCAobWFwW3R5cGVdID0gW10pXFxuICAgIGFyci5wdXNoKGYpXFxuICB9XFxufVxcblxcbnZhciBub0hhbmRsZXJzID0gW11cXG5mdW5jdGlvbiBnZXRIYW5kbGVycyhlbWl0dGVyLCB0eXBlLCBjb3B5KSB7XFxuICB2YXIgYXJyID0gZW1pdHRlci5faGFuZGxlcnMgJiYgZW1pdHRlci5faGFuZGxlcnNbdHlwZV1cXG4gIGlmIChjb3B5KSB7IHJldHVybiBhcnIgJiYgYXJyLmxlbmd0aCA+IDAgPyBhcnIuc2xpY2UoKSA6IG5vSGFuZGxlcnMgfVxcbiAgZWxzZSB7IHJldHVybiBhcnIgfHwgbm9IYW5kbGVycyB9XFxufVxcblxcbmZ1bmN0aW9uIG9mZihlbWl0dGVyLCB0eXBlLCBmKSB7XFxuICBpZiAoZW1pdHRlci5yZW1vdmVFdmVudExpc3RlbmVyKVxcbiAgICB7IGVtaXR0ZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBmLCBmYWxzZSkgfVxcbiAgZWxzZSBpZiAoZW1pdHRlci5kZXRhY2hFdmVudClcXG4gICAgeyBlbWl0dGVyLmRldGFjaEV2ZW50KFxcXCJvblxcXCIgKyB0eXBlLCBmKSB9XFxuICBlbHNlIHtcXG4gICAgdmFyIGhhbmRsZXJzID0gZ2V0SGFuZGxlcnMoZW1pdHRlciwgdHlwZSwgZmFsc2UpXFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaGFuZGxlcnMubGVuZ3RoOyArK2kpXFxuICAgICAgeyBpZiAoaGFuZGxlcnNbaV0gPT0gZikgeyBoYW5kbGVycy5zcGxpY2UoaSwgMSk7IGJyZWFrIH0gfVxcbiAgfVxcbn1cXG5cXG5mdW5jdGlvbiBzaWduYWwoZW1pdHRlciwgdHlwZSAvKiwgdmFsdWVzLi4uKi8pIHtcXG4gIHZhciBoYW5kbGVycyA9IGdldEhhbmRsZXJzKGVtaXR0ZXIsIHR5cGUsIHRydWUpXFxuICBpZiAoIWhhbmRsZXJzLmxlbmd0aCkgeyByZXR1cm4gfVxcbiAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpXFxuICBmb3IgKHZhciBpID0gMDsgaSA8IGhhbmRsZXJzLmxlbmd0aDsgKytpKSB7IGhhbmRsZXJzW2ldLmFwcGx5KG51bGwsIGFyZ3MpIH1cXG59XFxuXFxuLy8gVGhlIERPTSBldmVudHMgdGhhdCBDb2RlTWlycm9yIGhhbmRsZXMgY2FuIGJlIG92ZXJyaWRkZW4gYnlcXG4vLyByZWdpc3RlcmluZyBhIChub24tRE9NKSBoYW5kbGVyIG9uIHRoZSBlZGl0b3IgZm9yIHRoZSBldmVudCBuYW1lLFxcbi8vIGFuZCBwcmV2ZW50RGVmYXVsdC1pbmcgdGhlIGV2ZW50IGluIHRoYXQgaGFuZGxlci5cXG5mdW5jdGlvbiBzaWduYWxET01FdmVudChjbSwgZSwgb3ZlcnJpZGUpIHtcXG4gIGlmICh0eXBlb2YgZSA9PSBcXFwic3RyaW5nXFxcIilcXG4gICAgeyBlID0ge3R5cGU6IGUsIHByZXZlbnREZWZhdWx0OiBmdW5jdGlvbigpIHsgdGhpcy5kZWZhdWx0UHJldmVudGVkID0gdHJ1ZSB9fSB9XFxuICBzaWduYWwoY20sIG92ZXJyaWRlIHx8IGUudHlwZSwgY20sIGUpXFxuICByZXR1cm4gZV9kZWZhdWx0UHJldmVudGVkKGUpIHx8IGUuY29kZW1pcnJvcklnbm9yZVxcbn1cXG5cXG5mdW5jdGlvbiBzaWduYWxDdXJzb3JBY3Rpdml0eShjbSkge1xcbiAgdmFyIGFyciA9IGNtLl9oYW5kbGVycyAmJiBjbS5faGFuZGxlcnMuY3Vyc29yQWN0aXZpdHlcXG4gIGlmICghYXJyKSB7IHJldHVybiB9XFxuICB2YXIgc2V0ID0gY20uY3VyT3AuY3Vyc29yQWN0aXZpdHlIYW5kbGVycyB8fCAoY20uY3VyT3AuY3Vyc29yQWN0aXZpdHlIYW5kbGVycyA9IFtdKVxcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyArK2kpIHsgaWYgKGluZGV4T2Yoc2V0LCBhcnJbaV0pID09IC0xKVxcbiAgICB7IHNldC5wdXNoKGFycltpXSkgfSB9XFxufVxcblxcbmZ1bmN0aW9uIGhhc0hhbmRsZXIoZW1pdHRlciwgdHlwZSkge1xcbiAgcmV0dXJuIGdldEhhbmRsZXJzKGVtaXR0ZXIsIHR5cGUpLmxlbmd0aCA+IDBcXG59XFxuXFxuLy8gQWRkIG9uIGFuZCBvZmYgbWV0aG9kcyB0byBhIGNvbnN0cnVjdG9yJ3MgcHJvdG90eXBlLCB0byBtYWtlXFxuLy8gcmVnaXN0ZXJpbmcgZXZlbnRzIG9uIHN1Y2ggb2JqZWN0cyBtb3JlIGNvbnZlbmllbnQuXFxuZnVuY3Rpb24gZXZlbnRNaXhpbihjdG9yKSB7XFxuICBjdG9yLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uKHR5cGUsIGYpIHtvbih0aGlzLCB0eXBlLCBmKX1cXG4gIGN0b3IucHJvdG90eXBlLm9mZiA9IGZ1bmN0aW9uKHR5cGUsIGYpIHtvZmYodGhpcywgdHlwZSwgZil9XFxufVxcblxcbi8vIER1ZSB0byB0aGUgZmFjdCB0aGF0IHdlIHN0aWxsIHN1cHBvcnQganVyYXNzaWMgSUUgdmVyc2lvbnMsIHNvbWVcXG4vLyBjb21wYXRpYmlsaXR5IHdyYXBwZXJzIGFyZSBuZWVkZWQuXFxuXFxuZnVuY3Rpb24gZV9wcmV2ZW50RGVmYXVsdChlKSB7XFxuICBpZiAoZS5wcmV2ZW50RGVmYXVsdCkgeyBlLnByZXZlbnREZWZhdWx0KCkgfVxcbiAgZWxzZSB7IGUucmV0dXJuVmFsdWUgPSBmYWxzZSB9XFxufVxcbmZ1bmN0aW9uIGVfc3RvcFByb3BhZ2F0aW9uKGUpIHtcXG4gIGlmIChlLnN0b3BQcm9wYWdhdGlvbikgeyBlLnN0b3BQcm9wYWdhdGlvbigpIH1cXG4gIGVsc2UgeyBlLmNhbmNlbEJ1YmJsZSA9IHRydWUgfVxcbn1cXG5mdW5jdGlvbiBlX2RlZmF1bHRQcmV2ZW50ZWQoZSkge1xcbiAgcmV0dXJuIGUuZGVmYXVsdFByZXZlbnRlZCAhPSBudWxsID8gZS5kZWZhdWx0UHJldmVudGVkIDogZS5yZXR1cm5WYWx1ZSA9PSBmYWxzZVxcbn1cXG5mdW5jdGlvbiBlX3N0b3AoZSkge2VfcHJldmVudERlZmF1bHQoZSk7IGVfc3RvcFByb3BhZ2F0aW9uKGUpfVxcblxcbmZ1bmN0aW9uIGVfdGFyZ2V0KGUpIHtyZXR1cm4gZS50YXJnZXQgfHwgZS5zcmNFbGVtZW50fVxcbmZ1bmN0aW9uIGVfYnV0dG9uKGUpIHtcXG4gIHZhciBiID0gZS53aGljaFxcbiAgaWYgKGIgPT0gbnVsbCkge1xcbiAgICBpZiAoZS5idXR0b24gJiAxKSB7IGIgPSAxIH1cXG4gICAgZWxzZSBpZiAoZS5idXR0b24gJiAyKSB7IGIgPSAzIH1cXG4gICAgZWxzZSBpZiAoZS5idXR0b24gJiA0KSB7IGIgPSAyIH1cXG4gIH1cXG4gIGlmIChtYWMgJiYgZS5jdHJsS2V5ICYmIGIgPT0gMSkgeyBiID0gMyB9XFxuICByZXR1cm4gYlxcbn1cXG5cXG4vLyBEZXRlY3QgZHJhZy1hbmQtZHJvcFxcbnZhciBkcmFnQW5kRHJvcCA9IGZ1bmN0aW9uKCkge1xcbiAgLy8gVGhlcmUgaXMgKnNvbWUqIGtpbmQgb2YgZHJhZy1hbmQtZHJvcCBzdXBwb3J0IGluIElFNi04LCBidXQgSVxcbiAgLy8gY291bGRuJ3QgZ2V0IGl0IHRvIHdvcmsgeWV0LlxcbiAgaWYgKGllICYmIGllX3ZlcnNpb24gPCA5KSB7IHJldHVybiBmYWxzZSB9XFxuICB2YXIgZGl2ID0gZWx0KCdkaXYnKVxcbiAgcmV0dXJuIFxcXCJkcmFnZ2FibGVcXFwiIGluIGRpdiB8fCBcXFwiZHJhZ0Ryb3BcXFwiIGluIGRpdlxcbn0oKVxcblxcbnZhciB6d3NwU3VwcG9ydGVkXFxuZnVuY3Rpb24gemVyb1dpZHRoRWxlbWVudChtZWFzdXJlKSB7XFxuICBpZiAoendzcFN1cHBvcnRlZCA9PSBudWxsKSB7XFxuICAgIHZhciB0ZXN0ID0gZWx0KFxcXCJzcGFuXFxcIiwgXFxcIlxcXFx1MjAwYlxcXCIpXFxuICAgIHJlbW92ZUNoaWxkcmVuQW5kQWRkKG1lYXN1cmUsIGVsdChcXFwic3BhblxcXCIsIFt0ZXN0LCBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcXFwieFxcXCIpXSkpXFxuICAgIGlmIChtZWFzdXJlLmZpcnN0Q2hpbGQub2Zmc2V0SGVpZ2h0ICE9IDApXFxuICAgICAgeyB6d3NwU3VwcG9ydGVkID0gdGVzdC5vZmZzZXRXaWR0aCA8PSAxICYmIHRlc3Qub2Zmc2V0SGVpZ2h0ID4gMiAmJiAhKGllICYmIGllX3ZlcnNpb24gPCA4KSB9XFxuICB9XFxuICB2YXIgbm9kZSA9IHp3c3BTdXBwb3J0ZWQgPyBlbHQoXFxcInNwYW5cXFwiLCBcXFwiXFxcXHUyMDBiXFxcIikgOlxcbiAgICBlbHQoXFxcInNwYW5cXFwiLCBcXFwiXFxcXHUwMGEwXFxcIiwgbnVsbCwgXFxcImRpc3BsYXk6IGlubGluZS1ibG9jazsgd2lkdGg6IDFweDsgbWFyZ2luLXJpZ2h0OiAtMXB4XFxcIilcXG4gIG5vZGUuc2V0QXR0cmlidXRlKFxcXCJjbS10ZXh0XFxcIiwgXFxcIlxcXCIpXFxuICByZXR1cm4gbm9kZVxcbn1cXG5cXG4vLyBGZWF0dXJlLWRldGVjdCBJRSdzIGNydW1teSBjbGllbnQgcmVjdCByZXBvcnRpbmcgZm9yIGJpZGkgdGV4dFxcbnZhciBiYWRCaWRpUmVjdHNcXG5mdW5jdGlvbiBoYXNCYWRCaWRpUmVjdHMobWVhc3VyZSkge1xcbiAgaWYgKGJhZEJpZGlSZWN0cyAhPSBudWxsKSB7IHJldHVybiBiYWRCaWRpUmVjdHMgfVxcbiAgdmFyIHR4dCA9IHJlbW92ZUNoaWxkcmVuQW5kQWRkKG1lYXN1cmUsIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFxcXCJBXFxcXHUwNjJlQVxcXCIpKVxcbiAgdmFyIHIwID0gcmFuZ2UodHh0LCAwLCAxKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxcbiAgdmFyIHIxID0gcmFuZ2UodHh0LCAxLCAyKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxcbiAgcmVtb3ZlQ2hpbGRyZW4obWVhc3VyZSlcXG4gIGlmICghcjAgfHwgcjAubGVmdCA9PSByMC5yaWdodCkgeyByZXR1cm4gZmFsc2UgfSAvLyBTYWZhcmkgcmV0dXJucyBudWxsIGluIHNvbWUgY2FzZXMgKCMyNzgwKVxcbiAgcmV0dXJuIGJhZEJpZGlSZWN0cyA9IChyMS5yaWdodCAtIHIwLnJpZ2h0IDwgMylcXG59XFxuXFxuLy8gU2VlIGlmIFxcXCJcXFwiLnNwbGl0IGlzIHRoZSBicm9rZW4gSUUgdmVyc2lvbiwgaWYgc28sIHByb3ZpZGUgYW5cXG4vLyBhbHRlcm5hdGl2ZSB3YXkgdG8gc3BsaXQgbGluZXMuXFxudmFyIHNwbGl0TGluZXNBdXRvID0gXFxcIlxcXFxuXFxcXG5iXFxcIi5zcGxpdCgvXFxcXG4vKS5sZW5ndGggIT0gMyA/IGZ1bmN0aW9uIChzdHJpbmcpIHtcXG4gIHZhciBwb3MgPSAwLCByZXN1bHQgPSBbXSwgbCA9IHN0cmluZy5sZW5ndGhcXG4gIHdoaWxlIChwb3MgPD0gbCkge1xcbiAgICB2YXIgbmwgPSBzdHJpbmcuaW5kZXhPZihcXFwiXFxcXG5cXFwiLCBwb3MpXFxuICAgIGlmIChubCA9PSAtMSkgeyBubCA9IHN0cmluZy5sZW5ndGggfVxcbiAgICB2YXIgbGluZSA9IHN0cmluZy5zbGljZShwb3MsIHN0cmluZy5jaGFyQXQobmwgLSAxKSA9PSBcXFwiXFxcXHJcXFwiID8gbmwgLSAxIDogbmwpXFxuICAgIHZhciBydCA9IGxpbmUuaW5kZXhPZihcXFwiXFxcXHJcXFwiKVxcbiAgICBpZiAocnQgIT0gLTEpIHtcXG4gICAgICByZXN1bHQucHVzaChsaW5lLnNsaWNlKDAsIHJ0KSlcXG4gICAgICBwb3MgKz0gcnQgKyAxXFxuICAgIH0gZWxzZSB7XFxuICAgICAgcmVzdWx0LnB1c2gobGluZSlcXG4gICAgICBwb3MgPSBubCArIDFcXG4gICAgfVxcbiAgfVxcbiAgcmV0dXJuIHJlc3VsdFxcbn0gOiBmdW5jdGlvbiAoc3RyaW5nKSB7IHJldHVybiBzdHJpbmcuc3BsaXQoL1xcXFxyXFxcXG4/fFxcXFxuLyk7IH1cXG5cXG52YXIgaGFzU2VsZWN0aW9uID0gd2luZG93LmdldFNlbGVjdGlvbiA/IGZ1bmN0aW9uICh0ZSkge1xcbiAgdHJ5IHsgcmV0dXJuIHRlLnNlbGVjdGlvblN0YXJ0ICE9IHRlLnNlbGVjdGlvbkVuZCB9XFxuICBjYXRjaChlKSB7IHJldHVybiBmYWxzZSB9XFxufSA6IGZ1bmN0aW9uICh0ZSkge1xcbiAgdmFyIHJhbmdlXFxuICB0cnkge3JhbmdlID0gdGUub3duZXJEb2N1bWVudC5zZWxlY3Rpb24uY3JlYXRlUmFuZ2UoKX1cXG4gIGNhdGNoKGUpIHt9XFxuICBpZiAoIXJhbmdlIHx8IHJhbmdlLnBhcmVudEVsZW1lbnQoKSAhPSB0ZSkgeyByZXR1cm4gZmFsc2UgfVxcbiAgcmV0dXJuIHJhbmdlLmNvbXBhcmVFbmRQb2ludHMoXFxcIlN0YXJ0VG9FbmRcXFwiLCByYW5nZSkgIT0gMFxcbn1cXG5cXG52YXIgaGFzQ29weUV2ZW50ID0gKGZ1bmN0aW9uICgpIHtcXG4gIHZhciBlID0gZWx0KFxcXCJkaXZcXFwiKVxcbiAgaWYgKFxcXCJvbmNvcHlcXFwiIGluIGUpIHsgcmV0dXJuIHRydWUgfVxcbiAgZS5zZXRBdHRyaWJ1dGUoXFxcIm9uY29weVxcXCIsIFxcXCJyZXR1cm47XFxcIilcXG4gIHJldHVybiB0eXBlb2YgZS5vbmNvcHkgPT0gXFxcImZ1bmN0aW9uXFxcIlxcbn0pKClcXG5cXG52YXIgYmFkWm9vbWVkUmVjdHMgPSBudWxsXFxuZnVuY3Rpb24gaGFzQmFkWm9vbWVkUmVjdHMobWVhc3VyZSkge1xcbiAgaWYgKGJhZFpvb21lZFJlY3RzICE9IG51bGwpIHsgcmV0dXJuIGJhZFpvb21lZFJlY3RzIH1cXG4gIHZhciBub2RlID0gcmVtb3ZlQ2hpbGRyZW5BbmRBZGQobWVhc3VyZSwgZWx0KFxcXCJzcGFuXFxcIiwgXFxcInhcXFwiKSlcXG4gIHZhciBub3JtYWwgPSBub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXFxuICB2YXIgZnJvbVJhbmdlID0gcmFuZ2Uobm9kZSwgMCwgMSkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClcXG4gIHJldHVybiBiYWRab29tZWRSZWN0cyA9IE1hdGguYWJzKG5vcm1hbC5sZWZ0IC0gZnJvbVJhbmdlLmxlZnQpID4gMVxcbn1cXG5cXG52YXIgbW9kZXMgPSB7fTtcXG52YXIgbWltZU1vZGVzID0ge307XFxuLy8gRXh0cmEgYXJndW1lbnRzIGFyZSBzdG9yZWQgYXMgdGhlIG1vZGUncyBkZXBlbmRlbmNpZXMsIHdoaWNoIGlzXFxuLy8gdXNlZCBieSAobGVnYWN5KSBtZWNoYW5pc21zIGxpa2UgbG9hZG1vZGUuanMgdG8gYXV0b21hdGljYWxseVxcbi8vIGxvYWQgYSBtb2RlLiAoUHJlZmVycmVkIG1lY2hhbmlzbSBpcyB0aGUgcmVxdWlyZS9kZWZpbmUgY2FsbHMuKVxcbmZ1bmN0aW9uIGRlZmluZU1vZGUobmFtZSwgbW9kZSkge1xcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAyKVxcbiAgICB7IG1vZGUuZGVwZW5kZW5jaWVzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKSB9XFxuICBtb2Rlc1tuYW1lXSA9IG1vZGVcXG59XFxuXFxuZnVuY3Rpb24gZGVmaW5lTUlNRShtaW1lLCBzcGVjKSB7XFxuICBtaW1lTW9kZXNbbWltZV0gPSBzcGVjXFxufVxcblxcbi8vIEdpdmVuIGEgTUlNRSB0eXBlLCBhIHtuYW1lLCAuLi5vcHRpb25zfSBjb25maWcgb2JqZWN0LCBvciBhIG5hbWVcXG4vLyBzdHJpbmcsIHJldHVybiBhIG1vZGUgY29uZmlnIG9iamVjdC5cXG5mdW5jdGlvbiByZXNvbHZlTW9kZShzcGVjKSB7XFxuICBpZiAodHlwZW9mIHNwZWMgPT0gXFxcInN0cmluZ1xcXCIgJiYgbWltZU1vZGVzLmhhc093blByb3BlcnR5KHNwZWMpKSB7XFxuICAgIHNwZWMgPSBtaW1lTW9kZXNbc3BlY11cXG4gIH0gZWxzZSBpZiAoc3BlYyAmJiB0eXBlb2Ygc3BlYy5uYW1lID09IFxcXCJzdHJpbmdcXFwiICYmIG1pbWVNb2Rlcy5oYXNPd25Qcm9wZXJ0eShzcGVjLm5hbWUpKSB7XFxuICAgIHZhciBmb3VuZCA9IG1pbWVNb2Rlc1tzcGVjLm5hbWVdXFxuICAgIGlmICh0eXBlb2YgZm91bmQgPT0gXFxcInN0cmluZ1xcXCIpIHsgZm91bmQgPSB7bmFtZTogZm91bmR9IH1cXG4gICAgc3BlYyA9IGNyZWF0ZU9iaihmb3VuZCwgc3BlYylcXG4gICAgc3BlYy5uYW1lID0gZm91bmQubmFtZVxcbiAgfSBlbHNlIGlmICh0eXBlb2Ygc3BlYyA9PSBcXFwic3RyaW5nXFxcIiAmJiAvXltcXFxcd1xcXFwtXStcXFxcL1tcXFxcd1xcXFwtXStcXFxcK3htbCQvLnRlc3Qoc3BlYykpIHtcXG4gICAgcmV0dXJuIHJlc29sdmVNb2RlKFxcXCJhcHBsaWNhdGlvbi94bWxcXFwiKVxcbiAgfSBlbHNlIGlmICh0eXBlb2Ygc3BlYyA9PSBcXFwic3RyaW5nXFxcIiAmJiAvXltcXFxcd1xcXFwtXStcXFxcL1tcXFxcd1xcXFwtXStcXFxcK2pzb24kLy50ZXN0KHNwZWMpKSB7XFxuICAgIHJldHVybiByZXNvbHZlTW9kZShcXFwiYXBwbGljYXRpb24vanNvblxcXCIpXFxuICB9XFxuICBpZiAodHlwZW9mIHNwZWMgPT0gXFxcInN0cmluZ1xcXCIpIHsgcmV0dXJuIHtuYW1lOiBzcGVjfSB9XFxuICBlbHNlIHsgcmV0dXJuIHNwZWMgfHwge25hbWU6IFxcXCJudWxsXFxcIn0gfVxcbn1cXG5cXG4vLyBHaXZlbiBhIG1vZGUgc3BlYyAoYW55dGhpbmcgdGhhdCByZXNvbHZlTW9kZSBhY2NlcHRzKSwgZmluZCBhbmRcXG4vLyBpbml0aWFsaXplIGFuIGFjdHVhbCBtb2RlIG9iamVjdC5cXG5mdW5jdGlvbiBnZXRNb2RlKG9wdGlvbnMsIHNwZWMpIHtcXG4gIHNwZWMgPSByZXNvbHZlTW9kZShzcGVjKVxcbiAgdmFyIG1mYWN0b3J5ID0gbW9kZXNbc3BlYy5uYW1lXVxcbiAgaWYgKCFtZmFjdG9yeSkgeyByZXR1cm4gZ2V0TW9kZShvcHRpb25zLCBcXFwidGV4dC9wbGFpblxcXCIpIH1cXG4gIHZhciBtb2RlT2JqID0gbWZhY3Rvcnkob3B0aW9ucywgc3BlYylcXG4gIGlmIChtb2RlRXh0ZW5zaW9ucy5oYXNPd25Qcm9wZXJ0eShzcGVjLm5hbWUpKSB7XFxuICAgIHZhciBleHRzID0gbW9kZUV4dGVuc2lvbnNbc3BlYy5uYW1lXVxcbiAgICBmb3IgKHZhciBwcm9wIGluIGV4dHMpIHtcXG4gICAgICBpZiAoIWV4dHMuaGFzT3duUHJvcGVydHkocHJvcCkpIHsgY29udGludWUgfVxcbiAgICAgIGlmIChtb2RlT2JqLmhhc093blByb3BlcnR5KHByb3ApKSB7IG1vZGVPYmpbXFxcIl9cXFwiICsgcHJvcF0gPSBtb2RlT2JqW3Byb3BdIH1cXG4gICAgICBtb2RlT2JqW3Byb3BdID0gZXh0c1twcm9wXVxcbiAgICB9XFxuICB9XFxuICBtb2RlT2JqLm5hbWUgPSBzcGVjLm5hbWVcXG4gIGlmIChzcGVjLmhlbHBlclR5cGUpIHsgbW9kZU9iai5oZWxwZXJUeXBlID0gc3BlYy5oZWxwZXJUeXBlIH1cXG4gIGlmIChzcGVjLm1vZGVQcm9wcykgeyBmb3IgKHZhciBwcm9wJDEgaW4gc3BlYy5tb2RlUHJvcHMpXFxuICAgIHsgbW9kZU9ialtwcm9wJDFdID0gc3BlYy5tb2RlUHJvcHNbcHJvcCQxXSB9IH1cXG5cXG4gIHJldHVybiBtb2RlT2JqXFxufVxcblxcbi8vIFRoaXMgY2FuIGJlIHVzZWQgdG8gYXR0YWNoIHByb3BlcnRpZXMgdG8gbW9kZSBvYmplY3RzIGZyb21cXG4vLyBvdXRzaWRlIHRoZSBhY3R1YWwgbW9kZSBkZWZpbml0aW9uLlxcbnZhciBtb2RlRXh0ZW5zaW9ucyA9IHt9XFxuZnVuY3Rpb24gZXh0ZW5kTW9kZShtb2RlLCBwcm9wZXJ0aWVzKSB7XFxuICB2YXIgZXh0cyA9IG1vZGVFeHRlbnNpb25zLmhhc093blByb3BlcnR5KG1vZGUpID8gbW9kZUV4dGVuc2lvbnNbbW9kZV0gOiAobW9kZUV4dGVuc2lvbnNbbW9kZV0gPSB7fSlcXG4gIGNvcHlPYmoocHJvcGVydGllcywgZXh0cylcXG59XFxuXFxuZnVuY3Rpb24gY29weVN0YXRlKG1vZGUsIHN0YXRlKSB7XFxuICBpZiAoc3RhdGUgPT09IHRydWUpIHsgcmV0dXJuIHN0YXRlIH1cXG4gIGlmIChtb2RlLmNvcHlTdGF0ZSkgeyByZXR1cm4gbW9kZS5jb3B5U3RhdGUoc3RhdGUpIH1cXG4gIHZhciBuc3RhdGUgPSB7fVxcbiAgZm9yICh2YXIgbiBpbiBzdGF0ZSkge1xcbiAgICB2YXIgdmFsID0gc3RhdGVbbl1cXG4gICAgaWYgKHZhbCBpbnN0YW5jZW9mIEFycmF5KSB7IHZhbCA9IHZhbC5jb25jYXQoW10pIH1cXG4gICAgbnN0YXRlW25dID0gdmFsXFxuICB9XFxuICByZXR1cm4gbnN0YXRlXFxufVxcblxcbi8vIEdpdmVuIGEgbW9kZSBhbmQgYSBzdGF0ZSAoZm9yIHRoYXQgbW9kZSksIGZpbmQgdGhlIGlubmVyIG1vZGUgYW5kXFxuLy8gc3RhdGUgYXQgdGhlIHBvc2l0aW9uIHRoYXQgdGhlIHN0YXRlIHJlZmVycyB0by5cXG5mdW5jdGlvbiBpbm5lck1vZGUobW9kZSwgc3RhdGUpIHtcXG4gIHZhciBpbmZvXFxuICB3aGlsZSAobW9kZS5pbm5lck1vZGUpIHtcXG4gICAgaW5mbyA9IG1vZGUuaW5uZXJNb2RlKHN0YXRlKVxcbiAgICBpZiAoIWluZm8gfHwgaW5mby5tb2RlID09IG1vZGUpIHsgYnJlYWsgfVxcbiAgICBzdGF0ZSA9IGluZm8uc3RhdGVcXG4gICAgbW9kZSA9IGluZm8ubW9kZVxcbiAgfVxcbiAgcmV0dXJuIGluZm8gfHwge21vZGU6IG1vZGUsIHN0YXRlOiBzdGF0ZX1cXG59XFxuXFxuZnVuY3Rpb24gc3RhcnRTdGF0ZShtb2RlLCBhMSwgYTIpIHtcXG4gIHJldHVybiBtb2RlLnN0YXJ0U3RhdGUgPyBtb2RlLnN0YXJ0U3RhdGUoYTEsIGEyKSA6IHRydWVcXG59XFxuXFxuLy8gU1RSSU5HIFNUUkVBTVxcblxcbi8vIEZlZCB0byB0aGUgbW9kZSBwYXJzZXJzLCBwcm92aWRlcyBoZWxwZXIgZnVuY3Rpb25zIHRvIG1ha2VcXG4vLyBwYXJzZXJzIG1vcmUgc3VjY2luY3QuXFxuXFxudmFyIFN0cmluZ1N0cmVhbSA9IGZ1bmN0aW9uKHN0cmluZywgdGFiU2l6ZSkge1xcbiAgdGhpcy5wb3MgPSB0aGlzLnN0YXJ0ID0gMFxcbiAgdGhpcy5zdHJpbmcgPSBzdHJpbmdcXG4gIHRoaXMudGFiU2l6ZSA9IHRhYlNpemUgfHwgOFxcbiAgdGhpcy5sYXN0Q29sdW1uUG9zID0gdGhpcy5sYXN0Q29sdW1uVmFsdWUgPSAwXFxuICB0aGlzLmxpbmVTdGFydCA9IDBcXG59XFxuXFxuU3RyaW5nU3RyZWFtLnByb3RvdHlwZSA9IHtcXG4gIGVvbDogZnVuY3Rpb24oKSB7cmV0dXJuIHRoaXMucG9zID49IHRoaXMuc3RyaW5nLmxlbmd0aH0sXFxuICBzb2w6IGZ1bmN0aW9uKCkge3JldHVybiB0aGlzLnBvcyA9PSB0aGlzLmxpbmVTdGFydH0sXFxuICBwZWVrOiBmdW5jdGlvbigpIHtyZXR1cm4gdGhpcy5zdHJpbmcuY2hhckF0KHRoaXMucG9zKSB8fCB1bmRlZmluZWR9LFxcbiAgbmV4dDogZnVuY3Rpb24oKSB7XFxuICAgIGlmICh0aGlzLnBvcyA8IHRoaXMuc3RyaW5nLmxlbmd0aClcXG4gICAgICB7IHJldHVybiB0aGlzLnN0cmluZy5jaGFyQXQodGhpcy5wb3MrKykgfVxcbiAgfSxcXG4gIGVhdDogZnVuY3Rpb24obWF0Y2gpIHtcXG4gICAgdmFyIGNoID0gdGhpcy5zdHJpbmcuY2hhckF0KHRoaXMucG9zKVxcbiAgICB2YXIgb2tcXG4gICAgaWYgKHR5cGVvZiBtYXRjaCA9PSBcXFwic3RyaW5nXFxcIikgeyBvayA9IGNoID09IG1hdGNoIH1cXG4gICAgZWxzZSB7IG9rID0gY2ggJiYgKG1hdGNoLnRlc3QgPyBtYXRjaC50ZXN0KGNoKSA6IG1hdGNoKGNoKSkgfVxcbiAgICBpZiAob2spIHsrK3RoaXMucG9zOyByZXR1cm4gY2h9XFxuICB9LFxcbiAgZWF0V2hpbGU6IGZ1bmN0aW9uKG1hdGNoKSB7XFxuICAgIHZhciBzdGFydCA9IHRoaXMucG9zXFxuICAgIHdoaWxlICh0aGlzLmVhdChtYXRjaCkpe31cXG4gICAgcmV0dXJuIHRoaXMucG9zID4gc3RhcnRcXG4gIH0sXFxuICBlYXRTcGFjZTogZnVuY3Rpb24oKSB7XFxuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xcblxcbiAgICB2YXIgc3RhcnQgPSB0aGlzLnBvc1xcbiAgICB3aGlsZSAoL1tcXFxcc1xcXFx1MDBhMF0vLnRlc3QodGhpcy5zdHJpbmcuY2hhckF0KHRoaXMucG9zKSkpIHsgKyt0aGlzJDEucG9zIH1cXG4gICAgcmV0dXJuIHRoaXMucG9zID4gc3RhcnRcXG4gIH0sXFxuICBza2lwVG9FbmQ6IGZ1bmN0aW9uKCkge3RoaXMucG9zID0gdGhpcy5zdHJpbmcubGVuZ3RofSxcXG4gIHNraXBUbzogZnVuY3Rpb24oY2gpIHtcXG4gICAgdmFyIGZvdW5kID0gdGhpcy5zdHJpbmcuaW5kZXhPZihjaCwgdGhpcy5wb3MpXFxuICAgIGlmIChmb3VuZCA+IC0xKSB7dGhpcy5wb3MgPSBmb3VuZDsgcmV0dXJuIHRydWV9XFxuICB9LFxcbiAgYmFja1VwOiBmdW5jdGlvbihuKSB7dGhpcy5wb3MgLT0gbn0sXFxuICBjb2x1bW46IGZ1bmN0aW9uKCkge1xcbiAgICBpZiAodGhpcy5sYXN0Q29sdW1uUG9zIDwgdGhpcy5zdGFydCkge1xcbiAgICAgIHRoaXMubGFzdENvbHVtblZhbHVlID0gY291bnRDb2x1bW4odGhpcy5zdHJpbmcsIHRoaXMuc3RhcnQsIHRoaXMudGFiU2l6ZSwgdGhpcy5sYXN0Q29sdW1uUG9zLCB0aGlzLmxhc3RDb2x1bW5WYWx1ZSlcXG4gICAgICB0aGlzLmxhc3RDb2x1bW5Qb3MgPSB0aGlzLnN0YXJ0XFxuICAgIH1cXG4gICAgcmV0dXJuIHRoaXMubGFzdENvbHVtblZhbHVlIC0gKHRoaXMubGluZVN0YXJ0ID8gY291bnRDb2x1bW4odGhpcy5zdHJpbmcsIHRoaXMubGluZVN0YXJ0LCB0aGlzLnRhYlNpemUpIDogMClcXG4gIH0sXFxuICBpbmRlbnRhdGlvbjogZnVuY3Rpb24oKSB7XFxuICAgIHJldHVybiBjb3VudENvbHVtbih0aGlzLnN0cmluZywgbnVsbCwgdGhpcy50YWJTaXplKSAtXFxuICAgICAgKHRoaXMubGluZVN0YXJ0ID8gY291bnRDb2x1bW4odGhpcy5zdHJpbmcsIHRoaXMubGluZVN0YXJ0LCB0aGlzLnRhYlNpemUpIDogMClcXG4gIH0sXFxuICBtYXRjaDogZnVuY3Rpb24ocGF0dGVybiwgY29uc3VtZSwgY2FzZUluc2Vuc2l0aXZlKSB7XFxuICAgIGlmICh0eXBlb2YgcGF0dGVybiA9PSBcXFwic3RyaW5nXFxcIikge1xcbiAgICAgIHZhciBjYXNlZCA9IGZ1bmN0aW9uIChzdHIpIHsgcmV0dXJuIGNhc2VJbnNlbnNpdGl2ZSA/IHN0ci50b0xvd2VyQ2FzZSgpIDogc3RyOyB9XFxuICAgICAgdmFyIHN1YnN0ciA9IHRoaXMuc3RyaW5nLnN1YnN0cih0aGlzLnBvcywgcGF0dGVybi5sZW5ndGgpXFxuICAgICAgaWYgKGNhc2VkKHN1YnN0cikgPT0gY2FzZWQocGF0dGVybikpIHtcXG4gICAgICAgIGlmIChjb25zdW1lICE9PSBmYWxzZSkgeyB0aGlzLnBvcyArPSBwYXR0ZXJuLmxlbmd0aCB9XFxuICAgICAgICByZXR1cm4gdHJ1ZVxcbiAgICAgIH1cXG4gICAgfSBlbHNlIHtcXG4gICAgICB2YXIgbWF0Y2ggPSB0aGlzLnN0cmluZy5zbGljZSh0aGlzLnBvcykubWF0Y2gocGF0dGVybilcXG4gICAgICBpZiAobWF0Y2ggJiYgbWF0Y2guaW5kZXggPiAwKSB7IHJldHVybiBudWxsIH1cXG4gICAgICBpZiAobWF0Y2ggJiYgY29uc3VtZSAhPT0gZmFsc2UpIHsgdGhpcy5wb3MgKz0gbWF0Y2hbMF0ubGVuZ3RoIH1cXG4gICAgICByZXR1cm4gbWF0Y2hcXG4gICAgfVxcbiAgfSxcXG4gIGN1cnJlbnQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuc3RyaW5nLnNsaWNlKHRoaXMuc3RhcnQsIHRoaXMucG9zKX0sXFxuICBoaWRlRmlyc3RDaGFyczogZnVuY3Rpb24obiwgaW5uZXIpIHtcXG4gICAgdGhpcy5saW5lU3RhcnQgKz0gblxcbiAgICB0cnkgeyByZXR1cm4gaW5uZXIoKSB9XFxuICAgIGZpbmFsbHkgeyB0aGlzLmxpbmVTdGFydCAtPSBuIH1cXG4gIH1cXG59XFxuXFxuLy8gQ29tcHV0ZSBhIHN0eWxlIGFycmF5IChhbiBhcnJheSBzdGFydGluZyB3aXRoIGEgbW9kZSBnZW5lcmF0aW9uXFxuLy8gLS0gZm9yIGludmFsaWRhdGlvbiAtLSBmb2xsb3dlZCBieSBwYWlycyBvZiBlbmQgcG9zaXRpb25zIGFuZFxcbi8vIHN0eWxlIHN0cmluZ3MpLCB3aGljaCBpcyB1c2VkIHRvIGhpZ2hsaWdodCB0aGUgdG9rZW5zIG9uIHRoZVxcbi8vIGxpbmUuXFxuZnVuY3Rpb24gaGlnaGxpZ2h0TGluZShjbSwgbGluZSwgc3RhdGUsIGZvcmNlVG9FbmQpIHtcXG4gIC8vIEEgc3R5bGVzIGFycmF5IGFsd2F5cyBzdGFydHMgd2l0aCBhIG51bWJlciBpZGVudGlmeWluZyB0aGVcXG4gIC8vIG1vZGUvb3ZlcmxheXMgdGhhdCBpdCBpcyBiYXNlZCBvbiAoZm9yIGVhc3kgaW52YWxpZGF0aW9uKS5cXG4gIHZhciBzdCA9IFtjbS5zdGF0ZS5tb2RlR2VuXSwgbGluZUNsYXNzZXMgPSB7fVxcbiAgLy8gQ29tcHV0ZSB0aGUgYmFzZSBhcnJheSBvZiBzdHlsZXNcXG4gIHJ1bk1vZGUoY20sIGxpbmUudGV4dCwgY20uZG9jLm1vZGUsIHN0YXRlLCBmdW5jdGlvbiAoZW5kLCBzdHlsZSkgeyByZXR1cm4gc3QucHVzaChlbmQsIHN0eWxlKTsgfSxcXG4gICAgbGluZUNsYXNzZXMsIGZvcmNlVG9FbmQpXFxuXFxuICAvLyBSdW4gb3ZlcmxheXMsIGFkanVzdCBzdHlsZSBhcnJheS5cXG4gIHZhciBsb29wID0gZnVuY3Rpb24gKCBvICkge1xcbiAgICB2YXIgb3ZlcmxheSA9IGNtLnN0YXRlLm92ZXJsYXlzW29dLCBpID0gMSwgYXQgPSAwXFxuICAgIHJ1bk1vZGUoY20sIGxpbmUudGV4dCwgb3ZlcmxheS5tb2RlLCB0cnVlLCBmdW5jdGlvbiAoZW5kLCBzdHlsZSkge1xcbiAgICAgIHZhciBzdGFydCA9IGlcXG4gICAgICAvLyBFbnN1cmUgdGhlcmUncyBhIHRva2VuIGVuZCBhdCB0aGUgY3VycmVudCBwb3NpdGlvbiwgYW5kIHRoYXQgaSBwb2ludHMgYXQgaXRcXG4gICAgICB3aGlsZSAoYXQgPCBlbmQpIHtcXG4gICAgICAgIHZhciBpX2VuZCA9IHN0W2ldXFxuICAgICAgICBpZiAoaV9lbmQgPiBlbmQpXFxuICAgICAgICAgIHsgc3Quc3BsaWNlKGksIDEsIGVuZCwgc3RbaSsxXSwgaV9lbmQpIH1cXG4gICAgICAgIGkgKz0gMlxcbiAgICAgICAgYXQgPSBNYXRoLm1pbihlbmQsIGlfZW5kKVxcbiAgICAgIH1cXG4gICAgICBpZiAoIXN0eWxlKSB7IHJldHVybiB9XFxuICAgICAgaWYgKG92ZXJsYXkub3BhcXVlKSB7XFxuICAgICAgICBzdC5zcGxpY2Uoc3RhcnQsIGkgLSBzdGFydCwgZW5kLCBcXFwib3ZlcmxheSBcXFwiICsgc3R5bGUpXFxuICAgICAgICBpID0gc3RhcnQgKyAyXFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIGZvciAoOyBzdGFydCA8IGk7IHN0YXJ0ICs9IDIpIHtcXG4gICAgICAgICAgdmFyIGN1ciA9IHN0W3N0YXJ0KzFdXFxuICAgICAgICAgIHN0W3N0YXJ0KzFdID0gKGN1ciA/IGN1ciArIFxcXCIgXFxcIiA6IFxcXCJcXFwiKSArIFxcXCJvdmVybGF5IFxcXCIgKyBzdHlsZVxcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgfSwgbGluZUNsYXNzZXMpXFxuICB9O1xcblxcbiAgZm9yICh2YXIgbyA9IDA7IG8gPCBjbS5zdGF0ZS5vdmVybGF5cy5sZW5ndGg7ICsrbykgbG9vcCggbyApO1xcblxcbiAgcmV0dXJuIHtzdHlsZXM6IHN0LCBjbGFzc2VzOiBsaW5lQ2xhc3Nlcy5iZ0NsYXNzIHx8IGxpbmVDbGFzc2VzLnRleHRDbGFzcyA/IGxpbmVDbGFzc2VzIDogbnVsbH1cXG59XFxuXFxuZnVuY3Rpb24gZ2V0TGluZVN0eWxlcyhjbSwgbGluZSwgdXBkYXRlRnJvbnRpZXIpIHtcXG4gIGlmICghbGluZS5zdHlsZXMgfHwgbGluZS5zdHlsZXNbMF0gIT0gY20uc3RhdGUubW9kZUdlbikge1xcbiAgICB2YXIgc3RhdGUgPSBnZXRTdGF0ZUJlZm9yZShjbSwgbGluZU5vKGxpbmUpKVxcbiAgICB2YXIgcmVzdWx0ID0gaGlnaGxpZ2h0TGluZShjbSwgbGluZSwgbGluZS50ZXh0Lmxlbmd0aCA+IGNtLm9wdGlvbnMubWF4SGlnaGxpZ2h0TGVuZ3RoID8gY29weVN0YXRlKGNtLmRvYy5tb2RlLCBzdGF0ZSkgOiBzdGF0ZSlcXG4gICAgbGluZS5zdGF0ZUFmdGVyID0gc3RhdGVcXG4gICAgbGluZS5zdHlsZXMgPSByZXN1bHQuc3R5bGVzXFxuICAgIGlmIChyZXN1bHQuY2xhc3NlcykgeyBsaW5lLnN0eWxlQ2xhc3NlcyA9IHJlc3VsdC5jbGFzc2VzIH1cXG4gICAgZWxzZSBpZiAobGluZS5zdHlsZUNsYXNzZXMpIHsgbGluZS5zdHlsZUNsYXNzZXMgPSBudWxsIH1cXG4gICAgaWYgKHVwZGF0ZUZyb250aWVyID09PSBjbS5kb2MuZnJvbnRpZXIpIHsgY20uZG9jLmZyb250aWVyKysgfVxcbiAgfVxcbiAgcmV0dXJuIGxpbmUuc3R5bGVzXFxufVxcblxcbmZ1bmN0aW9uIGdldFN0YXRlQmVmb3JlKGNtLCBuLCBwcmVjaXNlKSB7XFxuICB2YXIgZG9jID0gY20uZG9jLCBkaXNwbGF5ID0gY20uZGlzcGxheVxcbiAgaWYgKCFkb2MubW9kZS5zdGFydFN0YXRlKSB7IHJldHVybiB0cnVlIH1cXG4gIHZhciBwb3MgPSBmaW5kU3RhcnRMaW5lKGNtLCBuLCBwcmVjaXNlKSwgc3RhdGUgPSBwb3MgPiBkb2MuZmlyc3QgJiYgZ2V0TGluZShkb2MsIHBvcy0xKS5zdGF0ZUFmdGVyXFxuICBpZiAoIXN0YXRlKSB7IHN0YXRlID0gc3RhcnRTdGF0ZShkb2MubW9kZSkgfVxcbiAgZWxzZSB7IHN0YXRlID0gY29weVN0YXRlKGRvYy5tb2RlLCBzdGF0ZSkgfVxcbiAgZG9jLml0ZXIocG9zLCBuLCBmdW5jdGlvbiAobGluZSkge1xcbiAgICBwcm9jZXNzTGluZShjbSwgbGluZS50ZXh0LCBzdGF0ZSlcXG4gICAgdmFyIHNhdmUgPSBwb3MgPT0gbiAtIDEgfHwgcG9zICUgNSA9PSAwIHx8IHBvcyA+PSBkaXNwbGF5LnZpZXdGcm9tICYmIHBvcyA8IGRpc3BsYXkudmlld1RvXFxuICAgIGxpbmUuc3RhdGVBZnRlciA9IHNhdmUgPyBjb3B5U3RhdGUoZG9jLm1vZGUsIHN0YXRlKSA6IG51bGxcXG4gICAgKytwb3NcXG4gIH0pXFxuICBpZiAocHJlY2lzZSkgeyBkb2MuZnJvbnRpZXIgPSBwb3MgfVxcbiAgcmV0dXJuIHN0YXRlXFxufVxcblxcbi8vIExpZ2h0d2VpZ2h0IGZvcm0gb2YgaGlnaGxpZ2h0IC0tIHByb2NlZWQgb3ZlciB0aGlzIGxpbmUgYW5kXFxuLy8gdXBkYXRlIHN0YXRlLCBidXQgZG9uJ3Qgc2F2ZSBhIHN0eWxlIGFycmF5LiBVc2VkIGZvciBsaW5lcyB0aGF0XFxuLy8gYXJlbid0IGN1cnJlbnRseSB2aXNpYmxlLlxcbmZ1bmN0aW9uIHByb2Nlc3NMaW5lKGNtLCB0ZXh0LCBzdGF0ZSwgc3RhcnRBdCkge1xcbiAgdmFyIG1vZGUgPSBjbS5kb2MubW9kZVxcbiAgdmFyIHN0cmVhbSA9IG5ldyBTdHJpbmdTdHJlYW0odGV4dCwgY20ub3B0aW9ucy50YWJTaXplKVxcbiAgc3RyZWFtLnN0YXJ0ID0gc3RyZWFtLnBvcyA9IHN0YXJ0QXQgfHwgMFxcbiAgaWYgKHRleHQgPT0gXFxcIlxcXCIpIHsgY2FsbEJsYW5rTGluZShtb2RlLCBzdGF0ZSkgfVxcbiAgd2hpbGUgKCFzdHJlYW0uZW9sKCkpIHtcXG4gICAgcmVhZFRva2VuKG1vZGUsIHN0cmVhbSwgc3RhdGUpXFxuICAgIHN0cmVhbS5zdGFydCA9IHN0cmVhbS5wb3NcXG4gIH1cXG59XFxuXFxuZnVuY3Rpb24gY2FsbEJsYW5rTGluZShtb2RlLCBzdGF0ZSkge1xcbiAgaWYgKG1vZGUuYmxhbmtMaW5lKSB7IHJldHVybiBtb2RlLmJsYW5rTGluZShzdGF0ZSkgfVxcbiAgaWYgKCFtb2RlLmlubmVyTW9kZSkgeyByZXR1cm4gfVxcbiAgdmFyIGlubmVyID0gaW5uZXJNb2RlKG1vZGUsIHN0YXRlKVxcbiAgaWYgKGlubmVyLm1vZGUuYmxhbmtMaW5lKSB7IHJldHVybiBpbm5lci5tb2RlLmJsYW5rTGluZShpbm5lci5zdGF0ZSkgfVxcbn1cXG5cXG5mdW5jdGlvbiByZWFkVG9rZW4obW9kZSwgc3RyZWFtLCBzdGF0ZSwgaW5uZXIpIHtcXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgMTA7IGkrKykge1xcbiAgICBpZiAoaW5uZXIpIHsgaW5uZXJbMF0gPSBpbm5lck1vZGUobW9kZSwgc3RhdGUpLm1vZGUgfVxcbiAgICB2YXIgc3R5bGUgPSBtb2RlLnRva2VuKHN0cmVhbSwgc3RhdGUpXFxuICAgIGlmIChzdHJlYW0ucG9zID4gc3RyZWFtLnN0YXJ0KSB7IHJldHVybiBzdHlsZSB9XFxuICB9XFxuICB0aHJvdyBuZXcgRXJyb3IoXFxcIk1vZGUgXFxcIiArIG1vZGUubmFtZSArIFxcXCIgZmFpbGVkIHRvIGFkdmFuY2Ugc3RyZWFtLlxcXCIpXFxufVxcblxcbi8vIFV0aWxpdHkgZm9yIGdldFRva2VuQXQgYW5kIGdldExpbmVUb2tlbnNcXG5mdW5jdGlvbiB0YWtlVG9rZW4oY20sIHBvcywgcHJlY2lzZSwgYXNBcnJheSkge1xcbiAgdmFyIGdldE9iaiA9IGZ1bmN0aW9uIChjb3B5KSB7IHJldHVybiAoe1xcbiAgICBzdGFydDogc3RyZWFtLnN0YXJ0LCBlbmQ6IHN0cmVhbS5wb3MsXFxuICAgIHN0cmluZzogc3RyZWFtLmN1cnJlbnQoKSxcXG4gICAgdHlwZTogc3R5bGUgfHwgbnVsbCxcXG4gICAgc3RhdGU6IGNvcHkgPyBjb3B5U3RhdGUoZG9jLm1vZGUsIHN0YXRlKSA6IHN0YXRlXFxuICB9KTsgfVxcblxcbiAgdmFyIGRvYyA9IGNtLmRvYywgbW9kZSA9IGRvYy5tb2RlLCBzdHlsZVxcbiAgcG9zID0gY2xpcFBvcyhkb2MsIHBvcylcXG4gIHZhciBsaW5lID0gZ2V0TGluZShkb2MsIHBvcy5saW5lKSwgc3RhdGUgPSBnZXRTdGF0ZUJlZm9yZShjbSwgcG9zLmxpbmUsIHByZWNpc2UpXFxuICB2YXIgc3RyZWFtID0gbmV3IFN0cmluZ1N0cmVhbShsaW5lLnRleHQsIGNtLm9wdGlvbnMudGFiU2l6ZSksIHRva2Vuc1xcbiAgaWYgKGFzQXJyYXkpIHsgdG9rZW5zID0gW10gfVxcbiAgd2hpbGUgKChhc0FycmF5IHx8IHN0cmVhbS5wb3MgPCBwb3MuY2gpICYmICFzdHJlYW0uZW9sKCkpIHtcXG4gICAgc3RyZWFtLnN0YXJ0ID0gc3RyZWFtLnBvc1xcbiAgICBzdHlsZSA9IHJlYWRUb2tlbihtb2RlLCBzdHJlYW0sIHN0YXRlKVxcbiAgICBpZiAoYXNBcnJheSkgeyB0b2tlbnMucHVzaChnZXRPYmoodHJ1ZSkpIH1cXG4gIH1cXG4gIHJldHVybiBhc0FycmF5ID8gdG9rZW5zIDogZ2V0T2JqKClcXG59XFxuXFxuZnVuY3Rpb24gZXh0cmFjdExpbmVDbGFzc2VzKHR5cGUsIG91dHB1dCkge1xcbiAgaWYgKHR5cGUpIHsgZm9yICg7Oykge1xcbiAgICB2YXIgbGluZUNsYXNzID0gdHlwZS5tYXRjaCgvKD86XnxcXFxccyspbGluZS0oYmFja2dyb3VuZC0pPyhcXFxcUyspLylcXG4gICAgaWYgKCFsaW5lQ2xhc3MpIHsgYnJlYWsgfVxcbiAgICB0eXBlID0gdHlwZS5zbGljZSgwLCBsaW5lQ2xhc3MuaW5kZXgpICsgdHlwZS5zbGljZShsaW5lQ2xhc3MuaW5kZXggKyBsaW5lQ2xhc3NbMF0ubGVuZ3RoKVxcbiAgICB2YXIgcHJvcCA9IGxpbmVDbGFzc1sxXSA/IFxcXCJiZ0NsYXNzXFxcIiA6IFxcXCJ0ZXh0Q2xhc3NcXFwiXFxuICAgIGlmIChvdXRwdXRbcHJvcF0gPT0gbnVsbClcXG4gICAgICB7IG91dHB1dFtwcm9wXSA9IGxpbmVDbGFzc1syXSB9XFxuICAgIGVsc2UgaWYgKCEobmV3IFJlZ0V4cChcXFwiKD86XnxcXFxccylcXFwiICsgbGluZUNsYXNzWzJdICsgXFxcIig/OiR8XFxcXHMpXFxcIikpLnRlc3Qob3V0cHV0W3Byb3BdKSlcXG4gICAgICB7IG91dHB1dFtwcm9wXSArPSBcXFwiIFxcXCIgKyBsaW5lQ2xhc3NbMl0gfVxcbiAgfSB9XFxuICByZXR1cm4gdHlwZVxcbn1cXG5cXG4vLyBSdW4gdGhlIGdpdmVuIG1vZGUncyBwYXJzZXIgb3ZlciBhIGxpbmUsIGNhbGxpbmcgZiBmb3IgZWFjaCB0b2tlbi5cXG5mdW5jdGlvbiBydW5Nb2RlKGNtLCB0ZXh0LCBtb2RlLCBzdGF0ZSwgZiwgbGluZUNsYXNzZXMsIGZvcmNlVG9FbmQpIHtcXG4gIHZhciBmbGF0dGVuU3BhbnMgPSBtb2RlLmZsYXR0ZW5TcGFuc1xcbiAgaWYgKGZsYXR0ZW5TcGFucyA9PSBudWxsKSB7IGZsYXR0ZW5TcGFucyA9IGNtLm9wdGlvbnMuZmxhdHRlblNwYW5zIH1cXG4gIHZhciBjdXJTdGFydCA9IDAsIGN1clN0eWxlID0gbnVsbFxcbiAgdmFyIHN0cmVhbSA9IG5ldyBTdHJpbmdTdHJlYW0odGV4dCwgY20ub3B0aW9ucy50YWJTaXplKSwgc3R5bGVcXG4gIHZhciBpbm5lciA9IGNtLm9wdGlvbnMuYWRkTW9kZUNsYXNzICYmIFtudWxsXVxcbiAgaWYgKHRleHQgPT0gXFxcIlxcXCIpIHsgZXh0cmFjdExpbmVDbGFzc2VzKGNhbGxCbGFua0xpbmUobW9kZSwgc3RhdGUpLCBsaW5lQ2xhc3NlcykgfVxcbiAgd2hpbGUgKCFzdHJlYW0uZW9sKCkpIHtcXG4gICAgaWYgKHN0cmVhbS5wb3MgPiBjbS5vcHRpb25zLm1heEhpZ2hsaWdodExlbmd0aCkge1xcbiAgICAgIGZsYXR0ZW5TcGFucyA9IGZhbHNlXFxuICAgICAgaWYgKGZvcmNlVG9FbmQpIHsgcHJvY2Vzc0xpbmUoY20sIHRleHQsIHN0YXRlLCBzdHJlYW0ucG9zKSB9XFxuICAgICAgc3RyZWFtLnBvcyA9IHRleHQubGVuZ3RoXFxuICAgICAgc3R5bGUgPSBudWxsXFxuICAgIH0gZWxzZSB7XFxuICAgICAgc3R5bGUgPSBleHRyYWN0TGluZUNsYXNzZXMocmVhZFRva2VuKG1vZGUsIHN0cmVhbSwgc3RhdGUsIGlubmVyKSwgbGluZUNsYXNzZXMpXFxuICAgIH1cXG4gICAgaWYgKGlubmVyKSB7XFxuICAgICAgdmFyIG1OYW1lID0gaW5uZXJbMF0ubmFtZVxcbiAgICAgIGlmIChtTmFtZSkgeyBzdHlsZSA9IFxcXCJtLVxcXCIgKyAoc3R5bGUgPyBtTmFtZSArIFxcXCIgXFxcIiArIHN0eWxlIDogbU5hbWUpIH1cXG4gICAgfVxcbiAgICBpZiAoIWZsYXR0ZW5TcGFucyB8fCBjdXJTdHlsZSAhPSBzdHlsZSkge1xcbiAgICAgIHdoaWxlIChjdXJTdGFydCA8IHN0cmVhbS5zdGFydCkge1xcbiAgICAgICAgY3VyU3RhcnQgPSBNYXRoLm1pbihzdHJlYW0uc3RhcnQsIGN1clN0YXJ0ICsgNTAwMClcXG4gICAgICAgIGYoY3VyU3RhcnQsIGN1clN0eWxlKVxcbiAgICAgIH1cXG4gICAgICBjdXJTdHlsZSA9IHN0eWxlXFxuICAgIH1cXG4gICAgc3RyZWFtLnN0YXJ0ID0gc3RyZWFtLnBvc1xcbiAgfVxcbiAgd2hpbGUgKGN1clN0YXJ0IDwgc3RyZWFtLnBvcykge1xcbiAgICAvLyBXZWJraXQgc2VlbXMgdG8gcmVmdXNlIHRvIHJlbmRlciB0ZXh0IG5vZGVzIGxvbmdlciB0aGFuIDU3NDQ0XFxuICAgIC8vIGNoYXJhY3RlcnMsIGFuZCByZXR1cm5zIGluYWNjdXJhdGUgbWVhc3VyZW1lbnRzIGluIG5vZGVzXFxuICAgIC8vIHN0YXJ0aW5nIGFyb3VuZCA1MDAwIGNoYXJzLlxcbiAgICB2YXIgcG9zID0gTWF0aC5taW4oc3RyZWFtLnBvcywgY3VyU3RhcnQgKyA1MDAwKVxcbiAgICBmKHBvcywgY3VyU3R5bGUpXFxuICAgIGN1clN0YXJ0ID0gcG9zXFxuICB9XFxufVxcblxcbi8vIEZpbmRzIHRoZSBsaW5lIHRvIHN0YXJ0IHdpdGggd2hlbiBzdGFydGluZyBhIHBhcnNlLiBUcmllcyB0b1xcbi8vIGZpbmQgYSBsaW5lIHdpdGggYSBzdGF0ZUFmdGVyLCBzbyB0aGF0IGl0IGNhbiBzdGFydCB3aXRoIGFcXG4vLyB2YWxpZCBzdGF0ZS4gSWYgdGhhdCBmYWlscywgaXQgcmV0dXJucyB0aGUgbGluZSB3aXRoIHRoZVxcbi8vIHNtYWxsZXN0IGluZGVudGF0aW9uLCB3aGljaCB0ZW5kcyB0byBuZWVkIHRoZSBsZWFzdCBjb250ZXh0IHRvXFxuLy8gcGFyc2UgY29ycmVjdGx5LlxcbmZ1bmN0aW9uIGZpbmRTdGFydExpbmUoY20sIG4sIHByZWNpc2UpIHtcXG4gIHZhciBtaW5pbmRlbnQsIG1pbmxpbmUsIGRvYyA9IGNtLmRvY1xcbiAgdmFyIGxpbSA9IHByZWNpc2UgPyAtMSA6IG4gLSAoY20uZG9jLm1vZGUuaW5uZXJNb2RlID8gMTAwMCA6IDEwMClcXG4gIGZvciAodmFyIHNlYXJjaCA9IG47IHNlYXJjaCA+IGxpbTsgLS1zZWFyY2gpIHtcXG4gICAgaWYgKHNlYXJjaCA8PSBkb2MuZmlyc3QpIHsgcmV0dXJuIGRvYy5maXJzdCB9XFxuICAgIHZhciBsaW5lID0gZ2V0TGluZShkb2MsIHNlYXJjaCAtIDEpXFxuICAgIGlmIChsaW5lLnN0YXRlQWZ0ZXIgJiYgKCFwcmVjaXNlIHx8IHNlYXJjaCA8PSBkb2MuZnJvbnRpZXIpKSB7IHJldHVybiBzZWFyY2ggfVxcbiAgICB2YXIgaW5kZW50ZWQgPSBjb3VudENvbHVtbihsaW5lLnRleHQsIG51bGwsIGNtLm9wdGlvbnMudGFiU2l6ZSlcXG4gICAgaWYgKG1pbmxpbmUgPT0gbnVsbCB8fCBtaW5pbmRlbnQgPiBpbmRlbnRlZCkge1xcbiAgICAgIG1pbmxpbmUgPSBzZWFyY2ggLSAxXFxuICAgICAgbWluaW5kZW50ID0gaW5kZW50ZWRcXG4gICAgfVxcbiAgfVxcbiAgcmV0dXJuIG1pbmxpbmVcXG59XFxuXFxuLy8gTElORSBEQVRBIFNUUlVDVFVSRVxcblxcbi8vIExpbmUgb2JqZWN0cy4gVGhlc2UgaG9sZCBzdGF0ZSByZWxhdGVkIHRvIGEgbGluZSwgaW5jbHVkaW5nXFxuLy8gaGlnaGxpZ2h0aW5nIGluZm8gKHRoZSBzdHlsZXMgYXJyYXkpLlxcbmZ1bmN0aW9uIExpbmUodGV4dCwgbWFya2VkU3BhbnMsIGVzdGltYXRlSGVpZ2h0KSB7XFxuICB0aGlzLnRleHQgPSB0ZXh0XFxuICBhdHRhY2hNYXJrZWRTcGFucyh0aGlzLCBtYXJrZWRTcGFucylcXG4gIHRoaXMuaGVpZ2h0ID0gZXN0aW1hdGVIZWlnaHQgPyBlc3RpbWF0ZUhlaWdodCh0aGlzKSA6IDFcXG59XFxuZXZlbnRNaXhpbihMaW5lKVxcbkxpbmUucHJvdG90eXBlLmxpbmVObyA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gbGluZU5vKHRoaXMpIH1cXG5cXG4vLyBDaGFuZ2UgdGhlIGNvbnRlbnQgKHRleHQsIG1hcmtlcnMpIG9mIGEgbGluZS4gQXV0b21hdGljYWxseVxcbi8vIGludmFsaWRhdGVzIGNhY2hlZCBpbmZvcm1hdGlvbiBhbmQgdHJpZXMgdG8gcmUtZXN0aW1hdGUgdGhlXFxuLy8gbGluZSdzIGhlaWdodC5cXG5mdW5jdGlvbiB1cGRhdGVMaW5lKGxpbmUsIHRleHQsIG1hcmtlZFNwYW5zLCBlc3RpbWF0ZUhlaWdodCkge1xcbiAgbGluZS50ZXh0ID0gdGV4dFxcbiAgaWYgKGxpbmUuc3RhdGVBZnRlcikgeyBsaW5lLnN0YXRlQWZ0ZXIgPSBudWxsIH1cXG4gIGlmIChsaW5lLnN0eWxlcykgeyBsaW5lLnN0eWxlcyA9IG51bGwgfVxcbiAgaWYgKGxpbmUub3JkZXIgIT0gbnVsbCkgeyBsaW5lLm9yZGVyID0gbnVsbCB9XFxuICBkZXRhY2hNYXJrZWRTcGFucyhsaW5lKVxcbiAgYXR0YWNoTWFya2VkU3BhbnMobGluZSwgbWFya2VkU3BhbnMpXFxuICB2YXIgZXN0SGVpZ2h0ID0gZXN0aW1hdGVIZWlnaHQgPyBlc3RpbWF0ZUhlaWdodChsaW5lKSA6IDFcXG4gIGlmIChlc3RIZWlnaHQgIT0gbGluZS5oZWlnaHQpIHsgdXBkYXRlTGluZUhlaWdodChsaW5lLCBlc3RIZWlnaHQpIH1cXG59XFxuXFxuLy8gRGV0YWNoIGEgbGluZSBmcm9tIHRoZSBkb2N1bWVudCB0cmVlIGFuZCBpdHMgbWFya2Vycy5cXG5mdW5jdGlvbiBjbGVhblVwTGluZShsaW5lKSB7XFxuICBsaW5lLnBhcmVudCA9IG51bGxcXG4gIGRldGFjaE1hcmtlZFNwYW5zKGxpbmUpXFxufVxcblxcbi8vIENvbnZlcnQgYSBzdHlsZSBhcyByZXR1cm5lZCBieSBhIG1vZGUgKGVpdGhlciBudWxsLCBvciBhIHN0cmluZ1xcbi8vIGNvbnRhaW5pbmcgb25lIG9yIG1vcmUgc3R5bGVzKSB0byBhIENTUyBzdHlsZS4gVGhpcyBpcyBjYWNoZWQsXFxuLy8gYW5kIGFsc28gbG9va3MgZm9yIGxpbmUtd2lkZSBzdHlsZXMuXFxudmFyIHN0eWxlVG9DbGFzc0NhY2hlID0ge307XFxudmFyIHN0eWxlVG9DbGFzc0NhY2hlV2l0aE1vZGUgPSB7fTtcXG5mdW5jdGlvbiBpbnRlcnByZXRUb2tlblN0eWxlKHN0eWxlLCBvcHRpb25zKSB7XFxuICBpZiAoIXN0eWxlIHx8IC9eXFxcXHMqJC8udGVzdChzdHlsZSkpIHsgcmV0dXJuIG51bGwgfVxcbiAgdmFyIGNhY2hlID0gb3B0aW9ucy5hZGRNb2RlQ2xhc3MgPyBzdHlsZVRvQ2xhc3NDYWNoZVdpdGhNb2RlIDogc3R5bGVUb0NsYXNzQ2FjaGVcXG4gIHJldHVybiBjYWNoZVtzdHlsZV0gfHxcXG4gICAgKGNhY2hlW3N0eWxlXSA9IHN0eWxlLnJlcGxhY2UoL1xcXFxTKy9nLCBcXFwiY20tJCZcXFwiKSlcXG59XFxuXFxuLy8gUmVuZGVyIHRoZSBET00gcmVwcmVzZW50YXRpb24gb2YgdGhlIHRleHQgb2YgYSBsaW5lLiBBbHNvIGJ1aWxkc1xcbi8vIHVwIGEgJ2xpbmUgbWFwJywgd2hpY2ggcG9pbnRzIGF0IHRoZSBET00gbm9kZXMgdGhhdCByZXByZXNlbnRcXG4vLyBzcGVjaWZpYyBzdHJldGNoZXMgb2YgdGV4dCwgYW5kIGlzIHVzZWQgYnkgdGhlIG1lYXN1cmluZyBjb2RlLlxcbi8vIFRoZSByZXR1cm5lZCBvYmplY3QgY29udGFpbnMgdGhlIERPTSBub2RlLCB0aGlzIG1hcCwgYW5kXFxuLy8gaW5mb3JtYXRpb24gYWJvdXQgbGluZS13aWRlIHN0eWxlcyB0aGF0IHdlcmUgc2V0IGJ5IHRoZSBtb2RlLlxcbmZ1bmN0aW9uIGJ1aWxkTGluZUNvbnRlbnQoY20sIGxpbmVWaWV3KSB7XFxuICAvLyBUaGUgcGFkZGluZy1yaWdodCBmb3JjZXMgdGhlIGVsZW1lbnQgdG8gaGF2ZSBhICdib3JkZXInLCB3aGljaFxcbiAgLy8gaXMgbmVlZGVkIG9uIFdlYmtpdCB0byBiZSBhYmxlIHRvIGdldCBsaW5lLWxldmVsIGJvdW5kaW5nXFxuICAvLyByZWN0YW5nbGVzIGZvciBpdCAoaW4gbWVhc3VyZUNoYXIpLlxcbiAgdmFyIGNvbnRlbnQgPSBlbHQoXFxcInNwYW5cXFwiLCBudWxsLCBudWxsLCB3ZWJraXQgPyBcXFwicGFkZGluZy1yaWdodDogLjFweFxcXCIgOiBudWxsKVxcbiAgdmFyIGJ1aWxkZXIgPSB7cHJlOiBlbHQoXFxcInByZVxcXCIsIFtjb250ZW50XSwgXFxcIkNvZGVNaXJyb3ItbGluZVxcXCIpLCBjb250ZW50OiBjb250ZW50LFxcbiAgICAgICAgICAgICAgICAgY29sOiAwLCBwb3M6IDAsIGNtOiBjbSxcXG4gICAgICAgICAgICAgICAgIHRyYWlsaW5nU3BhY2U6IGZhbHNlLFxcbiAgICAgICAgICAgICAgICAgc3BsaXRTcGFjZXM6IChpZSB8fCB3ZWJraXQpICYmIGNtLmdldE9wdGlvbihcXFwibGluZVdyYXBwaW5nXFxcIil9XFxuICBsaW5lVmlldy5tZWFzdXJlID0ge31cXG5cXG4gIC8vIEl0ZXJhdGUgb3ZlciB0aGUgbG9naWNhbCBsaW5lcyB0aGF0IG1ha2UgdXAgdGhpcyB2aXN1YWwgbGluZS5cXG4gIGZvciAodmFyIGkgPSAwOyBpIDw9IChsaW5lVmlldy5yZXN0ID8gbGluZVZpZXcucmVzdC5sZW5ndGggOiAwKTsgaSsrKSB7XFxuICAgIHZhciBsaW5lID0gaSA/IGxpbmVWaWV3LnJlc3RbaSAtIDFdIDogbGluZVZpZXcubGluZSwgb3JkZXIgPSB2b2lkIDBcXG4gICAgYnVpbGRlci5wb3MgPSAwXFxuICAgIGJ1aWxkZXIuYWRkVG9rZW4gPSBidWlsZFRva2VuXFxuICAgIC8vIE9wdGlvbmFsbHkgd2lyZSBpbiBzb21lIGhhY2tzIGludG8gdGhlIHRva2VuLXJlbmRlcmluZ1xcbiAgICAvLyBhbGdvcml0aG0sIHRvIGRlYWwgd2l0aCBicm93c2VyIHF1aXJrcy5cXG4gICAgaWYgKGhhc0JhZEJpZGlSZWN0cyhjbS5kaXNwbGF5Lm1lYXN1cmUpICYmIChvcmRlciA9IGdldE9yZGVyKGxpbmUpKSlcXG4gICAgICB7IGJ1aWxkZXIuYWRkVG9rZW4gPSBidWlsZFRva2VuQmFkQmlkaShidWlsZGVyLmFkZFRva2VuLCBvcmRlcikgfVxcbiAgICBidWlsZGVyLm1hcCA9IFtdXFxuICAgIHZhciBhbGxvd0Zyb250aWVyVXBkYXRlID0gbGluZVZpZXcgIT0gY20uZGlzcGxheS5leHRlcm5hbE1lYXN1cmVkICYmIGxpbmVObyhsaW5lKVxcbiAgICBpbnNlcnRMaW5lQ29udGVudChsaW5lLCBidWlsZGVyLCBnZXRMaW5lU3R5bGVzKGNtLCBsaW5lLCBhbGxvd0Zyb250aWVyVXBkYXRlKSlcXG4gICAgaWYgKGxpbmUuc3R5bGVDbGFzc2VzKSB7XFxuICAgICAgaWYgKGxpbmUuc3R5bGVDbGFzc2VzLmJnQ2xhc3MpXFxuICAgICAgICB7IGJ1aWxkZXIuYmdDbGFzcyA9IGpvaW5DbGFzc2VzKGxpbmUuc3R5bGVDbGFzc2VzLmJnQ2xhc3MsIGJ1aWxkZXIuYmdDbGFzcyB8fCBcXFwiXFxcIikgfVxcbiAgICAgIGlmIChsaW5lLnN0eWxlQ2xhc3Nlcy50ZXh0Q2xhc3MpXFxuICAgICAgICB7IGJ1aWxkZXIudGV4dENsYXNzID0gam9pbkNsYXNzZXMobGluZS5zdHlsZUNsYXNzZXMudGV4dENsYXNzLCBidWlsZGVyLnRleHRDbGFzcyB8fCBcXFwiXFxcIikgfVxcbiAgICB9XFxuXFxuICAgIC8vIEVuc3VyZSBhdCBsZWFzdCBhIHNpbmdsZSBub2RlIGlzIHByZXNlbnQsIGZvciBtZWFzdXJpbmcuXFxuICAgIGlmIChidWlsZGVyLm1hcC5sZW5ndGggPT0gMClcXG4gICAgICB7IGJ1aWxkZXIubWFwLnB1c2goMCwgMCwgYnVpbGRlci5jb250ZW50LmFwcGVuZENoaWxkKHplcm9XaWR0aEVsZW1lbnQoY20uZGlzcGxheS5tZWFzdXJlKSkpIH1cXG5cXG4gICAgLy8gU3RvcmUgdGhlIG1hcCBhbmQgYSBjYWNoZSBvYmplY3QgZm9yIHRoZSBjdXJyZW50IGxvZ2ljYWwgbGluZVxcbiAgICBpZiAoaSA9PSAwKSB7XFxuICAgICAgbGluZVZpZXcubWVhc3VyZS5tYXAgPSBidWlsZGVyLm1hcFxcbiAgICAgIGxpbmVWaWV3Lm1lYXN1cmUuY2FjaGUgPSB7fVxcbiAgICB9IGVsc2Uge1xcbiAgICAgIDsobGluZVZpZXcubWVhc3VyZS5tYXBzIHx8IChsaW5lVmlldy5tZWFzdXJlLm1hcHMgPSBbXSkpLnB1c2goYnVpbGRlci5tYXApXFxuICAgICAgOyhsaW5lVmlldy5tZWFzdXJlLmNhY2hlcyB8fCAobGluZVZpZXcubWVhc3VyZS5jYWNoZXMgPSBbXSkpLnB1c2goe30pXFxuICAgIH1cXG4gIH1cXG5cXG4gIC8vIFNlZSBpc3N1ZSAjMjkwMVxcbiAgaWYgKHdlYmtpdCkge1xcbiAgICB2YXIgbGFzdCA9IGJ1aWxkZXIuY29udGVudC5sYXN0Q2hpbGRcXG4gICAgaWYgKC9cXFxcYmNtLXRhYlxcXFxiLy50ZXN0KGxhc3QuY2xhc3NOYW1lKSB8fCAobGFzdC5xdWVyeVNlbGVjdG9yICYmIGxhc3QucXVlcnlTZWxlY3RvcihcXFwiLmNtLXRhYlxcXCIpKSlcXG4gICAgICB7IGJ1aWxkZXIuY29udGVudC5jbGFzc05hbWUgPSBcXFwiY20tdGFiLXdyYXAtaGFja1xcXCIgfVxcbiAgfVxcblxcbiAgc2lnbmFsKGNtLCBcXFwicmVuZGVyTGluZVxcXCIsIGNtLCBsaW5lVmlldy5saW5lLCBidWlsZGVyLnByZSlcXG4gIGlmIChidWlsZGVyLnByZS5jbGFzc05hbWUpXFxuICAgIHsgYnVpbGRlci50ZXh0Q2xhc3MgPSBqb2luQ2xhc3NlcyhidWlsZGVyLnByZS5jbGFzc05hbWUsIGJ1aWxkZXIudGV4dENsYXNzIHx8IFxcXCJcXFwiKSB9XFxuXFxuICByZXR1cm4gYnVpbGRlclxcbn1cXG5cXG5mdW5jdGlvbiBkZWZhdWx0U3BlY2lhbENoYXJQbGFjZWhvbGRlcihjaCkge1xcbiAgdmFyIHRva2VuID0gZWx0KFxcXCJzcGFuXFxcIiwgXFxcIlxcXFx1MjAyMlxcXCIsIFxcXCJjbS1pbnZhbGlkY2hhclxcXCIpXFxuICB0b2tlbi50aXRsZSA9IFxcXCJcXFxcXFxcXHVcXFwiICsgY2guY2hhckNvZGVBdCgwKS50b1N0cmluZygxNilcXG4gIHRva2VuLnNldEF0dHJpYnV0ZShcXFwiYXJpYS1sYWJlbFxcXCIsIHRva2VuLnRpdGxlKVxcbiAgcmV0dXJuIHRva2VuXFxufVxcblxcbi8vIEJ1aWxkIHVwIHRoZSBET00gcmVwcmVzZW50YXRpb24gZm9yIGEgc2luZ2xlIHRva2VuLCBhbmQgYWRkIGl0IHRvXFxuLy8gdGhlIGxpbmUgbWFwLiBUYWtlcyBjYXJlIHRvIHJlbmRlciBzcGVjaWFsIGNoYXJhY3RlcnMgc2VwYXJhdGVseS5cXG5mdW5jdGlvbiBidWlsZFRva2VuKGJ1aWxkZXIsIHRleHQsIHN0eWxlLCBzdGFydFN0eWxlLCBlbmRTdHlsZSwgdGl0bGUsIGNzcykge1xcbiAgaWYgKCF0ZXh0KSB7IHJldHVybiB9XFxuICB2YXIgZGlzcGxheVRleHQgPSBidWlsZGVyLnNwbGl0U3BhY2VzID8gc3BsaXRTcGFjZXModGV4dCwgYnVpbGRlci50cmFpbGluZ1NwYWNlKSA6IHRleHRcXG4gIHZhciBzcGVjaWFsID0gYnVpbGRlci5jbS5zdGF0ZS5zcGVjaWFsQ2hhcnMsIG11c3RXcmFwID0gZmFsc2VcXG4gIHZhciBjb250ZW50XFxuICBpZiAoIXNwZWNpYWwudGVzdCh0ZXh0KSkge1xcbiAgICBidWlsZGVyLmNvbCArPSB0ZXh0Lmxlbmd0aFxcbiAgICBjb250ZW50ID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoZGlzcGxheVRleHQpXFxuICAgIGJ1aWxkZXIubWFwLnB1c2goYnVpbGRlci5wb3MsIGJ1aWxkZXIucG9zICsgdGV4dC5sZW5ndGgsIGNvbnRlbnQpXFxuICAgIGlmIChpZSAmJiBpZV92ZXJzaW9uIDwgOSkgeyBtdXN0V3JhcCA9IHRydWUgfVxcbiAgICBidWlsZGVyLnBvcyArPSB0ZXh0Lmxlbmd0aFxcbiAgfSBlbHNlIHtcXG4gICAgY29udGVudCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKVxcbiAgICB2YXIgcG9zID0gMFxcbiAgICB3aGlsZSAodHJ1ZSkge1xcbiAgICAgIHNwZWNpYWwubGFzdEluZGV4ID0gcG9zXFxuICAgICAgdmFyIG0gPSBzcGVjaWFsLmV4ZWModGV4dClcXG4gICAgICB2YXIgc2tpcHBlZCA9IG0gPyBtLmluZGV4IC0gcG9zIDogdGV4dC5sZW5ndGggLSBwb3NcXG4gICAgICBpZiAoc2tpcHBlZCkge1xcbiAgICAgICAgdmFyIHR4dCA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGRpc3BsYXlUZXh0LnNsaWNlKHBvcywgcG9zICsgc2tpcHBlZCkpXFxuICAgICAgICBpZiAoaWUgJiYgaWVfdmVyc2lvbiA8IDkpIHsgY29udGVudC5hcHBlbmRDaGlsZChlbHQoXFxcInNwYW5cXFwiLCBbdHh0XSkpIH1cXG4gICAgICAgIGVsc2UgeyBjb250ZW50LmFwcGVuZENoaWxkKHR4dCkgfVxcbiAgICAgICAgYnVpbGRlci5tYXAucHVzaChidWlsZGVyLnBvcywgYnVpbGRlci5wb3MgKyBza2lwcGVkLCB0eHQpXFxuICAgICAgICBidWlsZGVyLmNvbCArPSBza2lwcGVkXFxuICAgICAgICBidWlsZGVyLnBvcyArPSBza2lwcGVkXFxuICAgICAgfVxcbiAgICAgIGlmICghbSkgeyBicmVhayB9XFxuICAgICAgcG9zICs9IHNraXBwZWQgKyAxXFxuICAgICAgdmFyIHR4dCQxID0gdm9pZCAwXFxuICAgICAgaWYgKG1bMF0gPT0gXFxcIlxcXFx0XFxcIikge1xcbiAgICAgICAgdmFyIHRhYlNpemUgPSBidWlsZGVyLmNtLm9wdGlvbnMudGFiU2l6ZSwgdGFiV2lkdGggPSB0YWJTaXplIC0gYnVpbGRlci5jb2wgJSB0YWJTaXplXFxuICAgICAgICB0eHQkMSA9IGNvbnRlbnQuYXBwZW5kQ2hpbGQoZWx0KFxcXCJzcGFuXFxcIiwgc3BhY2VTdHIodGFiV2lkdGgpLCBcXFwiY20tdGFiXFxcIikpXFxuICAgICAgICB0eHQkMS5zZXRBdHRyaWJ1dGUoXFxcInJvbGVcXFwiLCBcXFwicHJlc2VudGF0aW9uXFxcIilcXG4gICAgICAgIHR4dCQxLnNldEF0dHJpYnV0ZShcXFwiY20tdGV4dFxcXCIsIFxcXCJcXFxcdFxcXCIpXFxuICAgICAgICBidWlsZGVyLmNvbCArPSB0YWJXaWR0aFxcbiAgICAgIH0gZWxzZSBpZiAobVswXSA9PSBcXFwiXFxcXHJcXFwiIHx8IG1bMF0gPT0gXFxcIlxcXFxuXFxcIikge1xcbiAgICAgICAgdHh0JDEgPSBjb250ZW50LmFwcGVuZENoaWxkKGVsdChcXFwic3BhblxcXCIsIG1bMF0gPT0gXFxcIlxcXFxyXFxcIiA/IFxcXCJcXFxcdTI0MGRcXFwiIDogXFxcIlxcXFx1MjQyNFxcXCIsIFxcXCJjbS1pbnZhbGlkY2hhclxcXCIpKVxcbiAgICAgICAgdHh0JDEuc2V0QXR0cmlidXRlKFxcXCJjbS10ZXh0XFxcIiwgbVswXSlcXG4gICAgICAgIGJ1aWxkZXIuY29sICs9IDFcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgdHh0JDEgPSBidWlsZGVyLmNtLm9wdGlvbnMuc3BlY2lhbENoYXJQbGFjZWhvbGRlcihtWzBdKVxcbiAgICAgICAgdHh0JDEuc2V0QXR0cmlidXRlKFxcXCJjbS10ZXh0XFxcIiwgbVswXSlcXG4gICAgICAgIGlmIChpZSAmJiBpZV92ZXJzaW9uIDwgOSkgeyBjb250ZW50LmFwcGVuZENoaWxkKGVsdChcXFwic3BhblxcXCIsIFt0eHQkMV0pKSB9XFxuICAgICAgICBlbHNlIHsgY29udGVudC5hcHBlbmRDaGlsZCh0eHQkMSkgfVxcbiAgICAgICAgYnVpbGRlci5jb2wgKz0gMVxcbiAgICAgIH1cXG4gICAgICBidWlsZGVyLm1hcC5wdXNoKGJ1aWxkZXIucG9zLCBidWlsZGVyLnBvcyArIDEsIHR4dCQxKVxcbiAgICAgIGJ1aWxkZXIucG9zKytcXG4gICAgfVxcbiAgfVxcbiAgYnVpbGRlci50cmFpbGluZ1NwYWNlID0gZGlzcGxheVRleHQuY2hhckNvZGVBdCh0ZXh0Lmxlbmd0aCAtIDEpID09IDMyXFxuICBpZiAoc3R5bGUgfHwgc3RhcnRTdHlsZSB8fCBlbmRTdHlsZSB8fCBtdXN0V3JhcCB8fCBjc3MpIHtcXG4gICAgdmFyIGZ1bGxTdHlsZSA9IHN0eWxlIHx8IFxcXCJcXFwiXFxuICAgIGlmIChzdGFydFN0eWxlKSB7IGZ1bGxTdHlsZSArPSBzdGFydFN0eWxlIH1cXG4gICAgaWYgKGVuZFN0eWxlKSB7IGZ1bGxTdHlsZSArPSBlbmRTdHlsZSB9XFxuICAgIHZhciB0b2tlbiA9IGVsdChcXFwic3BhblxcXCIsIFtjb250ZW50XSwgZnVsbFN0eWxlLCBjc3MpXFxuICAgIGlmICh0aXRsZSkgeyB0b2tlbi50aXRsZSA9IHRpdGxlIH1cXG4gICAgcmV0dXJuIGJ1aWxkZXIuY29udGVudC5hcHBlbmRDaGlsZCh0b2tlbilcXG4gIH1cXG4gIGJ1aWxkZXIuY29udGVudC5hcHBlbmRDaGlsZChjb250ZW50KVxcbn1cXG5cXG5mdW5jdGlvbiBzcGxpdFNwYWNlcyh0ZXh0LCB0cmFpbGluZ0JlZm9yZSkge1xcbiAgaWYgKHRleHQubGVuZ3RoID4gMSAmJiAhLyAgLy50ZXN0KHRleHQpKSB7IHJldHVybiB0ZXh0IH1cXG4gIHZhciBzcGFjZUJlZm9yZSA9IHRyYWlsaW5nQmVmb3JlLCByZXN1bHQgPSBcXFwiXFxcIlxcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0ZXh0Lmxlbmd0aDsgaSsrKSB7XFxuICAgIHZhciBjaCA9IHRleHQuY2hhckF0KGkpXFxuICAgIGlmIChjaCA9PSBcXFwiIFxcXCIgJiYgc3BhY2VCZWZvcmUgJiYgKGkgPT0gdGV4dC5sZW5ndGggLSAxIHx8IHRleHQuY2hhckNvZGVBdChpICsgMSkgPT0gMzIpKVxcbiAgICAgIHsgY2ggPSBcXFwiXFxcXHUwMGEwXFxcIiB9XFxuICAgIHJlc3VsdCArPSBjaFxcbiAgICBzcGFjZUJlZm9yZSA9IGNoID09IFxcXCIgXFxcIlxcbiAgfVxcbiAgcmV0dXJuIHJlc3VsdFxcbn1cXG5cXG4vLyBXb3JrIGFyb3VuZCBub25zZW5zZSBkaW1lbnNpb25zIGJlaW5nIHJlcG9ydGVkIGZvciBzdHJldGNoZXMgb2ZcXG4vLyByaWdodC10by1sZWZ0IHRleHQuXFxuZnVuY3Rpb24gYnVpbGRUb2tlbkJhZEJpZGkoaW5uZXIsIG9yZGVyKSB7XFxuICByZXR1cm4gZnVuY3Rpb24gKGJ1aWxkZXIsIHRleHQsIHN0eWxlLCBzdGFydFN0eWxlLCBlbmRTdHlsZSwgdGl0bGUsIGNzcykge1xcbiAgICBzdHlsZSA9IHN0eWxlID8gc3R5bGUgKyBcXFwiIGNtLWZvcmNlLWJvcmRlclxcXCIgOiBcXFwiY20tZm9yY2UtYm9yZGVyXFxcIlxcbiAgICB2YXIgc3RhcnQgPSBidWlsZGVyLnBvcywgZW5kID0gc3RhcnQgKyB0ZXh0Lmxlbmd0aFxcbiAgICBmb3IgKDs7KSB7XFxuICAgICAgLy8gRmluZCB0aGUgcGFydCB0aGF0IG92ZXJsYXBzIHdpdGggdGhlIHN0YXJ0IG9mIHRoaXMgdGV4dFxcbiAgICAgIHZhciBwYXJ0ID0gdm9pZCAwXFxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcmRlci5sZW5ndGg7IGkrKykge1xcbiAgICAgICAgcGFydCA9IG9yZGVyW2ldXFxuICAgICAgICBpZiAocGFydC50byA+IHN0YXJ0ICYmIHBhcnQuZnJvbSA8PSBzdGFydCkgeyBicmVhayB9XFxuICAgICAgfVxcbiAgICAgIGlmIChwYXJ0LnRvID49IGVuZCkgeyByZXR1cm4gaW5uZXIoYnVpbGRlciwgdGV4dCwgc3R5bGUsIHN0YXJ0U3R5bGUsIGVuZFN0eWxlLCB0aXRsZSwgY3NzKSB9XFxuICAgICAgaW5uZXIoYnVpbGRlciwgdGV4dC5zbGljZSgwLCBwYXJ0LnRvIC0gc3RhcnQpLCBzdHlsZSwgc3RhcnRTdHlsZSwgbnVsbCwgdGl0bGUsIGNzcylcXG4gICAgICBzdGFydFN0eWxlID0gbnVsbFxcbiAgICAgIHRleHQgPSB0ZXh0LnNsaWNlKHBhcnQudG8gLSBzdGFydClcXG4gICAgICBzdGFydCA9IHBhcnQudG9cXG4gICAgfVxcbiAgfVxcbn1cXG5cXG5mdW5jdGlvbiBidWlsZENvbGxhcHNlZFNwYW4oYnVpbGRlciwgc2l6ZSwgbWFya2VyLCBpZ25vcmVXaWRnZXQpIHtcXG4gIHZhciB3aWRnZXQgPSAhaWdub3JlV2lkZ2V0ICYmIG1hcmtlci53aWRnZXROb2RlXFxuICBpZiAod2lkZ2V0KSB7IGJ1aWxkZXIubWFwLnB1c2goYnVpbGRlci5wb3MsIGJ1aWxkZXIucG9zICsgc2l6ZSwgd2lkZ2V0KSB9XFxuICBpZiAoIWlnbm9yZVdpZGdldCAmJiBidWlsZGVyLmNtLmRpc3BsYXkuaW5wdXQubmVlZHNDb250ZW50QXR0cmlidXRlKSB7XFxuICAgIGlmICghd2lkZ2V0KVxcbiAgICAgIHsgd2lkZ2V0ID0gYnVpbGRlci5jb250ZW50LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXFxcInNwYW5cXFwiKSkgfVxcbiAgICB3aWRnZXQuc2V0QXR0cmlidXRlKFxcXCJjbS1tYXJrZXJcXFwiLCBtYXJrZXIuaWQpXFxuICB9XFxuICBpZiAod2lkZ2V0KSB7XFxuICAgIGJ1aWxkZXIuY20uZGlzcGxheS5pbnB1dC5zZXRVbmVkaXRhYmxlKHdpZGdldClcXG4gICAgYnVpbGRlci5jb250ZW50LmFwcGVuZENoaWxkKHdpZGdldClcXG4gIH1cXG4gIGJ1aWxkZXIucG9zICs9IHNpemVcXG4gIGJ1aWxkZXIudHJhaWxpbmdTcGFjZSA9IGZhbHNlXFxufVxcblxcbi8vIE91dHB1dHMgYSBudW1iZXIgb2Ygc3BhbnMgdG8gbWFrZSB1cCBhIGxpbmUsIHRha2luZyBoaWdobGlnaHRpbmdcXG4vLyBhbmQgbWFya2VkIHRleHQgaW50byBhY2NvdW50LlxcbmZ1bmN0aW9uIGluc2VydExpbmVDb250ZW50KGxpbmUsIGJ1aWxkZXIsIHN0eWxlcykge1xcbiAgdmFyIHNwYW5zID0gbGluZS5tYXJrZWRTcGFucywgYWxsVGV4dCA9IGxpbmUudGV4dCwgYXQgPSAwXFxuICBpZiAoIXNwYW5zKSB7XFxuICAgIGZvciAodmFyIGkkMSA9IDE7IGkkMSA8IHN0eWxlcy5sZW5ndGg7IGkkMSs9MilcXG4gICAgICB7IGJ1aWxkZXIuYWRkVG9rZW4oYnVpbGRlciwgYWxsVGV4dC5zbGljZShhdCwgYXQgPSBzdHlsZXNbaSQxXSksIGludGVycHJldFRva2VuU3R5bGUoc3R5bGVzW2kkMSsxXSwgYnVpbGRlci5jbS5vcHRpb25zKSkgfVxcbiAgICByZXR1cm5cXG4gIH1cXG5cXG4gIHZhciBsZW4gPSBhbGxUZXh0Lmxlbmd0aCwgcG9zID0gMCwgaSA9IDEsIHRleHQgPSBcXFwiXFxcIiwgc3R5bGUsIGNzc1xcbiAgdmFyIG5leHRDaGFuZ2UgPSAwLCBzcGFuU3R5bGUsIHNwYW5FbmRTdHlsZSwgc3BhblN0YXJ0U3R5bGUsIHRpdGxlLCBjb2xsYXBzZWRcXG4gIGZvciAoOzspIHtcXG4gICAgaWYgKG5leHRDaGFuZ2UgPT0gcG9zKSB7IC8vIFVwZGF0ZSBjdXJyZW50IG1hcmtlciBzZXRcXG4gICAgICBzcGFuU3R5bGUgPSBzcGFuRW5kU3R5bGUgPSBzcGFuU3RhcnRTdHlsZSA9IHRpdGxlID0gY3NzID0gXFxcIlxcXCJcXG4gICAgICBjb2xsYXBzZWQgPSBudWxsOyBuZXh0Q2hhbmdlID0gSW5maW5pdHlcXG4gICAgICB2YXIgZm91bmRCb29rbWFya3MgPSBbXSwgZW5kU3R5bGVzID0gdm9pZCAwXFxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBzcGFucy5sZW5ndGg7ICsraikge1xcbiAgICAgICAgdmFyIHNwID0gc3BhbnNbal0sIG0gPSBzcC5tYXJrZXJcXG4gICAgICAgIGlmIChtLnR5cGUgPT0gXFxcImJvb2ttYXJrXFxcIiAmJiBzcC5mcm9tID09IHBvcyAmJiBtLndpZGdldE5vZGUpIHtcXG4gICAgICAgICAgZm91bmRCb29rbWFya3MucHVzaChtKVxcbiAgICAgICAgfSBlbHNlIGlmIChzcC5mcm9tIDw9IHBvcyAmJiAoc3AudG8gPT0gbnVsbCB8fCBzcC50byA+IHBvcyB8fCBtLmNvbGxhcHNlZCAmJiBzcC50byA9PSBwb3MgJiYgc3AuZnJvbSA9PSBwb3MpKSB7XFxuICAgICAgICAgIGlmIChzcC50byAhPSBudWxsICYmIHNwLnRvICE9IHBvcyAmJiBuZXh0Q2hhbmdlID4gc3AudG8pIHtcXG4gICAgICAgICAgICBuZXh0Q2hhbmdlID0gc3AudG9cXG4gICAgICAgICAgICBzcGFuRW5kU3R5bGUgPSBcXFwiXFxcIlxcbiAgICAgICAgICB9XFxuICAgICAgICAgIGlmIChtLmNsYXNzTmFtZSkgeyBzcGFuU3R5bGUgKz0gXFxcIiBcXFwiICsgbS5jbGFzc05hbWUgfVxcbiAgICAgICAgICBpZiAobS5jc3MpIHsgY3NzID0gKGNzcyA/IGNzcyArIFxcXCI7XFxcIiA6IFxcXCJcXFwiKSArIG0uY3NzIH1cXG4gICAgICAgICAgaWYgKG0uc3RhcnRTdHlsZSAmJiBzcC5mcm9tID09IHBvcykgeyBzcGFuU3RhcnRTdHlsZSArPSBcXFwiIFxcXCIgKyBtLnN0YXJ0U3R5bGUgfVxcbiAgICAgICAgICBpZiAobS5lbmRTdHlsZSAmJiBzcC50byA9PSBuZXh0Q2hhbmdlKSB7IChlbmRTdHlsZXMgfHwgKGVuZFN0eWxlcyA9IFtdKSkucHVzaChtLmVuZFN0eWxlLCBzcC50bykgfVxcbiAgICAgICAgICBpZiAobS50aXRsZSAmJiAhdGl0bGUpIHsgdGl0bGUgPSBtLnRpdGxlIH1cXG4gICAgICAgICAgaWYgKG0uY29sbGFwc2VkICYmICghY29sbGFwc2VkIHx8IGNvbXBhcmVDb2xsYXBzZWRNYXJrZXJzKGNvbGxhcHNlZC5tYXJrZXIsIG0pIDwgMCkpXFxuICAgICAgICAgICAgeyBjb2xsYXBzZWQgPSBzcCB9XFxuICAgICAgICB9IGVsc2UgaWYgKHNwLmZyb20gPiBwb3MgJiYgbmV4dENoYW5nZSA+IHNwLmZyb20pIHtcXG4gICAgICAgICAgbmV4dENoYW5nZSA9IHNwLmZyb21cXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgICAgaWYgKGVuZFN0eWxlcykgeyBmb3IgKHZhciBqJDEgPSAwOyBqJDEgPCBlbmRTdHlsZXMubGVuZ3RoOyBqJDEgKz0gMilcXG4gICAgICAgIHsgaWYgKGVuZFN0eWxlc1tqJDEgKyAxXSA9PSBuZXh0Q2hhbmdlKSB7IHNwYW5FbmRTdHlsZSArPSBcXFwiIFxcXCIgKyBlbmRTdHlsZXNbaiQxXSB9IH0gfVxcblxcbiAgICAgIGlmICghY29sbGFwc2VkIHx8IGNvbGxhcHNlZC5mcm9tID09IHBvcykgeyBmb3IgKHZhciBqJDIgPSAwOyBqJDIgPCBmb3VuZEJvb2ttYXJrcy5sZW5ndGg7ICsraiQyKVxcbiAgICAgICAgeyBidWlsZENvbGxhcHNlZFNwYW4oYnVpbGRlciwgMCwgZm91bmRCb29rbWFya3NbaiQyXSkgfSB9XFxuICAgICAgaWYgKGNvbGxhcHNlZCAmJiAoY29sbGFwc2VkLmZyb20gfHwgMCkgPT0gcG9zKSB7XFxuICAgICAgICBidWlsZENvbGxhcHNlZFNwYW4oYnVpbGRlciwgKGNvbGxhcHNlZC50byA9PSBudWxsID8gbGVuICsgMSA6IGNvbGxhcHNlZC50bykgLSBwb3MsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sbGFwc2VkLm1hcmtlciwgY29sbGFwc2VkLmZyb20gPT0gbnVsbClcXG4gICAgICAgIGlmIChjb2xsYXBzZWQudG8gPT0gbnVsbCkgeyByZXR1cm4gfVxcbiAgICAgICAgaWYgKGNvbGxhcHNlZC50byA9PSBwb3MpIHsgY29sbGFwc2VkID0gZmFsc2UgfVxcbiAgICAgIH1cXG4gICAgfVxcbiAgICBpZiAocG9zID49IGxlbikgeyBicmVhayB9XFxuXFxuICAgIHZhciB1cHRvID0gTWF0aC5taW4obGVuLCBuZXh0Q2hhbmdlKVxcbiAgICB3aGlsZSAodHJ1ZSkge1xcbiAgICAgIGlmICh0ZXh0KSB7XFxuICAgICAgICB2YXIgZW5kID0gcG9zICsgdGV4dC5sZW5ndGhcXG4gICAgICAgIGlmICghY29sbGFwc2VkKSB7XFxuICAgICAgICAgIHZhciB0b2tlblRleHQgPSBlbmQgPiB1cHRvID8gdGV4dC5zbGljZSgwLCB1cHRvIC0gcG9zKSA6IHRleHRcXG4gICAgICAgICAgYnVpbGRlci5hZGRUb2tlbihidWlsZGVyLCB0b2tlblRleHQsIHN0eWxlID8gc3R5bGUgKyBzcGFuU3R5bGUgOiBzcGFuU3R5bGUsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgc3BhblN0YXJ0U3R5bGUsIHBvcyArIHRva2VuVGV4dC5sZW5ndGggPT0gbmV4dENoYW5nZSA/IHNwYW5FbmRTdHlsZSA6IFxcXCJcXFwiLCB0aXRsZSwgY3NzKVxcbiAgICAgICAgfVxcbiAgICAgICAgaWYgKGVuZCA+PSB1cHRvKSB7dGV4dCA9IHRleHQuc2xpY2UodXB0byAtIHBvcyk7IHBvcyA9IHVwdG87IGJyZWFrfVxcbiAgICAgICAgcG9zID0gZW5kXFxuICAgICAgICBzcGFuU3RhcnRTdHlsZSA9IFxcXCJcXFwiXFxuICAgICAgfVxcbiAgICAgIHRleHQgPSBhbGxUZXh0LnNsaWNlKGF0LCBhdCA9IHN0eWxlc1tpKytdKVxcbiAgICAgIHN0eWxlID0gaW50ZXJwcmV0VG9rZW5TdHlsZShzdHlsZXNbaSsrXSwgYnVpbGRlci5jbS5vcHRpb25zKVxcbiAgICB9XFxuICB9XFxufVxcblxcblxcbi8vIFRoZXNlIG9iamVjdHMgYXJlIHVzZWQgdG8gcmVwcmVzZW50IHRoZSB2aXNpYmxlIChjdXJyZW50bHkgZHJhd24pXFxuLy8gcGFydCBvZiB0aGUgZG9jdW1lbnQuIEEgTGluZVZpZXcgbWF5IGNvcnJlc3BvbmQgdG8gbXVsdGlwbGVcXG4vLyBsb2dpY2FsIGxpbmVzLCBpZiB0aG9zZSBhcmUgY29ubmVjdGVkIGJ5IGNvbGxhcHNlZCByYW5nZXMuXFxuZnVuY3Rpb24gTGluZVZpZXcoZG9jLCBsaW5lLCBsaW5lTikge1xcbiAgLy8gVGhlIHN0YXJ0aW5nIGxpbmVcXG4gIHRoaXMubGluZSA9IGxpbmVcXG4gIC8vIENvbnRpbnVpbmcgbGluZXMsIGlmIGFueVxcbiAgdGhpcy5yZXN0ID0gdmlzdWFsTGluZUNvbnRpbnVlZChsaW5lKVxcbiAgLy8gTnVtYmVyIG9mIGxvZ2ljYWwgbGluZXMgaW4gdGhpcyB2aXN1YWwgbGluZVxcbiAgdGhpcy5zaXplID0gdGhpcy5yZXN0ID8gbGluZU5vKGxzdCh0aGlzLnJlc3QpKSAtIGxpbmVOICsgMSA6IDFcXG4gIHRoaXMubm9kZSA9IHRoaXMudGV4dCA9IG51bGxcXG4gIHRoaXMuaGlkZGVuID0gbGluZUlzSGlkZGVuKGRvYywgbGluZSlcXG59XFxuXFxuLy8gQ3JlYXRlIGEgcmFuZ2Ugb2YgTGluZVZpZXcgb2JqZWN0cyBmb3IgdGhlIGdpdmVuIGxpbmVzLlxcbmZ1bmN0aW9uIGJ1aWxkVmlld0FycmF5KGNtLCBmcm9tLCB0bykge1xcbiAgdmFyIGFycmF5ID0gW10sIG5leHRQb3NcXG4gIGZvciAodmFyIHBvcyA9IGZyb207IHBvcyA8IHRvOyBwb3MgPSBuZXh0UG9zKSB7XFxuICAgIHZhciB2aWV3ID0gbmV3IExpbmVWaWV3KGNtLmRvYywgZ2V0TGluZShjbS5kb2MsIHBvcyksIHBvcylcXG4gICAgbmV4dFBvcyA9IHBvcyArIHZpZXcuc2l6ZVxcbiAgICBhcnJheS5wdXNoKHZpZXcpXFxuICB9XFxuICByZXR1cm4gYXJyYXlcXG59XFxuXFxudmFyIG9wZXJhdGlvbkdyb3VwID0gbnVsbFxcblxcbmZ1bmN0aW9uIHB1c2hPcGVyYXRpb24ob3ApIHtcXG4gIGlmIChvcGVyYXRpb25Hcm91cCkge1xcbiAgICBvcGVyYXRpb25Hcm91cC5vcHMucHVzaChvcClcXG4gIH0gZWxzZSB7XFxuICAgIG9wLm93bnNHcm91cCA9IG9wZXJhdGlvbkdyb3VwID0ge1xcbiAgICAgIG9wczogW29wXSxcXG4gICAgICBkZWxheWVkQ2FsbGJhY2tzOiBbXVxcbiAgICB9XFxuICB9XFxufVxcblxcbmZ1bmN0aW9uIGZpcmVDYWxsYmFja3NGb3JPcHMoZ3JvdXApIHtcXG4gIC8vIENhbGxzIGRlbGF5ZWQgY2FsbGJhY2tzIGFuZCBjdXJzb3JBY3Rpdml0eSBoYW5kbGVycyB1bnRpbCBub1xcbiAgLy8gbmV3IG9uZXMgYXBwZWFyXFxuICB2YXIgY2FsbGJhY2tzID0gZ3JvdXAuZGVsYXllZENhbGxiYWNrcywgaSA9IDBcXG4gIGRvIHtcXG4gICAgZm9yICg7IGkgPCBjYWxsYmFja3MubGVuZ3RoOyBpKyspXFxuICAgICAgeyBjYWxsYmFja3NbaV0uY2FsbChudWxsKSB9XFxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgZ3JvdXAub3BzLmxlbmd0aDsgaisrKSB7XFxuICAgICAgdmFyIG9wID0gZ3JvdXAub3BzW2pdXFxuICAgICAgaWYgKG9wLmN1cnNvckFjdGl2aXR5SGFuZGxlcnMpXFxuICAgICAgICB7IHdoaWxlIChvcC5jdXJzb3JBY3Rpdml0eUNhbGxlZCA8IG9wLmN1cnNvckFjdGl2aXR5SGFuZGxlcnMubGVuZ3RoKVxcbiAgICAgICAgICB7IG9wLmN1cnNvckFjdGl2aXR5SGFuZGxlcnNbb3AuY3Vyc29yQWN0aXZpdHlDYWxsZWQrK10uY2FsbChudWxsLCBvcC5jbSkgfSB9XFxuICAgIH1cXG4gIH0gd2hpbGUgKGkgPCBjYWxsYmFja3MubGVuZ3RoKVxcbn1cXG5cXG5mdW5jdGlvbiBmaW5pc2hPcGVyYXRpb24ob3AsIGVuZENiKSB7XFxuICB2YXIgZ3JvdXAgPSBvcC5vd25zR3JvdXBcXG4gIGlmICghZ3JvdXApIHsgcmV0dXJuIH1cXG5cXG4gIHRyeSB7IGZpcmVDYWxsYmFja3NGb3JPcHMoZ3JvdXApIH1cXG4gIGZpbmFsbHkge1xcbiAgICBvcGVyYXRpb25Hcm91cCA9IG51bGxcXG4gICAgZW5kQ2IoZ3JvdXApXFxuICB9XFxufVxcblxcbnZhciBvcnBoYW5EZWxheWVkQ2FsbGJhY2tzID0gbnVsbFxcblxcbi8vIE9mdGVuLCB3ZSB3YW50IHRvIHNpZ25hbCBldmVudHMgYXQgYSBwb2ludCB3aGVyZSB3ZSBhcmUgaW4gdGhlXFxuLy8gbWlkZGxlIG9mIHNvbWUgd29yaywgYnV0IGRvbid0IHdhbnQgdGhlIGhhbmRsZXIgdG8gc3RhcnQgY2FsbGluZ1xcbi8vIG90aGVyIG1ldGhvZHMgb24gdGhlIGVkaXRvciwgd2hpY2ggbWlnaHQgYmUgaW4gYW4gaW5jb25zaXN0ZW50XFxuLy8gc3RhdGUgb3Igc2ltcGx5IG5vdCBleHBlY3QgYW55IG90aGVyIGV2ZW50cyB0byBoYXBwZW4uXFxuLy8gc2lnbmFsTGF0ZXIgbG9va3Mgd2hldGhlciB0aGVyZSBhcmUgYW55IGhhbmRsZXJzLCBhbmQgc2NoZWR1bGVzXFxuLy8gdGhlbSB0byBiZSBleGVjdXRlZCB3aGVuIHRoZSBsYXN0IG9wZXJhdGlvbiBlbmRzLCBvciwgaWYgbm9cXG4vLyBvcGVyYXRpb24gaXMgYWN0aXZlLCB3aGVuIGEgdGltZW91dCBmaXJlcy5cXG5mdW5jdGlvbiBzaWduYWxMYXRlcihlbWl0dGVyLCB0eXBlIC8qLCB2YWx1ZXMuLi4qLykge1xcbiAgdmFyIGFyciA9IGdldEhhbmRsZXJzKGVtaXR0ZXIsIHR5cGUsIGZhbHNlKVxcbiAgaWYgKCFhcnIubGVuZ3RoKSB7IHJldHVybiB9XFxuICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMiksIGxpc3RcXG4gIGlmIChvcGVyYXRpb25Hcm91cCkge1xcbiAgICBsaXN0ID0gb3BlcmF0aW9uR3JvdXAuZGVsYXllZENhbGxiYWNrc1xcbiAgfSBlbHNlIGlmIChvcnBoYW5EZWxheWVkQ2FsbGJhY2tzKSB7XFxuICAgIGxpc3QgPSBvcnBoYW5EZWxheWVkQ2FsbGJhY2tzXFxuICB9IGVsc2Uge1xcbiAgICBsaXN0ID0gb3JwaGFuRGVsYXllZENhbGxiYWNrcyA9IFtdXFxuICAgIHNldFRpbWVvdXQoZmlyZU9ycGhhbkRlbGF5ZWQsIDApXFxuICB9XFxuICB2YXIgbG9vcCA9IGZ1bmN0aW9uICggaSApIHtcXG4gICAgbGlzdC5wdXNoKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGFycltpXS5hcHBseShudWxsLCBhcmdzKTsgfSlcXG4gIH07XFxuXFxuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7ICsraSlcXG4gICAgbG9vcCggaSApO1xcbn1cXG5cXG5mdW5jdGlvbiBmaXJlT3JwaGFuRGVsYXllZCgpIHtcXG4gIHZhciBkZWxheWVkID0gb3JwaGFuRGVsYXllZENhbGxiYWNrc1xcbiAgb3JwaGFuRGVsYXllZENhbGxiYWNrcyA9IG51bGxcXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZGVsYXllZC5sZW5ndGg7ICsraSkgeyBkZWxheWVkW2ldKCkgfVxcbn1cXG5cXG4vLyBXaGVuIGFuIGFzcGVjdCBvZiBhIGxpbmUgY2hhbmdlcywgYSBzdHJpbmcgaXMgYWRkZWQgdG9cXG4vLyBsaW5lVmlldy5jaGFuZ2VzLiBUaGlzIHVwZGF0ZXMgdGhlIHJlbGV2YW50IHBhcnQgb2YgdGhlIGxpbmUnc1xcbi8vIERPTSBzdHJ1Y3R1cmUuXFxuZnVuY3Rpb24gdXBkYXRlTGluZUZvckNoYW5nZXMoY20sIGxpbmVWaWV3LCBsaW5lTiwgZGltcykge1xcbiAgZm9yICh2YXIgaiA9IDA7IGogPCBsaW5lVmlldy5jaGFuZ2VzLmxlbmd0aDsgaisrKSB7XFxuICAgIHZhciB0eXBlID0gbGluZVZpZXcuY2hhbmdlc1tqXVxcbiAgICBpZiAodHlwZSA9PSBcXFwidGV4dFxcXCIpIHsgdXBkYXRlTGluZVRleHQoY20sIGxpbmVWaWV3KSB9XFxuICAgIGVsc2UgaWYgKHR5cGUgPT0gXFxcImd1dHRlclxcXCIpIHsgdXBkYXRlTGluZUd1dHRlcihjbSwgbGluZVZpZXcsIGxpbmVOLCBkaW1zKSB9XFxuICAgIGVsc2UgaWYgKHR5cGUgPT0gXFxcImNsYXNzXFxcIikgeyB1cGRhdGVMaW5lQ2xhc3NlcyhsaW5lVmlldykgfVxcbiAgICBlbHNlIGlmICh0eXBlID09IFxcXCJ3aWRnZXRcXFwiKSB7IHVwZGF0ZUxpbmVXaWRnZXRzKGNtLCBsaW5lVmlldywgZGltcykgfVxcbiAgfVxcbiAgbGluZVZpZXcuY2hhbmdlcyA9IG51bGxcXG59XFxuXFxuLy8gTGluZXMgd2l0aCBndXR0ZXIgZWxlbWVudHMsIHdpZGdldHMgb3IgYSBiYWNrZ3JvdW5kIGNsYXNzIG5lZWQgdG9cXG4vLyBiZSB3cmFwcGVkLCBhbmQgaGF2ZSB0aGUgZXh0cmEgZWxlbWVudHMgYWRkZWQgdG8gdGhlIHdyYXBwZXIgZGl2XFxuZnVuY3Rpb24gZW5zdXJlTGluZVdyYXBwZWQobGluZVZpZXcpIHtcXG4gIGlmIChsaW5lVmlldy5ub2RlID09IGxpbmVWaWV3LnRleHQpIHtcXG4gICAgbGluZVZpZXcubm9kZSA9IGVsdChcXFwiZGl2XFxcIiwgbnVsbCwgbnVsbCwgXFxcInBvc2l0aW9uOiByZWxhdGl2ZVxcXCIpXFxuICAgIGlmIChsaW5lVmlldy50ZXh0LnBhcmVudE5vZGUpXFxuICAgICAgeyBsaW5lVmlldy50ZXh0LnBhcmVudE5vZGUucmVwbGFjZUNoaWxkKGxpbmVWaWV3Lm5vZGUsIGxpbmVWaWV3LnRleHQpIH1cXG4gICAgbGluZVZpZXcubm9kZS5hcHBlbmRDaGlsZChsaW5lVmlldy50ZXh0KVxcbiAgICBpZiAoaWUgJiYgaWVfdmVyc2lvbiA8IDgpIHsgbGluZVZpZXcubm9kZS5zdHlsZS56SW5kZXggPSAyIH1cXG4gIH1cXG4gIHJldHVybiBsaW5lVmlldy5ub2RlXFxufVxcblxcbmZ1bmN0aW9uIHVwZGF0ZUxpbmVCYWNrZ3JvdW5kKGxpbmVWaWV3KSB7XFxuICB2YXIgY2xzID0gbGluZVZpZXcuYmdDbGFzcyA/IGxpbmVWaWV3LmJnQ2xhc3MgKyBcXFwiIFxcXCIgKyAobGluZVZpZXcubGluZS5iZ0NsYXNzIHx8IFxcXCJcXFwiKSA6IGxpbmVWaWV3LmxpbmUuYmdDbGFzc1xcbiAgaWYgKGNscykgeyBjbHMgKz0gXFxcIiBDb2RlTWlycm9yLWxpbmViYWNrZ3JvdW5kXFxcIiB9XFxuICBpZiAobGluZVZpZXcuYmFja2dyb3VuZCkge1xcbiAgICBpZiAoY2xzKSB7IGxpbmVWaWV3LmJhY2tncm91bmQuY2xhc3NOYW1lID0gY2xzIH1cXG4gICAgZWxzZSB7IGxpbmVWaWV3LmJhY2tncm91bmQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChsaW5lVmlldy5iYWNrZ3JvdW5kKTsgbGluZVZpZXcuYmFja2dyb3VuZCA9IG51bGwgfVxcbiAgfSBlbHNlIGlmIChjbHMpIHtcXG4gICAgdmFyIHdyYXAgPSBlbnN1cmVMaW5lV3JhcHBlZChsaW5lVmlldylcXG4gICAgbGluZVZpZXcuYmFja2dyb3VuZCA9IHdyYXAuaW5zZXJ0QmVmb3JlKGVsdChcXFwiZGl2XFxcIiwgbnVsbCwgY2xzKSwgd3JhcC5maXJzdENoaWxkKVxcbiAgfVxcbn1cXG5cXG4vLyBXcmFwcGVyIGFyb3VuZCBidWlsZExpbmVDb250ZW50IHdoaWNoIHdpbGwgcmV1c2UgdGhlIHN0cnVjdHVyZVxcbi8vIGluIGRpc3BsYXkuZXh0ZXJuYWxNZWFzdXJlZCB3aGVuIHBvc3NpYmxlLlxcbmZ1bmN0aW9uIGdldExpbmVDb250ZW50KGNtLCBsaW5lVmlldykge1xcbiAgdmFyIGV4dCA9IGNtLmRpc3BsYXkuZXh0ZXJuYWxNZWFzdXJlZFxcbiAgaWYgKGV4dCAmJiBleHQubGluZSA9PSBsaW5lVmlldy5saW5lKSB7XFxuICAgIGNtLmRpc3BsYXkuZXh0ZXJuYWxNZWFzdXJlZCA9IG51bGxcXG4gICAgbGluZVZpZXcubWVhc3VyZSA9IGV4dC5tZWFzdXJlXFxuICAgIHJldHVybiBleHQuYnVpbHRcXG4gIH1cXG4gIHJldHVybiBidWlsZExpbmVDb250ZW50KGNtLCBsaW5lVmlldylcXG59XFxuXFxuLy8gUmVkcmF3IHRoZSBsaW5lJ3MgdGV4dC4gSW50ZXJhY3RzIHdpdGggdGhlIGJhY2tncm91bmQgYW5kIHRleHRcXG4vLyBjbGFzc2VzIGJlY2F1c2UgdGhlIG1vZGUgbWF5IG91dHB1dCB0b2tlbnMgdGhhdCBpbmZsdWVuY2UgdGhlc2VcXG4vLyBjbGFzc2VzLlxcbmZ1bmN0aW9uIHVwZGF0ZUxpbmVUZXh0KGNtLCBsaW5lVmlldykge1xcbiAgdmFyIGNscyA9IGxpbmVWaWV3LnRleHQuY2xhc3NOYW1lXFxuICB2YXIgYnVpbHQgPSBnZXRMaW5lQ29udGVudChjbSwgbGluZVZpZXcpXFxuICBpZiAobGluZVZpZXcudGV4dCA9PSBsaW5lVmlldy5ub2RlKSB7IGxpbmVWaWV3Lm5vZGUgPSBidWlsdC5wcmUgfVxcbiAgbGluZVZpZXcudGV4dC5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZChidWlsdC5wcmUsIGxpbmVWaWV3LnRleHQpXFxuICBsaW5lVmlldy50ZXh0ID0gYnVpbHQucHJlXFxuICBpZiAoYnVpbHQuYmdDbGFzcyAhPSBsaW5lVmlldy5iZ0NsYXNzIHx8IGJ1aWx0LnRleHRDbGFzcyAhPSBsaW5lVmlldy50ZXh0Q2xhc3MpIHtcXG4gICAgbGluZVZpZXcuYmdDbGFzcyA9IGJ1aWx0LmJnQ2xhc3NcXG4gICAgbGluZVZpZXcudGV4dENsYXNzID0gYnVpbHQudGV4dENsYXNzXFxuICAgIHVwZGF0ZUxpbmVDbGFzc2VzKGxpbmVWaWV3KVxcbiAgfSBlbHNlIGlmIChjbHMpIHtcXG4gICAgbGluZVZpZXcudGV4dC5jbGFzc05hbWUgPSBjbHNcXG4gIH1cXG59XFxuXFxuZnVuY3Rpb24gdXBkYXRlTGluZUNsYXNzZXMobGluZVZpZXcpIHtcXG4gIHVwZGF0ZUxpbmVCYWNrZ3JvdW5kKGxpbmVWaWV3KVxcbiAgaWYgKGxpbmVWaWV3LmxpbmUud3JhcENsYXNzKVxcbiAgICB7IGVuc3VyZUxpbmVXcmFwcGVkKGxpbmVWaWV3KS5jbGFzc05hbWUgPSBsaW5lVmlldy5saW5lLndyYXBDbGFzcyB9XFxuICBlbHNlIGlmIChsaW5lVmlldy5ub2RlICE9IGxpbmVWaWV3LnRleHQpXFxuICAgIHsgbGluZVZpZXcubm9kZS5jbGFzc05hbWUgPSBcXFwiXFxcIiB9XFxuICB2YXIgdGV4dENsYXNzID0gbGluZVZpZXcudGV4dENsYXNzID8gbGluZVZpZXcudGV4dENsYXNzICsgXFxcIiBcXFwiICsgKGxpbmVWaWV3LmxpbmUudGV4dENsYXNzIHx8IFxcXCJcXFwiKSA6IGxpbmVWaWV3LmxpbmUudGV4dENsYXNzXFxuICBsaW5lVmlldy50ZXh0LmNsYXNzTmFtZSA9IHRleHRDbGFzcyB8fCBcXFwiXFxcIlxcbn1cXG5cXG5mdW5jdGlvbiB1cGRhdGVMaW5lR3V0dGVyKGNtLCBsaW5lVmlldywgbGluZU4sIGRpbXMpIHtcXG4gIGlmIChsaW5lVmlldy5ndXR0ZXIpIHtcXG4gICAgbGluZVZpZXcubm9kZS5yZW1vdmVDaGlsZChsaW5lVmlldy5ndXR0ZXIpXFxuICAgIGxpbmVWaWV3Lmd1dHRlciA9IG51bGxcXG4gIH1cXG4gIGlmIChsaW5lVmlldy5ndXR0ZXJCYWNrZ3JvdW5kKSB7XFxuICAgIGxpbmVWaWV3Lm5vZGUucmVtb3ZlQ2hpbGQobGluZVZpZXcuZ3V0dGVyQmFja2dyb3VuZClcXG4gICAgbGluZVZpZXcuZ3V0dGVyQmFja2dyb3VuZCA9IG51bGxcXG4gIH1cXG4gIGlmIChsaW5lVmlldy5saW5lLmd1dHRlckNsYXNzKSB7XFxuICAgIHZhciB3cmFwID0gZW5zdXJlTGluZVdyYXBwZWQobGluZVZpZXcpXFxuICAgIGxpbmVWaWV3Lmd1dHRlckJhY2tncm91bmQgPSBlbHQoXFxcImRpdlxcXCIsIG51bGwsIFxcXCJDb2RlTWlycm9yLWd1dHRlci1iYWNrZ3JvdW5kIFxcXCIgKyBsaW5lVmlldy5saW5lLmd1dHRlckNsYXNzLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChcXFwibGVmdDogXFxcIiArIChjbS5vcHRpb25zLmZpeGVkR3V0dGVyID8gZGltcy5maXhlZFBvcyA6IC1kaW1zLmd1dHRlclRvdGFsV2lkdGgpICsgXFxcInB4OyB3aWR0aDogXFxcIiArIChkaW1zLmd1dHRlclRvdGFsV2lkdGgpICsgXFxcInB4XFxcIikpXFxuICAgIHdyYXAuaW5zZXJ0QmVmb3JlKGxpbmVWaWV3Lmd1dHRlckJhY2tncm91bmQsIGxpbmVWaWV3LnRleHQpXFxuICB9XFxuICB2YXIgbWFya2VycyA9IGxpbmVWaWV3LmxpbmUuZ3V0dGVyTWFya2Vyc1xcbiAgaWYgKGNtLm9wdGlvbnMubGluZU51bWJlcnMgfHwgbWFya2Vycykge1xcbiAgICB2YXIgd3JhcCQxID0gZW5zdXJlTGluZVdyYXBwZWQobGluZVZpZXcpXFxuICAgIHZhciBndXR0ZXJXcmFwID0gbGluZVZpZXcuZ3V0dGVyID0gZWx0KFxcXCJkaXZcXFwiLCBudWxsLCBcXFwiQ29kZU1pcnJvci1ndXR0ZXItd3JhcHBlclxcXCIsIChcXFwibGVmdDogXFxcIiArIChjbS5vcHRpb25zLmZpeGVkR3V0dGVyID8gZGltcy5maXhlZFBvcyA6IC1kaW1zLmd1dHRlclRvdGFsV2lkdGgpICsgXFxcInB4XFxcIikpXFxuICAgIGNtLmRpc3BsYXkuaW5wdXQuc2V0VW5lZGl0YWJsZShndXR0ZXJXcmFwKVxcbiAgICB3cmFwJDEuaW5zZXJ0QmVmb3JlKGd1dHRlcldyYXAsIGxpbmVWaWV3LnRleHQpXFxuICAgIGlmIChsaW5lVmlldy5saW5lLmd1dHRlckNsYXNzKVxcbiAgICAgIHsgZ3V0dGVyV3JhcC5jbGFzc05hbWUgKz0gXFxcIiBcXFwiICsgbGluZVZpZXcubGluZS5ndXR0ZXJDbGFzcyB9XFxuICAgIGlmIChjbS5vcHRpb25zLmxpbmVOdW1iZXJzICYmICghbWFya2VycyB8fCAhbWFya2Vyc1tcXFwiQ29kZU1pcnJvci1saW5lbnVtYmVyc1xcXCJdKSlcXG4gICAgICB7IGxpbmVWaWV3LmxpbmVOdW1iZXIgPSBndXR0ZXJXcmFwLmFwcGVuZENoaWxkKFxcbiAgICAgICAgZWx0KFxcXCJkaXZcXFwiLCBsaW5lTnVtYmVyRm9yKGNtLm9wdGlvbnMsIGxpbmVOKSxcXG4gICAgICAgICAgICBcXFwiQ29kZU1pcnJvci1saW5lbnVtYmVyIENvZGVNaXJyb3ItZ3V0dGVyLWVsdFxcXCIsXFxuICAgICAgICAgICAgKFxcXCJsZWZ0OiBcXFwiICsgKGRpbXMuZ3V0dGVyTGVmdFtcXFwiQ29kZU1pcnJvci1saW5lbnVtYmVyc1xcXCJdKSArIFxcXCJweDsgd2lkdGg6IFxcXCIgKyAoY20uZGlzcGxheS5saW5lTnVtSW5uZXJXaWR0aCkgKyBcXFwicHhcXFwiKSkpIH1cXG4gICAgaWYgKG1hcmtlcnMpIHsgZm9yICh2YXIgayA9IDA7IGsgPCBjbS5vcHRpb25zLmd1dHRlcnMubGVuZ3RoOyArK2spIHtcXG4gICAgICB2YXIgaWQgPSBjbS5vcHRpb25zLmd1dHRlcnNba10sIGZvdW5kID0gbWFya2Vycy5oYXNPd25Qcm9wZXJ0eShpZCkgJiYgbWFya2Vyc1tpZF1cXG4gICAgICBpZiAoZm91bmQpXFxuICAgICAgICB7IGd1dHRlcldyYXAuYXBwZW5kQ2hpbGQoZWx0KFxcXCJkaXZcXFwiLCBbZm91bmRdLCBcXFwiQ29kZU1pcnJvci1ndXR0ZXItZWx0XFxcIixcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChcXFwibGVmdDogXFxcIiArIChkaW1zLmd1dHRlckxlZnRbaWRdKSArIFxcXCJweDsgd2lkdGg6IFxcXCIgKyAoZGltcy5ndXR0ZXJXaWR0aFtpZF0pICsgXFxcInB4XFxcIikpKSB9XFxuICAgIH0gfVxcbiAgfVxcbn1cXG5cXG5mdW5jdGlvbiB1cGRhdGVMaW5lV2lkZ2V0cyhjbSwgbGluZVZpZXcsIGRpbXMpIHtcXG4gIGlmIChsaW5lVmlldy5hbGlnbmFibGUpIHsgbGluZVZpZXcuYWxpZ25hYmxlID0gbnVsbCB9XFxuICBmb3IgKHZhciBub2RlID0gbGluZVZpZXcubm9kZS5maXJzdENoaWxkLCBuZXh0ID0gdm9pZCAwOyBub2RlOyBub2RlID0gbmV4dCkge1xcbiAgICBuZXh0ID0gbm9kZS5uZXh0U2libGluZ1xcbiAgICBpZiAobm9kZS5jbGFzc05hbWUgPT0gXFxcIkNvZGVNaXJyb3ItbGluZXdpZGdldFxcXCIpXFxuICAgICAgeyBsaW5lVmlldy5ub2RlLnJlbW92ZUNoaWxkKG5vZGUpIH1cXG4gIH1cXG4gIGluc2VydExpbmVXaWRnZXRzKGNtLCBsaW5lVmlldywgZGltcylcXG59XFxuXFxuLy8gQnVpbGQgYSBsaW5lJ3MgRE9NIHJlcHJlc2VudGF0aW9uIGZyb20gc2NyYXRjaFxcbmZ1bmN0aW9uIGJ1aWxkTGluZUVsZW1lbnQoY20sIGxpbmVWaWV3LCBsaW5lTiwgZGltcykge1xcbiAgdmFyIGJ1aWx0ID0gZ2V0TGluZUNvbnRlbnQoY20sIGxpbmVWaWV3KVxcbiAgbGluZVZpZXcudGV4dCA9IGxpbmVWaWV3Lm5vZGUgPSBidWlsdC5wcmVcXG4gIGlmIChidWlsdC5iZ0NsYXNzKSB7IGxpbmVWaWV3LmJnQ2xhc3MgPSBidWlsdC5iZ0NsYXNzIH1cXG4gIGlmIChidWlsdC50ZXh0Q2xhc3MpIHsgbGluZVZpZXcudGV4dENsYXNzID0gYnVpbHQudGV4dENsYXNzIH1cXG5cXG4gIHVwZGF0ZUxpbmVDbGFzc2VzKGxpbmVWaWV3KVxcbiAgdXBkYXRlTGluZUd1dHRlcihjbSwgbGluZVZpZXcsIGxpbmVOLCBkaW1zKVxcbiAgaW5zZXJ0TGluZVdpZGdldHMoY20sIGxpbmVWaWV3LCBkaW1zKVxcbiAgcmV0dXJuIGxpbmVWaWV3Lm5vZGVcXG59XFxuXFxuLy8gQSBsaW5lVmlldyBtYXkgY29udGFpbiBtdWx0aXBsZSBsb2dpY2FsIGxpbmVzICh3aGVuIG1lcmdlZCBieVxcbi8vIGNvbGxhcHNlZCBzcGFucykuIFRoZSB3aWRnZXRzIGZvciBhbGwgb2YgdGhlbSBuZWVkIHRvIGJlIGRyYXduLlxcbmZ1bmN0aW9uIGluc2VydExpbmVXaWRnZXRzKGNtLCBsaW5lVmlldywgZGltcykge1xcbiAgaW5zZXJ0TGluZVdpZGdldHNGb3IoY20sIGxpbmVWaWV3LmxpbmUsIGxpbmVWaWV3LCBkaW1zLCB0cnVlKVxcbiAgaWYgKGxpbmVWaWV3LnJlc3QpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lVmlldy5yZXN0Lmxlbmd0aDsgaSsrKVxcbiAgICB7IGluc2VydExpbmVXaWRnZXRzRm9yKGNtLCBsaW5lVmlldy5yZXN0W2ldLCBsaW5lVmlldywgZGltcywgZmFsc2UpIH0gfVxcbn1cXG5cXG5mdW5jdGlvbiBpbnNlcnRMaW5lV2lkZ2V0c0ZvcihjbSwgbGluZSwgbGluZVZpZXcsIGRpbXMsIGFsbG93QWJvdmUpIHtcXG4gIGlmICghbGluZS53aWRnZXRzKSB7IHJldHVybiB9XFxuICB2YXIgd3JhcCA9IGVuc3VyZUxpbmVXcmFwcGVkKGxpbmVWaWV3KVxcbiAgZm9yICh2YXIgaSA9IDAsIHdzID0gbGluZS53aWRnZXRzOyBpIDwgd3MubGVuZ3RoOyArK2kpIHtcXG4gICAgdmFyIHdpZGdldCA9IHdzW2ldLCBub2RlID0gZWx0KFxcXCJkaXZcXFwiLCBbd2lkZ2V0Lm5vZGVdLCBcXFwiQ29kZU1pcnJvci1saW5ld2lkZ2V0XFxcIilcXG4gICAgaWYgKCF3aWRnZXQuaGFuZGxlTW91c2VFdmVudHMpIHsgbm9kZS5zZXRBdHRyaWJ1dGUoXFxcImNtLWlnbm9yZS1ldmVudHNcXFwiLCBcXFwidHJ1ZVxcXCIpIH1cXG4gICAgcG9zaXRpb25MaW5lV2lkZ2V0KHdpZGdldCwgbm9kZSwgbGluZVZpZXcsIGRpbXMpXFxuICAgIGNtLmRpc3BsYXkuaW5wdXQuc2V0VW5lZGl0YWJsZShub2RlKVxcbiAgICBpZiAoYWxsb3dBYm92ZSAmJiB3aWRnZXQuYWJvdmUpXFxuICAgICAgeyB3cmFwLmluc2VydEJlZm9yZShub2RlLCBsaW5lVmlldy5ndXR0ZXIgfHwgbGluZVZpZXcudGV4dCkgfVxcbiAgICBlbHNlXFxuICAgICAgeyB3cmFwLmFwcGVuZENoaWxkKG5vZGUpIH1cXG4gICAgc2lnbmFsTGF0ZXIod2lkZ2V0LCBcXFwicmVkcmF3XFxcIilcXG4gIH1cXG59XFxuXFxuZnVuY3Rpb24gcG9zaXRpb25MaW5lV2lkZ2V0KHdpZGdldCwgbm9kZSwgbGluZVZpZXcsIGRpbXMpIHtcXG4gIGlmICh3aWRnZXQubm9IU2Nyb2xsKSB7XFxuICAgIDsobGluZVZpZXcuYWxpZ25hYmxlIHx8IChsaW5lVmlldy5hbGlnbmFibGUgPSBbXSkpLnB1c2gobm9kZSlcXG4gICAgdmFyIHdpZHRoID0gZGltcy53cmFwcGVyV2lkdGhcXG4gICAgbm9kZS5zdHlsZS5sZWZ0ID0gZGltcy5maXhlZFBvcyArIFxcXCJweFxcXCJcXG4gICAgaWYgKCF3aWRnZXQuY292ZXJHdXR0ZXIpIHtcXG4gICAgICB3aWR0aCAtPSBkaW1zLmd1dHRlclRvdGFsV2lkdGhcXG4gICAgICBub2RlLnN0eWxlLnBhZGRpbmdMZWZ0ID0gZGltcy5ndXR0ZXJUb3RhbFdpZHRoICsgXFxcInB4XFxcIlxcbiAgICB9XFxuICAgIG5vZGUuc3R5bGUud2lkdGggPSB3aWR0aCArIFxcXCJweFxcXCJcXG4gIH1cXG4gIGlmICh3aWRnZXQuY292ZXJHdXR0ZXIpIHtcXG4gICAgbm9kZS5zdHlsZS56SW5kZXggPSA1XFxuICAgIG5vZGUuc3R5bGUucG9zaXRpb24gPSBcXFwicmVsYXRpdmVcXFwiXFxuICAgIGlmICghd2lkZ2V0Lm5vSFNjcm9sbCkgeyBub2RlLnN0eWxlLm1hcmdpbkxlZnQgPSAtZGltcy5ndXR0ZXJUb3RhbFdpZHRoICsgXFxcInB4XFxcIiB9XFxuICB9XFxufVxcblxcbmZ1bmN0aW9uIHdpZGdldEhlaWdodCh3aWRnZXQpIHtcXG4gIGlmICh3aWRnZXQuaGVpZ2h0ICE9IG51bGwpIHsgcmV0dXJuIHdpZGdldC5oZWlnaHQgfVxcbiAgdmFyIGNtID0gd2lkZ2V0LmRvYy5jbVxcbiAgaWYgKCFjbSkgeyByZXR1cm4gMCB9XFxuICBpZiAoIWNvbnRhaW5zKGRvY3VtZW50LmJvZHksIHdpZGdldC5ub2RlKSkge1xcbiAgICB2YXIgcGFyZW50U3R5bGUgPSBcXFwicG9zaXRpb246IHJlbGF0aXZlO1xcXCJcXG4gICAgaWYgKHdpZGdldC5jb3Zlckd1dHRlcilcXG4gICAgICB7IHBhcmVudFN0eWxlICs9IFxcXCJtYXJnaW4tbGVmdDogLVxcXCIgKyBjbS5kaXNwbGF5Lmd1dHRlcnMub2Zmc2V0V2lkdGggKyBcXFwicHg7XFxcIiB9XFxuICAgIGlmICh3aWRnZXQubm9IU2Nyb2xsKVxcbiAgICAgIHsgcGFyZW50U3R5bGUgKz0gXFxcIndpZHRoOiBcXFwiICsgY20uZGlzcGxheS53cmFwcGVyLmNsaWVudFdpZHRoICsgXFxcInB4O1xcXCIgfVxcbiAgICByZW1vdmVDaGlsZHJlbkFuZEFkZChjbS5kaXNwbGF5Lm1lYXN1cmUsIGVsdChcXFwiZGl2XFxcIiwgW3dpZGdldC5ub2RlXSwgbnVsbCwgcGFyZW50U3R5bGUpKVxcbiAgfVxcbiAgcmV0dXJuIHdpZGdldC5oZWlnaHQgPSB3aWRnZXQubm9kZS5wYXJlbnROb2RlLm9mZnNldEhlaWdodFxcbn1cXG5cXG4vLyBSZXR1cm4gdHJ1ZSB3aGVuIHRoZSBnaXZlbiBtb3VzZSBldmVudCBoYXBwZW5lZCBpbiBhIHdpZGdldFxcbmZ1bmN0aW9uIGV2ZW50SW5XaWRnZXQoZGlzcGxheSwgZSkge1xcbiAgZm9yICh2YXIgbiA9IGVfdGFyZ2V0KGUpOyBuICE9IGRpc3BsYXkud3JhcHBlcjsgbiA9IG4ucGFyZW50Tm9kZSkge1xcbiAgICBpZiAoIW4gfHwgKG4ubm9kZVR5cGUgPT0gMSAmJiBuLmdldEF0dHJpYnV0ZShcXFwiY20taWdub3JlLWV2ZW50c1xcXCIpID09IFxcXCJ0cnVlXFxcIikgfHxcXG4gICAgICAgIChuLnBhcmVudE5vZGUgPT0gZGlzcGxheS5zaXplciAmJiBuICE9IGRpc3BsYXkubW92ZXIpKVxcbiAgICAgIHsgcmV0dXJuIHRydWUgfVxcbiAgfVxcbn1cXG5cXG4vLyBQT1NJVElPTiBNRUFTVVJFTUVOVFxcblxcbmZ1bmN0aW9uIHBhZGRpbmdUb3AoZGlzcGxheSkge3JldHVybiBkaXNwbGF5LmxpbmVTcGFjZS5vZmZzZXRUb3B9XFxuZnVuY3Rpb24gcGFkZGluZ1ZlcnQoZGlzcGxheSkge3JldHVybiBkaXNwbGF5Lm1vdmVyLm9mZnNldEhlaWdodCAtIGRpc3BsYXkubGluZVNwYWNlLm9mZnNldEhlaWdodH1cXG5mdW5jdGlvbiBwYWRkaW5nSChkaXNwbGF5KSB7XFxuICBpZiAoZGlzcGxheS5jYWNoZWRQYWRkaW5nSCkgeyByZXR1cm4gZGlzcGxheS5jYWNoZWRQYWRkaW5nSCB9XFxuICB2YXIgZSA9IHJlbW92ZUNoaWxkcmVuQW5kQWRkKGRpc3BsYXkubWVhc3VyZSwgZWx0KFxcXCJwcmVcXFwiLCBcXFwieFxcXCIpKVxcbiAgdmFyIHN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUgPyB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlKSA6IGUuY3VycmVudFN0eWxlXFxuICB2YXIgZGF0YSA9IHtsZWZ0OiBwYXJzZUludChzdHlsZS5wYWRkaW5nTGVmdCksIHJpZ2h0OiBwYXJzZUludChzdHlsZS5wYWRkaW5nUmlnaHQpfVxcbiAgaWYgKCFpc05hTihkYXRhLmxlZnQpICYmICFpc05hTihkYXRhLnJpZ2h0KSkgeyBkaXNwbGF5LmNhY2hlZFBhZGRpbmdIID0gZGF0YSB9XFxuICByZXR1cm4gZGF0YVxcbn1cXG5cXG5mdW5jdGlvbiBzY3JvbGxHYXAoY20pIHsgcmV0dXJuIHNjcm9sbGVyR2FwIC0gY20uZGlzcGxheS5uYXRpdmVCYXJXaWR0aCB9XFxuZnVuY3Rpb24gZGlzcGxheVdpZHRoKGNtKSB7XFxuICByZXR1cm4gY20uZGlzcGxheS5zY3JvbGxlci5jbGllbnRXaWR0aCAtIHNjcm9sbEdhcChjbSkgLSBjbS5kaXNwbGF5LmJhcldpZHRoXFxufVxcbmZ1bmN0aW9uIGRpc3BsYXlIZWlnaHQoY20pIHtcXG4gIHJldHVybiBjbS5kaXNwbGF5LnNjcm9sbGVyLmNsaWVudEhlaWdodCAtIHNjcm9sbEdhcChjbSkgLSBjbS5kaXNwbGF5LmJhckhlaWdodFxcbn1cXG5cXG4vLyBFbnN1cmUgdGhlIGxpbmVWaWV3LndyYXBwaW5nLmhlaWdodHMgYXJyYXkgaXMgcG9wdWxhdGVkLiBUaGlzIGlzXFxuLy8gYW4gYXJyYXkgb2YgYm90dG9tIG9mZnNldHMgZm9yIHRoZSBsaW5lcyB0aGF0IG1ha2UgdXAgYSBkcmF3blxcbi8vIGxpbmUuIFdoZW4gbGluZVdyYXBwaW5nIGlzIG9uLCB0aGVyZSBtaWdodCBiZSBtb3JlIHRoYW4gb25lXFxuLy8gaGVpZ2h0LlxcbmZ1bmN0aW9uIGVuc3VyZUxpbmVIZWlnaHRzKGNtLCBsaW5lVmlldywgcmVjdCkge1xcbiAgdmFyIHdyYXBwaW5nID0gY20ub3B0aW9ucy5saW5lV3JhcHBpbmdcXG4gIHZhciBjdXJXaWR0aCA9IHdyYXBwaW5nICYmIGRpc3BsYXlXaWR0aChjbSlcXG4gIGlmICghbGluZVZpZXcubWVhc3VyZS5oZWlnaHRzIHx8IHdyYXBwaW5nICYmIGxpbmVWaWV3Lm1lYXN1cmUud2lkdGggIT0gY3VyV2lkdGgpIHtcXG4gICAgdmFyIGhlaWdodHMgPSBsaW5lVmlldy5tZWFzdXJlLmhlaWdodHMgPSBbXVxcbiAgICBpZiAod3JhcHBpbmcpIHtcXG4gICAgICBsaW5lVmlldy5tZWFzdXJlLndpZHRoID0gY3VyV2lkdGhcXG4gICAgICB2YXIgcmVjdHMgPSBsaW5lVmlldy50ZXh0LmZpcnN0Q2hpbGQuZ2V0Q2xpZW50UmVjdHMoKVxcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVjdHMubGVuZ3RoIC0gMTsgaSsrKSB7XFxuICAgICAgICB2YXIgY3VyID0gcmVjdHNbaV0sIG5leHQgPSByZWN0c1tpICsgMV1cXG4gICAgICAgIGlmIChNYXRoLmFicyhjdXIuYm90dG9tIC0gbmV4dC5ib3R0b20pID4gMilcXG4gICAgICAgICAgeyBoZWlnaHRzLnB1c2goKGN1ci5ib3R0b20gKyBuZXh0LnRvcCkgLyAyIC0gcmVjdC50b3ApIH1cXG4gICAgICB9XFxuICAgIH1cXG4gICAgaGVpZ2h0cy5wdXNoKHJlY3QuYm90dG9tIC0gcmVjdC50b3ApXFxuICB9XFxufVxcblxcbi8vIEZpbmQgYSBsaW5lIG1hcCAobWFwcGluZyBjaGFyYWN0ZXIgb2Zmc2V0cyB0byB0ZXh0IG5vZGVzKSBhbmQgYVxcbi8vIG1lYXN1cmVtZW50IGNhY2hlIGZvciB0aGUgZ2l2ZW4gbGluZSBudW1iZXIuIChBIGxpbmUgdmlldyBtaWdodFxcbi8vIGNvbnRhaW4gbXVsdGlwbGUgbGluZXMgd2hlbiBjb2xsYXBzZWQgcmFuZ2VzIGFyZSBwcmVzZW50LilcXG5mdW5jdGlvbiBtYXBGcm9tTGluZVZpZXcobGluZVZpZXcsIGxpbmUsIGxpbmVOKSB7XFxuICBpZiAobGluZVZpZXcubGluZSA9PSBsaW5lKVxcbiAgICB7IHJldHVybiB7bWFwOiBsaW5lVmlldy5tZWFzdXJlLm1hcCwgY2FjaGU6IGxpbmVWaWV3Lm1lYXN1cmUuY2FjaGV9IH1cXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGluZVZpZXcucmVzdC5sZW5ndGg7IGkrKylcXG4gICAgeyBpZiAobGluZVZpZXcucmVzdFtpXSA9PSBsaW5lKVxcbiAgICAgIHsgcmV0dXJuIHttYXA6IGxpbmVWaWV3Lm1lYXN1cmUubWFwc1tpXSwgY2FjaGU6IGxpbmVWaWV3Lm1lYXN1cmUuY2FjaGVzW2ldfSB9IH1cXG4gIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IGxpbmVWaWV3LnJlc3QubGVuZ3RoOyBpJDErKylcXG4gICAgeyBpZiAobGluZU5vKGxpbmVWaWV3LnJlc3RbaSQxXSkgPiBsaW5lTilcXG4gICAgICB7IHJldHVybiB7bWFwOiBsaW5lVmlldy5tZWFzdXJlLm1hcHNbaSQxXSwgY2FjaGU6IGxpbmVWaWV3Lm1lYXN1cmUuY2FjaGVzW2kkMV0sIGJlZm9yZTogdHJ1ZX0gfSB9XFxufVxcblxcbi8vIFJlbmRlciBhIGxpbmUgaW50byB0aGUgaGlkZGVuIG5vZGUgZGlzcGxheS5leHRlcm5hbE1lYXN1cmVkLiBVc2VkXFxuLy8gd2hlbiBtZWFzdXJlbWVudCBpcyBuZWVkZWQgZm9yIGEgbGluZSB0aGF0J3Mgbm90IGluIHRoZSB2aWV3cG9ydC5cXG5mdW5jdGlvbiB1cGRhdGVFeHRlcm5hbE1lYXN1cmVtZW50KGNtLCBsaW5lKSB7XFxuICBsaW5lID0gdmlzdWFsTGluZShsaW5lKVxcbiAgdmFyIGxpbmVOID0gbGluZU5vKGxpbmUpXFxuICB2YXIgdmlldyA9IGNtLmRpc3BsYXkuZXh0ZXJuYWxNZWFzdXJlZCA9IG5ldyBMaW5lVmlldyhjbS5kb2MsIGxpbmUsIGxpbmVOKVxcbiAgdmlldy5saW5lTiA9IGxpbmVOXFxuICB2YXIgYnVpbHQgPSB2aWV3LmJ1aWx0ID0gYnVpbGRMaW5lQ29udGVudChjbSwgdmlldylcXG4gIHZpZXcudGV4dCA9IGJ1aWx0LnByZVxcbiAgcmVtb3ZlQ2hpbGRyZW5BbmRBZGQoY20uZGlzcGxheS5saW5lTWVhc3VyZSwgYnVpbHQucHJlKVxcbiAgcmV0dXJuIHZpZXdcXG59XFxuXFxuLy8gR2V0IGEge3RvcCwgYm90dG9tLCBsZWZ0LCByaWdodH0gYm94IChpbiBsaW5lLWxvY2FsIGNvb3JkaW5hdGVzKVxcbi8vIGZvciBhIGdpdmVuIGNoYXJhY3Rlci5cXG5mdW5jdGlvbiBtZWFzdXJlQ2hhcihjbSwgbGluZSwgY2gsIGJpYXMpIHtcXG4gIHJldHVybiBtZWFzdXJlQ2hhclByZXBhcmVkKGNtLCBwcmVwYXJlTWVhc3VyZUZvckxpbmUoY20sIGxpbmUpLCBjaCwgYmlhcylcXG59XFxuXFxuLy8gRmluZCBhIGxpbmUgdmlldyB0aGF0IGNvcnJlc3BvbmRzIHRvIHRoZSBnaXZlbiBsaW5lIG51bWJlci5cXG5mdW5jdGlvbiBmaW5kVmlld0ZvckxpbmUoY20sIGxpbmVOKSB7XFxuICBpZiAobGluZU4gPj0gY20uZGlzcGxheS52aWV3RnJvbSAmJiBsaW5lTiA8IGNtLmRpc3BsYXkudmlld1RvKVxcbiAgICB7IHJldHVybiBjbS5kaXNwbGF5LnZpZXdbZmluZFZpZXdJbmRleChjbSwgbGluZU4pXSB9XFxuICB2YXIgZXh0ID0gY20uZGlzcGxheS5leHRlcm5hbE1lYXN1cmVkXFxuICBpZiAoZXh0ICYmIGxpbmVOID49IGV4dC5saW5lTiAmJiBsaW5lTiA8IGV4dC5saW5lTiArIGV4dC5zaXplKVxcbiAgICB7IHJldHVybiBleHQgfVxcbn1cXG5cXG4vLyBNZWFzdXJlbWVudCBjYW4gYmUgc3BsaXQgaW4gdHdvIHN0ZXBzLCB0aGUgc2V0LXVwIHdvcmsgdGhhdFxcbi8vIGFwcGxpZXMgdG8gdGhlIHdob2xlIGxpbmUsIGFuZCB0aGUgbWVhc3VyZW1lbnQgb2YgdGhlIGFjdHVhbFxcbi8vIGNoYXJhY3Rlci4gRnVuY3Rpb25zIGxpa2UgY29vcmRzQ2hhciwgdGhhdCBuZWVkIHRvIGRvIGEgbG90IG9mXFxuLy8gbWVhc3VyZW1lbnRzIGluIGEgcm93LCBjYW4gdGh1cyBlbnN1cmUgdGhhdCB0aGUgc2V0LXVwIHdvcmsgaXNcXG4vLyBvbmx5IGRvbmUgb25jZS5cXG5mdW5jdGlvbiBwcmVwYXJlTWVhc3VyZUZvckxpbmUoY20sIGxpbmUpIHtcXG4gIHZhciBsaW5lTiA9IGxpbmVObyhsaW5lKVxcbiAgdmFyIHZpZXcgPSBmaW5kVmlld0ZvckxpbmUoY20sIGxpbmVOKVxcbiAgaWYgKHZpZXcgJiYgIXZpZXcudGV4dCkge1xcbiAgICB2aWV3ID0gbnVsbFxcbiAgfSBlbHNlIGlmICh2aWV3ICYmIHZpZXcuY2hhbmdlcykge1xcbiAgICB1cGRhdGVMaW5lRm9yQ2hhbmdlcyhjbSwgdmlldywgbGluZU4sIGdldERpbWVuc2lvbnMoY20pKVxcbiAgICBjbS5jdXJPcC5mb3JjZVVwZGF0ZSA9IHRydWVcXG4gIH1cXG4gIGlmICghdmlldylcXG4gICAgeyB2aWV3ID0gdXBkYXRlRXh0ZXJuYWxNZWFzdXJlbWVudChjbSwgbGluZSkgfVxcblxcbiAgdmFyIGluZm8gPSBtYXBGcm9tTGluZVZpZXcodmlldywgbGluZSwgbGluZU4pXFxuICByZXR1cm4ge1xcbiAgICBsaW5lOiBsaW5lLCB2aWV3OiB2aWV3LCByZWN0OiBudWxsLFxcbiAgICBtYXA6IGluZm8ubWFwLCBjYWNoZTogaW5mby5jYWNoZSwgYmVmb3JlOiBpbmZvLmJlZm9yZSxcXG4gICAgaGFzSGVpZ2h0czogZmFsc2VcXG4gIH1cXG59XFxuXFxuLy8gR2l2ZW4gYSBwcmVwYXJlZCBtZWFzdXJlbWVudCBvYmplY3QsIG1lYXN1cmVzIHRoZSBwb3NpdGlvbiBvZiBhblxcbi8vIGFjdHVhbCBjaGFyYWN0ZXIgKG9yIGZldGNoZXMgaXQgZnJvbSB0aGUgY2FjaGUpLlxcbmZ1bmN0aW9uIG1lYXN1cmVDaGFyUHJlcGFyZWQoY20sIHByZXBhcmVkLCBjaCwgYmlhcywgdmFySGVpZ2h0KSB7XFxuICBpZiAocHJlcGFyZWQuYmVmb3JlKSB7IGNoID0gLTEgfVxcbiAgdmFyIGtleSA9IGNoICsgKGJpYXMgfHwgXFxcIlxcXCIpLCBmb3VuZFxcbiAgaWYgKHByZXBhcmVkLmNhY2hlLmhhc093blByb3BlcnR5KGtleSkpIHtcXG4gICAgZm91bmQgPSBwcmVwYXJlZC5jYWNoZVtrZXldXFxuICB9IGVsc2Uge1xcbiAgICBpZiAoIXByZXBhcmVkLnJlY3QpXFxuICAgICAgeyBwcmVwYXJlZC5yZWN0ID0gcHJlcGFyZWQudmlldy50ZXh0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpIH1cXG4gICAgaWYgKCFwcmVwYXJlZC5oYXNIZWlnaHRzKSB7XFxuICAgICAgZW5zdXJlTGluZUhlaWdodHMoY20sIHByZXBhcmVkLnZpZXcsIHByZXBhcmVkLnJlY3QpXFxuICAgICAgcHJlcGFyZWQuaGFzSGVpZ2h0cyA9IHRydWVcXG4gICAgfVxcbiAgICBmb3VuZCA9IG1lYXN1cmVDaGFySW5uZXIoY20sIHByZXBhcmVkLCBjaCwgYmlhcylcXG4gICAgaWYgKCFmb3VuZC5ib2d1cykgeyBwcmVwYXJlZC5jYWNoZVtrZXldID0gZm91bmQgfVxcbiAgfVxcbiAgcmV0dXJuIHtsZWZ0OiBmb3VuZC5sZWZ0LCByaWdodDogZm91bmQucmlnaHQsXFxuICAgICAgICAgIHRvcDogdmFySGVpZ2h0ID8gZm91bmQucnRvcCA6IGZvdW5kLnRvcCxcXG4gICAgICAgICAgYm90dG9tOiB2YXJIZWlnaHQgPyBmb3VuZC5yYm90dG9tIDogZm91bmQuYm90dG9tfVxcbn1cXG5cXG52YXIgbnVsbFJlY3QgPSB7bGVmdDogMCwgcmlnaHQ6IDAsIHRvcDogMCwgYm90dG9tOiAwfVxcblxcbmZ1bmN0aW9uIG5vZGVBbmRPZmZzZXRJbkxpbmVNYXAobWFwLCBjaCwgYmlhcykge1xcbiAgdmFyIG5vZGUsIHN0YXJ0LCBlbmQsIGNvbGxhcHNlLCBtU3RhcnQsIG1FbmRcXG4gIC8vIEZpcnN0LCBzZWFyY2ggdGhlIGxpbmUgbWFwIGZvciB0aGUgdGV4dCBub2RlIGNvcnJlc3BvbmRpbmcgdG8sXFxuICAvLyBvciBjbG9zZXN0IHRvLCB0aGUgdGFyZ2V0IGNoYXJhY3Rlci5cXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbWFwLmxlbmd0aDsgaSArPSAzKSB7XFxuICAgIG1TdGFydCA9IG1hcFtpXVxcbiAgICBtRW5kID0gbWFwW2kgKyAxXVxcbiAgICBpZiAoY2ggPCBtU3RhcnQpIHtcXG4gICAgICBzdGFydCA9IDA7IGVuZCA9IDFcXG4gICAgICBjb2xsYXBzZSA9IFxcXCJsZWZ0XFxcIlxcbiAgICB9IGVsc2UgaWYgKGNoIDwgbUVuZCkge1xcbiAgICAgIHN0YXJ0ID0gY2ggLSBtU3RhcnRcXG4gICAgICBlbmQgPSBzdGFydCArIDFcXG4gICAgfSBlbHNlIGlmIChpID09IG1hcC5sZW5ndGggLSAzIHx8IGNoID09IG1FbmQgJiYgbWFwW2kgKyAzXSA+IGNoKSB7XFxuICAgICAgZW5kID0gbUVuZCAtIG1TdGFydFxcbiAgICAgIHN0YXJ0ID0gZW5kIC0gMVxcbiAgICAgIGlmIChjaCA+PSBtRW5kKSB7IGNvbGxhcHNlID0gXFxcInJpZ2h0XFxcIiB9XFxuICAgIH1cXG4gICAgaWYgKHN0YXJ0ICE9IG51bGwpIHtcXG4gICAgICBub2RlID0gbWFwW2kgKyAyXVxcbiAgICAgIGlmIChtU3RhcnQgPT0gbUVuZCAmJiBiaWFzID09IChub2RlLmluc2VydExlZnQgPyBcXFwibGVmdFxcXCIgOiBcXFwicmlnaHRcXFwiKSlcXG4gICAgICAgIHsgY29sbGFwc2UgPSBiaWFzIH1cXG4gICAgICBpZiAoYmlhcyA9PSBcXFwibGVmdFxcXCIgJiYgc3RhcnQgPT0gMClcXG4gICAgICAgIHsgd2hpbGUgKGkgJiYgbWFwW2kgLSAyXSA9PSBtYXBbaSAtIDNdICYmIG1hcFtpIC0gMV0uaW5zZXJ0TGVmdCkge1xcbiAgICAgICAgICBub2RlID0gbWFwWyhpIC09IDMpICsgMl1cXG4gICAgICAgICAgY29sbGFwc2UgPSBcXFwibGVmdFxcXCJcXG4gICAgICAgIH0gfVxcbiAgICAgIGlmIChiaWFzID09IFxcXCJyaWdodFxcXCIgJiYgc3RhcnQgPT0gbUVuZCAtIG1TdGFydClcXG4gICAgICAgIHsgd2hpbGUgKGkgPCBtYXAubGVuZ3RoIC0gMyAmJiBtYXBbaSArIDNdID09IG1hcFtpICsgNF0gJiYgIW1hcFtpICsgNV0uaW5zZXJ0TGVmdCkge1xcbiAgICAgICAgICBub2RlID0gbWFwWyhpICs9IDMpICsgMl1cXG4gICAgICAgICAgY29sbGFwc2UgPSBcXFwicmlnaHRcXFwiXFxuICAgICAgICB9IH1cXG4gICAgICBicmVha1xcbiAgICB9XFxuICB9XFxuICByZXR1cm4ge25vZGU6IG5vZGUsIHN0YXJ0OiBzdGFydCwgZW5kOiBlbmQsIGNvbGxhcHNlOiBjb2xsYXBzZSwgY292ZXJTdGFydDogbVN0YXJ0LCBjb3ZlckVuZDogbUVuZH1cXG59XFxuXFxuZnVuY3Rpb24gZ2V0VXNlZnVsUmVjdChyZWN0cywgYmlhcykge1xcbiAgdmFyIHJlY3QgPSBudWxsUmVjdFxcbiAgaWYgKGJpYXMgPT0gXFxcImxlZnRcXFwiKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcmVjdHMubGVuZ3RoOyBpKyspIHtcXG4gICAgaWYgKChyZWN0ID0gcmVjdHNbaV0pLmxlZnQgIT0gcmVjdC5yaWdodCkgeyBicmVhayB9XFxuICB9IH0gZWxzZSB7IGZvciAodmFyIGkkMSA9IHJlY3RzLmxlbmd0aCAtIDE7IGkkMSA+PSAwOyBpJDEtLSkge1xcbiAgICBpZiAoKHJlY3QgPSByZWN0c1tpJDFdKS5sZWZ0ICE9IHJlY3QucmlnaHQpIHsgYnJlYWsgfVxcbiAgfSB9XFxuICByZXR1cm4gcmVjdFxcbn1cXG5cXG5mdW5jdGlvbiBtZWFzdXJlQ2hhcklubmVyKGNtLCBwcmVwYXJlZCwgY2gsIGJpYXMpIHtcXG4gIHZhciBwbGFjZSA9IG5vZGVBbmRPZmZzZXRJbkxpbmVNYXAocHJlcGFyZWQubWFwLCBjaCwgYmlhcylcXG4gIHZhciBub2RlID0gcGxhY2Uubm9kZSwgc3RhcnQgPSBwbGFjZS5zdGFydCwgZW5kID0gcGxhY2UuZW5kLCBjb2xsYXBzZSA9IHBsYWNlLmNvbGxhcHNlXFxuXFxuICB2YXIgcmVjdFxcbiAgaWYgKG5vZGUubm9kZVR5cGUgPT0gMykgeyAvLyBJZiBpdCBpcyBhIHRleHQgbm9kZSwgdXNlIGEgcmFuZ2UgdG8gcmV0cmlldmUgdGhlIGNvb3JkaW5hdGVzLlxcbiAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCA0OyBpJDErKykgeyAvLyBSZXRyeSBhIG1heGltdW0gb2YgNCB0aW1lcyB3aGVuIG5vbnNlbnNlIHJlY3RhbmdsZXMgYXJlIHJldHVybmVkXFxuICAgICAgd2hpbGUgKHN0YXJ0ICYmIGlzRXh0ZW5kaW5nQ2hhcihwcmVwYXJlZC5saW5lLnRleHQuY2hhckF0KHBsYWNlLmNvdmVyU3RhcnQgKyBzdGFydCkpKSB7IC0tc3RhcnQgfVxcbiAgICAgIHdoaWxlIChwbGFjZS5jb3ZlclN0YXJ0ICsgZW5kIDwgcGxhY2UuY292ZXJFbmQgJiYgaXNFeHRlbmRpbmdDaGFyKHByZXBhcmVkLmxpbmUudGV4dC5jaGFyQXQocGxhY2UuY292ZXJTdGFydCArIGVuZCkpKSB7ICsrZW5kIH1cXG4gICAgICBpZiAoaWUgJiYgaWVfdmVyc2lvbiA8IDkgJiYgc3RhcnQgPT0gMCAmJiBlbmQgPT0gcGxhY2UuY292ZXJFbmQgLSBwbGFjZS5jb3ZlclN0YXJ0KVxcbiAgICAgICAgeyByZWN0ID0gbm9kZS5wYXJlbnROb2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpIH1cXG4gICAgICBlbHNlXFxuICAgICAgICB7IHJlY3QgPSBnZXRVc2VmdWxSZWN0KHJhbmdlKG5vZGUsIHN0YXJ0LCBlbmQpLmdldENsaWVudFJlY3RzKCksIGJpYXMpIH1cXG4gICAgICBpZiAocmVjdC5sZWZ0IHx8IHJlY3QucmlnaHQgfHwgc3RhcnQgPT0gMCkgeyBicmVhayB9XFxuICAgICAgZW5kID0gc3RhcnRcXG4gICAgICBzdGFydCA9IHN0YXJ0IC0gMVxcbiAgICAgIGNvbGxhcHNlID0gXFxcInJpZ2h0XFxcIlxcbiAgICB9XFxuICAgIGlmIChpZSAmJiBpZV92ZXJzaW9uIDwgMTEpIHsgcmVjdCA9IG1heWJlVXBkYXRlUmVjdEZvclpvb21pbmcoY20uZGlzcGxheS5tZWFzdXJlLCByZWN0KSB9XFxuICB9IGVsc2UgeyAvLyBJZiBpdCBpcyBhIHdpZGdldCwgc2ltcGx5IGdldCB0aGUgYm94IGZvciB0aGUgd2hvbGUgd2lkZ2V0LlxcbiAgICBpZiAoc3RhcnQgPiAwKSB7IGNvbGxhcHNlID0gYmlhcyA9IFxcXCJyaWdodFxcXCIgfVxcbiAgICB2YXIgcmVjdHNcXG4gICAgaWYgKGNtLm9wdGlvbnMubGluZVdyYXBwaW5nICYmIChyZWN0cyA9IG5vZGUuZ2V0Q2xpZW50UmVjdHMoKSkubGVuZ3RoID4gMSlcXG4gICAgICB7IHJlY3QgPSByZWN0c1tiaWFzID09IFxcXCJyaWdodFxcXCIgPyByZWN0cy5sZW5ndGggLSAxIDogMF0gfVxcbiAgICBlbHNlXFxuICAgICAgeyByZWN0ID0gbm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSB9XFxuICB9XFxuICBpZiAoaWUgJiYgaWVfdmVyc2lvbiA8IDkgJiYgIXN0YXJ0ICYmICghcmVjdCB8fCAhcmVjdC5sZWZ0ICYmICFyZWN0LnJpZ2h0KSkge1xcbiAgICB2YXIgclNwYW4gPSBub2RlLnBhcmVudE5vZGUuZ2V0Q2xpZW50UmVjdHMoKVswXVxcbiAgICBpZiAoclNwYW4pXFxuICAgICAgeyByZWN0ID0ge2xlZnQ6IHJTcGFuLmxlZnQsIHJpZ2h0OiByU3Bhbi5sZWZ0ICsgY2hhcldpZHRoKGNtLmRpc3BsYXkpLCB0b3A6IHJTcGFuLnRvcCwgYm90dG9tOiByU3Bhbi5ib3R0b219IH1cXG4gICAgZWxzZVxcbiAgICAgIHsgcmVjdCA9IG51bGxSZWN0IH1cXG4gIH1cXG5cXG4gIHZhciBydG9wID0gcmVjdC50b3AgLSBwcmVwYXJlZC5yZWN0LnRvcCwgcmJvdCA9IHJlY3QuYm90dG9tIC0gcHJlcGFyZWQucmVjdC50b3BcXG4gIHZhciBtaWQgPSAocnRvcCArIHJib3QpIC8gMlxcbiAgdmFyIGhlaWdodHMgPSBwcmVwYXJlZC52aWV3Lm1lYXN1cmUuaGVpZ2h0c1xcbiAgdmFyIGkgPSAwXFxuICBmb3IgKDsgaSA8IGhlaWdodHMubGVuZ3RoIC0gMTsgaSsrKVxcbiAgICB7IGlmIChtaWQgPCBoZWlnaHRzW2ldKSB7IGJyZWFrIH0gfVxcbiAgdmFyIHRvcCA9IGkgPyBoZWlnaHRzW2kgLSAxXSA6IDAsIGJvdCA9IGhlaWdodHNbaV1cXG4gIHZhciByZXN1bHQgPSB7bGVmdDogKGNvbGxhcHNlID09IFxcXCJyaWdodFxcXCIgPyByZWN0LnJpZ2h0IDogcmVjdC5sZWZ0KSAtIHByZXBhcmVkLnJlY3QubGVmdCxcXG4gICAgICAgICAgICAgICAgcmlnaHQ6IChjb2xsYXBzZSA9PSBcXFwibGVmdFxcXCIgPyByZWN0LmxlZnQgOiByZWN0LnJpZ2h0KSAtIHByZXBhcmVkLnJlY3QubGVmdCxcXG4gICAgICAgICAgICAgICAgdG9wOiB0b3AsIGJvdHRvbTogYm90fVxcbiAgaWYgKCFyZWN0LmxlZnQgJiYgIXJlY3QucmlnaHQpIHsgcmVzdWx0LmJvZ3VzID0gdHJ1ZSB9XFxuICBpZiAoIWNtLm9wdGlvbnMuc2luZ2xlQ3Vyc29ySGVpZ2h0UGVyTGluZSkgeyByZXN1bHQucnRvcCA9IHJ0b3A7IHJlc3VsdC5yYm90dG9tID0gcmJvdCB9XFxuXFxuICByZXR1cm4gcmVzdWx0XFxufVxcblxcbi8vIFdvcmsgYXJvdW5kIHByb2JsZW0gd2l0aCBib3VuZGluZyBjbGllbnQgcmVjdHMgb24gcmFuZ2VzIGJlaW5nXFxuLy8gcmV0dXJuZWQgaW5jb3JyZWN0bHkgd2hlbiB6b29tZWQgb24gSUUxMCBhbmQgYmVsb3cuXFxuZnVuY3Rpb24gbWF5YmVVcGRhdGVSZWN0Rm9yWm9vbWluZyhtZWFzdXJlLCByZWN0KSB7XFxuICBpZiAoIXdpbmRvdy5zY3JlZW4gfHwgc2NyZWVuLmxvZ2ljYWxYRFBJID09IG51bGwgfHxcXG4gICAgICBzY3JlZW4ubG9naWNhbFhEUEkgPT0gc2NyZWVuLmRldmljZVhEUEkgfHwgIWhhc0JhZFpvb21lZFJlY3RzKG1lYXN1cmUpKVxcbiAgICB7IHJldHVybiByZWN0IH1cXG4gIHZhciBzY2FsZVggPSBzY3JlZW4ubG9naWNhbFhEUEkgLyBzY3JlZW4uZGV2aWNlWERQSVxcbiAgdmFyIHNjYWxlWSA9IHNjcmVlbi5sb2dpY2FsWURQSSAvIHNjcmVlbi5kZXZpY2VZRFBJXFxuICByZXR1cm4ge2xlZnQ6IHJlY3QubGVmdCAqIHNjYWxlWCwgcmlnaHQ6IHJlY3QucmlnaHQgKiBzY2FsZVgsXFxuICAgICAgICAgIHRvcDogcmVjdC50b3AgKiBzY2FsZVksIGJvdHRvbTogcmVjdC5ib3R0b20gKiBzY2FsZVl9XFxufVxcblxcbmZ1bmN0aW9uIGNsZWFyTGluZU1lYXN1cmVtZW50Q2FjaGVGb3IobGluZVZpZXcpIHtcXG4gIGlmIChsaW5lVmlldy5tZWFzdXJlKSB7XFxuICAgIGxpbmVWaWV3Lm1lYXN1cmUuY2FjaGUgPSB7fVxcbiAgICBsaW5lVmlldy5tZWFzdXJlLmhlaWdodHMgPSBudWxsXFxuICAgIGlmIChsaW5lVmlldy5yZXN0KSB7IGZvciAodmFyIGkgPSAwOyBpIDwgbGluZVZpZXcucmVzdC5sZW5ndGg7IGkrKylcXG4gICAgICB7IGxpbmVWaWV3Lm1lYXN1cmUuY2FjaGVzW2ldID0ge30gfSB9XFxuICB9XFxufVxcblxcbmZ1bmN0aW9uIGNsZWFyTGluZU1lYXN1cmVtZW50Q2FjaGUoY20pIHtcXG4gIGNtLmRpc3BsYXkuZXh0ZXJuYWxNZWFzdXJlID0gbnVsbFxcbiAgcmVtb3ZlQ2hpbGRyZW4oY20uZGlzcGxheS5saW5lTWVhc3VyZSlcXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY20uZGlzcGxheS52aWV3Lmxlbmd0aDsgaSsrKVxcbiAgICB7IGNsZWFyTGluZU1lYXN1cmVtZW50Q2FjaGVGb3IoY20uZGlzcGxheS52aWV3W2ldKSB9XFxufVxcblxcbmZ1bmN0aW9uIGNsZWFyQ2FjaGVzKGNtKSB7XFxuICBjbGVhckxpbmVNZWFzdXJlbWVudENhY2hlKGNtKVxcbiAgY20uZGlzcGxheS5jYWNoZWRDaGFyV2lkdGggPSBjbS5kaXNwbGF5LmNhY2hlZFRleHRIZWlnaHQgPSBjbS5kaXNwbGF5LmNhY2hlZFBhZGRpbmdIID0gbnVsbFxcbiAgaWYgKCFjbS5vcHRpb25zLmxpbmVXcmFwcGluZykgeyBjbS5kaXNwbGF5Lm1heExpbmVDaGFuZ2VkID0gdHJ1ZSB9XFxuICBjbS5kaXNwbGF5LmxpbmVOdW1DaGFycyA9IG51bGxcXG59XFxuXFxuZnVuY3Rpb24gcGFnZVNjcm9sbFgoKSB7IHJldHVybiB3aW5kb3cucGFnZVhPZmZzZXQgfHwgKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCB8fCBkb2N1bWVudC5ib2R5KS5zY3JvbGxMZWZ0IH1cXG5mdW5jdGlvbiBwYWdlU2Nyb2xsWSgpIHsgcmV0dXJuIHdpbmRvdy5wYWdlWU9mZnNldCB8fCAoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50IHx8IGRvY3VtZW50LmJvZHkpLnNjcm9sbFRvcCB9XFxuXFxuLy8gQ29udmVydHMgYSB7dG9wLCBib3R0b20sIGxlZnQsIHJpZ2h0fSBib3ggZnJvbSBsaW5lLWxvY2FsXFxuLy8gY29vcmRpbmF0ZXMgaW50byBhbm90aGVyIGNvb3JkaW5hdGUgc3lzdGVtLiBDb250ZXh0IG1heSBiZSBvbmUgb2ZcXG4vLyBcXFwibGluZVxcXCIsIFxcXCJkaXZcXFwiIChkaXNwbGF5LmxpbmVEaXYpLCBcXFwibG9jYWxcXFwiLi9udWxsIChlZGl0b3IpLCBcXFwid2luZG93XFxcIixcXG4vLyBvciBcXFwicGFnZVxcXCIuXFxuZnVuY3Rpb24gaW50b0Nvb3JkU3lzdGVtKGNtLCBsaW5lT2JqLCByZWN0LCBjb250ZXh0KSB7XFxuICBpZiAobGluZU9iai53aWRnZXRzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgbGluZU9iai53aWRnZXRzLmxlbmd0aDsgKytpKSB7IGlmIChsaW5lT2JqLndpZGdldHNbaV0uYWJvdmUpIHtcXG4gICAgdmFyIHNpemUgPSB3aWRnZXRIZWlnaHQobGluZU9iai53aWRnZXRzW2ldKVxcbiAgICByZWN0LnRvcCArPSBzaXplOyByZWN0LmJvdHRvbSArPSBzaXplXFxuICB9IH0gfVxcbiAgaWYgKGNvbnRleHQgPT0gXFxcImxpbmVcXFwiKSB7IHJldHVybiByZWN0IH1cXG4gIGlmICghY29udGV4dCkgeyBjb250ZXh0ID0gXFxcImxvY2FsXFxcIiB9XFxuICB2YXIgeU9mZiA9IGhlaWdodEF0TGluZShsaW5lT2JqKVxcbiAgaWYgKGNvbnRleHQgPT0gXFxcImxvY2FsXFxcIikgeyB5T2ZmICs9IHBhZGRpbmdUb3AoY20uZGlzcGxheSkgfVxcbiAgZWxzZSB7IHlPZmYgLT0gY20uZGlzcGxheS52aWV3T2Zmc2V0IH1cXG4gIGlmIChjb250ZXh0ID09IFxcXCJwYWdlXFxcIiB8fCBjb250ZXh0ID09IFxcXCJ3aW5kb3dcXFwiKSB7XFxuICAgIHZhciBsT2ZmID0gY20uZGlzcGxheS5saW5lU3BhY2UuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClcXG4gICAgeU9mZiArPSBsT2ZmLnRvcCArIChjb250ZXh0ID09IFxcXCJ3aW5kb3dcXFwiID8gMCA6IHBhZ2VTY3JvbGxZKCkpXFxuICAgIHZhciB4T2ZmID0gbE9mZi5sZWZ0ICsgKGNvbnRleHQgPT0gXFxcIndpbmRvd1xcXCIgPyAwIDogcGFnZVNjcm9sbFgoKSlcXG4gICAgcmVjdC5sZWZ0ICs9IHhPZmY7IHJlY3QucmlnaHQgKz0geE9mZlxcbiAgfVxcbiAgcmVjdC50b3AgKz0geU9mZjsgcmVjdC5ib3R0b20gKz0geU9mZlxcbiAgcmV0dXJuIHJlY3RcXG59XFxuXFxuLy8gQ292ZXJ0cyBhIGJveCBmcm9tIFxcXCJkaXZcXFwiIGNvb3JkcyB0byBhbm90aGVyIGNvb3JkaW5hdGUgc3lzdGVtLlxcbi8vIENvbnRleHQgbWF5IGJlIFxcXCJ3aW5kb3dcXFwiLCBcXFwicGFnZVxcXCIsIFxcXCJkaXZcXFwiLCBvciBcXFwibG9jYWxcXFwiLi9udWxsLlxcbmZ1bmN0aW9uIGZyb21Db29yZFN5c3RlbShjbSwgY29vcmRzLCBjb250ZXh0KSB7XFxuICBpZiAoY29udGV4dCA9PSBcXFwiZGl2XFxcIikgeyByZXR1cm4gY29vcmRzIH1cXG4gIHZhciBsZWZ0ID0gY29vcmRzLmxlZnQsIHRvcCA9IGNvb3Jkcy50b3BcXG4gIC8vIEZpcnN0IG1vdmUgaW50byBcXFwicGFnZVxcXCIgY29vcmRpbmF0ZSBzeXN0ZW1cXG4gIGlmIChjb250ZXh0ID09IFxcXCJwYWdlXFxcIikge1xcbiAgICBsZWZ0IC09IHBhZ2VTY3JvbGxYKClcXG4gICAgdG9wIC09IHBhZ2VTY3JvbGxZKClcXG4gIH0gZWxzZSBpZiAoY29udGV4dCA9PSBcXFwibG9jYWxcXFwiIHx8ICFjb250ZXh0KSB7XFxuICAgIHZhciBsb2NhbEJveCA9IGNtLmRpc3BsYXkuc2l6ZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClcXG4gICAgbGVmdCArPSBsb2NhbEJveC5sZWZ0XFxuICAgIHRvcCArPSBsb2NhbEJveC50b3BcXG4gIH1cXG5cXG4gIHZhciBsaW5lU3BhY2VCb3ggPSBjbS5kaXNwbGF5LmxpbmVTcGFjZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxcbiAgcmV0dXJuIHtsZWZ0OiBsZWZ0IC0gbGluZVNwYWNlQm94LmxlZnQsIHRvcDogdG9wIC0gbGluZVNwYWNlQm94LnRvcH1cXG59XFxuXFxuZnVuY3Rpb24gY2hhckNvb3JkcyhjbSwgcG9zLCBjb250ZXh0LCBsaW5lT2JqLCBiaWFzKSB7XFxuICBpZiAoIWxpbmVPYmopIHsgbGluZU9iaiA9IGdldExpbmUoY20uZG9jLCBwb3MubGluZSkgfVxcbiAgcmV0dXJuIGludG9Db29yZFN5c3RlbShjbSwgbGluZU9iaiwgbWVhc3VyZUNoYXIoY20sIGxpbmVPYmosIHBvcy5jaCwgYmlhcyksIGNvbnRleHQpXFxufVxcblxcbi8vIFJldHVybnMgYSBib3ggZm9yIGEgZ2l2ZW4gY3Vyc29yIHBvc2l0aW9uLCB3aGljaCBtYXkgaGF2ZSBhblxcbi8vICdvdGhlcicgcHJvcGVydHkgY29udGFpbmluZyB0aGUgcG9zaXRpb24gb2YgdGhlIHNlY29uZGFyeSBjdXJzb3JcXG4vLyBvbiBhIGJpZGkgYm91bmRhcnkuXFxuZnVuY3Rpb24gY3Vyc29yQ29vcmRzKGNtLCBwb3MsIGNvbnRleHQsIGxpbmVPYmosIHByZXBhcmVkTWVhc3VyZSwgdmFySGVpZ2h0KSB7XFxuICBsaW5lT2JqID0gbGluZU9iaiB8fCBnZXRMaW5lKGNtLmRvYywgcG9zLmxpbmUpXFxuICBpZiAoIXByZXBhcmVkTWVhc3VyZSkgeyBwcmVwYXJlZE1lYXN1cmUgPSBwcmVwYXJlTWVhc3VyZUZvckxpbmUoY20sIGxpbmVPYmopIH1cXG4gIGZ1bmN0aW9uIGdldChjaCwgcmlnaHQpIHtcXG4gICAgdmFyIG0gPSBtZWFzdXJlQ2hhclByZXBhcmVkKGNtLCBwcmVwYXJlZE1lYXN1cmUsIGNoLCByaWdodCA/IFxcXCJyaWdodFxcXCIgOiBcXFwibGVmdFxcXCIsIHZhckhlaWdodClcXG4gICAgaWYgKHJpZ2h0KSB7IG0ubGVmdCA9IG0ucmlnaHQ7IH0gZWxzZSB7IG0ucmlnaHQgPSBtLmxlZnQgfVxcbiAgICByZXR1cm4gaW50b0Nvb3JkU3lzdGVtKGNtLCBsaW5lT2JqLCBtLCBjb250ZXh0KVxcbiAgfVxcbiAgZnVuY3Rpb24gZ2V0QmlkaShjaCwgcGFydFBvcykge1xcbiAgICB2YXIgcGFydCA9IG9yZGVyW3BhcnRQb3NdLCByaWdodCA9IHBhcnQubGV2ZWwgJSAyXFxuICAgIGlmIChjaCA9PSBiaWRpTGVmdChwYXJ0KSAmJiBwYXJ0UG9zICYmIHBhcnQubGV2ZWwgPCBvcmRlcltwYXJ0UG9zIC0gMV0ubGV2ZWwpIHtcXG4gICAgICBwYXJ0ID0gb3JkZXJbLS1wYXJ0UG9zXVxcbiAgICAgIGNoID0gYmlkaVJpZ2h0KHBhcnQpIC0gKHBhcnQubGV2ZWwgJSAyID8gMCA6IDEpXFxuICAgICAgcmlnaHQgPSB0cnVlXFxuICAgIH0gZWxzZSBpZiAoY2ggPT0gYmlkaVJpZ2h0KHBhcnQpICYmIHBhcnRQb3MgPCBvcmRlci5sZW5ndGggLSAxICYmIHBhcnQubGV2ZWwgPCBvcmRlcltwYXJ0UG9zICsgMV0ubGV2ZWwpIHtcXG4gICAgICBwYXJ0ID0gb3JkZXJbKytwYXJ0UG9zXVxcbiAgICAgIGNoID0gYmlkaUxlZnQocGFydCkgLSBwYXJ0LmxldmVsICUgMlxcbiAgICAgIHJpZ2h0ID0gZmFsc2VcXG4gICAgfVxcbiAgICBpZiAocmlnaHQgJiYgY2ggPT0gcGFydC50byAmJiBjaCA+IHBhcnQuZnJvbSkgeyByZXR1cm4gZ2V0KGNoIC0gMSkgfVxcbiAgICByZXR1cm4gZ2V0KGNoLCByaWdodClcXG4gIH1cXG4gIHZhciBvcmRlciA9IGdldE9yZGVyKGxpbmVPYmopLCBjaCA9IHBvcy5jaFxcbiAgaWYgKCFvcmRlcikgeyByZXR1cm4gZ2V0KGNoKSB9XFxuICB2YXIgcGFydFBvcyA9IGdldEJpZGlQYXJ0QXQob3JkZXIsIGNoKVxcbiAgdmFyIHZhbCA9IGdldEJpZGkoY2gsIHBhcnRQb3MpXFxuICBpZiAoYmlkaU90aGVyICE9IG51bGwpIHsgdmFsLm90aGVyID0gZ2V0QmlkaShjaCwgYmlkaU90aGVyKSB9XFxuICByZXR1cm4gdmFsXFxufVxcblxcbi8vIFVzZWQgdG8gY2hlYXBseSBlc3RpbWF0ZSB0aGUgY29vcmRpbmF0ZXMgZm9yIGEgcG9zaXRpb24uIFVzZWQgZm9yXFxuLy8gaW50ZXJtZWRpYXRlIHNjcm9sbCB1cGRhdGVzLlxcbmZ1bmN0aW9uIGVzdGltYXRlQ29vcmRzKGNtLCBwb3MpIHtcXG4gIHZhciBsZWZ0ID0gMFxcbiAgcG9zID0gY2xpcFBvcyhjbS5kb2MsIHBvcylcXG4gIGlmICghY20ub3B0aW9ucy5saW5lV3JhcHBpbmcpIHsgbGVmdCA9IGNoYXJXaWR0aChjbS5kaXNwbGF5KSAqIHBvcy5jaCB9XFxuICB2YXIgbGluZU9iaiA9IGdldExpbmUoY20uZG9jLCBwb3MubGluZSlcXG4gIHZhciB0b3AgPSBoZWlnaHRBdExpbmUobGluZU9iaikgKyBwYWRkaW5nVG9wKGNtLmRpc3BsYXkpXFxuICByZXR1cm4ge2xlZnQ6IGxlZnQsIHJpZ2h0OiBsZWZ0LCB0b3A6IHRvcCwgYm90dG9tOiB0b3AgKyBsaW5lT2JqLmhlaWdodH1cXG59XFxuXFxuLy8gUG9zaXRpb25zIHJldHVybmVkIGJ5IGNvb3Jkc0NoYXIgY29udGFpbiBzb21lIGV4dHJhIGluZm9ybWF0aW9uLlxcbi8vIHhSZWwgaXMgdGhlIHJlbGF0aXZlIHggcG9zaXRpb24gb2YgdGhlIGlucHV0IGNvb3JkaW5hdGVzIGNvbXBhcmVkXFxuLy8gdG8gdGhlIGZvdW5kIHBvc2l0aW9uIChzbyB4UmVsID4gMCBtZWFucyB0aGUgY29vcmRpbmF0ZXMgYXJlIHRvXFxuLy8gdGhlIHJpZ2h0IG9mIHRoZSBjaGFyYWN0ZXIgcG9zaXRpb24sIGZvciBleGFtcGxlKS4gV2hlbiBvdXRzaWRlXFxuLy8gaXMgdHJ1ZSwgdGhhdCBtZWFucyB0aGUgY29vcmRpbmF0ZXMgbGllIG91dHNpZGUgdGhlIGxpbmUnc1xcbi8vIHZlcnRpY2FsIHJhbmdlLlxcbmZ1bmN0aW9uIFBvc1dpdGhJbmZvKGxpbmUsIGNoLCBvdXRzaWRlLCB4UmVsKSB7XFxuICB2YXIgcG9zID0gUG9zKGxpbmUsIGNoKVxcbiAgcG9zLnhSZWwgPSB4UmVsXFxuICBpZiAob3V0c2lkZSkgeyBwb3Mub3V0c2lkZSA9IHRydWUgfVxcbiAgcmV0dXJuIHBvc1xcbn1cXG5cXG4vLyBDb21wdXRlIHRoZSBjaGFyYWN0ZXIgcG9zaXRpb24gY2xvc2VzdCB0byB0aGUgZ2l2ZW4gY29vcmRpbmF0ZXMuXFxuLy8gSW5wdXQgbXVzdCBiZSBsaW5lU3BhY2UtbG9jYWwgKFxcXCJkaXZcXFwiIGNvb3JkaW5hdGUgc3lzdGVtKS5cXG5mdW5jdGlvbiBjb29yZHNDaGFyKGNtLCB4LCB5KSB7XFxuICB2YXIgZG9jID0gY20uZG9jXFxuICB5ICs9IGNtLmRpc3BsYXkudmlld09mZnNldFxcbiAgaWYgKHkgPCAwKSB7IHJldHVybiBQb3NXaXRoSW5mbyhkb2MuZmlyc3QsIDAsIHRydWUsIC0xKSB9XFxuICB2YXIgbGluZU4gPSBsaW5lQXRIZWlnaHQoZG9jLCB5KSwgbGFzdCA9IGRvYy5maXJzdCArIGRvYy5zaXplIC0gMVxcbiAgaWYgKGxpbmVOID4gbGFzdClcXG4gICAgeyByZXR1cm4gUG9zV2l0aEluZm8oZG9jLmZpcnN0ICsgZG9jLnNpemUgLSAxLCBnZXRMaW5lKGRvYywgbGFzdCkudGV4dC5sZW5ndGgsIHRydWUsIDEpIH1cXG4gIGlmICh4IDwgMCkgeyB4ID0gMCB9XFxuXFxuICB2YXIgbGluZU9iaiA9IGdldExpbmUoZG9jLCBsaW5lTilcXG4gIGZvciAoOzspIHtcXG4gICAgdmFyIGZvdW5kID0gY29vcmRzQ2hhcklubmVyKGNtLCBsaW5lT2JqLCBsaW5lTiwgeCwgeSlcXG4gICAgdmFyIG1lcmdlZCA9IGNvbGxhcHNlZFNwYW5BdEVuZChsaW5lT2JqKVxcbiAgICB2YXIgbWVyZ2VkUG9zID0gbWVyZ2VkICYmIG1lcmdlZC5maW5kKDAsIHRydWUpXFxuICAgIGlmIChtZXJnZWQgJiYgKGZvdW5kLmNoID4gbWVyZ2VkUG9zLmZyb20uY2ggfHwgZm91bmQuY2ggPT0gbWVyZ2VkUG9zLmZyb20uY2ggJiYgZm91bmQueFJlbCA+IDApKVxcbiAgICAgIHsgbGluZU4gPSBsaW5lTm8obGluZU9iaiA9IG1lcmdlZFBvcy50by5saW5lKSB9XFxuICAgIGVsc2VcXG4gICAgICB7IHJldHVybiBmb3VuZCB9XFxuICB9XFxufVxcblxcbmZ1bmN0aW9uIGNvb3Jkc0NoYXJJbm5lcihjbSwgbGluZU9iaiwgbGluZU5vLCB4LCB5KSB7XFxuICB2YXIgaW5uZXJPZmYgPSB5IC0gaGVpZ2h0QXRMaW5lKGxpbmVPYmopXFxuICB2YXIgd3JvbmdMaW5lID0gZmFsc2UsIGFkanVzdCA9IDIgKiBjbS5kaXNwbGF5LndyYXBwZXIuY2xpZW50V2lkdGhcXG4gIHZhciBwcmVwYXJlZE1lYXN1cmUgPSBwcmVwYXJlTWVhc3VyZUZvckxpbmUoY20sIGxpbmVPYmopXFxuXFxuICBmdW5jdGlvbiBnZXRYKGNoKSB7XFxuICAgIHZhciBzcCA9IGN1cnNvckNvb3JkcyhjbSwgUG9zKGxpbmVObywgY2gpLCBcXFwibGluZVxcXCIsIGxpbmVPYmosIHByZXBhcmVkTWVhc3VyZSlcXG4gICAgd3JvbmdMaW5lID0gdHJ1ZVxcbiAgICBpZiAoaW5uZXJPZmYgPiBzcC5ib3R0b20pIHsgcmV0dXJuIHNwLmxlZnQgLSBhZGp1c3QgfVxcbiAgICBlbHNlIGlmIChpbm5lck9mZiA8IHNwLnRvcCkgeyByZXR1cm4gc3AubGVmdCArIGFkanVzdCB9XFxuICAgIGVsc2UgeyB3cm9uZ0xpbmUgPSBmYWxzZSB9XFxuICAgIHJldHVybiBzcC5sZWZ0XFxuICB9XFxuXFxuICB2YXIgYmlkaSA9IGdldE9yZGVyKGxpbmVPYmopLCBkaXN0ID0gbGluZU9iai50ZXh0Lmxlbmd0aFxcbiAgdmFyIGZyb20gPSBsaW5lTGVmdChsaW5lT2JqKSwgdG8gPSBsaW5lUmlnaHQobGluZU9iailcXG4gIHZhciBmcm9tWCA9IGdldFgoZnJvbSksIGZyb21PdXRzaWRlID0gd3JvbmdMaW5lLCB0b1ggPSBnZXRYKHRvKSwgdG9PdXRzaWRlID0gd3JvbmdMaW5lXFxuXFxuICBpZiAoeCA+IHRvWCkgeyByZXR1cm4gUG9zV2l0aEluZm8obGluZU5vLCB0bywgdG9PdXRzaWRlLCAxKSB9XFxuICAvLyBEbyBhIGJpbmFyeSBzZWFyY2ggYmV0d2VlbiB0aGVzZSBib3VuZHMuXFxuICBmb3IgKDs7KSB7XFxuICAgIGlmIChiaWRpID8gdG8gPT0gZnJvbSB8fCB0byA9PSBtb3ZlVmlzdWFsbHkobGluZU9iaiwgZnJvbSwgMSkgOiB0byAtIGZyb20gPD0gMSkge1xcbiAgICAgIHZhciBjaCA9IHggPCBmcm9tWCB8fCB4IC0gZnJvbVggPD0gdG9YIC0geCA/IGZyb20gOiB0b1xcbiAgICAgIHZhciBvdXRzaWRlID0gY2ggPT0gZnJvbSA/IGZyb21PdXRzaWRlIDogdG9PdXRzaWRlXFxuICAgICAgdmFyIHhEaWZmID0geCAtIChjaCA9PSBmcm9tID8gZnJvbVggOiB0b1gpXFxuICAgICAgLy8gVGhpcyBpcyBhIGtsdWRnZSB0byBoYW5kbGUgdGhlIGNhc2Ugd2hlcmUgdGhlIGNvb3JkaW5hdGVzXFxuICAgICAgLy8gYXJlIGFmdGVyIGEgbGluZS13cmFwcGVkIGxpbmUuIFdlIHNob3VsZCByZXBsYWNlIGl0IHdpdGggYVxcbiAgICAgIC8vIG1vcmUgZ2VuZXJhbCBoYW5kbGluZyBvZiBjdXJzb3IgcG9zaXRpb25zIGFyb3VuZCBsaW5lXFxuICAgICAgLy8gYnJlYWtzLiAoSXNzdWUgIzQwNzgpXFxuICAgICAgaWYgKHRvT3V0c2lkZSAmJiAhYmlkaSAmJiAhL1xcXFxzLy50ZXN0KGxpbmVPYmoudGV4dC5jaGFyQXQoY2gpKSAmJiB4RGlmZiA+IDAgJiZcXG4gICAgICAgICAgY2ggPCBsaW5lT2JqLnRleHQubGVuZ3RoICYmIHByZXBhcmVkTWVhc3VyZS52aWV3Lm1lYXN1cmUuaGVpZ2h0cy5sZW5ndGggPiAxKSB7XFxuICAgICAgICB2YXIgY2hhclNpemUgPSBtZWFzdXJlQ2hhclByZXBhcmVkKGNtLCBwcmVwYXJlZE1lYXN1cmUsIGNoLCBcXFwicmlnaHRcXFwiKVxcbiAgICAgICAgaWYgKGlubmVyT2ZmIDw9IGNoYXJTaXplLmJvdHRvbSAmJiBpbm5lck9mZiA+PSBjaGFyU2l6ZS50b3AgJiYgTWF0aC5hYnMoeCAtIGNoYXJTaXplLnJpZ2h0KSA8IHhEaWZmKSB7XFxuICAgICAgICAgIG91dHNpZGUgPSBmYWxzZVxcbiAgICAgICAgICBjaCsrXFxuICAgICAgICAgIHhEaWZmID0geCAtIGNoYXJTaXplLnJpZ2h0XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICAgIHdoaWxlIChpc0V4dGVuZGluZ0NoYXIobGluZU9iai50ZXh0LmNoYXJBdChjaCkpKSB7ICsrY2ggfVxcbiAgICAgIHZhciBwb3MgPSBQb3NXaXRoSW5mbyhsaW5lTm8sIGNoLCBvdXRzaWRlLCB4RGlmZiA8IC0xID8gLTEgOiB4RGlmZiA+IDEgPyAxIDogMClcXG4gICAgICByZXR1cm4gcG9zXFxuICAgIH1cXG4gICAgdmFyIHN0ZXAgPSBNYXRoLmNlaWwoZGlzdCAvIDIpLCBtaWRkbGUgPSBmcm9tICsgc3RlcFxcbiAgICBpZiAoYmlkaSkge1xcbiAgICAgIG1pZGRsZSA9IGZyb21cXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ZXA7ICsraSkgeyBtaWRkbGUgPSBtb3ZlVmlzdWFsbHkobGluZU9iaiwgbWlkZGxlLCAxKSB9XFxuICAgIH1cXG4gICAgdmFyIG1pZGRsZVggPSBnZXRYKG1pZGRsZSlcXG4gICAgaWYgKG1pZGRsZVggPiB4KSB7dG8gPSBtaWRkbGU7IHRvWCA9IG1pZGRsZVg7IGlmICh0b091dHNpZGUgPSB3cm9uZ0xpbmUpIHsgdG9YICs9IDEwMDA7IH0gZGlzdCA9IHN0ZXB9XFxuICAgIGVsc2Uge2Zyb20gPSBtaWRkbGU7IGZyb21YID0gbWlkZGxlWDsgZnJvbU91dHNpZGUgPSB3cm9uZ0xpbmU7IGRpc3QgLT0gc3RlcH1cXG4gIH1cXG59XFxuXFxudmFyIG1lYXN1cmVUZXh0XFxuLy8gQ29tcHV0ZSB0aGUgZGVmYXVsdCB0ZXh0IGhlaWdodC5cXG5mdW5jdGlvbiB0ZXh0SGVpZ2h0KGRpc3BsYXkpIHtcXG4gIGlmIChkaXNwbGF5LmNhY2hlZFRleHRIZWlnaHQgIT0gbnVsbCkgeyByZXR1cm4gZGlzcGxheS5jYWNoZWRUZXh0SGVpZ2h0IH1cXG4gIGlmIChtZWFzdXJlVGV4dCA9PSBudWxsKSB7XFxuICAgIG1lYXN1cmVUZXh0ID0gZWx0KFxcXCJwcmVcXFwiKVxcbiAgICAvLyBNZWFzdXJlIGEgYnVuY2ggb2YgbGluZXMsIGZvciBicm93c2VycyB0aGF0IGNvbXB1dGVcXG4gICAgLy8gZnJhY3Rpb25hbCBoZWlnaHRzLlxcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IDQ5OyArK2kpIHtcXG4gICAgICBtZWFzdXJlVGV4dC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcXFwieFxcXCIpKVxcbiAgICAgIG1lYXN1cmVUZXh0LmFwcGVuZENoaWxkKGVsdChcXFwiYnJcXFwiKSlcXG4gICAgfVxcbiAgICBtZWFzdXJlVGV4dC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcXFwieFxcXCIpKVxcbiAgfVxcbiAgcmVtb3ZlQ2hpbGRyZW5BbmRBZGQoZGlzcGxheS5tZWFzdXJlLCBtZWFzdXJlVGV4dClcXG4gIHZhciBoZWlnaHQgPSBtZWFzdXJlVGV4dC5vZmZzZXRIZWlnaHQgLyA1MFxcbiAgaWYgKGhlaWdodCA+IDMpIHsgZGlzcGxheS5jYWNoZWRUZXh0SGVpZ2h0ID0gaGVpZ2h0IH1cXG4gIHJlbW92ZUNoaWxkcmVuKGRpc3BsYXkubWVhc3VyZSlcXG4gIHJldHVybiBoZWlnaHQgfHwgMVxcbn1cXG5cXG4vLyBDb21wdXRlIHRoZSBkZWZhdWx0IGNoYXJhY3RlciB3aWR0aC5cXG5mdW5jdGlvbiBjaGFyV2lkdGgoZGlzcGxheSkge1xcbiAgaWYgKGRpc3BsYXkuY2FjaGVkQ2hhcldpZHRoICE9IG51bGwpIHsgcmV0dXJuIGRpc3BsYXkuY2FjaGVkQ2hhcldpZHRoIH1cXG4gIHZhciBhbmNob3IgPSBlbHQoXFxcInNwYW5cXFwiLCBcXFwieHh4eHh4eHh4eFxcXCIpXFxuICB2YXIgcHJlID0gZWx0KFxcXCJwcmVcXFwiLCBbYW5jaG9yXSlcXG4gIHJlbW92ZUNoaWxkcmVuQW5kQWRkKGRpc3BsYXkubWVhc3VyZSwgcHJlKVxcbiAgdmFyIHJlY3QgPSBhbmNob3IuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIHdpZHRoID0gKHJlY3QucmlnaHQgLSByZWN0LmxlZnQpIC8gMTBcXG4gIGlmICh3aWR0aCA+IDIpIHsgZGlzcGxheS5jYWNoZWRDaGFyV2lkdGggPSB3aWR0aCB9XFxuICByZXR1cm4gd2lkdGggfHwgMTBcXG59XFxuXFxuLy8gRG8gYSBidWxrLXJlYWQgb2YgdGhlIERPTSBwb3NpdGlvbnMgYW5kIHNpemVzIG5lZWRlZCB0byBkcmF3IHRoZVxcbi8vIHZpZXcsIHNvIHRoYXQgd2UgZG9uJ3QgaW50ZXJsZWF2ZSByZWFkaW5nIGFuZCB3cml0aW5nIHRvIHRoZSBET00uXFxuZnVuY3Rpb24gZ2V0RGltZW5zaW9ucyhjbSkge1xcbiAgdmFyIGQgPSBjbS5kaXNwbGF5LCBsZWZ0ID0ge30sIHdpZHRoID0ge31cXG4gIHZhciBndXR0ZXJMZWZ0ID0gZC5ndXR0ZXJzLmNsaWVudExlZnRcXG4gIGZvciAodmFyIG4gPSBkLmd1dHRlcnMuZmlyc3RDaGlsZCwgaSA9IDA7IG47IG4gPSBuLm5leHRTaWJsaW5nLCArK2kpIHtcXG4gICAgbGVmdFtjbS5vcHRpb25zLmd1dHRlcnNbaV1dID0gbi5vZmZzZXRMZWZ0ICsgbi5jbGllbnRMZWZ0ICsgZ3V0dGVyTGVmdFxcbiAgICB3aWR0aFtjbS5vcHRpb25zLmd1dHRlcnNbaV1dID0gbi5jbGllbnRXaWR0aFxcbiAgfVxcbiAgcmV0dXJuIHtmaXhlZFBvczogY29tcGVuc2F0ZUZvckhTY3JvbGwoZCksXFxuICAgICAgICAgIGd1dHRlclRvdGFsV2lkdGg6IGQuZ3V0dGVycy5vZmZzZXRXaWR0aCxcXG4gICAgICAgICAgZ3V0dGVyTGVmdDogbGVmdCxcXG4gICAgICAgICAgZ3V0dGVyV2lkdGg6IHdpZHRoLFxcbiAgICAgICAgICB3cmFwcGVyV2lkdGg6IGQud3JhcHBlci5jbGllbnRXaWR0aH1cXG59XFxuXFxuLy8gQ29tcHV0ZXMgZGlzcGxheS5zY3JvbGxlci5zY3JvbGxMZWZ0ICsgZGlzcGxheS5ndXR0ZXJzLm9mZnNldFdpZHRoLFxcbi8vIGJ1dCB1c2luZyBnZXRCb3VuZGluZ0NsaWVudFJlY3QgdG8gZ2V0IGEgc3ViLXBpeGVsLWFjY3VyYXRlXFxuLy8gcmVzdWx0LlxcbmZ1bmN0aW9uIGNvbXBlbnNhdGVGb3JIU2Nyb2xsKGRpc3BsYXkpIHtcXG4gIHJldHVybiBkaXNwbGF5LnNjcm9sbGVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQgLSBkaXNwbGF5LnNpemVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnRcXG59XFxuXFxuLy8gUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgZXN0aW1hdGVzIHRoZSBoZWlnaHQgb2YgYSBsaW5lLCB0byB1c2UgYXNcXG4vLyBmaXJzdCBhcHByb3hpbWF0aW9uIHVudGlsIHRoZSBsaW5lIGJlY29tZXMgdmlzaWJsZSAoYW5kIGlzIHRodXNcXG4vLyBwcm9wZXJseSBtZWFzdXJhYmxlKS5cXG5mdW5jdGlvbiBlc3RpbWF0ZUhlaWdodChjbSkge1xcbiAgdmFyIHRoID0gdGV4dEhlaWdodChjbS5kaXNwbGF5KSwgd3JhcHBpbmcgPSBjbS5vcHRpb25zLmxpbmVXcmFwcGluZ1xcbiAgdmFyIHBlckxpbmUgPSB3cmFwcGluZyAmJiBNYXRoLm1heCg1LCBjbS5kaXNwbGF5LnNjcm9sbGVyLmNsaWVudFdpZHRoIC8gY2hhcldpZHRoKGNtLmRpc3BsYXkpIC0gMylcXG4gIHJldHVybiBmdW5jdGlvbiAobGluZSkge1xcbiAgICBpZiAobGluZUlzSGlkZGVuKGNtLmRvYywgbGluZSkpIHsgcmV0dXJuIDAgfVxcblxcbiAgICB2YXIgd2lkZ2V0c0hlaWdodCA9IDBcXG4gICAgaWYgKGxpbmUud2lkZ2V0cykgeyBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmUud2lkZ2V0cy5sZW5ndGg7IGkrKykge1xcbiAgICAgIGlmIChsaW5lLndpZGdldHNbaV0uaGVpZ2h0KSB7IHdpZGdldHNIZWlnaHQgKz0gbGluZS53aWRnZXRzW2ldLmhlaWdodCB9XFxuICAgIH0gfVxcblxcbiAgICBpZiAod3JhcHBpbmcpXFxuICAgICAgeyByZXR1cm4gd2lkZ2V0c0hlaWdodCArIChNYXRoLmNlaWwobGluZS50ZXh0Lmxlbmd0aCAvIHBlckxpbmUpIHx8IDEpICogdGggfVxcbiAgICBlbHNlXFxuICAgICAgeyByZXR1cm4gd2lkZ2V0c0hlaWdodCArIHRoIH1cXG4gIH1cXG59XFxuXFxuZnVuY3Rpb24gZXN0aW1hdGVMaW5lSGVpZ2h0cyhjbSkge1xcbiAgdmFyIGRvYyA9IGNtLmRvYywgZXN0ID0gZXN0aW1hdGVIZWlnaHQoY20pXFxuICBkb2MuaXRlcihmdW5jdGlvbiAobGluZSkge1xcbiAgICB2YXIgZXN0SGVpZ2h0ID0gZXN0KGxpbmUpXFxuICAgIGlmIChlc3RIZWlnaHQgIT0gbGluZS5oZWlnaHQpIHsgdXBkYXRlTGluZUhlaWdodChsaW5lLCBlc3RIZWlnaHQpIH1cXG4gIH0pXFxufVxcblxcbi8vIEdpdmVuIGEgbW91c2UgZXZlbnQsIGZpbmQgdGhlIGNvcnJlc3BvbmRpbmcgcG9zaXRpb24uIElmIGxpYmVyYWxcXG4vLyBpcyBmYWxzZSwgaXQgY2hlY2tzIHdoZXRoZXIgYSBndXR0ZXIgb3Igc2Nyb2xsYmFyIHdhcyBjbGlja2VkLFxcbi8vIGFuZCByZXR1cm5zIG51bGwgaWYgaXQgd2FzLiBmb3JSZWN0IGlzIHVzZWQgYnkgcmVjdGFuZ3VsYXJcXG4vLyBzZWxlY3Rpb25zLCBhbmQgdHJpZXMgdG8gZXN0aW1hdGUgYSBjaGFyYWN0ZXIgcG9zaXRpb24gZXZlbiBmb3JcXG4vLyBjb29yZGluYXRlcyBiZXlvbmQgdGhlIHJpZ2h0IG9mIHRoZSB0ZXh0LlxcbmZ1bmN0aW9uIHBvc0Zyb21Nb3VzZShjbSwgZSwgbGliZXJhbCwgZm9yUmVjdCkge1xcbiAgdmFyIGRpc3BsYXkgPSBjbS5kaXNwbGF5XFxuICBpZiAoIWxpYmVyYWwgJiYgZV90YXJnZXQoZSkuZ2V0QXR0cmlidXRlKFxcXCJjbS1ub3QtY29udGVudFxcXCIpID09IFxcXCJ0cnVlXFxcIikgeyByZXR1cm4gbnVsbCB9XFxuXFxuICB2YXIgeCwgeSwgc3BhY2UgPSBkaXNwbGF5LmxpbmVTcGFjZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxcbiAgLy8gRmFpbHMgdW5wcmVkaWN0YWJseSBvbiBJRVs2N10gd2hlbiBtb3VzZSBpcyBkcmFnZ2VkIGFyb3VuZCBxdWlja2x5LlxcbiAgdHJ5IHsgeCA9IGUuY2xpZW50WCAtIHNwYWNlLmxlZnQ7IHkgPSBlLmNsaWVudFkgLSBzcGFjZS50b3AgfVxcbiAgY2F0Y2ggKGUpIHsgcmV0dXJuIG51bGwgfVxcbiAgdmFyIGNvb3JkcyA9IGNvb3Jkc0NoYXIoY20sIHgsIHkpLCBsaW5lXFxuICBpZiAoZm9yUmVjdCAmJiBjb29yZHMueFJlbCA9PSAxICYmIChsaW5lID0gZ2V0TGluZShjbS5kb2MsIGNvb3Jkcy5saW5lKS50ZXh0KS5sZW5ndGggPT0gY29vcmRzLmNoKSB7XFxuICAgIHZhciBjb2xEaWZmID0gY291bnRDb2x1bW4obGluZSwgbGluZS5sZW5ndGgsIGNtLm9wdGlvbnMudGFiU2l6ZSkgLSBsaW5lLmxlbmd0aFxcbiAgICBjb29yZHMgPSBQb3MoY29vcmRzLmxpbmUsIE1hdGgubWF4KDAsIE1hdGgucm91bmQoKHggLSBwYWRkaW5nSChjbS5kaXNwbGF5KS5sZWZ0KSAvIGNoYXJXaWR0aChjbS5kaXNwbGF5KSkgLSBjb2xEaWZmKSlcXG4gIH1cXG4gIHJldHVybiBjb29yZHNcXG59XFxuXFxuLy8gRmluZCB0aGUgdmlldyBlbGVtZW50IGNvcnJlc3BvbmRpbmcgdG8gYSBnaXZlbiBsaW5lLiBSZXR1cm4gbnVsbFxcbi8vIHdoZW4gdGhlIGxpbmUgaXNuJ3QgdmlzaWJsZS5cXG5mdW5jdGlvbiBmaW5kVmlld0luZGV4KGNtLCBuKSB7XFxuICBpZiAobiA+PSBjbS5kaXNwbGF5LnZpZXdUbykgeyByZXR1cm4gbnVsbCB9XFxuICBuIC09IGNtLmRpc3BsYXkudmlld0Zyb21cXG4gIGlmIChuIDwgMCkgeyByZXR1cm4gbnVsbCB9XFxuICB2YXIgdmlldyA9IGNtLmRpc3BsYXkudmlld1xcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB2aWV3Lmxlbmd0aDsgaSsrKSB7XFxuICAgIG4gLT0gdmlld1tpXS5zaXplXFxuICAgIGlmIChuIDwgMCkgeyByZXR1cm4gaSB9XFxuICB9XFxufVxcblxcbmZ1bmN0aW9uIHVwZGF0ZVNlbGVjdGlvbihjbSkge1xcbiAgY20uZGlzcGxheS5pbnB1dC5zaG93U2VsZWN0aW9uKGNtLmRpc3BsYXkuaW5wdXQucHJlcGFyZVNlbGVjdGlvbigpKVxcbn1cXG5cXG5mdW5jdGlvbiBwcmVwYXJlU2VsZWN0aW9uKGNtLCBwcmltYXJ5KSB7XFxuICB2YXIgZG9jID0gY20uZG9jLCByZXN1bHQgPSB7fVxcbiAgdmFyIGN1ckZyYWdtZW50ID0gcmVzdWx0LmN1cnNvcnMgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KClcXG4gIHZhciBzZWxGcmFnbWVudCA9IHJlc3VsdC5zZWxlY3Rpb24gPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KClcXG5cXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZG9jLnNlbC5yYW5nZXMubGVuZ3RoOyBpKyspIHtcXG4gICAgaWYgKHByaW1hcnkgPT09IGZhbHNlICYmIGkgPT0gZG9jLnNlbC5wcmltSW5kZXgpIHsgY29udGludWUgfVxcbiAgICB2YXIgcmFuZ2UgPSBkb2Muc2VsLnJhbmdlc1tpXVxcbiAgICBpZiAocmFuZ2UuZnJvbSgpLmxpbmUgPj0gY20uZGlzcGxheS52aWV3VG8gfHwgcmFuZ2UudG8oKS5saW5lIDwgY20uZGlzcGxheS52aWV3RnJvbSkgeyBjb250aW51ZSB9XFxuICAgIHZhciBjb2xsYXBzZWQgPSByYW5nZS5lbXB0eSgpXFxuICAgIGlmIChjb2xsYXBzZWQgfHwgY20ub3B0aW9ucy5zaG93Q3Vyc29yV2hlblNlbGVjdGluZylcXG4gICAgICB7IGRyYXdTZWxlY3Rpb25DdXJzb3IoY20sIHJhbmdlLmhlYWQsIGN1ckZyYWdtZW50KSB9XFxuICAgIGlmICghY29sbGFwc2VkKVxcbiAgICAgIHsgZHJhd1NlbGVjdGlvblJhbmdlKGNtLCByYW5nZSwgc2VsRnJhZ21lbnQpIH1cXG4gIH1cXG4gIHJldHVybiByZXN1bHRcXG59XFxuXFxuLy8gRHJhd3MgYSBjdXJzb3IgZm9yIHRoZSBnaXZlbiByYW5nZVxcbmZ1bmN0aW9uIGRyYXdTZWxlY3Rpb25DdXJzb3IoY20sIGhlYWQsIG91dHB1dCkge1xcbiAgdmFyIHBvcyA9IGN1cnNvckNvb3JkcyhjbSwgaGVhZCwgXFxcImRpdlxcXCIsIG51bGwsIG51bGwsICFjbS5vcHRpb25zLnNpbmdsZUN1cnNvckhlaWdodFBlckxpbmUpXFxuXFxuICB2YXIgY3Vyc29yID0gb3V0cHV0LmFwcGVuZENoaWxkKGVsdChcXFwiZGl2XFxcIiwgXFxcIlxcXFx1MDBhMFxcXCIsIFxcXCJDb2RlTWlycm9yLWN1cnNvclxcXCIpKVxcbiAgY3Vyc29yLnN0eWxlLmxlZnQgPSBwb3MubGVmdCArIFxcXCJweFxcXCJcXG4gIGN1cnNvci5zdHlsZS50b3AgPSBwb3MudG9wICsgXFxcInB4XFxcIlxcbiAgY3Vyc29yLnN0eWxlLmhlaWdodCA9IE1hdGgubWF4KDAsIHBvcy5ib3R0b20gLSBwb3MudG9wKSAqIGNtLm9wdGlvbnMuY3Vyc29ySGVpZ2h0ICsgXFxcInB4XFxcIlxcblxcbiAgaWYgKHBvcy5vdGhlcikge1xcbiAgICAvLyBTZWNvbmRhcnkgY3Vyc29yLCBzaG93biB3aGVuIG9uIGEgJ2p1bXAnIGluIGJpLWRpcmVjdGlvbmFsIHRleHRcXG4gICAgdmFyIG90aGVyQ3Vyc29yID0gb3V0cHV0LmFwcGVuZENoaWxkKGVsdChcXFwiZGl2XFxcIiwgXFxcIlxcXFx1MDBhMFxcXCIsIFxcXCJDb2RlTWlycm9yLWN1cnNvciBDb2RlTWlycm9yLXNlY29uZGFyeWN1cnNvclxcXCIpKVxcbiAgICBvdGhlckN1cnNvci5zdHlsZS5kaXNwbGF5ID0gXFxcIlxcXCJcXG4gICAgb3RoZXJDdXJzb3Iuc3R5bGUubGVmdCA9IHBvcy5vdGhlci5sZWZ0ICsgXFxcInB4XFxcIlxcbiAgICBvdGhlckN1cnNvci5zdHlsZS50b3AgPSBwb3Mub3RoZXIudG9wICsgXFxcInB4XFxcIlxcbiAgICBvdGhlckN1cnNvci5zdHlsZS5oZWlnaHQgPSAocG9zLm90aGVyLmJvdHRvbSAtIHBvcy5vdGhlci50b3ApICogLjg1ICsgXFxcInB4XFxcIlxcbiAgfVxcbn1cXG5cXG4vLyBEcmF3cyB0aGUgZ2l2ZW4gcmFuZ2UgYXMgYSBoaWdobGlnaHRlZCBzZWxlY3Rpb25cXG5mdW5jdGlvbiBkcmF3U2VsZWN0aW9uUmFuZ2UoY20sIHJhbmdlLCBvdXRwdXQpIHtcXG4gIHZhciBkaXNwbGF5ID0gY20uZGlzcGxheSwgZG9jID0gY20uZG9jXFxuICB2YXIgZnJhZ21lbnQgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KClcXG4gIHZhciBwYWRkaW5nID0gcGFkZGluZ0goY20uZGlzcGxheSksIGxlZnRTaWRlID0gcGFkZGluZy5sZWZ0XFxuICB2YXIgcmlnaHRTaWRlID0gTWF0aC5tYXgoZGlzcGxheS5zaXplcldpZHRoLCBkaXNwbGF5V2lkdGgoY20pIC0gZGlzcGxheS5zaXplci5vZmZzZXRMZWZ0KSAtIHBhZGRpbmcucmlnaHRcXG5cXG4gIGZ1bmN0aW9uIGFkZChsZWZ0LCB0b3AsIHdpZHRoLCBib3R0b20pIHtcXG4gICAgaWYgKHRvcCA8IDApIHsgdG9wID0gMCB9XFxuICAgIHRvcCA9IE1hdGgucm91bmQodG9wKVxcbiAgICBib3R0b20gPSBNYXRoLnJvdW5kKGJvdHRvbSlcXG4gICAgZnJhZ21lbnQuYXBwZW5kQ2hpbGQoZWx0KFxcXCJkaXZcXFwiLCBudWxsLCBcXFwiQ29kZU1pcnJvci1zZWxlY3RlZFxcXCIsIChcXFwicG9zaXRpb246IGFic29sdXRlOyBsZWZ0OiBcXFwiICsgbGVmdCArIFxcXCJweDtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9wOiBcXFwiICsgdG9wICsgXFxcInB4OyB3aWR0aDogXFxcIiArICh3aWR0aCA9PSBudWxsID8gcmlnaHRTaWRlIC0gbGVmdCA6IHdpZHRoKSArIFxcXCJweDtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBcXFwiICsgKGJvdHRvbSAtIHRvcCkgKyBcXFwicHhcXFwiKSkpXFxuICB9XFxuXFxuICBmdW5jdGlvbiBkcmF3Rm9yTGluZShsaW5lLCBmcm9tQXJnLCB0b0FyZykge1xcbiAgICB2YXIgbGluZU9iaiA9IGdldExpbmUoZG9jLCBsaW5lKVxcbiAgICB2YXIgbGluZUxlbiA9IGxpbmVPYmoudGV4dC5sZW5ndGhcXG4gICAgdmFyIHN0YXJ0LCBlbmRcXG4gICAgZnVuY3Rpb24gY29vcmRzKGNoLCBiaWFzKSB7XFxuICAgICAgcmV0dXJuIGNoYXJDb29yZHMoY20sIFBvcyhsaW5lLCBjaCksIFxcXCJkaXZcXFwiLCBsaW5lT2JqLCBiaWFzKVxcbiAgICB9XFxuXFxuICAgIGl0ZXJhdGVCaWRpU2VjdGlvbnMoZ2V0T3JkZXIobGluZU9iaiksIGZyb21BcmcgfHwgMCwgdG9BcmcgPT0gbnVsbCA/IGxpbmVMZW4gOiB0b0FyZywgZnVuY3Rpb24gKGZyb20sIHRvLCBkaXIpIHtcXG4gICAgICB2YXIgbGVmdFBvcyA9IGNvb3Jkcyhmcm9tLCBcXFwibGVmdFxcXCIpLCByaWdodFBvcywgbGVmdCwgcmlnaHRcXG4gICAgICBpZiAoZnJvbSA9PSB0bykge1xcbiAgICAgICAgcmlnaHRQb3MgPSBsZWZ0UG9zXFxuICAgICAgICBsZWZ0ID0gcmlnaHQgPSBsZWZ0UG9zLmxlZnRcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgcmlnaHRQb3MgPSBjb29yZHModG8gLSAxLCBcXFwicmlnaHRcXFwiKVxcbiAgICAgICAgaWYgKGRpciA9PSBcXFwicnRsXFxcIikgeyB2YXIgdG1wID0gbGVmdFBvczsgbGVmdFBvcyA9IHJpZ2h0UG9zOyByaWdodFBvcyA9IHRtcCB9XFxuICAgICAgICBsZWZ0ID0gbGVmdFBvcy5sZWZ0XFxuICAgICAgICByaWdodCA9IHJpZ2h0UG9zLnJpZ2h0XFxuICAgICAgfVxcbiAgICAgIGlmIChmcm9tQXJnID09IG51bGwgJiYgZnJvbSA9PSAwKSB7IGxlZnQgPSBsZWZ0U2lkZSB9XFxuICAgICAgaWYgKHJpZ2h0UG9zLnRvcCAtIGxlZnRQb3MudG9wID4gMykgeyAvLyBEaWZmZXJlbnQgbGluZXMsIGRyYXcgdG9wIHBhcnRcXG4gICAgICAgIGFkZChsZWZ0LCBsZWZ0UG9zLnRvcCwgbnVsbCwgbGVmdFBvcy5ib3R0b20pXFxuICAgICAgICBsZWZ0ID0gbGVmdFNpZGVcXG4gICAgICAgIGlmIChsZWZ0UG9zLmJvdHRvbSA8IHJpZ2h0UG9zLnRvcCkgeyBhZGQobGVmdCwgbGVmdFBvcy5ib3R0b20sIG51bGwsIHJpZ2h0UG9zLnRvcCkgfVxcbiAgICAgIH1cXG4gICAgICBpZiAodG9BcmcgPT0gbnVsbCAmJiB0byA9PSBsaW5lTGVuKSB7IHJpZ2h0ID0gcmlnaHRTaWRlIH1cXG4gICAgICBpZiAoIXN0YXJ0IHx8IGxlZnRQb3MudG9wIDwgc3RhcnQudG9wIHx8IGxlZnRQb3MudG9wID09IHN0YXJ0LnRvcCAmJiBsZWZ0UG9zLmxlZnQgPCBzdGFydC5sZWZ0KVxcbiAgICAgICAgeyBzdGFydCA9IGxlZnRQb3MgfVxcbiAgICAgIGlmICghZW5kIHx8IHJpZ2h0UG9zLmJvdHRvbSA+IGVuZC5ib3R0b20gfHwgcmlnaHRQb3MuYm90dG9tID09IGVuZC5ib3R0b20gJiYgcmlnaHRQb3MucmlnaHQgPiBlbmQucmlnaHQpXFxuICAgICAgICB7IGVuZCA9IHJpZ2h0UG9zIH1cXG4gICAgICBpZiAobGVmdCA8IGxlZnRTaWRlICsgMSkgeyBsZWZ0ID0gbGVmdFNpZGUgfVxcbiAgICAgIGFkZChsZWZ0LCByaWdodFBvcy50b3AsIHJpZ2h0IC0gbGVmdCwgcmlnaHRQb3MuYm90dG9tKVxcbiAgICB9KVxcbiAgICByZXR1cm4ge3N0YXJ0OiBzdGFydCwgZW5kOiBlbmR9XFxuICB9XFxuXFxuICB2YXIgc0Zyb20gPSByYW5nZS5mcm9tKCksIHNUbyA9IHJhbmdlLnRvKClcXG4gIGlmIChzRnJvbS5saW5lID09IHNUby5saW5lKSB7XFxuICAgIGRyYXdGb3JMaW5lKHNGcm9tLmxpbmUsIHNGcm9tLmNoLCBzVG8uY2gpXFxuICB9IGVsc2Uge1xcbiAgICB2YXIgZnJvbUxpbmUgPSBnZXRMaW5lKGRvYywgc0Zyb20ubGluZSksIHRvTGluZSA9IGdldExpbmUoZG9jLCBzVG8ubGluZSlcXG4gICAgdmFyIHNpbmdsZVZMaW5lID0gdmlzdWFsTGluZShmcm9tTGluZSkgPT0gdmlzdWFsTGluZSh0b0xpbmUpXFxuICAgIHZhciBsZWZ0RW5kID0gZHJhd0ZvckxpbmUoc0Zyb20ubGluZSwgc0Zyb20uY2gsIHNpbmdsZVZMaW5lID8gZnJvbUxpbmUudGV4dC5sZW5ndGggKyAxIDogbnVsbCkuZW5kXFxuICAgIHZhciByaWdodFN0YXJ0ID0gZHJhd0ZvckxpbmUoc1RvLmxpbmUsIHNpbmdsZVZMaW5lID8gMCA6IG51bGwsIHNUby5jaCkuc3RhcnRcXG4gICAgaWYgKHNpbmdsZVZMaW5lKSB7XFxuICAgICAgaWYgKGxlZnRFbmQudG9wIDwgcmlnaHRTdGFydC50b3AgLSAyKSB7XFxuICAgICAgICBhZGQobGVmdEVuZC5yaWdodCwgbGVmdEVuZC50b3AsIG51bGwsIGxlZnRFbmQuYm90dG9tKVxcbiAgICAgICAgYWRkKGxlZnRTaWRlLCByaWdodFN0YXJ0LnRvcCwgcmlnaHRTdGFydC5sZWZ0LCByaWdodFN0YXJ0LmJvdHRvbSlcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgYWRkKGxlZnRFbmQucmlnaHQsIGxlZnRFbmQudG9wLCByaWdodFN0YXJ0LmxlZnQgLSBsZWZ0RW5kLnJpZ2h0LCBsZWZ0RW5kLmJvdHRvbSlcXG4gICAgICB9XFxuICAgIH1cXG4gICAgaWYgKGxlZnRFbmQuYm90dG9tIDwgcmlnaHRTdGFydC50b3ApXFxuICAgICAgeyBhZGQobGVmdFNpZGUsIGxlZnRFbmQuYm90dG9tLCBudWxsLCByaWdodFN0YXJ0LnRvcCkgfVxcbiAgfVxcblxcbiAgb3V0cHV0LmFwcGVuZENoaWxkKGZyYWdtZW50KVxcbn1cXG5cXG4vLyBDdXJzb3ItYmxpbmtpbmdcXG5mdW5jdGlvbiByZXN0YXJ0QmxpbmsoY20pIHtcXG4gIGlmICghY20uc3RhdGUuZm9jdXNlZCkgeyByZXR1cm4gfVxcbiAgdmFyIGRpc3BsYXkgPSBjbS5kaXNwbGF5XFxuICBjbGVhckludGVydmFsKGRpc3BsYXkuYmxpbmtlcilcXG4gIHZhciBvbiA9IHRydWVcXG4gIGRpc3BsYXkuY3Vyc29yRGl2LnN0eWxlLnZpc2liaWxpdHkgPSBcXFwiXFxcIlxcbiAgaWYgKGNtLm9wdGlvbnMuY3Vyc29yQmxpbmtSYXRlID4gMClcXG4gICAgeyBkaXNwbGF5LmJsaW5rZXIgPSBzZXRJbnRlcnZhbChmdW5jdGlvbiAoKSB7IHJldHVybiBkaXNwbGF5LmN1cnNvckRpdi5zdHlsZS52aXNpYmlsaXR5ID0gKG9uID0gIW9uKSA/IFxcXCJcXFwiIDogXFxcImhpZGRlblxcXCI7IH0sXFxuICAgICAgY20ub3B0aW9ucy5jdXJzb3JCbGlua1JhdGUpIH1cXG4gIGVsc2UgaWYgKGNtLm9wdGlvbnMuY3Vyc29yQmxpbmtSYXRlIDwgMClcXG4gICAgeyBkaXNwbGF5LmN1cnNvckRpdi5zdHlsZS52aXNpYmlsaXR5ID0gXFxcImhpZGRlblxcXCIgfVxcbn1cXG5cXG5mdW5jdGlvbiBlbnN1cmVGb2N1cyhjbSkge1xcbiAgaWYgKCFjbS5zdGF0ZS5mb2N1c2VkKSB7IGNtLmRpc3BsYXkuaW5wdXQuZm9jdXMoKTsgb25Gb2N1cyhjbSkgfVxcbn1cXG5cXG5mdW5jdGlvbiBkZWxheUJsdXJFdmVudChjbSkge1xcbiAgY20uc3RhdGUuZGVsYXlpbmdCbHVyRXZlbnQgPSB0cnVlXFxuICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgaWYgKGNtLnN0YXRlLmRlbGF5aW5nQmx1ckV2ZW50KSB7XFxuICAgIGNtLnN0YXRlLmRlbGF5aW5nQmx1ckV2ZW50ID0gZmFsc2VcXG4gICAgb25CbHVyKGNtKVxcbiAgfSB9LCAxMDApXFxufVxcblxcbmZ1bmN0aW9uIG9uRm9jdXMoY20sIGUpIHtcXG4gIGlmIChjbS5zdGF0ZS5kZWxheWluZ0JsdXJFdmVudCkgeyBjbS5zdGF0ZS5kZWxheWluZ0JsdXJFdmVudCA9IGZhbHNlIH1cXG5cXG4gIGlmIChjbS5vcHRpb25zLnJlYWRPbmx5ID09IFxcXCJub2N1cnNvclxcXCIpIHsgcmV0dXJuIH1cXG4gIGlmICghY20uc3RhdGUuZm9jdXNlZCkge1xcbiAgICBzaWduYWwoY20sIFxcXCJmb2N1c1xcXCIsIGNtLCBlKVxcbiAgICBjbS5zdGF0ZS5mb2N1c2VkID0gdHJ1ZVxcbiAgICBhZGRDbGFzcyhjbS5kaXNwbGF5LndyYXBwZXIsIFxcXCJDb2RlTWlycm9yLWZvY3VzZWRcXFwiKVxcbiAgICAvLyBUaGlzIHRlc3QgcHJldmVudHMgdGhpcyBmcm9tIGZpcmluZyB3aGVuIGEgY29udGV4dFxcbiAgICAvLyBtZW51IGlzIGNsb3NlZCAoc2luY2UgdGhlIGlucHV0IHJlc2V0IHdvdWxkIGtpbGwgdGhlXFxuICAgIC8vIHNlbGVjdC1hbGwgZGV0ZWN0aW9uIGhhY2spXFxuICAgIGlmICghY20uY3VyT3AgJiYgY20uZGlzcGxheS5zZWxGb3JDb250ZXh0TWVudSAhPSBjbS5kb2Muc2VsKSB7XFxuICAgICAgY20uZGlzcGxheS5pbnB1dC5yZXNldCgpXFxuICAgICAgaWYgKHdlYmtpdCkgeyBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNtLmRpc3BsYXkuaW5wdXQucmVzZXQodHJ1ZSk7IH0sIDIwKSB9IC8vIElzc3VlICMxNzMwXFxuICAgIH1cXG4gICAgY20uZGlzcGxheS5pbnB1dC5yZWNlaXZlZEZvY3VzKClcXG4gIH1cXG4gIHJlc3RhcnRCbGluayhjbSlcXG59XFxuZnVuY3Rpb24gb25CbHVyKGNtLCBlKSB7XFxuICBpZiAoY20uc3RhdGUuZGVsYXlpbmdCbHVyRXZlbnQpIHsgcmV0dXJuIH1cXG5cXG4gIGlmIChjbS5zdGF0ZS5mb2N1c2VkKSB7XFxuICAgIHNpZ25hbChjbSwgXFxcImJsdXJcXFwiLCBjbSwgZSlcXG4gICAgY20uc3RhdGUuZm9jdXNlZCA9IGZhbHNlXFxuICAgIHJtQ2xhc3MoY20uZGlzcGxheS53cmFwcGVyLCBcXFwiQ29kZU1pcnJvci1mb2N1c2VkXFxcIilcXG4gIH1cXG4gIGNsZWFySW50ZXJ2YWwoY20uZGlzcGxheS5ibGlua2VyKVxcbiAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IGlmICghY20uc3RhdGUuZm9jdXNlZCkgeyBjbS5kaXNwbGF5LnNoaWZ0ID0gZmFsc2UgfSB9LCAxNTApXFxufVxcblxcbi8vIFJlLWFsaWduIGxpbmUgbnVtYmVycyBhbmQgZ3V0dGVyIG1hcmtzIHRvIGNvbXBlbnNhdGUgZm9yXFxuLy8gaG9yaXpvbnRhbCBzY3JvbGxpbmcuXFxuZnVuY3Rpb24gYWxpZ25Ib3Jpem9udGFsbHkoY20pIHtcXG4gIHZhciBkaXNwbGF5ID0gY20uZGlzcGxheSwgdmlldyA9IGRpc3BsYXkudmlld1xcbiAgaWYgKCFkaXNwbGF5LmFsaWduV2lkZ2V0cyAmJiAoIWRpc3BsYXkuZ3V0dGVycy5maXJzdENoaWxkIHx8ICFjbS5vcHRpb25zLmZpeGVkR3V0dGVyKSkgeyByZXR1cm4gfVxcbiAgdmFyIGNvbXAgPSBjb21wZW5zYXRlRm9ySFNjcm9sbChkaXNwbGF5KSAtIGRpc3BsYXkuc2Nyb2xsZXIuc2Nyb2xsTGVmdCArIGNtLmRvYy5zY3JvbGxMZWZ0XFxuICB2YXIgZ3V0dGVyVyA9IGRpc3BsYXkuZ3V0dGVycy5vZmZzZXRXaWR0aCwgbGVmdCA9IGNvbXAgKyBcXFwicHhcXFwiXFxuICBmb3IgKHZhciBpID0gMDsgaSA8IHZpZXcubGVuZ3RoOyBpKyspIHsgaWYgKCF2aWV3W2ldLmhpZGRlbikge1xcbiAgICBpZiAoY20ub3B0aW9ucy5maXhlZEd1dHRlcikge1xcbiAgICAgIGlmICh2aWV3W2ldLmd1dHRlcilcXG4gICAgICAgIHsgdmlld1tpXS5ndXR0ZXIuc3R5bGUubGVmdCA9IGxlZnQgfVxcbiAgICAgIGlmICh2aWV3W2ldLmd1dHRlckJhY2tncm91bmQpXFxuICAgICAgICB7IHZpZXdbaV0uZ3V0dGVyQmFja2dyb3VuZC5zdHlsZS5sZWZ0ID0gbGVmdCB9XFxuICAgIH1cXG4gICAgdmFyIGFsaWduID0gdmlld1tpXS5hbGlnbmFibGVcXG4gICAgaWYgKGFsaWduKSB7IGZvciAodmFyIGogPSAwOyBqIDwgYWxpZ24ubGVuZ3RoOyBqKyspXFxuICAgICAgeyBhbGlnbltqXS5zdHlsZS5sZWZ0ID0gbGVmdCB9IH1cXG4gIH0gfVxcbiAgaWYgKGNtLm9wdGlvbnMuZml4ZWRHdXR0ZXIpXFxuICAgIHsgZGlzcGxheS5ndXR0ZXJzLnN0eWxlLmxlZnQgPSAoY29tcCArIGd1dHRlclcpICsgXFxcInB4XFxcIiB9XFxufVxcblxcbi8vIFVzZWQgdG8gZW5zdXJlIHRoYXQgdGhlIGxpbmUgbnVtYmVyIGd1dHRlciBpcyBzdGlsbCB0aGUgcmlnaHRcXG4vLyBzaXplIGZvciB0aGUgY3VycmVudCBkb2N1bWVudCBzaXplLiBSZXR1cm5zIHRydWUgd2hlbiBhbiB1cGRhdGVcXG4vLyBpcyBuZWVkZWQuXFxuZnVuY3Rpb24gbWF5YmVVcGRhdGVMaW5lTnVtYmVyV2lkdGgoY20pIHtcXG4gIGlmICghY20ub3B0aW9ucy5saW5lTnVtYmVycykgeyByZXR1cm4gZmFsc2UgfVxcbiAgdmFyIGRvYyA9IGNtLmRvYywgbGFzdCA9IGxpbmVOdW1iZXJGb3IoY20ub3B0aW9ucywgZG9jLmZpcnN0ICsgZG9jLnNpemUgLSAxKSwgZGlzcGxheSA9IGNtLmRpc3BsYXlcXG4gIGlmIChsYXN0Lmxlbmd0aCAhPSBkaXNwbGF5LmxpbmVOdW1DaGFycykge1xcbiAgICB2YXIgdGVzdCA9IGRpc3BsYXkubWVhc3VyZS5hcHBlbmRDaGlsZChlbHQoXFxcImRpdlxcXCIsIFtlbHQoXFxcImRpdlxcXCIsIGxhc3QpXSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcXCJDb2RlTWlycm9yLWxpbmVudW1iZXIgQ29kZU1pcnJvci1ndXR0ZXItZWx0XFxcIikpXFxuICAgIHZhciBpbm5lclcgPSB0ZXN0LmZpcnN0Q2hpbGQub2Zmc2V0V2lkdGgsIHBhZGRpbmcgPSB0ZXN0Lm9mZnNldFdpZHRoIC0gaW5uZXJXXFxuICAgIGRpc3BsYXkubGluZUd1dHRlci5zdHlsZS53aWR0aCA9IFxcXCJcXFwiXFxuICAgIGRpc3BsYXkubGluZU51bUlubmVyV2lkdGggPSBNYXRoLm1heChpbm5lclcsIGRpc3BsYXkubGluZUd1dHRlci5vZmZzZXRXaWR0aCAtIHBhZGRpbmcpICsgMVxcbiAgICBkaXNwbGF5LmxpbmVOdW1XaWR0aCA9IGRpc3BsYXkubGluZU51bUlubmVyV2lkdGggKyBwYWRkaW5nXFxuICAgIGRpc3BsYXkubGluZU51bUNoYXJzID0gZGlzcGxheS5saW5lTnVtSW5uZXJXaWR0aCA/IGxhc3QubGVuZ3RoIDogLTFcXG4gICAgZGlzcGxheS5saW5lR3V0dGVyLnN0eWxlLndpZHRoID0gZGlzcGxheS5saW5lTnVtV2lkdGggKyBcXFwicHhcXFwiXFxuICAgIHVwZGF0ZUd1dHRlclNwYWNlKGNtKVxcbiAgICByZXR1cm4gdHJ1ZVxcbiAgfVxcbiAgcmV0dXJuIGZhbHNlXFxufVxcblxcbi8vIFJlYWQgdGhlIGFjdHVhbCBoZWlnaHRzIG9mIHRoZSByZW5kZXJlZCBsaW5lcywgYW5kIHVwZGF0ZSB0aGVpclxcbi8vIHN0b3JlZCBoZWlnaHRzIHRvIG1hdGNoLlxcbmZ1bmN0aW9uIHVwZGF0ZUhlaWdodHNJblZpZXdwb3J0KGNtKSB7XFxuICB2YXIgZGlzcGxheSA9IGNtLmRpc3BsYXlcXG4gIHZhciBwcmV2Qm90dG9tID0gZGlzcGxheS5saW5lRGl2Lm9mZnNldFRvcFxcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaXNwbGF5LnZpZXcubGVuZ3RoOyBpKyspIHtcXG4gICAgdmFyIGN1ciA9IGRpc3BsYXkudmlld1tpXSwgaGVpZ2h0ID0gdm9pZCAwXFxuICAgIGlmIChjdXIuaGlkZGVuKSB7IGNvbnRpbnVlIH1cXG4gICAgaWYgKGllICYmIGllX3ZlcnNpb24gPCA4KSB7XFxuICAgICAgdmFyIGJvdCA9IGN1ci5ub2RlLm9mZnNldFRvcCArIGN1ci5ub2RlLm9mZnNldEhlaWdodFxcbiAgICAgIGhlaWdodCA9IGJvdCAtIHByZXZCb3R0b21cXG4gICAgICBwcmV2Qm90dG9tID0gYm90XFxuICAgIH0gZWxzZSB7XFxuICAgICAgdmFyIGJveCA9IGN1ci5ub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXFxuICAgICAgaGVpZ2h0ID0gYm94LmJvdHRvbSAtIGJveC50b3BcXG4gICAgfVxcbiAgICB2YXIgZGlmZiA9IGN1ci5saW5lLmhlaWdodCAtIGhlaWdodFxcbiAgICBpZiAoaGVpZ2h0IDwgMikgeyBoZWlnaHQgPSB0ZXh0SGVpZ2h0KGRpc3BsYXkpIH1cXG4gICAgaWYgKGRpZmYgPiAuMDAxIHx8IGRpZmYgPCAtLjAwMSkge1xcbiAgICAgIHVwZGF0ZUxpbmVIZWlnaHQoY3VyLmxpbmUsIGhlaWdodClcXG4gICAgICB1cGRhdGVXaWRnZXRIZWlnaHQoY3VyLmxpbmUpXFxuICAgICAgaWYgKGN1ci5yZXN0KSB7IGZvciAodmFyIGogPSAwOyBqIDwgY3VyLnJlc3QubGVuZ3RoOyBqKyspXFxuICAgICAgICB7IHVwZGF0ZVdpZGdldEhlaWdodChjdXIucmVzdFtqXSkgfSB9XFxuICAgIH1cXG4gIH1cXG59XFxuXFxuLy8gUmVhZCBhbmQgc3RvcmUgdGhlIGhlaWdodCBvZiBsaW5lIHdpZGdldHMgYXNzb2NpYXRlZCB3aXRoIHRoZVxcbi8vIGdpdmVuIGxpbmUuXFxuZnVuY3Rpb24gdXBkYXRlV2lkZ2V0SGVpZ2h0KGxpbmUpIHtcXG4gIGlmIChsaW5lLndpZGdldHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lLndpZGdldHMubGVuZ3RoOyArK2kpXFxuICAgIHsgbGluZS53aWRnZXRzW2ldLmhlaWdodCA9IGxpbmUud2lkZ2V0c1tpXS5ub2RlLnBhcmVudE5vZGUub2Zmc2V0SGVpZ2h0IH0gfVxcbn1cXG5cXG4vLyBDb21wdXRlIHRoZSBsaW5lcyB0aGF0IGFyZSB2aXNpYmxlIGluIGEgZ2l2ZW4gdmlld3BvcnQgKGRlZmF1bHRzXFxuLy8gdGhlIHRoZSBjdXJyZW50IHNjcm9sbCBwb3NpdGlvbikuIHZpZXdwb3J0IG1heSBjb250YWluIHRvcCxcXG4vLyBoZWlnaHQsIGFuZCBlbnN1cmUgKHNlZSBvcC5zY3JvbGxUb1BvcykgcHJvcGVydGllcy5cXG5mdW5jdGlvbiB2aXNpYmxlTGluZXMoZGlzcGxheSwgZG9jLCB2aWV3cG9ydCkge1xcbiAgdmFyIHRvcCA9IHZpZXdwb3J0ICYmIHZpZXdwb3J0LnRvcCAhPSBudWxsID8gTWF0aC5tYXgoMCwgdmlld3BvcnQudG9wKSA6IGRpc3BsYXkuc2Nyb2xsZXIuc2Nyb2xsVG9wXFxuICB0b3AgPSBNYXRoLmZsb29yKHRvcCAtIHBhZGRpbmdUb3AoZGlzcGxheSkpXFxuICB2YXIgYm90dG9tID0gdmlld3BvcnQgJiYgdmlld3BvcnQuYm90dG9tICE9IG51bGwgPyB2aWV3cG9ydC5ib3R0b20gOiB0b3AgKyBkaXNwbGF5LndyYXBwZXIuY2xpZW50SGVpZ2h0XFxuXFxuICB2YXIgZnJvbSA9IGxpbmVBdEhlaWdodChkb2MsIHRvcCksIHRvID0gbGluZUF0SGVpZ2h0KGRvYywgYm90dG9tKVxcbiAgLy8gRW5zdXJlIGlzIGEge2Zyb206IHtsaW5lLCBjaH0sIHRvOiB7bGluZSwgY2h9fSBvYmplY3QsIGFuZFxcbiAgLy8gZm9yY2VzIHRob3NlIGxpbmVzIGludG8gdGhlIHZpZXdwb3J0IChpZiBwb3NzaWJsZSkuXFxuICBpZiAodmlld3BvcnQgJiYgdmlld3BvcnQuZW5zdXJlKSB7XFxuICAgIHZhciBlbnN1cmVGcm9tID0gdmlld3BvcnQuZW5zdXJlLmZyb20ubGluZSwgZW5zdXJlVG8gPSB2aWV3cG9ydC5lbnN1cmUudG8ubGluZVxcbiAgICBpZiAoZW5zdXJlRnJvbSA8IGZyb20pIHtcXG4gICAgICBmcm9tID0gZW5zdXJlRnJvbVxcbiAgICAgIHRvID0gbGluZUF0SGVpZ2h0KGRvYywgaGVpZ2h0QXRMaW5lKGdldExpbmUoZG9jLCBlbnN1cmVGcm9tKSkgKyBkaXNwbGF5LndyYXBwZXIuY2xpZW50SGVpZ2h0KVxcbiAgICB9IGVsc2UgaWYgKE1hdGgubWluKGVuc3VyZVRvLCBkb2MubGFzdExpbmUoKSkgPj0gdG8pIHtcXG4gICAgICBmcm9tID0gbGluZUF0SGVpZ2h0KGRvYywgaGVpZ2h0QXRMaW5lKGdldExpbmUoZG9jLCBlbnN1cmVUbykpIC0gZGlzcGxheS53cmFwcGVyLmNsaWVudEhlaWdodClcXG4gICAgICB0byA9IGVuc3VyZVRvXFxuICAgIH1cXG4gIH1cXG4gIHJldHVybiB7ZnJvbTogZnJvbSwgdG86IE1hdGgubWF4KHRvLCBmcm9tICsgMSl9XFxufVxcblxcbi8vIFN5bmMgdGhlIHNjcm9sbGFibGUgYXJlYSBhbmQgc2Nyb2xsYmFycywgZW5zdXJlIHRoZSB2aWV3cG9ydFxcbi8vIGNvdmVycyB0aGUgdmlzaWJsZSBhcmVhLlxcbmZ1bmN0aW9uIHNldFNjcm9sbFRvcChjbSwgdmFsKSB7XFxuICBpZiAoTWF0aC5hYnMoY20uZG9jLnNjcm9sbFRvcCAtIHZhbCkgPCAyKSB7IHJldHVybiB9XFxuICBjbS5kb2Muc2Nyb2xsVG9wID0gdmFsXFxuICBpZiAoIWdlY2tvKSB7IHVwZGF0ZURpc3BsYXlTaW1wbGUoY20sIHt0b3A6IHZhbH0pIH1cXG4gIGlmIChjbS5kaXNwbGF5LnNjcm9sbGVyLnNjcm9sbFRvcCAhPSB2YWwpIHsgY20uZGlzcGxheS5zY3JvbGxlci5zY3JvbGxUb3AgPSB2YWwgfVxcbiAgY20uZGlzcGxheS5zY3JvbGxiYXJzLnNldFNjcm9sbFRvcCh2YWwpXFxuICBpZiAoZ2Vja28pIHsgdXBkYXRlRGlzcGxheVNpbXBsZShjbSkgfVxcbiAgc3RhcnRXb3JrZXIoY20sIDEwMClcXG59XFxuLy8gU3luYyBzY3JvbGxlciBhbmQgc2Nyb2xsYmFyLCBlbnN1cmUgdGhlIGd1dHRlciBlbGVtZW50cyBhcmVcXG4vLyBhbGlnbmVkLlxcbmZ1bmN0aW9uIHNldFNjcm9sbExlZnQoY20sIHZhbCwgaXNTY3JvbGxlcikge1xcbiAgaWYgKGlzU2Nyb2xsZXIgPyB2YWwgPT0gY20uZG9jLnNjcm9sbExlZnQgOiBNYXRoLmFicyhjbS5kb2Muc2Nyb2xsTGVmdCAtIHZhbCkgPCAyKSB7IHJldHVybiB9XFxuICB2YWwgPSBNYXRoLm1pbih2YWwsIGNtLmRpc3BsYXkuc2Nyb2xsZXIuc2Nyb2xsV2lkdGggLSBjbS5kaXNwbGF5LnNjcm9sbGVyLmNsaWVudFdpZHRoKVxcbiAgY20uZG9jLnNjcm9sbExlZnQgPSB2YWxcXG4gIGFsaWduSG9yaXpvbnRhbGx5KGNtKVxcbiAgaWYgKGNtLmRpc3BsYXkuc2Nyb2xsZXIuc2Nyb2xsTGVmdCAhPSB2YWwpIHsgY20uZGlzcGxheS5zY3JvbGxlci5zY3JvbGxMZWZ0ID0gdmFsIH1cXG4gIGNtLmRpc3BsYXkuc2Nyb2xsYmFycy5zZXRTY3JvbGxMZWZ0KHZhbClcXG59XFxuXFxuLy8gU2luY2UgdGhlIGRlbHRhIHZhbHVlcyByZXBvcnRlZCBvbiBtb3VzZSB3aGVlbCBldmVudHMgYXJlXFxuLy8gdW5zdGFuZGFyZGl6ZWQgYmV0d2VlbiBicm93c2VycyBhbmQgZXZlbiBicm93c2VyIHZlcnNpb25zLCBhbmRcXG4vLyBnZW5lcmFsbHkgaG9ycmlibHkgdW5wcmVkaWN0YWJsZSwgdGhpcyBjb2RlIHN0YXJ0cyBieSBtZWFzdXJpbmdcXG4vLyB0aGUgc2Nyb2xsIGVmZmVjdCB0aGF0IHRoZSBmaXJzdCBmZXcgbW91c2Ugd2hlZWwgZXZlbnRzIGhhdmUsXFxuLy8gYW5kLCBmcm9tIHRoYXQsIGRldGVjdHMgdGhlIHdheSBpdCBjYW4gY29udmVydCBkZWx0YXMgdG8gcGl4ZWxcXG4vLyBvZmZzZXRzIGFmdGVyd2FyZHMuXFxuLy9cXG4vLyBUaGUgcmVhc29uIHdlIHdhbnQgdG8ga25vdyB0aGUgYW1vdW50IGEgd2hlZWwgZXZlbnQgd2lsbCBzY3JvbGxcXG4vLyBpcyB0aGF0IGl0IGdpdmVzIHVzIGEgY2hhbmNlIHRvIHVwZGF0ZSB0aGUgZGlzcGxheSBiZWZvcmUgdGhlXFxuLy8gYWN0dWFsIHNjcm9sbGluZyBoYXBwZW5zLCByZWR1Y2luZyBmbGlja2VyaW5nLlxcblxcbnZhciB3aGVlbFNhbXBsZXMgPSAwO1xcbnZhciB3aGVlbFBpeGVsc1BlclVuaXQgPSBudWxsO1xcbi8vIEZpbGwgaW4gYSBicm93c2VyLWRldGVjdGVkIHN0YXJ0aW5nIHZhbHVlIG9uIGJyb3dzZXJzIHdoZXJlIHdlXFxuLy8ga25vdyBvbmUuIFRoZXNlIGRvbid0IGhhdmUgdG8gYmUgYWNjdXJhdGUgLS0gdGhlIHJlc3VsdCBvZiB0aGVtXFxuLy8gYmVpbmcgd3Jvbmcgd291bGQganVzdCBiZSBhIHNsaWdodCBmbGlja2VyIG9uIHRoZSBmaXJzdCB3aGVlbFxcbi8vIHNjcm9sbCAoaWYgaXQgaXMgbGFyZ2UgZW5vdWdoKS5cXG5pZiAoaWUpIHsgd2hlZWxQaXhlbHNQZXJVbml0ID0gLS41MyB9XFxuZWxzZSBpZiAoZ2Vja28pIHsgd2hlZWxQaXhlbHNQZXJVbml0ID0gMTUgfVxcbmVsc2UgaWYgKGNocm9tZSkgeyB3aGVlbFBpeGVsc1BlclVuaXQgPSAtLjcgfVxcbmVsc2UgaWYgKHNhZmFyaSkgeyB3aGVlbFBpeGVsc1BlclVuaXQgPSAtMS8zIH1cXG5cXG5mdW5jdGlvbiB3aGVlbEV2ZW50RGVsdGEoZSkge1xcbiAgdmFyIGR4ID0gZS53aGVlbERlbHRhWCwgZHkgPSBlLndoZWVsRGVsdGFZXFxuICBpZiAoZHggPT0gbnVsbCAmJiBlLmRldGFpbCAmJiBlLmF4aXMgPT0gZS5IT1JJWk9OVEFMX0FYSVMpIHsgZHggPSBlLmRldGFpbCB9XFxuICBpZiAoZHkgPT0gbnVsbCAmJiBlLmRldGFpbCAmJiBlLmF4aXMgPT0gZS5WRVJUSUNBTF9BWElTKSB7IGR5ID0gZS5kZXRhaWwgfVxcbiAgZWxzZSBpZiAoZHkgPT0gbnVsbCkgeyBkeSA9IGUud2hlZWxEZWx0YSB9XFxuICByZXR1cm4ge3g6IGR4LCB5OiBkeX1cXG59XFxuZnVuY3Rpb24gd2hlZWxFdmVudFBpeGVscyhlKSB7XFxuICB2YXIgZGVsdGEgPSB3aGVlbEV2ZW50RGVsdGEoZSlcXG4gIGRlbHRhLnggKj0gd2hlZWxQaXhlbHNQZXJVbml0XFxuICBkZWx0YS55ICo9IHdoZWVsUGl4ZWxzUGVyVW5pdFxcbiAgcmV0dXJuIGRlbHRhXFxufVxcblxcbmZ1bmN0aW9uIG9uU2Nyb2xsV2hlZWwoY20sIGUpIHtcXG4gIHZhciBkZWx0YSA9IHdoZWVsRXZlbnREZWx0YShlKSwgZHggPSBkZWx0YS54LCBkeSA9IGRlbHRhLnlcXG5cXG4gIHZhciBkaXNwbGF5ID0gY20uZGlzcGxheSwgc2Nyb2xsID0gZGlzcGxheS5zY3JvbGxlclxcbiAgLy8gUXVpdCBpZiB0aGVyZSdzIG5vdGhpbmcgdG8gc2Nyb2xsIGhlcmVcXG4gIHZhciBjYW5TY3JvbGxYID0gc2Nyb2xsLnNjcm9sbFdpZHRoID4gc2Nyb2xsLmNsaWVudFdpZHRoXFxuICB2YXIgY2FuU2Nyb2xsWSA9IHNjcm9sbC5zY3JvbGxIZWlnaHQgPiBzY3JvbGwuY2xpZW50SGVpZ2h0XFxuICBpZiAoIShkeCAmJiBjYW5TY3JvbGxYIHx8IGR5ICYmIGNhblNjcm9sbFkpKSB7IHJldHVybiB9XFxuXFxuICAvLyBXZWJraXQgYnJvd3NlcnMgb24gT1MgWCBhYm9ydCBtb21lbnR1bSBzY3JvbGxzIHdoZW4gdGhlIHRhcmdldFxcbiAgLy8gb2YgdGhlIHNjcm9sbCBldmVudCBpcyByZW1vdmVkIGZyb20gdGhlIHNjcm9sbGFibGUgZWxlbWVudC5cXG4gIC8vIFRoaXMgaGFjayAoc2VlIHJlbGF0ZWQgY29kZSBpbiBwYXRjaERpc3BsYXkpIG1ha2VzIHN1cmUgdGhlXFxuICAvLyBlbGVtZW50IGlzIGtlcHQgYXJvdW5kLlxcbiAgaWYgKGR5ICYmIG1hYyAmJiB3ZWJraXQpIHtcXG4gICAgb3V0ZXI6IGZvciAodmFyIGN1ciA9IGUudGFyZ2V0LCB2aWV3ID0gZGlzcGxheS52aWV3OyBjdXIgIT0gc2Nyb2xsOyBjdXIgPSBjdXIucGFyZW50Tm9kZSkge1xcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmlldy5sZW5ndGg7IGkrKykge1xcbiAgICAgICAgaWYgKHZpZXdbaV0ubm9kZSA9PSBjdXIpIHtcXG4gICAgICAgICAgY20uZGlzcGxheS5jdXJyZW50V2hlZWxUYXJnZXQgPSBjdXJcXG4gICAgICAgICAgYnJlYWsgb3V0ZXJcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIH1cXG4gIH1cXG5cXG4gIC8vIE9uIHNvbWUgYnJvd3NlcnMsIGhvcml6b250YWwgc2Nyb2xsaW5nIHdpbGwgY2F1c2UgcmVkcmF3cyB0b1xcbiAgLy8gaGFwcGVuIGJlZm9yZSB0aGUgZ3V0dGVyIGhhcyBiZWVuIHJlYWxpZ25lZCwgY2F1c2luZyBpdCB0b1xcbiAgLy8gd3JpZ2dsZSBhcm91bmQgaW4gYSBtb3N0IHVuc2VlbWx5IHdheS4gV2hlbiB3ZSBoYXZlIGFuXFxuICAvLyBlc3RpbWF0ZWQgcGl4ZWxzL2RlbHRhIHZhbHVlLCB3ZSBqdXN0IGhhbmRsZSBob3Jpem9udGFsXFxuICAvLyBzY3JvbGxpbmcgZW50aXJlbHkgaGVyZS4gSXQnbGwgYmUgc2xpZ2h0bHkgb2ZmIGZyb20gbmF0aXZlLCBidXRcXG4gIC8vIGJldHRlciB0aGFuIGdsaXRjaGluZyBvdXQuXFxuICBpZiAoZHggJiYgIWdlY2tvICYmICFwcmVzdG8gJiYgd2hlZWxQaXhlbHNQZXJVbml0ICE9IG51bGwpIHtcXG4gICAgaWYgKGR5ICYmIGNhblNjcm9sbFkpXFxuICAgICAgeyBzZXRTY3JvbGxUb3AoY20sIE1hdGgubWF4KDAsIE1hdGgubWluKHNjcm9sbC5zY3JvbGxUb3AgKyBkeSAqIHdoZWVsUGl4ZWxzUGVyVW5pdCwgc2Nyb2xsLnNjcm9sbEhlaWdodCAtIHNjcm9sbC5jbGllbnRIZWlnaHQpKSkgfVxcbiAgICBzZXRTY3JvbGxMZWZ0KGNtLCBNYXRoLm1heCgwLCBNYXRoLm1pbihzY3JvbGwuc2Nyb2xsTGVmdCArIGR4ICogd2hlZWxQaXhlbHNQZXJVbml0LCBzY3JvbGwuc2Nyb2xsV2lkdGggLSBzY3JvbGwuY2xpZW50V2lkdGgpKSlcXG4gICAgLy8gT25seSBwcmV2ZW50IGRlZmF1bHQgc2Nyb2xsaW5nIGlmIHZlcnRpY2FsIHNjcm9sbGluZyBpc1xcbiAgICAvLyBhY3R1YWxseSBwb3NzaWJsZS4gT3RoZXJ3aXNlLCBpdCBjYXVzZXMgdmVydGljYWwgc2Nyb2xsXFxuICAgIC8vIGppdHRlciBvbiBPU1ggdHJhY2twYWRzIHdoZW4gZGVsdGFYIGlzIHNtYWxsIGFuZCBkZWx0YVlcXG4gICAgLy8gaXMgbGFyZ2UgKGlzc3VlICMzNTc5KVxcbiAgICBpZiAoIWR5IHx8IChkeSAmJiBjYW5TY3JvbGxZKSlcXG4gICAgICB7IGVfcHJldmVudERlZmF1bHQoZSkgfVxcbiAgICBkaXNwbGF5LndoZWVsU3RhcnRYID0gbnVsbCAvLyBBYm9ydCBtZWFzdXJlbWVudCwgaWYgaW4gcHJvZ3Jlc3NcXG4gICAgcmV0dXJuXFxuICB9XFxuXFxuICAvLyAnUHJvamVjdCcgdGhlIHZpc2libGUgdmlld3BvcnQgdG8gY292ZXIgdGhlIGFyZWEgdGhhdCBpcyBiZWluZ1xcbiAgLy8gc2Nyb2xsZWQgaW50byB2aWV3IChpZiB3ZSBrbm93IGVub3VnaCB0byBlc3RpbWF0ZSBpdCkuXFxuICBpZiAoZHkgJiYgd2hlZWxQaXhlbHNQZXJVbml0ICE9IG51bGwpIHtcXG4gICAgdmFyIHBpeGVscyA9IGR5ICogd2hlZWxQaXhlbHNQZXJVbml0XFxuICAgIHZhciB0b3AgPSBjbS5kb2Muc2Nyb2xsVG9wLCBib3QgPSB0b3AgKyBkaXNwbGF5LndyYXBwZXIuY2xpZW50SGVpZ2h0XFxuICAgIGlmIChwaXhlbHMgPCAwKSB7IHRvcCA9IE1hdGgubWF4KDAsIHRvcCArIHBpeGVscyAtIDUwKSB9XFxuICAgIGVsc2UgeyBib3QgPSBNYXRoLm1pbihjbS5kb2MuaGVpZ2h0LCBib3QgKyBwaXhlbHMgKyA1MCkgfVxcbiAgICB1cGRhdGVEaXNwbGF5U2ltcGxlKGNtLCB7dG9wOiB0b3AsIGJvdHRvbTogYm90fSlcXG4gIH1cXG5cXG4gIGlmICh3aGVlbFNhbXBsZXMgPCAyMCkge1xcbiAgICBpZiAoZGlzcGxheS53aGVlbFN0YXJ0WCA9PSBudWxsKSB7XFxuICAgICAgZGlzcGxheS53aGVlbFN0YXJ0WCA9IHNjcm9sbC5zY3JvbGxMZWZ0OyBkaXNwbGF5LndoZWVsU3RhcnRZID0gc2Nyb2xsLnNjcm9sbFRvcFxcbiAgICAgIGRpc3BsYXkud2hlZWxEWCA9IGR4OyBkaXNwbGF5LndoZWVsRFkgPSBkeVxcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xcbiAgICAgICAgaWYgKGRpc3BsYXkud2hlZWxTdGFydFggPT0gbnVsbCkgeyByZXR1cm4gfVxcbiAgICAgICAgdmFyIG1vdmVkWCA9IHNjcm9sbC5zY3JvbGxMZWZ0IC0gZGlzcGxheS53aGVlbFN0YXJ0WFxcbiAgICAgICAgdmFyIG1vdmVkWSA9IHNjcm9sbC5zY3JvbGxUb3AgLSBkaXNwbGF5LndoZWVsU3RhcnRZXFxuICAgICAgICB2YXIgc2FtcGxlID0gKG1vdmVkWSAmJiBkaXNwbGF5LndoZWVsRFkgJiYgbW92ZWRZIC8gZGlzcGxheS53aGVlbERZKSB8fFxcbiAgICAgICAgICAobW92ZWRYICYmIGRpc3BsYXkud2hlZWxEWCAmJiBtb3ZlZFggLyBkaXNwbGF5LndoZWVsRFgpXFxuICAgICAgICBkaXNwbGF5LndoZWVsU3RhcnRYID0gZGlzcGxheS53aGVlbFN0YXJ0WSA9IG51bGxcXG4gICAgICAgIGlmICghc2FtcGxlKSB7IHJldHVybiB9XFxuICAgICAgICB3aGVlbFBpeGVsc1BlclVuaXQgPSAod2hlZWxQaXhlbHNQZXJVbml0ICogd2hlZWxTYW1wbGVzICsgc2FtcGxlKSAvICh3aGVlbFNhbXBsZXMgKyAxKVxcbiAgICAgICAgKyt3aGVlbFNhbXBsZXNcXG4gICAgICB9LCAyMDApXFxuICAgIH0gZWxzZSB7XFxuICAgICAgZGlzcGxheS53aGVlbERYICs9IGR4OyBkaXNwbGF5LndoZWVsRFkgKz0gZHlcXG4gICAgfVxcbiAgfVxcbn1cXG5cXG4vLyBTQ1JPTExCQVJTXFxuXFxuLy8gUHJlcGFyZSBET00gcmVhZHMgbmVlZGVkIHRvIHVwZGF0ZSB0aGUgc2Nyb2xsYmFycy4gRG9uZSBpbiBvbmVcXG4vLyBzaG90IHRvIG1pbmltaXplIHVwZGF0ZS9tZWFzdXJlIHJvdW5kdHJpcHMuXFxuZnVuY3Rpb24gbWVhc3VyZUZvclNjcm9sbGJhcnMoY20pIHtcXG4gIHZhciBkID0gY20uZGlzcGxheSwgZ3V0dGVyVyA9IGQuZ3V0dGVycy5vZmZzZXRXaWR0aFxcbiAgdmFyIGRvY0ggPSBNYXRoLnJvdW5kKGNtLmRvYy5oZWlnaHQgKyBwYWRkaW5nVmVydChjbS5kaXNwbGF5KSlcXG4gIHJldHVybiB7XFxuICAgIGNsaWVudEhlaWdodDogZC5zY3JvbGxlci5jbGllbnRIZWlnaHQsXFxuICAgIHZpZXdIZWlnaHQ6IGQud3JhcHBlci5jbGllbnRIZWlnaHQsXFxuICAgIHNjcm9sbFdpZHRoOiBkLnNjcm9sbGVyLnNjcm9sbFdpZHRoLCBjbGllbnRXaWR0aDogZC5zY3JvbGxlci5jbGllbnRXaWR0aCxcXG4gICAgdmlld1dpZHRoOiBkLndyYXBwZXIuY2xpZW50V2lkdGgsXFxuICAgIGJhckxlZnQ6IGNtLm9wdGlvbnMuZml4ZWRHdXR0ZXIgPyBndXR0ZXJXIDogMCxcXG4gICAgZG9jSGVpZ2h0OiBkb2NILFxcbiAgICBzY3JvbGxIZWlnaHQ6IGRvY0ggKyBzY3JvbGxHYXAoY20pICsgZC5iYXJIZWlnaHQsXFxuICAgIG5hdGl2ZUJhcldpZHRoOiBkLm5hdGl2ZUJhcldpZHRoLFxcbiAgICBndXR0ZXJXaWR0aDogZ3V0dGVyV1xcbiAgfVxcbn1cXG5cXG5mdW5jdGlvbiBOYXRpdmVTY3JvbGxiYXJzKHBsYWNlLCBzY3JvbGwsIGNtKSB7XFxuICB0aGlzLmNtID0gY21cXG4gIHZhciB2ZXJ0ID0gdGhpcy52ZXJ0ID0gZWx0KFxcXCJkaXZcXFwiLCBbZWx0KFxcXCJkaXZcXFwiLCBudWxsLCBudWxsLCBcXFwibWluLXdpZHRoOiAxcHhcXFwiKV0sIFxcXCJDb2RlTWlycm9yLXZzY3JvbGxiYXJcXFwiKVxcbiAgdmFyIGhvcml6ID0gdGhpcy5ob3JpeiA9IGVsdChcXFwiZGl2XFxcIiwgW2VsdChcXFwiZGl2XFxcIiwgbnVsbCwgbnVsbCwgXFxcImhlaWdodDogMTAwJTsgbWluLWhlaWdodDogMXB4XFxcIildLCBcXFwiQ29kZU1pcnJvci1oc2Nyb2xsYmFyXFxcIilcXG4gIHBsYWNlKHZlcnQpOyBwbGFjZShob3JpeilcXG5cXG4gIG9uKHZlcnQsIFxcXCJzY3JvbGxcXFwiLCBmdW5jdGlvbiAoKSB7XFxuICAgIGlmICh2ZXJ0LmNsaWVudEhlaWdodCkgeyBzY3JvbGwodmVydC5zY3JvbGxUb3AsIFxcXCJ2ZXJ0aWNhbFxcXCIpIH1cXG4gIH0pXFxuICBvbihob3JpeiwgXFxcInNjcm9sbFxcXCIsIGZ1bmN0aW9uICgpIHtcXG4gICAgaWYgKGhvcml6LmNsaWVudFdpZHRoKSB7IHNjcm9sbChob3Jpei5zY3JvbGxMZWZ0LCBcXFwiaG9yaXpvbnRhbFxcXCIpIH1cXG4gIH0pXFxuXFxuICB0aGlzLmNoZWNrZWRaZXJvV2lkdGggPSBmYWxzZVxcbiAgLy8gTmVlZCB0byBzZXQgYSBtaW5pbXVtIHdpZHRoIHRvIHNlZSB0aGUgc2Nyb2xsYmFyIG9uIElFNyAoYnV0IG11c3Qgbm90IHNldCBpdCBvbiBJRTgpLlxcbiAgaWYgKGllICYmIGllX3ZlcnNpb24gPCA4KSB7IHRoaXMuaG9yaXouc3R5bGUubWluSGVpZ2h0ID0gdGhpcy52ZXJ0LnN0eWxlLm1pbldpZHRoID0gXFxcIjE4cHhcXFwiIH1cXG59XFxuXFxuTmF0aXZlU2Nyb2xsYmFycy5wcm90b3R5cGUgPSBjb3B5T2JqKHtcXG4gIHVwZGF0ZTogZnVuY3Rpb24obWVhc3VyZSkge1xcbiAgICB2YXIgbmVlZHNIID0gbWVhc3VyZS5zY3JvbGxXaWR0aCA+IG1lYXN1cmUuY2xpZW50V2lkdGggKyAxXFxuICAgIHZhciBuZWVkc1YgPSBtZWFzdXJlLnNjcm9sbEhlaWdodCA+IG1lYXN1cmUuY2xpZW50SGVpZ2h0ICsgMVxcbiAgICB2YXIgc1dpZHRoID0gbWVhc3VyZS5uYXRpdmVCYXJXaWR0aFxcblxcbiAgICBpZiAobmVlZHNWKSB7XFxuICAgICAgdGhpcy52ZXJ0LnN0eWxlLmRpc3BsYXkgPSBcXFwiYmxvY2tcXFwiXFxuICAgICAgdGhpcy52ZXJ0LnN0eWxlLmJvdHRvbSA9IG5lZWRzSCA/IHNXaWR0aCArIFxcXCJweFxcXCIgOiBcXFwiMFxcXCJcXG4gICAgICB2YXIgdG90YWxIZWlnaHQgPSBtZWFzdXJlLnZpZXdIZWlnaHQgLSAobmVlZHNIID8gc1dpZHRoIDogMClcXG4gICAgICAvLyBBIGJ1ZyBpbiBJRTggY2FuIGNhdXNlIHRoaXMgdmFsdWUgdG8gYmUgbmVnYXRpdmUsIHNvIGd1YXJkIGl0LlxcbiAgICAgIHRoaXMudmVydC5maXJzdENoaWxkLnN0eWxlLmhlaWdodCA9XFxuICAgICAgICBNYXRoLm1heCgwLCBtZWFzdXJlLnNjcm9sbEhlaWdodCAtIG1lYXN1cmUuY2xpZW50SGVpZ2h0ICsgdG90YWxIZWlnaHQpICsgXFxcInB4XFxcIlxcbiAgICB9IGVsc2Uge1xcbiAgICAgIHRoaXMudmVydC5zdHlsZS5kaXNwbGF5ID0gXFxcIlxcXCJcXG4gICAgICB0aGlzLnZlcnQuZmlyc3RDaGlsZC5zdHlsZS5oZWlnaHQgPSBcXFwiMFxcXCJcXG4gICAgfVxcblxcbiAgICBpZiAobmVlZHNIKSB7XFxuICAgICAgdGhpcy5ob3Jpei5zdHlsZS5kaXNwbGF5ID0gXFxcImJsb2NrXFxcIlxcbiAgICAgIHRoaXMuaG9yaXouc3R5bGUucmlnaHQgPSBuZWVkc1YgPyBzV2lkdGggKyBcXFwicHhcXFwiIDogXFxcIjBcXFwiXFxuICAgICAgdGhpcy5ob3Jpei5zdHlsZS5sZWZ0ID0gbWVhc3VyZS5iYXJMZWZ0ICsgXFxcInB4XFxcIlxcbiAgICAgIHZhciB0b3RhbFdpZHRoID0gbWVhc3VyZS52aWV3V2lkdGggLSBtZWFzdXJlLmJhckxlZnQgLSAobmVlZHNWID8gc1dpZHRoIDogMClcXG4gICAgICB0aGlzLmhvcml6LmZpcnN0Q2hpbGQuc3R5bGUud2lkdGggPVxcbiAgICAgICAgKG1lYXN1cmUuc2Nyb2xsV2lkdGggLSBtZWFzdXJlLmNsaWVudFdpZHRoICsgdG90YWxXaWR0aCkgKyBcXFwicHhcXFwiXFxuICAgIH0gZWxzZSB7XFxuICAgICAgdGhpcy5ob3Jpei5zdHlsZS5kaXNwbGF5ID0gXFxcIlxcXCJcXG4gICAgICB0aGlzLmhvcml6LmZpcnN0Q2hpbGQuc3R5bGUud2lkdGggPSBcXFwiMFxcXCJcXG4gICAgfVxcblxcbiAgICBpZiAoIXRoaXMuY2hlY2tlZFplcm9XaWR0aCAmJiBtZWFzdXJlLmNsaWVudEhlaWdodCA+IDApIHtcXG4gICAgICBpZiAoc1dpZHRoID09IDApIHsgdGhpcy56ZXJvV2lkdGhIYWNrKCkgfVxcbiAgICAgIHRoaXMuY2hlY2tlZFplcm9XaWR0aCA9IHRydWVcXG4gICAgfVxcblxcbiAgICByZXR1cm4ge3JpZ2h0OiBuZWVkc1YgPyBzV2lkdGggOiAwLCBib3R0b206IG5lZWRzSCA/IHNXaWR0aCA6IDB9XFxuICB9LFxcbiAgc2V0U2Nyb2xsTGVmdDogZnVuY3Rpb24ocG9zKSB7XFxuICAgIGlmICh0aGlzLmhvcml6LnNjcm9sbExlZnQgIT0gcG9zKSB7IHRoaXMuaG9yaXouc2Nyb2xsTGVmdCA9IHBvcyB9XFxuICAgIGlmICh0aGlzLmRpc2FibGVIb3JpeikgeyB0aGlzLmVuYWJsZVplcm9XaWR0aEJhcih0aGlzLmhvcml6LCB0aGlzLmRpc2FibGVIb3JpeikgfVxcbiAgfSxcXG4gIHNldFNjcm9sbFRvcDogZnVuY3Rpb24ocG9zKSB7XFxuICAgIGlmICh0aGlzLnZlcnQuc2Nyb2xsVG9wICE9IHBvcykgeyB0aGlzLnZlcnQuc2Nyb2xsVG9wID0gcG9zIH1cXG4gICAgaWYgKHRoaXMuZGlzYWJsZVZlcnQpIHsgdGhpcy5lbmFibGVaZXJvV2lkdGhCYXIodGhpcy52ZXJ0LCB0aGlzLmRpc2FibGVWZXJ0KSB9XFxuICB9LFxcbiAgemVyb1dpZHRoSGFjazogZnVuY3Rpb24oKSB7XFxuICAgIHZhciB3ID0gbWFjICYmICFtYWNfZ2VNb3VudGFpbkxpb24gPyBcXFwiMTJweFxcXCIgOiBcXFwiMThweFxcXCJcXG4gICAgdGhpcy5ob3Jpei5zdHlsZS5oZWlnaHQgPSB0aGlzLnZlcnQuc3R5bGUud2lkdGggPSB3XFxuICAgIHRoaXMuaG9yaXouc3R5bGUucG9pbnRlckV2ZW50cyA9IHRoaXMudmVydC5zdHlsZS5wb2ludGVyRXZlbnRzID0gXFxcIm5vbmVcXFwiXFxuICAgIHRoaXMuZGlzYWJsZUhvcml6ID0gbmV3IERlbGF5ZWRcXG4gICAgdGhpcy5kaXNhYmxlVmVydCA9IG5ldyBEZWxheWVkXFxuICB9LFxcbiAgZW5hYmxlWmVyb1dpZHRoQmFyOiBmdW5jdGlvbihiYXIsIGRlbGF5KSB7XFxuICAgIGJhci5zdHlsZS5wb2ludGVyRXZlbnRzID0gXFxcImF1dG9cXFwiXFxuICAgIGZ1bmN0aW9uIG1heWJlRGlzYWJsZSgpIHtcXG4gICAgICAvLyBUbyBmaW5kIG91dCB3aGV0aGVyIHRoZSBzY3JvbGxiYXIgaXMgc3RpbGwgdmlzaWJsZSwgd2VcXG4gICAgICAvLyBjaGVjayB3aGV0aGVyIHRoZSBlbGVtZW50IHVuZGVyIHRoZSBwaXhlbCBpbiB0aGUgYm90dG9tXFxuICAgICAgLy8gbGVmdCBjb3JuZXIgb2YgdGhlIHNjcm9sbGJhciBib3ggaXMgdGhlIHNjcm9sbGJhciBib3hcXG4gICAgICAvLyBpdHNlbGYgKHdoZW4gdGhlIGJhciBpcyBzdGlsbCB2aXNpYmxlKSBvciBpdHMgZmlsbGVyIGNoaWxkXFxuICAgICAgLy8gKHdoZW4gdGhlIGJhciBpcyBoaWRkZW4pLiBJZiBpdCBpcyBzdGlsbCB2aXNpYmxlLCB3ZSBrZWVwXFxuICAgICAgLy8gaXQgZW5hYmxlZCwgaWYgaXQncyBoaWRkZW4sIHdlIGRpc2FibGUgcG9pbnRlciBldmVudHMuXFxuICAgICAgdmFyIGJveCA9IGJhci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxcbiAgICAgIHZhciBlbHQgPSBkb2N1bWVudC5lbGVtZW50RnJvbVBvaW50KGJveC5sZWZ0ICsgMSwgYm94LmJvdHRvbSAtIDEpXFxuICAgICAgaWYgKGVsdCAhPSBiYXIpIHsgYmFyLnN0eWxlLnBvaW50ZXJFdmVudHMgPSBcXFwibm9uZVxcXCIgfVxcbiAgICAgIGVsc2UgeyBkZWxheS5zZXQoMTAwMCwgbWF5YmVEaXNhYmxlKSB9XFxuICAgIH1cXG4gICAgZGVsYXkuc2V0KDEwMDAsIG1heWJlRGlzYWJsZSlcXG4gIH0sXFxuICBjbGVhcjogZnVuY3Rpb24oKSB7XFxuICAgIHZhciBwYXJlbnQgPSB0aGlzLmhvcml6LnBhcmVudE5vZGVcXG4gICAgcGFyZW50LnJlbW92ZUNoaWxkKHRoaXMuaG9yaXopXFxuICAgIHBhcmVudC5yZW1vdmVDaGlsZCh0aGlzLnZlcnQpXFxuICB9XFxufSwgTmF0aXZlU2Nyb2xsYmFycy5wcm90b3R5cGUpXFxuXFxuZnVuY3Rpb24gTnVsbFNjcm9sbGJhcnMoKSB7fVxcblxcbk51bGxTY3JvbGxiYXJzLnByb3RvdHlwZSA9IGNvcHlPYmooe1xcbiAgdXBkYXRlOiBmdW5jdGlvbigpIHsgcmV0dXJuIHtib3R0b206IDAsIHJpZ2h0OiAwfSB9LFxcbiAgc2V0U2Nyb2xsTGVmdDogZnVuY3Rpb24oKSB7fSxcXG4gIHNldFNjcm9sbFRvcDogZnVuY3Rpb24oKSB7fSxcXG4gIGNsZWFyOiBmdW5jdGlvbigpIHt9XFxufSwgTnVsbFNjcm9sbGJhcnMucHJvdG90eXBlKVxcblxcbmZ1bmN0aW9uIHVwZGF0ZVNjcm9sbGJhcnMoY20sIG1lYXN1cmUpIHtcXG4gIGlmICghbWVhc3VyZSkgeyBtZWFzdXJlID0gbWVhc3VyZUZvclNjcm9sbGJhcnMoY20pIH1cXG4gIHZhciBzdGFydFdpZHRoID0gY20uZGlzcGxheS5iYXJXaWR0aCwgc3RhcnRIZWlnaHQgPSBjbS5kaXNwbGF5LmJhckhlaWdodFxcbiAgdXBkYXRlU2Nyb2xsYmFyc0lubmVyKGNtLCBtZWFzdXJlKVxcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCA0ICYmIHN0YXJ0V2lkdGggIT0gY20uZGlzcGxheS5iYXJXaWR0aCB8fCBzdGFydEhlaWdodCAhPSBjbS5kaXNwbGF5LmJhckhlaWdodDsgaSsrKSB7XFxuICAgIGlmIChzdGFydFdpZHRoICE9IGNtLmRpc3BsYXkuYmFyV2lkdGggJiYgY20ub3B0aW9ucy5saW5lV3JhcHBpbmcpXFxuICAgICAgeyB1cGRhdGVIZWlnaHRzSW5WaWV3cG9ydChjbSkgfVxcbiAgICB1cGRhdGVTY3JvbGxiYXJzSW5uZXIoY20sIG1lYXN1cmVGb3JTY3JvbGxiYXJzKGNtKSlcXG4gICAgc3RhcnRXaWR0aCA9IGNtLmRpc3BsYXkuYmFyV2lkdGg7IHN0YXJ0SGVpZ2h0ID0gY20uZGlzcGxheS5iYXJIZWlnaHRcXG4gIH1cXG59XFxuXFxuLy8gUmUtc3luY2hyb25pemUgdGhlIGZha2Ugc2Nyb2xsYmFycyB3aXRoIHRoZSBhY3R1YWwgc2l6ZSBvZiB0aGVcXG4vLyBjb250ZW50LlxcbmZ1bmN0aW9uIHVwZGF0ZVNjcm9sbGJhcnNJbm5lcihjbSwgbWVhc3VyZSkge1xcbiAgdmFyIGQgPSBjbS5kaXNwbGF5XFxuICB2YXIgc2l6ZXMgPSBkLnNjcm9sbGJhcnMudXBkYXRlKG1lYXN1cmUpXFxuXFxuICBkLnNpemVyLnN0eWxlLnBhZGRpbmdSaWdodCA9IChkLmJhcldpZHRoID0gc2l6ZXMucmlnaHQpICsgXFxcInB4XFxcIlxcbiAgZC5zaXplci5zdHlsZS5wYWRkaW5nQm90dG9tID0gKGQuYmFySGVpZ2h0ID0gc2l6ZXMuYm90dG9tKSArIFxcXCJweFxcXCJcXG4gIGQuaGVpZ2h0Rm9yY2VyLnN0eWxlLmJvcmRlckJvdHRvbSA9IHNpemVzLmJvdHRvbSArIFxcXCJweCBzb2xpZCB0cmFuc3BhcmVudFxcXCJcXG5cXG4gIGlmIChzaXplcy5yaWdodCAmJiBzaXplcy5ib3R0b20pIHtcXG4gICAgZC5zY3JvbGxiYXJGaWxsZXIuc3R5bGUuZGlzcGxheSA9IFxcXCJibG9ja1xcXCJcXG4gICAgZC5zY3JvbGxiYXJGaWxsZXIuc3R5bGUuaGVpZ2h0ID0gc2l6ZXMuYm90dG9tICsgXFxcInB4XFxcIlxcbiAgICBkLnNjcm9sbGJhckZpbGxlci5zdHlsZS53aWR0aCA9IHNpemVzLnJpZ2h0ICsgXFxcInB4XFxcIlxcbiAgfSBlbHNlIHsgZC5zY3JvbGxiYXJGaWxsZXIuc3R5bGUuZGlzcGxheSA9IFxcXCJcXFwiIH1cXG4gIGlmIChzaXplcy5ib3R0b20gJiYgY20ub3B0aW9ucy5jb3Zlckd1dHRlck5leHRUb1Njcm9sbGJhciAmJiBjbS5vcHRpb25zLmZpeGVkR3V0dGVyKSB7XFxuICAgIGQuZ3V0dGVyRmlsbGVyLnN0eWxlLmRpc3BsYXkgPSBcXFwiYmxvY2tcXFwiXFxuICAgIGQuZ3V0dGVyRmlsbGVyLnN0eWxlLmhlaWdodCA9IHNpemVzLmJvdHRvbSArIFxcXCJweFxcXCJcXG4gICAgZC5ndXR0ZXJGaWxsZXIuc3R5bGUud2lkdGggPSBtZWFzdXJlLmd1dHRlcldpZHRoICsgXFxcInB4XFxcIlxcbiAgfSBlbHNlIHsgZC5ndXR0ZXJGaWxsZXIuc3R5bGUuZGlzcGxheSA9IFxcXCJcXFwiIH1cXG59XFxuXFxudmFyIHNjcm9sbGJhck1vZGVsID0ge1xcXCJuYXRpdmVcXFwiOiBOYXRpdmVTY3JvbGxiYXJzLCBcXFwibnVsbFxcXCI6IE51bGxTY3JvbGxiYXJzfVxcblxcbmZ1bmN0aW9uIGluaXRTY3JvbGxiYXJzKGNtKSB7XFxuICBpZiAoY20uZGlzcGxheS5zY3JvbGxiYXJzKSB7XFxuICAgIGNtLmRpc3BsYXkuc2Nyb2xsYmFycy5jbGVhcigpXFxuICAgIGlmIChjbS5kaXNwbGF5LnNjcm9sbGJhcnMuYWRkQ2xhc3MpXFxuICAgICAgeyBybUNsYXNzKGNtLmRpc3BsYXkud3JhcHBlciwgY20uZGlzcGxheS5zY3JvbGxiYXJzLmFkZENsYXNzKSB9XFxuICB9XFxuXFxuICBjbS5kaXNwbGF5LnNjcm9sbGJhcnMgPSBuZXcgc2Nyb2xsYmFyTW9kZWxbY20ub3B0aW9ucy5zY3JvbGxiYXJTdHlsZV0oZnVuY3Rpb24gKG5vZGUpIHtcXG4gICAgY20uZGlzcGxheS53cmFwcGVyLmluc2VydEJlZm9yZShub2RlLCBjbS5kaXNwbGF5LnNjcm9sbGJhckZpbGxlcilcXG4gICAgLy8gUHJldmVudCBjbGlja3MgaW4gdGhlIHNjcm9sbGJhcnMgZnJvbSBraWxsaW5nIGZvY3VzXFxuICAgIG9uKG5vZGUsIFxcXCJtb3VzZWRvd25cXFwiLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgaWYgKGNtLnN0YXRlLmZvY3VzZWQpIHsgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHJldHVybiBjbS5kaXNwbGF5LmlucHV0LmZvY3VzKCk7IH0sIDApIH1cXG4gICAgfSlcXG4gICAgbm9kZS5zZXRBdHRyaWJ1dGUoXFxcImNtLW5vdC1jb250ZW50XFxcIiwgXFxcInRydWVcXFwiKVxcbiAgfSwgZnVuY3Rpb24gKHBvcywgYXhpcykge1xcbiAgICBpZiAoYXhpcyA9PSBcXFwiaG9yaXpvbnRhbFxcXCIpIHsgc2V0U2Nyb2xsTGVmdChjbSwgcG9zKSB9XFxuICAgIGVsc2UgeyBzZXRTY3JvbGxUb3AoY20sIHBvcykgfVxcbiAgfSwgY20pXFxuICBpZiAoY20uZGlzcGxheS5zY3JvbGxiYXJzLmFkZENsYXNzKVxcbiAgICB7IGFkZENsYXNzKGNtLmRpc3BsYXkud3JhcHBlciwgY20uZGlzcGxheS5zY3JvbGxiYXJzLmFkZENsYXNzKSB9XFxufVxcblxcbi8vIFNDUk9MTElORyBUSElOR1MgSU5UTyBWSUVXXFxuXFxuLy8gSWYgYW4gZWRpdG9yIHNpdHMgb24gdGhlIHRvcCBvciBib3R0b20gb2YgdGhlIHdpbmRvdywgcGFydGlhbGx5XFxuLy8gc2Nyb2xsZWQgb3V0IG9mIHZpZXcsIHRoaXMgZW5zdXJlcyB0aGF0IHRoZSBjdXJzb3IgaXMgdmlzaWJsZS5cXG5mdW5jdGlvbiBtYXliZVNjcm9sbFdpbmRvdyhjbSwgY29vcmRzKSB7XFxuICBpZiAoc2lnbmFsRE9NRXZlbnQoY20sIFxcXCJzY3JvbGxDdXJzb3JJbnRvVmlld1xcXCIpKSB7IHJldHVybiB9XFxuXFxuICB2YXIgZGlzcGxheSA9IGNtLmRpc3BsYXksIGJveCA9IGRpc3BsYXkuc2l6ZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIGRvU2Nyb2xsID0gbnVsbFxcbiAgaWYgKGNvb3Jkcy50b3AgKyBib3gudG9wIDwgMCkgeyBkb1Njcm9sbCA9IHRydWUgfVxcbiAgZWxzZSBpZiAoY29vcmRzLmJvdHRvbSArIGJveC50b3AgPiAod2luZG93LmlubmVySGVpZ2h0IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQpKSB7IGRvU2Nyb2xsID0gZmFsc2UgfVxcbiAgaWYgKGRvU2Nyb2xsICE9IG51bGwgJiYgIXBoYW50b20pIHtcXG4gICAgdmFyIHNjcm9sbE5vZGUgPSBlbHQoXFxcImRpdlxcXCIsIFxcXCJcXFxcdTIwMGJcXFwiLCBudWxsLCAoXFxcInBvc2l0aW9uOiBhYnNvbHV0ZTtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICB0b3A6IFxcXCIgKyAoY29vcmRzLnRvcCAtIGRpc3BsYXkudmlld09mZnNldCAtIHBhZGRpbmdUb3AoY20uZGlzcGxheSkpICsgXFxcInB4O1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogXFxcIiArIChjb29yZHMuYm90dG9tIC0gY29vcmRzLnRvcCArIHNjcm9sbEdhcChjbSkgKyBkaXNwbGF5LmJhckhlaWdodCkgKyBcXFwicHg7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogXFxcIiArIChjb29yZHMubGVmdCkgKyBcXFwicHg7IHdpZHRoOiAycHg7XFxcIikpXFxuICAgIGNtLmRpc3BsYXkubGluZVNwYWNlLmFwcGVuZENoaWxkKHNjcm9sbE5vZGUpXFxuICAgIHNjcm9sbE5vZGUuc2Nyb2xsSW50b1ZpZXcoZG9TY3JvbGwpXFxuICAgIGNtLmRpc3BsYXkubGluZVNwYWNlLnJlbW92ZUNoaWxkKHNjcm9sbE5vZGUpXFxuICB9XFxufVxcblxcbi8vIFNjcm9sbCBhIGdpdmVuIHBvc2l0aW9uIGludG8gdmlldyAoaW1tZWRpYXRlbHkpLCB2ZXJpZnlpbmcgdGhhdFxcbi8vIGl0IGFjdHVhbGx5IGJlY2FtZSB2aXNpYmxlIChhcyBsaW5lIGhlaWdodHMgYXJlIGFjY3VyYXRlbHlcXG4vLyBtZWFzdXJlZCwgdGhlIHBvc2l0aW9uIG9mIHNvbWV0aGluZyBtYXkgJ2RyaWZ0JyBkdXJpbmcgZHJhd2luZykuXFxuZnVuY3Rpb24gc2Nyb2xsUG9zSW50b1ZpZXcoY20sIHBvcywgZW5kLCBtYXJnaW4pIHtcXG4gIGlmIChtYXJnaW4gPT0gbnVsbCkgeyBtYXJnaW4gPSAwIH1cXG4gIHZhciBjb29yZHNcXG4gIGZvciAodmFyIGxpbWl0ID0gMDsgbGltaXQgPCA1OyBsaW1pdCsrKSB7XFxuICAgIHZhciBjaGFuZ2VkID0gZmFsc2VcXG4gICAgY29vcmRzID0gY3Vyc29yQ29vcmRzKGNtLCBwb3MpXFxuICAgIHZhciBlbmRDb29yZHMgPSAhZW5kIHx8IGVuZCA9PSBwb3MgPyBjb29yZHMgOiBjdXJzb3JDb29yZHMoY20sIGVuZClcXG4gICAgdmFyIHNjcm9sbFBvcyA9IGNhbGN1bGF0ZVNjcm9sbFBvcyhjbSwgTWF0aC5taW4oY29vcmRzLmxlZnQsIGVuZENvb3Jkcy5sZWZ0KSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBNYXRoLm1pbihjb29yZHMudG9wLCBlbmRDb29yZHMudG9wKSAtIG1hcmdpbixcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBNYXRoLm1heChjb29yZHMubGVmdCwgZW5kQ29vcmRzLmxlZnQpLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1hdGgubWF4KGNvb3Jkcy5ib3R0b20sIGVuZENvb3Jkcy5ib3R0b20pICsgbWFyZ2luKVxcbiAgICB2YXIgc3RhcnRUb3AgPSBjbS5kb2Muc2Nyb2xsVG9wLCBzdGFydExlZnQgPSBjbS5kb2Muc2Nyb2xsTGVmdFxcbiAgICBpZiAoc2Nyb2xsUG9zLnNjcm9sbFRvcCAhPSBudWxsKSB7XFxuICAgICAgc2V0U2Nyb2xsVG9wKGNtLCBzY3JvbGxQb3Muc2Nyb2xsVG9wKVxcbiAgICAgIGlmIChNYXRoLmFicyhjbS5kb2Muc2Nyb2xsVG9wIC0gc3RhcnRUb3ApID4gMSkgeyBjaGFuZ2VkID0gdHJ1ZSB9XFxuICAgIH1cXG4gICAgaWYgKHNjcm9sbFBvcy5zY3JvbGxMZWZ0ICE9IG51bGwpIHtcXG4gICAgICBzZXRTY3JvbGxMZWZ0KGNtLCBzY3JvbGxQb3Muc2Nyb2xsTGVmdClcXG4gICAgICBpZiAoTWF0aC5hYnMoY20uZG9jLnNjcm9sbExlZnQgLSBzdGFydExlZnQpID4gMSkgeyBjaGFuZ2VkID0gdHJ1ZSB9XFxuICAgIH1cXG4gICAgaWYgKCFjaGFuZ2VkKSB7IGJyZWFrIH1cXG4gIH1cXG4gIHJldHVybiBjb29yZHNcXG59XFxuXFxuLy8gU2Nyb2xsIGEgZ2l2ZW4gc2V0IG9mIGNvb3JkaW5hdGVzIGludG8gdmlldyAoaW1tZWRpYXRlbHkpLlxcbmZ1bmN0aW9uIHNjcm9sbEludG9WaWV3KGNtLCB4MSwgeTEsIHgyLCB5Mikge1xcbiAgdmFyIHNjcm9sbFBvcyA9IGNhbGN1bGF0ZVNjcm9sbFBvcyhjbSwgeDEsIHkxLCB4MiwgeTIpXFxuICBpZiAoc2Nyb2xsUG9zLnNjcm9sbFRvcCAhPSBudWxsKSB7IHNldFNjcm9sbFRvcChjbSwgc2Nyb2xsUG9zLnNjcm9sbFRvcCkgfVxcbiAgaWYgKHNjcm9sbFBvcy5zY3JvbGxMZWZ0ICE9IG51bGwpIHsgc2V0U2Nyb2xsTGVmdChjbSwgc2Nyb2xsUG9zLnNjcm9sbExlZnQpIH1cXG59XFxuXFxuLy8gQ2FsY3VsYXRlIGEgbmV3IHNjcm9sbCBwb3NpdGlvbiBuZWVkZWQgdG8gc2Nyb2xsIHRoZSBnaXZlblxcbi8vIHJlY3RhbmdsZSBpbnRvIHZpZXcuIFJldHVybnMgYW4gb2JqZWN0IHdpdGggc2Nyb2xsVG9wIGFuZFxcbi8vIHNjcm9sbExlZnQgcHJvcGVydGllcy4gV2hlbiB0aGVzZSBhcmUgdW5kZWZpbmVkLCB0aGVcXG4vLyB2ZXJ0aWNhbC9ob3Jpem9udGFsIHBvc2l0aW9uIGRvZXMgbm90IG5lZWQgdG8gYmUgYWRqdXN0ZWQuXFxuZnVuY3Rpb24gY2FsY3VsYXRlU2Nyb2xsUG9zKGNtLCB4MSwgeTEsIHgyLCB5Mikge1xcbiAgdmFyIGRpc3BsYXkgPSBjbS5kaXNwbGF5LCBzbmFwTWFyZ2luID0gdGV4dEhlaWdodChjbS5kaXNwbGF5KVxcbiAgaWYgKHkxIDwgMCkgeyB5MSA9IDAgfVxcbiAgdmFyIHNjcmVlbnRvcCA9IGNtLmN1ck9wICYmIGNtLmN1ck9wLnNjcm9sbFRvcCAhPSBudWxsID8gY20uY3VyT3Auc2Nyb2xsVG9wIDogZGlzcGxheS5zY3JvbGxlci5zY3JvbGxUb3BcXG4gIHZhciBzY3JlZW4gPSBkaXNwbGF5SGVpZ2h0KGNtKSwgcmVzdWx0ID0ge31cXG4gIGlmICh5MiAtIHkxID4gc2NyZWVuKSB7IHkyID0geTEgKyBzY3JlZW4gfVxcbiAgdmFyIGRvY0JvdHRvbSA9IGNtLmRvYy5oZWlnaHQgKyBwYWRkaW5nVmVydChkaXNwbGF5KVxcbiAgdmFyIGF0VG9wID0geTEgPCBzbmFwTWFyZ2luLCBhdEJvdHRvbSA9IHkyID4gZG9jQm90dG9tIC0gc25hcE1hcmdpblxcbiAgaWYgKHkxIDwgc2NyZWVudG9wKSB7XFxuICAgIHJlc3VsdC5zY3JvbGxUb3AgPSBhdFRvcCA/IDAgOiB5MVxcbiAgfSBlbHNlIGlmICh5MiA+IHNjcmVlbnRvcCArIHNjcmVlbikge1xcbiAgICB2YXIgbmV3VG9wID0gTWF0aC5taW4oeTEsIChhdEJvdHRvbSA/IGRvY0JvdHRvbSA6IHkyKSAtIHNjcmVlbilcXG4gICAgaWYgKG5ld1RvcCAhPSBzY3JlZW50b3ApIHsgcmVzdWx0LnNjcm9sbFRvcCA9IG5ld1RvcCB9XFxuICB9XFxuXFxuICB2YXIgc2NyZWVubGVmdCA9IGNtLmN1ck9wICYmIGNtLmN1ck9wLnNjcm9sbExlZnQgIT0gbnVsbCA/IGNtLmN1ck9wLnNjcm9sbExlZnQgOiBkaXNwbGF5LnNjcm9sbGVyLnNjcm9sbExlZnRcXG4gIHZhciBzY3JlZW53ID0gZGlzcGxheVdpZHRoKGNtKSAtIChjbS5vcHRpb25zLmZpeGVkR3V0dGVyID8gZGlzcGxheS5ndXR0ZXJzLm9mZnNldFdpZHRoIDogMClcXG4gIHZhciB0b29XaWRlID0geDIgLSB4MSA+IHNjcmVlbndcXG4gIGlmICh0b29XaWRlKSB7IHgyID0geDEgKyBzY3JlZW53IH1cXG4gIGlmICh4MSA8IDEwKVxcbiAgICB7IHJlc3VsdC5zY3JvbGxMZWZ0ID0gMCB9XFxuICBlbHNlIGlmICh4MSA8IHNjcmVlbmxlZnQpXFxuICAgIHsgcmVzdWx0LnNjcm9sbExlZnQgPSBNYXRoLm1heCgwLCB4MSAtICh0b29XaWRlID8gMCA6IDEwKSkgfVxcbiAgZWxzZSBpZiAoeDIgPiBzY3JlZW53ICsgc2NyZWVubGVmdCAtIDMpXFxuICAgIHsgcmVzdWx0LnNjcm9sbExlZnQgPSB4MiArICh0b29XaWRlID8gMCA6IDEwKSAtIHNjcmVlbncgfVxcbiAgcmV0dXJuIHJlc3VsdFxcbn1cXG5cXG4vLyBTdG9yZSBhIHJlbGF0aXZlIGFkanVzdG1lbnQgdG8gdGhlIHNjcm9sbCBwb3NpdGlvbiBpbiB0aGUgY3VycmVudFxcbi8vIG9wZXJhdGlvbiAodG8gYmUgYXBwbGllZCB3aGVuIHRoZSBvcGVyYXRpb24gZmluaXNoZXMpLlxcbmZ1bmN0aW9uIGFkZFRvU2Nyb2xsUG9zKGNtLCBsZWZ0LCB0b3ApIHtcXG4gIGlmIChsZWZ0ICE9IG51bGwgfHwgdG9wICE9IG51bGwpIHsgcmVzb2x2ZVNjcm9sbFRvUG9zKGNtKSB9XFxuICBpZiAobGVmdCAhPSBudWxsKVxcbiAgICB7IGNtLmN1ck9wLnNjcm9sbExlZnQgPSAoY20uY3VyT3Auc2Nyb2xsTGVmdCA9PSBudWxsID8gY20uZG9jLnNjcm9sbExlZnQgOiBjbS5jdXJPcC5zY3JvbGxMZWZ0KSArIGxlZnQgfVxcbiAgaWYgKHRvcCAhPSBudWxsKVxcbiAgICB7IGNtLmN1ck9wLnNjcm9sbFRvcCA9IChjbS5jdXJPcC5zY3JvbGxUb3AgPT0gbnVsbCA/IGNtLmRvYy5zY3JvbGxUb3AgOiBjbS5jdXJPcC5zY3JvbGxUb3ApICsgdG9wIH1cXG59XFxuXFxuLy8gTWFrZSBzdXJlIHRoYXQgYXQgdGhlIGVuZCBvZiB0aGUgb3BlcmF0aW9uIHRoZSBjdXJyZW50IGN1cnNvciBpc1xcbi8vIHNob3duLlxcbmZ1bmN0aW9uIGVuc3VyZUN1cnNvclZpc2libGUoY20pIHtcXG4gIHJlc29sdmVTY3JvbGxUb1BvcyhjbSlcXG4gIHZhciBjdXIgPSBjbS5nZXRDdXJzb3IoKSwgZnJvbSA9IGN1ciwgdG8gPSBjdXJcXG4gIGlmICghY20ub3B0aW9ucy5saW5lV3JhcHBpbmcpIHtcXG4gICAgZnJvbSA9IGN1ci5jaCA/IFBvcyhjdXIubGluZSwgY3VyLmNoIC0gMSkgOiBjdXJcXG4gICAgdG8gPSBQb3MoY3VyLmxpbmUsIGN1ci5jaCArIDEpXFxuICB9XFxuICBjbS5jdXJPcC5zY3JvbGxUb1BvcyA9IHtmcm9tOiBmcm9tLCB0bzogdG8sIG1hcmdpbjogY20ub3B0aW9ucy5jdXJzb3JTY3JvbGxNYXJnaW4sIGlzQ3Vyc29yOiB0cnVlfVxcbn1cXG5cXG4vLyBXaGVuIGFuIG9wZXJhdGlvbiBoYXMgaXRzIHNjcm9sbFRvUG9zIHByb3BlcnR5IHNldCwgYW5kIGFub3RoZXJcXG4vLyBzY3JvbGwgYWN0aW9uIGlzIGFwcGxpZWQgYmVmb3JlIHRoZSBlbmQgb2YgdGhlIG9wZXJhdGlvbiwgdGhpc1xcbi8vICdzaW11bGF0ZXMnIHNjcm9sbGluZyB0aGF0IHBvc2l0aW9uIGludG8gdmlldyBpbiBhIGNoZWFwIHdheSwgc29cXG4vLyB0aGF0IHRoZSBlZmZlY3Qgb2YgaW50ZXJtZWRpYXRlIHNjcm9sbCBjb21tYW5kcyBpcyBub3QgaWdub3JlZC5cXG5mdW5jdGlvbiByZXNvbHZlU2Nyb2xsVG9Qb3MoY20pIHtcXG4gIHZhciByYW5nZSA9IGNtLmN1ck9wLnNjcm9sbFRvUG9zXFxuICBpZiAocmFuZ2UpIHtcXG4gICAgY20uY3VyT3Auc2Nyb2xsVG9Qb3MgPSBudWxsXFxuICAgIHZhciBmcm9tID0gZXN0aW1hdGVDb29yZHMoY20sIHJhbmdlLmZyb20pLCB0byA9IGVzdGltYXRlQ29vcmRzKGNtLCByYW5nZS50bylcXG4gICAgdmFyIHNQb3MgPSBjYWxjdWxhdGVTY3JvbGxQb3MoY20sIE1hdGgubWluKGZyb20ubGVmdCwgdG8ubGVmdCksXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1hdGgubWluKGZyb20udG9wLCB0by50b3ApIC0gcmFuZ2UubWFyZ2luLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBNYXRoLm1heChmcm9tLnJpZ2h0LCB0by5yaWdodCksXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1hdGgubWF4KGZyb20uYm90dG9tLCB0by5ib3R0b20pICsgcmFuZ2UubWFyZ2luKVxcbiAgICBjbS5zY3JvbGxUbyhzUG9zLnNjcm9sbExlZnQsIHNQb3Muc2Nyb2xsVG9wKVxcbiAgfVxcbn1cXG5cXG4vLyBPcGVyYXRpb25zIGFyZSB1c2VkIHRvIHdyYXAgYSBzZXJpZXMgb2YgY2hhbmdlcyB0byB0aGUgZWRpdG9yXFxuLy8gc3RhdGUgaW4gc3VjaCBhIHdheSB0aGF0IGVhY2ggY2hhbmdlIHdvbid0IGhhdmUgdG8gdXBkYXRlIHRoZVxcbi8vIGN1cnNvciBhbmQgZGlzcGxheSAod2hpY2ggd291bGQgYmUgYXdrd2FyZCwgc2xvdywgYW5kXFxuLy8gZXJyb3ItcHJvbmUpLiBJbnN0ZWFkLCBkaXNwbGF5IHVwZGF0ZXMgYXJlIGJhdGNoZWQgYW5kIHRoZW4gYWxsXFxuLy8gY29tYmluZWQgYW5kIGV4ZWN1dGVkIGF0IG9uY2UuXFxuXFxudmFyIG5leHRPcElkID0gMFxcbi8vIFN0YXJ0IGEgbmV3IG9wZXJhdGlvbi5cXG5mdW5jdGlvbiBzdGFydE9wZXJhdGlvbihjbSkge1xcbiAgY20uY3VyT3AgPSB7XFxuICAgIGNtOiBjbSxcXG4gICAgdmlld0NoYW5nZWQ6IGZhbHNlLCAgICAgIC8vIEZsYWcgdGhhdCBpbmRpY2F0ZXMgdGhhdCBsaW5lcyBtaWdodCBuZWVkIHRvIGJlIHJlZHJhd25cXG4gICAgc3RhcnRIZWlnaHQ6IGNtLmRvYy5oZWlnaHQsIC8vIFVzZWQgdG8gZGV0ZWN0IG5lZWQgdG8gdXBkYXRlIHNjcm9sbGJhclxcbiAgICBmb3JjZVVwZGF0ZTogZmFsc2UsICAgICAgLy8gVXNlZCB0byBmb3JjZSBhIHJlZHJhd1xcbiAgICB1cGRhdGVJbnB1dDogbnVsbCwgICAgICAgLy8gV2hldGhlciB0byByZXNldCB0aGUgaW5wdXQgdGV4dGFyZWFcXG4gICAgdHlwaW5nOiBmYWxzZSwgICAgICAgICAgIC8vIFdoZXRoZXIgdGhpcyByZXNldCBzaG91bGQgYmUgY2FyZWZ1bCB0byBsZWF2ZSBleGlzdGluZyB0ZXh0IChmb3IgY29tcG9zaXRpbmcpXFxuICAgIGNoYW5nZU9ianM6IG51bGwsICAgICAgICAvLyBBY2N1bXVsYXRlZCBjaGFuZ2VzLCBmb3IgZmlyaW5nIGNoYW5nZSBldmVudHNcXG4gICAgY3Vyc29yQWN0aXZpdHlIYW5kbGVyczogbnVsbCwgLy8gU2V0IG9mIGhhbmRsZXJzIHRvIGZpcmUgY3Vyc29yQWN0aXZpdHkgb25cXG4gICAgY3Vyc29yQWN0aXZpdHlDYWxsZWQ6IDAsIC8vIFRyYWNrcyB3aGljaCBjdXJzb3JBY3Rpdml0eSBoYW5kbGVycyBoYXZlIGJlZW4gY2FsbGVkIGFscmVhZHlcXG4gICAgc2VsZWN0aW9uQ2hhbmdlZDogZmFsc2UsIC8vIFdoZXRoZXIgdGhlIHNlbGVjdGlvbiBuZWVkcyB0byBiZSByZWRyYXduXFxuICAgIHVwZGF0ZU1heExpbmU6IGZhbHNlLCAgICAvLyBTZXQgd2hlbiB0aGUgd2lkZXN0IGxpbmUgbmVlZHMgdG8gYmUgZGV0ZXJtaW5lZCBhbmV3XFxuICAgIHNjcm9sbExlZnQ6IG51bGwsIHNjcm9sbFRvcDogbnVsbCwgLy8gSW50ZXJtZWRpYXRlIHNjcm9sbCBwb3NpdGlvbiwgbm90IHB1c2hlZCB0byBET00geWV0XFxuICAgIHNjcm9sbFRvUG9zOiBudWxsLCAgICAgICAvLyBVc2VkIHRvIHNjcm9sbCB0byBhIHNwZWNpZmljIHBvc2l0aW9uXFxuICAgIGZvY3VzOiBmYWxzZSxcXG4gICAgaWQ6ICsrbmV4dE9wSWQgICAgICAgICAgIC8vIFVuaXF1ZSBJRFxcbiAgfVxcbiAgcHVzaE9wZXJhdGlvbihjbS5jdXJPcClcXG59XFxuXFxuLy8gRmluaXNoIGFuIG9wZXJhdGlvbiwgdXBkYXRpbmcgdGhlIGRpc3BsYXkgYW5kIHNpZ25hbGxpbmcgZGVsYXllZCBldmVudHNcXG5mdW5jdGlvbiBlbmRPcGVyYXRpb24oY20pIHtcXG4gIHZhciBvcCA9IGNtLmN1ck9wXFxuICBmaW5pc2hPcGVyYXRpb24ob3AsIGZ1bmN0aW9uIChncm91cCkge1xcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdyb3VwLm9wcy5sZW5ndGg7IGkrKylcXG4gICAgICB7IGdyb3VwLm9wc1tpXS5jbS5jdXJPcCA9IG51bGwgfVxcbiAgICBlbmRPcGVyYXRpb25zKGdyb3VwKVxcbiAgfSlcXG59XFxuXFxuLy8gVGhlIERPTSB1cGRhdGVzIGRvbmUgd2hlbiBhbiBvcGVyYXRpb24gZmluaXNoZXMgYXJlIGJhdGNoZWQgc29cXG4vLyB0aGF0IHRoZSBtaW5pbXVtIG51bWJlciBvZiByZWxheW91dHMgYXJlIHJlcXVpcmVkLlxcbmZ1bmN0aW9uIGVuZE9wZXJhdGlvbnMoZ3JvdXApIHtcXG4gIHZhciBvcHMgPSBncm91cC5vcHNcXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgb3BzLmxlbmd0aDsgaSsrKSAvLyBSZWFkIERPTVxcbiAgICB7IGVuZE9wZXJhdGlvbl9SMShvcHNbaV0pIH1cXG4gIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IG9wcy5sZW5ndGg7IGkkMSsrKSAvLyBXcml0ZSBET00gKG1heWJlKVxcbiAgICB7IGVuZE9wZXJhdGlvbl9XMShvcHNbaSQxXSkgfVxcbiAgZm9yICh2YXIgaSQyID0gMDsgaSQyIDwgb3BzLmxlbmd0aDsgaSQyKyspIC8vIFJlYWQgRE9NXFxuICAgIHsgZW5kT3BlcmF0aW9uX1IyKG9wc1tpJDJdKSB9XFxuICBmb3IgKHZhciBpJDMgPSAwOyBpJDMgPCBvcHMubGVuZ3RoOyBpJDMrKykgLy8gV3JpdGUgRE9NIChtYXliZSlcXG4gICAgeyBlbmRPcGVyYXRpb25fVzIob3BzW2kkM10pIH1cXG4gIGZvciAodmFyIGkkNCA9IDA7IGkkNCA8IG9wcy5sZW5ndGg7IGkkNCsrKSAvLyBSZWFkIERPTVxcbiAgICB7IGVuZE9wZXJhdGlvbl9maW5pc2gob3BzW2kkNF0pIH1cXG59XFxuXFxuZnVuY3Rpb24gZW5kT3BlcmF0aW9uX1IxKG9wKSB7XFxuICB2YXIgY20gPSBvcC5jbSwgZGlzcGxheSA9IGNtLmRpc3BsYXlcXG4gIG1heWJlQ2xpcFNjcm9sbGJhcnMoY20pXFxuICBpZiAob3AudXBkYXRlTWF4TGluZSkgeyBmaW5kTWF4TGluZShjbSkgfVxcblxcbiAgb3AubXVzdFVwZGF0ZSA9IG9wLnZpZXdDaGFuZ2VkIHx8IG9wLmZvcmNlVXBkYXRlIHx8IG9wLnNjcm9sbFRvcCAhPSBudWxsIHx8XFxuICAgIG9wLnNjcm9sbFRvUG9zICYmIChvcC5zY3JvbGxUb1Bvcy5mcm9tLmxpbmUgPCBkaXNwbGF5LnZpZXdGcm9tIHx8XFxuICAgICAgICAgICAgICAgICAgICAgICBvcC5zY3JvbGxUb1Bvcy50by5saW5lID49IGRpc3BsYXkudmlld1RvKSB8fFxcbiAgICBkaXNwbGF5Lm1heExpbmVDaGFuZ2VkICYmIGNtLm9wdGlvbnMubGluZVdyYXBwaW5nXFxuICBvcC51cGRhdGUgPSBvcC5tdXN0VXBkYXRlICYmXFxuICAgIG5ldyBEaXNwbGF5VXBkYXRlKGNtLCBvcC5tdXN0VXBkYXRlICYmIHt0b3A6IG9wLnNjcm9sbFRvcCwgZW5zdXJlOiBvcC5zY3JvbGxUb1Bvc30sIG9wLmZvcmNlVXBkYXRlKVxcbn1cXG5cXG5mdW5jdGlvbiBlbmRPcGVyYXRpb25fVzEob3ApIHtcXG4gIG9wLnVwZGF0ZWREaXNwbGF5ID0gb3AubXVzdFVwZGF0ZSAmJiB1cGRhdGVEaXNwbGF5SWZOZWVkZWQob3AuY20sIG9wLnVwZGF0ZSlcXG59XFxuXFxuZnVuY3Rpb24gZW5kT3BlcmF0aW9uX1IyKG9wKSB7XFxuICB2YXIgY20gPSBvcC5jbSwgZGlzcGxheSA9IGNtLmRpc3BsYXlcXG4gIGlmIChvcC51cGRhdGVkRGlzcGxheSkgeyB1cGRhdGVIZWlnaHRzSW5WaWV3cG9ydChjbSkgfVxcblxcbiAgb3AuYmFyTWVhc3VyZSA9IG1lYXN1cmVGb3JTY3JvbGxiYXJzKGNtKVxcblxcbiAgLy8gSWYgdGhlIG1heCBsaW5lIGNoYW5nZWQgc2luY2UgaXQgd2FzIGxhc3QgbWVhc3VyZWQsIG1lYXN1cmUgaXQsXFxuICAvLyBhbmQgZW5zdXJlIHRoZSBkb2N1bWVudCdzIHdpZHRoIG1hdGNoZXMgaXQuXFxuICAvLyB1cGRhdGVEaXNwbGF5X1cyIHdpbGwgdXNlIHRoZXNlIHByb3BlcnRpZXMgdG8gZG8gdGhlIGFjdHVhbCByZXNpemluZ1xcbiAgaWYgKGRpc3BsYXkubWF4TGluZUNoYW5nZWQgJiYgIWNtLm9wdGlvbnMubGluZVdyYXBwaW5nKSB7XFxuICAgIG9wLmFkanVzdFdpZHRoVG8gPSBtZWFzdXJlQ2hhcihjbSwgZGlzcGxheS5tYXhMaW5lLCBkaXNwbGF5Lm1heExpbmUudGV4dC5sZW5ndGgpLmxlZnQgKyAzXFxuICAgIGNtLmRpc3BsYXkuc2l6ZXJXaWR0aCA9IG9wLmFkanVzdFdpZHRoVG9cXG4gICAgb3AuYmFyTWVhc3VyZS5zY3JvbGxXaWR0aCA9XFxuICAgICAgTWF0aC5tYXgoZGlzcGxheS5zY3JvbGxlci5jbGllbnRXaWR0aCwgZGlzcGxheS5zaXplci5vZmZzZXRMZWZ0ICsgb3AuYWRqdXN0V2lkdGhUbyArIHNjcm9sbEdhcChjbSkgKyBjbS5kaXNwbGF5LmJhcldpZHRoKVxcbiAgICBvcC5tYXhTY3JvbGxMZWZ0ID0gTWF0aC5tYXgoMCwgZGlzcGxheS5zaXplci5vZmZzZXRMZWZ0ICsgb3AuYWRqdXN0V2lkdGhUbyAtIGRpc3BsYXlXaWR0aChjbSkpXFxuICB9XFxuXFxuICBpZiAob3AudXBkYXRlZERpc3BsYXkgfHwgb3Auc2VsZWN0aW9uQ2hhbmdlZClcXG4gICAgeyBvcC5wcmVwYXJlZFNlbGVjdGlvbiA9IGRpc3BsYXkuaW5wdXQucHJlcGFyZVNlbGVjdGlvbihvcC5mb2N1cykgfVxcbn1cXG5cXG5mdW5jdGlvbiBlbmRPcGVyYXRpb25fVzIob3ApIHtcXG4gIHZhciBjbSA9IG9wLmNtXFxuXFxuICBpZiAob3AuYWRqdXN0V2lkdGhUbyAhPSBudWxsKSB7XFxuICAgIGNtLmRpc3BsYXkuc2l6ZXIuc3R5bGUubWluV2lkdGggPSBvcC5hZGp1c3RXaWR0aFRvICsgXFxcInB4XFxcIlxcbiAgICBpZiAob3AubWF4U2Nyb2xsTGVmdCA8IGNtLmRvYy5zY3JvbGxMZWZ0KVxcbiAgICAgIHsgc2V0U2Nyb2xsTGVmdChjbSwgTWF0aC5taW4oY20uZGlzcGxheS5zY3JvbGxlci5zY3JvbGxMZWZ0LCBvcC5tYXhTY3JvbGxMZWZ0KSwgdHJ1ZSkgfVxcbiAgICBjbS5kaXNwbGF5Lm1heExpbmVDaGFuZ2VkID0gZmFsc2VcXG4gIH1cXG5cXG4gIHZhciB0YWtlRm9jdXMgPSBvcC5mb2N1cyAmJiBvcC5mb2N1cyA9PSBhY3RpdmVFbHQoKSAmJiAoIWRvY3VtZW50Lmhhc0ZvY3VzIHx8IGRvY3VtZW50Lmhhc0ZvY3VzKCkpXFxuICBpZiAob3AucHJlcGFyZWRTZWxlY3Rpb24pXFxuICAgIHsgY20uZGlzcGxheS5pbnB1dC5zaG93U2VsZWN0aW9uKG9wLnByZXBhcmVkU2VsZWN0aW9uLCB0YWtlRm9jdXMpIH1cXG4gIGlmIChvcC51cGRhdGVkRGlzcGxheSB8fCBvcC5zdGFydEhlaWdodCAhPSBjbS5kb2MuaGVpZ2h0KVxcbiAgICB7IHVwZGF0ZVNjcm9sbGJhcnMoY20sIG9wLmJhck1lYXN1cmUpIH1cXG4gIGlmIChvcC51cGRhdGVkRGlzcGxheSlcXG4gICAgeyBzZXREb2N1bWVudEhlaWdodChjbSwgb3AuYmFyTWVhc3VyZSkgfVxcblxcbiAgaWYgKG9wLnNlbGVjdGlvbkNoYW5nZWQpIHsgcmVzdGFydEJsaW5rKGNtKSB9XFxuXFxuICBpZiAoY20uc3RhdGUuZm9jdXNlZCAmJiBvcC51cGRhdGVJbnB1dClcXG4gICAgeyBjbS5kaXNwbGF5LmlucHV0LnJlc2V0KG9wLnR5cGluZykgfVxcbiAgaWYgKHRha2VGb2N1cykgeyBlbnN1cmVGb2N1cyhvcC5jbSkgfVxcbn1cXG5cXG5mdW5jdGlvbiBlbmRPcGVyYXRpb25fZmluaXNoKG9wKSB7XFxuICB2YXIgY20gPSBvcC5jbSwgZGlzcGxheSA9IGNtLmRpc3BsYXksIGRvYyA9IGNtLmRvY1xcblxcbiAgaWYgKG9wLnVwZGF0ZWREaXNwbGF5KSB7IHBvc3RVcGRhdGVEaXNwbGF5KGNtLCBvcC51cGRhdGUpIH1cXG5cXG4gIC8vIEFib3J0IG1vdXNlIHdoZWVsIGRlbHRhIG1lYXN1cmVtZW50LCB3aGVuIHNjcm9sbGluZyBleHBsaWNpdGx5XFxuICBpZiAoZGlzcGxheS53aGVlbFN0YXJ0WCAhPSBudWxsICYmIChvcC5zY3JvbGxUb3AgIT0gbnVsbCB8fCBvcC5zY3JvbGxMZWZ0ICE9IG51bGwgfHwgb3Auc2Nyb2xsVG9Qb3MpKVxcbiAgICB7IGRpc3BsYXkud2hlZWxTdGFydFggPSBkaXNwbGF5LndoZWVsU3RhcnRZID0gbnVsbCB9XFxuXFxuICAvLyBQcm9wYWdhdGUgdGhlIHNjcm9sbCBwb3NpdGlvbiB0byB0aGUgYWN0dWFsIERPTSBzY3JvbGxlclxcbiAgaWYgKG9wLnNjcm9sbFRvcCAhPSBudWxsICYmIChkaXNwbGF5LnNjcm9sbGVyLnNjcm9sbFRvcCAhPSBvcC5zY3JvbGxUb3AgfHwgb3AuZm9yY2VTY3JvbGwpKSB7XFxuICAgIGRvYy5zY3JvbGxUb3AgPSBNYXRoLm1heCgwLCBNYXRoLm1pbihkaXNwbGF5LnNjcm9sbGVyLnNjcm9sbEhlaWdodCAtIGRpc3BsYXkuc2Nyb2xsZXIuY2xpZW50SGVpZ2h0LCBvcC5zY3JvbGxUb3ApKVxcbiAgICBkaXNwbGF5LnNjcm9sbGJhcnMuc2V0U2Nyb2xsVG9wKGRvYy5zY3JvbGxUb3ApXFxuICAgIGRpc3BsYXkuc2Nyb2xsZXIuc2Nyb2xsVG9wID0gZG9jLnNjcm9sbFRvcFxcbiAgfVxcbiAgaWYgKG9wLnNjcm9sbExlZnQgIT0gbnVsbCAmJiAoZGlzcGxheS5zY3JvbGxlci5zY3JvbGxMZWZ0ICE9IG9wLnNjcm9sbExlZnQgfHwgb3AuZm9yY2VTY3JvbGwpKSB7XFxuICAgIGRvYy5zY3JvbGxMZWZ0ID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oZGlzcGxheS5zY3JvbGxlci5zY3JvbGxXaWR0aCAtIGRpc3BsYXkuc2Nyb2xsZXIuY2xpZW50V2lkdGgsIG9wLnNjcm9sbExlZnQpKVxcbiAgICBkaXNwbGF5LnNjcm9sbGJhcnMuc2V0U2Nyb2xsTGVmdChkb2Muc2Nyb2xsTGVmdClcXG4gICAgZGlzcGxheS5zY3JvbGxlci5zY3JvbGxMZWZ0ID0gZG9jLnNjcm9sbExlZnRcXG4gICAgYWxpZ25Ib3Jpem9udGFsbHkoY20pXFxuICB9XFxuICAvLyBJZiB3ZSBuZWVkIHRvIHNjcm9sbCBhIHNwZWNpZmljIHBvc2l0aW9uIGludG8gdmlldywgZG8gc28uXFxuICBpZiAob3Auc2Nyb2xsVG9Qb3MpIHtcXG4gICAgdmFyIGNvb3JkcyA9IHNjcm9sbFBvc0ludG9WaWV3KGNtLCBjbGlwUG9zKGRvYywgb3Auc2Nyb2xsVG9Qb3MuZnJvbSksXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGlwUG9zKGRvYywgb3Auc2Nyb2xsVG9Qb3MudG8pLCBvcC5zY3JvbGxUb1Bvcy5tYXJnaW4pXFxuICAgIGlmIChvcC5zY3JvbGxUb1Bvcy5pc0N1cnNvciAmJiBjbS5zdGF0ZS5mb2N1c2VkKSB7IG1heWJlU2Nyb2xsV2luZG93KGNtLCBjb29yZHMpIH1cXG4gIH1cXG5cXG4gIC8vIEZpcmUgZXZlbnRzIGZvciBtYXJrZXJzIHRoYXQgYXJlIGhpZGRlbi91bmlkZGVuIGJ5IGVkaXRpbmcgb3JcXG4gIC8vIHVuZG9pbmdcXG4gIHZhciBoaWRkZW4gPSBvcC5tYXliZUhpZGRlbk1hcmtlcnMsIHVuaGlkZGVuID0gb3AubWF5YmVVbmhpZGRlbk1hcmtlcnNcXG4gIGlmIChoaWRkZW4pIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBoaWRkZW4ubGVuZ3RoOyArK2kpXFxuICAgIHsgaWYgKCFoaWRkZW5baV0ubGluZXMubGVuZ3RoKSB7IHNpZ25hbChoaWRkZW5baV0sIFxcXCJoaWRlXFxcIikgfSB9IH1cXG4gIGlmICh1bmhpZGRlbikgeyBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCB1bmhpZGRlbi5sZW5ndGg7ICsraSQxKVxcbiAgICB7IGlmICh1bmhpZGRlbltpJDFdLmxpbmVzLmxlbmd0aCkgeyBzaWduYWwodW5oaWRkZW5baSQxXSwgXFxcInVuaGlkZVxcXCIpIH0gfSB9XFxuXFxuICBpZiAoZGlzcGxheS53cmFwcGVyLm9mZnNldEhlaWdodClcXG4gICAgeyBkb2Muc2Nyb2xsVG9wID0gY20uZGlzcGxheS5zY3JvbGxlci5zY3JvbGxUb3AgfVxcblxcbiAgLy8gRmlyZSBjaGFuZ2UgZXZlbnRzLCBhbmQgZGVsYXllZCBldmVudCBoYW5kbGVyc1xcbiAgaWYgKG9wLmNoYW5nZU9ianMpXFxuICAgIHsgc2lnbmFsKGNtLCBcXFwiY2hhbmdlc1xcXCIsIGNtLCBvcC5jaGFuZ2VPYmpzKSB9XFxuICBpZiAob3AudXBkYXRlKVxcbiAgICB7IG9wLnVwZGF0ZS5maW5pc2goKSB9XFxufVxcblxcbi8vIFJ1biB0aGUgZ2l2ZW4gZnVuY3Rpb24gaW4gYW4gb3BlcmF0aW9uXFxuZnVuY3Rpb24gcnVuSW5PcChjbSwgZikge1xcbiAgaWYgKGNtLmN1ck9wKSB7IHJldHVybiBmKCkgfVxcbiAgc3RhcnRPcGVyYXRpb24oY20pXFxuICB0cnkgeyByZXR1cm4gZigpIH1cXG4gIGZpbmFsbHkgeyBlbmRPcGVyYXRpb24oY20pIH1cXG59XFxuLy8gV3JhcHMgYSBmdW5jdGlvbiBpbiBhbiBvcGVyYXRpb24uIFJldHVybnMgdGhlIHdyYXBwZWQgZnVuY3Rpb24uXFxuZnVuY3Rpb24gb3BlcmF0aW9uKGNtLCBmKSB7XFxuICByZXR1cm4gZnVuY3Rpb24oKSB7XFxuICAgIGlmIChjbS5jdXJPcCkgeyByZXR1cm4gZi5hcHBseShjbSwgYXJndW1lbnRzKSB9XFxuICAgIHN0YXJ0T3BlcmF0aW9uKGNtKVxcbiAgICB0cnkgeyByZXR1cm4gZi5hcHBseShjbSwgYXJndW1lbnRzKSB9XFxuICAgIGZpbmFsbHkgeyBlbmRPcGVyYXRpb24oY20pIH1cXG4gIH1cXG59XFxuLy8gVXNlZCB0byBhZGQgbWV0aG9kcyB0byBlZGl0b3IgYW5kIGRvYyBpbnN0YW5jZXMsIHdyYXBwaW5nIHRoZW0gaW5cXG4vLyBvcGVyYXRpb25zLlxcbmZ1bmN0aW9uIG1ldGhvZE9wKGYpIHtcXG4gIHJldHVybiBmdW5jdGlvbigpIHtcXG4gICAgaWYgKHRoaXMuY3VyT3ApIHsgcmV0dXJuIGYuYXBwbHkodGhpcywgYXJndW1lbnRzKSB9XFxuICAgIHN0YXJ0T3BlcmF0aW9uKHRoaXMpXFxuICAgIHRyeSB7IHJldHVybiBmLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfVxcbiAgICBmaW5hbGx5IHsgZW5kT3BlcmF0aW9uKHRoaXMpIH1cXG4gIH1cXG59XFxuZnVuY3Rpb24gZG9jTWV0aG9kT3AoZikge1xcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xcbiAgICB2YXIgY20gPSB0aGlzLmNtXFxuICAgIGlmICghY20gfHwgY20uY3VyT3ApIHsgcmV0dXJuIGYuYXBwbHkodGhpcywgYXJndW1lbnRzKSB9XFxuICAgIHN0YXJ0T3BlcmF0aW9uKGNtKVxcbiAgICB0cnkgeyByZXR1cm4gZi5hcHBseSh0aGlzLCBhcmd1bWVudHMpIH1cXG4gICAgZmluYWxseSB7IGVuZE9wZXJhdGlvbihjbSkgfVxcbiAgfVxcbn1cXG5cXG4vLyBVcGRhdGVzIHRoZSBkaXNwbGF5LnZpZXcgZGF0YSBzdHJ1Y3R1cmUgZm9yIGEgZ2l2ZW4gY2hhbmdlIHRvIHRoZVxcbi8vIGRvY3VtZW50LiBGcm9tIGFuZCB0byBhcmUgaW4gcHJlLWNoYW5nZSBjb29yZGluYXRlcy4gTGVuZGlmZiBpc1xcbi8vIHRoZSBhbW91bnQgb2YgbGluZXMgYWRkZWQgb3Igc3VidHJhY3RlZCBieSB0aGUgY2hhbmdlLiBUaGlzIGlzXFxuLy8gdXNlZCBmb3IgY2hhbmdlcyB0aGF0IHNwYW4gbXVsdGlwbGUgbGluZXMsIG9yIGNoYW5nZSB0aGUgd2F5XFxuLy8gbGluZXMgYXJlIGRpdmlkZWQgaW50byB2aXN1YWwgbGluZXMuIHJlZ0xpbmVDaGFuZ2UgKGJlbG93KVxcbi8vIHJlZ2lzdGVycyBzaW5nbGUtbGluZSBjaGFuZ2VzLlxcbmZ1bmN0aW9uIHJlZ0NoYW5nZShjbSwgZnJvbSwgdG8sIGxlbmRpZmYpIHtcXG4gIGlmIChmcm9tID09IG51bGwpIHsgZnJvbSA9IGNtLmRvYy5maXJzdCB9XFxuICBpZiAodG8gPT0gbnVsbCkgeyB0byA9IGNtLmRvYy5maXJzdCArIGNtLmRvYy5zaXplIH1cXG4gIGlmICghbGVuZGlmZikgeyBsZW5kaWZmID0gMCB9XFxuXFxuICB2YXIgZGlzcGxheSA9IGNtLmRpc3BsYXlcXG4gIGlmIChsZW5kaWZmICYmIHRvIDwgZGlzcGxheS52aWV3VG8gJiZcXG4gICAgICAoZGlzcGxheS51cGRhdGVMaW5lTnVtYmVycyA9PSBudWxsIHx8IGRpc3BsYXkudXBkYXRlTGluZU51bWJlcnMgPiBmcm9tKSlcXG4gICAgeyBkaXNwbGF5LnVwZGF0ZUxpbmVOdW1iZXJzID0gZnJvbSB9XFxuXFxuICBjbS5jdXJPcC52aWV3Q2hhbmdlZCA9IHRydWVcXG5cXG4gIGlmIChmcm9tID49IGRpc3BsYXkudmlld1RvKSB7IC8vIENoYW5nZSBhZnRlclxcbiAgICBpZiAoc2F3Q29sbGFwc2VkU3BhbnMgJiYgdmlzdWFsTGluZU5vKGNtLmRvYywgZnJvbSkgPCBkaXNwbGF5LnZpZXdUbylcXG4gICAgICB7IHJlc2V0VmlldyhjbSkgfVxcbiAgfSBlbHNlIGlmICh0byA8PSBkaXNwbGF5LnZpZXdGcm9tKSB7IC8vIENoYW5nZSBiZWZvcmVcXG4gICAgaWYgKHNhd0NvbGxhcHNlZFNwYW5zICYmIHZpc3VhbExpbmVFbmRObyhjbS5kb2MsIHRvICsgbGVuZGlmZikgPiBkaXNwbGF5LnZpZXdGcm9tKSB7XFxuICAgICAgcmVzZXRWaWV3KGNtKVxcbiAgICB9IGVsc2Uge1xcbiAgICAgIGRpc3BsYXkudmlld0Zyb20gKz0gbGVuZGlmZlxcbiAgICAgIGRpc3BsYXkudmlld1RvICs9IGxlbmRpZmZcXG4gICAgfVxcbiAgfSBlbHNlIGlmIChmcm9tIDw9IGRpc3BsYXkudmlld0Zyb20gJiYgdG8gPj0gZGlzcGxheS52aWV3VG8pIHsgLy8gRnVsbCBvdmVybGFwXFxuICAgIHJlc2V0VmlldyhjbSlcXG4gIH0gZWxzZSBpZiAoZnJvbSA8PSBkaXNwbGF5LnZpZXdGcm9tKSB7IC8vIFRvcCBvdmVybGFwXFxuICAgIHZhciBjdXQgPSB2aWV3Q3V0dGluZ1BvaW50KGNtLCB0bywgdG8gKyBsZW5kaWZmLCAxKVxcbiAgICBpZiAoY3V0KSB7XFxuICAgICAgZGlzcGxheS52aWV3ID0gZGlzcGxheS52aWV3LnNsaWNlKGN1dC5pbmRleClcXG4gICAgICBkaXNwbGF5LnZpZXdGcm9tID0gY3V0LmxpbmVOXFxuICAgICAgZGlzcGxheS52aWV3VG8gKz0gbGVuZGlmZlxcbiAgICB9IGVsc2Uge1xcbiAgICAgIHJlc2V0VmlldyhjbSlcXG4gICAgfVxcbiAgfSBlbHNlIGlmICh0byA+PSBkaXNwbGF5LnZpZXdUbykgeyAvLyBCb3R0b20gb3ZlcmxhcFxcbiAgICB2YXIgY3V0JDEgPSB2aWV3Q3V0dGluZ1BvaW50KGNtLCBmcm9tLCBmcm9tLCAtMSlcXG4gICAgaWYgKGN1dCQxKSB7XFxuICAgICAgZGlzcGxheS52aWV3ID0gZGlzcGxheS52aWV3LnNsaWNlKDAsIGN1dCQxLmluZGV4KVxcbiAgICAgIGRpc3BsYXkudmlld1RvID0gY3V0JDEubGluZU5cXG4gICAgfSBlbHNlIHtcXG4gICAgICByZXNldFZpZXcoY20pXFxuICAgIH1cXG4gIH0gZWxzZSB7IC8vIEdhcCBpbiB0aGUgbWlkZGxlXFxuICAgIHZhciBjdXRUb3AgPSB2aWV3Q3V0dGluZ1BvaW50KGNtLCBmcm9tLCBmcm9tLCAtMSlcXG4gICAgdmFyIGN1dEJvdCA9IHZpZXdDdXR0aW5nUG9pbnQoY20sIHRvLCB0byArIGxlbmRpZmYsIDEpXFxuICAgIGlmIChjdXRUb3AgJiYgY3V0Qm90KSB7XFxuICAgICAgZGlzcGxheS52aWV3ID0gZGlzcGxheS52aWV3LnNsaWNlKDAsIGN1dFRvcC5pbmRleClcXG4gICAgICAgIC5jb25jYXQoYnVpbGRWaWV3QXJyYXkoY20sIGN1dFRvcC5saW5lTiwgY3V0Qm90LmxpbmVOKSlcXG4gICAgICAgIC5jb25jYXQoZGlzcGxheS52aWV3LnNsaWNlKGN1dEJvdC5pbmRleCkpXFxuICAgICAgZGlzcGxheS52aWV3VG8gKz0gbGVuZGlmZlxcbiAgICB9IGVsc2Uge1xcbiAgICAgIHJlc2V0VmlldyhjbSlcXG4gICAgfVxcbiAgfVxcblxcbiAgdmFyIGV4dCA9IGRpc3BsYXkuZXh0ZXJuYWxNZWFzdXJlZFxcbiAgaWYgKGV4dCkge1xcbiAgICBpZiAodG8gPCBleHQubGluZU4pXFxuICAgICAgeyBleHQubGluZU4gKz0gbGVuZGlmZiB9XFxuICAgIGVsc2UgaWYgKGZyb20gPCBleHQubGluZU4gKyBleHQuc2l6ZSlcXG4gICAgICB7IGRpc3BsYXkuZXh0ZXJuYWxNZWFzdXJlZCA9IG51bGwgfVxcbiAgfVxcbn1cXG5cXG4vLyBSZWdpc3RlciBhIGNoYW5nZSB0byBhIHNpbmdsZSBsaW5lLiBUeXBlIG11c3QgYmUgb25lIG9mIFxcXCJ0ZXh0XFxcIixcXG4vLyBcXFwiZ3V0dGVyXFxcIiwgXFxcImNsYXNzXFxcIiwgXFxcIndpZGdldFxcXCJcXG5mdW5jdGlvbiByZWdMaW5lQ2hhbmdlKGNtLCBsaW5lLCB0eXBlKSB7XFxuICBjbS5jdXJPcC52aWV3Q2hhbmdlZCA9IHRydWVcXG4gIHZhciBkaXNwbGF5ID0gY20uZGlzcGxheSwgZXh0ID0gY20uZGlzcGxheS5leHRlcm5hbE1lYXN1cmVkXFxuICBpZiAoZXh0ICYmIGxpbmUgPj0gZXh0LmxpbmVOICYmIGxpbmUgPCBleHQubGluZU4gKyBleHQuc2l6ZSlcXG4gICAgeyBkaXNwbGF5LmV4dGVybmFsTWVhc3VyZWQgPSBudWxsIH1cXG5cXG4gIGlmIChsaW5lIDwgZGlzcGxheS52aWV3RnJvbSB8fCBsaW5lID49IGRpc3BsYXkudmlld1RvKSB7IHJldHVybiB9XFxuICB2YXIgbGluZVZpZXcgPSBkaXNwbGF5LnZpZXdbZmluZFZpZXdJbmRleChjbSwgbGluZSldXFxuICBpZiAobGluZVZpZXcubm9kZSA9PSBudWxsKSB7IHJldHVybiB9XFxuICB2YXIgYXJyID0gbGluZVZpZXcuY2hhbmdlcyB8fCAobGluZVZpZXcuY2hhbmdlcyA9IFtdKVxcbiAgaWYgKGluZGV4T2YoYXJyLCB0eXBlKSA9PSAtMSkgeyBhcnIucHVzaCh0eXBlKSB9XFxufVxcblxcbi8vIENsZWFyIHRoZSB2aWV3LlxcbmZ1bmN0aW9uIHJlc2V0VmlldyhjbSkge1xcbiAgY20uZGlzcGxheS52aWV3RnJvbSA9IGNtLmRpc3BsYXkudmlld1RvID0gY20uZG9jLmZpcnN0XFxuICBjbS5kaXNwbGF5LnZpZXcgPSBbXVxcbiAgY20uZGlzcGxheS52aWV3T2Zmc2V0ID0gMFxcbn1cXG5cXG5mdW5jdGlvbiB2aWV3Q3V0dGluZ1BvaW50KGNtLCBvbGROLCBuZXdOLCBkaXIpIHtcXG4gIHZhciBpbmRleCA9IGZpbmRWaWV3SW5kZXgoY20sIG9sZE4pLCBkaWZmLCB2aWV3ID0gY20uZGlzcGxheS52aWV3XFxuICBpZiAoIXNhd0NvbGxhcHNlZFNwYW5zIHx8IG5ld04gPT0gY20uZG9jLmZpcnN0ICsgY20uZG9jLnNpemUpXFxuICAgIHsgcmV0dXJuIHtpbmRleDogaW5kZXgsIGxpbmVOOiBuZXdOfSB9XFxuICB2YXIgbiA9IGNtLmRpc3BsYXkudmlld0Zyb21cXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgaW5kZXg7IGkrKylcXG4gICAgeyBuICs9IHZpZXdbaV0uc2l6ZSB9XFxuICBpZiAobiAhPSBvbGROKSB7XFxuICAgIGlmIChkaXIgPiAwKSB7XFxuICAgICAgaWYgKGluZGV4ID09IHZpZXcubGVuZ3RoIC0gMSkgeyByZXR1cm4gbnVsbCB9XFxuICAgICAgZGlmZiA9IChuICsgdmlld1tpbmRleF0uc2l6ZSkgLSBvbGROXFxuICAgICAgaW5kZXgrK1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIGRpZmYgPSBuIC0gb2xkTlxcbiAgICB9XFxuICAgIG9sZE4gKz0gZGlmZjsgbmV3TiArPSBkaWZmXFxuICB9XFxuICB3aGlsZSAodmlzdWFsTGluZU5vKGNtLmRvYywgbmV3TikgIT0gbmV3Tikge1xcbiAgICBpZiAoaW5kZXggPT0gKGRpciA8IDAgPyAwIDogdmlldy5sZW5ndGggLSAxKSkgeyByZXR1cm4gbnVsbCB9XFxuICAgIG5ld04gKz0gZGlyICogdmlld1tpbmRleCAtIChkaXIgPCAwID8gMSA6IDApXS5zaXplXFxuICAgIGluZGV4ICs9IGRpclxcbiAgfVxcbiAgcmV0dXJuIHtpbmRleDogaW5kZXgsIGxpbmVOOiBuZXdOfVxcbn1cXG5cXG4vLyBGb3JjZSB0aGUgdmlldyB0byBjb3ZlciBhIGdpdmVuIHJhbmdlLCBhZGRpbmcgZW1wdHkgdmlldyBlbGVtZW50XFxuLy8gb3IgY2xpcHBpbmcgb2ZmIGV4aXN0aW5nIG9uZXMgYXMgbmVlZGVkLlxcbmZ1bmN0aW9uIGFkanVzdFZpZXcoY20sIGZyb20sIHRvKSB7XFxuICB2YXIgZGlzcGxheSA9IGNtLmRpc3BsYXksIHZpZXcgPSBkaXNwbGF5LnZpZXdcXG4gIGlmICh2aWV3Lmxlbmd0aCA9PSAwIHx8IGZyb20gPj0gZGlzcGxheS52aWV3VG8gfHwgdG8gPD0gZGlzcGxheS52aWV3RnJvbSkge1xcbiAgICBkaXNwbGF5LnZpZXcgPSBidWlsZFZpZXdBcnJheShjbSwgZnJvbSwgdG8pXFxuICAgIGRpc3BsYXkudmlld0Zyb20gPSBmcm9tXFxuICB9IGVsc2Uge1xcbiAgICBpZiAoZGlzcGxheS52aWV3RnJvbSA+IGZyb20pXFxuICAgICAgeyBkaXNwbGF5LnZpZXcgPSBidWlsZFZpZXdBcnJheShjbSwgZnJvbSwgZGlzcGxheS52aWV3RnJvbSkuY29uY2F0KGRpc3BsYXkudmlldykgfVxcbiAgICBlbHNlIGlmIChkaXNwbGF5LnZpZXdGcm9tIDwgZnJvbSlcXG4gICAgICB7IGRpc3BsYXkudmlldyA9IGRpc3BsYXkudmlldy5zbGljZShmaW5kVmlld0luZGV4KGNtLCBmcm9tKSkgfVxcbiAgICBkaXNwbGF5LnZpZXdGcm9tID0gZnJvbVxcbiAgICBpZiAoZGlzcGxheS52aWV3VG8gPCB0bylcXG4gICAgICB7IGRpc3BsYXkudmlldyA9IGRpc3BsYXkudmlldy5jb25jYXQoYnVpbGRWaWV3QXJyYXkoY20sIGRpc3BsYXkudmlld1RvLCB0bykpIH1cXG4gICAgZWxzZSBpZiAoZGlzcGxheS52aWV3VG8gPiB0bylcXG4gICAgICB7IGRpc3BsYXkudmlldyA9IGRpc3BsYXkudmlldy5zbGljZSgwLCBmaW5kVmlld0luZGV4KGNtLCB0bykpIH1cXG4gIH1cXG4gIGRpc3BsYXkudmlld1RvID0gdG9cXG59XFxuXFxuLy8gQ291bnQgdGhlIG51bWJlciBvZiBsaW5lcyBpbiB0aGUgdmlldyB3aG9zZSBET00gcmVwcmVzZW50YXRpb24gaXNcXG4vLyBvdXQgb2YgZGF0ZSAob3Igbm9uZXhpc3RlbnQpLlxcbmZ1bmN0aW9uIGNvdW50RGlydHlWaWV3KGNtKSB7XFxuICB2YXIgdmlldyA9IGNtLmRpc3BsYXkudmlldywgZGlydHkgPSAwXFxuICBmb3IgKHZhciBpID0gMDsgaSA8IHZpZXcubGVuZ3RoOyBpKyspIHtcXG4gICAgdmFyIGxpbmVWaWV3ID0gdmlld1tpXVxcbiAgICBpZiAoIWxpbmVWaWV3LmhpZGRlbiAmJiAoIWxpbmVWaWV3Lm5vZGUgfHwgbGluZVZpZXcuY2hhbmdlcykpIHsgKytkaXJ0eSB9XFxuICB9XFxuICByZXR1cm4gZGlydHlcXG59XFxuXFxuLy8gSElHSExJR0hUIFdPUktFUlxcblxcbmZ1bmN0aW9uIHN0YXJ0V29ya2VyKGNtLCB0aW1lKSB7XFxuICBpZiAoY20uZG9jLm1vZGUuc3RhcnRTdGF0ZSAmJiBjbS5kb2MuZnJvbnRpZXIgPCBjbS5kaXNwbGF5LnZpZXdUbylcXG4gICAgeyBjbS5zdGF0ZS5oaWdobGlnaHQuc2V0KHRpbWUsIGJpbmQoaGlnaGxpZ2h0V29ya2VyLCBjbSkpIH1cXG59XFxuXFxuZnVuY3Rpb24gaGlnaGxpZ2h0V29ya2VyKGNtKSB7XFxuICB2YXIgZG9jID0gY20uZG9jXFxuICBpZiAoZG9jLmZyb250aWVyIDwgZG9jLmZpcnN0KSB7IGRvYy5mcm9udGllciA9IGRvYy5maXJzdCB9XFxuICBpZiAoZG9jLmZyb250aWVyID49IGNtLmRpc3BsYXkudmlld1RvKSB7IHJldHVybiB9XFxuICB2YXIgZW5kID0gK25ldyBEYXRlICsgY20ub3B0aW9ucy53b3JrVGltZVxcbiAgdmFyIHN0YXRlID0gY29weVN0YXRlKGRvYy5tb2RlLCBnZXRTdGF0ZUJlZm9yZShjbSwgZG9jLmZyb250aWVyKSlcXG4gIHZhciBjaGFuZ2VkTGluZXMgPSBbXVxcblxcbiAgZG9jLml0ZXIoZG9jLmZyb250aWVyLCBNYXRoLm1pbihkb2MuZmlyc3QgKyBkb2Muc2l6ZSwgY20uZGlzcGxheS52aWV3VG8gKyA1MDApLCBmdW5jdGlvbiAobGluZSkge1xcbiAgICBpZiAoZG9jLmZyb250aWVyID49IGNtLmRpc3BsYXkudmlld0Zyb20pIHsgLy8gVmlzaWJsZVxcbiAgICAgIHZhciBvbGRTdHlsZXMgPSBsaW5lLnN0eWxlcywgdG9vTG9uZyA9IGxpbmUudGV4dC5sZW5ndGggPiBjbS5vcHRpb25zLm1heEhpZ2hsaWdodExlbmd0aFxcbiAgICAgIHZhciBoaWdobGlnaHRlZCA9IGhpZ2hsaWdodExpbmUoY20sIGxpbmUsIHRvb0xvbmcgPyBjb3B5U3RhdGUoZG9jLm1vZGUsIHN0YXRlKSA6IHN0YXRlLCB0cnVlKVxcbiAgICAgIGxpbmUuc3R5bGVzID0gaGlnaGxpZ2h0ZWQuc3R5bGVzXFxuICAgICAgdmFyIG9sZENscyA9IGxpbmUuc3R5bGVDbGFzc2VzLCBuZXdDbHMgPSBoaWdobGlnaHRlZC5jbGFzc2VzXFxuICAgICAgaWYgKG5ld0NscykgeyBsaW5lLnN0eWxlQ2xhc3NlcyA9IG5ld0NscyB9XFxuICAgICAgZWxzZSBpZiAob2xkQ2xzKSB7IGxpbmUuc3R5bGVDbGFzc2VzID0gbnVsbCB9XFxuICAgICAgdmFyIGlzY2hhbmdlID0gIW9sZFN0eWxlcyB8fCBvbGRTdHlsZXMubGVuZ3RoICE9IGxpbmUuc3R5bGVzLmxlbmd0aCB8fFxcbiAgICAgICAgb2xkQ2xzICE9IG5ld0NscyAmJiAoIW9sZENscyB8fCAhbmV3Q2xzIHx8IG9sZENscy5iZ0NsYXNzICE9IG5ld0Nscy5iZ0NsYXNzIHx8IG9sZENscy50ZXh0Q2xhc3MgIT0gbmV3Q2xzLnRleHRDbGFzcylcXG4gICAgICBmb3IgKHZhciBpID0gMDsgIWlzY2hhbmdlICYmIGkgPCBvbGRTdHlsZXMubGVuZ3RoOyArK2kpIHsgaXNjaGFuZ2UgPSBvbGRTdHlsZXNbaV0gIT0gbGluZS5zdHlsZXNbaV0gfVxcbiAgICAgIGlmIChpc2NoYW5nZSkgeyBjaGFuZ2VkTGluZXMucHVzaChkb2MuZnJvbnRpZXIpIH1cXG4gICAgICBsaW5lLnN0YXRlQWZ0ZXIgPSB0b29Mb25nID8gc3RhdGUgOiBjb3B5U3RhdGUoZG9jLm1vZGUsIHN0YXRlKVxcbiAgICB9IGVsc2Uge1xcbiAgICAgIGlmIChsaW5lLnRleHQubGVuZ3RoIDw9IGNtLm9wdGlvbnMubWF4SGlnaGxpZ2h0TGVuZ3RoKVxcbiAgICAgICAgeyBwcm9jZXNzTGluZShjbSwgbGluZS50ZXh0LCBzdGF0ZSkgfVxcbiAgICAgIGxpbmUuc3RhdGVBZnRlciA9IGRvYy5mcm9udGllciAlIDUgPT0gMCA/IGNvcHlTdGF0ZShkb2MubW9kZSwgc3RhdGUpIDogbnVsbFxcbiAgICB9XFxuICAgICsrZG9jLmZyb250aWVyXFxuICAgIGlmICgrbmV3IERhdGUgPiBlbmQpIHtcXG4gICAgICBzdGFydFdvcmtlcihjbSwgY20ub3B0aW9ucy53b3JrRGVsYXkpXFxuICAgICAgcmV0dXJuIHRydWVcXG4gICAgfVxcbiAgfSlcXG4gIGlmIChjaGFuZ2VkTGluZXMubGVuZ3RoKSB7IHJ1bkluT3AoY20sIGZ1bmN0aW9uICgpIHtcXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGFuZ2VkTGluZXMubGVuZ3RoOyBpKyspXFxuICAgICAgeyByZWdMaW5lQ2hhbmdlKGNtLCBjaGFuZ2VkTGluZXNbaV0sIFxcXCJ0ZXh0XFxcIikgfVxcbiAgfSkgfVxcbn1cXG5cXG4vLyBESVNQTEFZIERSQVdJTkdcXG5cXG5mdW5jdGlvbiBEaXNwbGF5VXBkYXRlKGNtLCB2aWV3cG9ydCwgZm9yY2UpIHtcXG4gIHZhciBkaXNwbGF5ID0gY20uZGlzcGxheVxcblxcbiAgdGhpcy52aWV3cG9ydCA9IHZpZXdwb3J0XFxuICAvLyBTdG9yZSBzb21lIHZhbHVlcyB0aGF0IHdlJ2xsIG5lZWQgbGF0ZXIgKGJ1dCBkb24ndCB3YW50IHRvIGZvcmNlIGEgcmVsYXlvdXQgZm9yKVxcbiAgdGhpcy52aXNpYmxlID0gdmlzaWJsZUxpbmVzKGRpc3BsYXksIGNtLmRvYywgdmlld3BvcnQpXFxuICB0aGlzLmVkaXRvcklzSGlkZGVuID0gIWRpc3BsYXkud3JhcHBlci5vZmZzZXRXaWR0aFxcbiAgdGhpcy53cmFwcGVySGVpZ2h0ID0gZGlzcGxheS53cmFwcGVyLmNsaWVudEhlaWdodFxcbiAgdGhpcy53cmFwcGVyV2lkdGggPSBkaXNwbGF5LndyYXBwZXIuY2xpZW50V2lkdGhcXG4gIHRoaXMub2xkRGlzcGxheVdpZHRoID0gZGlzcGxheVdpZHRoKGNtKVxcbiAgdGhpcy5mb3JjZSA9IGZvcmNlXFxuICB0aGlzLmRpbXMgPSBnZXREaW1lbnNpb25zKGNtKVxcbiAgdGhpcy5ldmVudHMgPSBbXVxcbn1cXG5cXG5EaXNwbGF5VXBkYXRlLnByb3RvdHlwZS5zaWduYWwgPSBmdW5jdGlvbihlbWl0dGVyLCB0eXBlKSB7XFxuICBpZiAoaGFzSGFuZGxlcihlbWl0dGVyLCB0eXBlKSlcXG4gICAgeyB0aGlzLmV2ZW50cy5wdXNoKGFyZ3VtZW50cykgfVxcbn1cXG5EaXNwbGF5VXBkYXRlLnByb3RvdHlwZS5maW5pc2ggPSBmdW5jdGlvbigpIHtcXG4gIHZhciB0aGlzJDEgPSB0aGlzO1xcblxcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmV2ZW50cy5sZW5ndGg7IGkrKylcXG4gICAgeyBzaWduYWwuYXBwbHkobnVsbCwgdGhpcyQxLmV2ZW50c1tpXSkgfVxcbn1cXG5cXG5mdW5jdGlvbiBtYXliZUNsaXBTY3JvbGxiYXJzKGNtKSB7XFxuICB2YXIgZGlzcGxheSA9IGNtLmRpc3BsYXlcXG4gIGlmICghZGlzcGxheS5zY3JvbGxiYXJzQ2xpcHBlZCAmJiBkaXNwbGF5LnNjcm9sbGVyLm9mZnNldFdpZHRoKSB7XFxuICAgIGRpc3BsYXkubmF0aXZlQmFyV2lkdGggPSBkaXNwbGF5LnNjcm9sbGVyLm9mZnNldFdpZHRoIC0gZGlzcGxheS5zY3JvbGxlci5jbGllbnRXaWR0aFxcbiAgICBkaXNwbGF5LmhlaWdodEZvcmNlci5zdHlsZS5oZWlnaHQgPSBzY3JvbGxHYXAoY20pICsgXFxcInB4XFxcIlxcbiAgICBkaXNwbGF5LnNpemVyLnN0eWxlLm1hcmdpbkJvdHRvbSA9IC1kaXNwbGF5Lm5hdGl2ZUJhcldpZHRoICsgXFxcInB4XFxcIlxcbiAgICBkaXNwbGF5LnNpemVyLnN0eWxlLmJvcmRlclJpZ2h0V2lkdGggPSBzY3JvbGxHYXAoY20pICsgXFxcInB4XFxcIlxcbiAgICBkaXNwbGF5LnNjcm9sbGJhcnNDbGlwcGVkID0gdHJ1ZVxcbiAgfVxcbn1cXG5cXG4vLyBEb2VzIHRoZSBhY3R1YWwgdXBkYXRpbmcgb2YgdGhlIGxpbmUgZGlzcGxheS4gQmFpbHMgb3V0XFxuLy8gKHJldHVybmluZyBmYWxzZSkgd2hlbiB0aGVyZSBpcyBub3RoaW5nIHRvIGJlIGRvbmUgYW5kIGZvcmNlZCBpc1xcbi8vIGZhbHNlLlxcbmZ1bmN0aW9uIHVwZGF0ZURpc3BsYXlJZk5lZWRlZChjbSwgdXBkYXRlKSB7XFxuICB2YXIgZGlzcGxheSA9IGNtLmRpc3BsYXksIGRvYyA9IGNtLmRvY1xcblxcbiAgaWYgKHVwZGF0ZS5lZGl0b3JJc0hpZGRlbikge1xcbiAgICByZXNldFZpZXcoY20pXFxuICAgIHJldHVybiBmYWxzZVxcbiAgfVxcblxcbiAgLy8gQmFpbCBvdXQgaWYgdGhlIHZpc2libGUgYXJlYSBpcyBhbHJlYWR5IHJlbmRlcmVkIGFuZCBub3RoaW5nIGNoYW5nZWQuXFxuICBpZiAoIXVwZGF0ZS5mb3JjZSAmJlxcbiAgICAgIHVwZGF0ZS52aXNpYmxlLmZyb20gPj0gZGlzcGxheS52aWV3RnJvbSAmJiB1cGRhdGUudmlzaWJsZS50byA8PSBkaXNwbGF5LnZpZXdUbyAmJlxcbiAgICAgIChkaXNwbGF5LnVwZGF0ZUxpbmVOdW1iZXJzID09IG51bGwgfHwgZGlzcGxheS51cGRhdGVMaW5lTnVtYmVycyA+PSBkaXNwbGF5LnZpZXdUbykgJiZcXG4gICAgICBkaXNwbGF5LnJlbmRlcmVkVmlldyA9PSBkaXNwbGF5LnZpZXcgJiYgY291bnREaXJ0eVZpZXcoY20pID09IDApXFxuICAgIHsgcmV0dXJuIGZhbHNlIH1cXG5cXG4gIGlmIChtYXliZVVwZGF0ZUxpbmVOdW1iZXJXaWR0aChjbSkpIHtcXG4gICAgcmVzZXRWaWV3KGNtKVxcbiAgICB1cGRhdGUuZGltcyA9IGdldERpbWVuc2lvbnMoY20pXFxuICB9XFxuXFxuICAvLyBDb21wdXRlIGEgc3VpdGFibGUgbmV3IHZpZXdwb3J0IChmcm9tICYgdG8pXFxuICB2YXIgZW5kID0gZG9jLmZpcnN0ICsgZG9jLnNpemVcXG4gIHZhciBmcm9tID0gTWF0aC5tYXgodXBkYXRlLnZpc2libGUuZnJvbSAtIGNtLm9wdGlvbnMudmlld3BvcnRNYXJnaW4sIGRvYy5maXJzdClcXG4gIHZhciB0byA9IE1hdGgubWluKGVuZCwgdXBkYXRlLnZpc2libGUudG8gKyBjbS5vcHRpb25zLnZpZXdwb3J0TWFyZ2luKVxcbiAgaWYgKGRpc3BsYXkudmlld0Zyb20gPCBmcm9tICYmIGZyb20gLSBkaXNwbGF5LnZpZXdGcm9tIDwgMjApIHsgZnJvbSA9IE1hdGgubWF4KGRvYy5maXJzdCwgZGlzcGxheS52aWV3RnJvbSkgfVxcbiAgaWYgKGRpc3BsYXkudmlld1RvID4gdG8gJiYgZGlzcGxheS52aWV3VG8gLSB0byA8IDIwKSB7IHRvID0gTWF0aC5taW4oZW5kLCBkaXNwbGF5LnZpZXdUbykgfVxcbiAgaWYgKHNhd0NvbGxhcHNlZFNwYW5zKSB7XFxuICAgIGZyb20gPSB2aXN1YWxMaW5lTm8oY20uZG9jLCBmcm9tKVxcbiAgICB0byA9IHZpc3VhbExpbmVFbmRObyhjbS5kb2MsIHRvKVxcbiAgfVxcblxcbiAgdmFyIGRpZmZlcmVudCA9IGZyb20gIT0gZGlzcGxheS52aWV3RnJvbSB8fCB0byAhPSBkaXNwbGF5LnZpZXdUbyB8fFxcbiAgICBkaXNwbGF5Lmxhc3RXcmFwSGVpZ2h0ICE9IHVwZGF0ZS53cmFwcGVySGVpZ2h0IHx8IGRpc3BsYXkubGFzdFdyYXBXaWR0aCAhPSB1cGRhdGUud3JhcHBlcldpZHRoXFxuICBhZGp1c3RWaWV3KGNtLCBmcm9tLCB0bylcXG5cXG4gIGRpc3BsYXkudmlld09mZnNldCA9IGhlaWdodEF0TGluZShnZXRMaW5lKGNtLmRvYywgZGlzcGxheS52aWV3RnJvbSkpXFxuICAvLyBQb3NpdGlvbiB0aGUgbW92ZXIgZGl2IHRvIGFsaWduIHdpdGggdGhlIGN1cnJlbnQgc2Nyb2xsIHBvc2l0aW9uXFxuICBjbS5kaXNwbGF5Lm1vdmVyLnN0eWxlLnRvcCA9IGRpc3BsYXkudmlld09mZnNldCArIFxcXCJweFxcXCJcXG5cXG4gIHZhciB0b1VwZGF0ZSA9IGNvdW50RGlydHlWaWV3KGNtKVxcbiAgaWYgKCFkaWZmZXJlbnQgJiYgdG9VcGRhdGUgPT0gMCAmJiAhdXBkYXRlLmZvcmNlICYmIGRpc3BsYXkucmVuZGVyZWRWaWV3ID09IGRpc3BsYXkudmlldyAmJlxcbiAgICAgIChkaXNwbGF5LnVwZGF0ZUxpbmVOdW1iZXJzID09IG51bGwgfHwgZGlzcGxheS51cGRhdGVMaW5lTnVtYmVycyA+PSBkaXNwbGF5LnZpZXdUbykpXFxuICAgIHsgcmV0dXJuIGZhbHNlIH1cXG5cXG4gIC8vIEZvciBiaWcgY2hhbmdlcywgd2UgaGlkZSB0aGUgZW5jbG9zaW5nIGVsZW1lbnQgZHVyaW5nIHRoZVxcbiAgLy8gdXBkYXRlLCBzaW5jZSB0aGF0IHNwZWVkcyB1cCB0aGUgb3BlcmF0aW9ucyBvbiBtb3N0IGJyb3dzZXJzLlxcbiAgdmFyIGZvY3VzZWQgPSBhY3RpdmVFbHQoKVxcbiAgaWYgKHRvVXBkYXRlID4gNCkgeyBkaXNwbGF5LmxpbmVEaXYuc3R5bGUuZGlzcGxheSA9IFxcXCJub25lXFxcIiB9XFxuICBwYXRjaERpc3BsYXkoY20sIGRpc3BsYXkudXBkYXRlTGluZU51bWJlcnMsIHVwZGF0ZS5kaW1zKVxcbiAgaWYgKHRvVXBkYXRlID4gNCkgeyBkaXNwbGF5LmxpbmVEaXYuc3R5bGUuZGlzcGxheSA9IFxcXCJcXFwiIH1cXG4gIGRpc3BsYXkucmVuZGVyZWRWaWV3ID0gZGlzcGxheS52aWV3XFxuICAvLyBUaGVyZSBtaWdodCBoYXZlIGJlZW4gYSB3aWRnZXQgd2l0aCBhIGZvY3VzZWQgZWxlbWVudCB0aGF0IGdvdFxcbiAgLy8gaGlkZGVuIG9yIHVwZGF0ZWQsIGlmIHNvIHJlLWZvY3VzIGl0LlxcbiAgaWYgKGZvY3VzZWQgJiYgYWN0aXZlRWx0KCkgIT0gZm9jdXNlZCAmJiBmb2N1c2VkLm9mZnNldEhlaWdodCkgeyBmb2N1c2VkLmZvY3VzKCkgfVxcblxcbiAgLy8gUHJldmVudCBzZWxlY3Rpb24gYW5kIGN1cnNvcnMgZnJvbSBpbnRlcmZlcmluZyB3aXRoIHRoZSBzY3JvbGxcXG4gIC8vIHdpZHRoIGFuZCBoZWlnaHQuXFxuICByZW1vdmVDaGlsZHJlbihkaXNwbGF5LmN1cnNvckRpdilcXG4gIHJlbW92ZUNoaWxkcmVuKGRpc3BsYXkuc2VsZWN0aW9uRGl2KVxcbiAgZGlzcGxheS5ndXR0ZXJzLnN0eWxlLmhlaWdodCA9IGRpc3BsYXkuc2l6ZXIuc3R5bGUubWluSGVpZ2h0ID0gMFxcblxcbiAgaWYgKGRpZmZlcmVudCkge1xcbiAgICBkaXNwbGF5Lmxhc3RXcmFwSGVpZ2h0ID0gdXBkYXRlLndyYXBwZXJIZWlnaHRcXG4gICAgZGlzcGxheS5sYXN0V3JhcFdpZHRoID0gdXBkYXRlLndyYXBwZXJXaWR0aFxcbiAgICBzdGFydFdvcmtlcihjbSwgNDAwKVxcbiAgfVxcblxcbiAgZGlzcGxheS51cGRhdGVMaW5lTnVtYmVycyA9IG51bGxcXG5cXG4gIHJldHVybiB0cnVlXFxufVxcblxcbmZ1bmN0aW9uIHBvc3RVcGRhdGVEaXNwbGF5KGNtLCB1cGRhdGUpIHtcXG4gIHZhciB2aWV3cG9ydCA9IHVwZGF0ZS52aWV3cG9ydFxcblxcbiAgZm9yICh2YXIgZmlyc3QgPSB0cnVlOzsgZmlyc3QgPSBmYWxzZSkge1xcbiAgICBpZiAoIWZpcnN0IHx8ICFjbS5vcHRpb25zLmxpbmVXcmFwcGluZyB8fCB1cGRhdGUub2xkRGlzcGxheVdpZHRoID09IGRpc3BsYXlXaWR0aChjbSkpIHtcXG4gICAgICAvLyBDbGlwIGZvcmNlZCB2aWV3cG9ydCB0byBhY3R1YWwgc2Nyb2xsYWJsZSBhcmVhLlxcbiAgICAgIGlmICh2aWV3cG9ydCAmJiB2aWV3cG9ydC50b3AgIT0gbnVsbClcXG4gICAgICAgIHsgdmlld3BvcnQgPSB7dG9wOiBNYXRoLm1pbihjbS5kb2MuaGVpZ2h0ICsgcGFkZGluZ1ZlcnQoY20uZGlzcGxheSkgLSBkaXNwbGF5SGVpZ2h0KGNtKSwgdmlld3BvcnQudG9wKX0gfVxcbiAgICAgIC8vIFVwZGF0ZWQgbGluZSBoZWlnaHRzIG1pZ2h0IHJlc3VsdCBpbiB0aGUgZHJhd24gYXJlYSBub3RcXG4gICAgICAvLyBhY3R1YWxseSBjb3ZlcmluZyB0aGUgdmlld3BvcnQuIEtlZXAgbG9vcGluZyB1bnRpbCBpdCBkb2VzLlxcbiAgICAgIHVwZGF0ZS52aXNpYmxlID0gdmlzaWJsZUxpbmVzKGNtLmRpc3BsYXksIGNtLmRvYywgdmlld3BvcnQpXFxuICAgICAgaWYgKHVwZGF0ZS52aXNpYmxlLmZyb20gPj0gY20uZGlzcGxheS52aWV3RnJvbSAmJiB1cGRhdGUudmlzaWJsZS50byA8PSBjbS5kaXNwbGF5LnZpZXdUbylcXG4gICAgICAgIHsgYnJlYWsgfVxcbiAgICB9XFxuICAgIGlmICghdXBkYXRlRGlzcGxheUlmTmVlZGVkKGNtLCB1cGRhdGUpKSB7IGJyZWFrIH1cXG4gICAgdXBkYXRlSGVpZ2h0c0luVmlld3BvcnQoY20pXFxuICAgIHZhciBiYXJNZWFzdXJlID0gbWVhc3VyZUZvclNjcm9sbGJhcnMoY20pXFxuICAgIHVwZGF0ZVNlbGVjdGlvbihjbSlcXG4gICAgdXBkYXRlU2Nyb2xsYmFycyhjbSwgYmFyTWVhc3VyZSlcXG4gICAgc2V0RG9jdW1lbnRIZWlnaHQoY20sIGJhck1lYXN1cmUpXFxuICB9XFxuXFxuICB1cGRhdGUuc2lnbmFsKGNtLCBcXFwidXBkYXRlXFxcIiwgY20pXFxuICBpZiAoY20uZGlzcGxheS52aWV3RnJvbSAhPSBjbS5kaXNwbGF5LnJlcG9ydGVkVmlld0Zyb20gfHwgY20uZGlzcGxheS52aWV3VG8gIT0gY20uZGlzcGxheS5yZXBvcnRlZFZpZXdUbykge1xcbiAgICB1cGRhdGUuc2lnbmFsKGNtLCBcXFwidmlld3BvcnRDaGFuZ2VcXFwiLCBjbSwgY20uZGlzcGxheS52aWV3RnJvbSwgY20uZGlzcGxheS52aWV3VG8pXFxuICAgIGNtLmRpc3BsYXkucmVwb3J0ZWRWaWV3RnJvbSA9IGNtLmRpc3BsYXkudmlld0Zyb207IGNtLmRpc3BsYXkucmVwb3J0ZWRWaWV3VG8gPSBjbS5kaXNwbGF5LnZpZXdUb1xcbiAgfVxcbn1cXG5cXG5mdW5jdGlvbiB1cGRhdGVEaXNwbGF5U2ltcGxlKGNtLCB2aWV3cG9ydCkge1xcbiAgdmFyIHVwZGF0ZSA9IG5ldyBEaXNwbGF5VXBkYXRlKGNtLCB2aWV3cG9ydClcXG4gIGlmICh1cGRhdGVEaXNwbGF5SWZOZWVkZWQoY20sIHVwZGF0ZSkpIHtcXG4gICAgdXBkYXRlSGVpZ2h0c0luVmlld3BvcnQoY20pXFxuICAgIHBvc3RVcGRhdGVEaXNwbGF5KGNtLCB1cGRhdGUpXFxuICAgIHZhciBiYXJNZWFzdXJlID0gbWVhc3VyZUZvclNjcm9sbGJhcnMoY20pXFxuICAgIHVwZGF0ZVNlbGVjdGlvbihjbSlcXG4gICAgdXBkYXRlU2Nyb2xsYmFycyhjbSwgYmFyTWVhc3VyZSlcXG4gICAgc2V0RG9jdW1lbnRIZWlnaHQoY20sIGJhck1lYXN1cmUpXFxuICAgIHVwZGF0ZS5maW5pc2goKVxcbiAgfVxcbn1cXG5cXG4vLyBTeW5jIHRoZSBhY3R1YWwgZGlzcGxheSBET00gc3RydWN0dXJlIHdpdGggZGlzcGxheS52aWV3LCByZW1vdmluZ1xcbi8vIG5vZGVzIGZvciBsaW5lcyB0aGF0IGFyZSBubyBsb25nZXIgaW4gdmlldywgYW5kIGNyZWF0aW5nIHRoZSBvbmVzXFxuLy8gdGhhdCBhcmUgbm90IHRoZXJlIHlldCwgYW5kIHVwZGF0aW5nIHRoZSBvbmVzIHRoYXQgYXJlIG91dCBvZlxcbi8vIGRhdGUuXFxuZnVuY3Rpb24gcGF0Y2hEaXNwbGF5KGNtLCB1cGRhdGVOdW1iZXJzRnJvbSwgZGltcykge1xcbiAgdmFyIGRpc3BsYXkgPSBjbS5kaXNwbGF5LCBsaW5lTnVtYmVycyA9IGNtLm9wdGlvbnMubGluZU51bWJlcnNcXG4gIHZhciBjb250YWluZXIgPSBkaXNwbGF5LmxpbmVEaXYsIGN1ciA9IGNvbnRhaW5lci5maXJzdENoaWxkXFxuXFxuICBmdW5jdGlvbiBybShub2RlKSB7XFxuICAgIHZhciBuZXh0ID0gbm9kZS5uZXh0U2libGluZ1xcbiAgICAvLyBXb3JrcyBhcm91bmQgYSB0aHJvdy1zY3JvbGwgYnVnIGluIE9TIFggV2Via2l0XFxuICAgIGlmICh3ZWJraXQgJiYgbWFjICYmIGNtLmRpc3BsYXkuY3VycmVudFdoZWVsVGFyZ2V0ID09IG5vZGUpXFxuICAgICAgeyBub2RlLnN0eWxlLmRpc3BsYXkgPSBcXFwibm9uZVxcXCIgfVxcbiAgICBlbHNlXFxuICAgICAgeyBub2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobm9kZSkgfVxcbiAgICByZXR1cm4gbmV4dFxcbiAgfVxcblxcbiAgdmFyIHZpZXcgPSBkaXNwbGF5LnZpZXcsIGxpbmVOID0gZGlzcGxheS52aWV3RnJvbVxcbiAgLy8gTG9vcCBvdmVyIHRoZSBlbGVtZW50cyBpbiB0aGUgdmlldywgc3luY2luZyBjdXIgKHRoZSBET00gbm9kZXNcXG4gIC8vIGluIGRpc3BsYXkubGluZURpdikgd2l0aCB0aGUgdmlldyBhcyB3ZSBnby5cXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdmlldy5sZW5ndGg7IGkrKykge1xcbiAgICB2YXIgbGluZVZpZXcgPSB2aWV3W2ldXFxuICAgIGlmIChsaW5lVmlldy5oaWRkZW4pIHtcXG4gICAgfSBlbHNlIGlmICghbGluZVZpZXcubm9kZSB8fCBsaW5lVmlldy5ub2RlLnBhcmVudE5vZGUgIT0gY29udGFpbmVyKSB7IC8vIE5vdCBkcmF3biB5ZXRcXG4gICAgICB2YXIgbm9kZSA9IGJ1aWxkTGluZUVsZW1lbnQoY20sIGxpbmVWaWV3LCBsaW5lTiwgZGltcylcXG4gICAgICBjb250YWluZXIuaW5zZXJ0QmVmb3JlKG5vZGUsIGN1cilcXG4gICAgfSBlbHNlIHsgLy8gQWxyZWFkeSBkcmF3blxcbiAgICAgIHdoaWxlIChjdXIgIT0gbGluZVZpZXcubm9kZSkgeyBjdXIgPSBybShjdXIpIH1cXG4gICAgICB2YXIgdXBkYXRlTnVtYmVyID0gbGluZU51bWJlcnMgJiYgdXBkYXRlTnVtYmVyc0Zyb20gIT0gbnVsbCAmJlxcbiAgICAgICAgdXBkYXRlTnVtYmVyc0Zyb20gPD0gbGluZU4gJiYgbGluZVZpZXcubGluZU51bWJlclxcbiAgICAgIGlmIChsaW5lVmlldy5jaGFuZ2VzKSB7XFxuICAgICAgICBpZiAoaW5kZXhPZihsaW5lVmlldy5jaGFuZ2VzLCBcXFwiZ3V0dGVyXFxcIikgPiAtMSkgeyB1cGRhdGVOdW1iZXIgPSBmYWxzZSB9XFxuICAgICAgICB1cGRhdGVMaW5lRm9yQ2hhbmdlcyhjbSwgbGluZVZpZXcsIGxpbmVOLCBkaW1zKVxcbiAgICAgIH1cXG4gICAgICBpZiAodXBkYXRlTnVtYmVyKSB7XFxuICAgICAgICByZW1vdmVDaGlsZHJlbihsaW5lVmlldy5saW5lTnVtYmVyKVxcbiAgICAgICAgbGluZVZpZXcubGluZU51bWJlci5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShsaW5lTnVtYmVyRm9yKGNtLm9wdGlvbnMsIGxpbmVOKSkpXFxuICAgICAgfVxcbiAgICAgIGN1ciA9IGxpbmVWaWV3Lm5vZGUubmV4dFNpYmxpbmdcXG4gICAgfVxcbiAgICBsaW5lTiArPSBsaW5lVmlldy5zaXplXFxuICB9XFxuICB3aGlsZSAoY3VyKSB7IGN1ciA9IHJtKGN1cikgfVxcbn1cXG5cXG5mdW5jdGlvbiB1cGRhdGVHdXR0ZXJTcGFjZShjbSkge1xcbiAgdmFyIHdpZHRoID0gY20uZGlzcGxheS5ndXR0ZXJzLm9mZnNldFdpZHRoXFxuICBjbS5kaXNwbGF5LnNpemVyLnN0eWxlLm1hcmdpbkxlZnQgPSB3aWR0aCArIFxcXCJweFxcXCJcXG59XFxuXFxuZnVuY3Rpb24gc2V0RG9jdW1lbnRIZWlnaHQoY20sIG1lYXN1cmUpIHtcXG4gIGNtLmRpc3BsYXkuc2l6ZXIuc3R5bGUubWluSGVpZ2h0ID0gbWVhc3VyZS5kb2NIZWlnaHQgKyBcXFwicHhcXFwiXFxuICBjbS5kaXNwbGF5LmhlaWdodEZvcmNlci5zdHlsZS50b3AgPSBtZWFzdXJlLmRvY0hlaWdodCArIFxcXCJweFxcXCJcXG4gIGNtLmRpc3BsYXkuZ3V0dGVycy5zdHlsZS5oZWlnaHQgPSAobWVhc3VyZS5kb2NIZWlnaHQgKyBjbS5kaXNwbGF5LmJhckhlaWdodCArIHNjcm9sbEdhcChjbSkpICsgXFxcInB4XFxcIlxcbn1cXG5cXG4vLyBSZWJ1aWxkIHRoZSBndXR0ZXIgZWxlbWVudHMsIGVuc3VyZSB0aGUgbWFyZ2luIHRvIHRoZSBsZWZ0IG9mIHRoZVxcbi8vIGNvZGUgbWF0Y2hlcyB0aGVpciB3aWR0aC5cXG5mdW5jdGlvbiB1cGRhdGVHdXR0ZXJzKGNtKSB7XFxuICB2YXIgZ3V0dGVycyA9IGNtLmRpc3BsYXkuZ3V0dGVycywgc3BlY3MgPSBjbS5vcHRpb25zLmd1dHRlcnNcXG4gIHJlbW92ZUNoaWxkcmVuKGd1dHRlcnMpXFxuICB2YXIgaSA9IDBcXG4gIGZvciAoOyBpIDwgc3BlY3MubGVuZ3RoOyArK2kpIHtcXG4gICAgdmFyIGd1dHRlckNsYXNzID0gc3BlY3NbaV1cXG4gICAgdmFyIGdFbHQgPSBndXR0ZXJzLmFwcGVuZENoaWxkKGVsdChcXFwiZGl2XFxcIiwgbnVsbCwgXFxcIkNvZGVNaXJyb3ItZ3V0dGVyIFxcXCIgKyBndXR0ZXJDbGFzcykpXFxuICAgIGlmIChndXR0ZXJDbGFzcyA9PSBcXFwiQ29kZU1pcnJvci1saW5lbnVtYmVyc1xcXCIpIHtcXG4gICAgICBjbS5kaXNwbGF5LmxpbmVHdXR0ZXIgPSBnRWx0XFxuICAgICAgZ0VsdC5zdHlsZS53aWR0aCA9IChjbS5kaXNwbGF5LmxpbmVOdW1XaWR0aCB8fCAxKSArIFxcXCJweFxcXCJcXG4gICAgfVxcbiAgfVxcbiAgZ3V0dGVycy5zdHlsZS5kaXNwbGF5ID0gaSA/IFxcXCJcXFwiIDogXFxcIm5vbmVcXFwiXFxuICB1cGRhdGVHdXR0ZXJTcGFjZShjbSlcXG59XFxuXFxuLy8gTWFrZSBzdXJlIHRoZSBndXR0ZXJzIG9wdGlvbnMgY29udGFpbnMgdGhlIGVsZW1lbnRcXG4vLyBcXFwiQ29kZU1pcnJvci1saW5lbnVtYmVyc1xcXCIgd2hlbiB0aGUgbGluZU51bWJlcnMgb3B0aW9uIGlzIHRydWUuXFxuZnVuY3Rpb24gc2V0R3V0dGVyc0ZvckxpbmVOdW1iZXJzKG9wdGlvbnMpIHtcXG4gIHZhciBmb3VuZCA9IGluZGV4T2Yob3B0aW9ucy5ndXR0ZXJzLCBcXFwiQ29kZU1pcnJvci1saW5lbnVtYmVyc1xcXCIpXFxuICBpZiAoZm91bmQgPT0gLTEgJiYgb3B0aW9ucy5saW5lTnVtYmVycykge1xcbiAgICBvcHRpb25zLmd1dHRlcnMgPSBvcHRpb25zLmd1dHRlcnMuY29uY2F0KFtcXFwiQ29kZU1pcnJvci1saW5lbnVtYmVyc1xcXCJdKVxcbiAgfSBlbHNlIGlmIChmb3VuZCA+IC0xICYmICFvcHRpb25zLmxpbmVOdW1iZXJzKSB7XFxuICAgIG9wdGlvbnMuZ3V0dGVycyA9IG9wdGlvbnMuZ3V0dGVycy5zbGljZSgwKVxcbiAgICBvcHRpb25zLmd1dHRlcnMuc3BsaWNlKGZvdW5kLCAxKVxcbiAgfVxcbn1cXG5cXG4vLyBTZWxlY3Rpb24gb2JqZWN0cyBhcmUgaW1tdXRhYmxlLiBBIG5ldyBvbmUgaXMgY3JlYXRlZCBldmVyeSB0aW1lXFxuLy8gdGhlIHNlbGVjdGlvbiBjaGFuZ2VzLiBBIHNlbGVjdGlvbiBpcyBvbmUgb3IgbW9yZSBub24tb3ZlcmxhcHBpbmdcXG4vLyAoYW5kIG5vbi10b3VjaGluZykgcmFuZ2VzLCBzb3J0ZWQsIGFuZCBhbiBpbnRlZ2VyIHRoYXQgaW5kaWNhdGVzXFxuLy8gd2hpY2ggb25lIGlzIHRoZSBwcmltYXJ5IHNlbGVjdGlvbiAodGhlIG9uZSB0aGF0J3Mgc2Nyb2xsZWQgaW50b1xcbi8vIHZpZXcsIHRoYXQgZ2V0Q3Vyc29yIHJldHVybnMsIGV0YykuXFxuZnVuY3Rpb24gU2VsZWN0aW9uKHJhbmdlcywgcHJpbUluZGV4KSB7XFxuICB0aGlzLnJhbmdlcyA9IHJhbmdlc1xcbiAgdGhpcy5wcmltSW5kZXggPSBwcmltSW5kZXhcXG59XFxuXFxuU2VsZWN0aW9uLnByb3RvdHlwZSA9IHtcXG4gIHByaW1hcnk6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5yYW5nZXNbdGhpcy5wcmltSW5kZXhdIH0sXFxuICBlcXVhbHM6IGZ1bmN0aW9uKG90aGVyKSB7XFxuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xcblxcbiAgICBpZiAob3RoZXIgPT0gdGhpcykgeyByZXR1cm4gdHJ1ZSB9XFxuICAgIGlmIChvdGhlci5wcmltSW5kZXggIT0gdGhpcy5wcmltSW5kZXggfHwgb3RoZXIucmFuZ2VzLmxlbmd0aCAhPSB0aGlzLnJhbmdlcy5sZW5ndGgpIHsgcmV0dXJuIGZhbHNlIH1cXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnJhbmdlcy5sZW5ndGg7IGkrKykge1xcbiAgICAgIHZhciBoZXJlID0gdGhpcyQxLnJhbmdlc1tpXSwgdGhlcmUgPSBvdGhlci5yYW5nZXNbaV1cXG4gICAgICBpZiAoY21wKGhlcmUuYW5jaG9yLCB0aGVyZS5hbmNob3IpICE9IDAgfHwgY21wKGhlcmUuaGVhZCwgdGhlcmUuaGVhZCkgIT0gMCkgeyByZXR1cm4gZmFsc2UgfVxcbiAgICB9XFxuICAgIHJldHVybiB0cnVlXFxuICB9LFxcbiAgZGVlcENvcHk6IGZ1bmN0aW9uKCkge1xcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcXG5cXG4gICAgdmFyIG91dCA9IFtdXFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5yYW5nZXMubGVuZ3RoOyBpKyspXFxuICAgICAgeyBvdXRbaV0gPSBuZXcgUmFuZ2UoY29weVBvcyh0aGlzJDEucmFuZ2VzW2ldLmFuY2hvciksIGNvcHlQb3ModGhpcyQxLnJhbmdlc1tpXS5oZWFkKSkgfVxcbiAgICByZXR1cm4gbmV3IFNlbGVjdGlvbihvdXQsIHRoaXMucHJpbUluZGV4KVxcbiAgfSxcXG4gIHNvbWV0aGluZ1NlbGVjdGVkOiBmdW5jdGlvbigpIHtcXG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XFxuXFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5yYW5nZXMubGVuZ3RoOyBpKyspXFxuICAgICAgeyBpZiAoIXRoaXMkMS5yYW5nZXNbaV0uZW1wdHkoKSkgeyByZXR1cm4gdHJ1ZSB9IH1cXG4gICAgcmV0dXJuIGZhbHNlXFxuICB9LFxcbiAgY29udGFpbnM6IGZ1bmN0aW9uKHBvcywgZW5kKSB7XFxuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xcblxcbiAgICBpZiAoIWVuZCkgeyBlbmQgPSBwb3MgfVxcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucmFuZ2VzLmxlbmd0aDsgaSsrKSB7XFxuICAgICAgdmFyIHJhbmdlID0gdGhpcyQxLnJhbmdlc1tpXVxcbiAgICAgIGlmIChjbXAoZW5kLCByYW5nZS5mcm9tKCkpID49IDAgJiYgY21wKHBvcywgcmFuZ2UudG8oKSkgPD0gMClcXG4gICAgICAgIHsgcmV0dXJuIGkgfVxcbiAgICB9XFxuICAgIHJldHVybiAtMVxcbiAgfVxcbn1cXG5cXG5mdW5jdGlvbiBSYW5nZShhbmNob3IsIGhlYWQpIHtcXG4gIHRoaXMuYW5jaG9yID0gYW5jaG9yOyB0aGlzLmhlYWQgPSBoZWFkXFxufVxcblxcblJhbmdlLnByb3RvdHlwZSA9IHtcXG4gIGZyb206IGZ1bmN0aW9uKCkgeyByZXR1cm4gbWluUG9zKHRoaXMuYW5jaG9yLCB0aGlzLmhlYWQpIH0sXFxuICB0bzogZnVuY3Rpb24oKSB7IHJldHVybiBtYXhQb3ModGhpcy5hbmNob3IsIHRoaXMuaGVhZCkgfSxcXG4gIGVtcHR5OiBmdW5jdGlvbigpIHtcXG4gICAgcmV0dXJuIHRoaXMuaGVhZC5saW5lID09IHRoaXMuYW5jaG9yLmxpbmUgJiYgdGhpcy5oZWFkLmNoID09IHRoaXMuYW5jaG9yLmNoXFxuICB9XFxufVxcblxcbi8vIFRha2UgYW4gdW5zb3J0ZWQsIHBvdGVudGlhbGx5IG92ZXJsYXBwaW5nIHNldCBvZiByYW5nZXMsIGFuZFxcbi8vIGJ1aWxkIGEgc2VsZWN0aW9uIG91dCBvZiBpdC4gJ0NvbnN1bWVzJyByYW5nZXMgYXJyYXkgKG1vZGlmeWluZ1xcbi8vIGl0KS5cXG5mdW5jdGlvbiBub3JtYWxpemVTZWxlY3Rpb24ocmFuZ2VzLCBwcmltSW5kZXgpIHtcXG4gIHZhciBwcmltID0gcmFuZ2VzW3ByaW1JbmRleF1cXG4gIHJhbmdlcy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBjbXAoYS5mcm9tKCksIGIuZnJvbSgpKTsgfSlcXG4gIHByaW1JbmRleCA9IGluZGV4T2YocmFuZ2VzLCBwcmltKVxcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCByYW5nZXMubGVuZ3RoOyBpKyspIHtcXG4gICAgdmFyIGN1ciA9IHJhbmdlc1tpXSwgcHJldiA9IHJhbmdlc1tpIC0gMV1cXG4gICAgaWYgKGNtcChwcmV2LnRvKCksIGN1ci5mcm9tKCkpID49IDApIHtcXG4gICAgICB2YXIgZnJvbSA9IG1pblBvcyhwcmV2LmZyb20oKSwgY3VyLmZyb20oKSksIHRvID0gbWF4UG9zKHByZXYudG8oKSwgY3VyLnRvKCkpXFxuICAgICAgdmFyIGludiA9IHByZXYuZW1wdHkoKSA/IGN1ci5mcm9tKCkgPT0gY3VyLmhlYWQgOiBwcmV2LmZyb20oKSA9PSBwcmV2LmhlYWRcXG4gICAgICBpZiAoaSA8PSBwcmltSW5kZXgpIHsgLS1wcmltSW5kZXggfVxcbiAgICAgIHJhbmdlcy5zcGxpY2UoLS1pLCAyLCBuZXcgUmFuZ2UoaW52ID8gdG8gOiBmcm9tLCBpbnYgPyBmcm9tIDogdG8pKVxcbiAgICB9XFxuICB9XFxuICByZXR1cm4gbmV3IFNlbGVjdGlvbihyYW5nZXMsIHByaW1JbmRleClcXG59XFxuXFxuZnVuY3Rpb24gc2ltcGxlU2VsZWN0aW9uKGFuY2hvciwgaGVhZCkge1xcbiAgcmV0dXJuIG5ldyBTZWxlY3Rpb24oW25ldyBSYW5nZShhbmNob3IsIGhlYWQgfHwgYW5jaG9yKV0sIDApXFxufVxcblxcbi8vIENvbXB1dGUgdGhlIHBvc2l0aW9uIG9mIHRoZSBlbmQgb2YgYSBjaGFuZ2UgKGl0cyAndG8nIHByb3BlcnR5XFxuLy8gcmVmZXJzIHRvIHRoZSBwcmUtY2hhbmdlIGVuZCkuXFxuZnVuY3Rpb24gY2hhbmdlRW5kKGNoYW5nZSkge1xcbiAgaWYgKCFjaGFuZ2UudGV4dCkgeyByZXR1cm4gY2hhbmdlLnRvIH1cXG4gIHJldHVybiBQb3MoY2hhbmdlLmZyb20ubGluZSArIGNoYW5nZS50ZXh0Lmxlbmd0aCAtIDEsXFxuICAgICAgICAgICAgIGxzdChjaGFuZ2UudGV4dCkubGVuZ3RoICsgKGNoYW5nZS50ZXh0Lmxlbmd0aCA9PSAxID8gY2hhbmdlLmZyb20uY2ggOiAwKSlcXG59XFxuXFxuLy8gQWRqdXN0IGEgcG9zaXRpb24gdG8gcmVmZXIgdG8gdGhlIHBvc3QtY2hhbmdlIHBvc2l0aW9uIG9mIHRoZVxcbi8vIHNhbWUgdGV4dCwgb3IgdGhlIGVuZCBvZiB0aGUgY2hhbmdlIGlmIHRoZSBjaGFuZ2UgY292ZXJzIGl0LlxcbmZ1bmN0aW9uIGFkanVzdEZvckNoYW5nZShwb3MsIGNoYW5nZSkge1xcbiAgaWYgKGNtcChwb3MsIGNoYW5nZS5mcm9tKSA8IDApIHsgcmV0dXJuIHBvcyB9XFxuICBpZiAoY21wKHBvcywgY2hhbmdlLnRvKSA8PSAwKSB7IHJldHVybiBjaGFuZ2VFbmQoY2hhbmdlKSB9XFxuXFxuICB2YXIgbGluZSA9IHBvcy5saW5lICsgY2hhbmdlLnRleHQubGVuZ3RoIC0gKGNoYW5nZS50by5saW5lIC0gY2hhbmdlLmZyb20ubGluZSkgLSAxLCBjaCA9IHBvcy5jaFxcbiAgaWYgKHBvcy5saW5lID09IGNoYW5nZS50by5saW5lKSB7IGNoICs9IGNoYW5nZUVuZChjaGFuZ2UpLmNoIC0gY2hhbmdlLnRvLmNoIH1cXG4gIHJldHVybiBQb3MobGluZSwgY2gpXFxufVxcblxcbmZ1bmN0aW9uIGNvbXB1dGVTZWxBZnRlckNoYW5nZShkb2MsIGNoYW5nZSkge1xcbiAgdmFyIG91dCA9IFtdXFxuICBmb3IgKHZhciBpID0gMDsgaSA8IGRvYy5zZWwucmFuZ2VzLmxlbmd0aDsgaSsrKSB7XFxuICAgIHZhciByYW5nZSA9IGRvYy5zZWwucmFuZ2VzW2ldXFxuICAgIG91dC5wdXNoKG5ldyBSYW5nZShhZGp1c3RGb3JDaGFuZ2UocmFuZ2UuYW5jaG9yLCBjaGFuZ2UpLFxcbiAgICAgICAgICAgICAgICAgICAgICAgYWRqdXN0Rm9yQ2hhbmdlKHJhbmdlLmhlYWQsIGNoYW5nZSkpKVxcbiAgfVxcbiAgcmV0dXJuIG5vcm1hbGl6ZVNlbGVjdGlvbihvdXQsIGRvYy5zZWwucHJpbUluZGV4KVxcbn1cXG5cXG5mdW5jdGlvbiBvZmZzZXRQb3MocG9zLCBvbGQsIG53KSB7XFxuICBpZiAocG9zLmxpbmUgPT0gb2xkLmxpbmUpXFxuICAgIHsgcmV0dXJuIFBvcyhudy5saW5lLCBwb3MuY2ggLSBvbGQuY2ggKyBudy5jaCkgfVxcbiAgZWxzZVxcbiAgICB7IHJldHVybiBQb3MobncubGluZSArIChwb3MubGluZSAtIG9sZC5saW5lKSwgcG9zLmNoKSB9XFxufVxcblxcbi8vIFVzZWQgYnkgcmVwbGFjZVNlbGVjdGlvbnMgdG8gYWxsb3cgbW92aW5nIHRoZSBzZWxlY3Rpb24gdG8gdGhlXFxuLy8gc3RhcnQgb3IgYXJvdW5kIHRoZSByZXBsYWNlZCB0ZXN0LiBIaW50IG1heSBiZSBcXFwic3RhcnRcXFwiIG9yIFxcXCJhcm91bmRcXFwiLlxcbmZ1bmN0aW9uIGNvbXB1dGVSZXBsYWNlZFNlbChkb2MsIGNoYW5nZXMsIGhpbnQpIHtcXG4gIHZhciBvdXQgPSBbXVxcbiAgdmFyIG9sZFByZXYgPSBQb3MoZG9jLmZpcnN0LCAwKSwgbmV3UHJldiA9IG9sZFByZXZcXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY2hhbmdlcy5sZW5ndGg7IGkrKykge1xcbiAgICB2YXIgY2hhbmdlID0gY2hhbmdlc1tpXVxcbiAgICB2YXIgZnJvbSA9IG9mZnNldFBvcyhjaGFuZ2UuZnJvbSwgb2xkUHJldiwgbmV3UHJldilcXG4gICAgdmFyIHRvID0gb2Zmc2V0UG9zKGNoYW5nZUVuZChjaGFuZ2UpLCBvbGRQcmV2LCBuZXdQcmV2KVxcbiAgICBvbGRQcmV2ID0gY2hhbmdlLnRvXFxuICAgIG5ld1ByZXYgPSB0b1xcbiAgICBpZiAoaGludCA9PSBcXFwiYXJvdW5kXFxcIikge1xcbiAgICAgIHZhciByYW5nZSA9IGRvYy5zZWwucmFuZ2VzW2ldLCBpbnYgPSBjbXAocmFuZ2UuaGVhZCwgcmFuZ2UuYW5jaG9yKSA8IDBcXG4gICAgICBvdXRbaV0gPSBuZXcgUmFuZ2UoaW52ID8gdG8gOiBmcm9tLCBpbnYgPyBmcm9tIDogdG8pXFxuICAgIH0gZWxzZSB7XFxuICAgICAgb3V0W2ldID0gbmV3IFJhbmdlKGZyb20sIGZyb20pXFxuICAgIH1cXG4gIH1cXG4gIHJldHVybiBuZXcgU2VsZWN0aW9uKG91dCwgZG9jLnNlbC5wcmltSW5kZXgpXFxufVxcblxcbi8vIFVzZWQgdG8gZ2V0IHRoZSBlZGl0b3IgaW50byBhIGNvbnNpc3RlbnQgc3RhdGUgYWdhaW4gd2hlbiBvcHRpb25zIGNoYW5nZS5cXG5cXG5mdW5jdGlvbiBsb2FkTW9kZShjbSkge1xcbiAgY20uZG9jLm1vZGUgPSBnZXRNb2RlKGNtLm9wdGlvbnMsIGNtLmRvYy5tb2RlT3B0aW9uKVxcbiAgcmVzZXRNb2RlU3RhdGUoY20pXFxufVxcblxcbmZ1bmN0aW9uIHJlc2V0TW9kZVN0YXRlKGNtKSB7XFxuICBjbS5kb2MuaXRlcihmdW5jdGlvbiAobGluZSkge1xcbiAgICBpZiAobGluZS5zdGF0ZUFmdGVyKSB7IGxpbmUuc3RhdGVBZnRlciA9IG51bGwgfVxcbiAgICBpZiAobGluZS5zdHlsZXMpIHsgbGluZS5zdHlsZXMgPSBudWxsIH1cXG4gIH0pXFxuICBjbS5kb2MuZnJvbnRpZXIgPSBjbS5kb2MuZmlyc3RcXG4gIHN0YXJ0V29ya2VyKGNtLCAxMDApXFxuICBjbS5zdGF0ZS5tb2RlR2VuKytcXG4gIGlmIChjbS5jdXJPcCkgeyByZWdDaGFuZ2UoY20pIH1cXG59XFxuXFxuLy8gRE9DVU1FTlQgREFUQSBTVFJVQ1RVUkVcXG5cXG4vLyBCeSBkZWZhdWx0LCB1cGRhdGVzIHRoYXQgc3RhcnQgYW5kIGVuZCBhdCB0aGUgYmVnaW5uaW5nIG9mIGEgbGluZVxcbi8vIGFyZSB0cmVhdGVkIHNwZWNpYWxseSwgaW4gb3JkZXIgdG8gbWFrZSB0aGUgYXNzb2NpYXRpb24gb2YgbGluZVxcbi8vIHdpZGdldHMgYW5kIG1hcmtlciBlbGVtZW50cyB3aXRoIHRoZSB0ZXh0IGJlaGF2ZSBtb3JlIGludHVpdGl2ZS5cXG5mdW5jdGlvbiBpc1dob2xlTGluZVVwZGF0ZShkb2MsIGNoYW5nZSkge1xcbiAgcmV0dXJuIGNoYW5nZS5mcm9tLmNoID09IDAgJiYgY2hhbmdlLnRvLmNoID09IDAgJiYgbHN0KGNoYW5nZS50ZXh0KSA9PSBcXFwiXFxcIiAmJlxcbiAgICAoIWRvYy5jbSB8fCBkb2MuY20ub3B0aW9ucy53aG9sZUxpbmVVcGRhdGVCZWZvcmUpXFxufVxcblxcbi8vIFBlcmZvcm0gYSBjaGFuZ2Ugb24gdGhlIGRvY3VtZW50IGRhdGEgc3RydWN0dXJlLlxcbmZ1bmN0aW9uIHVwZGF0ZURvYyhkb2MsIGNoYW5nZSwgbWFya2VkU3BhbnMsIGVzdGltYXRlSGVpZ2h0KSB7XFxuICBmdW5jdGlvbiBzcGFuc0ZvcihuKSB7cmV0dXJuIG1hcmtlZFNwYW5zID8gbWFya2VkU3BhbnNbbl0gOiBudWxsfVxcbiAgZnVuY3Rpb24gdXBkYXRlKGxpbmUsIHRleHQsIHNwYW5zKSB7XFxuICAgIHVwZGF0ZUxpbmUobGluZSwgdGV4dCwgc3BhbnMsIGVzdGltYXRlSGVpZ2h0KVxcbiAgICBzaWduYWxMYXRlcihsaW5lLCBcXFwiY2hhbmdlXFxcIiwgbGluZSwgY2hhbmdlKVxcbiAgfVxcbiAgZnVuY3Rpb24gbGluZXNGb3Ioc3RhcnQsIGVuZCkge1xcbiAgICB2YXIgcmVzdWx0ID0gW11cXG4gICAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpXFxuICAgICAgeyByZXN1bHQucHVzaChuZXcgTGluZSh0ZXh0W2ldLCBzcGFuc0ZvcihpKSwgZXN0aW1hdGVIZWlnaHQpKSB9XFxuICAgIHJldHVybiByZXN1bHRcXG4gIH1cXG5cXG4gIHZhciBmcm9tID0gY2hhbmdlLmZyb20sIHRvID0gY2hhbmdlLnRvLCB0ZXh0ID0gY2hhbmdlLnRleHRcXG4gIHZhciBmaXJzdExpbmUgPSBnZXRMaW5lKGRvYywgZnJvbS5saW5lKSwgbGFzdExpbmUgPSBnZXRMaW5lKGRvYywgdG8ubGluZSlcXG4gIHZhciBsYXN0VGV4dCA9IGxzdCh0ZXh0KSwgbGFzdFNwYW5zID0gc3BhbnNGb3IodGV4dC5sZW5ndGggLSAxKSwgbmxpbmVzID0gdG8ubGluZSAtIGZyb20ubGluZVxcblxcbiAgLy8gQWRqdXN0IHRoZSBsaW5lIHN0cnVjdHVyZVxcbiAgaWYgKGNoYW5nZS5mdWxsKSB7XFxuICAgIGRvYy5pbnNlcnQoMCwgbGluZXNGb3IoMCwgdGV4dC5sZW5ndGgpKVxcbiAgICBkb2MucmVtb3ZlKHRleHQubGVuZ3RoLCBkb2Muc2l6ZSAtIHRleHQubGVuZ3RoKVxcbiAgfSBlbHNlIGlmIChpc1dob2xlTGluZVVwZGF0ZShkb2MsIGNoYW5nZSkpIHtcXG4gICAgLy8gVGhpcyBpcyBhIHdob2xlLWxpbmUgcmVwbGFjZS4gVHJlYXRlZCBzcGVjaWFsbHkgdG8gbWFrZVxcbiAgICAvLyBzdXJlIGxpbmUgb2JqZWN0cyBtb3ZlIHRoZSB3YXkgdGhleSBhcmUgc3VwcG9zZWQgdG8uXFxuICAgIHZhciBhZGRlZCA9IGxpbmVzRm9yKDAsIHRleHQubGVuZ3RoIC0gMSlcXG4gICAgdXBkYXRlKGxhc3RMaW5lLCBsYXN0TGluZS50ZXh0LCBsYXN0U3BhbnMpXFxuICAgIGlmIChubGluZXMpIHsgZG9jLnJlbW92ZShmcm9tLmxpbmUsIG5saW5lcykgfVxcbiAgICBpZiAoYWRkZWQubGVuZ3RoKSB7IGRvYy5pbnNlcnQoZnJvbS5saW5lLCBhZGRlZCkgfVxcbiAgfSBlbHNlIGlmIChmaXJzdExpbmUgPT0gbGFzdExpbmUpIHtcXG4gICAgaWYgKHRleHQubGVuZ3RoID09IDEpIHtcXG4gICAgICB1cGRhdGUoZmlyc3RMaW5lLCBmaXJzdExpbmUudGV4dC5zbGljZSgwLCBmcm9tLmNoKSArIGxhc3RUZXh0ICsgZmlyc3RMaW5lLnRleHQuc2xpY2UodG8uY2gpLCBsYXN0U3BhbnMpXFxuICAgIH0gZWxzZSB7XFxuICAgICAgdmFyIGFkZGVkJDEgPSBsaW5lc0ZvcigxLCB0ZXh0Lmxlbmd0aCAtIDEpXFxuICAgICAgYWRkZWQkMS5wdXNoKG5ldyBMaW5lKGxhc3RUZXh0ICsgZmlyc3RMaW5lLnRleHQuc2xpY2UodG8uY2gpLCBsYXN0U3BhbnMsIGVzdGltYXRlSGVpZ2h0KSlcXG4gICAgICB1cGRhdGUoZmlyc3RMaW5lLCBmaXJzdExpbmUudGV4dC5zbGljZSgwLCBmcm9tLmNoKSArIHRleHRbMF0sIHNwYW5zRm9yKDApKVxcbiAgICAgIGRvYy5pbnNlcnQoZnJvbS5saW5lICsgMSwgYWRkZWQkMSlcXG4gICAgfVxcbiAgfSBlbHNlIGlmICh0ZXh0Lmxlbmd0aCA9PSAxKSB7XFxuICAgIHVwZGF0ZShmaXJzdExpbmUsIGZpcnN0TGluZS50ZXh0LnNsaWNlKDAsIGZyb20uY2gpICsgdGV4dFswXSArIGxhc3RMaW5lLnRleHQuc2xpY2UodG8uY2gpLCBzcGFuc0ZvcigwKSlcXG4gICAgZG9jLnJlbW92ZShmcm9tLmxpbmUgKyAxLCBubGluZXMpXFxuICB9IGVsc2Uge1xcbiAgICB1cGRhdGUoZmlyc3RMaW5lLCBmaXJzdExpbmUudGV4dC5zbGljZSgwLCBmcm9tLmNoKSArIHRleHRbMF0sIHNwYW5zRm9yKDApKVxcbiAgICB1cGRhdGUobGFzdExpbmUsIGxhc3RUZXh0ICsgbGFzdExpbmUudGV4dC5zbGljZSh0by5jaCksIGxhc3RTcGFucylcXG4gICAgdmFyIGFkZGVkJDIgPSBsaW5lc0ZvcigxLCB0ZXh0Lmxlbmd0aCAtIDEpXFxuICAgIGlmIChubGluZXMgPiAxKSB7IGRvYy5yZW1vdmUoZnJvbS5saW5lICsgMSwgbmxpbmVzIC0gMSkgfVxcbiAgICBkb2MuaW5zZXJ0KGZyb20ubGluZSArIDEsIGFkZGVkJDIpXFxuICB9XFxuXFxuICBzaWduYWxMYXRlcihkb2MsIFxcXCJjaGFuZ2VcXFwiLCBkb2MsIGNoYW5nZSlcXG59XFxuXFxuLy8gQ2FsbCBmIGZvciBhbGwgbGlua2VkIGRvY3VtZW50cy5cXG5mdW5jdGlvbiBsaW5rZWREb2NzKGRvYywgZiwgc2hhcmVkSGlzdE9ubHkpIHtcXG4gIGZ1bmN0aW9uIHByb3BhZ2F0ZShkb2MsIHNraXAsIHNoYXJlZEhpc3QpIHtcXG4gICAgaWYgKGRvYy5saW5rZWQpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBkb2MubGlua2VkLmxlbmd0aDsgKytpKSB7XFxuICAgICAgdmFyIHJlbCA9IGRvYy5saW5rZWRbaV1cXG4gICAgICBpZiAocmVsLmRvYyA9PSBza2lwKSB7IGNvbnRpbnVlIH1cXG4gICAgICB2YXIgc2hhcmVkID0gc2hhcmVkSGlzdCAmJiByZWwuc2hhcmVkSGlzdFxcbiAgICAgIGlmIChzaGFyZWRIaXN0T25seSAmJiAhc2hhcmVkKSB7IGNvbnRpbnVlIH1cXG4gICAgICBmKHJlbC5kb2MsIHNoYXJlZClcXG4gICAgICBwcm9wYWdhdGUocmVsLmRvYywgZG9jLCBzaGFyZWQpXFxuICAgIH0gfVxcbiAgfVxcbiAgcHJvcGFnYXRlKGRvYywgbnVsbCwgdHJ1ZSlcXG59XFxuXFxuLy8gQXR0YWNoIGEgZG9jdW1lbnQgdG8gYW4gZWRpdG9yLlxcbmZ1bmN0aW9uIGF0dGFjaERvYyhjbSwgZG9jKSB7XFxuICBpZiAoZG9jLmNtKSB7IHRocm93IG5ldyBFcnJvcihcXFwiVGhpcyBkb2N1bWVudCBpcyBhbHJlYWR5IGluIHVzZS5cXFwiKSB9XFxuICBjbS5kb2MgPSBkb2NcXG4gIGRvYy5jbSA9IGNtXFxuICBlc3RpbWF0ZUxpbmVIZWlnaHRzKGNtKVxcbiAgbG9hZE1vZGUoY20pXFxuICBpZiAoIWNtLm9wdGlvbnMubGluZVdyYXBwaW5nKSB7IGZpbmRNYXhMaW5lKGNtKSB9XFxuICBjbS5vcHRpb25zLm1vZGUgPSBkb2MubW9kZU9wdGlvblxcbiAgcmVnQ2hhbmdlKGNtKVxcbn1cXG5cXG5mdW5jdGlvbiBIaXN0b3J5KHN0YXJ0R2VuKSB7XFxuICAvLyBBcnJheXMgb2YgY2hhbmdlIGV2ZW50cyBhbmQgc2VsZWN0aW9ucy4gRG9pbmcgc29tZXRoaW5nIGFkZHMgYW5cXG4gIC8vIGV2ZW50IHRvIGRvbmUgYW5kIGNsZWFycyB1bmRvLiBVbmRvaW5nIG1vdmVzIGV2ZW50cyBmcm9tIGRvbmVcXG4gIC8vIHRvIHVuZG9uZSwgcmVkb2luZyBtb3ZlcyB0aGVtIGluIHRoZSBvdGhlciBkaXJlY3Rpb24uXFxuICB0aGlzLmRvbmUgPSBbXTsgdGhpcy51bmRvbmUgPSBbXVxcbiAgdGhpcy51bmRvRGVwdGggPSBJbmZpbml0eVxcbiAgLy8gVXNlZCB0byB0cmFjayB3aGVuIGNoYW5nZXMgY2FuIGJlIG1lcmdlZCBpbnRvIGEgc2luZ2xlIHVuZG9cXG4gIC8vIGV2ZW50XFxuICB0aGlzLmxhc3RNb2RUaW1lID0gdGhpcy5sYXN0U2VsVGltZSA9IDBcXG4gIHRoaXMubGFzdE9wID0gdGhpcy5sYXN0U2VsT3AgPSBudWxsXFxuICB0aGlzLmxhc3RPcmlnaW4gPSB0aGlzLmxhc3RTZWxPcmlnaW4gPSBudWxsXFxuICAvLyBVc2VkIGJ5IHRoZSBpc0NsZWFuKCkgbWV0aG9kXFxuICB0aGlzLmdlbmVyYXRpb24gPSB0aGlzLm1heEdlbmVyYXRpb24gPSBzdGFydEdlbiB8fCAxXFxufVxcblxcbi8vIENyZWF0ZSBhIGhpc3RvcnkgY2hhbmdlIGV2ZW50IGZyb20gYW4gdXBkYXRlRG9jLXN0eWxlIGNoYW5nZVxcbi8vIG9iamVjdC5cXG5mdW5jdGlvbiBoaXN0b3J5Q2hhbmdlRnJvbUNoYW5nZShkb2MsIGNoYW5nZSkge1xcbiAgdmFyIGhpc3RDaGFuZ2UgPSB7ZnJvbTogY29weVBvcyhjaGFuZ2UuZnJvbSksIHRvOiBjaGFuZ2VFbmQoY2hhbmdlKSwgdGV4dDogZ2V0QmV0d2Vlbihkb2MsIGNoYW5nZS5mcm9tLCBjaGFuZ2UudG8pfVxcbiAgYXR0YWNoTG9jYWxTcGFucyhkb2MsIGhpc3RDaGFuZ2UsIGNoYW5nZS5mcm9tLmxpbmUsIGNoYW5nZS50by5saW5lICsgMSlcXG4gIGxpbmtlZERvY3MoZG9jLCBmdW5jdGlvbiAoZG9jKSB7IHJldHVybiBhdHRhY2hMb2NhbFNwYW5zKGRvYywgaGlzdENoYW5nZSwgY2hhbmdlLmZyb20ubGluZSwgY2hhbmdlLnRvLmxpbmUgKyAxKTsgfSwgdHJ1ZSlcXG4gIHJldHVybiBoaXN0Q2hhbmdlXFxufVxcblxcbi8vIFBvcCBhbGwgc2VsZWN0aW9uIGV2ZW50cyBvZmYgdGhlIGVuZCBvZiBhIGhpc3RvcnkgYXJyYXkuIFN0b3AgYXRcXG4vLyBhIGNoYW5nZSBldmVudC5cXG5mdW5jdGlvbiBjbGVhclNlbGVjdGlvbkV2ZW50cyhhcnJheSkge1xcbiAgd2hpbGUgKGFycmF5Lmxlbmd0aCkge1xcbiAgICB2YXIgbGFzdCA9IGxzdChhcnJheSlcXG4gICAgaWYgKGxhc3QucmFuZ2VzKSB7IGFycmF5LnBvcCgpIH1cXG4gICAgZWxzZSB7IGJyZWFrIH1cXG4gIH1cXG59XFxuXFxuLy8gRmluZCB0aGUgdG9wIGNoYW5nZSBldmVudCBpbiB0aGUgaGlzdG9yeS4gUG9wIG9mZiBzZWxlY3Rpb25cXG4vLyBldmVudHMgdGhhdCBhcmUgaW4gdGhlIHdheS5cXG5mdW5jdGlvbiBsYXN0Q2hhbmdlRXZlbnQoaGlzdCwgZm9yY2UpIHtcXG4gIGlmIChmb3JjZSkge1xcbiAgICBjbGVhclNlbGVjdGlvbkV2ZW50cyhoaXN0LmRvbmUpXFxuICAgIHJldHVybiBsc3QoaGlzdC5kb25lKVxcbiAgfSBlbHNlIGlmIChoaXN0LmRvbmUubGVuZ3RoICYmICFsc3QoaGlzdC5kb25lKS5yYW5nZXMpIHtcXG4gICAgcmV0dXJuIGxzdChoaXN0LmRvbmUpXFxuICB9IGVsc2UgaWYgKGhpc3QuZG9uZS5sZW5ndGggPiAxICYmICFoaXN0LmRvbmVbaGlzdC5kb25lLmxlbmd0aCAtIDJdLnJhbmdlcykge1xcbiAgICBoaXN0LmRvbmUucG9wKClcXG4gICAgcmV0dXJuIGxzdChoaXN0LmRvbmUpXFxuICB9XFxufVxcblxcbi8vIFJlZ2lzdGVyIGEgY2hhbmdlIGluIHRoZSBoaXN0b3J5LiBNZXJnZXMgY2hhbmdlcyB0aGF0IGFyZSB3aXRoaW5cXG4vLyBhIHNpbmdsZSBvcGVyYXRpb24sIG9yIGFyZSBjbG9zZSB0b2dldGhlciB3aXRoIGFuIG9yaWdpbiB0aGF0XFxuLy8gYWxsb3dzIG1lcmdpbmcgKHN0YXJ0aW5nIHdpdGggXFxcIitcXFwiKSBpbnRvIGEgc2luZ2xlIGV2ZW50LlxcbmZ1bmN0aW9uIGFkZENoYW5nZVRvSGlzdG9yeShkb2MsIGNoYW5nZSwgc2VsQWZ0ZXIsIG9wSWQpIHtcXG4gIHZhciBoaXN0ID0gZG9jLmhpc3RvcnlcXG4gIGhpc3QudW5kb25lLmxlbmd0aCA9IDBcXG4gIHZhciB0aW1lID0gK25ldyBEYXRlLCBjdXJcXG4gIHZhciBsYXN0XFxuXFxuICBpZiAoKGhpc3QubGFzdE9wID09IG9wSWQgfHxcXG4gICAgICAgaGlzdC5sYXN0T3JpZ2luID09IGNoYW5nZS5vcmlnaW4gJiYgY2hhbmdlLm9yaWdpbiAmJlxcbiAgICAgICAoKGNoYW5nZS5vcmlnaW4uY2hhckF0KDApID09IFxcXCIrXFxcIiAmJiBkb2MuY20gJiYgaGlzdC5sYXN0TW9kVGltZSA+IHRpbWUgLSBkb2MuY20ub3B0aW9ucy5oaXN0b3J5RXZlbnREZWxheSkgfHxcXG4gICAgICAgIGNoYW5nZS5vcmlnaW4uY2hhckF0KDApID09IFxcXCIqXFxcIikpICYmXFxuICAgICAgKGN1ciA9IGxhc3RDaGFuZ2VFdmVudChoaXN0LCBoaXN0Lmxhc3RPcCA9PSBvcElkKSkpIHtcXG4gICAgLy8gTWVyZ2UgdGhpcyBjaGFuZ2UgaW50byB0aGUgbGFzdCBldmVudFxcbiAgICBsYXN0ID0gbHN0KGN1ci5jaGFuZ2VzKVxcbiAgICBpZiAoY21wKGNoYW5nZS5mcm9tLCBjaGFuZ2UudG8pID09IDAgJiYgY21wKGNoYW5nZS5mcm9tLCBsYXN0LnRvKSA9PSAwKSB7XFxuICAgICAgLy8gT3B0aW1pemVkIGNhc2UgZm9yIHNpbXBsZSBpbnNlcnRpb24gLS0gZG9uJ3Qgd2FudCB0byBhZGRcXG4gICAgICAvLyBuZXcgY2hhbmdlc2V0cyBmb3IgZXZlcnkgY2hhcmFjdGVyIHR5cGVkXFxuICAgICAgbGFzdC50byA9IGNoYW5nZUVuZChjaGFuZ2UpXFxuICAgIH0gZWxzZSB7XFxuICAgICAgLy8gQWRkIG5ldyBzdWItZXZlbnRcXG4gICAgICBjdXIuY2hhbmdlcy5wdXNoKGhpc3RvcnlDaGFuZ2VGcm9tQ2hhbmdlKGRvYywgY2hhbmdlKSlcXG4gICAgfVxcbiAgfSBlbHNlIHtcXG4gICAgLy8gQ2FuIG5vdCBiZSBtZXJnZWQsIHN0YXJ0IGEgbmV3IGV2ZW50LlxcbiAgICB2YXIgYmVmb3JlID0gbHN0KGhpc3QuZG9uZSlcXG4gICAgaWYgKCFiZWZvcmUgfHwgIWJlZm9yZS5yYW5nZXMpXFxuICAgICAgeyBwdXNoU2VsZWN0aW9uVG9IaXN0b3J5KGRvYy5zZWwsIGhpc3QuZG9uZSkgfVxcbiAgICBjdXIgPSB7Y2hhbmdlczogW2hpc3RvcnlDaGFuZ2VGcm9tQ2hhbmdlKGRvYywgY2hhbmdlKV0sXFxuICAgICAgICAgICBnZW5lcmF0aW9uOiBoaXN0LmdlbmVyYXRpb259XFxuICAgIGhpc3QuZG9uZS5wdXNoKGN1cilcXG4gICAgd2hpbGUgKGhpc3QuZG9uZS5sZW5ndGggPiBoaXN0LnVuZG9EZXB0aCkge1xcbiAgICAgIGhpc3QuZG9uZS5zaGlmdCgpXFxuICAgICAgaWYgKCFoaXN0LmRvbmVbMF0ucmFuZ2VzKSB7IGhpc3QuZG9uZS5zaGlmdCgpIH1cXG4gICAgfVxcbiAgfVxcbiAgaGlzdC5kb25lLnB1c2goc2VsQWZ0ZXIpXFxuICBoaXN0LmdlbmVyYXRpb24gPSArK2hpc3QubWF4R2VuZXJhdGlvblxcbiAgaGlzdC5sYXN0TW9kVGltZSA9IGhpc3QubGFzdFNlbFRpbWUgPSB0aW1lXFxuICBoaXN0Lmxhc3RPcCA9IGhpc3QubGFzdFNlbE9wID0gb3BJZFxcbiAgaGlzdC5sYXN0T3JpZ2luID0gaGlzdC5sYXN0U2VsT3JpZ2luID0gY2hhbmdlLm9yaWdpblxcblxcbiAgaWYgKCFsYXN0KSB7IHNpZ25hbChkb2MsIFxcXCJoaXN0b3J5QWRkZWRcXFwiKSB9XFxufVxcblxcbmZ1bmN0aW9uIHNlbGVjdGlvbkV2ZW50Q2FuQmVNZXJnZWQoZG9jLCBvcmlnaW4sIHByZXYsIHNlbCkge1xcbiAgdmFyIGNoID0gb3JpZ2luLmNoYXJBdCgwKVxcbiAgcmV0dXJuIGNoID09IFxcXCIqXFxcIiB8fFxcbiAgICBjaCA9PSBcXFwiK1xcXCIgJiZcXG4gICAgcHJldi5yYW5nZXMubGVuZ3RoID09IHNlbC5yYW5nZXMubGVuZ3RoICYmXFxuICAgIHByZXYuc29tZXRoaW5nU2VsZWN0ZWQoKSA9PSBzZWwuc29tZXRoaW5nU2VsZWN0ZWQoKSAmJlxcbiAgICBuZXcgRGF0ZSAtIGRvYy5oaXN0b3J5Lmxhc3RTZWxUaW1lIDw9IChkb2MuY20gPyBkb2MuY20ub3B0aW9ucy5oaXN0b3J5RXZlbnREZWxheSA6IDUwMClcXG59XFxuXFxuLy8gQ2FsbGVkIHdoZW5ldmVyIHRoZSBzZWxlY3Rpb24gY2hhbmdlcywgc2V0cyB0aGUgbmV3IHNlbGVjdGlvbiBhc1xcbi8vIHRoZSBwZW5kaW5nIHNlbGVjdGlvbiBpbiB0aGUgaGlzdG9yeSwgYW5kIHB1c2hlcyB0aGUgb2xkIHBlbmRpbmdcXG4vLyBzZWxlY3Rpb24gaW50byB0aGUgJ2RvbmUnIGFycmF5IHdoZW4gaXQgd2FzIHNpZ25pZmljYW50bHlcXG4vLyBkaWZmZXJlbnQgKGluIG51bWJlciBvZiBzZWxlY3RlZCByYW5nZXMsIGVtcHRpbmVzcywgb3IgdGltZSkuXFxuZnVuY3Rpb24gYWRkU2VsZWN0aW9uVG9IaXN0b3J5KGRvYywgc2VsLCBvcElkLCBvcHRpb25zKSB7XFxuICB2YXIgaGlzdCA9IGRvYy5oaXN0b3J5LCBvcmlnaW4gPSBvcHRpb25zICYmIG9wdGlvbnMub3JpZ2luXFxuXFxuICAvLyBBIG5ldyBldmVudCBpcyBzdGFydGVkIHdoZW4gdGhlIHByZXZpb3VzIG9yaWdpbiBkb2VzIG5vdCBtYXRjaFxcbiAgLy8gdGhlIGN1cnJlbnQsIG9yIHRoZSBvcmlnaW5zIGRvbid0IGFsbG93IG1hdGNoaW5nLiBPcmlnaW5zXFxuICAvLyBzdGFydGluZyB3aXRoICogYXJlIGFsd2F5cyBtZXJnZWQsIHRob3NlIHN0YXJ0aW5nIHdpdGggKyBhcmVcXG4gIC8vIG1lcmdlZCB3aGVuIHNpbWlsYXIgYW5kIGNsb3NlIHRvZ2V0aGVyIGluIHRpbWUuXFxuICBpZiAob3BJZCA9PSBoaXN0Lmxhc3RTZWxPcCB8fFxcbiAgICAgIChvcmlnaW4gJiYgaGlzdC5sYXN0U2VsT3JpZ2luID09IG9yaWdpbiAmJlxcbiAgICAgICAoaGlzdC5sYXN0TW9kVGltZSA9PSBoaXN0Lmxhc3RTZWxUaW1lICYmIGhpc3QubGFzdE9yaWdpbiA9PSBvcmlnaW4gfHxcXG4gICAgICAgIHNlbGVjdGlvbkV2ZW50Q2FuQmVNZXJnZWQoZG9jLCBvcmlnaW4sIGxzdChoaXN0LmRvbmUpLCBzZWwpKSkpXFxuICAgIHsgaGlzdC5kb25lW2hpc3QuZG9uZS5sZW5ndGggLSAxXSA9IHNlbCB9XFxuICBlbHNlXFxuICAgIHsgcHVzaFNlbGVjdGlvblRvSGlzdG9yeShzZWwsIGhpc3QuZG9uZSkgfVxcblxcbiAgaGlzdC5sYXN0U2VsVGltZSA9ICtuZXcgRGF0ZVxcbiAgaGlzdC5sYXN0U2VsT3JpZ2luID0gb3JpZ2luXFxuICBoaXN0Lmxhc3RTZWxPcCA9IG9wSWRcXG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMuY2xlYXJSZWRvICE9PSBmYWxzZSlcXG4gICAgeyBjbGVhclNlbGVjdGlvbkV2ZW50cyhoaXN0LnVuZG9uZSkgfVxcbn1cXG5cXG5mdW5jdGlvbiBwdXNoU2VsZWN0aW9uVG9IaXN0b3J5KHNlbCwgZGVzdCkge1xcbiAgdmFyIHRvcCA9IGxzdChkZXN0KVxcbiAgaWYgKCEodG9wICYmIHRvcC5yYW5nZXMgJiYgdG9wLmVxdWFscyhzZWwpKSlcXG4gICAgeyBkZXN0LnB1c2goc2VsKSB9XFxufVxcblxcbi8vIFVzZWQgdG8gc3RvcmUgbWFya2VkIHNwYW4gaW5mb3JtYXRpb24gaW4gdGhlIGhpc3RvcnkuXFxuZnVuY3Rpb24gYXR0YWNoTG9jYWxTcGFucyhkb2MsIGNoYW5nZSwgZnJvbSwgdG8pIHtcXG4gIHZhciBleGlzdGluZyA9IGNoYW5nZVtcXFwic3BhbnNfXFxcIiArIGRvYy5pZF0sIG4gPSAwXFxuICBkb2MuaXRlcihNYXRoLm1heChkb2MuZmlyc3QsIGZyb20pLCBNYXRoLm1pbihkb2MuZmlyc3QgKyBkb2Muc2l6ZSwgdG8pLCBmdW5jdGlvbiAobGluZSkge1xcbiAgICBpZiAobGluZS5tYXJrZWRTcGFucylcXG4gICAgICB7IChleGlzdGluZyB8fCAoZXhpc3RpbmcgPSBjaGFuZ2VbXFxcInNwYW5zX1xcXCIgKyBkb2MuaWRdID0ge30pKVtuXSA9IGxpbmUubWFya2VkU3BhbnMgfVxcbiAgICArK25cXG4gIH0pXFxufVxcblxcbi8vIFdoZW4gdW4vcmUtZG9pbmcgcmVzdG9yZXMgdGV4dCBjb250YWluaW5nIG1hcmtlZCBzcGFucywgdGhvc2VcXG4vLyB0aGF0IGhhdmUgYmVlbiBleHBsaWNpdGx5IGNsZWFyZWQgc2hvdWxkIG5vdCBiZSByZXN0b3JlZC5cXG5mdW5jdGlvbiByZW1vdmVDbGVhcmVkU3BhbnMoc3BhbnMpIHtcXG4gIGlmICghc3BhbnMpIHsgcmV0dXJuIG51bGwgfVxcbiAgdmFyIG91dFxcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzcGFucy5sZW5ndGg7ICsraSkge1xcbiAgICBpZiAoc3BhbnNbaV0ubWFya2VyLmV4cGxpY2l0bHlDbGVhcmVkKSB7IGlmICghb3V0KSB7IG91dCA9IHNwYW5zLnNsaWNlKDAsIGkpIH0gfVxcbiAgICBlbHNlIGlmIChvdXQpIHsgb3V0LnB1c2goc3BhbnNbaV0pIH1cXG4gIH1cXG4gIHJldHVybiAhb3V0ID8gc3BhbnMgOiBvdXQubGVuZ3RoID8gb3V0IDogbnVsbFxcbn1cXG5cXG4vLyBSZXRyaWV2ZSBhbmQgZmlsdGVyIHRoZSBvbGQgbWFya2VkIHNwYW5zIHN0b3JlZCBpbiBhIGNoYW5nZSBldmVudC5cXG5mdW5jdGlvbiBnZXRPbGRTcGFucyhkb2MsIGNoYW5nZSkge1xcbiAgdmFyIGZvdW5kID0gY2hhbmdlW1xcXCJzcGFuc19cXFwiICsgZG9jLmlkXVxcbiAgaWYgKCFmb3VuZCkgeyByZXR1cm4gbnVsbCB9XFxuICB2YXIgbncgPSBbXVxcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGFuZ2UudGV4dC5sZW5ndGg7ICsraSlcXG4gICAgeyBudy5wdXNoKHJlbW92ZUNsZWFyZWRTcGFucyhmb3VuZFtpXSkpIH1cXG4gIHJldHVybiBud1xcbn1cXG5cXG4vLyBVc2VkIGZvciB1bi9yZS1kb2luZyBjaGFuZ2VzIGZyb20gdGhlIGhpc3RvcnkuIENvbWJpbmVzIHRoZVxcbi8vIHJlc3VsdCBvZiBjb21wdXRpbmcgdGhlIGV4aXN0aW5nIHNwYW5zIHdpdGggdGhlIHNldCBvZiBzcGFucyB0aGF0XFxuLy8gZXhpc3RlZCBpbiB0aGUgaGlzdG9yeSAoc28gdGhhdCBkZWxldGluZyBhcm91bmQgYSBzcGFuIGFuZCB0aGVuXFxuLy8gdW5kb2luZyBicmluZ3MgYmFjayB0aGUgc3BhbikuXFxuZnVuY3Rpb24gbWVyZ2VPbGRTcGFucyhkb2MsIGNoYW5nZSkge1xcbiAgdmFyIG9sZCA9IGdldE9sZFNwYW5zKGRvYywgY2hhbmdlKVxcbiAgdmFyIHN0cmV0Y2hlZCA9IHN0cmV0Y2hTcGFuc092ZXJDaGFuZ2UoZG9jLCBjaGFuZ2UpXFxuICBpZiAoIW9sZCkgeyByZXR1cm4gc3RyZXRjaGVkIH1cXG4gIGlmICghc3RyZXRjaGVkKSB7IHJldHVybiBvbGQgfVxcblxcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBvbGQubGVuZ3RoOyArK2kpIHtcXG4gICAgdmFyIG9sZEN1ciA9IG9sZFtpXSwgc3RyZXRjaEN1ciA9IHN0cmV0Y2hlZFtpXVxcbiAgICBpZiAob2xkQ3VyICYmIHN0cmV0Y2hDdXIpIHtcXG4gICAgICBzcGFuczogZm9yICh2YXIgaiA9IDA7IGogPCBzdHJldGNoQ3VyLmxlbmd0aDsgKytqKSB7XFxuICAgICAgICB2YXIgc3BhbiA9IHN0cmV0Y2hDdXJbal1cXG4gICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgb2xkQ3VyLmxlbmd0aDsgKytrKVxcbiAgICAgICAgICB7IGlmIChvbGRDdXJba10ubWFya2VyID09IHNwYW4ubWFya2VyKSB7IGNvbnRpbnVlIHNwYW5zIH0gfVxcbiAgICAgICAgb2xkQ3VyLnB1c2goc3BhbilcXG4gICAgICB9XFxuICAgIH0gZWxzZSBpZiAoc3RyZXRjaEN1cikge1xcbiAgICAgIG9sZFtpXSA9IHN0cmV0Y2hDdXJcXG4gICAgfVxcbiAgfVxcbiAgcmV0dXJuIG9sZFxcbn1cXG5cXG4vLyBVc2VkIGJvdGggdG8gcHJvdmlkZSBhIEpTT04tc2FmZSBvYmplY3QgaW4gLmdldEhpc3RvcnksIGFuZCwgd2hlblxcbi8vIGRldGFjaGluZyBhIGRvY3VtZW50LCB0byBzcGxpdCB0aGUgaGlzdG9yeSBpbiB0d29cXG5mdW5jdGlvbiBjb3B5SGlzdG9yeUFycmF5KGV2ZW50cywgbmV3R3JvdXAsIGluc3RhbnRpYXRlU2VsKSB7XFxuICB2YXIgY29weSA9IFtdXFxuICBmb3IgKHZhciBpID0gMDsgaSA8IGV2ZW50cy5sZW5ndGg7ICsraSkge1xcbiAgICB2YXIgZXZlbnQgPSBldmVudHNbaV1cXG4gICAgaWYgKGV2ZW50LnJhbmdlcykge1xcbiAgICAgIGNvcHkucHVzaChpbnN0YW50aWF0ZVNlbCA/IFNlbGVjdGlvbi5wcm90b3R5cGUuZGVlcENvcHkuY2FsbChldmVudCkgOiBldmVudClcXG4gICAgICBjb250aW51ZVxcbiAgICB9XFxuICAgIHZhciBjaGFuZ2VzID0gZXZlbnQuY2hhbmdlcywgbmV3Q2hhbmdlcyA9IFtdXFxuICAgIGNvcHkucHVzaCh7Y2hhbmdlczogbmV3Q2hhbmdlc30pXFxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgY2hhbmdlcy5sZW5ndGg7ICsraikge1xcbiAgICAgIHZhciBjaGFuZ2UgPSBjaGFuZ2VzW2pdLCBtID0gdm9pZCAwXFxuICAgICAgbmV3Q2hhbmdlcy5wdXNoKHtmcm9tOiBjaGFuZ2UuZnJvbSwgdG86IGNoYW5nZS50bywgdGV4dDogY2hhbmdlLnRleHR9KVxcbiAgICAgIGlmIChuZXdHcm91cCkgeyBmb3IgKHZhciBwcm9wIGluIGNoYW5nZSkgeyBpZiAobSA9IHByb3AubWF0Y2goL15zcGFuc18oXFxcXGQrKSQvKSkge1xcbiAgICAgICAgaWYgKGluZGV4T2YobmV3R3JvdXAsIE51bWJlcihtWzFdKSkgPiAtMSkge1xcbiAgICAgICAgICBsc3QobmV3Q2hhbmdlcylbcHJvcF0gPSBjaGFuZ2VbcHJvcF1cXG4gICAgICAgICAgZGVsZXRlIGNoYW5nZVtwcm9wXVxcbiAgICAgICAgfVxcbiAgICAgIH0gfSB9XFxuICAgIH1cXG4gIH1cXG4gIHJldHVybiBjb3B5XFxufVxcblxcbi8vIFRoZSAnc2Nyb2xsJyBwYXJhbWV0ZXIgZ2l2ZW4gdG8gbWFueSBvZiB0aGVzZSBpbmRpY2F0ZWQgd2hldGhlclxcbi8vIHRoZSBuZXcgY3Vyc29yIHBvc2l0aW9uIHNob3VsZCBiZSBzY3JvbGxlZCBpbnRvIHZpZXcgYWZ0ZXJcXG4vLyBtb2RpZnlpbmcgdGhlIHNlbGVjdGlvbi5cXG5cXG4vLyBJZiBzaGlmdCBpcyBoZWxkIG9yIHRoZSBleHRlbmQgZmxhZyBpcyBzZXQsIGV4dGVuZHMgYSByYW5nZSB0b1xcbi8vIGluY2x1ZGUgYSBnaXZlbiBwb3NpdGlvbiAoYW5kIG9wdGlvbmFsbHkgYSBzZWNvbmQgcG9zaXRpb24pLlxcbi8vIE90aGVyd2lzZSwgc2ltcGx5IHJldHVybnMgdGhlIHJhbmdlIGJldHdlZW4gdGhlIGdpdmVuIHBvc2l0aW9ucy5cXG4vLyBVc2VkIGZvciBjdXJzb3IgbW90aW9uIGFuZCBzdWNoLlxcbmZ1bmN0aW9uIGV4dGVuZFJhbmdlKGRvYywgcmFuZ2UsIGhlYWQsIG90aGVyKSB7XFxuICBpZiAoZG9jLmNtICYmIGRvYy5jbS5kaXNwbGF5LnNoaWZ0IHx8IGRvYy5leHRlbmQpIHtcXG4gICAgdmFyIGFuY2hvciA9IHJhbmdlLmFuY2hvclxcbiAgICBpZiAob3RoZXIpIHtcXG4gICAgICB2YXIgcG9zQmVmb3JlID0gY21wKGhlYWQsIGFuY2hvcikgPCAwXFxuICAgICAgaWYgKHBvc0JlZm9yZSAhPSAoY21wKG90aGVyLCBhbmNob3IpIDwgMCkpIHtcXG4gICAgICAgIGFuY2hvciA9IGhlYWRcXG4gICAgICAgIGhlYWQgPSBvdGhlclxcbiAgICAgIH0gZWxzZSBpZiAocG9zQmVmb3JlICE9IChjbXAoaGVhZCwgb3RoZXIpIDwgMCkpIHtcXG4gICAgICAgIGhlYWQgPSBvdGhlclxcbiAgICAgIH1cXG4gICAgfVxcbiAgICByZXR1cm4gbmV3IFJhbmdlKGFuY2hvciwgaGVhZClcXG4gIH0gZWxzZSB7XFxuICAgIHJldHVybiBuZXcgUmFuZ2Uob3RoZXIgfHwgaGVhZCwgaGVhZClcXG4gIH1cXG59XFxuXFxuLy8gRXh0ZW5kIHRoZSBwcmltYXJ5IHNlbGVjdGlvbiByYW5nZSwgZGlzY2FyZCB0aGUgcmVzdC5cXG5mdW5jdGlvbiBleHRlbmRTZWxlY3Rpb24oZG9jLCBoZWFkLCBvdGhlciwgb3B0aW9ucykge1xcbiAgc2V0U2VsZWN0aW9uKGRvYywgbmV3IFNlbGVjdGlvbihbZXh0ZW5kUmFuZ2UoZG9jLCBkb2Muc2VsLnByaW1hcnkoKSwgaGVhZCwgb3RoZXIpXSwgMCksIG9wdGlvbnMpXFxufVxcblxcbi8vIEV4dGVuZCBhbGwgc2VsZWN0aW9ucyAocG9zIGlzIGFuIGFycmF5IG9mIHNlbGVjdGlvbnMgd2l0aCBsZW5ndGhcXG4vLyBlcXVhbCB0aGUgbnVtYmVyIG9mIHNlbGVjdGlvbnMpXFxuZnVuY3Rpb24gZXh0ZW5kU2VsZWN0aW9ucyhkb2MsIGhlYWRzLCBvcHRpb25zKSB7XFxuICB2YXIgb3V0ID0gW11cXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZG9jLnNlbC5yYW5nZXMubGVuZ3RoOyBpKyspXFxuICAgIHsgb3V0W2ldID0gZXh0ZW5kUmFuZ2UoZG9jLCBkb2Muc2VsLnJhbmdlc1tpXSwgaGVhZHNbaV0sIG51bGwpIH1cXG4gIHZhciBuZXdTZWwgPSBub3JtYWxpemVTZWxlY3Rpb24ob3V0LCBkb2Muc2VsLnByaW1JbmRleClcXG4gIHNldFNlbGVjdGlvbihkb2MsIG5ld1NlbCwgb3B0aW9ucylcXG59XFxuXFxuLy8gVXBkYXRlcyBhIHNpbmdsZSByYW5nZSBpbiB0aGUgc2VsZWN0aW9uLlxcbmZ1bmN0aW9uIHJlcGxhY2VPbmVTZWxlY3Rpb24oZG9jLCBpLCByYW5nZSwgb3B0aW9ucykge1xcbiAgdmFyIHJhbmdlcyA9IGRvYy5zZWwucmFuZ2VzLnNsaWNlKDApXFxuICByYW5nZXNbaV0gPSByYW5nZVxcbiAgc2V0U2VsZWN0aW9uKGRvYywgbm9ybWFsaXplU2VsZWN0aW9uKHJhbmdlcywgZG9jLnNlbC5wcmltSW5kZXgpLCBvcHRpb25zKVxcbn1cXG5cXG4vLyBSZXNldCB0aGUgc2VsZWN0aW9uIHRvIGEgc2luZ2xlIHJhbmdlLlxcbmZ1bmN0aW9uIHNldFNpbXBsZVNlbGVjdGlvbihkb2MsIGFuY2hvciwgaGVhZCwgb3B0aW9ucykge1xcbiAgc2V0U2VsZWN0aW9uKGRvYywgc2ltcGxlU2VsZWN0aW9uKGFuY2hvciwgaGVhZCksIG9wdGlvbnMpXFxufVxcblxcbi8vIEdpdmUgYmVmb3JlU2VsZWN0aW9uQ2hhbmdlIGhhbmRsZXJzIGEgY2hhbmdlIHRvIGluZmx1ZW5jZSBhXFxuLy8gc2VsZWN0aW9uIHVwZGF0ZS5cXG5mdW5jdGlvbiBmaWx0ZXJTZWxlY3Rpb25DaGFuZ2UoZG9jLCBzZWwsIG9wdGlvbnMpIHtcXG4gIHZhciBvYmogPSB7XFxuICAgIHJhbmdlczogc2VsLnJhbmdlcyxcXG4gICAgdXBkYXRlOiBmdW5jdGlvbihyYW5nZXMpIHtcXG4gICAgICB2YXIgdGhpcyQxID0gdGhpcztcXG5cXG4gICAgICB0aGlzLnJhbmdlcyA9IFtdXFxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByYW5nZXMubGVuZ3RoOyBpKyspXFxuICAgICAgICB7IHRoaXMkMS5yYW5nZXNbaV0gPSBuZXcgUmFuZ2UoY2xpcFBvcyhkb2MsIHJhbmdlc1tpXS5hbmNob3IpLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xpcFBvcyhkb2MsIHJhbmdlc1tpXS5oZWFkKSkgfVxcbiAgICB9LFxcbiAgICBvcmlnaW46IG9wdGlvbnMgJiYgb3B0aW9ucy5vcmlnaW5cXG4gIH1cXG4gIHNpZ25hbChkb2MsIFxcXCJiZWZvcmVTZWxlY3Rpb25DaGFuZ2VcXFwiLCBkb2MsIG9iailcXG4gIGlmIChkb2MuY20pIHsgc2lnbmFsKGRvYy5jbSwgXFxcImJlZm9yZVNlbGVjdGlvbkNoYW5nZVxcXCIsIGRvYy5jbSwgb2JqKSB9XFxuICBpZiAob2JqLnJhbmdlcyAhPSBzZWwucmFuZ2VzKSB7IHJldHVybiBub3JtYWxpemVTZWxlY3Rpb24ob2JqLnJhbmdlcywgb2JqLnJhbmdlcy5sZW5ndGggLSAxKSB9XFxuICBlbHNlIHsgcmV0dXJuIHNlbCB9XFxufVxcblxcbmZ1bmN0aW9uIHNldFNlbGVjdGlvblJlcGxhY2VIaXN0b3J5KGRvYywgc2VsLCBvcHRpb25zKSB7XFxuICB2YXIgZG9uZSA9IGRvYy5oaXN0b3J5LmRvbmUsIGxhc3QgPSBsc3QoZG9uZSlcXG4gIGlmIChsYXN0ICYmIGxhc3QucmFuZ2VzKSB7XFxuICAgIGRvbmVbZG9uZS5sZW5ndGggLSAxXSA9IHNlbFxcbiAgICBzZXRTZWxlY3Rpb25Ob1VuZG8oZG9jLCBzZWwsIG9wdGlvbnMpXFxuICB9IGVsc2Uge1xcbiAgICBzZXRTZWxlY3Rpb24oZG9jLCBzZWwsIG9wdGlvbnMpXFxuICB9XFxufVxcblxcbi8vIFNldCBhIG5ldyBzZWxlY3Rpb24uXFxuZnVuY3Rpb24gc2V0U2VsZWN0aW9uKGRvYywgc2VsLCBvcHRpb25zKSB7XFxuICBzZXRTZWxlY3Rpb25Ob1VuZG8oZG9jLCBzZWwsIG9wdGlvbnMpXFxuICBhZGRTZWxlY3Rpb25Ub0hpc3RvcnkoZG9jLCBkb2Muc2VsLCBkb2MuY20gPyBkb2MuY20uY3VyT3AuaWQgOiBOYU4sIG9wdGlvbnMpXFxufVxcblxcbmZ1bmN0aW9uIHNldFNlbGVjdGlvbk5vVW5kbyhkb2MsIHNlbCwgb3B0aW9ucykge1xcbiAgaWYgKGhhc0hhbmRsZXIoZG9jLCBcXFwiYmVmb3JlU2VsZWN0aW9uQ2hhbmdlXFxcIikgfHwgZG9jLmNtICYmIGhhc0hhbmRsZXIoZG9jLmNtLCBcXFwiYmVmb3JlU2VsZWN0aW9uQ2hhbmdlXFxcIikpXFxuICAgIHsgc2VsID0gZmlsdGVyU2VsZWN0aW9uQ2hhbmdlKGRvYywgc2VsLCBvcHRpb25zKSB9XFxuXFxuICB2YXIgYmlhcyA9IG9wdGlvbnMgJiYgb3B0aW9ucy5iaWFzIHx8XFxuICAgIChjbXAoc2VsLnByaW1hcnkoKS5oZWFkLCBkb2Muc2VsLnByaW1hcnkoKS5oZWFkKSA8IDAgPyAtMSA6IDEpXFxuICBzZXRTZWxlY3Rpb25Jbm5lcihkb2MsIHNraXBBdG9taWNJblNlbGVjdGlvbihkb2MsIHNlbCwgYmlhcywgdHJ1ZSkpXFxuXFxuICBpZiAoIShvcHRpb25zICYmIG9wdGlvbnMuc2Nyb2xsID09PSBmYWxzZSkgJiYgZG9jLmNtKVxcbiAgICB7IGVuc3VyZUN1cnNvclZpc2libGUoZG9jLmNtKSB9XFxufVxcblxcbmZ1bmN0aW9uIHNldFNlbGVjdGlvbklubmVyKGRvYywgc2VsKSB7XFxuICBpZiAoc2VsLmVxdWFscyhkb2Muc2VsKSkgeyByZXR1cm4gfVxcblxcbiAgZG9jLnNlbCA9IHNlbFxcblxcbiAgaWYgKGRvYy5jbSkge1xcbiAgICBkb2MuY20uY3VyT3AudXBkYXRlSW5wdXQgPSBkb2MuY20uY3VyT3Auc2VsZWN0aW9uQ2hhbmdlZCA9IHRydWVcXG4gICAgc2lnbmFsQ3Vyc29yQWN0aXZpdHkoZG9jLmNtKVxcbiAgfVxcbiAgc2lnbmFsTGF0ZXIoZG9jLCBcXFwiY3Vyc29yQWN0aXZpdHlcXFwiLCBkb2MpXFxufVxcblxcbi8vIFZlcmlmeSB0aGF0IHRoZSBzZWxlY3Rpb24gZG9lcyBub3QgcGFydGlhbGx5IHNlbGVjdCBhbnkgYXRvbWljXFxuLy8gbWFya2VkIHJhbmdlcy5cXG5mdW5jdGlvbiByZUNoZWNrU2VsZWN0aW9uKGRvYykge1xcbiAgc2V0U2VsZWN0aW9uSW5uZXIoZG9jLCBza2lwQXRvbWljSW5TZWxlY3Rpb24oZG9jLCBkb2Muc2VsLCBudWxsLCBmYWxzZSksIHNlbF9kb250U2Nyb2xsKVxcbn1cXG5cXG4vLyBSZXR1cm4gYSBzZWxlY3Rpb24gdGhhdCBkb2VzIG5vdCBwYXJ0aWFsbHkgc2VsZWN0IGFueSBhdG9taWNcXG4vLyByYW5nZXMuXFxuZnVuY3Rpb24gc2tpcEF0b21pY0luU2VsZWN0aW9uKGRvYywgc2VsLCBiaWFzLCBtYXlDbGVhcikge1xcbiAgdmFyIG91dFxcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWwucmFuZ2VzLmxlbmd0aDsgaSsrKSB7XFxuICAgIHZhciByYW5nZSA9IHNlbC5yYW5nZXNbaV1cXG4gICAgdmFyIG9sZCA9IHNlbC5yYW5nZXMubGVuZ3RoID09IGRvYy5zZWwucmFuZ2VzLmxlbmd0aCAmJiBkb2Muc2VsLnJhbmdlc1tpXVxcbiAgICB2YXIgbmV3QW5jaG9yID0gc2tpcEF0b21pYyhkb2MsIHJhbmdlLmFuY2hvciwgb2xkICYmIG9sZC5hbmNob3IsIGJpYXMsIG1heUNsZWFyKVxcbiAgICB2YXIgbmV3SGVhZCA9IHNraXBBdG9taWMoZG9jLCByYW5nZS5oZWFkLCBvbGQgJiYgb2xkLmhlYWQsIGJpYXMsIG1heUNsZWFyKVxcbiAgICBpZiAob3V0IHx8IG5ld0FuY2hvciAhPSByYW5nZS5hbmNob3IgfHwgbmV3SGVhZCAhPSByYW5nZS5oZWFkKSB7XFxuICAgICAgaWYgKCFvdXQpIHsgb3V0ID0gc2VsLnJhbmdlcy5zbGljZSgwLCBpKSB9XFxuICAgICAgb3V0W2ldID0gbmV3IFJhbmdlKG5ld0FuY2hvciwgbmV3SGVhZClcXG4gICAgfVxcbiAgfVxcbiAgcmV0dXJuIG91dCA/IG5vcm1hbGl6ZVNlbGVjdGlvbihvdXQsIHNlbC5wcmltSW5kZXgpIDogc2VsXFxufVxcblxcbmZ1bmN0aW9uIHNraXBBdG9taWNJbm5lcihkb2MsIHBvcywgb2xkUG9zLCBkaXIsIG1heUNsZWFyKSB7XFxuICB2YXIgbGluZSA9IGdldExpbmUoZG9jLCBwb3MubGluZSlcXG4gIGlmIChsaW5lLm1hcmtlZFNwYW5zKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgbGluZS5tYXJrZWRTcGFucy5sZW5ndGg7ICsraSkge1xcbiAgICB2YXIgc3AgPSBsaW5lLm1hcmtlZFNwYW5zW2ldLCBtID0gc3AubWFya2VyXFxuICAgIGlmICgoc3AuZnJvbSA9PSBudWxsIHx8IChtLmluY2x1c2l2ZUxlZnQgPyBzcC5mcm9tIDw9IHBvcy5jaCA6IHNwLmZyb20gPCBwb3MuY2gpKSAmJlxcbiAgICAgICAgKHNwLnRvID09IG51bGwgfHwgKG0uaW5jbHVzaXZlUmlnaHQgPyBzcC50byA+PSBwb3MuY2ggOiBzcC50byA+IHBvcy5jaCkpKSB7XFxuICAgICAgaWYgKG1heUNsZWFyKSB7XFxuICAgICAgICBzaWduYWwobSwgXFxcImJlZm9yZUN1cnNvckVudGVyXFxcIilcXG4gICAgICAgIGlmIChtLmV4cGxpY2l0bHlDbGVhcmVkKSB7XFxuICAgICAgICAgIGlmICghbGluZS5tYXJrZWRTcGFucykgeyBicmVhayB9XFxuICAgICAgICAgIGVsc2Ugey0taTsgY29udGludWV9XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICAgIGlmICghbS5hdG9taWMpIHsgY29udGludWUgfVxcblxcbiAgICAgIGlmIChvbGRQb3MpIHtcXG4gICAgICAgIHZhciBuZWFyID0gbS5maW5kKGRpciA8IDAgPyAxIDogLTEpLCBkaWZmID0gdm9pZCAwXFxuICAgICAgICBpZiAoZGlyIDwgMCA/IG0uaW5jbHVzaXZlUmlnaHQgOiBtLmluY2x1c2l2ZUxlZnQpXFxuICAgICAgICAgIHsgbmVhciA9IG1vdmVQb3MoZG9jLCBuZWFyLCAtZGlyLCBuZWFyICYmIG5lYXIubGluZSA9PSBwb3MubGluZSA/IGxpbmUgOiBudWxsKSB9XFxuICAgICAgICBpZiAobmVhciAmJiBuZWFyLmxpbmUgPT0gcG9zLmxpbmUgJiYgKGRpZmYgPSBjbXAobmVhciwgb2xkUG9zKSkgJiYgKGRpciA8IDAgPyBkaWZmIDwgMCA6IGRpZmYgPiAwKSlcXG4gICAgICAgICAgeyByZXR1cm4gc2tpcEF0b21pY0lubmVyKGRvYywgbmVhciwgcG9zLCBkaXIsIG1heUNsZWFyKSB9XFxuICAgICAgfVxcblxcbiAgICAgIHZhciBmYXIgPSBtLmZpbmQoZGlyIDwgMCA/IC0xIDogMSlcXG4gICAgICBpZiAoZGlyIDwgMCA/IG0uaW5jbHVzaXZlTGVmdCA6IG0uaW5jbHVzaXZlUmlnaHQpXFxuICAgICAgICB7IGZhciA9IG1vdmVQb3MoZG9jLCBmYXIsIGRpciwgZmFyLmxpbmUgPT0gcG9zLmxpbmUgPyBsaW5lIDogbnVsbCkgfVxcbiAgICAgIHJldHVybiBmYXIgPyBza2lwQXRvbWljSW5uZXIoZG9jLCBmYXIsIHBvcywgZGlyLCBtYXlDbGVhcikgOiBudWxsXFxuICAgIH1cXG4gIH0gfVxcbiAgcmV0dXJuIHBvc1xcbn1cXG5cXG4vLyBFbnN1cmUgYSBnaXZlbiBwb3NpdGlvbiBpcyBub3QgaW5zaWRlIGFuIGF0b21pYyByYW5nZS5cXG5mdW5jdGlvbiBza2lwQXRvbWljKGRvYywgcG9zLCBvbGRQb3MsIGJpYXMsIG1heUNsZWFyKSB7XFxuICB2YXIgZGlyID0gYmlhcyB8fCAxXFxuICB2YXIgZm91bmQgPSBza2lwQXRvbWljSW5uZXIoZG9jLCBwb3MsIG9sZFBvcywgZGlyLCBtYXlDbGVhcikgfHxcXG4gICAgICAoIW1heUNsZWFyICYmIHNraXBBdG9taWNJbm5lcihkb2MsIHBvcywgb2xkUG9zLCBkaXIsIHRydWUpKSB8fFxcbiAgICAgIHNraXBBdG9taWNJbm5lcihkb2MsIHBvcywgb2xkUG9zLCAtZGlyLCBtYXlDbGVhcikgfHxcXG4gICAgICAoIW1heUNsZWFyICYmIHNraXBBdG9taWNJbm5lcihkb2MsIHBvcywgb2xkUG9zLCAtZGlyLCB0cnVlKSlcXG4gIGlmICghZm91bmQpIHtcXG4gICAgZG9jLmNhbnRFZGl0ID0gdHJ1ZVxcbiAgICByZXR1cm4gUG9zKGRvYy5maXJzdCwgMClcXG4gIH1cXG4gIHJldHVybiBmb3VuZFxcbn1cXG5cXG5mdW5jdGlvbiBtb3ZlUG9zKGRvYywgcG9zLCBkaXIsIGxpbmUpIHtcXG4gIGlmIChkaXIgPCAwICYmIHBvcy5jaCA9PSAwKSB7XFxuICAgIGlmIChwb3MubGluZSA+IGRvYy5maXJzdCkgeyByZXR1cm4gY2xpcFBvcyhkb2MsIFBvcyhwb3MubGluZSAtIDEpKSB9XFxuICAgIGVsc2UgeyByZXR1cm4gbnVsbCB9XFxuICB9IGVsc2UgaWYgKGRpciA+IDAgJiYgcG9zLmNoID09IChsaW5lIHx8IGdldExpbmUoZG9jLCBwb3MubGluZSkpLnRleHQubGVuZ3RoKSB7XFxuICAgIGlmIChwb3MubGluZSA8IGRvYy5maXJzdCArIGRvYy5zaXplIC0gMSkgeyByZXR1cm4gUG9zKHBvcy5saW5lICsgMSwgMCkgfVxcbiAgICBlbHNlIHsgcmV0dXJuIG51bGwgfVxcbiAgfSBlbHNlIHtcXG4gICAgcmV0dXJuIG5ldyBQb3MocG9zLmxpbmUsIHBvcy5jaCArIGRpcilcXG4gIH1cXG59XFxuXFxuZnVuY3Rpb24gc2VsZWN0QWxsKGNtKSB7XFxuICBjbS5zZXRTZWxlY3Rpb24oUG9zKGNtLmZpcnN0TGluZSgpLCAwKSwgUG9zKGNtLmxhc3RMaW5lKCkpLCBzZWxfZG9udFNjcm9sbClcXG59XFxuXFxuLy8gVVBEQVRJTkdcXG5cXG4vLyBBbGxvdyBcXFwiYmVmb3JlQ2hhbmdlXFxcIiBldmVudCBoYW5kbGVycyB0byBpbmZsdWVuY2UgYSBjaGFuZ2VcXG5mdW5jdGlvbiBmaWx0ZXJDaGFuZ2UoZG9jLCBjaGFuZ2UsIHVwZGF0ZSkge1xcbiAgdmFyIG9iaiA9IHtcXG4gICAgY2FuY2VsZWQ6IGZhbHNlLFxcbiAgICBmcm9tOiBjaGFuZ2UuZnJvbSxcXG4gICAgdG86IGNoYW5nZS50byxcXG4gICAgdGV4dDogY2hhbmdlLnRleHQsXFxuICAgIG9yaWdpbjogY2hhbmdlLm9yaWdpbixcXG4gICAgY2FuY2VsOiBmdW5jdGlvbiAoKSB7IHJldHVybiBvYmouY2FuY2VsZWQgPSB0cnVlOyB9XFxuICB9XFxuICBpZiAodXBkYXRlKSB7IG9iai51cGRhdGUgPSBmdW5jdGlvbiAoZnJvbSwgdG8sIHRleHQsIG9yaWdpbikge1xcbiAgICBpZiAoZnJvbSkgeyBvYmouZnJvbSA9IGNsaXBQb3MoZG9jLCBmcm9tKSB9XFxuICAgIGlmICh0bykgeyBvYmoudG8gPSBjbGlwUG9zKGRvYywgdG8pIH1cXG4gICAgaWYgKHRleHQpIHsgb2JqLnRleHQgPSB0ZXh0IH1cXG4gICAgaWYgKG9yaWdpbiAhPT0gdW5kZWZpbmVkKSB7IG9iai5vcmlnaW4gPSBvcmlnaW4gfVxcbiAgfSB9XFxuICBzaWduYWwoZG9jLCBcXFwiYmVmb3JlQ2hhbmdlXFxcIiwgZG9jLCBvYmopXFxuICBpZiAoZG9jLmNtKSB7IHNpZ25hbChkb2MuY20sIFxcXCJiZWZvcmVDaGFuZ2VcXFwiLCBkb2MuY20sIG9iaikgfVxcblxcbiAgaWYgKG9iai5jYW5jZWxlZCkgeyByZXR1cm4gbnVsbCB9XFxuICByZXR1cm4ge2Zyb206IG9iai5mcm9tLCB0bzogb2JqLnRvLCB0ZXh0OiBvYmoudGV4dCwgb3JpZ2luOiBvYmoub3JpZ2lufVxcbn1cXG5cXG4vLyBBcHBseSBhIGNoYW5nZSB0byBhIGRvY3VtZW50LCBhbmQgYWRkIGl0IHRvIHRoZSBkb2N1bWVudCdzXFxuLy8gaGlzdG9yeSwgYW5kIHByb3BhZ2F0aW5nIGl0IHRvIGFsbCBsaW5rZWQgZG9jdW1lbnRzLlxcbmZ1bmN0aW9uIG1ha2VDaGFuZ2UoZG9jLCBjaGFuZ2UsIGlnbm9yZVJlYWRPbmx5KSB7XFxuICBpZiAoZG9jLmNtKSB7XFxuICAgIGlmICghZG9jLmNtLmN1ck9wKSB7IHJldHVybiBvcGVyYXRpb24oZG9jLmNtLCBtYWtlQ2hhbmdlKShkb2MsIGNoYW5nZSwgaWdub3JlUmVhZE9ubHkpIH1cXG4gICAgaWYgKGRvYy5jbS5zdGF0ZS5zdXBwcmVzc0VkaXRzKSB7IHJldHVybiB9XFxuICB9XFxuXFxuICBpZiAoaGFzSGFuZGxlcihkb2MsIFxcXCJiZWZvcmVDaGFuZ2VcXFwiKSB8fCBkb2MuY20gJiYgaGFzSGFuZGxlcihkb2MuY20sIFxcXCJiZWZvcmVDaGFuZ2VcXFwiKSkge1xcbiAgICBjaGFuZ2UgPSBmaWx0ZXJDaGFuZ2UoZG9jLCBjaGFuZ2UsIHRydWUpXFxuICAgIGlmICghY2hhbmdlKSB7IHJldHVybiB9XFxuICB9XFxuXFxuICAvLyBQb3NzaWJseSBzcGxpdCBvciBzdXBwcmVzcyB0aGUgdXBkYXRlIGJhc2VkIG9uIHRoZSBwcmVzZW5jZVxcbiAgLy8gb2YgcmVhZC1vbmx5IHNwYW5zIGluIGl0cyByYW5nZS5cXG4gIHZhciBzcGxpdCA9IHNhd1JlYWRPbmx5U3BhbnMgJiYgIWlnbm9yZVJlYWRPbmx5ICYmIHJlbW92ZVJlYWRPbmx5UmFuZ2VzKGRvYywgY2hhbmdlLmZyb20sIGNoYW5nZS50bylcXG4gIGlmIChzcGxpdCkge1xcbiAgICBmb3IgKHZhciBpID0gc3BsaXQubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpXFxuICAgICAgeyBtYWtlQ2hhbmdlSW5uZXIoZG9jLCB7ZnJvbTogc3BsaXRbaV0uZnJvbSwgdG86IHNwbGl0W2ldLnRvLCB0ZXh0OiBpID8gW1xcXCJcXFwiXSA6IGNoYW5nZS50ZXh0fSkgfVxcbiAgfSBlbHNlIHtcXG4gICAgbWFrZUNoYW5nZUlubmVyKGRvYywgY2hhbmdlKVxcbiAgfVxcbn1cXG5cXG5mdW5jdGlvbiBtYWtlQ2hhbmdlSW5uZXIoZG9jLCBjaGFuZ2UpIHtcXG4gIGlmIChjaGFuZ2UudGV4dC5sZW5ndGggPT0gMSAmJiBjaGFuZ2UudGV4dFswXSA9PSBcXFwiXFxcIiAmJiBjbXAoY2hhbmdlLmZyb20sIGNoYW5nZS50bykgPT0gMCkgeyByZXR1cm4gfVxcbiAgdmFyIHNlbEFmdGVyID0gY29tcHV0ZVNlbEFmdGVyQ2hhbmdlKGRvYywgY2hhbmdlKVxcbiAgYWRkQ2hhbmdlVG9IaXN0b3J5KGRvYywgY2hhbmdlLCBzZWxBZnRlciwgZG9jLmNtID8gZG9jLmNtLmN1ck9wLmlkIDogTmFOKVxcblxcbiAgbWFrZUNoYW5nZVNpbmdsZURvYyhkb2MsIGNoYW5nZSwgc2VsQWZ0ZXIsIHN0cmV0Y2hTcGFuc092ZXJDaGFuZ2UoZG9jLCBjaGFuZ2UpKVxcbiAgdmFyIHJlYmFzZWQgPSBbXVxcblxcbiAgbGlua2VkRG9jcyhkb2MsIGZ1bmN0aW9uIChkb2MsIHNoYXJlZEhpc3QpIHtcXG4gICAgaWYgKCFzaGFyZWRIaXN0ICYmIGluZGV4T2YocmViYXNlZCwgZG9jLmhpc3RvcnkpID09IC0xKSB7XFxuICAgICAgcmViYXNlSGlzdChkb2MuaGlzdG9yeSwgY2hhbmdlKVxcbiAgICAgIHJlYmFzZWQucHVzaChkb2MuaGlzdG9yeSlcXG4gICAgfVxcbiAgICBtYWtlQ2hhbmdlU2luZ2xlRG9jKGRvYywgY2hhbmdlLCBudWxsLCBzdHJldGNoU3BhbnNPdmVyQ2hhbmdlKGRvYywgY2hhbmdlKSlcXG4gIH0pXFxufVxcblxcbi8vIFJldmVydCBhIGNoYW5nZSBzdG9yZWQgaW4gYSBkb2N1bWVudCdzIGhpc3RvcnkuXFxuZnVuY3Rpb24gbWFrZUNoYW5nZUZyb21IaXN0b3J5KGRvYywgdHlwZSwgYWxsb3dTZWxlY3Rpb25Pbmx5KSB7XFxuICBpZiAoZG9jLmNtICYmIGRvYy5jbS5zdGF0ZS5zdXBwcmVzc0VkaXRzICYmICFhbGxvd1NlbGVjdGlvbk9ubHkpIHsgcmV0dXJuIH1cXG5cXG4gIHZhciBoaXN0ID0gZG9jLmhpc3RvcnksIGV2ZW50LCBzZWxBZnRlciA9IGRvYy5zZWxcXG4gIHZhciBzb3VyY2UgPSB0eXBlID09IFxcXCJ1bmRvXFxcIiA/IGhpc3QuZG9uZSA6IGhpc3QudW5kb25lLCBkZXN0ID0gdHlwZSA9PSBcXFwidW5kb1xcXCIgPyBoaXN0LnVuZG9uZSA6IGhpc3QuZG9uZVxcblxcbiAgLy8gVmVyaWZ5IHRoYXQgdGhlcmUgaXMgYSB1c2VhYmxlIGV2ZW50IChzbyB0aGF0IGN0cmwteiB3b24ndFxcbiAgLy8gbmVlZGxlc3NseSBjbGVhciBzZWxlY3Rpb24gZXZlbnRzKVxcbiAgdmFyIGkgPSAwXFxuICBmb3IgKDsgaSA8IHNvdXJjZS5sZW5ndGg7IGkrKykge1xcbiAgICBldmVudCA9IHNvdXJjZVtpXVxcbiAgICBpZiAoYWxsb3dTZWxlY3Rpb25Pbmx5ID8gZXZlbnQucmFuZ2VzICYmICFldmVudC5lcXVhbHMoZG9jLnNlbCkgOiAhZXZlbnQucmFuZ2VzKVxcbiAgICAgIHsgYnJlYWsgfVxcbiAgfVxcbiAgaWYgKGkgPT0gc291cmNlLmxlbmd0aCkgeyByZXR1cm4gfVxcbiAgaGlzdC5sYXN0T3JpZ2luID0gaGlzdC5sYXN0U2VsT3JpZ2luID0gbnVsbFxcblxcbiAgZm9yICg7Oykge1xcbiAgICBldmVudCA9IHNvdXJjZS5wb3AoKVxcbiAgICBpZiAoZXZlbnQucmFuZ2VzKSB7XFxuICAgICAgcHVzaFNlbGVjdGlvblRvSGlzdG9yeShldmVudCwgZGVzdClcXG4gICAgICBpZiAoYWxsb3dTZWxlY3Rpb25Pbmx5ICYmICFldmVudC5lcXVhbHMoZG9jLnNlbCkpIHtcXG4gICAgICAgIHNldFNlbGVjdGlvbihkb2MsIGV2ZW50LCB7Y2xlYXJSZWRvOiBmYWxzZX0pXFxuICAgICAgICByZXR1cm5cXG4gICAgICB9XFxuICAgICAgc2VsQWZ0ZXIgPSBldmVudFxcbiAgICB9XFxuICAgIGVsc2UgeyBicmVhayB9XFxuICB9XFxuXFxuICAvLyBCdWlsZCB1cCBhIHJldmVyc2UgY2hhbmdlIG9iamVjdCB0byBhZGQgdG8gdGhlIG9wcG9zaXRlIGhpc3RvcnlcXG4gIC8vIHN0YWNrIChyZWRvIHdoZW4gdW5kb2luZywgYW5kIHZpY2UgdmVyc2EpLlxcbiAgdmFyIGFudGlDaGFuZ2VzID0gW11cXG4gIHB1c2hTZWxlY3Rpb25Ub0hpc3Rvcnkoc2VsQWZ0ZXIsIGRlc3QpXFxuICBkZXN0LnB1c2goe2NoYW5nZXM6IGFudGlDaGFuZ2VzLCBnZW5lcmF0aW9uOiBoaXN0LmdlbmVyYXRpb259KVxcbiAgaGlzdC5nZW5lcmF0aW9uID0gZXZlbnQuZ2VuZXJhdGlvbiB8fCArK2hpc3QubWF4R2VuZXJhdGlvblxcblxcbiAgdmFyIGZpbHRlciA9IGhhc0hhbmRsZXIoZG9jLCBcXFwiYmVmb3JlQ2hhbmdlXFxcIikgfHwgZG9jLmNtICYmIGhhc0hhbmRsZXIoZG9jLmNtLCBcXFwiYmVmb3JlQ2hhbmdlXFxcIilcXG5cXG4gIHZhciBsb29wID0gZnVuY3Rpb24gKCBpICkge1xcbiAgICB2YXIgY2hhbmdlID0gZXZlbnQuY2hhbmdlc1tpXVxcbiAgICBjaGFuZ2Uub3JpZ2luID0gdHlwZVxcbiAgICBpZiAoZmlsdGVyICYmICFmaWx0ZXJDaGFuZ2UoZG9jLCBjaGFuZ2UsIGZhbHNlKSkge1xcbiAgICAgIHNvdXJjZS5sZW5ndGggPSAwXFxuICAgICAgcmV0dXJuIHt9XFxuICAgIH1cXG5cXG4gICAgYW50aUNoYW5nZXMucHVzaChoaXN0b3J5Q2hhbmdlRnJvbUNoYW5nZShkb2MsIGNoYW5nZSkpXFxuXFxuICAgIHZhciBhZnRlciA9IGkgPyBjb21wdXRlU2VsQWZ0ZXJDaGFuZ2UoZG9jLCBjaGFuZ2UpIDogbHN0KHNvdXJjZSlcXG4gICAgbWFrZUNoYW5nZVNpbmdsZURvYyhkb2MsIGNoYW5nZSwgYWZ0ZXIsIG1lcmdlT2xkU3BhbnMoZG9jLCBjaGFuZ2UpKVxcbiAgICBpZiAoIWkgJiYgZG9jLmNtKSB7IGRvYy5jbS5zY3JvbGxJbnRvVmlldyh7ZnJvbTogY2hhbmdlLmZyb20sIHRvOiBjaGFuZ2VFbmQoY2hhbmdlKX0pIH1cXG4gICAgdmFyIHJlYmFzZWQgPSBbXVxcblxcbiAgICAvLyBQcm9wYWdhdGUgdG8gdGhlIGxpbmtlZCBkb2N1bWVudHNcXG4gICAgbGlua2VkRG9jcyhkb2MsIGZ1bmN0aW9uIChkb2MsIHNoYXJlZEhpc3QpIHtcXG4gICAgICBpZiAoIXNoYXJlZEhpc3QgJiYgaW5kZXhPZihyZWJhc2VkLCBkb2MuaGlzdG9yeSkgPT0gLTEpIHtcXG4gICAgICAgIHJlYmFzZUhpc3QoZG9jLmhpc3RvcnksIGNoYW5nZSlcXG4gICAgICAgIHJlYmFzZWQucHVzaChkb2MuaGlzdG9yeSlcXG4gICAgICB9XFxuICAgICAgbWFrZUNoYW5nZVNpbmdsZURvYyhkb2MsIGNoYW5nZSwgbnVsbCwgbWVyZ2VPbGRTcGFucyhkb2MsIGNoYW5nZSkpXFxuICAgIH0pXFxuICB9O1xcblxcbiAgZm9yICh2YXIgaSQxID0gZXZlbnQuY2hhbmdlcy5sZW5ndGggLSAxOyBpJDEgPj0gMDsgLS1pJDEpIHtcXG4gICAgdmFyIHJldHVybmVkID0gbG9vcCggaSQxICk7XFxuXFxuICAgIGlmICggcmV0dXJuZWQgKSByZXR1cm4gcmV0dXJuZWQudjtcXG4gIH1cXG59XFxuXFxuLy8gU3ViLXZpZXdzIG5lZWQgdGhlaXIgbGluZSBudW1iZXJzIHNoaWZ0ZWQgd2hlbiB0ZXh0IGlzIGFkZGVkXFxuLy8gYWJvdmUgb3IgYmVsb3cgdGhlbSBpbiB0aGUgcGFyZW50IGRvY3VtZW50LlxcbmZ1bmN0aW9uIHNoaWZ0RG9jKGRvYywgZGlzdGFuY2UpIHtcXG4gIGlmIChkaXN0YW5jZSA9PSAwKSB7IHJldHVybiB9XFxuICBkb2MuZmlyc3QgKz0gZGlzdGFuY2VcXG4gIGRvYy5zZWwgPSBuZXcgU2VsZWN0aW9uKG1hcChkb2Muc2VsLnJhbmdlcywgZnVuY3Rpb24gKHJhbmdlKSB7IHJldHVybiBuZXcgUmFuZ2UoXFxuICAgIFBvcyhyYW5nZS5hbmNob3IubGluZSArIGRpc3RhbmNlLCByYW5nZS5hbmNob3IuY2gpLFxcbiAgICBQb3MocmFuZ2UuaGVhZC5saW5lICsgZGlzdGFuY2UsIHJhbmdlLmhlYWQuY2gpXFxuICApOyB9KSwgZG9jLnNlbC5wcmltSW5kZXgpXFxuICBpZiAoZG9jLmNtKSB7XFxuICAgIHJlZ0NoYW5nZShkb2MuY20sIGRvYy5maXJzdCwgZG9jLmZpcnN0IC0gZGlzdGFuY2UsIGRpc3RhbmNlKVxcbiAgICBmb3IgKHZhciBkID0gZG9jLmNtLmRpc3BsYXksIGwgPSBkLnZpZXdGcm9tOyBsIDwgZC52aWV3VG87IGwrKylcXG4gICAgICB7IHJlZ0xpbmVDaGFuZ2UoZG9jLmNtLCBsLCBcXFwiZ3V0dGVyXFxcIikgfVxcbiAgfVxcbn1cXG5cXG4vLyBNb3JlIGxvd2VyLWxldmVsIGNoYW5nZSBmdW5jdGlvbiwgaGFuZGxpbmcgb25seSBhIHNpbmdsZSBkb2N1bWVudFxcbi8vIChub3QgbGlua2VkIG9uZXMpLlxcbmZ1bmN0aW9uIG1ha2VDaGFuZ2VTaW5nbGVEb2MoZG9jLCBjaGFuZ2UsIHNlbEFmdGVyLCBzcGFucykge1xcbiAgaWYgKGRvYy5jbSAmJiAhZG9jLmNtLmN1ck9wKVxcbiAgICB7IHJldHVybiBvcGVyYXRpb24oZG9jLmNtLCBtYWtlQ2hhbmdlU2luZ2xlRG9jKShkb2MsIGNoYW5nZSwgc2VsQWZ0ZXIsIHNwYW5zKSB9XFxuXFxuICBpZiAoY2hhbmdlLnRvLmxpbmUgPCBkb2MuZmlyc3QpIHtcXG4gICAgc2hpZnREb2MoZG9jLCBjaGFuZ2UudGV4dC5sZW5ndGggLSAxIC0gKGNoYW5nZS50by5saW5lIC0gY2hhbmdlLmZyb20ubGluZSkpXFxuICAgIHJldHVyblxcbiAgfVxcbiAgaWYgKGNoYW5nZS5mcm9tLmxpbmUgPiBkb2MubGFzdExpbmUoKSkgeyByZXR1cm4gfVxcblxcbiAgLy8gQ2xpcCB0aGUgY2hhbmdlIHRvIHRoZSBzaXplIG9mIHRoaXMgZG9jXFxuICBpZiAoY2hhbmdlLmZyb20ubGluZSA8IGRvYy5maXJzdCkge1xcbiAgICB2YXIgc2hpZnQgPSBjaGFuZ2UudGV4dC5sZW5ndGggLSAxIC0gKGRvYy5maXJzdCAtIGNoYW5nZS5mcm9tLmxpbmUpXFxuICAgIHNoaWZ0RG9jKGRvYywgc2hpZnQpXFxuICAgIGNoYW5nZSA9IHtmcm9tOiBQb3MoZG9jLmZpcnN0LCAwKSwgdG86IFBvcyhjaGFuZ2UudG8ubGluZSArIHNoaWZ0LCBjaGFuZ2UudG8uY2gpLFxcbiAgICAgICAgICAgICAgdGV4dDogW2xzdChjaGFuZ2UudGV4dCldLCBvcmlnaW46IGNoYW5nZS5vcmlnaW59XFxuICB9XFxuICB2YXIgbGFzdCA9IGRvYy5sYXN0TGluZSgpXFxuICBpZiAoY2hhbmdlLnRvLmxpbmUgPiBsYXN0KSB7XFxuICAgIGNoYW5nZSA9IHtmcm9tOiBjaGFuZ2UuZnJvbSwgdG86IFBvcyhsYXN0LCBnZXRMaW5lKGRvYywgbGFzdCkudGV4dC5sZW5ndGgpLFxcbiAgICAgICAgICAgICAgdGV4dDogW2NoYW5nZS50ZXh0WzBdXSwgb3JpZ2luOiBjaGFuZ2Uub3JpZ2lufVxcbiAgfVxcblxcbiAgY2hhbmdlLnJlbW92ZWQgPSBnZXRCZXR3ZWVuKGRvYywgY2hhbmdlLmZyb20sIGNoYW5nZS50bylcXG5cXG4gIGlmICghc2VsQWZ0ZXIpIHsgc2VsQWZ0ZXIgPSBjb21wdXRlU2VsQWZ0ZXJDaGFuZ2UoZG9jLCBjaGFuZ2UpIH1cXG4gIGlmIChkb2MuY20pIHsgbWFrZUNoYW5nZVNpbmdsZURvY0luRWRpdG9yKGRvYy5jbSwgY2hhbmdlLCBzcGFucykgfVxcbiAgZWxzZSB7IHVwZGF0ZURvYyhkb2MsIGNoYW5nZSwgc3BhbnMpIH1cXG4gIHNldFNlbGVjdGlvbk5vVW5kbyhkb2MsIHNlbEFmdGVyLCBzZWxfZG9udFNjcm9sbClcXG59XFxuXFxuLy8gSGFuZGxlIHRoZSBpbnRlcmFjdGlvbiBvZiBhIGNoYW5nZSB0byBhIGRvY3VtZW50IHdpdGggdGhlIGVkaXRvclxcbi8vIHRoYXQgdGhpcyBkb2N1bWVudCBpcyBwYXJ0IG9mLlxcbmZ1bmN0aW9uIG1ha2VDaGFuZ2VTaW5nbGVEb2NJbkVkaXRvcihjbSwgY2hhbmdlLCBzcGFucykge1xcbiAgdmFyIGRvYyA9IGNtLmRvYywgZGlzcGxheSA9IGNtLmRpc3BsYXksIGZyb20gPSBjaGFuZ2UuZnJvbSwgdG8gPSBjaGFuZ2UudG9cXG5cXG4gIHZhciByZWNvbXB1dGVNYXhMZW5ndGggPSBmYWxzZSwgY2hlY2tXaWR0aFN0YXJ0ID0gZnJvbS5saW5lXFxuICBpZiAoIWNtLm9wdGlvbnMubGluZVdyYXBwaW5nKSB7XFxuICAgIGNoZWNrV2lkdGhTdGFydCA9IGxpbmVObyh2aXN1YWxMaW5lKGdldExpbmUoZG9jLCBmcm9tLmxpbmUpKSlcXG4gICAgZG9jLml0ZXIoY2hlY2tXaWR0aFN0YXJ0LCB0by5saW5lICsgMSwgZnVuY3Rpb24gKGxpbmUpIHtcXG4gICAgICBpZiAobGluZSA9PSBkaXNwbGF5Lm1heExpbmUpIHtcXG4gICAgICAgIHJlY29tcHV0ZU1heExlbmd0aCA9IHRydWVcXG4gICAgICAgIHJldHVybiB0cnVlXFxuICAgICAgfVxcbiAgICB9KVxcbiAgfVxcblxcbiAgaWYgKGRvYy5zZWwuY29udGFpbnMoY2hhbmdlLmZyb20sIGNoYW5nZS50bykgPiAtMSlcXG4gICAgeyBzaWduYWxDdXJzb3JBY3Rpdml0eShjbSkgfVxcblxcbiAgdXBkYXRlRG9jKGRvYywgY2hhbmdlLCBzcGFucywgZXN0aW1hdGVIZWlnaHQoY20pKVxcblxcbiAgaWYgKCFjbS5vcHRpb25zLmxpbmVXcmFwcGluZykge1xcbiAgICBkb2MuaXRlcihjaGVja1dpZHRoU3RhcnQsIGZyb20ubGluZSArIGNoYW5nZS50ZXh0Lmxlbmd0aCwgZnVuY3Rpb24gKGxpbmUpIHtcXG4gICAgICB2YXIgbGVuID0gbGluZUxlbmd0aChsaW5lKVxcbiAgICAgIGlmIChsZW4gPiBkaXNwbGF5Lm1heExpbmVMZW5ndGgpIHtcXG4gICAgICAgIGRpc3BsYXkubWF4TGluZSA9IGxpbmVcXG4gICAgICAgIGRpc3BsYXkubWF4TGluZUxlbmd0aCA9IGxlblxcbiAgICAgICAgZGlzcGxheS5tYXhMaW5lQ2hhbmdlZCA9IHRydWVcXG4gICAgICAgIHJlY29tcHV0ZU1heExlbmd0aCA9IGZhbHNlXFxuICAgICAgfVxcbiAgICB9KVxcbiAgICBpZiAocmVjb21wdXRlTWF4TGVuZ3RoKSB7IGNtLmN1ck9wLnVwZGF0ZU1heExpbmUgPSB0cnVlIH1cXG4gIH1cXG5cXG4gIC8vIEFkanVzdCBmcm9udGllciwgc2NoZWR1bGUgd29ya2VyXFxuICBkb2MuZnJvbnRpZXIgPSBNYXRoLm1pbihkb2MuZnJvbnRpZXIsIGZyb20ubGluZSlcXG4gIHN0YXJ0V29ya2VyKGNtLCA0MDApXFxuXFxuICB2YXIgbGVuZGlmZiA9IGNoYW5nZS50ZXh0Lmxlbmd0aCAtICh0by5saW5lIC0gZnJvbS5saW5lKSAtIDFcXG4gIC8vIFJlbWVtYmVyIHRoYXQgdGhlc2UgbGluZXMgY2hhbmdlZCwgZm9yIHVwZGF0aW5nIHRoZSBkaXNwbGF5XFxuICBpZiAoY2hhbmdlLmZ1bGwpXFxuICAgIHsgcmVnQ2hhbmdlKGNtKSB9XFxuICBlbHNlIGlmIChmcm9tLmxpbmUgPT0gdG8ubGluZSAmJiBjaGFuZ2UudGV4dC5sZW5ndGggPT0gMSAmJiAhaXNXaG9sZUxpbmVVcGRhdGUoY20uZG9jLCBjaGFuZ2UpKVxcbiAgICB7IHJlZ0xpbmVDaGFuZ2UoY20sIGZyb20ubGluZSwgXFxcInRleHRcXFwiKSB9XFxuICBlbHNlXFxuICAgIHsgcmVnQ2hhbmdlKGNtLCBmcm9tLmxpbmUsIHRvLmxpbmUgKyAxLCBsZW5kaWZmKSB9XFxuXFxuICB2YXIgY2hhbmdlc0hhbmRsZXIgPSBoYXNIYW5kbGVyKGNtLCBcXFwiY2hhbmdlc1xcXCIpLCBjaGFuZ2VIYW5kbGVyID0gaGFzSGFuZGxlcihjbSwgXFxcImNoYW5nZVxcXCIpXFxuICBpZiAoY2hhbmdlSGFuZGxlciB8fCBjaGFuZ2VzSGFuZGxlcikge1xcbiAgICB2YXIgb2JqID0ge1xcbiAgICAgIGZyb206IGZyb20sIHRvOiB0byxcXG4gICAgICB0ZXh0OiBjaGFuZ2UudGV4dCxcXG4gICAgICByZW1vdmVkOiBjaGFuZ2UucmVtb3ZlZCxcXG4gICAgICBvcmlnaW46IGNoYW5nZS5vcmlnaW5cXG4gICAgfVxcbiAgICBpZiAoY2hhbmdlSGFuZGxlcikgeyBzaWduYWxMYXRlcihjbSwgXFxcImNoYW5nZVxcXCIsIGNtLCBvYmopIH1cXG4gICAgaWYgKGNoYW5nZXNIYW5kbGVyKSB7IChjbS5jdXJPcC5jaGFuZ2VPYmpzIHx8IChjbS5jdXJPcC5jaGFuZ2VPYmpzID0gW10pKS5wdXNoKG9iaikgfVxcbiAgfVxcbiAgY20uZGlzcGxheS5zZWxGb3JDb250ZXh0TWVudSA9IG51bGxcXG59XFxuXFxuZnVuY3Rpb24gcmVwbGFjZVJhbmdlKGRvYywgY29kZSwgZnJvbSwgdG8sIG9yaWdpbikge1xcbiAgaWYgKCF0bykgeyB0byA9IGZyb20gfVxcbiAgaWYgKGNtcCh0bywgZnJvbSkgPCAwKSB7IHZhciB0bXAgPSB0bzsgdG8gPSBmcm9tOyBmcm9tID0gdG1wIH1cXG4gIGlmICh0eXBlb2YgY29kZSA9PSBcXFwic3RyaW5nXFxcIikgeyBjb2RlID0gZG9jLnNwbGl0TGluZXMoY29kZSkgfVxcbiAgbWFrZUNoYW5nZShkb2MsIHtmcm9tOiBmcm9tLCB0bzogdG8sIHRleHQ6IGNvZGUsIG9yaWdpbjogb3JpZ2lufSlcXG59XFxuXFxuLy8gUmViYXNpbmcvcmVzZXR0aW5nIGhpc3RvcnkgdG8gZGVhbCB3aXRoIGV4dGVybmFsbHktc291cmNlZCBjaGFuZ2VzXFxuXFxuZnVuY3Rpb24gcmViYXNlSGlzdFNlbFNpbmdsZShwb3MsIGZyb20sIHRvLCBkaWZmKSB7XFxuICBpZiAodG8gPCBwb3MubGluZSkge1xcbiAgICBwb3MubGluZSArPSBkaWZmXFxuICB9IGVsc2UgaWYgKGZyb20gPCBwb3MubGluZSkge1xcbiAgICBwb3MubGluZSA9IGZyb21cXG4gICAgcG9zLmNoID0gMFxcbiAgfVxcbn1cXG5cXG4vLyBUcmllcyB0byByZWJhc2UgYW4gYXJyYXkgb2YgaGlzdG9yeSBldmVudHMgZ2l2ZW4gYSBjaGFuZ2UgaW4gdGhlXFxuLy8gZG9jdW1lbnQuIElmIHRoZSBjaGFuZ2UgdG91Y2hlcyB0aGUgc2FtZSBsaW5lcyBhcyB0aGUgZXZlbnQsIHRoZVxcbi8vIGV2ZW50LCBhbmQgZXZlcnl0aGluZyAnYmVoaW5kJyBpdCwgaXMgZGlzY2FyZGVkLiBJZiB0aGUgY2hhbmdlIGlzXFxuLy8gYmVmb3JlIHRoZSBldmVudCwgdGhlIGV2ZW50J3MgcG9zaXRpb25zIGFyZSB1cGRhdGVkLiBVc2VzIGFcXG4vLyBjb3B5LW9uLXdyaXRlIHNjaGVtZSBmb3IgdGhlIHBvc2l0aW9ucywgdG8gYXZvaWQgaGF2aW5nIHRvXFxuLy8gcmVhbGxvY2F0ZSB0aGVtIGFsbCBvbiBldmVyeSByZWJhc2UsIGJ1dCBhbHNvIGF2b2lkIHByb2JsZW1zIHdpdGhcXG4vLyBzaGFyZWQgcG9zaXRpb24gb2JqZWN0cyBiZWluZyB1bnNhZmVseSB1cGRhdGVkLlxcbmZ1bmN0aW9uIHJlYmFzZUhpc3RBcnJheShhcnJheSwgZnJvbSwgdG8sIGRpZmYpIHtcXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyArK2kpIHtcXG4gICAgdmFyIHN1YiA9IGFycmF5W2ldLCBvayA9IHRydWVcXG4gICAgaWYgKHN1Yi5yYW5nZXMpIHtcXG4gICAgICBpZiAoIXN1Yi5jb3BpZWQpIHsgc3ViID0gYXJyYXlbaV0gPSBzdWIuZGVlcENvcHkoKTsgc3ViLmNvcGllZCA9IHRydWUgfVxcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgc3ViLnJhbmdlcy5sZW5ndGg7IGorKykge1xcbiAgICAgICAgcmViYXNlSGlzdFNlbFNpbmdsZShzdWIucmFuZ2VzW2pdLmFuY2hvciwgZnJvbSwgdG8sIGRpZmYpXFxuICAgICAgICByZWJhc2VIaXN0U2VsU2luZ2xlKHN1Yi5yYW5nZXNbal0uaGVhZCwgZnJvbSwgdG8sIGRpZmYpXFxuICAgICAgfVxcbiAgICAgIGNvbnRpbnVlXFxuICAgIH1cXG4gICAgZm9yICh2YXIgaiQxID0gMDsgaiQxIDwgc3ViLmNoYW5nZXMubGVuZ3RoOyArK2okMSkge1xcbiAgICAgIHZhciBjdXIgPSBzdWIuY2hhbmdlc1tqJDFdXFxuICAgICAgaWYgKHRvIDwgY3VyLmZyb20ubGluZSkge1xcbiAgICAgICAgY3VyLmZyb20gPSBQb3MoY3VyLmZyb20ubGluZSArIGRpZmYsIGN1ci5mcm9tLmNoKVxcbiAgICAgICAgY3VyLnRvID0gUG9zKGN1ci50by5saW5lICsgZGlmZiwgY3VyLnRvLmNoKVxcbiAgICAgIH0gZWxzZSBpZiAoZnJvbSA8PSBjdXIudG8ubGluZSkge1xcbiAgICAgICAgb2sgPSBmYWxzZVxcbiAgICAgICAgYnJlYWtcXG4gICAgICB9XFxuICAgIH1cXG4gICAgaWYgKCFvaykge1xcbiAgICAgIGFycmF5LnNwbGljZSgwLCBpICsgMSlcXG4gICAgICBpID0gMFxcbiAgICB9XFxuICB9XFxufVxcblxcbmZ1bmN0aW9uIHJlYmFzZUhpc3QoaGlzdCwgY2hhbmdlKSB7XFxuICB2YXIgZnJvbSA9IGNoYW5nZS5mcm9tLmxpbmUsIHRvID0gY2hhbmdlLnRvLmxpbmUsIGRpZmYgPSBjaGFuZ2UudGV4dC5sZW5ndGggLSAodG8gLSBmcm9tKSAtIDFcXG4gIHJlYmFzZUhpc3RBcnJheShoaXN0LmRvbmUsIGZyb20sIHRvLCBkaWZmKVxcbiAgcmViYXNlSGlzdEFycmF5KGhpc3QudW5kb25lLCBmcm9tLCB0bywgZGlmZilcXG59XFxuXFxuLy8gVXRpbGl0eSBmb3IgYXBwbHlpbmcgYSBjaGFuZ2UgdG8gYSBsaW5lIGJ5IGhhbmRsZSBvciBudW1iZXIsXFxuLy8gcmV0dXJuaW5nIHRoZSBudW1iZXIgYW5kIG9wdGlvbmFsbHkgcmVnaXN0ZXJpbmcgdGhlIGxpbmUgYXNcXG4vLyBjaGFuZ2VkLlxcbmZ1bmN0aW9uIGNoYW5nZUxpbmUoZG9jLCBoYW5kbGUsIGNoYW5nZVR5cGUsIG9wKSB7XFxuICB2YXIgbm8gPSBoYW5kbGUsIGxpbmUgPSBoYW5kbGVcXG4gIGlmICh0eXBlb2YgaGFuZGxlID09IFxcXCJudW1iZXJcXFwiKSB7IGxpbmUgPSBnZXRMaW5lKGRvYywgY2xpcExpbmUoZG9jLCBoYW5kbGUpKSB9XFxuICBlbHNlIHsgbm8gPSBsaW5lTm8oaGFuZGxlKSB9XFxuICBpZiAobm8gPT0gbnVsbCkgeyByZXR1cm4gbnVsbCB9XFxuICBpZiAob3AobGluZSwgbm8pICYmIGRvYy5jbSkgeyByZWdMaW5lQ2hhbmdlKGRvYy5jbSwgbm8sIGNoYW5nZVR5cGUpIH1cXG4gIHJldHVybiBsaW5lXFxufVxcblxcbi8vIFRoZSBkb2N1bWVudCBpcyByZXByZXNlbnRlZCBhcyBhIEJUcmVlIGNvbnNpc3Rpbmcgb2YgbGVhdmVzLCB3aXRoXFxuLy8gY2h1bmsgb2YgbGluZXMgaW4gdGhlbSwgYW5kIGJyYW5jaGVzLCB3aXRoIHVwIHRvIHRlbiBsZWF2ZXMgb3JcXG4vLyBvdGhlciBicmFuY2ggbm9kZXMgYmVsb3cgdGhlbS4gVGhlIHRvcCBub2RlIGlzIGFsd2F5cyBhIGJyYW5jaFxcbi8vIG5vZGUsIGFuZCBpcyB0aGUgZG9jdW1lbnQgb2JqZWN0IGl0c2VsZiAobWVhbmluZyBpdCBoYXNcXG4vLyBhZGRpdGlvbmFsIG1ldGhvZHMgYW5kIHByb3BlcnRpZXMpLlxcbi8vXFxuLy8gQWxsIG5vZGVzIGhhdmUgcGFyZW50IGxpbmtzLiBUaGUgdHJlZSBpcyB1c2VkIGJvdGggdG8gZ28gZnJvbVxcbi8vIGxpbmUgbnVtYmVycyB0byBsaW5lIG9iamVjdHMsIGFuZCB0byBnbyBmcm9tIG9iamVjdHMgdG8gbnVtYmVycy5cXG4vLyBJdCBhbHNvIGluZGV4ZXMgYnkgaGVpZ2h0LCBhbmQgaXMgdXNlZCB0byBjb252ZXJ0IGJldHdlZW4gaGVpZ2h0XFxuLy8gYW5kIGxpbmUgb2JqZWN0LCBhbmQgdG8gZmluZCB0aGUgdG90YWwgaGVpZ2h0IG9mIHRoZSBkb2N1bWVudC5cXG4vL1xcbi8vIFNlZSBhbHNvIGh0dHA6Ly9tYXJpam5oYXZlcmJla2UubmwvYmxvZy9jb2RlbWlycm9yLWxpbmUtdHJlZS5odG1sXFxuXFxuZnVuY3Rpb24gTGVhZkNodW5rKGxpbmVzKSB7XFxuICB2YXIgdGhpcyQxID0gdGhpcztcXG5cXG4gIHRoaXMubGluZXMgPSBsaW5lc1xcbiAgdGhpcy5wYXJlbnQgPSBudWxsXFxuICB2YXIgaGVpZ2h0ID0gMFxcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7ICsraSkge1xcbiAgICBsaW5lc1tpXS5wYXJlbnQgPSB0aGlzJDFcXG4gICAgaGVpZ2h0ICs9IGxpbmVzW2ldLmhlaWdodFxcbiAgfVxcbiAgdGhpcy5oZWlnaHQgPSBoZWlnaHRcXG59XFxuXFxuTGVhZkNodW5rLnByb3RvdHlwZSA9IHtcXG4gIGNodW5rU2l6ZTogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLmxpbmVzLmxlbmd0aCB9LFxcbiAgLy8gUmVtb3ZlIHRoZSBuIGxpbmVzIGF0IG9mZnNldCAnYXQnLlxcbiAgcmVtb3ZlSW5uZXI6IGZ1bmN0aW9uKGF0LCBuKSB7XFxuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xcblxcbiAgICBmb3IgKHZhciBpID0gYXQsIGUgPSBhdCArIG47IGkgPCBlOyArK2kpIHtcXG4gICAgICB2YXIgbGluZSA9IHRoaXMkMS5saW5lc1tpXVxcbiAgICAgIHRoaXMkMS5oZWlnaHQgLT0gbGluZS5oZWlnaHRcXG4gICAgICBjbGVhblVwTGluZShsaW5lKVxcbiAgICAgIHNpZ25hbExhdGVyKGxpbmUsIFxcXCJkZWxldGVcXFwiKVxcbiAgICB9XFxuICAgIHRoaXMubGluZXMuc3BsaWNlKGF0LCBuKVxcbiAgfSxcXG4gIC8vIEhlbHBlciB1c2VkIHRvIGNvbGxhcHNlIGEgc21hbGwgYnJhbmNoIGludG8gYSBzaW5nbGUgbGVhZi5cXG4gIGNvbGxhcHNlOiBmdW5jdGlvbihsaW5lcykge1xcbiAgICBsaW5lcy5wdXNoLmFwcGx5KGxpbmVzLCB0aGlzLmxpbmVzKVxcbiAgfSxcXG4gIC8vIEluc2VydCB0aGUgZ2l2ZW4gYXJyYXkgb2YgbGluZXMgYXQgb2Zmc2V0ICdhdCcsIGNvdW50IHRoZW0gYXNcXG4gIC8vIGhhdmluZyB0aGUgZ2l2ZW4gaGVpZ2h0LlxcbiAgaW5zZXJ0SW5uZXI6IGZ1bmN0aW9uKGF0LCBsaW5lcywgaGVpZ2h0KSB7XFxuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xcblxcbiAgICB0aGlzLmhlaWdodCArPSBoZWlnaHRcXG4gICAgdGhpcy5saW5lcyA9IHRoaXMubGluZXMuc2xpY2UoMCwgYXQpLmNvbmNhdChsaW5lcykuY29uY2F0KHRoaXMubGluZXMuc2xpY2UoYXQpKVxcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgKytpKSB7IGxpbmVzW2ldLnBhcmVudCA9IHRoaXMkMSB9XFxuICB9LFxcbiAgLy8gVXNlZCB0byBpdGVyYXRlIG92ZXIgYSBwYXJ0IG9mIHRoZSB0cmVlLlxcbiAgaXRlck46IGZ1bmN0aW9uKGF0LCBuLCBvcCkge1xcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcXG5cXG4gICAgZm9yICh2YXIgZSA9IGF0ICsgbjsgYXQgPCBlOyArK2F0KVxcbiAgICAgIHsgaWYgKG9wKHRoaXMkMS5saW5lc1thdF0pKSB7IHJldHVybiB0cnVlIH0gfVxcbiAgfVxcbn1cXG5cXG5mdW5jdGlvbiBCcmFuY2hDaHVuayhjaGlsZHJlbikge1xcbiAgdmFyIHRoaXMkMSA9IHRoaXM7XFxuXFxuICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW5cXG4gIHZhciBzaXplID0gMCwgaGVpZ2h0ID0gMFxcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7ICsraSkge1xcbiAgICB2YXIgY2ggPSBjaGlsZHJlbltpXVxcbiAgICBzaXplICs9IGNoLmNodW5rU2l6ZSgpOyBoZWlnaHQgKz0gY2guaGVpZ2h0XFxuICAgIGNoLnBhcmVudCA9IHRoaXMkMVxcbiAgfVxcbiAgdGhpcy5zaXplID0gc2l6ZVxcbiAgdGhpcy5oZWlnaHQgPSBoZWlnaHRcXG4gIHRoaXMucGFyZW50ID0gbnVsbFxcbn1cXG5cXG5CcmFuY2hDaHVuay5wcm90b3R5cGUgPSB7XFxuICBjaHVua1NpemU6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5zaXplIH0sXFxuICByZW1vdmVJbm5lcjogZnVuY3Rpb24oYXQsIG4pIHtcXG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XFxuXFxuICAgIHRoaXMuc2l6ZSAtPSBuXFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7ICsraSkge1xcbiAgICAgIHZhciBjaGlsZCA9IHRoaXMkMS5jaGlsZHJlbltpXSwgc3ogPSBjaGlsZC5jaHVua1NpemUoKVxcbiAgICAgIGlmIChhdCA8IHN6KSB7XFxuICAgICAgICB2YXIgcm0gPSBNYXRoLm1pbihuLCBzeiAtIGF0KSwgb2xkSGVpZ2h0ID0gY2hpbGQuaGVpZ2h0XFxuICAgICAgICBjaGlsZC5yZW1vdmVJbm5lcihhdCwgcm0pXFxuICAgICAgICB0aGlzJDEuaGVpZ2h0IC09IG9sZEhlaWdodCAtIGNoaWxkLmhlaWdodFxcbiAgICAgICAgaWYgKHN6ID09IHJtKSB7IHRoaXMkMS5jaGlsZHJlbi5zcGxpY2UoaS0tLCAxKTsgY2hpbGQucGFyZW50ID0gbnVsbCB9XFxuICAgICAgICBpZiAoKG4gLT0gcm0pID09IDApIHsgYnJlYWsgfVxcbiAgICAgICAgYXQgPSAwXFxuICAgICAgfSBlbHNlIHsgYXQgLT0gc3ogfVxcbiAgICB9XFxuICAgIC8vIElmIHRoZSByZXN1bHQgaXMgc21hbGxlciB0aGFuIDI1IGxpbmVzLCBlbnN1cmUgdGhhdCBpdCBpcyBhXFxuICAgIC8vIHNpbmdsZSBsZWFmIG5vZGUuXFxuICAgIGlmICh0aGlzLnNpemUgLSBuIDwgMjUgJiZcXG4gICAgICAgICh0aGlzLmNoaWxkcmVuLmxlbmd0aCA+IDEgfHwgISh0aGlzLmNoaWxkcmVuWzBdIGluc3RhbmNlb2YgTGVhZkNodW5rKSkpIHtcXG4gICAgICB2YXIgbGluZXMgPSBbXVxcbiAgICAgIHRoaXMuY29sbGFwc2UobGluZXMpXFxuICAgICAgdGhpcy5jaGlsZHJlbiA9IFtuZXcgTGVhZkNodW5rKGxpbmVzKV1cXG4gICAgICB0aGlzLmNoaWxkcmVuWzBdLnBhcmVudCA9IHRoaXNcXG4gICAgfVxcbiAgfSxcXG4gIGNvbGxhcHNlOiBmdW5jdGlvbihsaW5lcykge1xcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcXG5cXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgKytpKSB7IHRoaXMkMS5jaGlsZHJlbltpXS5jb2xsYXBzZShsaW5lcykgfVxcbiAgfSxcXG4gIGluc2VydElubmVyOiBmdW5jdGlvbihhdCwgbGluZXMsIGhlaWdodCkge1xcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcXG5cXG4gICAgdGhpcy5zaXplICs9IGxpbmVzLmxlbmd0aFxcbiAgICB0aGlzLmhlaWdodCArPSBoZWlnaHRcXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgKytpKSB7XFxuICAgICAgdmFyIGNoaWxkID0gdGhpcyQxLmNoaWxkcmVuW2ldLCBzeiA9IGNoaWxkLmNodW5rU2l6ZSgpXFxuICAgICAgaWYgKGF0IDw9IHN6KSB7XFxuICAgICAgICBjaGlsZC5pbnNlcnRJbm5lcihhdCwgbGluZXMsIGhlaWdodClcXG4gICAgICAgIGlmIChjaGlsZC5saW5lcyAmJiBjaGlsZC5saW5lcy5sZW5ndGggPiA1MCkge1xcbiAgICAgICAgICAvLyBUbyBhdm9pZCBtZW1vcnkgdGhyYXNoaW5nIHdoZW4gY2hpbGQubGluZXMgaXMgaHVnZSAoZS5nLiBmaXJzdCB2aWV3IG9mIGEgbGFyZ2UgZmlsZSksIGl0J3MgbmV2ZXIgc3BsaWNlZC5cXG4gICAgICAgICAgLy8gSW5zdGVhZCwgc21hbGwgc2xpY2VzIGFyZSB0YWtlbi4gVGhleSdyZSB0YWtlbiBpbiBvcmRlciBiZWNhdXNlIHNlcXVlbnRpYWwgbWVtb3J5IGFjY2Vzc2VzIGFyZSBmYXN0ZXN0LlxcbiAgICAgICAgICB2YXIgcmVtYWluaW5nID0gY2hpbGQubGluZXMubGVuZ3RoICUgMjUgKyAyNVxcbiAgICAgICAgICBmb3IgKHZhciBwb3MgPSByZW1haW5pbmc7IHBvcyA8IGNoaWxkLmxpbmVzLmxlbmd0aDspIHtcXG4gICAgICAgICAgICB2YXIgbGVhZiA9IG5ldyBMZWFmQ2h1bmsoY2hpbGQubGluZXMuc2xpY2UocG9zLCBwb3MgKz0gMjUpKVxcbiAgICAgICAgICAgIGNoaWxkLmhlaWdodCAtPSBsZWFmLmhlaWdodFxcbiAgICAgICAgICAgIHRoaXMkMS5jaGlsZHJlbi5zcGxpY2UoKytpLCAwLCBsZWFmKVxcbiAgICAgICAgICAgIGxlYWYucGFyZW50ID0gdGhpcyQxXFxuICAgICAgICAgIH1cXG4gICAgICAgICAgY2hpbGQubGluZXMgPSBjaGlsZC5saW5lcy5zbGljZSgwLCByZW1haW5pbmcpXFxuICAgICAgICAgIHRoaXMkMS5tYXliZVNwaWxsKClcXG4gICAgICAgIH1cXG4gICAgICAgIGJyZWFrXFxuICAgICAgfVxcbiAgICAgIGF0IC09IHN6XFxuICAgIH1cXG4gIH0sXFxuICAvLyBXaGVuIGEgbm9kZSBoYXMgZ3Jvd24sIGNoZWNrIHdoZXRoZXIgaXQgc2hvdWxkIGJlIHNwbGl0LlxcbiAgbWF5YmVTcGlsbDogZnVuY3Rpb24oKSB7XFxuICAgIGlmICh0aGlzLmNoaWxkcmVuLmxlbmd0aCA8PSAxMCkgeyByZXR1cm4gfVxcbiAgICB2YXIgbWUgPSB0aGlzXFxuICAgIGRvIHtcXG4gICAgICB2YXIgc3BpbGxlZCA9IG1lLmNoaWxkcmVuLnNwbGljZShtZS5jaGlsZHJlbi5sZW5ndGggLSA1LCA1KVxcbiAgICAgIHZhciBzaWJsaW5nID0gbmV3IEJyYW5jaENodW5rKHNwaWxsZWQpXFxuICAgICAgaWYgKCFtZS5wYXJlbnQpIHsgLy8gQmVjb21lIHRoZSBwYXJlbnQgbm9kZVxcbiAgICAgICAgdmFyIGNvcHkgPSBuZXcgQnJhbmNoQ2h1bmsobWUuY2hpbGRyZW4pXFxuICAgICAgICBjb3B5LnBhcmVudCA9IG1lXFxuICAgICAgICBtZS5jaGlsZHJlbiA9IFtjb3B5LCBzaWJsaW5nXVxcbiAgICAgICAgbWUgPSBjb3B5XFxuICAgICB9IGVsc2Uge1xcbiAgICAgICAgbWUuc2l6ZSAtPSBzaWJsaW5nLnNpemVcXG4gICAgICAgIG1lLmhlaWdodCAtPSBzaWJsaW5nLmhlaWdodFxcbiAgICAgICAgdmFyIG15SW5kZXggPSBpbmRleE9mKG1lLnBhcmVudC5jaGlsZHJlbiwgbWUpXFxuICAgICAgICBtZS5wYXJlbnQuY2hpbGRyZW4uc3BsaWNlKG15SW5kZXggKyAxLCAwLCBzaWJsaW5nKVxcbiAgICAgIH1cXG4gICAgICBzaWJsaW5nLnBhcmVudCA9IG1lLnBhcmVudFxcbiAgICB9IHdoaWxlIChtZS5jaGlsZHJlbi5sZW5ndGggPiAxMClcXG4gICAgbWUucGFyZW50Lm1heWJlU3BpbGwoKVxcbiAgfSxcXG4gIGl0ZXJOOiBmdW5jdGlvbihhdCwgbiwgb3ApIHtcXG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XFxuXFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7ICsraSkge1xcbiAgICAgIHZhciBjaGlsZCA9IHRoaXMkMS5jaGlsZHJlbltpXSwgc3ogPSBjaGlsZC5jaHVua1NpemUoKVxcbiAgICAgIGlmIChhdCA8IHN6KSB7XFxuICAgICAgICB2YXIgdXNlZCA9IE1hdGgubWluKG4sIHN6IC0gYXQpXFxuICAgICAgICBpZiAoY2hpbGQuaXRlck4oYXQsIHVzZWQsIG9wKSkgeyByZXR1cm4gdHJ1ZSB9XFxuICAgICAgICBpZiAoKG4gLT0gdXNlZCkgPT0gMCkgeyBicmVhayB9XFxuICAgICAgICBhdCA9IDBcXG4gICAgICB9IGVsc2UgeyBhdCAtPSBzeiB9XFxuICAgIH1cXG4gIH1cXG59XFxuXFxuLy8gTGluZSB3aWRnZXRzIGFyZSBibG9jayBlbGVtZW50cyBkaXNwbGF5ZWQgYWJvdmUgb3IgYmVsb3cgYSBsaW5lLlxcblxcbmZ1bmN0aW9uIExpbmVXaWRnZXQoZG9jLCBub2RlLCBvcHRpb25zKSB7XFxuICB2YXIgdGhpcyQxID0gdGhpcztcXG5cXG4gIGlmIChvcHRpb25zKSB7IGZvciAodmFyIG9wdCBpbiBvcHRpb25zKSB7IGlmIChvcHRpb25zLmhhc093blByb3BlcnR5KG9wdCkpXFxuICAgIHsgdGhpcyQxW29wdF0gPSBvcHRpb25zW29wdF0gfSB9IH1cXG4gIHRoaXMuZG9jID0gZG9jXFxuICB0aGlzLm5vZGUgPSBub2RlXFxufVxcbmV2ZW50TWl4aW4oTGluZVdpZGdldClcXG5cXG5mdW5jdGlvbiBhZGp1c3RTY3JvbGxXaGVuQWJvdmVWaXNpYmxlKGNtLCBsaW5lLCBkaWZmKSB7XFxuICBpZiAoaGVpZ2h0QXRMaW5lKGxpbmUpIDwgKChjbS5jdXJPcCAmJiBjbS5jdXJPcC5zY3JvbGxUb3ApIHx8IGNtLmRvYy5zY3JvbGxUb3ApKVxcbiAgICB7IGFkZFRvU2Nyb2xsUG9zKGNtLCBudWxsLCBkaWZmKSB9XFxufVxcblxcbkxpbmVXaWRnZXQucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24oKSB7XFxuICB2YXIgdGhpcyQxID0gdGhpcztcXG5cXG4gIHZhciBjbSA9IHRoaXMuZG9jLmNtLCB3cyA9IHRoaXMubGluZS53aWRnZXRzLCBsaW5lID0gdGhpcy5saW5lLCBubyA9IGxpbmVObyhsaW5lKVxcbiAgaWYgKG5vID09IG51bGwgfHwgIXdzKSB7IHJldHVybiB9XFxuICBmb3IgKHZhciBpID0gMDsgaSA8IHdzLmxlbmd0aDsgKytpKSB7IGlmICh3c1tpXSA9PSB0aGlzJDEpIHsgd3Muc3BsaWNlKGktLSwgMSkgfSB9XFxuICBpZiAoIXdzLmxlbmd0aCkgeyBsaW5lLndpZGdldHMgPSBudWxsIH1cXG4gIHZhciBoZWlnaHQgPSB3aWRnZXRIZWlnaHQodGhpcylcXG4gIHVwZGF0ZUxpbmVIZWlnaHQobGluZSwgTWF0aC5tYXgoMCwgbGluZS5oZWlnaHQgLSBoZWlnaHQpKVxcbiAgaWYgKGNtKSB7IHJ1bkluT3AoY20sIGZ1bmN0aW9uICgpIHtcXG4gICAgYWRqdXN0U2Nyb2xsV2hlbkFib3ZlVmlzaWJsZShjbSwgbGluZSwgLWhlaWdodClcXG4gICAgcmVnTGluZUNoYW5nZShjbSwgbm8sIFxcXCJ3aWRnZXRcXFwiKVxcbiAgfSkgfVxcbn1cXG5MaW5lV2lkZ2V0LnByb3RvdHlwZS5jaGFuZ2VkID0gZnVuY3Rpb24oKSB7XFxuICB2YXIgb2xkSCA9IHRoaXMuaGVpZ2h0LCBjbSA9IHRoaXMuZG9jLmNtLCBsaW5lID0gdGhpcy5saW5lXFxuICB0aGlzLmhlaWdodCA9IG51bGxcXG4gIHZhciBkaWZmID0gd2lkZ2V0SGVpZ2h0KHRoaXMpIC0gb2xkSFxcbiAgaWYgKCFkaWZmKSB7IHJldHVybiB9XFxuICB1cGRhdGVMaW5lSGVpZ2h0KGxpbmUsIGxpbmUuaGVpZ2h0ICsgZGlmZilcXG4gIGlmIChjbSkgeyBydW5Jbk9wKGNtLCBmdW5jdGlvbiAoKSB7XFxuICAgIGNtLmN1ck9wLmZvcmNlVXBkYXRlID0gdHJ1ZVxcbiAgICBhZGp1c3RTY3JvbGxXaGVuQWJvdmVWaXNpYmxlKGNtLCBsaW5lLCBkaWZmKVxcbiAgfSkgfVxcbn1cXG5cXG5mdW5jdGlvbiBhZGRMaW5lV2lkZ2V0KGRvYywgaGFuZGxlLCBub2RlLCBvcHRpb25zKSB7XFxuICB2YXIgd2lkZ2V0ID0gbmV3IExpbmVXaWRnZXQoZG9jLCBub2RlLCBvcHRpb25zKVxcbiAgdmFyIGNtID0gZG9jLmNtXFxuICBpZiAoY20gJiYgd2lkZ2V0Lm5vSFNjcm9sbCkgeyBjbS5kaXNwbGF5LmFsaWduV2lkZ2V0cyA9IHRydWUgfVxcbiAgY2hhbmdlTGluZShkb2MsIGhhbmRsZSwgXFxcIndpZGdldFxcXCIsIGZ1bmN0aW9uIChsaW5lKSB7XFxuICAgIHZhciB3aWRnZXRzID0gbGluZS53aWRnZXRzIHx8IChsaW5lLndpZGdldHMgPSBbXSlcXG4gICAgaWYgKHdpZGdldC5pbnNlcnRBdCA9PSBudWxsKSB7IHdpZGdldHMucHVzaCh3aWRnZXQpIH1cXG4gICAgZWxzZSB7IHdpZGdldHMuc3BsaWNlKE1hdGgubWluKHdpZGdldHMubGVuZ3RoIC0gMSwgTWF0aC5tYXgoMCwgd2lkZ2V0Lmluc2VydEF0KSksIDAsIHdpZGdldCkgfVxcbiAgICB3aWRnZXQubGluZSA9IGxpbmVcXG4gICAgaWYgKGNtICYmICFsaW5lSXNIaWRkZW4oZG9jLCBsaW5lKSkge1xcbiAgICAgIHZhciBhYm92ZVZpc2libGUgPSBoZWlnaHRBdExpbmUobGluZSkgPCBkb2Muc2Nyb2xsVG9wXFxuICAgICAgdXBkYXRlTGluZUhlaWdodChsaW5lLCBsaW5lLmhlaWdodCArIHdpZGdldEhlaWdodCh3aWRnZXQpKVxcbiAgICAgIGlmIChhYm92ZVZpc2libGUpIHsgYWRkVG9TY3JvbGxQb3MoY20sIG51bGwsIHdpZGdldC5oZWlnaHQpIH1cXG4gICAgICBjbS5jdXJPcC5mb3JjZVVwZGF0ZSA9IHRydWVcXG4gICAgfVxcbiAgICByZXR1cm4gdHJ1ZVxcbiAgfSlcXG4gIHJldHVybiB3aWRnZXRcXG59XFxuXFxuLy8gVEVYVE1BUktFUlNcXG5cXG4vLyBDcmVhdGVkIHdpdGggbWFya1RleHQgYW5kIHNldEJvb2ttYXJrIG1ldGhvZHMuIEEgVGV4dE1hcmtlciBpcyBhXFxuLy8gaGFuZGxlIHRoYXQgY2FuIGJlIHVzZWQgdG8gY2xlYXIgb3IgZmluZCBhIG1hcmtlZCBwb3NpdGlvbiBpbiB0aGVcXG4vLyBkb2N1bWVudC4gTGluZSBvYmplY3RzIGhvbGQgYXJyYXlzIChtYXJrZWRTcGFucykgY29udGFpbmluZ1xcbi8vIHtmcm9tLCB0bywgbWFya2VyfSBvYmplY3QgcG9pbnRpbmcgdG8gc3VjaCBtYXJrZXIgb2JqZWN0cywgYW5kXFxuLy8gaW5kaWNhdGluZyB0aGF0IHN1Y2ggYSBtYXJrZXIgaXMgcHJlc2VudCBvbiB0aGF0IGxpbmUuIE11bHRpcGxlXFxuLy8gbGluZXMgbWF5IHBvaW50IHRvIHRoZSBzYW1lIG1hcmtlciB3aGVuIGl0IHNwYW5zIGFjcm9zcyBsaW5lcy5cXG4vLyBUaGUgc3BhbnMgd2lsbCBoYXZlIG51bGwgZm9yIHRoZWlyIGZyb20vdG8gcHJvcGVydGllcyB3aGVuIHRoZVxcbi8vIG1hcmtlciBjb250aW51ZXMgYmV5b25kIHRoZSBzdGFydC9lbmQgb2YgdGhlIGxpbmUuIE1hcmtlcnMgaGF2ZVxcbi8vIGxpbmtzIGJhY2sgdG8gdGhlIGxpbmVzIHRoZXkgY3VycmVudGx5IHRvdWNoLlxcblxcbi8vIENvbGxhcHNlZCBtYXJrZXJzIGhhdmUgdW5pcXVlIGlkcywgaW4gb3JkZXIgdG8gYmUgYWJsZSB0byBvcmRlclxcbi8vIHRoZW0sIHdoaWNoIGlzIG5lZWRlZCBmb3IgdW5pcXVlbHkgZGV0ZXJtaW5pbmcgYW4gb3V0ZXIgbWFya2VyXFxuLy8gd2hlbiB0aGV5IG92ZXJsYXAgKHRoZXkgbWF5IG5lc3QsIGJ1dCBub3QgcGFydGlhbGx5IG92ZXJsYXApLlxcbnZhciBuZXh0TWFya2VySWQgPSAwXFxuXFxuZnVuY3Rpb24gVGV4dE1hcmtlcihkb2MsIHR5cGUpIHtcXG4gIHRoaXMubGluZXMgPSBbXVxcbiAgdGhpcy50eXBlID0gdHlwZVxcbiAgdGhpcy5kb2MgPSBkb2NcXG4gIHRoaXMuaWQgPSArK25leHRNYXJrZXJJZFxcbn1cXG5ldmVudE1peGluKFRleHRNYXJrZXIpXFxuXFxuLy8gQ2xlYXIgdGhlIG1hcmtlci5cXG5UZXh0TWFya2VyLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uKCkge1xcbiAgdmFyIHRoaXMkMSA9IHRoaXM7XFxuXFxuICBpZiAodGhpcy5leHBsaWNpdGx5Q2xlYXJlZCkgeyByZXR1cm4gfVxcbiAgdmFyIGNtID0gdGhpcy5kb2MuY20sIHdpdGhPcCA9IGNtICYmICFjbS5jdXJPcFxcbiAgaWYgKHdpdGhPcCkgeyBzdGFydE9wZXJhdGlvbihjbSkgfVxcbiAgaWYgKGhhc0hhbmRsZXIodGhpcywgXFxcImNsZWFyXFxcIikpIHtcXG4gICAgdmFyIGZvdW5kID0gdGhpcy5maW5kKClcXG4gICAgaWYgKGZvdW5kKSB7IHNpZ25hbExhdGVyKHRoaXMsIFxcXCJjbGVhclxcXCIsIGZvdW5kLmZyb20sIGZvdW5kLnRvKSB9XFxuICB9XFxuICB2YXIgbWluID0gbnVsbCwgbWF4ID0gbnVsbFxcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxpbmVzLmxlbmd0aDsgKytpKSB7XFxuICAgIHZhciBsaW5lID0gdGhpcyQxLmxpbmVzW2ldXFxuICAgIHZhciBzcGFuID0gZ2V0TWFya2VkU3BhbkZvcihsaW5lLm1hcmtlZFNwYW5zLCB0aGlzJDEpXFxuICAgIGlmIChjbSAmJiAhdGhpcyQxLmNvbGxhcHNlZCkgeyByZWdMaW5lQ2hhbmdlKGNtLCBsaW5lTm8obGluZSksIFxcXCJ0ZXh0XFxcIikgfVxcbiAgICBlbHNlIGlmIChjbSkge1xcbiAgICAgIGlmIChzcGFuLnRvICE9IG51bGwpIHsgbWF4ID0gbGluZU5vKGxpbmUpIH1cXG4gICAgICBpZiAoc3Bhbi5mcm9tICE9IG51bGwpIHsgbWluID0gbGluZU5vKGxpbmUpIH1cXG4gICAgfVxcbiAgICBsaW5lLm1hcmtlZFNwYW5zID0gcmVtb3ZlTWFya2VkU3BhbihsaW5lLm1hcmtlZFNwYW5zLCBzcGFuKVxcbiAgICBpZiAoc3Bhbi5mcm9tID09IG51bGwgJiYgdGhpcyQxLmNvbGxhcHNlZCAmJiAhbGluZUlzSGlkZGVuKHRoaXMkMS5kb2MsIGxpbmUpICYmIGNtKVxcbiAgICAgIHsgdXBkYXRlTGluZUhlaWdodChsaW5lLCB0ZXh0SGVpZ2h0KGNtLmRpc3BsYXkpKSB9XFxuICB9XFxuICBpZiAoY20gJiYgdGhpcy5jb2xsYXBzZWQgJiYgIWNtLm9wdGlvbnMubGluZVdyYXBwaW5nKSB7IGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IHRoaXMubGluZXMubGVuZ3RoOyArK2kkMSkge1xcbiAgICB2YXIgdmlzdWFsID0gdmlzdWFsTGluZSh0aGlzJDEubGluZXNbaSQxXSksIGxlbiA9IGxpbmVMZW5ndGgodmlzdWFsKVxcbiAgICBpZiAobGVuID4gY20uZGlzcGxheS5tYXhMaW5lTGVuZ3RoKSB7XFxuICAgICAgY20uZGlzcGxheS5tYXhMaW5lID0gdmlzdWFsXFxuICAgICAgY20uZGlzcGxheS5tYXhMaW5lTGVuZ3RoID0gbGVuXFxuICAgICAgY20uZGlzcGxheS5tYXhMaW5lQ2hhbmdlZCA9IHRydWVcXG4gICAgfVxcbiAgfSB9XFxuXFxuICBpZiAobWluICE9IG51bGwgJiYgY20gJiYgdGhpcy5jb2xsYXBzZWQpIHsgcmVnQ2hhbmdlKGNtLCBtaW4sIG1heCArIDEpIH1cXG4gIHRoaXMubGluZXMubGVuZ3RoID0gMFxcbiAgdGhpcy5leHBsaWNpdGx5Q2xlYXJlZCA9IHRydWVcXG4gIGlmICh0aGlzLmF0b21pYyAmJiB0aGlzLmRvYy5jYW50RWRpdCkge1xcbiAgICB0aGlzLmRvYy5jYW50RWRpdCA9IGZhbHNlXFxuICAgIGlmIChjbSkgeyByZUNoZWNrU2VsZWN0aW9uKGNtLmRvYykgfVxcbiAgfVxcbiAgaWYgKGNtKSB7IHNpZ25hbExhdGVyKGNtLCBcXFwibWFya2VyQ2xlYXJlZFxcXCIsIGNtLCB0aGlzKSB9XFxuICBpZiAod2l0aE9wKSB7IGVuZE9wZXJhdGlvbihjbSkgfVxcbiAgaWYgKHRoaXMucGFyZW50KSB7IHRoaXMucGFyZW50LmNsZWFyKCkgfVxcbn1cXG5cXG4vLyBGaW5kIHRoZSBwb3NpdGlvbiBvZiB0aGUgbWFya2VyIGluIHRoZSBkb2N1bWVudC4gUmV0dXJucyBhIHtmcm9tLFxcbi8vIHRvfSBvYmplY3QgYnkgZGVmYXVsdC4gU2lkZSBjYW4gYmUgcGFzc2VkIHRvIGdldCBhIHNwZWNpZmljIHNpZGVcXG4vLyAtLSAwIChib3RoKSwgLTEgKGxlZnQpLCBvciAxIChyaWdodCkuIFdoZW4gbGluZU9iaiBpcyB0cnVlLCB0aGVcXG4vLyBQb3Mgb2JqZWN0cyByZXR1cm5lZCBjb250YWluIGEgbGluZSBvYmplY3QsIHJhdGhlciB0aGFuIGEgbGluZVxcbi8vIG51bWJlciAodXNlZCB0byBwcmV2ZW50IGxvb2tpbmcgdXAgdGhlIHNhbWUgbGluZSB0d2ljZSkuXFxuVGV4dE1hcmtlci5wcm90b3R5cGUuZmluZCA9IGZ1bmN0aW9uKHNpZGUsIGxpbmVPYmopIHtcXG4gIHZhciB0aGlzJDEgPSB0aGlzO1xcblxcbiAgaWYgKHNpZGUgPT0gbnVsbCAmJiB0aGlzLnR5cGUgPT0gXFxcImJvb2ttYXJrXFxcIikgeyBzaWRlID0gMSB9XFxuICB2YXIgZnJvbSwgdG9cXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5saW5lcy5sZW5ndGg7ICsraSkge1xcbiAgICB2YXIgbGluZSA9IHRoaXMkMS5saW5lc1tpXVxcbiAgICB2YXIgc3BhbiA9IGdldE1hcmtlZFNwYW5Gb3IobGluZS5tYXJrZWRTcGFucywgdGhpcyQxKVxcbiAgICBpZiAoc3Bhbi5mcm9tICE9IG51bGwpIHtcXG4gICAgICBmcm9tID0gUG9zKGxpbmVPYmogPyBsaW5lIDogbGluZU5vKGxpbmUpLCBzcGFuLmZyb20pXFxuICAgICAgaWYgKHNpZGUgPT0gLTEpIHsgcmV0dXJuIGZyb20gfVxcbiAgICB9XFxuICAgIGlmIChzcGFuLnRvICE9IG51bGwpIHtcXG4gICAgICB0byA9IFBvcyhsaW5lT2JqID8gbGluZSA6IGxpbmVObyhsaW5lKSwgc3Bhbi50bylcXG4gICAgICBpZiAoc2lkZSA9PSAxKSB7IHJldHVybiB0byB9XFxuICAgIH1cXG4gIH1cXG4gIHJldHVybiBmcm9tICYmIHtmcm9tOiBmcm9tLCB0bzogdG99XFxufVxcblxcbi8vIFNpZ25hbHMgdGhhdCB0aGUgbWFya2VyJ3Mgd2lkZ2V0IGNoYW5nZWQsIGFuZCBzdXJyb3VuZGluZyBsYXlvdXRcXG4vLyBzaG91bGQgYmUgcmVjb21wdXRlZC5cXG5UZXh0TWFya2VyLnByb3RvdHlwZS5jaGFuZ2VkID0gZnVuY3Rpb24oKSB7XFxuICB2YXIgcG9zID0gdGhpcy5maW5kKC0xLCB0cnVlKSwgd2lkZ2V0ID0gdGhpcywgY20gPSB0aGlzLmRvYy5jbVxcbiAgaWYgKCFwb3MgfHwgIWNtKSB7IHJldHVybiB9XFxuICBydW5Jbk9wKGNtLCBmdW5jdGlvbiAoKSB7XFxuICAgIHZhciBsaW5lID0gcG9zLmxpbmUsIGxpbmVOID0gbGluZU5vKHBvcy5saW5lKVxcbiAgICB2YXIgdmlldyA9IGZpbmRWaWV3Rm9yTGluZShjbSwgbGluZU4pXFxuICAgIGlmICh2aWV3KSB7XFxuICAgICAgY2xlYXJMaW5lTWVhc3VyZW1lbnRDYWNoZUZvcih2aWV3KVxcbiAgICAgIGNtLmN1ck9wLnNlbGVjdGlvbkNoYW5nZWQgPSBjbS5jdXJPcC5mb3JjZVVwZGF0ZSA9IHRydWVcXG4gICAgfVxcbiAgICBjbS5jdXJPcC51cGRhdGVNYXhMaW5lID0gdHJ1ZVxcbiAgICBpZiAoIWxpbmVJc0hpZGRlbih3aWRnZXQuZG9jLCBsaW5lKSAmJiB3aWRnZXQuaGVpZ2h0ICE9IG51bGwpIHtcXG4gICAgICB2YXIgb2xkSGVpZ2h0ID0gd2lkZ2V0LmhlaWdodFxcbiAgICAgIHdpZGdldC5oZWlnaHQgPSBudWxsXFxuICAgICAgdmFyIGRIZWlnaHQgPSB3aWRnZXRIZWlnaHQod2lkZ2V0KSAtIG9sZEhlaWdodFxcbiAgICAgIGlmIChkSGVpZ2h0KVxcbiAgICAgICAgeyB1cGRhdGVMaW5lSGVpZ2h0KGxpbmUsIGxpbmUuaGVpZ2h0ICsgZEhlaWdodCkgfVxcbiAgICB9XFxuICB9KVxcbn1cXG5cXG5UZXh0TWFya2VyLnByb3RvdHlwZS5hdHRhY2hMaW5lID0gZnVuY3Rpb24obGluZSkge1xcbiAgaWYgKCF0aGlzLmxpbmVzLmxlbmd0aCAmJiB0aGlzLmRvYy5jbSkge1xcbiAgICB2YXIgb3AgPSB0aGlzLmRvYy5jbS5jdXJPcFxcbiAgICBpZiAoIW9wLm1heWJlSGlkZGVuTWFya2VycyB8fCBpbmRleE9mKG9wLm1heWJlSGlkZGVuTWFya2VycywgdGhpcykgPT0gLTEpXFxuICAgICAgeyAob3AubWF5YmVVbmhpZGRlbk1hcmtlcnMgfHwgKG9wLm1heWJlVW5oaWRkZW5NYXJrZXJzID0gW10pKS5wdXNoKHRoaXMpIH1cXG4gIH1cXG4gIHRoaXMubGluZXMucHVzaChsaW5lKVxcbn1cXG5UZXh0TWFya2VyLnByb3RvdHlwZS5kZXRhY2hMaW5lID0gZnVuY3Rpb24obGluZSkge1xcbiAgdGhpcy5saW5lcy5zcGxpY2UoaW5kZXhPZih0aGlzLmxpbmVzLCBsaW5lKSwgMSlcXG4gIGlmICghdGhpcy5saW5lcy5sZW5ndGggJiYgdGhpcy5kb2MuY20pIHtcXG4gICAgdmFyIG9wID0gdGhpcy5kb2MuY20uY3VyT3BcXG4gICAgOyhvcC5tYXliZUhpZGRlbk1hcmtlcnMgfHwgKG9wLm1heWJlSGlkZGVuTWFya2VycyA9IFtdKSkucHVzaCh0aGlzKVxcbiAgfVxcbn1cXG5cXG4vLyBDcmVhdGUgYSBtYXJrZXIsIHdpcmUgaXQgdXAgdG8gdGhlIHJpZ2h0IGxpbmVzLCBhbmRcXG5mdW5jdGlvbiBtYXJrVGV4dChkb2MsIGZyb20sIHRvLCBvcHRpb25zLCB0eXBlKSB7XFxuICAvLyBTaGFyZWQgbWFya2VycyAoYWNyb3NzIGxpbmtlZCBkb2N1bWVudHMpIGFyZSBoYW5kbGVkIHNlcGFyYXRlbHlcXG4gIC8vIChtYXJrVGV4dFNoYXJlZCB3aWxsIGNhbGwgb3V0IHRvIHRoaXMgYWdhaW4sIG9uY2UgcGVyXFxuICAvLyBkb2N1bWVudCkuXFxuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnNoYXJlZCkgeyByZXR1cm4gbWFya1RleHRTaGFyZWQoZG9jLCBmcm9tLCB0bywgb3B0aW9ucywgdHlwZSkgfVxcbiAgLy8gRW5zdXJlIHdlIGFyZSBpbiBhbiBvcGVyYXRpb24uXFxuICBpZiAoZG9jLmNtICYmICFkb2MuY20uY3VyT3ApIHsgcmV0dXJuIG9wZXJhdGlvbihkb2MuY20sIG1hcmtUZXh0KShkb2MsIGZyb20sIHRvLCBvcHRpb25zLCB0eXBlKSB9XFxuXFxuICB2YXIgbWFya2VyID0gbmV3IFRleHRNYXJrZXIoZG9jLCB0eXBlKSwgZGlmZiA9IGNtcChmcm9tLCB0bylcXG4gIGlmIChvcHRpb25zKSB7IGNvcHlPYmoob3B0aW9ucywgbWFya2VyLCBmYWxzZSkgfVxcbiAgLy8gRG9uJ3QgY29ubmVjdCBlbXB0eSBtYXJrZXJzIHVubGVzcyBjbGVhcldoZW5FbXB0eSBpcyBmYWxzZVxcbiAgaWYgKGRpZmYgPiAwIHx8IGRpZmYgPT0gMCAmJiBtYXJrZXIuY2xlYXJXaGVuRW1wdHkgIT09IGZhbHNlKVxcbiAgICB7IHJldHVybiBtYXJrZXIgfVxcbiAgaWYgKG1hcmtlci5yZXBsYWNlZFdpdGgpIHtcXG4gICAgLy8gU2hvd2luZyB1cCBhcyBhIHdpZGdldCBpbXBsaWVzIGNvbGxhcHNlZCAod2lkZ2V0IHJlcGxhY2VzIHRleHQpXFxuICAgIG1hcmtlci5jb2xsYXBzZWQgPSB0cnVlXFxuICAgIG1hcmtlci53aWRnZXROb2RlID0gZWx0KFxcXCJzcGFuXFxcIiwgW21hcmtlci5yZXBsYWNlZFdpdGhdLCBcXFwiQ29kZU1pcnJvci13aWRnZXRcXFwiKVxcbiAgICBpZiAoIW9wdGlvbnMuaGFuZGxlTW91c2VFdmVudHMpIHsgbWFya2VyLndpZGdldE5vZGUuc2V0QXR0cmlidXRlKFxcXCJjbS1pZ25vcmUtZXZlbnRzXFxcIiwgXFxcInRydWVcXFwiKSB9XFxuICAgIGlmIChvcHRpb25zLmluc2VydExlZnQpIHsgbWFya2VyLndpZGdldE5vZGUuaW5zZXJ0TGVmdCA9IHRydWUgfVxcbiAgfVxcbiAgaWYgKG1hcmtlci5jb2xsYXBzZWQpIHtcXG4gICAgaWYgKGNvbmZsaWN0aW5nQ29sbGFwc2VkUmFuZ2UoZG9jLCBmcm9tLmxpbmUsIGZyb20sIHRvLCBtYXJrZXIpIHx8XFxuICAgICAgICBmcm9tLmxpbmUgIT0gdG8ubGluZSAmJiBjb25mbGljdGluZ0NvbGxhcHNlZFJhbmdlKGRvYywgdG8ubGluZSwgZnJvbSwgdG8sIG1hcmtlcikpXFxuICAgICAgeyB0aHJvdyBuZXcgRXJyb3IoXFxcIkluc2VydGluZyBjb2xsYXBzZWQgbWFya2VyIHBhcnRpYWxseSBvdmVybGFwcGluZyBhbiBleGlzdGluZyBvbmVcXFwiKSB9XFxuICAgIHNlZUNvbGxhcHNlZFNwYW5zKClcXG4gIH1cXG5cXG4gIGlmIChtYXJrZXIuYWRkVG9IaXN0b3J5KVxcbiAgICB7IGFkZENoYW5nZVRvSGlzdG9yeShkb2MsIHtmcm9tOiBmcm9tLCB0bzogdG8sIG9yaWdpbjogXFxcIm1hcmtUZXh0XFxcIn0sIGRvYy5zZWwsIE5hTikgfVxcblxcbiAgdmFyIGN1ckxpbmUgPSBmcm9tLmxpbmUsIGNtID0gZG9jLmNtLCB1cGRhdGVNYXhMaW5lXFxuICBkb2MuaXRlcihjdXJMaW5lLCB0by5saW5lICsgMSwgZnVuY3Rpb24gKGxpbmUpIHtcXG4gICAgaWYgKGNtICYmIG1hcmtlci5jb2xsYXBzZWQgJiYgIWNtLm9wdGlvbnMubGluZVdyYXBwaW5nICYmIHZpc3VhbExpbmUobGluZSkgPT0gY20uZGlzcGxheS5tYXhMaW5lKVxcbiAgICAgIHsgdXBkYXRlTWF4TGluZSA9IHRydWUgfVxcbiAgICBpZiAobWFya2VyLmNvbGxhcHNlZCAmJiBjdXJMaW5lICE9IGZyb20ubGluZSkgeyB1cGRhdGVMaW5lSGVpZ2h0KGxpbmUsIDApIH1cXG4gICAgYWRkTWFya2VkU3BhbihsaW5lLCBuZXcgTWFya2VkU3BhbihtYXJrZXIsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VyTGluZSA9PSBmcm9tLmxpbmUgPyBmcm9tLmNoIDogbnVsbCxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJMaW5lID09IHRvLmxpbmUgPyB0by5jaCA6IG51bGwpKVxcbiAgICArK2N1ckxpbmVcXG4gIH0pXFxuICAvLyBsaW5lSXNIaWRkZW4gZGVwZW5kcyBvbiB0aGUgcHJlc2VuY2Ugb2YgdGhlIHNwYW5zLCBzbyBuZWVkcyBhIHNlY29uZCBwYXNzXFxuICBpZiAobWFya2VyLmNvbGxhcHNlZCkgeyBkb2MuaXRlcihmcm9tLmxpbmUsIHRvLmxpbmUgKyAxLCBmdW5jdGlvbiAobGluZSkge1xcbiAgICBpZiAobGluZUlzSGlkZGVuKGRvYywgbGluZSkpIHsgdXBkYXRlTGluZUhlaWdodChsaW5lLCAwKSB9XFxuICB9KSB9XFxuXFxuICBpZiAobWFya2VyLmNsZWFyT25FbnRlcikgeyBvbihtYXJrZXIsIFxcXCJiZWZvcmVDdXJzb3JFbnRlclxcXCIsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1hcmtlci5jbGVhcigpOyB9KSB9XFxuXFxuICBpZiAobWFya2VyLnJlYWRPbmx5KSB7XFxuICAgIHNlZVJlYWRPbmx5U3BhbnMoKVxcbiAgICBpZiAoZG9jLmhpc3RvcnkuZG9uZS5sZW5ndGggfHwgZG9jLmhpc3RvcnkudW5kb25lLmxlbmd0aClcXG4gICAgICB7IGRvYy5jbGVhckhpc3RvcnkoKSB9XFxuICB9XFxuICBpZiAobWFya2VyLmNvbGxhcHNlZCkge1xcbiAgICBtYXJrZXIuaWQgPSArK25leHRNYXJrZXJJZFxcbiAgICBtYXJrZXIuYXRvbWljID0gdHJ1ZVxcbiAgfVxcbiAgaWYgKGNtKSB7XFxuICAgIC8vIFN5bmMgZWRpdG9yIHN0YXRlXFxuICAgIGlmICh1cGRhdGVNYXhMaW5lKSB7IGNtLmN1ck9wLnVwZGF0ZU1heExpbmUgPSB0cnVlIH1cXG4gICAgaWYgKG1hcmtlci5jb2xsYXBzZWQpXFxuICAgICAgeyByZWdDaGFuZ2UoY20sIGZyb20ubGluZSwgdG8ubGluZSArIDEpIH1cXG4gICAgZWxzZSBpZiAobWFya2VyLmNsYXNzTmFtZSB8fCBtYXJrZXIudGl0bGUgfHwgbWFya2VyLnN0YXJ0U3R5bGUgfHwgbWFya2VyLmVuZFN0eWxlIHx8IG1hcmtlci5jc3MpXFxuICAgICAgeyBmb3IgKHZhciBpID0gZnJvbS5saW5lOyBpIDw9IHRvLmxpbmU7IGkrKykgeyByZWdMaW5lQ2hhbmdlKGNtLCBpLCBcXFwidGV4dFxcXCIpIH0gfVxcbiAgICBpZiAobWFya2VyLmF0b21pYykgeyByZUNoZWNrU2VsZWN0aW9uKGNtLmRvYykgfVxcbiAgICBzaWduYWxMYXRlcihjbSwgXFxcIm1hcmtlckFkZGVkXFxcIiwgY20sIG1hcmtlcilcXG4gIH1cXG4gIHJldHVybiBtYXJrZXJcXG59XFxuXFxuLy8gU0hBUkVEIFRFWFRNQVJLRVJTXFxuXFxuLy8gQSBzaGFyZWQgbWFya2VyIHNwYW5zIG11bHRpcGxlIGxpbmtlZCBkb2N1bWVudHMuIEl0IGlzXFxuLy8gaW1wbGVtZW50ZWQgYXMgYSBtZXRhLW1hcmtlci1vYmplY3QgY29udHJvbGxpbmcgbXVsdGlwbGUgbm9ybWFsXFxuLy8gbWFya2Vycy5cXG5mdW5jdGlvbiBTaGFyZWRUZXh0TWFya2VyKG1hcmtlcnMsIHByaW1hcnkpIHtcXG4gIHZhciB0aGlzJDEgPSB0aGlzO1xcblxcbiAgdGhpcy5tYXJrZXJzID0gbWFya2Vyc1xcbiAgdGhpcy5wcmltYXJ5ID0gcHJpbWFyeVxcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXJrZXJzLmxlbmd0aDsgKytpKVxcbiAgICB7IG1hcmtlcnNbaV0ucGFyZW50ID0gdGhpcyQxIH1cXG59XFxuZXZlbnRNaXhpbihTaGFyZWRUZXh0TWFya2VyKVxcblxcblNoYXJlZFRleHRNYXJrZXIucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24oKSB7XFxuICB2YXIgdGhpcyQxID0gdGhpcztcXG5cXG4gIGlmICh0aGlzLmV4cGxpY2l0bHlDbGVhcmVkKSB7IHJldHVybiB9XFxuICB0aGlzLmV4cGxpY2l0bHlDbGVhcmVkID0gdHJ1ZVxcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm1hcmtlcnMubGVuZ3RoOyArK2kpXFxuICAgIHsgdGhpcyQxLm1hcmtlcnNbaV0uY2xlYXIoKSB9XFxuICBzaWduYWxMYXRlcih0aGlzLCBcXFwiY2xlYXJcXFwiKVxcbn1cXG5TaGFyZWRUZXh0TWFya2VyLnByb3RvdHlwZS5maW5kID0gZnVuY3Rpb24oc2lkZSwgbGluZU9iaikge1xcbiAgcmV0dXJuIHRoaXMucHJpbWFyeS5maW5kKHNpZGUsIGxpbmVPYmopXFxufVxcblxcbmZ1bmN0aW9uIG1hcmtUZXh0U2hhcmVkKGRvYywgZnJvbSwgdG8sIG9wdGlvbnMsIHR5cGUpIHtcXG4gIG9wdGlvbnMgPSBjb3B5T2JqKG9wdGlvbnMpXFxuICBvcHRpb25zLnNoYXJlZCA9IGZhbHNlXFxuICB2YXIgbWFya2VycyA9IFttYXJrVGV4dChkb2MsIGZyb20sIHRvLCBvcHRpb25zLCB0eXBlKV0sIHByaW1hcnkgPSBtYXJrZXJzWzBdXFxuICB2YXIgd2lkZ2V0ID0gb3B0aW9ucy53aWRnZXROb2RlXFxuICBsaW5rZWREb2NzKGRvYywgZnVuY3Rpb24gKGRvYykge1xcbiAgICBpZiAod2lkZ2V0KSB7IG9wdGlvbnMud2lkZ2V0Tm9kZSA9IHdpZGdldC5jbG9uZU5vZGUodHJ1ZSkgfVxcbiAgICBtYXJrZXJzLnB1c2gobWFya1RleHQoZG9jLCBjbGlwUG9zKGRvYywgZnJvbSksIGNsaXBQb3MoZG9jLCB0byksIG9wdGlvbnMsIHR5cGUpKVxcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRvYy5saW5rZWQubGVuZ3RoOyArK2kpXFxuICAgICAgeyBpZiAoZG9jLmxpbmtlZFtpXS5pc1BhcmVudCkgeyByZXR1cm4gfSB9XFxuICAgIHByaW1hcnkgPSBsc3QobWFya2VycylcXG4gIH0pXFxuICByZXR1cm4gbmV3IFNoYXJlZFRleHRNYXJrZXIobWFya2VycywgcHJpbWFyeSlcXG59XFxuXFxuZnVuY3Rpb24gZmluZFNoYXJlZE1hcmtlcnMoZG9jKSB7XFxuICByZXR1cm4gZG9jLmZpbmRNYXJrcyhQb3MoZG9jLmZpcnN0LCAwKSwgZG9jLmNsaXBQb3MoUG9zKGRvYy5sYXN0TGluZSgpKSksIGZ1bmN0aW9uIChtKSB7IHJldHVybiBtLnBhcmVudDsgfSlcXG59XFxuXFxuZnVuY3Rpb24gY29weVNoYXJlZE1hcmtlcnMoZG9jLCBtYXJrZXJzKSB7XFxuICBmb3IgKHZhciBpID0gMDsgaSA8IG1hcmtlcnMubGVuZ3RoOyBpKyspIHtcXG4gICAgdmFyIG1hcmtlciA9IG1hcmtlcnNbaV0sIHBvcyA9IG1hcmtlci5maW5kKClcXG4gICAgdmFyIG1Gcm9tID0gZG9jLmNsaXBQb3MocG9zLmZyb20pLCBtVG8gPSBkb2MuY2xpcFBvcyhwb3MudG8pXFxuICAgIGlmIChjbXAobUZyb20sIG1UbykpIHtcXG4gICAgICB2YXIgc3ViTWFyayA9IG1hcmtUZXh0KGRvYywgbUZyb20sIG1UbywgbWFya2VyLnByaW1hcnksIG1hcmtlci5wcmltYXJ5LnR5cGUpXFxuICAgICAgbWFya2VyLm1hcmtlcnMucHVzaChzdWJNYXJrKVxcbiAgICAgIHN1Yk1hcmsucGFyZW50ID0gbWFya2VyXFxuICAgIH1cXG4gIH1cXG59XFxuXFxuZnVuY3Rpb24gZGV0YWNoU2hhcmVkTWFya2VycyhtYXJrZXJzKSB7XFxuICB2YXIgbG9vcCA9IGZ1bmN0aW9uICggaSApIHtcXG4gICAgdmFyIG1hcmtlciA9IG1hcmtlcnNbaV0sIGxpbmtlZCA9IFttYXJrZXIucHJpbWFyeS5kb2NdXFxuICAgIGxpbmtlZERvY3MobWFya2VyLnByaW1hcnkuZG9jLCBmdW5jdGlvbiAoZCkgeyByZXR1cm4gbGlua2VkLnB1c2goZCk7IH0pXFxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgbWFya2VyLm1hcmtlcnMubGVuZ3RoOyBqKyspIHtcXG4gICAgICB2YXIgc3ViTWFya2VyID0gbWFya2VyLm1hcmtlcnNbal1cXG4gICAgICBpZiAoaW5kZXhPZihsaW5rZWQsIHN1Yk1hcmtlci5kb2MpID09IC0xKSB7XFxuICAgICAgICBzdWJNYXJrZXIucGFyZW50ID0gbnVsbFxcbiAgICAgICAgbWFya2VyLm1hcmtlcnMuc3BsaWNlKGotLSwgMSlcXG4gICAgICB9XFxuICAgIH1cXG4gIH07XFxuXFxuICBmb3IgKHZhciBpID0gMDsgaSA8IG1hcmtlcnMubGVuZ3RoOyBpKyspIGxvb3AoIGkgKTtcXG59XFxuXFxudmFyIG5leHREb2NJZCA9IDBcXG52YXIgRG9jID0gZnVuY3Rpb24odGV4dCwgbW9kZSwgZmlyc3RMaW5lLCBsaW5lU2VwKSB7XFxuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgRG9jKSkgeyByZXR1cm4gbmV3IERvYyh0ZXh0LCBtb2RlLCBmaXJzdExpbmUsIGxpbmVTZXApIH1cXG4gIGlmIChmaXJzdExpbmUgPT0gbnVsbCkgeyBmaXJzdExpbmUgPSAwIH1cXG5cXG4gIEJyYW5jaENodW5rLmNhbGwodGhpcywgW25ldyBMZWFmQ2h1bmsoW25ldyBMaW5lKFxcXCJcXFwiLCBudWxsKV0pXSlcXG4gIHRoaXMuZmlyc3QgPSBmaXJzdExpbmVcXG4gIHRoaXMuc2Nyb2xsVG9wID0gdGhpcy5zY3JvbGxMZWZ0ID0gMFxcbiAgdGhpcy5jYW50RWRpdCA9IGZhbHNlXFxuICB0aGlzLmNsZWFuR2VuZXJhdGlvbiA9IDFcXG4gIHRoaXMuZnJvbnRpZXIgPSBmaXJzdExpbmVcXG4gIHZhciBzdGFydCA9IFBvcyhmaXJzdExpbmUsIDApXFxuICB0aGlzLnNlbCA9IHNpbXBsZVNlbGVjdGlvbihzdGFydClcXG4gIHRoaXMuaGlzdG9yeSA9IG5ldyBIaXN0b3J5KG51bGwpXFxuICB0aGlzLmlkID0gKytuZXh0RG9jSWRcXG4gIHRoaXMubW9kZU9wdGlvbiA9IG1vZGVcXG4gIHRoaXMubGluZVNlcCA9IGxpbmVTZXBcXG4gIHRoaXMuZXh0ZW5kID0gZmFsc2VcXG5cXG4gIGlmICh0eXBlb2YgdGV4dCA9PSBcXFwic3RyaW5nXFxcIikgeyB0ZXh0ID0gdGhpcy5zcGxpdExpbmVzKHRleHQpIH1cXG4gIHVwZGF0ZURvYyh0aGlzLCB7ZnJvbTogc3RhcnQsIHRvOiBzdGFydCwgdGV4dDogdGV4dH0pXFxuICBzZXRTZWxlY3Rpb24odGhpcywgc2ltcGxlU2VsZWN0aW9uKHN0YXJ0KSwgc2VsX2RvbnRTY3JvbGwpXFxufVxcblxcbkRvYy5wcm90b3R5cGUgPSBjcmVhdGVPYmooQnJhbmNoQ2h1bmsucHJvdG90eXBlLCB7XFxuICBjb25zdHJ1Y3RvcjogRG9jLFxcbiAgLy8gSXRlcmF0ZSBvdmVyIHRoZSBkb2N1bWVudC4gU3VwcG9ydHMgdHdvIGZvcm1zIC0tIHdpdGggb25seSBvbmVcXG4gIC8vIGFyZ3VtZW50LCBpdCBjYWxscyB0aGF0IGZvciBlYWNoIGxpbmUgaW4gdGhlIGRvY3VtZW50LiBXaXRoXFxuICAvLyB0aHJlZSwgaXQgaXRlcmF0ZXMgb3ZlciB0aGUgcmFuZ2UgZ2l2ZW4gYnkgdGhlIGZpcnN0IHR3byAod2l0aFxcbiAgLy8gdGhlIHNlY29uZCBiZWluZyBub24taW5jbHVzaXZlKS5cXG4gIGl0ZXI6IGZ1bmN0aW9uKGZyb20sIHRvLCBvcCkge1xcbiAgICBpZiAob3ApIHsgdGhpcy5pdGVyTihmcm9tIC0gdGhpcy5maXJzdCwgdG8gLSBmcm9tLCBvcCkgfVxcbiAgICBlbHNlIHsgdGhpcy5pdGVyTih0aGlzLmZpcnN0LCB0aGlzLmZpcnN0ICsgdGhpcy5zaXplLCBmcm9tKSB9XFxuICB9LFxcblxcbiAgLy8gTm9uLXB1YmxpYyBpbnRlcmZhY2UgZm9yIGFkZGluZyBhbmQgcmVtb3ZpbmcgbGluZXMuXFxuICBpbnNlcnQ6IGZ1bmN0aW9uKGF0LCBsaW5lcykge1xcbiAgICB2YXIgaGVpZ2h0ID0gMFxcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgKytpKSB7IGhlaWdodCArPSBsaW5lc1tpXS5oZWlnaHQgfVxcbiAgICB0aGlzLmluc2VydElubmVyKGF0IC0gdGhpcy5maXJzdCwgbGluZXMsIGhlaWdodClcXG4gIH0sXFxuICByZW1vdmU6IGZ1bmN0aW9uKGF0LCBuKSB7IHRoaXMucmVtb3ZlSW5uZXIoYXQgLSB0aGlzLmZpcnN0LCBuKSB9LFxcblxcbiAgLy8gRnJvbSBoZXJlLCB0aGUgbWV0aG9kcyBhcmUgcGFydCBvZiB0aGUgcHVibGljIGludGVyZmFjZS4gTW9zdFxcbiAgLy8gYXJlIGFsc28gYXZhaWxhYmxlIGZyb20gQ29kZU1pcnJvciAoZWRpdG9yKSBpbnN0YW5jZXMuXFxuXFxuICBnZXRWYWx1ZTogZnVuY3Rpb24obGluZVNlcCkge1xcbiAgICB2YXIgbGluZXMgPSBnZXRMaW5lcyh0aGlzLCB0aGlzLmZpcnN0LCB0aGlzLmZpcnN0ICsgdGhpcy5zaXplKVxcbiAgICBpZiAobGluZVNlcCA9PT0gZmFsc2UpIHsgcmV0dXJuIGxpbmVzIH1cXG4gICAgcmV0dXJuIGxpbmVzLmpvaW4obGluZVNlcCB8fCB0aGlzLmxpbmVTZXBhcmF0b3IoKSlcXG4gIH0sXFxuICBzZXRWYWx1ZTogZG9jTWV0aG9kT3AoZnVuY3Rpb24oY29kZSkge1xcbiAgICB2YXIgdG9wID0gUG9zKHRoaXMuZmlyc3QsIDApLCBsYXN0ID0gdGhpcy5maXJzdCArIHRoaXMuc2l6ZSAtIDFcXG4gICAgbWFrZUNoYW5nZSh0aGlzLCB7ZnJvbTogdG9wLCB0bzogUG9zKGxhc3QsIGdldExpbmUodGhpcywgbGFzdCkudGV4dC5sZW5ndGgpLFxcbiAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiB0aGlzLnNwbGl0TGluZXMoY29kZSksIG9yaWdpbjogXFxcInNldFZhbHVlXFxcIiwgZnVsbDogdHJ1ZX0sIHRydWUpXFxuICAgIHNldFNlbGVjdGlvbih0aGlzLCBzaW1wbGVTZWxlY3Rpb24odG9wKSlcXG4gIH0pLFxcbiAgcmVwbGFjZVJhbmdlOiBmdW5jdGlvbihjb2RlLCBmcm9tLCB0bywgb3JpZ2luKSB7XFxuICAgIGZyb20gPSBjbGlwUG9zKHRoaXMsIGZyb20pXFxuICAgIHRvID0gdG8gPyBjbGlwUG9zKHRoaXMsIHRvKSA6IGZyb21cXG4gICAgcmVwbGFjZVJhbmdlKHRoaXMsIGNvZGUsIGZyb20sIHRvLCBvcmlnaW4pXFxuICB9LFxcbiAgZ2V0UmFuZ2U6IGZ1bmN0aW9uKGZyb20sIHRvLCBsaW5lU2VwKSB7XFxuICAgIHZhciBsaW5lcyA9IGdldEJldHdlZW4odGhpcywgY2xpcFBvcyh0aGlzLCBmcm9tKSwgY2xpcFBvcyh0aGlzLCB0bykpXFxuICAgIGlmIChsaW5lU2VwID09PSBmYWxzZSkgeyByZXR1cm4gbGluZXMgfVxcbiAgICByZXR1cm4gbGluZXMuam9pbihsaW5lU2VwIHx8IHRoaXMubGluZVNlcGFyYXRvcigpKVxcbiAgfSxcXG5cXG4gIGdldExpbmU6IGZ1bmN0aW9uKGxpbmUpIHt2YXIgbCA9IHRoaXMuZ2V0TGluZUhhbmRsZShsaW5lKTsgcmV0dXJuIGwgJiYgbC50ZXh0fSxcXG5cXG4gIGdldExpbmVIYW5kbGU6IGZ1bmN0aW9uKGxpbmUpIHtpZiAoaXNMaW5lKHRoaXMsIGxpbmUpKSB7IHJldHVybiBnZXRMaW5lKHRoaXMsIGxpbmUpIH19LFxcbiAgZ2V0TGluZU51bWJlcjogZnVuY3Rpb24obGluZSkge3JldHVybiBsaW5lTm8obGluZSl9LFxcblxcbiAgZ2V0TGluZUhhbmRsZVZpc3VhbFN0YXJ0OiBmdW5jdGlvbihsaW5lKSB7XFxuICAgIGlmICh0eXBlb2YgbGluZSA9PSBcXFwibnVtYmVyXFxcIikgeyBsaW5lID0gZ2V0TGluZSh0aGlzLCBsaW5lKSB9XFxuICAgIHJldHVybiB2aXN1YWxMaW5lKGxpbmUpXFxuICB9LFxcblxcbiAgbGluZUNvdW50OiBmdW5jdGlvbigpIHtyZXR1cm4gdGhpcy5zaXplfSxcXG4gIGZpcnN0TGluZTogZnVuY3Rpb24oKSB7cmV0dXJuIHRoaXMuZmlyc3R9LFxcbiAgbGFzdExpbmU6IGZ1bmN0aW9uKCkge3JldHVybiB0aGlzLmZpcnN0ICsgdGhpcy5zaXplIC0gMX0sXFxuXFxuICBjbGlwUG9zOiBmdW5jdGlvbihwb3MpIHtyZXR1cm4gY2xpcFBvcyh0aGlzLCBwb3MpfSxcXG5cXG4gIGdldEN1cnNvcjogZnVuY3Rpb24oc3RhcnQpIHtcXG4gICAgdmFyIHJhbmdlID0gdGhpcy5zZWwucHJpbWFyeSgpLCBwb3NcXG4gICAgaWYgKHN0YXJ0ID09IG51bGwgfHwgc3RhcnQgPT0gXFxcImhlYWRcXFwiKSB7IHBvcyA9IHJhbmdlLmhlYWQgfVxcbiAgICBlbHNlIGlmIChzdGFydCA9PSBcXFwiYW5jaG9yXFxcIikgeyBwb3MgPSByYW5nZS5hbmNob3IgfVxcbiAgICBlbHNlIGlmIChzdGFydCA9PSBcXFwiZW5kXFxcIiB8fCBzdGFydCA9PSBcXFwidG9cXFwiIHx8IHN0YXJ0ID09PSBmYWxzZSkgeyBwb3MgPSByYW5nZS50bygpIH1cXG4gICAgZWxzZSB7IHBvcyA9IHJhbmdlLmZyb20oKSB9XFxuICAgIHJldHVybiBwb3NcXG4gIH0sXFxuICBsaXN0U2VsZWN0aW9uczogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLnNlbC5yYW5nZXMgfSxcXG4gIHNvbWV0aGluZ1NlbGVjdGVkOiBmdW5jdGlvbigpIHtyZXR1cm4gdGhpcy5zZWwuc29tZXRoaW5nU2VsZWN0ZWQoKX0sXFxuXFxuICBzZXRDdXJzb3I6IGRvY01ldGhvZE9wKGZ1bmN0aW9uKGxpbmUsIGNoLCBvcHRpb25zKSB7XFxuICAgIHNldFNpbXBsZVNlbGVjdGlvbih0aGlzLCBjbGlwUG9zKHRoaXMsIHR5cGVvZiBsaW5lID09IFxcXCJudW1iZXJcXFwiID8gUG9zKGxpbmUsIGNoIHx8IDApIDogbGluZSksIG51bGwsIG9wdGlvbnMpXFxuICB9KSxcXG4gIHNldFNlbGVjdGlvbjogZG9jTWV0aG9kT3AoZnVuY3Rpb24oYW5jaG9yLCBoZWFkLCBvcHRpb25zKSB7XFxuICAgIHNldFNpbXBsZVNlbGVjdGlvbih0aGlzLCBjbGlwUG9zKHRoaXMsIGFuY2hvciksIGNsaXBQb3ModGhpcywgaGVhZCB8fCBhbmNob3IpLCBvcHRpb25zKVxcbiAgfSksXFxuICBleHRlbmRTZWxlY3Rpb246IGRvY01ldGhvZE9wKGZ1bmN0aW9uKGhlYWQsIG90aGVyLCBvcHRpb25zKSB7XFxuICAgIGV4dGVuZFNlbGVjdGlvbih0aGlzLCBjbGlwUG9zKHRoaXMsIGhlYWQpLCBvdGhlciAmJiBjbGlwUG9zKHRoaXMsIG90aGVyKSwgb3B0aW9ucylcXG4gIH0pLFxcbiAgZXh0ZW5kU2VsZWN0aW9uczogZG9jTWV0aG9kT3AoZnVuY3Rpb24oaGVhZHMsIG9wdGlvbnMpIHtcXG4gICAgZXh0ZW5kU2VsZWN0aW9ucyh0aGlzLCBjbGlwUG9zQXJyYXkodGhpcywgaGVhZHMpLCBvcHRpb25zKVxcbiAgfSksXFxuICBleHRlbmRTZWxlY3Rpb25zQnk6IGRvY01ldGhvZE9wKGZ1bmN0aW9uKGYsIG9wdGlvbnMpIHtcXG4gICAgdmFyIGhlYWRzID0gbWFwKHRoaXMuc2VsLnJhbmdlcywgZilcXG4gICAgZXh0ZW5kU2VsZWN0aW9ucyh0aGlzLCBjbGlwUG9zQXJyYXkodGhpcywgaGVhZHMpLCBvcHRpb25zKVxcbiAgfSksXFxuICBzZXRTZWxlY3Rpb25zOiBkb2NNZXRob2RPcChmdW5jdGlvbihyYW5nZXMsIHByaW1hcnksIG9wdGlvbnMpIHtcXG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XFxuXFxuICAgIGlmICghcmFuZ2VzLmxlbmd0aCkgeyByZXR1cm4gfVxcbiAgICB2YXIgb3V0ID0gW11cXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCByYW5nZXMubGVuZ3RoOyBpKyspXFxuICAgICAgeyBvdXRbaV0gPSBuZXcgUmFuZ2UoY2xpcFBvcyh0aGlzJDEsIHJhbmdlc1tpXS5hbmNob3IpLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICBjbGlwUG9zKHRoaXMkMSwgcmFuZ2VzW2ldLmhlYWQpKSB9XFxuICAgIGlmIChwcmltYXJ5ID09IG51bGwpIHsgcHJpbWFyeSA9IE1hdGgubWluKHJhbmdlcy5sZW5ndGggLSAxLCB0aGlzLnNlbC5wcmltSW5kZXgpIH1cXG4gICAgc2V0U2VsZWN0aW9uKHRoaXMsIG5vcm1hbGl6ZVNlbGVjdGlvbihvdXQsIHByaW1hcnkpLCBvcHRpb25zKVxcbiAgfSksXFxuICBhZGRTZWxlY3Rpb246IGRvY01ldGhvZE9wKGZ1bmN0aW9uKGFuY2hvciwgaGVhZCwgb3B0aW9ucykge1xcbiAgICB2YXIgcmFuZ2VzID0gdGhpcy5zZWwucmFuZ2VzLnNsaWNlKDApXFxuICAgIHJhbmdlcy5wdXNoKG5ldyBSYW5nZShjbGlwUG9zKHRoaXMsIGFuY2hvciksIGNsaXBQb3ModGhpcywgaGVhZCB8fCBhbmNob3IpKSlcXG4gICAgc2V0U2VsZWN0aW9uKHRoaXMsIG5vcm1hbGl6ZVNlbGVjdGlvbihyYW5nZXMsIHJhbmdlcy5sZW5ndGggLSAxKSwgb3B0aW9ucylcXG4gIH0pLFxcblxcbiAgZ2V0U2VsZWN0aW9uOiBmdW5jdGlvbihsaW5lU2VwKSB7XFxuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xcblxcbiAgICB2YXIgcmFuZ2VzID0gdGhpcy5zZWwucmFuZ2VzLCBsaW5lc1xcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJhbmdlcy5sZW5ndGg7IGkrKykge1xcbiAgICAgIHZhciBzZWwgPSBnZXRCZXR3ZWVuKHRoaXMkMSwgcmFuZ2VzW2ldLmZyb20oKSwgcmFuZ2VzW2ldLnRvKCkpXFxuICAgICAgbGluZXMgPSBsaW5lcyA/IGxpbmVzLmNvbmNhdChzZWwpIDogc2VsXFxuICAgIH1cXG4gICAgaWYgKGxpbmVTZXAgPT09IGZhbHNlKSB7IHJldHVybiBsaW5lcyB9XFxuICAgIGVsc2UgeyByZXR1cm4gbGluZXMuam9pbihsaW5lU2VwIHx8IHRoaXMubGluZVNlcGFyYXRvcigpKSB9XFxuICB9LFxcbiAgZ2V0U2VsZWN0aW9uczogZnVuY3Rpb24obGluZVNlcCkge1xcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcXG5cXG4gICAgdmFyIHBhcnRzID0gW10sIHJhbmdlcyA9IHRoaXMuc2VsLnJhbmdlc1xcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJhbmdlcy5sZW5ndGg7IGkrKykge1xcbiAgICAgIHZhciBzZWwgPSBnZXRCZXR3ZWVuKHRoaXMkMSwgcmFuZ2VzW2ldLmZyb20oKSwgcmFuZ2VzW2ldLnRvKCkpXFxuICAgICAgaWYgKGxpbmVTZXAgIT09IGZhbHNlKSB7IHNlbCA9IHNlbC5qb2luKGxpbmVTZXAgfHwgdGhpcyQxLmxpbmVTZXBhcmF0b3IoKSkgfVxcbiAgICAgIHBhcnRzW2ldID0gc2VsXFxuICAgIH1cXG4gICAgcmV0dXJuIHBhcnRzXFxuICB9LFxcbiAgcmVwbGFjZVNlbGVjdGlvbjogZnVuY3Rpb24oY29kZSwgY29sbGFwc2UsIG9yaWdpbikge1xcbiAgICB2YXIgZHVwID0gW11cXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnNlbC5yYW5nZXMubGVuZ3RoOyBpKyspXFxuICAgICAgeyBkdXBbaV0gPSBjb2RlIH1cXG4gICAgdGhpcy5yZXBsYWNlU2VsZWN0aW9ucyhkdXAsIGNvbGxhcHNlLCBvcmlnaW4gfHwgXFxcIitpbnB1dFxcXCIpXFxuICB9LFxcbiAgcmVwbGFjZVNlbGVjdGlvbnM6IGRvY01ldGhvZE9wKGZ1bmN0aW9uKGNvZGUsIGNvbGxhcHNlLCBvcmlnaW4pIHtcXG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XFxuXFxuICAgIHZhciBjaGFuZ2VzID0gW10sIHNlbCA9IHRoaXMuc2VsXFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VsLnJhbmdlcy5sZW5ndGg7IGkrKykge1xcbiAgICAgIHZhciByYW5nZSA9IHNlbC5yYW5nZXNbaV1cXG4gICAgICBjaGFuZ2VzW2ldID0ge2Zyb206IHJhbmdlLmZyb20oKSwgdG86IHJhbmdlLnRvKCksIHRleHQ6IHRoaXMkMS5zcGxpdExpbmVzKGNvZGVbaV0pLCBvcmlnaW46IG9yaWdpbn1cXG4gICAgfVxcbiAgICB2YXIgbmV3U2VsID0gY29sbGFwc2UgJiYgY29sbGFwc2UgIT0gXFxcImVuZFxcXCIgJiYgY29tcHV0ZVJlcGxhY2VkU2VsKHRoaXMsIGNoYW5nZXMsIGNvbGxhcHNlKVxcbiAgICBmb3IgKHZhciBpJDEgPSBjaGFuZ2VzLmxlbmd0aCAtIDE7IGkkMSA+PSAwOyBpJDEtLSlcXG4gICAgICB7IG1ha2VDaGFuZ2UodGhpcyQxLCBjaGFuZ2VzW2kkMV0pIH1cXG4gICAgaWYgKG5ld1NlbCkgeyBzZXRTZWxlY3Rpb25SZXBsYWNlSGlzdG9yeSh0aGlzLCBuZXdTZWwpIH1cXG4gICAgZWxzZSBpZiAodGhpcy5jbSkgeyBlbnN1cmVDdXJzb3JWaXNpYmxlKHRoaXMuY20pIH1cXG4gIH0pLFxcbiAgdW5kbzogZG9jTWV0aG9kT3AoZnVuY3Rpb24oKSB7bWFrZUNoYW5nZUZyb21IaXN0b3J5KHRoaXMsIFxcXCJ1bmRvXFxcIil9KSxcXG4gIHJlZG86IGRvY01ldGhvZE9wKGZ1bmN0aW9uKCkge21ha2VDaGFuZ2VGcm9tSGlzdG9yeSh0aGlzLCBcXFwicmVkb1xcXCIpfSksXFxuICB1bmRvU2VsZWN0aW9uOiBkb2NNZXRob2RPcChmdW5jdGlvbigpIHttYWtlQ2hhbmdlRnJvbUhpc3RvcnkodGhpcywgXFxcInVuZG9cXFwiLCB0cnVlKX0pLFxcbiAgcmVkb1NlbGVjdGlvbjogZG9jTWV0aG9kT3AoZnVuY3Rpb24oKSB7bWFrZUNoYW5nZUZyb21IaXN0b3J5KHRoaXMsIFxcXCJyZWRvXFxcIiwgdHJ1ZSl9KSxcXG5cXG4gIHNldEV4dGVuZGluZzogZnVuY3Rpb24odmFsKSB7dGhpcy5leHRlbmQgPSB2YWx9LFxcbiAgZ2V0RXh0ZW5kaW5nOiBmdW5jdGlvbigpIHtyZXR1cm4gdGhpcy5leHRlbmR9LFxcblxcbiAgaGlzdG9yeVNpemU6IGZ1bmN0aW9uKCkge1xcbiAgICB2YXIgaGlzdCA9IHRoaXMuaGlzdG9yeSwgZG9uZSA9IDAsIHVuZG9uZSA9IDBcXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBoaXN0LmRvbmUubGVuZ3RoOyBpKyspIHsgaWYgKCFoaXN0LmRvbmVbaV0ucmFuZ2VzKSB7ICsrZG9uZSB9IH1cXG4gICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgaGlzdC51bmRvbmUubGVuZ3RoOyBpJDErKykgeyBpZiAoIWhpc3QudW5kb25lW2kkMV0ucmFuZ2VzKSB7ICsrdW5kb25lIH0gfVxcbiAgICByZXR1cm4ge3VuZG86IGRvbmUsIHJlZG86IHVuZG9uZX1cXG4gIH0sXFxuICBjbGVhckhpc3Rvcnk6IGZ1bmN0aW9uKCkge3RoaXMuaGlzdG9yeSA9IG5ldyBIaXN0b3J5KHRoaXMuaGlzdG9yeS5tYXhHZW5lcmF0aW9uKX0sXFxuXFxuICBtYXJrQ2xlYW46IGZ1bmN0aW9uKCkge1xcbiAgICB0aGlzLmNsZWFuR2VuZXJhdGlvbiA9IHRoaXMuY2hhbmdlR2VuZXJhdGlvbih0cnVlKVxcbiAgfSxcXG4gIGNoYW5nZUdlbmVyYXRpb246IGZ1bmN0aW9uKGZvcmNlU3BsaXQpIHtcXG4gICAgaWYgKGZvcmNlU3BsaXQpXFxuICAgICAgeyB0aGlzLmhpc3RvcnkubGFzdE9wID0gdGhpcy5oaXN0b3J5Lmxhc3RTZWxPcCA9IHRoaXMuaGlzdG9yeS5sYXN0T3JpZ2luID0gbnVsbCB9XFxuICAgIHJldHVybiB0aGlzLmhpc3RvcnkuZ2VuZXJhdGlvblxcbiAgfSxcXG4gIGlzQ2xlYW46IGZ1bmN0aW9uIChnZW4pIHtcXG4gICAgcmV0dXJuIHRoaXMuaGlzdG9yeS5nZW5lcmF0aW9uID09IChnZW4gfHwgdGhpcy5jbGVhbkdlbmVyYXRpb24pXFxuICB9LFxcblxcbiAgZ2V0SGlzdG9yeTogZnVuY3Rpb24oKSB7XFxuICAgIHJldHVybiB7ZG9uZTogY29weUhpc3RvcnlBcnJheSh0aGlzLmhpc3RvcnkuZG9uZSksXFxuICAgICAgICAgICAgdW5kb25lOiBjb3B5SGlzdG9yeUFycmF5KHRoaXMuaGlzdG9yeS51bmRvbmUpfVxcbiAgfSxcXG4gIHNldEhpc3Rvcnk6IGZ1bmN0aW9uKGhpc3REYXRhKSB7XFxuICAgIHZhciBoaXN0ID0gdGhpcy5oaXN0b3J5ID0gbmV3IEhpc3RvcnkodGhpcy5oaXN0b3J5Lm1heEdlbmVyYXRpb24pXFxuICAgIGhpc3QuZG9uZSA9IGNvcHlIaXN0b3J5QXJyYXkoaGlzdERhdGEuZG9uZS5zbGljZSgwKSwgbnVsbCwgdHJ1ZSlcXG4gICAgaGlzdC51bmRvbmUgPSBjb3B5SGlzdG9yeUFycmF5KGhpc3REYXRhLnVuZG9uZS5zbGljZSgwKSwgbnVsbCwgdHJ1ZSlcXG4gIH0sXFxuXFxuICBhZGRMaW5lQ2xhc3M6IGRvY01ldGhvZE9wKGZ1bmN0aW9uKGhhbmRsZSwgd2hlcmUsIGNscykge1xcbiAgICByZXR1cm4gY2hhbmdlTGluZSh0aGlzLCBoYW5kbGUsIHdoZXJlID09IFxcXCJndXR0ZXJcXFwiID8gXFxcImd1dHRlclxcXCIgOiBcXFwiY2xhc3NcXFwiLCBmdW5jdGlvbiAobGluZSkge1xcbiAgICAgIHZhciBwcm9wID0gd2hlcmUgPT0gXFxcInRleHRcXFwiID8gXFxcInRleHRDbGFzc1xcXCJcXG4gICAgICAgICAgICAgICA6IHdoZXJlID09IFxcXCJiYWNrZ3JvdW5kXFxcIiA/IFxcXCJiZ0NsYXNzXFxcIlxcbiAgICAgICAgICAgICAgIDogd2hlcmUgPT0gXFxcImd1dHRlclxcXCIgPyBcXFwiZ3V0dGVyQ2xhc3NcXFwiIDogXFxcIndyYXBDbGFzc1xcXCJcXG4gICAgICBpZiAoIWxpbmVbcHJvcF0pIHsgbGluZVtwcm9wXSA9IGNscyB9XFxuICAgICAgZWxzZSBpZiAoY2xhc3NUZXN0KGNscykudGVzdChsaW5lW3Byb3BdKSkgeyByZXR1cm4gZmFsc2UgfVxcbiAgICAgIGVsc2UgeyBsaW5lW3Byb3BdICs9IFxcXCIgXFxcIiArIGNscyB9XFxuICAgICAgcmV0dXJuIHRydWVcXG4gICAgfSlcXG4gIH0pLFxcbiAgcmVtb3ZlTGluZUNsYXNzOiBkb2NNZXRob2RPcChmdW5jdGlvbihoYW5kbGUsIHdoZXJlLCBjbHMpIHtcXG4gICAgcmV0dXJuIGNoYW5nZUxpbmUodGhpcywgaGFuZGxlLCB3aGVyZSA9PSBcXFwiZ3V0dGVyXFxcIiA/IFxcXCJndXR0ZXJcXFwiIDogXFxcImNsYXNzXFxcIiwgZnVuY3Rpb24gKGxpbmUpIHtcXG4gICAgICB2YXIgcHJvcCA9IHdoZXJlID09IFxcXCJ0ZXh0XFxcIiA/IFxcXCJ0ZXh0Q2xhc3NcXFwiXFxuICAgICAgICAgICAgICAgOiB3aGVyZSA9PSBcXFwiYmFja2dyb3VuZFxcXCIgPyBcXFwiYmdDbGFzc1xcXCJcXG4gICAgICAgICAgICAgICA6IHdoZXJlID09IFxcXCJndXR0ZXJcXFwiID8gXFxcImd1dHRlckNsYXNzXFxcIiA6IFxcXCJ3cmFwQ2xhc3NcXFwiXFxuICAgICAgdmFyIGN1ciA9IGxpbmVbcHJvcF1cXG4gICAgICBpZiAoIWN1cikgeyByZXR1cm4gZmFsc2UgfVxcbiAgICAgIGVsc2UgaWYgKGNscyA9PSBudWxsKSB7IGxpbmVbcHJvcF0gPSBudWxsIH1cXG4gICAgICBlbHNlIHtcXG4gICAgICAgIHZhciBmb3VuZCA9IGN1ci5tYXRjaChjbGFzc1Rlc3QoY2xzKSlcXG4gICAgICAgIGlmICghZm91bmQpIHsgcmV0dXJuIGZhbHNlIH1cXG4gICAgICAgIHZhciBlbmQgPSBmb3VuZC5pbmRleCArIGZvdW5kWzBdLmxlbmd0aFxcbiAgICAgICAgbGluZVtwcm9wXSA9IGN1ci5zbGljZSgwLCBmb3VuZC5pbmRleCkgKyAoIWZvdW5kLmluZGV4IHx8IGVuZCA9PSBjdXIubGVuZ3RoID8gXFxcIlxcXCIgOiBcXFwiIFxcXCIpICsgY3VyLnNsaWNlKGVuZCkgfHwgbnVsbFxcbiAgICAgIH1cXG4gICAgICByZXR1cm4gdHJ1ZVxcbiAgICB9KVxcbiAgfSksXFxuXFxuICBhZGRMaW5lV2lkZ2V0OiBkb2NNZXRob2RPcChmdW5jdGlvbihoYW5kbGUsIG5vZGUsIG9wdGlvbnMpIHtcXG4gICAgcmV0dXJuIGFkZExpbmVXaWRnZXQodGhpcywgaGFuZGxlLCBub2RlLCBvcHRpb25zKVxcbiAgfSksXFxuICByZW1vdmVMaW5lV2lkZ2V0OiBmdW5jdGlvbih3aWRnZXQpIHsgd2lkZ2V0LmNsZWFyKCkgfSxcXG5cXG4gIG1hcmtUZXh0OiBmdW5jdGlvbihmcm9tLCB0bywgb3B0aW9ucykge1xcbiAgICByZXR1cm4gbWFya1RleHQodGhpcywgY2xpcFBvcyh0aGlzLCBmcm9tKSwgY2xpcFBvcyh0aGlzLCB0byksIG9wdGlvbnMsIG9wdGlvbnMgJiYgb3B0aW9ucy50eXBlIHx8IFxcXCJyYW5nZVxcXCIpXFxuICB9LFxcbiAgc2V0Qm9va21hcms6IGZ1bmN0aW9uKHBvcywgb3B0aW9ucykge1xcbiAgICB2YXIgcmVhbE9wdHMgPSB7cmVwbGFjZWRXaXRoOiBvcHRpb25zICYmIChvcHRpb25zLm5vZGVUeXBlID09IG51bGwgPyBvcHRpb25zLndpZGdldCA6IG9wdGlvbnMpLFxcbiAgICAgICAgICAgICAgICAgICAgaW5zZXJ0TGVmdDogb3B0aW9ucyAmJiBvcHRpb25zLmluc2VydExlZnQsXFxuICAgICAgICAgICAgICAgICAgICBjbGVhcldoZW5FbXB0eTogZmFsc2UsIHNoYXJlZDogb3B0aW9ucyAmJiBvcHRpb25zLnNoYXJlZCxcXG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZU1vdXNlRXZlbnRzOiBvcHRpb25zICYmIG9wdGlvbnMuaGFuZGxlTW91c2VFdmVudHN9XFxuICAgIHBvcyA9IGNsaXBQb3ModGhpcywgcG9zKVxcbiAgICByZXR1cm4gbWFya1RleHQodGhpcywgcG9zLCBwb3MsIHJlYWxPcHRzLCBcXFwiYm9va21hcmtcXFwiKVxcbiAgfSxcXG4gIGZpbmRNYXJrc0F0OiBmdW5jdGlvbihwb3MpIHtcXG4gICAgcG9zID0gY2xpcFBvcyh0aGlzLCBwb3MpXFxuICAgIHZhciBtYXJrZXJzID0gW10sIHNwYW5zID0gZ2V0TGluZSh0aGlzLCBwb3MubGluZSkubWFya2VkU3BhbnNcXG4gICAgaWYgKHNwYW5zKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgc3BhbnMubGVuZ3RoOyArK2kpIHtcXG4gICAgICB2YXIgc3BhbiA9IHNwYW5zW2ldXFxuICAgICAgaWYgKChzcGFuLmZyb20gPT0gbnVsbCB8fCBzcGFuLmZyb20gPD0gcG9zLmNoKSAmJlxcbiAgICAgICAgICAoc3Bhbi50byA9PSBudWxsIHx8IHNwYW4udG8gPj0gcG9zLmNoKSlcXG4gICAgICAgIHsgbWFya2Vycy5wdXNoKHNwYW4ubWFya2VyLnBhcmVudCB8fCBzcGFuLm1hcmtlcikgfVxcbiAgICB9IH1cXG4gICAgcmV0dXJuIG1hcmtlcnNcXG4gIH0sXFxuICBmaW5kTWFya3M6IGZ1bmN0aW9uKGZyb20sIHRvLCBmaWx0ZXIpIHtcXG4gICAgZnJvbSA9IGNsaXBQb3ModGhpcywgZnJvbSk7IHRvID0gY2xpcFBvcyh0aGlzLCB0bylcXG4gICAgdmFyIGZvdW5kID0gW10sIGxpbmVObyA9IGZyb20ubGluZVxcbiAgICB0aGlzLml0ZXIoZnJvbS5saW5lLCB0by5saW5lICsgMSwgZnVuY3Rpb24gKGxpbmUpIHtcXG4gICAgICB2YXIgc3BhbnMgPSBsaW5lLm1hcmtlZFNwYW5zXFxuICAgICAgaWYgKHNwYW5zKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgc3BhbnMubGVuZ3RoOyBpKyspIHtcXG4gICAgICAgIHZhciBzcGFuID0gc3BhbnNbaV1cXG4gICAgICAgIGlmICghKHNwYW4udG8gIT0gbnVsbCAmJiBsaW5lTm8gPT0gZnJvbS5saW5lICYmIGZyb20uY2ggPj0gc3Bhbi50byB8fFxcbiAgICAgICAgICAgICAgc3Bhbi5mcm9tID09IG51bGwgJiYgbGluZU5vICE9IGZyb20ubGluZSB8fFxcbiAgICAgICAgICAgICAgc3Bhbi5mcm9tICE9IG51bGwgJiYgbGluZU5vID09IHRvLmxpbmUgJiYgc3Bhbi5mcm9tID49IHRvLmNoKSAmJlxcbiAgICAgICAgICAgICghZmlsdGVyIHx8IGZpbHRlcihzcGFuLm1hcmtlcikpKVxcbiAgICAgICAgICB7IGZvdW5kLnB1c2goc3Bhbi5tYXJrZXIucGFyZW50IHx8IHNwYW4ubWFya2VyKSB9XFxuICAgICAgfSB9XFxuICAgICAgKytsaW5lTm9cXG4gICAgfSlcXG4gICAgcmV0dXJuIGZvdW5kXFxuICB9LFxcbiAgZ2V0QWxsTWFya3M6IGZ1bmN0aW9uKCkge1xcbiAgICB2YXIgbWFya2VycyA9IFtdXFxuICAgIHRoaXMuaXRlcihmdW5jdGlvbiAobGluZSkge1xcbiAgICAgIHZhciBzcHMgPSBsaW5lLm1hcmtlZFNwYW5zXFxuICAgICAgaWYgKHNwcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHNwcy5sZW5ndGg7ICsraSlcXG4gICAgICAgIHsgaWYgKHNwc1tpXS5mcm9tICE9IG51bGwpIHsgbWFya2Vycy5wdXNoKHNwc1tpXS5tYXJrZXIpIH0gfSB9XFxuICAgIH0pXFxuICAgIHJldHVybiBtYXJrZXJzXFxuICB9LFxcblxcbiAgcG9zRnJvbUluZGV4OiBmdW5jdGlvbihvZmYpIHtcXG4gICAgdmFyIGNoLCBsaW5lTm8gPSB0aGlzLmZpcnN0LCBzZXBTaXplID0gdGhpcy5saW5lU2VwYXJhdG9yKCkubGVuZ3RoXFxuICAgIHRoaXMuaXRlcihmdW5jdGlvbiAobGluZSkge1xcbiAgICAgIHZhciBzeiA9IGxpbmUudGV4dC5sZW5ndGggKyBzZXBTaXplXFxuICAgICAgaWYgKHN6ID4gb2ZmKSB7IGNoID0gb2ZmOyByZXR1cm4gdHJ1ZSB9XFxuICAgICAgb2ZmIC09IHN6XFxuICAgICAgKytsaW5lTm9cXG4gICAgfSlcXG4gICAgcmV0dXJuIGNsaXBQb3ModGhpcywgUG9zKGxpbmVObywgY2gpKVxcbiAgfSxcXG4gIGluZGV4RnJvbVBvczogZnVuY3Rpb24gKGNvb3Jkcykge1xcbiAgICBjb29yZHMgPSBjbGlwUG9zKHRoaXMsIGNvb3JkcylcXG4gICAgdmFyIGluZGV4ID0gY29vcmRzLmNoXFxuICAgIGlmIChjb29yZHMubGluZSA8IHRoaXMuZmlyc3QgfHwgY29vcmRzLmNoIDwgMCkgeyByZXR1cm4gMCB9XFxuICAgIHZhciBzZXBTaXplID0gdGhpcy5saW5lU2VwYXJhdG9yKCkubGVuZ3RoXFxuICAgIHRoaXMuaXRlcih0aGlzLmZpcnN0LCBjb29yZHMubGluZSwgZnVuY3Rpb24gKGxpbmUpIHsgLy8gaXRlciBhYm9ydHMgd2hlbiBjYWxsYmFjayByZXR1cm5zIGEgdHJ1dGh5IHZhbHVlXFxuICAgICAgaW5kZXggKz0gbGluZS50ZXh0Lmxlbmd0aCArIHNlcFNpemVcXG4gICAgfSlcXG4gICAgcmV0dXJuIGluZGV4XFxuICB9LFxcblxcbiAgY29weTogZnVuY3Rpb24oY29weUhpc3RvcnkpIHtcXG4gICAgdmFyIGRvYyA9IG5ldyBEb2MoZ2V0TGluZXModGhpcywgdGhpcy5maXJzdCwgdGhpcy5maXJzdCArIHRoaXMuc2l6ZSksXFxuICAgICAgICAgICAgICAgICAgICAgIHRoaXMubW9kZU9wdGlvbiwgdGhpcy5maXJzdCwgdGhpcy5saW5lU2VwKVxcbiAgICBkb2Muc2Nyb2xsVG9wID0gdGhpcy5zY3JvbGxUb3A7IGRvYy5zY3JvbGxMZWZ0ID0gdGhpcy5zY3JvbGxMZWZ0XFxuICAgIGRvYy5zZWwgPSB0aGlzLnNlbFxcbiAgICBkb2MuZXh0ZW5kID0gZmFsc2VcXG4gICAgaWYgKGNvcHlIaXN0b3J5KSB7XFxuICAgICAgZG9jLmhpc3RvcnkudW5kb0RlcHRoID0gdGhpcy5oaXN0b3J5LnVuZG9EZXB0aFxcbiAgICAgIGRvYy5zZXRIaXN0b3J5KHRoaXMuZ2V0SGlzdG9yeSgpKVxcbiAgICB9XFxuICAgIHJldHVybiBkb2NcXG4gIH0sXFxuXFxuICBsaW5rZWREb2M6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcXG4gICAgaWYgKCFvcHRpb25zKSB7IG9wdGlvbnMgPSB7fSB9XFxuICAgIHZhciBmcm9tID0gdGhpcy5maXJzdCwgdG8gPSB0aGlzLmZpcnN0ICsgdGhpcy5zaXplXFxuICAgIGlmIChvcHRpb25zLmZyb20gIT0gbnVsbCAmJiBvcHRpb25zLmZyb20gPiBmcm9tKSB7IGZyb20gPSBvcHRpb25zLmZyb20gfVxcbiAgICBpZiAob3B0aW9ucy50byAhPSBudWxsICYmIG9wdGlvbnMudG8gPCB0bykgeyB0byA9IG9wdGlvbnMudG8gfVxcbiAgICB2YXIgY29weSA9IG5ldyBEb2MoZ2V0TGluZXModGhpcywgZnJvbSwgdG8pLCBvcHRpb25zLm1vZGUgfHwgdGhpcy5tb2RlT3B0aW9uLCBmcm9tLCB0aGlzLmxpbmVTZXApXFxuICAgIGlmIChvcHRpb25zLnNoYXJlZEhpc3QpIHsgY29weS5oaXN0b3J5ID0gdGhpcy5oaXN0b3J5XFxuICAgIDsgfSh0aGlzLmxpbmtlZCB8fCAodGhpcy5saW5rZWQgPSBbXSkpLnB1c2goe2RvYzogY29weSwgc2hhcmVkSGlzdDogb3B0aW9ucy5zaGFyZWRIaXN0fSlcXG4gICAgY29weS5saW5rZWQgPSBbe2RvYzogdGhpcywgaXNQYXJlbnQ6IHRydWUsIHNoYXJlZEhpc3Q6IG9wdGlvbnMuc2hhcmVkSGlzdH1dXFxuICAgIGNvcHlTaGFyZWRNYXJrZXJzKGNvcHksIGZpbmRTaGFyZWRNYXJrZXJzKHRoaXMpKVxcbiAgICByZXR1cm4gY29weVxcbiAgfSxcXG4gIHVubGlua0RvYzogZnVuY3Rpb24ob3RoZXIpIHtcXG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XFxuXFxuICAgIGlmIChvdGhlciBpbnN0YW5jZW9mIENvZGVNaXJyb3IpIHsgb3RoZXIgPSBvdGhlci5kb2MgfVxcbiAgICBpZiAodGhpcy5saW5rZWQpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxpbmtlZC5sZW5ndGg7ICsraSkge1xcbiAgICAgIHZhciBsaW5rID0gdGhpcyQxLmxpbmtlZFtpXVxcbiAgICAgIGlmIChsaW5rLmRvYyAhPSBvdGhlcikgeyBjb250aW51ZSB9XFxuICAgICAgdGhpcyQxLmxpbmtlZC5zcGxpY2UoaSwgMSlcXG4gICAgICBvdGhlci51bmxpbmtEb2ModGhpcyQxKVxcbiAgICAgIGRldGFjaFNoYXJlZE1hcmtlcnMoZmluZFNoYXJlZE1hcmtlcnModGhpcyQxKSlcXG4gICAgICBicmVha1xcbiAgICB9IH1cXG4gICAgLy8gSWYgdGhlIGhpc3RvcmllcyB3ZXJlIHNoYXJlZCwgc3BsaXQgdGhlbSBhZ2FpblxcbiAgICBpZiAob3RoZXIuaGlzdG9yeSA9PSB0aGlzLmhpc3RvcnkpIHtcXG4gICAgICB2YXIgc3BsaXRJZHMgPSBbb3RoZXIuaWRdXFxuICAgICAgbGlua2VkRG9jcyhvdGhlciwgZnVuY3Rpb24gKGRvYykgeyByZXR1cm4gc3BsaXRJZHMucHVzaChkb2MuaWQpOyB9LCB0cnVlKVxcbiAgICAgIG90aGVyLmhpc3RvcnkgPSBuZXcgSGlzdG9yeShudWxsKVxcbiAgICAgIG90aGVyLmhpc3RvcnkuZG9uZSA9IGNvcHlIaXN0b3J5QXJyYXkodGhpcy5oaXN0b3J5LmRvbmUsIHNwbGl0SWRzKVxcbiAgICAgIG90aGVyLmhpc3RvcnkudW5kb25lID0gY29weUhpc3RvcnlBcnJheSh0aGlzLmhpc3RvcnkudW5kb25lLCBzcGxpdElkcylcXG4gICAgfVxcbiAgfSxcXG4gIGl0ZXJMaW5rZWREb2NzOiBmdW5jdGlvbihmKSB7bGlua2VkRG9jcyh0aGlzLCBmKX0sXFxuXFxuICBnZXRNb2RlOiBmdW5jdGlvbigpIHtyZXR1cm4gdGhpcy5tb2RlfSxcXG4gIGdldEVkaXRvcjogZnVuY3Rpb24oKSB7cmV0dXJuIHRoaXMuY219LFxcblxcbiAgc3BsaXRMaW5lczogZnVuY3Rpb24oc3RyKSB7XFxuICAgIGlmICh0aGlzLmxpbmVTZXApIHsgcmV0dXJuIHN0ci5zcGxpdCh0aGlzLmxpbmVTZXApIH1cXG4gICAgcmV0dXJuIHNwbGl0TGluZXNBdXRvKHN0cilcXG4gIH0sXFxuICBsaW5lU2VwYXJhdG9yOiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMubGluZVNlcCB8fCBcXFwiXFxcXG5cXFwiIH1cXG59KVxcblxcbi8vIFB1YmxpYyBhbGlhcy5cXG5Eb2MucHJvdG90eXBlLmVhY2hMaW5lID0gRG9jLnByb3RvdHlwZS5pdGVyXFxuXFxuLy8gS2x1ZGdlIHRvIHdvcmsgYXJvdW5kIHN0cmFuZ2UgSUUgYmVoYXZpb3Igd2hlcmUgaXQnbGwgc29tZXRpbWVzXFxuLy8gcmUtZmlyZSBhIHNlcmllcyBvZiBkcmFnLXJlbGF0ZWQgZXZlbnRzIHJpZ2h0IGFmdGVyIHRoZSBkcm9wICgjMTU1MSlcXG52YXIgbGFzdERyb3AgPSAwXFxuXFxuZnVuY3Rpb24gb25Ecm9wKGUpIHtcXG4gIHZhciBjbSA9IHRoaXNcXG4gIGNsZWFyRHJhZ0N1cnNvcihjbSlcXG4gIGlmIChzaWduYWxET01FdmVudChjbSwgZSkgfHwgZXZlbnRJbldpZGdldChjbS5kaXNwbGF5LCBlKSlcXG4gICAgeyByZXR1cm4gfVxcbiAgZV9wcmV2ZW50RGVmYXVsdChlKVxcbiAgaWYgKGllKSB7IGxhc3REcm9wID0gK25ldyBEYXRlIH1cXG4gIHZhciBwb3MgPSBwb3NGcm9tTW91c2UoY20sIGUsIHRydWUpLCBmaWxlcyA9IGUuZGF0YVRyYW5zZmVyLmZpbGVzXFxuICBpZiAoIXBvcyB8fCBjbS5pc1JlYWRPbmx5KCkpIHsgcmV0dXJuIH1cXG4gIC8vIE1pZ2h0IGJlIGEgZmlsZSBkcm9wLCBpbiB3aGljaCBjYXNlIHdlIHNpbXBseSBleHRyYWN0IHRoZSB0ZXh0XFxuICAvLyBhbmQgaW5zZXJ0IGl0LlxcbiAgaWYgKGZpbGVzICYmIGZpbGVzLmxlbmd0aCAmJiB3aW5kb3cuRmlsZVJlYWRlciAmJiB3aW5kb3cuRmlsZSkge1xcbiAgICB2YXIgbiA9IGZpbGVzLmxlbmd0aCwgdGV4dCA9IEFycmF5KG4pLCByZWFkID0gMFxcbiAgICB2YXIgbG9hZEZpbGUgPSBmdW5jdGlvbiAoZmlsZSwgaSkge1xcbiAgICAgIGlmIChjbS5vcHRpb25zLmFsbG93RHJvcEZpbGVUeXBlcyAmJlxcbiAgICAgICAgICBpbmRleE9mKGNtLm9wdGlvbnMuYWxsb3dEcm9wRmlsZVR5cGVzLCBmaWxlLnR5cGUpID09IC0xKVxcbiAgICAgICAgeyByZXR1cm4gfVxcblxcbiAgICAgIHZhciByZWFkZXIgPSBuZXcgRmlsZVJlYWRlclxcbiAgICAgIHJlYWRlci5vbmxvYWQgPSBvcGVyYXRpb24oY20sIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIHZhciBjb250ZW50ID0gcmVhZGVyLnJlc3VsdFxcbiAgICAgICAgaWYgKC9bXFxcXHgwMC1cXFxceDA4XFxcXHgwZS1cXFxceDFmXXsyfS8udGVzdChjb250ZW50KSkgeyBjb250ZW50ID0gXFxcIlxcXCIgfVxcbiAgICAgICAgdGV4dFtpXSA9IGNvbnRlbnRcXG4gICAgICAgIGlmICgrK3JlYWQgPT0gbikge1xcbiAgICAgICAgICBwb3MgPSBjbGlwUG9zKGNtLmRvYywgcG9zKVxcbiAgICAgICAgICB2YXIgY2hhbmdlID0ge2Zyb206IHBvcywgdG86IHBvcyxcXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiBjbS5kb2Muc3BsaXRMaW5lcyh0ZXh0LmpvaW4oY20uZG9jLmxpbmVTZXBhcmF0b3IoKSkpLFxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbjogXFxcInBhc3RlXFxcIn1cXG4gICAgICAgICAgbWFrZUNoYW5nZShjbS5kb2MsIGNoYW5nZSlcXG4gICAgICAgICAgc2V0U2VsZWN0aW9uUmVwbGFjZUhpc3RvcnkoY20uZG9jLCBzaW1wbGVTZWxlY3Rpb24ocG9zLCBjaGFuZ2VFbmQoY2hhbmdlKSkpXFxuICAgICAgICB9XFxuICAgICAgfSlcXG4gICAgICByZWFkZXIucmVhZEFzVGV4dChmaWxlKVxcbiAgICB9XFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgKytpKSB7IGxvYWRGaWxlKGZpbGVzW2ldLCBpKSB9XFxuICB9IGVsc2UgeyAvLyBOb3JtYWwgZHJvcFxcbiAgICAvLyBEb24ndCBkbyBhIHJlcGxhY2UgaWYgdGhlIGRyb3AgaGFwcGVuZWQgaW5zaWRlIG9mIHRoZSBzZWxlY3RlZCB0ZXh0LlxcbiAgICBpZiAoY20uc3RhdGUuZHJhZ2dpbmdUZXh0ICYmIGNtLmRvYy5zZWwuY29udGFpbnMocG9zKSA+IC0xKSB7XFxuICAgICAgY20uc3RhdGUuZHJhZ2dpbmdUZXh0KGUpXFxuICAgICAgLy8gRW5zdXJlIHRoZSBlZGl0b3IgaXMgcmUtZm9jdXNlZFxcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyByZXR1cm4gY20uZGlzcGxheS5pbnB1dC5mb2N1cygpOyB9LCAyMClcXG4gICAgICByZXR1cm5cXG4gICAgfVxcbiAgICB0cnkge1xcbiAgICAgIHZhciB0ZXh0JDEgPSBlLmRhdGFUcmFuc2Zlci5nZXREYXRhKFxcXCJUZXh0XFxcIilcXG4gICAgICBpZiAodGV4dCQxKSB7XFxuICAgICAgICB2YXIgc2VsZWN0ZWRcXG4gICAgICAgIGlmIChjbS5zdGF0ZS5kcmFnZ2luZ1RleHQgJiYgIWNtLnN0YXRlLmRyYWdnaW5nVGV4dC5jb3B5KVxcbiAgICAgICAgICB7IHNlbGVjdGVkID0gY20ubGlzdFNlbGVjdGlvbnMoKSB9XFxuICAgICAgICBzZXRTZWxlY3Rpb25Ob1VuZG8oY20uZG9jLCBzaW1wbGVTZWxlY3Rpb24ocG9zLCBwb3MpKVxcbiAgICAgICAgaWYgKHNlbGVjdGVkKSB7IGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IHNlbGVjdGVkLmxlbmd0aDsgKytpJDEpXFxuICAgICAgICAgIHsgcmVwbGFjZVJhbmdlKGNtLmRvYywgXFxcIlxcXCIsIHNlbGVjdGVkW2kkMV0uYW5jaG9yLCBzZWxlY3RlZFtpJDFdLmhlYWQsIFxcXCJkcmFnXFxcIikgfSB9XFxuICAgICAgICBjbS5yZXBsYWNlU2VsZWN0aW9uKHRleHQkMSwgXFxcImFyb3VuZFxcXCIsIFxcXCJwYXN0ZVxcXCIpXFxuICAgICAgICBjbS5kaXNwbGF5LmlucHV0LmZvY3VzKClcXG4gICAgICB9XFxuICAgIH1cXG4gICAgY2F0Y2goZSl7fVxcbiAgfVxcbn1cXG5cXG5mdW5jdGlvbiBvbkRyYWdTdGFydChjbSwgZSkge1xcbiAgaWYgKGllICYmICghY20uc3RhdGUuZHJhZ2dpbmdUZXh0IHx8ICtuZXcgRGF0ZSAtIGxhc3REcm9wIDwgMTAwKSkgeyBlX3N0b3AoZSk7IHJldHVybiB9XFxuICBpZiAoc2lnbmFsRE9NRXZlbnQoY20sIGUpIHx8IGV2ZW50SW5XaWRnZXQoY20uZGlzcGxheSwgZSkpIHsgcmV0dXJuIH1cXG5cXG4gIGUuZGF0YVRyYW5zZmVyLnNldERhdGEoXFxcIlRleHRcXFwiLCBjbS5nZXRTZWxlY3Rpb24oKSlcXG4gIGUuZGF0YVRyYW5zZmVyLmVmZmVjdEFsbG93ZWQgPSBcXFwiY29weU1vdmVcXFwiXFxuXFxuICAvLyBVc2UgZHVtbXkgaW1hZ2UgaW5zdGVhZCBvZiBkZWZhdWx0IGJyb3dzZXJzIGltYWdlLlxcbiAgLy8gUmVjZW50IFNhZmFyaSAofjYuMC4yKSBoYXZlIGEgdGVuZGVuY3kgdG8gc2VnZmF1bHQgd2hlbiB0aGlzIGhhcHBlbnMsIHNvIHdlIGRvbid0IGRvIGl0IHRoZXJlLlxcbiAgaWYgKGUuZGF0YVRyYW5zZmVyLnNldERyYWdJbWFnZSAmJiAhc2FmYXJpKSB7XFxuICAgIHZhciBpbWcgPSBlbHQoXFxcImltZ1xcXCIsIG51bGwsIG51bGwsIFxcXCJwb3NpdGlvbjogZml4ZWQ7IGxlZnQ6IDA7IHRvcDogMDtcXFwiKVxcbiAgICBpbWcuc3JjID0gXFxcImRhdGE6aW1hZ2UvZ2lmO2Jhc2U2NCxSMGxHT0RsaEFRQUJBQUFBQUNINUJBRUtBQUVBTEFBQUFBQUJBQUVBQUFJQ1RBRUFPdz09XFxcIlxcbiAgICBpZiAocHJlc3RvKSB7XFxuICAgICAgaW1nLndpZHRoID0gaW1nLmhlaWdodCA9IDFcXG4gICAgICBjbS5kaXNwbGF5LndyYXBwZXIuYXBwZW5kQ2hpbGQoaW1nKVxcbiAgICAgIC8vIEZvcmNlIGEgcmVsYXlvdXQsIG9yIE9wZXJhIHdvbid0IHVzZSBvdXIgaW1hZ2UgZm9yIHNvbWUgb2JzY3VyZSByZWFzb25cXG4gICAgICBpbWcuX3RvcCA9IGltZy5vZmZzZXRUb3BcXG4gICAgfVxcbiAgICBlLmRhdGFUcmFuc2Zlci5zZXREcmFnSW1hZ2UoaW1nLCAwLCAwKVxcbiAgICBpZiAocHJlc3RvKSB7IGltZy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGltZykgfVxcbiAgfVxcbn1cXG5cXG5mdW5jdGlvbiBvbkRyYWdPdmVyKGNtLCBlKSB7XFxuICB2YXIgcG9zID0gcG9zRnJvbU1vdXNlKGNtLCBlKVxcbiAgaWYgKCFwb3MpIHsgcmV0dXJuIH1cXG4gIHZhciBmcmFnID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpXFxuICBkcmF3U2VsZWN0aW9uQ3Vyc29yKGNtLCBwb3MsIGZyYWcpXFxuICBpZiAoIWNtLmRpc3BsYXkuZHJhZ0N1cnNvcikge1xcbiAgICBjbS5kaXNwbGF5LmRyYWdDdXJzb3IgPSBlbHQoXFxcImRpdlxcXCIsIG51bGwsIFxcXCJDb2RlTWlycm9yLWN1cnNvcnMgQ29kZU1pcnJvci1kcmFnY3Vyc29yc1xcXCIpXFxuICAgIGNtLmRpc3BsYXkubGluZVNwYWNlLmluc2VydEJlZm9yZShjbS5kaXNwbGF5LmRyYWdDdXJzb3IsIGNtLmRpc3BsYXkuY3Vyc29yRGl2KVxcbiAgfVxcbiAgcmVtb3ZlQ2hpbGRyZW5BbmRBZGQoY20uZGlzcGxheS5kcmFnQ3Vyc29yLCBmcmFnKVxcbn1cXG5cXG5mdW5jdGlvbiBjbGVhckRyYWdDdXJzb3IoY20pIHtcXG4gIGlmIChjbS5kaXNwbGF5LmRyYWdDdXJzb3IpIHtcXG4gICAgY20uZGlzcGxheS5saW5lU3BhY2UucmVtb3ZlQ2hpbGQoY20uZGlzcGxheS5kcmFnQ3Vyc29yKVxcbiAgICBjbS5kaXNwbGF5LmRyYWdDdXJzb3IgPSBudWxsXFxuICB9XFxufVxcblxcbi8vIFRoZXNlIG11c3QgYmUgaGFuZGxlZCBjYXJlZnVsbHksIGJlY2F1c2UgbmFpdmVseSByZWdpc3RlcmluZyBhXFxuLy8gaGFuZGxlciBmb3IgZWFjaCBlZGl0b3Igd2lsbCBjYXVzZSB0aGUgZWRpdG9ycyB0byBuZXZlciBiZVxcbi8vIGdhcmJhZ2UgY29sbGVjdGVkLlxcblxcbmZ1bmN0aW9uIGZvckVhY2hDb2RlTWlycm9yKGYpIHtcXG4gIGlmICghZG9jdW1lbnQuYm9keS5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKSB7IHJldHVybiB9XFxuICB2YXIgYnlDbGFzcyA9IGRvY3VtZW50LmJvZHkuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShcXFwiQ29kZU1pcnJvclxcXCIpXFxuICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5Q2xhc3MubGVuZ3RoOyBpKyspIHtcXG4gICAgdmFyIGNtID0gYnlDbGFzc1tpXS5Db2RlTWlycm9yXFxuICAgIGlmIChjbSkgeyBmKGNtKSB9XFxuICB9XFxufVxcblxcbnZhciBnbG9iYWxzUmVnaXN0ZXJlZCA9IGZhbHNlXFxuZnVuY3Rpb24gZW5zdXJlR2xvYmFsSGFuZGxlcnMoKSB7XFxuICBpZiAoZ2xvYmFsc1JlZ2lzdGVyZWQpIHsgcmV0dXJuIH1cXG4gIHJlZ2lzdGVyR2xvYmFsSGFuZGxlcnMoKVxcbiAgZ2xvYmFsc1JlZ2lzdGVyZWQgPSB0cnVlXFxufVxcbmZ1bmN0aW9uIHJlZ2lzdGVyR2xvYmFsSGFuZGxlcnMoKSB7XFxuICAvLyBXaGVuIHRoZSB3aW5kb3cgcmVzaXplcywgd2UgbmVlZCB0byByZWZyZXNoIGFjdGl2ZSBlZGl0b3JzLlxcbiAgdmFyIHJlc2l6ZVRpbWVyXFxuICBvbih3aW5kb3csIFxcXCJyZXNpemVcXFwiLCBmdW5jdGlvbiAoKSB7XFxuICAgIGlmIChyZXNpemVUaW1lciA9PSBudWxsKSB7IHJlc2l6ZVRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XFxuICAgICAgcmVzaXplVGltZXIgPSBudWxsXFxuICAgICAgZm9yRWFjaENvZGVNaXJyb3Iob25SZXNpemUpXFxuICAgIH0sIDEwMCkgfVxcbiAgfSlcXG4gIC8vIFdoZW4gdGhlIHdpbmRvdyBsb3NlcyBmb2N1cywgd2Ugd2FudCB0byBzaG93IHRoZSBlZGl0b3IgYXMgYmx1cnJlZFxcbiAgb24od2luZG93LCBcXFwiYmx1clxcXCIsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZvckVhY2hDb2RlTWlycm9yKG9uQmx1cik7IH0pXFxufVxcbi8vIENhbGxlZCB3aGVuIHRoZSB3aW5kb3cgcmVzaXplc1xcbmZ1bmN0aW9uIG9uUmVzaXplKGNtKSB7XFxuICB2YXIgZCA9IGNtLmRpc3BsYXlcXG4gIGlmIChkLmxhc3RXcmFwSGVpZ2h0ID09IGQud3JhcHBlci5jbGllbnRIZWlnaHQgJiYgZC5sYXN0V3JhcFdpZHRoID09IGQud3JhcHBlci5jbGllbnRXaWR0aClcXG4gICAgeyByZXR1cm4gfVxcbiAgLy8gTWlnaHQgYmUgYSB0ZXh0IHNjYWxpbmcgb3BlcmF0aW9uLCBjbGVhciBzaXplIGNhY2hlcy5cXG4gIGQuY2FjaGVkQ2hhcldpZHRoID0gZC5jYWNoZWRUZXh0SGVpZ2h0ID0gZC5jYWNoZWRQYWRkaW5nSCA9IG51bGxcXG4gIGQuc2Nyb2xsYmFyc0NsaXBwZWQgPSBmYWxzZVxcbiAgY20uc2V0U2l6ZSgpXFxufVxcblxcbnZhciBrZXlOYW1lcyA9IHtcXG4gIDM6IFxcXCJFbnRlclxcXCIsIDg6IFxcXCJCYWNrc3BhY2VcXFwiLCA5OiBcXFwiVGFiXFxcIiwgMTM6IFxcXCJFbnRlclxcXCIsIDE2OiBcXFwiU2hpZnRcXFwiLCAxNzogXFxcIkN0cmxcXFwiLCAxODogXFxcIkFsdFxcXCIsXFxuICAxOTogXFxcIlBhdXNlXFxcIiwgMjA6IFxcXCJDYXBzTG9ja1xcXCIsIDI3OiBcXFwiRXNjXFxcIiwgMzI6IFxcXCJTcGFjZVxcXCIsIDMzOiBcXFwiUGFnZVVwXFxcIiwgMzQ6IFxcXCJQYWdlRG93blxcXCIsIDM1OiBcXFwiRW5kXFxcIixcXG4gIDM2OiBcXFwiSG9tZVxcXCIsIDM3OiBcXFwiTGVmdFxcXCIsIDM4OiBcXFwiVXBcXFwiLCAzOTogXFxcIlJpZ2h0XFxcIiwgNDA6IFxcXCJEb3duXFxcIiwgNDQ6IFxcXCJQcmludFNjcm5cXFwiLCA0NTogXFxcIkluc2VydFxcXCIsXFxuICA0NjogXFxcIkRlbGV0ZVxcXCIsIDU5OiBcXFwiO1xcXCIsIDYxOiBcXFwiPVxcXCIsIDkxOiBcXFwiTW9kXFxcIiwgOTI6IFxcXCJNb2RcXFwiLCA5MzogXFxcIk1vZFxcXCIsXFxuICAxMDY6IFxcXCIqXFxcIiwgMTA3OiBcXFwiPVxcXCIsIDEwOTogXFxcIi1cXFwiLCAxMTA6IFxcXCIuXFxcIiwgMTExOiBcXFwiL1xcXCIsIDEyNzogXFxcIkRlbGV0ZVxcXCIsXFxuICAxNzM6IFxcXCItXFxcIiwgMTg2OiBcXFwiO1xcXCIsIDE4NzogXFxcIj1cXFwiLCAxODg6IFxcXCIsXFxcIiwgMTg5OiBcXFwiLVxcXCIsIDE5MDogXFxcIi5cXFwiLCAxOTE6IFxcXCIvXFxcIiwgMTkyOiBcXFwiYFxcXCIsIDIxOTogXFxcIltcXFwiLCAyMjA6IFxcXCJcXFxcXFxcXFxcXCIsXFxuICAyMjE6IFxcXCJdXFxcIiwgMjIyOiBcXFwiJ1xcXCIsIDYzMjMyOiBcXFwiVXBcXFwiLCA2MzIzMzogXFxcIkRvd25cXFwiLCA2MzIzNDogXFxcIkxlZnRcXFwiLCA2MzIzNTogXFxcIlJpZ2h0XFxcIiwgNjMyNzI6IFxcXCJEZWxldGVcXFwiLFxcbiAgNjMyNzM6IFxcXCJIb21lXFxcIiwgNjMyNzU6IFxcXCJFbmRcXFwiLCA2MzI3NjogXFxcIlBhZ2VVcFxcXCIsIDYzMjc3OiBcXFwiUGFnZURvd25cXFwiLCA2MzMwMjogXFxcIkluc2VydFxcXCJcXG59XFxuXFxuLy8gTnVtYmVyIGtleXNcXG5mb3IgKHZhciBpID0gMDsgaSA8IDEwOyBpKyspIHsga2V5TmFtZXNbaSArIDQ4XSA9IGtleU5hbWVzW2kgKyA5Nl0gPSBTdHJpbmcoaSkgfVxcbi8vIEFscGhhYmV0aWMga2V5c1xcbmZvciAodmFyIGkkMSA9IDY1OyBpJDEgPD0gOTA7IGkkMSsrKSB7IGtleU5hbWVzW2kkMV0gPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGkkMSkgfVxcbi8vIEZ1bmN0aW9uIGtleXNcXG5mb3IgKHZhciBpJDIgPSAxOyBpJDIgPD0gMTI7IGkkMisrKSB7IGtleU5hbWVzW2kkMiArIDExMV0gPSBrZXlOYW1lc1tpJDIgKyA2MzIzNV0gPSBcXFwiRlxcXCIgKyBpJDIgfVxcblxcbnZhciBrZXlNYXAgPSB7fVxcblxcbmtleU1hcC5iYXNpYyA9IHtcXG4gIFxcXCJMZWZ0XFxcIjogXFxcImdvQ2hhckxlZnRcXFwiLCBcXFwiUmlnaHRcXFwiOiBcXFwiZ29DaGFyUmlnaHRcXFwiLCBcXFwiVXBcXFwiOiBcXFwiZ29MaW5lVXBcXFwiLCBcXFwiRG93blxcXCI6IFxcXCJnb0xpbmVEb3duXFxcIixcXG4gIFxcXCJFbmRcXFwiOiBcXFwiZ29MaW5lRW5kXFxcIiwgXFxcIkhvbWVcXFwiOiBcXFwiZ29MaW5lU3RhcnRTbWFydFxcXCIsIFxcXCJQYWdlVXBcXFwiOiBcXFwiZ29QYWdlVXBcXFwiLCBcXFwiUGFnZURvd25cXFwiOiBcXFwiZ29QYWdlRG93blxcXCIsXFxuICBcXFwiRGVsZXRlXFxcIjogXFxcImRlbENoYXJBZnRlclxcXCIsIFxcXCJCYWNrc3BhY2VcXFwiOiBcXFwiZGVsQ2hhckJlZm9yZVxcXCIsIFxcXCJTaGlmdC1CYWNrc3BhY2VcXFwiOiBcXFwiZGVsQ2hhckJlZm9yZVxcXCIsXFxuICBcXFwiVGFiXFxcIjogXFxcImRlZmF1bHRUYWJcXFwiLCBcXFwiU2hpZnQtVGFiXFxcIjogXFxcImluZGVudEF1dG9cXFwiLFxcbiAgXFxcIkVudGVyXFxcIjogXFxcIm5ld2xpbmVBbmRJbmRlbnRcXFwiLCBcXFwiSW5zZXJ0XFxcIjogXFxcInRvZ2dsZU92ZXJ3cml0ZVxcXCIsXFxuICBcXFwiRXNjXFxcIjogXFxcInNpbmdsZVNlbGVjdGlvblxcXCJcXG59XFxuLy8gTm90ZSB0aGF0IHRoZSBzYXZlIGFuZCBmaW5kLXJlbGF0ZWQgY29tbWFuZHMgYXJlbid0IGRlZmluZWQgYnlcXG4vLyBkZWZhdWx0LiBVc2VyIGNvZGUgb3IgYWRkb25zIGNhbiBkZWZpbmUgdGhlbS4gVW5rbm93biBjb21tYW5kc1xcbi8vIGFyZSBzaW1wbHkgaWdub3JlZC5cXG5rZXlNYXAucGNEZWZhdWx0ID0ge1xcbiAgXFxcIkN0cmwtQVxcXCI6IFxcXCJzZWxlY3RBbGxcXFwiLCBcXFwiQ3RybC1EXFxcIjogXFxcImRlbGV0ZUxpbmVcXFwiLCBcXFwiQ3RybC1aXFxcIjogXFxcInVuZG9cXFwiLCBcXFwiU2hpZnQtQ3RybC1aXFxcIjogXFxcInJlZG9cXFwiLCBcXFwiQ3RybC1ZXFxcIjogXFxcInJlZG9cXFwiLFxcbiAgXFxcIkN0cmwtSG9tZVxcXCI6IFxcXCJnb0RvY1N0YXJ0XFxcIiwgXFxcIkN0cmwtRW5kXFxcIjogXFxcImdvRG9jRW5kXFxcIiwgXFxcIkN0cmwtVXBcXFwiOiBcXFwiZ29MaW5lVXBcXFwiLCBcXFwiQ3RybC1Eb3duXFxcIjogXFxcImdvTGluZURvd25cXFwiLFxcbiAgXFxcIkN0cmwtTGVmdFxcXCI6IFxcXCJnb0dyb3VwTGVmdFxcXCIsIFxcXCJDdHJsLVJpZ2h0XFxcIjogXFxcImdvR3JvdXBSaWdodFxcXCIsIFxcXCJBbHQtTGVmdFxcXCI6IFxcXCJnb0xpbmVTdGFydFxcXCIsIFxcXCJBbHQtUmlnaHRcXFwiOiBcXFwiZ29MaW5lRW5kXFxcIixcXG4gIFxcXCJDdHJsLUJhY2tzcGFjZVxcXCI6IFxcXCJkZWxHcm91cEJlZm9yZVxcXCIsIFxcXCJDdHJsLURlbGV0ZVxcXCI6IFxcXCJkZWxHcm91cEFmdGVyXFxcIiwgXFxcIkN0cmwtU1xcXCI6IFxcXCJzYXZlXFxcIiwgXFxcIkN0cmwtRlxcXCI6IFxcXCJmaW5kXFxcIixcXG4gIFxcXCJDdHJsLUdcXFwiOiBcXFwiZmluZE5leHRcXFwiLCBcXFwiU2hpZnQtQ3RybC1HXFxcIjogXFxcImZpbmRQcmV2XFxcIiwgXFxcIlNoaWZ0LUN0cmwtRlxcXCI6IFxcXCJyZXBsYWNlXFxcIiwgXFxcIlNoaWZ0LUN0cmwtUlxcXCI6IFxcXCJyZXBsYWNlQWxsXFxcIixcXG4gIFxcXCJDdHJsLVtcXFwiOiBcXFwiaW5kZW50TGVzc1xcXCIsIFxcXCJDdHJsLV1cXFwiOiBcXFwiaW5kZW50TW9yZVxcXCIsXFxuICBcXFwiQ3RybC1VXFxcIjogXFxcInVuZG9TZWxlY3Rpb25cXFwiLCBcXFwiU2hpZnQtQ3RybC1VXFxcIjogXFxcInJlZG9TZWxlY3Rpb25cXFwiLCBcXFwiQWx0LVVcXFwiOiBcXFwicmVkb1NlbGVjdGlvblxcXCIsXFxuICBmYWxsdGhyb3VnaDogXFxcImJhc2ljXFxcIlxcbn1cXG4vLyBWZXJ5IGJhc2ljIHJlYWRsaW5lL2VtYWNzLXN0eWxlIGJpbmRpbmdzLCB3aGljaCBhcmUgc3RhbmRhcmQgb24gTWFjLlxcbmtleU1hcC5lbWFjc3kgPSB7XFxuICBcXFwiQ3RybC1GXFxcIjogXFxcImdvQ2hhclJpZ2h0XFxcIiwgXFxcIkN0cmwtQlxcXCI6IFxcXCJnb0NoYXJMZWZ0XFxcIiwgXFxcIkN0cmwtUFxcXCI6IFxcXCJnb0xpbmVVcFxcXCIsIFxcXCJDdHJsLU5cXFwiOiBcXFwiZ29MaW5lRG93blxcXCIsXFxuICBcXFwiQWx0LUZcXFwiOiBcXFwiZ29Xb3JkUmlnaHRcXFwiLCBcXFwiQWx0LUJcXFwiOiBcXFwiZ29Xb3JkTGVmdFxcXCIsIFxcXCJDdHJsLUFcXFwiOiBcXFwiZ29MaW5lU3RhcnRcXFwiLCBcXFwiQ3RybC1FXFxcIjogXFxcImdvTGluZUVuZFxcXCIsXFxuICBcXFwiQ3RybC1WXFxcIjogXFxcImdvUGFnZURvd25cXFwiLCBcXFwiU2hpZnQtQ3RybC1WXFxcIjogXFxcImdvUGFnZVVwXFxcIiwgXFxcIkN0cmwtRFxcXCI6IFxcXCJkZWxDaGFyQWZ0ZXJcXFwiLCBcXFwiQ3RybC1IXFxcIjogXFxcImRlbENoYXJCZWZvcmVcXFwiLFxcbiAgXFxcIkFsdC1EXFxcIjogXFxcImRlbFdvcmRBZnRlclxcXCIsIFxcXCJBbHQtQmFja3NwYWNlXFxcIjogXFxcImRlbFdvcmRCZWZvcmVcXFwiLCBcXFwiQ3RybC1LXFxcIjogXFxcImtpbGxMaW5lXFxcIiwgXFxcIkN0cmwtVFxcXCI6IFxcXCJ0cmFuc3Bvc2VDaGFyc1xcXCIsXFxuICBcXFwiQ3RybC1PXFxcIjogXFxcIm9wZW5MaW5lXFxcIlxcbn1cXG5rZXlNYXAubWFjRGVmYXVsdCA9IHtcXG4gIFxcXCJDbWQtQVxcXCI6IFxcXCJzZWxlY3RBbGxcXFwiLCBcXFwiQ21kLURcXFwiOiBcXFwiZGVsZXRlTGluZVxcXCIsIFxcXCJDbWQtWlxcXCI6IFxcXCJ1bmRvXFxcIiwgXFxcIlNoaWZ0LUNtZC1aXFxcIjogXFxcInJlZG9cXFwiLCBcXFwiQ21kLVlcXFwiOiBcXFwicmVkb1xcXCIsXFxuICBcXFwiQ21kLUhvbWVcXFwiOiBcXFwiZ29Eb2NTdGFydFxcXCIsIFxcXCJDbWQtVXBcXFwiOiBcXFwiZ29Eb2NTdGFydFxcXCIsIFxcXCJDbWQtRW5kXFxcIjogXFxcImdvRG9jRW5kXFxcIiwgXFxcIkNtZC1Eb3duXFxcIjogXFxcImdvRG9jRW5kXFxcIiwgXFxcIkFsdC1MZWZ0XFxcIjogXFxcImdvR3JvdXBMZWZ0XFxcIixcXG4gIFxcXCJBbHQtUmlnaHRcXFwiOiBcXFwiZ29Hcm91cFJpZ2h0XFxcIiwgXFxcIkNtZC1MZWZ0XFxcIjogXFxcImdvTGluZUxlZnRcXFwiLCBcXFwiQ21kLVJpZ2h0XFxcIjogXFxcImdvTGluZVJpZ2h0XFxcIiwgXFxcIkFsdC1CYWNrc3BhY2VcXFwiOiBcXFwiZGVsR3JvdXBCZWZvcmVcXFwiLFxcbiAgXFxcIkN0cmwtQWx0LUJhY2tzcGFjZVxcXCI6IFxcXCJkZWxHcm91cEFmdGVyXFxcIiwgXFxcIkFsdC1EZWxldGVcXFwiOiBcXFwiZGVsR3JvdXBBZnRlclxcXCIsIFxcXCJDbWQtU1xcXCI6IFxcXCJzYXZlXFxcIiwgXFxcIkNtZC1GXFxcIjogXFxcImZpbmRcXFwiLFxcbiAgXFxcIkNtZC1HXFxcIjogXFxcImZpbmROZXh0XFxcIiwgXFxcIlNoaWZ0LUNtZC1HXFxcIjogXFxcImZpbmRQcmV2XFxcIiwgXFxcIkNtZC1BbHQtRlxcXCI6IFxcXCJyZXBsYWNlXFxcIiwgXFxcIlNoaWZ0LUNtZC1BbHQtRlxcXCI6IFxcXCJyZXBsYWNlQWxsXFxcIixcXG4gIFxcXCJDbWQtW1xcXCI6IFxcXCJpbmRlbnRMZXNzXFxcIiwgXFxcIkNtZC1dXFxcIjogXFxcImluZGVudE1vcmVcXFwiLCBcXFwiQ21kLUJhY2tzcGFjZVxcXCI6IFxcXCJkZWxXcmFwcGVkTGluZUxlZnRcXFwiLCBcXFwiQ21kLURlbGV0ZVxcXCI6IFxcXCJkZWxXcmFwcGVkTGluZVJpZ2h0XFxcIixcXG4gIFxcXCJDbWQtVVxcXCI6IFxcXCJ1bmRvU2VsZWN0aW9uXFxcIiwgXFxcIlNoaWZ0LUNtZC1VXFxcIjogXFxcInJlZG9TZWxlY3Rpb25cXFwiLCBcXFwiQ3RybC1VcFxcXCI6IFxcXCJnb0RvY1N0YXJ0XFxcIiwgXFxcIkN0cmwtRG93blxcXCI6IFxcXCJnb0RvY0VuZFxcXCIsXFxuICBmYWxsdGhyb3VnaDogW1xcXCJiYXNpY1xcXCIsIFxcXCJlbWFjc3lcXFwiXVxcbn1cXG5rZXlNYXBbXFxcImRlZmF1bHRcXFwiXSA9IG1hYyA/IGtleU1hcC5tYWNEZWZhdWx0IDoga2V5TWFwLnBjRGVmYXVsdFxcblxcbi8vIEtFWU1BUCBESVNQQVRDSFxcblxcbmZ1bmN0aW9uIG5vcm1hbGl6ZUtleU5hbWUobmFtZSkge1xcbiAgdmFyIHBhcnRzID0gbmFtZS5zcGxpdCgvLSg/ISQpLylcXG4gIG5hbWUgPSBwYXJ0c1twYXJ0cy5sZW5ndGggLSAxXVxcbiAgdmFyIGFsdCwgY3RybCwgc2hpZnQsIGNtZFxcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJ0cy5sZW5ndGggLSAxOyBpKyspIHtcXG4gICAgdmFyIG1vZCA9IHBhcnRzW2ldXFxuICAgIGlmICgvXihjbWR8bWV0YXxtKSQvaS50ZXN0KG1vZCkpIHsgY21kID0gdHJ1ZSB9XFxuICAgIGVsc2UgaWYgKC9eYShsdCk/JC9pLnRlc3QobW9kKSkgeyBhbHQgPSB0cnVlIH1cXG4gICAgZWxzZSBpZiAoL14oY3xjdHJsfGNvbnRyb2wpJC9pLnRlc3QobW9kKSkgeyBjdHJsID0gdHJ1ZSB9XFxuICAgIGVsc2UgaWYgKC9ecyhoaWZ0KT8kL2kudGVzdChtb2QpKSB7IHNoaWZ0ID0gdHJ1ZSB9XFxuICAgIGVsc2UgeyB0aHJvdyBuZXcgRXJyb3IoXFxcIlVucmVjb2duaXplZCBtb2RpZmllciBuYW1lOiBcXFwiICsgbW9kKSB9XFxuICB9XFxuICBpZiAoYWx0KSB7IG5hbWUgPSBcXFwiQWx0LVxcXCIgKyBuYW1lIH1cXG4gIGlmIChjdHJsKSB7IG5hbWUgPSBcXFwiQ3RybC1cXFwiICsgbmFtZSB9XFxuICBpZiAoY21kKSB7IG5hbWUgPSBcXFwiQ21kLVxcXCIgKyBuYW1lIH1cXG4gIGlmIChzaGlmdCkgeyBuYW1lID0gXFxcIlNoaWZ0LVxcXCIgKyBuYW1lIH1cXG4gIHJldHVybiBuYW1lXFxufVxcblxcbi8vIFRoaXMgaXMgYSBrbHVkZ2UgdG8ga2VlcCBrZXltYXBzIG1vc3RseSB3b3JraW5nIGFzIHJhdyBvYmplY3RzXFxuLy8gKGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5KSB3aGlsZSBhdCB0aGUgc2FtZSB0aW1lIHN1cHBvcnQgZmVhdHVyZXNcXG4vLyBsaWtlIG5vcm1hbGl6YXRpb24gYW5kIG11bHRpLXN0cm9rZSBrZXkgYmluZGluZ3MuIEl0IGNvbXBpbGVzIGFcXG4vLyBuZXcgbm9ybWFsaXplZCBrZXltYXAsIGFuZCB0aGVuIHVwZGF0ZXMgdGhlIG9sZCBvYmplY3QgdG8gcmVmbGVjdFxcbi8vIHRoaXMuXFxuZnVuY3Rpb24gbm9ybWFsaXplS2V5TWFwKGtleW1hcCkge1xcbiAgdmFyIGNvcHkgPSB7fVxcbiAgZm9yICh2YXIga2V5bmFtZSBpbiBrZXltYXApIHsgaWYgKGtleW1hcC5oYXNPd25Qcm9wZXJ0eShrZXluYW1lKSkge1xcbiAgICB2YXIgdmFsdWUgPSBrZXltYXBba2V5bmFtZV1cXG4gICAgaWYgKC9eKG5hbWV8ZmFsbHRocm91Z2h8KGRlfGF0KXRhY2gpJC8udGVzdChrZXluYW1lKSkgeyBjb250aW51ZSB9XFxuICAgIGlmICh2YWx1ZSA9PSBcXFwiLi4uXFxcIikgeyBkZWxldGUga2V5bWFwW2tleW5hbWVdOyBjb250aW51ZSB9XFxuXFxuICAgIHZhciBrZXlzID0gbWFwKGtleW5hbWUuc3BsaXQoXFxcIiBcXFwiKSwgbm9ybWFsaXplS2V5TmFtZSlcXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XFxuICAgICAgdmFyIHZhbCA9IHZvaWQgMCwgbmFtZSA9IHZvaWQgMFxcbiAgICAgIGlmIChpID09IGtleXMubGVuZ3RoIC0gMSkge1xcbiAgICAgICAgbmFtZSA9IGtleXMuam9pbihcXFwiIFxcXCIpXFxuICAgICAgICB2YWwgPSB2YWx1ZVxcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBuYW1lID0ga2V5cy5zbGljZSgwLCBpICsgMSkuam9pbihcXFwiIFxcXCIpXFxuICAgICAgICB2YWwgPSBcXFwiLi4uXFxcIlxcbiAgICAgIH1cXG4gICAgICB2YXIgcHJldiA9IGNvcHlbbmFtZV1cXG4gICAgICBpZiAoIXByZXYpIHsgY29weVtuYW1lXSA9IHZhbCB9XFxuICAgICAgZWxzZSBpZiAocHJldiAhPSB2YWwpIHsgdGhyb3cgbmV3IEVycm9yKFxcXCJJbmNvbnNpc3RlbnQgYmluZGluZ3MgZm9yIFxcXCIgKyBuYW1lKSB9XFxuICAgIH1cXG4gICAgZGVsZXRlIGtleW1hcFtrZXluYW1lXVxcbiAgfSB9XFxuICBmb3IgKHZhciBwcm9wIGluIGNvcHkpIHsga2V5bWFwW3Byb3BdID0gY29weVtwcm9wXSB9XFxuICByZXR1cm4ga2V5bWFwXFxufVxcblxcbmZ1bmN0aW9uIGxvb2t1cEtleShrZXksIG1hcCwgaGFuZGxlLCBjb250ZXh0KSB7XFxuICBtYXAgPSBnZXRLZXlNYXAobWFwKVxcbiAgdmFyIGZvdW5kID0gbWFwLmNhbGwgPyBtYXAuY2FsbChrZXksIGNvbnRleHQpIDogbWFwW2tleV1cXG4gIGlmIChmb3VuZCA9PT0gZmFsc2UpIHsgcmV0dXJuIFxcXCJub3RoaW5nXFxcIiB9XFxuICBpZiAoZm91bmQgPT09IFxcXCIuLi5cXFwiKSB7IHJldHVybiBcXFwibXVsdGlcXFwiIH1cXG4gIGlmIChmb3VuZCAhPSBudWxsICYmIGhhbmRsZShmb3VuZCkpIHsgcmV0dXJuIFxcXCJoYW5kbGVkXFxcIiB9XFxuXFxuICBpZiAobWFwLmZhbGx0aHJvdWdoKSB7XFxuICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobWFwLmZhbGx0aHJvdWdoKSAhPSBcXFwiW29iamVjdCBBcnJheV1cXFwiKVxcbiAgICAgIHsgcmV0dXJuIGxvb2t1cEtleShrZXksIG1hcC5mYWxsdGhyb3VnaCwgaGFuZGxlLCBjb250ZXh0KSB9XFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWFwLmZhbGx0aHJvdWdoLmxlbmd0aDsgaSsrKSB7XFxuICAgICAgdmFyIHJlc3VsdCA9IGxvb2t1cEtleShrZXksIG1hcC5mYWxsdGhyb3VnaFtpXSwgaGFuZGxlLCBjb250ZXh0KVxcbiAgICAgIGlmIChyZXN1bHQpIHsgcmV0dXJuIHJlc3VsdCB9XFxuICAgIH1cXG4gIH1cXG59XFxuXFxuLy8gTW9kaWZpZXIga2V5IHByZXNzZXMgZG9uJ3QgY291bnQgYXMgJ3JlYWwnIGtleSBwcmVzc2VzIGZvciB0aGVcXG4vLyBwdXJwb3NlIG9mIGtleW1hcCBmYWxsdGhyb3VnaC5cXG5mdW5jdGlvbiBpc01vZGlmaWVyS2V5KHZhbHVlKSB7XFxuICB2YXIgbmFtZSA9IHR5cGVvZiB2YWx1ZSA9PSBcXFwic3RyaW5nXFxcIiA/IHZhbHVlIDoga2V5TmFtZXNbdmFsdWUua2V5Q29kZV1cXG4gIHJldHVybiBuYW1lID09IFxcXCJDdHJsXFxcIiB8fCBuYW1lID09IFxcXCJBbHRcXFwiIHx8IG5hbWUgPT0gXFxcIlNoaWZ0XFxcIiB8fCBuYW1lID09IFxcXCJNb2RcXFwiXFxufVxcblxcbi8vIExvb2sgdXAgdGhlIG5hbWUgb2YgYSBrZXkgYXMgaW5kaWNhdGVkIGJ5IGFuIGV2ZW50IG9iamVjdC5cXG5mdW5jdGlvbiBrZXlOYW1lKGV2ZW50LCBub1NoaWZ0KSB7XFxuICBpZiAocHJlc3RvICYmIGV2ZW50LmtleUNvZGUgPT0gMzQgJiYgZXZlbnRbXFxcImNoYXJcXFwiXSkgeyByZXR1cm4gZmFsc2UgfVxcbiAgdmFyIGJhc2UgPSBrZXlOYW1lc1tldmVudC5rZXlDb2RlXSwgbmFtZSA9IGJhc2VcXG4gIGlmIChuYW1lID09IG51bGwgfHwgZXZlbnQuYWx0R3JhcGhLZXkpIHsgcmV0dXJuIGZhbHNlIH1cXG4gIGlmIChldmVudC5hbHRLZXkgJiYgYmFzZSAhPSBcXFwiQWx0XFxcIikgeyBuYW1lID0gXFxcIkFsdC1cXFwiICsgbmFtZSB9XFxuICBpZiAoKGZsaXBDdHJsQ21kID8gZXZlbnQubWV0YUtleSA6IGV2ZW50LmN0cmxLZXkpICYmIGJhc2UgIT0gXFxcIkN0cmxcXFwiKSB7IG5hbWUgPSBcXFwiQ3RybC1cXFwiICsgbmFtZSB9XFxuICBpZiAoKGZsaXBDdHJsQ21kID8gZXZlbnQuY3RybEtleSA6IGV2ZW50Lm1ldGFLZXkpICYmIGJhc2UgIT0gXFxcIkNtZFxcXCIpIHsgbmFtZSA9IFxcXCJDbWQtXFxcIiArIG5hbWUgfVxcbiAgaWYgKCFub1NoaWZ0ICYmIGV2ZW50LnNoaWZ0S2V5ICYmIGJhc2UgIT0gXFxcIlNoaWZ0XFxcIikgeyBuYW1lID0gXFxcIlNoaWZ0LVxcXCIgKyBuYW1lIH1cXG4gIHJldHVybiBuYW1lXFxufVxcblxcbmZ1bmN0aW9uIGdldEtleU1hcCh2YWwpIHtcXG4gIHJldHVybiB0eXBlb2YgdmFsID09IFxcXCJzdHJpbmdcXFwiID8ga2V5TWFwW3ZhbF0gOiB2YWxcXG59XFxuXFxuLy8gSGVscGVyIGZvciBkZWxldGluZyB0ZXh0IG5lYXIgdGhlIHNlbGVjdGlvbihzKSwgdXNlZCB0byBpbXBsZW1lbnRcXG4vLyBiYWNrc3BhY2UsIGRlbGV0ZSwgYW5kIHNpbWlsYXIgZnVuY3Rpb25hbGl0eS5cXG5mdW5jdGlvbiBkZWxldGVOZWFyU2VsZWN0aW9uKGNtLCBjb21wdXRlKSB7XFxuICB2YXIgcmFuZ2VzID0gY20uZG9jLnNlbC5yYW5nZXMsIGtpbGwgPSBbXVxcbiAgLy8gQnVpbGQgdXAgYSBzZXQgb2YgcmFuZ2VzIHRvIGtpbGwgZmlyc3QsIG1lcmdpbmcgb3ZlcmxhcHBpbmdcXG4gIC8vIHJhbmdlcy5cXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcmFuZ2VzLmxlbmd0aDsgaSsrKSB7XFxuICAgIHZhciB0b0tpbGwgPSBjb21wdXRlKHJhbmdlc1tpXSlcXG4gICAgd2hpbGUgKGtpbGwubGVuZ3RoICYmIGNtcCh0b0tpbGwuZnJvbSwgbHN0KGtpbGwpLnRvKSA8PSAwKSB7XFxuICAgICAgdmFyIHJlcGxhY2VkID0ga2lsbC5wb3AoKVxcbiAgICAgIGlmIChjbXAocmVwbGFjZWQuZnJvbSwgdG9LaWxsLmZyb20pIDwgMCkge1xcbiAgICAgICAgdG9LaWxsLmZyb20gPSByZXBsYWNlZC5mcm9tXFxuICAgICAgICBicmVha1xcbiAgICAgIH1cXG4gICAgfVxcbiAgICBraWxsLnB1c2godG9LaWxsKVxcbiAgfVxcbiAgLy8gTmV4dCwgcmVtb3ZlIHRob3NlIGFjdHVhbCByYW5nZXMuXFxuICBydW5Jbk9wKGNtLCBmdW5jdGlvbiAoKSB7XFxuICAgIGZvciAodmFyIGkgPSBraWxsLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxcbiAgICAgIHsgcmVwbGFjZVJhbmdlKGNtLmRvYywgXFxcIlxcXCIsIGtpbGxbaV0uZnJvbSwga2lsbFtpXS50bywgXFxcIitkZWxldGVcXFwiKSB9XFxuICAgIGVuc3VyZUN1cnNvclZpc2libGUoY20pXFxuICB9KVxcbn1cXG5cXG4vLyBDb21tYW5kcyBhcmUgcGFyYW1ldGVyLWxlc3MgYWN0aW9ucyB0aGF0IGNhbiBiZSBwZXJmb3JtZWQgb24gYW5cXG4vLyBlZGl0b3IsIG1vc3RseSB1c2VkIGZvciBrZXliaW5kaW5ncy5cXG52YXIgY29tbWFuZHMgPSB7XFxuICBzZWxlY3RBbGw6IHNlbGVjdEFsbCxcXG4gIHNpbmdsZVNlbGVjdGlvbjogZnVuY3Rpb24gKGNtKSB7IHJldHVybiBjbS5zZXRTZWxlY3Rpb24oY20uZ2V0Q3Vyc29yKFxcXCJhbmNob3JcXFwiKSwgY20uZ2V0Q3Vyc29yKFxcXCJoZWFkXFxcIiksIHNlbF9kb250U2Nyb2xsKTsgfSxcXG4gIGtpbGxMaW5lOiBmdW5jdGlvbiAoY20pIHsgcmV0dXJuIGRlbGV0ZU5lYXJTZWxlY3Rpb24oY20sIGZ1bmN0aW9uIChyYW5nZSkge1xcbiAgICBpZiAocmFuZ2UuZW1wdHkoKSkge1xcbiAgICAgIHZhciBsZW4gPSBnZXRMaW5lKGNtLmRvYywgcmFuZ2UuaGVhZC5saW5lKS50ZXh0Lmxlbmd0aFxcbiAgICAgIGlmIChyYW5nZS5oZWFkLmNoID09IGxlbiAmJiByYW5nZS5oZWFkLmxpbmUgPCBjbS5sYXN0TGluZSgpKVxcbiAgICAgICAgeyByZXR1cm4ge2Zyb206IHJhbmdlLmhlYWQsIHRvOiBQb3MocmFuZ2UuaGVhZC5saW5lICsgMSwgMCl9IH1cXG4gICAgICBlbHNlXFxuICAgICAgICB7IHJldHVybiB7ZnJvbTogcmFuZ2UuaGVhZCwgdG86IFBvcyhyYW5nZS5oZWFkLmxpbmUsIGxlbil9IH1cXG4gICAgfSBlbHNlIHtcXG4gICAgICByZXR1cm4ge2Zyb206IHJhbmdlLmZyb20oKSwgdG86IHJhbmdlLnRvKCl9XFxuICAgIH1cXG4gIH0pOyB9LFxcbiAgZGVsZXRlTGluZTogZnVuY3Rpb24gKGNtKSB7IHJldHVybiBkZWxldGVOZWFyU2VsZWN0aW9uKGNtLCBmdW5jdGlvbiAocmFuZ2UpIHsgcmV0dXJuICh7XFxuICAgIGZyb206IFBvcyhyYW5nZS5mcm9tKCkubGluZSwgMCksXFxuICAgIHRvOiBjbGlwUG9zKGNtLmRvYywgUG9zKHJhbmdlLnRvKCkubGluZSArIDEsIDApKVxcbiAgfSk7IH0pOyB9LFxcbiAgZGVsTGluZUxlZnQ6IGZ1bmN0aW9uIChjbSkgeyByZXR1cm4gZGVsZXRlTmVhclNlbGVjdGlvbihjbSwgZnVuY3Rpb24gKHJhbmdlKSB7IHJldHVybiAoe1xcbiAgICBmcm9tOiBQb3MocmFuZ2UuZnJvbSgpLmxpbmUsIDApLCB0bzogcmFuZ2UuZnJvbSgpXFxuICB9KTsgfSk7IH0sXFxuICBkZWxXcmFwcGVkTGluZUxlZnQ6IGZ1bmN0aW9uIChjbSkgeyByZXR1cm4gZGVsZXRlTmVhclNlbGVjdGlvbihjbSwgZnVuY3Rpb24gKHJhbmdlKSB7XFxuICAgIHZhciB0b3AgPSBjbS5jaGFyQ29vcmRzKHJhbmdlLmhlYWQsIFxcXCJkaXZcXFwiKS50b3AgKyA1XFxuICAgIHZhciBsZWZ0UG9zID0gY20uY29vcmRzQ2hhcih7bGVmdDogMCwgdG9wOiB0b3B9LCBcXFwiZGl2XFxcIilcXG4gICAgcmV0dXJuIHtmcm9tOiBsZWZ0UG9zLCB0bzogcmFuZ2UuZnJvbSgpfVxcbiAgfSk7IH0sXFxuICBkZWxXcmFwcGVkTGluZVJpZ2h0OiBmdW5jdGlvbiAoY20pIHsgcmV0dXJuIGRlbGV0ZU5lYXJTZWxlY3Rpb24oY20sIGZ1bmN0aW9uIChyYW5nZSkge1xcbiAgICB2YXIgdG9wID0gY20uY2hhckNvb3JkcyhyYW5nZS5oZWFkLCBcXFwiZGl2XFxcIikudG9wICsgNVxcbiAgICB2YXIgcmlnaHRQb3MgPSBjbS5jb29yZHNDaGFyKHtsZWZ0OiBjbS5kaXNwbGF5LmxpbmVEaXYub2Zmc2V0V2lkdGggKyAxMDAsIHRvcDogdG9wfSwgXFxcImRpdlxcXCIpXFxuICAgIHJldHVybiB7ZnJvbTogcmFuZ2UuZnJvbSgpLCB0bzogcmlnaHRQb3MgfVxcbiAgfSk7IH0sXFxuICB1bmRvOiBmdW5jdGlvbiAoY20pIHsgcmV0dXJuIGNtLnVuZG8oKTsgfSxcXG4gIHJlZG86IGZ1bmN0aW9uIChjbSkgeyByZXR1cm4gY20ucmVkbygpOyB9LFxcbiAgdW5kb1NlbGVjdGlvbjogZnVuY3Rpb24gKGNtKSB7IHJldHVybiBjbS51bmRvU2VsZWN0aW9uKCk7IH0sXFxuICByZWRvU2VsZWN0aW9uOiBmdW5jdGlvbiAoY20pIHsgcmV0dXJuIGNtLnJlZG9TZWxlY3Rpb24oKTsgfSxcXG4gIGdvRG9jU3RhcnQ6IGZ1bmN0aW9uIChjbSkgeyByZXR1cm4gY20uZXh0ZW5kU2VsZWN0aW9uKFBvcyhjbS5maXJzdExpbmUoKSwgMCkpOyB9LFxcbiAgZ29Eb2NFbmQ6IGZ1bmN0aW9uIChjbSkgeyByZXR1cm4gY20uZXh0ZW5kU2VsZWN0aW9uKFBvcyhjbS5sYXN0TGluZSgpKSk7IH0sXFxuICBnb0xpbmVTdGFydDogZnVuY3Rpb24gKGNtKSB7IHJldHVybiBjbS5leHRlbmRTZWxlY3Rpb25zQnkoZnVuY3Rpb24gKHJhbmdlKSB7IHJldHVybiBsaW5lU3RhcnQoY20sIHJhbmdlLmhlYWQubGluZSk7IH0sXFxuICAgIHtvcmlnaW46IFxcXCIrbW92ZVxcXCIsIGJpYXM6IDF9XFxuICApOyB9LFxcbiAgZ29MaW5lU3RhcnRTbWFydDogZnVuY3Rpb24gKGNtKSB7IHJldHVybiBjbS5leHRlbmRTZWxlY3Rpb25zQnkoZnVuY3Rpb24gKHJhbmdlKSB7IHJldHVybiBsaW5lU3RhcnRTbWFydChjbSwgcmFuZ2UuaGVhZCk7IH0sXFxuICAgIHtvcmlnaW46IFxcXCIrbW92ZVxcXCIsIGJpYXM6IDF9XFxuICApOyB9LFxcbiAgZ29MaW5lRW5kOiBmdW5jdGlvbiAoY20pIHsgcmV0dXJuIGNtLmV4dGVuZFNlbGVjdGlvbnNCeShmdW5jdGlvbiAocmFuZ2UpIHsgcmV0dXJuIGxpbmVFbmQoY20sIHJhbmdlLmhlYWQubGluZSk7IH0sXFxuICAgIHtvcmlnaW46IFxcXCIrbW92ZVxcXCIsIGJpYXM6IC0xfVxcbiAgKTsgfSxcXG4gIGdvTGluZVJpZ2h0OiBmdW5jdGlvbiAoY20pIHsgcmV0dXJuIGNtLmV4dGVuZFNlbGVjdGlvbnNCeShmdW5jdGlvbiAocmFuZ2UpIHtcXG4gICAgdmFyIHRvcCA9IGNtLmNoYXJDb29yZHMocmFuZ2UuaGVhZCwgXFxcImRpdlxcXCIpLnRvcCArIDVcXG4gICAgcmV0dXJuIGNtLmNvb3Jkc0NoYXIoe2xlZnQ6IGNtLmRpc3BsYXkubGluZURpdi5vZmZzZXRXaWR0aCArIDEwMCwgdG9wOiB0b3B9LCBcXFwiZGl2XFxcIilcXG4gIH0sIHNlbF9tb3ZlKTsgfSxcXG4gIGdvTGluZUxlZnQ6IGZ1bmN0aW9uIChjbSkgeyByZXR1cm4gY20uZXh0ZW5kU2VsZWN0aW9uc0J5KGZ1bmN0aW9uIChyYW5nZSkge1xcbiAgICB2YXIgdG9wID0gY20uY2hhckNvb3JkcyhyYW5nZS5oZWFkLCBcXFwiZGl2XFxcIikudG9wICsgNVxcbiAgICByZXR1cm4gY20uY29vcmRzQ2hhcih7bGVmdDogMCwgdG9wOiB0b3B9LCBcXFwiZGl2XFxcIilcXG4gIH0sIHNlbF9tb3ZlKTsgfSxcXG4gIGdvTGluZUxlZnRTbWFydDogZnVuY3Rpb24gKGNtKSB7IHJldHVybiBjbS5leHRlbmRTZWxlY3Rpb25zQnkoZnVuY3Rpb24gKHJhbmdlKSB7XFxuICAgIHZhciB0b3AgPSBjbS5jaGFyQ29vcmRzKHJhbmdlLmhlYWQsIFxcXCJkaXZcXFwiKS50b3AgKyA1XFxuICAgIHZhciBwb3MgPSBjbS5jb29yZHNDaGFyKHtsZWZ0OiAwLCB0b3A6IHRvcH0sIFxcXCJkaXZcXFwiKVxcbiAgICBpZiAocG9zLmNoIDwgY20uZ2V0TGluZShwb3MubGluZSkuc2VhcmNoKC9cXFxcUy8pKSB7IHJldHVybiBsaW5lU3RhcnRTbWFydChjbSwgcmFuZ2UuaGVhZCkgfVxcbiAgICByZXR1cm4gcG9zXFxuICB9LCBzZWxfbW92ZSk7IH0sXFxuICBnb0xpbmVVcDogZnVuY3Rpb24gKGNtKSB7IHJldHVybiBjbS5tb3ZlVigtMSwgXFxcImxpbmVcXFwiKTsgfSxcXG4gIGdvTGluZURvd246IGZ1bmN0aW9uIChjbSkgeyByZXR1cm4gY20ubW92ZVYoMSwgXFxcImxpbmVcXFwiKTsgfSxcXG4gIGdvUGFnZVVwOiBmdW5jdGlvbiAoY20pIHsgcmV0dXJuIGNtLm1vdmVWKC0xLCBcXFwicGFnZVxcXCIpOyB9LFxcbiAgZ29QYWdlRG93bjogZnVuY3Rpb24gKGNtKSB7IHJldHVybiBjbS5tb3ZlVigxLCBcXFwicGFnZVxcXCIpOyB9LFxcbiAgZ29DaGFyTGVmdDogZnVuY3Rpb24gKGNtKSB7IHJldHVybiBjbS5tb3ZlSCgtMSwgXFxcImNoYXJcXFwiKTsgfSxcXG4gIGdvQ2hhclJpZ2h0OiBmdW5jdGlvbiAoY20pIHsgcmV0dXJuIGNtLm1vdmVIKDEsIFxcXCJjaGFyXFxcIik7IH0sXFxuICBnb0NvbHVtbkxlZnQ6IGZ1bmN0aW9uIChjbSkgeyByZXR1cm4gY20ubW92ZUgoLTEsIFxcXCJjb2x1bW5cXFwiKTsgfSxcXG4gIGdvQ29sdW1uUmlnaHQ6IGZ1bmN0aW9uIChjbSkgeyByZXR1cm4gY20ubW92ZUgoMSwgXFxcImNvbHVtblxcXCIpOyB9LFxcbiAgZ29Xb3JkTGVmdDogZnVuY3Rpb24gKGNtKSB7IHJldHVybiBjbS5tb3ZlSCgtMSwgXFxcIndvcmRcXFwiKTsgfSxcXG4gIGdvR3JvdXBSaWdodDogZnVuY3Rpb24gKGNtKSB7IHJldHVybiBjbS5tb3ZlSCgxLCBcXFwiZ3JvdXBcXFwiKTsgfSxcXG4gIGdvR3JvdXBMZWZ0OiBmdW5jdGlvbiAoY20pIHsgcmV0dXJuIGNtLm1vdmVIKC0xLCBcXFwiZ3JvdXBcXFwiKTsgfSxcXG4gIGdvV29yZFJpZ2h0OiBmdW5jdGlvbiAoY20pIHsgcmV0dXJuIGNtLm1vdmVIKDEsIFxcXCJ3b3JkXFxcIik7IH0sXFxuICBkZWxDaGFyQmVmb3JlOiBmdW5jdGlvbiAoY20pIHsgcmV0dXJuIGNtLmRlbGV0ZUgoLTEsIFxcXCJjaGFyXFxcIik7IH0sXFxuICBkZWxDaGFyQWZ0ZXI6IGZ1bmN0aW9uIChjbSkgeyByZXR1cm4gY20uZGVsZXRlSCgxLCBcXFwiY2hhclxcXCIpOyB9LFxcbiAgZGVsV29yZEJlZm9yZTogZnVuY3Rpb24gKGNtKSB7IHJldHVybiBjbS5kZWxldGVIKC0xLCBcXFwid29yZFxcXCIpOyB9LFxcbiAgZGVsV29yZEFmdGVyOiBmdW5jdGlvbiAoY20pIHsgcmV0dXJuIGNtLmRlbGV0ZUgoMSwgXFxcIndvcmRcXFwiKTsgfSxcXG4gIGRlbEdyb3VwQmVmb3JlOiBmdW5jdGlvbiAoY20pIHsgcmV0dXJuIGNtLmRlbGV0ZUgoLTEsIFxcXCJncm91cFxcXCIpOyB9LFxcbiAgZGVsR3JvdXBBZnRlcjogZnVuY3Rpb24gKGNtKSB7IHJldHVybiBjbS5kZWxldGVIKDEsIFxcXCJncm91cFxcXCIpOyB9LFxcbiAgaW5kZW50QXV0bzogZnVuY3Rpb24gKGNtKSB7IHJldHVybiBjbS5pbmRlbnRTZWxlY3Rpb24oXFxcInNtYXJ0XFxcIik7IH0sXFxuICBpbmRlbnRNb3JlOiBmdW5jdGlvbiAoY20pIHsgcmV0dXJuIGNtLmluZGVudFNlbGVjdGlvbihcXFwiYWRkXFxcIik7IH0sXFxuICBpbmRlbnRMZXNzOiBmdW5jdGlvbiAoY20pIHsgcmV0dXJuIGNtLmluZGVudFNlbGVjdGlvbihcXFwic3VidHJhY3RcXFwiKTsgfSxcXG4gIGluc2VydFRhYjogZnVuY3Rpb24gKGNtKSB7IHJldHVybiBjbS5yZXBsYWNlU2VsZWN0aW9uKFxcXCJcXFxcdFxcXCIpOyB9LFxcbiAgaW5zZXJ0U29mdFRhYjogZnVuY3Rpb24gKGNtKSB7XFxuICAgIHZhciBzcGFjZXMgPSBbXSwgcmFuZ2VzID0gY20ubGlzdFNlbGVjdGlvbnMoKSwgdGFiU2l6ZSA9IGNtLm9wdGlvbnMudGFiU2l6ZVxcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJhbmdlcy5sZW5ndGg7IGkrKykge1xcbiAgICAgIHZhciBwb3MgPSByYW5nZXNbaV0uZnJvbSgpXFxuICAgICAgdmFyIGNvbCA9IGNvdW50Q29sdW1uKGNtLmdldExpbmUocG9zLmxpbmUpLCBwb3MuY2gsIHRhYlNpemUpXFxuICAgICAgc3BhY2VzLnB1c2goc3BhY2VTdHIodGFiU2l6ZSAtIGNvbCAlIHRhYlNpemUpKVxcbiAgICB9XFxuICAgIGNtLnJlcGxhY2VTZWxlY3Rpb25zKHNwYWNlcylcXG4gIH0sXFxuICBkZWZhdWx0VGFiOiBmdW5jdGlvbiAoY20pIHtcXG4gICAgaWYgKGNtLnNvbWV0aGluZ1NlbGVjdGVkKCkpIHsgY20uaW5kZW50U2VsZWN0aW9uKFxcXCJhZGRcXFwiKSB9XFxuICAgIGVsc2UgeyBjbS5leGVjQ29tbWFuZChcXFwiaW5zZXJ0VGFiXFxcIikgfVxcbiAgfSxcXG4gIC8vIFN3YXAgdGhlIHR3byBjaGFycyBsZWZ0IGFuZCByaWdodCBvZiBlYWNoIHNlbGVjdGlvbidzIGhlYWQuXFxuICAvLyBNb3ZlIGN1cnNvciBiZWhpbmQgdGhlIHR3byBzd2FwcGVkIGNoYXJhY3RlcnMgYWZ0ZXJ3YXJkcy5cXG4gIC8vXFxuICAvLyBEb2Vzbid0IGNvbnNpZGVyIGxpbmUgZmVlZHMgYSBjaGFyYWN0ZXIuXFxuICAvLyBEb2Vzbid0IHNjYW4gbW9yZSB0aGFuIG9uZSBsaW5lIGFib3ZlIHRvIGZpbmQgYSBjaGFyYWN0ZXIuXFxuICAvLyBEb2Vzbid0IGRvIGFueXRoaW5nIG9uIGFuIGVtcHR5IGxpbmUuXFxuICAvLyBEb2Vzbid0IGRvIGFueXRoaW5nIHdpdGggbm9uLWVtcHR5IHNlbGVjdGlvbnMuXFxuICB0cmFuc3Bvc2VDaGFyczogZnVuY3Rpb24gKGNtKSB7IHJldHVybiBydW5Jbk9wKGNtLCBmdW5jdGlvbiAoKSB7XFxuICAgIHZhciByYW5nZXMgPSBjbS5saXN0U2VsZWN0aW9ucygpLCBuZXdTZWwgPSBbXVxcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJhbmdlcy5sZW5ndGg7IGkrKykge1xcbiAgICAgIGlmICghcmFuZ2VzW2ldLmVtcHR5KCkpIHsgY29udGludWUgfVxcbiAgICAgIHZhciBjdXIgPSByYW5nZXNbaV0uaGVhZCwgbGluZSA9IGdldExpbmUoY20uZG9jLCBjdXIubGluZSkudGV4dFxcbiAgICAgIGlmIChsaW5lKSB7XFxuICAgICAgICBpZiAoY3VyLmNoID09IGxpbmUubGVuZ3RoKSB7IGN1ciA9IG5ldyBQb3MoY3VyLmxpbmUsIGN1ci5jaCAtIDEpIH1cXG4gICAgICAgIGlmIChjdXIuY2ggPiAwKSB7XFxuICAgICAgICAgIGN1ciA9IG5ldyBQb3MoY3VyLmxpbmUsIGN1ci5jaCArIDEpXFxuICAgICAgICAgIGNtLnJlcGxhY2VSYW5nZShsaW5lLmNoYXJBdChjdXIuY2ggLSAxKSArIGxpbmUuY2hhckF0KGN1ci5jaCAtIDIpLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgUG9zKGN1ci5saW5lLCBjdXIuY2ggLSAyKSwgY3VyLCBcXFwiK3RyYW5zcG9zZVxcXCIpXFxuICAgICAgICB9IGVsc2UgaWYgKGN1ci5saW5lID4gY20uZG9jLmZpcnN0KSB7XFxuICAgICAgICAgIHZhciBwcmV2ID0gZ2V0TGluZShjbS5kb2MsIGN1ci5saW5lIC0gMSkudGV4dFxcbiAgICAgICAgICBpZiAocHJldikge1xcbiAgICAgICAgICAgIGN1ciA9IG5ldyBQb3MoY3VyLmxpbmUsIDEpXFxuICAgICAgICAgICAgY20ucmVwbGFjZVJhbmdlKGxpbmUuY2hhckF0KDApICsgY20uZG9jLmxpbmVTZXBhcmF0b3IoKSArXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZXYuY2hhckF0KHByZXYubGVuZ3RoIC0gMSksXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFBvcyhjdXIubGluZSAtIDEsIHByZXYubGVuZ3RoIC0gMSksIGN1ciwgXFxcIit0cmFuc3Bvc2VcXFwiKVxcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICAgIG5ld1NlbC5wdXNoKG5ldyBSYW5nZShjdXIsIGN1cikpXFxuICAgIH1cXG4gICAgY20uc2V0U2VsZWN0aW9ucyhuZXdTZWwpXFxuICB9KTsgfSxcXG4gIG5ld2xpbmVBbmRJbmRlbnQ6IGZ1bmN0aW9uIChjbSkgeyByZXR1cm4gcnVuSW5PcChjbSwgZnVuY3Rpb24gKCkge1xcbiAgICB2YXIgc2VscyA9IGNtLmxpc3RTZWxlY3Rpb25zKClcXG4gICAgZm9yICh2YXIgaSA9IHNlbHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pXFxuICAgICAgeyBjbS5yZXBsYWNlUmFuZ2UoY20uZG9jLmxpbmVTZXBhcmF0b3IoKSwgc2Vsc1tpXS5hbmNob3IsIHNlbHNbaV0uaGVhZCwgXFxcIitpbnB1dFxcXCIpIH1cXG4gICAgc2VscyA9IGNtLmxpc3RTZWxlY3Rpb25zKClcXG4gICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgc2Vscy5sZW5ndGg7IGkkMSsrKVxcbiAgICAgIHsgY20uaW5kZW50TGluZShzZWxzW2kkMV0uZnJvbSgpLmxpbmUsIG51bGwsIHRydWUpIH1cXG4gICAgZW5zdXJlQ3Vyc29yVmlzaWJsZShjbSlcXG4gIH0pOyB9LFxcbiAgb3BlbkxpbmU6IGZ1bmN0aW9uIChjbSkgeyByZXR1cm4gY20ucmVwbGFjZVNlbGVjdGlvbihcXFwiXFxcXG5cXFwiLCBcXFwic3RhcnRcXFwiKTsgfSxcXG4gIHRvZ2dsZU92ZXJ3cml0ZTogZnVuY3Rpb24gKGNtKSB7IHJldHVybiBjbS50b2dnbGVPdmVyd3JpdGUoKTsgfVxcbn1cXG5cXG5cXG5mdW5jdGlvbiBsaW5lU3RhcnQoY20sIGxpbmVOKSB7XFxuICB2YXIgbGluZSA9IGdldExpbmUoY20uZG9jLCBsaW5lTilcXG4gIHZhciB2aXN1YWwgPSB2aXN1YWxMaW5lKGxpbmUpXFxuICBpZiAodmlzdWFsICE9IGxpbmUpIHsgbGluZU4gPSBsaW5lTm8odmlzdWFsKSB9XFxuICB2YXIgb3JkZXIgPSBnZXRPcmRlcih2aXN1YWwpXFxuICB2YXIgY2ggPSAhb3JkZXIgPyAwIDogb3JkZXJbMF0ubGV2ZWwgJSAyID8gbGluZVJpZ2h0KHZpc3VhbCkgOiBsaW5lTGVmdCh2aXN1YWwpXFxuICByZXR1cm4gUG9zKGxpbmVOLCBjaClcXG59XFxuZnVuY3Rpb24gbGluZUVuZChjbSwgbGluZU4pIHtcXG4gIHZhciBtZXJnZWQsIGxpbmUgPSBnZXRMaW5lKGNtLmRvYywgbGluZU4pXFxuICB3aGlsZSAobWVyZ2VkID0gY29sbGFwc2VkU3BhbkF0RW5kKGxpbmUpKSB7XFxuICAgIGxpbmUgPSBtZXJnZWQuZmluZCgxLCB0cnVlKS5saW5lXFxuICAgIGxpbmVOID0gbnVsbFxcbiAgfVxcbiAgdmFyIG9yZGVyID0gZ2V0T3JkZXIobGluZSlcXG4gIHZhciBjaCA9ICFvcmRlciA/IGxpbmUudGV4dC5sZW5ndGggOiBvcmRlclswXS5sZXZlbCAlIDIgPyBsaW5lTGVmdChsaW5lKSA6IGxpbmVSaWdodChsaW5lKVxcbiAgcmV0dXJuIFBvcyhsaW5lTiA9PSBudWxsID8gbGluZU5vKGxpbmUpIDogbGluZU4sIGNoKVxcbn1cXG5mdW5jdGlvbiBsaW5lU3RhcnRTbWFydChjbSwgcG9zKSB7XFxuICB2YXIgc3RhcnQgPSBsaW5lU3RhcnQoY20sIHBvcy5saW5lKVxcbiAgdmFyIGxpbmUgPSBnZXRMaW5lKGNtLmRvYywgc3RhcnQubGluZSlcXG4gIHZhciBvcmRlciA9IGdldE9yZGVyKGxpbmUpXFxuICBpZiAoIW9yZGVyIHx8IG9yZGVyWzBdLmxldmVsID09IDApIHtcXG4gICAgdmFyIGZpcnN0Tm9uV1MgPSBNYXRoLm1heCgwLCBsaW5lLnRleHQuc2VhcmNoKC9cXFxcUy8pKVxcbiAgICB2YXIgaW5XUyA9IHBvcy5saW5lID09IHN0YXJ0LmxpbmUgJiYgcG9zLmNoIDw9IGZpcnN0Tm9uV1MgJiYgcG9zLmNoXFxuICAgIHJldHVybiBQb3Moc3RhcnQubGluZSwgaW5XUyA/IDAgOiBmaXJzdE5vbldTKVxcbiAgfVxcbiAgcmV0dXJuIHN0YXJ0XFxufVxcblxcbi8vIFJ1biBhIGhhbmRsZXIgdGhhdCB3YXMgYm91bmQgdG8gYSBrZXkuXFxuZnVuY3Rpb24gZG9IYW5kbGVCaW5kaW5nKGNtLCBib3VuZCwgZHJvcFNoaWZ0KSB7XFxuICBpZiAodHlwZW9mIGJvdW5kID09IFxcXCJzdHJpbmdcXFwiKSB7XFxuICAgIGJvdW5kID0gY29tbWFuZHNbYm91bmRdXFxuICAgIGlmICghYm91bmQpIHsgcmV0dXJuIGZhbHNlIH1cXG4gIH1cXG4gIC8vIEVuc3VyZSBwcmV2aW91cyBpbnB1dCBoYXMgYmVlbiByZWFkLCBzbyB0aGF0IHRoZSBoYW5kbGVyIHNlZXMgYVxcbiAgLy8gY29uc2lzdGVudCB2aWV3IG9mIHRoZSBkb2N1bWVudFxcbiAgY20uZGlzcGxheS5pbnB1dC5lbnN1cmVQb2xsZWQoKVxcbiAgdmFyIHByZXZTaGlmdCA9IGNtLmRpc3BsYXkuc2hpZnQsIGRvbmUgPSBmYWxzZVxcbiAgdHJ5IHtcXG4gICAgaWYgKGNtLmlzUmVhZE9ubHkoKSkgeyBjbS5zdGF0ZS5zdXBwcmVzc0VkaXRzID0gdHJ1ZSB9XFxuICAgIGlmIChkcm9wU2hpZnQpIHsgY20uZGlzcGxheS5zaGlmdCA9IGZhbHNlIH1cXG4gICAgZG9uZSA9IGJvdW5kKGNtKSAhPSBQYXNzXFxuICB9IGZpbmFsbHkge1xcbiAgICBjbS5kaXNwbGF5LnNoaWZ0ID0gcHJldlNoaWZ0XFxuICAgIGNtLnN0YXRlLnN1cHByZXNzRWRpdHMgPSBmYWxzZVxcbiAgfVxcbiAgcmV0dXJuIGRvbmVcXG59XFxuXFxuZnVuY3Rpb24gbG9va3VwS2V5Rm9yRWRpdG9yKGNtLCBuYW1lLCBoYW5kbGUpIHtcXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY20uc3RhdGUua2V5TWFwcy5sZW5ndGg7IGkrKykge1xcbiAgICB2YXIgcmVzdWx0ID0gbG9va3VwS2V5KG5hbWUsIGNtLnN0YXRlLmtleU1hcHNbaV0sIGhhbmRsZSwgY20pXFxuICAgIGlmIChyZXN1bHQpIHsgcmV0dXJuIHJlc3VsdCB9XFxuICB9XFxuICByZXR1cm4gKGNtLm9wdGlvbnMuZXh0cmFLZXlzICYmIGxvb2t1cEtleShuYW1lLCBjbS5vcHRpb25zLmV4dHJhS2V5cywgaGFuZGxlLCBjbSkpXFxuICAgIHx8IGxvb2t1cEtleShuYW1lLCBjbS5vcHRpb25zLmtleU1hcCwgaGFuZGxlLCBjbSlcXG59XFxuXFxudmFyIHN0b3BTZXEgPSBuZXcgRGVsYXllZFxcbmZ1bmN0aW9uIGRpc3BhdGNoS2V5KGNtLCBuYW1lLCBlLCBoYW5kbGUpIHtcXG4gIHZhciBzZXEgPSBjbS5zdGF0ZS5rZXlTZXFcXG4gIGlmIChzZXEpIHtcXG4gICAgaWYgKGlzTW9kaWZpZXJLZXkobmFtZSkpIHsgcmV0dXJuIFxcXCJoYW5kbGVkXFxcIiB9XFxuICAgIHN0b3BTZXEuc2V0KDUwLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgaWYgKGNtLnN0YXRlLmtleVNlcSA9PSBzZXEpIHtcXG4gICAgICAgIGNtLnN0YXRlLmtleVNlcSA9IG51bGxcXG4gICAgICAgIGNtLmRpc3BsYXkuaW5wdXQucmVzZXQoKVxcbiAgICAgIH1cXG4gICAgfSlcXG4gICAgbmFtZSA9IHNlcSArIFxcXCIgXFxcIiArIG5hbWVcXG4gIH1cXG4gIHZhciByZXN1bHQgPSBsb29rdXBLZXlGb3JFZGl0b3IoY20sIG5hbWUsIGhhbmRsZSlcXG5cXG4gIGlmIChyZXN1bHQgPT0gXFxcIm11bHRpXFxcIilcXG4gICAgeyBjbS5zdGF0ZS5rZXlTZXEgPSBuYW1lIH1cXG4gIGlmIChyZXN1bHQgPT0gXFxcImhhbmRsZWRcXFwiKVxcbiAgICB7IHNpZ25hbExhdGVyKGNtLCBcXFwia2V5SGFuZGxlZFxcXCIsIGNtLCBuYW1lLCBlKSB9XFxuXFxuICBpZiAocmVzdWx0ID09IFxcXCJoYW5kbGVkXFxcIiB8fCByZXN1bHQgPT0gXFxcIm11bHRpXFxcIikge1xcbiAgICBlX3ByZXZlbnREZWZhdWx0KGUpXFxuICAgIHJlc3RhcnRCbGluayhjbSlcXG4gIH1cXG5cXG4gIGlmIChzZXEgJiYgIXJlc3VsdCAmJiAvXFxcXCckLy50ZXN0KG5hbWUpKSB7XFxuICAgIGVfcHJldmVudERlZmF1bHQoZSlcXG4gICAgcmV0dXJuIHRydWVcXG4gIH1cXG4gIHJldHVybiAhIXJlc3VsdFxcbn1cXG5cXG4vLyBIYW5kbGUgYSBrZXkgZnJvbSB0aGUga2V5ZG93biBldmVudC5cXG5mdW5jdGlvbiBoYW5kbGVLZXlCaW5kaW5nKGNtLCBlKSB7XFxuICB2YXIgbmFtZSA9IGtleU5hbWUoZSwgdHJ1ZSlcXG4gIGlmICghbmFtZSkgeyByZXR1cm4gZmFsc2UgfVxcblxcbiAgaWYgKGUuc2hpZnRLZXkgJiYgIWNtLnN0YXRlLmtleVNlcSkge1xcbiAgICAvLyBGaXJzdCB0cnkgdG8gcmVzb2x2ZSBmdWxsIG5hbWUgKGluY2x1ZGluZyAnU2hpZnQtJykuIEZhaWxpbmdcXG4gICAgLy8gdGhhdCwgc2VlIGlmIHRoZXJlIGlzIGEgY3Vyc29yLW1vdGlvbiBjb21tYW5kIChzdGFydGluZyB3aXRoXFxuICAgIC8vICdnbycpIGJvdW5kIHRvIHRoZSBrZXluYW1lIHdpdGhvdXQgJ1NoaWZ0LScuXFxuICAgIHJldHVybiBkaXNwYXRjaEtleShjbSwgXFxcIlNoaWZ0LVxcXCIgKyBuYW1lLCBlLCBmdW5jdGlvbiAoYikgeyByZXR1cm4gZG9IYW5kbGVCaW5kaW5nKGNtLCBiLCB0cnVlKTsgfSlcXG4gICAgICAgIHx8IGRpc3BhdGNoS2V5KGNtLCBuYW1lLCBlLCBmdW5jdGlvbiAoYikge1xcbiAgICAgICAgICAgICBpZiAodHlwZW9mIGIgPT0gXFxcInN0cmluZ1xcXCIgPyAvXmdvW0EtWl0vLnRlc3QoYikgOiBiLm1vdGlvbilcXG4gICAgICAgICAgICAgICB7IHJldHVybiBkb0hhbmRsZUJpbmRpbmcoY20sIGIpIH1cXG4gICAgICAgICAgIH0pXFxuICB9IGVsc2Uge1xcbiAgICByZXR1cm4gZGlzcGF0Y2hLZXkoY20sIG5hbWUsIGUsIGZ1bmN0aW9uIChiKSB7IHJldHVybiBkb0hhbmRsZUJpbmRpbmcoY20sIGIpOyB9KVxcbiAgfVxcbn1cXG5cXG4vLyBIYW5kbGUgYSBrZXkgZnJvbSB0aGUga2V5cHJlc3MgZXZlbnRcXG5mdW5jdGlvbiBoYW5kbGVDaGFyQmluZGluZyhjbSwgZSwgY2gpIHtcXG4gIHJldHVybiBkaXNwYXRjaEtleShjbSwgXFxcIidcXFwiICsgY2ggKyBcXFwiJ1xcXCIsIGUsIGZ1bmN0aW9uIChiKSB7IHJldHVybiBkb0hhbmRsZUJpbmRpbmcoY20sIGIsIHRydWUpOyB9KVxcbn1cXG5cXG52YXIgbGFzdFN0b3BwZWRLZXkgPSBudWxsXFxuZnVuY3Rpb24gb25LZXlEb3duKGUpIHtcXG4gIHZhciBjbSA9IHRoaXNcXG4gIGNtLmN1ck9wLmZvY3VzID0gYWN0aXZlRWx0KClcXG4gIGlmIChzaWduYWxET01FdmVudChjbSwgZSkpIHsgcmV0dXJuIH1cXG4gIC8vIElFIGRvZXMgc3RyYW5nZSB0aGluZ3Mgd2l0aCBlc2NhcGUuXFxuICBpZiAoaWUgJiYgaWVfdmVyc2lvbiA8IDExICYmIGUua2V5Q29kZSA9PSAyNykgeyBlLnJldHVyblZhbHVlID0gZmFsc2UgfVxcbiAgdmFyIGNvZGUgPSBlLmtleUNvZGVcXG4gIGNtLmRpc3BsYXkuc2hpZnQgPSBjb2RlID09IDE2IHx8IGUuc2hpZnRLZXlcXG4gIHZhciBoYW5kbGVkID0gaGFuZGxlS2V5QmluZGluZyhjbSwgZSlcXG4gIGlmIChwcmVzdG8pIHtcXG4gICAgbGFzdFN0b3BwZWRLZXkgPSBoYW5kbGVkID8gY29kZSA6IG51bGxcXG4gICAgLy8gT3BlcmEgaGFzIG5vIGN1dCBldmVudC4uLiB3ZSB0cnkgdG8gYXQgbGVhc3QgY2F0Y2ggdGhlIGtleSBjb21ib1xcbiAgICBpZiAoIWhhbmRsZWQgJiYgY29kZSA9PSA4OCAmJiAhaGFzQ29weUV2ZW50ICYmIChtYWMgPyBlLm1ldGFLZXkgOiBlLmN0cmxLZXkpKVxcbiAgICAgIHsgY20ucmVwbGFjZVNlbGVjdGlvbihcXFwiXFxcIiwgbnVsbCwgXFxcImN1dFxcXCIpIH1cXG4gIH1cXG5cXG4gIC8vIFR1cm4gbW91c2UgaW50byBjcm9zc2hhaXIgd2hlbiBBbHQgaXMgaGVsZCBvbiBNYWMuXFxuICBpZiAoY29kZSA9PSAxOCAmJiAhL1xcXFxiQ29kZU1pcnJvci1jcm9zc2hhaXJcXFxcYi8udGVzdChjbS5kaXNwbGF5LmxpbmVEaXYuY2xhc3NOYW1lKSlcXG4gICAgeyBzaG93Q3Jvc3NIYWlyKGNtKSB9XFxufVxcblxcbmZ1bmN0aW9uIHNob3dDcm9zc0hhaXIoY20pIHtcXG4gIHZhciBsaW5lRGl2ID0gY20uZGlzcGxheS5saW5lRGl2XFxuICBhZGRDbGFzcyhsaW5lRGl2LCBcXFwiQ29kZU1pcnJvci1jcm9zc2hhaXJcXFwiKVxcblxcbiAgZnVuY3Rpb24gdXAoZSkge1xcbiAgICBpZiAoZS5rZXlDb2RlID09IDE4IHx8ICFlLmFsdEtleSkge1xcbiAgICAgIHJtQ2xhc3MobGluZURpdiwgXFxcIkNvZGVNaXJyb3ItY3Jvc3NoYWlyXFxcIilcXG4gICAgICBvZmYoZG9jdW1lbnQsIFxcXCJrZXl1cFxcXCIsIHVwKVxcbiAgICAgIG9mZihkb2N1bWVudCwgXFxcIm1vdXNlb3ZlclxcXCIsIHVwKVxcbiAgICB9XFxuICB9XFxuICBvbihkb2N1bWVudCwgXFxcImtleXVwXFxcIiwgdXApXFxuICBvbihkb2N1bWVudCwgXFxcIm1vdXNlb3ZlclxcXCIsIHVwKVxcbn1cXG5cXG5mdW5jdGlvbiBvbktleVVwKGUpIHtcXG4gIGlmIChlLmtleUNvZGUgPT0gMTYpIHsgdGhpcy5kb2Muc2VsLnNoaWZ0ID0gZmFsc2UgfVxcbiAgc2lnbmFsRE9NRXZlbnQodGhpcywgZSlcXG59XFxuXFxuZnVuY3Rpb24gb25LZXlQcmVzcyhlKSB7XFxuICB2YXIgY20gPSB0aGlzXFxuICBpZiAoZXZlbnRJbldpZGdldChjbS5kaXNwbGF5LCBlKSB8fCBzaWduYWxET01FdmVudChjbSwgZSkgfHwgZS5jdHJsS2V5ICYmICFlLmFsdEtleSB8fCBtYWMgJiYgZS5tZXRhS2V5KSB7IHJldHVybiB9XFxuICB2YXIga2V5Q29kZSA9IGUua2V5Q29kZSwgY2hhckNvZGUgPSBlLmNoYXJDb2RlXFxuICBpZiAocHJlc3RvICYmIGtleUNvZGUgPT0gbGFzdFN0b3BwZWRLZXkpIHtsYXN0U3RvcHBlZEtleSA9IG51bGw7IGVfcHJldmVudERlZmF1bHQoZSk7IHJldHVybn1cXG4gIGlmICgocHJlc3RvICYmICghZS53aGljaCB8fCBlLndoaWNoIDwgMTApKSAmJiBoYW5kbGVLZXlCaW5kaW5nKGNtLCBlKSkgeyByZXR1cm4gfVxcbiAgdmFyIGNoID0gU3RyaW5nLmZyb21DaGFyQ29kZShjaGFyQ29kZSA9PSBudWxsID8ga2V5Q29kZSA6IGNoYXJDb2RlKVxcbiAgLy8gU29tZSBicm93c2VycyBmaXJlIGtleXByZXNzIGV2ZW50cyBmb3IgYmFja3NwYWNlXFxuICBpZiAoY2ggPT0gXFxcIlxcXFx4MDhcXFwiKSB7IHJldHVybiB9XFxuICBpZiAoaGFuZGxlQ2hhckJpbmRpbmcoY20sIGUsIGNoKSkgeyByZXR1cm4gfVxcbiAgY20uZGlzcGxheS5pbnB1dC5vbktleVByZXNzKGUpXFxufVxcblxcbi8vIEEgbW91c2UgZG93biBjYW4gYmUgYSBzaW5nbGUgY2xpY2ssIGRvdWJsZSBjbGljaywgdHJpcGxlIGNsaWNrLFxcbi8vIHN0YXJ0IG9mIHNlbGVjdGlvbiBkcmFnLCBzdGFydCBvZiB0ZXh0IGRyYWcsIG5ldyBjdXJzb3JcXG4vLyAoY3RybC1jbGljayksIHJlY3RhbmdsZSBkcmFnIChhbHQtZHJhZyksIG9yIHh3aW5cXG4vLyBtaWRkbGUtY2xpY2stcGFzdGUuIE9yIGl0IG1pZ2h0IGJlIGEgY2xpY2sgb24gc29tZXRoaW5nIHdlIHNob3VsZFxcbi8vIG5vdCBpbnRlcmZlcmUgd2l0aCwgc3VjaCBhcyBhIHNjcm9sbGJhciBvciB3aWRnZXQuXFxuZnVuY3Rpb24gb25Nb3VzZURvd24oZSkge1xcbiAgdmFyIGNtID0gdGhpcywgZGlzcGxheSA9IGNtLmRpc3BsYXlcXG4gIGlmIChzaWduYWxET01FdmVudChjbSwgZSkgfHwgZGlzcGxheS5hY3RpdmVUb3VjaCAmJiBkaXNwbGF5LmlucHV0LnN1cHBvcnRzVG91Y2goKSkgeyByZXR1cm4gfVxcbiAgZGlzcGxheS5zaGlmdCA9IGUuc2hpZnRLZXlcXG5cXG4gIGlmIChldmVudEluV2lkZ2V0KGRpc3BsYXksIGUpKSB7XFxuICAgIGlmICghd2Via2l0KSB7XFxuICAgICAgLy8gQnJpZWZseSB0dXJuIG9mZiBkcmFnZ2FiaWxpdHksIHRvIGFsbG93IHdpZGdldHMgdG8gZG9cXG4gICAgICAvLyBub3JtYWwgZHJhZ2dpbmcgdGhpbmdzLlxcbiAgICAgIGRpc3BsYXkuc2Nyb2xsZXIuZHJhZ2dhYmxlID0gZmFsc2VcXG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRpc3BsYXkuc2Nyb2xsZXIuZHJhZ2dhYmxlID0gdHJ1ZTsgfSwgMTAwKVxcbiAgICB9XFxuICAgIHJldHVyblxcbiAgfVxcbiAgaWYgKGNsaWNrSW5HdXR0ZXIoY20sIGUpKSB7IHJldHVybiB9XFxuICB2YXIgc3RhcnQgPSBwb3NGcm9tTW91c2UoY20sIGUpXFxuICB3aW5kb3cuZm9jdXMoKVxcblxcbiAgc3dpdGNoIChlX2J1dHRvbihlKSkge1xcbiAgY2FzZSAxOlxcbiAgICAvLyAjMzI2MTogbWFrZSBzdXJlLCB0aGF0IHdlJ3JlIG5vdCBzdGFydGluZyBhIHNlY29uZCBzZWxlY3Rpb25cXG4gICAgaWYgKGNtLnN0YXRlLnNlbGVjdGluZ1RleHQpXFxuICAgICAgeyBjbS5zdGF0ZS5zZWxlY3RpbmdUZXh0KGUpIH1cXG4gICAgZWxzZSBpZiAoc3RhcnQpXFxuICAgICAgeyBsZWZ0QnV0dG9uRG93bihjbSwgZSwgc3RhcnQpIH1cXG4gICAgZWxzZSBpZiAoZV90YXJnZXQoZSkgPT0gZGlzcGxheS5zY3JvbGxlcilcXG4gICAgICB7IGVfcHJldmVudERlZmF1bHQoZSkgfVxcbiAgICBicmVha1xcbiAgY2FzZSAyOlxcbiAgICBpZiAod2Via2l0KSB7IGNtLnN0YXRlLmxhc3RNaWRkbGVEb3duID0gK25ldyBEYXRlIH1cXG4gICAgaWYgKHN0YXJ0KSB7IGV4dGVuZFNlbGVjdGlvbihjbS5kb2MsIHN0YXJ0KSB9XFxuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyByZXR1cm4gZGlzcGxheS5pbnB1dC5mb2N1cygpOyB9LCAyMClcXG4gICAgZV9wcmV2ZW50RGVmYXVsdChlKVxcbiAgICBicmVha1xcbiAgY2FzZSAzOlxcbiAgICBpZiAoY2FwdHVyZVJpZ2h0Q2xpY2spIHsgb25Db250ZXh0TWVudShjbSwgZSkgfVxcbiAgICBlbHNlIHsgZGVsYXlCbHVyRXZlbnQoY20pIH1cXG4gICAgYnJlYWtcXG4gIH1cXG59XFxuXFxudmFyIGxhc3RDbGljaztcXG52YXIgbGFzdERvdWJsZUNsaWNrO1xcbmZ1bmN0aW9uIGxlZnRCdXR0b25Eb3duKGNtLCBlLCBzdGFydCkge1xcbiAgaWYgKGllKSB7IHNldFRpbWVvdXQoYmluZChlbnN1cmVGb2N1cywgY20pLCAwKSB9XFxuICBlbHNlIHsgY20uY3VyT3AuZm9jdXMgPSBhY3RpdmVFbHQoKSB9XFxuXFxuICB2YXIgbm93ID0gK25ldyBEYXRlLCB0eXBlXFxuICBpZiAobGFzdERvdWJsZUNsaWNrICYmIGxhc3REb3VibGVDbGljay50aW1lID4gbm93IC0gNDAwICYmIGNtcChsYXN0RG91YmxlQ2xpY2sucG9zLCBzdGFydCkgPT0gMCkge1xcbiAgICB0eXBlID0gXFxcInRyaXBsZVxcXCJcXG4gIH0gZWxzZSBpZiAobGFzdENsaWNrICYmIGxhc3RDbGljay50aW1lID4gbm93IC0gNDAwICYmIGNtcChsYXN0Q2xpY2sucG9zLCBzdGFydCkgPT0gMCkge1xcbiAgICB0eXBlID0gXFxcImRvdWJsZVxcXCJcXG4gICAgbGFzdERvdWJsZUNsaWNrID0ge3RpbWU6IG5vdywgcG9zOiBzdGFydH1cXG4gIH0gZWxzZSB7XFxuICAgIHR5cGUgPSBcXFwic2luZ2xlXFxcIlxcbiAgICBsYXN0Q2xpY2sgPSB7dGltZTogbm93LCBwb3M6IHN0YXJ0fVxcbiAgfVxcblxcbiAgdmFyIHNlbCA9IGNtLmRvYy5zZWwsIG1vZGlmaWVyID0gbWFjID8gZS5tZXRhS2V5IDogZS5jdHJsS2V5LCBjb250YWluZWRcXG4gIGlmIChjbS5vcHRpb25zLmRyYWdEcm9wICYmIGRyYWdBbmREcm9wICYmICFjbS5pc1JlYWRPbmx5KCkgJiZcXG4gICAgICB0eXBlID09IFxcXCJzaW5nbGVcXFwiICYmIChjb250YWluZWQgPSBzZWwuY29udGFpbnMoc3RhcnQpKSA+IC0xICYmXFxuICAgICAgKGNtcCgoY29udGFpbmVkID0gc2VsLnJhbmdlc1tjb250YWluZWRdKS5mcm9tKCksIHN0YXJ0KSA8IDAgfHwgc3RhcnQueFJlbCA+IDApICYmXFxuICAgICAgKGNtcChjb250YWluZWQudG8oKSwgc3RhcnQpID4gMCB8fCBzdGFydC54UmVsIDwgMCkpXFxuICAgIHsgbGVmdEJ1dHRvblN0YXJ0RHJhZyhjbSwgZSwgc3RhcnQsIG1vZGlmaWVyKSB9XFxuICBlbHNlXFxuICAgIHsgbGVmdEJ1dHRvblNlbGVjdChjbSwgZSwgc3RhcnQsIHR5cGUsIG1vZGlmaWVyKSB9XFxufVxcblxcbi8vIFN0YXJ0IGEgdGV4dCBkcmFnLiBXaGVuIGl0IGVuZHMsIHNlZSBpZiBhbnkgZHJhZ2dpbmcgYWN0dWFsbHlcXG4vLyBoYXBwZW4sIGFuZCB0cmVhdCBhcyBhIGNsaWNrIGlmIGl0IGRpZG4ndC5cXG5mdW5jdGlvbiBsZWZ0QnV0dG9uU3RhcnREcmFnKGNtLCBlLCBzdGFydCwgbW9kaWZpZXIpIHtcXG4gIHZhciBkaXNwbGF5ID0gY20uZGlzcGxheSwgc3RhcnRUaW1lID0gK25ldyBEYXRlXFxuICB2YXIgZHJhZ0VuZCA9IG9wZXJhdGlvbihjbSwgZnVuY3Rpb24gKGUyKSB7XFxuICAgIGlmICh3ZWJraXQpIHsgZGlzcGxheS5zY3JvbGxlci5kcmFnZ2FibGUgPSBmYWxzZSB9XFxuICAgIGNtLnN0YXRlLmRyYWdnaW5nVGV4dCA9IGZhbHNlXFxuICAgIG9mZihkb2N1bWVudCwgXFxcIm1vdXNldXBcXFwiLCBkcmFnRW5kKVxcbiAgICBvZmYoZGlzcGxheS5zY3JvbGxlciwgXFxcImRyb3BcXFwiLCBkcmFnRW5kKVxcbiAgICBpZiAoTWF0aC5hYnMoZS5jbGllbnRYIC0gZTIuY2xpZW50WCkgKyBNYXRoLmFicyhlLmNsaWVudFkgLSBlMi5jbGllbnRZKSA8IDEwKSB7XFxuICAgICAgZV9wcmV2ZW50RGVmYXVsdChlMilcXG4gICAgICBpZiAoIW1vZGlmaWVyICYmICtuZXcgRGF0ZSAtIDIwMCA8IHN0YXJ0VGltZSlcXG4gICAgICAgIHsgZXh0ZW5kU2VsZWN0aW9uKGNtLmRvYywgc3RhcnQpIH1cXG4gICAgICAvLyBXb3JrIGFyb3VuZCB1bmV4cGxhaW5hYmxlIGZvY3VzIHByb2JsZW0gaW4gSUU5ICgjMjEyNykgYW5kIENocm9tZSAoIzMwODEpXFxuICAgICAgaWYgKHdlYmtpdCB8fCBpZSAmJiBpZV92ZXJzaW9uID09IDkpXFxuICAgICAgICB7IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge2RvY3VtZW50LmJvZHkuZm9jdXMoKTsgZGlzcGxheS5pbnB1dC5mb2N1cygpfSwgMjApIH1cXG4gICAgICBlbHNlXFxuICAgICAgICB7IGRpc3BsYXkuaW5wdXQuZm9jdXMoKSB9XFxuICAgIH1cXG4gIH0pXFxuICAvLyBMZXQgdGhlIGRyYWcgaGFuZGxlciBoYW5kbGUgdGhpcy5cXG4gIGlmICh3ZWJraXQpIHsgZGlzcGxheS5zY3JvbGxlci5kcmFnZ2FibGUgPSB0cnVlIH1cXG4gIGNtLnN0YXRlLmRyYWdnaW5nVGV4dCA9IGRyYWdFbmRcXG4gIGRyYWdFbmQuY29weSA9IG1hYyA/IGUuYWx0S2V5IDogZS5jdHJsS2V5XFxuICAvLyBJRSdzIGFwcHJvYWNoIHRvIGRyYWdnYWJsZVxcbiAgaWYgKGRpc3BsYXkuc2Nyb2xsZXIuZHJhZ0Ryb3ApIHsgZGlzcGxheS5zY3JvbGxlci5kcmFnRHJvcCgpIH1cXG4gIG9uKGRvY3VtZW50LCBcXFwibW91c2V1cFxcXCIsIGRyYWdFbmQpXFxuICBvbihkaXNwbGF5LnNjcm9sbGVyLCBcXFwiZHJvcFxcXCIsIGRyYWdFbmQpXFxufVxcblxcbi8vIE5vcm1hbCBzZWxlY3Rpb24sIGFzIG9wcG9zZWQgdG8gdGV4dCBkcmFnZ2luZy5cXG5mdW5jdGlvbiBsZWZ0QnV0dG9uU2VsZWN0KGNtLCBlLCBzdGFydCwgdHlwZSwgYWRkTmV3KSB7XFxuICB2YXIgZGlzcGxheSA9IGNtLmRpc3BsYXksIGRvYyA9IGNtLmRvY1xcbiAgZV9wcmV2ZW50RGVmYXVsdChlKVxcblxcbiAgdmFyIG91clJhbmdlLCBvdXJJbmRleCwgc3RhcnRTZWwgPSBkb2Muc2VsLCByYW5nZXMgPSBzdGFydFNlbC5yYW5nZXNcXG4gIGlmIChhZGROZXcgJiYgIWUuc2hpZnRLZXkpIHtcXG4gICAgb3VySW5kZXggPSBkb2Muc2VsLmNvbnRhaW5zKHN0YXJ0KVxcbiAgICBpZiAob3VySW5kZXggPiAtMSlcXG4gICAgICB7IG91clJhbmdlID0gcmFuZ2VzW291ckluZGV4XSB9XFxuICAgIGVsc2VcXG4gICAgICB7IG91clJhbmdlID0gbmV3IFJhbmdlKHN0YXJ0LCBzdGFydCkgfVxcbiAgfSBlbHNlIHtcXG4gICAgb3VyUmFuZ2UgPSBkb2Muc2VsLnByaW1hcnkoKVxcbiAgICBvdXJJbmRleCA9IGRvYy5zZWwucHJpbUluZGV4XFxuICB9XFxuXFxuICBpZiAoY2hyb21lT1MgPyBlLnNoaWZ0S2V5ICYmIGUubWV0YUtleSA6IGUuYWx0S2V5KSB7XFxuICAgIHR5cGUgPSBcXFwicmVjdFxcXCJcXG4gICAgaWYgKCFhZGROZXcpIHsgb3VyUmFuZ2UgPSBuZXcgUmFuZ2Uoc3RhcnQsIHN0YXJ0KSB9XFxuICAgIHN0YXJ0ID0gcG9zRnJvbU1vdXNlKGNtLCBlLCB0cnVlLCB0cnVlKVxcbiAgICBvdXJJbmRleCA9IC0xXFxuICB9IGVsc2UgaWYgKHR5cGUgPT0gXFxcImRvdWJsZVxcXCIpIHtcXG4gICAgdmFyIHdvcmQgPSBjbS5maW5kV29yZEF0KHN0YXJ0KVxcbiAgICBpZiAoY20uZGlzcGxheS5zaGlmdCB8fCBkb2MuZXh0ZW5kKVxcbiAgICAgIHsgb3VyUmFuZ2UgPSBleHRlbmRSYW5nZShkb2MsIG91clJhbmdlLCB3b3JkLmFuY2hvciwgd29yZC5oZWFkKSB9XFxuICAgIGVsc2VcXG4gICAgICB7IG91clJhbmdlID0gd29yZCB9XFxuICB9IGVsc2UgaWYgKHR5cGUgPT0gXFxcInRyaXBsZVxcXCIpIHtcXG4gICAgdmFyIGxpbmUgPSBuZXcgUmFuZ2UoUG9zKHN0YXJ0LmxpbmUsIDApLCBjbGlwUG9zKGRvYywgUG9zKHN0YXJ0LmxpbmUgKyAxLCAwKSkpXFxuICAgIGlmIChjbS5kaXNwbGF5LnNoaWZ0IHx8IGRvYy5leHRlbmQpXFxuICAgICAgeyBvdXJSYW5nZSA9IGV4dGVuZFJhbmdlKGRvYywgb3VyUmFuZ2UsIGxpbmUuYW5jaG9yLCBsaW5lLmhlYWQpIH1cXG4gICAgZWxzZVxcbiAgICAgIHsgb3VyUmFuZ2UgPSBsaW5lIH1cXG4gIH0gZWxzZSB7XFxuICAgIG91clJhbmdlID0gZXh0ZW5kUmFuZ2UoZG9jLCBvdXJSYW5nZSwgc3RhcnQpXFxuICB9XFxuXFxuICBpZiAoIWFkZE5ldykge1xcbiAgICBvdXJJbmRleCA9IDBcXG4gICAgc2V0U2VsZWN0aW9uKGRvYywgbmV3IFNlbGVjdGlvbihbb3VyUmFuZ2VdLCAwKSwgc2VsX21vdXNlKVxcbiAgICBzdGFydFNlbCA9IGRvYy5zZWxcXG4gIH0gZWxzZSBpZiAob3VySW5kZXggPT0gLTEpIHtcXG4gICAgb3VySW5kZXggPSByYW5nZXMubGVuZ3RoXFxuICAgIHNldFNlbGVjdGlvbihkb2MsIG5vcm1hbGl6ZVNlbGVjdGlvbihyYW5nZXMuY29uY2F0KFtvdXJSYW5nZV0pLCBvdXJJbmRleCksXFxuICAgICAgICAgICAgICAgICB7c2Nyb2xsOiBmYWxzZSwgb3JpZ2luOiBcXFwiKm1vdXNlXFxcIn0pXFxuICB9IGVsc2UgaWYgKHJhbmdlcy5sZW5ndGggPiAxICYmIHJhbmdlc1tvdXJJbmRleF0uZW1wdHkoKSAmJiB0eXBlID09IFxcXCJzaW5nbGVcXFwiICYmICFlLnNoaWZ0S2V5KSB7XFxuICAgIHNldFNlbGVjdGlvbihkb2MsIG5vcm1hbGl6ZVNlbGVjdGlvbihyYW5nZXMuc2xpY2UoMCwgb3VySW5kZXgpLmNvbmNhdChyYW5nZXMuc2xpY2Uob3VySW5kZXggKyAxKSksIDApLFxcbiAgICAgICAgICAgICAgICAge3Njcm9sbDogZmFsc2UsIG9yaWdpbjogXFxcIiptb3VzZVxcXCJ9KVxcbiAgICBzdGFydFNlbCA9IGRvYy5zZWxcXG4gIH0gZWxzZSB7XFxuICAgIHJlcGxhY2VPbmVTZWxlY3Rpb24oZG9jLCBvdXJJbmRleCwgb3VyUmFuZ2UsIHNlbF9tb3VzZSlcXG4gIH1cXG5cXG4gIHZhciBsYXN0UG9zID0gc3RhcnRcXG4gIGZ1bmN0aW9uIGV4dGVuZFRvKHBvcykge1xcbiAgICBpZiAoY21wKGxhc3RQb3MsIHBvcykgPT0gMCkgeyByZXR1cm4gfVxcbiAgICBsYXN0UG9zID0gcG9zXFxuXFxuICAgIGlmICh0eXBlID09IFxcXCJyZWN0XFxcIikge1xcbiAgICAgIHZhciByYW5nZXMgPSBbXSwgdGFiU2l6ZSA9IGNtLm9wdGlvbnMudGFiU2l6ZVxcbiAgICAgIHZhciBzdGFydENvbCA9IGNvdW50Q29sdW1uKGdldExpbmUoZG9jLCBzdGFydC5saW5lKS50ZXh0LCBzdGFydC5jaCwgdGFiU2l6ZSlcXG4gICAgICB2YXIgcG9zQ29sID0gY291bnRDb2x1bW4oZ2V0TGluZShkb2MsIHBvcy5saW5lKS50ZXh0LCBwb3MuY2gsIHRhYlNpemUpXFxuICAgICAgdmFyIGxlZnQgPSBNYXRoLm1pbihzdGFydENvbCwgcG9zQ29sKSwgcmlnaHQgPSBNYXRoLm1heChzdGFydENvbCwgcG9zQ29sKVxcbiAgICAgIGZvciAodmFyIGxpbmUgPSBNYXRoLm1pbihzdGFydC5saW5lLCBwb3MubGluZSksIGVuZCA9IE1hdGgubWluKGNtLmxhc3RMaW5lKCksIE1hdGgubWF4KHN0YXJ0LmxpbmUsIHBvcy5saW5lKSk7XFxuICAgICAgICAgICBsaW5lIDw9IGVuZDsgbGluZSsrKSB7XFxuICAgICAgICB2YXIgdGV4dCA9IGdldExpbmUoZG9jLCBsaW5lKS50ZXh0LCBsZWZ0UG9zID0gZmluZENvbHVtbih0ZXh0LCBsZWZ0LCB0YWJTaXplKVxcbiAgICAgICAgaWYgKGxlZnQgPT0gcmlnaHQpXFxuICAgICAgICAgIHsgcmFuZ2VzLnB1c2gobmV3IFJhbmdlKFBvcyhsaW5lLCBsZWZ0UG9zKSwgUG9zKGxpbmUsIGxlZnRQb3MpKSkgfVxcbiAgICAgICAgZWxzZSBpZiAodGV4dC5sZW5ndGggPiBsZWZ0UG9zKVxcbiAgICAgICAgICB7IHJhbmdlcy5wdXNoKG5ldyBSYW5nZShQb3MobGluZSwgbGVmdFBvcyksIFBvcyhsaW5lLCBmaW5kQ29sdW1uKHRleHQsIHJpZ2h0LCB0YWJTaXplKSkpKSB9XFxuICAgICAgfVxcbiAgICAgIGlmICghcmFuZ2VzLmxlbmd0aCkgeyByYW5nZXMucHVzaChuZXcgUmFuZ2Uoc3RhcnQsIHN0YXJ0KSkgfVxcbiAgICAgIHNldFNlbGVjdGlvbihkb2MsIG5vcm1hbGl6ZVNlbGVjdGlvbihzdGFydFNlbC5yYW5nZXMuc2xpY2UoMCwgb3VySW5kZXgpLmNvbmNhdChyYW5nZXMpLCBvdXJJbmRleCksXFxuICAgICAgICAgICAgICAgICAgIHtvcmlnaW46IFxcXCIqbW91c2VcXFwiLCBzY3JvbGw6IGZhbHNlfSlcXG4gICAgICBjbS5zY3JvbGxJbnRvVmlldyhwb3MpXFxuICAgIH0gZWxzZSB7XFxuICAgICAgdmFyIG9sZFJhbmdlID0gb3VyUmFuZ2VcXG4gICAgICB2YXIgYW5jaG9yID0gb2xkUmFuZ2UuYW5jaG9yLCBoZWFkID0gcG9zXFxuICAgICAgaWYgKHR5cGUgIT0gXFxcInNpbmdsZVxcXCIpIHtcXG4gICAgICAgIHZhciByYW5nZVxcbiAgICAgICAgaWYgKHR5cGUgPT0gXFxcImRvdWJsZVxcXCIpXFxuICAgICAgICAgIHsgcmFuZ2UgPSBjbS5maW5kV29yZEF0KHBvcykgfVxcbiAgICAgICAgZWxzZVxcbiAgICAgICAgICB7IHJhbmdlID0gbmV3IFJhbmdlKFBvcyhwb3MubGluZSwgMCksIGNsaXBQb3MoZG9jLCBQb3MocG9zLmxpbmUgKyAxLCAwKSkpIH1cXG4gICAgICAgIGlmIChjbXAocmFuZ2UuYW5jaG9yLCBhbmNob3IpID4gMCkge1xcbiAgICAgICAgICBoZWFkID0gcmFuZ2UuaGVhZFxcbiAgICAgICAgICBhbmNob3IgPSBtaW5Qb3Mob2xkUmFuZ2UuZnJvbSgpLCByYW5nZS5hbmNob3IpXFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICBoZWFkID0gcmFuZ2UuYW5jaG9yXFxuICAgICAgICAgIGFuY2hvciA9IG1heFBvcyhvbGRSYW5nZS50bygpLCByYW5nZS5oZWFkKVxcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgICB2YXIgcmFuZ2VzJDEgPSBzdGFydFNlbC5yYW5nZXMuc2xpY2UoMClcXG4gICAgICByYW5nZXMkMVtvdXJJbmRleF0gPSBuZXcgUmFuZ2UoY2xpcFBvcyhkb2MsIGFuY2hvciksIGhlYWQpXFxuICAgICAgc2V0U2VsZWN0aW9uKGRvYywgbm9ybWFsaXplU2VsZWN0aW9uKHJhbmdlcyQxLCBvdXJJbmRleCksIHNlbF9tb3VzZSlcXG4gICAgfVxcbiAgfVxcblxcbiAgdmFyIGVkaXRvclNpemUgPSBkaXNwbGF5LndyYXBwZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClcXG4gIC8vIFVzZWQgdG8gZW5zdXJlIHRpbWVvdXQgcmUtdHJpZXMgZG9uJ3QgZmlyZSB3aGVuIGFub3RoZXIgZXh0ZW5kXFxuICAvLyBoYXBwZW5lZCBpbiB0aGUgbWVhbnRpbWUgKGNsZWFyVGltZW91dCBpc24ndCByZWxpYWJsZSAtLSBhdFxcbiAgLy8gbGVhc3Qgb24gQ2hyb21lLCB0aGUgdGltZW91dHMgc3RpbGwgaGFwcGVuIGV2ZW4gd2hlbiBjbGVhcmVkLFxcbiAgLy8gaWYgdGhlIGNsZWFyIGhhcHBlbnMgYWZ0ZXIgdGhlaXIgc2NoZWR1bGVkIGZpcmluZyB0aW1lKS5cXG4gIHZhciBjb3VudGVyID0gMFxcblxcbiAgZnVuY3Rpb24gZXh0ZW5kKGUpIHtcXG4gICAgdmFyIGN1ckNvdW50ID0gKytjb3VudGVyXFxuICAgIHZhciBjdXIgPSBwb3NGcm9tTW91c2UoY20sIGUsIHRydWUsIHR5cGUgPT0gXFxcInJlY3RcXFwiKVxcbiAgICBpZiAoIWN1cikgeyByZXR1cm4gfVxcbiAgICBpZiAoY21wKGN1ciwgbGFzdFBvcykgIT0gMCkge1xcbiAgICAgIGNtLmN1ck9wLmZvY3VzID0gYWN0aXZlRWx0KClcXG4gICAgICBleHRlbmRUbyhjdXIpXFxuICAgICAgdmFyIHZpc2libGUgPSB2aXNpYmxlTGluZXMoZGlzcGxheSwgZG9jKVxcbiAgICAgIGlmIChjdXIubGluZSA+PSB2aXNpYmxlLnRvIHx8IGN1ci5saW5lIDwgdmlzaWJsZS5mcm9tKVxcbiAgICAgICAgeyBzZXRUaW1lb3V0KG9wZXJhdGlvbihjbSwgZnVuY3Rpb24gKCkge2lmIChjb3VudGVyID09IGN1ckNvdW50KSB7IGV4dGVuZChlKSB9fSksIDE1MCkgfVxcbiAgICB9IGVsc2Uge1xcbiAgICAgIHZhciBvdXRzaWRlID0gZS5jbGllbnRZIDwgZWRpdG9yU2l6ZS50b3AgPyAtMjAgOiBlLmNsaWVudFkgPiBlZGl0b3JTaXplLmJvdHRvbSA/IDIwIDogMFxcbiAgICAgIGlmIChvdXRzaWRlKSB7IHNldFRpbWVvdXQob3BlcmF0aW9uKGNtLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgICBpZiAoY291bnRlciAhPSBjdXJDb3VudCkgeyByZXR1cm4gfVxcbiAgICAgICAgZGlzcGxheS5zY3JvbGxlci5zY3JvbGxUb3AgKz0gb3V0c2lkZVxcbiAgICAgICAgZXh0ZW5kKGUpXFxuICAgICAgfSksIDUwKSB9XFxuICAgIH1cXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIGRvbmUoZSkge1xcbiAgICBjbS5zdGF0ZS5zZWxlY3RpbmdUZXh0ID0gZmFsc2VcXG4gICAgY291bnRlciA9IEluZmluaXR5XFxuICAgIGVfcHJldmVudERlZmF1bHQoZSlcXG4gICAgZGlzcGxheS5pbnB1dC5mb2N1cygpXFxuICAgIG9mZihkb2N1bWVudCwgXFxcIm1vdXNlbW92ZVxcXCIsIG1vdmUpXFxuICAgIG9mZihkb2N1bWVudCwgXFxcIm1vdXNldXBcXFwiLCB1cClcXG4gICAgZG9jLmhpc3RvcnkubGFzdFNlbE9yaWdpbiA9IG51bGxcXG4gIH1cXG5cXG4gIHZhciBtb3ZlID0gb3BlcmF0aW9uKGNtLCBmdW5jdGlvbiAoZSkge1xcbiAgICBpZiAoIWVfYnV0dG9uKGUpKSB7IGRvbmUoZSkgfVxcbiAgICBlbHNlIHsgZXh0ZW5kKGUpIH1cXG4gIH0pXFxuICB2YXIgdXAgPSBvcGVyYXRpb24oY20sIGRvbmUpXFxuICBjbS5zdGF0ZS5zZWxlY3RpbmdUZXh0ID0gdXBcXG4gIG9uKGRvY3VtZW50LCBcXFwibW91c2Vtb3ZlXFxcIiwgbW92ZSlcXG4gIG9uKGRvY3VtZW50LCBcXFwibW91c2V1cFxcXCIsIHVwKVxcbn1cXG5cXG5cXG4vLyBEZXRlcm1pbmVzIHdoZXRoZXIgYW4gZXZlbnQgaGFwcGVuZWQgaW4gdGhlIGd1dHRlciwgYW5kIGZpcmVzIHRoZVxcbi8vIGhhbmRsZXJzIGZvciB0aGUgY29ycmVzcG9uZGluZyBldmVudC5cXG5mdW5jdGlvbiBndXR0ZXJFdmVudChjbSwgZSwgdHlwZSwgcHJldmVudCkge1xcbiAgdmFyIG1YLCBtWVxcbiAgdHJ5IHsgbVggPSBlLmNsaWVudFg7IG1ZID0gZS5jbGllbnRZIH1cXG4gIGNhdGNoKGUpIHsgcmV0dXJuIGZhbHNlIH1cXG4gIGlmIChtWCA+PSBNYXRoLmZsb29yKGNtLmRpc3BsYXkuZ3V0dGVycy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5yaWdodCkpIHsgcmV0dXJuIGZhbHNlIH1cXG4gIGlmIChwcmV2ZW50KSB7IGVfcHJldmVudERlZmF1bHQoZSkgfVxcblxcbiAgdmFyIGRpc3BsYXkgPSBjbS5kaXNwbGF5XFxuICB2YXIgbGluZUJveCA9IGRpc3BsYXkubGluZURpdi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxcblxcbiAgaWYgKG1ZID4gbGluZUJveC5ib3R0b20gfHwgIWhhc0hhbmRsZXIoY20sIHR5cGUpKSB7IHJldHVybiBlX2RlZmF1bHRQcmV2ZW50ZWQoZSkgfVxcbiAgbVkgLT0gbGluZUJveC50b3AgLSBkaXNwbGF5LnZpZXdPZmZzZXRcXG5cXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY20ub3B0aW9ucy5ndXR0ZXJzLmxlbmd0aDsgKytpKSB7XFxuICAgIHZhciBnID0gZGlzcGxheS5ndXR0ZXJzLmNoaWxkTm9kZXNbaV1cXG4gICAgaWYgKGcgJiYgZy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5yaWdodCA+PSBtWCkge1xcbiAgICAgIHZhciBsaW5lID0gbGluZUF0SGVpZ2h0KGNtLmRvYywgbVkpXFxuICAgICAgdmFyIGd1dHRlciA9IGNtLm9wdGlvbnMuZ3V0dGVyc1tpXVxcbiAgICAgIHNpZ25hbChjbSwgdHlwZSwgY20sIGxpbmUsIGd1dHRlciwgZSlcXG4gICAgICByZXR1cm4gZV9kZWZhdWx0UHJldmVudGVkKGUpXFxuICAgIH1cXG4gIH1cXG59XFxuXFxuZnVuY3Rpb24gY2xpY2tJbkd1dHRlcihjbSwgZSkge1xcbiAgcmV0dXJuIGd1dHRlckV2ZW50KGNtLCBlLCBcXFwiZ3V0dGVyQ2xpY2tcXFwiLCB0cnVlKVxcbn1cXG5cXG4vLyBDT05URVhUIE1FTlUgSEFORExJTkdcXG5cXG4vLyBUbyBtYWtlIHRoZSBjb250ZXh0IG1lbnUgd29yaywgd2UgbmVlZCB0byBicmllZmx5IHVuaGlkZSB0aGVcXG4vLyB0ZXh0YXJlYSAobWFraW5nIGl0IGFzIHVub2J0cnVzaXZlIGFzIHBvc3NpYmxlKSB0byBsZXQgdGhlXFxuLy8gcmlnaHQtY2xpY2sgdGFrZSBlZmZlY3Qgb24gaXQuXFxuZnVuY3Rpb24gb25Db250ZXh0TWVudShjbSwgZSkge1xcbiAgaWYgKGV2ZW50SW5XaWRnZXQoY20uZGlzcGxheSwgZSkgfHwgY29udGV4dE1lbnVJbkd1dHRlcihjbSwgZSkpIHsgcmV0dXJuIH1cXG4gIGlmIChzaWduYWxET01FdmVudChjbSwgZSwgXFxcImNvbnRleHRtZW51XFxcIikpIHsgcmV0dXJuIH1cXG4gIGNtLmRpc3BsYXkuaW5wdXQub25Db250ZXh0TWVudShlKVxcbn1cXG5cXG5mdW5jdGlvbiBjb250ZXh0TWVudUluR3V0dGVyKGNtLCBlKSB7XFxuICBpZiAoIWhhc0hhbmRsZXIoY20sIFxcXCJndXR0ZXJDb250ZXh0TWVudVxcXCIpKSB7IHJldHVybiBmYWxzZSB9XFxuICByZXR1cm4gZ3V0dGVyRXZlbnQoY20sIGUsIFxcXCJndXR0ZXJDb250ZXh0TWVudVxcXCIsIGZhbHNlKVxcbn1cXG5cXG5mdW5jdGlvbiB0aGVtZUNoYW5nZWQoY20pIHtcXG4gIGNtLmRpc3BsYXkud3JhcHBlci5jbGFzc05hbWUgPSBjbS5kaXNwbGF5LndyYXBwZXIuY2xhc3NOYW1lLnJlcGxhY2UoL1xcXFxzKmNtLXMtXFxcXFMrL2csIFxcXCJcXFwiKSArXFxuICAgIGNtLm9wdGlvbnMudGhlbWUucmVwbGFjZSgvKF58XFxcXHMpXFxcXHMqL2csIFxcXCIgY20tcy1cXFwiKVxcbiAgY2xlYXJDYWNoZXMoY20pXFxufVxcblxcbnZhciBJbml0ID0ge3RvU3RyaW5nOiBmdW5jdGlvbigpe3JldHVybiBcXFwiQ29kZU1pcnJvci5Jbml0XFxcIn19XFxuXFxudmFyIGRlZmF1bHRzID0ge31cXG52YXIgb3B0aW9uSGFuZGxlcnMgPSB7fVxcblxcbmZ1bmN0aW9uIGRlZmluZU9wdGlvbnMoQ29kZU1pcnJvcikge1xcbiAgdmFyIG9wdGlvbkhhbmRsZXJzID0gQ29kZU1pcnJvci5vcHRpb25IYW5kbGVyc1xcblxcbiAgZnVuY3Rpb24gb3B0aW9uKG5hbWUsIGRlZmx0LCBoYW5kbGUsIG5vdE9uSW5pdCkge1xcbiAgICBDb2RlTWlycm9yLmRlZmF1bHRzW25hbWVdID0gZGVmbHRcXG4gICAgaWYgKGhhbmRsZSkgeyBvcHRpb25IYW5kbGVyc1tuYW1lXSA9XFxuICAgICAgbm90T25Jbml0ID8gZnVuY3Rpb24gKGNtLCB2YWwsIG9sZCkge2lmIChvbGQgIT0gSW5pdCkgeyBoYW5kbGUoY20sIHZhbCwgb2xkKSB9fSA6IGhhbmRsZSB9XFxuICB9XFxuXFxuICBDb2RlTWlycm9yLmRlZmluZU9wdGlvbiA9IG9wdGlvblxcblxcbiAgLy8gUGFzc2VkIHRvIG9wdGlvbiBoYW5kbGVycyB3aGVuIHRoZXJlIGlzIG5vIG9sZCB2YWx1ZS5cXG4gIENvZGVNaXJyb3IuSW5pdCA9IEluaXRcXG5cXG4gIC8vIFRoZXNlIHR3byBhcmUsIG9uIGluaXQsIGNhbGxlZCBmcm9tIHRoZSBjb25zdHJ1Y3RvciBiZWNhdXNlIHRoZXlcXG4gIC8vIGhhdmUgdG8gYmUgaW5pdGlhbGl6ZWQgYmVmb3JlIHRoZSBlZGl0b3IgY2FuIHN0YXJ0IGF0IGFsbC5cXG4gIG9wdGlvbihcXFwidmFsdWVcXFwiLCBcXFwiXFxcIiwgZnVuY3Rpb24gKGNtLCB2YWwpIHsgcmV0dXJuIGNtLnNldFZhbHVlKHZhbCk7IH0sIHRydWUpXFxuICBvcHRpb24oXFxcIm1vZGVcXFwiLCBudWxsLCBmdW5jdGlvbiAoY20sIHZhbCkge1xcbiAgICBjbS5kb2MubW9kZU9wdGlvbiA9IHZhbFxcbiAgICBsb2FkTW9kZShjbSlcXG4gIH0sIHRydWUpXFxuXFxuICBvcHRpb24oXFxcImluZGVudFVuaXRcXFwiLCAyLCBsb2FkTW9kZSwgdHJ1ZSlcXG4gIG9wdGlvbihcXFwiaW5kZW50V2l0aFRhYnNcXFwiLCBmYWxzZSlcXG4gIG9wdGlvbihcXFwic21hcnRJbmRlbnRcXFwiLCB0cnVlKVxcbiAgb3B0aW9uKFxcXCJ0YWJTaXplXFxcIiwgNCwgZnVuY3Rpb24gKGNtKSB7XFxuICAgIHJlc2V0TW9kZVN0YXRlKGNtKVxcbiAgICBjbGVhckNhY2hlcyhjbSlcXG4gICAgcmVnQ2hhbmdlKGNtKVxcbiAgfSwgdHJ1ZSlcXG4gIG9wdGlvbihcXFwibGluZVNlcGFyYXRvclxcXCIsIG51bGwsIGZ1bmN0aW9uIChjbSwgdmFsKSB7XFxuICAgIGNtLmRvYy5saW5lU2VwID0gdmFsXFxuICAgIGlmICghdmFsKSB7IHJldHVybiB9XFxuICAgIHZhciBuZXdCcmVha3MgPSBbXSwgbGluZU5vID0gY20uZG9jLmZpcnN0XFxuICAgIGNtLmRvYy5pdGVyKGZ1bmN0aW9uIChsaW5lKSB7XFxuICAgICAgZm9yICh2YXIgcG9zID0gMDs7KSB7XFxuICAgICAgICB2YXIgZm91bmQgPSBsaW5lLnRleHQuaW5kZXhPZih2YWwsIHBvcylcXG4gICAgICAgIGlmIChmb3VuZCA9PSAtMSkgeyBicmVhayB9XFxuICAgICAgICBwb3MgPSBmb3VuZCArIHZhbC5sZW5ndGhcXG4gICAgICAgIG5ld0JyZWFrcy5wdXNoKFBvcyhsaW5lTm8sIGZvdW5kKSlcXG4gICAgICB9XFxuICAgICAgbGluZU5vKytcXG4gICAgfSlcXG4gICAgZm9yICh2YXIgaSA9IG5ld0JyZWFrcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSlcXG4gICAgICB7IHJlcGxhY2VSYW5nZShjbS5kb2MsIHZhbCwgbmV3QnJlYWtzW2ldLCBQb3MobmV3QnJlYWtzW2ldLmxpbmUsIG5ld0JyZWFrc1tpXS5jaCArIHZhbC5sZW5ndGgpKSB9XFxuICB9KVxcbiAgb3B0aW9uKFxcXCJzcGVjaWFsQ2hhcnNcXFwiLCAvW1xcXFx1MDAwMC1cXFxcdTAwMWZcXFxcdTAwN2ZcXFxcdTAwYWRcXFxcdTIwMGItXFxcXHUyMDBmXFxcXHUyMDI4XFxcXHUyMDI5XFxcXHVmZWZmXS9nLCBmdW5jdGlvbiAoY20sIHZhbCwgb2xkKSB7XFxuICAgIGNtLnN0YXRlLnNwZWNpYWxDaGFycyA9IG5ldyBSZWdFeHAodmFsLnNvdXJjZSArICh2YWwudGVzdChcXFwiXFxcXHRcXFwiKSA/IFxcXCJcXFwiIDogXFxcInxcXFxcdFxcXCIpLCBcXFwiZ1xcXCIpXFxuICAgIGlmIChvbGQgIT0gSW5pdCkgeyBjbS5yZWZyZXNoKCkgfVxcbiAgfSlcXG4gIG9wdGlvbihcXFwic3BlY2lhbENoYXJQbGFjZWhvbGRlclxcXCIsIGRlZmF1bHRTcGVjaWFsQ2hhclBsYWNlaG9sZGVyLCBmdW5jdGlvbiAoY20pIHsgcmV0dXJuIGNtLnJlZnJlc2goKTsgfSwgdHJ1ZSlcXG4gIG9wdGlvbihcXFwiZWxlY3RyaWNDaGFyc1xcXCIsIHRydWUpXFxuICBvcHRpb24oXFxcImlucHV0U3R5bGVcXFwiLCBtb2JpbGUgPyBcXFwiY29udGVudGVkaXRhYmxlXFxcIiA6IFxcXCJ0ZXh0YXJlYVxcXCIsIGZ1bmN0aW9uICgpIHtcXG4gICAgdGhyb3cgbmV3IEVycm9yKFxcXCJpbnB1dFN0eWxlIGNhbiBub3QgKHlldCkgYmUgY2hhbmdlZCBpbiBhIHJ1bm5pbmcgZWRpdG9yXFxcIikgLy8gRklYTUVcXG4gIH0sIHRydWUpXFxuICBvcHRpb24oXFxcInNwZWxsY2hlY2tcXFwiLCBmYWxzZSwgZnVuY3Rpb24gKGNtLCB2YWwpIHsgcmV0dXJuIGNtLmdldElucHV0RmllbGQoKS5zcGVsbGNoZWNrID0gdmFsOyB9LCB0cnVlKVxcbiAgb3B0aW9uKFxcXCJydGxNb3ZlVmlzdWFsbHlcXFwiLCAhd2luZG93cylcXG4gIG9wdGlvbihcXFwid2hvbGVMaW5lVXBkYXRlQmVmb3JlXFxcIiwgdHJ1ZSlcXG5cXG4gIG9wdGlvbihcXFwidGhlbWVcXFwiLCBcXFwiZGVmYXVsdFxcXCIsIGZ1bmN0aW9uIChjbSkge1xcbiAgICB0aGVtZUNoYW5nZWQoY20pXFxuICAgIGd1dHRlcnNDaGFuZ2VkKGNtKVxcbiAgfSwgdHJ1ZSlcXG4gIG9wdGlvbihcXFwia2V5TWFwXFxcIiwgXFxcImRlZmF1bHRcXFwiLCBmdW5jdGlvbiAoY20sIHZhbCwgb2xkKSB7XFxuICAgIHZhciBuZXh0ID0gZ2V0S2V5TWFwKHZhbClcXG4gICAgdmFyIHByZXYgPSBvbGQgIT0gSW5pdCAmJiBnZXRLZXlNYXAob2xkKVxcbiAgICBpZiAocHJldiAmJiBwcmV2LmRldGFjaCkgeyBwcmV2LmRldGFjaChjbSwgbmV4dCkgfVxcbiAgICBpZiAobmV4dC5hdHRhY2gpIHsgbmV4dC5hdHRhY2goY20sIHByZXYgfHwgbnVsbCkgfVxcbiAgfSlcXG4gIG9wdGlvbihcXFwiZXh0cmFLZXlzXFxcIiwgbnVsbClcXG5cXG4gIG9wdGlvbihcXFwibGluZVdyYXBwaW5nXFxcIiwgZmFsc2UsIHdyYXBwaW5nQ2hhbmdlZCwgdHJ1ZSlcXG4gIG9wdGlvbihcXFwiZ3V0dGVyc1xcXCIsIFtdLCBmdW5jdGlvbiAoY20pIHtcXG4gICAgc2V0R3V0dGVyc0ZvckxpbmVOdW1iZXJzKGNtLm9wdGlvbnMpXFxuICAgIGd1dHRlcnNDaGFuZ2VkKGNtKVxcbiAgfSwgdHJ1ZSlcXG4gIG9wdGlvbihcXFwiZml4ZWRHdXR0ZXJcXFwiLCB0cnVlLCBmdW5jdGlvbiAoY20sIHZhbCkge1xcbiAgICBjbS5kaXNwbGF5Lmd1dHRlcnMuc3R5bGUubGVmdCA9IHZhbCA/IGNvbXBlbnNhdGVGb3JIU2Nyb2xsKGNtLmRpc3BsYXkpICsgXFxcInB4XFxcIiA6IFxcXCIwXFxcIlxcbiAgICBjbS5yZWZyZXNoKClcXG4gIH0sIHRydWUpXFxuICBvcHRpb24oXFxcImNvdmVyR3V0dGVyTmV4dFRvU2Nyb2xsYmFyXFxcIiwgZmFsc2UsIGZ1bmN0aW9uIChjbSkgeyByZXR1cm4gdXBkYXRlU2Nyb2xsYmFycyhjbSk7IH0sIHRydWUpXFxuICBvcHRpb24oXFxcInNjcm9sbGJhclN0eWxlXFxcIiwgXFxcIm5hdGl2ZVxcXCIsIGZ1bmN0aW9uIChjbSkge1xcbiAgICBpbml0U2Nyb2xsYmFycyhjbSlcXG4gICAgdXBkYXRlU2Nyb2xsYmFycyhjbSlcXG4gICAgY20uZGlzcGxheS5zY3JvbGxiYXJzLnNldFNjcm9sbFRvcChjbS5kb2Muc2Nyb2xsVG9wKVxcbiAgICBjbS5kaXNwbGF5LnNjcm9sbGJhcnMuc2V0U2Nyb2xsTGVmdChjbS5kb2Muc2Nyb2xsTGVmdClcXG4gIH0sIHRydWUpXFxuICBvcHRpb24oXFxcImxpbmVOdW1iZXJzXFxcIiwgZmFsc2UsIGZ1bmN0aW9uIChjbSkge1xcbiAgICBzZXRHdXR0ZXJzRm9yTGluZU51bWJlcnMoY20ub3B0aW9ucylcXG4gICAgZ3V0dGVyc0NoYW5nZWQoY20pXFxuICB9LCB0cnVlKVxcbiAgb3B0aW9uKFxcXCJmaXJzdExpbmVOdW1iZXJcXFwiLCAxLCBndXR0ZXJzQ2hhbmdlZCwgdHJ1ZSlcXG4gIG9wdGlvbihcXFwibGluZU51bWJlckZvcm1hdHRlclxcXCIsIGZ1bmN0aW9uIChpbnRlZ2VyKSB7IHJldHVybiBpbnRlZ2VyOyB9LCBndXR0ZXJzQ2hhbmdlZCwgdHJ1ZSlcXG4gIG9wdGlvbihcXFwic2hvd0N1cnNvcldoZW5TZWxlY3RpbmdcXFwiLCBmYWxzZSwgdXBkYXRlU2VsZWN0aW9uLCB0cnVlKVxcblxcbiAgb3B0aW9uKFxcXCJyZXNldFNlbGVjdGlvbk9uQ29udGV4dE1lbnVcXFwiLCB0cnVlKVxcbiAgb3B0aW9uKFxcXCJsaW5lV2lzZUNvcHlDdXRcXFwiLCB0cnVlKVxcblxcbiAgb3B0aW9uKFxcXCJyZWFkT25seVxcXCIsIGZhbHNlLCBmdW5jdGlvbiAoY20sIHZhbCkge1xcbiAgICBpZiAodmFsID09IFxcXCJub2N1cnNvclxcXCIpIHtcXG4gICAgICBvbkJsdXIoY20pXFxuICAgICAgY20uZGlzcGxheS5pbnB1dC5ibHVyKClcXG4gICAgICBjbS5kaXNwbGF5LmRpc2FibGVkID0gdHJ1ZVxcbiAgICB9IGVsc2Uge1xcbiAgICAgIGNtLmRpc3BsYXkuZGlzYWJsZWQgPSBmYWxzZVxcbiAgICB9XFxuICAgIGNtLmRpc3BsYXkuaW5wdXQucmVhZE9ubHlDaGFuZ2VkKHZhbClcXG4gIH0pXFxuICBvcHRpb24oXFxcImRpc2FibGVJbnB1dFxcXCIsIGZhbHNlLCBmdW5jdGlvbiAoY20sIHZhbCkge2lmICghdmFsKSB7IGNtLmRpc3BsYXkuaW5wdXQucmVzZXQoKSB9fSwgdHJ1ZSlcXG4gIG9wdGlvbihcXFwiZHJhZ0Ryb3BcXFwiLCB0cnVlLCBkcmFnRHJvcENoYW5nZWQpXFxuICBvcHRpb24oXFxcImFsbG93RHJvcEZpbGVUeXBlc1xcXCIsIG51bGwpXFxuXFxuICBvcHRpb24oXFxcImN1cnNvckJsaW5rUmF0ZVxcXCIsIDUzMClcXG4gIG9wdGlvbihcXFwiY3Vyc29yU2Nyb2xsTWFyZ2luXFxcIiwgMClcXG4gIG9wdGlvbihcXFwiY3Vyc29ySGVpZ2h0XFxcIiwgMSwgdXBkYXRlU2VsZWN0aW9uLCB0cnVlKVxcbiAgb3B0aW9uKFxcXCJzaW5nbGVDdXJzb3JIZWlnaHRQZXJMaW5lXFxcIiwgdHJ1ZSwgdXBkYXRlU2VsZWN0aW9uLCB0cnVlKVxcbiAgb3B0aW9uKFxcXCJ3b3JrVGltZVxcXCIsIDEwMClcXG4gIG9wdGlvbihcXFwid29ya0RlbGF5XFxcIiwgMTAwKVxcbiAgb3B0aW9uKFxcXCJmbGF0dGVuU3BhbnNcXFwiLCB0cnVlLCByZXNldE1vZGVTdGF0ZSwgdHJ1ZSlcXG4gIG9wdGlvbihcXFwiYWRkTW9kZUNsYXNzXFxcIiwgZmFsc2UsIHJlc2V0TW9kZVN0YXRlLCB0cnVlKVxcbiAgb3B0aW9uKFxcXCJwb2xsSW50ZXJ2YWxcXFwiLCAxMDApXFxuICBvcHRpb24oXFxcInVuZG9EZXB0aFxcXCIsIDIwMCwgZnVuY3Rpb24gKGNtLCB2YWwpIHsgcmV0dXJuIGNtLmRvYy5oaXN0b3J5LnVuZG9EZXB0aCA9IHZhbDsgfSlcXG4gIG9wdGlvbihcXFwiaGlzdG9yeUV2ZW50RGVsYXlcXFwiLCAxMjUwKVxcbiAgb3B0aW9uKFxcXCJ2aWV3cG9ydE1hcmdpblxcXCIsIDEwLCBmdW5jdGlvbiAoY20pIHsgcmV0dXJuIGNtLnJlZnJlc2goKTsgfSwgdHJ1ZSlcXG4gIG9wdGlvbihcXFwibWF4SGlnaGxpZ2h0TGVuZ3RoXFxcIiwgMTAwMDAsIHJlc2V0TW9kZVN0YXRlLCB0cnVlKVxcbiAgb3B0aW9uKFxcXCJtb3ZlSW5wdXRXaXRoQ3Vyc29yXFxcIiwgdHJ1ZSwgZnVuY3Rpb24gKGNtLCB2YWwpIHtcXG4gICAgaWYgKCF2YWwpIHsgY20uZGlzcGxheS5pbnB1dC5yZXNldFBvc2l0aW9uKCkgfVxcbiAgfSlcXG5cXG4gIG9wdGlvbihcXFwidGFiaW5kZXhcXFwiLCBudWxsLCBmdW5jdGlvbiAoY20sIHZhbCkgeyByZXR1cm4gY20uZGlzcGxheS5pbnB1dC5nZXRGaWVsZCgpLnRhYkluZGV4ID0gdmFsIHx8IFxcXCJcXFwiOyB9KVxcbiAgb3B0aW9uKFxcXCJhdXRvZm9jdXNcXFwiLCBudWxsKVxcbn1cXG5cXG5mdW5jdGlvbiBndXR0ZXJzQ2hhbmdlZChjbSkge1xcbiAgdXBkYXRlR3V0dGVycyhjbSlcXG4gIHJlZ0NoYW5nZShjbSlcXG4gIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyByZXR1cm4gYWxpZ25Ib3Jpem9udGFsbHkoY20pOyB9LCAyMClcXG59XFxuXFxuZnVuY3Rpb24gZHJhZ0Ryb3BDaGFuZ2VkKGNtLCB2YWx1ZSwgb2xkKSB7XFxuICB2YXIgd2FzT24gPSBvbGQgJiYgb2xkICE9IEluaXRcXG4gIGlmICghdmFsdWUgIT0gIXdhc09uKSB7XFxuICAgIHZhciBmdW5jcyA9IGNtLmRpc3BsYXkuZHJhZ0Z1bmN0aW9uc1xcbiAgICB2YXIgdG9nZ2xlID0gdmFsdWUgPyBvbiA6IG9mZlxcbiAgICB0b2dnbGUoY20uZGlzcGxheS5zY3JvbGxlciwgXFxcImRyYWdzdGFydFxcXCIsIGZ1bmNzLnN0YXJ0KVxcbiAgICB0b2dnbGUoY20uZGlzcGxheS5zY3JvbGxlciwgXFxcImRyYWdlbnRlclxcXCIsIGZ1bmNzLmVudGVyKVxcbiAgICB0b2dnbGUoY20uZGlzcGxheS5zY3JvbGxlciwgXFxcImRyYWdvdmVyXFxcIiwgZnVuY3Mub3ZlcilcXG4gICAgdG9nZ2xlKGNtLmRpc3BsYXkuc2Nyb2xsZXIsIFxcXCJkcmFnbGVhdmVcXFwiLCBmdW5jcy5sZWF2ZSlcXG4gICAgdG9nZ2xlKGNtLmRpc3BsYXkuc2Nyb2xsZXIsIFxcXCJkcm9wXFxcIiwgZnVuY3MuZHJvcClcXG4gIH1cXG59XFxuXFxuZnVuY3Rpb24gd3JhcHBpbmdDaGFuZ2VkKGNtKSB7XFxuICBpZiAoY20ub3B0aW9ucy5saW5lV3JhcHBpbmcpIHtcXG4gICAgYWRkQ2xhc3MoY20uZGlzcGxheS53cmFwcGVyLCBcXFwiQ29kZU1pcnJvci13cmFwXFxcIilcXG4gICAgY20uZGlzcGxheS5zaXplci5zdHlsZS5taW5XaWR0aCA9IFxcXCJcXFwiXFxuICAgIGNtLmRpc3BsYXkuc2l6ZXJXaWR0aCA9IG51bGxcXG4gIH0gZWxzZSB7XFxuICAgIHJtQ2xhc3MoY20uZGlzcGxheS53cmFwcGVyLCBcXFwiQ29kZU1pcnJvci13cmFwXFxcIilcXG4gICAgZmluZE1heExpbmUoY20pXFxuICB9XFxuICBlc3RpbWF0ZUxpbmVIZWlnaHRzKGNtKVxcbiAgcmVnQ2hhbmdlKGNtKVxcbiAgY2xlYXJDYWNoZXMoY20pXFxuICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIHVwZGF0ZVNjcm9sbGJhcnMoY20pOyB9LCAxMDApXFxufVxcblxcbi8vIEEgQ29kZU1pcnJvciBpbnN0YW5jZSByZXByZXNlbnRzIGFuIGVkaXRvci4gVGhpcyBpcyB0aGUgb2JqZWN0XFxuLy8gdGhhdCB1c2VyIGNvZGUgaXMgdXN1YWxseSBkZWFsaW5nIHdpdGguXFxuXFxuZnVuY3Rpb24gQ29kZU1pcnJvcihwbGFjZSwgb3B0aW9ucykge1xcbiAgdmFyIHRoaXMkMSA9IHRoaXM7XFxuXFxuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgQ29kZU1pcnJvcikpIHsgcmV0dXJuIG5ldyBDb2RlTWlycm9yKHBsYWNlLCBvcHRpb25zKSB9XFxuXFxuICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zID0gb3B0aW9ucyA/IGNvcHlPYmoob3B0aW9ucykgOiB7fVxcbiAgLy8gRGV0ZXJtaW5lIGVmZmVjdGl2ZSBvcHRpb25zIGJhc2VkIG9uIGdpdmVuIHZhbHVlcyBhbmQgZGVmYXVsdHMuXFxuICBjb3B5T2JqKGRlZmF1bHRzLCBvcHRpb25zLCBmYWxzZSlcXG4gIHNldEd1dHRlcnNGb3JMaW5lTnVtYmVycyhvcHRpb25zKVxcblxcbiAgdmFyIGRvYyA9IG9wdGlvbnMudmFsdWVcXG4gIGlmICh0eXBlb2YgZG9jID09IFxcXCJzdHJpbmdcXFwiKSB7IGRvYyA9IG5ldyBEb2MoZG9jLCBvcHRpb25zLm1vZGUsIG51bGwsIG9wdGlvbnMubGluZVNlcGFyYXRvcikgfVxcbiAgdGhpcy5kb2MgPSBkb2NcXG5cXG4gIHZhciBpbnB1dCA9IG5ldyBDb2RlTWlycm9yLmlucHV0U3R5bGVzW29wdGlvbnMuaW5wdXRTdHlsZV0odGhpcylcXG4gIHZhciBkaXNwbGF5ID0gdGhpcy5kaXNwbGF5ID0gbmV3IERpc3BsYXkocGxhY2UsIGRvYywgaW5wdXQpXFxuICBkaXNwbGF5LndyYXBwZXIuQ29kZU1pcnJvciA9IHRoaXNcXG4gIHVwZGF0ZUd1dHRlcnModGhpcylcXG4gIHRoZW1lQ2hhbmdlZCh0aGlzKVxcbiAgaWYgKG9wdGlvbnMubGluZVdyYXBwaW5nKVxcbiAgICB7IHRoaXMuZGlzcGxheS53cmFwcGVyLmNsYXNzTmFtZSArPSBcXFwiIENvZGVNaXJyb3Itd3JhcFxcXCIgfVxcbiAgaWYgKG9wdGlvbnMuYXV0b2ZvY3VzICYmICFtb2JpbGUpIHsgZGlzcGxheS5pbnB1dC5mb2N1cygpIH1cXG4gIGluaXRTY3JvbGxiYXJzKHRoaXMpXFxuXFxuICB0aGlzLnN0YXRlID0ge1xcbiAgICBrZXlNYXBzOiBbXSwgIC8vIHN0b3JlcyBtYXBzIGFkZGVkIGJ5IGFkZEtleU1hcFxcbiAgICBvdmVybGF5czogW10sIC8vIGhpZ2hsaWdodGluZyBvdmVybGF5cywgYXMgYWRkZWQgYnkgYWRkT3ZlcmxheVxcbiAgICBtb2RlR2VuOiAwLCAgIC8vIGJ1bXBlZCB3aGVuIG1vZGUvb3ZlcmxheSBjaGFuZ2VzLCB1c2VkIHRvIGludmFsaWRhdGUgaGlnaGxpZ2h0aW5nIGluZm9cXG4gICAgb3ZlcndyaXRlOiBmYWxzZSxcXG4gICAgZGVsYXlpbmdCbHVyRXZlbnQ6IGZhbHNlLFxcbiAgICBmb2N1c2VkOiBmYWxzZSxcXG4gICAgc3VwcHJlc3NFZGl0czogZmFsc2UsIC8vIHVzZWQgdG8gZGlzYWJsZSBlZGl0aW5nIGR1cmluZyBrZXkgaGFuZGxlcnMgd2hlbiBpbiByZWFkT25seSBtb2RlXFxuICAgIHBhc3RlSW5jb21pbmc6IGZhbHNlLCBjdXRJbmNvbWluZzogZmFsc2UsIC8vIGhlbHAgcmVjb2duaXplIHBhc3RlL2N1dCBlZGl0cyBpbiBpbnB1dC5wb2xsXFxuICAgIHNlbGVjdGluZ1RleHQ6IGZhbHNlLFxcbiAgICBkcmFnZ2luZ1RleHQ6IGZhbHNlLFxcbiAgICBoaWdobGlnaHQ6IG5ldyBEZWxheWVkKCksIC8vIHN0b3JlcyBoaWdobGlnaHQgd29ya2VyIHRpbWVvdXRcXG4gICAga2V5U2VxOiBudWxsLCAgLy8gVW5maW5pc2hlZCBrZXkgc2VxdWVuY2VcXG4gICAgc3BlY2lhbENoYXJzOiBudWxsXFxuICB9XFxuXFxuICAvLyBPdmVycmlkZSBtYWdpYyB0ZXh0YXJlYSBjb250ZW50IHJlc3RvcmUgdGhhdCBJRSBzb21ldGltZXMgZG9lc1xcbiAgLy8gb24gb3VyIGhpZGRlbiB0ZXh0YXJlYSBvbiByZWxvYWRcXG4gIGlmIChpZSAmJiBpZV92ZXJzaW9uIDwgMTEpIHsgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzJDEuZGlzcGxheS5pbnB1dC5yZXNldCh0cnVlKTsgfSwgMjApIH1cXG5cXG4gIHJlZ2lzdGVyRXZlbnRIYW5kbGVycyh0aGlzKVxcbiAgZW5zdXJlR2xvYmFsSGFuZGxlcnMoKVxcblxcbiAgc3RhcnRPcGVyYXRpb24odGhpcylcXG4gIHRoaXMuY3VyT3AuZm9yY2VVcGRhdGUgPSB0cnVlXFxuICBhdHRhY2hEb2ModGhpcywgZG9jKVxcblxcbiAgaWYgKChvcHRpb25zLmF1dG9mb2N1cyAmJiAhbW9iaWxlKSB8fCB0aGlzLmhhc0ZvY3VzKCkpXFxuICAgIHsgc2V0VGltZW91dChiaW5kKG9uRm9jdXMsIHRoaXMpLCAyMCkgfVxcbiAgZWxzZVxcbiAgICB7IG9uQmx1cih0aGlzKSB9XFxuXFxuICBmb3IgKHZhciBvcHQgaW4gb3B0aW9uSGFuZGxlcnMpIHsgaWYgKG9wdGlvbkhhbmRsZXJzLmhhc093blByb3BlcnR5KG9wdCkpXFxuICAgIHsgb3B0aW9uSGFuZGxlcnNbb3B0XSh0aGlzJDEsIG9wdGlvbnNbb3B0XSwgSW5pdCkgfSB9XFxuICBtYXliZVVwZGF0ZUxpbmVOdW1iZXJXaWR0aCh0aGlzKVxcbiAgaWYgKG9wdGlvbnMuZmluaXNoSW5pdCkgeyBvcHRpb25zLmZpbmlzaEluaXQodGhpcykgfVxcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbml0SG9va3MubGVuZ3RoOyArK2kpIHsgaW5pdEhvb2tzW2ldKHRoaXMkMSkgfVxcbiAgZW5kT3BlcmF0aW9uKHRoaXMpXFxuICAvLyBTdXBwcmVzcyBvcHRpbWl6ZWxlZ2liaWxpdHkgaW4gV2Via2l0LCBzaW5jZSBpdCBicmVha3MgdGV4dFxcbiAgLy8gbWVhc3VyaW5nIG9uIGxpbmUgd3JhcHBpbmcgYm91bmRhcmllcy5cXG4gIGlmICh3ZWJraXQgJiYgb3B0aW9ucy5saW5lV3JhcHBpbmcgJiZcXG4gICAgICBnZXRDb21wdXRlZFN0eWxlKGRpc3BsYXkubGluZURpdikudGV4dFJlbmRlcmluZyA9PSBcXFwib3B0aW1pemVsZWdpYmlsaXR5XFxcIilcXG4gICAgeyBkaXNwbGF5LmxpbmVEaXYuc3R5bGUudGV4dFJlbmRlcmluZyA9IFxcXCJhdXRvXFxcIiB9XFxufVxcblxcbi8vIFRoZSBkZWZhdWx0IGNvbmZpZ3VyYXRpb24gb3B0aW9ucy5cXG5Db2RlTWlycm9yLmRlZmF1bHRzID0gZGVmYXVsdHNcXG4vLyBGdW5jdGlvbnMgdG8gcnVuIHdoZW4gb3B0aW9ucyBhcmUgY2hhbmdlZC5cXG5Db2RlTWlycm9yLm9wdGlvbkhhbmRsZXJzID0gb3B0aW9uSGFuZGxlcnNcXG5cXG4vLyBBdHRhY2ggdGhlIG5lY2Vzc2FyeSBldmVudCBoYW5kbGVycyB3aGVuIGluaXRpYWxpemluZyB0aGUgZWRpdG9yXFxuZnVuY3Rpb24gcmVnaXN0ZXJFdmVudEhhbmRsZXJzKGNtKSB7XFxuICB2YXIgZCA9IGNtLmRpc3BsYXlcXG4gIG9uKGQuc2Nyb2xsZXIsIFxcXCJtb3VzZWRvd25cXFwiLCBvcGVyYXRpb24oY20sIG9uTW91c2VEb3duKSlcXG4gIC8vIE9sZGVyIElFJ3Mgd2lsbCBub3QgZmlyZSBhIHNlY29uZCBtb3VzZWRvd24gZm9yIGEgZG91YmxlIGNsaWNrXFxuICBpZiAoaWUgJiYgaWVfdmVyc2lvbiA8IDExKVxcbiAgICB7IG9uKGQuc2Nyb2xsZXIsIFxcXCJkYmxjbGlja1xcXCIsIG9wZXJhdGlvbihjbSwgZnVuY3Rpb24gKGUpIHtcXG4gICAgICBpZiAoc2lnbmFsRE9NRXZlbnQoY20sIGUpKSB7IHJldHVybiB9XFxuICAgICAgdmFyIHBvcyA9IHBvc0Zyb21Nb3VzZShjbSwgZSlcXG4gICAgICBpZiAoIXBvcyB8fCBjbGlja0luR3V0dGVyKGNtLCBlKSB8fCBldmVudEluV2lkZ2V0KGNtLmRpc3BsYXksIGUpKSB7IHJldHVybiB9XFxuICAgICAgZV9wcmV2ZW50RGVmYXVsdChlKVxcbiAgICAgIHZhciB3b3JkID0gY20uZmluZFdvcmRBdChwb3MpXFxuICAgICAgZXh0ZW5kU2VsZWN0aW9uKGNtLmRvYywgd29yZC5hbmNob3IsIHdvcmQuaGVhZClcXG4gICAgfSkpIH1cXG4gIGVsc2VcXG4gICAgeyBvbihkLnNjcm9sbGVyLCBcXFwiZGJsY2xpY2tcXFwiLCBmdW5jdGlvbiAoZSkgeyByZXR1cm4gc2lnbmFsRE9NRXZlbnQoY20sIGUpIHx8IGVfcHJldmVudERlZmF1bHQoZSk7IH0pIH1cXG4gIC8vIFNvbWUgYnJvd3NlcnMgZmlyZSBjb250ZXh0bWVudSAqYWZ0ZXIqIG9wZW5pbmcgdGhlIG1lbnUsIGF0XFxuICAvLyB3aGljaCBwb2ludCB3ZSBjYW4ndCBtZXNzIHdpdGggaXQgYW55bW9yZS4gQ29udGV4dCBtZW51IGlzXFxuICAvLyBoYW5kbGVkIGluIG9uTW91c2VEb3duIGZvciB0aGVzZSBicm93c2Vycy5cXG4gIGlmICghY2FwdHVyZVJpZ2h0Q2xpY2spIHsgb24oZC5zY3JvbGxlciwgXFxcImNvbnRleHRtZW51XFxcIiwgZnVuY3Rpb24gKGUpIHsgcmV0dXJuIG9uQ29udGV4dE1lbnUoY20sIGUpOyB9KSB9XFxuXFxuICAvLyBVc2VkIHRvIHN1cHByZXNzIG1vdXNlIGV2ZW50IGhhbmRsaW5nIHdoZW4gYSB0b3VjaCBoYXBwZW5zXFxuICB2YXIgdG91Y2hGaW5pc2hlZCwgcHJldlRvdWNoID0ge2VuZDogMH1cXG4gIGZ1bmN0aW9uIGZpbmlzaFRvdWNoKCkge1xcbiAgICBpZiAoZC5hY3RpdmVUb3VjaCkge1xcbiAgICAgIHRvdWNoRmluaXNoZWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIGQuYWN0aXZlVG91Y2ggPSBudWxsOyB9LCAxMDAwKVxcbiAgICAgIHByZXZUb3VjaCA9IGQuYWN0aXZlVG91Y2hcXG4gICAgICBwcmV2VG91Y2guZW5kID0gK25ldyBEYXRlXFxuICAgIH1cXG4gIH1cXG4gIGZ1bmN0aW9uIGlzTW91c2VMaWtlVG91Y2hFdmVudChlKSB7XFxuICAgIGlmIChlLnRvdWNoZXMubGVuZ3RoICE9IDEpIHsgcmV0dXJuIGZhbHNlIH1cXG4gICAgdmFyIHRvdWNoID0gZS50b3VjaGVzWzBdXFxuICAgIHJldHVybiB0b3VjaC5yYWRpdXNYIDw9IDEgJiYgdG91Y2gucmFkaXVzWSA8PSAxXFxuICB9XFxuICBmdW5jdGlvbiBmYXJBd2F5KHRvdWNoLCBvdGhlcikge1xcbiAgICBpZiAob3RoZXIubGVmdCA9PSBudWxsKSB7IHJldHVybiB0cnVlIH1cXG4gICAgdmFyIGR4ID0gb3RoZXIubGVmdCAtIHRvdWNoLmxlZnQsIGR5ID0gb3RoZXIudG9wIC0gdG91Y2gudG9wXFxuICAgIHJldHVybiBkeCAqIGR4ICsgZHkgKiBkeSA+IDIwICogMjBcXG4gIH1cXG4gIG9uKGQuc2Nyb2xsZXIsIFxcXCJ0b3VjaHN0YXJ0XFxcIiwgZnVuY3Rpb24gKGUpIHtcXG4gICAgaWYgKCFzaWduYWxET01FdmVudChjbSwgZSkgJiYgIWlzTW91c2VMaWtlVG91Y2hFdmVudChlKSkge1xcbiAgICAgIGNsZWFyVGltZW91dCh0b3VjaEZpbmlzaGVkKVxcbiAgICAgIHZhciBub3cgPSArbmV3IERhdGVcXG4gICAgICBkLmFjdGl2ZVRvdWNoID0ge3N0YXJ0OiBub3csIG1vdmVkOiBmYWxzZSxcXG4gICAgICAgICAgICAgICAgICAgICAgIHByZXY6IG5vdyAtIHByZXZUb3VjaC5lbmQgPD0gMzAwID8gcHJldlRvdWNoIDogbnVsbH1cXG4gICAgICBpZiAoZS50b3VjaGVzLmxlbmd0aCA9PSAxKSB7XFxuICAgICAgICBkLmFjdGl2ZVRvdWNoLmxlZnQgPSBlLnRvdWNoZXNbMF0ucGFnZVhcXG4gICAgICAgIGQuYWN0aXZlVG91Y2gudG9wID0gZS50b3VjaGVzWzBdLnBhZ2VZXFxuICAgICAgfVxcbiAgICB9XFxuICB9KVxcbiAgb24oZC5zY3JvbGxlciwgXFxcInRvdWNobW92ZVxcXCIsIGZ1bmN0aW9uICgpIHtcXG4gICAgaWYgKGQuYWN0aXZlVG91Y2gpIHsgZC5hY3RpdmVUb3VjaC5tb3ZlZCA9IHRydWUgfVxcbiAgfSlcXG4gIG9uKGQuc2Nyb2xsZXIsIFxcXCJ0b3VjaGVuZFxcXCIsIGZ1bmN0aW9uIChlKSB7XFxuICAgIHZhciB0b3VjaCA9IGQuYWN0aXZlVG91Y2hcXG4gICAgaWYgKHRvdWNoICYmICFldmVudEluV2lkZ2V0KGQsIGUpICYmIHRvdWNoLmxlZnQgIT0gbnVsbCAmJlxcbiAgICAgICAgIXRvdWNoLm1vdmVkICYmIG5ldyBEYXRlIC0gdG91Y2guc3RhcnQgPCAzMDApIHtcXG4gICAgICB2YXIgcG9zID0gY20uY29vcmRzQ2hhcihkLmFjdGl2ZVRvdWNoLCBcXFwicGFnZVxcXCIpLCByYW5nZVxcbiAgICAgIGlmICghdG91Y2gucHJldiB8fCBmYXJBd2F5KHRvdWNoLCB0b3VjaC5wcmV2KSkgLy8gU2luZ2xlIHRhcFxcbiAgICAgICAgeyByYW5nZSA9IG5ldyBSYW5nZShwb3MsIHBvcykgfVxcbiAgICAgIGVsc2UgaWYgKCF0b3VjaC5wcmV2LnByZXYgfHwgZmFyQXdheSh0b3VjaCwgdG91Y2gucHJldi5wcmV2KSkgLy8gRG91YmxlIHRhcFxcbiAgICAgICAgeyByYW5nZSA9IGNtLmZpbmRXb3JkQXQocG9zKSB9XFxuICAgICAgZWxzZSAvLyBUcmlwbGUgdGFwXFxuICAgICAgICB7IHJhbmdlID0gbmV3IFJhbmdlKFBvcyhwb3MubGluZSwgMCksIGNsaXBQb3MoY20uZG9jLCBQb3MocG9zLmxpbmUgKyAxLCAwKSkpIH1cXG4gICAgICBjbS5zZXRTZWxlY3Rpb24ocmFuZ2UuYW5jaG9yLCByYW5nZS5oZWFkKVxcbiAgICAgIGNtLmZvY3VzKClcXG4gICAgICBlX3ByZXZlbnREZWZhdWx0KGUpXFxuICAgIH1cXG4gICAgZmluaXNoVG91Y2goKVxcbiAgfSlcXG4gIG9uKGQuc2Nyb2xsZXIsIFxcXCJ0b3VjaGNhbmNlbFxcXCIsIGZpbmlzaFRvdWNoKVxcblxcbiAgLy8gU3luYyBzY3JvbGxpbmcgYmV0d2VlbiBmYWtlIHNjcm9sbGJhcnMgYW5kIHJlYWwgc2Nyb2xsYWJsZVxcbiAgLy8gYXJlYSwgZW5zdXJlIHZpZXdwb3J0IGlzIHVwZGF0ZWQgd2hlbiBzY3JvbGxpbmcuXFxuICBvbihkLnNjcm9sbGVyLCBcXFwic2Nyb2xsXFxcIiwgZnVuY3Rpb24gKCkge1xcbiAgICBpZiAoZC5zY3JvbGxlci5jbGllbnRIZWlnaHQpIHtcXG4gICAgICBzZXRTY3JvbGxUb3AoY20sIGQuc2Nyb2xsZXIuc2Nyb2xsVG9wKVxcbiAgICAgIHNldFNjcm9sbExlZnQoY20sIGQuc2Nyb2xsZXIuc2Nyb2xsTGVmdCwgdHJ1ZSlcXG4gICAgICBzaWduYWwoY20sIFxcXCJzY3JvbGxcXFwiLCBjbSlcXG4gICAgfVxcbiAgfSlcXG5cXG4gIC8vIExpc3RlbiB0byB3aGVlbCBldmVudHMgaW4gb3JkZXIgdG8gdHJ5IGFuZCB1cGRhdGUgdGhlIHZpZXdwb3J0IG9uIHRpbWUuXFxuICBvbihkLnNjcm9sbGVyLCBcXFwibW91c2V3aGVlbFxcXCIsIGZ1bmN0aW9uIChlKSB7IHJldHVybiBvblNjcm9sbFdoZWVsKGNtLCBlKTsgfSlcXG4gIG9uKGQuc2Nyb2xsZXIsIFxcXCJET01Nb3VzZVNjcm9sbFxcXCIsIGZ1bmN0aW9uIChlKSB7IHJldHVybiBvblNjcm9sbFdoZWVsKGNtLCBlKTsgfSlcXG5cXG4gIC8vIFByZXZlbnQgd3JhcHBlciBmcm9tIGV2ZXIgc2Nyb2xsaW5nXFxuICBvbihkLndyYXBwZXIsIFxcXCJzY3JvbGxcXFwiLCBmdW5jdGlvbiAoKSB7IHJldHVybiBkLndyYXBwZXIuc2Nyb2xsVG9wID0gZC53cmFwcGVyLnNjcm9sbExlZnQgPSAwOyB9KVxcblxcbiAgZC5kcmFnRnVuY3Rpb25zID0ge1xcbiAgICBlbnRlcjogZnVuY3Rpb24gKGUpIHtpZiAoIXNpZ25hbERPTUV2ZW50KGNtLCBlKSkgeyBlX3N0b3AoZSkgfX0sXFxuICAgIG92ZXI6IGZ1bmN0aW9uIChlKSB7aWYgKCFzaWduYWxET01FdmVudChjbSwgZSkpIHsgb25EcmFnT3ZlcihjbSwgZSk7IGVfc3RvcChlKSB9fSxcXG4gICAgc3RhcnQ6IGZ1bmN0aW9uIChlKSB7IHJldHVybiBvbkRyYWdTdGFydChjbSwgZSk7IH0sXFxuICAgIGRyb3A6IG9wZXJhdGlvbihjbSwgb25Ecm9wKSxcXG4gICAgbGVhdmU6IGZ1bmN0aW9uIChlKSB7aWYgKCFzaWduYWxET01FdmVudChjbSwgZSkpIHsgY2xlYXJEcmFnQ3Vyc29yKGNtKSB9fVxcbiAgfVxcblxcbiAgdmFyIGlucCA9IGQuaW5wdXQuZ2V0RmllbGQoKVxcbiAgb24oaW5wLCBcXFwia2V5dXBcXFwiLCBmdW5jdGlvbiAoZSkgeyByZXR1cm4gb25LZXlVcC5jYWxsKGNtLCBlKTsgfSlcXG4gIG9uKGlucCwgXFxcImtleWRvd25cXFwiLCBvcGVyYXRpb24oY20sIG9uS2V5RG93bikpXFxuICBvbihpbnAsIFxcXCJrZXlwcmVzc1xcXCIsIG9wZXJhdGlvbihjbSwgb25LZXlQcmVzcykpXFxuICBvbihpbnAsIFxcXCJmb2N1c1xcXCIsIGZ1bmN0aW9uIChlKSB7IHJldHVybiBvbkZvY3VzKGNtLCBlKTsgfSlcXG4gIG9uKGlucCwgXFxcImJsdXJcXFwiLCBmdW5jdGlvbiAoZSkgeyByZXR1cm4gb25CbHVyKGNtLCBlKTsgfSlcXG59XFxuXFxudmFyIGluaXRIb29rcyA9IFtdXFxuQ29kZU1pcnJvci5kZWZpbmVJbml0SG9vayA9IGZ1bmN0aW9uIChmKSB7IHJldHVybiBpbml0SG9va3MucHVzaChmKTsgfVxcblxcbi8vIEluZGVudCB0aGUgZ2l2ZW4gbGluZS4gVGhlIGhvdyBwYXJhbWV0ZXIgY2FuIGJlIFxcXCJzbWFydFxcXCIsXFxuLy8gXFxcImFkZFxcXCIvbnVsbCwgXFxcInN1YnRyYWN0XFxcIiwgb3IgXFxcInByZXZcXFwiLiBXaGVuIGFnZ3Jlc3NpdmUgaXMgZmFsc2VcXG4vLyAodHlwaWNhbGx5IHNldCB0byB0cnVlIGZvciBmb3JjZWQgc2luZ2xlLWxpbmUgaW5kZW50cyksIGVtcHR5XFxuLy8gbGluZXMgYXJlIG5vdCBpbmRlbnRlZCwgYW5kIHBsYWNlcyB3aGVyZSB0aGUgbW9kZSByZXR1cm5zIFBhc3NcXG4vLyBhcmUgbGVmdCBhbG9uZS5cXG5mdW5jdGlvbiBpbmRlbnRMaW5lKGNtLCBuLCBob3csIGFnZ3Jlc3NpdmUpIHtcXG4gIHZhciBkb2MgPSBjbS5kb2MsIHN0YXRlXFxuICBpZiAoaG93ID09IG51bGwpIHsgaG93ID0gXFxcImFkZFxcXCIgfVxcbiAgaWYgKGhvdyA9PSBcXFwic21hcnRcXFwiKSB7XFxuICAgIC8vIEZhbGwgYmFjayB0byBcXFwicHJldlxcXCIgd2hlbiB0aGUgbW9kZSBkb2Vzbid0IGhhdmUgYW4gaW5kZW50YXRpb25cXG4gICAgLy8gbWV0aG9kLlxcbiAgICBpZiAoIWRvYy5tb2RlLmluZGVudCkgeyBob3cgPSBcXFwicHJldlxcXCIgfVxcbiAgICBlbHNlIHsgc3RhdGUgPSBnZXRTdGF0ZUJlZm9yZShjbSwgbikgfVxcbiAgfVxcblxcbiAgdmFyIHRhYlNpemUgPSBjbS5vcHRpb25zLnRhYlNpemVcXG4gIHZhciBsaW5lID0gZ2V0TGluZShkb2MsIG4pLCBjdXJTcGFjZSA9IGNvdW50Q29sdW1uKGxpbmUudGV4dCwgbnVsbCwgdGFiU2l6ZSlcXG4gIGlmIChsaW5lLnN0YXRlQWZ0ZXIpIHsgbGluZS5zdGF0ZUFmdGVyID0gbnVsbCB9XFxuICB2YXIgY3VyU3BhY2VTdHJpbmcgPSBsaW5lLnRleHQubWF0Y2goL15cXFxccyovKVswXSwgaW5kZW50YXRpb25cXG4gIGlmICghYWdncmVzc2l2ZSAmJiAhL1xcXFxTLy50ZXN0KGxpbmUudGV4dCkpIHtcXG4gICAgaW5kZW50YXRpb24gPSAwXFxuICAgIGhvdyA9IFxcXCJub3RcXFwiXFxuICB9IGVsc2UgaWYgKGhvdyA9PSBcXFwic21hcnRcXFwiKSB7XFxuICAgIGluZGVudGF0aW9uID0gZG9jLm1vZGUuaW5kZW50KHN0YXRlLCBsaW5lLnRleHQuc2xpY2UoY3VyU3BhY2VTdHJpbmcubGVuZ3RoKSwgbGluZS50ZXh0KVxcbiAgICBpZiAoaW5kZW50YXRpb24gPT0gUGFzcyB8fCBpbmRlbnRhdGlvbiA+IDE1MCkge1xcbiAgICAgIGlmICghYWdncmVzc2l2ZSkgeyByZXR1cm4gfVxcbiAgICAgIGhvdyA9IFxcXCJwcmV2XFxcIlxcbiAgICB9XFxuICB9XFxuICBpZiAoaG93ID09IFxcXCJwcmV2XFxcIikge1xcbiAgICBpZiAobiA+IGRvYy5maXJzdCkgeyBpbmRlbnRhdGlvbiA9IGNvdW50Q29sdW1uKGdldExpbmUoZG9jLCBuLTEpLnRleHQsIG51bGwsIHRhYlNpemUpIH1cXG4gICAgZWxzZSB7IGluZGVudGF0aW9uID0gMCB9XFxuICB9IGVsc2UgaWYgKGhvdyA9PSBcXFwiYWRkXFxcIikge1xcbiAgICBpbmRlbnRhdGlvbiA9IGN1clNwYWNlICsgY20ub3B0aW9ucy5pbmRlbnRVbml0XFxuICB9IGVsc2UgaWYgKGhvdyA9PSBcXFwic3VidHJhY3RcXFwiKSB7XFxuICAgIGluZGVudGF0aW9uID0gY3VyU3BhY2UgLSBjbS5vcHRpb25zLmluZGVudFVuaXRcXG4gIH0gZWxzZSBpZiAodHlwZW9mIGhvdyA9PSBcXFwibnVtYmVyXFxcIikge1xcbiAgICBpbmRlbnRhdGlvbiA9IGN1clNwYWNlICsgaG93XFxuICB9XFxuICBpbmRlbnRhdGlvbiA9IE1hdGgubWF4KDAsIGluZGVudGF0aW9uKVxcblxcbiAgdmFyIGluZGVudFN0cmluZyA9IFxcXCJcXFwiLCBwb3MgPSAwXFxuICBpZiAoY20ub3B0aW9ucy5pbmRlbnRXaXRoVGFicylcXG4gICAgeyBmb3IgKHZhciBpID0gTWF0aC5mbG9vcihpbmRlbnRhdGlvbiAvIHRhYlNpemUpOyBpOyAtLWkpIHtwb3MgKz0gdGFiU2l6ZTsgaW5kZW50U3RyaW5nICs9IFxcXCJcXFxcdFxcXCJ9IH1cXG4gIGlmIChwb3MgPCBpbmRlbnRhdGlvbikgeyBpbmRlbnRTdHJpbmcgKz0gc3BhY2VTdHIoaW5kZW50YXRpb24gLSBwb3MpIH1cXG5cXG4gIGlmIChpbmRlbnRTdHJpbmcgIT0gY3VyU3BhY2VTdHJpbmcpIHtcXG4gICAgcmVwbGFjZVJhbmdlKGRvYywgaW5kZW50U3RyaW5nLCBQb3MobiwgMCksIFBvcyhuLCBjdXJTcGFjZVN0cmluZy5sZW5ndGgpLCBcXFwiK2lucHV0XFxcIilcXG4gICAgbGluZS5zdGF0ZUFmdGVyID0gbnVsbFxcbiAgICByZXR1cm4gdHJ1ZVxcbiAgfSBlbHNlIHtcXG4gICAgLy8gRW5zdXJlIHRoYXQsIGlmIHRoZSBjdXJzb3Igd2FzIGluIHRoZSB3aGl0ZXNwYWNlIGF0IHRoZSBzdGFydFxcbiAgICAvLyBvZiB0aGUgbGluZSwgaXQgaXMgbW92ZWQgdG8gdGhlIGVuZCBvZiB0aGF0IHNwYWNlLlxcbiAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBkb2Muc2VsLnJhbmdlcy5sZW5ndGg7IGkkMSsrKSB7XFxuICAgICAgdmFyIHJhbmdlID0gZG9jLnNlbC5yYW5nZXNbaSQxXVxcbiAgICAgIGlmIChyYW5nZS5oZWFkLmxpbmUgPT0gbiAmJiByYW5nZS5oZWFkLmNoIDwgY3VyU3BhY2VTdHJpbmcubGVuZ3RoKSB7XFxuICAgICAgICB2YXIgcG9zJDEgPSBQb3MobiwgY3VyU3BhY2VTdHJpbmcubGVuZ3RoKVxcbiAgICAgICAgcmVwbGFjZU9uZVNlbGVjdGlvbihkb2MsIGkkMSwgbmV3IFJhbmdlKHBvcyQxLCBwb3MkMSkpXFxuICAgICAgICBicmVha1xcbiAgICAgIH1cXG4gICAgfVxcbiAgfVxcbn1cXG5cXG4vLyBUaGlzIHdpbGwgYmUgc2V0IHRvIGEge2xpbmVXaXNlOiBib29sLCB0ZXh0OiBbc3RyaW5nXX0gb2JqZWN0LCBzb1xcbi8vIHRoYXQsIHdoZW4gcGFzdGluZywgd2Uga25vdyB3aGF0IGtpbmQgb2Ygc2VsZWN0aW9ucyB0aGUgY29waWVkXFxuLy8gdGV4dCB3YXMgbWFkZSBvdXQgb2YuXFxudmFyIGxhc3RDb3BpZWQgPSBudWxsXFxuXFxuZnVuY3Rpb24gc2V0TGFzdENvcGllZChuZXdMYXN0Q29waWVkKSB7XFxuICBsYXN0Q29waWVkID0gbmV3TGFzdENvcGllZFxcbn1cXG5cXG5mdW5jdGlvbiBhcHBseVRleHRJbnB1dChjbSwgaW5zZXJ0ZWQsIGRlbGV0ZWQsIHNlbCwgb3JpZ2luKSB7XFxuICB2YXIgZG9jID0gY20uZG9jXFxuICBjbS5kaXNwbGF5LnNoaWZ0ID0gZmFsc2VcXG4gIGlmICghc2VsKSB7IHNlbCA9IGRvYy5zZWwgfVxcblxcbiAgdmFyIHBhc3RlID0gY20uc3RhdGUucGFzdGVJbmNvbWluZyB8fCBvcmlnaW4gPT0gXFxcInBhc3RlXFxcIlxcbiAgdmFyIHRleHRMaW5lcyA9IHNwbGl0TGluZXNBdXRvKGluc2VydGVkKSwgbXVsdGlQYXN0ZSA9IG51bGxcXG4gIC8vIFdoZW4gcGFzaW5nIE4gbGluZXMgaW50byBOIHNlbGVjdGlvbnMsIGluc2VydCBvbmUgbGluZSBwZXIgc2VsZWN0aW9uXFxuICBpZiAocGFzdGUgJiYgc2VsLnJhbmdlcy5sZW5ndGggPiAxKSB7XFxuICAgIGlmIChsYXN0Q29waWVkICYmIGxhc3RDb3BpZWQudGV4dC5qb2luKFxcXCJcXFxcblxcXCIpID09IGluc2VydGVkKSB7XFxuICAgICAgaWYgKHNlbC5yYW5nZXMubGVuZ3RoICUgbGFzdENvcGllZC50ZXh0Lmxlbmd0aCA9PSAwKSB7XFxuICAgICAgICBtdWx0aVBhc3RlID0gW11cXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGFzdENvcGllZC50ZXh0Lmxlbmd0aDsgaSsrKVxcbiAgICAgICAgICB7IG11bHRpUGFzdGUucHVzaChkb2Muc3BsaXRMaW5lcyhsYXN0Q29waWVkLnRleHRbaV0pKSB9XFxuICAgICAgfVxcbiAgICB9IGVsc2UgaWYgKHRleHRMaW5lcy5sZW5ndGggPT0gc2VsLnJhbmdlcy5sZW5ndGgpIHtcXG4gICAgICBtdWx0aVBhc3RlID0gbWFwKHRleHRMaW5lcywgZnVuY3Rpb24gKGwpIHsgcmV0dXJuIFtsXTsgfSlcXG4gICAgfVxcbiAgfVxcblxcbiAgdmFyIHVwZGF0ZUlucHV0XFxuICAvLyBOb3JtYWwgYmVoYXZpb3IgaXMgdG8gaW5zZXJ0IHRoZSBuZXcgdGV4dCBpbnRvIGV2ZXJ5IHNlbGVjdGlvblxcbiAgZm9yICh2YXIgaSQxID0gc2VsLnJhbmdlcy5sZW5ndGggLSAxOyBpJDEgPj0gMDsgaSQxLS0pIHtcXG4gICAgdmFyIHJhbmdlID0gc2VsLnJhbmdlc1tpJDFdXFxuICAgIHZhciBmcm9tID0gcmFuZ2UuZnJvbSgpLCB0byA9IHJhbmdlLnRvKClcXG4gICAgaWYgKHJhbmdlLmVtcHR5KCkpIHtcXG4gICAgICBpZiAoZGVsZXRlZCAmJiBkZWxldGVkID4gMCkgLy8gSGFuZGxlIGRlbGV0aW9uXFxuICAgICAgICB7IGZyb20gPSBQb3MoZnJvbS5saW5lLCBmcm9tLmNoIC0gZGVsZXRlZCkgfVxcbiAgICAgIGVsc2UgaWYgKGNtLnN0YXRlLm92ZXJ3cml0ZSAmJiAhcGFzdGUpIC8vIEhhbmRsZSBvdmVyd3JpdGVcXG4gICAgICAgIHsgdG8gPSBQb3ModG8ubGluZSwgTWF0aC5taW4oZ2V0TGluZShkb2MsIHRvLmxpbmUpLnRleHQubGVuZ3RoLCB0by5jaCArIGxzdCh0ZXh0TGluZXMpLmxlbmd0aCkpIH1cXG4gICAgICBlbHNlIGlmIChsYXN0Q29waWVkICYmIGxhc3RDb3BpZWQubGluZVdpc2UgJiYgbGFzdENvcGllZC50ZXh0LmpvaW4oXFxcIlxcXFxuXFxcIikgPT0gaW5zZXJ0ZWQpXFxuICAgICAgICB7IGZyb20gPSB0byA9IFBvcyhmcm9tLmxpbmUsIDApIH1cXG4gICAgfVxcbiAgICB1cGRhdGVJbnB1dCA9IGNtLmN1ck9wLnVwZGF0ZUlucHV0XFxuICAgIHZhciBjaGFuZ2VFdmVudCA9IHtmcm9tOiBmcm9tLCB0bzogdG8sIHRleHQ6IG11bHRpUGFzdGUgPyBtdWx0aVBhc3RlW2kkMSAlIG11bHRpUGFzdGUubGVuZ3RoXSA6IHRleHRMaW5lcyxcXG4gICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbjogb3JpZ2luIHx8IChwYXN0ZSA/IFxcXCJwYXN0ZVxcXCIgOiBjbS5zdGF0ZS5jdXRJbmNvbWluZyA/IFxcXCJjdXRcXFwiIDogXFxcIitpbnB1dFxcXCIpfVxcbiAgICBtYWtlQ2hhbmdlKGNtLmRvYywgY2hhbmdlRXZlbnQpXFxuICAgIHNpZ25hbExhdGVyKGNtLCBcXFwiaW5wdXRSZWFkXFxcIiwgY20sIGNoYW5nZUV2ZW50KVxcbiAgfVxcbiAgaWYgKGluc2VydGVkICYmICFwYXN0ZSlcXG4gICAgeyB0cmlnZ2VyRWxlY3RyaWMoY20sIGluc2VydGVkKSB9XFxuXFxuICBlbnN1cmVDdXJzb3JWaXNpYmxlKGNtKVxcbiAgY20uY3VyT3AudXBkYXRlSW5wdXQgPSB1cGRhdGVJbnB1dFxcbiAgY20uY3VyT3AudHlwaW5nID0gdHJ1ZVxcbiAgY20uc3RhdGUucGFzdGVJbmNvbWluZyA9IGNtLnN0YXRlLmN1dEluY29taW5nID0gZmFsc2VcXG59XFxuXFxuZnVuY3Rpb24gaGFuZGxlUGFzdGUoZSwgY20pIHtcXG4gIHZhciBwYXN0ZWQgPSBlLmNsaXBib2FyZERhdGEgJiYgZS5jbGlwYm9hcmREYXRhLmdldERhdGEoXFxcIlRleHRcXFwiKVxcbiAgaWYgKHBhc3RlZCkge1xcbiAgICBlLnByZXZlbnREZWZhdWx0KClcXG4gICAgaWYgKCFjbS5pc1JlYWRPbmx5KCkgJiYgIWNtLm9wdGlvbnMuZGlzYWJsZUlucHV0KVxcbiAgICAgIHsgcnVuSW5PcChjbSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gYXBwbHlUZXh0SW5wdXQoY20sIHBhc3RlZCwgMCwgbnVsbCwgXFxcInBhc3RlXFxcIik7IH0pIH1cXG4gICAgcmV0dXJuIHRydWVcXG4gIH1cXG59XFxuXFxuZnVuY3Rpb24gdHJpZ2dlckVsZWN0cmljKGNtLCBpbnNlcnRlZCkge1xcbiAgLy8gV2hlbiBhbiAnZWxlY3RyaWMnIGNoYXJhY3RlciBpcyBpbnNlcnRlZCwgaW1tZWRpYXRlbHkgdHJpZ2dlciBhIHJlaW5kZW50XFxuICBpZiAoIWNtLm9wdGlvbnMuZWxlY3RyaWNDaGFycyB8fCAhY20ub3B0aW9ucy5zbWFydEluZGVudCkgeyByZXR1cm4gfVxcbiAgdmFyIHNlbCA9IGNtLmRvYy5zZWxcXG5cXG4gIGZvciAodmFyIGkgPSBzZWwucmFuZ2VzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XFxuICAgIHZhciByYW5nZSA9IHNlbC5yYW5nZXNbaV1cXG4gICAgaWYgKHJhbmdlLmhlYWQuY2ggPiAxMDAgfHwgKGkgJiYgc2VsLnJhbmdlc1tpIC0gMV0uaGVhZC5saW5lID09IHJhbmdlLmhlYWQubGluZSkpIHsgY29udGludWUgfVxcbiAgICB2YXIgbW9kZSA9IGNtLmdldE1vZGVBdChyYW5nZS5oZWFkKVxcbiAgICB2YXIgaW5kZW50ZWQgPSBmYWxzZVxcbiAgICBpZiAobW9kZS5lbGVjdHJpY0NoYXJzKSB7XFxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBtb2RlLmVsZWN0cmljQ2hhcnMubGVuZ3RoOyBqKyspXFxuICAgICAgICB7IGlmIChpbnNlcnRlZC5pbmRleE9mKG1vZGUuZWxlY3RyaWNDaGFycy5jaGFyQXQoaikpID4gLTEpIHtcXG4gICAgICAgICAgaW5kZW50ZWQgPSBpbmRlbnRMaW5lKGNtLCByYW5nZS5oZWFkLmxpbmUsIFxcXCJzbWFydFxcXCIpXFxuICAgICAgICAgIGJyZWFrXFxuICAgICAgICB9IH1cXG4gICAgfSBlbHNlIGlmIChtb2RlLmVsZWN0cmljSW5wdXQpIHtcXG4gICAgICBpZiAobW9kZS5lbGVjdHJpY0lucHV0LnRlc3QoZ2V0TGluZShjbS5kb2MsIHJhbmdlLmhlYWQubGluZSkudGV4dC5zbGljZSgwLCByYW5nZS5oZWFkLmNoKSkpXFxuICAgICAgICB7IGluZGVudGVkID0gaW5kZW50TGluZShjbSwgcmFuZ2UuaGVhZC5saW5lLCBcXFwic21hcnRcXFwiKSB9XFxuICAgIH1cXG4gICAgaWYgKGluZGVudGVkKSB7IHNpZ25hbExhdGVyKGNtLCBcXFwiZWxlY3RyaWNJbnB1dFxcXCIsIGNtLCByYW5nZS5oZWFkLmxpbmUpIH1cXG4gIH1cXG59XFxuXFxuZnVuY3Rpb24gY29weWFibGVSYW5nZXMoY20pIHtcXG4gIHZhciB0ZXh0ID0gW10sIHJhbmdlcyA9IFtdXFxuICBmb3IgKHZhciBpID0gMDsgaSA8IGNtLmRvYy5zZWwucmFuZ2VzLmxlbmd0aDsgaSsrKSB7XFxuICAgIHZhciBsaW5lID0gY20uZG9jLnNlbC5yYW5nZXNbaV0uaGVhZC5saW5lXFxuICAgIHZhciBsaW5lUmFuZ2UgPSB7YW5jaG9yOiBQb3MobGluZSwgMCksIGhlYWQ6IFBvcyhsaW5lICsgMSwgMCl9XFxuICAgIHJhbmdlcy5wdXNoKGxpbmVSYW5nZSlcXG4gICAgdGV4dC5wdXNoKGNtLmdldFJhbmdlKGxpbmVSYW5nZS5hbmNob3IsIGxpbmVSYW5nZS5oZWFkKSlcXG4gIH1cXG4gIHJldHVybiB7dGV4dDogdGV4dCwgcmFuZ2VzOiByYW5nZXN9XFxufVxcblxcbmZ1bmN0aW9uIGRpc2FibGVCcm93c2VyTWFnaWMoZmllbGQsIHNwZWxsY2hlY2spIHtcXG4gIGZpZWxkLnNldEF0dHJpYnV0ZShcXFwiYXV0b2NvcnJlY3RcXFwiLCBcXFwib2ZmXFxcIilcXG4gIGZpZWxkLnNldEF0dHJpYnV0ZShcXFwiYXV0b2NhcGl0YWxpemVcXFwiLCBcXFwib2ZmXFxcIilcXG4gIGZpZWxkLnNldEF0dHJpYnV0ZShcXFwic3BlbGxjaGVja1xcXCIsICEhc3BlbGxjaGVjaylcXG59XFxuXFxuZnVuY3Rpb24gaGlkZGVuVGV4dGFyZWEoKSB7XFxuICB2YXIgdGUgPSBlbHQoXFxcInRleHRhcmVhXFxcIiwgbnVsbCwgbnVsbCwgXFxcInBvc2l0aW9uOiBhYnNvbHV0ZTsgYm90dG9tOiAtMWVtOyBwYWRkaW5nOiAwOyB3aWR0aDogMXB4OyBoZWlnaHQ6IDFlbTsgb3V0bGluZTogbm9uZVxcXCIpXFxuICB2YXIgZGl2ID0gZWx0KFxcXCJkaXZcXFwiLCBbdGVdLCBudWxsLCBcXFwib3ZlcmZsb3c6IGhpZGRlbjsgcG9zaXRpb246IHJlbGF0aXZlOyB3aWR0aDogM3B4OyBoZWlnaHQ6IDBweDtcXFwiKVxcbiAgLy8gVGhlIHRleHRhcmVhIGlzIGtlcHQgcG9zaXRpb25lZCBuZWFyIHRoZSBjdXJzb3IgdG8gcHJldmVudCB0aGVcXG4gIC8vIGZhY3QgdGhhdCBpdCdsbCBiZSBzY3JvbGxlZCBpbnRvIHZpZXcgb24gaW5wdXQgZnJvbSBzY3JvbGxpbmdcXG4gIC8vIG91ciBmYWtlIGN1cnNvciBvdXQgb2Ygdmlldy4gT24gd2Via2l0LCB3aGVuIHdyYXA9b2ZmLCBwYXN0ZSBpc1xcbiAgLy8gdmVyeSBzbG93LiBTbyBtYWtlIHRoZSBhcmVhIHdpZGUgaW5zdGVhZC5cXG4gIGlmICh3ZWJraXQpIHsgdGUuc3R5bGUud2lkdGggPSBcXFwiMTAwMHB4XFxcIiB9XFxuICBlbHNlIHsgdGUuc2V0QXR0cmlidXRlKFxcXCJ3cmFwXFxcIiwgXFxcIm9mZlxcXCIpIH1cXG4gIC8vIElmIGJvcmRlcjogMDsgLS0gaU9TIGZhaWxzIHRvIG9wZW4ga2V5Ym9hcmQgKGlzc3VlICMxMjg3KVxcbiAgaWYgKGlvcykgeyB0ZS5zdHlsZS5ib3JkZXIgPSBcXFwiMXB4IHNvbGlkIGJsYWNrXFxcIiB9XFxuICBkaXNhYmxlQnJvd3Nlck1hZ2ljKHRlKVxcbiAgcmV0dXJuIGRpdlxcbn1cXG5cXG4vLyBUaGUgcHVibGljbHkgdmlzaWJsZSBBUEkuIE5vdGUgdGhhdCBtZXRob2RPcChmKSBtZWFuc1xcbi8vICd3cmFwIGYgaW4gYW4gb3BlcmF0aW9uLCBwZXJmb3JtZWQgb24gaXRzIGB0aGlzYCBwYXJhbWV0ZXInLlxcblxcbi8vIFRoaXMgaXMgbm90IHRoZSBjb21wbGV0ZSBzZXQgb2YgZWRpdG9yIG1ldGhvZHMuIE1vc3Qgb2YgdGhlXFxuLy8gbWV0aG9kcyBkZWZpbmVkIG9uIHRoZSBEb2MgdHlwZSBhcmUgYWxzbyBpbmplY3RlZCBpbnRvXFxuLy8gQ29kZU1pcnJvci5wcm90b3R5cGUsIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSBhbmRcXG4vLyBjb252ZW5pZW5jZS5cXG5cXG5mdW5jdGlvbiBhZGRFZGl0b3JNZXRob2RzKENvZGVNaXJyb3IpIHtcXG4gIHZhciBvcHRpb25IYW5kbGVycyA9IENvZGVNaXJyb3Iub3B0aW9uSGFuZGxlcnNcXG5cXG4gIHZhciBoZWxwZXJzID0gQ29kZU1pcnJvci5oZWxwZXJzID0ge31cXG5cXG4gIENvZGVNaXJyb3IucHJvdG90eXBlID0ge1xcbiAgICBjb25zdHJ1Y3RvcjogQ29kZU1pcnJvcixcXG4gICAgZm9jdXM6IGZ1bmN0aW9uKCl7d2luZG93LmZvY3VzKCk7IHRoaXMuZGlzcGxheS5pbnB1dC5mb2N1cygpfSxcXG5cXG4gICAgc2V0T3B0aW9uOiBmdW5jdGlvbihvcHRpb24sIHZhbHVlKSB7XFxuICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsIG9sZCA9IG9wdGlvbnNbb3B0aW9uXVxcbiAgICAgIGlmIChvcHRpb25zW29wdGlvbl0gPT0gdmFsdWUgJiYgb3B0aW9uICE9IFxcXCJtb2RlXFxcIikgeyByZXR1cm4gfVxcbiAgICAgIG9wdGlvbnNbb3B0aW9uXSA9IHZhbHVlXFxuICAgICAgaWYgKG9wdGlvbkhhbmRsZXJzLmhhc093blByb3BlcnR5KG9wdGlvbikpXFxuICAgICAgICB7IG9wZXJhdGlvbih0aGlzLCBvcHRpb25IYW5kbGVyc1tvcHRpb25dKSh0aGlzLCB2YWx1ZSwgb2xkKSB9XFxuICAgIH0sXFxuXFxuICAgIGdldE9wdGlvbjogZnVuY3Rpb24ob3B0aW9uKSB7cmV0dXJuIHRoaXMub3B0aW9uc1tvcHRpb25dfSxcXG4gICAgZ2V0RG9jOiBmdW5jdGlvbigpIHtyZXR1cm4gdGhpcy5kb2N9LFxcblxcbiAgICBhZGRLZXlNYXA6IGZ1bmN0aW9uKG1hcCwgYm90dG9tKSB7XFxuICAgICAgdGhpcy5zdGF0ZS5rZXlNYXBzW2JvdHRvbSA/IFxcXCJwdXNoXFxcIiA6IFxcXCJ1bnNoaWZ0XFxcIl0oZ2V0S2V5TWFwKG1hcCkpXFxuICAgIH0sXFxuICAgIHJlbW92ZUtleU1hcDogZnVuY3Rpb24obWFwKSB7XFxuICAgICAgdmFyIG1hcHMgPSB0aGlzLnN0YXRlLmtleU1hcHNcXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1hcHMubGVuZ3RoOyArK2kpXFxuICAgICAgICB7IGlmIChtYXBzW2ldID09IG1hcCB8fCBtYXBzW2ldLm5hbWUgPT0gbWFwKSB7XFxuICAgICAgICAgIG1hcHMuc3BsaWNlKGksIDEpXFxuICAgICAgICAgIHJldHVybiB0cnVlXFxuICAgICAgICB9IH1cXG4gICAgfSxcXG5cXG4gICAgYWRkT3ZlcmxheTogbWV0aG9kT3AoZnVuY3Rpb24oc3BlYywgb3B0aW9ucykge1xcbiAgICAgIHZhciBtb2RlID0gc3BlYy50b2tlbiA/IHNwZWMgOiBDb2RlTWlycm9yLmdldE1vZGUodGhpcy5vcHRpb25zLCBzcGVjKVxcbiAgICAgIGlmIChtb2RlLnN0YXJ0U3RhdGUpIHsgdGhyb3cgbmV3IEVycm9yKFxcXCJPdmVybGF5cyBtYXkgbm90IGJlIHN0YXRlZnVsLlxcXCIpIH1cXG4gICAgICBpbnNlcnRTb3J0ZWQodGhpcy5zdGF0ZS5vdmVybGF5cyxcXG4gICAgICAgICAgICAgICAgICAge21vZGU6IG1vZGUsIG1vZGVTcGVjOiBzcGVjLCBvcGFxdWU6IG9wdGlvbnMgJiYgb3B0aW9ucy5vcGFxdWUsXFxuICAgICAgICAgICAgICAgICAgICBwcmlvcml0eTogKG9wdGlvbnMgJiYgb3B0aW9ucy5wcmlvcml0eSkgfHwgMH0sXFxuICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChvdmVybGF5KSB7IHJldHVybiBvdmVybGF5LnByaW9yaXR5OyB9KVxcbiAgICAgIHRoaXMuc3RhdGUubW9kZUdlbisrXFxuICAgICAgcmVnQ2hhbmdlKHRoaXMpXFxuICAgIH0pLFxcbiAgICByZW1vdmVPdmVybGF5OiBtZXRob2RPcChmdW5jdGlvbihzcGVjKSB7XFxuICAgICAgdmFyIHRoaXMkMSA9IHRoaXM7XFxuXFxuICAgICAgdmFyIG92ZXJsYXlzID0gdGhpcy5zdGF0ZS5vdmVybGF5c1xcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3ZlcmxheXMubGVuZ3RoOyArK2kpIHtcXG4gICAgICAgIHZhciBjdXIgPSBvdmVybGF5c1tpXS5tb2RlU3BlY1xcbiAgICAgICAgaWYgKGN1ciA9PSBzcGVjIHx8IHR5cGVvZiBzcGVjID09IFxcXCJzdHJpbmdcXFwiICYmIGN1ci5uYW1lID09IHNwZWMpIHtcXG4gICAgICAgICAgb3ZlcmxheXMuc3BsaWNlKGksIDEpXFxuICAgICAgICAgIHRoaXMkMS5zdGF0ZS5tb2RlR2VuKytcXG4gICAgICAgICAgcmVnQ2hhbmdlKHRoaXMkMSlcXG4gICAgICAgICAgcmV0dXJuXFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICB9KSxcXG5cXG4gICAgaW5kZW50TGluZTogbWV0aG9kT3AoZnVuY3Rpb24obiwgZGlyLCBhZ2dyZXNzaXZlKSB7XFxuICAgICAgaWYgKHR5cGVvZiBkaXIgIT0gXFxcInN0cmluZ1xcXCIgJiYgdHlwZW9mIGRpciAhPSBcXFwibnVtYmVyXFxcIikge1xcbiAgICAgICAgaWYgKGRpciA9PSBudWxsKSB7IGRpciA9IHRoaXMub3B0aW9ucy5zbWFydEluZGVudCA/IFxcXCJzbWFydFxcXCIgOiBcXFwicHJldlxcXCIgfVxcbiAgICAgICAgZWxzZSB7IGRpciA9IGRpciA/IFxcXCJhZGRcXFwiIDogXFxcInN1YnRyYWN0XFxcIiB9XFxuICAgICAgfVxcbiAgICAgIGlmIChpc0xpbmUodGhpcy5kb2MsIG4pKSB7IGluZGVudExpbmUodGhpcywgbiwgZGlyLCBhZ2dyZXNzaXZlKSB9XFxuICAgIH0pLFxcbiAgICBpbmRlbnRTZWxlY3Rpb246IG1ldGhvZE9wKGZ1bmN0aW9uKGhvdykge1xcbiAgICAgIHZhciB0aGlzJDEgPSB0aGlzO1xcblxcbiAgICAgIHZhciByYW5nZXMgPSB0aGlzLmRvYy5zZWwucmFuZ2VzLCBlbmQgPSAtMVxcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmFuZ2VzLmxlbmd0aDsgaSsrKSB7XFxuICAgICAgICB2YXIgcmFuZ2UgPSByYW5nZXNbaV1cXG4gICAgICAgIGlmICghcmFuZ2UuZW1wdHkoKSkge1xcbiAgICAgICAgICB2YXIgZnJvbSA9IHJhbmdlLmZyb20oKSwgdG8gPSByYW5nZS50bygpXFxuICAgICAgICAgIHZhciBzdGFydCA9IE1hdGgubWF4KGVuZCwgZnJvbS5saW5lKVxcbiAgICAgICAgICBlbmQgPSBNYXRoLm1pbih0aGlzJDEubGFzdExpbmUoKSwgdG8ubGluZSAtICh0by5jaCA/IDAgOiAxKSkgKyAxXFxuICAgICAgICAgIGZvciAodmFyIGogPSBzdGFydDsgaiA8IGVuZDsgKytqKVxcbiAgICAgICAgICAgIHsgaW5kZW50TGluZSh0aGlzJDEsIGosIGhvdykgfVxcbiAgICAgICAgICB2YXIgbmV3UmFuZ2VzID0gdGhpcyQxLmRvYy5zZWwucmFuZ2VzXFxuICAgICAgICAgIGlmIChmcm9tLmNoID09IDAgJiYgcmFuZ2VzLmxlbmd0aCA9PSBuZXdSYW5nZXMubGVuZ3RoICYmIG5ld1Jhbmdlc1tpXS5mcm9tKCkuY2ggPiAwKVxcbiAgICAgICAgICAgIHsgcmVwbGFjZU9uZVNlbGVjdGlvbih0aGlzJDEuZG9jLCBpLCBuZXcgUmFuZ2UoZnJvbSwgbmV3UmFuZ2VzW2ldLnRvKCkpLCBzZWxfZG9udFNjcm9sbCkgfVxcbiAgICAgICAgfSBlbHNlIGlmIChyYW5nZS5oZWFkLmxpbmUgPiBlbmQpIHtcXG4gICAgICAgICAgaW5kZW50TGluZSh0aGlzJDEsIHJhbmdlLmhlYWQubGluZSwgaG93LCB0cnVlKVxcbiAgICAgICAgICBlbmQgPSByYW5nZS5oZWFkLmxpbmVcXG4gICAgICAgICAgaWYgKGkgPT0gdGhpcyQxLmRvYy5zZWwucHJpbUluZGV4KSB7IGVuc3VyZUN1cnNvclZpc2libGUodGhpcyQxKSB9XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICB9KSxcXG5cXG4gICAgLy8gRmV0Y2ggdGhlIHBhcnNlciB0b2tlbiBmb3IgYSBnaXZlbiBjaGFyYWN0ZXIuIFVzZWZ1bCBmb3IgaGFja3NcXG4gICAgLy8gdGhhdCB3YW50IHRvIGluc3BlY3QgdGhlIG1vZGUgc3RhdGUgKHNheSwgZm9yIGNvbXBsZXRpb24pLlxcbiAgICBnZXRUb2tlbkF0OiBmdW5jdGlvbihwb3MsIHByZWNpc2UpIHtcXG4gICAgICByZXR1cm4gdGFrZVRva2VuKHRoaXMsIHBvcywgcHJlY2lzZSlcXG4gICAgfSxcXG5cXG4gICAgZ2V0TGluZVRva2VuczogZnVuY3Rpb24obGluZSwgcHJlY2lzZSkge1xcbiAgICAgIHJldHVybiB0YWtlVG9rZW4odGhpcywgUG9zKGxpbmUpLCBwcmVjaXNlLCB0cnVlKVxcbiAgICB9LFxcblxcbiAgICBnZXRUb2tlblR5cGVBdDogZnVuY3Rpb24ocG9zKSB7XFxuICAgICAgcG9zID0gY2xpcFBvcyh0aGlzLmRvYywgcG9zKVxcbiAgICAgIHZhciBzdHlsZXMgPSBnZXRMaW5lU3R5bGVzKHRoaXMsIGdldExpbmUodGhpcy5kb2MsIHBvcy5saW5lKSlcXG4gICAgICB2YXIgYmVmb3JlID0gMCwgYWZ0ZXIgPSAoc3R5bGVzLmxlbmd0aCAtIDEpIC8gMiwgY2ggPSBwb3MuY2hcXG4gICAgICB2YXIgdHlwZVxcbiAgICAgIGlmIChjaCA9PSAwKSB7IHR5cGUgPSBzdHlsZXNbMl0gfVxcbiAgICAgIGVsc2UgeyBmb3IgKDs7KSB7XFxuICAgICAgICB2YXIgbWlkID0gKGJlZm9yZSArIGFmdGVyKSA+PiAxXFxuICAgICAgICBpZiAoKG1pZCA/IHN0eWxlc1ttaWQgKiAyIC0gMV0gOiAwKSA+PSBjaCkgeyBhZnRlciA9IG1pZCB9XFxuICAgICAgICBlbHNlIGlmIChzdHlsZXNbbWlkICogMiArIDFdIDwgY2gpIHsgYmVmb3JlID0gbWlkICsgMSB9XFxuICAgICAgICBlbHNlIHsgdHlwZSA9IHN0eWxlc1ttaWQgKiAyICsgMl07IGJyZWFrIH1cXG4gICAgICB9IH1cXG4gICAgICB2YXIgY3V0ID0gdHlwZSA/IHR5cGUuaW5kZXhPZihcXFwib3ZlcmxheSBcXFwiKSA6IC0xXFxuICAgICAgcmV0dXJuIGN1dCA8IDAgPyB0eXBlIDogY3V0ID09IDAgPyBudWxsIDogdHlwZS5zbGljZSgwLCBjdXQgLSAxKVxcbiAgICB9LFxcblxcbiAgICBnZXRNb2RlQXQ6IGZ1bmN0aW9uKHBvcykge1xcbiAgICAgIHZhciBtb2RlID0gdGhpcy5kb2MubW9kZVxcbiAgICAgIGlmICghbW9kZS5pbm5lck1vZGUpIHsgcmV0dXJuIG1vZGUgfVxcbiAgICAgIHJldHVybiBDb2RlTWlycm9yLmlubmVyTW9kZShtb2RlLCB0aGlzLmdldFRva2VuQXQocG9zKS5zdGF0ZSkubW9kZVxcbiAgICB9LFxcblxcbiAgICBnZXRIZWxwZXI6IGZ1bmN0aW9uKHBvcywgdHlwZSkge1xcbiAgICAgIHJldHVybiB0aGlzLmdldEhlbHBlcnMocG9zLCB0eXBlKVswXVxcbiAgICB9LFxcblxcbiAgICBnZXRIZWxwZXJzOiBmdW5jdGlvbihwb3MsIHR5cGUpIHtcXG4gICAgICB2YXIgdGhpcyQxID0gdGhpcztcXG5cXG4gICAgICB2YXIgZm91bmQgPSBbXVxcbiAgICAgIGlmICghaGVscGVycy5oYXNPd25Qcm9wZXJ0eSh0eXBlKSkgeyByZXR1cm4gZm91bmQgfVxcbiAgICAgIHZhciBoZWxwID0gaGVscGVyc1t0eXBlXSwgbW9kZSA9IHRoaXMuZ2V0TW9kZUF0KHBvcylcXG4gICAgICBpZiAodHlwZW9mIG1vZGVbdHlwZV0gPT0gXFxcInN0cmluZ1xcXCIpIHtcXG4gICAgICAgIGlmIChoZWxwW21vZGVbdHlwZV1dKSB7IGZvdW5kLnB1c2goaGVscFttb2RlW3R5cGVdXSkgfVxcbiAgICAgIH0gZWxzZSBpZiAobW9kZVt0eXBlXSkge1xcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtb2RlW3R5cGVdLmxlbmd0aDsgaSsrKSB7XFxuICAgICAgICAgIHZhciB2YWwgPSBoZWxwW21vZGVbdHlwZV1baV1dXFxuICAgICAgICAgIGlmICh2YWwpIHsgZm91bmQucHVzaCh2YWwpIH1cXG4gICAgICAgIH1cXG4gICAgICB9IGVsc2UgaWYgKG1vZGUuaGVscGVyVHlwZSAmJiBoZWxwW21vZGUuaGVscGVyVHlwZV0pIHtcXG4gICAgICAgIGZvdW5kLnB1c2goaGVscFttb2RlLmhlbHBlclR5cGVdKVxcbiAgICAgIH0gZWxzZSBpZiAoaGVscFttb2RlLm5hbWVdKSB7XFxuICAgICAgICBmb3VuZC5wdXNoKGhlbHBbbW9kZS5uYW1lXSlcXG4gICAgICB9XFxuICAgICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgaGVscC5fZ2xvYmFsLmxlbmd0aDsgaSQxKyspIHtcXG4gICAgICAgIHZhciBjdXIgPSBoZWxwLl9nbG9iYWxbaSQxXVxcbiAgICAgICAgaWYgKGN1ci5wcmVkKG1vZGUsIHRoaXMkMSkgJiYgaW5kZXhPZihmb3VuZCwgY3VyLnZhbCkgPT0gLTEpXFxuICAgICAgICAgIHsgZm91bmQucHVzaChjdXIudmFsKSB9XFxuICAgICAgfVxcbiAgICAgIHJldHVybiBmb3VuZFxcbiAgICB9LFxcblxcbiAgICBnZXRTdGF0ZUFmdGVyOiBmdW5jdGlvbihsaW5lLCBwcmVjaXNlKSB7XFxuICAgICAgdmFyIGRvYyA9IHRoaXMuZG9jXFxuICAgICAgbGluZSA9IGNsaXBMaW5lKGRvYywgbGluZSA9PSBudWxsID8gZG9jLmZpcnN0ICsgZG9jLnNpemUgLSAxOiBsaW5lKVxcbiAgICAgIHJldHVybiBnZXRTdGF0ZUJlZm9yZSh0aGlzLCBsaW5lICsgMSwgcHJlY2lzZSlcXG4gICAgfSxcXG5cXG4gICAgY3Vyc29yQ29vcmRzOiBmdW5jdGlvbihzdGFydCwgbW9kZSkge1xcbiAgICAgIHZhciBwb3MsIHJhbmdlID0gdGhpcy5kb2Muc2VsLnByaW1hcnkoKVxcbiAgICAgIGlmIChzdGFydCA9PSBudWxsKSB7IHBvcyA9IHJhbmdlLmhlYWQgfVxcbiAgICAgIGVsc2UgaWYgKHR5cGVvZiBzdGFydCA9PSBcXFwib2JqZWN0XFxcIikgeyBwb3MgPSBjbGlwUG9zKHRoaXMuZG9jLCBzdGFydCkgfVxcbiAgICAgIGVsc2UgeyBwb3MgPSBzdGFydCA/IHJhbmdlLmZyb20oKSA6IHJhbmdlLnRvKCkgfVxcbiAgICAgIHJldHVybiBjdXJzb3JDb29yZHModGhpcywgcG9zLCBtb2RlIHx8IFxcXCJwYWdlXFxcIilcXG4gICAgfSxcXG5cXG4gICAgY2hhckNvb3JkczogZnVuY3Rpb24ocG9zLCBtb2RlKSB7XFxuICAgICAgcmV0dXJuIGNoYXJDb29yZHModGhpcywgY2xpcFBvcyh0aGlzLmRvYywgcG9zKSwgbW9kZSB8fCBcXFwicGFnZVxcXCIpXFxuICAgIH0sXFxuXFxuICAgIGNvb3Jkc0NoYXI6IGZ1bmN0aW9uKGNvb3JkcywgbW9kZSkge1xcbiAgICAgIGNvb3JkcyA9IGZyb21Db29yZFN5c3RlbSh0aGlzLCBjb29yZHMsIG1vZGUgfHwgXFxcInBhZ2VcXFwiKVxcbiAgICAgIHJldHVybiBjb29yZHNDaGFyKHRoaXMsIGNvb3Jkcy5sZWZ0LCBjb29yZHMudG9wKVxcbiAgICB9LFxcblxcbiAgICBsaW5lQXRIZWlnaHQ6IGZ1bmN0aW9uKGhlaWdodCwgbW9kZSkge1xcbiAgICAgIGhlaWdodCA9IGZyb21Db29yZFN5c3RlbSh0aGlzLCB7dG9wOiBoZWlnaHQsIGxlZnQ6IDB9LCBtb2RlIHx8IFxcXCJwYWdlXFxcIikudG9wXFxuICAgICAgcmV0dXJuIGxpbmVBdEhlaWdodCh0aGlzLmRvYywgaGVpZ2h0ICsgdGhpcy5kaXNwbGF5LnZpZXdPZmZzZXQpXFxuICAgIH0sXFxuICAgIGhlaWdodEF0TGluZTogZnVuY3Rpb24obGluZSwgbW9kZSkge1xcbiAgICAgIHZhciBlbmQgPSBmYWxzZSwgbGluZU9ialxcbiAgICAgIGlmICh0eXBlb2YgbGluZSA9PSBcXFwibnVtYmVyXFxcIikge1xcbiAgICAgICAgdmFyIGxhc3QgPSB0aGlzLmRvYy5maXJzdCArIHRoaXMuZG9jLnNpemUgLSAxXFxuICAgICAgICBpZiAobGluZSA8IHRoaXMuZG9jLmZpcnN0KSB7IGxpbmUgPSB0aGlzLmRvYy5maXJzdCB9XFxuICAgICAgICBlbHNlIGlmIChsaW5lID4gbGFzdCkgeyBsaW5lID0gbGFzdDsgZW5kID0gdHJ1ZSB9XFxuICAgICAgICBsaW5lT2JqID0gZ2V0TGluZSh0aGlzLmRvYywgbGluZSlcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgbGluZU9iaiA9IGxpbmVcXG4gICAgICB9XFxuICAgICAgcmV0dXJuIGludG9Db29yZFN5c3RlbSh0aGlzLCBsaW5lT2JqLCB7dG9wOiAwLCBsZWZ0OiAwfSwgbW9kZSB8fCBcXFwicGFnZVxcXCIpLnRvcCArXFxuICAgICAgICAoZW5kID8gdGhpcy5kb2MuaGVpZ2h0IC0gaGVpZ2h0QXRMaW5lKGxpbmVPYmopIDogMClcXG4gICAgfSxcXG5cXG4gICAgZGVmYXVsdFRleHRIZWlnaHQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGV4dEhlaWdodCh0aGlzLmRpc3BsYXkpIH0sXFxuICAgIGRlZmF1bHRDaGFyV2lkdGg6IGZ1bmN0aW9uKCkgeyByZXR1cm4gY2hhcldpZHRoKHRoaXMuZGlzcGxheSkgfSxcXG5cXG4gICAgc2V0R3V0dGVyTWFya2VyOiBtZXRob2RPcChmdW5jdGlvbihsaW5lLCBndXR0ZXJJRCwgdmFsdWUpIHtcXG4gICAgICByZXR1cm4gY2hhbmdlTGluZSh0aGlzLmRvYywgbGluZSwgXFxcImd1dHRlclxcXCIsIGZ1bmN0aW9uIChsaW5lKSB7XFxuICAgICAgICB2YXIgbWFya2VycyA9IGxpbmUuZ3V0dGVyTWFya2VycyB8fCAobGluZS5ndXR0ZXJNYXJrZXJzID0ge30pXFxuICAgICAgICBtYXJrZXJzW2d1dHRlcklEXSA9IHZhbHVlXFxuICAgICAgICBpZiAoIXZhbHVlICYmIGlzRW1wdHkobWFya2VycykpIHsgbGluZS5ndXR0ZXJNYXJrZXJzID0gbnVsbCB9XFxuICAgICAgICByZXR1cm4gdHJ1ZVxcbiAgICAgIH0pXFxuICAgIH0pLFxcblxcbiAgICBjbGVhckd1dHRlcjogbWV0aG9kT3AoZnVuY3Rpb24oZ3V0dGVySUQpIHtcXG4gICAgICB2YXIgdGhpcyQxID0gdGhpcztcXG5cXG4gICAgICB2YXIgZG9jID0gdGhpcy5kb2MsIGkgPSBkb2MuZmlyc3RcXG4gICAgICBkb2MuaXRlcihmdW5jdGlvbiAobGluZSkge1xcbiAgICAgICAgaWYgKGxpbmUuZ3V0dGVyTWFya2VycyAmJiBsaW5lLmd1dHRlck1hcmtlcnNbZ3V0dGVySURdKSB7XFxuICAgICAgICAgIGxpbmUuZ3V0dGVyTWFya2Vyc1tndXR0ZXJJRF0gPSBudWxsXFxuICAgICAgICAgIHJlZ0xpbmVDaGFuZ2UodGhpcyQxLCBpLCBcXFwiZ3V0dGVyXFxcIilcXG4gICAgICAgICAgaWYgKGlzRW1wdHkobGluZS5ndXR0ZXJNYXJrZXJzKSkgeyBsaW5lLmd1dHRlck1hcmtlcnMgPSBudWxsIH1cXG4gICAgICAgIH1cXG4gICAgICAgICsraVxcbiAgICAgIH0pXFxuICAgIH0pLFxcblxcbiAgICBsaW5lSW5mbzogZnVuY3Rpb24obGluZSkge1xcbiAgICAgIHZhciBuXFxuICAgICAgaWYgKHR5cGVvZiBsaW5lID09IFxcXCJudW1iZXJcXFwiKSB7XFxuICAgICAgICBpZiAoIWlzTGluZSh0aGlzLmRvYywgbGluZSkpIHsgcmV0dXJuIG51bGwgfVxcbiAgICAgICAgbiA9IGxpbmVcXG4gICAgICAgIGxpbmUgPSBnZXRMaW5lKHRoaXMuZG9jLCBsaW5lKVxcbiAgICAgICAgaWYgKCFsaW5lKSB7IHJldHVybiBudWxsIH1cXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgbiA9IGxpbmVObyhsaW5lKVxcbiAgICAgICAgaWYgKG4gPT0gbnVsbCkgeyByZXR1cm4gbnVsbCB9XFxuICAgICAgfVxcbiAgICAgIHJldHVybiB7bGluZTogbiwgaGFuZGxlOiBsaW5lLCB0ZXh0OiBsaW5lLnRleHQsIGd1dHRlck1hcmtlcnM6IGxpbmUuZ3V0dGVyTWFya2VycyxcXG4gICAgICAgICAgICAgIHRleHRDbGFzczogbGluZS50ZXh0Q2xhc3MsIGJnQ2xhc3M6IGxpbmUuYmdDbGFzcywgd3JhcENsYXNzOiBsaW5lLndyYXBDbGFzcyxcXG4gICAgICAgICAgICAgIHdpZGdldHM6IGxpbmUud2lkZ2V0c31cXG4gICAgfSxcXG5cXG4gICAgZ2V0Vmlld3BvcnQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4ge2Zyb206IHRoaXMuZGlzcGxheS52aWV3RnJvbSwgdG86IHRoaXMuZGlzcGxheS52aWV3VG99fSxcXG5cXG4gICAgYWRkV2lkZ2V0OiBmdW5jdGlvbihwb3MsIG5vZGUsIHNjcm9sbCwgdmVydCwgaG9yaXopIHtcXG4gICAgICB2YXIgZGlzcGxheSA9IHRoaXMuZGlzcGxheVxcbiAgICAgIHBvcyA9IGN1cnNvckNvb3Jkcyh0aGlzLCBjbGlwUG9zKHRoaXMuZG9jLCBwb3MpKVxcbiAgICAgIHZhciB0b3AgPSBwb3MuYm90dG9tLCBsZWZ0ID0gcG9zLmxlZnRcXG4gICAgICBub2RlLnN0eWxlLnBvc2l0aW9uID0gXFxcImFic29sdXRlXFxcIlxcbiAgICAgIG5vZGUuc2V0QXR0cmlidXRlKFxcXCJjbS1pZ25vcmUtZXZlbnRzXFxcIiwgXFxcInRydWVcXFwiKVxcbiAgICAgIHRoaXMuZGlzcGxheS5pbnB1dC5zZXRVbmVkaXRhYmxlKG5vZGUpXFxuICAgICAgZGlzcGxheS5zaXplci5hcHBlbmRDaGlsZChub2RlKVxcbiAgICAgIGlmICh2ZXJ0ID09IFxcXCJvdmVyXFxcIikge1xcbiAgICAgICAgdG9wID0gcG9zLnRvcFxcbiAgICAgIH0gZWxzZSBpZiAodmVydCA9PSBcXFwiYWJvdmVcXFwiIHx8IHZlcnQgPT0gXFxcIm5lYXJcXFwiKSB7XFxuICAgICAgICB2YXIgdnNwYWNlID0gTWF0aC5tYXgoZGlzcGxheS53cmFwcGVyLmNsaWVudEhlaWdodCwgdGhpcy5kb2MuaGVpZ2h0KSxcXG4gICAgICAgIGhzcGFjZSA9IE1hdGgubWF4KGRpc3BsYXkuc2l6ZXIuY2xpZW50V2lkdGgsIGRpc3BsYXkubGluZVNwYWNlLmNsaWVudFdpZHRoKVxcbiAgICAgICAgLy8gRGVmYXVsdCB0byBwb3NpdGlvbmluZyBhYm92ZSAoaWYgc3BlY2lmaWVkIGFuZCBwb3NzaWJsZSk7IG90aGVyd2lzZSBkZWZhdWx0IHRvIHBvc2l0aW9uaW5nIGJlbG93XFxuICAgICAgICBpZiAoKHZlcnQgPT0gJ2Fib3ZlJyB8fCBwb3MuYm90dG9tICsgbm9kZS5vZmZzZXRIZWlnaHQgPiB2c3BhY2UpICYmIHBvcy50b3AgPiBub2RlLm9mZnNldEhlaWdodClcXG4gICAgICAgICAgeyB0b3AgPSBwb3MudG9wIC0gbm9kZS5vZmZzZXRIZWlnaHQgfVxcbiAgICAgICAgZWxzZSBpZiAocG9zLmJvdHRvbSArIG5vZGUub2Zmc2V0SGVpZ2h0IDw9IHZzcGFjZSlcXG4gICAgICAgICAgeyB0b3AgPSBwb3MuYm90dG9tIH1cXG4gICAgICAgIGlmIChsZWZ0ICsgbm9kZS5vZmZzZXRXaWR0aCA+IGhzcGFjZSlcXG4gICAgICAgICAgeyBsZWZ0ID0gaHNwYWNlIC0gbm9kZS5vZmZzZXRXaWR0aCB9XFxuICAgICAgfVxcbiAgICAgIG5vZGUuc3R5bGUudG9wID0gdG9wICsgXFxcInB4XFxcIlxcbiAgICAgIG5vZGUuc3R5bGUubGVmdCA9IG5vZGUuc3R5bGUucmlnaHQgPSBcXFwiXFxcIlxcbiAgICAgIGlmIChob3JpeiA9PSBcXFwicmlnaHRcXFwiKSB7XFxuICAgICAgICBsZWZ0ID0gZGlzcGxheS5zaXplci5jbGllbnRXaWR0aCAtIG5vZGUub2Zmc2V0V2lkdGhcXG4gICAgICAgIG5vZGUuc3R5bGUucmlnaHQgPSBcXFwiMHB4XFxcIlxcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBpZiAoaG9yaXogPT0gXFxcImxlZnRcXFwiKSB7IGxlZnQgPSAwIH1cXG4gICAgICAgIGVsc2UgaWYgKGhvcml6ID09IFxcXCJtaWRkbGVcXFwiKSB7IGxlZnQgPSAoZGlzcGxheS5zaXplci5jbGllbnRXaWR0aCAtIG5vZGUub2Zmc2V0V2lkdGgpIC8gMiB9XFxuICAgICAgICBub2RlLnN0eWxlLmxlZnQgPSBsZWZ0ICsgXFxcInB4XFxcIlxcbiAgICAgIH1cXG4gICAgICBpZiAoc2Nyb2xsKVxcbiAgICAgICAgeyBzY3JvbGxJbnRvVmlldyh0aGlzLCBsZWZ0LCB0b3AsIGxlZnQgKyBub2RlLm9mZnNldFdpZHRoLCB0b3AgKyBub2RlLm9mZnNldEhlaWdodCkgfVxcbiAgICB9LFxcblxcbiAgICB0cmlnZ2VyT25LZXlEb3duOiBtZXRob2RPcChvbktleURvd24pLFxcbiAgICB0cmlnZ2VyT25LZXlQcmVzczogbWV0aG9kT3Aob25LZXlQcmVzcyksXFxuICAgIHRyaWdnZXJPbktleVVwOiBvbktleVVwLFxcblxcbiAgICBleGVjQ29tbWFuZDogZnVuY3Rpb24oY21kKSB7XFxuICAgICAgaWYgKGNvbW1hbmRzLmhhc093blByb3BlcnR5KGNtZCkpXFxuICAgICAgICB7IHJldHVybiBjb21tYW5kc1tjbWRdLmNhbGwobnVsbCwgdGhpcykgfVxcbiAgICB9LFxcblxcbiAgICB0cmlnZ2VyRWxlY3RyaWM6IG1ldGhvZE9wKGZ1bmN0aW9uKHRleHQpIHsgdHJpZ2dlckVsZWN0cmljKHRoaXMsIHRleHQpIH0pLFxcblxcbiAgICBmaW5kUG9zSDogZnVuY3Rpb24oZnJvbSwgYW1vdW50LCB1bml0LCB2aXN1YWxseSkge1xcbiAgICAgIHZhciB0aGlzJDEgPSB0aGlzO1xcblxcbiAgICAgIHZhciBkaXIgPSAxXFxuICAgICAgaWYgKGFtb3VudCA8IDApIHsgZGlyID0gLTE7IGFtb3VudCA9IC1hbW91bnQgfVxcbiAgICAgIHZhciBjdXIgPSBjbGlwUG9zKHRoaXMuZG9jLCBmcm9tKVxcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYW1vdW50OyArK2kpIHtcXG4gICAgICAgIGN1ciA9IGZpbmRQb3NIKHRoaXMkMS5kb2MsIGN1ciwgZGlyLCB1bml0LCB2aXN1YWxseSlcXG4gICAgICAgIGlmIChjdXIuaGl0U2lkZSkgeyBicmVhayB9XFxuICAgICAgfVxcbiAgICAgIHJldHVybiBjdXJcXG4gICAgfSxcXG5cXG4gICAgbW92ZUg6IG1ldGhvZE9wKGZ1bmN0aW9uKGRpciwgdW5pdCkge1xcbiAgICAgIHZhciB0aGlzJDEgPSB0aGlzO1xcblxcbiAgICAgIHRoaXMuZXh0ZW5kU2VsZWN0aW9uc0J5KGZ1bmN0aW9uIChyYW5nZSkge1xcbiAgICAgICAgaWYgKHRoaXMkMS5kaXNwbGF5LnNoaWZ0IHx8IHRoaXMkMS5kb2MuZXh0ZW5kIHx8IHJhbmdlLmVtcHR5KCkpXFxuICAgICAgICAgIHsgcmV0dXJuIGZpbmRQb3NIKHRoaXMkMS5kb2MsIHJhbmdlLmhlYWQsIGRpciwgdW5pdCwgdGhpcyQxLm9wdGlvbnMucnRsTW92ZVZpc3VhbGx5KSB9XFxuICAgICAgICBlbHNlXFxuICAgICAgICAgIHsgcmV0dXJuIGRpciA8IDAgPyByYW5nZS5mcm9tKCkgOiByYW5nZS50bygpIH1cXG4gICAgICB9LCBzZWxfbW92ZSlcXG4gICAgfSksXFxuXFxuICAgIGRlbGV0ZUg6IG1ldGhvZE9wKGZ1bmN0aW9uKGRpciwgdW5pdCkge1xcbiAgICAgIHZhciBzZWwgPSB0aGlzLmRvYy5zZWwsIGRvYyA9IHRoaXMuZG9jXFxuICAgICAgaWYgKHNlbC5zb21ldGhpbmdTZWxlY3RlZCgpKVxcbiAgICAgICAgeyBkb2MucmVwbGFjZVNlbGVjdGlvbihcXFwiXFxcIiwgbnVsbCwgXFxcIitkZWxldGVcXFwiKSB9XFxuICAgICAgZWxzZVxcbiAgICAgICAgeyBkZWxldGVOZWFyU2VsZWN0aW9uKHRoaXMsIGZ1bmN0aW9uIChyYW5nZSkge1xcbiAgICAgICAgICB2YXIgb3RoZXIgPSBmaW5kUG9zSChkb2MsIHJhbmdlLmhlYWQsIGRpciwgdW5pdCwgZmFsc2UpXFxuICAgICAgICAgIHJldHVybiBkaXIgPCAwID8ge2Zyb206IG90aGVyLCB0bzogcmFuZ2UuaGVhZH0gOiB7ZnJvbTogcmFuZ2UuaGVhZCwgdG86IG90aGVyfVxcbiAgICAgICAgfSkgfVxcbiAgICB9KSxcXG5cXG4gICAgZmluZFBvc1Y6IGZ1bmN0aW9uKGZyb20sIGFtb3VudCwgdW5pdCwgZ29hbENvbHVtbikge1xcbiAgICAgIHZhciB0aGlzJDEgPSB0aGlzO1xcblxcbiAgICAgIHZhciBkaXIgPSAxLCB4ID0gZ29hbENvbHVtblxcbiAgICAgIGlmIChhbW91bnQgPCAwKSB7IGRpciA9IC0xOyBhbW91bnQgPSAtYW1vdW50IH1cXG4gICAgICB2YXIgY3VyID0gY2xpcFBvcyh0aGlzLmRvYywgZnJvbSlcXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFtb3VudDsgKytpKSB7XFxuICAgICAgICB2YXIgY29vcmRzID0gY3Vyc29yQ29vcmRzKHRoaXMkMSwgY3VyLCBcXFwiZGl2XFxcIilcXG4gICAgICAgIGlmICh4ID09IG51bGwpIHsgeCA9IGNvb3Jkcy5sZWZ0IH1cXG4gICAgICAgIGVsc2UgeyBjb29yZHMubGVmdCA9IHggfVxcbiAgICAgICAgY3VyID0gZmluZFBvc1YodGhpcyQxLCBjb29yZHMsIGRpciwgdW5pdClcXG4gICAgICAgIGlmIChjdXIuaGl0U2lkZSkgeyBicmVhayB9XFxuICAgICAgfVxcbiAgICAgIHJldHVybiBjdXJcXG4gICAgfSxcXG5cXG4gICAgbW92ZVY6IG1ldGhvZE9wKGZ1bmN0aW9uKGRpciwgdW5pdCkge1xcbiAgICAgIHZhciB0aGlzJDEgPSB0aGlzO1xcblxcbiAgICAgIHZhciBkb2MgPSB0aGlzLmRvYywgZ29hbHMgPSBbXVxcbiAgICAgIHZhciBjb2xsYXBzZSA9ICF0aGlzLmRpc3BsYXkuc2hpZnQgJiYgIWRvYy5leHRlbmQgJiYgZG9jLnNlbC5zb21ldGhpbmdTZWxlY3RlZCgpXFxuICAgICAgZG9jLmV4dGVuZFNlbGVjdGlvbnNCeShmdW5jdGlvbiAocmFuZ2UpIHtcXG4gICAgICAgIGlmIChjb2xsYXBzZSlcXG4gICAgICAgICAgeyByZXR1cm4gZGlyIDwgMCA/IHJhbmdlLmZyb20oKSA6IHJhbmdlLnRvKCkgfVxcbiAgICAgICAgdmFyIGhlYWRQb3MgPSBjdXJzb3JDb29yZHModGhpcyQxLCByYW5nZS5oZWFkLCBcXFwiZGl2XFxcIilcXG4gICAgICAgIGlmIChyYW5nZS5nb2FsQ29sdW1uICE9IG51bGwpIHsgaGVhZFBvcy5sZWZ0ID0gcmFuZ2UuZ29hbENvbHVtbiB9XFxuICAgICAgICBnb2Fscy5wdXNoKGhlYWRQb3MubGVmdClcXG4gICAgICAgIHZhciBwb3MgPSBmaW5kUG9zVih0aGlzJDEsIGhlYWRQb3MsIGRpciwgdW5pdClcXG4gICAgICAgIGlmICh1bml0ID09IFxcXCJwYWdlXFxcIiAmJiByYW5nZSA9PSBkb2Muc2VsLnByaW1hcnkoKSlcXG4gICAgICAgICAgeyBhZGRUb1Njcm9sbFBvcyh0aGlzJDEsIG51bGwsIGNoYXJDb29yZHModGhpcyQxLCBwb3MsIFxcXCJkaXZcXFwiKS50b3AgLSBoZWFkUG9zLnRvcCkgfVxcbiAgICAgICAgcmV0dXJuIHBvc1xcbiAgICAgIH0sIHNlbF9tb3ZlKVxcbiAgICAgIGlmIChnb2Fscy5sZW5ndGgpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBkb2Muc2VsLnJhbmdlcy5sZW5ndGg7IGkrKylcXG4gICAgICAgIHsgZG9jLnNlbC5yYW5nZXNbaV0uZ29hbENvbHVtbiA9IGdvYWxzW2ldIH0gfVxcbiAgICB9KSxcXG5cXG4gICAgLy8gRmluZCB0aGUgd29yZCBhdCB0aGUgZ2l2ZW4gcG9zaXRpb24gKGFzIHJldHVybmVkIGJ5IGNvb3Jkc0NoYXIpLlxcbiAgICBmaW5kV29yZEF0OiBmdW5jdGlvbihwb3MpIHtcXG4gICAgICB2YXIgZG9jID0gdGhpcy5kb2MsIGxpbmUgPSBnZXRMaW5lKGRvYywgcG9zLmxpbmUpLnRleHRcXG4gICAgICB2YXIgc3RhcnQgPSBwb3MuY2gsIGVuZCA9IHBvcy5jaFxcbiAgICAgIGlmIChsaW5lKSB7XFxuICAgICAgICB2YXIgaGVscGVyID0gdGhpcy5nZXRIZWxwZXIocG9zLCBcXFwid29yZENoYXJzXFxcIilcXG4gICAgICAgIGlmICgocG9zLnhSZWwgPCAwIHx8IGVuZCA9PSBsaW5lLmxlbmd0aCkgJiYgc3RhcnQpIHsgLS1zdGFydDsgfSBlbHNlIHsgKytlbmQgfVxcbiAgICAgICAgdmFyIHN0YXJ0Q2hhciA9IGxpbmUuY2hhckF0KHN0YXJ0KVxcbiAgICAgICAgdmFyIGNoZWNrID0gaXNXb3JkQ2hhcihzdGFydENoYXIsIGhlbHBlcilcXG4gICAgICAgICAgPyBmdW5jdGlvbiAoY2gpIHsgcmV0dXJuIGlzV29yZENoYXIoY2gsIGhlbHBlcik7IH1cXG4gICAgICAgICAgOiAvXFxcXHMvLnRlc3Qoc3RhcnRDaGFyKSA/IGZ1bmN0aW9uIChjaCkgeyByZXR1cm4gL1xcXFxzLy50ZXN0KGNoKTsgfVxcbiAgICAgICAgICA6IGZ1bmN0aW9uIChjaCkgeyByZXR1cm4gKCEvXFxcXHMvLnRlc3QoY2gpICYmICFpc1dvcmRDaGFyKGNoKSk7IH1cXG4gICAgICAgIHdoaWxlIChzdGFydCA+IDAgJiYgY2hlY2sobGluZS5jaGFyQXQoc3RhcnQgLSAxKSkpIHsgLS1zdGFydCB9XFxuICAgICAgICB3aGlsZSAoZW5kIDwgbGluZS5sZW5ndGggJiYgY2hlY2sobGluZS5jaGFyQXQoZW5kKSkpIHsgKytlbmQgfVxcbiAgICAgIH1cXG4gICAgICByZXR1cm4gbmV3IFJhbmdlKFBvcyhwb3MubGluZSwgc3RhcnQpLCBQb3MocG9zLmxpbmUsIGVuZCkpXFxuICAgIH0sXFxuXFxuICAgIHRvZ2dsZU92ZXJ3cml0ZTogZnVuY3Rpb24odmFsdWUpIHtcXG4gICAgICBpZiAodmFsdWUgIT0gbnVsbCAmJiB2YWx1ZSA9PSB0aGlzLnN0YXRlLm92ZXJ3cml0ZSkgeyByZXR1cm4gfVxcbiAgICAgIGlmICh0aGlzLnN0YXRlLm92ZXJ3cml0ZSA9ICF0aGlzLnN0YXRlLm92ZXJ3cml0ZSlcXG4gICAgICAgIHsgYWRkQ2xhc3ModGhpcy5kaXNwbGF5LmN1cnNvckRpdiwgXFxcIkNvZGVNaXJyb3Itb3ZlcndyaXRlXFxcIikgfVxcbiAgICAgIGVsc2VcXG4gICAgICAgIHsgcm1DbGFzcyh0aGlzLmRpc3BsYXkuY3Vyc29yRGl2LCBcXFwiQ29kZU1pcnJvci1vdmVyd3JpdGVcXFwiKSB9XFxuXFxuICAgICAgc2lnbmFsKHRoaXMsIFxcXCJvdmVyd3JpdGVUb2dnbGVcXFwiLCB0aGlzLCB0aGlzLnN0YXRlLm92ZXJ3cml0ZSlcXG4gICAgfSxcXG4gICAgaGFzRm9jdXM6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5kaXNwbGF5LmlucHV0LmdldEZpZWxkKCkgPT0gYWN0aXZlRWx0KCkgfSxcXG4gICAgaXNSZWFkT25seTogZnVuY3Rpb24oKSB7IHJldHVybiAhISh0aGlzLm9wdGlvbnMucmVhZE9ubHkgfHwgdGhpcy5kb2MuY2FudEVkaXQpIH0sXFxuXFxuICAgIHNjcm9sbFRvOiBtZXRob2RPcChmdW5jdGlvbih4LCB5KSB7XFxuICAgICAgaWYgKHggIT0gbnVsbCB8fCB5ICE9IG51bGwpIHsgcmVzb2x2ZVNjcm9sbFRvUG9zKHRoaXMpIH1cXG4gICAgICBpZiAoeCAhPSBudWxsKSB7IHRoaXMuY3VyT3Auc2Nyb2xsTGVmdCA9IHggfVxcbiAgICAgIGlmICh5ICE9IG51bGwpIHsgdGhpcy5jdXJPcC5zY3JvbGxUb3AgPSB5IH1cXG4gICAgfSksXFxuICAgIGdldFNjcm9sbEluZm86IGZ1bmN0aW9uKCkge1xcbiAgICAgIHZhciBzY3JvbGxlciA9IHRoaXMuZGlzcGxheS5zY3JvbGxlclxcbiAgICAgIHJldHVybiB7bGVmdDogc2Nyb2xsZXIuc2Nyb2xsTGVmdCwgdG9wOiBzY3JvbGxlci5zY3JvbGxUb3AsXFxuICAgICAgICAgICAgICBoZWlnaHQ6IHNjcm9sbGVyLnNjcm9sbEhlaWdodCAtIHNjcm9sbEdhcCh0aGlzKSAtIHRoaXMuZGlzcGxheS5iYXJIZWlnaHQsXFxuICAgICAgICAgICAgICB3aWR0aDogc2Nyb2xsZXIuc2Nyb2xsV2lkdGggLSBzY3JvbGxHYXAodGhpcykgLSB0aGlzLmRpc3BsYXkuYmFyV2lkdGgsXFxuICAgICAgICAgICAgICBjbGllbnRIZWlnaHQ6IGRpc3BsYXlIZWlnaHQodGhpcyksIGNsaWVudFdpZHRoOiBkaXNwbGF5V2lkdGgodGhpcyl9XFxuICAgIH0sXFxuXFxuICAgIHNjcm9sbEludG9WaWV3OiBtZXRob2RPcChmdW5jdGlvbihyYW5nZSwgbWFyZ2luKSB7XFxuICAgICAgaWYgKHJhbmdlID09IG51bGwpIHtcXG4gICAgICAgIHJhbmdlID0ge2Zyb206IHRoaXMuZG9jLnNlbC5wcmltYXJ5KCkuaGVhZCwgdG86IG51bGx9XFxuICAgICAgICBpZiAobWFyZ2luID09IG51bGwpIHsgbWFyZ2luID0gdGhpcy5vcHRpb25zLmN1cnNvclNjcm9sbE1hcmdpbiB9XFxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgcmFuZ2UgPT0gXFxcIm51bWJlclxcXCIpIHtcXG4gICAgICAgIHJhbmdlID0ge2Zyb206IFBvcyhyYW5nZSwgMCksIHRvOiBudWxsfVxcbiAgICAgIH0gZWxzZSBpZiAocmFuZ2UuZnJvbSA9PSBudWxsKSB7XFxuICAgICAgICByYW5nZSA9IHtmcm9tOiByYW5nZSwgdG86IG51bGx9XFxuICAgICAgfVxcbiAgICAgIGlmICghcmFuZ2UudG8pIHsgcmFuZ2UudG8gPSByYW5nZS5mcm9tIH1cXG4gICAgICByYW5nZS5tYXJnaW4gPSBtYXJnaW4gfHwgMFxcblxcbiAgICAgIGlmIChyYW5nZS5mcm9tLmxpbmUgIT0gbnVsbCkge1xcbiAgICAgICAgcmVzb2x2ZVNjcm9sbFRvUG9zKHRoaXMpXFxuICAgICAgICB0aGlzLmN1ck9wLnNjcm9sbFRvUG9zID0gcmFuZ2VcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgdmFyIHNQb3MgPSBjYWxjdWxhdGVTY3JvbGxQb3ModGhpcywgTWF0aC5taW4ocmFuZ2UuZnJvbS5sZWZ0LCByYW5nZS50by5sZWZ0KSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1hdGgubWluKHJhbmdlLmZyb20udG9wLCByYW5nZS50by50b3ApIC0gcmFuZ2UubWFyZ2luLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5tYXgocmFuZ2UuZnJvbS5yaWdodCwgcmFuZ2UudG8ucmlnaHQpLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5tYXgocmFuZ2UuZnJvbS5ib3R0b20sIHJhbmdlLnRvLmJvdHRvbSkgKyByYW5nZS5tYXJnaW4pXFxuICAgICAgICB0aGlzLnNjcm9sbFRvKHNQb3Muc2Nyb2xsTGVmdCwgc1Bvcy5zY3JvbGxUb3ApXFxuICAgICAgfVxcbiAgICB9KSxcXG5cXG4gICAgc2V0U2l6ZTogbWV0aG9kT3AoZnVuY3Rpb24od2lkdGgsIGhlaWdodCkge1xcbiAgICAgIHZhciB0aGlzJDEgPSB0aGlzO1xcblxcbiAgICAgIHZhciBpbnRlcnByZXQgPSBmdW5jdGlvbiAodmFsKSB7IHJldHVybiB0eXBlb2YgdmFsID09IFxcXCJudW1iZXJcXFwiIHx8IC9eXFxcXGQrJC8udGVzdChTdHJpbmcodmFsKSkgPyB2YWwgKyBcXFwicHhcXFwiIDogdmFsOyB9XFxuICAgICAgaWYgKHdpZHRoICE9IG51bGwpIHsgdGhpcy5kaXNwbGF5LndyYXBwZXIuc3R5bGUud2lkdGggPSBpbnRlcnByZXQod2lkdGgpIH1cXG4gICAgICBpZiAoaGVpZ2h0ICE9IG51bGwpIHsgdGhpcy5kaXNwbGF5LndyYXBwZXIuc3R5bGUuaGVpZ2h0ID0gaW50ZXJwcmV0KGhlaWdodCkgfVxcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMubGluZVdyYXBwaW5nKSB7IGNsZWFyTGluZU1lYXN1cmVtZW50Q2FjaGUodGhpcykgfVxcbiAgICAgIHZhciBsaW5lTm8gPSB0aGlzLmRpc3BsYXkudmlld0Zyb21cXG4gICAgICB0aGlzLmRvYy5pdGVyKGxpbmVObywgdGhpcy5kaXNwbGF5LnZpZXdUbywgZnVuY3Rpb24gKGxpbmUpIHtcXG4gICAgICAgIGlmIChsaW5lLndpZGdldHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lLndpZGdldHMubGVuZ3RoOyBpKyspXFxuICAgICAgICAgIHsgaWYgKGxpbmUud2lkZ2V0c1tpXS5ub0hTY3JvbGwpIHsgcmVnTGluZUNoYW5nZSh0aGlzJDEsIGxpbmVObywgXFxcIndpZGdldFxcXCIpOyBicmVhayB9IH0gfVxcbiAgICAgICAgKytsaW5lTm9cXG4gICAgICB9KVxcbiAgICAgIHRoaXMuY3VyT3AuZm9yY2VVcGRhdGUgPSB0cnVlXFxuICAgICAgc2lnbmFsKHRoaXMsIFxcXCJyZWZyZXNoXFxcIiwgdGhpcylcXG4gICAgfSksXFxuXFxuICAgIG9wZXJhdGlvbjogZnVuY3Rpb24oZil7cmV0dXJuIHJ1bkluT3AodGhpcywgZil9LFxcblxcbiAgICByZWZyZXNoOiBtZXRob2RPcChmdW5jdGlvbigpIHtcXG4gICAgICB2YXIgb2xkSGVpZ2h0ID0gdGhpcy5kaXNwbGF5LmNhY2hlZFRleHRIZWlnaHRcXG4gICAgICByZWdDaGFuZ2UodGhpcylcXG4gICAgICB0aGlzLmN1ck9wLmZvcmNlVXBkYXRlID0gdHJ1ZVxcbiAgICAgIGNsZWFyQ2FjaGVzKHRoaXMpXFxuICAgICAgdGhpcy5zY3JvbGxUbyh0aGlzLmRvYy5zY3JvbGxMZWZ0LCB0aGlzLmRvYy5zY3JvbGxUb3ApXFxuICAgICAgdXBkYXRlR3V0dGVyU3BhY2UodGhpcylcXG4gICAgICBpZiAob2xkSGVpZ2h0ID09IG51bGwgfHwgTWF0aC5hYnMob2xkSGVpZ2h0IC0gdGV4dEhlaWdodCh0aGlzLmRpc3BsYXkpKSA+IC41KVxcbiAgICAgICAgeyBlc3RpbWF0ZUxpbmVIZWlnaHRzKHRoaXMpIH1cXG4gICAgICBzaWduYWwodGhpcywgXFxcInJlZnJlc2hcXFwiLCB0aGlzKVxcbiAgICB9KSxcXG5cXG4gICAgc3dhcERvYzogbWV0aG9kT3AoZnVuY3Rpb24oZG9jKSB7XFxuICAgICAgdmFyIG9sZCA9IHRoaXMuZG9jXFxuICAgICAgb2xkLmNtID0gbnVsbFxcbiAgICAgIGF0dGFjaERvYyh0aGlzLCBkb2MpXFxuICAgICAgY2xlYXJDYWNoZXModGhpcylcXG4gICAgICB0aGlzLmRpc3BsYXkuaW5wdXQucmVzZXQoKVxcbiAgICAgIHRoaXMuc2Nyb2xsVG8oZG9jLnNjcm9sbExlZnQsIGRvYy5zY3JvbGxUb3ApXFxuICAgICAgdGhpcy5jdXJPcC5mb3JjZVNjcm9sbCA9IHRydWVcXG4gICAgICBzaWduYWxMYXRlcih0aGlzLCBcXFwic3dhcERvY1xcXCIsIHRoaXMsIG9sZClcXG4gICAgICByZXR1cm4gb2xkXFxuICAgIH0pLFxcblxcbiAgICBnZXRJbnB1dEZpZWxkOiBmdW5jdGlvbigpe3JldHVybiB0aGlzLmRpc3BsYXkuaW5wdXQuZ2V0RmllbGQoKX0sXFxuICAgIGdldFdyYXBwZXJFbGVtZW50OiBmdW5jdGlvbigpe3JldHVybiB0aGlzLmRpc3BsYXkud3JhcHBlcn0sXFxuICAgIGdldFNjcm9sbGVyRWxlbWVudDogZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5kaXNwbGF5LnNjcm9sbGVyfSxcXG4gICAgZ2V0R3V0dGVyRWxlbWVudDogZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5kaXNwbGF5Lmd1dHRlcnN9XFxuICB9XFxuICBldmVudE1peGluKENvZGVNaXJyb3IpXFxuXFxuICBDb2RlTWlycm9yLnJlZ2lzdGVySGVscGVyID0gZnVuY3Rpb24odHlwZSwgbmFtZSwgdmFsdWUpIHtcXG4gICAgaWYgKCFoZWxwZXJzLmhhc093blByb3BlcnR5KHR5cGUpKSB7IGhlbHBlcnNbdHlwZV0gPSBDb2RlTWlycm9yW3R5cGVdID0ge19nbG9iYWw6IFtdfSB9XFxuICAgIGhlbHBlcnNbdHlwZV1bbmFtZV0gPSB2YWx1ZVxcbiAgfVxcbiAgQ29kZU1pcnJvci5yZWdpc3Rlckdsb2JhbEhlbHBlciA9IGZ1bmN0aW9uKHR5cGUsIG5hbWUsIHByZWRpY2F0ZSwgdmFsdWUpIHtcXG4gICAgQ29kZU1pcnJvci5yZWdpc3RlckhlbHBlcih0eXBlLCBuYW1lLCB2YWx1ZSlcXG4gICAgaGVscGVyc1t0eXBlXS5fZ2xvYmFsLnB1c2goe3ByZWQ6IHByZWRpY2F0ZSwgdmFsOiB2YWx1ZX0pXFxuICB9XFxufVxcblxcbi8vIFVzZWQgZm9yIGhvcml6b250YWwgcmVsYXRpdmUgbW90aW9uLiBEaXIgaXMgLTEgb3IgMSAobGVmdCBvclxcbi8vIHJpZ2h0KSwgdW5pdCBjYW4gYmUgXFxcImNoYXJcXFwiLCBcXFwiY29sdW1uXFxcIiAobGlrZSBjaGFyLCBidXQgZG9lc24ndFxcbi8vIGNyb3NzIGxpbmUgYm91bmRhcmllcyksIFxcXCJ3b3JkXFxcIiAoYWNyb3NzIG5leHQgd29yZCksIG9yIFxcXCJncm91cFxcXCIgKHRvXFxuLy8gdGhlIHN0YXJ0IG9mIG5leHQgZ3JvdXAgb2Ygd29yZCBvciBub24td29yZC1ub24td2hpdGVzcGFjZVxcbi8vIGNoYXJzKS4gVGhlIHZpc3VhbGx5IHBhcmFtIGNvbnRyb2xzIHdoZXRoZXIsIGluIHJpZ2h0LXRvLWxlZnRcXG4vLyB0ZXh0LCBkaXJlY3Rpb24gMSBtZWFucyB0byBtb3ZlIHRvd2FyZHMgdGhlIG5leHQgaW5kZXggaW4gdGhlXFxuLy8gc3RyaW5nLCBvciB0b3dhcmRzIHRoZSBjaGFyYWN0ZXIgdG8gdGhlIHJpZ2h0IG9mIHRoZSBjdXJyZW50XFxuLy8gcG9zaXRpb24uIFRoZSByZXN1bHRpbmcgcG9zaXRpb24gd2lsbCBoYXZlIGEgaGl0U2lkZT10cnVlXFxuLy8gcHJvcGVydHkgaWYgaXQgcmVhY2hlZCB0aGUgZW5kIG9mIHRoZSBkb2N1bWVudC5cXG5mdW5jdGlvbiBmaW5kUG9zSChkb2MsIHBvcywgZGlyLCB1bml0LCB2aXN1YWxseSkge1xcbiAgdmFyIGxpbmUgPSBwb3MubGluZSwgY2ggPSBwb3MuY2gsIG9yaWdEaXIgPSBkaXJcXG4gIHZhciBsaW5lT2JqID0gZ2V0TGluZShkb2MsIGxpbmUpXFxuICBmdW5jdGlvbiBmaW5kTmV4dExpbmUoKSB7XFxuICAgIHZhciBsID0gbGluZSArIGRpclxcbiAgICBpZiAobCA8IGRvYy5maXJzdCB8fCBsID49IGRvYy5maXJzdCArIGRvYy5zaXplKSB7IHJldHVybiBmYWxzZSB9XFxuICAgIGxpbmUgPSBsXFxuICAgIHJldHVybiBsaW5lT2JqID0gZ2V0TGluZShkb2MsIGwpXFxuICB9XFxuICBmdW5jdGlvbiBtb3ZlT25jZShib3VuZFRvTGluZSkge1xcbiAgICB2YXIgbmV4dCA9ICh2aXN1YWxseSA/IG1vdmVWaXN1YWxseSA6IG1vdmVMb2dpY2FsbHkpKGxpbmVPYmosIGNoLCBkaXIsIHRydWUpXFxuICAgIGlmIChuZXh0ID09IG51bGwpIHtcXG4gICAgICBpZiAoIWJvdW5kVG9MaW5lICYmIGZpbmROZXh0TGluZSgpKSB7XFxuICAgICAgICBpZiAodmlzdWFsbHkpIHsgY2ggPSAoZGlyIDwgMCA/IGxpbmVSaWdodCA6IGxpbmVMZWZ0KShsaW5lT2JqKSB9XFxuICAgICAgICBlbHNlIHsgY2ggPSBkaXIgPCAwID8gbGluZU9iai50ZXh0Lmxlbmd0aCA6IDAgfVxcbiAgICAgIH0gZWxzZSB7IHJldHVybiBmYWxzZSB9XFxuICAgIH0gZWxzZSB7IGNoID0gbmV4dCB9XFxuICAgIHJldHVybiB0cnVlXFxuICB9XFxuXFxuICBpZiAodW5pdCA9PSBcXFwiY2hhclxcXCIpIHtcXG4gICAgbW92ZU9uY2UoKVxcbiAgfSBlbHNlIGlmICh1bml0ID09IFxcXCJjb2x1bW5cXFwiKSB7XFxuICAgIG1vdmVPbmNlKHRydWUpXFxuICB9IGVsc2UgaWYgKHVuaXQgPT0gXFxcIndvcmRcXFwiIHx8IHVuaXQgPT0gXFxcImdyb3VwXFxcIikge1xcbiAgICB2YXIgc2F3VHlwZSA9IG51bGwsIGdyb3VwID0gdW5pdCA9PSBcXFwiZ3JvdXBcXFwiXFxuICAgIHZhciBoZWxwZXIgPSBkb2MuY20gJiYgZG9jLmNtLmdldEhlbHBlcihwb3MsIFxcXCJ3b3JkQ2hhcnNcXFwiKVxcbiAgICBmb3IgKHZhciBmaXJzdCA9IHRydWU7OyBmaXJzdCA9IGZhbHNlKSB7XFxuICAgICAgaWYgKGRpciA8IDAgJiYgIW1vdmVPbmNlKCFmaXJzdCkpIHsgYnJlYWsgfVxcbiAgICAgIHZhciBjdXIgPSBsaW5lT2JqLnRleHQuY2hhckF0KGNoKSB8fCBcXFwiXFxcXG5cXFwiXFxuICAgICAgdmFyIHR5cGUgPSBpc1dvcmRDaGFyKGN1ciwgaGVscGVyKSA/IFxcXCJ3XFxcIlxcbiAgICAgICAgOiBncm91cCAmJiBjdXIgPT0gXFxcIlxcXFxuXFxcIiA/IFxcXCJuXFxcIlxcbiAgICAgICAgOiAhZ3JvdXAgfHwgL1xcXFxzLy50ZXN0KGN1cikgPyBudWxsXFxuICAgICAgICA6IFxcXCJwXFxcIlxcbiAgICAgIGlmIChncm91cCAmJiAhZmlyc3QgJiYgIXR5cGUpIHsgdHlwZSA9IFxcXCJzXFxcIiB9XFxuICAgICAgaWYgKHNhd1R5cGUgJiYgc2F3VHlwZSAhPSB0eXBlKSB7XFxuICAgICAgICBpZiAoZGlyIDwgMCkge2RpciA9IDE7IG1vdmVPbmNlKCl9XFxuICAgICAgICBicmVha1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAodHlwZSkgeyBzYXdUeXBlID0gdHlwZSB9XFxuICAgICAgaWYgKGRpciA+IDAgJiYgIW1vdmVPbmNlKCFmaXJzdCkpIHsgYnJlYWsgfVxcbiAgICB9XFxuICB9XFxuICB2YXIgcmVzdWx0ID0gc2tpcEF0b21pYyhkb2MsIFBvcyhsaW5lLCBjaCksIHBvcywgb3JpZ0RpciwgdHJ1ZSlcXG4gIGlmICghY21wKHBvcywgcmVzdWx0KSkgeyByZXN1bHQuaGl0U2lkZSA9IHRydWUgfVxcbiAgcmV0dXJuIHJlc3VsdFxcbn1cXG5cXG4vLyBGb3IgcmVsYXRpdmUgdmVydGljYWwgbW92ZW1lbnQuIERpciBtYXkgYmUgLTEgb3IgMS4gVW5pdCBjYW4gYmVcXG4vLyBcXFwicGFnZVxcXCIgb3IgXFxcImxpbmVcXFwiLiBUaGUgcmVzdWx0aW5nIHBvc2l0aW9uIHdpbGwgaGF2ZSBhIGhpdFNpZGU9dHJ1ZVxcbi8vIHByb3BlcnR5IGlmIGl0IHJlYWNoZWQgdGhlIGVuZCBvZiB0aGUgZG9jdW1lbnQuXFxuZnVuY3Rpb24gZmluZFBvc1YoY20sIHBvcywgZGlyLCB1bml0KSB7XFxuICB2YXIgZG9jID0gY20uZG9jLCB4ID0gcG9zLmxlZnQsIHlcXG4gIGlmICh1bml0ID09IFxcXCJwYWdlXFxcIikge1xcbiAgICB2YXIgcGFnZVNpemUgPSBNYXRoLm1pbihjbS5kaXNwbGF5LndyYXBwZXIuY2xpZW50SGVpZ2h0LCB3aW5kb3cuaW5uZXJIZWlnaHQgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodClcXG4gICAgdmFyIG1vdmVBbW91bnQgPSBNYXRoLm1heChwYWdlU2l6ZSAtIC41ICogdGV4dEhlaWdodChjbS5kaXNwbGF5KSwgMylcXG4gICAgeSA9IChkaXIgPiAwID8gcG9zLmJvdHRvbSA6IHBvcy50b3ApICsgZGlyICogbW92ZUFtb3VudFxcblxcbiAgfSBlbHNlIGlmICh1bml0ID09IFxcXCJsaW5lXFxcIikge1xcbiAgICB5ID0gZGlyID4gMCA/IHBvcy5ib3R0b20gKyAzIDogcG9zLnRvcCAtIDNcXG4gIH1cXG4gIHZhciB0YXJnZXRcXG4gIGZvciAoOzspIHtcXG4gICAgdGFyZ2V0ID0gY29vcmRzQ2hhcihjbSwgeCwgeSlcXG4gICAgaWYgKCF0YXJnZXQub3V0c2lkZSkgeyBicmVhayB9XFxuICAgIGlmIChkaXIgPCAwID8geSA8PSAwIDogeSA+PSBkb2MuaGVpZ2h0KSB7IHRhcmdldC5oaXRTaWRlID0gdHJ1ZTsgYnJlYWsgfVxcbiAgICB5ICs9IGRpciAqIDVcXG4gIH1cXG4gIHJldHVybiB0YXJnZXRcXG59XFxuXFxuLy8gQ09OVEVOVEVESVRBQkxFIElOUFVUIFNUWUxFXFxuXFxuZnVuY3Rpb24gQ29udGVudEVkaXRhYmxlSW5wdXQoY20pIHtcXG4gIHRoaXMuY20gPSBjbVxcbiAgdGhpcy5sYXN0QW5jaG9yTm9kZSA9IHRoaXMubGFzdEFuY2hvck9mZnNldCA9IHRoaXMubGFzdEZvY3VzTm9kZSA9IHRoaXMubGFzdEZvY3VzT2Zmc2V0ID0gbnVsbFxcbiAgdGhpcy5wb2xsaW5nID0gbmV3IERlbGF5ZWQoKVxcbiAgdGhpcy5ncmFjZVBlcmlvZCA9IGZhbHNlXFxufVxcblxcbkNvbnRlbnRFZGl0YWJsZUlucHV0LnByb3RvdHlwZSA9IGNvcHlPYmooe1xcbiAgaW5pdDogZnVuY3Rpb24oZGlzcGxheSkge1xcbiAgICB2YXIgaW5wdXQgPSB0aGlzLCBjbSA9IGlucHV0LmNtXFxuICAgIHZhciBkaXYgPSBpbnB1dC5kaXYgPSBkaXNwbGF5LmxpbmVEaXZcXG4gICAgZGlzYWJsZUJyb3dzZXJNYWdpYyhkaXYsIGNtLm9wdGlvbnMuc3BlbGxjaGVjaylcXG5cXG4gICAgb24oZGl2LCBcXFwicGFzdGVcXFwiLCBmdW5jdGlvbiAoZSkge1xcbiAgICAgIGlmIChzaWduYWxET01FdmVudChjbSwgZSkgfHwgaGFuZGxlUGFzdGUoZSwgY20pKSB7IHJldHVybiB9XFxuICAgICAgLy8gSUUgZG9lc24ndCBmaXJlIGlucHV0IGV2ZW50cywgc28gd2Ugc2NoZWR1bGUgYSByZWFkIGZvciB0aGUgcGFzdGVkIGNvbnRlbnQgaW4gdGhpcyB3YXlcXG4gICAgICBpZiAoaWVfdmVyc2lvbiA8PSAxMSkgeyBzZXRUaW1lb3V0KG9wZXJhdGlvbihjbSwgZnVuY3Rpb24gKCkge1xcbiAgICAgICAgaWYgKCFpbnB1dC5wb2xsQ29udGVudCgpKSB7IHJlZ0NoYW5nZShjbSkgfVxcbiAgICAgIH0pLCAyMCkgfVxcbiAgICB9KVxcblxcbiAgICBvbihkaXYsIFxcXCJjb21wb3NpdGlvbnN0YXJ0XFxcIiwgZnVuY3Rpb24gKGUpIHtcXG4gICAgICB2YXIgZGF0YSA9IGUuZGF0YVxcbiAgICAgIGlucHV0LmNvbXBvc2luZyA9IHtzZWw6IGNtLmRvYy5zZWwsIGRhdGE6IGRhdGEsIHN0YXJ0RGF0YTogZGF0YX1cXG4gICAgICBpZiAoIWRhdGEpIHsgcmV0dXJuIH1cXG4gICAgICB2YXIgcHJpbSA9IGNtLmRvYy5zZWwucHJpbWFyeSgpXFxuICAgICAgdmFyIGxpbmUgPSBjbS5nZXRMaW5lKHByaW0uaGVhZC5saW5lKVxcbiAgICAgIHZhciBmb3VuZCA9IGxpbmUuaW5kZXhPZihkYXRhLCBNYXRoLm1heCgwLCBwcmltLmhlYWQuY2ggLSBkYXRhLmxlbmd0aCkpXFxuICAgICAgaWYgKGZvdW5kID4gLTEgJiYgZm91bmQgPD0gcHJpbS5oZWFkLmNoKVxcbiAgICAgICAgeyBpbnB1dC5jb21wb3Npbmcuc2VsID0gc2ltcGxlU2VsZWN0aW9uKFBvcyhwcmltLmhlYWQubGluZSwgZm91bmQpLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBQb3MocHJpbS5oZWFkLmxpbmUsIGZvdW5kICsgZGF0YS5sZW5ndGgpKSB9XFxuICAgIH0pXFxuICAgIG9uKGRpdiwgXFxcImNvbXBvc2l0aW9udXBkYXRlXFxcIiwgZnVuY3Rpb24gKGUpIHsgcmV0dXJuIGlucHV0LmNvbXBvc2luZy5kYXRhID0gZS5kYXRhOyB9KVxcbiAgICBvbihkaXYsIFxcXCJjb21wb3NpdGlvbmVuZFxcXCIsIGZ1bmN0aW9uIChlKSB7XFxuICAgICAgdmFyIG91cnMgPSBpbnB1dC5jb21wb3NpbmdcXG4gICAgICBpZiAoIW91cnMpIHsgcmV0dXJuIH1cXG4gICAgICBpZiAoZS5kYXRhICE9IG91cnMuc3RhcnREYXRhICYmICEvXFxcXHUyMDBiLy50ZXN0KGUuZGF0YSkpXFxuICAgICAgICB7IG91cnMuZGF0YSA9IGUuZGF0YSB9XFxuICAgICAgLy8gTmVlZCBhIHNtYWxsIGRlbGF5IHRvIHByZXZlbnQgb3RoZXIgY29kZSAoaW5wdXQgZXZlbnQsXFxuICAgICAgLy8gc2VsZWN0aW9uIHBvbGxpbmcpIGZyb20gZG9pbmcgZGFtYWdlIHdoZW4gZmlyZWQgcmlnaHQgYWZ0ZXJcXG4gICAgICAvLyBjb21wb3NpdGlvbmVuZC5cXG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIGlmICghb3Vycy5oYW5kbGVkKVxcbiAgICAgICAgICB7IGlucHV0LmFwcGx5Q29tcG9zaXRpb24ob3VycykgfVxcbiAgICAgICAgaWYgKGlucHV0LmNvbXBvc2luZyA9PSBvdXJzKVxcbiAgICAgICAgICB7IGlucHV0LmNvbXBvc2luZyA9IG51bGwgfVxcbiAgICAgIH0sIDUwKVxcbiAgICB9KVxcblxcbiAgICBvbihkaXYsIFxcXCJ0b3VjaHN0YXJ0XFxcIiwgZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5wdXQuZm9yY2VDb21wb3NpdGlvbkVuZCgpOyB9KVxcblxcbiAgICBvbihkaXYsIFxcXCJpbnB1dFxcXCIsIGZ1bmN0aW9uICgpIHtcXG4gICAgICBpZiAoaW5wdXQuY29tcG9zaW5nKSB7IHJldHVybiB9XFxuICAgICAgaWYgKGNtLmlzUmVhZE9ubHkoKSB8fCAhaW5wdXQucG9sbENvbnRlbnQoKSlcXG4gICAgICAgIHsgcnVuSW5PcChpbnB1dC5jbSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVnQ2hhbmdlKGNtKTsgfSkgfVxcbiAgICB9KVxcblxcbiAgICBmdW5jdGlvbiBvbkNvcHlDdXQoZSkge1xcbiAgICAgIGlmIChzaWduYWxET01FdmVudChjbSwgZSkpIHsgcmV0dXJuIH1cXG4gICAgICBpZiAoY20uc29tZXRoaW5nU2VsZWN0ZWQoKSkge1xcbiAgICAgICAgc2V0TGFzdENvcGllZCh7bGluZVdpc2U6IGZhbHNlLCB0ZXh0OiBjbS5nZXRTZWxlY3Rpb25zKCl9KVxcbiAgICAgICAgaWYgKGUudHlwZSA9PSBcXFwiY3V0XFxcIikgeyBjbS5yZXBsYWNlU2VsZWN0aW9uKFxcXCJcXFwiLCBudWxsLCBcXFwiY3V0XFxcIikgfVxcbiAgICAgIH0gZWxzZSBpZiAoIWNtLm9wdGlvbnMubGluZVdpc2VDb3B5Q3V0KSB7XFxuICAgICAgICByZXR1cm5cXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgdmFyIHJhbmdlcyA9IGNvcHlhYmxlUmFuZ2VzKGNtKVxcbiAgICAgICAgc2V0TGFzdENvcGllZCh7bGluZVdpc2U6IHRydWUsIHRleHQ6IHJhbmdlcy50ZXh0fSlcXG4gICAgICAgIGlmIChlLnR5cGUgPT0gXFxcImN1dFxcXCIpIHtcXG4gICAgICAgICAgY20ub3BlcmF0aW9uKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICBjbS5zZXRTZWxlY3Rpb25zKHJhbmdlcy5yYW5nZXMsIDAsIHNlbF9kb250U2Nyb2xsKVxcbiAgICAgICAgICAgIGNtLnJlcGxhY2VTZWxlY3Rpb24oXFxcIlxcXCIsIG51bGwsIFxcXCJjdXRcXFwiKVxcbiAgICAgICAgICB9KVxcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgICBpZiAoZS5jbGlwYm9hcmREYXRhKSB7XFxuICAgICAgICBlLmNsaXBib2FyZERhdGEuY2xlYXJEYXRhKClcXG4gICAgICAgIHZhciBjb250ZW50ID0gbGFzdENvcGllZC50ZXh0LmpvaW4oXFxcIlxcXFxuXFxcIilcXG4gICAgICAgIC8vIGlPUyBleHBvc2VzIHRoZSBjbGlwYm9hcmQgQVBJLCBidXQgc2VlbXMgdG8gZGlzY2FyZCBjb250ZW50IGluc2VydGVkIGludG8gaXRcXG4gICAgICAgIGUuY2xpcGJvYXJkRGF0YS5zZXREYXRhKFxcXCJUZXh0XFxcIiwgY29udGVudClcXG4gICAgICAgIGlmIChlLmNsaXBib2FyZERhdGEuZ2V0RGF0YShcXFwiVGV4dFxcXCIpID09IGNvbnRlbnQpIHtcXG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpXFxuICAgICAgICAgIHJldHVyblxcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgICAvLyBPbGQtZmFzaGlvbmVkIGJyaWVmbHktZm9jdXMtYS10ZXh0YXJlYSBoYWNrXFxuICAgICAgdmFyIGtsdWRnZSA9IGhpZGRlblRleHRhcmVhKCksIHRlID0ga2x1ZGdlLmZpcnN0Q2hpbGRcXG4gICAgICBjbS5kaXNwbGF5LmxpbmVTcGFjZS5pbnNlcnRCZWZvcmUoa2x1ZGdlLCBjbS5kaXNwbGF5LmxpbmVTcGFjZS5maXJzdENoaWxkKVxcbiAgICAgIHRlLnZhbHVlID0gbGFzdENvcGllZC50ZXh0LmpvaW4oXFxcIlxcXFxuXFxcIilcXG4gICAgICB2YXIgaGFkRm9jdXMgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50XFxuICAgICAgc2VsZWN0SW5wdXQodGUpXFxuICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XFxuICAgICAgICBjbS5kaXNwbGF5LmxpbmVTcGFjZS5yZW1vdmVDaGlsZChrbHVkZ2UpXFxuICAgICAgICBoYWRGb2N1cy5mb2N1cygpXFxuICAgICAgICBpZiAoaGFkRm9jdXMgPT0gZGl2KSB7IGlucHV0LnNob3dQcmltYXJ5U2VsZWN0aW9uKCkgfVxcbiAgICAgIH0sIDUwKVxcbiAgICB9XFxuICAgIG9uKGRpdiwgXFxcImNvcHlcXFwiLCBvbkNvcHlDdXQpXFxuICAgIG9uKGRpdiwgXFxcImN1dFxcXCIsIG9uQ29weUN1dClcXG4gIH0sXFxuXFxuICBwcmVwYXJlU2VsZWN0aW9uOiBmdW5jdGlvbigpIHtcXG4gICAgdmFyIHJlc3VsdCA9IHByZXBhcmVTZWxlY3Rpb24odGhpcy5jbSwgZmFsc2UpXFxuICAgIHJlc3VsdC5mb2N1cyA9IHRoaXMuY20uc3RhdGUuZm9jdXNlZFxcbiAgICByZXR1cm4gcmVzdWx0XFxuICB9LFxcblxcbiAgc2hvd1NlbGVjdGlvbjogZnVuY3Rpb24oaW5mbywgdGFrZUZvY3VzKSB7XFxuICAgIGlmICghaW5mbyB8fCAhdGhpcy5jbS5kaXNwbGF5LnZpZXcubGVuZ3RoKSB7IHJldHVybiB9XFxuICAgIGlmIChpbmZvLmZvY3VzIHx8IHRha2VGb2N1cykgeyB0aGlzLnNob3dQcmltYXJ5U2VsZWN0aW9uKCkgfVxcbiAgICB0aGlzLnNob3dNdWx0aXBsZVNlbGVjdGlvbnMoaW5mbylcXG4gIH0sXFxuXFxuICBzaG93UHJpbWFyeVNlbGVjdGlvbjogZnVuY3Rpb24oKSB7XFxuICAgIHZhciBzZWwgPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCksIHByaW0gPSB0aGlzLmNtLmRvYy5zZWwucHJpbWFyeSgpXFxuICAgIHZhciBjdXJBbmNob3IgPSBkb21Ub1Bvcyh0aGlzLmNtLCBzZWwuYW5jaG9yTm9kZSwgc2VsLmFuY2hvck9mZnNldClcXG4gICAgdmFyIGN1ckZvY3VzID0gZG9tVG9Qb3ModGhpcy5jbSwgc2VsLmZvY3VzTm9kZSwgc2VsLmZvY3VzT2Zmc2V0KVxcbiAgICBpZiAoY3VyQW5jaG9yICYmICFjdXJBbmNob3IuYmFkICYmIGN1ckZvY3VzICYmICFjdXJGb2N1cy5iYWQgJiZcXG4gICAgICAgIGNtcChtaW5Qb3MoY3VyQW5jaG9yLCBjdXJGb2N1cyksIHByaW0uZnJvbSgpKSA9PSAwICYmXFxuICAgICAgICBjbXAobWF4UG9zKGN1ckFuY2hvciwgY3VyRm9jdXMpLCBwcmltLnRvKCkpID09IDApXFxuICAgICAgeyByZXR1cm4gfVxcblxcbiAgICB2YXIgc3RhcnQgPSBwb3NUb0RPTSh0aGlzLmNtLCBwcmltLmZyb20oKSlcXG4gICAgdmFyIGVuZCA9IHBvc1RvRE9NKHRoaXMuY20sIHByaW0udG8oKSlcXG4gICAgaWYgKCFzdGFydCAmJiAhZW5kKSB7IHJldHVybiB9XFxuXFxuICAgIHZhciB2aWV3ID0gdGhpcy5jbS5kaXNwbGF5LnZpZXdcXG4gICAgdmFyIG9sZCA9IHNlbC5yYW5nZUNvdW50ICYmIHNlbC5nZXRSYW5nZUF0KDApXFxuICAgIGlmICghc3RhcnQpIHtcXG4gICAgICBzdGFydCA9IHtub2RlOiB2aWV3WzBdLm1lYXN1cmUubWFwWzJdLCBvZmZzZXQ6IDB9XFxuICAgIH0gZWxzZSBpZiAoIWVuZCkgeyAvLyBGSVhNRSBkYW5nZXJvdXNseSBoYWNreVxcbiAgICAgIHZhciBtZWFzdXJlID0gdmlld1t2aWV3Lmxlbmd0aCAtIDFdLm1lYXN1cmVcXG4gICAgICB2YXIgbWFwID0gbWVhc3VyZS5tYXBzID8gbWVhc3VyZS5tYXBzW21lYXN1cmUubWFwcy5sZW5ndGggLSAxXSA6IG1lYXN1cmUubWFwXFxuICAgICAgZW5kID0ge25vZGU6IG1hcFttYXAubGVuZ3RoIC0gMV0sIG9mZnNldDogbWFwW21hcC5sZW5ndGggLSAyXSAtIG1hcFttYXAubGVuZ3RoIC0gM119XFxuICAgIH1cXG5cXG4gICAgdmFyIHJuZ1xcbiAgICB0cnkgeyBybmcgPSByYW5nZShzdGFydC5ub2RlLCBzdGFydC5vZmZzZXQsIGVuZC5vZmZzZXQsIGVuZC5ub2RlKSB9XFxuICAgIGNhdGNoKGUpIHt9IC8vIE91ciBtb2RlbCBvZiB0aGUgRE9NIG1pZ2h0IGJlIG91dGRhdGVkLCBpbiB3aGljaCBjYXNlIHRoZSByYW5nZSB3ZSB0cnkgdG8gc2V0IGNhbiBiZSBpbXBvc3NpYmxlXFxuICAgIGlmIChybmcpIHtcXG4gICAgICBpZiAoIWdlY2tvICYmIHRoaXMuY20uc3RhdGUuZm9jdXNlZCkge1xcbiAgICAgICAgc2VsLmNvbGxhcHNlKHN0YXJ0Lm5vZGUsIHN0YXJ0Lm9mZnNldClcXG4gICAgICAgIGlmICghcm5nLmNvbGxhcHNlZCkge1xcbiAgICAgICAgICBzZWwucmVtb3ZlQWxsUmFuZ2VzKClcXG4gICAgICAgICAgc2VsLmFkZFJhbmdlKHJuZylcXG4gICAgICAgIH1cXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgc2VsLnJlbW92ZUFsbFJhbmdlcygpXFxuICAgICAgICBzZWwuYWRkUmFuZ2Uocm5nKVxcbiAgICAgIH1cXG4gICAgICBpZiAob2xkICYmIHNlbC5hbmNob3JOb2RlID09IG51bGwpIHsgc2VsLmFkZFJhbmdlKG9sZCkgfVxcbiAgICAgIGVsc2UgaWYgKGdlY2tvKSB7IHRoaXMuc3RhcnRHcmFjZVBlcmlvZCgpIH1cXG4gICAgfVxcbiAgICB0aGlzLnJlbWVtYmVyU2VsZWN0aW9uKClcXG4gIH0sXFxuXFxuICBzdGFydEdyYWNlUGVyaW9kOiBmdW5jdGlvbigpIHtcXG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XFxuXFxuICAgIGNsZWFyVGltZW91dCh0aGlzLmdyYWNlUGVyaW9kKVxcbiAgICB0aGlzLmdyYWNlUGVyaW9kID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XFxuICAgICAgdGhpcyQxLmdyYWNlUGVyaW9kID0gZmFsc2VcXG4gICAgICBpZiAodGhpcyQxLnNlbGVjdGlvbkNoYW5nZWQoKSlcXG4gICAgICAgIHsgdGhpcyQxLmNtLm9wZXJhdGlvbihmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzJDEuY20uY3VyT3Auc2VsZWN0aW9uQ2hhbmdlZCA9IHRydWU7IH0pIH1cXG4gICAgfSwgMjApXFxuICB9LFxcblxcbiAgc2hvd011bHRpcGxlU2VsZWN0aW9uczogZnVuY3Rpb24oaW5mbykge1xcbiAgICByZW1vdmVDaGlsZHJlbkFuZEFkZCh0aGlzLmNtLmRpc3BsYXkuY3Vyc29yRGl2LCBpbmZvLmN1cnNvcnMpXFxuICAgIHJlbW92ZUNoaWxkcmVuQW5kQWRkKHRoaXMuY20uZGlzcGxheS5zZWxlY3Rpb25EaXYsIGluZm8uc2VsZWN0aW9uKVxcbiAgfSxcXG5cXG4gIHJlbWVtYmVyU2VsZWN0aW9uOiBmdW5jdGlvbigpIHtcXG4gICAgdmFyIHNlbCA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKVxcbiAgICB0aGlzLmxhc3RBbmNob3JOb2RlID0gc2VsLmFuY2hvck5vZGU7IHRoaXMubGFzdEFuY2hvck9mZnNldCA9IHNlbC5hbmNob3JPZmZzZXRcXG4gICAgdGhpcy5sYXN0Rm9jdXNOb2RlID0gc2VsLmZvY3VzTm9kZTsgdGhpcy5sYXN0Rm9jdXNPZmZzZXQgPSBzZWwuZm9jdXNPZmZzZXRcXG4gIH0sXFxuXFxuICBzZWxlY3Rpb25JbkVkaXRvcjogZnVuY3Rpb24oKSB7XFxuICAgIHZhciBzZWwgPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKClcXG4gICAgaWYgKCFzZWwucmFuZ2VDb3VudCkgeyByZXR1cm4gZmFsc2UgfVxcbiAgICB2YXIgbm9kZSA9IHNlbC5nZXRSYW5nZUF0KDApLmNvbW1vbkFuY2VzdG9yQ29udGFpbmVyXFxuICAgIHJldHVybiBjb250YWlucyh0aGlzLmRpdiwgbm9kZSlcXG4gIH0sXFxuXFxuICBmb2N1czogZnVuY3Rpb24oKSB7XFxuICAgIGlmICh0aGlzLmNtLm9wdGlvbnMucmVhZE9ubHkgIT0gXFxcIm5vY3Vyc29yXFxcIikgeyB0aGlzLmRpdi5mb2N1cygpIH1cXG4gIH0sXFxuICBibHVyOiBmdW5jdGlvbigpIHsgdGhpcy5kaXYuYmx1cigpIH0sXFxuICBnZXRGaWVsZDogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLmRpdiB9LFxcblxcbiAgc3VwcG9ydHNUb3VjaDogZnVuY3Rpb24oKSB7IHJldHVybiB0cnVlIH0sXFxuXFxuICByZWNlaXZlZEZvY3VzOiBmdW5jdGlvbigpIHtcXG4gICAgdmFyIGlucHV0ID0gdGhpc1xcbiAgICBpZiAodGhpcy5zZWxlY3Rpb25JbkVkaXRvcigpKVxcbiAgICAgIHsgdGhpcy5wb2xsU2VsZWN0aW9uKCkgfVxcbiAgICBlbHNlXFxuICAgICAgeyBydW5Jbk9wKHRoaXMuY20sIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGlucHV0LmNtLmN1ck9wLnNlbGVjdGlvbkNoYW5nZWQgPSB0cnVlOyB9KSB9XFxuXFxuICAgIGZ1bmN0aW9uIHBvbGwoKSB7XFxuICAgICAgaWYgKGlucHV0LmNtLnN0YXRlLmZvY3VzZWQpIHtcXG4gICAgICAgIGlucHV0LnBvbGxTZWxlY3Rpb24oKVxcbiAgICAgICAgaW5wdXQucG9sbGluZy5zZXQoaW5wdXQuY20ub3B0aW9ucy5wb2xsSW50ZXJ2YWwsIHBvbGwpXFxuICAgICAgfVxcbiAgICB9XFxuICAgIHRoaXMucG9sbGluZy5zZXQodGhpcy5jbS5vcHRpb25zLnBvbGxJbnRlcnZhbCwgcG9sbClcXG4gIH0sXFxuXFxuICBzZWxlY3Rpb25DaGFuZ2VkOiBmdW5jdGlvbigpIHtcXG4gICAgdmFyIHNlbCA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKVxcbiAgICByZXR1cm4gc2VsLmFuY2hvck5vZGUgIT0gdGhpcy5sYXN0QW5jaG9yTm9kZSB8fCBzZWwuYW5jaG9yT2Zmc2V0ICE9IHRoaXMubGFzdEFuY2hvck9mZnNldCB8fFxcbiAgICAgIHNlbC5mb2N1c05vZGUgIT0gdGhpcy5sYXN0Rm9jdXNOb2RlIHx8IHNlbC5mb2N1c09mZnNldCAhPSB0aGlzLmxhc3RGb2N1c09mZnNldFxcbiAgfSxcXG5cXG4gIHBvbGxTZWxlY3Rpb246IGZ1bmN0aW9uKCkge1xcbiAgICBpZiAoIXRoaXMuY29tcG9zaW5nICYmICF0aGlzLmdyYWNlUGVyaW9kICYmIHRoaXMuc2VsZWN0aW9uQ2hhbmdlZCgpKSB7XFxuICAgICAgdmFyIHNlbCA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKSwgY20gPSB0aGlzLmNtXFxuICAgICAgdGhpcy5yZW1lbWJlclNlbGVjdGlvbigpXFxuICAgICAgdmFyIGFuY2hvciA9IGRvbVRvUG9zKGNtLCBzZWwuYW5jaG9yTm9kZSwgc2VsLmFuY2hvck9mZnNldClcXG4gICAgICB2YXIgaGVhZCA9IGRvbVRvUG9zKGNtLCBzZWwuZm9jdXNOb2RlLCBzZWwuZm9jdXNPZmZzZXQpXFxuICAgICAgaWYgKGFuY2hvciAmJiBoZWFkKSB7IHJ1bkluT3AoY20sIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIHNldFNlbGVjdGlvbihjbS5kb2MsIHNpbXBsZVNlbGVjdGlvbihhbmNob3IsIGhlYWQpLCBzZWxfZG9udFNjcm9sbClcXG4gICAgICAgIGlmIChhbmNob3IuYmFkIHx8IGhlYWQuYmFkKSB7IGNtLmN1ck9wLnNlbGVjdGlvbkNoYW5nZWQgPSB0cnVlIH1cXG4gICAgICB9KSB9XFxuICAgIH1cXG4gIH0sXFxuXFxuICBwb2xsQ29udGVudDogZnVuY3Rpb24oKSB7XFxuICAgIHZhciBjbSA9IHRoaXMuY20sIGRpc3BsYXkgPSBjbS5kaXNwbGF5LCBzZWwgPSBjbS5kb2Muc2VsLnByaW1hcnkoKVxcbiAgICB2YXIgZnJvbSA9IHNlbC5mcm9tKCksIHRvID0gc2VsLnRvKClcXG4gICAgaWYgKGZyb20ubGluZSA8IGRpc3BsYXkudmlld0Zyb20gfHwgdG8ubGluZSA+IGRpc3BsYXkudmlld1RvIC0gMSkgeyByZXR1cm4gZmFsc2UgfVxcblxcbiAgICB2YXIgZnJvbUluZGV4LCBmcm9tTGluZSwgZnJvbU5vZGVcXG4gICAgaWYgKGZyb20ubGluZSA9PSBkaXNwbGF5LnZpZXdGcm9tIHx8IChmcm9tSW5kZXggPSBmaW5kVmlld0luZGV4KGNtLCBmcm9tLmxpbmUpKSA9PSAwKSB7XFxuICAgICAgZnJvbUxpbmUgPSBsaW5lTm8oZGlzcGxheS52aWV3WzBdLmxpbmUpXFxuICAgICAgZnJvbU5vZGUgPSBkaXNwbGF5LnZpZXdbMF0ubm9kZVxcbiAgICB9IGVsc2Uge1xcbiAgICAgIGZyb21MaW5lID0gbGluZU5vKGRpc3BsYXkudmlld1tmcm9tSW5kZXhdLmxpbmUpXFxuICAgICAgZnJvbU5vZGUgPSBkaXNwbGF5LnZpZXdbZnJvbUluZGV4IC0gMV0ubm9kZS5uZXh0U2libGluZ1xcbiAgICB9XFxuICAgIHZhciB0b0luZGV4ID0gZmluZFZpZXdJbmRleChjbSwgdG8ubGluZSlcXG4gICAgdmFyIHRvTGluZSwgdG9Ob2RlXFxuICAgIGlmICh0b0luZGV4ID09IGRpc3BsYXkudmlldy5sZW5ndGggLSAxKSB7XFxuICAgICAgdG9MaW5lID0gZGlzcGxheS52aWV3VG8gLSAxXFxuICAgICAgdG9Ob2RlID0gZGlzcGxheS5saW5lRGl2Lmxhc3RDaGlsZFxcbiAgICB9IGVsc2Uge1xcbiAgICAgIHRvTGluZSA9IGxpbmVObyhkaXNwbGF5LnZpZXdbdG9JbmRleCArIDFdLmxpbmUpIC0gMVxcbiAgICAgIHRvTm9kZSA9IGRpc3BsYXkudmlld1t0b0luZGV4ICsgMV0ubm9kZS5wcmV2aW91c1NpYmxpbmdcXG4gICAgfVxcblxcbiAgICB2YXIgbmV3VGV4dCA9IGNtLmRvYy5zcGxpdExpbmVzKGRvbVRleHRCZXR3ZWVuKGNtLCBmcm9tTm9kZSwgdG9Ob2RlLCBmcm9tTGluZSwgdG9MaW5lKSlcXG4gICAgdmFyIG9sZFRleHQgPSBnZXRCZXR3ZWVuKGNtLmRvYywgUG9zKGZyb21MaW5lLCAwKSwgUG9zKHRvTGluZSwgZ2V0TGluZShjbS5kb2MsIHRvTGluZSkudGV4dC5sZW5ndGgpKVxcbiAgICB3aGlsZSAobmV3VGV4dC5sZW5ndGggPiAxICYmIG9sZFRleHQubGVuZ3RoID4gMSkge1xcbiAgICAgIGlmIChsc3QobmV3VGV4dCkgPT0gbHN0KG9sZFRleHQpKSB7IG5ld1RleHQucG9wKCk7IG9sZFRleHQucG9wKCk7IHRvTGluZS0tIH1cXG4gICAgICBlbHNlIGlmIChuZXdUZXh0WzBdID09IG9sZFRleHRbMF0pIHsgbmV3VGV4dC5zaGlmdCgpOyBvbGRUZXh0LnNoaWZ0KCk7IGZyb21MaW5lKysgfVxcbiAgICAgIGVsc2UgeyBicmVhayB9XFxuICAgIH1cXG5cXG4gICAgdmFyIGN1dEZyb250ID0gMCwgY3V0RW5kID0gMFxcbiAgICB2YXIgbmV3VG9wID0gbmV3VGV4dFswXSwgb2xkVG9wID0gb2xkVGV4dFswXSwgbWF4Q3V0RnJvbnQgPSBNYXRoLm1pbihuZXdUb3AubGVuZ3RoLCBvbGRUb3AubGVuZ3RoKVxcbiAgICB3aGlsZSAoY3V0RnJvbnQgPCBtYXhDdXRGcm9udCAmJiBuZXdUb3AuY2hhckNvZGVBdChjdXRGcm9udCkgPT0gb2xkVG9wLmNoYXJDb2RlQXQoY3V0RnJvbnQpKVxcbiAgICAgIHsgKytjdXRGcm9udCB9XFxuICAgIHZhciBuZXdCb3QgPSBsc3QobmV3VGV4dCksIG9sZEJvdCA9IGxzdChvbGRUZXh0KVxcbiAgICB2YXIgbWF4Q3V0RW5kID0gTWF0aC5taW4obmV3Qm90Lmxlbmd0aCAtIChuZXdUZXh0Lmxlbmd0aCA9PSAxID8gY3V0RnJvbnQgOiAwKSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9sZEJvdC5sZW5ndGggLSAob2xkVGV4dC5sZW5ndGggPT0gMSA/IGN1dEZyb250IDogMCkpXFxuICAgIHdoaWxlIChjdXRFbmQgPCBtYXhDdXRFbmQgJiZcXG4gICAgICAgICAgIG5ld0JvdC5jaGFyQ29kZUF0KG5ld0JvdC5sZW5ndGggLSBjdXRFbmQgLSAxKSA9PSBvbGRCb3QuY2hhckNvZGVBdChvbGRCb3QubGVuZ3RoIC0gY3V0RW5kIC0gMSkpXFxuICAgICAgeyArK2N1dEVuZCB9XFxuXFxuICAgIG5ld1RleHRbbmV3VGV4dC5sZW5ndGggLSAxXSA9IG5ld0JvdC5zbGljZSgwLCBuZXdCb3QubGVuZ3RoIC0gY3V0RW5kKVxcbiAgICBuZXdUZXh0WzBdID0gbmV3VGV4dFswXS5zbGljZShjdXRGcm9udClcXG5cXG4gICAgdmFyIGNoRnJvbSA9IFBvcyhmcm9tTGluZSwgY3V0RnJvbnQpXFxuICAgIHZhciBjaFRvID0gUG9zKHRvTGluZSwgb2xkVGV4dC5sZW5ndGggPyBsc3Qob2xkVGV4dCkubGVuZ3RoIC0gY3V0RW5kIDogMClcXG4gICAgaWYgKG5ld1RleHQubGVuZ3RoID4gMSB8fCBuZXdUZXh0WzBdIHx8IGNtcChjaEZyb20sIGNoVG8pKSB7XFxuICAgICAgcmVwbGFjZVJhbmdlKGNtLmRvYywgbmV3VGV4dCwgY2hGcm9tLCBjaFRvLCBcXFwiK2lucHV0XFxcIilcXG4gICAgICByZXR1cm4gdHJ1ZVxcbiAgICB9XFxuICB9LFxcblxcbiAgZW5zdXJlUG9sbGVkOiBmdW5jdGlvbigpIHtcXG4gICAgdGhpcy5mb3JjZUNvbXBvc2l0aW9uRW5kKClcXG4gIH0sXFxuICByZXNldDogZnVuY3Rpb24oKSB7XFxuICAgIHRoaXMuZm9yY2VDb21wb3NpdGlvbkVuZCgpXFxuICB9LFxcbiAgZm9yY2VDb21wb3NpdGlvbkVuZDogZnVuY3Rpb24oKSB7XFxuICAgIGlmICghdGhpcy5jb21wb3NpbmcgfHwgdGhpcy5jb21wb3NpbmcuaGFuZGxlZCkgeyByZXR1cm4gfVxcbiAgICB0aGlzLmFwcGx5Q29tcG9zaXRpb24odGhpcy5jb21wb3NpbmcpXFxuICAgIHRoaXMuY29tcG9zaW5nLmhhbmRsZWQgPSB0cnVlXFxuICAgIHRoaXMuZGl2LmJsdXIoKVxcbiAgICB0aGlzLmRpdi5mb2N1cygpXFxuICB9LFxcbiAgYXBwbHlDb21wb3NpdGlvbjogZnVuY3Rpb24oY29tcG9zaW5nKSB7XFxuICAgIGlmICh0aGlzLmNtLmlzUmVhZE9ubHkoKSlcXG4gICAgICB7IG9wZXJhdGlvbih0aGlzLmNtLCByZWdDaGFuZ2UpKHRoaXMuY20pIH1cXG4gICAgZWxzZSBpZiAoY29tcG9zaW5nLmRhdGEgJiYgY29tcG9zaW5nLmRhdGEgIT0gY29tcG9zaW5nLnN0YXJ0RGF0YSlcXG4gICAgICB7IG9wZXJhdGlvbih0aGlzLmNtLCBhcHBseVRleHRJbnB1dCkodGhpcy5jbSwgY29tcG9zaW5nLmRhdGEsIDAsIGNvbXBvc2luZy5zZWwpIH1cXG4gIH0sXFxuXFxuICBzZXRVbmVkaXRhYmxlOiBmdW5jdGlvbihub2RlKSB7XFxuICAgIG5vZGUuY29udGVudEVkaXRhYmxlID0gXFxcImZhbHNlXFxcIlxcbiAgfSxcXG5cXG4gIG9uS2V5UHJlc3M6IGZ1bmN0aW9uKGUpIHtcXG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpXFxuICAgIGlmICghdGhpcy5jbS5pc1JlYWRPbmx5KCkpXFxuICAgICAgeyBvcGVyYXRpb24odGhpcy5jbSwgYXBwbHlUZXh0SW5wdXQpKHRoaXMuY20sIFN0cmluZy5mcm9tQ2hhckNvZGUoZS5jaGFyQ29kZSA9PSBudWxsID8gZS5rZXlDb2RlIDogZS5jaGFyQ29kZSksIDApIH1cXG4gIH0sXFxuXFxuICByZWFkT25seUNoYW5nZWQ6IGZ1bmN0aW9uKHZhbCkge1xcbiAgICB0aGlzLmRpdi5jb250ZW50RWRpdGFibGUgPSBTdHJpbmcodmFsICE9IFxcXCJub2N1cnNvclxcXCIpXFxuICB9LFxcblxcbiAgb25Db250ZXh0TWVudTogbm90aGluZyxcXG4gIHJlc2V0UG9zaXRpb246IG5vdGhpbmcsXFxuXFxuICBuZWVkc0NvbnRlbnRBdHRyaWJ1dGU6IHRydWVcXG4gIH0sIENvbnRlbnRFZGl0YWJsZUlucHV0LnByb3RvdHlwZSlcXG5cXG5mdW5jdGlvbiBwb3NUb0RPTShjbSwgcG9zKSB7XFxuICB2YXIgdmlldyA9IGZpbmRWaWV3Rm9yTGluZShjbSwgcG9zLmxpbmUpXFxuICBpZiAoIXZpZXcgfHwgdmlldy5oaWRkZW4pIHsgcmV0dXJuIG51bGwgfVxcbiAgdmFyIGxpbmUgPSBnZXRMaW5lKGNtLmRvYywgcG9zLmxpbmUpXFxuICB2YXIgaW5mbyA9IG1hcEZyb21MaW5lVmlldyh2aWV3LCBsaW5lLCBwb3MubGluZSlcXG5cXG4gIHZhciBvcmRlciA9IGdldE9yZGVyKGxpbmUpLCBzaWRlID0gXFxcImxlZnRcXFwiXFxuICBpZiAob3JkZXIpIHtcXG4gICAgdmFyIHBhcnRQb3MgPSBnZXRCaWRpUGFydEF0KG9yZGVyLCBwb3MuY2gpXFxuICAgIHNpZGUgPSBwYXJ0UG9zICUgMiA/IFxcXCJyaWdodFxcXCIgOiBcXFwibGVmdFxcXCJcXG4gIH1cXG4gIHZhciByZXN1bHQgPSBub2RlQW5kT2Zmc2V0SW5MaW5lTWFwKGluZm8ubWFwLCBwb3MuY2gsIHNpZGUpXFxuICByZXN1bHQub2Zmc2V0ID0gcmVzdWx0LmNvbGxhcHNlID09IFxcXCJyaWdodFxcXCIgPyByZXN1bHQuZW5kIDogcmVzdWx0LnN0YXJ0XFxuICByZXR1cm4gcmVzdWx0XFxufVxcblxcbmZ1bmN0aW9uIGJhZFBvcyhwb3MsIGJhZCkgeyBpZiAoYmFkKSB7IHBvcy5iYWQgPSB0cnVlOyB9IHJldHVybiBwb3MgfVxcblxcbmZ1bmN0aW9uIGRvbVRleHRCZXR3ZWVuKGNtLCBmcm9tLCB0bywgZnJvbUxpbmUsIHRvTGluZSkge1xcbiAgdmFyIHRleHQgPSBcXFwiXFxcIiwgY2xvc2luZyA9IGZhbHNlLCBsaW5lU2VwID0gY20uZG9jLmxpbmVTZXBhcmF0b3IoKVxcbiAgZnVuY3Rpb24gcmVjb2duaXplTWFya2VyKGlkKSB7IHJldHVybiBmdW5jdGlvbiAobWFya2VyKSB7IHJldHVybiBtYXJrZXIuaWQgPT0gaWQ7IH0gfVxcbiAgZnVuY3Rpb24gd2Fsayhub2RlKSB7XFxuICAgIGlmIChub2RlLm5vZGVUeXBlID09IDEpIHtcXG4gICAgICB2YXIgY21UZXh0ID0gbm9kZS5nZXRBdHRyaWJ1dGUoXFxcImNtLXRleHRcXFwiKVxcbiAgICAgIGlmIChjbVRleHQgIT0gbnVsbCkge1xcbiAgICAgICAgaWYgKGNtVGV4dCA9PSBcXFwiXFxcIikgeyBjbVRleHQgPSBub2RlLnRleHRDb250ZW50LnJlcGxhY2UoL1xcXFx1MjAwYi9nLCBcXFwiXFxcIikgfVxcbiAgICAgICAgdGV4dCArPSBjbVRleHRcXG4gICAgICAgIHJldHVyblxcbiAgICAgIH1cXG4gICAgICB2YXIgbWFya2VySUQgPSBub2RlLmdldEF0dHJpYnV0ZShcXFwiY20tbWFya2VyXFxcIiksIHJhbmdlXFxuICAgICAgaWYgKG1hcmtlcklEKSB7XFxuICAgICAgICB2YXIgZm91bmQgPSBjbS5maW5kTWFya3MoUG9zKGZyb21MaW5lLCAwKSwgUG9zKHRvTGluZSArIDEsIDApLCByZWNvZ25pemVNYXJrZXIoK21hcmtlcklEKSlcXG4gICAgICAgIGlmIChmb3VuZC5sZW5ndGggJiYgKHJhbmdlID0gZm91bmRbMF0uZmluZCgpKSlcXG4gICAgICAgICAgeyB0ZXh0ICs9IGdldEJldHdlZW4oY20uZG9jLCByYW5nZS5mcm9tLCByYW5nZS50bykuam9pbihsaW5lU2VwKSB9XFxuICAgICAgICByZXR1cm5cXG4gICAgICB9XFxuICAgICAgaWYgKG5vZGUuZ2V0QXR0cmlidXRlKFxcXCJjb250ZW50ZWRpdGFibGVcXFwiKSA9PSBcXFwiZmFsc2VcXFwiKSB7IHJldHVybiB9XFxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLmNoaWxkTm9kZXMubGVuZ3RoOyBpKyspXFxuICAgICAgICB7IHdhbGsobm9kZS5jaGlsZE5vZGVzW2ldKSB9XFxuICAgICAgaWYgKC9eKHByZXxkaXZ8cCkkL2kudGVzdChub2RlLm5vZGVOYW1lKSlcXG4gICAgICAgIHsgY2xvc2luZyA9IHRydWUgfVxcbiAgICB9IGVsc2UgaWYgKG5vZGUubm9kZVR5cGUgPT0gMykge1xcbiAgICAgIHZhciB2YWwgPSBub2RlLm5vZGVWYWx1ZVxcbiAgICAgIGlmICghdmFsKSB7IHJldHVybiB9XFxuICAgICAgaWYgKGNsb3NpbmcpIHtcXG4gICAgICAgIHRleHQgKz0gbGluZVNlcFxcbiAgICAgICAgY2xvc2luZyA9IGZhbHNlXFxuICAgICAgfVxcbiAgICAgIHRleHQgKz0gdmFsXFxuICAgIH1cXG4gIH1cXG4gIGZvciAoOzspIHtcXG4gICAgd2Fsayhmcm9tKVxcbiAgICBpZiAoZnJvbSA9PSB0bykgeyBicmVhayB9XFxuICAgIGZyb20gPSBmcm9tLm5leHRTaWJsaW5nXFxuICB9XFxuICByZXR1cm4gdGV4dFxcbn1cXG5cXG5mdW5jdGlvbiBkb21Ub1BvcyhjbSwgbm9kZSwgb2Zmc2V0KSB7XFxuICB2YXIgbGluZU5vZGVcXG4gIGlmIChub2RlID09IGNtLmRpc3BsYXkubGluZURpdikge1xcbiAgICBsaW5lTm9kZSA9IGNtLmRpc3BsYXkubGluZURpdi5jaGlsZE5vZGVzW29mZnNldF1cXG4gICAgaWYgKCFsaW5lTm9kZSkgeyByZXR1cm4gYmFkUG9zKGNtLmNsaXBQb3MoUG9zKGNtLmRpc3BsYXkudmlld1RvIC0gMSkpLCB0cnVlKSB9XFxuICAgIG5vZGUgPSBudWxsOyBvZmZzZXQgPSAwXFxuICB9IGVsc2Uge1xcbiAgICBmb3IgKGxpbmVOb2RlID0gbm9kZTs7IGxpbmVOb2RlID0gbGluZU5vZGUucGFyZW50Tm9kZSkge1xcbiAgICAgIGlmICghbGluZU5vZGUgfHwgbGluZU5vZGUgPT0gY20uZGlzcGxheS5saW5lRGl2KSB7IHJldHVybiBudWxsIH1cXG4gICAgICBpZiAobGluZU5vZGUucGFyZW50Tm9kZSAmJiBsaW5lTm9kZS5wYXJlbnROb2RlID09IGNtLmRpc3BsYXkubGluZURpdikgeyBicmVhayB9XFxuICAgIH1cXG4gIH1cXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY20uZGlzcGxheS52aWV3Lmxlbmd0aDsgaSsrKSB7XFxuICAgIHZhciBsaW5lVmlldyA9IGNtLmRpc3BsYXkudmlld1tpXVxcbiAgICBpZiAobGluZVZpZXcubm9kZSA9PSBsaW5lTm9kZSlcXG4gICAgICB7IHJldHVybiBsb2NhdGVOb2RlSW5MaW5lVmlldyhsaW5lVmlldywgbm9kZSwgb2Zmc2V0KSB9XFxuICB9XFxufVxcblxcbmZ1bmN0aW9uIGxvY2F0ZU5vZGVJbkxpbmVWaWV3KGxpbmVWaWV3LCBub2RlLCBvZmZzZXQpIHtcXG4gIHZhciB3cmFwcGVyID0gbGluZVZpZXcudGV4dC5maXJzdENoaWxkLCBiYWQgPSBmYWxzZVxcbiAgaWYgKCFub2RlIHx8ICFjb250YWlucyh3cmFwcGVyLCBub2RlKSkgeyByZXR1cm4gYmFkUG9zKFBvcyhsaW5lTm8obGluZVZpZXcubGluZSksIDApLCB0cnVlKSB9XFxuICBpZiAobm9kZSA9PSB3cmFwcGVyKSB7XFxuICAgIGJhZCA9IHRydWVcXG4gICAgbm9kZSA9IHdyYXBwZXIuY2hpbGROb2Rlc1tvZmZzZXRdXFxuICAgIG9mZnNldCA9IDBcXG4gICAgaWYgKCFub2RlKSB7XFxuICAgICAgdmFyIGxpbmUgPSBsaW5lVmlldy5yZXN0ID8gbHN0KGxpbmVWaWV3LnJlc3QpIDogbGluZVZpZXcubGluZVxcbiAgICAgIHJldHVybiBiYWRQb3MoUG9zKGxpbmVObyhsaW5lKSwgbGluZS50ZXh0Lmxlbmd0aCksIGJhZClcXG4gICAgfVxcbiAgfVxcblxcbiAgdmFyIHRleHROb2RlID0gbm9kZS5ub2RlVHlwZSA9PSAzID8gbm9kZSA6IG51bGwsIHRvcE5vZGUgPSBub2RlXFxuICBpZiAoIXRleHROb2RlICYmIG5vZGUuY2hpbGROb2Rlcy5sZW5ndGggPT0gMSAmJiBub2RlLmZpcnN0Q2hpbGQubm9kZVR5cGUgPT0gMykge1xcbiAgICB0ZXh0Tm9kZSA9IG5vZGUuZmlyc3RDaGlsZFxcbiAgICBpZiAob2Zmc2V0KSB7IG9mZnNldCA9IHRleHROb2RlLm5vZGVWYWx1ZS5sZW5ndGggfVxcbiAgfVxcbiAgd2hpbGUgKHRvcE5vZGUucGFyZW50Tm9kZSAhPSB3cmFwcGVyKSB7IHRvcE5vZGUgPSB0b3BOb2RlLnBhcmVudE5vZGUgfVxcbiAgdmFyIG1lYXN1cmUgPSBsaW5lVmlldy5tZWFzdXJlLCBtYXBzID0gbWVhc3VyZS5tYXBzXFxuXFxuICBmdW5jdGlvbiBmaW5kKHRleHROb2RlLCB0b3BOb2RlLCBvZmZzZXQpIHtcXG4gICAgZm9yICh2YXIgaSA9IC0xOyBpIDwgKG1hcHMgPyBtYXBzLmxlbmd0aCA6IDApOyBpKyspIHtcXG4gICAgICB2YXIgbWFwID0gaSA8IDAgPyBtZWFzdXJlLm1hcCA6IG1hcHNbaV1cXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG1hcC5sZW5ndGg7IGogKz0gMykge1xcbiAgICAgICAgdmFyIGN1ck5vZGUgPSBtYXBbaiArIDJdXFxuICAgICAgICBpZiAoY3VyTm9kZSA9PSB0ZXh0Tm9kZSB8fCBjdXJOb2RlID09IHRvcE5vZGUpIHtcXG4gICAgICAgICAgdmFyIGxpbmUgPSBsaW5lTm8oaSA8IDAgPyBsaW5lVmlldy5saW5lIDogbGluZVZpZXcucmVzdFtpXSlcXG4gICAgICAgICAgdmFyIGNoID0gbWFwW2pdICsgb2Zmc2V0XFxuICAgICAgICAgIGlmIChvZmZzZXQgPCAwIHx8IGN1ck5vZGUgIT0gdGV4dE5vZGUpIHsgY2ggPSBtYXBbaiArIChvZmZzZXQgPyAxIDogMCldIH1cXG4gICAgICAgICAgcmV0dXJuIFBvcyhsaW5lLCBjaClcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIH1cXG4gIH1cXG4gIHZhciBmb3VuZCA9IGZpbmQodGV4dE5vZGUsIHRvcE5vZGUsIG9mZnNldClcXG4gIGlmIChmb3VuZCkgeyByZXR1cm4gYmFkUG9zKGZvdW5kLCBiYWQpIH1cXG5cXG4gIC8vIEZJWE1FIHRoaXMgaXMgYWxsIHJlYWxseSBzaGFreS4gbWlnaHQgaGFuZGxlIHRoZSBmZXcgY2FzZXMgaXQgbmVlZHMgdG8gaGFuZGxlLCBidXQgbGlrZWx5IHRvIGNhdXNlIHByb2JsZW1zXFxuICBmb3IgKHZhciBhZnRlciA9IHRvcE5vZGUubmV4dFNpYmxpbmcsIGRpc3QgPSB0ZXh0Tm9kZSA/IHRleHROb2RlLm5vZGVWYWx1ZS5sZW5ndGggLSBvZmZzZXQgOiAwOyBhZnRlcjsgYWZ0ZXIgPSBhZnRlci5uZXh0U2libGluZykge1xcbiAgICBmb3VuZCA9IGZpbmQoYWZ0ZXIsIGFmdGVyLmZpcnN0Q2hpbGQsIDApXFxuICAgIGlmIChmb3VuZClcXG4gICAgICB7IHJldHVybiBiYWRQb3MoUG9zKGZvdW5kLmxpbmUsIGZvdW5kLmNoIC0gZGlzdCksIGJhZCkgfVxcbiAgICBlbHNlXFxuICAgICAgeyBkaXN0ICs9IGFmdGVyLnRleHRDb250ZW50Lmxlbmd0aCB9XFxuICB9XFxuICBmb3IgKHZhciBiZWZvcmUgPSB0b3BOb2RlLnByZXZpb3VzU2libGluZywgZGlzdCQxID0gb2Zmc2V0OyBiZWZvcmU7IGJlZm9yZSA9IGJlZm9yZS5wcmV2aW91c1NpYmxpbmcpIHtcXG4gICAgZm91bmQgPSBmaW5kKGJlZm9yZSwgYmVmb3JlLmZpcnN0Q2hpbGQsIC0xKVxcbiAgICBpZiAoZm91bmQpXFxuICAgICAgeyByZXR1cm4gYmFkUG9zKFBvcyhmb3VuZC5saW5lLCBmb3VuZC5jaCArIGRpc3QkMSksIGJhZCkgfVxcbiAgICBlbHNlXFxuICAgICAgeyBkaXN0JDEgKz0gYmVmb3JlLnRleHRDb250ZW50Lmxlbmd0aCB9XFxuICB9XFxufVxcblxcbi8vIFRFWFRBUkVBIElOUFVUIFNUWUxFXFxuXFxuZnVuY3Rpb24gVGV4dGFyZWFJbnB1dChjbSkge1xcbiAgdGhpcy5jbSA9IGNtXFxuICAvLyBTZWUgaW5wdXQucG9sbCBhbmQgaW5wdXQucmVzZXRcXG4gIHRoaXMucHJldklucHV0ID0gXFxcIlxcXCJcXG5cXG4gIC8vIEZsYWcgdGhhdCBpbmRpY2F0ZXMgd2hldGhlciB3ZSBleHBlY3QgaW5wdXQgdG8gYXBwZWFyIHJlYWwgc29vblxcbiAgLy8gbm93IChhZnRlciBzb21lIGV2ZW50IGxpa2UgJ2tleXByZXNzJyBvciAnaW5wdXQnKSBhbmQgYXJlXFxuICAvLyBwb2xsaW5nIGludGVuc2l2ZWx5LlxcbiAgdGhpcy5wb2xsaW5nRmFzdCA9IGZhbHNlXFxuICAvLyBTZWxmLXJlc2V0dGluZyB0aW1lb3V0IGZvciB0aGUgcG9sbGVyXFxuICB0aGlzLnBvbGxpbmcgPSBuZXcgRGVsYXllZCgpXFxuICAvLyBUcmFja3Mgd2hlbiBpbnB1dC5yZXNldCBoYXMgcHVudGVkIHRvIGp1c3QgcHV0dGluZyBhIHNob3J0XFxuICAvLyBzdHJpbmcgaW50byB0aGUgdGV4dGFyZWEgaW5zdGVhZCBvZiB0aGUgZnVsbCBzZWxlY3Rpb24uXFxuICB0aGlzLmluYWNjdXJhdGVTZWxlY3Rpb24gPSBmYWxzZVxcbiAgLy8gVXNlZCB0byB3b3JrIGFyb3VuZCBJRSBpc3N1ZSB3aXRoIHNlbGVjdGlvbiBiZWluZyBmb3Jnb3R0ZW4gd2hlbiBmb2N1cyBtb3ZlcyBhd2F5IGZyb20gdGV4dGFyZWFcXG4gIHRoaXMuaGFzU2VsZWN0aW9uID0gZmFsc2VcXG4gIHRoaXMuY29tcG9zaW5nID0gbnVsbFxcbn1cXG5cXG5UZXh0YXJlYUlucHV0LnByb3RvdHlwZSA9IGNvcHlPYmooe1xcbiAgaW5pdDogZnVuY3Rpb24oZGlzcGxheSkge1xcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcXG5cXG4gICAgdmFyIGlucHV0ID0gdGhpcywgY20gPSB0aGlzLmNtXFxuXFxuICAgIC8vIFdyYXBzIGFuZCBoaWRlcyBpbnB1dCB0ZXh0YXJlYVxcbiAgICB2YXIgZGl2ID0gdGhpcy53cmFwcGVyID0gaGlkZGVuVGV4dGFyZWEoKVxcbiAgICAvLyBUaGUgc2VtaWhpZGRlbiB0ZXh0YXJlYSB0aGF0IGlzIGZvY3VzZWQgd2hlbiB0aGUgZWRpdG9yIGlzXFxuICAgIC8vIGZvY3VzZWQsIGFuZCByZWNlaXZlcyBpbnB1dC5cXG4gICAgdmFyIHRlID0gdGhpcy50ZXh0YXJlYSA9IGRpdi5maXJzdENoaWxkXFxuICAgIGRpc3BsYXkud3JhcHBlci5pbnNlcnRCZWZvcmUoZGl2LCBkaXNwbGF5LndyYXBwZXIuZmlyc3RDaGlsZClcXG5cXG4gICAgLy8gTmVlZGVkIHRvIGhpZGUgYmlnIGJsdWUgYmxpbmtpbmcgY3Vyc29yIG9uIE1vYmlsZSBTYWZhcmkgKGRvZXNuJ3Qgc2VlbSB0byB3b3JrIGluIGlPUyA4IGFueW1vcmUpXFxuICAgIGlmIChpb3MpIHsgdGUuc3R5bGUud2lkdGggPSBcXFwiMHB4XFxcIiB9XFxuXFxuICAgIG9uKHRlLCBcXFwiaW5wdXRcXFwiLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgaWYgKGllICYmIGllX3ZlcnNpb24gPj0gOSAmJiB0aGlzJDEuaGFzU2VsZWN0aW9uKSB7IHRoaXMkMS5oYXNTZWxlY3Rpb24gPSBudWxsIH1cXG4gICAgICBpbnB1dC5wb2xsKClcXG4gICAgfSlcXG5cXG4gICAgb24odGUsIFxcXCJwYXN0ZVxcXCIsIGZ1bmN0aW9uIChlKSB7XFxuICAgICAgaWYgKHNpZ25hbERPTUV2ZW50KGNtLCBlKSB8fCBoYW5kbGVQYXN0ZShlLCBjbSkpIHsgcmV0dXJuIH1cXG5cXG4gICAgICBjbS5zdGF0ZS5wYXN0ZUluY29taW5nID0gdHJ1ZVxcbiAgICAgIGlucHV0LmZhc3RQb2xsKClcXG4gICAgfSlcXG5cXG4gICAgZnVuY3Rpb24gcHJlcGFyZUNvcHlDdXQoZSkge1xcbiAgICAgIGlmIChzaWduYWxET01FdmVudChjbSwgZSkpIHsgcmV0dXJuIH1cXG4gICAgICBpZiAoY20uc29tZXRoaW5nU2VsZWN0ZWQoKSkge1xcbiAgICAgICAgc2V0TGFzdENvcGllZCh7bGluZVdpc2U6IGZhbHNlLCB0ZXh0OiBjbS5nZXRTZWxlY3Rpb25zKCl9KVxcbiAgICAgICAgaWYgKGlucHV0LmluYWNjdXJhdGVTZWxlY3Rpb24pIHtcXG4gICAgICAgICAgaW5wdXQucHJldklucHV0ID0gXFxcIlxcXCJcXG4gICAgICAgICAgaW5wdXQuaW5hY2N1cmF0ZVNlbGVjdGlvbiA9IGZhbHNlXFxuICAgICAgICAgIHRlLnZhbHVlID0gbGFzdENvcGllZC50ZXh0LmpvaW4oXFxcIlxcXFxuXFxcIilcXG4gICAgICAgICAgc2VsZWN0SW5wdXQodGUpXFxuICAgICAgICB9XFxuICAgICAgfSBlbHNlIGlmICghY20ub3B0aW9ucy5saW5lV2lzZUNvcHlDdXQpIHtcXG4gICAgICAgIHJldHVyblxcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICB2YXIgcmFuZ2VzID0gY29weWFibGVSYW5nZXMoY20pXFxuICAgICAgICBzZXRMYXN0Q29waWVkKHtsaW5lV2lzZTogdHJ1ZSwgdGV4dDogcmFuZ2VzLnRleHR9KVxcbiAgICAgICAgaWYgKGUudHlwZSA9PSBcXFwiY3V0XFxcIikge1xcbiAgICAgICAgICBjbS5zZXRTZWxlY3Rpb25zKHJhbmdlcy5yYW5nZXMsIG51bGwsIHNlbF9kb250U2Nyb2xsKVxcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgaW5wdXQucHJldklucHV0ID0gXFxcIlxcXCJcXG4gICAgICAgICAgdGUudmFsdWUgPSByYW5nZXMudGV4dC5qb2luKFxcXCJcXFxcblxcXCIpXFxuICAgICAgICAgIHNlbGVjdElucHV0KHRlKVxcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgICBpZiAoZS50eXBlID09IFxcXCJjdXRcXFwiKSB7IGNtLnN0YXRlLmN1dEluY29taW5nID0gdHJ1ZSB9XFxuICAgIH1cXG4gICAgb24odGUsIFxcXCJjdXRcXFwiLCBwcmVwYXJlQ29weUN1dClcXG4gICAgb24odGUsIFxcXCJjb3B5XFxcIiwgcHJlcGFyZUNvcHlDdXQpXFxuXFxuICAgIG9uKGRpc3BsYXkuc2Nyb2xsZXIsIFxcXCJwYXN0ZVxcXCIsIGZ1bmN0aW9uIChlKSB7XFxuICAgICAgaWYgKGV2ZW50SW5XaWRnZXQoZGlzcGxheSwgZSkgfHwgc2lnbmFsRE9NRXZlbnQoY20sIGUpKSB7IHJldHVybiB9XFxuICAgICAgY20uc3RhdGUucGFzdGVJbmNvbWluZyA9IHRydWVcXG4gICAgICBpbnB1dC5mb2N1cygpXFxuICAgIH0pXFxuXFxuICAgIC8vIFByZXZlbnQgbm9ybWFsIHNlbGVjdGlvbiBpbiB0aGUgZWRpdG9yICh3ZSBoYW5kbGUgb3VyIG93bilcXG4gICAgb24oZGlzcGxheS5saW5lU3BhY2UsIFxcXCJzZWxlY3RzdGFydFxcXCIsIGZ1bmN0aW9uIChlKSB7XFxuICAgICAgaWYgKCFldmVudEluV2lkZ2V0KGRpc3BsYXksIGUpKSB7IGVfcHJldmVudERlZmF1bHQoZSkgfVxcbiAgICB9KVxcblxcbiAgICBvbih0ZSwgXFxcImNvbXBvc2l0aW9uc3RhcnRcXFwiLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgdmFyIHN0YXJ0ID0gY20uZ2V0Q3Vyc29yKFxcXCJmcm9tXFxcIilcXG4gICAgICBpZiAoaW5wdXQuY29tcG9zaW5nKSB7IGlucHV0LmNvbXBvc2luZy5yYW5nZS5jbGVhcigpIH1cXG4gICAgICBpbnB1dC5jb21wb3NpbmcgPSB7XFxuICAgICAgICBzdGFydDogc3RhcnQsXFxuICAgICAgICByYW5nZTogY20ubWFya1RleHQoc3RhcnQsIGNtLmdldEN1cnNvcihcXFwidG9cXFwiKSwge2NsYXNzTmFtZTogXFxcIkNvZGVNaXJyb3ItY29tcG9zaW5nXFxcIn0pXFxuICAgICAgfVxcbiAgICB9KVxcbiAgICBvbih0ZSwgXFxcImNvbXBvc2l0aW9uZW5kXFxcIiwgZnVuY3Rpb24gKCkge1xcbiAgICAgIGlmIChpbnB1dC5jb21wb3NpbmcpIHtcXG4gICAgICAgIGlucHV0LnBvbGwoKVxcbiAgICAgICAgaW5wdXQuY29tcG9zaW5nLnJhbmdlLmNsZWFyKClcXG4gICAgICAgIGlucHV0LmNvbXBvc2luZyA9IG51bGxcXG4gICAgICB9XFxuICAgIH0pXFxuICB9LFxcblxcbiAgcHJlcGFyZVNlbGVjdGlvbjogZnVuY3Rpb24oKSB7XFxuICAgIC8vIFJlZHJhdyB0aGUgc2VsZWN0aW9uIGFuZC9vciBjdXJzb3JcXG4gICAgdmFyIGNtID0gdGhpcy5jbSwgZGlzcGxheSA9IGNtLmRpc3BsYXksIGRvYyA9IGNtLmRvY1xcbiAgICB2YXIgcmVzdWx0ID0gcHJlcGFyZVNlbGVjdGlvbihjbSlcXG5cXG4gICAgLy8gTW92ZSB0aGUgaGlkZGVuIHRleHRhcmVhIG5lYXIgdGhlIGN1cnNvciB0byBwcmV2ZW50IHNjcm9sbGluZyBhcnRpZmFjdHNcXG4gICAgaWYgKGNtLm9wdGlvbnMubW92ZUlucHV0V2l0aEN1cnNvcikge1xcbiAgICAgIHZhciBoZWFkUG9zID0gY3Vyc29yQ29vcmRzKGNtLCBkb2Muc2VsLnByaW1hcnkoKS5oZWFkLCBcXFwiZGl2XFxcIilcXG4gICAgICB2YXIgd3JhcE9mZiA9IGRpc3BsYXkud3JhcHBlci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgbGluZU9mZiA9IGRpc3BsYXkubGluZURpdi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxcbiAgICAgIHJlc3VsdC50ZVRvcCA9IE1hdGgubWF4KDAsIE1hdGgubWluKGRpc3BsYXkud3JhcHBlci5jbGllbnRIZWlnaHQgLSAxMCxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWFkUG9zLnRvcCArIGxpbmVPZmYudG9wIC0gd3JhcE9mZi50b3ApKVxcbiAgICAgIHJlc3VsdC50ZUxlZnQgPSBNYXRoLm1heCgwLCBNYXRoLm1pbihkaXNwbGF5LndyYXBwZXIuY2xpZW50V2lkdGggLSAxMCxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVhZFBvcy5sZWZ0ICsgbGluZU9mZi5sZWZ0IC0gd3JhcE9mZi5sZWZ0KSlcXG4gICAgfVxcblxcbiAgICByZXR1cm4gcmVzdWx0XFxuICB9LFxcblxcbiAgc2hvd1NlbGVjdGlvbjogZnVuY3Rpb24oZHJhd24pIHtcXG4gICAgdmFyIGNtID0gdGhpcy5jbSwgZGlzcGxheSA9IGNtLmRpc3BsYXlcXG4gICAgcmVtb3ZlQ2hpbGRyZW5BbmRBZGQoZGlzcGxheS5jdXJzb3JEaXYsIGRyYXduLmN1cnNvcnMpXFxuICAgIHJlbW92ZUNoaWxkcmVuQW5kQWRkKGRpc3BsYXkuc2VsZWN0aW9uRGl2LCBkcmF3bi5zZWxlY3Rpb24pXFxuICAgIGlmIChkcmF3bi50ZVRvcCAhPSBudWxsKSB7XFxuICAgICAgdGhpcy53cmFwcGVyLnN0eWxlLnRvcCA9IGRyYXduLnRlVG9wICsgXFxcInB4XFxcIlxcbiAgICAgIHRoaXMud3JhcHBlci5zdHlsZS5sZWZ0ID0gZHJhd24udGVMZWZ0ICsgXFxcInB4XFxcIlxcbiAgICB9XFxuICB9LFxcblxcbiAgLy8gUmVzZXQgdGhlIGlucHV0IHRvIGNvcnJlc3BvbmQgdG8gdGhlIHNlbGVjdGlvbiAob3IgdG8gYmUgZW1wdHksXFxuICAvLyB3aGVuIG5vdCB0eXBpbmcgYW5kIG5vdGhpbmcgaXMgc2VsZWN0ZWQpXFxuICByZXNldDogZnVuY3Rpb24odHlwaW5nKSB7XFxuICAgIGlmICh0aGlzLmNvbnRleHRNZW51UGVuZGluZykgeyByZXR1cm4gfVxcbiAgICB2YXIgbWluaW1hbCwgc2VsZWN0ZWQsIGNtID0gdGhpcy5jbSwgZG9jID0gY20uZG9jXFxuICAgIGlmIChjbS5zb21ldGhpbmdTZWxlY3RlZCgpKSB7XFxuICAgICAgdGhpcy5wcmV2SW5wdXQgPSBcXFwiXFxcIlxcbiAgICAgIHZhciByYW5nZSA9IGRvYy5zZWwucHJpbWFyeSgpXFxuICAgICAgbWluaW1hbCA9IGhhc0NvcHlFdmVudCAmJlxcbiAgICAgICAgKHJhbmdlLnRvKCkubGluZSAtIHJhbmdlLmZyb20oKS5saW5lID4gMTAwIHx8IChzZWxlY3RlZCA9IGNtLmdldFNlbGVjdGlvbigpKS5sZW5ndGggPiAxMDAwKVxcbiAgICAgIHZhciBjb250ZW50ID0gbWluaW1hbCA/IFxcXCItXFxcIiA6IHNlbGVjdGVkIHx8IGNtLmdldFNlbGVjdGlvbigpXFxuICAgICAgdGhpcy50ZXh0YXJlYS52YWx1ZSA9IGNvbnRlbnRcXG4gICAgICBpZiAoY20uc3RhdGUuZm9jdXNlZCkgeyBzZWxlY3RJbnB1dCh0aGlzLnRleHRhcmVhKSB9XFxuICAgICAgaWYgKGllICYmIGllX3ZlcnNpb24gPj0gOSkgeyB0aGlzLmhhc1NlbGVjdGlvbiA9IGNvbnRlbnQgfVxcbiAgICB9IGVsc2UgaWYgKCF0eXBpbmcpIHtcXG4gICAgICB0aGlzLnByZXZJbnB1dCA9IHRoaXMudGV4dGFyZWEudmFsdWUgPSBcXFwiXFxcIlxcbiAgICAgIGlmIChpZSAmJiBpZV92ZXJzaW9uID49IDkpIHsgdGhpcy5oYXNTZWxlY3Rpb24gPSBudWxsIH1cXG4gICAgfVxcbiAgICB0aGlzLmluYWNjdXJhdGVTZWxlY3Rpb24gPSBtaW5pbWFsXFxuICB9LFxcblxcbiAgZ2V0RmllbGQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy50ZXh0YXJlYSB9LFxcblxcbiAgc3VwcG9ydHNUb3VjaDogZnVuY3Rpb24oKSB7IHJldHVybiBmYWxzZSB9LFxcblxcbiAgZm9jdXM6IGZ1bmN0aW9uKCkge1xcbiAgICBpZiAodGhpcy5jbS5vcHRpb25zLnJlYWRPbmx5ICE9IFxcXCJub2N1cnNvclxcXCIgJiYgKCFtb2JpbGUgfHwgYWN0aXZlRWx0KCkgIT0gdGhpcy50ZXh0YXJlYSkpIHtcXG4gICAgICB0cnkgeyB0aGlzLnRleHRhcmVhLmZvY3VzKCkgfVxcbiAgICAgIGNhdGNoIChlKSB7fSAvLyBJRTggd2lsbCB0aHJvdyBpZiB0aGUgdGV4dGFyZWEgaXMgZGlzcGxheTogbm9uZSBvciBub3QgaW4gRE9NXFxuICAgIH1cXG4gIH0sXFxuXFxuICBibHVyOiBmdW5jdGlvbigpIHsgdGhpcy50ZXh0YXJlYS5ibHVyKCkgfSxcXG5cXG4gIHJlc2V0UG9zaXRpb246IGZ1bmN0aW9uKCkge1xcbiAgICB0aGlzLndyYXBwZXIuc3R5bGUudG9wID0gdGhpcy53cmFwcGVyLnN0eWxlLmxlZnQgPSAwXFxuICB9LFxcblxcbiAgcmVjZWl2ZWRGb2N1czogZnVuY3Rpb24oKSB7IHRoaXMuc2xvd1BvbGwoKSB9LFxcblxcbiAgLy8gUG9sbCBmb3IgaW5wdXQgY2hhbmdlcywgdXNpbmcgdGhlIG5vcm1hbCByYXRlIG9mIHBvbGxpbmcuIFRoaXNcXG4gIC8vIHJ1bnMgYXMgbG9uZyBhcyB0aGUgZWRpdG9yIGlzIGZvY3VzZWQuXFxuICBzbG93UG9sbDogZnVuY3Rpb24oKSB7XFxuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xcblxcbiAgICBpZiAodGhpcy5wb2xsaW5nRmFzdCkgeyByZXR1cm4gfVxcbiAgICB0aGlzLnBvbGxpbmcuc2V0KHRoaXMuY20ub3B0aW9ucy5wb2xsSW50ZXJ2YWwsIGZ1bmN0aW9uICgpIHtcXG4gICAgICB0aGlzJDEucG9sbCgpXFxuICAgICAgaWYgKHRoaXMkMS5jbS5zdGF0ZS5mb2N1c2VkKSB7IHRoaXMkMS5zbG93UG9sbCgpIH1cXG4gICAgfSlcXG4gIH0sXFxuXFxuICAvLyBXaGVuIGFuIGV2ZW50IGhhcyBqdXN0IGNvbWUgaW4gdGhhdCBpcyBsaWtlbHkgdG8gYWRkIG9yIGNoYW5nZVxcbiAgLy8gc29tZXRoaW5nIGluIHRoZSBpbnB1dCB0ZXh0YXJlYSwgd2UgcG9sbCBmYXN0ZXIsIHRvIGVuc3VyZSB0aGF0XFxuICAvLyB0aGUgY2hhbmdlIGFwcGVhcnMgb24gdGhlIHNjcmVlbiBxdWlja2x5LlxcbiAgZmFzdFBvbGw6IGZ1bmN0aW9uKCkge1xcbiAgICB2YXIgbWlzc2VkID0gZmFsc2UsIGlucHV0ID0gdGhpc1xcbiAgICBpbnB1dC5wb2xsaW5nRmFzdCA9IHRydWVcXG4gICAgZnVuY3Rpb24gcCgpIHtcXG4gICAgICB2YXIgY2hhbmdlZCA9IGlucHV0LnBvbGwoKVxcbiAgICAgIGlmICghY2hhbmdlZCAmJiAhbWlzc2VkKSB7bWlzc2VkID0gdHJ1ZTsgaW5wdXQucG9sbGluZy5zZXQoNjAsIHApfVxcbiAgICAgIGVsc2Uge2lucHV0LnBvbGxpbmdGYXN0ID0gZmFsc2U7IGlucHV0LnNsb3dQb2xsKCl9XFxuICAgIH1cXG4gICAgaW5wdXQucG9sbGluZy5zZXQoMjAsIHApXFxuICB9LFxcblxcbiAgLy8gUmVhZCBpbnB1dCBmcm9tIHRoZSB0ZXh0YXJlYSwgYW5kIHVwZGF0ZSB0aGUgZG9jdW1lbnQgdG8gbWF0Y2guXFxuICAvLyBXaGVuIHNvbWV0aGluZyBpcyBzZWxlY3RlZCwgaXQgaXMgcHJlc2VudCBpbiB0aGUgdGV4dGFyZWEsIGFuZFxcbiAgLy8gc2VsZWN0ZWQgKHVubGVzcyBpdCBpcyBodWdlLCBpbiB3aGljaCBjYXNlIGEgcGxhY2Vob2xkZXIgaXNcXG4gIC8vIHVzZWQpLiBXaGVuIG5vdGhpbmcgaXMgc2VsZWN0ZWQsIHRoZSBjdXJzb3Igc2l0cyBhZnRlciBwcmV2aW91c2x5XFxuICAvLyBzZWVuIHRleHQgKGNhbiBiZSBlbXB0eSksIHdoaWNoIGlzIHN0b3JlZCBpbiBwcmV2SW5wdXQgKHdlIG11c3RcXG4gIC8vIG5vdCByZXNldCB0aGUgdGV4dGFyZWEgd2hlbiB0eXBpbmcsIGJlY2F1c2UgdGhhdCBicmVha3MgSU1FKS5cXG4gIHBvbGw6IGZ1bmN0aW9uKCkge1xcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcXG5cXG4gICAgdmFyIGNtID0gdGhpcy5jbSwgaW5wdXQgPSB0aGlzLnRleHRhcmVhLCBwcmV2SW5wdXQgPSB0aGlzLnByZXZJbnB1dFxcbiAgICAvLyBTaW5jZSB0aGlzIGlzIGNhbGxlZCBhICpsb3QqLCB0cnkgdG8gYmFpbCBvdXQgYXMgY2hlYXBseSBhc1xcbiAgICAvLyBwb3NzaWJsZSB3aGVuIGl0IGlzIGNsZWFyIHRoYXQgbm90aGluZyBoYXBwZW5lZC4gaGFzU2VsZWN0aW9uXFxuICAgIC8vIHdpbGwgYmUgdGhlIGNhc2Ugd2hlbiB0aGVyZSBpcyBhIGxvdCBvZiB0ZXh0IGluIHRoZSB0ZXh0YXJlYSxcXG4gICAgLy8gaW4gd2hpY2ggY2FzZSByZWFkaW5nIGl0cyB2YWx1ZSB3b3VsZCBiZSBleHBlbnNpdmUuXFxuICAgIGlmICh0aGlzLmNvbnRleHRNZW51UGVuZGluZyB8fCAhY20uc3RhdGUuZm9jdXNlZCB8fFxcbiAgICAgICAgKGhhc1NlbGVjdGlvbihpbnB1dCkgJiYgIXByZXZJbnB1dCAmJiAhdGhpcy5jb21wb3NpbmcpIHx8XFxuICAgICAgICBjbS5pc1JlYWRPbmx5KCkgfHwgY20ub3B0aW9ucy5kaXNhYmxlSW5wdXQgfHwgY20uc3RhdGUua2V5U2VxKVxcbiAgICAgIHsgcmV0dXJuIGZhbHNlIH1cXG5cXG4gICAgdmFyIHRleHQgPSBpbnB1dC52YWx1ZVxcbiAgICAvLyBJZiBub3RoaW5nIGNoYW5nZWQsIGJhaWwuXFxuICAgIGlmICh0ZXh0ID09IHByZXZJbnB1dCAmJiAhY20uc29tZXRoaW5nU2VsZWN0ZWQoKSkgeyByZXR1cm4gZmFsc2UgfVxcbiAgICAvLyBXb3JrIGFyb3VuZCBub25zZW5zaWNhbCBzZWxlY3Rpb24gcmVzZXR0aW5nIGluIElFOS8xMCwgYW5kXFxuICAgIC8vIGluZXhwbGljYWJsZSBhcHBlYXJhbmNlIG9mIHByaXZhdGUgYXJlYSB1bmljb2RlIGNoYXJhY3RlcnMgb25cXG4gICAgLy8gc29tZSBrZXkgY29tYm9zIGluIE1hYyAoIzI2ODkpLlxcbiAgICBpZiAoaWUgJiYgaWVfdmVyc2lvbiA+PSA5ICYmIHRoaXMuaGFzU2VsZWN0aW9uID09PSB0ZXh0IHx8XFxuICAgICAgICBtYWMgJiYgL1tcXFxcdWY3MDAtXFxcXHVmN2ZmXS8udGVzdCh0ZXh0KSkge1xcbiAgICAgIGNtLmRpc3BsYXkuaW5wdXQucmVzZXQoKVxcbiAgICAgIHJldHVybiBmYWxzZVxcbiAgICB9XFxuXFxuICAgIGlmIChjbS5kb2Muc2VsID09IGNtLmRpc3BsYXkuc2VsRm9yQ29udGV4dE1lbnUpIHtcXG4gICAgICB2YXIgZmlyc3QgPSB0ZXh0LmNoYXJDb2RlQXQoMClcXG4gICAgICBpZiAoZmlyc3QgPT0gMHgyMDBiICYmICFwcmV2SW5wdXQpIHsgcHJldklucHV0ID0gXFxcIlxcXFx1MjAwYlxcXCIgfVxcbiAgICAgIGlmIChmaXJzdCA9PSAweDIxZGEpIHsgdGhpcy5yZXNldCgpOyByZXR1cm4gdGhpcy5jbS5leGVjQ29tbWFuZChcXFwidW5kb1xcXCIpIH1cXG4gICAgfVxcbiAgICAvLyBGaW5kIHRoZSBwYXJ0IG9mIHRoZSBpbnB1dCB0aGF0IGlzIGFjdHVhbGx5IG5ld1xcbiAgICB2YXIgc2FtZSA9IDAsIGwgPSBNYXRoLm1pbihwcmV2SW5wdXQubGVuZ3RoLCB0ZXh0Lmxlbmd0aClcXG4gICAgd2hpbGUgKHNhbWUgPCBsICYmIHByZXZJbnB1dC5jaGFyQ29kZUF0KHNhbWUpID09IHRleHQuY2hhckNvZGVBdChzYW1lKSkgeyArK3NhbWUgfVxcblxcbiAgICBydW5Jbk9wKGNtLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgYXBwbHlUZXh0SW5wdXQoY20sIHRleHQuc2xpY2Uoc2FtZSksIHByZXZJbnB1dC5sZW5ndGggLSBzYW1lLFxcbiAgICAgICAgICAgICAgICAgICAgIG51bGwsIHRoaXMkMS5jb21wb3NpbmcgPyBcXFwiKmNvbXBvc2VcXFwiIDogbnVsbClcXG5cXG4gICAgICAvLyBEb24ndCBsZWF2ZSBsb25nIHRleHQgaW4gdGhlIHRleHRhcmVhLCBzaW5jZSBpdCBtYWtlcyBmdXJ0aGVyIHBvbGxpbmcgc2xvd1xcbiAgICAgIGlmICh0ZXh0Lmxlbmd0aCA+IDEwMDAgfHwgdGV4dC5pbmRleE9mKFxcXCJcXFxcblxcXCIpID4gLTEpIHsgaW5wdXQudmFsdWUgPSB0aGlzJDEucHJldklucHV0ID0gXFxcIlxcXCIgfVxcbiAgICAgIGVsc2UgeyB0aGlzJDEucHJldklucHV0ID0gdGV4dCB9XFxuXFxuICAgICAgaWYgKHRoaXMkMS5jb21wb3NpbmcpIHtcXG4gICAgICAgIHRoaXMkMS5jb21wb3NpbmcucmFuZ2UuY2xlYXIoKVxcbiAgICAgICAgdGhpcyQxLmNvbXBvc2luZy5yYW5nZSA9IGNtLm1hcmtUZXh0KHRoaXMkMS5jb21wb3Npbmcuc3RhcnQsIGNtLmdldEN1cnNvcihcXFwidG9cXFwiKSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge2NsYXNzTmFtZTogXFxcIkNvZGVNaXJyb3ItY29tcG9zaW5nXFxcIn0pXFxuICAgICAgfVxcbiAgICB9KVxcbiAgICByZXR1cm4gdHJ1ZVxcbiAgfSxcXG5cXG4gIGVuc3VyZVBvbGxlZDogZnVuY3Rpb24oKSB7XFxuICAgIGlmICh0aGlzLnBvbGxpbmdGYXN0ICYmIHRoaXMucG9sbCgpKSB7IHRoaXMucG9sbGluZ0Zhc3QgPSBmYWxzZSB9XFxuICB9LFxcblxcbiAgb25LZXlQcmVzczogZnVuY3Rpb24oKSB7XFxuICAgIGlmIChpZSAmJiBpZV92ZXJzaW9uID49IDkpIHsgdGhpcy5oYXNTZWxlY3Rpb24gPSBudWxsIH1cXG4gICAgdGhpcy5mYXN0UG9sbCgpXFxuICB9LFxcblxcbiAgb25Db250ZXh0TWVudTogZnVuY3Rpb24oZSkge1xcbiAgICB2YXIgaW5wdXQgPSB0aGlzLCBjbSA9IGlucHV0LmNtLCBkaXNwbGF5ID0gY20uZGlzcGxheSwgdGUgPSBpbnB1dC50ZXh0YXJlYVxcbiAgICB2YXIgcG9zID0gcG9zRnJvbU1vdXNlKGNtLCBlKSwgc2Nyb2xsUG9zID0gZGlzcGxheS5zY3JvbGxlci5zY3JvbGxUb3BcXG4gICAgaWYgKCFwb3MgfHwgcHJlc3RvKSB7IHJldHVybiB9IC8vIE9wZXJhIGlzIGRpZmZpY3VsdC5cXG5cXG4gICAgLy8gUmVzZXQgdGhlIGN1cnJlbnQgdGV4dCBzZWxlY3Rpb24gb25seSBpZiB0aGUgY2xpY2sgaXMgZG9uZSBvdXRzaWRlIG9mIHRoZSBzZWxlY3Rpb25cXG4gICAgLy8gYW5kICdyZXNldFNlbGVjdGlvbk9uQ29udGV4dE1lbnUnIG9wdGlvbiBpcyB0cnVlLlxcbiAgICB2YXIgcmVzZXQgPSBjbS5vcHRpb25zLnJlc2V0U2VsZWN0aW9uT25Db250ZXh0TWVudVxcbiAgICBpZiAocmVzZXQgJiYgY20uZG9jLnNlbC5jb250YWlucyhwb3MpID09IC0xKVxcbiAgICAgIHsgb3BlcmF0aW9uKGNtLCBzZXRTZWxlY3Rpb24pKGNtLmRvYywgc2ltcGxlU2VsZWN0aW9uKHBvcyksIHNlbF9kb250U2Nyb2xsKSB9XFxuXFxuICAgIHZhciBvbGRDU1MgPSB0ZS5zdHlsZS5jc3NUZXh0LCBvbGRXcmFwcGVyQ1NTID0gaW5wdXQud3JhcHBlci5zdHlsZS5jc3NUZXh0XFxuICAgIGlucHV0LndyYXBwZXIuc3R5bGUuY3NzVGV4dCA9IFxcXCJwb3NpdGlvbjogYWJzb2x1dGVcXFwiXFxuICAgIHZhciB3cmFwcGVyQm94ID0gaW5wdXQud3JhcHBlci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxcbiAgICB0ZS5zdHlsZS5jc3NUZXh0ID0gXFxcInBvc2l0aW9uOiBhYnNvbHV0ZTsgd2lkdGg6IDMwcHg7IGhlaWdodDogMzBweDtcXFxcbiAgICAgIHRvcDogXFxcIiArIChlLmNsaWVudFkgLSB3cmFwcGVyQm94LnRvcCAtIDUpICsgXFxcInB4OyBsZWZ0OiBcXFwiICsgKGUuY2xpZW50WCAtIHdyYXBwZXJCb3gubGVmdCAtIDUpICsgXFxcInB4O1xcXFxuICAgICAgei1pbmRleDogMTAwMDsgYmFja2dyb3VuZDogXFxcIiArIChpZSA/IFxcXCJyZ2JhKDI1NSwgMjU1LCAyNTUsIC4wNSlcXFwiIDogXFxcInRyYW5zcGFyZW50XFxcIikgKyBcXFwiO1xcXFxuICAgICAgb3V0bGluZTogbm9uZTsgYm9yZGVyLXdpZHRoOiAwOyBvdXRsaW5lOiBub25lOyBvdmVyZmxvdzogaGlkZGVuOyBvcGFjaXR5OiAuMDU7IGZpbHRlcjogYWxwaGEob3BhY2l0eT01KTtcXFwiXFxuICAgIHZhciBvbGRTY3JvbGxZXFxuICAgIGlmICh3ZWJraXQpIHsgb2xkU2Nyb2xsWSA9IHdpbmRvdy5zY3JvbGxZIH0gLy8gV29yayBhcm91bmQgQ2hyb21lIGlzc3VlICgjMjcxMilcXG4gICAgZGlzcGxheS5pbnB1dC5mb2N1cygpXFxuICAgIGlmICh3ZWJraXQpIHsgd2luZG93LnNjcm9sbFRvKG51bGwsIG9sZFNjcm9sbFkpIH1cXG4gICAgZGlzcGxheS5pbnB1dC5yZXNldCgpXFxuICAgIC8vIEFkZHMgXFxcIlNlbGVjdCBhbGxcXFwiIHRvIGNvbnRleHQgbWVudSBpbiBGRlxcbiAgICBpZiAoIWNtLnNvbWV0aGluZ1NlbGVjdGVkKCkpIHsgdGUudmFsdWUgPSBpbnB1dC5wcmV2SW5wdXQgPSBcXFwiIFxcXCIgfVxcbiAgICBpbnB1dC5jb250ZXh0TWVudVBlbmRpbmcgPSB0cnVlXFxuICAgIGRpc3BsYXkuc2VsRm9yQ29udGV4dE1lbnUgPSBjbS5kb2Muc2VsXFxuICAgIGNsZWFyVGltZW91dChkaXNwbGF5LmRldGVjdGluZ1NlbGVjdEFsbClcXG5cXG4gICAgLy8gU2VsZWN0LWFsbCB3aWxsIGJlIGdyZXllZCBvdXQgaWYgdGhlcmUncyBub3RoaW5nIHRvIHNlbGVjdCwgc29cXG4gICAgLy8gdGhpcyBhZGRzIGEgemVyby13aWR0aCBzcGFjZSBzbyB0aGF0IHdlIGNhbiBsYXRlciBjaGVjayB3aGV0aGVyXFxuICAgIC8vIGl0IGdvdCBzZWxlY3RlZC5cXG4gICAgZnVuY3Rpb24gcHJlcGFyZVNlbGVjdEFsbEhhY2soKSB7XFxuICAgICAgaWYgKHRlLnNlbGVjdGlvblN0YXJ0ICE9IG51bGwpIHtcXG4gICAgICAgIHZhciBzZWxlY3RlZCA9IGNtLnNvbWV0aGluZ1NlbGVjdGVkKClcXG4gICAgICAgIHZhciBleHR2YWwgPSBcXFwiXFxcXHUyMDBiXFxcIiArIChzZWxlY3RlZCA/IHRlLnZhbHVlIDogXFxcIlxcXCIpXFxuICAgICAgICB0ZS52YWx1ZSA9IFxcXCJcXFxcdTIxZGFcXFwiIC8vIFVzZWQgdG8gY2F0Y2ggY29udGV4dC1tZW51IHVuZG9cXG4gICAgICAgIHRlLnZhbHVlID0gZXh0dmFsXFxuICAgICAgICBpbnB1dC5wcmV2SW5wdXQgPSBzZWxlY3RlZCA/IFxcXCJcXFwiIDogXFxcIlxcXFx1MjAwYlxcXCJcXG4gICAgICAgIHRlLnNlbGVjdGlvblN0YXJ0ID0gMTsgdGUuc2VsZWN0aW9uRW5kID0gZXh0dmFsLmxlbmd0aFxcbiAgICAgICAgLy8gUmUtc2V0IHRoaXMsIGluIGNhc2Ugc29tZSBvdGhlciBoYW5kbGVyIHRvdWNoZWQgdGhlXFxuICAgICAgICAvLyBzZWxlY3Rpb24gaW4gdGhlIG1lYW50aW1lLlxcbiAgICAgICAgZGlzcGxheS5zZWxGb3JDb250ZXh0TWVudSA9IGNtLmRvYy5zZWxcXG4gICAgICB9XFxuICAgIH1cXG4gICAgZnVuY3Rpb24gcmVoaWRlKCkge1xcbiAgICAgIGlucHV0LmNvbnRleHRNZW51UGVuZGluZyA9IGZhbHNlXFxuICAgICAgaW5wdXQud3JhcHBlci5zdHlsZS5jc3NUZXh0ID0gb2xkV3JhcHBlckNTU1xcbiAgICAgIHRlLnN0eWxlLmNzc1RleHQgPSBvbGRDU1NcXG4gICAgICBpZiAoaWUgJiYgaWVfdmVyc2lvbiA8IDkpIHsgZGlzcGxheS5zY3JvbGxiYXJzLnNldFNjcm9sbFRvcChkaXNwbGF5LnNjcm9sbGVyLnNjcm9sbFRvcCA9IHNjcm9sbFBvcykgfVxcblxcbiAgICAgIC8vIFRyeSB0byBkZXRlY3QgdGhlIHVzZXIgY2hvb3Npbmcgc2VsZWN0LWFsbFxcbiAgICAgIGlmICh0ZS5zZWxlY3Rpb25TdGFydCAhPSBudWxsKSB7XFxuICAgICAgICBpZiAoIWllIHx8IChpZSAmJiBpZV92ZXJzaW9uIDwgOSkpIHsgcHJlcGFyZVNlbGVjdEFsbEhhY2soKSB9XFxuICAgICAgICB2YXIgaSA9IDAsIHBvbGwgPSBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgIGlmIChkaXNwbGF5LnNlbEZvckNvbnRleHRNZW51ID09IGNtLmRvYy5zZWwgJiYgdGUuc2VsZWN0aW9uU3RhcnQgPT0gMCAmJlxcbiAgICAgICAgICAgICAgdGUuc2VsZWN0aW9uRW5kID4gMCAmJiBpbnB1dC5wcmV2SW5wdXQgPT0gXFxcIlxcXFx1MjAwYlxcXCIpXFxuICAgICAgICAgICAgeyBvcGVyYXRpb24oY20sIHNlbGVjdEFsbCkoY20pIH1cXG4gICAgICAgICAgZWxzZSBpZiAoaSsrIDwgMTApIHsgZGlzcGxheS5kZXRlY3RpbmdTZWxlY3RBbGwgPSBzZXRUaW1lb3V0KHBvbGwsIDUwMCkgfVxcbiAgICAgICAgICBlbHNlIHsgZGlzcGxheS5pbnB1dC5yZXNldCgpIH1cXG4gICAgICAgIH1cXG4gICAgICAgIGRpc3BsYXkuZGV0ZWN0aW5nU2VsZWN0QWxsID0gc2V0VGltZW91dChwb2xsLCAyMDApXFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIGlmIChpZSAmJiBpZV92ZXJzaW9uID49IDkpIHsgcHJlcGFyZVNlbGVjdEFsbEhhY2soKSB9XFxuICAgIGlmIChjYXB0dXJlUmlnaHRDbGljaykge1xcbiAgICAgIGVfc3RvcChlKVxcbiAgICAgIHZhciBtb3VzZXVwID0gZnVuY3Rpb24gKCkge1xcbiAgICAgICAgb2ZmKHdpbmRvdywgXFxcIm1vdXNldXBcXFwiLCBtb3VzZXVwKVxcbiAgICAgICAgc2V0VGltZW91dChyZWhpZGUsIDIwKVxcbiAgICAgIH1cXG4gICAgICBvbih3aW5kb3csIFxcXCJtb3VzZXVwXFxcIiwgbW91c2V1cClcXG4gICAgfSBlbHNlIHtcXG4gICAgICBzZXRUaW1lb3V0KHJlaGlkZSwgNTApXFxuICAgIH1cXG4gIH0sXFxuXFxuICByZWFkT25seUNoYW5nZWQ6IGZ1bmN0aW9uKHZhbCkge1xcbiAgICBpZiAoIXZhbCkgeyB0aGlzLnJlc2V0KCkgfVxcbiAgfSxcXG5cXG4gIHNldFVuZWRpdGFibGU6IG5vdGhpbmcsXFxuXFxuICBuZWVkc0NvbnRlbnRBdHRyaWJ1dGU6IGZhbHNlXFxufSwgVGV4dGFyZWFJbnB1dC5wcm90b3R5cGUpXFxuXFxuZnVuY3Rpb24gZnJvbVRleHRBcmVhKHRleHRhcmVhLCBvcHRpb25zKSB7XFxuICBvcHRpb25zID0gb3B0aW9ucyA/IGNvcHlPYmoob3B0aW9ucykgOiB7fVxcbiAgb3B0aW9ucy52YWx1ZSA9IHRleHRhcmVhLnZhbHVlXFxuICBpZiAoIW9wdGlvbnMudGFiaW5kZXggJiYgdGV4dGFyZWEudGFiSW5kZXgpXFxuICAgIHsgb3B0aW9ucy50YWJpbmRleCA9IHRleHRhcmVhLnRhYkluZGV4IH1cXG4gIGlmICghb3B0aW9ucy5wbGFjZWhvbGRlciAmJiB0ZXh0YXJlYS5wbGFjZWhvbGRlcilcXG4gICAgeyBvcHRpb25zLnBsYWNlaG9sZGVyID0gdGV4dGFyZWEucGxhY2Vob2xkZXIgfVxcbiAgLy8gU2V0IGF1dG9mb2N1cyB0byB0cnVlIGlmIHRoaXMgdGV4dGFyZWEgaXMgZm9jdXNlZCwgb3IgaWYgaXQgaGFzXFxuICAvLyBhdXRvZm9jdXMgYW5kIG5vIG90aGVyIGVsZW1lbnQgaXMgZm9jdXNlZC5cXG4gIGlmIChvcHRpb25zLmF1dG9mb2N1cyA9PSBudWxsKSB7XFxuICAgIHZhciBoYXNGb2N1cyA9IGFjdGl2ZUVsdCgpXFxuICAgIG9wdGlvbnMuYXV0b2ZvY3VzID0gaGFzRm9jdXMgPT0gdGV4dGFyZWEgfHxcXG4gICAgICB0ZXh0YXJlYS5nZXRBdHRyaWJ1dGUoXFxcImF1dG9mb2N1c1xcXCIpICE9IG51bGwgJiYgaGFzRm9jdXMgPT0gZG9jdW1lbnQuYm9keVxcbiAgfVxcblxcbiAgZnVuY3Rpb24gc2F2ZSgpIHt0ZXh0YXJlYS52YWx1ZSA9IGNtLmdldFZhbHVlKCl9XFxuXFxuICB2YXIgcmVhbFN1Ym1pdFxcbiAgaWYgKHRleHRhcmVhLmZvcm0pIHtcXG4gICAgb24odGV4dGFyZWEuZm9ybSwgXFxcInN1Ym1pdFxcXCIsIHNhdmUpXFxuICAgIC8vIERlcGxvcmFibGUgaGFjayB0byBtYWtlIHRoZSBzdWJtaXQgbWV0aG9kIGRvIHRoZSByaWdodCB0aGluZy5cXG4gICAgaWYgKCFvcHRpb25zLmxlYXZlU3VibWl0TWV0aG9kQWxvbmUpIHtcXG4gICAgICB2YXIgZm9ybSA9IHRleHRhcmVhLmZvcm1cXG4gICAgICByZWFsU3VibWl0ID0gZm9ybS5zdWJtaXRcXG4gICAgICB0cnkge1xcbiAgICAgICAgdmFyIHdyYXBwZWRTdWJtaXQgPSBmb3JtLnN1Ym1pdCA9IGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgc2F2ZSgpXFxuICAgICAgICAgIGZvcm0uc3VibWl0ID0gcmVhbFN1Ym1pdFxcbiAgICAgICAgICBmb3JtLnN1Ym1pdCgpXFxuICAgICAgICAgIGZvcm0uc3VibWl0ID0gd3JhcHBlZFN1Ym1pdFxcbiAgICAgICAgfVxcbiAgICAgIH0gY2F0Y2goZSkge31cXG4gICAgfVxcbiAgfVxcblxcbiAgb3B0aW9ucy5maW5pc2hJbml0ID0gZnVuY3Rpb24gKGNtKSB7XFxuICAgIGNtLnNhdmUgPSBzYXZlXFxuICAgIGNtLmdldFRleHRBcmVhID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGV4dGFyZWE7IH1cXG4gICAgY20udG9UZXh0QXJlYSA9IGZ1bmN0aW9uICgpIHtcXG4gICAgICBjbS50b1RleHRBcmVhID0gaXNOYU4gLy8gUHJldmVudCB0aGlzIGZyb20gYmVpbmcgcmFuIHR3aWNlXFxuICAgICAgc2F2ZSgpXFxuICAgICAgdGV4dGFyZWEucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChjbS5nZXRXcmFwcGVyRWxlbWVudCgpKVxcbiAgICAgIHRleHRhcmVhLnN0eWxlLmRpc3BsYXkgPSBcXFwiXFxcIlxcbiAgICAgIGlmICh0ZXh0YXJlYS5mb3JtKSB7XFxuICAgICAgICBvZmYodGV4dGFyZWEuZm9ybSwgXFxcInN1Ym1pdFxcXCIsIHNhdmUpXFxuICAgICAgICBpZiAodHlwZW9mIHRleHRhcmVhLmZvcm0uc3VibWl0ID09IFxcXCJmdW5jdGlvblxcXCIpXFxuICAgICAgICAgIHsgdGV4dGFyZWEuZm9ybS5zdWJtaXQgPSByZWFsU3VibWl0IH1cXG4gICAgICB9XFxuICAgIH1cXG4gIH1cXG5cXG4gIHRleHRhcmVhLnN0eWxlLmRpc3BsYXkgPSBcXFwibm9uZVxcXCJcXG4gIHZhciBjbSA9IENvZGVNaXJyb3IoZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIHRleHRhcmVhLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKG5vZGUsIHRleHRhcmVhLm5leHRTaWJsaW5nKTsgfSxcXG4gICAgb3B0aW9ucylcXG4gIHJldHVybiBjbVxcbn1cXG5cXG5mdW5jdGlvbiBhZGRMZWdhY3lQcm9wcyhDb2RlTWlycm9yKSB7XFxuICBDb2RlTWlycm9yLm9mZiA9IG9mZlxcbiAgQ29kZU1pcnJvci5vbiA9IG9uXFxuICBDb2RlTWlycm9yLndoZWVsRXZlbnRQaXhlbHMgPSB3aGVlbEV2ZW50UGl4ZWxzXFxuICBDb2RlTWlycm9yLkRvYyA9IERvY1xcbiAgQ29kZU1pcnJvci5zcGxpdExpbmVzID0gc3BsaXRMaW5lc0F1dG9cXG4gIENvZGVNaXJyb3IuY291bnRDb2x1bW4gPSBjb3VudENvbHVtblxcbiAgQ29kZU1pcnJvci5maW5kQ29sdW1uID0gZmluZENvbHVtblxcbiAgQ29kZU1pcnJvci5pc1dvcmRDaGFyID0gaXNXb3JkQ2hhckJhc2ljXFxuICBDb2RlTWlycm9yLlBhc3MgPSBQYXNzXFxuICBDb2RlTWlycm9yLnNpZ25hbCA9IHNpZ25hbFxcbiAgQ29kZU1pcnJvci5MaW5lID0gTGluZVxcbiAgQ29kZU1pcnJvci5jaGFuZ2VFbmQgPSBjaGFuZ2VFbmRcXG4gIENvZGVNaXJyb3Iuc2Nyb2xsYmFyTW9kZWwgPSBzY3JvbGxiYXJNb2RlbFxcbiAgQ29kZU1pcnJvci5Qb3MgPSBQb3NcXG4gIENvZGVNaXJyb3IuY21wUG9zID0gY21wXFxuICBDb2RlTWlycm9yLm1vZGVzID0gbW9kZXNcXG4gIENvZGVNaXJyb3IubWltZU1vZGVzID0gbWltZU1vZGVzXFxuICBDb2RlTWlycm9yLnJlc29sdmVNb2RlID0gcmVzb2x2ZU1vZGVcXG4gIENvZGVNaXJyb3IuZ2V0TW9kZSA9IGdldE1vZGVcXG4gIENvZGVNaXJyb3IubW9kZUV4dGVuc2lvbnMgPSBtb2RlRXh0ZW5zaW9uc1xcbiAgQ29kZU1pcnJvci5leHRlbmRNb2RlID0gZXh0ZW5kTW9kZVxcbiAgQ29kZU1pcnJvci5jb3B5U3RhdGUgPSBjb3B5U3RhdGVcXG4gIENvZGVNaXJyb3Iuc3RhcnRTdGF0ZSA9IHN0YXJ0U3RhdGVcXG4gIENvZGVNaXJyb3IuaW5uZXJNb2RlID0gaW5uZXJNb2RlXFxuICBDb2RlTWlycm9yLmNvbW1hbmRzID0gY29tbWFuZHNcXG4gIENvZGVNaXJyb3Iua2V5TWFwID0ga2V5TWFwXFxuICBDb2RlTWlycm9yLmtleU5hbWUgPSBrZXlOYW1lXFxuICBDb2RlTWlycm9yLmlzTW9kaWZpZXJLZXkgPSBpc01vZGlmaWVyS2V5XFxuICBDb2RlTWlycm9yLmxvb2t1cEtleSA9IGxvb2t1cEtleVxcbiAgQ29kZU1pcnJvci5ub3JtYWxpemVLZXlNYXAgPSBub3JtYWxpemVLZXlNYXBcXG4gIENvZGVNaXJyb3IuU3RyaW5nU3RyZWFtID0gU3RyaW5nU3RyZWFtXFxuICBDb2RlTWlycm9yLlNoYXJlZFRleHRNYXJrZXIgPSBTaGFyZWRUZXh0TWFya2VyXFxuICBDb2RlTWlycm9yLlRleHRNYXJrZXIgPSBUZXh0TWFya2VyXFxuICBDb2RlTWlycm9yLkxpbmVXaWRnZXQgPSBMaW5lV2lkZ2V0XFxuICBDb2RlTWlycm9yLmVfcHJldmVudERlZmF1bHQgPSBlX3ByZXZlbnREZWZhdWx0XFxuICBDb2RlTWlycm9yLmVfc3RvcFByb3BhZ2F0aW9uID0gZV9zdG9wUHJvcGFnYXRpb25cXG4gIENvZGVNaXJyb3IuZV9zdG9wID0gZV9zdG9wXFxuICBDb2RlTWlycm9yLmFkZENsYXNzID0gYWRkQ2xhc3NcXG4gIENvZGVNaXJyb3IuY29udGFpbnMgPSBjb250YWluc1xcbiAgQ29kZU1pcnJvci5ybUNsYXNzID0gcm1DbGFzc1xcbiAgQ29kZU1pcnJvci5rZXlOYW1lcyA9IGtleU5hbWVzXFxufVxcblxcbi8vIEVESVRPUiBDT05TVFJVQ1RPUlxcblxcbmRlZmluZU9wdGlvbnMoQ29kZU1pcnJvcilcXG5cXG5hZGRFZGl0b3JNZXRob2RzKENvZGVNaXJyb3IpXFxuXFxuLy8gU2V0IHVwIG1ldGhvZHMgb24gQ29kZU1pcnJvcidzIHByb3RvdHlwZSB0byByZWRpcmVjdCB0byB0aGUgZWRpdG9yJ3MgZG9jdW1lbnQuXFxudmFyIGRvbnREZWxlZ2F0ZSA9IFxcXCJpdGVyIGluc2VydCByZW1vdmUgY29weSBnZXRFZGl0b3IgY29uc3RydWN0b3JcXFwiLnNwbGl0KFxcXCIgXFxcIilcXG5mb3IgKHZhciBwcm9wIGluIERvYy5wcm90b3R5cGUpIHsgaWYgKERvYy5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkocHJvcCkgJiYgaW5kZXhPZihkb250RGVsZWdhdGUsIHByb3ApIDwgMClcXG4gIHsgQ29kZU1pcnJvci5wcm90b3R5cGVbcHJvcF0gPSAoZnVuY3Rpb24obWV0aG9kKSB7XFxuICAgIHJldHVybiBmdW5jdGlvbigpIHtyZXR1cm4gbWV0aG9kLmFwcGx5KHRoaXMuZG9jLCBhcmd1bWVudHMpfVxcbiAgfSkoRG9jLnByb3RvdHlwZVtwcm9wXSkgfSB9XFxuXFxuZXZlbnRNaXhpbihEb2MpXFxuXFxuLy8gSU5QVVQgSEFORExJTkdcXG5cXG5Db2RlTWlycm9yLmlucHV0U3R5bGVzID0ge1xcXCJ0ZXh0YXJlYVxcXCI6IFRleHRhcmVhSW5wdXQsIFxcXCJjb250ZW50ZWRpdGFibGVcXFwiOiBDb250ZW50RWRpdGFibGVJbnB1dH1cXG5cXG4vLyBNT0RFIERFRklOSVRJT04gQU5EIFFVRVJZSU5HXFxuXFxuLy8gRXh0cmEgYXJndW1lbnRzIGFyZSBzdG9yZWQgYXMgdGhlIG1vZGUncyBkZXBlbmRlbmNpZXMsIHdoaWNoIGlzXFxuLy8gdXNlZCBieSAobGVnYWN5KSBtZWNoYW5pc21zIGxpa2UgbG9hZG1vZGUuanMgdG8gYXV0b21hdGljYWxseVxcbi8vIGxvYWQgYSBtb2RlLiAoUHJlZmVycmVkIG1lY2hhbmlzbSBpcyB0aGUgcmVxdWlyZS9kZWZpbmUgY2FsbHMuKVxcbkNvZGVNaXJyb3IuZGVmaW5lTW9kZSA9IGZ1bmN0aW9uKG5hbWUvKiwgbW9kZSwg4oCmKi8pIHtcXG4gIGlmICghQ29kZU1pcnJvci5kZWZhdWx0cy5tb2RlICYmIG5hbWUgIT0gXFxcIm51bGxcXFwiKSB7IENvZGVNaXJyb3IuZGVmYXVsdHMubW9kZSA9IG5hbWUgfVxcbiAgZGVmaW5lTW9kZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpXFxufVxcblxcbkNvZGVNaXJyb3IuZGVmaW5lTUlNRSA9IGRlZmluZU1JTUVcXG5cXG4vLyBNaW5pbWFsIGRlZmF1bHQgbW9kZS5cXG5Db2RlTWlycm9yLmRlZmluZU1vZGUoXFxcIm51bGxcXFwiLCBmdW5jdGlvbiAoKSB7IHJldHVybiAoe3Rva2VuOiBmdW5jdGlvbiAoc3RyZWFtKSB7IHJldHVybiBzdHJlYW0uc2tpcFRvRW5kKCk7IH19KTsgfSlcXG5Db2RlTWlycm9yLmRlZmluZU1JTUUoXFxcInRleHQvcGxhaW5cXFwiLCBcXFwibnVsbFxcXCIpXFxuXFxuLy8gRVhURU5TSU9OU1xcblxcbkNvZGVNaXJyb3IuZGVmaW5lRXh0ZW5zaW9uID0gZnVuY3Rpb24gKG5hbWUsIGZ1bmMpIHtcXG4gIENvZGVNaXJyb3IucHJvdG90eXBlW25hbWVdID0gZnVuY1xcbn1cXG5Db2RlTWlycm9yLmRlZmluZURvY0V4dGVuc2lvbiA9IGZ1bmN0aW9uIChuYW1lLCBmdW5jKSB7XFxuICBEb2MucHJvdG90eXBlW25hbWVdID0gZnVuY1xcbn1cXG5cXG5Db2RlTWlycm9yLmZyb21UZXh0QXJlYSA9IGZyb21UZXh0QXJlYVxcblxcbmFkZExlZ2FjeVByb3BzKENvZGVNaXJyb3IpXFxuXFxuQ29kZU1pcnJvci52ZXJzaW9uID0gXFxcIjUuMjAuMlxcXCJcXG5cXG5yZXR1cm4gQ29kZU1pcnJvcjtcXG5cXG59KSkpO1wiXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3Jhdy1sb2FkZXIhLi9+L2NvZGVtaXJyb3IvbGliL2NvZGVtaXJyb3IuanNcbi8vIG1vZHVsZSBpZCA9IDVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQSIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	eval("__webpack_require__(2)(__webpack_require__(7))//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL34vY29kZW1pcnJvci9tb2RlL3htbC94bWwuanM/ODBhNyJdLCJzb3VyY2VzQ29udGVudCI6WyJyZXF1aXJlKFwiISEvdmFyL2FwcC93ZWIvanMvbm9kZV9tb2R1bGVzL3NjcmlwdC1sb2FkZXIvYWRkU2NyaXB0LmpzXCIpKHJlcXVpcmUoXCIhIS92YXIvYXBwL3dlYi9qcy9ub2RlX21vZHVsZXMvcmF3LWxvYWRlci9pbmRleC5qcyEvdmFyL2FwcC93ZWIvanMvbm9kZV9tb2R1bGVzL2NvZGVtaXJyb3IvbW9kZS94bWwveG1sLmpzXCIpKVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9zY3JpcHQtbG9hZGVyIS4vfi9jb2RlbWlycm9yL21vZGUveG1sL3htbC5qc1xuLy8gbW9kdWxlIGlkID0gNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 7 */
/***/ function(module, exports) {

	eval("module.exports = \"// CodeMirror, copyright (c) by Marijn Haverbeke and others\\n// Distributed under an MIT license: http://codemirror.net/LICENSE\\n\\n(function(mod) {\\n  if (typeof exports == \\\"object\\\" && typeof module == \\\"object\\\") // CommonJS\\n    mod(require(\\\"../../lib/codemirror\\\"));\\n  else if (typeof define == \\\"function\\\" && define.amd) // AMD\\n    define([\\\"../../lib/codemirror\\\"], mod);\\n  else // Plain browser env\\n    mod(CodeMirror);\\n})(function(CodeMirror) {\\n\\\"use strict\\\";\\n\\nvar htmlConfig = {\\n  autoSelfClosers: {'area': true, 'base': true, 'br': true, 'col': true, 'command': true,\\n                    'embed': true, 'frame': true, 'hr': true, 'img': true, 'input': true,\\n                    'keygen': true, 'link': true, 'meta': true, 'param': true, 'source': true,\\n                    'track': true, 'wbr': true, 'menuitem': true},\\n  implicitlyClosed: {'dd': true, 'li': true, 'optgroup': true, 'option': true, 'p': true,\\n                     'rp': true, 'rt': true, 'tbody': true, 'td': true, 'tfoot': true,\\n                     'th': true, 'tr': true},\\n  contextGrabbers: {\\n    'dd': {'dd': true, 'dt': true},\\n    'dt': {'dd': true, 'dt': true},\\n    'li': {'li': true},\\n    'option': {'option': true, 'optgroup': true},\\n    'optgroup': {'optgroup': true},\\n    'p': {'address': true, 'article': true, 'aside': true, 'blockquote': true, 'dir': true,\\n          'div': true, 'dl': true, 'fieldset': true, 'footer': true, 'form': true,\\n          'h1': true, 'h2': true, 'h3': true, 'h4': true, 'h5': true, 'h6': true,\\n          'header': true, 'hgroup': true, 'hr': true, 'menu': true, 'nav': true, 'ol': true,\\n          'p': true, 'pre': true, 'section': true, 'table': true, 'ul': true},\\n    'rp': {'rp': true, 'rt': true},\\n    'rt': {'rp': true, 'rt': true},\\n    'tbody': {'tbody': true, 'tfoot': true},\\n    'td': {'td': true, 'th': true},\\n    'tfoot': {'tbody': true},\\n    'th': {'td': true, 'th': true},\\n    'thead': {'tbody': true, 'tfoot': true},\\n    'tr': {'tr': true}\\n  },\\n  doNotIndent: {\\\"pre\\\": true},\\n  allowUnquoted: true,\\n  allowMissing: true,\\n  caseFold: true\\n}\\n\\nvar xmlConfig = {\\n  autoSelfClosers: {},\\n  implicitlyClosed: {},\\n  contextGrabbers: {},\\n  doNotIndent: {},\\n  allowUnquoted: false,\\n  allowMissing: false,\\n  caseFold: false\\n}\\n\\nCodeMirror.defineMode(\\\"xml\\\", function(editorConf, config_) {\\n  var indentUnit = editorConf.indentUnit\\n  var config = {}\\n  var defaults = config_.htmlMode ? htmlConfig : xmlConfig\\n  for (var prop in defaults) config[prop] = defaults[prop]\\n  for (var prop in config_) config[prop] = config_[prop]\\n\\n  // Return variables for tokenizers\\n  var type, setStyle;\\n\\n  function inText(stream, state) {\\n    function chain(parser) {\\n      state.tokenize = parser;\\n      return parser(stream, state);\\n    }\\n\\n    var ch = stream.next();\\n    if (ch == \\\"<\\\") {\\n      if (stream.eat(\\\"!\\\")) {\\n        if (stream.eat(\\\"[\\\")) {\\n          if (stream.match(\\\"CDATA[\\\")) return chain(inBlock(\\\"atom\\\", \\\"]]>\\\"));\\n          else return null;\\n        } else if (stream.match(\\\"--\\\")) {\\n          return chain(inBlock(\\\"comment\\\", \\\"-->\\\"));\\n        } else if (stream.match(\\\"DOCTYPE\\\", true, true)) {\\n          stream.eatWhile(/[\\\\w\\\\._\\\\-]/);\\n          return chain(doctype(1));\\n        } else {\\n          return null;\\n        }\\n      } else if (stream.eat(\\\"?\\\")) {\\n        stream.eatWhile(/[\\\\w\\\\._\\\\-]/);\\n        state.tokenize = inBlock(\\\"meta\\\", \\\"?>\\\");\\n        return \\\"meta\\\";\\n      } else {\\n        type = stream.eat(\\\"/\\\") ? \\\"closeTag\\\" : \\\"openTag\\\";\\n        state.tokenize = inTag;\\n        return \\\"tag bracket\\\";\\n      }\\n    } else if (ch == \\\"&\\\") {\\n      var ok;\\n      if (stream.eat(\\\"#\\\")) {\\n        if (stream.eat(\\\"x\\\")) {\\n          ok = stream.eatWhile(/[a-fA-F\\\\d]/) && stream.eat(\\\";\\\");\\n        } else {\\n          ok = stream.eatWhile(/[\\\\d]/) && stream.eat(\\\";\\\");\\n        }\\n      } else {\\n        ok = stream.eatWhile(/[\\\\w\\\\.\\\\-:]/) && stream.eat(\\\";\\\");\\n      }\\n      return ok ? \\\"atom\\\" : \\\"error\\\";\\n    } else {\\n      stream.eatWhile(/[^&<]/);\\n      return null;\\n    }\\n  }\\n  inText.isInText = true;\\n\\n  function inTag(stream, state) {\\n    var ch = stream.next();\\n    if (ch == \\\">\\\" || (ch == \\\"/\\\" && stream.eat(\\\">\\\"))) {\\n      state.tokenize = inText;\\n      type = ch == \\\">\\\" ? \\\"endTag\\\" : \\\"selfcloseTag\\\";\\n      return \\\"tag bracket\\\";\\n    } else if (ch == \\\"=\\\") {\\n      type = \\\"equals\\\";\\n      return null;\\n    } else if (ch == \\\"<\\\") {\\n      state.tokenize = inText;\\n      state.state = baseState;\\n      state.tagName = state.tagStart = null;\\n      var next = state.tokenize(stream, state);\\n      return next ? next + \\\" tag error\\\" : \\\"tag error\\\";\\n    } else if (/[\\\\'\\\\\\\"]/.test(ch)) {\\n      state.tokenize = inAttribute(ch);\\n      state.stringStartCol = stream.column();\\n      return state.tokenize(stream, state);\\n    } else {\\n      stream.match(/^[^\\\\s\\\\u00a0=<>\\\\\\\"\\\\']*[^\\\\s\\\\u00a0=<>\\\\\\\"\\\\'\\\\/]/);\\n      return \\\"word\\\";\\n    }\\n  }\\n\\n  function inAttribute(quote) {\\n    var closure = function(stream, state) {\\n      while (!stream.eol()) {\\n        if (stream.next() == quote) {\\n          state.tokenize = inTag;\\n          break;\\n        }\\n      }\\n      return \\\"string\\\";\\n    };\\n    closure.isInAttribute = true;\\n    return closure;\\n  }\\n\\n  function inBlock(style, terminator) {\\n    return function(stream, state) {\\n      while (!stream.eol()) {\\n        if (stream.match(terminator)) {\\n          state.tokenize = inText;\\n          break;\\n        }\\n        stream.next();\\n      }\\n      return style;\\n    };\\n  }\\n  function doctype(depth) {\\n    return function(stream, state) {\\n      var ch;\\n      while ((ch = stream.next()) != null) {\\n        if (ch == \\\"<\\\") {\\n          state.tokenize = doctype(depth + 1);\\n          return state.tokenize(stream, state);\\n        } else if (ch == \\\">\\\") {\\n          if (depth == 1) {\\n            state.tokenize = inText;\\n            break;\\n          } else {\\n            state.tokenize = doctype(depth - 1);\\n            return state.tokenize(stream, state);\\n          }\\n        }\\n      }\\n      return \\\"meta\\\";\\n    };\\n  }\\n\\n  function Context(state, tagName, startOfLine) {\\n    this.prev = state.context;\\n    this.tagName = tagName;\\n    this.indent = state.indented;\\n    this.startOfLine = startOfLine;\\n    if (config.doNotIndent.hasOwnProperty(tagName) || (state.context && state.context.noIndent))\\n      this.noIndent = true;\\n  }\\n  function popContext(state) {\\n    if (state.context) state.context = state.context.prev;\\n  }\\n  function maybePopContext(state, nextTagName) {\\n    var parentTagName;\\n    while (true) {\\n      if (!state.context) {\\n        return;\\n      }\\n      parentTagName = state.context.tagName;\\n      if (!config.contextGrabbers.hasOwnProperty(parentTagName) ||\\n          !config.contextGrabbers[parentTagName].hasOwnProperty(nextTagName)) {\\n        return;\\n      }\\n      popContext(state);\\n    }\\n  }\\n\\n  function baseState(type, stream, state) {\\n    if (type == \\\"openTag\\\") {\\n      state.tagStart = stream.column();\\n      return tagNameState;\\n    } else if (type == \\\"closeTag\\\") {\\n      return closeTagNameState;\\n    } else {\\n      return baseState;\\n    }\\n  }\\n  function tagNameState(type, stream, state) {\\n    if (type == \\\"word\\\") {\\n      state.tagName = stream.current();\\n      setStyle = \\\"tag\\\";\\n      return attrState;\\n    } else {\\n      setStyle = \\\"error\\\";\\n      return tagNameState;\\n    }\\n  }\\n  function closeTagNameState(type, stream, state) {\\n    if (type == \\\"word\\\") {\\n      var tagName = stream.current();\\n      if (state.context && state.context.tagName != tagName &&\\n          config.implicitlyClosed.hasOwnProperty(state.context.tagName))\\n        popContext(state);\\n      if ((state.context && state.context.tagName == tagName) || config.matchClosing === false) {\\n        setStyle = \\\"tag\\\";\\n        return closeState;\\n      } else {\\n        setStyle = \\\"tag error\\\";\\n        return closeStateErr;\\n      }\\n    } else {\\n      setStyle = \\\"error\\\";\\n      return closeStateErr;\\n    }\\n  }\\n\\n  function closeState(type, _stream, state) {\\n    if (type != \\\"endTag\\\") {\\n      setStyle = \\\"error\\\";\\n      return closeState;\\n    }\\n    popContext(state);\\n    return baseState;\\n  }\\n  function closeStateErr(type, stream, state) {\\n    setStyle = \\\"error\\\";\\n    return closeState(type, stream, state);\\n  }\\n\\n  function attrState(type, _stream, state) {\\n    if (type == \\\"word\\\") {\\n      setStyle = \\\"attribute\\\";\\n      return attrEqState;\\n    } else if (type == \\\"endTag\\\" || type == \\\"selfcloseTag\\\") {\\n      var tagName = state.tagName, tagStart = state.tagStart;\\n      state.tagName = state.tagStart = null;\\n      if (type == \\\"selfcloseTag\\\" ||\\n          config.autoSelfClosers.hasOwnProperty(tagName)) {\\n        maybePopContext(state, tagName);\\n      } else {\\n        maybePopContext(state, tagName);\\n        state.context = new Context(state, tagName, tagStart == state.indented);\\n      }\\n      return baseState;\\n    }\\n    setStyle = \\\"error\\\";\\n    return attrState;\\n  }\\n  function attrEqState(type, stream, state) {\\n    if (type == \\\"equals\\\") return attrValueState;\\n    if (!config.allowMissing) setStyle = \\\"error\\\";\\n    return attrState(type, stream, state);\\n  }\\n  function attrValueState(type, stream, state) {\\n    if (type == \\\"string\\\") return attrContinuedState;\\n    if (type == \\\"word\\\" && config.allowUnquoted) {setStyle = \\\"string\\\"; return attrState;}\\n    setStyle = \\\"error\\\";\\n    return attrState(type, stream, state);\\n  }\\n  function attrContinuedState(type, stream, state) {\\n    if (type == \\\"string\\\") return attrContinuedState;\\n    return attrState(type, stream, state);\\n  }\\n\\n  return {\\n    startState: function(baseIndent) {\\n      var state = {tokenize: inText,\\n                   state: baseState,\\n                   indented: baseIndent || 0,\\n                   tagName: null, tagStart: null,\\n                   context: null}\\n      if (baseIndent != null) state.baseIndent = baseIndent\\n      return state\\n    },\\n\\n    token: function(stream, state) {\\n      if (!state.tagName && stream.sol())\\n        state.indented = stream.indentation();\\n\\n      if (stream.eatSpace()) return null;\\n      type = null;\\n      var style = state.tokenize(stream, state);\\n      if ((style || type) && style != \\\"comment\\\") {\\n        setStyle = null;\\n        state.state = state.state(type || style, stream, state);\\n        if (setStyle)\\n          style = setStyle == \\\"error\\\" ? style + \\\" error\\\" : setStyle;\\n      }\\n      return style;\\n    },\\n\\n    indent: function(state, textAfter, fullLine) {\\n      var context = state.context;\\n      // Indent multi-line strings (e.g. css).\\n      if (state.tokenize.isInAttribute) {\\n        if (state.tagStart == state.indented)\\n          return state.stringStartCol + 1;\\n        else\\n          return state.indented + indentUnit;\\n      }\\n      if (context && context.noIndent) return CodeMirror.Pass;\\n      if (state.tokenize != inTag && state.tokenize != inText)\\n        return fullLine ? fullLine.match(/^(\\\\s*)/)[0].length : 0;\\n      // Indent the starts of attribute names.\\n      if (state.tagName) {\\n        if (config.multilineTagIndentPastTag !== false)\\n          return state.tagStart + state.tagName.length + 2;\\n        else\\n          return state.tagStart + indentUnit * (config.multilineTagIndentFactor || 1);\\n      }\\n      if (config.alignCDATA && /<!\\\\[CDATA\\\\[/.test(textAfter)) return 0;\\n      var tagAfter = textAfter && /^<(\\\\/)?([\\\\w_:\\\\.-]*)/.exec(textAfter);\\n      if (tagAfter && tagAfter[1]) { // Closing tag spotted\\n        while (context) {\\n          if (context.tagName == tagAfter[2]) {\\n            context = context.prev;\\n            break;\\n          } else if (config.implicitlyClosed.hasOwnProperty(context.tagName)) {\\n            context = context.prev;\\n          } else {\\n            break;\\n          }\\n        }\\n      } else if (tagAfter) { // Opening tag spotted\\n        while (context) {\\n          var grabbers = config.contextGrabbers[context.tagName];\\n          if (grabbers && grabbers.hasOwnProperty(tagAfter[2]))\\n            context = context.prev;\\n          else\\n            break;\\n        }\\n      }\\n      while (context && context.prev && !context.startOfLine)\\n        context = context.prev;\\n      if (context) return context.indent + indentUnit;\\n      else return state.baseIndent || 0;\\n    },\\n\\n    electricInput: /<\\\\/[\\\\s\\\\w:]+>$/,\\n    blockCommentStart: \\\"<!--\\\",\\n    blockCommentEnd: \\\"-->\\\",\\n\\n    configuration: config.htmlMode ? \\\"html\\\" : \\\"xml\\\",\\n    helperType: config.htmlMode ? \\\"html\\\" : \\\"xml\\\",\\n\\n    skipAttribute: function(state) {\\n      if (state.state == attrValueState)\\n        state.state = attrState\\n    }\\n  };\\n});\\n\\nCodeMirror.defineMIME(\\\"text/xml\\\", \\\"xml\\\");\\nCodeMirror.defineMIME(\\\"application/xml\\\", \\\"xml\\\");\\nif (!CodeMirror.mimeModes.hasOwnProperty(\\\"text/html\\\"))\\n  CodeMirror.defineMIME(\\\"text/html\\\", {name: \\\"xml\\\", htmlMode: true});\\n\\n});\\n\"//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL34vY29kZW1pcnJvci9tb2RlL3htbC94bWwuanM/Y2MzNSJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IFwiLy8gQ29kZU1pcnJvciwgY29weXJpZ2h0IChjKSBieSBNYXJpam4gSGF2ZXJiZWtlIGFuZCBvdGhlcnNcXG4vLyBEaXN0cmlidXRlZCB1bmRlciBhbiBNSVQgbGljZW5zZTogaHR0cDovL2NvZGVtaXJyb3IubmV0L0xJQ0VOU0VcXG5cXG4oZnVuY3Rpb24obW9kKSB7XFxuICBpZiAodHlwZW9mIGV4cG9ydHMgPT0gXFxcIm9iamVjdFxcXCIgJiYgdHlwZW9mIG1vZHVsZSA9PSBcXFwib2JqZWN0XFxcIikgLy8gQ29tbW9uSlNcXG4gICAgbW9kKHJlcXVpcmUoXFxcIi4uLy4uL2xpYi9jb2RlbWlycm9yXFxcIikpO1xcbiAgZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PSBcXFwiZnVuY3Rpb25cXFwiICYmIGRlZmluZS5hbWQpIC8vIEFNRFxcbiAgICBkZWZpbmUoW1xcXCIuLi8uLi9saWIvY29kZW1pcnJvclxcXCJdLCBtb2QpO1xcbiAgZWxzZSAvLyBQbGFpbiBicm93c2VyIGVudlxcbiAgICBtb2QoQ29kZU1pcnJvcik7XFxufSkoZnVuY3Rpb24oQ29kZU1pcnJvcikge1xcblxcXCJ1c2Ugc3RyaWN0XFxcIjtcXG5cXG52YXIgaHRtbENvbmZpZyA9IHtcXG4gIGF1dG9TZWxmQ2xvc2VyczogeydhcmVhJzogdHJ1ZSwgJ2Jhc2UnOiB0cnVlLCAnYnInOiB0cnVlLCAnY29sJzogdHJ1ZSwgJ2NvbW1hbmQnOiB0cnVlLFxcbiAgICAgICAgICAgICAgICAgICAgJ2VtYmVkJzogdHJ1ZSwgJ2ZyYW1lJzogdHJ1ZSwgJ2hyJzogdHJ1ZSwgJ2ltZyc6IHRydWUsICdpbnB1dCc6IHRydWUsXFxuICAgICAgICAgICAgICAgICAgICAna2V5Z2VuJzogdHJ1ZSwgJ2xpbmsnOiB0cnVlLCAnbWV0YSc6IHRydWUsICdwYXJhbSc6IHRydWUsICdzb3VyY2UnOiB0cnVlLFxcbiAgICAgICAgICAgICAgICAgICAgJ3RyYWNrJzogdHJ1ZSwgJ3dicic6IHRydWUsICdtZW51aXRlbSc6IHRydWV9LFxcbiAgaW1wbGljaXRseUNsb3NlZDogeydkZCc6IHRydWUsICdsaSc6IHRydWUsICdvcHRncm91cCc6IHRydWUsICdvcHRpb24nOiB0cnVlLCAncCc6IHRydWUsXFxuICAgICAgICAgICAgICAgICAgICAgJ3JwJzogdHJ1ZSwgJ3J0JzogdHJ1ZSwgJ3Rib2R5JzogdHJ1ZSwgJ3RkJzogdHJ1ZSwgJ3Rmb290JzogdHJ1ZSxcXG4gICAgICAgICAgICAgICAgICAgICAndGgnOiB0cnVlLCAndHInOiB0cnVlfSxcXG4gIGNvbnRleHRHcmFiYmVyczoge1xcbiAgICAnZGQnOiB7J2RkJzogdHJ1ZSwgJ2R0JzogdHJ1ZX0sXFxuICAgICdkdCc6IHsnZGQnOiB0cnVlLCAnZHQnOiB0cnVlfSxcXG4gICAgJ2xpJzogeydsaSc6IHRydWV9LFxcbiAgICAnb3B0aW9uJzogeydvcHRpb24nOiB0cnVlLCAnb3B0Z3JvdXAnOiB0cnVlfSxcXG4gICAgJ29wdGdyb3VwJzogeydvcHRncm91cCc6IHRydWV9LFxcbiAgICAncCc6IHsnYWRkcmVzcyc6IHRydWUsICdhcnRpY2xlJzogdHJ1ZSwgJ2FzaWRlJzogdHJ1ZSwgJ2Jsb2NrcXVvdGUnOiB0cnVlLCAnZGlyJzogdHJ1ZSxcXG4gICAgICAgICAgJ2Rpdic6IHRydWUsICdkbCc6IHRydWUsICdmaWVsZHNldCc6IHRydWUsICdmb290ZXInOiB0cnVlLCAnZm9ybSc6IHRydWUsXFxuICAgICAgICAgICdoMSc6IHRydWUsICdoMic6IHRydWUsICdoMyc6IHRydWUsICdoNCc6IHRydWUsICdoNSc6IHRydWUsICdoNic6IHRydWUsXFxuICAgICAgICAgICdoZWFkZXInOiB0cnVlLCAnaGdyb3VwJzogdHJ1ZSwgJ2hyJzogdHJ1ZSwgJ21lbnUnOiB0cnVlLCAnbmF2JzogdHJ1ZSwgJ29sJzogdHJ1ZSxcXG4gICAgICAgICAgJ3AnOiB0cnVlLCAncHJlJzogdHJ1ZSwgJ3NlY3Rpb24nOiB0cnVlLCAndGFibGUnOiB0cnVlLCAndWwnOiB0cnVlfSxcXG4gICAgJ3JwJzogeydycCc6IHRydWUsICdydCc6IHRydWV9LFxcbiAgICAncnQnOiB7J3JwJzogdHJ1ZSwgJ3J0JzogdHJ1ZX0sXFxuICAgICd0Ym9keSc6IHsndGJvZHknOiB0cnVlLCAndGZvb3QnOiB0cnVlfSxcXG4gICAgJ3RkJzogeyd0ZCc6IHRydWUsICd0aCc6IHRydWV9LFxcbiAgICAndGZvb3QnOiB7J3Rib2R5JzogdHJ1ZX0sXFxuICAgICd0aCc6IHsndGQnOiB0cnVlLCAndGgnOiB0cnVlfSxcXG4gICAgJ3RoZWFkJzogeyd0Ym9keSc6IHRydWUsICd0Zm9vdCc6IHRydWV9LFxcbiAgICAndHInOiB7J3RyJzogdHJ1ZX1cXG4gIH0sXFxuICBkb05vdEluZGVudDoge1xcXCJwcmVcXFwiOiB0cnVlfSxcXG4gIGFsbG93VW5xdW90ZWQ6IHRydWUsXFxuICBhbGxvd01pc3Npbmc6IHRydWUsXFxuICBjYXNlRm9sZDogdHJ1ZVxcbn1cXG5cXG52YXIgeG1sQ29uZmlnID0ge1xcbiAgYXV0b1NlbGZDbG9zZXJzOiB7fSxcXG4gIGltcGxpY2l0bHlDbG9zZWQ6IHt9LFxcbiAgY29udGV4dEdyYWJiZXJzOiB7fSxcXG4gIGRvTm90SW5kZW50OiB7fSxcXG4gIGFsbG93VW5xdW90ZWQ6IGZhbHNlLFxcbiAgYWxsb3dNaXNzaW5nOiBmYWxzZSxcXG4gIGNhc2VGb2xkOiBmYWxzZVxcbn1cXG5cXG5Db2RlTWlycm9yLmRlZmluZU1vZGUoXFxcInhtbFxcXCIsIGZ1bmN0aW9uKGVkaXRvckNvbmYsIGNvbmZpZ18pIHtcXG4gIHZhciBpbmRlbnRVbml0ID0gZWRpdG9yQ29uZi5pbmRlbnRVbml0XFxuICB2YXIgY29uZmlnID0ge31cXG4gIHZhciBkZWZhdWx0cyA9IGNvbmZpZ18uaHRtbE1vZGUgPyBodG1sQ29uZmlnIDogeG1sQ29uZmlnXFxuICBmb3IgKHZhciBwcm9wIGluIGRlZmF1bHRzKSBjb25maWdbcHJvcF0gPSBkZWZhdWx0c1twcm9wXVxcbiAgZm9yICh2YXIgcHJvcCBpbiBjb25maWdfKSBjb25maWdbcHJvcF0gPSBjb25maWdfW3Byb3BdXFxuXFxuICAvLyBSZXR1cm4gdmFyaWFibGVzIGZvciB0b2tlbml6ZXJzXFxuICB2YXIgdHlwZSwgc2V0U3R5bGU7XFxuXFxuICBmdW5jdGlvbiBpblRleHQoc3RyZWFtLCBzdGF0ZSkge1xcbiAgICBmdW5jdGlvbiBjaGFpbihwYXJzZXIpIHtcXG4gICAgICBzdGF0ZS50b2tlbml6ZSA9IHBhcnNlcjtcXG4gICAgICByZXR1cm4gcGFyc2VyKHN0cmVhbSwgc3RhdGUpO1xcbiAgICB9XFxuXFxuICAgIHZhciBjaCA9IHN0cmVhbS5uZXh0KCk7XFxuICAgIGlmIChjaCA9PSBcXFwiPFxcXCIpIHtcXG4gICAgICBpZiAoc3RyZWFtLmVhdChcXFwiIVxcXCIpKSB7XFxuICAgICAgICBpZiAoc3RyZWFtLmVhdChcXFwiW1xcXCIpKSB7XFxuICAgICAgICAgIGlmIChzdHJlYW0ubWF0Y2goXFxcIkNEQVRBW1xcXCIpKSByZXR1cm4gY2hhaW4oaW5CbG9jayhcXFwiYXRvbVxcXCIsIFxcXCJdXT5cXFwiKSk7XFxuICAgICAgICAgIGVsc2UgcmV0dXJuIG51bGw7XFxuICAgICAgICB9IGVsc2UgaWYgKHN0cmVhbS5tYXRjaChcXFwiLS1cXFwiKSkge1xcbiAgICAgICAgICByZXR1cm4gY2hhaW4oaW5CbG9jayhcXFwiY29tbWVudFxcXCIsIFxcXCItLT5cXFwiKSk7XFxuICAgICAgICB9IGVsc2UgaWYgKHN0cmVhbS5tYXRjaChcXFwiRE9DVFlQRVxcXCIsIHRydWUsIHRydWUpKSB7XFxuICAgICAgICAgIHN0cmVhbS5lYXRXaGlsZSgvW1xcXFx3XFxcXC5fXFxcXC1dLyk7XFxuICAgICAgICAgIHJldHVybiBjaGFpbihkb2N0eXBlKDEpKTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIHJldHVybiBudWxsO1xcbiAgICAgICAgfVxcbiAgICAgIH0gZWxzZSBpZiAoc3RyZWFtLmVhdChcXFwiP1xcXCIpKSB7XFxuICAgICAgICBzdHJlYW0uZWF0V2hpbGUoL1tcXFxcd1xcXFwuX1xcXFwtXS8pO1xcbiAgICAgICAgc3RhdGUudG9rZW5pemUgPSBpbkJsb2NrKFxcXCJtZXRhXFxcIiwgXFxcIj8+XFxcIik7XFxuICAgICAgICByZXR1cm4gXFxcIm1ldGFcXFwiO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICB0eXBlID0gc3RyZWFtLmVhdChcXFwiL1xcXCIpID8gXFxcImNsb3NlVGFnXFxcIiA6IFxcXCJvcGVuVGFnXFxcIjtcXG4gICAgICAgIHN0YXRlLnRva2VuaXplID0gaW5UYWc7XFxuICAgICAgICByZXR1cm4gXFxcInRhZyBicmFja2V0XFxcIjtcXG4gICAgICB9XFxuICAgIH0gZWxzZSBpZiAoY2ggPT0gXFxcIiZcXFwiKSB7XFxuICAgICAgdmFyIG9rO1xcbiAgICAgIGlmIChzdHJlYW0uZWF0KFxcXCIjXFxcIikpIHtcXG4gICAgICAgIGlmIChzdHJlYW0uZWF0KFxcXCJ4XFxcIikpIHtcXG4gICAgICAgICAgb2sgPSBzdHJlYW0uZWF0V2hpbGUoL1thLWZBLUZcXFxcZF0vKSAmJiBzdHJlYW0uZWF0KFxcXCI7XFxcIik7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICBvayA9IHN0cmVhbS5lYXRXaGlsZSgvW1xcXFxkXS8pICYmIHN0cmVhbS5lYXQoXFxcIjtcXFwiKTtcXG4gICAgICAgIH1cXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgb2sgPSBzdHJlYW0uZWF0V2hpbGUoL1tcXFxcd1xcXFwuXFxcXC06XS8pICYmIHN0cmVhbS5lYXQoXFxcIjtcXFwiKTtcXG4gICAgICB9XFxuICAgICAgcmV0dXJuIG9rID8gXFxcImF0b21cXFwiIDogXFxcImVycm9yXFxcIjtcXG4gICAgfSBlbHNlIHtcXG4gICAgICBzdHJlYW0uZWF0V2hpbGUoL1teJjxdLyk7XFxuICAgICAgcmV0dXJuIG51bGw7XFxuICAgIH1cXG4gIH1cXG4gIGluVGV4dC5pc0luVGV4dCA9IHRydWU7XFxuXFxuICBmdW5jdGlvbiBpblRhZyhzdHJlYW0sIHN0YXRlKSB7XFxuICAgIHZhciBjaCA9IHN0cmVhbS5uZXh0KCk7XFxuICAgIGlmIChjaCA9PSBcXFwiPlxcXCIgfHwgKGNoID09IFxcXCIvXFxcIiAmJiBzdHJlYW0uZWF0KFxcXCI+XFxcIikpKSB7XFxuICAgICAgc3RhdGUudG9rZW5pemUgPSBpblRleHQ7XFxuICAgICAgdHlwZSA9IGNoID09IFxcXCI+XFxcIiA/IFxcXCJlbmRUYWdcXFwiIDogXFxcInNlbGZjbG9zZVRhZ1xcXCI7XFxuICAgICAgcmV0dXJuIFxcXCJ0YWcgYnJhY2tldFxcXCI7XFxuICAgIH0gZWxzZSBpZiAoY2ggPT0gXFxcIj1cXFwiKSB7XFxuICAgICAgdHlwZSA9IFxcXCJlcXVhbHNcXFwiO1xcbiAgICAgIHJldHVybiBudWxsO1xcbiAgICB9IGVsc2UgaWYgKGNoID09IFxcXCI8XFxcIikge1xcbiAgICAgIHN0YXRlLnRva2VuaXplID0gaW5UZXh0O1xcbiAgICAgIHN0YXRlLnN0YXRlID0gYmFzZVN0YXRlO1xcbiAgICAgIHN0YXRlLnRhZ05hbWUgPSBzdGF0ZS50YWdTdGFydCA9IG51bGw7XFxuICAgICAgdmFyIG5leHQgPSBzdGF0ZS50b2tlbml6ZShzdHJlYW0sIHN0YXRlKTtcXG4gICAgICByZXR1cm4gbmV4dCA/IG5leHQgKyBcXFwiIHRhZyBlcnJvclxcXCIgOiBcXFwidGFnIGVycm9yXFxcIjtcXG4gICAgfSBlbHNlIGlmICgvW1xcXFwnXFxcXFxcXCJdLy50ZXN0KGNoKSkge1xcbiAgICAgIHN0YXRlLnRva2VuaXplID0gaW5BdHRyaWJ1dGUoY2gpO1xcbiAgICAgIHN0YXRlLnN0cmluZ1N0YXJ0Q29sID0gc3RyZWFtLmNvbHVtbigpO1xcbiAgICAgIHJldHVybiBzdGF0ZS50b2tlbml6ZShzdHJlYW0sIHN0YXRlKTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICBzdHJlYW0ubWF0Y2goL15bXlxcXFxzXFxcXHUwMGEwPTw+XFxcXFxcXCJcXFxcJ10qW15cXFxcc1xcXFx1MDBhMD08PlxcXFxcXFwiXFxcXCdcXFxcL10vKTtcXG4gICAgICByZXR1cm4gXFxcIndvcmRcXFwiO1xcbiAgICB9XFxuICB9XFxuXFxuICBmdW5jdGlvbiBpbkF0dHJpYnV0ZShxdW90ZSkge1xcbiAgICB2YXIgY2xvc3VyZSA9IGZ1bmN0aW9uKHN0cmVhbSwgc3RhdGUpIHtcXG4gICAgICB3aGlsZSAoIXN0cmVhbS5lb2woKSkge1xcbiAgICAgICAgaWYgKHN0cmVhbS5uZXh0KCkgPT0gcXVvdGUpIHtcXG4gICAgICAgICAgc3RhdGUudG9rZW5pemUgPSBpblRhZztcXG4gICAgICAgICAgYnJlYWs7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICAgIHJldHVybiBcXFwic3RyaW5nXFxcIjtcXG4gICAgfTtcXG4gICAgY2xvc3VyZS5pc0luQXR0cmlidXRlID0gdHJ1ZTtcXG4gICAgcmV0dXJuIGNsb3N1cmU7XFxuICB9XFxuXFxuICBmdW5jdGlvbiBpbkJsb2NrKHN0eWxlLCB0ZXJtaW5hdG9yKSB7XFxuICAgIHJldHVybiBmdW5jdGlvbihzdHJlYW0sIHN0YXRlKSB7XFxuICAgICAgd2hpbGUgKCFzdHJlYW0uZW9sKCkpIHtcXG4gICAgICAgIGlmIChzdHJlYW0ubWF0Y2godGVybWluYXRvcikpIHtcXG4gICAgICAgICAgc3RhdGUudG9rZW5pemUgPSBpblRleHQ7XFxuICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgfVxcbiAgICAgICAgc3RyZWFtLm5leHQoKTtcXG4gICAgICB9XFxuICAgICAgcmV0dXJuIHN0eWxlO1xcbiAgICB9O1xcbiAgfVxcbiAgZnVuY3Rpb24gZG9jdHlwZShkZXB0aCkge1xcbiAgICByZXR1cm4gZnVuY3Rpb24oc3RyZWFtLCBzdGF0ZSkge1xcbiAgICAgIHZhciBjaDtcXG4gICAgICB3aGlsZSAoKGNoID0gc3RyZWFtLm5leHQoKSkgIT0gbnVsbCkge1xcbiAgICAgICAgaWYgKGNoID09IFxcXCI8XFxcIikge1xcbiAgICAgICAgICBzdGF0ZS50b2tlbml6ZSA9IGRvY3R5cGUoZGVwdGggKyAxKTtcXG4gICAgICAgICAgcmV0dXJuIHN0YXRlLnRva2VuaXplKHN0cmVhbSwgc3RhdGUpO1xcbiAgICAgICAgfSBlbHNlIGlmIChjaCA9PSBcXFwiPlxcXCIpIHtcXG4gICAgICAgICAgaWYgKGRlcHRoID09IDEpIHtcXG4gICAgICAgICAgICBzdGF0ZS50b2tlbml6ZSA9IGluVGV4dDtcXG4gICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICBzdGF0ZS50b2tlbml6ZSA9IGRvY3R5cGUoZGVwdGggLSAxKTtcXG4gICAgICAgICAgICByZXR1cm4gc3RhdGUudG9rZW5pemUoc3RyZWFtLCBzdGF0ZSk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgICAgcmV0dXJuIFxcXCJtZXRhXFxcIjtcXG4gICAgfTtcXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIENvbnRleHQoc3RhdGUsIHRhZ05hbWUsIHN0YXJ0T2ZMaW5lKSB7XFxuICAgIHRoaXMucHJldiA9IHN0YXRlLmNvbnRleHQ7XFxuICAgIHRoaXMudGFnTmFtZSA9IHRhZ05hbWU7XFxuICAgIHRoaXMuaW5kZW50ID0gc3RhdGUuaW5kZW50ZWQ7XFxuICAgIHRoaXMuc3RhcnRPZkxpbmUgPSBzdGFydE9mTGluZTtcXG4gICAgaWYgKGNvbmZpZy5kb05vdEluZGVudC5oYXNPd25Qcm9wZXJ0eSh0YWdOYW1lKSB8fCAoc3RhdGUuY29udGV4dCAmJiBzdGF0ZS5jb250ZXh0Lm5vSW5kZW50KSlcXG4gICAgICB0aGlzLm5vSW5kZW50ID0gdHJ1ZTtcXG4gIH1cXG4gIGZ1bmN0aW9uIHBvcENvbnRleHQoc3RhdGUpIHtcXG4gICAgaWYgKHN0YXRlLmNvbnRleHQpIHN0YXRlLmNvbnRleHQgPSBzdGF0ZS5jb250ZXh0LnByZXY7XFxuICB9XFxuICBmdW5jdGlvbiBtYXliZVBvcENvbnRleHQoc3RhdGUsIG5leHRUYWdOYW1lKSB7XFxuICAgIHZhciBwYXJlbnRUYWdOYW1lO1xcbiAgICB3aGlsZSAodHJ1ZSkge1xcbiAgICAgIGlmICghc3RhdGUuY29udGV4dCkge1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICAgIH1cXG4gICAgICBwYXJlbnRUYWdOYW1lID0gc3RhdGUuY29udGV4dC50YWdOYW1lO1xcbiAgICAgIGlmICghY29uZmlnLmNvbnRleHRHcmFiYmVycy5oYXNPd25Qcm9wZXJ0eShwYXJlbnRUYWdOYW1lKSB8fFxcbiAgICAgICAgICAhY29uZmlnLmNvbnRleHRHcmFiYmVyc1twYXJlbnRUYWdOYW1lXS5oYXNPd25Qcm9wZXJ0eShuZXh0VGFnTmFtZSkpIHtcXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9XFxuICAgICAgcG9wQ29udGV4dChzdGF0ZSk7XFxuICAgIH1cXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIGJhc2VTdGF0ZSh0eXBlLCBzdHJlYW0sIHN0YXRlKSB7XFxuICAgIGlmICh0eXBlID09IFxcXCJvcGVuVGFnXFxcIikge1xcbiAgICAgIHN0YXRlLnRhZ1N0YXJ0ID0gc3RyZWFtLmNvbHVtbigpO1xcbiAgICAgIHJldHVybiB0YWdOYW1lU3RhdGU7XFxuICAgIH0gZWxzZSBpZiAodHlwZSA9PSBcXFwiY2xvc2VUYWdcXFwiKSB7XFxuICAgICAgcmV0dXJuIGNsb3NlVGFnTmFtZVN0YXRlO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIHJldHVybiBiYXNlU3RhdGU7XFxuICAgIH1cXG4gIH1cXG4gIGZ1bmN0aW9uIHRhZ05hbWVTdGF0ZSh0eXBlLCBzdHJlYW0sIHN0YXRlKSB7XFxuICAgIGlmICh0eXBlID09IFxcXCJ3b3JkXFxcIikge1xcbiAgICAgIHN0YXRlLnRhZ05hbWUgPSBzdHJlYW0uY3VycmVudCgpO1xcbiAgICAgIHNldFN0eWxlID0gXFxcInRhZ1xcXCI7XFxuICAgICAgcmV0dXJuIGF0dHJTdGF0ZTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICBzZXRTdHlsZSA9IFxcXCJlcnJvclxcXCI7XFxuICAgICAgcmV0dXJuIHRhZ05hbWVTdGF0ZTtcXG4gICAgfVxcbiAgfVxcbiAgZnVuY3Rpb24gY2xvc2VUYWdOYW1lU3RhdGUodHlwZSwgc3RyZWFtLCBzdGF0ZSkge1xcbiAgICBpZiAodHlwZSA9PSBcXFwid29yZFxcXCIpIHtcXG4gICAgICB2YXIgdGFnTmFtZSA9IHN0cmVhbS5jdXJyZW50KCk7XFxuICAgICAgaWYgKHN0YXRlLmNvbnRleHQgJiYgc3RhdGUuY29udGV4dC50YWdOYW1lICE9IHRhZ05hbWUgJiZcXG4gICAgICAgICAgY29uZmlnLmltcGxpY2l0bHlDbG9zZWQuaGFzT3duUHJvcGVydHkoc3RhdGUuY29udGV4dC50YWdOYW1lKSlcXG4gICAgICAgIHBvcENvbnRleHQoc3RhdGUpO1xcbiAgICAgIGlmICgoc3RhdGUuY29udGV4dCAmJiBzdGF0ZS5jb250ZXh0LnRhZ05hbWUgPT0gdGFnTmFtZSkgfHwgY29uZmlnLm1hdGNoQ2xvc2luZyA9PT0gZmFsc2UpIHtcXG4gICAgICAgIHNldFN0eWxlID0gXFxcInRhZ1xcXCI7XFxuICAgICAgICByZXR1cm4gY2xvc2VTdGF0ZTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgc2V0U3R5bGUgPSBcXFwidGFnIGVycm9yXFxcIjtcXG4gICAgICAgIHJldHVybiBjbG9zZVN0YXRlRXJyO1xcbiAgICAgIH1cXG4gICAgfSBlbHNlIHtcXG4gICAgICBzZXRTdHlsZSA9IFxcXCJlcnJvclxcXCI7XFxuICAgICAgcmV0dXJuIGNsb3NlU3RhdGVFcnI7XFxuICAgIH1cXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIGNsb3NlU3RhdGUodHlwZSwgX3N0cmVhbSwgc3RhdGUpIHtcXG4gICAgaWYgKHR5cGUgIT0gXFxcImVuZFRhZ1xcXCIpIHtcXG4gICAgICBzZXRTdHlsZSA9IFxcXCJlcnJvclxcXCI7XFxuICAgICAgcmV0dXJuIGNsb3NlU3RhdGU7XFxuICAgIH1cXG4gICAgcG9wQ29udGV4dChzdGF0ZSk7XFxuICAgIHJldHVybiBiYXNlU3RhdGU7XFxuICB9XFxuICBmdW5jdGlvbiBjbG9zZVN0YXRlRXJyKHR5cGUsIHN0cmVhbSwgc3RhdGUpIHtcXG4gICAgc2V0U3R5bGUgPSBcXFwiZXJyb3JcXFwiO1xcbiAgICByZXR1cm4gY2xvc2VTdGF0ZSh0eXBlLCBzdHJlYW0sIHN0YXRlKTtcXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIGF0dHJTdGF0ZSh0eXBlLCBfc3RyZWFtLCBzdGF0ZSkge1xcbiAgICBpZiAodHlwZSA9PSBcXFwid29yZFxcXCIpIHtcXG4gICAgICBzZXRTdHlsZSA9IFxcXCJhdHRyaWJ1dGVcXFwiO1xcbiAgICAgIHJldHVybiBhdHRyRXFTdGF0ZTtcXG4gICAgfSBlbHNlIGlmICh0eXBlID09IFxcXCJlbmRUYWdcXFwiIHx8IHR5cGUgPT0gXFxcInNlbGZjbG9zZVRhZ1xcXCIpIHtcXG4gICAgICB2YXIgdGFnTmFtZSA9IHN0YXRlLnRhZ05hbWUsIHRhZ1N0YXJ0ID0gc3RhdGUudGFnU3RhcnQ7XFxuICAgICAgc3RhdGUudGFnTmFtZSA9IHN0YXRlLnRhZ1N0YXJ0ID0gbnVsbDtcXG4gICAgICBpZiAodHlwZSA9PSBcXFwic2VsZmNsb3NlVGFnXFxcIiB8fFxcbiAgICAgICAgICBjb25maWcuYXV0b1NlbGZDbG9zZXJzLmhhc093blByb3BlcnR5KHRhZ05hbWUpKSB7XFxuICAgICAgICBtYXliZVBvcENvbnRleHQoc3RhdGUsIHRhZ05hbWUpO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBtYXliZVBvcENvbnRleHQoc3RhdGUsIHRhZ05hbWUpO1xcbiAgICAgICAgc3RhdGUuY29udGV4dCA9IG5ldyBDb250ZXh0KHN0YXRlLCB0YWdOYW1lLCB0YWdTdGFydCA9PSBzdGF0ZS5pbmRlbnRlZCk7XFxuICAgICAgfVxcbiAgICAgIHJldHVybiBiYXNlU3RhdGU7XFxuICAgIH1cXG4gICAgc2V0U3R5bGUgPSBcXFwiZXJyb3JcXFwiO1xcbiAgICByZXR1cm4gYXR0clN0YXRlO1xcbiAgfVxcbiAgZnVuY3Rpb24gYXR0ckVxU3RhdGUodHlwZSwgc3RyZWFtLCBzdGF0ZSkge1xcbiAgICBpZiAodHlwZSA9PSBcXFwiZXF1YWxzXFxcIikgcmV0dXJuIGF0dHJWYWx1ZVN0YXRlO1xcbiAgICBpZiAoIWNvbmZpZy5hbGxvd01pc3NpbmcpIHNldFN0eWxlID0gXFxcImVycm9yXFxcIjtcXG4gICAgcmV0dXJuIGF0dHJTdGF0ZSh0eXBlLCBzdHJlYW0sIHN0YXRlKTtcXG4gIH1cXG4gIGZ1bmN0aW9uIGF0dHJWYWx1ZVN0YXRlKHR5cGUsIHN0cmVhbSwgc3RhdGUpIHtcXG4gICAgaWYgKHR5cGUgPT0gXFxcInN0cmluZ1xcXCIpIHJldHVybiBhdHRyQ29udGludWVkU3RhdGU7XFxuICAgIGlmICh0eXBlID09IFxcXCJ3b3JkXFxcIiAmJiBjb25maWcuYWxsb3dVbnF1b3RlZCkge3NldFN0eWxlID0gXFxcInN0cmluZ1xcXCI7IHJldHVybiBhdHRyU3RhdGU7fVxcbiAgICBzZXRTdHlsZSA9IFxcXCJlcnJvclxcXCI7XFxuICAgIHJldHVybiBhdHRyU3RhdGUodHlwZSwgc3RyZWFtLCBzdGF0ZSk7XFxuICB9XFxuICBmdW5jdGlvbiBhdHRyQ29udGludWVkU3RhdGUodHlwZSwgc3RyZWFtLCBzdGF0ZSkge1xcbiAgICBpZiAodHlwZSA9PSBcXFwic3RyaW5nXFxcIikgcmV0dXJuIGF0dHJDb250aW51ZWRTdGF0ZTtcXG4gICAgcmV0dXJuIGF0dHJTdGF0ZSh0eXBlLCBzdHJlYW0sIHN0YXRlKTtcXG4gIH1cXG5cXG4gIHJldHVybiB7XFxuICAgIHN0YXJ0U3RhdGU6IGZ1bmN0aW9uKGJhc2VJbmRlbnQpIHtcXG4gICAgICB2YXIgc3RhdGUgPSB7dG9rZW5pemU6IGluVGV4dCxcXG4gICAgICAgICAgICAgICAgICAgc3RhdGU6IGJhc2VTdGF0ZSxcXG4gICAgICAgICAgICAgICAgICAgaW5kZW50ZWQ6IGJhc2VJbmRlbnQgfHwgMCxcXG4gICAgICAgICAgICAgICAgICAgdGFnTmFtZTogbnVsbCwgdGFnU3RhcnQ6IG51bGwsXFxuICAgICAgICAgICAgICAgICAgIGNvbnRleHQ6IG51bGx9XFxuICAgICAgaWYgKGJhc2VJbmRlbnQgIT0gbnVsbCkgc3RhdGUuYmFzZUluZGVudCA9IGJhc2VJbmRlbnRcXG4gICAgICByZXR1cm4gc3RhdGVcXG4gICAgfSxcXG5cXG4gICAgdG9rZW46IGZ1bmN0aW9uKHN0cmVhbSwgc3RhdGUpIHtcXG4gICAgICBpZiAoIXN0YXRlLnRhZ05hbWUgJiYgc3RyZWFtLnNvbCgpKVxcbiAgICAgICAgc3RhdGUuaW5kZW50ZWQgPSBzdHJlYW0uaW5kZW50YXRpb24oKTtcXG5cXG4gICAgICBpZiAoc3RyZWFtLmVhdFNwYWNlKCkpIHJldHVybiBudWxsO1xcbiAgICAgIHR5cGUgPSBudWxsO1xcbiAgICAgIHZhciBzdHlsZSA9IHN0YXRlLnRva2VuaXplKHN0cmVhbSwgc3RhdGUpO1xcbiAgICAgIGlmICgoc3R5bGUgfHwgdHlwZSkgJiYgc3R5bGUgIT0gXFxcImNvbW1lbnRcXFwiKSB7XFxuICAgICAgICBzZXRTdHlsZSA9IG51bGw7XFxuICAgICAgICBzdGF0ZS5zdGF0ZSA9IHN0YXRlLnN0YXRlKHR5cGUgfHwgc3R5bGUsIHN0cmVhbSwgc3RhdGUpO1xcbiAgICAgICAgaWYgKHNldFN0eWxlKVxcbiAgICAgICAgICBzdHlsZSA9IHNldFN0eWxlID09IFxcXCJlcnJvclxcXCIgPyBzdHlsZSArIFxcXCIgZXJyb3JcXFwiIDogc2V0U3R5bGU7XFxuICAgICAgfVxcbiAgICAgIHJldHVybiBzdHlsZTtcXG4gICAgfSxcXG5cXG4gICAgaW5kZW50OiBmdW5jdGlvbihzdGF0ZSwgdGV4dEFmdGVyLCBmdWxsTGluZSkge1xcbiAgICAgIHZhciBjb250ZXh0ID0gc3RhdGUuY29udGV4dDtcXG4gICAgICAvLyBJbmRlbnQgbXVsdGktbGluZSBzdHJpbmdzIChlLmcuIGNzcykuXFxuICAgICAgaWYgKHN0YXRlLnRva2VuaXplLmlzSW5BdHRyaWJ1dGUpIHtcXG4gICAgICAgIGlmIChzdGF0ZS50YWdTdGFydCA9PSBzdGF0ZS5pbmRlbnRlZClcXG4gICAgICAgICAgcmV0dXJuIHN0YXRlLnN0cmluZ1N0YXJ0Q29sICsgMTtcXG4gICAgICAgIGVsc2VcXG4gICAgICAgICAgcmV0dXJuIHN0YXRlLmluZGVudGVkICsgaW5kZW50VW5pdDtcXG4gICAgICB9XFxuICAgICAgaWYgKGNvbnRleHQgJiYgY29udGV4dC5ub0luZGVudCkgcmV0dXJuIENvZGVNaXJyb3IuUGFzcztcXG4gICAgICBpZiAoc3RhdGUudG9rZW5pemUgIT0gaW5UYWcgJiYgc3RhdGUudG9rZW5pemUgIT0gaW5UZXh0KVxcbiAgICAgICAgcmV0dXJuIGZ1bGxMaW5lID8gZnVsbExpbmUubWF0Y2goL14oXFxcXHMqKS8pWzBdLmxlbmd0aCA6IDA7XFxuICAgICAgLy8gSW5kZW50IHRoZSBzdGFydHMgb2YgYXR0cmlidXRlIG5hbWVzLlxcbiAgICAgIGlmIChzdGF0ZS50YWdOYW1lKSB7XFxuICAgICAgICBpZiAoY29uZmlnLm11bHRpbGluZVRhZ0luZGVudFBhc3RUYWcgIT09IGZhbHNlKVxcbiAgICAgICAgICByZXR1cm4gc3RhdGUudGFnU3RhcnQgKyBzdGF0ZS50YWdOYW1lLmxlbmd0aCArIDI7XFxuICAgICAgICBlbHNlXFxuICAgICAgICAgIHJldHVybiBzdGF0ZS50YWdTdGFydCArIGluZGVudFVuaXQgKiAoY29uZmlnLm11bHRpbGluZVRhZ0luZGVudEZhY3RvciB8fCAxKTtcXG4gICAgICB9XFxuICAgICAgaWYgKGNvbmZpZy5hbGlnbkNEQVRBICYmIC88IVxcXFxbQ0RBVEFcXFxcWy8udGVzdCh0ZXh0QWZ0ZXIpKSByZXR1cm4gMDtcXG4gICAgICB2YXIgdGFnQWZ0ZXIgPSB0ZXh0QWZ0ZXIgJiYgL148KFxcXFwvKT8oW1xcXFx3XzpcXFxcLi1dKikvLmV4ZWModGV4dEFmdGVyKTtcXG4gICAgICBpZiAodGFnQWZ0ZXIgJiYgdGFnQWZ0ZXJbMV0pIHsgLy8gQ2xvc2luZyB0YWcgc3BvdHRlZFxcbiAgICAgICAgd2hpbGUgKGNvbnRleHQpIHtcXG4gICAgICAgICAgaWYgKGNvbnRleHQudGFnTmFtZSA9PSB0YWdBZnRlclsyXSkge1xcbiAgICAgICAgICAgIGNvbnRleHQgPSBjb250ZXh0LnByZXY7XFxuICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgIH0gZWxzZSBpZiAoY29uZmlnLmltcGxpY2l0bHlDbG9zZWQuaGFzT3duUHJvcGVydHkoY29udGV4dC50YWdOYW1lKSkge1xcbiAgICAgICAgICAgIGNvbnRleHQgPSBjb250ZXh0LnByZXY7XFxuICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICB9IGVsc2UgaWYgKHRhZ0FmdGVyKSB7IC8vIE9wZW5pbmcgdGFnIHNwb3R0ZWRcXG4gICAgICAgIHdoaWxlIChjb250ZXh0KSB7XFxuICAgICAgICAgIHZhciBncmFiYmVycyA9IGNvbmZpZy5jb250ZXh0R3JhYmJlcnNbY29udGV4dC50YWdOYW1lXTtcXG4gICAgICAgICAgaWYgKGdyYWJiZXJzICYmIGdyYWJiZXJzLmhhc093blByb3BlcnR5KHRhZ0FmdGVyWzJdKSlcXG4gICAgICAgICAgICBjb250ZXh0ID0gY29udGV4dC5wcmV2O1xcbiAgICAgICAgICBlbHNlXFxuICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICAgIHdoaWxlIChjb250ZXh0ICYmIGNvbnRleHQucHJldiAmJiAhY29udGV4dC5zdGFydE9mTGluZSlcXG4gICAgICAgIGNvbnRleHQgPSBjb250ZXh0LnByZXY7XFxuICAgICAgaWYgKGNvbnRleHQpIHJldHVybiBjb250ZXh0LmluZGVudCArIGluZGVudFVuaXQ7XFxuICAgICAgZWxzZSByZXR1cm4gc3RhdGUuYmFzZUluZGVudCB8fCAwO1xcbiAgICB9LFxcblxcbiAgICBlbGVjdHJpY0lucHV0OiAvPFxcXFwvW1xcXFxzXFxcXHc6XSs+JC8sXFxuICAgIGJsb2NrQ29tbWVudFN0YXJ0OiBcXFwiPCEtLVxcXCIsXFxuICAgIGJsb2NrQ29tbWVudEVuZDogXFxcIi0tPlxcXCIsXFxuXFxuICAgIGNvbmZpZ3VyYXRpb246IGNvbmZpZy5odG1sTW9kZSA/IFxcXCJodG1sXFxcIiA6IFxcXCJ4bWxcXFwiLFxcbiAgICBoZWxwZXJUeXBlOiBjb25maWcuaHRtbE1vZGUgPyBcXFwiaHRtbFxcXCIgOiBcXFwieG1sXFxcIixcXG5cXG4gICAgc2tpcEF0dHJpYnV0ZTogZnVuY3Rpb24oc3RhdGUpIHtcXG4gICAgICBpZiAoc3RhdGUuc3RhdGUgPT0gYXR0clZhbHVlU3RhdGUpXFxuICAgICAgICBzdGF0ZS5zdGF0ZSA9IGF0dHJTdGF0ZVxcbiAgICB9XFxuICB9O1xcbn0pO1xcblxcbkNvZGVNaXJyb3IuZGVmaW5lTUlNRShcXFwidGV4dC94bWxcXFwiLCBcXFwieG1sXFxcIik7XFxuQ29kZU1pcnJvci5kZWZpbmVNSU1FKFxcXCJhcHBsaWNhdGlvbi94bWxcXFwiLCBcXFwieG1sXFxcIik7XFxuaWYgKCFDb2RlTWlycm9yLm1pbWVNb2Rlcy5oYXNPd25Qcm9wZXJ0eShcXFwidGV4dC9odG1sXFxcIikpXFxuICBDb2RlTWlycm9yLmRlZmluZU1JTUUoXFxcInRleHQvaHRtbFxcXCIsIHtuYW1lOiBcXFwieG1sXFxcIiwgaHRtbE1vZGU6IHRydWV9KTtcXG5cXG59KTtcXG5cIlxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yYXctbG9hZGVyIS4vfi9jb2RlbWlycm9yL21vZGUveG1sL3htbC5qc1xuLy8gbW9kdWxlIGlkID0gN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	eval("__webpack_require__(2)(__webpack_require__(9))//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL34vZnJvYWxhLWVkaXRvci9qcy9wbHVnaW5zL2FsaWduLm1pbi5qcz9jYzMxIl0sInNvdXJjZXNDb250ZW50IjpbInJlcXVpcmUoXCIhIS92YXIvYXBwL3dlYi9qcy9ub2RlX21vZHVsZXMvc2NyaXB0LWxvYWRlci9hZGRTY3JpcHQuanNcIikocmVxdWlyZShcIiEhL3Zhci9hcHAvd2ViL2pzL25vZGVfbW9kdWxlcy9yYXctbG9hZGVyL2luZGV4LmpzIS92YXIvYXBwL3dlYi9qcy9ub2RlX21vZHVsZXMvZnJvYWxhLWVkaXRvci9qcy9wbHVnaW5zL2FsaWduLm1pbi5qc1wiKSlcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vc2NyaXB0LWxvYWRlciEuL34vZnJvYWxhLWVkaXRvci9qcy9wbHVnaW5zL2FsaWduLm1pbi5qc1xuLy8gbW9kdWxlIGlkID0gOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 9 */
/***/ function(module, exports) {

	eval("module.exports = \"/*!\\n * froala_editor v2.3.5 (https://www.froala.com/wysiwyg-editor)\\n * License https://froala.com/wysiwyg-editor/terms/\\n * Copyright 2014-2016 Froala Labs\\n */\\n\\n!function(a){\\\"function\\\"==typeof define&&define.amd?define([\\\"jquery\\\"],a):\\\"object\\\"==typeof module&&module.exports?module.exports=function(b,c){return void 0===c&&(c=\\\"undefined\\\"!=typeof window?require(\\\"jquery\\\"):require(\\\"jquery\\\")(b)),a(c),c}:a(jQuery)}(function(a){a.FE.PLUGINS.align=function(b){function c(c){b.selection.save(),b.html.wrap(!0,!0,!0,!0),b.selection.restore();for(var d=b.selection.blocks(),e=0;e<d.length;e++)b.helpers.getAlignment(a(d[e].parentNode))==c?a(d[e]).css(\\\"text-align\\\",\\\"\\\").removeClass(\\\"fr-temp-div\\\"):a(d[e]).css(\\\"text-align\\\",c).removeClass(\\\"fr-temp-div\\\"),\\\"\\\"===a(d[e]).attr(\\\"class\\\")&&a(d[e]).removeAttr(\\\"class\\\"),\\\"\\\"===a(d[e]).attr(\\\"style\\\")&&a(d[e]).removeAttr(\\\"style\\\");b.selection.save(),b.html.unwrap(),b.selection.restore()}function d(c){var d=b.selection.blocks();if(d.length){var e=b.helpers.getAlignment(a(d[0]));c.find(\\\"> *:first\\\").replaceWith(b.icon.create(\\\"align-\\\"+e))}}function e(c,d){var e=b.selection.blocks();if(e.length){var f=b.helpers.getAlignment(a(e[0]));d.find('a.fr-command[data-param1=\\\"'+f+'\\\"]').addClass(\\\"fr-active\\\")}}return{apply:c,refresh:d,refreshOnShow:e}},a.FE.DefineIcon(\\\"align\\\",{NAME:\\\"align-left\\\"}),a.FE.DefineIcon(\\\"align-left\\\",{NAME:\\\"align-left\\\"}),a.FE.DefineIcon(\\\"align-right\\\",{NAME:\\\"align-right\\\"}),a.FE.DefineIcon(\\\"align-center\\\",{NAME:\\\"align-center\\\"}),a.FE.DefineIcon(\\\"align-justify\\\",{NAME:\\\"align-justify\\\"}),a.FE.RegisterCommand(\\\"align\\\",{type:\\\"dropdown\\\",title:\\\"Align\\\",options:{left:\\\"Align Left\\\",center:\\\"Align Center\\\",right:\\\"Align Right\\\",justify:\\\"Align Justify\\\"},html:function(){var b='<ul class=\\\"fr-dropdown-list\\\">',c=a.FE.COMMANDS.align.options;for(var d in c)c.hasOwnProperty(d)&&(b+='<li><a class=\\\"fr-command fr-title\\\" data-cmd=\\\"align\\\" data-param1=\\\"'+d+'\\\" title=\\\"'+this.language.translate(c[d])+'\\\">'+this.icon.create(\\\"align-\\\"+d)+\\\"</a></li>\\\");return b+=\\\"</ul>\\\"},callback:function(a,b){this.align.apply(b)},refresh:function(a){this.align.refresh(a)},refreshOnShow:function(a,b){this.align.refreshOnShow(a,b)},plugin:\\\"align\\\"})});\"//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL34vZnJvYWxhLWVkaXRvci9qcy9wbHVnaW5zL2FsaWduLm1pbi5qcz9iYmFkIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gXCIvKiFcXG4gKiBmcm9hbGFfZWRpdG9yIHYyLjMuNSAoaHR0cHM6Ly93d3cuZnJvYWxhLmNvbS93eXNpd3lnLWVkaXRvcilcXG4gKiBMaWNlbnNlIGh0dHBzOi8vZnJvYWxhLmNvbS93eXNpd3lnLWVkaXRvci90ZXJtcy9cXG4gKiBDb3B5cmlnaHQgMjAxNC0yMDE2IEZyb2FsYSBMYWJzXFxuICovXFxuXFxuIWZ1bmN0aW9uKGEpe1xcXCJmdW5jdGlvblxcXCI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQ/ZGVmaW5lKFtcXFwianF1ZXJ5XFxcIl0sYSk6XFxcIm9iamVjdFxcXCI9PXR5cGVvZiBtb2R1bGUmJm1vZHVsZS5leHBvcnRzP21vZHVsZS5leHBvcnRzPWZ1bmN0aW9uKGIsYyl7cmV0dXJuIHZvaWQgMD09PWMmJihjPVxcXCJ1bmRlZmluZWRcXFwiIT10eXBlb2Ygd2luZG93P3JlcXVpcmUoXFxcImpxdWVyeVxcXCIpOnJlcXVpcmUoXFxcImpxdWVyeVxcXCIpKGIpKSxhKGMpLGN9OmEoalF1ZXJ5KX0oZnVuY3Rpb24oYSl7YS5GRS5QTFVHSU5TLmFsaWduPWZ1bmN0aW9uKGIpe2Z1bmN0aW9uIGMoYyl7Yi5zZWxlY3Rpb24uc2F2ZSgpLGIuaHRtbC53cmFwKCEwLCEwLCEwLCEwKSxiLnNlbGVjdGlvbi5yZXN0b3JlKCk7Zm9yKHZhciBkPWIuc2VsZWN0aW9uLmJsb2NrcygpLGU9MDtlPGQubGVuZ3RoO2UrKyliLmhlbHBlcnMuZ2V0QWxpZ25tZW50KGEoZFtlXS5wYXJlbnROb2RlKSk9PWM/YShkW2VdKS5jc3MoXFxcInRleHQtYWxpZ25cXFwiLFxcXCJcXFwiKS5yZW1vdmVDbGFzcyhcXFwiZnItdGVtcC1kaXZcXFwiKTphKGRbZV0pLmNzcyhcXFwidGV4dC1hbGlnblxcXCIsYykucmVtb3ZlQ2xhc3MoXFxcImZyLXRlbXAtZGl2XFxcIiksXFxcIlxcXCI9PT1hKGRbZV0pLmF0dHIoXFxcImNsYXNzXFxcIikmJmEoZFtlXSkucmVtb3ZlQXR0cihcXFwiY2xhc3NcXFwiKSxcXFwiXFxcIj09PWEoZFtlXSkuYXR0cihcXFwic3R5bGVcXFwiKSYmYShkW2VdKS5yZW1vdmVBdHRyKFxcXCJzdHlsZVxcXCIpO2Iuc2VsZWN0aW9uLnNhdmUoKSxiLmh0bWwudW53cmFwKCksYi5zZWxlY3Rpb24ucmVzdG9yZSgpfWZ1bmN0aW9uIGQoYyl7dmFyIGQ9Yi5zZWxlY3Rpb24uYmxvY2tzKCk7aWYoZC5sZW5ndGgpe3ZhciBlPWIuaGVscGVycy5nZXRBbGlnbm1lbnQoYShkWzBdKSk7Yy5maW5kKFxcXCI+ICo6Zmlyc3RcXFwiKS5yZXBsYWNlV2l0aChiLmljb24uY3JlYXRlKFxcXCJhbGlnbi1cXFwiK2UpKX19ZnVuY3Rpb24gZShjLGQpe3ZhciBlPWIuc2VsZWN0aW9uLmJsb2NrcygpO2lmKGUubGVuZ3RoKXt2YXIgZj1iLmhlbHBlcnMuZ2V0QWxpZ25tZW50KGEoZVswXSkpO2QuZmluZCgnYS5mci1jb21tYW5kW2RhdGEtcGFyYW0xPVxcXCInK2YrJ1xcXCJdJykuYWRkQ2xhc3MoXFxcImZyLWFjdGl2ZVxcXCIpfX1yZXR1cm57YXBwbHk6YyxyZWZyZXNoOmQscmVmcmVzaE9uU2hvdzplfX0sYS5GRS5EZWZpbmVJY29uKFxcXCJhbGlnblxcXCIse05BTUU6XFxcImFsaWduLWxlZnRcXFwifSksYS5GRS5EZWZpbmVJY29uKFxcXCJhbGlnbi1sZWZ0XFxcIix7TkFNRTpcXFwiYWxpZ24tbGVmdFxcXCJ9KSxhLkZFLkRlZmluZUljb24oXFxcImFsaWduLXJpZ2h0XFxcIix7TkFNRTpcXFwiYWxpZ24tcmlnaHRcXFwifSksYS5GRS5EZWZpbmVJY29uKFxcXCJhbGlnbi1jZW50ZXJcXFwiLHtOQU1FOlxcXCJhbGlnbi1jZW50ZXJcXFwifSksYS5GRS5EZWZpbmVJY29uKFxcXCJhbGlnbi1qdXN0aWZ5XFxcIix7TkFNRTpcXFwiYWxpZ24tanVzdGlmeVxcXCJ9KSxhLkZFLlJlZ2lzdGVyQ29tbWFuZChcXFwiYWxpZ25cXFwiLHt0eXBlOlxcXCJkcm9wZG93blxcXCIsdGl0bGU6XFxcIkFsaWduXFxcIixvcHRpb25zOntsZWZ0OlxcXCJBbGlnbiBMZWZ0XFxcIixjZW50ZXI6XFxcIkFsaWduIENlbnRlclxcXCIscmlnaHQ6XFxcIkFsaWduIFJpZ2h0XFxcIixqdXN0aWZ5OlxcXCJBbGlnbiBKdXN0aWZ5XFxcIn0saHRtbDpmdW5jdGlvbigpe3ZhciBiPSc8dWwgY2xhc3M9XFxcImZyLWRyb3Bkb3duLWxpc3RcXFwiPicsYz1hLkZFLkNPTU1BTkRTLmFsaWduLm9wdGlvbnM7Zm9yKHZhciBkIGluIGMpYy5oYXNPd25Qcm9wZXJ0eShkKSYmKGIrPSc8bGk+PGEgY2xhc3M9XFxcImZyLWNvbW1hbmQgZnItdGl0bGVcXFwiIGRhdGEtY21kPVxcXCJhbGlnblxcXCIgZGF0YS1wYXJhbTE9XFxcIicrZCsnXFxcIiB0aXRsZT1cXFwiJyt0aGlzLmxhbmd1YWdlLnRyYW5zbGF0ZShjW2RdKSsnXFxcIj4nK3RoaXMuaWNvbi5jcmVhdGUoXFxcImFsaWduLVxcXCIrZCkrXFxcIjwvYT48L2xpPlxcXCIpO3JldHVybiBiKz1cXFwiPC91bD5cXFwifSxjYWxsYmFjazpmdW5jdGlvbihhLGIpe3RoaXMuYWxpZ24uYXBwbHkoYil9LHJlZnJlc2g6ZnVuY3Rpb24oYSl7dGhpcy5hbGlnbi5yZWZyZXNoKGEpfSxyZWZyZXNoT25TaG93OmZ1bmN0aW9uKGEsYil7dGhpcy5hbGlnbi5yZWZyZXNoT25TaG93KGEsYil9LHBsdWdpbjpcXFwiYWxpZ25cXFwifSl9KTtcIlxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yYXctbG9hZGVyIS4vfi9mcm9hbGEtZWRpdG9yL2pzL3BsdWdpbnMvYWxpZ24ubWluLmpzXG4vLyBtb2R1bGUgaWQgPSA5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	eval("__webpack_require__(2)(__webpack_require__(11))//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTAuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2Zyb2FsYS1lZGl0b3IvanMvcGx1Z2lucy9jaGFyX2NvdW50ZXIubWluLmpzPzc3YjEiXSwic291cmNlc0NvbnRlbnQiOlsicmVxdWlyZShcIiEhL3Zhci9hcHAvd2ViL2pzL25vZGVfbW9kdWxlcy9zY3JpcHQtbG9hZGVyL2FkZFNjcmlwdC5qc1wiKShyZXF1aXJlKFwiISEvdmFyL2FwcC93ZWIvanMvbm9kZV9tb2R1bGVzL3Jhdy1sb2FkZXIvaW5kZXguanMhL3Zhci9hcHAvd2ViL2pzL25vZGVfbW9kdWxlcy9mcm9hbGEtZWRpdG9yL2pzL3BsdWdpbnMvY2hhcl9jb3VudGVyLm1pbi5qc1wiKSlcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vc2NyaXB0LWxvYWRlciEuL34vZnJvYWxhLWVkaXRvci9qcy9wbHVnaW5zL2NoYXJfY291bnRlci5taW4uanNcbi8vIG1vZHVsZSBpZCA9IDEwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 11 */
/***/ function(module, exports) {

	eval("module.exports = \"/*!\\n * froala_editor v2.3.5 (https://www.froala.com/wysiwyg-editor)\\n * License https://froala.com/wysiwyg-editor/terms/\\n * Copyright 2014-2016 Froala Labs\\n */\\n\\n!function(a){\\\"function\\\"==typeof define&&define.amd?define([\\\"jquery\\\"],a):\\\"object\\\"==typeof module&&module.exports?module.exports=function(b,c){return void 0===c&&(c=\\\"undefined\\\"!=typeof window?require(\\\"jquery\\\"):require(\\\"jquery\\\")(b)),a(c),c}:a(jQuery)}(function(a){a.extend(a.FE.DEFAULTS,{charCounterMax:-1,charCounterCount:!0}),a.FE.PLUGINS.charCounter=function(b){function c(){return b.$el.text().length}function d(a){if(b.opts.charCounterMax<0)return!0;if(c()<b.opts.charCounterMax)return!0;var d=a.which;return!b.keys.ctrlKey(a)&&b.keys.isCharacter(d)?(a.preventDefault(),a.stopPropagation(),b.events.trigger(\\\"charCounter.exceeded\\\"),!1):!0}function e(d){if(b.opts.charCounterMax<0)return d;var e=a(\\\"<div>\\\").html(d).text().length;return e+c()<=b.opts.charCounterMax?d:(b.events.trigger(\\\"charCounter.exceeded\\\"),\\\"\\\")}function f(){if(b.opts.charCounterCount){var a=c()+(b.opts.charCounterMax>0?\\\"/\\\"+b.opts.charCounterMax:\\\"\\\");h.text(a),b.opts.toolbarBottom&&h.css(\\\"margin-bottom\\\",b.$tb.outerHeight(!0));var d=b.$wp.get(0).offsetWidth-b.$wp.get(0).clientWidth;d>=0&&(\\\"rtl\\\"==b.opts.direction?h.css(\\\"margin-left\\\",d):h.css(\\\"margin-right\\\",d))}}function g(){return b.$wp&&b.opts.charCounterCount?(h=a('<span class=\\\"fr-counter\\\"></span>'),h.css(\\\"bottom\\\",b.$wp.css(\\\"border-bottom-width\\\")),b.$box.append(h),b.events.on(\\\"keydown\\\",d,!0),b.events.on(\\\"paste.afterCleanup\\\",e),b.events.on(\\\"keyup contentChanged input\\\",function(){b.events.trigger(\\\"charCounter.update\\\")}),b.events.on(\\\"charCounter.update\\\",f),b.events.trigger(\\\"charCounter.update\\\"),void b.events.on(\\\"destroy\\\",function(){a(b.o_win).off(\\\"resize.char\\\"+b.id),h.removeData().remove(),h=null})):!1}var h;return{_init:g,count:c}}});\"//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTEuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2Zyb2FsYS1lZGl0b3IvanMvcGx1Z2lucy9jaGFyX2NvdW50ZXIubWluLmpzPzUwMWQiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBcIi8qIVxcbiAqIGZyb2FsYV9lZGl0b3IgdjIuMy41IChodHRwczovL3d3dy5mcm9hbGEuY29tL3d5c2l3eWctZWRpdG9yKVxcbiAqIExpY2Vuc2UgaHR0cHM6Ly9mcm9hbGEuY29tL3d5c2l3eWctZWRpdG9yL3Rlcm1zL1xcbiAqIENvcHlyaWdodCAyMDE0LTIwMTYgRnJvYWxhIExhYnNcXG4gKi9cXG5cXG4hZnVuY3Rpb24oYSl7XFxcImZ1bmN0aW9uXFxcIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUoW1xcXCJqcXVlcnlcXFwiXSxhKTpcXFwib2JqZWN0XFxcIj09dHlwZW9mIG1vZHVsZSYmbW9kdWxlLmV4cG9ydHM/bW9kdWxlLmV4cG9ydHM9ZnVuY3Rpb24oYixjKXtyZXR1cm4gdm9pZCAwPT09YyYmKGM9XFxcInVuZGVmaW5lZFxcXCIhPXR5cGVvZiB3aW5kb3c/cmVxdWlyZShcXFwianF1ZXJ5XFxcIik6cmVxdWlyZShcXFwianF1ZXJ5XFxcIikoYikpLGEoYyksY306YShqUXVlcnkpfShmdW5jdGlvbihhKXthLmV4dGVuZChhLkZFLkRFRkFVTFRTLHtjaGFyQ291bnRlck1heDotMSxjaGFyQ291bnRlckNvdW50OiEwfSksYS5GRS5QTFVHSU5TLmNoYXJDb3VudGVyPWZ1bmN0aW9uKGIpe2Z1bmN0aW9uIGMoKXtyZXR1cm4gYi4kZWwudGV4dCgpLmxlbmd0aH1mdW5jdGlvbiBkKGEpe2lmKGIub3B0cy5jaGFyQ291bnRlck1heDwwKXJldHVybiEwO2lmKGMoKTxiLm9wdHMuY2hhckNvdW50ZXJNYXgpcmV0dXJuITA7dmFyIGQ9YS53aGljaDtyZXR1cm4hYi5rZXlzLmN0cmxLZXkoYSkmJmIua2V5cy5pc0NoYXJhY3RlcihkKT8oYS5wcmV2ZW50RGVmYXVsdCgpLGEuc3RvcFByb3BhZ2F0aW9uKCksYi5ldmVudHMudHJpZ2dlcihcXFwiY2hhckNvdW50ZXIuZXhjZWVkZWRcXFwiKSwhMSk6ITB9ZnVuY3Rpb24gZShkKXtpZihiLm9wdHMuY2hhckNvdW50ZXJNYXg8MClyZXR1cm4gZDt2YXIgZT1hKFxcXCI8ZGl2PlxcXCIpLmh0bWwoZCkudGV4dCgpLmxlbmd0aDtyZXR1cm4gZStjKCk8PWIub3B0cy5jaGFyQ291bnRlck1heD9kOihiLmV2ZW50cy50cmlnZ2VyKFxcXCJjaGFyQ291bnRlci5leGNlZWRlZFxcXCIpLFxcXCJcXFwiKX1mdW5jdGlvbiBmKCl7aWYoYi5vcHRzLmNoYXJDb3VudGVyQ291bnQpe3ZhciBhPWMoKSsoYi5vcHRzLmNoYXJDb3VudGVyTWF4PjA/XFxcIi9cXFwiK2Iub3B0cy5jaGFyQ291bnRlck1heDpcXFwiXFxcIik7aC50ZXh0KGEpLGIub3B0cy50b29sYmFyQm90dG9tJiZoLmNzcyhcXFwibWFyZ2luLWJvdHRvbVxcXCIsYi4kdGIub3V0ZXJIZWlnaHQoITApKTt2YXIgZD1iLiR3cC5nZXQoMCkub2Zmc2V0V2lkdGgtYi4kd3AuZ2V0KDApLmNsaWVudFdpZHRoO2Q+PTAmJihcXFwicnRsXFxcIj09Yi5vcHRzLmRpcmVjdGlvbj9oLmNzcyhcXFwibWFyZ2luLWxlZnRcXFwiLGQpOmguY3NzKFxcXCJtYXJnaW4tcmlnaHRcXFwiLGQpKX19ZnVuY3Rpb24gZygpe3JldHVybiBiLiR3cCYmYi5vcHRzLmNoYXJDb3VudGVyQ291bnQ/KGg9YSgnPHNwYW4gY2xhc3M9XFxcImZyLWNvdW50ZXJcXFwiPjwvc3Bhbj4nKSxoLmNzcyhcXFwiYm90dG9tXFxcIixiLiR3cC5jc3MoXFxcImJvcmRlci1ib3R0b20td2lkdGhcXFwiKSksYi4kYm94LmFwcGVuZChoKSxiLmV2ZW50cy5vbihcXFwia2V5ZG93blxcXCIsZCwhMCksYi5ldmVudHMub24oXFxcInBhc3RlLmFmdGVyQ2xlYW51cFxcXCIsZSksYi5ldmVudHMub24oXFxcImtleXVwIGNvbnRlbnRDaGFuZ2VkIGlucHV0XFxcIixmdW5jdGlvbigpe2IuZXZlbnRzLnRyaWdnZXIoXFxcImNoYXJDb3VudGVyLnVwZGF0ZVxcXCIpfSksYi5ldmVudHMub24oXFxcImNoYXJDb3VudGVyLnVwZGF0ZVxcXCIsZiksYi5ldmVudHMudHJpZ2dlcihcXFwiY2hhckNvdW50ZXIudXBkYXRlXFxcIiksdm9pZCBiLmV2ZW50cy5vbihcXFwiZGVzdHJveVxcXCIsZnVuY3Rpb24oKXthKGIub193aW4pLm9mZihcXFwicmVzaXplLmNoYXJcXFwiK2IuaWQpLGgucmVtb3ZlRGF0YSgpLnJlbW92ZSgpLGg9bnVsbH0pKTohMX12YXIgaDtyZXR1cm57X2luaXQ6Zyxjb3VudDpjfX19KTtcIlxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yYXctbG9hZGVyIS4vfi9mcm9hbGEtZWRpdG9yL2pzL3BsdWdpbnMvY2hhcl9jb3VudGVyLm1pbi5qc1xuLy8gbW9kdWxlIGlkID0gMTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQSIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	eval("__webpack_require__(2)(__webpack_require__(13))//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTIuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2Zyb2FsYS1lZGl0b3IvanMvcGx1Z2lucy9jb2RlX3ZpZXcubWluLmpzPzljNWIiXSwic291cmNlc0NvbnRlbnQiOlsicmVxdWlyZShcIiEhL3Zhci9hcHAvd2ViL2pzL25vZGVfbW9kdWxlcy9zY3JpcHQtbG9hZGVyL2FkZFNjcmlwdC5qc1wiKShyZXF1aXJlKFwiISEvdmFyL2FwcC93ZWIvanMvbm9kZV9tb2R1bGVzL3Jhdy1sb2FkZXIvaW5kZXguanMhL3Zhci9hcHAvd2ViL2pzL25vZGVfbW9kdWxlcy9mcm9hbGEtZWRpdG9yL2pzL3BsdWdpbnMvY29kZV92aWV3Lm1pbi5qc1wiKSlcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vc2NyaXB0LWxvYWRlciEuL34vZnJvYWxhLWVkaXRvci9qcy9wbHVnaW5zL2NvZGVfdmlldy5taW4uanNcbi8vIG1vZHVsZSBpZCA9IDEyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 13 */
/***/ function(module, exports) {

	eval("module.exports = \"/*!\\n * froala_editor v2.3.5 (https://www.froala.com/wysiwyg-editor)\\n * License https://froala.com/wysiwyg-editor/terms/\\n * Copyright 2014-2016 Froala Labs\\n */\\n\\n!function(a){\\\"function\\\"==typeof define&&define.amd?define([\\\"jquery\\\"],a):\\\"object\\\"==typeof module&&module.exports?module.exports=function(b,c){return void 0===c&&(c=\\\"undefined\\\"!=typeof window?require(\\\"jquery\\\"):require(\\\"jquery\\\")(b)),a(c),c}:a(jQuery)}(function(a){a.extend(a.FE.DEFAULTS,{codeMirror:!0,codeMirrorOptions:{lineNumbers:!0,tabMode:\\\"indent\\\",indentWithTabs:!0,lineWrapping:!0,mode:\\\"text/html\\\",tabSize:2},codeBeautifierOptions:{end_with_newline:!0,indent_inner_html:!0,extra_liners:[\\\"p\\\",\\\"h1\\\",\\\"h2\\\",\\\"h3\\\",\\\"h4\\\",\\\"h5\\\",\\\"h6\\\",\\\"blockquote\\\",\\\"pre\\\",\\\"ul\\\",\\\"ol\\\",\\\"table\\\",\\\"dl\\\"],brace_style:\\\"expand\\\",indent_char:\\\"\\t\\\",indent_size:1,wrap_line_length:0},codeViewKeepActiveButtons:[\\\"fullscreen\\\"]}),a.FE.PLUGINS.codeView=function(b){function c(){return b.$box.hasClass(\\\"fr-code-view\\\")}function d(){return l?l.getValue():k.val()}function e(a){var c=d();b.html.set(c),b.$el.blur(),b.$tb.find(\\\" > .fr-command\\\").not(a).removeClass(\\\"fr-disabled\\\"),a.removeClass(\\\"fr-active\\\"),b.events.focus(!0),b.placeholder.refresh(),b.undo.saveStep()}function f(c){k||(i(),!l&&b.opts.codeMirror&&\\\"undefined\\\"!=typeof CodeMirror?l=CodeMirror.fromTextArea(k.get(0),b.opts.codeMirrorOptions):b.events.$on(k,\\\"keydown keyup change input\\\",function(){if(b.opts.height)this.rows=null;else if(this.rows||(this.rows=1),0===this.value.length)this.rows=1;else{for(this.style.height=\\\"auto\\\";this.rows>1&&this.scrollHeight<=this.offsetHeight;)this.rows-=1;for(;this.scrollHeight>this.offsetHeight&&(!b.opts.heightMax||this.offsetHeight<b.opts.heightMax);)this.rows+=1}})),b.undo.saveStep(),b.html.cleanEmptyTags(),b.html.cleanWhiteTags(!0),b.core.hasFocus()&&(b.core.isEmpty()||(b.selection.save(),b.$el.find('.fr-marker[data-type=\\\"true\\\"]:first').replaceWith('<span class=\\\"fr-tmp fr-sm\\\">F</span>'),b.$el.find('.fr-marker[data-type=\\\"false\\\"]:last').replaceWith('<span class=\\\"fr-tmp fr-em\\\">F</span>')));var d=b.html.get(!1,!0);b.$el.find(\\\"span.fr-tmp\\\").remove(),b.$box.toggleClass(\\\"fr-code-view\\\",!0),b.core.hasFocus()&&b.$el.blur(),d=d.replace(/<span class=\\\"fr-tmp fr-sm\\\">F<\\\\/span>/,\\\"FROALA-SM\\\"),d=d.replace(/<span class=\\\"fr-tmp fr-em\\\">F<\\\\/span>/,\\\"FROALA-EM\\\"),b.codeBeautifier&&(d=b.codeBeautifier.run(d,b.opts.codeBeautifierOptions));var e,f;if(l){e=d.indexOf(\\\"FROALA-SM\\\"),f=d.indexOf(\\\"FROALA-EM\\\"),e>f?e=f:f-=9,d=d.replace(/FROALA-SM/g,\\\"\\\").replace(/FROALA-EM/g,\\\"\\\");var g=d.substring(0,e).length-d.substring(0,e).replace(/\\\\n/g,\\\"\\\").length,h=d.substring(0,f).length-d.substring(0,f).replace(/\\\\n/g,\\\"\\\").length;e=d.substring(0,e).length-d.substring(0,d.substring(0,e).lastIndexOf(\\\"\\\\n\\\")+1).length,f=d.substring(0,f).length-d.substring(0,d.substring(0,f).lastIndexOf(\\\"\\\\n\\\")+1).length,l.setSize(null,b.opts.height?b.opts.height:\\\"auto\\\"),b.opts.heightMin&&b.$box.find(\\\".CodeMirror-scroll\\\").css(\\\"min-height\\\",b.opts.heightMin),l.setValue(d),l.focus(),l.setSelection({line:g,ch:e},{line:h,ch:f}),l.refresh(),l.clearHistory()}else{e=d.indexOf(\\\"FROALA-SM\\\"),f=d.indexOf(\\\"FROALA-EM\\\")-9,b.opts.heightMin&&k.css(\\\"min-height\\\",b.opts.heightMin),b.opts.height&&k.css(\\\"height\\\",b.opts.height),b.opts.heightMax&&k.css(\\\"max-height\\\",b.opts.height||b.opts.heightMax),k.val(d.replace(/FROALA-SM/g,\\\"\\\").replace(/FROALA-EM/g,\\\"\\\")).trigger(\\\"change\\\");var j=a(b.o_doc).scrollTop();k.focus(),k.get(0).setSelectionRange(e,f),a(b.o_doc).scrollTop(j)}b.$tb.find(\\\" > .fr-command\\\").not(c).filter(function(){return b.opts.codeViewKeepActiveButtons.indexOf(a(this).data(\\\"cmd\\\"))<0}).addClass(\\\"fr-disabled\\\"),c.addClass(\\\"fr-active\\\"),!b.helpers.isMobile()&&b.opts.toolbarInline&&b.toolbar.hide()}function g(a){\\\"undefined\\\"==typeof a&&(a=!c());var d=b.$tb.find('.fr-command[data-cmd=\\\"html\\\"]');a?(b.popups.hideAll(),f(d)):(b.$box.toggleClass(\\\"fr-code-view\\\",!1),e(d))}function h(){c()&&g(b.$tb.find('button[data-cmd=\\\"html\\\"]')),l&&l.toTextArea(),k.val(\\\"\\\").removeData().remove(),k=null,m&&(m.remove(),m=null)}function i(){k=a('<textarea class=\\\"fr-code\\\" tabindex=\\\"-1\\\">'),b.$wp.append(k),k.attr(\\\"dir\\\",b.opts.direction),b.$box.hasClass(\\\"fr-basic\\\")||(m=a('<a data-cmd=\\\"html\\\" title=\\\"Code View\\\" class=\\\"fr-command fr-btn html-switch'+(b.helpers.isMobile()?\\\"\\\":\\\" fr-desktop\\\")+'\\\" role=\\\"button\\\" tabindex=\\\"-1\\\"><i class=\\\"fa fa-code\\\"></i></button>'),b.$box.append(m),b.events.bindClick(b.$box,\\\"a.html-switch\\\",function(){g(!1)}));var e=function(){return!c()};b.events.on(\\\"buttons.refresh\\\",e),b.events.on(\\\"copy\\\",e,!0),b.events.on(\\\"cut\\\",e,!0),b.events.on(\\\"paste\\\",e,!0),b.events.on(\\\"destroy\\\",h,!0),b.events.on(\\\"html.set\\\",function(){c()&&g(!0)}),b.events.on(\\\"form.submit\\\",function(){c()&&(b.html.set(d()),b.events.trigger(\\\"contentChanged\\\",[],!0))},!0)}function j(){return b.$wp?void 0:!1}var k,l,m;return{_init:j,toggle:g,isActive:c,get:d}},a.FE.RegisterCommand(\\\"html\\\",{title:\\\"Code View\\\",undo:!1,focus:!1,forcedRefresh:!0,callback:function(){this.codeView.toggle()},plugin:\\\"codeView\\\"}),a.FE.DefineIcon(\\\"html\\\",{NAME:\\\"code\\\"})});\"//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2Zyb2FsYS1lZGl0b3IvanMvcGx1Z2lucy9jb2RlX3ZpZXcubWluLmpzPzg0ZjMiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBcIi8qIVxcbiAqIGZyb2FsYV9lZGl0b3IgdjIuMy41IChodHRwczovL3d3dy5mcm9hbGEuY29tL3d5c2l3eWctZWRpdG9yKVxcbiAqIExpY2Vuc2UgaHR0cHM6Ly9mcm9hbGEuY29tL3d5c2l3eWctZWRpdG9yL3Rlcm1zL1xcbiAqIENvcHlyaWdodCAyMDE0LTIwMTYgRnJvYWxhIExhYnNcXG4gKi9cXG5cXG4hZnVuY3Rpb24oYSl7XFxcImZ1bmN0aW9uXFxcIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUoW1xcXCJqcXVlcnlcXFwiXSxhKTpcXFwib2JqZWN0XFxcIj09dHlwZW9mIG1vZHVsZSYmbW9kdWxlLmV4cG9ydHM/bW9kdWxlLmV4cG9ydHM9ZnVuY3Rpb24oYixjKXtyZXR1cm4gdm9pZCAwPT09YyYmKGM9XFxcInVuZGVmaW5lZFxcXCIhPXR5cGVvZiB3aW5kb3c/cmVxdWlyZShcXFwianF1ZXJ5XFxcIik6cmVxdWlyZShcXFwianF1ZXJ5XFxcIikoYikpLGEoYyksY306YShqUXVlcnkpfShmdW5jdGlvbihhKXthLmV4dGVuZChhLkZFLkRFRkFVTFRTLHtjb2RlTWlycm9yOiEwLGNvZGVNaXJyb3JPcHRpb25zOntsaW5lTnVtYmVyczohMCx0YWJNb2RlOlxcXCJpbmRlbnRcXFwiLGluZGVudFdpdGhUYWJzOiEwLGxpbmVXcmFwcGluZzohMCxtb2RlOlxcXCJ0ZXh0L2h0bWxcXFwiLHRhYlNpemU6Mn0sY29kZUJlYXV0aWZpZXJPcHRpb25zOntlbmRfd2l0aF9uZXdsaW5lOiEwLGluZGVudF9pbm5lcl9odG1sOiEwLGV4dHJhX2xpbmVyczpbXFxcInBcXFwiLFxcXCJoMVxcXCIsXFxcImgyXFxcIixcXFwiaDNcXFwiLFxcXCJoNFxcXCIsXFxcImg1XFxcIixcXFwiaDZcXFwiLFxcXCJibG9ja3F1b3RlXFxcIixcXFwicHJlXFxcIixcXFwidWxcXFwiLFxcXCJvbFxcXCIsXFxcInRhYmxlXFxcIixcXFwiZGxcXFwiXSxicmFjZV9zdHlsZTpcXFwiZXhwYW5kXFxcIixpbmRlbnRfY2hhcjpcXFwiXFx0XFxcIixpbmRlbnRfc2l6ZToxLHdyYXBfbGluZV9sZW5ndGg6MH0sY29kZVZpZXdLZWVwQWN0aXZlQnV0dG9uczpbXFxcImZ1bGxzY3JlZW5cXFwiXX0pLGEuRkUuUExVR0lOUy5jb2RlVmlldz1mdW5jdGlvbihiKXtmdW5jdGlvbiBjKCl7cmV0dXJuIGIuJGJveC5oYXNDbGFzcyhcXFwiZnItY29kZS12aWV3XFxcIil9ZnVuY3Rpb24gZCgpe3JldHVybiBsP2wuZ2V0VmFsdWUoKTprLnZhbCgpfWZ1bmN0aW9uIGUoYSl7dmFyIGM9ZCgpO2IuaHRtbC5zZXQoYyksYi4kZWwuYmx1cigpLGIuJHRiLmZpbmQoXFxcIiA+IC5mci1jb21tYW5kXFxcIikubm90KGEpLnJlbW92ZUNsYXNzKFxcXCJmci1kaXNhYmxlZFxcXCIpLGEucmVtb3ZlQ2xhc3MoXFxcImZyLWFjdGl2ZVxcXCIpLGIuZXZlbnRzLmZvY3VzKCEwKSxiLnBsYWNlaG9sZGVyLnJlZnJlc2goKSxiLnVuZG8uc2F2ZVN0ZXAoKX1mdW5jdGlvbiBmKGMpe2t8fChpKCksIWwmJmIub3B0cy5jb2RlTWlycm9yJiZcXFwidW5kZWZpbmVkXFxcIiE9dHlwZW9mIENvZGVNaXJyb3I/bD1Db2RlTWlycm9yLmZyb21UZXh0QXJlYShrLmdldCgwKSxiLm9wdHMuY29kZU1pcnJvck9wdGlvbnMpOmIuZXZlbnRzLiRvbihrLFxcXCJrZXlkb3duIGtleXVwIGNoYW5nZSBpbnB1dFxcXCIsZnVuY3Rpb24oKXtpZihiLm9wdHMuaGVpZ2h0KXRoaXMucm93cz1udWxsO2Vsc2UgaWYodGhpcy5yb3dzfHwodGhpcy5yb3dzPTEpLDA9PT10aGlzLnZhbHVlLmxlbmd0aCl0aGlzLnJvd3M9MTtlbHNle2Zvcih0aGlzLnN0eWxlLmhlaWdodD1cXFwiYXV0b1xcXCI7dGhpcy5yb3dzPjEmJnRoaXMuc2Nyb2xsSGVpZ2h0PD10aGlzLm9mZnNldEhlaWdodDspdGhpcy5yb3dzLT0xO2Zvcig7dGhpcy5zY3JvbGxIZWlnaHQ+dGhpcy5vZmZzZXRIZWlnaHQmJighYi5vcHRzLmhlaWdodE1heHx8dGhpcy5vZmZzZXRIZWlnaHQ8Yi5vcHRzLmhlaWdodE1heCk7KXRoaXMucm93cys9MX19KSksYi51bmRvLnNhdmVTdGVwKCksYi5odG1sLmNsZWFuRW1wdHlUYWdzKCksYi5odG1sLmNsZWFuV2hpdGVUYWdzKCEwKSxiLmNvcmUuaGFzRm9jdXMoKSYmKGIuY29yZS5pc0VtcHR5KCl8fChiLnNlbGVjdGlvbi5zYXZlKCksYi4kZWwuZmluZCgnLmZyLW1hcmtlcltkYXRhLXR5cGU9XFxcInRydWVcXFwiXTpmaXJzdCcpLnJlcGxhY2VXaXRoKCc8c3BhbiBjbGFzcz1cXFwiZnItdG1wIGZyLXNtXFxcIj5GPC9zcGFuPicpLGIuJGVsLmZpbmQoJy5mci1tYXJrZXJbZGF0YS10eXBlPVxcXCJmYWxzZVxcXCJdOmxhc3QnKS5yZXBsYWNlV2l0aCgnPHNwYW4gY2xhc3M9XFxcImZyLXRtcCBmci1lbVxcXCI+Rjwvc3Bhbj4nKSkpO3ZhciBkPWIuaHRtbC5nZXQoITEsITApO2IuJGVsLmZpbmQoXFxcInNwYW4uZnItdG1wXFxcIikucmVtb3ZlKCksYi4kYm94LnRvZ2dsZUNsYXNzKFxcXCJmci1jb2RlLXZpZXdcXFwiLCEwKSxiLmNvcmUuaGFzRm9jdXMoKSYmYi4kZWwuYmx1cigpLGQ9ZC5yZXBsYWNlKC88c3BhbiBjbGFzcz1cXFwiZnItdG1wIGZyLXNtXFxcIj5GPFxcXFwvc3Bhbj4vLFxcXCJGUk9BTEEtU01cXFwiKSxkPWQucmVwbGFjZSgvPHNwYW4gY2xhc3M9XFxcImZyLXRtcCBmci1lbVxcXCI+RjxcXFxcL3NwYW4+LyxcXFwiRlJPQUxBLUVNXFxcIiksYi5jb2RlQmVhdXRpZmllciYmKGQ9Yi5jb2RlQmVhdXRpZmllci5ydW4oZCxiLm9wdHMuY29kZUJlYXV0aWZpZXJPcHRpb25zKSk7dmFyIGUsZjtpZihsKXtlPWQuaW5kZXhPZihcXFwiRlJPQUxBLVNNXFxcIiksZj1kLmluZGV4T2YoXFxcIkZST0FMQS1FTVxcXCIpLGU+Zj9lPWY6Zi09OSxkPWQucmVwbGFjZSgvRlJPQUxBLVNNL2csXFxcIlxcXCIpLnJlcGxhY2UoL0ZST0FMQS1FTS9nLFxcXCJcXFwiKTt2YXIgZz1kLnN1YnN0cmluZygwLGUpLmxlbmd0aC1kLnN1YnN0cmluZygwLGUpLnJlcGxhY2UoL1xcXFxuL2csXFxcIlxcXCIpLmxlbmd0aCxoPWQuc3Vic3RyaW5nKDAsZikubGVuZ3RoLWQuc3Vic3RyaW5nKDAsZikucmVwbGFjZSgvXFxcXG4vZyxcXFwiXFxcIikubGVuZ3RoO2U9ZC5zdWJzdHJpbmcoMCxlKS5sZW5ndGgtZC5zdWJzdHJpbmcoMCxkLnN1YnN0cmluZygwLGUpLmxhc3RJbmRleE9mKFxcXCJcXFxcblxcXCIpKzEpLmxlbmd0aCxmPWQuc3Vic3RyaW5nKDAsZikubGVuZ3RoLWQuc3Vic3RyaW5nKDAsZC5zdWJzdHJpbmcoMCxmKS5sYXN0SW5kZXhPZihcXFwiXFxcXG5cXFwiKSsxKS5sZW5ndGgsbC5zZXRTaXplKG51bGwsYi5vcHRzLmhlaWdodD9iLm9wdHMuaGVpZ2h0OlxcXCJhdXRvXFxcIiksYi5vcHRzLmhlaWdodE1pbiYmYi4kYm94LmZpbmQoXFxcIi5Db2RlTWlycm9yLXNjcm9sbFxcXCIpLmNzcyhcXFwibWluLWhlaWdodFxcXCIsYi5vcHRzLmhlaWdodE1pbiksbC5zZXRWYWx1ZShkKSxsLmZvY3VzKCksbC5zZXRTZWxlY3Rpb24oe2xpbmU6ZyxjaDplfSx7bGluZTpoLGNoOmZ9KSxsLnJlZnJlc2goKSxsLmNsZWFySGlzdG9yeSgpfWVsc2V7ZT1kLmluZGV4T2YoXFxcIkZST0FMQS1TTVxcXCIpLGY9ZC5pbmRleE9mKFxcXCJGUk9BTEEtRU1cXFwiKS05LGIub3B0cy5oZWlnaHRNaW4mJmsuY3NzKFxcXCJtaW4taGVpZ2h0XFxcIixiLm9wdHMuaGVpZ2h0TWluKSxiLm9wdHMuaGVpZ2h0JiZrLmNzcyhcXFwiaGVpZ2h0XFxcIixiLm9wdHMuaGVpZ2h0KSxiLm9wdHMuaGVpZ2h0TWF4JiZrLmNzcyhcXFwibWF4LWhlaWdodFxcXCIsYi5vcHRzLmhlaWdodHx8Yi5vcHRzLmhlaWdodE1heCksay52YWwoZC5yZXBsYWNlKC9GUk9BTEEtU00vZyxcXFwiXFxcIikucmVwbGFjZSgvRlJPQUxBLUVNL2csXFxcIlxcXCIpKS50cmlnZ2VyKFxcXCJjaGFuZ2VcXFwiKTt2YXIgaj1hKGIub19kb2MpLnNjcm9sbFRvcCgpO2suZm9jdXMoKSxrLmdldCgwKS5zZXRTZWxlY3Rpb25SYW5nZShlLGYpLGEoYi5vX2RvYykuc2Nyb2xsVG9wKGopfWIuJHRiLmZpbmQoXFxcIiA+IC5mci1jb21tYW5kXFxcIikubm90KGMpLmZpbHRlcihmdW5jdGlvbigpe3JldHVybiBiLm9wdHMuY29kZVZpZXdLZWVwQWN0aXZlQnV0dG9ucy5pbmRleE9mKGEodGhpcykuZGF0YShcXFwiY21kXFxcIikpPDB9KS5hZGRDbGFzcyhcXFwiZnItZGlzYWJsZWRcXFwiKSxjLmFkZENsYXNzKFxcXCJmci1hY3RpdmVcXFwiKSwhYi5oZWxwZXJzLmlzTW9iaWxlKCkmJmIub3B0cy50b29sYmFySW5saW5lJiZiLnRvb2xiYXIuaGlkZSgpfWZ1bmN0aW9uIGcoYSl7XFxcInVuZGVmaW5lZFxcXCI9PXR5cGVvZiBhJiYoYT0hYygpKTt2YXIgZD1iLiR0Yi5maW5kKCcuZnItY29tbWFuZFtkYXRhLWNtZD1cXFwiaHRtbFxcXCJdJyk7YT8oYi5wb3B1cHMuaGlkZUFsbCgpLGYoZCkpOihiLiRib3gudG9nZ2xlQ2xhc3MoXFxcImZyLWNvZGUtdmlld1xcXCIsITEpLGUoZCkpfWZ1bmN0aW9uIGgoKXtjKCkmJmcoYi4kdGIuZmluZCgnYnV0dG9uW2RhdGEtY21kPVxcXCJodG1sXFxcIl0nKSksbCYmbC50b1RleHRBcmVhKCksay52YWwoXFxcIlxcXCIpLnJlbW92ZURhdGEoKS5yZW1vdmUoKSxrPW51bGwsbSYmKG0ucmVtb3ZlKCksbT1udWxsKX1mdW5jdGlvbiBpKCl7az1hKCc8dGV4dGFyZWEgY2xhc3M9XFxcImZyLWNvZGVcXFwiIHRhYmluZGV4PVxcXCItMVxcXCI+JyksYi4kd3AuYXBwZW5kKGspLGsuYXR0cihcXFwiZGlyXFxcIixiLm9wdHMuZGlyZWN0aW9uKSxiLiRib3guaGFzQ2xhc3MoXFxcImZyLWJhc2ljXFxcIil8fChtPWEoJzxhIGRhdGEtY21kPVxcXCJodG1sXFxcIiB0aXRsZT1cXFwiQ29kZSBWaWV3XFxcIiBjbGFzcz1cXFwiZnItY29tbWFuZCBmci1idG4gaHRtbC1zd2l0Y2gnKyhiLmhlbHBlcnMuaXNNb2JpbGUoKT9cXFwiXFxcIjpcXFwiIGZyLWRlc2t0b3BcXFwiKSsnXFxcIiByb2xlPVxcXCJidXR0b25cXFwiIHRhYmluZGV4PVxcXCItMVxcXCI+PGkgY2xhc3M9XFxcImZhIGZhLWNvZGVcXFwiPjwvaT48L2J1dHRvbj4nKSxiLiRib3guYXBwZW5kKG0pLGIuZXZlbnRzLmJpbmRDbGljayhiLiRib3gsXFxcImEuaHRtbC1zd2l0Y2hcXFwiLGZ1bmN0aW9uKCl7ZyghMSl9KSk7dmFyIGU9ZnVuY3Rpb24oKXtyZXR1cm4hYygpfTtiLmV2ZW50cy5vbihcXFwiYnV0dG9ucy5yZWZyZXNoXFxcIixlKSxiLmV2ZW50cy5vbihcXFwiY29weVxcXCIsZSwhMCksYi5ldmVudHMub24oXFxcImN1dFxcXCIsZSwhMCksYi5ldmVudHMub24oXFxcInBhc3RlXFxcIixlLCEwKSxiLmV2ZW50cy5vbihcXFwiZGVzdHJveVxcXCIsaCwhMCksYi5ldmVudHMub24oXFxcImh0bWwuc2V0XFxcIixmdW5jdGlvbigpe2MoKSYmZyghMCl9KSxiLmV2ZW50cy5vbihcXFwiZm9ybS5zdWJtaXRcXFwiLGZ1bmN0aW9uKCl7YygpJiYoYi5odG1sLnNldChkKCkpLGIuZXZlbnRzLnRyaWdnZXIoXFxcImNvbnRlbnRDaGFuZ2VkXFxcIixbXSwhMCkpfSwhMCl9ZnVuY3Rpb24gaigpe3JldHVybiBiLiR3cD92b2lkIDA6ITF9dmFyIGssbCxtO3JldHVybntfaW5pdDpqLHRvZ2dsZTpnLGlzQWN0aXZlOmMsZ2V0OmR9fSxhLkZFLlJlZ2lzdGVyQ29tbWFuZChcXFwiaHRtbFxcXCIse3RpdGxlOlxcXCJDb2RlIFZpZXdcXFwiLHVuZG86ITEsZm9jdXM6ITEsZm9yY2VkUmVmcmVzaDohMCxjYWxsYmFjazpmdW5jdGlvbigpe3RoaXMuY29kZVZpZXcudG9nZ2xlKCl9LHBsdWdpbjpcXFwiY29kZVZpZXdcXFwifSksYS5GRS5EZWZpbmVJY29uKFxcXCJodG1sXFxcIix7TkFNRTpcXFwiY29kZVxcXCJ9KX0pO1wiXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3Jhdy1sb2FkZXIhLi9+L2Zyb2FsYS1lZGl0b3IvanMvcGx1Z2lucy9jb2RlX3ZpZXcubWluLmpzXG4vLyBtb2R1bGUgaWQgPSAxM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

	eval("__webpack_require__(2)(__webpack_require__(15))//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTQuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2Zyb2FsYS1lZGl0b3IvanMvcGx1Z2lucy9lbnRpdGllcy5taW4uanM/OTY4OCJdLCJzb3VyY2VzQ29udGVudCI6WyJyZXF1aXJlKFwiISEvdmFyL2FwcC93ZWIvanMvbm9kZV9tb2R1bGVzL3NjcmlwdC1sb2FkZXIvYWRkU2NyaXB0LmpzXCIpKHJlcXVpcmUoXCIhIS92YXIvYXBwL3dlYi9qcy9ub2RlX21vZHVsZXMvcmF3LWxvYWRlci9pbmRleC5qcyEvdmFyL2FwcC93ZWIvanMvbm9kZV9tb2R1bGVzL2Zyb2FsYS1lZGl0b3IvanMvcGx1Z2lucy9lbnRpdGllcy5taW4uanNcIikpXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3NjcmlwdC1sb2FkZXIhLi9+L2Zyb2FsYS1lZGl0b3IvanMvcGx1Z2lucy9lbnRpdGllcy5taW4uanNcbi8vIG1vZHVsZSBpZCA9IDE0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 15 */
/***/ function(module, exports) {

	eval("module.exports = \"/*!\\n * froala_editor v2.3.5 (https://www.froala.com/wysiwyg-editor)\\n * License https://froala.com/wysiwyg-editor/terms/\\n * Copyright 2014-2016 Froala Labs\\n */\\n\\n!function(a){\\\"function\\\"==typeof define&&define.amd?define([\\\"jquery\\\"],a):\\\"object\\\"==typeof module&&module.exports?module.exports=function(b,c){return void 0===c&&(c=\\\"undefined\\\"!=typeof window?require(\\\"jquery\\\"):require(\\\"jquery\\\")(b)),a(c),c}:a(jQuery)}(function(a){a.extend(a.FE.DEFAULTS,{entities:\\\"&quot;&#39;&iexcl;&cent;&pound;&curren;&yen;&brvbar;&sect;&uml;&copy;&ordf;&laquo;&not;&shy;&reg;&macr;&deg;&plusmn;&sup2;&sup3;&acute;&micro;&para;&middot;&cedil;&sup1;&ordm;&raquo;&frac14;&frac12;&frac34;&iquest;&Agrave;&Aacute;&Acirc;&Atilde;&Auml;&Aring;&AElig;&Ccedil;&Egrave;&Eacute;&Ecirc;&Euml;&Igrave;&Iacute;&Icirc;&Iuml;&ETH;&Ntilde;&Ograve;&Oacute;&Ocirc;&Otilde;&Ouml;&times;&Oslash;&Ugrave;&Uacute;&Ucirc;&Uuml;&Yacute;&THORN;&szlig;&agrave;&aacute;&acirc;&atilde;&auml;&aring;&aelig;&ccedil;&egrave;&eacute;&ecirc;&euml;&igrave;&iacute;&icirc;&iuml;&eth;&ntilde;&ograve;&oacute;&ocirc;&otilde;&ouml;&divide;&oslash;&ugrave;&uacute;&ucirc;&uuml;&yacute;&thorn;&yuml;&OElig;&oelig;&Scaron;&scaron;&Yuml;&fnof;&circ;&tilde;&Alpha;&Beta;&Gamma;&Delta;&Epsilon;&Zeta;&Eta;&Theta;&Iota;&Kappa;&Lambda;&Mu;&Nu;&Xi;&Omicron;&Pi;&Rho;&Sigma;&Tau;&Upsilon;&Phi;&Chi;&Psi;&Omega;&alpha;&beta;&gamma;&delta;&epsilon;&zeta;&eta;&theta;&iota;&kappa;&lambda;&mu;&nu;&xi;&omicron;&pi;&rho;&sigmaf;&sigma;&tau;&upsilon;&phi;&chi;&psi;&omega;&thetasym;&upsih;&piv;&ensp;&emsp;&thinsp;&zwnj;&zwj;&lrm;&rlm;&ndash;&mdash;&lsquo;&rsquo;&sbquo;&ldquo;&rdquo;&bdquo;&dagger;&Dagger;&bull;&hellip;&permil;&prime;&Prime;&lsaquo;&rsaquo;&oline;&frasl;&euro;&image;&weierp;&real;&trade;&alefsym;&larr;&uarr;&rarr;&darr;&harr;&crarr;&lArr;&uArr;&rArr;&dArr;&hArr;&forall;&part;&exist;&empty;&nabla;&isin;&notin;&ni;&prod;&sum;&minus;&lowast;&radic;&prop;&infin;&ang;&and;&or;&cap;&cup;&int;&there4;&sim;&cong;&asymp;&ne;&equiv;&le;&ge;&sub;&sup;&nsub;&sube;&supe;&oplus;&otimes;&perp;&sdot;&lceil;&rceil;&lfloor;&rfloor;&lang;&rang;&loz;&spades;&clubs;&hearts;&diams;\\\"}),a.FE.PLUGINS.entities=function(b){function c(a){var b=a.textContent;if(b.match(g)){for(var c=\\\"\\\",d=0;d<b.length;d++)c+=h[b[d]]?h[b[d]]:b[d];a.textContent=c}}function d(a){if(a&&[\\\"STYLE\\\",\\\"SCRIPT\\\"].indexOf(a.tagName)>=0)return!0;for(var e=b.node.contents(a),f=0;f<e.length;f++)e[f].nodeType==Node.TEXT_NODE?c(e[f]):d(e[f]);a.nodeType==Node.TEXT_NODE&&c(a)}function e(a){if(0===a.length)return\\\"\\\";var c=b.clean.exec(a,d).replace(/\\\\&amp;/g,\\\"&\\\");return c}function f(){b.opts.htmlSimpleAmpersand||(b.opts.entities=b.opts.entities+\\\"&amp;\\\");var c=a(\\\"<div>\\\").html(b.opts.entities).text(),d=b.opts.entities.split(\\\";\\\");h={},g=\\\"\\\";for(var f=0;f<c.length;f++){var i=c.charAt(f);h[i]=d[f]+\\\";\\\",g+=\\\"\\\\\\\\\\\"+i+(f<c.length-1?\\\"|\\\":\\\"\\\")}g=new RegExp(\\\"(\\\"+g+\\\")\\\",\\\"g\\\"),b.events.on(\\\"html.get\\\",e,!0)}var g,h;return{_init:f}}});\"//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTUuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2Zyb2FsYS1lZGl0b3IvanMvcGx1Z2lucy9lbnRpdGllcy5taW4uanM/ODViMiJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IFwiLyohXFxuICogZnJvYWxhX2VkaXRvciB2Mi4zLjUgKGh0dHBzOi8vd3d3LmZyb2FsYS5jb20vd3lzaXd5Zy1lZGl0b3IpXFxuICogTGljZW5zZSBodHRwczovL2Zyb2FsYS5jb20vd3lzaXd5Zy1lZGl0b3IvdGVybXMvXFxuICogQ29weXJpZ2h0IDIwMTQtMjAxNiBGcm9hbGEgTGFic1xcbiAqL1xcblxcbiFmdW5jdGlvbihhKXtcXFwiZnVuY3Rpb25cXFwiPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZShbXFxcImpxdWVyeVxcXCJdLGEpOlxcXCJvYmplY3RcXFwiPT10eXBlb2YgbW9kdWxlJiZtb2R1bGUuZXhwb3J0cz9tb2R1bGUuZXhwb3J0cz1mdW5jdGlvbihiLGMpe3JldHVybiB2b2lkIDA9PT1jJiYoYz1cXFwidW5kZWZpbmVkXFxcIiE9dHlwZW9mIHdpbmRvdz9yZXF1aXJlKFxcXCJqcXVlcnlcXFwiKTpyZXF1aXJlKFxcXCJqcXVlcnlcXFwiKShiKSksYShjKSxjfTphKGpRdWVyeSl9KGZ1bmN0aW9uKGEpe2EuZXh0ZW5kKGEuRkUuREVGQVVMVFMse2VudGl0aWVzOlxcXCImcXVvdDsmIzM5OyZpZXhjbDsmY2VudDsmcG91bmQ7JmN1cnJlbjsmeWVuOyZicnZiYXI7JnNlY3Q7JnVtbDsmY29weTsmb3JkZjsmbGFxdW87Jm5vdDsmc2h5OyZyZWc7Jm1hY3I7JmRlZzsmcGx1c21uOyZzdXAyOyZzdXAzOyZhY3V0ZTsmbWljcm87JnBhcmE7Jm1pZGRvdDsmY2VkaWw7JnN1cDE7Jm9yZG07JnJhcXVvOyZmcmFjMTQ7JmZyYWMxMjsmZnJhYzM0OyZpcXVlc3Q7JkFncmF2ZTsmQWFjdXRlOyZBY2lyYzsmQXRpbGRlOyZBdW1sOyZBcmluZzsmQUVsaWc7JkNjZWRpbDsmRWdyYXZlOyZFYWN1dGU7JkVjaXJjOyZFdW1sOyZJZ3JhdmU7JklhY3V0ZTsmSWNpcmM7Jkl1bWw7JkVUSDsmTnRpbGRlOyZPZ3JhdmU7Jk9hY3V0ZTsmT2NpcmM7Jk90aWxkZTsmT3VtbDsmdGltZXM7Jk9zbGFzaDsmVWdyYXZlOyZVYWN1dGU7JlVjaXJjOyZVdW1sOyZZYWN1dGU7JlRIT1JOOyZzemxpZzsmYWdyYXZlOyZhYWN1dGU7JmFjaXJjOyZhdGlsZGU7JmF1bWw7JmFyaW5nOyZhZWxpZzsmY2NlZGlsOyZlZ3JhdmU7JmVhY3V0ZTsmZWNpcmM7JmV1bWw7JmlncmF2ZTsmaWFjdXRlOyZpY2lyYzsmaXVtbDsmZXRoOyZudGlsZGU7Jm9ncmF2ZTsmb2FjdXRlOyZvY2lyYzsmb3RpbGRlOyZvdW1sOyZkaXZpZGU7Jm9zbGFzaDsmdWdyYXZlOyZ1YWN1dGU7JnVjaXJjOyZ1dW1sOyZ5YWN1dGU7JnRob3JuOyZ5dW1sOyZPRWxpZzsmb2VsaWc7JlNjYXJvbjsmc2Nhcm9uOyZZdW1sOyZmbm9mOyZjaXJjOyZ0aWxkZTsmQWxwaGE7JkJldGE7JkdhbW1hOyZEZWx0YTsmRXBzaWxvbjsmWmV0YTsmRXRhOyZUaGV0YTsmSW90YTsmS2FwcGE7JkxhbWJkYTsmTXU7Jk51OyZYaTsmT21pY3JvbjsmUGk7JlJobzsmU2lnbWE7JlRhdTsmVXBzaWxvbjsmUGhpOyZDaGk7JlBzaTsmT21lZ2E7JmFscGhhOyZiZXRhOyZnYW1tYTsmZGVsdGE7JmVwc2lsb247JnpldGE7JmV0YTsmdGhldGE7JmlvdGE7JmthcHBhOyZsYW1iZGE7Jm11OyZudTsmeGk7Jm9taWNyb247JnBpOyZyaG87JnNpZ21hZjsmc2lnbWE7JnRhdTsmdXBzaWxvbjsmcGhpOyZjaGk7JnBzaTsmb21lZ2E7JnRoZXRhc3ltOyZ1cHNpaDsmcGl2OyZlbnNwOyZlbXNwOyZ0aGluc3A7Jnp3bmo7Jnp3ajsmbHJtOyZybG07Jm5kYXNoOyZtZGFzaDsmbHNxdW87JnJzcXVvOyZzYnF1bzsmbGRxdW87JnJkcXVvOyZiZHF1bzsmZGFnZ2VyOyZEYWdnZXI7JmJ1bGw7JmhlbGxpcDsmcGVybWlsOyZwcmltZTsmUHJpbWU7JmxzYXF1bzsmcnNhcXVvOyZvbGluZTsmZnJhc2w7JmV1cm87JmltYWdlOyZ3ZWllcnA7JnJlYWw7JnRyYWRlOyZhbGVmc3ltOyZsYXJyOyZ1YXJyOyZyYXJyOyZkYXJyOyZoYXJyOyZjcmFycjsmbEFycjsmdUFycjsmckFycjsmZEFycjsmaEFycjsmZm9yYWxsOyZwYXJ0OyZleGlzdDsmZW1wdHk7Jm5hYmxhOyZpc2luOyZub3Rpbjsmbmk7JnByb2Q7JnN1bTsmbWludXM7Jmxvd2FzdDsmcmFkaWM7JnByb3A7JmluZmluOyZhbmc7JmFuZDsmb3I7JmNhcDsmY3VwOyZpbnQ7JnRoZXJlNDsmc2ltOyZjb25nOyZhc3ltcDsmbmU7JmVxdWl2OyZsZTsmZ2U7JnN1Yjsmc3VwOyZuc3ViOyZzdWJlOyZzdXBlOyZvcGx1czsmb3RpbWVzOyZwZXJwOyZzZG90OyZsY2VpbDsmcmNlaWw7JmxmbG9vcjsmcmZsb29yOyZsYW5nOyZyYW5nOyZsb3o7JnNwYWRlczsmY2x1YnM7JmhlYXJ0czsmZGlhbXM7XFxcIn0pLGEuRkUuUExVR0lOUy5lbnRpdGllcz1mdW5jdGlvbihiKXtmdW5jdGlvbiBjKGEpe3ZhciBiPWEudGV4dENvbnRlbnQ7aWYoYi5tYXRjaChnKSl7Zm9yKHZhciBjPVxcXCJcXFwiLGQ9MDtkPGIubGVuZ3RoO2QrKyljKz1oW2JbZF1dP2hbYltkXV06YltkXTthLnRleHRDb250ZW50PWN9fWZ1bmN0aW9uIGQoYSl7aWYoYSYmW1xcXCJTVFlMRVxcXCIsXFxcIlNDUklQVFxcXCJdLmluZGV4T2YoYS50YWdOYW1lKT49MClyZXR1cm4hMDtmb3IodmFyIGU9Yi5ub2RlLmNvbnRlbnRzKGEpLGY9MDtmPGUubGVuZ3RoO2YrKyllW2ZdLm5vZGVUeXBlPT1Ob2RlLlRFWFRfTk9ERT9jKGVbZl0pOmQoZVtmXSk7YS5ub2RlVHlwZT09Tm9kZS5URVhUX05PREUmJmMoYSl9ZnVuY3Rpb24gZShhKXtpZigwPT09YS5sZW5ndGgpcmV0dXJuXFxcIlxcXCI7dmFyIGM9Yi5jbGVhbi5leGVjKGEsZCkucmVwbGFjZSgvXFxcXCZhbXA7L2csXFxcIiZcXFwiKTtyZXR1cm4gY31mdW5jdGlvbiBmKCl7Yi5vcHRzLmh0bWxTaW1wbGVBbXBlcnNhbmR8fChiLm9wdHMuZW50aXRpZXM9Yi5vcHRzLmVudGl0aWVzK1xcXCImYW1wO1xcXCIpO3ZhciBjPWEoXFxcIjxkaXY+XFxcIikuaHRtbChiLm9wdHMuZW50aXRpZXMpLnRleHQoKSxkPWIub3B0cy5lbnRpdGllcy5zcGxpdChcXFwiO1xcXCIpO2g9e30sZz1cXFwiXFxcIjtmb3IodmFyIGY9MDtmPGMubGVuZ3RoO2YrKyl7dmFyIGk9Yy5jaGFyQXQoZik7aFtpXT1kW2ZdK1xcXCI7XFxcIixnKz1cXFwiXFxcXFxcXFxcXFwiK2krKGY8Yy5sZW5ndGgtMT9cXFwifFxcXCI6XFxcIlxcXCIpfWc9bmV3IFJlZ0V4cChcXFwiKFxcXCIrZytcXFwiKVxcXCIsXFxcImdcXFwiKSxiLmV2ZW50cy5vbihcXFwiaHRtbC5nZXRcXFwiLGUsITApfXZhciBnLGg7cmV0dXJue19pbml0OmZ9fX0pO1wiXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3Jhdy1sb2FkZXIhLi9+L2Zyb2FsYS1lZGl0b3IvanMvcGx1Z2lucy9lbnRpdGllcy5taW4uanNcbi8vIG1vZHVsZSBpZCA9IDE1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

	eval("__webpack_require__(2)(__webpack_require__(17))//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTYuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2Zyb2FsYS1lZGl0b3IvanMvcGx1Z2lucy9saW5rLm1pbi5qcz9lNGE2Il0sInNvdXJjZXNDb250ZW50IjpbInJlcXVpcmUoXCIhIS92YXIvYXBwL3dlYi9qcy9ub2RlX21vZHVsZXMvc2NyaXB0LWxvYWRlci9hZGRTY3JpcHQuanNcIikocmVxdWlyZShcIiEhL3Zhci9hcHAvd2ViL2pzL25vZGVfbW9kdWxlcy9yYXctbG9hZGVyL2luZGV4LmpzIS92YXIvYXBwL3dlYi9qcy9ub2RlX21vZHVsZXMvZnJvYWxhLWVkaXRvci9qcy9wbHVnaW5zL2xpbmsubWluLmpzXCIpKVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9zY3JpcHQtbG9hZGVyIS4vfi9mcm9hbGEtZWRpdG9yL2pzL3BsdWdpbnMvbGluay5taW4uanNcbi8vIG1vZHVsZSBpZCA9IDE2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 17 */
/***/ function(module, exports) {

	eval("module.exports = \"/*!\\n * froala_editor v2.3.5 (https://www.froala.com/wysiwyg-editor)\\n * License https://froala.com/wysiwyg-editor/terms/\\n * Copyright 2014-2016 Froala Labs\\n */\\n\\n!function(a){\\\"function\\\"==typeof define&&define.amd?define([\\\"jquery\\\"],a):\\\"object\\\"==typeof module&&module.exports?module.exports=function(b,c){return void 0===c&&(c=\\\"undefined\\\"!=typeof window?require(\\\"jquery\\\"):require(\\\"jquery\\\")(b)),a(c),c}:a(jQuery)}(function(a){a.extend(a.FE.POPUP_TEMPLATES,{\\\"link.edit\\\":\\\"[_BUTTONS_]\\\",\\\"link.insert\\\":\\\"[_BUTTONS_][_INPUT_LAYER_]\\\"}),a.extend(a.FE.DEFAULTS,{linkEditButtons:[\\\"linkOpen\\\",\\\"linkStyle\\\",\\\"linkEdit\\\",\\\"linkRemove\\\"],linkInsertButtons:[\\\"linkBack\\\",\\\"|\\\",\\\"linkList\\\"],linkAttributes:{},linkAutoPrefix:\\\"http://\\\",linkStyles:{\\\"fr-green\\\":\\\"Green\\\",\\\"fr-strong\\\":\\\"Thick\\\"},linkMultipleStyles:!0,linkConvertEmailAddress:!0,linkAlwaysBlank:!1,linkAlwaysNoFollow:!1,linkList:[{text:\\\"Froala\\\",href:\\\"https://froala.com\\\",target:\\\"_blank\\\"},{text:\\\"Google\\\",href:\\\"https://google.com\\\",target:\\\"_blank\\\"},{displayText:\\\"Facebook\\\",href:\\\"https://facebook.com\\\"}],linkText:!0}),a.FE.PLUGINS.link=function(b){function c(){var c=b.image?b.image.get():null;if(!c&&b.$wp){var d=b.selection.ranges(0).commonAncestorContainer;if(d&&\\\"A\\\"===d.tagName)return d;var e=b.selection.element(),f=b.selection.endElement();return\\\"A\\\"==e.tagName||b.node.isElement(e)||(e=a(e).parentsUntil(b.$el,\\\"a:first\\\").get(0)),\\\"A\\\"==f.tagName||b.node.isElement(f)||(f=a(f).parentsUntil(b.$el,\\\"a:first\\\").get(0)),f&&f==e&&\\\"A\\\"==f.tagName?e:null}return\\\"A\\\"==b.$el.get(0).tagName&&b.core.hasFocus()?b.$el.get(0):c&&c.get(0).parentNode&&\\\"A\\\"==c.get(0).parentNode.tagName?c.get(0).parentNode:void 0}function d(){var a=b.image?b.image.get():null,c=[];if(a)\\\"A\\\"==a.get(0).parentNode.tagName&&c.push(a.get(0).parentNode);else{var d,e,f,g;if(b.win.getSelection){var h=b.win.getSelection();if(h.getRangeAt&&h.rangeCount){g=b.doc.createRange();for(var i=0;i<h.rangeCount;++i)if(d=h.getRangeAt(i),e=d.commonAncestorContainer,e&&1!=e.nodeType&&(e=e.parentNode),e&&\\\"a\\\"==e.nodeName.toLowerCase())c.push(e);else{f=e.getElementsByTagName(\\\"a\\\");for(var j=0;j<f.length;++j)g.selectNodeContents(f[j]),g.compareBoundaryPoints(d.END_TO_START,d)<1&&g.compareBoundaryPoints(d.START_TO_END,d)>-1&&c.push(f[j])}}}else if(b.doc.selection&&\\\"Control\\\"!=b.doc.selection.type)if(d=b.doc.selection.createRange(),e=d.parentElement(),\\\"a\\\"==e.nodeName.toLowerCase())c.push(e);else{f=e.getElementsByTagName(\\\"a\\\"),g=b.doc.body.createTextRange();for(var k=0;k<f.length;++k)g.moveToElementText(f[k]),g.compareEndPoints(\\\"StartToEnd\\\",d)>-1&&g.compareEndPoints(\\\"EndToStart\\\",d)<1&&c.push(f[k])}}return c}function e(d){g(),setTimeout(function(){if(!d||d&&(1==d.which||\\\"mouseup\\\"!=d.type)){var e=c(),g=b.image?b.image.get():null;if(e&&!g){if(b.image){var h=b.node.contents(e);if(1==h.length&&\\\"IMG\\\"==h[0].tagName){var i=b.selection.ranges(0);return 0===i.startOffset&&0===i.endOffset?a(e).before(a.FE.MARKERS):a(e).after(a.FE.MARKERS),b.selection.restore(),!1}}d&&d.stopPropagation(),f(e)}}},b.helpers.isIOS()?100:0)}function f(c){var d=b.popups.get(\\\"link.edit\\\");d||(d=h());var e=a(c);b.popups.isVisible(\\\"link.edit\\\")||b.popups.refresh(\\\"link.edit\\\"),b.popups.setContainer(\\\"link.edit\\\",a(b.opts.scrollableContainer));var f=e.offset().left+a(c).outerWidth()/2,g=e.offset().top+e.outerHeight();b.popups.show(\\\"link.edit\\\",f,g,e.outerHeight())}function g(){b.popups.hide(\\\"link.edit\\\")}function h(){var a=\\\"\\\";b.opts.linkEditButtons.length>1&&(\\\"A\\\"==b.$el.get(0).tagName&&b.opts.linkEditButtons.indexOf(\\\"linkRemove\\\")>=0&&b.opts.linkEditButtons.splice(b.opts.linkEditButtons.indexOf(\\\"linkRemove\\\"),1),a='<div class=\\\"fr-buttons\\\">'+b.button.buildList(b.opts.linkEditButtons)+\\\"</div>\\\");var d={buttons:a},e=b.popups.create(\\\"link.edit\\\",d);return b.$wp&&b.events.$on(b.$wp,\\\"scroll.link-edit\\\",function(){c()&&b.popups.isVisible(\\\"link.edit\\\")&&f(c())}),e}function i(){}function j(){var d=b.popups.get(\\\"link.insert\\\"),e=c();if(e){var f,g,h=a(e),i=d.find('input.fr-link-attr[type=\\\"text\\\"]'),j=d.find('input.fr-link-attr[type=\\\"checkbox\\\"]');for(f=0;f<i.length;f++)g=a(i[f]),g.val(h.attr(g.attr(\\\"name\\\")||\\\"\\\"));for(j.prop(\\\"checked\\\",!1),f=0;f<j.length;f++)g=a(j[f]),h.attr(g.attr(\\\"name\\\"))==g.data(\\\"checked\\\")&&g.prop(\\\"checked\\\",!0);d.find('input.fr-link-attr[type=\\\"text\\\"][name=\\\"text\\\"]').val(h.text())}else d.find('input.fr-link-attr[type=\\\"text\\\"]').val(\\\"\\\"),d.find('input.fr-link-attr[type=\\\"checkbox\\\"]').prop(\\\"checked\\\",!1),d.find('input.fr-link-attr[type=\\\"text\\\"][name=\\\"text\\\"]').val(b.selection.text());d.find(\\\"input.fr-link-attr\\\").trigger(\\\"change\\\");var k=b.image?b.image.get():null;k?d.find('.fr-link-attr[name=\\\"text\\\"]').parent().hide():d.find('.fr-link-attr[name=\\\"text\\\"]').parent().show()}function k(){var c=b.$tb.find('.fr-command[data-cmd=\\\"insertLink\\\"]'),d=b.popups.get(\\\"link.insert\\\");if(d||(d=l()),!d.hasClass(\\\"fr-active\\\"))if(b.popups.refresh(\\\"link.insert\\\"),b.popups.setContainer(\\\"link.insert\\\",b.$tb||a(b.opts.scrollableContainer)),c.is(\\\":visible\\\")){var e=c.offset().left+c.outerWidth()/2,f=c.offset().top+(b.opts.toolbarBottom?10:c.outerHeight()-10);b.popups.show(\\\"link.insert\\\",e,f,c.outerHeight())}else b.position.forSelection(d),b.popups.show(\\\"link.insert\\\")}function l(a){if(a)return b.popups.onRefresh(\\\"link.insert\\\",j),b.popups.onHide(\\\"link.insert\\\",i),!0;var d=\\\"\\\";b.opts.linkInsertButtons.length>=1&&(d='<div class=\\\"fr-buttons\\\">'+b.button.buildList(b.opts.linkInsertButtons)+\\\"</div>\\\");var e='<svg version=\\\"1.1\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\" xmlns:xlink=\\\"http://www.w3.org/1999/xlink\\\" width=\\\"10\\\" height=\\\"10\\\" viewBox=\\\"0 0 32 32\\\"><path d=\\\"M27 4l-15 15-7-7-5 5 12 12 20-20z\\\" fill=\\\"#FFF\\\"></path></svg>',f=\\\"\\\",g=0;f='<div class=\\\"fr-link-insert-layer fr-layer fr-active\\\" id=\\\"fr-link-insert-layer-'+b.id+'\\\">',f+='<div class=\\\"fr-input-line\\\"><input name=\\\"href\\\" type=\\\"text\\\" class=\\\"fr-link-attr\\\" placeholder=\\\"URL\\\" tabIndex=\\\"'+ ++g+'\\\"></div>',b.opts.linkText&&(f+='<div class=\\\"fr-input-line\\\"><input name=\\\"text\\\" type=\\\"text\\\" class=\\\"fr-link-attr\\\" placeholder=\\\"'+b.language.translate(\\\"Text\\\")+'\\\" tabIndex=\\\"'+ ++g+'\\\"></div>');for(var h in b.opts.linkAttributes)if(b.opts.linkAttributes.hasOwnProperty(h)){var k=b.opts.linkAttributes[h];f+='<div class=\\\"fr-input-line\\\"><input name=\\\"'+h+'\\\" type=\\\"text\\\" class=\\\"fr-link-attr\\\" placeholder=\\\"'+b.language.translate(k)+'\\\" tabIndex=\\\"'+ ++g+'\\\"></div>'}b.opts.linkAlwaysBlank||(f+='<div class=\\\"fr-checkbox-line\\\"><span class=\\\"fr-checkbox\\\"><input name=\\\"target\\\" class=\\\"fr-link-attr\\\" data-checked=\\\"_blank\\\" type=\\\"checkbox\\\" id=\\\"fr-link-target-'+b.id+'\\\" tabIndex=\\\"'+ ++g+'\\\"><span>'+e+'</span></span><label for=\\\"fr-link-target-'+b.id+'\\\">'+b.language.translate(\\\"Open in new tab\\\")+\\\"</label></div>\\\"),f+='<div class=\\\"fr-action-buttons\\\"><button class=\\\"fr-command fr-submit\\\" data-cmd=\\\"linkInsert\\\" href=\\\"#\\\" tabIndex=\\\"'+ ++g+'\\\" type=\\\"button\\\">'+b.language.translate(\\\"Insert\\\")+\\\"</button></div></div>\\\";var l={buttons:d,input_layer:f},m=b.popups.create(\\\"link.insert\\\",l);return b.$wp&&b.events.$on(b.$wp,\\\"scroll.link-insert\\\",function(){var a=b.image?b.image.get():null;a&&b.popups.isVisible(\\\"link.insert\\\")&&u(),c&&b.popups.isVisible(\\\"link.insert\\\")&&s()}),m}function m(){var d=c(),e=b.image?b.image.get():null;return b.events.trigger(\\\"link.beforeRemove\\\",[d])===!1?!1:void(e&&d?(e.unwrap(),b.image.edit(e)):d&&(b.selection.save(),a(d).replaceWith(a(d).html()),b.selection.restore(),g()))}function n(){b.events.on(\\\"keyup\\\",function(b){b.which!=a.FE.KEYCODE.ESC&&e(b)}),b.events.on(\\\"window.mouseup\\\",e),b.helpers.isMobile()&&b.events.$on(b.$doc,\\\"selectionchange\\\",e),l(!0),\\\"A\\\"==b.$el.get(0).tagName&&b.$el.addClass(\\\"fr-view\\\")}function o(c){var d,e,f=b.opts.linkList[c],g=b.popups.get(\\\"link.insert\\\"),h=g.find('input.fr-link-attr[type=\\\"text\\\"]'),i=g.find('input.fr-link-attr[type=\\\"checkbox\\\"]');for(e=0;e<h.length;e++)d=a(h[e]),f[d.attr(\\\"name\\\")]?d.val(f[d.attr(\\\"name\\\")]):\\\"text\\\"!=d.attr(\\\"name\\\")&&d.val(\\\"\\\");for(e=0;e<i.length;e++)d=a(i[e]),d.prop(\\\"checked\\\",d.data(\\\"checked\\\")==f[d.attr(\\\"name\\\")])}function p(){var c,d,e=b.popups.get(\\\"link.insert\\\"),f=e.find('input.fr-link-attr[type=\\\"text\\\"]'),g=e.find('input.fr-link-attr[type=\\\"checkbox\\\"]'),h=f.filter('[name=\\\"href\\\"]').val(),i=f.filter('[name=\\\"text\\\"]').val(),j={};for(d=0;d<f.length;d++)c=a(f[d]),[\\\"href\\\",\\\"text\\\"].indexOf(c.attr(\\\"name\\\"))<0&&(j[c.attr(\\\"name\\\")]=c.val());for(d=0;d<g.length;d++)c=a(g[d]),c.is(\\\":checked\\\")?j[c.attr(\\\"name\\\")]=c.data(\\\"checked\\\"):j[c.attr(\\\"name\\\")]=c.data(\\\"unchecked\\\");var k=a(b.o_win).scrollTop();r(h,i,j),a(b.o_win).scrollTop(k)}function q(){if(!b.selection.isCollapsed()){b.selection.save();for(var c=b.$el.find(\\\".fr-marker\\\").addClass(\\\"fr-unprocessed\\\").toArray();c.length;){var d=a(c.pop());d.removeClass(\\\"fr-unprocessed\\\");var e=b.node.deepestParent(d.get(0));if(e){var f=d.get(0),g=\\\"\\\",h=\\\"\\\";do f=f.parentNode,b.node.isBlock(f)||(g+=b.node.closeTagString(f),h=b.node.openTagString(f)+h);while(f!=e);var i=b.node.openTagString(d.get(0))+d.html()+b.node.closeTagString(d.get(0));d.replaceWith('<span id=\\\"fr-break\\\"></span>');var j=a(e).html();j=j.replace(/<span id=\\\"fr-break\\\"><\\\\/span>/g,g+i+h),a(e).html(j)}c=b.$el.find(\\\".fr-marker.fr-unprocessed\\\").toArray()}b.selection.restore()}}function r(f,g,h){\\\"undefined\\\"==typeof h&&(h={});var i=b.image?b.image.get():null;i||\\\"A\\\"==b.$el.get(0).tagName?\\\"A\\\"==b.$el.get(0).tagName&&b.$el.focus():(b.selection.restore(),b.popups.hide(\\\"link.insert\\\"));var j=f;if(b.opts.linkConvertEmailAddress){var k=/^[\\\\w._]+@[a-z\\\\u00a1-\\\\uffff0-9_-]+?\\\\.[a-z\\\\u00a1-\\\\uffff0-9]{2,}$/i;k.test(f)&&!/^mailto:.*/i.test(f)&&(f=\\\"mailto:\\\"+f)}if(\\\"\\\"===b.opts.linkAutoPrefix||/^(mailto|tel|sms|notes|data):.*/i.test(f)||/^data:image.*/i.test(f)||/^(https?:|ftps?:|file:|)\\\\/\\\\//i.test(f)||[\\\"/\\\",\\\"{\\\",\\\"[\\\",\\\"#\\\",\\\"(\\\"].indexOf((f||\\\"\\\")[0])<0&&(f=b.opts.linkAutoPrefix+f),f=b.helpers.sanitizeURL(f),b.opts.linkAlwaysBlank&&(h.target=\\\"_blank\\\"),b.opts.linkAlwaysNoFollow&&(h.rel=\\\"nofollow\\\"),g=g||\\\"\\\",f===b.opts.linkAutoPrefix){var l=b.popups.get(\\\"link.insert\\\");return l.find('input[name=\\\"href\\\"]').addClass(\\\"fr-error\\\"),b.events.trigger(\\\"link.bad\\\",[j]),!1}var m,n=c();if(n){m=a(n);var o=b.node.rawAttributes(n);for(var p in o)o.hasOwnProperty(p)&&\\\"class\\\"!=p&&\\\"style\\\"!=p&&\\\"id\\\"!=p&&\\\"contenteditable\\\"!=p&&m.removeAttr(p);m.attr(\\\"href\\\",f),g.length>0&&m.text()!=g&&!i&&m.text(g),i||m.prepend(a.FE.START_MARKER).append(a.FE.END_MARKER),m.attr(h),i||b.selection.restore()}else{i?i.wrap('<a href=\\\"'+f+'\\\"></a>'):(b.format.remove(\\\"a\\\"),b.selection.isCollapsed()?(g=0===g.length?j:g,b.html.insert('<a href=\\\"'+f+'\\\">'+a.FE.START_MARKER+g+a.FE.END_MARKER+\\\"</a>\\\"),b.selection.restore()):g.length>0&&g!=b.selection.text().replace(/\\\\n/g,\\\"\\\")?(b.selection.remove(),b.html.insert('<a href=\\\"'+f+'\\\">'+a.FE.START_MARKER+g+a.FE.END_MARKER+\\\"</a>\\\"),b.selection.restore()):(q(),b.format.apply(\\\"a\\\",{href:f})));for(var r=d(),s=0;s<r.length;s++)m=a(r[s]),m.attr(h),m.removeAttr(\\\"_moz_dirty\\\");1==r.length&&b.$wp&&!i&&(a(r[0]).prepend(a.FE.START_MARKER).append(a.FE.END_MARKER),b.selection.restore())}if(i){var t=b.popups.get(\\\"link.insert\\\");t.find(\\\"input:focus\\\").blur(),b.image.edit(i)}else e()}function s(){g();var d=c();if(d){var e=b.popups.get(\\\"link.insert\\\");e||(e=l()),b.popups.isVisible(\\\"link.insert\\\")||(b.popups.refresh(\\\"link.insert\\\"),b.selection.save(),b.helpers.isMobile()&&(b.events.disableBlur(),b.$el.blur(),b.events.enableBlur())),b.popups.setContainer(\\\"link.insert\\\",a(b.opts.scrollableContainer));var f=(b.image?b.image.get():null)||a(d),h=f.offset().left+f.outerWidth()/2,i=f.offset().top+f.outerHeight();b.popups.show(\\\"link.insert\\\",h,i,f.outerHeight())}}function t(){var a=b.image?b.image.get():null;if(a)b.image.back();else{b.events.disableBlur(),b.selection.restore(),b.events.enableBlur();var d=c();d&&b.$wp?(b.selection.restore(),g(),e()):\\\"A\\\"==b.$el.get(0).tagName?(b.$el.focus(),e()):(b.popups.hide(\\\"link.insert\\\"),b.toolbar.showInline())}}function u(){var c=b.image?b.image.get():null;if(c){var d=b.popups.get(\\\"link.insert\\\");d||(d=l()),j(!0),b.popups.setContainer(\\\"link.insert\\\",a(b.opts.scrollableContainer));var e=c.offset().left+c.outerWidth()/2,f=c.offset().top+c.outerHeight();b.popups.show(\\\"link.insert\\\",e,f,c.outerHeight())}}function v(d,f,g){\\\"undefined\\\"==typeof g&&(g=b.opts.linkMultipleStyles),\\\"undefined\\\"==typeof f&&(f=b.opts.linkStyles);var h=c();if(!h)return!1;if(!g){var i=Object.keys(f);i.splice(i.indexOf(d),1),a(h).removeClass(i.join(\\\" \\\"))}a(h).toggleClass(d),e()}return{_init:n,remove:m,showInsertPopup:k,usePredefined:o,insertCallback:p,insert:r,update:s,get:c,allSelected:d,back:t,imageLink:u,applyStyle:v}},a.FE.DefineIcon(\\\"insertLink\\\",{NAME:\\\"link\\\"}),a.FE.RegisterShortcut(a.FE.KEYCODE.K,\\\"insertLink\\\",null,\\\"K\\\"),a.FE.RegisterCommand(\\\"insertLink\\\",{title:\\\"Insert Link\\\",undo:!1,focus:!0,refreshOnCallback:!1,popup:!0,callback:function(){this.popups.isVisible(\\\"link.insert\\\")?(this.$el.find(\\\".fr-marker\\\")&&(this.events.disableBlur(),this.selection.restore()),this.popups.hide(\\\"link.insert\\\")):this.link.showInsertPopup()},plugin:\\\"link\\\"}),a.FE.DefineIcon(\\\"linkOpen\\\",{NAME:\\\"external-link\\\"}),a.FE.RegisterCommand(\\\"linkOpen\\\",{title:\\\"Open Link\\\",undo:!1,refresh:function(a){var b=this.link.get();b?a.removeClass(\\\"fr-hidden\\\"):a.addClass(\\\"fr-hidden\\\")},callback:function(){var a=this.link.get();a&&this.o_win.open(a.href)}}),a.FE.DefineIcon(\\\"linkEdit\\\",{NAME:\\\"edit\\\"}),a.FE.RegisterCommand(\\\"linkEdit\\\",{title:\\\"Edit Link\\\",undo:!1,refreshAfterCallback:!1,callback:function(){this.link.update()},refresh:function(a){var b=this.link.get();b?a.removeClass(\\\"fr-hidden\\\"):a.addClass(\\\"fr-hidden\\\")}}),a.FE.DefineIcon(\\\"linkRemove\\\",{NAME:\\\"unlink\\\"}),a.FE.RegisterCommand(\\\"linkRemove\\\",{title:\\\"Unlink\\\",callback:function(){this.link.remove()},refresh:function(a){var b=this.link.get();b?a.removeClass(\\\"fr-hidden\\\"):a.addClass(\\\"fr-hidden\\\")}}),a.FE.DefineIcon(\\\"linkBack\\\",{NAME:\\\"arrow-left\\\"}),a.FE.RegisterCommand(\\\"linkBack\\\",{title:\\\"Back\\\",undo:!1,focus:!1,back:!0,refreshAfterCallback:!1,callback:function(){this.link.back()},refresh:function(a){var b=this.link.get(),c=this.image?this.image.get():null;c||b||this.opts.toolbarInline?(a.removeClass(\\\"fr-hidden\\\"),a.next(\\\".fr-separator\\\").removeClass(\\\"fr-hidden\\\")):(a.addClass(\\\"fr-hidden\\\"),a.next(\\\".fr-separator\\\").addClass(\\\"fr-hidden\\\"))}}),a.FE.DefineIcon(\\\"linkList\\\",{NAME:\\\"search\\\"}),a.FE.RegisterCommand(\\\"linkList\\\",{title:\\\"Choose Link\\\",type:\\\"dropdown\\\",focus:!1,undo:!1,refreshAfterCallback:!1,html:function(){for(var a='<ul class=\\\"fr-dropdown-list\\\">',b=this.opts.linkList,c=0;c<b.length;c++)a+='<li><a class=\\\"fr-command\\\" data-cmd=\\\"linkList\\\" data-param1=\\\"'+c+'\\\">'+(b[c].displayText||b[c].text)+\\\"</a></li>\\\";return a+=\\\"</ul>\\\"},callback:function(a,b){this.link.usePredefined(b)}}),a.FE.RegisterCommand(\\\"linkInsert\\\",{focus:!1,refreshAfterCallback:!1,callback:function(){this.link.insertCallback()},refresh:function(a){var b=this.link.get();b?a.text(this.language.translate(\\\"Update\\\")):a.text(this.language.translate(\\\"Insert\\\"))}}),a.FE.DefineIcon(\\\"imageLink\\\",{NAME:\\\"link\\\"}),a.FE.RegisterCommand(\\\"imageLink\\\",{title:\\\"Insert Link\\\",undo:!1,focus:!1,callback:function(){this.link.imageLink()},refresh:function(a){var b,c=this.link.get();c?(b=a.prev(),b.hasClass(\\\"fr-separator\\\")&&b.removeClass(\\\"fr-hidden\\\"),a.addClass(\\\"fr-hidden\\\")):(b=a.prev(),b.hasClass(\\\"fr-separator\\\")&&b.addClass(\\\"fr-hidden\\\"),a.removeClass(\\\"fr-hidden\\\"))}}),a.FE.DefineIcon(\\\"linkStyle\\\",{NAME:\\\"magic\\\"}),a.FE.RegisterCommand(\\\"linkStyle\\\",{title:\\\"Style\\\",type:\\\"dropdown\\\",html:function(){var a='<ul class=\\\"fr-dropdown-list\\\">',b=this.opts.linkStyles;for(var c in b)b.hasOwnProperty(c)&&(a+='<li><a class=\\\"fr-command\\\" data-cmd=\\\"linkStyle\\\" data-param1=\\\"'+c+'\\\">'+this.language.translate(b[c])+\\\"</a></li>\\\");return a+=\\\"</ul>\\\"},callback:function(a,b){this.link.applyStyle(b)},refreshOnShow:function(b,c){var d=this.link.get();if(d){var e=a(d);c.find(\\\".fr-command\\\").each(function(){var b=a(this).data(\\\"param1\\\");a(this).toggleClass(\\\"fr-active\\\",e.hasClass(b))})}}})});\"//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTcuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2Zyb2FsYS1lZGl0b3IvanMvcGx1Z2lucy9saW5rLm1pbi5qcz81MmY1Il0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gXCIvKiFcXG4gKiBmcm9hbGFfZWRpdG9yIHYyLjMuNSAoaHR0cHM6Ly93d3cuZnJvYWxhLmNvbS93eXNpd3lnLWVkaXRvcilcXG4gKiBMaWNlbnNlIGh0dHBzOi8vZnJvYWxhLmNvbS93eXNpd3lnLWVkaXRvci90ZXJtcy9cXG4gKiBDb3B5cmlnaHQgMjAxNC0yMDE2IEZyb2FsYSBMYWJzXFxuICovXFxuXFxuIWZ1bmN0aW9uKGEpe1xcXCJmdW5jdGlvblxcXCI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQ/ZGVmaW5lKFtcXFwianF1ZXJ5XFxcIl0sYSk6XFxcIm9iamVjdFxcXCI9PXR5cGVvZiBtb2R1bGUmJm1vZHVsZS5leHBvcnRzP21vZHVsZS5leHBvcnRzPWZ1bmN0aW9uKGIsYyl7cmV0dXJuIHZvaWQgMD09PWMmJihjPVxcXCJ1bmRlZmluZWRcXFwiIT10eXBlb2Ygd2luZG93P3JlcXVpcmUoXFxcImpxdWVyeVxcXCIpOnJlcXVpcmUoXFxcImpxdWVyeVxcXCIpKGIpKSxhKGMpLGN9OmEoalF1ZXJ5KX0oZnVuY3Rpb24oYSl7YS5leHRlbmQoYS5GRS5QT1BVUF9URU1QTEFURVMse1xcXCJsaW5rLmVkaXRcXFwiOlxcXCJbX0JVVFRPTlNfXVxcXCIsXFxcImxpbmsuaW5zZXJ0XFxcIjpcXFwiW19CVVRUT05TX11bX0lOUFVUX0xBWUVSX11cXFwifSksYS5leHRlbmQoYS5GRS5ERUZBVUxUUyx7bGlua0VkaXRCdXR0b25zOltcXFwibGlua09wZW5cXFwiLFxcXCJsaW5rU3R5bGVcXFwiLFxcXCJsaW5rRWRpdFxcXCIsXFxcImxpbmtSZW1vdmVcXFwiXSxsaW5rSW5zZXJ0QnV0dG9uczpbXFxcImxpbmtCYWNrXFxcIixcXFwifFxcXCIsXFxcImxpbmtMaXN0XFxcIl0sbGlua0F0dHJpYnV0ZXM6e30sbGlua0F1dG9QcmVmaXg6XFxcImh0dHA6Ly9cXFwiLGxpbmtTdHlsZXM6e1xcXCJmci1ncmVlblxcXCI6XFxcIkdyZWVuXFxcIixcXFwiZnItc3Ryb25nXFxcIjpcXFwiVGhpY2tcXFwifSxsaW5rTXVsdGlwbGVTdHlsZXM6ITAsbGlua0NvbnZlcnRFbWFpbEFkZHJlc3M6ITAsbGlua0Fsd2F5c0JsYW5rOiExLGxpbmtBbHdheXNOb0ZvbGxvdzohMSxsaW5rTGlzdDpbe3RleHQ6XFxcIkZyb2FsYVxcXCIsaHJlZjpcXFwiaHR0cHM6Ly9mcm9hbGEuY29tXFxcIix0YXJnZXQ6XFxcIl9ibGFua1xcXCJ9LHt0ZXh0OlxcXCJHb29nbGVcXFwiLGhyZWY6XFxcImh0dHBzOi8vZ29vZ2xlLmNvbVxcXCIsdGFyZ2V0OlxcXCJfYmxhbmtcXFwifSx7ZGlzcGxheVRleHQ6XFxcIkZhY2Vib29rXFxcIixocmVmOlxcXCJodHRwczovL2ZhY2Vib29rLmNvbVxcXCJ9XSxsaW5rVGV4dDohMH0pLGEuRkUuUExVR0lOUy5saW5rPWZ1bmN0aW9uKGIpe2Z1bmN0aW9uIGMoKXt2YXIgYz1iLmltYWdlP2IuaW1hZ2UuZ2V0KCk6bnVsbDtpZighYyYmYi4kd3Ape3ZhciBkPWIuc2VsZWN0aW9uLnJhbmdlcygwKS5jb21tb25BbmNlc3RvckNvbnRhaW5lcjtpZihkJiZcXFwiQVxcXCI9PT1kLnRhZ05hbWUpcmV0dXJuIGQ7dmFyIGU9Yi5zZWxlY3Rpb24uZWxlbWVudCgpLGY9Yi5zZWxlY3Rpb24uZW5kRWxlbWVudCgpO3JldHVyblxcXCJBXFxcIj09ZS50YWdOYW1lfHxiLm5vZGUuaXNFbGVtZW50KGUpfHwoZT1hKGUpLnBhcmVudHNVbnRpbChiLiRlbCxcXFwiYTpmaXJzdFxcXCIpLmdldCgwKSksXFxcIkFcXFwiPT1mLnRhZ05hbWV8fGIubm9kZS5pc0VsZW1lbnQoZil8fChmPWEoZikucGFyZW50c1VudGlsKGIuJGVsLFxcXCJhOmZpcnN0XFxcIikuZ2V0KDApKSxmJiZmPT1lJiZcXFwiQVxcXCI9PWYudGFnTmFtZT9lOm51bGx9cmV0dXJuXFxcIkFcXFwiPT1iLiRlbC5nZXQoMCkudGFnTmFtZSYmYi5jb3JlLmhhc0ZvY3VzKCk/Yi4kZWwuZ2V0KDApOmMmJmMuZ2V0KDApLnBhcmVudE5vZGUmJlxcXCJBXFxcIj09Yy5nZXQoMCkucGFyZW50Tm9kZS50YWdOYW1lP2MuZ2V0KDApLnBhcmVudE5vZGU6dm9pZCAwfWZ1bmN0aW9uIGQoKXt2YXIgYT1iLmltYWdlP2IuaW1hZ2UuZ2V0KCk6bnVsbCxjPVtdO2lmKGEpXFxcIkFcXFwiPT1hLmdldCgwKS5wYXJlbnROb2RlLnRhZ05hbWUmJmMucHVzaChhLmdldCgwKS5wYXJlbnROb2RlKTtlbHNle3ZhciBkLGUsZixnO2lmKGIud2luLmdldFNlbGVjdGlvbil7dmFyIGg9Yi53aW4uZ2V0U2VsZWN0aW9uKCk7aWYoaC5nZXRSYW5nZUF0JiZoLnJhbmdlQ291bnQpe2c9Yi5kb2MuY3JlYXRlUmFuZ2UoKTtmb3IodmFyIGk9MDtpPGgucmFuZ2VDb3VudDsrK2kpaWYoZD1oLmdldFJhbmdlQXQoaSksZT1kLmNvbW1vbkFuY2VzdG9yQ29udGFpbmVyLGUmJjEhPWUubm9kZVR5cGUmJihlPWUucGFyZW50Tm9kZSksZSYmXFxcImFcXFwiPT1lLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkpYy5wdXNoKGUpO2Vsc2V7Zj1lLmdldEVsZW1lbnRzQnlUYWdOYW1lKFxcXCJhXFxcIik7Zm9yKHZhciBqPTA7ajxmLmxlbmd0aDsrK2opZy5zZWxlY3ROb2RlQ29udGVudHMoZltqXSksZy5jb21wYXJlQm91bmRhcnlQb2ludHMoZC5FTkRfVE9fU1RBUlQsZCk8MSYmZy5jb21wYXJlQm91bmRhcnlQb2ludHMoZC5TVEFSVF9UT19FTkQsZCk+LTEmJmMucHVzaChmW2pdKX19fWVsc2UgaWYoYi5kb2Muc2VsZWN0aW9uJiZcXFwiQ29udHJvbFxcXCIhPWIuZG9jLnNlbGVjdGlvbi50eXBlKWlmKGQ9Yi5kb2Muc2VsZWN0aW9uLmNyZWF0ZVJhbmdlKCksZT1kLnBhcmVudEVsZW1lbnQoKSxcXFwiYVxcXCI9PWUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSljLnB1c2goZSk7ZWxzZXtmPWUuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXFxcImFcXFwiKSxnPWIuZG9jLmJvZHkuY3JlYXRlVGV4dFJhbmdlKCk7Zm9yKHZhciBrPTA7azxmLmxlbmd0aDsrK2spZy5tb3ZlVG9FbGVtZW50VGV4dChmW2tdKSxnLmNvbXBhcmVFbmRQb2ludHMoXFxcIlN0YXJ0VG9FbmRcXFwiLGQpPi0xJiZnLmNvbXBhcmVFbmRQb2ludHMoXFxcIkVuZFRvU3RhcnRcXFwiLGQpPDEmJmMucHVzaChmW2tdKX19cmV0dXJuIGN9ZnVuY3Rpb24gZShkKXtnKCksc2V0VGltZW91dChmdW5jdGlvbigpe2lmKCFkfHxkJiYoMT09ZC53aGljaHx8XFxcIm1vdXNldXBcXFwiIT1kLnR5cGUpKXt2YXIgZT1jKCksZz1iLmltYWdlP2IuaW1hZ2UuZ2V0KCk6bnVsbDtpZihlJiYhZyl7aWYoYi5pbWFnZSl7dmFyIGg9Yi5ub2RlLmNvbnRlbnRzKGUpO2lmKDE9PWgubGVuZ3RoJiZcXFwiSU1HXFxcIj09aFswXS50YWdOYW1lKXt2YXIgaT1iLnNlbGVjdGlvbi5yYW5nZXMoMCk7cmV0dXJuIDA9PT1pLnN0YXJ0T2Zmc2V0JiYwPT09aS5lbmRPZmZzZXQ/YShlKS5iZWZvcmUoYS5GRS5NQVJLRVJTKTphKGUpLmFmdGVyKGEuRkUuTUFSS0VSUyksYi5zZWxlY3Rpb24ucmVzdG9yZSgpLCExfX1kJiZkLnN0b3BQcm9wYWdhdGlvbigpLGYoZSl9fX0sYi5oZWxwZXJzLmlzSU9TKCk/MTAwOjApfWZ1bmN0aW9uIGYoYyl7dmFyIGQ9Yi5wb3B1cHMuZ2V0KFxcXCJsaW5rLmVkaXRcXFwiKTtkfHwoZD1oKCkpO3ZhciBlPWEoYyk7Yi5wb3B1cHMuaXNWaXNpYmxlKFxcXCJsaW5rLmVkaXRcXFwiKXx8Yi5wb3B1cHMucmVmcmVzaChcXFwibGluay5lZGl0XFxcIiksYi5wb3B1cHMuc2V0Q29udGFpbmVyKFxcXCJsaW5rLmVkaXRcXFwiLGEoYi5vcHRzLnNjcm9sbGFibGVDb250YWluZXIpKTt2YXIgZj1lLm9mZnNldCgpLmxlZnQrYShjKS5vdXRlcldpZHRoKCkvMixnPWUub2Zmc2V0KCkudG9wK2Uub3V0ZXJIZWlnaHQoKTtiLnBvcHVwcy5zaG93KFxcXCJsaW5rLmVkaXRcXFwiLGYsZyxlLm91dGVySGVpZ2h0KCkpfWZ1bmN0aW9uIGcoKXtiLnBvcHVwcy5oaWRlKFxcXCJsaW5rLmVkaXRcXFwiKX1mdW5jdGlvbiBoKCl7dmFyIGE9XFxcIlxcXCI7Yi5vcHRzLmxpbmtFZGl0QnV0dG9ucy5sZW5ndGg+MSYmKFxcXCJBXFxcIj09Yi4kZWwuZ2V0KDApLnRhZ05hbWUmJmIub3B0cy5saW5rRWRpdEJ1dHRvbnMuaW5kZXhPZihcXFwibGlua1JlbW92ZVxcXCIpPj0wJiZiLm9wdHMubGlua0VkaXRCdXR0b25zLnNwbGljZShiLm9wdHMubGlua0VkaXRCdXR0b25zLmluZGV4T2YoXFxcImxpbmtSZW1vdmVcXFwiKSwxKSxhPSc8ZGl2IGNsYXNzPVxcXCJmci1idXR0b25zXFxcIj4nK2IuYnV0dG9uLmJ1aWxkTGlzdChiLm9wdHMubGlua0VkaXRCdXR0b25zKStcXFwiPC9kaXY+XFxcIik7dmFyIGQ9e2J1dHRvbnM6YX0sZT1iLnBvcHVwcy5jcmVhdGUoXFxcImxpbmsuZWRpdFxcXCIsZCk7cmV0dXJuIGIuJHdwJiZiLmV2ZW50cy4kb24oYi4kd3AsXFxcInNjcm9sbC5saW5rLWVkaXRcXFwiLGZ1bmN0aW9uKCl7YygpJiZiLnBvcHVwcy5pc1Zpc2libGUoXFxcImxpbmsuZWRpdFxcXCIpJiZmKGMoKSl9KSxlfWZ1bmN0aW9uIGkoKXt9ZnVuY3Rpb24gaigpe3ZhciBkPWIucG9wdXBzLmdldChcXFwibGluay5pbnNlcnRcXFwiKSxlPWMoKTtpZihlKXt2YXIgZixnLGg9YShlKSxpPWQuZmluZCgnaW5wdXQuZnItbGluay1hdHRyW3R5cGU9XFxcInRleHRcXFwiXScpLGo9ZC5maW5kKCdpbnB1dC5mci1saW5rLWF0dHJbdHlwZT1cXFwiY2hlY2tib3hcXFwiXScpO2ZvcihmPTA7ZjxpLmxlbmd0aDtmKyspZz1hKGlbZl0pLGcudmFsKGguYXR0cihnLmF0dHIoXFxcIm5hbWVcXFwiKXx8XFxcIlxcXCIpKTtmb3Ioai5wcm9wKFxcXCJjaGVja2VkXFxcIiwhMSksZj0wO2Y8ai5sZW5ndGg7ZisrKWc9YShqW2ZdKSxoLmF0dHIoZy5hdHRyKFxcXCJuYW1lXFxcIikpPT1nLmRhdGEoXFxcImNoZWNrZWRcXFwiKSYmZy5wcm9wKFxcXCJjaGVja2VkXFxcIiwhMCk7ZC5maW5kKCdpbnB1dC5mci1saW5rLWF0dHJbdHlwZT1cXFwidGV4dFxcXCJdW25hbWU9XFxcInRleHRcXFwiXScpLnZhbChoLnRleHQoKSl9ZWxzZSBkLmZpbmQoJ2lucHV0LmZyLWxpbmstYXR0clt0eXBlPVxcXCJ0ZXh0XFxcIl0nKS52YWwoXFxcIlxcXCIpLGQuZmluZCgnaW5wdXQuZnItbGluay1hdHRyW3R5cGU9XFxcImNoZWNrYm94XFxcIl0nKS5wcm9wKFxcXCJjaGVja2VkXFxcIiwhMSksZC5maW5kKCdpbnB1dC5mci1saW5rLWF0dHJbdHlwZT1cXFwidGV4dFxcXCJdW25hbWU9XFxcInRleHRcXFwiXScpLnZhbChiLnNlbGVjdGlvbi50ZXh0KCkpO2QuZmluZChcXFwiaW5wdXQuZnItbGluay1hdHRyXFxcIikudHJpZ2dlcihcXFwiY2hhbmdlXFxcIik7dmFyIGs9Yi5pbWFnZT9iLmltYWdlLmdldCgpOm51bGw7az9kLmZpbmQoJy5mci1saW5rLWF0dHJbbmFtZT1cXFwidGV4dFxcXCJdJykucGFyZW50KCkuaGlkZSgpOmQuZmluZCgnLmZyLWxpbmstYXR0cltuYW1lPVxcXCJ0ZXh0XFxcIl0nKS5wYXJlbnQoKS5zaG93KCl9ZnVuY3Rpb24gaygpe3ZhciBjPWIuJHRiLmZpbmQoJy5mci1jb21tYW5kW2RhdGEtY21kPVxcXCJpbnNlcnRMaW5rXFxcIl0nKSxkPWIucG9wdXBzLmdldChcXFwibGluay5pbnNlcnRcXFwiKTtpZihkfHwoZD1sKCkpLCFkLmhhc0NsYXNzKFxcXCJmci1hY3RpdmVcXFwiKSlpZihiLnBvcHVwcy5yZWZyZXNoKFxcXCJsaW5rLmluc2VydFxcXCIpLGIucG9wdXBzLnNldENvbnRhaW5lcihcXFwibGluay5pbnNlcnRcXFwiLGIuJHRifHxhKGIub3B0cy5zY3JvbGxhYmxlQ29udGFpbmVyKSksYy5pcyhcXFwiOnZpc2libGVcXFwiKSl7dmFyIGU9Yy5vZmZzZXQoKS5sZWZ0K2Mub3V0ZXJXaWR0aCgpLzIsZj1jLm9mZnNldCgpLnRvcCsoYi5vcHRzLnRvb2xiYXJCb3R0b20/MTA6Yy5vdXRlckhlaWdodCgpLTEwKTtiLnBvcHVwcy5zaG93KFxcXCJsaW5rLmluc2VydFxcXCIsZSxmLGMub3V0ZXJIZWlnaHQoKSl9ZWxzZSBiLnBvc2l0aW9uLmZvclNlbGVjdGlvbihkKSxiLnBvcHVwcy5zaG93KFxcXCJsaW5rLmluc2VydFxcXCIpfWZ1bmN0aW9uIGwoYSl7aWYoYSlyZXR1cm4gYi5wb3B1cHMub25SZWZyZXNoKFxcXCJsaW5rLmluc2VydFxcXCIsaiksYi5wb3B1cHMub25IaWRlKFxcXCJsaW5rLmluc2VydFxcXCIsaSksITA7dmFyIGQ9XFxcIlxcXCI7Yi5vcHRzLmxpbmtJbnNlcnRCdXR0b25zLmxlbmd0aD49MSYmKGQ9JzxkaXYgY2xhc3M9XFxcImZyLWJ1dHRvbnNcXFwiPicrYi5idXR0b24uYnVpbGRMaXN0KGIub3B0cy5saW5rSW5zZXJ0QnV0dG9ucykrXFxcIjwvZGl2PlxcXCIpO3ZhciBlPSc8c3ZnIHZlcnNpb249XFxcIjEuMVxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIiB4bWxuczp4bGluaz1cXFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1xcXCIgd2lkdGg9XFxcIjEwXFxcIiBoZWlnaHQ9XFxcIjEwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMzIgMzJcXFwiPjxwYXRoIGQ9XFxcIk0yNyA0bC0xNSAxNS03LTctNSA1IDEyIDEyIDIwLTIwelxcXCIgZmlsbD1cXFwiI0ZGRlxcXCI+PC9wYXRoPjwvc3ZnPicsZj1cXFwiXFxcIixnPTA7Zj0nPGRpdiBjbGFzcz1cXFwiZnItbGluay1pbnNlcnQtbGF5ZXIgZnItbGF5ZXIgZnItYWN0aXZlXFxcIiBpZD1cXFwiZnItbGluay1pbnNlcnQtbGF5ZXItJytiLmlkKydcXFwiPicsZis9JzxkaXYgY2xhc3M9XFxcImZyLWlucHV0LWxpbmVcXFwiPjxpbnB1dCBuYW1lPVxcXCJocmVmXFxcIiB0eXBlPVxcXCJ0ZXh0XFxcIiBjbGFzcz1cXFwiZnItbGluay1hdHRyXFxcIiBwbGFjZWhvbGRlcj1cXFwiVVJMXFxcIiB0YWJJbmRleD1cXFwiJysgKytnKydcXFwiPjwvZGl2PicsYi5vcHRzLmxpbmtUZXh0JiYoZis9JzxkaXYgY2xhc3M9XFxcImZyLWlucHV0LWxpbmVcXFwiPjxpbnB1dCBuYW1lPVxcXCJ0ZXh0XFxcIiB0eXBlPVxcXCJ0ZXh0XFxcIiBjbGFzcz1cXFwiZnItbGluay1hdHRyXFxcIiBwbGFjZWhvbGRlcj1cXFwiJytiLmxhbmd1YWdlLnRyYW5zbGF0ZShcXFwiVGV4dFxcXCIpKydcXFwiIHRhYkluZGV4PVxcXCInKyArK2crJ1xcXCI+PC9kaXY+Jyk7Zm9yKHZhciBoIGluIGIub3B0cy5saW5rQXR0cmlidXRlcylpZihiLm9wdHMubGlua0F0dHJpYnV0ZXMuaGFzT3duUHJvcGVydHkoaCkpe3ZhciBrPWIub3B0cy5saW5rQXR0cmlidXRlc1toXTtmKz0nPGRpdiBjbGFzcz1cXFwiZnItaW5wdXQtbGluZVxcXCI+PGlucHV0IG5hbWU9XFxcIicraCsnXFxcIiB0eXBlPVxcXCJ0ZXh0XFxcIiBjbGFzcz1cXFwiZnItbGluay1hdHRyXFxcIiBwbGFjZWhvbGRlcj1cXFwiJytiLmxhbmd1YWdlLnRyYW5zbGF0ZShrKSsnXFxcIiB0YWJJbmRleD1cXFwiJysgKytnKydcXFwiPjwvZGl2Pid9Yi5vcHRzLmxpbmtBbHdheXNCbGFua3x8KGYrPSc8ZGl2IGNsYXNzPVxcXCJmci1jaGVja2JveC1saW5lXFxcIj48c3BhbiBjbGFzcz1cXFwiZnItY2hlY2tib3hcXFwiPjxpbnB1dCBuYW1lPVxcXCJ0YXJnZXRcXFwiIGNsYXNzPVxcXCJmci1saW5rLWF0dHJcXFwiIGRhdGEtY2hlY2tlZD1cXFwiX2JsYW5rXFxcIiB0eXBlPVxcXCJjaGVja2JveFxcXCIgaWQ9XFxcImZyLWxpbmstdGFyZ2V0LScrYi5pZCsnXFxcIiB0YWJJbmRleD1cXFwiJysgKytnKydcXFwiPjxzcGFuPicrZSsnPC9zcGFuPjwvc3Bhbj48bGFiZWwgZm9yPVxcXCJmci1saW5rLXRhcmdldC0nK2IuaWQrJ1xcXCI+JytiLmxhbmd1YWdlLnRyYW5zbGF0ZShcXFwiT3BlbiBpbiBuZXcgdGFiXFxcIikrXFxcIjwvbGFiZWw+PC9kaXY+XFxcIiksZis9JzxkaXYgY2xhc3M9XFxcImZyLWFjdGlvbi1idXR0b25zXFxcIj48YnV0dG9uIGNsYXNzPVxcXCJmci1jb21tYW5kIGZyLXN1Ym1pdFxcXCIgZGF0YS1jbWQ9XFxcImxpbmtJbnNlcnRcXFwiIGhyZWY9XFxcIiNcXFwiIHRhYkluZGV4PVxcXCInKyArK2crJ1xcXCIgdHlwZT1cXFwiYnV0dG9uXFxcIj4nK2IubGFuZ3VhZ2UudHJhbnNsYXRlKFxcXCJJbnNlcnRcXFwiKStcXFwiPC9idXR0b24+PC9kaXY+PC9kaXY+XFxcIjt2YXIgbD17YnV0dG9uczpkLGlucHV0X2xheWVyOmZ9LG09Yi5wb3B1cHMuY3JlYXRlKFxcXCJsaW5rLmluc2VydFxcXCIsbCk7cmV0dXJuIGIuJHdwJiZiLmV2ZW50cy4kb24oYi4kd3AsXFxcInNjcm9sbC5saW5rLWluc2VydFxcXCIsZnVuY3Rpb24oKXt2YXIgYT1iLmltYWdlP2IuaW1hZ2UuZ2V0KCk6bnVsbDthJiZiLnBvcHVwcy5pc1Zpc2libGUoXFxcImxpbmsuaW5zZXJ0XFxcIikmJnUoKSxjJiZiLnBvcHVwcy5pc1Zpc2libGUoXFxcImxpbmsuaW5zZXJ0XFxcIikmJnMoKX0pLG19ZnVuY3Rpb24gbSgpe3ZhciBkPWMoKSxlPWIuaW1hZ2U/Yi5pbWFnZS5nZXQoKTpudWxsO3JldHVybiBiLmV2ZW50cy50cmlnZ2VyKFxcXCJsaW5rLmJlZm9yZVJlbW92ZVxcXCIsW2RdKT09PSExPyExOnZvaWQoZSYmZD8oZS51bndyYXAoKSxiLmltYWdlLmVkaXQoZSkpOmQmJihiLnNlbGVjdGlvbi5zYXZlKCksYShkKS5yZXBsYWNlV2l0aChhKGQpLmh0bWwoKSksYi5zZWxlY3Rpb24ucmVzdG9yZSgpLGcoKSkpfWZ1bmN0aW9uIG4oKXtiLmV2ZW50cy5vbihcXFwia2V5dXBcXFwiLGZ1bmN0aW9uKGIpe2Iud2hpY2ghPWEuRkUuS0VZQ09ERS5FU0MmJmUoYil9KSxiLmV2ZW50cy5vbihcXFwid2luZG93Lm1vdXNldXBcXFwiLGUpLGIuaGVscGVycy5pc01vYmlsZSgpJiZiLmV2ZW50cy4kb24oYi4kZG9jLFxcXCJzZWxlY3Rpb25jaGFuZ2VcXFwiLGUpLGwoITApLFxcXCJBXFxcIj09Yi4kZWwuZ2V0KDApLnRhZ05hbWUmJmIuJGVsLmFkZENsYXNzKFxcXCJmci12aWV3XFxcIil9ZnVuY3Rpb24gbyhjKXt2YXIgZCxlLGY9Yi5vcHRzLmxpbmtMaXN0W2NdLGc9Yi5wb3B1cHMuZ2V0KFxcXCJsaW5rLmluc2VydFxcXCIpLGg9Zy5maW5kKCdpbnB1dC5mci1saW5rLWF0dHJbdHlwZT1cXFwidGV4dFxcXCJdJyksaT1nLmZpbmQoJ2lucHV0LmZyLWxpbmstYXR0clt0eXBlPVxcXCJjaGVja2JveFxcXCJdJyk7Zm9yKGU9MDtlPGgubGVuZ3RoO2UrKylkPWEoaFtlXSksZltkLmF0dHIoXFxcIm5hbWVcXFwiKV0/ZC52YWwoZltkLmF0dHIoXFxcIm5hbWVcXFwiKV0pOlxcXCJ0ZXh0XFxcIiE9ZC5hdHRyKFxcXCJuYW1lXFxcIikmJmQudmFsKFxcXCJcXFwiKTtmb3IoZT0wO2U8aS5sZW5ndGg7ZSsrKWQ9YShpW2VdKSxkLnByb3AoXFxcImNoZWNrZWRcXFwiLGQuZGF0YShcXFwiY2hlY2tlZFxcXCIpPT1mW2QuYXR0cihcXFwibmFtZVxcXCIpXSl9ZnVuY3Rpb24gcCgpe3ZhciBjLGQsZT1iLnBvcHVwcy5nZXQoXFxcImxpbmsuaW5zZXJ0XFxcIiksZj1lLmZpbmQoJ2lucHV0LmZyLWxpbmstYXR0clt0eXBlPVxcXCJ0ZXh0XFxcIl0nKSxnPWUuZmluZCgnaW5wdXQuZnItbGluay1hdHRyW3R5cGU9XFxcImNoZWNrYm94XFxcIl0nKSxoPWYuZmlsdGVyKCdbbmFtZT1cXFwiaHJlZlxcXCJdJykudmFsKCksaT1mLmZpbHRlcignW25hbWU9XFxcInRleHRcXFwiXScpLnZhbCgpLGo9e307Zm9yKGQ9MDtkPGYubGVuZ3RoO2QrKyljPWEoZltkXSksW1xcXCJocmVmXFxcIixcXFwidGV4dFxcXCJdLmluZGV4T2YoYy5hdHRyKFxcXCJuYW1lXFxcIikpPDAmJihqW2MuYXR0cihcXFwibmFtZVxcXCIpXT1jLnZhbCgpKTtmb3IoZD0wO2Q8Zy5sZW5ndGg7ZCsrKWM9YShnW2RdKSxjLmlzKFxcXCI6Y2hlY2tlZFxcXCIpP2pbYy5hdHRyKFxcXCJuYW1lXFxcIildPWMuZGF0YShcXFwiY2hlY2tlZFxcXCIpOmpbYy5hdHRyKFxcXCJuYW1lXFxcIildPWMuZGF0YShcXFwidW5jaGVja2VkXFxcIik7dmFyIGs9YShiLm9fd2luKS5zY3JvbGxUb3AoKTtyKGgsaSxqKSxhKGIub193aW4pLnNjcm9sbFRvcChrKX1mdW5jdGlvbiBxKCl7aWYoIWIuc2VsZWN0aW9uLmlzQ29sbGFwc2VkKCkpe2Iuc2VsZWN0aW9uLnNhdmUoKTtmb3IodmFyIGM9Yi4kZWwuZmluZChcXFwiLmZyLW1hcmtlclxcXCIpLmFkZENsYXNzKFxcXCJmci11bnByb2Nlc3NlZFxcXCIpLnRvQXJyYXkoKTtjLmxlbmd0aDspe3ZhciBkPWEoYy5wb3AoKSk7ZC5yZW1vdmVDbGFzcyhcXFwiZnItdW5wcm9jZXNzZWRcXFwiKTt2YXIgZT1iLm5vZGUuZGVlcGVzdFBhcmVudChkLmdldCgwKSk7aWYoZSl7dmFyIGY9ZC5nZXQoMCksZz1cXFwiXFxcIixoPVxcXCJcXFwiO2RvIGY9Zi5wYXJlbnROb2RlLGIubm9kZS5pc0Jsb2NrKGYpfHwoZys9Yi5ub2RlLmNsb3NlVGFnU3RyaW5nKGYpLGg9Yi5ub2RlLm9wZW5UYWdTdHJpbmcoZikraCk7d2hpbGUoZiE9ZSk7dmFyIGk9Yi5ub2RlLm9wZW5UYWdTdHJpbmcoZC5nZXQoMCkpK2QuaHRtbCgpK2Iubm9kZS5jbG9zZVRhZ1N0cmluZyhkLmdldCgwKSk7ZC5yZXBsYWNlV2l0aCgnPHNwYW4gaWQ9XFxcImZyLWJyZWFrXFxcIj48L3NwYW4+Jyk7dmFyIGo9YShlKS5odG1sKCk7aj1qLnJlcGxhY2UoLzxzcGFuIGlkPVxcXCJmci1icmVha1xcXCI+PFxcXFwvc3Bhbj4vZyxnK2kraCksYShlKS5odG1sKGopfWM9Yi4kZWwuZmluZChcXFwiLmZyLW1hcmtlci5mci11bnByb2Nlc3NlZFxcXCIpLnRvQXJyYXkoKX1iLnNlbGVjdGlvbi5yZXN0b3JlKCl9fWZ1bmN0aW9uIHIoZixnLGgpe1xcXCJ1bmRlZmluZWRcXFwiPT10eXBlb2YgaCYmKGg9e30pO3ZhciBpPWIuaW1hZ2U/Yi5pbWFnZS5nZXQoKTpudWxsO2l8fFxcXCJBXFxcIj09Yi4kZWwuZ2V0KDApLnRhZ05hbWU/XFxcIkFcXFwiPT1iLiRlbC5nZXQoMCkudGFnTmFtZSYmYi4kZWwuZm9jdXMoKTooYi5zZWxlY3Rpb24ucmVzdG9yZSgpLGIucG9wdXBzLmhpZGUoXFxcImxpbmsuaW5zZXJ0XFxcIikpO3ZhciBqPWY7aWYoYi5vcHRzLmxpbmtDb252ZXJ0RW1haWxBZGRyZXNzKXt2YXIgaz0vXltcXFxcdy5fXStAW2EtelxcXFx1MDBhMS1cXFxcdWZmZmYwLTlfLV0rP1xcXFwuW2EtelxcXFx1MDBhMS1cXFxcdWZmZmYwLTldezIsfSQvaTtrLnRlc3QoZikmJiEvXm1haWx0bzouKi9pLnRlc3QoZikmJihmPVxcXCJtYWlsdG86XFxcIitmKX1pZihcXFwiXFxcIj09PWIub3B0cy5saW5rQXV0b1ByZWZpeHx8L14obWFpbHRvfHRlbHxzbXN8bm90ZXN8ZGF0YSk6LiovaS50ZXN0KGYpfHwvXmRhdGE6aW1hZ2UuKi9pLnRlc3QoZil8fC9eKGh0dHBzPzp8ZnRwcz86fGZpbGU6fClcXFxcL1xcXFwvL2kudGVzdChmKXx8W1xcXCIvXFxcIixcXFwie1xcXCIsXFxcIltcXFwiLFxcXCIjXFxcIixcXFwiKFxcXCJdLmluZGV4T2YoKGZ8fFxcXCJcXFwiKVswXSk8MCYmKGY9Yi5vcHRzLmxpbmtBdXRvUHJlZml4K2YpLGY9Yi5oZWxwZXJzLnNhbml0aXplVVJMKGYpLGIub3B0cy5saW5rQWx3YXlzQmxhbmsmJihoLnRhcmdldD1cXFwiX2JsYW5rXFxcIiksYi5vcHRzLmxpbmtBbHdheXNOb0ZvbGxvdyYmKGgucmVsPVxcXCJub2ZvbGxvd1xcXCIpLGc9Z3x8XFxcIlxcXCIsZj09PWIub3B0cy5saW5rQXV0b1ByZWZpeCl7dmFyIGw9Yi5wb3B1cHMuZ2V0KFxcXCJsaW5rLmluc2VydFxcXCIpO3JldHVybiBsLmZpbmQoJ2lucHV0W25hbWU9XFxcImhyZWZcXFwiXScpLmFkZENsYXNzKFxcXCJmci1lcnJvclxcXCIpLGIuZXZlbnRzLnRyaWdnZXIoXFxcImxpbmsuYmFkXFxcIixbal0pLCExfXZhciBtLG49YygpO2lmKG4pe209YShuKTt2YXIgbz1iLm5vZGUucmF3QXR0cmlidXRlcyhuKTtmb3IodmFyIHAgaW4gbylvLmhhc093blByb3BlcnR5KHApJiZcXFwiY2xhc3NcXFwiIT1wJiZcXFwic3R5bGVcXFwiIT1wJiZcXFwiaWRcXFwiIT1wJiZcXFwiY29udGVudGVkaXRhYmxlXFxcIiE9cCYmbS5yZW1vdmVBdHRyKHApO20uYXR0cihcXFwiaHJlZlxcXCIsZiksZy5sZW5ndGg+MCYmbS50ZXh0KCkhPWcmJiFpJiZtLnRleHQoZyksaXx8bS5wcmVwZW5kKGEuRkUuU1RBUlRfTUFSS0VSKS5hcHBlbmQoYS5GRS5FTkRfTUFSS0VSKSxtLmF0dHIoaCksaXx8Yi5zZWxlY3Rpb24ucmVzdG9yZSgpfWVsc2V7aT9pLndyYXAoJzxhIGhyZWY9XFxcIicrZisnXFxcIj48L2E+Jyk6KGIuZm9ybWF0LnJlbW92ZShcXFwiYVxcXCIpLGIuc2VsZWN0aW9uLmlzQ29sbGFwc2VkKCk/KGc9MD09PWcubGVuZ3RoP2o6ZyxiLmh0bWwuaW5zZXJ0KCc8YSBocmVmPVxcXCInK2YrJ1xcXCI+JythLkZFLlNUQVJUX01BUktFUitnK2EuRkUuRU5EX01BUktFUitcXFwiPC9hPlxcXCIpLGIuc2VsZWN0aW9uLnJlc3RvcmUoKSk6Zy5sZW5ndGg+MCYmZyE9Yi5zZWxlY3Rpb24udGV4dCgpLnJlcGxhY2UoL1xcXFxuL2csXFxcIlxcXCIpPyhiLnNlbGVjdGlvbi5yZW1vdmUoKSxiLmh0bWwuaW5zZXJ0KCc8YSBocmVmPVxcXCInK2YrJ1xcXCI+JythLkZFLlNUQVJUX01BUktFUitnK2EuRkUuRU5EX01BUktFUitcXFwiPC9hPlxcXCIpLGIuc2VsZWN0aW9uLnJlc3RvcmUoKSk6KHEoKSxiLmZvcm1hdC5hcHBseShcXFwiYVxcXCIse2hyZWY6Zn0pKSk7Zm9yKHZhciByPWQoKSxzPTA7czxyLmxlbmd0aDtzKyspbT1hKHJbc10pLG0uYXR0cihoKSxtLnJlbW92ZUF0dHIoXFxcIl9tb3pfZGlydHlcXFwiKTsxPT1yLmxlbmd0aCYmYi4kd3AmJiFpJiYoYShyWzBdKS5wcmVwZW5kKGEuRkUuU1RBUlRfTUFSS0VSKS5hcHBlbmQoYS5GRS5FTkRfTUFSS0VSKSxiLnNlbGVjdGlvbi5yZXN0b3JlKCkpfWlmKGkpe3ZhciB0PWIucG9wdXBzLmdldChcXFwibGluay5pbnNlcnRcXFwiKTt0LmZpbmQoXFxcImlucHV0OmZvY3VzXFxcIikuYmx1cigpLGIuaW1hZ2UuZWRpdChpKX1lbHNlIGUoKX1mdW5jdGlvbiBzKCl7ZygpO3ZhciBkPWMoKTtpZihkKXt2YXIgZT1iLnBvcHVwcy5nZXQoXFxcImxpbmsuaW5zZXJ0XFxcIik7ZXx8KGU9bCgpKSxiLnBvcHVwcy5pc1Zpc2libGUoXFxcImxpbmsuaW5zZXJ0XFxcIil8fChiLnBvcHVwcy5yZWZyZXNoKFxcXCJsaW5rLmluc2VydFxcXCIpLGIuc2VsZWN0aW9uLnNhdmUoKSxiLmhlbHBlcnMuaXNNb2JpbGUoKSYmKGIuZXZlbnRzLmRpc2FibGVCbHVyKCksYi4kZWwuYmx1cigpLGIuZXZlbnRzLmVuYWJsZUJsdXIoKSkpLGIucG9wdXBzLnNldENvbnRhaW5lcihcXFwibGluay5pbnNlcnRcXFwiLGEoYi5vcHRzLnNjcm9sbGFibGVDb250YWluZXIpKTt2YXIgZj0oYi5pbWFnZT9iLmltYWdlLmdldCgpOm51bGwpfHxhKGQpLGg9Zi5vZmZzZXQoKS5sZWZ0K2Yub3V0ZXJXaWR0aCgpLzIsaT1mLm9mZnNldCgpLnRvcCtmLm91dGVySGVpZ2h0KCk7Yi5wb3B1cHMuc2hvdyhcXFwibGluay5pbnNlcnRcXFwiLGgsaSxmLm91dGVySGVpZ2h0KCkpfX1mdW5jdGlvbiB0KCl7dmFyIGE9Yi5pbWFnZT9iLmltYWdlLmdldCgpOm51bGw7aWYoYSliLmltYWdlLmJhY2soKTtlbHNle2IuZXZlbnRzLmRpc2FibGVCbHVyKCksYi5zZWxlY3Rpb24ucmVzdG9yZSgpLGIuZXZlbnRzLmVuYWJsZUJsdXIoKTt2YXIgZD1jKCk7ZCYmYi4kd3A/KGIuc2VsZWN0aW9uLnJlc3RvcmUoKSxnKCksZSgpKTpcXFwiQVxcXCI9PWIuJGVsLmdldCgwKS50YWdOYW1lPyhiLiRlbC5mb2N1cygpLGUoKSk6KGIucG9wdXBzLmhpZGUoXFxcImxpbmsuaW5zZXJ0XFxcIiksYi50b29sYmFyLnNob3dJbmxpbmUoKSl9fWZ1bmN0aW9uIHUoKXt2YXIgYz1iLmltYWdlP2IuaW1hZ2UuZ2V0KCk6bnVsbDtpZihjKXt2YXIgZD1iLnBvcHVwcy5nZXQoXFxcImxpbmsuaW5zZXJ0XFxcIik7ZHx8KGQ9bCgpKSxqKCEwKSxiLnBvcHVwcy5zZXRDb250YWluZXIoXFxcImxpbmsuaW5zZXJ0XFxcIixhKGIub3B0cy5zY3JvbGxhYmxlQ29udGFpbmVyKSk7dmFyIGU9Yy5vZmZzZXQoKS5sZWZ0K2Mub3V0ZXJXaWR0aCgpLzIsZj1jLm9mZnNldCgpLnRvcCtjLm91dGVySGVpZ2h0KCk7Yi5wb3B1cHMuc2hvdyhcXFwibGluay5pbnNlcnRcXFwiLGUsZixjLm91dGVySGVpZ2h0KCkpfX1mdW5jdGlvbiB2KGQsZixnKXtcXFwidW5kZWZpbmVkXFxcIj09dHlwZW9mIGcmJihnPWIub3B0cy5saW5rTXVsdGlwbGVTdHlsZXMpLFxcXCJ1bmRlZmluZWRcXFwiPT10eXBlb2YgZiYmKGY9Yi5vcHRzLmxpbmtTdHlsZXMpO3ZhciBoPWMoKTtpZighaClyZXR1cm4hMTtpZighZyl7dmFyIGk9T2JqZWN0LmtleXMoZik7aS5zcGxpY2UoaS5pbmRleE9mKGQpLDEpLGEoaCkucmVtb3ZlQ2xhc3MoaS5qb2luKFxcXCIgXFxcIikpfWEoaCkudG9nZ2xlQ2xhc3MoZCksZSgpfXJldHVybntfaW5pdDpuLHJlbW92ZTptLHNob3dJbnNlcnRQb3B1cDprLHVzZVByZWRlZmluZWQ6byxpbnNlcnRDYWxsYmFjazpwLGluc2VydDpyLHVwZGF0ZTpzLGdldDpjLGFsbFNlbGVjdGVkOmQsYmFjazp0LGltYWdlTGluazp1LGFwcGx5U3R5bGU6dn19LGEuRkUuRGVmaW5lSWNvbihcXFwiaW5zZXJ0TGlua1xcXCIse05BTUU6XFxcImxpbmtcXFwifSksYS5GRS5SZWdpc3RlclNob3J0Y3V0KGEuRkUuS0VZQ09ERS5LLFxcXCJpbnNlcnRMaW5rXFxcIixudWxsLFxcXCJLXFxcIiksYS5GRS5SZWdpc3RlckNvbW1hbmQoXFxcImluc2VydExpbmtcXFwiLHt0aXRsZTpcXFwiSW5zZXJ0IExpbmtcXFwiLHVuZG86ITEsZm9jdXM6ITAscmVmcmVzaE9uQ2FsbGJhY2s6ITEscG9wdXA6ITAsY2FsbGJhY2s6ZnVuY3Rpb24oKXt0aGlzLnBvcHVwcy5pc1Zpc2libGUoXFxcImxpbmsuaW5zZXJ0XFxcIik/KHRoaXMuJGVsLmZpbmQoXFxcIi5mci1tYXJrZXJcXFwiKSYmKHRoaXMuZXZlbnRzLmRpc2FibGVCbHVyKCksdGhpcy5zZWxlY3Rpb24ucmVzdG9yZSgpKSx0aGlzLnBvcHVwcy5oaWRlKFxcXCJsaW5rLmluc2VydFxcXCIpKTp0aGlzLmxpbmsuc2hvd0luc2VydFBvcHVwKCl9LHBsdWdpbjpcXFwibGlua1xcXCJ9KSxhLkZFLkRlZmluZUljb24oXFxcImxpbmtPcGVuXFxcIix7TkFNRTpcXFwiZXh0ZXJuYWwtbGlua1xcXCJ9KSxhLkZFLlJlZ2lzdGVyQ29tbWFuZChcXFwibGlua09wZW5cXFwiLHt0aXRsZTpcXFwiT3BlbiBMaW5rXFxcIix1bmRvOiExLHJlZnJlc2g6ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5saW5rLmdldCgpO2I/YS5yZW1vdmVDbGFzcyhcXFwiZnItaGlkZGVuXFxcIik6YS5hZGRDbGFzcyhcXFwiZnItaGlkZGVuXFxcIil9LGNhbGxiYWNrOmZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5saW5rLmdldCgpO2EmJnRoaXMub193aW4ub3BlbihhLmhyZWYpfX0pLGEuRkUuRGVmaW5lSWNvbihcXFwibGlua0VkaXRcXFwiLHtOQU1FOlxcXCJlZGl0XFxcIn0pLGEuRkUuUmVnaXN0ZXJDb21tYW5kKFxcXCJsaW5rRWRpdFxcXCIse3RpdGxlOlxcXCJFZGl0IExpbmtcXFwiLHVuZG86ITEscmVmcmVzaEFmdGVyQ2FsbGJhY2s6ITEsY2FsbGJhY2s6ZnVuY3Rpb24oKXt0aGlzLmxpbmsudXBkYXRlKCl9LHJlZnJlc2g6ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5saW5rLmdldCgpO2I/YS5yZW1vdmVDbGFzcyhcXFwiZnItaGlkZGVuXFxcIik6YS5hZGRDbGFzcyhcXFwiZnItaGlkZGVuXFxcIil9fSksYS5GRS5EZWZpbmVJY29uKFxcXCJsaW5rUmVtb3ZlXFxcIix7TkFNRTpcXFwidW5saW5rXFxcIn0pLGEuRkUuUmVnaXN0ZXJDb21tYW5kKFxcXCJsaW5rUmVtb3ZlXFxcIix7dGl0bGU6XFxcIlVubGlua1xcXCIsY2FsbGJhY2s6ZnVuY3Rpb24oKXt0aGlzLmxpbmsucmVtb3ZlKCl9LHJlZnJlc2g6ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5saW5rLmdldCgpO2I/YS5yZW1vdmVDbGFzcyhcXFwiZnItaGlkZGVuXFxcIik6YS5hZGRDbGFzcyhcXFwiZnItaGlkZGVuXFxcIil9fSksYS5GRS5EZWZpbmVJY29uKFxcXCJsaW5rQmFja1xcXCIse05BTUU6XFxcImFycm93LWxlZnRcXFwifSksYS5GRS5SZWdpc3RlckNvbW1hbmQoXFxcImxpbmtCYWNrXFxcIix7dGl0bGU6XFxcIkJhY2tcXFwiLHVuZG86ITEsZm9jdXM6ITEsYmFjazohMCxyZWZyZXNoQWZ0ZXJDYWxsYmFjazohMSxjYWxsYmFjazpmdW5jdGlvbigpe3RoaXMubGluay5iYWNrKCl9LHJlZnJlc2g6ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5saW5rLmdldCgpLGM9dGhpcy5pbWFnZT90aGlzLmltYWdlLmdldCgpOm51bGw7Y3x8Ynx8dGhpcy5vcHRzLnRvb2xiYXJJbmxpbmU/KGEucmVtb3ZlQ2xhc3MoXFxcImZyLWhpZGRlblxcXCIpLGEubmV4dChcXFwiLmZyLXNlcGFyYXRvclxcXCIpLnJlbW92ZUNsYXNzKFxcXCJmci1oaWRkZW5cXFwiKSk6KGEuYWRkQ2xhc3MoXFxcImZyLWhpZGRlblxcXCIpLGEubmV4dChcXFwiLmZyLXNlcGFyYXRvclxcXCIpLmFkZENsYXNzKFxcXCJmci1oaWRkZW5cXFwiKSl9fSksYS5GRS5EZWZpbmVJY29uKFxcXCJsaW5rTGlzdFxcXCIse05BTUU6XFxcInNlYXJjaFxcXCJ9KSxhLkZFLlJlZ2lzdGVyQ29tbWFuZChcXFwibGlua0xpc3RcXFwiLHt0aXRsZTpcXFwiQ2hvb3NlIExpbmtcXFwiLHR5cGU6XFxcImRyb3Bkb3duXFxcIixmb2N1czohMSx1bmRvOiExLHJlZnJlc2hBZnRlckNhbGxiYWNrOiExLGh0bWw6ZnVuY3Rpb24oKXtmb3IodmFyIGE9Jzx1bCBjbGFzcz1cXFwiZnItZHJvcGRvd24tbGlzdFxcXCI+JyxiPXRoaXMub3B0cy5saW5rTGlzdCxjPTA7YzxiLmxlbmd0aDtjKyspYSs9JzxsaT48YSBjbGFzcz1cXFwiZnItY29tbWFuZFxcXCIgZGF0YS1jbWQ9XFxcImxpbmtMaXN0XFxcIiBkYXRhLXBhcmFtMT1cXFwiJytjKydcXFwiPicrKGJbY10uZGlzcGxheVRleHR8fGJbY10udGV4dCkrXFxcIjwvYT48L2xpPlxcXCI7cmV0dXJuIGErPVxcXCI8L3VsPlxcXCJ9LGNhbGxiYWNrOmZ1bmN0aW9uKGEsYil7dGhpcy5saW5rLnVzZVByZWRlZmluZWQoYil9fSksYS5GRS5SZWdpc3RlckNvbW1hbmQoXFxcImxpbmtJbnNlcnRcXFwiLHtmb2N1czohMSxyZWZyZXNoQWZ0ZXJDYWxsYmFjazohMSxjYWxsYmFjazpmdW5jdGlvbigpe3RoaXMubGluay5pbnNlcnRDYWxsYmFjaygpfSxyZWZyZXNoOmZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMubGluay5nZXQoKTtiP2EudGV4dCh0aGlzLmxhbmd1YWdlLnRyYW5zbGF0ZShcXFwiVXBkYXRlXFxcIikpOmEudGV4dCh0aGlzLmxhbmd1YWdlLnRyYW5zbGF0ZShcXFwiSW5zZXJ0XFxcIikpfX0pLGEuRkUuRGVmaW5lSWNvbihcXFwiaW1hZ2VMaW5rXFxcIix7TkFNRTpcXFwibGlua1xcXCJ9KSxhLkZFLlJlZ2lzdGVyQ29tbWFuZChcXFwiaW1hZ2VMaW5rXFxcIix7dGl0bGU6XFxcIkluc2VydCBMaW5rXFxcIix1bmRvOiExLGZvY3VzOiExLGNhbGxiYWNrOmZ1bmN0aW9uKCl7dGhpcy5saW5rLmltYWdlTGluaygpfSxyZWZyZXNoOmZ1bmN0aW9uKGEpe3ZhciBiLGM9dGhpcy5saW5rLmdldCgpO2M/KGI9YS5wcmV2KCksYi5oYXNDbGFzcyhcXFwiZnItc2VwYXJhdG9yXFxcIikmJmIucmVtb3ZlQ2xhc3MoXFxcImZyLWhpZGRlblxcXCIpLGEuYWRkQ2xhc3MoXFxcImZyLWhpZGRlblxcXCIpKTooYj1hLnByZXYoKSxiLmhhc0NsYXNzKFxcXCJmci1zZXBhcmF0b3JcXFwiKSYmYi5hZGRDbGFzcyhcXFwiZnItaGlkZGVuXFxcIiksYS5yZW1vdmVDbGFzcyhcXFwiZnItaGlkZGVuXFxcIikpfX0pLGEuRkUuRGVmaW5lSWNvbihcXFwibGlua1N0eWxlXFxcIix7TkFNRTpcXFwibWFnaWNcXFwifSksYS5GRS5SZWdpc3RlckNvbW1hbmQoXFxcImxpbmtTdHlsZVxcXCIse3RpdGxlOlxcXCJTdHlsZVxcXCIsdHlwZTpcXFwiZHJvcGRvd25cXFwiLGh0bWw6ZnVuY3Rpb24oKXt2YXIgYT0nPHVsIGNsYXNzPVxcXCJmci1kcm9wZG93bi1saXN0XFxcIj4nLGI9dGhpcy5vcHRzLmxpbmtTdHlsZXM7Zm9yKHZhciBjIGluIGIpYi5oYXNPd25Qcm9wZXJ0eShjKSYmKGErPSc8bGk+PGEgY2xhc3M9XFxcImZyLWNvbW1hbmRcXFwiIGRhdGEtY21kPVxcXCJsaW5rU3R5bGVcXFwiIGRhdGEtcGFyYW0xPVxcXCInK2MrJ1xcXCI+Jyt0aGlzLmxhbmd1YWdlLnRyYW5zbGF0ZShiW2NdKStcXFwiPC9hPjwvbGk+XFxcIik7cmV0dXJuIGErPVxcXCI8L3VsPlxcXCJ9LGNhbGxiYWNrOmZ1bmN0aW9uKGEsYil7dGhpcy5saW5rLmFwcGx5U3R5bGUoYil9LHJlZnJlc2hPblNob3c6ZnVuY3Rpb24oYixjKXt2YXIgZD10aGlzLmxpbmsuZ2V0KCk7aWYoZCl7dmFyIGU9YShkKTtjLmZpbmQoXFxcIi5mci1jb21tYW5kXFxcIikuZWFjaChmdW5jdGlvbigpe3ZhciBiPWEodGhpcykuZGF0YShcXFwicGFyYW0xXFxcIik7YSh0aGlzKS50b2dnbGVDbGFzcyhcXFwiZnItYWN0aXZlXFxcIixlLmhhc0NsYXNzKGIpKX0pfX19KX0pO1wiXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3Jhdy1sb2FkZXIhLi9+L2Zyb2FsYS1lZGl0b3IvanMvcGx1Z2lucy9saW5rLm1pbi5qc1xuLy8gbW9kdWxlIGlkID0gMTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQSIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

	eval("__webpack_require__(2)(__webpack_require__(19))//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTguanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2Zyb2FsYS1lZGl0b3IvanMvcGx1Z2lucy91cmwubWluLmpzPzY2NWYiXSwic291cmNlc0NvbnRlbnQiOlsicmVxdWlyZShcIiEhL3Zhci9hcHAvd2ViL2pzL25vZGVfbW9kdWxlcy9zY3JpcHQtbG9hZGVyL2FkZFNjcmlwdC5qc1wiKShyZXF1aXJlKFwiISEvdmFyL2FwcC93ZWIvanMvbm9kZV9tb2R1bGVzL3Jhdy1sb2FkZXIvaW5kZXguanMhL3Zhci9hcHAvd2ViL2pzL25vZGVfbW9kdWxlcy9mcm9hbGEtZWRpdG9yL2pzL3BsdWdpbnMvdXJsLm1pbi5qc1wiKSlcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vc2NyaXB0LWxvYWRlciEuL34vZnJvYWxhLWVkaXRvci9qcy9wbHVnaW5zL3VybC5taW4uanNcbi8vIG1vZHVsZSBpZCA9IDE4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 19 */
/***/ function(module, exports) {

	eval("module.exports = \"/*!\\n * froala_editor v2.3.5 (https://www.froala.com/wysiwyg-editor)\\n * License https://froala.com/wysiwyg-editor/terms/\\n * Copyright 2014-2016 Froala Labs\\n */\\n\\n!function(a){\\\"function\\\"==typeof define&&define.amd?define([\\\"jquery\\\"],a):\\\"object\\\"==typeof module&&module.exports?module.exports=function(b,c){return void 0===c&&(c=\\\"undefined\\\"!=typeof window?require(\\\"jquery\\\"):require(\\\"jquery\\\")(b)),a(c),c}:a(jQuery)}(function(a){a.extend(a.FE.DEFAULTS,{}),a.FE.URLRegEx=/(\\\\s|^|>)((http|https|ftp|ftps)\\\\:\\\\/\\\\/[a-zA-Z0-9\\\\-\\\\.]+(\\\\.[a-zA-Z]{2,3})?(:\\\\d*)?(\\\\/[^\\\\s<]*)?)(\\\\s|$|<)/gi,a.FE.PLUGINS.url=function(b){function c(d){d.each(function(){if(\\\"IFRAME\\\"!=this.tagName)if(3==this.nodeType){var d=this.textContent.replace(/&nbsp;/gi,\\\"\\\");a.FE.URLRegEx.test(d)&&(a(this).before(d.replace(a.FE.URLRegEx,\\\"$1<a\\\"+(b.opts.linkAlwaysBlank?' target=\\\"_blank\\\"':\\\"\\\")+(b.opts.linkAlwaysNoFollow?' rel=\\\"nofollow\\\"':\\\"\\\")+' href=\\\"$2\\\">$2</a>$7')),a(this).remove())}else 1==this.nodeType&&[\\\"A\\\",\\\"BUTTON\\\",\\\"TEXTAREA\\\"].indexOf(this.tagName)<0&&c(b.node.contents(this))})}function d(){b.events.on(\\\"paste.afterCleanup\\\",function(c){return a.FE.URLRegEx.test(c)?c.replace(a.FE.URLRegEx,\\\"$1<a\\\"+(b.opts.linkAlwaysBlank?' target=\\\"_blank\\\"':\\\"\\\")+(b.opts.linkAlwaysNoFollow?' rel=\\\"nofollow\\\"':\\\"\\\")+' href=\\\"$2\\\">$2</a>$7'):void 0}),b.events.on(\\\"keyup\\\",function(d){var e=d.which;(e==a.FE.KEYCODE.ENTER||e==a.FE.KEYCODE.SPACE)&&c(b.node.contents(b.$el.get(0)))}),b.events.on(\\\"keydown\\\",function(c){var d=c.which;if(d==a.FE.KEYCODE.ENTER){var e=b.selection.element();if((\\\"A\\\"==e.tagName||a(e).parents(\\\"a\\\").length)&&b.selection.info(e).atEnd)return c.stopImmediatePropagation(),\\\"A\\\"!==e.tagName&&(e=a(e).parents(\\\"a\\\")[0]),a(e).after(\\\"&nbsp;\\\"+a.FE.MARKERS),b.selection.restore(),!1}})}return{_init:d}}});\"//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTkuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2Zyb2FsYS1lZGl0b3IvanMvcGx1Z2lucy91cmwubWluLmpzP2E1NmIiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBcIi8qIVxcbiAqIGZyb2FsYV9lZGl0b3IgdjIuMy41IChodHRwczovL3d3dy5mcm9hbGEuY29tL3d5c2l3eWctZWRpdG9yKVxcbiAqIExpY2Vuc2UgaHR0cHM6Ly9mcm9hbGEuY29tL3d5c2l3eWctZWRpdG9yL3Rlcm1zL1xcbiAqIENvcHlyaWdodCAyMDE0LTIwMTYgRnJvYWxhIExhYnNcXG4gKi9cXG5cXG4hZnVuY3Rpb24oYSl7XFxcImZ1bmN0aW9uXFxcIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUoW1xcXCJqcXVlcnlcXFwiXSxhKTpcXFwib2JqZWN0XFxcIj09dHlwZW9mIG1vZHVsZSYmbW9kdWxlLmV4cG9ydHM/bW9kdWxlLmV4cG9ydHM9ZnVuY3Rpb24oYixjKXtyZXR1cm4gdm9pZCAwPT09YyYmKGM9XFxcInVuZGVmaW5lZFxcXCIhPXR5cGVvZiB3aW5kb3c/cmVxdWlyZShcXFwianF1ZXJ5XFxcIik6cmVxdWlyZShcXFwianF1ZXJ5XFxcIikoYikpLGEoYyksY306YShqUXVlcnkpfShmdW5jdGlvbihhKXthLmV4dGVuZChhLkZFLkRFRkFVTFRTLHt9KSxhLkZFLlVSTFJlZ0V4PS8oXFxcXHN8Xnw+KSgoaHR0cHxodHRwc3xmdHB8ZnRwcylcXFxcOlxcXFwvXFxcXC9bYS16QS1aMC05XFxcXC1cXFxcLl0rKFxcXFwuW2EtekEtWl17MiwzfSk/KDpcXFxcZCopPyhcXFxcL1teXFxcXHM8XSopPykoXFxcXHN8JHw8KS9naSxhLkZFLlBMVUdJTlMudXJsPWZ1bmN0aW9uKGIpe2Z1bmN0aW9uIGMoZCl7ZC5lYWNoKGZ1bmN0aW9uKCl7aWYoXFxcIklGUkFNRVxcXCIhPXRoaXMudGFnTmFtZSlpZigzPT10aGlzLm5vZGVUeXBlKXt2YXIgZD10aGlzLnRleHRDb250ZW50LnJlcGxhY2UoLyZuYnNwOy9naSxcXFwiXFxcIik7YS5GRS5VUkxSZWdFeC50ZXN0KGQpJiYoYSh0aGlzKS5iZWZvcmUoZC5yZXBsYWNlKGEuRkUuVVJMUmVnRXgsXFxcIiQxPGFcXFwiKyhiLm9wdHMubGlua0Fsd2F5c0JsYW5rPycgdGFyZ2V0PVxcXCJfYmxhbmtcXFwiJzpcXFwiXFxcIikrKGIub3B0cy5saW5rQWx3YXlzTm9Gb2xsb3c/JyByZWw9XFxcIm5vZm9sbG93XFxcIic6XFxcIlxcXCIpKycgaHJlZj1cXFwiJDJcXFwiPiQyPC9hPiQ3JykpLGEodGhpcykucmVtb3ZlKCkpfWVsc2UgMT09dGhpcy5ub2RlVHlwZSYmW1xcXCJBXFxcIixcXFwiQlVUVE9OXFxcIixcXFwiVEVYVEFSRUFcXFwiXS5pbmRleE9mKHRoaXMudGFnTmFtZSk8MCYmYyhiLm5vZGUuY29udGVudHModGhpcykpfSl9ZnVuY3Rpb24gZCgpe2IuZXZlbnRzLm9uKFxcXCJwYXN0ZS5hZnRlckNsZWFudXBcXFwiLGZ1bmN0aW9uKGMpe3JldHVybiBhLkZFLlVSTFJlZ0V4LnRlc3QoYyk/Yy5yZXBsYWNlKGEuRkUuVVJMUmVnRXgsXFxcIiQxPGFcXFwiKyhiLm9wdHMubGlua0Fsd2F5c0JsYW5rPycgdGFyZ2V0PVxcXCJfYmxhbmtcXFwiJzpcXFwiXFxcIikrKGIub3B0cy5saW5rQWx3YXlzTm9Gb2xsb3c/JyByZWw9XFxcIm5vZm9sbG93XFxcIic6XFxcIlxcXCIpKycgaHJlZj1cXFwiJDJcXFwiPiQyPC9hPiQ3Jyk6dm9pZCAwfSksYi5ldmVudHMub24oXFxcImtleXVwXFxcIixmdW5jdGlvbihkKXt2YXIgZT1kLndoaWNoOyhlPT1hLkZFLktFWUNPREUuRU5URVJ8fGU9PWEuRkUuS0VZQ09ERS5TUEFDRSkmJmMoYi5ub2RlLmNvbnRlbnRzKGIuJGVsLmdldCgwKSkpfSksYi5ldmVudHMub24oXFxcImtleWRvd25cXFwiLGZ1bmN0aW9uKGMpe3ZhciBkPWMud2hpY2g7aWYoZD09YS5GRS5LRVlDT0RFLkVOVEVSKXt2YXIgZT1iLnNlbGVjdGlvbi5lbGVtZW50KCk7aWYoKFxcXCJBXFxcIj09ZS50YWdOYW1lfHxhKGUpLnBhcmVudHMoXFxcImFcXFwiKS5sZW5ndGgpJiZiLnNlbGVjdGlvbi5pbmZvKGUpLmF0RW5kKXJldHVybiBjLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpLFxcXCJBXFxcIiE9PWUudGFnTmFtZSYmKGU9YShlKS5wYXJlbnRzKFxcXCJhXFxcIilbMF0pLGEoZSkuYWZ0ZXIoXFxcIiZuYnNwO1xcXCIrYS5GRS5NQVJLRVJTKSxiLnNlbGVjdGlvbi5yZXN0b3JlKCksITF9fSl9cmV0dXJue19pbml0OmR9fX0pO1wiXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3Jhdy1sb2FkZXIhLi9+L2Zyb2FsYS1lZGl0b3IvanMvcGx1Z2lucy91cmwubWluLmpzXG4vLyBtb2R1bGUgaWQgPSAxOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {

	eval("__webpack_require__(2)(__webpack_require__(21))//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjAuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2Zyb2FsYS1lZGl0b3IvanMvbGFuZ3VhZ2VzL2VuX2diLmpzPzczYTgiXSwic291cmNlc0NvbnRlbnQiOlsicmVxdWlyZShcIiEhL3Zhci9hcHAvd2ViL2pzL25vZGVfbW9kdWxlcy9zY3JpcHQtbG9hZGVyL2FkZFNjcmlwdC5qc1wiKShyZXF1aXJlKFwiISEvdmFyL2FwcC93ZWIvanMvbm9kZV9tb2R1bGVzL3Jhdy1sb2FkZXIvaW5kZXguanMhL3Zhci9hcHAvd2ViL2pzL25vZGVfbW9kdWxlcy9mcm9hbGEtZWRpdG9yL2pzL2xhbmd1YWdlcy9lbl9nYi5qc1wiKSlcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vc2NyaXB0LWxvYWRlciEuL34vZnJvYWxhLWVkaXRvci9qcy9sYW5ndWFnZXMvZW5fZ2IuanNcbi8vIG1vZHVsZSBpZCA9IDIwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 21 */
/***/ function(module, exports) {

	eval("module.exports = \"/*!\\n * froala_editor v2.3.5 (https://www.froala.com/wysiwyg-editor)\\n * License https://froala.com/wysiwyg-editor/terms/\\n * Copyright 2014-2016 Froala Labs\\n */\\n\\n/**\\n * English spoken in Great Britain\\n */\\n\\n$.FE.LANGUAGE['en_gb'] = {\\n  translation: {\\n    // Place holder\\n    \\\"Type something\\\": \\\"Type something\\\",\\n\\n    // Basic formatting\\n    \\\"Bold\\\": \\\"Bold\\\",\\n    \\\"Italic\\\": \\\"Italic\\\",\\n    \\\"Underline\\\": \\\"Underline\\\",\\n    \\\"Strikethrough\\\": \\\"Strikethrough\\\",\\n\\n    // Main buttons\\n    \\\"Insert\\\": \\\"Insert\\\",\\n    \\\"Delete\\\": \\\"Delete\\\",\\n    \\\"Cancel\\\": \\\"Cancel\\\",\\n    \\\"OK\\\": \\\"OK\\\",\\n    \\\"Back\\\": \\\"Back\\\",\\n    \\\"Remove\\\": \\\"Remove\\\",\\n    \\\"More\\\": \\\"More\\\",\\n    \\\"Update\\\": \\\"Update\\\",\\n    \\\"Style\\\": \\\"Style\\\",\\n\\n    // Font\\n    \\\"Font Family\\\": \\\"Font Family\\\",\\n    \\\"Font Size\\\": \\\"Font Size\\\",\\n\\n    // Colors\\n    \\\"Colors\\\": \\\"Colours\\\",\\n    \\\"Background\\\": \\\"Background\\\",\\n    \\\"Text\\\": \\\"Text\\\",\\n\\n    // Paragraphs\\n    \\\"Paragraph Format\\\": \\\"Paragraph Format\\\",\\n    \\\"Normal\\\": \\\"Normal\\\",\\n    \\\"Code\\\": \\\"Code\\\",\\n    \\\"Heading 1\\\": \\\"Heading 1\\\",\\n    \\\"Heading 2\\\": \\\"Heading 2\\\",\\n    \\\"Heading 3\\\": \\\"Heading 3\\\",\\n    \\\"Heading 4\\\": \\\"Heading 4\\\",\\n\\n    // Style\\n    \\\"Paragraph Style\\\": \\\"Paragraph Style\\\",\\n    \\\"Inline Style\\\": \\\"Inline Style\\\",\\n\\n    // Alignment\\n    \\\"Align\\\": \\\"Align\\\",\\n    \\\"Align Left\\\": \\\"Align Left\\\",\\n    \\\"Align Center\\\": \\\"Align Centre\\\",\\n    \\\"Align Right\\\": \\\"Alight Right\\\",\\n    \\\"Align Justify\\\": \\\"Align Justify\\\",\\n    \\\"None\\\": \\\"None\\\",\\n\\n    // Lists\\n    \\\"Ordered List\\\": \\\"Ordered List\\\",\\n    \\\"Unordered List\\\": \\\"Unordered List\\\",\\n\\n    // Indent\\n    \\\"Decrease Indent\\\": \\\"Decrease Indent\\\",\\n    \\\"Increase Indent\\\": \\\"Increase Indent\\\",\\n\\n    // Links\\n    \\\"Insert Link\\\": \\\"Insert Link\\\",\\n    \\\"Open in new tab\\\": \\\"Open in new tab\\\",\\n    \\\"Open Link\\\": \\\"Open Link\\\",\\n    \\\"Edit Link\\\": \\\"Edit Link\\\",\\n    \\\"Unlink\\\": \\\"Unlink\\\",\\n    \\\"Choose Link\\\": \\\"Choose Link\\\",\\n\\n    // Images\\n    \\\"Insert Image\\\": \\\"Insert Image\\\",\\n    \\\"Upload Image\\\": \\\"Upload Image\\\",\\n    \\\"By URL\\\": \\\"By URL\\\",\\n    \\\"Browse\\\": \\\"Browse\\\",\\n    \\\"Drop image\\\": \\\"Drop image\\\",\\n    \\\"or click\\\": \\\"or click\\\",\\n    \\\"Manage Images\\\": \\\"Manage Images\\\",\\n    \\\"Loading\\\": \\\"Loading\\\",\\n    \\\"Deleting\\\": \\\"Deleting\\\",\\n    \\\"Tags\\\": \\\"Tags\\\",\\n    \\\"Are you sure? Image will be deleted.\\\": \\\"Are you sure? Image will be deleted.\\\",\\n    \\\"Replace\\\": \\\"Replace\\\",\\n    \\\"Uploading\\\": \\\"Uploading\\\",\\n    \\\"Loading image\\\": \\\"Loading image\\\",\\n    \\\"Display\\\": \\\"Display\\\",\\n    \\\"Inline\\\": \\\"Inline\\\",\\n    \\\"Break Text\\\": \\\"Break Text\\\",\\n    \\\"Alternate Text\\\": \\\"Alternate Text\\\",\\n    \\\"Change Size\\\": \\\"Change Size\\\",\\n    \\\"Width\\\": \\\"Width\\\",\\n    \\\"Height\\\": \\\"Height\\\",\\n    \\\"Something went wrong. Please try again.\\\": \\\"Something went wrong. Please try again.\\\",\\n\\n    // Video\\n    \\\"Insert Video\\\": \\\"Insert Video\\\",\\n    \\\"Embedded Code\\\": \\\"Embedded Code\\\",\\n\\n    // Tables\\n    \\\"Insert Table\\\": \\\"Insert Table\\\",\\n    \\\"Table Header\\\": \\\"Table Header\\\",\\n    \\\"Remove Table\\\": \\\"Remove Table\\\",\\n    \\\"Table Style\\\": \\\"Table Style\\\",\\n    \\\"Horizontal Align\\\": \\\"Horizontal Align\\\",\\n    \\\"Row\\\": \\\"Row\\\",\\n    \\\"Insert row above\\\": \\\"Insert row above\\\",\\n    \\\"Insert row below\\\": \\\"Insert row below\\\",\\n    \\\"Delete row\\\": \\\"Delete row\\\",\\n    \\\"Column\\\": \\\"Column\\\",\\n    \\\"Insert column before\\\": \\\"Insert column before\\\",\\n    \\\"Insert column after\\\": \\\"Insert column after\\\",\\n    \\\"Delete column\\\": \\\"Delete column\\\",\\n    \\\"Cell\\\": \\\"Cell\\\",\\n    \\\"Merge cells\\\": \\\"Merge cells\\\",\\n    \\\"Horizontal split\\\": \\\"Horizontal split\\\",\\n    \\\"Vertical split\\\": \\\"Vertical split\\\",\\n    \\\"Cell Background\\\": \\\"Cell Background\\\",\\n    \\\"Vertical Align\\\": \\\"Vertical Align\\\",\\n    \\\"Top\\\": \\\"Top\\\",\\n    \\\"Middle\\\": \\\"Middle\\\",\\n    \\\"Bottom\\\": \\\"Bottom\\\",\\n    \\\"Align Top\\\": \\\"Align Top\\\",\\n    \\\"Align Middle\\\": \\\"Align Middle\\\",\\n    \\\"Align Bottom\\\": \\\"Align Bottom\\\",\\n    \\\"Cell Style\\\": \\\"Cell Style\\\",\\n\\n    // Files\\n    \\\"Upload File\\\": \\\"Upload File\\\",\\n    \\\"Drop file\\\": \\\"Drop file\\\",\\n\\n    // Emoticons\\n    \\\"Emoticons\\\": \\\"Emoticons\\\",\\n\\n    // Line breaker\\n    \\\"Break\\\": \\\"Break\\\",\\n\\n    // Math\\n    \\\"Subscript\\\": \\\"Subscript\\\",\\n    \\\"Superscript\\\": \\\"Superscript\\\",\\n\\n    // Full screen\\n    \\\"Fullscreen\\\": \\\"Fullscreen\\\",\\n\\n    // Horizontal line\\n    \\\"Insert Horizontal Line\\\": \\\"Insert Horizontal Line\\\",\\n\\n    // Clear formatting\\n    \\\"Clear Formatting\\\": \\\"Cell Formatting\\\",\\n\\n    // Undo, redo\\n    \\\"Undo\\\": \\\"Undo\\\",\\n    \\\"Redo\\\": \\\"Redo\\\",\\n\\n    // Select all\\n    \\\"Select All\\\": \\\"Select All\\\",\\n\\n    // Code view\\n    \\\"Code View\\\": \\\"Code View\\\",\\n\\n    // Quote\\n    \\\"Quote\\\": \\\"Quote\\\",\\n    \\\"Increase\\\": \\\"Increase\\\",\\n    \\\"Decrease\\\": \\\"Decrease\\\",\\n\\n    // Quick Insert\\n    \\\"Quick Insert\\\": \\\"Quick Insert\\\"\\n  },\\n  direction: \\\"ltr\\\"\\n};\\n\"//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjEuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2Zyb2FsYS1lZGl0b3IvanMvbGFuZ3VhZ2VzL2VuX2diLmpzP2U4NTUiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBcIi8qIVxcbiAqIGZyb2FsYV9lZGl0b3IgdjIuMy41IChodHRwczovL3d3dy5mcm9hbGEuY29tL3d5c2l3eWctZWRpdG9yKVxcbiAqIExpY2Vuc2UgaHR0cHM6Ly9mcm9hbGEuY29tL3d5c2l3eWctZWRpdG9yL3Rlcm1zL1xcbiAqIENvcHlyaWdodCAyMDE0LTIwMTYgRnJvYWxhIExhYnNcXG4gKi9cXG5cXG4vKipcXG4gKiBFbmdsaXNoIHNwb2tlbiBpbiBHcmVhdCBCcml0YWluXFxuICovXFxuXFxuJC5GRS5MQU5HVUFHRVsnZW5fZ2InXSA9IHtcXG4gIHRyYW5zbGF0aW9uOiB7XFxuICAgIC8vIFBsYWNlIGhvbGRlclxcbiAgICBcXFwiVHlwZSBzb21ldGhpbmdcXFwiOiBcXFwiVHlwZSBzb21ldGhpbmdcXFwiLFxcblxcbiAgICAvLyBCYXNpYyBmb3JtYXR0aW5nXFxuICAgIFxcXCJCb2xkXFxcIjogXFxcIkJvbGRcXFwiLFxcbiAgICBcXFwiSXRhbGljXFxcIjogXFxcIkl0YWxpY1xcXCIsXFxuICAgIFxcXCJVbmRlcmxpbmVcXFwiOiBcXFwiVW5kZXJsaW5lXFxcIixcXG4gICAgXFxcIlN0cmlrZXRocm91Z2hcXFwiOiBcXFwiU3RyaWtldGhyb3VnaFxcXCIsXFxuXFxuICAgIC8vIE1haW4gYnV0dG9uc1xcbiAgICBcXFwiSW5zZXJ0XFxcIjogXFxcIkluc2VydFxcXCIsXFxuICAgIFxcXCJEZWxldGVcXFwiOiBcXFwiRGVsZXRlXFxcIixcXG4gICAgXFxcIkNhbmNlbFxcXCI6IFxcXCJDYW5jZWxcXFwiLFxcbiAgICBcXFwiT0tcXFwiOiBcXFwiT0tcXFwiLFxcbiAgICBcXFwiQmFja1xcXCI6IFxcXCJCYWNrXFxcIixcXG4gICAgXFxcIlJlbW92ZVxcXCI6IFxcXCJSZW1vdmVcXFwiLFxcbiAgICBcXFwiTW9yZVxcXCI6IFxcXCJNb3JlXFxcIixcXG4gICAgXFxcIlVwZGF0ZVxcXCI6IFxcXCJVcGRhdGVcXFwiLFxcbiAgICBcXFwiU3R5bGVcXFwiOiBcXFwiU3R5bGVcXFwiLFxcblxcbiAgICAvLyBGb250XFxuICAgIFxcXCJGb250IEZhbWlseVxcXCI6IFxcXCJGb250IEZhbWlseVxcXCIsXFxuICAgIFxcXCJGb250IFNpemVcXFwiOiBcXFwiRm9udCBTaXplXFxcIixcXG5cXG4gICAgLy8gQ29sb3JzXFxuICAgIFxcXCJDb2xvcnNcXFwiOiBcXFwiQ29sb3Vyc1xcXCIsXFxuICAgIFxcXCJCYWNrZ3JvdW5kXFxcIjogXFxcIkJhY2tncm91bmRcXFwiLFxcbiAgICBcXFwiVGV4dFxcXCI6IFxcXCJUZXh0XFxcIixcXG5cXG4gICAgLy8gUGFyYWdyYXBoc1xcbiAgICBcXFwiUGFyYWdyYXBoIEZvcm1hdFxcXCI6IFxcXCJQYXJhZ3JhcGggRm9ybWF0XFxcIixcXG4gICAgXFxcIk5vcm1hbFxcXCI6IFxcXCJOb3JtYWxcXFwiLFxcbiAgICBcXFwiQ29kZVxcXCI6IFxcXCJDb2RlXFxcIixcXG4gICAgXFxcIkhlYWRpbmcgMVxcXCI6IFxcXCJIZWFkaW5nIDFcXFwiLFxcbiAgICBcXFwiSGVhZGluZyAyXFxcIjogXFxcIkhlYWRpbmcgMlxcXCIsXFxuICAgIFxcXCJIZWFkaW5nIDNcXFwiOiBcXFwiSGVhZGluZyAzXFxcIixcXG4gICAgXFxcIkhlYWRpbmcgNFxcXCI6IFxcXCJIZWFkaW5nIDRcXFwiLFxcblxcbiAgICAvLyBTdHlsZVxcbiAgICBcXFwiUGFyYWdyYXBoIFN0eWxlXFxcIjogXFxcIlBhcmFncmFwaCBTdHlsZVxcXCIsXFxuICAgIFxcXCJJbmxpbmUgU3R5bGVcXFwiOiBcXFwiSW5saW5lIFN0eWxlXFxcIixcXG5cXG4gICAgLy8gQWxpZ25tZW50XFxuICAgIFxcXCJBbGlnblxcXCI6IFxcXCJBbGlnblxcXCIsXFxuICAgIFxcXCJBbGlnbiBMZWZ0XFxcIjogXFxcIkFsaWduIExlZnRcXFwiLFxcbiAgICBcXFwiQWxpZ24gQ2VudGVyXFxcIjogXFxcIkFsaWduIENlbnRyZVxcXCIsXFxuICAgIFxcXCJBbGlnbiBSaWdodFxcXCI6IFxcXCJBbGlnaHQgUmlnaHRcXFwiLFxcbiAgICBcXFwiQWxpZ24gSnVzdGlmeVxcXCI6IFxcXCJBbGlnbiBKdXN0aWZ5XFxcIixcXG4gICAgXFxcIk5vbmVcXFwiOiBcXFwiTm9uZVxcXCIsXFxuXFxuICAgIC8vIExpc3RzXFxuICAgIFxcXCJPcmRlcmVkIExpc3RcXFwiOiBcXFwiT3JkZXJlZCBMaXN0XFxcIixcXG4gICAgXFxcIlVub3JkZXJlZCBMaXN0XFxcIjogXFxcIlVub3JkZXJlZCBMaXN0XFxcIixcXG5cXG4gICAgLy8gSW5kZW50XFxuICAgIFxcXCJEZWNyZWFzZSBJbmRlbnRcXFwiOiBcXFwiRGVjcmVhc2UgSW5kZW50XFxcIixcXG4gICAgXFxcIkluY3JlYXNlIEluZGVudFxcXCI6IFxcXCJJbmNyZWFzZSBJbmRlbnRcXFwiLFxcblxcbiAgICAvLyBMaW5rc1xcbiAgICBcXFwiSW5zZXJ0IExpbmtcXFwiOiBcXFwiSW5zZXJ0IExpbmtcXFwiLFxcbiAgICBcXFwiT3BlbiBpbiBuZXcgdGFiXFxcIjogXFxcIk9wZW4gaW4gbmV3IHRhYlxcXCIsXFxuICAgIFxcXCJPcGVuIExpbmtcXFwiOiBcXFwiT3BlbiBMaW5rXFxcIixcXG4gICAgXFxcIkVkaXQgTGlua1xcXCI6IFxcXCJFZGl0IExpbmtcXFwiLFxcbiAgICBcXFwiVW5saW5rXFxcIjogXFxcIlVubGlua1xcXCIsXFxuICAgIFxcXCJDaG9vc2UgTGlua1xcXCI6IFxcXCJDaG9vc2UgTGlua1xcXCIsXFxuXFxuICAgIC8vIEltYWdlc1xcbiAgICBcXFwiSW5zZXJ0IEltYWdlXFxcIjogXFxcIkluc2VydCBJbWFnZVxcXCIsXFxuICAgIFxcXCJVcGxvYWQgSW1hZ2VcXFwiOiBcXFwiVXBsb2FkIEltYWdlXFxcIixcXG4gICAgXFxcIkJ5IFVSTFxcXCI6IFxcXCJCeSBVUkxcXFwiLFxcbiAgICBcXFwiQnJvd3NlXFxcIjogXFxcIkJyb3dzZVxcXCIsXFxuICAgIFxcXCJEcm9wIGltYWdlXFxcIjogXFxcIkRyb3AgaW1hZ2VcXFwiLFxcbiAgICBcXFwib3IgY2xpY2tcXFwiOiBcXFwib3IgY2xpY2tcXFwiLFxcbiAgICBcXFwiTWFuYWdlIEltYWdlc1xcXCI6IFxcXCJNYW5hZ2UgSW1hZ2VzXFxcIixcXG4gICAgXFxcIkxvYWRpbmdcXFwiOiBcXFwiTG9hZGluZ1xcXCIsXFxuICAgIFxcXCJEZWxldGluZ1xcXCI6IFxcXCJEZWxldGluZ1xcXCIsXFxuICAgIFxcXCJUYWdzXFxcIjogXFxcIlRhZ3NcXFwiLFxcbiAgICBcXFwiQXJlIHlvdSBzdXJlPyBJbWFnZSB3aWxsIGJlIGRlbGV0ZWQuXFxcIjogXFxcIkFyZSB5b3Ugc3VyZT8gSW1hZ2Ugd2lsbCBiZSBkZWxldGVkLlxcXCIsXFxuICAgIFxcXCJSZXBsYWNlXFxcIjogXFxcIlJlcGxhY2VcXFwiLFxcbiAgICBcXFwiVXBsb2FkaW5nXFxcIjogXFxcIlVwbG9hZGluZ1xcXCIsXFxuICAgIFxcXCJMb2FkaW5nIGltYWdlXFxcIjogXFxcIkxvYWRpbmcgaW1hZ2VcXFwiLFxcbiAgICBcXFwiRGlzcGxheVxcXCI6IFxcXCJEaXNwbGF5XFxcIixcXG4gICAgXFxcIklubGluZVxcXCI6IFxcXCJJbmxpbmVcXFwiLFxcbiAgICBcXFwiQnJlYWsgVGV4dFxcXCI6IFxcXCJCcmVhayBUZXh0XFxcIixcXG4gICAgXFxcIkFsdGVybmF0ZSBUZXh0XFxcIjogXFxcIkFsdGVybmF0ZSBUZXh0XFxcIixcXG4gICAgXFxcIkNoYW5nZSBTaXplXFxcIjogXFxcIkNoYW5nZSBTaXplXFxcIixcXG4gICAgXFxcIldpZHRoXFxcIjogXFxcIldpZHRoXFxcIixcXG4gICAgXFxcIkhlaWdodFxcXCI6IFxcXCJIZWlnaHRcXFwiLFxcbiAgICBcXFwiU29tZXRoaW5nIHdlbnQgd3JvbmcuIFBsZWFzZSB0cnkgYWdhaW4uXFxcIjogXFxcIlNvbWV0aGluZyB3ZW50IHdyb25nLiBQbGVhc2UgdHJ5IGFnYWluLlxcXCIsXFxuXFxuICAgIC8vIFZpZGVvXFxuICAgIFxcXCJJbnNlcnQgVmlkZW9cXFwiOiBcXFwiSW5zZXJ0IFZpZGVvXFxcIixcXG4gICAgXFxcIkVtYmVkZGVkIENvZGVcXFwiOiBcXFwiRW1iZWRkZWQgQ29kZVxcXCIsXFxuXFxuICAgIC8vIFRhYmxlc1xcbiAgICBcXFwiSW5zZXJ0IFRhYmxlXFxcIjogXFxcIkluc2VydCBUYWJsZVxcXCIsXFxuICAgIFxcXCJUYWJsZSBIZWFkZXJcXFwiOiBcXFwiVGFibGUgSGVhZGVyXFxcIixcXG4gICAgXFxcIlJlbW92ZSBUYWJsZVxcXCI6IFxcXCJSZW1vdmUgVGFibGVcXFwiLFxcbiAgICBcXFwiVGFibGUgU3R5bGVcXFwiOiBcXFwiVGFibGUgU3R5bGVcXFwiLFxcbiAgICBcXFwiSG9yaXpvbnRhbCBBbGlnblxcXCI6IFxcXCJIb3Jpem9udGFsIEFsaWduXFxcIixcXG4gICAgXFxcIlJvd1xcXCI6IFxcXCJSb3dcXFwiLFxcbiAgICBcXFwiSW5zZXJ0IHJvdyBhYm92ZVxcXCI6IFxcXCJJbnNlcnQgcm93IGFib3ZlXFxcIixcXG4gICAgXFxcIkluc2VydCByb3cgYmVsb3dcXFwiOiBcXFwiSW5zZXJ0IHJvdyBiZWxvd1xcXCIsXFxuICAgIFxcXCJEZWxldGUgcm93XFxcIjogXFxcIkRlbGV0ZSByb3dcXFwiLFxcbiAgICBcXFwiQ29sdW1uXFxcIjogXFxcIkNvbHVtblxcXCIsXFxuICAgIFxcXCJJbnNlcnQgY29sdW1uIGJlZm9yZVxcXCI6IFxcXCJJbnNlcnQgY29sdW1uIGJlZm9yZVxcXCIsXFxuICAgIFxcXCJJbnNlcnQgY29sdW1uIGFmdGVyXFxcIjogXFxcIkluc2VydCBjb2x1bW4gYWZ0ZXJcXFwiLFxcbiAgICBcXFwiRGVsZXRlIGNvbHVtblxcXCI6IFxcXCJEZWxldGUgY29sdW1uXFxcIixcXG4gICAgXFxcIkNlbGxcXFwiOiBcXFwiQ2VsbFxcXCIsXFxuICAgIFxcXCJNZXJnZSBjZWxsc1xcXCI6IFxcXCJNZXJnZSBjZWxsc1xcXCIsXFxuICAgIFxcXCJIb3Jpem9udGFsIHNwbGl0XFxcIjogXFxcIkhvcml6b250YWwgc3BsaXRcXFwiLFxcbiAgICBcXFwiVmVydGljYWwgc3BsaXRcXFwiOiBcXFwiVmVydGljYWwgc3BsaXRcXFwiLFxcbiAgICBcXFwiQ2VsbCBCYWNrZ3JvdW5kXFxcIjogXFxcIkNlbGwgQmFja2dyb3VuZFxcXCIsXFxuICAgIFxcXCJWZXJ0aWNhbCBBbGlnblxcXCI6IFxcXCJWZXJ0aWNhbCBBbGlnblxcXCIsXFxuICAgIFxcXCJUb3BcXFwiOiBcXFwiVG9wXFxcIixcXG4gICAgXFxcIk1pZGRsZVxcXCI6IFxcXCJNaWRkbGVcXFwiLFxcbiAgICBcXFwiQm90dG9tXFxcIjogXFxcIkJvdHRvbVxcXCIsXFxuICAgIFxcXCJBbGlnbiBUb3BcXFwiOiBcXFwiQWxpZ24gVG9wXFxcIixcXG4gICAgXFxcIkFsaWduIE1pZGRsZVxcXCI6IFxcXCJBbGlnbiBNaWRkbGVcXFwiLFxcbiAgICBcXFwiQWxpZ24gQm90dG9tXFxcIjogXFxcIkFsaWduIEJvdHRvbVxcXCIsXFxuICAgIFxcXCJDZWxsIFN0eWxlXFxcIjogXFxcIkNlbGwgU3R5bGVcXFwiLFxcblxcbiAgICAvLyBGaWxlc1xcbiAgICBcXFwiVXBsb2FkIEZpbGVcXFwiOiBcXFwiVXBsb2FkIEZpbGVcXFwiLFxcbiAgICBcXFwiRHJvcCBmaWxlXFxcIjogXFxcIkRyb3AgZmlsZVxcXCIsXFxuXFxuICAgIC8vIEVtb3RpY29uc1xcbiAgICBcXFwiRW1vdGljb25zXFxcIjogXFxcIkVtb3RpY29uc1xcXCIsXFxuXFxuICAgIC8vIExpbmUgYnJlYWtlclxcbiAgICBcXFwiQnJlYWtcXFwiOiBcXFwiQnJlYWtcXFwiLFxcblxcbiAgICAvLyBNYXRoXFxuICAgIFxcXCJTdWJzY3JpcHRcXFwiOiBcXFwiU3Vic2NyaXB0XFxcIixcXG4gICAgXFxcIlN1cGVyc2NyaXB0XFxcIjogXFxcIlN1cGVyc2NyaXB0XFxcIixcXG5cXG4gICAgLy8gRnVsbCBzY3JlZW5cXG4gICAgXFxcIkZ1bGxzY3JlZW5cXFwiOiBcXFwiRnVsbHNjcmVlblxcXCIsXFxuXFxuICAgIC8vIEhvcml6b250YWwgbGluZVxcbiAgICBcXFwiSW5zZXJ0IEhvcml6b250YWwgTGluZVxcXCI6IFxcXCJJbnNlcnQgSG9yaXpvbnRhbCBMaW5lXFxcIixcXG5cXG4gICAgLy8gQ2xlYXIgZm9ybWF0dGluZ1xcbiAgICBcXFwiQ2xlYXIgRm9ybWF0dGluZ1xcXCI6IFxcXCJDZWxsIEZvcm1hdHRpbmdcXFwiLFxcblxcbiAgICAvLyBVbmRvLCByZWRvXFxuICAgIFxcXCJVbmRvXFxcIjogXFxcIlVuZG9cXFwiLFxcbiAgICBcXFwiUmVkb1xcXCI6IFxcXCJSZWRvXFxcIixcXG5cXG4gICAgLy8gU2VsZWN0IGFsbFxcbiAgICBcXFwiU2VsZWN0IEFsbFxcXCI6IFxcXCJTZWxlY3QgQWxsXFxcIixcXG5cXG4gICAgLy8gQ29kZSB2aWV3XFxuICAgIFxcXCJDb2RlIFZpZXdcXFwiOiBcXFwiQ29kZSBWaWV3XFxcIixcXG5cXG4gICAgLy8gUXVvdGVcXG4gICAgXFxcIlF1b3RlXFxcIjogXFxcIlF1b3RlXFxcIixcXG4gICAgXFxcIkluY3JlYXNlXFxcIjogXFxcIkluY3JlYXNlXFxcIixcXG4gICAgXFxcIkRlY3JlYXNlXFxcIjogXFxcIkRlY3JlYXNlXFxcIixcXG5cXG4gICAgLy8gUXVpY2sgSW5zZXJ0XFxuICAgIFxcXCJRdWljayBJbnNlcnRcXFwiOiBcXFwiUXVpY2sgSW5zZXJ0XFxcIlxcbiAgfSxcXG4gIGRpcmVjdGlvbjogXFxcImx0clxcXCJcXG59O1xcblwiXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3Jhdy1sb2FkZXIhLi9+L2Zyb2FsYS1lZGl0b3IvanMvbGFuZ3VhZ2VzL2VuX2diLmpzXG4vLyBtb2R1bGUgaWQgPSAyMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9");

/***/ }
]);