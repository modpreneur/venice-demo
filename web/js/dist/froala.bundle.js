webpackJsonp([0],[
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\n__webpack_require__(1);\n\n__webpack_require__(4);\n\n__webpack_require__(6);\n\n__webpack_require__(8);\n\n__webpack_require__(10);\n\n__webpack_require__(12);\n\n__webpack_require__(14);\n\n__webpack_require__(16);\n\n__webpack_require__(18);\n\n__webpack_require__(20);//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9ub2RlX21vZHVsZXMvdmVuaWNlLWpzL21haW5Gcm9hbGEuanM/NWM3MyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENyZWF0ZWQgYnkgYnVyMDEgb24gOS8xMi8xNi5cbiAqL1xuaW1wb3J0ICdzY3JpcHQhZnJvYWxhLWVkaXRvci9qcy9mcm9hbGFfZWRpdG9yLm1pbi5qcyc7XG5pbXBvcnQgJ3NjcmlwdCFjb2RlbWlycm9yL2xpYi9jb2RlbWlycm9yLmpzJztcbmltcG9ydCAnc2NyaXB0IWNvZGVtaXJyb3IvbW9kZS94bWwveG1sLmpzJztcbmltcG9ydCAnc2NyaXB0IWZyb2FsYS1lZGl0b3IvanMvcGx1Z2lucy9hbGlnbi5taW4uanMnO1xuaW1wb3J0ICdzY3JpcHQhZnJvYWxhLWVkaXRvci9qcy9wbHVnaW5zL2NoYXJfY291bnRlci5taW4uanMnO1xuaW1wb3J0ICdzY3JpcHQhZnJvYWxhLWVkaXRvci9qcy9wbHVnaW5zL2NvZGVfdmlldy5taW4uanMnO1xuaW1wb3J0ICdzY3JpcHQhZnJvYWxhLWVkaXRvci9qcy9wbHVnaW5zL2VudGl0aWVzLm1pbi5qcyc7XG5pbXBvcnQgJ3NjcmlwdCFmcm9hbGEtZWRpdG9yL2pzL3BsdWdpbnMvbGluay5taW4uanMnO1xuaW1wb3J0ICdzY3JpcHQhZnJvYWxhLWVkaXRvci9qcy9wbHVnaW5zL3VybC5taW4uanMnO1xuaW1wb3J0ICdzY3JpcHQhZnJvYWxhLWVkaXRvci9qcy9sYW5ndWFnZXMvZW5fZ2IuanMnO1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogbm9kZV9tb2R1bGVzL3ZlbmljZS1qcy9tYWluRnJvYWxhLmpzXG4gKiovIl0sIm1hcHBpbmdzIjoiOztBQUdBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBIiwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	eval("__webpack_require__(2)(__webpack_require__(3))//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL34vZnJvYWxhLWVkaXRvci9qcy9mcm9hbGFfZWRpdG9yLm1pbi5qcz9hOWQwIl0sInNvdXJjZXNDb250ZW50IjpbInJlcXVpcmUoXCIhIS92YXIvYXBwL3dlYi9qcy9ub2RlX21vZHVsZXMvc2NyaXB0LWxvYWRlci9hZGRTY3JpcHQuanNcIikocmVxdWlyZShcIiEhL3Zhci9hcHAvd2ViL2pzL25vZGVfbW9kdWxlcy9yYXctbG9hZGVyL2luZGV4LmpzIS92YXIvYXBwL3dlYi9qcy9ub2RlX21vZHVsZXMvZnJvYWxhLWVkaXRvci9qcy9mcm9hbGFfZWRpdG9yLm1pbi5qc1wiKSlcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9zY3JpcHQtbG9hZGVyIS4vfi9mcm9hbGEtZWRpdG9yL2pzL2Zyb2FsYV9lZGl0b3IubWluLmpzXG4gKiogbW9kdWxlIGlkID0gMVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIl0sIm1hcHBpbmdzIjoiQUFBQSIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 2 */
/***/ function(module, exports) {

	eval("/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\r\nmodule.exports = function(src) {\r\n\tif (typeof execScript !== \"undefined\")\r\n\t\texecScript(src);\r\n\telse\r\n\t\teval.call(null, src);\r\n}\r\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL34vc2NyaXB0LWxvYWRlci9hZGRTY3JpcHQuanM/ODEwNyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxyXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXHJcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxyXG4qL1xyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHNyYykge1xyXG5cdGlmICh0eXBlb2YgZXhlY1NjcmlwdCAhPT0gXCJ1bmRlZmluZWRcIilcclxuXHRcdGV4ZWNTY3JpcHQoc3JjKTtcclxuXHRlbHNlXHJcblx0XHRldmFsLmNhbGwobnVsbCwgc3JjKTtcclxufVxyXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9zY3JpcHQtbG9hZGVyL2FkZFNjcmlwdC5qc1xuICoqIG1vZHVsZSBpZCA9IDJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 3 */
/***/ function(module, exports) {

	eval("module.exports = \"/*!\\n * froala_editor v2.3.4 (https://www.froala.com/wysiwyg-editor)\\n * License https://froala.com/wysiwyg-editor/terms/\\n * Copyright 2014-2016 Froala Labs\\n */\\n\\n!function(a){\\\"function\\\"==typeof define&&define.amd?define([\\\"jquery\\\"],a):\\\"object\\\"==typeof module&&module.exports?module.exports=function(b,c){return void 0===c&&(c=\\\"undefined\\\"!=typeof window?require(\\\"jquery\\\"):require(\\\"jquery\\\")(b)),a(c),c}:a(jQuery)}(function(a){\\\"use strict\\\";var b=function(c,d){this.id=++a.FE.ID,this.opts=a.extend(!0,{},a.extend({},b.DEFAULTS,\\\"object\\\"==typeof d&&d));var e=JSON.stringify(this.opts);a.FE.OPTS_MAPPING[e]=a.FE.OPTS_MAPPING[e]||this.id,this.sid=a.FE.OPTS_MAPPING[e],a.FE.SHARED[this.sid]=a.FE.SHARED[this.sid]||{},this.shared=a.FE.SHARED[this.sid],this.shared.count=(this.shared.count||0)+1,this.$oel=a(c),this.$oel.data(\\\"froala.editor\\\",this),this.o_doc=c.ownerDocument,this.o_win=\\\"defaultView\\\"in this.o_doc?this.o_doc.defaultView:this.o_doc.parentWindow;var f=a(this.o_win).scrollTop();this.$oel.on(\\\"froala.doInit\\\",a.proxy(function(){this.$oel.off(\\\"froala.doInit\\\"),this.doc=this.$el.get(0).ownerDocument,this.win=\\\"defaultView\\\"in this.doc?this.doc.defaultView:this.doc.parentWindow,this.$doc=a(this.doc),this.$win=a(this.win),this.opts.pluginsEnabled||(this.opts.pluginsEnabled=Object.keys(a.FE.PLUGINS)),this.opts.initOnClick?(this.load(a.FE.MODULES),this.$el.on(\\\"touchstart.init\\\",function(){a(this).data(\\\"touched\\\",!0)}),this.$el.on(\\\"touchmove.init\\\",function(){a(this).removeData(\\\"touched\\\")}),this.$el.on(\\\"mousedown.init touchend.init dragenter.init focus.init\\\",a.proxy(function(b){if(\\\"touchend\\\"==b.type&&!this.$el.data(\\\"touched\\\"))return!0;if(1===b.which||0===b.which){this.$el.off(\\\"mousedown.init touchstart.init touchmove.init touchend.init dragenter.init focus.init\\\"),this.load(a.FE.MODULES),this.load(a.FE.PLUGINS);var c=b.originalEvent&&b.originalEvent.originalTarget;c&&\\\"IMG\\\"==c.tagName&&a(c).trigger(\\\"mousedown\\\"),\\\"undefined\\\"==typeof this.ul&&this.destroy(),\\\"touchend\\\"==b.type&&this.image&&b.originalEvent&&b.originalEvent.target&&a(b.originalEvent.target).is(\\\"img\\\")&&setTimeout(a.proxy(function(){this.image.edit(a(b.originalEvent.target))},this),100),this.events.trigger(\\\"initialized\\\")}},this))):(this.load(a.FE.MODULES),this.load(a.FE.PLUGINS),a(this.o_win).scrollTop(f),\\\"undefined\\\"==typeof this.ul&&this.destroy(),this.events.trigger(\\\"initialized\\\"))},this)),this._init()};b.DEFAULTS={initOnClick:!1,pluginsEnabled:null},b.MODULES={},b.PLUGINS={},b.VERSION=\\\"2.3.4\\\",b.INSTANCES=[],b.OPTS_MAPPING={},b.SHARED={},b.ID=0,b.prototype._init=function(){var b=this.$oel.prop(\\\"tagName\\\"),c=a.proxy(function(){this._original_html=this._original_html||this.$oel.html(),this.$box=this.$box||this.$oel,this.opts.fullPage&&(this.opts.iframe=!0),this.opts.iframe?(this.$iframe=a('<iframe src=\\\"about:blank\\\" frameBorder=\\\"0\\\">'),this.$wp=a(\\\"<div></div>\\\"),this.$box.html(this.$wp),this.$wp.append(this.$iframe),this.$iframe.get(0).contentWindow.document.open(),this.$iframe.get(0).contentWindow.document.write(\\\"<!DOCTYPE html>\\\"),this.$iframe.get(0).contentWindow.document.write(\\\"<html><head></head><body></body></html>\\\"),this.$iframe.get(0).contentWindow.document.close(),this.$el=this.$iframe.contents().find(\\\"body\\\"),this.$head=this.$iframe.contents().find(\\\"head\\\"),this.$html=this.$iframe.contents().find(\\\"html\\\"),this.iframe_document=this.$iframe.get(0).contentWindow.document,this.$oel.trigger(\\\"froala.doInit\\\")):(this.$el=a(\\\"<div></div>\\\"),this.$wp=a(\\\"<div></div>\\\").append(this.$el),this.$box.html(this.$wp),this.$oel.trigger(\\\"froala.doInit\\\"))},this),d=a.proxy(function(){this.$box=a(\\\"<div>\\\"),this.$oel.before(this.$box).hide(),this._original_html=this.$oel.val(),this.$oel.parents(\\\"form\\\").on(\\\"submit.\\\"+this.id,a.proxy(function(){this.events.trigger(\\\"form.submit\\\")},this)),this.$oel.parents(\\\"form\\\").on(\\\"reset.\\\"+this.id,a.proxy(function(){this.events.trigger(\\\"form.reset\\\")},this)),c()},this),e=a.proxy(function(){this.$el=this.$oel,this.$el.attr(\\\"contenteditable\\\",!0).css(\\\"outline\\\",\\\"none\\\").css(\\\"display\\\",\\\"inline-block\\\"),this.opts.multiLine=!1,this.opts.toolbarInline=!1,this.$oel.trigger(\\\"froala.doInit\\\")},this),f=a.proxy(function(){this.$el=this.$oel,this.opts.toolbarInline=!1,this.$oel.trigger(\\\"froala.doInit\\\")},this),g=a.proxy(function(){this.$el=this.$oel,this.opts.toolbarInline=!1,this.$oel.on(\\\"click.popup\\\",function(a){a.preventDefault()}),this.$oel.trigger(\\\"froala.doInit\\\")},this);this.opts.editInPopup?g():\\\"TEXTAREA\\\"==b?d():\\\"A\\\"==b?e():\\\"IMG\\\"==b?f():\\\"BUTTON\\\"==b||\\\"INPUT\\\"==b?(this.opts.editInPopup=!0,this.opts.toolbarInline=!1,g()):c()},b.prototype.load=function(b){for(var c in b)if(b.hasOwnProperty(c)){if(this[c])continue;if(a.FE.PLUGINS[c]&&this.opts.pluginsEnabled.indexOf(c)<0)continue;if(this[c]=new b[c](this),this[c]._init&&(this[c]._init(),this.opts.initOnClick&&\\\"core\\\"==c))return!1}},b.prototype.destroy=function(){this.shared.count--,this.events.$off();var b=this.html.get();if(this.events.trigger(\\\"destroy\\\",[],!0),this.events.trigger(\\\"shared.destroy\\\",void 0,!0),0===this.shared.count){for(var c in this.shared)this.shared.hasOwnProperty(c)&&(null==this.shared[c],a.FE.SHARED[this.sid][c]=null);a.FE.SHARED[this.sid]={}}this.$oel.parents(\\\"form\\\").off(\\\".\\\"+this.id),this.$oel.off(\\\"click.popup\\\"),this.$oel.removeData(\\\"froala.editor\\\"),this.core.destroy(b),a.FE.INSTANCES.splice(a.FE.INSTANCES.indexOf(this),1)},a.fn.froalaEditor=function(c){for(var d=[],e=0;e<arguments.length;e++)d.push(arguments[e]);if(\\\"string\\\"==typeof c){var f=[];return this.each(function(){var b=a(this),e=b.data(\\\"froala.editor\\\");if(e){var g,h;if(c.indexOf(\\\".\\\")>0&&e[c.split(\\\".\\\")[0]]?(e[c.split(\\\".\\\")[0]]&&(g=e[c.split(\\\".\\\")[0]]),h=c.split(\\\".\\\")[1]):(g=e,h=c.split(\\\".\\\")[0]),!g[h])return a.error(\\\"Method \\\"+c+\\\" does not exist in Froala Editor.\\\");var i=g[h].apply(e,d.slice(1));void 0===i?f.push(this):0===f.length&&f.push(i)}}),1==f.length?f[0]:f}return\\\"object\\\"!=typeof c&&c?void 0:this.each(function(){var d=a(this).data(\\\"froala.editor\\\");if(!d){var e=this;new b(e,c)}})},a.fn.froalaEditor.Constructor=b,a.FroalaEditor=b,a.FE=b,a.FE.MODULES.node=function(b){function c(b){return b&&\\\"IFRAME\\\"!=b.tagName?a(b).contents():[]}function d(b){return b?b.nodeType!=Node.ELEMENT_NODE?!1:a.FE.BLOCK_TAGS.indexOf(b.tagName.toLowerCase())>=0:!1}function e(e,f){if(a(e).find(\\\"table\\\").length>0)return!1;if(e.querySelectorAll(a.FE.VOID_ELEMENTS.join(\\\",\\\")).length-e.querySelectorAll(\\\"br\\\").length)return!1;if(e.querySelectorAll(b.opts.htmlAllowedEmptyTags.join(\\\":not(.fr-marker),\\\")+\\\":not(.fr-marker)\\\").length)return!1;if(e.querySelectorAll(a.FE.BLOCK_TAGS.join(\\\",\\\")).length>1)return!1;if(e.querySelectorAll(b.opts.htmlDoNotWrapTags.join(\\\":not(.fr-marker),\\\")+\\\":not(.fr-marker)\\\").length)return!1;var g=c(e);1==g.length&&d(g[0])&&(g=c(g[0]));for(var h=!1,i=0;i<g.length;i++){var j=g[i];if(!(f&&a(j).hasClass(\\\"fr-marker\\\")||j.nodeType==Node.TEXT_NODE&&0==j.textContent.length)){if(\\\"BR\\\"!=j.tagName&&(j.textContent||\\\"\\\").replace(/\\\\u200B/gi,\\\"\\\").replace(/\\\\n/g,\\\"\\\").length>0)return!1;if(h)return!1;\\\"BR\\\"==j.tagName&&(h=!0)}}return!0}function f(c){for(;c&&c.parentNode!==b.$el.get(0)&&(!c.parentNode||!a(c.parentNode).hasClass(\\\"fr-inner\\\"));)if(c=c.parentNode,d(c))return c;return null}function g(c,e,f){if(\\\"undefined\\\"==typeof e&&(e=[]),\\\"undefined\\\"==typeof f&&(f=!0),e.push(b.$el.get(0)),e.indexOf(c.parentNode)>=0||c.parentNode&&a(c.parentNode).hasClass(\\\"fr-inner\\\")||c.parentNode&&a.FE.SIMPLE_ENTER_TAGS.indexOf(c.parentNode.tagName)>=0&&f)return null;for(;e.indexOf(c.parentNode)<0&&c.parentNode&&!a(c.parentNode).hasClass(\\\"fr-inner\\\")&&(a.FE.SIMPLE_ENTER_TAGS.indexOf(c.parentNode.tagName)<0||!f)&&(!d(c)||!d(c.parentNode)||!f);)c=c.parentNode;return c}function h(a){var b={},c=a.attributes;if(c)for(var d=0;d<c.length;d++){var e=c[d];b[e.nodeName]=e.value}return b}function i(a){for(var b=\\\"\\\",c=h(a),d=Object.keys(c).sort(),e=0;e<d.length;e++){var f=d[e],g=c[f];b+=g.indexOf('\\\"')<0?\\\" \\\"+f+'=\\\"'+g+'\\\"':\\\" \\\"+f+\\\"='\\\"+g+\\\"'\\\"}return b}function j(a){for(var b=a.attributes,c=0;c<b.length;c++){var d=b[c];a.removeAttribute(d.nodeName)}}function k(a){return\\\"<\\\"+a.tagName.toLowerCase()+i(a)+\\\">\\\"}function l(a){return\\\"</\\\"+a.tagName.toLowerCase()+\\\">\\\"}function m(b,c){\\\"undefined\\\"==typeof c&&(c=!0);for(var d=b.previousSibling;d&&c&&a(d).hasClass(\\\"fr-marker\\\");)d=d.previousSibling;return d?d.nodeType==Node.TEXT_NODE&&\\\"\\\"===d.textContent?m(d):!1:!0}function n(b,c){\\\"undefined\\\"==typeof c&&(c=!0);for(var d=b.nextSibling;d&&c&&a(d).hasClass(\\\"fr-marker\\\");)d=d.nextSibling;return d?d.nodeType==Node.TEXT_NODE&&\\\"\\\"===d.textContent?n(d):!1:!0}function o(b){return b&&b.nodeType==Node.ELEMENT_NODE&&a.FE.VOID_ELEMENTS.indexOf((b.tagName||\\\"\\\").toLowerCase())>=0}function p(a){return a?[\\\"UL\\\",\\\"OL\\\"].indexOf(a.tagName)>=0:!1}function q(a){return a===b.$el.get(0)}function r(a){return a&&a.className&&(a.className||\\\"\\\").indexOf(\\\"fr-deletable\\\")>=0}function s(a){return a===b.doc.activeElement&&(!b.doc.hasFocus||b.doc.hasFocus())&&!!(q(a)||a.type||a.href||~a.tabIndex)}function t(a){return(!a.getAttribute||\\\"false\\\"!=a.getAttribute(\\\"contenteditable\\\"))&&[\\\"STYLE\\\",\\\"SCRIPT\\\"].indexOf(a.tagName)<0}return{isBlock:d,isEmpty:e,blockParent:f,deepestParent:g,rawAttributes:h,attributes:i,clearAttributes:j,openTagString:k,closeTagString:l,isFirstSibling:m,isLastSibling:n,isList:p,isElement:q,contents:c,isVoid:o,hasFocus:s,isEditable:t,isDeletable:r}},a.extend(a.FE.DEFAULTS,{htmlAllowedTags:[\\\"a\\\",\\\"abbr\\\",\\\"address\\\",\\\"area\\\",\\\"article\\\",\\\"aside\\\",\\\"audio\\\",\\\"b\\\",\\\"base\\\",\\\"bdi\\\",\\\"bdo\\\",\\\"blockquote\\\",\\\"br\\\",\\\"button\\\",\\\"canvas\\\",\\\"caption\\\",\\\"cite\\\",\\\"code\\\",\\\"col\\\",\\\"colgroup\\\",\\\"datalist\\\",\\\"dd\\\",\\\"del\\\",\\\"details\\\",\\\"dfn\\\",\\\"dialog\\\",\\\"div\\\",\\\"dl\\\",\\\"dt\\\",\\\"em\\\",\\\"embed\\\",\\\"fieldset\\\",\\\"figcaption\\\",\\\"figure\\\",\\\"footer\\\",\\\"form\\\",\\\"h1\\\",\\\"h2\\\",\\\"h3\\\",\\\"h4\\\",\\\"h5\\\",\\\"h6\\\",\\\"header\\\",\\\"hgroup\\\",\\\"hr\\\",\\\"i\\\",\\\"iframe\\\",\\\"img\\\",\\\"input\\\",\\\"ins\\\",\\\"kbd\\\",\\\"keygen\\\",\\\"label\\\",\\\"legend\\\",\\\"li\\\",\\\"link\\\",\\\"main\\\",\\\"map\\\",\\\"mark\\\",\\\"menu\\\",\\\"menuitem\\\",\\\"meter\\\",\\\"nav\\\",\\\"noscript\\\",\\\"object\\\",\\\"ol\\\",\\\"optgroup\\\",\\\"option\\\",\\\"output\\\",\\\"p\\\",\\\"param\\\",\\\"pre\\\",\\\"progress\\\",\\\"queue\\\",\\\"rp\\\",\\\"rt\\\",\\\"ruby\\\",\\\"s\\\",\\\"samp\\\",\\\"script\\\",\\\"style\\\",\\\"section\\\",\\\"select\\\",\\\"small\\\",\\\"source\\\",\\\"span\\\",\\\"strike\\\",\\\"strong\\\",\\\"sub\\\",\\\"summary\\\",\\\"sup\\\",\\\"table\\\",\\\"tbody\\\",\\\"td\\\",\\\"textarea\\\",\\\"tfoot\\\",\\\"th\\\",\\\"thead\\\",\\\"time\\\",\\\"tr\\\",\\\"track\\\",\\\"u\\\",\\\"ul\\\",\\\"var\\\",\\\"video\\\",\\\"wbr\\\"],htmlRemoveTags:[\\\"script\\\",\\\"style\\\"],htmlAllowedAttrs:[\\\"accept\\\",\\\"accept-charset\\\",\\\"accesskey\\\",\\\"action\\\",\\\"align\\\",\\\"allowfullscreen\\\",\\\"allowtransparency\\\",\\\"alt\\\",\\\"async\\\",\\\"autocomplete\\\",\\\"autofocus\\\",\\\"autoplay\\\",\\\"autosave\\\",\\\"background\\\",\\\"bgcolor\\\",\\\"border\\\",\\\"charset\\\",\\\"cellpadding\\\",\\\"cellspacing\\\",\\\"checked\\\",\\\"cite\\\",\\\"class\\\",\\\"color\\\",\\\"cols\\\",\\\"colspan\\\",\\\"content\\\",\\\"contenteditable\\\",\\\"contextmenu\\\",\\\"controls\\\",\\\"coords\\\",\\\"data\\\",\\\"data-.*\\\",\\\"datetime\\\",\\\"default\\\",\\\"defer\\\",\\\"dir\\\",\\\"dirname\\\",\\\"disabled\\\",\\\"download\\\",\\\"draggable\\\",\\\"dropzone\\\",\\\"enctype\\\",\\\"for\\\",\\\"form\\\",\\\"formaction\\\",\\\"frameborder\\\",\\\"headers\\\",\\\"height\\\",\\\"hidden\\\",\\\"high\\\",\\\"href\\\",\\\"hreflang\\\",\\\"http-equiv\\\",\\\"icon\\\",\\\"id\\\",\\\"ismap\\\",\\\"itemprop\\\",\\\"keytype\\\",\\\"kind\\\",\\\"label\\\",\\\"lang\\\",\\\"language\\\",\\\"list\\\",\\\"loop\\\",\\\"low\\\",\\\"max\\\",\\\"maxlength\\\",\\\"media\\\",\\\"method\\\",\\\"min\\\",\\\"mozallowfullscreen\\\",\\\"multiple\\\",\\\"name\\\",\\\"novalidate\\\",\\\"open\\\",\\\"optimum\\\",\\\"pattern\\\",\\\"ping\\\",\\\"placeholder\\\",\\\"poster\\\",\\\"preload\\\",\\\"pubdate\\\",\\\"radiogroup\\\",\\\"readonly\\\",\\\"rel\\\",\\\"required\\\",\\\"reversed\\\",\\\"rows\\\",\\\"rowspan\\\",\\\"sandbox\\\",\\\"scope\\\",\\\"scoped\\\",\\\"scrolling\\\",\\\"seamless\\\",\\\"selected\\\",\\\"shape\\\",\\\"size\\\",\\\"sizes\\\",\\\"span\\\",\\\"src\\\",\\\"srcdoc\\\",\\\"srclang\\\",\\\"srcset\\\",\\\"start\\\",\\\"step\\\",\\\"summary\\\",\\\"spellcheck\\\",\\\"style\\\",\\\"tabindex\\\",\\\"target\\\",\\\"title\\\",\\\"type\\\",\\\"translate\\\",\\\"usemap\\\",\\\"value\\\",\\\"valign\\\",\\\"webkitallowfullscreen\\\",\\\"width\\\",\\\"wrap\\\"],htmlAllowComments:!0,fullPage:!1}),a.FE.HTML5Map={B:\\\"STRONG\\\",I:\\\"EM\\\",STRIKE:\\\"S\\\"},a.FE.MODULES.clean=function(b){function c(a){if(a.className&&a.className.indexOf(\\\"fr-marker\\\")>=0)return!1;var d,e=b.node.contents(a),f=[];for(d=0;d<e.length;d++)e[d].nodeType!=Node.ELEMENT_NODE||b.node.isVoid(e[d])?e[d].nodeType==Node.TEXT_NODE&&(e[d].textContent=e[d].textContent.replace(/\\\\u200b/g,\\\"\\\")):e[d].textContent.replace(/\\\\u200b/g,\\\"\\\").length!=e[d].textContent.length&&c(e[d]);if(a.nodeType==Node.ELEMENT_NODE&&!b.node.isVoid(a)&&(a.normalize(),e=b.node.contents(a),f=a.querySelectorAll(\\\".fr-marker\\\"),e.length-f.length==0)){for(d=0;d<e.length;d++)if((e[d].className||\\\"\\\").indexOf(\\\"fr-marker\\\")<0)return!1;for(d=0;d<f.length;d++)a.parentNode.insertBefore(f[d].cloneNode(!0),a);return a.parentNode.removeChild(a),!1}}function d(a){if(a.nodeType==Node.COMMENT_NODE)return\\\"<!--\\\"+a.nodeValue+\\\"-->\\\";if(a.nodeType==Node.TEXT_NODE)return a.textContent.replace(/\\\\</g,\\\"&lt;\\\").replace(/\\\\>/g,\\\"&gt;\\\").replace(/\\\\u00A0/g,\\\"&nbsp;\\\");if(a.nodeType!=Node.ELEMENT_NODE)return a.outerHTML;if(a.nodeType==Node.ELEMENT_NODE&&[\\\"STYLE\\\",\\\"SCRIPT\\\"].indexOf(a.tagName)>=0)return a.outerHTML;if(\\\"IFRAME\\\"==a.tagName)return a.outerHTML;var c=a.childNodes;if(0===c.length)return a.outerHTML;for(var e=\\\"\\\",f=0;f<c.length;f++)e+=d(c[f]);return b.node.openTagString(a)+e+b.node.closeTagString(a)}function e(a){return I=[],a=a.replace(/<script\\\\b[^<]*(?:(?!<\\\\/script>)<[^<]*)*<\\\\/script>/gi,function(a){return I.push(a),\\\"[FROALA.EDITOR.SCRIPT \\\"+(I.length-1)+\\\"]\\\"}),a=a.replace(/<img((?:[\\\\w\\\\W]*?)) src=\\\"/g,'<img$1 data-fr-src=\\\"')}function f(a){return a=a.replace(/\\\\[FROALA\\\\.EDITOR\\\\.SCRIPT ([\\\\d]*)\\\\]/gi,function(a,c){return b.opts.htmlRemoveTags.indexOf(\\\"script\\\")>=0?\\\"\\\":I[parseInt(c,10)]}),a=a.replace(/<img((?:[\\\\w\\\\W]*?)) data-fr-src=\\\"/g,'<img$1 src=\\\"')}function g(a){var b;for(b in a)a.hasOwnProperty(b)&&(b.match(H)||delete a[b]);for(var c=\\\"\\\",d=Object.keys(a).sort(),e=0;e<d.length;e++)b=d[e],c+=a[b].indexOf('\\\"')<0?\\\" \\\"+b+'=\\\"'+a[b]+'\\\"':\\\" \\\"+b+\\\"='\\\"+a[b]+\\\"'\\\";return c}function h(a,c,d){if(b.opts.fullPage){var e=b.html.extractDoctype(d),f=g(b.html.extractNodeAttrs(d,\\\"html\\\"));c=null==c?b.html.extractNode(d,\\\"head\\\")||\\\"<title></title>\\\":c;var h=g(b.html.extractNodeAttrs(d,\\\"head\\\")),i=g(b.html.extractNodeAttrs(d,\\\"body\\\"));return e+\\\"<html\\\"+f+\\\"><head\\\"+h+\\\">\\\"+c+\\\"</head><body\\\"+i+\\\">\\\"+a+\\\"</body></html>\\\"}return a}function i(c,e){var f=a(\\\"<div>\\\"+c+\\\"</div>\\\"),g=\\\"\\\";if(f){for(var h=b.node.contents(f.get(0)),i=0;i<h.length;i++)e(h[i]);h=b.node.contents(f.get(0));for(var i=0;i<h.length;i++)g+=d(h[i])}return g}function j(a,c,d){a=e(a);var g=a,j=null;if(b.opts.fullPage){var g=b.html.extractNode(a,\\\"body\\\")||(a.indexOf(\\\"<body\\\")>=0?\\\"\\\":a);d&&(j=b.html.extractNode(a,\\\"head\\\")||\\\"\\\")}g=i(g,c),j&&(j=i(j,c));var k=h(g,j,a);return f(k)}function k(a){return a.replace(/\\\\u200b/g,\\\"\\\").length==a.length?a:b.clean.exec(a,c)}function l(){var c=b.$el.get(0).querySelectorAll(Object.keys(a.FE.HTML5Map).join(\\\",\\\"));if(c.length){b.selection.save();for(var d=0;d<c.length;d++)\\\"\\\"===b.node.attributes(c[d])&&a(c[d]).replaceWith(\\\"<\\\"+a.FE.HTML5Map[c[d].tagName]+\\\">\\\"+c[d].innerHTML+\\\"</\\\"+a.FE.HTML5Map[c[d].tagName]+\\\">\\\");b.selection.restore()}}function m(c){if(\\\"SPAN\\\"==c.tagName&&(c.className||\\\"\\\").indexOf(\\\"fr-marker\\\")>=0)return!1;if(\\\"PRE\\\"==c.tagName&&o(c),c.nodeType==Node.ELEMENT_NODE&&(c.getAttribute(\\\"data-fr-src\\\")&&c.setAttribute(\\\"data-fr-src\\\",b.helpers.sanitizeURL(c.getAttribute(\\\"data-fr-src\\\"))),c.getAttribute(\\\"href\\\")&&c.setAttribute(\\\"href\\\",b.helpers.sanitizeURL(c.getAttribute(\\\"href\\\"))),[\\\"TABLE\\\",\\\"TBODY\\\",\\\"TFOOT\\\",\\\"TR\\\"].indexOf(c.tagName)>=0&&(c.innerHTML=c.innerHTML.trim())),!b.opts.pasteAllowLocalImages&&c.nodeType==Node.ELEMENT_NODE&&\\\"IMG\\\"==c.tagName&&c.getAttribute(\\\"data-fr-src\\\")&&0==c.getAttribute(\\\"data-fr-src\\\").indexOf(\\\"file://\\\"))return c.parentNode.removeChild(c),!1;if(c.nodeType==Node.ELEMENT_NODE&&a.FE.HTML5Map[c.tagName]&&\\\"\\\"===b.node.attributes(c)){var d=a.FE.HTML5Map[c.tagName],e=\\\"<\\\"+d+\\\">\\\"+c.innerHTML+\\\"</\\\"+d+\\\">\\\";c.insertAdjacentHTML(\\\"beforebegin\\\",e),c=c.previousSibling,c.parentNode.removeChild(c.nextSibling)}if(b.opts.htmlAllowComments||c.nodeType!=Node.COMMENT_NODE)if(c.tagName&&c.tagName.match(G))c.parentNode.removeChild(c);else if(c.tagName&&!c.tagName.match(F))c.outerHTML=c.innerHTML;else{var f=c.attributes;if(f)for(var g=f.length-1;g>=0;g--){var h=f[g];h.nodeName.match(H)||c.removeAttribute(h.nodeName)}}else 0!==c.data.indexOf(\\\"[FROALA.EDITOR\\\")&&c.parentNode.removeChild(c)}function n(a){for(var c=b.node.contents(a),d=0;d<c.length;d++)c[d].nodeType!=Node.TEXT_NODE&&n(c[d]);m(a)}function o(a){var b=a.innerHTML;b.indexOf(\\\"\\\\n\\\")>=0&&(a.innerHTML=b.replace(/\\\\n/g,\\\"<br>\\\"))}function p(c,d,e,f){\\\"undefined\\\"==typeof d&&(d=[]),\\\"undefined\\\"==typeof e&&(e=[]),\\\"undefined\\\"==typeof f&&(f=!1),c=c.replace(/\\\\u0009/g,\\\"\\\");var g,h=a.merge([],b.opts.htmlAllowedTags);for(g=0;g<d.length;g++)h.indexOf(d[g])>=0&&h.splice(h.indexOf(d[g]),1);var i=a.merge([],b.opts.htmlAllowedAttrs);for(g=0;g<e.length;g++)i.indexOf(e[g])>=0&&i.splice(i.indexOf(e[g]),1);return i.push(\\\"data-fr-.*\\\"),i.push(\\\"fr-.*\\\"),F=new RegExp(\\\"^\\\"+h.join(\\\"$|^\\\")+\\\"$\\\",\\\"gi\\\"),H=new RegExp(\\\"^\\\"+i.join(\\\"$|^\\\")+\\\"$\\\",\\\"gi\\\"),G=new RegExp(\\\"^\\\"+b.opts.htmlRemoveTags.join(\\\"$|^\\\")+\\\"$\\\",\\\"gi\\\"),c=j(c,n,!0)}function q(){for(var c=b.$el.get(0).querySelectorAll(\\\"blockquote + blockquote\\\"),d=0;d<c.length;d++){var e=c[d];b.node.attributes(e)==b.node.attributes(e.previousSibling)&&(a(e).prev().append(a(e).html()),a(e).remove())}}function r(){for(var a=b.$el.get(0).querySelectorAll(\\\"tr\\\"),c=0;c<a.length;c++){for(var d=a[c].children,e=!0,f=0;f<d.length;f++)if(\\\"TH\\\"!=d[f].tagName){e=!1;break}if(0!=e&&0!=d.length){for(var g=a[c];g&&\\\"TABLE\\\"!=g.tagName&&\\\"THEAD\\\"!=g.tagName;)g=g.parentNode;var h=g;\\\"THEAD\\\"!=h.tagName&&(h=b.doc.createElement(\\\"THEAD\\\"),g.insertBefore(h,g.firstChild)),h.appendChild(a[c])}}}function s(){for(var c=b.$el.get(0).querySelectorAll(\\\"table\\\"),d=0;d<c.length;d++){for(var e=c[d].previousSibling;e&&e.nodeType==Node.TEXT_NODE&&0==e.textContent.length;)e=e.previousSibling;!e||b.node.isBlock(e)||\\\"BR\\\"==e.tagName||e.nodeType!=Node.TEXT_NODE&&e.nodeType!=Node.ELEMENT_NODE||a(e).is(b.opts.htmlDoNotWrapTags.join(\\\",\\\"))||c[d].parentNode.insertBefore(b.doc.createElement(\\\"br\\\"),c[d])}}function t(){var c=b.html.defaultTag();if(c)for(var d=b.$el.get(0).querySelectorAll(\\\"td > \\\"+c+\\\", th > \\\"+c),e=0;e<d.length;e++)\\\"\\\"===b.node.attributes(d[e])&&a(d[e]).replaceWith(d[e].innerHTML+\\\"<br>\\\")}function u(){r(),s(),t()}function v(){var a=[],c=function(a){return!b.node.isList(a.parentNode)};do{if(a.length){var d=a[0],e=b.doc.createElement(\\\"ul\\\");d.parentNode.insertBefore(e,d);do{var f=d;d=d.nextSibling,e.appendChild(f)}while(d&&\\\"LI\\\"==d.tagName)}a=[];for(var g=b.$el.get(0).querySelectorAll(\\\"li\\\"),h=0;h<g.length;h++)c(g[h])&&a.push(g[h])}while(a.length>0)}function w(){for(var a=b.$el.get(0).querySelectorAll(\\\"ol + ol, ul + ul\\\"),c=0;c<a.length;c++){var d=a[c];if(b.node.isList(d.previousSibling)&&b.node.openTagString(d)==b.node.openTagString(d.previousSibling)){for(var e=b.node.contents(d),f=0;f<e.length;f++)d.previousSibling.appendChild(e[f]);d.parentNode.removeChild(d)}}}function x(){var a,c=function(b){0===b.querySelectorAll(\\\"LI\\\").length&&(a=!0,b.parentNode.removeChild(b))};do{a=!1;for(var d=b.$el.get(0).querySelectorAll(\\\"li:empty\\\"),e=0;e<d.length;e++)d[e].parentNode.removeChild(d[e]);for(var f=b.$el.get(0).querySelectorAll(\\\"ul, ol\\\"),e=0;e<f.length;e++)c(f[e])}while(a===!0)}function y(){for(var c=b.$el.get(0).querySelectorAll(\\\"ul > ul, ol > ol, ul > ol, ol > ul\\\"),d=0;d<c.length;d++){var e=c[d],f=e.previousSibling;f&&(\\\"LI\\\"==f.tagName?f.appendChild(e):a(e).wrap(\\\"<li></li>\\\"))}}function z(){for(var c=b.$el.get(0).querySelectorAll(\\\"li > ul, li > ol\\\"),d=0;d<c.length;d++){var e=c[d];if(e.nextSibling){var f=e.nextSibling,g=a(\\\"<li>\\\");a(e.parentNode).after(g);do{var h=f;f=f.nextSibling,g.append(h)}while(f)}}}function A(){for(var c=b.$el.get(0).querySelectorAll(\\\"li > ul, li > ol\\\"),d=0;d<c.length;d++){var e=c[d];if(b.node.isFirstSibling(e))a(e).before(\\\"<br/>\\\");else if(e.previousSibling&&\\\"BR\\\"==e.previousSibling.tagName){for(var f=e.previousSibling.previousSibling;f&&a(f).hasClass(\\\"fr-marker\\\");)f=f.previousSibling;f&&\\\"BR\\\"!=f.tagName&&a(e.previousSibling).remove()}}}function B(){for(var c=b.$el.get(0).querySelectorAll(\\\"li:empty\\\"),d=0;d<c.length;d++)a(c[d]).remove()}function C(){for(var c=b.$el.get(0).querySelectorAll(\\\"ul, ol\\\"),d=0;d<c.length;d++)for(var e=b.node.contents(c[d]),f=null,g=e.length-1;g>=0;g--)\\\"LI\\\"!=e[g].tagName?(f||(f=a(\\\"<li>\\\"),f.insertBefore(e[g])),f.append(e[g])):f=null}function D(){v(),w(),x(),y(),z(),A(),C(),B()}function E(){b.opts.fullPage&&a.merge(b.opts.htmlAllowedTags,[\\\"head\\\",\\\"title\\\",\\\"style\\\",\\\"link\\\",\\\"base\\\",\\\"body\\\",\\\"html\\\"])}var F,G,H,I=[],I=[];return{_init:E,html:p,toHTML5:l,tables:u,lists:D,quotes:q,invisibleSpaces:k,exec:j}},a.FE.XS=0,a.FE.SM=1,a.FE.MD=2,a.FE.LG=3,a.FE.MODULES.helpers=function(b){function c(){var a,b,c=-1;return\\\"Microsoft Internet Explorer\\\"==navigator.appName?(a=navigator.userAgent,b=new RegExp(\\\"MSIE ([0-9]{1,}[\\\\\\\\.0-9]{0,})\\\"),null!==b.exec(a)&&(c=parseFloat(RegExp.$1))):\\\"Netscape\\\"==navigator.appName&&(a=navigator.userAgent,b=new RegExp(\\\"Trident/.*rv:([0-9]{1,}[\\\\\\\\.0-9]{0,})\\\"),null!==b.exec(a)&&(c=parseFloat(RegExp.$1))),c}function d(){var a={},b=c();if(b>0)a.msie=!0;else{var d=navigator.userAgent.toLowerCase(),e=/(edge)[ \\\\/]([\\\\w.]+)/.exec(d)||/(chrome)[ \\\\/]([\\\\w.]+)/.exec(d)||/(webkit)[ \\\\/]([\\\\w.]+)/.exec(d)||/(opera)(?:.*version|)[ \\\\/]([\\\\w.]+)/.exec(d)||/(msie) ([\\\\w.]+)/.exec(d)||d.indexOf(\\\"compatible\\\")<0&&/(mozilla)(?:.*? rv:([\\\\w.]+)|)/.exec(d)||[],f={browser:e[1]||\\\"\\\",version:e[2]||\\\"0\\\"};e[1]&&(a[f.browser]=!0),a.chrome?a.webkit=!0:a.webkit&&(a.safari=!0)}return a.msie&&(a.version=b),a}function e(){return/(iPad|iPhone|iPod)/g.test(navigator.userAgent)&&!h()}function f(){return/(Android)/g.test(navigator.userAgent)&&!h()}function g(){return/(Blackberry)/g.test(navigator.userAgent)}function h(){return/(Windows Phone)/gi.test(navigator.userAgent)}function i(){return f()||e()||g()}function j(){return window.requestAnimationFrame||window.webkitRequestAnimationFrame||window.mozRequestAnimationFrame||function(a){window.setTimeout(a,1e3/60)}}function k(a){return parseInt(a,10)||0}function l(){var b=a('<div class=\\\"fr-visibility-helper\\\"></div>').appendTo(\\\"body\\\"),c=k(b.css(\\\"margin-left\\\"));return b.remove(),c}function m(){return\\\"ontouchstart\\\"in window||window.DocumentTouch&&document instanceof DocumentTouch}function n(a){if(!/^(https?:|ftps?:|)\\\\/\\\\//i.test(a))return!1;a=String(a).replace(/</g,\\\"%3C\\\").replace(/>/g,\\\"%3E\\\").replace(/\\\"/g,\\\"%22\\\").replace(/ /g,\\\"%20\\\");var b=/(http|ftp|https):\\\\/\\\\/[a-z\\\\u00a1-\\\\uffff0-9]+(\\\\.[a-z\\\\u00a1-\\\\uffff0-9]*)*([a-z\\\\u00a1-\\\\uffff0-9.,@?^=%&amp;:\\\\/~+#-]*[a-z\\\\u00a1-\\\\uffff0-9@?^=%&amp;\\\\/~+#-])?/gi;return b.test(a)}function o(a){if(/^(https?:|ftps?:|)\\\\/\\\\//i.test(a)){if(!n(a)&&!n(\\\"http:\\\"+a))return\\\"\\\"}else a=encodeURIComponent(a).replace(/%23/g,\\\"#\\\").replace(/%2F/g,\\\"/\\\").replace(/%25/g,\\\"%\\\").replace(/mailto%3A/gi,\\\"mailto:\\\").replace(/file%3A/gi,\\\"file:\\\").replace(/sms%3A/gi,\\\"sms:\\\").replace(/tel%3A/gi,\\\"tel:\\\").replace(/notes%3A/gi,\\\"notes:\\\").replace(/data%3Aimage/gi,\\\"data:image\\\").replace(/blob%3A/gi,\\\"blob:\\\").replace(/webkit-fake-url%3A/gi,\\\"webkit-fake-url:\\\").replace(/%3F/g,\\\"?\\\").replace(/%3D/g,\\\"=\\\").replace(/%26/g,\\\"&\\\").replace(/&amp;/g,\\\"&\\\").replace(/%2C/g,\\\",\\\").replace(/%3B/g,\\\";\\\").replace(/%2B/g,\\\"+\\\").replace(/%40/g,\\\"@\\\").replace(/%5B/g,\\\"[\\\").replace(/%5D/g,\\\"]\\\").replace(/%7B/g,\\\"{\\\").replace(/%7D/g,\\\"}\\\");return a}function p(a){return a&&!a.propertyIsEnumerable(\\\"length\\\")&&\\\"object\\\"==typeof a&&\\\"number\\\"==typeof a.length}function q(a){function b(a){return(\\\"0\\\"+parseInt(a,10).toString(16)).slice(-2)}try{return a&&\\\"transparent\\\"!==a?/^#[0-9A-F]{6}$/i.test(a)?a:(a=a.match(/^rgb\\\\((\\\\d+),\\\\s*(\\\\d+),\\\\s*(\\\\d+)\\\\)$/),(\\\"#\\\"+b(a[1])+b(a[2])+b(a[3])).toUpperCase()):\\\"\\\"}catch(c){return null}}function r(a){var b=/^#?([a-f\\\\d])([a-f\\\\d])([a-f\\\\d])$/i;a=a.replace(b,function(a,b,c,d){return b+b+c+c+d+d});var c=/^#?([a-f\\\\d]{2})([a-f\\\\d]{2})([a-f\\\\d]{2})$/i.exec(a);return c?\\\"rgb(\\\"+parseInt(c[1],16)+\\\", \\\"+parseInt(c[2],16)+\\\", \\\"+parseInt(c[3],16)+\\\")\\\":\\\"\\\"}function s(b){var c=(b.css(\\\"text-align\\\")||\\\"\\\").replace(/-(.*)-/g,\\\"\\\");if([\\\"left\\\",\\\"right\\\",\\\"justify\\\",\\\"center\\\"].indexOf(c)<0){if(!v){var d=a('<div dir=\\\"auto\\\" style=\\\"text-align: initial; position: fixed; left: -3000px;\\\"><span id=\\\"s1\\\">.</span><span id=\\\"s2\\\">.</span></div>');a(\\\"body\\\").append(d);var e=d.find(\\\"#s1\\\").get(0).getBoundingClientRect().left,f=d.find(\\\"#s2\\\").get(0).getBoundingClientRect().left;d.remove(),v=f>e?\\\"left\\\":\\\"right\\\"}c=v}return c}function t(){return null==w&&(w=navigator.platform.toUpperCase().indexOf(\\\"MAC\\\")>=0),w}function u(){b.browser=d()}var v,w=null;return{_init:u,isIOS:e,isMac:t,isAndroid:f,isBlackberry:g,isWindowsPhone:h,isMobile:i,requestAnimationFrame:j,getPX:k,screenSize:l,isTouch:m,sanitizeURL:o,isArray:p,RGBToHex:q,HEXtoRGB:r,isURL:n,getAlignment:s}},a.FE.MODULES.events=function(b){function c(a,b,c){s(a,b,c)}function d(){c(b.$el,\\\"cut copy paste beforepaste\\\",function(a){v(a.type,[a])})}function e(){c(b.$el,\\\"click mouseup mousedown touchstart touchend dragenter dragover dragleave dragend drop dragstart\\\",function(a){v(a.type,[a])}),r(\\\"mousedown\\\",function(){for(var c=0;c<a.FE.INSTANCES.length;c++)a.FE.INSTANCES[c]!=b&&a.FE.INSTANCES[c].popups&&a.FE.INSTANCES[c].popups.areVisible()&&a.FE.INSTANCES[c].$el.find(\\\".fr-marker\\\").remove()})}function f(){c(b.$el,\\\"keydown keypress keyup input\\\",function(a){v(a.type,[a])})}function g(){c(b.$win,b._mousedown,function(a){v(\\\"window.mousedown\\\",[a]),n()}),c(b.$win,b._mouseup,function(a){v(\\\"window.mouseup\\\",[a])}),c(b.$win,\\\"cut copy keydown keyup touchmove touchend\\\",function(a){v(\\\"window.\\\"+a.type,[a])})}function h(){c(b.$doc,\\\"dragend drop\\\",function(a){v(\\\"document.\\\"+a.type,[a])})}function i(c){if(\\\"undefined\\\"==typeof c&&(c=!0),!b.$wp)return!1;if(b.helpers.isIOS()&&b.$win.get(0).focus(),!b.core.hasFocus()&&c){var d=b.$win.scrollTop();return b.$el.focus(),d!=b.$win.scrollTop()&&b.$win.scrollTop(d),!1}if(!b.core.hasFocus()||b.$el.find(\\\".fr-marker\\\").length>0)return!1;var e=b.selection.info(b.$el.get(0));if(e.atStart&&b.selection.isCollapsed()&&null!=b.html.defaultTag()){var f=b.markers.insert();if(f&&!b.node.blockParent(f)){a(f).remove();var g=b.$el.find(b.html.blockTagsQuery()).get(0);g&&(a(g).prepend(a.FE.MARKERS),b.selection.restore())}else f&&a(f).remove()}}function j(){c(b.$el,\\\"focus\\\",function(a){p()&&(i(!1),C===!1&&v(a.type,[a]))}),c(b.$el,\\\"blur\\\",function(a){p()&&C===!0&&(v(a.type,[a]),n())}),r(\\\"focus\\\",function(){C=!0}),r(\\\"blur\\\",function(){C=!1})}function k(){b.helpers.isMobile()?(b._mousedown=\\\"touchstart\\\",b._mouseup=\\\"touchend\\\",b._move=\\\"touchmove\\\",b._mousemove=\\\"touchmove\\\"):(b._mousedown=\\\"mousedown\\\",b._mouseup=\\\"mouseup\\\",b._move=\\\"\\\",b._mousemove=\\\"mousemove\\\")}function l(c){var d=a(c.currentTarget);return b.edit.isDisabled()||d.hasClass(\\\"fr-disabled\\\")?(c.preventDefault(),!1):\\\"mousedown\\\"===c.type&&1!==c.which?!0:(b.helpers.isMobile()||c.preventDefault(),(b.helpers.isAndroid()||b.helpers.isWindowsPhone())&&0===d.parents(\\\".fr-dropdown-menu\\\").length&&(c.preventDefault(),c.stopPropagation()),d.addClass(\\\"fr-selected\\\"),void b.events.trigger(\\\"commands.mousedown\\\",[d]))}function m(c,d){var e=a(c.currentTarget);if(b.edit.isDisabled()||e.hasClass(\\\"fr-disabled\\\"))return c.preventDefault(),!1;if(\\\"mouseup\\\"===c.type&&1!==c.which)return!0;if(!e.hasClass(\\\"fr-selected\\\"))return!0;if(\\\"touchmove\\\"!=c.type){if(c.stopPropagation(),c.stopImmediatePropagation(),c.preventDefault(),!e.hasClass(\\\"fr-selected\\\"))return a(\\\".fr-selected\\\").removeClass(\\\"fr-selected\\\"),!1;if(a(\\\".fr-selected\\\").removeClass(\\\"fr-selected\\\"),e.data(\\\"dragging\\\")||e.attr(\\\"disabled\\\"))return e.removeData(\\\"dragging\\\"),!1;var f=e.data(\\\"timeout\\\");f&&(clearTimeout(f),e.removeData(\\\"timeout\\\")),d.apply(b,[c])}else e.data(\\\"timeout\\\")||e.data(\\\"timeout\\\",setTimeout(function(){e.data(\\\"dragging\\\",!0)},100))}function n(){A=!0}function o(){A=!1}function p(){return A}function q(a,c,d){s(a,b._mousedown,c,function(a){b.edit.isDisabled()||l(a)},!0),s(a,b._mouseup+\\\" \\\"+b._move,c,function(a){b.edit.isDisabled()||m(a,d)},!0),s(a,\\\"mousedown click mouseup\\\",c,function(a){b.edit.isDisabled()||a.stopPropagation()},!0),r(\\\"window.mouseup\\\",function(){b.edit.isDisabled()||(a.find(c).removeClass(\\\"fr-selected\\\"),n())})}function r(a,c,d){var e=a.split(\\\" \\\");if(e.length>1){for(var f=0;f<e.length;f++)r(e[f],c,d);return!0}\\\"undefined\\\"==typeof d&&(d=!1);var g;g=0!=a.indexOf(\\\"shared.\\\")?B[a]=B[a]||[]:b.shared._events[a]=b.shared._events[a]||[],d?g.unshift(c):g.push(c)}function s(a,c,d,e,f){\\\"function\\\"==typeof d&&(f=e,e=d,d=!1);var g=f?b.shared.$_events:D,h=f?b.sid:b.id;d?a.on(c.split(\\\" \\\").join(\\\".ed\\\"+h+\\\" \\\")+\\\".ed\\\"+h,d,e):a.on(c.split(\\\" \\\").join(\\\".ed\\\"+h+\\\" \\\")+\\\".ed\\\"+h,e),g.indexOf(a.get(0))<0&&g.push(a.get(0))}function t(b,c){for(var d=0;d<b.length;d++)a(b[d]).off(\\\".ed\\\"+c)}function u(){t(D,b.id),D=[],0==b.shared.count&&(t(b.shared.$_events,b.sid),b.shared.$_events=null)}function v(c,d,e){if(!b.edit.isDisabled()||e){var f;if(0!=c.indexOf(\\\"shared.\\\"))f=B[c];else{if(b.shared.count>0)return!1;f=b.shared._events[c]}var g;if(f)for(var h=0;h<f.length;h++)if(g=f[h].apply(b,d),g===!1)return!1;return g=b.$oel.triggerHandler(\\\"froalaEditor.\\\"+c,a.merge([b],d||[])),g===!1?!1:g}}function w(c,d,e){if(!b.edit.isDisabled()||e){var f;if(0!=c.indexOf(\\\"shared.\\\"))f=B[c];else{if(b.shared.count>0)return!1;f=b.shared._events[c]}var g;if(f)for(var h=0;h<f.length;h++)g=f[h].apply(b,[d]),\\\"undefined\\\"!=typeof g&&(d=g);return g=b.$oel.triggerHandler(\\\"froalaEditor.\\\"+c,a.merge([b],[d])),\\\"undefined\\\"!=typeof g&&(d=g),d}}function x(){for(var a in B)B.hasOwnProperty(a)&&delete B[a]}function y(){for(var a in b.shared._events)b.shared._events.hasOwnProperty(a)&&delete b.shared._events[a]}function z(){b.shared.$_events=b.shared.$_events||[],b.shared._events={},k(),e(),g(),h(),f(),j(),n(),d(),r(\\\"destroy\\\",x),r(\\\"shared.destroy\\\",y)}var A,B={},C=!1,D=[];return{_init:z,on:r,trigger:v,bindClick:q,disableBlur:o,enableBlur:n,blurActive:p,focus:i,chainTrigger:w,$on:s,$off:u}},a.FE.INVISIBLE_SPACE=\\\"&#8203;\\\",a.FE.START_MARKER='<span class=\\\"fr-marker\\\" data-id=\\\"0\\\" data-type=\\\"true\\\" style=\\\"display: none; line-height: 0;\\\">'+a.FE.INVISIBLE_SPACE+\\\"</span>\\\",a.FE.END_MARKER='<span class=\\\"fr-marker\\\" data-id=\\\"0\\\" data-type=\\\"false\\\" style=\\\"display: none; line-height: 0;\\\">'+a.FE.INVISIBLE_SPACE+\\\"</span>\\\",a.FE.MARKERS=a.FE.START_MARKER+a.FE.END_MARKER,a.FE.MODULES.markers=function(b){function c(c,d){return a('<span class=\\\"fr-marker\\\" data-id=\\\"'+d+'\\\" data-type=\\\"'+c+'\\\" style=\\\"display: '+(b.browser.safari?\\\"none\\\":\\\"inline-block\\\")+'; line-height: 0;\\\">'+a.FE.INVISIBLE_SPACE+\\\"</span>\\\",b.doc)[0]}function d(d,e,f){try{var g=d.cloneRange();if(g.collapse(e),g.insertNode(c(e,f)),e===!0&&d.collapsed)for(var h=b.$el.find('span.fr-marker[data-type=\\\"true\\\"][data-id=\\\"'+f+'\\\"]'),i=h.get(0).nextSibling;i&&i.nodeType===Node.TEXT_NODE&&0===i.textContent.length;)a(i).remove(),i=h.nextSibling;if(e===!0&&!d.collapsed){var h=b.$el.find('span.fr-marker[data-type=\\\"true\\\"][data-id=\\\"'+f+'\\\"]').get(0),i=h.nextSibling;if(i&&i.nodeType===Node.ELEMENT_NODE&&b.node.isBlock(i)){var j=[i];do i=j[0],j=b.node.contents(i);while(j[0]&&b.node.isBlock(j[0]));a(i).prepend(a(h))}}if(e===!1&&!d.collapsed){var h=b.$el.find('span.fr-marker[data-type=\\\"false\\\"][data-id=\\\"'+f+'\\\"]').get(0),i=h.previousSibling;if(i&&i.nodeType===Node.ELEMENT_NODE&&b.node.isBlock(i)){var j=[i];do i=j[j.length-1],j=b.node.contents(i);while(j[j.length-1]&&b.node.isBlock(j[j.length-1]));a(i).append(a(h))}h.parentNode&&[\\\"TD\\\",\\\"TH\\\"].indexOf(h.parentNode.tagName)>=0&&h.parentNode.previousSibling&&!h.previousSibling&&a(h.parentNode.previousSibling).append(h)}var k=b.$el.find('span.fr-marker[data-type=\\\"'+e+'\\\"][data-id=\\\"'+f+'\\\"]').get(0);return k&&(k.style.display=\\\"none\\\"),k}catch(l){return null}}function e(){if(!b.$wp)return null;try{var c=b.selection.ranges(0),d=c.commonAncestorContainer;if(d!=b.$el.get(0)&&0==b.$el.find(d).length)return null;var e=c.cloneRange(),f=c.cloneRange();e.collapse(!0);var g=a('<span class=\\\"fr-marker\\\" style=\\\"display: none; line-height: 0;\\\">'+a.FE.INVISIBLE_SPACE+\\\"</span>\\\",b.doc)[0];if(e.insertNode(g),g=b.$el.find(\\\"span.fr-marker\\\").get(0)){for(var h=g.nextSibling;h&&h.nodeType===Node.TEXT_NODE&&0===h.textContent.length;)a(h).remove(),h=b.$el.find(\\\"span.fr-marker\\\").get(0).nextSibling;return b.selection.clear(),b.selection.get().addRange(f),g}return null}catch(i){}}function f(){b.selection.isCollapsed()||b.selection.remove();var c=b.$el.find(\\\".fr-marker\\\").get(0);if(null==c&&(c=e()),null==c)return null;var d;if(d=b.node.deepestParent(c))if(b.node.isBlock(d)&&b.node.isEmpty(d))a(d).replaceWith('<span class=\\\"fr-marker\\\"></span>');else{var f=c,g=\\\"\\\",h=\\\"\\\";do f=f.parentNode,g+=b.node.closeTagString(f),h=b.node.openTagString(f)+h;while(f!=d);a(c).replaceWith('<span id=\\\"fr-break\\\"></span>');var i=b.node.openTagString(d)+a(d).html()+b.node.closeTagString(d);i=i.replace(/<span id=\\\"fr-break\\\"><\\\\/span>/g,g+'<span class=\\\"fr-marker\\\"></span>'+h),a(d).replaceWith(i)}return b.$el.find(\\\".fr-marker\\\").get(0)}function g(a){var c=a.clientX,d=a.clientY;h();\\nvar f,g=null;if(\\\"undefined\\\"!=typeof b.doc.caretPositionFromPoint?(f=b.doc.caretPositionFromPoint(c,d),g=b.doc.createRange(),g.setStart(f.offsetNode,f.offset),g.setEnd(f.offsetNode,f.offset)):\\\"undefined\\\"!=typeof b.doc.caretRangeFromPoint&&(f=b.doc.caretRangeFromPoint(c,d),g=b.doc.createRange(),g.setStart(f.startContainer,f.startOffset),g.setEnd(f.startContainer,f.startOffset)),null!==g&&\\\"undefined\\\"!=typeof b.win.getSelection){var i=b.win.getSelection();i.removeAllRanges(),i.addRange(g)}else if(\\\"undefined\\\"!=typeof b.doc.body.createTextRange)try{g=b.doc.body.createTextRange(),g.moveToPoint(c,d);var j=g.duplicate();j.moveToPoint(c,d),g.setEndPoint(\\\"EndToEnd\\\",j),g.select()}catch(k){return!1}e()}function h(){b.$el.find(\\\".fr-marker\\\").remove()}return{place:d,insert:e,split:f,insertAtPoint:g,remove:h}},a.FE.MODULES.selection=function(b){function c(){var a=\\\"\\\";return b.win.getSelection?a=b.win.getSelection():b.doc.getSelection?a=b.doc.getSelection():b.doc.selection&&(a=b.doc.selection.createRange().text),a.toString()}function d(){var a=\\\"\\\";return a=b.win.getSelection?b.win.getSelection():b.doc.getSelection?b.doc.getSelection():b.doc.selection.createRange()}function e(a){var c=d(),e=[];if(c&&c.getRangeAt&&c.rangeCount)for(var e=[],f=0;f<c.rangeCount;f++)e.push(c.getRangeAt(f));else e=b.doc.createRange?[b.doc.createRange()]:[];return\\\"undefined\\\"!=typeof a?e[a]:e}function f(){var a=d();try{a.removeAllRanges?a.removeAllRanges():a.empty?a.empty():a.clear&&a.clear()}catch(b){}}function g(){var f=d();try{if(f.rangeCount){var g=e(0),h=g.startContainer;if(h.nodeType==Node.TEXT_NODE&&g.startOffset==(h.textContent||\\\"\\\").length&&h.nextSibling&&(h=h.nextSibling),h.nodeType==Node.ELEMENT_NODE){var i=!1;if(h.childNodes.length>0&&h.childNodes[g.startOffset]){for(var j=h.childNodes[g.startOffset];j&&j.nodeType==Node.TEXT_NODE&&0==j.textContent.length;)j=j.nextSibling;j&&j.textContent.replace(/\\\\u200B/g,\\\"\\\")===c().replace(/\\\\u200B/g,\\\"\\\")&&(h=j,i=!0)}else if(!g.collapsed&&h.nextSibling&&h.nextSibling.nodeType==Node.ELEMENT_NODE){var j=h.nextSibling;j&&j.textContent.replace(/\\\\u200B/g,\\\"\\\")===c().replace(/\\\\u200B/g,\\\"\\\")&&(h=j,i=!0)}!i&&h.childNodes.length>0&&a(h.childNodes[0]).text().replace(/\\\\u200B/g,\\\"\\\")===c().replace(/\\\\u200B/g,\\\"\\\")&&[\\\"BR\\\",\\\"IMG\\\",\\\"HR\\\"].indexOf(h.childNodes[0].tagName)<0&&(h=h.childNodes[0])}for(;h.nodeType!=Node.ELEMENT_NODE&&h.parentNode;)h=h.parentNode;for(var k=h;k&&\\\"HTML\\\"!=k.tagName;){if(k==b.$el.get(0))return h;k=a(k).parent()[0]}}}catch(l){}return b.$el.get(0)}function h(){var f=d();try{if(f.rangeCount){var g=e(0),h=g.endContainer;if(h.nodeType==Node.ELEMENT_NODE){var i=!1;if(h.childNodes.length>0&&h.childNodes[g.endOffset]&&a(h.childNodes[g.endOffset]).text()===c())h=h.childNodes[g.endOffset],i=!0;else if(!g.collapsed&&h.previousSibling&&h.previousSibling.nodeType==Node.ELEMENT_NODE){var j=h.previousSibling;j&&j.textContent.replace(/\\\\u200B/g,\\\"\\\")===c().replace(/\\\\u200B/g,\\\"\\\")&&(h=j,i=!0)}else if(!g.collapsed&&h.childNodes.length>0&&h.childNodes[g.endOffset]){var j=h.childNodes[g.endOffset].previousSibling;j.nodeType==Node.ELEMENT_NODE&&j&&j.textContent.replace(/\\\\u200B/g,\\\"\\\")===c().replace(/\\\\u200B/g,\\\"\\\")&&(h=j,i=!0)}!i&&h.childNodes.length>0&&a(h.childNodes[h.childNodes.length-1]).text()===c()&&[\\\"BR\\\",\\\"IMG\\\",\\\"HR\\\"].indexOf(h.childNodes[h.childNodes.length-1].tagName)<0&&(h=h.childNodes[h.childNodes.length-1])}for(h.nodeType==Node.TEXT_NODE&&0==g.endOffset&&h.previousSibling&&h.previousSibling.nodeType==Node.ELEMENT_NODE&&(h=h.previousSibling);h.nodeType!=Node.ELEMENT_NODE&&h.parentNode;)h=h.parentNode;for(var k=h;k&&\\\"HTML\\\"!=k.tagName;){if(k==b.$el.get(0))return h;k=a(k).parent()[0]}}}catch(l){}return b.$el.get(0)}function i(a,b){var c=a;return c.nodeType==Node.ELEMENT_NODE&&c.childNodes.length>0&&c.childNodes[b]&&(c=c.childNodes[b]),c.nodeType==Node.TEXT_NODE&&(c=c.parentNode),c}function j(){var c=[],f=d();if(t()&&f.rangeCount)for(var g=e(),h=0;h<g.length;h++){var j=g[h],k=i(j.startContainer,j.startOffset),l=i(j.endContainer,j.endOffset);b.node.isBlock(k)&&c.indexOf(k)<0&&c.push(k);var m=b.node.blockParent(k);m&&c.indexOf(m)<0&&c.push(m);for(var n=[],o=k;o!==l&&o!==b.$el.get(0);)n.indexOf(o)<0&&o.children&&o.children.length?(n.push(o),o=o.children[0]):o.nextSibling?o=o.nextSibling:o.parentNode&&(o=o.parentNode,n.push(o)),b.node.isBlock(o)&&n.indexOf(o)<0&&c.indexOf(o)<0&&(o!==l||j.endOffset>0)&&c.push(o);b.node.isBlock(l)&&c.indexOf(l)<0&&j.endOffset>0&&c.push(l);var m=b.node.blockParent(l);m&&c.indexOf(m)<0&&c.push(m)}for(var h=c.length-1;h>0;h--)a(c[h]).find(c).length&&\\\"LI\\\"!=c[h].tagName&&c.splice(h,1);return c}function k(){if(b.$wp){b.markers.remove();for(var a=e(),c=[],d=0;d<a.length;d++)if(a[d].startContainer!==b.doc){var f=a[d],g=f.collapsed,h=b.markers.place(f,!0,d),i=b.markers.place(f,!1,d);if(b.$el.get(0).normalize(),b.browser.safari&&!g){var f=b.doc.createRange();f.setStartAfter(h),f.setEndBefore(i),c.push(f)}}if(b.browser.safari&&c.length){b.selection.clear();for(var d=0;d<c.length;d++)b.selection.get().addRange(c[d])}}}function l(){var c=b.$el.get(0).querySelectorAll('.fr-marker[data-type=\\\"true\\\"]');if(!b.$wp)return b.markers.remove(),!1;if(0===c.length)return!1;if(b.browser.msie||b.browser.edge)for(var e=0;e<c.length;e++)c[e].style.display=\\\"inline-block\\\";b.core.hasFocus()||b.browser.msie||b.browser.webkit||b.$el.focus(),f();for(var g=d(),e=0;e<c.length;e++){var h=a(c[e]).data(\\\"id\\\"),i=c[e],j=b.doc.createRange(),k=b.$el.find('.fr-marker[data-type=\\\"false\\\"][data-id=\\\"'+h+'\\\"]');(b.browser.msie||b.browser.edge)&&k.css(\\\"display\\\",\\\"inline-block\\\");var l=null;if(k.length>0){k=k[0];try{for(var n=!1,o=i.nextSibling;o&&o.nodeType==Node.TEXT_NODE&&0==o.textContent.length;){var p=o;o=o.nextSibling,a(p).remove()}for(var q=k.nextSibling;q&&q.nodeType==Node.TEXT_NODE&&0==q.textContent.length;){var p=q;q=q.nextSibling,a(p).remove()}if(i.nextSibling==k||k.nextSibling==i){for(var r=i.nextSibling==k?i:k,s=r==i?k:i,t=r.previousSibling;t&&t.nodeType==Node.TEXT_NODE&&0==t.length;){var p=t;t=t.previousSibling,a(p).remove()}if(t&&t.nodeType==Node.TEXT_NODE)for(;t&&t.previousSibling&&t.previousSibling.nodeType==Node.TEXT_NODE;)t.previousSibling.textContent=t.previousSibling.textContent+t.textContent,t=t.previousSibling,a(t.nextSibling).remove();for(var u=s.nextSibling;u&&u.nodeType==Node.TEXT_NODE&&0==u.length;){var p=u;u=u.nextSibling,a(p).remove()}if(u&&u.nodeType==Node.TEXT_NODE)for(;u&&u.nextSibling&&u.nextSibling.nodeType==Node.TEXT_NODE;)u.nextSibling.textContent=u.textContent+u.nextSibling.textContent,u=u.nextSibling,a(u.previousSibling).remove();if(t&&(b.node.isVoid(t)||b.node.isBlock(t))&&(t=null),u&&(b.node.isVoid(u)||b.node.isBlock(u))&&(u=null),t&&u&&t.nodeType==Node.TEXT_NODE&&u.nodeType==Node.TEXT_NODE){a(i).remove(),a(k).remove();var v=t.textContent.length;t.textContent=t.textContent+u.textContent,a(u).remove(),b.spaces.normalize(t),j.setStart(t,v),j.setEnd(t,v),n=!0}else!t&&u&&u.nodeType==Node.TEXT_NODE?(a(i).remove(),a(k).remove(),b.spaces.normalize(u),l=a(b.doc.createTextNode(\\\"\\\\u200b\\\")),a(u).before(l),j.setStart(u,0),j.setEnd(u,0),n=!0):!u&&t&&t.nodeType==Node.TEXT_NODE&&(a(i).remove(),a(k).remove(),b.spaces.normalize(t),l=a(b.doc.createTextNode(\\\"\\\\u200b\\\")),a(t).after(l),j.setStart(t,t.textContent.length),j.setEnd(t,t.textContent.length),n=!0)}if(!n){var w,x;if(b.browser.chrome&&i.nextSibling==k)w=m(k,j,!0)||j.setStartAfter(k),x=m(i,j,!1)||j.setEndBefore(i);else{i.previousSibling==k&&(i=k,k=i.nextSibling),k.nextSibling&&\\\"BR\\\"===k.nextSibling.tagName||!k.nextSibling&&b.node.isBlock(i.previousSibling)||i.previousSibling&&\\\"BR\\\"==i.previousSibling.tagName||(i.style.display=\\\"inline\\\",k.style.display=\\\"inline\\\",l=a(b.doc.createTextNode(\\\"\\\\u200b\\\")));var y=i.previousSibling;y&&y.style&&\\\"block\\\"==b.win.getComputedStyle(y).display&&!b.opts.enter==a.FE.ENTER_BR?(j.setEndAfter(y),j.setStartAfter(y)):(w=m(i,j,!0)||a(i).before(l)&&j.setStartBefore(i),x=m(k,j,!1)||a(k).after(l)&&j.setEndAfter(k))}\\\"function\\\"==typeof w&&w(),\\\"function\\\"==typeof x&&x()}}catch(z){}}l&&l.remove();try{g.addRange(j)}catch(z){}}b.markers.remove()}function m(c,d,e){var f=c.previousSibling,g=c.nextSibling;if(f&&g&&f.nodeType==Node.TEXT_NODE&&g.nodeType==Node.TEXT_NODE){var h=f.textContent.length;return e?(g.textContent=f.textContent+g.textContent,a(f).remove(),a(c).remove(),b.spaces.normalize(g),function(){d.setStart(g,h)}):(f.textContent=f.textContent+g.textContent,a(g).remove(),a(c).remove(),b.spaces.normalize(f),function(){d.setEnd(f,h)})}if(f&&!g&&f.nodeType==Node.TEXT_NODE){var h=f.textContent.length;return e?(b.spaces.normalize(f),function(){d.setStart(f,h)}):(b.spaces.normalize(f),function(){d.setEnd(f,h)})}return g&&!f&&g.nodeType==Node.TEXT_NODE?e?(b.spaces.normalize(g),function(){d.setStart(g,0)}):(b.spaces.normalize(g),function(){d.setEnd(g,0)}):!1}function n(){return!0}function o(){for(var a=e(),b=0;b<a.length;b++)if(!a[b].collapsed)return!1;return!0}function p(a){var c,d,e=!1,f=!1;if(b.win.getSelection){var g=b.win.getSelection();g.rangeCount&&(c=g.getRangeAt(0),d=c.cloneRange(),d.selectNodeContents(a),d.setEnd(c.startContainer,c.startOffset),e=\\\"\\\"===d.toString(),d.selectNodeContents(a),d.setStart(c.endContainer,c.endOffset),f=\\\"\\\"===d.toString())}else b.doc.selection&&\\\"Control\\\"!=b.doc.selection.type&&(c=b.doc.selection.createRange(),d=c.duplicate(),d.moveToElementText(a),d.setEndPoint(\\\"EndToStart\\\",c),e=\\\"\\\"===d.text,d.moveToElementText(a),d.setEndPoint(\\\"StartToEnd\\\",c),f=\\\"\\\"===d.text);return{atStart:e,atEnd:f}}function q(){if(o())return!1;b.$el.find(\\\"td\\\").prepend('<span class=\\\"fr-mk\\\">'+a.FE.INVISIBLE_SPACE+\\\"</span>\\\"),b.$el.find(\\\"img\\\").append('<span class=\\\"fr-mk\\\">'+a.FE.INVISIBLE_SPACE+\\\"</span>\\\");var c=!1,d=p(b.$el.get(0));return d.atStart&&d.atEnd&&(c=!0),b.$el.find(\\\".fr-mk\\\").remove(),c}function r(c,d){\\\"undefined\\\"==typeof d&&(d=!0);var e=a(c).html();e&&e.replace(/\\\\u200b/g,\\\"\\\").length!=e.length&&a(c).html(e.replace(/\\\\u200b/g,\\\"\\\"));for(var f=b.node.contents(c),g=0;g<f.length;g++)f[g].nodeType!=Node.ELEMENT_NODE?a(f[g]).remove():(r(f[g],0==g),0==g&&(d=!1));c.nodeType==Node.TEXT_NODE?a(c).replaceWith('<span data-first=\\\"true\\\" data-text=\\\"true\\\"></span>'):d&&a(c).attr(\\\"data-first\\\",!0)}function s(c,d){var e=b.node.contents(c.get(0));[\\\"TD\\\",\\\"TH\\\"].indexOf(c.get(0).tagName)>=0&&1==c.find(\\\".fr-marker\\\").length&&a(e[0]).hasClass(\\\"fr-marker\\\")&&c.attr(\\\"data-del-cell\\\",!0);for(var f=0;f<e.length;f++){var g=e[f];a(g).hasClass(\\\"fr-marker\\\")?d=(d+1)%2:d?a(g).find(\\\".fr-marker\\\").length>0?d=s(a(g),d):[\\\"TD\\\",\\\"TH\\\"].indexOf(g.tagName)<0&&!a(g).hasClass(\\\"fr-inner\\\")?!b.opts.keepFormatOnDelete||b.$el.find(\\\"[data-first]\\\").length>0?a(g).remove():r(g):a(g).hasClass(\\\"fr-inner\\\")?0==a(g).find(\\\".fr-inner\\\").length?a(g).html(\\\"<br>\\\"):a(g).find(\\\".fr-inner\\\").filter(function(){return 0==a(this).find(\\\"fr-inner\\\").length}).html(\\\"<br>\\\"):(a(g).empty(),a(g).attr(\\\"data-del-cell\\\",!0)):a(g).find(\\\".fr-marker\\\").length>0&&(d=s(a(g),d))}return d}function t(){try{if(!b.$wp)return!1;for(var a=e(0),c=a.commonAncestorContainer;c&&!b.node.isElement(c);)c=c.parentNode;return b.node.isElement(c)?!0:!1}catch(d){return!1}}function u(){if(o())return!0;k();for(var c=function(b){for(var c=b.previousSibling;c&&c.nodeType==Node.TEXT_NODE&&0==c.textContent.length;){var d=c,c=c.previousSibling;a(d).remove()}return c},d=function(b){for(var c=b.nextSibling;c&&c.nodeType==Node.TEXT_NODE&&0==c.textContent.length;){var d=c,c=c.nextSibling;a(d).remove()}return c},e=b.$el.find('.fr-marker[data-type=\\\"true\\\"]'),f=0;f<e.length;f++)for(var g=e[f];!c(g)&&!b.node.isBlock(g.parentNode)&&!b.$el.is(g.parentNode);)a(g.parentNode).before(g);for(var h=b.$el.find('.fr-marker[data-type=\\\"false\\\"]'),f=0;f<h.length;f++){for(var i=h[f];!d(i)&&!b.node.isBlock(i.parentNode)&&!b.$el.is(i.parentNode);)a(i.parentNode).after(i);i.parentNode&&b.node.isBlock(i.parentNode)&&b.node.isEmpty(i.parentNode)&&!b.$el.is(i.parentNode)&&a(i.parentNode).after(i)}if(n()){s(b.$el,0);var j=b.$el.find('[data-first=\\\"true\\\"]');if(j.length)b.$el.find(\\\".fr-marker\\\").remove(),j.append(a.FE.INVISIBLE_SPACE+a.FE.MARKERS).removeAttr(\\\"data-first\\\"),j.attr(\\\"data-text\\\")&&j.replaceWith(j.html());else{b.$el.find(\\\"table\\\").filter(function(){var b=a(this).find(\\\"[data-del-cell]\\\").length>0&&a(this).find(\\\"[data-del-cell]\\\").length==a(this).find(\\\"td, th\\\").length;return b}).remove(),b.$el.find(\\\"[data-del-cell]\\\").removeAttr(\\\"data-del-cell\\\");for(var e=b.$el.find('.fr-marker[data-type=\\\"true\\\"]'),f=0;f<e.length;f++){var m=e[f],p=m.nextSibling,q=b.$el.find('.fr-marker[data-type=\\\"false\\\"][data-id=\\\"'+a(m).data(\\\"id\\\")+'\\\"]').get(0);if(q){if(p&&p==q);else if(m){var r=b.node.blockParent(m),t=b.node.blockParent(q),u=!1,v=!1;if(r&&[\\\"UL\\\",\\\"OL\\\"].indexOf(r.tagName)>=0&&(r=null,u=!0),t&&[\\\"UL\\\",\\\"OL\\\"].indexOf(t.tagName)>=0&&(t=null,v=!0),a(m).after(q),r==t);else if(null!=r||u)if(null!=t||v||0!=a(r).parentsUntil(b.$el,\\\"table\\\").length)r&&t&&0==a(r).parentsUntil(b.$el,\\\"table\\\").length&&0==a(t).parentsUntil(b.$el,\\\"table\\\").length&&(a(r).append(a(t).html()),a(t).remove());else{for(var p=r;!p.nextSibling&&p.parentNode!=b.$el.get(0);)p=p.parentNode;for(p=p.nextSibling;p&&\\\"BR\\\"!=p.tagName;){var w=p.nextSibling;a(r).append(p),p=w}p&&\\\"BR\\\"==p.tagName&&a(p).remove()}else{var x=b.node.deepestParent(m);x?(a(x).after(a(t).html()),a(t).remove()):0==a(t).parentsUntil(b.$el,\\\"table\\\").length&&(a(m).next().after(a(t).html()),a(t).remove())}}}else q=a(m).clone().attr(\\\"data-type\\\",!1),a(m).after(q)}}}b.opts.keepFormatOnDelete||b.html.fillEmptyBlocks(),b.html.cleanEmptyTags(!0),b.clean.lists(),b.spaces.normalize();var y=b.$el.find(\\\".fr-marker:last\\\").get(0),z=b.$el.find(\\\".fr-marker:first\\\").get(0);!y.nextSibling&&z.previousSibling&&\\\"BR\\\"==z.previousSibling.tagName&&b.node.isElement(y.parentNode)&&b.node.isElement(z.parentNode)&&b.$el.append(\\\"<br>\\\"),l()}function v(c){if(a(c).find(\\\".fr-marker\\\").length>0)return!1;for(var d=b.node.contents(c);d.length&&b.node.isBlock(d[0]);)c=d[0],d=b.node.contents(c);a(c).prepend(a.FE.MARKERS)}function w(c){if(a(c).find(\\\".fr-marker\\\").length>0)return!1;for(var d=b.node.contents(c);d.length&&b.node.isBlock(d[d.length-1]);)c=d[d.length-1],d=b.node.contents(c);a(c).append(a.FE.MARKERS)}function x(c){for(var d=c.previousSibling;d&&d.nodeType==Node.TEXT_NODE&&0==d.textContent.length;)d=d.previousSibling;return d?(b.node.isBlock(d)?w(d):\\\"BR\\\"==d.tagName?a(d).before(a.FE.MARKERS):a(d).after(a.FE.MARKERS),!0):!1}function y(c){for(var d=c.nextSibling;d&&d.nodeType==Node.TEXT_NODE&&0==d.textContent.length;)d=d.nextSibling;return d?(b.node.isBlock(d)?v(d):a(d).before(a.FE.MARKERS),!0):!1}return{text:c,get:d,ranges:e,clear:f,element:g,endElement:h,save:k,restore:l,isCollapsed:o,isFull:q,inEditor:t,remove:u,blocks:j,info:p,setAtEnd:w,setAtStart:v,setBefore:x,setAfter:y,rangeElement:i}},a.FE.MODULES.spaces=function(b){function c(a){var b=a.nextSibling||a.parentNode;return a.parentNode.removeChild(a),b}function d(a,b){return a&&a.parentNode===b||\\\"PRE\\\"===b.nodeName?b.nextSibling||b.parentNode:b.firstChild||b.nextSibling||b.parentNode}function e(a){if(a.firstChild&&\\\"PRE\\\"!==a.nodeName&&!([\\\"STYLE\\\",\\\"SCRIPT\\\"].indexOf(a.tagName)>=0)){for(var e=null,f=null,g=d(f,a);g!==a&&\\\"PRE\\\"!==g.nodeName&&[\\\"STYLE\\\",\\\"SCRIPT\\\"].indexOf(g.tagName)<0;){if(g.nodeType===Node.TEXT_NODE){var h=g.data.replace(/[ \\\\r\\\\n\\\\t]+/g,\\\" \\\");if(e&&!/ $/.test(e.data)||\\\" \\\"!==h[0]||g.previousSibling&&b.node.isVoid(g.previousSibling)&&\\\"BR\\\"!==g.previousSibling.tagName||(h=h.substr(1)),!h||0==h.length){g=c(g);continue}g.data=h,e=g}else g.nodeType===Node.ELEMENT_NODE&&(b.node.isBlock(g)||b.node.isVoid(g)?(e&&e.data&&(b.node.isBlock(g)||\\\"BR\\\"===g.tagName)&&(e.data=e.data.replace(/ $/,\\\"\\\")),e=null):0==g.textContent.length&&(e=g));var i=d(f,g);f=g,g=i}e&&e.data&&(e.data=e.data.replace(/ $/,\\\"\\\"),e.data||c(e))}}function f(c,d){if(\\\"undefined\\\"!=typeof c&&c||(c=b.$el.get(0)),\\\"undefined\\\"==typeof d&&(d=!1),d&&e(c),!c.getAttribute||\\\"false\\\"!=c.getAttribute(\\\"contenteditable\\\"))if(c.nodeType==Node.ELEMENT_NODE&&[\\\"STYLE\\\",\\\"SCRIPT\\\",\\\"HEAD\\\"].indexOf(c.tagName)<0)for(var g=b.node.contents(c),h=g.length-1;h>=0;h--)(g[h].tagName!=Node.ELEMENT_NODE||(g[h].className||\\\"\\\").indexOf(\\\"fr-marker\\\")<0)&&f(g[h]);else if(c.nodeType==Node.TEXT_NODE&&c.textContent.length>0){var i=(c.previousSibling,c.nextSibling,c.textContent);i=i.replace(new RegExp(a.FE.UNICODE_NBSP,\\\"g\\\"),\\\" \\\");for(var j=\\\"\\\",k=0;k<i.length;k++)j+=32!=i.charCodeAt(k)||0!==k&&32!=j.charCodeAt(k-1)?i[k]:a.FE.UNICODE_NBSP;(!c.nextSibling||b.node.isBlock(c.nextSibling)||c.nextSibling.nodeType==Node.ELEMENT_NODE&&b.win.getComputedStyle(c.nextSibling)&&\\\"block\\\"==b.win.getComputedStyle(c.nextSibling).display)&&(j=j.replace(/ $/,a.FE.UNICODE_NBSP)),!c.previousSibling||b.node.isVoid(c.previousSibling)||b.node.isBlock(c.previousSibling)||(j=j.replace(/^\\\\u00A0([^ $])/,\\\" $1\\\"),1!==j.length||160!==j.charCodeAt(0)||!c.nextSibling||b.node.isVoid(c.nextSibling)||b.node.isBlock(c.nextSibling)||(j=\\\" \\\")),j=j.replace(/([^ \\\\u00A0])\\\\u00A0([^ \\\\u00A0])/g,\\\"$1 $2\\\"),c.textContent!=j&&(c.textContent=j)}}return{normalize:f}},a.FE.UNICODE_NBSP=String.fromCharCode(160),a.FE.VOID_ELEMENTS=[\\\"area\\\",\\\"base\\\",\\\"br\\\",\\\"col\\\",\\\"embed\\\",\\\"hr\\\",\\\"img\\\",\\\"input\\\",\\\"keygen\\\",\\\"link\\\",\\\"menuitem\\\",\\\"meta\\\",\\\"param\\\",\\\"source\\\",\\\"track\\\",\\\"wbr\\\"],a.FE.BLOCK_TAGS=[\\\"address\\\",\\\"article\\\",\\\"aside\\\",\\\"audio\\\",\\\"blockquote\\\",\\\"canvas\\\",\\\"dd\\\",\\\"div\\\",\\\"dl\\\",\\\"dt\\\",\\\"fieldset\\\",\\\"figcaption\\\",\\\"figure\\\",\\\"footer\\\",\\\"form\\\",\\\"h1\\\",\\\"h2\\\",\\\"h3\\\",\\\"h4\\\",\\\"h5\\\",\\\"h6\\\",\\\"header\\\",\\\"hgroup\\\",\\\"hr\\\",\\\"li\\\",\\\"main\\\",\\\"nav\\\",\\\"noscript\\\",\\\"ol\\\",\\\"output\\\",\\\"p\\\",\\\"pre\\\",\\\"section\\\",\\\"table\\\",\\\"tbody\\\",\\\"td\\\",\\\"tfoot\\\",\\\"th\\\",\\\"thead\\\",\\\"tr\\\",\\\"ul\\\",\\\"video\\\"],a.extend(a.FE.DEFAULTS,{htmlAllowedEmptyTags:[\\\"textarea\\\",\\\"a\\\",\\\"iframe\\\",\\\"object\\\",\\\"video\\\",\\\"style\\\",\\\"script\\\",\\\".fa\\\",\\\".fr-emoticon\\\"],htmlDoNotWrapTags:[\\\"script\\\",\\\"style\\\"],htmlSimpleAmpersand:!1}),a.FE.MODULES.html=function(b){function c(){return b.opts.enter==a.FE.ENTER_P?\\\"p\\\":b.opts.enter==a.FE.ENTER_DIV?\\\"div\\\":b.opts.enter==a.FE.ENTER_BR?null:void 0}function d(){for(var c=[],d=b.$el.get(0).querySelectorAll(f()),e=0;e<d.length;e++)if(!(d[e].querySelectorAll(a.FE.VOID_ELEMENTS.join(\\\",\\\")).length>0||d[e].querySelectorAll(b.opts.htmlAllowedEmptyTags.join(\\\":not(.fr-marker),\\\")+\\\":not(.fr-marker)\\\").length>0||d[e].querySelectorAll(f()).length>0)){for(var g=b.node.contents(d[e]),h=!1,i=0;i<g.length;i++)if(g[i].nodeType!=Node.COMMENT_NODE&&g[i].textContent&&g[i].textContent.replace(/\\\\u200B/g,\\\"\\\").replace(/\\\\n/g,\\\"\\\").length>0){h=!0;break}h||c.push(d[e])}return c}function e(){return a.FE.BLOCK_TAGS.join(\\\":empty, \\\")+\\\":empty\\\"}function f(){return a.FE.BLOCK_TAGS.join(\\\", \\\")}function g(c){var d=a.merge([],a.FE.VOID_ELEMENTS);d=a.merge(d,b.opts.htmlAllowedEmptyTags),\\\"undefined\\\"==typeof c&&(d=a.merge(d,a.FE.BLOCK_TAGS));var e,f;do{f=!1,e=b.$el.get(0).querySelectorAll(\\\"*:empty:not(\\\"+d.join(\\\"):not(\\\")+\\\"):not(.fr-marker)\\\");for(var g=0;g<e.length;g++)(0===e[g].attributes.length||\\\"undefined\\\"!=typeof e[g].getAttribute(\\\"href\\\"))&&(a(e[g]).remove(),f=!0);e=b.$el.get(0).querySelectorAll(\\\"*:empty:not(\\\"+d.join(\\\"):not(\\\")+\\\"):not(.fr-marker)\\\")}while(e.length&&f)}function h(d,e){var f=c();if(e&&(f='div class=\\\"fr-temp-div\\\"'),f)for(var g=b.node.contents(d.get(0)),h=null,i=0;i<g.length;i++){var j=g[i];if(j.nodeType==Node.ELEMENT_NODE&&(b.node.isBlock(j)||a(j).is(b.opts.htmlDoNotWrapTags.join(\\\",\\\"))&&!a(j).hasClass(\\\"fr-marker\\\")))h=null;else if(j.nodeType!=Node.ELEMENT_NODE&&j.nodeType!=Node.TEXT_NODE)h=null;else if(j.nodeType==Node.ELEMENT_NODE&&\\\"BR\\\"==j.tagName)if(null==h)e?a(j).replaceWith(\\\"<\\\"+f+' data-empty=\\\"true\\\"><br></div>'):a(j).replaceWith(\\\"<\\\"+f+\\\"><br></\\\"+f+\\\">\\\");else{a(j).remove();for(var k=b.node.contents(h),l=!1,m=0;m<k.length;m++)if(!a(k[m]).hasClass(\\\"fr-marker\\\")&&(k[m].nodeType!=Node.TEXT_NODE||0!==k[m].textContent.replace(/ /g,\\\"\\\").length)){l=!0;break}l===!1&&(h.append(\\\"<br>\\\"),h.data(\\\"empty\\\",!0)),h=null}else j.nodeType==Node.TEXT_NODE&&0==a(j).text().trim().length?a(j).remove():(null==h&&(h=a(\\\"<\\\"+f+\\\">\\\"),a(j).before(h)),j.nodeType==Node.TEXT_NODE&&a(j).text().trim().length>0?(h.append(a(j).clone()),a(j).remove()):h.append(a(j)))}}function i(c,d,e,f){return b.$wp?(\\\"undefined\\\"==typeof c&&(c=!1),\\\"undefined\\\"==typeof d&&(d=!1),\\\"undefined\\\"==typeof e&&(e=!1),\\\"undefined\\\"==typeof f&&(f=!1),h(b.$el,c),f&&b.$el.find(\\\".fr-inner\\\").each(function(){h(a(this),c)}),d&&b.$el.find(\\\"td, th\\\").each(function(){h(a(this),c)}),void(e&&b.$el.find(\\\"blockquote\\\").each(function(){h(a(this),c)}))):!1}function j(){b.$el.find(\\\"div.fr-temp-div\\\").each(function(){a(this).data(\\\"empty\\\")||\\\"LI\\\"==this.parentNode.tagName?a(this).replaceWith(a(this).html()):a(this).replaceWith(a(this).html()+\\\"<br>\\\")}),b.$el.find(\\\".fr-temp-div\\\").removeClass(\\\"fr-temp-div\\\").filter(function(){return\\\"\\\"==a(this).attr(\\\"class\\\")}).removeAttr(\\\"class\\\")}function k(){for(var c=d(),e=0;e<c.length;e++){var f=c[e];\\\"false\\\"==f.getAttribute(\\\"contenteditable\\\")||0!=f.querySelectorAll(b.opts.htmlAllowedEmptyTags.join(\\\":not(.fr-marker),\\\")+\\\":not(.fr-marker)\\\").length||b.node.isVoid(f)||\\\"TABLE\\\"!=f.tagName&&f.appendChild(b.doc.createElement(\\\"br\\\"))}if(b.browser.msie&&b.opts.enter==a.FE.ENTER_BR){var g=b.node.contents(b.$el.get(0));g.length&&g[g.length-1].nodeType==Node.TEXT_NODE&&b.$el.append(\\\"<br>\\\")}}function l(){return b.$el.find(f())}function m(a){if(\\\"undefined\\\"==typeof a&&(a=b.$el.get(0)),a&&[\\\"SCRIPT\\\",\\\"STYLE\\\",\\\"PRE\\\"].indexOf(a.tagName)>=0)return!1;for(var c=b.node.contents(a),d=c.length-1;d>=0;d--)if(c[d].nodeType==Node.TEXT_NODE){c[d].textContent=c[d].textContent.replace(/(?!^)( ){2,}(?!$)/g,\\\" \\\"),c[d].textContent=c[d].textContent.replace(/\\\\n/g,\\\" \\\"),c[d].textContent=c[d].textContent.replace(/^[ ]{2,}/g,\\\" \\\"),c[d].textContent=c[d].textContent.replace(/[ ]{2,}$/g,\\\" \\\"),(b.node.isBlock(a)||b.node.isElement(a))&&(c[d].previousSibling||(c[d].textContent=c[d].textContent.replace(/^ */,\\\"\\\")),c[d].nextSibling||(c[d].textContent=c[d].textContent.replace(/ *$/,\\\"\\\")),c[d].previousSibling&&c[d].nextSibling&&\\\" \\\"==c[d].textContent&&(c[d].previousSibling&&c[d].nextSibling&&b.node.isBlock(c[d].previousSibling)&&b.node.isBlock(c[d].nextSibling)?c[d].textContent=\\\"\\\":c[d].textContent=\\\"\\\\n\\\"))}else m(c[d])}function n(a){return a&&(b.node.isBlock(a)||[\\\"STYLE\\\",\\\"SCRIPT\\\",\\\"HEAD\\\",\\\"BR\\\",\\\"HR\\\"].indexOf(a.tagName)>=0||a.nodeType==Node.COMMENT_NODE)}function o(c){if(\\\"undefined\\\"==typeof c&&(c=b.$el.get(0)),c.nodeType==Node.ELEMENT_NODE&&[\\\"STYLE\\\",\\\"SCRIPT\\\",\\\"HEAD\\\"].indexOf(c.tagName)<0){for(var d=b.node.contents(c),e=d.length-1;e>=0;e--)if(!a(d[e]).hasClass(\\\"fr-marker\\\")){var f=o(d[e]);if(1==f)return!0}}else if(c.nodeType==Node.TEXT_NODE&&c.textContent.length>0){var g=c.previousSibling,h=c.nextSibling;if(n(g)&&n(h)&&0===c.textContent.trim().length)return!0;var i=c.textContent;i=i.replace(new RegExp(a.FE.UNICODE_NBSP,\\\"g\\\"),\\\" \\\");for(var j=\\\"\\\",k=0;k<i.length;k++)j+=32!=i.charCodeAt(k)||0!==k&&32!=j.charCodeAt(k-1)?i[k]:a.FE.UNICODE_NBSP;if(c.nextSibling||(j=j.replace(/ $/,a.FE.UNICODE_NBSP)),c.previousSibling&&!b.node.isVoid(c.previousSibling)&&(j=j.replace(/^\\\\u00A0([^ $])/,\\\" $1\\\")),j=j.replace(/([^ \\\\u00A0])\\\\u00A0([^ \\\\u00A0])/g,\\\"$1 $2\\\"),c.textContent!=j)return!0}return!1}function p(a,b,c){var d=new RegExp(b,\\\"gi\\\"),e=d.exec(a);return e?e[c]:null}function q(a,b){var c=a.match(/<!DOCTYPE ?([^ ]*) ?([^ ]*) ?\\\"?([^\\\"]*)\\\"? ?\\\"?([^\\\"]*)\\\"?>/i);return c?b.implementation.createDocumentType(c[1],c[3],c[4]):b.implementation.createDocumentType(\\\"html\\\")}function r(a){var b=a.doctype,c=\\\"<!DOCTYPE html>\\\";return b&&(c=\\\"<!DOCTYPE \\\"+b.name+(b.publicId?' PUBLIC \\\"'+b.publicId+'\\\"':\\\"\\\")+(!b.publicId&&b.systemId?\\\" SYSTEM\\\":\\\"\\\")+(b.systemId?' \\\"'+b.systemId+'\\\"':\\\"\\\")+\\\">\\\"),c}function s(){i(),m(),g(),b.spaces.normalize(null,!0),b.html.fillEmptyBlocks(),b.clean.quotes(),b.clean.lists(),b.clean.tables(),b.clean.toHTML5(),b.selection.restore(),t(),b.placeholder.refresh()}function t(){b.core.isEmpty()&&(null!=c()?0===b.$el.get(0).querySelectorAll(f()).length&&0===b.$el.get(0).querySelectorAll(b.opts.htmlDoNotWrapTags.join(\\\":not(.fr-marker),\\\")+\\\":not(.fr-marker)\\\").length&&(b.core.hasFocus()?(b.$el.html(\\\"<\\\"+c()+\\\">\\\"+a.FE.MARKERS+\\\"<br/></\\\"+c()+\\\">\\\"),b.selection.restore()):b.$el.html(\\\"<\\\"+c()+\\\"><br/></\\\"+c()+\\\">\\\")):0===b.$el.get(0).querySelectorAll(\\\"*:not(.fr-marker):not(br)\\\").length&&(b.core.hasFocus()?(b.$el.html(a.FE.MARKERS+\\\"<br/>\\\"),b.selection.restore()):b.$el.html(\\\"<br/>\\\")))}function u(a,b){return p(a,\\\"<\\\"+b+\\\"[^>]*?>([\\\\\\\\w\\\\\\\\W]*)</\\\"+b+\\\">\\\",1)}function v(c,d){var e=a(\\\"<div \\\"+(p(c,\\\"<\\\"+d+\\\"([^>]*?)>\\\",1)||\\\"\\\")+\\\">\\\");return b.node.rawAttributes(e.get(0))}function w(a){return p(a,\\\"<!DOCTYPE([^>]*?)>\\\",0)||\\\"<!DOCTYPE html>\\\"}function x(c){var d=b.clean.html(c||\\\"\\\",[],[],b.opts.fullPage);if(b.opts.fullPage){var e=u(d,\\\"body\\\")||(d.indexOf(\\\"<body\\\")>=0?\\\"\\\":d),f=v(d,\\\"body\\\"),g=u(d,\\\"head\\\")||\\\"<title></title>\\\",h=v(d,\\\"head\\\"),i=a(\\\"<div>\\\").append(g).find(\\\"base, link, meta, noscript, script, style, template, title\\\").remove().end().html().trim();g=a(\\\"<div>\\\").append(g).find(\\\"base, link, meta, noscript, script, style, template, title\\\").map(function(){return this.outerHTML}).toArray().join(\\\"\\\");var j=w(d),k=v(d,\\\"html\\\");b.$el.html(i+\\\"\\\\n\\\"+e),b.node.clearAttributes(b.$el.get(0)),b.$el.attr(f),b.$el.addClass(\\\"fr-view\\\"),b.$el.attr(\\\"spellcheck\\\",b.opts.spellcheck),b.$el.attr(\\\"dir\\\",b.opts.direction),b.$head.html(g),b.node.clearAttributes(b.$head.get(0)),b.$head.attr(h),b.node.clearAttributes(b.$html.get(0)),b.$html.attr(k),b.iframe_document.doctype.parentNode.replaceChild(q(j,b.iframe_document),b.iframe_document.doctype)}else b.$el.html(d);var l=b.edit.isDisabled();b.edit.on(),b.core.injectStyle(b.opts.iframeStyle),s(),b.opts.useClasses||(b.$el.find(\\\"[fr-original-class]\\\").each(function(){this.setAttribute(\\\"class\\\",this.getAttribute(\\\"fr-original-class\\\")),this.removeAttribute(\\\"fr-original-class\\\")}),b.$el.find(\\\"[fr-original-style]\\\").each(function(){this.setAttribute(\\\"style\\\",this.getAttribute(\\\"fr-original-style\\\")),this.removeAttribute(\\\"fr-original-style\\\")})),l&&b.edit.off(),b.events.trigger(\\\"html.set\\\")}function y(a,c){if(!b.$wp)return b.$oel.clone().removeClass(\\\"fr-view\\\").removeAttr(\\\"contenteditable\\\").get(0).outerHTML;var d=\\\"\\\";b.events.trigger(\\\"html.beforeGet\\\");var e,f=function(a){var b=/(#[^\\\\s\\\\+>~\\\\.\\\\[:]+)/g,c=/(\\\\[[^\\\\]]+\\\\])/g,d=/(\\\\.[^\\\\s\\\\+>~\\\\.\\\\[:]+)/g,e=/(::[^\\\\s\\\\+>~\\\\.\\\\[:]+|:first-line|:first-letter|:before|:after)/gi,f=/(:[\\\\w-]+\\\\([^\\\\)]*\\\\))/gi,g=/(:[^\\\\s\\\\+>~\\\\.\\\\[:]+)/g,h=/([^\\\\s\\\\+>~\\\\.\\\\[:]+)/g;!function(){var b=/:not\\\\(([^\\\\)]*)\\\\)/g;b.test(a)&&(a=a.replace(b,\\\"     $1 \\\"))}();var i=100*(a.match(b)||[]).length+10*(a.match(c)||[]).length+10*(a.match(d)||[]).length+10*(a.match(f)||[]).length+10*(a.match(g)||[]).length+(a.match(e)||[]).length;return a=a.replace(/[\\\\*\\\\s\\\\+>~]/g,\\\" \\\"),a=a.replace(/[#\\\\.]/g,\\\" \\\"),i+=(a.match(h)||[]).length},g=[],h={};if(!b.opts.useClasses&&!c){for(e=0;e<b.doc.styleSheets.length;e++){var i,j=0;try{i=b.doc.styleSheets[e].cssRules,b.doc.styleSheets[e].ownerNode&&\\\"STYLE\\\"==b.doc.styleSheets[e].ownerNode.nodeType&&(j=1)}catch(k){}if(i)for(var l=0,m=i.length;m>l;l++)if(i[l].selectorText&&i[l].style.cssText.length>0){var n,o=i[l].selectorText.replace(/body |\\\\.fr-view /g,\\\"\\\").replace(/::/g,\\\":\\\");try{n=b.$el.get(0).querySelectorAll(o)}catch(k){n=[]}for(var p=0;p<n.length;p++){!n[p].getAttribute(\\\"fr-original-style\\\")&&n[p].getAttribute(\\\"style\\\")?(n[p].setAttribute(\\\"fr-original-style\\\",n[p].getAttribute(\\\"style\\\")),g.push(n[p])):n[p].getAttribute(\\\"fr-original-style\\\")||g.push(n[p]),h[n[p]]||(h[n[p]]={});for(var q=1e3*j+f(i[l].selectorText),s=i[l].style.cssText.split(\\\";\\\"),t=0;t<s.length;t++){var u=s[t].trim().split(\\\":\\\")[0];h[n[p]][u]||(h[n[p]][u]=0,(n[p].getAttribute(\\\"fr-original-style\\\")||\\\"\\\").indexOf(u+\\\":\\\")>=0&&(h[n[p]][u]=1e4)),q>=h[n[p]][u]&&(h[n[p]][u]=q,s[t].trim().length&&(n[p].style[u.trim()]=s[t].trim().split(\\\":\\\")[1].trim()))}}}}for(e=0;e<g.length;e++)if(g[e].getAttribute(\\\"class\\\")&&(g[e].setAttribute(\\\"fr-original-class\\\",g[e].getAttribute(\\\"class\\\")),g[e].removeAttribute(\\\"class\\\")),(g[e].getAttribute(\\\"fr-original-style\\\")||\\\"\\\").trim().length>0)for(var v=g[e].getAttribute(\\\"fr-original-style\\\").split(\\\";\\\"),p=0;p<v.length;p++)v[p].indexOf(\\\":\\\")>0&&(g[e].style[v[p].split(\\\":\\\")[0].trim()]=v[p].split(\\\":\\\")[1].trim())}if(b.core.isEmpty()?b.opts.fullPage&&(d=r(b.iframe_document),d+=\\\"<html\\\"+b.node.attributes(b.$html.get(0))+\\\">\\\"+b.$html.find(\\\"head\\\").get(0).outerHTML+\\\"<body></body></html>\\\"):(\\\"undefined\\\"==typeof a&&(a=!1),b.opts.fullPage?(d=r(b.iframe_document),b.$el.removeClass(\\\"fr-view\\\"),d+=\\\"<html\\\"+b.node.attributes(b.$html.get(0))+\\\">\\\"+b.$html.html()+\\\"</html>\\\",b.$el.addClass(\\\"fr-view\\\")):d=b.$el.html()),!b.opts.useClasses&&!c)for(e=0;e<g.length;e++)g[e].getAttribute(\\\"fr-original-class\\\")&&(g[e].setAttribute(\\\"class\\\",g[e].getAttribute(\\\"fr-original-class\\\")),g[e].removeAttribute(\\\"fr-original-class\\\")),g[e].getAttribute(\\\"fr-original-style\\\")?(g[e].setAttribute(\\\"style\\\",g[e].getAttribute(\\\"fr-original-style\\\")),g[e].removeAttribute(\\\"fr-original-style\\\")):g[e].removeAttribute(\\\"style\\\");b.opts.fullPage&&(d=d.replace(/<style data-fr-style=\\\"true\\\">(?:[\\\\w\\\\W]*?)<\\\\/style>/g,\\\"\\\"),d=d.replace(/<link(?:[\\\\w\\\\W]*?)data-fr-style=\\\"true\\\"(?:[\\\\w\\\\W]*?)>/g,\\\"\\\"),d=d.replace(/<style(?:[\\\\w\\\\W]*?)class=\\\"firebugResetStyles\\\"(?:[\\\\w\\\\W]*?)>(?:[\\\\w\\\\W]*?)<\\\\/style>/g,\\\"\\\"),d=d.replace(/<body((?:[\\\\w\\\\W]*?)) spellcheck=\\\"true\\\"((?:[\\\\w\\\\W]*?))>((?:[\\\\w\\\\W]*?))<\\\\/body>/g,\\\"<body$1$2>$3</body>\\\"),d=d.replace(/<body((?:[\\\\w\\\\W]*?)) contenteditable=\\\"(true|false)\\\"((?:[\\\\w\\\\W]*?))>((?:[\\\\w\\\\W]*?))<\\\\/body>/g,\\\"<body$1$3>$4</body>\\\"),d=d.replace(/<body((?:[\\\\w\\\\W]*?)) dir=\\\"([\\\\w]*)\\\"((?:[\\\\w\\\\W]*?))>((?:[\\\\w\\\\W]*?))<\\\\/body>/g,\\\"<body$1$3>$4</body>\\\"),d=d.replace(/<body((?:[\\\\w\\\\W]*?))class=\\\"([\\\\w\\\\W]*?)(fr-rtl|fr-ltr)([\\\\w\\\\W]*?)\\\"((?:[\\\\w\\\\W]*?))>((?:[\\\\w\\\\W]*?))<\\\\/body>/g,'<body$1class=\\\"$2$4\\\"$5>$6</body>'),d=d.replace(/<body((?:[\\\\w\\\\W]*?)) class=\\\"\\\"((?:[\\\\w\\\\W]*?))>((?:[\\\\w\\\\W]*?))<\\\\/body>/g,\\\"<body$1$2>$3</body>\\\")),b.opts.htmlSimpleAmpersand&&(d=d.replace(/\\\\&amp;/gi,\\\"&\\\")),b.events.trigger(\\\"html.afterGet\\\"),a||(d=d.replace(/<span[^>]*? class\\\\s*=\\\\s*[\\\"']?fr-marker[\\\"']?[^>]+>\\\\u200b<\\\\/span>/gi,\\\"\\\")),d=b.clean.invisibleSpaces(d);var w=b.events.chainTrigger(\\\"html.get\\\",d);return\\\"string\\\"==typeof w&&(d=w),d=d.replace(/<pre(?:[\\\\w\\\\W]*?)>(?:[\\\\w\\\\W]*?)<\\\\/pre>/g,function(a){return a.replace(/<br>/g,\\\"\\\\n\\\")})}function z(){var c=function(c,d){for(;d&&(d.nodeType==Node.TEXT_NODE||!b.node.isBlock(d))&&!b.node.isElement(d);)d&&d.nodeType!=Node.TEXT_NODE&&a(c).wrapInner(b.node.openTagString(d)+b.node.closeTagString(d)),d=d.parentNode;d&&c.innerHTML==d.innerHTML&&(c.innerHTML=d.outerHTML)},d=function(){var c,d=null;return b.win.getSelection?(c=b.win.getSelection(),c&&c.rangeCount&&(d=c.getRangeAt(0).commonAncestorContainer,d.nodeType!=Node.ELEMENT_NODE&&(d=d.parentNode))):(c=b.doc.selection)&&\\\"Control\\\"!=c.type&&(d=c.createRange().parentElement()),null!=d&&(a.inArray(b.$el.get(0),a(d).parents())>=0||d==b.$el.get(0))?d:null},e=\\\"\\\";if(\\\"undefined\\\"!=typeof b.win.getSelection){b.browser.mozilla&&(b.selection.save(),b.$el.find('.fr-marker[data-type=\\\"false\\\"]').length>1&&(b.$el.find('.fr-marker[data-type=\\\"false\\\"][data-id=\\\"0\\\"]').remove(),b.$el.find('.fr-marker[data-type=\\\"false\\\"]:last').attr(\\\"data-id\\\",\\\"0\\\"),b.$el.find(\\\".fr-marker\\\").not('[data-id=\\\"0\\\"]').remove()),b.selection.restore());for(var f=b.selection.ranges(),g=0;g<f.length;g++){var h=document.createElement(\\\"div\\\");h.appendChild(f[g].cloneContents()),c(h,d()),a(h).find(\\\".fr-element\\\").length>0&&(h=b.$el.get(0)),e+=h.innerHTML}}else\\\"undefined\\\"!=typeof b.doc.selection&&\\\"Text\\\"==b.doc.selection.type&&(e=b.doc.selection.createRange().htmlText);return e}function A(b){var c=a(\\\"<div>\\\").html(b);return c.find(f()).length>0}function B(a){var c=b.doc.createElement(\\\"div\\\");return c.innerHTML=a,b.selection.setAtEnd(c),c.innerHTML}function C(a){return a.replace(/</gi,\\\"&lt;\\\").replace(/>/gi,\\\"&gt;\\\").replace(/\\\"/gi,\\\"&quot;\\\").replace(/'/gi,\\\"&apos;\\\")}function D(c,d,e){b.selection.isCollapsed()||b.selection.remove();var f;if(f=d?c:b.clean.html(c),f=f.replace(/\\\\r|\\\\n/g,\\\" \\\"),c.indexOf('class=\\\"fr-marker\\\"')<0&&(f=B(f)),b.core.isEmpty())b.$el.html(f);else{var g=b.markers.insert();if(g){var h;if((A(f)||e)&&(h=b.node.deepestParent(g))){var g=b.markers.split();if(!g)return!1;a(g).replaceWith(f)}else a(g).replaceWith(f)}else b.$el.append(f)}s(),b.events.trigger(\\\"html.inserted\\\")}function E(c){var d=null;\\\"undefined\\\"==typeof c&&(d=b.selection.element());var e,f;do{f=!1,e=b.$el.get(0).querySelectorAll(\\\"*:not(.fr-marker)\\\");for(var g=0;g<e.length;g++){var h=e[g];if(d!=h){var i=h.textContent;0===h.children.length&&1===i.length&&8203==i.charCodeAt(0)&&(a(h).remove(),f=!0)}}}while(f)}function F(){var a=function(){\\nE(),b.placeholder&&b.placeholder.refresh()};b.events.on(\\\"mouseup\\\",a),b.events.on(\\\"keydown\\\",a),b.events.on(\\\"contentChanged\\\",t)}return{defaultTag:c,emptyBlocks:d,emptyBlockTagsQuery:e,blockTagsQuery:f,fillEmptyBlocks:k,cleanEmptyTags:g,cleanWhiteTags:E,doNormalize:o,cleanBlankSpaces:m,blocks:l,getDoctype:r,set:x,get:y,getSelected:z,insert:D,wrap:i,unwrap:j,escapeEntities:C,checkIfEmpty:t,extractNode:u,extractNodeAttrs:v,extractDoctype:w,_init:F}},a.extend(a.FE.DEFAULTS,{height:null,heightMax:null,heightMin:null,width:null}),a.FE.MODULES.size=function(a){function b(){c(),a.opts.height&&a.$el.css(\\\"minHeight\\\",a.opts.height-a.helpers.getPX(a.$el.css(\\\"padding-top\\\"))-a.helpers.getPX(a.$el.css(\\\"padding-bottom\\\"))),a.$iframe.height(a.$el.outerHeight(!0))}function c(){a.opts.heightMin?a.$el.css(\\\"minHeight\\\",a.opts.heightMin):a.$el.css(\\\"minHeight\\\",\\\"\\\"),a.opts.heightMax?(a.$wp.css(\\\"maxHeight\\\",a.opts.heightMax),a.$wp.css(\\\"overflow\\\",\\\"auto\\\")):(a.$wp.css(\\\"maxHeight\\\",\\\"\\\"),a.$wp.css(\\\"overflow\\\",\\\"\\\")),a.opts.height?(a.$wp.height(a.opts.height),a.$el.css(\\\"minHeight\\\",a.opts.height-a.helpers.getPX(a.$el.css(\\\"padding-top\\\"))-a.helpers.getPX(a.$el.css(\\\"padding-bottom\\\"))),a.$wp.css(\\\"overflow\\\",\\\"auto\\\")):(a.$wp.css(\\\"height\\\",\\\"\\\"),a.opts.heightMin||a.$el.css(\\\"minHeight\\\",\\\"\\\"),a.opts.heightMax||a.$wp.css(\\\"overflow\\\",\\\"\\\")),a.opts.width&&a.$box.width(a.opts.width)}function d(){return a.$wp?(c(),void(a.$iframe&&(a.events.on(\\\"keyup\\\",b),a.events.on(\\\"commands.after\\\",b),a.events.on(\\\"html.set\\\",b),a.events.on(\\\"init\\\",b),a.events.on(\\\"initialized\\\",b)))):!1}return{_init:d,syncIframe:b,refresh:c}},a.extend(a.FE.DEFAULTS,{language:null}),a.FE.LANGUAGE={},a.FE.MODULES.language=function(b){function c(a){return e&&e.translation[a]?e.translation[a]:a}function d(){a.FE.LANGUAGE&&(e=a.FE.LANGUAGE[b.opts.language]),e&&e.direction&&(b.opts.direction=e.direction)}var e;return{_init:d,translate:c}},a.extend(a.FE.DEFAULTS,{placeholderText:\\\"Type something\\\"}),a.FE.MODULES.placeholder=function(b){function c(){b.$placeholder||g();var c=0,d=0,e=0,f=0,h=b.node.contents(b.$el.get(0));if(h.length&&h[0].nodeType==Node.ELEMENT_NODE){var i=a(h[0]);b.opts.toolbarInline||(c=b.helpers.getPX(i.css(\\\"margin-top\\\")),e=b.helpers.getPX(i.css(\\\"padding-top\\\")),d=b.helpers.getPX(i.css(\\\"margin-left\\\")),f=b.helpers.getPX(i.css(\\\"padding-left\\\"))),b.$placeholder.css(\\\"font-size\\\",i.css(\\\"font-size\\\")),b.$placeholder.css(\\\"line-height\\\",i.css(\\\"line-height\\\"))}else b.$placeholder.css(\\\"font-size\\\",b.$el.css(\\\"font-size\\\")),b.$placeholder.css(\\\"line-height\\\",b.$el.css(\\\"line-height\\\"));b.$wp.addClass(\\\"show-placeholder\\\"),b.$placeholder.css({marginTop:Math.max(b.helpers.getPX(b.$el.css(\\\"margin-top\\\")),c),paddingTop:Math.max(b.helpers.getPX(b.$el.css(\\\"padding-top\\\")),e),paddingLeft:Math.max(b.helpers.getPX(b.$el.css(\\\"padding-left\\\")),f),marginLeft:Math.max(b.helpers.getPX(b.$el.css(\\\"margin-left\\\")),d)}).text(b.language.translate(b.opts.placeholderText||b.$oel.attr(\\\"placeholder\\\")||\\\"\\\")),b.$placeholder.html(b.$placeholder.text().replace(/\\\\n/g,\\\"<br>\\\"))}function d(){b.$wp.removeClass(\\\"show-placeholder\\\")}function e(){return b.$wp?b.$wp.hasClass(\\\"show-placeholder\\\"):!0}function f(){return b.$wp?void(b.core.isEmpty()?c():d()):!1}function g(){b.$placeholder=a('<span class=\\\"fr-placeholder\\\"></span>'),b.$wp.append(b.$placeholder)}function h(){return b.$wp?void b.events.on(\\\"init input keydown keyup contentChanged initialized\\\",f):!1}return{_init:h,show:c,hide:d,refresh:f,isVisible:e}},a.FE.MODULES.edit=function(a){function b(){if(a.browser.mozilla)try{a.doc.execCommand(\\\"enableObjectResizing\\\",!1,\\\"false\\\"),a.doc.execCommand(\\\"enableInlineTableEditing\\\",!1,\\\"false\\\")}catch(b){}if(a.browser.msie)try{a.doc.body.addEventListener(\\\"mscontrolselect\\\",function(a){return a.preventDefault(),!1})}catch(b){}}function c(){a.$wp?(a.$el.attr(\\\"contenteditable\\\",!0),a.$el.removeClass(\\\"fr-disabled\\\"),a.$tb&&a.$tb.removeClass(\\\"fr-disabled\\\"),b()):a.$el.is(\\\"a\\\")&&a.$el.attr(\\\"contenteditable\\\",!0),f=!1}function d(){a.$wp?(a.$el.attr(\\\"contenteditable\\\",!1),a.$el.addClass(\\\"fr-disabled\\\"),a.$tb&&a.$tb.addClass(\\\"fr-disabled\\\")):a.$el.is(\\\"a\\\")&&a.$el.attr(\\\"contenteditable\\\",!1),f=!0}function e(){return f}var f=!1;return{on:c,off:d,disableDesign:b,isDisabled:e}},a.extend(a.FE.DEFAULTS,{editorClass:null,typingTimer:500,iframe:!1,requestWithCORS:!0,requestHeaders:{},useClasses:!0,spellcheck:!0,iframeStyle:'html{margin: 0px;}body{padding:10px;background:transparent;color:#000000;position:relative;z-index: 2;-webkit-user-select:auto;margin:0px;overflow:hidden;min-height:20px;}body:after{content:\\\"\\\";display:block;clear:both;}',iframeStyleFiles:[],direction:\\\"auto\\\",zIndex:1,disableRightClick:!1,scrollableContainer:\\\"body\\\",keepFormatOnDelete:!1,theme:null}),a.FE.MODULES.core=function(b){function c(a){if(b.opts.iframe){b.$head.find(\\\"style[data-fr-style], link[data-fr-style]\\\").remove(),b.$head.append('<style data-fr-style=\\\"true\\\">'+a+\\\"</style>\\\");for(var c=0;c<b.opts.iframeStyleFiles.length;c++)b.$head.append('<link data-fr-style=\\\"true\\\" rel=\\\"stylesheet\\\" href=\\\"'+b.opts.iframeStyleFiles[c]+'\\\">')}}function d(){b.opts.iframe||b.$el.addClass(\\\"fr-element fr-view\\\")}function e(){if(b.$box.addClass(\\\"fr-box\\\"+(b.opts.editorClass?\\\" \\\"+b.opts.editorClass:\\\"\\\")),b.$wp.addClass(\\\"fr-wrapper\\\"),d(),b.opts.iframe){b.$iframe.addClass(\\\"fr-iframe\\\"),b.$el.addClass(\\\"fr-view\\\");for(var a=0;a<b.o_doc.styleSheets.length;a++){var c;try{c=b.o_doc.styleSheets[a].cssRules}catch(e){}if(c)for(var f=0,g=c.length;g>f;f++)!c[f].selectorText||0!==c[f].selectorText.indexOf(\\\".fr-view\\\")&&0!==c[f].selectorText.indexOf(\\\".fr-element\\\")||c[f].style.cssText.length>0&&(0===c[f].selectorText.indexOf(\\\".fr-view\\\")?b.opts.iframeStyle+=c[f].selectorText.replace(/\\\\.fr-view/g,\\\"body\\\")+\\\"{\\\"+c[f].style.cssText+\\\"}\\\":b.opts.iframeStyle+=c[f].selectorText.replace(/\\\\.fr-element/g,\\\"body\\\")+\\\"{\\\"+c[f].style.cssText+\\\"}\\\")}}\\\"auto\\\"!=b.opts.direction&&b.$box.removeClass(\\\"fr-ltr fr-rtl\\\").addClass(\\\"fr-\\\"+b.opts.direction),b.$el.attr(\\\"dir\\\",b.opts.direction),b.$wp.attr(\\\"dir\\\",b.opts.direction),b.opts.zIndex>1&&b.$box.css(\\\"z-index\\\",b.opts.zIndex),b.opts.theme&&b.$box.addClass(b.opts.theme+\\\"-theme\\\")}function f(){return b.node.isEmpty(b.$el.get(0))}function g(){b.drag_support={filereader:\\\"undefined\\\"!=typeof FileReader,formdata:!!b.win.FormData,progress:\\\"upload\\\"in new XMLHttpRequest}}function h(a,c){var d=new XMLHttpRequest;d.open(c,a,!0),b.opts.requestWithCORS&&(d.withCredentials=!0);for(var e in b.opts.requestHeaders)b.opts.requestHeaders.hasOwnProperty(e)&&d.setRequestHeader(e,b.opts.requestHeaders[e]);return d}function i(a){\\\"TEXTAREA\\\"==b.$oel.get(0).tagName&&b.$oel.val(a),b.$wp&&(\\\"TEXTAREA\\\"==b.$oel.get(0).tagName?(b.$el.html(\\\"\\\"),b.$wp.html(\\\"\\\"),b.$box.replaceWith(b.$oel),b.$oel.show()):(b.$wp.replaceWith(a),b.$el.html(\\\"\\\"),b.$box.removeClass(\\\"fr-view fr-ltr fr-box \\\"+(b.opts.editorClass||\\\"\\\")),b.opts.theme&&b.$box.addClass(b.opts.theme+\\\"-theme\\\"))),this.$wp=null,this.$el=null,this.$box=null}function j(){return b.browser.mozilla&&b.helpers.isMobile()?b.selection.inEditor():b.node.hasFocus(b.$el.get(0))||b.$el.find(\\\"*:focus\\\").length>0}function k(a){if(!a)return!1;var c=a.data(\\\"instance\\\");return c?c.id==b.id:!1}function l(){if(a.FE.INSTANCES.push(b),g(),b.$wp){e(),b.html.set(b._original_html),b.$el.attr(\\\"spellcheck\\\",b.opts.spellcheck),b.helpers.isMobile()&&(b.$el.attr(\\\"autocomplete\\\",b.opts.spellcheck?\\\"on\\\":\\\"off\\\"),b.$el.attr(\\\"autocorrect\\\",b.opts.spellcheck?\\\"on\\\":\\\"off\\\"),b.$el.attr(\\\"autocapitalize\\\",b.opts.spellcheck?\\\"on\\\":\\\"off\\\")),b.opts.disableRightClick&&b.events.$on(b.$el,\\\"contextmenu\\\",function(a){return 2==a.button?!1:void 0});try{b.doc.execCommand(\\\"styleWithCSS\\\",!1,!1)}catch(c){}}b.events.on(\\\"drop\\\",function(a){a.preventDefault(),a.stopPropagation()}),\\\"TEXTAREA\\\"==b.$oel.get(0).tagName&&(b.events.on(\\\"contentChanged\\\",function(){b.$oel.val(b.html.get())}),b.events.on(\\\"form.submit\\\",function(){b.$oel.val(b.html.get())}),b.events.on(\\\"form.reset\\\",function(){b.html.set(b._original_html)}),b.$oel.val(b.html.get())),b.helpers.isIOS()&&b.events.$on(b.$doc,\\\"selectionchange\\\",function(){b.$doc.get(0).hasFocus()||b.$win.get(0).focus()}),b.events.trigger(\\\"init\\\")}return{_init:l,destroy:i,isEmpty:f,getXHR:h,injectStyle:c,hasFocus:j,sameInstance:k}},a.FE.MODULES.format=function(b){function c(a,b){var c=\\\"<\\\"+a;for(var d in b)b.hasOwnProperty(d)&&(c+=\\\" \\\"+d+'=\\\"'+b[d]+'\\\"');return c+=\\\">\\\"}function d(a){return\\\"</\\\"+a+\\\">\\\"}function e(a,b){var c=a;for(var d in b)b.hasOwnProperty(d)&&(a+=\\\"id\\\"==d?\\\"#\\\"+b[d]:\\\"class\\\"==d?\\\".\\\"+b[d]:\\\"[\\\"+d+'=\\\"'+b[d]+'\\\"]');return c}function f(a,b){return a&&a.nodeType==Node.ELEMENT_NODE?(a.matches||a.matchesSelector||a.msMatchesSelector||a.mozMatchesSelector||a.webkitMatchesSelector||a.oMatchesSelector).call(a,b):!1}function g(d,e,f){if(d){if(b.node.isBlock(d))return g(d.firstChild,e,f),!1;for(var h=a(c(e,f)).insertBefore(d),i=d;i&&!a(i).is(\\\".fr-marker\\\")&&0==a(i).find(\\\".fr-marker\\\").length;){var j=i;i=i.nextSibling,h.append(j)}if(i)a(i).find(\\\".fr-marker\\\").length&&g(i.firstChild,e,f);else{for(var k=h.get(0).parentNode;k&&!k.nextSibling&&!b.node.isElement(k);)k=k.parentNode;if(k){var l=k.nextSibling;l&&(b.node.isBlock(l)?g(l.firstChild,e,f):g(l,e,f))}}h.is(\\\":empty\\\")&&h.remove()}}function h(h,i){if(\\\"undefined\\\"==typeof i&&(i={}),i.style&&delete i.style,b.selection.isCollapsed()){b.markers.insert();var j=b.$el.find(\\\".fr-marker\\\");j.replaceWith(c(h,i)+a.FE.INVISIBLE_SPACE+a.FE.MARKERS+d(h)),b.selection.restore()}else{b.selection.save();var k=b.$el.find('.fr-marker[data-type=\\\"true\\\"]').get(0).nextSibling;g(k,h,i);var l;do l=b.$el.find(e(h,i)+\\\" > \\\"+e(h,i)),l.each(function(){a(this).replaceWith(this.innerHTML)});while(l.length);b.$el.get(0).normalize();for(var m=b.$el.get(0).querySelectorAll(\\\".fr-marker\\\"),n=0;n<m.length;n++){var o=a(m[n]);1==o.data(\\\"type\\\")?f(o.get(0).nextSibling,e(h,i))&&o.next().prepend(o):f(o.get(0).previousSibling,e(h,i))&&o.prev().append(o)}b.selection.restore()}}function i(a,c,d,g){if(!g){var h=!1;if(a.data(\\\"type\\\")===!0)for(;b.node.isFirstSibling(a.get(0))&&!a.parent().is(b.$el);)a.parent().before(a),h=!0;else if(a.data(\\\"type\\\")===!1)for(;b.node.isLastSibling(a.get(0))&&!a.parent().is(b.$el);)a.parent().after(a),h=!0;if(h)return!0}if(a.parents(c).length||\\\"undefined\\\"==typeof c){var i=\\\"\\\",j=\\\"\\\",k=a.parent();if(k.is(b.$el)||b.node.isBlock(k.get(0)))return!1;for(;\\\"undefined\\\"==typeof c&&!b.node.isBlock(k.parent().get(0))||\\\"undefined\\\"!=typeof c&&!f(k.get(0),e(c,d));)i+=b.node.closeTagString(k.get(0)),j=b.node.openTagString(k.get(0))+j,k=k.parent();var l=a.get(0).outerHTML;a.replaceWith('<span id=\\\"mark\\\"></span>');var m=k.html().replace(/<span id=\\\"mark\\\"><\\\\/span>/,i+b.node.closeTagString(k.get(0))+j+l+i+b.node.openTagString(k.get(0))+j);return k.replaceWith(b.node.openTagString(k.get(0))+m+b.node.closeTagString(k.get(0))),!0}return!1}function j(c,d,g,h){for(var i=b.node.contents(c.get(0)),k=0;k<i.length;k++){var l=i[k];a(l).hasClass(\\\"fr-marker\\\")?d=(d+1)%2:d?a(l).find(\\\".fr-marker\\\").length>0?d=j(a(l),d,g,h):(a(a(l).find(g||\\\"*\\\").get().reverse()).each(function(){b.node.isBlock(this)||b.node.isVoid(this)||a(this).replaceWith(this.innerHTML)}),(\\\"undefined\\\"==typeof g&&l.nodeType==Node.ELEMENT_NODE&&!b.node.isVoid(l)&&!b.node.isBlock(l)||f(l,e(g,h)))&&a(l).replaceWith(l.innerHTML)):a(l).find(\\\".fr-marker\\\").length>0&&(d=j(a(l),d,g,h))}return d}function k(c,d){\\\"undefined\\\"==typeof d&&(d={}),d.style&&delete d.style;var e=b.selection.isCollapsed();b.selection.save();for(var f=!0;f;){f=!1;for(var g=b.$el.find(\\\".fr-marker\\\"),h=0;h<g.length;h++)if(i(a(g[h]),c,d,e)){f=!0;break}}j(b.$el,0,c,d),e&&b.$el.find(\\\".fr-marker\\\").before(a.FE.INVISIBLE_SPACE).after(a.FE.INVISIBLE_SPACE),b.html.cleanEmptyTags(),b.$el.get(0).normalize(),b.selection.restore()}function l(a,b){q(a,b)?k(a,b):h(a,b)}function m(b,c){var d=a(b);d.css(c,\\\"\\\"),\\\"\\\"===d.attr(\\\"style\\\")&&d.replaceWith(d.html())}function n(b,c){return 0===a(b).attr(\\\"style\\\").indexOf(c+\\\":\\\")||a(b).attr(\\\"style\\\").indexOf(\\\";\\\"+c+\\\":\\\")>=0||a(b).attr(\\\"style\\\").indexOf(\\\"; \\\"+c+\\\":\\\")>=0}function o(c,d){if(b.selection.isCollapsed()){b.markers.insert();var e=b.$el.find(\\\".fr-marker\\\"),f=e.parent();b.node.openTagString(f.get(0))=='<span style=\\\"'+c+\\\": \\\"+f.css(c)+';\\\">'&&b.node.isEmpty(f.get(0))?f.replaceWith('<span style=\\\"'+c+\\\": \\\"+d+';\\\">'+a.FE.INVISIBLE_SPACE+a.FE.MARKERS+\\\"</span>\\\"):b.node.isEmpty(f.get(0))&&f.is(\\\"span\\\")?(e.replaceWith(a.FE.MARKERS),f.css(c,d)):e.replaceWith('<span style=\\\"'+c+\\\": \\\"+d+';\\\">'+a.FE.INVISIBLE_SPACE+a.FE.MARKERS+\\\"</span>\\\"),b.selection.restore()}else{if(b.selection.save(),null===d)for(var h=b.$el.find(\\\".fr-marker\\\"),i=0;i<h.length;i++){var e=a(h[i]);if(e.data(\\\"type\\\")===!0)for(;b.node.isFirstSibling(e.get(0))&&!e.parent().is(b.$el);)e.parent().before(e);else for(;b.node.isLastSibling(e.get(0))&&!e.parent().is(b.$el);)e.parent().after(e)}var j=b.$el.find('.fr-marker[data-type=\\\"true\\\"]').get(0).nextSibling,k={\\\"class\\\":\\\"fr-unprocessed\\\"};for(d&&(k.style=c+\\\": \\\"+d+\\\";\\\"),g(j,\\\"span\\\",k),b.$el.find(\\\".fr-marker + .fr-unprocessed\\\").each(function(){a(this).prepend(a(this).prev())}),b.$el.find(\\\".fr-unprocessed + .fr-marker\\\").each(function(){a(this).prev().append(this)});b.$el.find(\\\"span.fr-unprocessed\\\").length>0;){var l=b.$el.find(\\\"span.fr-unprocessed:first\\\").removeClass(\\\"fr-unprocessed\\\");if(l.parent().get(0).normalize(),l.parent().is(\\\"span\\\")&&1==l.parent().get(0).childNodes.length){l.parent().css(c,d);var o=l;l=l.parent(),o.replaceWith(o.html())}for(var p=l.find(\\\"span\\\"),i=p.length-1;i>=0;i--)m(p[i],c);var q=l.parentsUntil(b.$el,\\\"span[style]\\\").filter(function(){return n(this,c)});if(q.length){var r=\\\"\\\",s=\\\"\\\",t=\\\"\\\",u=\\\"\\\",v=l.get(0);do v=v.parentNode,r+=b.node.closeTagString(v),s=b.node.openTagString(a(v).clone().addClass(\\\"fr-split\\\").get(0))+s,q.get(0)!=v&&(t+=b.node.closeTagString(v),u=b.node.openTagString(a(v).clone().addClass(\\\"fr-split\\\").get(0))+u);while(q.get(0)!=v);var w=r+b.node.openTagString(a(q.get(0)).clone().css(c,d||\\\"\\\").get(0))+u+l.css(c,\\\"\\\").get(0).outerHTML+t+\\\"</span>\\\"+s;l.replaceWith('<span id=\\\"fr-break\\\"></span>');var x=q.get(0).outerHTML;a(q.get(0)).replaceWith(x.replace(/<span id=\\\"fr-break\\\"><\\\\/span>/g,w))}}for(;b.$el.find(\\\".fr-split:empty\\\").length>0;)b.$el.find(\\\".fr-split:empty\\\").remove();b.$el.find(\\\".fr-split\\\").removeClass(\\\"fr-split\\\"),b.$el.find('span[style=\\\"\\\"]').removeAttr(\\\"style\\\"),b.$el.find('span[class=\\\"\\\"]').removeAttr(\\\"class\\\"),b.html.cleanEmptyTags(),a(b.$el.find(\\\"span\\\").get().reverse()).each(function(){this.attributes&&0!=this.attributes.length||a(this).replaceWith(this.innerHTML)}),b.$el.get(0).normalize();var y=b.$el.find(\\\"span[style] + span[style]\\\");for(i=0;i<y.length;i++){var z=a(y[i]),A=a(y[i]).prev();z.get(0).previousSibling==A.get(0)&&b.node.openTagString(z.get(0))==b.node.openTagString(A.get(0))&&(z.prepend(A.html()),A.remove())}b.$el.get(0).normalize(),b.selection.restore()}}function p(a){o(a,null)}function q(a,c){\\\"undefined\\\"==typeof c&&(c={}),c.style&&delete c.style;var d=b.selection.ranges(0),g=d.startContainer;g.nodeType==Node.ELEMENT_NODE&&g.childNodes.length>0&&g.childNodes[d.startOffset]&&(g=g.childNodes[d.startOffset]);for(var h=g;h&&h.nodeType==Node.ELEMENT_NODE&&!f(h,e(a,c));)h=h.firstChild;if(h&&h.nodeType==Node.ELEMENT_NODE&&f(h,e(a,c)))return!0;var i=g;for(i&&i.nodeType!=Node.ELEMENT_NODE&&(i=i.parentNode);i&&i.nodeType==Node.ELEMENT_NODE&&i!=b.$el.get(0)&&!f(i,e(a,c));)i=i.parentNode;return i&&i.nodeType==Node.ELEMENT_NODE&&i!=b.$el.get(0)&&f(i,e(a,c))?!0:!1}return{is:q,toggle:l,apply:h,remove:k,applyStyle:o,removeStyle:p}},a.FE.COMMANDS={bold:{title:\\\"Bold\\\",refresh:function(a){a.toggleClass(\\\"fr-active\\\",this.format.is(\\\"strong\\\"))}},italic:{title:\\\"Italic\\\",refresh:function(a){a.toggleClass(\\\"fr-active\\\",this.format.is(\\\"em\\\"))}},underline:{title:\\\"Underline\\\",refresh:function(a){a.toggleClass(\\\"fr-active\\\",this.format.is(\\\"u\\\"))}},strikeThrough:{title:\\\"Strikethrough\\\",refresh:function(a){a.toggleClass(\\\"fr-active\\\",this.format.is(\\\"s\\\"))}},subscript:{title:\\\"Subscript\\\",refresh:function(a){a.toggleClass(\\\"fr-active\\\",this.format.is(\\\"sub\\\"))}},superscript:{title:\\\"Superscript\\\",refresh:function(a){a.toggleClass(\\\"fr-active\\\",this.format.is(\\\"sup\\\"))}},outdent:{title:\\\"Decrease Indent\\\"},indent:{title:\\\"Increase Indent\\\"},undo:{title:\\\"Undo\\\",undo:!1,forcedRefresh:!0,disabled:!0},redo:{title:\\\"Redo\\\",undo:!1,forcedRefresh:!0,disabled:!0},insertHR:{title:\\\"Insert Horizontal Line\\\"},clearFormatting:{title:\\\"Clear Formatting\\\"},selectAll:{title:\\\"Select All\\\",undo:!1}},a.FE.RegisterCommand=function(b,c){a.FE.COMMANDS[b]=c},a.FE.MODULES.commands=function(b){function c(c,d){if(b.events.trigger(\\\"commands.before\\\",a.merge([c],d||[]))!==!1){var e=a.FE.COMMANDS[c]&&a.FE.COMMANDS[c].callback||h[c],f=!0;a.FE.COMMANDS[c]&&\\\"undefined\\\"!=typeof a.FE.COMMANDS[c].focus&&(f=a.FE.COMMANDS[c].focus),b.core.hasFocus()||!f||b.popups.areVisible()||b.events.focus(!0),a.FE.COMMANDS[c]&&a.FE.COMMANDS[c].undo!==!1&&b.undo.saveStep(),e&&e.apply(b,a.merge([c],d||[])),b.events.trigger(\\\"commands.after\\\",a.merge([c],d||[])),a.FE.COMMANDS[c]&&a.FE.COMMANDS[c].undo!==!1&&b.undo.saveStep()}}function d(a,c){b.format.toggle(c)}function e(c){b.selection.save(),b.html.wrap(!0,!0,!0,!0),b.selection.restore();for(var d=b.selection.blocks(),e=0;e<d.length;e++)if(\\\"LI\\\"!=d[e].tagName&&\\\"LI\\\"!=d[e].parentNode.tagName){var f=a(d[e]),g=\\\"rtl\\\"==b.opts.direction||\\\"rtl\\\"==f.css(\\\"direction\\\")?\\\"margin-right\\\":\\\"margin-left\\\",h=b.helpers.getPX(f.css(g));f.css(g,Math.max(h+20*c,0)||\\\"\\\"),f.removeClass(\\\"fr-temp-div\\\")}b.selection.save(),b.html.unwrap(),b.selection.restore()}function f(a){return function(){c(a)}}function g(){b.events.on(\\\"keydown\\\",function(a){var c=b.selection.element();return c&&\\\"HR\\\"==c.tagName?(a.preventDefault(),!1):void 0}),b.events.on(\\\"mousedown\\\",function(a){return a.target&&\\\"HR\\\"==a.target.tagName?(a.preventDefault(),a.stopPropagation(),!1):void 0}),b.events.on(\\\"mouseup\\\",function(c){var d=b.selection.element(),e=b.selection.endElement();d==e&&d&&\\\"HR\\\"==d.tagName&&(d.nextSibling&&(b.node.isBlock(d.nextSibling)?b.selection.setAtStart(d.nextSibling):a(d).after(a.FE.MARKERS)),b.selection.restore())})}var h={bold:function(){d(\\\"bold\\\",\\\"strong\\\")},subscript:function(){d(\\\"subscript\\\",\\\"sub\\\")},superscript:function(){d(\\\"superscript\\\",\\\"sup\\\")},italic:function(){d(\\\"italic\\\",\\\"em\\\")},strikeThrough:function(){d(\\\"strikeThrough\\\",\\\"s\\\")},underline:function(){d(\\\"underline\\\",\\\"u\\\")},undo:function(){b.undo.run()},redo:function(){b.undo.redo()},indent:function(){e(1)},outdent:function(){e(-1)},show:function(){b.opts.toolbarInline&&b.toolbar.showInline(null,!0)},insertHR:function(){b.selection.remove();var a=\\\"\\\";b.core.isEmpty()&&(a=\\\"<br>\\\",b.html.defaultTag()&&(a=\\\"<\\\"+b.html.defaultTag()+\\\">\\\"+a+\\\"</\\\"+b.html.defaultTag()+\\\">\\\")),b.html.insert('<hr id=\\\"fr-just\\\">'+a);var c=b.$el.find(\\\"hr#fr-just\\\");c.removeAttr(\\\"id\\\"),b.selection.setAfter(c.get(0))||b.selection.setBefore(c.get(0)),b.selection.restore()},clearFormatting:function(){b.format.remove()},selectAll:function(){b.doc.execCommand(\\\"selectAll\\\",!1,!1)}},i={};for(var j in h)h.hasOwnProperty(j)&&(i[j]=f(j));return a.extend(i,{exec:c,_init:g})},a.FE.MODULES.cursorLists=function(b){function c(a){for(var b=a;\\\"LI\\\"!=b.tagName;)b=b.parentNode;return b}function d(a){for(var c=a;!b.node.isList(c);)c=c.parentNode;return c}function e(e){var f,g=c(e),h=g.nextSibling,i=g.previousSibling,j=b.html.defaultTag();if(b.node.isEmpty(g,!0)&&h){for(var k=\\\"\\\",l=\\\"\\\",m=e.parentNode;!b.node.isList(m)&&m.parentNode&&\\\"LI\\\"!==m.parentNode.tagName;)k=b.node.openTagString(m)+k,l+=b.node.closeTagString(m),m=m.parentNode;k=b.node.openTagString(m)+k,l+=b.node.closeTagString(m);var n=\\\"\\\";for(n=m.parentNode&&\\\"LI\\\"==m.parentNode.tagName?l+\\\"<li>\\\"+a.FE.MARKERS+\\\"<br>\\\"+k:j?l+\\\"<\\\"+j+\\\">\\\"+a.FE.MARKERS+\\\"<br></\\\"+j+\\\">\\\"+k:l+a.FE.MARKERS+\\\"<br>\\\"+k,a(g).html('<span id=\\\"fr-break\\\"></span>');[\\\"UL\\\",\\\"OL\\\"].indexOf(m.tagName)<0||m.parentNode&&\\\"LI\\\"===m.parentNode.tagName;)m=m.parentNode;var o=b.node.openTagString(m)+a(m).html()+b.node.closeTagString(m);o=o.replace(/<span id=\\\"fr-break\\\"><\\\\/span>/g,n),a(m).replaceWith(o),b.$el.find(\\\"li:empty\\\").remove()}else i&&h||!b.node.isEmpty(g,!0)?(a(g).before(\\\"<li><br></li>\\\"),a(e).remove()):i?(f=d(g),f.parentNode&&\\\"LI\\\"==f.parentNode.tagName?a(f.parentNode).after(\\\"<li>\\\"+a.FE.MARKERS+\\\"<br></li>\\\"):j?a(f).after(\\\"<\\\"+j+\\\">\\\"+a.FE.MARKERS+\\\"<br></\\\"+j+\\\">\\\"):a(f).after(a.FE.MARKERS+\\\"<br>\\\"),a(g).remove()):(f=d(g),f.parentNode&&\\\"LI\\\"==f.parentNode.tagName?a(f.parentNode).before(\\\"<li>\\\"+a.FE.MARKERS+\\\"<br></li>\\\"):j?a(f).before(\\\"<\\\"+j+\\\">\\\"+a.FE.MARKERS+\\\"<br></\\\"+j+\\\">\\\"):a(f).before(a.FE.MARKERS+\\\"<br>\\\"),a(g).remove())}function f(d){for(var e=c(d),f=\\\"\\\",g=d,h=\\\"\\\",i=\\\"\\\";g!=e;){g=g.parentNode;var j=\\\"A\\\"==g.tagName&&b.cursor.isAtEnd(d,g)?\\\"fr-to-remove\\\":\\\"\\\";h=b.node.openTagString(a(g).clone().addClass(j).get(0))+h,i=b.node.closeTagString(g)+i}f=i+f+h+a.FE.MARKERS,a(d).replaceWith('<span id=\\\"fr-break\\\"></span>');var k=b.node.openTagString(e)+a(e).html()+b.node.closeTagString(e);k=k.replace(/<span id=\\\"fr-break\\\"><\\\\/span>/g,f),a(e).replaceWith(k)}function g(d){for(var e=c(d),f=a.FE.MARKERS,g=\\\"\\\",h=d,i=!1;h!=e;){h=h.parentNode;var j=\\\"A\\\"==h.tagName&&b.cursor.isAtEnd(d,h)?\\\"fr-to-remove\\\":\\\"\\\";i||h==e||b.node.isBlock(h)||(i=!0,g+=a.FE.INVISIBLE_SPACE),g=b.node.openTagString(a(h).clone().addClass(j).get(0))+g,f+=b.node.closeTagString(h)}var k=g+f;a(d).remove(),a(e).after(k)}function h(e){var f=c(e),g=f.previousSibling;if(g){g=a(g).find(b.html.blockTagsQuery()).get(-1)||g,a(e).replaceWith(a.FE.MARKERS);var h=b.node.contents(g);h.length&&\\\"BR\\\"==h[h.length-1].tagName&&a(h[h.length-1]).remove(),a(f).find(b.html.blockTagsQuery()).not(\\\"ol, ul, table\\\").each(function(){this.parentNode==f&&a(this).replaceWith(a(this).html()+(b.node.isEmpty(this)?\\\"\\\":\\\"<br>\\\"))});for(var i,j=b.node.contents(f)[0];j&&!b.node.isList(j);)i=j.nextSibling,a(g).append(j),j=i;for(g=f.previousSibling;j;)i=j.nextSibling,a(g).append(j),j=i;a(f).remove()}else{var k=d(f);if(a(e).replaceWith(a.FE.MARKERS),k.parentNode&&\\\"LI\\\"==k.parentNode.tagName){var l=k.previousSibling;b.node.isBlock(l)?(a(f).find(b.html.blockTagsQuery()).not(\\\"ol, ul, table\\\").each(function(){this.parentNode==f&&a(this).replaceWith(a(this).html()+(b.node.isEmpty(this)?\\\"\\\":\\\"<br>\\\"))}),a(l).append(a(f).html())):a(k).before(a(f).html())}else{var m=b.html.defaultTag();m&&0===a(f).find(b.html.blockTagsQuery()).length?a(k).before(\\\"<\\\"+m+\\\">\\\"+a(f).html()+\\\"</\\\"+m+\\\">\\\"):a(k).before(a(f).html())}a(f).remove(),0===a(k).find(\\\"li\\\").length&&a(k).remove()}}function i(d){var e,f=c(d),g=f.nextSibling;if(g){e=b.node.contents(g),e.length&&\\\"BR\\\"==e[0].tagName&&a(e[0]).remove(),a(g).find(b.html.blockTagsQuery()).not(\\\"ol, ul, table\\\").each(function(){this.parentNode==g&&a(this).replaceWith(a(this).html()+(b.node.isEmpty(this)?\\\"\\\":\\\"<br>\\\"))});for(var h,i=d,j=b.node.contents(g)[0];j&&!b.node.isList(j);)h=j.nextSibling,a(i).after(j),i=j,j=h;for(;j;)h=j.nextSibling,a(f).append(j),j=h;a(d).replaceWith(a.FE.MARKERS),a(g).remove()}else{for(var k=f;!k.nextSibling&&k!=b.$el.get(0);)k=k.parentNode;if(k==b.$el.get(0))return!1;if(k=k.nextSibling,b.node.isBlock(k))a.FE.NO_DELETE_TAGS.indexOf(k.tagName)<0&&(a(d).replaceWith(a.FE.MARKERS),e=b.node.contents(f),e.length&&\\\"BR\\\"==e[e.length-1].tagName&&a(e[e.length-1]).remove(),a(f).append(a(k).html()),a(k).remove());else for(e=b.node.contents(f),e.length&&\\\"BR\\\"==e[e.length-1].tagName&&a(e[e.length-1]).remove(),a(d).replaceWith(a.FE.MARKERS);k&&!b.node.isBlock(k)&&\\\"BR\\\"!=k.tagName;)a(f).append(a(k)),k=k.nextSibling}}return{_startEnter:e,_middleEnter:f,_endEnter:g,_backspace:h,_del:i}},a.FE.NO_DELETE_TAGS=[\\\"TH\\\",\\\"TD\\\",\\\"TABLE\\\",\\\"FORM\\\"],a.FE.SIMPLE_ENTER_TAGS=[\\\"TH\\\",\\\"TD\\\",\\\"LI\\\",\\\"DL\\\",\\\"DT\\\",\\\"FORM\\\"],a.FE.MODULES.cursor=function(b){function c(a){return a?b.node.isBlock(a)?!0:a.nextSibling?!1:c(a.parentNode):!1}function d(a){return a?b.node.isBlock(a)?!0:a.previousSibling?!1:d(a.parentNode):!1}function e(a,c){return a?a==b.$wp.get(0)?!1:a.previousSibling?!1:a.parentNode==c?!0:e(a.parentNode,c):!1}function f(a,c){return a?a==b.$wp.get(0)?!1:a.nextSibling?!1:a.parentNode==c?!0:f(a.parentNode,c):!1}function g(c){return a(c).parentsUntil(b.$el,\\\"LI\\\").length>0&&0===a(c).parentsUntil(\\\"LI\\\",\\\"TABLE\\\").length}function h(c){var d=a(c).parentsUntil(b.$el,\\\"BLOCKQUOTE\\\").length>0,e=b.node.deepestParent(c,[],!d);if(e&&\\\"BLOCKQUOTE\\\"==e.tagName){var f=b.node.deepestParent(c,[a(c).parentsUntil(b.$el,\\\"BLOCKQUOTE\\\").get(0)]);f&&f.previousSibling&&(e=f)}if(null!==e){var g,h=e.previousSibling;if(b.node.isBlock(e)&&b.node.isEditable(e)&&h&&a.FE.NO_DELETE_TAGS.indexOf(h.tagName)<0)if(b.node.isDeletable(h))a(h).remove(),a(c).replaceWith(a.FE.MARKERS);else if(b.node.isEditable(h))if(b.node.isBlock(h))if(b.node.isEmpty(h)&&!b.node.isList(h))a(h).remove();else{if(b.node.isList(h)&&(h=a(h).find(\\\"li:last\\\").get(0)),g=b.node.contents(h),g.length&&\\\"BR\\\"==g[g.length-1].tagName&&a(g[g.length-1]).remove(),\\\"BLOCKQUOTE\\\"==h.tagName&&\\\"BLOCKQUOTE\\\"!=e.tagName)for(g=b.node.contents(h);g.length&&b.node.isBlock(g[g.length-1]);)h=g[g.length-1],g=b.node.contents(h);else if(\\\"BLOCKQUOTE\\\"!=h.tagName&&\\\"BLOCKQUOTE\\\"==e.tagName)for(g=b.node.contents(e);g.length&&b.node.isBlock(g[0]);)e=g[0],g=b.node.contents(e);a(c).replaceWith(a.FE.MARKERS),a(h).append(b.node.isEmpty(e)?a.FE.MARKERS:e.innerHTML),a(e).remove()}else a(c).replaceWith(a.FE.MARKERS),\\\"BLOCKQUOTE\\\"==e.tagName&&h.nodeType==Node.ELEMENT_NODE?a(h).remove():(a(h).after(b.node.isEmpty(e)?\\\"\\\":a(e).html()),a(e).remove(),\\\"BR\\\"==h.tagName&&a(h).remove())}}function i(c){for(var d=c;!d.previousSibling;)if(d=d.parentNode,b.node.isElement(d))return!1;d=d.previousSibling;var e;if(!b.node.isBlock(d)&&b.node.isEditable(d)){for(e=b.node.contents(d);d.nodeType!=Node.TEXT_NODE&&!b.node.isDeletable(d)&&e.length&&b.node.isEditable(d);)d=e[e.length-1],e=b.node.contents(d);if(d.nodeType==Node.TEXT_NODE){if(b.helpers.isIOS())return!0;var f=d.textContent,g=f.length-1;if(b.opts.tabSpaces&&f.length>=b.opts.tabSpaces){var h=f.substr(f.length-b.opts.tabSpaces,f.length-1);0==h.replace(/ /g,\\\"\\\").replace(new RegExp(a.FE.UNICODE_NBSP,\\\"g\\\"),\\\"\\\").length&&(g=f.length-b.opts.tabSpaces)}d.textContent=f.substring(0,g),d.textContent.length&&55357==d.textContent.charCodeAt(d.textContent.length-1)&&(d.textContent=d.textContent.substr(0,d.textContent.length-1)),0==d.textContent.length?2!=d.parentNode.childNodes.length||d.parentNode!=c.parentNode||b.node.isBlock(d.parentNode)||b.node.isElement(d.parentNode)?(a(d).after(a.FE.MARKERS),b.node.isElement(d.parentNode)&&!c.nextSibling&&d.previousSibling&&\\\"BR\\\"==d.previousSibling.tagName&&a(c).after(\\\"<br>\\\"),d.parentNode.removeChild(d)):(a(d.parentNode).after(a.FE.MARKERS),a(d.parentNode).remove()):a(d).after(a.FE.MARKERS)}else b.node.isDeletable(d)?(a(d).after(a.FE.MARKERS),a(d).remove()):b.events.trigger(\\\"node.remove\\\",[a(d)])!==!1&&(a(d).after(a.FE.MARKERS),a(d).remove())}else if(a.FE.NO_DELETE_TAGS.indexOf(d.tagName)<0&&b.node.isEditable(d))if(b.node.isEmpty(d)&&!b.node.isList(d))a(d).remove(),a(c).replaceWith(a.FE.MARKERS);else{for(b.node.isList(d)&&(d=a(d).find(\\\"li:last\\\").get(0)),e=b.node.contents(d),e&&\\\"BR\\\"==e[e.length-1].tagName&&a(e[e.length-1]).remove(),e=b.node.contents(d);e&&b.node.isBlock(e[e.length-1]);)d=e[e.length-1],e=b.node.contents(d);a(d).append(a.FE.MARKERS);for(var i=c;!i.previousSibling;)i=i.parentNode;for(;i&&\\\"BR\\\"!==i.tagName&&!b.node.isBlock(i);){var j=i;i=i.nextSibling,a(d).append(j)}i&&\\\"BR\\\"==i.tagName&&a(i).remove(),a(c).remove()}else c.nextSibling&&\\\"BR\\\"==c.nextSibling.tagName&&a(c.nextSibling).remove()}function j(){var f=!1,j=b.markers.insert();if(!j)return!0;b.$el.get(0).normalize();var k=j.previousSibling;if(k){var l=k.textContent;l&&l.length&&8203==l.charCodeAt(l.length-1)&&(1==l.length?a(k).remove():(k.textContent=k.textContent.substr(0,l.length-1),k.textContent.length&&55357==k.textContent.charCodeAt(k.textContent.length-1)&&(k.textContent=k.textContent.substr(0,k.textContent.length-1))))}return c(j)?f=i(j):d(j)?g(j)&&e(j,a(j).parents(\\\"li:first\\\").get(0))?b.cursorLists._backspace(j):h(j):f=i(j),a(j).remove(),b.$el.find(\\\"blockquote:empty\\\").remove(),b.html.fillEmptyBlocks(),b.html.cleanEmptyTags(),b.clean.quotes(),b.clean.lists(),b.spaces.normalize(),b.selection.restore(),f}function k(c){var d=a(c).parentsUntil(b.$el,\\\"BLOCKQUOTE\\\").length>0,e=b.node.deepestParent(c,[],!d);if(e&&\\\"BLOCKQUOTE\\\"==e.tagName){var f=b.node.deepestParent(c,[a(c).parentsUntil(b.$el,\\\"BLOCKQUOTE\\\").get(0)]);f&&f.nextSibling&&(e=f)}if(null!==e){var g,h=e.nextSibling;if(b.node.isBlock(e)&&(b.node.isEditable(e)||b.node.isDeletable(e))&&h&&a.FE.NO_DELETE_TAGS.indexOf(h.tagName)<0)if(b.node.isDeletable(h))a(h).remove(),a(c).replaceWith(a.FE.MARKERS);else if(b.node.isBlock(h)&&b.node.isEditable(h))if(b.node.isList(h))if(b.node.isEmpty(e,!0))a(e).remove(),a(h).find(\\\"li:first\\\").prepend(a.FE.MARKERS);else{var i=a(h).find(\\\"li:first\\\");\\\"BLOCKQUOTE\\\"==e.tagName&&(g=b.node.contents(e),g.length&&b.node.isBlock(g[g.length-1])&&(e=g[g.length-1])),0===i.find(\\\"ul, ol\\\").length&&(a(c).replaceWith(a.FE.MARKERS),i.find(b.html.blockTagsQuery()).not(\\\"ol, ul, table\\\").each(function(){this.parentNode==i.get(0)&&a(this).replaceWith(a(this).html()+(b.node.isEmpty(this)?\\\"\\\":\\\"<br>\\\"))}),a(e).append(b.node.contents(i.get(0))),i.remove(),0===a(h).find(\\\"li\\\").length&&a(h).remove())}else{if(g=b.node.contents(h),g.length&&\\\"BR\\\"==g[0].tagName&&a(g[0]).remove(),\\\"BLOCKQUOTE\\\"!=h.tagName&&\\\"BLOCKQUOTE\\\"==e.tagName)for(g=b.node.contents(e);g.length&&b.node.isBlock(g[g.length-1]);)e=g[g.length-1],g=b.node.contents(e);else if(\\\"BLOCKQUOTE\\\"==h.tagName&&\\\"BLOCKQUOTE\\\"!=e.tagName)for(g=b.node.contents(h);g.length&&b.node.isBlock(g[0]);)h=g[0],g=b.node.contents(h);a(c).replaceWith(a.FE.MARKERS),a(e).append(h.innerHTML),a(h).remove()}else{for(a(c).replaceWith(a.FE.MARKERS);h&&\\\"BR\\\"!==h.tagName&&!b.node.isBlock(h)&&b.node.isEditable(h);){var j=h;h=h.nextSibling,a(e).append(j)}h&&\\\"BR\\\"==h.tagName&&b.node.isEditable(h)&&a(h).remove()}}}function l(d){for(var e=d;!e.nextSibling;)if(e=e.parentNode,b.node.isElement(e))return!1;if(e=e.nextSibling,\\\"BR\\\"==e.tagName&&b.node.isEditable(e))if(e.nextSibling){if(b.node.isBlock(e.nextSibling)&&b.node.isEditable(e.nextSibling)){if(!(a.FE.NO_DELETE_TAGS.indexOf(e.nextSibling.tagName)<0))return void a(e).remove();e=e.nextSibling,a(e.previousSibling).remove()}}else if(c(e)){if(g(d))b.cursorLists._del(d);else{var f=b.node.deepestParent(e);f&&(a(e).remove(),k(d))}return}var h;if(!b.node.isBlock(e)&&b.node.isEditable(e)){for(h=b.node.contents(e);e.nodeType!=Node.TEXT_NODE&&h.length&&!b.node.isDeletable(e)&&b.node.isEditable(e);)e=h[0],h=b.node.contents(e);e.nodeType==Node.TEXT_NODE?(a(e).before(a.FE.MARKERS),e.textContent.length&&55357==e.textContent.charCodeAt(0)?e.textContent=e.textContent.substring(2,e.textContent.length):e.textContent=e.textContent.substring(1,e.textContent.length)):b.node.isDeletable(e)?(a(e).before(a.FE.MARKERS),a(e).remove()):b.events.trigger(\\\"node.remove\\\",[a(e)])!==!1&&(a(e).before(a.FE.MARKERS),a(e).remove()),a(d).remove()}else if(a.FE.NO_DELETE_TAGS.indexOf(e.tagName)<0&&(b.node.isEditable(e)||b.node.isDeletable(e)))if(b.node.isDeletable(e))a(d).replaceWith(a.FE.MARKERS),a(e).remove();else if(b.node.isList(e))d.previousSibling?(a(e).find(\\\"li:first\\\").prepend(d),b.cursorLists._backspace(d)):(a(e).find(\\\"li:first\\\").prepend(a.FE.MARKERS),a(d).remove());else if(h=b.node.contents(e),h&&\\\"BR\\\"==h[0].tagName&&a(h[0]).remove(),h&&\\\"BLOCKQUOTE\\\"==e.tagName){var i=h[0];for(a(d).before(a.FE.MARKERS);i&&\\\"BR\\\"!=i.tagName;){var j=i;i=i.nextSibling,a(d).before(j)}i&&\\\"BR\\\"==i.tagName&&a(i).remove()}else a(d).after(a(e).html()).after(a.FE.MARKERS),a(e).remove()}function m(){var e=b.markers.insert();if(!e)return!1;if(b.$el.get(0).normalize(),c(e))if(g(e))if(0===a(e).parents(\\\"li:first\\\").find(\\\"ul, ol\\\").length)b.cursorLists._del(e);else{var f=a(e).parents(\\\"li:first\\\").find(\\\"ul:first, ol:first\\\").find(\\\"li:first\\\");f=f.find(b.html.blockTagsQuery()).get(-1)||f,f.prepend(e),b.cursorLists._backspace(e)}else k(e);else l(d(e)?e:e);a(e).remove(),b.$el.find(\\\"blockquote:empty\\\").remove(),b.html.fillEmptyBlocks(),b.html.cleanEmptyTags(),b.clean.quotes(),b.clean.lists(),b.spaces.normalize(),b.selection.restore()}function n(){b.$el.find(\\\".fr-to-remove\\\").each(function(){for(var c=b.node.contents(this),d=0;d<c.length;d++)c[d].nodeType==Node.TEXT_NODE&&(c[d].textContent=c[d].textContent.replace(/\\\\u200B/g,\\\"\\\"));a(this).replaceWith(this.innerHTML)})}function o(c,d,e){var g,h=b.node.deepestParent(c,[],!e);if(h&&\\\"BLOCKQUOTE\\\"==h.tagName)return f(c,h)?(g=b.html.defaultTag(),\\ng?a(h).after(\\\"<\\\"+g+\\\">\\\"+a.FE.MARKERS+\\\"<br></\\\"+g+\\\">\\\"):a(h).after(a.FE.MARKERS+\\\"<br>\\\"),a(c).remove(),!1):(q(c,d,e),!1);if(null==h)g=b.html.defaultTag(),g&&b.node.isElement(c.parentNode)?a(c).replaceWith(\\\"<\\\"+g+\\\">\\\"+a.FE.MARKERS+\\\"<br></\\\"+g+\\\">\\\"):a(c).replaceWith(\\\"<br/>\\\"+a.FE.MARKERS+\\\"<br/>\\\");else{var i=c,j=\\\"\\\";(!b.node.isBlock(h)||d)&&(j=\\\"<br/>\\\");var k=\\\"\\\",l=\\\"\\\";g=b.html.defaultTag();var m=\\\"\\\",n=\\\"\\\";g&&b.node.isBlock(h)&&(m=\\\"<\\\"+g+\\\">\\\",n=\\\"</\\\"+g+\\\">\\\",h.tagName==g.toUpperCase()&&(m=b.node.openTagString(a(h).clone().removeAttr(\\\"id\\\").get(0))));do if(i=i.parentNode,!d||i!=h||d&&!b.node.isBlock(h))if(k+=b.node.closeTagString(i),i==h&&b.node.isBlock(h))l=m+l;else{var o=\\\"A\\\"==i.tagName&&f(c,i)?\\\"fr-to-remove\\\":\\\"\\\";l=b.node.openTagString(a(i).clone().addClass(o).get(0))+l}while(i!=h);j=k+j+l+(c.parentNode==h&&b.node.isBlock(h)?\\\"\\\":a.FE.INVISIBLE_SPACE)+a.FE.MARKERS,b.node.isBlock(h)&&!a(h).find(\\\"*:last\\\").is(\\\"br\\\")&&a(h).append(\\\"<br/>\\\"),a(c).after('<span id=\\\"fr-break\\\"></span>'),a(c).remove(),h.nextSibling&&!b.node.isBlock(h.nextSibling)||b.node.isBlock(h)||a(h).after(\\\"<br>\\\");var p;p=!d&&b.node.isBlock(h)?b.node.openTagString(h)+a(h).html()+n:b.node.openTagString(h)+a(h).html()+b.node.closeTagString(h),p=p.replace(/<span id=\\\"fr-break\\\"><\\\\/span>/g,j),a(h).replaceWith(p)}}function p(c,d,g){var h,i=b.node.deepestParent(c,[],!g);if(i&&\\\"BLOCKQUOTE\\\"==i.tagName){if(e(c,i))return h=b.html.defaultTag(),h?a(i).before(\\\"<\\\"+h+\\\">\\\"+a.FE.MARKERS+\\\"<br></\\\"+h+\\\">\\\"):a(i).before(a.FE.MARKERS+\\\"<br>\\\"),a(c).remove(),!1;f(c,i)?o(c,d,!0):q(c,d,!0)}if(null==i)h=b.html.defaultTag(),h&&b.node.isElement(c.parentNode)?a(c).replaceWith(\\\"<\\\"+h+\\\">\\\"+a.FE.MARKERS+\\\"<br></\\\"+h+\\\">\\\"):a(c).replaceWith(\\\"<br>\\\"+a.FE.MARKERS);else{if(b.node.isBlock(i))if(d)a(c).remove(),a(i).prepend(\\\"<br>\\\"+a.FE.MARKERS);else{if(b.node.isEmpty(i,!0))return o(c,d,g);a(i).before(b.node.openTagString(a(i).clone().removeAttr(\\\"id\\\").get(0))+\\\"<br>\\\"+b.node.closeTagString(i))}else a(i).before(\\\"<br>\\\");a(c).remove()}}function q(c,d,g){var h=b.node.deepestParent(c,[],!g);if(null==h)b.html.defaultTag()&&c.parentNode===b.$el.get(0)?a(c).replaceWith(\\\"<\\\"+b.html.defaultTag()+\\\">\\\"+a.FE.MARKERS+\\\"<br></\\\"+b.html.defaultTag()+\\\">\\\"):((!c.nextSibling||b.node.isBlock(c.nextSibling))&&a(c).after(\\\"<br>\\\"),a(c).replaceWith(\\\"<br>\\\"+a.FE.MARKERS));else{var i=c,j=\\\"\\\";\\\"PRE\\\"==h.tagName&&(d=!0),(!b.node.isBlock(h)||d)&&(j=\\\"<br>\\\");var k=\\\"\\\",l=\\\"\\\";do{var m=i;if(i=i.parentNode,\\\"BLOCKQUOTE\\\"==h.tagName&&b.node.isEmpty(m)&&!a(m).hasClass(\\\"fr-marker\\\")&&a(m).find(c).length>0&&a(m).after(c),(\\\"BLOCKQUOTE\\\"!=h.tagName||!f(c,i)&&!e(c,i))&&(!d||i!=h||d&&!b.node.isBlock(h))){k+=b.node.closeTagString(i);var n=\\\"A\\\"==i.tagName&&f(c,i)?\\\"fr-to-remove\\\":\\\"\\\";l=b.node.openTagString(a(i).clone().addClass(n).removeAttr(\\\"id\\\").get(0))+l}}while(i!=h);var o=h==c.parentNode&&b.node.isBlock(h)||c.nextSibling;if(\\\"BLOCKQUOTE\\\"==h.tagName){c.previousSibling&&b.node.isBlock(c.previousSibling)&&c.nextSibling&&\\\"BR\\\"==c.nextSibling.tagName&&(a(c.nextSibling).after(c),c.nextSibling&&\\\"BR\\\"==c.nextSibling.tagName&&a(c.nextSibling).remove());var p=b.html.defaultTag();j=k+j+(p?\\\"<\\\"+p+\\\">\\\":\\\"\\\")+a.FE.MARKERS+\\\"<br>\\\"+(p?\\\"</\\\"+p+\\\">\\\":\\\"\\\")+l}else j=k+j+l+(o?\\\"\\\":a.FE.INVISIBLE_SPACE)+a.FE.MARKERS;a(c).replaceWith('<span id=\\\"fr-break\\\"></span>');var q=b.node.openTagString(h)+a(h).html()+b.node.closeTagString(h);q=q.replace(/<span id=\\\"fr-break\\\"><\\\\/span>/g,j),a(h).replaceWith(q)}}function r(e){var f=b.markers.insert();if(!f)return!0;b.$el.get(0).normalize();var h=!1;a(f).parentsUntil(b.$el,\\\"BLOCKQUOTE\\\").length>0&&(e=!1,h=!0),a(f).parentsUntil(b.$el,\\\"TD, TH\\\").length&&(h=!1),c(f)?!g(f)||e||h?o(f,e,h):b.cursorLists._endEnter(f):d(f)?!g(f)||e||h?p(f,e,h):b.cursorLists._startEnter(f):!g(f)||e||h?q(f,e,h):b.cursorLists._middleEnter(f),n(),b.html.fillEmptyBlocks(),b.html.cleanEmptyTags(),b.clean.lists(),b.spaces.normalize(),b.selection.restore()}return{enter:r,backspace:j,del:m,isAtEnd:f}},a.FE.MODULES.data=function(a){function b(a){return a}function c(a){if(!a)return a;for(var c=\\\"\\\",f=b(\\\"charCodeAt\\\"),g=b(\\\"fromCharCode\\\"),h=l.indexOf(a[0]),i=1;i<a.length-2;i++){for(var j=d(++h),k=a[f](i),m=\\\"\\\";/[0-9-]/.test(a[i+1]);)m+=a[++i];m=parseInt(m,10)||0,k=e(k,j,m),k^=h-1&31,c+=String[g](k)}return c}function d(a){for(var b=a.toString(),c=0,d=0;d<b.length;d++)c+=parseInt(b.charAt(d),10);return c>10?c%9+1:c}function e(a,b,c){for(var d=Math.abs(c);d-- >0;)a-=b;return 0>c&&(a+=123),a}function f(a){return a&&\\\"none\\\"==a.css(\\\"display\\\")?(a.remove(),!0):!1}function g(){return f(j)||f(k)}function h(){return a.$box?(a.$box.append(n(b(n(\\\"kTDD4spmKD1klaMB1C7A5RA1G3RA10YA5qhrjuvnmE1D3FD2bcG-7noHE6B2JB4C3xXA8WF6F-10RG2C3G3B-21zZE3C3H3xCA16NC4DC1f1hOF1MB3B-21whzQH5UA2WB10kc1C2F4D3XC2YD4D1C4F3GF2eJ2lfcD-13HF1IE1TC11TC7WE4TA4d1A2YA6XA4d1A3yCG2qmB-13GF4A1B1KH1HD2fzfbeQC3TD9VE4wd1H2A20A2B-22ujB3nBG2A13jBC10D3C2HD5D1H1KB11uD-16uWF2D4A3F-7C9D-17c1E4D4B3d1D2CA6B2B-13qlwzJF2NC2C-13E-11ND1A3xqUA8UE6bsrrF-7C-22ia1D2CF2H1E2akCD2OE1HH1dlKA6PA5jcyfzB-22cXB4f1C3qvdiC4gjGG2H2gklC3D-16wJC1UG4dgaWE2D5G4g1I2H3B7vkqrxH1H2EC9C3E4gdgzKF1OA1A5PF5C4WWC3VA6XA4e1E3YA2YA5HE4oGH4F2H2IB10D3D2NC5G1B1qWA9PD6PG5fQA13A10XA4C4A3e1H2BA17kC-22cmOB1lmoA2fyhcptwWA3RA8A-13xB-11nf1I3f1B7GB3aD3pavFC10D5gLF2OG1LSB2D9E7fQC1F4F3wpSB5XD3NkklhhaE-11naKA9BnIA6D1F5bQA3A10c1QC6Kjkvitc2B6BE3AF3E2DA6A4JD2IC1jgA-64MB11D6C4==\\\")))),j=a.$box.find(\\\"> div:last\\\"),k=j.find(\\\"> a\\\"),void(\\\"rtl\\\"==a.opts.direction&&j.css(\\\"left\\\",\\\"auto\\\").css(\\\"right\\\",0))):!1}function i(){var c=a.opts.key||[\\\"\\\"];\\\"string\\\"==typeof c&&(c=[c]),a.ul=!0;for(var d=0;d<c.length;d++){var e=n(c[d])||\\\"\\\";if(!(e!==n(b(n(\\\"mcVRDoB1BGILD7YFe1BTXBA7B6==\\\")))&&e.indexOf(m,e.length-m.length)<0&&[n(\\\"9qqG-7amjlwq==\\\"),n(\\\"KA3B3C2A6D1D5H5H1A3==\\\"),n(\\\"QzbzvxyB2yA-9m==\\\")].indexOf(m)<0)){a.ul=!1;break}}a.ul===!0&&h(),a.events.on(\\\"contentChanged\\\",function(){a.ul===!0&&g()&&h()}),a.events.on(\\\"destroy\\\",function(){j&&j.length&&j.remove()},!0)}var j,k,l=\\\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\\\",m=function(){for(var a=0,b=document.domain,c=b.split(\\\".\\\"),d=\\\"_gd\\\"+(new Date).getTime();a<c.length-1&&-1==document.cookie.indexOf(d+\\\"=\\\"+d);)b=c.slice(-1-++a).join(\\\".\\\"),document.cookie=d+\\\"=\\\"+d+\\\";domain=\\\"+b+\\\";\\\";return document.cookie=d+\\\"=;expires=Thu, 01 Jan 1970 00:00:01 GMT;domain=\\\"+b+\\\";\\\",b}(),n=b(c);return{_init:i}},a.FE.ENTER_P=0,a.FE.ENTER_DIV=1,a.FE.ENTER_BR=2,a.FE.KEYCODE={BACKSPACE:8,TAB:9,ENTER:13,SHIFT:16,CTRL:17,ALT:18,ESC:27,SPACE:32,DELETE:46,ZERO:48,ONE:49,TWO:50,THREE:51,FOUR:52,FIVE:53,SIX:54,SEVEN:55,EIGHT:56,NINE:57,FF_SEMICOLON:59,FF_EQUALS:61,QUESTION_MARK:63,A:65,B:66,C:67,D:68,E:69,F:70,G:71,H:72,I:73,J:74,K:75,L:76,M:77,N:78,O:79,P:80,Q:81,R:82,S:83,T:84,U:85,V:86,W:87,X:88,Y:89,Z:90,META:91,NUM_ZERO:96,NUM_ONE:97,NUM_TWO:98,NUM_THREE:99,NUM_FOUR:100,NUM_FIVE:101,NUM_SIX:102,NUM_SEVEN:103,NUM_EIGHT:104,NUM_NINE:105,NUM_MULTIPLY:106,NUM_PLUS:107,NUM_MINUS:109,NUM_PERIOD:110,NUM_DIVISION:111,SEMICOLON:186,DASH:189,EQUALS:187,COMMA:188,PERIOD:190,SLASH:191,APOSTROPHE:192,TILDE:192,SINGLE_QUOTE:222,OPEN_SQUARE_BRACKET:219,BACKSLASH:220,CLOSE_SQUARE_BRACKET:221},a.extend(a.FE.DEFAULTS,{enter:a.FE.ENTER_P,multiLine:!0,tabSpaces:0}),a.FE.MODULES.keys=function(b){function c(){if(b.helpers.isIOS()){var c=navigator.userAgent.match(\\\"CriOS\\\"),d=/(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(navigator.userAgent);if(!c&&!d){var e=a(b.o_win).scrollTop();b.events.disableBlur(),b.selection.save(),b.$el.blur(),b.selection.restore(),b.events.enableBlur(),a(b.o_win).scrollTop(e)}}}function d(a){a.preventDefault(),a.stopPropagation(),b.opts.multiLine&&(b.selection.isCollapsed()||b.selection.remove(),b.cursor.enter()),c()}function e(a){a.preventDefault(),a.stopPropagation(),b.opts.multiLine&&(b.selection.isCollapsed()||b.selection.remove(),b.cursor.enter(!0))}function f(a){b.selection.isCollapsed()?b.cursor.backspace()||(a.preventDefault(),a.stopPropagation(),x=!1):(a.preventDefault(),a.stopPropagation(),b.selection.remove(),b.html.fillEmptyBlocks(),x=!1),b.placeholder.refresh()}function g(a){a.preventDefault(),a.stopPropagation(),\\\"\\\"===b.selection.text()?b.cursor.del():b.selection.remove(),b.placeholder.refresh()}function h(c){if(b.browser.mozilla){c.preventDefault(),c.stopPropagation(),b.selection.isCollapsed()||b.selection.remove(),b.markers.insert();var d=b.$el.find(\\\".fr-marker\\\").get(0),e=d.previousSibling,f=d.nextSibling;!f&&d.parentNode&&\\\"A\\\"==d.parentNode.tagName?(a(d).parent().after(\\\"&nbsp;\\\"+a.FE.MARKERS),a(d).remove()):(e&&e.nodeType==Node.TEXT_NODE&&1==e.textContent.length&&160==e.textContent.charCodeAt(0)?a(e).after(\\\" \\\"):a(d).before(\\\"&nbsp;\\\"),a(d).replaceWith(a.FE.MARKERS)),b.selection.restore()}}function i(){if(b.browser.mozilla&&b.selection.isCollapsed()&&!A){var a=b.selection.ranges(0),c=a.startContainer,d=a.startOffset;c&&c.nodeType==Node.TEXT_NODE&&d<=c.textContent.length&&d>0&&32==c.textContent.charCodeAt(d-1)&&(b.selection.save(),b.spaces.normalize(),b.selection.restore())}}function j(){b.selection.isFull()&&setTimeout(function(){var c=b.html.defaultTag();c?b.$el.html(\\\"<\\\"+c+\\\">\\\"+a.FE.MARKERS+\\\"<br/></\\\"+c+\\\">\\\"):b.$el.html(a.FE.MARKERS+\\\"<br/>\\\"),b.selection.restore(),b.placeholder.refresh(),b.button.bulkRefresh(),b.undo.saveStep()},0)}function k(a){if(b.opts.tabSpaces>0)if(b.selection.isCollapsed()){b.undo.saveStep(),a.preventDefault(),a.stopPropagation();for(var c=\\\"\\\",d=0;d<b.opts.tabSpaces;d++)c+=\\\"&nbsp;\\\";b.html.insert(c),b.placeholder.refresh(),b.undo.saveStep()}else a.preventDefault(),a.stopPropagation(),a.shiftKey?b.commands.outdent():b.commands.indent()}function l(a){A=!1}function m(){return A}function n(c){b.events.disableBlur(),x=!0;var i=c.which;if(16===i)return!0;if(229===i)return A=!0,!0;A=!1;var j=s(i)&&!r(c),l=i==a.FE.KEYCODE.BACKSPACE||i==a.FE.KEYCODE.DELETE;if((b.selection.isFull()&&!b.opts.keepFormatOnDelete&&!b.placeholder.isVisible()||l&&b.placeholder.isVisible()&&b.opts.keepFormatOnDelete)&&(j||l)){var m=b.html.defaultTag();if(m?b.$el.html(\\\"<\\\"+m+\\\">\\\"+a.FE.MARKERS+\\\"<br/></\\\"+m+\\\">\\\"):b.$el.html(a.FE.MARKERS+\\\"<br/>\\\"),b.selection.restore(),!s(i))return c.preventDefault(),!0}i==a.FE.KEYCODE.ENTER?c.shiftKey?e(c):d(c):i!=a.FE.KEYCODE.BACKSPACE||r(c)||c.altKey||b.placeholder.isVisible()?i!=a.FE.KEYCODE.DELETE||r(c)||c.altKey||b.placeholder.isVisible()?i==a.FE.KEYCODE.SPACE?h(c):i==a.FE.KEYCODE.TAB?k(c):r(c)||!s(c.which)||b.selection.isCollapsed()||c.ctrlKey||b.selection.remove():g(c):f(c),b.events.enableBlur()}function o(c){for(var d=0;d<c.length;d++)c[d].nodeType==Node.TEXT_NODE&&/\\\\u200B/gi.test(c[d].textContent)?(c[d].textContent=c[d].textContent.replace(/\\\\u200B/gi,\\\"\\\"),0===c[d].textContent.length&&a(c[d]).remove()):c[d].nodeType==Node.ELEMENT_NODE&&\\\"IFRAME\\\"!=c[d].nodeType&&o(b.node.contents(c[d]))}function p(){if(!b.$wp)return!0;var c;b.opts.height||b.opts.heightMax?(c=b.position.getBoundingRect().top,b.helpers.isIOS()&&(c-=a(b.o_win).scrollTop()),b.opts.iframe&&(c+=b.$iframe.offset().top),c>b.$wp.offset().top-a(b.o_win).scrollTop()+b.$wp.height()-20&&b.$wp.scrollTop(c+b.$wp.scrollTop()-(b.$wp.height()+b.$wp.offset().top)+a(b.o_win).scrollTop()+20)):(c=b.position.getBoundingRect().top,b.opts.toolbarBottom&&(c+=b.opts.toolbarStickyOffset),b.helpers.isIOS()&&(c-=a(b.o_win).scrollTop()),b.opts.iframe&&(c+=b.$iframe.offset().top),c+=b.opts.toolbarStickyOffset,c>b.o_win.innerHeight-20&&a(b.o_win).scrollTop(c+a(b.o_win).scrollTop()-b.o_win.innerHeight+20),c=b.position.getBoundingRect().top,b.opts.toolbarBottom||(c-=b.opts.toolbarStickyOffset),b.helpers.isIOS()&&(c-=a(b.o_win).scrollTop()),b.opts.iframe&&(c+=b.$iframe.offset().top),c<b.$tb.height()+20&&a(b.o_win).scrollTop(c+a(b.o_win).scrollTop()-b.$tb.height()-20))}function q(c){if(A)return!1;if(!b.selection.isCollapsed())return!0;if(c&&(c.which===a.FE.KEYCODE.META||c.which==a.FE.KEYCODE.CTRL))return!0;c&&(c.which==a.FE.KEYCODE.ENTER||c.which==a.FE.KEYCODE.BACKSPACE||c.which>=37&&c.which<=40&&!b.browser.msie)&&(c.which==a.FE.KEYCODE.BACKSPACE&&x||p());var d=b.$el.find(b.html.blockTagsQuery());d.push(b.$el.get(0));for(var e=[],f=0;f<d.length;f++)if([\\\"TD\\\",\\\"TH\\\"].indexOf(d[f].tagName)<0)for(var g=d[f].children,h=0;h<g.length;h++)\\\"BR\\\"==g[h].tagName&&e.push(g[h]);for(var d=[],f=0;f<e.length;f++){var i=e[f],j=i.previousSibling,k=i.nextSibling,l=b.node.blockParent(i)||b.$el.get(0);j&&l&&\\\"BR\\\"!=j.tagName&&!b.node.isBlock(j)&&!k&&a(l).text().replace(/\\\\u200B/g,\\\"\\\").length>0&&a(j).text().length>0&&(b.$el.is(l)&&!k&&b.opts.enter==a.FE.ENTER_BR&&b.browser.msie||(b.selection.save(),a(i).remove(),b.selection.restore()))}e=[];var m=function(b){if(!b)return!1;var c=a(b).html();return c=c.replace(/<span[^>]*? class\\\\s*=\\\\s*[\\\"']?fr-marker[\\\"']?[^>]+>\\\\u200b<\\\\/span>/gi,\\\"\\\"),c&&/\\\\u200B/.test(c)&&c.replace(/\\\\u200B/gi,\\\"\\\").length>0?!0:!1},n=function(a){var c=/[\\\\u3041-\\\\u3096\\\\u30A0-\\\\u30FF\\\\u4E00-\\\\u9FFF\\\\u3130-\\\\u318F\\\\uAC00-\\\\uD7AF]/gi;return!b.helpers.isIOS()||0===((a.textContent||\\\"\\\").match(c)||[]).length},q=b.selection.element();m(q)&&0===a(q).find(\\\"li\\\").length&&!a(q).hasClass(\\\"fr-marker\\\")&&\\\"IFRAME\\\"!=q.tagName&&n(q)&&(b.selection.save(),o(b.node.contents(q)),b.selection.restore()),!b.browser.mozilla&&b.html.doNormalize()&&(b.selection.save(),b.spaces.normalize(),b.selection.restore())}function r(a){if(-1!=navigator.userAgent.indexOf(\\\"Mac OS X\\\")){if(a.metaKey&&!a.altKey)return!0}else if(a.ctrlKey&&!a.altKey)return!0;return!1}function s(c){if(c>=a.FE.KEYCODE.ZERO&&c<=a.FE.KEYCODE.NINE)return!0;if(c>=a.FE.KEYCODE.NUM_ZERO&&c<=a.FE.KEYCODE.NUM_MULTIPLY)return!0;if(c>=a.FE.KEYCODE.A&&c<=a.FE.KEYCODE.Z)return!0;if(b.browser.webkit&&0===c)return!0;switch(c){case a.FE.KEYCODE.SPACE:case a.FE.KEYCODE.QUESTION_MARK:case a.FE.KEYCODE.NUM_PLUS:case a.FE.KEYCODE.NUM_MINUS:case a.FE.KEYCODE.NUM_PERIOD:case a.FE.KEYCODE.NUM_DIVISION:case a.FE.KEYCODE.SEMICOLON:case a.FE.KEYCODE.FF_SEMICOLON:case a.FE.KEYCODE.DASH:case a.FE.KEYCODE.EQUALS:case a.FE.KEYCODE.FF_EQUALS:case a.FE.KEYCODE.COMMA:case a.FE.KEYCODE.PERIOD:case a.FE.KEYCODE.SLASH:case a.FE.KEYCODE.APOSTROPHE:case a.FE.KEYCODE.SINGLE_QUOTE:case a.FE.KEYCODE.OPEN_SQUARE_BRACKET:case a.FE.KEYCODE.BACKSLASH:case a.FE.KEYCODE.CLOSE_SQUARE_BRACKET:return!0;default:return!1}}function t(c){var d=c.which;return r(c)||d>=37&&40>=d||!s(d)&&d!=a.FE.KEYCODE.DELETE&&d!=a.FE.KEYCODE.BACKSPACE&&d!=a.FE.KEYCODE.ENTER?!0:(y||(z=b.snapshot.get()),clearTimeout(y),void(y=setTimeout(function(){y=null,b.undo.saveStep()},Math.max(250,b.opts.typingTimer))))}function u(a){return r(a)?!0:void(z&&y&&(b.undo.saveStep(z),z=null))}function v(){y&&(clearTimeout(y),b.undo.saveStep(),z=null)}function w(){if(b.events.on(\\\"keydown\\\",t),b.events.on(\\\"input\\\",i),b.events.on(\\\"keyup\\\",u),b.events.on(\\\"keypress\\\",l),b.events.on(\\\"keydown\\\",n),b.events.on(\\\"keyup\\\",q),b.events.on(\\\"html.inserted\\\",q),b.events.on(\\\"cut\\\",j),b.$el.get(0).msGetInputContext)try{b.$el.get(0).msGetInputContext().addEventListener(\\\"MSCandidateWindowShow\\\",function(){A=!0}),b.$el.get(0).msGetInputContext().addEventListener(\\\"MSCandidateWindowHide\\\",function(){A=!1,q()})}catch(a){}}var x,y,z,A=!1;return{_init:w,ctrlKey:r,isCharacter:s,forceUndo:v,isIME:m}},a.extend(a.FE.DEFAULTS,{pastePlain:!1,pasteDeniedTags:[\\\"colgroup\\\",\\\"col\\\"],pasteDeniedAttrs:[\\\"class\\\",\\\"id\\\",\\\"style\\\"],pasteAllowLocalImages:!1}),a.FE.MODULES.paste=function(b){function c(c){a.FE.copied_html=b.html.getSelected(),a.FE.copied_text=a(\\\"<div>\\\").html(a.FE.copied_html).text(),\\\"cut\\\"==c.type&&(b.undo.saveStep(),setTimeout(function(){b.html.wrap(),b.events.focus(),b.undo.saveStep()},0))}function d(a){if(o)return!1;if(a.originalEvent&&(a=a.originalEvent),b.events.trigger(\\\"paste.before\\\",[a])===!1)return!1;if(l=b.$win.scrollTop(),a&&a.clipboardData&&a.clipboardData.getData){var c=\\\"\\\",d=a.clipboardData.types;if(b.helpers.isArray(d))for(var f=0;f<d.length;f++)c+=d[f]+\\\";\\\";else c=d;if(m=\\\"\\\",/text\\\\/html/.test(c)?m=a.clipboardData.getData(\\\"text/html\\\"):/text\\\\/rtf/.test(c)&&b.browser.safari?m=a.clipboardData.getData(\\\"text/rtf\\\"):/text\\\\/plain/.test(c)&&!this.browser.mozilla&&(m=b.html.escapeEntities(a.clipboardData.getData(\\\"text/plain\\\")).replace(/\\\\n/g,\\\"<br>\\\")),\\\"\\\"!==m)return h(),a.preventDefault&&(a.stopPropagation(),a.preventDefault()),!1;m=null}e()}function e(){b.selection.save(),b.events.disableBlur(),m=null,n?n.html(\\\"\\\"):(n=a('<div contenteditable=\\\"true\\\" style=\\\"position: fixed; top: 0; left: -9999px; height: 100%; width: 0; word-break: break-all; overflow:hidden; z-index: 9999; line-height: 140%;\\\" tabindex=\\\"-1\\\"></div>'),b.$box.after(n),b.events.on(\\\"destroy\\\",function(){n.remove()})),n.focus(),b.win.setTimeout(h,1)}function f(c){c=c.replace(/<p(.*?)class=\\\"?'?MsoListParagraph\\\"?'? ([\\\\s\\\\S]*?)>([\\\\s\\\\S]*?)<\\\\/p>/gi,\\\"<ul><li>$3</li></ul>\\\"),c=c.replace(/<p(.*?)class=\\\"?'?NumberedText\\\"?'? ([\\\\s\\\\S]*?)>([\\\\s\\\\S]*?)<\\\\/p>/gi,\\\"<ol><li>$3</li></ol>\\\"),c=c.replace(/<p(.*?)class=\\\"?'?MsoListParagraphCxSpFirst\\\"?'?([\\\\s\\\\S]*?)(level\\\\d)?([\\\\s\\\\S]*?)>([\\\\s\\\\S]*?)<\\\\/p>/gi,\\\"<ul><li$3>$5</li>\\\"),c=c.replace(/<p(.*?)class=\\\"?'?NumberedTextCxSpFirst\\\"?'?([\\\\s\\\\S]*?)(level\\\\d)?([\\\\s\\\\S]*?)>([\\\\s\\\\S]*?)<\\\\/p>/gi,\\\"<ol><li$3>$5</li>\\\"),c=c.replace(/<p(.*?)class=\\\"?'?MsoListParagraphCxSpMiddle\\\"?'?([\\\\s\\\\S]*?)(level\\\\d)?([\\\\s\\\\S]*?)>([\\\\s\\\\S]*?)<\\\\/p>/gi,\\\"<li$3>$5</li>\\\"),c=c.replace(/<p(.*?)class=\\\"?'?NumberedTextCxSpMiddle\\\"?'?([\\\\s\\\\S]*?)(level\\\\d)?([\\\\s\\\\S]*?)>([\\\\s\\\\S]*?)<\\\\/p>/gi,\\\"<li$3>$5</li>\\\"),c=c.replace(/<p(.*?)class=\\\"?'?MsoListBullet\\\"?'?([\\\\s\\\\S]*?)(level\\\\d)?([\\\\s\\\\S]*?)>([\\\\s\\\\S]*?)<\\\\/p>/gi,\\\"<li$3>$5</li>\\\"),c=c.replace(/<p(.*?)class=\\\"?'?MsoListParagraphCxSpLast\\\"?'?([\\\\s\\\\S]*?)(level\\\\d)?([\\\\s\\\\S]*?)>([\\\\s\\\\S]*?)<\\\\/p>/gi,\\\"<li$3>$5</li></ul>\\\"),c=c.replace(/<p(.*?)class=\\\"?'?NumberedTextCxSpLast\\\"?'?([\\\\s\\\\S]*?)(level\\\\d)?([\\\\s\\\\S]*?)>([\\\\s\\\\S]*?)<\\\\/p>/gi,\\\"<li$3>$5</li></ol>\\\"),c=c.replace(/<span([^<]*?)style=\\\"?'?mso-list:Ignore\\\"?'?([\\\\s\\\\S]*?)>([\\\\s\\\\S]*?)<span/gi,\\\"<span><span\\\"),c=c.replace(/<!--\\\\[if \\\\!supportLists\\\\]-->([\\\\s\\\\S]*?)<!--\\\\[endif\\\\]-->/gi,\\\"\\\"),c=c.replace(/<!\\\\[if \\\\!supportLists\\\\]>([\\\\s\\\\S]*?)<!\\\\[endif\\\\]>/gi,\\\"\\\"),c=c.replace(/(\\\\n|\\\\r| class=(\\\")?Mso[a-zA-Z0-9]+(\\\")?)/gi,\\\" \\\"),c=c.replace(/<!--[\\\\s\\\\S]*?-->/gi,\\\"\\\"),c=c.replace(/<(\\\\/)*(meta|link|span|\\\\\\\\?xml:|st1:|o:|font)(.*?)>/gi,\\\"\\\");for(var d=[\\\"style\\\",\\\"script\\\",\\\"applet\\\",\\\"embed\\\",\\\"noframes\\\",\\\"noscript\\\"],e=0;e<d.length;e++){var f=new RegExp(\\\"<\\\"+d[e]+\\\".*?\\\"+d[e]+\\\"(.*?)>\\\",\\\"gi\\\");c=c.replace(f,\\\"\\\")}c=c.replace(/&nbsp;/gi,\\\" \\\"),c=c.replace(/<td([^>]*)><\\\\/td>/g,\\\"<td$1><br></td>\\\"),c=c.replace(/<th([^>]*)><\\\\/th>/g,\\\"<th$1><br></th>\\\");var g;do g=c,c=c.replace(/<[^\\\\/>][^>]*><\\\\/[^>]+>/gi,\\\"\\\");while(c!=g);c=c.replace(/<lilevel([^1])([^>]*)>/gi,'<li data-indent=\\\"true\\\"$2>'),c=c.replace(/<lilevel1([^>]*)>/gi,\\\"<li$1>\\\"),c=b.clean.html(c,b.opts.pasteDeniedTags,b.opts.pasteDeniedAttrs),c=c.replace(/<a>(.[^<]+)<\\\\/a>/gi,\\\"$1\\\"),c=c.replace(/<br> */g,\\\"<br>\\\");var h=a(\\\"<div>\\\").html(c);return h.find(\\\"li[data-indent]\\\").each(function(b,c){var d=a(c);if(d.prev(\\\"li\\\").length>0){var e=d.prev(\\\"li\\\").find(\\\"> ul, > ol\\\");0===e.length&&(e=a(\\\"ul\\\"),d.prev(\\\"li\\\").append(e)),e.append(c)}else d.removeAttr(\\\"data-indent\\\")}),b.html.cleanBlankSpaces(h.get(0)),c=h.html()}function g(c){var d=a(\\\"<div>\\\").html(c);d.find(\\\"p, div, h1, h2, h3, h4, h5, h6, pre, blockquote\\\").each(function(c,d){a(d).replaceWith(\\\"<\\\"+(b.html.defaultTag()||\\\"DIV\\\")+\\\">\\\"+a(d).html()+\\\"</\\\"+(b.html.defaultTag()||\\\"DIV\\\")+\\\">\\\")}),a(d.find(\\\"*\\\").not(\\\"p, div, h1, h2, h3, h4, h5, h6, pre, blockquote, ul, ol, li, table, tbody, thead, tr, td, br, img\\\").get().reverse()).each(function(){a(this).replaceWith(a(this).html())});var e=function(c){for(var d=b.node.contents(c),f=0;f<d.length;f++)3!=d[f].nodeType&&1!=d[f].nodeType?a(d[f]).remove():e(d[f])};return e(d.get(0)),d.html()}function h(){b.keys.forceUndo();var c=b.snapshot.get();null===m&&(m=n.html(),b.selection.restore(),b.events.enableBlur());var d=b.events.chainTrigger(\\\"paste.beforeCleanup\\\",m);\\\"string\\\"==typeof d&&(m=d),m.indexOf(\\\"<body\\\")>=0&&(m=m.replace(/[.\\\\s\\\\S\\\\w\\\\W<>]*<body[^>]*>([.\\\\s\\\\S\\\\w\\\\W<>]*)<\\\\/body>[.\\\\s\\\\S\\\\w\\\\W<>]*/g,\\\"$1\\\"));var e=!1;if(m.indexOf('id=\\\"docs-internal-guid')>=0&&(m=m.replace(/^.* id=\\\"docs-internal-guid[^>]*>(.*)<\\\\/b>.*$/,\\\"$1\\\"),e=!0),m.match(/(class=\\\\\\\"?Mso|class=\\\\'?Mso|style=\\\\\\\"[^\\\\\\\"]*\\\\bmso\\\\-|style=\\\\'[^\\\\']*\\\\bmso\\\\-|w:WordDocument)/gi)?(m=m.replace(/^\\\\n*/g,\\\"\\\").replace(/^ /g,\\\"\\\"),0===m.indexOf(\\\"<colgroup>\\\")&&(m=\\\"<table>\\\"+m+\\\"</table>\\\"),m=f(m),m=j(m)):(b.opts.htmlAllowComments=!1,m=b.clean.html(m,b.opts.pasteDeniedTags,b.opts.pasteDeniedAttrs),b.opts.htmlAllowComments=!0,m=j(m),m=m.replace(/\\\\r|\\\\n|\\\\t/g,\\\"\\\"),a.FE.copied_text&&a(\\\"<div>\\\").html(m).text().replace(/(\\\\u00A0)/gi,\\\" \\\").replace(/\\\\r|\\\\n/gi,\\\"\\\")==a.FE.copied_text.replace(/(\\\\u00A0)/gi,\\\" \\\").replace(/\\\\r|\\\\n/gi,\\\"\\\")&&(m=a.FE.copied_html),m=m.replace(/^ */g,\\\"\\\").replace(/ *$/g,\\\"\\\")),b.opts.pastePlain&&(m=g(m)),d=b.events.chainTrigger(\\\"paste.afterCleanup\\\",m),\\\"string\\\"==typeof d&&(m=d),\\\"\\\"!==m){var h=a(\\\"<div>\\\").html(m);b.spaces.normalize(h.get(0)),h.find(\\\"span\\\").each(function(){0==this.attributes.length&&a(this).replaceWith(this.innerHTML)}),e||h.find(\\\"br\\\").each(function(){this.previousSibling&&b.node.isBlock(this.previousSibling)&&a(this).remove()}),m=h.html(),b.html.insert(m,!0)}i(),b.undo.saveStep(c),b.undo.saveStep()}function i(){b.events.trigger(\\\"paste.after\\\")}function j(c){for(var d,e=a(\\\"<div>\\\").html(c),f=e.find(\\\"*:empty:not(br, img, td, th)\\\");f.length;){for(d=0;d<f.length;d++)a(f[d]).remove();f=e.find(\\\"*:empty:not(br, img, td, th)\\\")}for(var g=e.find(\\\"> div:not([style]), td > div, th > div, li > div\\\");g.length&&d++<100;){var h=a(g[g.length-1]);b.html.defaultTag()&&\\\"div\\\"!=b.html.defaultTag()?h.replaceWith(\\\"<\\\"+b.html.defaultTag()+\\\">\\\"+h.html()+\\\"</\\\"+b.html.defaultTag()+\\\">\\\"):h.find(\\\"*:last\\\").is(\\\"br\\\")?h.replaceWith(h.html()):h.replaceWith(h.html()+\\\"<br>\\\"),g=e.find(\\\"> div:not([style]), td > div, th > div, li > div\\\")}for(g=e.find(\\\"div:not([style])\\\");g.length;){for(d=0;d<g.length;d++){var i=a(g[d]),j=i.html().replace(/\\\\u0009/gi,\\\"\\\").trim();i.replaceWith(j)}g=e.find(\\\"div:not([style])\\\")}return e.html()}function k(){b.events.on(\\\"copy\\\",c),b.events.on(\\\"cut\\\",c),b.events.on(\\\"paste\\\",d),b.browser.msie&&b.browser.version<11&&(b.events.on(\\\"mouseup\\\",function(a){2==a.button&&(setTimeout(function(){o=!1},50),o=!0)},!0),b.events.on(\\\"beforepaste\\\",d))}var l,m,n,o=!1;return{_init:k}},a.extend(a.FE.DEFAULTS,{shortcutsEnabled:[\\\"show\\\",\\\"bold\\\",\\\"italic\\\",\\\"underline\\\",\\\"strikeThrough\\\",\\\"indent\\\",\\\"outdent\\\",\\\"undo\\\",\\\"redo\\\"],shortcutsHint:!0}),a.FE.SHORTCUTS_MAP={},a.FE.RegisterShortcut=function(b,c,d,e,f,g){a.FE.SHORTCUTS_MAP[(f?\\\"^\\\":\\\"\\\")+(g?\\\"@\\\":\\\"\\\")+b]={cmd:c,val:d,letter:e,shift:f,option:g},a.FE.DEFAULTS.shortcutsEnabled.push(c)},a.FE.RegisterShortcut(a.FE.KEYCODE.E,\\\"show\\\",null,\\\"E\\\",!1,!1),a.FE.RegisterShortcut(a.FE.KEYCODE.B,\\\"bold\\\",null,\\\"B\\\",!1,!1),a.FE.RegisterShortcut(a.FE.KEYCODE.I,\\\"italic\\\",null,\\\"I\\\",!1,!1),a.FE.RegisterShortcut(a.FE.KEYCODE.U,\\\"underline\\\",null,\\\"U\\\",!1,!1),a.FE.RegisterShortcut(a.FE.KEYCODE.S,\\\"strikeThrough\\\",null,\\\"S\\\",!1,!1),a.FE.RegisterShortcut(a.FE.KEYCODE.CLOSE_SQUARE_BRACKET,\\\"indent\\\",null,\\\"]\\\",!1,!1),a.FE.RegisterShortcut(a.FE.KEYCODE.OPEN_SQUARE_BRACKET,\\\"outdent\\\",null,\\\"[\\\",!1,!1),a.FE.RegisterShortcut(a.FE.KEYCODE.Z,\\\"undo\\\",null,\\\"Z\\\",!1,!1),a.FE.RegisterShortcut(a.FE.KEYCODE.Z,\\\"redo\\\",null,\\\"Z\\\",!0,!1),a.FE.MODULES.shortcuts=function(b){function c(c){if(!b.opts.shortcutsHint)return null;if(!f){f={};for(var d in a.FE.SHORTCUTS_MAP)a.FE.SHORTCUTS_MAP.hasOwnProperty(d)&&b.opts.shortcutsEnabled.indexOf(a.FE.SHORTCUTS_MAP[d].cmd)>=0&&(f[a.FE.SHORTCUTS_MAP[d].cmd+\\\".\\\"+(a.FE.SHORTCUTS_MAP[d].val||\\\"\\\")]={shift:a.FE.SHORTCUTS_MAP[d].shift,option:a.FE.SHORTCUTS_MAP[d].option,letter:a.FE.SHORTCUTS_MAP[d].letter})}var e=f[c];return e?(b.helpers.isMac()?String.fromCharCode(8984):\\\"Ctrl+\\\")+(e.shift?b.helpers.isMac()?String.fromCharCode(8679):\\\"Shift+\\\":\\\"\\\")+(e.option?b.helpers.isMac()?String.fromCharCode(8997):\\\"Alt+\\\":\\\"\\\")+e.letter:null}function d(c){if(!b.core.hasFocus())return!0;var d=c.which,e=-1!=navigator.userAgent.indexOf(\\\"Mac OS X\\\")?c.metaKey:c.ctrlKey,f=(c.shiftKey?\\\"^\\\":\\\"\\\")+(c.altKey?\\\"@\\\":\\\"\\\")+d;if(e&&a.FE.SHORTCUTS_MAP[f]){var g=a.FE.SHORTCUTS_MAP[f].cmd;if(g&&b.opts.shortcutsEnabled.indexOf(g)>=0){var h,i=a.FE.SHORTCUTS_MAP[f].val;if(g&&!i?h=b.$tb.find('.fr-command[data-cmd=\\\"'+g+'\\\"]'):g&&i&&(h=b.$tb.find('.fr-command[data-cmd=\\\"'+g+'\\\"][data-param1=\\\"'+i+'\\\"]')),h.length)return c.preventDefault(),c.stopPropagation(),h.parents(\\\".fr-toolbar\\\").data(\\\"instance\\\",b),\\\"keydown\\\"==c.type&&b.button.exec(h),!1;if(g&&b.commands[g])return c.preventDefault(),c.stopPropagation(),\\\"keydown\\\"==c.type&&b.commands[g](),!1}}}function e(){b.events.on(\\\"keydown\\\",d,!0),b.events.on(\\\"keyup\\\",d,!0)}var f=null;return{_init:e,get:c}},a.FE.MODULES.snapshot=function(a){function b(a){for(var b=a.parentNode.childNodes,c=0,d=null,e=0;e<b.length;e++){if(d){var f=b[e].nodeType===Node.TEXT_NODE&&\\\"\\\"===b[e].textContent,g=d.nodeType===Node.TEXT_NODE&&b[e].nodeType===Node.TEXT_NODE;f||g||c++}if(b[e]==a)return c;d=b[e]}}function c(c){var d=[];if(!c.parentNode)return[];for(;!a.node.isElement(c);)d.push(b(c)),c=c.parentNode;return d.reverse()}function d(a,b){for(;a&&a.nodeType===Node.TEXT_NODE;){var c=a.previousSibling;c&&c.nodeType==Node.TEXT_NODE&&(b+=c.textContent.length),a=c}return b}function e(a){return{scLoc:c(a.startContainer),scOffset:d(a.startContainer,a.startOffset),ecLoc:c(a.endContainer),ecOffset:d(a.endContainer,a.endOffset)}}function f(){var b={};if(a.events.trigger(\\\"snapshot.before\\\"),b.html=a.$wp?a.$el.html():a.$oel.get(0).outerHTML,b.ranges=[],a.$wp&&a.selection.inEditor()&&a.core.hasFocus())for(var c=a.selection.ranges(),d=0;d<c.length;d++)b.ranges.push(e(c[d]));return a.events.trigger(\\\"snapshot.after\\\"),b}function g(b){for(var c=a.$el.get(0),d=0;d<b.length;d++)c=c.childNodes[b[d]];return c}function h(b,c){try{var d=g(c.scLoc),e=c.scOffset,f=g(c.ecLoc),h=c.ecOffset,i=a.doc.createRange();i.setStart(d,e),i.setEnd(f,h),b.addRange(i)}catch(j){}}function i(b){a.$el.html()!=b.html&&a.$el.html(b.html);var c=a.selection.get();a.selection.clear(),a.events.focus(!0);for(var d=0;d<b.ranges.length;d++)h(c,b.ranges[d])}function j(b,c){return b.html!=c.html?!1:a.core.hasFocus()&&JSON.stringify(b.ranges)!=JSON.stringify(c.ranges)?!1:!0}return{get:f,restore:i,equal:j}},a.FE.MODULES.undo=function(a){function b(b){var c=b.which,d=a.keys.ctrlKey(b);d&&(90==c&&b.shiftKey&&b.preventDefault(),90==c&&b.preventDefault())}function c(){return 0===a.undo_stack.length||a.undo_index<=1?!1:!0}function d(){return a.undo_index==a.undo_stack.length?!1:!0}function e(b){return!a.undo_stack||a.undoing||a.$el.get(0).querySelectorAll(\\\".fr-marker\\\").length?!1:void(\\\"undefined\\\"==typeof b?(b=a.snapshot.get(),a.undo_stack[a.undo_index-1]&&a.snapshot.equal(a.undo_stack[a.undo_index-1],b)||(f(),a.undo_stack.push(b),a.undo_index++,b.html!=l&&(a.events.trigger(\\\"contentChanged\\\"),l=b.html))):(f(),a.undo_index>0?a.undo_stack[a.undo_index-1]=b:(a.undo_stack.push(b),a.undo_index++)))}function f(){if(!a.undo_stack||a.undoing)return!1;for(;a.undo_stack.length>a.undo_index;)a.undo_stack.pop()}function g(){if(a.undo_index>1){a.undoing=!0;var b=a.undo_stack[--a.undo_index-1];clearTimeout(a._content_changed_timer),a.snapshot.restore(b),l=b.html,a.popups.hideAll(),a.toolbar.enable(),a.events.trigger(\\\"contentChanged\\\"),a.events.trigger(\\\"commands.undo\\\"),a.undoing=!1}}function h(){if(a.undo_index<a.undo_stack.length){a.undoing=!0;var b=a.undo_stack[a.undo_index++];clearTimeout(a._content_changed_timer),a.snapshot.restore(b),l=b.html,a.popups.hideAll(),a.toolbar.enable(),a.events.trigger(\\\"contentChanged\\\"),a.events.trigger(\\\"commands.redo\\\"),a.undoing=!1}}function i(){a.undo_index=0,a.undo_stack=[]}function j(){a.undo_stack=[]}function k(){i(),a.events.on(\\\"initialized\\\",function(){l=a.html.get(!1,!0)}),a.events.on(\\\"blur\\\",function(){a.undo.saveStep()}),a.events.on(\\\"keydown\\\",b),a.events.on(\\\"destroy\\\",j)}var l=null;return{_init:k,run:g,redo:h,canDo:c,canRedo:d,dropRedo:f,reset:i,saveStep:e}},a.FE.ICON_DEFAULT_TEMPLATE=\\\"font_awesome\\\",a.FE.ICON_TEMPLATES={font_awesome:'<i class=\\\"fa fa-[NAME]\\\"></i>',text:'<span style=\\\"text-align: center;\\\">[NAME]</span>',image:\\\"<img src=[SRC] alt=[ALT] />\\\"},a.FE.ICONS={bold:{NAME:\\\"bold\\\"},italic:{NAME:\\\"italic\\\"},underline:{NAME:\\\"underline\\\"},strikeThrough:{NAME:\\\"strikethrough\\\"},subscript:{NAME:\\\"subscript\\\"},superscript:{NAME:\\\"superscript\\\"},color:{NAME:\\\"tint\\\"},outdent:{NAME:\\\"outdent\\\"},indent:{NAME:\\\"indent\\\"},undo:{NAME:\\\"rotate-left\\\"},redo:{NAME:\\\"rotate-right\\\"},insertHR:{NAME:\\\"minus\\\"},clearFormatting:{NAME:\\\"eraser\\\"},selectAll:{NAME:\\\"mouse-pointer\\\"}},a.FE.DefineIconTemplate=function(b,c){a.FE.ICON_TEMPLATES[b]=c},a.FE.DefineIcon=function(b,c){a.FE.ICONS[b]=c},a.FE.MODULES.icon=function(b){function c(b){var c=null,d=a.FE.ICONS[b];if(\\\"undefined\\\"!=typeof d){var e=d.template||a.FE.ICON_DEFAULT_TEMPLATE;e&&(e=a.FE.ICON_TEMPLATES[e])&&(c=e.replace(/\\\\[([a-zA-Z]*)\\\\]/g,function(a,c){return\\\"NAME\\\"==c?d[c]||b:d[c]}))}return c||b}return{create:c}},a.FE.MODULES.tooltip=function(b){function c(){b.$tooltip&&b.$tooltip.removeClass(\\\"fr-visible\\\").css(\\\"left\\\",\\\"-3000px\\\").css(\\\"position\\\",\\\"fixed\\\")}function d(c,d){if(c.data(\\\"title\\\")||c.data(\\\"title\\\",c.attr(\\\"title\\\")),!c.data(\\\"title\\\"))return!1;b.$tooltip||f(),c.removeAttr(\\\"title\\\"),b.$tooltip.text(c.data(\\\"title\\\")),b.$tooltip.addClass(\\\"fr-visible\\\");var e=c.offset().left+(c.outerWidth()-b.$tooltip.outerWidth())/2;0>e&&(e=0),e+b.$tooltip.outerWidth()>a(b.o_win).width()&&(e=a(b.o_win).width()-b.$tooltip.outerWidth()),\\\"undefined\\\"==typeof d&&(d=b.opts.toolbarBottom);var g=d?c.offset().top-b.$tooltip.height():c.offset().top+c.outerHeight();b.$tooltip.css(\\\"position\\\",\\\"\\\"),b.$tooltip.css(\\\"left\\\",e),b.$tooltip.css(\\\"top\\\",g),\\\"static\\\"!=a(b.o_doc).find(\\\"body\\\").css(\\\"position\\\")?(b.$tooltip.css(\\\"margin-left\\\",-a(b.o_doc).find(\\\"body\\\").offset().left),b.$tooltip.css(\\\"margin-top\\\",-a(b.o_doc).find(\\\"body\\\").offset().top)):(b.$tooltip.css(\\\"margin-left\\\",\\\"\\\"),b.$tooltip.css(\\\"margin-top\\\",\\\"\\\"))}function e(e,f,g){b.helpers.isMobile()||(b.events.$on(e,\\\"mouseenter\\\",f,function(c){a(c.currentTarget).hasClass(\\\"fr-disabled\\\")||b.edit.isDisabled()||d(a(c.currentTarget),g)},!0),b.events.$on(e,\\\"mouseleave \\\"+b._mousedown+\\\" \\\"+b._mouseup,f,function(a){c()},!0))}function f(){b.helpers.isMobile()||(b.shared.$tooltip?b.$tooltip=b.shared.$tooltip:(b.shared.$tooltip=a('<div class=\\\"fr-tooltip\\\"></div>'),b.$tooltip=b.shared.$tooltip,b.opts.theme&&b.$tooltip.addClass(b.opts.theme+\\\"-theme\\\"),a(b.o_doc).find(\\\"body\\\").append(b.$tooltip)),b.events.on(\\\"shared.destroy\\\",function(){b.$tooltip.html(\\\"\\\").removeData().remove(),b.$tooltip=null},!0))}return{hide:c,to:d,bind:e}},a.FE.MODULES.button=function(b){function c(c){var d=a(c.currentTarget),e=d.next(),f=d.hasClass(\\\"fr-active\\\"),g=(b.helpers.isMobile(),a(\\\".fr-dropdown.fr-active\\\").not(d)),h=d.parents(\\\".fr-toolbar, .fr-popup\\\").data(\\\"instance\\\")||b;if(h.helpers.isIOS()&&0==h.$el.get(0).querySelectorAll(\\\".fr-marker\\\").length&&(h.selection.save(),h.selection.clear(),h.selection.restore()),!f){var i=d.data(\\\"cmd\\\");e.find(\\\".fr-command\\\").removeClass(\\\"fr-active\\\"),a.FE.COMMANDS[i]&&a.FE.COMMANDS[i].refreshOnShow&&a.FE.COMMANDS[i].refreshOnShow.apply(h,[d,e]),e.css(\\\"left\\\",d.offset().left-d.parent().offset().left-(\\\"rtl\\\"==b.opts.direction?e.width()-d.outerWidth():0)),b.opts.toolbarBottom?e.css(\\\"bottom\\\",b.$tb.height()-d.position().top):e.css(\\\"top\\\",d.position().top+d.outerHeight())}d.addClass(\\\"fr-blink\\\").toggleClass(\\\"fr-active\\\"),setTimeout(function(){d.removeClass(\\\"fr-blink\\\")},300),e.offset().left+e.outerWidth()>a(b.opts.scrollableContainer).offset().left+a(b.opts.scrollableContainer).outerWidth()&&e.css(\\\"margin-left\\\",-(e.offset().left+e.outerWidth()-a(b.opts.scrollableContainer).offset().left-a(b.opts.scrollableContainer).outerWidth())),g.removeClass(\\\"fr-active\\\"),g.parent(\\\".fr-toolbar:not(.fr-inline)\\\").css(\\\"zIndex\\\",\\\"\\\"),0!=d.parents(\\\".fr-popup\\\").length||b.opts.toolbarInline||(d.hasClass(\\\"fr-active\\\")?b.$tb.css(\\\"zIndex\\\",(b.opts.zIndex||1)+4):b.$tb.css(\\\"zIndex\\\",\\\"\\\"))}function d(b){b.addClass(\\\"fr-blink\\\"),setTimeout(function(){b.removeClass(\\\"fr-blink\\\")},500);for(var c=b.data(\\\"cmd\\\"),d=[];\\\"undefined\\\"!=typeof b.data(\\\"param\\\"+(d.length+1));)d.push(b.data(\\\"param\\\"+(d.length+1)));var e=a(\\\".fr-dropdown.fr-active\\\");e.length&&(e.removeClass(\\\"fr-active\\\"),e.parent(\\\".fr-toolbar:not(.fr-inline)\\\").css(\\\"zIndex\\\",\\\"\\\")),b.parents(\\\".fr-popup, .fr-toolbar\\\").data(\\\"instance\\\").commands.exec(c,d)}function e(b){var c=a(b.currentTarget);d(c)}function f(b){var d=a(b.currentTarget),f=d.parents(\\\".fr-popup, .fr-toolbar\\\").data(\\\"instance\\\");if(0!=d.parents(\\\".fr-popup\\\").length||d.data(\\\"popup\\\")||f.popups.hideAll(),f.popups.areVisible()&&!f.popups.areVisible(f)){\\nfor(var g=0;g<a.FE.INSTANCES.length;g++)a.FE.INSTANCES[g]!=f&&a.FE.INSTANCES[g].popups&&a.FE.INSTANCES[g].popups.areVisible()&&a.FE.INSTANCES[g].$el.find(\\\".fr-marker\\\").remove();f.popups.hideAll()}d.hasClass(\\\"fr-dropdown\\\")?c(b):(e(b),a.FE.COMMANDS[d.data(\\\"cmd\\\")]&&0!=a.FE.COMMANDS[d.data(\\\"cmd\\\")].refreshAfterCallback&&f.button.bulkRefresh())}function g(a){var b=a.find(\\\".fr-dropdown.fr-active\\\");b.length&&(b.removeClass(\\\"fr-active\\\"),b.parent(\\\".fr-toolbar:not(.fr-inline)\\\").css(\\\"zIndex\\\",\\\"\\\"))}function h(a){a.preventDefault(),a.stopPropagation()}function i(a){return a.stopPropagation(),b.helpers.isMobile()?void 0:!1}function j(c,d){b.events.bindClick(c,\\\".fr-command:not(.fr-disabled)\\\",f),b.events.$on(c,b._mousedown+\\\" \\\"+b._mouseup+\\\" \\\"+b._move,\\\".fr-dropdown-menu\\\",h,!0),b.events.$on(c,b._mousedown+\\\" \\\"+b._mouseup+\\\" \\\"+b._move,\\\".fr-dropdown-menu .fr-dropdown-wrapper\\\",i,!0);var e=c.get(0).ownerDocument,j=\\\"defaultView\\\"in e?e.defaultView:e.parentWindow,k=function(d){(!d||d.type==b._mouseup&&d.target!=a(\\\"html\\\").get(0)||\\\"keydown\\\"==d.type&&(b.keys.isCharacter(d.which)&&!b.keys.ctrlKey(d)||d.which==a.FE.KEYCODE.ESC))&&g(c)};b.events.$on(a(j),b._mouseup+\\\" resize keydown\\\",k,!0),b.opts.iframe&&b.events.$on(b.$win,b._mouseup,k,!0),c.hasClass(\\\"fr-popup\\\")?a.merge(t,c.find(\\\".fr-btn\\\").toArray()):a.merge(s,c.find(\\\".fr-btn\\\").toArray()),b.tooltip.bind(c,\\\".fr-btn, .fr-title\\\",d)}function k(a,c){var d=\\\"\\\";if(c.html)d+=\\\"function\\\"==typeof c.html?c.html.call(b):c.html;else{var e=c.options;\\\"function\\\"==typeof e&&(e=e()),d+='<ul class=\\\"fr-dropdown-list\\\">';for(var f in e)if(e.hasOwnProperty(f)){var g=b.shortcuts.get(a+\\\".\\\"+f);g=g?'<span class=\\\"fr-shortcut\\\">'+g+\\\"</span>\\\":\\\"\\\",d+='<li><a class=\\\"fr-command\\\" data-cmd=\\\"'+a+'\\\" data-param1=\\\"'+f+'\\\" title=\\\"'+e[f]+'\\\">'+b.language.translate(e[f])+\\\"</a></li>\\\"}d+=\\\"</ul>\\\"}return d}function l(a,c,d){var e=c.displaySelection;\\\"function\\\"==typeof e&&(e=e(b));var f;if(e){var g=\\\"function\\\"==typeof c.defaultSelection?c.defaultSelection(b):c.defaultSelection;f='<span style=\\\"width:'+(c.displaySelectionWidth||100)+'px\\\">'+(g||b.language.translate(c.title))+\\\"</span>\\\"}else f=b.icon.create(c.icon||a);var h=c.popup?' data-popup=\\\"true\\\"':\\\"\\\",i=b.shortcuts.get(a+\\\".\\\");i=i?\\\" (\\\"+i+\\\")\\\":\\\"\\\";var j='<button type=\\\"button\\\" tabindex=\\\"-1\\\" aria-label=\\\"'+(b.language.translate(c.title)||\\\"\\\")+'\\\" title=\\\"'+(b.language.translate(c.title)||\\\"\\\")+i+'\\\" class=\\\"fr-command fr-btn'+(\\\"dropdown\\\"==c.type?\\\" fr-dropdown\\\":\\\"\\\")+(c.displaySelection?\\\" fr-selection\\\":\\\"\\\")+(c.back?\\\" fr-back\\\":\\\"\\\")+(c.disabled?\\\" fr-disabled\\\":\\\"\\\")+(d?\\\"\\\":\\\" fr-hidden\\\")+'\\\" data-cmd=\\\"'+a+'\\\"'+h+\\\">\\\"+f+\\\"</button>\\\";if(\\\"dropdown\\\"==c.type){var l='<div class=\\\"fr-dropdown-menu\\\"><div class=\\\"fr-dropdown-wrapper\\\"><div class=\\\"fr-dropdown-content\\\">';l+=k(a,c),l+=\\\"</div></div></div>\\\",j+=l}return j}function m(c,d){for(var e=\\\"\\\",f=0;f<c.length;f++){var g=c[f],h=a.FE.COMMANDS[g];if(!(h&&\\\"undefined\\\"!=typeof h.plugin&&b.opts.pluginsEnabled.indexOf(h.plugin)<0))if(h){var i=\\\"undefined\\\"!=typeof d?d.indexOf(g)>=0:!0;e+=l(g,h,i)}else\\\"|\\\"==g?e+='<div class=\\\"fr-separator fr-vs\\\"></div>':\\\"-\\\"==g&&(e+='<div class=\\\"fr-separator fr-hs\\\"></div>')}return e}function n(c){var d,e=c.parents(\\\".fr-popup, .fr-toolbar\\\").data(\\\"instance\\\")||b,f=c.data(\\\"cmd\\\");c.hasClass(\\\"fr-dropdown\\\")?d=c.next():c.removeClass(\\\"fr-active\\\"),a.FE.COMMANDS[f]&&a.FE.COMMANDS[f].refresh?a.FE.COMMANDS[f].refresh.apply(e,[c,d]):b.refresh[f]&&e.refresh[f](c,d)}function o(c){var d=b.$tb?b.$tb.data(\\\"instance\\\")||b:b;return 0==b.events.trigger(\\\"buttons.refresh\\\")?!0:void setTimeout(function(){for(var b=d.selection.inEditor()&&d.core.hasFocus(),e=0;e<c.length;e++){var f=a(c[e]),g=f.data(\\\"cmd\\\");0==f.parents(\\\".fr-popup\\\").length?b||a.FE.COMMANDS[g]&&a.FE.COMMANDS[g].forcedRefresh?d.button.refresh(f):f.hasClass(\\\"fr-dropdown\\\")||f.removeClass(\\\"fr-active\\\"):f.parents(\\\".fr-popup\\\").is(\\\":visible\\\")&&d.button.refresh(f)}},0)}function p(){o(s),o(t)}function q(){s=[],t=[]}function r(){b.opts.toolbarInline?b.events.on(\\\"toolbar.show\\\",p):(b.events.on(\\\"mouseup\\\",p),b.events.on(\\\"keyup\\\",p),b.events.on(\\\"blur\\\",p),b.events.on(\\\"focus\\\",p),b.events.on(\\\"contentChanged\\\",p)),b.events.on(\\\"shared.destroy\\\",q)}var s=[];(b.opts.toolbarInline||b.opts.toolbarContainer)&&(b.shared.buttons||(b.shared.buttons=[]),s=b.shared.buttons);var t=[];return b.shared.popup_buttons||(b.shared.popup_buttons=[]),t=b.shared.popup_buttons,{_init:r,buildList:m,bindCommands:j,refresh:n,bulkRefresh:p,exec:d}},a.FE.POPUP_TEMPLATES={\\\"text.edit\\\":\\\"[_EDIT_]\\\"},a.FE.RegisterTemplate=function(b,c){a.FE.POPUP_TEMPLATES[b]=c},a.FE.MODULES.popups=function(b){function c(c,d){d.is(\\\":visible\\\")||(d=a(b.opts.scrollableContainer)),d.is(x[c].data(\\\"container\\\"))||(x[c].data(\\\"container\\\",d),d.append(x[c]))}function d(d,e,h,i){if(g()&&b.$el.find(\\\".fr-marker\\\").length>0&&(b.events.disableBlur(),b.selection.restore()),m([d]),!x[d])return!1;a(\\\".fr-dropdown.fr-active\\\").removeClass(\\\"fr-active\\\").parent(\\\".fr-toolbar\\\").css(\\\"zIndex\\\",\\\"\\\"),x[d].data(\\\"instance\\\",b),b.$tb&&b.$tb.data(\\\"instance\\\",b);var j=x[d].outerWidth(),k=(x[d].outerHeight(),f(d));x[d].addClass(\\\"fr-active\\\").removeClass(\\\"fr-hidden\\\").find(\\\"input, textarea\\\").removeAttr(\\\"disabled\\\");var l=x[d].data(\\\"container\\\");l.is(b.$tb)&&b.$tb.css(\\\"zIndex\\\",(b.opts.zIndex||1)+4),b.opts.toolbarInline&&l&&b.$tb&&l.get(0)==b.$tb.get(0)&&(c(d,a(b.opts.scrollableContainer)),h=b.$tb.offset().top-b.helpers.getPX(b.$tb.css(\\\"margin-top\\\")),e=b.$tb.offset().left+b.$tb.outerWidth()/2+(parseFloat(b.$tb.find(\\\".fr-arrow\\\").css(\\\"margin-left\\\"))||0)+b.$tb.find(\\\".fr-arrow\\\").outerWidth()/2,b.$tb.hasClass(\\\"fr-above\\\")&&h&&(h+=b.$tb.outerHeight()),i=0),l=x[d].data(\\\"container\\\"),!b.opts.iframe||i||k||(e&&(e-=b.$iframe.offset().left),h&&(h-=b.$iframe.offset().top)),e&&(e-=j/2),b.opts.toolbarBottom&&l&&b.$tb&&l.get(0)==b.$tb.get(0)&&(x[d].addClass(\\\"fr-above\\\"),h&&(h-=x[d].outerHeight())),x[d].removeClass(\\\"fr-active\\\"),b.position.at(e,h,x[d],i||0),x[d].addClass(\\\"fr-active\\\");var n=x[d].find(\\\"input:visible, textarea:visible\\\").get(0);n&&(0==b.$el.find(\\\".fr-marker\\\").length&&b.core.hasFocus()&&b.selection.save(),b.events.disableBlur(),a(n).select().focus()),b.opts.toolbarInline&&b.toolbar.hide(),b.events.trigger(\\\"popups.show.\\\"+d),s(d)._repositionPopup(),o()}function e(a,c){b.events.on(\\\"popups.show.\\\"+a,c)}function f(a){return x[a]&&x[a].hasClass(\\\"fr-active\\\")&&b.core.sameInstance(x[a])||!1}function g(a){for(var b in x)if(x.hasOwnProperty(b)&&f(b)&&(\\\"undefined\\\"==typeof a||x[b].data(\\\"instance\\\")==a))return!0;return!1}function h(a){x[a]&&x[a].hasClass(\\\"fr-active\\\")&&(x[a].removeClass(\\\"fr-active fr-above\\\"),b.events.trigger(\\\"popups.hide.\\\"+a),b.$tb&&(b.opts.zIndex>1?b.$tb.css(\\\"zIndex\\\",b.opts.zIndex+1):b.$tb.css(\\\"zIndex\\\",\\\"\\\")),b.events.disableBlur(),x[a].find(\\\"input, textarea, button\\\").filter(\\\":focus\\\").blur(),x[a].find(\\\"input, textarea\\\").attr(\\\"disabled\\\",\\\"disabled\\\"))}function i(a,c){b.events.on(\\\"popups.hide.\\\"+a,c)}function j(a){var c=x[a];if(c&&!c.data(\\\"inst\\\"+b.id)){var d=s(a);t(d,a)}return c}function k(a,c){b.events.on(\\\"popups.refresh.\\\"+a,c)}function l(c){b.events.trigger(\\\"popups.refresh.\\\"+c);for(var d=x[c].find(\\\".fr-command\\\"),e=0;e<d.length;e++){var f=a(d[e]);0==f.parents(\\\".fr-dropdown-menu\\\").length&&b.button.refresh(f)}}function m(a){\\\"undefined\\\"==typeof a&&(a=[]);for(var b in x)x.hasOwnProperty(b)&&a.indexOf(b)<0&&h(b)}function n(){b.shared.exit_flag=!0}function o(){b.shared.exit_flag=!1}function p(){return b.shared.exit_flag}function q(c,d){var e=a.FE.POPUP_TEMPLATES[c];\\\"function\\\"==typeof e&&(e=e.apply(b));for(var f in d)d.hasOwnProperty(f)&&(e=e.replace(\\\"[_\\\"+f.toUpperCase()+\\\"_]\\\",d[f]));return e}function r(c,d){var e=q(c,d),f=a('<div class=\\\"fr-popup'+(b.helpers.isMobile()?\\\" fr-mobile\\\":\\\" fr-desktop\\\")+(b.opts.toolbarInline?\\\" fr-inline\\\":\\\"\\\")+'\\\"><span class=\\\"fr-arrow\\\"></span>'+e+\\\"</div>\\\");b.opts.theme&&f.addClass(b.opts.theme+\\\"-theme\\\"),b.opts.zIndex>1&&b.$tb.css(\\\"z-index\\\",b.opts.zIndex+2),\\\"auto\\\"!=b.opts.direction&&f.removeClass(\\\"fr-ltr fr-rtl\\\").addClass(\\\"fr-\\\"+b.opts.direction),f.find(\\\"input, textarea\\\").attr(\\\"dir\\\",b.opts.direction).attr(\\\"disabled\\\",\\\"disabled\\\");var g=a(\\\"body\\\");return g.append(f),f.data(\\\"container\\\",g),x[c]=f,b.button.bindCommands(f,!1),f}function s(c){var d=x[c];return{_windowResize:function(){var a=d.data(\\\"instance\\\")||b;!a.helpers.isMobile()&&d.is(\\\":visible\\\")&&(a.events.disableBlur(),a.popups.hide(c),a.events.enableBlur())},_inputFocus:function(c){var e=d.data(\\\"instance\\\")||b;if(c.preventDefault(),setTimeout(function(){e.events.enableBlur()},0),e.helpers.isMobile()){var f=a(e.o_win).scrollTop();setTimeout(function(){a(e.o_win).scrollTop(f)},0)}},_inputBlur:function(c){var e=d.data(\\\"instance\\\")||b;document.activeElement!=this&&a(this).is(\\\":visible\\\")&&(e.events.blurActive()&&e.events.trigger(\\\"blur\\\"),e.events.enableBlur())},_inputKeydown:function(e){var g=d.data(\\\"instance\\\")||b,h=e.which;if(a.FE.KEYCODE.TAB==h){e.preventDefault();var i=d.find(\\\"input, textarea, button, select\\\").filter(\\\":visible\\\").not(\\\":disabled\\\").toArray();i.sort(function(b,c){return e.shiftKey?a(b).attr(\\\"tabIndex\\\")<a(c).attr(\\\"tabIndex\\\"):a(b).attr(\\\"tabIndex\\\")>a(c).attr(\\\"tabIndex\\\")}),g.events.disableBlur();var j=i.indexOf(this)+1;j==i.length&&(j=0),a(i[j]).focus()}else if(a.FE.KEYCODE.ENTER==h)d.find(\\\".fr-submit:visible\\\").length>0&&(e.preventDefault(),e.stopPropagation(),g.events.disableBlur(),g.button.exec(d.find(\\\".fr-submit:visible:first\\\")));else{if(a.FE.KEYCODE.ESC==h)return e.preventDefault(),e.stopPropagation(),g.$el.find(\\\".fr-marker\\\")&&(g.events.disableBlur(),a(this).data(\\\"skip\\\",!0),g.selection.restore(),g.events.enableBlur()),f(c)&&d.find(\\\".fr-back:visible\\\").length?g.button.exec(d.find(\\\".fr-back:visible:first\\\")):g.popups.hide(c),g.opts.toolbarInline&&g.toolbar.showInline(null,!0),!1;e.stopPropagation()}},_windowKeydown:function(e){if(!b.core.sameInstance(d))return!0;var g=d.data(\\\"instance\\\")||b,h=e.which;if(a.FE.KEYCODE.ESC==h){if(f(c)&&g.opts.toolbarInline)return e.stopPropagation(),f(c)&&d.find(\\\".fr-back:visible\\\").length?g.button.exec(d.find(\\\".fr-back:visible:first\\\")):(g.popups.hide(c),g.toolbar.showInline(null,!0)),!1;f(c)&&d.find(\\\".fr-back:visible\\\").length?g.button.exec(d.find(\\\".fr-back:visible:first\\\")):g.popups.hide(c)}},_editorKeydown:function(e){var g=d.data(\\\"instance\\\")||b;g.keys.ctrlKey(e)||e.which==a.FE.KEYCODE.ESC||(f(c)&&d.find(\\\".fr-back:visible\\\").length?g.button.exec(d.find(\\\".fr-back:visible:first\\\")):g.popups.hide(c))},_preventFocus:function(c){var e=d.data(\\\"instance\\\")||b;e.events.disableBlur();var f=c.originalEvent?c.originalEvent.target||c.originalEvent.originalTarget:null,g=\\\"input, textarea, button, select, label, .fr-command\\\";return f&&!a(f).is(g)&&0===a(f).parents(g).length?(c.stopPropagation(),!1):(f&&a(f).is(g)&&c.stopPropagation(),void o())},_editorMouseup:function(a){d.is(\\\":visible\\\")&&p()&&d.find(\\\"input:focus, textarea:focus, button:focus, select:focus\\\").filter(\\\":visible\\\").length>0&&b.events.disableBlur()},_windowMouseup:function(a){if(!b.core.sameInstance(d))return!0;var e=d.data(\\\"instance\\\")||b;d.is(\\\":visible\\\")&&p()&&(a.stopPropagation(),e.markers.remove(),e.popups.hide(c),o())},_doPlaceholder:function(b){var c=a(this).next();0==c.length&&a(this).after(\\\"<label>\\\"+a(this).attr(\\\"placeholder\\\")+\\\"</label>\\\"),a(this).toggleClass(\\\"fr-not-empty\\\",\\\"\\\"!=a(this).val())},_repositionPopup:function(e){if(!b.opts.height&&!b.opts.heightMax||b.opts.toolbarInline)return!0;if(b.$wp&&f(c)&&d.parent().get(0)==a(b.opts.scrollableContainer).get(0)){var g=d.offset().top-b.$wp.offset().top,h=b.$wp.outerHeight();d.hasClass(\\\"fr-above\\\")&&(g+=d.outerHeight()),g>h||0>g?d.addClass(\\\"fr-hidden\\\"):d.removeClass(\\\"fr-hidden\\\")}}}}function t(a,c){b.events.on(\\\"mouseup\\\",a._editorMouseup,!0),b.$wp&&b.events.on(\\\"keydown\\\",a._editorKeydown),b.events.on(\\\"blur\\\",function(a){g()&&b.markers.remove(),m()}),b.$wp&&!b.helpers.isMobile()&&b.events.$on(b.$wp,\\\"scroll.popup\\\"+c,a._repositionPopup),b.events.on(\\\"window.keydown\\\",a._windowKeydown),b.events.on(\\\"window.mouseup\\\",a._windowMouseup,!0),x[c].data(\\\"inst\\\"+b.id,!0),b.events.on(\\\"destroy\\\",function(){b.core.sameInstance(x[c])&&x[c].removeClass(\\\"fr-active\\\").appendTo(\\\"body\\\")},!0)}function u(c,d){var e=r(c,d),f=s(c);return t(f,c),b.events.$on(e,\\\"mousedown mouseup touchstart touchend touch\\\",\\\"*\\\",f._preventFocus,!0),b.events.$on(e,\\\"focus\\\",\\\"input, textarea, button, select\\\",f._inputFocus,!0),b.events.$on(e,\\\"blur\\\",\\\"input, textarea, button, select\\\",f._inputBlur,!0),b.events.$on(e,\\\"keydown\\\",\\\"input, textarea, button, select\\\",f._inputKeydown,!0),b.events.$on(e,\\\"keydown keyup change input\\\",\\\"input, textarea\\\",f._doPlaceholder,!0),b.helpers.isIOS()&&b.events.$on(e,\\\"touchend\\\",\\\"label\\\",function(){a(\\\"#\\\"+a(this).attr(\\\"for\\\")).prop(\\\"checked\\\",function(a,b){return!b})},!0),b.events.$on(a(b.o_win),\\\"resize\\\",f._windowResize,!0),e}function v(){for(var a in x)if(x.hasOwnProperty(a)){var b=x[a];b.html(\\\"\\\").removeData().remove(),x[a]=null}x=[]}function w(){b.events.on(\\\"shared.destroy\\\",v,!0),b.events.on(\\\"window.mousedown\\\",n),b.events.on(\\\"window.touchmove\\\",o),b.events.on(\\\"mousedown\\\",function(a){g()&&(a.stopPropagation(),b.$el.find(\\\".fr-marker\\\").remove(),n(),b.events.disableBlur())})}b.shared.popups||(b.shared.popups={});var x=b.shared.popups;return b.shared.exit_flag=!1,{_init:w,create:u,get:j,show:d,hide:h,onHide:i,hideAll:m,setContainer:c,refresh:l,onRefresh:k,onShow:e,isVisible:f,areVisible:g}},a.FE.MODULES.position=function(b){function c(){var c,d=b.selection.ranges(0);if(d&&d.collapsed&&b.selection.inEditor()){var e=!1;0==b.$el.find(\\\".fr-marker\\\").length&&(b.selection.save(),e=!0);var f=b.$el.find(\\\".fr-marker:first\\\");f.css(\\\"display\\\",\\\"inline\\\"),f.css(\\\"line-height\\\",\\\"\\\");var g=f.offset(),h=f.outerHeight();f.css(\\\"display\\\",\\\"none\\\"),f.css(\\\"line-height\\\",0),c={},c.left=g.left,c.width=0,c.height=h,c.top=g.top-(b.helpers.isIOS()?0:a(b.o_win).scrollTop()),c.right=1,c.bottom=1,c.ok=!0,e&&b.selection.restore()}else d&&(c=d.getBoundingClientRect());return c}function d(c,d,e){var f=c.outerHeight();if(!b.helpers.isMobile()&&b.$tb&&c.parent().get(0)!=b.$tb.get(0)){var g=(c.parent().height()-20-(b.opts.toolbarBottom?b.$tb.outerHeight():0),c.parent().offset().top),h=d-f-(e||0);c.parent().get(0)==a(b.opts.scrollableContainer).get(0)&&(g-=c.parent().position().top);var i=a(b.opts.scrollableContainer).get(0).scrollHeight;g+d+f>a(b.opts.scrollableContainer).offset().top+i&&c.parent().offset().top+h>0?(d=h,c.addClass(\\\"fr-above\\\")):c.removeClass(\\\"fr-above\\\")}return d}function e(c,d){var e=c.outerWidth();return d+e>a(b.opts.scrollableContainer).width()-10&&(d=a(b.opts.scrollableContainer).width()-e-10),0>d&&(d=10),d}function f(d){var e=c();d.css(\\\"top\\\",0).css(\\\"left\\\",0);var f=e.top+e.height,h=e.left+e.width/2-d.outerWidth()/2+a(b.o_win).scrollLeft();b.opts.iframe||(f+=a(b.o_win).scrollTop()),g(h,f,d,e.height)}function g(a,c,f,g){var h=f.data(\\\"container\\\");!h||h.is(\\\"body\\\")&&\\\"static\\\"==h.css(\\\"position\\\")||(a&&(a-=h.offset().left),c&&(c-=h.offset().top),\\\"BODY\\\"!=h.get(0).tagName?(a&&(a+=h.scrollLeft()),c&&(c+=h.scrollTop())):\\\"absolute\\\"==h.css(\\\"position\\\")&&(a&&(a+=h.position().left),c&&(c+=h.position().top))),b.opts.iframe&&h&&b.$tb&&h.get(0)!=b.$tb.get(0)&&(a&&(a+=b.$iframe.offset().left),c&&(c+=b.$iframe.offset().top));var i=e(f,a);if(a){f.css(\\\"left\\\",i);var j=f.find(\\\".fr-arrow\\\");j.data(\\\"margin-left\\\")||j.data(\\\"margin-left\\\",b.helpers.getPX(j.css(\\\"margin-left\\\"))),j.css(\\\"margin-left\\\",a-i+j.data(\\\"margin-left\\\"))}c&&f.css(\\\"top\\\",d(f,c,g))}function h(c){var d=a(c),e=d.is(\\\".fr-sticky-on\\\"),f=d.data(\\\"sticky-top\\\"),g=d.data(\\\"sticky-scheduled\\\");if(\\\"undefined\\\"==typeof f){d.data(\\\"sticky-top\\\",0);var h=a('<div class=\\\"fr-sticky-dummy\\\" style=\\\"height: '+d.outerHeight()+'px;\\\"></div>');b.$box.prepend(h)}else b.$box.find(\\\".fr-sticky-dummy\\\").css(\\\"height\\\",d.outerHeight());if(b.core.hasFocus()||b.$tb.find(\\\"input:visible:focus\\\").length>0){var i=a(window).scrollTop(),j=Math.min(Math.max(i-b.$tb.parent().offset().top,0),b.$tb.parent().outerHeight()-d.outerHeight());j!=f&&j!=g&&(clearTimeout(d.data(\\\"sticky-timeout\\\")),d.data(\\\"sticky-scheduled\\\",j),d.outerHeight()<i-b.$tb.parent().offset().top&&d.addClass(\\\"fr-opacity-0\\\"),d.data(\\\"sticky-timeout\\\",setTimeout(function(){var c=a(window).scrollTop(),e=Math.min(Math.max(c-b.$tb.parent().offset().top,0),b.$tb.parent().outerHeight()-d.outerHeight());e>0&&\\\"BODY\\\"==b.$tb.parent().get(0).tagName&&(e+=b.$tb.parent().position().top),e!=f&&(d.css(\\\"top\\\",Math.max(e,0)),d.data(\\\"sticky-top\\\",e),d.data(\\\"sticky-scheduled\\\",e)),d.removeClass(\\\"fr-opacity-0\\\")},100))),e||(d.css(\\\"top\\\",\\\"0\\\"),d.width(b.$tb.parent().width()),d.addClass(\\\"fr-sticky-on\\\"),b.$box.addClass(\\\"fr-sticky-box\\\"))}else clearTimeout(a(c).css(\\\"sticky-timeout\\\")),d.css(\\\"top\\\",\\\"0\\\"),d.css(\\\"position\\\",\\\"\\\"),d.width(\\\"\\\"),d.data(\\\"sticky-top\\\",0),d.removeClass(\\\"fr-sticky-on\\\"),b.$box.removeClass(\\\"fr-sticky-box\\\")}function i(c){if(c.offsetWidth){var d,e,f=a(c),g=f.outerHeight(),h=f.data(\\\"sticky-position\\\"),i=a(\\\"body\\\"==b.opts.scrollableContainer?b.o_win:b.opts.scrollableContainer).outerHeight(),j=0,k=0;\\\"body\\\"!==b.opts.scrollableContainer&&(j=a(b.opts.scrollableContainer).offset().top,k=a(b.o_win).outerHeight()-j-i);var l=\\\"body\\\"==b.opts.scrollableContainer?a(b.o_win).scrollTop():j,m=f.is(\\\".fr-sticky-on\\\");f.data(\\\"sticky-parent\\\")||f.data(\\\"sticky-parent\\\",f.parent());var n=f.data(\\\"sticky-parent\\\"),o=n.offset().top,p=n.outerHeight();if(f.data(\\\"sticky-offset\\\")||(f.data(\\\"sticky-offset\\\",!0),f.after('<div class=\\\"fr-sticky-dummy\\\" style=\\\"height: '+g+'px;\\\"></div>')),!h){var q=\\\"auto\\\"!==f.css(\\\"top\\\")||\\\"auto\\\"!==f.css(\\\"bottom\\\");q||f.css(\\\"position\\\",\\\"fixed\\\"),h={top:f.hasClass(\\\"fr-top\\\"),bottom:f.hasClass(\\\"fr-bottom\\\")},q||f.css(\\\"position\\\",\\\"\\\"),f.data(\\\"sticky-position\\\",h),f.data(\\\"top\\\",f.hasClass(\\\"fr-top\\\")?f.css(\\\"top\\\"):\\\"auto\\\"),f.data(\\\"bottom\\\",f.hasClass(\\\"fr-bottom\\\")?f.css(\\\"bottom\\\"):\\\"auto\\\")}var r=function(){return l+d>o&&o+p-g>=l+d},s=function(){return l+i-e>o+g&&o+p>l+i-e};d=b.helpers.getPX(f.data(\\\"top\\\")),e=b.helpers.getPX(f.data(\\\"bottom\\\"));var t=h.top&&r(),u=h.bottom&&s();t||u?(f.css(\\\"width\\\",n.width()+\\\"px\\\"),m||(f.addClass(\\\"fr-sticky-on\\\"),f.removeClass(\\\"fr-sticky-off\\\"),f.css(\\\"top\\\")&&(\\\"auto\\\"!=f.data(\\\"top\\\")?f.css(\\\"top\\\",b.helpers.getPX(f.data(\\\"top\\\"))+j):f.data(\\\"top\\\",\\\"auto\\\")),f.css(\\\"bottom\\\")&&(\\\"auto\\\"!=f.data(\\\"bottom\\\")?f.css(\\\"bottom\\\",b.helpers.getPX(f.data(\\\"bottom\\\"))+k):f.css(\\\"bottom\\\",\\\"auto\\\")))):f.hasClass(\\\"fr-sticky-off\\\")||(f.width(\\\"\\\"),f.removeClass(\\\"fr-sticky-on\\\"),f.addClass(\\\"fr-sticky-off\\\"),f.css(\\\"top\\\")&&\\\"auto\\\"!=f.css(\\\"top\\\")&&f.css(\\\"top\\\",0),f.css(\\\"bottom\\\")&&f.css(\\\"bottom\\\",0))}}function j(){var a=document.createElement(\\\"test\\\"),c=a.style;return c.cssText=\\\"position:\\\"+[\\\"-webkit-\\\",\\\"-moz-\\\",\\\"-ms-\\\",\\\"-o-\\\",\\\"\\\"].join(\\\"sticky; position:\\\")+\\\" sticky;\\\",-1!==c.position.indexOf(\\\"sticky\\\")&&!b.helpers.isIOS()&&!b.helpers.isAndroid()}function k(){if(!j())if(b._stickyElements=[],b.helpers.isIOS()){var c=function(){b.helpers.requestAnimationFrame()(c);for(var a=0;a<b._stickyElements.length;a++)h(b._stickyElements[a])};c(),b.events.$on(a(b.o_win),\\\"scroll\\\",function(){if(b.core.hasFocus())for(var c=0;c<b._stickyElements.length;c++){var d=a(b._stickyElements[c]),e=d.parent(),f=a(window).scrollTop();d.outerHeight()<f-e.offset().top&&(d.addClass(\\\"fr-opacity-0\\\"),d.data(\\\"sticky-top\\\",-1),d.data(\\\"sticky-scheduled\\\",-1))}},!0)}else b.events.$on(a(\\\"body\\\"==b.opts.scrollableContainer?b.o_win:b.opts.scrollableContainer),\\\"scroll\\\",l,!0),b.events.$on(a(b.o_win),\\\"resize\\\",l,!0),b.events.on(\\\"initialized\\\",l),b.events.on(\\\"focus\\\",l),b.events.$on(a(b.o_win),\\\"resize\\\",\\\"textarea\\\",l,!0);b.events.on(\\\"destroy\\\",function(a){b._stickyElements=[]})}function l(){for(var a=0;a<b._stickyElements.length;a++)i(b._stickyElements[a])}function m(a){a.addClass(\\\"fr-sticky\\\"),b.helpers.isIOS()&&a.addClass(\\\"fr-sticky-ios\\\"),j()||b._stickyElements.push(a.get(0))}function n(){k()}return{_init:n,forSelection:f,addSticky:m,refresh:l,at:g,getBoundingRect:c}},a.FE.MODULES.refresh=function(b){function c(a){a.toggleClass(\\\"fr-disabled\\\",!b.undo.canDo())}function d(a){a.toggleClass(\\\"fr-disabled\\\",!b.undo.canRedo())}function e(a){if(a.hasClass(\\\"fr-no-refresh\\\"))return!1;for(var c=b.selection.blocks(),d=0;d<c.length;d++){for(var e=c[d].previousSibling;e&&e.nodeType==Node.TEXT_NODE&&0===e.textContent.length;)e=e.previousSibling;if(\\\"LI\\\"!=c[d].tagName||e)return a.removeClass(\\\"fr-disabled\\\"),!0;a.addClass(\\\"fr-disabled\\\")}}function f(c){if(c.hasClass(\\\"fr-no-refresh\\\"))return!1;for(var d=b.selection.blocks(),e=0;e<d.length;e++){var f=\\\"rtl\\\"==b.opts.direction||\\\"rtl\\\"==a(d[e]).css(\\\"direction\\\")?\\\"margin-right\\\":\\\"margin-left\\\";if(\\\"LI\\\"==d[e].tagName||\\\"LI\\\"==d[e].parentNode.tagName)return c.removeClass(\\\"fr-disabled\\\"),!0;if(b.helpers.getPX(a(d[e]).css(f))>0)return c.removeClass(\\\"fr-disabled\\\"),!0}c.addClass(\\\"fr-disabled\\\")}return{undo:c,redo:d,outdent:f,indent:e}},a.extend(a.FE.DEFAULTS,{editInPopup:!1}),a.FE.MODULES.textEdit=function(b){function c(){var a='<div id=\\\"fr-text-edit-'+b.id+'\\\" class=\\\"fr-layer fr-text-edit-layer\\\"><div class=\\\"fr-input-line\\\"><input type=\\\"text\\\" placeholder=\\\"'+b.language.translate(\\\"Text\\\")+'\\\" tabIndex=\\\"1\\\"></div><div class=\\\"fr-action-buttons\\\"><button type=\\\"button\\\" class=\\\"fr-command fr-submit\\\" data-cmd=\\\"updateText\\\" tabIndex=\\\"2\\\">'+b.language.translate(\\\"Update\\\")+\\\"</button></div></div>\\\",c={edit:a};b.popups.create(\\\"text.edit\\\",c)}function d(){var c,d=b.popups.get(\\\"text.edit\\\");c=\\\"INPUT\\\"===b.$el.prop(\\\"tagName\\\")?b.$el.attr(\\\"placeholder\\\"):b.$el.text(),d.find(\\\"input\\\").val(c).trigger(\\\"change\\\"),b.popups.setContainer(\\\"text.edit\\\",a(\\\"body\\\")),b.popups.show(\\\"text.edit\\\",b.$el.offset().left+b.$el.outerWidth()/2,b.$el.offset().top+b.$el.outerHeight(),b.$el.outerHeight())}function e(){b.events.$on(b.$el,b._mouseup,function(a){setTimeout(function(){d()},10)})}function f(){var a=b.popups.get(\\\"text.edit\\\"),c=a.find(\\\"input\\\").val();0==c.length&&(c=b.opts.placeholderText),\\\"INPUT\\\"===b.$el.prop(\\\"tagName\\\")?b.$el.attr(\\\"placeholder\\\",c):b.$el.text(c),b.events.trigger(\\\"contentChanged\\\"),b.popups.hide(\\\"text.edit\\\")}function g(){b.opts.editInPopup&&(c(),e())}return{_init:g,update:f}},a.FE.RegisterCommand(\\\"updateText\\\",{focus:!1,undo:!1,callback:function(){this.textEdit.update()}}),a.extend(a.FE.DEFAULTS,{toolbarBottom:!1,toolbarButtons:[\\\"fullscreen\\\",\\\"bold\\\",\\\"italic\\\",\\\"underline\\\",\\\"strikeThrough\\\",\\\"subscript\\\",\\\"superscript\\\",\\\"fontFamily\\\",\\\"fontSize\\\",\\\"|\\\",\\\"color\\\",\\\"emoticons\\\",\\\"inlineStyle\\\",\\\"paragraphStyle\\\",\\\"|\\\",\\\"paragraphFormat\\\",\\\"align\\\",\\\"formatOL\\\",\\\"formatUL\\\",\\\"outdent\\\",\\\"indent\\\",\\\"quote\\\",\\\"insertHR\\\",\\\"-\\\",\\\"insertLink\\\",\\\"insertImage\\\",\\\"insertVideo\\\",\\\"insertFile\\\",\\\"insertTable\\\",\\\"undo\\\",\\\"redo\\\",\\\"clearFormatting\\\",\\\"selectAll\\\",\\\"html\\\",\\\"applyFormat\\\",\\\"removeFormat\\\"],toolbarButtonsXS:[\\\"bold\\\",\\\"italic\\\",\\\"fontFamily\\\",\\\"fontSize\\\",\\\"|\\\",\\\"undo\\\",\\\"redo\\\"],toolbarButtonsSM:[\\\"bold\\\",\\\"italic\\\",\\\"underline\\\",\\\"|\\\",\\\"fontFamily\\\",\\\"fontSize\\\",\\\"insertLink\\\",\\\"insertImage\\\",\\\"table\\\",\\\"|\\\",\\\"undo\\\",\\\"redo\\\"],toolbarButtonsMD:[\\\"fullscreen\\\",\\\"bold\\\",\\\"italic\\\",\\\"underline\\\",\\\"fontFamily\\\",\\\"fontSize\\\",\\\"color\\\",\\\"paragraphStyle\\\",\\\"paragraphFormat\\\",\\\"align\\\",\\\"formatOL\\\",\\\"formatUL\\\",\\\"outdent\\\",\\\"indent\\\",\\\"quote\\\",\\\"insertHR\\\",\\\"-\\\",\\\"insertLink\\\",\\\"insertImage\\\",\\\"insertVideo\\\",\\\"insertFile\\\",\\\"insertTable\\\",\\\"undo\\\",\\\"redo\\\",\\\"clearFormatting\\\"],toolbarContainer:null,toolbarInline:!1,toolbarSticky:!0,toolbarStickyOffset:0,toolbarVisibleWithoutSelection:!1}),a.FE.MODULES.toolbar=function(b){function c(a,b){for(var c=0;c<b.length;c++)\\\"-\\\"!=b[c]&&\\\"|\\\"!=b[c]&&a.indexOf(b[c])<0&&a.push(b[c])}function d(){var d=a.merge([],e());c(d,b.opts.toolbarButtonsXS||[]),c(d,b.opts.toolbarButtonsSM||[]),c(d,b.opts.toolbarButtonsMD||[]),c(d,b.opts.toolbarButtons);for(var f=d.length-1;f>=0;f--)\\\"-\\\"!=d[f]&&\\\"|\\\"!=d[f]&&d.indexOf(d[f])<f&&d.splice(f,1);var g=b.button.buildList(d,e());b.$tb.append(g),b.button.bindCommands(b.$tb)}function e(){var a=b.helpers.screenSize();return u[a]}function f(){var a=e();b.$tb.find(\\\".fr-separator\\\").remove(),b.$tb.find(\\\"> .fr-command\\\").addClass(\\\"fr-hidden\\\");for(var c=0;c<a.length;c++)if(\\\"|\\\"==a[c]||\\\"-\\\"==a[c])b.$tb.append(b.button.buildList([a[c]]));else{var d=b.$tb.find('> .fr-command[data-cmd=\\\"'+a[c]+'\\\"]'),f=null;d.next().hasClass(\\\"fr-dropdown-menu\\\")&&(f=d.next()),d.removeClass(\\\"fr-hidden\\\").appendTo(b.$tb),f&&f.appendTo(b.$tb)}}function g(){b.events.$on(a(b.o_win),\\\"resize\\\",f,!0),b.events.$on(a(b.o_win),\\\"orientationchange\\\",f,!0)}function h(c,d){setTimeout(function(){if(c&&c.which==a.FE.KEYCODE.ESC);else if(b.selection.inEditor()&&b.core.hasFocus()&&!b.popups.areVisible()&&(b.opts.toolbarVisibleWithoutSelection&&c&&\\\"keyup\\\"!=c.type||!b.selection.isCollapsed()&&!b.keys.isIME()||d)){if(b.$tb.data(\\\"instance\\\",b),0==b.events.trigger(\\\"toolbar.show\\\",[c]))return!1;b.opts.toolbarContainer||b.position.forSelection(b.$tb),b.$tb.show()}},0)}function i(c){var d=a(\\\".fr-dropdown.fr-active\\\");return d.next().find(b.o_doc.activeElement).length?!0:void(b.events.trigger(\\\"toolbar.hide\\\")!==!1&&b.$tb.hide())}function j(){return 0==b.events.trigger(\\\"toolbar.show\\\")?!1:void b.$tb.show()}function k(){b.events.on(\\\"window.mousedown\\\",i),b.events.on(\\\"keydown\\\",i),b.events.on(\\\"blur\\\",i),b.events.on(\\\"window.mouseup\\\",h),b.helpers.isMobile()?b.helpers.isIOS()||(b.events.on(\\\"window.touchend\\\",h),b.browser.mozilla&&setInterval(h,200)):b.events.on(\\\"window.keyup\\\",h),b.events.on(\\\"keydown\\\",function(b){b&&b.which==a.FE.KEYCODE.ESC&&i()}),b.events.$on(b.$wp,\\\"scroll.toolbar\\\",h),b.events.on(\\\"commands.after\\\",h),b.helpers.isMobile()&&(b.events.$on(b.$doc,\\\"selectionchange\\\",h),b.events.$on(b.$doc,\\\"orientationchange\\\",h))}function l(){b.opts.toolbarInline?(a(b.opts.scrollableContainer).append(b.$tb),b.$tb.data(\\\"container\\\",a(b.opts.scrollableContainer)),b.$tb.addClass(\\\"fr-inline\\\"),b.$tb.prepend('<span class=\\\"fr-arrow\\\"></span>'),k(),b.opts.toolbarBottom=!1):(b.opts.toolbarBottom&&!b.helpers.isIOS()?(b.$box.append(b.$tb),b.$tb.addClass(\\\"fr-bottom\\\"),b.$box.addClass(\\\"fr-bottom\\\")):(b.opts.toolbarBottom=!1,b.$box.prepend(b.$tb),b.$tb.addClass(\\\"fr-top\\\"),b.$box.addClass(\\\"fr-top\\\")),b.$tb.addClass(\\\"fr-basic\\\"),b.opts.toolbarSticky&&(b.opts.toolbarStickyOffset&&(b.opts.toolbarBottom?b.$tb.css(\\\"bottom\\\",b.opts.toolbarStickyOffset):b.$tb.css(\\\"top\\\",b.opts.toolbarStickyOffset)),b.position.addSticky(b.$tb)))}function m(){b.$tb.html(\\\"\\\").removeData().remove(),b.$tb=null}function n(){b.$box.removeClass(\\\"fr-top fr-bottom fr-inline fr-basic\\\"),b.$box.find(\\\".fr-sticky-dummy\\\").remove()}function o(){b.opts.theme&&b.$tb.addClass(b.opts.theme+\\\"-theme\\\"),b.opts.zIndex>1&&b.$tb.css(\\\"z-index\\\",b.opts.zIndex+1),\\\"auto\\\"!=b.opts.direction&&b.$tb.removeClass(\\\"fr-ltr fr-rtl\\\").addClass(\\\"fr-\\\"+b.opts.direction),b.helpers.isMobile()?b.$tb.addClass(\\\"fr-mobile\\\"):b.$tb.addClass(\\\"fr-desktop\\\"),b.opts.toolbarContainer?(b.opts.toolbarInline&&(k(),i()),b.opts.toolbarBottom?b.$tb.addClass(\\\"fr-bottom\\\"):b.$tb.addClass(\\\"fr-top\\\")):l(),s=b.$tb.get(0).ownerDocument,t=\\\"defaultView\\\"in s?s.defaultView:s.parentWindow,d(),g(),b.events.$on(b.$tb,b._mousedown+\\\" \\\"+b._mouseup,function(a){var c=a.originalEvent?a.originalEvent.target||a.originalEvent.originalTarget:null;return c&&\\\"INPUT\\\"!=c.tagName&&!b.edit.isDisabled()?(a.stopPropagation(),a.preventDefault(),!1):void 0},!0)}function p(){return b.$wp?(b.opts.toolbarContainer?(b.shared.$tb?(b.$tb=b.shared.$tb,b.opts.toolbarInline&&k()):(b.shared.$tb=a('<div class=\\\"fr-toolbar\\\"></div>'),b.$tb=b.shared.$tb,a(b.opts.toolbarContainer).append(b.$tb),o(),b.$tb.data(\\\"instance\\\",b)),b.opts.toolbarInline?b.$box.addClass(\\\"fr-inline\\\"):b.$box.addClass(\\\"fr-basic\\\"),b.events.on(\\\"focus\\\",function(){b.$tb.data(\\\"instance\\\",b)},!0),b.opts.toolbarInline=!1):b.opts.toolbarInline?(b.$box.addClass(\\\"fr-inline\\\"),b.shared.$tb?(b.$tb=b.shared.$tb,k()):(b.shared.$tb=a('<div class=\\\"fr-toolbar\\\"></div>'),b.$tb=b.shared.$tb,o())):(b.$box.addClass(\\\"fr-basic\\\"),b.$tb=a('<div class=\\\"fr-toolbar\\\"></div>'),o(),b.$tb.data(\\\"instance\\\",b)),b.events.on(\\\"destroy\\\",n,!0),void b.events.on(b.opts.toolbarInline?\\\"shared.destroy\\\":\\\"destroy\\\",m,!0)):!1}function q(){!v&&b.$tb&&(b.$tb.find(\\\"> .fr-command\\\").addClass(\\\"fr-disabled fr-no-refresh\\\"),v=!0)}function r(){v&&b.$tb&&(b.$tb.find(\\\"> .fr-command\\\").removeClass(\\\"fr-disabled fr-no-refresh\\\"),v=!1),b.button.bulkRefresh()}var s,t,u=[];u[a.FE.XS]=b.opts.toolbarButtonsXS||b.opts.toolbarButtons,u[a.FE.SM]=b.opts.toolbarButtonsSM||b.opts.toolbarButtons,u[a.FE.MD]=b.opts.toolbarButtonsMD||b.opts.toolbarButtons,u[a.FE.LG]=b.opts.toolbarButtons;var v=!1;return{_init:p,hide:i,show:j,showInline:h,disable:q,enable:r}}});\"//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL34vZnJvYWxhLWVkaXRvci9qcy9mcm9hbGFfZWRpdG9yLm1pbi5qcz81NDRiIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gXCIvKiFcXG4gKiBmcm9hbGFfZWRpdG9yIHYyLjMuNCAoaHR0cHM6Ly93d3cuZnJvYWxhLmNvbS93eXNpd3lnLWVkaXRvcilcXG4gKiBMaWNlbnNlIGh0dHBzOi8vZnJvYWxhLmNvbS93eXNpd3lnLWVkaXRvci90ZXJtcy9cXG4gKiBDb3B5cmlnaHQgMjAxNC0yMDE2IEZyb2FsYSBMYWJzXFxuICovXFxuXFxuIWZ1bmN0aW9uKGEpe1xcXCJmdW5jdGlvblxcXCI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQ/ZGVmaW5lKFtcXFwianF1ZXJ5XFxcIl0sYSk6XFxcIm9iamVjdFxcXCI9PXR5cGVvZiBtb2R1bGUmJm1vZHVsZS5leHBvcnRzP21vZHVsZS5leHBvcnRzPWZ1bmN0aW9uKGIsYyl7cmV0dXJuIHZvaWQgMD09PWMmJihjPVxcXCJ1bmRlZmluZWRcXFwiIT10eXBlb2Ygd2luZG93P3JlcXVpcmUoXFxcImpxdWVyeVxcXCIpOnJlcXVpcmUoXFxcImpxdWVyeVxcXCIpKGIpKSxhKGMpLGN9OmEoalF1ZXJ5KX0oZnVuY3Rpb24oYSl7XFxcInVzZSBzdHJpY3RcXFwiO3ZhciBiPWZ1bmN0aW9uKGMsZCl7dGhpcy5pZD0rK2EuRkUuSUQsdGhpcy5vcHRzPWEuZXh0ZW5kKCEwLHt9LGEuZXh0ZW5kKHt9LGIuREVGQVVMVFMsXFxcIm9iamVjdFxcXCI9PXR5cGVvZiBkJiZkKSk7dmFyIGU9SlNPTi5zdHJpbmdpZnkodGhpcy5vcHRzKTthLkZFLk9QVFNfTUFQUElOR1tlXT1hLkZFLk9QVFNfTUFQUElOR1tlXXx8dGhpcy5pZCx0aGlzLnNpZD1hLkZFLk9QVFNfTUFQUElOR1tlXSxhLkZFLlNIQVJFRFt0aGlzLnNpZF09YS5GRS5TSEFSRURbdGhpcy5zaWRdfHx7fSx0aGlzLnNoYXJlZD1hLkZFLlNIQVJFRFt0aGlzLnNpZF0sdGhpcy5zaGFyZWQuY291bnQ9KHRoaXMuc2hhcmVkLmNvdW50fHwwKSsxLHRoaXMuJG9lbD1hKGMpLHRoaXMuJG9lbC5kYXRhKFxcXCJmcm9hbGEuZWRpdG9yXFxcIix0aGlzKSx0aGlzLm9fZG9jPWMub3duZXJEb2N1bWVudCx0aGlzLm9fd2luPVxcXCJkZWZhdWx0Vmlld1xcXCJpbiB0aGlzLm9fZG9jP3RoaXMub19kb2MuZGVmYXVsdFZpZXc6dGhpcy5vX2RvYy5wYXJlbnRXaW5kb3c7dmFyIGY9YSh0aGlzLm9fd2luKS5zY3JvbGxUb3AoKTt0aGlzLiRvZWwub24oXFxcImZyb2FsYS5kb0luaXRcXFwiLGEucHJveHkoZnVuY3Rpb24oKXt0aGlzLiRvZWwub2ZmKFxcXCJmcm9hbGEuZG9Jbml0XFxcIiksdGhpcy5kb2M9dGhpcy4kZWwuZ2V0KDApLm93bmVyRG9jdW1lbnQsdGhpcy53aW49XFxcImRlZmF1bHRWaWV3XFxcImluIHRoaXMuZG9jP3RoaXMuZG9jLmRlZmF1bHRWaWV3OnRoaXMuZG9jLnBhcmVudFdpbmRvdyx0aGlzLiRkb2M9YSh0aGlzLmRvYyksdGhpcy4kd2luPWEodGhpcy53aW4pLHRoaXMub3B0cy5wbHVnaW5zRW5hYmxlZHx8KHRoaXMub3B0cy5wbHVnaW5zRW5hYmxlZD1PYmplY3Qua2V5cyhhLkZFLlBMVUdJTlMpKSx0aGlzLm9wdHMuaW5pdE9uQ2xpY2s/KHRoaXMubG9hZChhLkZFLk1PRFVMRVMpLHRoaXMuJGVsLm9uKFxcXCJ0b3VjaHN0YXJ0LmluaXRcXFwiLGZ1bmN0aW9uKCl7YSh0aGlzKS5kYXRhKFxcXCJ0b3VjaGVkXFxcIiwhMCl9KSx0aGlzLiRlbC5vbihcXFwidG91Y2htb3ZlLmluaXRcXFwiLGZ1bmN0aW9uKCl7YSh0aGlzKS5yZW1vdmVEYXRhKFxcXCJ0b3VjaGVkXFxcIil9KSx0aGlzLiRlbC5vbihcXFwibW91c2Vkb3duLmluaXQgdG91Y2hlbmQuaW5pdCBkcmFnZW50ZXIuaW5pdCBmb2N1cy5pbml0XFxcIixhLnByb3h5KGZ1bmN0aW9uKGIpe2lmKFxcXCJ0b3VjaGVuZFxcXCI9PWIudHlwZSYmIXRoaXMuJGVsLmRhdGEoXFxcInRvdWNoZWRcXFwiKSlyZXR1cm4hMDtpZigxPT09Yi53aGljaHx8MD09PWIud2hpY2gpe3RoaXMuJGVsLm9mZihcXFwibW91c2Vkb3duLmluaXQgdG91Y2hzdGFydC5pbml0IHRvdWNobW92ZS5pbml0IHRvdWNoZW5kLmluaXQgZHJhZ2VudGVyLmluaXQgZm9jdXMuaW5pdFxcXCIpLHRoaXMubG9hZChhLkZFLk1PRFVMRVMpLHRoaXMubG9hZChhLkZFLlBMVUdJTlMpO3ZhciBjPWIub3JpZ2luYWxFdmVudCYmYi5vcmlnaW5hbEV2ZW50Lm9yaWdpbmFsVGFyZ2V0O2MmJlxcXCJJTUdcXFwiPT1jLnRhZ05hbWUmJmEoYykudHJpZ2dlcihcXFwibW91c2Vkb3duXFxcIiksXFxcInVuZGVmaW5lZFxcXCI9PXR5cGVvZiB0aGlzLnVsJiZ0aGlzLmRlc3Ryb3koKSxcXFwidG91Y2hlbmRcXFwiPT1iLnR5cGUmJnRoaXMuaW1hZ2UmJmIub3JpZ2luYWxFdmVudCYmYi5vcmlnaW5hbEV2ZW50LnRhcmdldCYmYShiLm9yaWdpbmFsRXZlbnQudGFyZ2V0KS5pcyhcXFwiaW1nXFxcIikmJnNldFRpbWVvdXQoYS5wcm94eShmdW5jdGlvbigpe3RoaXMuaW1hZ2UuZWRpdChhKGIub3JpZ2luYWxFdmVudC50YXJnZXQpKX0sdGhpcyksMTAwKSx0aGlzLmV2ZW50cy50cmlnZ2VyKFxcXCJpbml0aWFsaXplZFxcXCIpfX0sdGhpcykpKToodGhpcy5sb2FkKGEuRkUuTU9EVUxFUyksdGhpcy5sb2FkKGEuRkUuUExVR0lOUyksYSh0aGlzLm9fd2luKS5zY3JvbGxUb3AoZiksXFxcInVuZGVmaW5lZFxcXCI9PXR5cGVvZiB0aGlzLnVsJiZ0aGlzLmRlc3Ryb3koKSx0aGlzLmV2ZW50cy50cmlnZ2VyKFxcXCJpbml0aWFsaXplZFxcXCIpKX0sdGhpcykpLHRoaXMuX2luaXQoKX07Yi5ERUZBVUxUUz17aW5pdE9uQ2xpY2s6ITEscGx1Z2luc0VuYWJsZWQ6bnVsbH0sYi5NT0RVTEVTPXt9LGIuUExVR0lOUz17fSxiLlZFUlNJT049XFxcIjIuMy40XFxcIixiLklOU1RBTkNFUz1bXSxiLk9QVFNfTUFQUElORz17fSxiLlNIQVJFRD17fSxiLklEPTAsYi5wcm90b3R5cGUuX2luaXQ9ZnVuY3Rpb24oKXt2YXIgYj10aGlzLiRvZWwucHJvcChcXFwidGFnTmFtZVxcXCIpLGM9YS5wcm94eShmdW5jdGlvbigpe3RoaXMuX29yaWdpbmFsX2h0bWw9dGhpcy5fb3JpZ2luYWxfaHRtbHx8dGhpcy4kb2VsLmh0bWwoKSx0aGlzLiRib3g9dGhpcy4kYm94fHx0aGlzLiRvZWwsdGhpcy5vcHRzLmZ1bGxQYWdlJiYodGhpcy5vcHRzLmlmcmFtZT0hMCksdGhpcy5vcHRzLmlmcmFtZT8odGhpcy4kaWZyYW1lPWEoJzxpZnJhbWUgc3JjPVxcXCJhYm91dDpibGFua1xcXCIgZnJhbWVCb3JkZXI9XFxcIjBcXFwiPicpLHRoaXMuJHdwPWEoXFxcIjxkaXY+PC9kaXY+XFxcIiksdGhpcy4kYm94Lmh0bWwodGhpcy4kd3ApLHRoaXMuJHdwLmFwcGVuZCh0aGlzLiRpZnJhbWUpLHRoaXMuJGlmcmFtZS5nZXQoMCkuY29udGVudFdpbmRvdy5kb2N1bWVudC5vcGVuKCksdGhpcy4kaWZyYW1lLmdldCgwKS5jb250ZW50V2luZG93LmRvY3VtZW50LndyaXRlKFxcXCI8IURPQ1RZUEUgaHRtbD5cXFwiKSx0aGlzLiRpZnJhbWUuZ2V0KDApLmNvbnRlbnRXaW5kb3cuZG9jdW1lbnQud3JpdGUoXFxcIjxodG1sPjxoZWFkPjwvaGVhZD48Ym9keT48L2JvZHk+PC9odG1sPlxcXCIpLHRoaXMuJGlmcmFtZS5nZXQoMCkuY29udGVudFdpbmRvdy5kb2N1bWVudC5jbG9zZSgpLHRoaXMuJGVsPXRoaXMuJGlmcmFtZS5jb250ZW50cygpLmZpbmQoXFxcImJvZHlcXFwiKSx0aGlzLiRoZWFkPXRoaXMuJGlmcmFtZS5jb250ZW50cygpLmZpbmQoXFxcImhlYWRcXFwiKSx0aGlzLiRodG1sPXRoaXMuJGlmcmFtZS5jb250ZW50cygpLmZpbmQoXFxcImh0bWxcXFwiKSx0aGlzLmlmcmFtZV9kb2N1bWVudD10aGlzLiRpZnJhbWUuZ2V0KDApLmNvbnRlbnRXaW5kb3cuZG9jdW1lbnQsdGhpcy4kb2VsLnRyaWdnZXIoXFxcImZyb2FsYS5kb0luaXRcXFwiKSk6KHRoaXMuJGVsPWEoXFxcIjxkaXY+PC9kaXY+XFxcIiksdGhpcy4kd3A9YShcXFwiPGRpdj48L2Rpdj5cXFwiKS5hcHBlbmQodGhpcy4kZWwpLHRoaXMuJGJveC5odG1sKHRoaXMuJHdwKSx0aGlzLiRvZWwudHJpZ2dlcihcXFwiZnJvYWxhLmRvSW5pdFxcXCIpKX0sdGhpcyksZD1hLnByb3h5KGZ1bmN0aW9uKCl7dGhpcy4kYm94PWEoXFxcIjxkaXY+XFxcIiksdGhpcy4kb2VsLmJlZm9yZSh0aGlzLiRib3gpLmhpZGUoKSx0aGlzLl9vcmlnaW5hbF9odG1sPXRoaXMuJG9lbC52YWwoKSx0aGlzLiRvZWwucGFyZW50cyhcXFwiZm9ybVxcXCIpLm9uKFxcXCJzdWJtaXQuXFxcIit0aGlzLmlkLGEucHJveHkoZnVuY3Rpb24oKXt0aGlzLmV2ZW50cy50cmlnZ2VyKFxcXCJmb3JtLnN1Ym1pdFxcXCIpfSx0aGlzKSksdGhpcy4kb2VsLnBhcmVudHMoXFxcImZvcm1cXFwiKS5vbihcXFwicmVzZXQuXFxcIit0aGlzLmlkLGEucHJveHkoZnVuY3Rpb24oKXt0aGlzLmV2ZW50cy50cmlnZ2VyKFxcXCJmb3JtLnJlc2V0XFxcIil9LHRoaXMpKSxjKCl9LHRoaXMpLGU9YS5wcm94eShmdW5jdGlvbigpe3RoaXMuJGVsPXRoaXMuJG9lbCx0aGlzLiRlbC5hdHRyKFxcXCJjb250ZW50ZWRpdGFibGVcXFwiLCEwKS5jc3MoXFxcIm91dGxpbmVcXFwiLFxcXCJub25lXFxcIikuY3NzKFxcXCJkaXNwbGF5XFxcIixcXFwiaW5saW5lLWJsb2NrXFxcIiksdGhpcy5vcHRzLm11bHRpTGluZT0hMSx0aGlzLm9wdHMudG9vbGJhcklubGluZT0hMSx0aGlzLiRvZWwudHJpZ2dlcihcXFwiZnJvYWxhLmRvSW5pdFxcXCIpfSx0aGlzKSxmPWEucHJveHkoZnVuY3Rpb24oKXt0aGlzLiRlbD10aGlzLiRvZWwsdGhpcy5vcHRzLnRvb2xiYXJJbmxpbmU9ITEsdGhpcy4kb2VsLnRyaWdnZXIoXFxcImZyb2FsYS5kb0luaXRcXFwiKX0sdGhpcyksZz1hLnByb3h5KGZ1bmN0aW9uKCl7dGhpcy4kZWw9dGhpcy4kb2VsLHRoaXMub3B0cy50b29sYmFySW5saW5lPSExLHRoaXMuJG9lbC5vbihcXFwiY2xpY2sucG9wdXBcXFwiLGZ1bmN0aW9uKGEpe2EucHJldmVudERlZmF1bHQoKX0pLHRoaXMuJG9lbC50cmlnZ2VyKFxcXCJmcm9hbGEuZG9Jbml0XFxcIil9LHRoaXMpO3RoaXMub3B0cy5lZGl0SW5Qb3B1cD9nKCk6XFxcIlRFWFRBUkVBXFxcIj09Yj9kKCk6XFxcIkFcXFwiPT1iP2UoKTpcXFwiSU1HXFxcIj09Yj9mKCk6XFxcIkJVVFRPTlxcXCI9PWJ8fFxcXCJJTlBVVFxcXCI9PWI/KHRoaXMub3B0cy5lZGl0SW5Qb3B1cD0hMCx0aGlzLm9wdHMudG9vbGJhcklubGluZT0hMSxnKCkpOmMoKX0sYi5wcm90b3R5cGUubG9hZD1mdW5jdGlvbihiKXtmb3IodmFyIGMgaW4gYilpZihiLmhhc093blByb3BlcnR5KGMpKXtpZih0aGlzW2NdKWNvbnRpbnVlO2lmKGEuRkUuUExVR0lOU1tjXSYmdGhpcy5vcHRzLnBsdWdpbnNFbmFibGVkLmluZGV4T2YoYyk8MCljb250aW51ZTtpZih0aGlzW2NdPW5ldyBiW2NdKHRoaXMpLHRoaXNbY10uX2luaXQmJih0aGlzW2NdLl9pbml0KCksdGhpcy5vcHRzLmluaXRPbkNsaWNrJiZcXFwiY29yZVxcXCI9PWMpKXJldHVybiExfX0sYi5wcm90b3R5cGUuZGVzdHJveT1mdW5jdGlvbigpe3RoaXMuc2hhcmVkLmNvdW50LS0sdGhpcy5ldmVudHMuJG9mZigpO3ZhciBiPXRoaXMuaHRtbC5nZXQoKTtpZih0aGlzLmV2ZW50cy50cmlnZ2VyKFxcXCJkZXN0cm95XFxcIixbXSwhMCksdGhpcy5ldmVudHMudHJpZ2dlcihcXFwic2hhcmVkLmRlc3Ryb3lcXFwiLHZvaWQgMCwhMCksMD09PXRoaXMuc2hhcmVkLmNvdW50KXtmb3IodmFyIGMgaW4gdGhpcy5zaGFyZWQpdGhpcy5zaGFyZWQuaGFzT3duUHJvcGVydHkoYykmJihudWxsPT10aGlzLnNoYXJlZFtjXSxhLkZFLlNIQVJFRFt0aGlzLnNpZF1bY109bnVsbCk7YS5GRS5TSEFSRURbdGhpcy5zaWRdPXt9fXRoaXMuJG9lbC5wYXJlbnRzKFxcXCJmb3JtXFxcIikub2ZmKFxcXCIuXFxcIit0aGlzLmlkKSx0aGlzLiRvZWwub2ZmKFxcXCJjbGljay5wb3B1cFxcXCIpLHRoaXMuJG9lbC5yZW1vdmVEYXRhKFxcXCJmcm9hbGEuZWRpdG9yXFxcIiksdGhpcy5jb3JlLmRlc3Ryb3koYiksYS5GRS5JTlNUQU5DRVMuc3BsaWNlKGEuRkUuSU5TVEFOQ0VTLmluZGV4T2YodGhpcyksMSl9LGEuZm4uZnJvYWxhRWRpdG9yPWZ1bmN0aW9uKGMpe2Zvcih2YXIgZD1bXSxlPTA7ZTxhcmd1bWVudHMubGVuZ3RoO2UrKylkLnB1c2goYXJndW1lbnRzW2VdKTtpZihcXFwic3RyaW5nXFxcIj09dHlwZW9mIGMpe3ZhciBmPVtdO3JldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKXt2YXIgYj1hKHRoaXMpLGU9Yi5kYXRhKFxcXCJmcm9hbGEuZWRpdG9yXFxcIik7aWYoZSl7dmFyIGcsaDtpZihjLmluZGV4T2YoXFxcIi5cXFwiKT4wJiZlW2Muc3BsaXQoXFxcIi5cXFwiKVswXV0/KGVbYy5zcGxpdChcXFwiLlxcXCIpWzBdXSYmKGc9ZVtjLnNwbGl0KFxcXCIuXFxcIilbMF1dKSxoPWMuc3BsaXQoXFxcIi5cXFwiKVsxXSk6KGc9ZSxoPWMuc3BsaXQoXFxcIi5cXFwiKVswXSksIWdbaF0pcmV0dXJuIGEuZXJyb3IoXFxcIk1ldGhvZCBcXFwiK2MrXFxcIiBkb2VzIG5vdCBleGlzdCBpbiBGcm9hbGEgRWRpdG9yLlxcXCIpO3ZhciBpPWdbaF0uYXBwbHkoZSxkLnNsaWNlKDEpKTt2b2lkIDA9PT1pP2YucHVzaCh0aGlzKTowPT09Zi5sZW5ndGgmJmYucHVzaChpKX19KSwxPT1mLmxlbmd0aD9mWzBdOmZ9cmV0dXJuXFxcIm9iamVjdFxcXCIhPXR5cGVvZiBjJiZjP3ZvaWQgMDp0aGlzLmVhY2goZnVuY3Rpb24oKXt2YXIgZD1hKHRoaXMpLmRhdGEoXFxcImZyb2FsYS5lZGl0b3JcXFwiKTtpZighZCl7dmFyIGU9dGhpcztuZXcgYihlLGMpfX0pfSxhLmZuLmZyb2FsYUVkaXRvci5Db25zdHJ1Y3Rvcj1iLGEuRnJvYWxhRWRpdG9yPWIsYS5GRT1iLGEuRkUuTU9EVUxFUy5ub2RlPWZ1bmN0aW9uKGIpe2Z1bmN0aW9uIGMoYil7cmV0dXJuIGImJlxcXCJJRlJBTUVcXFwiIT1iLnRhZ05hbWU/YShiKS5jb250ZW50cygpOltdfWZ1bmN0aW9uIGQoYil7cmV0dXJuIGI/Yi5ub2RlVHlwZSE9Tm9kZS5FTEVNRU5UX05PREU/ITE6YS5GRS5CTE9DS19UQUdTLmluZGV4T2YoYi50YWdOYW1lLnRvTG93ZXJDYXNlKCkpPj0wOiExfWZ1bmN0aW9uIGUoZSxmKXtpZihhKGUpLmZpbmQoXFxcInRhYmxlXFxcIikubGVuZ3RoPjApcmV0dXJuITE7aWYoZS5xdWVyeVNlbGVjdG9yQWxsKGEuRkUuVk9JRF9FTEVNRU5UUy5qb2luKFxcXCIsXFxcIikpLmxlbmd0aC1lLnF1ZXJ5U2VsZWN0b3JBbGwoXFxcImJyXFxcIikubGVuZ3RoKXJldHVybiExO2lmKGUucXVlcnlTZWxlY3RvckFsbChiLm9wdHMuaHRtbEFsbG93ZWRFbXB0eVRhZ3Muam9pbihcXFwiOm5vdCguZnItbWFya2VyKSxcXFwiKStcXFwiOm5vdCguZnItbWFya2VyKVxcXCIpLmxlbmd0aClyZXR1cm4hMTtpZihlLnF1ZXJ5U2VsZWN0b3JBbGwoYS5GRS5CTE9DS19UQUdTLmpvaW4oXFxcIixcXFwiKSkubGVuZ3RoPjEpcmV0dXJuITE7aWYoZS5xdWVyeVNlbGVjdG9yQWxsKGIub3B0cy5odG1sRG9Ob3RXcmFwVGFncy5qb2luKFxcXCI6bm90KC5mci1tYXJrZXIpLFxcXCIpK1xcXCI6bm90KC5mci1tYXJrZXIpXFxcIikubGVuZ3RoKXJldHVybiExO3ZhciBnPWMoZSk7MT09Zy5sZW5ndGgmJmQoZ1swXSkmJihnPWMoZ1swXSkpO2Zvcih2YXIgaD0hMSxpPTA7aTxnLmxlbmd0aDtpKyspe3ZhciBqPWdbaV07aWYoIShmJiZhKGopLmhhc0NsYXNzKFxcXCJmci1tYXJrZXJcXFwiKXx8ai5ub2RlVHlwZT09Tm9kZS5URVhUX05PREUmJjA9PWoudGV4dENvbnRlbnQubGVuZ3RoKSl7aWYoXFxcIkJSXFxcIiE9ai50YWdOYW1lJiYoai50ZXh0Q29udGVudHx8XFxcIlxcXCIpLnJlcGxhY2UoL1xcXFx1MjAwQi9naSxcXFwiXFxcIikucmVwbGFjZSgvXFxcXG4vZyxcXFwiXFxcIikubGVuZ3RoPjApcmV0dXJuITE7aWYoaClyZXR1cm4hMTtcXFwiQlJcXFwiPT1qLnRhZ05hbWUmJihoPSEwKX19cmV0dXJuITB9ZnVuY3Rpb24gZihjKXtmb3IoO2MmJmMucGFyZW50Tm9kZSE9PWIuJGVsLmdldCgwKSYmKCFjLnBhcmVudE5vZGV8fCFhKGMucGFyZW50Tm9kZSkuaGFzQ2xhc3MoXFxcImZyLWlubmVyXFxcIikpOylpZihjPWMucGFyZW50Tm9kZSxkKGMpKXJldHVybiBjO3JldHVybiBudWxsfWZ1bmN0aW9uIGcoYyxlLGYpe2lmKFxcXCJ1bmRlZmluZWRcXFwiPT10eXBlb2YgZSYmKGU9W10pLFxcXCJ1bmRlZmluZWRcXFwiPT10eXBlb2YgZiYmKGY9ITApLGUucHVzaChiLiRlbC5nZXQoMCkpLGUuaW5kZXhPZihjLnBhcmVudE5vZGUpPj0wfHxjLnBhcmVudE5vZGUmJmEoYy5wYXJlbnROb2RlKS5oYXNDbGFzcyhcXFwiZnItaW5uZXJcXFwiKXx8Yy5wYXJlbnROb2RlJiZhLkZFLlNJTVBMRV9FTlRFUl9UQUdTLmluZGV4T2YoYy5wYXJlbnROb2RlLnRhZ05hbWUpPj0wJiZmKXJldHVybiBudWxsO2Zvcig7ZS5pbmRleE9mKGMucGFyZW50Tm9kZSk8MCYmYy5wYXJlbnROb2RlJiYhYShjLnBhcmVudE5vZGUpLmhhc0NsYXNzKFxcXCJmci1pbm5lclxcXCIpJiYoYS5GRS5TSU1QTEVfRU5URVJfVEFHUy5pbmRleE9mKGMucGFyZW50Tm9kZS50YWdOYW1lKTwwfHwhZikmJighZChjKXx8IWQoYy5wYXJlbnROb2RlKXx8IWYpOyljPWMucGFyZW50Tm9kZTtyZXR1cm4gY31mdW5jdGlvbiBoKGEpe3ZhciBiPXt9LGM9YS5hdHRyaWJ1dGVzO2lmKGMpZm9yKHZhciBkPTA7ZDxjLmxlbmd0aDtkKyspe3ZhciBlPWNbZF07YltlLm5vZGVOYW1lXT1lLnZhbHVlfXJldHVybiBifWZ1bmN0aW9uIGkoYSl7Zm9yKHZhciBiPVxcXCJcXFwiLGM9aChhKSxkPU9iamVjdC5rZXlzKGMpLnNvcnQoKSxlPTA7ZTxkLmxlbmd0aDtlKyspe3ZhciBmPWRbZV0sZz1jW2ZdO2IrPWcuaW5kZXhPZignXFxcIicpPDA/XFxcIiBcXFwiK2YrJz1cXFwiJytnKydcXFwiJzpcXFwiIFxcXCIrZitcXFwiPSdcXFwiK2crXFxcIidcXFwifXJldHVybiBifWZ1bmN0aW9uIGooYSl7Zm9yKHZhciBiPWEuYXR0cmlidXRlcyxjPTA7YzxiLmxlbmd0aDtjKyspe3ZhciBkPWJbY107YS5yZW1vdmVBdHRyaWJ1dGUoZC5ub2RlTmFtZSl9fWZ1bmN0aW9uIGsoYSl7cmV0dXJuXFxcIjxcXFwiK2EudGFnTmFtZS50b0xvd2VyQ2FzZSgpK2koYSkrXFxcIj5cXFwifWZ1bmN0aW9uIGwoYSl7cmV0dXJuXFxcIjwvXFxcIithLnRhZ05hbWUudG9Mb3dlckNhc2UoKStcXFwiPlxcXCJ9ZnVuY3Rpb24gbShiLGMpe1xcXCJ1bmRlZmluZWRcXFwiPT10eXBlb2YgYyYmKGM9ITApO2Zvcih2YXIgZD1iLnByZXZpb3VzU2libGluZztkJiZjJiZhKGQpLmhhc0NsYXNzKFxcXCJmci1tYXJrZXJcXFwiKTspZD1kLnByZXZpb3VzU2libGluZztyZXR1cm4gZD9kLm5vZGVUeXBlPT1Ob2RlLlRFWFRfTk9ERSYmXFxcIlxcXCI9PT1kLnRleHRDb250ZW50P20oZCk6ITE6ITB9ZnVuY3Rpb24gbihiLGMpe1xcXCJ1bmRlZmluZWRcXFwiPT10eXBlb2YgYyYmKGM9ITApO2Zvcih2YXIgZD1iLm5leHRTaWJsaW5nO2QmJmMmJmEoZCkuaGFzQ2xhc3MoXFxcImZyLW1hcmtlclxcXCIpOylkPWQubmV4dFNpYmxpbmc7cmV0dXJuIGQ/ZC5ub2RlVHlwZT09Tm9kZS5URVhUX05PREUmJlxcXCJcXFwiPT09ZC50ZXh0Q29udGVudD9uKGQpOiExOiEwfWZ1bmN0aW9uIG8oYil7cmV0dXJuIGImJmIubm9kZVR5cGU9PU5vZGUuRUxFTUVOVF9OT0RFJiZhLkZFLlZPSURfRUxFTUVOVFMuaW5kZXhPZigoYi50YWdOYW1lfHxcXFwiXFxcIikudG9Mb3dlckNhc2UoKSk+PTB9ZnVuY3Rpb24gcChhKXtyZXR1cm4gYT9bXFxcIlVMXFxcIixcXFwiT0xcXFwiXS5pbmRleE9mKGEudGFnTmFtZSk+PTA6ITF9ZnVuY3Rpb24gcShhKXtyZXR1cm4gYT09PWIuJGVsLmdldCgwKX1mdW5jdGlvbiByKGEpe3JldHVybiBhJiZhLmNsYXNzTmFtZSYmKGEuY2xhc3NOYW1lfHxcXFwiXFxcIikuaW5kZXhPZihcXFwiZnItZGVsZXRhYmxlXFxcIik+PTB9ZnVuY3Rpb24gcyhhKXtyZXR1cm4gYT09PWIuZG9jLmFjdGl2ZUVsZW1lbnQmJighYi5kb2MuaGFzRm9jdXN8fGIuZG9jLmhhc0ZvY3VzKCkpJiYhIShxKGEpfHxhLnR5cGV8fGEuaHJlZnx8fmEudGFiSW5kZXgpfWZ1bmN0aW9uIHQoYSl7cmV0dXJuKCFhLmdldEF0dHJpYnV0ZXx8XFxcImZhbHNlXFxcIiE9YS5nZXRBdHRyaWJ1dGUoXFxcImNvbnRlbnRlZGl0YWJsZVxcXCIpKSYmW1xcXCJTVFlMRVxcXCIsXFxcIlNDUklQVFxcXCJdLmluZGV4T2YoYS50YWdOYW1lKTwwfXJldHVybntpc0Jsb2NrOmQsaXNFbXB0eTplLGJsb2NrUGFyZW50OmYsZGVlcGVzdFBhcmVudDpnLHJhd0F0dHJpYnV0ZXM6aCxhdHRyaWJ1dGVzOmksY2xlYXJBdHRyaWJ1dGVzOmosb3BlblRhZ1N0cmluZzprLGNsb3NlVGFnU3RyaW5nOmwsaXNGaXJzdFNpYmxpbmc6bSxpc0xhc3RTaWJsaW5nOm4saXNMaXN0OnAsaXNFbGVtZW50OnEsY29udGVudHM6Yyxpc1ZvaWQ6byxoYXNGb2N1czpzLGlzRWRpdGFibGU6dCxpc0RlbGV0YWJsZTpyfX0sYS5leHRlbmQoYS5GRS5ERUZBVUxUUyx7aHRtbEFsbG93ZWRUYWdzOltcXFwiYVxcXCIsXFxcImFiYnJcXFwiLFxcXCJhZGRyZXNzXFxcIixcXFwiYXJlYVxcXCIsXFxcImFydGljbGVcXFwiLFxcXCJhc2lkZVxcXCIsXFxcImF1ZGlvXFxcIixcXFwiYlxcXCIsXFxcImJhc2VcXFwiLFxcXCJiZGlcXFwiLFxcXCJiZG9cXFwiLFxcXCJibG9ja3F1b3RlXFxcIixcXFwiYnJcXFwiLFxcXCJidXR0b25cXFwiLFxcXCJjYW52YXNcXFwiLFxcXCJjYXB0aW9uXFxcIixcXFwiY2l0ZVxcXCIsXFxcImNvZGVcXFwiLFxcXCJjb2xcXFwiLFxcXCJjb2xncm91cFxcXCIsXFxcImRhdGFsaXN0XFxcIixcXFwiZGRcXFwiLFxcXCJkZWxcXFwiLFxcXCJkZXRhaWxzXFxcIixcXFwiZGZuXFxcIixcXFwiZGlhbG9nXFxcIixcXFwiZGl2XFxcIixcXFwiZGxcXFwiLFxcXCJkdFxcXCIsXFxcImVtXFxcIixcXFwiZW1iZWRcXFwiLFxcXCJmaWVsZHNldFxcXCIsXFxcImZpZ2NhcHRpb25cXFwiLFxcXCJmaWd1cmVcXFwiLFxcXCJmb290ZXJcXFwiLFxcXCJmb3JtXFxcIixcXFwiaDFcXFwiLFxcXCJoMlxcXCIsXFxcImgzXFxcIixcXFwiaDRcXFwiLFxcXCJoNVxcXCIsXFxcImg2XFxcIixcXFwiaGVhZGVyXFxcIixcXFwiaGdyb3VwXFxcIixcXFwiaHJcXFwiLFxcXCJpXFxcIixcXFwiaWZyYW1lXFxcIixcXFwiaW1nXFxcIixcXFwiaW5wdXRcXFwiLFxcXCJpbnNcXFwiLFxcXCJrYmRcXFwiLFxcXCJrZXlnZW5cXFwiLFxcXCJsYWJlbFxcXCIsXFxcImxlZ2VuZFxcXCIsXFxcImxpXFxcIixcXFwibGlua1xcXCIsXFxcIm1haW5cXFwiLFxcXCJtYXBcXFwiLFxcXCJtYXJrXFxcIixcXFwibWVudVxcXCIsXFxcIm1lbnVpdGVtXFxcIixcXFwibWV0ZXJcXFwiLFxcXCJuYXZcXFwiLFxcXCJub3NjcmlwdFxcXCIsXFxcIm9iamVjdFxcXCIsXFxcIm9sXFxcIixcXFwib3B0Z3JvdXBcXFwiLFxcXCJvcHRpb25cXFwiLFxcXCJvdXRwdXRcXFwiLFxcXCJwXFxcIixcXFwicGFyYW1cXFwiLFxcXCJwcmVcXFwiLFxcXCJwcm9ncmVzc1xcXCIsXFxcInF1ZXVlXFxcIixcXFwicnBcXFwiLFxcXCJydFxcXCIsXFxcInJ1YnlcXFwiLFxcXCJzXFxcIixcXFwic2FtcFxcXCIsXFxcInNjcmlwdFxcXCIsXFxcInN0eWxlXFxcIixcXFwic2VjdGlvblxcXCIsXFxcInNlbGVjdFxcXCIsXFxcInNtYWxsXFxcIixcXFwic291cmNlXFxcIixcXFwic3BhblxcXCIsXFxcInN0cmlrZVxcXCIsXFxcInN0cm9uZ1xcXCIsXFxcInN1YlxcXCIsXFxcInN1bW1hcnlcXFwiLFxcXCJzdXBcXFwiLFxcXCJ0YWJsZVxcXCIsXFxcInRib2R5XFxcIixcXFwidGRcXFwiLFxcXCJ0ZXh0YXJlYVxcXCIsXFxcInRmb290XFxcIixcXFwidGhcXFwiLFxcXCJ0aGVhZFxcXCIsXFxcInRpbWVcXFwiLFxcXCJ0clxcXCIsXFxcInRyYWNrXFxcIixcXFwidVxcXCIsXFxcInVsXFxcIixcXFwidmFyXFxcIixcXFwidmlkZW9cXFwiLFxcXCJ3YnJcXFwiXSxodG1sUmVtb3ZlVGFnczpbXFxcInNjcmlwdFxcXCIsXFxcInN0eWxlXFxcIl0saHRtbEFsbG93ZWRBdHRyczpbXFxcImFjY2VwdFxcXCIsXFxcImFjY2VwdC1jaGFyc2V0XFxcIixcXFwiYWNjZXNza2V5XFxcIixcXFwiYWN0aW9uXFxcIixcXFwiYWxpZ25cXFwiLFxcXCJhbGxvd2Z1bGxzY3JlZW5cXFwiLFxcXCJhbGxvd3RyYW5zcGFyZW5jeVxcXCIsXFxcImFsdFxcXCIsXFxcImFzeW5jXFxcIixcXFwiYXV0b2NvbXBsZXRlXFxcIixcXFwiYXV0b2ZvY3VzXFxcIixcXFwiYXV0b3BsYXlcXFwiLFxcXCJhdXRvc2F2ZVxcXCIsXFxcImJhY2tncm91bmRcXFwiLFxcXCJiZ2NvbG9yXFxcIixcXFwiYm9yZGVyXFxcIixcXFwiY2hhcnNldFxcXCIsXFxcImNlbGxwYWRkaW5nXFxcIixcXFwiY2VsbHNwYWNpbmdcXFwiLFxcXCJjaGVja2VkXFxcIixcXFwiY2l0ZVxcXCIsXFxcImNsYXNzXFxcIixcXFwiY29sb3JcXFwiLFxcXCJjb2xzXFxcIixcXFwiY29sc3BhblxcXCIsXFxcImNvbnRlbnRcXFwiLFxcXCJjb250ZW50ZWRpdGFibGVcXFwiLFxcXCJjb250ZXh0bWVudVxcXCIsXFxcImNvbnRyb2xzXFxcIixcXFwiY29vcmRzXFxcIixcXFwiZGF0YVxcXCIsXFxcImRhdGEtLipcXFwiLFxcXCJkYXRldGltZVxcXCIsXFxcImRlZmF1bHRcXFwiLFxcXCJkZWZlclxcXCIsXFxcImRpclxcXCIsXFxcImRpcm5hbWVcXFwiLFxcXCJkaXNhYmxlZFxcXCIsXFxcImRvd25sb2FkXFxcIixcXFwiZHJhZ2dhYmxlXFxcIixcXFwiZHJvcHpvbmVcXFwiLFxcXCJlbmN0eXBlXFxcIixcXFwiZm9yXFxcIixcXFwiZm9ybVxcXCIsXFxcImZvcm1hY3Rpb25cXFwiLFxcXCJmcmFtZWJvcmRlclxcXCIsXFxcImhlYWRlcnNcXFwiLFxcXCJoZWlnaHRcXFwiLFxcXCJoaWRkZW5cXFwiLFxcXCJoaWdoXFxcIixcXFwiaHJlZlxcXCIsXFxcImhyZWZsYW5nXFxcIixcXFwiaHR0cC1lcXVpdlxcXCIsXFxcImljb25cXFwiLFxcXCJpZFxcXCIsXFxcImlzbWFwXFxcIixcXFwiaXRlbXByb3BcXFwiLFxcXCJrZXl0eXBlXFxcIixcXFwia2luZFxcXCIsXFxcImxhYmVsXFxcIixcXFwibGFuZ1xcXCIsXFxcImxhbmd1YWdlXFxcIixcXFwibGlzdFxcXCIsXFxcImxvb3BcXFwiLFxcXCJsb3dcXFwiLFxcXCJtYXhcXFwiLFxcXCJtYXhsZW5ndGhcXFwiLFxcXCJtZWRpYVxcXCIsXFxcIm1ldGhvZFxcXCIsXFxcIm1pblxcXCIsXFxcIm1vemFsbG93ZnVsbHNjcmVlblxcXCIsXFxcIm11bHRpcGxlXFxcIixcXFwibmFtZVxcXCIsXFxcIm5vdmFsaWRhdGVcXFwiLFxcXCJvcGVuXFxcIixcXFwib3B0aW11bVxcXCIsXFxcInBhdHRlcm5cXFwiLFxcXCJwaW5nXFxcIixcXFwicGxhY2Vob2xkZXJcXFwiLFxcXCJwb3N0ZXJcXFwiLFxcXCJwcmVsb2FkXFxcIixcXFwicHViZGF0ZVxcXCIsXFxcInJhZGlvZ3JvdXBcXFwiLFxcXCJyZWFkb25seVxcXCIsXFxcInJlbFxcXCIsXFxcInJlcXVpcmVkXFxcIixcXFwicmV2ZXJzZWRcXFwiLFxcXCJyb3dzXFxcIixcXFwicm93c3BhblxcXCIsXFxcInNhbmRib3hcXFwiLFxcXCJzY29wZVxcXCIsXFxcInNjb3BlZFxcXCIsXFxcInNjcm9sbGluZ1xcXCIsXFxcInNlYW1sZXNzXFxcIixcXFwic2VsZWN0ZWRcXFwiLFxcXCJzaGFwZVxcXCIsXFxcInNpemVcXFwiLFxcXCJzaXplc1xcXCIsXFxcInNwYW5cXFwiLFxcXCJzcmNcXFwiLFxcXCJzcmNkb2NcXFwiLFxcXCJzcmNsYW5nXFxcIixcXFwic3Jjc2V0XFxcIixcXFwic3RhcnRcXFwiLFxcXCJzdGVwXFxcIixcXFwic3VtbWFyeVxcXCIsXFxcInNwZWxsY2hlY2tcXFwiLFxcXCJzdHlsZVxcXCIsXFxcInRhYmluZGV4XFxcIixcXFwidGFyZ2V0XFxcIixcXFwidGl0bGVcXFwiLFxcXCJ0eXBlXFxcIixcXFwidHJhbnNsYXRlXFxcIixcXFwidXNlbWFwXFxcIixcXFwidmFsdWVcXFwiLFxcXCJ2YWxpZ25cXFwiLFxcXCJ3ZWJraXRhbGxvd2Z1bGxzY3JlZW5cXFwiLFxcXCJ3aWR0aFxcXCIsXFxcIndyYXBcXFwiXSxodG1sQWxsb3dDb21tZW50czohMCxmdWxsUGFnZTohMX0pLGEuRkUuSFRNTDVNYXA9e0I6XFxcIlNUUk9OR1xcXCIsSTpcXFwiRU1cXFwiLFNUUklLRTpcXFwiU1xcXCJ9LGEuRkUuTU9EVUxFUy5jbGVhbj1mdW5jdGlvbihiKXtmdW5jdGlvbiBjKGEpe2lmKGEuY2xhc3NOYW1lJiZhLmNsYXNzTmFtZS5pbmRleE9mKFxcXCJmci1tYXJrZXJcXFwiKT49MClyZXR1cm4hMTt2YXIgZCxlPWIubm9kZS5jb250ZW50cyhhKSxmPVtdO2ZvcihkPTA7ZDxlLmxlbmd0aDtkKyspZVtkXS5ub2RlVHlwZSE9Tm9kZS5FTEVNRU5UX05PREV8fGIubm9kZS5pc1ZvaWQoZVtkXSk/ZVtkXS5ub2RlVHlwZT09Tm9kZS5URVhUX05PREUmJihlW2RdLnRleHRDb250ZW50PWVbZF0udGV4dENvbnRlbnQucmVwbGFjZSgvXFxcXHUyMDBiL2csXFxcIlxcXCIpKTplW2RdLnRleHRDb250ZW50LnJlcGxhY2UoL1xcXFx1MjAwYi9nLFxcXCJcXFwiKS5sZW5ndGghPWVbZF0udGV4dENvbnRlbnQubGVuZ3RoJiZjKGVbZF0pO2lmKGEubm9kZVR5cGU9PU5vZGUuRUxFTUVOVF9OT0RFJiYhYi5ub2RlLmlzVm9pZChhKSYmKGEubm9ybWFsaXplKCksZT1iLm5vZGUuY29udGVudHMoYSksZj1hLnF1ZXJ5U2VsZWN0b3JBbGwoXFxcIi5mci1tYXJrZXJcXFwiKSxlLmxlbmd0aC1mLmxlbmd0aD09MCkpe2ZvcihkPTA7ZDxlLmxlbmd0aDtkKyspaWYoKGVbZF0uY2xhc3NOYW1lfHxcXFwiXFxcIikuaW5kZXhPZihcXFwiZnItbWFya2VyXFxcIik8MClyZXR1cm4hMTtmb3IoZD0wO2Q8Zi5sZW5ndGg7ZCsrKWEucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoZltkXS5jbG9uZU5vZGUoITApLGEpO3JldHVybiBhLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoYSksITF9fWZ1bmN0aW9uIGQoYSl7aWYoYS5ub2RlVHlwZT09Tm9kZS5DT01NRU5UX05PREUpcmV0dXJuXFxcIjwhLS1cXFwiK2Eubm9kZVZhbHVlK1xcXCItLT5cXFwiO2lmKGEubm9kZVR5cGU9PU5vZGUuVEVYVF9OT0RFKXJldHVybiBhLnRleHRDb250ZW50LnJlcGxhY2UoL1xcXFw8L2csXFxcIiZsdDtcXFwiKS5yZXBsYWNlKC9cXFxcPi9nLFxcXCImZ3Q7XFxcIikucmVwbGFjZSgvXFxcXHUwMEEwL2csXFxcIiZuYnNwO1xcXCIpO2lmKGEubm9kZVR5cGUhPU5vZGUuRUxFTUVOVF9OT0RFKXJldHVybiBhLm91dGVySFRNTDtpZihhLm5vZGVUeXBlPT1Ob2RlLkVMRU1FTlRfTk9ERSYmW1xcXCJTVFlMRVxcXCIsXFxcIlNDUklQVFxcXCJdLmluZGV4T2YoYS50YWdOYW1lKT49MClyZXR1cm4gYS5vdXRlckhUTUw7aWYoXFxcIklGUkFNRVxcXCI9PWEudGFnTmFtZSlyZXR1cm4gYS5vdXRlckhUTUw7dmFyIGM9YS5jaGlsZE5vZGVzO2lmKDA9PT1jLmxlbmd0aClyZXR1cm4gYS5vdXRlckhUTUw7Zm9yKHZhciBlPVxcXCJcXFwiLGY9MDtmPGMubGVuZ3RoO2YrKyllKz1kKGNbZl0pO3JldHVybiBiLm5vZGUub3BlblRhZ1N0cmluZyhhKStlK2Iubm9kZS5jbG9zZVRhZ1N0cmluZyhhKX1mdW5jdGlvbiBlKGEpe3JldHVybiBJPVtdLGE9YS5yZXBsYWNlKC88c2NyaXB0XFxcXGJbXjxdKig/Oig/ITxcXFxcL3NjcmlwdD4pPFtePF0qKSo8XFxcXC9zY3JpcHQ+L2dpLGZ1bmN0aW9uKGEpe3JldHVybiBJLnB1c2goYSksXFxcIltGUk9BTEEuRURJVE9SLlNDUklQVCBcXFwiKyhJLmxlbmd0aC0xKStcXFwiXVxcXCJ9KSxhPWEucmVwbGFjZSgvPGltZygoPzpbXFxcXHdcXFxcV10qPykpIHNyYz1cXFwiL2csJzxpbWckMSBkYXRhLWZyLXNyYz1cXFwiJyl9ZnVuY3Rpb24gZihhKXtyZXR1cm4gYT1hLnJlcGxhY2UoL1xcXFxbRlJPQUxBXFxcXC5FRElUT1JcXFxcLlNDUklQVCAoW1xcXFxkXSopXFxcXF0vZ2ksZnVuY3Rpb24oYSxjKXtyZXR1cm4gYi5vcHRzLmh0bWxSZW1vdmVUYWdzLmluZGV4T2YoXFxcInNjcmlwdFxcXCIpPj0wP1xcXCJcXFwiOklbcGFyc2VJbnQoYywxMCldfSksYT1hLnJlcGxhY2UoLzxpbWcoKD86W1xcXFx3XFxcXFddKj8pKSBkYXRhLWZyLXNyYz1cXFwiL2csJzxpbWckMSBzcmM9XFxcIicpfWZ1bmN0aW9uIGcoYSl7dmFyIGI7Zm9yKGIgaW4gYSlhLmhhc093blByb3BlcnR5KGIpJiYoYi5tYXRjaChIKXx8ZGVsZXRlIGFbYl0pO2Zvcih2YXIgYz1cXFwiXFxcIixkPU9iamVjdC5rZXlzKGEpLnNvcnQoKSxlPTA7ZTxkLmxlbmd0aDtlKyspYj1kW2VdLGMrPWFbYl0uaW5kZXhPZignXFxcIicpPDA/XFxcIiBcXFwiK2IrJz1cXFwiJythW2JdKydcXFwiJzpcXFwiIFxcXCIrYitcXFwiPSdcXFwiK2FbYl0rXFxcIidcXFwiO3JldHVybiBjfWZ1bmN0aW9uIGgoYSxjLGQpe2lmKGIub3B0cy5mdWxsUGFnZSl7dmFyIGU9Yi5odG1sLmV4dHJhY3REb2N0eXBlKGQpLGY9ZyhiLmh0bWwuZXh0cmFjdE5vZGVBdHRycyhkLFxcXCJodG1sXFxcIikpO2M9bnVsbD09Yz9iLmh0bWwuZXh0cmFjdE5vZGUoZCxcXFwiaGVhZFxcXCIpfHxcXFwiPHRpdGxlPjwvdGl0bGU+XFxcIjpjO3ZhciBoPWcoYi5odG1sLmV4dHJhY3ROb2RlQXR0cnMoZCxcXFwiaGVhZFxcXCIpKSxpPWcoYi5odG1sLmV4dHJhY3ROb2RlQXR0cnMoZCxcXFwiYm9keVxcXCIpKTtyZXR1cm4gZStcXFwiPGh0bWxcXFwiK2YrXFxcIj48aGVhZFxcXCIraCtcXFwiPlxcXCIrYytcXFwiPC9oZWFkPjxib2R5XFxcIitpK1xcXCI+XFxcIithK1xcXCI8L2JvZHk+PC9odG1sPlxcXCJ9cmV0dXJuIGF9ZnVuY3Rpb24gaShjLGUpe3ZhciBmPWEoXFxcIjxkaXY+XFxcIitjK1xcXCI8L2Rpdj5cXFwiKSxnPVxcXCJcXFwiO2lmKGYpe2Zvcih2YXIgaD1iLm5vZGUuY29udGVudHMoZi5nZXQoMCkpLGk9MDtpPGgubGVuZ3RoO2krKyllKGhbaV0pO2g9Yi5ub2RlLmNvbnRlbnRzKGYuZ2V0KDApKTtmb3IodmFyIGk9MDtpPGgubGVuZ3RoO2krKylnKz1kKGhbaV0pfXJldHVybiBnfWZ1bmN0aW9uIGooYSxjLGQpe2E9ZShhKTt2YXIgZz1hLGo9bnVsbDtpZihiLm9wdHMuZnVsbFBhZ2Upe3ZhciBnPWIuaHRtbC5leHRyYWN0Tm9kZShhLFxcXCJib2R5XFxcIil8fChhLmluZGV4T2YoXFxcIjxib2R5XFxcIik+PTA/XFxcIlxcXCI6YSk7ZCYmKGo9Yi5odG1sLmV4dHJhY3ROb2RlKGEsXFxcImhlYWRcXFwiKXx8XFxcIlxcXCIpfWc9aShnLGMpLGomJihqPWkoaixjKSk7dmFyIGs9aChnLGosYSk7cmV0dXJuIGYoayl9ZnVuY3Rpb24gayhhKXtyZXR1cm4gYS5yZXBsYWNlKC9cXFxcdTIwMGIvZyxcXFwiXFxcIikubGVuZ3RoPT1hLmxlbmd0aD9hOmIuY2xlYW4uZXhlYyhhLGMpfWZ1bmN0aW9uIGwoKXt2YXIgYz1iLiRlbC5nZXQoMCkucXVlcnlTZWxlY3RvckFsbChPYmplY3Qua2V5cyhhLkZFLkhUTUw1TWFwKS5qb2luKFxcXCIsXFxcIikpO2lmKGMubGVuZ3RoKXtiLnNlbGVjdGlvbi5zYXZlKCk7Zm9yKHZhciBkPTA7ZDxjLmxlbmd0aDtkKyspXFxcIlxcXCI9PT1iLm5vZGUuYXR0cmlidXRlcyhjW2RdKSYmYShjW2RdKS5yZXBsYWNlV2l0aChcXFwiPFxcXCIrYS5GRS5IVE1MNU1hcFtjW2RdLnRhZ05hbWVdK1xcXCI+XFxcIitjW2RdLmlubmVySFRNTCtcXFwiPC9cXFwiK2EuRkUuSFRNTDVNYXBbY1tkXS50YWdOYW1lXStcXFwiPlxcXCIpO2Iuc2VsZWN0aW9uLnJlc3RvcmUoKX19ZnVuY3Rpb24gbShjKXtpZihcXFwiU1BBTlxcXCI9PWMudGFnTmFtZSYmKGMuY2xhc3NOYW1lfHxcXFwiXFxcIikuaW5kZXhPZihcXFwiZnItbWFya2VyXFxcIik+PTApcmV0dXJuITE7aWYoXFxcIlBSRVxcXCI9PWMudGFnTmFtZSYmbyhjKSxjLm5vZGVUeXBlPT1Ob2RlLkVMRU1FTlRfTk9ERSYmKGMuZ2V0QXR0cmlidXRlKFxcXCJkYXRhLWZyLXNyY1xcXCIpJiZjLnNldEF0dHJpYnV0ZShcXFwiZGF0YS1mci1zcmNcXFwiLGIuaGVscGVycy5zYW5pdGl6ZVVSTChjLmdldEF0dHJpYnV0ZShcXFwiZGF0YS1mci1zcmNcXFwiKSkpLGMuZ2V0QXR0cmlidXRlKFxcXCJocmVmXFxcIikmJmMuc2V0QXR0cmlidXRlKFxcXCJocmVmXFxcIixiLmhlbHBlcnMuc2FuaXRpemVVUkwoYy5nZXRBdHRyaWJ1dGUoXFxcImhyZWZcXFwiKSkpLFtcXFwiVEFCTEVcXFwiLFxcXCJUQk9EWVxcXCIsXFxcIlRGT09UXFxcIixcXFwiVFJcXFwiXS5pbmRleE9mKGMudGFnTmFtZSk+PTAmJihjLmlubmVySFRNTD1jLmlubmVySFRNTC50cmltKCkpKSwhYi5vcHRzLnBhc3RlQWxsb3dMb2NhbEltYWdlcyYmYy5ub2RlVHlwZT09Tm9kZS5FTEVNRU5UX05PREUmJlxcXCJJTUdcXFwiPT1jLnRhZ05hbWUmJmMuZ2V0QXR0cmlidXRlKFxcXCJkYXRhLWZyLXNyY1xcXCIpJiYwPT1jLmdldEF0dHJpYnV0ZShcXFwiZGF0YS1mci1zcmNcXFwiKS5pbmRleE9mKFxcXCJmaWxlOi8vXFxcIikpcmV0dXJuIGMucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChjKSwhMTtpZihjLm5vZGVUeXBlPT1Ob2RlLkVMRU1FTlRfTk9ERSYmYS5GRS5IVE1MNU1hcFtjLnRhZ05hbWVdJiZcXFwiXFxcIj09PWIubm9kZS5hdHRyaWJ1dGVzKGMpKXt2YXIgZD1hLkZFLkhUTUw1TWFwW2MudGFnTmFtZV0sZT1cXFwiPFxcXCIrZCtcXFwiPlxcXCIrYy5pbm5lckhUTUwrXFxcIjwvXFxcIitkK1xcXCI+XFxcIjtjLmluc2VydEFkamFjZW50SFRNTChcXFwiYmVmb3JlYmVnaW5cXFwiLGUpLGM9Yy5wcmV2aW91c1NpYmxpbmcsYy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGMubmV4dFNpYmxpbmcpfWlmKGIub3B0cy5odG1sQWxsb3dDb21tZW50c3x8Yy5ub2RlVHlwZSE9Tm9kZS5DT01NRU5UX05PREUpaWYoYy50YWdOYW1lJiZjLnRhZ05hbWUubWF0Y2goRykpYy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGMpO2Vsc2UgaWYoYy50YWdOYW1lJiYhYy50YWdOYW1lLm1hdGNoKEYpKWMub3V0ZXJIVE1MPWMuaW5uZXJIVE1MO2Vsc2V7dmFyIGY9Yy5hdHRyaWJ1dGVzO2lmKGYpZm9yKHZhciBnPWYubGVuZ3RoLTE7Zz49MDtnLS0pe3ZhciBoPWZbZ107aC5ub2RlTmFtZS5tYXRjaChIKXx8Yy5yZW1vdmVBdHRyaWJ1dGUoaC5ub2RlTmFtZSl9fWVsc2UgMCE9PWMuZGF0YS5pbmRleE9mKFxcXCJbRlJPQUxBLkVESVRPUlxcXCIpJiZjLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoYyl9ZnVuY3Rpb24gbihhKXtmb3IodmFyIGM9Yi5ub2RlLmNvbnRlbnRzKGEpLGQ9MDtkPGMubGVuZ3RoO2QrKyljW2RdLm5vZGVUeXBlIT1Ob2RlLlRFWFRfTk9ERSYmbihjW2RdKTttKGEpfWZ1bmN0aW9uIG8oYSl7dmFyIGI9YS5pbm5lckhUTUw7Yi5pbmRleE9mKFxcXCJcXFxcblxcXCIpPj0wJiYoYS5pbm5lckhUTUw9Yi5yZXBsYWNlKC9cXFxcbi9nLFxcXCI8YnI+XFxcIikpfWZ1bmN0aW9uIHAoYyxkLGUsZil7XFxcInVuZGVmaW5lZFxcXCI9PXR5cGVvZiBkJiYoZD1bXSksXFxcInVuZGVmaW5lZFxcXCI9PXR5cGVvZiBlJiYoZT1bXSksXFxcInVuZGVmaW5lZFxcXCI9PXR5cGVvZiBmJiYoZj0hMSksYz1jLnJlcGxhY2UoL1xcXFx1MDAwOS9nLFxcXCJcXFwiKTt2YXIgZyxoPWEubWVyZ2UoW10sYi5vcHRzLmh0bWxBbGxvd2VkVGFncyk7Zm9yKGc9MDtnPGQubGVuZ3RoO2crKyloLmluZGV4T2YoZFtnXSk+PTAmJmguc3BsaWNlKGguaW5kZXhPZihkW2ddKSwxKTt2YXIgaT1hLm1lcmdlKFtdLGIub3B0cy5odG1sQWxsb3dlZEF0dHJzKTtmb3IoZz0wO2c8ZS5sZW5ndGg7ZysrKWkuaW5kZXhPZihlW2ddKT49MCYmaS5zcGxpY2UoaS5pbmRleE9mKGVbZ10pLDEpO3JldHVybiBpLnB1c2goXFxcImRhdGEtZnItLipcXFwiKSxpLnB1c2goXFxcImZyLS4qXFxcIiksRj1uZXcgUmVnRXhwKFxcXCJeXFxcIitoLmpvaW4oXFxcIiR8XlxcXCIpK1xcXCIkXFxcIixcXFwiZ2lcXFwiKSxIPW5ldyBSZWdFeHAoXFxcIl5cXFwiK2kuam9pbihcXFwiJHxeXFxcIikrXFxcIiRcXFwiLFxcXCJnaVxcXCIpLEc9bmV3IFJlZ0V4cChcXFwiXlxcXCIrYi5vcHRzLmh0bWxSZW1vdmVUYWdzLmpvaW4oXFxcIiR8XlxcXCIpK1xcXCIkXFxcIixcXFwiZ2lcXFwiKSxjPWooYyxuLCEwKX1mdW5jdGlvbiBxKCl7Zm9yKHZhciBjPWIuJGVsLmdldCgwKS5xdWVyeVNlbGVjdG9yQWxsKFxcXCJibG9ja3F1b3RlICsgYmxvY2txdW90ZVxcXCIpLGQ9MDtkPGMubGVuZ3RoO2QrKyl7dmFyIGU9Y1tkXTtiLm5vZGUuYXR0cmlidXRlcyhlKT09Yi5ub2RlLmF0dHJpYnV0ZXMoZS5wcmV2aW91c1NpYmxpbmcpJiYoYShlKS5wcmV2KCkuYXBwZW5kKGEoZSkuaHRtbCgpKSxhKGUpLnJlbW92ZSgpKX19ZnVuY3Rpb24gcigpe2Zvcih2YXIgYT1iLiRlbC5nZXQoMCkucXVlcnlTZWxlY3RvckFsbChcXFwidHJcXFwiKSxjPTA7YzxhLmxlbmd0aDtjKyspe2Zvcih2YXIgZD1hW2NdLmNoaWxkcmVuLGU9ITAsZj0wO2Y8ZC5sZW5ndGg7ZisrKWlmKFxcXCJUSFxcXCIhPWRbZl0udGFnTmFtZSl7ZT0hMTticmVha31pZigwIT1lJiYwIT1kLmxlbmd0aCl7Zm9yKHZhciBnPWFbY107ZyYmXFxcIlRBQkxFXFxcIiE9Zy50YWdOYW1lJiZcXFwiVEhFQURcXFwiIT1nLnRhZ05hbWU7KWc9Zy5wYXJlbnROb2RlO3ZhciBoPWc7XFxcIlRIRUFEXFxcIiE9aC50YWdOYW1lJiYoaD1iLmRvYy5jcmVhdGVFbGVtZW50KFxcXCJUSEVBRFxcXCIpLGcuaW5zZXJ0QmVmb3JlKGgsZy5maXJzdENoaWxkKSksaC5hcHBlbmRDaGlsZChhW2NdKX19fWZ1bmN0aW9uIHMoKXtmb3IodmFyIGM9Yi4kZWwuZ2V0KDApLnF1ZXJ5U2VsZWN0b3JBbGwoXFxcInRhYmxlXFxcIiksZD0wO2Q8Yy5sZW5ndGg7ZCsrKXtmb3IodmFyIGU9Y1tkXS5wcmV2aW91c1NpYmxpbmc7ZSYmZS5ub2RlVHlwZT09Tm9kZS5URVhUX05PREUmJjA9PWUudGV4dENvbnRlbnQubGVuZ3RoOyllPWUucHJldmlvdXNTaWJsaW5nOyFlfHxiLm5vZGUuaXNCbG9jayhlKXx8XFxcIkJSXFxcIj09ZS50YWdOYW1lfHxlLm5vZGVUeXBlIT1Ob2RlLlRFWFRfTk9ERSYmZS5ub2RlVHlwZSE9Tm9kZS5FTEVNRU5UX05PREV8fGEoZSkuaXMoYi5vcHRzLmh0bWxEb05vdFdyYXBUYWdzLmpvaW4oXFxcIixcXFwiKSl8fGNbZF0ucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoYi5kb2MuY3JlYXRlRWxlbWVudChcXFwiYnJcXFwiKSxjW2RdKX19ZnVuY3Rpb24gdCgpe3ZhciBjPWIuaHRtbC5kZWZhdWx0VGFnKCk7aWYoYylmb3IodmFyIGQ9Yi4kZWwuZ2V0KDApLnF1ZXJ5U2VsZWN0b3JBbGwoXFxcInRkID4gXFxcIitjK1xcXCIsIHRoID4gXFxcIitjKSxlPTA7ZTxkLmxlbmd0aDtlKyspXFxcIlxcXCI9PT1iLm5vZGUuYXR0cmlidXRlcyhkW2VdKSYmYShkW2VdKS5yZXBsYWNlV2l0aChkW2VdLmlubmVySFRNTCtcXFwiPGJyPlxcXCIpfWZ1bmN0aW9uIHUoKXtyKCkscygpLHQoKX1mdW5jdGlvbiB2KCl7dmFyIGE9W10sYz1mdW5jdGlvbihhKXtyZXR1cm4hYi5ub2RlLmlzTGlzdChhLnBhcmVudE5vZGUpfTtkb3tpZihhLmxlbmd0aCl7dmFyIGQ9YVswXSxlPWIuZG9jLmNyZWF0ZUVsZW1lbnQoXFxcInVsXFxcIik7ZC5wYXJlbnROb2RlLmluc2VydEJlZm9yZShlLGQpO2Rve3ZhciBmPWQ7ZD1kLm5leHRTaWJsaW5nLGUuYXBwZW5kQ2hpbGQoZil9d2hpbGUoZCYmXFxcIkxJXFxcIj09ZC50YWdOYW1lKX1hPVtdO2Zvcih2YXIgZz1iLiRlbC5nZXQoMCkucXVlcnlTZWxlY3RvckFsbChcXFwibGlcXFwiKSxoPTA7aDxnLmxlbmd0aDtoKyspYyhnW2hdKSYmYS5wdXNoKGdbaF0pfXdoaWxlKGEubGVuZ3RoPjApfWZ1bmN0aW9uIHcoKXtmb3IodmFyIGE9Yi4kZWwuZ2V0KDApLnF1ZXJ5U2VsZWN0b3JBbGwoXFxcIm9sICsgb2wsIHVsICsgdWxcXFwiKSxjPTA7YzxhLmxlbmd0aDtjKyspe3ZhciBkPWFbY107aWYoYi5ub2RlLmlzTGlzdChkLnByZXZpb3VzU2libGluZykmJmIubm9kZS5vcGVuVGFnU3RyaW5nKGQpPT1iLm5vZGUub3BlblRhZ1N0cmluZyhkLnByZXZpb3VzU2libGluZykpe2Zvcih2YXIgZT1iLm5vZGUuY29udGVudHMoZCksZj0wO2Y8ZS5sZW5ndGg7ZisrKWQucHJldmlvdXNTaWJsaW5nLmFwcGVuZENoaWxkKGVbZl0pO2QucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChkKX19fWZ1bmN0aW9uIHgoKXt2YXIgYSxjPWZ1bmN0aW9uKGIpezA9PT1iLnF1ZXJ5U2VsZWN0b3JBbGwoXFxcIkxJXFxcIikubGVuZ3RoJiYoYT0hMCxiLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoYikpfTtkb3thPSExO2Zvcih2YXIgZD1iLiRlbC5nZXQoMCkucXVlcnlTZWxlY3RvckFsbChcXFwibGk6ZW1wdHlcXFwiKSxlPTA7ZTxkLmxlbmd0aDtlKyspZFtlXS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGRbZV0pO2Zvcih2YXIgZj1iLiRlbC5nZXQoMCkucXVlcnlTZWxlY3RvckFsbChcXFwidWwsIG9sXFxcIiksZT0wO2U8Zi5sZW5ndGg7ZSsrKWMoZltlXSl9d2hpbGUoYT09PSEwKX1mdW5jdGlvbiB5KCl7Zm9yKHZhciBjPWIuJGVsLmdldCgwKS5xdWVyeVNlbGVjdG9yQWxsKFxcXCJ1bCA+IHVsLCBvbCA+IG9sLCB1bCA+IG9sLCBvbCA+IHVsXFxcIiksZD0wO2Q8Yy5sZW5ndGg7ZCsrKXt2YXIgZT1jW2RdLGY9ZS5wcmV2aW91c1NpYmxpbmc7ZiYmKFxcXCJMSVxcXCI9PWYudGFnTmFtZT9mLmFwcGVuZENoaWxkKGUpOmEoZSkud3JhcChcXFwiPGxpPjwvbGk+XFxcIikpfX1mdW5jdGlvbiB6KCl7Zm9yKHZhciBjPWIuJGVsLmdldCgwKS5xdWVyeVNlbGVjdG9yQWxsKFxcXCJsaSA+IHVsLCBsaSA+IG9sXFxcIiksZD0wO2Q8Yy5sZW5ndGg7ZCsrKXt2YXIgZT1jW2RdO2lmKGUubmV4dFNpYmxpbmcpe3ZhciBmPWUubmV4dFNpYmxpbmcsZz1hKFxcXCI8bGk+XFxcIik7YShlLnBhcmVudE5vZGUpLmFmdGVyKGcpO2Rve3ZhciBoPWY7Zj1mLm5leHRTaWJsaW5nLGcuYXBwZW5kKGgpfXdoaWxlKGYpfX19ZnVuY3Rpb24gQSgpe2Zvcih2YXIgYz1iLiRlbC5nZXQoMCkucXVlcnlTZWxlY3RvckFsbChcXFwibGkgPiB1bCwgbGkgPiBvbFxcXCIpLGQ9MDtkPGMubGVuZ3RoO2QrKyl7dmFyIGU9Y1tkXTtpZihiLm5vZGUuaXNGaXJzdFNpYmxpbmcoZSkpYShlKS5iZWZvcmUoXFxcIjxici8+XFxcIik7ZWxzZSBpZihlLnByZXZpb3VzU2libGluZyYmXFxcIkJSXFxcIj09ZS5wcmV2aW91c1NpYmxpbmcudGFnTmFtZSl7Zm9yKHZhciBmPWUucHJldmlvdXNTaWJsaW5nLnByZXZpb3VzU2libGluZztmJiZhKGYpLmhhc0NsYXNzKFxcXCJmci1tYXJrZXJcXFwiKTspZj1mLnByZXZpb3VzU2libGluZztmJiZcXFwiQlJcXFwiIT1mLnRhZ05hbWUmJmEoZS5wcmV2aW91c1NpYmxpbmcpLnJlbW92ZSgpfX19ZnVuY3Rpb24gQigpe2Zvcih2YXIgYz1iLiRlbC5nZXQoMCkucXVlcnlTZWxlY3RvckFsbChcXFwibGk6ZW1wdHlcXFwiKSxkPTA7ZDxjLmxlbmd0aDtkKyspYShjW2RdKS5yZW1vdmUoKX1mdW5jdGlvbiBDKCl7Zm9yKHZhciBjPWIuJGVsLmdldCgwKS5xdWVyeVNlbGVjdG9yQWxsKFxcXCJ1bCwgb2xcXFwiKSxkPTA7ZDxjLmxlbmd0aDtkKyspZm9yKHZhciBlPWIubm9kZS5jb250ZW50cyhjW2RdKSxmPW51bGwsZz1lLmxlbmd0aC0xO2c+PTA7Zy0tKVxcXCJMSVxcXCIhPWVbZ10udGFnTmFtZT8oZnx8KGY9YShcXFwiPGxpPlxcXCIpLGYuaW5zZXJ0QmVmb3JlKGVbZ10pKSxmLmFwcGVuZChlW2ddKSk6Zj1udWxsfWZ1bmN0aW9uIEQoKXt2KCksdygpLHgoKSx5KCkseigpLEEoKSxDKCksQigpfWZ1bmN0aW9uIEUoKXtiLm9wdHMuZnVsbFBhZ2UmJmEubWVyZ2UoYi5vcHRzLmh0bWxBbGxvd2VkVGFncyxbXFxcImhlYWRcXFwiLFxcXCJ0aXRsZVxcXCIsXFxcInN0eWxlXFxcIixcXFwibGlua1xcXCIsXFxcImJhc2VcXFwiLFxcXCJib2R5XFxcIixcXFwiaHRtbFxcXCJdKX12YXIgRixHLEgsST1bXSxJPVtdO3JldHVybntfaW5pdDpFLGh0bWw6cCx0b0hUTUw1OmwsdGFibGVzOnUsbGlzdHM6RCxxdW90ZXM6cSxpbnZpc2libGVTcGFjZXM6ayxleGVjOmp9fSxhLkZFLlhTPTAsYS5GRS5TTT0xLGEuRkUuTUQ9MixhLkZFLkxHPTMsYS5GRS5NT0RVTEVTLmhlbHBlcnM9ZnVuY3Rpb24oYil7ZnVuY3Rpb24gYygpe3ZhciBhLGIsYz0tMTtyZXR1cm5cXFwiTWljcm9zb2Z0IEludGVybmV0IEV4cGxvcmVyXFxcIj09bmF2aWdhdG9yLmFwcE5hbWU/KGE9bmF2aWdhdG9yLnVzZXJBZ2VudCxiPW5ldyBSZWdFeHAoXFxcIk1TSUUgKFswLTldezEsfVtcXFxcXFxcXC4wLTldezAsfSlcXFwiKSxudWxsIT09Yi5leGVjKGEpJiYoYz1wYXJzZUZsb2F0KFJlZ0V4cC4kMSkpKTpcXFwiTmV0c2NhcGVcXFwiPT1uYXZpZ2F0b3IuYXBwTmFtZSYmKGE9bmF2aWdhdG9yLnVzZXJBZ2VudCxiPW5ldyBSZWdFeHAoXFxcIlRyaWRlbnQvLipydjooWzAtOV17MSx9W1xcXFxcXFxcLjAtOV17MCx9KVxcXCIpLG51bGwhPT1iLmV4ZWMoYSkmJihjPXBhcnNlRmxvYXQoUmVnRXhwLiQxKSkpLGN9ZnVuY3Rpb24gZCgpe3ZhciBhPXt9LGI9YygpO2lmKGI+MClhLm1zaWU9ITA7ZWxzZXt2YXIgZD1uYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCksZT0vKGVkZ2UpWyBcXFxcL10oW1xcXFx3Ll0rKS8uZXhlYyhkKXx8LyhjaHJvbWUpWyBcXFxcL10oW1xcXFx3Ll0rKS8uZXhlYyhkKXx8Lyh3ZWJraXQpWyBcXFxcL10oW1xcXFx3Ll0rKS8uZXhlYyhkKXx8LyhvcGVyYSkoPzouKnZlcnNpb258KVsgXFxcXC9dKFtcXFxcdy5dKykvLmV4ZWMoZCl8fC8obXNpZSkgKFtcXFxcdy5dKykvLmV4ZWMoZCl8fGQuaW5kZXhPZihcXFwiY29tcGF0aWJsZVxcXCIpPDAmJi8obW96aWxsYSkoPzouKj8gcnY6KFtcXFxcdy5dKyl8KS8uZXhlYyhkKXx8W10sZj17YnJvd3NlcjplWzFdfHxcXFwiXFxcIix2ZXJzaW9uOmVbMl18fFxcXCIwXFxcIn07ZVsxXSYmKGFbZi5icm93c2VyXT0hMCksYS5jaHJvbWU/YS53ZWJraXQ9ITA6YS53ZWJraXQmJihhLnNhZmFyaT0hMCl9cmV0dXJuIGEubXNpZSYmKGEudmVyc2lvbj1iKSxhfWZ1bmN0aW9uIGUoKXtyZXR1cm4vKGlQYWR8aVBob25lfGlQb2QpL2cudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSYmIWgoKX1mdW5jdGlvbiBmKCl7cmV0dXJuLyhBbmRyb2lkKS9nLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkmJiFoKCl9ZnVuY3Rpb24gZygpe3JldHVybi8oQmxhY2tiZXJyeSkvZy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpfWZ1bmN0aW9uIGgoKXtyZXR1cm4vKFdpbmRvd3MgUGhvbmUpL2dpLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCl9ZnVuY3Rpb24gaSgpe3JldHVybiBmKCl8fGUoKXx8ZygpfWZ1bmN0aW9uIGooKXtyZXR1cm4gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZXx8d2luZG93LndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZXx8d2luZG93Lm1velJlcXVlc3RBbmltYXRpb25GcmFtZXx8ZnVuY3Rpb24oYSl7d2luZG93LnNldFRpbWVvdXQoYSwxZTMvNjApfX1mdW5jdGlvbiBrKGEpe3JldHVybiBwYXJzZUludChhLDEwKXx8MH1mdW5jdGlvbiBsKCl7dmFyIGI9YSgnPGRpdiBjbGFzcz1cXFwiZnItdmlzaWJpbGl0eS1oZWxwZXJcXFwiPjwvZGl2PicpLmFwcGVuZFRvKFxcXCJib2R5XFxcIiksYz1rKGIuY3NzKFxcXCJtYXJnaW4tbGVmdFxcXCIpKTtyZXR1cm4gYi5yZW1vdmUoKSxjfWZ1bmN0aW9uIG0oKXtyZXR1cm5cXFwib250b3VjaHN0YXJ0XFxcImluIHdpbmRvd3x8d2luZG93LkRvY3VtZW50VG91Y2gmJmRvY3VtZW50IGluc3RhbmNlb2YgRG9jdW1lbnRUb3VjaH1mdW5jdGlvbiBuKGEpe2lmKCEvXihodHRwcz86fGZ0cHM/OnwpXFxcXC9cXFxcLy9pLnRlc3QoYSkpcmV0dXJuITE7YT1TdHJpbmcoYSkucmVwbGFjZSgvPC9nLFxcXCIlM0NcXFwiKS5yZXBsYWNlKC8+L2csXFxcIiUzRVxcXCIpLnJlcGxhY2UoL1xcXCIvZyxcXFwiJTIyXFxcIikucmVwbGFjZSgvIC9nLFxcXCIlMjBcXFwiKTt2YXIgYj0vKGh0dHB8ZnRwfGh0dHBzKTpcXFxcL1xcXFwvW2EtelxcXFx1MDBhMS1cXFxcdWZmZmYwLTldKyhcXFxcLlthLXpcXFxcdTAwYTEtXFxcXHVmZmZmMC05XSopKihbYS16XFxcXHUwMGExLVxcXFx1ZmZmZjAtOS4sQD9ePSUmYW1wOzpcXFxcL34rIy1dKlthLXpcXFxcdTAwYTEtXFxcXHVmZmZmMC05QD9ePSUmYW1wO1xcXFwvfisjLV0pPy9naTtyZXR1cm4gYi50ZXN0KGEpfWZ1bmN0aW9uIG8oYSl7aWYoL14oaHR0cHM/OnxmdHBzPzp8KVxcXFwvXFxcXC8vaS50ZXN0KGEpKXtpZighbihhKSYmIW4oXFxcImh0dHA6XFxcIithKSlyZXR1cm5cXFwiXFxcIn1lbHNlIGE9ZW5jb2RlVVJJQ29tcG9uZW50KGEpLnJlcGxhY2UoLyUyMy9nLFxcXCIjXFxcIikucmVwbGFjZSgvJTJGL2csXFxcIi9cXFwiKS5yZXBsYWNlKC8lMjUvZyxcXFwiJVxcXCIpLnJlcGxhY2UoL21haWx0byUzQS9naSxcXFwibWFpbHRvOlxcXCIpLnJlcGxhY2UoL2ZpbGUlM0EvZ2ksXFxcImZpbGU6XFxcIikucmVwbGFjZSgvc21zJTNBL2dpLFxcXCJzbXM6XFxcIikucmVwbGFjZSgvdGVsJTNBL2dpLFxcXCJ0ZWw6XFxcIikucmVwbGFjZSgvbm90ZXMlM0EvZ2ksXFxcIm5vdGVzOlxcXCIpLnJlcGxhY2UoL2RhdGElM0FpbWFnZS9naSxcXFwiZGF0YTppbWFnZVxcXCIpLnJlcGxhY2UoL2Jsb2IlM0EvZ2ksXFxcImJsb2I6XFxcIikucmVwbGFjZSgvd2Via2l0LWZha2UtdXJsJTNBL2dpLFxcXCJ3ZWJraXQtZmFrZS11cmw6XFxcIikucmVwbGFjZSgvJTNGL2csXFxcIj9cXFwiKS5yZXBsYWNlKC8lM0QvZyxcXFwiPVxcXCIpLnJlcGxhY2UoLyUyNi9nLFxcXCImXFxcIikucmVwbGFjZSgvJmFtcDsvZyxcXFwiJlxcXCIpLnJlcGxhY2UoLyUyQy9nLFxcXCIsXFxcIikucmVwbGFjZSgvJTNCL2csXFxcIjtcXFwiKS5yZXBsYWNlKC8lMkIvZyxcXFwiK1xcXCIpLnJlcGxhY2UoLyU0MC9nLFxcXCJAXFxcIikucmVwbGFjZSgvJTVCL2csXFxcIltcXFwiKS5yZXBsYWNlKC8lNUQvZyxcXFwiXVxcXCIpLnJlcGxhY2UoLyU3Qi9nLFxcXCJ7XFxcIikucmVwbGFjZSgvJTdEL2csXFxcIn1cXFwiKTtyZXR1cm4gYX1mdW5jdGlvbiBwKGEpe3JldHVybiBhJiYhYS5wcm9wZXJ0eUlzRW51bWVyYWJsZShcXFwibGVuZ3RoXFxcIikmJlxcXCJvYmplY3RcXFwiPT10eXBlb2YgYSYmXFxcIm51bWJlclxcXCI9PXR5cGVvZiBhLmxlbmd0aH1mdW5jdGlvbiBxKGEpe2Z1bmN0aW9uIGIoYSl7cmV0dXJuKFxcXCIwXFxcIitwYXJzZUludChhLDEwKS50b1N0cmluZygxNikpLnNsaWNlKC0yKX10cnl7cmV0dXJuIGEmJlxcXCJ0cmFuc3BhcmVudFxcXCIhPT1hPy9eI1swLTlBLUZdezZ9JC9pLnRlc3QoYSk/YTooYT1hLm1hdGNoKC9ecmdiXFxcXCgoXFxcXGQrKSxcXFxccyooXFxcXGQrKSxcXFxccyooXFxcXGQrKVxcXFwpJC8pLChcXFwiI1xcXCIrYihhWzFdKStiKGFbMl0pK2IoYVszXSkpLnRvVXBwZXJDYXNlKCkpOlxcXCJcXFwifWNhdGNoKGMpe3JldHVybiBudWxsfX1mdW5jdGlvbiByKGEpe3ZhciBiPS9eIz8oW2EtZlxcXFxkXSkoW2EtZlxcXFxkXSkoW2EtZlxcXFxkXSkkL2k7YT1hLnJlcGxhY2UoYixmdW5jdGlvbihhLGIsYyxkKXtyZXR1cm4gYitiK2MrYytkK2R9KTt2YXIgYz0vXiM/KFthLWZcXFxcZF17Mn0pKFthLWZcXFxcZF17Mn0pKFthLWZcXFxcZF17Mn0pJC9pLmV4ZWMoYSk7cmV0dXJuIGM/XFxcInJnYihcXFwiK3BhcnNlSW50KGNbMV0sMTYpK1xcXCIsIFxcXCIrcGFyc2VJbnQoY1syXSwxNikrXFxcIiwgXFxcIitwYXJzZUludChjWzNdLDE2KStcXFwiKVxcXCI6XFxcIlxcXCJ9ZnVuY3Rpb24gcyhiKXt2YXIgYz0oYi5jc3MoXFxcInRleHQtYWxpZ25cXFwiKXx8XFxcIlxcXCIpLnJlcGxhY2UoLy0oLiopLS9nLFxcXCJcXFwiKTtpZihbXFxcImxlZnRcXFwiLFxcXCJyaWdodFxcXCIsXFxcImp1c3RpZnlcXFwiLFxcXCJjZW50ZXJcXFwiXS5pbmRleE9mKGMpPDApe2lmKCF2KXt2YXIgZD1hKCc8ZGl2IGRpcj1cXFwiYXV0b1xcXCIgc3R5bGU9XFxcInRleHQtYWxpZ246IGluaXRpYWw7IHBvc2l0aW9uOiBmaXhlZDsgbGVmdDogLTMwMDBweDtcXFwiPjxzcGFuIGlkPVxcXCJzMVxcXCI+Ljwvc3Bhbj48c3BhbiBpZD1cXFwiczJcXFwiPi48L3NwYW4+PC9kaXY+Jyk7YShcXFwiYm9keVxcXCIpLmFwcGVuZChkKTt2YXIgZT1kLmZpbmQoXFxcIiNzMVxcXCIpLmdldCgwKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0LGY9ZC5maW5kKFxcXCIjczJcXFwiKS5nZXQoMCkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdDtkLnJlbW92ZSgpLHY9Zj5lP1xcXCJsZWZ0XFxcIjpcXFwicmlnaHRcXFwifWM9dn1yZXR1cm4gY31mdW5jdGlvbiB0KCl7cmV0dXJuIG51bGw9PXcmJih3PW5hdmlnYXRvci5wbGF0Zm9ybS50b1VwcGVyQ2FzZSgpLmluZGV4T2YoXFxcIk1BQ1xcXCIpPj0wKSx3fWZ1bmN0aW9uIHUoKXtiLmJyb3dzZXI9ZCgpfXZhciB2LHc9bnVsbDtyZXR1cm57X2luaXQ6dSxpc0lPUzplLGlzTWFjOnQsaXNBbmRyb2lkOmYsaXNCbGFja2JlcnJ5OmcsaXNXaW5kb3dzUGhvbmU6aCxpc01vYmlsZTppLHJlcXVlc3RBbmltYXRpb25GcmFtZTpqLGdldFBYOmssc2NyZWVuU2l6ZTpsLGlzVG91Y2g6bSxzYW5pdGl6ZVVSTDpvLGlzQXJyYXk6cCxSR0JUb0hleDpxLEhFWHRvUkdCOnIsaXNVUkw6bixnZXRBbGlnbm1lbnQ6c319LGEuRkUuTU9EVUxFUy5ldmVudHM9ZnVuY3Rpb24oYil7ZnVuY3Rpb24gYyhhLGIsYyl7cyhhLGIsYyl9ZnVuY3Rpb24gZCgpe2MoYi4kZWwsXFxcImN1dCBjb3B5IHBhc3RlIGJlZm9yZXBhc3RlXFxcIixmdW5jdGlvbihhKXt2KGEudHlwZSxbYV0pfSl9ZnVuY3Rpb24gZSgpe2MoYi4kZWwsXFxcImNsaWNrIG1vdXNldXAgbW91c2Vkb3duIHRvdWNoc3RhcnQgdG91Y2hlbmQgZHJhZ2VudGVyIGRyYWdvdmVyIGRyYWdsZWF2ZSBkcmFnZW5kIGRyb3AgZHJhZ3N0YXJ0XFxcIixmdW5jdGlvbihhKXt2KGEudHlwZSxbYV0pfSkscihcXFwibW91c2Vkb3duXFxcIixmdW5jdGlvbigpe2Zvcih2YXIgYz0wO2M8YS5GRS5JTlNUQU5DRVMubGVuZ3RoO2MrKylhLkZFLklOU1RBTkNFU1tjXSE9YiYmYS5GRS5JTlNUQU5DRVNbY10ucG9wdXBzJiZhLkZFLklOU1RBTkNFU1tjXS5wb3B1cHMuYXJlVmlzaWJsZSgpJiZhLkZFLklOU1RBTkNFU1tjXS4kZWwuZmluZChcXFwiLmZyLW1hcmtlclxcXCIpLnJlbW92ZSgpfSl9ZnVuY3Rpb24gZigpe2MoYi4kZWwsXFxcImtleWRvd24ga2V5cHJlc3Mga2V5dXAgaW5wdXRcXFwiLGZ1bmN0aW9uKGEpe3YoYS50eXBlLFthXSl9KX1mdW5jdGlvbiBnKCl7YyhiLiR3aW4sYi5fbW91c2Vkb3duLGZ1bmN0aW9uKGEpe3YoXFxcIndpbmRvdy5tb3VzZWRvd25cXFwiLFthXSksbigpfSksYyhiLiR3aW4sYi5fbW91c2V1cCxmdW5jdGlvbihhKXt2KFxcXCJ3aW5kb3cubW91c2V1cFxcXCIsW2FdKX0pLGMoYi4kd2luLFxcXCJjdXQgY29weSBrZXlkb3duIGtleXVwIHRvdWNobW92ZSB0b3VjaGVuZFxcXCIsZnVuY3Rpb24oYSl7dihcXFwid2luZG93LlxcXCIrYS50eXBlLFthXSl9KX1mdW5jdGlvbiBoKCl7YyhiLiRkb2MsXFxcImRyYWdlbmQgZHJvcFxcXCIsZnVuY3Rpb24oYSl7dihcXFwiZG9jdW1lbnQuXFxcIithLnR5cGUsW2FdKX0pfWZ1bmN0aW9uIGkoYyl7aWYoXFxcInVuZGVmaW5lZFxcXCI9PXR5cGVvZiBjJiYoYz0hMCksIWIuJHdwKXJldHVybiExO2lmKGIuaGVscGVycy5pc0lPUygpJiZiLiR3aW4uZ2V0KDApLmZvY3VzKCksIWIuY29yZS5oYXNGb2N1cygpJiZjKXt2YXIgZD1iLiR3aW4uc2Nyb2xsVG9wKCk7cmV0dXJuIGIuJGVsLmZvY3VzKCksZCE9Yi4kd2luLnNjcm9sbFRvcCgpJiZiLiR3aW4uc2Nyb2xsVG9wKGQpLCExfWlmKCFiLmNvcmUuaGFzRm9jdXMoKXx8Yi4kZWwuZmluZChcXFwiLmZyLW1hcmtlclxcXCIpLmxlbmd0aD4wKXJldHVybiExO3ZhciBlPWIuc2VsZWN0aW9uLmluZm8oYi4kZWwuZ2V0KDApKTtpZihlLmF0U3RhcnQmJmIuc2VsZWN0aW9uLmlzQ29sbGFwc2VkKCkmJm51bGwhPWIuaHRtbC5kZWZhdWx0VGFnKCkpe3ZhciBmPWIubWFya2Vycy5pbnNlcnQoKTtpZihmJiYhYi5ub2RlLmJsb2NrUGFyZW50KGYpKXthKGYpLnJlbW92ZSgpO3ZhciBnPWIuJGVsLmZpbmQoYi5odG1sLmJsb2NrVGFnc1F1ZXJ5KCkpLmdldCgwKTtnJiYoYShnKS5wcmVwZW5kKGEuRkUuTUFSS0VSUyksYi5zZWxlY3Rpb24ucmVzdG9yZSgpKX1lbHNlIGYmJmEoZikucmVtb3ZlKCl9fWZ1bmN0aW9uIGooKXtjKGIuJGVsLFxcXCJmb2N1c1xcXCIsZnVuY3Rpb24oYSl7cCgpJiYoaSghMSksQz09PSExJiZ2KGEudHlwZSxbYV0pKX0pLGMoYi4kZWwsXFxcImJsdXJcXFwiLGZ1bmN0aW9uKGEpe3AoKSYmQz09PSEwJiYodihhLnR5cGUsW2FdKSxuKCkpfSkscihcXFwiZm9jdXNcXFwiLGZ1bmN0aW9uKCl7Qz0hMH0pLHIoXFxcImJsdXJcXFwiLGZ1bmN0aW9uKCl7Qz0hMX0pfWZ1bmN0aW9uIGsoKXtiLmhlbHBlcnMuaXNNb2JpbGUoKT8oYi5fbW91c2Vkb3duPVxcXCJ0b3VjaHN0YXJ0XFxcIixiLl9tb3VzZXVwPVxcXCJ0b3VjaGVuZFxcXCIsYi5fbW92ZT1cXFwidG91Y2htb3ZlXFxcIixiLl9tb3VzZW1vdmU9XFxcInRvdWNobW92ZVxcXCIpOihiLl9tb3VzZWRvd249XFxcIm1vdXNlZG93blxcXCIsYi5fbW91c2V1cD1cXFwibW91c2V1cFxcXCIsYi5fbW92ZT1cXFwiXFxcIixiLl9tb3VzZW1vdmU9XFxcIm1vdXNlbW92ZVxcXCIpfWZ1bmN0aW9uIGwoYyl7dmFyIGQ9YShjLmN1cnJlbnRUYXJnZXQpO3JldHVybiBiLmVkaXQuaXNEaXNhYmxlZCgpfHxkLmhhc0NsYXNzKFxcXCJmci1kaXNhYmxlZFxcXCIpPyhjLnByZXZlbnREZWZhdWx0KCksITEpOlxcXCJtb3VzZWRvd25cXFwiPT09Yy50eXBlJiYxIT09Yy53aGljaD8hMDooYi5oZWxwZXJzLmlzTW9iaWxlKCl8fGMucHJldmVudERlZmF1bHQoKSwoYi5oZWxwZXJzLmlzQW5kcm9pZCgpfHxiLmhlbHBlcnMuaXNXaW5kb3dzUGhvbmUoKSkmJjA9PT1kLnBhcmVudHMoXFxcIi5mci1kcm9wZG93bi1tZW51XFxcIikubGVuZ3RoJiYoYy5wcmV2ZW50RGVmYXVsdCgpLGMuc3RvcFByb3BhZ2F0aW9uKCkpLGQuYWRkQ2xhc3MoXFxcImZyLXNlbGVjdGVkXFxcIiksdm9pZCBiLmV2ZW50cy50cmlnZ2VyKFxcXCJjb21tYW5kcy5tb3VzZWRvd25cXFwiLFtkXSkpfWZ1bmN0aW9uIG0oYyxkKXt2YXIgZT1hKGMuY3VycmVudFRhcmdldCk7aWYoYi5lZGl0LmlzRGlzYWJsZWQoKXx8ZS5oYXNDbGFzcyhcXFwiZnItZGlzYWJsZWRcXFwiKSlyZXR1cm4gYy5wcmV2ZW50RGVmYXVsdCgpLCExO2lmKFxcXCJtb3VzZXVwXFxcIj09PWMudHlwZSYmMSE9PWMud2hpY2gpcmV0dXJuITA7aWYoIWUuaGFzQ2xhc3MoXFxcImZyLXNlbGVjdGVkXFxcIikpcmV0dXJuITA7aWYoXFxcInRvdWNobW92ZVxcXCIhPWMudHlwZSl7aWYoYy5zdG9wUHJvcGFnYXRpb24oKSxjLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpLGMucHJldmVudERlZmF1bHQoKSwhZS5oYXNDbGFzcyhcXFwiZnItc2VsZWN0ZWRcXFwiKSlyZXR1cm4gYShcXFwiLmZyLXNlbGVjdGVkXFxcIikucmVtb3ZlQ2xhc3MoXFxcImZyLXNlbGVjdGVkXFxcIiksITE7aWYoYShcXFwiLmZyLXNlbGVjdGVkXFxcIikucmVtb3ZlQ2xhc3MoXFxcImZyLXNlbGVjdGVkXFxcIiksZS5kYXRhKFxcXCJkcmFnZ2luZ1xcXCIpfHxlLmF0dHIoXFxcImRpc2FibGVkXFxcIikpcmV0dXJuIGUucmVtb3ZlRGF0YShcXFwiZHJhZ2dpbmdcXFwiKSwhMTt2YXIgZj1lLmRhdGEoXFxcInRpbWVvdXRcXFwiKTtmJiYoY2xlYXJUaW1lb3V0KGYpLGUucmVtb3ZlRGF0YShcXFwidGltZW91dFxcXCIpKSxkLmFwcGx5KGIsW2NdKX1lbHNlIGUuZGF0YShcXFwidGltZW91dFxcXCIpfHxlLmRhdGEoXFxcInRpbWVvdXRcXFwiLHNldFRpbWVvdXQoZnVuY3Rpb24oKXtlLmRhdGEoXFxcImRyYWdnaW5nXFxcIiwhMCl9LDEwMCkpfWZ1bmN0aW9uIG4oKXtBPSEwfWZ1bmN0aW9uIG8oKXtBPSExfWZ1bmN0aW9uIHAoKXtyZXR1cm4gQX1mdW5jdGlvbiBxKGEsYyxkKXtzKGEsYi5fbW91c2Vkb3duLGMsZnVuY3Rpb24oYSl7Yi5lZGl0LmlzRGlzYWJsZWQoKXx8bChhKX0sITApLHMoYSxiLl9tb3VzZXVwK1xcXCIgXFxcIitiLl9tb3ZlLGMsZnVuY3Rpb24oYSl7Yi5lZGl0LmlzRGlzYWJsZWQoKXx8bShhLGQpfSwhMCkscyhhLFxcXCJtb3VzZWRvd24gY2xpY2sgbW91c2V1cFxcXCIsYyxmdW5jdGlvbihhKXtiLmVkaXQuaXNEaXNhYmxlZCgpfHxhLnN0b3BQcm9wYWdhdGlvbigpfSwhMCkscihcXFwid2luZG93Lm1vdXNldXBcXFwiLGZ1bmN0aW9uKCl7Yi5lZGl0LmlzRGlzYWJsZWQoKXx8KGEuZmluZChjKS5yZW1vdmVDbGFzcyhcXFwiZnItc2VsZWN0ZWRcXFwiKSxuKCkpfSl9ZnVuY3Rpb24gcihhLGMsZCl7dmFyIGU9YS5zcGxpdChcXFwiIFxcXCIpO2lmKGUubGVuZ3RoPjEpe2Zvcih2YXIgZj0wO2Y8ZS5sZW5ndGg7ZisrKXIoZVtmXSxjLGQpO3JldHVybiEwfVxcXCJ1bmRlZmluZWRcXFwiPT10eXBlb2YgZCYmKGQ9ITEpO3ZhciBnO2c9MCE9YS5pbmRleE9mKFxcXCJzaGFyZWQuXFxcIik/QlthXT1CW2FdfHxbXTpiLnNoYXJlZC5fZXZlbnRzW2FdPWIuc2hhcmVkLl9ldmVudHNbYV18fFtdLGQ/Zy51bnNoaWZ0KGMpOmcucHVzaChjKX1mdW5jdGlvbiBzKGEsYyxkLGUsZil7XFxcImZ1bmN0aW9uXFxcIj09dHlwZW9mIGQmJihmPWUsZT1kLGQ9ITEpO3ZhciBnPWY/Yi5zaGFyZWQuJF9ldmVudHM6RCxoPWY/Yi5zaWQ6Yi5pZDtkP2Eub24oYy5zcGxpdChcXFwiIFxcXCIpLmpvaW4oXFxcIi5lZFxcXCIraCtcXFwiIFxcXCIpK1xcXCIuZWRcXFwiK2gsZCxlKTphLm9uKGMuc3BsaXQoXFxcIiBcXFwiKS5qb2luKFxcXCIuZWRcXFwiK2grXFxcIiBcXFwiKStcXFwiLmVkXFxcIitoLGUpLGcuaW5kZXhPZihhLmdldCgwKSk8MCYmZy5wdXNoKGEuZ2V0KDApKX1mdW5jdGlvbiB0KGIsYyl7Zm9yKHZhciBkPTA7ZDxiLmxlbmd0aDtkKyspYShiW2RdKS5vZmYoXFxcIi5lZFxcXCIrYyl9ZnVuY3Rpb24gdSgpe3QoRCxiLmlkKSxEPVtdLDA9PWIuc2hhcmVkLmNvdW50JiYodChiLnNoYXJlZC4kX2V2ZW50cyxiLnNpZCksYi5zaGFyZWQuJF9ldmVudHM9bnVsbCl9ZnVuY3Rpb24gdihjLGQsZSl7aWYoIWIuZWRpdC5pc0Rpc2FibGVkKCl8fGUpe3ZhciBmO2lmKDAhPWMuaW5kZXhPZihcXFwic2hhcmVkLlxcXCIpKWY9QltjXTtlbHNle2lmKGIuc2hhcmVkLmNvdW50PjApcmV0dXJuITE7Zj1iLnNoYXJlZC5fZXZlbnRzW2NdfXZhciBnO2lmKGYpZm9yKHZhciBoPTA7aDxmLmxlbmd0aDtoKyspaWYoZz1mW2hdLmFwcGx5KGIsZCksZz09PSExKXJldHVybiExO3JldHVybiBnPWIuJG9lbC50cmlnZ2VySGFuZGxlcihcXFwiZnJvYWxhRWRpdG9yLlxcXCIrYyxhLm1lcmdlKFtiXSxkfHxbXSkpLGc9PT0hMT8hMTpnfX1mdW5jdGlvbiB3KGMsZCxlKXtpZighYi5lZGl0LmlzRGlzYWJsZWQoKXx8ZSl7dmFyIGY7aWYoMCE9Yy5pbmRleE9mKFxcXCJzaGFyZWQuXFxcIikpZj1CW2NdO2Vsc2V7aWYoYi5zaGFyZWQuY291bnQ+MClyZXR1cm4hMTtmPWIuc2hhcmVkLl9ldmVudHNbY119dmFyIGc7aWYoZilmb3IodmFyIGg9MDtoPGYubGVuZ3RoO2grKylnPWZbaF0uYXBwbHkoYixbZF0pLFxcXCJ1bmRlZmluZWRcXFwiIT10eXBlb2YgZyYmKGQ9Zyk7cmV0dXJuIGc9Yi4kb2VsLnRyaWdnZXJIYW5kbGVyKFxcXCJmcm9hbGFFZGl0b3IuXFxcIitjLGEubWVyZ2UoW2JdLFtkXSkpLFxcXCJ1bmRlZmluZWRcXFwiIT10eXBlb2YgZyYmKGQ9ZyksZH19ZnVuY3Rpb24geCgpe2Zvcih2YXIgYSBpbiBCKUIuaGFzT3duUHJvcGVydHkoYSkmJmRlbGV0ZSBCW2FdfWZ1bmN0aW9uIHkoKXtmb3IodmFyIGEgaW4gYi5zaGFyZWQuX2V2ZW50cyliLnNoYXJlZC5fZXZlbnRzLmhhc093blByb3BlcnR5KGEpJiZkZWxldGUgYi5zaGFyZWQuX2V2ZW50c1thXX1mdW5jdGlvbiB6KCl7Yi5zaGFyZWQuJF9ldmVudHM9Yi5zaGFyZWQuJF9ldmVudHN8fFtdLGIuc2hhcmVkLl9ldmVudHM9e30saygpLGUoKSxnKCksaCgpLGYoKSxqKCksbigpLGQoKSxyKFxcXCJkZXN0cm95XFxcIix4KSxyKFxcXCJzaGFyZWQuZGVzdHJveVxcXCIseSl9dmFyIEEsQj17fSxDPSExLEQ9W107cmV0dXJue19pbml0Onosb246cix0cmlnZ2VyOnYsYmluZENsaWNrOnEsZGlzYWJsZUJsdXI6byxlbmFibGVCbHVyOm4sYmx1ckFjdGl2ZTpwLGZvY3VzOmksY2hhaW5UcmlnZ2VyOncsJG9uOnMsJG9mZjp1fX0sYS5GRS5JTlZJU0lCTEVfU1BBQ0U9XFxcIiYjODIwMztcXFwiLGEuRkUuU1RBUlRfTUFSS0VSPSc8c3BhbiBjbGFzcz1cXFwiZnItbWFya2VyXFxcIiBkYXRhLWlkPVxcXCIwXFxcIiBkYXRhLXR5cGU9XFxcInRydWVcXFwiIHN0eWxlPVxcXCJkaXNwbGF5OiBub25lOyBsaW5lLWhlaWdodDogMDtcXFwiPicrYS5GRS5JTlZJU0lCTEVfU1BBQ0UrXFxcIjwvc3Bhbj5cXFwiLGEuRkUuRU5EX01BUktFUj0nPHNwYW4gY2xhc3M9XFxcImZyLW1hcmtlclxcXCIgZGF0YS1pZD1cXFwiMFxcXCIgZGF0YS10eXBlPVxcXCJmYWxzZVxcXCIgc3R5bGU9XFxcImRpc3BsYXk6IG5vbmU7IGxpbmUtaGVpZ2h0OiAwO1xcXCI+JythLkZFLklOVklTSUJMRV9TUEFDRStcXFwiPC9zcGFuPlxcXCIsYS5GRS5NQVJLRVJTPWEuRkUuU1RBUlRfTUFSS0VSK2EuRkUuRU5EX01BUktFUixhLkZFLk1PRFVMRVMubWFya2Vycz1mdW5jdGlvbihiKXtmdW5jdGlvbiBjKGMsZCl7cmV0dXJuIGEoJzxzcGFuIGNsYXNzPVxcXCJmci1tYXJrZXJcXFwiIGRhdGEtaWQ9XFxcIicrZCsnXFxcIiBkYXRhLXR5cGU9XFxcIicrYysnXFxcIiBzdHlsZT1cXFwiZGlzcGxheTogJysoYi5icm93c2VyLnNhZmFyaT9cXFwibm9uZVxcXCI6XFxcImlubGluZS1ibG9ja1xcXCIpKyc7IGxpbmUtaGVpZ2h0OiAwO1xcXCI+JythLkZFLklOVklTSUJMRV9TUEFDRStcXFwiPC9zcGFuPlxcXCIsYi5kb2MpWzBdfWZ1bmN0aW9uIGQoZCxlLGYpe3RyeXt2YXIgZz1kLmNsb25lUmFuZ2UoKTtpZihnLmNvbGxhcHNlKGUpLGcuaW5zZXJ0Tm9kZShjKGUsZikpLGU9PT0hMCYmZC5jb2xsYXBzZWQpZm9yKHZhciBoPWIuJGVsLmZpbmQoJ3NwYW4uZnItbWFya2VyW2RhdGEtdHlwZT1cXFwidHJ1ZVxcXCJdW2RhdGEtaWQ9XFxcIicrZisnXFxcIl0nKSxpPWguZ2V0KDApLm5leHRTaWJsaW5nO2kmJmkubm9kZVR5cGU9PT1Ob2RlLlRFWFRfTk9ERSYmMD09PWkudGV4dENvbnRlbnQubGVuZ3RoOylhKGkpLnJlbW92ZSgpLGk9aC5uZXh0U2libGluZztpZihlPT09ITAmJiFkLmNvbGxhcHNlZCl7dmFyIGg9Yi4kZWwuZmluZCgnc3Bhbi5mci1tYXJrZXJbZGF0YS10eXBlPVxcXCJ0cnVlXFxcIl1bZGF0YS1pZD1cXFwiJytmKydcXFwiXScpLmdldCgwKSxpPWgubmV4dFNpYmxpbmc7aWYoaSYmaS5ub2RlVHlwZT09PU5vZGUuRUxFTUVOVF9OT0RFJiZiLm5vZGUuaXNCbG9jayhpKSl7dmFyIGo9W2ldO2RvIGk9alswXSxqPWIubm9kZS5jb250ZW50cyhpKTt3aGlsZShqWzBdJiZiLm5vZGUuaXNCbG9jayhqWzBdKSk7YShpKS5wcmVwZW5kKGEoaCkpfX1pZihlPT09ITEmJiFkLmNvbGxhcHNlZCl7dmFyIGg9Yi4kZWwuZmluZCgnc3Bhbi5mci1tYXJrZXJbZGF0YS10eXBlPVxcXCJmYWxzZVxcXCJdW2RhdGEtaWQ9XFxcIicrZisnXFxcIl0nKS5nZXQoMCksaT1oLnByZXZpb3VzU2libGluZztpZihpJiZpLm5vZGVUeXBlPT09Tm9kZS5FTEVNRU5UX05PREUmJmIubm9kZS5pc0Jsb2NrKGkpKXt2YXIgaj1baV07ZG8gaT1qW2oubGVuZ3RoLTFdLGo9Yi5ub2RlLmNvbnRlbnRzKGkpO3doaWxlKGpbai5sZW5ndGgtMV0mJmIubm9kZS5pc0Jsb2NrKGpbai5sZW5ndGgtMV0pKTthKGkpLmFwcGVuZChhKGgpKX1oLnBhcmVudE5vZGUmJltcXFwiVERcXFwiLFxcXCJUSFxcXCJdLmluZGV4T2YoaC5wYXJlbnROb2RlLnRhZ05hbWUpPj0wJiZoLnBhcmVudE5vZGUucHJldmlvdXNTaWJsaW5nJiYhaC5wcmV2aW91c1NpYmxpbmcmJmEoaC5wYXJlbnROb2RlLnByZXZpb3VzU2libGluZykuYXBwZW5kKGgpfXZhciBrPWIuJGVsLmZpbmQoJ3NwYW4uZnItbWFya2VyW2RhdGEtdHlwZT1cXFwiJytlKydcXFwiXVtkYXRhLWlkPVxcXCInK2YrJ1xcXCJdJykuZ2V0KDApO3JldHVybiBrJiYoay5zdHlsZS5kaXNwbGF5PVxcXCJub25lXFxcIiksa31jYXRjaChsKXtyZXR1cm4gbnVsbH19ZnVuY3Rpb24gZSgpe2lmKCFiLiR3cClyZXR1cm4gbnVsbDt0cnl7dmFyIGM9Yi5zZWxlY3Rpb24ucmFuZ2VzKDApLGQ9Yy5jb21tb25BbmNlc3RvckNvbnRhaW5lcjtpZihkIT1iLiRlbC5nZXQoMCkmJjA9PWIuJGVsLmZpbmQoZCkubGVuZ3RoKXJldHVybiBudWxsO3ZhciBlPWMuY2xvbmVSYW5nZSgpLGY9Yy5jbG9uZVJhbmdlKCk7ZS5jb2xsYXBzZSghMCk7dmFyIGc9YSgnPHNwYW4gY2xhc3M9XFxcImZyLW1hcmtlclxcXCIgc3R5bGU9XFxcImRpc3BsYXk6IG5vbmU7IGxpbmUtaGVpZ2h0OiAwO1xcXCI+JythLkZFLklOVklTSUJMRV9TUEFDRStcXFwiPC9zcGFuPlxcXCIsYi5kb2MpWzBdO2lmKGUuaW5zZXJ0Tm9kZShnKSxnPWIuJGVsLmZpbmQoXFxcInNwYW4uZnItbWFya2VyXFxcIikuZ2V0KDApKXtmb3IodmFyIGg9Zy5uZXh0U2libGluZztoJiZoLm5vZGVUeXBlPT09Tm9kZS5URVhUX05PREUmJjA9PT1oLnRleHRDb250ZW50Lmxlbmd0aDspYShoKS5yZW1vdmUoKSxoPWIuJGVsLmZpbmQoXFxcInNwYW4uZnItbWFya2VyXFxcIikuZ2V0KDApLm5leHRTaWJsaW5nO3JldHVybiBiLnNlbGVjdGlvbi5jbGVhcigpLGIuc2VsZWN0aW9uLmdldCgpLmFkZFJhbmdlKGYpLGd9cmV0dXJuIG51bGx9Y2F0Y2goaSl7fX1mdW5jdGlvbiBmKCl7Yi5zZWxlY3Rpb24uaXNDb2xsYXBzZWQoKXx8Yi5zZWxlY3Rpb24ucmVtb3ZlKCk7dmFyIGM9Yi4kZWwuZmluZChcXFwiLmZyLW1hcmtlclxcXCIpLmdldCgwKTtpZihudWxsPT1jJiYoYz1lKCkpLG51bGw9PWMpcmV0dXJuIG51bGw7dmFyIGQ7aWYoZD1iLm5vZGUuZGVlcGVzdFBhcmVudChjKSlpZihiLm5vZGUuaXNCbG9jayhkKSYmYi5ub2RlLmlzRW1wdHkoZCkpYShkKS5yZXBsYWNlV2l0aCgnPHNwYW4gY2xhc3M9XFxcImZyLW1hcmtlclxcXCI+PC9zcGFuPicpO2Vsc2V7dmFyIGY9YyxnPVxcXCJcXFwiLGg9XFxcIlxcXCI7ZG8gZj1mLnBhcmVudE5vZGUsZys9Yi5ub2RlLmNsb3NlVGFnU3RyaW5nKGYpLGg9Yi5ub2RlLm9wZW5UYWdTdHJpbmcoZikraDt3aGlsZShmIT1kKTthKGMpLnJlcGxhY2VXaXRoKCc8c3BhbiBpZD1cXFwiZnItYnJlYWtcXFwiPjwvc3Bhbj4nKTt2YXIgaT1iLm5vZGUub3BlblRhZ1N0cmluZyhkKSthKGQpLmh0bWwoKStiLm5vZGUuY2xvc2VUYWdTdHJpbmcoZCk7aT1pLnJlcGxhY2UoLzxzcGFuIGlkPVxcXCJmci1icmVha1xcXCI+PFxcXFwvc3Bhbj4vZyxnKyc8c3BhbiBjbGFzcz1cXFwiZnItbWFya2VyXFxcIj48L3NwYW4+JytoKSxhKGQpLnJlcGxhY2VXaXRoKGkpfXJldHVybiBiLiRlbC5maW5kKFxcXCIuZnItbWFya2VyXFxcIikuZ2V0KDApfWZ1bmN0aW9uIGcoYSl7dmFyIGM9YS5jbGllbnRYLGQ9YS5jbGllbnRZO2goKTtcXG52YXIgZixnPW51bGw7aWYoXFxcInVuZGVmaW5lZFxcXCIhPXR5cGVvZiBiLmRvYy5jYXJldFBvc2l0aW9uRnJvbVBvaW50PyhmPWIuZG9jLmNhcmV0UG9zaXRpb25Gcm9tUG9pbnQoYyxkKSxnPWIuZG9jLmNyZWF0ZVJhbmdlKCksZy5zZXRTdGFydChmLm9mZnNldE5vZGUsZi5vZmZzZXQpLGcuc2V0RW5kKGYub2Zmc2V0Tm9kZSxmLm9mZnNldCkpOlxcXCJ1bmRlZmluZWRcXFwiIT10eXBlb2YgYi5kb2MuY2FyZXRSYW5nZUZyb21Qb2ludCYmKGY9Yi5kb2MuY2FyZXRSYW5nZUZyb21Qb2ludChjLGQpLGc9Yi5kb2MuY3JlYXRlUmFuZ2UoKSxnLnNldFN0YXJ0KGYuc3RhcnRDb250YWluZXIsZi5zdGFydE9mZnNldCksZy5zZXRFbmQoZi5zdGFydENvbnRhaW5lcixmLnN0YXJ0T2Zmc2V0KSksbnVsbCE9PWcmJlxcXCJ1bmRlZmluZWRcXFwiIT10eXBlb2YgYi53aW4uZ2V0U2VsZWN0aW9uKXt2YXIgaT1iLndpbi5nZXRTZWxlY3Rpb24oKTtpLnJlbW92ZUFsbFJhbmdlcygpLGkuYWRkUmFuZ2UoZyl9ZWxzZSBpZihcXFwidW5kZWZpbmVkXFxcIiE9dHlwZW9mIGIuZG9jLmJvZHkuY3JlYXRlVGV4dFJhbmdlKXRyeXtnPWIuZG9jLmJvZHkuY3JlYXRlVGV4dFJhbmdlKCksZy5tb3ZlVG9Qb2ludChjLGQpO3ZhciBqPWcuZHVwbGljYXRlKCk7ai5tb3ZlVG9Qb2ludChjLGQpLGcuc2V0RW5kUG9pbnQoXFxcIkVuZFRvRW5kXFxcIixqKSxnLnNlbGVjdCgpfWNhdGNoKGspe3JldHVybiExfWUoKX1mdW5jdGlvbiBoKCl7Yi4kZWwuZmluZChcXFwiLmZyLW1hcmtlclxcXCIpLnJlbW92ZSgpfXJldHVybntwbGFjZTpkLGluc2VydDplLHNwbGl0OmYsaW5zZXJ0QXRQb2ludDpnLHJlbW92ZTpofX0sYS5GRS5NT0RVTEVTLnNlbGVjdGlvbj1mdW5jdGlvbihiKXtmdW5jdGlvbiBjKCl7dmFyIGE9XFxcIlxcXCI7cmV0dXJuIGIud2luLmdldFNlbGVjdGlvbj9hPWIud2luLmdldFNlbGVjdGlvbigpOmIuZG9jLmdldFNlbGVjdGlvbj9hPWIuZG9jLmdldFNlbGVjdGlvbigpOmIuZG9jLnNlbGVjdGlvbiYmKGE9Yi5kb2Muc2VsZWN0aW9uLmNyZWF0ZVJhbmdlKCkudGV4dCksYS50b1N0cmluZygpfWZ1bmN0aW9uIGQoKXt2YXIgYT1cXFwiXFxcIjtyZXR1cm4gYT1iLndpbi5nZXRTZWxlY3Rpb24/Yi53aW4uZ2V0U2VsZWN0aW9uKCk6Yi5kb2MuZ2V0U2VsZWN0aW9uP2IuZG9jLmdldFNlbGVjdGlvbigpOmIuZG9jLnNlbGVjdGlvbi5jcmVhdGVSYW5nZSgpfWZ1bmN0aW9uIGUoYSl7dmFyIGM9ZCgpLGU9W107aWYoYyYmYy5nZXRSYW5nZUF0JiZjLnJhbmdlQ291bnQpZm9yKHZhciBlPVtdLGY9MDtmPGMucmFuZ2VDb3VudDtmKyspZS5wdXNoKGMuZ2V0UmFuZ2VBdChmKSk7ZWxzZSBlPWIuZG9jLmNyZWF0ZVJhbmdlP1tiLmRvYy5jcmVhdGVSYW5nZSgpXTpbXTtyZXR1cm5cXFwidW5kZWZpbmVkXFxcIiE9dHlwZW9mIGE/ZVthXTplfWZ1bmN0aW9uIGYoKXt2YXIgYT1kKCk7dHJ5e2EucmVtb3ZlQWxsUmFuZ2VzP2EucmVtb3ZlQWxsUmFuZ2VzKCk6YS5lbXB0eT9hLmVtcHR5KCk6YS5jbGVhciYmYS5jbGVhcigpfWNhdGNoKGIpe319ZnVuY3Rpb24gZygpe3ZhciBmPWQoKTt0cnl7aWYoZi5yYW5nZUNvdW50KXt2YXIgZz1lKDApLGg9Zy5zdGFydENvbnRhaW5lcjtpZihoLm5vZGVUeXBlPT1Ob2RlLlRFWFRfTk9ERSYmZy5zdGFydE9mZnNldD09KGgudGV4dENvbnRlbnR8fFxcXCJcXFwiKS5sZW5ndGgmJmgubmV4dFNpYmxpbmcmJihoPWgubmV4dFNpYmxpbmcpLGgubm9kZVR5cGU9PU5vZGUuRUxFTUVOVF9OT0RFKXt2YXIgaT0hMTtpZihoLmNoaWxkTm9kZXMubGVuZ3RoPjAmJmguY2hpbGROb2Rlc1tnLnN0YXJ0T2Zmc2V0XSl7Zm9yKHZhciBqPWguY2hpbGROb2Rlc1tnLnN0YXJ0T2Zmc2V0XTtqJiZqLm5vZGVUeXBlPT1Ob2RlLlRFWFRfTk9ERSYmMD09ai50ZXh0Q29udGVudC5sZW5ndGg7KWo9ai5uZXh0U2libGluZztqJiZqLnRleHRDb250ZW50LnJlcGxhY2UoL1xcXFx1MjAwQi9nLFxcXCJcXFwiKT09PWMoKS5yZXBsYWNlKC9cXFxcdTIwMEIvZyxcXFwiXFxcIikmJihoPWosaT0hMCl9ZWxzZSBpZighZy5jb2xsYXBzZWQmJmgubmV4dFNpYmxpbmcmJmgubmV4dFNpYmxpbmcubm9kZVR5cGU9PU5vZGUuRUxFTUVOVF9OT0RFKXt2YXIgaj1oLm5leHRTaWJsaW5nO2omJmoudGV4dENvbnRlbnQucmVwbGFjZSgvXFxcXHUyMDBCL2csXFxcIlxcXCIpPT09YygpLnJlcGxhY2UoL1xcXFx1MjAwQi9nLFxcXCJcXFwiKSYmKGg9aixpPSEwKX0haSYmaC5jaGlsZE5vZGVzLmxlbmd0aD4wJiZhKGguY2hpbGROb2Rlc1swXSkudGV4dCgpLnJlcGxhY2UoL1xcXFx1MjAwQi9nLFxcXCJcXFwiKT09PWMoKS5yZXBsYWNlKC9cXFxcdTIwMEIvZyxcXFwiXFxcIikmJltcXFwiQlJcXFwiLFxcXCJJTUdcXFwiLFxcXCJIUlxcXCJdLmluZGV4T2YoaC5jaGlsZE5vZGVzWzBdLnRhZ05hbWUpPDAmJihoPWguY2hpbGROb2Rlc1swXSl9Zm9yKDtoLm5vZGVUeXBlIT1Ob2RlLkVMRU1FTlRfTk9ERSYmaC5wYXJlbnROb2RlOyloPWgucGFyZW50Tm9kZTtmb3IodmFyIGs9aDtrJiZcXFwiSFRNTFxcXCIhPWsudGFnTmFtZTspe2lmKGs9PWIuJGVsLmdldCgwKSlyZXR1cm4gaDtrPWEoaykucGFyZW50KClbMF19fX1jYXRjaChsKXt9cmV0dXJuIGIuJGVsLmdldCgwKX1mdW5jdGlvbiBoKCl7dmFyIGY9ZCgpO3RyeXtpZihmLnJhbmdlQ291bnQpe3ZhciBnPWUoMCksaD1nLmVuZENvbnRhaW5lcjtpZihoLm5vZGVUeXBlPT1Ob2RlLkVMRU1FTlRfTk9ERSl7dmFyIGk9ITE7aWYoaC5jaGlsZE5vZGVzLmxlbmd0aD4wJiZoLmNoaWxkTm9kZXNbZy5lbmRPZmZzZXRdJiZhKGguY2hpbGROb2Rlc1tnLmVuZE9mZnNldF0pLnRleHQoKT09PWMoKSloPWguY2hpbGROb2Rlc1tnLmVuZE9mZnNldF0saT0hMDtlbHNlIGlmKCFnLmNvbGxhcHNlZCYmaC5wcmV2aW91c1NpYmxpbmcmJmgucHJldmlvdXNTaWJsaW5nLm5vZGVUeXBlPT1Ob2RlLkVMRU1FTlRfTk9ERSl7dmFyIGo9aC5wcmV2aW91c1NpYmxpbmc7aiYmai50ZXh0Q29udGVudC5yZXBsYWNlKC9cXFxcdTIwMEIvZyxcXFwiXFxcIik9PT1jKCkucmVwbGFjZSgvXFxcXHUyMDBCL2csXFxcIlxcXCIpJiYoaD1qLGk9ITApfWVsc2UgaWYoIWcuY29sbGFwc2VkJiZoLmNoaWxkTm9kZXMubGVuZ3RoPjAmJmguY2hpbGROb2Rlc1tnLmVuZE9mZnNldF0pe3ZhciBqPWguY2hpbGROb2Rlc1tnLmVuZE9mZnNldF0ucHJldmlvdXNTaWJsaW5nO2oubm9kZVR5cGU9PU5vZGUuRUxFTUVOVF9OT0RFJiZqJiZqLnRleHRDb250ZW50LnJlcGxhY2UoL1xcXFx1MjAwQi9nLFxcXCJcXFwiKT09PWMoKS5yZXBsYWNlKC9cXFxcdTIwMEIvZyxcXFwiXFxcIikmJihoPWosaT0hMCl9IWkmJmguY2hpbGROb2Rlcy5sZW5ndGg+MCYmYShoLmNoaWxkTm9kZXNbaC5jaGlsZE5vZGVzLmxlbmd0aC0xXSkudGV4dCgpPT09YygpJiZbXFxcIkJSXFxcIixcXFwiSU1HXFxcIixcXFwiSFJcXFwiXS5pbmRleE9mKGguY2hpbGROb2Rlc1toLmNoaWxkTm9kZXMubGVuZ3RoLTFdLnRhZ05hbWUpPDAmJihoPWguY2hpbGROb2Rlc1toLmNoaWxkTm9kZXMubGVuZ3RoLTFdKX1mb3IoaC5ub2RlVHlwZT09Tm9kZS5URVhUX05PREUmJjA9PWcuZW5kT2Zmc2V0JiZoLnByZXZpb3VzU2libGluZyYmaC5wcmV2aW91c1NpYmxpbmcubm9kZVR5cGU9PU5vZGUuRUxFTUVOVF9OT0RFJiYoaD1oLnByZXZpb3VzU2libGluZyk7aC5ub2RlVHlwZSE9Tm9kZS5FTEVNRU5UX05PREUmJmgucGFyZW50Tm9kZTspaD1oLnBhcmVudE5vZGU7Zm9yKHZhciBrPWg7ayYmXFxcIkhUTUxcXFwiIT1rLnRhZ05hbWU7KXtpZihrPT1iLiRlbC5nZXQoMCkpcmV0dXJuIGg7az1hKGspLnBhcmVudCgpWzBdfX19Y2F0Y2gobCl7fXJldHVybiBiLiRlbC5nZXQoMCl9ZnVuY3Rpb24gaShhLGIpe3ZhciBjPWE7cmV0dXJuIGMubm9kZVR5cGU9PU5vZGUuRUxFTUVOVF9OT0RFJiZjLmNoaWxkTm9kZXMubGVuZ3RoPjAmJmMuY2hpbGROb2Rlc1tiXSYmKGM9Yy5jaGlsZE5vZGVzW2JdKSxjLm5vZGVUeXBlPT1Ob2RlLlRFWFRfTk9ERSYmKGM9Yy5wYXJlbnROb2RlKSxjfWZ1bmN0aW9uIGooKXt2YXIgYz1bXSxmPWQoKTtpZih0KCkmJmYucmFuZ2VDb3VudClmb3IodmFyIGc9ZSgpLGg9MDtoPGcubGVuZ3RoO2grKyl7dmFyIGo9Z1toXSxrPWkoai5zdGFydENvbnRhaW5lcixqLnN0YXJ0T2Zmc2V0KSxsPWkoai5lbmRDb250YWluZXIsai5lbmRPZmZzZXQpO2Iubm9kZS5pc0Jsb2NrKGspJiZjLmluZGV4T2Yoayk8MCYmYy5wdXNoKGspO3ZhciBtPWIubm9kZS5ibG9ja1BhcmVudChrKTttJiZjLmluZGV4T2YobSk8MCYmYy5wdXNoKG0pO2Zvcih2YXIgbj1bXSxvPWs7byE9PWwmJm8hPT1iLiRlbC5nZXQoMCk7KW4uaW5kZXhPZihvKTwwJiZvLmNoaWxkcmVuJiZvLmNoaWxkcmVuLmxlbmd0aD8obi5wdXNoKG8pLG89by5jaGlsZHJlblswXSk6by5uZXh0U2libGluZz9vPW8ubmV4dFNpYmxpbmc6by5wYXJlbnROb2RlJiYobz1vLnBhcmVudE5vZGUsbi5wdXNoKG8pKSxiLm5vZGUuaXNCbG9jayhvKSYmbi5pbmRleE9mKG8pPDAmJmMuaW5kZXhPZihvKTwwJiYobyE9PWx8fGouZW5kT2Zmc2V0PjApJiZjLnB1c2gobyk7Yi5ub2RlLmlzQmxvY2sobCkmJmMuaW5kZXhPZihsKTwwJiZqLmVuZE9mZnNldD4wJiZjLnB1c2gobCk7dmFyIG09Yi5ub2RlLmJsb2NrUGFyZW50KGwpO20mJmMuaW5kZXhPZihtKTwwJiZjLnB1c2gobSl9Zm9yKHZhciBoPWMubGVuZ3RoLTE7aD4wO2gtLSlhKGNbaF0pLmZpbmQoYykubGVuZ3RoJiZcXFwiTElcXFwiIT1jW2hdLnRhZ05hbWUmJmMuc3BsaWNlKGgsMSk7cmV0dXJuIGN9ZnVuY3Rpb24gaygpe2lmKGIuJHdwKXtiLm1hcmtlcnMucmVtb3ZlKCk7Zm9yKHZhciBhPWUoKSxjPVtdLGQ9MDtkPGEubGVuZ3RoO2QrKylpZihhW2RdLnN0YXJ0Q29udGFpbmVyIT09Yi5kb2Mpe3ZhciBmPWFbZF0sZz1mLmNvbGxhcHNlZCxoPWIubWFya2Vycy5wbGFjZShmLCEwLGQpLGk9Yi5tYXJrZXJzLnBsYWNlKGYsITEsZCk7aWYoYi4kZWwuZ2V0KDApLm5vcm1hbGl6ZSgpLGIuYnJvd3Nlci5zYWZhcmkmJiFnKXt2YXIgZj1iLmRvYy5jcmVhdGVSYW5nZSgpO2Yuc2V0U3RhcnRBZnRlcihoKSxmLnNldEVuZEJlZm9yZShpKSxjLnB1c2goZil9fWlmKGIuYnJvd3Nlci5zYWZhcmkmJmMubGVuZ3RoKXtiLnNlbGVjdGlvbi5jbGVhcigpO2Zvcih2YXIgZD0wO2Q8Yy5sZW5ndGg7ZCsrKWIuc2VsZWN0aW9uLmdldCgpLmFkZFJhbmdlKGNbZF0pfX19ZnVuY3Rpb24gbCgpe3ZhciBjPWIuJGVsLmdldCgwKS5xdWVyeVNlbGVjdG9yQWxsKCcuZnItbWFya2VyW2RhdGEtdHlwZT1cXFwidHJ1ZVxcXCJdJyk7aWYoIWIuJHdwKXJldHVybiBiLm1hcmtlcnMucmVtb3ZlKCksITE7aWYoMD09PWMubGVuZ3RoKXJldHVybiExO2lmKGIuYnJvd3Nlci5tc2llfHxiLmJyb3dzZXIuZWRnZSlmb3IodmFyIGU9MDtlPGMubGVuZ3RoO2UrKyljW2VdLnN0eWxlLmRpc3BsYXk9XFxcImlubGluZS1ibG9ja1xcXCI7Yi5jb3JlLmhhc0ZvY3VzKCl8fGIuYnJvd3Nlci5tc2llfHxiLmJyb3dzZXIud2Via2l0fHxiLiRlbC5mb2N1cygpLGYoKTtmb3IodmFyIGc9ZCgpLGU9MDtlPGMubGVuZ3RoO2UrKyl7dmFyIGg9YShjW2VdKS5kYXRhKFxcXCJpZFxcXCIpLGk9Y1tlXSxqPWIuZG9jLmNyZWF0ZVJhbmdlKCksaz1iLiRlbC5maW5kKCcuZnItbWFya2VyW2RhdGEtdHlwZT1cXFwiZmFsc2VcXFwiXVtkYXRhLWlkPVxcXCInK2grJ1xcXCJdJyk7KGIuYnJvd3Nlci5tc2llfHxiLmJyb3dzZXIuZWRnZSkmJmsuY3NzKFxcXCJkaXNwbGF5XFxcIixcXFwiaW5saW5lLWJsb2NrXFxcIik7dmFyIGw9bnVsbDtpZihrLmxlbmd0aD4wKXtrPWtbMF07dHJ5e2Zvcih2YXIgbj0hMSxvPWkubmV4dFNpYmxpbmc7byYmby5ub2RlVHlwZT09Tm9kZS5URVhUX05PREUmJjA9PW8udGV4dENvbnRlbnQubGVuZ3RoOyl7dmFyIHA9bztvPW8ubmV4dFNpYmxpbmcsYShwKS5yZW1vdmUoKX1mb3IodmFyIHE9ay5uZXh0U2libGluZztxJiZxLm5vZGVUeXBlPT1Ob2RlLlRFWFRfTk9ERSYmMD09cS50ZXh0Q29udGVudC5sZW5ndGg7KXt2YXIgcD1xO3E9cS5uZXh0U2libGluZyxhKHApLnJlbW92ZSgpfWlmKGkubmV4dFNpYmxpbmc9PWt8fGsubmV4dFNpYmxpbmc9PWkpe2Zvcih2YXIgcj1pLm5leHRTaWJsaW5nPT1rP2k6ayxzPXI9PWk/azppLHQ9ci5wcmV2aW91c1NpYmxpbmc7dCYmdC5ub2RlVHlwZT09Tm9kZS5URVhUX05PREUmJjA9PXQubGVuZ3RoOyl7dmFyIHA9dDt0PXQucHJldmlvdXNTaWJsaW5nLGEocCkucmVtb3ZlKCl9aWYodCYmdC5ub2RlVHlwZT09Tm9kZS5URVhUX05PREUpZm9yKDt0JiZ0LnByZXZpb3VzU2libGluZyYmdC5wcmV2aW91c1NpYmxpbmcubm9kZVR5cGU9PU5vZGUuVEVYVF9OT0RFOyl0LnByZXZpb3VzU2libGluZy50ZXh0Q29udGVudD10LnByZXZpb3VzU2libGluZy50ZXh0Q29udGVudCt0LnRleHRDb250ZW50LHQ9dC5wcmV2aW91c1NpYmxpbmcsYSh0Lm5leHRTaWJsaW5nKS5yZW1vdmUoKTtmb3IodmFyIHU9cy5uZXh0U2libGluZzt1JiZ1Lm5vZGVUeXBlPT1Ob2RlLlRFWFRfTk9ERSYmMD09dS5sZW5ndGg7KXt2YXIgcD11O3U9dS5uZXh0U2libGluZyxhKHApLnJlbW92ZSgpfWlmKHUmJnUubm9kZVR5cGU9PU5vZGUuVEVYVF9OT0RFKWZvcig7dSYmdS5uZXh0U2libGluZyYmdS5uZXh0U2libGluZy5ub2RlVHlwZT09Tm9kZS5URVhUX05PREU7KXUubmV4dFNpYmxpbmcudGV4dENvbnRlbnQ9dS50ZXh0Q29udGVudCt1Lm5leHRTaWJsaW5nLnRleHRDb250ZW50LHU9dS5uZXh0U2libGluZyxhKHUucHJldmlvdXNTaWJsaW5nKS5yZW1vdmUoKTtpZih0JiYoYi5ub2RlLmlzVm9pZCh0KXx8Yi5ub2RlLmlzQmxvY2sodCkpJiYodD1udWxsKSx1JiYoYi5ub2RlLmlzVm9pZCh1KXx8Yi5ub2RlLmlzQmxvY2sodSkpJiYodT1udWxsKSx0JiZ1JiZ0Lm5vZGVUeXBlPT1Ob2RlLlRFWFRfTk9ERSYmdS5ub2RlVHlwZT09Tm9kZS5URVhUX05PREUpe2EoaSkucmVtb3ZlKCksYShrKS5yZW1vdmUoKTt2YXIgdj10LnRleHRDb250ZW50Lmxlbmd0aDt0LnRleHRDb250ZW50PXQudGV4dENvbnRlbnQrdS50ZXh0Q29udGVudCxhKHUpLnJlbW92ZSgpLGIuc3BhY2VzLm5vcm1hbGl6ZSh0KSxqLnNldFN0YXJ0KHQsdiksai5zZXRFbmQodCx2KSxuPSEwfWVsc2UhdCYmdSYmdS5ub2RlVHlwZT09Tm9kZS5URVhUX05PREU/KGEoaSkucmVtb3ZlKCksYShrKS5yZW1vdmUoKSxiLnNwYWNlcy5ub3JtYWxpemUodSksbD1hKGIuZG9jLmNyZWF0ZVRleHROb2RlKFxcXCJcXFxcdTIwMGJcXFwiKSksYSh1KS5iZWZvcmUobCksai5zZXRTdGFydCh1LDApLGouc2V0RW5kKHUsMCksbj0hMCk6IXUmJnQmJnQubm9kZVR5cGU9PU5vZGUuVEVYVF9OT0RFJiYoYShpKS5yZW1vdmUoKSxhKGspLnJlbW92ZSgpLGIuc3BhY2VzLm5vcm1hbGl6ZSh0KSxsPWEoYi5kb2MuY3JlYXRlVGV4dE5vZGUoXFxcIlxcXFx1MjAwYlxcXCIpKSxhKHQpLmFmdGVyKGwpLGouc2V0U3RhcnQodCx0LnRleHRDb250ZW50Lmxlbmd0aCksai5zZXRFbmQodCx0LnRleHRDb250ZW50Lmxlbmd0aCksbj0hMCl9aWYoIW4pe3ZhciB3LHg7aWYoYi5icm93c2VyLmNocm9tZSYmaS5uZXh0U2libGluZz09ayl3PW0oayxqLCEwKXx8ai5zZXRTdGFydEFmdGVyKGspLHg9bShpLGosITEpfHxqLnNldEVuZEJlZm9yZShpKTtlbHNle2kucHJldmlvdXNTaWJsaW5nPT1rJiYoaT1rLGs9aS5uZXh0U2libGluZyksay5uZXh0U2libGluZyYmXFxcIkJSXFxcIj09PWsubmV4dFNpYmxpbmcudGFnTmFtZXx8IWsubmV4dFNpYmxpbmcmJmIubm9kZS5pc0Jsb2NrKGkucHJldmlvdXNTaWJsaW5nKXx8aS5wcmV2aW91c1NpYmxpbmcmJlxcXCJCUlxcXCI9PWkucHJldmlvdXNTaWJsaW5nLnRhZ05hbWV8fChpLnN0eWxlLmRpc3BsYXk9XFxcImlubGluZVxcXCIsay5zdHlsZS5kaXNwbGF5PVxcXCJpbmxpbmVcXFwiLGw9YShiLmRvYy5jcmVhdGVUZXh0Tm9kZShcXFwiXFxcXHUyMDBiXFxcIikpKTt2YXIgeT1pLnByZXZpb3VzU2libGluZzt5JiZ5LnN0eWxlJiZcXFwiYmxvY2tcXFwiPT1iLndpbi5nZXRDb21wdXRlZFN0eWxlKHkpLmRpc3BsYXkmJiFiLm9wdHMuZW50ZXI9PWEuRkUuRU5URVJfQlI/KGouc2V0RW5kQWZ0ZXIoeSksai5zZXRTdGFydEFmdGVyKHkpKToodz1tKGksaiwhMCl8fGEoaSkuYmVmb3JlKGwpJiZqLnNldFN0YXJ0QmVmb3JlKGkpLHg9bShrLGosITEpfHxhKGspLmFmdGVyKGwpJiZqLnNldEVuZEFmdGVyKGspKX1cXFwiZnVuY3Rpb25cXFwiPT10eXBlb2YgdyYmdygpLFxcXCJmdW5jdGlvblxcXCI9PXR5cGVvZiB4JiZ4KCl9fWNhdGNoKHope319bCYmbC5yZW1vdmUoKTt0cnl7Zy5hZGRSYW5nZShqKX1jYXRjaCh6KXt9fWIubWFya2Vycy5yZW1vdmUoKX1mdW5jdGlvbiBtKGMsZCxlKXt2YXIgZj1jLnByZXZpb3VzU2libGluZyxnPWMubmV4dFNpYmxpbmc7aWYoZiYmZyYmZi5ub2RlVHlwZT09Tm9kZS5URVhUX05PREUmJmcubm9kZVR5cGU9PU5vZGUuVEVYVF9OT0RFKXt2YXIgaD1mLnRleHRDb250ZW50Lmxlbmd0aDtyZXR1cm4gZT8oZy50ZXh0Q29udGVudD1mLnRleHRDb250ZW50K2cudGV4dENvbnRlbnQsYShmKS5yZW1vdmUoKSxhKGMpLnJlbW92ZSgpLGIuc3BhY2VzLm5vcm1hbGl6ZShnKSxmdW5jdGlvbigpe2Quc2V0U3RhcnQoZyxoKX0pOihmLnRleHRDb250ZW50PWYudGV4dENvbnRlbnQrZy50ZXh0Q29udGVudCxhKGcpLnJlbW92ZSgpLGEoYykucmVtb3ZlKCksYi5zcGFjZXMubm9ybWFsaXplKGYpLGZ1bmN0aW9uKCl7ZC5zZXRFbmQoZixoKX0pfWlmKGYmJiFnJiZmLm5vZGVUeXBlPT1Ob2RlLlRFWFRfTk9ERSl7dmFyIGg9Zi50ZXh0Q29udGVudC5sZW5ndGg7cmV0dXJuIGU/KGIuc3BhY2VzLm5vcm1hbGl6ZShmKSxmdW5jdGlvbigpe2Quc2V0U3RhcnQoZixoKX0pOihiLnNwYWNlcy5ub3JtYWxpemUoZiksZnVuY3Rpb24oKXtkLnNldEVuZChmLGgpfSl9cmV0dXJuIGcmJiFmJiZnLm5vZGVUeXBlPT1Ob2RlLlRFWFRfTk9ERT9lPyhiLnNwYWNlcy5ub3JtYWxpemUoZyksZnVuY3Rpb24oKXtkLnNldFN0YXJ0KGcsMCl9KTooYi5zcGFjZXMubm9ybWFsaXplKGcpLGZ1bmN0aW9uKCl7ZC5zZXRFbmQoZywwKX0pOiExfWZ1bmN0aW9uIG4oKXtyZXR1cm4hMH1mdW5jdGlvbiBvKCl7Zm9yKHZhciBhPWUoKSxiPTA7YjxhLmxlbmd0aDtiKyspaWYoIWFbYl0uY29sbGFwc2VkKXJldHVybiExO3JldHVybiEwfWZ1bmN0aW9uIHAoYSl7dmFyIGMsZCxlPSExLGY9ITE7aWYoYi53aW4uZ2V0U2VsZWN0aW9uKXt2YXIgZz1iLndpbi5nZXRTZWxlY3Rpb24oKTtnLnJhbmdlQ291bnQmJihjPWcuZ2V0UmFuZ2VBdCgwKSxkPWMuY2xvbmVSYW5nZSgpLGQuc2VsZWN0Tm9kZUNvbnRlbnRzKGEpLGQuc2V0RW5kKGMuc3RhcnRDb250YWluZXIsYy5zdGFydE9mZnNldCksZT1cXFwiXFxcIj09PWQudG9TdHJpbmcoKSxkLnNlbGVjdE5vZGVDb250ZW50cyhhKSxkLnNldFN0YXJ0KGMuZW5kQ29udGFpbmVyLGMuZW5kT2Zmc2V0KSxmPVxcXCJcXFwiPT09ZC50b1N0cmluZygpKX1lbHNlIGIuZG9jLnNlbGVjdGlvbiYmXFxcIkNvbnRyb2xcXFwiIT1iLmRvYy5zZWxlY3Rpb24udHlwZSYmKGM9Yi5kb2Muc2VsZWN0aW9uLmNyZWF0ZVJhbmdlKCksZD1jLmR1cGxpY2F0ZSgpLGQubW92ZVRvRWxlbWVudFRleHQoYSksZC5zZXRFbmRQb2ludChcXFwiRW5kVG9TdGFydFxcXCIsYyksZT1cXFwiXFxcIj09PWQudGV4dCxkLm1vdmVUb0VsZW1lbnRUZXh0KGEpLGQuc2V0RW5kUG9pbnQoXFxcIlN0YXJ0VG9FbmRcXFwiLGMpLGY9XFxcIlxcXCI9PT1kLnRleHQpO3JldHVybnthdFN0YXJ0OmUsYXRFbmQ6Zn19ZnVuY3Rpb24gcSgpe2lmKG8oKSlyZXR1cm4hMTtiLiRlbC5maW5kKFxcXCJ0ZFxcXCIpLnByZXBlbmQoJzxzcGFuIGNsYXNzPVxcXCJmci1ta1xcXCI+JythLkZFLklOVklTSUJMRV9TUEFDRStcXFwiPC9zcGFuPlxcXCIpLGIuJGVsLmZpbmQoXFxcImltZ1xcXCIpLmFwcGVuZCgnPHNwYW4gY2xhc3M9XFxcImZyLW1rXFxcIj4nK2EuRkUuSU5WSVNJQkxFX1NQQUNFK1xcXCI8L3NwYW4+XFxcIik7dmFyIGM9ITEsZD1wKGIuJGVsLmdldCgwKSk7cmV0dXJuIGQuYXRTdGFydCYmZC5hdEVuZCYmKGM9ITApLGIuJGVsLmZpbmQoXFxcIi5mci1ta1xcXCIpLnJlbW92ZSgpLGN9ZnVuY3Rpb24gcihjLGQpe1xcXCJ1bmRlZmluZWRcXFwiPT10eXBlb2YgZCYmKGQ9ITApO3ZhciBlPWEoYykuaHRtbCgpO2UmJmUucmVwbGFjZSgvXFxcXHUyMDBiL2csXFxcIlxcXCIpLmxlbmd0aCE9ZS5sZW5ndGgmJmEoYykuaHRtbChlLnJlcGxhY2UoL1xcXFx1MjAwYi9nLFxcXCJcXFwiKSk7Zm9yKHZhciBmPWIubm9kZS5jb250ZW50cyhjKSxnPTA7ZzxmLmxlbmd0aDtnKyspZltnXS5ub2RlVHlwZSE9Tm9kZS5FTEVNRU5UX05PREU/YShmW2ddKS5yZW1vdmUoKToocihmW2ddLDA9PWcpLDA9PWcmJihkPSExKSk7Yy5ub2RlVHlwZT09Tm9kZS5URVhUX05PREU/YShjKS5yZXBsYWNlV2l0aCgnPHNwYW4gZGF0YS1maXJzdD1cXFwidHJ1ZVxcXCIgZGF0YS10ZXh0PVxcXCJ0cnVlXFxcIj48L3NwYW4+Jyk6ZCYmYShjKS5hdHRyKFxcXCJkYXRhLWZpcnN0XFxcIiwhMCl9ZnVuY3Rpb24gcyhjLGQpe3ZhciBlPWIubm9kZS5jb250ZW50cyhjLmdldCgwKSk7W1xcXCJURFxcXCIsXFxcIlRIXFxcIl0uaW5kZXhPZihjLmdldCgwKS50YWdOYW1lKT49MCYmMT09Yy5maW5kKFxcXCIuZnItbWFya2VyXFxcIikubGVuZ3RoJiZhKGVbMF0pLmhhc0NsYXNzKFxcXCJmci1tYXJrZXJcXFwiKSYmYy5hdHRyKFxcXCJkYXRhLWRlbC1jZWxsXFxcIiwhMCk7Zm9yKHZhciBmPTA7ZjxlLmxlbmd0aDtmKyspe3ZhciBnPWVbZl07YShnKS5oYXNDbGFzcyhcXFwiZnItbWFya2VyXFxcIik/ZD0oZCsxKSUyOmQ/YShnKS5maW5kKFxcXCIuZnItbWFya2VyXFxcIikubGVuZ3RoPjA/ZD1zKGEoZyksZCk6W1xcXCJURFxcXCIsXFxcIlRIXFxcIl0uaW5kZXhPZihnLnRhZ05hbWUpPDAmJiFhKGcpLmhhc0NsYXNzKFxcXCJmci1pbm5lclxcXCIpPyFiLm9wdHMua2VlcEZvcm1hdE9uRGVsZXRlfHxiLiRlbC5maW5kKFxcXCJbZGF0YS1maXJzdF1cXFwiKS5sZW5ndGg+MD9hKGcpLnJlbW92ZSgpOnIoZyk6YShnKS5oYXNDbGFzcyhcXFwiZnItaW5uZXJcXFwiKT8wPT1hKGcpLmZpbmQoXFxcIi5mci1pbm5lclxcXCIpLmxlbmd0aD9hKGcpLmh0bWwoXFxcIjxicj5cXFwiKTphKGcpLmZpbmQoXFxcIi5mci1pbm5lclxcXCIpLmZpbHRlcihmdW5jdGlvbigpe3JldHVybiAwPT1hKHRoaXMpLmZpbmQoXFxcImZyLWlubmVyXFxcIikubGVuZ3RofSkuaHRtbChcXFwiPGJyPlxcXCIpOihhKGcpLmVtcHR5KCksYShnKS5hdHRyKFxcXCJkYXRhLWRlbC1jZWxsXFxcIiwhMCkpOmEoZykuZmluZChcXFwiLmZyLW1hcmtlclxcXCIpLmxlbmd0aD4wJiYoZD1zKGEoZyksZCkpfXJldHVybiBkfWZ1bmN0aW9uIHQoKXt0cnl7aWYoIWIuJHdwKXJldHVybiExO2Zvcih2YXIgYT1lKDApLGM9YS5jb21tb25BbmNlc3RvckNvbnRhaW5lcjtjJiYhYi5ub2RlLmlzRWxlbWVudChjKTspYz1jLnBhcmVudE5vZGU7cmV0dXJuIGIubm9kZS5pc0VsZW1lbnQoYyk/ITA6ITF9Y2F0Y2goZCl7cmV0dXJuITF9fWZ1bmN0aW9uIHUoKXtpZihvKCkpcmV0dXJuITA7aygpO2Zvcih2YXIgYz1mdW5jdGlvbihiKXtmb3IodmFyIGM9Yi5wcmV2aW91c1NpYmxpbmc7YyYmYy5ub2RlVHlwZT09Tm9kZS5URVhUX05PREUmJjA9PWMudGV4dENvbnRlbnQubGVuZ3RoOyl7dmFyIGQ9YyxjPWMucHJldmlvdXNTaWJsaW5nO2EoZCkucmVtb3ZlKCl9cmV0dXJuIGN9LGQ9ZnVuY3Rpb24oYil7Zm9yKHZhciBjPWIubmV4dFNpYmxpbmc7YyYmYy5ub2RlVHlwZT09Tm9kZS5URVhUX05PREUmJjA9PWMudGV4dENvbnRlbnQubGVuZ3RoOyl7dmFyIGQ9YyxjPWMubmV4dFNpYmxpbmc7YShkKS5yZW1vdmUoKX1yZXR1cm4gY30sZT1iLiRlbC5maW5kKCcuZnItbWFya2VyW2RhdGEtdHlwZT1cXFwidHJ1ZVxcXCJdJyksZj0wO2Y8ZS5sZW5ndGg7ZisrKWZvcih2YXIgZz1lW2ZdOyFjKGcpJiYhYi5ub2RlLmlzQmxvY2soZy5wYXJlbnROb2RlKSYmIWIuJGVsLmlzKGcucGFyZW50Tm9kZSk7KWEoZy5wYXJlbnROb2RlKS5iZWZvcmUoZyk7Zm9yKHZhciBoPWIuJGVsLmZpbmQoJy5mci1tYXJrZXJbZGF0YS10eXBlPVxcXCJmYWxzZVxcXCJdJyksZj0wO2Y8aC5sZW5ndGg7ZisrKXtmb3IodmFyIGk9aFtmXTshZChpKSYmIWIubm9kZS5pc0Jsb2NrKGkucGFyZW50Tm9kZSkmJiFiLiRlbC5pcyhpLnBhcmVudE5vZGUpOylhKGkucGFyZW50Tm9kZSkuYWZ0ZXIoaSk7aS5wYXJlbnROb2RlJiZiLm5vZGUuaXNCbG9jayhpLnBhcmVudE5vZGUpJiZiLm5vZGUuaXNFbXB0eShpLnBhcmVudE5vZGUpJiYhYi4kZWwuaXMoaS5wYXJlbnROb2RlKSYmYShpLnBhcmVudE5vZGUpLmFmdGVyKGkpfWlmKG4oKSl7cyhiLiRlbCwwKTt2YXIgaj1iLiRlbC5maW5kKCdbZGF0YS1maXJzdD1cXFwidHJ1ZVxcXCJdJyk7aWYoai5sZW5ndGgpYi4kZWwuZmluZChcXFwiLmZyLW1hcmtlclxcXCIpLnJlbW92ZSgpLGouYXBwZW5kKGEuRkUuSU5WSVNJQkxFX1NQQUNFK2EuRkUuTUFSS0VSUykucmVtb3ZlQXR0cihcXFwiZGF0YS1maXJzdFxcXCIpLGouYXR0cihcXFwiZGF0YS10ZXh0XFxcIikmJmoucmVwbGFjZVdpdGgoai5odG1sKCkpO2Vsc2V7Yi4kZWwuZmluZChcXFwidGFibGVcXFwiKS5maWx0ZXIoZnVuY3Rpb24oKXt2YXIgYj1hKHRoaXMpLmZpbmQoXFxcIltkYXRhLWRlbC1jZWxsXVxcXCIpLmxlbmd0aD4wJiZhKHRoaXMpLmZpbmQoXFxcIltkYXRhLWRlbC1jZWxsXVxcXCIpLmxlbmd0aD09YSh0aGlzKS5maW5kKFxcXCJ0ZCwgdGhcXFwiKS5sZW5ndGg7cmV0dXJuIGJ9KS5yZW1vdmUoKSxiLiRlbC5maW5kKFxcXCJbZGF0YS1kZWwtY2VsbF1cXFwiKS5yZW1vdmVBdHRyKFxcXCJkYXRhLWRlbC1jZWxsXFxcIik7Zm9yKHZhciBlPWIuJGVsLmZpbmQoJy5mci1tYXJrZXJbZGF0YS10eXBlPVxcXCJ0cnVlXFxcIl0nKSxmPTA7ZjxlLmxlbmd0aDtmKyspe3ZhciBtPWVbZl0scD1tLm5leHRTaWJsaW5nLHE9Yi4kZWwuZmluZCgnLmZyLW1hcmtlcltkYXRhLXR5cGU9XFxcImZhbHNlXFxcIl1bZGF0YS1pZD1cXFwiJythKG0pLmRhdGEoXFxcImlkXFxcIikrJ1xcXCJdJykuZ2V0KDApO2lmKHEpe2lmKHAmJnA9PXEpO2Vsc2UgaWYobSl7dmFyIHI9Yi5ub2RlLmJsb2NrUGFyZW50KG0pLHQ9Yi5ub2RlLmJsb2NrUGFyZW50KHEpLHU9ITEsdj0hMTtpZihyJiZbXFxcIlVMXFxcIixcXFwiT0xcXFwiXS5pbmRleE9mKHIudGFnTmFtZSk+PTAmJihyPW51bGwsdT0hMCksdCYmW1xcXCJVTFxcXCIsXFxcIk9MXFxcIl0uaW5kZXhPZih0LnRhZ05hbWUpPj0wJiYodD1udWxsLHY9ITApLGEobSkuYWZ0ZXIocSkscj09dCk7ZWxzZSBpZihudWxsIT1yfHx1KWlmKG51bGwhPXR8fHZ8fDAhPWEocikucGFyZW50c1VudGlsKGIuJGVsLFxcXCJ0YWJsZVxcXCIpLmxlbmd0aClyJiZ0JiYwPT1hKHIpLnBhcmVudHNVbnRpbChiLiRlbCxcXFwidGFibGVcXFwiKS5sZW5ndGgmJjA9PWEodCkucGFyZW50c1VudGlsKGIuJGVsLFxcXCJ0YWJsZVxcXCIpLmxlbmd0aCYmKGEocikuYXBwZW5kKGEodCkuaHRtbCgpKSxhKHQpLnJlbW92ZSgpKTtlbHNle2Zvcih2YXIgcD1yOyFwLm5leHRTaWJsaW5nJiZwLnBhcmVudE5vZGUhPWIuJGVsLmdldCgwKTspcD1wLnBhcmVudE5vZGU7Zm9yKHA9cC5uZXh0U2libGluZztwJiZcXFwiQlJcXFwiIT1wLnRhZ05hbWU7KXt2YXIgdz1wLm5leHRTaWJsaW5nO2EocikuYXBwZW5kKHApLHA9d31wJiZcXFwiQlJcXFwiPT1wLnRhZ05hbWUmJmEocCkucmVtb3ZlKCl9ZWxzZXt2YXIgeD1iLm5vZGUuZGVlcGVzdFBhcmVudChtKTt4PyhhKHgpLmFmdGVyKGEodCkuaHRtbCgpKSxhKHQpLnJlbW92ZSgpKTowPT1hKHQpLnBhcmVudHNVbnRpbChiLiRlbCxcXFwidGFibGVcXFwiKS5sZW5ndGgmJihhKG0pLm5leHQoKS5hZnRlcihhKHQpLmh0bWwoKSksYSh0KS5yZW1vdmUoKSl9fX1lbHNlIHE9YShtKS5jbG9uZSgpLmF0dHIoXFxcImRhdGEtdHlwZVxcXCIsITEpLGEobSkuYWZ0ZXIocSl9fX1iLm9wdHMua2VlcEZvcm1hdE9uRGVsZXRlfHxiLmh0bWwuZmlsbEVtcHR5QmxvY2tzKCksYi5odG1sLmNsZWFuRW1wdHlUYWdzKCEwKSxiLmNsZWFuLmxpc3RzKCksYi5zcGFjZXMubm9ybWFsaXplKCk7dmFyIHk9Yi4kZWwuZmluZChcXFwiLmZyLW1hcmtlcjpsYXN0XFxcIikuZ2V0KDApLHo9Yi4kZWwuZmluZChcXFwiLmZyLW1hcmtlcjpmaXJzdFxcXCIpLmdldCgwKTsheS5uZXh0U2libGluZyYmei5wcmV2aW91c1NpYmxpbmcmJlxcXCJCUlxcXCI9PXoucHJldmlvdXNTaWJsaW5nLnRhZ05hbWUmJmIubm9kZS5pc0VsZW1lbnQoeS5wYXJlbnROb2RlKSYmYi5ub2RlLmlzRWxlbWVudCh6LnBhcmVudE5vZGUpJiZiLiRlbC5hcHBlbmQoXFxcIjxicj5cXFwiKSxsKCl9ZnVuY3Rpb24gdihjKXtpZihhKGMpLmZpbmQoXFxcIi5mci1tYXJrZXJcXFwiKS5sZW5ndGg+MClyZXR1cm4hMTtmb3IodmFyIGQ9Yi5ub2RlLmNvbnRlbnRzKGMpO2QubGVuZ3RoJiZiLm5vZGUuaXNCbG9jayhkWzBdKTspYz1kWzBdLGQ9Yi5ub2RlLmNvbnRlbnRzKGMpO2EoYykucHJlcGVuZChhLkZFLk1BUktFUlMpfWZ1bmN0aW9uIHcoYyl7aWYoYShjKS5maW5kKFxcXCIuZnItbWFya2VyXFxcIikubGVuZ3RoPjApcmV0dXJuITE7Zm9yKHZhciBkPWIubm9kZS5jb250ZW50cyhjKTtkLmxlbmd0aCYmYi5ub2RlLmlzQmxvY2soZFtkLmxlbmd0aC0xXSk7KWM9ZFtkLmxlbmd0aC0xXSxkPWIubm9kZS5jb250ZW50cyhjKTthKGMpLmFwcGVuZChhLkZFLk1BUktFUlMpfWZ1bmN0aW9uIHgoYyl7Zm9yKHZhciBkPWMucHJldmlvdXNTaWJsaW5nO2QmJmQubm9kZVR5cGU9PU5vZGUuVEVYVF9OT0RFJiYwPT1kLnRleHRDb250ZW50Lmxlbmd0aDspZD1kLnByZXZpb3VzU2libGluZztyZXR1cm4gZD8oYi5ub2RlLmlzQmxvY2soZCk/dyhkKTpcXFwiQlJcXFwiPT1kLnRhZ05hbWU/YShkKS5iZWZvcmUoYS5GRS5NQVJLRVJTKTphKGQpLmFmdGVyKGEuRkUuTUFSS0VSUyksITApOiExfWZ1bmN0aW9uIHkoYyl7Zm9yKHZhciBkPWMubmV4dFNpYmxpbmc7ZCYmZC5ub2RlVHlwZT09Tm9kZS5URVhUX05PREUmJjA9PWQudGV4dENvbnRlbnQubGVuZ3RoOylkPWQubmV4dFNpYmxpbmc7cmV0dXJuIGQ/KGIubm9kZS5pc0Jsb2NrKGQpP3YoZCk6YShkKS5iZWZvcmUoYS5GRS5NQVJLRVJTKSwhMCk6ITF9cmV0dXJue3RleHQ6YyxnZXQ6ZCxyYW5nZXM6ZSxjbGVhcjpmLGVsZW1lbnQ6ZyxlbmRFbGVtZW50Omgsc2F2ZTprLHJlc3RvcmU6bCxpc0NvbGxhcHNlZDpvLGlzRnVsbDpxLGluRWRpdG9yOnQscmVtb3ZlOnUsYmxvY2tzOmosaW5mbzpwLHNldEF0RW5kOncsc2V0QXRTdGFydDp2LHNldEJlZm9yZTp4LHNldEFmdGVyOnkscmFuZ2VFbGVtZW50Oml9fSxhLkZFLk1PRFVMRVMuc3BhY2VzPWZ1bmN0aW9uKGIpe2Z1bmN0aW9uIGMoYSl7dmFyIGI9YS5uZXh0U2libGluZ3x8YS5wYXJlbnROb2RlO3JldHVybiBhLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoYSksYn1mdW5jdGlvbiBkKGEsYil7cmV0dXJuIGEmJmEucGFyZW50Tm9kZT09PWJ8fFxcXCJQUkVcXFwiPT09Yi5ub2RlTmFtZT9iLm5leHRTaWJsaW5nfHxiLnBhcmVudE5vZGU6Yi5maXJzdENoaWxkfHxiLm5leHRTaWJsaW5nfHxiLnBhcmVudE5vZGV9ZnVuY3Rpb24gZShhKXtpZihhLmZpcnN0Q2hpbGQmJlxcXCJQUkVcXFwiIT09YS5ub2RlTmFtZSYmIShbXFxcIlNUWUxFXFxcIixcXFwiU0NSSVBUXFxcIl0uaW5kZXhPZihhLnRhZ05hbWUpPj0wKSl7Zm9yKHZhciBlPW51bGwsZj1udWxsLGc9ZChmLGEpO2chPT1hJiZcXFwiUFJFXFxcIiE9PWcubm9kZU5hbWUmJltcXFwiU1RZTEVcXFwiLFxcXCJTQ1JJUFRcXFwiXS5pbmRleE9mKGcudGFnTmFtZSk8MDspe2lmKGcubm9kZVR5cGU9PT1Ob2RlLlRFWFRfTk9ERSl7dmFyIGg9Zy5kYXRhLnJlcGxhY2UoL1sgXFxcXHJcXFxcblxcXFx0XSsvZyxcXFwiIFxcXCIpO2lmKGUmJiEvICQvLnRlc3QoZS5kYXRhKXx8XFxcIiBcXFwiIT09aFswXXx8Zy5wcmV2aW91c1NpYmxpbmcmJmIubm9kZS5pc1ZvaWQoZy5wcmV2aW91c1NpYmxpbmcpJiZcXFwiQlJcXFwiIT09Zy5wcmV2aW91c1NpYmxpbmcudGFnTmFtZXx8KGg9aC5zdWJzdHIoMSkpLCFofHwwPT1oLmxlbmd0aCl7Zz1jKGcpO2NvbnRpbnVlfWcuZGF0YT1oLGU9Z31lbHNlIGcubm9kZVR5cGU9PT1Ob2RlLkVMRU1FTlRfTk9ERSYmKGIubm9kZS5pc0Jsb2NrKGcpfHxiLm5vZGUuaXNWb2lkKGcpPyhlJiZlLmRhdGEmJihiLm5vZGUuaXNCbG9jayhnKXx8XFxcIkJSXFxcIj09PWcudGFnTmFtZSkmJihlLmRhdGE9ZS5kYXRhLnJlcGxhY2UoLyAkLyxcXFwiXFxcIikpLGU9bnVsbCk6MD09Zy50ZXh0Q29udGVudC5sZW5ndGgmJihlPWcpKTt2YXIgaT1kKGYsZyk7Zj1nLGc9aX1lJiZlLmRhdGEmJihlLmRhdGE9ZS5kYXRhLnJlcGxhY2UoLyAkLyxcXFwiXFxcIiksZS5kYXRhfHxjKGUpKX19ZnVuY3Rpb24gZihjLGQpe2lmKFxcXCJ1bmRlZmluZWRcXFwiIT10eXBlb2YgYyYmY3x8KGM9Yi4kZWwuZ2V0KDApKSxcXFwidW5kZWZpbmVkXFxcIj09dHlwZW9mIGQmJihkPSExKSxkJiZlKGMpLCFjLmdldEF0dHJpYnV0ZXx8XFxcImZhbHNlXFxcIiE9Yy5nZXRBdHRyaWJ1dGUoXFxcImNvbnRlbnRlZGl0YWJsZVxcXCIpKWlmKGMubm9kZVR5cGU9PU5vZGUuRUxFTUVOVF9OT0RFJiZbXFxcIlNUWUxFXFxcIixcXFwiU0NSSVBUXFxcIixcXFwiSEVBRFxcXCJdLmluZGV4T2YoYy50YWdOYW1lKTwwKWZvcih2YXIgZz1iLm5vZGUuY29udGVudHMoYyksaD1nLmxlbmd0aC0xO2g+PTA7aC0tKShnW2hdLnRhZ05hbWUhPU5vZGUuRUxFTUVOVF9OT0RFfHwoZ1toXS5jbGFzc05hbWV8fFxcXCJcXFwiKS5pbmRleE9mKFxcXCJmci1tYXJrZXJcXFwiKTwwKSYmZihnW2hdKTtlbHNlIGlmKGMubm9kZVR5cGU9PU5vZGUuVEVYVF9OT0RFJiZjLnRleHRDb250ZW50Lmxlbmd0aD4wKXt2YXIgaT0oYy5wcmV2aW91c1NpYmxpbmcsYy5uZXh0U2libGluZyxjLnRleHRDb250ZW50KTtpPWkucmVwbGFjZShuZXcgUmVnRXhwKGEuRkUuVU5JQ09ERV9OQlNQLFxcXCJnXFxcIiksXFxcIiBcXFwiKTtmb3IodmFyIGo9XFxcIlxcXCIsaz0wO2s8aS5sZW5ndGg7aysrKWorPTMyIT1pLmNoYXJDb2RlQXQoayl8fDAhPT1rJiYzMiE9ai5jaGFyQ29kZUF0KGstMSk/aVtrXTphLkZFLlVOSUNPREVfTkJTUDsoIWMubmV4dFNpYmxpbmd8fGIubm9kZS5pc0Jsb2NrKGMubmV4dFNpYmxpbmcpfHxjLm5leHRTaWJsaW5nLm5vZGVUeXBlPT1Ob2RlLkVMRU1FTlRfTk9ERSYmYi53aW4uZ2V0Q29tcHV0ZWRTdHlsZShjLm5leHRTaWJsaW5nKSYmXFxcImJsb2NrXFxcIj09Yi53aW4uZ2V0Q29tcHV0ZWRTdHlsZShjLm5leHRTaWJsaW5nKS5kaXNwbGF5KSYmKGo9ai5yZXBsYWNlKC8gJC8sYS5GRS5VTklDT0RFX05CU1ApKSwhYy5wcmV2aW91c1NpYmxpbmd8fGIubm9kZS5pc1ZvaWQoYy5wcmV2aW91c1NpYmxpbmcpfHxiLm5vZGUuaXNCbG9jayhjLnByZXZpb3VzU2libGluZyl8fChqPWoucmVwbGFjZSgvXlxcXFx1MDBBMChbXiAkXSkvLFxcXCIgJDFcXFwiKSwxIT09ai5sZW5ndGh8fDE2MCE9PWouY2hhckNvZGVBdCgwKXx8IWMubmV4dFNpYmxpbmd8fGIubm9kZS5pc1ZvaWQoYy5uZXh0U2libGluZyl8fGIubm9kZS5pc0Jsb2NrKGMubmV4dFNpYmxpbmcpfHwoaj1cXFwiIFxcXCIpKSxqPWoucmVwbGFjZSgvKFteIFxcXFx1MDBBMF0pXFxcXHUwMEEwKFteIFxcXFx1MDBBMF0pL2csXFxcIiQxICQyXFxcIiksYy50ZXh0Q29udGVudCE9aiYmKGMudGV4dENvbnRlbnQ9ail9fXJldHVybntub3JtYWxpemU6Zn19LGEuRkUuVU5JQ09ERV9OQlNQPVN0cmluZy5mcm9tQ2hhckNvZGUoMTYwKSxhLkZFLlZPSURfRUxFTUVOVFM9W1xcXCJhcmVhXFxcIixcXFwiYmFzZVxcXCIsXFxcImJyXFxcIixcXFwiY29sXFxcIixcXFwiZW1iZWRcXFwiLFxcXCJoclxcXCIsXFxcImltZ1xcXCIsXFxcImlucHV0XFxcIixcXFwia2V5Z2VuXFxcIixcXFwibGlua1xcXCIsXFxcIm1lbnVpdGVtXFxcIixcXFwibWV0YVxcXCIsXFxcInBhcmFtXFxcIixcXFwic291cmNlXFxcIixcXFwidHJhY2tcXFwiLFxcXCJ3YnJcXFwiXSxhLkZFLkJMT0NLX1RBR1M9W1xcXCJhZGRyZXNzXFxcIixcXFwiYXJ0aWNsZVxcXCIsXFxcImFzaWRlXFxcIixcXFwiYXVkaW9cXFwiLFxcXCJibG9ja3F1b3RlXFxcIixcXFwiY2FudmFzXFxcIixcXFwiZGRcXFwiLFxcXCJkaXZcXFwiLFxcXCJkbFxcXCIsXFxcImR0XFxcIixcXFwiZmllbGRzZXRcXFwiLFxcXCJmaWdjYXB0aW9uXFxcIixcXFwiZmlndXJlXFxcIixcXFwiZm9vdGVyXFxcIixcXFwiZm9ybVxcXCIsXFxcImgxXFxcIixcXFwiaDJcXFwiLFxcXCJoM1xcXCIsXFxcImg0XFxcIixcXFwiaDVcXFwiLFxcXCJoNlxcXCIsXFxcImhlYWRlclxcXCIsXFxcImhncm91cFxcXCIsXFxcImhyXFxcIixcXFwibGlcXFwiLFxcXCJtYWluXFxcIixcXFwibmF2XFxcIixcXFwibm9zY3JpcHRcXFwiLFxcXCJvbFxcXCIsXFxcIm91dHB1dFxcXCIsXFxcInBcXFwiLFxcXCJwcmVcXFwiLFxcXCJzZWN0aW9uXFxcIixcXFwidGFibGVcXFwiLFxcXCJ0Ym9keVxcXCIsXFxcInRkXFxcIixcXFwidGZvb3RcXFwiLFxcXCJ0aFxcXCIsXFxcInRoZWFkXFxcIixcXFwidHJcXFwiLFxcXCJ1bFxcXCIsXFxcInZpZGVvXFxcIl0sYS5leHRlbmQoYS5GRS5ERUZBVUxUUyx7aHRtbEFsbG93ZWRFbXB0eVRhZ3M6W1xcXCJ0ZXh0YXJlYVxcXCIsXFxcImFcXFwiLFxcXCJpZnJhbWVcXFwiLFxcXCJvYmplY3RcXFwiLFxcXCJ2aWRlb1xcXCIsXFxcInN0eWxlXFxcIixcXFwic2NyaXB0XFxcIixcXFwiLmZhXFxcIixcXFwiLmZyLWVtb3RpY29uXFxcIl0saHRtbERvTm90V3JhcFRhZ3M6W1xcXCJzY3JpcHRcXFwiLFxcXCJzdHlsZVxcXCJdLGh0bWxTaW1wbGVBbXBlcnNhbmQ6ITF9KSxhLkZFLk1PRFVMRVMuaHRtbD1mdW5jdGlvbihiKXtmdW5jdGlvbiBjKCl7cmV0dXJuIGIub3B0cy5lbnRlcj09YS5GRS5FTlRFUl9QP1xcXCJwXFxcIjpiLm9wdHMuZW50ZXI9PWEuRkUuRU5URVJfRElWP1xcXCJkaXZcXFwiOmIub3B0cy5lbnRlcj09YS5GRS5FTlRFUl9CUj9udWxsOnZvaWQgMH1mdW5jdGlvbiBkKCl7Zm9yKHZhciBjPVtdLGQ9Yi4kZWwuZ2V0KDApLnF1ZXJ5U2VsZWN0b3JBbGwoZigpKSxlPTA7ZTxkLmxlbmd0aDtlKyspaWYoIShkW2VdLnF1ZXJ5U2VsZWN0b3JBbGwoYS5GRS5WT0lEX0VMRU1FTlRTLmpvaW4oXFxcIixcXFwiKSkubGVuZ3RoPjB8fGRbZV0ucXVlcnlTZWxlY3RvckFsbChiLm9wdHMuaHRtbEFsbG93ZWRFbXB0eVRhZ3Muam9pbihcXFwiOm5vdCguZnItbWFya2VyKSxcXFwiKStcXFwiOm5vdCguZnItbWFya2VyKVxcXCIpLmxlbmd0aD4wfHxkW2VdLnF1ZXJ5U2VsZWN0b3JBbGwoZigpKS5sZW5ndGg+MCkpe2Zvcih2YXIgZz1iLm5vZGUuY29udGVudHMoZFtlXSksaD0hMSxpPTA7aTxnLmxlbmd0aDtpKyspaWYoZ1tpXS5ub2RlVHlwZSE9Tm9kZS5DT01NRU5UX05PREUmJmdbaV0udGV4dENvbnRlbnQmJmdbaV0udGV4dENvbnRlbnQucmVwbGFjZSgvXFxcXHUyMDBCL2csXFxcIlxcXCIpLnJlcGxhY2UoL1xcXFxuL2csXFxcIlxcXCIpLmxlbmd0aD4wKXtoPSEwO2JyZWFrfWh8fGMucHVzaChkW2VdKX1yZXR1cm4gY31mdW5jdGlvbiBlKCl7cmV0dXJuIGEuRkUuQkxPQ0tfVEFHUy5qb2luKFxcXCI6ZW1wdHksIFxcXCIpK1xcXCI6ZW1wdHlcXFwifWZ1bmN0aW9uIGYoKXtyZXR1cm4gYS5GRS5CTE9DS19UQUdTLmpvaW4oXFxcIiwgXFxcIil9ZnVuY3Rpb24gZyhjKXt2YXIgZD1hLm1lcmdlKFtdLGEuRkUuVk9JRF9FTEVNRU5UUyk7ZD1hLm1lcmdlKGQsYi5vcHRzLmh0bWxBbGxvd2VkRW1wdHlUYWdzKSxcXFwidW5kZWZpbmVkXFxcIj09dHlwZW9mIGMmJihkPWEubWVyZ2UoZCxhLkZFLkJMT0NLX1RBR1MpKTt2YXIgZSxmO2Rve2Y9ITEsZT1iLiRlbC5nZXQoMCkucXVlcnlTZWxlY3RvckFsbChcXFwiKjplbXB0eTpub3QoXFxcIitkLmpvaW4oXFxcIik6bm90KFxcXCIpK1xcXCIpOm5vdCguZnItbWFya2VyKVxcXCIpO2Zvcih2YXIgZz0wO2c8ZS5sZW5ndGg7ZysrKSgwPT09ZVtnXS5hdHRyaWJ1dGVzLmxlbmd0aHx8XFxcInVuZGVmaW5lZFxcXCIhPXR5cGVvZiBlW2ddLmdldEF0dHJpYnV0ZShcXFwiaHJlZlxcXCIpKSYmKGEoZVtnXSkucmVtb3ZlKCksZj0hMCk7ZT1iLiRlbC5nZXQoMCkucXVlcnlTZWxlY3RvckFsbChcXFwiKjplbXB0eTpub3QoXFxcIitkLmpvaW4oXFxcIik6bm90KFxcXCIpK1xcXCIpOm5vdCguZnItbWFya2VyKVxcXCIpfXdoaWxlKGUubGVuZ3RoJiZmKX1mdW5jdGlvbiBoKGQsZSl7dmFyIGY9YygpO2lmKGUmJihmPSdkaXYgY2xhc3M9XFxcImZyLXRlbXAtZGl2XFxcIicpLGYpZm9yKHZhciBnPWIubm9kZS5jb250ZW50cyhkLmdldCgwKSksaD1udWxsLGk9MDtpPGcubGVuZ3RoO2krKyl7dmFyIGo9Z1tpXTtpZihqLm5vZGVUeXBlPT1Ob2RlLkVMRU1FTlRfTk9ERSYmKGIubm9kZS5pc0Jsb2NrKGopfHxhKGopLmlzKGIub3B0cy5odG1sRG9Ob3RXcmFwVGFncy5qb2luKFxcXCIsXFxcIikpJiYhYShqKS5oYXNDbGFzcyhcXFwiZnItbWFya2VyXFxcIikpKWg9bnVsbDtlbHNlIGlmKGoubm9kZVR5cGUhPU5vZGUuRUxFTUVOVF9OT0RFJiZqLm5vZGVUeXBlIT1Ob2RlLlRFWFRfTk9ERSloPW51bGw7ZWxzZSBpZihqLm5vZGVUeXBlPT1Ob2RlLkVMRU1FTlRfTk9ERSYmXFxcIkJSXFxcIj09ai50YWdOYW1lKWlmKG51bGw9PWgpZT9hKGopLnJlcGxhY2VXaXRoKFxcXCI8XFxcIitmKycgZGF0YS1lbXB0eT1cXFwidHJ1ZVxcXCI+PGJyPjwvZGl2PicpOmEoaikucmVwbGFjZVdpdGgoXFxcIjxcXFwiK2YrXFxcIj48YnI+PC9cXFwiK2YrXFxcIj5cXFwiKTtlbHNle2EoaikucmVtb3ZlKCk7Zm9yKHZhciBrPWIubm9kZS5jb250ZW50cyhoKSxsPSExLG09MDttPGsubGVuZ3RoO20rKylpZighYShrW21dKS5oYXNDbGFzcyhcXFwiZnItbWFya2VyXFxcIikmJihrW21dLm5vZGVUeXBlIT1Ob2RlLlRFWFRfTk9ERXx8MCE9PWtbbV0udGV4dENvbnRlbnQucmVwbGFjZSgvIC9nLFxcXCJcXFwiKS5sZW5ndGgpKXtsPSEwO2JyZWFrfWw9PT0hMSYmKGguYXBwZW5kKFxcXCI8YnI+XFxcIiksaC5kYXRhKFxcXCJlbXB0eVxcXCIsITApKSxoPW51bGx9ZWxzZSBqLm5vZGVUeXBlPT1Ob2RlLlRFWFRfTk9ERSYmMD09YShqKS50ZXh0KCkudHJpbSgpLmxlbmd0aD9hKGopLnJlbW92ZSgpOihudWxsPT1oJiYoaD1hKFxcXCI8XFxcIitmK1xcXCI+XFxcIiksYShqKS5iZWZvcmUoaCkpLGoubm9kZVR5cGU9PU5vZGUuVEVYVF9OT0RFJiZhKGopLnRleHQoKS50cmltKCkubGVuZ3RoPjA/KGguYXBwZW5kKGEoaikuY2xvbmUoKSksYShqKS5yZW1vdmUoKSk6aC5hcHBlbmQoYShqKSkpfX1mdW5jdGlvbiBpKGMsZCxlLGYpe3JldHVybiBiLiR3cD8oXFxcInVuZGVmaW5lZFxcXCI9PXR5cGVvZiBjJiYoYz0hMSksXFxcInVuZGVmaW5lZFxcXCI9PXR5cGVvZiBkJiYoZD0hMSksXFxcInVuZGVmaW5lZFxcXCI9PXR5cGVvZiBlJiYoZT0hMSksXFxcInVuZGVmaW5lZFxcXCI9PXR5cGVvZiBmJiYoZj0hMSksaChiLiRlbCxjKSxmJiZiLiRlbC5maW5kKFxcXCIuZnItaW5uZXJcXFwiKS5lYWNoKGZ1bmN0aW9uKCl7aChhKHRoaXMpLGMpfSksZCYmYi4kZWwuZmluZChcXFwidGQsIHRoXFxcIikuZWFjaChmdW5jdGlvbigpe2goYSh0aGlzKSxjKX0pLHZvaWQoZSYmYi4kZWwuZmluZChcXFwiYmxvY2txdW90ZVxcXCIpLmVhY2goZnVuY3Rpb24oKXtoKGEodGhpcyksYyl9KSkpOiExfWZ1bmN0aW9uIGooKXtiLiRlbC5maW5kKFxcXCJkaXYuZnItdGVtcC1kaXZcXFwiKS5lYWNoKGZ1bmN0aW9uKCl7YSh0aGlzKS5kYXRhKFxcXCJlbXB0eVxcXCIpfHxcXFwiTElcXFwiPT10aGlzLnBhcmVudE5vZGUudGFnTmFtZT9hKHRoaXMpLnJlcGxhY2VXaXRoKGEodGhpcykuaHRtbCgpKTphKHRoaXMpLnJlcGxhY2VXaXRoKGEodGhpcykuaHRtbCgpK1xcXCI8YnI+XFxcIil9KSxiLiRlbC5maW5kKFxcXCIuZnItdGVtcC1kaXZcXFwiKS5yZW1vdmVDbGFzcyhcXFwiZnItdGVtcC1kaXZcXFwiKS5maWx0ZXIoZnVuY3Rpb24oKXtyZXR1cm5cXFwiXFxcIj09YSh0aGlzKS5hdHRyKFxcXCJjbGFzc1xcXCIpfSkucmVtb3ZlQXR0cihcXFwiY2xhc3NcXFwiKX1mdW5jdGlvbiBrKCl7Zm9yKHZhciBjPWQoKSxlPTA7ZTxjLmxlbmd0aDtlKyspe3ZhciBmPWNbZV07XFxcImZhbHNlXFxcIj09Zi5nZXRBdHRyaWJ1dGUoXFxcImNvbnRlbnRlZGl0YWJsZVxcXCIpfHwwIT1mLnF1ZXJ5U2VsZWN0b3JBbGwoYi5vcHRzLmh0bWxBbGxvd2VkRW1wdHlUYWdzLmpvaW4oXFxcIjpub3QoLmZyLW1hcmtlciksXFxcIikrXFxcIjpub3QoLmZyLW1hcmtlcilcXFwiKS5sZW5ndGh8fGIubm9kZS5pc1ZvaWQoZil8fFxcXCJUQUJMRVxcXCIhPWYudGFnTmFtZSYmZi5hcHBlbmRDaGlsZChiLmRvYy5jcmVhdGVFbGVtZW50KFxcXCJiclxcXCIpKX1pZihiLmJyb3dzZXIubXNpZSYmYi5vcHRzLmVudGVyPT1hLkZFLkVOVEVSX0JSKXt2YXIgZz1iLm5vZGUuY29udGVudHMoYi4kZWwuZ2V0KDApKTtnLmxlbmd0aCYmZ1tnLmxlbmd0aC0xXS5ub2RlVHlwZT09Tm9kZS5URVhUX05PREUmJmIuJGVsLmFwcGVuZChcXFwiPGJyPlxcXCIpfX1mdW5jdGlvbiBsKCl7cmV0dXJuIGIuJGVsLmZpbmQoZigpKX1mdW5jdGlvbiBtKGEpe2lmKFxcXCJ1bmRlZmluZWRcXFwiPT10eXBlb2YgYSYmKGE9Yi4kZWwuZ2V0KDApKSxhJiZbXFxcIlNDUklQVFxcXCIsXFxcIlNUWUxFXFxcIixcXFwiUFJFXFxcIl0uaW5kZXhPZihhLnRhZ05hbWUpPj0wKXJldHVybiExO2Zvcih2YXIgYz1iLm5vZGUuY29udGVudHMoYSksZD1jLmxlbmd0aC0xO2Q+PTA7ZC0tKWlmKGNbZF0ubm9kZVR5cGU9PU5vZGUuVEVYVF9OT0RFKXtjW2RdLnRleHRDb250ZW50PWNbZF0udGV4dENvbnRlbnQucmVwbGFjZSgvKD8hXikoICl7Mix9KD8hJCkvZyxcXFwiIFxcXCIpLGNbZF0udGV4dENvbnRlbnQ9Y1tkXS50ZXh0Q29udGVudC5yZXBsYWNlKC9cXFxcbi9nLFxcXCIgXFxcIiksY1tkXS50ZXh0Q29udGVudD1jW2RdLnRleHRDb250ZW50LnJlcGxhY2UoL15bIF17Mix9L2csXFxcIiBcXFwiKSxjW2RdLnRleHRDb250ZW50PWNbZF0udGV4dENvbnRlbnQucmVwbGFjZSgvWyBdezIsfSQvZyxcXFwiIFxcXCIpLChiLm5vZGUuaXNCbG9jayhhKXx8Yi5ub2RlLmlzRWxlbWVudChhKSkmJihjW2RdLnByZXZpb3VzU2libGluZ3x8KGNbZF0udGV4dENvbnRlbnQ9Y1tkXS50ZXh0Q29udGVudC5yZXBsYWNlKC9eICovLFxcXCJcXFwiKSksY1tkXS5uZXh0U2libGluZ3x8KGNbZF0udGV4dENvbnRlbnQ9Y1tkXS50ZXh0Q29udGVudC5yZXBsYWNlKC8gKiQvLFxcXCJcXFwiKSksY1tkXS5wcmV2aW91c1NpYmxpbmcmJmNbZF0ubmV4dFNpYmxpbmcmJlxcXCIgXFxcIj09Y1tkXS50ZXh0Q29udGVudCYmKGNbZF0ucHJldmlvdXNTaWJsaW5nJiZjW2RdLm5leHRTaWJsaW5nJiZiLm5vZGUuaXNCbG9jayhjW2RdLnByZXZpb3VzU2libGluZykmJmIubm9kZS5pc0Jsb2NrKGNbZF0ubmV4dFNpYmxpbmcpP2NbZF0udGV4dENvbnRlbnQ9XFxcIlxcXCI6Y1tkXS50ZXh0Q29udGVudD1cXFwiXFxcXG5cXFwiKSl9ZWxzZSBtKGNbZF0pfWZ1bmN0aW9uIG4oYSl7cmV0dXJuIGEmJihiLm5vZGUuaXNCbG9jayhhKXx8W1xcXCJTVFlMRVxcXCIsXFxcIlNDUklQVFxcXCIsXFxcIkhFQURcXFwiLFxcXCJCUlxcXCIsXFxcIkhSXFxcIl0uaW5kZXhPZihhLnRhZ05hbWUpPj0wfHxhLm5vZGVUeXBlPT1Ob2RlLkNPTU1FTlRfTk9ERSl9ZnVuY3Rpb24gbyhjKXtpZihcXFwidW5kZWZpbmVkXFxcIj09dHlwZW9mIGMmJihjPWIuJGVsLmdldCgwKSksYy5ub2RlVHlwZT09Tm9kZS5FTEVNRU5UX05PREUmJltcXFwiU1RZTEVcXFwiLFxcXCJTQ1JJUFRcXFwiLFxcXCJIRUFEXFxcIl0uaW5kZXhPZihjLnRhZ05hbWUpPDApe2Zvcih2YXIgZD1iLm5vZGUuY29udGVudHMoYyksZT1kLmxlbmd0aC0xO2U+PTA7ZS0tKWlmKCFhKGRbZV0pLmhhc0NsYXNzKFxcXCJmci1tYXJrZXJcXFwiKSl7dmFyIGY9byhkW2VdKTtpZigxPT1mKXJldHVybiEwfX1lbHNlIGlmKGMubm9kZVR5cGU9PU5vZGUuVEVYVF9OT0RFJiZjLnRleHRDb250ZW50Lmxlbmd0aD4wKXt2YXIgZz1jLnByZXZpb3VzU2libGluZyxoPWMubmV4dFNpYmxpbmc7aWYobihnKSYmbihoKSYmMD09PWMudGV4dENvbnRlbnQudHJpbSgpLmxlbmd0aClyZXR1cm4hMDt2YXIgaT1jLnRleHRDb250ZW50O2k9aS5yZXBsYWNlKG5ldyBSZWdFeHAoYS5GRS5VTklDT0RFX05CU1AsXFxcImdcXFwiKSxcXFwiIFxcXCIpO2Zvcih2YXIgaj1cXFwiXFxcIixrPTA7azxpLmxlbmd0aDtrKyspais9MzIhPWkuY2hhckNvZGVBdChrKXx8MCE9PWsmJjMyIT1qLmNoYXJDb2RlQXQoay0xKT9pW2tdOmEuRkUuVU5JQ09ERV9OQlNQO2lmKGMubmV4dFNpYmxpbmd8fChqPWoucmVwbGFjZSgvICQvLGEuRkUuVU5JQ09ERV9OQlNQKSksYy5wcmV2aW91c1NpYmxpbmcmJiFiLm5vZGUuaXNWb2lkKGMucHJldmlvdXNTaWJsaW5nKSYmKGo9ai5yZXBsYWNlKC9eXFxcXHUwMEEwKFteICRdKS8sXFxcIiAkMVxcXCIpKSxqPWoucmVwbGFjZSgvKFteIFxcXFx1MDBBMF0pXFxcXHUwMEEwKFteIFxcXFx1MDBBMF0pL2csXFxcIiQxICQyXFxcIiksYy50ZXh0Q29udGVudCE9ailyZXR1cm4hMH1yZXR1cm4hMX1mdW5jdGlvbiBwKGEsYixjKXt2YXIgZD1uZXcgUmVnRXhwKGIsXFxcImdpXFxcIiksZT1kLmV4ZWMoYSk7cmV0dXJuIGU/ZVtjXTpudWxsfWZ1bmN0aW9uIHEoYSxiKXt2YXIgYz1hLm1hdGNoKC88IURPQ1RZUEUgPyhbXiBdKikgPyhbXiBdKikgP1xcXCI/KFteXFxcIl0qKVxcXCI/ID9cXFwiPyhbXlxcXCJdKilcXFwiPz4vaSk7cmV0dXJuIGM/Yi5pbXBsZW1lbnRhdGlvbi5jcmVhdGVEb2N1bWVudFR5cGUoY1sxXSxjWzNdLGNbNF0pOmIuaW1wbGVtZW50YXRpb24uY3JlYXRlRG9jdW1lbnRUeXBlKFxcXCJodG1sXFxcIil9ZnVuY3Rpb24gcihhKXt2YXIgYj1hLmRvY3R5cGUsYz1cXFwiPCFET0NUWVBFIGh0bWw+XFxcIjtyZXR1cm4gYiYmKGM9XFxcIjwhRE9DVFlQRSBcXFwiK2IubmFtZSsoYi5wdWJsaWNJZD8nIFBVQkxJQyBcXFwiJytiLnB1YmxpY0lkKydcXFwiJzpcXFwiXFxcIikrKCFiLnB1YmxpY0lkJiZiLnN5c3RlbUlkP1xcXCIgU1lTVEVNXFxcIjpcXFwiXFxcIikrKGIuc3lzdGVtSWQ/JyBcXFwiJytiLnN5c3RlbUlkKydcXFwiJzpcXFwiXFxcIikrXFxcIj5cXFwiKSxjfWZ1bmN0aW9uIHMoKXtpKCksbSgpLGcoKSxiLnNwYWNlcy5ub3JtYWxpemUobnVsbCwhMCksYi5odG1sLmZpbGxFbXB0eUJsb2NrcygpLGIuY2xlYW4ucXVvdGVzKCksYi5jbGVhbi5saXN0cygpLGIuY2xlYW4udGFibGVzKCksYi5jbGVhbi50b0hUTUw1KCksYi5zZWxlY3Rpb24ucmVzdG9yZSgpLHQoKSxiLnBsYWNlaG9sZGVyLnJlZnJlc2goKX1mdW5jdGlvbiB0KCl7Yi5jb3JlLmlzRW1wdHkoKSYmKG51bGwhPWMoKT8wPT09Yi4kZWwuZ2V0KDApLnF1ZXJ5U2VsZWN0b3JBbGwoZigpKS5sZW5ndGgmJjA9PT1iLiRlbC5nZXQoMCkucXVlcnlTZWxlY3RvckFsbChiLm9wdHMuaHRtbERvTm90V3JhcFRhZ3Muam9pbihcXFwiOm5vdCguZnItbWFya2VyKSxcXFwiKStcXFwiOm5vdCguZnItbWFya2VyKVxcXCIpLmxlbmd0aCYmKGIuY29yZS5oYXNGb2N1cygpPyhiLiRlbC5odG1sKFxcXCI8XFxcIitjKCkrXFxcIj5cXFwiK2EuRkUuTUFSS0VSUytcXFwiPGJyLz48L1xcXCIrYygpK1xcXCI+XFxcIiksYi5zZWxlY3Rpb24ucmVzdG9yZSgpKTpiLiRlbC5odG1sKFxcXCI8XFxcIitjKCkrXFxcIj48YnIvPjwvXFxcIitjKCkrXFxcIj5cXFwiKSk6MD09PWIuJGVsLmdldCgwKS5xdWVyeVNlbGVjdG9yQWxsKFxcXCIqOm5vdCguZnItbWFya2VyKTpub3QoYnIpXFxcIikubGVuZ3RoJiYoYi5jb3JlLmhhc0ZvY3VzKCk/KGIuJGVsLmh0bWwoYS5GRS5NQVJLRVJTK1xcXCI8YnIvPlxcXCIpLGIuc2VsZWN0aW9uLnJlc3RvcmUoKSk6Yi4kZWwuaHRtbChcXFwiPGJyLz5cXFwiKSkpfWZ1bmN0aW9uIHUoYSxiKXtyZXR1cm4gcChhLFxcXCI8XFxcIitiK1xcXCJbXj5dKj8+KFtcXFxcXFxcXHdcXFxcXFxcXFddKik8L1xcXCIrYitcXFwiPlxcXCIsMSl9ZnVuY3Rpb24gdihjLGQpe3ZhciBlPWEoXFxcIjxkaXYgXFxcIisocChjLFxcXCI8XFxcIitkK1xcXCIoW14+XSo/KT5cXFwiLDEpfHxcXFwiXFxcIikrXFxcIj5cXFwiKTtyZXR1cm4gYi5ub2RlLnJhd0F0dHJpYnV0ZXMoZS5nZXQoMCkpfWZ1bmN0aW9uIHcoYSl7cmV0dXJuIHAoYSxcXFwiPCFET0NUWVBFKFtePl0qPyk+XFxcIiwwKXx8XFxcIjwhRE9DVFlQRSBodG1sPlxcXCJ9ZnVuY3Rpb24geChjKXt2YXIgZD1iLmNsZWFuLmh0bWwoY3x8XFxcIlxcXCIsW10sW10sYi5vcHRzLmZ1bGxQYWdlKTtpZihiLm9wdHMuZnVsbFBhZ2Upe3ZhciBlPXUoZCxcXFwiYm9keVxcXCIpfHwoZC5pbmRleE9mKFxcXCI8Ym9keVxcXCIpPj0wP1xcXCJcXFwiOmQpLGY9dihkLFxcXCJib2R5XFxcIiksZz11KGQsXFxcImhlYWRcXFwiKXx8XFxcIjx0aXRsZT48L3RpdGxlPlxcXCIsaD12KGQsXFxcImhlYWRcXFwiKSxpPWEoXFxcIjxkaXY+XFxcIikuYXBwZW5kKGcpLmZpbmQoXFxcImJhc2UsIGxpbmssIG1ldGEsIG5vc2NyaXB0LCBzY3JpcHQsIHN0eWxlLCB0ZW1wbGF0ZSwgdGl0bGVcXFwiKS5yZW1vdmUoKS5lbmQoKS5odG1sKCkudHJpbSgpO2c9YShcXFwiPGRpdj5cXFwiKS5hcHBlbmQoZykuZmluZChcXFwiYmFzZSwgbGluaywgbWV0YSwgbm9zY3JpcHQsIHNjcmlwdCwgc3R5bGUsIHRlbXBsYXRlLCB0aXRsZVxcXCIpLm1hcChmdW5jdGlvbigpe3JldHVybiB0aGlzLm91dGVySFRNTH0pLnRvQXJyYXkoKS5qb2luKFxcXCJcXFwiKTt2YXIgaj13KGQpLGs9dihkLFxcXCJodG1sXFxcIik7Yi4kZWwuaHRtbChpK1xcXCJcXFxcblxcXCIrZSksYi5ub2RlLmNsZWFyQXR0cmlidXRlcyhiLiRlbC5nZXQoMCkpLGIuJGVsLmF0dHIoZiksYi4kZWwuYWRkQ2xhc3MoXFxcImZyLXZpZXdcXFwiKSxiLiRlbC5hdHRyKFxcXCJzcGVsbGNoZWNrXFxcIixiLm9wdHMuc3BlbGxjaGVjayksYi4kZWwuYXR0cihcXFwiZGlyXFxcIixiLm9wdHMuZGlyZWN0aW9uKSxiLiRoZWFkLmh0bWwoZyksYi5ub2RlLmNsZWFyQXR0cmlidXRlcyhiLiRoZWFkLmdldCgwKSksYi4kaGVhZC5hdHRyKGgpLGIubm9kZS5jbGVhckF0dHJpYnV0ZXMoYi4kaHRtbC5nZXQoMCkpLGIuJGh0bWwuYXR0cihrKSxiLmlmcmFtZV9kb2N1bWVudC5kb2N0eXBlLnBhcmVudE5vZGUucmVwbGFjZUNoaWxkKHEoaixiLmlmcmFtZV9kb2N1bWVudCksYi5pZnJhbWVfZG9jdW1lbnQuZG9jdHlwZSl9ZWxzZSBiLiRlbC5odG1sKGQpO3ZhciBsPWIuZWRpdC5pc0Rpc2FibGVkKCk7Yi5lZGl0Lm9uKCksYi5jb3JlLmluamVjdFN0eWxlKGIub3B0cy5pZnJhbWVTdHlsZSkscygpLGIub3B0cy51c2VDbGFzc2VzfHwoYi4kZWwuZmluZChcXFwiW2ZyLW9yaWdpbmFsLWNsYXNzXVxcXCIpLmVhY2goZnVuY3Rpb24oKXt0aGlzLnNldEF0dHJpYnV0ZShcXFwiY2xhc3NcXFwiLHRoaXMuZ2V0QXR0cmlidXRlKFxcXCJmci1vcmlnaW5hbC1jbGFzc1xcXCIpKSx0aGlzLnJlbW92ZUF0dHJpYnV0ZShcXFwiZnItb3JpZ2luYWwtY2xhc3NcXFwiKX0pLGIuJGVsLmZpbmQoXFxcIltmci1vcmlnaW5hbC1zdHlsZV1cXFwiKS5lYWNoKGZ1bmN0aW9uKCl7dGhpcy5zZXRBdHRyaWJ1dGUoXFxcInN0eWxlXFxcIix0aGlzLmdldEF0dHJpYnV0ZShcXFwiZnItb3JpZ2luYWwtc3R5bGVcXFwiKSksdGhpcy5yZW1vdmVBdHRyaWJ1dGUoXFxcImZyLW9yaWdpbmFsLXN0eWxlXFxcIil9KSksbCYmYi5lZGl0Lm9mZigpLGIuZXZlbnRzLnRyaWdnZXIoXFxcImh0bWwuc2V0XFxcIil9ZnVuY3Rpb24geShhLGMpe2lmKCFiLiR3cClyZXR1cm4gYi4kb2VsLmNsb25lKCkucmVtb3ZlQ2xhc3MoXFxcImZyLXZpZXdcXFwiKS5yZW1vdmVBdHRyKFxcXCJjb250ZW50ZWRpdGFibGVcXFwiKS5nZXQoMCkub3V0ZXJIVE1MO3ZhciBkPVxcXCJcXFwiO2IuZXZlbnRzLnRyaWdnZXIoXFxcImh0bWwuYmVmb3JlR2V0XFxcIik7dmFyIGUsZj1mdW5jdGlvbihhKXt2YXIgYj0vKCNbXlxcXFxzXFxcXCs+flxcXFwuXFxcXFs6XSspL2csYz0vKFxcXFxbW15cXFxcXV0rXFxcXF0pL2csZD0vKFxcXFwuW15cXFxcc1xcXFwrPn5cXFxcLlxcXFxbOl0rKS9nLGU9Lyg6OlteXFxcXHNcXFxcKz5+XFxcXC5cXFxcWzpdK3w6Zmlyc3QtbGluZXw6Zmlyc3QtbGV0dGVyfDpiZWZvcmV8OmFmdGVyKS9naSxmPS8oOltcXFxcdy1dK1xcXFwoW15cXFxcKV0qXFxcXCkpL2dpLGc9Lyg6W15cXFxcc1xcXFwrPn5cXFxcLlxcXFxbOl0rKS9nLGg9LyhbXlxcXFxzXFxcXCs+flxcXFwuXFxcXFs6XSspL2c7IWZ1bmN0aW9uKCl7dmFyIGI9Lzpub3RcXFxcKChbXlxcXFwpXSopXFxcXCkvZztiLnRlc3QoYSkmJihhPWEucmVwbGFjZShiLFxcXCIgICAgICQxIFxcXCIpKX0oKTt2YXIgaT0xMDAqKGEubWF0Y2goYil8fFtdKS5sZW5ndGgrMTAqKGEubWF0Y2goYyl8fFtdKS5sZW5ndGgrMTAqKGEubWF0Y2goZCl8fFtdKS5sZW5ndGgrMTAqKGEubWF0Y2goZil8fFtdKS5sZW5ndGgrMTAqKGEubWF0Y2goZyl8fFtdKS5sZW5ndGgrKGEubWF0Y2goZSl8fFtdKS5sZW5ndGg7cmV0dXJuIGE9YS5yZXBsYWNlKC9bXFxcXCpcXFxcc1xcXFwrPn5dL2csXFxcIiBcXFwiKSxhPWEucmVwbGFjZSgvWyNcXFxcLl0vZyxcXFwiIFxcXCIpLGkrPShhLm1hdGNoKGgpfHxbXSkubGVuZ3RofSxnPVtdLGg9e307aWYoIWIub3B0cy51c2VDbGFzc2VzJiYhYyl7Zm9yKGU9MDtlPGIuZG9jLnN0eWxlU2hlZXRzLmxlbmd0aDtlKyspe3ZhciBpLGo9MDt0cnl7aT1iLmRvYy5zdHlsZVNoZWV0c1tlXS5jc3NSdWxlcyxiLmRvYy5zdHlsZVNoZWV0c1tlXS5vd25lck5vZGUmJlxcXCJTVFlMRVxcXCI9PWIuZG9jLnN0eWxlU2hlZXRzW2VdLm93bmVyTm9kZS5ub2RlVHlwZSYmKGo9MSl9Y2F0Y2goayl7fWlmKGkpZm9yKHZhciBsPTAsbT1pLmxlbmd0aDttPmw7bCsrKWlmKGlbbF0uc2VsZWN0b3JUZXh0JiZpW2xdLnN0eWxlLmNzc1RleHQubGVuZ3RoPjApe3ZhciBuLG89aVtsXS5zZWxlY3RvclRleHQucmVwbGFjZSgvYm9keSB8XFxcXC5mci12aWV3IC9nLFxcXCJcXFwiKS5yZXBsYWNlKC86Oi9nLFxcXCI6XFxcIik7dHJ5e249Yi4kZWwuZ2V0KDApLnF1ZXJ5U2VsZWN0b3JBbGwobyl9Y2F0Y2goayl7bj1bXX1mb3IodmFyIHA9MDtwPG4ubGVuZ3RoO3ArKyl7IW5bcF0uZ2V0QXR0cmlidXRlKFxcXCJmci1vcmlnaW5hbC1zdHlsZVxcXCIpJiZuW3BdLmdldEF0dHJpYnV0ZShcXFwic3R5bGVcXFwiKT8obltwXS5zZXRBdHRyaWJ1dGUoXFxcImZyLW9yaWdpbmFsLXN0eWxlXFxcIixuW3BdLmdldEF0dHJpYnV0ZShcXFwic3R5bGVcXFwiKSksZy5wdXNoKG5bcF0pKTpuW3BdLmdldEF0dHJpYnV0ZShcXFwiZnItb3JpZ2luYWwtc3R5bGVcXFwiKXx8Zy5wdXNoKG5bcF0pLGhbbltwXV18fChoW25bcF1dPXt9KTtmb3IodmFyIHE9MWUzKmorZihpW2xdLnNlbGVjdG9yVGV4dCkscz1pW2xdLnN0eWxlLmNzc1RleHQuc3BsaXQoXFxcIjtcXFwiKSx0PTA7dDxzLmxlbmd0aDt0Kyspe3ZhciB1PXNbdF0udHJpbSgpLnNwbGl0KFxcXCI6XFxcIilbMF07aFtuW3BdXVt1XXx8KGhbbltwXV1bdV09MCwobltwXS5nZXRBdHRyaWJ1dGUoXFxcImZyLW9yaWdpbmFsLXN0eWxlXFxcIil8fFxcXCJcXFwiKS5pbmRleE9mKHUrXFxcIjpcXFwiKT49MCYmKGhbbltwXV1bdV09MWU0KSkscT49aFtuW3BdXVt1XSYmKGhbbltwXV1bdV09cSxzW3RdLnRyaW0oKS5sZW5ndGgmJihuW3BdLnN0eWxlW3UudHJpbSgpXT1zW3RdLnRyaW0oKS5zcGxpdChcXFwiOlxcXCIpWzFdLnRyaW0oKSkpfX19fWZvcihlPTA7ZTxnLmxlbmd0aDtlKyspaWYoZ1tlXS5nZXRBdHRyaWJ1dGUoXFxcImNsYXNzXFxcIikmJihnW2VdLnNldEF0dHJpYnV0ZShcXFwiZnItb3JpZ2luYWwtY2xhc3NcXFwiLGdbZV0uZ2V0QXR0cmlidXRlKFxcXCJjbGFzc1xcXCIpKSxnW2VdLnJlbW92ZUF0dHJpYnV0ZShcXFwiY2xhc3NcXFwiKSksKGdbZV0uZ2V0QXR0cmlidXRlKFxcXCJmci1vcmlnaW5hbC1zdHlsZVxcXCIpfHxcXFwiXFxcIikudHJpbSgpLmxlbmd0aD4wKWZvcih2YXIgdj1nW2VdLmdldEF0dHJpYnV0ZShcXFwiZnItb3JpZ2luYWwtc3R5bGVcXFwiKS5zcGxpdChcXFwiO1xcXCIpLHA9MDtwPHYubGVuZ3RoO3ArKyl2W3BdLmluZGV4T2YoXFxcIjpcXFwiKT4wJiYoZ1tlXS5zdHlsZVt2W3BdLnNwbGl0KFxcXCI6XFxcIilbMF0udHJpbSgpXT12W3BdLnNwbGl0KFxcXCI6XFxcIilbMV0udHJpbSgpKX1pZihiLmNvcmUuaXNFbXB0eSgpP2Iub3B0cy5mdWxsUGFnZSYmKGQ9cihiLmlmcmFtZV9kb2N1bWVudCksZCs9XFxcIjxodG1sXFxcIitiLm5vZGUuYXR0cmlidXRlcyhiLiRodG1sLmdldCgwKSkrXFxcIj5cXFwiK2IuJGh0bWwuZmluZChcXFwiaGVhZFxcXCIpLmdldCgwKS5vdXRlckhUTUwrXFxcIjxib2R5PjwvYm9keT48L2h0bWw+XFxcIik6KFxcXCJ1bmRlZmluZWRcXFwiPT10eXBlb2YgYSYmKGE9ITEpLGIub3B0cy5mdWxsUGFnZT8oZD1yKGIuaWZyYW1lX2RvY3VtZW50KSxiLiRlbC5yZW1vdmVDbGFzcyhcXFwiZnItdmlld1xcXCIpLGQrPVxcXCI8aHRtbFxcXCIrYi5ub2RlLmF0dHJpYnV0ZXMoYi4kaHRtbC5nZXQoMCkpK1xcXCI+XFxcIitiLiRodG1sLmh0bWwoKStcXFwiPC9odG1sPlxcXCIsYi4kZWwuYWRkQ2xhc3MoXFxcImZyLXZpZXdcXFwiKSk6ZD1iLiRlbC5odG1sKCkpLCFiLm9wdHMudXNlQ2xhc3NlcyYmIWMpZm9yKGU9MDtlPGcubGVuZ3RoO2UrKylnW2VdLmdldEF0dHJpYnV0ZShcXFwiZnItb3JpZ2luYWwtY2xhc3NcXFwiKSYmKGdbZV0uc2V0QXR0cmlidXRlKFxcXCJjbGFzc1xcXCIsZ1tlXS5nZXRBdHRyaWJ1dGUoXFxcImZyLW9yaWdpbmFsLWNsYXNzXFxcIikpLGdbZV0ucmVtb3ZlQXR0cmlidXRlKFxcXCJmci1vcmlnaW5hbC1jbGFzc1xcXCIpKSxnW2VdLmdldEF0dHJpYnV0ZShcXFwiZnItb3JpZ2luYWwtc3R5bGVcXFwiKT8oZ1tlXS5zZXRBdHRyaWJ1dGUoXFxcInN0eWxlXFxcIixnW2VdLmdldEF0dHJpYnV0ZShcXFwiZnItb3JpZ2luYWwtc3R5bGVcXFwiKSksZ1tlXS5yZW1vdmVBdHRyaWJ1dGUoXFxcImZyLW9yaWdpbmFsLXN0eWxlXFxcIikpOmdbZV0ucmVtb3ZlQXR0cmlidXRlKFxcXCJzdHlsZVxcXCIpO2Iub3B0cy5mdWxsUGFnZSYmKGQ9ZC5yZXBsYWNlKC88c3R5bGUgZGF0YS1mci1zdHlsZT1cXFwidHJ1ZVxcXCI+KD86W1xcXFx3XFxcXFddKj8pPFxcXFwvc3R5bGU+L2csXFxcIlxcXCIpLGQ9ZC5yZXBsYWNlKC88bGluayg/OltcXFxcd1xcXFxXXSo/KWRhdGEtZnItc3R5bGU9XFxcInRydWVcXFwiKD86W1xcXFx3XFxcXFddKj8pPi9nLFxcXCJcXFwiKSxkPWQucmVwbGFjZSgvPHN0eWxlKD86W1xcXFx3XFxcXFddKj8pY2xhc3M9XFxcImZpcmVidWdSZXNldFN0eWxlc1xcXCIoPzpbXFxcXHdcXFxcV10qPyk+KD86W1xcXFx3XFxcXFddKj8pPFxcXFwvc3R5bGU+L2csXFxcIlxcXCIpLGQ9ZC5yZXBsYWNlKC88Ym9keSgoPzpbXFxcXHdcXFxcV10qPykpIHNwZWxsY2hlY2s9XFxcInRydWVcXFwiKCg/OltcXFxcd1xcXFxXXSo/KSk+KCg/OltcXFxcd1xcXFxXXSo/KSk8XFxcXC9ib2R5Pi9nLFxcXCI8Ym9keSQxJDI+JDM8L2JvZHk+XFxcIiksZD1kLnJlcGxhY2UoLzxib2R5KCg/OltcXFxcd1xcXFxXXSo/KSkgY29udGVudGVkaXRhYmxlPVxcXCIodHJ1ZXxmYWxzZSlcXFwiKCg/OltcXFxcd1xcXFxXXSo/KSk+KCg/OltcXFxcd1xcXFxXXSo/KSk8XFxcXC9ib2R5Pi9nLFxcXCI8Ym9keSQxJDM+JDQ8L2JvZHk+XFxcIiksZD1kLnJlcGxhY2UoLzxib2R5KCg/OltcXFxcd1xcXFxXXSo/KSkgZGlyPVxcXCIoW1xcXFx3XSopXFxcIigoPzpbXFxcXHdcXFxcV10qPykpPigoPzpbXFxcXHdcXFxcV10qPykpPFxcXFwvYm9keT4vZyxcXFwiPGJvZHkkMSQzPiQ0PC9ib2R5PlxcXCIpLGQ9ZC5yZXBsYWNlKC88Ym9keSgoPzpbXFxcXHdcXFxcV10qPykpY2xhc3M9XFxcIihbXFxcXHdcXFxcV10qPykoZnItcnRsfGZyLWx0cikoW1xcXFx3XFxcXFddKj8pXFxcIigoPzpbXFxcXHdcXFxcV10qPykpPigoPzpbXFxcXHdcXFxcV10qPykpPFxcXFwvYm9keT4vZywnPGJvZHkkMWNsYXNzPVxcXCIkMiQ0XFxcIiQ1PiQ2PC9ib2R5PicpLGQ9ZC5yZXBsYWNlKC88Ym9keSgoPzpbXFxcXHdcXFxcV10qPykpIGNsYXNzPVxcXCJcXFwiKCg/OltcXFxcd1xcXFxXXSo/KSk+KCg/OltcXFxcd1xcXFxXXSo/KSk8XFxcXC9ib2R5Pi9nLFxcXCI8Ym9keSQxJDI+JDM8L2JvZHk+XFxcIikpLGIub3B0cy5odG1sU2ltcGxlQW1wZXJzYW5kJiYoZD1kLnJlcGxhY2UoL1xcXFwmYW1wOy9naSxcXFwiJlxcXCIpKSxiLmV2ZW50cy50cmlnZ2VyKFxcXCJodG1sLmFmdGVyR2V0XFxcIiksYXx8KGQ9ZC5yZXBsYWNlKC88c3BhbltePl0qPyBjbGFzc1xcXFxzKj1cXFxccypbXFxcIiddP2ZyLW1hcmtlcltcXFwiJ10/W14+XSs+XFxcXHUyMDBiPFxcXFwvc3Bhbj4vZ2ksXFxcIlxcXCIpKSxkPWIuY2xlYW4uaW52aXNpYmxlU3BhY2VzKGQpO3ZhciB3PWIuZXZlbnRzLmNoYWluVHJpZ2dlcihcXFwiaHRtbC5nZXRcXFwiLGQpO3JldHVyblxcXCJzdHJpbmdcXFwiPT10eXBlb2YgdyYmKGQ9dyksZD1kLnJlcGxhY2UoLzxwcmUoPzpbXFxcXHdcXFxcV10qPyk+KD86W1xcXFx3XFxcXFddKj8pPFxcXFwvcHJlPi9nLGZ1bmN0aW9uKGEpe3JldHVybiBhLnJlcGxhY2UoLzxicj4vZyxcXFwiXFxcXG5cXFwiKX0pfWZ1bmN0aW9uIHooKXt2YXIgYz1mdW5jdGlvbihjLGQpe2Zvcig7ZCYmKGQubm9kZVR5cGU9PU5vZGUuVEVYVF9OT0RFfHwhYi5ub2RlLmlzQmxvY2soZCkpJiYhYi5ub2RlLmlzRWxlbWVudChkKTspZCYmZC5ub2RlVHlwZSE9Tm9kZS5URVhUX05PREUmJmEoYykud3JhcElubmVyKGIubm9kZS5vcGVuVGFnU3RyaW5nKGQpK2Iubm9kZS5jbG9zZVRhZ1N0cmluZyhkKSksZD1kLnBhcmVudE5vZGU7ZCYmYy5pbm5lckhUTUw9PWQuaW5uZXJIVE1MJiYoYy5pbm5lckhUTUw9ZC5vdXRlckhUTUwpfSxkPWZ1bmN0aW9uKCl7dmFyIGMsZD1udWxsO3JldHVybiBiLndpbi5nZXRTZWxlY3Rpb24/KGM9Yi53aW4uZ2V0U2VsZWN0aW9uKCksYyYmYy5yYW5nZUNvdW50JiYoZD1jLmdldFJhbmdlQXQoMCkuY29tbW9uQW5jZXN0b3JDb250YWluZXIsZC5ub2RlVHlwZSE9Tm9kZS5FTEVNRU5UX05PREUmJihkPWQucGFyZW50Tm9kZSkpKTooYz1iLmRvYy5zZWxlY3Rpb24pJiZcXFwiQ29udHJvbFxcXCIhPWMudHlwZSYmKGQ9Yy5jcmVhdGVSYW5nZSgpLnBhcmVudEVsZW1lbnQoKSksbnVsbCE9ZCYmKGEuaW5BcnJheShiLiRlbC5nZXQoMCksYShkKS5wYXJlbnRzKCkpPj0wfHxkPT1iLiRlbC5nZXQoMCkpP2Q6bnVsbH0sZT1cXFwiXFxcIjtpZihcXFwidW5kZWZpbmVkXFxcIiE9dHlwZW9mIGIud2luLmdldFNlbGVjdGlvbil7Yi5icm93c2VyLm1vemlsbGEmJihiLnNlbGVjdGlvbi5zYXZlKCksYi4kZWwuZmluZCgnLmZyLW1hcmtlcltkYXRhLXR5cGU9XFxcImZhbHNlXFxcIl0nKS5sZW5ndGg+MSYmKGIuJGVsLmZpbmQoJy5mci1tYXJrZXJbZGF0YS10eXBlPVxcXCJmYWxzZVxcXCJdW2RhdGEtaWQ9XFxcIjBcXFwiXScpLnJlbW92ZSgpLGIuJGVsLmZpbmQoJy5mci1tYXJrZXJbZGF0YS10eXBlPVxcXCJmYWxzZVxcXCJdOmxhc3QnKS5hdHRyKFxcXCJkYXRhLWlkXFxcIixcXFwiMFxcXCIpLGIuJGVsLmZpbmQoXFxcIi5mci1tYXJrZXJcXFwiKS5ub3QoJ1tkYXRhLWlkPVxcXCIwXFxcIl0nKS5yZW1vdmUoKSksYi5zZWxlY3Rpb24ucmVzdG9yZSgpKTtmb3IodmFyIGY9Yi5zZWxlY3Rpb24ucmFuZ2VzKCksZz0wO2c8Zi5sZW5ndGg7ZysrKXt2YXIgaD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFxcXCJkaXZcXFwiKTtoLmFwcGVuZENoaWxkKGZbZ10uY2xvbmVDb250ZW50cygpKSxjKGgsZCgpKSxhKGgpLmZpbmQoXFxcIi5mci1lbGVtZW50XFxcIikubGVuZ3RoPjAmJihoPWIuJGVsLmdldCgwKSksZSs9aC5pbm5lckhUTUx9fWVsc2VcXFwidW5kZWZpbmVkXFxcIiE9dHlwZW9mIGIuZG9jLnNlbGVjdGlvbiYmXFxcIlRleHRcXFwiPT1iLmRvYy5zZWxlY3Rpb24udHlwZSYmKGU9Yi5kb2Muc2VsZWN0aW9uLmNyZWF0ZVJhbmdlKCkuaHRtbFRleHQpO3JldHVybiBlfWZ1bmN0aW9uIEEoYil7dmFyIGM9YShcXFwiPGRpdj5cXFwiKS5odG1sKGIpO3JldHVybiBjLmZpbmQoZigpKS5sZW5ndGg+MH1mdW5jdGlvbiBCKGEpe3ZhciBjPWIuZG9jLmNyZWF0ZUVsZW1lbnQoXFxcImRpdlxcXCIpO3JldHVybiBjLmlubmVySFRNTD1hLGIuc2VsZWN0aW9uLnNldEF0RW5kKGMpLGMuaW5uZXJIVE1MfWZ1bmN0aW9uIEMoYSl7cmV0dXJuIGEucmVwbGFjZSgvPC9naSxcXFwiJmx0O1xcXCIpLnJlcGxhY2UoLz4vZ2ksXFxcIiZndDtcXFwiKS5yZXBsYWNlKC9cXFwiL2dpLFxcXCImcXVvdDtcXFwiKS5yZXBsYWNlKC8nL2dpLFxcXCImYXBvcztcXFwiKX1mdW5jdGlvbiBEKGMsZCxlKXtiLnNlbGVjdGlvbi5pc0NvbGxhcHNlZCgpfHxiLnNlbGVjdGlvbi5yZW1vdmUoKTt2YXIgZjtpZihmPWQ/YzpiLmNsZWFuLmh0bWwoYyksZj1mLnJlcGxhY2UoL1xcXFxyfFxcXFxuL2csXFxcIiBcXFwiKSxjLmluZGV4T2YoJ2NsYXNzPVxcXCJmci1tYXJrZXJcXFwiJyk8MCYmKGY9QihmKSksYi5jb3JlLmlzRW1wdHkoKSliLiRlbC5odG1sKGYpO2Vsc2V7dmFyIGc9Yi5tYXJrZXJzLmluc2VydCgpO2lmKGcpe3ZhciBoO2lmKChBKGYpfHxlKSYmKGg9Yi5ub2RlLmRlZXBlc3RQYXJlbnQoZykpKXt2YXIgZz1iLm1hcmtlcnMuc3BsaXQoKTtpZighZylyZXR1cm4hMTthKGcpLnJlcGxhY2VXaXRoKGYpfWVsc2UgYShnKS5yZXBsYWNlV2l0aChmKX1lbHNlIGIuJGVsLmFwcGVuZChmKX1zKCksYi5ldmVudHMudHJpZ2dlcihcXFwiaHRtbC5pbnNlcnRlZFxcXCIpfWZ1bmN0aW9uIEUoYyl7dmFyIGQ9bnVsbDtcXFwidW5kZWZpbmVkXFxcIj09dHlwZW9mIGMmJihkPWIuc2VsZWN0aW9uLmVsZW1lbnQoKSk7dmFyIGUsZjtkb3tmPSExLGU9Yi4kZWwuZ2V0KDApLnF1ZXJ5U2VsZWN0b3JBbGwoXFxcIio6bm90KC5mci1tYXJrZXIpXFxcIik7Zm9yKHZhciBnPTA7ZzxlLmxlbmd0aDtnKyspe3ZhciBoPWVbZ107aWYoZCE9aCl7dmFyIGk9aC50ZXh0Q29udGVudDswPT09aC5jaGlsZHJlbi5sZW5ndGgmJjE9PT1pLmxlbmd0aCYmODIwMz09aS5jaGFyQ29kZUF0KDApJiYoYShoKS5yZW1vdmUoKSxmPSEwKX19fXdoaWxlKGYpfWZ1bmN0aW9uIEYoKXt2YXIgYT1mdW5jdGlvbigpe1xcbkUoKSxiLnBsYWNlaG9sZGVyJiZiLnBsYWNlaG9sZGVyLnJlZnJlc2goKX07Yi5ldmVudHMub24oXFxcIm1vdXNldXBcXFwiLGEpLGIuZXZlbnRzLm9uKFxcXCJrZXlkb3duXFxcIixhKSxiLmV2ZW50cy5vbihcXFwiY29udGVudENoYW5nZWRcXFwiLHQpfXJldHVybntkZWZhdWx0VGFnOmMsZW1wdHlCbG9ja3M6ZCxlbXB0eUJsb2NrVGFnc1F1ZXJ5OmUsYmxvY2tUYWdzUXVlcnk6ZixmaWxsRW1wdHlCbG9ja3M6ayxjbGVhbkVtcHR5VGFnczpnLGNsZWFuV2hpdGVUYWdzOkUsZG9Ob3JtYWxpemU6byxjbGVhbkJsYW5rU3BhY2VzOm0sYmxvY2tzOmwsZ2V0RG9jdHlwZTpyLHNldDp4LGdldDp5LGdldFNlbGVjdGVkOnosaW5zZXJ0OkQsd3JhcDppLHVud3JhcDpqLGVzY2FwZUVudGl0aWVzOkMsY2hlY2tJZkVtcHR5OnQsZXh0cmFjdE5vZGU6dSxleHRyYWN0Tm9kZUF0dHJzOnYsZXh0cmFjdERvY3R5cGU6dyxfaW5pdDpGfX0sYS5leHRlbmQoYS5GRS5ERUZBVUxUUyx7aGVpZ2h0Om51bGwsaGVpZ2h0TWF4Om51bGwsaGVpZ2h0TWluOm51bGwsd2lkdGg6bnVsbH0pLGEuRkUuTU9EVUxFUy5zaXplPWZ1bmN0aW9uKGEpe2Z1bmN0aW9uIGIoKXtjKCksYS5vcHRzLmhlaWdodCYmYS4kZWwuY3NzKFxcXCJtaW5IZWlnaHRcXFwiLGEub3B0cy5oZWlnaHQtYS5oZWxwZXJzLmdldFBYKGEuJGVsLmNzcyhcXFwicGFkZGluZy10b3BcXFwiKSktYS5oZWxwZXJzLmdldFBYKGEuJGVsLmNzcyhcXFwicGFkZGluZy1ib3R0b21cXFwiKSkpLGEuJGlmcmFtZS5oZWlnaHQoYS4kZWwub3V0ZXJIZWlnaHQoITApKX1mdW5jdGlvbiBjKCl7YS5vcHRzLmhlaWdodE1pbj9hLiRlbC5jc3MoXFxcIm1pbkhlaWdodFxcXCIsYS5vcHRzLmhlaWdodE1pbik6YS4kZWwuY3NzKFxcXCJtaW5IZWlnaHRcXFwiLFxcXCJcXFwiKSxhLm9wdHMuaGVpZ2h0TWF4PyhhLiR3cC5jc3MoXFxcIm1heEhlaWdodFxcXCIsYS5vcHRzLmhlaWdodE1heCksYS4kd3AuY3NzKFxcXCJvdmVyZmxvd1xcXCIsXFxcImF1dG9cXFwiKSk6KGEuJHdwLmNzcyhcXFwibWF4SGVpZ2h0XFxcIixcXFwiXFxcIiksYS4kd3AuY3NzKFxcXCJvdmVyZmxvd1xcXCIsXFxcIlxcXCIpKSxhLm9wdHMuaGVpZ2h0PyhhLiR3cC5oZWlnaHQoYS5vcHRzLmhlaWdodCksYS4kZWwuY3NzKFxcXCJtaW5IZWlnaHRcXFwiLGEub3B0cy5oZWlnaHQtYS5oZWxwZXJzLmdldFBYKGEuJGVsLmNzcyhcXFwicGFkZGluZy10b3BcXFwiKSktYS5oZWxwZXJzLmdldFBYKGEuJGVsLmNzcyhcXFwicGFkZGluZy1ib3R0b21cXFwiKSkpLGEuJHdwLmNzcyhcXFwib3ZlcmZsb3dcXFwiLFxcXCJhdXRvXFxcIikpOihhLiR3cC5jc3MoXFxcImhlaWdodFxcXCIsXFxcIlxcXCIpLGEub3B0cy5oZWlnaHRNaW58fGEuJGVsLmNzcyhcXFwibWluSGVpZ2h0XFxcIixcXFwiXFxcIiksYS5vcHRzLmhlaWdodE1heHx8YS4kd3AuY3NzKFxcXCJvdmVyZmxvd1xcXCIsXFxcIlxcXCIpKSxhLm9wdHMud2lkdGgmJmEuJGJveC53aWR0aChhLm9wdHMud2lkdGgpfWZ1bmN0aW9uIGQoKXtyZXR1cm4gYS4kd3A/KGMoKSx2b2lkKGEuJGlmcmFtZSYmKGEuZXZlbnRzLm9uKFxcXCJrZXl1cFxcXCIsYiksYS5ldmVudHMub24oXFxcImNvbW1hbmRzLmFmdGVyXFxcIixiKSxhLmV2ZW50cy5vbihcXFwiaHRtbC5zZXRcXFwiLGIpLGEuZXZlbnRzLm9uKFxcXCJpbml0XFxcIixiKSxhLmV2ZW50cy5vbihcXFwiaW5pdGlhbGl6ZWRcXFwiLGIpKSkpOiExfXJldHVybntfaW5pdDpkLHN5bmNJZnJhbWU6YixyZWZyZXNoOmN9fSxhLmV4dGVuZChhLkZFLkRFRkFVTFRTLHtsYW5ndWFnZTpudWxsfSksYS5GRS5MQU5HVUFHRT17fSxhLkZFLk1PRFVMRVMubGFuZ3VhZ2U9ZnVuY3Rpb24oYil7ZnVuY3Rpb24gYyhhKXtyZXR1cm4gZSYmZS50cmFuc2xhdGlvblthXT9lLnRyYW5zbGF0aW9uW2FdOmF9ZnVuY3Rpb24gZCgpe2EuRkUuTEFOR1VBR0UmJihlPWEuRkUuTEFOR1VBR0VbYi5vcHRzLmxhbmd1YWdlXSksZSYmZS5kaXJlY3Rpb24mJihiLm9wdHMuZGlyZWN0aW9uPWUuZGlyZWN0aW9uKX12YXIgZTtyZXR1cm57X2luaXQ6ZCx0cmFuc2xhdGU6Y319LGEuZXh0ZW5kKGEuRkUuREVGQVVMVFMse3BsYWNlaG9sZGVyVGV4dDpcXFwiVHlwZSBzb21ldGhpbmdcXFwifSksYS5GRS5NT0RVTEVTLnBsYWNlaG9sZGVyPWZ1bmN0aW9uKGIpe2Z1bmN0aW9uIGMoKXtiLiRwbGFjZWhvbGRlcnx8ZygpO3ZhciBjPTAsZD0wLGU9MCxmPTAsaD1iLm5vZGUuY29udGVudHMoYi4kZWwuZ2V0KDApKTtpZihoLmxlbmd0aCYmaFswXS5ub2RlVHlwZT09Tm9kZS5FTEVNRU5UX05PREUpe3ZhciBpPWEoaFswXSk7Yi5vcHRzLnRvb2xiYXJJbmxpbmV8fChjPWIuaGVscGVycy5nZXRQWChpLmNzcyhcXFwibWFyZ2luLXRvcFxcXCIpKSxlPWIuaGVscGVycy5nZXRQWChpLmNzcyhcXFwicGFkZGluZy10b3BcXFwiKSksZD1iLmhlbHBlcnMuZ2V0UFgoaS5jc3MoXFxcIm1hcmdpbi1sZWZ0XFxcIikpLGY9Yi5oZWxwZXJzLmdldFBYKGkuY3NzKFxcXCJwYWRkaW5nLWxlZnRcXFwiKSkpLGIuJHBsYWNlaG9sZGVyLmNzcyhcXFwiZm9udC1zaXplXFxcIixpLmNzcyhcXFwiZm9udC1zaXplXFxcIikpLGIuJHBsYWNlaG9sZGVyLmNzcyhcXFwibGluZS1oZWlnaHRcXFwiLGkuY3NzKFxcXCJsaW5lLWhlaWdodFxcXCIpKX1lbHNlIGIuJHBsYWNlaG9sZGVyLmNzcyhcXFwiZm9udC1zaXplXFxcIixiLiRlbC5jc3MoXFxcImZvbnQtc2l6ZVxcXCIpKSxiLiRwbGFjZWhvbGRlci5jc3MoXFxcImxpbmUtaGVpZ2h0XFxcIixiLiRlbC5jc3MoXFxcImxpbmUtaGVpZ2h0XFxcIikpO2IuJHdwLmFkZENsYXNzKFxcXCJzaG93LXBsYWNlaG9sZGVyXFxcIiksYi4kcGxhY2Vob2xkZXIuY3NzKHttYXJnaW5Ub3A6TWF0aC5tYXgoYi5oZWxwZXJzLmdldFBYKGIuJGVsLmNzcyhcXFwibWFyZ2luLXRvcFxcXCIpKSxjKSxwYWRkaW5nVG9wOk1hdGgubWF4KGIuaGVscGVycy5nZXRQWChiLiRlbC5jc3MoXFxcInBhZGRpbmctdG9wXFxcIikpLGUpLHBhZGRpbmdMZWZ0Ok1hdGgubWF4KGIuaGVscGVycy5nZXRQWChiLiRlbC5jc3MoXFxcInBhZGRpbmctbGVmdFxcXCIpKSxmKSxtYXJnaW5MZWZ0Ok1hdGgubWF4KGIuaGVscGVycy5nZXRQWChiLiRlbC5jc3MoXFxcIm1hcmdpbi1sZWZ0XFxcIikpLGQpfSkudGV4dChiLmxhbmd1YWdlLnRyYW5zbGF0ZShiLm9wdHMucGxhY2Vob2xkZXJUZXh0fHxiLiRvZWwuYXR0cihcXFwicGxhY2Vob2xkZXJcXFwiKXx8XFxcIlxcXCIpKSxiLiRwbGFjZWhvbGRlci5odG1sKGIuJHBsYWNlaG9sZGVyLnRleHQoKS5yZXBsYWNlKC9cXFxcbi9nLFxcXCI8YnI+XFxcIikpfWZ1bmN0aW9uIGQoKXtiLiR3cC5yZW1vdmVDbGFzcyhcXFwic2hvdy1wbGFjZWhvbGRlclxcXCIpfWZ1bmN0aW9uIGUoKXtyZXR1cm4gYi4kd3A/Yi4kd3AuaGFzQ2xhc3MoXFxcInNob3ctcGxhY2Vob2xkZXJcXFwiKTohMH1mdW5jdGlvbiBmKCl7cmV0dXJuIGIuJHdwP3ZvaWQoYi5jb3JlLmlzRW1wdHkoKT9jKCk6ZCgpKTohMX1mdW5jdGlvbiBnKCl7Yi4kcGxhY2Vob2xkZXI9YSgnPHNwYW4gY2xhc3M9XFxcImZyLXBsYWNlaG9sZGVyXFxcIj48L3NwYW4+JyksYi4kd3AuYXBwZW5kKGIuJHBsYWNlaG9sZGVyKX1mdW5jdGlvbiBoKCl7cmV0dXJuIGIuJHdwP3ZvaWQgYi5ldmVudHMub24oXFxcImluaXQgaW5wdXQga2V5ZG93biBrZXl1cCBjb250ZW50Q2hhbmdlZCBpbml0aWFsaXplZFxcXCIsZik6ITF9cmV0dXJue19pbml0Omgsc2hvdzpjLGhpZGU6ZCxyZWZyZXNoOmYsaXNWaXNpYmxlOmV9fSxhLkZFLk1PRFVMRVMuZWRpdD1mdW5jdGlvbihhKXtmdW5jdGlvbiBiKCl7aWYoYS5icm93c2VyLm1vemlsbGEpdHJ5e2EuZG9jLmV4ZWNDb21tYW5kKFxcXCJlbmFibGVPYmplY3RSZXNpemluZ1xcXCIsITEsXFxcImZhbHNlXFxcIiksYS5kb2MuZXhlY0NvbW1hbmQoXFxcImVuYWJsZUlubGluZVRhYmxlRWRpdGluZ1xcXCIsITEsXFxcImZhbHNlXFxcIil9Y2F0Y2goYil7fWlmKGEuYnJvd3Nlci5tc2llKXRyeXthLmRvYy5ib2R5LmFkZEV2ZW50TGlzdGVuZXIoXFxcIm1zY29udHJvbHNlbGVjdFxcXCIsZnVuY3Rpb24oYSl7cmV0dXJuIGEucHJldmVudERlZmF1bHQoKSwhMX0pfWNhdGNoKGIpe319ZnVuY3Rpb24gYygpe2EuJHdwPyhhLiRlbC5hdHRyKFxcXCJjb250ZW50ZWRpdGFibGVcXFwiLCEwKSxhLiRlbC5yZW1vdmVDbGFzcyhcXFwiZnItZGlzYWJsZWRcXFwiKSxhLiR0YiYmYS4kdGIucmVtb3ZlQ2xhc3MoXFxcImZyLWRpc2FibGVkXFxcIiksYigpKTphLiRlbC5pcyhcXFwiYVxcXCIpJiZhLiRlbC5hdHRyKFxcXCJjb250ZW50ZWRpdGFibGVcXFwiLCEwKSxmPSExfWZ1bmN0aW9uIGQoKXthLiR3cD8oYS4kZWwuYXR0cihcXFwiY29udGVudGVkaXRhYmxlXFxcIiwhMSksYS4kZWwuYWRkQ2xhc3MoXFxcImZyLWRpc2FibGVkXFxcIiksYS4kdGImJmEuJHRiLmFkZENsYXNzKFxcXCJmci1kaXNhYmxlZFxcXCIpKTphLiRlbC5pcyhcXFwiYVxcXCIpJiZhLiRlbC5hdHRyKFxcXCJjb250ZW50ZWRpdGFibGVcXFwiLCExKSxmPSEwfWZ1bmN0aW9uIGUoKXtyZXR1cm4gZn12YXIgZj0hMTtyZXR1cm57b246YyxvZmY6ZCxkaXNhYmxlRGVzaWduOmIsaXNEaXNhYmxlZDplfX0sYS5leHRlbmQoYS5GRS5ERUZBVUxUUyx7ZWRpdG9yQ2xhc3M6bnVsbCx0eXBpbmdUaW1lcjo1MDAsaWZyYW1lOiExLHJlcXVlc3RXaXRoQ09SUzohMCxyZXF1ZXN0SGVhZGVyczp7fSx1c2VDbGFzc2VzOiEwLHNwZWxsY2hlY2s6ITAsaWZyYW1lU3R5bGU6J2h0bWx7bWFyZ2luOiAwcHg7fWJvZHl7cGFkZGluZzoxMHB4O2JhY2tncm91bmQ6dHJhbnNwYXJlbnQ7Y29sb3I6IzAwMDAwMDtwb3NpdGlvbjpyZWxhdGl2ZTt6LWluZGV4OiAyOy13ZWJraXQtdXNlci1zZWxlY3Q6YXV0bzttYXJnaW46MHB4O292ZXJmbG93OmhpZGRlbjttaW4taGVpZ2h0OjIwcHg7fWJvZHk6YWZ0ZXJ7Y29udGVudDpcXFwiXFxcIjtkaXNwbGF5OmJsb2NrO2NsZWFyOmJvdGg7fScsaWZyYW1lU3R5bGVGaWxlczpbXSxkaXJlY3Rpb246XFxcImF1dG9cXFwiLHpJbmRleDoxLGRpc2FibGVSaWdodENsaWNrOiExLHNjcm9sbGFibGVDb250YWluZXI6XFxcImJvZHlcXFwiLGtlZXBGb3JtYXRPbkRlbGV0ZTohMSx0aGVtZTpudWxsfSksYS5GRS5NT0RVTEVTLmNvcmU9ZnVuY3Rpb24oYil7ZnVuY3Rpb24gYyhhKXtpZihiLm9wdHMuaWZyYW1lKXtiLiRoZWFkLmZpbmQoXFxcInN0eWxlW2RhdGEtZnItc3R5bGVdLCBsaW5rW2RhdGEtZnItc3R5bGVdXFxcIikucmVtb3ZlKCksYi4kaGVhZC5hcHBlbmQoJzxzdHlsZSBkYXRhLWZyLXN0eWxlPVxcXCJ0cnVlXFxcIj4nK2ErXFxcIjwvc3R5bGU+XFxcIik7Zm9yKHZhciBjPTA7YzxiLm9wdHMuaWZyYW1lU3R5bGVGaWxlcy5sZW5ndGg7YysrKWIuJGhlYWQuYXBwZW5kKCc8bGluayBkYXRhLWZyLXN0eWxlPVxcXCJ0cnVlXFxcIiByZWw9XFxcInN0eWxlc2hlZXRcXFwiIGhyZWY9XFxcIicrYi5vcHRzLmlmcmFtZVN0eWxlRmlsZXNbY10rJ1xcXCI+Jyl9fWZ1bmN0aW9uIGQoKXtiLm9wdHMuaWZyYW1lfHxiLiRlbC5hZGRDbGFzcyhcXFwiZnItZWxlbWVudCBmci12aWV3XFxcIil9ZnVuY3Rpb24gZSgpe2lmKGIuJGJveC5hZGRDbGFzcyhcXFwiZnItYm94XFxcIisoYi5vcHRzLmVkaXRvckNsYXNzP1xcXCIgXFxcIitiLm9wdHMuZWRpdG9yQ2xhc3M6XFxcIlxcXCIpKSxiLiR3cC5hZGRDbGFzcyhcXFwiZnItd3JhcHBlclxcXCIpLGQoKSxiLm9wdHMuaWZyYW1lKXtiLiRpZnJhbWUuYWRkQ2xhc3MoXFxcImZyLWlmcmFtZVxcXCIpLGIuJGVsLmFkZENsYXNzKFxcXCJmci12aWV3XFxcIik7Zm9yKHZhciBhPTA7YTxiLm9fZG9jLnN0eWxlU2hlZXRzLmxlbmd0aDthKyspe3ZhciBjO3RyeXtjPWIub19kb2Muc3R5bGVTaGVldHNbYV0uY3NzUnVsZXN9Y2F0Y2goZSl7fWlmKGMpZm9yKHZhciBmPTAsZz1jLmxlbmd0aDtnPmY7ZisrKSFjW2ZdLnNlbGVjdG9yVGV4dHx8MCE9PWNbZl0uc2VsZWN0b3JUZXh0LmluZGV4T2YoXFxcIi5mci12aWV3XFxcIikmJjAhPT1jW2ZdLnNlbGVjdG9yVGV4dC5pbmRleE9mKFxcXCIuZnItZWxlbWVudFxcXCIpfHxjW2ZdLnN0eWxlLmNzc1RleHQubGVuZ3RoPjAmJigwPT09Y1tmXS5zZWxlY3RvclRleHQuaW5kZXhPZihcXFwiLmZyLXZpZXdcXFwiKT9iLm9wdHMuaWZyYW1lU3R5bGUrPWNbZl0uc2VsZWN0b3JUZXh0LnJlcGxhY2UoL1xcXFwuZnItdmlldy9nLFxcXCJib2R5XFxcIikrXFxcIntcXFwiK2NbZl0uc3R5bGUuY3NzVGV4dCtcXFwifVxcXCI6Yi5vcHRzLmlmcmFtZVN0eWxlKz1jW2ZdLnNlbGVjdG9yVGV4dC5yZXBsYWNlKC9cXFxcLmZyLWVsZW1lbnQvZyxcXFwiYm9keVxcXCIpK1xcXCJ7XFxcIitjW2ZdLnN0eWxlLmNzc1RleHQrXFxcIn1cXFwiKX19XFxcImF1dG9cXFwiIT1iLm9wdHMuZGlyZWN0aW9uJiZiLiRib3gucmVtb3ZlQ2xhc3MoXFxcImZyLWx0ciBmci1ydGxcXFwiKS5hZGRDbGFzcyhcXFwiZnItXFxcIitiLm9wdHMuZGlyZWN0aW9uKSxiLiRlbC5hdHRyKFxcXCJkaXJcXFwiLGIub3B0cy5kaXJlY3Rpb24pLGIuJHdwLmF0dHIoXFxcImRpclxcXCIsYi5vcHRzLmRpcmVjdGlvbiksYi5vcHRzLnpJbmRleD4xJiZiLiRib3guY3NzKFxcXCJ6LWluZGV4XFxcIixiLm9wdHMuekluZGV4KSxiLm9wdHMudGhlbWUmJmIuJGJveC5hZGRDbGFzcyhiLm9wdHMudGhlbWUrXFxcIi10aGVtZVxcXCIpfWZ1bmN0aW9uIGYoKXtyZXR1cm4gYi5ub2RlLmlzRW1wdHkoYi4kZWwuZ2V0KDApKX1mdW5jdGlvbiBnKCl7Yi5kcmFnX3N1cHBvcnQ9e2ZpbGVyZWFkZXI6XFxcInVuZGVmaW5lZFxcXCIhPXR5cGVvZiBGaWxlUmVhZGVyLGZvcm1kYXRhOiEhYi53aW4uRm9ybURhdGEscHJvZ3Jlc3M6XFxcInVwbG9hZFxcXCJpbiBuZXcgWE1MSHR0cFJlcXVlc3R9fWZ1bmN0aW9uIGgoYSxjKXt2YXIgZD1uZXcgWE1MSHR0cFJlcXVlc3Q7ZC5vcGVuKGMsYSwhMCksYi5vcHRzLnJlcXVlc3RXaXRoQ09SUyYmKGQud2l0aENyZWRlbnRpYWxzPSEwKTtmb3IodmFyIGUgaW4gYi5vcHRzLnJlcXVlc3RIZWFkZXJzKWIub3B0cy5yZXF1ZXN0SGVhZGVycy5oYXNPd25Qcm9wZXJ0eShlKSYmZC5zZXRSZXF1ZXN0SGVhZGVyKGUsYi5vcHRzLnJlcXVlc3RIZWFkZXJzW2VdKTtyZXR1cm4gZH1mdW5jdGlvbiBpKGEpe1xcXCJURVhUQVJFQVxcXCI9PWIuJG9lbC5nZXQoMCkudGFnTmFtZSYmYi4kb2VsLnZhbChhKSxiLiR3cCYmKFxcXCJURVhUQVJFQVxcXCI9PWIuJG9lbC5nZXQoMCkudGFnTmFtZT8oYi4kZWwuaHRtbChcXFwiXFxcIiksYi4kd3AuaHRtbChcXFwiXFxcIiksYi4kYm94LnJlcGxhY2VXaXRoKGIuJG9lbCksYi4kb2VsLnNob3coKSk6KGIuJHdwLnJlcGxhY2VXaXRoKGEpLGIuJGVsLmh0bWwoXFxcIlxcXCIpLGIuJGJveC5yZW1vdmVDbGFzcyhcXFwiZnItdmlldyBmci1sdHIgZnItYm94IFxcXCIrKGIub3B0cy5lZGl0b3JDbGFzc3x8XFxcIlxcXCIpKSxiLm9wdHMudGhlbWUmJmIuJGJveC5hZGRDbGFzcyhiLm9wdHMudGhlbWUrXFxcIi10aGVtZVxcXCIpKSksdGhpcy4kd3A9bnVsbCx0aGlzLiRlbD1udWxsLHRoaXMuJGJveD1udWxsfWZ1bmN0aW9uIGooKXtyZXR1cm4gYi5icm93c2VyLm1vemlsbGEmJmIuaGVscGVycy5pc01vYmlsZSgpP2Iuc2VsZWN0aW9uLmluRWRpdG9yKCk6Yi5ub2RlLmhhc0ZvY3VzKGIuJGVsLmdldCgwKSl8fGIuJGVsLmZpbmQoXFxcIio6Zm9jdXNcXFwiKS5sZW5ndGg+MH1mdW5jdGlvbiBrKGEpe2lmKCFhKXJldHVybiExO3ZhciBjPWEuZGF0YShcXFwiaW5zdGFuY2VcXFwiKTtyZXR1cm4gYz9jLmlkPT1iLmlkOiExfWZ1bmN0aW9uIGwoKXtpZihhLkZFLklOU1RBTkNFUy5wdXNoKGIpLGcoKSxiLiR3cCl7ZSgpLGIuaHRtbC5zZXQoYi5fb3JpZ2luYWxfaHRtbCksYi4kZWwuYXR0cihcXFwic3BlbGxjaGVja1xcXCIsYi5vcHRzLnNwZWxsY2hlY2spLGIuaGVscGVycy5pc01vYmlsZSgpJiYoYi4kZWwuYXR0cihcXFwiYXV0b2NvbXBsZXRlXFxcIixiLm9wdHMuc3BlbGxjaGVjaz9cXFwib25cXFwiOlxcXCJvZmZcXFwiKSxiLiRlbC5hdHRyKFxcXCJhdXRvY29ycmVjdFxcXCIsYi5vcHRzLnNwZWxsY2hlY2s/XFxcIm9uXFxcIjpcXFwib2ZmXFxcIiksYi4kZWwuYXR0cihcXFwiYXV0b2NhcGl0YWxpemVcXFwiLGIub3B0cy5zcGVsbGNoZWNrP1xcXCJvblxcXCI6XFxcIm9mZlxcXCIpKSxiLm9wdHMuZGlzYWJsZVJpZ2h0Q2xpY2smJmIuZXZlbnRzLiRvbihiLiRlbCxcXFwiY29udGV4dG1lbnVcXFwiLGZ1bmN0aW9uKGEpe3JldHVybiAyPT1hLmJ1dHRvbj8hMTp2b2lkIDB9KTt0cnl7Yi5kb2MuZXhlY0NvbW1hbmQoXFxcInN0eWxlV2l0aENTU1xcXCIsITEsITEpfWNhdGNoKGMpe319Yi5ldmVudHMub24oXFxcImRyb3BcXFwiLGZ1bmN0aW9uKGEpe2EucHJldmVudERlZmF1bHQoKSxhLnN0b3BQcm9wYWdhdGlvbigpfSksXFxcIlRFWFRBUkVBXFxcIj09Yi4kb2VsLmdldCgwKS50YWdOYW1lJiYoYi5ldmVudHMub24oXFxcImNvbnRlbnRDaGFuZ2VkXFxcIixmdW5jdGlvbigpe2IuJG9lbC52YWwoYi5odG1sLmdldCgpKX0pLGIuZXZlbnRzLm9uKFxcXCJmb3JtLnN1Ym1pdFxcXCIsZnVuY3Rpb24oKXtiLiRvZWwudmFsKGIuaHRtbC5nZXQoKSl9KSxiLmV2ZW50cy5vbihcXFwiZm9ybS5yZXNldFxcXCIsZnVuY3Rpb24oKXtiLmh0bWwuc2V0KGIuX29yaWdpbmFsX2h0bWwpfSksYi4kb2VsLnZhbChiLmh0bWwuZ2V0KCkpKSxiLmhlbHBlcnMuaXNJT1MoKSYmYi5ldmVudHMuJG9uKGIuJGRvYyxcXFwic2VsZWN0aW9uY2hhbmdlXFxcIixmdW5jdGlvbigpe2IuJGRvYy5nZXQoMCkuaGFzRm9jdXMoKXx8Yi4kd2luLmdldCgwKS5mb2N1cygpfSksYi5ldmVudHMudHJpZ2dlcihcXFwiaW5pdFxcXCIpfXJldHVybntfaW5pdDpsLGRlc3Ryb3k6aSxpc0VtcHR5OmYsZ2V0WEhSOmgsaW5qZWN0U3R5bGU6YyxoYXNGb2N1czpqLHNhbWVJbnN0YW5jZTprfX0sYS5GRS5NT0RVTEVTLmZvcm1hdD1mdW5jdGlvbihiKXtmdW5jdGlvbiBjKGEsYil7dmFyIGM9XFxcIjxcXFwiK2E7Zm9yKHZhciBkIGluIGIpYi5oYXNPd25Qcm9wZXJ0eShkKSYmKGMrPVxcXCIgXFxcIitkKyc9XFxcIicrYltkXSsnXFxcIicpO3JldHVybiBjKz1cXFwiPlxcXCJ9ZnVuY3Rpb24gZChhKXtyZXR1cm5cXFwiPC9cXFwiK2ErXFxcIj5cXFwifWZ1bmN0aW9uIGUoYSxiKXt2YXIgYz1hO2Zvcih2YXIgZCBpbiBiKWIuaGFzT3duUHJvcGVydHkoZCkmJihhKz1cXFwiaWRcXFwiPT1kP1xcXCIjXFxcIitiW2RdOlxcXCJjbGFzc1xcXCI9PWQ/XFxcIi5cXFwiK2JbZF06XFxcIltcXFwiK2QrJz1cXFwiJytiW2RdKydcXFwiXScpO3JldHVybiBjfWZ1bmN0aW9uIGYoYSxiKXtyZXR1cm4gYSYmYS5ub2RlVHlwZT09Tm9kZS5FTEVNRU5UX05PREU/KGEubWF0Y2hlc3x8YS5tYXRjaGVzU2VsZWN0b3J8fGEubXNNYXRjaGVzU2VsZWN0b3J8fGEubW96TWF0Y2hlc1NlbGVjdG9yfHxhLndlYmtpdE1hdGNoZXNTZWxlY3Rvcnx8YS5vTWF0Y2hlc1NlbGVjdG9yKS5jYWxsKGEsYik6ITF9ZnVuY3Rpb24gZyhkLGUsZil7aWYoZCl7aWYoYi5ub2RlLmlzQmxvY2soZCkpcmV0dXJuIGcoZC5maXJzdENoaWxkLGUsZiksITE7Zm9yKHZhciBoPWEoYyhlLGYpKS5pbnNlcnRCZWZvcmUoZCksaT1kO2kmJiFhKGkpLmlzKFxcXCIuZnItbWFya2VyXFxcIikmJjA9PWEoaSkuZmluZChcXFwiLmZyLW1hcmtlclxcXCIpLmxlbmd0aDspe3ZhciBqPWk7aT1pLm5leHRTaWJsaW5nLGguYXBwZW5kKGopfWlmKGkpYShpKS5maW5kKFxcXCIuZnItbWFya2VyXFxcIikubGVuZ3RoJiZnKGkuZmlyc3RDaGlsZCxlLGYpO2Vsc2V7Zm9yKHZhciBrPWguZ2V0KDApLnBhcmVudE5vZGU7ayYmIWsubmV4dFNpYmxpbmcmJiFiLm5vZGUuaXNFbGVtZW50KGspOylrPWsucGFyZW50Tm9kZTtpZihrKXt2YXIgbD1rLm5leHRTaWJsaW5nO2wmJihiLm5vZGUuaXNCbG9jayhsKT9nKGwuZmlyc3RDaGlsZCxlLGYpOmcobCxlLGYpKX19aC5pcyhcXFwiOmVtcHR5XFxcIikmJmgucmVtb3ZlKCl9fWZ1bmN0aW9uIGgoaCxpKXtpZihcXFwidW5kZWZpbmVkXFxcIj09dHlwZW9mIGkmJihpPXt9KSxpLnN0eWxlJiZkZWxldGUgaS5zdHlsZSxiLnNlbGVjdGlvbi5pc0NvbGxhcHNlZCgpKXtiLm1hcmtlcnMuaW5zZXJ0KCk7dmFyIGo9Yi4kZWwuZmluZChcXFwiLmZyLW1hcmtlclxcXCIpO2oucmVwbGFjZVdpdGgoYyhoLGkpK2EuRkUuSU5WSVNJQkxFX1NQQUNFK2EuRkUuTUFSS0VSUytkKGgpKSxiLnNlbGVjdGlvbi5yZXN0b3JlKCl9ZWxzZXtiLnNlbGVjdGlvbi5zYXZlKCk7dmFyIGs9Yi4kZWwuZmluZCgnLmZyLW1hcmtlcltkYXRhLXR5cGU9XFxcInRydWVcXFwiXScpLmdldCgwKS5uZXh0U2libGluZztnKGssaCxpKTt2YXIgbDtkbyBsPWIuJGVsLmZpbmQoZShoLGkpK1xcXCIgPiBcXFwiK2UoaCxpKSksbC5lYWNoKGZ1bmN0aW9uKCl7YSh0aGlzKS5yZXBsYWNlV2l0aCh0aGlzLmlubmVySFRNTCl9KTt3aGlsZShsLmxlbmd0aCk7Yi4kZWwuZ2V0KDApLm5vcm1hbGl6ZSgpO2Zvcih2YXIgbT1iLiRlbC5nZXQoMCkucXVlcnlTZWxlY3RvckFsbChcXFwiLmZyLW1hcmtlclxcXCIpLG49MDtuPG0ubGVuZ3RoO24rKyl7dmFyIG89YShtW25dKTsxPT1vLmRhdGEoXFxcInR5cGVcXFwiKT9mKG8uZ2V0KDApLm5leHRTaWJsaW5nLGUoaCxpKSkmJm8ubmV4dCgpLnByZXBlbmQobyk6ZihvLmdldCgwKS5wcmV2aW91c1NpYmxpbmcsZShoLGkpKSYmby5wcmV2KCkuYXBwZW5kKG8pfWIuc2VsZWN0aW9uLnJlc3RvcmUoKX19ZnVuY3Rpb24gaShhLGMsZCxnKXtpZighZyl7dmFyIGg9ITE7aWYoYS5kYXRhKFxcXCJ0eXBlXFxcIik9PT0hMClmb3IoO2Iubm9kZS5pc0ZpcnN0U2libGluZyhhLmdldCgwKSkmJiFhLnBhcmVudCgpLmlzKGIuJGVsKTspYS5wYXJlbnQoKS5iZWZvcmUoYSksaD0hMDtlbHNlIGlmKGEuZGF0YShcXFwidHlwZVxcXCIpPT09ITEpZm9yKDtiLm5vZGUuaXNMYXN0U2libGluZyhhLmdldCgwKSkmJiFhLnBhcmVudCgpLmlzKGIuJGVsKTspYS5wYXJlbnQoKS5hZnRlcihhKSxoPSEwO2lmKGgpcmV0dXJuITB9aWYoYS5wYXJlbnRzKGMpLmxlbmd0aHx8XFxcInVuZGVmaW5lZFxcXCI9PXR5cGVvZiBjKXt2YXIgaT1cXFwiXFxcIixqPVxcXCJcXFwiLGs9YS5wYXJlbnQoKTtpZihrLmlzKGIuJGVsKXx8Yi5ub2RlLmlzQmxvY2soay5nZXQoMCkpKXJldHVybiExO2Zvcig7XFxcInVuZGVmaW5lZFxcXCI9PXR5cGVvZiBjJiYhYi5ub2RlLmlzQmxvY2soay5wYXJlbnQoKS5nZXQoMCkpfHxcXFwidW5kZWZpbmVkXFxcIiE9dHlwZW9mIGMmJiFmKGsuZ2V0KDApLGUoYyxkKSk7KWkrPWIubm9kZS5jbG9zZVRhZ1N0cmluZyhrLmdldCgwKSksaj1iLm5vZGUub3BlblRhZ1N0cmluZyhrLmdldCgwKSkraixrPWsucGFyZW50KCk7dmFyIGw9YS5nZXQoMCkub3V0ZXJIVE1MO2EucmVwbGFjZVdpdGgoJzxzcGFuIGlkPVxcXCJtYXJrXFxcIj48L3NwYW4+Jyk7dmFyIG09ay5odG1sKCkucmVwbGFjZSgvPHNwYW4gaWQ9XFxcIm1hcmtcXFwiPjxcXFxcL3NwYW4+LyxpK2Iubm9kZS5jbG9zZVRhZ1N0cmluZyhrLmdldCgwKSkraitsK2krYi5ub2RlLm9wZW5UYWdTdHJpbmcoay5nZXQoMCkpK2opO3JldHVybiBrLnJlcGxhY2VXaXRoKGIubm9kZS5vcGVuVGFnU3RyaW5nKGsuZ2V0KDApKSttK2Iubm9kZS5jbG9zZVRhZ1N0cmluZyhrLmdldCgwKSkpLCEwfXJldHVybiExfWZ1bmN0aW9uIGooYyxkLGcsaCl7Zm9yKHZhciBpPWIubm9kZS5jb250ZW50cyhjLmdldCgwKSksaz0wO2s8aS5sZW5ndGg7aysrKXt2YXIgbD1pW2tdO2EobCkuaGFzQ2xhc3MoXFxcImZyLW1hcmtlclxcXCIpP2Q9KGQrMSklMjpkP2EobCkuZmluZChcXFwiLmZyLW1hcmtlclxcXCIpLmxlbmd0aD4wP2Q9aihhKGwpLGQsZyxoKTooYShhKGwpLmZpbmQoZ3x8XFxcIipcXFwiKS5nZXQoKS5yZXZlcnNlKCkpLmVhY2goZnVuY3Rpb24oKXtiLm5vZGUuaXNCbG9jayh0aGlzKXx8Yi5ub2RlLmlzVm9pZCh0aGlzKXx8YSh0aGlzKS5yZXBsYWNlV2l0aCh0aGlzLmlubmVySFRNTCl9KSwoXFxcInVuZGVmaW5lZFxcXCI9PXR5cGVvZiBnJiZsLm5vZGVUeXBlPT1Ob2RlLkVMRU1FTlRfTk9ERSYmIWIubm9kZS5pc1ZvaWQobCkmJiFiLm5vZGUuaXNCbG9jayhsKXx8ZihsLGUoZyxoKSkpJiZhKGwpLnJlcGxhY2VXaXRoKGwuaW5uZXJIVE1MKSk6YShsKS5maW5kKFxcXCIuZnItbWFya2VyXFxcIikubGVuZ3RoPjAmJihkPWooYShsKSxkLGcsaCkpfXJldHVybiBkfWZ1bmN0aW9uIGsoYyxkKXtcXFwidW5kZWZpbmVkXFxcIj09dHlwZW9mIGQmJihkPXt9KSxkLnN0eWxlJiZkZWxldGUgZC5zdHlsZTt2YXIgZT1iLnNlbGVjdGlvbi5pc0NvbGxhcHNlZCgpO2Iuc2VsZWN0aW9uLnNhdmUoKTtmb3IodmFyIGY9ITA7Zjspe2Y9ITE7Zm9yKHZhciBnPWIuJGVsLmZpbmQoXFxcIi5mci1tYXJrZXJcXFwiKSxoPTA7aDxnLmxlbmd0aDtoKyspaWYoaShhKGdbaF0pLGMsZCxlKSl7Zj0hMDticmVha319aihiLiRlbCwwLGMsZCksZSYmYi4kZWwuZmluZChcXFwiLmZyLW1hcmtlclxcXCIpLmJlZm9yZShhLkZFLklOVklTSUJMRV9TUEFDRSkuYWZ0ZXIoYS5GRS5JTlZJU0lCTEVfU1BBQ0UpLGIuaHRtbC5jbGVhbkVtcHR5VGFncygpLGIuJGVsLmdldCgwKS5ub3JtYWxpemUoKSxiLnNlbGVjdGlvbi5yZXN0b3JlKCl9ZnVuY3Rpb24gbChhLGIpe3EoYSxiKT9rKGEsYik6aChhLGIpfWZ1bmN0aW9uIG0oYixjKXt2YXIgZD1hKGIpO2QuY3NzKGMsXFxcIlxcXCIpLFxcXCJcXFwiPT09ZC5hdHRyKFxcXCJzdHlsZVxcXCIpJiZkLnJlcGxhY2VXaXRoKGQuaHRtbCgpKX1mdW5jdGlvbiBuKGIsYyl7cmV0dXJuIDA9PT1hKGIpLmF0dHIoXFxcInN0eWxlXFxcIikuaW5kZXhPZihjK1xcXCI6XFxcIil8fGEoYikuYXR0cihcXFwic3R5bGVcXFwiKS5pbmRleE9mKFxcXCI7XFxcIitjK1xcXCI6XFxcIik+PTB8fGEoYikuYXR0cihcXFwic3R5bGVcXFwiKS5pbmRleE9mKFxcXCI7IFxcXCIrYytcXFwiOlxcXCIpPj0wfWZ1bmN0aW9uIG8oYyxkKXtpZihiLnNlbGVjdGlvbi5pc0NvbGxhcHNlZCgpKXtiLm1hcmtlcnMuaW5zZXJ0KCk7dmFyIGU9Yi4kZWwuZmluZChcXFwiLmZyLW1hcmtlclxcXCIpLGY9ZS5wYXJlbnQoKTtiLm5vZGUub3BlblRhZ1N0cmluZyhmLmdldCgwKSk9PSc8c3BhbiBzdHlsZT1cXFwiJytjK1xcXCI6IFxcXCIrZi5jc3MoYykrJztcXFwiPicmJmIubm9kZS5pc0VtcHR5KGYuZ2V0KDApKT9mLnJlcGxhY2VXaXRoKCc8c3BhbiBzdHlsZT1cXFwiJytjK1xcXCI6IFxcXCIrZCsnO1xcXCI+JythLkZFLklOVklTSUJMRV9TUEFDRSthLkZFLk1BUktFUlMrXFxcIjwvc3Bhbj5cXFwiKTpiLm5vZGUuaXNFbXB0eShmLmdldCgwKSkmJmYuaXMoXFxcInNwYW5cXFwiKT8oZS5yZXBsYWNlV2l0aChhLkZFLk1BUktFUlMpLGYuY3NzKGMsZCkpOmUucmVwbGFjZVdpdGgoJzxzcGFuIHN0eWxlPVxcXCInK2MrXFxcIjogXFxcIitkKyc7XFxcIj4nK2EuRkUuSU5WSVNJQkxFX1NQQUNFK2EuRkUuTUFSS0VSUytcXFwiPC9zcGFuPlxcXCIpLGIuc2VsZWN0aW9uLnJlc3RvcmUoKX1lbHNle2lmKGIuc2VsZWN0aW9uLnNhdmUoKSxudWxsPT09ZClmb3IodmFyIGg9Yi4kZWwuZmluZChcXFwiLmZyLW1hcmtlclxcXCIpLGk9MDtpPGgubGVuZ3RoO2krKyl7dmFyIGU9YShoW2ldKTtpZihlLmRhdGEoXFxcInR5cGVcXFwiKT09PSEwKWZvcig7Yi5ub2RlLmlzRmlyc3RTaWJsaW5nKGUuZ2V0KDApKSYmIWUucGFyZW50KCkuaXMoYi4kZWwpOyllLnBhcmVudCgpLmJlZm9yZShlKTtlbHNlIGZvcig7Yi5ub2RlLmlzTGFzdFNpYmxpbmcoZS5nZXQoMCkpJiYhZS5wYXJlbnQoKS5pcyhiLiRlbCk7KWUucGFyZW50KCkuYWZ0ZXIoZSl9dmFyIGo9Yi4kZWwuZmluZCgnLmZyLW1hcmtlcltkYXRhLXR5cGU9XFxcInRydWVcXFwiXScpLmdldCgwKS5uZXh0U2libGluZyxrPXtcXFwiY2xhc3NcXFwiOlxcXCJmci11bnByb2Nlc3NlZFxcXCJ9O2ZvcihkJiYoay5zdHlsZT1jK1xcXCI6IFxcXCIrZCtcXFwiO1xcXCIpLGcoaixcXFwic3BhblxcXCIsayksYi4kZWwuZmluZChcXFwiLmZyLW1hcmtlciArIC5mci11bnByb2Nlc3NlZFxcXCIpLmVhY2goZnVuY3Rpb24oKXthKHRoaXMpLnByZXBlbmQoYSh0aGlzKS5wcmV2KCkpfSksYi4kZWwuZmluZChcXFwiLmZyLXVucHJvY2Vzc2VkICsgLmZyLW1hcmtlclxcXCIpLmVhY2goZnVuY3Rpb24oKXthKHRoaXMpLnByZXYoKS5hcHBlbmQodGhpcyl9KTtiLiRlbC5maW5kKFxcXCJzcGFuLmZyLXVucHJvY2Vzc2VkXFxcIikubGVuZ3RoPjA7KXt2YXIgbD1iLiRlbC5maW5kKFxcXCJzcGFuLmZyLXVucHJvY2Vzc2VkOmZpcnN0XFxcIikucmVtb3ZlQ2xhc3MoXFxcImZyLXVucHJvY2Vzc2VkXFxcIik7aWYobC5wYXJlbnQoKS5nZXQoMCkubm9ybWFsaXplKCksbC5wYXJlbnQoKS5pcyhcXFwic3BhblxcXCIpJiYxPT1sLnBhcmVudCgpLmdldCgwKS5jaGlsZE5vZGVzLmxlbmd0aCl7bC5wYXJlbnQoKS5jc3MoYyxkKTt2YXIgbz1sO2w9bC5wYXJlbnQoKSxvLnJlcGxhY2VXaXRoKG8uaHRtbCgpKX1mb3IodmFyIHA9bC5maW5kKFxcXCJzcGFuXFxcIiksaT1wLmxlbmd0aC0xO2k+PTA7aS0tKW0ocFtpXSxjKTt2YXIgcT1sLnBhcmVudHNVbnRpbChiLiRlbCxcXFwic3BhbltzdHlsZV1cXFwiKS5maWx0ZXIoZnVuY3Rpb24oKXtyZXR1cm4gbih0aGlzLGMpfSk7aWYocS5sZW5ndGgpe3ZhciByPVxcXCJcXFwiLHM9XFxcIlxcXCIsdD1cXFwiXFxcIix1PVxcXCJcXFwiLHY9bC5nZXQoMCk7ZG8gdj12LnBhcmVudE5vZGUscis9Yi5ub2RlLmNsb3NlVGFnU3RyaW5nKHYpLHM9Yi5ub2RlLm9wZW5UYWdTdHJpbmcoYSh2KS5jbG9uZSgpLmFkZENsYXNzKFxcXCJmci1zcGxpdFxcXCIpLmdldCgwKSkrcyxxLmdldCgwKSE9diYmKHQrPWIubm9kZS5jbG9zZVRhZ1N0cmluZyh2KSx1PWIubm9kZS5vcGVuVGFnU3RyaW5nKGEodikuY2xvbmUoKS5hZGRDbGFzcyhcXFwiZnItc3BsaXRcXFwiKS5nZXQoMCkpK3UpO3doaWxlKHEuZ2V0KDApIT12KTt2YXIgdz1yK2Iubm9kZS5vcGVuVGFnU3RyaW5nKGEocS5nZXQoMCkpLmNsb25lKCkuY3NzKGMsZHx8XFxcIlxcXCIpLmdldCgwKSkrdStsLmNzcyhjLFxcXCJcXFwiKS5nZXQoMCkub3V0ZXJIVE1MK3QrXFxcIjwvc3Bhbj5cXFwiK3M7bC5yZXBsYWNlV2l0aCgnPHNwYW4gaWQ9XFxcImZyLWJyZWFrXFxcIj48L3NwYW4+Jyk7dmFyIHg9cS5nZXQoMCkub3V0ZXJIVE1MO2EocS5nZXQoMCkpLnJlcGxhY2VXaXRoKHgucmVwbGFjZSgvPHNwYW4gaWQ9XFxcImZyLWJyZWFrXFxcIj48XFxcXC9zcGFuPi9nLHcpKX19Zm9yKDtiLiRlbC5maW5kKFxcXCIuZnItc3BsaXQ6ZW1wdHlcXFwiKS5sZW5ndGg+MDspYi4kZWwuZmluZChcXFwiLmZyLXNwbGl0OmVtcHR5XFxcIikucmVtb3ZlKCk7Yi4kZWwuZmluZChcXFwiLmZyLXNwbGl0XFxcIikucmVtb3ZlQ2xhc3MoXFxcImZyLXNwbGl0XFxcIiksYi4kZWwuZmluZCgnc3BhbltzdHlsZT1cXFwiXFxcIl0nKS5yZW1vdmVBdHRyKFxcXCJzdHlsZVxcXCIpLGIuJGVsLmZpbmQoJ3NwYW5bY2xhc3M9XFxcIlxcXCJdJykucmVtb3ZlQXR0cihcXFwiY2xhc3NcXFwiKSxiLmh0bWwuY2xlYW5FbXB0eVRhZ3MoKSxhKGIuJGVsLmZpbmQoXFxcInNwYW5cXFwiKS5nZXQoKS5yZXZlcnNlKCkpLmVhY2goZnVuY3Rpb24oKXt0aGlzLmF0dHJpYnV0ZXMmJjAhPXRoaXMuYXR0cmlidXRlcy5sZW5ndGh8fGEodGhpcykucmVwbGFjZVdpdGgodGhpcy5pbm5lckhUTUwpfSksYi4kZWwuZ2V0KDApLm5vcm1hbGl6ZSgpO3ZhciB5PWIuJGVsLmZpbmQoXFxcInNwYW5bc3R5bGVdICsgc3BhbltzdHlsZV1cXFwiKTtmb3IoaT0wO2k8eS5sZW5ndGg7aSsrKXt2YXIgej1hKHlbaV0pLEE9YSh5W2ldKS5wcmV2KCk7ei5nZXQoMCkucHJldmlvdXNTaWJsaW5nPT1BLmdldCgwKSYmYi5ub2RlLm9wZW5UYWdTdHJpbmcoei5nZXQoMCkpPT1iLm5vZGUub3BlblRhZ1N0cmluZyhBLmdldCgwKSkmJih6LnByZXBlbmQoQS5odG1sKCkpLEEucmVtb3ZlKCkpfWIuJGVsLmdldCgwKS5ub3JtYWxpemUoKSxiLnNlbGVjdGlvbi5yZXN0b3JlKCl9fWZ1bmN0aW9uIHAoYSl7byhhLG51bGwpfWZ1bmN0aW9uIHEoYSxjKXtcXFwidW5kZWZpbmVkXFxcIj09dHlwZW9mIGMmJihjPXt9KSxjLnN0eWxlJiZkZWxldGUgYy5zdHlsZTt2YXIgZD1iLnNlbGVjdGlvbi5yYW5nZXMoMCksZz1kLnN0YXJ0Q29udGFpbmVyO2cubm9kZVR5cGU9PU5vZGUuRUxFTUVOVF9OT0RFJiZnLmNoaWxkTm9kZXMubGVuZ3RoPjAmJmcuY2hpbGROb2Rlc1tkLnN0YXJ0T2Zmc2V0XSYmKGc9Zy5jaGlsZE5vZGVzW2Quc3RhcnRPZmZzZXRdKTtmb3IodmFyIGg9ZztoJiZoLm5vZGVUeXBlPT1Ob2RlLkVMRU1FTlRfTk9ERSYmIWYoaCxlKGEsYykpOyloPWguZmlyc3RDaGlsZDtpZihoJiZoLm5vZGVUeXBlPT1Ob2RlLkVMRU1FTlRfTk9ERSYmZihoLGUoYSxjKSkpcmV0dXJuITA7dmFyIGk9Zztmb3IoaSYmaS5ub2RlVHlwZSE9Tm9kZS5FTEVNRU5UX05PREUmJihpPWkucGFyZW50Tm9kZSk7aSYmaS5ub2RlVHlwZT09Tm9kZS5FTEVNRU5UX05PREUmJmkhPWIuJGVsLmdldCgwKSYmIWYoaSxlKGEsYykpOylpPWkucGFyZW50Tm9kZTtyZXR1cm4gaSYmaS5ub2RlVHlwZT09Tm9kZS5FTEVNRU5UX05PREUmJmkhPWIuJGVsLmdldCgwKSYmZihpLGUoYSxjKSk/ITA6ITF9cmV0dXJue2lzOnEsdG9nZ2xlOmwsYXBwbHk6aCxyZW1vdmU6ayxhcHBseVN0eWxlOm8scmVtb3ZlU3R5bGU6cH19LGEuRkUuQ09NTUFORFM9e2JvbGQ6e3RpdGxlOlxcXCJCb2xkXFxcIixyZWZyZXNoOmZ1bmN0aW9uKGEpe2EudG9nZ2xlQ2xhc3MoXFxcImZyLWFjdGl2ZVxcXCIsdGhpcy5mb3JtYXQuaXMoXFxcInN0cm9uZ1xcXCIpKX19LGl0YWxpYzp7dGl0bGU6XFxcIkl0YWxpY1xcXCIscmVmcmVzaDpmdW5jdGlvbihhKXthLnRvZ2dsZUNsYXNzKFxcXCJmci1hY3RpdmVcXFwiLHRoaXMuZm9ybWF0LmlzKFxcXCJlbVxcXCIpKX19LHVuZGVybGluZTp7dGl0bGU6XFxcIlVuZGVybGluZVxcXCIscmVmcmVzaDpmdW5jdGlvbihhKXthLnRvZ2dsZUNsYXNzKFxcXCJmci1hY3RpdmVcXFwiLHRoaXMuZm9ybWF0LmlzKFxcXCJ1XFxcIikpfX0sc3RyaWtlVGhyb3VnaDp7dGl0bGU6XFxcIlN0cmlrZXRocm91Z2hcXFwiLHJlZnJlc2g6ZnVuY3Rpb24oYSl7YS50b2dnbGVDbGFzcyhcXFwiZnItYWN0aXZlXFxcIix0aGlzLmZvcm1hdC5pcyhcXFwic1xcXCIpKX19LHN1YnNjcmlwdDp7dGl0bGU6XFxcIlN1YnNjcmlwdFxcXCIscmVmcmVzaDpmdW5jdGlvbihhKXthLnRvZ2dsZUNsYXNzKFxcXCJmci1hY3RpdmVcXFwiLHRoaXMuZm9ybWF0LmlzKFxcXCJzdWJcXFwiKSl9fSxzdXBlcnNjcmlwdDp7dGl0bGU6XFxcIlN1cGVyc2NyaXB0XFxcIixyZWZyZXNoOmZ1bmN0aW9uKGEpe2EudG9nZ2xlQ2xhc3MoXFxcImZyLWFjdGl2ZVxcXCIsdGhpcy5mb3JtYXQuaXMoXFxcInN1cFxcXCIpKX19LG91dGRlbnQ6e3RpdGxlOlxcXCJEZWNyZWFzZSBJbmRlbnRcXFwifSxpbmRlbnQ6e3RpdGxlOlxcXCJJbmNyZWFzZSBJbmRlbnRcXFwifSx1bmRvOnt0aXRsZTpcXFwiVW5kb1xcXCIsdW5kbzohMSxmb3JjZWRSZWZyZXNoOiEwLGRpc2FibGVkOiEwfSxyZWRvOnt0aXRsZTpcXFwiUmVkb1xcXCIsdW5kbzohMSxmb3JjZWRSZWZyZXNoOiEwLGRpc2FibGVkOiEwfSxpbnNlcnRIUjp7dGl0bGU6XFxcIkluc2VydCBIb3Jpem9udGFsIExpbmVcXFwifSxjbGVhckZvcm1hdHRpbmc6e3RpdGxlOlxcXCJDbGVhciBGb3JtYXR0aW5nXFxcIn0sc2VsZWN0QWxsOnt0aXRsZTpcXFwiU2VsZWN0IEFsbFxcXCIsdW5kbzohMX19LGEuRkUuUmVnaXN0ZXJDb21tYW5kPWZ1bmN0aW9uKGIsYyl7YS5GRS5DT01NQU5EU1tiXT1jfSxhLkZFLk1PRFVMRVMuY29tbWFuZHM9ZnVuY3Rpb24oYil7ZnVuY3Rpb24gYyhjLGQpe2lmKGIuZXZlbnRzLnRyaWdnZXIoXFxcImNvbW1hbmRzLmJlZm9yZVxcXCIsYS5tZXJnZShbY10sZHx8W10pKSE9PSExKXt2YXIgZT1hLkZFLkNPTU1BTkRTW2NdJiZhLkZFLkNPTU1BTkRTW2NdLmNhbGxiYWNrfHxoW2NdLGY9ITA7YS5GRS5DT01NQU5EU1tjXSYmXFxcInVuZGVmaW5lZFxcXCIhPXR5cGVvZiBhLkZFLkNPTU1BTkRTW2NdLmZvY3VzJiYoZj1hLkZFLkNPTU1BTkRTW2NdLmZvY3VzKSxiLmNvcmUuaGFzRm9jdXMoKXx8IWZ8fGIucG9wdXBzLmFyZVZpc2libGUoKXx8Yi5ldmVudHMuZm9jdXMoITApLGEuRkUuQ09NTUFORFNbY10mJmEuRkUuQ09NTUFORFNbY10udW5kbyE9PSExJiZiLnVuZG8uc2F2ZVN0ZXAoKSxlJiZlLmFwcGx5KGIsYS5tZXJnZShbY10sZHx8W10pKSxiLmV2ZW50cy50cmlnZ2VyKFxcXCJjb21tYW5kcy5hZnRlclxcXCIsYS5tZXJnZShbY10sZHx8W10pKSxhLkZFLkNPTU1BTkRTW2NdJiZhLkZFLkNPTU1BTkRTW2NdLnVuZG8hPT0hMSYmYi51bmRvLnNhdmVTdGVwKCl9fWZ1bmN0aW9uIGQoYSxjKXtiLmZvcm1hdC50b2dnbGUoYyl9ZnVuY3Rpb24gZShjKXtiLnNlbGVjdGlvbi5zYXZlKCksYi5odG1sLndyYXAoITAsITAsITAsITApLGIuc2VsZWN0aW9uLnJlc3RvcmUoKTtmb3IodmFyIGQ9Yi5zZWxlY3Rpb24uYmxvY2tzKCksZT0wO2U8ZC5sZW5ndGg7ZSsrKWlmKFxcXCJMSVxcXCIhPWRbZV0udGFnTmFtZSYmXFxcIkxJXFxcIiE9ZFtlXS5wYXJlbnROb2RlLnRhZ05hbWUpe3ZhciBmPWEoZFtlXSksZz1cXFwicnRsXFxcIj09Yi5vcHRzLmRpcmVjdGlvbnx8XFxcInJ0bFxcXCI9PWYuY3NzKFxcXCJkaXJlY3Rpb25cXFwiKT9cXFwibWFyZ2luLXJpZ2h0XFxcIjpcXFwibWFyZ2luLWxlZnRcXFwiLGg9Yi5oZWxwZXJzLmdldFBYKGYuY3NzKGcpKTtmLmNzcyhnLE1hdGgubWF4KGgrMjAqYywwKXx8XFxcIlxcXCIpLGYucmVtb3ZlQ2xhc3MoXFxcImZyLXRlbXAtZGl2XFxcIil9Yi5zZWxlY3Rpb24uc2F2ZSgpLGIuaHRtbC51bndyYXAoKSxiLnNlbGVjdGlvbi5yZXN0b3JlKCl9ZnVuY3Rpb24gZihhKXtyZXR1cm4gZnVuY3Rpb24oKXtjKGEpfX1mdW5jdGlvbiBnKCl7Yi5ldmVudHMub24oXFxcImtleWRvd25cXFwiLGZ1bmN0aW9uKGEpe3ZhciBjPWIuc2VsZWN0aW9uLmVsZW1lbnQoKTtyZXR1cm4gYyYmXFxcIkhSXFxcIj09Yy50YWdOYW1lPyhhLnByZXZlbnREZWZhdWx0KCksITEpOnZvaWQgMH0pLGIuZXZlbnRzLm9uKFxcXCJtb3VzZWRvd25cXFwiLGZ1bmN0aW9uKGEpe3JldHVybiBhLnRhcmdldCYmXFxcIkhSXFxcIj09YS50YXJnZXQudGFnTmFtZT8oYS5wcmV2ZW50RGVmYXVsdCgpLGEuc3RvcFByb3BhZ2F0aW9uKCksITEpOnZvaWQgMH0pLGIuZXZlbnRzLm9uKFxcXCJtb3VzZXVwXFxcIixmdW5jdGlvbihjKXt2YXIgZD1iLnNlbGVjdGlvbi5lbGVtZW50KCksZT1iLnNlbGVjdGlvbi5lbmRFbGVtZW50KCk7ZD09ZSYmZCYmXFxcIkhSXFxcIj09ZC50YWdOYW1lJiYoZC5uZXh0U2libGluZyYmKGIubm9kZS5pc0Jsb2NrKGQubmV4dFNpYmxpbmcpP2Iuc2VsZWN0aW9uLnNldEF0U3RhcnQoZC5uZXh0U2libGluZyk6YShkKS5hZnRlcihhLkZFLk1BUktFUlMpKSxiLnNlbGVjdGlvbi5yZXN0b3JlKCkpfSl9dmFyIGg9e2JvbGQ6ZnVuY3Rpb24oKXtkKFxcXCJib2xkXFxcIixcXFwic3Ryb25nXFxcIil9LHN1YnNjcmlwdDpmdW5jdGlvbigpe2QoXFxcInN1YnNjcmlwdFxcXCIsXFxcInN1YlxcXCIpfSxzdXBlcnNjcmlwdDpmdW5jdGlvbigpe2QoXFxcInN1cGVyc2NyaXB0XFxcIixcXFwic3VwXFxcIil9LGl0YWxpYzpmdW5jdGlvbigpe2QoXFxcIml0YWxpY1xcXCIsXFxcImVtXFxcIil9LHN0cmlrZVRocm91Z2g6ZnVuY3Rpb24oKXtkKFxcXCJzdHJpa2VUaHJvdWdoXFxcIixcXFwic1xcXCIpfSx1bmRlcmxpbmU6ZnVuY3Rpb24oKXtkKFxcXCJ1bmRlcmxpbmVcXFwiLFxcXCJ1XFxcIil9LHVuZG86ZnVuY3Rpb24oKXtiLnVuZG8ucnVuKCl9LHJlZG86ZnVuY3Rpb24oKXtiLnVuZG8ucmVkbygpfSxpbmRlbnQ6ZnVuY3Rpb24oKXtlKDEpfSxvdXRkZW50OmZ1bmN0aW9uKCl7ZSgtMSl9LHNob3c6ZnVuY3Rpb24oKXtiLm9wdHMudG9vbGJhcklubGluZSYmYi50b29sYmFyLnNob3dJbmxpbmUobnVsbCwhMCl9LGluc2VydEhSOmZ1bmN0aW9uKCl7Yi5zZWxlY3Rpb24ucmVtb3ZlKCk7dmFyIGE9XFxcIlxcXCI7Yi5jb3JlLmlzRW1wdHkoKSYmKGE9XFxcIjxicj5cXFwiLGIuaHRtbC5kZWZhdWx0VGFnKCkmJihhPVxcXCI8XFxcIitiLmh0bWwuZGVmYXVsdFRhZygpK1xcXCI+XFxcIithK1xcXCI8L1xcXCIrYi5odG1sLmRlZmF1bHRUYWcoKStcXFwiPlxcXCIpKSxiLmh0bWwuaW5zZXJ0KCc8aHIgaWQ9XFxcImZyLWp1c3RcXFwiPicrYSk7dmFyIGM9Yi4kZWwuZmluZChcXFwiaHIjZnItanVzdFxcXCIpO2MucmVtb3ZlQXR0cihcXFwiaWRcXFwiKSxiLnNlbGVjdGlvbi5zZXRBZnRlcihjLmdldCgwKSl8fGIuc2VsZWN0aW9uLnNldEJlZm9yZShjLmdldCgwKSksYi5zZWxlY3Rpb24ucmVzdG9yZSgpfSxjbGVhckZvcm1hdHRpbmc6ZnVuY3Rpb24oKXtiLmZvcm1hdC5yZW1vdmUoKX0sc2VsZWN0QWxsOmZ1bmN0aW9uKCl7Yi5kb2MuZXhlY0NvbW1hbmQoXFxcInNlbGVjdEFsbFxcXCIsITEsITEpfX0saT17fTtmb3IodmFyIGogaW4gaCloLmhhc093blByb3BlcnR5KGopJiYoaVtqXT1mKGopKTtyZXR1cm4gYS5leHRlbmQoaSx7ZXhlYzpjLF9pbml0Omd9KX0sYS5GRS5NT0RVTEVTLmN1cnNvckxpc3RzPWZ1bmN0aW9uKGIpe2Z1bmN0aW9uIGMoYSl7Zm9yKHZhciBiPWE7XFxcIkxJXFxcIiE9Yi50YWdOYW1lOyliPWIucGFyZW50Tm9kZTtyZXR1cm4gYn1mdW5jdGlvbiBkKGEpe2Zvcih2YXIgYz1hOyFiLm5vZGUuaXNMaXN0KGMpOyljPWMucGFyZW50Tm9kZTtyZXR1cm4gY31mdW5jdGlvbiBlKGUpe3ZhciBmLGc9YyhlKSxoPWcubmV4dFNpYmxpbmcsaT1nLnByZXZpb3VzU2libGluZyxqPWIuaHRtbC5kZWZhdWx0VGFnKCk7aWYoYi5ub2RlLmlzRW1wdHkoZywhMCkmJmgpe2Zvcih2YXIgaz1cXFwiXFxcIixsPVxcXCJcXFwiLG09ZS5wYXJlbnROb2RlOyFiLm5vZGUuaXNMaXN0KG0pJiZtLnBhcmVudE5vZGUmJlxcXCJMSVxcXCIhPT1tLnBhcmVudE5vZGUudGFnTmFtZTspaz1iLm5vZGUub3BlblRhZ1N0cmluZyhtKStrLGwrPWIubm9kZS5jbG9zZVRhZ1N0cmluZyhtKSxtPW0ucGFyZW50Tm9kZTtrPWIubm9kZS5vcGVuVGFnU3RyaW5nKG0pK2ssbCs9Yi5ub2RlLmNsb3NlVGFnU3RyaW5nKG0pO3ZhciBuPVxcXCJcXFwiO2ZvcihuPW0ucGFyZW50Tm9kZSYmXFxcIkxJXFxcIj09bS5wYXJlbnROb2RlLnRhZ05hbWU/bCtcXFwiPGxpPlxcXCIrYS5GRS5NQVJLRVJTK1xcXCI8YnI+XFxcIitrOmo/bCtcXFwiPFxcXCIraitcXFwiPlxcXCIrYS5GRS5NQVJLRVJTK1xcXCI8YnI+PC9cXFwiK2orXFxcIj5cXFwiK2s6bCthLkZFLk1BUktFUlMrXFxcIjxicj5cXFwiK2ssYShnKS5odG1sKCc8c3BhbiBpZD1cXFwiZnItYnJlYWtcXFwiPjwvc3Bhbj4nKTtbXFxcIlVMXFxcIixcXFwiT0xcXFwiXS5pbmRleE9mKG0udGFnTmFtZSk8MHx8bS5wYXJlbnROb2RlJiZcXFwiTElcXFwiPT09bS5wYXJlbnROb2RlLnRhZ05hbWU7KW09bS5wYXJlbnROb2RlO3ZhciBvPWIubm9kZS5vcGVuVGFnU3RyaW5nKG0pK2EobSkuaHRtbCgpK2Iubm9kZS5jbG9zZVRhZ1N0cmluZyhtKTtvPW8ucmVwbGFjZSgvPHNwYW4gaWQ9XFxcImZyLWJyZWFrXFxcIj48XFxcXC9zcGFuPi9nLG4pLGEobSkucmVwbGFjZVdpdGgobyksYi4kZWwuZmluZChcXFwibGk6ZW1wdHlcXFwiKS5yZW1vdmUoKX1lbHNlIGkmJmh8fCFiLm5vZGUuaXNFbXB0eShnLCEwKT8oYShnKS5iZWZvcmUoXFxcIjxsaT48YnI+PC9saT5cXFwiKSxhKGUpLnJlbW92ZSgpKTppPyhmPWQoZyksZi5wYXJlbnROb2RlJiZcXFwiTElcXFwiPT1mLnBhcmVudE5vZGUudGFnTmFtZT9hKGYucGFyZW50Tm9kZSkuYWZ0ZXIoXFxcIjxsaT5cXFwiK2EuRkUuTUFSS0VSUytcXFwiPGJyPjwvbGk+XFxcIik6aj9hKGYpLmFmdGVyKFxcXCI8XFxcIitqK1xcXCI+XFxcIithLkZFLk1BUktFUlMrXFxcIjxicj48L1xcXCIraitcXFwiPlxcXCIpOmEoZikuYWZ0ZXIoYS5GRS5NQVJLRVJTK1xcXCI8YnI+XFxcIiksYShnKS5yZW1vdmUoKSk6KGY9ZChnKSxmLnBhcmVudE5vZGUmJlxcXCJMSVxcXCI9PWYucGFyZW50Tm9kZS50YWdOYW1lP2EoZi5wYXJlbnROb2RlKS5iZWZvcmUoXFxcIjxsaT5cXFwiK2EuRkUuTUFSS0VSUytcXFwiPGJyPjwvbGk+XFxcIik6aj9hKGYpLmJlZm9yZShcXFwiPFxcXCIraitcXFwiPlxcXCIrYS5GRS5NQVJLRVJTK1xcXCI8YnI+PC9cXFwiK2orXFxcIj5cXFwiKTphKGYpLmJlZm9yZShhLkZFLk1BUktFUlMrXFxcIjxicj5cXFwiKSxhKGcpLnJlbW92ZSgpKX1mdW5jdGlvbiBmKGQpe2Zvcih2YXIgZT1jKGQpLGY9XFxcIlxcXCIsZz1kLGg9XFxcIlxcXCIsaT1cXFwiXFxcIjtnIT1lOyl7Zz1nLnBhcmVudE5vZGU7dmFyIGo9XFxcIkFcXFwiPT1nLnRhZ05hbWUmJmIuY3Vyc29yLmlzQXRFbmQoZCxnKT9cXFwiZnItdG8tcmVtb3ZlXFxcIjpcXFwiXFxcIjtoPWIubm9kZS5vcGVuVGFnU3RyaW5nKGEoZykuY2xvbmUoKS5hZGRDbGFzcyhqKS5nZXQoMCkpK2gsaT1iLm5vZGUuY2xvc2VUYWdTdHJpbmcoZykraX1mPWkrZitoK2EuRkUuTUFSS0VSUyxhKGQpLnJlcGxhY2VXaXRoKCc8c3BhbiBpZD1cXFwiZnItYnJlYWtcXFwiPjwvc3Bhbj4nKTt2YXIgaz1iLm5vZGUub3BlblRhZ1N0cmluZyhlKSthKGUpLmh0bWwoKStiLm5vZGUuY2xvc2VUYWdTdHJpbmcoZSk7az1rLnJlcGxhY2UoLzxzcGFuIGlkPVxcXCJmci1icmVha1xcXCI+PFxcXFwvc3Bhbj4vZyxmKSxhKGUpLnJlcGxhY2VXaXRoKGspfWZ1bmN0aW9uIGcoZCl7Zm9yKHZhciBlPWMoZCksZj1hLkZFLk1BUktFUlMsZz1cXFwiXFxcIixoPWQsaT0hMTtoIT1lOyl7aD1oLnBhcmVudE5vZGU7dmFyIGo9XFxcIkFcXFwiPT1oLnRhZ05hbWUmJmIuY3Vyc29yLmlzQXRFbmQoZCxoKT9cXFwiZnItdG8tcmVtb3ZlXFxcIjpcXFwiXFxcIjtpfHxoPT1lfHxiLm5vZGUuaXNCbG9jayhoKXx8KGk9ITAsZys9YS5GRS5JTlZJU0lCTEVfU1BBQ0UpLGc9Yi5ub2RlLm9wZW5UYWdTdHJpbmcoYShoKS5jbG9uZSgpLmFkZENsYXNzKGopLmdldCgwKSkrZyxmKz1iLm5vZGUuY2xvc2VUYWdTdHJpbmcoaCl9dmFyIGs9ZytmO2EoZCkucmVtb3ZlKCksYShlKS5hZnRlcihrKX1mdW5jdGlvbiBoKGUpe3ZhciBmPWMoZSksZz1mLnByZXZpb3VzU2libGluZztpZihnKXtnPWEoZykuZmluZChiLmh0bWwuYmxvY2tUYWdzUXVlcnkoKSkuZ2V0KC0xKXx8ZyxhKGUpLnJlcGxhY2VXaXRoKGEuRkUuTUFSS0VSUyk7dmFyIGg9Yi5ub2RlLmNvbnRlbnRzKGcpO2gubGVuZ3RoJiZcXFwiQlJcXFwiPT1oW2gubGVuZ3RoLTFdLnRhZ05hbWUmJmEoaFtoLmxlbmd0aC0xXSkucmVtb3ZlKCksYShmKS5maW5kKGIuaHRtbC5ibG9ja1RhZ3NRdWVyeSgpKS5ub3QoXFxcIm9sLCB1bCwgdGFibGVcXFwiKS5lYWNoKGZ1bmN0aW9uKCl7dGhpcy5wYXJlbnROb2RlPT1mJiZhKHRoaXMpLnJlcGxhY2VXaXRoKGEodGhpcykuaHRtbCgpKyhiLm5vZGUuaXNFbXB0eSh0aGlzKT9cXFwiXFxcIjpcXFwiPGJyPlxcXCIpKX0pO2Zvcih2YXIgaSxqPWIubm9kZS5jb250ZW50cyhmKVswXTtqJiYhYi5ub2RlLmlzTGlzdChqKTspaT1qLm5leHRTaWJsaW5nLGEoZykuYXBwZW5kKGopLGo9aTtmb3IoZz1mLnByZXZpb3VzU2libGluZztqOylpPWoubmV4dFNpYmxpbmcsYShnKS5hcHBlbmQoaiksaj1pO2EoZikucmVtb3ZlKCl9ZWxzZXt2YXIgaz1kKGYpO2lmKGEoZSkucmVwbGFjZVdpdGgoYS5GRS5NQVJLRVJTKSxrLnBhcmVudE5vZGUmJlxcXCJMSVxcXCI9PWsucGFyZW50Tm9kZS50YWdOYW1lKXt2YXIgbD1rLnByZXZpb3VzU2libGluZztiLm5vZGUuaXNCbG9jayhsKT8oYShmKS5maW5kKGIuaHRtbC5ibG9ja1RhZ3NRdWVyeSgpKS5ub3QoXFxcIm9sLCB1bCwgdGFibGVcXFwiKS5lYWNoKGZ1bmN0aW9uKCl7dGhpcy5wYXJlbnROb2RlPT1mJiZhKHRoaXMpLnJlcGxhY2VXaXRoKGEodGhpcykuaHRtbCgpKyhiLm5vZGUuaXNFbXB0eSh0aGlzKT9cXFwiXFxcIjpcXFwiPGJyPlxcXCIpKX0pLGEobCkuYXBwZW5kKGEoZikuaHRtbCgpKSk6YShrKS5iZWZvcmUoYShmKS5odG1sKCkpfWVsc2V7dmFyIG09Yi5odG1sLmRlZmF1bHRUYWcoKTttJiYwPT09YShmKS5maW5kKGIuaHRtbC5ibG9ja1RhZ3NRdWVyeSgpKS5sZW5ndGg/YShrKS5iZWZvcmUoXFxcIjxcXFwiK20rXFxcIj5cXFwiK2EoZikuaHRtbCgpK1xcXCI8L1xcXCIrbStcXFwiPlxcXCIpOmEoaykuYmVmb3JlKGEoZikuaHRtbCgpKX1hKGYpLnJlbW92ZSgpLDA9PT1hKGspLmZpbmQoXFxcImxpXFxcIikubGVuZ3RoJiZhKGspLnJlbW92ZSgpfX1mdW5jdGlvbiBpKGQpe3ZhciBlLGY9YyhkKSxnPWYubmV4dFNpYmxpbmc7aWYoZyl7ZT1iLm5vZGUuY29udGVudHMoZyksZS5sZW5ndGgmJlxcXCJCUlxcXCI9PWVbMF0udGFnTmFtZSYmYShlWzBdKS5yZW1vdmUoKSxhKGcpLmZpbmQoYi5odG1sLmJsb2NrVGFnc1F1ZXJ5KCkpLm5vdChcXFwib2wsIHVsLCB0YWJsZVxcXCIpLmVhY2goZnVuY3Rpb24oKXt0aGlzLnBhcmVudE5vZGU9PWcmJmEodGhpcykucmVwbGFjZVdpdGgoYSh0aGlzKS5odG1sKCkrKGIubm9kZS5pc0VtcHR5KHRoaXMpP1xcXCJcXFwiOlxcXCI8YnI+XFxcIikpfSk7Zm9yKHZhciBoLGk9ZCxqPWIubm9kZS5jb250ZW50cyhnKVswXTtqJiYhYi5ub2RlLmlzTGlzdChqKTspaD1qLm5leHRTaWJsaW5nLGEoaSkuYWZ0ZXIoaiksaT1qLGo9aDtmb3IoO2o7KWg9ai5uZXh0U2libGluZyxhKGYpLmFwcGVuZChqKSxqPWg7YShkKS5yZXBsYWNlV2l0aChhLkZFLk1BUktFUlMpLGEoZykucmVtb3ZlKCl9ZWxzZXtmb3IodmFyIGs9Zjshay5uZXh0U2libGluZyYmayE9Yi4kZWwuZ2V0KDApOylrPWsucGFyZW50Tm9kZTtpZihrPT1iLiRlbC5nZXQoMCkpcmV0dXJuITE7aWYoaz1rLm5leHRTaWJsaW5nLGIubm9kZS5pc0Jsb2NrKGspKWEuRkUuTk9fREVMRVRFX1RBR1MuaW5kZXhPZihrLnRhZ05hbWUpPDAmJihhKGQpLnJlcGxhY2VXaXRoKGEuRkUuTUFSS0VSUyksZT1iLm5vZGUuY29udGVudHMoZiksZS5sZW5ndGgmJlxcXCJCUlxcXCI9PWVbZS5sZW5ndGgtMV0udGFnTmFtZSYmYShlW2UubGVuZ3RoLTFdKS5yZW1vdmUoKSxhKGYpLmFwcGVuZChhKGspLmh0bWwoKSksYShrKS5yZW1vdmUoKSk7ZWxzZSBmb3IoZT1iLm5vZGUuY29udGVudHMoZiksZS5sZW5ndGgmJlxcXCJCUlxcXCI9PWVbZS5sZW5ndGgtMV0udGFnTmFtZSYmYShlW2UubGVuZ3RoLTFdKS5yZW1vdmUoKSxhKGQpLnJlcGxhY2VXaXRoKGEuRkUuTUFSS0VSUyk7ayYmIWIubm9kZS5pc0Jsb2NrKGspJiZcXFwiQlJcXFwiIT1rLnRhZ05hbWU7KWEoZikuYXBwZW5kKGEoaykpLGs9ay5uZXh0U2libGluZ319cmV0dXJue19zdGFydEVudGVyOmUsX21pZGRsZUVudGVyOmYsX2VuZEVudGVyOmcsX2JhY2tzcGFjZTpoLF9kZWw6aX19LGEuRkUuTk9fREVMRVRFX1RBR1M9W1xcXCJUSFxcXCIsXFxcIlREXFxcIixcXFwiVEFCTEVcXFwiLFxcXCJGT1JNXFxcIl0sYS5GRS5TSU1QTEVfRU5URVJfVEFHUz1bXFxcIlRIXFxcIixcXFwiVERcXFwiLFxcXCJMSVxcXCIsXFxcIkRMXFxcIixcXFwiRFRcXFwiLFxcXCJGT1JNXFxcIl0sYS5GRS5NT0RVTEVTLmN1cnNvcj1mdW5jdGlvbihiKXtmdW5jdGlvbiBjKGEpe3JldHVybiBhP2Iubm9kZS5pc0Jsb2NrKGEpPyEwOmEubmV4dFNpYmxpbmc/ITE6YyhhLnBhcmVudE5vZGUpOiExfWZ1bmN0aW9uIGQoYSl7cmV0dXJuIGE/Yi5ub2RlLmlzQmxvY2soYSk/ITA6YS5wcmV2aW91c1NpYmxpbmc/ITE6ZChhLnBhcmVudE5vZGUpOiExfWZ1bmN0aW9uIGUoYSxjKXtyZXR1cm4gYT9hPT1iLiR3cC5nZXQoMCk/ITE6YS5wcmV2aW91c1NpYmxpbmc/ITE6YS5wYXJlbnROb2RlPT1jPyEwOmUoYS5wYXJlbnROb2RlLGMpOiExfWZ1bmN0aW9uIGYoYSxjKXtyZXR1cm4gYT9hPT1iLiR3cC5nZXQoMCk/ITE6YS5uZXh0U2libGluZz8hMTphLnBhcmVudE5vZGU9PWM/ITA6ZihhLnBhcmVudE5vZGUsYyk6ITF9ZnVuY3Rpb24gZyhjKXtyZXR1cm4gYShjKS5wYXJlbnRzVW50aWwoYi4kZWwsXFxcIkxJXFxcIikubGVuZ3RoPjAmJjA9PT1hKGMpLnBhcmVudHNVbnRpbChcXFwiTElcXFwiLFxcXCJUQUJMRVxcXCIpLmxlbmd0aH1mdW5jdGlvbiBoKGMpe3ZhciBkPWEoYykucGFyZW50c1VudGlsKGIuJGVsLFxcXCJCTE9DS1FVT1RFXFxcIikubGVuZ3RoPjAsZT1iLm5vZGUuZGVlcGVzdFBhcmVudChjLFtdLCFkKTtpZihlJiZcXFwiQkxPQ0tRVU9URVxcXCI9PWUudGFnTmFtZSl7dmFyIGY9Yi5ub2RlLmRlZXBlc3RQYXJlbnQoYyxbYShjKS5wYXJlbnRzVW50aWwoYi4kZWwsXFxcIkJMT0NLUVVPVEVcXFwiKS5nZXQoMCldKTtmJiZmLnByZXZpb3VzU2libGluZyYmKGU9Zil9aWYobnVsbCE9PWUpe3ZhciBnLGg9ZS5wcmV2aW91c1NpYmxpbmc7aWYoYi5ub2RlLmlzQmxvY2soZSkmJmIubm9kZS5pc0VkaXRhYmxlKGUpJiZoJiZhLkZFLk5PX0RFTEVURV9UQUdTLmluZGV4T2YoaC50YWdOYW1lKTwwKWlmKGIubm9kZS5pc0RlbGV0YWJsZShoKSlhKGgpLnJlbW92ZSgpLGEoYykucmVwbGFjZVdpdGgoYS5GRS5NQVJLRVJTKTtlbHNlIGlmKGIubm9kZS5pc0VkaXRhYmxlKGgpKWlmKGIubm9kZS5pc0Jsb2NrKGgpKWlmKGIubm9kZS5pc0VtcHR5KGgpJiYhYi5ub2RlLmlzTGlzdChoKSlhKGgpLnJlbW92ZSgpO2Vsc2V7aWYoYi5ub2RlLmlzTGlzdChoKSYmKGg9YShoKS5maW5kKFxcXCJsaTpsYXN0XFxcIikuZ2V0KDApKSxnPWIubm9kZS5jb250ZW50cyhoKSxnLmxlbmd0aCYmXFxcIkJSXFxcIj09Z1tnLmxlbmd0aC0xXS50YWdOYW1lJiZhKGdbZy5sZW5ndGgtMV0pLnJlbW92ZSgpLFxcXCJCTE9DS1FVT1RFXFxcIj09aC50YWdOYW1lJiZcXFwiQkxPQ0tRVU9URVxcXCIhPWUudGFnTmFtZSlmb3IoZz1iLm5vZGUuY29udGVudHMoaCk7Zy5sZW5ndGgmJmIubm9kZS5pc0Jsb2NrKGdbZy5sZW5ndGgtMV0pOyloPWdbZy5sZW5ndGgtMV0sZz1iLm5vZGUuY29udGVudHMoaCk7ZWxzZSBpZihcXFwiQkxPQ0tRVU9URVxcXCIhPWgudGFnTmFtZSYmXFxcIkJMT0NLUVVPVEVcXFwiPT1lLnRhZ05hbWUpZm9yKGc9Yi5ub2RlLmNvbnRlbnRzKGUpO2cubGVuZ3RoJiZiLm5vZGUuaXNCbG9jayhnWzBdKTspZT1nWzBdLGc9Yi5ub2RlLmNvbnRlbnRzKGUpO2EoYykucmVwbGFjZVdpdGgoYS5GRS5NQVJLRVJTKSxhKGgpLmFwcGVuZChiLm5vZGUuaXNFbXB0eShlKT9hLkZFLk1BUktFUlM6ZS5pbm5lckhUTUwpLGEoZSkucmVtb3ZlKCl9ZWxzZSBhKGMpLnJlcGxhY2VXaXRoKGEuRkUuTUFSS0VSUyksXFxcIkJMT0NLUVVPVEVcXFwiPT1lLnRhZ05hbWUmJmgubm9kZVR5cGU9PU5vZGUuRUxFTUVOVF9OT0RFP2EoaCkucmVtb3ZlKCk6KGEoaCkuYWZ0ZXIoYi5ub2RlLmlzRW1wdHkoZSk/XFxcIlxcXCI6YShlKS5odG1sKCkpLGEoZSkucmVtb3ZlKCksXFxcIkJSXFxcIj09aC50YWdOYW1lJiZhKGgpLnJlbW92ZSgpKX19ZnVuY3Rpb24gaShjKXtmb3IodmFyIGQ9YzshZC5wcmV2aW91c1NpYmxpbmc7KWlmKGQ9ZC5wYXJlbnROb2RlLGIubm9kZS5pc0VsZW1lbnQoZCkpcmV0dXJuITE7ZD1kLnByZXZpb3VzU2libGluZzt2YXIgZTtpZighYi5ub2RlLmlzQmxvY2soZCkmJmIubm9kZS5pc0VkaXRhYmxlKGQpKXtmb3IoZT1iLm5vZGUuY29udGVudHMoZCk7ZC5ub2RlVHlwZSE9Tm9kZS5URVhUX05PREUmJiFiLm5vZGUuaXNEZWxldGFibGUoZCkmJmUubGVuZ3RoJiZiLm5vZGUuaXNFZGl0YWJsZShkKTspZD1lW2UubGVuZ3RoLTFdLGU9Yi5ub2RlLmNvbnRlbnRzKGQpO2lmKGQubm9kZVR5cGU9PU5vZGUuVEVYVF9OT0RFKXtpZihiLmhlbHBlcnMuaXNJT1MoKSlyZXR1cm4hMDt2YXIgZj1kLnRleHRDb250ZW50LGc9Zi5sZW5ndGgtMTtpZihiLm9wdHMudGFiU3BhY2VzJiZmLmxlbmd0aD49Yi5vcHRzLnRhYlNwYWNlcyl7dmFyIGg9Zi5zdWJzdHIoZi5sZW5ndGgtYi5vcHRzLnRhYlNwYWNlcyxmLmxlbmd0aC0xKTswPT1oLnJlcGxhY2UoLyAvZyxcXFwiXFxcIikucmVwbGFjZShuZXcgUmVnRXhwKGEuRkUuVU5JQ09ERV9OQlNQLFxcXCJnXFxcIiksXFxcIlxcXCIpLmxlbmd0aCYmKGc9Zi5sZW5ndGgtYi5vcHRzLnRhYlNwYWNlcyl9ZC50ZXh0Q29udGVudD1mLnN1YnN0cmluZygwLGcpLGQudGV4dENvbnRlbnQubGVuZ3RoJiY1NTM1Nz09ZC50ZXh0Q29udGVudC5jaGFyQ29kZUF0KGQudGV4dENvbnRlbnQubGVuZ3RoLTEpJiYoZC50ZXh0Q29udGVudD1kLnRleHRDb250ZW50LnN1YnN0cigwLGQudGV4dENvbnRlbnQubGVuZ3RoLTEpKSwwPT1kLnRleHRDb250ZW50Lmxlbmd0aD8yIT1kLnBhcmVudE5vZGUuY2hpbGROb2Rlcy5sZW5ndGh8fGQucGFyZW50Tm9kZSE9Yy5wYXJlbnROb2RlfHxiLm5vZGUuaXNCbG9jayhkLnBhcmVudE5vZGUpfHxiLm5vZGUuaXNFbGVtZW50KGQucGFyZW50Tm9kZSk/KGEoZCkuYWZ0ZXIoYS5GRS5NQVJLRVJTKSxiLm5vZGUuaXNFbGVtZW50KGQucGFyZW50Tm9kZSkmJiFjLm5leHRTaWJsaW5nJiZkLnByZXZpb3VzU2libGluZyYmXFxcIkJSXFxcIj09ZC5wcmV2aW91c1NpYmxpbmcudGFnTmFtZSYmYShjKS5hZnRlcihcXFwiPGJyPlxcXCIpLGQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChkKSk6KGEoZC5wYXJlbnROb2RlKS5hZnRlcihhLkZFLk1BUktFUlMpLGEoZC5wYXJlbnROb2RlKS5yZW1vdmUoKSk6YShkKS5hZnRlcihhLkZFLk1BUktFUlMpfWVsc2UgYi5ub2RlLmlzRGVsZXRhYmxlKGQpPyhhKGQpLmFmdGVyKGEuRkUuTUFSS0VSUyksYShkKS5yZW1vdmUoKSk6Yi5ldmVudHMudHJpZ2dlcihcXFwibm9kZS5yZW1vdmVcXFwiLFthKGQpXSkhPT0hMSYmKGEoZCkuYWZ0ZXIoYS5GRS5NQVJLRVJTKSxhKGQpLnJlbW92ZSgpKX1lbHNlIGlmKGEuRkUuTk9fREVMRVRFX1RBR1MuaW5kZXhPZihkLnRhZ05hbWUpPDAmJmIubm9kZS5pc0VkaXRhYmxlKGQpKWlmKGIubm9kZS5pc0VtcHR5KGQpJiYhYi5ub2RlLmlzTGlzdChkKSlhKGQpLnJlbW92ZSgpLGEoYykucmVwbGFjZVdpdGgoYS5GRS5NQVJLRVJTKTtlbHNle2ZvcihiLm5vZGUuaXNMaXN0KGQpJiYoZD1hKGQpLmZpbmQoXFxcImxpOmxhc3RcXFwiKS5nZXQoMCkpLGU9Yi5ub2RlLmNvbnRlbnRzKGQpLGUmJlxcXCJCUlxcXCI9PWVbZS5sZW5ndGgtMV0udGFnTmFtZSYmYShlW2UubGVuZ3RoLTFdKS5yZW1vdmUoKSxlPWIubm9kZS5jb250ZW50cyhkKTtlJiZiLm5vZGUuaXNCbG9jayhlW2UubGVuZ3RoLTFdKTspZD1lW2UubGVuZ3RoLTFdLGU9Yi5ub2RlLmNvbnRlbnRzKGQpO2EoZCkuYXBwZW5kKGEuRkUuTUFSS0VSUyk7Zm9yKHZhciBpPWM7IWkucHJldmlvdXNTaWJsaW5nOylpPWkucGFyZW50Tm9kZTtmb3IoO2kmJlxcXCJCUlxcXCIhPT1pLnRhZ05hbWUmJiFiLm5vZGUuaXNCbG9jayhpKTspe3ZhciBqPWk7aT1pLm5leHRTaWJsaW5nLGEoZCkuYXBwZW5kKGopfWkmJlxcXCJCUlxcXCI9PWkudGFnTmFtZSYmYShpKS5yZW1vdmUoKSxhKGMpLnJlbW92ZSgpfWVsc2UgYy5uZXh0U2libGluZyYmXFxcIkJSXFxcIj09Yy5uZXh0U2libGluZy50YWdOYW1lJiZhKGMubmV4dFNpYmxpbmcpLnJlbW92ZSgpfWZ1bmN0aW9uIGooKXt2YXIgZj0hMSxqPWIubWFya2Vycy5pbnNlcnQoKTtpZighailyZXR1cm4hMDtiLiRlbC5nZXQoMCkubm9ybWFsaXplKCk7dmFyIGs9ai5wcmV2aW91c1NpYmxpbmc7aWYoayl7dmFyIGw9ay50ZXh0Q29udGVudDtsJiZsLmxlbmd0aCYmODIwMz09bC5jaGFyQ29kZUF0KGwubGVuZ3RoLTEpJiYoMT09bC5sZW5ndGg/YShrKS5yZW1vdmUoKTooay50ZXh0Q29udGVudD1rLnRleHRDb250ZW50LnN1YnN0cigwLGwubGVuZ3RoLTEpLGsudGV4dENvbnRlbnQubGVuZ3RoJiY1NTM1Nz09ay50ZXh0Q29udGVudC5jaGFyQ29kZUF0KGsudGV4dENvbnRlbnQubGVuZ3RoLTEpJiYoay50ZXh0Q29udGVudD1rLnRleHRDb250ZW50LnN1YnN0cigwLGsudGV4dENvbnRlbnQubGVuZ3RoLTEpKSkpfXJldHVybiBjKGopP2Y9aShqKTpkKGopP2coaikmJmUoaixhKGopLnBhcmVudHMoXFxcImxpOmZpcnN0XFxcIikuZ2V0KDApKT9iLmN1cnNvckxpc3RzLl9iYWNrc3BhY2Uoaik6aChqKTpmPWkoaiksYShqKS5yZW1vdmUoKSxiLiRlbC5maW5kKFxcXCJibG9ja3F1b3RlOmVtcHR5XFxcIikucmVtb3ZlKCksYi5odG1sLmZpbGxFbXB0eUJsb2NrcygpLGIuaHRtbC5jbGVhbkVtcHR5VGFncygpLGIuY2xlYW4ucXVvdGVzKCksYi5jbGVhbi5saXN0cygpLGIuc3BhY2VzLm5vcm1hbGl6ZSgpLGIuc2VsZWN0aW9uLnJlc3RvcmUoKSxmfWZ1bmN0aW9uIGsoYyl7dmFyIGQ9YShjKS5wYXJlbnRzVW50aWwoYi4kZWwsXFxcIkJMT0NLUVVPVEVcXFwiKS5sZW5ndGg+MCxlPWIubm9kZS5kZWVwZXN0UGFyZW50KGMsW10sIWQpO2lmKGUmJlxcXCJCTE9DS1FVT1RFXFxcIj09ZS50YWdOYW1lKXt2YXIgZj1iLm5vZGUuZGVlcGVzdFBhcmVudChjLFthKGMpLnBhcmVudHNVbnRpbChiLiRlbCxcXFwiQkxPQ0tRVU9URVxcXCIpLmdldCgwKV0pO2YmJmYubmV4dFNpYmxpbmcmJihlPWYpfWlmKG51bGwhPT1lKXt2YXIgZyxoPWUubmV4dFNpYmxpbmc7aWYoYi5ub2RlLmlzQmxvY2soZSkmJihiLm5vZGUuaXNFZGl0YWJsZShlKXx8Yi5ub2RlLmlzRGVsZXRhYmxlKGUpKSYmaCYmYS5GRS5OT19ERUxFVEVfVEFHUy5pbmRleE9mKGgudGFnTmFtZSk8MClpZihiLm5vZGUuaXNEZWxldGFibGUoaCkpYShoKS5yZW1vdmUoKSxhKGMpLnJlcGxhY2VXaXRoKGEuRkUuTUFSS0VSUyk7ZWxzZSBpZihiLm5vZGUuaXNCbG9jayhoKSYmYi5ub2RlLmlzRWRpdGFibGUoaCkpaWYoYi5ub2RlLmlzTGlzdChoKSlpZihiLm5vZGUuaXNFbXB0eShlLCEwKSlhKGUpLnJlbW92ZSgpLGEoaCkuZmluZChcXFwibGk6Zmlyc3RcXFwiKS5wcmVwZW5kKGEuRkUuTUFSS0VSUyk7ZWxzZXt2YXIgaT1hKGgpLmZpbmQoXFxcImxpOmZpcnN0XFxcIik7XFxcIkJMT0NLUVVPVEVcXFwiPT1lLnRhZ05hbWUmJihnPWIubm9kZS5jb250ZW50cyhlKSxnLmxlbmd0aCYmYi5ub2RlLmlzQmxvY2soZ1tnLmxlbmd0aC0xXSkmJihlPWdbZy5sZW5ndGgtMV0pKSwwPT09aS5maW5kKFxcXCJ1bCwgb2xcXFwiKS5sZW5ndGgmJihhKGMpLnJlcGxhY2VXaXRoKGEuRkUuTUFSS0VSUyksaS5maW5kKGIuaHRtbC5ibG9ja1RhZ3NRdWVyeSgpKS5ub3QoXFxcIm9sLCB1bCwgdGFibGVcXFwiKS5lYWNoKGZ1bmN0aW9uKCl7dGhpcy5wYXJlbnROb2RlPT1pLmdldCgwKSYmYSh0aGlzKS5yZXBsYWNlV2l0aChhKHRoaXMpLmh0bWwoKSsoYi5ub2RlLmlzRW1wdHkodGhpcyk/XFxcIlxcXCI6XFxcIjxicj5cXFwiKSl9KSxhKGUpLmFwcGVuZChiLm5vZGUuY29udGVudHMoaS5nZXQoMCkpKSxpLnJlbW92ZSgpLDA9PT1hKGgpLmZpbmQoXFxcImxpXFxcIikubGVuZ3RoJiZhKGgpLnJlbW92ZSgpKX1lbHNle2lmKGc9Yi5ub2RlLmNvbnRlbnRzKGgpLGcubGVuZ3RoJiZcXFwiQlJcXFwiPT1nWzBdLnRhZ05hbWUmJmEoZ1swXSkucmVtb3ZlKCksXFxcIkJMT0NLUVVPVEVcXFwiIT1oLnRhZ05hbWUmJlxcXCJCTE9DS1FVT1RFXFxcIj09ZS50YWdOYW1lKWZvcihnPWIubm9kZS5jb250ZW50cyhlKTtnLmxlbmd0aCYmYi5ub2RlLmlzQmxvY2soZ1tnLmxlbmd0aC0xXSk7KWU9Z1tnLmxlbmd0aC0xXSxnPWIubm9kZS5jb250ZW50cyhlKTtlbHNlIGlmKFxcXCJCTE9DS1FVT1RFXFxcIj09aC50YWdOYW1lJiZcXFwiQkxPQ0tRVU9URVxcXCIhPWUudGFnTmFtZSlmb3IoZz1iLm5vZGUuY29udGVudHMoaCk7Zy5sZW5ndGgmJmIubm9kZS5pc0Jsb2NrKGdbMF0pOyloPWdbMF0sZz1iLm5vZGUuY29udGVudHMoaCk7YShjKS5yZXBsYWNlV2l0aChhLkZFLk1BUktFUlMpLGEoZSkuYXBwZW5kKGguaW5uZXJIVE1MKSxhKGgpLnJlbW92ZSgpfWVsc2V7Zm9yKGEoYykucmVwbGFjZVdpdGgoYS5GRS5NQVJLRVJTKTtoJiZcXFwiQlJcXFwiIT09aC50YWdOYW1lJiYhYi5ub2RlLmlzQmxvY2soaCkmJmIubm9kZS5pc0VkaXRhYmxlKGgpOyl7dmFyIGo9aDtoPWgubmV4dFNpYmxpbmcsYShlKS5hcHBlbmQoail9aCYmXFxcIkJSXFxcIj09aC50YWdOYW1lJiZiLm5vZGUuaXNFZGl0YWJsZShoKSYmYShoKS5yZW1vdmUoKX19fWZ1bmN0aW9uIGwoZCl7Zm9yKHZhciBlPWQ7IWUubmV4dFNpYmxpbmc7KWlmKGU9ZS5wYXJlbnROb2RlLGIubm9kZS5pc0VsZW1lbnQoZSkpcmV0dXJuITE7aWYoZT1lLm5leHRTaWJsaW5nLFxcXCJCUlxcXCI9PWUudGFnTmFtZSYmYi5ub2RlLmlzRWRpdGFibGUoZSkpaWYoZS5uZXh0U2libGluZyl7aWYoYi5ub2RlLmlzQmxvY2soZS5uZXh0U2libGluZykmJmIubm9kZS5pc0VkaXRhYmxlKGUubmV4dFNpYmxpbmcpKXtpZighKGEuRkUuTk9fREVMRVRFX1RBR1MuaW5kZXhPZihlLm5leHRTaWJsaW5nLnRhZ05hbWUpPDApKXJldHVybiB2b2lkIGEoZSkucmVtb3ZlKCk7ZT1lLm5leHRTaWJsaW5nLGEoZS5wcmV2aW91c1NpYmxpbmcpLnJlbW92ZSgpfX1lbHNlIGlmKGMoZSkpe2lmKGcoZCkpYi5jdXJzb3JMaXN0cy5fZGVsKGQpO2Vsc2V7dmFyIGY9Yi5ub2RlLmRlZXBlc3RQYXJlbnQoZSk7ZiYmKGEoZSkucmVtb3ZlKCksayhkKSl9cmV0dXJufXZhciBoO2lmKCFiLm5vZGUuaXNCbG9jayhlKSYmYi5ub2RlLmlzRWRpdGFibGUoZSkpe2ZvcihoPWIubm9kZS5jb250ZW50cyhlKTtlLm5vZGVUeXBlIT1Ob2RlLlRFWFRfTk9ERSYmaC5sZW5ndGgmJiFiLm5vZGUuaXNEZWxldGFibGUoZSkmJmIubm9kZS5pc0VkaXRhYmxlKGUpOyllPWhbMF0saD1iLm5vZGUuY29udGVudHMoZSk7ZS5ub2RlVHlwZT09Tm9kZS5URVhUX05PREU/KGEoZSkuYmVmb3JlKGEuRkUuTUFSS0VSUyksZS50ZXh0Q29udGVudC5sZW5ndGgmJjU1MzU3PT1lLnRleHRDb250ZW50LmNoYXJDb2RlQXQoMCk/ZS50ZXh0Q29udGVudD1lLnRleHRDb250ZW50LnN1YnN0cmluZygyLGUudGV4dENvbnRlbnQubGVuZ3RoKTplLnRleHRDb250ZW50PWUudGV4dENvbnRlbnQuc3Vic3RyaW5nKDEsZS50ZXh0Q29udGVudC5sZW5ndGgpKTpiLm5vZGUuaXNEZWxldGFibGUoZSk/KGEoZSkuYmVmb3JlKGEuRkUuTUFSS0VSUyksYShlKS5yZW1vdmUoKSk6Yi5ldmVudHMudHJpZ2dlcihcXFwibm9kZS5yZW1vdmVcXFwiLFthKGUpXSkhPT0hMSYmKGEoZSkuYmVmb3JlKGEuRkUuTUFSS0VSUyksYShlKS5yZW1vdmUoKSksYShkKS5yZW1vdmUoKX1lbHNlIGlmKGEuRkUuTk9fREVMRVRFX1RBR1MuaW5kZXhPZihlLnRhZ05hbWUpPDAmJihiLm5vZGUuaXNFZGl0YWJsZShlKXx8Yi5ub2RlLmlzRGVsZXRhYmxlKGUpKSlpZihiLm5vZGUuaXNEZWxldGFibGUoZSkpYShkKS5yZXBsYWNlV2l0aChhLkZFLk1BUktFUlMpLGEoZSkucmVtb3ZlKCk7ZWxzZSBpZihiLm5vZGUuaXNMaXN0KGUpKWQucHJldmlvdXNTaWJsaW5nPyhhKGUpLmZpbmQoXFxcImxpOmZpcnN0XFxcIikucHJlcGVuZChkKSxiLmN1cnNvckxpc3RzLl9iYWNrc3BhY2UoZCkpOihhKGUpLmZpbmQoXFxcImxpOmZpcnN0XFxcIikucHJlcGVuZChhLkZFLk1BUktFUlMpLGEoZCkucmVtb3ZlKCkpO2Vsc2UgaWYoaD1iLm5vZGUuY29udGVudHMoZSksaCYmXFxcIkJSXFxcIj09aFswXS50YWdOYW1lJiZhKGhbMF0pLnJlbW92ZSgpLGgmJlxcXCJCTE9DS1FVT1RFXFxcIj09ZS50YWdOYW1lKXt2YXIgaT1oWzBdO2ZvcihhKGQpLmJlZm9yZShhLkZFLk1BUktFUlMpO2kmJlxcXCJCUlxcXCIhPWkudGFnTmFtZTspe3ZhciBqPWk7aT1pLm5leHRTaWJsaW5nLGEoZCkuYmVmb3JlKGopfWkmJlxcXCJCUlxcXCI9PWkudGFnTmFtZSYmYShpKS5yZW1vdmUoKX1lbHNlIGEoZCkuYWZ0ZXIoYShlKS5odG1sKCkpLmFmdGVyKGEuRkUuTUFSS0VSUyksYShlKS5yZW1vdmUoKX1mdW5jdGlvbiBtKCl7dmFyIGU9Yi5tYXJrZXJzLmluc2VydCgpO2lmKCFlKXJldHVybiExO2lmKGIuJGVsLmdldCgwKS5ub3JtYWxpemUoKSxjKGUpKWlmKGcoZSkpaWYoMD09PWEoZSkucGFyZW50cyhcXFwibGk6Zmlyc3RcXFwiKS5maW5kKFxcXCJ1bCwgb2xcXFwiKS5sZW5ndGgpYi5jdXJzb3JMaXN0cy5fZGVsKGUpO2Vsc2V7dmFyIGY9YShlKS5wYXJlbnRzKFxcXCJsaTpmaXJzdFxcXCIpLmZpbmQoXFxcInVsOmZpcnN0LCBvbDpmaXJzdFxcXCIpLmZpbmQoXFxcImxpOmZpcnN0XFxcIik7Zj1mLmZpbmQoYi5odG1sLmJsb2NrVGFnc1F1ZXJ5KCkpLmdldCgtMSl8fGYsZi5wcmVwZW5kKGUpLGIuY3Vyc29yTGlzdHMuX2JhY2tzcGFjZShlKX1lbHNlIGsoZSk7ZWxzZSBsKGQoZSk/ZTplKTthKGUpLnJlbW92ZSgpLGIuJGVsLmZpbmQoXFxcImJsb2NrcXVvdGU6ZW1wdHlcXFwiKS5yZW1vdmUoKSxiLmh0bWwuZmlsbEVtcHR5QmxvY2tzKCksYi5odG1sLmNsZWFuRW1wdHlUYWdzKCksYi5jbGVhbi5xdW90ZXMoKSxiLmNsZWFuLmxpc3RzKCksYi5zcGFjZXMubm9ybWFsaXplKCksYi5zZWxlY3Rpb24ucmVzdG9yZSgpfWZ1bmN0aW9uIG4oKXtiLiRlbC5maW5kKFxcXCIuZnItdG8tcmVtb3ZlXFxcIikuZWFjaChmdW5jdGlvbigpe2Zvcih2YXIgYz1iLm5vZGUuY29udGVudHModGhpcyksZD0wO2Q8Yy5sZW5ndGg7ZCsrKWNbZF0ubm9kZVR5cGU9PU5vZGUuVEVYVF9OT0RFJiYoY1tkXS50ZXh0Q29udGVudD1jW2RdLnRleHRDb250ZW50LnJlcGxhY2UoL1xcXFx1MjAwQi9nLFxcXCJcXFwiKSk7YSh0aGlzKS5yZXBsYWNlV2l0aCh0aGlzLmlubmVySFRNTCl9KX1mdW5jdGlvbiBvKGMsZCxlKXt2YXIgZyxoPWIubm9kZS5kZWVwZXN0UGFyZW50KGMsW10sIWUpO2lmKGgmJlxcXCJCTE9DS1FVT1RFXFxcIj09aC50YWdOYW1lKXJldHVybiBmKGMsaCk/KGc9Yi5odG1sLmRlZmF1bHRUYWcoKSxcXG5nP2EoaCkuYWZ0ZXIoXFxcIjxcXFwiK2crXFxcIj5cXFwiK2EuRkUuTUFSS0VSUytcXFwiPGJyPjwvXFxcIitnK1xcXCI+XFxcIik6YShoKS5hZnRlcihhLkZFLk1BUktFUlMrXFxcIjxicj5cXFwiKSxhKGMpLnJlbW92ZSgpLCExKToocShjLGQsZSksITEpO2lmKG51bGw9PWgpZz1iLmh0bWwuZGVmYXVsdFRhZygpLGcmJmIubm9kZS5pc0VsZW1lbnQoYy5wYXJlbnROb2RlKT9hKGMpLnJlcGxhY2VXaXRoKFxcXCI8XFxcIitnK1xcXCI+XFxcIithLkZFLk1BUktFUlMrXFxcIjxicj48L1xcXCIrZytcXFwiPlxcXCIpOmEoYykucmVwbGFjZVdpdGgoXFxcIjxici8+XFxcIithLkZFLk1BUktFUlMrXFxcIjxici8+XFxcIik7ZWxzZXt2YXIgaT1jLGo9XFxcIlxcXCI7KCFiLm5vZGUuaXNCbG9jayhoKXx8ZCkmJihqPVxcXCI8YnIvPlxcXCIpO3ZhciBrPVxcXCJcXFwiLGw9XFxcIlxcXCI7Zz1iLmh0bWwuZGVmYXVsdFRhZygpO3ZhciBtPVxcXCJcXFwiLG49XFxcIlxcXCI7ZyYmYi5ub2RlLmlzQmxvY2soaCkmJihtPVxcXCI8XFxcIitnK1xcXCI+XFxcIixuPVxcXCI8L1xcXCIrZytcXFwiPlxcXCIsaC50YWdOYW1lPT1nLnRvVXBwZXJDYXNlKCkmJihtPWIubm9kZS5vcGVuVGFnU3RyaW5nKGEoaCkuY2xvbmUoKS5yZW1vdmVBdHRyKFxcXCJpZFxcXCIpLmdldCgwKSkpKTtkbyBpZihpPWkucGFyZW50Tm9kZSwhZHx8aSE9aHx8ZCYmIWIubm9kZS5pc0Jsb2NrKGgpKWlmKGsrPWIubm9kZS5jbG9zZVRhZ1N0cmluZyhpKSxpPT1oJiZiLm5vZGUuaXNCbG9jayhoKSlsPW0rbDtlbHNle3ZhciBvPVxcXCJBXFxcIj09aS50YWdOYW1lJiZmKGMsaSk/XFxcImZyLXRvLXJlbW92ZVxcXCI6XFxcIlxcXCI7bD1iLm5vZGUub3BlblRhZ1N0cmluZyhhKGkpLmNsb25lKCkuYWRkQ2xhc3MobykuZ2V0KDApKStsfXdoaWxlKGkhPWgpO2o9aytqK2wrKGMucGFyZW50Tm9kZT09aCYmYi5ub2RlLmlzQmxvY2soaCk/XFxcIlxcXCI6YS5GRS5JTlZJU0lCTEVfU1BBQ0UpK2EuRkUuTUFSS0VSUyxiLm5vZGUuaXNCbG9jayhoKSYmIWEoaCkuZmluZChcXFwiKjpsYXN0XFxcIikuaXMoXFxcImJyXFxcIikmJmEoaCkuYXBwZW5kKFxcXCI8YnIvPlxcXCIpLGEoYykuYWZ0ZXIoJzxzcGFuIGlkPVxcXCJmci1icmVha1xcXCI+PC9zcGFuPicpLGEoYykucmVtb3ZlKCksaC5uZXh0U2libGluZyYmIWIubm9kZS5pc0Jsb2NrKGgubmV4dFNpYmxpbmcpfHxiLm5vZGUuaXNCbG9jayhoKXx8YShoKS5hZnRlcihcXFwiPGJyPlxcXCIpO3ZhciBwO3A9IWQmJmIubm9kZS5pc0Jsb2NrKGgpP2Iubm9kZS5vcGVuVGFnU3RyaW5nKGgpK2EoaCkuaHRtbCgpK246Yi5ub2RlLm9wZW5UYWdTdHJpbmcoaCkrYShoKS5odG1sKCkrYi5ub2RlLmNsb3NlVGFnU3RyaW5nKGgpLHA9cC5yZXBsYWNlKC88c3BhbiBpZD1cXFwiZnItYnJlYWtcXFwiPjxcXFxcL3NwYW4+L2csaiksYShoKS5yZXBsYWNlV2l0aChwKX19ZnVuY3Rpb24gcChjLGQsZyl7dmFyIGgsaT1iLm5vZGUuZGVlcGVzdFBhcmVudChjLFtdLCFnKTtpZihpJiZcXFwiQkxPQ0tRVU9URVxcXCI9PWkudGFnTmFtZSl7aWYoZShjLGkpKXJldHVybiBoPWIuaHRtbC5kZWZhdWx0VGFnKCksaD9hKGkpLmJlZm9yZShcXFwiPFxcXCIraCtcXFwiPlxcXCIrYS5GRS5NQVJLRVJTK1xcXCI8YnI+PC9cXFwiK2grXFxcIj5cXFwiKTphKGkpLmJlZm9yZShhLkZFLk1BUktFUlMrXFxcIjxicj5cXFwiKSxhKGMpLnJlbW92ZSgpLCExO2YoYyxpKT9vKGMsZCwhMCk6cShjLGQsITApfWlmKG51bGw9PWkpaD1iLmh0bWwuZGVmYXVsdFRhZygpLGgmJmIubm9kZS5pc0VsZW1lbnQoYy5wYXJlbnROb2RlKT9hKGMpLnJlcGxhY2VXaXRoKFxcXCI8XFxcIitoK1xcXCI+XFxcIithLkZFLk1BUktFUlMrXFxcIjxicj48L1xcXCIraCtcXFwiPlxcXCIpOmEoYykucmVwbGFjZVdpdGgoXFxcIjxicj5cXFwiK2EuRkUuTUFSS0VSUyk7ZWxzZXtpZihiLm5vZGUuaXNCbG9jayhpKSlpZihkKWEoYykucmVtb3ZlKCksYShpKS5wcmVwZW5kKFxcXCI8YnI+XFxcIithLkZFLk1BUktFUlMpO2Vsc2V7aWYoYi5ub2RlLmlzRW1wdHkoaSwhMCkpcmV0dXJuIG8oYyxkLGcpO2EoaSkuYmVmb3JlKGIubm9kZS5vcGVuVGFnU3RyaW5nKGEoaSkuY2xvbmUoKS5yZW1vdmVBdHRyKFxcXCJpZFxcXCIpLmdldCgwKSkrXFxcIjxicj5cXFwiK2Iubm9kZS5jbG9zZVRhZ1N0cmluZyhpKSl9ZWxzZSBhKGkpLmJlZm9yZShcXFwiPGJyPlxcXCIpO2EoYykucmVtb3ZlKCl9fWZ1bmN0aW9uIHEoYyxkLGcpe3ZhciBoPWIubm9kZS5kZWVwZXN0UGFyZW50KGMsW10sIWcpO2lmKG51bGw9PWgpYi5odG1sLmRlZmF1bHRUYWcoKSYmYy5wYXJlbnROb2RlPT09Yi4kZWwuZ2V0KDApP2EoYykucmVwbGFjZVdpdGgoXFxcIjxcXFwiK2IuaHRtbC5kZWZhdWx0VGFnKCkrXFxcIj5cXFwiK2EuRkUuTUFSS0VSUytcXFwiPGJyPjwvXFxcIitiLmh0bWwuZGVmYXVsdFRhZygpK1xcXCI+XFxcIik6KCghYy5uZXh0U2libGluZ3x8Yi5ub2RlLmlzQmxvY2soYy5uZXh0U2libGluZykpJiZhKGMpLmFmdGVyKFxcXCI8YnI+XFxcIiksYShjKS5yZXBsYWNlV2l0aChcXFwiPGJyPlxcXCIrYS5GRS5NQVJLRVJTKSk7ZWxzZXt2YXIgaT1jLGo9XFxcIlxcXCI7XFxcIlBSRVxcXCI9PWgudGFnTmFtZSYmKGQ9ITApLCghYi5ub2RlLmlzQmxvY2soaCl8fGQpJiYoaj1cXFwiPGJyPlxcXCIpO3ZhciBrPVxcXCJcXFwiLGw9XFxcIlxcXCI7ZG97dmFyIG09aTtpZihpPWkucGFyZW50Tm9kZSxcXFwiQkxPQ0tRVU9URVxcXCI9PWgudGFnTmFtZSYmYi5ub2RlLmlzRW1wdHkobSkmJiFhKG0pLmhhc0NsYXNzKFxcXCJmci1tYXJrZXJcXFwiKSYmYShtKS5maW5kKGMpLmxlbmd0aD4wJiZhKG0pLmFmdGVyKGMpLChcXFwiQkxPQ0tRVU9URVxcXCIhPWgudGFnTmFtZXx8IWYoYyxpKSYmIWUoYyxpKSkmJighZHx8aSE9aHx8ZCYmIWIubm9kZS5pc0Jsb2NrKGgpKSl7ays9Yi5ub2RlLmNsb3NlVGFnU3RyaW5nKGkpO3ZhciBuPVxcXCJBXFxcIj09aS50YWdOYW1lJiZmKGMsaSk/XFxcImZyLXRvLXJlbW92ZVxcXCI6XFxcIlxcXCI7bD1iLm5vZGUub3BlblRhZ1N0cmluZyhhKGkpLmNsb25lKCkuYWRkQ2xhc3MobikucmVtb3ZlQXR0cihcXFwiaWRcXFwiKS5nZXQoMCkpK2x9fXdoaWxlKGkhPWgpO3ZhciBvPWg9PWMucGFyZW50Tm9kZSYmYi5ub2RlLmlzQmxvY2soaCl8fGMubmV4dFNpYmxpbmc7aWYoXFxcIkJMT0NLUVVPVEVcXFwiPT1oLnRhZ05hbWUpe2MucHJldmlvdXNTaWJsaW5nJiZiLm5vZGUuaXNCbG9jayhjLnByZXZpb3VzU2libGluZykmJmMubmV4dFNpYmxpbmcmJlxcXCJCUlxcXCI9PWMubmV4dFNpYmxpbmcudGFnTmFtZSYmKGEoYy5uZXh0U2libGluZykuYWZ0ZXIoYyksYy5uZXh0U2libGluZyYmXFxcIkJSXFxcIj09Yy5uZXh0U2libGluZy50YWdOYW1lJiZhKGMubmV4dFNpYmxpbmcpLnJlbW92ZSgpKTt2YXIgcD1iLmh0bWwuZGVmYXVsdFRhZygpO2o9aytqKyhwP1xcXCI8XFxcIitwK1xcXCI+XFxcIjpcXFwiXFxcIikrYS5GRS5NQVJLRVJTK1xcXCI8YnI+XFxcIisocD9cXFwiPC9cXFwiK3ArXFxcIj5cXFwiOlxcXCJcXFwiKStsfWVsc2Ugaj1rK2orbCsobz9cXFwiXFxcIjphLkZFLklOVklTSUJMRV9TUEFDRSkrYS5GRS5NQVJLRVJTO2EoYykucmVwbGFjZVdpdGgoJzxzcGFuIGlkPVxcXCJmci1icmVha1xcXCI+PC9zcGFuPicpO3ZhciBxPWIubm9kZS5vcGVuVGFnU3RyaW5nKGgpK2EoaCkuaHRtbCgpK2Iubm9kZS5jbG9zZVRhZ1N0cmluZyhoKTtxPXEucmVwbGFjZSgvPHNwYW4gaWQ9XFxcImZyLWJyZWFrXFxcIj48XFxcXC9zcGFuPi9nLGopLGEoaCkucmVwbGFjZVdpdGgocSl9fWZ1bmN0aW9uIHIoZSl7dmFyIGY9Yi5tYXJrZXJzLmluc2VydCgpO2lmKCFmKXJldHVybiEwO2IuJGVsLmdldCgwKS5ub3JtYWxpemUoKTt2YXIgaD0hMTthKGYpLnBhcmVudHNVbnRpbChiLiRlbCxcXFwiQkxPQ0tRVU9URVxcXCIpLmxlbmd0aD4wJiYoZT0hMSxoPSEwKSxhKGYpLnBhcmVudHNVbnRpbChiLiRlbCxcXFwiVEQsIFRIXFxcIikubGVuZ3RoJiYoaD0hMSksYyhmKT8hZyhmKXx8ZXx8aD9vKGYsZSxoKTpiLmN1cnNvckxpc3RzLl9lbmRFbnRlcihmKTpkKGYpPyFnKGYpfHxlfHxoP3AoZixlLGgpOmIuY3Vyc29yTGlzdHMuX3N0YXJ0RW50ZXIoZik6IWcoZil8fGV8fGg/cShmLGUsaCk6Yi5jdXJzb3JMaXN0cy5fbWlkZGxlRW50ZXIoZiksbigpLGIuaHRtbC5maWxsRW1wdHlCbG9ja3MoKSxiLmh0bWwuY2xlYW5FbXB0eVRhZ3MoKSxiLmNsZWFuLmxpc3RzKCksYi5zcGFjZXMubm9ybWFsaXplKCksYi5zZWxlY3Rpb24ucmVzdG9yZSgpfXJldHVybntlbnRlcjpyLGJhY2tzcGFjZTpqLGRlbDptLGlzQXRFbmQ6Zn19LGEuRkUuTU9EVUxFUy5kYXRhPWZ1bmN0aW9uKGEpe2Z1bmN0aW9uIGIoYSl7cmV0dXJuIGF9ZnVuY3Rpb24gYyhhKXtpZighYSlyZXR1cm4gYTtmb3IodmFyIGM9XFxcIlxcXCIsZj1iKFxcXCJjaGFyQ29kZUF0XFxcIiksZz1iKFxcXCJmcm9tQ2hhckNvZGVcXFwiKSxoPWwuaW5kZXhPZihhWzBdKSxpPTE7aTxhLmxlbmd0aC0yO2krKyl7Zm9yKHZhciBqPWQoKytoKSxrPWFbZl0oaSksbT1cXFwiXFxcIjsvWzAtOS1dLy50ZXN0KGFbaSsxXSk7KW0rPWFbKytpXTttPXBhcnNlSW50KG0sMTApfHwwLGs9ZShrLGosbSksa149aC0xJjMxLGMrPVN0cmluZ1tnXShrKX1yZXR1cm4gY31mdW5jdGlvbiBkKGEpe2Zvcih2YXIgYj1hLnRvU3RyaW5nKCksYz0wLGQ9MDtkPGIubGVuZ3RoO2QrKyljKz1wYXJzZUludChiLmNoYXJBdChkKSwxMCk7cmV0dXJuIGM+MTA/YyU5KzE6Y31mdW5jdGlvbiBlKGEsYixjKXtmb3IodmFyIGQ9TWF0aC5hYnMoYyk7ZC0tID4wOylhLT1iO3JldHVybiAwPmMmJihhKz0xMjMpLGF9ZnVuY3Rpb24gZihhKXtyZXR1cm4gYSYmXFxcIm5vbmVcXFwiPT1hLmNzcyhcXFwiZGlzcGxheVxcXCIpPyhhLnJlbW92ZSgpLCEwKTohMX1mdW5jdGlvbiBnKCl7cmV0dXJuIGYoail8fGYoayl9ZnVuY3Rpb24gaCgpe3JldHVybiBhLiRib3g/KGEuJGJveC5hcHBlbmQobihiKG4oXFxcImtUREQ0c3BtS0Qxa2xhTUIxQzdBNVJBMUczUkExMFlBNXFocmp1dm5tRTFEM0ZEMmJjRy03bm9IRTZCMkpCNEMzeFhBOFdGNkYtMTBSRzJDM0czQi0yMXpaRTNDM0gzeENBMTZOQzREQzFmMWhPRjFNQjNCLTIxd2h6UUg1VUEyV0IxMGtjMUMyRjREM1hDMllENEQxQzRGM0dGMmVKMmxmY0QtMTNIRjFJRTFUQzExVEM3V0U0VEE0ZDFBMllBNlhBNGQxQTN5Q0cycW1CLTEzR0Y0QTFCMUtIMUhEMmZ6ZmJlUUMzVEQ5VkU0d2QxSDJBMjBBMkItMjJ1akIzbkJHMkExM2pCQzEwRDNDMkhENUQxSDFLQjExdUQtMTZ1V0YyRDRBM0YtN0M5RC0xN2MxRTRENEIzZDFEMkNBNkIyQi0xM3Fsd3pKRjJOQzJDLTEzRS0xMU5EMUEzeHFVQThVRTZic3JyRi03Qy0yMmlhMUQyQ0YySDFFMmFrQ0QyT0UxSEgxZGxLQTZQQTVqY3lmekItMjJjWEI0ZjFDM3F2ZGlDNGdqR0cySDJna2xDM0QtMTZ3SkMxVUc0ZGdhV0UyRDVHNGcxSTJIM0I3dmtxcnhIMUgyRUM5QzNFNGdkZ3pLRjFPQTFBNVBGNUM0V1dDM1ZBNlhBNGUxRTNZQTJZQTVIRTRvR0g0RjJIMklCMTBEM0QyTkM1RzFCMXFXQTlQRDZQRzVmUUExM0ExMFhBNEM0QTNlMUgyQkExN2tDLTIyY21PQjFsbW9BMmZ5aGNwdHdXQTNSQThBLTEzeEItMTFuZjFJM2YxQjdHQjNhRDNwYXZGQzEwRDVnTEYyT0cxTFNCMkQ5RTdmUUMxRjRGM3dwU0I1WEQzTmtrbGhoYUUtMTFuYUtBOUJuSUE2RDFGNWJRQTNBMTBjMVFDNktqa3ZpdGMyQjZCRTNBRjNFMkRBNkE0SkQySUMxamdBLTY0TUIxMUQ2QzQ9PVxcXCIpKSkpLGo9YS4kYm94LmZpbmQoXFxcIj4gZGl2Omxhc3RcXFwiKSxrPWouZmluZChcXFwiPiBhXFxcIiksdm9pZChcXFwicnRsXFxcIj09YS5vcHRzLmRpcmVjdGlvbiYmai5jc3MoXFxcImxlZnRcXFwiLFxcXCJhdXRvXFxcIikuY3NzKFxcXCJyaWdodFxcXCIsMCkpKTohMX1mdW5jdGlvbiBpKCl7dmFyIGM9YS5vcHRzLmtleXx8W1xcXCJcXFwiXTtcXFwic3RyaW5nXFxcIj09dHlwZW9mIGMmJihjPVtjXSksYS51bD0hMDtmb3IodmFyIGQ9MDtkPGMubGVuZ3RoO2QrKyl7dmFyIGU9bihjW2RdKXx8XFxcIlxcXCI7aWYoIShlIT09bihiKG4oXFxcIm1jVlJEb0IxQkdJTEQ3WUZlMUJUWEJBN0I2PT1cXFwiKSkpJiZlLmluZGV4T2YobSxlLmxlbmd0aC1tLmxlbmd0aCk8MCYmW24oXFxcIjlxcUctN2Ftamx3cT09XFxcIiksbihcXFwiS0EzQjNDMkE2RDFENUg1SDFBMz09XFxcIiksbihcXFwiUXpienZ4eUIyeUEtOW09PVxcXCIpXS5pbmRleE9mKG0pPDApKXthLnVsPSExO2JyZWFrfX1hLnVsPT09ITAmJmgoKSxhLmV2ZW50cy5vbihcXFwiY29udGVudENoYW5nZWRcXFwiLGZ1bmN0aW9uKCl7YS51bD09PSEwJiZnKCkmJmgoKX0pLGEuZXZlbnRzLm9uKFxcXCJkZXN0cm95XFxcIixmdW5jdGlvbigpe2omJmoubGVuZ3RoJiZqLnJlbW92ZSgpfSwhMCl9dmFyIGosayxsPVxcXCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OVxcXCIsbT1mdW5jdGlvbigpe2Zvcih2YXIgYT0wLGI9ZG9jdW1lbnQuZG9tYWluLGM9Yi5zcGxpdChcXFwiLlxcXCIpLGQ9XFxcIl9nZFxcXCIrKG5ldyBEYXRlKS5nZXRUaW1lKCk7YTxjLmxlbmd0aC0xJiYtMT09ZG9jdW1lbnQuY29va2llLmluZGV4T2YoZCtcXFwiPVxcXCIrZCk7KWI9Yy5zbGljZSgtMS0rK2EpLmpvaW4oXFxcIi5cXFwiKSxkb2N1bWVudC5jb29raWU9ZCtcXFwiPVxcXCIrZCtcXFwiO2RvbWFpbj1cXFwiK2IrXFxcIjtcXFwiO3JldHVybiBkb2N1bWVudC5jb29raWU9ZCtcXFwiPTtleHBpcmVzPVRodSwgMDEgSmFuIDE5NzAgMDA6MDA6MDEgR01UO2RvbWFpbj1cXFwiK2IrXFxcIjtcXFwiLGJ9KCksbj1iKGMpO3JldHVybntfaW5pdDppfX0sYS5GRS5FTlRFUl9QPTAsYS5GRS5FTlRFUl9ESVY9MSxhLkZFLkVOVEVSX0JSPTIsYS5GRS5LRVlDT0RFPXtCQUNLU1BBQ0U6OCxUQUI6OSxFTlRFUjoxMyxTSElGVDoxNixDVFJMOjE3LEFMVDoxOCxFU0M6MjcsU1BBQ0U6MzIsREVMRVRFOjQ2LFpFUk86NDgsT05FOjQ5LFRXTzo1MCxUSFJFRTo1MSxGT1VSOjUyLEZJVkU6NTMsU0lYOjU0LFNFVkVOOjU1LEVJR0hUOjU2LE5JTkU6NTcsRkZfU0VNSUNPTE9OOjU5LEZGX0VRVUFMUzo2MSxRVUVTVElPTl9NQVJLOjYzLEE6NjUsQjo2NixDOjY3LEQ6NjgsRTo2OSxGOjcwLEc6NzEsSDo3MixJOjczLEo6NzQsSzo3NSxMOjc2LE06NzcsTjo3OCxPOjc5LFA6ODAsUTo4MSxSOjgyLFM6ODMsVDo4NCxVOjg1LFY6ODYsVzo4NyxYOjg4LFk6ODksWjo5MCxNRVRBOjkxLE5VTV9aRVJPOjk2LE5VTV9PTkU6OTcsTlVNX1RXTzo5OCxOVU1fVEhSRUU6OTksTlVNX0ZPVVI6MTAwLE5VTV9GSVZFOjEwMSxOVU1fU0lYOjEwMixOVU1fU0VWRU46MTAzLE5VTV9FSUdIVDoxMDQsTlVNX05JTkU6MTA1LE5VTV9NVUxUSVBMWToxMDYsTlVNX1BMVVM6MTA3LE5VTV9NSU5VUzoxMDksTlVNX1BFUklPRDoxMTAsTlVNX0RJVklTSU9OOjExMSxTRU1JQ09MT046MTg2LERBU0g6MTg5LEVRVUFMUzoxODcsQ09NTUE6MTg4LFBFUklPRDoxOTAsU0xBU0g6MTkxLEFQT1NUUk9QSEU6MTkyLFRJTERFOjE5MixTSU5HTEVfUVVPVEU6MjIyLE9QRU5fU1FVQVJFX0JSQUNLRVQ6MjE5LEJBQ0tTTEFTSDoyMjAsQ0xPU0VfU1FVQVJFX0JSQUNLRVQ6MjIxfSxhLmV4dGVuZChhLkZFLkRFRkFVTFRTLHtlbnRlcjphLkZFLkVOVEVSX1AsbXVsdGlMaW5lOiEwLHRhYlNwYWNlczowfSksYS5GRS5NT0RVTEVTLmtleXM9ZnVuY3Rpb24oYil7ZnVuY3Rpb24gYygpe2lmKGIuaGVscGVycy5pc0lPUygpKXt2YXIgYz1uYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKFxcXCJDcmlPU1xcXCIpLGQ9LyhpUGhvbmV8aVBvZHxpUGFkKS4qQXBwbGVXZWJLaXQoPyEuKlNhZmFyaSkvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO2lmKCFjJiYhZCl7dmFyIGU9YShiLm9fd2luKS5zY3JvbGxUb3AoKTtiLmV2ZW50cy5kaXNhYmxlQmx1cigpLGIuc2VsZWN0aW9uLnNhdmUoKSxiLiRlbC5ibHVyKCksYi5zZWxlY3Rpb24ucmVzdG9yZSgpLGIuZXZlbnRzLmVuYWJsZUJsdXIoKSxhKGIub193aW4pLnNjcm9sbFRvcChlKX19fWZ1bmN0aW9uIGQoYSl7YS5wcmV2ZW50RGVmYXVsdCgpLGEuc3RvcFByb3BhZ2F0aW9uKCksYi5vcHRzLm11bHRpTGluZSYmKGIuc2VsZWN0aW9uLmlzQ29sbGFwc2VkKCl8fGIuc2VsZWN0aW9uLnJlbW92ZSgpLGIuY3Vyc29yLmVudGVyKCkpLGMoKX1mdW5jdGlvbiBlKGEpe2EucHJldmVudERlZmF1bHQoKSxhLnN0b3BQcm9wYWdhdGlvbigpLGIub3B0cy5tdWx0aUxpbmUmJihiLnNlbGVjdGlvbi5pc0NvbGxhcHNlZCgpfHxiLnNlbGVjdGlvbi5yZW1vdmUoKSxiLmN1cnNvci5lbnRlcighMCkpfWZ1bmN0aW9uIGYoYSl7Yi5zZWxlY3Rpb24uaXNDb2xsYXBzZWQoKT9iLmN1cnNvci5iYWNrc3BhY2UoKXx8KGEucHJldmVudERlZmF1bHQoKSxhLnN0b3BQcm9wYWdhdGlvbigpLHg9ITEpOihhLnByZXZlbnREZWZhdWx0KCksYS5zdG9wUHJvcGFnYXRpb24oKSxiLnNlbGVjdGlvbi5yZW1vdmUoKSxiLmh0bWwuZmlsbEVtcHR5QmxvY2tzKCkseD0hMSksYi5wbGFjZWhvbGRlci5yZWZyZXNoKCl9ZnVuY3Rpb24gZyhhKXthLnByZXZlbnREZWZhdWx0KCksYS5zdG9wUHJvcGFnYXRpb24oKSxcXFwiXFxcIj09PWIuc2VsZWN0aW9uLnRleHQoKT9iLmN1cnNvci5kZWwoKTpiLnNlbGVjdGlvbi5yZW1vdmUoKSxiLnBsYWNlaG9sZGVyLnJlZnJlc2goKX1mdW5jdGlvbiBoKGMpe2lmKGIuYnJvd3Nlci5tb3ppbGxhKXtjLnByZXZlbnREZWZhdWx0KCksYy5zdG9wUHJvcGFnYXRpb24oKSxiLnNlbGVjdGlvbi5pc0NvbGxhcHNlZCgpfHxiLnNlbGVjdGlvbi5yZW1vdmUoKSxiLm1hcmtlcnMuaW5zZXJ0KCk7dmFyIGQ9Yi4kZWwuZmluZChcXFwiLmZyLW1hcmtlclxcXCIpLmdldCgwKSxlPWQucHJldmlvdXNTaWJsaW5nLGY9ZC5uZXh0U2libGluZzshZiYmZC5wYXJlbnROb2RlJiZcXFwiQVxcXCI9PWQucGFyZW50Tm9kZS50YWdOYW1lPyhhKGQpLnBhcmVudCgpLmFmdGVyKFxcXCImbmJzcDtcXFwiK2EuRkUuTUFSS0VSUyksYShkKS5yZW1vdmUoKSk6KGUmJmUubm9kZVR5cGU9PU5vZGUuVEVYVF9OT0RFJiYxPT1lLnRleHRDb250ZW50Lmxlbmd0aCYmMTYwPT1lLnRleHRDb250ZW50LmNoYXJDb2RlQXQoMCk/YShlKS5hZnRlcihcXFwiIFxcXCIpOmEoZCkuYmVmb3JlKFxcXCImbmJzcDtcXFwiKSxhKGQpLnJlcGxhY2VXaXRoKGEuRkUuTUFSS0VSUykpLGIuc2VsZWN0aW9uLnJlc3RvcmUoKX19ZnVuY3Rpb24gaSgpe2lmKGIuYnJvd3Nlci5tb3ppbGxhJiZiLnNlbGVjdGlvbi5pc0NvbGxhcHNlZCgpJiYhQSl7dmFyIGE9Yi5zZWxlY3Rpb24ucmFuZ2VzKDApLGM9YS5zdGFydENvbnRhaW5lcixkPWEuc3RhcnRPZmZzZXQ7YyYmYy5ub2RlVHlwZT09Tm9kZS5URVhUX05PREUmJmQ8PWMudGV4dENvbnRlbnQubGVuZ3RoJiZkPjAmJjMyPT1jLnRleHRDb250ZW50LmNoYXJDb2RlQXQoZC0xKSYmKGIuc2VsZWN0aW9uLnNhdmUoKSxiLnNwYWNlcy5ub3JtYWxpemUoKSxiLnNlbGVjdGlvbi5yZXN0b3JlKCkpfX1mdW5jdGlvbiBqKCl7Yi5zZWxlY3Rpb24uaXNGdWxsKCkmJnNldFRpbWVvdXQoZnVuY3Rpb24oKXt2YXIgYz1iLmh0bWwuZGVmYXVsdFRhZygpO2M/Yi4kZWwuaHRtbChcXFwiPFxcXCIrYytcXFwiPlxcXCIrYS5GRS5NQVJLRVJTK1xcXCI8YnIvPjwvXFxcIitjK1xcXCI+XFxcIik6Yi4kZWwuaHRtbChhLkZFLk1BUktFUlMrXFxcIjxici8+XFxcIiksYi5zZWxlY3Rpb24ucmVzdG9yZSgpLGIucGxhY2Vob2xkZXIucmVmcmVzaCgpLGIuYnV0dG9uLmJ1bGtSZWZyZXNoKCksYi51bmRvLnNhdmVTdGVwKCl9LDApfWZ1bmN0aW9uIGsoYSl7aWYoYi5vcHRzLnRhYlNwYWNlcz4wKWlmKGIuc2VsZWN0aW9uLmlzQ29sbGFwc2VkKCkpe2IudW5kby5zYXZlU3RlcCgpLGEucHJldmVudERlZmF1bHQoKSxhLnN0b3BQcm9wYWdhdGlvbigpO2Zvcih2YXIgYz1cXFwiXFxcIixkPTA7ZDxiLm9wdHMudGFiU3BhY2VzO2QrKyljKz1cXFwiJm5ic3A7XFxcIjtiLmh0bWwuaW5zZXJ0KGMpLGIucGxhY2Vob2xkZXIucmVmcmVzaCgpLGIudW5kby5zYXZlU3RlcCgpfWVsc2UgYS5wcmV2ZW50RGVmYXVsdCgpLGEuc3RvcFByb3BhZ2F0aW9uKCksYS5zaGlmdEtleT9iLmNvbW1hbmRzLm91dGRlbnQoKTpiLmNvbW1hbmRzLmluZGVudCgpfWZ1bmN0aW9uIGwoYSl7QT0hMX1mdW5jdGlvbiBtKCl7cmV0dXJuIEF9ZnVuY3Rpb24gbihjKXtiLmV2ZW50cy5kaXNhYmxlQmx1cigpLHg9ITA7dmFyIGk9Yy53aGljaDtpZigxNj09PWkpcmV0dXJuITA7aWYoMjI5PT09aSlyZXR1cm4gQT0hMCwhMDtBPSExO3ZhciBqPXMoaSkmJiFyKGMpLGw9aT09YS5GRS5LRVlDT0RFLkJBQ0tTUEFDRXx8aT09YS5GRS5LRVlDT0RFLkRFTEVURTtpZigoYi5zZWxlY3Rpb24uaXNGdWxsKCkmJiFiLm9wdHMua2VlcEZvcm1hdE9uRGVsZXRlJiYhYi5wbGFjZWhvbGRlci5pc1Zpc2libGUoKXx8bCYmYi5wbGFjZWhvbGRlci5pc1Zpc2libGUoKSYmYi5vcHRzLmtlZXBGb3JtYXRPbkRlbGV0ZSkmJihqfHxsKSl7dmFyIG09Yi5odG1sLmRlZmF1bHRUYWcoKTtpZihtP2IuJGVsLmh0bWwoXFxcIjxcXFwiK20rXFxcIj5cXFwiK2EuRkUuTUFSS0VSUytcXFwiPGJyLz48L1xcXCIrbStcXFwiPlxcXCIpOmIuJGVsLmh0bWwoYS5GRS5NQVJLRVJTK1xcXCI8YnIvPlxcXCIpLGIuc2VsZWN0aW9uLnJlc3RvcmUoKSwhcyhpKSlyZXR1cm4gYy5wcmV2ZW50RGVmYXVsdCgpLCEwfWk9PWEuRkUuS0VZQ09ERS5FTlRFUj9jLnNoaWZ0S2V5P2UoYyk6ZChjKTppIT1hLkZFLktFWUNPREUuQkFDS1NQQUNFfHxyKGMpfHxjLmFsdEtleXx8Yi5wbGFjZWhvbGRlci5pc1Zpc2libGUoKT9pIT1hLkZFLktFWUNPREUuREVMRVRFfHxyKGMpfHxjLmFsdEtleXx8Yi5wbGFjZWhvbGRlci5pc1Zpc2libGUoKT9pPT1hLkZFLktFWUNPREUuU1BBQ0U/aChjKTppPT1hLkZFLktFWUNPREUuVEFCP2soYyk6cihjKXx8IXMoYy53aGljaCl8fGIuc2VsZWN0aW9uLmlzQ29sbGFwc2VkKCl8fGMuY3RybEtleXx8Yi5zZWxlY3Rpb24ucmVtb3ZlKCk6ZyhjKTpmKGMpLGIuZXZlbnRzLmVuYWJsZUJsdXIoKX1mdW5jdGlvbiBvKGMpe2Zvcih2YXIgZD0wO2Q8Yy5sZW5ndGg7ZCsrKWNbZF0ubm9kZVR5cGU9PU5vZGUuVEVYVF9OT0RFJiYvXFxcXHUyMDBCL2dpLnRlc3QoY1tkXS50ZXh0Q29udGVudCk/KGNbZF0udGV4dENvbnRlbnQ9Y1tkXS50ZXh0Q29udGVudC5yZXBsYWNlKC9cXFxcdTIwMEIvZ2ksXFxcIlxcXCIpLDA9PT1jW2RdLnRleHRDb250ZW50Lmxlbmd0aCYmYShjW2RdKS5yZW1vdmUoKSk6Y1tkXS5ub2RlVHlwZT09Tm9kZS5FTEVNRU5UX05PREUmJlxcXCJJRlJBTUVcXFwiIT1jW2RdLm5vZGVUeXBlJiZvKGIubm9kZS5jb250ZW50cyhjW2RdKSl9ZnVuY3Rpb24gcCgpe2lmKCFiLiR3cClyZXR1cm4hMDt2YXIgYztiLm9wdHMuaGVpZ2h0fHxiLm9wdHMuaGVpZ2h0TWF4PyhjPWIucG9zaXRpb24uZ2V0Qm91bmRpbmdSZWN0KCkudG9wLGIuaGVscGVycy5pc0lPUygpJiYoYy09YShiLm9fd2luKS5zY3JvbGxUb3AoKSksYi5vcHRzLmlmcmFtZSYmKGMrPWIuJGlmcmFtZS5vZmZzZXQoKS50b3ApLGM+Yi4kd3Aub2Zmc2V0KCkudG9wLWEoYi5vX3dpbikuc2Nyb2xsVG9wKCkrYi4kd3AuaGVpZ2h0KCktMjAmJmIuJHdwLnNjcm9sbFRvcChjK2IuJHdwLnNjcm9sbFRvcCgpLShiLiR3cC5oZWlnaHQoKStiLiR3cC5vZmZzZXQoKS50b3ApK2EoYi5vX3dpbikuc2Nyb2xsVG9wKCkrMjApKTooYz1iLnBvc2l0aW9uLmdldEJvdW5kaW5nUmVjdCgpLnRvcCxiLm9wdHMudG9vbGJhckJvdHRvbSYmKGMrPWIub3B0cy50b29sYmFyU3RpY2t5T2Zmc2V0KSxiLmhlbHBlcnMuaXNJT1MoKSYmKGMtPWEoYi5vX3dpbikuc2Nyb2xsVG9wKCkpLGIub3B0cy5pZnJhbWUmJihjKz1iLiRpZnJhbWUub2Zmc2V0KCkudG9wKSxjKz1iLm9wdHMudG9vbGJhclN0aWNreU9mZnNldCxjPmIub193aW4uaW5uZXJIZWlnaHQtMjAmJmEoYi5vX3dpbikuc2Nyb2xsVG9wKGMrYShiLm9fd2luKS5zY3JvbGxUb3AoKS1iLm9fd2luLmlubmVySGVpZ2h0KzIwKSxjPWIucG9zaXRpb24uZ2V0Qm91bmRpbmdSZWN0KCkudG9wLGIub3B0cy50b29sYmFyQm90dG9tfHwoYy09Yi5vcHRzLnRvb2xiYXJTdGlja3lPZmZzZXQpLGIuaGVscGVycy5pc0lPUygpJiYoYy09YShiLm9fd2luKS5zY3JvbGxUb3AoKSksYi5vcHRzLmlmcmFtZSYmKGMrPWIuJGlmcmFtZS5vZmZzZXQoKS50b3ApLGM8Yi4kdGIuaGVpZ2h0KCkrMjAmJmEoYi5vX3dpbikuc2Nyb2xsVG9wKGMrYShiLm9fd2luKS5zY3JvbGxUb3AoKS1iLiR0Yi5oZWlnaHQoKS0yMCkpfWZ1bmN0aW9uIHEoYyl7aWYoQSlyZXR1cm4hMTtpZighYi5zZWxlY3Rpb24uaXNDb2xsYXBzZWQoKSlyZXR1cm4hMDtpZihjJiYoYy53aGljaD09PWEuRkUuS0VZQ09ERS5NRVRBfHxjLndoaWNoPT1hLkZFLktFWUNPREUuQ1RSTCkpcmV0dXJuITA7YyYmKGMud2hpY2g9PWEuRkUuS0VZQ09ERS5FTlRFUnx8Yy53aGljaD09YS5GRS5LRVlDT0RFLkJBQ0tTUEFDRXx8Yy53aGljaD49MzcmJmMud2hpY2g8PTQwJiYhYi5icm93c2VyLm1zaWUpJiYoYy53aGljaD09YS5GRS5LRVlDT0RFLkJBQ0tTUEFDRSYmeHx8cCgpKTt2YXIgZD1iLiRlbC5maW5kKGIuaHRtbC5ibG9ja1RhZ3NRdWVyeSgpKTtkLnB1c2goYi4kZWwuZ2V0KDApKTtmb3IodmFyIGU9W10sZj0wO2Y8ZC5sZW5ndGg7ZisrKWlmKFtcXFwiVERcXFwiLFxcXCJUSFxcXCJdLmluZGV4T2YoZFtmXS50YWdOYW1lKTwwKWZvcih2YXIgZz1kW2ZdLmNoaWxkcmVuLGg9MDtoPGcubGVuZ3RoO2grKylcXFwiQlJcXFwiPT1nW2hdLnRhZ05hbWUmJmUucHVzaChnW2hdKTtmb3IodmFyIGQ9W10sZj0wO2Y8ZS5sZW5ndGg7ZisrKXt2YXIgaT1lW2ZdLGo9aS5wcmV2aW91c1NpYmxpbmcsaz1pLm5leHRTaWJsaW5nLGw9Yi5ub2RlLmJsb2NrUGFyZW50KGkpfHxiLiRlbC5nZXQoMCk7aiYmbCYmXFxcIkJSXFxcIiE9ai50YWdOYW1lJiYhYi5ub2RlLmlzQmxvY2soaikmJiFrJiZhKGwpLnRleHQoKS5yZXBsYWNlKC9cXFxcdTIwMEIvZyxcXFwiXFxcIikubGVuZ3RoPjAmJmEoaikudGV4dCgpLmxlbmd0aD4wJiYoYi4kZWwuaXMobCkmJiFrJiZiLm9wdHMuZW50ZXI9PWEuRkUuRU5URVJfQlImJmIuYnJvd3Nlci5tc2llfHwoYi5zZWxlY3Rpb24uc2F2ZSgpLGEoaSkucmVtb3ZlKCksYi5zZWxlY3Rpb24ucmVzdG9yZSgpKSl9ZT1bXTt2YXIgbT1mdW5jdGlvbihiKXtpZighYilyZXR1cm4hMTt2YXIgYz1hKGIpLmh0bWwoKTtyZXR1cm4gYz1jLnJlcGxhY2UoLzxzcGFuW14+XSo/IGNsYXNzXFxcXHMqPVxcXFxzKltcXFwiJ10/ZnItbWFya2VyW1xcXCInXT9bXj5dKz5cXFxcdTIwMGI8XFxcXC9zcGFuPi9naSxcXFwiXFxcIiksYyYmL1xcXFx1MjAwQi8udGVzdChjKSYmYy5yZXBsYWNlKC9cXFxcdTIwMEIvZ2ksXFxcIlxcXCIpLmxlbmd0aD4wPyEwOiExfSxuPWZ1bmN0aW9uKGEpe3ZhciBjPS9bXFxcXHUzMDQxLVxcXFx1MzA5NlxcXFx1MzBBMC1cXFxcdTMwRkZcXFxcdTRFMDAtXFxcXHU5RkZGXFxcXHUzMTMwLVxcXFx1MzE4RlxcXFx1QUMwMC1cXFxcdUQ3QUZdL2dpO3JldHVybiFiLmhlbHBlcnMuaXNJT1MoKXx8MD09PSgoYS50ZXh0Q29udGVudHx8XFxcIlxcXCIpLm1hdGNoKGMpfHxbXSkubGVuZ3RofSxxPWIuc2VsZWN0aW9uLmVsZW1lbnQoKTttKHEpJiYwPT09YShxKS5maW5kKFxcXCJsaVxcXCIpLmxlbmd0aCYmIWEocSkuaGFzQ2xhc3MoXFxcImZyLW1hcmtlclxcXCIpJiZcXFwiSUZSQU1FXFxcIiE9cS50YWdOYW1lJiZuKHEpJiYoYi5zZWxlY3Rpb24uc2F2ZSgpLG8oYi5ub2RlLmNvbnRlbnRzKHEpKSxiLnNlbGVjdGlvbi5yZXN0b3JlKCkpLCFiLmJyb3dzZXIubW96aWxsYSYmYi5odG1sLmRvTm9ybWFsaXplKCkmJihiLnNlbGVjdGlvbi5zYXZlKCksYi5zcGFjZXMubm9ybWFsaXplKCksYi5zZWxlY3Rpb24ucmVzdG9yZSgpKX1mdW5jdGlvbiByKGEpe2lmKC0xIT1uYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoXFxcIk1hYyBPUyBYXFxcIikpe2lmKGEubWV0YUtleSYmIWEuYWx0S2V5KXJldHVybiEwfWVsc2UgaWYoYS5jdHJsS2V5JiYhYS5hbHRLZXkpcmV0dXJuITA7cmV0dXJuITF9ZnVuY3Rpb24gcyhjKXtpZihjPj1hLkZFLktFWUNPREUuWkVSTyYmYzw9YS5GRS5LRVlDT0RFLk5JTkUpcmV0dXJuITA7aWYoYz49YS5GRS5LRVlDT0RFLk5VTV9aRVJPJiZjPD1hLkZFLktFWUNPREUuTlVNX01VTFRJUExZKXJldHVybiEwO2lmKGM+PWEuRkUuS0VZQ09ERS5BJiZjPD1hLkZFLktFWUNPREUuWilyZXR1cm4hMDtpZihiLmJyb3dzZXIud2Via2l0JiYwPT09YylyZXR1cm4hMDtzd2l0Y2goYyl7Y2FzZSBhLkZFLktFWUNPREUuU1BBQ0U6Y2FzZSBhLkZFLktFWUNPREUuUVVFU1RJT05fTUFSSzpjYXNlIGEuRkUuS0VZQ09ERS5OVU1fUExVUzpjYXNlIGEuRkUuS0VZQ09ERS5OVU1fTUlOVVM6Y2FzZSBhLkZFLktFWUNPREUuTlVNX1BFUklPRDpjYXNlIGEuRkUuS0VZQ09ERS5OVU1fRElWSVNJT046Y2FzZSBhLkZFLktFWUNPREUuU0VNSUNPTE9OOmNhc2UgYS5GRS5LRVlDT0RFLkZGX1NFTUlDT0xPTjpjYXNlIGEuRkUuS0VZQ09ERS5EQVNIOmNhc2UgYS5GRS5LRVlDT0RFLkVRVUFMUzpjYXNlIGEuRkUuS0VZQ09ERS5GRl9FUVVBTFM6Y2FzZSBhLkZFLktFWUNPREUuQ09NTUE6Y2FzZSBhLkZFLktFWUNPREUuUEVSSU9EOmNhc2UgYS5GRS5LRVlDT0RFLlNMQVNIOmNhc2UgYS5GRS5LRVlDT0RFLkFQT1NUUk9QSEU6Y2FzZSBhLkZFLktFWUNPREUuU0lOR0xFX1FVT1RFOmNhc2UgYS5GRS5LRVlDT0RFLk9QRU5fU1FVQVJFX0JSQUNLRVQ6Y2FzZSBhLkZFLktFWUNPREUuQkFDS1NMQVNIOmNhc2UgYS5GRS5LRVlDT0RFLkNMT1NFX1NRVUFSRV9CUkFDS0VUOnJldHVybiEwO2RlZmF1bHQ6cmV0dXJuITF9fWZ1bmN0aW9uIHQoYyl7dmFyIGQ9Yy53aGljaDtyZXR1cm4gcihjKXx8ZD49MzcmJjQwPj1kfHwhcyhkKSYmZCE9YS5GRS5LRVlDT0RFLkRFTEVURSYmZCE9YS5GRS5LRVlDT0RFLkJBQ0tTUEFDRSYmZCE9YS5GRS5LRVlDT0RFLkVOVEVSPyEwOih5fHwoej1iLnNuYXBzaG90LmdldCgpKSxjbGVhclRpbWVvdXQoeSksdm9pZCh5PXNldFRpbWVvdXQoZnVuY3Rpb24oKXt5PW51bGwsYi51bmRvLnNhdmVTdGVwKCl9LE1hdGgubWF4KDI1MCxiLm9wdHMudHlwaW5nVGltZXIpKSkpfWZ1bmN0aW9uIHUoYSl7cmV0dXJuIHIoYSk/ITA6dm9pZCh6JiZ5JiYoYi51bmRvLnNhdmVTdGVwKHopLHo9bnVsbCkpfWZ1bmN0aW9uIHYoKXt5JiYoY2xlYXJUaW1lb3V0KHkpLGIudW5kby5zYXZlU3RlcCgpLHo9bnVsbCl9ZnVuY3Rpb24gdygpe2lmKGIuZXZlbnRzLm9uKFxcXCJrZXlkb3duXFxcIix0KSxiLmV2ZW50cy5vbihcXFwiaW5wdXRcXFwiLGkpLGIuZXZlbnRzLm9uKFxcXCJrZXl1cFxcXCIsdSksYi5ldmVudHMub24oXFxcImtleXByZXNzXFxcIixsKSxiLmV2ZW50cy5vbihcXFwia2V5ZG93blxcXCIsbiksYi5ldmVudHMub24oXFxcImtleXVwXFxcIixxKSxiLmV2ZW50cy5vbihcXFwiaHRtbC5pbnNlcnRlZFxcXCIscSksYi5ldmVudHMub24oXFxcImN1dFxcXCIsaiksYi4kZWwuZ2V0KDApLm1zR2V0SW5wdXRDb250ZXh0KXRyeXtiLiRlbC5nZXQoMCkubXNHZXRJbnB1dENvbnRleHQoKS5hZGRFdmVudExpc3RlbmVyKFxcXCJNU0NhbmRpZGF0ZVdpbmRvd1Nob3dcXFwiLGZ1bmN0aW9uKCl7QT0hMH0pLGIuJGVsLmdldCgwKS5tc0dldElucHV0Q29udGV4dCgpLmFkZEV2ZW50TGlzdGVuZXIoXFxcIk1TQ2FuZGlkYXRlV2luZG93SGlkZVxcXCIsZnVuY3Rpb24oKXtBPSExLHEoKX0pfWNhdGNoKGEpe319dmFyIHgseSx6LEE9ITE7cmV0dXJue19pbml0OncsY3RybEtleTpyLGlzQ2hhcmFjdGVyOnMsZm9yY2VVbmRvOnYsaXNJTUU6bX19LGEuZXh0ZW5kKGEuRkUuREVGQVVMVFMse3Bhc3RlUGxhaW46ITEscGFzdGVEZW5pZWRUYWdzOltcXFwiY29sZ3JvdXBcXFwiLFxcXCJjb2xcXFwiXSxwYXN0ZURlbmllZEF0dHJzOltcXFwiY2xhc3NcXFwiLFxcXCJpZFxcXCIsXFxcInN0eWxlXFxcIl0scGFzdGVBbGxvd0xvY2FsSW1hZ2VzOiExfSksYS5GRS5NT0RVTEVTLnBhc3RlPWZ1bmN0aW9uKGIpe2Z1bmN0aW9uIGMoYyl7YS5GRS5jb3BpZWRfaHRtbD1iLmh0bWwuZ2V0U2VsZWN0ZWQoKSxhLkZFLmNvcGllZF90ZXh0PWEoXFxcIjxkaXY+XFxcIikuaHRtbChhLkZFLmNvcGllZF9odG1sKS50ZXh0KCksXFxcImN1dFxcXCI9PWMudHlwZSYmKGIudW5kby5zYXZlU3RlcCgpLHNldFRpbWVvdXQoZnVuY3Rpb24oKXtiLmh0bWwud3JhcCgpLGIuZXZlbnRzLmZvY3VzKCksYi51bmRvLnNhdmVTdGVwKCl9LDApKX1mdW5jdGlvbiBkKGEpe2lmKG8pcmV0dXJuITE7aWYoYS5vcmlnaW5hbEV2ZW50JiYoYT1hLm9yaWdpbmFsRXZlbnQpLGIuZXZlbnRzLnRyaWdnZXIoXFxcInBhc3RlLmJlZm9yZVxcXCIsW2FdKT09PSExKXJldHVybiExO2lmKGw9Yi4kd2luLnNjcm9sbFRvcCgpLGEmJmEuY2xpcGJvYXJkRGF0YSYmYS5jbGlwYm9hcmREYXRhLmdldERhdGEpe3ZhciBjPVxcXCJcXFwiLGQ9YS5jbGlwYm9hcmREYXRhLnR5cGVzO2lmKGIuaGVscGVycy5pc0FycmF5KGQpKWZvcih2YXIgZj0wO2Y8ZC5sZW5ndGg7ZisrKWMrPWRbZl0rXFxcIjtcXFwiO2Vsc2UgYz1kO2lmKG09XFxcIlxcXCIsL3RleHRcXFxcL2h0bWwvLnRlc3QoYyk/bT1hLmNsaXBib2FyZERhdGEuZ2V0RGF0YShcXFwidGV4dC9odG1sXFxcIik6L3RleHRcXFxcL3J0Zi8udGVzdChjKSYmYi5icm93c2VyLnNhZmFyaT9tPWEuY2xpcGJvYXJkRGF0YS5nZXREYXRhKFxcXCJ0ZXh0L3J0ZlxcXCIpOi90ZXh0XFxcXC9wbGFpbi8udGVzdChjKSYmIXRoaXMuYnJvd3Nlci5tb3ppbGxhJiYobT1iLmh0bWwuZXNjYXBlRW50aXRpZXMoYS5jbGlwYm9hcmREYXRhLmdldERhdGEoXFxcInRleHQvcGxhaW5cXFwiKSkucmVwbGFjZSgvXFxcXG4vZyxcXFwiPGJyPlxcXCIpKSxcXFwiXFxcIiE9PW0pcmV0dXJuIGgoKSxhLnByZXZlbnREZWZhdWx0JiYoYS5zdG9wUHJvcGFnYXRpb24oKSxhLnByZXZlbnREZWZhdWx0KCkpLCExO209bnVsbH1lKCl9ZnVuY3Rpb24gZSgpe2Iuc2VsZWN0aW9uLnNhdmUoKSxiLmV2ZW50cy5kaXNhYmxlQmx1cigpLG09bnVsbCxuP24uaHRtbChcXFwiXFxcIik6KG49YSgnPGRpdiBjb250ZW50ZWRpdGFibGU9XFxcInRydWVcXFwiIHN0eWxlPVxcXCJwb3NpdGlvbjogZml4ZWQ7IHRvcDogMDsgbGVmdDogLTk5OTlweDsgaGVpZ2h0OiAxMDAlOyB3aWR0aDogMDsgd29yZC1icmVhazogYnJlYWstYWxsOyBvdmVyZmxvdzpoaWRkZW47IHotaW5kZXg6IDk5OTk7IGxpbmUtaGVpZ2h0OiAxNDAlO1xcXCIgdGFiaW5kZXg9XFxcIi0xXFxcIj48L2Rpdj4nKSxiLiRib3guYWZ0ZXIobiksYi5ldmVudHMub24oXFxcImRlc3Ryb3lcXFwiLGZ1bmN0aW9uKCl7bi5yZW1vdmUoKX0pKSxuLmZvY3VzKCksYi53aW4uc2V0VGltZW91dChoLDEpfWZ1bmN0aW9uIGYoYyl7Yz1jLnJlcGxhY2UoLzxwKC4qPyljbGFzcz1cXFwiPyc/TXNvTGlzdFBhcmFncmFwaFxcXCI/Jz8gKFtcXFxcc1xcXFxTXSo/KT4oW1xcXFxzXFxcXFNdKj8pPFxcXFwvcD4vZ2ksXFxcIjx1bD48bGk+JDM8L2xpPjwvdWw+XFxcIiksYz1jLnJlcGxhY2UoLzxwKC4qPyljbGFzcz1cXFwiPyc/TnVtYmVyZWRUZXh0XFxcIj8nPyAoW1xcXFxzXFxcXFNdKj8pPihbXFxcXHNcXFxcU10qPyk8XFxcXC9wPi9naSxcXFwiPG9sPjxsaT4kMzwvbGk+PC9vbD5cXFwiKSxjPWMucmVwbGFjZSgvPHAoLio/KWNsYXNzPVxcXCI/Jz9Nc29MaXN0UGFyYWdyYXBoQ3hTcEZpcnN0XFxcIj8nPyhbXFxcXHNcXFxcU10qPykobGV2ZWxcXFxcZCk/KFtcXFxcc1xcXFxTXSo/KT4oW1xcXFxzXFxcXFNdKj8pPFxcXFwvcD4vZ2ksXFxcIjx1bD48bGkkMz4kNTwvbGk+XFxcIiksYz1jLnJlcGxhY2UoLzxwKC4qPyljbGFzcz1cXFwiPyc/TnVtYmVyZWRUZXh0Q3hTcEZpcnN0XFxcIj8nPyhbXFxcXHNcXFxcU10qPykobGV2ZWxcXFxcZCk/KFtcXFxcc1xcXFxTXSo/KT4oW1xcXFxzXFxcXFNdKj8pPFxcXFwvcD4vZ2ksXFxcIjxvbD48bGkkMz4kNTwvbGk+XFxcIiksYz1jLnJlcGxhY2UoLzxwKC4qPyljbGFzcz1cXFwiPyc/TXNvTGlzdFBhcmFncmFwaEN4U3BNaWRkbGVcXFwiPyc/KFtcXFxcc1xcXFxTXSo/KShsZXZlbFxcXFxkKT8oW1xcXFxzXFxcXFNdKj8pPihbXFxcXHNcXFxcU10qPyk8XFxcXC9wPi9naSxcXFwiPGxpJDM+JDU8L2xpPlxcXCIpLGM9Yy5yZXBsYWNlKC88cCguKj8pY2xhc3M9XFxcIj8nP051bWJlcmVkVGV4dEN4U3BNaWRkbGVcXFwiPyc/KFtcXFxcc1xcXFxTXSo/KShsZXZlbFxcXFxkKT8oW1xcXFxzXFxcXFNdKj8pPihbXFxcXHNcXFxcU10qPyk8XFxcXC9wPi9naSxcXFwiPGxpJDM+JDU8L2xpPlxcXCIpLGM9Yy5yZXBsYWNlKC88cCguKj8pY2xhc3M9XFxcIj8nP01zb0xpc3RCdWxsZXRcXFwiPyc/KFtcXFxcc1xcXFxTXSo/KShsZXZlbFxcXFxkKT8oW1xcXFxzXFxcXFNdKj8pPihbXFxcXHNcXFxcU10qPyk8XFxcXC9wPi9naSxcXFwiPGxpJDM+JDU8L2xpPlxcXCIpLGM9Yy5yZXBsYWNlKC88cCguKj8pY2xhc3M9XFxcIj8nP01zb0xpc3RQYXJhZ3JhcGhDeFNwTGFzdFxcXCI/Jz8oW1xcXFxzXFxcXFNdKj8pKGxldmVsXFxcXGQpPyhbXFxcXHNcXFxcU10qPyk+KFtcXFxcc1xcXFxTXSo/KTxcXFxcL3A+L2dpLFxcXCI8bGkkMz4kNTwvbGk+PC91bD5cXFwiKSxjPWMucmVwbGFjZSgvPHAoLio/KWNsYXNzPVxcXCI/Jz9OdW1iZXJlZFRleHRDeFNwTGFzdFxcXCI/Jz8oW1xcXFxzXFxcXFNdKj8pKGxldmVsXFxcXGQpPyhbXFxcXHNcXFxcU10qPyk+KFtcXFxcc1xcXFxTXSo/KTxcXFxcL3A+L2dpLFxcXCI8bGkkMz4kNTwvbGk+PC9vbD5cXFwiKSxjPWMucmVwbGFjZSgvPHNwYW4oW148XSo/KXN0eWxlPVxcXCI/Jz9tc28tbGlzdDpJZ25vcmVcXFwiPyc/KFtcXFxcc1xcXFxTXSo/KT4oW1xcXFxzXFxcXFNdKj8pPHNwYW4vZ2ksXFxcIjxzcGFuPjxzcGFuXFxcIiksYz1jLnJlcGxhY2UoLzwhLS1cXFxcW2lmIFxcXFwhc3VwcG9ydExpc3RzXFxcXF0tLT4oW1xcXFxzXFxcXFNdKj8pPCEtLVxcXFxbZW5kaWZcXFxcXS0tPi9naSxcXFwiXFxcIiksYz1jLnJlcGxhY2UoLzwhXFxcXFtpZiBcXFxcIXN1cHBvcnRMaXN0c1xcXFxdPihbXFxcXHNcXFxcU10qPyk8IVxcXFxbZW5kaWZcXFxcXT4vZ2ksXFxcIlxcXCIpLGM9Yy5yZXBsYWNlKC8oXFxcXG58XFxcXHJ8IGNsYXNzPShcXFwiKT9Nc29bYS16QS1aMC05XSsoXFxcIik/KS9naSxcXFwiIFxcXCIpLGM9Yy5yZXBsYWNlKC88IS0tW1xcXFxzXFxcXFNdKj8tLT4vZ2ksXFxcIlxcXCIpLGM9Yy5yZXBsYWNlKC88KFxcXFwvKSoobWV0YXxsaW5rfHNwYW58XFxcXFxcXFw/eG1sOnxzdDE6fG86fGZvbnQpKC4qPyk+L2dpLFxcXCJcXFwiKTtmb3IodmFyIGQ9W1xcXCJzdHlsZVxcXCIsXFxcInNjcmlwdFxcXCIsXFxcImFwcGxldFxcXCIsXFxcImVtYmVkXFxcIixcXFwibm9mcmFtZXNcXFwiLFxcXCJub3NjcmlwdFxcXCJdLGU9MDtlPGQubGVuZ3RoO2UrKyl7dmFyIGY9bmV3IFJlZ0V4cChcXFwiPFxcXCIrZFtlXStcXFwiLio/XFxcIitkW2VdK1xcXCIoLio/KT5cXFwiLFxcXCJnaVxcXCIpO2M9Yy5yZXBsYWNlKGYsXFxcIlxcXCIpfWM9Yy5yZXBsYWNlKC8mbmJzcDsvZ2ksXFxcIiBcXFwiKSxjPWMucmVwbGFjZSgvPHRkKFtePl0qKT48XFxcXC90ZD4vZyxcXFwiPHRkJDE+PGJyPjwvdGQ+XFxcIiksYz1jLnJlcGxhY2UoLzx0aChbXj5dKik+PFxcXFwvdGg+L2csXFxcIjx0aCQxPjxicj48L3RoPlxcXCIpO3ZhciBnO2RvIGc9YyxjPWMucmVwbGFjZSgvPFteXFxcXC8+XVtePl0qPjxcXFxcL1tePl0rPi9naSxcXFwiXFxcIik7d2hpbGUoYyE9Zyk7Yz1jLnJlcGxhY2UoLzxsaWxldmVsKFteMV0pKFtePl0qKT4vZ2ksJzxsaSBkYXRhLWluZGVudD1cXFwidHJ1ZVxcXCIkMj4nKSxjPWMucmVwbGFjZSgvPGxpbGV2ZWwxKFtePl0qKT4vZ2ksXFxcIjxsaSQxPlxcXCIpLGM9Yi5jbGVhbi5odG1sKGMsYi5vcHRzLnBhc3RlRGVuaWVkVGFncyxiLm9wdHMucGFzdGVEZW5pZWRBdHRycyksYz1jLnJlcGxhY2UoLzxhPiguW148XSspPFxcXFwvYT4vZ2ksXFxcIiQxXFxcIiksYz1jLnJlcGxhY2UoLzxicj4gKi9nLFxcXCI8YnI+XFxcIik7dmFyIGg9YShcXFwiPGRpdj5cXFwiKS5odG1sKGMpO3JldHVybiBoLmZpbmQoXFxcImxpW2RhdGEtaW5kZW50XVxcXCIpLmVhY2goZnVuY3Rpb24oYixjKXt2YXIgZD1hKGMpO2lmKGQucHJldihcXFwibGlcXFwiKS5sZW5ndGg+MCl7dmFyIGU9ZC5wcmV2KFxcXCJsaVxcXCIpLmZpbmQoXFxcIj4gdWwsID4gb2xcXFwiKTswPT09ZS5sZW5ndGgmJihlPWEoXFxcInVsXFxcIiksZC5wcmV2KFxcXCJsaVxcXCIpLmFwcGVuZChlKSksZS5hcHBlbmQoYyl9ZWxzZSBkLnJlbW92ZUF0dHIoXFxcImRhdGEtaW5kZW50XFxcIil9KSxiLmh0bWwuY2xlYW5CbGFua1NwYWNlcyhoLmdldCgwKSksYz1oLmh0bWwoKX1mdW5jdGlvbiBnKGMpe3ZhciBkPWEoXFxcIjxkaXY+XFxcIikuaHRtbChjKTtkLmZpbmQoXFxcInAsIGRpdiwgaDEsIGgyLCBoMywgaDQsIGg1LCBoNiwgcHJlLCBibG9ja3F1b3RlXFxcIikuZWFjaChmdW5jdGlvbihjLGQpe2EoZCkucmVwbGFjZVdpdGgoXFxcIjxcXFwiKyhiLmh0bWwuZGVmYXVsdFRhZygpfHxcXFwiRElWXFxcIikrXFxcIj5cXFwiK2EoZCkuaHRtbCgpK1xcXCI8L1xcXCIrKGIuaHRtbC5kZWZhdWx0VGFnKCl8fFxcXCJESVZcXFwiKStcXFwiPlxcXCIpfSksYShkLmZpbmQoXFxcIipcXFwiKS5ub3QoXFxcInAsIGRpdiwgaDEsIGgyLCBoMywgaDQsIGg1LCBoNiwgcHJlLCBibG9ja3F1b3RlLCB1bCwgb2wsIGxpLCB0YWJsZSwgdGJvZHksIHRoZWFkLCB0ciwgdGQsIGJyLCBpbWdcXFwiKS5nZXQoKS5yZXZlcnNlKCkpLmVhY2goZnVuY3Rpb24oKXthKHRoaXMpLnJlcGxhY2VXaXRoKGEodGhpcykuaHRtbCgpKX0pO3ZhciBlPWZ1bmN0aW9uKGMpe2Zvcih2YXIgZD1iLm5vZGUuY29udGVudHMoYyksZj0wO2Y8ZC5sZW5ndGg7ZisrKTMhPWRbZl0ubm9kZVR5cGUmJjEhPWRbZl0ubm9kZVR5cGU/YShkW2ZdKS5yZW1vdmUoKTplKGRbZl0pfTtyZXR1cm4gZShkLmdldCgwKSksZC5odG1sKCl9ZnVuY3Rpb24gaCgpe2Iua2V5cy5mb3JjZVVuZG8oKTt2YXIgYz1iLnNuYXBzaG90LmdldCgpO251bGw9PT1tJiYobT1uLmh0bWwoKSxiLnNlbGVjdGlvbi5yZXN0b3JlKCksYi5ldmVudHMuZW5hYmxlQmx1cigpKTt2YXIgZD1iLmV2ZW50cy5jaGFpblRyaWdnZXIoXFxcInBhc3RlLmJlZm9yZUNsZWFudXBcXFwiLG0pO1xcXCJzdHJpbmdcXFwiPT10eXBlb2YgZCYmKG09ZCksbS5pbmRleE9mKFxcXCI8Ym9keVxcXCIpPj0wJiYobT1tLnJlcGxhY2UoL1suXFxcXHNcXFxcU1xcXFx3XFxcXFc8Pl0qPGJvZHlbXj5dKj4oWy5cXFxcc1xcXFxTXFxcXHdcXFxcVzw+XSopPFxcXFwvYm9keT5bLlxcXFxzXFxcXFNcXFxcd1xcXFxXPD5dKi9nLFxcXCIkMVxcXCIpKTt2YXIgZT0hMTtpZihtLmluZGV4T2YoJ2lkPVxcXCJkb2NzLWludGVybmFsLWd1aWQnKT49MCYmKG09bS5yZXBsYWNlKC9eLiogaWQ9XFxcImRvY3MtaW50ZXJuYWwtZ3VpZFtePl0qPiguKik8XFxcXC9iPi4qJC8sXFxcIiQxXFxcIiksZT0hMCksbS5tYXRjaCgvKGNsYXNzPVxcXFxcXFwiP01zb3xjbGFzcz1cXFxcJz9Nc298c3R5bGU9XFxcXFxcXCJbXlxcXFxcXFwiXSpcXFxcYm1zb1xcXFwtfHN0eWxlPVxcXFwnW15cXFxcJ10qXFxcXGJtc29cXFxcLXx3OldvcmREb2N1bWVudCkvZ2kpPyhtPW0ucmVwbGFjZSgvXlxcXFxuKi9nLFxcXCJcXFwiKS5yZXBsYWNlKC9eIC9nLFxcXCJcXFwiKSwwPT09bS5pbmRleE9mKFxcXCI8Y29sZ3JvdXA+XFxcIikmJihtPVxcXCI8dGFibGU+XFxcIittK1xcXCI8L3RhYmxlPlxcXCIpLG09ZihtKSxtPWoobSkpOihiLm9wdHMuaHRtbEFsbG93Q29tbWVudHM9ITEsbT1iLmNsZWFuLmh0bWwobSxiLm9wdHMucGFzdGVEZW5pZWRUYWdzLGIub3B0cy5wYXN0ZURlbmllZEF0dHJzKSxiLm9wdHMuaHRtbEFsbG93Q29tbWVudHM9ITAsbT1qKG0pLG09bS5yZXBsYWNlKC9cXFxccnxcXFxcbnxcXFxcdC9nLFxcXCJcXFwiKSxhLkZFLmNvcGllZF90ZXh0JiZhKFxcXCI8ZGl2PlxcXCIpLmh0bWwobSkudGV4dCgpLnJlcGxhY2UoLyhcXFxcdTAwQTApL2dpLFxcXCIgXFxcIikucmVwbGFjZSgvXFxcXHJ8XFxcXG4vZ2ksXFxcIlxcXCIpPT1hLkZFLmNvcGllZF90ZXh0LnJlcGxhY2UoLyhcXFxcdTAwQTApL2dpLFxcXCIgXFxcIikucmVwbGFjZSgvXFxcXHJ8XFxcXG4vZ2ksXFxcIlxcXCIpJiYobT1hLkZFLmNvcGllZF9odG1sKSxtPW0ucmVwbGFjZSgvXiAqL2csXFxcIlxcXCIpLnJlcGxhY2UoLyAqJC9nLFxcXCJcXFwiKSksYi5vcHRzLnBhc3RlUGxhaW4mJihtPWcobSkpLGQ9Yi5ldmVudHMuY2hhaW5UcmlnZ2VyKFxcXCJwYXN0ZS5hZnRlckNsZWFudXBcXFwiLG0pLFxcXCJzdHJpbmdcXFwiPT10eXBlb2YgZCYmKG09ZCksXFxcIlxcXCIhPT1tKXt2YXIgaD1hKFxcXCI8ZGl2PlxcXCIpLmh0bWwobSk7Yi5zcGFjZXMubm9ybWFsaXplKGguZ2V0KDApKSxoLmZpbmQoXFxcInNwYW5cXFwiKS5lYWNoKGZ1bmN0aW9uKCl7MD09dGhpcy5hdHRyaWJ1dGVzLmxlbmd0aCYmYSh0aGlzKS5yZXBsYWNlV2l0aCh0aGlzLmlubmVySFRNTCl9KSxlfHxoLmZpbmQoXFxcImJyXFxcIikuZWFjaChmdW5jdGlvbigpe3RoaXMucHJldmlvdXNTaWJsaW5nJiZiLm5vZGUuaXNCbG9jayh0aGlzLnByZXZpb3VzU2libGluZykmJmEodGhpcykucmVtb3ZlKCl9KSxtPWguaHRtbCgpLGIuaHRtbC5pbnNlcnQobSwhMCl9aSgpLGIudW5kby5zYXZlU3RlcChjKSxiLnVuZG8uc2F2ZVN0ZXAoKX1mdW5jdGlvbiBpKCl7Yi5ldmVudHMudHJpZ2dlcihcXFwicGFzdGUuYWZ0ZXJcXFwiKX1mdW5jdGlvbiBqKGMpe2Zvcih2YXIgZCxlPWEoXFxcIjxkaXY+XFxcIikuaHRtbChjKSxmPWUuZmluZChcXFwiKjplbXB0eTpub3QoYnIsIGltZywgdGQsIHRoKVxcXCIpO2YubGVuZ3RoOyl7Zm9yKGQ9MDtkPGYubGVuZ3RoO2QrKylhKGZbZF0pLnJlbW92ZSgpO2Y9ZS5maW5kKFxcXCIqOmVtcHR5Om5vdChiciwgaW1nLCB0ZCwgdGgpXFxcIil9Zm9yKHZhciBnPWUuZmluZChcXFwiPiBkaXY6bm90KFtzdHlsZV0pLCB0ZCA+IGRpdiwgdGggPiBkaXYsIGxpID4gZGl2XFxcIik7Zy5sZW5ndGgmJmQrKzwxMDA7KXt2YXIgaD1hKGdbZy5sZW5ndGgtMV0pO2IuaHRtbC5kZWZhdWx0VGFnKCkmJlxcXCJkaXZcXFwiIT1iLmh0bWwuZGVmYXVsdFRhZygpP2gucmVwbGFjZVdpdGgoXFxcIjxcXFwiK2IuaHRtbC5kZWZhdWx0VGFnKCkrXFxcIj5cXFwiK2guaHRtbCgpK1xcXCI8L1xcXCIrYi5odG1sLmRlZmF1bHRUYWcoKStcXFwiPlxcXCIpOmguZmluZChcXFwiKjpsYXN0XFxcIikuaXMoXFxcImJyXFxcIik/aC5yZXBsYWNlV2l0aChoLmh0bWwoKSk6aC5yZXBsYWNlV2l0aChoLmh0bWwoKStcXFwiPGJyPlxcXCIpLGc9ZS5maW5kKFxcXCI+IGRpdjpub3QoW3N0eWxlXSksIHRkID4gZGl2LCB0aCA+IGRpdiwgbGkgPiBkaXZcXFwiKX1mb3IoZz1lLmZpbmQoXFxcImRpdjpub3QoW3N0eWxlXSlcXFwiKTtnLmxlbmd0aDspe2ZvcihkPTA7ZDxnLmxlbmd0aDtkKyspe3ZhciBpPWEoZ1tkXSksaj1pLmh0bWwoKS5yZXBsYWNlKC9cXFxcdTAwMDkvZ2ksXFxcIlxcXCIpLnRyaW0oKTtpLnJlcGxhY2VXaXRoKGopfWc9ZS5maW5kKFxcXCJkaXY6bm90KFtzdHlsZV0pXFxcIil9cmV0dXJuIGUuaHRtbCgpfWZ1bmN0aW9uIGsoKXtiLmV2ZW50cy5vbihcXFwiY29weVxcXCIsYyksYi5ldmVudHMub24oXFxcImN1dFxcXCIsYyksYi5ldmVudHMub24oXFxcInBhc3RlXFxcIixkKSxiLmJyb3dzZXIubXNpZSYmYi5icm93c2VyLnZlcnNpb248MTEmJihiLmV2ZW50cy5vbihcXFwibW91c2V1cFxcXCIsZnVuY3Rpb24oYSl7Mj09YS5idXR0b24mJihzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7bz0hMX0sNTApLG89ITApfSwhMCksYi5ldmVudHMub24oXFxcImJlZm9yZXBhc3RlXFxcIixkKSl9dmFyIGwsbSxuLG89ITE7cmV0dXJue19pbml0Omt9fSxhLmV4dGVuZChhLkZFLkRFRkFVTFRTLHtzaG9ydGN1dHNFbmFibGVkOltcXFwic2hvd1xcXCIsXFxcImJvbGRcXFwiLFxcXCJpdGFsaWNcXFwiLFxcXCJ1bmRlcmxpbmVcXFwiLFxcXCJzdHJpa2VUaHJvdWdoXFxcIixcXFwiaW5kZW50XFxcIixcXFwib3V0ZGVudFxcXCIsXFxcInVuZG9cXFwiLFxcXCJyZWRvXFxcIl0sc2hvcnRjdXRzSGludDohMH0pLGEuRkUuU0hPUlRDVVRTX01BUD17fSxhLkZFLlJlZ2lzdGVyU2hvcnRjdXQ9ZnVuY3Rpb24oYixjLGQsZSxmLGcpe2EuRkUuU0hPUlRDVVRTX01BUFsoZj9cXFwiXlxcXCI6XFxcIlxcXCIpKyhnP1xcXCJAXFxcIjpcXFwiXFxcIikrYl09e2NtZDpjLHZhbDpkLGxldHRlcjplLHNoaWZ0OmYsb3B0aW9uOmd9LGEuRkUuREVGQVVMVFMuc2hvcnRjdXRzRW5hYmxlZC5wdXNoKGMpfSxhLkZFLlJlZ2lzdGVyU2hvcnRjdXQoYS5GRS5LRVlDT0RFLkUsXFxcInNob3dcXFwiLG51bGwsXFxcIkVcXFwiLCExLCExKSxhLkZFLlJlZ2lzdGVyU2hvcnRjdXQoYS5GRS5LRVlDT0RFLkIsXFxcImJvbGRcXFwiLG51bGwsXFxcIkJcXFwiLCExLCExKSxhLkZFLlJlZ2lzdGVyU2hvcnRjdXQoYS5GRS5LRVlDT0RFLkksXFxcIml0YWxpY1xcXCIsbnVsbCxcXFwiSVxcXCIsITEsITEpLGEuRkUuUmVnaXN0ZXJTaG9ydGN1dChhLkZFLktFWUNPREUuVSxcXFwidW5kZXJsaW5lXFxcIixudWxsLFxcXCJVXFxcIiwhMSwhMSksYS5GRS5SZWdpc3RlclNob3J0Y3V0KGEuRkUuS0VZQ09ERS5TLFxcXCJzdHJpa2VUaHJvdWdoXFxcIixudWxsLFxcXCJTXFxcIiwhMSwhMSksYS5GRS5SZWdpc3RlclNob3J0Y3V0KGEuRkUuS0VZQ09ERS5DTE9TRV9TUVVBUkVfQlJBQ0tFVCxcXFwiaW5kZW50XFxcIixudWxsLFxcXCJdXFxcIiwhMSwhMSksYS5GRS5SZWdpc3RlclNob3J0Y3V0KGEuRkUuS0VZQ09ERS5PUEVOX1NRVUFSRV9CUkFDS0VULFxcXCJvdXRkZW50XFxcIixudWxsLFxcXCJbXFxcIiwhMSwhMSksYS5GRS5SZWdpc3RlclNob3J0Y3V0KGEuRkUuS0VZQ09ERS5aLFxcXCJ1bmRvXFxcIixudWxsLFxcXCJaXFxcIiwhMSwhMSksYS5GRS5SZWdpc3RlclNob3J0Y3V0KGEuRkUuS0VZQ09ERS5aLFxcXCJyZWRvXFxcIixudWxsLFxcXCJaXFxcIiwhMCwhMSksYS5GRS5NT0RVTEVTLnNob3J0Y3V0cz1mdW5jdGlvbihiKXtmdW5jdGlvbiBjKGMpe2lmKCFiLm9wdHMuc2hvcnRjdXRzSGludClyZXR1cm4gbnVsbDtpZighZil7Zj17fTtmb3IodmFyIGQgaW4gYS5GRS5TSE9SVENVVFNfTUFQKWEuRkUuU0hPUlRDVVRTX01BUC5oYXNPd25Qcm9wZXJ0eShkKSYmYi5vcHRzLnNob3J0Y3V0c0VuYWJsZWQuaW5kZXhPZihhLkZFLlNIT1JUQ1VUU19NQVBbZF0uY21kKT49MCYmKGZbYS5GRS5TSE9SVENVVFNfTUFQW2RdLmNtZCtcXFwiLlxcXCIrKGEuRkUuU0hPUlRDVVRTX01BUFtkXS52YWx8fFxcXCJcXFwiKV09e3NoaWZ0OmEuRkUuU0hPUlRDVVRTX01BUFtkXS5zaGlmdCxvcHRpb246YS5GRS5TSE9SVENVVFNfTUFQW2RdLm9wdGlvbixsZXR0ZXI6YS5GRS5TSE9SVENVVFNfTUFQW2RdLmxldHRlcn0pfXZhciBlPWZbY107cmV0dXJuIGU/KGIuaGVscGVycy5pc01hYygpP1N0cmluZy5mcm9tQ2hhckNvZGUoODk4NCk6XFxcIkN0cmwrXFxcIikrKGUuc2hpZnQ/Yi5oZWxwZXJzLmlzTWFjKCk/U3RyaW5nLmZyb21DaGFyQ29kZSg4Njc5KTpcXFwiU2hpZnQrXFxcIjpcXFwiXFxcIikrKGUub3B0aW9uP2IuaGVscGVycy5pc01hYygpP1N0cmluZy5mcm9tQ2hhckNvZGUoODk5Nyk6XFxcIkFsdCtcXFwiOlxcXCJcXFwiKStlLmxldHRlcjpudWxsfWZ1bmN0aW9uIGQoYyl7aWYoIWIuY29yZS5oYXNGb2N1cygpKXJldHVybiEwO3ZhciBkPWMud2hpY2gsZT0tMSE9bmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKFxcXCJNYWMgT1MgWFxcXCIpP2MubWV0YUtleTpjLmN0cmxLZXksZj0oYy5zaGlmdEtleT9cXFwiXlxcXCI6XFxcIlxcXCIpKyhjLmFsdEtleT9cXFwiQFxcXCI6XFxcIlxcXCIpK2Q7aWYoZSYmYS5GRS5TSE9SVENVVFNfTUFQW2ZdKXt2YXIgZz1hLkZFLlNIT1JUQ1VUU19NQVBbZl0uY21kO2lmKGcmJmIub3B0cy5zaG9ydGN1dHNFbmFibGVkLmluZGV4T2YoZyk+PTApe3ZhciBoLGk9YS5GRS5TSE9SVENVVFNfTUFQW2ZdLnZhbDtpZihnJiYhaT9oPWIuJHRiLmZpbmQoJy5mci1jb21tYW5kW2RhdGEtY21kPVxcXCInK2crJ1xcXCJdJyk6ZyYmaSYmKGg9Yi4kdGIuZmluZCgnLmZyLWNvbW1hbmRbZGF0YS1jbWQ9XFxcIicrZysnXFxcIl1bZGF0YS1wYXJhbTE9XFxcIicraSsnXFxcIl0nKSksaC5sZW5ndGgpcmV0dXJuIGMucHJldmVudERlZmF1bHQoKSxjLnN0b3BQcm9wYWdhdGlvbigpLGgucGFyZW50cyhcXFwiLmZyLXRvb2xiYXJcXFwiKS5kYXRhKFxcXCJpbnN0YW5jZVxcXCIsYiksXFxcImtleWRvd25cXFwiPT1jLnR5cGUmJmIuYnV0dG9uLmV4ZWMoaCksITE7aWYoZyYmYi5jb21tYW5kc1tnXSlyZXR1cm4gYy5wcmV2ZW50RGVmYXVsdCgpLGMuc3RvcFByb3BhZ2F0aW9uKCksXFxcImtleWRvd25cXFwiPT1jLnR5cGUmJmIuY29tbWFuZHNbZ10oKSwhMX19fWZ1bmN0aW9uIGUoKXtiLmV2ZW50cy5vbihcXFwia2V5ZG93blxcXCIsZCwhMCksYi5ldmVudHMub24oXFxcImtleXVwXFxcIixkLCEwKX12YXIgZj1udWxsO3JldHVybntfaW5pdDplLGdldDpjfX0sYS5GRS5NT0RVTEVTLnNuYXBzaG90PWZ1bmN0aW9uKGEpe2Z1bmN0aW9uIGIoYSl7Zm9yKHZhciBiPWEucGFyZW50Tm9kZS5jaGlsZE5vZGVzLGM9MCxkPW51bGwsZT0wO2U8Yi5sZW5ndGg7ZSsrKXtpZihkKXt2YXIgZj1iW2VdLm5vZGVUeXBlPT09Tm9kZS5URVhUX05PREUmJlxcXCJcXFwiPT09YltlXS50ZXh0Q29udGVudCxnPWQubm9kZVR5cGU9PT1Ob2RlLlRFWFRfTk9ERSYmYltlXS5ub2RlVHlwZT09PU5vZGUuVEVYVF9OT0RFO2Z8fGd8fGMrK31pZihiW2VdPT1hKXJldHVybiBjO2Q9YltlXX19ZnVuY3Rpb24gYyhjKXt2YXIgZD1bXTtpZighYy5wYXJlbnROb2RlKXJldHVybltdO2Zvcig7IWEubm9kZS5pc0VsZW1lbnQoYyk7KWQucHVzaChiKGMpKSxjPWMucGFyZW50Tm9kZTtyZXR1cm4gZC5yZXZlcnNlKCl9ZnVuY3Rpb24gZChhLGIpe2Zvcig7YSYmYS5ub2RlVHlwZT09PU5vZGUuVEVYVF9OT0RFOyl7dmFyIGM9YS5wcmV2aW91c1NpYmxpbmc7YyYmYy5ub2RlVHlwZT09Tm9kZS5URVhUX05PREUmJihiKz1jLnRleHRDb250ZW50Lmxlbmd0aCksYT1jfXJldHVybiBifWZ1bmN0aW9uIGUoYSl7cmV0dXJue3NjTG9jOmMoYS5zdGFydENvbnRhaW5lciksc2NPZmZzZXQ6ZChhLnN0YXJ0Q29udGFpbmVyLGEuc3RhcnRPZmZzZXQpLGVjTG9jOmMoYS5lbmRDb250YWluZXIpLGVjT2Zmc2V0OmQoYS5lbmRDb250YWluZXIsYS5lbmRPZmZzZXQpfX1mdW5jdGlvbiBmKCl7dmFyIGI9e307aWYoYS5ldmVudHMudHJpZ2dlcihcXFwic25hcHNob3QuYmVmb3JlXFxcIiksYi5odG1sPWEuJHdwP2EuJGVsLmh0bWwoKTphLiRvZWwuZ2V0KDApLm91dGVySFRNTCxiLnJhbmdlcz1bXSxhLiR3cCYmYS5zZWxlY3Rpb24uaW5FZGl0b3IoKSYmYS5jb3JlLmhhc0ZvY3VzKCkpZm9yKHZhciBjPWEuc2VsZWN0aW9uLnJhbmdlcygpLGQ9MDtkPGMubGVuZ3RoO2QrKyliLnJhbmdlcy5wdXNoKGUoY1tkXSkpO3JldHVybiBhLmV2ZW50cy50cmlnZ2VyKFxcXCJzbmFwc2hvdC5hZnRlclxcXCIpLGJ9ZnVuY3Rpb24gZyhiKXtmb3IodmFyIGM9YS4kZWwuZ2V0KDApLGQ9MDtkPGIubGVuZ3RoO2QrKyljPWMuY2hpbGROb2Rlc1tiW2RdXTtyZXR1cm4gY31mdW5jdGlvbiBoKGIsYyl7dHJ5e3ZhciBkPWcoYy5zY0xvYyksZT1jLnNjT2Zmc2V0LGY9ZyhjLmVjTG9jKSxoPWMuZWNPZmZzZXQsaT1hLmRvYy5jcmVhdGVSYW5nZSgpO2kuc2V0U3RhcnQoZCxlKSxpLnNldEVuZChmLGgpLGIuYWRkUmFuZ2UoaSl9Y2F0Y2goail7fX1mdW5jdGlvbiBpKGIpe2EuJGVsLmh0bWwoKSE9Yi5odG1sJiZhLiRlbC5odG1sKGIuaHRtbCk7dmFyIGM9YS5zZWxlY3Rpb24uZ2V0KCk7YS5zZWxlY3Rpb24uY2xlYXIoKSxhLmV2ZW50cy5mb2N1cyghMCk7Zm9yKHZhciBkPTA7ZDxiLnJhbmdlcy5sZW5ndGg7ZCsrKWgoYyxiLnJhbmdlc1tkXSl9ZnVuY3Rpb24gaihiLGMpe3JldHVybiBiLmh0bWwhPWMuaHRtbD8hMTphLmNvcmUuaGFzRm9jdXMoKSYmSlNPTi5zdHJpbmdpZnkoYi5yYW5nZXMpIT1KU09OLnN0cmluZ2lmeShjLnJhbmdlcyk/ITE6ITB9cmV0dXJue2dldDpmLHJlc3RvcmU6aSxlcXVhbDpqfX0sYS5GRS5NT0RVTEVTLnVuZG89ZnVuY3Rpb24oYSl7ZnVuY3Rpb24gYihiKXt2YXIgYz1iLndoaWNoLGQ9YS5rZXlzLmN0cmxLZXkoYik7ZCYmKDkwPT1jJiZiLnNoaWZ0S2V5JiZiLnByZXZlbnREZWZhdWx0KCksOTA9PWMmJmIucHJldmVudERlZmF1bHQoKSl9ZnVuY3Rpb24gYygpe3JldHVybiAwPT09YS51bmRvX3N0YWNrLmxlbmd0aHx8YS51bmRvX2luZGV4PD0xPyExOiEwfWZ1bmN0aW9uIGQoKXtyZXR1cm4gYS51bmRvX2luZGV4PT1hLnVuZG9fc3RhY2subGVuZ3RoPyExOiEwfWZ1bmN0aW9uIGUoYil7cmV0dXJuIWEudW5kb19zdGFja3x8YS51bmRvaW5nfHxhLiRlbC5nZXQoMCkucXVlcnlTZWxlY3RvckFsbChcXFwiLmZyLW1hcmtlclxcXCIpLmxlbmd0aD8hMTp2b2lkKFxcXCJ1bmRlZmluZWRcXFwiPT10eXBlb2YgYj8oYj1hLnNuYXBzaG90LmdldCgpLGEudW5kb19zdGFja1thLnVuZG9faW5kZXgtMV0mJmEuc25hcHNob3QuZXF1YWwoYS51bmRvX3N0YWNrW2EudW5kb19pbmRleC0xXSxiKXx8KGYoKSxhLnVuZG9fc3RhY2sucHVzaChiKSxhLnVuZG9faW5kZXgrKyxiLmh0bWwhPWwmJihhLmV2ZW50cy50cmlnZ2VyKFxcXCJjb250ZW50Q2hhbmdlZFxcXCIpLGw9Yi5odG1sKSkpOihmKCksYS51bmRvX2luZGV4PjA/YS51bmRvX3N0YWNrW2EudW5kb19pbmRleC0xXT1iOihhLnVuZG9fc3RhY2sucHVzaChiKSxhLnVuZG9faW5kZXgrKykpKX1mdW5jdGlvbiBmKCl7aWYoIWEudW5kb19zdGFja3x8YS51bmRvaW5nKXJldHVybiExO2Zvcig7YS51bmRvX3N0YWNrLmxlbmd0aD5hLnVuZG9faW5kZXg7KWEudW5kb19zdGFjay5wb3AoKX1mdW5jdGlvbiBnKCl7aWYoYS51bmRvX2luZGV4PjEpe2EudW5kb2luZz0hMDt2YXIgYj1hLnVuZG9fc3RhY2tbLS1hLnVuZG9faW5kZXgtMV07Y2xlYXJUaW1lb3V0KGEuX2NvbnRlbnRfY2hhbmdlZF90aW1lciksYS5zbmFwc2hvdC5yZXN0b3JlKGIpLGw9Yi5odG1sLGEucG9wdXBzLmhpZGVBbGwoKSxhLnRvb2xiYXIuZW5hYmxlKCksYS5ldmVudHMudHJpZ2dlcihcXFwiY29udGVudENoYW5nZWRcXFwiKSxhLmV2ZW50cy50cmlnZ2VyKFxcXCJjb21tYW5kcy51bmRvXFxcIiksYS51bmRvaW5nPSExfX1mdW5jdGlvbiBoKCl7aWYoYS51bmRvX2luZGV4PGEudW5kb19zdGFjay5sZW5ndGgpe2EudW5kb2luZz0hMDt2YXIgYj1hLnVuZG9fc3RhY2tbYS51bmRvX2luZGV4KytdO2NsZWFyVGltZW91dChhLl9jb250ZW50X2NoYW5nZWRfdGltZXIpLGEuc25hcHNob3QucmVzdG9yZShiKSxsPWIuaHRtbCxhLnBvcHVwcy5oaWRlQWxsKCksYS50b29sYmFyLmVuYWJsZSgpLGEuZXZlbnRzLnRyaWdnZXIoXFxcImNvbnRlbnRDaGFuZ2VkXFxcIiksYS5ldmVudHMudHJpZ2dlcihcXFwiY29tbWFuZHMucmVkb1xcXCIpLGEudW5kb2luZz0hMX19ZnVuY3Rpb24gaSgpe2EudW5kb19pbmRleD0wLGEudW5kb19zdGFjaz1bXX1mdW5jdGlvbiBqKCl7YS51bmRvX3N0YWNrPVtdfWZ1bmN0aW9uIGsoKXtpKCksYS5ldmVudHMub24oXFxcImluaXRpYWxpemVkXFxcIixmdW5jdGlvbigpe2w9YS5odG1sLmdldCghMSwhMCl9KSxhLmV2ZW50cy5vbihcXFwiYmx1clxcXCIsZnVuY3Rpb24oKXthLnVuZG8uc2F2ZVN0ZXAoKX0pLGEuZXZlbnRzLm9uKFxcXCJrZXlkb3duXFxcIixiKSxhLmV2ZW50cy5vbihcXFwiZGVzdHJveVxcXCIsail9dmFyIGw9bnVsbDtyZXR1cm57X2luaXQ6ayxydW46ZyxyZWRvOmgsY2FuRG86YyxjYW5SZWRvOmQsZHJvcFJlZG86ZixyZXNldDppLHNhdmVTdGVwOmV9fSxhLkZFLklDT05fREVGQVVMVF9URU1QTEFURT1cXFwiZm9udF9hd2Vzb21lXFxcIixhLkZFLklDT05fVEVNUExBVEVTPXtmb250X2F3ZXNvbWU6JzxpIGNsYXNzPVxcXCJmYSBmYS1bTkFNRV1cXFwiPjwvaT4nLHRleHQ6JzxzcGFuIHN0eWxlPVxcXCJ0ZXh0LWFsaWduOiBjZW50ZXI7XFxcIj5bTkFNRV08L3NwYW4+JyxpbWFnZTpcXFwiPGltZyBzcmM9W1NSQ10gYWx0PVtBTFRdIC8+XFxcIn0sYS5GRS5JQ09OUz17Ym9sZDp7TkFNRTpcXFwiYm9sZFxcXCJ9LGl0YWxpYzp7TkFNRTpcXFwiaXRhbGljXFxcIn0sdW5kZXJsaW5lOntOQU1FOlxcXCJ1bmRlcmxpbmVcXFwifSxzdHJpa2VUaHJvdWdoOntOQU1FOlxcXCJzdHJpa2V0aHJvdWdoXFxcIn0sc3Vic2NyaXB0OntOQU1FOlxcXCJzdWJzY3JpcHRcXFwifSxzdXBlcnNjcmlwdDp7TkFNRTpcXFwic3VwZXJzY3JpcHRcXFwifSxjb2xvcjp7TkFNRTpcXFwidGludFxcXCJ9LG91dGRlbnQ6e05BTUU6XFxcIm91dGRlbnRcXFwifSxpbmRlbnQ6e05BTUU6XFxcImluZGVudFxcXCJ9LHVuZG86e05BTUU6XFxcInJvdGF0ZS1sZWZ0XFxcIn0scmVkbzp7TkFNRTpcXFwicm90YXRlLXJpZ2h0XFxcIn0saW5zZXJ0SFI6e05BTUU6XFxcIm1pbnVzXFxcIn0sY2xlYXJGb3JtYXR0aW5nOntOQU1FOlxcXCJlcmFzZXJcXFwifSxzZWxlY3RBbGw6e05BTUU6XFxcIm1vdXNlLXBvaW50ZXJcXFwifX0sYS5GRS5EZWZpbmVJY29uVGVtcGxhdGU9ZnVuY3Rpb24oYixjKXthLkZFLklDT05fVEVNUExBVEVTW2JdPWN9LGEuRkUuRGVmaW5lSWNvbj1mdW5jdGlvbihiLGMpe2EuRkUuSUNPTlNbYl09Y30sYS5GRS5NT0RVTEVTLmljb249ZnVuY3Rpb24oYil7ZnVuY3Rpb24gYyhiKXt2YXIgYz1udWxsLGQ9YS5GRS5JQ09OU1tiXTtpZihcXFwidW5kZWZpbmVkXFxcIiE9dHlwZW9mIGQpe3ZhciBlPWQudGVtcGxhdGV8fGEuRkUuSUNPTl9ERUZBVUxUX1RFTVBMQVRFO2UmJihlPWEuRkUuSUNPTl9URU1QTEFURVNbZV0pJiYoYz1lLnJlcGxhY2UoL1xcXFxbKFthLXpBLVpdKilcXFxcXS9nLGZ1bmN0aW9uKGEsYyl7cmV0dXJuXFxcIk5BTUVcXFwiPT1jP2RbY118fGI6ZFtjXX0pKX1yZXR1cm4gY3x8Yn1yZXR1cm57Y3JlYXRlOmN9fSxhLkZFLk1PRFVMRVMudG9vbHRpcD1mdW5jdGlvbihiKXtmdW5jdGlvbiBjKCl7Yi4kdG9vbHRpcCYmYi4kdG9vbHRpcC5yZW1vdmVDbGFzcyhcXFwiZnItdmlzaWJsZVxcXCIpLmNzcyhcXFwibGVmdFxcXCIsXFxcIi0zMDAwcHhcXFwiKS5jc3MoXFxcInBvc2l0aW9uXFxcIixcXFwiZml4ZWRcXFwiKX1mdW5jdGlvbiBkKGMsZCl7aWYoYy5kYXRhKFxcXCJ0aXRsZVxcXCIpfHxjLmRhdGEoXFxcInRpdGxlXFxcIixjLmF0dHIoXFxcInRpdGxlXFxcIikpLCFjLmRhdGEoXFxcInRpdGxlXFxcIikpcmV0dXJuITE7Yi4kdG9vbHRpcHx8ZigpLGMucmVtb3ZlQXR0cihcXFwidGl0bGVcXFwiKSxiLiR0b29sdGlwLnRleHQoYy5kYXRhKFxcXCJ0aXRsZVxcXCIpKSxiLiR0b29sdGlwLmFkZENsYXNzKFxcXCJmci12aXNpYmxlXFxcIik7dmFyIGU9Yy5vZmZzZXQoKS5sZWZ0KyhjLm91dGVyV2lkdGgoKS1iLiR0b29sdGlwLm91dGVyV2lkdGgoKSkvMjswPmUmJihlPTApLGUrYi4kdG9vbHRpcC5vdXRlcldpZHRoKCk+YShiLm9fd2luKS53aWR0aCgpJiYoZT1hKGIub193aW4pLndpZHRoKCktYi4kdG9vbHRpcC5vdXRlcldpZHRoKCkpLFxcXCJ1bmRlZmluZWRcXFwiPT10eXBlb2YgZCYmKGQ9Yi5vcHRzLnRvb2xiYXJCb3R0b20pO3ZhciBnPWQ/Yy5vZmZzZXQoKS50b3AtYi4kdG9vbHRpcC5oZWlnaHQoKTpjLm9mZnNldCgpLnRvcCtjLm91dGVySGVpZ2h0KCk7Yi4kdG9vbHRpcC5jc3MoXFxcInBvc2l0aW9uXFxcIixcXFwiXFxcIiksYi4kdG9vbHRpcC5jc3MoXFxcImxlZnRcXFwiLGUpLGIuJHRvb2x0aXAuY3NzKFxcXCJ0b3BcXFwiLGcpLFxcXCJzdGF0aWNcXFwiIT1hKGIub19kb2MpLmZpbmQoXFxcImJvZHlcXFwiKS5jc3MoXFxcInBvc2l0aW9uXFxcIik/KGIuJHRvb2x0aXAuY3NzKFxcXCJtYXJnaW4tbGVmdFxcXCIsLWEoYi5vX2RvYykuZmluZChcXFwiYm9keVxcXCIpLm9mZnNldCgpLmxlZnQpLGIuJHRvb2x0aXAuY3NzKFxcXCJtYXJnaW4tdG9wXFxcIiwtYShiLm9fZG9jKS5maW5kKFxcXCJib2R5XFxcIikub2Zmc2V0KCkudG9wKSk6KGIuJHRvb2x0aXAuY3NzKFxcXCJtYXJnaW4tbGVmdFxcXCIsXFxcIlxcXCIpLGIuJHRvb2x0aXAuY3NzKFxcXCJtYXJnaW4tdG9wXFxcIixcXFwiXFxcIikpfWZ1bmN0aW9uIGUoZSxmLGcpe2IuaGVscGVycy5pc01vYmlsZSgpfHwoYi5ldmVudHMuJG9uKGUsXFxcIm1vdXNlZW50ZXJcXFwiLGYsZnVuY3Rpb24oYyl7YShjLmN1cnJlbnRUYXJnZXQpLmhhc0NsYXNzKFxcXCJmci1kaXNhYmxlZFxcXCIpfHxiLmVkaXQuaXNEaXNhYmxlZCgpfHxkKGEoYy5jdXJyZW50VGFyZ2V0KSxnKX0sITApLGIuZXZlbnRzLiRvbihlLFxcXCJtb3VzZWxlYXZlIFxcXCIrYi5fbW91c2Vkb3duK1xcXCIgXFxcIitiLl9tb3VzZXVwLGYsZnVuY3Rpb24oYSl7YygpfSwhMCkpfWZ1bmN0aW9uIGYoKXtiLmhlbHBlcnMuaXNNb2JpbGUoKXx8KGIuc2hhcmVkLiR0b29sdGlwP2IuJHRvb2x0aXA9Yi5zaGFyZWQuJHRvb2x0aXA6KGIuc2hhcmVkLiR0b29sdGlwPWEoJzxkaXYgY2xhc3M9XFxcImZyLXRvb2x0aXBcXFwiPjwvZGl2PicpLGIuJHRvb2x0aXA9Yi5zaGFyZWQuJHRvb2x0aXAsYi5vcHRzLnRoZW1lJiZiLiR0b29sdGlwLmFkZENsYXNzKGIub3B0cy50aGVtZStcXFwiLXRoZW1lXFxcIiksYShiLm9fZG9jKS5maW5kKFxcXCJib2R5XFxcIikuYXBwZW5kKGIuJHRvb2x0aXApKSxiLmV2ZW50cy5vbihcXFwic2hhcmVkLmRlc3Ryb3lcXFwiLGZ1bmN0aW9uKCl7Yi4kdG9vbHRpcC5odG1sKFxcXCJcXFwiKS5yZW1vdmVEYXRhKCkucmVtb3ZlKCksYi4kdG9vbHRpcD1udWxsfSwhMCkpfXJldHVybntoaWRlOmMsdG86ZCxiaW5kOmV9fSxhLkZFLk1PRFVMRVMuYnV0dG9uPWZ1bmN0aW9uKGIpe2Z1bmN0aW9uIGMoYyl7dmFyIGQ9YShjLmN1cnJlbnRUYXJnZXQpLGU9ZC5uZXh0KCksZj1kLmhhc0NsYXNzKFxcXCJmci1hY3RpdmVcXFwiKSxnPShiLmhlbHBlcnMuaXNNb2JpbGUoKSxhKFxcXCIuZnItZHJvcGRvd24uZnItYWN0aXZlXFxcIikubm90KGQpKSxoPWQucGFyZW50cyhcXFwiLmZyLXRvb2xiYXIsIC5mci1wb3B1cFxcXCIpLmRhdGEoXFxcImluc3RhbmNlXFxcIil8fGI7aWYoaC5oZWxwZXJzLmlzSU9TKCkmJjA9PWguJGVsLmdldCgwKS5xdWVyeVNlbGVjdG9yQWxsKFxcXCIuZnItbWFya2VyXFxcIikubGVuZ3RoJiYoaC5zZWxlY3Rpb24uc2F2ZSgpLGguc2VsZWN0aW9uLmNsZWFyKCksaC5zZWxlY3Rpb24ucmVzdG9yZSgpKSwhZil7dmFyIGk9ZC5kYXRhKFxcXCJjbWRcXFwiKTtlLmZpbmQoXFxcIi5mci1jb21tYW5kXFxcIikucmVtb3ZlQ2xhc3MoXFxcImZyLWFjdGl2ZVxcXCIpLGEuRkUuQ09NTUFORFNbaV0mJmEuRkUuQ09NTUFORFNbaV0ucmVmcmVzaE9uU2hvdyYmYS5GRS5DT01NQU5EU1tpXS5yZWZyZXNoT25TaG93LmFwcGx5KGgsW2QsZV0pLGUuY3NzKFxcXCJsZWZ0XFxcIixkLm9mZnNldCgpLmxlZnQtZC5wYXJlbnQoKS5vZmZzZXQoKS5sZWZ0LShcXFwicnRsXFxcIj09Yi5vcHRzLmRpcmVjdGlvbj9lLndpZHRoKCktZC5vdXRlcldpZHRoKCk6MCkpLGIub3B0cy50b29sYmFyQm90dG9tP2UuY3NzKFxcXCJib3R0b21cXFwiLGIuJHRiLmhlaWdodCgpLWQucG9zaXRpb24oKS50b3ApOmUuY3NzKFxcXCJ0b3BcXFwiLGQucG9zaXRpb24oKS50b3ArZC5vdXRlckhlaWdodCgpKX1kLmFkZENsYXNzKFxcXCJmci1ibGlua1xcXCIpLnRvZ2dsZUNsYXNzKFxcXCJmci1hY3RpdmVcXFwiKSxzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7ZC5yZW1vdmVDbGFzcyhcXFwiZnItYmxpbmtcXFwiKX0sMzAwKSxlLm9mZnNldCgpLmxlZnQrZS5vdXRlcldpZHRoKCk+YShiLm9wdHMuc2Nyb2xsYWJsZUNvbnRhaW5lcikub2Zmc2V0KCkubGVmdCthKGIub3B0cy5zY3JvbGxhYmxlQ29udGFpbmVyKS5vdXRlcldpZHRoKCkmJmUuY3NzKFxcXCJtYXJnaW4tbGVmdFxcXCIsLShlLm9mZnNldCgpLmxlZnQrZS5vdXRlcldpZHRoKCktYShiLm9wdHMuc2Nyb2xsYWJsZUNvbnRhaW5lcikub2Zmc2V0KCkubGVmdC1hKGIub3B0cy5zY3JvbGxhYmxlQ29udGFpbmVyKS5vdXRlcldpZHRoKCkpKSxnLnJlbW92ZUNsYXNzKFxcXCJmci1hY3RpdmVcXFwiKSxnLnBhcmVudChcXFwiLmZyLXRvb2xiYXI6bm90KC5mci1pbmxpbmUpXFxcIikuY3NzKFxcXCJ6SW5kZXhcXFwiLFxcXCJcXFwiKSwwIT1kLnBhcmVudHMoXFxcIi5mci1wb3B1cFxcXCIpLmxlbmd0aHx8Yi5vcHRzLnRvb2xiYXJJbmxpbmV8fChkLmhhc0NsYXNzKFxcXCJmci1hY3RpdmVcXFwiKT9iLiR0Yi5jc3MoXFxcInpJbmRleFxcXCIsKGIub3B0cy56SW5kZXh8fDEpKzQpOmIuJHRiLmNzcyhcXFwiekluZGV4XFxcIixcXFwiXFxcIikpfWZ1bmN0aW9uIGQoYil7Yi5hZGRDbGFzcyhcXFwiZnItYmxpbmtcXFwiKSxzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7Yi5yZW1vdmVDbGFzcyhcXFwiZnItYmxpbmtcXFwiKX0sNTAwKTtmb3IodmFyIGM9Yi5kYXRhKFxcXCJjbWRcXFwiKSxkPVtdO1xcXCJ1bmRlZmluZWRcXFwiIT10eXBlb2YgYi5kYXRhKFxcXCJwYXJhbVxcXCIrKGQubGVuZ3RoKzEpKTspZC5wdXNoKGIuZGF0YShcXFwicGFyYW1cXFwiKyhkLmxlbmd0aCsxKSkpO3ZhciBlPWEoXFxcIi5mci1kcm9wZG93bi5mci1hY3RpdmVcXFwiKTtlLmxlbmd0aCYmKGUucmVtb3ZlQ2xhc3MoXFxcImZyLWFjdGl2ZVxcXCIpLGUucGFyZW50KFxcXCIuZnItdG9vbGJhcjpub3QoLmZyLWlubGluZSlcXFwiKS5jc3MoXFxcInpJbmRleFxcXCIsXFxcIlxcXCIpKSxiLnBhcmVudHMoXFxcIi5mci1wb3B1cCwgLmZyLXRvb2xiYXJcXFwiKS5kYXRhKFxcXCJpbnN0YW5jZVxcXCIpLmNvbW1hbmRzLmV4ZWMoYyxkKX1mdW5jdGlvbiBlKGIpe3ZhciBjPWEoYi5jdXJyZW50VGFyZ2V0KTtkKGMpfWZ1bmN0aW9uIGYoYil7dmFyIGQ9YShiLmN1cnJlbnRUYXJnZXQpLGY9ZC5wYXJlbnRzKFxcXCIuZnItcG9wdXAsIC5mci10b29sYmFyXFxcIikuZGF0YShcXFwiaW5zdGFuY2VcXFwiKTtpZigwIT1kLnBhcmVudHMoXFxcIi5mci1wb3B1cFxcXCIpLmxlbmd0aHx8ZC5kYXRhKFxcXCJwb3B1cFxcXCIpfHxmLnBvcHVwcy5oaWRlQWxsKCksZi5wb3B1cHMuYXJlVmlzaWJsZSgpJiYhZi5wb3B1cHMuYXJlVmlzaWJsZShmKSl7XFxuZm9yKHZhciBnPTA7ZzxhLkZFLklOU1RBTkNFUy5sZW5ndGg7ZysrKWEuRkUuSU5TVEFOQ0VTW2ddIT1mJiZhLkZFLklOU1RBTkNFU1tnXS5wb3B1cHMmJmEuRkUuSU5TVEFOQ0VTW2ddLnBvcHVwcy5hcmVWaXNpYmxlKCkmJmEuRkUuSU5TVEFOQ0VTW2ddLiRlbC5maW5kKFxcXCIuZnItbWFya2VyXFxcIikucmVtb3ZlKCk7Zi5wb3B1cHMuaGlkZUFsbCgpfWQuaGFzQ2xhc3MoXFxcImZyLWRyb3Bkb3duXFxcIik/YyhiKTooZShiKSxhLkZFLkNPTU1BTkRTW2QuZGF0YShcXFwiY21kXFxcIildJiYwIT1hLkZFLkNPTU1BTkRTW2QuZGF0YShcXFwiY21kXFxcIildLnJlZnJlc2hBZnRlckNhbGxiYWNrJiZmLmJ1dHRvbi5idWxrUmVmcmVzaCgpKX1mdW5jdGlvbiBnKGEpe3ZhciBiPWEuZmluZChcXFwiLmZyLWRyb3Bkb3duLmZyLWFjdGl2ZVxcXCIpO2IubGVuZ3RoJiYoYi5yZW1vdmVDbGFzcyhcXFwiZnItYWN0aXZlXFxcIiksYi5wYXJlbnQoXFxcIi5mci10b29sYmFyOm5vdCguZnItaW5saW5lKVxcXCIpLmNzcyhcXFwiekluZGV4XFxcIixcXFwiXFxcIikpfWZ1bmN0aW9uIGgoYSl7YS5wcmV2ZW50RGVmYXVsdCgpLGEuc3RvcFByb3BhZ2F0aW9uKCl9ZnVuY3Rpb24gaShhKXtyZXR1cm4gYS5zdG9wUHJvcGFnYXRpb24oKSxiLmhlbHBlcnMuaXNNb2JpbGUoKT92b2lkIDA6ITF9ZnVuY3Rpb24gaihjLGQpe2IuZXZlbnRzLmJpbmRDbGljayhjLFxcXCIuZnItY29tbWFuZDpub3QoLmZyLWRpc2FibGVkKVxcXCIsZiksYi5ldmVudHMuJG9uKGMsYi5fbW91c2Vkb3duK1xcXCIgXFxcIitiLl9tb3VzZXVwK1xcXCIgXFxcIitiLl9tb3ZlLFxcXCIuZnItZHJvcGRvd24tbWVudVxcXCIsaCwhMCksYi5ldmVudHMuJG9uKGMsYi5fbW91c2Vkb3duK1xcXCIgXFxcIitiLl9tb3VzZXVwK1xcXCIgXFxcIitiLl9tb3ZlLFxcXCIuZnItZHJvcGRvd24tbWVudSAuZnItZHJvcGRvd24td3JhcHBlclxcXCIsaSwhMCk7dmFyIGU9Yy5nZXQoMCkub3duZXJEb2N1bWVudCxqPVxcXCJkZWZhdWx0Vmlld1xcXCJpbiBlP2UuZGVmYXVsdFZpZXc6ZS5wYXJlbnRXaW5kb3csaz1mdW5jdGlvbihkKXsoIWR8fGQudHlwZT09Yi5fbW91c2V1cCYmZC50YXJnZXQhPWEoXFxcImh0bWxcXFwiKS5nZXQoMCl8fFxcXCJrZXlkb3duXFxcIj09ZC50eXBlJiYoYi5rZXlzLmlzQ2hhcmFjdGVyKGQud2hpY2gpJiYhYi5rZXlzLmN0cmxLZXkoZCl8fGQud2hpY2g9PWEuRkUuS0VZQ09ERS5FU0MpKSYmZyhjKX07Yi5ldmVudHMuJG9uKGEoaiksYi5fbW91c2V1cCtcXFwiIHJlc2l6ZSBrZXlkb3duXFxcIixrLCEwKSxiLm9wdHMuaWZyYW1lJiZiLmV2ZW50cy4kb24oYi4kd2luLGIuX21vdXNldXAsaywhMCksYy5oYXNDbGFzcyhcXFwiZnItcG9wdXBcXFwiKT9hLm1lcmdlKHQsYy5maW5kKFxcXCIuZnItYnRuXFxcIikudG9BcnJheSgpKTphLm1lcmdlKHMsYy5maW5kKFxcXCIuZnItYnRuXFxcIikudG9BcnJheSgpKSxiLnRvb2x0aXAuYmluZChjLFxcXCIuZnItYnRuLCAuZnItdGl0bGVcXFwiLGQpfWZ1bmN0aW9uIGsoYSxjKXt2YXIgZD1cXFwiXFxcIjtpZihjLmh0bWwpZCs9XFxcImZ1bmN0aW9uXFxcIj09dHlwZW9mIGMuaHRtbD9jLmh0bWwuY2FsbChiKTpjLmh0bWw7ZWxzZXt2YXIgZT1jLm9wdGlvbnM7XFxcImZ1bmN0aW9uXFxcIj09dHlwZW9mIGUmJihlPWUoKSksZCs9Jzx1bCBjbGFzcz1cXFwiZnItZHJvcGRvd24tbGlzdFxcXCI+Jztmb3IodmFyIGYgaW4gZSlpZihlLmhhc093blByb3BlcnR5KGYpKXt2YXIgZz1iLnNob3J0Y3V0cy5nZXQoYStcXFwiLlxcXCIrZik7Zz1nPyc8c3BhbiBjbGFzcz1cXFwiZnItc2hvcnRjdXRcXFwiPicrZytcXFwiPC9zcGFuPlxcXCI6XFxcIlxcXCIsZCs9JzxsaT48YSBjbGFzcz1cXFwiZnItY29tbWFuZFxcXCIgZGF0YS1jbWQ9XFxcIicrYSsnXFxcIiBkYXRhLXBhcmFtMT1cXFwiJytmKydcXFwiIHRpdGxlPVxcXCInK2VbZl0rJ1xcXCI+JytiLmxhbmd1YWdlLnRyYW5zbGF0ZShlW2ZdKStcXFwiPC9hPjwvbGk+XFxcIn1kKz1cXFwiPC91bD5cXFwifXJldHVybiBkfWZ1bmN0aW9uIGwoYSxjLGQpe3ZhciBlPWMuZGlzcGxheVNlbGVjdGlvbjtcXFwiZnVuY3Rpb25cXFwiPT10eXBlb2YgZSYmKGU9ZShiKSk7dmFyIGY7aWYoZSl7dmFyIGc9XFxcImZ1bmN0aW9uXFxcIj09dHlwZW9mIGMuZGVmYXVsdFNlbGVjdGlvbj9jLmRlZmF1bHRTZWxlY3Rpb24oYik6Yy5kZWZhdWx0U2VsZWN0aW9uO2Y9JzxzcGFuIHN0eWxlPVxcXCJ3aWR0aDonKyhjLmRpc3BsYXlTZWxlY3Rpb25XaWR0aHx8MTAwKSsncHhcXFwiPicrKGd8fGIubGFuZ3VhZ2UudHJhbnNsYXRlKGMudGl0bGUpKStcXFwiPC9zcGFuPlxcXCJ9ZWxzZSBmPWIuaWNvbi5jcmVhdGUoYy5pY29ufHxhKTt2YXIgaD1jLnBvcHVwPycgZGF0YS1wb3B1cD1cXFwidHJ1ZVxcXCInOlxcXCJcXFwiLGk9Yi5zaG9ydGN1dHMuZ2V0KGErXFxcIi5cXFwiKTtpPWk/XFxcIiAoXFxcIitpK1xcXCIpXFxcIjpcXFwiXFxcIjt2YXIgaj0nPGJ1dHRvbiB0eXBlPVxcXCJidXR0b25cXFwiIHRhYmluZGV4PVxcXCItMVxcXCIgYXJpYS1sYWJlbD1cXFwiJysoYi5sYW5ndWFnZS50cmFuc2xhdGUoYy50aXRsZSl8fFxcXCJcXFwiKSsnXFxcIiB0aXRsZT1cXFwiJysoYi5sYW5ndWFnZS50cmFuc2xhdGUoYy50aXRsZSl8fFxcXCJcXFwiKStpKydcXFwiIGNsYXNzPVxcXCJmci1jb21tYW5kIGZyLWJ0bicrKFxcXCJkcm9wZG93blxcXCI9PWMudHlwZT9cXFwiIGZyLWRyb3Bkb3duXFxcIjpcXFwiXFxcIikrKGMuZGlzcGxheVNlbGVjdGlvbj9cXFwiIGZyLXNlbGVjdGlvblxcXCI6XFxcIlxcXCIpKyhjLmJhY2s/XFxcIiBmci1iYWNrXFxcIjpcXFwiXFxcIikrKGMuZGlzYWJsZWQ/XFxcIiBmci1kaXNhYmxlZFxcXCI6XFxcIlxcXCIpKyhkP1xcXCJcXFwiOlxcXCIgZnItaGlkZGVuXFxcIikrJ1xcXCIgZGF0YS1jbWQ9XFxcIicrYSsnXFxcIicraCtcXFwiPlxcXCIrZitcXFwiPC9idXR0b24+XFxcIjtpZihcXFwiZHJvcGRvd25cXFwiPT1jLnR5cGUpe3ZhciBsPSc8ZGl2IGNsYXNzPVxcXCJmci1kcm9wZG93bi1tZW51XFxcIj48ZGl2IGNsYXNzPVxcXCJmci1kcm9wZG93bi13cmFwcGVyXFxcIj48ZGl2IGNsYXNzPVxcXCJmci1kcm9wZG93bi1jb250ZW50XFxcIj4nO2wrPWsoYSxjKSxsKz1cXFwiPC9kaXY+PC9kaXY+PC9kaXY+XFxcIixqKz1sfXJldHVybiBqfWZ1bmN0aW9uIG0oYyxkKXtmb3IodmFyIGU9XFxcIlxcXCIsZj0wO2Y8Yy5sZW5ndGg7ZisrKXt2YXIgZz1jW2ZdLGg9YS5GRS5DT01NQU5EU1tnXTtpZighKGgmJlxcXCJ1bmRlZmluZWRcXFwiIT10eXBlb2YgaC5wbHVnaW4mJmIub3B0cy5wbHVnaW5zRW5hYmxlZC5pbmRleE9mKGgucGx1Z2luKTwwKSlpZihoKXt2YXIgaT1cXFwidW5kZWZpbmVkXFxcIiE9dHlwZW9mIGQ/ZC5pbmRleE9mKGcpPj0wOiEwO2UrPWwoZyxoLGkpfWVsc2VcXFwifFxcXCI9PWc/ZSs9JzxkaXYgY2xhc3M9XFxcImZyLXNlcGFyYXRvciBmci12c1xcXCI+PC9kaXY+JzpcXFwiLVxcXCI9PWcmJihlKz0nPGRpdiBjbGFzcz1cXFwiZnItc2VwYXJhdG9yIGZyLWhzXFxcIj48L2Rpdj4nKX1yZXR1cm4gZX1mdW5jdGlvbiBuKGMpe3ZhciBkLGU9Yy5wYXJlbnRzKFxcXCIuZnItcG9wdXAsIC5mci10b29sYmFyXFxcIikuZGF0YShcXFwiaW5zdGFuY2VcXFwiKXx8YixmPWMuZGF0YShcXFwiY21kXFxcIik7Yy5oYXNDbGFzcyhcXFwiZnItZHJvcGRvd25cXFwiKT9kPWMubmV4dCgpOmMucmVtb3ZlQ2xhc3MoXFxcImZyLWFjdGl2ZVxcXCIpLGEuRkUuQ09NTUFORFNbZl0mJmEuRkUuQ09NTUFORFNbZl0ucmVmcmVzaD9hLkZFLkNPTU1BTkRTW2ZdLnJlZnJlc2guYXBwbHkoZSxbYyxkXSk6Yi5yZWZyZXNoW2ZdJiZlLnJlZnJlc2hbZl0oYyxkKX1mdW5jdGlvbiBvKGMpe3ZhciBkPWIuJHRiP2IuJHRiLmRhdGEoXFxcImluc3RhbmNlXFxcIil8fGI6YjtyZXR1cm4gMD09Yi5ldmVudHMudHJpZ2dlcihcXFwiYnV0dG9ucy5yZWZyZXNoXFxcIik/ITA6dm9pZCBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7Zm9yKHZhciBiPWQuc2VsZWN0aW9uLmluRWRpdG9yKCkmJmQuY29yZS5oYXNGb2N1cygpLGU9MDtlPGMubGVuZ3RoO2UrKyl7dmFyIGY9YShjW2VdKSxnPWYuZGF0YShcXFwiY21kXFxcIik7MD09Zi5wYXJlbnRzKFxcXCIuZnItcG9wdXBcXFwiKS5sZW5ndGg/Ynx8YS5GRS5DT01NQU5EU1tnXSYmYS5GRS5DT01NQU5EU1tnXS5mb3JjZWRSZWZyZXNoP2QuYnV0dG9uLnJlZnJlc2goZik6Zi5oYXNDbGFzcyhcXFwiZnItZHJvcGRvd25cXFwiKXx8Zi5yZW1vdmVDbGFzcyhcXFwiZnItYWN0aXZlXFxcIik6Zi5wYXJlbnRzKFxcXCIuZnItcG9wdXBcXFwiKS5pcyhcXFwiOnZpc2libGVcXFwiKSYmZC5idXR0b24ucmVmcmVzaChmKX19LDApfWZ1bmN0aW9uIHAoKXtvKHMpLG8odCl9ZnVuY3Rpb24gcSgpe3M9W10sdD1bXX1mdW5jdGlvbiByKCl7Yi5vcHRzLnRvb2xiYXJJbmxpbmU/Yi5ldmVudHMub24oXFxcInRvb2xiYXIuc2hvd1xcXCIscCk6KGIuZXZlbnRzLm9uKFxcXCJtb3VzZXVwXFxcIixwKSxiLmV2ZW50cy5vbihcXFwia2V5dXBcXFwiLHApLGIuZXZlbnRzLm9uKFxcXCJibHVyXFxcIixwKSxiLmV2ZW50cy5vbihcXFwiZm9jdXNcXFwiLHApLGIuZXZlbnRzLm9uKFxcXCJjb250ZW50Q2hhbmdlZFxcXCIscCkpLGIuZXZlbnRzLm9uKFxcXCJzaGFyZWQuZGVzdHJveVxcXCIscSl9dmFyIHM9W107KGIub3B0cy50b29sYmFySW5saW5lfHxiLm9wdHMudG9vbGJhckNvbnRhaW5lcikmJihiLnNoYXJlZC5idXR0b25zfHwoYi5zaGFyZWQuYnV0dG9ucz1bXSkscz1iLnNoYXJlZC5idXR0b25zKTt2YXIgdD1bXTtyZXR1cm4gYi5zaGFyZWQucG9wdXBfYnV0dG9uc3x8KGIuc2hhcmVkLnBvcHVwX2J1dHRvbnM9W10pLHQ9Yi5zaGFyZWQucG9wdXBfYnV0dG9ucyx7X2luaXQ6cixidWlsZExpc3Q6bSxiaW5kQ29tbWFuZHM6aixyZWZyZXNoOm4sYnVsa1JlZnJlc2g6cCxleGVjOmR9fSxhLkZFLlBPUFVQX1RFTVBMQVRFUz17XFxcInRleHQuZWRpdFxcXCI6XFxcIltfRURJVF9dXFxcIn0sYS5GRS5SZWdpc3RlclRlbXBsYXRlPWZ1bmN0aW9uKGIsYyl7YS5GRS5QT1BVUF9URU1QTEFURVNbYl09Y30sYS5GRS5NT0RVTEVTLnBvcHVwcz1mdW5jdGlvbihiKXtmdW5jdGlvbiBjKGMsZCl7ZC5pcyhcXFwiOnZpc2libGVcXFwiKXx8KGQ9YShiLm9wdHMuc2Nyb2xsYWJsZUNvbnRhaW5lcikpLGQuaXMoeFtjXS5kYXRhKFxcXCJjb250YWluZXJcXFwiKSl8fCh4W2NdLmRhdGEoXFxcImNvbnRhaW5lclxcXCIsZCksZC5hcHBlbmQoeFtjXSkpfWZ1bmN0aW9uIGQoZCxlLGgsaSl7aWYoZygpJiZiLiRlbC5maW5kKFxcXCIuZnItbWFya2VyXFxcIikubGVuZ3RoPjAmJihiLmV2ZW50cy5kaXNhYmxlQmx1cigpLGIuc2VsZWN0aW9uLnJlc3RvcmUoKSksbShbZF0pLCF4W2RdKXJldHVybiExO2EoXFxcIi5mci1kcm9wZG93bi5mci1hY3RpdmVcXFwiKS5yZW1vdmVDbGFzcyhcXFwiZnItYWN0aXZlXFxcIikucGFyZW50KFxcXCIuZnItdG9vbGJhclxcXCIpLmNzcyhcXFwiekluZGV4XFxcIixcXFwiXFxcIikseFtkXS5kYXRhKFxcXCJpbnN0YW5jZVxcXCIsYiksYi4kdGImJmIuJHRiLmRhdGEoXFxcImluc3RhbmNlXFxcIixiKTt2YXIgaj14W2RdLm91dGVyV2lkdGgoKSxrPSh4W2RdLm91dGVySGVpZ2h0KCksZihkKSk7eFtkXS5hZGRDbGFzcyhcXFwiZnItYWN0aXZlXFxcIikucmVtb3ZlQ2xhc3MoXFxcImZyLWhpZGRlblxcXCIpLmZpbmQoXFxcImlucHV0LCB0ZXh0YXJlYVxcXCIpLnJlbW92ZUF0dHIoXFxcImRpc2FibGVkXFxcIik7dmFyIGw9eFtkXS5kYXRhKFxcXCJjb250YWluZXJcXFwiKTtsLmlzKGIuJHRiKSYmYi4kdGIuY3NzKFxcXCJ6SW5kZXhcXFwiLChiLm9wdHMuekluZGV4fHwxKSs0KSxiLm9wdHMudG9vbGJhcklubGluZSYmbCYmYi4kdGImJmwuZ2V0KDApPT1iLiR0Yi5nZXQoMCkmJihjKGQsYShiLm9wdHMuc2Nyb2xsYWJsZUNvbnRhaW5lcikpLGg9Yi4kdGIub2Zmc2V0KCkudG9wLWIuaGVscGVycy5nZXRQWChiLiR0Yi5jc3MoXFxcIm1hcmdpbi10b3BcXFwiKSksZT1iLiR0Yi5vZmZzZXQoKS5sZWZ0K2IuJHRiLm91dGVyV2lkdGgoKS8yKyhwYXJzZUZsb2F0KGIuJHRiLmZpbmQoXFxcIi5mci1hcnJvd1xcXCIpLmNzcyhcXFwibWFyZ2luLWxlZnRcXFwiKSl8fDApK2IuJHRiLmZpbmQoXFxcIi5mci1hcnJvd1xcXCIpLm91dGVyV2lkdGgoKS8yLGIuJHRiLmhhc0NsYXNzKFxcXCJmci1hYm92ZVxcXCIpJiZoJiYoaCs9Yi4kdGIub3V0ZXJIZWlnaHQoKSksaT0wKSxsPXhbZF0uZGF0YShcXFwiY29udGFpbmVyXFxcIiksIWIub3B0cy5pZnJhbWV8fGl8fGt8fChlJiYoZS09Yi4kaWZyYW1lLm9mZnNldCgpLmxlZnQpLGgmJihoLT1iLiRpZnJhbWUub2Zmc2V0KCkudG9wKSksZSYmKGUtPWovMiksYi5vcHRzLnRvb2xiYXJCb3R0b20mJmwmJmIuJHRiJiZsLmdldCgwKT09Yi4kdGIuZ2V0KDApJiYoeFtkXS5hZGRDbGFzcyhcXFwiZnItYWJvdmVcXFwiKSxoJiYoaC09eFtkXS5vdXRlckhlaWdodCgpKSkseFtkXS5yZW1vdmVDbGFzcyhcXFwiZnItYWN0aXZlXFxcIiksYi5wb3NpdGlvbi5hdChlLGgseFtkXSxpfHwwKSx4W2RdLmFkZENsYXNzKFxcXCJmci1hY3RpdmVcXFwiKTt2YXIgbj14W2RdLmZpbmQoXFxcImlucHV0OnZpc2libGUsIHRleHRhcmVhOnZpc2libGVcXFwiKS5nZXQoMCk7biYmKDA9PWIuJGVsLmZpbmQoXFxcIi5mci1tYXJrZXJcXFwiKS5sZW5ndGgmJmIuY29yZS5oYXNGb2N1cygpJiZiLnNlbGVjdGlvbi5zYXZlKCksYi5ldmVudHMuZGlzYWJsZUJsdXIoKSxhKG4pLnNlbGVjdCgpLmZvY3VzKCkpLGIub3B0cy50b29sYmFySW5saW5lJiZiLnRvb2xiYXIuaGlkZSgpLGIuZXZlbnRzLnRyaWdnZXIoXFxcInBvcHVwcy5zaG93LlxcXCIrZCkscyhkKS5fcmVwb3NpdGlvblBvcHVwKCksbygpfWZ1bmN0aW9uIGUoYSxjKXtiLmV2ZW50cy5vbihcXFwicG9wdXBzLnNob3cuXFxcIithLGMpfWZ1bmN0aW9uIGYoYSl7cmV0dXJuIHhbYV0mJnhbYV0uaGFzQ2xhc3MoXFxcImZyLWFjdGl2ZVxcXCIpJiZiLmNvcmUuc2FtZUluc3RhbmNlKHhbYV0pfHwhMX1mdW5jdGlvbiBnKGEpe2Zvcih2YXIgYiBpbiB4KWlmKHguaGFzT3duUHJvcGVydHkoYikmJmYoYikmJihcXFwidW5kZWZpbmVkXFxcIj09dHlwZW9mIGF8fHhbYl0uZGF0YShcXFwiaW5zdGFuY2VcXFwiKT09YSkpcmV0dXJuITA7cmV0dXJuITF9ZnVuY3Rpb24gaChhKXt4W2FdJiZ4W2FdLmhhc0NsYXNzKFxcXCJmci1hY3RpdmVcXFwiKSYmKHhbYV0ucmVtb3ZlQ2xhc3MoXFxcImZyLWFjdGl2ZSBmci1hYm92ZVxcXCIpLGIuZXZlbnRzLnRyaWdnZXIoXFxcInBvcHVwcy5oaWRlLlxcXCIrYSksYi4kdGImJihiLm9wdHMuekluZGV4PjE/Yi4kdGIuY3NzKFxcXCJ6SW5kZXhcXFwiLGIub3B0cy56SW5kZXgrMSk6Yi4kdGIuY3NzKFxcXCJ6SW5kZXhcXFwiLFxcXCJcXFwiKSksYi5ldmVudHMuZGlzYWJsZUJsdXIoKSx4W2FdLmZpbmQoXFxcImlucHV0LCB0ZXh0YXJlYSwgYnV0dG9uXFxcIikuZmlsdGVyKFxcXCI6Zm9jdXNcXFwiKS5ibHVyKCkseFthXS5maW5kKFxcXCJpbnB1dCwgdGV4dGFyZWFcXFwiKS5hdHRyKFxcXCJkaXNhYmxlZFxcXCIsXFxcImRpc2FibGVkXFxcIikpfWZ1bmN0aW9uIGkoYSxjKXtiLmV2ZW50cy5vbihcXFwicG9wdXBzLmhpZGUuXFxcIithLGMpfWZ1bmN0aW9uIGooYSl7dmFyIGM9eFthXTtpZihjJiYhYy5kYXRhKFxcXCJpbnN0XFxcIitiLmlkKSl7dmFyIGQ9cyhhKTt0KGQsYSl9cmV0dXJuIGN9ZnVuY3Rpb24gayhhLGMpe2IuZXZlbnRzLm9uKFxcXCJwb3B1cHMucmVmcmVzaC5cXFwiK2EsYyl9ZnVuY3Rpb24gbChjKXtiLmV2ZW50cy50cmlnZ2VyKFxcXCJwb3B1cHMucmVmcmVzaC5cXFwiK2MpO2Zvcih2YXIgZD14W2NdLmZpbmQoXFxcIi5mci1jb21tYW5kXFxcIiksZT0wO2U8ZC5sZW5ndGg7ZSsrKXt2YXIgZj1hKGRbZV0pOzA9PWYucGFyZW50cyhcXFwiLmZyLWRyb3Bkb3duLW1lbnVcXFwiKS5sZW5ndGgmJmIuYnV0dG9uLnJlZnJlc2goZil9fWZ1bmN0aW9uIG0oYSl7XFxcInVuZGVmaW5lZFxcXCI9PXR5cGVvZiBhJiYoYT1bXSk7Zm9yKHZhciBiIGluIHgpeC5oYXNPd25Qcm9wZXJ0eShiKSYmYS5pbmRleE9mKGIpPDAmJmgoYil9ZnVuY3Rpb24gbigpe2Iuc2hhcmVkLmV4aXRfZmxhZz0hMH1mdW5jdGlvbiBvKCl7Yi5zaGFyZWQuZXhpdF9mbGFnPSExfWZ1bmN0aW9uIHAoKXtyZXR1cm4gYi5zaGFyZWQuZXhpdF9mbGFnfWZ1bmN0aW9uIHEoYyxkKXt2YXIgZT1hLkZFLlBPUFVQX1RFTVBMQVRFU1tjXTtcXFwiZnVuY3Rpb25cXFwiPT10eXBlb2YgZSYmKGU9ZS5hcHBseShiKSk7Zm9yKHZhciBmIGluIGQpZC5oYXNPd25Qcm9wZXJ0eShmKSYmKGU9ZS5yZXBsYWNlKFxcXCJbX1xcXCIrZi50b1VwcGVyQ2FzZSgpK1xcXCJfXVxcXCIsZFtmXSkpO3JldHVybiBlfWZ1bmN0aW9uIHIoYyxkKXt2YXIgZT1xKGMsZCksZj1hKCc8ZGl2IGNsYXNzPVxcXCJmci1wb3B1cCcrKGIuaGVscGVycy5pc01vYmlsZSgpP1xcXCIgZnItbW9iaWxlXFxcIjpcXFwiIGZyLWRlc2t0b3BcXFwiKSsoYi5vcHRzLnRvb2xiYXJJbmxpbmU/XFxcIiBmci1pbmxpbmVcXFwiOlxcXCJcXFwiKSsnXFxcIj48c3BhbiBjbGFzcz1cXFwiZnItYXJyb3dcXFwiPjwvc3Bhbj4nK2UrXFxcIjwvZGl2PlxcXCIpO2Iub3B0cy50aGVtZSYmZi5hZGRDbGFzcyhiLm9wdHMudGhlbWUrXFxcIi10aGVtZVxcXCIpLGIub3B0cy56SW5kZXg+MSYmYi4kdGIuY3NzKFxcXCJ6LWluZGV4XFxcIixiLm9wdHMuekluZGV4KzIpLFxcXCJhdXRvXFxcIiE9Yi5vcHRzLmRpcmVjdGlvbiYmZi5yZW1vdmVDbGFzcyhcXFwiZnItbHRyIGZyLXJ0bFxcXCIpLmFkZENsYXNzKFxcXCJmci1cXFwiK2Iub3B0cy5kaXJlY3Rpb24pLGYuZmluZChcXFwiaW5wdXQsIHRleHRhcmVhXFxcIikuYXR0cihcXFwiZGlyXFxcIixiLm9wdHMuZGlyZWN0aW9uKS5hdHRyKFxcXCJkaXNhYmxlZFxcXCIsXFxcImRpc2FibGVkXFxcIik7dmFyIGc9YShcXFwiYm9keVxcXCIpO3JldHVybiBnLmFwcGVuZChmKSxmLmRhdGEoXFxcImNvbnRhaW5lclxcXCIsZykseFtjXT1mLGIuYnV0dG9uLmJpbmRDb21tYW5kcyhmLCExKSxmfWZ1bmN0aW9uIHMoYyl7dmFyIGQ9eFtjXTtyZXR1cm57X3dpbmRvd1Jlc2l6ZTpmdW5jdGlvbigpe3ZhciBhPWQuZGF0YShcXFwiaW5zdGFuY2VcXFwiKXx8YjshYS5oZWxwZXJzLmlzTW9iaWxlKCkmJmQuaXMoXFxcIjp2aXNpYmxlXFxcIikmJihhLmV2ZW50cy5kaXNhYmxlQmx1cigpLGEucG9wdXBzLmhpZGUoYyksYS5ldmVudHMuZW5hYmxlQmx1cigpKX0sX2lucHV0Rm9jdXM6ZnVuY3Rpb24oYyl7dmFyIGU9ZC5kYXRhKFxcXCJpbnN0YW5jZVxcXCIpfHxiO2lmKGMucHJldmVudERlZmF1bHQoKSxzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7ZS5ldmVudHMuZW5hYmxlQmx1cigpfSwwKSxlLmhlbHBlcnMuaXNNb2JpbGUoKSl7dmFyIGY9YShlLm9fd2luKS5zY3JvbGxUb3AoKTtzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7YShlLm9fd2luKS5zY3JvbGxUb3AoZil9LDApfX0sX2lucHV0Qmx1cjpmdW5jdGlvbihjKXt2YXIgZT1kLmRhdGEoXFxcImluc3RhbmNlXFxcIil8fGI7ZG9jdW1lbnQuYWN0aXZlRWxlbWVudCE9dGhpcyYmYSh0aGlzKS5pcyhcXFwiOnZpc2libGVcXFwiKSYmKGUuZXZlbnRzLmJsdXJBY3RpdmUoKSYmZS5ldmVudHMudHJpZ2dlcihcXFwiYmx1clxcXCIpLGUuZXZlbnRzLmVuYWJsZUJsdXIoKSl9LF9pbnB1dEtleWRvd246ZnVuY3Rpb24oZSl7dmFyIGc9ZC5kYXRhKFxcXCJpbnN0YW5jZVxcXCIpfHxiLGg9ZS53aGljaDtpZihhLkZFLktFWUNPREUuVEFCPT1oKXtlLnByZXZlbnREZWZhdWx0KCk7dmFyIGk9ZC5maW5kKFxcXCJpbnB1dCwgdGV4dGFyZWEsIGJ1dHRvbiwgc2VsZWN0XFxcIikuZmlsdGVyKFxcXCI6dmlzaWJsZVxcXCIpLm5vdChcXFwiOmRpc2FibGVkXFxcIikudG9BcnJheSgpO2kuc29ydChmdW5jdGlvbihiLGMpe3JldHVybiBlLnNoaWZ0S2V5P2EoYikuYXR0cihcXFwidGFiSW5kZXhcXFwiKTxhKGMpLmF0dHIoXFxcInRhYkluZGV4XFxcIik6YShiKS5hdHRyKFxcXCJ0YWJJbmRleFxcXCIpPmEoYykuYXR0cihcXFwidGFiSW5kZXhcXFwiKX0pLGcuZXZlbnRzLmRpc2FibGVCbHVyKCk7dmFyIGo9aS5pbmRleE9mKHRoaXMpKzE7aj09aS5sZW5ndGgmJihqPTApLGEoaVtqXSkuZm9jdXMoKX1lbHNlIGlmKGEuRkUuS0VZQ09ERS5FTlRFUj09aClkLmZpbmQoXFxcIi5mci1zdWJtaXQ6dmlzaWJsZVxcXCIpLmxlbmd0aD4wJiYoZS5wcmV2ZW50RGVmYXVsdCgpLGUuc3RvcFByb3BhZ2F0aW9uKCksZy5ldmVudHMuZGlzYWJsZUJsdXIoKSxnLmJ1dHRvbi5leGVjKGQuZmluZChcXFwiLmZyLXN1Ym1pdDp2aXNpYmxlOmZpcnN0XFxcIikpKTtlbHNle2lmKGEuRkUuS0VZQ09ERS5FU0M9PWgpcmV0dXJuIGUucHJldmVudERlZmF1bHQoKSxlLnN0b3BQcm9wYWdhdGlvbigpLGcuJGVsLmZpbmQoXFxcIi5mci1tYXJrZXJcXFwiKSYmKGcuZXZlbnRzLmRpc2FibGVCbHVyKCksYSh0aGlzKS5kYXRhKFxcXCJza2lwXFxcIiwhMCksZy5zZWxlY3Rpb24ucmVzdG9yZSgpLGcuZXZlbnRzLmVuYWJsZUJsdXIoKSksZihjKSYmZC5maW5kKFxcXCIuZnItYmFjazp2aXNpYmxlXFxcIikubGVuZ3RoP2cuYnV0dG9uLmV4ZWMoZC5maW5kKFxcXCIuZnItYmFjazp2aXNpYmxlOmZpcnN0XFxcIikpOmcucG9wdXBzLmhpZGUoYyksZy5vcHRzLnRvb2xiYXJJbmxpbmUmJmcudG9vbGJhci5zaG93SW5saW5lKG51bGwsITApLCExO2Uuc3RvcFByb3BhZ2F0aW9uKCl9fSxfd2luZG93S2V5ZG93bjpmdW5jdGlvbihlKXtpZighYi5jb3JlLnNhbWVJbnN0YW5jZShkKSlyZXR1cm4hMDt2YXIgZz1kLmRhdGEoXFxcImluc3RhbmNlXFxcIil8fGIsaD1lLndoaWNoO2lmKGEuRkUuS0VZQ09ERS5FU0M9PWgpe2lmKGYoYykmJmcub3B0cy50b29sYmFySW5saW5lKXJldHVybiBlLnN0b3BQcm9wYWdhdGlvbigpLGYoYykmJmQuZmluZChcXFwiLmZyLWJhY2s6dmlzaWJsZVxcXCIpLmxlbmd0aD9nLmJ1dHRvbi5leGVjKGQuZmluZChcXFwiLmZyLWJhY2s6dmlzaWJsZTpmaXJzdFxcXCIpKTooZy5wb3B1cHMuaGlkZShjKSxnLnRvb2xiYXIuc2hvd0lubGluZShudWxsLCEwKSksITE7ZihjKSYmZC5maW5kKFxcXCIuZnItYmFjazp2aXNpYmxlXFxcIikubGVuZ3RoP2cuYnV0dG9uLmV4ZWMoZC5maW5kKFxcXCIuZnItYmFjazp2aXNpYmxlOmZpcnN0XFxcIikpOmcucG9wdXBzLmhpZGUoYyl9fSxfZWRpdG9yS2V5ZG93bjpmdW5jdGlvbihlKXt2YXIgZz1kLmRhdGEoXFxcImluc3RhbmNlXFxcIil8fGI7Zy5rZXlzLmN0cmxLZXkoZSl8fGUud2hpY2g9PWEuRkUuS0VZQ09ERS5FU0N8fChmKGMpJiZkLmZpbmQoXFxcIi5mci1iYWNrOnZpc2libGVcXFwiKS5sZW5ndGg/Zy5idXR0b24uZXhlYyhkLmZpbmQoXFxcIi5mci1iYWNrOnZpc2libGU6Zmlyc3RcXFwiKSk6Zy5wb3B1cHMuaGlkZShjKSl9LF9wcmV2ZW50Rm9jdXM6ZnVuY3Rpb24oYyl7dmFyIGU9ZC5kYXRhKFxcXCJpbnN0YW5jZVxcXCIpfHxiO2UuZXZlbnRzLmRpc2FibGVCbHVyKCk7dmFyIGY9Yy5vcmlnaW5hbEV2ZW50P2Mub3JpZ2luYWxFdmVudC50YXJnZXR8fGMub3JpZ2luYWxFdmVudC5vcmlnaW5hbFRhcmdldDpudWxsLGc9XFxcImlucHV0LCB0ZXh0YXJlYSwgYnV0dG9uLCBzZWxlY3QsIGxhYmVsLCAuZnItY29tbWFuZFxcXCI7cmV0dXJuIGYmJiFhKGYpLmlzKGcpJiYwPT09YShmKS5wYXJlbnRzKGcpLmxlbmd0aD8oYy5zdG9wUHJvcGFnYXRpb24oKSwhMSk6KGYmJmEoZikuaXMoZykmJmMuc3RvcFByb3BhZ2F0aW9uKCksdm9pZCBvKCkpfSxfZWRpdG9yTW91c2V1cDpmdW5jdGlvbihhKXtkLmlzKFxcXCI6dmlzaWJsZVxcXCIpJiZwKCkmJmQuZmluZChcXFwiaW5wdXQ6Zm9jdXMsIHRleHRhcmVhOmZvY3VzLCBidXR0b246Zm9jdXMsIHNlbGVjdDpmb2N1c1xcXCIpLmZpbHRlcihcXFwiOnZpc2libGVcXFwiKS5sZW5ndGg+MCYmYi5ldmVudHMuZGlzYWJsZUJsdXIoKX0sX3dpbmRvd01vdXNldXA6ZnVuY3Rpb24oYSl7aWYoIWIuY29yZS5zYW1lSW5zdGFuY2UoZCkpcmV0dXJuITA7dmFyIGU9ZC5kYXRhKFxcXCJpbnN0YW5jZVxcXCIpfHxiO2QuaXMoXFxcIjp2aXNpYmxlXFxcIikmJnAoKSYmKGEuc3RvcFByb3BhZ2F0aW9uKCksZS5tYXJrZXJzLnJlbW92ZSgpLGUucG9wdXBzLmhpZGUoYyksbygpKX0sX2RvUGxhY2Vob2xkZXI6ZnVuY3Rpb24oYil7dmFyIGM9YSh0aGlzKS5uZXh0KCk7MD09Yy5sZW5ndGgmJmEodGhpcykuYWZ0ZXIoXFxcIjxsYWJlbD5cXFwiK2EodGhpcykuYXR0cihcXFwicGxhY2Vob2xkZXJcXFwiKStcXFwiPC9sYWJlbD5cXFwiKSxhKHRoaXMpLnRvZ2dsZUNsYXNzKFxcXCJmci1ub3QtZW1wdHlcXFwiLFxcXCJcXFwiIT1hKHRoaXMpLnZhbCgpKX0sX3JlcG9zaXRpb25Qb3B1cDpmdW5jdGlvbihlKXtpZighYi5vcHRzLmhlaWdodCYmIWIub3B0cy5oZWlnaHRNYXh8fGIub3B0cy50b29sYmFySW5saW5lKXJldHVybiEwO2lmKGIuJHdwJiZmKGMpJiZkLnBhcmVudCgpLmdldCgwKT09YShiLm9wdHMuc2Nyb2xsYWJsZUNvbnRhaW5lcikuZ2V0KDApKXt2YXIgZz1kLm9mZnNldCgpLnRvcC1iLiR3cC5vZmZzZXQoKS50b3AsaD1iLiR3cC5vdXRlckhlaWdodCgpO2QuaGFzQ2xhc3MoXFxcImZyLWFib3ZlXFxcIikmJihnKz1kLm91dGVySGVpZ2h0KCkpLGc+aHx8MD5nP2QuYWRkQ2xhc3MoXFxcImZyLWhpZGRlblxcXCIpOmQucmVtb3ZlQ2xhc3MoXFxcImZyLWhpZGRlblxcXCIpfX19fWZ1bmN0aW9uIHQoYSxjKXtiLmV2ZW50cy5vbihcXFwibW91c2V1cFxcXCIsYS5fZWRpdG9yTW91c2V1cCwhMCksYi4kd3AmJmIuZXZlbnRzLm9uKFxcXCJrZXlkb3duXFxcIixhLl9lZGl0b3JLZXlkb3duKSxiLmV2ZW50cy5vbihcXFwiYmx1clxcXCIsZnVuY3Rpb24oYSl7ZygpJiZiLm1hcmtlcnMucmVtb3ZlKCksbSgpfSksYi4kd3AmJiFiLmhlbHBlcnMuaXNNb2JpbGUoKSYmYi5ldmVudHMuJG9uKGIuJHdwLFxcXCJzY3JvbGwucG9wdXBcXFwiK2MsYS5fcmVwb3NpdGlvblBvcHVwKSxiLmV2ZW50cy5vbihcXFwid2luZG93LmtleWRvd25cXFwiLGEuX3dpbmRvd0tleWRvd24pLGIuZXZlbnRzLm9uKFxcXCJ3aW5kb3cubW91c2V1cFxcXCIsYS5fd2luZG93TW91c2V1cCwhMCkseFtjXS5kYXRhKFxcXCJpbnN0XFxcIitiLmlkLCEwKSxiLmV2ZW50cy5vbihcXFwiZGVzdHJveVxcXCIsZnVuY3Rpb24oKXtiLmNvcmUuc2FtZUluc3RhbmNlKHhbY10pJiZ4W2NdLnJlbW92ZUNsYXNzKFxcXCJmci1hY3RpdmVcXFwiKS5hcHBlbmRUbyhcXFwiYm9keVxcXCIpfSwhMCl9ZnVuY3Rpb24gdShjLGQpe3ZhciBlPXIoYyxkKSxmPXMoYyk7cmV0dXJuIHQoZixjKSxiLmV2ZW50cy4kb24oZSxcXFwibW91c2Vkb3duIG1vdXNldXAgdG91Y2hzdGFydCB0b3VjaGVuZCB0b3VjaFxcXCIsXFxcIipcXFwiLGYuX3ByZXZlbnRGb2N1cywhMCksYi5ldmVudHMuJG9uKGUsXFxcImZvY3VzXFxcIixcXFwiaW5wdXQsIHRleHRhcmVhLCBidXR0b24sIHNlbGVjdFxcXCIsZi5faW5wdXRGb2N1cywhMCksYi5ldmVudHMuJG9uKGUsXFxcImJsdXJcXFwiLFxcXCJpbnB1dCwgdGV4dGFyZWEsIGJ1dHRvbiwgc2VsZWN0XFxcIixmLl9pbnB1dEJsdXIsITApLGIuZXZlbnRzLiRvbihlLFxcXCJrZXlkb3duXFxcIixcXFwiaW5wdXQsIHRleHRhcmVhLCBidXR0b24sIHNlbGVjdFxcXCIsZi5faW5wdXRLZXlkb3duLCEwKSxiLmV2ZW50cy4kb24oZSxcXFwia2V5ZG93biBrZXl1cCBjaGFuZ2UgaW5wdXRcXFwiLFxcXCJpbnB1dCwgdGV4dGFyZWFcXFwiLGYuX2RvUGxhY2Vob2xkZXIsITApLGIuaGVscGVycy5pc0lPUygpJiZiLmV2ZW50cy4kb24oZSxcXFwidG91Y2hlbmRcXFwiLFxcXCJsYWJlbFxcXCIsZnVuY3Rpb24oKXthKFxcXCIjXFxcIithKHRoaXMpLmF0dHIoXFxcImZvclxcXCIpKS5wcm9wKFxcXCJjaGVja2VkXFxcIixmdW5jdGlvbihhLGIpe3JldHVybiFifSl9LCEwKSxiLmV2ZW50cy4kb24oYShiLm9fd2luKSxcXFwicmVzaXplXFxcIixmLl93aW5kb3dSZXNpemUsITApLGV9ZnVuY3Rpb24gdigpe2Zvcih2YXIgYSBpbiB4KWlmKHguaGFzT3duUHJvcGVydHkoYSkpe3ZhciBiPXhbYV07Yi5odG1sKFxcXCJcXFwiKS5yZW1vdmVEYXRhKCkucmVtb3ZlKCkseFthXT1udWxsfXg9W119ZnVuY3Rpb24gdygpe2IuZXZlbnRzLm9uKFxcXCJzaGFyZWQuZGVzdHJveVxcXCIsdiwhMCksYi5ldmVudHMub24oXFxcIndpbmRvdy5tb3VzZWRvd25cXFwiLG4pLGIuZXZlbnRzLm9uKFxcXCJ3aW5kb3cudG91Y2htb3ZlXFxcIixvKSxiLmV2ZW50cy5vbihcXFwibW91c2Vkb3duXFxcIixmdW5jdGlvbihhKXtnKCkmJihhLnN0b3BQcm9wYWdhdGlvbigpLGIuJGVsLmZpbmQoXFxcIi5mci1tYXJrZXJcXFwiKS5yZW1vdmUoKSxuKCksYi5ldmVudHMuZGlzYWJsZUJsdXIoKSl9KX1iLnNoYXJlZC5wb3B1cHN8fChiLnNoYXJlZC5wb3B1cHM9e30pO3ZhciB4PWIuc2hhcmVkLnBvcHVwcztyZXR1cm4gYi5zaGFyZWQuZXhpdF9mbGFnPSExLHtfaW5pdDp3LGNyZWF0ZTp1LGdldDpqLHNob3c6ZCxoaWRlOmgsb25IaWRlOmksaGlkZUFsbDptLHNldENvbnRhaW5lcjpjLHJlZnJlc2g6bCxvblJlZnJlc2g6ayxvblNob3c6ZSxpc1Zpc2libGU6ZixhcmVWaXNpYmxlOmd9fSxhLkZFLk1PRFVMRVMucG9zaXRpb249ZnVuY3Rpb24oYil7ZnVuY3Rpb24gYygpe3ZhciBjLGQ9Yi5zZWxlY3Rpb24ucmFuZ2VzKDApO2lmKGQmJmQuY29sbGFwc2VkJiZiLnNlbGVjdGlvbi5pbkVkaXRvcigpKXt2YXIgZT0hMTswPT1iLiRlbC5maW5kKFxcXCIuZnItbWFya2VyXFxcIikubGVuZ3RoJiYoYi5zZWxlY3Rpb24uc2F2ZSgpLGU9ITApO3ZhciBmPWIuJGVsLmZpbmQoXFxcIi5mci1tYXJrZXI6Zmlyc3RcXFwiKTtmLmNzcyhcXFwiZGlzcGxheVxcXCIsXFxcImlubGluZVxcXCIpLGYuY3NzKFxcXCJsaW5lLWhlaWdodFxcXCIsXFxcIlxcXCIpO3ZhciBnPWYub2Zmc2V0KCksaD1mLm91dGVySGVpZ2h0KCk7Zi5jc3MoXFxcImRpc3BsYXlcXFwiLFxcXCJub25lXFxcIiksZi5jc3MoXFxcImxpbmUtaGVpZ2h0XFxcIiwwKSxjPXt9LGMubGVmdD1nLmxlZnQsYy53aWR0aD0wLGMuaGVpZ2h0PWgsYy50b3A9Zy50b3AtKGIuaGVscGVycy5pc0lPUygpPzA6YShiLm9fd2luKS5zY3JvbGxUb3AoKSksYy5yaWdodD0xLGMuYm90dG9tPTEsYy5vaz0hMCxlJiZiLnNlbGVjdGlvbi5yZXN0b3JlKCl9ZWxzZSBkJiYoYz1kLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpKTtyZXR1cm4gY31mdW5jdGlvbiBkKGMsZCxlKXt2YXIgZj1jLm91dGVySGVpZ2h0KCk7aWYoIWIuaGVscGVycy5pc01vYmlsZSgpJiZiLiR0YiYmYy5wYXJlbnQoKS5nZXQoMCkhPWIuJHRiLmdldCgwKSl7dmFyIGc9KGMucGFyZW50KCkuaGVpZ2h0KCktMjAtKGIub3B0cy50b29sYmFyQm90dG9tP2IuJHRiLm91dGVySGVpZ2h0KCk6MCksYy5wYXJlbnQoKS5vZmZzZXQoKS50b3ApLGg9ZC1mLShlfHwwKTtjLnBhcmVudCgpLmdldCgwKT09YShiLm9wdHMuc2Nyb2xsYWJsZUNvbnRhaW5lcikuZ2V0KDApJiYoZy09Yy5wYXJlbnQoKS5wb3NpdGlvbigpLnRvcCk7dmFyIGk9YShiLm9wdHMuc2Nyb2xsYWJsZUNvbnRhaW5lcikuZ2V0KDApLnNjcm9sbEhlaWdodDtnK2QrZj5hKGIub3B0cy5zY3JvbGxhYmxlQ29udGFpbmVyKS5vZmZzZXQoKS50b3AraSYmYy5wYXJlbnQoKS5vZmZzZXQoKS50b3AraD4wPyhkPWgsYy5hZGRDbGFzcyhcXFwiZnItYWJvdmVcXFwiKSk6Yy5yZW1vdmVDbGFzcyhcXFwiZnItYWJvdmVcXFwiKX1yZXR1cm4gZH1mdW5jdGlvbiBlKGMsZCl7dmFyIGU9Yy5vdXRlcldpZHRoKCk7cmV0dXJuIGQrZT5hKGIub3B0cy5zY3JvbGxhYmxlQ29udGFpbmVyKS53aWR0aCgpLTEwJiYoZD1hKGIub3B0cy5zY3JvbGxhYmxlQ29udGFpbmVyKS53aWR0aCgpLWUtMTApLDA+ZCYmKGQ9MTApLGR9ZnVuY3Rpb24gZihkKXt2YXIgZT1jKCk7ZC5jc3MoXFxcInRvcFxcXCIsMCkuY3NzKFxcXCJsZWZ0XFxcIiwwKTt2YXIgZj1lLnRvcCtlLmhlaWdodCxoPWUubGVmdCtlLndpZHRoLzItZC5vdXRlcldpZHRoKCkvMithKGIub193aW4pLnNjcm9sbExlZnQoKTtiLm9wdHMuaWZyYW1lfHwoZis9YShiLm9fd2luKS5zY3JvbGxUb3AoKSksZyhoLGYsZCxlLmhlaWdodCl9ZnVuY3Rpb24gZyhhLGMsZixnKXt2YXIgaD1mLmRhdGEoXFxcImNvbnRhaW5lclxcXCIpOyFofHxoLmlzKFxcXCJib2R5XFxcIikmJlxcXCJzdGF0aWNcXFwiPT1oLmNzcyhcXFwicG9zaXRpb25cXFwiKXx8KGEmJihhLT1oLm9mZnNldCgpLmxlZnQpLGMmJihjLT1oLm9mZnNldCgpLnRvcCksXFxcIkJPRFlcXFwiIT1oLmdldCgwKS50YWdOYW1lPyhhJiYoYSs9aC5zY3JvbGxMZWZ0KCkpLGMmJihjKz1oLnNjcm9sbFRvcCgpKSk6XFxcImFic29sdXRlXFxcIj09aC5jc3MoXFxcInBvc2l0aW9uXFxcIikmJihhJiYoYSs9aC5wb3NpdGlvbigpLmxlZnQpLGMmJihjKz1oLnBvc2l0aW9uKCkudG9wKSkpLGIub3B0cy5pZnJhbWUmJmgmJmIuJHRiJiZoLmdldCgwKSE9Yi4kdGIuZ2V0KDApJiYoYSYmKGErPWIuJGlmcmFtZS5vZmZzZXQoKS5sZWZ0KSxjJiYoYys9Yi4kaWZyYW1lLm9mZnNldCgpLnRvcCkpO3ZhciBpPWUoZixhKTtpZihhKXtmLmNzcyhcXFwibGVmdFxcXCIsaSk7dmFyIGo9Zi5maW5kKFxcXCIuZnItYXJyb3dcXFwiKTtqLmRhdGEoXFxcIm1hcmdpbi1sZWZ0XFxcIil8fGouZGF0YShcXFwibWFyZ2luLWxlZnRcXFwiLGIuaGVscGVycy5nZXRQWChqLmNzcyhcXFwibWFyZ2luLWxlZnRcXFwiKSkpLGouY3NzKFxcXCJtYXJnaW4tbGVmdFxcXCIsYS1pK2ouZGF0YShcXFwibWFyZ2luLWxlZnRcXFwiKSl9YyYmZi5jc3MoXFxcInRvcFxcXCIsZChmLGMsZykpfWZ1bmN0aW9uIGgoYyl7dmFyIGQ9YShjKSxlPWQuaXMoXFxcIi5mci1zdGlja3ktb25cXFwiKSxmPWQuZGF0YShcXFwic3RpY2t5LXRvcFxcXCIpLGc9ZC5kYXRhKFxcXCJzdGlja3ktc2NoZWR1bGVkXFxcIik7aWYoXFxcInVuZGVmaW5lZFxcXCI9PXR5cGVvZiBmKXtkLmRhdGEoXFxcInN0aWNreS10b3BcXFwiLDApO3ZhciBoPWEoJzxkaXYgY2xhc3M9XFxcImZyLXN0aWNreS1kdW1teVxcXCIgc3R5bGU9XFxcImhlaWdodDogJytkLm91dGVySGVpZ2h0KCkrJ3B4O1xcXCI+PC9kaXY+Jyk7Yi4kYm94LnByZXBlbmQoaCl9ZWxzZSBiLiRib3guZmluZChcXFwiLmZyLXN0aWNreS1kdW1teVxcXCIpLmNzcyhcXFwiaGVpZ2h0XFxcIixkLm91dGVySGVpZ2h0KCkpO2lmKGIuY29yZS5oYXNGb2N1cygpfHxiLiR0Yi5maW5kKFxcXCJpbnB1dDp2aXNpYmxlOmZvY3VzXFxcIikubGVuZ3RoPjApe3ZhciBpPWEod2luZG93KS5zY3JvbGxUb3AoKSxqPU1hdGgubWluKE1hdGgubWF4KGktYi4kdGIucGFyZW50KCkub2Zmc2V0KCkudG9wLDApLGIuJHRiLnBhcmVudCgpLm91dGVySGVpZ2h0KCktZC5vdXRlckhlaWdodCgpKTtqIT1mJiZqIT1nJiYoY2xlYXJUaW1lb3V0KGQuZGF0YShcXFwic3RpY2t5LXRpbWVvdXRcXFwiKSksZC5kYXRhKFxcXCJzdGlja3ktc2NoZWR1bGVkXFxcIixqKSxkLm91dGVySGVpZ2h0KCk8aS1iLiR0Yi5wYXJlbnQoKS5vZmZzZXQoKS50b3AmJmQuYWRkQ2xhc3MoXFxcImZyLW9wYWNpdHktMFxcXCIpLGQuZGF0YShcXFwic3RpY2t5LXRpbWVvdXRcXFwiLHNldFRpbWVvdXQoZnVuY3Rpb24oKXt2YXIgYz1hKHdpbmRvdykuc2Nyb2xsVG9wKCksZT1NYXRoLm1pbihNYXRoLm1heChjLWIuJHRiLnBhcmVudCgpLm9mZnNldCgpLnRvcCwwKSxiLiR0Yi5wYXJlbnQoKS5vdXRlckhlaWdodCgpLWQub3V0ZXJIZWlnaHQoKSk7ZT4wJiZcXFwiQk9EWVxcXCI9PWIuJHRiLnBhcmVudCgpLmdldCgwKS50YWdOYW1lJiYoZSs9Yi4kdGIucGFyZW50KCkucG9zaXRpb24oKS50b3ApLGUhPWYmJihkLmNzcyhcXFwidG9wXFxcIixNYXRoLm1heChlLDApKSxkLmRhdGEoXFxcInN0aWNreS10b3BcXFwiLGUpLGQuZGF0YShcXFwic3RpY2t5LXNjaGVkdWxlZFxcXCIsZSkpLGQucmVtb3ZlQ2xhc3MoXFxcImZyLW9wYWNpdHktMFxcXCIpfSwxMDApKSksZXx8KGQuY3NzKFxcXCJ0b3BcXFwiLFxcXCIwXFxcIiksZC53aWR0aChiLiR0Yi5wYXJlbnQoKS53aWR0aCgpKSxkLmFkZENsYXNzKFxcXCJmci1zdGlja3ktb25cXFwiKSxiLiRib3guYWRkQ2xhc3MoXFxcImZyLXN0aWNreS1ib3hcXFwiKSl9ZWxzZSBjbGVhclRpbWVvdXQoYShjKS5jc3MoXFxcInN0aWNreS10aW1lb3V0XFxcIikpLGQuY3NzKFxcXCJ0b3BcXFwiLFxcXCIwXFxcIiksZC5jc3MoXFxcInBvc2l0aW9uXFxcIixcXFwiXFxcIiksZC53aWR0aChcXFwiXFxcIiksZC5kYXRhKFxcXCJzdGlja3ktdG9wXFxcIiwwKSxkLnJlbW92ZUNsYXNzKFxcXCJmci1zdGlja3ktb25cXFwiKSxiLiRib3gucmVtb3ZlQ2xhc3MoXFxcImZyLXN0aWNreS1ib3hcXFwiKX1mdW5jdGlvbiBpKGMpe2lmKGMub2Zmc2V0V2lkdGgpe3ZhciBkLGUsZj1hKGMpLGc9Zi5vdXRlckhlaWdodCgpLGg9Zi5kYXRhKFxcXCJzdGlja3ktcG9zaXRpb25cXFwiKSxpPWEoXFxcImJvZHlcXFwiPT1iLm9wdHMuc2Nyb2xsYWJsZUNvbnRhaW5lcj9iLm9fd2luOmIub3B0cy5zY3JvbGxhYmxlQ29udGFpbmVyKS5vdXRlckhlaWdodCgpLGo9MCxrPTA7XFxcImJvZHlcXFwiIT09Yi5vcHRzLnNjcm9sbGFibGVDb250YWluZXImJihqPWEoYi5vcHRzLnNjcm9sbGFibGVDb250YWluZXIpLm9mZnNldCgpLnRvcCxrPWEoYi5vX3dpbikub3V0ZXJIZWlnaHQoKS1qLWkpO3ZhciBsPVxcXCJib2R5XFxcIj09Yi5vcHRzLnNjcm9sbGFibGVDb250YWluZXI/YShiLm9fd2luKS5zY3JvbGxUb3AoKTpqLG09Zi5pcyhcXFwiLmZyLXN0aWNreS1vblxcXCIpO2YuZGF0YShcXFwic3RpY2t5LXBhcmVudFxcXCIpfHxmLmRhdGEoXFxcInN0aWNreS1wYXJlbnRcXFwiLGYucGFyZW50KCkpO3ZhciBuPWYuZGF0YShcXFwic3RpY2t5LXBhcmVudFxcXCIpLG89bi5vZmZzZXQoKS50b3AscD1uLm91dGVySGVpZ2h0KCk7aWYoZi5kYXRhKFxcXCJzdGlja3ktb2Zmc2V0XFxcIil8fChmLmRhdGEoXFxcInN0aWNreS1vZmZzZXRcXFwiLCEwKSxmLmFmdGVyKCc8ZGl2IGNsYXNzPVxcXCJmci1zdGlja3ktZHVtbXlcXFwiIHN0eWxlPVxcXCJoZWlnaHQ6ICcrZysncHg7XFxcIj48L2Rpdj4nKSksIWgpe3ZhciBxPVxcXCJhdXRvXFxcIiE9PWYuY3NzKFxcXCJ0b3BcXFwiKXx8XFxcImF1dG9cXFwiIT09Zi5jc3MoXFxcImJvdHRvbVxcXCIpO3F8fGYuY3NzKFxcXCJwb3NpdGlvblxcXCIsXFxcImZpeGVkXFxcIiksaD17dG9wOmYuaGFzQ2xhc3MoXFxcImZyLXRvcFxcXCIpLGJvdHRvbTpmLmhhc0NsYXNzKFxcXCJmci1ib3R0b21cXFwiKX0scXx8Zi5jc3MoXFxcInBvc2l0aW9uXFxcIixcXFwiXFxcIiksZi5kYXRhKFxcXCJzdGlja3ktcG9zaXRpb25cXFwiLGgpLGYuZGF0YShcXFwidG9wXFxcIixmLmhhc0NsYXNzKFxcXCJmci10b3BcXFwiKT9mLmNzcyhcXFwidG9wXFxcIik6XFxcImF1dG9cXFwiKSxmLmRhdGEoXFxcImJvdHRvbVxcXCIsZi5oYXNDbGFzcyhcXFwiZnItYm90dG9tXFxcIik/Zi5jc3MoXFxcImJvdHRvbVxcXCIpOlxcXCJhdXRvXFxcIil9dmFyIHI9ZnVuY3Rpb24oKXtyZXR1cm4gbCtkPm8mJm8rcC1nPj1sK2R9LHM9ZnVuY3Rpb24oKXtyZXR1cm4gbCtpLWU+bytnJiZvK3A+bCtpLWV9O2Q9Yi5oZWxwZXJzLmdldFBYKGYuZGF0YShcXFwidG9wXFxcIikpLGU9Yi5oZWxwZXJzLmdldFBYKGYuZGF0YShcXFwiYm90dG9tXFxcIikpO3ZhciB0PWgudG9wJiZyKCksdT1oLmJvdHRvbSYmcygpO3R8fHU/KGYuY3NzKFxcXCJ3aWR0aFxcXCIsbi53aWR0aCgpK1xcXCJweFxcXCIpLG18fChmLmFkZENsYXNzKFxcXCJmci1zdGlja3ktb25cXFwiKSxmLnJlbW92ZUNsYXNzKFxcXCJmci1zdGlja3ktb2ZmXFxcIiksZi5jc3MoXFxcInRvcFxcXCIpJiYoXFxcImF1dG9cXFwiIT1mLmRhdGEoXFxcInRvcFxcXCIpP2YuY3NzKFxcXCJ0b3BcXFwiLGIuaGVscGVycy5nZXRQWChmLmRhdGEoXFxcInRvcFxcXCIpKStqKTpmLmRhdGEoXFxcInRvcFxcXCIsXFxcImF1dG9cXFwiKSksZi5jc3MoXFxcImJvdHRvbVxcXCIpJiYoXFxcImF1dG9cXFwiIT1mLmRhdGEoXFxcImJvdHRvbVxcXCIpP2YuY3NzKFxcXCJib3R0b21cXFwiLGIuaGVscGVycy5nZXRQWChmLmRhdGEoXFxcImJvdHRvbVxcXCIpKStrKTpmLmNzcyhcXFwiYm90dG9tXFxcIixcXFwiYXV0b1xcXCIpKSkpOmYuaGFzQ2xhc3MoXFxcImZyLXN0aWNreS1vZmZcXFwiKXx8KGYud2lkdGgoXFxcIlxcXCIpLGYucmVtb3ZlQ2xhc3MoXFxcImZyLXN0aWNreS1vblxcXCIpLGYuYWRkQ2xhc3MoXFxcImZyLXN0aWNreS1vZmZcXFwiKSxmLmNzcyhcXFwidG9wXFxcIikmJlxcXCJhdXRvXFxcIiE9Zi5jc3MoXFxcInRvcFxcXCIpJiZmLmNzcyhcXFwidG9wXFxcIiwwKSxmLmNzcyhcXFwiYm90dG9tXFxcIikmJmYuY3NzKFxcXCJib3R0b21cXFwiLDApKX19ZnVuY3Rpb24gaigpe3ZhciBhPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXFxcInRlc3RcXFwiKSxjPWEuc3R5bGU7cmV0dXJuIGMuY3NzVGV4dD1cXFwicG9zaXRpb246XFxcIitbXFxcIi13ZWJraXQtXFxcIixcXFwiLW1vei1cXFwiLFxcXCItbXMtXFxcIixcXFwiLW8tXFxcIixcXFwiXFxcIl0uam9pbihcXFwic3RpY2t5OyBwb3NpdGlvbjpcXFwiKStcXFwiIHN0aWNreTtcXFwiLC0xIT09Yy5wb3NpdGlvbi5pbmRleE9mKFxcXCJzdGlja3lcXFwiKSYmIWIuaGVscGVycy5pc0lPUygpJiYhYi5oZWxwZXJzLmlzQW5kcm9pZCgpfWZ1bmN0aW9uIGsoKXtpZighaigpKWlmKGIuX3N0aWNreUVsZW1lbnRzPVtdLGIuaGVscGVycy5pc0lPUygpKXt2YXIgYz1mdW5jdGlvbigpe2IuaGVscGVycy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKShjKTtmb3IodmFyIGE9MDthPGIuX3N0aWNreUVsZW1lbnRzLmxlbmd0aDthKyspaChiLl9zdGlja3lFbGVtZW50c1thXSl9O2MoKSxiLmV2ZW50cy4kb24oYShiLm9fd2luKSxcXFwic2Nyb2xsXFxcIixmdW5jdGlvbigpe2lmKGIuY29yZS5oYXNGb2N1cygpKWZvcih2YXIgYz0wO2M8Yi5fc3RpY2t5RWxlbWVudHMubGVuZ3RoO2MrKyl7dmFyIGQ9YShiLl9zdGlja3lFbGVtZW50c1tjXSksZT1kLnBhcmVudCgpLGY9YSh3aW5kb3cpLnNjcm9sbFRvcCgpO2Qub3V0ZXJIZWlnaHQoKTxmLWUub2Zmc2V0KCkudG9wJiYoZC5hZGRDbGFzcyhcXFwiZnItb3BhY2l0eS0wXFxcIiksZC5kYXRhKFxcXCJzdGlja3ktdG9wXFxcIiwtMSksZC5kYXRhKFxcXCJzdGlja3ktc2NoZWR1bGVkXFxcIiwtMSkpfX0sITApfWVsc2UgYi5ldmVudHMuJG9uKGEoXFxcImJvZHlcXFwiPT1iLm9wdHMuc2Nyb2xsYWJsZUNvbnRhaW5lcj9iLm9fd2luOmIub3B0cy5zY3JvbGxhYmxlQ29udGFpbmVyKSxcXFwic2Nyb2xsXFxcIixsLCEwKSxiLmV2ZW50cy4kb24oYShiLm9fd2luKSxcXFwicmVzaXplXFxcIixsLCEwKSxiLmV2ZW50cy5vbihcXFwiaW5pdGlhbGl6ZWRcXFwiLGwpLGIuZXZlbnRzLm9uKFxcXCJmb2N1c1xcXCIsbCksYi5ldmVudHMuJG9uKGEoYi5vX3dpbiksXFxcInJlc2l6ZVxcXCIsXFxcInRleHRhcmVhXFxcIixsLCEwKTtiLmV2ZW50cy5vbihcXFwiZGVzdHJveVxcXCIsZnVuY3Rpb24oYSl7Yi5fc3RpY2t5RWxlbWVudHM9W119KX1mdW5jdGlvbiBsKCl7Zm9yKHZhciBhPTA7YTxiLl9zdGlja3lFbGVtZW50cy5sZW5ndGg7YSsrKWkoYi5fc3RpY2t5RWxlbWVudHNbYV0pfWZ1bmN0aW9uIG0oYSl7YS5hZGRDbGFzcyhcXFwiZnItc3RpY2t5XFxcIiksYi5oZWxwZXJzLmlzSU9TKCkmJmEuYWRkQ2xhc3MoXFxcImZyLXN0aWNreS1pb3NcXFwiKSxqKCl8fGIuX3N0aWNreUVsZW1lbnRzLnB1c2goYS5nZXQoMCkpfWZ1bmN0aW9uIG4oKXtrKCl9cmV0dXJue19pbml0Om4sZm9yU2VsZWN0aW9uOmYsYWRkU3RpY2t5Om0scmVmcmVzaDpsLGF0OmcsZ2V0Qm91bmRpbmdSZWN0OmN9fSxhLkZFLk1PRFVMRVMucmVmcmVzaD1mdW5jdGlvbihiKXtmdW5jdGlvbiBjKGEpe2EudG9nZ2xlQ2xhc3MoXFxcImZyLWRpc2FibGVkXFxcIiwhYi51bmRvLmNhbkRvKCkpfWZ1bmN0aW9uIGQoYSl7YS50b2dnbGVDbGFzcyhcXFwiZnItZGlzYWJsZWRcXFwiLCFiLnVuZG8uY2FuUmVkbygpKX1mdW5jdGlvbiBlKGEpe2lmKGEuaGFzQ2xhc3MoXFxcImZyLW5vLXJlZnJlc2hcXFwiKSlyZXR1cm4hMTtmb3IodmFyIGM9Yi5zZWxlY3Rpb24uYmxvY2tzKCksZD0wO2Q8Yy5sZW5ndGg7ZCsrKXtmb3IodmFyIGU9Y1tkXS5wcmV2aW91c1NpYmxpbmc7ZSYmZS5ub2RlVHlwZT09Tm9kZS5URVhUX05PREUmJjA9PT1lLnRleHRDb250ZW50Lmxlbmd0aDspZT1lLnByZXZpb3VzU2libGluZztpZihcXFwiTElcXFwiIT1jW2RdLnRhZ05hbWV8fGUpcmV0dXJuIGEucmVtb3ZlQ2xhc3MoXFxcImZyLWRpc2FibGVkXFxcIiksITA7YS5hZGRDbGFzcyhcXFwiZnItZGlzYWJsZWRcXFwiKX19ZnVuY3Rpb24gZihjKXtpZihjLmhhc0NsYXNzKFxcXCJmci1uby1yZWZyZXNoXFxcIikpcmV0dXJuITE7Zm9yKHZhciBkPWIuc2VsZWN0aW9uLmJsb2NrcygpLGU9MDtlPGQubGVuZ3RoO2UrKyl7dmFyIGY9XFxcInJ0bFxcXCI9PWIub3B0cy5kaXJlY3Rpb258fFxcXCJydGxcXFwiPT1hKGRbZV0pLmNzcyhcXFwiZGlyZWN0aW9uXFxcIik/XFxcIm1hcmdpbi1yaWdodFxcXCI6XFxcIm1hcmdpbi1sZWZ0XFxcIjtpZihcXFwiTElcXFwiPT1kW2VdLnRhZ05hbWV8fFxcXCJMSVxcXCI9PWRbZV0ucGFyZW50Tm9kZS50YWdOYW1lKXJldHVybiBjLnJlbW92ZUNsYXNzKFxcXCJmci1kaXNhYmxlZFxcXCIpLCEwO2lmKGIuaGVscGVycy5nZXRQWChhKGRbZV0pLmNzcyhmKSk+MClyZXR1cm4gYy5yZW1vdmVDbGFzcyhcXFwiZnItZGlzYWJsZWRcXFwiKSwhMH1jLmFkZENsYXNzKFxcXCJmci1kaXNhYmxlZFxcXCIpfXJldHVybnt1bmRvOmMscmVkbzpkLG91dGRlbnQ6ZixpbmRlbnQ6ZX19LGEuZXh0ZW5kKGEuRkUuREVGQVVMVFMse2VkaXRJblBvcHVwOiExfSksYS5GRS5NT0RVTEVTLnRleHRFZGl0PWZ1bmN0aW9uKGIpe2Z1bmN0aW9uIGMoKXt2YXIgYT0nPGRpdiBpZD1cXFwiZnItdGV4dC1lZGl0LScrYi5pZCsnXFxcIiBjbGFzcz1cXFwiZnItbGF5ZXIgZnItdGV4dC1lZGl0LWxheWVyXFxcIj48ZGl2IGNsYXNzPVxcXCJmci1pbnB1dC1saW5lXFxcIj48aW5wdXQgdHlwZT1cXFwidGV4dFxcXCIgcGxhY2Vob2xkZXI9XFxcIicrYi5sYW5ndWFnZS50cmFuc2xhdGUoXFxcIlRleHRcXFwiKSsnXFxcIiB0YWJJbmRleD1cXFwiMVxcXCI+PC9kaXY+PGRpdiBjbGFzcz1cXFwiZnItYWN0aW9uLWJ1dHRvbnNcXFwiPjxidXR0b24gdHlwZT1cXFwiYnV0dG9uXFxcIiBjbGFzcz1cXFwiZnItY29tbWFuZCBmci1zdWJtaXRcXFwiIGRhdGEtY21kPVxcXCJ1cGRhdGVUZXh0XFxcIiB0YWJJbmRleD1cXFwiMlxcXCI+JytiLmxhbmd1YWdlLnRyYW5zbGF0ZShcXFwiVXBkYXRlXFxcIikrXFxcIjwvYnV0dG9uPjwvZGl2PjwvZGl2PlxcXCIsYz17ZWRpdDphfTtiLnBvcHVwcy5jcmVhdGUoXFxcInRleHQuZWRpdFxcXCIsYyl9ZnVuY3Rpb24gZCgpe3ZhciBjLGQ9Yi5wb3B1cHMuZ2V0KFxcXCJ0ZXh0LmVkaXRcXFwiKTtjPVxcXCJJTlBVVFxcXCI9PT1iLiRlbC5wcm9wKFxcXCJ0YWdOYW1lXFxcIik/Yi4kZWwuYXR0cihcXFwicGxhY2Vob2xkZXJcXFwiKTpiLiRlbC50ZXh0KCksZC5maW5kKFxcXCJpbnB1dFxcXCIpLnZhbChjKS50cmlnZ2VyKFxcXCJjaGFuZ2VcXFwiKSxiLnBvcHVwcy5zZXRDb250YWluZXIoXFxcInRleHQuZWRpdFxcXCIsYShcXFwiYm9keVxcXCIpKSxiLnBvcHVwcy5zaG93KFxcXCJ0ZXh0LmVkaXRcXFwiLGIuJGVsLm9mZnNldCgpLmxlZnQrYi4kZWwub3V0ZXJXaWR0aCgpLzIsYi4kZWwub2Zmc2V0KCkudG9wK2IuJGVsLm91dGVySGVpZ2h0KCksYi4kZWwub3V0ZXJIZWlnaHQoKSl9ZnVuY3Rpb24gZSgpe2IuZXZlbnRzLiRvbihiLiRlbCxiLl9tb3VzZXVwLGZ1bmN0aW9uKGEpe3NldFRpbWVvdXQoZnVuY3Rpb24oKXtkKCl9LDEwKX0pfWZ1bmN0aW9uIGYoKXt2YXIgYT1iLnBvcHVwcy5nZXQoXFxcInRleHQuZWRpdFxcXCIpLGM9YS5maW5kKFxcXCJpbnB1dFxcXCIpLnZhbCgpOzA9PWMubGVuZ3RoJiYoYz1iLm9wdHMucGxhY2Vob2xkZXJUZXh0KSxcXFwiSU5QVVRcXFwiPT09Yi4kZWwucHJvcChcXFwidGFnTmFtZVxcXCIpP2IuJGVsLmF0dHIoXFxcInBsYWNlaG9sZGVyXFxcIixjKTpiLiRlbC50ZXh0KGMpLGIuZXZlbnRzLnRyaWdnZXIoXFxcImNvbnRlbnRDaGFuZ2VkXFxcIiksYi5wb3B1cHMuaGlkZShcXFwidGV4dC5lZGl0XFxcIil9ZnVuY3Rpb24gZygpe2Iub3B0cy5lZGl0SW5Qb3B1cCYmKGMoKSxlKCkpfXJldHVybntfaW5pdDpnLHVwZGF0ZTpmfX0sYS5GRS5SZWdpc3RlckNvbW1hbmQoXFxcInVwZGF0ZVRleHRcXFwiLHtmb2N1czohMSx1bmRvOiExLGNhbGxiYWNrOmZ1bmN0aW9uKCl7dGhpcy50ZXh0RWRpdC51cGRhdGUoKX19KSxhLmV4dGVuZChhLkZFLkRFRkFVTFRTLHt0b29sYmFyQm90dG9tOiExLHRvb2xiYXJCdXR0b25zOltcXFwiZnVsbHNjcmVlblxcXCIsXFxcImJvbGRcXFwiLFxcXCJpdGFsaWNcXFwiLFxcXCJ1bmRlcmxpbmVcXFwiLFxcXCJzdHJpa2VUaHJvdWdoXFxcIixcXFwic3Vic2NyaXB0XFxcIixcXFwic3VwZXJzY3JpcHRcXFwiLFxcXCJmb250RmFtaWx5XFxcIixcXFwiZm9udFNpemVcXFwiLFxcXCJ8XFxcIixcXFwiY29sb3JcXFwiLFxcXCJlbW90aWNvbnNcXFwiLFxcXCJpbmxpbmVTdHlsZVxcXCIsXFxcInBhcmFncmFwaFN0eWxlXFxcIixcXFwifFxcXCIsXFxcInBhcmFncmFwaEZvcm1hdFxcXCIsXFxcImFsaWduXFxcIixcXFwiZm9ybWF0T0xcXFwiLFxcXCJmb3JtYXRVTFxcXCIsXFxcIm91dGRlbnRcXFwiLFxcXCJpbmRlbnRcXFwiLFxcXCJxdW90ZVxcXCIsXFxcImluc2VydEhSXFxcIixcXFwiLVxcXCIsXFxcImluc2VydExpbmtcXFwiLFxcXCJpbnNlcnRJbWFnZVxcXCIsXFxcImluc2VydFZpZGVvXFxcIixcXFwiaW5zZXJ0RmlsZVxcXCIsXFxcImluc2VydFRhYmxlXFxcIixcXFwidW5kb1xcXCIsXFxcInJlZG9cXFwiLFxcXCJjbGVhckZvcm1hdHRpbmdcXFwiLFxcXCJzZWxlY3RBbGxcXFwiLFxcXCJodG1sXFxcIixcXFwiYXBwbHlGb3JtYXRcXFwiLFxcXCJyZW1vdmVGb3JtYXRcXFwiXSx0b29sYmFyQnV0dG9uc1hTOltcXFwiYm9sZFxcXCIsXFxcIml0YWxpY1xcXCIsXFxcImZvbnRGYW1pbHlcXFwiLFxcXCJmb250U2l6ZVxcXCIsXFxcInxcXFwiLFxcXCJ1bmRvXFxcIixcXFwicmVkb1xcXCJdLHRvb2xiYXJCdXR0b25zU006W1xcXCJib2xkXFxcIixcXFwiaXRhbGljXFxcIixcXFwidW5kZXJsaW5lXFxcIixcXFwifFxcXCIsXFxcImZvbnRGYW1pbHlcXFwiLFxcXCJmb250U2l6ZVxcXCIsXFxcImluc2VydExpbmtcXFwiLFxcXCJpbnNlcnRJbWFnZVxcXCIsXFxcInRhYmxlXFxcIixcXFwifFxcXCIsXFxcInVuZG9cXFwiLFxcXCJyZWRvXFxcIl0sdG9vbGJhckJ1dHRvbnNNRDpbXFxcImZ1bGxzY3JlZW5cXFwiLFxcXCJib2xkXFxcIixcXFwiaXRhbGljXFxcIixcXFwidW5kZXJsaW5lXFxcIixcXFwiZm9udEZhbWlseVxcXCIsXFxcImZvbnRTaXplXFxcIixcXFwiY29sb3JcXFwiLFxcXCJwYXJhZ3JhcGhTdHlsZVxcXCIsXFxcInBhcmFncmFwaEZvcm1hdFxcXCIsXFxcImFsaWduXFxcIixcXFwiZm9ybWF0T0xcXFwiLFxcXCJmb3JtYXRVTFxcXCIsXFxcIm91dGRlbnRcXFwiLFxcXCJpbmRlbnRcXFwiLFxcXCJxdW90ZVxcXCIsXFxcImluc2VydEhSXFxcIixcXFwiLVxcXCIsXFxcImluc2VydExpbmtcXFwiLFxcXCJpbnNlcnRJbWFnZVxcXCIsXFxcImluc2VydFZpZGVvXFxcIixcXFwiaW5zZXJ0RmlsZVxcXCIsXFxcImluc2VydFRhYmxlXFxcIixcXFwidW5kb1xcXCIsXFxcInJlZG9cXFwiLFxcXCJjbGVhckZvcm1hdHRpbmdcXFwiXSx0b29sYmFyQ29udGFpbmVyOm51bGwsdG9vbGJhcklubGluZTohMSx0b29sYmFyU3RpY2t5OiEwLHRvb2xiYXJTdGlja3lPZmZzZXQ6MCx0b29sYmFyVmlzaWJsZVdpdGhvdXRTZWxlY3Rpb246ITF9KSxhLkZFLk1PRFVMRVMudG9vbGJhcj1mdW5jdGlvbihiKXtmdW5jdGlvbiBjKGEsYil7Zm9yKHZhciBjPTA7YzxiLmxlbmd0aDtjKyspXFxcIi1cXFwiIT1iW2NdJiZcXFwifFxcXCIhPWJbY10mJmEuaW5kZXhPZihiW2NdKTwwJiZhLnB1c2goYltjXSl9ZnVuY3Rpb24gZCgpe3ZhciBkPWEubWVyZ2UoW10sZSgpKTtjKGQsYi5vcHRzLnRvb2xiYXJCdXR0b25zWFN8fFtdKSxjKGQsYi5vcHRzLnRvb2xiYXJCdXR0b25zU018fFtdKSxjKGQsYi5vcHRzLnRvb2xiYXJCdXR0b25zTUR8fFtdKSxjKGQsYi5vcHRzLnRvb2xiYXJCdXR0b25zKTtmb3IodmFyIGY9ZC5sZW5ndGgtMTtmPj0wO2YtLSlcXFwiLVxcXCIhPWRbZl0mJlxcXCJ8XFxcIiE9ZFtmXSYmZC5pbmRleE9mKGRbZl0pPGYmJmQuc3BsaWNlKGYsMSk7dmFyIGc9Yi5idXR0b24uYnVpbGRMaXN0KGQsZSgpKTtiLiR0Yi5hcHBlbmQoZyksYi5idXR0b24uYmluZENvbW1hbmRzKGIuJHRiKX1mdW5jdGlvbiBlKCl7dmFyIGE9Yi5oZWxwZXJzLnNjcmVlblNpemUoKTtyZXR1cm4gdVthXX1mdW5jdGlvbiBmKCl7dmFyIGE9ZSgpO2IuJHRiLmZpbmQoXFxcIi5mci1zZXBhcmF0b3JcXFwiKS5yZW1vdmUoKSxiLiR0Yi5maW5kKFxcXCI+IC5mci1jb21tYW5kXFxcIikuYWRkQ2xhc3MoXFxcImZyLWhpZGRlblxcXCIpO2Zvcih2YXIgYz0wO2M8YS5sZW5ndGg7YysrKWlmKFxcXCJ8XFxcIj09YVtjXXx8XFxcIi1cXFwiPT1hW2NdKWIuJHRiLmFwcGVuZChiLmJ1dHRvbi5idWlsZExpc3QoW2FbY11dKSk7ZWxzZXt2YXIgZD1iLiR0Yi5maW5kKCc+IC5mci1jb21tYW5kW2RhdGEtY21kPVxcXCInK2FbY10rJ1xcXCJdJyksZj1udWxsO2QubmV4dCgpLmhhc0NsYXNzKFxcXCJmci1kcm9wZG93bi1tZW51XFxcIikmJihmPWQubmV4dCgpKSxkLnJlbW92ZUNsYXNzKFxcXCJmci1oaWRkZW5cXFwiKS5hcHBlbmRUbyhiLiR0YiksZiYmZi5hcHBlbmRUbyhiLiR0Yil9fWZ1bmN0aW9uIGcoKXtiLmV2ZW50cy4kb24oYShiLm9fd2luKSxcXFwicmVzaXplXFxcIixmLCEwKSxiLmV2ZW50cy4kb24oYShiLm9fd2luKSxcXFwib3JpZW50YXRpb25jaGFuZ2VcXFwiLGYsITApfWZ1bmN0aW9uIGgoYyxkKXtzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7aWYoYyYmYy53aGljaD09YS5GRS5LRVlDT0RFLkVTQyk7ZWxzZSBpZihiLnNlbGVjdGlvbi5pbkVkaXRvcigpJiZiLmNvcmUuaGFzRm9jdXMoKSYmIWIucG9wdXBzLmFyZVZpc2libGUoKSYmKGIub3B0cy50b29sYmFyVmlzaWJsZVdpdGhvdXRTZWxlY3Rpb24mJmMmJlxcXCJrZXl1cFxcXCIhPWMudHlwZXx8IWIuc2VsZWN0aW9uLmlzQ29sbGFwc2VkKCkmJiFiLmtleXMuaXNJTUUoKXx8ZCkpe2lmKGIuJHRiLmRhdGEoXFxcImluc3RhbmNlXFxcIixiKSwwPT1iLmV2ZW50cy50cmlnZ2VyKFxcXCJ0b29sYmFyLnNob3dcXFwiLFtjXSkpcmV0dXJuITE7Yi5vcHRzLnRvb2xiYXJDb250YWluZXJ8fGIucG9zaXRpb24uZm9yU2VsZWN0aW9uKGIuJHRiKSxiLiR0Yi5zaG93KCl9fSwwKX1mdW5jdGlvbiBpKGMpe3ZhciBkPWEoXFxcIi5mci1kcm9wZG93bi5mci1hY3RpdmVcXFwiKTtyZXR1cm4gZC5uZXh0KCkuZmluZChiLm9fZG9jLmFjdGl2ZUVsZW1lbnQpLmxlbmd0aD8hMDp2b2lkKGIuZXZlbnRzLnRyaWdnZXIoXFxcInRvb2xiYXIuaGlkZVxcXCIpIT09ITEmJmIuJHRiLmhpZGUoKSl9ZnVuY3Rpb24gaigpe3JldHVybiAwPT1iLmV2ZW50cy50cmlnZ2VyKFxcXCJ0b29sYmFyLnNob3dcXFwiKT8hMTp2b2lkIGIuJHRiLnNob3coKX1mdW5jdGlvbiBrKCl7Yi5ldmVudHMub24oXFxcIndpbmRvdy5tb3VzZWRvd25cXFwiLGkpLGIuZXZlbnRzLm9uKFxcXCJrZXlkb3duXFxcIixpKSxiLmV2ZW50cy5vbihcXFwiYmx1clxcXCIsaSksYi5ldmVudHMub24oXFxcIndpbmRvdy5tb3VzZXVwXFxcIixoKSxiLmhlbHBlcnMuaXNNb2JpbGUoKT9iLmhlbHBlcnMuaXNJT1MoKXx8KGIuZXZlbnRzLm9uKFxcXCJ3aW5kb3cudG91Y2hlbmRcXFwiLGgpLGIuYnJvd3Nlci5tb3ppbGxhJiZzZXRJbnRlcnZhbChoLDIwMCkpOmIuZXZlbnRzLm9uKFxcXCJ3aW5kb3cua2V5dXBcXFwiLGgpLGIuZXZlbnRzLm9uKFxcXCJrZXlkb3duXFxcIixmdW5jdGlvbihiKXtiJiZiLndoaWNoPT1hLkZFLktFWUNPREUuRVNDJiZpKCl9KSxiLmV2ZW50cy4kb24oYi4kd3AsXFxcInNjcm9sbC50b29sYmFyXFxcIixoKSxiLmV2ZW50cy5vbihcXFwiY29tbWFuZHMuYWZ0ZXJcXFwiLGgpLGIuaGVscGVycy5pc01vYmlsZSgpJiYoYi5ldmVudHMuJG9uKGIuJGRvYyxcXFwic2VsZWN0aW9uY2hhbmdlXFxcIixoKSxiLmV2ZW50cy4kb24oYi4kZG9jLFxcXCJvcmllbnRhdGlvbmNoYW5nZVxcXCIsaCkpfWZ1bmN0aW9uIGwoKXtiLm9wdHMudG9vbGJhcklubGluZT8oYShiLm9wdHMuc2Nyb2xsYWJsZUNvbnRhaW5lcikuYXBwZW5kKGIuJHRiKSxiLiR0Yi5kYXRhKFxcXCJjb250YWluZXJcXFwiLGEoYi5vcHRzLnNjcm9sbGFibGVDb250YWluZXIpKSxiLiR0Yi5hZGRDbGFzcyhcXFwiZnItaW5saW5lXFxcIiksYi4kdGIucHJlcGVuZCgnPHNwYW4gY2xhc3M9XFxcImZyLWFycm93XFxcIj48L3NwYW4+JyksaygpLGIub3B0cy50b29sYmFyQm90dG9tPSExKTooYi5vcHRzLnRvb2xiYXJCb3R0b20mJiFiLmhlbHBlcnMuaXNJT1MoKT8oYi4kYm94LmFwcGVuZChiLiR0YiksYi4kdGIuYWRkQ2xhc3MoXFxcImZyLWJvdHRvbVxcXCIpLGIuJGJveC5hZGRDbGFzcyhcXFwiZnItYm90dG9tXFxcIikpOihiLm9wdHMudG9vbGJhckJvdHRvbT0hMSxiLiRib3gucHJlcGVuZChiLiR0YiksYi4kdGIuYWRkQ2xhc3MoXFxcImZyLXRvcFxcXCIpLGIuJGJveC5hZGRDbGFzcyhcXFwiZnItdG9wXFxcIikpLGIuJHRiLmFkZENsYXNzKFxcXCJmci1iYXNpY1xcXCIpLGIub3B0cy50b29sYmFyU3RpY2t5JiYoYi5vcHRzLnRvb2xiYXJTdGlja3lPZmZzZXQmJihiLm9wdHMudG9vbGJhckJvdHRvbT9iLiR0Yi5jc3MoXFxcImJvdHRvbVxcXCIsYi5vcHRzLnRvb2xiYXJTdGlja3lPZmZzZXQpOmIuJHRiLmNzcyhcXFwidG9wXFxcIixiLm9wdHMudG9vbGJhclN0aWNreU9mZnNldCkpLGIucG9zaXRpb24uYWRkU3RpY2t5KGIuJHRiKSkpfWZ1bmN0aW9uIG0oKXtiLiR0Yi5odG1sKFxcXCJcXFwiKS5yZW1vdmVEYXRhKCkucmVtb3ZlKCksYi4kdGI9bnVsbH1mdW5jdGlvbiBuKCl7Yi4kYm94LnJlbW92ZUNsYXNzKFxcXCJmci10b3AgZnItYm90dG9tIGZyLWlubGluZSBmci1iYXNpY1xcXCIpLGIuJGJveC5maW5kKFxcXCIuZnItc3RpY2t5LWR1bW15XFxcIikucmVtb3ZlKCl9ZnVuY3Rpb24gbygpe2Iub3B0cy50aGVtZSYmYi4kdGIuYWRkQ2xhc3MoYi5vcHRzLnRoZW1lK1xcXCItdGhlbWVcXFwiKSxiLm9wdHMuekluZGV4PjEmJmIuJHRiLmNzcyhcXFwiei1pbmRleFxcXCIsYi5vcHRzLnpJbmRleCsxKSxcXFwiYXV0b1xcXCIhPWIub3B0cy5kaXJlY3Rpb24mJmIuJHRiLnJlbW92ZUNsYXNzKFxcXCJmci1sdHIgZnItcnRsXFxcIikuYWRkQ2xhc3MoXFxcImZyLVxcXCIrYi5vcHRzLmRpcmVjdGlvbiksYi5oZWxwZXJzLmlzTW9iaWxlKCk/Yi4kdGIuYWRkQ2xhc3MoXFxcImZyLW1vYmlsZVxcXCIpOmIuJHRiLmFkZENsYXNzKFxcXCJmci1kZXNrdG9wXFxcIiksYi5vcHRzLnRvb2xiYXJDb250YWluZXI/KGIub3B0cy50b29sYmFySW5saW5lJiYoaygpLGkoKSksYi5vcHRzLnRvb2xiYXJCb3R0b20/Yi4kdGIuYWRkQ2xhc3MoXFxcImZyLWJvdHRvbVxcXCIpOmIuJHRiLmFkZENsYXNzKFxcXCJmci10b3BcXFwiKSk6bCgpLHM9Yi4kdGIuZ2V0KDApLm93bmVyRG9jdW1lbnQsdD1cXFwiZGVmYXVsdFZpZXdcXFwiaW4gcz9zLmRlZmF1bHRWaWV3OnMucGFyZW50V2luZG93LGQoKSxnKCksYi5ldmVudHMuJG9uKGIuJHRiLGIuX21vdXNlZG93bitcXFwiIFxcXCIrYi5fbW91c2V1cCxmdW5jdGlvbihhKXt2YXIgYz1hLm9yaWdpbmFsRXZlbnQ/YS5vcmlnaW5hbEV2ZW50LnRhcmdldHx8YS5vcmlnaW5hbEV2ZW50Lm9yaWdpbmFsVGFyZ2V0Om51bGw7cmV0dXJuIGMmJlxcXCJJTlBVVFxcXCIhPWMudGFnTmFtZSYmIWIuZWRpdC5pc0Rpc2FibGVkKCk/KGEuc3RvcFByb3BhZ2F0aW9uKCksYS5wcmV2ZW50RGVmYXVsdCgpLCExKTp2b2lkIDB9LCEwKX1mdW5jdGlvbiBwKCl7cmV0dXJuIGIuJHdwPyhiLm9wdHMudG9vbGJhckNvbnRhaW5lcj8oYi5zaGFyZWQuJHRiPyhiLiR0Yj1iLnNoYXJlZC4kdGIsYi5vcHRzLnRvb2xiYXJJbmxpbmUmJmsoKSk6KGIuc2hhcmVkLiR0Yj1hKCc8ZGl2IGNsYXNzPVxcXCJmci10b29sYmFyXFxcIj48L2Rpdj4nKSxiLiR0Yj1iLnNoYXJlZC4kdGIsYShiLm9wdHMudG9vbGJhckNvbnRhaW5lcikuYXBwZW5kKGIuJHRiKSxvKCksYi4kdGIuZGF0YShcXFwiaW5zdGFuY2VcXFwiLGIpKSxiLm9wdHMudG9vbGJhcklubGluZT9iLiRib3guYWRkQ2xhc3MoXFxcImZyLWlubGluZVxcXCIpOmIuJGJveC5hZGRDbGFzcyhcXFwiZnItYmFzaWNcXFwiKSxiLmV2ZW50cy5vbihcXFwiZm9jdXNcXFwiLGZ1bmN0aW9uKCl7Yi4kdGIuZGF0YShcXFwiaW5zdGFuY2VcXFwiLGIpfSwhMCksYi5vcHRzLnRvb2xiYXJJbmxpbmU9ITEpOmIub3B0cy50b29sYmFySW5saW5lPyhiLiRib3guYWRkQ2xhc3MoXFxcImZyLWlubGluZVxcXCIpLGIuc2hhcmVkLiR0Yj8oYi4kdGI9Yi5zaGFyZWQuJHRiLGsoKSk6KGIuc2hhcmVkLiR0Yj1hKCc8ZGl2IGNsYXNzPVxcXCJmci10b29sYmFyXFxcIj48L2Rpdj4nKSxiLiR0Yj1iLnNoYXJlZC4kdGIsbygpKSk6KGIuJGJveC5hZGRDbGFzcyhcXFwiZnItYmFzaWNcXFwiKSxiLiR0Yj1hKCc8ZGl2IGNsYXNzPVxcXCJmci10b29sYmFyXFxcIj48L2Rpdj4nKSxvKCksYi4kdGIuZGF0YShcXFwiaW5zdGFuY2VcXFwiLGIpKSxiLmV2ZW50cy5vbihcXFwiZGVzdHJveVxcXCIsbiwhMCksdm9pZCBiLmV2ZW50cy5vbihiLm9wdHMudG9vbGJhcklubGluZT9cXFwic2hhcmVkLmRlc3Ryb3lcXFwiOlxcXCJkZXN0cm95XFxcIixtLCEwKSk6ITF9ZnVuY3Rpb24gcSgpeyF2JiZiLiR0YiYmKGIuJHRiLmZpbmQoXFxcIj4gLmZyLWNvbW1hbmRcXFwiKS5hZGRDbGFzcyhcXFwiZnItZGlzYWJsZWQgZnItbm8tcmVmcmVzaFxcXCIpLHY9ITApfWZ1bmN0aW9uIHIoKXt2JiZiLiR0YiYmKGIuJHRiLmZpbmQoXFxcIj4gLmZyLWNvbW1hbmRcXFwiKS5yZW1vdmVDbGFzcyhcXFwiZnItZGlzYWJsZWQgZnItbm8tcmVmcmVzaFxcXCIpLHY9ITEpLGIuYnV0dG9uLmJ1bGtSZWZyZXNoKCl9dmFyIHMsdCx1PVtdO3VbYS5GRS5YU109Yi5vcHRzLnRvb2xiYXJCdXR0b25zWFN8fGIub3B0cy50b29sYmFyQnV0dG9ucyx1W2EuRkUuU01dPWIub3B0cy50b29sYmFyQnV0dG9uc1NNfHxiLm9wdHMudG9vbGJhckJ1dHRvbnMsdVthLkZFLk1EXT1iLm9wdHMudG9vbGJhckJ1dHRvbnNNRHx8Yi5vcHRzLnRvb2xiYXJCdXR0b25zLHVbYS5GRS5MR109Yi5vcHRzLnRvb2xiYXJCdXR0b25zO3ZhciB2PSExO3JldHVybntfaW5pdDpwLGhpZGU6aSxzaG93Omosc2hvd0lubGluZTpoLGRpc2FibGU6cSxlbmFibGU6cn19fSk7XCJcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yYXctbG9hZGVyIS4vfi9mcm9hbGEtZWRpdG9yL2pzL2Zyb2FsYV9lZGl0b3IubWluLmpzXG4gKiogbW9kdWxlIGlkID0gM1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIl0sIm1hcHBpbmdzIjoiQUFBQSIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	eval("__webpack_require__(2)(__webpack_require__(5))//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL34vY29kZW1pcnJvci9saWIvY29kZW1pcnJvci5qcz8yNTI1Il0sInNvdXJjZXNDb250ZW50IjpbInJlcXVpcmUoXCIhIS92YXIvYXBwL3dlYi9qcy9ub2RlX21vZHVsZXMvc2NyaXB0LWxvYWRlci9hZGRTY3JpcHQuanNcIikocmVxdWlyZShcIiEhL3Zhci9hcHAvd2ViL2pzL25vZGVfbW9kdWxlcy9yYXctbG9hZGVyL2luZGV4LmpzIS92YXIvYXBwL3dlYi9qcy9ub2RlX21vZHVsZXMvY29kZW1pcnJvci9saWIvY29kZW1pcnJvci5qc1wiKSlcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9zY3JpcHQtbG9hZGVyIS4vfi9jb2RlbWlycm9yL2xpYi9jb2RlbWlycm9yLmpzXG4gKiogbW9kdWxlIGlkID0gNFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIl0sIm1hcHBpbmdzIjoiQUFBQSIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 5 */
/***/ function(module, exports) {

	eval("module.exports = \"// CodeMirror, copyright (c) by Marijn Haverbeke and others\\n// Distributed under an MIT license: http://codemirror.net/LICENSE\\n\\n// This is CodeMirror (http://codemirror.net), a code editor\\n// implemented in JavaScript on top of the browser's DOM.\\n//\\n// You can find some technical background for some of the code below\\n// at http://marijnhaverbeke.nl/blog/#cm-internals .\\n\\n(function(mod) {\\n  if (typeof exports == \\\"object\\\" && typeof module == \\\"object\\\") // CommonJS\\n    module.exports = mod();\\n  else if (typeof define == \\\"function\\\" && define.amd) // AMD\\n    return define([], mod);\\n  else // Plain browser env\\n    (this || window).CodeMirror = mod();\\n})(function() {\\n  \\\"use strict\\\";\\n\\n  // BROWSER SNIFFING\\n\\n  // Kludges for bugs and behavior differences that can't be feature\\n  // detected are enabled based on userAgent etc sniffing.\\n  var userAgent = navigator.userAgent;\\n  var platform = navigator.platform;\\n\\n  var gecko = /gecko\\\\/\\\\d/i.test(userAgent);\\n  var ie_upto10 = /MSIE \\\\d/.test(userAgent);\\n  var ie_11up = /Trident\\\\/(?:[7-9]|\\\\d{2,})\\\\..*rv:(\\\\d+)/.exec(userAgent);\\n  var ie = ie_upto10 || ie_11up;\\n  var ie_version = ie && (ie_upto10 ? document.documentMode || 6 : ie_11up[1]);\\n  var webkit = /WebKit\\\\//.test(userAgent);\\n  var qtwebkit = webkit && /Qt\\\\/\\\\d+\\\\.\\\\d+/.test(userAgent);\\n  var chrome = /Chrome\\\\//.test(userAgent);\\n  var presto = /Opera\\\\//.test(userAgent);\\n  var safari = /Apple Computer/.test(navigator.vendor);\\n  var mac_geMountainLion = /Mac OS X 1\\\\d\\\\D([8-9]|\\\\d\\\\d)\\\\D/.test(userAgent);\\n  var phantom = /PhantomJS/.test(userAgent);\\n\\n  var ios = /AppleWebKit/.test(userAgent) && /Mobile\\\\/\\\\w+/.test(userAgent);\\n  // This is woefully incomplete. Suggestions for alternative methods welcome.\\n  var mobile = ios || /Android|webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(userAgent);\\n  var mac = ios || /Mac/.test(platform);\\n  var chromeOS = /\\\\bCrOS\\\\b/.test(userAgent);\\n  var windows = /win/i.test(platform);\\n\\n  var presto_version = presto && userAgent.match(/Version\\\\/(\\\\d*\\\\.\\\\d*)/);\\n  if (presto_version) presto_version = Number(presto_version[1]);\\n  if (presto_version && presto_version >= 15) { presto = false; webkit = true; }\\n  // Some browsers use the wrong event properties to signal cmd/ctrl on OS X\\n  var flipCtrlCmd = mac && (qtwebkit || presto && (presto_version == null || presto_version < 12.11));\\n  var captureRightClick = gecko || (ie && ie_version >= 9);\\n\\n  // Optimize some code when these features are not used.\\n  var sawReadOnlySpans = false, sawCollapsedSpans = false;\\n\\n  // EDITOR CONSTRUCTOR\\n\\n  // A CodeMirror instance represents an editor. This is the object\\n  // that user code is usually dealing with.\\n\\n  function CodeMirror(place, options) {\\n    if (!(this instanceof CodeMirror)) return new CodeMirror(place, options);\\n\\n    this.options = options = options ? copyObj(options) : {};\\n    // Determine effective options based on given values and defaults.\\n    copyObj(defaults, options, false);\\n    setGuttersForLineNumbers(options);\\n\\n    var doc = options.value;\\n    if (typeof doc == \\\"string\\\") doc = new Doc(doc, options.mode, null, options.lineSeparator);\\n    this.doc = doc;\\n\\n    var input = new CodeMirror.inputStyles[options.inputStyle](this);\\n    var display = this.display = new Display(place, doc, input);\\n    display.wrapper.CodeMirror = this;\\n    updateGutters(this);\\n    themeChanged(this);\\n    if (options.lineWrapping)\\n      this.display.wrapper.className += \\\" CodeMirror-wrap\\\";\\n    if (options.autofocus && !mobile) display.input.focus();\\n    initScrollbars(this);\\n\\n    this.state = {\\n      keyMaps: [],  // stores maps added by addKeyMap\\n      overlays: [], // highlighting overlays, as added by addOverlay\\n      modeGen: 0,   // bumped when mode/overlay changes, used to invalidate highlighting info\\n      overwrite: false,\\n      delayingBlurEvent: false,\\n      focused: false,\\n      suppressEdits: false, // used to disable editing during key handlers when in readOnly mode\\n      pasteIncoming: false, cutIncoming: false, // help recognize paste/cut edits in input.poll\\n      selectingText: false,\\n      draggingText: false,\\n      highlight: new Delayed(), // stores highlight worker timeout\\n      keySeq: null,  // Unfinished key sequence\\n      specialChars: null\\n    };\\n\\n    var cm = this;\\n\\n    // Override magic textarea content restore that IE sometimes does\\n    // on our hidden textarea on reload\\n    if (ie && ie_version < 11) setTimeout(function() { cm.display.input.reset(true); }, 20);\\n\\n    registerEventHandlers(this);\\n    ensureGlobalHandlers();\\n\\n    startOperation(this);\\n    this.curOp.forceUpdate = true;\\n    attachDoc(this, doc);\\n\\n    if ((options.autofocus && !mobile) || cm.hasFocus())\\n      setTimeout(bind(onFocus, this), 20);\\n    else\\n      onBlur(this);\\n\\n    for (var opt in optionHandlers) if (optionHandlers.hasOwnProperty(opt))\\n      optionHandlers[opt](this, options[opt], Init);\\n    maybeUpdateLineNumberWidth(this);\\n    if (options.finishInit) options.finishInit(this);\\n    for (var i = 0; i < initHooks.length; ++i) initHooks[i](this);\\n    endOperation(this);\\n    // Suppress optimizelegibility in Webkit, since it breaks text\\n    // measuring on line wrapping boundaries.\\n    if (webkit && options.lineWrapping &&\\n        getComputedStyle(display.lineDiv).textRendering == \\\"optimizelegibility\\\")\\n      display.lineDiv.style.textRendering = \\\"auto\\\";\\n  }\\n\\n  // DISPLAY CONSTRUCTOR\\n\\n  // The display handles the DOM integration, both for input reading\\n  // and content drawing. It holds references to DOM nodes and\\n  // display-related state.\\n\\n  function Display(place, doc, input) {\\n    var d = this;\\n    this.input = input;\\n\\n    // Covers bottom-right square when both scrollbars are present.\\n    d.scrollbarFiller = elt(\\\"div\\\", null, \\\"CodeMirror-scrollbar-filler\\\");\\n    d.scrollbarFiller.setAttribute(\\\"cm-not-content\\\", \\\"true\\\");\\n    // Covers bottom of gutter when coverGutterNextToScrollbar is on\\n    // and h scrollbar is present.\\n    d.gutterFiller = elt(\\\"div\\\", null, \\\"CodeMirror-gutter-filler\\\");\\n    d.gutterFiller.setAttribute(\\\"cm-not-content\\\", \\\"true\\\");\\n    // Will contain the actual code, positioned to cover the viewport.\\n    d.lineDiv = elt(\\\"div\\\", null, \\\"CodeMirror-code\\\");\\n    // Elements are added to these to represent selection and cursors.\\n    d.selectionDiv = elt(\\\"div\\\", null, null, \\\"position: relative; z-index: 1\\\");\\n    d.cursorDiv = elt(\\\"div\\\", null, \\\"CodeMirror-cursors\\\");\\n    // A visibility: hidden element used to find the size of things.\\n    d.measure = elt(\\\"div\\\", null, \\\"CodeMirror-measure\\\");\\n    // When lines outside of the viewport are measured, they are drawn in this.\\n    d.lineMeasure = elt(\\\"div\\\", null, \\\"CodeMirror-measure\\\");\\n    // Wraps everything that needs to exist inside the vertically-padded coordinate system\\n    d.lineSpace = elt(\\\"div\\\", [d.measure, d.lineMeasure, d.selectionDiv, d.cursorDiv, d.lineDiv],\\n                      null, \\\"position: relative; outline: none\\\");\\n    // Moved around its parent to cover visible view.\\n    d.mover = elt(\\\"div\\\", [elt(\\\"div\\\", [d.lineSpace], \\\"CodeMirror-lines\\\")], null, \\\"position: relative\\\");\\n    // Set to the height of the document, allowing scrolling.\\n    d.sizer = elt(\\\"div\\\", [d.mover], \\\"CodeMirror-sizer\\\");\\n    d.sizerWidth = null;\\n    // Behavior of elts with overflow: auto and padding is\\n    // inconsistent across browsers. This is used to ensure the\\n    // scrollable area is big enough.\\n    d.heightForcer = elt(\\\"div\\\", null, null, \\\"position: absolute; height: \\\" + scrollerGap + \\\"px; width: 1px;\\\");\\n    // Will contain the gutters, if any.\\n    d.gutters = elt(\\\"div\\\", null, \\\"CodeMirror-gutters\\\");\\n    d.lineGutter = null;\\n    // Actual scrollable element.\\n    d.scroller = elt(\\\"div\\\", [d.sizer, d.heightForcer, d.gutters], \\\"CodeMirror-scroll\\\");\\n    d.scroller.setAttribute(\\\"tabIndex\\\", \\\"-1\\\");\\n    // The element in which the editor lives.\\n    d.wrapper = elt(\\\"div\\\", [d.scrollbarFiller, d.gutterFiller, d.scroller], \\\"CodeMirror\\\");\\n\\n    // Work around IE7 z-index bug (not perfect, hence IE7 not really being supported)\\n    if (ie && ie_version < 8) { d.gutters.style.zIndex = -1; d.scroller.style.paddingRight = 0; }\\n    if (!webkit && !(gecko && mobile)) d.scroller.draggable = true;\\n\\n    if (place) {\\n      if (place.appendChild) place.appendChild(d.wrapper);\\n      else place(d.wrapper);\\n    }\\n\\n    // Current rendered range (may be bigger than the view window).\\n    d.viewFrom = d.viewTo = doc.first;\\n    d.reportedViewFrom = d.reportedViewTo = doc.first;\\n    // Information about the rendered lines.\\n    d.view = [];\\n    d.renderedView = null;\\n    // Holds info about a single rendered line when it was rendered\\n    // for measurement, while not in view.\\n    d.externalMeasured = null;\\n    // Empty space (in pixels) above the view\\n    d.viewOffset = 0;\\n    d.lastWrapHeight = d.lastWrapWidth = 0;\\n    d.updateLineNumbers = null;\\n\\n    d.nativeBarWidth = d.barHeight = d.barWidth = 0;\\n    d.scrollbarsClipped = false;\\n\\n    // Used to only resize the line number gutter when necessary (when\\n    // the amount of lines crosses a boundary that makes its width change)\\n    d.lineNumWidth = d.lineNumInnerWidth = d.lineNumChars = null;\\n    // Set to true when a non-horizontal-scrolling line widget is\\n    // added. As an optimization, line widget aligning is skipped when\\n    // this is false.\\n    d.alignWidgets = false;\\n\\n    d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;\\n\\n    // Tracks the maximum line length so that the horizontal scrollbar\\n    // can be kept static when scrolling.\\n    d.maxLine = null;\\n    d.maxLineLength = 0;\\n    d.maxLineChanged = false;\\n\\n    // Used for measuring wheel scrolling granularity\\n    d.wheelDX = d.wheelDY = d.wheelStartX = d.wheelStartY = null;\\n\\n    // True when shift is held down.\\n    d.shift = false;\\n\\n    // Used to track whether anything happened since the context menu\\n    // was opened.\\n    d.selForContextMenu = null;\\n\\n    d.activeTouch = null;\\n\\n    input.init(d);\\n  }\\n\\n  // STATE UPDATES\\n\\n  // Used to get the editor into a consistent state again when options change.\\n\\n  function loadMode(cm) {\\n    cm.doc.mode = CodeMirror.getMode(cm.options, cm.doc.modeOption);\\n    resetModeState(cm);\\n  }\\n\\n  function resetModeState(cm) {\\n    cm.doc.iter(function(line) {\\n      if (line.stateAfter) line.stateAfter = null;\\n      if (line.styles) line.styles = null;\\n    });\\n    cm.doc.frontier = cm.doc.first;\\n    startWorker(cm, 100);\\n    cm.state.modeGen++;\\n    if (cm.curOp) regChange(cm);\\n  }\\n\\n  function wrappingChanged(cm) {\\n    if (cm.options.lineWrapping) {\\n      addClass(cm.display.wrapper, \\\"CodeMirror-wrap\\\");\\n      cm.display.sizer.style.minWidth = \\\"\\\";\\n      cm.display.sizerWidth = null;\\n    } else {\\n      rmClass(cm.display.wrapper, \\\"CodeMirror-wrap\\\");\\n      findMaxLine(cm);\\n    }\\n    estimateLineHeights(cm);\\n    regChange(cm);\\n    clearCaches(cm);\\n    setTimeout(function(){updateScrollbars(cm);}, 100);\\n  }\\n\\n  // Returns a function that estimates the height of a line, to use as\\n  // first approximation until the line becomes visible (and is thus\\n  // properly measurable).\\n  function estimateHeight(cm) {\\n    var th = textHeight(cm.display), wrapping = cm.options.lineWrapping;\\n    var perLine = wrapping && Math.max(5, cm.display.scroller.clientWidth / charWidth(cm.display) - 3);\\n    return function(line) {\\n      if (lineIsHidden(cm.doc, line)) return 0;\\n\\n      var widgetsHeight = 0;\\n      if (line.widgets) for (var i = 0; i < line.widgets.length; i++) {\\n        if (line.widgets[i].height) widgetsHeight += line.widgets[i].height;\\n      }\\n\\n      if (wrapping)\\n        return widgetsHeight + (Math.ceil(line.text.length / perLine) || 1) * th;\\n      else\\n        return widgetsHeight + th;\\n    };\\n  }\\n\\n  function estimateLineHeights(cm) {\\n    var doc = cm.doc, est = estimateHeight(cm);\\n    doc.iter(function(line) {\\n      var estHeight = est(line);\\n      if (estHeight != line.height) updateLineHeight(line, estHeight);\\n    });\\n  }\\n\\n  function themeChanged(cm) {\\n    cm.display.wrapper.className = cm.display.wrapper.className.replace(/\\\\s*cm-s-\\\\S+/g, \\\"\\\") +\\n      cm.options.theme.replace(/(^|\\\\s)\\\\s*/g, \\\" cm-s-\\\");\\n    clearCaches(cm);\\n  }\\n\\n  function guttersChanged(cm) {\\n    updateGutters(cm);\\n    regChange(cm);\\n    setTimeout(function(){alignHorizontally(cm);}, 20);\\n  }\\n\\n  // Rebuild the gutter elements, ensure the margin to the left of the\\n  // code matches their width.\\n  function updateGutters(cm) {\\n    var gutters = cm.display.gutters, specs = cm.options.gutters;\\n    removeChildren(gutters);\\n    for (var i = 0; i < specs.length; ++i) {\\n      var gutterClass = specs[i];\\n      var gElt = gutters.appendChild(elt(\\\"div\\\", null, \\\"CodeMirror-gutter \\\" + gutterClass));\\n      if (gutterClass == \\\"CodeMirror-linenumbers\\\") {\\n        cm.display.lineGutter = gElt;\\n        gElt.style.width = (cm.display.lineNumWidth || 1) + \\\"px\\\";\\n      }\\n    }\\n    gutters.style.display = i ? \\\"\\\" : \\\"none\\\";\\n    updateGutterSpace(cm);\\n  }\\n\\n  function updateGutterSpace(cm) {\\n    var width = cm.display.gutters.offsetWidth;\\n    cm.display.sizer.style.marginLeft = width + \\\"px\\\";\\n  }\\n\\n  // Compute the character length of a line, taking into account\\n  // collapsed ranges (see markText) that might hide parts, and join\\n  // other lines onto it.\\n  function lineLength(line) {\\n    if (line.height == 0) return 0;\\n    var len = line.text.length, merged, cur = line;\\n    while (merged = collapsedSpanAtStart(cur)) {\\n      var found = merged.find(0, true);\\n      cur = found.from.line;\\n      len += found.from.ch - found.to.ch;\\n    }\\n    cur = line;\\n    while (merged = collapsedSpanAtEnd(cur)) {\\n      var found = merged.find(0, true);\\n      len -= cur.text.length - found.from.ch;\\n      cur = found.to.line;\\n      len += cur.text.length - found.to.ch;\\n    }\\n    return len;\\n  }\\n\\n  // Find the longest line in the document.\\n  function findMaxLine(cm) {\\n    var d = cm.display, doc = cm.doc;\\n    d.maxLine = getLine(doc, doc.first);\\n    d.maxLineLength = lineLength(d.maxLine);\\n    d.maxLineChanged = true;\\n    doc.iter(function(line) {\\n      var len = lineLength(line);\\n      if (len > d.maxLineLength) {\\n        d.maxLineLength = len;\\n        d.maxLine = line;\\n      }\\n    });\\n  }\\n\\n  // Make sure the gutters options contains the element\\n  // \\\"CodeMirror-linenumbers\\\" when the lineNumbers option is true.\\n  function setGuttersForLineNumbers(options) {\\n    var found = indexOf(options.gutters, \\\"CodeMirror-linenumbers\\\");\\n    if (found == -1 && options.lineNumbers) {\\n      options.gutters = options.gutters.concat([\\\"CodeMirror-linenumbers\\\"]);\\n    } else if (found > -1 && !options.lineNumbers) {\\n      options.gutters = options.gutters.slice(0);\\n      options.gutters.splice(found, 1);\\n    }\\n  }\\n\\n  // SCROLLBARS\\n\\n  // Prepare DOM reads needed to update the scrollbars. Done in one\\n  // shot to minimize update/measure roundtrips.\\n  function measureForScrollbars(cm) {\\n    var d = cm.display, gutterW = d.gutters.offsetWidth;\\n    var docH = Math.round(cm.doc.height + paddingVert(cm.display));\\n    return {\\n      clientHeight: d.scroller.clientHeight,\\n      viewHeight: d.wrapper.clientHeight,\\n      scrollWidth: d.scroller.scrollWidth, clientWidth: d.scroller.clientWidth,\\n      viewWidth: d.wrapper.clientWidth,\\n      barLeft: cm.options.fixedGutter ? gutterW : 0,\\n      docHeight: docH,\\n      scrollHeight: docH + scrollGap(cm) + d.barHeight,\\n      nativeBarWidth: d.nativeBarWidth,\\n      gutterWidth: gutterW\\n    };\\n  }\\n\\n  function NativeScrollbars(place, scroll, cm) {\\n    this.cm = cm;\\n    var vert = this.vert = elt(\\\"div\\\", [elt(\\\"div\\\", null, null, \\\"min-width: 1px\\\")], \\\"CodeMirror-vscrollbar\\\");\\n    var horiz = this.horiz = elt(\\\"div\\\", [elt(\\\"div\\\", null, null, \\\"height: 100%; min-height: 1px\\\")], \\\"CodeMirror-hscrollbar\\\");\\n    place(vert); place(horiz);\\n\\n    on(vert, \\\"scroll\\\", function() {\\n      if (vert.clientHeight) scroll(vert.scrollTop, \\\"vertical\\\");\\n    });\\n    on(horiz, \\\"scroll\\\", function() {\\n      if (horiz.clientWidth) scroll(horiz.scrollLeft, \\\"horizontal\\\");\\n    });\\n\\n    this.checkedZeroWidth = false;\\n    // Need to set a minimum width to see the scrollbar on IE7 (but must not set it on IE8).\\n    if (ie && ie_version < 8) this.horiz.style.minHeight = this.vert.style.minWidth = \\\"18px\\\";\\n  }\\n\\n  NativeScrollbars.prototype = copyObj({\\n    update: function(measure) {\\n      var needsH = measure.scrollWidth > measure.clientWidth + 1;\\n      var needsV = measure.scrollHeight > measure.clientHeight + 1;\\n      var sWidth = measure.nativeBarWidth;\\n\\n      if (needsV) {\\n        this.vert.style.display = \\\"block\\\";\\n        this.vert.style.bottom = needsH ? sWidth + \\\"px\\\" : \\\"0\\\";\\n        var totalHeight = measure.viewHeight - (needsH ? sWidth : 0);\\n        // A bug in IE8 can cause this value to be negative, so guard it.\\n        this.vert.firstChild.style.height =\\n          Math.max(0, measure.scrollHeight - measure.clientHeight + totalHeight) + \\\"px\\\";\\n      } else {\\n        this.vert.style.display = \\\"\\\";\\n        this.vert.firstChild.style.height = \\\"0\\\";\\n      }\\n\\n      if (needsH) {\\n        this.horiz.style.display = \\\"block\\\";\\n        this.horiz.style.right = needsV ? sWidth + \\\"px\\\" : \\\"0\\\";\\n        this.horiz.style.left = measure.barLeft + \\\"px\\\";\\n        var totalWidth = measure.viewWidth - measure.barLeft - (needsV ? sWidth : 0);\\n        this.horiz.firstChild.style.width =\\n          (measure.scrollWidth - measure.clientWidth + totalWidth) + \\\"px\\\";\\n      } else {\\n        this.horiz.style.display = \\\"\\\";\\n        this.horiz.firstChild.style.width = \\\"0\\\";\\n      }\\n\\n      if (!this.checkedZeroWidth && measure.clientHeight > 0) {\\n        if (sWidth == 0) this.zeroWidthHack();\\n        this.checkedZeroWidth = true;\\n      }\\n\\n      return {right: needsV ? sWidth : 0, bottom: needsH ? sWidth : 0};\\n    },\\n    setScrollLeft: function(pos) {\\n      if (this.horiz.scrollLeft != pos) this.horiz.scrollLeft = pos;\\n      if (this.disableHoriz) this.enableZeroWidthBar(this.horiz, this.disableHoriz);\\n    },\\n    setScrollTop: function(pos) {\\n      if (this.vert.scrollTop != pos) this.vert.scrollTop = pos;\\n      if (this.disableVert) this.enableZeroWidthBar(this.vert, this.disableVert);\\n    },\\n    zeroWidthHack: function() {\\n      var w = mac && !mac_geMountainLion ? \\\"12px\\\" : \\\"18px\\\";\\n      this.horiz.style.height = this.vert.style.width = w;\\n      this.horiz.style.pointerEvents = this.vert.style.pointerEvents = \\\"none\\\";\\n      this.disableHoriz = new Delayed;\\n      this.disableVert = new Delayed;\\n    },\\n    enableZeroWidthBar: function(bar, delay) {\\n      bar.style.pointerEvents = \\\"auto\\\";\\n      function maybeDisable() {\\n        // To find out whether the scrollbar is still visible, we\\n        // check whether the element under the pixel in the bottom\\n        // left corner of the scrollbar box is the scrollbar box\\n        // itself (when the bar is still visible) or its filler child\\n        // (when the bar is hidden). If it is still visible, we keep\\n        // it enabled, if it's hidden, we disable pointer events.\\n        var box = bar.getBoundingClientRect();\\n        var elt = document.elementFromPoint(box.left + 1, box.bottom - 1);\\n        if (elt != bar) bar.style.pointerEvents = \\\"none\\\";\\n        else delay.set(1000, maybeDisable);\\n      }\\n      delay.set(1000, maybeDisable);\\n    },\\n    clear: function() {\\n      var parent = this.horiz.parentNode;\\n      parent.removeChild(this.horiz);\\n      parent.removeChild(this.vert);\\n    }\\n  }, NativeScrollbars.prototype);\\n\\n  function NullScrollbars() {}\\n\\n  NullScrollbars.prototype = copyObj({\\n    update: function() { return {bottom: 0, right: 0}; },\\n    setScrollLeft: function() {},\\n    setScrollTop: function() {},\\n    clear: function() {}\\n  }, NullScrollbars.prototype);\\n\\n  CodeMirror.scrollbarModel = {\\\"native\\\": NativeScrollbars, \\\"null\\\": NullScrollbars};\\n\\n  function initScrollbars(cm) {\\n    if (cm.display.scrollbars) {\\n      cm.display.scrollbars.clear();\\n      if (cm.display.scrollbars.addClass)\\n        rmClass(cm.display.wrapper, cm.display.scrollbars.addClass);\\n    }\\n\\n    cm.display.scrollbars = new CodeMirror.scrollbarModel[cm.options.scrollbarStyle](function(node) {\\n      cm.display.wrapper.insertBefore(node, cm.display.scrollbarFiller);\\n      // Prevent clicks in the scrollbars from killing focus\\n      on(node, \\\"mousedown\\\", function() {\\n        if (cm.state.focused) setTimeout(function() { cm.display.input.focus(); }, 0);\\n      });\\n      node.setAttribute(\\\"cm-not-content\\\", \\\"true\\\");\\n    }, function(pos, axis) {\\n      if (axis == \\\"horizontal\\\") setScrollLeft(cm, pos);\\n      else setScrollTop(cm, pos);\\n    }, cm);\\n    if (cm.display.scrollbars.addClass)\\n      addClass(cm.display.wrapper, cm.display.scrollbars.addClass);\\n  }\\n\\n  function updateScrollbars(cm, measure) {\\n    if (!measure) measure = measureForScrollbars(cm);\\n    var startWidth = cm.display.barWidth, startHeight = cm.display.barHeight;\\n    updateScrollbarsInner(cm, measure);\\n    for (var i = 0; i < 4 && startWidth != cm.display.barWidth || startHeight != cm.display.barHeight; i++) {\\n      if (startWidth != cm.display.barWidth && cm.options.lineWrapping)\\n        updateHeightsInViewport(cm);\\n      updateScrollbarsInner(cm, measureForScrollbars(cm));\\n      startWidth = cm.display.barWidth; startHeight = cm.display.barHeight;\\n    }\\n  }\\n\\n  // Re-synchronize the fake scrollbars with the actual size of the\\n  // content.\\n  function updateScrollbarsInner(cm, measure) {\\n    var d = cm.display;\\n    var sizes = d.scrollbars.update(measure);\\n\\n    d.sizer.style.paddingRight = (d.barWidth = sizes.right) + \\\"px\\\";\\n    d.sizer.style.paddingBottom = (d.barHeight = sizes.bottom) + \\\"px\\\";\\n    d.heightForcer.style.borderBottom = sizes.bottom + \\\"px solid transparent\\\"\\n\\n    if (sizes.right && sizes.bottom) {\\n      d.scrollbarFiller.style.display = \\\"block\\\";\\n      d.scrollbarFiller.style.height = sizes.bottom + \\\"px\\\";\\n      d.scrollbarFiller.style.width = sizes.right + \\\"px\\\";\\n    } else d.scrollbarFiller.style.display = \\\"\\\";\\n    if (sizes.bottom && cm.options.coverGutterNextToScrollbar && cm.options.fixedGutter) {\\n      d.gutterFiller.style.display = \\\"block\\\";\\n      d.gutterFiller.style.height = sizes.bottom + \\\"px\\\";\\n      d.gutterFiller.style.width = measure.gutterWidth + \\\"px\\\";\\n    } else d.gutterFiller.style.display = \\\"\\\";\\n  }\\n\\n  // Compute the lines that are visible in a given viewport (defaults\\n  // the the current scroll position). viewport may contain top,\\n  // height, and ensure (see op.scrollToPos) properties.\\n  function visibleLines(display, doc, viewport) {\\n    var top = viewport && viewport.top != null ? Math.max(0, viewport.top) : display.scroller.scrollTop;\\n    top = Math.floor(top - paddingTop(display));\\n    var bottom = viewport && viewport.bottom != null ? viewport.bottom : top + display.wrapper.clientHeight;\\n\\n    var from = lineAtHeight(doc, top), to = lineAtHeight(doc, bottom);\\n    // Ensure is a {from: {line, ch}, to: {line, ch}} object, and\\n    // forces those lines into the viewport (if possible).\\n    if (viewport && viewport.ensure) {\\n      var ensureFrom = viewport.ensure.from.line, ensureTo = viewport.ensure.to.line;\\n      if (ensureFrom < from) {\\n        from = ensureFrom;\\n        to = lineAtHeight(doc, heightAtLine(getLine(doc, ensureFrom)) + display.wrapper.clientHeight);\\n      } else if (Math.min(ensureTo, doc.lastLine()) >= to) {\\n        from = lineAtHeight(doc, heightAtLine(getLine(doc, ensureTo)) - display.wrapper.clientHeight);\\n        to = ensureTo;\\n      }\\n    }\\n    return {from: from, to: Math.max(to, from + 1)};\\n  }\\n\\n  // LINE NUMBERS\\n\\n  // Re-align line numbers and gutter marks to compensate for\\n  // horizontal scrolling.\\n  function alignHorizontally(cm) {\\n    var display = cm.display, view = display.view;\\n    if (!display.alignWidgets && (!display.gutters.firstChild || !cm.options.fixedGutter)) return;\\n    var comp = compensateForHScroll(display) - display.scroller.scrollLeft + cm.doc.scrollLeft;\\n    var gutterW = display.gutters.offsetWidth, left = comp + \\\"px\\\";\\n    for (var i = 0; i < view.length; i++) if (!view[i].hidden) {\\n      if (cm.options.fixedGutter) {\\n        if (view[i].gutter)\\n          view[i].gutter.style.left = left;\\n        if (view[i].gutterBackground)\\n          view[i].gutterBackground.style.left = left;\\n      }\\n      var align = view[i].alignable;\\n      if (align) for (var j = 0; j < align.length; j++)\\n        align[j].style.left = left;\\n    }\\n    if (cm.options.fixedGutter)\\n      display.gutters.style.left = (comp + gutterW) + \\\"px\\\";\\n  }\\n\\n  // Used to ensure that the line number gutter is still the right\\n  // size for the current document size. Returns true when an update\\n  // is needed.\\n  function maybeUpdateLineNumberWidth(cm) {\\n    if (!cm.options.lineNumbers) return false;\\n    var doc = cm.doc, last = lineNumberFor(cm.options, doc.first + doc.size - 1), display = cm.display;\\n    if (last.length != display.lineNumChars) {\\n      var test = display.measure.appendChild(elt(\\\"div\\\", [elt(\\\"div\\\", last)],\\n                                                 \\\"CodeMirror-linenumber CodeMirror-gutter-elt\\\"));\\n      var innerW = test.firstChild.offsetWidth, padding = test.offsetWidth - innerW;\\n      display.lineGutter.style.width = \\\"\\\";\\n      display.lineNumInnerWidth = Math.max(innerW, display.lineGutter.offsetWidth - padding) + 1;\\n      display.lineNumWidth = display.lineNumInnerWidth + padding;\\n      display.lineNumChars = display.lineNumInnerWidth ? last.length : -1;\\n      display.lineGutter.style.width = display.lineNumWidth + \\\"px\\\";\\n      updateGutterSpace(cm);\\n      return true;\\n    }\\n    return false;\\n  }\\n\\n  function lineNumberFor(options, i) {\\n    return String(options.lineNumberFormatter(i + options.firstLineNumber));\\n  }\\n\\n  // Computes display.scroller.scrollLeft + display.gutters.offsetWidth,\\n  // but using getBoundingClientRect to get a sub-pixel-accurate\\n  // result.\\n  function compensateForHScroll(display) {\\n    return display.scroller.getBoundingClientRect().left - display.sizer.getBoundingClientRect().left;\\n  }\\n\\n  // DISPLAY DRAWING\\n\\n  function DisplayUpdate(cm, viewport, force) {\\n    var display = cm.display;\\n\\n    this.viewport = viewport;\\n    // Store some values that we'll need later (but don't want to force a relayout for)\\n    this.visible = visibleLines(display, cm.doc, viewport);\\n    this.editorIsHidden = !display.wrapper.offsetWidth;\\n    this.wrapperHeight = display.wrapper.clientHeight;\\n    this.wrapperWidth = display.wrapper.clientWidth;\\n    this.oldDisplayWidth = displayWidth(cm);\\n    this.force = force;\\n    this.dims = getDimensions(cm);\\n    this.events = [];\\n  }\\n\\n  DisplayUpdate.prototype.signal = function(emitter, type) {\\n    if (hasHandler(emitter, type))\\n      this.events.push(arguments);\\n  };\\n  DisplayUpdate.prototype.finish = function() {\\n    for (var i = 0; i < this.events.length; i++)\\n      signal.apply(null, this.events[i]);\\n  };\\n\\n  function maybeClipScrollbars(cm) {\\n    var display = cm.display;\\n    if (!display.scrollbarsClipped && display.scroller.offsetWidth) {\\n      display.nativeBarWidth = display.scroller.offsetWidth - display.scroller.clientWidth;\\n      display.heightForcer.style.height = scrollGap(cm) + \\\"px\\\";\\n      display.sizer.style.marginBottom = -display.nativeBarWidth + \\\"px\\\";\\n      display.sizer.style.borderRightWidth = scrollGap(cm) + \\\"px\\\";\\n      display.scrollbarsClipped = true;\\n    }\\n  }\\n\\n  // Does the actual updating of the line display. Bails out\\n  // (returning false) when there is nothing to be done and forced is\\n  // false.\\n  function updateDisplayIfNeeded(cm, update) {\\n    var display = cm.display, doc = cm.doc;\\n\\n    if (update.editorIsHidden) {\\n      resetView(cm);\\n      return false;\\n    }\\n\\n    // Bail out if the visible area is already rendered and nothing changed.\\n    if (!update.force &&\\n        update.visible.from >= display.viewFrom && update.visible.to <= display.viewTo &&\\n        (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo) &&\\n        display.renderedView == display.view && countDirtyView(cm) == 0)\\n      return false;\\n\\n    if (maybeUpdateLineNumberWidth(cm)) {\\n      resetView(cm);\\n      update.dims = getDimensions(cm);\\n    }\\n\\n    // Compute a suitable new viewport (from & to)\\n    var end = doc.first + doc.size;\\n    var from = Math.max(update.visible.from - cm.options.viewportMargin, doc.first);\\n    var to = Math.min(end, update.visible.to + cm.options.viewportMargin);\\n    if (display.viewFrom < from && from - display.viewFrom < 20) from = Math.max(doc.first, display.viewFrom);\\n    if (display.viewTo > to && display.viewTo - to < 20) to = Math.min(end, display.viewTo);\\n    if (sawCollapsedSpans) {\\n      from = visualLineNo(cm.doc, from);\\n      to = visualLineEndNo(cm.doc, to);\\n    }\\n\\n    var different = from != display.viewFrom || to != display.viewTo ||\\n      display.lastWrapHeight != update.wrapperHeight || display.lastWrapWidth != update.wrapperWidth;\\n    adjustView(cm, from, to);\\n\\n    display.viewOffset = heightAtLine(getLine(cm.doc, display.viewFrom));\\n    // Position the mover div to align with the current scroll position\\n    cm.display.mover.style.top = display.viewOffset + \\\"px\\\";\\n\\n    var toUpdate = countDirtyView(cm);\\n    if (!different && toUpdate == 0 && !update.force && display.renderedView == display.view &&\\n        (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo))\\n      return false;\\n\\n    // For big changes, we hide the enclosing element during the\\n    // update, since that speeds up the operations on most browsers.\\n    var focused = activeElt();\\n    if (toUpdate > 4) display.lineDiv.style.display = \\\"none\\\";\\n    patchDisplay(cm, display.updateLineNumbers, update.dims);\\n    if (toUpdate > 4) display.lineDiv.style.display = \\\"\\\";\\n    display.renderedView = display.view;\\n    // There might have been a widget with a focused element that got\\n    // hidden or updated, if so re-focus it.\\n    if (focused && activeElt() != focused && focused.offsetHeight) focused.focus();\\n\\n    // Prevent selection and cursors from interfering with the scroll\\n    // width and height.\\n    removeChildren(display.cursorDiv);\\n    removeChildren(display.selectionDiv);\\n    display.gutters.style.height = display.sizer.style.minHeight = 0;\\n\\n    if (different) {\\n      display.lastWrapHeight = update.wrapperHeight;\\n      display.lastWrapWidth = update.wrapperWidth;\\n      startWorker(cm, 400);\\n    }\\n\\n    display.updateLineNumbers = null;\\n\\n    return true;\\n  }\\n\\n  function postUpdateDisplay(cm, update) {\\n    var viewport = update.viewport;\\n\\n    for (var first = true;; first = false) {\\n      if (!first || !cm.options.lineWrapping || update.oldDisplayWidth == displayWidth(cm)) {\\n        // Clip forced viewport to actual scrollable area.\\n        if (viewport && viewport.top != null)\\n          viewport = {top: Math.min(cm.doc.height + paddingVert(cm.display) - displayHeight(cm), viewport.top)};\\n        // Updated line heights might result in the drawn area not\\n        // actually covering the viewport. Keep looping until it does.\\n        update.visible = visibleLines(cm.display, cm.doc, viewport);\\n        if (update.visible.from >= cm.display.viewFrom && update.visible.to <= cm.display.viewTo)\\n          break;\\n      }\\n      if (!updateDisplayIfNeeded(cm, update)) break;\\n      updateHeightsInViewport(cm);\\n      var barMeasure = measureForScrollbars(cm);\\n      updateSelection(cm);\\n      updateScrollbars(cm, barMeasure);\\n      setDocumentHeight(cm, barMeasure);\\n    }\\n\\n    update.signal(cm, \\\"update\\\", cm);\\n    if (cm.display.viewFrom != cm.display.reportedViewFrom || cm.display.viewTo != cm.display.reportedViewTo) {\\n      update.signal(cm, \\\"viewportChange\\\", cm, cm.display.viewFrom, cm.display.viewTo);\\n      cm.display.reportedViewFrom = cm.display.viewFrom; cm.display.reportedViewTo = cm.display.viewTo;\\n    }\\n  }\\n\\n  function updateDisplaySimple(cm, viewport) {\\n    var update = new DisplayUpdate(cm, viewport);\\n    if (updateDisplayIfNeeded(cm, update)) {\\n      updateHeightsInViewport(cm);\\n      postUpdateDisplay(cm, update);\\n      var barMeasure = measureForScrollbars(cm);\\n      updateSelection(cm);\\n      updateScrollbars(cm, barMeasure);\\n      setDocumentHeight(cm, barMeasure);\\n      update.finish();\\n    }\\n  }\\n\\n  function setDocumentHeight(cm, measure) {\\n    cm.display.sizer.style.minHeight = measure.docHeight + \\\"px\\\";\\n    cm.display.heightForcer.style.top = measure.docHeight + \\\"px\\\";\\n    cm.display.gutters.style.height = (measure.docHeight + cm.display.barHeight + scrollGap(cm)) + \\\"px\\\";\\n  }\\n\\n  // Read the actual heights of the rendered lines, and update their\\n  // stored heights to match.\\n  function updateHeightsInViewport(cm) {\\n    var display = cm.display;\\n    var prevBottom = display.lineDiv.offsetTop;\\n    for (var i = 0; i < display.view.length; i++) {\\n      var cur = display.view[i], height;\\n      if (cur.hidden) continue;\\n      if (ie && ie_version < 8) {\\n        var bot = cur.node.offsetTop + cur.node.offsetHeight;\\n        height = bot - prevBottom;\\n        prevBottom = bot;\\n      } else {\\n        var box = cur.node.getBoundingClientRect();\\n        height = box.bottom - box.top;\\n      }\\n      var diff = cur.line.height - height;\\n      if (height < 2) height = textHeight(display);\\n      if (diff > .001 || diff < -.001) {\\n        updateLineHeight(cur.line, height);\\n        updateWidgetHeight(cur.line);\\n        if (cur.rest) for (var j = 0; j < cur.rest.length; j++)\\n          updateWidgetHeight(cur.rest[j]);\\n      }\\n    }\\n  }\\n\\n  // Read and store the height of line widgets associated with the\\n  // given line.\\n  function updateWidgetHeight(line) {\\n    if (line.widgets) for (var i = 0; i < line.widgets.length; ++i)\\n      line.widgets[i].height = line.widgets[i].node.parentNode.offsetHeight;\\n  }\\n\\n  // Do a bulk-read of the DOM positions and sizes needed to draw the\\n  // view, so that we don't interleave reading and writing to the DOM.\\n  function getDimensions(cm) {\\n    var d = cm.display, left = {}, width = {};\\n    var gutterLeft = d.gutters.clientLeft;\\n    for (var n = d.gutters.firstChild, i = 0; n; n = n.nextSibling, ++i) {\\n      left[cm.options.gutters[i]] = n.offsetLeft + n.clientLeft + gutterLeft;\\n      width[cm.options.gutters[i]] = n.clientWidth;\\n    }\\n    return {fixedPos: compensateForHScroll(d),\\n            gutterTotalWidth: d.gutters.offsetWidth,\\n            gutterLeft: left,\\n            gutterWidth: width,\\n            wrapperWidth: d.wrapper.clientWidth};\\n  }\\n\\n  // Sync the actual display DOM structure with display.view, removing\\n  // nodes for lines that are no longer in view, and creating the ones\\n  // that are not there yet, and updating the ones that are out of\\n  // date.\\n  function patchDisplay(cm, updateNumbersFrom, dims) {\\n    var display = cm.display, lineNumbers = cm.options.lineNumbers;\\n    var container = display.lineDiv, cur = container.firstChild;\\n\\n    function rm(node) {\\n      var next = node.nextSibling;\\n      // Works around a throw-scroll bug in OS X Webkit\\n      if (webkit && mac && cm.display.currentWheelTarget == node)\\n        node.style.display = \\\"none\\\";\\n      else\\n        node.parentNode.removeChild(node);\\n      return next;\\n    }\\n\\n    var view = display.view, lineN = display.viewFrom;\\n    // Loop over the elements in the view, syncing cur (the DOM nodes\\n    // in display.lineDiv) with the view as we go.\\n    for (var i = 0; i < view.length; i++) {\\n      var lineView = view[i];\\n      if (lineView.hidden) {\\n      } else if (!lineView.node || lineView.node.parentNode != container) { // Not drawn yet\\n        var node = buildLineElement(cm, lineView, lineN, dims);\\n        container.insertBefore(node, cur);\\n      } else { // Already drawn\\n        while (cur != lineView.node) cur = rm(cur);\\n        var updateNumber = lineNumbers && updateNumbersFrom != null &&\\n          updateNumbersFrom <= lineN && lineView.lineNumber;\\n        if (lineView.changes) {\\n          if (indexOf(lineView.changes, \\\"gutter\\\") > -1) updateNumber = false;\\n          updateLineForChanges(cm, lineView, lineN, dims);\\n        }\\n        if (updateNumber) {\\n          removeChildren(lineView.lineNumber);\\n          lineView.lineNumber.appendChild(document.createTextNode(lineNumberFor(cm.options, lineN)));\\n        }\\n        cur = lineView.node.nextSibling;\\n      }\\n      lineN += lineView.size;\\n    }\\n    while (cur) cur = rm(cur);\\n  }\\n\\n  // When an aspect of a line changes, a string is added to\\n  // lineView.changes. This updates the relevant part of the line's\\n  // DOM structure.\\n  function updateLineForChanges(cm, lineView, lineN, dims) {\\n    for (var j = 0; j < lineView.changes.length; j++) {\\n      var type = lineView.changes[j];\\n      if (type == \\\"text\\\") updateLineText(cm, lineView);\\n      else if (type == \\\"gutter\\\") updateLineGutter(cm, lineView, lineN, dims);\\n      else if (type == \\\"class\\\") updateLineClasses(lineView);\\n      else if (type == \\\"widget\\\") updateLineWidgets(cm, lineView, dims);\\n    }\\n    lineView.changes = null;\\n  }\\n\\n  // Lines with gutter elements, widgets or a background class need to\\n  // be wrapped, and have the extra elements added to the wrapper div\\n  function ensureLineWrapped(lineView) {\\n    if (lineView.node == lineView.text) {\\n      lineView.node = elt(\\\"div\\\", null, null, \\\"position: relative\\\");\\n      if (lineView.text.parentNode)\\n        lineView.text.parentNode.replaceChild(lineView.node, lineView.text);\\n      lineView.node.appendChild(lineView.text);\\n      if (ie && ie_version < 8) lineView.node.style.zIndex = 2;\\n    }\\n    return lineView.node;\\n  }\\n\\n  function updateLineBackground(lineView) {\\n    var cls = lineView.bgClass ? lineView.bgClass + \\\" \\\" + (lineView.line.bgClass || \\\"\\\") : lineView.line.bgClass;\\n    if (cls) cls += \\\" CodeMirror-linebackground\\\";\\n    if (lineView.background) {\\n      if (cls) lineView.background.className = cls;\\n      else { lineView.background.parentNode.removeChild(lineView.background); lineView.background = null; }\\n    } else if (cls) {\\n      var wrap = ensureLineWrapped(lineView);\\n      lineView.background = wrap.insertBefore(elt(\\\"div\\\", null, cls), wrap.firstChild);\\n    }\\n  }\\n\\n  // Wrapper around buildLineContent which will reuse the structure\\n  // in display.externalMeasured when possible.\\n  function getLineContent(cm, lineView) {\\n    var ext = cm.display.externalMeasured;\\n    if (ext && ext.line == lineView.line) {\\n      cm.display.externalMeasured = null;\\n      lineView.measure = ext.measure;\\n      return ext.built;\\n    }\\n    return buildLineContent(cm, lineView);\\n  }\\n\\n  // Redraw the line's text. Interacts with the background and text\\n  // classes because the mode may output tokens that influence these\\n  // classes.\\n  function updateLineText(cm, lineView) {\\n    var cls = lineView.text.className;\\n    var built = getLineContent(cm, lineView);\\n    if (lineView.text == lineView.node) lineView.node = built.pre;\\n    lineView.text.parentNode.replaceChild(built.pre, lineView.text);\\n    lineView.text = built.pre;\\n    if (built.bgClass != lineView.bgClass || built.textClass != lineView.textClass) {\\n      lineView.bgClass = built.bgClass;\\n      lineView.textClass = built.textClass;\\n      updateLineClasses(lineView);\\n    } else if (cls) {\\n      lineView.text.className = cls;\\n    }\\n  }\\n\\n  function updateLineClasses(lineView) {\\n    updateLineBackground(lineView);\\n    if (lineView.line.wrapClass)\\n      ensureLineWrapped(lineView).className = lineView.line.wrapClass;\\n    else if (lineView.node != lineView.text)\\n      lineView.node.className = \\\"\\\";\\n    var textClass = lineView.textClass ? lineView.textClass + \\\" \\\" + (lineView.line.textClass || \\\"\\\") : lineView.line.textClass;\\n    lineView.text.className = textClass || \\\"\\\";\\n  }\\n\\n  function updateLineGutter(cm, lineView, lineN, dims) {\\n    if (lineView.gutter) {\\n      lineView.node.removeChild(lineView.gutter);\\n      lineView.gutter = null;\\n    }\\n    if (lineView.gutterBackground) {\\n      lineView.node.removeChild(lineView.gutterBackground);\\n      lineView.gutterBackground = null;\\n    }\\n    if (lineView.line.gutterClass) {\\n      var wrap = ensureLineWrapped(lineView);\\n      lineView.gutterBackground = elt(\\\"div\\\", null, \\\"CodeMirror-gutter-background \\\" + lineView.line.gutterClass,\\n                                      \\\"left: \\\" + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) +\\n                                      \\\"px; width: \\\" + dims.gutterTotalWidth + \\\"px\\\");\\n      wrap.insertBefore(lineView.gutterBackground, lineView.text);\\n    }\\n    var markers = lineView.line.gutterMarkers;\\n    if (cm.options.lineNumbers || markers) {\\n      var wrap = ensureLineWrapped(lineView);\\n      var gutterWrap = lineView.gutter = elt(\\\"div\\\", null, \\\"CodeMirror-gutter-wrapper\\\", \\\"left: \\\" +\\n                                             (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + \\\"px\\\");\\n      cm.display.input.setUneditable(gutterWrap);\\n      wrap.insertBefore(gutterWrap, lineView.text);\\n      if (lineView.line.gutterClass)\\n        gutterWrap.className += \\\" \\\" + lineView.line.gutterClass;\\n      if (cm.options.lineNumbers && (!markers || !markers[\\\"CodeMirror-linenumbers\\\"]))\\n        lineView.lineNumber = gutterWrap.appendChild(\\n          elt(\\\"div\\\", lineNumberFor(cm.options, lineN),\\n              \\\"CodeMirror-linenumber CodeMirror-gutter-elt\\\",\\n              \\\"left: \\\" + dims.gutterLeft[\\\"CodeMirror-linenumbers\\\"] + \\\"px; width: \\\"\\n              + cm.display.lineNumInnerWidth + \\\"px\\\"));\\n      if (markers) for (var k = 0; k < cm.options.gutters.length; ++k) {\\n        var id = cm.options.gutters[k], found = markers.hasOwnProperty(id) && markers[id];\\n        if (found)\\n          gutterWrap.appendChild(elt(\\\"div\\\", [found], \\\"CodeMirror-gutter-elt\\\", \\\"left: \\\" +\\n                                     dims.gutterLeft[id] + \\\"px; width: \\\" + dims.gutterWidth[id] + \\\"px\\\"));\\n      }\\n    }\\n  }\\n\\n  function updateLineWidgets(cm, lineView, dims) {\\n    if (lineView.alignable) lineView.alignable = null;\\n    for (var node = lineView.node.firstChild, next; node; node = next) {\\n      var next = node.nextSibling;\\n      if (node.className == \\\"CodeMirror-linewidget\\\")\\n        lineView.node.removeChild(node);\\n    }\\n    insertLineWidgets(cm, lineView, dims);\\n  }\\n\\n  // Build a line's DOM representation from scratch\\n  function buildLineElement(cm, lineView, lineN, dims) {\\n    var built = getLineContent(cm, lineView);\\n    lineView.text = lineView.node = built.pre;\\n    if (built.bgClass) lineView.bgClass = built.bgClass;\\n    if (built.textClass) lineView.textClass = built.textClass;\\n\\n    updateLineClasses(lineView);\\n    updateLineGutter(cm, lineView, lineN, dims);\\n    insertLineWidgets(cm, lineView, dims);\\n    return lineView.node;\\n  }\\n\\n  // A lineView may contain multiple logical lines (when merged by\\n  // collapsed spans). The widgets for all of them need to be drawn.\\n  function insertLineWidgets(cm, lineView, dims) {\\n    insertLineWidgetsFor(cm, lineView.line, lineView, dims, true);\\n    if (lineView.rest) for (var i = 0; i < lineView.rest.length; i++)\\n      insertLineWidgetsFor(cm, lineView.rest[i], lineView, dims, false);\\n  }\\n\\n  function insertLineWidgetsFor(cm, line, lineView, dims, allowAbove) {\\n    if (!line.widgets) return;\\n    var wrap = ensureLineWrapped(lineView);\\n    for (var i = 0, ws = line.widgets; i < ws.length; ++i) {\\n      var widget = ws[i], node = elt(\\\"div\\\", [widget.node], \\\"CodeMirror-linewidget\\\");\\n      if (!widget.handleMouseEvents) node.setAttribute(\\\"cm-ignore-events\\\", \\\"true\\\");\\n      positionLineWidget(widget, node, lineView, dims);\\n      cm.display.input.setUneditable(node);\\n      if (allowAbove && widget.above)\\n        wrap.insertBefore(node, lineView.gutter || lineView.text);\\n      else\\n        wrap.appendChild(node);\\n      signalLater(widget, \\\"redraw\\\");\\n    }\\n  }\\n\\n  function positionLineWidget(widget, node, lineView, dims) {\\n    if (widget.noHScroll) {\\n      (lineView.alignable || (lineView.alignable = [])).push(node);\\n      var width = dims.wrapperWidth;\\n      node.style.left = dims.fixedPos + \\\"px\\\";\\n      if (!widget.coverGutter) {\\n        width -= dims.gutterTotalWidth;\\n        node.style.paddingLeft = dims.gutterTotalWidth + \\\"px\\\";\\n      }\\n      node.style.width = width + \\\"px\\\";\\n    }\\n    if (widget.coverGutter) {\\n      node.style.zIndex = 5;\\n      node.style.position = \\\"relative\\\";\\n      if (!widget.noHScroll) node.style.marginLeft = -dims.gutterTotalWidth + \\\"px\\\";\\n    }\\n  }\\n\\n  // POSITION OBJECT\\n\\n  // A Pos instance represents a position within the text.\\n  var Pos = CodeMirror.Pos = function(line, ch) {\\n    if (!(this instanceof Pos)) return new Pos(line, ch);\\n    this.line = line; this.ch = ch;\\n  };\\n\\n  // Compare two positions, return 0 if they are the same, a negative\\n  // number when a is less, and a positive number otherwise.\\n  var cmp = CodeMirror.cmpPos = function(a, b) { return a.line - b.line || a.ch - b.ch; };\\n\\n  function copyPos(x) {return Pos(x.line, x.ch);}\\n  function maxPos(a, b) { return cmp(a, b) < 0 ? b : a; }\\n  function minPos(a, b) { return cmp(a, b) < 0 ? a : b; }\\n\\n  // INPUT HANDLING\\n\\n  function ensureFocus(cm) {\\n    if (!cm.state.focused) { cm.display.input.focus(); onFocus(cm); }\\n  }\\n\\n  // This will be set to a {lineWise: bool, text: [string]} object, so\\n  // that, when pasting, we know what kind of selections the copied\\n  // text was made out of.\\n  var lastCopied = null;\\n\\n  function applyTextInput(cm, inserted, deleted, sel, origin) {\\n    var doc = cm.doc;\\n    cm.display.shift = false;\\n    if (!sel) sel = doc.sel;\\n\\n    var paste = cm.state.pasteIncoming || origin == \\\"paste\\\";\\n    var textLines = doc.splitLines(inserted), multiPaste = null\\n    // When pasing N lines into N selections, insert one line per selection\\n    if (paste && sel.ranges.length > 1) {\\n      if (lastCopied && lastCopied.text.join(\\\"\\\\n\\\") == inserted) {\\n        if (sel.ranges.length % lastCopied.text.length == 0) {\\n          multiPaste = [];\\n          for (var i = 0; i < lastCopied.text.length; i++)\\n            multiPaste.push(doc.splitLines(lastCopied.text[i]));\\n        }\\n      } else if (textLines.length == sel.ranges.length) {\\n        multiPaste = map(textLines, function(l) { return [l]; });\\n      }\\n    }\\n\\n    // Normal behavior is to insert the new text into every selection\\n    for (var i = sel.ranges.length - 1; i >= 0; i--) {\\n      var range = sel.ranges[i];\\n      var from = range.from(), to = range.to();\\n      if (range.empty()) {\\n        if (deleted && deleted > 0) // Handle deletion\\n          from = Pos(from.line, from.ch - deleted);\\n        else if (cm.state.overwrite && !paste) // Handle overwrite\\n          to = Pos(to.line, Math.min(getLine(doc, to.line).text.length, to.ch + lst(textLines).length));\\n        else if (lastCopied && lastCopied.lineWise && lastCopied.text.join(\\\"\\\\n\\\") == inserted)\\n          from = to = Pos(from.line, 0)\\n      }\\n      var updateInput = cm.curOp.updateInput;\\n      var changeEvent = {from: from, to: to, text: multiPaste ? multiPaste[i % multiPaste.length] : textLines,\\n                         origin: origin || (paste ? \\\"paste\\\" : cm.state.cutIncoming ? \\\"cut\\\" : \\\"+input\\\")};\\n      makeChange(cm.doc, changeEvent);\\n      signalLater(cm, \\\"inputRead\\\", cm, changeEvent);\\n    }\\n    if (inserted && !paste)\\n      triggerElectric(cm, inserted);\\n\\n    ensureCursorVisible(cm);\\n    cm.curOp.updateInput = updateInput;\\n    cm.curOp.typing = true;\\n    cm.state.pasteIncoming = cm.state.cutIncoming = false;\\n  }\\n\\n  function handlePaste(e, cm) {\\n    var pasted = e.clipboardData && e.clipboardData.getData(\\\"Text\\\");\\n    if (pasted) {\\n      e.preventDefault();\\n      if (!cm.isReadOnly() && !cm.options.disableInput)\\n        runInOp(cm, function() { applyTextInput(cm, pasted, 0, null, \\\"paste\\\"); });\\n      return true;\\n    }\\n  }\\n\\n  function triggerElectric(cm, inserted) {\\n    // When an 'electric' character is inserted, immediately trigger a reindent\\n    if (!cm.options.electricChars || !cm.options.smartIndent) return;\\n    var sel = cm.doc.sel;\\n\\n    for (var i = sel.ranges.length - 1; i >= 0; i--) {\\n      var range = sel.ranges[i];\\n      if (range.head.ch > 100 || (i && sel.ranges[i - 1].head.line == range.head.line)) continue;\\n      var mode = cm.getModeAt(range.head);\\n      var indented = false;\\n      if (mode.electricChars) {\\n        for (var j = 0; j < mode.electricChars.length; j++)\\n          if (inserted.indexOf(mode.electricChars.charAt(j)) > -1) {\\n            indented = indentLine(cm, range.head.line, \\\"smart\\\");\\n            break;\\n          }\\n      } else if (mode.electricInput) {\\n        if (mode.electricInput.test(getLine(cm.doc, range.head.line).text.slice(0, range.head.ch)))\\n          indented = indentLine(cm, range.head.line, \\\"smart\\\");\\n      }\\n      if (indented) signalLater(cm, \\\"electricInput\\\", cm, range.head.line);\\n    }\\n  }\\n\\n  function copyableRanges(cm) {\\n    var text = [], ranges = [];\\n    for (var i = 0; i < cm.doc.sel.ranges.length; i++) {\\n      var line = cm.doc.sel.ranges[i].head.line;\\n      var lineRange = {anchor: Pos(line, 0), head: Pos(line + 1, 0)};\\n      ranges.push(lineRange);\\n      text.push(cm.getRange(lineRange.anchor, lineRange.head));\\n    }\\n    return {text: text, ranges: ranges};\\n  }\\n\\n  function disableBrowserMagic(field, spellcheck) {\\n    field.setAttribute(\\\"autocorrect\\\", \\\"off\\\");\\n    field.setAttribute(\\\"autocapitalize\\\", \\\"off\\\");\\n    field.setAttribute(\\\"spellcheck\\\", !!spellcheck);\\n  }\\n\\n  // TEXTAREA INPUT STYLE\\n\\n  function TextareaInput(cm) {\\n    this.cm = cm;\\n    // See input.poll and input.reset\\n    this.prevInput = \\\"\\\";\\n\\n    // Flag that indicates whether we expect input to appear real soon\\n    // now (after some event like 'keypress' or 'input') and are\\n    // polling intensively.\\n    this.pollingFast = false;\\n    // Self-resetting timeout for the poller\\n    this.polling = new Delayed();\\n    // Tracks when input.reset has punted to just putting a short\\n    // string into the textarea instead of the full selection.\\n    this.inaccurateSelection = false;\\n    // Used to work around IE issue with selection being forgotten when focus moves away from textarea\\n    this.hasSelection = false;\\n    this.composing = null;\\n  };\\n\\n  function hiddenTextarea() {\\n    var te = elt(\\\"textarea\\\", null, null, \\\"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none\\\");\\n    var div = elt(\\\"div\\\", [te], null, \\\"overflow: hidden; position: relative; width: 3px; height: 0px;\\\");\\n    // The textarea is kept positioned near the cursor to prevent the\\n    // fact that it'll be scrolled into view on input from scrolling\\n    // our fake cursor out of view. On webkit, when wrap=off, paste is\\n    // very slow. So make the area wide instead.\\n    if (webkit) te.style.width = \\\"1000px\\\";\\n    else te.setAttribute(\\\"wrap\\\", \\\"off\\\");\\n    // If border: 0; -- iOS fails to open keyboard (issue #1287)\\n    if (ios) te.style.border = \\\"1px solid black\\\";\\n    disableBrowserMagic(te);\\n    return div;\\n  }\\n\\n  TextareaInput.prototype = copyObj({\\n    init: function(display) {\\n      var input = this, cm = this.cm;\\n\\n      // Wraps and hides input textarea\\n      var div = this.wrapper = hiddenTextarea();\\n      // The semihidden textarea that is focused when the editor is\\n      // focused, and receives input.\\n      var te = this.textarea = div.firstChild;\\n      display.wrapper.insertBefore(div, display.wrapper.firstChild);\\n\\n      // Needed to hide big blue blinking cursor on Mobile Safari (doesn't seem to work in iOS 8 anymore)\\n      if (ios) te.style.width = \\\"0px\\\";\\n\\n      on(te, \\\"input\\\", function() {\\n        if (ie && ie_version >= 9 && input.hasSelection) input.hasSelection = null;\\n        input.poll();\\n      });\\n\\n      on(te, \\\"paste\\\", function(e) {\\n        if (signalDOMEvent(cm, e) || handlePaste(e, cm)) return\\n\\n        cm.state.pasteIncoming = true;\\n        input.fastPoll();\\n      });\\n\\n      function prepareCopyCut(e) {\\n        if (signalDOMEvent(cm, e)) return\\n        if (cm.somethingSelected()) {\\n          lastCopied = {lineWise: false, text: cm.getSelections()};\\n          if (input.inaccurateSelection) {\\n            input.prevInput = \\\"\\\";\\n            input.inaccurateSelection = false;\\n            te.value = lastCopied.text.join(\\\"\\\\n\\\");\\n            selectInput(te);\\n          }\\n        } else if (!cm.options.lineWiseCopyCut) {\\n          return;\\n        } else {\\n          var ranges = copyableRanges(cm);\\n          lastCopied = {lineWise: true, text: ranges.text};\\n          if (e.type == \\\"cut\\\") {\\n            cm.setSelections(ranges.ranges, null, sel_dontScroll);\\n          } else {\\n            input.prevInput = \\\"\\\";\\n            te.value = ranges.text.join(\\\"\\\\n\\\");\\n            selectInput(te);\\n          }\\n        }\\n        if (e.type == \\\"cut\\\") cm.state.cutIncoming = true;\\n      }\\n      on(te, \\\"cut\\\", prepareCopyCut);\\n      on(te, \\\"copy\\\", prepareCopyCut);\\n\\n      on(display.scroller, \\\"paste\\\", function(e) {\\n        if (eventInWidget(display, e) || signalDOMEvent(cm, e)) return;\\n        cm.state.pasteIncoming = true;\\n        input.focus();\\n      });\\n\\n      // Prevent normal selection in the editor (we handle our own)\\n      on(display.lineSpace, \\\"selectstart\\\", function(e) {\\n        if (!eventInWidget(display, e)) e_preventDefault(e);\\n      });\\n\\n      on(te, \\\"compositionstart\\\", function() {\\n        var start = cm.getCursor(\\\"from\\\");\\n        if (input.composing) input.composing.range.clear()\\n        input.composing = {\\n          start: start,\\n          range: cm.markText(start, cm.getCursor(\\\"to\\\"), {className: \\\"CodeMirror-composing\\\"})\\n        };\\n      });\\n      on(te, \\\"compositionend\\\", function() {\\n        if (input.composing) {\\n          input.poll();\\n          input.composing.range.clear();\\n          input.composing = null;\\n        }\\n      });\\n    },\\n\\n    prepareSelection: function() {\\n      // Redraw the selection and/or cursor\\n      var cm = this.cm, display = cm.display, doc = cm.doc;\\n      var result = prepareSelection(cm);\\n\\n      // Move the hidden textarea near the cursor to prevent scrolling artifacts\\n      if (cm.options.moveInputWithCursor) {\\n        var headPos = cursorCoords(cm, doc.sel.primary().head, \\\"div\\\");\\n        var wrapOff = display.wrapper.getBoundingClientRect(), lineOff = display.lineDiv.getBoundingClientRect();\\n        result.teTop = Math.max(0, Math.min(display.wrapper.clientHeight - 10,\\n                                            headPos.top + lineOff.top - wrapOff.top));\\n        result.teLeft = Math.max(0, Math.min(display.wrapper.clientWidth - 10,\\n                                             headPos.left + lineOff.left - wrapOff.left));\\n      }\\n\\n      return result;\\n    },\\n\\n    showSelection: function(drawn) {\\n      var cm = this.cm, display = cm.display;\\n      removeChildrenAndAdd(display.cursorDiv, drawn.cursors);\\n      removeChildrenAndAdd(display.selectionDiv, drawn.selection);\\n      if (drawn.teTop != null) {\\n        this.wrapper.style.top = drawn.teTop + \\\"px\\\";\\n        this.wrapper.style.left = drawn.teLeft + \\\"px\\\";\\n      }\\n    },\\n\\n    // Reset the input to correspond to the selection (or to be empty,\\n    // when not typing and nothing is selected)\\n    reset: function(typing) {\\n      if (this.contextMenuPending) return;\\n      var minimal, selected, cm = this.cm, doc = cm.doc;\\n      if (cm.somethingSelected()) {\\n        this.prevInput = \\\"\\\";\\n        var range = doc.sel.primary();\\n        minimal = hasCopyEvent &&\\n          (range.to().line - range.from().line > 100 || (selected = cm.getSelection()).length > 1000);\\n        var content = minimal ? \\\"-\\\" : selected || cm.getSelection();\\n        this.textarea.value = content;\\n        if (cm.state.focused) selectInput(this.textarea);\\n        if (ie && ie_version >= 9) this.hasSelection = content;\\n      } else if (!typing) {\\n        this.prevInput = this.textarea.value = \\\"\\\";\\n        if (ie && ie_version >= 9) this.hasSelection = null;\\n      }\\n      this.inaccurateSelection = minimal;\\n    },\\n\\n    getField: function() { return this.textarea; },\\n\\n    supportsTouch: function() { return false; },\\n\\n    focus: function() {\\n      if (this.cm.options.readOnly != \\\"nocursor\\\" && (!mobile || activeElt() != this.textarea)) {\\n        try { this.textarea.focus(); }\\n        catch (e) {} // IE8 will throw if the textarea is display: none or not in DOM\\n      }\\n    },\\n\\n    blur: function() { this.textarea.blur(); },\\n\\n    resetPosition: function() {\\n      this.wrapper.style.top = this.wrapper.style.left = 0;\\n    },\\n\\n    receivedFocus: function() { this.slowPoll(); },\\n\\n    // Poll for input changes, using the normal rate of polling. This\\n    // runs as long as the editor is focused.\\n    slowPoll: function() {\\n      var input = this;\\n      if (input.pollingFast) return;\\n      input.polling.set(this.cm.options.pollInterval, function() {\\n        input.poll();\\n        if (input.cm.state.focused) input.slowPoll();\\n      });\\n    },\\n\\n    // When an event has just come in that is likely to add or change\\n    // something in the input textarea, we poll faster, to ensure that\\n    // the change appears on the screen quickly.\\n    fastPoll: function() {\\n      var missed = false, input = this;\\n      input.pollingFast = true;\\n      function p() {\\n        var changed = input.poll();\\n        if (!changed && !missed) {missed = true; input.polling.set(60, p);}\\n        else {input.pollingFast = false; input.slowPoll();}\\n      }\\n      input.polling.set(20, p);\\n    },\\n\\n    // Read input from the textarea, and update the document to match.\\n    // When something is selected, it is present in the textarea, and\\n    // selected (unless it is huge, in which case a placeholder is\\n    // used). When nothing is selected, the cursor sits after previously\\n    // seen text (can be empty), which is stored in prevInput (we must\\n    // not reset the textarea when typing, because that breaks IME).\\n    poll: function() {\\n      var cm = this.cm, input = this.textarea, prevInput = this.prevInput;\\n      // Since this is called a *lot*, try to bail out as cheaply as\\n      // possible when it is clear that nothing happened. hasSelection\\n      // will be the case when there is a lot of text in the textarea,\\n      // in which case reading its value would be expensive.\\n      if (this.contextMenuPending || !cm.state.focused ||\\n          (hasSelection(input) && !prevInput && !this.composing) ||\\n          cm.isReadOnly() || cm.options.disableInput || cm.state.keySeq)\\n        return false;\\n\\n      var text = input.value;\\n      // If nothing changed, bail.\\n      if (text == prevInput && !cm.somethingSelected()) return false;\\n      // Work around nonsensical selection resetting in IE9/10, and\\n      // inexplicable appearance of private area unicode characters on\\n      // some key combos in Mac (#2689).\\n      if (ie && ie_version >= 9 && this.hasSelection === text ||\\n          mac && /[\\\\uf700-\\\\uf7ff]/.test(text)) {\\n        cm.display.input.reset();\\n        return false;\\n      }\\n\\n      if (cm.doc.sel == cm.display.selForContextMenu) {\\n        var first = text.charCodeAt(0);\\n        if (first == 0x200b && !prevInput) prevInput = \\\"\\\\u200b\\\";\\n        if (first == 0x21da) { this.reset(); return this.cm.execCommand(\\\"undo\\\"); }\\n      }\\n      // Find the part of the input that is actually new\\n      var same = 0, l = Math.min(prevInput.length, text.length);\\n      while (same < l && prevInput.charCodeAt(same) == text.charCodeAt(same)) ++same;\\n\\n      var self = this;\\n      runInOp(cm, function() {\\n        applyTextInput(cm, text.slice(same), prevInput.length - same,\\n                       null, self.composing ? \\\"*compose\\\" : null);\\n\\n        // Don't leave long text in the textarea, since it makes further polling slow\\n        if (text.length > 1000 || text.indexOf(\\\"\\\\n\\\") > -1) input.value = self.prevInput = \\\"\\\";\\n        else self.prevInput = text;\\n\\n        if (self.composing) {\\n          self.composing.range.clear();\\n          self.composing.range = cm.markText(self.composing.start, cm.getCursor(\\\"to\\\"),\\n                                             {className: \\\"CodeMirror-composing\\\"});\\n        }\\n      });\\n      return true;\\n    },\\n\\n    ensurePolled: function() {\\n      if (this.pollingFast && this.poll()) this.pollingFast = false;\\n    },\\n\\n    onKeyPress: function() {\\n      if (ie && ie_version >= 9) this.hasSelection = null;\\n      this.fastPoll();\\n    },\\n\\n    onContextMenu: function(e) {\\n      var input = this, cm = input.cm, display = cm.display, te = input.textarea;\\n      var pos = posFromMouse(cm, e), scrollPos = display.scroller.scrollTop;\\n      if (!pos || presto) return; // Opera is difficult.\\n\\n      // Reset the current text selection only if the click is done outside of the selection\\n      // and 'resetSelectionOnContextMenu' option is true.\\n      var reset = cm.options.resetSelectionOnContextMenu;\\n      if (reset && cm.doc.sel.contains(pos) == -1)\\n        operation(cm, setSelection)(cm.doc, simpleSelection(pos), sel_dontScroll);\\n\\n      var oldCSS = te.style.cssText, oldWrapperCSS = input.wrapper.style.cssText;\\n      input.wrapper.style.cssText = \\\"position: absolute\\\"\\n      var wrapperBox = input.wrapper.getBoundingClientRect()\\n      te.style.cssText = \\\"position: absolute; width: 30px; height: 30px; top: \\\" + (e.clientY - wrapperBox.top - 5) +\\n        \\\"px; left: \\\" + (e.clientX - wrapperBox.left - 5) + \\\"px; z-index: 1000; background: \\\" +\\n        (ie ? \\\"rgba(255, 255, 255, .05)\\\" : \\\"transparent\\\") +\\n        \\\"; outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);\\\";\\n      if (webkit) var oldScrollY = window.scrollY; // Work around Chrome issue (#2712)\\n      display.input.focus();\\n      if (webkit) window.scrollTo(null, oldScrollY);\\n      display.input.reset();\\n      // Adds \\\"Select all\\\" to context menu in FF\\n      if (!cm.somethingSelected()) te.value = input.prevInput = \\\" \\\";\\n      input.contextMenuPending = true;\\n      display.selForContextMenu = cm.doc.sel;\\n      clearTimeout(display.detectingSelectAll);\\n\\n      // Select-all will be greyed out if there's nothing to select, so\\n      // this adds a zero-width space so that we can later check whether\\n      // it got selected.\\n      function prepareSelectAllHack() {\\n        if (te.selectionStart != null) {\\n          var selected = cm.somethingSelected();\\n          var extval = \\\"\\\\u200b\\\" + (selected ? te.value : \\\"\\\");\\n          te.value = \\\"\\\\u21da\\\"; // Used to catch context-menu undo\\n          te.value = extval;\\n          input.prevInput = selected ? \\\"\\\" : \\\"\\\\u200b\\\";\\n          te.selectionStart = 1; te.selectionEnd = extval.length;\\n          // Re-set this, in case some other handler touched the\\n          // selection in the meantime.\\n          display.selForContextMenu = cm.doc.sel;\\n        }\\n      }\\n      function rehide() {\\n        input.contextMenuPending = false;\\n        input.wrapper.style.cssText = oldWrapperCSS\\n        te.style.cssText = oldCSS;\\n        if (ie && ie_version < 9) display.scrollbars.setScrollTop(display.scroller.scrollTop = scrollPos);\\n\\n        // Try to detect the user choosing select-all\\n        if (te.selectionStart != null) {\\n          if (!ie || (ie && ie_version < 9)) prepareSelectAllHack();\\n          var i = 0, poll = function() {\\n            if (display.selForContextMenu == cm.doc.sel && te.selectionStart == 0 &&\\n                te.selectionEnd > 0 && input.prevInput == \\\"\\\\u200b\\\")\\n              operation(cm, commands.selectAll)(cm);\\n            else if (i++ < 10) display.detectingSelectAll = setTimeout(poll, 500);\\n            else display.input.reset();\\n          };\\n          display.detectingSelectAll = setTimeout(poll, 200);\\n        }\\n      }\\n\\n      if (ie && ie_version >= 9) prepareSelectAllHack();\\n      if (captureRightClick) {\\n        e_stop(e);\\n        var mouseup = function() {\\n          off(window, \\\"mouseup\\\", mouseup);\\n          setTimeout(rehide, 20);\\n        };\\n        on(window, \\\"mouseup\\\", mouseup);\\n      } else {\\n        setTimeout(rehide, 50);\\n      }\\n    },\\n\\n    readOnlyChanged: function(val) {\\n      if (!val) this.reset();\\n    },\\n\\n    setUneditable: nothing,\\n\\n    needsContentAttribute: false\\n  }, TextareaInput.prototype);\\n\\n  // CONTENTEDITABLE INPUT STYLE\\n\\n  function ContentEditableInput(cm) {\\n    this.cm = cm;\\n    this.lastAnchorNode = this.lastAnchorOffset = this.lastFocusNode = this.lastFocusOffset = null;\\n    this.polling = new Delayed();\\n    this.gracePeriod = false;\\n  }\\n\\n  ContentEditableInput.prototype = copyObj({\\n    init: function(display) {\\n      var input = this, cm = input.cm;\\n      var div = input.div = display.lineDiv;\\n      disableBrowserMagic(div, cm.options.spellcheck);\\n\\n      on(div, \\\"paste\\\", function(e) {\\n        if (signalDOMEvent(cm, e) || handlePaste(e, cm)) return\\n        // IE doesn't fire input events, so we schedule a read for the pasted content in this way\\n        if (ie_version <= 11) setTimeout(operation(cm, function() {\\n          if (!input.pollContent()) regChange(cm);\\n        }), 20)\\n      })\\n\\n      on(div, \\\"compositionstart\\\", function(e) {\\n        var data = e.data;\\n        input.composing = {sel: cm.doc.sel, data: data, startData: data};\\n        if (!data) return;\\n        var prim = cm.doc.sel.primary();\\n        var line = cm.getLine(prim.head.line);\\n        var found = line.indexOf(data, Math.max(0, prim.head.ch - data.length));\\n        if (found > -1 && found <= prim.head.ch)\\n          input.composing.sel = simpleSelection(Pos(prim.head.line, found),\\n                                                Pos(prim.head.line, found + data.length));\\n      });\\n      on(div, \\\"compositionupdate\\\", function(e) {\\n        input.composing.data = e.data;\\n      });\\n      on(div, \\\"compositionend\\\", function(e) {\\n        var ours = input.composing;\\n        if (!ours) return;\\n        if (e.data != ours.startData && !/\\\\u200b/.test(e.data))\\n          ours.data = e.data;\\n        // Need a small delay to prevent other code (input event,\\n        // selection polling) from doing damage when fired right after\\n        // compositionend.\\n        setTimeout(function() {\\n          if (!ours.handled)\\n            input.applyComposition(ours);\\n          if (input.composing == ours)\\n            input.composing = null;\\n        }, 50);\\n      });\\n\\n      on(div, \\\"touchstart\\\", function() {\\n        input.forceCompositionEnd();\\n      });\\n\\n      on(div, \\\"input\\\", function() {\\n        if (input.composing) return;\\n        if (cm.isReadOnly() || !input.pollContent())\\n          runInOp(input.cm, function() {regChange(cm);});\\n      });\\n\\n      function onCopyCut(e) {\\n        if (signalDOMEvent(cm, e)) return\\n        if (cm.somethingSelected()) {\\n          lastCopied = {lineWise: false, text: cm.getSelections()};\\n          if (e.type == \\\"cut\\\") cm.replaceSelection(\\\"\\\", null, \\\"cut\\\");\\n        } else if (!cm.options.lineWiseCopyCut) {\\n          return;\\n        } else {\\n          var ranges = copyableRanges(cm);\\n          lastCopied = {lineWise: true, text: ranges.text};\\n          if (e.type == \\\"cut\\\") {\\n            cm.operation(function() {\\n              cm.setSelections(ranges.ranges, 0, sel_dontScroll);\\n              cm.replaceSelection(\\\"\\\", null, \\\"cut\\\");\\n            });\\n          }\\n        }\\n        if (e.clipboardData) {\\n          e.clipboardData.clearData();\\n          var content = lastCopied.text.join(\\\"\\\\n\\\")\\n          // iOS exposes the clipboard API, but seems to discard content inserted into it\\n          e.clipboardData.setData(\\\"Text\\\", content);\\n          if (e.clipboardData.getData(\\\"Text\\\") == content) {\\n            e.preventDefault();\\n            return\\n          }\\n        }\\n        // Old-fashioned briefly-focus-a-textarea hack\\n        var kludge = hiddenTextarea(), te = kludge.firstChild;\\n        cm.display.lineSpace.insertBefore(kludge, cm.display.lineSpace.firstChild);\\n        te.value = lastCopied.text.join(\\\"\\\\n\\\");\\n        var hadFocus = document.activeElement;\\n        selectInput(te);\\n        setTimeout(function() {\\n          cm.display.lineSpace.removeChild(kludge);\\n          hadFocus.focus();\\n          if (hadFocus == div) input.showPrimarySelection()\\n        }, 50);\\n      }\\n      on(div, \\\"copy\\\", onCopyCut);\\n      on(div, \\\"cut\\\", onCopyCut);\\n    },\\n\\n    prepareSelection: function() {\\n      var result = prepareSelection(this.cm, false);\\n      result.focus = this.cm.state.focused;\\n      return result;\\n    },\\n\\n    showSelection: function(info, takeFocus) {\\n      if (!info || !this.cm.display.view.length) return;\\n      if (info.focus || takeFocus) this.showPrimarySelection();\\n      this.showMultipleSelections(info);\\n    },\\n\\n    showPrimarySelection: function() {\\n      var sel = window.getSelection(), prim = this.cm.doc.sel.primary();\\n      var curAnchor = domToPos(this.cm, sel.anchorNode, sel.anchorOffset);\\n      var curFocus = domToPos(this.cm, sel.focusNode, sel.focusOffset);\\n      if (curAnchor && !curAnchor.bad && curFocus && !curFocus.bad &&\\n          cmp(minPos(curAnchor, curFocus), prim.from()) == 0 &&\\n          cmp(maxPos(curAnchor, curFocus), prim.to()) == 0)\\n        return;\\n\\n      var start = posToDOM(this.cm, prim.from());\\n      var end = posToDOM(this.cm, prim.to());\\n      if (!start && !end) return;\\n\\n      var view = this.cm.display.view;\\n      var old = sel.rangeCount && sel.getRangeAt(0);\\n      if (!start) {\\n        start = {node: view[0].measure.map[2], offset: 0};\\n      } else if (!end) { // FIXME dangerously hacky\\n        var measure = view[view.length - 1].measure;\\n        var map = measure.maps ? measure.maps[measure.maps.length - 1] : measure.map;\\n        end = {node: map[map.length - 1], offset: map[map.length - 2] - map[map.length - 3]};\\n      }\\n\\n      try { var rng = range(start.node, start.offset, end.offset, end.node); }\\n      catch(e) {} // Our model of the DOM might be outdated, in which case the range we try to set can be impossible\\n      if (rng) {\\n        if (!gecko && this.cm.state.focused) {\\n          sel.collapse(start.node, start.offset);\\n          if (!rng.collapsed) sel.addRange(rng);\\n        } else {\\n          sel.removeAllRanges();\\n          sel.addRange(rng);\\n        }\\n        if (old && sel.anchorNode == null) sel.addRange(old);\\n        else if (gecko) this.startGracePeriod();\\n      }\\n      this.rememberSelection();\\n    },\\n\\n    startGracePeriod: function() {\\n      var input = this;\\n      clearTimeout(this.gracePeriod);\\n      this.gracePeriod = setTimeout(function() {\\n        input.gracePeriod = false;\\n        if (input.selectionChanged())\\n          input.cm.operation(function() { input.cm.curOp.selectionChanged = true; });\\n      }, 20);\\n    },\\n\\n    showMultipleSelections: function(info) {\\n      removeChildrenAndAdd(this.cm.display.cursorDiv, info.cursors);\\n      removeChildrenAndAdd(this.cm.display.selectionDiv, info.selection);\\n    },\\n\\n    rememberSelection: function() {\\n      var sel = window.getSelection();\\n      this.lastAnchorNode = sel.anchorNode; this.lastAnchorOffset = sel.anchorOffset;\\n      this.lastFocusNode = sel.focusNode; this.lastFocusOffset = sel.focusOffset;\\n    },\\n\\n    selectionInEditor: function() {\\n      var sel = window.getSelection();\\n      if (!sel.rangeCount) return false;\\n      var node = sel.getRangeAt(0).commonAncestorContainer;\\n      return contains(this.div, node);\\n    },\\n\\n    focus: function() {\\n      if (this.cm.options.readOnly != \\\"nocursor\\\") this.div.focus();\\n    },\\n    blur: function() { this.div.blur(); },\\n    getField: function() { return this.div; },\\n\\n    supportsTouch: function() { return true; },\\n\\n    receivedFocus: function() {\\n      var input = this;\\n      if (this.selectionInEditor())\\n        this.pollSelection();\\n      else\\n        runInOp(this.cm, function() { input.cm.curOp.selectionChanged = true; });\\n\\n      function poll() {\\n        if (input.cm.state.focused) {\\n          input.pollSelection();\\n          input.polling.set(input.cm.options.pollInterval, poll);\\n        }\\n      }\\n      this.polling.set(this.cm.options.pollInterval, poll);\\n    },\\n\\n    selectionChanged: function() {\\n      var sel = window.getSelection();\\n      return sel.anchorNode != this.lastAnchorNode || sel.anchorOffset != this.lastAnchorOffset ||\\n        sel.focusNode != this.lastFocusNode || sel.focusOffset != this.lastFocusOffset;\\n    },\\n\\n    pollSelection: function() {\\n      if (!this.composing && !this.gracePeriod && this.selectionChanged()) {\\n        var sel = window.getSelection(), cm = this.cm;\\n        this.rememberSelection();\\n        var anchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);\\n        var head = domToPos(cm, sel.focusNode, sel.focusOffset);\\n        if (anchor && head) runInOp(cm, function() {\\n          setSelection(cm.doc, simpleSelection(anchor, head), sel_dontScroll);\\n          if (anchor.bad || head.bad) cm.curOp.selectionChanged = true;\\n        });\\n      }\\n    },\\n\\n    pollContent: function() {\\n      var cm = this.cm, display = cm.display, sel = cm.doc.sel.primary();\\n      var from = sel.from(), to = sel.to();\\n      if (from.line < display.viewFrom || to.line > display.viewTo - 1) return false;\\n\\n      var fromIndex;\\n      if (from.line == display.viewFrom || (fromIndex = findViewIndex(cm, from.line)) == 0) {\\n        var fromLine = lineNo(display.view[0].line);\\n        var fromNode = display.view[0].node;\\n      } else {\\n        var fromLine = lineNo(display.view[fromIndex].line);\\n        var fromNode = display.view[fromIndex - 1].node.nextSibling;\\n      }\\n      var toIndex = findViewIndex(cm, to.line);\\n      if (toIndex == display.view.length - 1) {\\n        var toLine = display.viewTo - 1;\\n        var toNode = display.lineDiv.lastChild;\\n      } else {\\n        var toLine = lineNo(display.view[toIndex + 1].line) - 1;\\n        var toNode = display.view[toIndex + 1].node.previousSibling;\\n      }\\n\\n      var newText = cm.doc.splitLines(domTextBetween(cm, fromNode, toNode, fromLine, toLine));\\n      var oldText = getBetween(cm.doc, Pos(fromLine, 0), Pos(toLine, getLine(cm.doc, toLine).text.length));\\n      while (newText.length > 1 && oldText.length > 1) {\\n        if (lst(newText) == lst(oldText)) { newText.pop(); oldText.pop(); toLine--; }\\n        else if (newText[0] == oldText[0]) { newText.shift(); oldText.shift(); fromLine++; }\\n        else break;\\n      }\\n\\n      var cutFront = 0, cutEnd = 0;\\n      var newTop = newText[0], oldTop = oldText[0], maxCutFront = Math.min(newTop.length, oldTop.length);\\n      while (cutFront < maxCutFront && newTop.charCodeAt(cutFront) == oldTop.charCodeAt(cutFront))\\n        ++cutFront;\\n      var newBot = lst(newText), oldBot = lst(oldText);\\n      var maxCutEnd = Math.min(newBot.length - (newText.length == 1 ? cutFront : 0),\\n                               oldBot.length - (oldText.length == 1 ? cutFront : 0));\\n      while (cutEnd < maxCutEnd &&\\n             newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1))\\n        ++cutEnd;\\n\\n      newText[newText.length - 1] = newBot.slice(0, newBot.length - cutEnd);\\n      newText[0] = newText[0].slice(cutFront);\\n\\n      var chFrom = Pos(fromLine, cutFront);\\n      var chTo = Pos(toLine, oldText.length ? lst(oldText).length - cutEnd : 0);\\n      if (newText.length > 1 || newText[0] || cmp(chFrom, chTo)) {\\n        replaceRange(cm.doc, newText, chFrom, chTo, \\\"+input\\\");\\n        return true;\\n      }\\n    },\\n\\n    ensurePolled: function() {\\n      this.forceCompositionEnd();\\n    },\\n    reset: function() {\\n      this.forceCompositionEnd();\\n    },\\n    forceCompositionEnd: function() {\\n      if (!this.composing || this.composing.handled) return;\\n      this.applyComposition(this.composing);\\n      this.composing.handled = true;\\n      this.div.blur();\\n      this.div.focus();\\n    },\\n    applyComposition: function(composing) {\\n      if (this.cm.isReadOnly())\\n        operation(this.cm, regChange)(this.cm)\\n      else if (composing.data && composing.data != composing.startData)\\n        operation(this.cm, applyTextInput)(this.cm, composing.data, 0, composing.sel);\\n    },\\n\\n    setUneditable: function(node) {\\n      node.contentEditable = \\\"false\\\"\\n    },\\n\\n    onKeyPress: function(e) {\\n      e.preventDefault();\\n      if (!this.cm.isReadOnly())\\n        operation(this.cm, applyTextInput)(this.cm, String.fromCharCode(e.charCode == null ? e.keyCode : e.charCode), 0);\\n    },\\n\\n    readOnlyChanged: function(val) {\\n      this.div.contentEditable = String(val != \\\"nocursor\\\")\\n    },\\n\\n    onContextMenu: nothing,\\n    resetPosition: nothing,\\n\\n    needsContentAttribute: true\\n  }, ContentEditableInput.prototype);\\n\\n  function posToDOM(cm, pos) {\\n    var view = findViewForLine(cm, pos.line);\\n    if (!view || view.hidden) return null;\\n    var line = getLine(cm.doc, pos.line);\\n    var info = mapFromLineView(view, line, pos.line);\\n\\n    var order = getOrder(line), side = \\\"left\\\";\\n    if (order) {\\n      var partPos = getBidiPartAt(order, pos.ch);\\n      side = partPos % 2 ? \\\"right\\\" : \\\"left\\\";\\n    }\\n    var result = nodeAndOffsetInLineMap(info.map, pos.ch, side);\\n    result.offset = result.collapse == \\\"right\\\" ? result.end : result.start;\\n    return result;\\n  }\\n\\n  function badPos(pos, bad) { if (bad) pos.bad = true; return pos; }\\n\\n  function domToPos(cm, node, offset) {\\n    var lineNode;\\n    if (node == cm.display.lineDiv) {\\n      lineNode = cm.display.lineDiv.childNodes[offset];\\n      if (!lineNode) return badPos(cm.clipPos(Pos(cm.display.viewTo - 1)), true);\\n      node = null; offset = 0;\\n    } else {\\n      for (lineNode = node;; lineNode = lineNode.parentNode) {\\n        if (!lineNode || lineNode == cm.display.lineDiv) return null;\\n        if (lineNode.parentNode && lineNode.parentNode == cm.display.lineDiv) break;\\n      }\\n    }\\n    for (var i = 0; i < cm.display.view.length; i++) {\\n      var lineView = cm.display.view[i];\\n      if (lineView.node == lineNode)\\n        return locateNodeInLineView(lineView, node, offset);\\n    }\\n  }\\n\\n  function locateNodeInLineView(lineView, node, offset) {\\n    var wrapper = lineView.text.firstChild, bad = false;\\n    if (!node || !contains(wrapper, node)) return badPos(Pos(lineNo(lineView.line), 0), true);\\n    if (node == wrapper) {\\n      bad = true;\\n      node = wrapper.childNodes[offset];\\n      offset = 0;\\n      if (!node) {\\n        var line = lineView.rest ? lst(lineView.rest) : lineView.line;\\n        return badPos(Pos(lineNo(line), line.text.length), bad);\\n      }\\n    }\\n\\n    var textNode = node.nodeType == 3 ? node : null, topNode = node;\\n    if (!textNode && node.childNodes.length == 1 && node.firstChild.nodeType == 3) {\\n      textNode = node.firstChild;\\n      if (offset) offset = textNode.nodeValue.length;\\n    }\\n    while (topNode.parentNode != wrapper) topNode = topNode.parentNode;\\n    var measure = lineView.measure, maps = measure.maps;\\n\\n    function find(textNode, topNode, offset) {\\n      for (var i = -1; i < (maps ? maps.length : 0); i++) {\\n        var map = i < 0 ? measure.map : maps[i];\\n        for (var j = 0; j < map.length; j += 3) {\\n          var curNode = map[j + 2];\\n          if (curNode == textNode || curNode == topNode) {\\n            var line = lineNo(i < 0 ? lineView.line : lineView.rest[i]);\\n            var ch = map[j] + offset;\\n            if (offset < 0 || curNode != textNode) ch = map[j + (offset ? 1 : 0)];\\n            return Pos(line, ch);\\n          }\\n        }\\n      }\\n    }\\n    var found = find(textNode, topNode, offset);\\n    if (found) return badPos(found, bad);\\n\\n    // FIXME this is all really shaky. might handle the few cases it needs to handle, but likely to cause problems\\n    for (var after = topNode.nextSibling, dist = textNode ? textNode.nodeValue.length - offset : 0; after; after = after.nextSibling) {\\n      found = find(after, after.firstChild, 0);\\n      if (found)\\n        return badPos(Pos(found.line, found.ch - dist), bad);\\n      else\\n        dist += after.textContent.length;\\n    }\\n    for (var before = topNode.previousSibling, dist = offset; before; before = before.previousSibling) {\\n      found = find(before, before.firstChild, -1);\\n      if (found)\\n        return badPos(Pos(found.line, found.ch + dist), bad);\\n      else\\n        dist += before.textContent.length;\\n    }\\n  }\\n\\n  function domTextBetween(cm, from, to, fromLine, toLine) {\\n    var text = \\\"\\\", closing = false, lineSep = cm.doc.lineSeparator();\\n    function recognizeMarker(id) { return function(marker) { return marker.id == id; }; }\\n    function walk(node) {\\n      if (node.nodeType == 1) {\\n        var cmText = node.getAttribute(\\\"cm-text\\\");\\n        if (cmText != null) {\\n          if (cmText == \\\"\\\") cmText = node.textContent.replace(/\\\\u200b/g, \\\"\\\");\\n          text += cmText;\\n          return;\\n        }\\n        var markerID = node.getAttribute(\\\"cm-marker\\\"), range;\\n        if (markerID) {\\n          var found = cm.findMarks(Pos(fromLine, 0), Pos(toLine + 1, 0), recognizeMarker(+markerID));\\n          if (found.length && (range = found[0].find()))\\n            text += getBetween(cm.doc, range.from, range.to).join(lineSep);\\n          return;\\n        }\\n        if (node.getAttribute(\\\"contenteditable\\\") == \\\"false\\\") return;\\n        for (var i = 0; i < node.childNodes.length; i++)\\n          walk(node.childNodes[i]);\\n        if (/^(pre|div|p)$/i.test(node.nodeName))\\n          closing = true;\\n      } else if (node.nodeType == 3) {\\n        var val = node.nodeValue;\\n        if (!val) return;\\n        if (closing) {\\n          text += lineSep;\\n          closing = false;\\n        }\\n        text += val;\\n      }\\n    }\\n    for (;;) {\\n      walk(from);\\n      if (from == to) break;\\n      from = from.nextSibling;\\n    }\\n    return text;\\n  }\\n\\n  CodeMirror.inputStyles = {\\\"textarea\\\": TextareaInput, \\\"contenteditable\\\": ContentEditableInput};\\n\\n  // SELECTION / CURSOR\\n\\n  // Selection objects are immutable. A new one is created every time\\n  // the selection changes. A selection is one or more non-overlapping\\n  // (and non-touching) ranges, sorted, and an integer that indicates\\n  // which one is the primary selection (the one that's scrolled into\\n  // view, that getCursor returns, etc).\\n  function Selection(ranges, primIndex) {\\n    this.ranges = ranges;\\n    this.primIndex = primIndex;\\n  }\\n\\n  Selection.prototype = {\\n    primary: function() { return this.ranges[this.primIndex]; },\\n    equals: function(other) {\\n      if (other == this) return true;\\n      if (other.primIndex != this.primIndex || other.ranges.length != this.ranges.length) return false;\\n      for (var i = 0; i < this.ranges.length; i++) {\\n        var here = this.ranges[i], there = other.ranges[i];\\n        if (cmp(here.anchor, there.anchor) != 0 || cmp(here.head, there.head) != 0) return false;\\n      }\\n      return true;\\n    },\\n    deepCopy: function() {\\n      for (var out = [], i = 0; i < this.ranges.length; i++)\\n        out[i] = new Range(copyPos(this.ranges[i].anchor), copyPos(this.ranges[i].head));\\n      return new Selection(out, this.primIndex);\\n    },\\n    somethingSelected: function() {\\n      for (var i = 0; i < this.ranges.length; i++)\\n        if (!this.ranges[i].empty()) return true;\\n      return false;\\n    },\\n    contains: function(pos, end) {\\n      if (!end) end = pos;\\n      for (var i = 0; i < this.ranges.length; i++) {\\n        var range = this.ranges[i];\\n        if (cmp(end, range.from()) >= 0 && cmp(pos, range.to()) <= 0)\\n          return i;\\n      }\\n      return -1;\\n    }\\n  };\\n\\n  function Range(anchor, head) {\\n    this.anchor = anchor; this.head = head;\\n  }\\n\\n  Range.prototype = {\\n    from: function() { return minPos(this.anchor, this.head); },\\n    to: function() { return maxPos(this.anchor, this.head); },\\n    empty: function() {\\n      return this.head.line == this.anchor.line && this.head.ch == this.anchor.ch;\\n    }\\n  };\\n\\n  // Take an unsorted, potentially overlapping set of ranges, and\\n  // build a selection out of it. 'Consumes' ranges array (modifying\\n  // it).\\n  function normalizeSelection(ranges, primIndex) {\\n    var prim = ranges[primIndex];\\n    ranges.sort(function(a, b) { return cmp(a.from(), b.from()); });\\n    primIndex = indexOf(ranges, prim);\\n    for (var i = 1; i < ranges.length; i++) {\\n      var cur = ranges[i], prev = ranges[i - 1];\\n      if (cmp(prev.to(), cur.from()) >= 0) {\\n        var from = minPos(prev.from(), cur.from()), to = maxPos(prev.to(), cur.to());\\n        var inv = prev.empty() ? cur.from() == cur.head : prev.from() == prev.head;\\n        if (i <= primIndex) --primIndex;\\n        ranges.splice(--i, 2, new Range(inv ? to : from, inv ? from : to));\\n      }\\n    }\\n    return new Selection(ranges, primIndex);\\n  }\\n\\n  function simpleSelection(anchor, head) {\\n    return new Selection([new Range(anchor, head || anchor)], 0);\\n  }\\n\\n  // Most of the external API clips given positions to make sure they\\n  // actually exist within the document.\\n  function clipLine(doc, n) {return Math.max(doc.first, Math.min(n, doc.first + doc.size - 1));}\\n  function clipPos(doc, pos) {\\n    if (pos.line < doc.first) return Pos(doc.first, 0);\\n    var last = doc.first + doc.size - 1;\\n    if (pos.line > last) return Pos(last, getLine(doc, last).text.length);\\n    return clipToLen(pos, getLine(doc, pos.line).text.length);\\n  }\\n  function clipToLen(pos, linelen) {\\n    var ch = pos.ch;\\n    if (ch == null || ch > linelen) return Pos(pos.line, linelen);\\n    else if (ch < 0) return Pos(pos.line, 0);\\n    else return pos;\\n  }\\n  function isLine(doc, l) {return l >= doc.first && l < doc.first + doc.size;}\\n  function clipPosArray(doc, array) {\\n    for (var out = [], i = 0; i < array.length; i++) out[i] = clipPos(doc, array[i]);\\n    return out;\\n  }\\n\\n  // SELECTION UPDATES\\n\\n  // The 'scroll' parameter given to many of these indicated whether\\n  // the new cursor position should be scrolled into view after\\n  // modifying the selection.\\n\\n  // If shift is held or the extend flag is set, extends a range to\\n  // include a given position (and optionally a second position).\\n  // Otherwise, simply returns the range between the given positions.\\n  // Used for cursor motion and such.\\n  function extendRange(doc, range, head, other) {\\n    if (doc.cm && doc.cm.display.shift || doc.extend) {\\n      var anchor = range.anchor;\\n      if (other) {\\n        var posBefore = cmp(head, anchor) < 0;\\n        if (posBefore != (cmp(other, anchor) < 0)) {\\n          anchor = head;\\n          head = other;\\n        } else if (posBefore != (cmp(head, other) < 0)) {\\n          head = other;\\n        }\\n      }\\n      return new Range(anchor, head);\\n    } else {\\n      return new Range(other || head, head);\\n    }\\n  }\\n\\n  // Extend the primary selection range, discard the rest.\\n  function extendSelection(doc, head, other, options) {\\n    setSelection(doc, new Selection([extendRange(doc, doc.sel.primary(), head, other)], 0), options);\\n  }\\n\\n  // Extend all selections (pos is an array of selections with length\\n  // equal the number of selections)\\n  function extendSelections(doc, heads, options) {\\n    for (var out = [], i = 0; i < doc.sel.ranges.length; i++)\\n      out[i] = extendRange(doc, doc.sel.ranges[i], heads[i], null);\\n    var newSel = normalizeSelection(out, doc.sel.primIndex);\\n    setSelection(doc, newSel, options);\\n  }\\n\\n  // Updates a single range in the selection.\\n  function replaceOneSelection(doc, i, range, options) {\\n    var ranges = doc.sel.ranges.slice(0);\\n    ranges[i] = range;\\n    setSelection(doc, normalizeSelection(ranges, doc.sel.primIndex), options);\\n  }\\n\\n  // Reset the selection to a single range.\\n  function setSimpleSelection(doc, anchor, head, options) {\\n    setSelection(doc, simpleSelection(anchor, head), options);\\n  }\\n\\n  // Give beforeSelectionChange handlers a change to influence a\\n  // selection update.\\n  function filterSelectionChange(doc, sel, options) {\\n    var obj = {\\n      ranges: sel.ranges,\\n      update: function(ranges) {\\n        this.ranges = [];\\n        for (var i = 0; i < ranges.length; i++)\\n          this.ranges[i] = new Range(clipPos(doc, ranges[i].anchor),\\n                                     clipPos(doc, ranges[i].head));\\n      },\\n      origin: options && options.origin\\n    };\\n    signal(doc, \\\"beforeSelectionChange\\\", doc, obj);\\n    if (doc.cm) signal(doc.cm, \\\"beforeSelectionChange\\\", doc.cm, obj);\\n    if (obj.ranges != sel.ranges) return normalizeSelection(obj.ranges, obj.ranges.length - 1);\\n    else return sel;\\n  }\\n\\n  function setSelectionReplaceHistory(doc, sel, options) {\\n    var done = doc.history.done, last = lst(done);\\n    if (last && last.ranges) {\\n      done[done.length - 1] = sel;\\n      setSelectionNoUndo(doc, sel, options);\\n    } else {\\n      setSelection(doc, sel, options);\\n    }\\n  }\\n\\n  // Set a new selection.\\n  function setSelection(doc, sel, options) {\\n    setSelectionNoUndo(doc, sel, options);\\n    addSelectionToHistory(doc, doc.sel, doc.cm ? doc.cm.curOp.id : NaN, options);\\n  }\\n\\n  function setSelectionNoUndo(doc, sel, options) {\\n    if (hasHandler(doc, \\\"beforeSelectionChange\\\") || doc.cm && hasHandler(doc.cm, \\\"beforeSelectionChange\\\"))\\n      sel = filterSelectionChange(doc, sel, options);\\n\\n    var bias = options && options.bias ||\\n      (cmp(sel.primary().head, doc.sel.primary().head) < 0 ? -1 : 1);\\n    setSelectionInner(doc, skipAtomicInSelection(doc, sel, bias, true));\\n\\n    if (!(options && options.scroll === false) && doc.cm)\\n      ensureCursorVisible(doc.cm);\\n  }\\n\\n  function setSelectionInner(doc, sel) {\\n    if (sel.equals(doc.sel)) return;\\n\\n    doc.sel = sel;\\n\\n    if (doc.cm) {\\n      doc.cm.curOp.updateInput = doc.cm.curOp.selectionChanged = true;\\n      signalCursorActivity(doc.cm);\\n    }\\n    signalLater(doc, \\\"cursorActivity\\\", doc);\\n  }\\n\\n  // Verify that the selection does not partially select any atomic\\n  // marked ranges.\\n  function reCheckSelection(doc) {\\n    setSelectionInner(doc, skipAtomicInSelection(doc, doc.sel, null, false), sel_dontScroll);\\n  }\\n\\n  // Return a selection that does not partially select any atomic\\n  // ranges.\\n  function skipAtomicInSelection(doc, sel, bias, mayClear) {\\n    var out;\\n    for (var i = 0; i < sel.ranges.length; i++) {\\n      var range = sel.ranges[i];\\n      var old = sel.ranges.length == doc.sel.ranges.length && doc.sel.ranges[i];\\n      var newAnchor = skipAtomic(doc, range.anchor, old && old.anchor, bias, mayClear);\\n      var newHead = skipAtomic(doc, range.head, old && old.head, bias, mayClear);\\n      if (out || newAnchor != range.anchor || newHead != range.head) {\\n        if (!out) out = sel.ranges.slice(0, i);\\n        out[i] = new Range(newAnchor, newHead);\\n      }\\n    }\\n    return out ? normalizeSelection(out, sel.primIndex) : sel;\\n  }\\n\\n  function skipAtomicInner(doc, pos, oldPos, dir, mayClear) {\\n    var line = getLine(doc, pos.line);\\n    if (line.markedSpans) for (var i = 0; i < line.markedSpans.length; ++i) {\\n      var sp = line.markedSpans[i], m = sp.marker;\\n      if ((sp.from == null || (m.inclusiveLeft ? sp.from <= pos.ch : sp.from < pos.ch)) &&\\n          (sp.to == null || (m.inclusiveRight ? sp.to >= pos.ch : sp.to > pos.ch))) {\\n        if (mayClear) {\\n          signal(m, \\\"beforeCursorEnter\\\");\\n          if (m.explicitlyCleared) {\\n            if (!line.markedSpans) break;\\n            else {--i; continue;}\\n          }\\n        }\\n        if (!m.atomic) continue;\\n\\n        if (oldPos) {\\n          var near = m.find(dir < 0 ? 1 : -1), diff;\\n          if (dir < 0 ? m.inclusiveRight : m.inclusiveLeft)\\n            near = movePos(doc, near, -dir, near && near.line == pos.line ? line : null);\\n          if (near && near.line == pos.line && (diff = cmp(near, oldPos)) && (dir < 0 ? diff < 0 : diff > 0))\\n            return skipAtomicInner(doc, near, pos, dir, mayClear);\\n        }\\n\\n        var far = m.find(dir < 0 ? -1 : 1);\\n        if (dir < 0 ? m.inclusiveLeft : m.inclusiveRight)\\n          far = movePos(doc, far, dir, far.line == pos.line ? line : null);\\n        return far ? skipAtomicInner(doc, far, pos, dir, mayClear) : null;\\n      }\\n    }\\n    return pos;\\n  }\\n\\n  // Ensure a given position is not inside an atomic range.\\n  function skipAtomic(doc, pos, oldPos, bias, mayClear) {\\n    var dir = bias || 1;\\n    var found = skipAtomicInner(doc, pos, oldPos, dir, mayClear) ||\\n        (!mayClear && skipAtomicInner(doc, pos, oldPos, dir, true)) ||\\n        skipAtomicInner(doc, pos, oldPos, -dir, mayClear) ||\\n        (!mayClear && skipAtomicInner(doc, pos, oldPos, -dir, true));\\n    if (!found) {\\n      doc.cantEdit = true;\\n      return Pos(doc.first, 0);\\n    }\\n    return found;\\n  }\\n\\n  function movePos(doc, pos, dir, line) {\\n    if (dir < 0 && pos.ch == 0) {\\n      if (pos.line > doc.first) return clipPos(doc, Pos(pos.line - 1));\\n      else return null;\\n    } else if (dir > 0 && pos.ch == (line || getLine(doc, pos.line)).text.length) {\\n      if (pos.line < doc.first + doc.size - 1) return Pos(pos.line + 1, 0);\\n      else return null;\\n    } else {\\n      return new Pos(pos.line, pos.ch + dir);\\n    }\\n  }\\n\\n  // SELECTION DRAWING\\n\\n  function updateSelection(cm) {\\n    cm.display.input.showSelection(cm.display.input.prepareSelection());\\n  }\\n\\n  function prepareSelection(cm, primary) {\\n    var doc = cm.doc, result = {};\\n    var curFragment = result.cursors = document.createDocumentFragment();\\n    var selFragment = result.selection = document.createDocumentFragment();\\n\\n    for (var i = 0; i < doc.sel.ranges.length; i++) {\\n      if (primary === false && i == doc.sel.primIndex) continue;\\n      var range = doc.sel.ranges[i];\\n      if (range.from().line >= cm.display.viewTo || range.to().line < cm.display.viewFrom) continue;\\n      var collapsed = range.empty();\\n      if (collapsed || cm.options.showCursorWhenSelecting)\\n        drawSelectionCursor(cm, range.head, curFragment);\\n      if (!collapsed)\\n        drawSelectionRange(cm, range, selFragment);\\n    }\\n    return result;\\n  }\\n\\n  // Draws a cursor for the given range\\n  function drawSelectionCursor(cm, head, output) {\\n    var pos = cursorCoords(cm, head, \\\"div\\\", null, null, !cm.options.singleCursorHeightPerLine);\\n\\n    var cursor = output.appendChild(elt(\\\"div\\\", \\\"\\\\u00a0\\\", \\\"CodeMirror-cursor\\\"));\\n    cursor.style.left = pos.left + \\\"px\\\";\\n    cursor.style.top = pos.top + \\\"px\\\";\\n    cursor.style.height = Math.max(0, pos.bottom - pos.top) * cm.options.cursorHeight + \\\"px\\\";\\n\\n    if (pos.other) {\\n      // Secondary cursor, shown when on a 'jump' in bi-directional text\\n      var otherCursor = output.appendChild(elt(\\\"div\\\", \\\"\\\\u00a0\\\", \\\"CodeMirror-cursor CodeMirror-secondarycursor\\\"));\\n      otherCursor.style.display = \\\"\\\";\\n      otherCursor.style.left = pos.other.left + \\\"px\\\";\\n      otherCursor.style.top = pos.other.top + \\\"px\\\";\\n      otherCursor.style.height = (pos.other.bottom - pos.other.top) * .85 + \\\"px\\\";\\n    }\\n  }\\n\\n  // Draws the given range as a highlighted selection\\n  function drawSelectionRange(cm, range, output) {\\n    var display = cm.display, doc = cm.doc;\\n    var fragment = document.createDocumentFragment();\\n    var padding = paddingH(cm.display), leftSide = padding.left;\\n    var rightSide = Math.max(display.sizerWidth, displayWidth(cm) - display.sizer.offsetLeft) - padding.right;\\n\\n    function add(left, top, width, bottom) {\\n      if (top < 0) top = 0;\\n      top = Math.round(top);\\n      bottom = Math.round(bottom);\\n      fragment.appendChild(elt(\\\"div\\\", null, \\\"CodeMirror-selected\\\", \\\"position: absolute; left: \\\" + left +\\n                               \\\"px; top: \\\" + top + \\\"px; width: \\\" + (width == null ? rightSide - left : width) +\\n                               \\\"px; height: \\\" + (bottom - top) + \\\"px\\\"));\\n    }\\n\\n    function drawForLine(line, fromArg, toArg) {\\n      var lineObj = getLine(doc, line);\\n      var lineLen = lineObj.text.length;\\n      var start, end;\\n      function coords(ch, bias) {\\n        return charCoords(cm, Pos(line, ch), \\\"div\\\", lineObj, bias);\\n      }\\n\\n      iterateBidiSections(getOrder(lineObj), fromArg || 0, toArg == null ? lineLen : toArg, function(from, to, dir) {\\n        var leftPos = coords(from, \\\"left\\\"), rightPos, left, right;\\n        if (from == to) {\\n          rightPos = leftPos;\\n          left = right = leftPos.left;\\n        } else {\\n          rightPos = coords(to - 1, \\\"right\\\");\\n          if (dir == \\\"rtl\\\") { var tmp = leftPos; leftPos = rightPos; rightPos = tmp; }\\n          left = leftPos.left;\\n          right = rightPos.right;\\n        }\\n        if (fromArg == null && from == 0) left = leftSide;\\n        if (rightPos.top - leftPos.top > 3) { // Different lines, draw top part\\n          add(left, leftPos.top, null, leftPos.bottom);\\n          left = leftSide;\\n          if (leftPos.bottom < rightPos.top) add(left, leftPos.bottom, null, rightPos.top);\\n        }\\n        if (toArg == null && to == lineLen) right = rightSide;\\n        if (!start || leftPos.top < start.top || leftPos.top == start.top && leftPos.left < start.left)\\n          start = leftPos;\\n        if (!end || rightPos.bottom > end.bottom || rightPos.bottom == end.bottom && rightPos.right > end.right)\\n          end = rightPos;\\n        if (left < leftSide + 1) left = leftSide;\\n        add(left, rightPos.top, right - left, rightPos.bottom);\\n      });\\n      return {start: start, end: end};\\n    }\\n\\n    var sFrom = range.from(), sTo = range.to();\\n    if (sFrom.line == sTo.line) {\\n      drawForLine(sFrom.line, sFrom.ch, sTo.ch);\\n    } else {\\n      var fromLine = getLine(doc, sFrom.line), toLine = getLine(doc, sTo.line);\\n      var singleVLine = visualLine(fromLine) == visualLine(toLine);\\n      var leftEnd = drawForLine(sFrom.line, sFrom.ch, singleVLine ? fromLine.text.length + 1 : null).end;\\n      var rightStart = drawForLine(sTo.line, singleVLine ? 0 : null, sTo.ch).start;\\n      if (singleVLine) {\\n        if (leftEnd.top < rightStart.top - 2) {\\n          add(leftEnd.right, leftEnd.top, null, leftEnd.bottom);\\n          add(leftSide, rightStart.top, rightStart.left, rightStart.bottom);\\n        } else {\\n          add(leftEnd.right, leftEnd.top, rightStart.left - leftEnd.right, leftEnd.bottom);\\n        }\\n      }\\n      if (leftEnd.bottom < rightStart.top)\\n        add(leftSide, leftEnd.bottom, null, rightStart.top);\\n    }\\n\\n    output.appendChild(fragment);\\n  }\\n\\n  // Cursor-blinking\\n  function restartBlink(cm) {\\n    if (!cm.state.focused) return;\\n    var display = cm.display;\\n    clearInterval(display.blinker);\\n    var on = true;\\n    display.cursorDiv.style.visibility = \\\"\\\";\\n    if (cm.options.cursorBlinkRate > 0)\\n      display.blinker = setInterval(function() {\\n        display.cursorDiv.style.visibility = (on = !on) ? \\\"\\\" : \\\"hidden\\\";\\n      }, cm.options.cursorBlinkRate);\\n    else if (cm.options.cursorBlinkRate < 0)\\n      display.cursorDiv.style.visibility = \\\"hidden\\\";\\n  }\\n\\n  // HIGHLIGHT WORKER\\n\\n  function startWorker(cm, time) {\\n    if (cm.doc.mode.startState && cm.doc.frontier < cm.display.viewTo)\\n      cm.state.highlight.set(time, bind(highlightWorker, cm));\\n  }\\n\\n  function highlightWorker(cm) {\\n    var doc = cm.doc;\\n    if (doc.frontier < doc.first) doc.frontier = doc.first;\\n    if (doc.frontier >= cm.display.viewTo) return;\\n    var end = +new Date + cm.options.workTime;\\n    var state = copyState(doc.mode, getStateBefore(cm, doc.frontier));\\n    var changedLines = [];\\n\\n    doc.iter(doc.frontier, Math.min(doc.first + doc.size, cm.display.viewTo + 500), function(line) {\\n      if (doc.frontier >= cm.display.viewFrom) { // Visible\\n        var oldStyles = line.styles, tooLong = line.text.length > cm.options.maxHighlightLength;\\n        var highlighted = highlightLine(cm, line, tooLong ? copyState(doc.mode, state) : state, true);\\n        line.styles = highlighted.styles;\\n        var oldCls = line.styleClasses, newCls = highlighted.classes;\\n        if (newCls) line.styleClasses = newCls;\\n        else if (oldCls) line.styleClasses = null;\\n        var ischange = !oldStyles || oldStyles.length != line.styles.length ||\\n          oldCls != newCls && (!oldCls || !newCls || oldCls.bgClass != newCls.bgClass || oldCls.textClass != newCls.textClass);\\n        for (var i = 0; !ischange && i < oldStyles.length; ++i) ischange = oldStyles[i] != line.styles[i];\\n        if (ischange) changedLines.push(doc.frontier);\\n        line.stateAfter = tooLong ? state : copyState(doc.mode, state);\\n      } else {\\n        if (line.text.length <= cm.options.maxHighlightLength)\\n          processLine(cm, line.text, state);\\n        line.stateAfter = doc.frontier % 5 == 0 ? copyState(doc.mode, state) : null;\\n      }\\n      ++doc.frontier;\\n      if (+new Date > end) {\\n        startWorker(cm, cm.options.workDelay);\\n        return true;\\n      }\\n    });\\n    if (changedLines.length) runInOp(cm, function() {\\n      for (var i = 0; i < changedLines.length; i++)\\n        regLineChange(cm, changedLines[i], \\\"text\\\");\\n    });\\n  }\\n\\n  // Finds the line to start with when starting a parse. Tries to\\n  // find a line with a stateAfter, so that it can start with a\\n  // valid state. If that fails, it returns the line with the\\n  // smallest indentation, which tends to need the least context to\\n  // parse correctly.\\n  function findStartLine(cm, n, precise) {\\n    var minindent, minline, doc = cm.doc;\\n    var lim = precise ? -1 : n - (cm.doc.mode.innerMode ? 1000 : 100);\\n    for (var search = n; search > lim; --search) {\\n      if (search <= doc.first) return doc.first;\\n      var line = getLine(doc, search - 1);\\n      if (line.stateAfter && (!precise || search <= doc.frontier)) return search;\\n      var indented = countColumn(line.text, null, cm.options.tabSize);\\n      if (minline == null || minindent > indented) {\\n        minline = search - 1;\\n        minindent = indented;\\n      }\\n    }\\n    return minline;\\n  }\\n\\n  function getStateBefore(cm, n, precise) {\\n    var doc = cm.doc, display = cm.display;\\n    if (!doc.mode.startState) return true;\\n    var pos = findStartLine(cm, n, precise), state = pos > doc.first && getLine(doc, pos-1).stateAfter;\\n    if (!state) state = startState(doc.mode);\\n    else state = copyState(doc.mode, state);\\n    doc.iter(pos, n, function(line) {\\n      processLine(cm, line.text, state);\\n      var save = pos == n - 1 || pos % 5 == 0 || pos >= display.viewFrom && pos < display.viewTo;\\n      line.stateAfter = save ? copyState(doc.mode, state) : null;\\n      ++pos;\\n    });\\n    if (precise) doc.frontier = pos;\\n    return state;\\n  }\\n\\n  // POSITION MEASUREMENT\\n\\n  function paddingTop(display) {return display.lineSpace.offsetTop;}\\n  function paddingVert(display) {return display.mover.offsetHeight - display.lineSpace.offsetHeight;}\\n  function paddingH(display) {\\n    if (display.cachedPaddingH) return display.cachedPaddingH;\\n    var e = removeChildrenAndAdd(display.measure, elt(\\\"pre\\\", \\\"x\\\"));\\n    var style = window.getComputedStyle ? window.getComputedStyle(e) : e.currentStyle;\\n    var data = {left: parseInt(style.paddingLeft), right: parseInt(style.paddingRight)};\\n    if (!isNaN(data.left) && !isNaN(data.right)) display.cachedPaddingH = data;\\n    return data;\\n  }\\n\\n  function scrollGap(cm) { return scrollerGap - cm.display.nativeBarWidth; }\\n  function displayWidth(cm) {\\n    return cm.display.scroller.clientWidth - scrollGap(cm) - cm.display.barWidth;\\n  }\\n  function displayHeight(cm) {\\n    return cm.display.scroller.clientHeight - scrollGap(cm) - cm.display.barHeight;\\n  }\\n\\n  // Ensure the lineView.wrapping.heights array is populated. This is\\n  // an array of bottom offsets for the lines that make up a drawn\\n  // line. When lineWrapping is on, there might be more than one\\n  // height.\\n  function ensureLineHeights(cm, lineView, rect) {\\n    var wrapping = cm.options.lineWrapping;\\n    var curWidth = wrapping && displayWidth(cm);\\n    if (!lineView.measure.heights || wrapping && lineView.measure.width != curWidth) {\\n      var heights = lineView.measure.heights = [];\\n      if (wrapping) {\\n        lineView.measure.width = curWidth;\\n        var rects = lineView.text.firstChild.getClientRects();\\n        for (var i = 0; i < rects.length - 1; i++) {\\n          var cur = rects[i], next = rects[i + 1];\\n          if (Math.abs(cur.bottom - next.bottom) > 2)\\n            heights.push((cur.bottom + next.top) / 2 - rect.top);\\n        }\\n      }\\n      heights.push(rect.bottom - rect.top);\\n    }\\n  }\\n\\n  // Find a line map (mapping character offsets to text nodes) and a\\n  // measurement cache for the given line number. (A line view might\\n  // contain multiple lines when collapsed ranges are present.)\\n  function mapFromLineView(lineView, line, lineN) {\\n    if (lineView.line == line)\\n      return {map: lineView.measure.map, cache: lineView.measure.cache};\\n    for (var i = 0; i < lineView.rest.length; i++)\\n      if (lineView.rest[i] == line)\\n        return {map: lineView.measure.maps[i], cache: lineView.measure.caches[i]};\\n    for (var i = 0; i < lineView.rest.length; i++)\\n      if (lineNo(lineView.rest[i]) > lineN)\\n        return {map: lineView.measure.maps[i], cache: lineView.measure.caches[i], before: true};\\n  }\\n\\n  // Render a line into the hidden node display.externalMeasured. Used\\n  // when measurement is needed for a line that's not in the viewport.\\n  function updateExternalMeasurement(cm, line) {\\n    line = visualLine(line);\\n    var lineN = lineNo(line);\\n    var view = cm.display.externalMeasured = new LineView(cm.doc, line, lineN);\\n    view.lineN = lineN;\\n    var built = view.built = buildLineContent(cm, view);\\n    view.text = built.pre;\\n    removeChildrenAndAdd(cm.display.lineMeasure, built.pre);\\n    return view;\\n  }\\n\\n  // Get a {top, bottom, left, right} box (in line-local coordinates)\\n  // for a given character.\\n  function measureChar(cm, line, ch, bias) {\\n    return measureCharPrepared(cm, prepareMeasureForLine(cm, line), ch, bias);\\n  }\\n\\n  // Find a line view that corresponds to the given line number.\\n  function findViewForLine(cm, lineN) {\\n    if (lineN >= cm.display.viewFrom && lineN < cm.display.viewTo)\\n      return cm.display.view[findViewIndex(cm, lineN)];\\n    var ext = cm.display.externalMeasured;\\n    if (ext && lineN >= ext.lineN && lineN < ext.lineN + ext.size)\\n      return ext;\\n  }\\n\\n  // Measurement can be split in two steps, the set-up work that\\n  // applies to the whole line, and the measurement of the actual\\n  // character. Functions like coordsChar, that need to do a lot of\\n  // measurements in a row, can thus ensure that the set-up work is\\n  // only done once.\\n  function prepareMeasureForLine(cm, line) {\\n    var lineN = lineNo(line);\\n    var view = findViewForLine(cm, lineN);\\n    if (view && !view.text) {\\n      view = null;\\n    } else if (view && view.changes) {\\n      updateLineForChanges(cm, view, lineN, getDimensions(cm));\\n      cm.curOp.forceUpdate = true;\\n    }\\n    if (!view)\\n      view = updateExternalMeasurement(cm, line);\\n\\n    var info = mapFromLineView(view, line, lineN);\\n    return {\\n      line: line, view: view, rect: null,\\n      map: info.map, cache: info.cache, before: info.before,\\n      hasHeights: false\\n    };\\n  }\\n\\n  // Given a prepared measurement object, measures the position of an\\n  // actual character (or fetches it from the cache).\\n  function measureCharPrepared(cm, prepared, ch, bias, varHeight) {\\n    if (prepared.before) ch = -1;\\n    var key = ch + (bias || \\\"\\\"), found;\\n    if (prepared.cache.hasOwnProperty(key)) {\\n      found = prepared.cache[key];\\n    } else {\\n      if (!prepared.rect)\\n        prepared.rect = prepared.view.text.getBoundingClientRect();\\n      if (!prepared.hasHeights) {\\n        ensureLineHeights(cm, prepared.view, prepared.rect);\\n        prepared.hasHeights = true;\\n      }\\n      found = measureCharInner(cm, prepared, ch, bias);\\n      if (!found.bogus) prepared.cache[key] = found;\\n    }\\n    return {left: found.left, right: found.right,\\n            top: varHeight ? found.rtop : found.top,\\n            bottom: varHeight ? found.rbottom : found.bottom};\\n  }\\n\\n  var nullRect = {left: 0, right: 0, top: 0, bottom: 0};\\n\\n  function nodeAndOffsetInLineMap(map, ch, bias) {\\n    var node, start, end, collapse;\\n    // First, search the line map for the text node corresponding to,\\n    // or closest to, the target character.\\n    for (var i = 0; i < map.length; i += 3) {\\n      var mStart = map[i], mEnd = map[i + 1];\\n      if (ch < mStart) {\\n        start = 0; end = 1;\\n        collapse = \\\"left\\\";\\n      } else if (ch < mEnd) {\\n        start = ch - mStart;\\n        end = start + 1;\\n      } else if (i == map.length - 3 || ch == mEnd && map[i + 3] > ch) {\\n        end = mEnd - mStart;\\n        start = end - 1;\\n        if (ch >= mEnd) collapse = \\\"right\\\";\\n      }\\n      if (start != null) {\\n        node = map[i + 2];\\n        if (mStart == mEnd && bias == (node.insertLeft ? \\\"left\\\" : \\\"right\\\"))\\n          collapse = bias;\\n        if (bias == \\\"left\\\" && start == 0)\\n          while (i && map[i - 2] == map[i - 3] && map[i - 1].insertLeft) {\\n            node = map[(i -= 3) + 2];\\n            collapse = \\\"left\\\";\\n          }\\n        if (bias == \\\"right\\\" && start == mEnd - mStart)\\n          while (i < map.length - 3 && map[i + 3] == map[i + 4] && !map[i + 5].insertLeft) {\\n            node = map[(i += 3) + 2];\\n            collapse = \\\"right\\\";\\n          }\\n        break;\\n      }\\n    }\\n    return {node: node, start: start, end: end, collapse: collapse, coverStart: mStart, coverEnd: mEnd};\\n  }\\n\\n  function getUsefulRect(rects, bias) {\\n    var rect = nullRect\\n    if (bias == \\\"left\\\") for (var i = 0; i < rects.length; i++) {\\n      if ((rect = rects[i]).left != rect.right) break\\n    } else for (var i = rects.length - 1; i >= 0; i--) {\\n      if ((rect = rects[i]).left != rect.right) break\\n    }\\n    return rect\\n  }\\n\\n  function measureCharInner(cm, prepared, ch, bias) {\\n    var place = nodeAndOffsetInLineMap(prepared.map, ch, bias);\\n    var node = place.node, start = place.start, end = place.end, collapse = place.collapse;\\n\\n    var rect;\\n    if (node.nodeType == 3) { // If it is a text node, use a range to retrieve the coordinates.\\n      for (var i = 0; i < 4; i++) { // Retry a maximum of 4 times when nonsense rectangles are returned\\n        while (start && isExtendingChar(prepared.line.text.charAt(place.coverStart + start))) --start;\\n        while (place.coverStart + end < place.coverEnd && isExtendingChar(prepared.line.text.charAt(place.coverStart + end))) ++end;\\n        if (ie && ie_version < 9 && start == 0 && end == place.coverEnd - place.coverStart)\\n          rect = node.parentNode.getBoundingClientRect();\\n        else\\n          rect = getUsefulRect(range(node, start, end).getClientRects(), bias)\\n        if (rect.left || rect.right || start == 0) break;\\n        end = start;\\n        start = start - 1;\\n        collapse = \\\"right\\\";\\n      }\\n      if (ie && ie_version < 11) rect = maybeUpdateRectForZooming(cm.display.measure, rect);\\n    } else { // If it is a widget, simply get the box for the whole widget.\\n      if (start > 0) collapse = bias = \\\"right\\\";\\n      var rects;\\n      if (cm.options.lineWrapping && (rects = node.getClientRects()).length > 1)\\n        rect = rects[bias == \\\"right\\\" ? rects.length - 1 : 0];\\n      else\\n        rect = node.getBoundingClientRect();\\n    }\\n    if (ie && ie_version < 9 && !start && (!rect || !rect.left && !rect.right)) {\\n      var rSpan = node.parentNode.getClientRects()[0];\\n      if (rSpan)\\n        rect = {left: rSpan.left, right: rSpan.left + charWidth(cm.display), top: rSpan.top, bottom: rSpan.bottom};\\n      else\\n        rect = nullRect;\\n    }\\n\\n    var rtop = rect.top - prepared.rect.top, rbot = rect.bottom - prepared.rect.top;\\n    var mid = (rtop + rbot) / 2;\\n    var heights = prepared.view.measure.heights;\\n    for (var i = 0; i < heights.length - 1; i++)\\n      if (mid < heights[i]) break;\\n    var top = i ? heights[i - 1] : 0, bot = heights[i];\\n    var result = {left: (collapse == \\\"right\\\" ? rect.right : rect.left) - prepared.rect.left,\\n                  right: (collapse == \\\"left\\\" ? rect.left : rect.right) - prepared.rect.left,\\n                  top: top, bottom: bot};\\n    if (!rect.left && !rect.right) result.bogus = true;\\n    if (!cm.options.singleCursorHeightPerLine) { result.rtop = rtop; result.rbottom = rbot; }\\n\\n    return result;\\n  }\\n\\n  // Work around problem with bounding client rects on ranges being\\n  // returned incorrectly when zoomed on IE10 and below.\\n  function maybeUpdateRectForZooming(measure, rect) {\\n    if (!window.screen || screen.logicalXDPI == null ||\\n        screen.logicalXDPI == screen.deviceXDPI || !hasBadZoomedRects(measure))\\n      return rect;\\n    var scaleX = screen.logicalXDPI / screen.deviceXDPI;\\n    var scaleY = screen.logicalYDPI / screen.deviceYDPI;\\n    return {left: rect.left * scaleX, right: rect.right * scaleX,\\n            top: rect.top * scaleY, bottom: rect.bottom * scaleY};\\n  }\\n\\n  function clearLineMeasurementCacheFor(lineView) {\\n    if (lineView.measure) {\\n      lineView.measure.cache = {};\\n      lineView.measure.heights = null;\\n      if (lineView.rest) for (var i = 0; i < lineView.rest.length; i++)\\n        lineView.measure.caches[i] = {};\\n    }\\n  }\\n\\n  function clearLineMeasurementCache(cm) {\\n    cm.display.externalMeasure = null;\\n    removeChildren(cm.display.lineMeasure);\\n    for (var i = 0; i < cm.display.view.length; i++)\\n      clearLineMeasurementCacheFor(cm.display.view[i]);\\n  }\\n\\n  function clearCaches(cm) {\\n    clearLineMeasurementCache(cm);\\n    cm.display.cachedCharWidth = cm.display.cachedTextHeight = cm.display.cachedPaddingH = null;\\n    if (!cm.options.lineWrapping) cm.display.maxLineChanged = true;\\n    cm.display.lineNumChars = null;\\n  }\\n\\n  function pageScrollX() { return window.pageXOffset || (document.documentElement || document.body).scrollLeft; }\\n  function pageScrollY() { return window.pageYOffset || (document.documentElement || document.body).scrollTop; }\\n\\n  // Converts a {top, bottom, left, right} box from line-local\\n  // coordinates into another coordinate system. Context may be one of\\n  // \\\"line\\\", \\\"div\\\" (display.lineDiv), \\\"local\\\"/null (editor), \\\"window\\\",\\n  // or \\\"page\\\".\\n  function intoCoordSystem(cm, lineObj, rect, context) {\\n    if (lineObj.widgets) for (var i = 0; i < lineObj.widgets.length; ++i) if (lineObj.widgets[i].above) {\\n      var size = widgetHeight(lineObj.widgets[i]);\\n      rect.top += size; rect.bottom += size;\\n    }\\n    if (context == \\\"line\\\") return rect;\\n    if (!context) context = \\\"local\\\";\\n    var yOff = heightAtLine(lineObj);\\n    if (context == \\\"local\\\") yOff += paddingTop(cm.display);\\n    else yOff -= cm.display.viewOffset;\\n    if (context == \\\"page\\\" || context == \\\"window\\\") {\\n      var lOff = cm.display.lineSpace.getBoundingClientRect();\\n      yOff += lOff.top + (context == \\\"window\\\" ? 0 : pageScrollY());\\n      var xOff = lOff.left + (context == \\\"window\\\" ? 0 : pageScrollX());\\n      rect.left += xOff; rect.right += xOff;\\n    }\\n    rect.top += yOff; rect.bottom += yOff;\\n    return rect;\\n  }\\n\\n  // Coverts a box from \\\"div\\\" coords to another coordinate system.\\n  // Context may be \\\"window\\\", \\\"page\\\", \\\"div\\\", or \\\"local\\\"/null.\\n  function fromCoordSystem(cm, coords, context) {\\n    if (context == \\\"div\\\") return coords;\\n    var left = coords.left, top = coords.top;\\n    // First move into \\\"page\\\" coordinate system\\n    if (context == \\\"page\\\") {\\n      left -= pageScrollX();\\n      top -= pageScrollY();\\n    } else if (context == \\\"local\\\" || !context) {\\n      var localBox = cm.display.sizer.getBoundingClientRect();\\n      left += localBox.left;\\n      top += localBox.top;\\n    }\\n\\n    var lineSpaceBox = cm.display.lineSpace.getBoundingClientRect();\\n    return {left: left - lineSpaceBox.left, top: top - lineSpaceBox.top};\\n  }\\n\\n  function charCoords(cm, pos, context, lineObj, bias) {\\n    if (!lineObj) lineObj = getLine(cm.doc, pos.line);\\n    return intoCoordSystem(cm, lineObj, measureChar(cm, lineObj, pos.ch, bias), context);\\n  }\\n\\n  // Returns a box for a given cursor position, which may have an\\n  // 'other' property containing the position of the secondary cursor\\n  // on a bidi boundary.\\n  function cursorCoords(cm, pos, context, lineObj, preparedMeasure, varHeight) {\\n    lineObj = lineObj || getLine(cm.doc, pos.line);\\n    if (!preparedMeasure) preparedMeasure = prepareMeasureForLine(cm, lineObj);\\n    function get(ch, right) {\\n      var m = measureCharPrepared(cm, preparedMeasure, ch, right ? \\\"right\\\" : \\\"left\\\", varHeight);\\n      if (right) m.left = m.right; else m.right = m.left;\\n      return intoCoordSystem(cm, lineObj, m, context);\\n    }\\n    function getBidi(ch, partPos) {\\n      var part = order[partPos], right = part.level % 2;\\n      if (ch == bidiLeft(part) && partPos && part.level < order[partPos - 1].level) {\\n        part = order[--partPos];\\n        ch = bidiRight(part) - (part.level % 2 ? 0 : 1);\\n        right = true;\\n      } else if (ch == bidiRight(part) && partPos < order.length - 1 && part.level < order[partPos + 1].level) {\\n        part = order[++partPos];\\n        ch = bidiLeft(part) - part.level % 2;\\n        right = false;\\n      }\\n      if (right && ch == part.to && ch > part.from) return get(ch - 1);\\n      return get(ch, right);\\n    }\\n    var order = getOrder(lineObj), ch = pos.ch;\\n    if (!order) return get(ch);\\n    var partPos = getBidiPartAt(order, ch);\\n    var val = getBidi(ch, partPos);\\n    if (bidiOther != null) val.other = getBidi(ch, bidiOther);\\n    return val;\\n  }\\n\\n  // Used to cheaply estimate the coordinates for a position. Used for\\n  // intermediate scroll updates.\\n  function estimateCoords(cm, pos) {\\n    var left = 0, pos = clipPos(cm.doc, pos);\\n    if (!cm.options.lineWrapping) left = charWidth(cm.display) * pos.ch;\\n    var lineObj = getLine(cm.doc, pos.line);\\n    var top = heightAtLine(lineObj) + paddingTop(cm.display);\\n    return {left: left, right: left, top: top, bottom: top + lineObj.height};\\n  }\\n\\n  // Positions returned by coordsChar contain some extra information.\\n  // xRel is the relative x position of the input coordinates compared\\n  // to the found position (so xRel > 0 means the coordinates are to\\n  // the right of the character position, for example). When outside\\n  // is true, that means the coordinates lie outside the line's\\n  // vertical range.\\n  function PosWithInfo(line, ch, outside, xRel) {\\n    var pos = Pos(line, ch);\\n    pos.xRel = xRel;\\n    if (outside) pos.outside = true;\\n    return pos;\\n  }\\n\\n  // Compute the character position closest to the given coordinates.\\n  // Input must be lineSpace-local (\\\"div\\\" coordinate system).\\n  function coordsChar(cm, x, y) {\\n    var doc = cm.doc;\\n    y += cm.display.viewOffset;\\n    if (y < 0) return PosWithInfo(doc.first, 0, true, -1);\\n    var lineN = lineAtHeight(doc, y), last = doc.first + doc.size - 1;\\n    if (lineN > last)\\n      return PosWithInfo(doc.first + doc.size - 1, getLine(doc, last).text.length, true, 1);\\n    if (x < 0) x = 0;\\n\\n    var lineObj = getLine(doc, lineN);\\n    for (;;) {\\n      var found = coordsCharInner(cm, lineObj, lineN, x, y);\\n      var merged = collapsedSpanAtEnd(lineObj);\\n      var mergedPos = merged && merged.find(0, true);\\n      if (merged && (found.ch > mergedPos.from.ch || found.ch == mergedPos.from.ch && found.xRel > 0))\\n        lineN = lineNo(lineObj = mergedPos.to.line);\\n      else\\n        return found;\\n    }\\n  }\\n\\n  function coordsCharInner(cm, lineObj, lineNo, x, y) {\\n    var innerOff = y - heightAtLine(lineObj);\\n    var wrongLine = false, adjust = 2 * cm.display.wrapper.clientWidth;\\n    var preparedMeasure = prepareMeasureForLine(cm, lineObj);\\n\\n    function getX(ch) {\\n      var sp = cursorCoords(cm, Pos(lineNo, ch), \\\"line\\\", lineObj, preparedMeasure);\\n      wrongLine = true;\\n      if (innerOff > sp.bottom) return sp.left - adjust;\\n      else if (innerOff < sp.top) return sp.left + adjust;\\n      else wrongLine = false;\\n      return sp.left;\\n    }\\n\\n    var bidi = getOrder(lineObj), dist = lineObj.text.length;\\n    var from = lineLeft(lineObj), to = lineRight(lineObj);\\n    var fromX = getX(from), fromOutside = wrongLine, toX = getX(to), toOutside = wrongLine;\\n\\n    if (x > toX) return PosWithInfo(lineNo, to, toOutside, 1);\\n    // Do a binary search between these bounds.\\n    for (;;) {\\n      if (bidi ? to == from || to == moveVisually(lineObj, from, 1) : to - from <= 1) {\\n        var ch = x < fromX || x - fromX <= toX - x ? from : to;\\n        var outside = ch == from ? fromOutside : toOutside\\n        var xDiff = x - (ch == from ? fromX : toX);\\n        // This is a kludge to handle the case where the coordinates\\n        // are after a line-wrapped line. We should replace it with a\\n        // more general handling of cursor positions around line\\n        // breaks. (Issue #4078)\\n        if (toOutside && !bidi && !/\\\\s/.test(lineObj.text.charAt(ch)) && xDiff > 0 &&\\n            ch < lineObj.text.length && preparedMeasure.view.measure.heights.length > 1) {\\n          var charSize = measureCharPrepared(cm, preparedMeasure, ch, \\\"right\\\");\\n          if (innerOff <= charSize.bottom && innerOff >= charSize.top && Math.abs(x - charSize.right) < xDiff) {\\n            outside = false\\n            ch++\\n            xDiff = x - charSize.right\\n          }\\n        }\\n        while (isExtendingChar(lineObj.text.charAt(ch))) ++ch;\\n        var pos = PosWithInfo(lineNo, ch, outside, xDiff < -1 ? -1 : xDiff > 1 ? 1 : 0);\\n        return pos;\\n      }\\n      var step = Math.ceil(dist / 2), middle = from + step;\\n      if (bidi) {\\n        middle = from;\\n        for (var i = 0; i < step; ++i) middle = moveVisually(lineObj, middle, 1);\\n      }\\n      var middleX = getX(middle);\\n      if (middleX > x) {to = middle; toX = middleX; if (toOutside = wrongLine) toX += 1000; dist = step;}\\n      else {from = middle; fromX = middleX; fromOutside = wrongLine; dist -= step;}\\n    }\\n  }\\n\\n  var measureText;\\n  // Compute the default text height.\\n  function textHeight(display) {\\n    if (display.cachedTextHeight != null) return display.cachedTextHeight;\\n    if (measureText == null) {\\n      measureText = elt(\\\"pre\\\");\\n      // Measure a bunch of lines, for browsers that compute\\n      // fractional heights.\\n      for (var i = 0; i < 49; ++i) {\\n        measureText.appendChild(document.createTextNode(\\\"x\\\"));\\n        measureText.appendChild(elt(\\\"br\\\"));\\n      }\\n      measureText.appendChild(document.createTextNode(\\\"x\\\"));\\n    }\\n    removeChildrenAndAdd(display.measure, measureText);\\n    var height = measureText.offsetHeight / 50;\\n    if (height > 3) display.cachedTextHeight = height;\\n    removeChildren(display.measure);\\n    return height || 1;\\n  }\\n\\n  // Compute the default character width.\\n  function charWidth(display) {\\n    if (display.cachedCharWidth != null) return display.cachedCharWidth;\\n    var anchor = elt(\\\"span\\\", \\\"xxxxxxxxxx\\\");\\n    var pre = elt(\\\"pre\\\", [anchor]);\\n    removeChildrenAndAdd(display.measure, pre);\\n    var rect = anchor.getBoundingClientRect(), width = (rect.right - rect.left) / 10;\\n    if (width > 2) display.cachedCharWidth = width;\\n    return width || 10;\\n  }\\n\\n  // OPERATIONS\\n\\n  // Operations are used to wrap a series of changes to the editor\\n  // state in such a way that each change won't have to update the\\n  // cursor and display (which would be awkward, slow, and\\n  // error-prone). Instead, display updates are batched and then all\\n  // combined and executed at once.\\n\\n  var operationGroup = null;\\n\\n  var nextOpId = 0;\\n  // Start a new operation.\\n  function startOperation(cm) {\\n    cm.curOp = {\\n      cm: cm,\\n      viewChanged: false,      // Flag that indicates that lines might need to be redrawn\\n      startHeight: cm.doc.height, // Used to detect need to update scrollbar\\n      forceUpdate: false,      // Used to force a redraw\\n      updateInput: null,       // Whether to reset the input textarea\\n      typing: false,           // Whether this reset should be careful to leave existing text (for compositing)\\n      changeObjs: null,        // Accumulated changes, for firing change events\\n      cursorActivityHandlers: null, // Set of handlers to fire cursorActivity on\\n      cursorActivityCalled: 0, // Tracks which cursorActivity handlers have been called already\\n      selectionChanged: false, // Whether the selection needs to be redrawn\\n      updateMaxLine: false,    // Set when the widest line needs to be determined anew\\n      scrollLeft: null, scrollTop: null, // Intermediate scroll position, not pushed to DOM yet\\n      scrollToPos: null,       // Used to scroll to a specific position\\n      focus: false,\\n      id: ++nextOpId           // Unique ID\\n    };\\n    if (operationGroup) {\\n      operationGroup.ops.push(cm.curOp);\\n    } else {\\n      cm.curOp.ownsGroup = operationGroup = {\\n        ops: [cm.curOp],\\n        delayedCallbacks: []\\n      };\\n    }\\n  }\\n\\n  function fireCallbacksForOps(group) {\\n    // Calls delayed callbacks and cursorActivity handlers until no\\n    // new ones appear\\n    var callbacks = group.delayedCallbacks, i = 0;\\n    do {\\n      for (; i < callbacks.length; i++)\\n        callbacks[i].call(null);\\n      for (var j = 0; j < group.ops.length; j++) {\\n        var op = group.ops[j];\\n        if (op.cursorActivityHandlers)\\n          while (op.cursorActivityCalled < op.cursorActivityHandlers.length)\\n            op.cursorActivityHandlers[op.cursorActivityCalled++].call(null, op.cm);\\n      }\\n    } while (i < callbacks.length);\\n  }\\n\\n  // Finish an operation, updating the display and signalling delayed events\\n  function endOperation(cm) {\\n    var op = cm.curOp, group = op.ownsGroup;\\n    if (!group) return;\\n\\n    try { fireCallbacksForOps(group); }\\n    finally {\\n      operationGroup = null;\\n      for (var i = 0; i < group.ops.length; i++)\\n        group.ops[i].cm.curOp = null;\\n      endOperations(group);\\n    }\\n  }\\n\\n  // The DOM updates done when an operation finishes are batched so\\n  // that the minimum number of relayouts are required.\\n  function endOperations(group) {\\n    var ops = group.ops;\\n    for (var i = 0; i < ops.length; i++) // Read DOM\\n      endOperation_R1(ops[i]);\\n    for (var i = 0; i < ops.length; i++) // Write DOM (maybe)\\n      endOperation_W1(ops[i]);\\n    for (var i = 0; i < ops.length; i++) // Read DOM\\n      endOperation_R2(ops[i]);\\n    for (var i = 0; i < ops.length; i++) // Write DOM (maybe)\\n      endOperation_W2(ops[i]);\\n    for (var i = 0; i < ops.length; i++) // Read DOM\\n      endOperation_finish(ops[i]);\\n  }\\n\\n  function endOperation_R1(op) {\\n    var cm = op.cm, display = cm.display;\\n    maybeClipScrollbars(cm);\\n    if (op.updateMaxLine) findMaxLine(cm);\\n\\n    op.mustUpdate = op.viewChanged || op.forceUpdate || op.scrollTop != null ||\\n      op.scrollToPos && (op.scrollToPos.from.line < display.viewFrom ||\\n                         op.scrollToPos.to.line >= display.viewTo) ||\\n      display.maxLineChanged && cm.options.lineWrapping;\\n    op.update = op.mustUpdate &&\\n      new DisplayUpdate(cm, op.mustUpdate && {top: op.scrollTop, ensure: op.scrollToPos}, op.forceUpdate);\\n  }\\n\\n  function endOperation_W1(op) {\\n    op.updatedDisplay = op.mustUpdate && updateDisplayIfNeeded(op.cm, op.update);\\n  }\\n\\n  function endOperation_R2(op) {\\n    var cm = op.cm, display = cm.display;\\n    if (op.updatedDisplay) updateHeightsInViewport(cm);\\n\\n    op.barMeasure = measureForScrollbars(cm);\\n\\n    // If the max line changed since it was last measured, measure it,\\n    // and ensure the document's width matches it.\\n    // updateDisplay_W2 will use these properties to do the actual resizing\\n    if (display.maxLineChanged && !cm.options.lineWrapping) {\\n      op.adjustWidthTo = measureChar(cm, display.maxLine, display.maxLine.text.length).left + 3;\\n      cm.display.sizerWidth = op.adjustWidthTo;\\n      op.barMeasure.scrollWidth =\\n        Math.max(display.scroller.clientWidth, display.sizer.offsetLeft + op.adjustWidthTo + scrollGap(cm) + cm.display.barWidth);\\n      op.maxScrollLeft = Math.max(0, display.sizer.offsetLeft + op.adjustWidthTo - displayWidth(cm));\\n    }\\n\\n    if (op.updatedDisplay || op.selectionChanged)\\n      op.preparedSelection = display.input.prepareSelection(op.focus);\\n  }\\n\\n  function endOperation_W2(op) {\\n    var cm = op.cm;\\n\\n    if (op.adjustWidthTo != null) {\\n      cm.display.sizer.style.minWidth = op.adjustWidthTo + \\\"px\\\";\\n      if (op.maxScrollLeft < cm.doc.scrollLeft)\\n        setScrollLeft(cm, Math.min(cm.display.scroller.scrollLeft, op.maxScrollLeft), true);\\n      cm.display.maxLineChanged = false;\\n    }\\n\\n    var takeFocus = op.focus && op.focus == activeElt() && (!document.hasFocus || document.hasFocus())\\n    if (op.preparedSelection)\\n      cm.display.input.showSelection(op.preparedSelection, takeFocus);\\n    if (op.updatedDisplay || op.startHeight != cm.doc.height)\\n      updateScrollbars(cm, op.barMeasure);\\n    if (op.updatedDisplay)\\n      setDocumentHeight(cm, op.barMeasure);\\n\\n    if (op.selectionChanged) restartBlink(cm);\\n\\n    if (cm.state.focused && op.updateInput)\\n      cm.display.input.reset(op.typing);\\n    if (takeFocus) ensureFocus(op.cm);\\n  }\\n\\n  function endOperation_finish(op) {\\n    var cm = op.cm, display = cm.display, doc = cm.doc;\\n\\n    if (op.updatedDisplay) postUpdateDisplay(cm, op.update);\\n\\n    // Abort mouse wheel delta measurement, when scrolling explicitly\\n    if (display.wheelStartX != null && (op.scrollTop != null || op.scrollLeft != null || op.scrollToPos))\\n      display.wheelStartX = display.wheelStartY = null;\\n\\n    // Propagate the scroll position to the actual DOM scroller\\n    if (op.scrollTop != null && (display.scroller.scrollTop != op.scrollTop || op.forceScroll)) {\\n      doc.scrollTop = Math.max(0, Math.min(display.scroller.scrollHeight - display.scroller.clientHeight, op.scrollTop));\\n      display.scrollbars.setScrollTop(doc.scrollTop);\\n      display.scroller.scrollTop = doc.scrollTop;\\n    }\\n    if (op.scrollLeft != null && (display.scroller.scrollLeft != op.scrollLeft || op.forceScroll)) {\\n      doc.scrollLeft = Math.max(0, Math.min(display.scroller.scrollWidth - display.scroller.clientWidth, op.scrollLeft));\\n      display.scrollbars.setScrollLeft(doc.scrollLeft);\\n      display.scroller.scrollLeft = doc.scrollLeft;\\n      alignHorizontally(cm);\\n    }\\n    // If we need to scroll a specific position into view, do so.\\n    if (op.scrollToPos) {\\n      var coords = scrollPosIntoView(cm, clipPos(doc, op.scrollToPos.from),\\n                                     clipPos(doc, op.scrollToPos.to), op.scrollToPos.margin);\\n      if (op.scrollToPos.isCursor && cm.state.focused) maybeScrollWindow(cm, coords);\\n    }\\n\\n    // Fire events for markers that are hidden/unidden by editing or\\n    // undoing\\n    var hidden = op.maybeHiddenMarkers, unhidden = op.maybeUnhiddenMarkers;\\n    if (hidden) for (var i = 0; i < hidden.length; ++i)\\n      if (!hidden[i].lines.length) signal(hidden[i], \\\"hide\\\");\\n    if (unhidden) for (var i = 0; i < unhidden.length; ++i)\\n      if (unhidden[i].lines.length) signal(unhidden[i], \\\"unhide\\\");\\n\\n    if (display.wrapper.offsetHeight)\\n      doc.scrollTop = cm.display.scroller.scrollTop;\\n\\n    // Fire change events, and delayed event handlers\\n    if (op.changeObjs)\\n      signal(cm, \\\"changes\\\", cm, op.changeObjs);\\n    if (op.update)\\n      op.update.finish();\\n  }\\n\\n  // Run the given function in an operation\\n  function runInOp(cm, f) {\\n    if (cm.curOp) return f();\\n    startOperation(cm);\\n    try { return f(); }\\n    finally { endOperation(cm); }\\n  }\\n  // Wraps a function in an operation. Returns the wrapped function.\\n  function operation(cm, f) {\\n    return function() {\\n      if (cm.curOp) return f.apply(cm, arguments);\\n      startOperation(cm);\\n      try { return f.apply(cm, arguments); }\\n      finally { endOperation(cm); }\\n    };\\n  }\\n  // Used to add methods to editor and doc instances, wrapping them in\\n  // operations.\\n  function methodOp(f) {\\n    return function() {\\n      if (this.curOp) return f.apply(this, arguments);\\n      startOperation(this);\\n      try { return f.apply(this, arguments); }\\n      finally { endOperation(this); }\\n    };\\n  }\\n  function docMethodOp(f) {\\n    return function() {\\n      var cm = this.cm;\\n      if (!cm || cm.curOp) return f.apply(this, arguments);\\n      startOperation(cm);\\n      try { return f.apply(this, arguments); }\\n      finally { endOperation(cm); }\\n    };\\n  }\\n\\n  // VIEW TRACKING\\n\\n  // These objects are used to represent the visible (currently drawn)\\n  // part of the document. A LineView may correspond to multiple\\n  // logical lines, if those are connected by collapsed ranges.\\n  function LineView(doc, line, lineN) {\\n    // The starting line\\n    this.line = line;\\n    // Continuing lines, if any\\n    this.rest = visualLineContinued(line);\\n    // Number of logical lines in this visual line\\n    this.size = this.rest ? lineNo(lst(this.rest)) - lineN + 1 : 1;\\n    this.node = this.text = null;\\n    this.hidden = lineIsHidden(doc, line);\\n  }\\n\\n  // Create a range of LineView objects for the given lines.\\n  function buildViewArray(cm, from, to) {\\n    var array = [], nextPos;\\n    for (var pos = from; pos < to; pos = nextPos) {\\n      var view = new LineView(cm.doc, getLine(cm.doc, pos), pos);\\n      nextPos = pos + view.size;\\n      array.push(view);\\n    }\\n    return array;\\n  }\\n\\n  // Updates the display.view data structure for a given change to the\\n  // document. From and to are in pre-change coordinates. Lendiff is\\n  // the amount of lines added or subtracted by the change. This is\\n  // used for changes that span multiple lines, or change the way\\n  // lines are divided into visual lines. regLineChange (below)\\n  // registers single-line changes.\\n  function regChange(cm, from, to, lendiff) {\\n    if (from == null) from = cm.doc.first;\\n    if (to == null) to = cm.doc.first + cm.doc.size;\\n    if (!lendiff) lendiff = 0;\\n\\n    var display = cm.display;\\n    if (lendiff && to < display.viewTo &&\\n        (display.updateLineNumbers == null || display.updateLineNumbers > from))\\n      display.updateLineNumbers = from;\\n\\n    cm.curOp.viewChanged = true;\\n\\n    if (from >= display.viewTo) { // Change after\\n      if (sawCollapsedSpans && visualLineNo(cm.doc, from) < display.viewTo)\\n        resetView(cm);\\n    } else if (to <= display.viewFrom) { // Change before\\n      if (sawCollapsedSpans && visualLineEndNo(cm.doc, to + lendiff) > display.viewFrom) {\\n        resetView(cm);\\n      } else {\\n        display.viewFrom += lendiff;\\n        display.viewTo += lendiff;\\n      }\\n    } else if (from <= display.viewFrom && to >= display.viewTo) { // Full overlap\\n      resetView(cm);\\n    } else if (from <= display.viewFrom) { // Top overlap\\n      var cut = viewCuttingPoint(cm, to, to + lendiff, 1);\\n      if (cut) {\\n        display.view = display.view.slice(cut.index);\\n        display.viewFrom = cut.lineN;\\n        display.viewTo += lendiff;\\n      } else {\\n        resetView(cm);\\n      }\\n    } else if (to >= display.viewTo) { // Bottom overlap\\n      var cut = viewCuttingPoint(cm, from, from, -1);\\n      if (cut) {\\n        display.view = display.view.slice(0, cut.index);\\n        display.viewTo = cut.lineN;\\n      } else {\\n        resetView(cm);\\n      }\\n    } else { // Gap in the middle\\n      var cutTop = viewCuttingPoint(cm, from, from, -1);\\n      var cutBot = viewCuttingPoint(cm, to, to + lendiff, 1);\\n      if (cutTop && cutBot) {\\n        display.view = display.view.slice(0, cutTop.index)\\n          .concat(buildViewArray(cm, cutTop.lineN, cutBot.lineN))\\n          .concat(display.view.slice(cutBot.index));\\n        display.viewTo += lendiff;\\n      } else {\\n        resetView(cm);\\n      }\\n    }\\n\\n    var ext = display.externalMeasured;\\n    if (ext) {\\n      if (to < ext.lineN)\\n        ext.lineN += lendiff;\\n      else if (from < ext.lineN + ext.size)\\n        display.externalMeasured = null;\\n    }\\n  }\\n\\n  // Register a change to a single line. Type must be one of \\\"text\\\",\\n  // \\\"gutter\\\", \\\"class\\\", \\\"widget\\\"\\n  function regLineChange(cm, line, type) {\\n    cm.curOp.viewChanged = true;\\n    var display = cm.display, ext = cm.display.externalMeasured;\\n    if (ext && line >= ext.lineN && line < ext.lineN + ext.size)\\n      display.externalMeasured = null;\\n\\n    if (line < display.viewFrom || line >= display.viewTo) return;\\n    var lineView = display.view[findViewIndex(cm, line)];\\n    if (lineView.node == null) return;\\n    var arr = lineView.changes || (lineView.changes = []);\\n    if (indexOf(arr, type) == -1) arr.push(type);\\n  }\\n\\n  // Clear the view.\\n  function resetView(cm) {\\n    cm.display.viewFrom = cm.display.viewTo = cm.doc.first;\\n    cm.display.view = [];\\n    cm.display.viewOffset = 0;\\n  }\\n\\n  // Find the view element corresponding to a given line. Return null\\n  // when the line isn't visible.\\n  function findViewIndex(cm, n) {\\n    if (n >= cm.display.viewTo) return null;\\n    n -= cm.display.viewFrom;\\n    if (n < 0) return null;\\n    var view = cm.display.view;\\n    for (var i = 0; i < view.length; i++) {\\n      n -= view[i].size;\\n      if (n < 0) return i;\\n    }\\n  }\\n\\n  function viewCuttingPoint(cm, oldN, newN, dir) {\\n    var index = findViewIndex(cm, oldN), diff, view = cm.display.view;\\n    if (!sawCollapsedSpans || newN == cm.doc.first + cm.doc.size)\\n      return {index: index, lineN: newN};\\n    for (var i = 0, n = cm.display.viewFrom; i < index; i++)\\n      n += view[i].size;\\n    if (n != oldN) {\\n      if (dir > 0) {\\n        if (index == view.length - 1) return null;\\n        diff = (n + view[index].size) - oldN;\\n        index++;\\n      } else {\\n        diff = n - oldN;\\n      }\\n      oldN += diff; newN += diff;\\n    }\\n    while (visualLineNo(cm.doc, newN) != newN) {\\n      if (index == (dir < 0 ? 0 : view.length - 1)) return null;\\n      newN += dir * view[index - (dir < 0 ? 1 : 0)].size;\\n      index += dir;\\n    }\\n    return {index: index, lineN: newN};\\n  }\\n\\n  // Force the view to cover a given range, adding empty view element\\n  // or clipping off existing ones as needed.\\n  function adjustView(cm, from, to) {\\n    var display = cm.display, view = display.view;\\n    if (view.length == 0 || from >= display.viewTo || to <= display.viewFrom) {\\n      display.view = buildViewArray(cm, from, to);\\n      display.viewFrom = from;\\n    } else {\\n      if (display.viewFrom > from)\\n        display.view = buildViewArray(cm, from, display.viewFrom).concat(display.view);\\n      else if (display.viewFrom < from)\\n        display.view = display.view.slice(findViewIndex(cm, from));\\n      display.viewFrom = from;\\n      if (display.viewTo < to)\\n        display.view = display.view.concat(buildViewArray(cm, display.viewTo, to));\\n      else if (display.viewTo > to)\\n        display.view = display.view.slice(0, findViewIndex(cm, to));\\n    }\\n    display.viewTo = to;\\n  }\\n\\n  // Count the number of lines in the view whose DOM representation is\\n  // out of date (or nonexistent).\\n  function countDirtyView(cm) {\\n    var view = cm.display.view, dirty = 0;\\n    for (var i = 0; i < view.length; i++) {\\n      var lineView = view[i];\\n      if (!lineView.hidden && (!lineView.node || lineView.changes)) ++dirty;\\n    }\\n    return dirty;\\n  }\\n\\n  // EVENT HANDLERS\\n\\n  // Attach the necessary event handlers when initializing the editor\\n  function registerEventHandlers(cm) {\\n    var d = cm.display;\\n    on(d.scroller, \\\"mousedown\\\", operation(cm, onMouseDown));\\n    // Older IE's will not fire a second mousedown for a double click\\n    if (ie && ie_version < 11)\\n      on(d.scroller, \\\"dblclick\\\", operation(cm, function(e) {\\n        if (signalDOMEvent(cm, e)) return;\\n        var pos = posFromMouse(cm, e);\\n        if (!pos || clickInGutter(cm, e) || eventInWidget(cm.display, e)) return;\\n        e_preventDefault(e);\\n        var word = cm.findWordAt(pos);\\n        extendSelection(cm.doc, word.anchor, word.head);\\n      }));\\n    else\\n      on(d.scroller, \\\"dblclick\\\", function(e) { signalDOMEvent(cm, e) || e_preventDefault(e); });\\n    // Some browsers fire contextmenu *after* opening the menu, at\\n    // which point we can't mess with it anymore. Context menu is\\n    // handled in onMouseDown for these browsers.\\n    if (!captureRightClick) on(d.scroller, \\\"contextmenu\\\", function(e) {onContextMenu(cm, e);});\\n\\n    // Used to suppress mouse event handling when a touch happens\\n    var touchFinished, prevTouch = {end: 0};\\n    function finishTouch() {\\n      if (d.activeTouch) {\\n        touchFinished = setTimeout(function() {d.activeTouch = null;}, 1000);\\n        prevTouch = d.activeTouch;\\n        prevTouch.end = +new Date;\\n      }\\n    };\\n    function isMouseLikeTouchEvent(e) {\\n      if (e.touches.length != 1) return false;\\n      var touch = e.touches[0];\\n      return touch.radiusX <= 1 && touch.radiusY <= 1;\\n    }\\n    function farAway(touch, other) {\\n      if (other.left == null) return true;\\n      var dx = other.left - touch.left, dy = other.top - touch.top;\\n      return dx * dx + dy * dy > 20 * 20;\\n    }\\n    on(d.scroller, \\\"touchstart\\\", function(e) {\\n      if (!signalDOMEvent(cm, e) && !isMouseLikeTouchEvent(e)) {\\n        clearTimeout(touchFinished);\\n        var now = +new Date;\\n        d.activeTouch = {start: now, moved: false,\\n                         prev: now - prevTouch.end <= 300 ? prevTouch : null};\\n        if (e.touches.length == 1) {\\n          d.activeTouch.left = e.touches[0].pageX;\\n          d.activeTouch.top = e.touches[0].pageY;\\n        }\\n      }\\n    });\\n    on(d.scroller, \\\"touchmove\\\", function() {\\n      if (d.activeTouch) d.activeTouch.moved = true;\\n    });\\n    on(d.scroller, \\\"touchend\\\", function(e) {\\n      var touch = d.activeTouch;\\n      if (touch && !eventInWidget(d, e) && touch.left != null &&\\n          !touch.moved && new Date - touch.start < 300) {\\n        var pos = cm.coordsChar(d.activeTouch, \\\"page\\\"), range;\\n        if (!touch.prev || farAway(touch, touch.prev)) // Single tap\\n          range = new Range(pos, pos);\\n        else if (!touch.prev.prev || farAway(touch, touch.prev.prev)) // Double tap\\n          range = cm.findWordAt(pos);\\n        else // Triple tap\\n          range = new Range(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0)));\\n        cm.setSelection(range.anchor, range.head);\\n        cm.focus();\\n        e_preventDefault(e);\\n      }\\n      finishTouch();\\n    });\\n    on(d.scroller, \\\"touchcancel\\\", finishTouch);\\n\\n    // Sync scrolling between fake scrollbars and real scrollable\\n    // area, ensure viewport is updated when scrolling.\\n    on(d.scroller, \\\"scroll\\\", function() {\\n      if (d.scroller.clientHeight) {\\n        setScrollTop(cm, d.scroller.scrollTop);\\n        setScrollLeft(cm, d.scroller.scrollLeft, true);\\n        signal(cm, \\\"scroll\\\", cm);\\n      }\\n    });\\n\\n    // Listen to wheel events in order to try and update the viewport on time.\\n    on(d.scroller, \\\"mousewheel\\\", function(e){onScrollWheel(cm, e);});\\n    on(d.scroller, \\\"DOMMouseScroll\\\", function(e){onScrollWheel(cm, e);});\\n\\n    // Prevent wrapper from ever scrolling\\n    on(d.wrapper, \\\"scroll\\\", function() { d.wrapper.scrollTop = d.wrapper.scrollLeft = 0; });\\n\\n    d.dragFunctions = {\\n      enter: function(e) {if (!signalDOMEvent(cm, e)) e_stop(e);},\\n      over: function(e) {if (!signalDOMEvent(cm, e)) { onDragOver(cm, e); e_stop(e); }},\\n      start: function(e){onDragStart(cm, e);},\\n      drop: operation(cm, onDrop),\\n      leave: function(e) {if (!signalDOMEvent(cm, e)) { clearDragCursor(cm); }}\\n    };\\n\\n    var inp = d.input.getField();\\n    on(inp, \\\"keyup\\\", function(e) { onKeyUp.call(cm, e); });\\n    on(inp, \\\"keydown\\\", operation(cm, onKeyDown));\\n    on(inp, \\\"keypress\\\", operation(cm, onKeyPress));\\n    on(inp, \\\"focus\\\", function (e) { onFocus(cm, e); });\\n    on(inp, \\\"blur\\\", function (e) { onBlur(cm, e); });\\n  }\\n\\n  function dragDropChanged(cm, value, old) {\\n    var wasOn = old && old != CodeMirror.Init;\\n    if (!value != !wasOn) {\\n      var funcs = cm.display.dragFunctions;\\n      var toggle = value ? on : off;\\n      toggle(cm.display.scroller, \\\"dragstart\\\", funcs.start);\\n      toggle(cm.display.scroller, \\\"dragenter\\\", funcs.enter);\\n      toggle(cm.display.scroller, \\\"dragover\\\", funcs.over);\\n      toggle(cm.display.scroller, \\\"dragleave\\\", funcs.leave);\\n      toggle(cm.display.scroller, \\\"drop\\\", funcs.drop);\\n    }\\n  }\\n\\n  // Called when the window resizes\\n  function onResize(cm) {\\n    var d = cm.display;\\n    if (d.lastWrapHeight == d.wrapper.clientHeight && d.lastWrapWidth == d.wrapper.clientWidth)\\n      return;\\n    // Might be a text scaling operation, clear size caches.\\n    d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;\\n    d.scrollbarsClipped = false;\\n    cm.setSize();\\n  }\\n\\n  // MOUSE EVENTS\\n\\n  // Return true when the given mouse event happened in a widget\\n  function eventInWidget(display, e) {\\n    for (var n = e_target(e); n != display.wrapper; n = n.parentNode) {\\n      if (!n || (n.nodeType == 1 && n.getAttribute(\\\"cm-ignore-events\\\") == \\\"true\\\") ||\\n          (n.parentNode == display.sizer && n != display.mover))\\n        return true;\\n    }\\n  }\\n\\n  // Given a mouse event, find the corresponding position. If liberal\\n  // is false, it checks whether a gutter or scrollbar was clicked,\\n  // and returns null if it was. forRect is used by rectangular\\n  // selections, and tries to estimate a character position even for\\n  // coordinates beyond the right of the text.\\n  function posFromMouse(cm, e, liberal, forRect) {\\n    var display = cm.display;\\n    if (!liberal && e_target(e).getAttribute(\\\"cm-not-content\\\") == \\\"true\\\") return null;\\n\\n    var x, y, space = display.lineSpace.getBoundingClientRect();\\n    // Fails unpredictably on IE[67] when mouse is dragged around quickly.\\n    try { x = e.clientX - space.left; y = e.clientY - space.top; }\\n    catch (e) { return null; }\\n    var coords = coordsChar(cm, x, y), line;\\n    if (forRect && coords.xRel == 1 && (line = getLine(cm.doc, coords.line).text).length == coords.ch) {\\n      var colDiff = countColumn(line, line.length, cm.options.tabSize) - line.length;\\n      coords = Pos(coords.line, Math.max(0, Math.round((x - paddingH(cm.display).left) / charWidth(cm.display)) - colDiff));\\n    }\\n    return coords;\\n  }\\n\\n  // A mouse down can be a single click, double click, triple click,\\n  // start of selection drag, start of text drag, new cursor\\n  // (ctrl-click), rectangle drag (alt-drag), or xwin\\n  // middle-click-paste. Or it might be a click on something we should\\n  // not interfere with, such as a scrollbar or widget.\\n  function onMouseDown(e) {\\n    var cm = this, display = cm.display;\\n    if (signalDOMEvent(cm, e) || display.activeTouch && display.input.supportsTouch()) return;\\n    display.shift = e.shiftKey;\\n\\n    if (eventInWidget(display, e)) {\\n      if (!webkit) {\\n        // Briefly turn off draggability, to allow widgets to do\\n        // normal dragging things.\\n        display.scroller.draggable = false;\\n        setTimeout(function(){display.scroller.draggable = true;}, 100);\\n      }\\n      return;\\n    }\\n    if (clickInGutter(cm, e)) return;\\n    var start = posFromMouse(cm, e);\\n    window.focus();\\n\\n    switch (e_button(e)) {\\n    case 1:\\n      // #3261: make sure, that we're not starting a second selection\\n      if (cm.state.selectingText)\\n        cm.state.selectingText(e);\\n      else if (start)\\n        leftButtonDown(cm, e, start);\\n      else if (e_target(e) == display.scroller)\\n        e_preventDefault(e);\\n      break;\\n    case 2:\\n      if (webkit) cm.state.lastMiddleDown = +new Date;\\n      if (start) extendSelection(cm.doc, start);\\n      setTimeout(function() {display.input.focus();}, 20);\\n      e_preventDefault(e);\\n      break;\\n    case 3:\\n      if (captureRightClick) onContextMenu(cm, e);\\n      else delayBlurEvent(cm);\\n      break;\\n    }\\n  }\\n\\n  var lastClick, lastDoubleClick;\\n  function leftButtonDown(cm, e, start) {\\n    if (ie) setTimeout(bind(ensureFocus, cm), 0);\\n    else cm.curOp.focus = activeElt();\\n\\n    var now = +new Date, type;\\n    if (lastDoubleClick && lastDoubleClick.time > now - 400 && cmp(lastDoubleClick.pos, start) == 0) {\\n      type = \\\"triple\\\";\\n    } else if (lastClick && lastClick.time > now - 400 && cmp(lastClick.pos, start) == 0) {\\n      type = \\\"double\\\";\\n      lastDoubleClick = {time: now, pos: start};\\n    } else {\\n      type = \\\"single\\\";\\n      lastClick = {time: now, pos: start};\\n    }\\n\\n    var sel = cm.doc.sel, modifier = mac ? e.metaKey : e.ctrlKey, contained;\\n    if (cm.options.dragDrop && dragAndDrop && !cm.isReadOnly() &&\\n        type == \\\"single\\\" && (contained = sel.contains(start)) > -1 &&\\n        (cmp((contained = sel.ranges[contained]).from(), start) < 0 || start.xRel > 0) &&\\n        (cmp(contained.to(), start) > 0 || start.xRel < 0))\\n      leftButtonStartDrag(cm, e, start, modifier);\\n    else\\n      leftButtonSelect(cm, e, start, type, modifier);\\n  }\\n\\n  // Start a text drag. When it ends, see if any dragging actually\\n  // happen, and treat as a click if it didn't.\\n  function leftButtonStartDrag(cm, e, start, modifier) {\\n    var display = cm.display, startTime = +new Date;\\n    var dragEnd = operation(cm, function(e2) {\\n      if (webkit) display.scroller.draggable = false;\\n      cm.state.draggingText = false;\\n      off(document, \\\"mouseup\\\", dragEnd);\\n      off(display.scroller, \\\"drop\\\", dragEnd);\\n      if (Math.abs(e.clientX - e2.clientX) + Math.abs(e.clientY - e2.clientY) < 10) {\\n        e_preventDefault(e2);\\n        if (!modifier && +new Date - 200 < startTime)\\n          extendSelection(cm.doc, start);\\n        // Work around unexplainable focus problem in IE9 (#2127) and Chrome (#3081)\\n        if (webkit || ie && ie_version == 9)\\n          setTimeout(function() {document.body.focus(); display.input.focus();}, 20);\\n        else\\n          display.input.focus();\\n      }\\n    });\\n    // Let the drag handler handle this.\\n    if (webkit) display.scroller.draggable = true;\\n    cm.state.draggingText = dragEnd;\\n    dragEnd.copy = mac ? e.altKey : e.ctrlKey\\n    // IE's approach to draggable\\n    if (display.scroller.dragDrop) display.scroller.dragDrop();\\n    on(document, \\\"mouseup\\\", dragEnd);\\n    on(display.scroller, \\\"drop\\\", dragEnd);\\n  }\\n\\n  // Normal selection, as opposed to text dragging.\\n  function leftButtonSelect(cm, e, start, type, addNew) {\\n    var display = cm.display, doc = cm.doc;\\n    e_preventDefault(e);\\n\\n    var ourRange, ourIndex, startSel = doc.sel, ranges = startSel.ranges;\\n    if (addNew && !e.shiftKey) {\\n      ourIndex = doc.sel.contains(start);\\n      if (ourIndex > -1)\\n        ourRange = ranges[ourIndex];\\n      else\\n        ourRange = new Range(start, start);\\n    } else {\\n      ourRange = doc.sel.primary();\\n      ourIndex = doc.sel.primIndex;\\n    }\\n\\n    if (chromeOS ? e.shiftKey && e.metaKey : e.altKey) {\\n      type = \\\"rect\\\";\\n      if (!addNew) ourRange = new Range(start, start);\\n      start = posFromMouse(cm, e, true, true);\\n      ourIndex = -1;\\n    } else if (type == \\\"double\\\") {\\n      var word = cm.findWordAt(start);\\n      if (cm.display.shift || doc.extend)\\n        ourRange = extendRange(doc, ourRange, word.anchor, word.head);\\n      else\\n        ourRange = word;\\n    } else if (type == \\\"triple\\\") {\\n      var line = new Range(Pos(start.line, 0), clipPos(doc, Pos(start.line + 1, 0)));\\n      if (cm.display.shift || doc.extend)\\n        ourRange = extendRange(doc, ourRange, line.anchor, line.head);\\n      else\\n        ourRange = line;\\n    } else {\\n      ourRange = extendRange(doc, ourRange, start);\\n    }\\n\\n    if (!addNew) {\\n      ourIndex = 0;\\n      setSelection(doc, new Selection([ourRange], 0), sel_mouse);\\n      startSel = doc.sel;\\n    } else if (ourIndex == -1) {\\n      ourIndex = ranges.length;\\n      setSelection(doc, normalizeSelection(ranges.concat([ourRange]), ourIndex),\\n                   {scroll: false, origin: \\\"*mouse\\\"});\\n    } else if (ranges.length > 1 && ranges[ourIndex].empty() && type == \\\"single\\\" && !e.shiftKey) {\\n      setSelection(doc, normalizeSelection(ranges.slice(0, ourIndex).concat(ranges.slice(ourIndex + 1)), 0),\\n                   {scroll: false, origin: \\\"*mouse\\\"});\\n      startSel = doc.sel;\\n    } else {\\n      replaceOneSelection(doc, ourIndex, ourRange, sel_mouse);\\n    }\\n\\n    var lastPos = start;\\n    function extendTo(pos) {\\n      if (cmp(lastPos, pos) == 0) return;\\n      lastPos = pos;\\n\\n      if (type == \\\"rect\\\") {\\n        var ranges = [], tabSize = cm.options.tabSize;\\n        var startCol = countColumn(getLine(doc, start.line).text, start.ch, tabSize);\\n        var posCol = countColumn(getLine(doc, pos.line).text, pos.ch, tabSize);\\n        var left = Math.min(startCol, posCol), right = Math.max(startCol, posCol);\\n        for (var line = Math.min(start.line, pos.line), end = Math.min(cm.lastLine(), Math.max(start.line, pos.line));\\n             line <= end; line++) {\\n          var text = getLine(doc, line).text, leftPos = findColumn(text, left, tabSize);\\n          if (left == right)\\n            ranges.push(new Range(Pos(line, leftPos), Pos(line, leftPos)));\\n          else if (text.length > leftPos)\\n            ranges.push(new Range(Pos(line, leftPos), Pos(line, findColumn(text, right, tabSize))));\\n        }\\n        if (!ranges.length) ranges.push(new Range(start, start));\\n        setSelection(doc, normalizeSelection(startSel.ranges.slice(0, ourIndex).concat(ranges), ourIndex),\\n                     {origin: \\\"*mouse\\\", scroll: false});\\n        cm.scrollIntoView(pos);\\n      } else {\\n        var oldRange = ourRange;\\n        var anchor = oldRange.anchor, head = pos;\\n        if (type != \\\"single\\\") {\\n          if (type == \\\"double\\\")\\n            var range = cm.findWordAt(pos);\\n          else\\n            var range = new Range(Pos(pos.line, 0), clipPos(doc, Pos(pos.line + 1, 0)));\\n          if (cmp(range.anchor, anchor) > 0) {\\n            head = range.head;\\n            anchor = minPos(oldRange.from(), range.anchor);\\n          } else {\\n            head = range.anchor;\\n            anchor = maxPos(oldRange.to(), range.head);\\n          }\\n        }\\n        var ranges = startSel.ranges.slice(0);\\n        ranges[ourIndex] = new Range(clipPos(doc, anchor), head);\\n        setSelection(doc, normalizeSelection(ranges, ourIndex), sel_mouse);\\n      }\\n    }\\n\\n    var editorSize = display.wrapper.getBoundingClientRect();\\n    // Used to ensure timeout re-tries don't fire when another extend\\n    // happened in the meantime (clearTimeout isn't reliable -- at\\n    // least on Chrome, the timeouts still happen even when cleared,\\n    // if the clear happens after their scheduled firing time).\\n    var counter = 0;\\n\\n    function extend(e) {\\n      var curCount = ++counter;\\n      var cur = posFromMouse(cm, e, true, type == \\\"rect\\\");\\n      if (!cur) return;\\n      if (cmp(cur, lastPos) != 0) {\\n        cm.curOp.focus = activeElt();\\n        extendTo(cur);\\n        var visible = visibleLines(display, doc);\\n        if (cur.line >= visible.to || cur.line < visible.from)\\n          setTimeout(operation(cm, function(){if (counter == curCount) extend(e);}), 150);\\n      } else {\\n        var outside = e.clientY < editorSize.top ? -20 : e.clientY > editorSize.bottom ? 20 : 0;\\n        if (outside) setTimeout(operation(cm, function() {\\n          if (counter != curCount) return;\\n          display.scroller.scrollTop += outside;\\n          extend(e);\\n        }), 50);\\n      }\\n    }\\n\\n    function done(e) {\\n      cm.state.selectingText = false;\\n      counter = Infinity;\\n      e_preventDefault(e);\\n      display.input.focus();\\n      off(document, \\\"mousemove\\\", move);\\n      off(document, \\\"mouseup\\\", up);\\n      doc.history.lastSelOrigin = null;\\n    }\\n\\n    var move = operation(cm, function(e) {\\n      if (!e_button(e)) done(e);\\n      else extend(e);\\n    });\\n    var up = operation(cm, done);\\n    cm.state.selectingText = up;\\n    on(document, \\\"mousemove\\\", move);\\n    on(document, \\\"mouseup\\\", up);\\n  }\\n\\n  // Determines whether an event happened in the gutter, and fires the\\n  // handlers for the corresponding event.\\n  function gutterEvent(cm, e, type, prevent) {\\n    try { var mX = e.clientX, mY = e.clientY; }\\n    catch(e) { return false; }\\n    if (mX >= Math.floor(cm.display.gutters.getBoundingClientRect().right)) return false;\\n    if (prevent) e_preventDefault(e);\\n\\n    var display = cm.display;\\n    var lineBox = display.lineDiv.getBoundingClientRect();\\n\\n    if (mY > lineBox.bottom || !hasHandler(cm, type)) return e_defaultPrevented(e);\\n    mY -= lineBox.top - display.viewOffset;\\n\\n    for (var i = 0; i < cm.options.gutters.length; ++i) {\\n      var g = display.gutters.childNodes[i];\\n      if (g && g.getBoundingClientRect().right >= mX) {\\n        var line = lineAtHeight(cm.doc, mY);\\n        var gutter = cm.options.gutters[i];\\n        signal(cm, type, cm, line, gutter, e);\\n        return e_defaultPrevented(e);\\n      }\\n    }\\n  }\\n\\n  function clickInGutter(cm, e) {\\n    return gutterEvent(cm, e, \\\"gutterClick\\\", true);\\n  }\\n\\n  // Kludge to work around strange IE behavior where it'll sometimes\\n  // re-fire a series of drag-related events right after the drop (#1551)\\n  var lastDrop = 0;\\n\\n  function onDrop(e) {\\n    var cm = this;\\n    clearDragCursor(cm);\\n    if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e))\\n      return;\\n    e_preventDefault(e);\\n    if (ie) lastDrop = +new Date;\\n    var pos = posFromMouse(cm, e, true), files = e.dataTransfer.files;\\n    if (!pos || cm.isReadOnly()) return;\\n    // Might be a file drop, in which case we simply extract the text\\n    // and insert it.\\n    if (files && files.length && window.FileReader && window.File) {\\n      var n = files.length, text = Array(n), read = 0;\\n      var loadFile = function(file, i) {\\n        if (cm.options.allowDropFileTypes &&\\n            indexOf(cm.options.allowDropFileTypes, file.type) == -1)\\n          return;\\n\\n        var reader = new FileReader;\\n        reader.onload = operation(cm, function() {\\n          var content = reader.result;\\n          if (/[\\\\x00-\\\\x08\\\\x0e-\\\\x1f]{2}/.test(content)) content = \\\"\\\";\\n          text[i] = content;\\n          if (++read == n) {\\n            pos = clipPos(cm.doc, pos);\\n            var change = {from: pos, to: pos,\\n                          text: cm.doc.splitLines(text.join(cm.doc.lineSeparator())),\\n                          origin: \\\"paste\\\"};\\n            makeChange(cm.doc, change);\\n            setSelectionReplaceHistory(cm.doc, simpleSelection(pos, changeEnd(change)));\\n          }\\n        });\\n        reader.readAsText(file);\\n      };\\n      for (var i = 0; i < n; ++i) loadFile(files[i], i);\\n    } else { // Normal drop\\n      // Don't do a replace if the drop happened inside of the selected text.\\n      if (cm.state.draggingText && cm.doc.sel.contains(pos) > -1) {\\n        cm.state.draggingText(e);\\n        // Ensure the editor is re-focused\\n        setTimeout(function() {cm.display.input.focus();}, 20);\\n        return;\\n      }\\n      try {\\n        var text = e.dataTransfer.getData(\\\"Text\\\");\\n        if (text) {\\n          if (cm.state.draggingText && !cm.state.draggingText.copy)\\n            var selected = cm.listSelections();\\n          setSelectionNoUndo(cm.doc, simpleSelection(pos, pos));\\n          if (selected) for (var i = 0; i < selected.length; ++i)\\n            replaceRange(cm.doc, \\\"\\\", selected[i].anchor, selected[i].head, \\\"drag\\\");\\n          cm.replaceSelection(text, \\\"around\\\", \\\"paste\\\");\\n          cm.display.input.focus();\\n        }\\n      }\\n      catch(e){}\\n    }\\n  }\\n\\n  function onDragStart(cm, e) {\\n    if (ie && (!cm.state.draggingText || +new Date - lastDrop < 100)) { e_stop(e); return; }\\n    if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e)) return;\\n\\n    e.dataTransfer.setData(\\\"Text\\\", cm.getSelection());\\n    e.dataTransfer.effectAllowed = \\\"copyMove\\\"\\n\\n    // Use dummy image instead of default browsers image.\\n    // Recent Safari (~6.0.2) have a tendency to segfault when this happens, so we don't do it there.\\n    if (e.dataTransfer.setDragImage && !safari) {\\n      var img = elt(\\\"img\\\", null, null, \\\"position: fixed; left: 0; top: 0;\\\");\\n      img.src = \\\"data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\\\";\\n      if (presto) {\\n        img.width = img.height = 1;\\n        cm.display.wrapper.appendChild(img);\\n        // Force a relayout, or Opera won't use our image for some obscure reason\\n        img._top = img.offsetTop;\\n      }\\n      e.dataTransfer.setDragImage(img, 0, 0);\\n      if (presto) img.parentNode.removeChild(img);\\n    }\\n  }\\n\\n  function onDragOver(cm, e) {\\n    var pos = posFromMouse(cm, e);\\n    if (!pos) return;\\n    var frag = document.createDocumentFragment();\\n    drawSelectionCursor(cm, pos, frag);\\n    if (!cm.display.dragCursor) {\\n      cm.display.dragCursor = elt(\\\"div\\\", null, \\\"CodeMirror-cursors CodeMirror-dragcursors\\\");\\n      cm.display.lineSpace.insertBefore(cm.display.dragCursor, cm.display.cursorDiv);\\n    }\\n    removeChildrenAndAdd(cm.display.dragCursor, frag);\\n  }\\n\\n  function clearDragCursor(cm) {\\n    if (cm.display.dragCursor) {\\n      cm.display.lineSpace.removeChild(cm.display.dragCursor);\\n      cm.display.dragCursor = null;\\n    }\\n  }\\n\\n  // SCROLL EVENTS\\n\\n  // Sync the scrollable area and scrollbars, ensure the viewport\\n  // covers the visible area.\\n  function setScrollTop(cm, val) {\\n    if (Math.abs(cm.doc.scrollTop - val) < 2) return;\\n    cm.doc.scrollTop = val;\\n    if (!gecko) updateDisplaySimple(cm, {top: val});\\n    if (cm.display.scroller.scrollTop != val) cm.display.scroller.scrollTop = val;\\n    cm.display.scrollbars.setScrollTop(val);\\n    if (gecko) updateDisplaySimple(cm);\\n    startWorker(cm, 100);\\n  }\\n  // Sync scroller and scrollbar, ensure the gutter elements are\\n  // aligned.\\n  function setScrollLeft(cm, val, isScroller) {\\n    if (isScroller ? val == cm.doc.scrollLeft : Math.abs(cm.doc.scrollLeft - val) < 2) return;\\n    val = Math.min(val, cm.display.scroller.scrollWidth - cm.display.scroller.clientWidth);\\n    cm.doc.scrollLeft = val;\\n    alignHorizontally(cm);\\n    if (cm.display.scroller.scrollLeft != val) cm.display.scroller.scrollLeft = val;\\n    cm.display.scrollbars.setScrollLeft(val);\\n  }\\n\\n  // Since the delta values reported on mouse wheel events are\\n  // unstandardized between browsers and even browser versions, and\\n  // generally horribly unpredictable, this code starts by measuring\\n  // the scroll effect that the first few mouse wheel events have,\\n  // and, from that, detects the way it can convert deltas to pixel\\n  // offsets afterwards.\\n  //\\n  // The reason we want to know the amount a wheel event will scroll\\n  // is that it gives us a chance to update the display before the\\n  // actual scrolling happens, reducing flickering.\\n\\n  var wheelSamples = 0, wheelPixelsPerUnit = null;\\n  // Fill in a browser-detected starting value on browsers where we\\n  // know one. These don't have to be accurate -- the result of them\\n  // being wrong would just be a slight flicker on the first wheel\\n  // scroll (if it is large enough).\\n  if (ie) wheelPixelsPerUnit = -.53;\\n  else if (gecko) wheelPixelsPerUnit = 15;\\n  else if (chrome) wheelPixelsPerUnit = -.7;\\n  else if (safari) wheelPixelsPerUnit = -1/3;\\n\\n  var wheelEventDelta = function(e) {\\n    var dx = e.wheelDeltaX, dy = e.wheelDeltaY;\\n    if (dx == null && e.detail && e.axis == e.HORIZONTAL_AXIS) dx = e.detail;\\n    if (dy == null && e.detail && e.axis == e.VERTICAL_AXIS) dy = e.detail;\\n    else if (dy == null) dy = e.wheelDelta;\\n    return {x: dx, y: dy};\\n  };\\n  CodeMirror.wheelEventPixels = function(e) {\\n    var delta = wheelEventDelta(e);\\n    delta.x *= wheelPixelsPerUnit;\\n    delta.y *= wheelPixelsPerUnit;\\n    return delta;\\n  };\\n\\n  function onScrollWheel(cm, e) {\\n    var delta = wheelEventDelta(e), dx = delta.x, dy = delta.y;\\n\\n    var display = cm.display, scroll = display.scroller;\\n    // Quit if there's nothing to scroll here\\n    var canScrollX = scroll.scrollWidth > scroll.clientWidth;\\n    var canScrollY = scroll.scrollHeight > scroll.clientHeight;\\n    if (!(dx && canScrollX || dy && canScrollY)) return;\\n\\n    // Webkit browsers on OS X abort momentum scrolls when the target\\n    // of the scroll event is removed from the scrollable element.\\n    // This hack (see related code in patchDisplay) makes sure the\\n    // element is kept around.\\n    if (dy && mac && webkit) {\\n      outer: for (var cur = e.target, view = display.view; cur != scroll; cur = cur.parentNode) {\\n        for (var i = 0; i < view.length; i++) {\\n          if (view[i].node == cur) {\\n            cm.display.currentWheelTarget = cur;\\n            break outer;\\n          }\\n        }\\n      }\\n    }\\n\\n    // On some browsers, horizontal scrolling will cause redraws to\\n    // happen before the gutter has been realigned, causing it to\\n    // wriggle around in a most unseemly way. When we have an\\n    // estimated pixels/delta value, we just handle horizontal\\n    // scrolling entirely here. It'll be slightly off from native, but\\n    // better than glitching out.\\n    if (dx && !gecko && !presto && wheelPixelsPerUnit != null) {\\n      if (dy && canScrollY)\\n        setScrollTop(cm, Math.max(0, Math.min(scroll.scrollTop + dy * wheelPixelsPerUnit, scroll.scrollHeight - scroll.clientHeight)));\\n      setScrollLeft(cm, Math.max(0, Math.min(scroll.scrollLeft + dx * wheelPixelsPerUnit, scroll.scrollWidth - scroll.clientWidth)));\\n      // Only prevent default scrolling if vertical scrolling is\\n      // actually possible. Otherwise, it causes vertical scroll\\n      // jitter on OSX trackpads when deltaX is small and deltaY\\n      // is large (issue #3579)\\n      if (!dy || (dy && canScrollY))\\n        e_preventDefault(e);\\n      display.wheelStartX = null; // Abort measurement, if in progress\\n      return;\\n    }\\n\\n    // 'Project' the visible viewport to cover the area that is being\\n    // scrolled into view (if we know enough to estimate it).\\n    if (dy && wheelPixelsPerUnit != null) {\\n      var pixels = dy * wheelPixelsPerUnit;\\n      var top = cm.doc.scrollTop, bot = top + display.wrapper.clientHeight;\\n      if (pixels < 0) top = Math.max(0, top + pixels - 50);\\n      else bot = Math.min(cm.doc.height, bot + pixels + 50);\\n      updateDisplaySimple(cm, {top: top, bottom: bot});\\n    }\\n\\n    if (wheelSamples < 20) {\\n      if (display.wheelStartX == null) {\\n        display.wheelStartX = scroll.scrollLeft; display.wheelStartY = scroll.scrollTop;\\n        display.wheelDX = dx; display.wheelDY = dy;\\n        setTimeout(function() {\\n          if (display.wheelStartX == null) return;\\n          var movedX = scroll.scrollLeft - display.wheelStartX;\\n          var movedY = scroll.scrollTop - display.wheelStartY;\\n          var sample = (movedY && display.wheelDY && movedY / display.wheelDY) ||\\n            (movedX && display.wheelDX && movedX / display.wheelDX);\\n          display.wheelStartX = display.wheelStartY = null;\\n          if (!sample) return;\\n          wheelPixelsPerUnit = (wheelPixelsPerUnit * wheelSamples + sample) / (wheelSamples + 1);\\n          ++wheelSamples;\\n        }, 200);\\n      } else {\\n        display.wheelDX += dx; display.wheelDY += dy;\\n      }\\n    }\\n  }\\n\\n  // KEY EVENTS\\n\\n  // Run a handler that was bound to a key.\\n  function doHandleBinding(cm, bound, dropShift) {\\n    if (typeof bound == \\\"string\\\") {\\n      bound = commands[bound];\\n      if (!bound) return false;\\n    }\\n    // Ensure previous input has been read, so that the handler sees a\\n    // consistent view of the document\\n    cm.display.input.ensurePolled();\\n    var prevShift = cm.display.shift, done = false;\\n    try {\\n      if (cm.isReadOnly()) cm.state.suppressEdits = true;\\n      if (dropShift) cm.display.shift = false;\\n      done = bound(cm) != Pass;\\n    } finally {\\n      cm.display.shift = prevShift;\\n      cm.state.suppressEdits = false;\\n    }\\n    return done;\\n  }\\n\\n  function lookupKeyForEditor(cm, name, handle) {\\n    for (var i = 0; i < cm.state.keyMaps.length; i++) {\\n      var result = lookupKey(name, cm.state.keyMaps[i], handle, cm);\\n      if (result) return result;\\n    }\\n    return (cm.options.extraKeys && lookupKey(name, cm.options.extraKeys, handle, cm))\\n      || lookupKey(name, cm.options.keyMap, handle, cm);\\n  }\\n\\n  var stopSeq = new Delayed;\\n  function dispatchKey(cm, name, e, handle) {\\n    var seq = cm.state.keySeq;\\n    if (seq) {\\n      if (isModifierKey(name)) return \\\"handled\\\";\\n      stopSeq.set(50, function() {\\n        if (cm.state.keySeq == seq) {\\n          cm.state.keySeq = null;\\n          cm.display.input.reset();\\n        }\\n      });\\n      name = seq + \\\" \\\" + name;\\n    }\\n    var result = lookupKeyForEditor(cm, name, handle);\\n\\n    if (result == \\\"multi\\\")\\n      cm.state.keySeq = name;\\n    if (result == \\\"handled\\\")\\n      signalLater(cm, \\\"keyHandled\\\", cm, name, e);\\n\\n    if (result == \\\"handled\\\" || result == \\\"multi\\\") {\\n      e_preventDefault(e);\\n      restartBlink(cm);\\n    }\\n\\n    if (seq && !result && /\\\\'$/.test(name)) {\\n      e_preventDefault(e);\\n      return true;\\n    }\\n    return !!result;\\n  }\\n\\n  // Handle a key from the keydown event.\\n  function handleKeyBinding(cm, e) {\\n    var name = keyName(e, true);\\n    if (!name) return false;\\n\\n    if (e.shiftKey && !cm.state.keySeq) {\\n      // First try to resolve full name (including 'Shift-'). Failing\\n      // that, see if there is a cursor-motion command (starting with\\n      // 'go') bound to the keyname without 'Shift-'.\\n      return dispatchKey(cm, \\\"Shift-\\\" + name, e, function(b) {return doHandleBinding(cm, b, true);})\\n          || dispatchKey(cm, name, e, function(b) {\\n               if (typeof b == \\\"string\\\" ? /^go[A-Z]/.test(b) : b.motion)\\n                 return doHandleBinding(cm, b);\\n             });\\n    } else {\\n      return dispatchKey(cm, name, e, function(b) { return doHandleBinding(cm, b); });\\n    }\\n  }\\n\\n  // Handle a key from the keypress event\\n  function handleCharBinding(cm, e, ch) {\\n    return dispatchKey(cm, \\\"'\\\" + ch + \\\"'\\\", e,\\n                       function(b) { return doHandleBinding(cm, b, true); });\\n  }\\n\\n  var lastStoppedKey = null;\\n  function onKeyDown(e) {\\n    var cm = this;\\n    cm.curOp.focus = activeElt();\\n    if (signalDOMEvent(cm, e)) return;\\n    // IE does strange things with escape.\\n    if (ie && ie_version < 11 && e.keyCode == 27) e.returnValue = false;\\n    var code = e.keyCode;\\n    cm.display.shift = code == 16 || e.shiftKey;\\n    var handled = handleKeyBinding(cm, e);\\n    if (presto) {\\n      lastStoppedKey = handled ? code : null;\\n      // Opera has no cut event... we try to at least catch the key combo\\n      if (!handled && code == 88 && !hasCopyEvent && (mac ? e.metaKey : e.ctrlKey))\\n        cm.replaceSelection(\\\"\\\", null, \\\"cut\\\");\\n    }\\n\\n    // Turn mouse into crosshair when Alt is held on Mac.\\n    if (code == 18 && !/\\\\bCodeMirror-crosshair\\\\b/.test(cm.display.lineDiv.className))\\n      showCrossHair(cm);\\n  }\\n\\n  function showCrossHair(cm) {\\n    var lineDiv = cm.display.lineDiv;\\n    addClass(lineDiv, \\\"CodeMirror-crosshair\\\");\\n\\n    function up(e) {\\n      if (e.keyCode == 18 || !e.altKey) {\\n        rmClass(lineDiv, \\\"CodeMirror-crosshair\\\");\\n        off(document, \\\"keyup\\\", up);\\n        off(document, \\\"mouseover\\\", up);\\n      }\\n    }\\n    on(document, \\\"keyup\\\", up);\\n    on(document, \\\"mouseover\\\", up);\\n  }\\n\\n  function onKeyUp(e) {\\n    if (e.keyCode == 16) this.doc.sel.shift = false;\\n    signalDOMEvent(this, e);\\n  }\\n\\n  function onKeyPress(e) {\\n    var cm = this;\\n    if (eventInWidget(cm.display, e) || signalDOMEvent(cm, e) || e.ctrlKey && !e.altKey || mac && e.metaKey) return;\\n    var keyCode = e.keyCode, charCode = e.charCode;\\n    if (presto && keyCode == lastStoppedKey) {lastStoppedKey = null; e_preventDefault(e); return;}\\n    if ((presto && (!e.which || e.which < 10)) && handleKeyBinding(cm, e)) return;\\n    var ch = String.fromCharCode(charCode == null ? keyCode : charCode);\\n    if (handleCharBinding(cm, e, ch)) return;\\n    cm.display.input.onKeyPress(e);\\n  }\\n\\n  // FOCUS/BLUR EVENTS\\n\\n  function delayBlurEvent(cm) {\\n    cm.state.delayingBlurEvent = true;\\n    setTimeout(function() {\\n      if (cm.state.delayingBlurEvent) {\\n        cm.state.delayingBlurEvent = false;\\n        onBlur(cm);\\n      }\\n    }, 100);\\n  }\\n\\n  function onFocus(cm, e) {\\n    if (cm.state.delayingBlurEvent) cm.state.delayingBlurEvent = false;\\n\\n    if (cm.options.readOnly == \\\"nocursor\\\") return;\\n    if (!cm.state.focused) {\\n      signal(cm, \\\"focus\\\", cm, e);\\n      cm.state.focused = true;\\n      addClass(cm.display.wrapper, \\\"CodeMirror-focused\\\");\\n      // This test prevents this from firing when a context\\n      // menu is closed (since the input reset would kill the\\n      // select-all detection hack)\\n      if (!cm.curOp && cm.display.selForContextMenu != cm.doc.sel) {\\n        cm.display.input.reset();\\n        if (webkit) setTimeout(function() { cm.display.input.reset(true); }, 20); // Issue #1730\\n      }\\n      cm.display.input.receivedFocus();\\n    }\\n    restartBlink(cm);\\n  }\\n  function onBlur(cm, e) {\\n    if (cm.state.delayingBlurEvent) return;\\n\\n    if (cm.state.focused) {\\n      signal(cm, \\\"blur\\\", cm, e);\\n      cm.state.focused = false;\\n      rmClass(cm.display.wrapper, \\\"CodeMirror-focused\\\");\\n    }\\n    clearInterval(cm.display.blinker);\\n    setTimeout(function() {if (!cm.state.focused) cm.display.shift = false;}, 150);\\n  }\\n\\n  // CONTEXT MENU HANDLING\\n\\n  // To make the context menu work, we need to briefly unhide the\\n  // textarea (making it as unobtrusive as possible) to let the\\n  // right-click take effect on it.\\n  function onContextMenu(cm, e) {\\n    if (eventInWidget(cm.display, e) || contextMenuInGutter(cm, e)) return;\\n    if (signalDOMEvent(cm, e, \\\"contextmenu\\\")) return;\\n    cm.display.input.onContextMenu(e);\\n  }\\n\\n  function contextMenuInGutter(cm, e) {\\n    if (!hasHandler(cm, \\\"gutterContextMenu\\\")) return false;\\n    return gutterEvent(cm, e, \\\"gutterContextMenu\\\", false);\\n  }\\n\\n  // UPDATING\\n\\n  // Compute the position of the end of a change (its 'to' property\\n  // refers to the pre-change end).\\n  var changeEnd = CodeMirror.changeEnd = function(change) {\\n    if (!change.text) return change.to;\\n    return Pos(change.from.line + change.text.length - 1,\\n               lst(change.text).length + (change.text.length == 1 ? change.from.ch : 0));\\n  };\\n\\n  // Adjust a position to refer to the post-change position of the\\n  // same text, or the end of the change if the change covers it.\\n  function adjustForChange(pos, change) {\\n    if (cmp(pos, change.from) < 0) return pos;\\n    if (cmp(pos, change.to) <= 0) return changeEnd(change);\\n\\n    var line = pos.line + change.text.length - (change.to.line - change.from.line) - 1, ch = pos.ch;\\n    if (pos.line == change.to.line) ch += changeEnd(change).ch - change.to.ch;\\n    return Pos(line, ch);\\n  }\\n\\n  function computeSelAfterChange(doc, change) {\\n    var out = [];\\n    for (var i = 0; i < doc.sel.ranges.length; i++) {\\n      var range = doc.sel.ranges[i];\\n      out.push(new Range(adjustForChange(range.anchor, change),\\n                         adjustForChange(range.head, change)));\\n    }\\n    return normalizeSelection(out, doc.sel.primIndex);\\n  }\\n\\n  function offsetPos(pos, old, nw) {\\n    if (pos.line == old.line)\\n      return Pos(nw.line, pos.ch - old.ch + nw.ch);\\n    else\\n      return Pos(nw.line + (pos.line - old.line), pos.ch);\\n  }\\n\\n  // Used by replaceSelections to allow moving the selection to the\\n  // start or around the replaced test. Hint may be \\\"start\\\" or \\\"around\\\".\\n  function computeReplacedSel(doc, changes, hint) {\\n    var out = [];\\n    var oldPrev = Pos(doc.first, 0), newPrev = oldPrev;\\n    for (var i = 0; i < changes.length; i++) {\\n      var change = changes[i];\\n      var from = offsetPos(change.from, oldPrev, newPrev);\\n      var to = offsetPos(changeEnd(change), oldPrev, newPrev);\\n      oldPrev = change.to;\\n      newPrev = to;\\n      if (hint == \\\"around\\\") {\\n        var range = doc.sel.ranges[i], inv = cmp(range.head, range.anchor) < 0;\\n        out[i] = new Range(inv ? to : from, inv ? from : to);\\n      } else {\\n        out[i] = new Range(from, from);\\n      }\\n    }\\n    return new Selection(out, doc.sel.primIndex);\\n  }\\n\\n  // Allow \\\"beforeChange\\\" event handlers to influence a change\\n  function filterChange(doc, change, update) {\\n    var obj = {\\n      canceled: false,\\n      from: change.from,\\n      to: change.to,\\n      text: change.text,\\n      origin: change.origin,\\n      cancel: function() { this.canceled = true; }\\n    };\\n    if (update) obj.update = function(from, to, text, origin) {\\n      if (from) this.from = clipPos(doc, from);\\n      if (to) this.to = clipPos(doc, to);\\n      if (text) this.text = text;\\n      if (origin !== undefined) this.origin = origin;\\n    };\\n    signal(doc, \\\"beforeChange\\\", doc, obj);\\n    if (doc.cm) signal(doc.cm, \\\"beforeChange\\\", doc.cm, obj);\\n\\n    if (obj.canceled) return null;\\n    return {from: obj.from, to: obj.to, text: obj.text, origin: obj.origin};\\n  }\\n\\n  // Apply a change to a document, and add it to the document's\\n  // history, and propagating it to all linked documents.\\n  function makeChange(doc, change, ignoreReadOnly) {\\n    if (doc.cm) {\\n      if (!doc.cm.curOp) return operation(doc.cm, makeChange)(doc, change, ignoreReadOnly);\\n      if (doc.cm.state.suppressEdits) return;\\n    }\\n\\n    if (hasHandler(doc, \\\"beforeChange\\\") || doc.cm && hasHandler(doc.cm, \\\"beforeChange\\\")) {\\n      change = filterChange(doc, change, true);\\n      if (!change) return;\\n    }\\n\\n    // Possibly split or suppress the update based on the presence\\n    // of read-only spans in its range.\\n    var split = sawReadOnlySpans && !ignoreReadOnly && removeReadOnlyRanges(doc, change.from, change.to);\\n    if (split) {\\n      for (var i = split.length - 1; i >= 0; --i)\\n        makeChangeInner(doc, {from: split[i].from, to: split[i].to, text: i ? [\\\"\\\"] : change.text});\\n    } else {\\n      makeChangeInner(doc, change);\\n    }\\n  }\\n\\n  function makeChangeInner(doc, change) {\\n    if (change.text.length == 1 && change.text[0] == \\\"\\\" && cmp(change.from, change.to) == 0) return;\\n    var selAfter = computeSelAfterChange(doc, change);\\n    addChangeToHistory(doc, change, selAfter, doc.cm ? doc.cm.curOp.id : NaN);\\n\\n    makeChangeSingleDoc(doc, change, selAfter, stretchSpansOverChange(doc, change));\\n    var rebased = [];\\n\\n    linkedDocs(doc, function(doc, sharedHist) {\\n      if (!sharedHist && indexOf(rebased, doc.history) == -1) {\\n        rebaseHist(doc.history, change);\\n        rebased.push(doc.history);\\n      }\\n      makeChangeSingleDoc(doc, change, null, stretchSpansOverChange(doc, change));\\n    });\\n  }\\n\\n  // Revert a change stored in a document's history.\\n  function makeChangeFromHistory(doc, type, allowSelectionOnly) {\\n    if (doc.cm && doc.cm.state.suppressEdits && !allowSelectionOnly) return;\\n\\n    var hist = doc.history, event, selAfter = doc.sel;\\n    var source = type == \\\"undo\\\" ? hist.done : hist.undone, dest = type == \\\"undo\\\" ? hist.undone : hist.done;\\n\\n    // Verify that there is a useable event (so that ctrl-z won't\\n    // needlessly clear selection events)\\n    for (var i = 0; i < source.length; i++) {\\n      event = source[i];\\n      if (allowSelectionOnly ? event.ranges && !event.equals(doc.sel) : !event.ranges)\\n        break;\\n    }\\n    if (i == source.length) return;\\n    hist.lastOrigin = hist.lastSelOrigin = null;\\n\\n    for (;;) {\\n      event = source.pop();\\n      if (event.ranges) {\\n        pushSelectionToHistory(event, dest);\\n        if (allowSelectionOnly && !event.equals(doc.sel)) {\\n          setSelection(doc, event, {clearRedo: false});\\n          return;\\n        }\\n        selAfter = event;\\n      }\\n      else break;\\n    }\\n\\n    // Build up a reverse change object to add to the opposite history\\n    // stack (redo when undoing, and vice versa).\\n    var antiChanges = [];\\n    pushSelectionToHistory(selAfter, dest);\\n    dest.push({changes: antiChanges, generation: hist.generation});\\n    hist.generation = event.generation || ++hist.maxGeneration;\\n\\n    var filter = hasHandler(doc, \\\"beforeChange\\\") || doc.cm && hasHandler(doc.cm, \\\"beforeChange\\\");\\n\\n    for (var i = event.changes.length - 1; i >= 0; --i) {\\n      var change = event.changes[i];\\n      change.origin = type;\\n      if (filter && !filterChange(doc, change, false)) {\\n        source.length = 0;\\n        return;\\n      }\\n\\n      antiChanges.push(historyChangeFromChange(doc, change));\\n\\n      var after = i ? computeSelAfterChange(doc, change) : lst(source);\\n      makeChangeSingleDoc(doc, change, after, mergeOldSpans(doc, change));\\n      if (!i && doc.cm) doc.cm.scrollIntoView({from: change.from, to: changeEnd(change)});\\n      var rebased = [];\\n\\n      // Propagate to the linked documents\\n      linkedDocs(doc, function(doc, sharedHist) {\\n        if (!sharedHist && indexOf(rebased, doc.history) == -1) {\\n          rebaseHist(doc.history, change);\\n          rebased.push(doc.history);\\n        }\\n        makeChangeSingleDoc(doc, change, null, mergeOldSpans(doc, change));\\n      });\\n    }\\n  }\\n\\n  // Sub-views need their line numbers shifted when text is added\\n  // above or below them in the parent document.\\n  function shiftDoc(doc, distance) {\\n    if (distance == 0) return;\\n    doc.first += distance;\\n    doc.sel = new Selection(map(doc.sel.ranges, function(range) {\\n      return new Range(Pos(range.anchor.line + distance, range.anchor.ch),\\n                       Pos(range.head.line + distance, range.head.ch));\\n    }), doc.sel.primIndex);\\n    if (doc.cm) {\\n      regChange(doc.cm, doc.first, doc.first - distance, distance);\\n      for (var d = doc.cm.display, l = d.viewFrom; l < d.viewTo; l++)\\n        regLineChange(doc.cm, l, \\\"gutter\\\");\\n    }\\n  }\\n\\n  // More lower-level change function, handling only a single document\\n  // (not linked ones).\\n  function makeChangeSingleDoc(doc, change, selAfter, spans) {\\n    if (doc.cm && !doc.cm.curOp)\\n      return operation(doc.cm, makeChangeSingleDoc)(doc, change, selAfter, spans);\\n\\n    if (change.to.line < doc.first) {\\n      shiftDoc(doc, change.text.length - 1 - (change.to.line - change.from.line));\\n      return;\\n    }\\n    if (change.from.line > doc.lastLine()) return;\\n\\n    // Clip the change to the size of this doc\\n    if (change.from.line < doc.first) {\\n      var shift = change.text.length - 1 - (doc.first - change.from.line);\\n      shiftDoc(doc, shift);\\n      change = {from: Pos(doc.first, 0), to: Pos(change.to.line + shift, change.to.ch),\\n                text: [lst(change.text)], origin: change.origin};\\n    }\\n    var last = doc.lastLine();\\n    if (change.to.line > last) {\\n      change = {from: change.from, to: Pos(last, getLine(doc, last).text.length),\\n                text: [change.text[0]], origin: change.origin};\\n    }\\n\\n    change.removed = getBetween(doc, change.from, change.to);\\n\\n    if (!selAfter) selAfter = computeSelAfterChange(doc, change);\\n    if (doc.cm) makeChangeSingleDocInEditor(doc.cm, change, spans);\\n    else updateDoc(doc, change, spans);\\n    setSelectionNoUndo(doc, selAfter, sel_dontScroll);\\n  }\\n\\n  // Handle the interaction of a change to a document with the editor\\n  // that this document is part of.\\n  function makeChangeSingleDocInEditor(cm, change, spans) {\\n    var doc = cm.doc, display = cm.display, from = change.from, to = change.to;\\n\\n    var recomputeMaxLength = false, checkWidthStart = from.line;\\n    if (!cm.options.lineWrapping) {\\n      checkWidthStart = lineNo(visualLine(getLine(doc, from.line)));\\n      doc.iter(checkWidthStart, to.line + 1, function(line) {\\n        if (line == display.maxLine) {\\n          recomputeMaxLength = true;\\n          return true;\\n        }\\n      });\\n    }\\n\\n    if (doc.sel.contains(change.from, change.to) > -1)\\n      signalCursorActivity(cm);\\n\\n    updateDoc(doc, change, spans, estimateHeight(cm));\\n\\n    if (!cm.options.lineWrapping) {\\n      doc.iter(checkWidthStart, from.line + change.text.length, function(line) {\\n        var len = lineLength(line);\\n        if (len > display.maxLineLength) {\\n          display.maxLine = line;\\n          display.maxLineLength = len;\\n          display.maxLineChanged = true;\\n          recomputeMaxLength = false;\\n        }\\n      });\\n      if (recomputeMaxLength) cm.curOp.updateMaxLine = true;\\n    }\\n\\n    // Adjust frontier, schedule worker\\n    doc.frontier = Math.min(doc.frontier, from.line);\\n    startWorker(cm, 400);\\n\\n    var lendiff = change.text.length - (to.line - from.line) - 1;\\n    // Remember that these lines changed, for updating the display\\n    if (change.full)\\n      regChange(cm);\\n    else if (from.line == to.line && change.text.length == 1 && !isWholeLineUpdate(cm.doc, change))\\n      regLineChange(cm, from.line, \\\"text\\\");\\n    else\\n      regChange(cm, from.line, to.line + 1, lendiff);\\n\\n    var changesHandler = hasHandler(cm, \\\"changes\\\"), changeHandler = hasHandler(cm, \\\"change\\\");\\n    if (changeHandler || changesHandler) {\\n      var obj = {\\n        from: from, to: to,\\n        text: change.text,\\n        removed: change.removed,\\n        origin: change.origin\\n      };\\n      if (changeHandler) signalLater(cm, \\\"change\\\", cm, obj);\\n      if (changesHandler) (cm.curOp.changeObjs || (cm.curOp.changeObjs = [])).push(obj);\\n    }\\n    cm.display.selForContextMenu = null;\\n  }\\n\\n  function replaceRange(doc, code, from, to, origin) {\\n    if (!to) to = from;\\n    if (cmp(to, from) < 0) { var tmp = to; to = from; from = tmp; }\\n    if (typeof code == \\\"string\\\") code = doc.splitLines(code);\\n    makeChange(doc, {from: from, to: to, text: code, origin: origin});\\n  }\\n\\n  // SCROLLING THINGS INTO VIEW\\n\\n  // If an editor sits on the top or bottom of the window, partially\\n  // scrolled out of view, this ensures that the cursor is visible.\\n  function maybeScrollWindow(cm, coords) {\\n    if (signalDOMEvent(cm, \\\"scrollCursorIntoView\\\")) return;\\n\\n    var display = cm.display, box = display.sizer.getBoundingClientRect(), doScroll = null;\\n    if (coords.top + box.top < 0) doScroll = true;\\n    else if (coords.bottom + box.top > (window.innerHeight || document.documentElement.clientHeight)) doScroll = false;\\n    if (doScroll != null && !phantom) {\\n      var scrollNode = elt(\\\"div\\\", \\\"\\\\u200b\\\", null, \\\"position: absolute; top: \\\" +\\n                           (coords.top - display.viewOffset - paddingTop(cm.display)) + \\\"px; height: \\\" +\\n                           (coords.bottom - coords.top + scrollGap(cm) + display.barHeight) + \\\"px; left: \\\" +\\n                           coords.left + \\\"px; width: 2px;\\\");\\n      cm.display.lineSpace.appendChild(scrollNode);\\n      scrollNode.scrollIntoView(doScroll);\\n      cm.display.lineSpace.removeChild(scrollNode);\\n    }\\n  }\\n\\n  // Scroll a given position into view (immediately), verifying that\\n  // it actually became visible (as line heights are accurately\\n  // measured, the position of something may 'drift' during drawing).\\n  function scrollPosIntoView(cm, pos, end, margin) {\\n    if (margin == null) margin = 0;\\n    for (var limit = 0; limit < 5; limit++) {\\n      var changed = false, coords = cursorCoords(cm, pos);\\n      var endCoords = !end || end == pos ? coords : cursorCoords(cm, end);\\n      var scrollPos = calculateScrollPos(cm, Math.min(coords.left, endCoords.left),\\n                                         Math.min(coords.top, endCoords.top) - margin,\\n                                         Math.max(coords.left, endCoords.left),\\n                                         Math.max(coords.bottom, endCoords.bottom) + margin);\\n      var startTop = cm.doc.scrollTop, startLeft = cm.doc.scrollLeft;\\n      if (scrollPos.scrollTop != null) {\\n        setScrollTop(cm, scrollPos.scrollTop);\\n        if (Math.abs(cm.doc.scrollTop - startTop) > 1) changed = true;\\n      }\\n      if (scrollPos.scrollLeft != null) {\\n        setScrollLeft(cm, scrollPos.scrollLeft);\\n        if (Math.abs(cm.doc.scrollLeft - startLeft) > 1) changed = true;\\n      }\\n      if (!changed) break;\\n    }\\n    return coords;\\n  }\\n\\n  // Scroll a given set of coordinates into view (immediately).\\n  function scrollIntoView(cm, x1, y1, x2, y2) {\\n    var scrollPos = calculateScrollPos(cm, x1, y1, x2, y2);\\n    if (scrollPos.scrollTop != null) setScrollTop(cm, scrollPos.scrollTop);\\n    if (scrollPos.scrollLeft != null) setScrollLeft(cm, scrollPos.scrollLeft);\\n  }\\n\\n  // Calculate a new scroll position needed to scroll the given\\n  // rectangle into view. Returns an object with scrollTop and\\n  // scrollLeft properties. When these are undefined, the\\n  // vertical/horizontal position does not need to be adjusted.\\n  function calculateScrollPos(cm, x1, y1, x2, y2) {\\n    var display = cm.display, snapMargin = textHeight(cm.display);\\n    if (y1 < 0) y1 = 0;\\n    var screentop = cm.curOp && cm.curOp.scrollTop != null ? cm.curOp.scrollTop : display.scroller.scrollTop;\\n    var screen = displayHeight(cm), result = {};\\n    if (y2 - y1 > screen) y2 = y1 + screen;\\n    var docBottom = cm.doc.height + paddingVert(display);\\n    var atTop = y1 < snapMargin, atBottom = y2 > docBottom - snapMargin;\\n    if (y1 < screentop) {\\n      result.scrollTop = atTop ? 0 : y1;\\n    } else if (y2 > screentop + screen) {\\n      var newTop = Math.min(y1, (atBottom ? docBottom : y2) - screen);\\n      if (newTop != screentop) result.scrollTop = newTop;\\n    }\\n\\n    var screenleft = cm.curOp && cm.curOp.scrollLeft != null ? cm.curOp.scrollLeft : display.scroller.scrollLeft;\\n    var screenw = displayWidth(cm) - (cm.options.fixedGutter ? display.gutters.offsetWidth : 0);\\n    var tooWide = x2 - x1 > screenw;\\n    if (tooWide) x2 = x1 + screenw;\\n    if (x1 < 10)\\n      result.scrollLeft = 0;\\n    else if (x1 < screenleft)\\n      result.scrollLeft = Math.max(0, x1 - (tooWide ? 0 : 10));\\n    else if (x2 > screenw + screenleft - 3)\\n      result.scrollLeft = x2 + (tooWide ? 0 : 10) - screenw;\\n    return result;\\n  }\\n\\n  // Store a relative adjustment to the scroll position in the current\\n  // operation (to be applied when the operation finishes).\\n  function addToScrollPos(cm, left, top) {\\n    if (left != null || top != null) resolveScrollToPos(cm);\\n    if (left != null)\\n      cm.curOp.scrollLeft = (cm.curOp.scrollLeft == null ? cm.doc.scrollLeft : cm.curOp.scrollLeft) + left;\\n    if (top != null)\\n      cm.curOp.scrollTop = (cm.curOp.scrollTop == null ? cm.doc.scrollTop : cm.curOp.scrollTop) + top;\\n  }\\n\\n  // Make sure that at the end of the operation the current cursor is\\n  // shown.\\n  function ensureCursorVisible(cm) {\\n    resolveScrollToPos(cm);\\n    var cur = cm.getCursor(), from = cur, to = cur;\\n    if (!cm.options.lineWrapping) {\\n      from = cur.ch ? Pos(cur.line, cur.ch - 1) : cur;\\n      to = Pos(cur.line, cur.ch + 1);\\n    }\\n    cm.curOp.scrollToPos = {from: from, to: to, margin: cm.options.cursorScrollMargin, isCursor: true};\\n  }\\n\\n  // When an operation has its scrollToPos property set, and another\\n  // scroll action is applied before the end of the operation, this\\n  // 'simulates' scrolling that position into view in a cheap way, so\\n  // that the effect of intermediate scroll commands is not ignored.\\n  function resolveScrollToPos(cm) {\\n    var range = cm.curOp.scrollToPos;\\n    if (range) {\\n      cm.curOp.scrollToPos = null;\\n      var from = estimateCoords(cm, range.from), to = estimateCoords(cm, range.to);\\n      var sPos = calculateScrollPos(cm, Math.min(from.left, to.left),\\n                                    Math.min(from.top, to.top) - range.margin,\\n                                    Math.max(from.right, to.right),\\n                                    Math.max(from.bottom, to.bottom) + range.margin);\\n      cm.scrollTo(sPos.scrollLeft, sPos.scrollTop);\\n    }\\n  }\\n\\n  // API UTILITIES\\n\\n  // Indent the given line. The how parameter can be \\\"smart\\\",\\n  // \\\"add\\\"/null, \\\"subtract\\\", or \\\"prev\\\". When aggressive is false\\n  // (typically set to true for forced single-line indents), empty\\n  // lines are not indented, and places where the mode returns Pass\\n  // are left alone.\\n  function indentLine(cm, n, how, aggressive) {\\n    var doc = cm.doc, state;\\n    if (how == null) how = \\\"add\\\";\\n    if (how == \\\"smart\\\") {\\n      // Fall back to \\\"prev\\\" when the mode doesn't have an indentation\\n      // method.\\n      if (!doc.mode.indent) how = \\\"prev\\\";\\n      else state = getStateBefore(cm, n);\\n    }\\n\\n    var tabSize = cm.options.tabSize;\\n    var line = getLine(doc, n), curSpace = countColumn(line.text, null, tabSize);\\n    if (line.stateAfter) line.stateAfter = null;\\n    var curSpaceString = line.text.match(/^\\\\s*/)[0], indentation;\\n    if (!aggressive && !/\\\\S/.test(line.text)) {\\n      indentation = 0;\\n      how = \\\"not\\\";\\n    } else if (how == \\\"smart\\\") {\\n      indentation = doc.mode.indent(state, line.text.slice(curSpaceString.length), line.text);\\n      if (indentation == Pass || indentation > 150) {\\n        if (!aggressive) return;\\n        how = \\\"prev\\\";\\n      }\\n    }\\n    if (how == \\\"prev\\\") {\\n      if (n > doc.first) indentation = countColumn(getLine(doc, n-1).text, null, tabSize);\\n      else indentation = 0;\\n    } else if (how == \\\"add\\\") {\\n      indentation = curSpace + cm.options.indentUnit;\\n    } else if (how == \\\"subtract\\\") {\\n      indentation = curSpace - cm.options.indentUnit;\\n    } else if (typeof how == \\\"number\\\") {\\n      indentation = curSpace + how;\\n    }\\n    indentation = Math.max(0, indentation);\\n\\n    var indentString = \\\"\\\", pos = 0;\\n    if (cm.options.indentWithTabs)\\n      for (var i = Math.floor(indentation / tabSize); i; --i) {pos += tabSize; indentString += \\\"\\\\t\\\";}\\n    if (pos < indentation) indentString += spaceStr(indentation - pos);\\n\\n    if (indentString != curSpaceString) {\\n      replaceRange(doc, indentString, Pos(n, 0), Pos(n, curSpaceString.length), \\\"+input\\\");\\n      line.stateAfter = null;\\n      return true;\\n    } else {\\n      // Ensure that, if the cursor was in the whitespace at the start\\n      // of the line, it is moved to the end of that space.\\n      for (var i = 0; i < doc.sel.ranges.length; i++) {\\n        var range = doc.sel.ranges[i];\\n        if (range.head.line == n && range.head.ch < curSpaceString.length) {\\n          var pos = Pos(n, curSpaceString.length);\\n          replaceOneSelection(doc, i, new Range(pos, pos));\\n          break;\\n        }\\n      }\\n    }\\n  }\\n\\n  // Utility for applying a change to a line by handle or number,\\n  // returning the number and optionally registering the line as\\n  // changed.\\n  function changeLine(doc, handle, changeType, op) {\\n    var no = handle, line = handle;\\n    if (typeof handle == \\\"number\\\") line = getLine(doc, clipLine(doc, handle));\\n    else no = lineNo(handle);\\n    if (no == null) return null;\\n    if (op(line, no) && doc.cm) regLineChange(doc.cm, no, changeType);\\n    return line;\\n  }\\n\\n  // Helper for deleting text near the selection(s), used to implement\\n  // backspace, delete, and similar functionality.\\n  function deleteNearSelection(cm, compute) {\\n    var ranges = cm.doc.sel.ranges, kill = [];\\n    // Build up a set of ranges to kill first, merging overlapping\\n    // ranges.\\n    for (var i = 0; i < ranges.length; i++) {\\n      var toKill = compute(ranges[i]);\\n      while (kill.length && cmp(toKill.from, lst(kill).to) <= 0) {\\n        var replaced = kill.pop();\\n        if (cmp(replaced.from, toKill.from) < 0) {\\n          toKill.from = replaced.from;\\n          break;\\n        }\\n      }\\n      kill.push(toKill);\\n    }\\n    // Next, remove those actual ranges.\\n    runInOp(cm, function() {\\n      for (var i = kill.length - 1; i >= 0; i--)\\n        replaceRange(cm.doc, \\\"\\\", kill[i].from, kill[i].to, \\\"+delete\\\");\\n      ensureCursorVisible(cm);\\n    });\\n  }\\n\\n  // Used for horizontal relative motion. Dir is -1 or 1 (left or\\n  // right), unit can be \\\"char\\\", \\\"column\\\" (like char, but doesn't\\n  // cross line boundaries), \\\"word\\\" (across next word), or \\\"group\\\" (to\\n  // the start of next group of word or non-word-non-whitespace\\n  // chars). The visually param controls whether, in right-to-left\\n  // text, direction 1 means to move towards the next index in the\\n  // string, or towards the character to the right of the current\\n  // position. The resulting position will have a hitSide=true\\n  // property if it reached the end of the document.\\n  function findPosH(doc, pos, dir, unit, visually) {\\n    var line = pos.line, ch = pos.ch, origDir = dir;\\n    var lineObj = getLine(doc, line);\\n    function findNextLine() {\\n      var l = line + dir;\\n      if (l < doc.first || l >= doc.first + doc.size) return false\\n      line = l;\\n      return lineObj = getLine(doc, l);\\n    }\\n    function moveOnce(boundToLine) {\\n      var next = (visually ? moveVisually : moveLogically)(lineObj, ch, dir, true);\\n      if (next == null) {\\n        if (!boundToLine && findNextLine()) {\\n          if (visually) ch = (dir < 0 ? lineRight : lineLeft)(lineObj);\\n          else ch = dir < 0 ? lineObj.text.length : 0;\\n        } else return false\\n      } else ch = next;\\n      return true;\\n    }\\n\\n    if (unit == \\\"char\\\") {\\n      moveOnce()\\n    } else if (unit == \\\"column\\\") {\\n      moveOnce(true)\\n    } else if (unit == \\\"word\\\" || unit == \\\"group\\\") {\\n      var sawType = null, group = unit == \\\"group\\\";\\n      var helper = doc.cm && doc.cm.getHelper(pos, \\\"wordChars\\\");\\n      for (var first = true;; first = false) {\\n        if (dir < 0 && !moveOnce(!first)) break;\\n        var cur = lineObj.text.charAt(ch) || \\\"\\\\n\\\";\\n        var type = isWordChar(cur, helper) ? \\\"w\\\"\\n          : group && cur == \\\"\\\\n\\\" ? \\\"n\\\"\\n          : !group || /\\\\s/.test(cur) ? null\\n          : \\\"p\\\";\\n        if (group && !first && !type) type = \\\"s\\\";\\n        if (sawType && sawType != type) {\\n          if (dir < 0) {dir = 1; moveOnce();}\\n          break;\\n        }\\n\\n        if (type) sawType = type;\\n        if (dir > 0 && !moveOnce(!first)) break;\\n      }\\n    }\\n    var result = skipAtomic(doc, Pos(line, ch), pos, origDir, true);\\n    if (!cmp(pos, result)) result.hitSide = true;\\n    return result;\\n  }\\n\\n  // For relative vertical movement. Dir may be -1 or 1. Unit can be\\n  // \\\"page\\\" or \\\"line\\\". The resulting position will have a hitSide=true\\n  // property if it reached the end of the document.\\n  function findPosV(cm, pos, dir, unit) {\\n    var doc = cm.doc, x = pos.left, y;\\n    if (unit == \\\"page\\\") {\\n      var pageSize = Math.min(cm.display.wrapper.clientHeight, window.innerHeight || document.documentElement.clientHeight);\\n      var moveAmount = Math.max(pageSize - .5 * textHeight(cm.display), 3);\\n      y = (dir > 0 ? pos.bottom : pos.top) + dir * moveAmount;\\n    } else if (unit == \\\"line\\\") {\\n      y = dir > 0 ? pos.bottom + 3 : pos.top - 3;\\n    }\\n    for (;;) {\\n      var target = coordsChar(cm, x, y);\\n      if (!target.outside) break;\\n      if (dir < 0 ? y <= 0 : y >= doc.height) { target.hitSide = true; break; }\\n      y += dir * 5;\\n    }\\n    return target;\\n  }\\n\\n  // EDITOR METHODS\\n\\n  // The publicly visible API. Note that methodOp(f) means\\n  // 'wrap f in an operation, performed on its `this` parameter'.\\n\\n  // This is not the complete set of editor methods. Most of the\\n  // methods defined on the Doc type are also injected into\\n  // CodeMirror.prototype, for backwards compatibility and\\n  // convenience.\\n\\n  CodeMirror.prototype = {\\n    constructor: CodeMirror,\\n    focus: function(){window.focus(); this.display.input.focus();},\\n\\n    setOption: function(option, value) {\\n      var options = this.options, old = options[option];\\n      if (options[option] == value && option != \\\"mode\\\") return;\\n      options[option] = value;\\n      if (optionHandlers.hasOwnProperty(option))\\n        operation(this, optionHandlers[option])(this, value, old);\\n    },\\n\\n    getOption: function(option) {return this.options[option];},\\n    getDoc: function() {return this.doc;},\\n\\n    addKeyMap: function(map, bottom) {\\n      this.state.keyMaps[bottom ? \\\"push\\\" : \\\"unshift\\\"](getKeyMap(map));\\n    },\\n    removeKeyMap: function(map) {\\n      var maps = this.state.keyMaps;\\n      for (var i = 0; i < maps.length; ++i)\\n        if (maps[i] == map || maps[i].name == map) {\\n          maps.splice(i, 1);\\n          return true;\\n        }\\n    },\\n\\n    addOverlay: methodOp(function(spec, options) {\\n      var mode = spec.token ? spec : CodeMirror.getMode(this.options, spec);\\n      if (mode.startState) throw new Error(\\\"Overlays may not be stateful.\\\");\\n      insertSorted(this.state.overlays,\\n                   {mode: mode, modeSpec: spec, opaque: options && options.opaque,\\n                    priority: (options && options.priority) || 0},\\n                   function(overlay) { return overlay.priority })\\n      this.state.modeGen++;\\n      regChange(this);\\n    }),\\n    removeOverlay: methodOp(function(spec) {\\n      var overlays = this.state.overlays;\\n      for (var i = 0; i < overlays.length; ++i) {\\n        var cur = overlays[i].modeSpec;\\n        if (cur == spec || typeof spec == \\\"string\\\" && cur.name == spec) {\\n          overlays.splice(i, 1);\\n          this.state.modeGen++;\\n          regChange(this);\\n          return;\\n        }\\n      }\\n    }),\\n\\n    indentLine: methodOp(function(n, dir, aggressive) {\\n      if (typeof dir != \\\"string\\\" && typeof dir != \\\"number\\\") {\\n        if (dir == null) dir = this.options.smartIndent ? \\\"smart\\\" : \\\"prev\\\";\\n        else dir = dir ? \\\"add\\\" : \\\"subtract\\\";\\n      }\\n      if (isLine(this.doc, n)) indentLine(this, n, dir, aggressive);\\n    }),\\n    indentSelection: methodOp(function(how) {\\n      var ranges = this.doc.sel.ranges, end = -1;\\n      for (var i = 0; i < ranges.length; i++) {\\n        var range = ranges[i];\\n        if (!range.empty()) {\\n          var from = range.from(), to = range.to();\\n          var start = Math.max(end, from.line);\\n          end = Math.min(this.lastLine(), to.line - (to.ch ? 0 : 1)) + 1;\\n          for (var j = start; j < end; ++j)\\n            indentLine(this, j, how);\\n          var newRanges = this.doc.sel.ranges;\\n          if (from.ch == 0 && ranges.length == newRanges.length && newRanges[i].from().ch > 0)\\n            replaceOneSelection(this.doc, i, new Range(from, newRanges[i].to()), sel_dontScroll);\\n        } else if (range.head.line > end) {\\n          indentLine(this, range.head.line, how, true);\\n          end = range.head.line;\\n          if (i == this.doc.sel.primIndex) ensureCursorVisible(this);\\n        }\\n      }\\n    }),\\n\\n    // Fetch the parser token for a given character. Useful for hacks\\n    // that want to inspect the mode state (say, for completion).\\n    getTokenAt: function(pos, precise) {\\n      return takeToken(this, pos, precise);\\n    },\\n\\n    getLineTokens: function(line, precise) {\\n      return takeToken(this, Pos(line), precise, true);\\n    },\\n\\n    getTokenTypeAt: function(pos) {\\n      pos = clipPos(this.doc, pos);\\n      var styles = getLineStyles(this, getLine(this.doc, pos.line));\\n      var before = 0, after = (styles.length - 1) / 2, ch = pos.ch;\\n      var type;\\n      if (ch == 0) type = styles[2];\\n      else for (;;) {\\n        var mid = (before + after) >> 1;\\n        if ((mid ? styles[mid * 2 - 1] : 0) >= ch) after = mid;\\n        else if (styles[mid * 2 + 1] < ch) before = mid + 1;\\n        else { type = styles[mid * 2 + 2]; break; }\\n      }\\n      var cut = type ? type.indexOf(\\\"cm-overlay \\\") : -1;\\n      return cut < 0 ? type : cut == 0 ? null : type.slice(0, cut - 1);\\n    },\\n\\n    getModeAt: function(pos) {\\n      var mode = this.doc.mode;\\n      if (!mode.innerMode) return mode;\\n      return CodeMirror.innerMode(mode, this.getTokenAt(pos).state).mode;\\n    },\\n\\n    getHelper: function(pos, type) {\\n      return this.getHelpers(pos, type)[0];\\n    },\\n\\n    getHelpers: function(pos, type) {\\n      var found = [];\\n      if (!helpers.hasOwnProperty(type)) return found;\\n      var help = helpers[type], mode = this.getModeAt(pos);\\n      if (typeof mode[type] == \\\"string\\\") {\\n        if (help[mode[type]]) found.push(help[mode[type]]);\\n      } else if (mode[type]) {\\n        for (var i = 0; i < mode[type].length; i++) {\\n          var val = help[mode[type][i]];\\n          if (val) found.push(val);\\n        }\\n      } else if (mode.helperType && help[mode.helperType]) {\\n        found.push(help[mode.helperType]);\\n      } else if (help[mode.name]) {\\n        found.push(help[mode.name]);\\n      }\\n      for (var i = 0; i < help._global.length; i++) {\\n        var cur = help._global[i];\\n        if (cur.pred(mode, this) && indexOf(found, cur.val) == -1)\\n          found.push(cur.val);\\n      }\\n      return found;\\n    },\\n\\n    getStateAfter: function(line, precise) {\\n      var doc = this.doc;\\n      line = clipLine(doc, line == null ? doc.first + doc.size - 1: line);\\n      return getStateBefore(this, line + 1, precise);\\n    },\\n\\n    cursorCoords: function(start, mode) {\\n      var pos, range = this.doc.sel.primary();\\n      if (start == null) pos = range.head;\\n      else if (typeof start == \\\"object\\\") pos = clipPos(this.doc, start);\\n      else pos = start ? range.from() : range.to();\\n      return cursorCoords(this, pos, mode || \\\"page\\\");\\n    },\\n\\n    charCoords: function(pos, mode) {\\n      return charCoords(this, clipPos(this.doc, pos), mode || \\\"page\\\");\\n    },\\n\\n    coordsChar: function(coords, mode) {\\n      coords = fromCoordSystem(this, coords, mode || \\\"page\\\");\\n      return coordsChar(this, coords.left, coords.top);\\n    },\\n\\n    lineAtHeight: function(height, mode) {\\n      height = fromCoordSystem(this, {top: height, left: 0}, mode || \\\"page\\\").top;\\n      return lineAtHeight(this.doc, height + this.display.viewOffset);\\n    },\\n    heightAtLine: function(line, mode) {\\n      var end = false, lineObj;\\n      if (typeof line == \\\"number\\\") {\\n        var last = this.doc.first + this.doc.size - 1;\\n        if (line < this.doc.first) line = this.doc.first;\\n        else if (line > last) { line = last; end = true; }\\n        lineObj = getLine(this.doc, line);\\n      } else {\\n        lineObj = line;\\n      }\\n      return intoCoordSystem(this, lineObj, {top: 0, left: 0}, mode || \\\"page\\\").top +\\n        (end ? this.doc.height - heightAtLine(lineObj) : 0);\\n    },\\n\\n    defaultTextHeight: function() { return textHeight(this.display); },\\n    defaultCharWidth: function() { return charWidth(this.display); },\\n\\n    setGutterMarker: methodOp(function(line, gutterID, value) {\\n      return changeLine(this.doc, line, \\\"gutter\\\", function(line) {\\n        var markers = line.gutterMarkers || (line.gutterMarkers = {});\\n        markers[gutterID] = value;\\n        if (!value && isEmpty(markers)) line.gutterMarkers = null;\\n        return true;\\n      });\\n    }),\\n\\n    clearGutter: methodOp(function(gutterID) {\\n      var cm = this, doc = cm.doc, i = doc.first;\\n      doc.iter(function(line) {\\n        if (line.gutterMarkers && line.gutterMarkers[gutterID]) {\\n          line.gutterMarkers[gutterID] = null;\\n          regLineChange(cm, i, \\\"gutter\\\");\\n          if (isEmpty(line.gutterMarkers)) line.gutterMarkers = null;\\n        }\\n        ++i;\\n      });\\n    }),\\n\\n    lineInfo: function(line) {\\n      if (typeof line == \\\"number\\\") {\\n        if (!isLine(this.doc, line)) return null;\\n        var n = line;\\n        line = getLine(this.doc, line);\\n        if (!line) return null;\\n      } else {\\n        var n = lineNo(line);\\n        if (n == null) return null;\\n      }\\n      return {line: n, handle: line, text: line.text, gutterMarkers: line.gutterMarkers,\\n              textClass: line.textClass, bgClass: line.bgClass, wrapClass: line.wrapClass,\\n              widgets: line.widgets};\\n    },\\n\\n    getViewport: function() { return {from: this.display.viewFrom, to: this.display.viewTo};},\\n\\n    addWidget: function(pos, node, scroll, vert, horiz) {\\n      var display = this.display;\\n      pos = cursorCoords(this, clipPos(this.doc, pos));\\n      var top = pos.bottom, left = pos.left;\\n      node.style.position = \\\"absolute\\\";\\n      node.setAttribute(\\\"cm-ignore-events\\\", \\\"true\\\");\\n      this.display.input.setUneditable(node);\\n      display.sizer.appendChild(node);\\n      if (vert == \\\"over\\\") {\\n        top = pos.top;\\n      } else if (vert == \\\"above\\\" || vert == \\\"near\\\") {\\n        var vspace = Math.max(display.wrapper.clientHeight, this.doc.height),\\n        hspace = Math.max(display.sizer.clientWidth, display.lineSpace.clientWidth);\\n        // Default to positioning above (if specified and possible); otherwise default to positioning below\\n        if ((vert == 'above' || pos.bottom + node.offsetHeight > vspace) && pos.top > node.offsetHeight)\\n          top = pos.top - node.offsetHeight;\\n        else if (pos.bottom + node.offsetHeight <= vspace)\\n          top = pos.bottom;\\n        if (left + node.offsetWidth > hspace)\\n          left = hspace - node.offsetWidth;\\n      }\\n      node.style.top = top + \\\"px\\\";\\n      node.style.left = node.style.right = \\\"\\\";\\n      if (horiz == \\\"right\\\") {\\n        left = display.sizer.clientWidth - node.offsetWidth;\\n        node.style.right = \\\"0px\\\";\\n      } else {\\n        if (horiz == \\\"left\\\") left = 0;\\n        else if (horiz == \\\"middle\\\") left = (display.sizer.clientWidth - node.offsetWidth) / 2;\\n        node.style.left = left + \\\"px\\\";\\n      }\\n      if (scroll)\\n        scrollIntoView(this, left, top, left + node.offsetWidth, top + node.offsetHeight);\\n    },\\n\\n    triggerOnKeyDown: methodOp(onKeyDown),\\n    triggerOnKeyPress: methodOp(onKeyPress),\\n    triggerOnKeyUp: onKeyUp,\\n\\n    execCommand: function(cmd) {\\n      if (commands.hasOwnProperty(cmd))\\n        return commands[cmd].call(null, this);\\n    },\\n\\n    triggerElectric: methodOp(function(text) { triggerElectric(this, text); }),\\n\\n    findPosH: function(from, amount, unit, visually) {\\n      var dir = 1;\\n      if (amount < 0) { dir = -1; amount = -amount; }\\n      for (var i = 0, cur = clipPos(this.doc, from); i < amount; ++i) {\\n        cur = findPosH(this.doc, cur, dir, unit, visually);\\n        if (cur.hitSide) break;\\n      }\\n      return cur;\\n    },\\n\\n    moveH: methodOp(function(dir, unit) {\\n      var cm = this;\\n      cm.extendSelectionsBy(function(range) {\\n        if (cm.display.shift || cm.doc.extend || range.empty())\\n          return findPosH(cm.doc, range.head, dir, unit, cm.options.rtlMoveVisually);\\n        else\\n          return dir < 0 ? range.from() : range.to();\\n      }, sel_move);\\n    }),\\n\\n    deleteH: methodOp(function(dir, unit) {\\n      var sel = this.doc.sel, doc = this.doc;\\n      if (sel.somethingSelected())\\n        doc.replaceSelection(\\\"\\\", null, \\\"+delete\\\");\\n      else\\n        deleteNearSelection(this, function(range) {\\n          var other = findPosH(doc, range.head, dir, unit, false);\\n          return dir < 0 ? {from: other, to: range.head} : {from: range.head, to: other};\\n        });\\n    }),\\n\\n    findPosV: function(from, amount, unit, goalColumn) {\\n      var dir = 1, x = goalColumn;\\n      if (amount < 0) { dir = -1; amount = -amount; }\\n      for (var i = 0, cur = clipPos(this.doc, from); i < amount; ++i) {\\n        var coords = cursorCoords(this, cur, \\\"div\\\");\\n        if (x == null) x = coords.left;\\n        else coords.left = x;\\n        cur = findPosV(this, coords, dir, unit);\\n        if (cur.hitSide) break;\\n      }\\n      return cur;\\n    },\\n\\n    moveV: methodOp(function(dir, unit) {\\n      var cm = this, doc = this.doc, goals = [];\\n      var collapse = !cm.display.shift && !doc.extend && doc.sel.somethingSelected();\\n      doc.extendSelectionsBy(function(range) {\\n        if (collapse)\\n          return dir < 0 ? range.from() : range.to();\\n        var headPos = cursorCoords(cm, range.head, \\\"div\\\");\\n        if (range.goalColumn != null) headPos.left = range.goalColumn;\\n        goals.push(headPos.left);\\n        var pos = findPosV(cm, headPos, dir, unit);\\n        if (unit == \\\"page\\\" && range == doc.sel.primary())\\n          addToScrollPos(cm, null, charCoords(cm, pos, \\\"div\\\").top - headPos.top);\\n        return pos;\\n      }, sel_move);\\n      if (goals.length) for (var i = 0; i < doc.sel.ranges.length; i++)\\n        doc.sel.ranges[i].goalColumn = goals[i];\\n    }),\\n\\n    // Find the word at the given position (as returned by coordsChar).\\n    findWordAt: function(pos) {\\n      var doc = this.doc, line = getLine(doc, pos.line).text;\\n      var start = pos.ch, end = pos.ch;\\n      if (line) {\\n        var helper = this.getHelper(pos, \\\"wordChars\\\");\\n        if ((pos.xRel < 0 || end == line.length) && start) --start; else ++end;\\n        var startChar = line.charAt(start);\\n        var check = isWordChar(startChar, helper)\\n          ? function(ch) { return isWordChar(ch, helper); }\\n          : /\\\\s/.test(startChar) ? function(ch) {return /\\\\s/.test(ch);}\\n          : function(ch) {return !/\\\\s/.test(ch) && !isWordChar(ch);};\\n        while (start > 0 && check(line.charAt(start - 1))) --start;\\n        while (end < line.length && check(line.charAt(end))) ++end;\\n      }\\n      return new Range(Pos(pos.line, start), Pos(pos.line, end));\\n    },\\n\\n    toggleOverwrite: function(value) {\\n      if (value != null && value == this.state.overwrite) return;\\n      if (this.state.overwrite = !this.state.overwrite)\\n        addClass(this.display.cursorDiv, \\\"CodeMirror-overwrite\\\");\\n      else\\n        rmClass(this.display.cursorDiv, \\\"CodeMirror-overwrite\\\");\\n\\n      signal(this, \\\"overwriteToggle\\\", this, this.state.overwrite);\\n    },\\n    hasFocus: function() { return this.display.input.getField() == activeElt(); },\\n    isReadOnly: function() { return !!(this.options.readOnly || this.doc.cantEdit); },\\n\\n    scrollTo: methodOp(function(x, y) {\\n      if (x != null || y != null) resolveScrollToPos(this);\\n      if (x != null) this.curOp.scrollLeft = x;\\n      if (y != null) this.curOp.scrollTop = y;\\n    }),\\n    getScrollInfo: function() {\\n      var scroller = this.display.scroller;\\n      return {left: scroller.scrollLeft, top: scroller.scrollTop,\\n              height: scroller.scrollHeight - scrollGap(this) - this.display.barHeight,\\n              width: scroller.scrollWidth - scrollGap(this) - this.display.barWidth,\\n              clientHeight: displayHeight(this), clientWidth: displayWidth(this)};\\n    },\\n\\n    scrollIntoView: methodOp(function(range, margin) {\\n      if (range == null) {\\n        range = {from: this.doc.sel.primary().head, to: null};\\n        if (margin == null) margin = this.options.cursorScrollMargin;\\n      } else if (typeof range == \\\"number\\\") {\\n        range = {from: Pos(range, 0), to: null};\\n      } else if (range.from == null) {\\n        range = {from: range, to: null};\\n      }\\n      if (!range.to) range.to = range.from;\\n      range.margin = margin || 0;\\n\\n      if (range.from.line != null) {\\n        resolveScrollToPos(this);\\n        this.curOp.scrollToPos = range;\\n      } else {\\n        var sPos = calculateScrollPos(this, Math.min(range.from.left, range.to.left),\\n                                      Math.min(range.from.top, range.to.top) - range.margin,\\n                                      Math.max(range.from.right, range.to.right),\\n                                      Math.max(range.from.bottom, range.to.bottom) + range.margin);\\n        this.scrollTo(sPos.scrollLeft, sPos.scrollTop);\\n      }\\n    }),\\n\\n    setSize: methodOp(function(width, height) {\\n      var cm = this;\\n      function interpret(val) {\\n        return typeof val == \\\"number\\\" || /^\\\\d+$/.test(String(val)) ? val + \\\"px\\\" : val;\\n      }\\n      if (width != null) cm.display.wrapper.style.width = interpret(width);\\n      if (height != null) cm.display.wrapper.style.height = interpret(height);\\n      if (cm.options.lineWrapping) clearLineMeasurementCache(this);\\n      var lineNo = cm.display.viewFrom;\\n      cm.doc.iter(lineNo, cm.display.viewTo, function(line) {\\n        if (line.widgets) for (var i = 0; i < line.widgets.length; i++)\\n          if (line.widgets[i].noHScroll) { regLineChange(cm, lineNo, \\\"widget\\\"); break; }\\n        ++lineNo;\\n      });\\n      cm.curOp.forceUpdate = true;\\n      signal(cm, \\\"refresh\\\", this);\\n    }),\\n\\n    operation: function(f){return runInOp(this, f);},\\n\\n    refresh: methodOp(function() {\\n      var oldHeight = this.display.cachedTextHeight;\\n      regChange(this);\\n      this.curOp.forceUpdate = true;\\n      clearCaches(this);\\n      this.scrollTo(this.doc.scrollLeft, this.doc.scrollTop);\\n      updateGutterSpace(this);\\n      if (oldHeight == null || Math.abs(oldHeight - textHeight(this.display)) > .5)\\n        estimateLineHeights(this);\\n      signal(this, \\\"refresh\\\", this);\\n    }),\\n\\n    swapDoc: methodOp(function(doc) {\\n      var old = this.doc;\\n      old.cm = null;\\n      attachDoc(this, doc);\\n      clearCaches(this);\\n      this.display.input.reset();\\n      this.scrollTo(doc.scrollLeft, doc.scrollTop);\\n      this.curOp.forceScroll = true;\\n      signalLater(this, \\\"swapDoc\\\", this, old);\\n      return old;\\n    }),\\n\\n    getInputField: function(){return this.display.input.getField();},\\n    getWrapperElement: function(){return this.display.wrapper;},\\n    getScrollerElement: function(){return this.display.scroller;},\\n    getGutterElement: function(){return this.display.gutters;}\\n  };\\n  eventMixin(CodeMirror);\\n\\n  // OPTION DEFAULTS\\n\\n  // The default configuration options.\\n  var defaults = CodeMirror.defaults = {};\\n  // Functions to run when options are changed.\\n  var optionHandlers = CodeMirror.optionHandlers = {};\\n\\n  function option(name, deflt, handle, notOnInit) {\\n    CodeMirror.defaults[name] = deflt;\\n    if (handle) optionHandlers[name] =\\n      notOnInit ? function(cm, val, old) {if (old != Init) handle(cm, val, old);} : handle;\\n  }\\n\\n  // Passed to option handlers when there is no old value.\\n  var Init = CodeMirror.Init = {toString: function(){return \\\"CodeMirror.Init\\\";}};\\n\\n  // These two are, on init, called from the constructor because they\\n  // have to be initialized before the editor can start at all.\\n  option(\\\"value\\\", \\\"\\\", function(cm, val) {\\n    cm.setValue(val);\\n  }, true);\\n  option(\\\"mode\\\", null, function(cm, val) {\\n    cm.doc.modeOption = val;\\n    loadMode(cm);\\n  }, true);\\n\\n  option(\\\"indentUnit\\\", 2, loadMode, true);\\n  option(\\\"indentWithTabs\\\", false);\\n  option(\\\"smartIndent\\\", true);\\n  option(\\\"tabSize\\\", 4, function(cm) {\\n    resetModeState(cm);\\n    clearCaches(cm);\\n    regChange(cm);\\n  }, true);\\n  option(\\\"lineSeparator\\\", null, function(cm, val) {\\n    cm.doc.lineSep = val;\\n    if (!val) return;\\n    var newBreaks = [], lineNo = cm.doc.first;\\n    cm.doc.iter(function(line) {\\n      for (var pos = 0;;) {\\n        var found = line.text.indexOf(val, pos);\\n        if (found == -1) break;\\n        pos = found + val.length;\\n        newBreaks.push(Pos(lineNo, found));\\n      }\\n      lineNo++;\\n    });\\n    for (var i = newBreaks.length - 1; i >= 0; i--)\\n      replaceRange(cm.doc, val, newBreaks[i], Pos(newBreaks[i].line, newBreaks[i].ch + val.length))\\n  });\\n  option(\\\"specialChars\\\", /[\\\\u0000-\\\\u001f\\\\u007f\\\\u00ad\\\\u200b-\\\\u200f\\\\u2028\\\\u2029\\\\ufeff]/g, function(cm, val, old) {\\n    cm.state.specialChars = new RegExp(val.source + (val.test(\\\"\\\\t\\\") ? \\\"\\\" : \\\"|\\\\t\\\"), \\\"g\\\");\\n    if (old != CodeMirror.Init) cm.refresh();\\n  });\\n  option(\\\"specialCharPlaceholder\\\", defaultSpecialCharPlaceholder, function(cm) {cm.refresh();}, true);\\n  option(\\\"electricChars\\\", true);\\n  option(\\\"inputStyle\\\", mobile ? \\\"contenteditable\\\" : \\\"textarea\\\", function() {\\n    throw new Error(\\\"inputStyle can not (yet) be changed in a running editor\\\"); // FIXME\\n  }, true);\\n  option(\\\"spellcheck\\\", false, function(cm, val) {\\n    cm.getInputField().spellcheck = val\\n  }, true);\\n  option(\\\"rtlMoveVisually\\\", !windows);\\n  option(\\\"wholeLineUpdateBefore\\\", true);\\n\\n  option(\\\"theme\\\", \\\"default\\\", function(cm) {\\n    themeChanged(cm);\\n    guttersChanged(cm);\\n  }, true);\\n  option(\\\"keyMap\\\", \\\"default\\\", function(cm, val, old) {\\n    var next = getKeyMap(val);\\n    var prev = old != CodeMirror.Init && getKeyMap(old);\\n    if (prev && prev.detach) prev.detach(cm, next);\\n    if (next.attach) next.attach(cm, prev || null);\\n  });\\n  option(\\\"extraKeys\\\", null);\\n\\n  option(\\\"lineWrapping\\\", false, wrappingChanged, true);\\n  option(\\\"gutters\\\", [], function(cm) {\\n    setGuttersForLineNumbers(cm.options);\\n    guttersChanged(cm);\\n  }, true);\\n  option(\\\"fixedGutter\\\", true, function(cm, val) {\\n    cm.display.gutters.style.left = val ? compensateForHScroll(cm.display) + \\\"px\\\" : \\\"0\\\";\\n    cm.refresh();\\n  }, true);\\n  option(\\\"coverGutterNextToScrollbar\\\", false, function(cm) {updateScrollbars(cm);}, true);\\n  option(\\\"scrollbarStyle\\\", \\\"native\\\", function(cm) {\\n    initScrollbars(cm);\\n    updateScrollbars(cm);\\n    cm.display.scrollbars.setScrollTop(cm.doc.scrollTop);\\n    cm.display.scrollbars.setScrollLeft(cm.doc.scrollLeft);\\n  }, true);\\n  option(\\\"lineNumbers\\\", false, function(cm) {\\n    setGuttersForLineNumbers(cm.options);\\n    guttersChanged(cm);\\n  }, true);\\n  option(\\\"firstLineNumber\\\", 1, guttersChanged, true);\\n  option(\\\"lineNumberFormatter\\\", function(integer) {return integer;}, guttersChanged, true);\\n  option(\\\"showCursorWhenSelecting\\\", false, updateSelection, true);\\n\\n  option(\\\"resetSelectionOnContextMenu\\\", true);\\n  option(\\\"lineWiseCopyCut\\\", true);\\n\\n  option(\\\"readOnly\\\", false, function(cm, val) {\\n    if (val == \\\"nocursor\\\") {\\n      onBlur(cm);\\n      cm.display.input.blur();\\n      cm.display.disabled = true;\\n    } else {\\n      cm.display.disabled = false;\\n    }\\n    cm.display.input.readOnlyChanged(val)\\n  });\\n  option(\\\"disableInput\\\", false, function(cm, val) {if (!val) cm.display.input.reset();}, true);\\n  option(\\\"dragDrop\\\", true, dragDropChanged);\\n  option(\\\"allowDropFileTypes\\\", null);\\n\\n  option(\\\"cursorBlinkRate\\\", 530);\\n  option(\\\"cursorScrollMargin\\\", 0);\\n  option(\\\"cursorHeight\\\", 1, updateSelection, true);\\n  option(\\\"singleCursorHeightPerLine\\\", true, updateSelection, true);\\n  option(\\\"workTime\\\", 100);\\n  option(\\\"workDelay\\\", 100);\\n  option(\\\"flattenSpans\\\", true, resetModeState, true);\\n  option(\\\"addModeClass\\\", false, resetModeState, true);\\n  option(\\\"pollInterval\\\", 100);\\n  option(\\\"undoDepth\\\", 200, function(cm, val){cm.doc.history.undoDepth = val;});\\n  option(\\\"historyEventDelay\\\", 1250);\\n  option(\\\"viewportMargin\\\", 10, function(cm){cm.refresh();}, true);\\n  option(\\\"maxHighlightLength\\\", 10000, resetModeState, true);\\n  option(\\\"moveInputWithCursor\\\", true, function(cm, val) {\\n    if (!val) cm.display.input.resetPosition();\\n  });\\n\\n  option(\\\"tabindex\\\", null, function(cm, val) {\\n    cm.display.input.getField().tabIndex = val || \\\"\\\";\\n  });\\n  option(\\\"autofocus\\\", null);\\n\\n  // MODE DEFINITION AND QUERYING\\n\\n  // Known modes, by name and by MIME\\n  var modes = CodeMirror.modes = {}, mimeModes = CodeMirror.mimeModes = {};\\n\\n  // Extra arguments are stored as the mode's dependencies, which is\\n  // used by (legacy) mechanisms like loadmode.js to automatically\\n  // load a mode. (Preferred mechanism is the require/define calls.)\\n  CodeMirror.defineMode = function(name, mode) {\\n    if (!CodeMirror.defaults.mode && name != \\\"null\\\") CodeMirror.defaults.mode = name;\\n    if (arguments.length > 2)\\n      mode.dependencies = Array.prototype.slice.call(arguments, 2);\\n    modes[name] = mode;\\n  };\\n\\n  CodeMirror.defineMIME = function(mime, spec) {\\n    mimeModes[mime] = spec;\\n  };\\n\\n  // Given a MIME type, a {name, ...options} config object, or a name\\n  // string, return a mode config object.\\n  CodeMirror.resolveMode = function(spec) {\\n    if (typeof spec == \\\"string\\\" && mimeModes.hasOwnProperty(spec)) {\\n      spec = mimeModes[spec];\\n    } else if (spec && typeof spec.name == \\\"string\\\" && mimeModes.hasOwnProperty(spec.name)) {\\n      var found = mimeModes[spec.name];\\n      if (typeof found == \\\"string\\\") found = {name: found};\\n      spec = createObj(found, spec);\\n      spec.name = found.name;\\n    } else if (typeof spec == \\\"string\\\" && /^[\\\\w\\\\-]+\\\\/[\\\\w\\\\-]+\\\\+xml$/.test(spec)) {\\n      return CodeMirror.resolveMode(\\\"application/xml\\\");\\n    } else if (typeof spec == \\\"string\\\" && /^[\\\\w\\\\-]+\\\\/[\\\\w\\\\-]+\\\\+json$/.test(spec)) {\\n      return CodeMirror.resolveMode(\\\"application/json\\\");\\n    }\\n    if (typeof spec == \\\"string\\\") return {name: spec};\\n    else return spec || {name: \\\"null\\\"};\\n  };\\n\\n  // Given a mode spec (anything that resolveMode accepts), find and\\n  // initialize an actual mode object.\\n  CodeMirror.getMode = function(options, spec) {\\n    var spec = CodeMirror.resolveMode(spec);\\n    var mfactory = modes[spec.name];\\n    if (!mfactory) return CodeMirror.getMode(options, \\\"text/plain\\\");\\n    var modeObj = mfactory(options, spec);\\n    if (modeExtensions.hasOwnProperty(spec.name)) {\\n      var exts = modeExtensions[spec.name];\\n      for (var prop in exts) {\\n        if (!exts.hasOwnProperty(prop)) continue;\\n        if (modeObj.hasOwnProperty(prop)) modeObj[\\\"_\\\" + prop] = modeObj[prop];\\n        modeObj[prop] = exts[prop];\\n      }\\n    }\\n    modeObj.name = spec.name;\\n    if (spec.helperType) modeObj.helperType = spec.helperType;\\n    if (spec.modeProps) for (var prop in spec.modeProps)\\n      modeObj[prop] = spec.modeProps[prop];\\n\\n    return modeObj;\\n  };\\n\\n  // Minimal default mode.\\n  CodeMirror.defineMode(\\\"null\\\", function() {\\n    return {token: function(stream) {stream.skipToEnd();}};\\n  });\\n  CodeMirror.defineMIME(\\\"text/plain\\\", \\\"null\\\");\\n\\n  // This can be used to attach properties to mode objects from\\n  // outside the actual mode definition.\\n  var modeExtensions = CodeMirror.modeExtensions = {};\\n  CodeMirror.extendMode = function(mode, properties) {\\n    var exts = modeExtensions.hasOwnProperty(mode) ? modeExtensions[mode] : (modeExtensions[mode] = {});\\n    copyObj(properties, exts);\\n  };\\n\\n  // EXTENSIONS\\n\\n  CodeMirror.defineExtension = function(name, func) {\\n    CodeMirror.prototype[name] = func;\\n  };\\n  CodeMirror.defineDocExtension = function(name, func) {\\n    Doc.prototype[name] = func;\\n  };\\n  CodeMirror.defineOption = option;\\n\\n  var initHooks = [];\\n  CodeMirror.defineInitHook = function(f) {initHooks.push(f);};\\n\\n  var helpers = CodeMirror.helpers = {};\\n  CodeMirror.registerHelper = function(type, name, value) {\\n    if (!helpers.hasOwnProperty(type)) helpers[type] = CodeMirror[type] = {_global: []};\\n    helpers[type][name] = value;\\n  };\\n  CodeMirror.registerGlobalHelper = function(type, name, predicate, value) {\\n    CodeMirror.registerHelper(type, name, value);\\n    helpers[type]._global.push({pred: predicate, val: value});\\n  };\\n\\n  // MODE STATE HANDLING\\n\\n  // Utility functions for working with state. Exported because nested\\n  // modes need to do this for their inner modes.\\n\\n  var copyState = CodeMirror.copyState = function(mode, state) {\\n    if (state === true) return state;\\n    if (mode.copyState) return mode.copyState(state);\\n    var nstate = {};\\n    for (var n in state) {\\n      var val = state[n];\\n      if (val instanceof Array) val = val.concat([]);\\n      nstate[n] = val;\\n    }\\n    return nstate;\\n  };\\n\\n  var startState = CodeMirror.startState = function(mode, a1, a2) {\\n    return mode.startState ? mode.startState(a1, a2) : true;\\n  };\\n\\n  // Given a mode and a state (for that mode), find the inner mode and\\n  // state at the position that the state refers to.\\n  CodeMirror.innerMode = function(mode, state) {\\n    while (mode.innerMode) {\\n      var info = mode.innerMode(state);\\n      if (!info || info.mode == mode) break;\\n      state = info.state;\\n      mode = info.mode;\\n    }\\n    return info || {mode: mode, state: state};\\n  };\\n\\n  // STANDARD COMMANDS\\n\\n  // Commands are parameter-less actions that can be performed on an\\n  // editor, mostly used for keybindings.\\n  var commands = CodeMirror.commands = {\\n    selectAll: function(cm) {cm.setSelection(Pos(cm.firstLine(), 0), Pos(cm.lastLine()), sel_dontScroll);},\\n    singleSelection: function(cm) {\\n      cm.setSelection(cm.getCursor(\\\"anchor\\\"), cm.getCursor(\\\"head\\\"), sel_dontScroll);\\n    },\\n    killLine: function(cm) {\\n      deleteNearSelection(cm, function(range) {\\n        if (range.empty()) {\\n          var len = getLine(cm.doc, range.head.line).text.length;\\n          if (range.head.ch == len && range.head.line < cm.lastLine())\\n            return {from: range.head, to: Pos(range.head.line + 1, 0)};\\n          else\\n            return {from: range.head, to: Pos(range.head.line, len)};\\n        } else {\\n          return {from: range.from(), to: range.to()};\\n        }\\n      });\\n    },\\n    deleteLine: function(cm) {\\n      deleteNearSelection(cm, function(range) {\\n        return {from: Pos(range.from().line, 0),\\n                to: clipPos(cm.doc, Pos(range.to().line + 1, 0))};\\n      });\\n    },\\n    delLineLeft: function(cm) {\\n      deleteNearSelection(cm, function(range) {\\n        return {from: Pos(range.from().line, 0), to: range.from()};\\n      });\\n    },\\n    delWrappedLineLeft: function(cm) {\\n      deleteNearSelection(cm, function(range) {\\n        var top = cm.charCoords(range.head, \\\"div\\\").top + 5;\\n        var leftPos = cm.coordsChar({left: 0, top: top}, \\\"div\\\");\\n        return {from: leftPos, to: range.from()};\\n      });\\n    },\\n    delWrappedLineRight: function(cm) {\\n      deleteNearSelection(cm, function(range) {\\n        var top = cm.charCoords(range.head, \\\"div\\\").top + 5;\\n        var rightPos = cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, \\\"div\\\");\\n        return {from: range.from(), to: rightPos };\\n      });\\n    },\\n    undo: function(cm) {cm.undo();},\\n    redo: function(cm) {cm.redo();},\\n    undoSelection: function(cm) {cm.undoSelection();},\\n    redoSelection: function(cm) {cm.redoSelection();},\\n    goDocStart: function(cm) {cm.extendSelection(Pos(cm.firstLine(), 0));},\\n    goDocEnd: function(cm) {cm.extendSelection(Pos(cm.lastLine()));},\\n    goLineStart: function(cm) {\\n      cm.extendSelectionsBy(function(range) { return lineStart(cm, range.head.line); },\\n                            {origin: \\\"+move\\\", bias: 1});\\n    },\\n    goLineStartSmart: function(cm) {\\n      cm.extendSelectionsBy(function(range) {\\n        return lineStartSmart(cm, range.head);\\n      }, {origin: \\\"+move\\\", bias: 1});\\n    },\\n    goLineEnd: function(cm) {\\n      cm.extendSelectionsBy(function(range) { return lineEnd(cm, range.head.line); },\\n                            {origin: \\\"+move\\\", bias: -1});\\n    },\\n    goLineRight: function(cm) {\\n      cm.extendSelectionsBy(function(range) {\\n        var top = cm.charCoords(range.head, \\\"div\\\").top + 5;\\n        return cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, \\\"div\\\");\\n      }, sel_move);\\n    },\\n    goLineLeft: function(cm) {\\n      cm.extendSelectionsBy(function(range) {\\n        var top = cm.charCoords(range.head, \\\"div\\\").top + 5;\\n        return cm.coordsChar({left: 0, top: top}, \\\"div\\\");\\n      }, sel_move);\\n    },\\n    goLineLeftSmart: function(cm) {\\n      cm.extendSelectionsBy(function(range) {\\n        var top = cm.charCoords(range.head, \\\"div\\\").top + 5;\\n        var pos = cm.coordsChar({left: 0, top: top}, \\\"div\\\");\\n        if (pos.ch < cm.getLine(pos.line).search(/\\\\S/)) return lineStartSmart(cm, range.head);\\n        return pos;\\n      }, sel_move);\\n    },\\n    goLineUp: function(cm) {cm.moveV(-1, \\\"line\\\");},\\n    goLineDown: function(cm) {cm.moveV(1, \\\"line\\\");},\\n    goPageUp: function(cm) {cm.moveV(-1, \\\"page\\\");},\\n    goPageDown: function(cm) {cm.moveV(1, \\\"page\\\");},\\n    goCharLeft: function(cm) {cm.moveH(-1, \\\"char\\\");},\\n    goCharRight: function(cm) {cm.moveH(1, \\\"char\\\");},\\n    goColumnLeft: function(cm) {cm.moveH(-1, \\\"column\\\");},\\n    goColumnRight: function(cm) {cm.moveH(1, \\\"column\\\");},\\n    goWordLeft: function(cm) {cm.moveH(-1, \\\"word\\\");},\\n    goGroupRight: function(cm) {cm.moveH(1, \\\"group\\\");},\\n    goGroupLeft: function(cm) {cm.moveH(-1, \\\"group\\\");},\\n    goWordRight: function(cm) {cm.moveH(1, \\\"word\\\");},\\n    delCharBefore: function(cm) {cm.deleteH(-1, \\\"char\\\");},\\n    delCharAfter: function(cm) {cm.deleteH(1, \\\"char\\\");},\\n    delWordBefore: function(cm) {cm.deleteH(-1, \\\"word\\\");},\\n    delWordAfter: function(cm) {cm.deleteH(1, \\\"word\\\");},\\n    delGroupBefore: function(cm) {cm.deleteH(-1, \\\"group\\\");},\\n    delGroupAfter: function(cm) {cm.deleteH(1, \\\"group\\\");},\\n    indentAuto: function(cm) {cm.indentSelection(\\\"smart\\\");},\\n    indentMore: function(cm) {cm.indentSelection(\\\"add\\\");},\\n    indentLess: function(cm) {cm.indentSelection(\\\"subtract\\\");},\\n    insertTab: function(cm) {cm.replaceSelection(\\\"\\\\t\\\");},\\n    insertSoftTab: function(cm) {\\n      var spaces = [], ranges = cm.listSelections(), tabSize = cm.options.tabSize;\\n      for (var i = 0; i < ranges.length; i++) {\\n        var pos = ranges[i].from();\\n        var col = countColumn(cm.getLine(pos.line), pos.ch, tabSize);\\n        spaces.push(spaceStr(tabSize - col % tabSize));\\n      }\\n      cm.replaceSelections(spaces);\\n    },\\n    defaultTab: function(cm) {\\n      if (cm.somethingSelected()) cm.indentSelection(\\\"add\\\");\\n      else cm.execCommand(\\\"insertTab\\\");\\n    },\\n    transposeChars: function(cm) {\\n      runInOp(cm, function() {\\n        var ranges = cm.listSelections(), newSel = [];\\n        for (var i = 0; i < ranges.length; i++) {\\n          var cur = ranges[i].head, line = getLine(cm.doc, cur.line).text;\\n          if (line) {\\n            if (cur.ch == line.length) cur = new Pos(cur.line, cur.ch - 1);\\n            if (cur.ch > 0) {\\n              cur = new Pos(cur.line, cur.ch + 1);\\n              cm.replaceRange(line.charAt(cur.ch - 1) + line.charAt(cur.ch - 2),\\n                              Pos(cur.line, cur.ch - 2), cur, \\\"+transpose\\\");\\n            } else if (cur.line > cm.doc.first) {\\n              var prev = getLine(cm.doc, cur.line - 1).text;\\n              if (prev)\\n                cm.replaceRange(line.charAt(0) + cm.doc.lineSeparator() +\\n                                prev.charAt(prev.length - 1),\\n                                Pos(cur.line - 1, prev.length - 1), Pos(cur.line, 1), \\\"+transpose\\\");\\n            }\\n          }\\n          newSel.push(new Range(cur, cur));\\n        }\\n        cm.setSelections(newSel);\\n      });\\n    },\\n    newlineAndIndent: function(cm) {\\n      runInOp(cm, function() {\\n        var len = cm.listSelections().length;\\n        for (var i = 0; i < len; i++) {\\n          var range = cm.listSelections()[i];\\n          cm.replaceRange(cm.doc.lineSeparator(), range.anchor, range.head, \\\"+input\\\");\\n          cm.indentLine(range.from().line + 1, null, true);\\n        }\\n        ensureCursorVisible(cm);\\n      });\\n    },\\n    openLine: function(cm) {cm.replaceSelection(\\\"\\\\n\\\", \\\"start\\\")},\\n    toggleOverwrite: function(cm) {cm.toggleOverwrite();}\\n  };\\n\\n\\n  // STANDARD KEYMAPS\\n\\n  var keyMap = CodeMirror.keyMap = {};\\n\\n  keyMap.basic = {\\n    \\\"Left\\\": \\\"goCharLeft\\\", \\\"Right\\\": \\\"goCharRight\\\", \\\"Up\\\": \\\"goLineUp\\\", \\\"Down\\\": \\\"goLineDown\\\",\\n    \\\"End\\\": \\\"goLineEnd\\\", \\\"Home\\\": \\\"goLineStartSmart\\\", \\\"PageUp\\\": \\\"goPageUp\\\", \\\"PageDown\\\": \\\"goPageDown\\\",\\n    \\\"Delete\\\": \\\"delCharAfter\\\", \\\"Backspace\\\": \\\"delCharBefore\\\", \\\"Shift-Backspace\\\": \\\"delCharBefore\\\",\\n    \\\"Tab\\\": \\\"defaultTab\\\", \\\"Shift-Tab\\\": \\\"indentAuto\\\",\\n    \\\"Enter\\\": \\\"newlineAndIndent\\\", \\\"Insert\\\": \\\"toggleOverwrite\\\",\\n    \\\"Esc\\\": \\\"singleSelection\\\"\\n  };\\n  // Note that the save and find-related commands aren't defined by\\n  // default. User code or addons can define them. Unknown commands\\n  // are simply ignored.\\n  keyMap.pcDefault = {\\n    \\\"Ctrl-A\\\": \\\"selectAll\\\", \\\"Ctrl-D\\\": \\\"deleteLine\\\", \\\"Ctrl-Z\\\": \\\"undo\\\", \\\"Shift-Ctrl-Z\\\": \\\"redo\\\", \\\"Ctrl-Y\\\": \\\"redo\\\",\\n    \\\"Ctrl-Home\\\": \\\"goDocStart\\\", \\\"Ctrl-End\\\": \\\"goDocEnd\\\", \\\"Ctrl-Up\\\": \\\"goLineUp\\\", \\\"Ctrl-Down\\\": \\\"goLineDown\\\",\\n    \\\"Ctrl-Left\\\": \\\"goGroupLeft\\\", \\\"Ctrl-Right\\\": \\\"goGroupRight\\\", \\\"Alt-Left\\\": \\\"goLineStart\\\", \\\"Alt-Right\\\": \\\"goLineEnd\\\",\\n    \\\"Ctrl-Backspace\\\": \\\"delGroupBefore\\\", \\\"Ctrl-Delete\\\": \\\"delGroupAfter\\\", \\\"Ctrl-S\\\": \\\"save\\\", \\\"Ctrl-F\\\": \\\"find\\\",\\n    \\\"Ctrl-G\\\": \\\"findNext\\\", \\\"Shift-Ctrl-G\\\": \\\"findPrev\\\", \\\"Shift-Ctrl-F\\\": \\\"replace\\\", \\\"Shift-Ctrl-R\\\": \\\"replaceAll\\\",\\n    \\\"Ctrl-[\\\": \\\"indentLess\\\", \\\"Ctrl-]\\\": \\\"indentMore\\\",\\n    \\\"Ctrl-U\\\": \\\"undoSelection\\\", \\\"Shift-Ctrl-U\\\": \\\"redoSelection\\\", \\\"Alt-U\\\": \\\"redoSelection\\\",\\n    fallthrough: \\\"basic\\\"\\n  };\\n  // Very basic readline/emacs-style bindings, which are standard on Mac.\\n  keyMap.emacsy = {\\n    \\\"Ctrl-F\\\": \\\"goCharRight\\\", \\\"Ctrl-B\\\": \\\"goCharLeft\\\", \\\"Ctrl-P\\\": \\\"goLineUp\\\", \\\"Ctrl-N\\\": \\\"goLineDown\\\",\\n    \\\"Alt-F\\\": \\\"goWordRight\\\", \\\"Alt-B\\\": \\\"goWordLeft\\\", \\\"Ctrl-A\\\": \\\"goLineStart\\\", \\\"Ctrl-E\\\": \\\"goLineEnd\\\",\\n    \\\"Ctrl-V\\\": \\\"goPageDown\\\", \\\"Shift-Ctrl-V\\\": \\\"goPageUp\\\", \\\"Ctrl-D\\\": \\\"delCharAfter\\\", \\\"Ctrl-H\\\": \\\"delCharBefore\\\",\\n    \\\"Alt-D\\\": \\\"delWordAfter\\\", \\\"Alt-Backspace\\\": \\\"delWordBefore\\\", \\\"Ctrl-K\\\": \\\"killLine\\\", \\\"Ctrl-T\\\": \\\"transposeChars\\\",\\n    \\\"Ctrl-O\\\": \\\"openLine\\\"\\n  };\\n  keyMap.macDefault = {\\n    \\\"Cmd-A\\\": \\\"selectAll\\\", \\\"Cmd-D\\\": \\\"deleteLine\\\", \\\"Cmd-Z\\\": \\\"undo\\\", \\\"Shift-Cmd-Z\\\": \\\"redo\\\", \\\"Cmd-Y\\\": \\\"redo\\\",\\n    \\\"Cmd-Home\\\": \\\"goDocStart\\\", \\\"Cmd-Up\\\": \\\"goDocStart\\\", \\\"Cmd-End\\\": \\\"goDocEnd\\\", \\\"Cmd-Down\\\": \\\"goDocEnd\\\", \\\"Alt-Left\\\": \\\"goGroupLeft\\\",\\n    \\\"Alt-Right\\\": \\\"goGroupRight\\\", \\\"Cmd-Left\\\": \\\"goLineLeft\\\", \\\"Cmd-Right\\\": \\\"goLineRight\\\", \\\"Alt-Backspace\\\": \\\"delGroupBefore\\\",\\n    \\\"Ctrl-Alt-Backspace\\\": \\\"delGroupAfter\\\", \\\"Alt-Delete\\\": \\\"delGroupAfter\\\", \\\"Cmd-S\\\": \\\"save\\\", \\\"Cmd-F\\\": \\\"find\\\",\\n    \\\"Cmd-G\\\": \\\"findNext\\\", \\\"Shift-Cmd-G\\\": \\\"findPrev\\\", \\\"Cmd-Alt-F\\\": \\\"replace\\\", \\\"Shift-Cmd-Alt-F\\\": \\\"replaceAll\\\",\\n    \\\"Cmd-[\\\": \\\"indentLess\\\", \\\"Cmd-]\\\": \\\"indentMore\\\", \\\"Cmd-Backspace\\\": \\\"delWrappedLineLeft\\\", \\\"Cmd-Delete\\\": \\\"delWrappedLineRight\\\",\\n    \\\"Cmd-U\\\": \\\"undoSelection\\\", \\\"Shift-Cmd-U\\\": \\\"redoSelection\\\", \\\"Ctrl-Up\\\": \\\"goDocStart\\\", \\\"Ctrl-Down\\\": \\\"goDocEnd\\\",\\n    fallthrough: [\\\"basic\\\", \\\"emacsy\\\"]\\n  };\\n  keyMap[\\\"default\\\"] = mac ? keyMap.macDefault : keyMap.pcDefault;\\n\\n  // KEYMAP DISPATCH\\n\\n  function normalizeKeyName(name) {\\n    var parts = name.split(/-(?!$)/), name = parts[parts.length - 1];\\n    var alt, ctrl, shift, cmd;\\n    for (var i = 0; i < parts.length - 1; i++) {\\n      var mod = parts[i];\\n      if (/^(cmd|meta|m)$/i.test(mod)) cmd = true;\\n      else if (/^a(lt)?$/i.test(mod)) alt = true;\\n      else if (/^(c|ctrl|control)$/i.test(mod)) ctrl = true;\\n      else if (/^s(hift)$/i.test(mod)) shift = true;\\n      else throw new Error(\\\"Unrecognized modifier name: \\\" + mod);\\n    }\\n    if (alt) name = \\\"Alt-\\\" + name;\\n    if (ctrl) name = \\\"Ctrl-\\\" + name;\\n    if (cmd) name = \\\"Cmd-\\\" + name;\\n    if (shift) name = \\\"Shift-\\\" + name;\\n    return name;\\n  }\\n\\n  // This is a kludge to keep keymaps mostly working as raw objects\\n  // (backwards compatibility) while at the same time support features\\n  // like normalization and multi-stroke key bindings. It compiles a\\n  // new normalized keymap, and then updates the old object to reflect\\n  // this.\\n  CodeMirror.normalizeKeyMap = function(keymap) {\\n    var copy = {};\\n    for (var keyname in keymap) if (keymap.hasOwnProperty(keyname)) {\\n      var value = keymap[keyname];\\n      if (/^(name|fallthrough|(de|at)tach)$/.test(keyname)) continue;\\n      if (value == \\\"...\\\") { delete keymap[keyname]; continue; }\\n\\n      var keys = map(keyname.split(\\\" \\\"), normalizeKeyName);\\n      for (var i = 0; i < keys.length; i++) {\\n        var val, name;\\n        if (i == keys.length - 1) {\\n          name = keys.join(\\\" \\\");\\n          val = value;\\n        } else {\\n          name = keys.slice(0, i + 1).join(\\\" \\\");\\n          val = \\\"...\\\";\\n        }\\n        var prev = copy[name];\\n        if (!prev) copy[name] = val;\\n        else if (prev != val) throw new Error(\\\"Inconsistent bindings for \\\" + name);\\n      }\\n      delete keymap[keyname];\\n    }\\n    for (var prop in copy) keymap[prop] = copy[prop];\\n    return keymap;\\n  };\\n\\n  var lookupKey = CodeMirror.lookupKey = function(key, map, handle, context) {\\n    map = getKeyMap(map);\\n    var found = map.call ? map.call(key, context) : map[key];\\n    if (found === false) return \\\"nothing\\\";\\n    if (found === \\\"...\\\") return \\\"multi\\\";\\n    if (found != null && handle(found)) return \\\"handled\\\";\\n\\n    if (map.fallthrough) {\\n      if (Object.prototype.toString.call(map.fallthrough) != \\\"[object Array]\\\")\\n        return lookupKey(key, map.fallthrough, handle, context);\\n      for (var i = 0; i < map.fallthrough.length; i++) {\\n        var result = lookupKey(key, map.fallthrough[i], handle, context);\\n        if (result) return result;\\n      }\\n    }\\n  };\\n\\n  // Modifier key presses don't count as 'real' key presses for the\\n  // purpose of keymap fallthrough.\\n  var isModifierKey = CodeMirror.isModifierKey = function(value) {\\n    var name = typeof value == \\\"string\\\" ? value : keyNames[value.keyCode];\\n    return name == \\\"Ctrl\\\" || name == \\\"Alt\\\" || name == \\\"Shift\\\" || name == \\\"Mod\\\";\\n  };\\n\\n  // Look up the name of a key as indicated by an event object.\\n  var keyName = CodeMirror.keyName = function(event, noShift) {\\n    if (presto && event.keyCode == 34 && event[\\\"char\\\"]) return false;\\n    var base = keyNames[event.keyCode], name = base;\\n    if (name == null || event.altGraphKey) return false;\\n    if (event.altKey && base != \\\"Alt\\\") name = \\\"Alt-\\\" + name;\\n    if ((flipCtrlCmd ? event.metaKey : event.ctrlKey) && base != \\\"Ctrl\\\") name = \\\"Ctrl-\\\" + name;\\n    if ((flipCtrlCmd ? event.ctrlKey : event.metaKey) && base != \\\"Cmd\\\") name = \\\"Cmd-\\\" + name;\\n    if (!noShift && event.shiftKey && base != \\\"Shift\\\") name = \\\"Shift-\\\" + name;\\n    return name;\\n  };\\n\\n  function getKeyMap(val) {\\n    return typeof val == \\\"string\\\" ? keyMap[val] : val;\\n  }\\n\\n  // FROMTEXTAREA\\n\\n  CodeMirror.fromTextArea = function(textarea, options) {\\n    options = options ? copyObj(options) : {};\\n    options.value = textarea.value;\\n    if (!options.tabindex && textarea.tabIndex)\\n      options.tabindex = textarea.tabIndex;\\n    if (!options.placeholder && textarea.placeholder)\\n      options.placeholder = textarea.placeholder;\\n    // Set autofocus to true if this textarea is focused, or if it has\\n    // autofocus and no other element is focused.\\n    if (options.autofocus == null) {\\n      var hasFocus = activeElt();\\n      options.autofocus = hasFocus == textarea ||\\n        textarea.getAttribute(\\\"autofocus\\\") != null && hasFocus == document.body;\\n    }\\n\\n    function save() {textarea.value = cm.getValue();}\\n    if (textarea.form) {\\n      on(textarea.form, \\\"submit\\\", save);\\n      // Deplorable hack to make the submit method do the right thing.\\n      if (!options.leaveSubmitMethodAlone) {\\n        var form = textarea.form, realSubmit = form.submit;\\n        try {\\n          var wrappedSubmit = form.submit = function() {\\n            save();\\n            form.submit = realSubmit;\\n            form.submit();\\n            form.submit = wrappedSubmit;\\n          };\\n        } catch(e) {}\\n      }\\n    }\\n\\n    options.finishInit = function(cm) {\\n      cm.save = save;\\n      cm.getTextArea = function() { return textarea; };\\n      cm.toTextArea = function() {\\n        cm.toTextArea = isNaN; // Prevent this from being ran twice\\n        save();\\n        textarea.parentNode.removeChild(cm.getWrapperElement());\\n        textarea.style.display = \\\"\\\";\\n        if (textarea.form) {\\n          off(textarea.form, \\\"submit\\\", save);\\n          if (typeof textarea.form.submit == \\\"function\\\")\\n            textarea.form.submit = realSubmit;\\n        }\\n      };\\n    };\\n\\n    textarea.style.display = \\\"none\\\";\\n    var cm = CodeMirror(function(node) {\\n      textarea.parentNode.insertBefore(node, textarea.nextSibling);\\n    }, options);\\n    return cm;\\n  };\\n\\n  // STRING STREAM\\n\\n  // Fed to the mode parsers, provides helper functions to make\\n  // parsers more succinct.\\n\\n  var StringStream = CodeMirror.StringStream = function(string, tabSize) {\\n    this.pos = this.start = 0;\\n    this.string = string;\\n    this.tabSize = tabSize || 8;\\n    this.lastColumnPos = this.lastColumnValue = 0;\\n    this.lineStart = 0;\\n  };\\n\\n  StringStream.prototype = {\\n    eol: function() {return this.pos >= this.string.length;},\\n    sol: function() {return this.pos == this.lineStart;},\\n    peek: function() {return this.string.charAt(this.pos) || undefined;},\\n    next: function() {\\n      if (this.pos < this.string.length)\\n        return this.string.charAt(this.pos++);\\n    },\\n    eat: function(match) {\\n      var ch = this.string.charAt(this.pos);\\n      if (typeof match == \\\"string\\\") var ok = ch == match;\\n      else var ok = ch && (match.test ? match.test(ch) : match(ch));\\n      if (ok) {++this.pos; return ch;}\\n    },\\n    eatWhile: function(match) {\\n      var start = this.pos;\\n      while (this.eat(match)){}\\n      return this.pos > start;\\n    },\\n    eatSpace: function() {\\n      var start = this.pos;\\n      while (/[\\\\s\\\\u00a0]/.test(this.string.charAt(this.pos))) ++this.pos;\\n      return this.pos > start;\\n    },\\n    skipToEnd: function() {this.pos = this.string.length;},\\n    skipTo: function(ch) {\\n      var found = this.string.indexOf(ch, this.pos);\\n      if (found > -1) {this.pos = found; return true;}\\n    },\\n    backUp: function(n) {this.pos -= n;},\\n    column: function() {\\n      if (this.lastColumnPos < this.start) {\\n        this.lastColumnValue = countColumn(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);\\n        this.lastColumnPos = this.start;\\n      }\\n      return this.lastColumnValue - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);\\n    },\\n    indentation: function() {\\n      return countColumn(this.string, null, this.tabSize) -\\n        (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);\\n    },\\n    match: function(pattern, consume, caseInsensitive) {\\n      if (typeof pattern == \\\"string\\\") {\\n        var cased = function(str) {return caseInsensitive ? str.toLowerCase() : str;};\\n        var substr = this.string.substr(this.pos, pattern.length);\\n        if (cased(substr) == cased(pattern)) {\\n          if (consume !== false) this.pos += pattern.length;\\n          return true;\\n        }\\n      } else {\\n        var match = this.string.slice(this.pos).match(pattern);\\n        if (match && match.index > 0) return null;\\n        if (match && consume !== false) this.pos += match[0].length;\\n        return match;\\n      }\\n    },\\n    current: function(){return this.string.slice(this.start, this.pos);},\\n    hideFirstChars: function(n, inner) {\\n      this.lineStart += n;\\n      try { return inner(); }\\n      finally { this.lineStart -= n; }\\n    }\\n  };\\n\\n  // TEXTMARKERS\\n\\n  // Created with markText and setBookmark methods. A TextMarker is a\\n  // handle that can be used to clear or find a marked position in the\\n  // document. Line objects hold arrays (markedSpans) containing\\n  // {from, to, marker} object pointing to such marker objects, and\\n  // indicating that such a marker is present on that line. Multiple\\n  // lines may point to the same marker when it spans across lines.\\n  // The spans will have null for their from/to properties when the\\n  // marker continues beyond the start/end of the line. Markers have\\n  // links back to the lines they currently touch.\\n\\n  var nextMarkerId = 0;\\n\\n  var TextMarker = CodeMirror.TextMarker = function(doc, type) {\\n    this.lines = [];\\n    this.type = type;\\n    this.doc = doc;\\n    this.id = ++nextMarkerId;\\n  };\\n  eventMixin(TextMarker);\\n\\n  // Clear the marker.\\n  TextMarker.prototype.clear = function() {\\n    if (this.explicitlyCleared) return;\\n    var cm = this.doc.cm, withOp = cm && !cm.curOp;\\n    if (withOp) startOperation(cm);\\n    if (hasHandler(this, \\\"clear\\\")) {\\n      var found = this.find();\\n      if (found) signalLater(this, \\\"clear\\\", found.from, found.to);\\n    }\\n    var min = null, max = null;\\n    for (var i = 0; i < this.lines.length; ++i) {\\n      var line = this.lines[i];\\n      var span = getMarkedSpanFor(line.markedSpans, this);\\n      if (cm && !this.collapsed) regLineChange(cm, lineNo(line), \\\"text\\\");\\n      else if (cm) {\\n        if (span.to != null) max = lineNo(line);\\n        if (span.from != null) min = lineNo(line);\\n      }\\n      line.markedSpans = removeMarkedSpan(line.markedSpans, span);\\n      if (span.from == null && this.collapsed && !lineIsHidden(this.doc, line) && cm)\\n        updateLineHeight(line, textHeight(cm.display));\\n    }\\n    if (cm && this.collapsed && !cm.options.lineWrapping) for (var i = 0; i < this.lines.length; ++i) {\\n      var visual = visualLine(this.lines[i]), len = lineLength(visual);\\n      if (len > cm.display.maxLineLength) {\\n        cm.display.maxLine = visual;\\n        cm.display.maxLineLength = len;\\n        cm.display.maxLineChanged = true;\\n      }\\n    }\\n\\n    if (min != null && cm && this.collapsed) regChange(cm, min, max + 1);\\n    this.lines.length = 0;\\n    this.explicitlyCleared = true;\\n    if (this.atomic && this.doc.cantEdit) {\\n      this.doc.cantEdit = false;\\n      if (cm) reCheckSelection(cm.doc);\\n    }\\n    if (cm) signalLater(cm, \\\"markerCleared\\\", cm, this);\\n    if (withOp) endOperation(cm);\\n    if (this.parent) this.parent.clear();\\n  };\\n\\n  // Find the position of the marker in the document. Returns a {from,\\n  // to} object by default. Side can be passed to get a specific side\\n  // -- 0 (both), -1 (left), or 1 (right). When lineObj is true, the\\n  // Pos objects returned contain a line object, rather than a line\\n  // number (used to prevent looking up the same line twice).\\n  TextMarker.prototype.find = function(side, lineObj) {\\n    if (side == null && this.type == \\\"bookmark\\\") side = 1;\\n    var from, to;\\n    for (var i = 0; i < this.lines.length; ++i) {\\n      var line = this.lines[i];\\n      var span = getMarkedSpanFor(line.markedSpans, this);\\n      if (span.from != null) {\\n        from = Pos(lineObj ? line : lineNo(line), span.from);\\n        if (side == -1) return from;\\n      }\\n      if (span.to != null) {\\n        to = Pos(lineObj ? line : lineNo(line), span.to);\\n        if (side == 1) return to;\\n      }\\n    }\\n    return from && {from: from, to: to};\\n  };\\n\\n  // Signals that the marker's widget changed, and surrounding layout\\n  // should be recomputed.\\n  TextMarker.prototype.changed = function() {\\n    var pos = this.find(-1, true), widget = this, cm = this.doc.cm;\\n    if (!pos || !cm) return;\\n    runInOp(cm, function() {\\n      var line = pos.line, lineN = lineNo(pos.line);\\n      var view = findViewForLine(cm, lineN);\\n      if (view) {\\n        clearLineMeasurementCacheFor(view);\\n        cm.curOp.selectionChanged = cm.curOp.forceUpdate = true;\\n      }\\n      cm.curOp.updateMaxLine = true;\\n      if (!lineIsHidden(widget.doc, line) && widget.height != null) {\\n        var oldHeight = widget.height;\\n        widget.height = null;\\n        var dHeight = widgetHeight(widget) - oldHeight;\\n        if (dHeight)\\n          updateLineHeight(line, line.height + dHeight);\\n      }\\n    });\\n  };\\n\\n  TextMarker.prototype.attachLine = function(line) {\\n    if (!this.lines.length && this.doc.cm) {\\n      var op = this.doc.cm.curOp;\\n      if (!op.maybeHiddenMarkers || indexOf(op.maybeHiddenMarkers, this) == -1)\\n        (op.maybeUnhiddenMarkers || (op.maybeUnhiddenMarkers = [])).push(this);\\n    }\\n    this.lines.push(line);\\n  };\\n  TextMarker.prototype.detachLine = function(line) {\\n    this.lines.splice(indexOf(this.lines, line), 1);\\n    if (!this.lines.length && this.doc.cm) {\\n      var op = this.doc.cm.curOp;\\n      (op.maybeHiddenMarkers || (op.maybeHiddenMarkers = [])).push(this);\\n    }\\n  };\\n\\n  // Collapsed markers have unique ids, in order to be able to order\\n  // them, which is needed for uniquely determining an outer marker\\n  // when they overlap (they may nest, but not partially overlap).\\n  var nextMarkerId = 0;\\n\\n  // Create a marker, wire it up to the right lines, and\\n  function markText(doc, from, to, options, type) {\\n    // Shared markers (across linked documents) are handled separately\\n    // (markTextShared will call out to this again, once per\\n    // document).\\n    if (options && options.shared) return markTextShared(doc, from, to, options, type);\\n    // Ensure we are in an operation.\\n    if (doc.cm && !doc.cm.curOp) return operation(doc.cm, markText)(doc, from, to, options, type);\\n\\n    var marker = new TextMarker(doc, type), diff = cmp(from, to);\\n    if (options) copyObj(options, marker, false);\\n    // Don't connect empty markers unless clearWhenEmpty is false\\n    if (diff > 0 || diff == 0 && marker.clearWhenEmpty !== false)\\n      return marker;\\n    if (marker.replacedWith) {\\n      // Showing up as a widget implies collapsed (widget replaces text)\\n      marker.collapsed = true;\\n      marker.widgetNode = elt(\\\"span\\\", [marker.replacedWith], \\\"CodeMirror-widget\\\");\\n      if (!options.handleMouseEvents) marker.widgetNode.setAttribute(\\\"cm-ignore-events\\\", \\\"true\\\");\\n      if (options.insertLeft) marker.widgetNode.insertLeft = true;\\n    }\\n    if (marker.collapsed) {\\n      if (conflictingCollapsedRange(doc, from.line, from, to, marker) ||\\n          from.line != to.line && conflictingCollapsedRange(doc, to.line, from, to, marker))\\n        throw new Error(\\\"Inserting collapsed marker partially overlapping an existing one\\\");\\n      sawCollapsedSpans = true;\\n    }\\n\\n    if (marker.addToHistory)\\n      addChangeToHistory(doc, {from: from, to: to, origin: \\\"markText\\\"}, doc.sel, NaN);\\n\\n    var curLine = from.line, cm = doc.cm, updateMaxLine;\\n    doc.iter(curLine, to.line + 1, function(line) {\\n      if (cm && marker.collapsed && !cm.options.lineWrapping && visualLine(line) == cm.display.maxLine)\\n        updateMaxLine = true;\\n      if (marker.collapsed && curLine != from.line) updateLineHeight(line, 0);\\n      addMarkedSpan(line, new MarkedSpan(marker,\\n                                         curLine == from.line ? from.ch : null,\\n                                         curLine == to.line ? to.ch : null));\\n      ++curLine;\\n    });\\n    // lineIsHidden depends on the presence of the spans, so needs a second pass\\n    if (marker.collapsed) doc.iter(from.line, to.line + 1, function(line) {\\n      if (lineIsHidden(doc, line)) updateLineHeight(line, 0);\\n    });\\n\\n    if (marker.clearOnEnter) on(marker, \\\"beforeCursorEnter\\\", function() { marker.clear(); });\\n\\n    if (marker.readOnly) {\\n      sawReadOnlySpans = true;\\n      if (doc.history.done.length || doc.history.undone.length)\\n        doc.clearHistory();\\n    }\\n    if (marker.collapsed) {\\n      marker.id = ++nextMarkerId;\\n      marker.atomic = true;\\n    }\\n    if (cm) {\\n      // Sync editor state\\n      if (updateMaxLine) cm.curOp.updateMaxLine = true;\\n      if (marker.collapsed)\\n        regChange(cm, from.line, to.line + 1);\\n      else if (marker.className || marker.title || marker.startStyle || marker.endStyle || marker.css)\\n        for (var i = from.line; i <= to.line; i++) regLineChange(cm, i, \\\"text\\\");\\n      if (marker.atomic) reCheckSelection(cm.doc);\\n      signalLater(cm, \\\"markerAdded\\\", cm, marker);\\n    }\\n    return marker;\\n  }\\n\\n  // SHARED TEXTMARKERS\\n\\n  // A shared marker spans multiple linked documents. It is\\n  // implemented as a meta-marker-object controlling multiple normal\\n  // markers.\\n  var SharedTextMarker = CodeMirror.SharedTextMarker = function(markers, primary) {\\n    this.markers = markers;\\n    this.primary = primary;\\n    for (var i = 0; i < markers.length; ++i)\\n      markers[i].parent = this;\\n  };\\n  eventMixin(SharedTextMarker);\\n\\n  SharedTextMarker.prototype.clear = function() {\\n    if (this.explicitlyCleared) return;\\n    this.explicitlyCleared = true;\\n    for (var i = 0; i < this.markers.length; ++i)\\n      this.markers[i].clear();\\n    signalLater(this, \\\"clear\\\");\\n  };\\n  SharedTextMarker.prototype.find = function(side, lineObj) {\\n    return this.primary.find(side, lineObj);\\n  };\\n\\n  function markTextShared(doc, from, to, options, type) {\\n    options = copyObj(options);\\n    options.shared = false;\\n    var markers = [markText(doc, from, to, options, type)], primary = markers[0];\\n    var widget = options.widgetNode;\\n    linkedDocs(doc, function(doc) {\\n      if (widget) options.widgetNode = widget.cloneNode(true);\\n      markers.push(markText(doc, clipPos(doc, from), clipPos(doc, to), options, type));\\n      for (var i = 0; i < doc.linked.length; ++i)\\n        if (doc.linked[i].isParent) return;\\n      primary = lst(markers);\\n    });\\n    return new SharedTextMarker(markers, primary);\\n  }\\n\\n  function findSharedMarkers(doc) {\\n    return doc.findMarks(Pos(doc.first, 0), doc.clipPos(Pos(doc.lastLine())),\\n                         function(m) { return m.parent; });\\n  }\\n\\n  function copySharedMarkers(doc, markers) {\\n    for (var i = 0; i < markers.length; i++) {\\n      var marker = markers[i], pos = marker.find();\\n      var mFrom = doc.clipPos(pos.from), mTo = doc.clipPos(pos.to);\\n      if (cmp(mFrom, mTo)) {\\n        var subMark = markText(doc, mFrom, mTo, marker.primary, marker.primary.type);\\n        marker.markers.push(subMark);\\n        subMark.parent = marker;\\n      }\\n    }\\n  }\\n\\n  function detachSharedMarkers(markers) {\\n    for (var i = 0; i < markers.length; i++) {\\n      var marker = markers[i], linked = [marker.primary.doc];;\\n      linkedDocs(marker.primary.doc, function(d) { linked.push(d); });\\n      for (var j = 0; j < marker.markers.length; j++) {\\n        var subMarker = marker.markers[j];\\n        if (indexOf(linked, subMarker.doc) == -1) {\\n          subMarker.parent = null;\\n          marker.markers.splice(j--, 1);\\n        }\\n      }\\n    }\\n  }\\n\\n  // TEXTMARKER SPANS\\n\\n  function MarkedSpan(marker, from, to) {\\n    this.marker = marker;\\n    this.from = from; this.to = to;\\n  }\\n\\n  // Search an array of spans for a span matching the given marker.\\n  function getMarkedSpanFor(spans, marker) {\\n    if (spans) for (var i = 0; i < spans.length; ++i) {\\n      var span = spans[i];\\n      if (span.marker == marker) return span;\\n    }\\n  }\\n  // Remove a span from an array, returning undefined if no spans are\\n  // left (we don't store arrays for lines without spans).\\n  function removeMarkedSpan(spans, span) {\\n    for (var r, i = 0; i < spans.length; ++i)\\n      if (spans[i] != span) (r || (r = [])).push(spans[i]);\\n    return r;\\n  }\\n  // Add a span to a line.\\n  function addMarkedSpan(line, span) {\\n    line.markedSpans = line.markedSpans ? line.markedSpans.concat([span]) : [span];\\n    span.marker.attachLine(line);\\n  }\\n\\n  // Used for the algorithm that adjusts markers for a change in the\\n  // document. These functions cut an array of spans at a given\\n  // character position, returning an array of remaining chunks (or\\n  // undefined if nothing remains).\\n  function markedSpansBefore(old, startCh, isInsert) {\\n    if (old) for (var i = 0, nw; i < old.length; ++i) {\\n      var span = old[i], marker = span.marker;\\n      var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= startCh : span.from < startCh);\\n      if (startsBefore || span.from == startCh && marker.type == \\\"bookmark\\\" && (!isInsert || !span.marker.insertLeft)) {\\n        var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= startCh : span.to > startCh);\\n        (nw || (nw = [])).push(new MarkedSpan(marker, span.from, endsAfter ? null : span.to));\\n      }\\n    }\\n    return nw;\\n  }\\n  function markedSpansAfter(old, endCh, isInsert) {\\n    if (old) for (var i = 0, nw; i < old.length; ++i) {\\n      var span = old[i], marker = span.marker;\\n      var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= endCh : span.to > endCh);\\n      if (endsAfter || span.from == endCh && marker.type == \\\"bookmark\\\" && (!isInsert || span.marker.insertLeft)) {\\n        var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= endCh : span.from < endCh);\\n        (nw || (nw = [])).push(new MarkedSpan(marker, startsBefore ? null : span.from - endCh,\\n                                              span.to == null ? null : span.to - endCh));\\n      }\\n    }\\n    return nw;\\n  }\\n\\n  // Given a change object, compute the new set of marker spans that\\n  // cover the line in which the change took place. Removes spans\\n  // entirely within the change, reconnects spans belonging to the\\n  // same marker that appear on both sides of the change, and cuts off\\n  // spans partially within the change. Returns an array of span\\n  // arrays with one element for each line in (after) the change.\\n  function stretchSpansOverChange(doc, change) {\\n    if (change.full) return null;\\n    var oldFirst = isLine(doc, change.from.line) && getLine(doc, change.from.line).markedSpans;\\n    var oldLast = isLine(doc, change.to.line) && getLine(doc, change.to.line).markedSpans;\\n    if (!oldFirst && !oldLast) return null;\\n\\n    var startCh = change.from.ch, endCh = change.to.ch, isInsert = cmp(change.from, change.to) == 0;\\n    // Get the spans that 'stick out' on both sides\\n    var first = markedSpansBefore(oldFirst, startCh, isInsert);\\n    var last = markedSpansAfter(oldLast, endCh, isInsert);\\n\\n    // Next, merge those two ends\\n    var sameLine = change.text.length == 1, offset = lst(change.text).length + (sameLine ? startCh : 0);\\n    if (first) {\\n      // Fix up .to properties of first\\n      for (var i = 0; i < first.length; ++i) {\\n        var span = first[i];\\n        if (span.to == null) {\\n          var found = getMarkedSpanFor(last, span.marker);\\n          if (!found) span.to = startCh;\\n          else if (sameLine) span.to = found.to == null ? null : found.to + offset;\\n        }\\n      }\\n    }\\n    if (last) {\\n      // Fix up .from in last (or move them into first in case of sameLine)\\n      for (var i = 0; i < last.length; ++i) {\\n        var span = last[i];\\n        if (span.to != null) span.to += offset;\\n        if (span.from == null) {\\n          var found = getMarkedSpanFor(first, span.marker);\\n          if (!found) {\\n            span.from = offset;\\n            if (sameLine) (first || (first = [])).push(span);\\n          }\\n        } else {\\n          span.from += offset;\\n          if (sameLine) (first || (first = [])).push(span);\\n        }\\n      }\\n    }\\n    // Make sure we didn't create any zero-length spans\\n    if (first) first = clearEmptySpans(first);\\n    if (last && last != first) last = clearEmptySpans(last);\\n\\n    var newMarkers = [first];\\n    if (!sameLine) {\\n      // Fill gap with whole-line-spans\\n      var gap = change.text.length - 2, gapMarkers;\\n      if (gap > 0 && first)\\n        for (var i = 0; i < first.length; ++i)\\n          if (first[i].to == null)\\n            (gapMarkers || (gapMarkers = [])).push(new MarkedSpan(first[i].marker, null, null));\\n      for (var i = 0; i < gap; ++i)\\n        newMarkers.push(gapMarkers);\\n      newMarkers.push(last);\\n    }\\n    return newMarkers;\\n  }\\n\\n  // Remove spans that are empty and don't have a clearWhenEmpty\\n  // option of false.\\n  function clearEmptySpans(spans) {\\n    for (var i = 0; i < spans.length; ++i) {\\n      var span = spans[i];\\n      if (span.from != null && span.from == span.to && span.marker.clearWhenEmpty !== false)\\n        spans.splice(i--, 1);\\n    }\\n    if (!spans.length) return null;\\n    return spans;\\n  }\\n\\n  // Used for un/re-doing changes from the history. Combines the\\n  // result of computing the existing spans with the set of spans that\\n  // existed in the history (so that deleting around a span and then\\n  // undoing brings back the span).\\n  function mergeOldSpans(doc, change) {\\n    var old = getOldSpans(doc, change);\\n    var stretched = stretchSpansOverChange(doc, change);\\n    if (!old) return stretched;\\n    if (!stretched) return old;\\n\\n    for (var i = 0; i < old.length; ++i) {\\n      var oldCur = old[i], stretchCur = stretched[i];\\n      if (oldCur && stretchCur) {\\n        spans: for (var j = 0; j < stretchCur.length; ++j) {\\n          var span = stretchCur[j];\\n          for (var k = 0; k < oldCur.length; ++k)\\n            if (oldCur[k].marker == span.marker) continue spans;\\n          oldCur.push(span);\\n        }\\n      } else if (stretchCur) {\\n        old[i] = stretchCur;\\n      }\\n    }\\n    return old;\\n  }\\n\\n  // Used to 'clip' out readOnly ranges when making a change.\\n  function removeReadOnlyRanges(doc, from, to) {\\n    var markers = null;\\n    doc.iter(from.line, to.line + 1, function(line) {\\n      if (line.markedSpans) for (var i = 0; i < line.markedSpans.length; ++i) {\\n        var mark = line.markedSpans[i].marker;\\n        if (mark.readOnly && (!markers || indexOf(markers, mark) == -1))\\n          (markers || (markers = [])).push(mark);\\n      }\\n    });\\n    if (!markers) return null;\\n    var parts = [{from: from, to: to}];\\n    for (var i = 0; i < markers.length; ++i) {\\n      var mk = markers[i], m = mk.find(0);\\n      for (var j = 0; j < parts.length; ++j) {\\n        var p = parts[j];\\n        if (cmp(p.to, m.from) < 0 || cmp(p.from, m.to) > 0) continue;\\n        var newParts = [j, 1], dfrom = cmp(p.from, m.from), dto = cmp(p.to, m.to);\\n        if (dfrom < 0 || !mk.inclusiveLeft && !dfrom)\\n          newParts.push({from: p.from, to: m.from});\\n        if (dto > 0 || !mk.inclusiveRight && !dto)\\n          newParts.push({from: m.to, to: p.to});\\n        parts.splice.apply(parts, newParts);\\n        j += newParts.length - 1;\\n      }\\n    }\\n    return parts;\\n  }\\n\\n  // Connect or disconnect spans from a line.\\n  function detachMarkedSpans(line) {\\n    var spans = line.markedSpans;\\n    if (!spans) return;\\n    for (var i = 0; i < spans.length; ++i)\\n      spans[i].marker.detachLine(line);\\n    line.markedSpans = null;\\n  }\\n  function attachMarkedSpans(line, spans) {\\n    if (!spans) return;\\n    for (var i = 0; i < spans.length; ++i)\\n      spans[i].marker.attachLine(line);\\n    line.markedSpans = spans;\\n  }\\n\\n  // Helpers used when computing which overlapping collapsed span\\n  // counts as the larger one.\\n  function extraLeft(marker) { return marker.inclusiveLeft ? -1 : 0; }\\n  function extraRight(marker) { return marker.inclusiveRight ? 1 : 0; }\\n\\n  // Returns a number indicating which of two overlapping collapsed\\n  // spans is larger (and thus includes the other). Falls back to\\n  // comparing ids when the spans cover exactly the same range.\\n  function compareCollapsedMarkers(a, b) {\\n    var lenDiff = a.lines.length - b.lines.length;\\n    if (lenDiff != 0) return lenDiff;\\n    var aPos = a.find(), bPos = b.find();\\n    var fromCmp = cmp(aPos.from, bPos.from) || extraLeft(a) - extraLeft(b);\\n    if (fromCmp) return -fromCmp;\\n    var toCmp = cmp(aPos.to, bPos.to) || extraRight(a) - extraRight(b);\\n    if (toCmp) return toCmp;\\n    return b.id - a.id;\\n  }\\n\\n  // Find out whether a line ends or starts in a collapsed span. If\\n  // so, return the marker for that span.\\n  function collapsedSpanAtSide(line, start) {\\n    var sps = sawCollapsedSpans && line.markedSpans, found;\\n    if (sps) for (var sp, i = 0; i < sps.length; ++i) {\\n      sp = sps[i];\\n      if (sp.marker.collapsed && (start ? sp.from : sp.to) == null &&\\n          (!found || compareCollapsedMarkers(found, sp.marker) < 0))\\n        found = sp.marker;\\n    }\\n    return found;\\n  }\\n  function collapsedSpanAtStart(line) { return collapsedSpanAtSide(line, true); }\\n  function collapsedSpanAtEnd(line) { return collapsedSpanAtSide(line, false); }\\n\\n  // Test whether there exists a collapsed span that partially\\n  // overlaps (covers the start or end, but not both) of a new span.\\n  // Such overlap is not allowed.\\n  function conflictingCollapsedRange(doc, lineNo, from, to, marker) {\\n    var line = getLine(doc, lineNo);\\n    var sps = sawCollapsedSpans && line.markedSpans;\\n    if (sps) for (var i = 0; i < sps.length; ++i) {\\n      var sp = sps[i];\\n      if (!sp.marker.collapsed) continue;\\n      var found = sp.marker.find(0);\\n      var fromCmp = cmp(found.from, from) || extraLeft(sp.marker) - extraLeft(marker);\\n      var toCmp = cmp(found.to, to) || extraRight(sp.marker) - extraRight(marker);\\n      if (fromCmp >= 0 && toCmp <= 0 || fromCmp <= 0 && toCmp >= 0) continue;\\n      if (fromCmp <= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.to, from) >= 0 : cmp(found.to, from) > 0) ||\\n          fromCmp >= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.from, to) <= 0 : cmp(found.from, to) < 0))\\n        return true;\\n    }\\n  }\\n\\n  // A visual line is a line as drawn on the screen. Folding, for\\n  // example, can cause multiple logical lines to appear on the same\\n  // visual line. This finds the start of the visual line that the\\n  // given line is part of (usually that is the line itself).\\n  function visualLine(line) {\\n    var merged;\\n    while (merged = collapsedSpanAtStart(line))\\n      line = merged.find(-1, true).line;\\n    return line;\\n  }\\n\\n  // Returns an array of logical lines that continue the visual line\\n  // started by the argument, or undefined if there are no such lines.\\n  function visualLineContinued(line) {\\n    var merged, lines;\\n    while (merged = collapsedSpanAtEnd(line)) {\\n      line = merged.find(1, true).line;\\n      (lines || (lines = [])).push(line);\\n    }\\n    return lines;\\n  }\\n\\n  // Get the line number of the start of the visual line that the\\n  // given line number is part of.\\n  function visualLineNo(doc, lineN) {\\n    var line = getLine(doc, lineN), vis = visualLine(line);\\n    if (line == vis) return lineN;\\n    return lineNo(vis);\\n  }\\n  // Get the line number of the start of the next visual line after\\n  // the given line.\\n  function visualLineEndNo(doc, lineN) {\\n    if (lineN > doc.lastLine()) return lineN;\\n    var line = getLine(doc, lineN), merged;\\n    if (!lineIsHidden(doc, line)) return lineN;\\n    while (merged = collapsedSpanAtEnd(line))\\n      line = merged.find(1, true).line;\\n    return lineNo(line) + 1;\\n  }\\n\\n  // Compute whether a line is hidden. Lines count as hidden when they\\n  // are part of a visual line that starts with another line, or when\\n  // they are entirely covered by collapsed, non-widget span.\\n  function lineIsHidden(doc, line) {\\n    var sps = sawCollapsedSpans && line.markedSpans;\\n    if (sps) for (var sp, i = 0; i < sps.length; ++i) {\\n      sp = sps[i];\\n      if (!sp.marker.collapsed) continue;\\n      if (sp.from == null) return true;\\n      if (sp.marker.widgetNode) continue;\\n      if (sp.from == 0 && sp.marker.inclusiveLeft && lineIsHiddenInner(doc, line, sp))\\n        return true;\\n    }\\n  }\\n  function lineIsHiddenInner(doc, line, span) {\\n    if (span.to == null) {\\n      var end = span.marker.find(1, true);\\n      return lineIsHiddenInner(doc, end.line, getMarkedSpanFor(end.line.markedSpans, span.marker));\\n    }\\n    if (span.marker.inclusiveRight && span.to == line.text.length)\\n      return true;\\n    for (var sp, i = 0; i < line.markedSpans.length; ++i) {\\n      sp = line.markedSpans[i];\\n      if (sp.marker.collapsed && !sp.marker.widgetNode && sp.from == span.to &&\\n          (sp.to == null || sp.to != span.from) &&\\n          (sp.marker.inclusiveLeft || span.marker.inclusiveRight) &&\\n          lineIsHiddenInner(doc, line, sp)) return true;\\n    }\\n  }\\n\\n  // LINE WIDGETS\\n\\n  // Line widgets are block elements displayed above or below a line.\\n\\n  var LineWidget = CodeMirror.LineWidget = function(doc, node, options) {\\n    if (options) for (var opt in options) if (options.hasOwnProperty(opt))\\n      this[opt] = options[opt];\\n    this.doc = doc;\\n    this.node = node;\\n  };\\n  eventMixin(LineWidget);\\n\\n  function adjustScrollWhenAboveVisible(cm, line, diff) {\\n    if (heightAtLine(line) < ((cm.curOp && cm.curOp.scrollTop) || cm.doc.scrollTop))\\n      addToScrollPos(cm, null, diff);\\n  }\\n\\n  LineWidget.prototype.clear = function() {\\n    var cm = this.doc.cm, ws = this.line.widgets, line = this.line, no = lineNo(line);\\n    if (no == null || !ws) return;\\n    for (var i = 0; i < ws.length; ++i) if (ws[i] == this) ws.splice(i--, 1);\\n    if (!ws.length) line.widgets = null;\\n    var height = widgetHeight(this);\\n    updateLineHeight(line, Math.max(0, line.height - height));\\n    if (cm) runInOp(cm, function() {\\n      adjustScrollWhenAboveVisible(cm, line, -height);\\n      regLineChange(cm, no, \\\"widget\\\");\\n    });\\n  };\\n  LineWidget.prototype.changed = function() {\\n    var oldH = this.height, cm = this.doc.cm, line = this.line;\\n    this.height = null;\\n    var diff = widgetHeight(this) - oldH;\\n    if (!diff) return;\\n    updateLineHeight(line, line.height + diff);\\n    if (cm) runInOp(cm, function() {\\n      cm.curOp.forceUpdate = true;\\n      adjustScrollWhenAboveVisible(cm, line, diff);\\n    });\\n  };\\n\\n  function widgetHeight(widget) {\\n    if (widget.height != null) return widget.height;\\n    var cm = widget.doc.cm;\\n    if (!cm) return 0;\\n    if (!contains(document.body, widget.node)) {\\n      var parentStyle = \\\"position: relative;\\\";\\n      if (widget.coverGutter)\\n        parentStyle += \\\"margin-left: -\\\" + cm.display.gutters.offsetWidth + \\\"px;\\\";\\n      if (widget.noHScroll)\\n        parentStyle += \\\"width: \\\" + cm.display.wrapper.clientWidth + \\\"px;\\\";\\n      removeChildrenAndAdd(cm.display.measure, elt(\\\"div\\\", [widget.node], null, parentStyle));\\n    }\\n    return widget.height = widget.node.parentNode.offsetHeight;\\n  }\\n\\n  function addLineWidget(doc, handle, node, options) {\\n    var widget = new LineWidget(doc, node, options);\\n    var cm = doc.cm;\\n    if (cm && widget.noHScroll) cm.display.alignWidgets = true;\\n    changeLine(doc, handle, \\\"widget\\\", function(line) {\\n      var widgets = line.widgets || (line.widgets = []);\\n      if (widget.insertAt == null) widgets.push(widget);\\n      else widgets.splice(Math.min(widgets.length - 1, Math.max(0, widget.insertAt)), 0, widget);\\n      widget.line = line;\\n      if (cm && !lineIsHidden(doc, line)) {\\n        var aboveVisible = heightAtLine(line) < doc.scrollTop;\\n        updateLineHeight(line, line.height + widgetHeight(widget));\\n        if (aboveVisible) addToScrollPos(cm, null, widget.height);\\n        cm.curOp.forceUpdate = true;\\n      }\\n      return true;\\n    });\\n    return widget;\\n  }\\n\\n  // LINE DATA STRUCTURE\\n\\n  // Line objects. These hold state related to a line, including\\n  // highlighting info (the styles array).\\n  var Line = CodeMirror.Line = function(text, markedSpans, estimateHeight) {\\n    this.text = text;\\n    attachMarkedSpans(this, markedSpans);\\n    this.height = estimateHeight ? estimateHeight(this) : 1;\\n  };\\n  eventMixin(Line);\\n  Line.prototype.lineNo = function() { return lineNo(this); };\\n\\n  // Change the content (text, markers) of a line. Automatically\\n  // invalidates cached information and tries to re-estimate the\\n  // line's height.\\n  function updateLine(line, text, markedSpans, estimateHeight) {\\n    line.text = text;\\n    if (line.stateAfter) line.stateAfter = null;\\n    if (line.styles) line.styles = null;\\n    if (line.order != null) line.order = null;\\n    detachMarkedSpans(line);\\n    attachMarkedSpans(line, markedSpans);\\n    var estHeight = estimateHeight ? estimateHeight(line) : 1;\\n    if (estHeight != line.height) updateLineHeight(line, estHeight);\\n  }\\n\\n  // Detach a line from the document tree and its markers.\\n  function cleanUpLine(line) {\\n    line.parent = null;\\n    detachMarkedSpans(line);\\n  }\\n\\n  function extractLineClasses(type, output) {\\n    if (type) for (;;) {\\n      var lineClass = type.match(/(?:^|\\\\s+)line-(background-)?(\\\\S+)/);\\n      if (!lineClass) break;\\n      type = type.slice(0, lineClass.index) + type.slice(lineClass.index + lineClass[0].length);\\n      var prop = lineClass[1] ? \\\"bgClass\\\" : \\\"textClass\\\";\\n      if (output[prop] == null)\\n        output[prop] = lineClass[2];\\n      else if (!(new RegExp(\\\"(?:^|\\\\s)\\\" + lineClass[2] + \\\"(?:$|\\\\s)\\\")).test(output[prop]))\\n        output[prop] += \\\" \\\" + lineClass[2];\\n    }\\n    return type;\\n  }\\n\\n  function callBlankLine(mode, state) {\\n    if (mode.blankLine) return mode.blankLine(state);\\n    if (!mode.innerMode) return;\\n    var inner = CodeMirror.innerMode(mode, state);\\n    if (inner.mode.blankLine) return inner.mode.blankLine(inner.state);\\n  }\\n\\n  function readToken(mode, stream, state, inner) {\\n    for (var i = 0; i < 10; i++) {\\n      if (inner) inner[0] = CodeMirror.innerMode(mode, state).mode;\\n      var style = mode.token(stream, state);\\n      if (stream.pos > stream.start) return style;\\n    }\\n    throw new Error(\\\"Mode \\\" + mode.name + \\\" failed to advance stream.\\\");\\n  }\\n\\n  // Utility for getTokenAt and getLineTokens\\n  function takeToken(cm, pos, precise, asArray) {\\n    function getObj(copy) {\\n      return {start: stream.start, end: stream.pos,\\n              string: stream.current(),\\n              type: style || null,\\n              state: copy ? copyState(doc.mode, state) : state};\\n    }\\n\\n    var doc = cm.doc, mode = doc.mode, style;\\n    pos = clipPos(doc, pos);\\n    var line = getLine(doc, pos.line), state = getStateBefore(cm, pos.line, precise);\\n    var stream = new StringStream(line.text, cm.options.tabSize), tokens;\\n    if (asArray) tokens = [];\\n    while ((asArray || stream.pos < pos.ch) && !stream.eol()) {\\n      stream.start = stream.pos;\\n      style = readToken(mode, stream, state);\\n      if (asArray) tokens.push(getObj(true));\\n    }\\n    return asArray ? tokens : getObj();\\n  }\\n\\n  // Run the given mode's parser over a line, calling f for each token.\\n  function runMode(cm, text, mode, state, f, lineClasses, forceToEnd) {\\n    var flattenSpans = mode.flattenSpans;\\n    if (flattenSpans == null) flattenSpans = cm.options.flattenSpans;\\n    var curStart = 0, curStyle = null;\\n    var stream = new StringStream(text, cm.options.tabSize), style;\\n    var inner = cm.options.addModeClass && [null];\\n    if (text == \\\"\\\") extractLineClasses(callBlankLine(mode, state), lineClasses);\\n    while (!stream.eol()) {\\n      if (stream.pos > cm.options.maxHighlightLength) {\\n        flattenSpans = false;\\n        if (forceToEnd) processLine(cm, text, state, stream.pos);\\n        stream.pos = text.length;\\n        style = null;\\n      } else {\\n        style = extractLineClasses(readToken(mode, stream, state, inner), lineClasses);\\n      }\\n      if (inner) {\\n        var mName = inner[0].name;\\n        if (mName) style = \\\"m-\\\" + (style ? mName + \\\" \\\" + style : mName);\\n      }\\n      if (!flattenSpans || curStyle != style) {\\n        while (curStart < stream.start) {\\n          curStart = Math.min(stream.start, curStart + 5000);\\n          f(curStart, curStyle);\\n        }\\n        curStyle = style;\\n      }\\n      stream.start = stream.pos;\\n    }\\n    while (curStart < stream.pos) {\\n      // Webkit seems to refuse to render text nodes longer than 57444\\n      // characters, and returns inaccurate measurements in nodes\\n      // starting around 5000 chars.\\n      var pos = Math.min(stream.pos, curStart + 5000);\\n      f(pos, curStyle);\\n      curStart = pos;\\n    }\\n  }\\n\\n  // Compute a style array (an array starting with a mode generation\\n  // -- for invalidation -- followed by pairs of end positions and\\n  // style strings), which is used to highlight the tokens on the\\n  // line.\\n  function highlightLine(cm, line, state, forceToEnd) {\\n    // A styles array always starts with a number identifying the\\n    // mode/overlays that it is based on (for easy invalidation).\\n    var st = [cm.state.modeGen], lineClasses = {};\\n    // Compute the base array of styles\\n    runMode(cm, line.text, cm.doc.mode, state, function(end, style) {\\n      st.push(end, style);\\n    }, lineClasses, forceToEnd);\\n\\n    // Run overlays, adjust style array.\\n    for (var o = 0; o < cm.state.overlays.length; ++o) {\\n      var overlay = cm.state.overlays[o], i = 1, at = 0;\\n      runMode(cm, line.text, overlay.mode, true, function(end, style) {\\n        var start = i;\\n        // Ensure there's a token end at the current position, and that i points at it\\n        while (at < end) {\\n          var i_end = st[i];\\n          if (i_end > end)\\n            st.splice(i, 1, end, st[i+1], i_end);\\n          i += 2;\\n          at = Math.min(end, i_end);\\n        }\\n        if (!style) return;\\n        if (overlay.opaque) {\\n          st.splice(start, i - start, end, \\\"cm-overlay \\\" + style);\\n          i = start + 2;\\n        } else {\\n          for (; start < i; start += 2) {\\n            var cur = st[start+1];\\n            st[start+1] = (cur ? cur + \\\" \\\" : \\\"\\\") + \\\"cm-overlay \\\" + style;\\n          }\\n        }\\n      }, lineClasses);\\n    }\\n\\n    return {styles: st, classes: lineClasses.bgClass || lineClasses.textClass ? lineClasses : null};\\n  }\\n\\n  function getLineStyles(cm, line, updateFrontier) {\\n    if (!line.styles || line.styles[0] != cm.state.modeGen) {\\n      var state = getStateBefore(cm, lineNo(line));\\n      var result = highlightLine(cm, line, line.text.length > cm.options.maxHighlightLength ? copyState(cm.doc.mode, state) : state);\\n      line.stateAfter = state;\\n      line.styles = result.styles;\\n      if (result.classes) line.styleClasses = result.classes;\\n      else if (line.styleClasses) line.styleClasses = null;\\n      if (updateFrontier === cm.doc.frontier) cm.doc.frontier++;\\n    }\\n    return line.styles;\\n  }\\n\\n  // Lightweight form of highlight -- proceed over this line and\\n  // update state, but don't save a style array. Used for lines that\\n  // aren't currently visible.\\n  function processLine(cm, text, state, startAt) {\\n    var mode = cm.doc.mode;\\n    var stream = new StringStream(text, cm.options.tabSize);\\n    stream.start = stream.pos = startAt || 0;\\n    if (text == \\\"\\\") callBlankLine(mode, state);\\n    while (!stream.eol()) {\\n      readToken(mode, stream, state);\\n      stream.start = stream.pos;\\n    }\\n  }\\n\\n  // Convert a style as returned by a mode (either null, or a string\\n  // containing one or more styles) to a CSS style. This is cached,\\n  // and also looks for line-wide styles.\\n  var styleToClassCache = {}, styleToClassCacheWithMode = {};\\n  function interpretTokenStyle(style, options) {\\n    if (!style || /^\\\\s*$/.test(style)) return null;\\n    var cache = options.addModeClass ? styleToClassCacheWithMode : styleToClassCache;\\n    return cache[style] ||\\n      (cache[style] = style.replace(/\\\\S+/g, \\\"cm-$&\\\"));\\n  }\\n\\n  // Render the DOM representation of the text of a line. Also builds\\n  // up a 'line map', which points at the DOM nodes that represent\\n  // specific stretches of text, and is used by the measuring code.\\n  // The returned object contains the DOM node, this map, and\\n  // information about line-wide styles that were set by the mode.\\n  function buildLineContent(cm, lineView) {\\n    // The padding-right forces the element to have a 'border', which\\n    // is needed on Webkit to be able to get line-level bounding\\n    // rectangles for it (in measureChar).\\n    var content = elt(\\\"span\\\", null, null, webkit ? \\\"padding-right: .1px\\\" : null);\\n    var builder = {pre: elt(\\\"pre\\\", [content], \\\"CodeMirror-line\\\"), content: content,\\n                   col: 0, pos: 0, cm: cm,\\n                   trailingSpace: false,\\n                   splitSpaces: (ie || webkit) && cm.getOption(\\\"lineWrapping\\\")};\\n    lineView.measure = {};\\n\\n    // Iterate over the logical lines that make up this visual line.\\n    for (var i = 0; i <= (lineView.rest ? lineView.rest.length : 0); i++) {\\n      var line = i ? lineView.rest[i - 1] : lineView.line, order;\\n      builder.pos = 0;\\n      builder.addToken = buildToken;\\n      // Optionally wire in some hacks into the token-rendering\\n      // algorithm, to deal with browser quirks.\\n      if (hasBadBidiRects(cm.display.measure) && (order = getOrder(line)))\\n        builder.addToken = buildTokenBadBidi(builder.addToken, order);\\n      builder.map = [];\\n      var allowFrontierUpdate = lineView != cm.display.externalMeasured && lineNo(line);\\n      insertLineContent(line, builder, getLineStyles(cm, line, allowFrontierUpdate));\\n      if (line.styleClasses) {\\n        if (line.styleClasses.bgClass)\\n          builder.bgClass = joinClasses(line.styleClasses.bgClass, builder.bgClass || \\\"\\\");\\n        if (line.styleClasses.textClass)\\n          builder.textClass = joinClasses(line.styleClasses.textClass, builder.textClass || \\\"\\\");\\n      }\\n\\n      // Ensure at least a single node is present, for measuring.\\n      if (builder.map.length == 0)\\n        builder.map.push(0, 0, builder.content.appendChild(zeroWidthElement(cm.display.measure)));\\n\\n      // Store the map and a cache object for the current logical line\\n      if (i == 0) {\\n        lineView.measure.map = builder.map;\\n        lineView.measure.cache = {};\\n      } else {\\n        (lineView.measure.maps || (lineView.measure.maps = [])).push(builder.map);\\n        (lineView.measure.caches || (lineView.measure.caches = [])).push({});\\n      }\\n    }\\n\\n    // See issue #2901\\n    if (webkit) {\\n      var last = builder.content.lastChild\\n      if (/\\\\bcm-tab\\\\b/.test(last.className) || (last.querySelector && last.querySelector(\\\".cm-tab\\\")))\\n        builder.content.className = \\\"cm-tab-wrap-hack\\\";\\n    }\\n\\n    signal(cm, \\\"renderLine\\\", cm, lineView.line, builder.pre);\\n    if (builder.pre.className)\\n      builder.textClass = joinClasses(builder.pre.className, builder.textClass || \\\"\\\");\\n\\n    return builder;\\n  }\\n\\n  function defaultSpecialCharPlaceholder(ch) {\\n    var token = elt(\\\"span\\\", \\\"\\\\u2022\\\", \\\"cm-invalidchar\\\");\\n    token.title = \\\"\\\\\\\\u\\\" + ch.charCodeAt(0).toString(16);\\n    token.setAttribute(\\\"aria-label\\\", token.title);\\n    return token;\\n  }\\n\\n  // Build up the DOM representation for a single token, and add it to\\n  // the line map. Takes care to render special characters separately.\\n  function buildToken(builder, text, style, startStyle, endStyle, title, css) {\\n    if (!text) return;\\n    var displayText = builder.splitSpaces ? splitSpaces(text, builder.trailingSpace) : text\\n    var special = builder.cm.state.specialChars, mustWrap = false;\\n    if (!special.test(text)) {\\n      builder.col += text.length;\\n      var content = document.createTextNode(displayText);\\n      builder.map.push(builder.pos, builder.pos + text.length, content);\\n      if (ie && ie_version < 9) mustWrap = true;\\n      builder.pos += text.length;\\n    } else {\\n      var content = document.createDocumentFragment(), pos = 0;\\n      while (true) {\\n        special.lastIndex = pos;\\n        var m = special.exec(text);\\n        var skipped = m ? m.index - pos : text.length - pos;\\n        if (skipped) {\\n          var txt = document.createTextNode(displayText.slice(pos, pos + skipped));\\n          if (ie && ie_version < 9) content.appendChild(elt(\\\"span\\\", [txt]));\\n          else content.appendChild(txt);\\n          builder.map.push(builder.pos, builder.pos + skipped, txt);\\n          builder.col += skipped;\\n          builder.pos += skipped;\\n        }\\n        if (!m) break;\\n        pos += skipped + 1;\\n        if (m[0] == \\\"\\\\t\\\") {\\n          var tabSize = builder.cm.options.tabSize, tabWidth = tabSize - builder.col % tabSize;\\n          var txt = content.appendChild(elt(\\\"span\\\", spaceStr(tabWidth), \\\"cm-tab\\\"));\\n          txt.setAttribute(\\\"role\\\", \\\"presentation\\\");\\n          txt.setAttribute(\\\"cm-text\\\", \\\"\\\\t\\\");\\n          builder.col += tabWidth;\\n        } else if (m[0] == \\\"\\\\r\\\" || m[0] == \\\"\\\\n\\\") {\\n          var txt = content.appendChild(elt(\\\"span\\\", m[0] == \\\"\\\\r\\\" ? \\\"\\\\u240d\\\" : \\\"\\\\u2424\\\", \\\"cm-invalidchar\\\"));\\n          txt.setAttribute(\\\"cm-text\\\", m[0]);\\n          builder.col += 1;\\n        } else {\\n          var txt = builder.cm.options.specialCharPlaceholder(m[0]);\\n          txt.setAttribute(\\\"cm-text\\\", m[0]);\\n          if (ie && ie_version < 9) content.appendChild(elt(\\\"span\\\", [txt]));\\n          else content.appendChild(txt);\\n          builder.col += 1;\\n        }\\n        builder.map.push(builder.pos, builder.pos + 1, txt);\\n        builder.pos++;\\n      }\\n    }\\n    builder.trailingSpace = displayText.charCodeAt(text.length - 1) == 32\\n    if (style || startStyle || endStyle || mustWrap || css) {\\n      var fullStyle = style || \\\"\\\";\\n      if (startStyle) fullStyle += startStyle;\\n      if (endStyle) fullStyle += endStyle;\\n      var token = elt(\\\"span\\\", [content], fullStyle, css);\\n      if (title) token.title = title;\\n      return builder.content.appendChild(token);\\n    }\\n    builder.content.appendChild(content);\\n  }\\n\\n  function splitSpaces(text, trailingBefore) {\\n    if (text.length > 1 && !/  /.test(text)) return text\\n    var spaceBefore = trailingBefore, result = \\\"\\\"\\n    for (var i = 0; i < text.length; i++) {\\n      var ch = text.charAt(i)\\n      if (ch == \\\" \\\" && spaceBefore && (i == text.length - 1 || text.charCodeAt(i + 1) == 32))\\n        ch = \\\"\\\\u00a0\\\"\\n      result += ch\\n      spaceBefore = ch == \\\" \\\"\\n    }\\n    return result\\n  }\\n\\n  // Work around nonsense dimensions being reported for stretches of\\n  // right-to-left text.\\n  function buildTokenBadBidi(inner, order) {\\n    return function(builder, text, style, startStyle, endStyle, title, css) {\\n      style = style ? style + \\\" cm-force-border\\\" : \\\"cm-force-border\\\";\\n      var start = builder.pos, end = start + text.length;\\n      for (;;) {\\n        // Find the part that overlaps with the start of this text\\n        for (var i = 0; i < order.length; i++) {\\n          var part = order[i];\\n          if (part.to > start && part.from <= start) break;\\n        }\\n        if (part.to >= end) return inner(builder, text, style, startStyle, endStyle, title, css);\\n        inner(builder, text.slice(0, part.to - start), style, startStyle, null, title, css);\\n        startStyle = null;\\n        text = text.slice(part.to - start);\\n        start = part.to;\\n      }\\n    };\\n  }\\n\\n  function buildCollapsedSpan(builder, size, marker, ignoreWidget) {\\n    var widget = !ignoreWidget && marker.widgetNode;\\n    if (widget) builder.map.push(builder.pos, builder.pos + size, widget);\\n    if (!ignoreWidget && builder.cm.display.input.needsContentAttribute) {\\n      if (!widget)\\n        widget = builder.content.appendChild(document.createElement(\\\"span\\\"));\\n      widget.setAttribute(\\\"cm-marker\\\", marker.id);\\n    }\\n    if (widget) {\\n      builder.cm.display.input.setUneditable(widget);\\n      builder.content.appendChild(widget);\\n    }\\n    builder.pos += size;\\n    builder.trailingSpace = false\\n  }\\n\\n  // Outputs a number of spans to make up a line, taking highlighting\\n  // and marked text into account.\\n  function insertLineContent(line, builder, styles) {\\n    var spans = line.markedSpans, allText = line.text, at = 0;\\n    if (!spans) {\\n      for (var i = 1; i < styles.length; i+=2)\\n        builder.addToken(builder, allText.slice(at, at = styles[i]), interpretTokenStyle(styles[i+1], builder.cm.options));\\n      return;\\n    }\\n\\n    var len = allText.length, pos = 0, i = 1, text = \\\"\\\", style, css;\\n    var nextChange = 0, spanStyle, spanEndStyle, spanStartStyle, title, collapsed;\\n    for (;;) {\\n      if (nextChange == pos) { // Update current marker set\\n        spanStyle = spanEndStyle = spanStartStyle = title = css = \\\"\\\";\\n        collapsed = null; nextChange = Infinity;\\n        var foundBookmarks = [], endStyles\\n        for (var j = 0; j < spans.length; ++j) {\\n          var sp = spans[j], m = sp.marker;\\n          if (m.type == \\\"bookmark\\\" && sp.from == pos && m.widgetNode) {\\n            foundBookmarks.push(m);\\n          } else if (sp.from <= pos && (sp.to == null || sp.to > pos || m.collapsed && sp.to == pos && sp.from == pos)) {\\n            if (sp.to != null && sp.to != pos && nextChange > sp.to) {\\n              nextChange = sp.to;\\n              spanEndStyle = \\\"\\\";\\n            }\\n            if (m.className) spanStyle += \\\" \\\" + m.className;\\n            if (m.css) css = (css ? css + \\\";\\\" : \\\"\\\") + m.css;\\n            if (m.startStyle && sp.from == pos) spanStartStyle += \\\" \\\" + m.startStyle;\\n            if (m.endStyle && sp.to == nextChange) (endStyles || (endStyles = [])).push(m.endStyle, sp.to)\\n            if (m.title && !title) title = m.title;\\n            if (m.collapsed && (!collapsed || compareCollapsedMarkers(collapsed.marker, m) < 0))\\n              collapsed = sp;\\n          } else if (sp.from > pos && nextChange > sp.from) {\\n            nextChange = sp.from;\\n          }\\n        }\\n        if (endStyles) for (var j = 0; j < endStyles.length; j += 2)\\n          if (endStyles[j + 1] == nextChange) spanEndStyle += \\\" \\\" + endStyles[j]\\n\\n        if (!collapsed || collapsed.from == pos) for (var j = 0; j < foundBookmarks.length; ++j)\\n          buildCollapsedSpan(builder, 0, foundBookmarks[j]);\\n        if (collapsed && (collapsed.from || 0) == pos) {\\n          buildCollapsedSpan(builder, (collapsed.to == null ? len + 1 : collapsed.to) - pos,\\n                             collapsed.marker, collapsed.from == null);\\n          if (collapsed.to == null) return;\\n          if (collapsed.to == pos) collapsed = false;\\n        }\\n      }\\n      if (pos >= len) break;\\n\\n      var upto = Math.min(len, nextChange);\\n      while (true) {\\n        if (text) {\\n          var end = pos + text.length;\\n          if (!collapsed) {\\n            var tokenText = end > upto ? text.slice(0, upto - pos) : text;\\n            builder.addToken(builder, tokenText, style ? style + spanStyle : spanStyle,\\n                             spanStartStyle, pos + tokenText.length == nextChange ? spanEndStyle : \\\"\\\", title, css);\\n          }\\n          if (end >= upto) {text = text.slice(upto - pos); pos = upto; break;}\\n          pos = end;\\n          spanStartStyle = \\\"\\\";\\n        }\\n        text = allText.slice(at, at = styles[i++]);\\n        style = interpretTokenStyle(styles[i++], builder.cm.options);\\n      }\\n    }\\n  }\\n\\n  // DOCUMENT DATA STRUCTURE\\n\\n  // By default, updates that start and end at the beginning of a line\\n  // are treated specially, in order to make the association of line\\n  // widgets and marker elements with the text behave more intuitive.\\n  function isWholeLineUpdate(doc, change) {\\n    return change.from.ch == 0 && change.to.ch == 0 && lst(change.text) == \\\"\\\" &&\\n      (!doc.cm || doc.cm.options.wholeLineUpdateBefore);\\n  }\\n\\n  // Perform a change on the document data structure.\\n  function updateDoc(doc, change, markedSpans, estimateHeight) {\\n    function spansFor(n) {return markedSpans ? markedSpans[n] : null;}\\n    function update(line, text, spans) {\\n      updateLine(line, text, spans, estimateHeight);\\n      signalLater(line, \\\"change\\\", line, change);\\n    }\\n    function linesFor(start, end) {\\n      for (var i = start, result = []; i < end; ++i)\\n        result.push(new Line(text[i], spansFor(i), estimateHeight));\\n      return result;\\n    }\\n\\n    var from = change.from, to = change.to, text = change.text;\\n    var firstLine = getLine(doc, from.line), lastLine = getLine(doc, to.line);\\n    var lastText = lst(text), lastSpans = spansFor(text.length - 1), nlines = to.line - from.line;\\n\\n    // Adjust the line structure\\n    if (change.full) {\\n      doc.insert(0, linesFor(0, text.length));\\n      doc.remove(text.length, doc.size - text.length);\\n    } else if (isWholeLineUpdate(doc, change)) {\\n      // This is a whole-line replace. Treated specially to make\\n      // sure line objects move the way they are supposed to.\\n      var added = linesFor(0, text.length - 1);\\n      update(lastLine, lastLine.text, lastSpans);\\n      if (nlines) doc.remove(from.line, nlines);\\n      if (added.length) doc.insert(from.line, added);\\n    } else if (firstLine == lastLine) {\\n      if (text.length == 1) {\\n        update(firstLine, firstLine.text.slice(0, from.ch) + lastText + firstLine.text.slice(to.ch), lastSpans);\\n      } else {\\n        var added = linesFor(1, text.length - 1);\\n        added.push(new Line(lastText + firstLine.text.slice(to.ch), lastSpans, estimateHeight));\\n        update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));\\n        doc.insert(from.line + 1, added);\\n      }\\n    } else if (text.length == 1) {\\n      update(firstLine, firstLine.text.slice(0, from.ch) + text[0] + lastLine.text.slice(to.ch), spansFor(0));\\n      doc.remove(from.line + 1, nlines);\\n    } else {\\n      update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));\\n      update(lastLine, lastText + lastLine.text.slice(to.ch), lastSpans);\\n      var added = linesFor(1, text.length - 1);\\n      if (nlines > 1) doc.remove(from.line + 1, nlines - 1);\\n      doc.insert(from.line + 1, added);\\n    }\\n\\n    signalLater(doc, \\\"change\\\", doc, change);\\n  }\\n\\n  // The document is represented as a BTree consisting of leaves, with\\n  // chunk of lines in them, and branches, with up to ten leaves or\\n  // other branch nodes below them. The top node is always a branch\\n  // node, and is the document object itself (meaning it has\\n  // additional methods and properties).\\n  //\\n  // All nodes have parent links. The tree is used both to go from\\n  // line numbers to line objects, and to go from objects to numbers.\\n  // It also indexes by height, and is used to convert between height\\n  // and line object, and to find the total height of the document.\\n  //\\n  // See also http://marijnhaverbeke.nl/blog/codemirror-line-tree.html\\n\\n  function LeafChunk(lines) {\\n    this.lines = lines;\\n    this.parent = null;\\n    for (var i = 0, height = 0; i < lines.length; ++i) {\\n      lines[i].parent = this;\\n      height += lines[i].height;\\n    }\\n    this.height = height;\\n  }\\n\\n  LeafChunk.prototype = {\\n    chunkSize: function() { return this.lines.length; },\\n    // Remove the n lines at offset 'at'.\\n    removeInner: function(at, n) {\\n      for (var i = at, e = at + n; i < e; ++i) {\\n        var line = this.lines[i];\\n        this.height -= line.height;\\n        cleanUpLine(line);\\n        signalLater(line, \\\"delete\\\");\\n      }\\n      this.lines.splice(at, n);\\n    },\\n    // Helper used to collapse a small branch into a single leaf.\\n    collapse: function(lines) {\\n      lines.push.apply(lines, this.lines);\\n    },\\n    // Insert the given array of lines at offset 'at', count them as\\n    // having the given height.\\n    insertInner: function(at, lines, height) {\\n      this.height += height;\\n      this.lines = this.lines.slice(0, at).concat(lines).concat(this.lines.slice(at));\\n      for (var i = 0; i < lines.length; ++i) lines[i].parent = this;\\n    },\\n    // Used to iterate over a part of the tree.\\n    iterN: function(at, n, op) {\\n      for (var e = at + n; at < e; ++at)\\n        if (op(this.lines[at])) return true;\\n    }\\n  };\\n\\n  function BranchChunk(children) {\\n    this.children = children;\\n    var size = 0, height = 0;\\n    for (var i = 0; i < children.length; ++i) {\\n      var ch = children[i];\\n      size += ch.chunkSize(); height += ch.height;\\n      ch.parent = this;\\n    }\\n    this.size = size;\\n    this.height = height;\\n    this.parent = null;\\n  }\\n\\n  BranchChunk.prototype = {\\n    chunkSize: function() { return this.size; },\\n    removeInner: function(at, n) {\\n      this.size -= n;\\n      for (var i = 0; i < this.children.length; ++i) {\\n        var child = this.children[i], sz = child.chunkSize();\\n        if (at < sz) {\\n          var rm = Math.min(n, sz - at), oldHeight = child.height;\\n          child.removeInner(at, rm);\\n          this.height -= oldHeight - child.height;\\n          if (sz == rm) { this.children.splice(i--, 1); child.parent = null; }\\n          if ((n -= rm) == 0) break;\\n          at = 0;\\n        } else at -= sz;\\n      }\\n      // If the result is smaller than 25 lines, ensure that it is a\\n      // single leaf node.\\n      if (this.size - n < 25 &&\\n          (this.children.length > 1 || !(this.children[0] instanceof LeafChunk))) {\\n        var lines = [];\\n        this.collapse(lines);\\n        this.children = [new LeafChunk(lines)];\\n        this.children[0].parent = this;\\n      }\\n    },\\n    collapse: function(lines) {\\n      for (var i = 0; i < this.children.length; ++i) this.children[i].collapse(lines);\\n    },\\n    insertInner: function(at, lines, height) {\\n      this.size += lines.length;\\n      this.height += height;\\n      for (var i = 0; i < this.children.length; ++i) {\\n        var child = this.children[i], sz = child.chunkSize();\\n        if (at <= sz) {\\n          child.insertInner(at, lines, height);\\n          if (child.lines && child.lines.length > 50) {\\n            // To avoid memory thrashing when child.lines is huge (e.g. first view of a large file), it's never spliced.\\n            // Instead, small slices are taken. They're taken in order because sequential memory accesses are fastest.\\n            var remaining = child.lines.length % 25 + 25\\n            for (var pos = remaining; pos < child.lines.length;) {\\n              var leaf = new LeafChunk(child.lines.slice(pos, pos += 25));\\n              child.height -= leaf.height;\\n              this.children.splice(++i, 0, leaf);\\n              leaf.parent = this;\\n            }\\n            child.lines = child.lines.slice(0, remaining);\\n            this.maybeSpill();\\n          }\\n          break;\\n        }\\n        at -= sz;\\n      }\\n    },\\n    // When a node has grown, check whether it should be split.\\n    maybeSpill: function() {\\n      if (this.children.length <= 10) return;\\n      var me = this;\\n      do {\\n        var spilled = me.children.splice(me.children.length - 5, 5);\\n        var sibling = new BranchChunk(spilled);\\n        if (!me.parent) { // Become the parent node\\n          var copy = new BranchChunk(me.children);\\n          copy.parent = me;\\n          me.children = [copy, sibling];\\n          me = copy;\\n       } else {\\n          me.size -= sibling.size;\\n          me.height -= sibling.height;\\n          var myIndex = indexOf(me.parent.children, me);\\n          me.parent.children.splice(myIndex + 1, 0, sibling);\\n        }\\n        sibling.parent = me.parent;\\n      } while (me.children.length > 10);\\n      me.parent.maybeSpill();\\n    },\\n    iterN: function(at, n, op) {\\n      for (var i = 0; i < this.children.length; ++i) {\\n        var child = this.children[i], sz = child.chunkSize();\\n        if (at < sz) {\\n          var used = Math.min(n, sz - at);\\n          if (child.iterN(at, used, op)) return true;\\n          if ((n -= used) == 0) break;\\n          at = 0;\\n        } else at -= sz;\\n      }\\n    }\\n  };\\n\\n  var nextDocId = 0;\\n  var Doc = CodeMirror.Doc = function(text, mode, firstLine, lineSep) {\\n    if (!(this instanceof Doc)) return new Doc(text, mode, firstLine, lineSep);\\n    if (firstLine == null) firstLine = 0;\\n\\n    BranchChunk.call(this, [new LeafChunk([new Line(\\\"\\\", null)])]);\\n    this.first = firstLine;\\n    this.scrollTop = this.scrollLeft = 0;\\n    this.cantEdit = false;\\n    this.cleanGeneration = 1;\\n    this.frontier = firstLine;\\n    var start = Pos(firstLine, 0);\\n    this.sel = simpleSelection(start);\\n    this.history = new History(null);\\n    this.id = ++nextDocId;\\n    this.modeOption = mode;\\n    this.lineSep = lineSep;\\n    this.extend = false;\\n\\n    if (typeof text == \\\"string\\\") text = this.splitLines(text);\\n    updateDoc(this, {from: start, to: start, text: text});\\n    setSelection(this, simpleSelection(start), sel_dontScroll);\\n  };\\n\\n  Doc.prototype = createObj(BranchChunk.prototype, {\\n    constructor: Doc,\\n    // Iterate over the document. Supports two forms -- with only one\\n    // argument, it calls that for each line in the document. With\\n    // three, it iterates over the range given by the first two (with\\n    // the second being non-inclusive).\\n    iter: function(from, to, op) {\\n      if (op) this.iterN(from - this.first, to - from, op);\\n      else this.iterN(this.first, this.first + this.size, from);\\n    },\\n\\n    // Non-public interface for adding and removing lines.\\n    insert: function(at, lines) {\\n      var height = 0;\\n      for (var i = 0; i < lines.length; ++i) height += lines[i].height;\\n      this.insertInner(at - this.first, lines, height);\\n    },\\n    remove: function(at, n) { this.removeInner(at - this.first, n); },\\n\\n    // From here, the methods are part of the public interface. Most\\n    // are also available from CodeMirror (editor) instances.\\n\\n    getValue: function(lineSep) {\\n      var lines = getLines(this, this.first, this.first + this.size);\\n      if (lineSep === false) return lines;\\n      return lines.join(lineSep || this.lineSeparator());\\n    },\\n    setValue: docMethodOp(function(code) {\\n      var top = Pos(this.first, 0), last = this.first + this.size - 1;\\n      makeChange(this, {from: top, to: Pos(last, getLine(this, last).text.length),\\n                        text: this.splitLines(code), origin: \\\"setValue\\\", full: true}, true);\\n      setSelection(this, simpleSelection(top));\\n    }),\\n    replaceRange: function(code, from, to, origin) {\\n      from = clipPos(this, from);\\n      to = to ? clipPos(this, to) : from;\\n      replaceRange(this, code, from, to, origin);\\n    },\\n    getRange: function(from, to, lineSep) {\\n      var lines = getBetween(this, clipPos(this, from), clipPos(this, to));\\n      if (lineSep === false) return lines;\\n      return lines.join(lineSep || this.lineSeparator());\\n    },\\n\\n    getLine: function(line) {var l = this.getLineHandle(line); return l && l.text;},\\n\\n    getLineHandle: function(line) {if (isLine(this, line)) return getLine(this, line);},\\n    getLineNumber: function(line) {return lineNo(line);},\\n\\n    getLineHandleVisualStart: function(line) {\\n      if (typeof line == \\\"number\\\") line = getLine(this, line);\\n      return visualLine(line);\\n    },\\n\\n    lineCount: function() {return this.size;},\\n    firstLine: function() {return this.first;},\\n    lastLine: function() {return this.first + this.size - 1;},\\n\\n    clipPos: function(pos) {return clipPos(this, pos);},\\n\\n    getCursor: function(start) {\\n      var range = this.sel.primary(), pos;\\n      if (start == null || start == \\\"head\\\") pos = range.head;\\n      else if (start == \\\"anchor\\\") pos = range.anchor;\\n      else if (start == \\\"end\\\" || start == \\\"to\\\" || start === false) pos = range.to();\\n      else pos = range.from();\\n      return pos;\\n    },\\n    listSelections: function() { return this.sel.ranges; },\\n    somethingSelected: function() {return this.sel.somethingSelected();},\\n\\n    setCursor: docMethodOp(function(line, ch, options) {\\n      setSimpleSelection(this, clipPos(this, typeof line == \\\"number\\\" ? Pos(line, ch || 0) : line), null, options);\\n    }),\\n    setSelection: docMethodOp(function(anchor, head, options) {\\n      setSimpleSelection(this, clipPos(this, anchor), clipPos(this, head || anchor), options);\\n    }),\\n    extendSelection: docMethodOp(function(head, other, options) {\\n      extendSelection(this, clipPos(this, head), other && clipPos(this, other), options);\\n    }),\\n    extendSelections: docMethodOp(function(heads, options) {\\n      extendSelections(this, clipPosArray(this, heads), options);\\n    }),\\n    extendSelectionsBy: docMethodOp(function(f, options) {\\n      var heads = map(this.sel.ranges, f);\\n      extendSelections(this, clipPosArray(this, heads), options);\\n    }),\\n    setSelections: docMethodOp(function(ranges, primary, options) {\\n      if (!ranges.length) return;\\n      for (var i = 0, out = []; i < ranges.length; i++)\\n        out[i] = new Range(clipPos(this, ranges[i].anchor),\\n                           clipPos(this, ranges[i].head));\\n      if (primary == null) primary = Math.min(ranges.length - 1, this.sel.primIndex);\\n      setSelection(this, normalizeSelection(out, primary), options);\\n    }),\\n    addSelection: docMethodOp(function(anchor, head, options) {\\n      var ranges = this.sel.ranges.slice(0);\\n      ranges.push(new Range(clipPos(this, anchor), clipPos(this, head || anchor)));\\n      setSelection(this, normalizeSelection(ranges, ranges.length - 1), options);\\n    }),\\n\\n    getSelection: function(lineSep) {\\n      var ranges = this.sel.ranges, lines;\\n      for (var i = 0; i < ranges.length; i++) {\\n        var sel = getBetween(this, ranges[i].from(), ranges[i].to());\\n        lines = lines ? lines.concat(sel) : sel;\\n      }\\n      if (lineSep === false) return lines;\\n      else return lines.join(lineSep || this.lineSeparator());\\n    },\\n    getSelections: function(lineSep) {\\n      var parts = [], ranges = this.sel.ranges;\\n      for (var i = 0; i < ranges.length; i++) {\\n        var sel = getBetween(this, ranges[i].from(), ranges[i].to());\\n        if (lineSep !== false) sel = sel.join(lineSep || this.lineSeparator());\\n        parts[i] = sel;\\n      }\\n      return parts;\\n    },\\n    replaceSelection: function(code, collapse, origin) {\\n      var dup = [];\\n      for (var i = 0; i < this.sel.ranges.length; i++)\\n        dup[i] = code;\\n      this.replaceSelections(dup, collapse, origin || \\\"+input\\\");\\n    },\\n    replaceSelections: docMethodOp(function(code, collapse, origin) {\\n      var changes = [], sel = this.sel;\\n      for (var i = 0; i < sel.ranges.length; i++) {\\n        var range = sel.ranges[i];\\n        changes[i] = {from: range.from(), to: range.to(), text: this.splitLines(code[i]), origin: origin};\\n      }\\n      var newSel = collapse && collapse != \\\"end\\\" && computeReplacedSel(this, changes, collapse);\\n      for (var i = changes.length - 1; i >= 0; i--)\\n        makeChange(this, changes[i]);\\n      if (newSel) setSelectionReplaceHistory(this, newSel);\\n      else if (this.cm) ensureCursorVisible(this.cm);\\n    }),\\n    undo: docMethodOp(function() {makeChangeFromHistory(this, \\\"undo\\\");}),\\n    redo: docMethodOp(function() {makeChangeFromHistory(this, \\\"redo\\\");}),\\n    undoSelection: docMethodOp(function() {makeChangeFromHistory(this, \\\"undo\\\", true);}),\\n    redoSelection: docMethodOp(function() {makeChangeFromHistory(this, \\\"redo\\\", true);}),\\n\\n    setExtending: function(val) {this.extend = val;},\\n    getExtending: function() {return this.extend;},\\n\\n    historySize: function() {\\n      var hist = this.history, done = 0, undone = 0;\\n      for (var i = 0; i < hist.done.length; i++) if (!hist.done[i].ranges) ++done;\\n      for (var i = 0; i < hist.undone.length; i++) if (!hist.undone[i].ranges) ++undone;\\n      return {undo: done, redo: undone};\\n    },\\n    clearHistory: function() {this.history = new History(this.history.maxGeneration);},\\n\\n    markClean: function() {\\n      this.cleanGeneration = this.changeGeneration(true);\\n    },\\n    changeGeneration: function(forceSplit) {\\n      if (forceSplit)\\n        this.history.lastOp = this.history.lastSelOp = this.history.lastOrigin = null;\\n      return this.history.generation;\\n    },\\n    isClean: function (gen) {\\n      return this.history.generation == (gen || this.cleanGeneration);\\n    },\\n\\n    getHistory: function() {\\n      return {done: copyHistoryArray(this.history.done),\\n              undone: copyHistoryArray(this.history.undone)};\\n    },\\n    setHistory: function(histData) {\\n      var hist = this.history = new History(this.history.maxGeneration);\\n      hist.done = copyHistoryArray(histData.done.slice(0), null, true);\\n      hist.undone = copyHistoryArray(histData.undone.slice(0), null, true);\\n    },\\n\\n    addLineClass: docMethodOp(function(handle, where, cls) {\\n      return changeLine(this, handle, where == \\\"gutter\\\" ? \\\"gutter\\\" : \\\"class\\\", function(line) {\\n        var prop = where == \\\"text\\\" ? \\\"textClass\\\"\\n                 : where == \\\"background\\\" ? \\\"bgClass\\\"\\n                 : where == \\\"gutter\\\" ? \\\"gutterClass\\\" : \\\"wrapClass\\\";\\n        if (!line[prop]) line[prop] = cls;\\n        else if (classTest(cls).test(line[prop])) return false;\\n        else line[prop] += \\\" \\\" + cls;\\n        return true;\\n      });\\n    }),\\n    removeLineClass: docMethodOp(function(handle, where, cls) {\\n      return changeLine(this, handle, where == \\\"gutter\\\" ? \\\"gutter\\\" : \\\"class\\\", function(line) {\\n        var prop = where == \\\"text\\\" ? \\\"textClass\\\"\\n                 : where == \\\"background\\\" ? \\\"bgClass\\\"\\n                 : where == \\\"gutter\\\" ? \\\"gutterClass\\\" : \\\"wrapClass\\\";\\n        var cur = line[prop];\\n        if (!cur) return false;\\n        else if (cls == null) line[prop] = null;\\n        else {\\n          var found = cur.match(classTest(cls));\\n          if (!found) return false;\\n          var end = found.index + found[0].length;\\n          line[prop] = cur.slice(0, found.index) + (!found.index || end == cur.length ? \\\"\\\" : \\\" \\\") + cur.slice(end) || null;\\n        }\\n        return true;\\n      });\\n    }),\\n\\n    addLineWidget: docMethodOp(function(handle, node, options) {\\n      return addLineWidget(this, handle, node, options);\\n    }),\\n    removeLineWidget: function(widget) { widget.clear(); },\\n\\n    markText: function(from, to, options) {\\n      return markText(this, clipPos(this, from), clipPos(this, to), options, options && options.type || \\\"range\\\");\\n    },\\n    setBookmark: function(pos, options) {\\n      var realOpts = {replacedWith: options && (options.nodeType == null ? options.widget : options),\\n                      insertLeft: options && options.insertLeft,\\n                      clearWhenEmpty: false, shared: options && options.shared,\\n                      handleMouseEvents: options && options.handleMouseEvents};\\n      pos = clipPos(this, pos);\\n      return markText(this, pos, pos, realOpts, \\\"bookmark\\\");\\n    },\\n    findMarksAt: function(pos) {\\n      pos = clipPos(this, pos);\\n      var markers = [], spans = getLine(this, pos.line).markedSpans;\\n      if (spans) for (var i = 0; i < spans.length; ++i) {\\n        var span = spans[i];\\n        if ((span.from == null || span.from <= pos.ch) &&\\n            (span.to == null || span.to >= pos.ch))\\n          markers.push(span.marker.parent || span.marker);\\n      }\\n      return markers;\\n    },\\n    findMarks: function(from, to, filter) {\\n      from = clipPos(this, from); to = clipPos(this, to);\\n      var found = [], lineNo = from.line;\\n      this.iter(from.line, to.line + 1, function(line) {\\n        var spans = line.markedSpans;\\n        if (spans) for (var i = 0; i < spans.length; i++) {\\n          var span = spans[i];\\n          if (!(span.to != null && lineNo == from.line && from.ch >= span.to ||\\n                span.from == null && lineNo != from.line ||\\n                span.from != null && lineNo == to.line && span.from >= to.ch) &&\\n              (!filter || filter(span.marker)))\\n            found.push(span.marker.parent || span.marker);\\n        }\\n        ++lineNo;\\n      });\\n      return found;\\n    },\\n    getAllMarks: function() {\\n      var markers = [];\\n      this.iter(function(line) {\\n        var sps = line.markedSpans;\\n        if (sps) for (var i = 0; i < sps.length; ++i)\\n          if (sps[i].from != null) markers.push(sps[i].marker);\\n      });\\n      return markers;\\n    },\\n\\n    posFromIndex: function(off) {\\n      var ch, lineNo = this.first, sepSize = this.lineSeparator().length;\\n      this.iter(function(line) {\\n        var sz = line.text.length + sepSize;\\n        if (sz > off) { ch = off; return true; }\\n        off -= sz;\\n        ++lineNo;\\n      });\\n      return clipPos(this, Pos(lineNo, ch));\\n    },\\n    indexFromPos: function (coords) {\\n      coords = clipPos(this, coords);\\n      var index = coords.ch;\\n      if (coords.line < this.first || coords.ch < 0) return 0;\\n      var sepSize = this.lineSeparator().length;\\n      this.iter(this.first, coords.line, function (line) {\\n        index += line.text.length + sepSize;\\n      });\\n      return index;\\n    },\\n\\n    copy: function(copyHistory) {\\n      var doc = new Doc(getLines(this, this.first, this.first + this.size),\\n                        this.modeOption, this.first, this.lineSep);\\n      doc.scrollTop = this.scrollTop; doc.scrollLeft = this.scrollLeft;\\n      doc.sel = this.sel;\\n      doc.extend = false;\\n      if (copyHistory) {\\n        doc.history.undoDepth = this.history.undoDepth;\\n        doc.setHistory(this.getHistory());\\n      }\\n      return doc;\\n    },\\n\\n    linkedDoc: function(options) {\\n      if (!options) options = {};\\n      var from = this.first, to = this.first + this.size;\\n      if (options.from != null && options.from > from) from = options.from;\\n      if (options.to != null && options.to < to) to = options.to;\\n      var copy = new Doc(getLines(this, from, to), options.mode || this.modeOption, from, this.lineSep);\\n      if (options.sharedHist) copy.history = this.history;\\n      (this.linked || (this.linked = [])).push({doc: copy, sharedHist: options.sharedHist});\\n      copy.linked = [{doc: this, isParent: true, sharedHist: options.sharedHist}];\\n      copySharedMarkers(copy, findSharedMarkers(this));\\n      return copy;\\n    },\\n    unlinkDoc: function(other) {\\n      if (other instanceof CodeMirror) other = other.doc;\\n      if (this.linked) for (var i = 0; i < this.linked.length; ++i) {\\n        var link = this.linked[i];\\n        if (link.doc != other) continue;\\n        this.linked.splice(i, 1);\\n        other.unlinkDoc(this);\\n        detachSharedMarkers(findSharedMarkers(this));\\n        break;\\n      }\\n      // If the histories were shared, split them again\\n      if (other.history == this.history) {\\n        var splitIds = [other.id];\\n        linkedDocs(other, function(doc) {splitIds.push(doc.id);}, true);\\n        other.history = new History(null);\\n        other.history.done = copyHistoryArray(this.history.done, splitIds);\\n        other.history.undone = copyHistoryArray(this.history.undone, splitIds);\\n      }\\n    },\\n    iterLinkedDocs: function(f) {linkedDocs(this, f);},\\n\\n    getMode: function() {return this.mode;},\\n    getEditor: function() {return this.cm;},\\n\\n    splitLines: function(str) {\\n      if (this.lineSep) return str.split(this.lineSep);\\n      return splitLinesAuto(str);\\n    },\\n    lineSeparator: function() { return this.lineSep || \\\"\\\\n\\\"; }\\n  });\\n\\n  // Public alias.\\n  Doc.prototype.eachLine = Doc.prototype.iter;\\n\\n  // Set up methods on CodeMirror's prototype to redirect to the editor's document.\\n  var dontDelegate = \\\"iter insert remove copy getEditor constructor\\\".split(\\\" \\\");\\n  for (var prop in Doc.prototype) if (Doc.prototype.hasOwnProperty(prop) && indexOf(dontDelegate, prop) < 0)\\n    CodeMirror.prototype[prop] = (function(method) {\\n      return function() {return method.apply(this.doc, arguments);};\\n    })(Doc.prototype[prop]);\\n\\n  eventMixin(Doc);\\n\\n  // Call f for all linked documents.\\n  function linkedDocs(doc, f, sharedHistOnly) {\\n    function propagate(doc, skip, sharedHist) {\\n      if (doc.linked) for (var i = 0; i < doc.linked.length; ++i) {\\n        var rel = doc.linked[i];\\n        if (rel.doc == skip) continue;\\n        var shared = sharedHist && rel.sharedHist;\\n        if (sharedHistOnly && !shared) continue;\\n        f(rel.doc, shared);\\n        propagate(rel.doc, doc, shared);\\n      }\\n    }\\n    propagate(doc, null, true);\\n  }\\n\\n  // Attach a document to an editor.\\n  function attachDoc(cm, doc) {\\n    if (doc.cm) throw new Error(\\\"This document is already in use.\\\");\\n    cm.doc = doc;\\n    doc.cm = cm;\\n    estimateLineHeights(cm);\\n    loadMode(cm);\\n    if (!cm.options.lineWrapping) findMaxLine(cm);\\n    cm.options.mode = doc.modeOption;\\n    regChange(cm);\\n  }\\n\\n  // LINE UTILITIES\\n\\n  // Find the line object corresponding to the given line number.\\n  function getLine(doc, n) {\\n    n -= doc.first;\\n    if (n < 0 || n >= doc.size) throw new Error(\\\"There is no line \\\" + (n + doc.first) + \\\" in the document.\\\");\\n    for (var chunk = doc; !chunk.lines;) {\\n      for (var i = 0;; ++i) {\\n        var child = chunk.children[i], sz = child.chunkSize();\\n        if (n < sz) { chunk = child; break; }\\n        n -= sz;\\n      }\\n    }\\n    return chunk.lines[n];\\n  }\\n\\n  // Get the part of a document between two positions, as an array of\\n  // strings.\\n  function getBetween(doc, start, end) {\\n    var out = [], n = start.line;\\n    doc.iter(start.line, end.line + 1, function(line) {\\n      var text = line.text;\\n      if (n == end.line) text = text.slice(0, end.ch);\\n      if (n == start.line) text = text.slice(start.ch);\\n      out.push(text);\\n      ++n;\\n    });\\n    return out;\\n  }\\n  // Get the lines between from and to, as array of strings.\\n  function getLines(doc, from, to) {\\n    var out = [];\\n    doc.iter(from, to, function(line) { out.push(line.text); });\\n    return out;\\n  }\\n\\n  // Update the height of a line, propagating the height change\\n  // upwards to parent nodes.\\n  function updateLineHeight(line, height) {\\n    var diff = height - line.height;\\n    if (diff) for (var n = line; n; n = n.parent) n.height += diff;\\n  }\\n\\n  // Given a line object, find its line number by walking up through\\n  // its parent links.\\n  function lineNo(line) {\\n    if (line.parent == null) return null;\\n    var cur = line.parent, no = indexOf(cur.lines, line);\\n    for (var chunk = cur.parent; chunk; cur = chunk, chunk = chunk.parent) {\\n      for (var i = 0;; ++i) {\\n        if (chunk.children[i] == cur) break;\\n        no += chunk.children[i].chunkSize();\\n      }\\n    }\\n    return no + cur.first;\\n  }\\n\\n  // Find the line at the given vertical position, using the height\\n  // information in the document tree.\\n  function lineAtHeight(chunk, h) {\\n    var n = chunk.first;\\n    outer: do {\\n      for (var i = 0; i < chunk.children.length; ++i) {\\n        var child = chunk.children[i], ch = child.height;\\n        if (h < ch) { chunk = child; continue outer; }\\n        h -= ch;\\n        n += child.chunkSize();\\n      }\\n      return n;\\n    } while (!chunk.lines);\\n    for (var i = 0; i < chunk.lines.length; ++i) {\\n      var line = chunk.lines[i], lh = line.height;\\n      if (h < lh) break;\\n      h -= lh;\\n    }\\n    return n + i;\\n  }\\n\\n\\n  // Find the height above the given line.\\n  function heightAtLine(lineObj) {\\n    lineObj = visualLine(lineObj);\\n\\n    var h = 0, chunk = lineObj.parent;\\n    for (var i = 0; i < chunk.lines.length; ++i) {\\n      var line = chunk.lines[i];\\n      if (line == lineObj) break;\\n      else h += line.height;\\n    }\\n    for (var p = chunk.parent; p; chunk = p, p = chunk.parent) {\\n      for (var i = 0; i < p.children.length; ++i) {\\n        var cur = p.children[i];\\n        if (cur == chunk) break;\\n        else h += cur.height;\\n      }\\n    }\\n    return h;\\n  }\\n\\n  // Get the bidi ordering for the given line (and cache it). Returns\\n  // false for lines that are fully left-to-right, and an array of\\n  // BidiSpan objects otherwise.\\n  function getOrder(line) {\\n    var order = line.order;\\n    if (order == null) order = line.order = bidiOrdering(line.text);\\n    return order;\\n  }\\n\\n  // HISTORY\\n\\n  function History(startGen) {\\n    // Arrays of change events and selections. Doing something adds an\\n    // event to done and clears undo. Undoing moves events from done\\n    // to undone, redoing moves them in the other direction.\\n    this.done = []; this.undone = [];\\n    this.undoDepth = Infinity;\\n    // Used to track when changes can be merged into a single undo\\n    // event\\n    this.lastModTime = this.lastSelTime = 0;\\n    this.lastOp = this.lastSelOp = null;\\n    this.lastOrigin = this.lastSelOrigin = null;\\n    // Used by the isClean() method\\n    this.generation = this.maxGeneration = startGen || 1;\\n  }\\n\\n  // Create a history change event from an updateDoc-style change\\n  // object.\\n  function historyChangeFromChange(doc, change) {\\n    var histChange = {from: copyPos(change.from), to: changeEnd(change), text: getBetween(doc, change.from, change.to)};\\n    attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);\\n    linkedDocs(doc, function(doc) {attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);}, true);\\n    return histChange;\\n  }\\n\\n  // Pop all selection events off the end of a history array. Stop at\\n  // a change event.\\n  function clearSelectionEvents(array) {\\n    while (array.length) {\\n      var last = lst(array);\\n      if (last.ranges) array.pop();\\n      else break;\\n    }\\n  }\\n\\n  // Find the top change event in the history. Pop off selection\\n  // events that are in the way.\\n  function lastChangeEvent(hist, force) {\\n    if (force) {\\n      clearSelectionEvents(hist.done);\\n      return lst(hist.done);\\n    } else if (hist.done.length && !lst(hist.done).ranges) {\\n      return lst(hist.done);\\n    } else if (hist.done.length > 1 && !hist.done[hist.done.length - 2].ranges) {\\n      hist.done.pop();\\n      return lst(hist.done);\\n    }\\n  }\\n\\n  // Register a change in the history. Merges changes that are within\\n  // a single operation, or are close together with an origin that\\n  // allows merging (starting with \\\"+\\\") into a single event.\\n  function addChangeToHistory(doc, change, selAfter, opId) {\\n    var hist = doc.history;\\n    hist.undone.length = 0;\\n    var time = +new Date, cur;\\n\\n    if ((hist.lastOp == opId ||\\n         hist.lastOrigin == change.origin && change.origin &&\\n         ((change.origin.charAt(0) == \\\"+\\\" && doc.cm && hist.lastModTime > time - doc.cm.options.historyEventDelay) ||\\n          change.origin.charAt(0) == \\\"*\\\")) &&\\n        (cur = lastChangeEvent(hist, hist.lastOp == opId))) {\\n      // Merge this change into the last event\\n      var last = lst(cur.changes);\\n      if (cmp(change.from, change.to) == 0 && cmp(change.from, last.to) == 0) {\\n        // Optimized case for simple insertion -- don't want to add\\n        // new changesets for every character typed\\n        last.to = changeEnd(change);\\n      } else {\\n        // Add new sub-event\\n        cur.changes.push(historyChangeFromChange(doc, change));\\n      }\\n    } else {\\n      // Can not be merged, start a new event.\\n      var before = lst(hist.done);\\n      if (!before || !before.ranges)\\n        pushSelectionToHistory(doc.sel, hist.done);\\n      cur = {changes: [historyChangeFromChange(doc, change)],\\n             generation: hist.generation};\\n      hist.done.push(cur);\\n      while (hist.done.length > hist.undoDepth) {\\n        hist.done.shift();\\n        if (!hist.done[0].ranges) hist.done.shift();\\n      }\\n    }\\n    hist.done.push(selAfter);\\n    hist.generation = ++hist.maxGeneration;\\n    hist.lastModTime = hist.lastSelTime = time;\\n    hist.lastOp = hist.lastSelOp = opId;\\n    hist.lastOrigin = hist.lastSelOrigin = change.origin;\\n\\n    if (!last) signal(doc, \\\"historyAdded\\\");\\n  }\\n\\n  function selectionEventCanBeMerged(doc, origin, prev, sel) {\\n    var ch = origin.charAt(0);\\n    return ch == \\\"*\\\" ||\\n      ch == \\\"+\\\" &&\\n      prev.ranges.length == sel.ranges.length &&\\n      prev.somethingSelected() == sel.somethingSelected() &&\\n      new Date - doc.history.lastSelTime <= (doc.cm ? doc.cm.options.historyEventDelay : 500);\\n  }\\n\\n  // Called whenever the selection changes, sets the new selection as\\n  // the pending selection in the history, and pushes the old pending\\n  // selection into the 'done' array when it was significantly\\n  // different (in number of selected ranges, emptiness, or time).\\n  function addSelectionToHistory(doc, sel, opId, options) {\\n    var hist = doc.history, origin = options && options.origin;\\n\\n    // A new event is started when the previous origin does not match\\n    // the current, or the origins don't allow matching. Origins\\n    // starting with * are always merged, those starting with + are\\n    // merged when similar and close together in time.\\n    if (opId == hist.lastSelOp ||\\n        (origin && hist.lastSelOrigin == origin &&\\n         (hist.lastModTime == hist.lastSelTime && hist.lastOrigin == origin ||\\n          selectionEventCanBeMerged(doc, origin, lst(hist.done), sel))))\\n      hist.done[hist.done.length - 1] = sel;\\n    else\\n      pushSelectionToHistory(sel, hist.done);\\n\\n    hist.lastSelTime = +new Date;\\n    hist.lastSelOrigin = origin;\\n    hist.lastSelOp = opId;\\n    if (options && options.clearRedo !== false)\\n      clearSelectionEvents(hist.undone);\\n  }\\n\\n  function pushSelectionToHistory(sel, dest) {\\n    var top = lst(dest);\\n    if (!(top && top.ranges && top.equals(sel)))\\n      dest.push(sel);\\n  }\\n\\n  // Used to store marked span information in the history.\\n  function attachLocalSpans(doc, change, from, to) {\\n    var existing = change[\\\"spans_\\\" + doc.id], n = 0;\\n    doc.iter(Math.max(doc.first, from), Math.min(doc.first + doc.size, to), function(line) {\\n      if (line.markedSpans)\\n        (existing || (existing = change[\\\"spans_\\\" + doc.id] = {}))[n] = line.markedSpans;\\n      ++n;\\n    });\\n  }\\n\\n  // When un/re-doing restores text containing marked spans, those\\n  // that have been explicitly cleared should not be restored.\\n  function removeClearedSpans(spans) {\\n    if (!spans) return null;\\n    for (var i = 0, out; i < spans.length; ++i) {\\n      if (spans[i].marker.explicitlyCleared) { if (!out) out = spans.slice(0, i); }\\n      else if (out) out.push(spans[i]);\\n    }\\n    return !out ? spans : out.length ? out : null;\\n  }\\n\\n  // Retrieve and filter the old marked spans stored in a change event.\\n  function getOldSpans(doc, change) {\\n    var found = change[\\\"spans_\\\" + doc.id];\\n    if (!found) return null;\\n    for (var i = 0, nw = []; i < change.text.length; ++i)\\n      nw.push(removeClearedSpans(found[i]));\\n    return nw;\\n  }\\n\\n  // Used both to provide a JSON-safe object in .getHistory, and, when\\n  // detaching a document, to split the history in two\\n  function copyHistoryArray(events, newGroup, instantiateSel) {\\n    for (var i = 0, copy = []; i < events.length; ++i) {\\n      var event = events[i];\\n      if (event.ranges) {\\n        copy.push(instantiateSel ? Selection.prototype.deepCopy.call(event) : event);\\n        continue;\\n      }\\n      var changes = event.changes, newChanges = [];\\n      copy.push({changes: newChanges});\\n      for (var j = 0; j < changes.length; ++j) {\\n        var change = changes[j], m;\\n        newChanges.push({from: change.from, to: change.to, text: change.text});\\n        if (newGroup) for (var prop in change) if (m = prop.match(/^spans_(\\\\d+)$/)) {\\n          if (indexOf(newGroup, Number(m[1])) > -1) {\\n            lst(newChanges)[prop] = change[prop];\\n            delete change[prop];\\n          }\\n        }\\n      }\\n    }\\n    return copy;\\n  }\\n\\n  // Rebasing/resetting history to deal with externally-sourced changes\\n\\n  function rebaseHistSelSingle(pos, from, to, diff) {\\n    if (to < pos.line) {\\n      pos.line += diff;\\n    } else if (from < pos.line) {\\n      pos.line = from;\\n      pos.ch = 0;\\n    }\\n  }\\n\\n  // Tries to rebase an array of history events given a change in the\\n  // document. If the change touches the same lines as the event, the\\n  // event, and everything 'behind' it, is discarded. If the change is\\n  // before the event, the event's positions are updated. Uses a\\n  // copy-on-write scheme for the positions, to avoid having to\\n  // reallocate them all on every rebase, but also avoid problems with\\n  // shared position objects being unsafely updated.\\n  function rebaseHistArray(array, from, to, diff) {\\n    for (var i = 0; i < array.length; ++i) {\\n      var sub = array[i], ok = true;\\n      if (sub.ranges) {\\n        if (!sub.copied) { sub = array[i] = sub.deepCopy(); sub.copied = true; }\\n        for (var j = 0; j < sub.ranges.length; j++) {\\n          rebaseHistSelSingle(sub.ranges[j].anchor, from, to, diff);\\n          rebaseHistSelSingle(sub.ranges[j].head, from, to, diff);\\n        }\\n        continue;\\n      }\\n      for (var j = 0; j < sub.changes.length; ++j) {\\n        var cur = sub.changes[j];\\n        if (to < cur.from.line) {\\n          cur.from = Pos(cur.from.line + diff, cur.from.ch);\\n          cur.to = Pos(cur.to.line + diff, cur.to.ch);\\n        } else if (from <= cur.to.line) {\\n          ok = false;\\n          break;\\n        }\\n      }\\n      if (!ok) {\\n        array.splice(0, i + 1);\\n        i = 0;\\n      }\\n    }\\n  }\\n\\n  function rebaseHist(hist, change) {\\n    var from = change.from.line, to = change.to.line, diff = change.text.length - (to - from) - 1;\\n    rebaseHistArray(hist.done, from, to, diff);\\n    rebaseHistArray(hist.undone, from, to, diff);\\n  }\\n\\n  // EVENT UTILITIES\\n\\n  // Due to the fact that we still support jurassic IE versions, some\\n  // compatibility wrappers are needed.\\n\\n  var e_preventDefault = CodeMirror.e_preventDefault = function(e) {\\n    if (e.preventDefault) e.preventDefault();\\n    else e.returnValue = false;\\n  };\\n  var e_stopPropagation = CodeMirror.e_stopPropagation = function(e) {\\n    if (e.stopPropagation) e.stopPropagation();\\n    else e.cancelBubble = true;\\n  };\\n  function e_defaultPrevented(e) {\\n    return e.defaultPrevented != null ? e.defaultPrevented : e.returnValue == false;\\n  }\\n  var e_stop = CodeMirror.e_stop = function(e) {e_preventDefault(e); e_stopPropagation(e);};\\n\\n  function e_target(e) {return e.target || e.srcElement;}\\n  function e_button(e) {\\n    var b = e.which;\\n    if (b == null) {\\n      if (e.button & 1) b = 1;\\n      else if (e.button & 2) b = 3;\\n      else if (e.button & 4) b = 2;\\n    }\\n    if (mac && e.ctrlKey && b == 1) b = 3;\\n    return b;\\n  }\\n\\n  // EVENT HANDLING\\n\\n  // Lightweight event framework. on/off also work on DOM nodes,\\n  // registering native DOM handlers.\\n\\n  var on = CodeMirror.on = function(emitter, type, f) {\\n    if (emitter.addEventListener)\\n      emitter.addEventListener(type, f, false);\\n    else if (emitter.attachEvent)\\n      emitter.attachEvent(\\\"on\\\" + type, f);\\n    else {\\n      var map = emitter._handlers || (emitter._handlers = {});\\n      var arr = map[type] || (map[type] = []);\\n      arr.push(f);\\n    }\\n  };\\n\\n  var noHandlers = []\\n  function getHandlers(emitter, type, copy) {\\n    var arr = emitter._handlers && emitter._handlers[type]\\n    if (copy) return arr && arr.length > 0 ? arr.slice() : noHandlers\\n    else return arr || noHandlers\\n  }\\n\\n  var off = CodeMirror.off = function(emitter, type, f) {\\n    if (emitter.removeEventListener)\\n      emitter.removeEventListener(type, f, false);\\n    else if (emitter.detachEvent)\\n      emitter.detachEvent(\\\"on\\\" + type, f);\\n    else {\\n      var handlers = getHandlers(emitter, type, false)\\n      for (var i = 0; i < handlers.length; ++i)\\n        if (handlers[i] == f) { handlers.splice(i, 1); break; }\\n    }\\n  };\\n\\n  var signal = CodeMirror.signal = function(emitter, type /*, values...*/) {\\n    var handlers = getHandlers(emitter, type, true)\\n    if (!handlers.length) return;\\n    var args = Array.prototype.slice.call(arguments, 2);\\n    for (var i = 0; i < handlers.length; ++i) handlers[i].apply(null, args);\\n  };\\n\\n  var orphanDelayedCallbacks = null;\\n\\n  // Often, we want to signal events at a point where we are in the\\n  // middle of some work, but don't want the handler to start calling\\n  // other methods on the editor, which might be in an inconsistent\\n  // state or simply not expect any other events to happen.\\n  // signalLater looks whether there are any handlers, and schedules\\n  // them to be executed when the last operation ends, or, if no\\n  // operation is active, when a timeout fires.\\n  function signalLater(emitter, type /*, values...*/) {\\n    var arr = getHandlers(emitter, type, false)\\n    if (!arr.length) return;\\n    var args = Array.prototype.slice.call(arguments, 2), list;\\n    if (operationGroup) {\\n      list = operationGroup.delayedCallbacks;\\n    } else if (orphanDelayedCallbacks) {\\n      list = orphanDelayedCallbacks;\\n    } else {\\n      list = orphanDelayedCallbacks = [];\\n      setTimeout(fireOrphanDelayed, 0);\\n    }\\n    function bnd(f) {return function(){f.apply(null, args);};};\\n    for (var i = 0; i < arr.length; ++i)\\n      list.push(bnd(arr[i]));\\n  }\\n\\n  function fireOrphanDelayed() {\\n    var delayed = orphanDelayedCallbacks;\\n    orphanDelayedCallbacks = null;\\n    for (var i = 0; i < delayed.length; ++i) delayed[i]();\\n  }\\n\\n  // The DOM events that CodeMirror handles can be overridden by\\n  // registering a (non-DOM) handler on the editor for the event name,\\n  // and preventDefault-ing the event in that handler.\\n  function signalDOMEvent(cm, e, override) {\\n    if (typeof e == \\\"string\\\")\\n      e = {type: e, preventDefault: function() { this.defaultPrevented = true; }};\\n    signal(cm, override || e.type, cm, e);\\n    return e_defaultPrevented(e) || e.codemirrorIgnore;\\n  }\\n\\n  function signalCursorActivity(cm) {\\n    var arr = cm._handlers && cm._handlers.cursorActivity;\\n    if (!arr) return;\\n    var set = cm.curOp.cursorActivityHandlers || (cm.curOp.cursorActivityHandlers = []);\\n    for (var i = 0; i < arr.length; ++i) if (indexOf(set, arr[i]) == -1)\\n      set.push(arr[i]);\\n  }\\n\\n  function hasHandler(emitter, type) {\\n    return getHandlers(emitter, type).length > 0\\n  }\\n\\n  // Add on and off methods to a constructor's prototype, to make\\n  // registering events on such objects more convenient.\\n  function eventMixin(ctor) {\\n    ctor.prototype.on = function(type, f) {on(this, type, f);};\\n    ctor.prototype.off = function(type, f) {off(this, type, f);};\\n  }\\n\\n  // MISC UTILITIES\\n\\n  // Number of pixels added to scroller and sizer to hide scrollbar\\n  var scrollerGap = 30;\\n\\n  // Returned or thrown by various protocols to signal 'I'm not\\n  // handling this'.\\n  var Pass = CodeMirror.Pass = {toString: function(){return \\\"CodeMirror.Pass\\\";}};\\n\\n  // Reused option objects for setSelection & friends\\n  var sel_dontScroll = {scroll: false}, sel_mouse = {origin: \\\"*mouse\\\"}, sel_move = {origin: \\\"+move\\\"};\\n\\n  function Delayed() {this.id = null;}\\n  Delayed.prototype.set = function(ms, f) {\\n    clearTimeout(this.id);\\n    this.id = setTimeout(f, ms);\\n  };\\n\\n  // Counts the column offset in a string, taking tabs into account.\\n  // Used mostly to find indentation.\\n  var countColumn = CodeMirror.countColumn = function(string, end, tabSize, startIndex, startValue) {\\n    if (end == null) {\\n      end = string.search(/[^\\\\s\\\\u00a0]/);\\n      if (end == -1) end = string.length;\\n    }\\n    for (var i = startIndex || 0, n = startValue || 0;;) {\\n      var nextTab = string.indexOf(\\\"\\\\t\\\", i);\\n      if (nextTab < 0 || nextTab >= end)\\n        return n + (end - i);\\n      n += nextTab - i;\\n      n += tabSize - (n % tabSize);\\n      i = nextTab + 1;\\n    }\\n  };\\n\\n  // The inverse of countColumn -- find the offset that corresponds to\\n  // a particular column.\\n  var findColumn = CodeMirror.findColumn = function(string, goal, tabSize) {\\n    for (var pos = 0, col = 0;;) {\\n      var nextTab = string.indexOf(\\\"\\\\t\\\", pos);\\n      if (nextTab == -1) nextTab = string.length;\\n      var skipped = nextTab - pos;\\n      if (nextTab == string.length || col + skipped >= goal)\\n        return pos + Math.min(skipped, goal - col);\\n      col += nextTab - pos;\\n      col += tabSize - (col % tabSize);\\n      pos = nextTab + 1;\\n      if (col >= goal) return pos;\\n    }\\n  }\\n\\n  var spaceStrs = [\\\"\\\"];\\n  function spaceStr(n) {\\n    while (spaceStrs.length <= n)\\n      spaceStrs.push(lst(spaceStrs) + \\\" \\\");\\n    return spaceStrs[n];\\n  }\\n\\n  function lst(arr) { return arr[arr.length-1]; }\\n\\n  var selectInput = function(node) { node.select(); };\\n  if (ios) // Mobile Safari apparently has a bug where select() is broken.\\n    selectInput = function(node) { node.selectionStart = 0; node.selectionEnd = node.value.length; };\\n  else if (ie) // Suppress mysterious IE10 errors\\n    selectInput = function(node) { try { node.select(); } catch(_e) {} };\\n\\n  function indexOf(array, elt) {\\n    for (var i = 0; i < array.length; ++i)\\n      if (array[i] == elt) return i;\\n    return -1;\\n  }\\n  function map(array, f) {\\n    var out = [];\\n    for (var i = 0; i < array.length; i++) out[i] = f(array[i], i);\\n    return out;\\n  }\\n\\n  function insertSorted(array, value, score) {\\n    var pos = 0, priority = score(value)\\n    while (pos < array.length && score(array[pos]) <= priority) pos++\\n    array.splice(pos, 0, value)\\n  }\\n\\n  function nothing() {}\\n\\n  function createObj(base, props) {\\n    var inst;\\n    if (Object.create) {\\n      inst = Object.create(base);\\n    } else {\\n      nothing.prototype = base;\\n      inst = new nothing();\\n    }\\n    if (props) copyObj(props, inst);\\n    return inst;\\n  };\\n\\n  function copyObj(obj, target, overwrite) {\\n    if (!target) target = {};\\n    for (var prop in obj)\\n      if (obj.hasOwnProperty(prop) && (overwrite !== false || !target.hasOwnProperty(prop)))\\n        target[prop] = obj[prop];\\n    return target;\\n  }\\n\\n  function bind(f) {\\n    var args = Array.prototype.slice.call(arguments, 1);\\n    return function(){return f.apply(null, args);};\\n  }\\n\\n  var nonASCIISingleCaseWordChar = /[\\\\u00df\\\\u0587\\\\u0590-\\\\u05f4\\\\u0600-\\\\u06ff\\\\u3040-\\\\u309f\\\\u30a0-\\\\u30ff\\\\u3400-\\\\u4db5\\\\u4e00-\\\\u9fcc\\\\uac00-\\\\ud7af]/;\\n  var isWordCharBasic = CodeMirror.isWordChar = function(ch) {\\n    return /\\\\w/.test(ch) || ch > \\\"\\\\x80\\\" &&\\n      (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch));\\n  };\\n  function isWordChar(ch, helper) {\\n    if (!helper) return isWordCharBasic(ch);\\n    if (helper.source.indexOf(\\\"\\\\\\\\w\\\") > -1 && isWordCharBasic(ch)) return true;\\n    return helper.test(ch);\\n  }\\n\\n  function isEmpty(obj) {\\n    for (var n in obj) if (obj.hasOwnProperty(n) && obj[n]) return false;\\n    return true;\\n  }\\n\\n  // Extending unicode characters. A series of a non-extending char +\\n  // any number of extending chars is treated as a single unit as far\\n  // as editing and measuring is concerned. This is not fully correct,\\n  // since some scripts/fonts/browsers also treat other configurations\\n  // of code points as a group.\\n  var extendingChars = /[\\\\u0300-\\\\u036f\\\\u0483-\\\\u0489\\\\u0591-\\\\u05bd\\\\u05bf\\\\u05c1\\\\u05c2\\\\u05c4\\\\u05c5\\\\u05c7\\\\u0610-\\\\u061a\\\\u064b-\\\\u065e\\\\u0670\\\\u06d6-\\\\u06dc\\\\u06de-\\\\u06e4\\\\u06e7\\\\u06e8\\\\u06ea-\\\\u06ed\\\\u0711\\\\u0730-\\\\u074a\\\\u07a6-\\\\u07b0\\\\u07eb-\\\\u07f3\\\\u0816-\\\\u0819\\\\u081b-\\\\u0823\\\\u0825-\\\\u0827\\\\u0829-\\\\u082d\\\\u0900-\\\\u0902\\\\u093c\\\\u0941-\\\\u0948\\\\u094d\\\\u0951-\\\\u0955\\\\u0962\\\\u0963\\\\u0981\\\\u09bc\\\\u09be\\\\u09c1-\\\\u09c4\\\\u09cd\\\\u09d7\\\\u09e2\\\\u09e3\\\\u0a01\\\\u0a02\\\\u0a3c\\\\u0a41\\\\u0a42\\\\u0a47\\\\u0a48\\\\u0a4b-\\\\u0a4d\\\\u0a51\\\\u0a70\\\\u0a71\\\\u0a75\\\\u0a81\\\\u0a82\\\\u0abc\\\\u0ac1-\\\\u0ac5\\\\u0ac7\\\\u0ac8\\\\u0acd\\\\u0ae2\\\\u0ae3\\\\u0b01\\\\u0b3c\\\\u0b3e\\\\u0b3f\\\\u0b41-\\\\u0b44\\\\u0b4d\\\\u0b56\\\\u0b57\\\\u0b62\\\\u0b63\\\\u0b82\\\\u0bbe\\\\u0bc0\\\\u0bcd\\\\u0bd7\\\\u0c3e-\\\\u0c40\\\\u0c46-\\\\u0c48\\\\u0c4a-\\\\u0c4d\\\\u0c55\\\\u0c56\\\\u0c62\\\\u0c63\\\\u0cbc\\\\u0cbf\\\\u0cc2\\\\u0cc6\\\\u0ccc\\\\u0ccd\\\\u0cd5\\\\u0cd6\\\\u0ce2\\\\u0ce3\\\\u0d3e\\\\u0d41-\\\\u0d44\\\\u0d4d\\\\u0d57\\\\u0d62\\\\u0d63\\\\u0dca\\\\u0dcf\\\\u0dd2-\\\\u0dd4\\\\u0dd6\\\\u0ddf\\\\u0e31\\\\u0e34-\\\\u0e3a\\\\u0e47-\\\\u0e4e\\\\u0eb1\\\\u0eb4-\\\\u0eb9\\\\u0ebb\\\\u0ebc\\\\u0ec8-\\\\u0ecd\\\\u0f18\\\\u0f19\\\\u0f35\\\\u0f37\\\\u0f39\\\\u0f71-\\\\u0f7e\\\\u0f80-\\\\u0f84\\\\u0f86\\\\u0f87\\\\u0f90-\\\\u0f97\\\\u0f99-\\\\u0fbc\\\\u0fc6\\\\u102d-\\\\u1030\\\\u1032-\\\\u1037\\\\u1039\\\\u103a\\\\u103d\\\\u103e\\\\u1058\\\\u1059\\\\u105e-\\\\u1060\\\\u1071-\\\\u1074\\\\u1082\\\\u1085\\\\u1086\\\\u108d\\\\u109d\\\\u135f\\\\u1712-\\\\u1714\\\\u1732-\\\\u1734\\\\u1752\\\\u1753\\\\u1772\\\\u1773\\\\u17b7-\\\\u17bd\\\\u17c6\\\\u17c9-\\\\u17d3\\\\u17dd\\\\u180b-\\\\u180d\\\\u18a9\\\\u1920-\\\\u1922\\\\u1927\\\\u1928\\\\u1932\\\\u1939-\\\\u193b\\\\u1a17\\\\u1a18\\\\u1a56\\\\u1a58-\\\\u1a5e\\\\u1a60\\\\u1a62\\\\u1a65-\\\\u1a6c\\\\u1a73-\\\\u1a7c\\\\u1a7f\\\\u1b00-\\\\u1b03\\\\u1b34\\\\u1b36-\\\\u1b3a\\\\u1b3c\\\\u1b42\\\\u1b6b-\\\\u1b73\\\\u1b80\\\\u1b81\\\\u1ba2-\\\\u1ba5\\\\u1ba8\\\\u1ba9\\\\u1c2c-\\\\u1c33\\\\u1c36\\\\u1c37\\\\u1cd0-\\\\u1cd2\\\\u1cd4-\\\\u1ce0\\\\u1ce2-\\\\u1ce8\\\\u1ced\\\\u1dc0-\\\\u1de6\\\\u1dfd-\\\\u1dff\\\\u200c\\\\u200d\\\\u20d0-\\\\u20f0\\\\u2cef-\\\\u2cf1\\\\u2de0-\\\\u2dff\\\\u302a-\\\\u302f\\\\u3099\\\\u309a\\\\ua66f-\\\\ua672\\\\ua67c\\\\ua67d\\\\ua6f0\\\\ua6f1\\\\ua802\\\\ua806\\\\ua80b\\\\ua825\\\\ua826\\\\ua8c4\\\\ua8e0-\\\\ua8f1\\\\ua926-\\\\ua92d\\\\ua947-\\\\ua951\\\\ua980-\\\\ua982\\\\ua9b3\\\\ua9b6-\\\\ua9b9\\\\ua9bc\\\\uaa29-\\\\uaa2e\\\\uaa31\\\\uaa32\\\\uaa35\\\\uaa36\\\\uaa43\\\\uaa4c\\\\uaab0\\\\uaab2-\\\\uaab4\\\\uaab7\\\\uaab8\\\\uaabe\\\\uaabf\\\\uaac1\\\\uabe5\\\\uabe8\\\\uabed\\\\udc00-\\\\udfff\\\\ufb1e\\\\ufe00-\\\\ufe0f\\\\ufe20-\\\\ufe26\\\\uff9e\\\\uff9f]/;\\n  function isExtendingChar(ch) { return ch.charCodeAt(0) >= 768 && extendingChars.test(ch); }\\n\\n  // DOM UTILITIES\\n\\n  function elt(tag, content, className, style) {\\n    var e = document.createElement(tag);\\n    if (className) e.className = className;\\n    if (style) e.style.cssText = style;\\n    if (typeof content == \\\"string\\\") e.appendChild(document.createTextNode(content));\\n    else if (content) for (var i = 0; i < content.length; ++i) e.appendChild(content[i]);\\n    return e;\\n  }\\n\\n  var range;\\n  if (document.createRange) range = function(node, start, end, endNode) {\\n    var r = document.createRange();\\n    r.setEnd(endNode || node, end);\\n    r.setStart(node, start);\\n    return r;\\n  };\\n  else range = function(node, start, end) {\\n    var r = document.body.createTextRange();\\n    try { r.moveToElementText(node.parentNode); }\\n    catch(e) { return r; }\\n    r.collapse(true);\\n    r.moveEnd(\\\"character\\\", end);\\n    r.moveStart(\\\"character\\\", start);\\n    return r;\\n  };\\n\\n  function removeChildren(e) {\\n    for (var count = e.childNodes.length; count > 0; --count)\\n      e.removeChild(e.firstChild);\\n    return e;\\n  }\\n\\n  function removeChildrenAndAdd(parent, e) {\\n    return removeChildren(parent).appendChild(e);\\n  }\\n\\n  var contains = CodeMirror.contains = function(parent, child) {\\n    if (child.nodeType == 3) // Android browser always returns false when child is a textnode\\n      child = child.parentNode;\\n    if (parent.contains)\\n      return parent.contains(child);\\n    do {\\n      if (child.nodeType == 11) child = child.host;\\n      if (child == parent) return true;\\n    } while (child = child.parentNode);\\n  };\\n\\n  function activeElt() {\\n    var activeElement = document.activeElement;\\n    while (activeElement && activeElement.root && activeElement.root.activeElement)\\n      activeElement = activeElement.root.activeElement;\\n    return activeElement;\\n  }\\n  // Older versions of IE throws unspecified error when touching\\n  // document.activeElement in some cases (during loading, in iframe)\\n  if (ie && ie_version < 11) activeElt = function() {\\n    try { return document.activeElement; }\\n    catch(e) { return document.body; }\\n  };\\n\\n  function classTest(cls) { return new RegExp(\\\"(^|\\\\\\\\s)\\\" + cls + \\\"(?:$|\\\\\\\\s)\\\\\\\\s*\\\"); }\\n  var rmClass = CodeMirror.rmClass = function(node, cls) {\\n    var current = node.className;\\n    var match = classTest(cls).exec(current);\\n    if (match) {\\n      var after = current.slice(match.index + match[0].length);\\n      node.className = current.slice(0, match.index) + (after ? match[1] + after : \\\"\\\");\\n    }\\n  };\\n  var addClass = CodeMirror.addClass = function(node, cls) {\\n    var current = node.className;\\n    if (!classTest(cls).test(current)) node.className += (current ? \\\" \\\" : \\\"\\\") + cls;\\n  };\\n  function joinClasses(a, b) {\\n    var as = a.split(\\\" \\\");\\n    for (var i = 0; i < as.length; i++)\\n      if (as[i] && !classTest(as[i]).test(b)) b += \\\" \\\" + as[i];\\n    return b;\\n  }\\n\\n  // WINDOW-WIDE EVENTS\\n\\n  // These must be handled carefully, because naively registering a\\n  // handler for each editor will cause the editors to never be\\n  // garbage collected.\\n\\n  function forEachCodeMirror(f) {\\n    if (!document.body.getElementsByClassName) return;\\n    var byClass = document.body.getElementsByClassName(\\\"CodeMirror\\\");\\n    for (var i = 0; i < byClass.length; i++) {\\n      var cm = byClass[i].CodeMirror;\\n      if (cm) f(cm);\\n    }\\n  }\\n\\n  var globalsRegistered = false;\\n  function ensureGlobalHandlers() {\\n    if (globalsRegistered) return;\\n    registerGlobalHandlers();\\n    globalsRegistered = true;\\n  }\\n  function registerGlobalHandlers() {\\n    // When the window resizes, we need to refresh active editors.\\n    var resizeTimer;\\n    on(window, \\\"resize\\\", function() {\\n      if (resizeTimer == null) resizeTimer = setTimeout(function() {\\n        resizeTimer = null;\\n        forEachCodeMirror(onResize);\\n      }, 100);\\n    });\\n    // When the window loses focus, we want to show the editor as blurred\\n    on(window, \\\"blur\\\", function() {\\n      forEachCodeMirror(onBlur);\\n    });\\n  }\\n\\n  // FEATURE DETECTION\\n\\n  // Detect drag-and-drop\\n  var dragAndDrop = function() {\\n    // There is *some* kind of drag-and-drop support in IE6-8, but I\\n    // couldn't get it to work yet.\\n    if (ie && ie_version < 9) return false;\\n    var div = elt('div');\\n    return \\\"draggable\\\" in div || \\\"dragDrop\\\" in div;\\n  }();\\n\\n  var zwspSupported;\\n  function zeroWidthElement(measure) {\\n    if (zwspSupported == null) {\\n      var test = elt(\\\"span\\\", \\\"\\\\u200b\\\");\\n      removeChildrenAndAdd(measure, elt(\\\"span\\\", [test, document.createTextNode(\\\"x\\\")]));\\n      if (measure.firstChild.offsetHeight != 0)\\n        zwspSupported = test.offsetWidth <= 1 && test.offsetHeight > 2 && !(ie && ie_version < 8);\\n    }\\n    var node = zwspSupported ? elt(\\\"span\\\", \\\"\\\\u200b\\\") :\\n      elt(\\\"span\\\", \\\"\\\\u00a0\\\", null, \\\"display: inline-block; width: 1px; margin-right: -1px\\\");\\n    node.setAttribute(\\\"cm-text\\\", \\\"\\\");\\n    return node;\\n  }\\n\\n  // Feature-detect IE's crummy client rect reporting for bidi text\\n  var badBidiRects;\\n  function hasBadBidiRects(measure) {\\n    if (badBidiRects != null) return badBidiRects;\\n    var txt = removeChildrenAndAdd(measure, document.createTextNode(\\\"A\\\\u062eA\\\"));\\n    var r0 = range(txt, 0, 1).getBoundingClientRect();\\n    var r1 = range(txt, 1, 2).getBoundingClientRect();\\n    removeChildren(measure);\\n    if (!r0 || r0.left == r0.right) return false; // Safari returns null in some cases (#2780)\\n    return badBidiRects = (r1.right - r0.right < 3);\\n  }\\n\\n  // See if \\\"\\\".split is the broken IE version, if so, provide an\\n  // alternative way to split lines.\\n  var splitLinesAuto = CodeMirror.splitLines = \\\"\\\\n\\\\nb\\\".split(/\\\\n/).length != 3 ? function(string) {\\n    var pos = 0, result = [], l = string.length;\\n    while (pos <= l) {\\n      var nl = string.indexOf(\\\"\\\\n\\\", pos);\\n      if (nl == -1) nl = string.length;\\n      var line = string.slice(pos, string.charAt(nl - 1) == \\\"\\\\r\\\" ? nl - 1 : nl);\\n      var rt = line.indexOf(\\\"\\\\r\\\");\\n      if (rt != -1) {\\n        result.push(line.slice(0, rt));\\n        pos += rt + 1;\\n      } else {\\n        result.push(line);\\n        pos = nl + 1;\\n      }\\n    }\\n    return result;\\n  } : function(string){return string.split(/\\\\r\\\\n?|\\\\n/);};\\n\\n  var hasSelection = window.getSelection ? function(te) {\\n    try { return te.selectionStart != te.selectionEnd; }\\n    catch(e) { return false; }\\n  } : function(te) {\\n    try {var range = te.ownerDocument.selection.createRange();}\\n    catch(e) {}\\n    if (!range || range.parentElement() != te) return false;\\n    return range.compareEndPoints(\\\"StartToEnd\\\", range) != 0;\\n  };\\n\\n  var hasCopyEvent = (function() {\\n    var e = elt(\\\"div\\\");\\n    if (\\\"oncopy\\\" in e) return true;\\n    e.setAttribute(\\\"oncopy\\\", \\\"return;\\\");\\n    return typeof e.oncopy == \\\"function\\\";\\n  })();\\n\\n  var badZoomedRects = null;\\n  function hasBadZoomedRects(measure) {\\n    if (badZoomedRects != null) return badZoomedRects;\\n    var node = removeChildrenAndAdd(measure, elt(\\\"span\\\", \\\"x\\\"));\\n    var normal = node.getBoundingClientRect();\\n    var fromRange = range(node, 0, 1).getBoundingClientRect();\\n    return badZoomedRects = Math.abs(normal.left - fromRange.left) > 1;\\n  }\\n\\n  // KEY NAMES\\n\\n  var keyNames = CodeMirror.keyNames = {\\n    3: \\\"Enter\\\", 8: \\\"Backspace\\\", 9: \\\"Tab\\\", 13: \\\"Enter\\\", 16: \\\"Shift\\\", 17: \\\"Ctrl\\\", 18: \\\"Alt\\\",\\n    19: \\\"Pause\\\", 20: \\\"CapsLock\\\", 27: \\\"Esc\\\", 32: \\\"Space\\\", 33: \\\"PageUp\\\", 34: \\\"PageDown\\\", 35: \\\"End\\\",\\n    36: \\\"Home\\\", 37: \\\"Left\\\", 38: \\\"Up\\\", 39: \\\"Right\\\", 40: \\\"Down\\\", 44: \\\"PrintScrn\\\", 45: \\\"Insert\\\",\\n    46: \\\"Delete\\\", 59: \\\";\\\", 61: \\\"=\\\", 91: \\\"Mod\\\", 92: \\\"Mod\\\", 93: \\\"Mod\\\",\\n    106: \\\"*\\\", 107: \\\"=\\\", 109: \\\"-\\\", 110: \\\".\\\", 111: \\\"/\\\", 127: \\\"Delete\\\",\\n    173: \\\"-\\\", 186: \\\";\\\", 187: \\\"=\\\", 188: \\\",\\\", 189: \\\"-\\\", 190: \\\".\\\", 191: \\\"/\\\", 192: \\\"`\\\", 219: \\\"[\\\", 220: \\\"\\\\\\\\\\\",\\n    221: \\\"]\\\", 222: \\\"'\\\", 63232: \\\"Up\\\", 63233: \\\"Down\\\", 63234: \\\"Left\\\", 63235: \\\"Right\\\", 63272: \\\"Delete\\\",\\n    63273: \\\"Home\\\", 63275: \\\"End\\\", 63276: \\\"PageUp\\\", 63277: \\\"PageDown\\\", 63302: \\\"Insert\\\"\\n  };\\n  (function() {\\n    // Number keys\\n    for (var i = 0; i < 10; i++) keyNames[i + 48] = keyNames[i + 96] = String(i);\\n    // Alphabetic keys\\n    for (var i = 65; i <= 90; i++) keyNames[i] = String.fromCharCode(i);\\n    // Function keys\\n    for (var i = 1; i <= 12; i++) keyNames[i + 111] = keyNames[i + 63235] = \\\"F\\\" + i;\\n  })();\\n\\n  // BIDI HELPERS\\n\\n  function iterateBidiSections(order, from, to, f) {\\n    if (!order) return f(from, to, \\\"ltr\\\");\\n    var found = false;\\n    for (var i = 0; i < order.length; ++i) {\\n      var part = order[i];\\n      if (part.from < to && part.to > from || from == to && part.to == from) {\\n        f(Math.max(part.from, from), Math.min(part.to, to), part.level == 1 ? \\\"rtl\\\" : \\\"ltr\\\");\\n        found = true;\\n      }\\n    }\\n    if (!found) f(from, to, \\\"ltr\\\");\\n  }\\n\\n  function bidiLeft(part) { return part.level % 2 ? part.to : part.from; }\\n  function bidiRight(part) { return part.level % 2 ? part.from : part.to; }\\n\\n  function lineLeft(line) { var order = getOrder(line); return order ? bidiLeft(order[0]) : 0; }\\n  function lineRight(line) {\\n    var order = getOrder(line);\\n    if (!order) return line.text.length;\\n    return bidiRight(lst(order));\\n  }\\n\\n  function lineStart(cm, lineN) {\\n    var line = getLine(cm.doc, lineN);\\n    var visual = visualLine(line);\\n    if (visual != line) lineN = lineNo(visual);\\n    var order = getOrder(visual);\\n    var ch = !order ? 0 : order[0].level % 2 ? lineRight(visual) : lineLeft(visual);\\n    return Pos(lineN, ch);\\n  }\\n  function lineEnd(cm, lineN) {\\n    var merged, line = getLine(cm.doc, lineN);\\n    while (merged = collapsedSpanAtEnd(line)) {\\n      line = merged.find(1, true).line;\\n      lineN = null;\\n    }\\n    var order = getOrder(line);\\n    var ch = !order ? line.text.length : order[0].level % 2 ? lineLeft(line) : lineRight(line);\\n    return Pos(lineN == null ? lineNo(line) : lineN, ch);\\n  }\\n  function lineStartSmart(cm, pos) {\\n    var start = lineStart(cm, pos.line);\\n    var line = getLine(cm.doc, start.line);\\n    var order = getOrder(line);\\n    if (!order || order[0].level == 0) {\\n      var firstNonWS = Math.max(0, line.text.search(/\\\\S/));\\n      var inWS = pos.line == start.line && pos.ch <= firstNonWS && pos.ch;\\n      return Pos(start.line, inWS ? 0 : firstNonWS);\\n    }\\n    return start;\\n  }\\n\\n  function compareBidiLevel(order, a, b) {\\n    var linedir = order[0].level;\\n    if (a == linedir) return true;\\n    if (b == linedir) return false;\\n    return a < b;\\n  }\\n  var bidiOther;\\n  function getBidiPartAt(order, pos) {\\n    bidiOther = null;\\n    for (var i = 0, found; i < order.length; ++i) {\\n      var cur = order[i];\\n      if (cur.from < pos && cur.to > pos) return i;\\n      if ((cur.from == pos || cur.to == pos)) {\\n        if (found == null) {\\n          found = i;\\n        } else if (compareBidiLevel(order, cur.level, order[found].level)) {\\n          if (cur.from != cur.to) bidiOther = found;\\n          return i;\\n        } else {\\n          if (cur.from != cur.to) bidiOther = i;\\n          return found;\\n        }\\n      }\\n    }\\n    return found;\\n  }\\n\\n  function moveInLine(line, pos, dir, byUnit) {\\n    if (!byUnit) return pos + dir;\\n    do pos += dir;\\n    while (pos > 0 && isExtendingChar(line.text.charAt(pos)));\\n    return pos;\\n  }\\n\\n  // This is needed in order to move 'visually' through bi-directional\\n  // text -- i.e., pressing left should make the cursor go left, even\\n  // when in RTL text. The tricky part is the 'jumps', where RTL and\\n  // LTR text touch each other. This often requires the cursor offset\\n  // to move more than one unit, in order to visually move one unit.\\n  function moveVisually(line, start, dir, byUnit) {\\n    var bidi = getOrder(line);\\n    if (!bidi) return moveLogically(line, start, dir, byUnit);\\n    var pos = getBidiPartAt(bidi, start), part = bidi[pos];\\n    var target = moveInLine(line, start, part.level % 2 ? -dir : dir, byUnit);\\n\\n    for (;;) {\\n      if (target > part.from && target < part.to) return target;\\n      if (target == part.from || target == part.to) {\\n        if (getBidiPartAt(bidi, target) == pos) return target;\\n        part = bidi[pos += dir];\\n        return (dir > 0) == part.level % 2 ? part.to : part.from;\\n      } else {\\n        part = bidi[pos += dir];\\n        if (!part) return null;\\n        if ((dir > 0) == part.level % 2)\\n          target = moveInLine(line, part.to, -1, byUnit);\\n        else\\n          target = moveInLine(line, part.from, 1, byUnit);\\n      }\\n    }\\n  }\\n\\n  function moveLogically(line, start, dir, byUnit) {\\n    var target = start + dir;\\n    if (byUnit) while (target > 0 && isExtendingChar(line.text.charAt(target))) target += dir;\\n    return target < 0 || target > line.text.length ? null : target;\\n  }\\n\\n  // Bidirectional ordering algorithm\\n  // See http://unicode.org/reports/tr9/tr9-13.html for the algorithm\\n  // that this (partially) implements.\\n\\n  // One-char codes used for character types:\\n  // L (L):   Left-to-Right\\n  // R (R):   Right-to-Left\\n  // r (AL):  Right-to-Left Arabic\\n  // 1 (EN):  European Number\\n  // + (ES):  European Number Separator\\n  // % (ET):  European Number Terminator\\n  // n (AN):  Arabic Number\\n  // , (CS):  Common Number Separator\\n  // m (NSM): Non-Spacing Mark\\n  // b (BN):  Boundary Neutral\\n  // s (B):   Paragraph Separator\\n  // t (S):   Segment Separator\\n  // w (WS):  Whitespace\\n  // N (ON):  Other Neutrals\\n\\n  // Returns null if characters are ordered as they appear\\n  // (left-to-right), or an array of sections ({from, to, level}\\n  // objects) in the order in which they occur visually.\\n  var bidiOrdering = (function() {\\n    // Character types for codepoints 0 to 0xff\\n    var lowTypes = \\\"bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN\\\";\\n    // Character types for codepoints 0x600 to 0x6ff\\n    var arabicTypes = \\\"rrrrrrrrrrrr,rNNmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmrrrrrrrnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmNmmmm\\\";\\n    function charType(code) {\\n      if (code <= 0xf7) return lowTypes.charAt(code);\\n      else if (0x590 <= code && code <= 0x5f4) return \\\"R\\\";\\n      else if (0x600 <= code && code <= 0x6ed) return arabicTypes.charAt(code - 0x600);\\n      else if (0x6ee <= code && code <= 0x8ac) return \\\"r\\\";\\n      else if (0x2000 <= code && code <= 0x200b) return \\\"w\\\";\\n      else if (code == 0x200c) return \\\"b\\\";\\n      else return \\\"L\\\";\\n    }\\n\\n    var bidiRE = /[\\\\u0590-\\\\u05f4\\\\u0600-\\\\u06ff\\\\u0700-\\\\u08ac]/;\\n    var isNeutral = /[stwN]/, isStrong = /[LRr]/, countsAsLeft = /[Lb1n]/, countsAsNum = /[1n]/;\\n    // Browsers seem to always treat the boundaries of block elements as being L.\\n    var outerType = \\\"L\\\";\\n\\n    function BidiSpan(level, from, to) {\\n      this.level = level;\\n      this.from = from; this.to = to;\\n    }\\n\\n    return function(str) {\\n      if (!bidiRE.test(str)) return false;\\n      var len = str.length, types = [];\\n      for (var i = 0, type; i < len; ++i)\\n        types.push(type = charType(str.charCodeAt(i)));\\n\\n      // W1. Examine each non-spacing mark (NSM) in the level run, and\\n      // change the type of the NSM to the type of the previous\\n      // character. If the NSM is at the start of the level run, it will\\n      // get the type of sor.\\n      for (var i = 0, prev = outerType; i < len; ++i) {\\n        var type = types[i];\\n        if (type == \\\"m\\\") types[i] = prev;\\n        else prev = type;\\n      }\\n\\n      // W2. Search backwards from each instance of a European number\\n      // until the first strong type (R, L, AL, or sor) is found. If an\\n      // AL is found, change the type of the European number to Arabic\\n      // number.\\n      // W3. Change all ALs to R.\\n      for (var i = 0, cur = outerType; i < len; ++i) {\\n        var type = types[i];\\n        if (type == \\\"1\\\" && cur == \\\"r\\\") types[i] = \\\"n\\\";\\n        else if (isStrong.test(type)) { cur = type; if (type == \\\"r\\\") types[i] = \\\"R\\\"; }\\n      }\\n\\n      // W4. A single European separator between two European numbers\\n      // changes to a European number. A single common separator between\\n      // two numbers of the same type changes to that type.\\n      for (var i = 1, prev = types[0]; i < len - 1; ++i) {\\n        var type = types[i];\\n        if (type == \\\"+\\\" && prev == \\\"1\\\" && types[i+1] == \\\"1\\\") types[i] = \\\"1\\\";\\n        else if (type == \\\",\\\" && prev == types[i+1] &&\\n                 (prev == \\\"1\\\" || prev == \\\"n\\\")) types[i] = prev;\\n        prev = type;\\n      }\\n\\n      // W5. A sequence of European terminators adjacent to European\\n      // numbers changes to all European numbers.\\n      // W6. Otherwise, separators and terminators change to Other\\n      // Neutral.\\n      for (var i = 0; i < len; ++i) {\\n        var type = types[i];\\n        if (type == \\\",\\\") types[i] = \\\"N\\\";\\n        else if (type == \\\"%\\\") {\\n          for (var end = i + 1; end < len && types[end] == \\\"%\\\"; ++end) {}\\n          var replace = (i && types[i-1] == \\\"!\\\") || (end < len && types[end] == \\\"1\\\") ? \\\"1\\\" : \\\"N\\\";\\n          for (var j = i; j < end; ++j) types[j] = replace;\\n          i = end - 1;\\n        }\\n      }\\n\\n      // W7. Search backwards from each instance of a European number\\n      // until the first strong type (R, L, or sor) is found. If an L is\\n      // found, then change the type of the European number to L.\\n      for (var i = 0, cur = outerType; i < len; ++i) {\\n        var type = types[i];\\n        if (cur == \\\"L\\\" && type == \\\"1\\\") types[i] = \\\"L\\\";\\n        else if (isStrong.test(type)) cur = type;\\n      }\\n\\n      // N1. A sequence of neutrals takes the direction of the\\n      // surrounding strong text if the text on both sides has the same\\n      // direction. European and Arabic numbers act as if they were R in\\n      // terms of their influence on neutrals. Start-of-level-run (sor)\\n      // and end-of-level-run (eor) are used at level run boundaries.\\n      // N2. Any remaining neutrals take the embedding direction.\\n      for (var i = 0; i < len; ++i) {\\n        if (isNeutral.test(types[i])) {\\n          for (var end = i + 1; end < len && isNeutral.test(types[end]); ++end) {}\\n          var before = (i ? types[i-1] : outerType) == \\\"L\\\";\\n          var after = (end < len ? types[end] : outerType) == \\\"L\\\";\\n          var replace = before || after ? \\\"L\\\" : \\\"R\\\";\\n          for (var j = i; j < end; ++j) types[j] = replace;\\n          i = end - 1;\\n        }\\n      }\\n\\n      // Here we depart from the documented algorithm, in order to avoid\\n      // building up an actual levels array. Since there are only three\\n      // levels (0, 1, 2) in an implementation that doesn't take\\n      // explicit embedding into account, we can build up the order on\\n      // the fly, without following the level-based algorithm.\\n      var order = [], m;\\n      for (var i = 0; i < len;) {\\n        if (countsAsLeft.test(types[i])) {\\n          var start = i;\\n          for (++i; i < len && countsAsLeft.test(types[i]); ++i) {}\\n          order.push(new BidiSpan(0, start, i));\\n        } else {\\n          var pos = i, at = order.length;\\n          for (++i; i < len && types[i] != \\\"L\\\"; ++i) {}\\n          for (var j = pos; j < i;) {\\n            if (countsAsNum.test(types[j])) {\\n              if (pos < j) order.splice(at, 0, new BidiSpan(1, pos, j));\\n              var nstart = j;\\n              for (++j; j < i && countsAsNum.test(types[j]); ++j) {}\\n              order.splice(at, 0, new BidiSpan(2, nstart, j));\\n              pos = j;\\n            } else ++j;\\n          }\\n          if (pos < i) order.splice(at, 0, new BidiSpan(1, pos, i));\\n        }\\n      }\\n      if (order[0].level == 1 && (m = str.match(/^\\\\s+/))) {\\n        order[0].from = m[0].length;\\n        order.unshift(new BidiSpan(0, 0, m[0].length));\\n      }\\n      if (lst(order).level == 1 && (m = str.match(/\\\\s+$/))) {\\n        lst(order).to -= m[0].length;\\n        order.push(new BidiSpan(0, len - m[0].length, len));\\n      }\\n      if (order[0].level == 2)\\n        order.unshift(new BidiSpan(1, order[0].to, order[0].to));\\n      if (order[0].level != lst(order).level)\\n        order.push(new BidiSpan(order[0].level, len, len));\\n\\n      return order;\\n    };\\n  })();\\n\\n  // THE END\\n\\n  CodeMirror.version = \\\"5.19.0\\\";\\n\\n  return CodeMirror;\\n});\\n\"//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL34vY29kZW1pcnJvci9saWIvY29kZW1pcnJvci5qcz9iMGIxIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gXCIvLyBDb2RlTWlycm9yLCBjb3B5cmlnaHQgKGMpIGJ5IE1hcmlqbiBIYXZlcmJla2UgYW5kIG90aGVyc1xcbi8vIERpc3RyaWJ1dGVkIHVuZGVyIGFuIE1JVCBsaWNlbnNlOiBodHRwOi8vY29kZW1pcnJvci5uZXQvTElDRU5TRVxcblxcbi8vIFRoaXMgaXMgQ29kZU1pcnJvciAoaHR0cDovL2NvZGVtaXJyb3IubmV0KSwgYSBjb2RlIGVkaXRvclxcbi8vIGltcGxlbWVudGVkIGluIEphdmFTY3JpcHQgb24gdG9wIG9mIHRoZSBicm93c2VyJ3MgRE9NLlxcbi8vXFxuLy8gWW91IGNhbiBmaW5kIHNvbWUgdGVjaG5pY2FsIGJhY2tncm91bmQgZm9yIHNvbWUgb2YgdGhlIGNvZGUgYmVsb3dcXG4vLyBhdCBodHRwOi8vbWFyaWpuaGF2ZXJiZWtlLm5sL2Jsb2cvI2NtLWludGVybmFscyAuXFxuXFxuKGZ1bmN0aW9uKG1vZCkge1xcbiAgaWYgKHR5cGVvZiBleHBvcnRzID09IFxcXCJvYmplY3RcXFwiICYmIHR5cGVvZiBtb2R1bGUgPT0gXFxcIm9iamVjdFxcXCIpIC8vIENvbW1vbkpTXFxuICAgIG1vZHVsZS5leHBvcnRzID0gbW9kKCk7XFxuICBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09IFxcXCJmdW5jdGlvblxcXCIgJiYgZGVmaW5lLmFtZCkgLy8gQU1EXFxuICAgIHJldHVybiBkZWZpbmUoW10sIG1vZCk7XFxuICBlbHNlIC8vIFBsYWluIGJyb3dzZXIgZW52XFxuICAgICh0aGlzIHx8IHdpbmRvdykuQ29kZU1pcnJvciA9IG1vZCgpO1xcbn0pKGZ1bmN0aW9uKCkge1xcbiAgXFxcInVzZSBzdHJpY3RcXFwiO1xcblxcbiAgLy8gQlJPV1NFUiBTTklGRklOR1xcblxcbiAgLy8gS2x1ZGdlcyBmb3IgYnVncyBhbmQgYmVoYXZpb3IgZGlmZmVyZW5jZXMgdGhhdCBjYW4ndCBiZSBmZWF0dXJlXFxuICAvLyBkZXRlY3RlZCBhcmUgZW5hYmxlZCBiYXNlZCBvbiB1c2VyQWdlbnQgZXRjIHNuaWZmaW5nLlxcbiAgdmFyIHVzZXJBZ2VudCA9IG5hdmlnYXRvci51c2VyQWdlbnQ7XFxuICB2YXIgcGxhdGZvcm0gPSBuYXZpZ2F0b3IucGxhdGZvcm07XFxuXFxuICB2YXIgZ2Vja28gPSAvZ2Vja29cXFxcL1xcXFxkL2kudGVzdCh1c2VyQWdlbnQpO1xcbiAgdmFyIGllX3VwdG8xMCA9IC9NU0lFIFxcXFxkLy50ZXN0KHVzZXJBZ2VudCk7XFxuICB2YXIgaWVfMTF1cCA9IC9UcmlkZW50XFxcXC8oPzpbNy05XXxcXFxcZHsyLH0pXFxcXC4uKnJ2OihcXFxcZCspLy5leGVjKHVzZXJBZ2VudCk7XFxuICB2YXIgaWUgPSBpZV91cHRvMTAgfHwgaWVfMTF1cDtcXG4gIHZhciBpZV92ZXJzaW9uID0gaWUgJiYgKGllX3VwdG8xMCA/IGRvY3VtZW50LmRvY3VtZW50TW9kZSB8fCA2IDogaWVfMTF1cFsxXSk7XFxuICB2YXIgd2Via2l0ID0gL1dlYktpdFxcXFwvLy50ZXN0KHVzZXJBZ2VudCk7XFxuICB2YXIgcXR3ZWJraXQgPSB3ZWJraXQgJiYgL1F0XFxcXC9cXFxcZCtcXFxcLlxcXFxkKy8udGVzdCh1c2VyQWdlbnQpO1xcbiAgdmFyIGNocm9tZSA9IC9DaHJvbWVcXFxcLy8udGVzdCh1c2VyQWdlbnQpO1xcbiAgdmFyIHByZXN0byA9IC9PcGVyYVxcXFwvLy50ZXN0KHVzZXJBZ2VudCk7XFxuICB2YXIgc2FmYXJpID0gL0FwcGxlIENvbXB1dGVyLy50ZXN0KG5hdmlnYXRvci52ZW5kb3IpO1xcbiAgdmFyIG1hY19nZU1vdW50YWluTGlvbiA9IC9NYWMgT1MgWCAxXFxcXGRcXFxcRChbOC05XXxcXFxcZFxcXFxkKVxcXFxELy50ZXN0KHVzZXJBZ2VudCk7XFxuICB2YXIgcGhhbnRvbSA9IC9QaGFudG9tSlMvLnRlc3QodXNlckFnZW50KTtcXG5cXG4gIHZhciBpb3MgPSAvQXBwbGVXZWJLaXQvLnRlc3QodXNlckFnZW50KSAmJiAvTW9iaWxlXFxcXC9cXFxcdysvLnRlc3QodXNlckFnZW50KTtcXG4gIC8vIFRoaXMgaXMgd29lZnVsbHkgaW5jb21wbGV0ZS4gU3VnZ2VzdGlvbnMgZm9yIGFsdGVybmF0aXZlIG1ldGhvZHMgd2VsY29tZS5cXG4gIHZhciBtb2JpbGUgPSBpb3MgfHwgL0FuZHJvaWR8d2ViT1N8QmxhY2tCZXJyeXxPcGVyYSBNaW5pfE9wZXJhIE1vYml8SUVNb2JpbGUvaS50ZXN0KHVzZXJBZ2VudCk7XFxuICB2YXIgbWFjID0gaW9zIHx8IC9NYWMvLnRlc3QocGxhdGZvcm0pO1xcbiAgdmFyIGNocm9tZU9TID0gL1xcXFxiQ3JPU1xcXFxiLy50ZXN0KHVzZXJBZ2VudCk7XFxuICB2YXIgd2luZG93cyA9IC93aW4vaS50ZXN0KHBsYXRmb3JtKTtcXG5cXG4gIHZhciBwcmVzdG9fdmVyc2lvbiA9IHByZXN0byAmJiB1c2VyQWdlbnQubWF0Y2goL1ZlcnNpb25cXFxcLyhcXFxcZCpcXFxcLlxcXFxkKikvKTtcXG4gIGlmIChwcmVzdG9fdmVyc2lvbikgcHJlc3RvX3ZlcnNpb24gPSBOdW1iZXIocHJlc3RvX3ZlcnNpb25bMV0pO1xcbiAgaWYgKHByZXN0b192ZXJzaW9uICYmIHByZXN0b192ZXJzaW9uID49IDE1KSB7IHByZXN0byA9IGZhbHNlOyB3ZWJraXQgPSB0cnVlOyB9XFxuICAvLyBTb21lIGJyb3dzZXJzIHVzZSB0aGUgd3JvbmcgZXZlbnQgcHJvcGVydGllcyB0byBzaWduYWwgY21kL2N0cmwgb24gT1MgWFxcbiAgdmFyIGZsaXBDdHJsQ21kID0gbWFjICYmIChxdHdlYmtpdCB8fCBwcmVzdG8gJiYgKHByZXN0b192ZXJzaW9uID09IG51bGwgfHwgcHJlc3RvX3ZlcnNpb24gPCAxMi4xMSkpO1xcbiAgdmFyIGNhcHR1cmVSaWdodENsaWNrID0gZ2Vja28gfHwgKGllICYmIGllX3ZlcnNpb24gPj0gOSk7XFxuXFxuICAvLyBPcHRpbWl6ZSBzb21lIGNvZGUgd2hlbiB0aGVzZSBmZWF0dXJlcyBhcmUgbm90IHVzZWQuXFxuICB2YXIgc2F3UmVhZE9ubHlTcGFucyA9IGZhbHNlLCBzYXdDb2xsYXBzZWRTcGFucyA9IGZhbHNlO1xcblxcbiAgLy8gRURJVE9SIENPTlNUUlVDVE9SXFxuXFxuICAvLyBBIENvZGVNaXJyb3IgaW5zdGFuY2UgcmVwcmVzZW50cyBhbiBlZGl0b3IuIFRoaXMgaXMgdGhlIG9iamVjdFxcbiAgLy8gdGhhdCB1c2VyIGNvZGUgaXMgdXN1YWxseSBkZWFsaW5nIHdpdGguXFxuXFxuICBmdW5jdGlvbiBDb2RlTWlycm9yKHBsYWNlLCBvcHRpb25zKSB7XFxuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBDb2RlTWlycm9yKSkgcmV0dXJuIG5ldyBDb2RlTWlycm9yKHBsYWNlLCBvcHRpb25zKTtcXG5cXG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyA9IG9wdGlvbnMgPyBjb3B5T2JqKG9wdGlvbnMpIDoge307XFxuICAgIC8vIERldGVybWluZSBlZmZlY3RpdmUgb3B0aW9ucyBiYXNlZCBvbiBnaXZlbiB2YWx1ZXMgYW5kIGRlZmF1bHRzLlxcbiAgICBjb3B5T2JqKGRlZmF1bHRzLCBvcHRpb25zLCBmYWxzZSk7XFxuICAgIHNldEd1dHRlcnNGb3JMaW5lTnVtYmVycyhvcHRpb25zKTtcXG5cXG4gICAgdmFyIGRvYyA9IG9wdGlvbnMudmFsdWU7XFxuICAgIGlmICh0eXBlb2YgZG9jID09IFxcXCJzdHJpbmdcXFwiKSBkb2MgPSBuZXcgRG9jKGRvYywgb3B0aW9ucy5tb2RlLCBudWxsLCBvcHRpb25zLmxpbmVTZXBhcmF0b3IpO1xcbiAgICB0aGlzLmRvYyA9IGRvYztcXG5cXG4gICAgdmFyIGlucHV0ID0gbmV3IENvZGVNaXJyb3IuaW5wdXRTdHlsZXNbb3B0aW9ucy5pbnB1dFN0eWxlXSh0aGlzKTtcXG4gICAgdmFyIGRpc3BsYXkgPSB0aGlzLmRpc3BsYXkgPSBuZXcgRGlzcGxheShwbGFjZSwgZG9jLCBpbnB1dCk7XFxuICAgIGRpc3BsYXkud3JhcHBlci5Db2RlTWlycm9yID0gdGhpcztcXG4gICAgdXBkYXRlR3V0dGVycyh0aGlzKTtcXG4gICAgdGhlbWVDaGFuZ2VkKHRoaXMpO1xcbiAgICBpZiAob3B0aW9ucy5saW5lV3JhcHBpbmcpXFxuICAgICAgdGhpcy5kaXNwbGF5LndyYXBwZXIuY2xhc3NOYW1lICs9IFxcXCIgQ29kZU1pcnJvci13cmFwXFxcIjtcXG4gICAgaWYgKG9wdGlvbnMuYXV0b2ZvY3VzICYmICFtb2JpbGUpIGRpc3BsYXkuaW5wdXQuZm9jdXMoKTtcXG4gICAgaW5pdFNjcm9sbGJhcnModGhpcyk7XFxuXFxuICAgIHRoaXMuc3RhdGUgPSB7XFxuICAgICAga2V5TWFwczogW10sICAvLyBzdG9yZXMgbWFwcyBhZGRlZCBieSBhZGRLZXlNYXBcXG4gICAgICBvdmVybGF5czogW10sIC8vIGhpZ2hsaWdodGluZyBvdmVybGF5cywgYXMgYWRkZWQgYnkgYWRkT3ZlcmxheVxcbiAgICAgIG1vZGVHZW46IDAsICAgLy8gYnVtcGVkIHdoZW4gbW9kZS9vdmVybGF5IGNoYW5nZXMsIHVzZWQgdG8gaW52YWxpZGF0ZSBoaWdobGlnaHRpbmcgaW5mb1xcbiAgICAgIG92ZXJ3cml0ZTogZmFsc2UsXFxuICAgICAgZGVsYXlpbmdCbHVyRXZlbnQ6IGZhbHNlLFxcbiAgICAgIGZvY3VzZWQ6IGZhbHNlLFxcbiAgICAgIHN1cHByZXNzRWRpdHM6IGZhbHNlLCAvLyB1c2VkIHRvIGRpc2FibGUgZWRpdGluZyBkdXJpbmcga2V5IGhhbmRsZXJzIHdoZW4gaW4gcmVhZE9ubHkgbW9kZVxcbiAgICAgIHBhc3RlSW5jb21pbmc6IGZhbHNlLCBjdXRJbmNvbWluZzogZmFsc2UsIC8vIGhlbHAgcmVjb2duaXplIHBhc3RlL2N1dCBlZGl0cyBpbiBpbnB1dC5wb2xsXFxuICAgICAgc2VsZWN0aW5nVGV4dDogZmFsc2UsXFxuICAgICAgZHJhZ2dpbmdUZXh0OiBmYWxzZSxcXG4gICAgICBoaWdobGlnaHQ6IG5ldyBEZWxheWVkKCksIC8vIHN0b3JlcyBoaWdobGlnaHQgd29ya2VyIHRpbWVvdXRcXG4gICAgICBrZXlTZXE6IG51bGwsICAvLyBVbmZpbmlzaGVkIGtleSBzZXF1ZW5jZVxcbiAgICAgIHNwZWNpYWxDaGFyczogbnVsbFxcbiAgICB9O1xcblxcbiAgICB2YXIgY20gPSB0aGlzO1xcblxcbiAgICAvLyBPdmVycmlkZSBtYWdpYyB0ZXh0YXJlYSBjb250ZW50IHJlc3RvcmUgdGhhdCBJRSBzb21ldGltZXMgZG9lc1xcbiAgICAvLyBvbiBvdXIgaGlkZGVuIHRleHRhcmVhIG9uIHJlbG9hZFxcbiAgICBpZiAoaWUgJiYgaWVfdmVyc2lvbiA8IDExKSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkgeyBjbS5kaXNwbGF5LmlucHV0LnJlc2V0KHRydWUpOyB9LCAyMCk7XFxuXFxuICAgIHJlZ2lzdGVyRXZlbnRIYW5kbGVycyh0aGlzKTtcXG4gICAgZW5zdXJlR2xvYmFsSGFuZGxlcnMoKTtcXG5cXG4gICAgc3RhcnRPcGVyYXRpb24odGhpcyk7XFxuICAgIHRoaXMuY3VyT3AuZm9yY2VVcGRhdGUgPSB0cnVlO1xcbiAgICBhdHRhY2hEb2ModGhpcywgZG9jKTtcXG5cXG4gICAgaWYgKChvcHRpb25zLmF1dG9mb2N1cyAmJiAhbW9iaWxlKSB8fCBjbS5oYXNGb2N1cygpKVxcbiAgICAgIHNldFRpbWVvdXQoYmluZChvbkZvY3VzLCB0aGlzKSwgMjApO1xcbiAgICBlbHNlXFxuICAgICAgb25CbHVyKHRoaXMpO1xcblxcbiAgICBmb3IgKHZhciBvcHQgaW4gb3B0aW9uSGFuZGxlcnMpIGlmIChvcHRpb25IYW5kbGVycy5oYXNPd25Qcm9wZXJ0eShvcHQpKVxcbiAgICAgIG9wdGlvbkhhbmRsZXJzW29wdF0odGhpcywgb3B0aW9uc1tvcHRdLCBJbml0KTtcXG4gICAgbWF5YmVVcGRhdGVMaW5lTnVtYmVyV2lkdGgodGhpcyk7XFxuICAgIGlmIChvcHRpb25zLmZpbmlzaEluaXQpIG9wdGlvbnMuZmluaXNoSW5pdCh0aGlzKTtcXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbml0SG9va3MubGVuZ3RoOyArK2kpIGluaXRIb29rc1tpXSh0aGlzKTtcXG4gICAgZW5kT3BlcmF0aW9uKHRoaXMpO1xcbiAgICAvLyBTdXBwcmVzcyBvcHRpbWl6ZWxlZ2liaWxpdHkgaW4gV2Via2l0LCBzaW5jZSBpdCBicmVha3MgdGV4dFxcbiAgICAvLyBtZWFzdXJpbmcgb24gbGluZSB3cmFwcGluZyBib3VuZGFyaWVzLlxcbiAgICBpZiAod2Via2l0ICYmIG9wdGlvbnMubGluZVdyYXBwaW5nICYmXFxuICAgICAgICBnZXRDb21wdXRlZFN0eWxlKGRpc3BsYXkubGluZURpdikudGV4dFJlbmRlcmluZyA9PSBcXFwib3B0aW1pemVsZWdpYmlsaXR5XFxcIilcXG4gICAgICBkaXNwbGF5LmxpbmVEaXYuc3R5bGUudGV4dFJlbmRlcmluZyA9IFxcXCJhdXRvXFxcIjtcXG4gIH1cXG5cXG4gIC8vIERJU1BMQVkgQ09OU1RSVUNUT1JcXG5cXG4gIC8vIFRoZSBkaXNwbGF5IGhhbmRsZXMgdGhlIERPTSBpbnRlZ3JhdGlvbiwgYm90aCBmb3IgaW5wdXQgcmVhZGluZ1xcbiAgLy8gYW5kIGNvbnRlbnQgZHJhd2luZy4gSXQgaG9sZHMgcmVmZXJlbmNlcyB0byBET00gbm9kZXMgYW5kXFxuICAvLyBkaXNwbGF5LXJlbGF0ZWQgc3RhdGUuXFxuXFxuICBmdW5jdGlvbiBEaXNwbGF5KHBsYWNlLCBkb2MsIGlucHV0KSB7XFxuICAgIHZhciBkID0gdGhpcztcXG4gICAgdGhpcy5pbnB1dCA9IGlucHV0O1xcblxcbiAgICAvLyBDb3ZlcnMgYm90dG9tLXJpZ2h0IHNxdWFyZSB3aGVuIGJvdGggc2Nyb2xsYmFycyBhcmUgcHJlc2VudC5cXG4gICAgZC5zY3JvbGxiYXJGaWxsZXIgPSBlbHQoXFxcImRpdlxcXCIsIG51bGwsIFxcXCJDb2RlTWlycm9yLXNjcm9sbGJhci1maWxsZXJcXFwiKTtcXG4gICAgZC5zY3JvbGxiYXJGaWxsZXIuc2V0QXR0cmlidXRlKFxcXCJjbS1ub3QtY29udGVudFxcXCIsIFxcXCJ0cnVlXFxcIik7XFxuICAgIC8vIENvdmVycyBib3R0b20gb2YgZ3V0dGVyIHdoZW4gY292ZXJHdXR0ZXJOZXh0VG9TY3JvbGxiYXIgaXMgb25cXG4gICAgLy8gYW5kIGggc2Nyb2xsYmFyIGlzIHByZXNlbnQuXFxuICAgIGQuZ3V0dGVyRmlsbGVyID0gZWx0KFxcXCJkaXZcXFwiLCBudWxsLCBcXFwiQ29kZU1pcnJvci1ndXR0ZXItZmlsbGVyXFxcIik7XFxuICAgIGQuZ3V0dGVyRmlsbGVyLnNldEF0dHJpYnV0ZShcXFwiY20tbm90LWNvbnRlbnRcXFwiLCBcXFwidHJ1ZVxcXCIpO1xcbiAgICAvLyBXaWxsIGNvbnRhaW4gdGhlIGFjdHVhbCBjb2RlLCBwb3NpdGlvbmVkIHRvIGNvdmVyIHRoZSB2aWV3cG9ydC5cXG4gICAgZC5saW5lRGl2ID0gZWx0KFxcXCJkaXZcXFwiLCBudWxsLCBcXFwiQ29kZU1pcnJvci1jb2RlXFxcIik7XFxuICAgIC8vIEVsZW1lbnRzIGFyZSBhZGRlZCB0byB0aGVzZSB0byByZXByZXNlbnQgc2VsZWN0aW9uIGFuZCBjdXJzb3JzLlxcbiAgICBkLnNlbGVjdGlvbkRpdiA9IGVsdChcXFwiZGl2XFxcIiwgbnVsbCwgbnVsbCwgXFxcInBvc2l0aW9uOiByZWxhdGl2ZTsgei1pbmRleDogMVxcXCIpO1xcbiAgICBkLmN1cnNvckRpdiA9IGVsdChcXFwiZGl2XFxcIiwgbnVsbCwgXFxcIkNvZGVNaXJyb3ItY3Vyc29yc1xcXCIpO1xcbiAgICAvLyBBIHZpc2liaWxpdHk6IGhpZGRlbiBlbGVtZW50IHVzZWQgdG8gZmluZCB0aGUgc2l6ZSBvZiB0aGluZ3MuXFxuICAgIGQubWVhc3VyZSA9IGVsdChcXFwiZGl2XFxcIiwgbnVsbCwgXFxcIkNvZGVNaXJyb3ItbWVhc3VyZVxcXCIpO1xcbiAgICAvLyBXaGVuIGxpbmVzIG91dHNpZGUgb2YgdGhlIHZpZXdwb3J0IGFyZSBtZWFzdXJlZCwgdGhleSBhcmUgZHJhd24gaW4gdGhpcy5cXG4gICAgZC5saW5lTWVhc3VyZSA9IGVsdChcXFwiZGl2XFxcIiwgbnVsbCwgXFxcIkNvZGVNaXJyb3ItbWVhc3VyZVxcXCIpO1xcbiAgICAvLyBXcmFwcyBldmVyeXRoaW5nIHRoYXQgbmVlZHMgdG8gZXhpc3QgaW5zaWRlIHRoZSB2ZXJ0aWNhbGx5LXBhZGRlZCBjb29yZGluYXRlIHN5c3RlbVxcbiAgICBkLmxpbmVTcGFjZSA9IGVsdChcXFwiZGl2XFxcIiwgW2QubWVhc3VyZSwgZC5saW5lTWVhc3VyZSwgZC5zZWxlY3Rpb25EaXYsIGQuY3Vyc29yRGl2LCBkLmxpbmVEaXZdLFxcbiAgICAgICAgICAgICAgICAgICAgICBudWxsLCBcXFwicG9zaXRpb246IHJlbGF0aXZlOyBvdXRsaW5lOiBub25lXFxcIik7XFxuICAgIC8vIE1vdmVkIGFyb3VuZCBpdHMgcGFyZW50IHRvIGNvdmVyIHZpc2libGUgdmlldy5cXG4gICAgZC5tb3ZlciA9IGVsdChcXFwiZGl2XFxcIiwgW2VsdChcXFwiZGl2XFxcIiwgW2QubGluZVNwYWNlXSwgXFxcIkNvZGVNaXJyb3ItbGluZXNcXFwiKV0sIG51bGwsIFxcXCJwb3NpdGlvbjogcmVsYXRpdmVcXFwiKTtcXG4gICAgLy8gU2V0IHRvIHRoZSBoZWlnaHQgb2YgdGhlIGRvY3VtZW50LCBhbGxvd2luZyBzY3JvbGxpbmcuXFxuICAgIGQuc2l6ZXIgPSBlbHQoXFxcImRpdlxcXCIsIFtkLm1vdmVyXSwgXFxcIkNvZGVNaXJyb3Itc2l6ZXJcXFwiKTtcXG4gICAgZC5zaXplcldpZHRoID0gbnVsbDtcXG4gICAgLy8gQmVoYXZpb3Igb2YgZWx0cyB3aXRoIG92ZXJmbG93OiBhdXRvIGFuZCBwYWRkaW5nIGlzXFxuICAgIC8vIGluY29uc2lzdGVudCBhY3Jvc3MgYnJvd3NlcnMuIFRoaXMgaXMgdXNlZCB0byBlbnN1cmUgdGhlXFxuICAgIC8vIHNjcm9sbGFibGUgYXJlYSBpcyBiaWcgZW5vdWdoLlxcbiAgICBkLmhlaWdodEZvcmNlciA9IGVsdChcXFwiZGl2XFxcIiwgbnVsbCwgbnVsbCwgXFxcInBvc2l0aW9uOiBhYnNvbHV0ZTsgaGVpZ2h0OiBcXFwiICsgc2Nyb2xsZXJHYXAgKyBcXFwicHg7IHdpZHRoOiAxcHg7XFxcIik7XFxuICAgIC8vIFdpbGwgY29udGFpbiB0aGUgZ3V0dGVycywgaWYgYW55LlxcbiAgICBkLmd1dHRlcnMgPSBlbHQoXFxcImRpdlxcXCIsIG51bGwsIFxcXCJDb2RlTWlycm9yLWd1dHRlcnNcXFwiKTtcXG4gICAgZC5saW5lR3V0dGVyID0gbnVsbDtcXG4gICAgLy8gQWN0dWFsIHNjcm9sbGFibGUgZWxlbWVudC5cXG4gICAgZC5zY3JvbGxlciA9IGVsdChcXFwiZGl2XFxcIiwgW2Quc2l6ZXIsIGQuaGVpZ2h0Rm9yY2VyLCBkLmd1dHRlcnNdLCBcXFwiQ29kZU1pcnJvci1zY3JvbGxcXFwiKTtcXG4gICAgZC5zY3JvbGxlci5zZXRBdHRyaWJ1dGUoXFxcInRhYkluZGV4XFxcIiwgXFxcIi0xXFxcIik7XFxuICAgIC8vIFRoZSBlbGVtZW50IGluIHdoaWNoIHRoZSBlZGl0b3IgbGl2ZXMuXFxuICAgIGQud3JhcHBlciA9IGVsdChcXFwiZGl2XFxcIiwgW2Quc2Nyb2xsYmFyRmlsbGVyLCBkLmd1dHRlckZpbGxlciwgZC5zY3JvbGxlcl0sIFxcXCJDb2RlTWlycm9yXFxcIik7XFxuXFxuICAgIC8vIFdvcmsgYXJvdW5kIElFNyB6LWluZGV4IGJ1ZyAobm90IHBlcmZlY3QsIGhlbmNlIElFNyBub3QgcmVhbGx5IGJlaW5nIHN1cHBvcnRlZClcXG4gICAgaWYgKGllICYmIGllX3ZlcnNpb24gPCA4KSB7IGQuZ3V0dGVycy5zdHlsZS56SW5kZXggPSAtMTsgZC5zY3JvbGxlci5zdHlsZS5wYWRkaW5nUmlnaHQgPSAwOyB9XFxuICAgIGlmICghd2Via2l0ICYmICEoZ2Vja28gJiYgbW9iaWxlKSkgZC5zY3JvbGxlci5kcmFnZ2FibGUgPSB0cnVlO1xcblxcbiAgICBpZiAocGxhY2UpIHtcXG4gICAgICBpZiAocGxhY2UuYXBwZW5kQ2hpbGQpIHBsYWNlLmFwcGVuZENoaWxkKGQud3JhcHBlcik7XFxuICAgICAgZWxzZSBwbGFjZShkLndyYXBwZXIpO1xcbiAgICB9XFxuXFxuICAgIC8vIEN1cnJlbnQgcmVuZGVyZWQgcmFuZ2UgKG1heSBiZSBiaWdnZXIgdGhhbiB0aGUgdmlldyB3aW5kb3cpLlxcbiAgICBkLnZpZXdGcm9tID0gZC52aWV3VG8gPSBkb2MuZmlyc3Q7XFxuICAgIGQucmVwb3J0ZWRWaWV3RnJvbSA9IGQucmVwb3J0ZWRWaWV3VG8gPSBkb2MuZmlyc3Q7XFxuICAgIC8vIEluZm9ybWF0aW9uIGFib3V0IHRoZSByZW5kZXJlZCBsaW5lcy5cXG4gICAgZC52aWV3ID0gW107XFxuICAgIGQucmVuZGVyZWRWaWV3ID0gbnVsbDtcXG4gICAgLy8gSG9sZHMgaW5mbyBhYm91dCBhIHNpbmdsZSByZW5kZXJlZCBsaW5lIHdoZW4gaXQgd2FzIHJlbmRlcmVkXFxuICAgIC8vIGZvciBtZWFzdXJlbWVudCwgd2hpbGUgbm90IGluIHZpZXcuXFxuICAgIGQuZXh0ZXJuYWxNZWFzdXJlZCA9IG51bGw7XFxuICAgIC8vIEVtcHR5IHNwYWNlIChpbiBwaXhlbHMpIGFib3ZlIHRoZSB2aWV3XFxuICAgIGQudmlld09mZnNldCA9IDA7XFxuICAgIGQubGFzdFdyYXBIZWlnaHQgPSBkLmxhc3RXcmFwV2lkdGggPSAwO1xcbiAgICBkLnVwZGF0ZUxpbmVOdW1iZXJzID0gbnVsbDtcXG5cXG4gICAgZC5uYXRpdmVCYXJXaWR0aCA9IGQuYmFySGVpZ2h0ID0gZC5iYXJXaWR0aCA9IDA7XFxuICAgIGQuc2Nyb2xsYmFyc0NsaXBwZWQgPSBmYWxzZTtcXG5cXG4gICAgLy8gVXNlZCB0byBvbmx5IHJlc2l6ZSB0aGUgbGluZSBudW1iZXIgZ3V0dGVyIHdoZW4gbmVjZXNzYXJ5ICh3aGVuXFxuICAgIC8vIHRoZSBhbW91bnQgb2YgbGluZXMgY3Jvc3NlcyBhIGJvdW5kYXJ5IHRoYXQgbWFrZXMgaXRzIHdpZHRoIGNoYW5nZSlcXG4gICAgZC5saW5lTnVtV2lkdGggPSBkLmxpbmVOdW1Jbm5lcldpZHRoID0gZC5saW5lTnVtQ2hhcnMgPSBudWxsO1xcbiAgICAvLyBTZXQgdG8gdHJ1ZSB3aGVuIGEgbm9uLWhvcml6b250YWwtc2Nyb2xsaW5nIGxpbmUgd2lkZ2V0IGlzXFxuICAgIC8vIGFkZGVkLiBBcyBhbiBvcHRpbWl6YXRpb24sIGxpbmUgd2lkZ2V0IGFsaWduaW5nIGlzIHNraXBwZWQgd2hlblxcbiAgICAvLyB0aGlzIGlzIGZhbHNlLlxcbiAgICBkLmFsaWduV2lkZ2V0cyA9IGZhbHNlO1xcblxcbiAgICBkLmNhY2hlZENoYXJXaWR0aCA9IGQuY2FjaGVkVGV4dEhlaWdodCA9IGQuY2FjaGVkUGFkZGluZ0ggPSBudWxsO1xcblxcbiAgICAvLyBUcmFja3MgdGhlIG1heGltdW0gbGluZSBsZW5ndGggc28gdGhhdCB0aGUgaG9yaXpvbnRhbCBzY3JvbGxiYXJcXG4gICAgLy8gY2FuIGJlIGtlcHQgc3RhdGljIHdoZW4gc2Nyb2xsaW5nLlxcbiAgICBkLm1heExpbmUgPSBudWxsO1xcbiAgICBkLm1heExpbmVMZW5ndGggPSAwO1xcbiAgICBkLm1heExpbmVDaGFuZ2VkID0gZmFsc2U7XFxuXFxuICAgIC8vIFVzZWQgZm9yIG1lYXN1cmluZyB3aGVlbCBzY3JvbGxpbmcgZ3JhbnVsYXJpdHlcXG4gICAgZC53aGVlbERYID0gZC53aGVlbERZID0gZC53aGVlbFN0YXJ0WCA9IGQud2hlZWxTdGFydFkgPSBudWxsO1xcblxcbiAgICAvLyBUcnVlIHdoZW4gc2hpZnQgaXMgaGVsZCBkb3duLlxcbiAgICBkLnNoaWZ0ID0gZmFsc2U7XFxuXFxuICAgIC8vIFVzZWQgdG8gdHJhY2sgd2hldGhlciBhbnl0aGluZyBoYXBwZW5lZCBzaW5jZSB0aGUgY29udGV4dCBtZW51XFxuICAgIC8vIHdhcyBvcGVuZWQuXFxuICAgIGQuc2VsRm9yQ29udGV4dE1lbnUgPSBudWxsO1xcblxcbiAgICBkLmFjdGl2ZVRvdWNoID0gbnVsbDtcXG5cXG4gICAgaW5wdXQuaW5pdChkKTtcXG4gIH1cXG5cXG4gIC8vIFNUQVRFIFVQREFURVNcXG5cXG4gIC8vIFVzZWQgdG8gZ2V0IHRoZSBlZGl0b3IgaW50byBhIGNvbnNpc3RlbnQgc3RhdGUgYWdhaW4gd2hlbiBvcHRpb25zIGNoYW5nZS5cXG5cXG4gIGZ1bmN0aW9uIGxvYWRNb2RlKGNtKSB7XFxuICAgIGNtLmRvYy5tb2RlID0gQ29kZU1pcnJvci5nZXRNb2RlKGNtLm9wdGlvbnMsIGNtLmRvYy5tb2RlT3B0aW9uKTtcXG4gICAgcmVzZXRNb2RlU3RhdGUoY20pO1xcbiAgfVxcblxcbiAgZnVuY3Rpb24gcmVzZXRNb2RlU3RhdGUoY20pIHtcXG4gICAgY20uZG9jLml0ZXIoZnVuY3Rpb24obGluZSkge1xcbiAgICAgIGlmIChsaW5lLnN0YXRlQWZ0ZXIpIGxpbmUuc3RhdGVBZnRlciA9IG51bGw7XFxuICAgICAgaWYgKGxpbmUuc3R5bGVzKSBsaW5lLnN0eWxlcyA9IG51bGw7XFxuICAgIH0pO1xcbiAgICBjbS5kb2MuZnJvbnRpZXIgPSBjbS5kb2MuZmlyc3Q7XFxuICAgIHN0YXJ0V29ya2VyKGNtLCAxMDApO1xcbiAgICBjbS5zdGF0ZS5tb2RlR2VuKys7XFxuICAgIGlmIChjbS5jdXJPcCkgcmVnQ2hhbmdlKGNtKTtcXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIHdyYXBwaW5nQ2hhbmdlZChjbSkge1xcbiAgICBpZiAoY20ub3B0aW9ucy5saW5lV3JhcHBpbmcpIHtcXG4gICAgICBhZGRDbGFzcyhjbS5kaXNwbGF5LndyYXBwZXIsIFxcXCJDb2RlTWlycm9yLXdyYXBcXFwiKTtcXG4gICAgICBjbS5kaXNwbGF5LnNpemVyLnN0eWxlLm1pbldpZHRoID0gXFxcIlxcXCI7XFxuICAgICAgY20uZGlzcGxheS5zaXplcldpZHRoID0gbnVsbDtcXG4gICAgfSBlbHNlIHtcXG4gICAgICBybUNsYXNzKGNtLmRpc3BsYXkud3JhcHBlciwgXFxcIkNvZGVNaXJyb3Itd3JhcFxcXCIpO1xcbiAgICAgIGZpbmRNYXhMaW5lKGNtKTtcXG4gICAgfVxcbiAgICBlc3RpbWF0ZUxpbmVIZWlnaHRzKGNtKTtcXG4gICAgcmVnQ2hhbmdlKGNtKTtcXG4gICAgY2xlYXJDYWNoZXMoY20pO1xcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7dXBkYXRlU2Nyb2xsYmFycyhjbSk7fSwgMTAwKTtcXG4gIH1cXG5cXG4gIC8vIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IGVzdGltYXRlcyB0aGUgaGVpZ2h0IG9mIGEgbGluZSwgdG8gdXNlIGFzXFxuICAvLyBmaXJzdCBhcHByb3hpbWF0aW9uIHVudGlsIHRoZSBsaW5lIGJlY29tZXMgdmlzaWJsZSAoYW5kIGlzIHRodXNcXG4gIC8vIHByb3Blcmx5IG1lYXN1cmFibGUpLlxcbiAgZnVuY3Rpb24gZXN0aW1hdGVIZWlnaHQoY20pIHtcXG4gICAgdmFyIHRoID0gdGV4dEhlaWdodChjbS5kaXNwbGF5KSwgd3JhcHBpbmcgPSBjbS5vcHRpb25zLmxpbmVXcmFwcGluZztcXG4gICAgdmFyIHBlckxpbmUgPSB3cmFwcGluZyAmJiBNYXRoLm1heCg1LCBjbS5kaXNwbGF5LnNjcm9sbGVyLmNsaWVudFdpZHRoIC8gY2hhcldpZHRoKGNtLmRpc3BsYXkpIC0gMyk7XFxuICAgIHJldHVybiBmdW5jdGlvbihsaW5lKSB7XFxuICAgICAgaWYgKGxpbmVJc0hpZGRlbihjbS5kb2MsIGxpbmUpKSByZXR1cm4gMDtcXG5cXG4gICAgICB2YXIgd2lkZ2V0c0hlaWdodCA9IDA7XFxuICAgICAgaWYgKGxpbmUud2lkZ2V0cykgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lLndpZGdldHMubGVuZ3RoOyBpKyspIHtcXG4gICAgICAgIGlmIChsaW5lLndpZGdldHNbaV0uaGVpZ2h0KSB3aWRnZXRzSGVpZ2h0ICs9IGxpbmUud2lkZ2V0c1tpXS5oZWlnaHQ7XFxuICAgICAgfVxcblxcbiAgICAgIGlmICh3cmFwcGluZylcXG4gICAgICAgIHJldHVybiB3aWRnZXRzSGVpZ2h0ICsgKE1hdGguY2VpbChsaW5lLnRleHQubGVuZ3RoIC8gcGVyTGluZSkgfHwgMSkgKiB0aDtcXG4gICAgICBlbHNlXFxuICAgICAgICByZXR1cm4gd2lkZ2V0c0hlaWdodCArIHRoO1xcbiAgICB9O1xcbiAgfVxcblxcbiAgZnVuY3Rpb24gZXN0aW1hdGVMaW5lSGVpZ2h0cyhjbSkge1xcbiAgICB2YXIgZG9jID0gY20uZG9jLCBlc3QgPSBlc3RpbWF0ZUhlaWdodChjbSk7XFxuICAgIGRvYy5pdGVyKGZ1bmN0aW9uKGxpbmUpIHtcXG4gICAgICB2YXIgZXN0SGVpZ2h0ID0gZXN0KGxpbmUpO1xcbiAgICAgIGlmIChlc3RIZWlnaHQgIT0gbGluZS5oZWlnaHQpIHVwZGF0ZUxpbmVIZWlnaHQobGluZSwgZXN0SGVpZ2h0KTtcXG4gICAgfSk7XFxuICB9XFxuXFxuICBmdW5jdGlvbiB0aGVtZUNoYW5nZWQoY20pIHtcXG4gICAgY20uZGlzcGxheS53cmFwcGVyLmNsYXNzTmFtZSA9IGNtLmRpc3BsYXkud3JhcHBlci5jbGFzc05hbWUucmVwbGFjZSgvXFxcXHMqY20tcy1cXFxcUysvZywgXFxcIlxcXCIpICtcXG4gICAgICBjbS5vcHRpb25zLnRoZW1lLnJlcGxhY2UoLyhefFxcXFxzKVxcXFxzKi9nLCBcXFwiIGNtLXMtXFxcIik7XFxuICAgIGNsZWFyQ2FjaGVzKGNtKTtcXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIGd1dHRlcnNDaGFuZ2VkKGNtKSB7XFxuICAgIHVwZGF0ZUd1dHRlcnMoY20pO1xcbiAgICByZWdDaGFuZ2UoY20pO1xcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7YWxpZ25Ib3Jpem9udGFsbHkoY20pO30sIDIwKTtcXG4gIH1cXG5cXG4gIC8vIFJlYnVpbGQgdGhlIGd1dHRlciBlbGVtZW50cywgZW5zdXJlIHRoZSBtYXJnaW4gdG8gdGhlIGxlZnQgb2YgdGhlXFxuICAvLyBjb2RlIG1hdGNoZXMgdGhlaXIgd2lkdGguXFxuICBmdW5jdGlvbiB1cGRhdGVHdXR0ZXJzKGNtKSB7XFxuICAgIHZhciBndXR0ZXJzID0gY20uZGlzcGxheS5ndXR0ZXJzLCBzcGVjcyA9IGNtLm9wdGlvbnMuZ3V0dGVycztcXG4gICAgcmVtb3ZlQ2hpbGRyZW4oZ3V0dGVycyk7XFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3BlY3MubGVuZ3RoOyArK2kpIHtcXG4gICAgICB2YXIgZ3V0dGVyQ2xhc3MgPSBzcGVjc1tpXTtcXG4gICAgICB2YXIgZ0VsdCA9IGd1dHRlcnMuYXBwZW5kQ2hpbGQoZWx0KFxcXCJkaXZcXFwiLCBudWxsLCBcXFwiQ29kZU1pcnJvci1ndXR0ZXIgXFxcIiArIGd1dHRlckNsYXNzKSk7XFxuICAgICAgaWYgKGd1dHRlckNsYXNzID09IFxcXCJDb2RlTWlycm9yLWxpbmVudW1iZXJzXFxcIikge1xcbiAgICAgICAgY20uZGlzcGxheS5saW5lR3V0dGVyID0gZ0VsdDtcXG4gICAgICAgIGdFbHQuc3R5bGUud2lkdGggPSAoY20uZGlzcGxheS5saW5lTnVtV2lkdGggfHwgMSkgKyBcXFwicHhcXFwiO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgICBndXR0ZXJzLnN0eWxlLmRpc3BsYXkgPSBpID8gXFxcIlxcXCIgOiBcXFwibm9uZVxcXCI7XFxuICAgIHVwZGF0ZUd1dHRlclNwYWNlKGNtKTtcXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIHVwZGF0ZUd1dHRlclNwYWNlKGNtKSB7XFxuICAgIHZhciB3aWR0aCA9IGNtLmRpc3BsYXkuZ3V0dGVycy5vZmZzZXRXaWR0aDtcXG4gICAgY20uZGlzcGxheS5zaXplci5zdHlsZS5tYXJnaW5MZWZ0ID0gd2lkdGggKyBcXFwicHhcXFwiO1xcbiAgfVxcblxcbiAgLy8gQ29tcHV0ZSB0aGUgY2hhcmFjdGVyIGxlbmd0aCBvZiBhIGxpbmUsIHRha2luZyBpbnRvIGFjY291bnRcXG4gIC8vIGNvbGxhcHNlZCByYW5nZXMgKHNlZSBtYXJrVGV4dCkgdGhhdCBtaWdodCBoaWRlIHBhcnRzLCBhbmQgam9pblxcbiAgLy8gb3RoZXIgbGluZXMgb250byBpdC5cXG4gIGZ1bmN0aW9uIGxpbmVMZW5ndGgobGluZSkge1xcbiAgICBpZiAobGluZS5oZWlnaHQgPT0gMCkgcmV0dXJuIDA7XFxuICAgIHZhciBsZW4gPSBsaW5lLnRleHQubGVuZ3RoLCBtZXJnZWQsIGN1ciA9IGxpbmU7XFxuICAgIHdoaWxlIChtZXJnZWQgPSBjb2xsYXBzZWRTcGFuQXRTdGFydChjdXIpKSB7XFxuICAgICAgdmFyIGZvdW5kID0gbWVyZ2VkLmZpbmQoMCwgdHJ1ZSk7XFxuICAgICAgY3VyID0gZm91bmQuZnJvbS5saW5lO1xcbiAgICAgIGxlbiArPSBmb3VuZC5mcm9tLmNoIC0gZm91bmQudG8uY2g7XFxuICAgIH1cXG4gICAgY3VyID0gbGluZTtcXG4gICAgd2hpbGUgKG1lcmdlZCA9IGNvbGxhcHNlZFNwYW5BdEVuZChjdXIpKSB7XFxuICAgICAgdmFyIGZvdW5kID0gbWVyZ2VkLmZpbmQoMCwgdHJ1ZSk7XFxuICAgICAgbGVuIC09IGN1ci50ZXh0Lmxlbmd0aCAtIGZvdW5kLmZyb20uY2g7XFxuICAgICAgY3VyID0gZm91bmQudG8ubGluZTtcXG4gICAgICBsZW4gKz0gY3VyLnRleHQubGVuZ3RoIC0gZm91bmQudG8uY2g7XFxuICAgIH1cXG4gICAgcmV0dXJuIGxlbjtcXG4gIH1cXG5cXG4gIC8vIEZpbmQgdGhlIGxvbmdlc3QgbGluZSBpbiB0aGUgZG9jdW1lbnQuXFxuICBmdW5jdGlvbiBmaW5kTWF4TGluZShjbSkge1xcbiAgICB2YXIgZCA9IGNtLmRpc3BsYXksIGRvYyA9IGNtLmRvYztcXG4gICAgZC5tYXhMaW5lID0gZ2V0TGluZShkb2MsIGRvYy5maXJzdCk7XFxuICAgIGQubWF4TGluZUxlbmd0aCA9IGxpbmVMZW5ndGgoZC5tYXhMaW5lKTtcXG4gICAgZC5tYXhMaW5lQ2hhbmdlZCA9IHRydWU7XFxuICAgIGRvYy5pdGVyKGZ1bmN0aW9uKGxpbmUpIHtcXG4gICAgICB2YXIgbGVuID0gbGluZUxlbmd0aChsaW5lKTtcXG4gICAgICBpZiAobGVuID4gZC5tYXhMaW5lTGVuZ3RoKSB7XFxuICAgICAgICBkLm1heExpbmVMZW5ndGggPSBsZW47XFxuICAgICAgICBkLm1heExpbmUgPSBsaW5lO1xcbiAgICAgIH1cXG4gICAgfSk7XFxuICB9XFxuXFxuICAvLyBNYWtlIHN1cmUgdGhlIGd1dHRlcnMgb3B0aW9ucyBjb250YWlucyB0aGUgZWxlbWVudFxcbiAgLy8gXFxcIkNvZGVNaXJyb3ItbGluZW51bWJlcnNcXFwiIHdoZW4gdGhlIGxpbmVOdW1iZXJzIG9wdGlvbiBpcyB0cnVlLlxcbiAgZnVuY3Rpb24gc2V0R3V0dGVyc0ZvckxpbmVOdW1iZXJzKG9wdGlvbnMpIHtcXG4gICAgdmFyIGZvdW5kID0gaW5kZXhPZihvcHRpb25zLmd1dHRlcnMsIFxcXCJDb2RlTWlycm9yLWxpbmVudW1iZXJzXFxcIik7XFxuICAgIGlmIChmb3VuZCA9PSAtMSAmJiBvcHRpb25zLmxpbmVOdW1iZXJzKSB7XFxuICAgICAgb3B0aW9ucy5ndXR0ZXJzID0gb3B0aW9ucy5ndXR0ZXJzLmNvbmNhdChbXFxcIkNvZGVNaXJyb3ItbGluZW51bWJlcnNcXFwiXSk7XFxuICAgIH0gZWxzZSBpZiAoZm91bmQgPiAtMSAmJiAhb3B0aW9ucy5saW5lTnVtYmVycykge1xcbiAgICAgIG9wdGlvbnMuZ3V0dGVycyA9IG9wdGlvbnMuZ3V0dGVycy5zbGljZSgwKTtcXG4gICAgICBvcHRpb25zLmd1dHRlcnMuc3BsaWNlKGZvdW5kLCAxKTtcXG4gICAgfVxcbiAgfVxcblxcbiAgLy8gU0NST0xMQkFSU1xcblxcbiAgLy8gUHJlcGFyZSBET00gcmVhZHMgbmVlZGVkIHRvIHVwZGF0ZSB0aGUgc2Nyb2xsYmFycy4gRG9uZSBpbiBvbmVcXG4gIC8vIHNob3QgdG8gbWluaW1pemUgdXBkYXRlL21lYXN1cmUgcm91bmR0cmlwcy5cXG4gIGZ1bmN0aW9uIG1lYXN1cmVGb3JTY3JvbGxiYXJzKGNtKSB7XFxuICAgIHZhciBkID0gY20uZGlzcGxheSwgZ3V0dGVyVyA9IGQuZ3V0dGVycy5vZmZzZXRXaWR0aDtcXG4gICAgdmFyIGRvY0ggPSBNYXRoLnJvdW5kKGNtLmRvYy5oZWlnaHQgKyBwYWRkaW5nVmVydChjbS5kaXNwbGF5KSk7XFxuICAgIHJldHVybiB7XFxuICAgICAgY2xpZW50SGVpZ2h0OiBkLnNjcm9sbGVyLmNsaWVudEhlaWdodCxcXG4gICAgICB2aWV3SGVpZ2h0OiBkLndyYXBwZXIuY2xpZW50SGVpZ2h0LFxcbiAgICAgIHNjcm9sbFdpZHRoOiBkLnNjcm9sbGVyLnNjcm9sbFdpZHRoLCBjbGllbnRXaWR0aDogZC5zY3JvbGxlci5jbGllbnRXaWR0aCxcXG4gICAgICB2aWV3V2lkdGg6IGQud3JhcHBlci5jbGllbnRXaWR0aCxcXG4gICAgICBiYXJMZWZ0OiBjbS5vcHRpb25zLmZpeGVkR3V0dGVyID8gZ3V0dGVyVyA6IDAsXFxuICAgICAgZG9jSGVpZ2h0OiBkb2NILFxcbiAgICAgIHNjcm9sbEhlaWdodDogZG9jSCArIHNjcm9sbEdhcChjbSkgKyBkLmJhckhlaWdodCxcXG4gICAgICBuYXRpdmVCYXJXaWR0aDogZC5uYXRpdmVCYXJXaWR0aCxcXG4gICAgICBndXR0ZXJXaWR0aDogZ3V0dGVyV1xcbiAgICB9O1xcbiAgfVxcblxcbiAgZnVuY3Rpb24gTmF0aXZlU2Nyb2xsYmFycyhwbGFjZSwgc2Nyb2xsLCBjbSkge1xcbiAgICB0aGlzLmNtID0gY207XFxuICAgIHZhciB2ZXJ0ID0gdGhpcy52ZXJ0ID0gZWx0KFxcXCJkaXZcXFwiLCBbZWx0KFxcXCJkaXZcXFwiLCBudWxsLCBudWxsLCBcXFwibWluLXdpZHRoOiAxcHhcXFwiKV0sIFxcXCJDb2RlTWlycm9yLXZzY3JvbGxiYXJcXFwiKTtcXG4gICAgdmFyIGhvcml6ID0gdGhpcy5ob3JpeiA9IGVsdChcXFwiZGl2XFxcIiwgW2VsdChcXFwiZGl2XFxcIiwgbnVsbCwgbnVsbCwgXFxcImhlaWdodDogMTAwJTsgbWluLWhlaWdodDogMXB4XFxcIildLCBcXFwiQ29kZU1pcnJvci1oc2Nyb2xsYmFyXFxcIik7XFxuICAgIHBsYWNlKHZlcnQpOyBwbGFjZShob3Jpeik7XFxuXFxuICAgIG9uKHZlcnQsIFxcXCJzY3JvbGxcXFwiLCBmdW5jdGlvbigpIHtcXG4gICAgICBpZiAodmVydC5jbGllbnRIZWlnaHQpIHNjcm9sbCh2ZXJ0LnNjcm9sbFRvcCwgXFxcInZlcnRpY2FsXFxcIik7XFxuICAgIH0pO1xcbiAgICBvbihob3JpeiwgXFxcInNjcm9sbFxcXCIsIGZ1bmN0aW9uKCkge1xcbiAgICAgIGlmIChob3Jpei5jbGllbnRXaWR0aCkgc2Nyb2xsKGhvcml6LnNjcm9sbExlZnQsIFxcXCJob3Jpem9udGFsXFxcIik7XFxuICAgIH0pO1xcblxcbiAgICB0aGlzLmNoZWNrZWRaZXJvV2lkdGggPSBmYWxzZTtcXG4gICAgLy8gTmVlZCB0byBzZXQgYSBtaW5pbXVtIHdpZHRoIHRvIHNlZSB0aGUgc2Nyb2xsYmFyIG9uIElFNyAoYnV0IG11c3Qgbm90IHNldCBpdCBvbiBJRTgpLlxcbiAgICBpZiAoaWUgJiYgaWVfdmVyc2lvbiA8IDgpIHRoaXMuaG9yaXouc3R5bGUubWluSGVpZ2h0ID0gdGhpcy52ZXJ0LnN0eWxlLm1pbldpZHRoID0gXFxcIjE4cHhcXFwiO1xcbiAgfVxcblxcbiAgTmF0aXZlU2Nyb2xsYmFycy5wcm90b3R5cGUgPSBjb3B5T2JqKHtcXG4gICAgdXBkYXRlOiBmdW5jdGlvbihtZWFzdXJlKSB7XFxuICAgICAgdmFyIG5lZWRzSCA9IG1lYXN1cmUuc2Nyb2xsV2lkdGggPiBtZWFzdXJlLmNsaWVudFdpZHRoICsgMTtcXG4gICAgICB2YXIgbmVlZHNWID0gbWVhc3VyZS5zY3JvbGxIZWlnaHQgPiBtZWFzdXJlLmNsaWVudEhlaWdodCArIDE7XFxuICAgICAgdmFyIHNXaWR0aCA9IG1lYXN1cmUubmF0aXZlQmFyV2lkdGg7XFxuXFxuICAgICAgaWYgKG5lZWRzVikge1xcbiAgICAgICAgdGhpcy52ZXJ0LnN0eWxlLmRpc3BsYXkgPSBcXFwiYmxvY2tcXFwiO1xcbiAgICAgICAgdGhpcy52ZXJ0LnN0eWxlLmJvdHRvbSA9IG5lZWRzSCA/IHNXaWR0aCArIFxcXCJweFxcXCIgOiBcXFwiMFxcXCI7XFxuICAgICAgICB2YXIgdG90YWxIZWlnaHQgPSBtZWFzdXJlLnZpZXdIZWlnaHQgLSAobmVlZHNIID8gc1dpZHRoIDogMCk7XFxuICAgICAgICAvLyBBIGJ1ZyBpbiBJRTggY2FuIGNhdXNlIHRoaXMgdmFsdWUgdG8gYmUgbmVnYXRpdmUsIHNvIGd1YXJkIGl0LlxcbiAgICAgICAgdGhpcy52ZXJ0LmZpcnN0Q2hpbGQuc3R5bGUuaGVpZ2h0ID1cXG4gICAgICAgICAgTWF0aC5tYXgoMCwgbWVhc3VyZS5zY3JvbGxIZWlnaHQgLSBtZWFzdXJlLmNsaWVudEhlaWdodCArIHRvdGFsSGVpZ2h0KSArIFxcXCJweFxcXCI7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIHRoaXMudmVydC5zdHlsZS5kaXNwbGF5ID0gXFxcIlxcXCI7XFxuICAgICAgICB0aGlzLnZlcnQuZmlyc3RDaGlsZC5zdHlsZS5oZWlnaHQgPSBcXFwiMFxcXCI7XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChuZWVkc0gpIHtcXG4gICAgICAgIHRoaXMuaG9yaXouc3R5bGUuZGlzcGxheSA9IFxcXCJibG9ja1xcXCI7XFxuICAgICAgICB0aGlzLmhvcml6LnN0eWxlLnJpZ2h0ID0gbmVlZHNWID8gc1dpZHRoICsgXFxcInB4XFxcIiA6IFxcXCIwXFxcIjtcXG4gICAgICAgIHRoaXMuaG9yaXouc3R5bGUubGVmdCA9IG1lYXN1cmUuYmFyTGVmdCArIFxcXCJweFxcXCI7XFxuICAgICAgICB2YXIgdG90YWxXaWR0aCA9IG1lYXN1cmUudmlld1dpZHRoIC0gbWVhc3VyZS5iYXJMZWZ0IC0gKG5lZWRzViA/IHNXaWR0aCA6IDApO1xcbiAgICAgICAgdGhpcy5ob3Jpei5maXJzdENoaWxkLnN0eWxlLndpZHRoID1cXG4gICAgICAgICAgKG1lYXN1cmUuc2Nyb2xsV2lkdGggLSBtZWFzdXJlLmNsaWVudFdpZHRoICsgdG90YWxXaWR0aCkgKyBcXFwicHhcXFwiO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICB0aGlzLmhvcml6LnN0eWxlLmRpc3BsYXkgPSBcXFwiXFxcIjtcXG4gICAgICAgIHRoaXMuaG9yaXouZmlyc3RDaGlsZC5zdHlsZS53aWR0aCA9IFxcXCIwXFxcIjtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKCF0aGlzLmNoZWNrZWRaZXJvV2lkdGggJiYgbWVhc3VyZS5jbGllbnRIZWlnaHQgPiAwKSB7XFxuICAgICAgICBpZiAoc1dpZHRoID09IDApIHRoaXMuemVyb1dpZHRoSGFjaygpO1xcbiAgICAgICAgdGhpcy5jaGVja2VkWmVyb1dpZHRoID0gdHJ1ZTtcXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIHtyaWdodDogbmVlZHNWID8gc1dpZHRoIDogMCwgYm90dG9tOiBuZWVkc0ggPyBzV2lkdGggOiAwfTtcXG4gICAgfSxcXG4gICAgc2V0U2Nyb2xsTGVmdDogZnVuY3Rpb24ocG9zKSB7XFxuICAgICAgaWYgKHRoaXMuaG9yaXouc2Nyb2xsTGVmdCAhPSBwb3MpIHRoaXMuaG9yaXouc2Nyb2xsTGVmdCA9IHBvcztcXG4gICAgICBpZiAodGhpcy5kaXNhYmxlSG9yaXopIHRoaXMuZW5hYmxlWmVyb1dpZHRoQmFyKHRoaXMuaG9yaXosIHRoaXMuZGlzYWJsZUhvcml6KTtcXG4gICAgfSxcXG4gICAgc2V0U2Nyb2xsVG9wOiBmdW5jdGlvbihwb3MpIHtcXG4gICAgICBpZiAodGhpcy52ZXJ0LnNjcm9sbFRvcCAhPSBwb3MpIHRoaXMudmVydC5zY3JvbGxUb3AgPSBwb3M7XFxuICAgICAgaWYgKHRoaXMuZGlzYWJsZVZlcnQpIHRoaXMuZW5hYmxlWmVyb1dpZHRoQmFyKHRoaXMudmVydCwgdGhpcy5kaXNhYmxlVmVydCk7XFxuICAgIH0sXFxuICAgIHplcm9XaWR0aEhhY2s6IGZ1bmN0aW9uKCkge1xcbiAgICAgIHZhciB3ID0gbWFjICYmICFtYWNfZ2VNb3VudGFpbkxpb24gPyBcXFwiMTJweFxcXCIgOiBcXFwiMThweFxcXCI7XFxuICAgICAgdGhpcy5ob3Jpei5zdHlsZS5oZWlnaHQgPSB0aGlzLnZlcnQuc3R5bGUud2lkdGggPSB3O1xcbiAgICAgIHRoaXMuaG9yaXouc3R5bGUucG9pbnRlckV2ZW50cyA9IHRoaXMudmVydC5zdHlsZS5wb2ludGVyRXZlbnRzID0gXFxcIm5vbmVcXFwiO1xcbiAgICAgIHRoaXMuZGlzYWJsZUhvcml6ID0gbmV3IERlbGF5ZWQ7XFxuICAgICAgdGhpcy5kaXNhYmxlVmVydCA9IG5ldyBEZWxheWVkO1xcbiAgICB9LFxcbiAgICBlbmFibGVaZXJvV2lkdGhCYXI6IGZ1bmN0aW9uKGJhciwgZGVsYXkpIHtcXG4gICAgICBiYXIuc3R5bGUucG9pbnRlckV2ZW50cyA9IFxcXCJhdXRvXFxcIjtcXG4gICAgICBmdW5jdGlvbiBtYXliZURpc2FibGUoKSB7XFxuICAgICAgICAvLyBUbyBmaW5kIG91dCB3aGV0aGVyIHRoZSBzY3JvbGxiYXIgaXMgc3RpbGwgdmlzaWJsZSwgd2VcXG4gICAgICAgIC8vIGNoZWNrIHdoZXRoZXIgdGhlIGVsZW1lbnQgdW5kZXIgdGhlIHBpeGVsIGluIHRoZSBib3R0b21cXG4gICAgICAgIC8vIGxlZnQgY29ybmVyIG9mIHRoZSBzY3JvbGxiYXIgYm94IGlzIHRoZSBzY3JvbGxiYXIgYm94XFxuICAgICAgICAvLyBpdHNlbGYgKHdoZW4gdGhlIGJhciBpcyBzdGlsbCB2aXNpYmxlKSBvciBpdHMgZmlsbGVyIGNoaWxkXFxuICAgICAgICAvLyAod2hlbiB0aGUgYmFyIGlzIGhpZGRlbikuIElmIGl0IGlzIHN0aWxsIHZpc2libGUsIHdlIGtlZXBcXG4gICAgICAgIC8vIGl0IGVuYWJsZWQsIGlmIGl0J3MgaGlkZGVuLCB3ZSBkaXNhYmxlIHBvaW50ZXIgZXZlbnRzLlxcbiAgICAgICAgdmFyIGJveCA9IGJhci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcXG4gICAgICAgIHZhciBlbHQgPSBkb2N1bWVudC5lbGVtZW50RnJvbVBvaW50KGJveC5sZWZ0ICsgMSwgYm94LmJvdHRvbSAtIDEpO1xcbiAgICAgICAgaWYgKGVsdCAhPSBiYXIpIGJhci5zdHlsZS5wb2ludGVyRXZlbnRzID0gXFxcIm5vbmVcXFwiO1xcbiAgICAgICAgZWxzZSBkZWxheS5zZXQoMTAwMCwgbWF5YmVEaXNhYmxlKTtcXG4gICAgICB9XFxuICAgICAgZGVsYXkuc2V0KDEwMDAsIG1heWJlRGlzYWJsZSk7XFxuICAgIH0sXFxuICAgIGNsZWFyOiBmdW5jdGlvbigpIHtcXG4gICAgICB2YXIgcGFyZW50ID0gdGhpcy5ob3Jpei5wYXJlbnROb2RlO1xcbiAgICAgIHBhcmVudC5yZW1vdmVDaGlsZCh0aGlzLmhvcml6KTtcXG4gICAgICBwYXJlbnQucmVtb3ZlQ2hpbGQodGhpcy52ZXJ0KTtcXG4gICAgfVxcbiAgfSwgTmF0aXZlU2Nyb2xsYmFycy5wcm90b3R5cGUpO1xcblxcbiAgZnVuY3Rpb24gTnVsbFNjcm9sbGJhcnMoKSB7fVxcblxcbiAgTnVsbFNjcm9sbGJhcnMucHJvdG90eXBlID0gY29weU9iaih7XFxuICAgIHVwZGF0ZTogZnVuY3Rpb24oKSB7IHJldHVybiB7Ym90dG9tOiAwLCByaWdodDogMH07IH0sXFxuICAgIHNldFNjcm9sbExlZnQ6IGZ1bmN0aW9uKCkge30sXFxuICAgIHNldFNjcm9sbFRvcDogZnVuY3Rpb24oKSB7fSxcXG4gICAgY2xlYXI6IGZ1bmN0aW9uKCkge31cXG4gIH0sIE51bGxTY3JvbGxiYXJzLnByb3RvdHlwZSk7XFxuXFxuICBDb2RlTWlycm9yLnNjcm9sbGJhck1vZGVsID0ge1xcXCJuYXRpdmVcXFwiOiBOYXRpdmVTY3JvbGxiYXJzLCBcXFwibnVsbFxcXCI6IE51bGxTY3JvbGxiYXJzfTtcXG5cXG4gIGZ1bmN0aW9uIGluaXRTY3JvbGxiYXJzKGNtKSB7XFxuICAgIGlmIChjbS5kaXNwbGF5LnNjcm9sbGJhcnMpIHtcXG4gICAgICBjbS5kaXNwbGF5LnNjcm9sbGJhcnMuY2xlYXIoKTtcXG4gICAgICBpZiAoY20uZGlzcGxheS5zY3JvbGxiYXJzLmFkZENsYXNzKVxcbiAgICAgICAgcm1DbGFzcyhjbS5kaXNwbGF5LndyYXBwZXIsIGNtLmRpc3BsYXkuc2Nyb2xsYmFycy5hZGRDbGFzcyk7XFxuICAgIH1cXG5cXG4gICAgY20uZGlzcGxheS5zY3JvbGxiYXJzID0gbmV3IENvZGVNaXJyb3Iuc2Nyb2xsYmFyTW9kZWxbY20ub3B0aW9ucy5zY3JvbGxiYXJTdHlsZV0oZnVuY3Rpb24obm9kZSkge1xcbiAgICAgIGNtLmRpc3BsYXkud3JhcHBlci5pbnNlcnRCZWZvcmUobm9kZSwgY20uZGlzcGxheS5zY3JvbGxiYXJGaWxsZXIpO1xcbiAgICAgIC8vIFByZXZlbnQgY2xpY2tzIGluIHRoZSBzY3JvbGxiYXJzIGZyb20ga2lsbGluZyBmb2N1c1xcbiAgICAgIG9uKG5vZGUsIFxcXCJtb3VzZWRvd25cXFwiLCBmdW5jdGlvbigpIHtcXG4gICAgICAgIGlmIChjbS5zdGF0ZS5mb2N1c2VkKSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkgeyBjbS5kaXNwbGF5LmlucHV0LmZvY3VzKCk7IH0sIDApO1xcbiAgICAgIH0pO1xcbiAgICAgIG5vZGUuc2V0QXR0cmlidXRlKFxcXCJjbS1ub3QtY29udGVudFxcXCIsIFxcXCJ0cnVlXFxcIik7XFxuICAgIH0sIGZ1bmN0aW9uKHBvcywgYXhpcykge1xcbiAgICAgIGlmIChheGlzID09IFxcXCJob3Jpem9udGFsXFxcIikgc2V0U2Nyb2xsTGVmdChjbSwgcG9zKTtcXG4gICAgICBlbHNlIHNldFNjcm9sbFRvcChjbSwgcG9zKTtcXG4gICAgfSwgY20pO1xcbiAgICBpZiAoY20uZGlzcGxheS5zY3JvbGxiYXJzLmFkZENsYXNzKVxcbiAgICAgIGFkZENsYXNzKGNtLmRpc3BsYXkud3JhcHBlciwgY20uZGlzcGxheS5zY3JvbGxiYXJzLmFkZENsYXNzKTtcXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIHVwZGF0ZVNjcm9sbGJhcnMoY20sIG1lYXN1cmUpIHtcXG4gICAgaWYgKCFtZWFzdXJlKSBtZWFzdXJlID0gbWVhc3VyZUZvclNjcm9sbGJhcnMoY20pO1xcbiAgICB2YXIgc3RhcnRXaWR0aCA9IGNtLmRpc3BsYXkuYmFyV2lkdGgsIHN0YXJ0SGVpZ2h0ID0gY20uZGlzcGxheS5iYXJIZWlnaHQ7XFxuICAgIHVwZGF0ZVNjcm9sbGJhcnNJbm5lcihjbSwgbWVhc3VyZSk7XFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNCAmJiBzdGFydFdpZHRoICE9IGNtLmRpc3BsYXkuYmFyV2lkdGggfHwgc3RhcnRIZWlnaHQgIT0gY20uZGlzcGxheS5iYXJIZWlnaHQ7IGkrKykge1xcbiAgICAgIGlmIChzdGFydFdpZHRoICE9IGNtLmRpc3BsYXkuYmFyV2lkdGggJiYgY20ub3B0aW9ucy5saW5lV3JhcHBpbmcpXFxuICAgICAgICB1cGRhdGVIZWlnaHRzSW5WaWV3cG9ydChjbSk7XFxuICAgICAgdXBkYXRlU2Nyb2xsYmFyc0lubmVyKGNtLCBtZWFzdXJlRm9yU2Nyb2xsYmFycyhjbSkpO1xcbiAgICAgIHN0YXJ0V2lkdGggPSBjbS5kaXNwbGF5LmJhcldpZHRoOyBzdGFydEhlaWdodCA9IGNtLmRpc3BsYXkuYmFySGVpZ2h0O1xcbiAgICB9XFxuICB9XFxuXFxuICAvLyBSZS1zeW5jaHJvbml6ZSB0aGUgZmFrZSBzY3JvbGxiYXJzIHdpdGggdGhlIGFjdHVhbCBzaXplIG9mIHRoZVxcbiAgLy8gY29udGVudC5cXG4gIGZ1bmN0aW9uIHVwZGF0ZVNjcm9sbGJhcnNJbm5lcihjbSwgbWVhc3VyZSkge1xcbiAgICB2YXIgZCA9IGNtLmRpc3BsYXk7XFxuICAgIHZhciBzaXplcyA9IGQuc2Nyb2xsYmFycy51cGRhdGUobWVhc3VyZSk7XFxuXFxuICAgIGQuc2l6ZXIuc3R5bGUucGFkZGluZ1JpZ2h0ID0gKGQuYmFyV2lkdGggPSBzaXplcy5yaWdodCkgKyBcXFwicHhcXFwiO1xcbiAgICBkLnNpemVyLnN0eWxlLnBhZGRpbmdCb3R0b20gPSAoZC5iYXJIZWlnaHQgPSBzaXplcy5ib3R0b20pICsgXFxcInB4XFxcIjtcXG4gICAgZC5oZWlnaHRGb3JjZXIuc3R5bGUuYm9yZGVyQm90dG9tID0gc2l6ZXMuYm90dG9tICsgXFxcInB4IHNvbGlkIHRyYW5zcGFyZW50XFxcIlxcblxcbiAgICBpZiAoc2l6ZXMucmlnaHQgJiYgc2l6ZXMuYm90dG9tKSB7XFxuICAgICAgZC5zY3JvbGxiYXJGaWxsZXIuc3R5bGUuZGlzcGxheSA9IFxcXCJibG9ja1xcXCI7XFxuICAgICAgZC5zY3JvbGxiYXJGaWxsZXIuc3R5bGUuaGVpZ2h0ID0gc2l6ZXMuYm90dG9tICsgXFxcInB4XFxcIjtcXG4gICAgICBkLnNjcm9sbGJhckZpbGxlci5zdHlsZS53aWR0aCA9IHNpemVzLnJpZ2h0ICsgXFxcInB4XFxcIjtcXG4gICAgfSBlbHNlIGQuc2Nyb2xsYmFyRmlsbGVyLnN0eWxlLmRpc3BsYXkgPSBcXFwiXFxcIjtcXG4gICAgaWYgKHNpemVzLmJvdHRvbSAmJiBjbS5vcHRpb25zLmNvdmVyR3V0dGVyTmV4dFRvU2Nyb2xsYmFyICYmIGNtLm9wdGlvbnMuZml4ZWRHdXR0ZXIpIHtcXG4gICAgICBkLmd1dHRlckZpbGxlci5zdHlsZS5kaXNwbGF5ID0gXFxcImJsb2NrXFxcIjtcXG4gICAgICBkLmd1dHRlckZpbGxlci5zdHlsZS5oZWlnaHQgPSBzaXplcy5ib3R0b20gKyBcXFwicHhcXFwiO1xcbiAgICAgIGQuZ3V0dGVyRmlsbGVyLnN0eWxlLndpZHRoID0gbWVhc3VyZS5ndXR0ZXJXaWR0aCArIFxcXCJweFxcXCI7XFxuICAgIH0gZWxzZSBkLmd1dHRlckZpbGxlci5zdHlsZS5kaXNwbGF5ID0gXFxcIlxcXCI7XFxuICB9XFxuXFxuICAvLyBDb21wdXRlIHRoZSBsaW5lcyB0aGF0IGFyZSB2aXNpYmxlIGluIGEgZ2l2ZW4gdmlld3BvcnQgKGRlZmF1bHRzXFxuICAvLyB0aGUgdGhlIGN1cnJlbnQgc2Nyb2xsIHBvc2l0aW9uKS4gdmlld3BvcnQgbWF5IGNvbnRhaW4gdG9wLFxcbiAgLy8gaGVpZ2h0LCBhbmQgZW5zdXJlIChzZWUgb3Auc2Nyb2xsVG9Qb3MpIHByb3BlcnRpZXMuXFxuICBmdW5jdGlvbiB2aXNpYmxlTGluZXMoZGlzcGxheSwgZG9jLCB2aWV3cG9ydCkge1xcbiAgICB2YXIgdG9wID0gdmlld3BvcnQgJiYgdmlld3BvcnQudG9wICE9IG51bGwgPyBNYXRoLm1heCgwLCB2aWV3cG9ydC50b3ApIDogZGlzcGxheS5zY3JvbGxlci5zY3JvbGxUb3A7XFxuICAgIHRvcCA9IE1hdGguZmxvb3IodG9wIC0gcGFkZGluZ1RvcChkaXNwbGF5KSk7XFxuICAgIHZhciBib3R0b20gPSB2aWV3cG9ydCAmJiB2aWV3cG9ydC5ib3R0b20gIT0gbnVsbCA/IHZpZXdwb3J0LmJvdHRvbSA6IHRvcCArIGRpc3BsYXkud3JhcHBlci5jbGllbnRIZWlnaHQ7XFxuXFxuICAgIHZhciBmcm9tID0gbGluZUF0SGVpZ2h0KGRvYywgdG9wKSwgdG8gPSBsaW5lQXRIZWlnaHQoZG9jLCBib3R0b20pO1xcbiAgICAvLyBFbnN1cmUgaXMgYSB7ZnJvbToge2xpbmUsIGNofSwgdG86IHtsaW5lLCBjaH19IG9iamVjdCwgYW5kXFxuICAgIC8vIGZvcmNlcyB0aG9zZSBsaW5lcyBpbnRvIHRoZSB2aWV3cG9ydCAoaWYgcG9zc2libGUpLlxcbiAgICBpZiAodmlld3BvcnQgJiYgdmlld3BvcnQuZW5zdXJlKSB7XFxuICAgICAgdmFyIGVuc3VyZUZyb20gPSB2aWV3cG9ydC5lbnN1cmUuZnJvbS5saW5lLCBlbnN1cmVUbyA9IHZpZXdwb3J0LmVuc3VyZS50by5saW5lO1xcbiAgICAgIGlmIChlbnN1cmVGcm9tIDwgZnJvbSkge1xcbiAgICAgICAgZnJvbSA9IGVuc3VyZUZyb207XFxuICAgICAgICB0byA9IGxpbmVBdEhlaWdodChkb2MsIGhlaWdodEF0TGluZShnZXRMaW5lKGRvYywgZW5zdXJlRnJvbSkpICsgZGlzcGxheS53cmFwcGVyLmNsaWVudEhlaWdodCk7XFxuICAgICAgfSBlbHNlIGlmIChNYXRoLm1pbihlbnN1cmVUbywgZG9jLmxhc3RMaW5lKCkpID49IHRvKSB7XFxuICAgICAgICBmcm9tID0gbGluZUF0SGVpZ2h0KGRvYywgaGVpZ2h0QXRMaW5lKGdldExpbmUoZG9jLCBlbnN1cmVUbykpIC0gZGlzcGxheS53cmFwcGVyLmNsaWVudEhlaWdodCk7XFxuICAgICAgICB0byA9IGVuc3VyZVRvO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgICByZXR1cm4ge2Zyb206IGZyb20sIHRvOiBNYXRoLm1heCh0bywgZnJvbSArIDEpfTtcXG4gIH1cXG5cXG4gIC8vIExJTkUgTlVNQkVSU1xcblxcbiAgLy8gUmUtYWxpZ24gbGluZSBudW1iZXJzIGFuZCBndXR0ZXIgbWFya3MgdG8gY29tcGVuc2F0ZSBmb3JcXG4gIC8vIGhvcml6b250YWwgc2Nyb2xsaW5nLlxcbiAgZnVuY3Rpb24gYWxpZ25Ib3Jpem9udGFsbHkoY20pIHtcXG4gICAgdmFyIGRpc3BsYXkgPSBjbS5kaXNwbGF5LCB2aWV3ID0gZGlzcGxheS52aWV3O1xcbiAgICBpZiAoIWRpc3BsYXkuYWxpZ25XaWRnZXRzICYmICghZGlzcGxheS5ndXR0ZXJzLmZpcnN0Q2hpbGQgfHwgIWNtLm9wdGlvbnMuZml4ZWRHdXR0ZXIpKSByZXR1cm47XFxuICAgIHZhciBjb21wID0gY29tcGVuc2F0ZUZvckhTY3JvbGwoZGlzcGxheSkgLSBkaXNwbGF5LnNjcm9sbGVyLnNjcm9sbExlZnQgKyBjbS5kb2Muc2Nyb2xsTGVmdDtcXG4gICAgdmFyIGd1dHRlclcgPSBkaXNwbGF5Lmd1dHRlcnMub2Zmc2V0V2lkdGgsIGxlZnQgPSBjb21wICsgXFxcInB4XFxcIjtcXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2aWV3Lmxlbmd0aDsgaSsrKSBpZiAoIXZpZXdbaV0uaGlkZGVuKSB7XFxuICAgICAgaWYgKGNtLm9wdGlvbnMuZml4ZWRHdXR0ZXIpIHtcXG4gICAgICAgIGlmICh2aWV3W2ldLmd1dHRlcilcXG4gICAgICAgICAgdmlld1tpXS5ndXR0ZXIuc3R5bGUubGVmdCA9IGxlZnQ7XFxuICAgICAgICBpZiAodmlld1tpXS5ndXR0ZXJCYWNrZ3JvdW5kKVxcbiAgICAgICAgICB2aWV3W2ldLmd1dHRlckJhY2tncm91bmQuc3R5bGUubGVmdCA9IGxlZnQ7XFxuICAgICAgfVxcbiAgICAgIHZhciBhbGlnbiA9IHZpZXdbaV0uYWxpZ25hYmxlO1xcbiAgICAgIGlmIChhbGlnbikgZm9yICh2YXIgaiA9IDA7IGogPCBhbGlnbi5sZW5ndGg7IGorKylcXG4gICAgICAgIGFsaWduW2pdLnN0eWxlLmxlZnQgPSBsZWZ0O1xcbiAgICB9XFxuICAgIGlmIChjbS5vcHRpb25zLmZpeGVkR3V0dGVyKVxcbiAgICAgIGRpc3BsYXkuZ3V0dGVycy5zdHlsZS5sZWZ0ID0gKGNvbXAgKyBndXR0ZXJXKSArIFxcXCJweFxcXCI7XFxuICB9XFxuXFxuICAvLyBVc2VkIHRvIGVuc3VyZSB0aGF0IHRoZSBsaW5lIG51bWJlciBndXR0ZXIgaXMgc3RpbGwgdGhlIHJpZ2h0XFxuICAvLyBzaXplIGZvciB0aGUgY3VycmVudCBkb2N1bWVudCBzaXplLiBSZXR1cm5zIHRydWUgd2hlbiBhbiB1cGRhdGVcXG4gIC8vIGlzIG5lZWRlZC5cXG4gIGZ1bmN0aW9uIG1heWJlVXBkYXRlTGluZU51bWJlcldpZHRoKGNtKSB7XFxuICAgIGlmICghY20ub3B0aW9ucy5saW5lTnVtYmVycykgcmV0dXJuIGZhbHNlO1xcbiAgICB2YXIgZG9jID0gY20uZG9jLCBsYXN0ID0gbGluZU51bWJlckZvcihjbS5vcHRpb25zLCBkb2MuZmlyc3QgKyBkb2Muc2l6ZSAtIDEpLCBkaXNwbGF5ID0gY20uZGlzcGxheTtcXG4gICAgaWYgKGxhc3QubGVuZ3RoICE9IGRpc3BsYXkubGluZU51bUNoYXJzKSB7XFxuICAgICAgdmFyIHRlc3QgPSBkaXNwbGF5Lm1lYXN1cmUuYXBwZW5kQ2hpbGQoZWx0KFxcXCJkaXZcXFwiLCBbZWx0KFxcXCJkaXZcXFwiLCBsYXN0KV0sXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcXCJDb2RlTWlycm9yLWxpbmVudW1iZXIgQ29kZU1pcnJvci1ndXR0ZXItZWx0XFxcIikpO1xcbiAgICAgIHZhciBpbm5lclcgPSB0ZXN0LmZpcnN0Q2hpbGQub2Zmc2V0V2lkdGgsIHBhZGRpbmcgPSB0ZXN0Lm9mZnNldFdpZHRoIC0gaW5uZXJXO1xcbiAgICAgIGRpc3BsYXkubGluZUd1dHRlci5zdHlsZS53aWR0aCA9IFxcXCJcXFwiO1xcbiAgICAgIGRpc3BsYXkubGluZU51bUlubmVyV2lkdGggPSBNYXRoLm1heChpbm5lclcsIGRpc3BsYXkubGluZUd1dHRlci5vZmZzZXRXaWR0aCAtIHBhZGRpbmcpICsgMTtcXG4gICAgICBkaXNwbGF5LmxpbmVOdW1XaWR0aCA9IGRpc3BsYXkubGluZU51bUlubmVyV2lkdGggKyBwYWRkaW5nO1xcbiAgICAgIGRpc3BsYXkubGluZU51bUNoYXJzID0gZGlzcGxheS5saW5lTnVtSW5uZXJXaWR0aCA/IGxhc3QubGVuZ3RoIDogLTE7XFxuICAgICAgZGlzcGxheS5saW5lR3V0dGVyLnN0eWxlLndpZHRoID0gZGlzcGxheS5saW5lTnVtV2lkdGggKyBcXFwicHhcXFwiO1xcbiAgICAgIHVwZGF0ZUd1dHRlclNwYWNlKGNtKTtcXG4gICAgICByZXR1cm4gdHJ1ZTtcXG4gICAgfVxcbiAgICByZXR1cm4gZmFsc2U7XFxuICB9XFxuXFxuICBmdW5jdGlvbiBsaW5lTnVtYmVyRm9yKG9wdGlvbnMsIGkpIHtcXG4gICAgcmV0dXJuIFN0cmluZyhvcHRpb25zLmxpbmVOdW1iZXJGb3JtYXR0ZXIoaSArIG9wdGlvbnMuZmlyc3RMaW5lTnVtYmVyKSk7XFxuICB9XFxuXFxuICAvLyBDb21wdXRlcyBkaXNwbGF5LnNjcm9sbGVyLnNjcm9sbExlZnQgKyBkaXNwbGF5Lmd1dHRlcnMub2Zmc2V0V2lkdGgsXFxuICAvLyBidXQgdXNpbmcgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IHRvIGdldCBhIHN1Yi1waXhlbC1hY2N1cmF0ZVxcbiAgLy8gcmVzdWx0LlxcbiAgZnVuY3Rpb24gY29tcGVuc2F0ZUZvckhTY3JvbGwoZGlzcGxheSkge1xcbiAgICByZXR1cm4gZGlzcGxheS5zY3JvbGxlci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0IC0gZGlzcGxheS5zaXplci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0O1xcbiAgfVxcblxcbiAgLy8gRElTUExBWSBEUkFXSU5HXFxuXFxuICBmdW5jdGlvbiBEaXNwbGF5VXBkYXRlKGNtLCB2aWV3cG9ydCwgZm9yY2UpIHtcXG4gICAgdmFyIGRpc3BsYXkgPSBjbS5kaXNwbGF5O1xcblxcbiAgICB0aGlzLnZpZXdwb3J0ID0gdmlld3BvcnQ7XFxuICAgIC8vIFN0b3JlIHNvbWUgdmFsdWVzIHRoYXQgd2UnbGwgbmVlZCBsYXRlciAoYnV0IGRvbid0IHdhbnQgdG8gZm9yY2UgYSByZWxheW91dCBmb3IpXFxuICAgIHRoaXMudmlzaWJsZSA9IHZpc2libGVMaW5lcyhkaXNwbGF5LCBjbS5kb2MsIHZpZXdwb3J0KTtcXG4gICAgdGhpcy5lZGl0b3JJc0hpZGRlbiA9ICFkaXNwbGF5LndyYXBwZXIub2Zmc2V0V2lkdGg7XFxuICAgIHRoaXMud3JhcHBlckhlaWdodCA9IGRpc3BsYXkud3JhcHBlci5jbGllbnRIZWlnaHQ7XFxuICAgIHRoaXMud3JhcHBlcldpZHRoID0gZGlzcGxheS53cmFwcGVyLmNsaWVudFdpZHRoO1xcbiAgICB0aGlzLm9sZERpc3BsYXlXaWR0aCA9IGRpc3BsYXlXaWR0aChjbSk7XFxuICAgIHRoaXMuZm9yY2UgPSBmb3JjZTtcXG4gICAgdGhpcy5kaW1zID0gZ2V0RGltZW5zaW9ucyhjbSk7XFxuICAgIHRoaXMuZXZlbnRzID0gW107XFxuICB9XFxuXFxuICBEaXNwbGF5VXBkYXRlLnByb3RvdHlwZS5zaWduYWwgPSBmdW5jdGlvbihlbWl0dGVyLCB0eXBlKSB7XFxuICAgIGlmIChoYXNIYW5kbGVyKGVtaXR0ZXIsIHR5cGUpKVxcbiAgICAgIHRoaXMuZXZlbnRzLnB1c2goYXJndW1lbnRzKTtcXG4gIH07XFxuICBEaXNwbGF5VXBkYXRlLnByb3RvdHlwZS5maW5pc2ggPSBmdW5jdGlvbigpIHtcXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmV2ZW50cy5sZW5ndGg7IGkrKylcXG4gICAgICBzaWduYWwuYXBwbHkobnVsbCwgdGhpcy5ldmVudHNbaV0pO1xcbiAgfTtcXG5cXG4gIGZ1bmN0aW9uIG1heWJlQ2xpcFNjcm9sbGJhcnMoY20pIHtcXG4gICAgdmFyIGRpc3BsYXkgPSBjbS5kaXNwbGF5O1xcbiAgICBpZiAoIWRpc3BsYXkuc2Nyb2xsYmFyc0NsaXBwZWQgJiYgZGlzcGxheS5zY3JvbGxlci5vZmZzZXRXaWR0aCkge1xcbiAgICAgIGRpc3BsYXkubmF0aXZlQmFyV2lkdGggPSBkaXNwbGF5LnNjcm9sbGVyLm9mZnNldFdpZHRoIC0gZGlzcGxheS5zY3JvbGxlci5jbGllbnRXaWR0aDtcXG4gICAgICBkaXNwbGF5LmhlaWdodEZvcmNlci5zdHlsZS5oZWlnaHQgPSBzY3JvbGxHYXAoY20pICsgXFxcInB4XFxcIjtcXG4gICAgICBkaXNwbGF5LnNpemVyLnN0eWxlLm1hcmdpbkJvdHRvbSA9IC1kaXNwbGF5Lm5hdGl2ZUJhcldpZHRoICsgXFxcInB4XFxcIjtcXG4gICAgICBkaXNwbGF5LnNpemVyLnN0eWxlLmJvcmRlclJpZ2h0V2lkdGggPSBzY3JvbGxHYXAoY20pICsgXFxcInB4XFxcIjtcXG4gICAgICBkaXNwbGF5LnNjcm9sbGJhcnNDbGlwcGVkID0gdHJ1ZTtcXG4gICAgfVxcbiAgfVxcblxcbiAgLy8gRG9lcyB0aGUgYWN0dWFsIHVwZGF0aW5nIG9mIHRoZSBsaW5lIGRpc3BsYXkuIEJhaWxzIG91dFxcbiAgLy8gKHJldHVybmluZyBmYWxzZSkgd2hlbiB0aGVyZSBpcyBub3RoaW5nIHRvIGJlIGRvbmUgYW5kIGZvcmNlZCBpc1xcbiAgLy8gZmFsc2UuXFxuICBmdW5jdGlvbiB1cGRhdGVEaXNwbGF5SWZOZWVkZWQoY20sIHVwZGF0ZSkge1xcbiAgICB2YXIgZGlzcGxheSA9IGNtLmRpc3BsYXksIGRvYyA9IGNtLmRvYztcXG5cXG4gICAgaWYgKHVwZGF0ZS5lZGl0b3JJc0hpZGRlbikge1xcbiAgICAgIHJlc2V0VmlldyhjbSk7XFxuICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICB9XFxuXFxuICAgIC8vIEJhaWwgb3V0IGlmIHRoZSB2aXNpYmxlIGFyZWEgaXMgYWxyZWFkeSByZW5kZXJlZCBhbmQgbm90aGluZyBjaGFuZ2VkLlxcbiAgICBpZiAoIXVwZGF0ZS5mb3JjZSAmJlxcbiAgICAgICAgdXBkYXRlLnZpc2libGUuZnJvbSA+PSBkaXNwbGF5LnZpZXdGcm9tICYmIHVwZGF0ZS52aXNpYmxlLnRvIDw9IGRpc3BsYXkudmlld1RvICYmXFxuICAgICAgICAoZGlzcGxheS51cGRhdGVMaW5lTnVtYmVycyA9PSBudWxsIHx8IGRpc3BsYXkudXBkYXRlTGluZU51bWJlcnMgPj0gZGlzcGxheS52aWV3VG8pICYmXFxuICAgICAgICBkaXNwbGF5LnJlbmRlcmVkVmlldyA9PSBkaXNwbGF5LnZpZXcgJiYgY291bnREaXJ0eVZpZXcoY20pID09IDApXFxuICAgICAgcmV0dXJuIGZhbHNlO1xcblxcbiAgICBpZiAobWF5YmVVcGRhdGVMaW5lTnVtYmVyV2lkdGgoY20pKSB7XFxuICAgICAgcmVzZXRWaWV3KGNtKTtcXG4gICAgICB1cGRhdGUuZGltcyA9IGdldERpbWVuc2lvbnMoY20pO1xcbiAgICB9XFxuXFxuICAgIC8vIENvbXB1dGUgYSBzdWl0YWJsZSBuZXcgdmlld3BvcnQgKGZyb20gJiB0bylcXG4gICAgdmFyIGVuZCA9IGRvYy5maXJzdCArIGRvYy5zaXplO1xcbiAgICB2YXIgZnJvbSA9IE1hdGgubWF4KHVwZGF0ZS52aXNpYmxlLmZyb20gLSBjbS5vcHRpb25zLnZpZXdwb3J0TWFyZ2luLCBkb2MuZmlyc3QpO1xcbiAgICB2YXIgdG8gPSBNYXRoLm1pbihlbmQsIHVwZGF0ZS52aXNpYmxlLnRvICsgY20ub3B0aW9ucy52aWV3cG9ydE1hcmdpbik7XFxuICAgIGlmIChkaXNwbGF5LnZpZXdGcm9tIDwgZnJvbSAmJiBmcm9tIC0gZGlzcGxheS52aWV3RnJvbSA8IDIwKSBmcm9tID0gTWF0aC5tYXgoZG9jLmZpcnN0LCBkaXNwbGF5LnZpZXdGcm9tKTtcXG4gICAgaWYgKGRpc3BsYXkudmlld1RvID4gdG8gJiYgZGlzcGxheS52aWV3VG8gLSB0byA8IDIwKSB0byA9IE1hdGgubWluKGVuZCwgZGlzcGxheS52aWV3VG8pO1xcbiAgICBpZiAoc2F3Q29sbGFwc2VkU3BhbnMpIHtcXG4gICAgICBmcm9tID0gdmlzdWFsTGluZU5vKGNtLmRvYywgZnJvbSk7XFxuICAgICAgdG8gPSB2aXN1YWxMaW5lRW5kTm8oY20uZG9jLCB0byk7XFxuICAgIH1cXG5cXG4gICAgdmFyIGRpZmZlcmVudCA9IGZyb20gIT0gZGlzcGxheS52aWV3RnJvbSB8fCB0byAhPSBkaXNwbGF5LnZpZXdUbyB8fFxcbiAgICAgIGRpc3BsYXkubGFzdFdyYXBIZWlnaHQgIT0gdXBkYXRlLndyYXBwZXJIZWlnaHQgfHwgZGlzcGxheS5sYXN0V3JhcFdpZHRoICE9IHVwZGF0ZS53cmFwcGVyV2lkdGg7XFxuICAgIGFkanVzdFZpZXcoY20sIGZyb20sIHRvKTtcXG5cXG4gICAgZGlzcGxheS52aWV3T2Zmc2V0ID0gaGVpZ2h0QXRMaW5lKGdldExpbmUoY20uZG9jLCBkaXNwbGF5LnZpZXdGcm9tKSk7XFxuICAgIC8vIFBvc2l0aW9uIHRoZSBtb3ZlciBkaXYgdG8gYWxpZ24gd2l0aCB0aGUgY3VycmVudCBzY3JvbGwgcG9zaXRpb25cXG4gICAgY20uZGlzcGxheS5tb3Zlci5zdHlsZS50b3AgPSBkaXNwbGF5LnZpZXdPZmZzZXQgKyBcXFwicHhcXFwiO1xcblxcbiAgICB2YXIgdG9VcGRhdGUgPSBjb3VudERpcnR5VmlldyhjbSk7XFxuICAgIGlmICghZGlmZmVyZW50ICYmIHRvVXBkYXRlID09IDAgJiYgIXVwZGF0ZS5mb3JjZSAmJiBkaXNwbGF5LnJlbmRlcmVkVmlldyA9PSBkaXNwbGF5LnZpZXcgJiZcXG4gICAgICAgIChkaXNwbGF5LnVwZGF0ZUxpbmVOdW1iZXJzID09IG51bGwgfHwgZGlzcGxheS51cGRhdGVMaW5lTnVtYmVycyA+PSBkaXNwbGF5LnZpZXdUbykpXFxuICAgICAgcmV0dXJuIGZhbHNlO1xcblxcbiAgICAvLyBGb3IgYmlnIGNoYW5nZXMsIHdlIGhpZGUgdGhlIGVuY2xvc2luZyBlbGVtZW50IGR1cmluZyB0aGVcXG4gICAgLy8gdXBkYXRlLCBzaW5jZSB0aGF0IHNwZWVkcyB1cCB0aGUgb3BlcmF0aW9ucyBvbiBtb3N0IGJyb3dzZXJzLlxcbiAgICB2YXIgZm9jdXNlZCA9IGFjdGl2ZUVsdCgpO1xcbiAgICBpZiAodG9VcGRhdGUgPiA0KSBkaXNwbGF5LmxpbmVEaXYuc3R5bGUuZGlzcGxheSA9IFxcXCJub25lXFxcIjtcXG4gICAgcGF0Y2hEaXNwbGF5KGNtLCBkaXNwbGF5LnVwZGF0ZUxpbmVOdW1iZXJzLCB1cGRhdGUuZGltcyk7XFxuICAgIGlmICh0b1VwZGF0ZSA+IDQpIGRpc3BsYXkubGluZURpdi5zdHlsZS5kaXNwbGF5ID0gXFxcIlxcXCI7XFxuICAgIGRpc3BsYXkucmVuZGVyZWRWaWV3ID0gZGlzcGxheS52aWV3O1xcbiAgICAvLyBUaGVyZSBtaWdodCBoYXZlIGJlZW4gYSB3aWRnZXQgd2l0aCBhIGZvY3VzZWQgZWxlbWVudCB0aGF0IGdvdFxcbiAgICAvLyBoaWRkZW4gb3IgdXBkYXRlZCwgaWYgc28gcmUtZm9jdXMgaXQuXFxuICAgIGlmIChmb2N1c2VkICYmIGFjdGl2ZUVsdCgpICE9IGZvY3VzZWQgJiYgZm9jdXNlZC5vZmZzZXRIZWlnaHQpIGZvY3VzZWQuZm9jdXMoKTtcXG5cXG4gICAgLy8gUHJldmVudCBzZWxlY3Rpb24gYW5kIGN1cnNvcnMgZnJvbSBpbnRlcmZlcmluZyB3aXRoIHRoZSBzY3JvbGxcXG4gICAgLy8gd2lkdGggYW5kIGhlaWdodC5cXG4gICAgcmVtb3ZlQ2hpbGRyZW4oZGlzcGxheS5jdXJzb3JEaXYpO1xcbiAgICByZW1vdmVDaGlsZHJlbihkaXNwbGF5LnNlbGVjdGlvbkRpdik7XFxuICAgIGRpc3BsYXkuZ3V0dGVycy5zdHlsZS5oZWlnaHQgPSBkaXNwbGF5LnNpemVyLnN0eWxlLm1pbkhlaWdodCA9IDA7XFxuXFxuICAgIGlmIChkaWZmZXJlbnQpIHtcXG4gICAgICBkaXNwbGF5Lmxhc3RXcmFwSGVpZ2h0ID0gdXBkYXRlLndyYXBwZXJIZWlnaHQ7XFxuICAgICAgZGlzcGxheS5sYXN0V3JhcFdpZHRoID0gdXBkYXRlLndyYXBwZXJXaWR0aDtcXG4gICAgICBzdGFydFdvcmtlcihjbSwgNDAwKTtcXG4gICAgfVxcblxcbiAgICBkaXNwbGF5LnVwZGF0ZUxpbmVOdW1iZXJzID0gbnVsbDtcXG5cXG4gICAgcmV0dXJuIHRydWU7XFxuICB9XFxuXFxuICBmdW5jdGlvbiBwb3N0VXBkYXRlRGlzcGxheShjbSwgdXBkYXRlKSB7XFxuICAgIHZhciB2aWV3cG9ydCA9IHVwZGF0ZS52aWV3cG9ydDtcXG5cXG4gICAgZm9yICh2YXIgZmlyc3QgPSB0cnVlOzsgZmlyc3QgPSBmYWxzZSkge1xcbiAgICAgIGlmICghZmlyc3QgfHwgIWNtLm9wdGlvbnMubGluZVdyYXBwaW5nIHx8IHVwZGF0ZS5vbGREaXNwbGF5V2lkdGggPT0gZGlzcGxheVdpZHRoKGNtKSkge1xcbiAgICAgICAgLy8gQ2xpcCBmb3JjZWQgdmlld3BvcnQgdG8gYWN0dWFsIHNjcm9sbGFibGUgYXJlYS5cXG4gICAgICAgIGlmICh2aWV3cG9ydCAmJiB2aWV3cG9ydC50b3AgIT0gbnVsbClcXG4gICAgICAgICAgdmlld3BvcnQgPSB7dG9wOiBNYXRoLm1pbihjbS5kb2MuaGVpZ2h0ICsgcGFkZGluZ1ZlcnQoY20uZGlzcGxheSkgLSBkaXNwbGF5SGVpZ2h0KGNtKSwgdmlld3BvcnQudG9wKX07XFxuICAgICAgICAvLyBVcGRhdGVkIGxpbmUgaGVpZ2h0cyBtaWdodCByZXN1bHQgaW4gdGhlIGRyYXduIGFyZWEgbm90XFxuICAgICAgICAvLyBhY3R1YWxseSBjb3ZlcmluZyB0aGUgdmlld3BvcnQuIEtlZXAgbG9vcGluZyB1bnRpbCBpdCBkb2VzLlxcbiAgICAgICAgdXBkYXRlLnZpc2libGUgPSB2aXNpYmxlTGluZXMoY20uZGlzcGxheSwgY20uZG9jLCB2aWV3cG9ydCk7XFxuICAgICAgICBpZiAodXBkYXRlLnZpc2libGUuZnJvbSA+PSBjbS5kaXNwbGF5LnZpZXdGcm9tICYmIHVwZGF0ZS52aXNpYmxlLnRvIDw9IGNtLmRpc3BsYXkudmlld1RvKVxcbiAgICAgICAgICBicmVhaztcXG4gICAgICB9XFxuICAgICAgaWYgKCF1cGRhdGVEaXNwbGF5SWZOZWVkZWQoY20sIHVwZGF0ZSkpIGJyZWFrO1xcbiAgICAgIHVwZGF0ZUhlaWdodHNJblZpZXdwb3J0KGNtKTtcXG4gICAgICB2YXIgYmFyTWVhc3VyZSA9IG1lYXN1cmVGb3JTY3JvbGxiYXJzKGNtKTtcXG4gICAgICB1cGRhdGVTZWxlY3Rpb24oY20pO1xcbiAgICAgIHVwZGF0ZVNjcm9sbGJhcnMoY20sIGJhck1lYXN1cmUpO1xcbiAgICAgIHNldERvY3VtZW50SGVpZ2h0KGNtLCBiYXJNZWFzdXJlKTtcXG4gICAgfVxcblxcbiAgICB1cGRhdGUuc2lnbmFsKGNtLCBcXFwidXBkYXRlXFxcIiwgY20pO1xcbiAgICBpZiAoY20uZGlzcGxheS52aWV3RnJvbSAhPSBjbS5kaXNwbGF5LnJlcG9ydGVkVmlld0Zyb20gfHwgY20uZGlzcGxheS52aWV3VG8gIT0gY20uZGlzcGxheS5yZXBvcnRlZFZpZXdUbykge1xcbiAgICAgIHVwZGF0ZS5zaWduYWwoY20sIFxcXCJ2aWV3cG9ydENoYW5nZVxcXCIsIGNtLCBjbS5kaXNwbGF5LnZpZXdGcm9tLCBjbS5kaXNwbGF5LnZpZXdUbyk7XFxuICAgICAgY20uZGlzcGxheS5yZXBvcnRlZFZpZXdGcm9tID0gY20uZGlzcGxheS52aWV3RnJvbTsgY20uZGlzcGxheS5yZXBvcnRlZFZpZXdUbyA9IGNtLmRpc3BsYXkudmlld1RvO1xcbiAgICB9XFxuICB9XFxuXFxuICBmdW5jdGlvbiB1cGRhdGVEaXNwbGF5U2ltcGxlKGNtLCB2aWV3cG9ydCkge1xcbiAgICB2YXIgdXBkYXRlID0gbmV3IERpc3BsYXlVcGRhdGUoY20sIHZpZXdwb3J0KTtcXG4gICAgaWYgKHVwZGF0ZURpc3BsYXlJZk5lZWRlZChjbSwgdXBkYXRlKSkge1xcbiAgICAgIHVwZGF0ZUhlaWdodHNJblZpZXdwb3J0KGNtKTtcXG4gICAgICBwb3N0VXBkYXRlRGlzcGxheShjbSwgdXBkYXRlKTtcXG4gICAgICB2YXIgYmFyTWVhc3VyZSA9IG1lYXN1cmVGb3JTY3JvbGxiYXJzKGNtKTtcXG4gICAgICB1cGRhdGVTZWxlY3Rpb24oY20pO1xcbiAgICAgIHVwZGF0ZVNjcm9sbGJhcnMoY20sIGJhck1lYXN1cmUpO1xcbiAgICAgIHNldERvY3VtZW50SGVpZ2h0KGNtLCBiYXJNZWFzdXJlKTtcXG4gICAgICB1cGRhdGUuZmluaXNoKCk7XFxuICAgIH1cXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIHNldERvY3VtZW50SGVpZ2h0KGNtLCBtZWFzdXJlKSB7XFxuICAgIGNtLmRpc3BsYXkuc2l6ZXIuc3R5bGUubWluSGVpZ2h0ID0gbWVhc3VyZS5kb2NIZWlnaHQgKyBcXFwicHhcXFwiO1xcbiAgICBjbS5kaXNwbGF5LmhlaWdodEZvcmNlci5zdHlsZS50b3AgPSBtZWFzdXJlLmRvY0hlaWdodCArIFxcXCJweFxcXCI7XFxuICAgIGNtLmRpc3BsYXkuZ3V0dGVycy5zdHlsZS5oZWlnaHQgPSAobWVhc3VyZS5kb2NIZWlnaHQgKyBjbS5kaXNwbGF5LmJhckhlaWdodCArIHNjcm9sbEdhcChjbSkpICsgXFxcInB4XFxcIjtcXG4gIH1cXG5cXG4gIC8vIFJlYWQgdGhlIGFjdHVhbCBoZWlnaHRzIG9mIHRoZSByZW5kZXJlZCBsaW5lcywgYW5kIHVwZGF0ZSB0aGVpclxcbiAgLy8gc3RvcmVkIGhlaWdodHMgdG8gbWF0Y2guXFxuICBmdW5jdGlvbiB1cGRhdGVIZWlnaHRzSW5WaWV3cG9ydChjbSkge1xcbiAgICB2YXIgZGlzcGxheSA9IGNtLmRpc3BsYXk7XFxuICAgIHZhciBwcmV2Qm90dG9tID0gZGlzcGxheS5saW5lRGl2Lm9mZnNldFRvcDtcXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaXNwbGF5LnZpZXcubGVuZ3RoOyBpKyspIHtcXG4gICAgICB2YXIgY3VyID0gZGlzcGxheS52aWV3W2ldLCBoZWlnaHQ7XFxuICAgICAgaWYgKGN1ci5oaWRkZW4pIGNvbnRpbnVlO1xcbiAgICAgIGlmIChpZSAmJiBpZV92ZXJzaW9uIDwgOCkge1xcbiAgICAgICAgdmFyIGJvdCA9IGN1ci5ub2RlLm9mZnNldFRvcCArIGN1ci5ub2RlLm9mZnNldEhlaWdodDtcXG4gICAgICAgIGhlaWdodCA9IGJvdCAtIHByZXZCb3R0b207XFxuICAgICAgICBwcmV2Qm90dG9tID0gYm90O1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICB2YXIgYm94ID0gY3VyLm5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XFxuICAgICAgICBoZWlnaHQgPSBib3guYm90dG9tIC0gYm94LnRvcDtcXG4gICAgICB9XFxuICAgICAgdmFyIGRpZmYgPSBjdXIubGluZS5oZWlnaHQgLSBoZWlnaHQ7XFxuICAgICAgaWYgKGhlaWdodCA8IDIpIGhlaWdodCA9IHRleHRIZWlnaHQoZGlzcGxheSk7XFxuICAgICAgaWYgKGRpZmYgPiAuMDAxIHx8IGRpZmYgPCAtLjAwMSkge1xcbiAgICAgICAgdXBkYXRlTGluZUhlaWdodChjdXIubGluZSwgaGVpZ2h0KTtcXG4gICAgICAgIHVwZGF0ZVdpZGdldEhlaWdodChjdXIubGluZSk7XFxuICAgICAgICBpZiAoY3VyLnJlc3QpIGZvciAodmFyIGogPSAwOyBqIDwgY3VyLnJlc3QubGVuZ3RoOyBqKyspXFxuICAgICAgICAgIHVwZGF0ZVdpZGdldEhlaWdodChjdXIucmVzdFtqXSk7XFxuICAgICAgfVxcbiAgICB9XFxuICB9XFxuXFxuICAvLyBSZWFkIGFuZCBzdG9yZSB0aGUgaGVpZ2h0IG9mIGxpbmUgd2lkZ2V0cyBhc3NvY2lhdGVkIHdpdGggdGhlXFxuICAvLyBnaXZlbiBsaW5lLlxcbiAgZnVuY3Rpb24gdXBkYXRlV2lkZ2V0SGVpZ2h0KGxpbmUpIHtcXG4gICAgaWYgKGxpbmUud2lkZ2V0cykgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lLndpZGdldHMubGVuZ3RoOyArK2kpXFxuICAgICAgbGluZS53aWRnZXRzW2ldLmhlaWdodCA9IGxpbmUud2lkZ2V0c1tpXS5ub2RlLnBhcmVudE5vZGUub2Zmc2V0SGVpZ2h0O1xcbiAgfVxcblxcbiAgLy8gRG8gYSBidWxrLXJlYWQgb2YgdGhlIERPTSBwb3NpdGlvbnMgYW5kIHNpemVzIG5lZWRlZCB0byBkcmF3IHRoZVxcbiAgLy8gdmlldywgc28gdGhhdCB3ZSBkb24ndCBpbnRlcmxlYXZlIHJlYWRpbmcgYW5kIHdyaXRpbmcgdG8gdGhlIERPTS5cXG4gIGZ1bmN0aW9uIGdldERpbWVuc2lvbnMoY20pIHtcXG4gICAgdmFyIGQgPSBjbS5kaXNwbGF5LCBsZWZ0ID0ge30sIHdpZHRoID0ge307XFxuICAgIHZhciBndXR0ZXJMZWZ0ID0gZC5ndXR0ZXJzLmNsaWVudExlZnQ7XFxuICAgIGZvciAodmFyIG4gPSBkLmd1dHRlcnMuZmlyc3RDaGlsZCwgaSA9IDA7IG47IG4gPSBuLm5leHRTaWJsaW5nLCArK2kpIHtcXG4gICAgICBsZWZ0W2NtLm9wdGlvbnMuZ3V0dGVyc1tpXV0gPSBuLm9mZnNldExlZnQgKyBuLmNsaWVudExlZnQgKyBndXR0ZXJMZWZ0O1xcbiAgICAgIHdpZHRoW2NtLm9wdGlvbnMuZ3V0dGVyc1tpXV0gPSBuLmNsaWVudFdpZHRoO1xcbiAgICB9XFxuICAgIHJldHVybiB7Zml4ZWRQb3M6IGNvbXBlbnNhdGVGb3JIU2Nyb2xsKGQpLFxcbiAgICAgICAgICAgIGd1dHRlclRvdGFsV2lkdGg6IGQuZ3V0dGVycy5vZmZzZXRXaWR0aCxcXG4gICAgICAgICAgICBndXR0ZXJMZWZ0OiBsZWZ0LFxcbiAgICAgICAgICAgIGd1dHRlcldpZHRoOiB3aWR0aCxcXG4gICAgICAgICAgICB3cmFwcGVyV2lkdGg6IGQud3JhcHBlci5jbGllbnRXaWR0aH07XFxuICB9XFxuXFxuICAvLyBTeW5jIHRoZSBhY3R1YWwgZGlzcGxheSBET00gc3RydWN0dXJlIHdpdGggZGlzcGxheS52aWV3LCByZW1vdmluZ1xcbiAgLy8gbm9kZXMgZm9yIGxpbmVzIHRoYXQgYXJlIG5vIGxvbmdlciBpbiB2aWV3LCBhbmQgY3JlYXRpbmcgdGhlIG9uZXNcXG4gIC8vIHRoYXQgYXJlIG5vdCB0aGVyZSB5ZXQsIGFuZCB1cGRhdGluZyB0aGUgb25lcyB0aGF0IGFyZSBvdXQgb2ZcXG4gIC8vIGRhdGUuXFxuICBmdW5jdGlvbiBwYXRjaERpc3BsYXkoY20sIHVwZGF0ZU51bWJlcnNGcm9tLCBkaW1zKSB7XFxuICAgIHZhciBkaXNwbGF5ID0gY20uZGlzcGxheSwgbGluZU51bWJlcnMgPSBjbS5vcHRpb25zLmxpbmVOdW1iZXJzO1xcbiAgICB2YXIgY29udGFpbmVyID0gZGlzcGxheS5saW5lRGl2LCBjdXIgPSBjb250YWluZXIuZmlyc3RDaGlsZDtcXG5cXG4gICAgZnVuY3Rpb24gcm0obm9kZSkge1xcbiAgICAgIHZhciBuZXh0ID0gbm9kZS5uZXh0U2libGluZztcXG4gICAgICAvLyBXb3JrcyBhcm91bmQgYSB0aHJvdy1zY3JvbGwgYnVnIGluIE9TIFggV2Via2l0XFxuICAgICAgaWYgKHdlYmtpdCAmJiBtYWMgJiYgY20uZGlzcGxheS5jdXJyZW50V2hlZWxUYXJnZXQgPT0gbm9kZSlcXG4gICAgICAgIG5vZGUuc3R5bGUuZGlzcGxheSA9IFxcXCJub25lXFxcIjtcXG4gICAgICBlbHNlXFxuICAgICAgICBub2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobm9kZSk7XFxuICAgICAgcmV0dXJuIG5leHQ7XFxuICAgIH1cXG5cXG4gICAgdmFyIHZpZXcgPSBkaXNwbGF5LnZpZXcsIGxpbmVOID0gZGlzcGxheS52aWV3RnJvbTtcXG4gICAgLy8gTG9vcCBvdmVyIHRoZSBlbGVtZW50cyBpbiB0aGUgdmlldywgc3luY2luZyBjdXIgKHRoZSBET00gbm9kZXNcXG4gICAgLy8gaW4gZGlzcGxheS5saW5lRGl2KSB3aXRoIHRoZSB2aWV3IGFzIHdlIGdvLlxcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZpZXcubGVuZ3RoOyBpKyspIHtcXG4gICAgICB2YXIgbGluZVZpZXcgPSB2aWV3W2ldO1xcbiAgICAgIGlmIChsaW5lVmlldy5oaWRkZW4pIHtcXG4gICAgICB9IGVsc2UgaWYgKCFsaW5lVmlldy5ub2RlIHx8IGxpbmVWaWV3Lm5vZGUucGFyZW50Tm9kZSAhPSBjb250YWluZXIpIHsgLy8gTm90IGRyYXduIHlldFxcbiAgICAgICAgdmFyIG5vZGUgPSBidWlsZExpbmVFbGVtZW50KGNtLCBsaW5lVmlldywgbGluZU4sIGRpbXMpO1xcbiAgICAgICAgY29udGFpbmVyLmluc2VydEJlZm9yZShub2RlLCBjdXIpO1xcbiAgICAgIH0gZWxzZSB7IC8vIEFscmVhZHkgZHJhd25cXG4gICAgICAgIHdoaWxlIChjdXIgIT0gbGluZVZpZXcubm9kZSkgY3VyID0gcm0oY3VyKTtcXG4gICAgICAgIHZhciB1cGRhdGVOdW1iZXIgPSBsaW5lTnVtYmVycyAmJiB1cGRhdGVOdW1iZXJzRnJvbSAhPSBudWxsICYmXFxuICAgICAgICAgIHVwZGF0ZU51bWJlcnNGcm9tIDw9IGxpbmVOICYmIGxpbmVWaWV3LmxpbmVOdW1iZXI7XFxuICAgICAgICBpZiAobGluZVZpZXcuY2hhbmdlcykge1xcbiAgICAgICAgICBpZiAoaW5kZXhPZihsaW5lVmlldy5jaGFuZ2VzLCBcXFwiZ3V0dGVyXFxcIikgPiAtMSkgdXBkYXRlTnVtYmVyID0gZmFsc2U7XFxuICAgICAgICAgIHVwZGF0ZUxpbmVGb3JDaGFuZ2VzKGNtLCBsaW5lVmlldywgbGluZU4sIGRpbXMpO1xcbiAgICAgICAgfVxcbiAgICAgICAgaWYgKHVwZGF0ZU51bWJlcikge1xcbiAgICAgICAgICByZW1vdmVDaGlsZHJlbihsaW5lVmlldy5saW5lTnVtYmVyKTtcXG4gICAgICAgICAgbGluZVZpZXcubGluZU51bWJlci5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShsaW5lTnVtYmVyRm9yKGNtLm9wdGlvbnMsIGxpbmVOKSkpO1xcbiAgICAgICAgfVxcbiAgICAgICAgY3VyID0gbGluZVZpZXcubm9kZS5uZXh0U2libGluZztcXG4gICAgICB9XFxuICAgICAgbGluZU4gKz0gbGluZVZpZXcuc2l6ZTtcXG4gICAgfVxcbiAgICB3aGlsZSAoY3VyKSBjdXIgPSBybShjdXIpO1xcbiAgfVxcblxcbiAgLy8gV2hlbiBhbiBhc3BlY3Qgb2YgYSBsaW5lIGNoYW5nZXMsIGEgc3RyaW5nIGlzIGFkZGVkIHRvXFxuICAvLyBsaW5lVmlldy5jaGFuZ2VzLiBUaGlzIHVwZGF0ZXMgdGhlIHJlbGV2YW50IHBhcnQgb2YgdGhlIGxpbmUnc1xcbiAgLy8gRE9NIHN0cnVjdHVyZS5cXG4gIGZ1bmN0aW9uIHVwZGF0ZUxpbmVGb3JDaGFuZ2VzKGNtLCBsaW5lVmlldywgbGluZU4sIGRpbXMpIHtcXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBsaW5lVmlldy5jaGFuZ2VzLmxlbmd0aDsgaisrKSB7XFxuICAgICAgdmFyIHR5cGUgPSBsaW5lVmlldy5jaGFuZ2VzW2pdO1xcbiAgICAgIGlmICh0eXBlID09IFxcXCJ0ZXh0XFxcIikgdXBkYXRlTGluZVRleHQoY20sIGxpbmVWaWV3KTtcXG4gICAgICBlbHNlIGlmICh0eXBlID09IFxcXCJndXR0ZXJcXFwiKSB1cGRhdGVMaW5lR3V0dGVyKGNtLCBsaW5lVmlldywgbGluZU4sIGRpbXMpO1xcbiAgICAgIGVsc2UgaWYgKHR5cGUgPT0gXFxcImNsYXNzXFxcIikgdXBkYXRlTGluZUNsYXNzZXMobGluZVZpZXcpO1xcbiAgICAgIGVsc2UgaWYgKHR5cGUgPT0gXFxcIndpZGdldFxcXCIpIHVwZGF0ZUxpbmVXaWRnZXRzKGNtLCBsaW5lVmlldywgZGltcyk7XFxuICAgIH1cXG4gICAgbGluZVZpZXcuY2hhbmdlcyA9IG51bGw7XFxuICB9XFxuXFxuICAvLyBMaW5lcyB3aXRoIGd1dHRlciBlbGVtZW50cywgd2lkZ2V0cyBvciBhIGJhY2tncm91bmQgY2xhc3MgbmVlZCB0b1xcbiAgLy8gYmUgd3JhcHBlZCwgYW5kIGhhdmUgdGhlIGV4dHJhIGVsZW1lbnRzIGFkZGVkIHRvIHRoZSB3cmFwcGVyIGRpdlxcbiAgZnVuY3Rpb24gZW5zdXJlTGluZVdyYXBwZWQobGluZVZpZXcpIHtcXG4gICAgaWYgKGxpbmVWaWV3Lm5vZGUgPT0gbGluZVZpZXcudGV4dCkge1xcbiAgICAgIGxpbmVWaWV3Lm5vZGUgPSBlbHQoXFxcImRpdlxcXCIsIG51bGwsIG51bGwsIFxcXCJwb3NpdGlvbjogcmVsYXRpdmVcXFwiKTtcXG4gICAgICBpZiAobGluZVZpZXcudGV4dC5wYXJlbnROb2RlKVxcbiAgICAgICAgbGluZVZpZXcudGV4dC5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZChsaW5lVmlldy5ub2RlLCBsaW5lVmlldy50ZXh0KTtcXG4gICAgICBsaW5lVmlldy5ub2RlLmFwcGVuZENoaWxkKGxpbmVWaWV3LnRleHQpO1xcbiAgICAgIGlmIChpZSAmJiBpZV92ZXJzaW9uIDwgOCkgbGluZVZpZXcubm9kZS5zdHlsZS56SW5kZXggPSAyO1xcbiAgICB9XFxuICAgIHJldHVybiBsaW5lVmlldy5ub2RlO1xcbiAgfVxcblxcbiAgZnVuY3Rpb24gdXBkYXRlTGluZUJhY2tncm91bmQobGluZVZpZXcpIHtcXG4gICAgdmFyIGNscyA9IGxpbmVWaWV3LmJnQ2xhc3MgPyBsaW5lVmlldy5iZ0NsYXNzICsgXFxcIiBcXFwiICsgKGxpbmVWaWV3LmxpbmUuYmdDbGFzcyB8fCBcXFwiXFxcIikgOiBsaW5lVmlldy5saW5lLmJnQ2xhc3M7XFxuICAgIGlmIChjbHMpIGNscyArPSBcXFwiIENvZGVNaXJyb3ItbGluZWJhY2tncm91bmRcXFwiO1xcbiAgICBpZiAobGluZVZpZXcuYmFja2dyb3VuZCkge1xcbiAgICAgIGlmIChjbHMpIGxpbmVWaWV3LmJhY2tncm91bmQuY2xhc3NOYW1lID0gY2xzO1xcbiAgICAgIGVsc2UgeyBsaW5lVmlldy5iYWNrZ3JvdW5kLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobGluZVZpZXcuYmFja2dyb3VuZCk7IGxpbmVWaWV3LmJhY2tncm91bmQgPSBudWxsOyB9XFxuICAgIH0gZWxzZSBpZiAoY2xzKSB7XFxuICAgICAgdmFyIHdyYXAgPSBlbnN1cmVMaW5lV3JhcHBlZChsaW5lVmlldyk7XFxuICAgICAgbGluZVZpZXcuYmFja2dyb3VuZCA9IHdyYXAuaW5zZXJ0QmVmb3JlKGVsdChcXFwiZGl2XFxcIiwgbnVsbCwgY2xzKSwgd3JhcC5maXJzdENoaWxkKTtcXG4gICAgfVxcbiAgfVxcblxcbiAgLy8gV3JhcHBlciBhcm91bmQgYnVpbGRMaW5lQ29udGVudCB3aGljaCB3aWxsIHJldXNlIHRoZSBzdHJ1Y3R1cmVcXG4gIC8vIGluIGRpc3BsYXkuZXh0ZXJuYWxNZWFzdXJlZCB3aGVuIHBvc3NpYmxlLlxcbiAgZnVuY3Rpb24gZ2V0TGluZUNvbnRlbnQoY20sIGxpbmVWaWV3KSB7XFxuICAgIHZhciBleHQgPSBjbS5kaXNwbGF5LmV4dGVybmFsTWVhc3VyZWQ7XFxuICAgIGlmIChleHQgJiYgZXh0LmxpbmUgPT0gbGluZVZpZXcubGluZSkge1xcbiAgICAgIGNtLmRpc3BsYXkuZXh0ZXJuYWxNZWFzdXJlZCA9IG51bGw7XFxuICAgICAgbGluZVZpZXcubWVhc3VyZSA9IGV4dC5tZWFzdXJlO1xcbiAgICAgIHJldHVybiBleHQuYnVpbHQ7XFxuICAgIH1cXG4gICAgcmV0dXJuIGJ1aWxkTGluZUNvbnRlbnQoY20sIGxpbmVWaWV3KTtcXG4gIH1cXG5cXG4gIC8vIFJlZHJhdyB0aGUgbGluZSdzIHRleHQuIEludGVyYWN0cyB3aXRoIHRoZSBiYWNrZ3JvdW5kIGFuZCB0ZXh0XFxuICAvLyBjbGFzc2VzIGJlY2F1c2UgdGhlIG1vZGUgbWF5IG91dHB1dCB0b2tlbnMgdGhhdCBpbmZsdWVuY2UgdGhlc2VcXG4gIC8vIGNsYXNzZXMuXFxuICBmdW5jdGlvbiB1cGRhdGVMaW5lVGV4dChjbSwgbGluZVZpZXcpIHtcXG4gICAgdmFyIGNscyA9IGxpbmVWaWV3LnRleHQuY2xhc3NOYW1lO1xcbiAgICB2YXIgYnVpbHQgPSBnZXRMaW5lQ29udGVudChjbSwgbGluZVZpZXcpO1xcbiAgICBpZiAobGluZVZpZXcudGV4dCA9PSBsaW5lVmlldy5ub2RlKSBsaW5lVmlldy5ub2RlID0gYnVpbHQucHJlO1xcbiAgICBsaW5lVmlldy50ZXh0LnBhcmVudE5vZGUucmVwbGFjZUNoaWxkKGJ1aWx0LnByZSwgbGluZVZpZXcudGV4dCk7XFxuICAgIGxpbmVWaWV3LnRleHQgPSBidWlsdC5wcmU7XFxuICAgIGlmIChidWlsdC5iZ0NsYXNzICE9IGxpbmVWaWV3LmJnQ2xhc3MgfHwgYnVpbHQudGV4dENsYXNzICE9IGxpbmVWaWV3LnRleHRDbGFzcykge1xcbiAgICAgIGxpbmVWaWV3LmJnQ2xhc3MgPSBidWlsdC5iZ0NsYXNzO1xcbiAgICAgIGxpbmVWaWV3LnRleHRDbGFzcyA9IGJ1aWx0LnRleHRDbGFzcztcXG4gICAgICB1cGRhdGVMaW5lQ2xhc3NlcyhsaW5lVmlldyk7XFxuICAgIH0gZWxzZSBpZiAoY2xzKSB7XFxuICAgICAgbGluZVZpZXcudGV4dC5jbGFzc05hbWUgPSBjbHM7XFxuICAgIH1cXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIHVwZGF0ZUxpbmVDbGFzc2VzKGxpbmVWaWV3KSB7XFxuICAgIHVwZGF0ZUxpbmVCYWNrZ3JvdW5kKGxpbmVWaWV3KTtcXG4gICAgaWYgKGxpbmVWaWV3LmxpbmUud3JhcENsYXNzKVxcbiAgICAgIGVuc3VyZUxpbmVXcmFwcGVkKGxpbmVWaWV3KS5jbGFzc05hbWUgPSBsaW5lVmlldy5saW5lLndyYXBDbGFzcztcXG4gICAgZWxzZSBpZiAobGluZVZpZXcubm9kZSAhPSBsaW5lVmlldy50ZXh0KVxcbiAgICAgIGxpbmVWaWV3Lm5vZGUuY2xhc3NOYW1lID0gXFxcIlxcXCI7XFxuICAgIHZhciB0ZXh0Q2xhc3MgPSBsaW5lVmlldy50ZXh0Q2xhc3MgPyBsaW5lVmlldy50ZXh0Q2xhc3MgKyBcXFwiIFxcXCIgKyAobGluZVZpZXcubGluZS50ZXh0Q2xhc3MgfHwgXFxcIlxcXCIpIDogbGluZVZpZXcubGluZS50ZXh0Q2xhc3M7XFxuICAgIGxpbmVWaWV3LnRleHQuY2xhc3NOYW1lID0gdGV4dENsYXNzIHx8IFxcXCJcXFwiO1xcbiAgfVxcblxcbiAgZnVuY3Rpb24gdXBkYXRlTGluZUd1dHRlcihjbSwgbGluZVZpZXcsIGxpbmVOLCBkaW1zKSB7XFxuICAgIGlmIChsaW5lVmlldy5ndXR0ZXIpIHtcXG4gICAgICBsaW5lVmlldy5ub2RlLnJlbW92ZUNoaWxkKGxpbmVWaWV3Lmd1dHRlcik7XFxuICAgICAgbGluZVZpZXcuZ3V0dGVyID0gbnVsbDtcXG4gICAgfVxcbiAgICBpZiAobGluZVZpZXcuZ3V0dGVyQmFja2dyb3VuZCkge1xcbiAgICAgIGxpbmVWaWV3Lm5vZGUucmVtb3ZlQ2hpbGQobGluZVZpZXcuZ3V0dGVyQmFja2dyb3VuZCk7XFxuICAgICAgbGluZVZpZXcuZ3V0dGVyQmFja2dyb3VuZCA9IG51bGw7XFxuICAgIH1cXG4gICAgaWYgKGxpbmVWaWV3LmxpbmUuZ3V0dGVyQ2xhc3MpIHtcXG4gICAgICB2YXIgd3JhcCA9IGVuc3VyZUxpbmVXcmFwcGVkKGxpbmVWaWV3KTtcXG4gICAgICBsaW5lVmlldy5ndXR0ZXJCYWNrZ3JvdW5kID0gZWx0KFxcXCJkaXZcXFwiLCBudWxsLCBcXFwiQ29kZU1pcnJvci1ndXR0ZXItYmFja2dyb3VuZCBcXFwiICsgbGluZVZpZXcubGluZS5ndXR0ZXJDbGFzcyxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcXCJsZWZ0OiBcXFwiICsgKGNtLm9wdGlvbnMuZml4ZWRHdXR0ZXIgPyBkaW1zLmZpeGVkUG9zIDogLWRpbXMuZ3V0dGVyVG90YWxXaWR0aCkgK1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxcInB4OyB3aWR0aDogXFxcIiArIGRpbXMuZ3V0dGVyVG90YWxXaWR0aCArIFxcXCJweFxcXCIpO1xcbiAgICAgIHdyYXAuaW5zZXJ0QmVmb3JlKGxpbmVWaWV3Lmd1dHRlckJhY2tncm91bmQsIGxpbmVWaWV3LnRleHQpO1xcbiAgICB9XFxuICAgIHZhciBtYXJrZXJzID0gbGluZVZpZXcubGluZS5ndXR0ZXJNYXJrZXJzO1xcbiAgICBpZiAoY20ub3B0aW9ucy5saW5lTnVtYmVycyB8fCBtYXJrZXJzKSB7XFxuICAgICAgdmFyIHdyYXAgPSBlbnN1cmVMaW5lV3JhcHBlZChsaW5lVmlldyk7XFxuICAgICAgdmFyIGd1dHRlcldyYXAgPSBsaW5lVmlldy5ndXR0ZXIgPSBlbHQoXFxcImRpdlxcXCIsIG51bGwsIFxcXCJDb2RlTWlycm9yLWd1dHRlci13cmFwcGVyXFxcIiwgXFxcImxlZnQ6IFxcXCIgK1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChjbS5vcHRpb25zLmZpeGVkR3V0dGVyID8gZGltcy5maXhlZFBvcyA6IC1kaW1zLmd1dHRlclRvdGFsV2lkdGgpICsgXFxcInB4XFxcIik7XFxuICAgICAgY20uZGlzcGxheS5pbnB1dC5zZXRVbmVkaXRhYmxlKGd1dHRlcldyYXApO1xcbiAgICAgIHdyYXAuaW5zZXJ0QmVmb3JlKGd1dHRlcldyYXAsIGxpbmVWaWV3LnRleHQpO1xcbiAgICAgIGlmIChsaW5lVmlldy5saW5lLmd1dHRlckNsYXNzKVxcbiAgICAgICAgZ3V0dGVyV3JhcC5jbGFzc05hbWUgKz0gXFxcIiBcXFwiICsgbGluZVZpZXcubGluZS5ndXR0ZXJDbGFzcztcXG4gICAgICBpZiAoY20ub3B0aW9ucy5saW5lTnVtYmVycyAmJiAoIW1hcmtlcnMgfHwgIW1hcmtlcnNbXFxcIkNvZGVNaXJyb3ItbGluZW51bWJlcnNcXFwiXSkpXFxuICAgICAgICBsaW5lVmlldy5saW5lTnVtYmVyID0gZ3V0dGVyV3JhcC5hcHBlbmRDaGlsZChcXG4gICAgICAgICAgZWx0KFxcXCJkaXZcXFwiLCBsaW5lTnVtYmVyRm9yKGNtLm9wdGlvbnMsIGxpbmVOKSxcXG4gICAgICAgICAgICAgIFxcXCJDb2RlTWlycm9yLWxpbmVudW1iZXIgQ29kZU1pcnJvci1ndXR0ZXItZWx0XFxcIixcXG4gICAgICAgICAgICAgIFxcXCJsZWZ0OiBcXFwiICsgZGltcy5ndXR0ZXJMZWZ0W1xcXCJDb2RlTWlycm9yLWxpbmVudW1iZXJzXFxcIl0gKyBcXFwicHg7IHdpZHRoOiBcXFwiXFxuICAgICAgICAgICAgICArIGNtLmRpc3BsYXkubGluZU51bUlubmVyV2lkdGggKyBcXFwicHhcXFwiKSk7XFxuICAgICAgaWYgKG1hcmtlcnMpIGZvciAodmFyIGsgPSAwOyBrIDwgY20ub3B0aW9ucy5ndXR0ZXJzLmxlbmd0aDsgKytrKSB7XFxuICAgICAgICB2YXIgaWQgPSBjbS5vcHRpb25zLmd1dHRlcnNba10sIGZvdW5kID0gbWFya2Vycy5oYXNPd25Qcm9wZXJ0eShpZCkgJiYgbWFya2Vyc1tpZF07XFxuICAgICAgICBpZiAoZm91bmQpXFxuICAgICAgICAgIGd1dHRlcldyYXAuYXBwZW5kQ2hpbGQoZWx0KFxcXCJkaXZcXFwiLCBbZm91bmRdLCBcXFwiQ29kZU1pcnJvci1ndXR0ZXItZWx0XFxcIiwgXFxcImxlZnQ6IFxcXCIgK1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaW1zLmd1dHRlckxlZnRbaWRdICsgXFxcInB4OyB3aWR0aDogXFxcIiArIGRpbXMuZ3V0dGVyV2lkdGhbaWRdICsgXFxcInB4XFxcIikpO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgfVxcblxcbiAgZnVuY3Rpb24gdXBkYXRlTGluZVdpZGdldHMoY20sIGxpbmVWaWV3LCBkaW1zKSB7XFxuICAgIGlmIChsaW5lVmlldy5hbGlnbmFibGUpIGxpbmVWaWV3LmFsaWduYWJsZSA9IG51bGw7XFxuICAgIGZvciAodmFyIG5vZGUgPSBsaW5lVmlldy5ub2RlLmZpcnN0Q2hpbGQsIG5leHQ7IG5vZGU7IG5vZGUgPSBuZXh0KSB7XFxuICAgICAgdmFyIG5leHQgPSBub2RlLm5leHRTaWJsaW5nO1xcbiAgICAgIGlmIChub2RlLmNsYXNzTmFtZSA9PSBcXFwiQ29kZU1pcnJvci1saW5ld2lkZ2V0XFxcIilcXG4gICAgICAgIGxpbmVWaWV3Lm5vZGUucmVtb3ZlQ2hpbGQobm9kZSk7XFxuICAgIH1cXG4gICAgaW5zZXJ0TGluZVdpZGdldHMoY20sIGxpbmVWaWV3LCBkaW1zKTtcXG4gIH1cXG5cXG4gIC8vIEJ1aWxkIGEgbGluZSdzIERPTSByZXByZXNlbnRhdGlvbiBmcm9tIHNjcmF0Y2hcXG4gIGZ1bmN0aW9uIGJ1aWxkTGluZUVsZW1lbnQoY20sIGxpbmVWaWV3LCBsaW5lTiwgZGltcykge1xcbiAgICB2YXIgYnVpbHQgPSBnZXRMaW5lQ29udGVudChjbSwgbGluZVZpZXcpO1xcbiAgICBsaW5lVmlldy50ZXh0ID0gbGluZVZpZXcubm9kZSA9IGJ1aWx0LnByZTtcXG4gICAgaWYgKGJ1aWx0LmJnQ2xhc3MpIGxpbmVWaWV3LmJnQ2xhc3MgPSBidWlsdC5iZ0NsYXNzO1xcbiAgICBpZiAoYnVpbHQudGV4dENsYXNzKSBsaW5lVmlldy50ZXh0Q2xhc3MgPSBidWlsdC50ZXh0Q2xhc3M7XFxuXFxuICAgIHVwZGF0ZUxpbmVDbGFzc2VzKGxpbmVWaWV3KTtcXG4gICAgdXBkYXRlTGluZUd1dHRlcihjbSwgbGluZVZpZXcsIGxpbmVOLCBkaW1zKTtcXG4gICAgaW5zZXJ0TGluZVdpZGdldHMoY20sIGxpbmVWaWV3LCBkaW1zKTtcXG4gICAgcmV0dXJuIGxpbmVWaWV3Lm5vZGU7XFxuICB9XFxuXFxuICAvLyBBIGxpbmVWaWV3IG1heSBjb250YWluIG11bHRpcGxlIGxvZ2ljYWwgbGluZXMgKHdoZW4gbWVyZ2VkIGJ5XFxuICAvLyBjb2xsYXBzZWQgc3BhbnMpLiBUaGUgd2lkZ2V0cyBmb3IgYWxsIG9mIHRoZW0gbmVlZCB0byBiZSBkcmF3bi5cXG4gIGZ1bmN0aW9uIGluc2VydExpbmVXaWRnZXRzKGNtLCBsaW5lVmlldywgZGltcykge1xcbiAgICBpbnNlcnRMaW5lV2lkZ2V0c0ZvcihjbSwgbGluZVZpZXcubGluZSwgbGluZVZpZXcsIGRpbXMsIHRydWUpO1xcbiAgICBpZiAobGluZVZpZXcucmVzdCkgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lVmlldy5yZXN0Lmxlbmd0aDsgaSsrKVxcbiAgICAgIGluc2VydExpbmVXaWRnZXRzRm9yKGNtLCBsaW5lVmlldy5yZXN0W2ldLCBsaW5lVmlldywgZGltcywgZmFsc2UpO1xcbiAgfVxcblxcbiAgZnVuY3Rpb24gaW5zZXJ0TGluZVdpZGdldHNGb3IoY20sIGxpbmUsIGxpbmVWaWV3LCBkaW1zLCBhbGxvd0Fib3ZlKSB7XFxuICAgIGlmICghbGluZS53aWRnZXRzKSByZXR1cm47XFxuICAgIHZhciB3cmFwID0gZW5zdXJlTGluZVdyYXBwZWQobGluZVZpZXcpO1xcbiAgICBmb3IgKHZhciBpID0gMCwgd3MgPSBsaW5lLndpZGdldHM7IGkgPCB3cy5sZW5ndGg7ICsraSkge1xcbiAgICAgIHZhciB3aWRnZXQgPSB3c1tpXSwgbm9kZSA9IGVsdChcXFwiZGl2XFxcIiwgW3dpZGdldC5ub2RlXSwgXFxcIkNvZGVNaXJyb3ItbGluZXdpZGdldFxcXCIpO1xcbiAgICAgIGlmICghd2lkZ2V0LmhhbmRsZU1vdXNlRXZlbnRzKSBub2RlLnNldEF0dHJpYnV0ZShcXFwiY20taWdub3JlLWV2ZW50c1xcXCIsIFxcXCJ0cnVlXFxcIik7XFxuICAgICAgcG9zaXRpb25MaW5lV2lkZ2V0KHdpZGdldCwgbm9kZSwgbGluZVZpZXcsIGRpbXMpO1xcbiAgICAgIGNtLmRpc3BsYXkuaW5wdXQuc2V0VW5lZGl0YWJsZShub2RlKTtcXG4gICAgICBpZiAoYWxsb3dBYm92ZSAmJiB3aWRnZXQuYWJvdmUpXFxuICAgICAgICB3cmFwLmluc2VydEJlZm9yZShub2RlLCBsaW5lVmlldy5ndXR0ZXIgfHwgbGluZVZpZXcudGV4dCk7XFxuICAgICAgZWxzZVxcbiAgICAgICAgd3JhcC5hcHBlbmRDaGlsZChub2RlKTtcXG4gICAgICBzaWduYWxMYXRlcih3aWRnZXQsIFxcXCJyZWRyYXdcXFwiKTtcXG4gICAgfVxcbiAgfVxcblxcbiAgZnVuY3Rpb24gcG9zaXRpb25MaW5lV2lkZ2V0KHdpZGdldCwgbm9kZSwgbGluZVZpZXcsIGRpbXMpIHtcXG4gICAgaWYgKHdpZGdldC5ub0hTY3JvbGwpIHtcXG4gICAgICAobGluZVZpZXcuYWxpZ25hYmxlIHx8IChsaW5lVmlldy5hbGlnbmFibGUgPSBbXSkpLnB1c2gobm9kZSk7XFxuICAgICAgdmFyIHdpZHRoID0gZGltcy53cmFwcGVyV2lkdGg7XFxuICAgICAgbm9kZS5zdHlsZS5sZWZ0ID0gZGltcy5maXhlZFBvcyArIFxcXCJweFxcXCI7XFxuICAgICAgaWYgKCF3aWRnZXQuY292ZXJHdXR0ZXIpIHtcXG4gICAgICAgIHdpZHRoIC09IGRpbXMuZ3V0dGVyVG90YWxXaWR0aDtcXG4gICAgICAgIG5vZGUuc3R5bGUucGFkZGluZ0xlZnQgPSBkaW1zLmd1dHRlclRvdGFsV2lkdGggKyBcXFwicHhcXFwiO1xcbiAgICAgIH1cXG4gICAgICBub2RlLnN0eWxlLndpZHRoID0gd2lkdGggKyBcXFwicHhcXFwiO1xcbiAgICB9XFxuICAgIGlmICh3aWRnZXQuY292ZXJHdXR0ZXIpIHtcXG4gICAgICBub2RlLnN0eWxlLnpJbmRleCA9IDU7XFxuICAgICAgbm9kZS5zdHlsZS5wb3NpdGlvbiA9IFxcXCJyZWxhdGl2ZVxcXCI7XFxuICAgICAgaWYgKCF3aWRnZXQubm9IU2Nyb2xsKSBub2RlLnN0eWxlLm1hcmdpbkxlZnQgPSAtZGltcy5ndXR0ZXJUb3RhbFdpZHRoICsgXFxcInB4XFxcIjtcXG4gICAgfVxcbiAgfVxcblxcbiAgLy8gUE9TSVRJT04gT0JKRUNUXFxuXFxuICAvLyBBIFBvcyBpbnN0YW5jZSByZXByZXNlbnRzIGEgcG9zaXRpb24gd2l0aGluIHRoZSB0ZXh0LlxcbiAgdmFyIFBvcyA9IENvZGVNaXJyb3IuUG9zID0gZnVuY3Rpb24obGluZSwgY2gpIHtcXG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFBvcykpIHJldHVybiBuZXcgUG9zKGxpbmUsIGNoKTtcXG4gICAgdGhpcy5saW5lID0gbGluZTsgdGhpcy5jaCA9IGNoO1xcbiAgfTtcXG5cXG4gIC8vIENvbXBhcmUgdHdvIHBvc2l0aW9ucywgcmV0dXJuIDAgaWYgdGhleSBhcmUgdGhlIHNhbWUsIGEgbmVnYXRpdmVcXG4gIC8vIG51bWJlciB3aGVuIGEgaXMgbGVzcywgYW5kIGEgcG9zaXRpdmUgbnVtYmVyIG90aGVyd2lzZS5cXG4gIHZhciBjbXAgPSBDb2RlTWlycm9yLmNtcFBvcyA9IGZ1bmN0aW9uKGEsIGIpIHsgcmV0dXJuIGEubGluZSAtIGIubGluZSB8fCBhLmNoIC0gYi5jaDsgfTtcXG5cXG4gIGZ1bmN0aW9uIGNvcHlQb3MoeCkge3JldHVybiBQb3MoeC5saW5lLCB4LmNoKTt9XFxuICBmdW5jdGlvbiBtYXhQb3MoYSwgYikgeyByZXR1cm4gY21wKGEsIGIpIDwgMCA/IGIgOiBhOyB9XFxuICBmdW5jdGlvbiBtaW5Qb3MoYSwgYikgeyByZXR1cm4gY21wKGEsIGIpIDwgMCA/IGEgOiBiOyB9XFxuXFxuICAvLyBJTlBVVCBIQU5ETElOR1xcblxcbiAgZnVuY3Rpb24gZW5zdXJlRm9jdXMoY20pIHtcXG4gICAgaWYgKCFjbS5zdGF0ZS5mb2N1c2VkKSB7IGNtLmRpc3BsYXkuaW5wdXQuZm9jdXMoKTsgb25Gb2N1cyhjbSk7IH1cXG4gIH1cXG5cXG4gIC8vIFRoaXMgd2lsbCBiZSBzZXQgdG8gYSB7bGluZVdpc2U6IGJvb2wsIHRleHQ6IFtzdHJpbmddfSBvYmplY3QsIHNvXFxuICAvLyB0aGF0LCB3aGVuIHBhc3RpbmcsIHdlIGtub3cgd2hhdCBraW5kIG9mIHNlbGVjdGlvbnMgdGhlIGNvcGllZFxcbiAgLy8gdGV4dCB3YXMgbWFkZSBvdXQgb2YuXFxuICB2YXIgbGFzdENvcGllZCA9IG51bGw7XFxuXFxuICBmdW5jdGlvbiBhcHBseVRleHRJbnB1dChjbSwgaW5zZXJ0ZWQsIGRlbGV0ZWQsIHNlbCwgb3JpZ2luKSB7XFxuICAgIHZhciBkb2MgPSBjbS5kb2M7XFxuICAgIGNtLmRpc3BsYXkuc2hpZnQgPSBmYWxzZTtcXG4gICAgaWYgKCFzZWwpIHNlbCA9IGRvYy5zZWw7XFxuXFxuICAgIHZhciBwYXN0ZSA9IGNtLnN0YXRlLnBhc3RlSW5jb21pbmcgfHwgb3JpZ2luID09IFxcXCJwYXN0ZVxcXCI7XFxuICAgIHZhciB0ZXh0TGluZXMgPSBkb2Muc3BsaXRMaW5lcyhpbnNlcnRlZCksIG11bHRpUGFzdGUgPSBudWxsXFxuICAgIC8vIFdoZW4gcGFzaW5nIE4gbGluZXMgaW50byBOIHNlbGVjdGlvbnMsIGluc2VydCBvbmUgbGluZSBwZXIgc2VsZWN0aW9uXFxuICAgIGlmIChwYXN0ZSAmJiBzZWwucmFuZ2VzLmxlbmd0aCA+IDEpIHtcXG4gICAgICBpZiAobGFzdENvcGllZCAmJiBsYXN0Q29waWVkLnRleHQuam9pbihcXFwiXFxcXG5cXFwiKSA9PSBpbnNlcnRlZCkge1xcbiAgICAgICAgaWYgKHNlbC5yYW5nZXMubGVuZ3RoICUgbGFzdENvcGllZC50ZXh0Lmxlbmd0aCA9PSAwKSB7XFxuICAgICAgICAgIG11bHRpUGFzdGUgPSBbXTtcXG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXN0Q29waWVkLnRleHQubGVuZ3RoOyBpKyspXFxuICAgICAgICAgICAgbXVsdGlQYXN0ZS5wdXNoKGRvYy5zcGxpdExpbmVzKGxhc3RDb3BpZWQudGV4dFtpXSkpO1xcbiAgICAgICAgfVxcbiAgICAgIH0gZWxzZSBpZiAodGV4dExpbmVzLmxlbmd0aCA9PSBzZWwucmFuZ2VzLmxlbmd0aCkge1xcbiAgICAgICAgbXVsdGlQYXN0ZSA9IG1hcCh0ZXh0TGluZXMsIGZ1bmN0aW9uKGwpIHsgcmV0dXJuIFtsXTsgfSk7XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIC8vIE5vcm1hbCBiZWhhdmlvciBpcyB0byBpbnNlcnQgdGhlIG5ldyB0ZXh0IGludG8gZXZlcnkgc2VsZWN0aW9uXFxuICAgIGZvciAodmFyIGkgPSBzZWwucmFuZ2VzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XFxuICAgICAgdmFyIHJhbmdlID0gc2VsLnJhbmdlc1tpXTtcXG4gICAgICB2YXIgZnJvbSA9IHJhbmdlLmZyb20oKSwgdG8gPSByYW5nZS50bygpO1xcbiAgICAgIGlmIChyYW5nZS5lbXB0eSgpKSB7XFxuICAgICAgICBpZiAoZGVsZXRlZCAmJiBkZWxldGVkID4gMCkgLy8gSGFuZGxlIGRlbGV0aW9uXFxuICAgICAgICAgIGZyb20gPSBQb3MoZnJvbS5saW5lLCBmcm9tLmNoIC0gZGVsZXRlZCk7XFxuICAgICAgICBlbHNlIGlmIChjbS5zdGF0ZS5vdmVyd3JpdGUgJiYgIXBhc3RlKSAvLyBIYW5kbGUgb3ZlcndyaXRlXFxuICAgICAgICAgIHRvID0gUG9zKHRvLmxpbmUsIE1hdGgubWluKGdldExpbmUoZG9jLCB0by5saW5lKS50ZXh0Lmxlbmd0aCwgdG8uY2ggKyBsc3QodGV4dExpbmVzKS5sZW5ndGgpKTtcXG4gICAgICAgIGVsc2UgaWYgKGxhc3RDb3BpZWQgJiYgbGFzdENvcGllZC5saW5lV2lzZSAmJiBsYXN0Q29waWVkLnRleHQuam9pbihcXFwiXFxcXG5cXFwiKSA9PSBpbnNlcnRlZClcXG4gICAgICAgICAgZnJvbSA9IHRvID0gUG9zKGZyb20ubGluZSwgMClcXG4gICAgICB9XFxuICAgICAgdmFyIHVwZGF0ZUlucHV0ID0gY20uY3VyT3AudXBkYXRlSW5wdXQ7XFxuICAgICAgdmFyIGNoYW5nZUV2ZW50ID0ge2Zyb206IGZyb20sIHRvOiB0bywgdGV4dDogbXVsdGlQYXN0ZSA/IG11bHRpUGFzdGVbaSAlIG11bHRpUGFzdGUubGVuZ3RoXSA6IHRleHRMaW5lcyxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luOiBvcmlnaW4gfHwgKHBhc3RlID8gXFxcInBhc3RlXFxcIiA6IGNtLnN0YXRlLmN1dEluY29taW5nID8gXFxcImN1dFxcXCIgOiBcXFwiK2lucHV0XFxcIil9O1xcbiAgICAgIG1ha2VDaGFuZ2UoY20uZG9jLCBjaGFuZ2VFdmVudCk7XFxuICAgICAgc2lnbmFsTGF0ZXIoY20sIFxcXCJpbnB1dFJlYWRcXFwiLCBjbSwgY2hhbmdlRXZlbnQpO1xcbiAgICB9XFxuICAgIGlmIChpbnNlcnRlZCAmJiAhcGFzdGUpXFxuICAgICAgdHJpZ2dlckVsZWN0cmljKGNtLCBpbnNlcnRlZCk7XFxuXFxuICAgIGVuc3VyZUN1cnNvclZpc2libGUoY20pO1xcbiAgICBjbS5jdXJPcC51cGRhdGVJbnB1dCA9IHVwZGF0ZUlucHV0O1xcbiAgICBjbS5jdXJPcC50eXBpbmcgPSB0cnVlO1xcbiAgICBjbS5zdGF0ZS5wYXN0ZUluY29taW5nID0gY20uc3RhdGUuY3V0SW5jb21pbmcgPSBmYWxzZTtcXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIGhhbmRsZVBhc3RlKGUsIGNtKSB7XFxuICAgIHZhciBwYXN0ZWQgPSBlLmNsaXBib2FyZERhdGEgJiYgZS5jbGlwYm9hcmREYXRhLmdldERhdGEoXFxcIlRleHRcXFwiKTtcXG4gICAgaWYgKHBhc3RlZCkge1xcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcXG4gICAgICBpZiAoIWNtLmlzUmVhZE9ubHkoKSAmJiAhY20ub3B0aW9ucy5kaXNhYmxlSW5wdXQpXFxuICAgICAgICBydW5Jbk9wKGNtLCBmdW5jdGlvbigpIHsgYXBwbHlUZXh0SW5wdXQoY20sIHBhc3RlZCwgMCwgbnVsbCwgXFxcInBhc3RlXFxcIik7IH0pO1xcbiAgICAgIHJldHVybiB0cnVlO1xcbiAgICB9XFxuICB9XFxuXFxuICBmdW5jdGlvbiB0cmlnZ2VyRWxlY3RyaWMoY20sIGluc2VydGVkKSB7XFxuICAgIC8vIFdoZW4gYW4gJ2VsZWN0cmljJyBjaGFyYWN0ZXIgaXMgaW5zZXJ0ZWQsIGltbWVkaWF0ZWx5IHRyaWdnZXIgYSByZWluZGVudFxcbiAgICBpZiAoIWNtLm9wdGlvbnMuZWxlY3RyaWNDaGFycyB8fCAhY20ub3B0aW9ucy5zbWFydEluZGVudCkgcmV0dXJuO1xcbiAgICB2YXIgc2VsID0gY20uZG9jLnNlbDtcXG5cXG4gICAgZm9yICh2YXIgaSA9IHNlbC5yYW5nZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcXG4gICAgICB2YXIgcmFuZ2UgPSBzZWwucmFuZ2VzW2ldO1xcbiAgICAgIGlmIChyYW5nZS5oZWFkLmNoID4gMTAwIHx8IChpICYmIHNlbC5yYW5nZXNbaSAtIDFdLmhlYWQubGluZSA9PSByYW5nZS5oZWFkLmxpbmUpKSBjb250aW51ZTtcXG4gICAgICB2YXIgbW9kZSA9IGNtLmdldE1vZGVBdChyYW5nZS5oZWFkKTtcXG4gICAgICB2YXIgaW5kZW50ZWQgPSBmYWxzZTtcXG4gICAgICBpZiAobW9kZS5lbGVjdHJpY0NoYXJzKSB7XFxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG1vZGUuZWxlY3RyaWNDaGFycy5sZW5ndGg7IGorKylcXG4gICAgICAgICAgaWYgKGluc2VydGVkLmluZGV4T2YobW9kZS5lbGVjdHJpY0NoYXJzLmNoYXJBdChqKSkgPiAtMSkge1xcbiAgICAgICAgICAgIGluZGVudGVkID0gaW5kZW50TGluZShjbSwgcmFuZ2UuaGVhZC5saW5lLCBcXFwic21hcnRcXFwiKTtcXG4gICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgfVxcbiAgICAgIH0gZWxzZSBpZiAobW9kZS5lbGVjdHJpY0lucHV0KSB7XFxuICAgICAgICBpZiAobW9kZS5lbGVjdHJpY0lucHV0LnRlc3QoZ2V0TGluZShjbS5kb2MsIHJhbmdlLmhlYWQubGluZSkudGV4dC5zbGljZSgwLCByYW5nZS5oZWFkLmNoKSkpXFxuICAgICAgICAgIGluZGVudGVkID0gaW5kZW50TGluZShjbSwgcmFuZ2UuaGVhZC5saW5lLCBcXFwic21hcnRcXFwiKTtcXG4gICAgICB9XFxuICAgICAgaWYgKGluZGVudGVkKSBzaWduYWxMYXRlcihjbSwgXFxcImVsZWN0cmljSW5wdXRcXFwiLCBjbSwgcmFuZ2UuaGVhZC5saW5lKTtcXG4gICAgfVxcbiAgfVxcblxcbiAgZnVuY3Rpb24gY29weWFibGVSYW5nZXMoY20pIHtcXG4gICAgdmFyIHRleHQgPSBbXSwgcmFuZ2VzID0gW107XFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY20uZG9jLnNlbC5yYW5nZXMubGVuZ3RoOyBpKyspIHtcXG4gICAgICB2YXIgbGluZSA9IGNtLmRvYy5zZWwucmFuZ2VzW2ldLmhlYWQubGluZTtcXG4gICAgICB2YXIgbGluZVJhbmdlID0ge2FuY2hvcjogUG9zKGxpbmUsIDApLCBoZWFkOiBQb3MobGluZSArIDEsIDApfTtcXG4gICAgICByYW5nZXMucHVzaChsaW5lUmFuZ2UpO1xcbiAgICAgIHRleHQucHVzaChjbS5nZXRSYW5nZShsaW5lUmFuZ2UuYW5jaG9yLCBsaW5lUmFuZ2UuaGVhZCkpO1xcbiAgICB9XFxuICAgIHJldHVybiB7dGV4dDogdGV4dCwgcmFuZ2VzOiByYW5nZXN9O1xcbiAgfVxcblxcbiAgZnVuY3Rpb24gZGlzYWJsZUJyb3dzZXJNYWdpYyhmaWVsZCwgc3BlbGxjaGVjaykge1xcbiAgICBmaWVsZC5zZXRBdHRyaWJ1dGUoXFxcImF1dG9jb3JyZWN0XFxcIiwgXFxcIm9mZlxcXCIpO1xcbiAgICBmaWVsZC5zZXRBdHRyaWJ1dGUoXFxcImF1dG9jYXBpdGFsaXplXFxcIiwgXFxcIm9mZlxcXCIpO1xcbiAgICBmaWVsZC5zZXRBdHRyaWJ1dGUoXFxcInNwZWxsY2hlY2tcXFwiLCAhIXNwZWxsY2hlY2spO1xcbiAgfVxcblxcbiAgLy8gVEVYVEFSRUEgSU5QVVQgU1RZTEVcXG5cXG4gIGZ1bmN0aW9uIFRleHRhcmVhSW5wdXQoY20pIHtcXG4gICAgdGhpcy5jbSA9IGNtO1xcbiAgICAvLyBTZWUgaW5wdXQucG9sbCBhbmQgaW5wdXQucmVzZXRcXG4gICAgdGhpcy5wcmV2SW5wdXQgPSBcXFwiXFxcIjtcXG5cXG4gICAgLy8gRmxhZyB0aGF0IGluZGljYXRlcyB3aGV0aGVyIHdlIGV4cGVjdCBpbnB1dCB0byBhcHBlYXIgcmVhbCBzb29uXFxuICAgIC8vIG5vdyAoYWZ0ZXIgc29tZSBldmVudCBsaWtlICdrZXlwcmVzcycgb3IgJ2lucHV0JykgYW5kIGFyZVxcbiAgICAvLyBwb2xsaW5nIGludGVuc2l2ZWx5LlxcbiAgICB0aGlzLnBvbGxpbmdGYXN0ID0gZmFsc2U7XFxuICAgIC8vIFNlbGYtcmVzZXR0aW5nIHRpbWVvdXQgZm9yIHRoZSBwb2xsZXJcXG4gICAgdGhpcy5wb2xsaW5nID0gbmV3IERlbGF5ZWQoKTtcXG4gICAgLy8gVHJhY2tzIHdoZW4gaW5wdXQucmVzZXQgaGFzIHB1bnRlZCB0byBqdXN0IHB1dHRpbmcgYSBzaG9ydFxcbiAgICAvLyBzdHJpbmcgaW50byB0aGUgdGV4dGFyZWEgaW5zdGVhZCBvZiB0aGUgZnVsbCBzZWxlY3Rpb24uXFxuICAgIHRoaXMuaW5hY2N1cmF0ZVNlbGVjdGlvbiA9IGZhbHNlO1xcbiAgICAvLyBVc2VkIHRvIHdvcmsgYXJvdW5kIElFIGlzc3VlIHdpdGggc2VsZWN0aW9uIGJlaW5nIGZvcmdvdHRlbiB3aGVuIGZvY3VzIG1vdmVzIGF3YXkgZnJvbSB0ZXh0YXJlYVxcbiAgICB0aGlzLmhhc1NlbGVjdGlvbiA9IGZhbHNlO1xcbiAgICB0aGlzLmNvbXBvc2luZyA9IG51bGw7XFxuICB9O1xcblxcbiAgZnVuY3Rpb24gaGlkZGVuVGV4dGFyZWEoKSB7XFxuICAgIHZhciB0ZSA9IGVsdChcXFwidGV4dGFyZWFcXFwiLCBudWxsLCBudWxsLCBcXFwicG9zaXRpb246IGFic29sdXRlOyBib3R0b206IC0xZW07IHBhZGRpbmc6IDA7IHdpZHRoOiAxcHg7IGhlaWdodDogMWVtOyBvdXRsaW5lOiBub25lXFxcIik7XFxuICAgIHZhciBkaXYgPSBlbHQoXFxcImRpdlxcXCIsIFt0ZV0sIG51bGwsIFxcXCJvdmVyZmxvdzogaGlkZGVuOyBwb3NpdGlvbjogcmVsYXRpdmU7IHdpZHRoOiAzcHg7IGhlaWdodDogMHB4O1xcXCIpO1xcbiAgICAvLyBUaGUgdGV4dGFyZWEgaXMga2VwdCBwb3NpdGlvbmVkIG5lYXIgdGhlIGN1cnNvciB0byBwcmV2ZW50IHRoZVxcbiAgICAvLyBmYWN0IHRoYXQgaXQnbGwgYmUgc2Nyb2xsZWQgaW50byB2aWV3IG9uIGlucHV0IGZyb20gc2Nyb2xsaW5nXFxuICAgIC8vIG91ciBmYWtlIGN1cnNvciBvdXQgb2Ygdmlldy4gT24gd2Via2l0LCB3aGVuIHdyYXA9b2ZmLCBwYXN0ZSBpc1xcbiAgICAvLyB2ZXJ5IHNsb3cuIFNvIG1ha2UgdGhlIGFyZWEgd2lkZSBpbnN0ZWFkLlxcbiAgICBpZiAod2Via2l0KSB0ZS5zdHlsZS53aWR0aCA9IFxcXCIxMDAwcHhcXFwiO1xcbiAgICBlbHNlIHRlLnNldEF0dHJpYnV0ZShcXFwid3JhcFxcXCIsIFxcXCJvZmZcXFwiKTtcXG4gICAgLy8gSWYgYm9yZGVyOiAwOyAtLSBpT1MgZmFpbHMgdG8gb3BlbiBrZXlib2FyZCAoaXNzdWUgIzEyODcpXFxuICAgIGlmIChpb3MpIHRlLnN0eWxlLmJvcmRlciA9IFxcXCIxcHggc29saWQgYmxhY2tcXFwiO1xcbiAgICBkaXNhYmxlQnJvd3Nlck1hZ2ljKHRlKTtcXG4gICAgcmV0dXJuIGRpdjtcXG4gIH1cXG5cXG4gIFRleHRhcmVhSW5wdXQucHJvdG90eXBlID0gY29weU9iaih7XFxuICAgIGluaXQ6IGZ1bmN0aW9uKGRpc3BsYXkpIHtcXG4gICAgICB2YXIgaW5wdXQgPSB0aGlzLCBjbSA9IHRoaXMuY207XFxuXFxuICAgICAgLy8gV3JhcHMgYW5kIGhpZGVzIGlucHV0IHRleHRhcmVhXFxuICAgICAgdmFyIGRpdiA9IHRoaXMud3JhcHBlciA9IGhpZGRlblRleHRhcmVhKCk7XFxuICAgICAgLy8gVGhlIHNlbWloaWRkZW4gdGV4dGFyZWEgdGhhdCBpcyBmb2N1c2VkIHdoZW4gdGhlIGVkaXRvciBpc1xcbiAgICAgIC8vIGZvY3VzZWQsIGFuZCByZWNlaXZlcyBpbnB1dC5cXG4gICAgICB2YXIgdGUgPSB0aGlzLnRleHRhcmVhID0gZGl2LmZpcnN0Q2hpbGQ7XFxuICAgICAgZGlzcGxheS53cmFwcGVyLmluc2VydEJlZm9yZShkaXYsIGRpc3BsYXkud3JhcHBlci5maXJzdENoaWxkKTtcXG5cXG4gICAgICAvLyBOZWVkZWQgdG8gaGlkZSBiaWcgYmx1ZSBibGlua2luZyBjdXJzb3Igb24gTW9iaWxlIFNhZmFyaSAoZG9lc24ndCBzZWVtIHRvIHdvcmsgaW4gaU9TIDggYW55bW9yZSlcXG4gICAgICBpZiAoaW9zKSB0ZS5zdHlsZS53aWR0aCA9IFxcXCIwcHhcXFwiO1xcblxcbiAgICAgIG9uKHRlLCBcXFwiaW5wdXRcXFwiLCBmdW5jdGlvbigpIHtcXG4gICAgICAgIGlmIChpZSAmJiBpZV92ZXJzaW9uID49IDkgJiYgaW5wdXQuaGFzU2VsZWN0aW9uKSBpbnB1dC5oYXNTZWxlY3Rpb24gPSBudWxsO1xcbiAgICAgICAgaW5wdXQucG9sbCgpO1xcbiAgICAgIH0pO1xcblxcbiAgICAgIG9uKHRlLCBcXFwicGFzdGVcXFwiLCBmdW5jdGlvbihlKSB7XFxuICAgICAgICBpZiAoc2lnbmFsRE9NRXZlbnQoY20sIGUpIHx8IGhhbmRsZVBhc3RlKGUsIGNtKSkgcmV0dXJuXFxuXFxuICAgICAgICBjbS5zdGF0ZS5wYXN0ZUluY29taW5nID0gdHJ1ZTtcXG4gICAgICAgIGlucHV0LmZhc3RQb2xsKCk7XFxuICAgICAgfSk7XFxuXFxuICAgICAgZnVuY3Rpb24gcHJlcGFyZUNvcHlDdXQoZSkge1xcbiAgICAgICAgaWYgKHNpZ25hbERPTUV2ZW50KGNtLCBlKSkgcmV0dXJuXFxuICAgICAgICBpZiAoY20uc29tZXRoaW5nU2VsZWN0ZWQoKSkge1xcbiAgICAgICAgICBsYXN0Q29waWVkID0ge2xpbmVXaXNlOiBmYWxzZSwgdGV4dDogY20uZ2V0U2VsZWN0aW9ucygpfTtcXG4gICAgICAgICAgaWYgKGlucHV0LmluYWNjdXJhdGVTZWxlY3Rpb24pIHtcXG4gICAgICAgICAgICBpbnB1dC5wcmV2SW5wdXQgPSBcXFwiXFxcIjtcXG4gICAgICAgICAgICBpbnB1dC5pbmFjY3VyYXRlU2VsZWN0aW9uID0gZmFsc2U7XFxuICAgICAgICAgICAgdGUudmFsdWUgPSBsYXN0Q29waWVkLnRleHQuam9pbihcXFwiXFxcXG5cXFwiKTtcXG4gICAgICAgICAgICBzZWxlY3RJbnB1dCh0ZSk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH0gZWxzZSBpZiAoIWNtLm9wdGlvbnMubGluZVdpc2VDb3B5Q3V0KSB7XFxuICAgICAgICAgIHJldHVybjtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIHZhciByYW5nZXMgPSBjb3B5YWJsZVJhbmdlcyhjbSk7XFxuICAgICAgICAgIGxhc3RDb3BpZWQgPSB7bGluZVdpc2U6IHRydWUsIHRleHQ6IHJhbmdlcy50ZXh0fTtcXG4gICAgICAgICAgaWYgKGUudHlwZSA9PSBcXFwiY3V0XFxcIikge1xcbiAgICAgICAgICAgIGNtLnNldFNlbGVjdGlvbnMocmFuZ2VzLnJhbmdlcywgbnVsbCwgc2VsX2RvbnRTY3JvbGwpO1xcbiAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIGlucHV0LnByZXZJbnB1dCA9IFxcXCJcXFwiO1xcbiAgICAgICAgICAgIHRlLnZhbHVlID0gcmFuZ2VzLnRleHQuam9pbihcXFwiXFxcXG5cXFwiKTtcXG4gICAgICAgICAgICBzZWxlY3RJbnB1dCh0ZSk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIGlmIChlLnR5cGUgPT0gXFxcImN1dFxcXCIpIGNtLnN0YXRlLmN1dEluY29taW5nID0gdHJ1ZTtcXG4gICAgICB9XFxuICAgICAgb24odGUsIFxcXCJjdXRcXFwiLCBwcmVwYXJlQ29weUN1dCk7XFxuICAgICAgb24odGUsIFxcXCJjb3B5XFxcIiwgcHJlcGFyZUNvcHlDdXQpO1xcblxcbiAgICAgIG9uKGRpc3BsYXkuc2Nyb2xsZXIsIFxcXCJwYXN0ZVxcXCIsIGZ1bmN0aW9uKGUpIHtcXG4gICAgICAgIGlmIChldmVudEluV2lkZ2V0KGRpc3BsYXksIGUpIHx8IHNpZ25hbERPTUV2ZW50KGNtLCBlKSkgcmV0dXJuO1xcbiAgICAgICAgY20uc3RhdGUucGFzdGVJbmNvbWluZyA9IHRydWU7XFxuICAgICAgICBpbnB1dC5mb2N1cygpO1xcbiAgICAgIH0pO1xcblxcbiAgICAgIC8vIFByZXZlbnQgbm9ybWFsIHNlbGVjdGlvbiBpbiB0aGUgZWRpdG9yICh3ZSBoYW5kbGUgb3VyIG93bilcXG4gICAgICBvbihkaXNwbGF5LmxpbmVTcGFjZSwgXFxcInNlbGVjdHN0YXJ0XFxcIiwgZnVuY3Rpb24oZSkge1xcbiAgICAgICAgaWYgKCFldmVudEluV2lkZ2V0KGRpc3BsYXksIGUpKSBlX3ByZXZlbnREZWZhdWx0KGUpO1xcbiAgICAgIH0pO1xcblxcbiAgICAgIG9uKHRlLCBcXFwiY29tcG9zaXRpb25zdGFydFxcXCIsIGZ1bmN0aW9uKCkge1xcbiAgICAgICAgdmFyIHN0YXJ0ID0gY20uZ2V0Q3Vyc29yKFxcXCJmcm9tXFxcIik7XFxuICAgICAgICBpZiAoaW5wdXQuY29tcG9zaW5nKSBpbnB1dC5jb21wb3NpbmcucmFuZ2UuY2xlYXIoKVxcbiAgICAgICAgaW5wdXQuY29tcG9zaW5nID0ge1xcbiAgICAgICAgICBzdGFydDogc3RhcnQsXFxuICAgICAgICAgIHJhbmdlOiBjbS5tYXJrVGV4dChzdGFydCwgY20uZ2V0Q3Vyc29yKFxcXCJ0b1xcXCIpLCB7Y2xhc3NOYW1lOiBcXFwiQ29kZU1pcnJvci1jb21wb3NpbmdcXFwifSlcXG4gICAgICAgIH07XFxuICAgICAgfSk7XFxuICAgICAgb24odGUsIFxcXCJjb21wb3NpdGlvbmVuZFxcXCIsIGZ1bmN0aW9uKCkge1xcbiAgICAgICAgaWYgKGlucHV0LmNvbXBvc2luZykge1xcbiAgICAgICAgICBpbnB1dC5wb2xsKCk7XFxuICAgICAgICAgIGlucHV0LmNvbXBvc2luZy5yYW5nZS5jbGVhcigpO1xcbiAgICAgICAgICBpbnB1dC5jb21wb3NpbmcgPSBudWxsO1xcbiAgICAgICAgfVxcbiAgICAgIH0pO1xcbiAgICB9LFxcblxcbiAgICBwcmVwYXJlU2VsZWN0aW9uOiBmdW5jdGlvbigpIHtcXG4gICAgICAvLyBSZWRyYXcgdGhlIHNlbGVjdGlvbiBhbmQvb3IgY3Vyc29yXFxuICAgICAgdmFyIGNtID0gdGhpcy5jbSwgZGlzcGxheSA9IGNtLmRpc3BsYXksIGRvYyA9IGNtLmRvYztcXG4gICAgICB2YXIgcmVzdWx0ID0gcHJlcGFyZVNlbGVjdGlvbihjbSk7XFxuXFxuICAgICAgLy8gTW92ZSB0aGUgaGlkZGVuIHRleHRhcmVhIG5lYXIgdGhlIGN1cnNvciB0byBwcmV2ZW50IHNjcm9sbGluZyBhcnRpZmFjdHNcXG4gICAgICBpZiAoY20ub3B0aW9ucy5tb3ZlSW5wdXRXaXRoQ3Vyc29yKSB7XFxuICAgICAgICB2YXIgaGVhZFBvcyA9IGN1cnNvckNvb3JkcyhjbSwgZG9jLnNlbC5wcmltYXJ5KCkuaGVhZCwgXFxcImRpdlxcXCIpO1xcbiAgICAgICAgdmFyIHdyYXBPZmYgPSBkaXNwbGF5LndyYXBwZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIGxpbmVPZmYgPSBkaXNwbGF5LmxpbmVEaXYuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XFxuICAgICAgICByZXN1bHQudGVUb3AgPSBNYXRoLm1heCgwLCBNYXRoLm1pbihkaXNwbGF5LndyYXBwZXIuY2xpZW50SGVpZ2h0IC0gMTAsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWFkUG9zLnRvcCArIGxpbmVPZmYudG9wIC0gd3JhcE9mZi50b3ApKTtcXG4gICAgICAgIHJlc3VsdC50ZUxlZnQgPSBNYXRoLm1heCgwLCBNYXRoLm1pbihkaXNwbGF5LndyYXBwZXIuY2xpZW50V2lkdGggLSAxMCxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWFkUG9zLmxlZnQgKyBsaW5lT2ZmLmxlZnQgLSB3cmFwT2ZmLmxlZnQpKTtcXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIHJlc3VsdDtcXG4gICAgfSxcXG5cXG4gICAgc2hvd1NlbGVjdGlvbjogZnVuY3Rpb24oZHJhd24pIHtcXG4gICAgICB2YXIgY20gPSB0aGlzLmNtLCBkaXNwbGF5ID0gY20uZGlzcGxheTtcXG4gICAgICByZW1vdmVDaGlsZHJlbkFuZEFkZChkaXNwbGF5LmN1cnNvckRpdiwgZHJhd24uY3Vyc29ycyk7XFxuICAgICAgcmVtb3ZlQ2hpbGRyZW5BbmRBZGQoZGlzcGxheS5zZWxlY3Rpb25EaXYsIGRyYXduLnNlbGVjdGlvbik7XFxuICAgICAgaWYgKGRyYXduLnRlVG9wICE9IG51bGwpIHtcXG4gICAgICAgIHRoaXMud3JhcHBlci5zdHlsZS50b3AgPSBkcmF3bi50ZVRvcCArIFxcXCJweFxcXCI7XFxuICAgICAgICB0aGlzLndyYXBwZXIuc3R5bGUubGVmdCA9IGRyYXduLnRlTGVmdCArIFxcXCJweFxcXCI7XFxuICAgICAgfVxcbiAgICB9LFxcblxcbiAgICAvLyBSZXNldCB0aGUgaW5wdXQgdG8gY29ycmVzcG9uZCB0byB0aGUgc2VsZWN0aW9uIChvciB0byBiZSBlbXB0eSxcXG4gICAgLy8gd2hlbiBub3QgdHlwaW5nIGFuZCBub3RoaW5nIGlzIHNlbGVjdGVkKVxcbiAgICByZXNldDogZnVuY3Rpb24odHlwaW5nKSB7XFxuICAgICAgaWYgKHRoaXMuY29udGV4dE1lbnVQZW5kaW5nKSByZXR1cm47XFxuICAgICAgdmFyIG1pbmltYWwsIHNlbGVjdGVkLCBjbSA9IHRoaXMuY20sIGRvYyA9IGNtLmRvYztcXG4gICAgICBpZiAoY20uc29tZXRoaW5nU2VsZWN0ZWQoKSkge1xcbiAgICAgICAgdGhpcy5wcmV2SW5wdXQgPSBcXFwiXFxcIjtcXG4gICAgICAgIHZhciByYW5nZSA9IGRvYy5zZWwucHJpbWFyeSgpO1xcbiAgICAgICAgbWluaW1hbCA9IGhhc0NvcHlFdmVudCAmJlxcbiAgICAgICAgICAocmFuZ2UudG8oKS5saW5lIC0gcmFuZ2UuZnJvbSgpLmxpbmUgPiAxMDAgfHwgKHNlbGVjdGVkID0gY20uZ2V0U2VsZWN0aW9uKCkpLmxlbmd0aCA+IDEwMDApO1xcbiAgICAgICAgdmFyIGNvbnRlbnQgPSBtaW5pbWFsID8gXFxcIi1cXFwiIDogc2VsZWN0ZWQgfHwgY20uZ2V0U2VsZWN0aW9uKCk7XFxuICAgICAgICB0aGlzLnRleHRhcmVhLnZhbHVlID0gY29udGVudDtcXG4gICAgICAgIGlmIChjbS5zdGF0ZS5mb2N1c2VkKSBzZWxlY3RJbnB1dCh0aGlzLnRleHRhcmVhKTtcXG4gICAgICAgIGlmIChpZSAmJiBpZV92ZXJzaW9uID49IDkpIHRoaXMuaGFzU2VsZWN0aW9uID0gY29udGVudDtcXG4gICAgICB9IGVsc2UgaWYgKCF0eXBpbmcpIHtcXG4gICAgICAgIHRoaXMucHJldklucHV0ID0gdGhpcy50ZXh0YXJlYS52YWx1ZSA9IFxcXCJcXFwiO1xcbiAgICAgICAgaWYgKGllICYmIGllX3ZlcnNpb24gPj0gOSkgdGhpcy5oYXNTZWxlY3Rpb24gPSBudWxsO1xcbiAgICAgIH1cXG4gICAgICB0aGlzLmluYWNjdXJhdGVTZWxlY3Rpb24gPSBtaW5pbWFsO1xcbiAgICB9LFxcblxcbiAgICBnZXRGaWVsZDogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLnRleHRhcmVhOyB9LFxcblxcbiAgICBzdXBwb3J0c1RvdWNoOiBmdW5jdGlvbigpIHsgcmV0dXJuIGZhbHNlOyB9LFxcblxcbiAgICBmb2N1czogZnVuY3Rpb24oKSB7XFxuICAgICAgaWYgKHRoaXMuY20ub3B0aW9ucy5yZWFkT25seSAhPSBcXFwibm9jdXJzb3JcXFwiICYmICghbW9iaWxlIHx8IGFjdGl2ZUVsdCgpICE9IHRoaXMudGV4dGFyZWEpKSB7XFxuICAgICAgICB0cnkgeyB0aGlzLnRleHRhcmVhLmZvY3VzKCk7IH1cXG4gICAgICAgIGNhdGNoIChlKSB7fSAvLyBJRTggd2lsbCB0aHJvdyBpZiB0aGUgdGV4dGFyZWEgaXMgZGlzcGxheTogbm9uZSBvciBub3QgaW4gRE9NXFxuICAgICAgfVxcbiAgICB9LFxcblxcbiAgICBibHVyOiBmdW5jdGlvbigpIHsgdGhpcy50ZXh0YXJlYS5ibHVyKCk7IH0sXFxuXFxuICAgIHJlc2V0UG9zaXRpb246IGZ1bmN0aW9uKCkge1xcbiAgICAgIHRoaXMud3JhcHBlci5zdHlsZS50b3AgPSB0aGlzLndyYXBwZXIuc3R5bGUubGVmdCA9IDA7XFxuICAgIH0sXFxuXFxuICAgIHJlY2VpdmVkRm9jdXM6IGZ1bmN0aW9uKCkgeyB0aGlzLnNsb3dQb2xsKCk7IH0sXFxuXFxuICAgIC8vIFBvbGwgZm9yIGlucHV0IGNoYW5nZXMsIHVzaW5nIHRoZSBub3JtYWwgcmF0ZSBvZiBwb2xsaW5nLiBUaGlzXFxuICAgIC8vIHJ1bnMgYXMgbG9uZyBhcyB0aGUgZWRpdG9yIGlzIGZvY3VzZWQuXFxuICAgIHNsb3dQb2xsOiBmdW5jdGlvbigpIHtcXG4gICAgICB2YXIgaW5wdXQgPSB0aGlzO1xcbiAgICAgIGlmIChpbnB1dC5wb2xsaW5nRmFzdCkgcmV0dXJuO1xcbiAgICAgIGlucHV0LnBvbGxpbmcuc2V0KHRoaXMuY20ub3B0aW9ucy5wb2xsSW50ZXJ2YWwsIGZ1bmN0aW9uKCkge1xcbiAgICAgICAgaW5wdXQucG9sbCgpO1xcbiAgICAgICAgaWYgKGlucHV0LmNtLnN0YXRlLmZvY3VzZWQpIGlucHV0LnNsb3dQb2xsKCk7XFxuICAgICAgfSk7XFxuICAgIH0sXFxuXFxuICAgIC8vIFdoZW4gYW4gZXZlbnQgaGFzIGp1c3QgY29tZSBpbiB0aGF0IGlzIGxpa2VseSB0byBhZGQgb3IgY2hhbmdlXFxuICAgIC8vIHNvbWV0aGluZyBpbiB0aGUgaW5wdXQgdGV4dGFyZWEsIHdlIHBvbGwgZmFzdGVyLCB0byBlbnN1cmUgdGhhdFxcbiAgICAvLyB0aGUgY2hhbmdlIGFwcGVhcnMgb24gdGhlIHNjcmVlbiBxdWlja2x5LlxcbiAgICBmYXN0UG9sbDogZnVuY3Rpb24oKSB7XFxuICAgICAgdmFyIG1pc3NlZCA9IGZhbHNlLCBpbnB1dCA9IHRoaXM7XFxuICAgICAgaW5wdXQucG9sbGluZ0Zhc3QgPSB0cnVlO1xcbiAgICAgIGZ1bmN0aW9uIHAoKSB7XFxuICAgICAgICB2YXIgY2hhbmdlZCA9IGlucHV0LnBvbGwoKTtcXG4gICAgICAgIGlmICghY2hhbmdlZCAmJiAhbWlzc2VkKSB7bWlzc2VkID0gdHJ1ZTsgaW5wdXQucG9sbGluZy5zZXQoNjAsIHApO31cXG4gICAgICAgIGVsc2Uge2lucHV0LnBvbGxpbmdGYXN0ID0gZmFsc2U7IGlucHV0LnNsb3dQb2xsKCk7fVxcbiAgICAgIH1cXG4gICAgICBpbnB1dC5wb2xsaW5nLnNldCgyMCwgcCk7XFxuICAgIH0sXFxuXFxuICAgIC8vIFJlYWQgaW5wdXQgZnJvbSB0aGUgdGV4dGFyZWEsIGFuZCB1cGRhdGUgdGhlIGRvY3VtZW50IHRvIG1hdGNoLlxcbiAgICAvLyBXaGVuIHNvbWV0aGluZyBpcyBzZWxlY3RlZCwgaXQgaXMgcHJlc2VudCBpbiB0aGUgdGV4dGFyZWEsIGFuZFxcbiAgICAvLyBzZWxlY3RlZCAodW5sZXNzIGl0IGlzIGh1Z2UsIGluIHdoaWNoIGNhc2UgYSBwbGFjZWhvbGRlciBpc1xcbiAgICAvLyB1c2VkKS4gV2hlbiBub3RoaW5nIGlzIHNlbGVjdGVkLCB0aGUgY3Vyc29yIHNpdHMgYWZ0ZXIgcHJldmlvdXNseVxcbiAgICAvLyBzZWVuIHRleHQgKGNhbiBiZSBlbXB0eSksIHdoaWNoIGlzIHN0b3JlZCBpbiBwcmV2SW5wdXQgKHdlIG11c3RcXG4gICAgLy8gbm90IHJlc2V0IHRoZSB0ZXh0YXJlYSB3aGVuIHR5cGluZywgYmVjYXVzZSB0aGF0IGJyZWFrcyBJTUUpLlxcbiAgICBwb2xsOiBmdW5jdGlvbigpIHtcXG4gICAgICB2YXIgY20gPSB0aGlzLmNtLCBpbnB1dCA9IHRoaXMudGV4dGFyZWEsIHByZXZJbnB1dCA9IHRoaXMucHJldklucHV0O1xcbiAgICAgIC8vIFNpbmNlIHRoaXMgaXMgY2FsbGVkIGEgKmxvdCosIHRyeSB0byBiYWlsIG91dCBhcyBjaGVhcGx5IGFzXFxuICAgICAgLy8gcG9zc2libGUgd2hlbiBpdCBpcyBjbGVhciB0aGF0IG5vdGhpbmcgaGFwcGVuZWQuIGhhc1NlbGVjdGlvblxcbiAgICAgIC8vIHdpbGwgYmUgdGhlIGNhc2Ugd2hlbiB0aGVyZSBpcyBhIGxvdCBvZiB0ZXh0IGluIHRoZSB0ZXh0YXJlYSxcXG4gICAgICAvLyBpbiB3aGljaCBjYXNlIHJlYWRpbmcgaXRzIHZhbHVlIHdvdWxkIGJlIGV4cGVuc2l2ZS5cXG4gICAgICBpZiAodGhpcy5jb250ZXh0TWVudVBlbmRpbmcgfHwgIWNtLnN0YXRlLmZvY3VzZWQgfHxcXG4gICAgICAgICAgKGhhc1NlbGVjdGlvbihpbnB1dCkgJiYgIXByZXZJbnB1dCAmJiAhdGhpcy5jb21wb3NpbmcpIHx8XFxuICAgICAgICAgIGNtLmlzUmVhZE9ubHkoKSB8fCBjbS5vcHRpb25zLmRpc2FibGVJbnB1dCB8fCBjbS5zdGF0ZS5rZXlTZXEpXFxuICAgICAgICByZXR1cm4gZmFsc2U7XFxuXFxuICAgICAgdmFyIHRleHQgPSBpbnB1dC52YWx1ZTtcXG4gICAgICAvLyBJZiBub3RoaW5nIGNoYW5nZWQsIGJhaWwuXFxuICAgICAgaWYgKHRleHQgPT0gcHJldklucHV0ICYmICFjbS5zb21ldGhpbmdTZWxlY3RlZCgpKSByZXR1cm4gZmFsc2U7XFxuICAgICAgLy8gV29yayBhcm91bmQgbm9uc2Vuc2ljYWwgc2VsZWN0aW9uIHJlc2V0dGluZyBpbiBJRTkvMTAsIGFuZFxcbiAgICAgIC8vIGluZXhwbGljYWJsZSBhcHBlYXJhbmNlIG9mIHByaXZhdGUgYXJlYSB1bmljb2RlIGNoYXJhY3RlcnMgb25cXG4gICAgICAvLyBzb21lIGtleSBjb21ib3MgaW4gTWFjICgjMjY4OSkuXFxuICAgICAgaWYgKGllICYmIGllX3ZlcnNpb24gPj0gOSAmJiB0aGlzLmhhc1NlbGVjdGlvbiA9PT0gdGV4dCB8fFxcbiAgICAgICAgICBtYWMgJiYgL1tcXFxcdWY3MDAtXFxcXHVmN2ZmXS8udGVzdCh0ZXh0KSkge1xcbiAgICAgICAgY20uZGlzcGxheS5pbnB1dC5yZXNldCgpO1xcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoY20uZG9jLnNlbCA9PSBjbS5kaXNwbGF5LnNlbEZvckNvbnRleHRNZW51KSB7XFxuICAgICAgICB2YXIgZmlyc3QgPSB0ZXh0LmNoYXJDb2RlQXQoMCk7XFxuICAgICAgICBpZiAoZmlyc3QgPT0gMHgyMDBiICYmICFwcmV2SW5wdXQpIHByZXZJbnB1dCA9IFxcXCJcXFxcdTIwMGJcXFwiO1xcbiAgICAgICAgaWYgKGZpcnN0ID09IDB4MjFkYSkgeyB0aGlzLnJlc2V0KCk7IHJldHVybiB0aGlzLmNtLmV4ZWNDb21tYW5kKFxcXCJ1bmRvXFxcIik7IH1cXG4gICAgICB9XFxuICAgICAgLy8gRmluZCB0aGUgcGFydCBvZiB0aGUgaW5wdXQgdGhhdCBpcyBhY3R1YWxseSBuZXdcXG4gICAgICB2YXIgc2FtZSA9IDAsIGwgPSBNYXRoLm1pbihwcmV2SW5wdXQubGVuZ3RoLCB0ZXh0Lmxlbmd0aCk7XFxuICAgICAgd2hpbGUgKHNhbWUgPCBsICYmIHByZXZJbnB1dC5jaGFyQ29kZUF0KHNhbWUpID09IHRleHQuY2hhckNvZGVBdChzYW1lKSkgKytzYW1lO1xcblxcbiAgICAgIHZhciBzZWxmID0gdGhpcztcXG4gICAgICBydW5Jbk9wKGNtLCBmdW5jdGlvbigpIHtcXG4gICAgICAgIGFwcGx5VGV4dElucHV0KGNtLCB0ZXh0LnNsaWNlKHNhbWUpLCBwcmV2SW5wdXQubGVuZ3RoIC0gc2FtZSxcXG4gICAgICAgICAgICAgICAgICAgICAgIG51bGwsIHNlbGYuY29tcG9zaW5nID8gXFxcIipjb21wb3NlXFxcIiA6IG51bGwpO1xcblxcbiAgICAgICAgLy8gRG9uJ3QgbGVhdmUgbG9uZyB0ZXh0IGluIHRoZSB0ZXh0YXJlYSwgc2luY2UgaXQgbWFrZXMgZnVydGhlciBwb2xsaW5nIHNsb3dcXG4gICAgICAgIGlmICh0ZXh0Lmxlbmd0aCA+IDEwMDAgfHwgdGV4dC5pbmRleE9mKFxcXCJcXFxcblxcXCIpID4gLTEpIGlucHV0LnZhbHVlID0gc2VsZi5wcmV2SW5wdXQgPSBcXFwiXFxcIjtcXG4gICAgICAgIGVsc2Ugc2VsZi5wcmV2SW5wdXQgPSB0ZXh0O1xcblxcbiAgICAgICAgaWYgKHNlbGYuY29tcG9zaW5nKSB7XFxuICAgICAgICAgIHNlbGYuY29tcG9zaW5nLnJhbmdlLmNsZWFyKCk7XFxuICAgICAgICAgIHNlbGYuY29tcG9zaW5nLnJhbmdlID0gY20ubWFya1RleHQoc2VsZi5jb21wb3Npbmcuc3RhcnQsIGNtLmdldEN1cnNvcihcXFwidG9cXFwiKSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7Y2xhc3NOYW1lOiBcXFwiQ29kZU1pcnJvci1jb21wb3NpbmdcXFwifSk7XFxuICAgICAgICB9XFxuICAgICAgfSk7XFxuICAgICAgcmV0dXJuIHRydWU7XFxuICAgIH0sXFxuXFxuICAgIGVuc3VyZVBvbGxlZDogZnVuY3Rpb24oKSB7XFxuICAgICAgaWYgKHRoaXMucG9sbGluZ0Zhc3QgJiYgdGhpcy5wb2xsKCkpIHRoaXMucG9sbGluZ0Zhc3QgPSBmYWxzZTtcXG4gICAgfSxcXG5cXG4gICAgb25LZXlQcmVzczogZnVuY3Rpb24oKSB7XFxuICAgICAgaWYgKGllICYmIGllX3ZlcnNpb24gPj0gOSkgdGhpcy5oYXNTZWxlY3Rpb24gPSBudWxsO1xcbiAgICAgIHRoaXMuZmFzdFBvbGwoKTtcXG4gICAgfSxcXG5cXG4gICAgb25Db250ZXh0TWVudTogZnVuY3Rpb24oZSkge1xcbiAgICAgIHZhciBpbnB1dCA9IHRoaXMsIGNtID0gaW5wdXQuY20sIGRpc3BsYXkgPSBjbS5kaXNwbGF5LCB0ZSA9IGlucHV0LnRleHRhcmVhO1xcbiAgICAgIHZhciBwb3MgPSBwb3NGcm9tTW91c2UoY20sIGUpLCBzY3JvbGxQb3MgPSBkaXNwbGF5LnNjcm9sbGVyLnNjcm9sbFRvcDtcXG4gICAgICBpZiAoIXBvcyB8fCBwcmVzdG8pIHJldHVybjsgLy8gT3BlcmEgaXMgZGlmZmljdWx0LlxcblxcbiAgICAgIC8vIFJlc2V0IHRoZSBjdXJyZW50IHRleHQgc2VsZWN0aW9uIG9ubHkgaWYgdGhlIGNsaWNrIGlzIGRvbmUgb3V0c2lkZSBvZiB0aGUgc2VsZWN0aW9uXFxuICAgICAgLy8gYW5kICdyZXNldFNlbGVjdGlvbk9uQ29udGV4dE1lbnUnIG9wdGlvbiBpcyB0cnVlLlxcbiAgICAgIHZhciByZXNldCA9IGNtLm9wdGlvbnMucmVzZXRTZWxlY3Rpb25PbkNvbnRleHRNZW51O1xcbiAgICAgIGlmIChyZXNldCAmJiBjbS5kb2Muc2VsLmNvbnRhaW5zKHBvcykgPT0gLTEpXFxuICAgICAgICBvcGVyYXRpb24oY20sIHNldFNlbGVjdGlvbikoY20uZG9jLCBzaW1wbGVTZWxlY3Rpb24ocG9zKSwgc2VsX2RvbnRTY3JvbGwpO1xcblxcbiAgICAgIHZhciBvbGRDU1MgPSB0ZS5zdHlsZS5jc3NUZXh0LCBvbGRXcmFwcGVyQ1NTID0gaW5wdXQud3JhcHBlci5zdHlsZS5jc3NUZXh0O1xcbiAgICAgIGlucHV0LndyYXBwZXIuc3R5bGUuY3NzVGV4dCA9IFxcXCJwb3NpdGlvbjogYWJzb2x1dGVcXFwiXFxuICAgICAgdmFyIHdyYXBwZXJCb3ggPSBpbnB1dC53cmFwcGVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXFxuICAgICAgdGUuc3R5bGUuY3NzVGV4dCA9IFxcXCJwb3NpdGlvbjogYWJzb2x1dGU7IHdpZHRoOiAzMHB4OyBoZWlnaHQ6IDMwcHg7IHRvcDogXFxcIiArIChlLmNsaWVudFkgLSB3cmFwcGVyQm94LnRvcCAtIDUpICtcXG4gICAgICAgIFxcXCJweDsgbGVmdDogXFxcIiArIChlLmNsaWVudFggLSB3cmFwcGVyQm94LmxlZnQgLSA1KSArIFxcXCJweDsgei1pbmRleDogMTAwMDsgYmFja2dyb3VuZDogXFxcIiArXFxuICAgICAgICAoaWUgPyBcXFwicmdiYSgyNTUsIDI1NSwgMjU1LCAuMDUpXFxcIiA6IFxcXCJ0cmFuc3BhcmVudFxcXCIpICtcXG4gICAgICAgIFxcXCI7IG91dGxpbmU6IG5vbmU7IGJvcmRlci13aWR0aDogMDsgb3V0bGluZTogbm9uZTsgb3ZlcmZsb3c6IGhpZGRlbjsgb3BhY2l0eTogLjA1OyBmaWx0ZXI6IGFscGhhKG9wYWNpdHk9NSk7XFxcIjtcXG4gICAgICBpZiAod2Via2l0KSB2YXIgb2xkU2Nyb2xsWSA9IHdpbmRvdy5zY3JvbGxZOyAvLyBXb3JrIGFyb3VuZCBDaHJvbWUgaXNzdWUgKCMyNzEyKVxcbiAgICAgIGRpc3BsYXkuaW5wdXQuZm9jdXMoKTtcXG4gICAgICBpZiAod2Via2l0KSB3aW5kb3cuc2Nyb2xsVG8obnVsbCwgb2xkU2Nyb2xsWSk7XFxuICAgICAgZGlzcGxheS5pbnB1dC5yZXNldCgpO1xcbiAgICAgIC8vIEFkZHMgXFxcIlNlbGVjdCBhbGxcXFwiIHRvIGNvbnRleHQgbWVudSBpbiBGRlxcbiAgICAgIGlmICghY20uc29tZXRoaW5nU2VsZWN0ZWQoKSkgdGUudmFsdWUgPSBpbnB1dC5wcmV2SW5wdXQgPSBcXFwiIFxcXCI7XFxuICAgICAgaW5wdXQuY29udGV4dE1lbnVQZW5kaW5nID0gdHJ1ZTtcXG4gICAgICBkaXNwbGF5LnNlbEZvckNvbnRleHRNZW51ID0gY20uZG9jLnNlbDtcXG4gICAgICBjbGVhclRpbWVvdXQoZGlzcGxheS5kZXRlY3RpbmdTZWxlY3RBbGwpO1xcblxcbiAgICAgIC8vIFNlbGVjdC1hbGwgd2lsbCBiZSBncmV5ZWQgb3V0IGlmIHRoZXJlJ3Mgbm90aGluZyB0byBzZWxlY3QsIHNvXFxuICAgICAgLy8gdGhpcyBhZGRzIGEgemVyby13aWR0aCBzcGFjZSBzbyB0aGF0IHdlIGNhbiBsYXRlciBjaGVjayB3aGV0aGVyXFxuICAgICAgLy8gaXQgZ290IHNlbGVjdGVkLlxcbiAgICAgIGZ1bmN0aW9uIHByZXBhcmVTZWxlY3RBbGxIYWNrKCkge1xcbiAgICAgICAgaWYgKHRlLnNlbGVjdGlvblN0YXJ0ICE9IG51bGwpIHtcXG4gICAgICAgICAgdmFyIHNlbGVjdGVkID0gY20uc29tZXRoaW5nU2VsZWN0ZWQoKTtcXG4gICAgICAgICAgdmFyIGV4dHZhbCA9IFxcXCJcXFxcdTIwMGJcXFwiICsgKHNlbGVjdGVkID8gdGUudmFsdWUgOiBcXFwiXFxcIik7XFxuICAgICAgICAgIHRlLnZhbHVlID0gXFxcIlxcXFx1MjFkYVxcXCI7IC8vIFVzZWQgdG8gY2F0Y2ggY29udGV4dC1tZW51IHVuZG9cXG4gICAgICAgICAgdGUudmFsdWUgPSBleHR2YWw7XFxuICAgICAgICAgIGlucHV0LnByZXZJbnB1dCA9IHNlbGVjdGVkID8gXFxcIlxcXCIgOiBcXFwiXFxcXHUyMDBiXFxcIjtcXG4gICAgICAgICAgdGUuc2VsZWN0aW9uU3RhcnQgPSAxOyB0ZS5zZWxlY3Rpb25FbmQgPSBleHR2YWwubGVuZ3RoO1xcbiAgICAgICAgICAvLyBSZS1zZXQgdGhpcywgaW4gY2FzZSBzb21lIG90aGVyIGhhbmRsZXIgdG91Y2hlZCB0aGVcXG4gICAgICAgICAgLy8gc2VsZWN0aW9uIGluIHRoZSBtZWFudGltZS5cXG4gICAgICAgICAgZGlzcGxheS5zZWxGb3JDb250ZXh0TWVudSA9IGNtLmRvYy5zZWw7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICAgIGZ1bmN0aW9uIHJlaGlkZSgpIHtcXG4gICAgICAgIGlucHV0LmNvbnRleHRNZW51UGVuZGluZyA9IGZhbHNlO1xcbiAgICAgICAgaW5wdXQud3JhcHBlci5zdHlsZS5jc3NUZXh0ID0gb2xkV3JhcHBlckNTU1xcbiAgICAgICAgdGUuc3R5bGUuY3NzVGV4dCA9IG9sZENTUztcXG4gICAgICAgIGlmIChpZSAmJiBpZV92ZXJzaW9uIDwgOSkgZGlzcGxheS5zY3JvbGxiYXJzLnNldFNjcm9sbFRvcChkaXNwbGF5LnNjcm9sbGVyLnNjcm9sbFRvcCA9IHNjcm9sbFBvcyk7XFxuXFxuICAgICAgICAvLyBUcnkgdG8gZGV0ZWN0IHRoZSB1c2VyIGNob29zaW5nIHNlbGVjdC1hbGxcXG4gICAgICAgIGlmICh0ZS5zZWxlY3Rpb25TdGFydCAhPSBudWxsKSB7XFxuICAgICAgICAgIGlmICghaWUgfHwgKGllICYmIGllX3ZlcnNpb24gPCA5KSkgcHJlcGFyZVNlbGVjdEFsbEhhY2soKTtcXG4gICAgICAgICAgdmFyIGkgPSAwLCBwb2xsID0gZnVuY3Rpb24oKSB7XFxuICAgICAgICAgICAgaWYgKGRpc3BsYXkuc2VsRm9yQ29udGV4dE1lbnUgPT0gY20uZG9jLnNlbCAmJiB0ZS5zZWxlY3Rpb25TdGFydCA9PSAwICYmXFxuICAgICAgICAgICAgICAgIHRlLnNlbGVjdGlvbkVuZCA+IDAgJiYgaW5wdXQucHJldklucHV0ID09IFxcXCJcXFxcdTIwMGJcXFwiKVxcbiAgICAgICAgICAgICAgb3BlcmF0aW9uKGNtLCBjb21tYW5kcy5zZWxlY3RBbGwpKGNtKTtcXG4gICAgICAgICAgICBlbHNlIGlmIChpKysgPCAxMCkgZGlzcGxheS5kZXRlY3RpbmdTZWxlY3RBbGwgPSBzZXRUaW1lb3V0KHBvbGwsIDUwMCk7XFxuICAgICAgICAgICAgZWxzZSBkaXNwbGF5LmlucHV0LnJlc2V0KCk7XFxuICAgICAgICAgIH07XFxuICAgICAgICAgIGRpc3BsYXkuZGV0ZWN0aW5nU2VsZWN0QWxsID0gc2V0VGltZW91dChwb2xsLCAyMDApO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoaWUgJiYgaWVfdmVyc2lvbiA+PSA5KSBwcmVwYXJlU2VsZWN0QWxsSGFjaygpO1xcbiAgICAgIGlmIChjYXB0dXJlUmlnaHRDbGljaykge1xcbiAgICAgICAgZV9zdG9wKGUpO1xcbiAgICAgICAgdmFyIG1vdXNldXAgPSBmdW5jdGlvbigpIHtcXG4gICAgICAgICAgb2ZmKHdpbmRvdywgXFxcIm1vdXNldXBcXFwiLCBtb3VzZXVwKTtcXG4gICAgICAgICAgc2V0VGltZW91dChyZWhpZGUsIDIwKTtcXG4gICAgICAgIH07XFxuICAgICAgICBvbih3aW5kb3csIFxcXCJtb3VzZXVwXFxcIiwgbW91c2V1cCk7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIHNldFRpbWVvdXQocmVoaWRlLCA1MCk7XFxuICAgICAgfVxcbiAgICB9LFxcblxcbiAgICByZWFkT25seUNoYW5nZWQ6IGZ1bmN0aW9uKHZhbCkge1xcbiAgICAgIGlmICghdmFsKSB0aGlzLnJlc2V0KCk7XFxuICAgIH0sXFxuXFxuICAgIHNldFVuZWRpdGFibGU6IG5vdGhpbmcsXFxuXFxuICAgIG5lZWRzQ29udGVudEF0dHJpYnV0ZTogZmFsc2VcXG4gIH0sIFRleHRhcmVhSW5wdXQucHJvdG90eXBlKTtcXG5cXG4gIC8vIENPTlRFTlRFRElUQUJMRSBJTlBVVCBTVFlMRVxcblxcbiAgZnVuY3Rpb24gQ29udGVudEVkaXRhYmxlSW5wdXQoY20pIHtcXG4gICAgdGhpcy5jbSA9IGNtO1xcbiAgICB0aGlzLmxhc3RBbmNob3JOb2RlID0gdGhpcy5sYXN0QW5jaG9yT2Zmc2V0ID0gdGhpcy5sYXN0Rm9jdXNOb2RlID0gdGhpcy5sYXN0Rm9jdXNPZmZzZXQgPSBudWxsO1xcbiAgICB0aGlzLnBvbGxpbmcgPSBuZXcgRGVsYXllZCgpO1xcbiAgICB0aGlzLmdyYWNlUGVyaW9kID0gZmFsc2U7XFxuICB9XFxuXFxuICBDb250ZW50RWRpdGFibGVJbnB1dC5wcm90b3R5cGUgPSBjb3B5T2JqKHtcXG4gICAgaW5pdDogZnVuY3Rpb24oZGlzcGxheSkge1xcbiAgICAgIHZhciBpbnB1dCA9IHRoaXMsIGNtID0gaW5wdXQuY207XFxuICAgICAgdmFyIGRpdiA9IGlucHV0LmRpdiA9IGRpc3BsYXkubGluZURpdjtcXG4gICAgICBkaXNhYmxlQnJvd3Nlck1hZ2ljKGRpdiwgY20ub3B0aW9ucy5zcGVsbGNoZWNrKTtcXG5cXG4gICAgICBvbihkaXYsIFxcXCJwYXN0ZVxcXCIsIGZ1bmN0aW9uKGUpIHtcXG4gICAgICAgIGlmIChzaWduYWxET01FdmVudChjbSwgZSkgfHwgaGFuZGxlUGFzdGUoZSwgY20pKSByZXR1cm5cXG4gICAgICAgIC8vIElFIGRvZXNuJ3QgZmlyZSBpbnB1dCBldmVudHMsIHNvIHdlIHNjaGVkdWxlIGEgcmVhZCBmb3IgdGhlIHBhc3RlZCBjb250ZW50IGluIHRoaXMgd2F5XFxuICAgICAgICBpZiAoaWVfdmVyc2lvbiA8PSAxMSkgc2V0VGltZW91dChvcGVyYXRpb24oY20sIGZ1bmN0aW9uKCkge1xcbiAgICAgICAgICBpZiAoIWlucHV0LnBvbGxDb250ZW50KCkpIHJlZ0NoYW5nZShjbSk7XFxuICAgICAgICB9KSwgMjApXFxuICAgICAgfSlcXG5cXG4gICAgICBvbihkaXYsIFxcXCJjb21wb3NpdGlvbnN0YXJ0XFxcIiwgZnVuY3Rpb24oZSkge1xcbiAgICAgICAgdmFyIGRhdGEgPSBlLmRhdGE7XFxuICAgICAgICBpbnB1dC5jb21wb3NpbmcgPSB7c2VsOiBjbS5kb2Muc2VsLCBkYXRhOiBkYXRhLCBzdGFydERhdGE6IGRhdGF9O1xcbiAgICAgICAgaWYgKCFkYXRhKSByZXR1cm47XFxuICAgICAgICB2YXIgcHJpbSA9IGNtLmRvYy5zZWwucHJpbWFyeSgpO1xcbiAgICAgICAgdmFyIGxpbmUgPSBjbS5nZXRMaW5lKHByaW0uaGVhZC5saW5lKTtcXG4gICAgICAgIHZhciBmb3VuZCA9IGxpbmUuaW5kZXhPZihkYXRhLCBNYXRoLm1heCgwLCBwcmltLmhlYWQuY2ggLSBkYXRhLmxlbmd0aCkpO1xcbiAgICAgICAgaWYgKGZvdW5kID4gLTEgJiYgZm91bmQgPD0gcHJpbS5oZWFkLmNoKVxcbiAgICAgICAgICBpbnB1dC5jb21wb3Npbmcuc2VsID0gc2ltcGxlU2VsZWN0aW9uKFBvcyhwcmltLmhlYWQubGluZSwgZm91bmQpLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFBvcyhwcmltLmhlYWQubGluZSwgZm91bmQgKyBkYXRhLmxlbmd0aCkpO1xcbiAgICAgIH0pO1xcbiAgICAgIG9uKGRpdiwgXFxcImNvbXBvc2l0aW9udXBkYXRlXFxcIiwgZnVuY3Rpb24oZSkge1xcbiAgICAgICAgaW5wdXQuY29tcG9zaW5nLmRhdGEgPSBlLmRhdGE7XFxuICAgICAgfSk7XFxuICAgICAgb24oZGl2LCBcXFwiY29tcG9zaXRpb25lbmRcXFwiLCBmdW5jdGlvbihlKSB7XFxuICAgICAgICB2YXIgb3VycyA9IGlucHV0LmNvbXBvc2luZztcXG4gICAgICAgIGlmICghb3VycykgcmV0dXJuO1xcbiAgICAgICAgaWYgKGUuZGF0YSAhPSBvdXJzLnN0YXJ0RGF0YSAmJiAhL1xcXFx1MjAwYi8udGVzdChlLmRhdGEpKVxcbiAgICAgICAgICBvdXJzLmRhdGEgPSBlLmRhdGE7XFxuICAgICAgICAvLyBOZWVkIGEgc21hbGwgZGVsYXkgdG8gcHJldmVudCBvdGhlciBjb2RlIChpbnB1dCBldmVudCxcXG4gICAgICAgIC8vIHNlbGVjdGlvbiBwb2xsaW5nKSBmcm9tIGRvaW5nIGRhbWFnZSB3aGVuIGZpcmVkIHJpZ2h0IGFmdGVyXFxuICAgICAgICAvLyBjb21wb3NpdGlvbmVuZC5cXG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XFxuICAgICAgICAgIGlmICghb3Vycy5oYW5kbGVkKVxcbiAgICAgICAgICAgIGlucHV0LmFwcGx5Q29tcG9zaXRpb24ob3Vycyk7XFxuICAgICAgICAgIGlmIChpbnB1dC5jb21wb3NpbmcgPT0gb3VycylcXG4gICAgICAgICAgICBpbnB1dC5jb21wb3NpbmcgPSBudWxsO1xcbiAgICAgICAgfSwgNTApO1xcbiAgICAgIH0pO1xcblxcbiAgICAgIG9uKGRpdiwgXFxcInRvdWNoc3RhcnRcXFwiLCBmdW5jdGlvbigpIHtcXG4gICAgICAgIGlucHV0LmZvcmNlQ29tcG9zaXRpb25FbmQoKTtcXG4gICAgICB9KTtcXG5cXG4gICAgICBvbihkaXYsIFxcXCJpbnB1dFxcXCIsIGZ1bmN0aW9uKCkge1xcbiAgICAgICAgaWYgKGlucHV0LmNvbXBvc2luZykgcmV0dXJuO1xcbiAgICAgICAgaWYgKGNtLmlzUmVhZE9ubHkoKSB8fCAhaW5wdXQucG9sbENvbnRlbnQoKSlcXG4gICAgICAgICAgcnVuSW5PcChpbnB1dC5jbSwgZnVuY3Rpb24oKSB7cmVnQ2hhbmdlKGNtKTt9KTtcXG4gICAgICB9KTtcXG5cXG4gICAgICBmdW5jdGlvbiBvbkNvcHlDdXQoZSkge1xcbiAgICAgICAgaWYgKHNpZ25hbERPTUV2ZW50KGNtLCBlKSkgcmV0dXJuXFxuICAgICAgICBpZiAoY20uc29tZXRoaW5nU2VsZWN0ZWQoKSkge1xcbiAgICAgICAgICBsYXN0Q29waWVkID0ge2xpbmVXaXNlOiBmYWxzZSwgdGV4dDogY20uZ2V0U2VsZWN0aW9ucygpfTtcXG4gICAgICAgICAgaWYgKGUudHlwZSA9PSBcXFwiY3V0XFxcIikgY20ucmVwbGFjZVNlbGVjdGlvbihcXFwiXFxcIiwgbnVsbCwgXFxcImN1dFxcXCIpO1xcbiAgICAgICAgfSBlbHNlIGlmICghY20ub3B0aW9ucy5saW5lV2lzZUNvcHlDdXQpIHtcXG4gICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgdmFyIHJhbmdlcyA9IGNvcHlhYmxlUmFuZ2VzKGNtKTtcXG4gICAgICAgICAgbGFzdENvcGllZCA9IHtsaW5lV2lzZTogdHJ1ZSwgdGV4dDogcmFuZ2VzLnRleHR9O1xcbiAgICAgICAgICBpZiAoZS50eXBlID09IFxcXCJjdXRcXFwiKSB7XFxuICAgICAgICAgICAgY20ub3BlcmF0aW9uKGZ1bmN0aW9uKCkge1xcbiAgICAgICAgICAgICAgY20uc2V0U2VsZWN0aW9ucyhyYW5nZXMucmFuZ2VzLCAwLCBzZWxfZG9udFNjcm9sbCk7XFxuICAgICAgICAgICAgICBjbS5yZXBsYWNlU2VsZWN0aW9uKFxcXCJcXFwiLCBudWxsLCBcXFwiY3V0XFxcIik7XFxuICAgICAgICAgICAgfSk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIGlmIChlLmNsaXBib2FyZERhdGEpIHtcXG4gICAgICAgICAgZS5jbGlwYm9hcmREYXRhLmNsZWFyRGF0YSgpO1xcbiAgICAgICAgICB2YXIgY29udGVudCA9IGxhc3RDb3BpZWQudGV4dC5qb2luKFxcXCJcXFxcblxcXCIpXFxuICAgICAgICAgIC8vIGlPUyBleHBvc2VzIHRoZSBjbGlwYm9hcmQgQVBJLCBidXQgc2VlbXMgdG8gZGlzY2FyZCBjb250ZW50IGluc2VydGVkIGludG8gaXRcXG4gICAgICAgICAgZS5jbGlwYm9hcmREYXRhLnNldERhdGEoXFxcIlRleHRcXFwiLCBjb250ZW50KTtcXG4gICAgICAgICAgaWYgKGUuY2xpcGJvYXJkRGF0YS5nZXREYXRhKFxcXCJUZXh0XFxcIikgPT0gY29udGVudCkge1xcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcXG4gICAgICAgICAgICByZXR1cm5cXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgLy8gT2xkLWZhc2hpb25lZCBicmllZmx5LWZvY3VzLWEtdGV4dGFyZWEgaGFja1xcbiAgICAgICAgdmFyIGtsdWRnZSA9IGhpZGRlblRleHRhcmVhKCksIHRlID0ga2x1ZGdlLmZpcnN0Q2hpbGQ7XFxuICAgICAgICBjbS5kaXNwbGF5LmxpbmVTcGFjZS5pbnNlcnRCZWZvcmUoa2x1ZGdlLCBjbS5kaXNwbGF5LmxpbmVTcGFjZS5maXJzdENoaWxkKTtcXG4gICAgICAgIHRlLnZhbHVlID0gbGFzdENvcGllZC50ZXh0LmpvaW4oXFxcIlxcXFxuXFxcIik7XFxuICAgICAgICB2YXIgaGFkRm9jdXMgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xcbiAgICAgICAgc2VsZWN0SW5wdXQodGUpO1xcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcXG4gICAgICAgICAgY20uZGlzcGxheS5saW5lU3BhY2UucmVtb3ZlQ2hpbGQoa2x1ZGdlKTtcXG4gICAgICAgICAgaGFkRm9jdXMuZm9jdXMoKTtcXG4gICAgICAgICAgaWYgKGhhZEZvY3VzID09IGRpdikgaW5wdXQuc2hvd1ByaW1hcnlTZWxlY3Rpb24oKVxcbiAgICAgICAgfSwgNTApO1xcbiAgICAgIH1cXG4gICAgICBvbihkaXYsIFxcXCJjb3B5XFxcIiwgb25Db3B5Q3V0KTtcXG4gICAgICBvbihkaXYsIFxcXCJjdXRcXFwiLCBvbkNvcHlDdXQpO1xcbiAgICB9LFxcblxcbiAgICBwcmVwYXJlU2VsZWN0aW9uOiBmdW5jdGlvbigpIHtcXG4gICAgICB2YXIgcmVzdWx0ID0gcHJlcGFyZVNlbGVjdGlvbih0aGlzLmNtLCBmYWxzZSk7XFxuICAgICAgcmVzdWx0LmZvY3VzID0gdGhpcy5jbS5zdGF0ZS5mb2N1c2VkO1xcbiAgICAgIHJldHVybiByZXN1bHQ7XFxuICAgIH0sXFxuXFxuICAgIHNob3dTZWxlY3Rpb246IGZ1bmN0aW9uKGluZm8sIHRha2VGb2N1cykge1xcbiAgICAgIGlmICghaW5mbyB8fCAhdGhpcy5jbS5kaXNwbGF5LnZpZXcubGVuZ3RoKSByZXR1cm47XFxuICAgICAgaWYgKGluZm8uZm9jdXMgfHwgdGFrZUZvY3VzKSB0aGlzLnNob3dQcmltYXJ5U2VsZWN0aW9uKCk7XFxuICAgICAgdGhpcy5zaG93TXVsdGlwbGVTZWxlY3Rpb25zKGluZm8pO1xcbiAgICB9LFxcblxcbiAgICBzaG93UHJpbWFyeVNlbGVjdGlvbjogZnVuY3Rpb24oKSB7XFxuICAgICAgdmFyIHNlbCA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKSwgcHJpbSA9IHRoaXMuY20uZG9jLnNlbC5wcmltYXJ5KCk7XFxuICAgICAgdmFyIGN1ckFuY2hvciA9IGRvbVRvUG9zKHRoaXMuY20sIHNlbC5hbmNob3JOb2RlLCBzZWwuYW5jaG9yT2Zmc2V0KTtcXG4gICAgICB2YXIgY3VyRm9jdXMgPSBkb21Ub1Bvcyh0aGlzLmNtLCBzZWwuZm9jdXNOb2RlLCBzZWwuZm9jdXNPZmZzZXQpO1xcbiAgICAgIGlmIChjdXJBbmNob3IgJiYgIWN1ckFuY2hvci5iYWQgJiYgY3VyRm9jdXMgJiYgIWN1ckZvY3VzLmJhZCAmJlxcbiAgICAgICAgICBjbXAobWluUG9zKGN1ckFuY2hvciwgY3VyRm9jdXMpLCBwcmltLmZyb20oKSkgPT0gMCAmJlxcbiAgICAgICAgICBjbXAobWF4UG9zKGN1ckFuY2hvciwgY3VyRm9jdXMpLCBwcmltLnRvKCkpID09IDApXFxuICAgICAgICByZXR1cm47XFxuXFxuICAgICAgdmFyIHN0YXJ0ID0gcG9zVG9ET00odGhpcy5jbSwgcHJpbS5mcm9tKCkpO1xcbiAgICAgIHZhciBlbmQgPSBwb3NUb0RPTSh0aGlzLmNtLCBwcmltLnRvKCkpO1xcbiAgICAgIGlmICghc3RhcnQgJiYgIWVuZCkgcmV0dXJuO1xcblxcbiAgICAgIHZhciB2aWV3ID0gdGhpcy5jbS5kaXNwbGF5LnZpZXc7XFxuICAgICAgdmFyIG9sZCA9IHNlbC5yYW5nZUNvdW50ICYmIHNlbC5nZXRSYW5nZUF0KDApO1xcbiAgICAgIGlmICghc3RhcnQpIHtcXG4gICAgICAgIHN0YXJ0ID0ge25vZGU6IHZpZXdbMF0ubWVhc3VyZS5tYXBbMl0sIG9mZnNldDogMH07XFxuICAgICAgfSBlbHNlIGlmICghZW5kKSB7IC8vIEZJWE1FIGRhbmdlcm91c2x5IGhhY2t5XFxuICAgICAgICB2YXIgbWVhc3VyZSA9IHZpZXdbdmlldy5sZW5ndGggLSAxXS5tZWFzdXJlO1xcbiAgICAgICAgdmFyIG1hcCA9IG1lYXN1cmUubWFwcyA/IG1lYXN1cmUubWFwc1ttZWFzdXJlLm1hcHMubGVuZ3RoIC0gMV0gOiBtZWFzdXJlLm1hcDtcXG4gICAgICAgIGVuZCA9IHtub2RlOiBtYXBbbWFwLmxlbmd0aCAtIDFdLCBvZmZzZXQ6IG1hcFttYXAubGVuZ3RoIC0gMl0gLSBtYXBbbWFwLmxlbmd0aCAtIDNdfTtcXG4gICAgICB9XFxuXFxuICAgICAgdHJ5IHsgdmFyIHJuZyA9IHJhbmdlKHN0YXJ0Lm5vZGUsIHN0YXJ0Lm9mZnNldCwgZW5kLm9mZnNldCwgZW5kLm5vZGUpOyB9XFxuICAgICAgY2F0Y2goZSkge30gLy8gT3VyIG1vZGVsIG9mIHRoZSBET00gbWlnaHQgYmUgb3V0ZGF0ZWQsIGluIHdoaWNoIGNhc2UgdGhlIHJhbmdlIHdlIHRyeSB0byBzZXQgY2FuIGJlIGltcG9zc2libGVcXG4gICAgICBpZiAocm5nKSB7XFxuICAgICAgICBpZiAoIWdlY2tvICYmIHRoaXMuY20uc3RhdGUuZm9jdXNlZCkge1xcbiAgICAgICAgICBzZWwuY29sbGFwc2Uoc3RhcnQubm9kZSwgc3RhcnQub2Zmc2V0KTtcXG4gICAgICAgICAgaWYgKCFybmcuY29sbGFwc2VkKSBzZWwuYWRkUmFuZ2Uocm5nKTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIHNlbC5yZW1vdmVBbGxSYW5nZXMoKTtcXG4gICAgICAgICAgc2VsLmFkZFJhbmdlKHJuZyk7XFxuICAgICAgICB9XFxuICAgICAgICBpZiAob2xkICYmIHNlbC5hbmNob3JOb2RlID09IG51bGwpIHNlbC5hZGRSYW5nZShvbGQpO1xcbiAgICAgICAgZWxzZSBpZiAoZ2Vja28pIHRoaXMuc3RhcnRHcmFjZVBlcmlvZCgpO1xcbiAgICAgIH1cXG4gICAgICB0aGlzLnJlbWVtYmVyU2VsZWN0aW9uKCk7XFxuICAgIH0sXFxuXFxuICAgIHN0YXJ0R3JhY2VQZXJpb2Q6IGZ1bmN0aW9uKCkge1xcbiAgICAgIHZhciBpbnB1dCA9IHRoaXM7XFxuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuZ3JhY2VQZXJpb2QpO1xcbiAgICAgIHRoaXMuZ3JhY2VQZXJpb2QgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xcbiAgICAgICAgaW5wdXQuZ3JhY2VQZXJpb2QgPSBmYWxzZTtcXG4gICAgICAgIGlmIChpbnB1dC5zZWxlY3Rpb25DaGFuZ2VkKCkpXFxuICAgICAgICAgIGlucHV0LmNtLm9wZXJhdGlvbihmdW5jdGlvbigpIHsgaW5wdXQuY20uY3VyT3Auc2VsZWN0aW9uQ2hhbmdlZCA9IHRydWU7IH0pO1xcbiAgICAgIH0sIDIwKTtcXG4gICAgfSxcXG5cXG4gICAgc2hvd011bHRpcGxlU2VsZWN0aW9uczogZnVuY3Rpb24oaW5mbykge1xcbiAgICAgIHJlbW92ZUNoaWxkcmVuQW5kQWRkKHRoaXMuY20uZGlzcGxheS5jdXJzb3JEaXYsIGluZm8uY3Vyc29ycyk7XFxuICAgICAgcmVtb3ZlQ2hpbGRyZW5BbmRBZGQodGhpcy5jbS5kaXNwbGF5LnNlbGVjdGlvbkRpdiwgaW5mby5zZWxlY3Rpb24pO1xcbiAgICB9LFxcblxcbiAgICByZW1lbWJlclNlbGVjdGlvbjogZnVuY3Rpb24oKSB7XFxuICAgICAgdmFyIHNlbCA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKTtcXG4gICAgICB0aGlzLmxhc3RBbmNob3JOb2RlID0gc2VsLmFuY2hvck5vZGU7IHRoaXMubGFzdEFuY2hvck9mZnNldCA9IHNlbC5hbmNob3JPZmZzZXQ7XFxuICAgICAgdGhpcy5sYXN0Rm9jdXNOb2RlID0gc2VsLmZvY3VzTm9kZTsgdGhpcy5sYXN0Rm9jdXNPZmZzZXQgPSBzZWwuZm9jdXNPZmZzZXQ7XFxuICAgIH0sXFxuXFxuICAgIHNlbGVjdGlvbkluRWRpdG9yOiBmdW5jdGlvbigpIHtcXG4gICAgICB2YXIgc2VsID0gd2luZG93LmdldFNlbGVjdGlvbigpO1xcbiAgICAgIGlmICghc2VsLnJhbmdlQ291bnQpIHJldHVybiBmYWxzZTtcXG4gICAgICB2YXIgbm9kZSA9IHNlbC5nZXRSYW5nZUF0KDApLmNvbW1vbkFuY2VzdG9yQ29udGFpbmVyO1xcbiAgICAgIHJldHVybiBjb250YWlucyh0aGlzLmRpdiwgbm9kZSk7XFxuICAgIH0sXFxuXFxuICAgIGZvY3VzOiBmdW5jdGlvbigpIHtcXG4gICAgICBpZiAodGhpcy5jbS5vcHRpb25zLnJlYWRPbmx5ICE9IFxcXCJub2N1cnNvclxcXCIpIHRoaXMuZGl2LmZvY3VzKCk7XFxuICAgIH0sXFxuICAgIGJsdXI6IGZ1bmN0aW9uKCkgeyB0aGlzLmRpdi5ibHVyKCk7IH0sXFxuICAgIGdldEZpZWxkOiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuZGl2OyB9LFxcblxcbiAgICBzdXBwb3J0c1RvdWNoOiBmdW5jdGlvbigpIHsgcmV0dXJuIHRydWU7IH0sXFxuXFxuICAgIHJlY2VpdmVkRm9jdXM6IGZ1bmN0aW9uKCkge1xcbiAgICAgIHZhciBpbnB1dCA9IHRoaXM7XFxuICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uSW5FZGl0b3IoKSlcXG4gICAgICAgIHRoaXMucG9sbFNlbGVjdGlvbigpO1xcbiAgICAgIGVsc2VcXG4gICAgICAgIHJ1bkluT3AodGhpcy5jbSwgZnVuY3Rpb24oKSB7IGlucHV0LmNtLmN1ck9wLnNlbGVjdGlvbkNoYW5nZWQgPSB0cnVlOyB9KTtcXG5cXG4gICAgICBmdW5jdGlvbiBwb2xsKCkge1xcbiAgICAgICAgaWYgKGlucHV0LmNtLnN0YXRlLmZvY3VzZWQpIHtcXG4gICAgICAgICAgaW5wdXQucG9sbFNlbGVjdGlvbigpO1xcbiAgICAgICAgICBpbnB1dC5wb2xsaW5nLnNldChpbnB1dC5jbS5vcHRpb25zLnBvbGxJbnRlcnZhbCwgcG9sbCk7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICAgIHRoaXMucG9sbGluZy5zZXQodGhpcy5jbS5vcHRpb25zLnBvbGxJbnRlcnZhbCwgcG9sbCk7XFxuICAgIH0sXFxuXFxuICAgIHNlbGVjdGlvbkNoYW5nZWQ6IGZ1bmN0aW9uKCkge1xcbiAgICAgIHZhciBzZWwgPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XFxuICAgICAgcmV0dXJuIHNlbC5hbmNob3JOb2RlICE9IHRoaXMubGFzdEFuY2hvck5vZGUgfHwgc2VsLmFuY2hvck9mZnNldCAhPSB0aGlzLmxhc3RBbmNob3JPZmZzZXQgfHxcXG4gICAgICAgIHNlbC5mb2N1c05vZGUgIT0gdGhpcy5sYXN0Rm9jdXNOb2RlIHx8IHNlbC5mb2N1c09mZnNldCAhPSB0aGlzLmxhc3RGb2N1c09mZnNldDtcXG4gICAgfSxcXG5cXG4gICAgcG9sbFNlbGVjdGlvbjogZnVuY3Rpb24oKSB7XFxuICAgICAgaWYgKCF0aGlzLmNvbXBvc2luZyAmJiAhdGhpcy5ncmFjZVBlcmlvZCAmJiB0aGlzLnNlbGVjdGlvbkNoYW5nZWQoKSkge1xcbiAgICAgICAgdmFyIHNlbCA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKSwgY20gPSB0aGlzLmNtO1xcbiAgICAgICAgdGhpcy5yZW1lbWJlclNlbGVjdGlvbigpO1xcbiAgICAgICAgdmFyIGFuY2hvciA9IGRvbVRvUG9zKGNtLCBzZWwuYW5jaG9yTm9kZSwgc2VsLmFuY2hvck9mZnNldCk7XFxuICAgICAgICB2YXIgaGVhZCA9IGRvbVRvUG9zKGNtLCBzZWwuZm9jdXNOb2RlLCBzZWwuZm9jdXNPZmZzZXQpO1xcbiAgICAgICAgaWYgKGFuY2hvciAmJiBoZWFkKSBydW5Jbk9wKGNtLCBmdW5jdGlvbigpIHtcXG4gICAgICAgICAgc2V0U2VsZWN0aW9uKGNtLmRvYywgc2ltcGxlU2VsZWN0aW9uKGFuY2hvciwgaGVhZCksIHNlbF9kb250U2Nyb2xsKTtcXG4gICAgICAgICAgaWYgKGFuY2hvci5iYWQgfHwgaGVhZC5iYWQpIGNtLmN1ck9wLnNlbGVjdGlvbkNoYW5nZWQgPSB0cnVlO1xcbiAgICAgICAgfSk7XFxuICAgICAgfVxcbiAgICB9LFxcblxcbiAgICBwb2xsQ29udGVudDogZnVuY3Rpb24oKSB7XFxuICAgICAgdmFyIGNtID0gdGhpcy5jbSwgZGlzcGxheSA9IGNtLmRpc3BsYXksIHNlbCA9IGNtLmRvYy5zZWwucHJpbWFyeSgpO1xcbiAgICAgIHZhciBmcm9tID0gc2VsLmZyb20oKSwgdG8gPSBzZWwudG8oKTtcXG4gICAgICBpZiAoZnJvbS5saW5lIDwgZGlzcGxheS52aWV3RnJvbSB8fCB0by5saW5lID4gZGlzcGxheS52aWV3VG8gLSAxKSByZXR1cm4gZmFsc2U7XFxuXFxuICAgICAgdmFyIGZyb21JbmRleDtcXG4gICAgICBpZiAoZnJvbS5saW5lID09IGRpc3BsYXkudmlld0Zyb20gfHwgKGZyb21JbmRleCA9IGZpbmRWaWV3SW5kZXgoY20sIGZyb20ubGluZSkpID09IDApIHtcXG4gICAgICAgIHZhciBmcm9tTGluZSA9IGxpbmVObyhkaXNwbGF5LnZpZXdbMF0ubGluZSk7XFxuICAgICAgICB2YXIgZnJvbU5vZGUgPSBkaXNwbGF5LnZpZXdbMF0ubm9kZTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgdmFyIGZyb21MaW5lID0gbGluZU5vKGRpc3BsYXkudmlld1tmcm9tSW5kZXhdLmxpbmUpO1xcbiAgICAgICAgdmFyIGZyb21Ob2RlID0gZGlzcGxheS52aWV3W2Zyb21JbmRleCAtIDFdLm5vZGUubmV4dFNpYmxpbmc7XFxuICAgICAgfVxcbiAgICAgIHZhciB0b0luZGV4ID0gZmluZFZpZXdJbmRleChjbSwgdG8ubGluZSk7XFxuICAgICAgaWYgKHRvSW5kZXggPT0gZGlzcGxheS52aWV3Lmxlbmd0aCAtIDEpIHtcXG4gICAgICAgIHZhciB0b0xpbmUgPSBkaXNwbGF5LnZpZXdUbyAtIDE7XFxuICAgICAgICB2YXIgdG9Ob2RlID0gZGlzcGxheS5saW5lRGl2Lmxhc3RDaGlsZDtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgdmFyIHRvTGluZSA9IGxpbmVObyhkaXNwbGF5LnZpZXdbdG9JbmRleCArIDFdLmxpbmUpIC0gMTtcXG4gICAgICAgIHZhciB0b05vZGUgPSBkaXNwbGF5LnZpZXdbdG9JbmRleCArIDFdLm5vZGUucHJldmlvdXNTaWJsaW5nO1xcbiAgICAgIH1cXG5cXG4gICAgICB2YXIgbmV3VGV4dCA9IGNtLmRvYy5zcGxpdExpbmVzKGRvbVRleHRCZXR3ZWVuKGNtLCBmcm9tTm9kZSwgdG9Ob2RlLCBmcm9tTGluZSwgdG9MaW5lKSk7XFxuICAgICAgdmFyIG9sZFRleHQgPSBnZXRCZXR3ZWVuKGNtLmRvYywgUG9zKGZyb21MaW5lLCAwKSwgUG9zKHRvTGluZSwgZ2V0TGluZShjbS5kb2MsIHRvTGluZSkudGV4dC5sZW5ndGgpKTtcXG4gICAgICB3aGlsZSAobmV3VGV4dC5sZW5ndGggPiAxICYmIG9sZFRleHQubGVuZ3RoID4gMSkge1xcbiAgICAgICAgaWYgKGxzdChuZXdUZXh0KSA9PSBsc3Qob2xkVGV4dCkpIHsgbmV3VGV4dC5wb3AoKTsgb2xkVGV4dC5wb3AoKTsgdG9MaW5lLS07IH1cXG4gICAgICAgIGVsc2UgaWYgKG5ld1RleHRbMF0gPT0gb2xkVGV4dFswXSkgeyBuZXdUZXh0LnNoaWZ0KCk7IG9sZFRleHQuc2hpZnQoKTsgZnJvbUxpbmUrKzsgfVxcbiAgICAgICAgZWxzZSBicmVhaztcXG4gICAgICB9XFxuXFxuICAgICAgdmFyIGN1dEZyb250ID0gMCwgY3V0RW5kID0gMDtcXG4gICAgICB2YXIgbmV3VG9wID0gbmV3VGV4dFswXSwgb2xkVG9wID0gb2xkVGV4dFswXSwgbWF4Q3V0RnJvbnQgPSBNYXRoLm1pbihuZXdUb3AubGVuZ3RoLCBvbGRUb3AubGVuZ3RoKTtcXG4gICAgICB3aGlsZSAoY3V0RnJvbnQgPCBtYXhDdXRGcm9udCAmJiBuZXdUb3AuY2hhckNvZGVBdChjdXRGcm9udCkgPT0gb2xkVG9wLmNoYXJDb2RlQXQoY3V0RnJvbnQpKVxcbiAgICAgICAgKytjdXRGcm9udDtcXG4gICAgICB2YXIgbmV3Qm90ID0gbHN0KG5ld1RleHQpLCBvbGRCb3QgPSBsc3Qob2xkVGV4dCk7XFxuICAgICAgdmFyIG1heEN1dEVuZCA9IE1hdGgubWluKG5ld0JvdC5sZW5ndGggLSAobmV3VGV4dC5sZW5ndGggPT0gMSA/IGN1dEZyb250IDogMCksXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9sZEJvdC5sZW5ndGggLSAob2xkVGV4dC5sZW5ndGggPT0gMSA/IGN1dEZyb250IDogMCkpO1xcbiAgICAgIHdoaWxlIChjdXRFbmQgPCBtYXhDdXRFbmQgJiZcXG4gICAgICAgICAgICAgbmV3Qm90LmNoYXJDb2RlQXQobmV3Qm90Lmxlbmd0aCAtIGN1dEVuZCAtIDEpID09IG9sZEJvdC5jaGFyQ29kZUF0KG9sZEJvdC5sZW5ndGggLSBjdXRFbmQgLSAxKSlcXG4gICAgICAgICsrY3V0RW5kO1xcblxcbiAgICAgIG5ld1RleHRbbmV3VGV4dC5sZW5ndGggLSAxXSA9IG5ld0JvdC5zbGljZSgwLCBuZXdCb3QubGVuZ3RoIC0gY3V0RW5kKTtcXG4gICAgICBuZXdUZXh0WzBdID0gbmV3VGV4dFswXS5zbGljZShjdXRGcm9udCk7XFxuXFxuICAgICAgdmFyIGNoRnJvbSA9IFBvcyhmcm9tTGluZSwgY3V0RnJvbnQpO1xcbiAgICAgIHZhciBjaFRvID0gUG9zKHRvTGluZSwgb2xkVGV4dC5sZW5ndGggPyBsc3Qob2xkVGV4dCkubGVuZ3RoIC0gY3V0RW5kIDogMCk7XFxuICAgICAgaWYgKG5ld1RleHQubGVuZ3RoID4gMSB8fCBuZXdUZXh0WzBdIHx8IGNtcChjaEZyb20sIGNoVG8pKSB7XFxuICAgICAgICByZXBsYWNlUmFuZ2UoY20uZG9jLCBuZXdUZXh0LCBjaEZyb20sIGNoVG8sIFxcXCIraW5wdXRcXFwiKTtcXG4gICAgICAgIHJldHVybiB0cnVlO1xcbiAgICAgIH1cXG4gICAgfSxcXG5cXG4gICAgZW5zdXJlUG9sbGVkOiBmdW5jdGlvbigpIHtcXG4gICAgICB0aGlzLmZvcmNlQ29tcG9zaXRpb25FbmQoKTtcXG4gICAgfSxcXG4gICAgcmVzZXQ6IGZ1bmN0aW9uKCkge1xcbiAgICAgIHRoaXMuZm9yY2VDb21wb3NpdGlvbkVuZCgpO1xcbiAgICB9LFxcbiAgICBmb3JjZUNvbXBvc2l0aW9uRW5kOiBmdW5jdGlvbigpIHtcXG4gICAgICBpZiAoIXRoaXMuY29tcG9zaW5nIHx8IHRoaXMuY29tcG9zaW5nLmhhbmRsZWQpIHJldHVybjtcXG4gICAgICB0aGlzLmFwcGx5Q29tcG9zaXRpb24odGhpcy5jb21wb3NpbmcpO1xcbiAgICAgIHRoaXMuY29tcG9zaW5nLmhhbmRsZWQgPSB0cnVlO1xcbiAgICAgIHRoaXMuZGl2LmJsdXIoKTtcXG4gICAgICB0aGlzLmRpdi5mb2N1cygpO1xcbiAgICB9LFxcbiAgICBhcHBseUNvbXBvc2l0aW9uOiBmdW5jdGlvbihjb21wb3NpbmcpIHtcXG4gICAgICBpZiAodGhpcy5jbS5pc1JlYWRPbmx5KCkpXFxuICAgICAgICBvcGVyYXRpb24odGhpcy5jbSwgcmVnQ2hhbmdlKSh0aGlzLmNtKVxcbiAgICAgIGVsc2UgaWYgKGNvbXBvc2luZy5kYXRhICYmIGNvbXBvc2luZy5kYXRhICE9IGNvbXBvc2luZy5zdGFydERhdGEpXFxuICAgICAgICBvcGVyYXRpb24odGhpcy5jbSwgYXBwbHlUZXh0SW5wdXQpKHRoaXMuY20sIGNvbXBvc2luZy5kYXRhLCAwLCBjb21wb3Npbmcuc2VsKTtcXG4gICAgfSxcXG5cXG4gICAgc2V0VW5lZGl0YWJsZTogZnVuY3Rpb24obm9kZSkge1xcbiAgICAgIG5vZGUuY29udGVudEVkaXRhYmxlID0gXFxcImZhbHNlXFxcIlxcbiAgICB9LFxcblxcbiAgICBvbktleVByZXNzOiBmdW5jdGlvbihlKSB7XFxuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xcbiAgICAgIGlmICghdGhpcy5jbS5pc1JlYWRPbmx5KCkpXFxuICAgICAgICBvcGVyYXRpb24odGhpcy5jbSwgYXBwbHlUZXh0SW5wdXQpKHRoaXMuY20sIFN0cmluZy5mcm9tQ2hhckNvZGUoZS5jaGFyQ29kZSA9PSBudWxsID8gZS5rZXlDb2RlIDogZS5jaGFyQ29kZSksIDApO1xcbiAgICB9LFxcblxcbiAgICByZWFkT25seUNoYW5nZWQ6IGZ1bmN0aW9uKHZhbCkge1xcbiAgICAgIHRoaXMuZGl2LmNvbnRlbnRFZGl0YWJsZSA9IFN0cmluZyh2YWwgIT0gXFxcIm5vY3Vyc29yXFxcIilcXG4gICAgfSxcXG5cXG4gICAgb25Db250ZXh0TWVudTogbm90aGluZyxcXG4gICAgcmVzZXRQb3NpdGlvbjogbm90aGluZyxcXG5cXG4gICAgbmVlZHNDb250ZW50QXR0cmlidXRlOiB0cnVlXFxuICB9LCBDb250ZW50RWRpdGFibGVJbnB1dC5wcm90b3R5cGUpO1xcblxcbiAgZnVuY3Rpb24gcG9zVG9ET00oY20sIHBvcykge1xcbiAgICB2YXIgdmlldyA9IGZpbmRWaWV3Rm9yTGluZShjbSwgcG9zLmxpbmUpO1xcbiAgICBpZiAoIXZpZXcgfHwgdmlldy5oaWRkZW4pIHJldHVybiBudWxsO1xcbiAgICB2YXIgbGluZSA9IGdldExpbmUoY20uZG9jLCBwb3MubGluZSk7XFxuICAgIHZhciBpbmZvID0gbWFwRnJvbUxpbmVWaWV3KHZpZXcsIGxpbmUsIHBvcy5saW5lKTtcXG5cXG4gICAgdmFyIG9yZGVyID0gZ2V0T3JkZXIobGluZSksIHNpZGUgPSBcXFwibGVmdFxcXCI7XFxuICAgIGlmIChvcmRlcikge1xcbiAgICAgIHZhciBwYXJ0UG9zID0gZ2V0QmlkaVBhcnRBdChvcmRlciwgcG9zLmNoKTtcXG4gICAgICBzaWRlID0gcGFydFBvcyAlIDIgPyBcXFwicmlnaHRcXFwiIDogXFxcImxlZnRcXFwiO1xcbiAgICB9XFxuICAgIHZhciByZXN1bHQgPSBub2RlQW5kT2Zmc2V0SW5MaW5lTWFwKGluZm8ubWFwLCBwb3MuY2gsIHNpZGUpO1xcbiAgICByZXN1bHQub2Zmc2V0ID0gcmVzdWx0LmNvbGxhcHNlID09IFxcXCJyaWdodFxcXCIgPyByZXN1bHQuZW5kIDogcmVzdWx0LnN0YXJ0O1xcbiAgICByZXR1cm4gcmVzdWx0O1xcbiAgfVxcblxcbiAgZnVuY3Rpb24gYmFkUG9zKHBvcywgYmFkKSB7IGlmIChiYWQpIHBvcy5iYWQgPSB0cnVlOyByZXR1cm4gcG9zOyB9XFxuXFxuICBmdW5jdGlvbiBkb21Ub1BvcyhjbSwgbm9kZSwgb2Zmc2V0KSB7XFxuICAgIHZhciBsaW5lTm9kZTtcXG4gICAgaWYgKG5vZGUgPT0gY20uZGlzcGxheS5saW5lRGl2KSB7XFxuICAgICAgbGluZU5vZGUgPSBjbS5kaXNwbGF5LmxpbmVEaXYuY2hpbGROb2Rlc1tvZmZzZXRdO1xcbiAgICAgIGlmICghbGluZU5vZGUpIHJldHVybiBiYWRQb3MoY20uY2xpcFBvcyhQb3MoY20uZGlzcGxheS52aWV3VG8gLSAxKSksIHRydWUpO1xcbiAgICAgIG5vZGUgPSBudWxsOyBvZmZzZXQgPSAwO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIGZvciAobGluZU5vZGUgPSBub2RlOzsgbGluZU5vZGUgPSBsaW5lTm9kZS5wYXJlbnROb2RlKSB7XFxuICAgICAgICBpZiAoIWxpbmVOb2RlIHx8IGxpbmVOb2RlID09IGNtLmRpc3BsYXkubGluZURpdikgcmV0dXJuIG51bGw7XFxuICAgICAgICBpZiAobGluZU5vZGUucGFyZW50Tm9kZSAmJiBsaW5lTm9kZS5wYXJlbnROb2RlID09IGNtLmRpc3BsYXkubGluZURpdikgYnJlYWs7XFxuICAgICAgfVxcbiAgICB9XFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY20uZGlzcGxheS52aWV3Lmxlbmd0aDsgaSsrKSB7XFxuICAgICAgdmFyIGxpbmVWaWV3ID0gY20uZGlzcGxheS52aWV3W2ldO1xcbiAgICAgIGlmIChsaW5lVmlldy5ub2RlID09IGxpbmVOb2RlKVxcbiAgICAgICAgcmV0dXJuIGxvY2F0ZU5vZGVJbkxpbmVWaWV3KGxpbmVWaWV3LCBub2RlLCBvZmZzZXQpO1xcbiAgICB9XFxuICB9XFxuXFxuICBmdW5jdGlvbiBsb2NhdGVOb2RlSW5MaW5lVmlldyhsaW5lVmlldywgbm9kZSwgb2Zmc2V0KSB7XFxuICAgIHZhciB3cmFwcGVyID0gbGluZVZpZXcudGV4dC5maXJzdENoaWxkLCBiYWQgPSBmYWxzZTtcXG4gICAgaWYgKCFub2RlIHx8ICFjb250YWlucyh3cmFwcGVyLCBub2RlKSkgcmV0dXJuIGJhZFBvcyhQb3MobGluZU5vKGxpbmVWaWV3LmxpbmUpLCAwKSwgdHJ1ZSk7XFxuICAgIGlmIChub2RlID09IHdyYXBwZXIpIHtcXG4gICAgICBiYWQgPSB0cnVlO1xcbiAgICAgIG5vZGUgPSB3cmFwcGVyLmNoaWxkTm9kZXNbb2Zmc2V0XTtcXG4gICAgICBvZmZzZXQgPSAwO1xcbiAgICAgIGlmICghbm9kZSkge1xcbiAgICAgICAgdmFyIGxpbmUgPSBsaW5lVmlldy5yZXN0ID8gbHN0KGxpbmVWaWV3LnJlc3QpIDogbGluZVZpZXcubGluZTtcXG4gICAgICAgIHJldHVybiBiYWRQb3MoUG9zKGxpbmVObyhsaW5lKSwgbGluZS50ZXh0Lmxlbmd0aCksIGJhZCk7XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIHZhciB0ZXh0Tm9kZSA9IG5vZGUubm9kZVR5cGUgPT0gMyA/IG5vZGUgOiBudWxsLCB0b3BOb2RlID0gbm9kZTtcXG4gICAgaWYgKCF0ZXh0Tm9kZSAmJiBub2RlLmNoaWxkTm9kZXMubGVuZ3RoID09IDEgJiYgbm9kZS5maXJzdENoaWxkLm5vZGVUeXBlID09IDMpIHtcXG4gICAgICB0ZXh0Tm9kZSA9IG5vZGUuZmlyc3RDaGlsZDtcXG4gICAgICBpZiAob2Zmc2V0KSBvZmZzZXQgPSB0ZXh0Tm9kZS5ub2RlVmFsdWUubGVuZ3RoO1xcbiAgICB9XFxuICAgIHdoaWxlICh0b3BOb2RlLnBhcmVudE5vZGUgIT0gd3JhcHBlcikgdG9wTm9kZSA9IHRvcE5vZGUucGFyZW50Tm9kZTtcXG4gICAgdmFyIG1lYXN1cmUgPSBsaW5lVmlldy5tZWFzdXJlLCBtYXBzID0gbWVhc3VyZS5tYXBzO1xcblxcbiAgICBmdW5jdGlvbiBmaW5kKHRleHROb2RlLCB0b3BOb2RlLCBvZmZzZXQpIHtcXG4gICAgICBmb3IgKHZhciBpID0gLTE7IGkgPCAobWFwcyA/IG1hcHMubGVuZ3RoIDogMCk7IGkrKykge1xcbiAgICAgICAgdmFyIG1hcCA9IGkgPCAwID8gbWVhc3VyZS5tYXAgOiBtYXBzW2ldO1xcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBtYXAubGVuZ3RoOyBqICs9IDMpIHtcXG4gICAgICAgICAgdmFyIGN1ck5vZGUgPSBtYXBbaiArIDJdO1xcbiAgICAgICAgICBpZiAoY3VyTm9kZSA9PSB0ZXh0Tm9kZSB8fCBjdXJOb2RlID09IHRvcE5vZGUpIHtcXG4gICAgICAgICAgICB2YXIgbGluZSA9IGxpbmVObyhpIDwgMCA/IGxpbmVWaWV3LmxpbmUgOiBsaW5lVmlldy5yZXN0W2ldKTtcXG4gICAgICAgICAgICB2YXIgY2ggPSBtYXBbal0gKyBvZmZzZXQ7XFxuICAgICAgICAgICAgaWYgKG9mZnNldCA8IDAgfHwgY3VyTm9kZSAhPSB0ZXh0Tm9kZSkgY2ggPSBtYXBbaiArIChvZmZzZXQgPyAxIDogMCldO1xcbiAgICAgICAgICAgIHJldHVybiBQb3MobGluZSwgY2gpO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICB9XFxuICAgIHZhciBmb3VuZCA9IGZpbmQodGV4dE5vZGUsIHRvcE5vZGUsIG9mZnNldCk7XFxuICAgIGlmIChmb3VuZCkgcmV0dXJuIGJhZFBvcyhmb3VuZCwgYmFkKTtcXG5cXG4gICAgLy8gRklYTUUgdGhpcyBpcyBhbGwgcmVhbGx5IHNoYWt5LiBtaWdodCBoYW5kbGUgdGhlIGZldyBjYXNlcyBpdCBuZWVkcyB0byBoYW5kbGUsIGJ1dCBsaWtlbHkgdG8gY2F1c2UgcHJvYmxlbXNcXG4gICAgZm9yICh2YXIgYWZ0ZXIgPSB0b3BOb2RlLm5leHRTaWJsaW5nLCBkaXN0ID0gdGV4dE5vZGUgPyB0ZXh0Tm9kZS5ub2RlVmFsdWUubGVuZ3RoIC0gb2Zmc2V0IDogMDsgYWZ0ZXI7IGFmdGVyID0gYWZ0ZXIubmV4dFNpYmxpbmcpIHtcXG4gICAgICBmb3VuZCA9IGZpbmQoYWZ0ZXIsIGFmdGVyLmZpcnN0Q2hpbGQsIDApO1xcbiAgICAgIGlmIChmb3VuZClcXG4gICAgICAgIHJldHVybiBiYWRQb3MoUG9zKGZvdW5kLmxpbmUsIGZvdW5kLmNoIC0gZGlzdCksIGJhZCk7XFxuICAgICAgZWxzZVxcbiAgICAgICAgZGlzdCArPSBhZnRlci50ZXh0Q29udGVudC5sZW5ndGg7XFxuICAgIH1cXG4gICAgZm9yICh2YXIgYmVmb3JlID0gdG9wTm9kZS5wcmV2aW91c1NpYmxpbmcsIGRpc3QgPSBvZmZzZXQ7IGJlZm9yZTsgYmVmb3JlID0gYmVmb3JlLnByZXZpb3VzU2libGluZykge1xcbiAgICAgIGZvdW5kID0gZmluZChiZWZvcmUsIGJlZm9yZS5maXJzdENoaWxkLCAtMSk7XFxuICAgICAgaWYgKGZvdW5kKVxcbiAgICAgICAgcmV0dXJuIGJhZFBvcyhQb3MoZm91bmQubGluZSwgZm91bmQuY2ggKyBkaXN0KSwgYmFkKTtcXG4gICAgICBlbHNlXFxuICAgICAgICBkaXN0ICs9IGJlZm9yZS50ZXh0Q29udGVudC5sZW5ndGg7XFxuICAgIH1cXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIGRvbVRleHRCZXR3ZWVuKGNtLCBmcm9tLCB0bywgZnJvbUxpbmUsIHRvTGluZSkge1xcbiAgICB2YXIgdGV4dCA9IFxcXCJcXFwiLCBjbG9zaW5nID0gZmFsc2UsIGxpbmVTZXAgPSBjbS5kb2MubGluZVNlcGFyYXRvcigpO1xcbiAgICBmdW5jdGlvbiByZWNvZ25pemVNYXJrZXIoaWQpIHsgcmV0dXJuIGZ1bmN0aW9uKG1hcmtlcikgeyByZXR1cm4gbWFya2VyLmlkID09IGlkOyB9OyB9XFxuICAgIGZ1bmN0aW9uIHdhbGsobm9kZSkge1xcbiAgICAgIGlmIChub2RlLm5vZGVUeXBlID09IDEpIHtcXG4gICAgICAgIHZhciBjbVRleHQgPSBub2RlLmdldEF0dHJpYnV0ZShcXFwiY20tdGV4dFxcXCIpO1xcbiAgICAgICAgaWYgKGNtVGV4dCAhPSBudWxsKSB7XFxuICAgICAgICAgIGlmIChjbVRleHQgPT0gXFxcIlxcXCIpIGNtVGV4dCA9IG5vZGUudGV4dENvbnRlbnQucmVwbGFjZSgvXFxcXHUyMDBiL2csIFxcXCJcXFwiKTtcXG4gICAgICAgICAgdGV4dCArPSBjbVRleHQ7XFxuICAgICAgICAgIHJldHVybjtcXG4gICAgICAgIH1cXG4gICAgICAgIHZhciBtYXJrZXJJRCA9IG5vZGUuZ2V0QXR0cmlidXRlKFxcXCJjbS1tYXJrZXJcXFwiKSwgcmFuZ2U7XFxuICAgICAgICBpZiAobWFya2VySUQpIHtcXG4gICAgICAgICAgdmFyIGZvdW5kID0gY20uZmluZE1hcmtzKFBvcyhmcm9tTGluZSwgMCksIFBvcyh0b0xpbmUgKyAxLCAwKSwgcmVjb2duaXplTWFya2VyKCttYXJrZXJJRCkpO1xcbiAgICAgICAgICBpZiAoZm91bmQubGVuZ3RoICYmIChyYW5nZSA9IGZvdW5kWzBdLmZpbmQoKSkpXFxuICAgICAgICAgICAgdGV4dCArPSBnZXRCZXR3ZWVuKGNtLmRvYywgcmFuZ2UuZnJvbSwgcmFuZ2UudG8pLmpvaW4obGluZVNlcCk7XFxuICAgICAgICAgIHJldHVybjtcXG4gICAgICAgIH1cXG4gICAgICAgIGlmIChub2RlLmdldEF0dHJpYnV0ZShcXFwiY29udGVudGVkaXRhYmxlXFxcIikgPT0gXFxcImZhbHNlXFxcIikgcmV0dXJuO1xcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLmNoaWxkTm9kZXMubGVuZ3RoOyBpKyspXFxuICAgICAgICAgIHdhbGsobm9kZS5jaGlsZE5vZGVzW2ldKTtcXG4gICAgICAgIGlmICgvXihwcmV8ZGl2fHApJC9pLnRlc3Qobm9kZS5ub2RlTmFtZSkpXFxuICAgICAgICAgIGNsb3NpbmcgPSB0cnVlO1xcbiAgICAgIH0gZWxzZSBpZiAobm9kZS5ub2RlVHlwZSA9PSAzKSB7XFxuICAgICAgICB2YXIgdmFsID0gbm9kZS5ub2RlVmFsdWU7XFxuICAgICAgICBpZiAoIXZhbCkgcmV0dXJuO1xcbiAgICAgICAgaWYgKGNsb3NpbmcpIHtcXG4gICAgICAgICAgdGV4dCArPSBsaW5lU2VwO1xcbiAgICAgICAgICBjbG9zaW5nID0gZmFsc2U7XFxuICAgICAgICB9XFxuICAgICAgICB0ZXh0ICs9IHZhbDtcXG4gICAgICB9XFxuICAgIH1cXG4gICAgZm9yICg7Oykge1xcbiAgICAgIHdhbGsoZnJvbSk7XFxuICAgICAgaWYgKGZyb20gPT0gdG8pIGJyZWFrO1xcbiAgICAgIGZyb20gPSBmcm9tLm5leHRTaWJsaW5nO1xcbiAgICB9XFxuICAgIHJldHVybiB0ZXh0O1xcbiAgfVxcblxcbiAgQ29kZU1pcnJvci5pbnB1dFN0eWxlcyA9IHtcXFwidGV4dGFyZWFcXFwiOiBUZXh0YXJlYUlucHV0LCBcXFwiY29udGVudGVkaXRhYmxlXFxcIjogQ29udGVudEVkaXRhYmxlSW5wdXR9O1xcblxcbiAgLy8gU0VMRUNUSU9OIC8gQ1VSU09SXFxuXFxuICAvLyBTZWxlY3Rpb24gb2JqZWN0cyBhcmUgaW1tdXRhYmxlLiBBIG5ldyBvbmUgaXMgY3JlYXRlZCBldmVyeSB0aW1lXFxuICAvLyB0aGUgc2VsZWN0aW9uIGNoYW5nZXMuIEEgc2VsZWN0aW9uIGlzIG9uZSBvciBtb3JlIG5vbi1vdmVybGFwcGluZ1xcbiAgLy8gKGFuZCBub24tdG91Y2hpbmcpIHJhbmdlcywgc29ydGVkLCBhbmQgYW4gaW50ZWdlciB0aGF0IGluZGljYXRlc1xcbiAgLy8gd2hpY2ggb25lIGlzIHRoZSBwcmltYXJ5IHNlbGVjdGlvbiAodGhlIG9uZSB0aGF0J3Mgc2Nyb2xsZWQgaW50b1xcbiAgLy8gdmlldywgdGhhdCBnZXRDdXJzb3IgcmV0dXJucywgZXRjKS5cXG4gIGZ1bmN0aW9uIFNlbGVjdGlvbihyYW5nZXMsIHByaW1JbmRleCkge1xcbiAgICB0aGlzLnJhbmdlcyA9IHJhbmdlcztcXG4gICAgdGhpcy5wcmltSW5kZXggPSBwcmltSW5kZXg7XFxuICB9XFxuXFxuICBTZWxlY3Rpb24ucHJvdG90eXBlID0ge1xcbiAgICBwcmltYXJ5OiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMucmFuZ2VzW3RoaXMucHJpbUluZGV4XTsgfSxcXG4gICAgZXF1YWxzOiBmdW5jdGlvbihvdGhlcikge1xcbiAgICAgIGlmIChvdGhlciA9PSB0aGlzKSByZXR1cm4gdHJ1ZTtcXG4gICAgICBpZiAob3RoZXIucHJpbUluZGV4ICE9IHRoaXMucHJpbUluZGV4IHx8IG90aGVyLnJhbmdlcy5sZW5ndGggIT0gdGhpcy5yYW5nZXMubGVuZ3RoKSByZXR1cm4gZmFsc2U7XFxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnJhbmdlcy5sZW5ndGg7IGkrKykge1xcbiAgICAgICAgdmFyIGhlcmUgPSB0aGlzLnJhbmdlc1tpXSwgdGhlcmUgPSBvdGhlci5yYW5nZXNbaV07XFxuICAgICAgICBpZiAoY21wKGhlcmUuYW5jaG9yLCB0aGVyZS5hbmNob3IpICE9IDAgfHwgY21wKGhlcmUuaGVhZCwgdGhlcmUuaGVhZCkgIT0gMCkgcmV0dXJuIGZhbHNlO1xcbiAgICAgIH1cXG4gICAgICByZXR1cm4gdHJ1ZTtcXG4gICAgfSxcXG4gICAgZGVlcENvcHk6IGZ1bmN0aW9uKCkge1xcbiAgICAgIGZvciAodmFyIG91dCA9IFtdLCBpID0gMDsgaSA8IHRoaXMucmFuZ2VzLmxlbmd0aDsgaSsrKVxcbiAgICAgICAgb3V0W2ldID0gbmV3IFJhbmdlKGNvcHlQb3ModGhpcy5yYW5nZXNbaV0uYW5jaG9yKSwgY29weVBvcyh0aGlzLnJhbmdlc1tpXS5oZWFkKSk7XFxuICAgICAgcmV0dXJuIG5ldyBTZWxlY3Rpb24ob3V0LCB0aGlzLnByaW1JbmRleCk7XFxuICAgIH0sXFxuICAgIHNvbWV0aGluZ1NlbGVjdGVkOiBmdW5jdGlvbigpIHtcXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucmFuZ2VzLmxlbmd0aDsgaSsrKVxcbiAgICAgICAgaWYgKCF0aGlzLnJhbmdlc1tpXS5lbXB0eSgpKSByZXR1cm4gdHJ1ZTtcXG4gICAgICByZXR1cm4gZmFsc2U7XFxuICAgIH0sXFxuICAgIGNvbnRhaW5zOiBmdW5jdGlvbihwb3MsIGVuZCkge1xcbiAgICAgIGlmICghZW5kKSBlbmQgPSBwb3M7XFxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnJhbmdlcy5sZW5ndGg7IGkrKykge1xcbiAgICAgICAgdmFyIHJhbmdlID0gdGhpcy5yYW5nZXNbaV07XFxuICAgICAgICBpZiAoY21wKGVuZCwgcmFuZ2UuZnJvbSgpKSA+PSAwICYmIGNtcChwb3MsIHJhbmdlLnRvKCkpIDw9IDApXFxuICAgICAgICAgIHJldHVybiBpO1xcbiAgICAgIH1cXG4gICAgICByZXR1cm4gLTE7XFxuICAgIH1cXG4gIH07XFxuXFxuICBmdW5jdGlvbiBSYW5nZShhbmNob3IsIGhlYWQpIHtcXG4gICAgdGhpcy5hbmNob3IgPSBhbmNob3I7IHRoaXMuaGVhZCA9IGhlYWQ7XFxuICB9XFxuXFxuICBSYW5nZS5wcm90b3R5cGUgPSB7XFxuICAgIGZyb206IGZ1bmN0aW9uKCkgeyByZXR1cm4gbWluUG9zKHRoaXMuYW5jaG9yLCB0aGlzLmhlYWQpOyB9LFxcbiAgICB0bzogZnVuY3Rpb24oKSB7IHJldHVybiBtYXhQb3ModGhpcy5hbmNob3IsIHRoaXMuaGVhZCk7IH0sXFxuICAgIGVtcHR5OiBmdW5jdGlvbigpIHtcXG4gICAgICByZXR1cm4gdGhpcy5oZWFkLmxpbmUgPT0gdGhpcy5hbmNob3IubGluZSAmJiB0aGlzLmhlYWQuY2ggPT0gdGhpcy5hbmNob3IuY2g7XFxuICAgIH1cXG4gIH07XFxuXFxuICAvLyBUYWtlIGFuIHVuc29ydGVkLCBwb3RlbnRpYWxseSBvdmVybGFwcGluZyBzZXQgb2YgcmFuZ2VzLCBhbmRcXG4gIC8vIGJ1aWxkIGEgc2VsZWN0aW9uIG91dCBvZiBpdC4gJ0NvbnN1bWVzJyByYW5nZXMgYXJyYXkgKG1vZGlmeWluZ1xcbiAgLy8gaXQpLlxcbiAgZnVuY3Rpb24gbm9ybWFsaXplU2VsZWN0aW9uKHJhbmdlcywgcHJpbUluZGV4KSB7XFxuICAgIHZhciBwcmltID0gcmFuZ2VzW3ByaW1JbmRleF07XFxuICAgIHJhbmdlcy5zb3J0KGZ1bmN0aW9uKGEsIGIpIHsgcmV0dXJuIGNtcChhLmZyb20oKSwgYi5mcm9tKCkpOyB9KTtcXG4gICAgcHJpbUluZGV4ID0gaW5kZXhPZihyYW5nZXMsIHByaW0pO1xcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IHJhbmdlcy5sZW5ndGg7IGkrKykge1xcbiAgICAgIHZhciBjdXIgPSByYW5nZXNbaV0sIHByZXYgPSByYW5nZXNbaSAtIDFdO1xcbiAgICAgIGlmIChjbXAocHJldi50bygpLCBjdXIuZnJvbSgpKSA+PSAwKSB7XFxuICAgICAgICB2YXIgZnJvbSA9IG1pblBvcyhwcmV2LmZyb20oKSwgY3VyLmZyb20oKSksIHRvID0gbWF4UG9zKHByZXYudG8oKSwgY3VyLnRvKCkpO1xcbiAgICAgICAgdmFyIGludiA9IHByZXYuZW1wdHkoKSA/IGN1ci5mcm9tKCkgPT0gY3VyLmhlYWQgOiBwcmV2LmZyb20oKSA9PSBwcmV2LmhlYWQ7XFxuICAgICAgICBpZiAoaSA8PSBwcmltSW5kZXgpIC0tcHJpbUluZGV4O1xcbiAgICAgICAgcmFuZ2VzLnNwbGljZSgtLWksIDIsIG5ldyBSYW5nZShpbnYgPyB0byA6IGZyb20sIGludiA/IGZyb20gOiB0bykpO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgICByZXR1cm4gbmV3IFNlbGVjdGlvbihyYW5nZXMsIHByaW1JbmRleCk7XFxuICB9XFxuXFxuICBmdW5jdGlvbiBzaW1wbGVTZWxlY3Rpb24oYW5jaG9yLCBoZWFkKSB7XFxuICAgIHJldHVybiBuZXcgU2VsZWN0aW9uKFtuZXcgUmFuZ2UoYW5jaG9yLCBoZWFkIHx8IGFuY2hvcildLCAwKTtcXG4gIH1cXG5cXG4gIC8vIE1vc3Qgb2YgdGhlIGV4dGVybmFsIEFQSSBjbGlwcyBnaXZlbiBwb3NpdGlvbnMgdG8gbWFrZSBzdXJlIHRoZXlcXG4gIC8vIGFjdHVhbGx5IGV4aXN0IHdpdGhpbiB0aGUgZG9jdW1lbnQuXFxuICBmdW5jdGlvbiBjbGlwTGluZShkb2MsIG4pIHtyZXR1cm4gTWF0aC5tYXgoZG9jLmZpcnN0LCBNYXRoLm1pbihuLCBkb2MuZmlyc3QgKyBkb2Muc2l6ZSAtIDEpKTt9XFxuICBmdW5jdGlvbiBjbGlwUG9zKGRvYywgcG9zKSB7XFxuICAgIGlmIChwb3MubGluZSA8IGRvYy5maXJzdCkgcmV0dXJuIFBvcyhkb2MuZmlyc3QsIDApO1xcbiAgICB2YXIgbGFzdCA9IGRvYy5maXJzdCArIGRvYy5zaXplIC0gMTtcXG4gICAgaWYgKHBvcy5saW5lID4gbGFzdCkgcmV0dXJuIFBvcyhsYXN0LCBnZXRMaW5lKGRvYywgbGFzdCkudGV4dC5sZW5ndGgpO1xcbiAgICByZXR1cm4gY2xpcFRvTGVuKHBvcywgZ2V0TGluZShkb2MsIHBvcy5saW5lKS50ZXh0Lmxlbmd0aCk7XFxuICB9XFxuICBmdW5jdGlvbiBjbGlwVG9MZW4ocG9zLCBsaW5lbGVuKSB7XFxuICAgIHZhciBjaCA9IHBvcy5jaDtcXG4gICAgaWYgKGNoID09IG51bGwgfHwgY2ggPiBsaW5lbGVuKSByZXR1cm4gUG9zKHBvcy5saW5lLCBsaW5lbGVuKTtcXG4gICAgZWxzZSBpZiAoY2ggPCAwKSByZXR1cm4gUG9zKHBvcy5saW5lLCAwKTtcXG4gICAgZWxzZSByZXR1cm4gcG9zO1xcbiAgfVxcbiAgZnVuY3Rpb24gaXNMaW5lKGRvYywgbCkge3JldHVybiBsID49IGRvYy5maXJzdCAmJiBsIDwgZG9jLmZpcnN0ICsgZG9jLnNpemU7fVxcbiAgZnVuY3Rpb24gY2xpcFBvc0FycmF5KGRvYywgYXJyYXkpIHtcXG4gICAgZm9yICh2YXIgb3V0ID0gW10sIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIG91dFtpXSA9IGNsaXBQb3MoZG9jLCBhcnJheVtpXSk7XFxuICAgIHJldHVybiBvdXQ7XFxuICB9XFxuXFxuICAvLyBTRUxFQ1RJT04gVVBEQVRFU1xcblxcbiAgLy8gVGhlICdzY3JvbGwnIHBhcmFtZXRlciBnaXZlbiB0byBtYW55IG9mIHRoZXNlIGluZGljYXRlZCB3aGV0aGVyXFxuICAvLyB0aGUgbmV3IGN1cnNvciBwb3NpdGlvbiBzaG91bGQgYmUgc2Nyb2xsZWQgaW50byB2aWV3IGFmdGVyXFxuICAvLyBtb2RpZnlpbmcgdGhlIHNlbGVjdGlvbi5cXG5cXG4gIC8vIElmIHNoaWZ0IGlzIGhlbGQgb3IgdGhlIGV4dGVuZCBmbGFnIGlzIHNldCwgZXh0ZW5kcyBhIHJhbmdlIHRvXFxuICAvLyBpbmNsdWRlIGEgZ2l2ZW4gcG9zaXRpb24gKGFuZCBvcHRpb25hbGx5IGEgc2Vjb25kIHBvc2l0aW9uKS5cXG4gIC8vIE90aGVyd2lzZSwgc2ltcGx5IHJldHVybnMgdGhlIHJhbmdlIGJldHdlZW4gdGhlIGdpdmVuIHBvc2l0aW9ucy5cXG4gIC8vIFVzZWQgZm9yIGN1cnNvciBtb3Rpb24gYW5kIHN1Y2guXFxuICBmdW5jdGlvbiBleHRlbmRSYW5nZShkb2MsIHJhbmdlLCBoZWFkLCBvdGhlcikge1xcbiAgICBpZiAoZG9jLmNtICYmIGRvYy5jbS5kaXNwbGF5LnNoaWZ0IHx8IGRvYy5leHRlbmQpIHtcXG4gICAgICB2YXIgYW5jaG9yID0gcmFuZ2UuYW5jaG9yO1xcbiAgICAgIGlmIChvdGhlcikge1xcbiAgICAgICAgdmFyIHBvc0JlZm9yZSA9IGNtcChoZWFkLCBhbmNob3IpIDwgMDtcXG4gICAgICAgIGlmIChwb3NCZWZvcmUgIT0gKGNtcChvdGhlciwgYW5jaG9yKSA8IDApKSB7XFxuICAgICAgICAgIGFuY2hvciA9IGhlYWQ7XFxuICAgICAgICAgIGhlYWQgPSBvdGhlcjtcXG4gICAgICAgIH0gZWxzZSBpZiAocG9zQmVmb3JlICE9IChjbXAoaGVhZCwgb3RoZXIpIDwgMCkpIHtcXG4gICAgICAgICAgaGVhZCA9IG90aGVyO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgICByZXR1cm4gbmV3IFJhbmdlKGFuY2hvciwgaGVhZCk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgcmV0dXJuIG5ldyBSYW5nZShvdGhlciB8fCBoZWFkLCBoZWFkKTtcXG4gICAgfVxcbiAgfVxcblxcbiAgLy8gRXh0ZW5kIHRoZSBwcmltYXJ5IHNlbGVjdGlvbiByYW5nZSwgZGlzY2FyZCB0aGUgcmVzdC5cXG4gIGZ1bmN0aW9uIGV4dGVuZFNlbGVjdGlvbihkb2MsIGhlYWQsIG90aGVyLCBvcHRpb25zKSB7XFxuICAgIHNldFNlbGVjdGlvbihkb2MsIG5ldyBTZWxlY3Rpb24oW2V4dGVuZFJhbmdlKGRvYywgZG9jLnNlbC5wcmltYXJ5KCksIGhlYWQsIG90aGVyKV0sIDApLCBvcHRpb25zKTtcXG4gIH1cXG5cXG4gIC8vIEV4dGVuZCBhbGwgc2VsZWN0aW9ucyAocG9zIGlzIGFuIGFycmF5IG9mIHNlbGVjdGlvbnMgd2l0aCBsZW5ndGhcXG4gIC8vIGVxdWFsIHRoZSBudW1iZXIgb2Ygc2VsZWN0aW9ucylcXG4gIGZ1bmN0aW9uIGV4dGVuZFNlbGVjdGlvbnMoZG9jLCBoZWFkcywgb3B0aW9ucykge1xcbiAgICBmb3IgKHZhciBvdXQgPSBbXSwgaSA9IDA7IGkgPCBkb2Muc2VsLnJhbmdlcy5sZW5ndGg7IGkrKylcXG4gICAgICBvdXRbaV0gPSBleHRlbmRSYW5nZShkb2MsIGRvYy5zZWwucmFuZ2VzW2ldLCBoZWFkc1tpXSwgbnVsbCk7XFxuICAgIHZhciBuZXdTZWwgPSBub3JtYWxpemVTZWxlY3Rpb24ob3V0LCBkb2Muc2VsLnByaW1JbmRleCk7XFxuICAgIHNldFNlbGVjdGlvbihkb2MsIG5ld1NlbCwgb3B0aW9ucyk7XFxuICB9XFxuXFxuICAvLyBVcGRhdGVzIGEgc2luZ2xlIHJhbmdlIGluIHRoZSBzZWxlY3Rpb24uXFxuICBmdW5jdGlvbiByZXBsYWNlT25lU2VsZWN0aW9uKGRvYywgaSwgcmFuZ2UsIG9wdGlvbnMpIHtcXG4gICAgdmFyIHJhbmdlcyA9IGRvYy5zZWwucmFuZ2VzLnNsaWNlKDApO1xcbiAgICByYW5nZXNbaV0gPSByYW5nZTtcXG4gICAgc2V0U2VsZWN0aW9uKGRvYywgbm9ybWFsaXplU2VsZWN0aW9uKHJhbmdlcywgZG9jLnNlbC5wcmltSW5kZXgpLCBvcHRpb25zKTtcXG4gIH1cXG5cXG4gIC8vIFJlc2V0IHRoZSBzZWxlY3Rpb24gdG8gYSBzaW5nbGUgcmFuZ2UuXFxuICBmdW5jdGlvbiBzZXRTaW1wbGVTZWxlY3Rpb24oZG9jLCBhbmNob3IsIGhlYWQsIG9wdGlvbnMpIHtcXG4gICAgc2V0U2VsZWN0aW9uKGRvYywgc2ltcGxlU2VsZWN0aW9uKGFuY2hvciwgaGVhZCksIG9wdGlvbnMpO1xcbiAgfVxcblxcbiAgLy8gR2l2ZSBiZWZvcmVTZWxlY3Rpb25DaGFuZ2UgaGFuZGxlcnMgYSBjaGFuZ2UgdG8gaW5mbHVlbmNlIGFcXG4gIC8vIHNlbGVjdGlvbiB1cGRhdGUuXFxuICBmdW5jdGlvbiBmaWx0ZXJTZWxlY3Rpb25DaGFuZ2UoZG9jLCBzZWwsIG9wdGlvbnMpIHtcXG4gICAgdmFyIG9iaiA9IHtcXG4gICAgICByYW5nZXM6IHNlbC5yYW5nZXMsXFxuICAgICAgdXBkYXRlOiBmdW5jdGlvbihyYW5nZXMpIHtcXG4gICAgICAgIHRoaXMucmFuZ2VzID0gW107XFxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJhbmdlcy5sZW5ndGg7IGkrKylcXG4gICAgICAgICAgdGhpcy5yYW5nZXNbaV0gPSBuZXcgUmFuZ2UoY2xpcFBvcyhkb2MsIHJhbmdlc1tpXS5hbmNob3IpLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGlwUG9zKGRvYywgcmFuZ2VzW2ldLmhlYWQpKTtcXG4gICAgICB9LFxcbiAgICAgIG9yaWdpbjogb3B0aW9ucyAmJiBvcHRpb25zLm9yaWdpblxcbiAgICB9O1xcbiAgICBzaWduYWwoZG9jLCBcXFwiYmVmb3JlU2VsZWN0aW9uQ2hhbmdlXFxcIiwgZG9jLCBvYmopO1xcbiAgICBpZiAoZG9jLmNtKSBzaWduYWwoZG9jLmNtLCBcXFwiYmVmb3JlU2VsZWN0aW9uQ2hhbmdlXFxcIiwgZG9jLmNtLCBvYmopO1xcbiAgICBpZiAob2JqLnJhbmdlcyAhPSBzZWwucmFuZ2VzKSByZXR1cm4gbm9ybWFsaXplU2VsZWN0aW9uKG9iai5yYW5nZXMsIG9iai5yYW5nZXMubGVuZ3RoIC0gMSk7XFxuICAgIGVsc2UgcmV0dXJuIHNlbDtcXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIHNldFNlbGVjdGlvblJlcGxhY2VIaXN0b3J5KGRvYywgc2VsLCBvcHRpb25zKSB7XFxuICAgIHZhciBkb25lID0gZG9jLmhpc3RvcnkuZG9uZSwgbGFzdCA9IGxzdChkb25lKTtcXG4gICAgaWYgKGxhc3QgJiYgbGFzdC5yYW5nZXMpIHtcXG4gICAgICBkb25lW2RvbmUubGVuZ3RoIC0gMV0gPSBzZWw7XFxuICAgICAgc2V0U2VsZWN0aW9uTm9VbmRvKGRvYywgc2VsLCBvcHRpb25zKTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICBzZXRTZWxlY3Rpb24oZG9jLCBzZWwsIG9wdGlvbnMpO1xcbiAgICB9XFxuICB9XFxuXFxuICAvLyBTZXQgYSBuZXcgc2VsZWN0aW9uLlxcbiAgZnVuY3Rpb24gc2V0U2VsZWN0aW9uKGRvYywgc2VsLCBvcHRpb25zKSB7XFxuICAgIHNldFNlbGVjdGlvbk5vVW5kbyhkb2MsIHNlbCwgb3B0aW9ucyk7XFxuICAgIGFkZFNlbGVjdGlvblRvSGlzdG9yeShkb2MsIGRvYy5zZWwsIGRvYy5jbSA/IGRvYy5jbS5jdXJPcC5pZCA6IE5hTiwgb3B0aW9ucyk7XFxuICB9XFxuXFxuICBmdW5jdGlvbiBzZXRTZWxlY3Rpb25Ob1VuZG8oZG9jLCBzZWwsIG9wdGlvbnMpIHtcXG4gICAgaWYgKGhhc0hhbmRsZXIoZG9jLCBcXFwiYmVmb3JlU2VsZWN0aW9uQ2hhbmdlXFxcIikgfHwgZG9jLmNtICYmIGhhc0hhbmRsZXIoZG9jLmNtLCBcXFwiYmVmb3JlU2VsZWN0aW9uQ2hhbmdlXFxcIikpXFxuICAgICAgc2VsID0gZmlsdGVyU2VsZWN0aW9uQ2hhbmdlKGRvYywgc2VsLCBvcHRpb25zKTtcXG5cXG4gICAgdmFyIGJpYXMgPSBvcHRpb25zICYmIG9wdGlvbnMuYmlhcyB8fFxcbiAgICAgIChjbXAoc2VsLnByaW1hcnkoKS5oZWFkLCBkb2Muc2VsLnByaW1hcnkoKS5oZWFkKSA8IDAgPyAtMSA6IDEpO1xcbiAgICBzZXRTZWxlY3Rpb25Jbm5lcihkb2MsIHNraXBBdG9taWNJblNlbGVjdGlvbihkb2MsIHNlbCwgYmlhcywgdHJ1ZSkpO1xcblxcbiAgICBpZiAoIShvcHRpb25zICYmIG9wdGlvbnMuc2Nyb2xsID09PSBmYWxzZSkgJiYgZG9jLmNtKVxcbiAgICAgIGVuc3VyZUN1cnNvclZpc2libGUoZG9jLmNtKTtcXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIHNldFNlbGVjdGlvbklubmVyKGRvYywgc2VsKSB7XFxuICAgIGlmIChzZWwuZXF1YWxzKGRvYy5zZWwpKSByZXR1cm47XFxuXFxuICAgIGRvYy5zZWwgPSBzZWw7XFxuXFxuICAgIGlmIChkb2MuY20pIHtcXG4gICAgICBkb2MuY20uY3VyT3AudXBkYXRlSW5wdXQgPSBkb2MuY20uY3VyT3Auc2VsZWN0aW9uQ2hhbmdlZCA9IHRydWU7XFxuICAgICAgc2lnbmFsQ3Vyc29yQWN0aXZpdHkoZG9jLmNtKTtcXG4gICAgfVxcbiAgICBzaWduYWxMYXRlcihkb2MsIFxcXCJjdXJzb3JBY3Rpdml0eVxcXCIsIGRvYyk7XFxuICB9XFxuXFxuICAvLyBWZXJpZnkgdGhhdCB0aGUgc2VsZWN0aW9uIGRvZXMgbm90IHBhcnRpYWxseSBzZWxlY3QgYW55IGF0b21pY1xcbiAgLy8gbWFya2VkIHJhbmdlcy5cXG4gIGZ1bmN0aW9uIHJlQ2hlY2tTZWxlY3Rpb24oZG9jKSB7XFxuICAgIHNldFNlbGVjdGlvbklubmVyKGRvYywgc2tpcEF0b21pY0luU2VsZWN0aW9uKGRvYywgZG9jLnNlbCwgbnVsbCwgZmFsc2UpLCBzZWxfZG9udFNjcm9sbCk7XFxuICB9XFxuXFxuICAvLyBSZXR1cm4gYSBzZWxlY3Rpb24gdGhhdCBkb2VzIG5vdCBwYXJ0aWFsbHkgc2VsZWN0IGFueSBhdG9taWNcXG4gIC8vIHJhbmdlcy5cXG4gIGZ1bmN0aW9uIHNraXBBdG9taWNJblNlbGVjdGlvbihkb2MsIHNlbCwgYmlhcywgbWF5Q2xlYXIpIHtcXG4gICAgdmFyIG91dDtcXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWwucmFuZ2VzLmxlbmd0aDsgaSsrKSB7XFxuICAgICAgdmFyIHJhbmdlID0gc2VsLnJhbmdlc1tpXTtcXG4gICAgICB2YXIgb2xkID0gc2VsLnJhbmdlcy5sZW5ndGggPT0gZG9jLnNlbC5yYW5nZXMubGVuZ3RoICYmIGRvYy5zZWwucmFuZ2VzW2ldO1xcbiAgICAgIHZhciBuZXdBbmNob3IgPSBza2lwQXRvbWljKGRvYywgcmFuZ2UuYW5jaG9yLCBvbGQgJiYgb2xkLmFuY2hvciwgYmlhcywgbWF5Q2xlYXIpO1xcbiAgICAgIHZhciBuZXdIZWFkID0gc2tpcEF0b21pYyhkb2MsIHJhbmdlLmhlYWQsIG9sZCAmJiBvbGQuaGVhZCwgYmlhcywgbWF5Q2xlYXIpO1xcbiAgICAgIGlmIChvdXQgfHwgbmV3QW5jaG9yICE9IHJhbmdlLmFuY2hvciB8fCBuZXdIZWFkICE9IHJhbmdlLmhlYWQpIHtcXG4gICAgICAgIGlmICghb3V0KSBvdXQgPSBzZWwucmFuZ2VzLnNsaWNlKDAsIGkpO1xcbiAgICAgICAgb3V0W2ldID0gbmV3IFJhbmdlKG5ld0FuY2hvciwgbmV3SGVhZCk7XFxuICAgICAgfVxcbiAgICB9XFxuICAgIHJldHVybiBvdXQgPyBub3JtYWxpemVTZWxlY3Rpb24ob3V0LCBzZWwucHJpbUluZGV4KSA6IHNlbDtcXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIHNraXBBdG9taWNJbm5lcihkb2MsIHBvcywgb2xkUG9zLCBkaXIsIG1heUNsZWFyKSB7XFxuICAgIHZhciBsaW5lID0gZ2V0TGluZShkb2MsIHBvcy5saW5lKTtcXG4gICAgaWYgKGxpbmUubWFya2VkU3BhbnMpIGZvciAodmFyIGkgPSAwOyBpIDwgbGluZS5tYXJrZWRTcGFucy5sZW5ndGg7ICsraSkge1xcbiAgICAgIHZhciBzcCA9IGxpbmUubWFya2VkU3BhbnNbaV0sIG0gPSBzcC5tYXJrZXI7XFxuICAgICAgaWYgKChzcC5mcm9tID09IG51bGwgfHwgKG0uaW5jbHVzaXZlTGVmdCA/IHNwLmZyb20gPD0gcG9zLmNoIDogc3AuZnJvbSA8IHBvcy5jaCkpICYmXFxuICAgICAgICAgIChzcC50byA9PSBudWxsIHx8IChtLmluY2x1c2l2ZVJpZ2h0ID8gc3AudG8gPj0gcG9zLmNoIDogc3AudG8gPiBwb3MuY2gpKSkge1xcbiAgICAgICAgaWYgKG1heUNsZWFyKSB7XFxuICAgICAgICAgIHNpZ25hbChtLCBcXFwiYmVmb3JlQ3Vyc29yRW50ZXJcXFwiKTtcXG4gICAgICAgICAgaWYgKG0uZXhwbGljaXRseUNsZWFyZWQpIHtcXG4gICAgICAgICAgICBpZiAoIWxpbmUubWFya2VkU3BhbnMpIGJyZWFrO1xcbiAgICAgICAgICAgIGVsc2Ugey0taTsgY29udGludWU7fVxcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgICBpZiAoIW0uYXRvbWljKSBjb250aW51ZTtcXG5cXG4gICAgICAgIGlmIChvbGRQb3MpIHtcXG4gICAgICAgICAgdmFyIG5lYXIgPSBtLmZpbmQoZGlyIDwgMCA/IDEgOiAtMSksIGRpZmY7XFxuICAgICAgICAgIGlmIChkaXIgPCAwID8gbS5pbmNsdXNpdmVSaWdodCA6IG0uaW5jbHVzaXZlTGVmdClcXG4gICAgICAgICAgICBuZWFyID0gbW92ZVBvcyhkb2MsIG5lYXIsIC1kaXIsIG5lYXIgJiYgbmVhci5saW5lID09IHBvcy5saW5lID8gbGluZSA6IG51bGwpO1xcbiAgICAgICAgICBpZiAobmVhciAmJiBuZWFyLmxpbmUgPT0gcG9zLmxpbmUgJiYgKGRpZmYgPSBjbXAobmVhciwgb2xkUG9zKSkgJiYgKGRpciA8IDAgPyBkaWZmIDwgMCA6IGRpZmYgPiAwKSlcXG4gICAgICAgICAgICByZXR1cm4gc2tpcEF0b21pY0lubmVyKGRvYywgbmVhciwgcG9zLCBkaXIsIG1heUNsZWFyKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHZhciBmYXIgPSBtLmZpbmQoZGlyIDwgMCA/IC0xIDogMSk7XFxuICAgICAgICBpZiAoZGlyIDwgMCA/IG0uaW5jbHVzaXZlTGVmdCA6IG0uaW5jbHVzaXZlUmlnaHQpXFxuICAgICAgICAgIGZhciA9IG1vdmVQb3MoZG9jLCBmYXIsIGRpciwgZmFyLmxpbmUgPT0gcG9zLmxpbmUgPyBsaW5lIDogbnVsbCk7XFxuICAgICAgICByZXR1cm4gZmFyID8gc2tpcEF0b21pY0lubmVyKGRvYywgZmFyLCBwb3MsIGRpciwgbWF5Q2xlYXIpIDogbnVsbDtcXG4gICAgICB9XFxuICAgIH1cXG4gICAgcmV0dXJuIHBvcztcXG4gIH1cXG5cXG4gIC8vIEVuc3VyZSBhIGdpdmVuIHBvc2l0aW9uIGlzIG5vdCBpbnNpZGUgYW4gYXRvbWljIHJhbmdlLlxcbiAgZnVuY3Rpb24gc2tpcEF0b21pYyhkb2MsIHBvcywgb2xkUG9zLCBiaWFzLCBtYXlDbGVhcikge1xcbiAgICB2YXIgZGlyID0gYmlhcyB8fCAxO1xcbiAgICB2YXIgZm91bmQgPSBza2lwQXRvbWljSW5uZXIoZG9jLCBwb3MsIG9sZFBvcywgZGlyLCBtYXlDbGVhcikgfHxcXG4gICAgICAgICghbWF5Q2xlYXIgJiYgc2tpcEF0b21pY0lubmVyKGRvYywgcG9zLCBvbGRQb3MsIGRpciwgdHJ1ZSkpIHx8XFxuICAgICAgICBza2lwQXRvbWljSW5uZXIoZG9jLCBwb3MsIG9sZFBvcywgLWRpciwgbWF5Q2xlYXIpIHx8XFxuICAgICAgICAoIW1heUNsZWFyICYmIHNraXBBdG9taWNJbm5lcihkb2MsIHBvcywgb2xkUG9zLCAtZGlyLCB0cnVlKSk7XFxuICAgIGlmICghZm91bmQpIHtcXG4gICAgICBkb2MuY2FudEVkaXQgPSB0cnVlO1xcbiAgICAgIHJldHVybiBQb3MoZG9jLmZpcnN0LCAwKTtcXG4gICAgfVxcbiAgICByZXR1cm4gZm91bmQ7XFxuICB9XFxuXFxuICBmdW5jdGlvbiBtb3ZlUG9zKGRvYywgcG9zLCBkaXIsIGxpbmUpIHtcXG4gICAgaWYgKGRpciA8IDAgJiYgcG9zLmNoID09IDApIHtcXG4gICAgICBpZiAocG9zLmxpbmUgPiBkb2MuZmlyc3QpIHJldHVybiBjbGlwUG9zKGRvYywgUG9zKHBvcy5saW5lIC0gMSkpO1xcbiAgICAgIGVsc2UgcmV0dXJuIG51bGw7XFxuICAgIH0gZWxzZSBpZiAoZGlyID4gMCAmJiBwb3MuY2ggPT0gKGxpbmUgfHwgZ2V0TGluZShkb2MsIHBvcy5saW5lKSkudGV4dC5sZW5ndGgpIHtcXG4gICAgICBpZiAocG9zLmxpbmUgPCBkb2MuZmlyc3QgKyBkb2Muc2l6ZSAtIDEpIHJldHVybiBQb3MocG9zLmxpbmUgKyAxLCAwKTtcXG4gICAgICBlbHNlIHJldHVybiBudWxsO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIHJldHVybiBuZXcgUG9zKHBvcy5saW5lLCBwb3MuY2ggKyBkaXIpO1xcbiAgICB9XFxuICB9XFxuXFxuICAvLyBTRUxFQ1RJT04gRFJBV0lOR1xcblxcbiAgZnVuY3Rpb24gdXBkYXRlU2VsZWN0aW9uKGNtKSB7XFxuICAgIGNtLmRpc3BsYXkuaW5wdXQuc2hvd1NlbGVjdGlvbihjbS5kaXNwbGF5LmlucHV0LnByZXBhcmVTZWxlY3Rpb24oKSk7XFxuICB9XFxuXFxuICBmdW5jdGlvbiBwcmVwYXJlU2VsZWN0aW9uKGNtLCBwcmltYXJ5KSB7XFxuICAgIHZhciBkb2MgPSBjbS5kb2MsIHJlc3VsdCA9IHt9O1xcbiAgICB2YXIgY3VyRnJhZ21lbnQgPSByZXN1bHQuY3Vyc29ycyA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcXG4gICAgdmFyIHNlbEZyYWdtZW50ID0gcmVzdWx0LnNlbGVjdGlvbiA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcXG5cXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkb2Muc2VsLnJhbmdlcy5sZW5ndGg7IGkrKykge1xcbiAgICAgIGlmIChwcmltYXJ5ID09PSBmYWxzZSAmJiBpID09IGRvYy5zZWwucHJpbUluZGV4KSBjb250aW51ZTtcXG4gICAgICB2YXIgcmFuZ2UgPSBkb2Muc2VsLnJhbmdlc1tpXTtcXG4gICAgICBpZiAocmFuZ2UuZnJvbSgpLmxpbmUgPj0gY20uZGlzcGxheS52aWV3VG8gfHwgcmFuZ2UudG8oKS5saW5lIDwgY20uZGlzcGxheS52aWV3RnJvbSkgY29udGludWU7XFxuICAgICAgdmFyIGNvbGxhcHNlZCA9IHJhbmdlLmVtcHR5KCk7XFxuICAgICAgaWYgKGNvbGxhcHNlZCB8fCBjbS5vcHRpb25zLnNob3dDdXJzb3JXaGVuU2VsZWN0aW5nKVxcbiAgICAgICAgZHJhd1NlbGVjdGlvbkN1cnNvcihjbSwgcmFuZ2UuaGVhZCwgY3VyRnJhZ21lbnQpO1xcbiAgICAgIGlmICghY29sbGFwc2VkKVxcbiAgICAgICAgZHJhd1NlbGVjdGlvblJhbmdlKGNtLCByYW5nZSwgc2VsRnJhZ21lbnQpO1xcbiAgICB9XFxuICAgIHJldHVybiByZXN1bHQ7XFxuICB9XFxuXFxuICAvLyBEcmF3cyBhIGN1cnNvciBmb3IgdGhlIGdpdmVuIHJhbmdlXFxuICBmdW5jdGlvbiBkcmF3U2VsZWN0aW9uQ3Vyc29yKGNtLCBoZWFkLCBvdXRwdXQpIHtcXG4gICAgdmFyIHBvcyA9IGN1cnNvckNvb3JkcyhjbSwgaGVhZCwgXFxcImRpdlxcXCIsIG51bGwsIG51bGwsICFjbS5vcHRpb25zLnNpbmdsZUN1cnNvckhlaWdodFBlckxpbmUpO1xcblxcbiAgICB2YXIgY3Vyc29yID0gb3V0cHV0LmFwcGVuZENoaWxkKGVsdChcXFwiZGl2XFxcIiwgXFxcIlxcXFx1MDBhMFxcXCIsIFxcXCJDb2RlTWlycm9yLWN1cnNvclxcXCIpKTtcXG4gICAgY3Vyc29yLnN0eWxlLmxlZnQgPSBwb3MubGVmdCArIFxcXCJweFxcXCI7XFxuICAgIGN1cnNvci5zdHlsZS50b3AgPSBwb3MudG9wICsgXFxcInB4XFxcIjtcXG4gICAgY3Vyc29yLnN0eWxlLmhlaWdodCA9IE1hdGgubWF4KDAsIHBvcy5ib3R0b20gLSBwb3MudG9wKSAqIGNtLm9wdGlvbnMuY3Vyc29ySGVpZ2h0ICsgXFxcInB4XFxcIjtcXG5cXG4gICAgaWYgKHBvcy5vdGhlcikge1xcbiAgICAgIC8vIFNlY29uZGFyeSBjdXJzb3IsIHNob3duIHdoZW4gb24gYSAnanVtcCcgaW4gYmktZGlyZWN0aW9uYWwgdGV4dFxcbiAgICAgIHZhciBvdGhlckN1cnNvciA9IG91dHB1dC5hcHBlbmRDaGlsZChlbHQoXFxcImRpdlxcXCIsIFxcXCJcXFxcdTAwYTBcXFwiLCBcXFwiQ29kZU1pcnJvci1jdXJzb3IgQ29kZU1pcnJvci1zZWNvbmRhcnljdXJzb3JcXFwiKSk7XFxuICAgICAgb3RoZXJDdXJzb3Iuc3R5bGUuZGlzcGxheSA9IFxcXCJcXFwiO1xcbiAgICAgIG90aGVyQ3Vyc29yLnN0eWxlLmxlZnQgPSBwb3Mub3RoZXIubGVmdCArIFxcXCJweFxcXCI7XFxuICAgICAgb3RoZXJDdXJzb3Iuc3R5bGUudG9wID0gcG9zLm90aGVyLnRvcCArIFxcXCJweFxcXCI7XFxuICAgICAgb3RoZXJDdXJzb3Iuc3R5bGUuaGVpZ2h0ID0gKHBvcy5vdGhlci5ib3R0b20gLSBwb3Mub3RoZXIudG9wKSAqIC44NSArIFxcXCJweFxcXCI7XFxuICAgIH1cXG4gIH1cXG5cXG4gIC8vIERyYXdzIHRoZSBnaXZlbiByYW5nZSBhcyBhIGhpZ2hsaWdodGVkIHNlbGVjdGlvblxcbiAgZnVuY3Rpb24gZHJhd1NlbGVjdGlvblJhbmdlKGNtLCByYW5nZSwgb3V0cHV0KSB7XFxuICAgIHZhciBkaXNwbGF5ID0gY20uZGlzcGxheSwgZG9jID0gY20uZG9jO1xcbiAgICB2YXIgZnJhZ21lbnQgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XFxuICAgIHZhciBwYWRkaW5nID0gcGFkZGluZ0goY20uZGlzcGxheSksIGxlZnRTaWRlID0gcGFkZGluZy5sZWZ0O1xcbiAgICB2YXIgcmlnaHRTaWRlID0gTWF0aC5tYXgoZGlzcGxheS5zaXplcldpZHRoLCBkaXNwbGF5V2lkdGgoY20pIC0gZGlzcGxheS5zaXplci5vZmZzZXRMZWZ0KSAtIHBhZGRpbmcucmlnaHQ7XFxuXFxuICAgIGZ1bmN0aW9uIGFkZChsZWZ0LCB0b3AsIHdpZHRoLCBib3R0b20pIHtcXG4gICAgICBpZiAodG9wIDwgMCkgdG9wID0gMDtcXG4gICAgICB0b3AgPSBNYXRoLnJvdW5kKHRvcCk7XFxuICAgICAgYm90dG9tID0gTWF0aC5yb3VuZChib3R0b20pO1xcbiAgICAgIGZyYWdtZW50LmFwcGVuZENoaWxkKGVsdChcXFwiZGl2XFxcIiwgbnVsbCwgXFxcIkNvZGVNaXJyb3Itc2VsZWN0ZWRcXFwiLCBcXFwicG9zaXRpb246IGFic29sdXRlOyBsZWZ0OiBcXFwiICsgbGVmdCArXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcXCJweDsgdG9wOiBcXFwiICsgdG9wICsgXFxcInB4OyB3aWR0aDogXFxcIiArICh3aWR0aCA9PSBudWxsID8gcmlnaHRTaWRlIC0gbGVmdCA6IHdpZHRoKSArXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcXCJweDsgaGVpZ2h0OiBcXFwiICsgKGJvdHRvbSAtIHRvcCkgKyBcXFwicHhcXFwiKSk7XFxuICAgIH1cXG5cXG4gICAgZnVuY3Rpb24gZHJhd0ZvckxpbmUobGluZSwgZnJvbUFyZywgdG9BcmcpIHtcXG4gICAgICB2YXIgbGluZU9iaiA9IGdldExpbmUoZG9jLCBsaW5lKTtcXG4gICAgICB2YXIgbGluZUxlbiA9IGxpbmVPYmoudGV4dC5sZW5ndGg7XFxuICAgICAgdmFyIHN0YXJ0LCBlbmQ7XFxuICAgICAgZnVuY3Rpb24gY29vcmRzKGNoLCBiaWFzKSB7XFxuICAgICAgICByZXR1cm4gY2hhckNvb3JkcyhjbSwgUG9zKGxpbmUsIGNoKSwgXFxcImRpdlxcXCIsIGxpbmVPYmosIGJpYXMpO1xcbiAgICAgIH1cXG5cXG4gICAgICBpdGVyYXRlQmlkaVNlY3Rpb25zKGdldE9yZGVyKGxpbmVPYmopLCBmcm9tQXJnIHx8IDAsIHRvQXJnID09IG51bGwgPyBsaW5lTGVuIDogdG9BcmcsIGZ1bmN0aW9uKGZyb20sIHRvLCBkaXIpIHtcXG4gICAgICAgIHZhciBsZWZ0UG9zID0gY29vcmRzKGZyb20sIFxcXCJsZWZ0XFxcIiksIHJpZ2h0UG9zLCBsZWZ0LCByaWdodDtcXG4gICAgICAgIGlmIChmcm9tID09IHRvKSB7XFxuICAgICAgICAgIHJpZ2h0UG9zID0gbGVmdFBvcztcXG4gICAgICAgICAgbGVmdCA9IHJpZ2h0ID0gbGVmdFBvcy5sZWZ0O1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgcmlnaHRQb3MgPSBjb29yZHModG8gLSAxLCBcXFwicmlnaHRcXFwiKTtcXG4gICAgICAgICAgaWYgKGRpciA9PSBcXFwicnRsXFxcIikgeyB2YXIgdG1wID0gbGVmdFBvczsgbGVmdFBvcyA9IHJpZ2h0UG9zOyByaWdodFBvcyA9IHRtcDsgfVxcbiAgICAgICAgICBsZWZ0ID0gbGVmdFBvcy5sZWZ0O1xcbiAgICAgICAgICByaWdodCA9IHJpZ2h0UG9zLnJpZ2h0O1xcbiAgICAgICAgfVxcbiAgICAgICAgaWYgKGZyb21BcmcgPT0gbnVsbCAmJiBmcm9tID09IDApIGxlZnQgPSBsZWZ0U2lkZTtcXG4gICAgICAgIGlmIChyaWdodFBvcy50b3AgLSBsZWZ0UG9zLnRvcCA+IDMpIHsgLy8gRGlmZmVyZW50IGxpbmVzLCBkcmF3IHRvcCBwYXJ0XFxuICAgICAgICAgIGFkZChsZWZ0LCBsZWZ0UG9zLnRvcCwgbnVsbCwgbGVmdFBvcy5ib3R0b20pO1xcbiAgICAgICAgICBsZWZ0ID0gbGVmdFNpZGU7XFxuICAgICAgICAgIGlmIChsZWZ0UG9zLmJvdHRvbSA8IHJpZ2h0UG9zLnRvcCkgYWRkKGxlZnQsIGxlZnRQb3MuYm90dG9tLCBudWxsLCByaWdodFBvcy50b3ApO1xcbiAgICAgICAgfVxcbiAgICAgICAgaWYgKHRvQXJnID09IG51bGwgJiYgdG8gPT0gbGluZUxlbikgcmlnaHQgPSByaWdodFNpZGU7XFxuICAgICAgICBpZiAoIXN0YXJ0IHx8IGxlZnRQb3MudG9wIDwgc3RhcnQudG9wIHx8IGxlZnRQb3MudG9wID09IHN0YXJ0LnRvcCAmJiBsZWZ0UG9zLmxlZnQgPCBzdGFydC5sZWZ0KVxcbiAgICAgICAgICBzdGFydCA9IGxlZnRQb3M7XFxuICAgICAgICBpZiAoIWVuZCB8fCByaWdodFBvcy5ib3R0b20gPiBlbmQuYm90dG9tIHx8IHJpZ2h0UG9zLmJvdHRvbSA9PSBlbmQuYm90dG9tICYmIHJpZ2h0UG9zLnJpZ2h0ID4gZW5kLnJpZ2h0KVxcbiAgICAgICAgICBlbmQgPSByaWdodFBvcztcXG4gICAgICAgIGlmIChsZWZ0IDwgbGVmdFNpZGUgKyAxKSBsZWZ0ID0gbGVmdFNpZGU7XFxuICAgICAgICBhZGQobGVmdCwgcmlnaHRQb3MudG9wLCByaWdodCAtIGxlZnQsIHJpZ2h0UG9zLmJvdHRvbSk7XFxuICAgICAgfSk7XFxuICAgICAgcmV0dXJuIHtzdGFydDogc3RhcnQsIGVuZDogZW5kfTtcXG4gICAgfVxcblxcbiAgICB2YXIgc0Zyb20gPSByYW5nZS5mcm9tKCksIHNUbyA9IHJhbmdlLnRvKCk7XFxuICAgIGlmIChzRnJvbS5saW5lID09IHNUby5saW5lKSB7XFxuICAgICAgZHJhd0ZvckxpbmUoc0Zyb20ubGluZSwgc0Zyb20uY2gsIHNUby5jaCk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgdmFyIGZyb21MaW5lID0gZ2V0TGluZShkb2MsIHNGcm9tLmxpbmUpLCB0b0xpbmUgPSBnZXRMaW5lKGRvYywgc1RvLmxpbmUpO1xcbiAgICAgIHZhciBzaW5nbGVWTGluZSA9IHZpc3VhbExpbmUoZnJvbUxpbmUpID09IHZpc3VhbExpbmUodG9MaW5lKTtcXG4gICAgICB2YXIgbGVmdEVuZCA9IGRyYXdGb3JMaW5lKHNGcm9tLmxpbmUsIHNGcm9tLmNoLCBzaW5nbGVWTGluZSA/IGZyb21MaW5lLnRleHQubGVuZ3RoICsgMSA6IG51bGwpLmVuZDtcXG4gICAgICB2YXIgcmlnaHRTdGFydCA9IGRyYXdGb3JMaW5lKHNUby5saW5lLCBzaW5nbGVWTGluZSA/IDAgOiBudWxsLCBzVG8uY2gpLnN0YXJ0O1xcbiAgICAgIGlmIChzaW5nbGVWTGluZSkge1xcbiAgICAgICAgaWYgKGxlZnRFbmQudG9wIDwgcmlnaHRTdGFydC50b3AgLSAyKSB7XFxuICAgICAgICAgIGFkZChsZWZ0RW5kLnJpZ2h0LCBsZWZ0RW5kLnRvcCwgbnVsbCwgbGVmdEVuZC5ib3R0b20pO1xcbiAgICAgICAgICBhZGQobGVmdFNpZGUsIHJpZ2h0U3RhcnQudG9wLCByaWdodFN0YXJ0LmxlZnQsIHJpZ2h0U3RhcnQuYm90dG9tKTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIGFkZChsZWZ0RW5kLnJpZ2h0LCBsZWZ0RW5kLnRvcCwgcmlnaHRTdGFydC5sZWZ0IC0gbGVmdEVuZC5yaWdodCwgbGVmdEVuZC5ib3R0b20pO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgICBpZiAobGVmdEVuZC5ib3R0b20gPCByaWdodFN0YXJ0LnRvcClcXG4gICAgICAgIGFkZChsZWZ0U2lkZSwgbGVmdEVuZC5ib3R0b20sIG51bGwsIHJpZ2h0U3RhcnQudG9wKTtcXG4gICAgfVxcblxcbiAgICBvdXRwdXQuYXBwZW5kQ2hpbGQoZnJhZ21lbnQpO1xcbiAgfVxcblxcbiAgLy8gQ3Vyc29yLWJsaW5raW5nXFxuICBmdW5jdGlvbiByZXN0YXJ0QmxpbmsoY20pIHtcXG4gICAgaWYgKCFjbS5zdGF0ZS5mb2N1c2VkKSByZXR1cm47XFxuICAgIHZhciBkaXNwbGF5ID0gY20uZGlzcGxheTtcXG4gICAgY2xlYXJJbnRlcnZhbChkaXNwbGF5LmJsaW5rZXIpO1xcbiAgICB2YXIgb24gPSB0cnVlO1xcbiAgICBkaXNwbGF5LmN1cnNvckRpdi5zdHlsZS52aXNpYmlsaXR5ID0gXFxcIlxcXCI7XFxuICAgIGlmIChjbS5vcHRpb25zLmN1cnNvckJsaW5rUmF0ZSA+IDApXFxuICAgICAgZGlzcGxheS5ibGlua2VyID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24oKSB7XFxuICAgICAgICBkaXNwbGF5LmN1cnNvckRpdi5zdHlsZS52aXNpYmlsaXR5ID0gKG9uID0gIW9uKSA/IFxcXCJcXFwiIDogXFxcImhpZGRlblxcXCI7XFxuICAgICAgfSwgY20ub3B0aW9ucy5jdXJzb3JCbGlua1JhdGUpO1xcbiAgICBlbHNlIGlmIChjbS5vcHRpb25zLmN1cnNvckJsaW5rUmF0ZSA8IDApXFxuICAgICAgZGlzcGxheS5jdXJzb3JEaXYuc3R5bGUudmlzaWJpbGl0eSA9IFxcXCJoaWRkZW5cXFwiO1xcbiAgfVxcblxcbiAgLy8gSElHSExJR0hUIFdPUktFUlxcblxcbiAgZnVuY3Rpb24gc3RhcnRXb3JrZXIoY20sIHRpbWUpIHtcXG4gICAgaWYgKGNtLmRvYy5tb2RlLnN0YXJ0U3RhdGUgJiYgY20uZG9jLmZyb250aWVyIDwgY20uZGlzcGxheS52aWV3VG8pXFxuICAgICAgY20uc3RhdGUuaGlnaGxpZ2h0LnNldCh0aW1lLCBiaW5kKGhpZ2hsaWdodFdvcmtlciwgY20pKTtcXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIGhpZ2hsaWdodFdvcmtlcihjbSkge1xcbiAgICB2YXIgZG9jID0gY20uZG9jO1xcbiAgICBpZiAoZG9jLmZyb250aWVyIDwgZG9jLmZpcnN0KSBkb2MuZnJvbnRpZXIgPSBkb2MuZmlyc3Q7XFxuICAgIGlmIChkb2MuZnJvbnRpZXIgPj0gY20uZGlzcGxheS52aWV3VG8pIHJldHVybjtcXG4gICAgdmFyIGVuZCA9ICtuZXcgRGF0ZSArIGNtLm9wdGlvbnMud29ya1RpbWU7XFxuICAgIHZhciBzdGF0ZSA9IGNvcHlTdGF0ZShkb2MubW9kZSwgZ2V0U3RhdGVCZWZvcmUoY20sIGRvYy5mcm9udGllcikpO1xcbiAgICB2YXIgY2hhbmdlZExpbmVzID0gW107XFxuXFxuICAgIGRvYy5pdGVyKGRvYy5mcm9udGllciwgTWF0aC5taW4oZG9jLmZpcnN0ICsgZG9jLnNpemUsIGNtLmRpc3BsYXkudmlld1RvICsgNTAwKSwgZnVuY3Rpb24obGluZSkge1xcbiAgICAgIGlmIChkb2MuZnJvbnRpZXIgPj0gY20uZGlzcGxheS52aWV3RnJvbSkgeyAvLyBWaXNpYmxlXFxuICAgICAgICB2YXIgb2xkU3R5bGVzID0gbGluZS5zdHlsZXMsIHRvb0xvbmcgPSBsaW5lLnRleHQubGVuZ3RoID4gY20ub3B0aW9ucy5tYXhIaWdobGlnaHRMZW5ndGg7XFxuICAgICAgICB2YXIgaGlnaGxpZ2h0ZWQgPSBoaWdobGlnaHRMaW5lKGNtLCBsaW5lLCB0b29Mb25nID8gY29weVN0YXRlKGRvYy5tb2RlLCBzdGF0ZSkgOiBzdGF0ZSwgdHJ1ZSk7XFxuICAgICAgICBsaW5lLnN0eWxlcyA9IGhpZ2hsaWdodGVkLnN0eWxlcztcXG4gICAgICAgIHZhciBvbGRDbHMgPSBsaW5lLnN0eWxlQ2xhc3NlcywgbmV3Q2xzID0gaGlnaGxpZ2h0ZWQuY2xhc3NlcztcXG4gICAgICAgIGlmIChuZXdDbHMpIGxpbmUuc3R5bGVDbGFzc2VzID0gbmV3Q2xzO1xcbiAgICAgICAgZWxzZSBpZiAob2xkQ2xzKSBsaW5lLnN0eWxlQ2xhc3NlcyA9IG51bGw7XFxuICAgICAgICB2YXIgaXNjaGFuZ2UgPSAhb2xkU3R5bGVzIHx8IG9sZFN0eWxlcy5sZW5ndGggIT0gbGluZS5zdHlsZXMubGVuZ3RoIHx8XFxuICAgICAgICAgIG9sZENscyAhPSBuZXdDbHMgJiYgKCFvbGRDbHMgfHwgIW5ld0NscyB8fCBvbGRDbHMuYmdDbGFzcyAhPSBuZXdDbHMuYmdDbGFzcyB8fCBvbGRDbHMudGV4dENsYXNzICE9IG5ld0Nscy50ZXh0Q2xhc3MpO1xcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7ICFpc2NoYW5nZSAmJiBpIDwgb2xkU3R5bGVzLmxlbmd0aDsgKytpKSBpc2NoYW5nZSA9IG9sZFN0eWxlc1tpXSAhPSBsaW5lLnN0eWxlc1tpXTtcXG4gICAgICAgIGlmIChpc2NoYW5nZSkgY2hhbmdlZExpbmVzLnB1c2goZG9jLmZyb250aWVyKTtcXG4gICAgICAgIGxpbmUuc3RhdGVBZnRlciA9IHRvb0xvbmcgPyBzdGF0ZSA6IGNvcHlTdGF0ZShkb2MubW9kZSwgc3RhdGUpO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBpZiAobGluZS50ZXh0Lmxlbmd0aCA8PSBjbS5vcHRpb25zLm1heEhpZ2hsaWdodExlbmd0aClcXG4gICAgICAgICAgcHJvY2Vzc0xpbmUoY20sIGxpbmUudGV4dCwgc3RhdGUpO1xcbiAgICAgICAgbGluZS5zdGF0ZUFmdGVyID0gZG9jLmZyb250aWVyICUgNSA9PSAwID8gY29weVN0YXRlKGRvYy5tb2RlLCBzdGF0ZSkgOiBudWxsO1xcbiAgICAgIH1cXG4gICAgICArK2RvYy5mcm9udGllcjtcXG4gICAgICBpZiAoK25ldyBEYXRlID4gZW5kKSB7XFxuICAgICAgICBzdGFydFdvcmtlcihjbSwgY20ub3B0aW9ucy53b3JrRGVsYXkpO1xcbiAgICAgICAgcmV0dXJuIHRydWU7XFxuICAgICAgfVxcbiAgICB9KTtcXG4gICAgaWYgKGNoYW5nZWRMaW5lcy5sZW5ndGgpIHJ1bkluT3AoY20sIGZ1bmN0aW9uKCkge1xcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hhbmdlZExpbmVzLmxlbmd0aDsgaSsrKVxcbiAgICAgICAgcmVnTGluZUNoYW5nZShjbSwgY2hhbmdlZExpbmVzW2ldLCBcXFwidGV4dFxcXCIpO1xcbiAgICB9KTtcXG4gIH1cXG5cXG4gIC8vIEZpbmRzIHRoZSBsaW5lIHRvIHN0YXJ0IHdpdGggd2hlbiBzdGFydGluZyBhIHBhcnNlLiBUcmllcyB0b1xcbiAgLy8gZmluZCBhIGxpbmUgd2l0aCBhIHN0YXRlQWZ0ZXIsIHNvIHRoYXQgaXQgY2FuIHN0YXJ0IHdpdGggYVxcbiAgLy8gdmFsaWQgc3RhdGUuIElmIHRoYXQgZmFpbHMsIGl0IHJldHVybnMgdGhlIGxpbmUgd2l0aCB0aGVcXG4gIC8vIHNtYWxsZXN0IGluZGVudGF0aW9uLCB3aGljaCB0ZW5kcyB0byBuZWVkIHRoZSBsZWFzdCBjb250ZXh0IHRvXFxuICAvLyBwYXJzZSBjb3JyZWN0bHkuXFxuICBmdW5jdGlvbiBmaW5kU3RhcnRMaW5lKGNtLCBuLCBwcmVjaXNlKSB7XFxuICAgIHZhciBtaW5pbmRlbnQsIG1pbmxpbmUsIGRvYyA9IGNtLmRvYztcXG4gICAgdmFyIGxpbSA9IHByZWNpc2UgPyAtMSA6IG4gLSAoY20uZG9jLm1vZGUuaW5uZXJNb2RlID8gMTAwMCA6IDEwMCk7XFxuICAgIGZvciAodmFyIHNlYXJjaCA9IG47IHNlYXJjaCA+IGxpbTsgLS1zZWFyY2gpIHtcXG4gICAgICBpZiAoc2VhcmNoIDw9IGRvYy5maXJzdCkgcmV0dXJuIGRvYy5maXJzdDtcXG4gICAgICB2YXIgbGluZSA9IGdldExpbmUoZG9jLCBzZWFyY2ggLSAxKTtcXG4gICAgICBpZiAobGluZS5zdGF0ZUFmdGVyICYmICghcHJlY2lzZSB8fCBzZWFyY2ggPD0gZG9jLmZyb250aWVyKSkgcmV0dXJuIHNlYXJjaDtcXG4gICAgICB2YXIgaW5kZW50ZWQgPSBjb3VudENvbHVtbihsaW5lLnRleHQsIG51bGwsIGNtLm9wdGlvbnMudGFiU2l6ZSk7XFxuICAgICAgaWYgKG1pbmxpbmUgPT0gbnVsbCB8fCBtaW5pbmRlbnQgPiBpbmRlbnRlZCkge1xcbiAgICAgICAgbWlubGluZSA9IHNlYXJjaCAtIDE7XFxuICAgICAgICBtaW5pbmRlbnQgPSBpbmRlbnRlZDtcXG4gICAgICB9XFxuICAgIH1cXG4gICAgcmV0dXJuIG1pbmxpbmU7XFxuICB9XFxuXFxuICBmdW5jdGlvbiBnZXRTdGF0ZUJlZm9yZShjbSwgbiwgcHJlY2lzZSkge1xcbiAgICB2YXIgZG9jID0gY20uZG9jLCBkaXNwbGF5ID0gY20uZGlzcGxheTtcXG4gICAgaWYgKCFkb2MubW9kZS5zdGFydFN0YXRlKSByZXR1cm4gdHJ1ZTtcXG4gICAgdmFyIHBvcyA9IGZpbmRTdGFydExpbmUoY20sIG4sIHByZWNpc2UpLCBzdGF0ZSA9IHBvcyA+IGRvYy5maXJzdCAmJiBnZXRMaW5lKGRvYywgcG9zLTEpLnN0YXRlQWZ0ZXI7XFxuICAgIGlmICghc3RhdGUpIHN0YXRlID0gc3RhcnRTdGF0ZShkb2MubW9kZSk7XFxuICAgIGVsc2Ugc3RhdGUgPSBjb3B5U3RhdGUoZG9jLm1vZGUsIHN0YXRlKTtcXG4gICAgZG9jLml0ZXIocG9zLCBuLCBmdW5jdGlvbihsaW5lKSB7XFxuICAgICAgcHJvY2Vzc0xpbmUoY20sIGxpbmUudGV4dCwgc3RhdGUpO1xcbiAgICAgIHZhciBzYXZlID0gcG9zID09IG4gLSAxIHx8IHBvcyAlIDUgPT0gMCB8fCBwb3MgPj0gZGlzcGxheS52aWV3RnJvbSAmJiBwb3MgPCBkaXNwbGF5LnZpZXdUbztcXG4gICAgICBsaW5lLnN0YXRlQWZ0ZXIgPSBzYXZlID8gY29weVN0YXRlKGRvYy5tb2RlLCBzdGF0ZSkgOiBudWxsO1xcbiAgICAgICsrcG9zO1xcbiAgICB9KTtcXG4gICAgaWYgKHByZWNpc2UpIGRvYy5mcm9udGllciA9IHBvcztcXG4gICAgcmV0dXJuIHN0YXRlO1xcbiAgfVxcblxcbiAgLy8gUE9TSVRJT04gTUVBU1VSRU1FTlRcXG5cXG4gIGZ1bmN0aW9uIHBhZGRpbmdUb3AoZGlzcGxheSkge3JldHVybiBkaXNwbGF5LmxpbmVTcGFjZS5vZmZzZXRUb3A7fVxcbiAgZnVuY3Rpb24gcGFkZGluZ1ZlcnQoZGlzcGxheSkge3JldHVybiBkaXNwbGF5Lm1vdmVyLm9mZnNldEhlaWdodCAtIGRpc3BsYXkubGluZVNwYWNlLm9mZnNldEhlaWdodDt9XFxuICBmdW5jdGlvbiBwYWRkaW5nSChkaXNwbGF5KSB7XFxuICAgIGlmIChkaXNwbGF5LmNhY2hlZFBhZGRpbmdIKSByZXR1cm4gZGlzcGxheS5jYWNoZWRQYWRkaW5nSDtcXG4gICAgdmFyIGUgPSByZW1vdmVDaGlsZHJlbkFuZEFkZChkaXNwbGF5Lm1lYXN1cmUsIGVsdChcXFwicHJlXFxcIiwgXFxcInhcXFwiKSk7XFxuICAgIHZhciBzdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlID8gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZSkgOiBlLmN1cnJlbnRTdHlsZTtcXG4gICAgdmFyIGRhdGEgPSB7bGVmdDogcGFyc2VJbnQoc3R5bGUucGFkZGluZ0xlZnQpLCByaWdodDogcGFyc2VJbnQoc3R5bGUucGFkZGluZ1JpZ2h0KX07XFxuICAgIGlmICghaXNOYU4oZGF0YS5sZWZ0KSAmJiAhaXNOYU4oZGF0YS5yaWdodCkpIGRpc3BsYXkuY2FjaGVkUGFkZGluZ0ggPSBkYXRhO1xcbiAgICByZXR1cm4gZGF0YTtcXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIHNjcm9sbEdhcChjbSkgeyByZXR1cm4gc2Nyb2xsZXJHYXAgLSBjbS5kaXNwbGF5Lm5hdGl2ZUJhcldpZHRoOyB9XFxuICBmdW5jdGlvbiBkaXNwbGF5V2lkdGgoY20pIHtcXG4gICAgcmV0dXJuIGNtLmRpc3BsYXkuc2Nyb2xsZXIuY2xpZW50V2lkdGggLSBzY3JvbGxHYXAoY20pIC0gY20uZGlzcGxheS5iYXJXaWR0aDtcXG4gIH1cXG4gIGZ1bmN0aW9uIGRpc3BsYXlIZWlnaHQoY20pIHtcXG4gICAgcmV0dXJuIGNtLmRpc3BsYXkuc2Nyb2xsZXIuY2xpZW50SGVpZ2h0IC0gc2Nyb2xsR2FwKGNtKSAtIGNtLmRpc3BsYXkuYmFySGVpZ2h0O1xcbiAgfVxcblxcbiAgLy8gRW5zdXJlIHRoZSBsaW5lVmlldy53cmFwcGluZy5oZWlnaHRzIGFycmF5IGlzIHBvcHVsYXRlZC4gVGhpcyBpc1xcbiAgLy8gYW4gYXJyYXkgb2YgYm90dG9tIG9mZnNldHMgZm9yIHRoZSBsaW5lcyB0aGF0IG1ha2UgdXAgYSBkcmF3blxcbiAgLy8gbGluZS4gV2hlbiBsaW5lV3JhcHBpbmcgaXMgb24sIHRoZXJlIG1pZ2h0IGJlIG1vcmUgdGhhbiBvbmVcXG4gIC8vIGhlaWdodC5cXG4gIGZ1bmN0aW9uIGVuc3VyZUxpbmVIZWlnaHRzKGNtLCBsaW5lVmlldywgcmVjdCkge1xcbiAgICB2YXIgd3JhcHBpbmcgPSBjbS5vcHRpb25zLmxpbmVXcmFwcGluZztcXG4gICAgdmFyIGN1cldpZHRoID0gd3JhcHBpbmcgJiYgZGlzcGxheVdpZHRoKGNtKTtcXG4gICAgaWYgKCFsaW5lVmlldy5tZWFzdXJlLmhlaWdodHMgfHwgd3JhcHBpbmcgJiYgbGluZVZpZXcubWVhc3VyZS53aWR0aCAhPSBjdXJXaWR0aCkge1xcbiAgICAgIHZhciBoZWlnaHRzID0gbGluZVZpZXcubWVhc3VyZS5oZWlnaHRzID0gW107XFxuICAgICAgaWYgKHdyYXBwaW5nKSB7XFxuICAgICAgICBsaW5lVmlldy5tZWFzdXJlLndpZHRoID0gY3VyV2lkdGg7XFxuICAgICAgICB2YXIgcmVjdHMgPSBsaW5lVmlldy50ZXh0LmZpcnN0Q2hpbGQuZ2V0Q2xpZW50UmVjdHMoKTtcXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVjdHMubGVuZ3RoIC0gMTsgaSsrKSB7XFxuICAgICAgICAgIHZhciBjdXIgPSByZWN0c1tpXSwgbmV4dCA9IHJlY3RzW2kgKyAxXTtcXG4gICAgICAgICAgaWYgKE1hdGguYWJzKGN1ci5ib3R0b20gLSBuZXh0LmJvdHRvbSkgPiAyKVxcbiAgICAgICAgICAgIGhlaWdodHMucHVzaCgoY3VyLmJvdHRvbSArIG5leHQudG9wKSAvIDIgLSByZWN0LnRvcCk7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICAgIGhlaWdodHMucHVzaChyZWN0LmJvdHRvbSAtIHJlY3QudG9wKTtcXG4gICAgfVxcbiAgfVxcblxcbiAgLy8gRmluZCBhIGxpbmUgbWFwIChtYXBwaW5nIGNoYXJhY3RlciBvZmZzZXRzIHRvIHRleHQgbm9kZXMpIGFuZCBhXFxuICAvLyBtZWFzdXJlbWVudCBjYWNoZSBmb3IgdGhlIGdpdmVuIGxpbmUgbnVtYmVyLiAoQSBsaW5lIHZpZXcgbWlnaHRcXG4gIC8vIGNvbnRhaW4gbXVsdGlwbGUgbGluZXMgd2hlbiBjb2xsYXBzZWQgcmFuZ2VzIGFyZSBwcmVzZW50LilcXG4gIGZ1bmN0aW9uIG1hcEZyb21MaW5lVmlldyhsaW5lVmlldywgbGluZSwgbGluZU4pIHtcXG4gICAgaWYgKGxpbmVWaWV3LmxpbmUgPT0gbGluZSlcXG4gICAgICByZXR1cm4ge21hcDogbGluZVZpZXcubWVhc3VyZS5tYXAsIGNhY2hlOiBsaW5lVmlldy5tZWFzdXJlLmNhY2hlfTtcXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lVmlldy5yZXN0Lmxlbmd0aDsgaSsrKVxcbiAgICAgIGlmIChsaW5lVmlldy5yZXN0W2ldID09IGxpbmUpXFxuICAgICAgICByZXR1cm4ge21hcDogbGluZVZpZXcubWVhc3VyZS5tYXBzW2ldLCBjYWNoZTogbGluZVZpZXcubWVhc3VyZS5jYWNoZXNbaV19O1xcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmVWaWV3LnJlc3QubGVuZ3RoOyBpKyspXFxuICAgICAgaWYgKGxpbmVObyhsaW5lVmlldy5yZXN0W2ldKSA+IGxpbmVOKVxcbiAgICAgICAgcmV0dXJuIHttYXA6IGxpbmVWaWV3Lm1lYXN1cmUubWFwc1tpXSwgY2FjaGU6IGxpbmVWaWV3Lm1lYXN1cmUuY2FjaGVzW2ldLCBiZWZvcmU6IHRydWV9O1xcbiAgfVxcblxcbiAgLy8gUmVuZGVyIGEgbGluZSBpbnRvIHRoZSBoaWRkZW4gbm9kZSBkaXNwbGF5LmV4dGVybmFsTWVhc3VyZWQuIFVzZWRcXG4gIC8vIHdoZW4gbWVhc3VyZW1lbnQgaXMgbmVlZGVkIGZvciBhIGxpbmUgdGhhdCdzIG5vdCBpbiB0aGUgdmlld3BvcnQuXFxuICBmdW5jdGlvbiB1cGRhdGVFeHRlcm5hbE1lYXN1cmVtZW50KGNtLCBsaW5lKSB7XFxuICAgIGxpbmUgPSB2aXN1YWxMaW5lKGxpbmUpO1xcbiAgICB2YXIgbGluZU4gPSBsaW5lTm8obGluZSk7XFxuICAgIHZhciB2aWV3ID0gY20uZGlzcGxheS5leHRlcm5hbE1lYXN1cmVkID0gbmV3IExpbmVWaWV3KGNtLmRvYywgbGluZSwgbGluZU4pO1xcbiAgICB2aWV3LmxpbmVOID0gbGluZU47XFxuICAgIHZhciBidWlsdCA9IHZpZXcuYnVpbHQgPSBidWlsZExpbmVDb250ZW50KGNtLCB2aWV3KTtcXG4gICAgdmlldy50ZXh0ID0gYnVpbHQucHJlO1xcbiAgICByZW1vdmVDaGlsZHJlbkFuZEFkZChjbS5kaXNwbGF5LmxpbmVNZWFzdXJlLCBidWlsdC5wcmUpO1xcbiAgICByZXR1cm4gdmlldztcXG4gIH1cXG5cXG4gIC8vIEdldCBhIHt0b3AsIGJvdHRvbSwgbGVmdCwgcmlnaHR9IGJveCAoaW4gbGluZS1sb2NhbCBjb29yZGluYXRlcylcXG4gIC8vIGZvciBhIGdpdmVuIGNoYXJhY3Rlci5cXG4gIGZ1bmN0aW9uIG1lYXN1cmVDaGFyKGNtLCBsaW5lLCBjaCwgYmlhcykge1xcbiAgICByZXR1cm4gbWVhc3VyZUNoYXJQcmVwYXJlZChjbSwgcHJlcGFyZU1lYXN1cmVGb3JMaW5lKGNtLCBsaW5lKSwgY2gsIGJpYXMpO1xcbiAgfVxcblxcbiAgLy8gRmluZCBhIGxpbmUgdmlldyB0aGF0IGNvcnJlc3BvbmRzIHRvIHRoZSBnaXZlbiBsaW5lIG51bWJlci5cXG4gIGZ1bmN0aW9uIGZpbmRWaWV3Rm9yTGluZShjbSwgbGluZU4pIHtcXG4gICAgaWYgKGxpbmVOID49IGNtLmRpc3BsYXkudmlld0Zyb20gJiYgbGluZU4gPCBjbS5kaXNwbGF5LnZpZXdUbylcXG4gICAgICByZXR1cm4gY20uZGlzcGxheS52aWV3W2ZpbmRWaWV3SW5kZXgoY20sIGxpbmVOKV07XFxuICAgIHZhciBleHQgPSBjbS5kaXNwbGF5LmV4dGVybmFsTWVhc3VyZWQ7XFxuICAgIGlmIChleHQgJiYgbGluZU4gPj0gZXh0LmxpbmVOICYmIGxpbmVOIDwgZXh0LmxpbmVOICsgZXh0LnNpemUpXFxuICAgICAgcmV0dXJuIGV4dDtcXG4gIH1cXG5cXG4gIC8vIE1lYXN1cmVtZW50IGNhbiBiZSBzcGxpdCBpbiB0d28gc3RlcHMsIHRoZSBzZXQtdXAgd29yayB0aGF0XFxuICAvLyBhcHBsaWVzIHRvIHRoZSB3aG9sZSBsaW5lLCBhbmQgdGhlIG1lYXN1cmVtZW50IG9mIHRoZSBhY3R1YWxcXG4gIC8vIGNoYXJhY3Rlci4gRnVuY3Rpb25zIGxpa2UgY29vcmRzQ2hhciwgdGhhdCBuZWVkIHRvIGRvIGEgbG90IG9mXFxuICAvLyBtZWFzdXJlbWVudHMgaW4gYSByb3csIGNhbiB0aHVzIGVuc3VyZSB0aGF0IHRoZSBzZXQtdXAgd29yayBpc1xcbiAgLy8gb25seSBkb25lIG9uY2UuXFxuICBmdW5jdGlvbiBwcmVwYXJlTWVhc3VyZUZvckxpbmUoY20sIGxpbmUpIHtcXG4gICAgdmFyIGxpbmVOID0gbGluZU5vKGxpbmUpO1xcbiAgICB2YXIgdmlldyA9IGZpbmRWaWV3Rm9yTGluZShjbSwgbGluZU4pO1xcbiAgICBpZiAodmlldyAmJiAhdmlldy50ZXh0KSB7XFxuICAgICAgdmlldyA9IG51bGw7XFxuICAgIH0gZWxzZSBpZiAodmlldyAmJiB2aWV3LmNoYW5nZXMpIHtcXG4gICAgICB1cGRhdGVMaW5lRm9yQ2hhbmdlcyhjbSwgdmlldywgbGluZU4sIGdldERpbWVuc2lvbnMoY20pKTtcXG4gICAgICBjbS5jdXJPcC5mb3JjZVVwZGF0ZSA9IHRydWU7XFxuICAgIH1cXG4gICAgaWYgKCF2aWV3KVxcbiAgICAgIHZpZXcgPSB1cGRhdGVFeHRlcm5hbE1lYXN1cmVtZW50KGNtLCBsaW5lKTtcXG5cXG4gICAgdmFyIGluZm8gPSBtYXBGcm9tTGluZVZpZXcodmlldywgbGluZSwgbGluZU4pO1xcbiAgICByZXR1cm4ge1xcbiAgICAgIGxpbmU6IGxpbmUsIHZpZXc6IHZpZXcsIHJlY3Q6IG51bGwsXFxuICAgICAgbWFwOiBpbmZvLm1hcCwgY2FjaGU6IGluZm8uY2FjaGUsIGJlZm9yZTogaW5mby5iZWZvcmUsXFxuICAgICAgaGFzSGVpZ2h0czogZmFsc2VcXG4gICAgfTtcXG4gIH1cXG5cXG4gIC8vIEdpdmVuIGEgcHJlcGFyZWQgbWVhc3VyZW1lbnQgb2JqZWN0LCBtZWFzdXJlcyB0aGUgcG9zaXRpb24gb2YgYW5cXG4gIC8vIGFjdHVhbCBjaGFyYWN0ZXIgKG9yIGZldGNoZXMgaXQgZnJvbSB0aGUgY2FjaGUpLlxcbiAgZnVuY3Rpb24gbWVhc3VyZUNoYXJQcmVwYXJlZChjbSwgcHJlcGFyZWQsIGNoLCBiaWFzLCB2YXJIZWlnaHQpIHtcXG4gICAgaWYgKHByZXBhcmVkLmJlZm9yZSkgY2ggPSAtMTtcXG4gICAgdmFyIGtleSA9IGNoICsgKGJpYXMgfHwgXFxcIlxcXCIpLCBmb3VuZDtcXG4gICAgaWYgKHByZXBhcmVkLmNhY2hlLmhhc093blByb3BlcnR5KGtleSkpIHtcXG4gICAgICBmb3VuZCA9IHByZXBhcmVkLmNhY2hlW2tleV07XFxuICAgIH0gZWxzZSB7XFxuICAgICAgaWYgKCFwcmVwYXJlZC5yZWN0KVxcbiAgICAgICAgcHJlcGFyZWQucmVjdCA9IHByZXBhcmVkLnZpZXcudGV4dC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcXG4gICAgICBpZiAoIXByZXBhcmVkLmhhc0hlaWdodHMpIHtcXG4gICAgICAgIGVuc3VyZUxpbmVIZWlnaHRzKGNtLCBwcmVwYXJlZC52aWV3LCBwcmVwYXJlZC5yZWN0KTtcXG4gICAgICAgIHByZXBhcmVkLmhhc0hlaWdodHMgPSB0cnVlO1xcbiAgICAgIH1cXG4gICAgICBmb3VuZCA9IG1lYXN1cmVDaGFySW5uZXIoY20sIHByZXBhcmVkLCBjaCwgYmlhcyk7XFxuICAgICAgaWYgKCFmb3VuZC5ib2d1cykgcHJlcGFyZWQuY2FjaGVba2V5XSA9IGZvdW5kO1xcbiAgICB9XFxuICAgIHJldHVybiB7bGVmdDogZm91bmQubGVmdCwgcmlnaHQ6IGZvdW5kLnJpZ2h0LFxcbiAgICAgICAgICAgIHRvcDogdmFySGVpZ2h0ID8gZm91bmQucnRvcCA6IGZvdW5kLnRvcCxcXG4gICAgICAgICAgICBib3R0b206IHZhckhlaWdodCA/IGZvdW5kLnJib3R0b20gOiBmb3VuZC5ib3R0b219O1xcbiAgfVxcblxcbiAgdmFyIG51bGxSZWN0ID0ge2xlZnQ6IDAsIHJpZ2h0OiAwLCB0b3A6IDAsIGJvdHRvbTogMH07XFxuXFxuICBmdW5jdGlvbiBub2RlQW5kT2Zmc2V0SW5MaW5lTWFwKG1hcCwgY2gsIGJpYXMpIHtcXG4gICAgdmFyIG5vZGUsIHN0YXJ0LCBlbmQsIGNvbGxhcHNlO1xcbiAgICAvLyBGaXJzdCwgc2VhcmNoIHRoZSBsaW5lIG1hcCBmb3IgdGhlIHRleHQgbm9kZSBjb3JyZXNwb25kaW5nIHRvLFxcbiAgICAvLyBvciBjbG9zZXN0IHRvLCB0aGUgdGFyZ2V0IGNoYXJhY3Rlci5cXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXAubGVuZ3RoOyBpICs9IDMpIHtcXG4gICAgICB2YXIgbVN0YXJ0ID0gbWFwW2ldLCBtRW5kID0gbWFwW2kgKyAxXTtcXG4gICAgICBpZiAoY2ggPCBtU3RhcnQpIHtcXG4gICAgICAgIHN0YXJ0ID0gMDsgZW5kID0gMTtcXG4gICAgICAgIGNvbGxhcHNlID0gXFxcImxlZnRcXFwiO1xcbiAgICAgIH0gZWxzZSBpZiAoY2ggPCBtRW5kKSB7XFxuICAgICAgICBzdGFydCA9IGNoIC0gbVN0YXJ0O1xcbiAgICAgICAgZW5kID0gc3RhcnQgKyAxO1xcbiAgICAgIH0gZWxzZSBpZiAoaSA9PSBtYXAubGVuZ3RoIC0gMyB8fCBjaCA9PSBtRW5kICYmIG1hcFtpICsgM10gPiBjaCkge1xcbiAgICAgICAgZW5kID0gbUVuZCAtIG1TdGFydDtcXG4gICAgICAgIHN0YXJ0ID0gZW5kIC0gMTtcXG4gICAgICAgIGlmIChjaCA+PSBtRW5kKSBjb2xsYXBzZSA9IFxcXCJyaWdodFxcXCI7XFxuICAgICAgfVxcbiAgICAgIGlmIChzdGFydCAhPSBudWxsKSB7XFxuICAgICAgICBub2RlID0gbWFwW2kgKyAyXTtcXG4gICAgICAgIGlmIChtU3RhcnQgPT0gbUVuZCAmJiBiaWFzID09IChub2RlLmluc2VydExlZnQgPyBcXFwibGVmdFxcXCIgOiBcXFwicmlnaHRcXFwiKSlcXG4gICAgICAgICAgY29sbGFwc2UgPSBiaWFzO1xcbiAgICAgICAgaWYgKGJpYXMgPT0gXFxcImxlZnRcXFwiICYmIHN0YXJ0ID09IDApXFxuICAgICAgICAgIHdoaWxlIChpICYmIG1hcFtpIC0gMl0gPT0gbWFwW2kgLSAzXSAmJiBtYXBbaSAtIDFdLmluc2VydExlZnQpIHtcXG4gICAgICAgICAgICBub2RlID0gbWFwWyhpIC09IDMpICsgMl07XFxuICAgICAgICAgICAgY29sbGFwc2UgPSBcXFwibGVmdFxcXCI7XFxuICAgICAgICAgIH1cXG4gICAgICAgIGlmIChiaWFzID09IFxcXCJyaWdodFxcXCIgJiYgc3RhcnQgPT0gbUVuZCAtIG1TdGFydClcXG4gICAgICAgICAgd2hpbGUgKGkgPCBtYXAubGVuZ3RoIC0gMyAmJiBtYXBbaSArIDNdID09IG1hcFtpICsgNF0gJiYgIW1hcFtpICsgNV0uaW5zZXJ0TGVmdCkge1xcbiAgICAgICAgICAgIG5vZGUgPSBtYXBbKGkgKz0gMykgKyAyXTtcXG4gICAgICAgICAgICBjb2xsYXBzZSA9IFxcXCJyaWdodFxcXCI7XFxuICAgICAgICAgIH1cXG4gICAgICAgIGJyZWFrO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgICByZXR1cm4ge25vZGU6IG5vZGUsIHN0YXJ0OiBzdGFydCwgZW5kOiBlbmQsIGNvbGxhcHNlOiBjb2xsYXBzZSwgY292ZXJTdGFydDogbVN0YXJ0LCBjb3ZlckVuZDogbUVuZH07XFxuICB9XFxuXFxuICBmdW5jdGlvbiBnZXRVc2VmdWxSZWN0KHJlY3RzLCBiaWFzKSB7XFxuICAgIHZhciByZWN0ID0gbnVsbFJlY3RcXG4gICAgaWYgKGJpYXMgPT0gXFxcImxlZnRcXFwiKSBmb3IgKHZhciBpID0gMDsgaSA8IHJlY3RzLmxlbmd0aDsgaSsrKSB7XFxuICAgICAgaWYgKChyZWN0ID0gcmVjdHNbaV0pLmxlZnQgIT0gcmVjdC5yaWdodCkgYnJlYWtcXG4gICAgfSBlbHNlIGZvciAodmFyIGkgPSByZWN0cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xcbiAgICAgIGlmICgocmVjdCA9IHJlY3RzW2ldKS5sZWZ0ICE9IHJlY3QucmlnaHQpIGJyZWFrXFxuICAgIH1cXG4gICAgcmV0dXJuIHJlY3RcXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIG1lYXN1cmVDaGFySW5uZXIoY20sIHByZXBhcmVkLCBjaCwgYmlhcykge1xcbiAgICB2YXIgcGxhY2UgPSBub2RlQW5kT2Zmc2V0SW5MaW5lTWFwKHByZXBhcmVkLm1hcCwgY2gsIGJpYXMpO1xcbiAgICB2YXIgbm9kZSA9IHBsYWNlLm5vZGUsIHN0YXJ0ID0gcGxhY2Uuc3RhcnQsIGVuZCA9IHBsYWNlLmVuZCwgY29sbGFwc2UgPSBwbGFjZS5jb2xsYXBzZTtcXG5cXG4gICAgdmFyIHJlY3Q7XFxuICAgIGlmIChub2RlLm5vZGVUeXBlID09IDMpIHsgLy8gSWYgaXQgaXMgYSB0ZXh0IG5vZGUsIHVzZSBhIHJhbmdlIHRvIHJldHJpZXZlIHRoZSBjb29yZGluYXRlcy5cXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDQ7IGkrKykgeyAvLyBSZXRyeSBhIG1heGltdW0gb2YgNCB0aW1lcyB3aGVuIG5vbnNlbnNlIHJlY3RhbmdsZXMgYXJlIHJldHVybmVkXFxuICAgICAgICB3aGlsZSAoc3RhcnQgJiYgaXNFeHRlbmRpbmdDaGFyKHByZXBhcmVkLmxpbmUudGV4dC5jaGFyQXQocGxhY2UuY292ZXJTdGFydCArIHN0YXJ0KSkpIC0tc3RhcnQ7XFxuICAgICAgICB3aGlsZSAocGxhY2UuY292ZXJTdGFydCArIGVuZCA8IHBsYWNlLmNvdmVyRW5kICYmIGlzRXh0ZW5kaW5nQ2hhcihwcmVwYXJlZC5saW5lLnRleHQuY2hhckF0KHBsYWNlLmNvdmVyU3RhcnQgKyBlbmQpKSkgKytlbmQ7XFxuICAgICAgICBpZiAoaWUgJiYgaWVfdmVyc2lvbiA8IDkgJiYgc3RhcnQgPT0gMCAmJiBlbmQgPT0gcGxhY2UuY292ZXJFbmQgLSBwbGFjZS5jb3ZlclN0YXJ0KVxcbiAgICAgICAgICByZWN0ID0gbm9kZS5wYXJlbnROb2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xcbiAgICAgICAgZWxzZVxcbiAgICAgICAgICByZWN0ID0gZ2V0VXNlZnVsUmVjdChyYW5nZShub2RlLCBzdGFydCwgZW5kKS5nZXRDbGllbnRSZWN0cygpLCBiaWFzKVxcbiAgICAgICAgaWYgKHJlY3QubGVmdCB8fCByZWN0LnJpZ2h0IHx8IHN0YXJ0ID09IDApIGJyZWFrO1xcbiAgICAgICAgZW5kID0gc3RhcnQ7XFxuICAgICAgICBzdGFydCA9IHN0YXJ0IC0gMTtcXG4gICAgICAgIGNvbGxhcHNlID0gXFxcInJpZ2h0XFxcIjtcXG4gICAgICB9XFxuICAgICAgaWYgKGllICYmIGllX3ZlcnNpb24gPCAxMSkgcmVjdCA9IG1heWJlVXBkYXRlUmVjdEZvclpvb21pbmcoY20uZGlzcGxheS5tZWFzdXJlLCByZWN0KTtcXG4gICAgfSBlbHNlIHsgLy8gSWYgaXQgaXMgYSB3aWRnZXQsIHNpbXBseSBnZXQgdGhlIGJveCBmb3IgdGhlIHdob2xlIHdpZGdldC5cXG4gICAgICBpZiAoc3RhcnQgPiAwKSBjb2xsYXBzZSA9IGJpYXMgPSBcXFwicmlnaHRcXFwiO1xcbiAgICAgIHZhciByZWN0cztcXG4gICAgICBpZiAoY20ub3B0aW9ucy5saW5lV3JhcHBpbmcgJiYgKHJlY3RzID0gbm9kZS5nZXRDbGllbnRSZWN0cygpKS5sZW5ndGggPiAxKVxcbiAgICAgICAgcmVjdCA9IHJlY3RzW2JpYXMgPT0gXFxcInJpZ2h0XFxcIiA/IHJlY3RzLmxlbmd0aCAtIDEgOiAwXTtcXG4gICAgICBlbHNlXFxuICAgICAgICByZWN0ID0gbm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcXG4gICAgfVxcbiAgICBpZiAoaWUgJiYgaWVfdmVyc2lvbiA8IDkgJiYgIXN0YXJ0ICYmICghcmVjdCB8fCAhcmVjdC5sZWZ0ICYmICFyZWN0LnJpZ2h0KSkge1xcbiAgICAgIHZhciByU3BhbiA9IG5vZGUucGFyZW50Tm9kZS5nZXRDbGllbnRSZWN0cygpWzBdO1xcbiAgICAgIGlmIChyU3BhbilcXG4gICAgICAgIHJlY3QgPSB7bGVmdDogclNwYW4ubGVmdCwgcmlnaHQ6IHJTcGFuLmxlZnQgKyBjaGFyV2lkdGgoY20uZGlzcGxheSksIHRvcDogclNwYW4udG9wLCBib3R0b206IHJTcGFuLmJvdHRvbX07XFxuICAgICAgZWxzZVxcbiAgICAgICAgcmVjdCA9IG51bGxSZWN0O1xcbiAgICB9XFxuXFxuICAgIHZhciBydG9wID0gcmVjdC50b3AgLSBwcmVwYXJlZC5yZWN0LnRvcCwgcmJvdCA9IHJlY3QuYm90dG9tIC0gcHJlcGFyZWQucmVjdC50b3A7XFxuICAgIHZhciBtaWQgPSAocnRvcCArIHJib3QpIC8gMjtcXG4gICAgdmFyIGhlaWdodHMgPSBwcmVwYXJlZC52aWV3Lm1lYXN1cmUuaGVpZ2h0cztcXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBoZWlnaHRzLmxlbmd0aCAtIDE7IGkrKylcXG4gICAgICBpZiAobWlkIDwgaGVpZ2h0c1tpXSkgYnJlYWs7XFxuICAgIHZhciB0b3AgPSBpID8gaGVpZ2h0c1tpIC0gMV0gOiAwLCBib3QgPSBoZWlnaHRzW2ldO1xcbiAgICB2YXIgcmVzdWx0ID0ge2xlZnQ6IChjb2xsYXBzZSA9PSBcXFwicmlnaHRcXFwiID8gcmVjdC5yaWdodCA6IHJlY3QubGVmdCkgLSBwcmVwYXJlZC5yZWN0LmxlZnQsXFxuICAgICAgICAgICAgICAgICAgcmlnaHQ6IChjb2xsYXBzZSA9PSBcXFwibGVmdFxcXCIgPyByZWN0LmxlZnQgOiByZWN0LnJpZ2h0KSAtIHByZXBhcmVkLnJlY3QubGVmdCxcXG4gICAgICAgICAgICAgICAgICB0b3A6IHRvcCwgYm90dG9tOiBib3R9O1xcbiAgICBpZiAoIXJlY3QubGVmdCAmJiAhcmVjdC5yaWdodCkgcmVzdWx0LmJvZ3VzID0gdHJ1ZTtcXG4gICAgaWYgKCFjbS5vcHRpb25zLnNpbmdsZUN1cnNvckhlaWdodFBlckxpbmUpIHsgcmVzdWx0LnJ0b3AgPSBydG9wOyByZXN1bHQucmJvdHRvbSA9IHJib3Q7IH1cXG5cXG4gICAgcmV0dXJuIHJlc3VsdDtcXG4gIH1cXG5cXG4gIC8vIFdvcmsgYXJvdW5kIHByb2JsZW0gd2l0aCBib3VuZGluZyBjbGllbnQgcmVjdHMgb24gcmFuZ2VzIGJlaW5nXFxuICAvLyByZXR1cm5lZCBpbmNvcnJlY3RseSB3aGVuIHpvb21lZCBvbiBJRTEwIGFuZCBiZWxvdy5cXG4gIGZ1bmN0aW9uIG1heWJlVXBkYXRlUmVjdEZvclpvb21pbmcobWVhc3VyZSwgcmVjdCkge1xcbiAgICBpZiAoIXdpbmRvdy5zY3JlZW4gfHwgc2NyZWVuLmxvZ2ljYWxYRFBJID09IG51bGwgfHxcXG4gICAgICAgIHNjcmVlbi5sb2dpY2FsWERQSSA9PSBzY3JlZW4uZGV2aWNlWERQSSB8fCAhaGFzQmFkWm9vbWVkUmVjdHMobWVhc3VyZSkpXFxuICAgICAgcmV0dXJuIHJlY3Q7XFxuICAgIHZhciBzY2FsZVggPSBzY3JlZW4ubG9naWNhbFhEUEkgLyBzY3JlZW4uZGV2aWNlWERQSTtcXG4gICAgdmFyIHNjYWxlWSA9IHNjcmVlbi5sb2dpY2FsWURQSSAvIHNjcmVlbi5kZXZpY2VZRFBJO1xcbiAgICByZXR1cm4ge2xlZnQ6IHJlY3QubGVmdCAqIHNjYWxlWCwgcmlnaHQ6IHJlY3QucmlnaHQgKiBzY2FsZVgsXFxuICAgICAgICAgICAgdG9wOiByZWN0LnRvcCAqIHNjYWxlWSwgYm90dG9tOiByZWN0LmJvdHRvbSAqIHNjYWxlWX07XFxuICB9XFxuXFxuICBmdW5jdGlvbiBjbGVhckxpbmVNZWFzdXJlbWVudENhY2hlRm9yKGxpbmVWaWV3KSB7XFxuICAgIGlmIChsaW5lVmlldy5tZWFzdXJlKSB7XFxuICAgICAgbGluZVZpZXcubWVhc3VyZS5jYWNoZSA9IHt9O1xcbiAgICAgIGxpbmVWaWV3Lm1lYXN1cmUuaGVpZ2h0cyA9IG51bGw7XFxuICAgICAgaWYgKGxpbmVWaWV3LnJlc3QpIGZvciAodmFyIGkgPSAwOyBpIDwgbGluZVZpZXcucmVzdC5sZW5ndGg7IGkrKylcXG4gICAgICAgIGxpbmVWaWV3Lm1lYXN1cmUuY2FjaGVzW2ldID0ge307XFxuICAgIH1cXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIGNsZWFyTGluZU1lYXN1cmVtZW50Q2FjaGUoY20pIHtcXG4gICAgY20uZGlzcGxheS5leHRlcm5hbE1lYXN1cmUgPSBudWxsO1xcbiAgICByZW1vdmVDaGlsZHJlbihjbS5kaXNwbGF5LmxpbmVNZWFzdXJlKTtcXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjbS5kaXNwbGF5LnZpZXcubGVuZ3RoOyBpKyspXFxuICAgICAgY2xlYXJMaW5lTWVhc3VyZW1lbnRDYWNoZUZvcihjbS5kaXNwbGF5LnZpZXdbaV0pO1xcbiAgfVxcblxcbiAgZnVuY3Rpb24gY2xlYXJDYWNoZXMoY20pIHtcXG4gICAgY2xlYXJMaW5lTWVhc3VyZW1lbnRDYWNoZShjbSk7XFxuICAgIGNtLmRpc3BsYXkuY2FjaGVkQ2hhcldpZHRoID0gY20uZGlzcGxheS5jYWNoZWRUZXh0SGVpZ2h0ID0gY20uZGlzcGxheS5jYWNoZWRQYWRkaW5nSCA9IG51bGw7XFxuICAgIGlmICghY20ub3B0aW9ucy5saW5lV3JhcHBpbmcpIGNtLmRpc3BsYXkubWF4TGluZUNoYW5nZWQgPSB0cnVlO1xcbiAgICBjbS5kaXNwbGF5LmxpbmVOdW1DaGFycyA9IG51bGw7XFxuICB9XFxuXFxuICBmdW5jdGlvbiBwYWdlU2Nyb2xsWCgpIHsgcmV0dXJuIHdpbmRvdy5wYWdlWE9mZnNldCB8fCAoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50IHx8IGRvY3VtZW50LmJvZHkpLnNjcm9sbExlZnQ7IH1cXG4gIGZ1bmN0aW9uIHBhZ2VTY3JvbGxZKCkgeyByZXR1cm4gd2luZG93LnBhZ2VZT2Zmc2V0IHx8IChkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgfHwgZG9jdW1lbnQuYm9keSkuc2Nyb2xsVG9wOyB9XFxuXFxuICAvLyBDb252ZXJ0cyBhIHt0b3AsIGJvdHRvbSwgbGVmdCwgcmlnaHR9IGJveCBmcm9tIGxpbmUtbG9jYWxcXG4gIC8vIGNvb3JkaW5hdGVzIGludG8gYW5vdGhlciBjb29yZGluYXRlIHN5c3RlbS4gQ29udGV4dCBtYXkgYmUgb25lIG9mXFxuICAvLyBcXFwibGluZVxcXCIsIFxcXCJkaXZcXFwiIChkaXNwbGF5LmxpbmVEaXYpLCBcXFwibG9jYWxcXFwiL251bGwgKGVkaXRvciksIFxcXCJ3aW5kb3dcXFwiLFxcbiAgLy8gb3IgXFxcInBhZ2VcXFwiLlxcbiAgZnVuY3Rpb24gaW50b0Nvb3JkU3lzdGVtKGNtLCBsaW5lT2JqLCByZWN0LCBjb250ZXh0KSB7XFxuICAgIGlmIChsaW5lT2JqLndpZGdldHMpIGZvciAodmFyIGkgPSAwOyBpIDwgbGluZU9iai53aWRnZXRzLmxlbmd0aDsgKytpKSBpZiAobGluZU9iai53aWRnZXRzW2ldLmFib3ZlKSB7XFxuICAgICAgdmFyIHNpemUgPSB3aWRnZXRIZWlnaHQobGluZU9iai53aWRnZXRzW2ldKTtcXG4gICAgICByZWN0LnRvcCArPSBzaXplOyByZWN0LmJvdHRvbSArPSBzaXplO1xcbiAgICB9XFxuICAgIGlmIChjb250ZXh0ID09IFxcXCJsaW5lXFxcIikgcmV0dXJuIHJlY3Q7XFxuICAgIGlmICghY29udGV4dCkgY29udGV4dCA9IFxcXCJsb2NhbFxcXCI7XFxuICAgIHZhciB5T2ZmID0gaGVpZ2h0QXRMaW5lKGxpbmVPYmopO1xcbiAgICBpZiAoY29udGV4dCA9PSBcXFwibG9jYWxcXFwiKSB5T2ZmICs9IHBhZGRpbmdUb3AoY20uZGlzcGxheSk7XFxuICAgIGVsc2UgeU9mZiAtPSBjbS5kaXNwbGF5LnZpZXdPZmZzZXQ7XFxuICAgIGlmIChjb250ZXh0ID09IFxcXCJwYWdlXFxcIiB8fCBjb250ZXh0ID09IFxcXCJ3aW5kb3dcXFwiKSB7XFxuICAgICAgdmFyIGxPZmYgPSBjbS5kaXNwbGF5LmxpbmVTcGFjZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcXG4gICAgICB5T2ZmICs9IGxPZmYudG9wICsgKGNvbnRleHQgPT0gXFxcIndpbmRvd1xcXCIgPyAwIDogcGFnZVNjcm9sbFkoKSk7XFxuICAgICAgdmFyIHhPZmYgPSBsT2ZmLmxlZnQgKyAoY29udGV4dCA9PSBcXFwid2luZG93XFxcIiA/IDAgOiBwYWdlU2Nyb2xsWCgpKTtcXG4gICAgICByZWN0LmxlZnQgKz0geE9mZjsgcmVjdC5yaWdodCArPSB4T2ZmO1xcbiAgICB9XFxuICAgIHJlY3QudG9wICs9IHlPZmY7IHJlY3QuYm90dG9tICs9IHlPZmY7XFxuICAgIHJldHVybiByZWN0O1xcbiAgfVxcblxcbiAgLy8gQ292ZXJ0cyBhIGJveCBmcm9tIFxcXCJkaXZcXFwiIGNvb3JkcyB0byBhbm90aGVyIGNvb3JkaW5hdGUgc3lzdGVtLlxcbiAgLy8gQ29udGV4dCBtYXkgYmUgXFxcIndpbmRvd1xcXCIsIFxcXCJwYWdlXFxcIiwgXFxcImRpdlxcXCIsIG9yIFxcXCJsb2NhbFxcXCIvbnVsbC5cXG4gIGZ1bmN0aW9uIGZyb21Db29yZFN5c3RlbShjbSwgY29vcmRzLCBjb250ZXh0KSB7XFxuICAgIGlmIChjb250ZXh0ID09IFxcXCJkaXZcXFwiKSByZXR1cm4gY29vcmRzO1xcbiAgICB2YXIgbGVmdCA9IGNvb3Jkcy5sZWZ0LCB0b3AgPSBjb29yZHMudG9wO1xcbiAgICAvLyBGaXJzdCBtb3ZlIGludG8gXFxcInBhZ2VcXFwiIGNvb3JkaW5hdGUgc3lzdGVtXFxuICAgIGlmIChjb250ZXh0ID09IFxcXCJwYWdlXFxcIikge1xcbiAgICAgIGxlZnQgLT0gcGFnZVNjcm9sbFgoKTtcXG4gICAgICB0b3AgLT0gcGFnZVNjcm9sbFkoKTtcXG4gICAgfSBlbHNlIGlmIChjb250ZXh0ID09IFxcXCJsb2NhbFxcXCIgfHwgIWNvbnRleHQpIHtcXG4gICAgICB2YXIgbG9jYWxCb3ggPSBjbS5kaXNwbGF5LnNpemVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xcbiAgICAgIGxlZnQgKz0gbG9jYWxCb3gubGVmdDtcXG4gICAgICB0b3AgKz0gbG9jYWxCb3gudG9wO1xcbiAgICB9XFxuXFxuICAgIHZhciBsaW5lU3BhY2VCb3ggPSBjbS5kaXNwbGF5LmxpbmVTcGFjZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcXG4gICAgcmV0dXJuIHtsZWZ0OiBsZWZ0IC0gbGluZVNwYWNlQm94LmxlZnQsIHRvcDogdG9wIC0gbGluZVNwYWNlQm94LnRvcH07XFxuICB9XFxuXFxuICBmdW5jdGlvbiBjaGFyQ29vcmRzKGNtLCBwb3MsIGNvbnRleHQsIGxpbmVPYmosIGJpYXMpIHtcXG4gICAgaWYgKCFsaW5lT2JqKSBsaW5lT2JqID0gZ2V0TGluZShjbS5kb2MsIHBvcy5saW5lKTtcXG4gICAgcmV0dXJuIGludG9Db29yZFN5c3RlbShjbSwgbGluZU9iaiwgbWVhc3VyZUNoYXIoY20sIGxpbmVPYmosIHBvcy5jaCwgYmlhcyksIGNvbnRleHQpO1xcbiAgfVxcblxcbiAgLy8gUmV0dXJucyBhIGJveCBmb3IgYSBnaXZlbiBjdXJzb3IgcG9zaXRpb24sIHdoaWNoIG1heSBoYXZlIGFuXFxuICAvLyAnb3RoZXInIHByb3BlcnR5IGNvbnRhaW5pbmcgdGhlIHBvc2l0aW9uIG9mIHRoZSBzZWNvbmRhcnkgY3Vyc29yXFxuICAvLyBvbiBhIGJpZGkgYm91bmRhcnkuXFxuICBmdW5jdGlvbiBjdXJzb3JDb29yZHMoY20sIHBvcywgY29udGV4dCwgbGluZU9iaiwgcHJlcGFyZWRNZWFzdXJlLCB2YXJIZWlnaHQpIHtcXG4gICAgbGluZU9iaiA9IGxpbmVPYmogfHwgZ2V0TGluZShjbS5kb2MsIHBvcy5saW5lKTtcXG4gICAgaWYgKCFwcmVwYXJlZE1lYXN1cmUpIHByZXBhcmVkTWVhc3VyZSA9IHByZXBhcmVNZWFzdXJlRm9yTGluZShjbSwgbGluZU9iaik7XFxuICAgIGZ1bmN0aW9uIGdldChjaCwgcmlnaHQpIHtcXG4gICAgICB2YXIgbSA9IG1lYXN1cmVDaGFyUHJlcGFyZWQoY20sIHByZXBhcmVkTWVhc3VyZSwgY2gsIHJpZ2h0ID8gXFxcInJpZ2h0XFxcIiA6IFxcXCJsZWZ0XFxcIiwgdmFySGVpZ2h0KTtcXG4gICAgICBpZiAocmlnaHQpIG0ubGVmdCA9IG0ucmlnaHQ7IGVsc2UgbS5yaWdodCA9IG0ubGVmdDtcXG4gICAgICByZXR1cm4gaW50b0Nvb3JkU3lzdGVtKGNtLCBsaW5lT2JqLCBtLCBjb250ZXh0KTtcXG4gICAgfVxcbiAgICBmdW5jdGlvbiBnZXRCaWRpKGNoLCBwYXJ0UG9zKSB7XFxuICAgICAgdmFyIHBhcnQgPSBvcmRlcltwYXJ0UG9zXSwgcmlnaHQgPSBwYXJ0LmxldmVsICUgMjtcXG4gICAgICBpZiAoY2ggPT0gYmlkaUxlZnQocGFydCkgJiYgcGFydFBvcyAmJiBwYXJ0LmxldmVsIDwgb3JkZXJbcGFydFBvcyAtIDFdLmxldmVsKSB7XFxuICAgICAgICBwYXJ0ID0gb3JkZXJbLS1wYXJ0UG9zXTtcXG4gICAgICAgIGNoID0gYmlkaVJpZ2h0KHBhcnQpIC0gKHBhcnQubGV2ZWwgJSAyID8gMCA6IDEpO1xcbiAgICAgICAgcmlnaHQgPSB0cnVlO1xcbiAgICAgIH0gZWxzZSBpZiAoY2ggPT0gYmlkaVJpZ2h0KHBhcnQpICYmIHBhcnRQb3MgPCBvcmRlci5sZW5ndGggLSAxICYmIHBhcnQubGV2ZWwgPCBvcmRlcltwYXJ0UG9zICsgMV0ubGV2ZWwpIHtcXG4gICAgICAgIHBhcnQgPSBvcmRlclsrK3BhcnRQb3NdO1xcbiAgICAgICAgY2ggPSBiaWRpTGVmdChwYXJ0KSAtIHBhcnQubGV2ZWwgJSAyO1xcbiAgICAgICAgcmlnaHQgPSBmYWxzZTtcXG4gICAgICB9XFxuICAgICAgaWYgKHJpZ2h0ICYmIGNoID09IHBhcnQudG8gJiYgY2ggPiBwYXJ0LmZyb20pIHJldHVybiBnZXQoY2ggLSAxKTtcXG4gICAgICByZXR1cm4gZ2V0KGNoLCByaWdodCk7XFxuICAgIH1cXG4gICAgdmFyIG9yZGVyID0gZ2V0T3JkZXIobGluZU9iaiksIGNoID0gcG9zLmNoO1xcbiAgICBpZiAoIW9yZGVyKSByZXR1cm4gZ2V0KGNoKTtcXG4gICAgdmFyIHBhcnRQb3MgPSBnZXRCaWRpUGFydEF0KG9yZGVyLCBjaCk7XFxuICAgIHZhciB2YWwgPSBnZXRCaWRpKGNoLCBwYXJ0UG9zKTtcXG4gICAgaWYgKGJpZGlPdGhlciAhPSBudWxsKSB2YWwub3RoZXIgPSBnZXRCaWRpKGNoLCBiaWRpT3RoZXIpO1xcbiAgICByZXR1cm4gdmFsO1xcbiAgfVxcblxcbiAgLy8gVXNlZCB0byBjaGVhcGx5IGVzdGltYXRlIHRoZSBjb29yZGluYXRlcyBmb3IgYSBwb3NpdGlvbi4gVXNlZCBmb3JcXG4gIC8vIGludGVybWVkaWF0ZSBzY3JvbGwgdXBkYXRlcy5cXG4gIGZ1bmN0aW9uIGVzdGltYXRlQ29vcmRzKGNtLCBwb3MpIHtcXG4gICAgdmFyIGxlZnQgPSAwLCBwb3MgPSBjbGlwUG9zKGNtLmRvYywgcG9zKTtcXG4gICAgaWYgKCFjbS5vcHRpb25zLmxpbmVXcmFwcGluZykgbGVmdCA9IGNoYXJXaWR0aChjbS5kaXNwbGF5KSAqIHBvcy5jaDtcXG4gICAgdmFyIGxpbmVPYmogPSBnZXRMaW5lKGNtLmRvYywgcG9zLmxpbmUpO1xcbiAgICB2YXIgdG9wID0gaGVpZ2h0QXRMaW5lKGxpbmVPYmopICsgcGFkZGluZ1RvcChjbS5kaXNwbGF5KTtcXG4gICAgcmV0dXJuIHtsZWZ0OiBsZWZ0LCByaWdodDogbGVmdCwgdG9wOiB0b3AsIGJvdHRvbTogdG9wICsgbGluZU9iai5oZWlnaHR9O1xcbiAgfVxcblxcbiAgLy8gUG9zaXRpb25zIHJldHVybmVkIGJ5IGNvb3Jkc0NoYXIgY29udGFpbiBzb21lIGV4dHJhIGluZm9ybWF0aW9uLlxcbiAgLy8geFJlbCBpcyB0aGUgcmVsYXRpdmUgeCBwb3NpdGlvbiBvZiB0aGUgaW5wdXQgY29vcmRpbmF0ZXMgY29tcGFyZWRcXG4gIC8vIHRvIHRoZSBmb3VuZCBwb3NpdGlvbiAoc28geFJlbCA+IDAgbWVhbnMgdGhlIGNvb3JkaW5hdGVzIGFyZSB0b1xcbiAgLy8gdGhlIHJpZ2h0IG9mIHRoZSBjaGFyYWN0ZXIgcG9zaXRpb24sIGZvciBleGFtcGxlKS4gV2hlbiBvdXRzaWRlXFxuICAvLyBpcyB0cnVlLCB0aGF0IG1lYW5zIHRoZSBjb29yZGluYXRlcyBsaWUgb3V0c2lkZSB0aGUgbGluZSdzXFxuICAvLyB2ZXJ0aWNhbCByYW5nZS5cXG4gIGZ1bmN0aW9uIFBvc1dpdGhJbmZvKGxpbmUsIGNoLCBvdXRzaWRlLCB4UmVsKSB7XFxuICAgIHZhciBwb3MgPSBQb3MobGluZSwgY2gpO1xcbiAgICBwb3MueFJlbCA9IHhSZWw7XFxuICAgIGlmIChvdXRzaWRlKSBwb3Mub3V0c2lkZSA9IHRydWU7XFxuICAgIHJldHVybiBwb3M7XFxuICB9XFxuXFxuICAvLyBDb21wdXRlIHRoZSBjaGFyYWN0ZXIgcG9zaXRpb24gY2xvc2VzdCB0byB0aGUgZ2l2ZW4gY29vcmRpbmF0ZXMuXFxuICAvLyBJbnB1dCBtdXN0IGJlIGxpbmVTcGFjZS1sb2NhbCAoXFxcImRpdlxcXCIgY29vcmRpbmF0ZSBzeXN0ZW0pLlxcbiAgZnVuY3Rpb24gY29vcmRzQ2hhcihjbSwgeCwgeSkge1xcbiAgICB2YXIgZG9jID0gY20uZG9jO1xcbiAgICB5ICs9IGNtLmRpc3BsYXkudmlld09mZnNldDtcXG4gICAgaWYgKHkgPCAwKSByZXR1cm4gUG9zV2l0aEluZm8oZG9jLmZpcnN0LCAwLCB0cnVlLCAtMSk7XFxuICAgIHZhciBsaW5lTiA9IGxpbmVBdEhlaWdodChkb2MsIHkpLCBsYXN0ID0gZG9jLmZpcnN0ICsgZG9jLnNpemUgLSAxO1xcbiAgICBpZiAobGluZU4gPiBsYXN0KVxcbiAgICAgIHJldHVybiBQb3NXaXRoSW5mbyhkb2MuZmlyc3QgKyBkb2Muc2l6ZSAtIDEsIGdldExpbmUoZG9jLCBsYXN0KS50ZXh0Lmxlbmd0aCwgdHJ1ZSwgMSk7XFxuICAgIGlmICh4IDwgMCkgeCA9IDA7XFxuXFxuICAgIHZhciBsaW5lT2JqID0gZ2V0TGluZShkb2MsIGxpbmVOKTtcXG4gICAgZm9yICg7Oykge1xcbiAgICAgIHZhciBmb3VuZCA9IGNvb3Jkc0NoYXJJbm5lcihjbSwgbGluZU9iaiwgbGluZU4sIHgsIHkpO1xcbiAgICAgIHZhciBtZXJnZWQgPSBjb2xsYXBzZWRTcGFuQXRFbmQobGluZU9iaik7XFxuICAgICAgdmFyIG1lcmdlZFBvcyA9IG1lcmdlZCAmJiBtZXJnZWQuZmluZCgwLCB0cnVlKTtcXG4gICAgICBpZiAobWVyZ2VkICYmIChmb3VuZC5jaCA+IG1lcmdlZFBvcy5mcm9tLmNoIHx8IGZvdW5kLmNoID09IG1lcmdlZFBvcy5mcm9tLmNoICYmIGZvdW5kLnhSZWwgPiAwKSlcXG4gICAgICAgIGxpbmVOID0gbGluZU5vKGxpbmVPYmogPSBtZXJnZWRQb3MudG8ubGluZSk7XFxuICAgICAgZWxzZVxcbiAgICAgICAgcmV0dXJuIGZvdW5kO1xcbiAgICB9XFxuICB9XFxuXFxuICBmdW5jdGlvbiBjb29yZHNDaGFySW5uZXIoY20sIGxpbmVPYmosIGxpbmVObywgeCwgeSkge1xcbiAgICB2YXIgaW5uZXJPZmYgPSB5IC0gaGVpZ2h0QXRMaW5lKGxpbmVPYmopO1xcbiAgICB2YXIgd3JvbmdMaW5lID0gZmFsc2UsIGFkanVzdCA9IDIgKiBjbS5kaXNwbGF5LndyYXBwZXIuY2xpZW50V2lkdGg7XFxuICAgIHZhciBwcmVwYXJlZE1lYXN1cmUgPSBwcmVwYXJlTWVhc3VyZUZvckxpbmUoY20sIGxpbmVPYmopO1xcblxcbiAgICBmdW5jdGlvbiBnZXRYKGNoKSB7XFxuICAgICAgdmFyIHNwID0gY3Vyc29yQ29vcmRzKGNtLCBQb3MobGluZU5vLCBjaCksIFxcXCJsaW5lXFxcIiwgbGluZU9iaiwgcHJlcGFyZWRNZWFzdXJlKTtcXG4gICAgICB3cm9uZ0xpbmUgPSB0cnVlO1xcbiAgICAgIGlmIChpbm5lck9mZiA+IHNwLmJvdHRvbSkgcmV0dXJuIHNwLmxlZnQgLSBhZGp1c3Q7XFxuICAgICAgZWxzZSBpZiAoaW5uZXJPZmYgPCBzcC50b3ApIHJldHVybiBzcC5sZWZ0ICsgYWRqdXN0O1xcbiAgICAgIGVsc2Ugd3JvbmdMaW5lID0gZmFsc2U7XFxuICAgICAgcmV0dXJuIHNwLmxlZnQ7XFxuICAgIH1cXG5cXG4gICAgdmFyIGJpZGkgPSBnZXRPcmRlcihsaW5lT2JqKSwgZGlzdCA9IGxpbmVPYmoudGV4dC5sZW5ndGg7XFxuICAgIHZhciBmcm9tID0gbGluZUxlZnQobGluZU9iaiksIHRvID0gbGluZVJpZ2h0KGxpbmVPYmopO1xcbiAgICB2YXIgZnJvbVggPSBnZXRYKGZyb20pLCBmcm9tT3V0c2lkZSA9IHdyb25nTGluZSwgdG9YID0gZ2V0WCh0byksIHRvT3V0c2lkZSA9IHdyb25nTGluZTtcXG5cXG4gICAgaWYgKHggPiB0b1gpIHJldHVybiBQb3NXaXRoSW5mbyhsaW5lTm8sIHRvLCB0b091dHNpZGUsIDEpO1xcbiAgICAvLyBEbyBhIGJpbmFyeSBzZWFyY2ggYmV0d2VlbiB0aGVzZSBib3VuZHMuXFxuICAgIGZvciAoOzspIHtcXG4gICAgICBpZiAoYmlkaSA/IHRvID09IGZyb20gfHwgdG8gPT0gbW92ZVZpc3VhbGx5KGxpbmVPYmosIGZyb20sIDEpIDogdG8gLSBmcm9tIDw9IDEpIHtcXG4gICAgICAgIHZhciBjaCA9IHggPCBmcm9tWCB8fCB4IC0gZnJvbVggPD0gdG9YIC0geCA/IGZyb20gOiB0bztcXG4gICAgICAgIHZhciBvdXRzaWRlID0gY2ggPT0gZnJvbSA/IGZyb21PdXRzaWRlIDogdG9PdXRzaWRlXFxuICAgICAgICB2YXIgeERpZmYgPSB4IC0gKGNoID09IGZyb20gPyBmcm9tWCA6IHRvWCk7XFxuICAgICAgICAvLyBUaGlzIGlzIGEga2x1ZGdlIHRvIGhhbmRsZSB0aGUgY2FzZSB3aGVyZSB0aGUgY29vcmRpbmF0ZXNcXG4gICAgICAgIC8vIGFyZSBhZnRlciBhIGxpbmUtd3JhcHBlZCBsaW5lLiBXZSBzaG91bGQgcmVwbGFjZSBpdCB3aXRoIGFcXG4gICAgICAgIC8vIG1vcmUgZ2VuZXJhbCBoYW5kbGluZyBvZiBjdXJzb3IgcG9zaXRpb25zIGFyb3VuZCBsaW5lXFxuICAgICAgICAvLyBicmVha3MuIChJc3N1ZSAjNDA3OClcXG4gICAgICAgIGlmICh0b091dHNpZGUgJiYgIWJpZGkgJiYgIS9cXFxccy8udGVzdChsaW5lT2JqLnRleHQuY2hhckF0KGNoKSkgJiYgeERpZmYgPiAwICYmXFxuICAgICAgICAgICAgY2ggPCBsaW5lT2JqLnRleHQubGVuZ3RoICYmIHByZXBhcmVkTWVhc3VyZS52aWV3Lm1lYXN1cmUuaGVpZ2h0cy5sZW5ndGggPiAxKSB7XFxuICAgICAgICAgIHZhciBjaGFyU2l6ZSA9IG1lYXN1cmVDaGFyUHJlcGFyZWQoY20sIHByZXBhcmVkTWVhc3VyZSwgY2gsIFxcXCJyaWdodFxcXCIpO1xcbiAgICAgICAgICBpZiAoaW5uZXJPZmYgPD0gY2hhclNpemUuYm90dG9tICYmIGlubmVyT2ZmID49IGNoYXJTaXplLnRvcCAmJiBNYXRoLmFicyh4IC0gY2hhclNpemUucmlnaHQpIDwgeERpZmYpIHtcXG4gICAgICAgICAgICBvdXRzaWRlID0gZmFsc2VcXG4gICAgICAgICAgICBjaCsrXFxuICAgICAgICAgICAgeERpZmYgPSB4IC0gY2hhclNpemUucmlnaHRcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgd2hpbGUgKGlzRXh0ZW5kaW5nQ2hhcihsaW5lT2JqLnRleHQuY2hhckF0KGNoKSkpICsrY2g7XFxuICAgICAgICB2YXIgcG9zID0gUG9zV2l0aEluZm8obGluZU5vLCBjaCwgb3V0c2lkZSwgeERpZmYgPCAtMSA/IC0xIDogeERpZmYgPiAxID8gMSA6IDApO1xcbiAgICAgICAgcmV0dXJuIHBvcztcXG4gICAgICB9XFxuICAgICAgdmFyIHN0ZXAgPSBNYXRoLmNlaWwoZGlzdCAvIDIpLCBtaWRkbGUgPSBmcm9tICsgc3RlcDtcXG4gICAgICBpZiAoYmlkaSkge1xcbiAgICAgICAgbWlkZGxlID0gZnJvbTtcXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RlcDsgKytpKSBtaWRkbGUgPSBtb3ZlVmlzdWFsbHkobGluZU9iaiwgbWlkZGxlLCAxKTtcXG4gICAgICB9XFxuICAgICAgdmFyIG1pZGRsZVggPSBnZXRYKG1pZGRsZSk7XFxuICAgICAgaWYgKG1pZGRsZVggPiB4KSB7dG8gPSBtaWRkbGU7IHRvWCA9IG1pZGRsZVg7IGlmICh0b091dHNpZGUgPSB3cm9uZ0xpbmUpIHRvWCArPSAxMDAwOyBkaXN0ID0gc3RlcDt9XFxuICAgICAgZWxzZSB7ZnJvbSA9IG1pZGRsZTsgZnJvbVggPSBtaWRkbGVYOyBmcm9tT3V0c2lkZSA9IHdyb25nTGluZTsgZGlzdCAtPSBzdGVwO31cXG4gICAgfVxcbiAgfVxcblxcbiAgdmFyIG1lYXN1cmVUZXh0O1xcbiAgLy8gQ29tcHV0ZSB0aGUgZGVmYXVsdCB0ZXh0IGhlaWdodC5cXG4gIGZ1bmN0aW9uIHRleHRIZWlnaHQoZGlzcGxheSkge1xcbiAgICBpZiAoZGlzcGxheS5jYWNoZWRUZXh0SGVpZ2h0ICE9IG51bGwpIHJldHVybiBkaXNwbGF5LmNhY2hlZFRleHRIZWlnaHQ7XFxuICAgIGlmIChtZWFzdXJlVGV4dCA9PSBudWxsKSB7XFxuICAgICAgbWVhc3VyZVRleHQgPSBlbHQoXFxcInByZVxcXCIpO1xcbiAgICAgIC8vIE1lYXN1cmUgYSBidW5jaCBvZiBsaW5lcywgZm9yIGJyb3dzZXJzIHRoYXQgY29tcHV0ZVxcbiAgICAgIC8vIGZyYWN0aW9uYWwgaGVpZ2h0cy5cXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDQ5OyArK2kpIHtcXG4gICAgICAgIG1lYXN1cmVUZXh0LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFxcXCJ4XFxcIikpO1xcbiAgICAgICAgbWVhc3VyZVRleHQuYXBwZW5kQ2hpbGQoZWx0KFxcXCJiclxcXCIpKTtcXG4gICAgICB9XFxuICAgICAgbWVhc3VyZVRleHQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXFxcInhcXFwiKSk7XFxuICAgIH1cXG4gICAgcmVtb3ZlQ2hpbGRyZW5BbmRBZGQoZGlzcGxheS5tZWFzdXJlLCBtZWFzdXJlVGV4dCk7XFxuICAgIHZhciBoZWlnaHQgPSBtZWFzdXJlVGV4dC5vZmZzZXRIZWlnaHQgLyA1MDtcXG4gICAgaWYgKGhlaWdodCA+IDMpIGRpc3BsYXkuY2FjaGVkVGV4dEhlaWdodCA9IGhlaWdodDtcXG4gICAgcmVtb3ZlQ2hpbGRyZW4oZGlzcGxheS5tZWFzdXJlKTtcXG4gICAgcmV0dXJuIGhlaWdodCB8fCAxO1xcbiAgfVxcblxcbiAgLy8gQ29tcHV0ZSB0aGUgZGVmYXVsdCBjaGFyYWN0ZXIgd2lkdGguXFxuICBmdW5jdGlvbiBjaGFyV2lkdGgoZGlzcGxheSkge1xcbiAgICBpZiAoZGlzcGxheS5jYWNoZWRDaGFyV2lkdGggIT0gbnVsbCkgcmV0dXJuIGRpc3BsYXkuY2FjaGVkQ2hhcldpZHRoO1xcbiAgICB2YXIgYW5jaG9yID0gZWx0KFxcXCJzcGFuXFxcIiwgXFxcInh4eHh4eHh4eHhcXFwiKTtcXG4gICAgdmFyIHByZSA9IGVsdChcXFwicHJlXFxcIiwgW2FuY2hvcl0pO1xcbiAgICByZW1vdmVDaGlsZHJlbkFuZEFkZChkaXNwbGF5Lm1lYXN1cmUsIHByZSk7XFxuICAgIHZhciByZWN0ID0gYW5jaG9yLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLCB3aWR0aCA9IChyZWN0LnJpZ2h0IC0gcmVjdC5sZWZ0KSAvIDEwO1xcbiAgICBpZiAod2lkdGggPiAyKSBkaXNwbGF5LmNhY2hlZENoYXJXaWR0aCA9IHdpZHRoO1xcbiAgICByZXR1cm4gd2lkdGggfHwgMTA7XFxuICB9XFxuXFxuICAvLyBPUEVSQVRJT05TXFxuXFxuICAvLyBPcGVyYXRpb25zIGFyZSB1c2VkIHRvIHdyYXAgYSBzZXJpZXMgb2YgY2hhbmdlcyB0byB0aGUgZWRpdG9yXFxuICAvLyBzdGF0ZSBpbiBzdWNoIGEgd2F5IHRoYXQgZWFjaCBjaGFuZ2Ugd29uJ3QgaGF2ZSB0byB1cGRhdGUgdGhlXFxuICAvLyBjdXJzb3IgYW5kIGRpc3BsYXkgKHdoaWNoIHdvdWxkIGJlIGF3a3dhcmQsIHNsb3csIGFuZFxcbiAgLy8gZXJyb3ItcHJvbmUpLiBJbnN0ZWFkLCBkaXNwbGF5IHVwZGF0ZXMgYXJlIGJhdGNoZWQgYW5kIHRoZW4gYWxsXFxuICAvLyBjb21iaW5lZCBhbmQgZXhlY3V0ZWQgYXQgb25jZS5cXG5cXG4gIHZhciBvcGVyYXRpb25Hcm91cCA9IG51bGw7XFxuXFxuICB2YXIgbmV4dE9wSWQgPSAwO1xcbiAgLy8gU3RhcnQgYSBuZXcgb3BlcmF0aW9uLlxcbiAgZnVuY3Rpb24gc3RhcnRPcGVyYXRpb24oY20pIHtcXG4gICAgY20uY3VyT3AgPSB7XFxuICAgICAgY206IGNtLFxcbiAgICAgIHZpZXdDaGFuZ2VkOiBmYWxzZSwgICAgICAvLyBGbGFnIHRoYXQgaW5kaWNhdGVzIHRoYXQgbGluZXMgbWlnaHQgbmVlZCB0byBiZSByZWRyYXduXFxuICAgICAgc3RhcnRIZWlnaHQ6IGNtLmRvYy5oZWlnaHQsIC8vIFVzZWQgdG8gZGV0ZWN0IG5lZWQgdG8gdXBkYXRlIHNjcm9sbGJhclxcbiAgICAgIGZvcmNlVXBkYXRlOiBmYWxzZSwgICAgICAvLyBVc2VkIHRvIGZvcmNlIGEgcmVkcmF3XFxuICAgICAgdXBkYXRlSW5wdXQ6IG51bGwsICAgICAgIC8vIFdoZXRoZXIgdG8gcmVzZXQgdGhlIGlucHV0IHRleHRhcmVhXFxuICAgICAgdHlwaW5nOiBmYWxzZSwgICAgICAgICAgIC8vIFdoZXRoZXIgdGhpcyByZXNldCBzaG91bGQgYmUgY2FyZWZ1bCB0byBsZWF2ZSBleGlzdGluZyB0ZXh0IChmb3IgY29tcG9zaXRpbmcpXFxuICAgICAgY2hhbmdlT2JqczogbnVsbCwgICAgICAgIC8vIEFjY3VtdWxhdGVkIGNoYW5nZXMsIGZvciBmaXJpbmcgY2hhbmdlIGV2ZW50c1xcbiAgICAgIGN1cnNvckFjdGl2aXR5SGFuZGxlcnM6IG51bGwsIC8vIFNldCBvZiBoYW5kbGVycyB0byBmaXJlIGN1cnNvckFjdGl2aXR5IG9uXFxuICAgICAgY3Vyc29yQWN0aXZpdHlDYWxsZWQ6IDAsIC8vIFRyYWNrcyB3aGljaCBjdXJzb3JBY3Rpdml0eSBoYW5kbGVycyBoYXZlIGJlZW4gY2FsbGVkIGFscmVhZHlcXG4gICAgICBzZWxlY3Rpb25DaGFuZ2VkOiBmYWxzZSwgLy8gV2hldGhlciB0aGUgc2VsZWN0aW9uIG5lZWRzIHRvIGJlIHJlZHJhd25cXG4gICAgICB1cGRhdGVNYXhMaW5lOiBmYWxzZSwgICAgLy8gU2V0IHdoZW4gdGhlIHdpZGVzdCBsaW5lIG5lZWRzIHRvIGJlIGRldGVybWluZWQgYW5ld1xcbiAgICAgIHNjcm9sbExlZnQ6IG51bGwsIHNjcm9sbFRvcDogbnVsbCwgLy8gSW50ZXJtZWRpYXRlIHNjcm9sbCBwb3NpdGlvbiwgbm90IHB1c2hlZCB0byBET00geWV0XFxuICAgICAgc2Nyb2xsVG9Qb3M6IG51bGwsICAgICAgIC8vIFVzZWQgdG8gc2Nyb2xsIHRvIGEgc3BlY2lmaWMgcG9zaXRpb25cXG4gICAgICBmb2N1czogZmFsc2UsXFxuICAgICAgaWQ6ICsrbmV4dE9wSWQgICAgICAgICAgIC8vIFVuaXF1ZSBJRFxcbiAgICB9O1xcbiAgICBpZiAob3BlcmF0aW9uR3JvdXApIHtcXG4gICAgICBvcGVyYXRpb25Hcm91cC5vcHMucHVzaChjbS5jdXJPcCk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgY20uY3VyT3Aub3duc0dyb3VwID0gb3BlcmF0aW9uR3JvdXAgPSB7XFxuICAgICAgICBvcHM6IFtjbS5jdXJPcF0sXFxuICAgICAgICBkZWxheWVkQ2FsbGJhY2tzOiBbXVxcbiAgICAgIH07XFxuICAgIH1cXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIGZpcmVDYWxsYmFja3NGb3JPcHMoZ3JvdXApIHtcXG4gICAgLy8gQ2FsbHMgZGVsYXllZCBjYWxsYmFja3MgYW5kIGN1cnNvckFjdGl2aXR5IGhhbmRsZXJzIHVudGlsIG5vXFxuICAgIC8vIG5ldyBvbmVzIGFwcGVhclxcbiAgICB2YXIgY2FsbGJhY2tzID0gZ3JvdXAuZGVsYXllZENhbGxiYWNrcywgaSA9IDA7XFxuICAgIGRvIHtcXG4gICAgICBmb3IgKDsgaSA8IGNhbGxiYWNrcy5sZW5ndGg7IGkrKylcXG4gICAgICAgIGNhbGxiYWNrc1tpXS5jYWxsKG51bGwpO1xcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZ3JvdXAub3BzLmxlbmd0aDsgaisrKSB7XFxuICAgICAgICB2YXIgb3AgPSBncm91cC5vcHNbal07XFxuICAgICAgICBpZiAob3AuY3Vyc29yQWN0aXZpdHlIYW5kbGVycylcXG4gICAgICAgICAgd2hpbGUgKG9wLmN1cnNvckFjdGl2aXR5Q2FsbGVkIDwgb3AuY3Vyc29yQWN0aXZpdHlIYW5kbGVycy5sZW5ndGgpXFxuICAgICAgICAgICAgb3AuY3Vyc29yQWN0aXZpdHlIYW5kbGVyc1tvcC5jdXJzb3JBY3Rpdml0eUNhbGxlZCsrXS5jYWxsKG51bGwsIG9wLmNtKTtcXG4gICAgICB9XFxuICAgIH0gd2hpbGUgKGkgPCBjYWxsYmFja3MubGVuZ3RoKTtcXG4gIH1cXG5cXG4gIC8vIEZpbmlzaCBhbiBvcGVyYXRpb24sIHVwZGF0aW5nIHRoZSBkaXNwbGF5IGFuZCBzaWduYWxsaW5nIGRlbGF5ZWQgZXZlbnRzXFxuICBmdW5jdGlvbiBlbmRPcGVyYXRpb24oY20pIHtcXG4gICAgdmFyIG9wID0gY20uY3VyT3AsIGdyb3VwID0gb3Aub3duc0dyb3VwO1xcbiAgICBpZiAoIWdyb3VwKSByZXR1cm47XFxuXFxuICAgIHRyeSB7IGZpcmVDYWxsYmFja3NGb3JPcHMoZ3JvdXApOyB9XFxuICAgIGZpbmFsbHkge1xcbiAgICAgIG9wZXJhdGlvbkdyb3VwID0gbnVsbDtcXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdyb3VwLm9wcy5sZW5ndGg7IGkrKylcXG4gICAgICAgIGdyb3VwLm9wc1tpXS5jbS5jdXJPcCA9IG51bGw7XFxuICAgICAgZW5kT3BlcmF0aW9ucyhncm91cCk7XFxuICAgIH1cXG4gIH1cXG5cXG4gIC8vIFRoZSBET00gdXBkYXRlcyBkb25lIHdoZW4gYW4gb3BlcmF0aW9uIGZpbmlzaGVzIGFyZSBiYXRjaGVkIHNvXFxuICAvLyB0aGF0IHRoZSBtaW5pbXVtIG51bWJlciBvZiByZWxheW91dHMgYXJlIHJlcXVpcmVkLlxcbiAgZnVuY3Rpb24gZW5kT3BlcmF0aW9ucyhncm91cCkge1xcbiAgICB2YXIgb3BzID0gZ3JvdXAub3BzO1xcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9wcy5sZW5ndGg7IGkrKykgLy8gUmVhZCBET01cXG4gICAgICBlbmRPcGVyYXRpb25fUjEob3BzW2ldKTtcXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcHMubGVuZ3RoOyBpKyspIC8vIFdyaXRlIERPTSAobWF5YmUpXFxuICAgICAgZW5kT3BlcmF0aW9uX1cxKG9wc1tpXSk7XFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3BzLmxlbmd0aDsgaSsrKSAvLyBSZWFkIERPTVxcbiAgICAgIGVuZE9wZXJhdGlvbl9SMihvcHNbaV0pO1xcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9wcy5sZW5ndGg7IGkrKykgLy8gV3JpdGUgRE9NIChtYXliZSlcXG4gICAgICBlbmRPcGVyYXRpb25fVzIob3BzW2ldKTtcXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcHMubGVuZ3RoOyBpKyspIC8vIFJlYWQgRE9NXFxuICAgICAgZW5kT3BlcmF0aW9uX2ZpbmlzaChvcHNbaV0pO1xcbiAgfVxcblxcbiAgZnVuY3Rpb24gZW5kT3BlcmF0aW9uX1IxKG9wKSB7XFxuICAgIHZhciBjbSA9IG9wLmNtLCBkaXNwbGF5ID0gY20uZGlzcGxheTtcXG4gICAgbWF5YmVDbGlwU2Nyb2xsYmFycyhjbSk7XFxuICAgIGlmIChvcC51cGRhdGVNYXhMaW5lKSBmaW5kTWF4TGluZShjbSk7XFxuXFxuICAgIG9wLm11c3RVcGRhdGUgPSBvcC52aWV3Q2hhbmdlZCB8fCBvcC5mb3JjZVVwZGF0ZSB8fCBvcC5zY3JvbGxUb3AgIT0gbnVsbCB8fFxcbiAgICAgIG9wLnNjcm9sbFRvUG9zICYmIChvcC5zY3JvbGxUb1Bvcy5mcm9tLmxpbmUgPCBkaXNwbGF5LnZpZXdGcm9tIHx8XFxuICAgICAgICAgICAgICAgICAgICAgICAgIG9wLnNjcm9sbFRvUG9zLnRvLmxpbmUgPj0gZGlzcGxheS52aWV3VG8pIHx8XFxuICAgICAgZGlzcGxheS5tYXhMaW5lQ2hhbmdlZCAmJiBjbS5vcHRpb25zLmxpbmVXcmFwcGluZztcXG4gICAgb3AudXBkYXRlID0gb3AubXVzdFVwZGF0ZSAmJlxcbiAgICAgIG5ldyBEaXNwbGF5VXBkYXRlKGNtLCBvcC5tdXN0VXBkYXRlICYmIHt0b3A6IG9wLnNjcm9sbFRvcCwgZW5zdXJlOiBvcC5zY3JvbGxUb1Bvc30sIG9wLmZvcmNlVXBkYXRlKTtcXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIGVuZE9wZXJhdGlvbl9XMShvcCkge1xcbiAgICBvcC51cGRhdGVkRGlzcGxheSA9IG9wLm11c3RVcGRhdGUgJiYgdXBkYXRlRGlzcGxheUlmTmVlZGVkKG9wLmNtLCBvcC51cGRhdGUpO1xcbiAgfVxcblxcbiAgZnVuY3Rpb24gZW5kT3BlcmF0aW9uX1IyKG9wKSB7XFxuICAgIHZhciBjbSA9IG9wLmNtLCBkaXNwbGF5ID0gY20uZGlzcGxheTtcXG4gICAgaWYgKG9wLnVwZGF0ZWREaXNwbGF5KSB1cGRhdGVIZWlnaHRzSW5WaWV3cG9ydChjbSk7XFxuXFxuICAgIG9wLmJhck1lYXN1cmUgPSBtZWFzdXJlRm9yU2Nyb2xsYmFycyhjbSk7XFxuXFxuICAgIC8vIElmIHRoZSBtYXggbGluZSBjaGFuZ2VkIHNpbmNlIGl0IHdhcyBsYXN0IG1lYXN1cmVkLCBtZWFzdXJlIGl0LFxcbiAgICAvLyBhbmQgZW5zdXJlIHRoZSBkb2N1bWVudCdzIHdpZHRoIG1hdGNoZXMgaXQuXFxuICAgIC8vIHVwZGF0ZURpc3BsYXlfVzIgd2lsbCB1c2UgdGhlc2UgcHJvcGVydGllcyB0byBkbyB0aGUgYWN0dWFsIHJlc2l6aW5nXFxuICAgIGlmIChkaXNwbGF5Lm1heExpbmVDaGFuZ2VkICYmICFjbS5vcHRpb25zLmxpbmVXcmFwcGluZykge1xcbiAgICAgIG9wLmFkanVzdFdpZHRoVG8gPSBtZWFzdXJlQ2hhcihjbSwgZGlzcGxheS5tYXhMaW5lLCBkaXNwbGF5Lm1heExpbmUudGV4dC5sZW5ndGgpLmxlZnQgKyAzO1xcbiAgICAgIGNtLmRpc3BsYXkuc2l6ZXJXaWR0aCA9IG9wLmFkanVzdFdpZHRoVG87XFxuICAgICAgb3AuYmFyTWVhc3VyZS5zY3JvbGxXaWR0aCA9XFxuICAgICAgICBNYXRoLm1heChkaXNwbGF5LnNjcm9sbGVyLmNsaWVudFdpZHRoLCBkaXNwbGF5LnNpemVyLm9mZnNldExlZnQgKyBvcC5hZGp1c3RXaWR0aFRvICsgc2Nyb2xsR2FwKGNtKSArIGNtLmRpc3BsYXkuYmFyV2lkdGgpO1xcbiAgICAgIG9wLm1heFNjcm9sbExlZnQgPSBNYXRoLm1heCgwLCBkaXNwbGF5LnNpemVyLm9mZnNldExlZnQgKyBvcC5hZGp1c3RXaWR0aFRvIC0gZGlzcGxheVdpZHRoKGNtKSk7XFxuICAgIH1cXG5cXG4gICAgaWYgKG9wLnVwZGF0ZWREaXNwbGF5IHx8IG9wLnNlbGVjdGlvbkNoYW5nZWQpXFxuICAgICAgb3AucHJlcGFyZWRTZWxlY3Rpb24gPSBkaXNwbGF5LmlucHV0LnByZXBhcmVTZWxlY3Rpb24ob3AuZm9jdXMpO1xcbiAgfVxcblxcbiAgZnVuY3Rpb24gZW5kT3BlcmF0aW9uX1cyKG9wKSB7XFxuICAgIHZhciBjbSA9IG9wLmNtO1xcblxcbiAgICBpZiAob3AuYWRqdXN0V2lkdGhUbyAhPSBudWxsKSB7XFxuICAgICAgY20uZGlzcGxheS5zaXplci5zdHlsZS5taW5XaWR0aCA9IG9wLmFkanVzdFdpZHRoVG8gKyBcXFwicHhcXFwiO1xcbiAgICAgIGlmIChvcC5tYXhTY3JvbGxMZWZ0IDwgY20uZG9jLnNjcm9sbExlZnQpXFxuICAgICAgICBzZXRTY3JvbGxMZWZ0KGNtLCBNYXRoLm1pbihjbS5kaXNwbGF5LnNjcm9sbGVyLnNjcm9sbExlZnQsIG9wLm1heFNjcm9sbExlZnQpLCB0cnVlKTtcXG4gICAgICBjbS5kaXNwbGF5Lm1heExpbmVDaGFuZ2VkID0gZmFsc2U7XFxuICAgIH1cXG5cXG4gICAgdmFyIHRha2VGb2N1cyA9IG9wLmZvY3VzICYmIG9wLmZvY3VzID09IGFjdGl2ZUVsdCgpICYmICghZG9jdW1lbnQuaGFzRm9jdXMgfHwgZG9jdW1lbnQuaGFzRm9jdXMoKSlcXG4gICAgaWYgKG9wLnByZXBhcmVkU2VsZWN0aW9uKVxcbiAgICAgIGNtLmRpc3BsYXkuaW5wdXQuc2hvd1NlbGVjdGlvbihvcC5wcmVwYXJlZFNlbGVjdGlvbiwgdGFrZUZvY3VzKTtcXG4gICAgaWYgKG9wLnVwZGF0ZWREaXNwbGF5IHx8IG9wLnN0YXJ0SGVpZ2h0ICE9IGNtLmRvYy5oZWlnaHQpXFxuICAgICAgdXBkYXRlU2Nyb2xsYmFycyhjbSwgb3AuYmFyTWVhc3VyZSk7XFxuICAgIGlmIChvcC51cGRhdGVkRGlzcGxheSlcXG4gICAgICBzZXREb2N1bWVudEhlaWdodChjbSwgb3AuYmFyTWVhc3VyZSk7XFxuXFxuICAgIGlmIChvcC5zZWxlY3Rpb25DaGFuZ2VkKSByZXN0YXJ0QmxpbmsoY20pO1xcblxcbiAgICBpZiAoY20uc3RhdGUuZm9jdXNlZCAmJiBvcC51cGRhdGVJbnB1dClcXG4gICAgICBjbS5kaXNwbGF5LmlucHV0LnJlc2V0KG9wLnR5cGluZyk7XFxuICAgIGlmICh0YWtlRm9jdXMpIGVuc3VyZUZvY3VzKG9wLmNtKTtcXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIGVuZE9wZXJhdGlvbl9maW5pc2gob3ApIHtcXG4gICAgdmFyIGNtID0gb3AuY20sIGRpc3BsYXkgPSBjbS5kaXNwbGF5LCBkb2MgPSBjbS5kb2M7XFxuXFxuICAgIGlmIChvcC51cGRhdGVkRGlzcGxheSkgcG9zdFVwZGF0ZURpc3BsYXkoY20sIG9wLnVwZGF0ZSk7XFxuXFxuICAgIC8vIEFib3J0IG1vdXNlIHdoZWVsIGRlbHRhIG1lYXN1cmVtZW50LCB3aGVuIHNjcm9sbGluZyBleHBsaWNpdGx5XFxuICAgIGlmIChkaXNwbGF5LndoZWVsU3RhcnRYICE9IG51bGwgJiYgKG9wLnNjcm9sbFRvcCAhPSBudWxsIHx8IG9wLnNjcm9sbExlZnQgIT0gbnVsbCB8fCBvcC5zY3JvbGxUb1BvcykpXFxuICAgICAgZGlzcGxheS53aGVlbFN0YXJ0WCA9IGRpc3BsYXkud2hlZWxTdGFydFkgPSBudWxsO1xcblxcbiAgICAvLyBQcm9wYWdhdGUgdGhlIHNjcm9sbCBwb3NpdGlvbiB0byB0aGUgYWN0dWFsIERPTSBzY3JvbGxlclxcbiAgICBpZiAob3Auc2Nyb2xsVG9wICE9IG51bGwgJiYgKGRpc3BsYXkuc2Nyb2xsZXIuc2Nyb2xsVG9wICE9IG9wLnNjcm9sbFRvcCB8fCBvcC5mb3JjZVNjcm9sbCkpIHtcXG4gICAgICBkb2Muc2Nyb2xsVG9wID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oZGlzcGxheS5zY3JvbGxlci5zY3JvbGxIZWlnaHQgLSBkaXNwbGF5LnNjcm9sbGVyLmNsaWVudEhlaWdodCwgb3Auc2Nyb2xsVG9wKSk7XFxuICAgICAgZGlzcGxheS5zY3JvbGxiYXJzLnNldFNjcm9sbFRvcChkb2Muc2Nyb2xsVG9wKTtcXG4gICAgICBkaXNwbGF5LnNjcm9sbGVyLnNjcm9sbFRvcCA9IGRvYy5zY3JvbGxUb3A7XFxuICAgIH1cXG4gICAgaWYgKG9wLnNjcm9sbExlZnQgIT0gbnVsbCAmJiAoZGlzcGxheS5zY3JvbGxlci5zY3JvbGxMZWZ0ICE9IG9wLnNjcm9sbExlZnQgfHwgb3AuZm9yY2VTY3JvbGwpKSB7XFxuICAgICAgZG9jLnNjcm9sbExlZnQgPSBNYXRoLm1heCgwLCBNYXRoLm1pbihkaXNwbGF5LnNjcm9sbGVyLnNjcm9sbFdpZHRoIC0gZGlzcGxheS5zY3JvbGxlci5jbGllbnRXaWR0aCwgb3Auc2Nyb2xsTGVmdCkpO1xcbiAgICAgIGRpc3BsYXkuc2Nyb2xsYmFycy5zZXRTY3JvbGxMZWZ0KGRvYy5zY3JvbGxMZWZ0KTtcXG4gICAgICBkaXNwbGF5LnNjcm9sbGVyLnNjcm9sbExlZnQgPSBkb2Muc2Nyb2xsTGVmdDtcXG4gICAgICBhbGlnbkhvcml6b250YWxseShjbSk7XFxuICAgIH1cXG4gICAgLy8gSWYgd2UgbmVlZCB0byBzY3JvbGwgYSBzcGVjaWZpYyBwb3NpdGlvbiBpbnRvIHZpZXcsIGRvIHNvLlxcbiAgICBpZiAob3Auc2Nyb2xsVG9Qb3MpIHtcXG4gICAgICB2YXIgY29vcmRzID0gc2Nyb2xsUG9zSW50b1ZpZXcoY20sIGNsaXBQb3MoZG9jLCBvcC5zY3JvbGxUb1Bvcy5mcm9tKSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xpcFBvcyhkb2MsIG9wLnNjcm9sbFRvUG9zLnRvKSwgb3Auc2Nyb2xsVG9Qb3MubWFyZ2luKTtcXG4gICAgICBpZiAob3Auc2Nyb2xsVG9Qb3MuaXNDdXJzb3IgJiYgY20uc3RhdGUuZm9jdXNlZCkgbWF5YmVTY3JvbGxXaW5kb3coY20sIGNvb3Jkcyk7XFxuICAgIH1cXG5cXG4gICAgLy8gRmlyZSBldmVudHMgZm9yIG1hcmtlcnMgdGhhdCBhcmUgaGlkZGVuL3VuaWRkZW4gYnkgZWRpdGluZyBvclxcbiAgICAvLyB1bmRvaW5nXFxuICAgIHZhciBoaWRkZW4gPSBvcC5tYXliZUhpZGRlbk1hcmtlcnMsIHVuaGlkZGVuID0gb3AubWF5YmVVbmhpZGRlbk1hcmtlcnM7XFxuICAgIGlmIChoaWRkZW4pIGZvciAodmFyIGkgPSAwOyBpIDwgaGlkZGVuLmxlbmd0aDsgKytpKVxcbiAgICAgIGlmICghaGlkZGVuW2ldLmxpbmVzLmxlbmd0aCkgc2lnbmFsKGhpZGRlbltpXSwgXFxcImhpZGVcXFwiKTtcXG4gICAgaWYgKHVuaGlkZGVuKSBmb3IgKHZhciBpID0gMDsgaSA8IHVuaGlkZGVuLmxlbmd0aDsgKytpKVxcbiAgICAgIGlmICh1bmhpZGRlbltpXS5saW5lcy5sZW5ndGgpIHNpZ25hbCh1bmhpZGRlbltpXSwgXFxcInVuaGlkZVxcXCIpO1xcblxcbiAgICBpZiAoZGlzcGxheS53cmFwcGVyLm9mZnNldEhlaWdodClcXG4gICAgICBkb2Muc2Nyb2xsVG9wID0gY20uZGlzcGxheS5zY3JvbGxlci5zY3JvbGxUb3A7XFxuXFxuICAgIC8vIEZpcmUgY2hhbmdlIGV2ZW50cywgYW5kIGRlbGF5ZWQgZXZlbnQgaGFuZGxlcnNcXG4gICAgaWYgKG9wLmNoYW5nZU9ianMpXFxuICAgICAgc2lnbmFsKGNtLCBcXFwiY2hhbmdlc1xcXCIsIGNtLCBvcC5jaGFuZ2VPYmpzKTtcXG4gICAgaWYgKG9wLnVwZGF0ZSlcXG4gICAgICBvcC51cGRhdGUuZmluaXNoKCk7XFxuICB9XFxuXFxuICAvLyBSdW4gdGhlIGdpdmVuIGZ1bmN0aW9uIGluIGFuIG9wZXJhdGlvblxcbiAgZnVuY3Rpb24gcnVuSW5PcChjbSwgZikge1xcbiAgICBpZiAoY20uY3VyT3ApIHJldHVybiBmKCk7XFxuICAgIHN0YXJ0T3BlcmF0aW9uKGNtKTtcXG4gICAgdHJ5IHsgcmV0dXJuIGYoKTsgfVxcbiAgICBmaW5hbGx5IHsgZW5kT3BlcmF0aW9uKGNtKTsgfVxcbiAgfVxcbiAgLy8gV3JhcHMgYSBmdW5jdGlvbiBpbiBhbiBvcGVyYXRpb24uIFJldHVybnMgdGhlIHdyYXBwZWQgZnVuY3Rpb24uXFxuICBmdW5jdGlvbiBvcGVyYXRpb24oY20sIGYpIHtcXG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xcbiAgICAgIGlmIChjbS5jdXJPcCkgcmV0dXJuIGYuYXBwbHkoY20sIGFyZ3VtZW50cyk7XFxuICAgICAgc3RhcnRPcGVyYXRpb24oY20pO1xcbiAgICAgIHRyeSB7IHJldHVybiBmLmFwcGx5KGNtLCBhcmd1bWVudHMpOyB9XFxuICAgICAgZmluYWxseSB7IGVuZE9wZXJhdGlvbihjbSk7IH1cXG4gICAgfTtcXG4gIH1cXG4gIC8vIFVzZWQgdG8gYWRkIG1ldGhvZHMgdG8gZWRpdG9yIGFuZCBkb2MgaW5zdGFuY2VzLCB3cmFwcGluZyB0aGVtIGluXFxuICAvLyBvcGVyYXRpb25zLlxcbiAgZnVuY3Rpb24gbWV0aG9kT3AoZikge1xcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XFxuICAgICAgaWYgKHRoaXMuY3VyT3ApIHJldHVybiBmLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XFxuICAgICAgc3RhcnRPcGVyYXRpb24odGhpcyk7XFxuICAgICAgdHJ5IHsgcmV0dXJuIGYuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfVxcbiAgICAgIGZpbmFsbHkgeyBlbmRPcGVyYXRpb24odGhpcyk7IH1cXG4gICAgfTtcXG4gIH1cXG4gIGZ1bmN0aW9uIGRvY01ldGhvZE9wKGYpIHtcXG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xcbiAgICAgIHZhciBjbSA9IHRoaXMuY207XFxuICAgICAgaWYgKCFjbSB8fCBjbS5jdXJPcCkgcmV0dXJuIGYuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcXG4gICAgICBzdGFydE9wZXJhdGlvbihjbSk7XFxuICAgICAgdHJ5IHsgcmV0dXJuIGYuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfVxcbiAgICAgIGZpbmFsbHkgeyBlbmRPcGVyYXRpb24oY20pOyB9XFxuICAgIH07XFxuICB9XFxuXFxuICAvLyBWSUVXIFRSQUNLSU5HXFxuXFxuICAvLyBUaGVzZSBvYmplY3RzIGFyZSB1c2VkIHRvIHJlcHJlc2VudCB0aGUgdmlzaWJsZSAoY3VycmVudGx5IGRyYXduKVxcbiAgLy8gcGFydCBvZiB0aGUgZG9jdW1lbnQuIEEgTGluZVZpZXcgbWF5IGNvcnJlc3BvbmQgdG8gbXVsdGlwbGVcXG4gIC8vIGxvZ2ljYWwgbGluZXMsIGlmIHRob3NlIGFyZSBjb25uZWN0ZWQgYnkgY29sbGFwc2VkIHJhbmdlcy5cXG4gIGZ1bmN0aW9uIExpbmVWaWV3KGRvYywgbGluZSwgbGluZU4pIHtcXG4gICAgLy8gVGhlIHN0YXJ0aW5nIGxpbmVcXG4gICAgdGhpcy5saW5lID0gbGluZTtcXG4gICAgLy8gQ29udGludWluZyBsaW5lcywgaWYgYW55XFxuICAgIHRoaXMucmVzdCA9IHZpc3VhbExpbmVDb250aW51ZWQobGluZSk7XFxuICAgIC8vIE51bWJlciBvZiBsb2dpY2FsIGxpbmVzIGluIHRoaXMgdmlzdWFsIGxpbmVcXG4gICAgdGhpcy5zaXplID0gdGhpcy5yZXN0ID8gbGluZU5vKGxzdCh0aGlzLnJlc3QpKSAtIGxpbmVOICsgMSA6IDE7XFxuICAgIHRoaXMubm9kZSA9IHRoaXMudGV4dCA9IG51bGw7XFxuICAgIHRoaXMuaGlkZGVuID0gbGluZUlzSGlkZGVuKGRvYywgbGluZSk7XFxuICB9XFxuXFxuICAvLyBDcmVhdGUgYSByYW5nZSBvZiBMaW5lVmlldyBvYmplY3RzIGZvciB0aGUgZ2l2ZW4gbGluZXMuXFxuICBmdW5jdGlvbiBidWlsZFZpZXdBcnJheShjbSwgZnJvbSwgdG8pIHtcXG4gICAgdmFyIGFycmF5ID0gW10sIG5leHRQb3M7XFxuICAgIGZvciAodmFyIHBvcyA9IGZyb207IHBvcyA8IHRvOyBwb3MgPSBuZXh0UG9zKSB7XFxuICAgICAgdmFyIHZpZXcgPSBuZXcgTGluZVZpZXcoY20uZG9jLCBnZXRMaW5lKGNtLmRvYywgcG9zKSwgcG9zKTtcXG4gICAgICBuZXh0UG9zID0gcG9zICsgdmlldy5zaXplO1xcbiAgICAgIGFycmF5LnB1c2godmlldyk7XFxuICAgIH1cXG4gICAgcmV0dXJuIGFycmF5O1xcbiAgfVxcblxcbiAgLy8gVXBkYXRlcyB0aGUgZGlzcGxheS52aWV3IGRhdGEgc3RydWN0dXJlIGZvciBhIGdpdmVuIGNoYW5nZSB0byB0aGVcXG4gIC8vIGRvY3VtZW50LiBGcm9tIGFuZCB0byBhcmUgaW4gcHJlLWNoYW5nZSBjb29yZGluYXRlcy4gTGVuZGlmZiBpc1xcbiAgLy8gdGhlIGFtb3VudCBvZiBsaW5lcyBhZGRlZCBvciBzdWJ0cmFjdGVkIGJ5IHRoZSBjaGFuZ2UuIFRoaXMgaXNcXG4gIC8vIHVzZWQgZm9yIGNoYW5nZXMgdGhhdCBzcGFuIG11bHRpcGxlIGxpbmVzLCBvciBjaGFuZ2UgdGhlIHdheVxcbiAgLy8gbGluZXMgYXJlIGRpdmlkZWQgaW50byB2aXN1YWwgbGluZXMuIHJlZ0xpbmVDaGFuZ2UgKGJlbG93KVxcbiAgLy8gcmVnaXN0ZXJzIHNpbmdsZS1saW5lIGNoYW5nZXMuXFxuICBmdW5jdGlvbiByZWdDaGFuZ2UoY20sIGZyb20sIHRvLCBsZW5kaWZmKSB7XFxuICAgIGlmIChmcm9tID09IG51bGwpIGZyb20gPSBjbS5kb2MuZmlyc3Q7XFxuICAgIGlmICh0byA9PSBudWxsKSB0byA9IGNtLmRvYy5maXJzdCArIGNtLmRvYy5zaXplO1xcbiAgICBpZiAoIWxlbmRpZmYpIGxlbmRpZmYgPSAwO1xcblxcbiAgICB2YXIgZGlzcGxheSA9IGNtLmRpc3BsYXk7XFxuICAgIGlmIChsZW5kaWZmICYmIHRvIDwgZGlzcGxheS52aWV3VG8gJiZcXG4gICAgICAgIChkaXNwbGF5LnVwZGF0ZUxpbmVOdW1iZXJzID09IG51bGwgfHwgZGlzcGxheS51cGRhdGVMaW5lTnVtYmVycyA+IGZyb20pKVxcbiAgICAgIGRpc3BsYXkudXBkYXRlTGluZU51bWJlcnMgPSBmcm9tO1xcblxcbiAgICBjbS5jdXJPcC52aWV3Q2hhbmdlZCA9IHRydWU7XFxuXFxuICAgIGlmIChmcm9tID49IGRpc3BsYXkudmlld1RvKSB7IC8vIENoYW5nZSBhZnRlclxcbiAgICAgIGlmIChzYXdDb2xsYXBzZWRTcGFucyAmJiB2aXN1YWxMaW5lTm8oY20uZG9jLCBmcm9tKSA8IGRpc3BsYXkudmlld1RvKVxcbiAgICAgICAgcmVzZXRWaWV3KGNtKTtcXG4gICAgfSBlbHNlIGlmICh0byA8PSBkaXNwbGF5LnZpZXdGcm9tKSB7IC8vIENoYW5nZSBiZWZvcmVcXG4gICAgICBpZiAoc2F3Q29sbGFwc2VkU3BhbnMgJiYgdmlzdWFsTGluZUVuZE5vKGNtLmRvYywgdG8gKyBsZW5kaWZmKSA+IGRpc3BsYXkudmlld0Zyb20pIHtcXG4gICAgICAgIHJlc2V0VmlldyhjbSk7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIGRpc3BsYXkudmlld0Zyb20gKz0gbGVuZGlmZjtcXG4gICAgICAgIGRpc3BsYXkudmlld1RvICs9IGxlbmRpZmY7XFxuICAgICAgfVxcbiAgICB9IGVsc2UgaWYgKGZyb20gPD0gZGlzcGxheS52aWV3RnJvbSAmJiB0byA+PSBkaXNwbGF5LnZpZXdUbykgeyAvLyBGdWxsIG92ZXJsYXBcXG4gICAgICByZXNldFZpZXcoY20pO1xcbiAgICB9IGVsc2UgaWYgKGZyb20gPD0gZGlzcGxheS52aWV3RnJvbSkgeyAvLyBUb3Agb3ZlcmxhcFxcbiAgICAgIHZhciBjdXQgPSB2aWV3Q3V0dGluZ1BvaW50KGNtLCB0bywgdG8gKyBsZW5kaWZmLCAxKTtcXG4gICAgICBpZiAoY3V0KSB7XFxuICAgICAgICBkaXNwbGF5LnZpZXcgPSBkaXNwbGF5LnZpZXcuc2xpY2UoY3V0LmluZGV4KTtcXG4gICAgICAgIGRpc3BsYXkudmlld0Zyb20gPSBjdXQubGluZU47XFxuICAgICAgICBkaXNwbGF5LnZpZXdUbyArPSBsZW5kaWZmO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICByZXNldFZpZXcoY20pO1xcbiAgICAgIH1cXG4gICAgfSBlbHNlIGlmICh0byA+PSBkaXNwbGF5LnZpZXdUbykgeyAvLyBCb3R0b20gb3ZlcmxhcFxcbiAgICAgIHZhciBjdXQgPSB2aWV3Q3V0dGluZ1BvaW50KGNtLCBmcm9tLCBmcm9tLCAtMSk7XFxuICAgICAgaWYgKGN1dCkge1xcbiAgICAgICAgZGlzcGxheS52aWV3ID0gZGlzcGxheS52aWV3LnNsaWNlKDAsIGN1dC5pbmRleCk7XFxuICAgICAgICBkaXNwbGF5LnZpZXdUbyA9IGN1dC5saW5lTjtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgcmVzZXRWaWV3KGNtKTtcXG4gICAgICB9XFxuICAgIH0gZWxzZSB7IC8vIEdhcCBpbiB0aGUgbWlkZGxlXFxuICAgICAgdmFyIGN1dFRvcCA9IHZpZXdDdXR0aW5nUG9pbnQoY20sIGZyb20sIGZyb20sIC0xKTtcXG4gICAgICB2YXIgY3V0Qm90ID0gdmlld0N1dHRpbmdQb2ludChjbSwgdG8sIHRvICsgbGVuZGlmZiwgMSk7XFxuICAgICAgaWYgKGN1dFRvcCAmJiBjdXRCb3QpIHtcXG4gICAgICAgIGRpc3BsYXkudmlldyA9IGRpc3BsYXkudmlldy5zbGljZSgwLCBjdXRUb3AuaW5kZXgpXFxuICAgICAgICAgIC5jb25jYXQoYnVpbGRWaWV3QXJyYXkoY20sIGN1dFRvcC5saW5lTiwgY3V0Qm90LmxpbmVOKSlcXG4gICAgICAgICAgLmNvbmNhdChkaXNwbGF5LnZpZXcuc2xpY2UoY3V0Qm90LmluZGV4KSk7XFxuICAgICAgICBkaXNwbGF5LnZpZXdUbyArPSBsZW5kaWZmO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICByZXNldFZpZXcoY20pO1xcbiAgICAgIH1cXG4gICAgfVxcblxcbiAgICB2YXIgZXh0ID0gZGlzcGxheS5leHRlcm5hbE1lYXN1cmVkO1xcbiAgICBpZiAoZXh0KSB7XFxuICAgICAgaWYgKHRvIDwgZXh0LmxpbmVOKVxcbiAgICAgICAgZXh0LmxpbmVOICs9IGxlbmRpZmY7XFxuICAgICAgZWxzZSBpZiAoZnJvbSA8IGV4dC5saW5lTiArIGV4dC5zaXplKVxcbiAgICAgICAgZGlzcGxheS5leHRlcm5hbE1lYXN1cmVkID0gbnVsbDtcXG4gICAgfVxcbiAgfVxcblxcbiAgLy8gUmVnaXN0ZXIgYSBjaGFuZ2UgdG8gYSBzaW5nbGUgbGluZS4gVHlwZSBtdXN0IGJlIG9uZSBvZiBcXFwidGV4dFxcXCIsXFxuICAvLyBcXFwiZ3V0dGVyXFxcIiwgXFxcImNsYXNzXFxcIiwgXFxcIndpZGdldFxcXCJcXG4gIGZ1bmN0aW9uIHJlZ0xpbmVDaGFuZ2UoY20sIGxpbmUsIHR5cGUpIHtcXG4gICAgY20uY3VyT3Audmlld0NoYW5nZWQgPSB0cnVlO1xcbiAgICB2YXIgZGlzcGxheSA9IGNtLmRpc3BsYXksIGV4dCA9IGNtLmRpc3BsYXkuZXh0ZXJuYWxNZWFzdXJlZDtcXG4gICAgaWYgKGV4dCAmJiBsaW5lID49IGV4dC5saW5lTiAmJiBsaW5lIDwgZXh0LmxpbmVOICsgZXh0LnNpemUpXFxuICAgICAgZGlzcGxheS5leHRlcm5hbE1lYXN1cmVkID0gbnVsbDtcXG5cXG4gICAgaWYgKGxpbmUgPCBkaXNwbGF5LnZpZXdGcm9tIHx8IGxpbmUgPj0gZGlzcGxheS52aWV3VG8pIHJldHVybjtcXG4gICAgdmFyIGxpbmVWaWV3ID0gZGlzcGxheS52aWV3W2ZpbmRWaWV3SW5kZXgoY20sIGxpbmUpXTtcXG4gICAgaWYgKGxpbmVWaWV3Lm5vZGUgPT0gbnVsbCkgcmV0dXJuO1xcbiAgICB2YXIgYXJyID0gbGluZVZpZXcuY2hhbmdlcyB8fCAobGluZVZpZXcuY2hhbmdlcyA9IFtdKTtcXG4gICAgaWYgKGluZGV4T2YoYXJyLCB0eXBlKSA9PSAtMSkgYXJyLnB1c2godHlwZSk7XFxuICB9XFxuXFxuICAvLyBDbGVhciB0aGUgdmlldy5cXG4gIGZ1bmN0aW9uIHJlc2V0VmlldyhjbSkge1xcbiAgICBjbS5kaXNwbGF5LnZpZXdGcm9tID0gY20uZGlzcGxheS52aWV3VG8gPSBjbS5kb2MuZmlyc3Q7XFxuICAgIGNtLmRpc3BsYXkudmlldyA9IFtdO1xcbiAgICBjbS5kaXNwbGF5LnZpZXdPZmZzZXQgPSAwO1xcbiAgfVxcblxcbiAgLy8gRmluZCB0aGUgdmlldyBlbGVtZW50IGNvcnJlc3BvbmRpbmcgdG8gYSBnaXZlbiBsaW5lLiBSZXR1cm4gbnVsbFxcbiAgLy8gd2hlbiB0aGUgbGluZSBpc24ndCB2aXNpYmxlLlxcbiAgZnVuY3Rpb24gZmluZFZpZXdJbmRleChjbSwgbikge1xcbiAgICBpZiAobiA+PSBjbS5kaXNwbGF5LnZpZXdUbykgcmV0dXJuIG51bGw7XFxuICAgIG4gLT0gY20uZGlzcGxheS52aWV3RnJvbTtcXG4gICAgaWYgKG4gPCAwKSByZXR1cm4gbnVsbDtcXG4gICAgdmFyIHZpZXcgPSBjbS5kaXNwbGF5LnZpZXc7XFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmlldy5sZW5ndGg7IGkrKykge1xcbiAgICAgIG4gLT0gdmlld1tpXS5zaXplO1xcbiAgICAgIGlmIChuIDwgMCkgcmV0dXJuIGk7XFxuICAgIH1cXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIHZpZXdDdXR0aW5nUG9pbnQoY20sIG9sZE4sIG5ld04sIGRpcikge1xcbiAgICB2YXIgaW5kZXggPSBmaW5kVmlld0luZGV4KGNtLCBvbGROKSwgZGlmZiwgdmlldyA9IGNtLmRpc3BsYXkudmlldztcXG4gICAgaWYgKCFzYXdDb2xsYXBzZWRTcGFucyB8fCBuZXdOID09IGNtLmRvYy5maXJzdCArIGNtLmRvYy5zaXplKVxcbiAgICAgIHJldHVybiB7aW5kZXg6IGluZGV4LCBsaW5lTjogbmV3Tn07XFxuICAgIGZvciAodmFyIGkgPSAwLCBuID0gY20uZGlzcGxheS52aWV3RnJvbTsgaSA8IGluZGV4OyBpKyspXFxuICAgICAgbiArPSB2aWV3W2ldLnNpemU7XFxuICAgIGlmIChuICE9IG9sZE4pIHtcXG4gICAgICBpZiAoZGlyID4gMCkge1xcbiAgICAgICAgaWYgKGluZGV4ID09IHZpZXcubGVuZ3RoIC0gMSkgcmV0dXJuIG51bGw7XFxuICAgICAgICBkaWZmID0gKG4gKyB2aWV3W2luZGV4XS5zaXplKSAtIG9sZE47XFxuICAgICAgICBpbmRleCsrO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBkaWZmID0gbiAtIG9sZE47XFxuICAgICAgfVxcbiAgICAgIG9sZE4gKz0gZGlmZjsgbmV3TiArPSBkaWZmO1xcbiAgICB9XFxuICAgIHdoaWxlICh2aXN1YWxMaW5lTm8oY20uZG9jLCBuZXdOKSAhPSBuZXdOKSB7XFxuICAgICAgaWYgKGluZGV4ID09IChkaXIgPCAwID8gMCA6IHZpZXcubGVuZ3RoIC0gMSkpIHJldHVybiBudWxsO1xcbiAgICAgIG5ld04gKz0gZGlyICogdmlld1tpbmRleCAtIChkaXIgPCAwID8gMSA6IDApXS5zaXplO1xcbiAgICAgIGluZGV4ICs9IGRpcjtcXG4gICAgfVxcbiAgICByZXR1cm4ge2luZGV4OiBpbmRleCwgbGluZU46IG5ld059O1xcbiAgfVxcblxcbiAgLy8gRm9yY2UgdGhlIHZpZXcgdG8gY292ZXIgYSBnaXZlbiByYW5nZSwgYWRkaW5nIGVtcHR5IHZpZXcgZWxlbWVudFxcbiAgLy8gb3IgY2xpcHBpbmcgb2ZmIGV4aXN0aW5nIG9uZXMgYXMgbmVlZGVkLlxcbiAgZnVuY3Rpb24gYWRqdXN0VmlldyhjbSwgZnJvbSwgdG8pIHtcXG4gICAgdmFyIGRpc3BsYXkgPSBjbS5kaXNwbGF5LCB2aWV3ID0gZGlzcGxheS52aWV3O1xcbiAgICBpZiAodmlldy5sZW5ndGggPT0gMCB8fCBmcm9tID49IGRpc3BsYXkudmlld1RvIHx8IHRvIDw9IGRpc3BsYXkudmlld0Zyb20pIHtcXG4gICAgICBkaXNwbGF5LnZpZXcgPSBidWlsZFZpZXdBcnJheShjbSwgZnJvbSwgdG8pO1xcbiAgICAgIGRpc3BsYXkudmlld0Zyb20gPSBmcm9tO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIGlmIChkaXNwbGF5LnZpZXdGcm9tID4gZnJvbSlcXG4gICAgICAgIGRpc3BsYXkudmlldyA9IGJ1aWxkVmlld0FycmF5KGNtLCBmcm9tLCBkaXNwbGF5LnZpZXdGcm9tKS5jb25jYXQoZGlzcGxheS52aWV3KTtcXG4gICAgICBlbHNlIGlmIChkaXNwbGF5LnZpZXdGcm9tIDwgZnJvbSlcXG4gICAgICAgIGRpc3BsYXkudmlldyA9IGRpc3BsYXkudmlldy5zbGljZShmaW5kVmlld0luZGV4KGNtLCBmcm9tKSk7XFxuICAgICAgZGlzcGxheS52aWV3RnJvbSA9IGZyb207XFxuICAgICAgaWYgKGRpc3BsYXkudmlld1RvIDwgdG8pXFxuICAgICAgICBkaXNwbGF5LnZpZXcgPSBkaXNwbGF5LnZpZXcuY29uY2F0KGJ1aWxkVmlld0FycmF5KGNtLCBkaXNwbGF5LnZpZXdUbywgdG8pKTtcXG4gICAgICBlbHNlIGlmIChkaXNwbGF5LnZpZXdUbyA+IHRvKVxcbiAgICAgICAgZGlzcGxheS52aWV3ID0gZGlzcGxheS52aWV3LnNsaWNlKDAsIGZpbmRWaWV3SW5kZXgoY20sIHRvKSk7XFxuICAgIH1cXG4gICAgZGlzcGxheS52aWV3VG8gPSB0bztcXG4gIH1cXG5cXG4gIC8vIENvdW50IHRoZSBudW1iZXIgb2YgbGluZXMgaW4gdGhlIHZpZXcgd2hvc2UgRE9NIHJlcHJlc2VudGF0aW9uIGlzXFxuICAvLyBvdXQgb2YgZGF0ZSAob3Igbm9uZXhpc3RlbnQpLlxcbiAgZnVuY3Rpb24gY291bnREaXJ0eVZpZXcoY20pIHtcXG4gICAgdmFyIHZpZXcgPSBjbS5kaXNwbGF5LnZpZXcsIGRpcnR5ID0gMDtcXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2aWV3Lmxlbmd0aDsgaSsrKSB7XFxuICAgICAgdmFyIGxpbmVWaWV3ID0gdmlld1tpXTtcXG4gICAgICBpZiAoIWxpbmVWaWV3LmhpZGRlbiAmJiAoIWxpbmVWaWV3Lm5vZGUgfHwgbGluZVZpZXcuY2hhbmdlcykpICsrZGlydHk7XFxuICAgIH1cXG4gICAgcmV0dXJuIGRpcnR5O1xcbiAgfVxcblxcbiAgLy8gRVZFTlQgSEFORExFUlNcXG5cXG4gIC8vIEF0dGFjaCB0aGUgbmVjZXNzYXJ5IGV2ZW50IGhhbmRsZXJzIHdoZW4gaW5pdGlhbGl6aW5nIHRoZSBlZGl0b3JcXG4gIGZ1bmN0aW9uIHJlZ2lzdGVyRXZlbnRIYW5kbGVycyhjbSkge1xcbiAgICB2YXIgZCA9IGNtLmRpc3BsYXk7XFxuICAgIG9uKGQuc2Nyb2xsZXIsIFxcXCJtb3VzZWRvd25cXFwiLCBvcGVyYXRpb24oY20sIG9uTW91c2VEb3duKSk7XFxuICAgIC8vIE9sZGVyIElFJ3Mgd2lsbCBub3QgZmlyZSBhIHNlY29uZCBtb3VzZWRvd24gZm9yIGEgZG91YmxlIGNsaWNrXFxuICAgIGlmIChpZSAmJiBpZV92ZXJzaW9uIDwgMTEpXFxuICAgICAgb24oZC5zY3JvbGxlciwgXFxcImRibGNsaWNrXFxcIiwgb3BlcmF0aW9uKGNtLCBmdW5jdGlvbihlKSB7XFxuICAgICAgICBpZiAoc2lnbmFsRE9NRXZlbnQoY20sIGUpKSByZXR1cm47XFxuICAgICAgICB2YXIgcG9zID0gcG9zRnJvbU1vdXNlKGNtLCBlKTtcXG4gICAgICAgIGlmICghcG9zIHx8IGNsaWNrSW5HdXR0ZXIoY20sIGUpIHx8IGV2ZW50SW5XaWRnZXQoY20uZGlzcGxheSwgZSkpIHJldHVybjtcXG4gICAgICAgIGVfcHJldmVudERlZmF1bHQoZSk7XFxuICAgICAgICB2YXIgd29yZCA9IGNtLmZpbmRXb3JkQXQocG9zKTtcXG4gICAgICAgIGV4dGVuZFNlbGVjdGlvbihjbS5kb2MsIHdvcmQuYW5jaG9yLCB3b3JkLmhlYWQpO1xcbiAgICAgIH0pKTtcXG4gICAgZWxzZVxcbiAgICAgIG9uKGQuc2Nyb2xsZXIsIFxcXCJkYmxjbGlja1xcXCIsIGZ1bmN0aW9uKGUpIHsgc2lnbmFsRE9NRXZlbnQoY20sIGUpIHx8IGVfcHJldmVudERlZmF1bHQoZSk7IH0pO1xcbiAgICAvLyBTb21lIGJyb3dzZXJzIGZpcmUgY29udGV4dG1lbnUgKmFmdGVyKiBvcGVuaW5nIHRoZSBtZW51LCBhdFxcbiAgICAvLyB3aGljaCBwb2ludCB3ZSBjYW4ndCBtZXNzIHdpdGggaXQgYW55bW9yZS4gQ29udGV4dCBtZW51IGlzXFxuICAgIC8vIGhhbmRsZWQgaW4gb25Nb3VzZURvd24gZm9yIHRoZXNlIGJyb3dzZXJzLlxcbiAgICBpZiAoIWNhcHR1cmVSaWdodENsaWNrKSBvbihkLnNjcm9sbGVyLCBcXFwiY29udGV4dG1lbnVcXFwiLCBmdW5jdGlvbihlKSB7b25Db250ZXh0TWVudShjbSwgZSk7fSk7XFxuXFxuICAgIC8vIFVzZWQgdG8gc3VwcHJlc3MgbW91c2UgZXZlbnQgaGFuZGxpbmcgd2hlbiBhIHRvdWNoIGhhcHBlbnNcXG4gICAgdmFyIHRvdWNoRmluaXNoZWQsIHByZXZUb3VjaCA9IHtlbmQ6IDB9O1xcbiAgICBmdW5jdGlvbiBmaW5pc2hUb3VjaCgpIHtcXG4gICAgICBpZiAoZC5hY3RpdmVUb3VjaCkge1xcbiAgICAgICAgdG91Y2hGaW5pc2hlZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7ZC5hY3RpdmVUb3VjaCA9IG51bGw7fSwgMTAwMCk7XFxuICAgICAgICBwcmV2VG91Y2ggPSBkLmFjdGl2ZVRvdWNoO1xcbiAgICAgICAgcHJldlRvdWNoLmVuZCA9ICtuZXcgRGF0ZTtcXG4gICAgICB9XFxuICAgIH07XFxuICAgIGZ1bmN0aW9uIGlzTW91c2VMaWtlVG91Y2hFdmVudChlKSB7XFxuICAgICAgaWYgKGUudG91Y2hlcy5sZW5ndGggIT0gMSkgcmV0dXJuIGZhbHNlO1xcbiAgICAgIHZhciB0b3VjaCA9IGUudG91Y2hlc1swXTtcXG4gICAgICByZXR1cm4gdG91Y2gucmFkaXVzWCA8PSAxICYmIHRvdWNoLnJhZGl1c1kgPD0gMTtcXG4gICAgfVxcbiAgICBmdW5jdGlvbiBmYXJBd2F5KHRvdWNoLCBvdGhlcikge1xcbiAgICAgIGlmIChvdGhlci5sZWZ0ID09IG51bGwpIHJldHVybiB0cnVlO1xcbiAgICAgIHZhciBkeCA9IG90aGVyLmxlZnQgLSB0b3VjaC5sZWZ0LCBkeSA9IG90aGVyLnRvcCAtIHRvdWNoLnRvcDtcXG4gICAgICByZXR1cm4gZHggKiBkeCArIGR5ICogZHkgPiAyMCAqIDIwO1xcbiAgICB9XFxuICAgIG9uKGQuc2Nyb2xsZXIsIFxcXCJ0b3VjaHN0YXJ0XFxcIiwgZnVuY3Rpb24oZSkge1xcbiAgICAgIGlmICghc2lnbmFsRE9NRXZlbnQoY20sIGUpICYmICFpc01vdXNlTGlrZVRvdWNoRXZlbnQoZSkpIHtcXG4gICAgICAgIGNsZWFyVGltZW91dCh0b3VjaEZpbmlzaGVkKTtcXG4gICAgICAgIHZhciBub3cgPSArbmV3IERhdGU7XFxuICAgICAgICBkLmFjdGl2ZVRvdWNoID0ge3N0YXJ0OiBub3csIG1vdmVkOiBmYWxzZSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgcHJldjogbm93IC0gcHJldlRvdWNoLmVuZCA8PSAzMDAgPyBwcmV2VG91Y2ggOiBudWxsfTtcXG4gICAgICAgIGlmIChlLnRvdWNoZXMubGVuZ3RoID09IDEpIHtcXG4gICAgICAgICAgZC5hY3RpdmVUb3VjaC5sZWZ0ID0gZS50b3VjaGVzWzBdLnBhZ2VYO1xcbiAgICAgICAgICBkLmFjdGl2ZVRvdWNoLnRvcCA9IGUudG91Y2hlc1swXS5wYWdlWTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIH0pO1xcbiAgICBvbihkLnNjcm9sbGVyLCBcXFwidG91Y2htb3ZlXFxcIiwgZnVuY3Rpb24oKSB7XFxuICAgICAgaWYgKGQuYWN0aXZlVG91Y2gpIGQuYWN0aXZlVG91Y2gubW92ZWQgPSB0cnVlO1xcbiAgICB9KTtcXG4gICAgb24oZC5zY3JvbGxlciwgXFxcInRvdWNoZW5kXFxcIiwgZnVuY3Rpb24oZSkge1xcbiAgICAgIHZhciB0b3VjaCA9IGQuYWN0aXZlVG91Y2g7XFxuICAgICAgaWYgKHRvdWNoICYmICFldmVudEluV2lkZ2V0KGQsIGUpICYmIHRvdWNoLmxlZnQgIT0gbnVsbCAmJlxcbiAgICAgICAgICAhdG91Y2gubW92ZWQgJiYgbmV3IERhdGUgLSB0b3VjaC5zdGFydCA8IDMwMCkge1xcbiAgICAgICAgdmFyIHBvcyA9IGNtLmNvb3Jkc0NoYXIoZC5hY3RpdmVUb3VjaCwgXFxcInBhZ2VcXFwiKSwgcmFuZ2U7XFxuICAgICAgICBpZiAoIXRvdWNoLnByZXYgfHwgZmFyQXdheSh0b3VjaCwgdG91Y2gucHJldikpIC8vIFNpbmdsZSB0YXBcXG4gICAgICAgICAgcmFuZ2UgPSBuZXcgUmFuZ2UocG9zLCBwb3MpO1xcbiAgICAgICAgZWxzZSBpZiAoIXRvdWNoLnByZXYucHJldiB8fCBmYXJBd2F5KHRvdWNoLCB0b3VjaC5wcmV2LnByZXYpKSAvLyBEb3VibGUgdGFwXFxuICAgICAgICAgIHJhbmdlID0gY20uZmluZFdvcmRBdChwb3MpO1xcbiAgICAgICAgZWxzZSAvLyBUcmlwbGUgdGFwXFxuICAgICAgICAgIHJhbmdlID0gbmV3IFJhbmdlKFBvcyhwb3MubGluZSwgMCksIGNsaXBQb3MoY20uZG9jLCBQb3MocG9zLmxpbmUgKyAxLCAwKSkpO1xcbiAgICAgICAgY20uc2V0U2VsZWN0aW9uKHJhbmdlLmFuY2hvciwgcmFuZ2UuaGVhZCk7XFxuICAgICAgICBjbS5mb2N1cygpO1xcbiAgICAgICAgZV9wcmV2ZW50RGVmYXVsdChlKTtcXG4gICAgICB9XFxuICAgICAgZmluaXNoVG91Y2goKTtcXG4gICAgfSk7XFxuICAgIG9uKGQuc2Nyb2xsZXIsIFxcXCJ0b3VjaGNhbmNlbFxcXCIsIGZpbmlzaFRvdWNoKTtcXG5cXG4gICAgLy8gU3luYyBzY3JvbGxpbmcgYmV0d2VlbiBmYWtlIHNjcm9sbGJhcnMgYW5kIHJlYWwgc2Nyb2xsYWJsZVxcbiAgICAvLyBhcmVhLCBlbnN1cmUgdmlld3BvcnQgaXMgdXBkYXRlZCB3aGVuIHNjcm9sbGluZy5cXG4gICAgb24oZC5zY3JvbGxlciwgXFxcInNjcm9sbFxcXCIsIGZ1bmN0aW9uKCkge1xcbiAgICAgIGlmIChkLnNjcm9sbGVyLmNsaWVudEhlaWdodCkge1xcbiAgICAgICAgc2V0U2Nyb2xsVG9wKGNtLCBkLnNjcm9sbGVyLnNjcm9sbFRvcCk7XFxuICAgICAgICBzZXRTY3JvbGxMZWZ0KGNtLCBkLnNjcm9sbGVyLnNjcm9sbExlZnQsIHRydWUpO1xcbiAgICAgICAgc2lnbmFsKGNtLCBcXFwic2Nyb2xsXFxcIiwgY20pO1xcbiAgICAgIH1cXG4gICAgfSk7XFxuXFxuICAgIC8vIExpc3RlbiB0byB3aGVlbCBldmVudHMgaW4gb3JkZXIgdG8gdHJ5IGFuZCB1cGRhdGUgdGhlIHZpZXdwb3J0IG9uIHRpbWUuXFxuICAgIG9uKGQuc2Nyb2xsZXIsIFxcXCJtb3VzZXdoZWVsXFxcIiwgZnVuY3Rpb24oZSl7b25TY3JvbGxXaGVlbChjbSwgZSk7fSk7XFxuICAgIG9uKGQuc2Nyb2xsZXIsIFxcXCJET01Nb3VzZVNjcm9sbFxcXCIsIGZ1bmN0aW9uKGUpe29uU2Nyb2xsV2hlZWwoY20sIGUpO30pO1xcblxcbiAgICAvLyBQcmV2ZW50IHdyYXBwZXIgZnJvbSBldmVyIHNjcm9sbGluZ1xcbiAgICBvbihkLndyYXBwZXIsIFxcXCJzY3JvbGxcXFwiLCBmdW5jdGlvbigpIHsgZC53cmFwcGVyLnNjcm9sbFRvcCA9IGQud3JhcHBlci5zY3JvbGxMZWZ0ID0gMDsgfSk7XFxuXFxuICAgIGQuZHJhZ0Z1bmN0aW9ucyA9IHtcXG4gICAgICBlbnRlcjogZnVuY3Rpb24oZSkge2lmICghc2lnbmFsRE9NRXZlbnQoY20sIGUpKSBlX3N0b3AoZSk7fSxcXG4gICAgICBvdmVyOiBmdW5jdGlvbihlKSB7aWYgKCFzaWduYWxET01FdmVudChjbSwgZSkpIHsgb25EcmFnT3ZlcihjbSwgZSk7IGVfc3RvcChlKTsgfX0sXFxuICAgICAgc3RhcnQ6IGZ1bmN0aW9uKGUpe29uRHJhZ1N0YXJ0KGNtLCBlKTt9LFxcbiAgICAgIGRyb3A6IG9wZXJhdGlvbihjbSwgb25Ecm9wKSxcXG4gICAgICBsZWF2ZTogZnVuY3Rpb24oZSkge2lmICghc2lnbmFsRE9NRXZlbnQoY20sIGUpKSB7IGNsZWFyRHJhZ0N1cnNvcihjbSk7IH19XFxuICAgIH07XFxuXFxuICAgIHZhciBpbnAgPSBkLmlucHV0LmdldEZpZWxkKCk7XFxuICAgIG9uKGlucCwgXFxcImtleXVwXFxcIiwgZnVuY3Rpb24oZSkgeyBvbktleVVwLmNhbGwoY20sIGUpOyB9KTtcXG4gICAgb24oaW5wLCBcXFwia2V5ZG93blxcXCIsIG9wZXJhdGlvbihjbSwgb25LZXlEb3duKSk7XFxuICAgIG9uKGlucCwgXFxcImtleXByZXNzXFxcIiwgb3BlcmF0aW9uKGNtLCBvbktleVByZXNzKSk7XFxuICAgIG9uKGlucCwgXFxcImZvY3VzXFxcIiwgZnVuY3Rpb24gKGUpIHsgb25Gb2N1cyhjbSwgZSk7IH0pO1xcbiAgICBvbihpbnAsIFxcXCJibHVyXFxcIiwgZnVuY3Rpb24gKGUpIHsgb25CbHVyKGNtLCBlKTsgfSk7XFxuICB9XFxuXFxuICBmdW5jdGlvbiBkcmFnRHJvcENoYW5nZWQoY20sIHZhbHVlLCBvbGQpIHtcXG4gICAgdmFyIHdhc09uID0gb2xkICYmIG9sZCAhPSBDb2RlTWlycm9yLkluaXQ7XFxuICAgIGlmICghdmFsdWUgIT0gIXdhc09uKSB7XFxuICAgICAgdmFyIGZ1bmNzID0gY20uZGlzcGxheS5kcmFnRnVuY3Rpb25zO1xcbiAgICAgIHZhciB0b2dnbGUgPSB2YWx1ZSA/IG9uIDogb2ZmO1xcbiAgICAgIHRvZ2dsZShjbS5kaXNwbGF5LnNjcm9sbGVyLCBcXFwiZHJhZ3N0YXJ0XFxcIiwgZnVuY3Muc3RhcnQpO1xcbiAgICAgIHRvZ2dsZShjbS5kaXNwbGF5LnNjcm9sbGVyLCBcXFwiZHJhZ2VudGVyXFxcIiwgZnVuY3MuZW50ZXIpO1xcbiAgICAgIHRvZ2dsZShjbS5kaXNwbGF5LnNjcm9sbGVyLCBcXFwiZHJhZ292ZXJcXFwiLCBmdW5jcy5vdmVyKTtcXG4gICAgICB0b2dnbGUoY20uZGlzcGxheS5zY3JvbGxlciwgXFxcImRyYWdsZWF2ZVxcXCIsIGZ1bmNzLmxlYXZlKTtcXG4gICAgICB0b2dnbGUoY20uZGlzcGxheS5zY3JvbGxlciwgXFxcImRyb3BcXFwiLCBmdW5jcy5kcm9wKTtcXG4gICAgfVxcbiAgfVxcblxcbiAgLy8gQ2FsbGVkIHdoZW4gdGhlIHdpbmRvdyByZXNpemVzXFxuICBmdW5jdGlvbiBvblJlc2l6ZShjbSkge1xcbiAgICB2YXIgZCA9IGNtLmRpc3BsYXk7XFxuICAgIGlmIChkLmxhc3RXcmFwSGVpZ2h0ID09IGQud3JhcHBlci5jbGllbnRIZWlnaHQgJiYgZC5sYXN0V3JhcFdpZHRoID09IGQud3JhcHBlci5jbGllbnRXaWR0aClcXG4gICAgICByZXR1cm47XFxuICAgIC8vIE1pZ2h0IGJlIGEgdGV4dCBzY2FsaW5nIG9wZXJhdGlvbiwgY2xlYXIgc2l6ZSBjYWNoZXMuXFxuICAgIGQuY2FjaGVkQ2hhcldpZHRoID0gZC5jYWNoZWRUZXh0SGVpZ2h0ID0gZC5jYWNoZWRQYWRkaW5nSCA9IG51bGw7XFxuICAgIGQuc2Nyb2xsYmFyc0NsaXBwZWQgPSBmYWxzZTtcXG4gICAgY20uc2V0U2l6ZSgpO1xcbiAgfVxcblxcbiAgLy8gTU9VU0UgRVZFTlRTXFxuXFxuICAvLyBSZXR1cm4gdHJ1ZSB3aGVuIHRoZSBnaXZlbiBtb3VzZSBldmVudCBoYXBwZW5lZCBpbiBhIHdpZGdldFxcbiAgZnVuY3Rpb24gZXZlbnRJbldpZGdldChkaXNwbGF5LCBlKSB7XFxuICAgIGZvciAodmFyIG4gPSBlX3RhcmdldChlKTsgbiAhPSBkaXNwbGF5LndyYXBwZXI7IG4gPSBuLnBhcmVudE5vZGUpIHtcXG4gICAgICBpZiAoIW4gfHwgKG4ubm9kZVR5cGUgPT0gMSAmJiBuLmdldEF0dHJpYnV0ZShcXFwiY20taWdub3JlLWV2ZW50c1xcXCIpID09IFxcXCJ0cnVlXFxcIikgfHxcXG4gICAgICAgICAgKG4ucGFyZW50Tm9kZSA9PSBkaXNwbGF5LnNpemVyICYmIG4gIT0gZGlzcGxheS5tb3ZlcikpXFxuICAgICAgICByZXR1cm4gdHJ1ZTtcXG4gICAgfVxcbiAgfVxcblxcbiAgLy8gR2l2ZW4gYSBtb3VzZSBldmVudCwgZmluZCB0aGUgY29ycmVzcG9uZGluZyBwb3NpdGlvbi4gSWYgbGliZXJhbFxcbiAgLy8gaXMgZmFsc2UsIGl0IGNoZWNrcyB3aGV0aGVyIGEgZ3V0dGVyIG9yIHNjcm9sbGJhciB3YXMgY2xpY2tlZCxcXG4gIC8vIGFuZCByZXR1cm5zIG51bGwgaWYgaXQgd2FzLiBmb3JSZWN0IGlzIHVzZWQgYnkgcmVjdGFuZ3VsYXJcXG4gIC8vIHNlbGVjdGlvbnMsIGFuZCB0cmllcyB0byBlc3RpbWF0ZSBhIGNoYXJhY3RlciBwb3NpdGlvbiBldmVuIGZvclxcbiAgLy8gY29vcmRpbmF0ZXMgYmV5b25kIHRoZSByaWdodCBvZiB0aGUgdGV4dC5cXG4gIGZ1bmN0aW9uIHBvc0Zyb21Nb3VzZShjbSwgZSwgbGliZXJhbCwgZm9yUmVjdCkge1xcbiAgICB2YXIgZGlzcGxheSA9IGNtLmRpc3BsYXk7XFxuICAgIGlmICghbGliZXJhbCAmJiBlX3RhcmdldChlKS5nZXRBdHRyaWJ1dGUoXFxcImNtLW5vdC1jb250ZW50XFxcIikgPT0gXFxcInRydWVcXFwiKSByZXR1cm4gbnVsbDtcXG5cXG4gICAgdmFyIHgsIHksIHNwYWNlID0gZGlzcGxheS5saW5lU3BhY2UuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XFxuICAgIC8vIEZhaWxzIHVucHJlZGljdGFibHkgb24gSUVbNjddIHdoZW4gbW91c2UgaXMgZHJhZ2dlZCBhcm91bmQgcXVpY2tseS5cXG4gICAgdHJ5IHsgeCA9IGUuY2xpZW50WCAtIHNwYWNlLmxlZnQ7IHkgPSBlLmNsaWVudFkgLSBzcGFjZS50b3A7IH1cXG4gICAgY2F0Y2ggKGUpIHsgcmV0dXJuIG51bGw7IH1cXG4gICAgdmFyIGNvb3JkcyA9IGNvb3Jkc0NoYXIoY20sIHgsIHkpLCBsaW5lO1xcbiAgICBpZiAoZm9yUmVjdCAmJiBjb29yZHMueFJlbCA9PSAxICYmIChsaW5lID0gZ2V0TGluZShjbS5kb2MsIGNvb3Jkcy5saW5lKS50ZXh0KS5sZW5ndGggPT0gY29vcmRzLmNoKSB7XFxuICAgICAgdmFyIGNvbERpZmYgPSBjb3VudENvbHVtbihsaW5lLCBsaW5lLmxlbmd0aCwgY20ub3B0aW9ucy50YWJTaXplKSAtIGxpbmUubGVuZ3RoO1xcbiAgICAgIGNvb3JkcyA9IFBvcyhjb29yZHMubGluZSwgTWF0aC5tYXgoMCwgTWF0aC5yb3VuZCgoeCAtIHBhZGRpbmdIKGNtLmRpc3BsYXkpLmxlZnQpIC8gY2hhcldpZHRoKGNtLmRpc3BsYXkpKSAtIGNvbERpZmYpKTtcXG4gICAgfVxcbiAgICByZXR1cm4gY29vcmRzO1xcbiAgfVxcblxcbiAgLy8gQSBtb3VzZSBkb3duIGNhbiBiZSBhIHNpbmdsZSBjbGljaywgZG91YmxlIGNsaWNrLCB0cmlwbGUgY2xpY2ssXFxuICAvLyBzdGFydCBvZiBzZWxlY3Rpb24gZHJhZywgc3RhcnQgb2YgdGV4dCBkcmFnLCBuZXcgY3Vyc29yXFxuICAvLyAoY3RybC1jbGljayksIHJlY3RhbmdsZSBkcmFnIChhbHQtZHJhZyksIG9yIHh3aW5cXG4gIC8vIG1pZGRsZS1jbGljay1wYXN0ZS4gT3IgaXQgbWlnaHQgYmUgYSBjbGljayBvbiBzb21ldGhpbmcgd2Ugc2hvdWxkXFxuICAvLyBub3QgaW50ZXJmZXJlIHdpdGgsIHN1Y2ggYXMgYSBzY3JvbGxiYXIgb3Igd2lkZ2V0LlxcbiAgZnVuY3Rpb24gb25Nb3VzZURvd24oZSkge1xcbiAgICB2YXIgY20gPSB0aGlzLCBkaXNwbGF5ID0gY20uZGlzcGxheTtcXG4gICAgaWYgKHNpZ25hbERPTUV2ZW50KGNtLCBlKSB8fCBkaXNwbGF5LmFjdGl2ZVRvdWNoICYmIGRpc3BsYXkuaW5wdXQuc3VwcG9ydHNUb3VjaCgpKSByZXR1cm47XFxuICAgIGRpc3BsYXkuc2hpZnQgPSBlLnNoaWZ0S2V5O1xcblxcbiAgICBpZiAoZXZlbnRJbldpZGdldChkaXNwbGF5LCBlKSkge1xcbiAgICAgIGlmICghd2Via2l0KSB7XFxuICAgICAgICAvLyBCcmllZmx5IHR1cm4gb2ZmIGRyYWdnYWJpbGl0eSwgdG8gYWxsb3cgd2lkZ2V0cyB0byBkb1xcbiAgICAgICAgLy8gbm9ybWFsIGRyYWdnaW5nIHRoaW5ncy5cXG4gICAgICAgIGRpc3BsYXkuc2Nyb2xsZXIuZHJhZ2dhYmxlID0gZmFsc2U7XFxuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7ZGlzcGxheS5zY3JvbGxlci5kcmFnZ2FibGUgPSB0cnVlO30sIDEwMCk7XFxuICAgICAgfVxcbiAgICAgIHJldHVybjtcXG4gICAgfVxcbiAgICBpZiAoY2xpY2tJbkd1dHRlcihjbSwgZSkpIHJldHVybjtcXG4gICAgdmFyIHN0YXJ0ID0gcG9zRnJvbU1vdXNlKGNtLCBlKTtcXG4gICAgd2luZG93LmZvY3VzKCk7XFxuXFxuICAgIHN3aXRjaCAoZV9idXR0b24oZSkpIHtcXG4gICAgY2FzZSAxOlxcbiAgICAgIC8vICMzMjYxOiBtYWtlIHN1cmUsIHRoYXQgd2UncmUgbm90IHN0YXJ0aW5nIGEgc2Vjb25kIHNlbGVjdGlvblxcbiAgICAgIGlmIChjbS5zdGF0ZS5zZWxlY3RpbmdUZXh0KVxcbiAgICAgICAgY20uc3RhdGUuc2VsZWN0aW5nVGV4dChlKTtcXG4gICAgICBlbHNlIGlmIChzdGFydClcXG4gICAgICAgIGxlZnRCdXR0b25Eb3duKGNtLCBlLCBzdGFydCk7XFxuICAgICAgZWxzZSBpZiAoZV90YXJnZXQoZSkgPT0gZGlzcGxheS5zY3JvbGxlcilcXG4gICAgICAgIGVfcHJldmVudERlZmF1bHQoZSk7XFxuICAgICAgYnJlYWs7XFxuICAgIGNhc2UgMjpcXG4gICAgICBpZiAod2Via2l0KSBjbS5zdGF0ZS5sYXN0TWlkZGxlRG93biA9ICtuZXcgRGF0ZTtcXG4gICAgICBpZiAoc3RhcnQpIGV4dGVuZFNlbGVjdGlvbihjbS5kb2MsIHN0YXJ0KTtcXG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge2Rpc3BsYXkuaW5wdXQuZm9jdXMoKTt9LCAyMCk7XFxuICAgICAgZV9wcmV2ZW50RGVmYXVsdChlKTtcXG4gICAgICBicmVhaztcXG4gICAgY2FzZSAzOlxcbiAgICAgIGlmIChjYXB0dXJlUmlnaHRDbGljaykgb25Db250ZXh0TWVudShjbSwgZSk7XFxuICAgICAgZWxzZSBkZWxheUJsdXJFdmVudChjbSk7XFxuICAgICAgYnJlYWs7XFxuICAgIH1cXG4gIH1cXG5cXG4gIHZhciBsYXN0Q2xpY2ssIGxhc3REb3VibGVDbGljaztcXG4gIGZ1bmN0aW9uIGxlZnRCdXR0b25Eb3duKGNtLCBlLCBzdGFydCkge1xcbiAgICBpZiAoaWUpIHNldFRpbWVvdXQoYmluZChlbnN1cmVGb2N1cywgY20pLCAwKTtcXG4gICAgZWxzZSBjbS5jdXJPcC5mb2N1cyA9IGFjdGl2ZUVsdCgpO1xcblxcbiAgICB2YXIgbm93ID0gK25ldyBEYXRlLCB0eXBlO1xcbiAgICBpZiAobGFzdERvdWJsZUNsaWNrICYmIGxhc3REb3VibGVDbGljay50aW1lID4gbm93IC0gNDAwICYmIGNtcChsYXN0RG91YmxlQ2xpY2sucG9zLCBzdGFydCkgPT0gMCkge1xcbiAgICAgIHR5cGUgPSBcXFwidHJpcGxlXFxcIjtcXG4gICAgfSBlbHNlIGlmIChsYXN0Q2xpY2sgJiYgbGFzdENsaWNrLnRpbWUgPiBub3cgLSA0MDAgJiYgY21wKGxhc3RDbGljay5wb3MsIHN0YXJ0KSA9PSAwKSB7XFxuICAgICAgdHlwZSA9IFxcXCJkb3VibGVcXFwiO1xcbiAgICAgIGxhc3REb3VibGVDbGljayA9IHt0aW1lOiBub3csIHBvczogc3RhcnR9O1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIHR5cGUgPSBcXFwic2luZ2xlXFxcIjtcXG4gICAgICBsYXN0Q2xpY2sgPSB7dGltZTogbm93LCBwb3M6IHN0YXJ0fTtcXG4gICAgfVxcblxcbiAgICB2YXIgc2VsID0gY20uZG9jLnNlbCwgbW9kaWZpZXIgPSBtYWMgPyBlLm1ldGFLZXkgOiBlLmN0cmxLZXksIGNvbnRhaW5lZDtcXG4gICAgaWYgKGNtLm9wdGlvbnMuZHJhZ0Ryb3AgJiYgZHJhZ0FuZERyb3AgJiYgIWNtLmlzUmVhZE9ubHkoKSAmJlxcbiAgICAgICAgdHlwZSA9PSBcXFwic2luZ2xlXFxcIiAmJiAoY29udGFpbmVkID0gc2VsLmNvbnRhaW5zKHN0YXJ0KSkgPiAtMSAmJlxcbiAgICAgICAgKGNtcCgoY29udGFpbmVkID0gc2VsLnJhbmdlc1tjb250YWluZWRdKS5mcm9tKCksIHN0YXJ0KSA8IDAgfHwgc3RhcnQueFJlbCA+IDApICYmXFxuICAgICAgICAoY21wKGNvbnRhaW5lZC50bygpLCBzdGFydCkgPiAwIHx8IHN0YXJ0LnhSZWwgPCAwKSlcXG4gICAgICBsZWZ0QnV0dG9uU3RhcnREcmFnKGNtLCBlLCBzdGFydCwgbW9kaWZpZXIpO1xcbiAgICBlbHNlXFxuICAgICAgbGVmdEJ1dHRvblNlbGVjdChjbSwgZSwgc3RhcnQsIHR5cGUsIG1vZGlmaWVyKTtcXG4gIH1cXG5cXG4gIC8vIFN0YXJ0IGEgdGV4dCBkcmFnLiBXaGVuIGl0IGVuZHMsIHNlZSBpZiBhbnkgZHJhZ2dpbmcgYWN0dWFsbHlcXG4gIC8vIGhhcHBlbiwgYW5kIHRyZWF0IGFzIGEgY2xpY2sgaWYgaXQgZGlkbid0LlxcbiAgZnVuY3Rpb24gbGVmdEJ1dHRvblN0YXJ0RHJhZyhjbSwgZSwgc3RhcnQsIG1vZGlmaWVyKSB7XFxuICAgIHZhciBkaXNwbGF5ID0gY20uZGlzcGxheSwgc3RhcnRUaW1lID0gK25ldyBEYXRlO1xcbiAgICB2YXIgZHJhZ0VuZCA9IG9wZXJhdGlvbihjbSwgZnVuY3Rpb24oZTIpIHtcXG4gICAgICBpZiAod2Via2l0KSBkaXNwbGF5LnNjcm9sbGVyLmRyYWdnYWJsZSA9IGZhbHNlO1xcbiAgICAgIGNtLnN0YXRlLmRyYWdnaW5nVGV4dCA9IGZhbHNlO1xcbiAgICAgIG9mZihkb2N1bWVudCwgXFxcIm1vdXNldXBcXFwiLCBkcmFnRW5kKTtcXG4gICAgICBvZmYoZGlzcGxheS5zY3JvbGxlciwgXFxcImRyb3BcXFwiLCBkcmFnRW5kKTtcXG4gICAgICBpZiAoTWF0aC5hYnMoZS5jbGllbnRYIC0gZTIuY2xpZW50WCkgKyBNYXRoLmFicyhlLmNsaWVudFkgLSBlMi5jbGllbnRZKSA8IDEwKSB7XFxuICAgICAgICBlX3ByZXZlbnREZWZhdWx0KGUyKTtcXG4gICAgICAgIGlmICghbW9kaWZpZXIgJiYgK25ldyBEYXRlIC0gMjAwIDwgc3RhcnRUaW1lKVxcbiAgICAgICAgICBleHRlbmRTZWxlY3Rpb24oY20uZG9jLCBzdGFydCk7XFxuICAgICAgICAvLyBXb3JrIGFyb3VuZCB1bmV4cGxhaW5hYmxlIGZvY3VzIHByb2JsZW0gaW4gSUU5ICgjMjEyNykgYW5kIENocm9tZSAoIzMwODEpXFxuICAgICAgICBpZiAod2Via2l0IHx8IGllICYmIGllX3ZlcnNpb24gPT0gOSlcXG4gICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtkb2N1bWVudC5ib2R5LmZvY3VzKCk7IGRpc3BsYXkuaW5wdXQuZm9jdXMoKTt9LCAyMCk7XFxuICAgICAgICBlbHNlXFxuICAgICAgICAgIGRpc3BsYXkuaW5wdXQuZm9jdXMoKTtcXG4gICAgICB9XFxuICAgIH0pO1xcbiAgICAvLyBMZXQgdGhlIGRyYWcgaGFuZGxlciBoYW5kbGUgdGhpcy5cXG4gICAgaWYgKHdlYmtpdCkgZGlzcGxheS5zY3JvbGxlci5kcmFnZ2FibGUgPSB0cnVlO1xcbiAgICBjbS5zdGF0ZS5kcmFnZ2luZ1RleHQgPSBkcmFnRW5kO1xcbiAgICBkcmFnRW5kLmNvcHkgPSBtYWMgPyBlLmFsdEtleSA6IGUuY3RybEtleVxcbiAgICAvLyBJRSdzIGFwcHJvYWNoIHRvIGRyYWdnYWJsZVxcbiAgICBpZiAoZGlzcGxheS5zY3JvbGxlci5kcmFnRHJvcCkgZGlzcGxheS5zY3JvbGxlci5kcmFnRHJvcCgpO1xcbiAgICBvbihkb2N1bWVudCwgXFxcIm1vdXNldXBcXFwiLCBkcmFnRW5kKTtcXG4gICAgb24oZGlzcGxheS5zY3JvbGxlciwgXFxcImRyb3BcXFwiLCBkcmFnRW5kKTtcXG4gIH1cXG5cXG4gIC8vIE5vcm1hbCBzZWxlY3Rpb24sIGFzIG9wcG9zZWQgdG8gdGV4dCBkcmFnZ2luZy5cXG4gIGZ1bmN0aW9uIGxlZnRCdXR0b25TZWxlY3QoY20sIGUsIHN0YXJ0LCB0eXBlLCBhZGROZXcpIHtcXG4gICAgdmFyIGRpc3BsYXkgPSBjbS5kaXNwbGF5LCBkb2MgPSBjbS5kb2M7XFxuICAgIGVfcHJldmVudERlZmF1bHQoZSk7XFxuXFxuICAgIHZhciBvdXJSYW5nZSwgb3VySW5kZXgsIHN0YXJ0U2VsID0gZG9jLnNlbCwgcmFuZ2VzID0gc3RhcnRTZWwucmFuZ2VzO1xcbiAgICBpZiAoYWRkTmV3ICYmICFlLnNoaWZ0S2V5KSB7XFxuICAgICAgb3VySW5kZXggPSBkb2Muc2VsLmNvbnRhaW5zKHN0YXJ0KTtcXG4gICAgICBpZiAob3VySW5kZXggPiAtMSlcXG4gICAgICAgIG91clJhbmdlID0gcmFuZ2VzW291ckluZGV4XTtcXG4gICAgICBlbHNlXFxuICAgICAgICBvdXJSYW5nZSA9IG5ldyBSYW5nZShzdGFydCwgc3RhcnQpO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIG91clJhbmdlID0gZG9jLnNlbC5wcmltYXJ5KCk7XFxuICAgICAgb3VySW5kZXggPSBkb2Muc2VsLnByaW1JbmRleDtcXG4gICAgfVxcblxcbiAgICBpZiAoY2hyb21lT1MgPyBlLnNoaWZ0S2V5ICYmIGUubWV0YUtleSA6IGUuYWx0S2V5KSB7XFxuICAgICAgdHlwZSA9IFxcXCJyZWN0XFxcIjtcXG4gICAgICBpZiAoIWFkZE5ldykgb3VyUmFuZ2UgPSBuZXcgUmFuZ2Uoc3RhcnQsIHN0YXJ0KTtcXG4gICAgICBzdGFydCA9IHBvc0Zyb21Nb3VzZShjbSwgZSwgdHJ1ZSwgdHJ1ZSk7XFxuICAgICAgb3VySW5kZXggPSAtMTtcXG4gICAgfSBlbHNlIGlmICh0eXBlID09IFxcXCJkb3VibGVcXFwiKSB7XFxuICAgICAgdmFyIHdvcmQgPSBjbS5maW5kV29yZEF0KHN0YXJ0KTtcXG4gICAgICBpZiAoY20uZGlzcGxheS5zaGlmdCB8fCBkb2MuZXh0ZW5kKVxcbiAgICAgICAgb3VyUmFuZ2UgPSBleHRlbmRSYW5nZShkb2MsIG91clJhbmdlLCB3b3JkLmFuY2hvciwgd29yZC5oZWFkKTtcXG4gICAgICBlbHNlXFxuICAgICAgICBvdXJSYW5nZSA9IHdvcmQ7XFxuICAgIH0gZWxzZSBpZiAodHlwZSA9PSBcXFwidHJpcGxlXFxcIikge1xcbiAgICAgIHZhciBsaW5lID0gbmV3IFJhbmdlKFBvcyhzdGFydC5saW5lLCAwKSwgY2xpcFBvcyhkb2MsIFBvcyhzdGFydC5saW5lICsgMSwgMCkpKTtcXG4gICAgICBpZiAoY20uZGlzcGxheS5zaGlmdCB8fCBkb2MuZXh0ZW5kKVxcbiAgICAgICAgb3VyUmFuZ2UgPSBleHRlbmRSYW5nZShkb2MsIG91clJhbmdlLCBsaW5lLmFuY2hvciwgbGluZS5oZWFkKTtcXG4gICAgICBlbHNlXFxuICAgICAgICBvdXJSYW5nZSA9IGxpbmU7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgb3VyUmFuZ2UgPSBleHRlbmRSYW5nZShkb2MsIG91clJhbmdlLCBzdGFydCk7XFxuICAgIH1cXG5cXG4gICAgaWYgKCFhZGROZXcpIHtcXG4gICAgICBvdXJJbmRleCA9IDA7XFxuICAgICAgc2V0U2VsZWN0aW9uKGRvYywgbmV3IFNlbGVjdGlvbihbb3VyUmFuZ2VdLCAwKSwgc2VsX21vdXNlKTtcXG4gICAgICBzdGFydFNlbCA9IGRvYy5zZWw7XFxuICAgIH0gZWxzZSBpZiAob3VySW5kZXggPT0gLTEpIHtcXG4gICAgICBvdXJJbmRleCA9IHJhbmdlcy5sZW5ndGg7XFxuICAgICAgc2V0U2VsZWN0aW9uKGRvYywgbm9ybWFsaXplU2VsZWN0aW9uKHJhbmdlcy5jb25jYXQoW291clJhbmdlXSksIG91ckluZGV4KSxcXG4gICAgICAgICAgICAgICAgICAge3Njcm9sbDogZmFsc2UsIG9yaWdpbjogXFxcIiptb3VzZVxcXCJ9KTtcXG4gICAgfSBlbHNlIGlmIChyYW5nZXMubGVuZ3RoID4gMSAmJiByYW5nZXNbb3VySW5kZXhdLmVtcHR5KCkgJiYgdHlwZSA9PSBcXFwic2luZ2xlXFxcIiAmJiAhZS5zaGlmdEtleSkge1xcbiAgICAgIHNldFNlbGVjdGlvbihkb2MsIG5vcm1hbGl6ZVNlbGVjdGlvbihyYW5nZXMuc2xpY2UoMCwgb3VySW5kZXgpLmNvbmNhdChyYW5nZXMuc2xpY2Uob3VySW5kZXggKyAxKSksIDApLFxcbiAgICAgICAgICAgICAgICAgICB7c2Nyb2xsOiBmYWxzZSwgb3JpZ2luOiBcXFwiKm1vdXNlXFxcIn0pO1xcbiAgICAgIHN0YXJ0U2VsID0gZG9jLnNlbDtcXG4gICAgfSBlbHNlIHtcXG4gICAgICByZXBsYWNlT25lU2VsZWN0aW9uKGRvYywgb3VySW5kZXgsIG91clJhbmdlLCBzZWxfbW91c2UpO1xcbiAgICB9XFxuXFxuICAgIHZhciBsYXN0UG9zID0gc3RhcnQ7XFxuICAgIGZ1bmN0aW9uIGV4dGVuZFRvKHBvcykge1xcbiAgICAgIGlmIChjbXAobGFzdFBvcywgcG9zKSA9PSAwKSByZXR1cm47XFxuICAgICAgbGFzdFBvcyA9IHBvcztcXG5cXG4gICAgICBpZiAodHlwZSA9PSBcXFwicmVjdFxcXCIpIHtcXG4gICAgICAgIHZhciByYW5nZXMgPSBbXSwgdGFiU2l6ZSA9IGNtLm9wdGlvbnMudGFiU2l6ZTtcXG4gICAgICAgIHZhciBzdGFydENvbCA9IGNvdW50Q29sdW1uKGdldExpbmUoZG9jLCBzdGFydC5saW5lKS50ZXh0LCBzdGFydC5jaCwgdGFiU2l6ZSk7XFxuICAgICAgICB2YXIgcG9zQ29sID0gY291bnRDb2x1bW4oZ2V0TGluZShkb2MsIHBvcy5saW5lKS50ZXh0LCBwb3MuY2gsIHRhYlNpemUpO1xcbiAgICAgICAgdmFyIGxlZnQgPSBNYXRoLm1pbihzdGFydENvbCwgcG9zQ29sKSwgcmlnaHQgPSBNYXRoLm1heChzdGFydENvbCwgcG9zQ29sKTtcXG4gICAgICAgIGZvciAodmFyIGxpbmUgPSBNYXRoLm1pbihzdGFydC5saW5lLCBwb3MubGluZSksIGVuZCA9IE1hdGgubWluKGNtLmxhc3RMaW5lKCksIE1hdGgubWF4KHN0YXJ0LmxpbmUsIHBvcy5saW5lKSk7XFxuICAgICAgICAgICAgIGxpbmUgPD0gZW5kOyBsaW5lKyspIHtcXG4gICAgICAgICAgdmFyIHRleHQgPSBnZXRMaW5lKGRvYywgbGluZSkudGV4dCwgbGVmdFBvcyA9IGZpbmRDb2x1bW4odGV4dCwgbGVmdCwgdGFiU2l6ZSk7XFxuICAgICAgICAgIGlmIChsZWZ0ID09IHJpZ2h0KVxcbiAgICAgICAgICAgIHJhbmdlcy5wdXNoKG5ldyBSYW5nZShQb3MobGluZSwgbGVmdFBvcyksIFBvcyhsaW5lLCBsZWZ0UG9zKSkpO1xcbiAgICAgICAgICBlbHNlIGlmICh0ZXh0Lmxlbmd0aCA+IGxlZnRQb3MpXFxuICAgICAgICAgICAgcmFuZ2VzLnB1c2gobmV3IFJhbmdlKFBvcyhsaW5lLCBsZWZ0UG9zKSwgUG9zKGxpbmUsIGZpbmRDb2x1bW4odGV4dCwgcmlnaHQsIHRhYlNpemUpKSkpO1xcbiAgICAgICAgfVxcbiAgICAgICAgaWYgKCFyYW5nZXMubGVuZ3RoKSByYW5nZXMucHVzaChuZXcgUmFuZ2Uoc3RhcnQsIHN0YXJ0KSk7XFxuICAgICAgICBzZXRTZWxlY3Rpb24oZG9jLCBub3JtYWxpemVTZWxlY3Rpb24oc3RhcnRTZWwucmFuZ2VzLnNsaWNlKDAsIG91ckluZGV4KS5jb25jYXQocmFuZ2VzKSwgb3VySW5kZXgpLFxcbiAgICAgICAgICAgICAgICAgICAgIHtvcmlnaW46IFxcXCIqbW91c2VcXFwiLCBzY3JvbGw6IGZhbHNlfSk7XFxuICAgICAgICBjbS5zY3JvbGxJbnRvVmlldyhwb3MpO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICB2YXIgb2xkUmFuZ2UgPSBvdXJSYW5nZTtcXG4gICAgICAgIHZhciBhbmNob3IgPSBvbGRSYW5nZS5hbmNob3IsIGhlYWQgPSBwb3M7XFxuICAgICAgICBpZiAodHlwZSAhPSBcXFwic2luZ2xlXFxcIikge1xcbiAgICAgICAgICBpZiAodHlwZSA9PSBcXFwiZG91YmxlXFxcIilcXG4gICAgICAgICAgICB2YXIgcmFuZ2UgPSBjbS5maW5kV29yZEF0KHBvcyk7XFxuICAgICAgICAgIGVsc2VcXG4gICAgICAgICAgICB2YXIgcmFuZ2UgPSBuZXcgUmFuZ2UoUG9zKHBvcy5saW5lLCAwKSwgY2xpcFBvcyhkb2MsIFBvcyhwb3MubGluZSArIDEsIDApKSk7XFxuICAgICAgICAgIGlmIChjbXAocmFuZ2UuYW5jaG9yLCBhbmNob3IpID4gMCkge1xcbiAgICAgICAgICAgIGhlYWQgPSByYW5nZS5oZWFkO1xcbiAgICAgICAgICAgIGFuY2hvciA9IG1pblBvcyhvbGRSYW5nZS5mcm9tKCksIHJhbmdlLmFuY2hvcik7XFxuICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgaGVhZCA9IHJhbmdlLmFuY2hvcjtcXG4gICAgICAgICAgICBhbmNob3IgPSBtYXhQb3Mob2xkUmFuZ2UudG8oKSwgcmFuZ2UuaGVhZCk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIHZhciByYW5nZXMgPSBzdGFydFNlbC5yYW5nZXMuc2xpY2UoMCk7XFxuICAgICAgICByYW5nZXNbb3VySW5kZXhdID0gbmV3IFJhbmdlKGNsaXBQb3MoZG9jLCBhbmNob3IpLCBoZWFkKTtcXG4gICAgICAgIHNldFNlbGVjdGlvbihkb2MsIG5vcm1hbGl6ZVNlbGVjdGlvbihyYW5nZXMsIG91ckluZGV4KSwgc2VsX21vdXNlKTtcXG4gICAgICB9XFxuICAgIH1cXG5cXG4gICAgdmFyIGVkaXRvclNpemUgPSBkaXNwbGF5LndyYXBwZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XFxuICAgIC8vIFVzZWQgdG8gZW5zdXJlIHRpbWVvdXQgcmUtdHJpZXMgZG9uJ3QgZmlyZSB3aGVuIGFub3RoZXIgZXh0ZW5kXFxuICAgIC8vIGhhcHBlbmVkIGluIHRoZSBtZWFudGltZSAoY2xlYXJUaW1lb3V0IGlzbid0IHJlbGlhYmxlIC0tIGF0XFxuICAgIC8vIGxlYXN0IG9uIENocm9tZSwgdGhlIHRpbWVvdXRzIHN0aWxsIGhhcHBlbiBldmVuIHdoZW4gY2xlYXJlZCxcXG4gICAgLy8gaWYgdGhlIGNsZWFyIGhhcHBlbnMgYWZ0ZXIgdGhlaXIgc2NoZWR1bGVkIGZpcmluZyB0aW1lKS5cXG4gICAgdmFyIGNvdW50ZXIgPSAwO1xcblxcbiAgICBmdW5jdGlvbiBleHRlbmQoZSkge1xcbiAgICAgIHZhciBjdXJDb3VudCA9ICsrY291bnRlcjtcXG4gICAgICB2YXIgY3VyID0gcG9zRnJvbU1vdXNlKGNtLCBlLCB0cnVlLCB0eXBlID09IFxcXCJyZWN0XFxcIik7XFxuICAgICAgaWYgKCFjdXIpIHJldHVybjtcXG4gICAgICBpZiAoY21wKGN1ciwgbGFzdFBvcykgIT0gMCkge1xcbiAgICAgICAgY20uY3VyT3AuZm9jdXMgPSBhY3RpdmVFbHQoKTtcXG4gICAgICAgIGV4dGVuZFRvKGN1cik7XFxuICAgICAgICB2YXIgdmlzaWJsZSA9IHZpc2libGVMaW5lcyhkaXNwbGF5LCBkb2MpO1xcbiAgICAgICAgaWYgKGN1ci5saW5lID49IHZpc2libGUudG8gfHwgY3VyLmxpbmUgPCB2aXNpYmxlLmZyb20pXFxuICAgICAgICAgIHNldFRpbWVvdXQob3BlcmF0aW9uKGNtLCBmdW5jdGlvbigpe2lmIChjb3VudGVyID09IGN1ckNvdW50KSBleHRlbmQoZSk7fSksIDE1MCk7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIHZhciBvdXRzaWRlID0gZS5jbGllbnRZIDwgZWRpdG9yU2l6ZS50b3AgPyAtMjAgOiBlLmNsaWVudFkgPiBlZGl0b3JTaXplLmJvdHRvbSA/IDIwIDogMDtcXG4gICAgICAgIGlmIChvdXRzaWRlKSBzZXRUaW1lb3V0KG9wZXJhdGlvbihjbSwgZnVuY3Rpb24oKSB7XFxuICAgICAgICAgIGlmIChjb3VudGVyICE9IGN1ckNvdW50KSByZXR1cm47XFxuICAgICAgICAgIGRpc3BsYXkuc2Nyb2xsZXIuc2Nyb2xsVG9wICs9IG91dHNpZGU7XFxuICAgICAgICAgIGV4dGVuZChlKTtcXG4gICAgICAgIH0pLCA1MCk7XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIGZ1bmN0aW9uIGRvbmUoZSkge1xcbiAgICAgIGNtLnN0YXRlLnNlbGVjdGluZ1RleHQgPSBmYWxzZTtcXG4gICAgICBjb3VudGVyID0gSW5maW5pdHk7XFxuICAgICAgZV9wcmV2ZW50RGVmYXVsdChlKTtcXG4gICAgICBkaXNwbGF5LmlucHV0LmZvY3VzKCk7XFxuICAgICAgb2ZmKGRvY3VtZW50LCBcXFwibW91c2Vtb3ZlXFxcIiwgbW92ZSk7XFxuICAgICAgb2ZmKGRvY3VtZW50LCBcXFwibW91c2V1cFxcXCIsIHVwKTtcXG4gICAgICBkb2MuaGlzdG9yeS5sYXN0U2VsT3JpZ2luID0gbnVsbDtcXG4gICAgfVxcblxcbiAgICB2YXIgbW92ZSA9IG9wZXJhdGlvbihjbSwgZnVuY3Rpb24oZSkge1xcbiAgICAgIGlmICghZV9idXR0b24oZSkpIGRvbmUoZSk7XFxuICAgICAgZWxzZSBleHRlbmQoZSk7XFxuICAgIH0pO1xcbiAgICB2YXIgdXAgPSBvcGVyYXRpb24oY20sIGRvbmUpO1xcbiAgICBjbS5zdGF0ZS5zZWxlY3RpbmdUZXh0ID0gdXA7XFxuICAgIG9uKGRvY3VtZW50LCBcXFwibW91c2Vtb3ZlXFxcIiwgbW92ZSk7XFxuICAgIG9uKGRvY3VtZW50LCBcXFwibW91c2V1cFxcXCIsIHVwKTtcXG4gIH1cXG5cXG4gIC8vIERldGVybWluZXMgd2hldGhlciBhbiBldmVudCBoYXBwZW5lZCBpbiB0aGUgZ3V0dGVyLCBhbmQgZmlyZXMgdGhlXFxuICAvLyBoYW5kbGVycyBmb3IgdGhlIGNvcnJlc3BvbmRpbmcgZXZlbnQuXFxuICBmdW5jdGlvbiBndXR0ZXJFdmVudChjbSwgZSwgdHlwZSwgcHJldmVudCkge1xcbiAgICB0cnkgeyB2YXIgbVggPSBlLmNsaWVudFgsIG1ZID0gZS5jbGllbnRZOyB9XFxuICAgIGNhdGNoKGUpIHsgcmV0dXJuIGZhbHNlOyB9XFxuICAgIGlmIChtWCA+PSBNYXRoLmZsb29yKGNtLmRpc3BsYXkuZ3V0dGVycy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5yaWdodCkpIHJldHVybiBmYWxzZTtcXG4gICAgaWYgKHByZXZlbnQpIGVfcHJldmVudERlZmF1bHQoZSk7XFxuXFxuICAgIHZhciBkaXNwbGF5ID0gY20uZGlzcGxheTtcXG4gICAgdmFyIGxpbmVCb3ggPSBkaXNwbGF5LmxpbmVEaXYuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XFxuXFxuICAgIGlmIChtWSA+IGxpbmVCb3guYm90dG9tIHx8ICFoYXNIYW5kbGVyKGNtLCB0eXBlKSkgcmV0dXJuIGVfZGVmYXVsdFByZXZlbnRlZChlKTtcXG4gICAgbVkgLT0gbGluZUJveC50b3AgLSBkaXNwbGF5LnZpZXdPZmZzZXQ7XFxuXFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY20ub3B0aW9ucy5ndXR0ZXJzLmxlbmd0aDsgKytpKSB7XFxuICAgICAgdmFyIGcgPSBkaXNwbGF5Lmd1dHRlcnMuY2hpbGROb2Rlc1tpXTtcXG4gICAgICBpZiAoZyAmJiBnLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnJpZ2h0ID49IG1YKSB7XFxuICAgICAgICB2YXIgbGluZSA9IGxpbmVBdEhlaWdodChjbS5kb2MsIG1ZKTtcXG4gICAgICAgIHZhciBndXR0ZXIgPSBjbS5vcHRpb25zLmd1dHRlcnNbaV07XFxuICAgICAgICBzaWduYWwoY20sIHR5cGUsIGNtLCBsaW5lLCBndXR0ZXIsIGUpO1xcbiAgICAgICAgcmV0dXJuIGVfZGVmYXVsdFByZXZlbnRlZChlKTtcXG4gICAgICB9XFxuICAgIH1cXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIGNsaWNrSW5HdXR0ZXIoY20sIGUpIHtcXG4gICAgcmV0dXJuIGd1dHRlckV2ZW50KGNtLCBlLCBcXFwiZ3V0dGVyQ2xpY2tcXFwiLCB0cnVlKTtcXG4gIH1cXG5cXG4gIC8vIEtsdWRnZSB0byB3b3JrIGFyb3VuZCBzdHJhbmdlIElFIGJlaGF2aW9yIHdoZXJlIGl0J2xsIHNvbWV0aW1lc1xcbiAgLy8gcmUtZmlyZSBhIHNlcmllcyBvZiBkcmFnLXJlbGF0ZWQgZXZlbnRzIHJpZ2h0IGFmdGVyIHRoZSBkcm9wICgjMTU1MSlcXG4gIHZhciBsYXN0RHJvcCA9IDA7XFxuXFxuICBmdW5jdGlvbiBvbkRyb3AoZSkge1xcbiAgICB2YXIgY20gPSB0aGlzO1xcbiAgICBjbGVhckRyYWdDdXJzb3IoY20pO1xcbiAgICBpZiAoc2lnbmFsRE9NRXZlbnQoY20sIGUpIHx8IGV2ZW50SW5XaWRnZXQoY20uZGlzcGxheSwgZSkpXFxuICAgICAgcmV0dXJuO1xcbiAgICBlX3ByZXZlbnREZWZhdWx0KGUpO1xcbiAgICBpZiAoaWUpIGxhc3REcm9wID0gK25ldyBEYXRlO1xcbiAgICB2YXIgcG9zID0gcG9zRnJvbU1vdXNlKGNtLCBlLCB0cnVlKSwgZmlsZXMgPSBlLmRhdGFUcmFuc2Zlci5maWxlcztcXG4gICAgaWYgKCFwb3MgfHwgY20uaXNSZWFkT25seSgpKSByZXR1cm47XFxuICAgIC8vIE1pZ2h0IGJlIGEgZmlsZSBkcm9wLCBpbiB3aGljaCBjYXNlIHdlIHNpbXBseSBleHRyYWN0IHRoZSB0ZXh0XFxuICAgIC8vIGFuZCBpbnNlcnQgaXQuXFxuICAgIGlmIChmaWxlcyAmJiBmaWxlcy5sZW5ndGggJiYgd2luZG93LkZpbGVSZWFkZXIgJiYgd2luZG93LkZpbGUpIHtcXG4gICAgICB2YXIgbiA9IGZpbGVzLmxlbmd0aCwgdGV4dCA9IEFycmF5KG4pLCByZWFkID0gMDtcXG4gICAgICB2YXIgbG9hZEZpbGUgPSBmdW5jdGlvbihmaWxlLCBpKSB7XFxuICAgICAgICBpZiAoY20ub3B0aW9ucy5hbGxvd0Ryb3BGaWxlVHlwZXMgJiZcXG4gICAgICAgICAgICBpbmRleE9mKGNtLm9wdGlvbnMuYWxsb3dEcm9wRmlsZVR5cGVzLCBmaWxlLnR5cGUpID09IC0xKVxcbiAgICAgICAgICByZXR1cm47XFxuXFxuICAgICAgICB2YXIgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXI7XFxuICAgICAgICByZWFkZXIub25sb2FkID0gb3BlcmF0aW9uKGNtLCBmdW5jdGlvbigpIHtcXG4gICAgICAgICAgdmFyIGNvbnRlbnQgPSByZWFkZXIucmVzdWx0O1xcbiAgICAgICAgICBpZiAoL1tcXFxceDAwLVxcXFx4MDhcXFxceDBlLVxcXFx4MWZdezJ9Ly50ZXN0KGNvbnRlbnQpKSBjb250ZW50ID0gXFxcIlxcXCI7XFxuICAgICAgICAgIHRleHRbaV0gPSBjb250ZW50O1xcbiAgICAgICAgICBpZiAoKytyZWFkID09IG4pIHtcXG4gICAgICAgICAgICBwb3MgPSBjbGlwUG9zKGNtLmRvYywgcG9zKTtcXG4gICAgICAgICAgICB2YXIgY2hhbmdlID0ge2Zyb206IHBvcywgdG86IHBvcyxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IGNtLmRvYy5zcGxpdExpbmVzKHRleHQuam9pbihjbS5kb2MubGluZVNlcGFyYXRvcigpKSksXFxuICAgICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW46IFxcXCJwYXN0ZVxcXCJ9O1xcbiAgICAgICAgICAgIG1ha2VDaGFuZ2UoY20uZG9jLCBjaGFuZ2UpO1xcbiAgICAgICAgICAgIHNldFNlbGVjdGlvblJlcGxhY2VIaXN0b3J5KGNtLmRvYywgc2ltcGxlU2VsZWN0aW9uKHBvcywgY2hhbmdlRW5kKGNoYW5nZSkpKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfSk7XFxuICAgICAgICByZWFkZXIucmVhZEFzVGV4dChmaWxlKTtcXG4gICAgICB9O1xcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgKytpKSBsb2FkRmlsZShmaWxlc1tpXSwgaSk7XFxuICAgIH0gZWxzZSB7IC8vIE5vcm1hbCBkcm9wXFxuICAgICAgLy8gRG9uJ3QgZG8gYSByZXBsYWNlIGlmIHRoZSBkcm9wIGhhcHBlbmVkIGluc2lkZSBvZiB0aGUgc2VsZWN0ZWQgdGV4dC5cXG4gICAgICBpZiAoY20uc3RhdGUuZHJhZ2dpbmdUZXh0ICYmIGNtLmRvYy5zZWwuY29udGFpbnMocG9zKSA+IC0xKSB7XFxuICAgICAgICBjbS5zdGF0ZS5kcmFnZ2luZ1RleHQoZSk7XFxuICAgICAgICAvLyBFbnN1cmUgdGhlIGVkaXRvciBpcyByZS1mb2N1c2VkXFxuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge2NtLmRpc3BsYXkuaW5wdXQuZm9jdXMoKTt9LCAyMCk7XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfVxcbiAgICAgIHRyeSB7XFxuICAgICAgICB2YXIgdGV4dCA9IGUuZGF0YVRyYW5zZmVyLmdldERhdGEoXFxcIlRleHRcXFwiKTtcXG4gICAgICAgIGlmICh0ZXh0KSB7XFxuICAgICAgICAgIGlmIChjbS5zdGF0ZS5kcmFnZ2luZ1RleHQgJiYgIWNtLnN0YXRlLmRyYWdnaW5nVGV4dC5jb3B5KVxcbiAgICAgICAgICAgIHZhciBzZWxlY3RlZCA9IGNtLmxpc3RTZWxlY3Rpb25zKCk7XFxuICAgICAgICAgIHNldFNlbGVjdGlvbk5vVW5kbyhjbS5kb2MsIHNpbXBsZVNlbGVjdGlvbihwb3MsIHBvcykpO1xcbiAgICAgICAgICBpZiAoc2VsZWN0ZWQpIGZvciAodmFyIGkgPSAwOyBpIDwgc2VsZWN0ZWQubGVuZ3RoOyArK2kpXFxuICAgICAgICAgICAgcmVwbGFjZVJhbmdlKGNtLmRvYywgXFxcIlxcXCIsIHNlbGVjdGVkW2ldLmFuY2hvciwgc2VsZWN0ZWRbaV0uaGVhZCwgXFxcImRyYWdcXFwiKTtcXG4gICAgICAgICAgY20ucmVwbGFjZVNlbGVjdGlvbih0ZXh0LCBcXFwiYXJvdW5kXFxcIiwgXFxcInBhc3RlXFxcIik7XFxuICAgICAgICAgIGNtLmRpc3BsYXkuaW5wdXQuZm9jdXMoKTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgICAgY2F0Y2goZSl7fVxcbiAgICB9XFxuICB9XFxuXFxuICBmdW5jdGlvbiBvbkRyYWdTdGFydChjbSwgZSkge1xcbiAgICBpZiAoaWUgJiYgKCFjbS5zdGF0ZS5kcmFnZ2luZ1RleHQgfHwgK25ldyBEYXRlIC0gbGFzdERyb3AgPCAxMDApKSB7IGVfc3RvcChlKTsgcmV0dXJuOyB9XFxuICAgIGlmIChzaWduYWxET01FdmVudChjbSwgZSkgfHwgZXZlbnRJbldpZGdldChjbS5kaXNwbGF5LCBlKSkgcmV0dXJuO1xcblxcbiAgICBlLmRhdGFUcmFuc2Zlci5zZXREYXRhKFxcXCJUZXh0XFxcIiwgY20uZ2V0U2VsZWN0aW9uKCkpO1xcbiAgICBlLmRhdGFUcmFuc2Zlci5lZmZlY3RBbGxvd2VkID0gXFxcImNvcHlNb3ZlXFxcIlxcblxcbiAgICAvLyBVc2UgZHVtbXkgaW1hZ2UgaW5zdGVhZCBvZiBkZWZhdWx0IGJyb3dzZXJzIGltYWdlLlxcbiAgICAvLyBSZWNlbnQgU2FmYXJpICh+Ni4wLjIpIGhhdmUgYSB0ZW5kZW5jeSB0byBzZWdmYXVsdCB3aGVuIHRoaXMgaGFwcGVucywgc28gd2UgZG9uJ3QgZG8gaXQgdGhlcmUuXFxuICAgIGlmIChlLmRhdGFUcmFuc2Zlci5zZXREcmFnSW1hZ2UgJiYgIXNhZmFyaSkge1xcbiAgICAgIHZhciBpbWcgPSBlbHQoXFxcImltZ1xcXCIsIG51bGwsIG51bGwsIFxcXCJwb3NpdGlvbjogZml4ZWQ7IGxlZnQ6IDA7IHRvcDogMDtcXFwiKTtcXG4gICAgICBpbWcuc3JjID0gXFxcImRhdGE6aW1hZ2UvZ2lmO2Jhc2U2NCxSMGxHT0RsaEFRQUJBQUFBQUNINUJBRUtBQUVBTEFBQUFBQUJBQUVBQUFJQ1RBRUFPdz09XFxcIjtcXG4gICAgICBpZiAocHJlc3RvKSB7XFxuICAgICAgICBpbWcud2lkdGggPSBpbWcuaGVpZ2h0ID0gMTtcXG4gICAgICAgIGNtLmRpc3BsYXkud3JhcHBlci5hcHBlbmRDaGlsZChpbWcpO1xcbiAgICAgICAgLy8gRm9yY2UgYSByZWxheW91dCwgb3IgT3BlcmEgd29uJ3QgdXNlIG91ciBpbWFnZSBmb3Igc29tZSBvYnNjdXJlIHJlYXNvblxcbiAgICAgICAgaW1nLl90b3AgPSBpbWcub2Zmc2V0VG9wO1xcbiAgICAgIH1cXG4gICAgICBlLmRhdGFUcmFuc2Zlci5zZXREcmFnSW1hZ2UoaW1nLCAwLCAwKTtcXG4gICAgICBpZiAocHJlc3RvKSBpbWcucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChpbWcpO1xcbiAgICB9XFxuICB9XFxuXFxuICBmdW5jdGlvbiBvbkRyYWdPdmVyKGNtLCBlKSB7XFxuICAgIHZhciBwb3MgPSBwb3NGcm9tTW91c2UoY20sIGUpO1xcbiAgICBpZiAoIXBvcykgcmV0dXJuO1xcbiAgICB2YXIgZnJhZyA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcXG4gICAgZHJhd1NlbGVjdGlvbkN1cnNvcihjbSwgcG9zLCBmcmFnKTtcXG4gICAgaWYgKCFjbS5kaXNwbGF5LmRyYWdDdXJzb3IpIHtcXG4gICAgICBjbS5kaXNwbGF5LmRyYWdDdXJzb3IgPSBlbHQoXFxcImRpdlxcXCIsIG51bGwsIFxcXCJDb2RlTWlycm9yLWN1cnNvcnMgQ29kZU1pcnJvci1kcmFnY3Vyc29yc1xcXCIpO1xcbiAgICAgIGNtLmRpc3BsYXkubGluZVNwYWNlLmluc2VydEJlZm9yZShjbS5kaXNwbGF5LmRyYWdDdXJzb3IsIGNtLmRpc3BsYXkuY3Vyc29yRGl2KTtcXG4gICAgfVxcbiAgICByZW1vdmVDaGlsZHJlbkFuZEFkZChjbS5kaXNwbGF5LmRyYWdDdXJzb3IsIGZyYWcpO1xcbiAgfVxcblxcbiAgZnVuY3Rpb24gY2xlYXJEcmFnQ3Vyc29yKGNtKSB7XFxuICAgIGlmIChjbS5kaXNwbGF5LmRyYWdDdXJzb3IpIHtcXG4gICAgICBjbS5kaXNwbGF5LmxpbmVTcGFjZS5yZW1vdmVDaGlsZChjbS5kaXNwbGF5LmRyYWdDdXJzb3IpO1xcbiAgICAgIGNtLmRpc3BsYXkuZHJhZ0N1cnNvciA9IG51bGw7XFxuICAgIH1cXG4gIH1cXG5cXG4gIC8vIFNDUk9MTCBFVkVOVFNcXG5cXG4gIC8vIFN5bmMgdGhlIHNjcm9sbGFibGUgYXJlYSBhbmQgc2Nyb2xsYmFycywgZW5zdXJlIHRoZSB2aWV3cG9ydFxcbiAgLy8gY292ZXJzIHRoZSB2aXNpYmxlIGFyZWEuXFxuICBmdW5jdGlvbiBzZXRTY3JvbGxUb3AoY20sIHZhbCkge1xcbiAgICBpZiAoTWF0aC5hYnMoY20uZG9jLnNjcm9sbFRvcCAtIHZhbCkgPCAyKSByZXR1cm47XFxuICAgIGNtLmRvYy5zY3JvbGxUb3AgPSB2YWw7XFxuICAgIGlmICghZ2Vja28pIHVwZGF0ZURpc3BsYXlTaW1wbGUoY20sIHt0b3A6IHZhbH0pO1xcbiAgICBpZiAoY20uZGlzcGxheS5zY3JvbGxlci5zY3JvbGxUb3AgIT0gdmFsKSBjbS5kaXNwbGF5LnNjcm9sbGVyLnNjcm9sbFRvcCA9IHZhbDtcXG4gICAgY20uZGlzcGxheS5zY3JvbGxiYXJzLnNldFNjcm9sbFRvcCh2YWwpO1xcbiAgICBpZiAoZ2Vja28pIHVwZGF0ZURpc3BsYXlTaW1wbGUoY20pO1xcbiAgICBzdGFydFdvcmtlcihjbSwgMTAwKTtcXG4gIH1cXG4gIC8vIFN5bmMgc2Nyb2xsZXIgYW5kIHNjcm9sbGJhciwgZW5zdXJlIHRoZSBndXR0ZXIgZWxlbWVudHMgYXJlXFxuICAvLyBhbGlnbmVkLlxcbiAgZnVuY3Rpb24gc2V0U2Nyb2xsTGVmdChjbSwgdmFsLCBpc1Njcm9sbGVyKSB7XFxuICAgIGlmIChpc1Njcm9sbGVyID8gdmFsID09IGNtLmRvYy5zY3JvbGxMZWZ0IDogTWF0aC5hYnMoY20uZG9jLnNjcm9sbExlZnQgLSB2YWwpIDwgMikgcmV0dXJuO1xcbiAgICB2YWwgPSBNYXRoLm1pbih2YWwsIGNtLmRpc3BsYXkuc2Nyb2xsZXIuc2Nyb2xsV2lkdGggLSBjbS5kaXNwbGF5LnNjcm9sbGVyLmNsaWVudFdpZHRoKTtcXG4gICAgY20uZG9jLnNjcm9sbExlZnQgPSB2YWw7XFxuICAgIGFsaWduSG9yaXpvbnRhbGx5KGNtKTtcXG4gICAgaWYgKGNtLmRpc3BsYXkuc2Nyb2xsZXIuc2Nyb2xsTGVmdCAhPSB2YWwpIGNtLmRpc3BsYXkuc2Nyb2xsZXIuc2Nyb2xsTGVmdCA9IHZhbDtcXG4gICAgY20uZGlzcGxheS5zY3JvbGxiYXJzLnNldFNjcm9sbExlZnQodmFsKTtcXG4gIH1cXG5cXG4gIC8vIFNpbmNlIHRoZSBkZWx0YSB2YWx1ZXMgcmVwb3J0ZWQgb24gbW91c2Ugd2hlZWwgZXZlbnRzIGFyZVxcbiAgLy8gdW5zdGFuZGFyZGl6ZWQgYmV0d2VlbiBicm93c2VycyBhbmQgZXZlbiBicm93c2VyIHZlcnNpb25zLCBhbmRcXG4gIC8vIGdlbmVyYWxseSBob3JyaWJseSB1bnByZWRpY3RhYmxlLCB0aGlzIGNvZGUgc3RhcnRzIGJ5IG1lYXN1cmluZ1xcbiAgLy8gdGhlIHNjcm9sbCBlZmZlY3QgdGhhdCB0aGUgZmlyc3QgZmV3IG1vdXNlIHdoZWVsIGV2ZW50cyBoYXZlLFxcbiAgLy8gYW5kLCBmcm9tIHRoYXQsIGRldGVjdHMgdGhlIHdheSBpdCBjYW4gY29udmVydCBkZWx0YXMgdG8gcGl4ZWxcXG4gIC8vIG9mZnNldHMgYWZ0ZXJ3YXJkcy5cXG4gIC8vXFxuICAvLyBUaGUgcmVhc29uIHdlIHdhbnQgdG8ga25vdyB0aGUgYW1vdW50IGEgd2hlZWwgZXZlbnQgd2lsbCBzY3JvbGxcXG4gIC8vIGlzIHRoYXQgaXQgZ2l2ZXMgdXMgYSBjaGFuY2UgdG8gdXBkYXRlIHRoZSBkaXNwbGF5IGJlZm9yZSB0aGVcXG4gIC8vIGFjdHVhbCBzY3JvbGxpbmcgaGFwcGVucywgcmVkdWNpbmcgZmxpY2tlcmluZy5cXG5cXG4gIHZhciB3aGVlbFNhbXBsZXMgPSAwLCB3aGVlbFBpeGVsc1BlclVuaXQgPSBudWxsO1xcbiAgLy8gRmlsbCBpbiBhIGJyb3dzZXItZGV0ZWN0ZWQgc3RhcnRpbmcgdmFsdWUgb24gYnJvd3NlcnMgd2hlcmUgd2VcXG4gIC8vIGtub3cgb25lLiBUaGVzZSBkb24ndCBoYXZlIHRvIGJlIGFjY3VyYXRlIC0tIHRoZSByZXN1bHQgb2YgdGhlbVxcbiAgLy8gYmVpbmcgd3Jvbmcgd291bGQganVzdCBiZSBhIHNsaWdodCBmbGlja2VyIG9uIHRoZSBmaXJzdCB3aGVlbFxcbiAgLy8gc2Nyb2xsIChpZiBpdCBpcyBsYXJnZSBlbm91Z2gpLlxcbiAgaWYgKGllKSB3aGVlbFBpeGVsc1BlclVuaXQgPSAtLjUzO1xcbiAgZWxzZSBpZiAoZ2Vja28pIHdoZWVsUGl4ZWxzUGVyVW5pdCA9IDE1O1xcbiAgZWxzZSBpZiAoY2hyb21lKSB3aGVlbFBpeGVsc1BlclVuaXQgPSAtLjc7XFxuICBlbHNlIGlmIChzYWZhcmkpIHdoZWVsUGl4ZWxzUGVyVW5pdCA9IC0xLzM7XFxuXFxuICB2YXIgd2hlZWxFdmVudERlbHRhID0gZnVuY3Rpb24oZSkge1xcbiAgICB2YXIgZHggPSBlLndoZWVsRGVsdGFYLCBkeSA9IGUud2hlZWxEZWx0YVk7XFxuICAgIGlmIChkeCA9PSBudWxsICYmIGUuZGV0YWlsICYmIGUuYXhpcyA9PSBlLkhPUklaT05UQUxfQVhJUykgZHggPSBlLmRldGFpbDtcXG4gICAgaWYgKGR5ID09IG51bGwgJiYgZS5kZXRhaWwgJiYgZS5heGlzID09IGUuVkVSVElDQUxfQVhJUykgZHkgPSBlLmRldGFpbDtcXG4gICAgZWxzZSBpZiAoZHkgPT0gbnVsbCkgZHkgPSBlLndoZWVsRGVsdGE7XFxuICAgIHJldHVybiB7eDogZHgsIHk6IGR5fTtcXG4gIH07XFxuICBDb2RlTWlycm9yLndoZWVsRXZlbnRQaXhlbHMgPSBmdW5jdGlvbihlKSB7XFxuICAgIHZhciBkZWx0YSA9IHdoZWVsRXZlbnREZWx0YShlKTtcXG4gICAgZGVsdGEueCAqPSB3aGVlbFBpeGVsc1BlclVuaXQ7XFxuICAgIGRlbHRhLnkgKj0gd2hlZWxQaXhlbHNQZXJVbml0O1xcbiAgICByZXR1cm4gZGVsdGE7XFxuICB9O1xcblxcbiAgZnVuY3Rpb24gb25TY3JvbGxXaGVlbChjbSwgZSkge1xcbiAgICB2YXIgZGVsdGEgPSB3aGVlbEV2ZW50RGVsdGEoZSksIGR4ID0gZGVsdGEueCwgZHkgPSBkZWx0YS55O1xcblxcbiAgICB2YXIgZGlzcGxheSA9IGNtLmRpc3BsYXksIHNjcm9sbCA9IGRpc3BsYXkuc2Nyb2xsZXI7XFxuICAgIC8vIFF1aXQgaWYgdGhlcmUncyBub3RoaW5nIHRvIHNjcm9sbCBoZXJlXFxuICAgIHZhciBjYW5TY3JvbGxYID0gc2Nyb2xsLnNjcm9sbFdpZHRoID4gc2Nyb2xsLmNsaWVudFdpZHRoO1xcbiAgICB2YXIgY2FuU2Nyb2xsWSA9IHNjcm9sbC5zY3JvbGxIZWlnaHQgPiBzY3JvbGwuY2xpZW50SGVpZ2h0O1xcbiAgICBpZiAoIShkeCAmJiBjYW5TY3JvbGxYIHx8IGR5ICYmIGNhblNjcm9sbFkpKSByZXR1cm47XFxuXFxuICAgIC8vIFdlYmtpdCBicm93c2VycyBvbiBPUyBYIGFib3J0IG1vbWVudHVtIHNjcm9sbHMgd2hlbiB0aGUgdGFyZ2V0XFxuICAgIC8vIG9mIHRoZSBzY3JvbGwgZXZlbnQgaXMgcmVtb3ZlZCBmcm9tIHRoZSBzY3JvbGxhYmxlIGVsZW1lbnQuXFxuICAgIC8vIFRoaXMgaGFjayAoc2VlIHJlbGF0ZWQgY29kZSBpbiBwYXRjaERpc3BsYXkpIG1ha2VzIHN1cmUgdGhlXFxuICAgIC8vIGVsZW1lbnQgaXMga2VwdCBhcm91bmQuXFxuICAgIGlmIChkeSAmJiBtYWMgJiYgd2Via2l0KSB7XFxuICAgICAgb3V0ZXI6IGZvciAodmFyIGN1ciA9IGUudGFyZ2V0LCB2aWV3ID0gZGlzcGxheS52aWV3OyBjdXIgIT0gc2Nyb2xsOyBjdXIgPSBjdXIucGFyZW50Tm9kZSkge1xcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2aWV3Lmxlbmd0aDsgaSsrKSB7XFxuICAgICAgICAgIGlmICh2aWV3W2ldLm5vZGUgPT0gY3VyKSB7XFxuICAgICAgICAgICAgY20uZGlzcGxheS5jdXJyZW50V2hlZWxUYXJnZXQgPSBjdXI7XFxuICAgICAgICAgICAgYnJlYWsgb3V0ZXI7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIH1cXG5cXG4gICAgLy8gT24gc29tZSBicm93c2VycywgaG9yaXpvbnRhbCBzY3JvbGxpbmcgd2lsbCBjYXVzZSByZWRyYXdzIHRvXFxuICAgIC8vIGhhcHBlbiBiZWZvcmUgdGhlIGd1dHRlciBoYXMgYmVlbiByZWFsaWduZWQsIGNhdXNpbmcgaXQgdG9cXG4gICAgLy8gd3JpZ2dsZSBhcm91bmQgaW4gYSBtb3N0IHVuc2VlbWx5IHdheS4gV2hlbiB3ZSBoYXZlIGFuXFxuICAgIC8vIGVzdGltYXRlZCBwaXhlbHMvZGVsdGEgdmFsdWUsIHdlIGp1c3QgaGFuZGxlIGhvcml6b250YWxcXG4gICAgLy8gc2Nyb2xsaW5nIGVudGlyZWx5IGhlcmUuIEl0J2xsIGJlIHNsaWdodGx5IG9mZiBmcm9tIG5hdGl2ZSwgYnV0XFxuICAgIC8vIGJldHRlciB0aGFuIGdsaXRjaGluZyBvdXQuXFxuICAgIGlmIChkeCAmJiAhZ2Vja28gJiYgIXByZXN0byAmJiB3aGVlbFBpeGVsc1BlclVuaXQgIT0gbnVsbCkge1xcbiAgICAgIGlmIChkeSAmJiBjYW5TY3JvbGxZKVxcbiAgICAgICAgc2V0U2Nyb2xsVG9wKGNtLCBNYXRoLm1heCgwLCBNYXRoLm1pbihzY3JvbGwuc2Nyb2xsVG9wICsgZHkgKiB3aGVlbFBpeGVsc1BlclVuaXQsIHNjcm9sbC5zY3JvbGxIZWlnaHQgLSBzY3JvbGwuY2xpZW50SGVpZ2h0KSkpO1xcbiAgICAgIHNldFNjcm9sbExlZnQoY20sIE1hdGgubWF4KDAsIE1hdGgubWluKHNjcm9sbC5zY3JvbGxMZWZ0ICsgZHggKiB3aGVlbFBpeGVsc1BlclVuaXQsIHNjcm9sbC5zY3JvbGxXaWR0aCAtIHNjcm9sbC5jbGllbnRXaWR0aCkpKTtcXG4gICAgICAvLyBPbmx5IHByZXZlbnQgZGVmYXVsdCBzY3JvbGxpbmcgaWYgdmVydGljYWwgc2Nyb2xsaW5nIGlzXFxuICAgICAgLy8gYWN0dWFsbHkgcG9zc2libGUuIE90aGVyd2lzZSwgaXQgY2F1c2VzIHZlcnRpY2FsIHNjcm9sbFxcbiAgICAgIC8vIGppdHRlciBvbiBPU1ggdHJhY2twYWRzIHdoZW4gZGVsdGFYIGlzIHNtYWxsIGFuZCBkZWx0YVlcXG4gICAgICAvLyBpcyBsYXJnZSAoaXNzdWUgIzM1NzkpXFxuICAgICAgaWYgKCFkeSB8fCAoZHkgJiYgY2FuU2Nyb2xsWSkpXFxuICAgICAgICBlX3ByZXZlbnREZWZhdWx0KGUpO1xcbiAgICAgIGRpc3BsYXkud2hlZWxTdGFydFggPSBudWxsOyAvLyBBYm9ydCBtZWFzdXJlbWVudCwgaWYgaW4gcHJvZ3Jlc3NcXG4gICAgICByZXR1cm47XFxuICAgIH1cXG5cXG4gICAgLy8gJ1Byb2plY3QnIHRoZSB2aXNpYmxlIHZpZXdwb3J0IHRvIGNvdmVyIHRoZSBhcmVhIHRoYXQgaXMgYmVpbmdcXG4gICAgLy8gc2Nyb2xsZWQgaW50byB2aWV3IChpZiB3ZSBrbm93IGVub3VnaCB0byBlc3RpbWF0ZSBpdCkuXFxuICAgIGlmIChkeSAmJiB3aGVlbFBpeGVsc1BlclVuaXQgIT0gbnVsbCkge1xcbiAgICAgIHZhciBwaXhlbHMgPSBkeSAqIHdoZWVsUGl4ZWxzUGVyVW5pdDtcXG4gICAgICB2YXIgdG9wID0gY20uZG9jLnNjcm9sbFRvcCwgYm90ID0gdG9wICsgZGlzcGxheS53cmFwcGVyLmNsaWVudEhlaWdodDtcXG4gICAgICBpZiAocGl4ZWxzIDwgMCkgdG9wID0gTWF0aC5tYXgoMCwgdG9wICsgcGl4ZWxzIC0gNTApO1xcbiAgICAgIGVsc2UgYm90ID0gTWF0aC5taW4oY20uZG9jLmhlaWdodCwgYm90ICsgcGl4ZWxzICsgNTApO1xcbiAgICAgIHVwZGF0ZURpc3BsYXlTaW1wbGUoY20sIHt0b3A6IHRvcCwgYm90dG9tOiBib3R9KTtcXG4gICAgfVxcblxcbiAgICBpZiAod2hlZWxTYW1wbGVzIDwgMjApIHtcXG4gICAgICBpZiAoZGlzcGxheS53aGVlbFN0YXJ0WCA9PSBudWxsKSB7XFxuICAgICAgICBkaXNwbGF5LndoZWVsU3RhcnRYID0gc2Nyb2xsLnNjcm9sbExlZnQ7IGRpc3BsYXkud2hlZWxTdGFydFkgPSBzY3JvbGwuc2Nyb2xsVG9wO1xcbiAgICAgICAgZGlzcGxheS53aGVlbERYID0gZHg7IGRpc3BsYXkud2hlZWxEWSA9IGR5O1xcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcXG4gICAgICAgICAgaWYgKGRpc3BsYXkud2hlZWxTdGFydFggPT0gbnVsbCkgcmV0dXJuO1xcbiAgICAgICAgICB2YXIgbW92ZWRYID0gc2Nyb2xsLnNjcm9sbExlZnQgLSBkaXNwbGF5LndoZWVsU3RhcnRYO1xcbiAgICAgICAgICB2YXIgbW92ZWRZID0gc2Nyb2xsLnNjcm9sbFRvcCAtIGRpc3BsYXkud2hlZWxTdGFydFk7XFxuICAgICAgICAgIHZhciBzYW1wbGUgPSAobW92ZWRZICYmIGRpc3BsYXkud2hlZWxEWSAmJiBtb3ZlZFkgLyBkaXNwbGF5LndoZWVsRFkpIHx8XFxuICAgICAgICAgICAgKG1vdmVkWCAmJiBkaXNwbGF5LndoZWVsRFggJiYgbW92ZWRYIC8gZGlzcGxheS53aGVlbERYKTtcXG4gICAgICAgICAgZGlzcGxheS53aGVlbFN0YXJ0WCA9IGRpc3BsYXkud2hlZWxTdGFydFkgPSBudWxsO1xcbiAgICAgICAgICBpZiAoIXNhbXBsZSkgcmV0dXJuO1xcbiAgICAgICAgICB3aGVlbFBpeGVsc1BlclVuaXQgPSAod2hlZWxQaXhlbHNQZXJVbml0ICogd2hlZWxTYW1wbGVzICsgc2FtcGxlKSAvICh3aGVlbFNhbXBsZXMgKyAxKTtcXG4gICAgICAgICAgKyt3aGVlbFNhbXBsZXM7XFxuICAgICAgICB9LCAyMDApO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBkaXNwbGF5LndoZWVsRFggKz0gZHg7IGRpc3BsYXkud2hlZWxEWSArPSBkeTtcXG4gICAgICB9XFxuICAgIH1cXG4gIH1cXG5cXG4gIC8vIEtFWSBFVkVOVFNcXG5cXG4gIC8vIFJ1biBhIGhhbmRsZXIgdGhhdCB3YXMgYm91bmQgdG8gYSBrZXkuXFxuICBmdW5jdGlvbiBkb0hhbmRsZUJpbmRpbmcoY20sIGJvdW5kLCBkcm9wU2hpZnQpIHtcXG4gICAgaWYgKHR5cGVvZiBib3VuZCA9PSBcXFwic3RyaW5nXFxcIikge1xcbiAgICAgIGJvdW5kID0gY29tbWFuZHNbYm91bmRdO1xcbiAgICAgIGlmICghYm91bmQpIHJldHVybiBmYWxzZTtcXG4gICAgfVxcbiAgICAvLyBFbnN1cmUgcHJldmlvdXMgaW5wdXQgaGFzIGJlZW4gcmVhZCwgc28gdGhhdCB0aGUgaGFuZGxlciBzZWVzIGFcXG4gICAgLy8gY29uc2lzdGVudCB2aWV3IG9mIHRoZSBkb2N1bWVudFxcbiAgICBjbS5kaXNwbGF5LmlucHV0LmVuc3VyZVBvbGxlZCgpO1xcbiAgICB2YXIgcHJldlNoaWZ0ID0gY20uZGlzcGxheS5zaGlmdCwgZG9uZSA9IGZhbHNlO1xcbiAgICB0cnkge1xcbiAgICAgIGlmIChjbS5pc1JlYWRPbmx5KCkpIGNtLnN0YXRlLnN1cHByZXNzRWRpdHMgPSB0cnVlO1xcbiAgICAgIGlmIChkcm9wU2hpZnQpIGNtLmRpc3BsYXkuc2hpZnQgPSBmYWxzZTtcXG4gICAgICBkb25lID0gYm91bmQoY20pICE9IFBhc3M7XFxuICAgIH0gZmluYWxseSB7XFxuICAgICAgY20uZGlzcGxheS5zaGlmdCA9IHByZXZTaGlmdDtcXG4gICAgICBjbS5zdGF0ZS5zdXBwcmVzc0VkaXRzID0gZmFsc2U7XFxuICAgIH1cXG4gICAgcmV0dXJuIGRvbmU7XFxuICB9XFxuXFxuICBmdW5jdGlvbiBsb29rdXBLZXlGb3JFZGl0b3IoY20sIG5hbWUsIGhhbmRsZSkge1xcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNtLnN0YXRlLmtleU1hcHMubGVuZ3RoOyBpKyspIHtcXG4gICAgICB2YXIgcmVzdWx0ID0gbG9va3VwS2V5KG5hbWUsIGNtLnN0YXRlLmtleU1hcHNbaV0sIGhhbmRsZSwgY20pO1xcbiAgICAgIGlmIChyZXN1bHQpIHJldHVybiByZXN1bHQ7XFxuICAgIH1cXG4gICAgcmV0dXJuIChjbS5vcHRpb25zLmV4dHJhS2V5cyAmJiBsb29rdXBLZXkobmFtZSwgY20ub3B0aW9ucy5leHRyYUtleXMsIGhhbmRsZSwgY20pKVxcbiAgICAgIHx8IGxvb2t1cEtleShuYW1lLCBjbS5vcHRpb25zLmtleU1hcCwgaGFuZGxlLCBjbSk7XFxuICB9XFxuXFxuICB2YXIgc3RvcFNlcSA9IG5ldyBEZWxheWVkO1xcbiAgZnVuY3Rpb24gZGlzcGF0Y2hLZXkoY20sIG5hbWUsIGUsIGhhbmRsZSkge1xcbiAgICB2YXIgc2VxID0gY20uc3RhdGUua2V5U2VxO1xcbiAgICBpZiAoc2VxKSB7XFxuICAgICAgaWYgKGlzTW9kaWZpZXJLZXkobmFtZSkpIHJldHVybiBcXFwiaGFuZGxlZFxcXCI7XFxuICAgICAgc3RvcFNlcS5zZXQoNTAsIGZ1bmN0aW9uKCkge1xcbiAgICAgICAgaWYgKGNtLnN0YXRlLmtleVNlcSA9PSBzZXEpIHtcXG4gICAgICAgICAgY20uc3RhdGUua2V5U2VxID0gbnVsbDtcXG4gICAgICAgICAgY20uZGlzcGxheS5pbnB1dC5yZXNldCgpO1xcbiAgICAgICAgfVxcbiAgICAgIH0pO1xcbiAgICAgIG5hbWUgPSBzZXEgKyBcXFwiIFxcXCIgKyBuYW1lO1xcbiAgICB9XFxuICAgIHZhciByZXN1bHQgPSBsb29rdXBLZXlGb3JFZGl0b3IoY20sIG5hbWUsIGhhbmRsZSk7XFxuXFxuICAgIGlmIChyZXN1bHQgPT0gXFxcIm11bHRpXFxcIilcXG4gICAgICBjbS5zdGF0ZS5rZXlTZXEgPSBuYW1lO1xcbiAgICBpZiAocmVzdWx0ID09IFxcXCJoYW5kbGVkXFxcIilcXG4gICAgICBzaWduYWxMYXRlcihjbSwgXFxcImtleUhhbmRsZWRcXFwiLCBjbSwgbmFtZSwgZSk7XFxuXFxuICAgIGlmIChyZXN1bHQgPT0gXFxcImhhbmRsZWRcXFwiIHx8IHJlc3VsdCA9PSBcXFwibXVsdGlcXFwiKSB7XFxuICAgICAgZV9wcmV2ZW50RGVmYXVsdChlKTtcXG4gICAgICByZXN0YXJ0QmxpbmsoY20pO1xcbiAgICB9XFxuXFxuICAgIGlmIChzZXEgJiYgIXJlc3VsdCAmJiAvXFxcXCckLy50ZXN0KG5hbWUpKSB7XFxuICAgICAgZV9wcmV2ZW50RGVmYXVsdChlKTtcXG4gICAgICByZXR1cm4gdHJ1ZTtcXG4gICAgfVxcbiAgICByZXR1cm4gISFyZXN1bHQ7XFxuICB9XFxuXFxuICAvLyBIYW5kbGUgYSBrZXkgZnJvbSB0aGUga2V5ZG93biBldmVudC5cXG4gIGZ1bmN0aW9uIGhhbmRsZUtleUJpbmRpbmcoY20sIGUpIHtcXG4gICAgdmFyIG5hbWUgPSBrZXlOYW1lKGUsIHRydWUpO1xcbiAgICBpZiAoIW5hbWUpIHJldHVybiBmYWxzZTtcXG5cXG4gICAgaWYgKGUuc2hpZnRLZXkgJiYgIWNtLnN0YXRlLmtleVNlcSkge1xcbiAgICAgIC8vIEZpcnN0IHRyeSB0byByZXNvbHZlIGZ1bGwgbmFtZSAoaW5jbHVkaW5nICdTaGlmdC0nKS4gRmFpbGluZ1xcbiAgICAgIC8vIHRoYXQsIHNlZSBpZiB0aGVyZSBpcyBhIGN1cnNvci1tb3Rpb24gY29tbWFuZCAoc3RhcnRpbmcgd2l0aFxcbiAgICAgIC8vICdnbycpIGJvdW5kIHRvIHRoZSBrZXluYW1lIHdpdGhvdXQgJ1NoaWZ0LScuXFxuICAgICAgcmV0dXJuIGRpc3BhdGNoS2V5KGNtLCBcXFwiU2hpZnQtXFxcIiArIG5hbWUsIGUsIGZ1bmN0aW9uKGIpIHtyZXR1cm4gZG9IYW5kbGVCaW5kaW5nKGNtLCBiLCB0cnVlKTt9KVxcbiAgICAgICAgICB8fCBkaXNwYXRjaEtleShjbSwgbmFtZSwgZSwgZnVuY3Rpb24oYikge1xcbiAgICAgICAgICAgICAgIGlmICh0eXBlb2YgYiA9PSBcXFwic3RyaW5nXFxcIiA/IC9eZ29bQS1aXS8udGVzdChiKSA6IGIubW90aW9uKVxcbiAgICAgICAgICAgICAgICAgcmV0dXJuIGRvSGFuZGxlQmluZGluZyhjbSwgYik7XFxuICAgICAgICAgICAgIH0pO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIHJldHVybiBkaXNwYXRjaEtleShjbSwgbmFtZSwgZSwgZnVuY3Rpb24oYikgeyByZXR1cm4gZG9IYW5kbGVCaW5kaW5nKGNtLCBiKTsgfSk7XFxuICAgIH1cXG4gIH1cXG5cXG4gIC8vIEhhbmRsZSBhIGtleSBmcm9tIHRoZSBrZXlwcmVzcyBldmVudFxcbiAgZnVuY3Rpb24gaGFuZGxlQ2hhckJpbmRpbmcoY20sIGUsIGNoKSB7XFxuICAgIHJldHVybiBkaXNwYXRjaEtleShjbSwgXFxcIidcXFwiICsgY2ggKyBcXFwiJ1xcXCIsIGUsXFxuICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbihiKSB7IHJldHVybiBkb0hhbmRsZUJpbmRpbmcoY20sIGIsIHRydWUpOyB9KTtcXG4gIH1cXG5cXG4gIHZhciBsYXN0U3RvcHBlZEtleSA9IG51bGw7XFxuICBmdW5jdGlvbiBvbktleURvd24oZSkge1xcbiAgICB2YXIgY20gPSB0aGlzO1xcbiAgICBjbS5jdXJPcC5mb2N1cyA9IGFjdGl2ZUVsdCgpO1xcbiAgICBpZiAoc2lnbmFsRE9NRXZlbnQoY20sIGUpKSByZXR1cm47XFxuICAgIC8vIElFIGRvZXMgc3RyYW5nZSB0aGluZ3Mgd2l0aCBlc2NhcGUuXFxuICAgIGlmIChpZSAmJiBpZV92ZXJzaW9uIDwgMTEgJiYgZS5rZXlDb2RlID09IDI3KSBlLnJldHVyblZhbHVlID0gZmFsc2U7XFxuICAgIHZhciBjb2RlID0gZS5rZXlDb2RlO1xcbiAgICBjbS5kaXNwbGF5LnNoaWZ0ID0gY29kZSA9PSAxNiB8fCBlLnNoaWZ0S2V5O1xcbiAgICB2YXIgaGFuZGxlZCA9IGhhbmRsZUtleUJpbmRpbmcoY20sIGUpO1xcbiAgICBpZiAocHJlc3RvKSB7XFxuICAgICAgbGFzdFN0b3BwZWRLZXkgPSBoYW5kbGVkID8gY29kZSA6IG51bGw7XFxuICAgICAgLy8gT3BlcmEgaGFzIG5vIGN1dCBldmVudC4uLiB3ZSB0cnkgdG8gYXQgbGVhc3QgY2F0Y2ggdGhlIGtleSBjb21ib1xcbiAgICAgIGlmICghaGFuZGxlZCAmJiBjb2RlID09IDg4ICYmICFoYXNDb3B5RXZlbnQgJiYgKG1hYyA/IGUubWV0YUtleSA6IGUuY3RybEtleSkpXFxuICAgICAgICBjbS5yZXBsYWNlU2VsZWN0aW9uKFxcXCJcXFwiLCBudWxsLCBcXFwiY3V0XFxcIik7XFxuICAgIH1cXG5cXG4gICAgLy8gVHVybiBtb3VzZSBpbnRvIGNyb3NzaGFpciB3aGVuIEFsdCBpcyBoZWxkIG9uIE1hYy5cXG4gICAgaWYgKGNvZGUgPT0gMTggJiYgIS9cXFxcYkNvZGVNaXJyb3ItY3Jvc3NoYWlyXFxcXGIvLnRlc3QoY20uZGlzcGxheS5saW5lRGl2LmNsYXNzTmFtZSkpXFxuICAgICAgc2hvd0Nyb3NzSGFpcihjbSk7XFxuICB9XFxuXFxuICBmdW5jdGlvbiBzaG93Q3Jvc3NIYWlyKGNtKSB7XFxuICAgIHZhciBsaW5lRGl2ID0gY20uZGlzcGxheS5saW5lRGl2O1xcbiAgICBhZGRDbGFzcyhsaW5lRGl2LCBcXFwiQ29kZU1pcnJvci1jcm9zc2hhaXJcXFwiKTtcXG5cXG4gICAgZnVuY3Rpb24gdXAoZSkge1xcbiAgICAgIGlmIChlLmtleUNvZGUgPT0gMTggfHwgIWUuYWx0S2V5KSB7XFxuICAgICAgICBybUNsYXNzKGxpbmVEaXYsIFxcXCJDb2RlTWlycm9yLWNyb3NzaGFpclxcXCIpO1xcbiAgICAgICAgb2ZmKGRvY3VtZW50LCBcXFwia2V5dXBcXFwiLCB1cCk7XFxuICAgICAgICBvZmYoZG9jdW1lbnQsIFxcXCJtb3VzZW92ZXJcXFwiLCB1cCk7XFxuICAgICAgfVxcbiAgICB9XFxuICAgIG9uKGRvY3VtZW50LCBcXFwia2V5dXBcXFwiLCB1cCk7XFxuICAgIG9uKGRvY3VtZW50LCBcXFwibW91c2VvdmVyXFxcIiwgdXApO1xcbiAgfVxcblxcbiAgZnVuY3Rpb24gb25LZXlVcChlKSB7XFxuICAgIGlmIChlLmtleUNvZGUgPT0gMTYpIHRoaXMuZG9jLnNlbC5zaGlmdCA9IGZhbHNlO1xcbiAgICBzaWduYWxET01FdmVudCh0aGlzLCBlKTtcXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIG9uS2V5UHJlc3MoZSkge1xcbiAgICB2YXIgY20gPSB0aGlzO1xcbiAgICBpZiAoZXZlbnRJbldpZGdldChjbS5kaXNwbGF5LCBlKSB8fCBzaWduYWxET01FdmVudChjbSwgZSkgfHwgZS5jdHJsS2V5ICYmICFlLmFsdEtleSB8fCBtYWMgJiYgZS5tZXRhS2V5KSByZXR1cm47XFxuICAgIHZhciBrZXlDb2RlID0gZS5rZXlDb2RlLCBjaGFyQ29kZSA9IGUuY2hhckNvZGU7XFxuICAgIGlmIChwcmVzdG8gJiYga2V5Q29kZSA9PSBsYXN0U3RvcHBlZEtleSkge2xhc3RTdG9wcGVkS2V5ID0gbnVsbDsgZV9wcmV2ZW50RGVmYXVsdChlKTsgcmV0dXJuO31cXG4gICAgaWYgKChwcmVzdG8gJiYgKCFlLndoaWNoIHx8IGUud2hpY2ggPCAxMCkpICYmIGhhbmRsZUtleUJpbmRpbmcoY20sIGUpKSByZXR1cm47XFxuICAgIHZhciBjaCA9IFN0cmluZy5mcm9tQ2hhckNvZGUoY2hhckNvZGUgPT0gbnVsbCA/IGtleUNvZGUgOiBjaGFyQ29kZSk7XFxuICAgIGlmIChoYW5kbGVDaGFyQmluZGluZyhjbSwgZSwgY2gpKSByZXR1cm47XFxuICAgIGNtLmRpc3BsYXkuaW5wdXQub25LZXlQcmVzcyhlKTtcXG4gIH1cXG5cXG4gIC8vIEZPQ1VTL0JMVVIgRVZFTlRTXFxuXFxuICBmdW5jdGlvbiBkZWxheUJsdXJFdmVudChjbSkge1xcbiAgICBjbS5zdGF0ZS5kZWxheWluZ0JsdXJFdmVudCA9IHRydWU7XFxuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XFxuICAgICAgaWYgKGNtLnN0YXRlLmRlbGF5aW5nQmx1ckV2ZW50KSB7XFxuICAgICAgICBjbS5zdGF0ZS5kZWxheWluZ0JsdXJFdmVudCA9IGZhbHNlO1xcbiAgICAgICAgb25CbHVyKGNtKTtcXG4gICAgICB9XFxuICAgIH0sIDEwMCk7XFxuICB9XFxuXFxuICBmdW5jdGlvbiBvbkZvY3VzKGNtLCBlKSB7XFxuICAgIGlmIChjbS5zdGF0ZS5kZWxheWluZ0JsdXJFdmVudCkgY20uc3RhdGUuZGVsYXlpbmdCbHVyRXZlbnQgPSBmYWxzZTtcXG5cXG4gICAgaWYgKGNtLm9wdGlvbnMucmVhZE9ubHkgPT0gXFxcIm5vY3Vyc29yXFxcIikgcmV0dXJuO1xcbiAgICBpZiAoIWNtLnN0YXRlLmZvY3VzZWQpIHtcXG4gICAgICBzaWduYWwoY20sIFxcXCJmb2N1c1xcXCIsIGNtLCBlKTtcXG4gICAgICBjbS5zdGF0ZS5mb2N1c2VkID0gdHJ1ZTtcXG4gICAgICBhZGRDbGFzcyhjbS5kaXNwbGF5LndyYXBwZXIsIFxcXCJDb2RlTWlycm9yLWZvY3VzZWRcXFwiKTtcXG4gICAgICAvLyBUaGlzIHRlc3QgcHJldmVudHMgdGhpcyBmcm9tIGZpcmluZyB3aGVuIGEgY29udGV4dFxcbiAgICAgIC8vIG1lbnUgaXMgY2xvc2VkIChzaW5jZSB0aGUgaW5wdXQgcmVzZXQgd291bGQga2lsbCB0aGVcXG4gICAgICAvLyBzZWxlY3QtYWxsIGRldGVjdGlvbiBoYWNrKVxcbiAgICAgIGlmICghY20uY3VyT3AgJiYgY20uZGlzcGxheS5zZWxGb3JDb250ZXh0TWVudSAhPSBjbS5kb2Muc2VsKSB7XFxuICAgICAgICBjbS5kaXNwbGF5LmlucHV0LnJlc2V0KCk7XFxuICAgICAgICBpZiAod2Via2l0KSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkgeyBjbS5kaXNwbGF5LmlucHV0LnJlc2V0KHRydWUpOyB9LCAyMCk7IC8vIElzc3VlICMxNzMwXFxuICAgICAgfVxcbiAgICAgIGNtLmRpc3BsYXkuaW5wdXQucmVjZWl2ZWRGb2N1cygpO1xcbiAgICB9XFxuICAgIHJlc3RhcnRCbGluayhjbSk7XFxuICB9XFxuICBmdW5jdGlvbiBvbkJsdXIoY20sIGUpIHtcXG4gICAgaWYgKGNtLnN0YXRlLmRlbGF5aW5nQmx1ckV2ZW50KSByZXR1cm47XFxuXFxuICAgIGlmIChjbS5zdGF0ZS5mb2N1c2VkKSB7XFxuICAgICAgc2lnbmFsKGNtLCBcXFwiYmx1clxcXCIsIGNtLCBlKTtcXG4gICAgICBjbS5zdGF0ZS5mb2N1c2VkID0gZmFsc2U7XFxuICAgICAgcm1DbGFzcyhjbS5kaXNwbGF5LndyYXBwZXIsIFxcXCJDb2RlTWlycm9yLWZvY3VzZWRcXFwiKTtcXG4gICAgfVxcbiAgICBjbGVhckludGVydmFsKGNtLmRpc3BsYXkuYmxpbmtlcik7XFxuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7aWYgKCFjbS5zdGF0ZS5mb2N1c2VkKSBjbS5kaXNwbGF5LnNoaWZ0ID0gZmFsc2U7fSwgMTUwKTtcXG4gIH1cXG5cXG4gIC8vIENPTlRFWFQgTUVOVSBIQU5ETElOR1xcblxcbiAgLy8gVG8gbWFrZSB0aGUgY29udGV4dCBtZW51IHdvcmssIHdlIG5lZWQgdG8gYnJpZWZseSB1bmhpZGUgdGhlXFxuICAvLyB0ZXh0YXJlYSAobWFraW5nIGl0IGFzIHVub2J0cnVzaXZlIGFzIHBvc3NpYmxlKSB0byBsZXQgdGhlXFxuICAvLyByaWdodC1jbGljayB0YWtlIGVmZmVjdCBvbiBpdC5cXG4gIGZ1bmN0aW9uIG9uQ29udGV4dE1lbnUoY20sIGUpIHtcXG4gICAgaWYgKGV2ZW50SW5XaWRnZXQoY20uZGlzcGxheSwgZSkgfHwgY29udGV4dE1lbnVJbkd1dHRlcihjbSwgZSkpIHJldHVybjtcXG4gICAgaWYgKHNpZ25hbERPTUV2ZW50KGNtLCBlLCBcXFwiY29udGV4dG1lbnVcXFwiKSkgcmV0dXJuO1xcbiAgICBjbS5kaXNwbGF5LmlucHV0Lm9uQ29udGV4dE1lbnUoZSk7XFxuICB9XFxuXFxuICBmdW5jdGlvbiBjb250ZXh0TWVudUluR3V0dGVyKGNtLCBlKSB7XFxuICAgIGlmICghaGFzSGFuZGxlcihjbSwgXFxcImd1dHRlckNvbnRleHRNZW51XFxcIikpIHJldHVybiBmYWxzZTtcXG4gICAgcmV0dXJuIGd1dHRlckV2ZW50KGNtLCBlLCBcXFwiZ3V0dGVyQ29udGV4dE1lbnVcXFwiLCBmYWxzZSk7XFxuICB9XFxuXFxuICAvLyBVUERBVElOR1xcblxcbiAgLy8gQ29tcHV0ZSB0aGUgcG9zaXRpb24gb2YgdGhlIGVuZCBvZiBhIGNoYW5nZSAoaXRzICd0bycgcHJvcGVydHlcXG4gIC8vIHJlZmVycyB0byB0aGUgcHJlLWNoYW5nZSBlbmQpLlxcbiAgdmFyIGNoYW5nZUVuZCA9IENvZGVNaXJyb3IuY2hhbmdlRW5kID0gZnVuY3Rpb24oY2hhbmdlKSB7XFxuICAgIGlmICghY2hhbmdlLnRleHQpIHJldHVybiBjaGFuZ2UudG87XFxuICAgIHJldHVybiBQb3MoY2hhbmdlLmZyb20ubGluZSArIGNoYW5nZS50ZXh0Lmxlbmd0aCAtIDEsXFxuICAgICAgICAgICAgICAgbHN0KGNoYW5nZS50ZXh0KS5sZW5ndGggKyAoY2hhbmdlLnRleHQubGVuZ3RoID09IDEgPyBjaGFuZ2UuZnJvbS5jaCA6IDApKTtcXG4gIH07XFxuXFxuICAvLyBBZGp1c3QgYSBwb3NpdGlvbiB0byByZWZlciB0byB0aGUgcG9zdC1jaGFuZ2UgcG9zaXRpb24gb2YgdGhlXFxuICAvLyBzYW1lIHRleHQsIG9yIHRoZSBlbmQgb2YgdGhlIGNoYW5nZSBpZiB0aGUgY2hhbmdlIGNvdmVycyBpdC5cXG4gIGZ1bmN0aW9uIGFkanVzdEZvckNoYW5nZShwb3MsIGNoYW5nZSkge1xcbiAgICBpZiAoY21wKHBvcywgY2hhbmdlLmZyb20pIDwgMCkgcmV0dXJuIHBvcztcXG4gICAgaWYgKGNtcChwb3MsIGNoYW5nZS50bykgPD0gMCkgcmV0dXJuIGNoYW5nZUVuZChjaGFuZ2UpO1xcblxcbiAgICB2YXIgbGluZSA9IHBvcy5saW5lICsgY2hhbmdlLnRleHQubGVuZ3RoIC0gKGNoYW5nZS50by5saW5lIC0gY2hhbmdlLmZyb20ubGluZSkgLSAxLCBjaCA9IHBvcy5jaDtcXG4gICAgaWYgKHBvcy5saW5lID09IGNoYW5nZS50by5saW5lKSBjaCArPSBjaGFuZ2VFbmQoY2hhbmdlKS5jaCAtIGNoYW5nZS50by5jaDtcXG4gICAgcmV0dXJuIFBvcyhsaW5lLCBjaCk7XFxuICB9XFxuXFxuICBmdW5jdGlvbiBjb21wdXRlU2VsQWZ0ZXJDaGFuZ2UoZG9jLCBjaGFuZ2UpIHtcXG4gICAgdmFyIG91dCA9IFtdO1xcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRvYy5zZWwucmFuZ2VzLmxlbmd0aDsgaSsrKSB7XFxuICAgICAgdmFyIHJhbmdlID0gZG9jLnNlbC5yYW5nZXNbaV07XFxuICAgICAgb3V0LnB1c2gobmV3IFJhbmdlKGFkanVzdEZvckNoYW5nZShyYW5nZS5hbmNob3IsIGNoYW5nZSksXFxuICAgICAgICAgICAgICAgICAgICAgICAgIGFkanVzdEZvckNoYW5nZShyYW5nZS5oZWFkLCBjaGFuZ2UpKSk7XFxuICAgIH1cXG4gICAgcmV0dXJuIG5vcm1hbGl6ZVNlbGVjdGlvbihvdXQsIGRvYy5zZWwucHJpbUluZGV4KTtcXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIG9mZnNldFBvcyhwb3MsIG9sZCwgbncpIHtcXG4gICAgaWYgKHBvcy5saW5lID09IG9sZC5saW5lKVxcbiAgICAgIHJldHVybiBQb3MobncubGluZSwgcG9zLmNoIC0gb2xkLmNoICsgbncuY2gpO1xcbiAgICBlbHNlXFxuICAgICAgcmV0dXJuIFBvcyhudy5saW5lICsgKHBvcy5saW5lIC0gb2xkLmxpbmUpLCBwb3MuY2gpO1xcbiAgfVxcblxcbiAgLy8gVXNlZCBieSByZXBsYWNlU2VsZWN0aW9ucyB0byBhbGxvdyBtb3ZpbmcgdGhlIHNlbGVjdGlvbiB0byB0aGVcXG4gIC8vIHN0YXJ0IG9yIGFyb3VuZCB0aGUgcmVwbGFjZWQgdGVzdC4gSGludCBtYXkgYmUgXFxcInN0YXJ0XFxcIiBvciBcXFwiYXJvdW5kXFxcIi5cXG4gIGZ1bmN0aW9uIGNvbXB1dGVSZXBsYWNlZFNlbChkb2MsIGNoYW5nZXMsIGhpbnQpIHtcXG4gICAgdmFyIG91dCA9IFtdO1xcbiAgICB2YXIgb2xkUHJldiA9IFBvcyhkb2MuZmlyc3QsIDApLCBuZXdQcmV2ID0gb2xkUHJldjtcXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGFuZ2VzLmxlbmd0aDsgaSsrKSB7XFxuICAgICAgdmFyIGNoYW5nZSA9IGNoYW5nZXNbaV07XFxuICAgICAgdmFyIGZyb20gPSBvZmZzZXRQb3MoY2hhbmdlLmZyb20sIG9sZFByZXYsIG5ld1ByZXYpO1xcbiAgICAgIHZhciB0byA9IG9mZnNldFBvcyhjaGFuZ2VFbmQoY2hhbmdlKSwgb2xkUHJldiwgbmV3UHJldik7XFxuICAgICAgb2xkUHJldiA9IGNoYW5nZS50bztcXG4gICAgICBuZXdQcmV2ID0gdG87XFxuICAgICAgaWYgKGhpbnQgPT0gXFxcImFyb3VuZFxcXCIpIHtcXG4gICAgICAgIHZhciByYW5nZSA9IGRvYy5zZWwucmFuZ2VzW2ldLCBpbnYgPSBjbXAocmFuZ2UuaGVhZCwgcmFuZ2UuYW5jaG9yKSA8IDA7XFxuICAgICAgICBvdXRbaV0gPSBuZXcgUmFuZ2UoaW52ID8gdG8gOiBmcm9tLCBpbnYgPyBmcm9tIDogdG8pO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBvdXRbaV0gPSBuZXcgUmFuZ2UoZnJvbSwgZnJvbSk7XFxuICAgICAgfVxcbiAgICB9XFxuICAgIHJldHVybiBuZXcgU2VsZWN0aW9uKG91dCwgZG9jLnNlbC5wcmltSW5kZXgpO1xcbiAgfVxcblxcbiAgLy8gQWxsb3cgXFxcImJlZm9yZUNoYW5nZVxcXCIgZXZlbnQgaGFuZGxlcnMgdG8gaW5mbHVlbmNlIGEgY2hhbmdlXFxuICBmdW5jdGlvbiBmaWx0ZXJDaGFuZ2UoZG9jLCBjaGFuZ2UsIHVwZGF0ZSkge1xcbiAgICB2YXIgb2JqID0ge1xcbiAgICAgIGNhbmNlbGVkOiBmYWxzZSxcXG4gICAgICBmcm9tOiBjaGFuZ2UuZnJvbSxcXG4gICAgICB0bzogY2hhbmdlLnRvLFxcbiAgICAgIHRleHQ6IGNoYW5nZS50ZXh0LFxcbiAgICAgIG9yaWdpbjogY2hhbmdlLm9yaWdpbixcXG4gICAgICBjYW5jZWw6IGZ1bmN0aW9uKCkgeyB0aGlzLmNhbmNlbGVkID0gdHJ1ZTsgfVxcbiAgICB9O1xcbiAgICBpZiAodXBkYXRlKSBvYmoudXBkYXRlID0gZnVuY3Rpb24oZnJvbSwgdG8sIHRleHQsIG9yaWdpbikge1xcbiAgICAgIGlmIChmcm9tKSB0aGlzLmZyb20gPSBjbGlwUG9zKGRvYywgZnJvbSk7XFxuICAgICAgaWYgKHRvKSB0aGlzLnRvID0gY2xpcFBvcyhkb2MsIHRvKTtcXG4gICAgICBpZiAodGV4dCkgdGhpcy50ZXh0ID0gdGV4dDtcXG4gICAgICBpZiAob3JpZ2luICE9PSB1bmRlZmluZWQpIHRoaXMub3JpZ2luID0gb3JpZ2luO1xcbiAgICB9O1xcbiAgICBzaWduYWwoZG9jLCBcXFwiYmVmb3JlQ2hhbmdlXFxcIiwgZG9jLCBvYmopO1xcbiAgICBpZiAoZG9jLmNtKSBzaWduYWwoZG9jLmNtLCBcXFwiYmVmb3JlQ2hhbmdlXFxcIiwgZG9jLmNtLCBvYmopO1xcblxcbiAgICBpZiAob2JqLmNhbmNlbGVkKSByZXR1cm4gbnVsbDtcXG4gICAgcmV0dXJuIHtmcm9tOiBvYmouZnJvbSwgdG86IG9iai50bywgdGV4dDogb2JqLnRleHQsIG9yaWdpbjogb2JqLm9yaWdpbn07XFxuICB9XFxuXFxuICAvLyBBcHBseSBhIGNoYW5nZSB0byBhIGRvY3VtZW50LCBhbmQgYWRkIGl0IHRvIHRoZSBkb2N1bWVudCdzXFxuICAvLyBoaXN0b3J5LCBhbmQgcHJvcGFnYXRpbmcgaXQgdG8gYWxsIGxpbmtlZCBkb2N1bWVudHMuXFxuICBmdW5jdGlvbiBtYWtlQ2hhbmdlKGRvYywgY2hhbmdlLCBpZ25vcmVSZWFkT25seSkge1xcbiAgICBpZiAoZG9jLmNtKSB7XFxuICAgICAgaWYgKCFkb2MuY20uY3VyT3ApIHJldHVybiBvcGVyYXRpb24oZG9jLmNtLCBtYWtlQ2hhbmdlKShkb2MsIGNoYW5nZSwgaWdub3JlUmVhZE9ubHkpO1xcbiAgICAgIGlmIChkb2MuY20uc3RhdGUuc3VwcHJlc3NFZGl0cykgcmV0dXJuO1xcbiAgICB9XFxuXFxuICAgIGlmIChoYXNIYW5kbGVyKGRvYywgXFxcImJlZm9yZUNoYW5nZVxcXCIpIHx8IGRvYy5jbSAmJiBoYXNIYW5kbGVyKGRvYy5jbSwgXFxcImJlZm9yZUNoYW5nZVxcXCIpKSB7XFxuICAgICAgY2hhbmdlID0gZmlsdGVyQ2hhbmdlKGRvYywgY2hhbmdlLCB0cnVlKTtcXG4gICAgICBpZiAoIWNoYW5nZSkgcmV0dXJuO1xcbiAgICB9XFxuXFxuICAgIC8vIFBvc3NpYmx5IHNwbGl0IG9yIHN1cHByZXNzIHRoZSB1cGRhdGUgYmFzZWQgb24gdGhlIHByZXNlbmNlXFxuICAgIC8vIG9mIHJlYWQtb25seSBzcGFucyBpbiBpdHMgcmFuZ2UuXFxuICAgIHZhciBzcGxpdCA9IHNhd1JlYWRPbmx5U3BhbnMgJiYgIWlnbm9yZVJlYWRPbmx5ICYmIHJlbW92ZVJlYWRPbmx5UmFuZ2VzKGRvYywgY2hhbmdlLmZyb20sIGNoYW5nZS50byk7XFxuICAgIGlmIChzcGxpdCkge1xcbiAgICAgIGZvciAodmFyIGkgPSBzcGxpdC5sZW5ndGggLSAxOyBpID49IDA7IC0taSlcXG4gICAgICAgIG1ha2VDaGFuZ2VJbm5lcihkb2MsIHtmcm9tOiBzcGxpdFtpXS5mcm9tLCB0bzogc3BsaXRbaV0udG8sIHRleHQ6IGkgPyBbXFxcIlxcXCJdIDogY2hhbmdlLnRleHR9KTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICBtYWtlQ2hhbmdlSW5uZXIoZG9jLCBjaGFuZ2UpO1xcbiAgICB9XFxuICB9XFxuXFxuICBmdW5jdGlvbiBtYWtlQ2hhbmdlSW5uZXIoZG9jLCBjaGFuZ2UpIHtcXG4gICAgaWYgKGNoYW5nZS50ZXh0Lmxlbmd0aCA9PSAxICYmIGNoYW5nZS50ZXh0WzBdID09IFxcXCJcXFwiICYmIGNtcChjaGFuZ2UuZnJvbSwgY2hhbmdlLnRvKSA9PSAwKSByZXR1cm47XFxuICAgIHZhciBzZWxBZnRlciA9IGNvbXB1dGVTZWxBZnRlckNoYW5nZShkb2MsIGNoYW5nZSk7XFxuICAgIGFkZENoYW5nZVRvSGlzdG9yeShkb2MsIGNoYW5nZSwgc2VsQWZ0ZXIsIGRvYy5jbSA/IGRvYy5jbS5jdXJPcC5pZCA6IE5hTik7XFxuXFxuICAgIG1ha2VDaGFuZ2VTaW5nbGVEb2MoZG9jLCBjaGFuZ2UsIHNlbEFmdGVyLCBzdHJldGNoU3BhbnNPdmVyQ2hhbmdlKGRvYywgY2hhbmdlKSk7XFxuICAgIHZhciByZWJhc2VkID0gW107XFxuXFxuICAgIGxpbmtlZERvY3MoZG9jLCBmdW5jdGlvbihkb2MsIHNoYXJlZEhpc3QpIHtcXG4gICAgICBpZiAoIXNoYXJlZEhpc3QgJiYgaW5kZXhPZihyZWJhc2VkLCBkb2MuaGlzdG9yeSkgPT0gLTEpIHtcXG4gICAgICAgIHJlYmFzZUhpc3QoZG9jLmhpc3RvcnksIGNoYW5nZSk7XFxuICAgICAgICByZWJhc2VkLnB1c2goZG9jLmhpc3RvcnkpO1xcbiAgICAgIH1cXG4gICAgICBtYWtlQ2hhbmdlU2luZ2xlRG9jKGRvYywgY2hhbmdlLCBudWxsLCBzdHJldGNoU3BhbnNPdmVyQ2hhbmdlKGRvYywgY2hhbmdlKSk7XFxuICAgIH0pO1xcbiAgfVxcblxcbiAgLy8gUmV2ZXJ0IGEgY2hhbmdlIHN0b3JlZCBpbiBhIGRvY3VtZW50J3MgaGlzdG9yeS5cXG4gIGZ1bmN0aW9uIG1ha2VDaGFuZ2VGcm9tSGlzdG9yeShkb2MsIHR5cGUsIGFsbG93U2VsZWN0aW9uT25seSkge1xcbiAgICBpZiAoZG9jLmNtICYmIGRvYy5jbS5zdGF0ZS5zdXBwcmVzc0VkaXRzICYmICFhbGxvd1NlbGVjdGlvbk9ubHkpIHJldHVybjtcXG5cXG4gICAgdmFyIGhpc3QgPSBkb2MuaGlzdG9yeSwgZXZlbnQsIHNlbEFmdGVyID0gZG9jLnNlbDtcXG4gICAgdmFyIHNvdXJjZSA9IHR5cGUgPT0gXFxcInVuZG9cXFwiID8gaGlzdC5kb25lIDogaGlzdC51bmRvbmUsIGRlc3QgPSB0eXBlID09IFxcXCJ1bmRvXFxcIiA/IGhpc3QudW5kb25lIDogaGlzdC5kb25lO1xcblxcbiAgICAvLyBWZXJpZnkgdGhhdCB0aGVyZSBpcyBhIHVzZWFibGUgZXZlbnQgKHNvIHRoYXQgY3RybC16IHdvbid0XFxuICAgIC8vIG5lZWRsZXNzbHkgY2xlYXIgc2VsZWN0aW9uIGV2ZW50cylcXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzb3VyY2UubGVuZ3RoOyBpKyspIHtcXG4gICAgICBldmVudCA9IHNvdXJjZVtpXTtcXG4gICAgICBpZiAoYWxsb3dTZWxlY3Rpb25Pbmx5ID8gZXZlbnQucmFuZ2VzICYmICFldmVudC5lcXVhbHMoZG9jLnNlbCkgOiAhZXZlbnQucmFuZ2VzKVxcbiAgICAgICAgYnJlYWs7XFxuICAgIH1cXG4gICAgaWYgKGkgPT0gc291cmNlLmxlbmd0aCkgcmV0dXJuO1xcbiAgICBoaXN0Lmxhc3RPcmlnaW4gPSBoaXN0Lmxhc3RTZWxPcmlnaW4gPSBudWxsO1xcblxcbiAgICBmb3IgKDs7KSB7XFxuICAgICAgZXZlbnQgPSBzb3VyY2UucG9wKCk7XFxuICAgICAgaWYgKGV2ZW50LnJhbmdlcykge1xcbiAgICAgICAgcHVzaFNlbGVjdGlvblRvSGlzdG9yeShldmVudCwgZGVzdCk7XFxuICAgICAgICBpZiAoYWxsb3dTZWxlY3Rpb25Pbmx5ICYmICFldmVudC5lcXVhbHMoZG9jLnNlbCkpIHtcXG4gICAgICAgICAgc2V0U2VsZWN0aW9uKGRvYywgZXZlbnQsIHtjbGVhclJlZG86IGZhbHNlfSk7XFxuICAgICAgICAgIHJldHVybjtcXG4gICAgICAgIH1cXG4gICAgICAgIHNlbEFmdGVyID0gZXZlbnQ7XFxuICAgICAgfVxcbiAgICAgIGVsc2UgYnJlYWs7XFxuICAgIH1cXG5cXG4gICAgLy8gQnVpbGQgdXAgYSByZXZlcnNlIGNoYW5nZSBvYmplY3QgdG8gYWRkIHRvIHRoZSBvcHBvc2l0ZSBoaXN0b3J5XFxuICAgIC8vIHN0YWNrIChyZWRvIHdoZW4gdW5kb2luZywgYW5kIHZpY2UgdmVyc2EpLlxcbiAgICB2YXIgYW50aUNoYW5nZXMgPSBbXTtcXG4gICAgcHVzaFNlbGVjdGlvblRvSGlzdG9yeShzZWxBZnRlciwgZGVzdCk7XFxuICAgIGRlc3QucHVzaCh7Y2hhbmdlczogYW50aUNoYW5nZXMsIGdlbmVyYXRpb246IGhpc3QuZ2VuZXJhdGlvbn0pO1xcbiAgICBoaXN0LmdlbmVyYXRpb24gPSBldmVudC5nZW5lcmF0aW9uIHx8ICsraGlzdC5tYXhHZW5lcmF0aW9uO1xcblxcbiAgICB2YXIgZmlsdGVyID0gaGFzSGFuZGxlcihkb2MsIFxcXCJiZWZvcmVDaGFuZ2VcXFwiKSB8fCBkb2MuY20gJiYgaGFzSGFuZGxlcihkb2MuY20sIFxcXCJiZWZvcmVDaGFuZ2VcXFwiKTtcXG5cXG4gICAgZm9yICh2YXIgaSA9IGV2ZW50LmNoYW5nZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcXG4gICAgICB2YXIgY2hhbmdlID0gZXZlbnQuY2hhbmdlc1tpXTtcXG4gICAgICBjaGFuZ2Uub3JpZ2luID0gdHlwZTtcXG4gICAgICBpZiAoZmlsdGVyICYmICFmaWx0ZXJDaGFuZ2UoZG9jLCBjaGFuZ2UsIGZhbHNlKSkge1xcbiAgICAgICAgc291cmNlLmxlbmd0aCA9IDA7XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfVxcblxcbiAgICAgIGFudGlDaGFuZ2VzLnB1c2goaGlzdG9yeUNoYW5nZUZyb21DaGFuZ2UoZG9jLCBjaGFuZ2UpKTtcXG5cXG4gICAgICB2YXIgYWZ0ZXIgPSBpID8gY29tcHV0ZVNlbEFmdGVyQ2hhbmdlKGRvYywgY2hhbmdlKSA6IGxzdChzb3VyY2UpO1xcbiAgICAgIG1ha2VDaGFuZ2VTaW5nbGVEb2MoZG9jLCBjaGFuZ2UsIGFmdGVyLCBtZXJnZU9sZFNwYW5zKGRvYywgY2hhbmdlKSk7XFxuICAgICAgaWYgKCFpICYmIGRvYy5jbSkgZG9jLmNtLnNjcm9sbEludG9WaWV3KHtmcm9tOiBjaGFuZ2UuZnJvbSwgdG86IGNoYW5nZUVuZChjaGFuZ2UpfSk7XFxuICAgICAgdmFyIHJlYmFzZWQgPSBbXTtcXG5cXG4gICAgICAvLyBQcm9wYWdhdGUgdG8gdGhlIGxpbmtlZCBkb2N1bWVudHNcXG4gICAgICBsaW5rZWREb2NzKGRvYywgZnVuY3Rpb24oZG9jLCBzaGFyZWRIaXN0KSB7XFxuICAgICAgICBpZiAoIXNoYXJlZEhpc3QgJiYgaW5kZXhPZihyZWJhc2VkLCBkb2MuaGlzdG9yeSkgPT0gLTEpIHtcXG4gICAgICAgICAgcmViYXNlSGlzdChkb2MuaGlzdG9yeSwgY2hhbmdlKTtcXG4gICAgICAgICAgcmViYXNlZC5wdXNoKGRvYy5oaXN0b3J5KTtcXG4gICAgICAgIH1cXG4gICAgICAgIG1ha2VDaGFuZ2VTaW5nbGVEb2MoZG9jLCBjaGFuZ2UsIG51bGwsIG1lcmdlT2xkU3BhbnMoZG9jLCBjaGFuZ2UpKTtcXG4gICAgICB9KTtcXG4gICAgfVxcbiAgfVxcblxcbiAgLy8gU3ViLXZpZXdzIG5lZWQgdGhlaXIgbGluZSBudW1iZXJzIHNoaWZ0ZWQgd2hlbiB0ZXh0IGlzIGFkZGVkXFxuICAvLyBhYm92ZSBvciBiZWxvdyB0aGVtIGluIHRoZSBwYXJlbnQgZG9jdW1lbnQuXFxuICBmdW5jdGlvbiBzaGlmdERvYyhkb2MsIGRpc3RhbmNlKSB7XFxuICAgIGlmIChkaXN0YW5jZSA9PSAwKSByZXR1cm47XFxuICAgIGRvYy5maXJzdCArPSBkaXN0YW5jZTtcXG4gICAgZG9jLnNlbCA9IG5ldyBTZWxlY3Rpb24obWFwKGRvYy5zZWwucmFuZ2VzLCBmdW5jdGlvbihyYW5nZSkge1xcbiAgICAgIHJldHVybiBuZXcgUmFuZ2UoUG9zKHJhbmdlLmFuY2hvci5saW5lICsgZGlzdGFuY2UsIHJhbmdlLmFuY2hvci5jaCksXFxuICAgICAgICAgICAgICAgICAgICAgICBQb3MocmFuZ2UuaGVhZC5saW5lICsgZGlzdGFuY2UsIHJhbmdlLmhlYWQuY2gpKTtcXG4gICAgfSksIGRvYy5zZWwucHJpbUluZGV4KTtcXG4gICAgaWYgKGRvYy5jbSkge1xcbiAgICAgIHJlZ0NoYW5nZShkb2MuY20sIGRvYy5maXJzdCwgZG9jLmZpcnN0IC0gZGlzdGFuY2UsIGRpc3RhbmNlKTtcXG4gICAgICBmb3IgKHZhciBkID0gZG9jLmNtLmRpc3BsYXksIGwgPSBkLnZpZXdGcm9tOyBsIDwgZC52aWV3VG87IGwrKylcXG4gICAgICAgIHJlZ0xpbmVDaGFuZ2UoZG9jLmNtLCBsLCBcXFwiZ3V0dGVyXFxcIik7XFxuICAgIH1cXG4gIH1cXG5cXG4gIC8vIE1vcmUgbG93ZXItbGV2ZWwgY2hhbmdlIGZ1bmN0aW9uLCBoYW5kbGluZyBvbmx5IGEgc2luZ2xlIGRvY3VtZW50XFxuICAvLyAobm90IGxpbmtlZCBvbmVzKS5cXG4gIGZ1bmN0aW9uIG1ha2VDaGFuZ2VTaW5nbGVEb2MoZG9jLCBjaGFuZ2UsIHNlbEFmdGVyLCBzcGFucykge1xcbiAgICBpZiAoZG9jLmNtICYmICFkb2MuY20uY3VyT3ApXFxuICAgICAgcmV0dXJuIG9wZXJhdGlvbihkb2MuY20sIG1ha2VDaGFuZ2VTaW5nbGVEb2MpKGRvYywgY2hhbmdlLCBzZWxBZnRlciwgc3BhbnMpO1xcblxcbiAgICBpZiAoY2hhbmdlLnRvLmxpbmUgPCBkb2MuZmlyc3QpIHtcXG4gICAgICBzaGlmdERvYyhkb2MsIGNoYW5nZS50ZXh0Lmxlbmd0aCAtIDEgLSAoY2hhbmdlLnRvLmxpbmUgLSBjaGFuZ2UuZnJvbS5saW5lKSk7XFxuICAgICAgcmV0dXJuO1xcbiAgICB9XFxuICAgIGlmIChjaGFuZ2UuZnJvbS5saW5lID4gZG9jLmxhc3RMaW5lKCkpIHJldHVybjtcXG5cXG4gICAgLy8gQ2xpcCB0aGUgY2hhbmdlIHRvIHRoZSBzaXplIG9mIHRoaXMgZG9jXFxuICAgIGlmIChjaGFuZ2UuZnJvbS5saW5lIDwgZG9jLmZpcnN0KSB7XFxuICAgICAgdmFyIHNoaWZ0ID0gY2hhbmdlLnRleHQubGVuZ3RoIC0gMSAtIChkb2MuZmlyc3QgLSBjaGFuZ2UuZnJvbS5saW5lKTtcXG4gICAgICBzaGlmdERvYyhkb2MsIHNoaWZ0KTtcXG4gICAgICBjaGFuZ2UgPSB7ZnJvbTogUG9zKGRvYy5maXJzdCwgMCksIHRvOiBQb3MoY2hhbmdlLnRvLmxpbmUgKyBzaGlmdCwgY2hhbmdlLnRvLmNoKSxcXG4gICAgICAgICAgICAgICAgdGV4dDogW2xzdChjaGFuZ2UudGV4dCldLCBvcmlnaW46IGNoYW5nZS5vcmlnaW59O1xcbiAgICB9XFxuICAgIHZhciBsYXN0ID0gZG9jLmxhc3RMaW5lKCk7XFxuICAgIGlmIChjaGFuZ2UudG8ubGluZSA+IGxhc3QpIHtcXG4gICAgICBjaGFuZ2UgPSB7ZnJvbTogY2hhbmdlLmZyb20sIHRvOiBQb3MobGFzdCwgZ2V0TGluZShkb2MsIGxhc3QpLnRleHQubGVuZ3RoKSxcXG4gICAgICAgICAgICAgICAgdGV4dDogW2NoYW5nZS50ZXh0WzBdXSwgb3JpZ2luOiBjaGFuZ2Uub3JpZ2lufTtcXG4gICAgfVxcblxcbiAgICBjaGFuZ2UucmVtb3ZlZCA9IGdldEJldHdlZW4oZG9jLCBjaGFuZ2UuZnJvbSwgY2hhbmdlLnRvKTtcXG5cXG4gICAgaWYgKCFzZWxBZnRlcikgc2VsQWZ0ZXIgPSBjb21wdXRlU2VsQWZ0ZXJDaGFuZ2UoZG9jLCBjaGFuZ2UpO1xcbiAgICBpZiAoZG9jLmNtKSBtYWtlQ2hhbmdlU2luZ2xlRG9jSW5FZGl0b3IoZG9jLmNtLCBjaGFuZ2UsIHNwYW5zKTtcXG4gICAgZWxzZSB1cGRhdGVEb2MoZG9jLCBjaGFuZ2UsIHNwYW5zKTtcXG4gICAgc2V0U2VsZWN0aW9uTm9VbmRvKGRvYywgc2VsQWZ0ZXIsIHNlbF9kb250U2Nyb2xsKTtcXG4gIH1cXG5cXG4gIC8vIEhhbmRsZSB0aGUgaW50ZXJhY3Rpb24gb2YgYSBjaGFuZ2UgdG8gYSBkb2N1bWVudCB3aXRoIHRoZSBlZGl0b3JcXG4gIC8vIHRoYXQgdGhpcyBkb2N1bWVudCBpcyBwYXJ0IG9mLlxcbiAgZnVuY3Rpb24gbWFrZUNoYW5nZVNpbmdsZURvY0luRWRpdG9yKGNtLCBjaGFuZ2UsIHNwYW5zKSB7XFxuICAgIHZhciBkb2MgPSBjbS5kb2MsIGRpc3BsYXkgPSBjbS5kaXNwbGF5LCBmcm9tID0gY2hhbmdlLmZyb20sIHRvID0gY2hhbmdlLnRvO1xcblxcbiAgICB2YXIgcmVjb21wdXRlTWF4TGVuZ3RoID0gZmFsc2UsIGNoZWNrV2lkdGhTdGFydCA9IGZyb20ubGluZTtcXG4gICAgaWYgKCFjbS5vcHRpb25zLmxpbmVXcmFwcGluZykge1xcbiAgICAgIGNoZWNrV2lkdGhTdGFydCA9IGxpbmVObyh2aXN1YWxMaW5lKGdldExpbmUoZG9jLCBmcm9tLmxpbmUpKSk7XFxuICAgICAgZG9jLml0ZXIoY2hlY2tXaWR0aFN0YXJ0LCB0by5saW5lICsgMSwgZnVuY3Rpb24obGluZSkge1xcbiAgICAgICAgaWYgKGxpbmUgPT0gZGlzcGxheS5tYXhMaW5lKSB7XFxuICAgICAgICAgIHJlY29tcHV0ZU1heExlbmd0aCA9IHRydWU7XFxuICAgICAgICAgIHJldHVybiB0cnVlO1xcbiAgICAgICAgfVxcbiAgICAgIH0pO1xcbiAgICB9XFxuXFxuICAgIGlmIChkb2Muc2VsLmNvbnRhaW5zKGNoYW5nZS5mcm9tLCBjaGFuZ2UudG8pID4gLTEpXFxuICAgICAgc2lnbmFsQ3Vyc29yQWN0aXZpdHkoY20pO1xcblxcbiAgICB1cGRhdGVEb2MoZG9jLCBjaGFuZ2UsIHNwYW5zLCBlc3RpbWF0ZUhlaWdodChjbSkpO1xcblxcbiAgICBpZiAoIWNtLm9wdGlvbnMubGluZVdyYXBwaW5nKSB7XFxuICAgICAgZG9jLml0ZXIoY2hlY2tXaWR0aFN0YXJ0LCBmcm9tLmxpbmUgKyBjaGFuZ2UudGV4dC5sZW5ndGgsIGZ1bmN0aW9uKGxpbmUpIHtcXG4gICAgICAgIHZhciBsZW4gPSBsaW5lTGVuZ3RoKGxpbmUpO1xcbiAgICAgICAgaWYgKGxlbiA+IGRpc3BsYXkubWF4TGluZUxlbmd0aCkge1xcbiAgICAgICAgICBkaXNwbGF5Lm1heExpbmUgPSBsaW5lO1xcbiAgICAgICAgICBkaXNwbGF5Lm1heExpbmVMZW5ndGggPSBsZW47XFxuICAgICAgICAgIGRpc3BsYXkubWF4TGluZUNoYW5nZWQgPSB0cnVlO1xcbiAgICAgICAgICByZWNvbXB1dGVNYXhMZW5ndGggPSBmYWxzZTtcXG4gICAgICAgIH1cXG4gICAgICB9KTtcXG4gICAgICBpZiAocmVjb21wdXRlTWF4TGVuZ3RoKSBjbS5jdXJPcC51cGRhdGVNYXhMaW5lID0gdHJ1ZTtcXG4gICAgfVxcblxcbiAgICAvLyBBZGp1c3QgZnJvbnRpZXIsIHNjaGVkdWxlIHdvcmtlclxcbiAgICBkb2MuZnJvbnRpZXIgPSBNYXRoLm1pbihkb2MuZnJvbnRpZXIsIGZyb20ubGluZSk7XFxuICAgIHN0YXJ0V29ya2VyKGNtLCA0MDApO1xcblxcbiAgICB2YXIgbGVuZGlmZiA9IGNoYW5nZS50ZXh0Lmxlbmd0aCAtICh0by5saW5lIC0gZnJvbS5saW5lKSAtIDE7XFxuICAgIC8vIFJlbWVtYmVyIHRoYXQgdGhlc2UgbGluZXMgY2hhbmdlZCwgZm9yIHVwZGF0aW5nIHRoZSBkaXNwbGF5XFxuICAgIGlmIChjaGFuZ2UuZnVsbClcXG4gICAgICByZWdDaGFuZ2UoY20pO1xcbiAgICBlbHNlIGlmIChmcm9tLmxpbmUgPT0gdG8ubGluZSAmJiBjaGFuZ2UudGV4dC5sZW5ndGggPT0gMSAmJiAhaXNXaG9sZUxpbmVVcGRhdGUoY20uZG9jLCBjaGFuZ2UpKVxcbiAgICAgIHJlZ0xpbmVDaGFuZ2UoY20sIGZyb20ubGluZSwgXFxcInRleHRcXFwiKTtcXG4gICAgZWxzZVxcbiAgICAgIHJlZ0NoYW5nZShjbSwgZnJvbS5saW5lLCB0by5saW5lICsgMSwgbGVuZGlmZik7XFxuXFxuICAgIHZhciBjaGFuZ2VzSGFuZGxlciA9IGhhc0hhbmRsZXIoY20sIFxcXCJjaGFuZ2VzXFxcIiksIGNoYW5nZUhhbmRsZXIgPSBoYXNIYW5kbGVyKGNtLCBcXFwiY2hhbmdlXFxcIik7XFxuICAgIGlmIChjaGFuZ2VIYW5kbGVyIHx8IGNoYW5nZXNIYW5kbGVyKSB7XFxuICAgICAgdmFyIG9iaiA9IHtcXG4gICAgICAgIGZyb206IGZyb20sIHRvOiB0byxcXG4gICAgICAgIHRleHQ6IGNoYW5nZS50ZXh0LFxcbiAgICAgICAgcmVtb3ZlZDogY2hhbmdlLnJlbW92ZWQsXFxuICAgICAgICBvcmlnaW46IGNoYW5nZS5vcmlnaW5cXG4gICAgICB9O1xcbiAgICAgIGlmIChjaGFuZ2VIYW5kbGVyKSBzaWduYWxMYXRlcihjbSwgXFxcImNoYW5nZVxcXCIsIGNtLCBvYmopO1xcbiAgICAgIGlmIChjaGFuZ2VzSGFuZGxlcikgKGNtLmN1ck9wLmNoYW5nZU9ianMgfHwgKGNtLmN1ck9wLmNoYW5nZU9ianMgPSBbXSkpLnB1c2gob2JqKTtcXG4gICAgfVxcbiAgICBjbS5kaXNwbGF5LnNlbEZvckNvbnRleHRNZW51ID0gbnVsbDtcXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIHJlcGxhY2VSYW5nZShkb2MsIGNvZGUsIGZyb20sIHRvLCBvcmlnaW4pIHtcXG4gICAgaWYgKCF0bykgdG8gPSBmcm9tO1xcbiAgICBpZiAoY21wKHRvLCBmcm9tKSA8IDApIHsgdmFyIHRtcCA9IHRvOyB0byA9IGZyb207IGZyb20gPSB0bXA7IH1cXG4gICAgaWYgKHR5cGVvZiBjb2RlID09IFxcXCJzdHJpbmdcXFwiKSBjb2RlID0gZG9jLnNwbGl0TGluZXMoY29kZSk7XFxuICAgIG1ha2VDaGFuZ2UoZG9jLCB7ZnJvbTogZnJvbSwgdG86IHRvLCB0ZXh0OiBjb2RlLCBvcmlnaW46IG9yaWdpbn0pO1xcbiAgfVxcblxcbiAgLy8gU0NST0xMSU5HIFRISU5HUyBJTlRPIFZJRVdcXG5cXG4gIC8vIElmIGFuIGVkaXRvciBzaXRzIG9uIHRoZSB0b3Agb3IgYm90dG9tIG9mIHRoZSB3aW5kb3csIHBhcnRpYWxseVxcbiAgLy8gc2Nyb2xsZWQgb3V0IG9mIHZpZXcsIHRoaXMgZW5zdXJlcyB0aGF0IHRoZSBjdXJzb3IgaXMgdmlzaWJsZS5cXG4gIGZ1bmN0aW9uIG1heWJlU2Nyb2xsV2luZG93KGNtLCBjb29yZHMpIHtcXG4gICAgaWYgKHNpZ25hbERPTUV2ZW50KGNtLCBcXFwic2Nyb2xsQ3Vyc29ySW50b1ZpZXdcXFwiKSkgcmV0dXJuO1xcblxcbiAgICB2YXIgZGlzcGxheSA9IGNtLmRpc3BsYXksIGJveCA9IGRpc3BsYXkuc2l6ZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIGRvU2Nyb2xsID0gbnVsbDtcXG4gICAgaWYgKGNvb3Jkcy50b3AgKyBib3gudG9wIDwgMCkgZG9TY3JvbGwgPSB0cnVlO1xcbiAgICBlbHNlIGlmIChjb29yZHMuYm90dG9tICsgYm94LnRvcCA+ICh3aW5kb3cuaW5uZXJIZWlnaHQgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodCkpIGRvU2Nyb2xsID0gZmFsc2U7XFxuICAgIGlmIChkb1Njcm9sbCAhPSBudWxsICYmICFwaGFudG9tKSB7XFxuICAgICAgdmFyIHNjcm9sbE5vZGUgPSBlbHQoXFxcImRpdlxcXCIsIFxcXCJcXFxcdTIwMGJcXFwiLCBudWxsLCBcXFwicG9zaXRpb246IGFic29sdXRlOyB0b3A6IFxcXCIgK1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIChjb29yZHMudG9wIC0gZGlzcGxheS52aWV3T2Zmc2V0IC0gcGFkZGluZ1RvcChjbS5kaXNwbGF5KSkgKyBcXFwicHg7IGhlaWdodDogXFxcIiArXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgKGNvb3Jkcy5ib3R0b20gLSBjb29yZHMudG9wICsgc2Nyb2xsR2FwKGNtKSArIGRpc3BsYXkuYmFySGVpZ2h0KSArIFxcXCJweDsgbGVmdDogXFxcIiArXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgY29vcmRzLmxlZnQgKyBcXFwicHg7IHdpZHRoOiAycHg7XFxcIik7XFxuICAgICAgY20uZGlzcGxheS5saW5lU3BhY2UuYXBwZW5kQ2hpbGQoc2Nyb2xsTm9kZSk7XFxuICAgICAgc2Nyb2xsTm9kZS5zY3JvbGxJbnRvVmlldyhkb1Njcm9sbCk7XFxuICAgICAgY20uZGlzcGxheS5saW5lU3BhY2UucmVtb3ZlQ2hpbGQoc2Nyb2xsTm9kZSk7XFxuICAgIH1cXG4gIH1cXG5cXG4gIC8vIFNjcm9sbCBhIGdpdmVuIHBvc2l0aW9uIGludG8gdmlldyAoaW1tZWRpYXRlbHkpLCB2ZXJpZnlpbmcgdGhhdFxcbiAgLy8gaXQgYWN0dWFsbHkgYmVjYW1lIHZpc2libGUgKGFzIGxpbmUgaGVpZ2h0cyBhcmUgYWNjdXJhdGVseVxcbiAgLy8gbWVhc3VyZWQsIHRoZSBwb3NpdGlvbiBvZiBzb21ldGhpbmcgbWF5ICdkcmlmdCcgZHVyaW5nIGRyYXdpbmcpLlxcbiAgZnVuY3Rpb24gc2Nyb2xsUG9zSW50b1ZpZXcoY20sIHBvcywgZW5kLCBtYXJnaW4pIHtcXG4gICAgaWYgKG1hcmdpbiA9PSBudWxsKSBtYXJnaW4gPSAwO1xcbiAgICBmb3IgKHZhciBsaW1pdCA9IDA7IGxpbWl0IDwgNTsgbGltaXQrKykge1xcbiAgICAgIHZhciBjaGFuZ2VkID0gZmFsc2UsIGNvb3JkcyA9IGN1cnNvckNvb3JkcyhjbSwgcG9zKTtcXG4gICAgICB2YXIgZW5kQ29vcmRzID0gIWVuZCB8fCBlbmQgPT0gcG9zID8gY29vcmRzIDogY3Vyc29yQ29vcmRzKGNtLCBlbmQpO1xcbiAgICAgIHZhciBzY3JvbGxQb3MgPSBjYWxjdWxhdGVTY3JvbGxQb3MoY20sIE1hdGgubWluKGNvb3Jkcy5sZWZ0LCBlbmRDb29yZHMubGVmdCksXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBNYXRoLm1pbihjb29yZHMudG9wLCBlbmRDb29yZHMudG9wKSAtIG1hcmdpbixcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1hdGgubWF4KGNvb3Jkcy5sZWZ0LCBlbmRDb29yZHMubGVmdCksXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBNYXRoLm1heChjb29yZHMuYm90dG9tLCBlbmRDb29yZHMuYm90dG9tKSArIG1hcmdpbik7XFxuICAgICAgdmFyIHN0YXJ0VG9wID0gY20uZG9jLnNjcm9sbFRvcCwgc3RhcnRMZWZ0ID0gY20uZG9jLnNjcm9sbExlZnQ7XFxuICAgICAgaWYgKHNjcm9sbFBvcy5zY3JvbGxUb3AgIT0gbnVsbCkge1xcbiAgICAgICAgc2V0U2Nyb2xsVG9wKGNtLCBzY3JvbGxQb3Muc2Nyb2xsVG9wKTtcXG4gICAgICAgIGlmIChNYXRoLmFicyhjbS5kb2Muc2Nyb2xsVG9wIC0gc3RhcnRUb3ApID4gMSkgY2hhbmdlZCA9IHRydWU7XFxuICAgICAgfVxcbiAgICAgIGlmIChzY3JvbGxQb3Muc2Nyb2xsTGVmdCAhPSBudWxsKSB7XFxuICAgICAgICBzZXRTY3JvbGxMZWZ0KGNtLCBzY3JvbGxQb3Muc2Nyb2xsTGVmdCk7XFxuICAgICAgICBpZiAoTWF0aC5hYnMoY20uZG9jLnNjcm9sbExlZnQgLSBzdGFydExlZnQpID4gMSkgY2hhbmdlZCA9IHRydWU7XFxuICAgICAgfVxcbiAgICAgIGlmICghY2hhbmdlZCkgYnJlYWs7XFxuICAgIH1cXG4gICAgcmV0dXJuIGNvb3JkcztcXG4gIH1cXG5cXG4gIC8vIFNjcm9sbCBhIGdpdmVuIHNldCBvZiBjb29yZGluYXRlcyBpbnRvIHZpZXcgKGltbWVkaWF0ZWx5KS5cXG4gIGZ1bmN0aW9uIHNjcm9sbEludG9WaWV3KGNtLCB4MSwgeTEsIHgyLCB5Mikge1xcbiAgICB2YXIgc2Nyb2xsUG9zID0gY2FsY3VsYXRlU2Nyb2xsUG9zKGNtLCB4MSwgeTEsIHgyLCB5Mik7XFxuICAgIGlmIChzY3JvbGxQb3Muc2Nyb2xsVG9wICE9IG51bGwpIHNldFNjcm9sbFRvcChjbSwgc2Nyb2xsUG9zLnNjcm9sbFRvcCk7XFxuICAgIGlmIChzY3JvbGxQb3Muc2Nyb2xsTGVmdCAhPSBudWxsKSBzZXRTY3JvbGxMZWZ0KGNtLCBzY3JvbGxQb3Muc2Nyb2xsTGVmdCk7XFxuICB9XFxuXFxuICAvLyBDYWxjdWxhdGUgYSBuZXcgc2Nyb2xsIHBvc2l0aW9uIG5lZWRlZCB0byBzY3JvbGwgdGhlIGdpdmVuXFxuICAvLyByZWN0YW5nbGUgaW50byB2aWV3LiBSZXR1cm5zIGFuIG9iamVjdCB3aXRoIHNjcm9sbFRvcCBhbmRcXG4gIC8vIHNjcm9sbExlZnQgcHJvcGVydGllcy4gV2hlbiB0aGVzZSBhcmUgdW5kZWZpbmVkLCB0aGVcXG4gIC8vIHZlcnRpY2FsL2hvcml6b250YWwgcG9zaXRpb24gZG9lcyBub3QgbmVlZCB0byBiZSBhZGp1c3RlZC5cXG4gIGZ1bmN0aW9uIGNhbGN1bGF0ZVNjcm9sbFBvcyhjbSwgeDEsIHkxLCB4MiwgeTIpIHtcXG4gICAgdmFyIGRpc3BsYXkgPSBjbS5kaXNwbGF5LCBzbmFwTWFyZ2luID0gdGV4dEhlaWdodChjbS5kaXNwbGF5KTtcXG4gICAgaWYgKHkxIDwgMCkgeTEgPSAwO1xcbiAgICB2YXIgc2NyZWVudG9wID0gY20uY3VyT3AgJiYgY20uY3VyT3Auc2Nyb2xsVG9wICE9IG51bGwgPyBjbS5jdXJPcC5zY3JvbGxUb3AgOiBkaXNwbGF5LnNjcm9sbGVyLnNjcm9sbFRvcDtcXG4gICAgdmFyIHNjcmVlbiA9IGRpc3BsYXlIZWlnaHQoY20pLCByZXN1bHQgPSB7fTtcXG4gICAgaWYgKHkyIC0geTEgPiBzY3JlZW4pIHkyID0geTEgKyBzY3JlZW47XFxuICAgIHZhciBkb2NCb3R0b20gPSBjbS5kb2MuaGVpZ2h0ICsgcGFkZGluZ1ZlcnQoZGlzcGxheSk7XFxuICAgIHZhciBhdFRvcCA9IHkxIDwgc25hcE1hcmdpbiwgYXRCb3R0b20gPSB5MiA+IGRvY0JvdHRvbSAtIHNuYXBNYXJnaW47XFxuICAgIGlmICh5MSA8IHNjcmVlbnRvcCkge1xcbiAgICAgIHJlc3VsdC5zY3JvbGxUb3AgPSBhdFRvcCA/IDAgOiB5MTtcXG4gICAgfSBlbHNlIGlmICh5MiA+IHNjcmVlbnRvcCArIHNjcmVlbikge1xcbiAgICAgIHZhciBuZXdUb3AgPSBNYXRoLm1pbih5MSwgKGF0Qm90dG9tID8gZG9jQm90dG9tIDogeTIpIC0gc2NyZWVuKTtcXG4gICAgICBpZiAobmV3VG9wICE9IHNjcmVlbnRvcCkgcmVzdWx0LnNjcm9sbFRvcCA9IG5ld1RvcDtcXG4gICAgfVxcblxcbiAgICB2YXIgc2NyZWVubGVmdCA9IGNtLmN1ck9wICYmIGNtLmN1ck9wLnNjcm9sbExlZnQgIT0gbnVsbCA/IGNtLmN1ck9wLnNjcm9sbExlZnQgOiBkaXNwbGF5LnNjcm9sbGVyLnNjcm9sbExlZnQ7XFxuICAgIHZhciBzY3JlZW53ID0gZGlzcGxheVdpZHRoKGNtKSAtIChjbS5vcHRpb25zLmZpeGVkR3V0dGVyID8gZGlzcGxheS5ndXR0ZXJzLm9mZnNldFdpZHRoIDogMCk7XFxuICAgIHZhciB0b29XaWRlID0geDIgLSB4MSA+IHNjcmVlbnc7XFxuICAgIGlmICh0b29XaWRlKSB4MiA9IHgxICsgc2NyZWVudztcXG4gICAgaWYgKHgxIDwgMTApXFxuICAgICAgcmVzdWx0LnNjcm9sbExlZnQgPSAwO1xcbiAgICBlbHNlIGlmICh4MSA8IHNjcmVlbmxlZnQpXFxuICAgICAgcmVzdWx0LnNjcm9sbExlZnQgPSBNYXRoLm1heCgwLCB4MSAtICh0b29XaWRlID8gMCA6IDEwKSk7XFxuICAgIGVsc2UgaWYgKHgyID4gc2NyZWVudyArIHNjcmVlbmxlZnQgLSAzKVxcbiAgICAgIHJlc3VsdC5zY3JvbGxMZWZ0ID0geDIgKyAodG9vV2lkZSA/IDAgOiAxMCkgLSBzY3JlZW53O1xcbiAgICByZXR1cm4gcmVzdWx0O1xcbiAgfVxcblxcbiAgLy8gU3RvcmUgYSByZWxhdGl2ZSBhZGp1c3RtZW50IHRvIHRoZSBzY3JvbGwgcG9zaXRpb24gaW4gdGhlIGN1cnJlbnRcXG4gIC8vIG9wZXJhdGlvbiAodG8gYmUgYXBwbGllZCB3aGVuIHRoZSBvcGVyYXRpb24gZmluaXNoZXMpLlxcbiAgZnVuY3Rpb24gYWRkVG9TY3JvbGxQb3MoY20sIGxlZnQsIHRvcCkge1xcbiAgICBpZiAobGVmdCAhPSBudWxsIHx8IHRvcCAhPSBudWxsKSByZXNvbHZlU2Nyb2xsVG9Qb3MoY20pO1xcbiAgICBpZiAobGVmdCAhPSBudWxsKVxcbiAgICAgIGNtLmN1ck9wLnNjcm9sbExlZnQgPSAoY20uY3VyT3Auc2Nyb2xsTGVmdCA9PSBudWxsID8gY20uZG9jLnNjcm9sbExlZnQgOiBjbS5jdXJPcC5zY3JvbGxMZWZ0KSArIGxlZnQ7XFxuICAgIGlmICh0b3AgIT0gbnVsbClcXG4gICAgICBjbS5jdXJPcC5zY3JvbGxUb3AgPSAoY20uY3VyT3Auc2Nyb2xsVG9wID09IG51bGwgPyBjbS5kb2Muc2Nyb2xsVG9wIDogY20uY3VyT3Auc2Nyb2xsVG9wKSArIHRvcDtcXG4gIH1cXG5cXG4gIC8vIE1ha2Ugc3VyZSB0aGF0IGF0IHRoZSBlbmQgb2YgdGhlIG9wZXJhdGlvbiB0aGUgY3VycmVudCBjdXJzb3IgaXNcXG4gIC8vIHNob3duLlxcbiAgZnVuY3Rpb24gZW5zdXJlQ3Vyc29yVmlzaWJsZShjbSkge1xcbiAgICByZXNvbHZlU2Nyb2xsVG9Qb3MoY20pO1xcbiAgICB2YXIgY3VyID0gY20uZ2V0Q3Vyc29yKCksIGZyb20gPSBjdXIsIHRvID0gY3VyO1xcbiAgICBpZiAoIWNtLm9wdGlvbnMubGluZVdyYXBwaW5nKSB7XFxuICAgICAgZnJvbSA9IGN1ci5jaCA/IFBvcyhjdXIubGluZSwgY3VyLmNoIC0gMSkgOiBjdXI7XFxuICAgICAgdG8gPSBQb3MoY3VyLmxpbmUsIGN1ci5jaCArIDEpO1xcbiAgICB9XFxuICAgIGNtLmN1ck9wLnNjcm9sbFRvUG9zID0ge2Zyb206IGZyb20sIHRvOiB0bywgbWFyZ2luOiBjbS5vcHRpb25zLmN1cnNvclNjcm9sbE1hcmdpbiwgaXNDdXJzb3I6IHRydWV9O1xcbiAgfVxcblxcbiAgLy8gV2hlbiBhbiBvcGVyYXRpb24gaGFzIGl0cyBzY3JvbGxUb1BvcyBwcm9wZXJ0eSBzZXQsIGFuZCBhbm90aGVyXFxuICAvLyBzY3JvbGwgYWN0aW9uIGlzIGFwcGxpZWQgYmVmb3JlIHRoZSBlbmQgb2YgdGhlIG9wZXJhdGlvbiwgdGhpc1xcbiAgLy8gJ3NpbXVsYXRlcycgc2Nyb2xsaW5nIHRoYXQgcG9zaXRpb24gaW50byB2aWV3IGluIGEgY2hlYXAgd2F5LCBzb1xcbiAgLy8gdGhhdCB0aGUgZWZmZWN0IG9mIGludGVybWVkaWF0ZSBzY3JvbGwgY29tbWFuZHMgaXMgbm90IGlnbm9yZWQuXFxuICBmdW5jdGlvbiByZXNvbHZlU2Nyb2xsVG9Qb3MoY20pIHtcXG4gICAgdmFyIHJhbmdlID0gY20uY3VyT3Auc2Nyb2xsVG9Qb3M7XFxuICAgIGlmIChyYW5nZSkge1xcbiAgICAgIGNtLmN1ck9wLnNjcm9sbFRvUG9zID0gbnVsbDtcXG4gICAgICB2YXIgZnJvbSA9IGVzdGltYXRlQ29vcmRzKGNtLCByYW5nZS5mcm9tKSwgdG8gPSBlc3RpbWF0ZUNvb3JkcyhjbSwgcmFuZ2UudG8pO1xcbiAgICAgIHZhciBzUG9zID0gY2FsY3VsYXRlU2Nyb2xsUG9zKGNtLCBNYXRoLm1pbihmcm9tLmxlZnQsIHRvLmxlZnQpLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1hdGgubWluKGZyb20udG9wLCB0by50b3ApIC0gcmFuZ2UubWFyZ2luLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1hdGgubWF4KGZyb20ucmlnaHQsIHRvLnJpZ2h0KSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBNYXRoLm1heChmcm9tLmJvdHRvbSwgdG8uYm90dG9tKSArIHJhbmdlLm1hcmdpbik7XFxuICAgICAgY20uc2Nyb2xsVG8oc1Bvcy5zY3JvbGxMZWZ0LCBzUG9zLnNjcm9sbFRvcCk7XFxuICAgIH1cXG4gIH1cXG5cXG4gIC8vIEFQSSBVVElMSVRJRVNcXG5cXG4gIC8vIEluZGVudCB0aGUgZ2l2ZW4gbGluZS4gVGhlIGhvdyBwYXJhbWV0ZXIgY2FuIGJlIFxcXCJzbWFydFxcXCIsXFxuICAvLyBcXFwiYWRkXFxcIi9udWxsLCBcXFwic3VidHJhY3RcXFwiLCBvciBcXFwicHJldlxcXCIuIFdoZW4gYWdncmVzc2l2ZSBpcyBmYWxzZVxcbiAgLy8gKHR5cGljYWxseSBzZXQgdG8gdHJ1ZSBmb3IgZm9yY2VkIHNpbmdsZS1saW5lIGluZGVudHMpLCBlbXB0eVxcbiAgLy8gbGluZXMgYXJlIG5vdCBpbmRlbnRlZCwgYW5kIHBsYWNlcyB3aGVyZSB0aGUgbW9kZSByZXR1cm5zIFBhc3NcXG4gIC8vIGFyZSBsZWZ0IGFsb25lLlxcbiAgZnVuY3Rpb24gaW5kZW50TGluZShjbSwgbiwgaG93LCBhZ2dyZXNzaXZlKSB7XFxuICAgIHZhciBkb2MgPSBjbS5kb2MsIHN0YXRlO1xcbiAgICBpZiAoaG93ID09IG51bGwpIGhvdyA9IFxcXCJhZGRcXFwiO1xcbiAgICBpZiAoaG93ID09IFxcXCJzbWFydFxcXCIpIHtcXG4gICAgICAvLyBGYWxsIGJhY2sgdG8gXFxcInByZXZcXFwiIHdoZW4gdGhlIG1vZGUgZG9lc24ndCBoYXZlIGFuIGluZGVudGF0aW9uXFxuICAgICAgLy8gbWV0aG9kLlxcbiAgICAgIGlmICghZG9jLm1vZGUuaW5kZW50KSBob3cgPSBcXFwicHJldlxcXCI7XFxuICAgICAgZWxzZSBzdGF0ZSA9IGdldFN0YXRlQmVmb3JlKGNtLCBuKTtcXG4gICAgfVxcblxcbiAgICB2YXIgdGFiU2l6ZSA9IGNtLm9wdGlvbnMudGFiU2l6ZTtcXG4gICAgdmFyIGxpbmUgPSBnZXRMaW5lKGRvYywgbiksIGN1clNwYWNlID0gY291bnRDb2x1bW4obGluZS50ZXh0LCBudWxsLCB0YWJTaXplKTtcXG4gICAgaWYgKGxpbmUuc3RhdGVBZnRlcikgbGluZS5zdGF0ZUFmdGVyID0gbnVsbDtcXG4gICAgdmFyIGN1clNwYWNlU3RyaW5nID0gbGluZS50ZXh0Lm1hdGNoKC9eXFxcXHMqLylbMF0sIGluZGVudGF0aW9uO1xcbiAgICBpZiAoIWFnZ3Jlc3NpdmUgJiYgIS9cXFxcUy8udGVzdChsaW5lLnRleHQpKSB7XFxuICAgICAgaW5kZW50YXRpb24gPSAwO1xcbiAgICAgIGhvdyA9IFxcXCJub3RcXFwiO1xcbiAgICB9IGVsc2UgaWYgKGhvdyA9PSBcXFwic21hcnRcXFwiKSB7XFxuICAgICAgaW5kZW50YXRpb24gPSBkb2MubW9kZS5pbmRlbnQoc3RhdGUsIGxpbmUudGV4dC5zbGljZShjdXJTcGFjZVN0cmluZy5sZW5ndGgpLCBsaW5lLnRleHQpO1xcbiAgICAgIGlmIChpbmRlbnRhdGlvbiA9PSBQYXNzIHx8IGluZGVudGF0aW9uID4gMTUwKSB7XFxuICAgICAgICBpZiAoIWFnZ3Jlc3NpdmUpIHJldHVybjtcXG4gICAgICAgIGhvdyA9IFxcXCJwcmV2XFxcIjtcXG4gICAgICB9XFxuICAgIH1cXG4gICAgaWYgKGhvdyA9PSBcXFwicHJldlxcXCIpIHtcXG4gICAgICBpZiAobiA+IGRvYy5maXJzdCkgaW5kZW50YXRpb24gPSBjb3VudENvbHVtbihnZXRMaW5lKGRvYywgbi0xKS50ZXh0LCBudWxsLCB0YWJTaXplKTtcXG4gICAgICBlbHNlIGluZGVudGF0aW9uID0gMDtcXG4gICAgfSBlbHNlIGlmIChob3cgPT0gXFxcImFkZFxcXCIpIHtcXG4gICAgICBpbmRlbnRhdGlvbiA9IGN1clNwYWNlICsgY20ub3B0aW9ucy5pbmRlbnRVbml0O1xcbiAgICB9IGVsc2UgaWYgKGhvdyA9PSBcXFwic3VidHJhY3RcXFwiKSB7XFxuICAgICAgaW5kZW50YXRpb24gPSBjdXJTcGFjZSAtIGNtLm9wdGlvbnMuaW5kZW50VW5pdDtcXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgaG93ID09IFxcXCJudW1iZXJcXFwiKSB7XFxuICAgICAgaW5kZW50YXRpb24gPSBjdXJTcGFjZSArIGhvdztcXG4gICAgfVxcbiAgICBpbmRlbnRhdGlvbiA9IE1hdGgubWF4KDAsIGluZGVudGF0aW9uKTtcXG5cXG4gICAgdmFyIGluZGVudFN0cmluZyA9IFxcXCJcXFwiLCBwb3MgPSAwO1xcbiAgICBpZiAoY20ub3B0aW9ucy5pbmRlbnRXaXRoVGFicylcXG4gICAgICBmb3IgKHZhciBpID0gTWF0aC5mbG9vcihpbmRlbnRhdGlvbiAvIHRhYlNpemUpOyBpOyAtLWkpIHtwb3MgKz0gdGFiU2l6ZTsgaW5kZW50U3RyaW5nICs9IFxcXCJcXFxcdFxcXCI7fVxcbiAgICBpZiAocG9zIDwgaW5kZW50YXRpb24pIGluZGVudFN0cmluZyArPSBzcGFjZVN0cihpbmRlbnRhdGlvbiAtIHBvcyk7XFxuXFxuICAgIGlmIChpbmRlbnRTdHJpbmcgIT0gY3VyU3BhY2VTdHJpbmcpIHtcXG4gICAgICByZXBsYWNlUmFuZ2UoZG9jLCBpbmRlbnRTdHJpbmcsIFBvcyhuLCAwKSwgUG9zKG4sIGN1clNwYWNlU3RyaW5nLmxlbmd0aCksIFxcXCIraW5wdXRcXFwiKTtcXG4gICAgICBsaW5lLnN0YXRlQWZ0ZXIgPSBudWxsO1xcbiAgICAgIHJldHVybiB0cnVlO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIC8vIEVuc3VyZSB0aGF0LCBpZiB0aGUgY3Vyc29yIHdhcyBpbiB0aGUgd2hpdGVzcGFjZSBhdCB0aGUgc3RhcnRcXG4gICAgICAvLyBvZiB0aGUgbGluZSwgaXQgaXMgbW92ZWQgdG8gdGhlIGVuZCBvZiB0aGF0IHNwYWNlLlxcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZG9jLnNlbC5yYW5nZXMubGVuZ3RoOyBpKyspIHtcXG4gICAgICAgIHZhciByYW5nZSA9IGRvYy5zZWwucmFuZ2VzW2ldO1xcbiAgICAgICAgaWYgKHJhbmdlLmhlYWQubGluZSA9PSBuICYmIHJhbmdlLmhlYWQuY2ggPCBjdXJTcGFjZVN0cmluZy5sZW5ndGgpIHtcXG4gICAgICAgICAgdmFyIHBvcyA9IFBvcyhuLCBjdXJTcGFjZVN0cmluZy5sZW5ndGgpO1xcbiAgICAgICAgICByZXBsYWNlT25lU2VsZWN0aW9uKGRvYywgaSwgbmV3IFJhbmdlKHBvcywgcG9zKSk7XFxuICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgfVxcbiAgfVxcblxcbiAgLy8gVXRpbGl0eSBmb3IgYXBwbHlpbmcgYSBjaGFuZ2UgdG8gYSBsaW5lIGJ5IGhhbmRsZSBvciBudW1iZXIsXFxuICAvLyByZXR1cm5pbmcgdGhlIG51bWJlciBhbmQgb3B0aW9uYWxseSByZWdpc3RlcmluZyB0aGUgbGluZSBhc1xcbiAgLy8gY2hhbmdlZC5cXG4gIGZ1bmN0aW9uIGNoYW5nZUxpbmUoZG9jLCBoYW5kbGUsIGNoYW5nZVR5cGUsIG9wKSB7XFxuICAgIHZhciBubyA9IGhhbmRsZSwgbGluZSA9IGhhbmRsZTtcXG4gICAgaWYgKHR5cGVvZiBoYW5kbGUgPT0gXFxcIm51bWJlclxcXCIpIGxpbmUgPSBnZXRMaW5lKGRvYywgY2xpcExpbmUoZG9jLCBoYW5kbGUpKTtcXG4gICAgZWxzZSBubyA9IGxpbmVObyhoYW5kbGUpO1xcbiAgICBpZiAobm8gPT0gbnVsbCkgcmV0dXJuIG51bGw7XFxuICAgIGlmIChvcChsaW5lLCBubykgJiYgZG9jLmNtKSByZWdMaW5lQ2hhbmdlKGRvYy5jbSwgbm8sIGNoYW5nZVR5cGUpO1xcbiAgICByZXR1cm4gbGluZTtcXG4gIH1cXG5cXG4gIC8vIEhlbHBlciBmb3IgZGVsZXRpbmcgdGV4dCBuZWFyIHRoZSBzZWxlY3Rpb24ocyksIHVzZWQgdG8gaW1wbGVtZW50XFxuICAvLyBiYWNrc3BhY2UsIGRlbGV0ZSwgYW5kIHNpbWlsYXIgZnVuY3Rpb25hbGl0eS5cXG4gIGZ1bmN0aW9uIGRlbGV0ZU5lYXJTZWxlY3Rpb24oY20sIGNvbXB1dGUpIHtcXG4gICAgdmFyIHJhbmdlcyA9IGNtLmRvYy5zZWwucmFuZ2VzLCBraWxsID0gW107XFxuICAgIC8vIEJ1aWxkIHVwIGEgc2V0IG9mIHJhbmdlcyB0byBraWxsIGZpcnN0LCBtZXJnaW5nIG92ZXJsYXBwaW5nXFxuICAgIC8vIHJhbmdlcy5cXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCByYW5nZXMubGVuZ3RoOyBpKyspIHtcXG4gICAgICB2YXIgdG9LaWxsID0gY29tcHV0ZShyYW5nZXNbaV0pO1xcbiAgICAgIHdoaWxlIChraWxsLmxlbmd0aCAmJiBjbXAodG9LaWxsLmZyb20sIGxzdChraWxsKS50bykgPD0gMCkge1xcbiAgICAgICAgdmFyIHJlcGxhY2VkID0ga2lsbC5wb3AoKTtcXG4gICAgICAgIGlmIChjbXAocmVwbGFjZWQuZnJvbSwgdG9LaWxsLmZyb20pIDwgMCkge1xcbiAgICAgICAgICB0b0tpbGwuZnJvbSA9IHJlcGxhY2VkLmZyb207XFxuICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgICBraWxsLnB1c2godG9LaWxsKTtcXG4gICAgfVxcbiAgICAvLyBOZXh0LCByZW1vdmUgdGhvc2UgYWN0dWFsIHJhbmdlcy5cXG4gICAgcnVuSW5PcChjbSwgZnVuY3Rpb24oKSB7XFxuICAgICAgZm9yICh2YXIgaSA9IGtpbGwubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pXFxuICAgICAgICByZXBsYWNlUmFuZ2UoY20uZG9jLCBcXFwiXFxcIiwga2lsbFtpXS5mcm9tLCBraWxsW2ldLnRvLCBcXFwiK2RlbGV0ZVxcXCIpO1xcbiAgICAgIGVuc3VyZUN1cnNvclZpc2libGUoY20pO1xcbiAgICB9KTtcXG4gIH1cXG5cXG4gIC8vIFVzZWQgZm9yIGhvcml6b250YWwgcmVsYXRpdmUgbW90aW9uLiBEaXIgaXMgLTEgb3IgMSAobGVmdCBvclxcbiAgLy8gcmlnaHQpLCB1bml0IGNhbiBiZSBcXFwiY2hhclxcXCIsIFxcXCJjb2x1bW5cXFwiIChsaWtlIGNoYXIsIGJ1dCBkb2Vzbid0XFxuICAvLyBjcm9zcyBsaW5lIGJvdW5kYXJpZXMpLCBcXFwid29yZFxcXCIgKGFjcm9zcyBuZXh0IHdvcmQpLCBvciBcXFwiZ3JvdXBcXFwiICh0b1xcbiAgLy8gdGhlIHN0YXJ0IG9mIG5leHQgZ3JvdXAgb2Ygd29yZCBvciBub24td29yZC1ub24td2hpdGVzcGFjZVxcbiAgLy8gY2hhcnMpLiBUaGUgdmlzdWFsbHkgcGFyYW0gY29udHJvbHMgd2hldGhlciwgaW4gcmlnaHQtdG8tbGVmdFxcbiAgLy8gdGV4dCwgZGlyZWN0aW9uIDEgbWVhbnMgdG8gbW92ZSB0b3dhcmRzIHRoZSBuZXh0IGluZGV4IGluIHRoZVxcbiAgLy8gc3RyaW5nLCBvciB0b3dhcmRzIHRoZSBjaGFyYWN0ZXIgdG8gdGhlIHJpZ2h0IG9mIHRoZSBjdXJyZW50XFxuICAvLyBwb3NpdGlvbi4gVGhlIHJlc3VsdGluZyBwb3NpdGlvbiB3aWxsIGhhdmUgYSBoaXRTaWRlPXRydWVcXG4gIC8vIHByb3BlcnR5IGlmIGl0IHJlYWNoZWQgdGhlIGVuZCBvZiB0aGUgZG9jdW1lbnQuXFxuICBmdW5jdGlvbiBmaW5kUG9zSChkb2MsIHBvcywgZGlyLCB1bml0LCB2aXN1YWxseSkge1xcbiAgICB2YXIgbGluZSA9IHBvcy5saW5lLCBjaCA9IHBvcy5jaCwgb3JpZ0RpciA9IGRpcjtcXG4gICAgdmFyIGxpbmVPYmogPSBnZXRMaW5lKGRvYywgbGluZSk7XFxuICAgIGZ1bmN0aW9uIGZpbmROZXh0TGluZSgpIHtcXG4gICAgICB2YXIgbCA9IGxpbmUgKyBkaXI7XFxuICAgICAgaWYgKGwgPCBkb2MuZmlyc3QgfHwgbCA+PSBkb2MuZmlyc3QgKyBkb2Muc2l6ZSkgcmV0dXJuIGZhbHNlXFxuICAgICAgbGluZSA9IGw7XFxuICAgICAgcmV0dXJuIGxpbmVPYmogPSBnZXRMaW5lKGRvYywgbCk7XFxuICAgIH1cXG4gICAgZnVuY3Rpb24gbW92ZU9uY2UoYm91bmRUb0xpbmUpIHtcXG4gICAgICB2YXIgbmV4dCA9ICh2aXN1YWxseSA/IG1vdmVWaXN1YWxseSA6IG1vdmVMb2dpY2FsbHkpKGxpbmVPYmosIGNoLCBkaXIsIHRydWUpO1xcbiAgICAgIGlmIChuZXh0ID09IG51bGwpIHtcXG4gICAgICAgIGlmICghYm91bmRUb0xpbmUgJiYgZmluZE5leHRMaW5lKCkpIHtcXG4gICAgICAgICAgaWYgKHZpc3VhbGx5KSBjaCA9IChkaXIgPCAwID8gbGluZVJpZ2h0IDogbGluZUxlZnQpKGxpbmVPYmopO1xcbiAgICAgICAgICBlbHNlIGNoID0gZGlyIDwgMCA/IGxpbmVPYmoudGV4dC5sZW5ndGggOiAwO1xcbiAgICAgICAgfSBlbHNlIHJldHVybiBmYWxzZVxcbiAgICAgIH0gZWxzZSBjaCA9IG5leHQ7XFxuICAgICAgcmV0dXJuIHRydWU7XFxuICAgIH1cXG5cXG4gICAgaWYgKHVuaXQgPT0gXFxcImNoYXJcXFwiKSB7XFxuICAgICAgbW92ZU9uY2UoKVxcbiAgICB9IGVsc2UgaWYgKHVuaXQgPT0gXFxcImNvbHVtblxcXCIpIHtcXG4gICAgICBtb3ZlT25jZSh0cnVlKVxcbiAgICB9IGVsc2UgaWYgKHVuaXQgPT0gXFxcIndvcmRcXFwiIHx8IHVuaXQgPT0gXFxcImdyb3VwXFxcIikge1xcbiAgICAgIHZhciBzYXdUeXBlID0gbnVsbCwgZ3JvdXAgPSB1bml0ID09IFxcXCJncm91cFxcXCI7XFxuICAgICAgdmFyIGhlbHBlciA9IGRvYy5jbSAmJiBkb2MuY20uZ2V0SGVscGVyKHBvcywgXFxcIndvcmRDaGFyc1xcXCIpO1xcbiAgICAgIGZvciAodmFyIGZpcnN0ID0gdHJ1ZTs7IGZpcnN0ID0gZmFsc2UpIHtcXG4gICAgICAgIGlmIChkaXIgPCAwICYmICFtb3ZlT25jZSghZmlyc3QpKSBicmVhaztcXG4gICAgICAgIHZhciBjdXIgPSBsaW5lT2JqLnRleHQuY2hhckF0KGNoKSB8fCBcXFwiXFxcXG5cXFwiO1xcbiAgICAgICAgdmFyIHR5cGUgPSBpc1dvcmRDaGFyKGN1ciwgaGVscGVyKSA/IFxcXCJ3XFxcIlxcbiAgICAgICAgICA6IGdyb3VwICYmIGN1ciA9PSBcXFwiXFxcXG5cXFwiID8gXFxcIm5cXFwiXFxuICAgICAgICAgIDogIWdyb3VwIHx8IC9cXFxccy8udGVzdChjdXIpID8gbnVsbFxcbiAgICAgICAgICA6IFxcXCJwXFxcIjtcXG4gICAgICAgIGlmIChncm91cCAmJiAhZmlyc3QgJiYgIXR5cGUpIHR5cGUgPSBcXFwic1xcXCI7XFxuICAgICAgICBpZiAoc2F3VHlwZSAmJiBzYXdUeXBlICE9IHR5cGUpIHtcXG4gICAgICAgICAgaWYgKGRpciA8IDApIHtkaXIgPSAxOyBtb3ZlT25jZSgpO31cXG4gICAgICAgICAgYnJlYWs7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBpZiAodHlwZSkgc2F3VHlwZSA9IHR5cGU7XFxuICAgICAgICBpZiAoZGlyID4gMCAmJiAhbW92ZU9uY2UoIWZpcnN0KSkgYnJlYWs7XFxuICAgICAgfVxcbiAgICB9XFxuICAgIHZhciByZXN1bHQgPSBza2lwQXRvbWljKGRvYywgUG9zKGxpbmUsIGNoKSwgcG9zLCBvcmlnRGlyLCB0cnVlKTtcXG4gICAgaWYgKCFjbXAocG9zLCByZXN1bHQpKSByZXN1bHQuaGl0U2lkZSA9IHRydWU7XFxuICAgIHJldHVybiByZXN1bHQ7XFxuICB9XFxuXFxuICAvLyBGb3IgcmVsYXRpdmUgdmVydGljYWwgbW92ZW1lbnQuIERpciBtYXkgYmUgLTEgb3IgMS4gVW5pdCBjYW4gYmVcXG4gIC8vIFxcXCJwYWdlXFxcIiBvciBcXFwibGluZVxcXCIuIFRoZSByZXN1bHRpbmcgcG9zaXRpb24gd2lsbCBoYXZlIGEgaGl0U2lkZT10cnVlXFxuICAvLyBwcm9wZXJ0eSBpZiBpdCByZWFjaGVkIHRoZSBlbmQgb2YgdGhlIGRvY3VtZW50LlxcbiAgZnVuY3Rpb24gZmluZFBvc1YoY20sIHBvcywgZGlyLCB1bml0KSB7XFxuICAgIHZhciBkb2MgPSBjbS5kb2MsIHggPSBwb3MubGVmdCwgeTtcXG4gICAgaWYgKHVuaXQgPT0gXFxcInBhZ2VcXFwiKSB7XFxuICAgICAgdmFyIHBhZ2VTaXplID0gTWF0aC5taW4oY20uZGlzcGxheS53cmFwcGVyLmNsaWVudEhlaWdodCwgd2luZG93LmlubmVySGVpZ2h0IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQpO1xcbiAgICAgIHZhciBtb3ZlQW1vdW50ID0gTWF0aC5tYXgocGFnZVNpemUgLSAuNSAqIHRleHRIZWlnaHQoY20uZGlzcGxheSksIDMpO1xcbiAgICAgIHkgPSAoZGlyID4gMCA/IHBvcy5ib3R0b20gOiBwb3MudG9wKSArIGRpciAqIG1vdmVBbW91bnQ7XFxuICAgIH0gZWxzZSBpZiAodW5pdCA9PSBcXFwibGluZVxcXCIpIHtcXG4gICAgICB5ID0gZGlyID4gMCA/IHBvcy5ib3R0b20gKyAzIDogcG9zLnRvcCAtIDM7XFxuICAgIH1cXG4gICAgZm9yICg7Oykge1xcbiAgICAgIHZhciB0YXJnZXQgPSBjb29yZHNDaGFyKGNtLCB4LCB5KTtcXG4gICAgICBpZiAoIXRhcmdldC5vdXRzaWRlKSBicmVhaztcXG4gICAgICBpZiAoZGlyIDwgMCA/IHkgPD0gMCA6IHkgPj0gZG9jLmhlaWdodCkgeyB0YXJnZXQuaGl0U2lkZSA9IHRydWU7IGJyZWFrOyB9XFxuICAgICAgeSArPSBkaXIgKiA1O1xcbiAgICB9XFxuICAgIHJldHVybiB0YXJnZXQ7XFxuICB9XFxuXFxuICAvLyBFRElUT1IgTUVUSE9EU1xcblxcbiAgLy8gVGhlIHB1YmxpY2x5IHZpc2libGUgQVBJLiBOb3RlIHRoYXQgbWV0aG9kT3AoZikgbWVhbnNcXG4gIC8vICd3cmFwIGYgaW4gYW4gb3BlcmF0aW9uLCBwZXJmb3JtZWQgb24gaXRzIGB0aGlzYCBwYXJhbWV0ZXInLlxcblxcbiAgLy8gVGhpcyBpcyBub3QgdGhlIGNvbXBsZXRlIHNldCBvZiBlZGl0b3IgbWV0aG9kcy4gTW9zdCBvZiB0aGVcXG4gIC8vIG1ldGhvZHMgZGVmaW5lZCBvbiB0aGUgRG9jIHR5cGUgYXJlIGFsc28gaW5qZWN0ZWQgaW50b1xcbiAgLy8gQ29kZU1pcnJvci5wcm90b3R5cGUsIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSBhbmRcXG4gIC8vIGNvbnZlbmllbmNlLlxcblxcbiAgQ29kZU1pcnJvci5wcm90b3R5cGUgPSB7XFxuICAgIGNvbnN0cnVjdG9yOiBDb2RlTWlycm9yLFxcbiAgICBmb2N1czogZnVuY3Rpb24oKXt3aW5kb3cuZm9jdXMoKTsgdGhpcy5kaXNwbGF5LmlucHV0LmZvY3VzKCk7fSxcXG5cXG4gICAgc2V0T3B0aW9uOiBmdW5jdGlvbihvcHRpb24sIHZhbHVlKSB7XFxuICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsIG9sZCA9IG9wdGlvbnNbb3B0aW9uXTtcXG4gICAgICBpZiAob3B0aW9uc1tvcHRpb25dID09IHZhbHVlICYmIG9wdGlvbiAhPSBcXFwibW9kZVxcXCIpIHJldHVybjtcXG4gICAgICBvcHRpb25zW29wdGlvbl0gPSB2YWx1ZTtcXG4gICAgICBpZiAob3B0aW9uSGFuZGxlcnMuaGFzT3duUHJvcGVydHkob3B0aW9uKSlcXG4gICAgICAgIG9wZXJhdGlvbih0aGlzLCBvcHRpb25IYW5kbGVyc1tvcHRpb25dKSh0aGlzLCB2YWx1ZSwgb2xkKTtcXG4gICAgfSxcXG5cXG4gICAgZ2V0T3B0aW9uOiBmdW5jdGlvbihvcHRpb24pIHtyZXR1cm4gdGhpcy5vcHRpb25zW29wdGlvbl07fSxcXG4gICAgZ2V0RG9jOiBmdW5jdGlvbigpIHtyZXR1cm4gdGhpcy5kb2M7fSxcXG5cXG4gICAgYWRkS2V5TWFwOiBmdW5jdGlvbihtYXAsIGJvdHRvbSkge1xcbiAgICAgIHRoaXMuc3RhdGUua2V5TWFwc1tib3R0b20gPyBcXFwicHVzaFxcXCIgOiBcXFwidW5zaGlmdFxcXCJdKGdldEtleU1hcChtYXApKTtcXG4gICAgfSxcXG4gICAgcmVtb3ZlS2V5TWFwOiBmdW5jdGlvbihtYXApIHtcXG4gICAgICB2YXIgbWFwcyA9IHRoaXMuc3RhdGUua2V5TWFwcztcXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1hcHMubGVuZ3RoOyArK2kpXFxuICAgICAgICBpZiAobWFwc1tpXSA9PSBtYXAgfHwgbWFwc1tpXS5uYW1lID09IG1hcCkge1xcbiAgICAgICAgICBtYXBzLnNwbGljZShpLCAxKTtcXG4gICAgICAgICAgcmV0dXJuIHRydWU7XFxuICAgICAgICB9XFxuICAgIH0sXFxuXFxuICAgIGFkZE92ZXJsYXk6IG1ldGhvZE9wKGZ1bmN0aW9uKHNwZWMsIG9wdGlvbnMpIHtcXG4gICAgICB2YXIgbW9kZSA9IHNwZWMudG9rZW4gPyBzcGVjIDogQ29kZU1pcnJvci5nZXRNb2RlKHRoaXMub3B0aW9ucywgc3BlYyk7XFxuICAgICAgaWYgKG1vZGUuc3RhcnRTdGF0ZSkgdGhyb3cgbmV3IEVycm9yKFxcXCJPdmVybGF5cyBtYXkgbm90IGJlIHN0YXRlZnVsLlxcXCIpO1xcbiAgICAgIGluc2VydFNvcnRlZCh0aGlzLnN0YXRlLm92ZXJsYXlzLFxcbiAgICAgICAgICAgICAgICAgICB7bW9kZTogbW9kZSwgbW9kZVNwZWM6IHNwZWMsIG9wYXF1ZTogb3B0aW9ucyAmJiBvcHRpb25zLm9wYXF1ZSxcXG4gICAgICAgICAgICAgICAgICAgIHByaW9yaXR5OiAob3B0aW9ucyAmJiBvcHRpb25zLnByaW9yaXR5KSB8fCAwfSxcXG4gICAgICAgICAgICAgICAgICAgZnVuY3Rpb24ob3ZlcmxheSkgeyByZXR1cm4gb3ZlcmxheS5wcmlvcml0eSB9KVxcbiAgICAgIHRoaXMuc3RhdGUubW9kZUdlbisrO1xcbiAgICAgIHJlZ0NoYW5nZSh0aGlzKTtcXG4gICAgfSksXFxuICAgIHJlbW92ZU92ZXJsYXk6IG1ldGhvZE9wKGZ1bmN0aW9uKHNwZWMpIHtcXG4gICAgICB2YXIgb3ZlcmxheXMgPSB0aGlzLnN0YXRlLm92ZXJsYXlzO1xcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3ZlcmxheXMubGVuZ3RoOyArK2kpIHtcXG4gICAgICAgIHZhciBjdXIgPSBvdmVybGF5c1tpXS5tb2RlU3BlYztcXG4gICAgICAgIGlmIChjdXIgPT0gc3BlYyB8fCB0eXBlb2Ygc3BlYyA9PSBcXFwic3RyaW5nXFxcIiAmJiBjdXIubmFtZSA9PSBzcGVjKSB7XFxuICAgICAgICAgIG92ZXJsYXlzLnNwbGljZShpLCAxKTtcXG4gICAgICAgICAgdGhpcy5zdGF0ZS5tb2RlR2VuKys7XFxuICAgICAgICAgIHJlZ0NoYW5nZSh0aGlzKTtcXG4gICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgfSksXFxuXFxuICAgIGluZGVudExpbmU6IG1ldGhvZE9wKGZ1bmN0aW9uKG4sIGRpciwgYWdncmVzc2l2ZSkge1xcbiAgICAgIGlmICh0eXBlb2YgZGlyICE9IFxcXCJzdHJpbmdcXFwiICYmIHR5cGVvZiBkaXIgIT0gXFxcIm51bWJlclxcXCIpIHtcXG4gICAgICAgIGlmIChkaXIgPT0gbnVsbCkgZGlyID0gdGhpcy5vcHRpb25zLnNtYXJ0SW5kZW50ID8gXFxcInNtYXJ0XFxcIiA6IFxcXCJwcmV2XFxcIjtcXG4gICAgICAgIGVsc2UgZGlyID0gZGlyID8gXFxcImFkZFxcXCIgOiBcXFwic3VidHJhY3RcXFwiO1xcbiAgICAgIH1cXG4gICAgICBpZiAoaXNMaW5lKHRoaXMuZG9jLCBuKSkgaW5kZW50TGluZSh0aGlzLCBuLCBkaXIsIGFnZ3Jlc3NpdmUpO1xcbiAgICB9KSxcXG4gICAgaW5kZW50U2VsZWN0aW9uOiBtZXRob2RPcChmdW5jdGlvbihob3cpIHtcXG4gICAgICB2YXIgcmFuZ2VzID0gdGhpcy5kb2Muc2VsLnJhbmdlcywgZW5kID0gLTE7XFxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByYW5nZXMubGVuZ3RoOyBpKyspIHtcXG4gICAgICAgIHZhciByYW5nZSA9IHJhbmdlc1tpXTtcXG4gICAgICAgIGlmICghcmFuZ2UuZW1wdHkoKSkge1xcbiAgICAgICAgICB2YXIgZnJvbSA9IHJhbmdlLmZyb20oKSwgdG8gPSByYW5nZS50bygpO1xcbiAgICAgICAgICB2YXIgc3RhcnQgPSBNYXRoLm1heChlbmQsIGZyb20ubGluZSk7XFxuICAgICAgICAgIGVuZCA9IE1hdGgubWluKHRoaXMubGFzdExpbmUoKSwgdG8ubGluZSAtICh0by5jaCA/IDAgOiAxKSkgKyAxO1xcbiAgICAgICAgICBmb3IgKHZhciBqID0gc3RhcnQ7IGogPCBlbmQ7ICsrailcXG4gICAgICAgICAgICBpbmRlbnRMaW5lKHRoaXMsIGosIGhvdyk7XFxuICAgICAgICAgIHZhciBuZXdSYW5nZXMgPSB0aGlzLmRvYy5zZWwucmFuZ2VzO1xcbiAgICAgICAgICBpZiAoZnJvbS5jaCA9PSAwICYmIHJhbmdlcy5sZW5ndGggPT0gbmV3UmFuZ2VzLmxlbmd0aCAmJiBuZXdSYW5nZXNbaV0uZnJvbSgpLmNoID4gMClcXG4gICAgICAgICAgICByZXBsYWNlT25lU2VsZWN0aW9uKHRoaXMuZG9jLCBpLCBuZXcgUmFuZ2UoZnJvbSwgbmV3UmFuZ2VzW2ldLnRvKCkpLCBzZWxfZG9udFNjcm9sbCk7XFxuICAgICAgICB9IGVsc2UgaWYgKHJhbmdlLmhlYWQubGluZSA+IGVuZCkge1xcbiAgICAgICAgICBpbmRlbnRMaW5lKHRoaXMsIHJhbmdlLmhlYWQubGluZSwgaG93LCB0cnVlKTtcXG4gICAgICAgICAgZW5kID0gcmFuZ2UuaGVhZC5saW5lO1xcbiAgICAgICAgICBpZiAoaSA9PSB0aGlzLmRvYy5zZWwucHJpbUluZGV4KSBlbnN1cmVDdXJzb3JWaXNpYmxlKHRoaXMpO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgfSksXFxuXFxuICAgIC8vIEZldGNoIHRoZSBwYXJzZXIgdG9rZW4gZm9yIGEgZ2l2ZW4gY2hhcmFjdGVyLiBVc2VmdWwgZm9yIGhhY2tzXFxuICAgIC8vIHRoYXQgd2FudCB0byBpbnNwZWN0IHRoZSBtb2RlIHN0YXRlIChzYXksIGZvciBjb21wbGV0aW9uKS5cXG4gICAgZ2V0VG9rZW5BdDogZnVuY3Rpb24ocG9zLCBwcmVjaXNlKSB7XFxuICAgICAgcmV0dXJuIHRha2VUb2tlbih0aGlzLCBwb3MsIHByZWNpc2UpO1xcbiAgICB9LFxcblxcbiAgICBnZXRMaW5lVG9rZW5zOiBmdW5jdGlvbihsaW5lLCBwcmVjaXNlKSB7XFxuICAgICAgcmV0dXJuIHRha2VUb2tlbih0aGlzLCBQb3MobGluZSksIHByZWNpc2UsIHRydWUpO1xcbiAgICB9LFxcblxcbiAgICBnZXRUb2tlblR5cGVBdDogZnVuY3Rpb24ocG9zKSB7XFxuICAgICAgcG9zID0gY2xpcFBvcyh0aGlzLmRvYywgcG9zKTtcXG4gICAgICB2YXIgc3R5bGVzID0gZ2V0TGluZVN0eWxlcyh0aGlzLCBnZXRMaW5lKHRoaXMuZG9jLCBwb3MubGluZSkpO1xcbiAgICAgIHZhciBiZWZvcmUgPSAwLCBhZnRlciA9IChzdHlsZXMubGVuZ3RoIC0gMSkgLyAyLCBjaCA9IHBvcy5jaDtcXG4gICAgICB2YXIgdHlwZTtcXG4gICAgICBpZiAoY2ggPT0gMCkgdHlwZSA9IHN0eWxlc1syXTtcXG4gICAgICBlbHNlIGZvciAoOzspIHtcXG4gICAgICAgIHZhciBtaWQgPSAoYmVmb3JlICsgYWZ0ZXIpID4+IDE7XFxuICAgICAgICBpZiAoKG1pZCA/IHN0eWxlc1ttaWQgKiAyIC0gMV0gOiAwKSA+PSBjaCkgYWZ0ZXIgPSBtaWQ7XFxuICAgICAgICBlbHNlIGlmIChzdHlsZXNbbWlkICogMiArIDFdIDwgY2gpIGJlZm9yZSA9IG1pZCArIDE7XFxuICAgICAgICBlbHNlIHsgdHlwZSA9IHN0eWxlc1ttaWQgKiAyICsgMl07IGJyZWFrOyB9XFxuICAgICAgfVxcbiAgICAgIHZhciBjdXQgPSB0eXBlID8gdHlwZS5pbmRleE9mKFxcXCJjbS1vdmVybGF5IFxcXCIpIDogLTE7XFxuICAgICAgcmV0dXJuIGN1dCA8IDAgPyB0eXBlIDogY3V0ID09IDAgPyBudWxsIDogdHlwZS5zbGljZSgwLCBjdXQgLSAxKTtcXG4gICAgfSxcXG5cXG4gICAgZ2V0TW9kZUF0OiBmdW5jdGlvbihwb3MpIHtcXG4gICAgICB2YXIgbW9kZSA9IHRoaXMuZG9jLm1vZGU7XFxuICAgICAgaWYgKCFtb2RlLmlubmVyTW9kZSkgcmV0dXJuIG1vZGU7XFxuICAgICAgcmV0dXJuIENvZGVNaXJyb3IuaW5uZXJNb2RlKG1vZGUsIHRoaXMuZ2V0VG9rZW5BdChwb3MpLnN0YXRlKS5tb2RlO1xcbiAgICB9LFxcblxcbiAgICBnZXRIZWxwZXI6IGZ1bmN0aW9uKHBvcywgdHlwZSkge1xcbiAgICAgIHJldHVybiB0aGlzLmdldEhlbHBlcnMocG9zLCB0eXBlKVswXTtcXG4gICAgfSxcXG5cXG4gICAgZ2V0SGVscGVyczogZnVuY3Rpb24ocG9zLCB0eXBlKSB7XFxuICAgICAgdmFyIGZvdW5kID0gW107XFxuICAgICAgaWYgKCFoZWxwZXJzLmhhc093blByb3BlcnR5KHR5cGUpKSByZXR1cm4gZm91bmQ7XFxuICAgICAgdmFyIGhlbHAgPSBoZWxwZXJzW3R5cGVdLCBtb2RlID0gdGhpcy5nZXRNb2RlQXQocG9zKTtcXG4gICAgICBpZiAodHlwZW9mIG1vZGVbdHlwZV0gPT0gXFxcInN0cmluZ1xcXCIpIHtcXG4gICAgICAgIGlmIChoZWxwW21vZGVbdHlwZV1dKSBmb3VuZC5wdXNoKGhlbHBbbW9kZVt0eXBlXV0pO1xcbiAgICAgIH0gZWxzZSBpZiAobW9kZVt0eXBlXSkge1xcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtb2RlW3R5cGVdLmxlbmd0aDsgaSsrKSB7XFxuICAgICAgICAgIHZhciB2YWwgPSBoZWxwW21vZGVbdHlwZV1baV1dO1xcbiAgICAgICAgICBpZiAodmFsKSBmb3VuZC5wdXNoKHZhbCk7XFxuICAgICAgICB9XFxuICAgICAgfSBlbHNlIGlmIChtb2RlLmhlbHBlclR5cGUgJiYgaGVscFttb2RlLmhlbHBlclR5cGVdKSB7XFxuICAgICAgICBmb3VuZC5wdXNoKGhlbHBbbW9kZS5oZWxwZXJUeXBlXSk7XFxuICAgICAgfSBlbHNlIGlmIChoZWxwW21vZGUubmFtZV0pIHtcXG4gICAgICAgIGZvdW5kLnB1c2goaGVscFttb2RlLm5hbWVdKTtcXG4gICAgICB9XFxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBoZWxwLl9nbG9iYWwubGVuZ3RoOyBpKyspIHtcXG4gICAgICAgIHZhciBjdXIgPSBoZWxwLl9nbG9iYWxbaV07XFxuICAgICAgICBpZiAoY3VyLnByZWQobW9kZSwgdGhpcykgJiYgaW5kZXhPZihmb3VuZCwgY3VyLnZhbCkgPT0gLTEpXFxuICAgICAgICAgIGZvdW5kLnB1c2goY3VyLnZhbCk7XFxuICAgICAgfVxcbiAgICAgIHJldHVybiBmb3VuZDtcXG4gICAgfSxcXG5cXG4gICAgZ2V0U3RhdGVBZnRlcjogZnVuY3Rpb24obGluZSwgcHJlY2lzZSkge1xcbiAgICAgIHZhciBkb2MgPSB0aGlzLmRvYztcXG4gICAgICBsaW5lID0gY2xpcExpbmUoZG9jLCBsaW5lID09IG51bGwgPyBkb2MuZmlyc3QgKyBkb2Muc2l6ZSAtIDE6IGxpbmUpO1xcbiAgICAgIHJldHVybiBnZXRTdGF0ZUJlZm9yZSh0aGlzLCBsaW5lICsgMSwgcHJlY2lzZSk7XFxuICAgIH0sXFxuXFxuICAgIGN1cnNvckNvb3JkczogZnVuY3Rpb24oc3RhcnQsIG1vZGUpIHtcXG4gICAgICB2YXIgcG9zLCByYW5nZSA9IHRoaXMuZG9jLnNlbC5wcmltYXJ5KCk7XFxuICAgICAgaWYgKHN0YXJ0ID09IG51bGwpIHBvcyA9IHJhbmdlLmhlYWQ7XFxuICAgICAgZWxzZSBpZiAodHlwZW9mIHN0YXJ0ID09IFxcXCJvYmplY3RcXFwiKSBwb3MgPSBjbGlwUG9zKHRoaXMuZG9jLCBzdGFydCk7XFxuICAgICAgZWxzZSBwb3MgPSBzdGFydCA/IHJhbmdlLmZyb20oKSA6IHJhbmdlLnRvKCk7XFxuICAgICAgcmV0dXJuIGN1cnNvckNvb3Jkcyh0aGlzLCBwb3MsIG1vZGUgfHwgXFxcInBhZ2VcXFwiKTtcXG4gICAgfSxcXG5cXG4gICAgY2hhckNvb3JkczogZnVuY3Rpb24ocG9zLCBtb2RlKSB7XFxuICAgICAgcmV0dXJuIGNoYXJDb29yZHModGhpcywgY2xpcFBvcyh0aGlzLmRvYywgcG9zKSwgbW9kZSB8fCBcXFwicGFnZVxcXCIpO1xcbiAgICB9LFxcblxcbiAgICBjb29yZHNDaGFyOiBmdW5jdGlvbihjb29yZHMsIG1vZGUpIHtcXG4gICAgICBjb29yZHMgPSBmcm9tQ29vcmRTeXN0ZW0odGhpcywgY29vcmRzLCBtb2RlIHx8IFxcXCJwYWdlXFxcIik7XFxuICAgICAgcmV0dXJuIGNvb3Jkc0NoYXIodGhpcywgY29vcmRzLmxlZnQsIGNvb3Jkcy50b3ApO1xcbiAgICB9LFxcblxcbiAgICBsaW5lQXRIZWlnaHQ6IGZ1bmN0aW9uKGhlaWdodCwgbW9kZSkge1xcbiAgICAgIGhlaWdodCA9IGZyb21Db29yZFN5c3RlbSh0aGlzLCB7dG9wOiBoZWlnaHQsIGxlZnQ6IDB9LCBtb2RlIHx8IFxcXCJwYWdlXFxcIikudG9wO1xcbiAgICAgIHJldHVybiBsaW5lQXRIZWlnaHQodGhpcy5kb2MsIGhlaWdodCArIHRoaXMuZGlzcGxheS52aWV3T2Zmc2V0KTtcXG4gICAgfSxcXG4gICAgaGVpZ2h0QXRMaW5lOiBmdW5jdGlvbihsaW5lLCBtb2RlKSB7XFxuICAgICAgdmFyIGVuZCA9IGZhbHNlLCBsaW5lT2JqO1xcbiAgICAgIGlmICh0eXBlb2YgbGluZSA9PSBcXFwibnVtYmVyXFxcIikge1xcbiAgICAgICAgdmFyIGxhc3QgPSB0aGlzLmRvYy5maXJzdCArIHRoaXMuZG9jLnNpemUgLSAxO1xcbiAgICAgICAgaWYgKGxpbmUgPCB0aGlzLmRvYy5maXJzdCkgbGluZSA9IHRoaXMuZG9jLmZpcnN0O1xcbiAgICAgICAgZWxzZSBpZiAobGluZSA+IGxhc3QpIHsgbGluZSA9IGxhc3Q7IGVuZCA9IHRydWU7IH1cXG4gICAgICAgIGxpbmVPYmogPSBnZXRMaW5lKHRoaXMuZG9jLCBsaW5lKTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgbGluZU9iaiA9IGxpbmU7XFxuICAgICAgfVxcbiAgICAgIHJldHVybiBpbnRvQ29vcmRTeXN0ZW0odGhpcywgbGluZU9iaiwge3RvcDogMCwgbGVmdDogMH0sIG1vZGUgfHwgXFxcInBhZ2VcXFwiKS50b3AgK1xcbiAgICAgICAgKGVuZCA/IHRoaXMuZG9jLmhlaWdodCAtIGhlaWdodEF0TGluZShsaW5lT2JqKSA6IDApO1xcbiAgICB9LFxcblxcbiAgICBkZWZhdWx0VGV4dEhlaWdodDogZnVuY3Rpb24oKSB7IHJldHVybiB0ZXh0SGVpZ2h0KHRoaXMuZGlzcGxheSk7IH0sXFxuICAgIGRlZmF1bHRDaGFyV2lkdGg6IGZ1bmN0aW9uKCkgeyByZXR1cm4gY2hhcldpZHRoKHRoaXMuZGlzcGxheSk7IH0sXFxuXFxuICAgIHNldEd1dHRlck1hcmtlcjogbWV0aG9kT3AoZnVuY3Rpb24obGluZSwgZ3V0dGVySUQsIHZhbHVlKSB7XFxuICAgICAgcmV0dXJuIGNoYW5nZUxpbmUodGhpcy5kb2MsIGxpbmUsIFxcXCJndXR0ZXJcXFwiLCBmdW5jdGlvbihsaW5lKSB7XFxuICAgICAgICB2YXIgbWFya2VycyA9IGxpbmUuZ3V0dGVyTWFya2VycyB8fCAobGluZS5ndXR0ZXJNYXJrZXJzID0ge30pO1xcbiAgICAgICAgbWFya2Vyc1tndXR0ZXJJRF0gPSB2YWx1ZTtcXG4gICAgICAgIGlmICghdmFsdWUgJiYgaXNFbXB0eShtYXJrZXJzKSkgbGluZS5ndXR0ZXJNYXJrZXJzID0gbnVsbDtcXG4gICAgICAgIHJldHVybiB0cnVlO1xcbiAgICAgIH0pO1xcbiAgICB9KSxcXG5cXG4gICAgY2xlYXJHdXR0ZXI6IG1ldGhvZE9wKGZ1bmN0aW9uKGd1dHRlcklEKSB7XFxuICAgICAgdmFyIGNtID0gdGhpcywgZG9jID0gY20uZG9jLCBpID0gZG9jLmZpcnN0O1xcbiAgICAgIGRvYy5pdGVyKGZ1bmN0aW9uKGxpbmUpIHtcXG4gICAgICAgIGlmIChsaW5lLmd1dHRlck1hcmtlcnMgJiYgbGluZS5ndXR0ZXJNYXJrZXJzW2d1dHRlcklEXSkge1xcbiAgICAgICAgICBsaW5lLmd1dHRlck1hcmtlcnNbZ3V0dGVySURdID0gbnVsbDtcXG4gICAgICAgICAgcmVnTGluZUNoYW5nZShjbSwgaSwgXFxcImd1dHRlclxcXCIpO1xcbiAgICAgICAgICBpZiAoaXNFbXB0eShsaW5lLmd1dHRlck1hcmtlcnMpKSBsaW5lLmd1dHRlck1hcmtlcnMgPSBudWxsO1xcbiAgICAgICAgfVxcbiAgICAgICAgKytpO1xcbiAgICAgIH0pO1xcbiAgICB9KSxcXG5cXG4gICAgbGluZUluZm86IGZ1bmN0aW9uKGxpbmUpIHtcXG4gICAgICBpZiAodHlwZW9mIGxpbmUgPT0gXFxcIm51bWJlclxcXCIpIHtcXG4gICAgICAgIGlmICghaXNMaW5lKHRoaXMuZG9jLCBsaW5lKSkgcmV0dXJuIG51bGw7XFxuICAgICAgICB2YXIgbiA9IGxpbmU7XFxuICAgICAgICBsaW5lID0gZ2V0TGluZSh0aGlzLmRvYywgbGluZSk7XFxuICAgICAgICBpZiAoIWxpbmUpIHJldHVybiBudWxsO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICB2YXIgbiA9IGxpbmVObyhsaW5lKTtcXG4gICAgICAgIGlmIChuID09IG51bGwpIHJldHVybiBudWxsO1xcbiAgICAgIH1cXG4gICAgICByZXR1cm4ge2xpbmU6IG4sIGhhbmRsZTogbGluZSwgdGV4dDogbGluZS50ZXh0LCBndXR0ZXJNYXJrZXJzOiBsaW5lLmd1dHRlck1hcmtlcnMsXFxuICAgICAgICAgICAgICB0ZXh0Q2xhc3M6IGxpbmUudGV4dENsYXNzLCBiZ0NsYXNzOiBsaW5lLmJnQ2xhc3MsIHdyYXBDbGFzczogbGluZS53cmFwQ2xhc3MsXFxuICAgICAgICAgICAgICB3aWRnZXRzOiBsaW5lLndpZGdldHN9O1xcbiAgICB9LFxcblxcbiAgICBnZXRWaWV3cG9ydDogZnVuY3Rpb24oKSB7IHJldHVybiB7ZnJvbTogdGhpcy5kaXNwbGF5LnZpZXdGcm9tLCB0bzogdGhpcy5kaXNwbGF5LnZpZXdUb307fSxcXG5cXG4gICAgYWRkV2lkZ2V0OiBmdW5jdGlvbihwb3MsIG5vZGUsIHNjcm9sbCwgdmVydCwgaG9yaXopIHtcXG4gICAgICB2YXIgZGlzcGxheSA9IHRoaXMuZGlzcGxheTtcXG4gICAgICBwb3MgPSBjdXJzb3JDb29yZHModGhpcywgY2xpcFBvcyh0aGlzLmRvYywgcG9zKSk7XFxuICAgICAgdmFyIHRvcCA9IHBvcy5ib3R0b20sIGxlZnQgPSBwb3MubGVmdDtcXG4gICAgICBub2RlLnN0eWxlLnBvc2l0aW9uID0gXFxcImFic29sdXRlXFxcIjtcXG4gICAgICBub2RlLnNldEF0dHJpYnV0ZShcXFwiY20taWdub3JlLWV2ZW50c1xcXCIsIFxcXCJ0cnVlXFxcIik7XFxuICAgICAgdGhpcy5kaXNwbGF5LmlucHV0LnNldFVuZWRpdGFibGUobm9kZSk7XFxuICAgICAgZGlzcGxheS5zaXplci5hcHBlbmRDaGlsZChub2RlKTtcXG4gICAgICBpZiAodmVydCA9PSBcXFwib3ZlclxcXCIpIHtcXG4gICAgICAgIHRvcCA9IHBvcy50b3A7XFxuICAgICAgfSBlbHNlIGlmICh2ZXJ0ID09IFxcXCJhYm92ZVxcXCIgfHwgdmVydCA9PSBcXFwibmVhclxcXCIpIHtcXG4gICAgICAgIHZhciB2c3BhY2UgPSBNYXRoLm1heChkaXNwbGF5LndyYXBwZXIuY2xpZW50SGVpZ2h0LCB0aGlzLmRvYy5oZWlnaHQpLFxcbiAgICAgICAgaHNwYWNlID0gTWF0aC5tYXgoZGlzcGxheS5zaXplci5jbGllbnRXaWR0aCwgZGlzcGxheS5saW5lU3BhY2UuY2xpZW50V2lkdGgpO1xcbiAgICAgICAgLy8gRGVmYXVsdCB0byBwb3NpdGlvbmluZyBhYm92ZSAoaWYgc3BlY2lmaWVkIGFuZCBwb3NzaWJsZSk7IG90aGVyd2lzZSBkZWZhdWx0IHRvIHBvc2l0aW9uaW5nIGJlbG93XFxuICAgICAgICBpZiAoKHZlcnQgPT0gJ2Fib3ZlJyB8fCBwb3MuYm90dG9tICsgbm9kZS5vZmZzZXRIZWlnaHQgPiB2c3BhY2UpICYmIHBvcy50b3AgPiBub2RlLm9mZnNldEhlaWdodClcXG4gICAgICAgICAgdG9wID0gcG9zLnRvcCAtIG5vZGUub2Zmc2V0SGVpZ2h0O1xcbiAgICAgICAgZWxzZSBpZiAocG9zLmJvdHRvbSArIG5vZGUub2Zmc2V0SGVpZ2h0IDw9IHZzcGFjZSlcXG4gICAgICAgICAgdG9wID0gcG9zLmJvdHRvbTtcXG4gICAgICAgIGlmIChsZWZ0ICsgbm9kZS5vZmZzZXRXaWR0aCA+IGhzcGFjZSlcXG4gICAgICAgICAgbGVmdCA9IGhzcGFjZSAtIG5vZGUub2Zmc2V0V2lkdGg7XFxuICAgICAgfVxcbiAgICAgIG5vZGUuc3R5bGUudG9wID0gdG9wICsgXFxcInB4XFxcIjtcXG4gICAgICBub2RlLnN0eWxlLmxlZnQgPSBub2RlLnN0eWxlLnJpZ2h0ID0gXFxcIlxcXCI7XFxuICAgICAgaWYgKGhvcml6ID09IFxcXCJyaWdodFxcXCIpIHtcXG4gICAgICAgIGxlZnQgPSBkaXNwbGF5LnNpemVyLmNsaWVudFdpZHRoIC0gbm9kZS5vZmZzZXRXaWR0aDtcXG4gICAgICAgIG5vZGUuc3R5bGUucmlnaHQgPSBcXFwiMHB4XFxcIjtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgaWYgKGhvcml6ID09IFxcXCJsZWZ0XFxcIikgbGVmdCA9IDA7XFxuICAgICAgICBlbHNlIGlmIChob3JpeiA9PSBcXFwibWlkZGxlXFxcIikgbGVmdCA9IChkaXNwbGF5LnNpemVyLmNsaWVudFdpZHRoIC0gbm9kZS5vZmZzZXRXaWR0aCkgLyAyO1xcbiAgICAgICAgbm9kZS5zdHlsZS5sZWZ0ID0gbGVmdCArIFxcXCJweFxcXCI7XFxuICAgICAgfVxcbiAgICAgIGlmIChzY3JvbGwpXFxuICAgICAgICBzY3JvbGxJbnRvVmlldyh0aGlzLCBsZWZ0LCB0b3AsIGxlZnQgKyBub2RlLm9mZnNldFdpZHRoLCB0b3AgKyBub2RlLm9mZnNldEhlaWdodCk7XFxuICAgIH0sXFxuXFxuICAgIHRyaWdnZXJPbktleURvd246IG1ldGhvZE9wKG9uS2V5RG93biksXFxuICAgIHRyaWdnZXJPbktleVByZXNzOiBtZXRob2RPcChvbktleVByZXNzKSxcXG4gICAgdHJpZ2dlck9uS2V5VXA6IG9uS2V5VXAsXFxuXFxuICAgIGV4ZWNDb21tYW5kOiBmdW5jdGlvbihjbWQpIHtcXG4gICAgICBpZiAoY29tbWFuZHMuaGFzT3duUHJvcGVydHkoY21kKSlcXG4gICAgICAgIHJldHVybiBjb21tYW5kc1tjbWRdLmNhbGwobnVsbCwgdGhpcyk7XFxuICAgIH0sXFxuXFxuICAgIHRyaWdnZXJFbGVjdHJpYzogbWV0aG9kT3AoZnVuY3Rpb24odGV4dCkgeyB0cmlnZ2VyRWxlY3RyaWModGhpcywgdGV4dCk7IH0pLFxcblxcbiAgICBmaW5kUG9zSDogZnVuY3Rpb24oZnJvbSwgYW1vdW50LCB1bml0LCB2aXN1YWxseSkge1xcbiAgICAgIHZhciBkaXIgPSAxO1xcbiAgICAgIGlmIChhbW91bnQgPCAwKSB7IGRpciA9IC0xOyBhbW91bnQgPSAtYW1vdW50OyB9XFxuICAgICAgZm9yICh2YXIgaSA9IDAsIGN1ciA9IGNsaXBQb3ModGhpcy5kb2MsIGZyb20pOyBpIDwgYW1vdW50OyArK2kpIHtcXG4gICAgICAgIGN1ciA9IGZpbmRQb3NIKHRoaXMuZG9jLCBjdXIsIGRpciwgdW5pdCwgdmlzdWFsbHkpO1xcbiAgICAgICAgaWYgKGN1ci5oaXRTaWRlKSBicmVhaztcXG4gICAgICB9XFxuICAgICAgcmV0dXJuIGN1cjtcXG4gICAgfSxcXG5cXG4gICAgbW92ZUg6IG1ldGhvZE9wKGZ1bmN0aW9uKGRpciwgdW5pdCkge1xcbiAgICAgIHZhciBjbSA9IHRoaXM7XFxuICAgICAgY20uZXh0ZW5kU2VsZWN0aW9uc0J5KGZ1bmN0aW9uKHJhbmdlKSB7XFxuICAgICAgICBpZiAoY20uZGlzcGxheS5zaGlmdCB8fCBjbS5kb2MuZXh0ZW5kIHx8IHJhbmdlLmVtcHR5KCkpXFxuICAgICAgICAgIHJldHVybiBmaW5kUG9zSChjbS5kb2MsIHJhbmdlLmhlYWQsIGRpciwgdW5pdCwgY20ub3B0aW9ucy5ydGxNb3ZlVmlzdWFsbHkpO1xcbiAgICAgICAgZWxzZVxcbiAgICAgICAgICByZXR1cm4gZGlyIDwgMCA/IHJhbmdlLmZyb20oKSA6IHJhbmdlLnRvKCk7XFxuICAgICAgfSwgc2VsX21vdmUpO1xcbiAgICB9KSxcXG5cXG4gICAgZGVsZXRlSDogbWV0aG9kT3AoZnVuY3Rpb24oZGlyLCB1bml0KSB7XFxuICAgICAgdmFyIHNlbCA9IHRoaXMuZG9jLnNlbCwgZG9jID0gdGhpcy5kb2M7XFxuICAgICAgaWYgKHNlbC5zb21ldGhpbmdTZWxlY3RlZCgpKVxcbiAgICAgICAgZG9jLnJlcGxhY2VTZWxlY3Rpb24oXFxcIlxcXCIsIG51bGwsIFxcXCIrZGVsZXRlXFxcIik7XFxuICAgICAgZWxzZVxcbiAgICAgICAgZGVsZXRlTmVhclNlbGVjdGlvbih0aGlzLCBmdW5jdGlvbihyYW5nZSkge1xcbiAgICAgICAgICB2YXIgb3RoZXIgPSBmaW5kUG9zSChkb2MsIHJhbmdlLmhlYWQsIGRpciwgdW5pdCwgZmFsc2UpO1xcbiAgICAgICAgICByZXR1cm4gZGlyIDwgMCA/IHtmcm9tOiBvdGhlciwgdG86IHJhbmdlLmhlYWR9IDoge2Zyb206IHJhbmdlLmhlYWQsIHRvOiBvdGhlcn07XFxuICAgICAgICB9KTtcXG4gICAgfSksXFxuXFxuICAgIGZpbmRQb3NWOiBmdW5jdGlvbihmcm9tLCBhbW91bnQsIHVuaXQsIGdvYWxDb2x1bW4pIHtcXG4gICAgICB2YXIgZGlyID0gMSwgeCA9IGdvYWxDb2x1bW47XFxuICAgICAgaWYgKGFtb3VudCA8IDApIHsgZGlyID0gLTE7IGFtb3VudCA9IC1hbW91bnQ7IH1cXG4gICAgICBmb3IgKHZhciBpID0gMCwgY3VyID0gY2xpcFBvcyh0aGlzLmRvYywgZnJvbSk7IGkgPCBhbW91bnQ7ICsraSkge1xcbiAgICAgICAgdmFyIGNvb3JkcyA9IGN1cnNvckNvb3Jkcyh0aGlzLCBjdXIsIFxcXCJkaXZcXFwiKTtcXG4gICAgICAgIGlmICh4ID09IG51bGwpIHggPSBjb29yZHMubGVmdDtcXG4gICAgICAgIGVsc2UgY29vcmRzLmxlZnQgPSB4O1xcbiAgICAgICAgY3VyID0gZmluZFBvc1YodGhpcywgY29vcmRzLCBkaXIsIHVuaXQpO1xcbiAgICAgICAgaWYgKGN1ci5oaXRTaWRlKSBicmVhaztcXG4gICAgICB9XFxuICAgICAgcmV0dXJuIGN1cjtcXG4gICAgfSxcXG5cXG4gICAgbW92ZVY6IG1ldGhvZE9wKGZ1bmN0aW9uKGRpciwgdW5pdCkge1xcbiAgICAgIHZhciBjbSA9IHRoaXMsIGRvYyA9IHRoaXMuZG9jLCBnb2FscyA9IFtdO1xcbiAgICAgIHZhciBjb2xsYXBzZSA9ICFjbS5kaXNwbGF5LnNoaWZ0ICYmICFkb2MuZXh0ZW5kICYmIGRvYy5zZWwuc29tZXRoaW5nU2VsZWN0ZWQoKTtcXG4gICAgICBkb2MuZXh0ZW5kU2VsZWN0aW9uc0J5KGZ1bmN0aW9uKHJhbmdlKSB7XFxuICAgICAgICBpZiAoY29sbGFwc2UpXFxuICAgICAgICAgIHJldHVybiBkaXIgPCAwID8gcmFuZ2UuZnJvbSgpIDogcmFuZ2UudG8oKTtcXG4gICAgICAgIHZhciBoZWFkUG9zID0gY3Vyc29yQ29vcmRzKGNtLCByYW5nZS5oZWFkLCBcXFwiZGl2XFxcIik7XFxuICAgICAgICBpZiAocmFuZ2UuZ29hbENvbHVtbiAhPSBudWxsKSBoZWFkUG9zLmxlZnQgPSByYW5nZS5nb2FsQ29sdW1uO1xcbiAgICAgICAgZ29hbHMucHVzaChoZWFkUG9zLmxlZnQpO1xcbiAgICAgICAgdmFyIHBvcyA9IGZpbmRQb3NWKGNtLCBoZWFkUG9zLCBkaXIsIHVuaXQpO1xcbiAgICAgICAgaWYgKHVuaXQgPT0gXFxcInBhZ2VcXFwiICYmIHJhbmdlID09IGRvYy5zZWwucHJpbWFyeSgpKVxcbiAgICAgICAgICBhZGRUb1Njcm9sbFBvcyhjbSwgbnVsbCwgY2hhckNvb3JkcyhjbSwgcG9zLCBcXFwiZGl2XFxcIikudG9wIC0gaGVhZFBvcy50b3ApO1xcbiAgICAgICAgcmV0dXJuIHBvcztcXG4gICAgICB9LCBzZWxfbW92ZSk7XFxuICAgICAgaWYgKGdvYWxzLmxlbmd0aCkgZm9yICh2YXIgaSA9IDA7IGkgPCBkb2Muc2VsLnJhbmdlcy5sZW5ndGg7IGkrKylcXG4gICAgICAgIGRvYy5zZWwucmFuZ2VzW2ldLmdvYWxDb2x1bW4gPSBnb2Fsc1tpXTtcXG4gICAgfSksXFxuXFxuICAgIC8vIEZpbmQgdGhlIHdvcmQgYXQgdGhlIGdpdmVuIHBvc2l0aW9uIChhcyByZXR1cm5lZCBieSBjb29yZHNDaGFyKS5cXG4gICAgZmluZFdvcmRBdDogZnVuY3Rpb24ocG9zKSB7XFxuICAgICAgdmFyIGRvYyA9IHRoaXMuZG9jLCBsaW5lID0gZ2V0TGluZShkb2MsIHBvcy5saW5lKS50ZXh0O1xcbiAgICAgIHZhciBzdGFydCA9IHBvcy5jaCwgZW5kID0gcG9zLmNoO1xcbiAgICAgIGlmIChsaW5lKSB7XFxuICAgICAgICB2YXIgaGVscGVyID0gdGhpcy5nZXRIZWxwZXIocG9zLCBcXFwid29yZENoYXJzXFxcIik7XFxuICAgICAgICBpZiAoKHBvcy54UmVsIDwgMCB8fCBlbmQgPT0gbGluZS5sZW5ndGgpICYmIHN0YXJ0KSAtLXN0YXJ0OyBlbHNlICsrZW5kO1xcbiAgICAgICAgdmFyIHN0YXJ0Q2hhciA9IGxpbmUuY2hhckF0KHN0YXJ0KTtcXG4gICAgICAgIHZhciBjaGVjayA9IGlzV29yZENoYXIoc3RhcnRDaGFyLCBoZWxwZXIpXFxuICAgICAgICAgID8gZnVuY3Rpb24oY2gpIHsgcmV0dXJuIGlzV29yZENoYXIoY2gsIGhlbHBlcik7IH1cXG4gICAgICAgICAgOiAvXFxcXHMvLnRlc3Qoc3RhcnRDaGFyKSA/IGZ1bmN0aW9uKGNoKSB7cmV0dXJuIC9cXFxccy8udGVzdChjaCk7fVxcbiAgICAgICAgICA6IGZ1bmN0aW9uKGNoKSB7cmV0dXJuICEvXFxcXHMvLnRlc3QoY2gpICYmICFpc1dvcmRDaGFyKGNoKTt9O1xcbiAgICAgICAgd2hpbGUgKHN0YXJ0ID4gMCAmJiBjaGVjayhsaW5lLmNoYXJBdChzdGFydCAtIDEpKSkgLS1zdGFydDtcXG4gICAgICAgIHdoaWxlIChlbmQgPCBsaW5lLmxlbmd0aCAmJiBjaGVjayhsaW5lLmNoYXJBdChlbmQpKSkgKytlbmQ7XFxuICAgICAgfVxcbiAgICAgIHJldHVybiBuZXcgUmFuZ2UoUG9zKHBvcy5saW5lLCBzdGFydCksIFBvcyhwb3MubGluZSwgZW5kKSk7XFxuICAgIH0sXFxuXFxuICAgIHRvZ2dsZU92ZXJ3cml0ZTogZnVuY3Rpb24odmFsdWUpIHtcXG4gICAgICBpZiAodmFsdWUgIT0gbnVsbCAmJiB2YWx1ZSA9PSB0aGlzLnN0YXRlLm92ZXJ3cml0ZSkgcmV0dXJuO1xcbiAgICAgIGlmICh0aGlzLnN0YXRlLm92ZXJ3cml0ZSA9ICF0aGlzLnN0YXRlLm92ZXJ3cml0ZSlcXG4gICAgICAgIGFkZENsYXNzKHRoaXMuZGlzcGxheS5jdXJzb3JEaXYsIFxcXCJDb2RlTWlycm9yLW92ZXJ3cml0ZVxcXCIpO1xcbiAgICAgIGVsc2VcXG4gICAgICAgIHJtQ2xhc3ModGhpcy5kaXNwbGF5LmN1cnNvckRpdiwgXFxcIkNvZGVNaXJyb3Itb3ZlcndyaXRlXFxcIik7XFxuXFxuICAgICAgc2lnbmFsKHRoaXMsIFxcXCJvdmVyd3JpdGVUb2dnbGVcXFwiLCB0aGlzLCB0aGlzLnN0YXRlLm92ZXJ3cml0ZSk7XFxuICAgIH0sXFxuICAgIGhhc0ZvY3VzOiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuZGlzcGxheS5pbnB1dC5nZXRGaWVsZCgpID09IGFjdGl2ZUVsdCgpOyB9LFxcbiAgICBpc1JlYWRPbmx5OiBmdW5jdGlvbigpIHsgcmV0dXJuICEhKHRoaXMub3B0aW9ucy5yZWFkT25seSB8fCB0aGlzLmRvYy5jYW50RWRpdCk7IH0sXFxuXFxuICAgIHNjcm9sbFRvOiBtZXRob2RPcChmdW5jdGlvbih4LCB5KSB7XFxuICAgICAgaWYgKHggIT0gbnVsbCB8fCB5ICE9IG51bGwpIHJlc29sdmVTY3JvbGxUb1Bvcyh0aGlzKTtcXG4gICAgICBpZiAoeCAhPSBudWxsKSB0aGlzLmN1ck9wLnNjcm9sbExlZnQgPSB4O1xcbiAgICAgIGlmICh5ICE9IG51bGwpIHRoaXMuY3VyT3Auc2Nyb2xsVG9wID0geTtcXG4gICAgfSksXFxuICAgIGdldFNjcm9sbEluZm86IGZ1bmN0aW9uKCkge1xcbiAgICAgIHZhciBzY3JvbGxlciA9IHRoaXMuZGlzcGxheS5zY3JvbGxlcjtcXG4gICAgICByZXR1cm4ge2xlZnQ6IHNjcm9sbGVyLnNjcm9sbExlZnQsIHRvcDogc2Nyb2xsZXIuc2Nyb2xsVG9wLFxcbiAgICAgICAgICAgICAgaGVpZ2h0OiBzY3JvbGxlci5zY3JvbGxIZWlnaHQgLSBzY3JvbGxHYXAodGhpcykgLSB0aGlzLmRpc3BsYXkuYmFySGVpZ2h0LFxcbiAgICAgICAgICAgICAgd2lkdGg6IHNjcm9sbGVyLnNjcm9sbFdpZHRoIC0gc2Nyb2xsR2FwKHRoaXMpIC0gdGhpcy5kaXNwbGF5LmJhcldpZHRoLFxcbiAgICAgICAgICAgICAgY2xpZW50SGVpZ2h0OiBkaXNwbGF5SGVpZ2h0KHRoaXMpLCBjbGllbnRXaWR0aDogZGlzcGxheVdpZHRoKHRoaXMpfTtcXG4gICAgfSxcXG5cXG4gICAgc2Nyb2xsSW50b1ZpZXc6IG1ldGhvZE9wKGZ1bmN0aW9uKHJhbmdlLCBtYXJnaW4pIHtcXG4gICAgICBpZiAocmFuZ2UgPT0gbnVsbCkge1xcbiAgICAgICAgcmFuZ2UgPSB7ZnJvbTogdGhpcy5kb2Muc2VsLnByaW1hcnkoKS5oZWFkLCB0bzogbnVsbH07XFxuICAgICAgICBpZiAobWFyZ2luID09IG51bGwpIG1hcmdpbiA9IHRoaXMub3B0aW9ucy5jdXJzb3JTY3JvbGxNYXJnaW47XFxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgcmFuZ2UgPT0gXFxcIm51bWJlclxcXCIpIHtcXG4gICAgICAgIHJhbmdlID0ge2Zyb206IFBvcyhyYW5nZSwgMCksIHRvOiBudWxsfTtcXG4gICAgICB9IGVsc2UgaWYgKHJhbmdlLmZyb20gPT0gbnVsbCkge1xcbiAgICAgICAgcmFuZ2UgPSB7ZnJvbTogcmFuZ2UsIHRvOiBudWxsfTtcXG4gICAgICB9XFxuICAgICAgaWYgKCFyYW5nZS50bykgcmFuZ2UudG8gPSByYW5nZS5mcm9tO1xcbiAgICAgIHJhbmdlLm1hcmdpbiA9IG1hcmdpbiB8fCAwO1xcblxcbiAgICAgIGlmIChyYW5nZS5mcm9tLmxpbmUgIT0gbnVsbCkge1xcbiAgICAgICAgcmVzb2x2ZVNjcm9sbFRvUG9zKHRoaXMpO1xcbiAgICAgICAgdGhpcy5jdXJPcC5zY3JvbGxUb1BvcyA9IHJhbmdlO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICB2YXIgc1BvcyA9IGNhbGN1bGF0ZVNjcm9sbFBvcyh0aGlzLCBNYXRoLm1pbihyYW5nZS5mcm9tLmxlZnQsIHJhbmdlLnRvLmxlZnQpLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5taW4ocmFuZ2UuZnJvbS50b3AsIHJhbmdlLnRvLnRvcCkgLSByYW5nZS5tYXJnaW4sXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBNYXRoLm1heChyYW5nZS5mcm9tLnJpZ2h0LCByYW5nZS50by5yaWdodCksXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBNYXRoLm1heChyYW5nZS5mcm9tLmJvdHRvbSwgcmFuZ2UudG8uYm90dG9tKSArIHJhbmdlLm1hcmdpbik7XFxuICAgICAgICB0aGlzLnNjcm9sbFRvKHNQb3Muc2Nyb2xsTGVmdCwgc1Bvcy5zY3JvbGxUb3ApO1xcbiAgICAgIH1cXG4gICAgfSksXFxuXFxuICAgIHNldFNpemU6IG1ldGhvZE9wKGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQpIHtcXG4gICAgICB2YXIgY20gPSB0aGlzO1xcbiAgICAgIGZ1bmN0aW9uIGludGVycHJldCh2YWwpIHtcXG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsID09IFxcXCJudW1iZXJcXFwiIHx8IC9eXFxcXGQrJC8udGVzdChTdHJpbmcodmFsKSkgPyB2YWwgKyBcXFwicHhcXFwiIDogdmFsO1xcbiAgICAgIH1cXG4gICAgICBpZiAod2lkdGggIT0gbnVsbCkgY20uZGlzcGxheS53cmFwcGVyLnN0eWxlLndpZHRoID0gaW50ZXJwcmV0KHdpZHRoKTtcXG4gICAgICBpZiAoaGVpZ2h0ICE9IG51bGwpIGNtLmRpc3BsYXkud3JhcHBlci5zdHlsZS5oZWlnaHQgPSBpbnRlcnByZXQoaGVpZ2h0KTtcXG4gICAgICBpZiAoY20ub3B0aW9ucy5saW5lV3JhcHBpbmcpIGNsZWFyTGluZU1lYXN1cmVtZW50Q2FjaGUodGhpcyk7XFxuICAgICAgdmFyIGxpbmVObyA9IGNtLmRpc3BsYXkudmlld0Zyb207XFxuICAgICAgY20uZG9jLml0ZXIobGluZU5vLCBjbS5kaXNwbGF5LnZpZXdUbywgZnVuY3Rpb24obGluZSkge1xcbiAgICAgICAgaWYgKGxpbmUud2lkZ2V0cykgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lLndpZGdldHMubGVuZ3RoOyBpKyspXFxuICAgICAgICAgIGlmIChsaW5lLndpZGdldHNbaV0ubm9IU2Nyb2xsKSB7IHJlZ0xpbmVDaGFuZ2UoY20sIGxpbmVObywgXFxcIndpZGdldFxcXCIpOyBicmVhazsgfVxcbiAgICAgICAgKytsaW5lTm87XFxuICAgICAgfSk7XFxuICAgICAgY20uY3VyT3AuZm9yY2VVcGRhdGUgPSB0cnVlO1xcbiAgICAgIHNpZ25hbChjbSwgXFxcInJlZnJlc2hcXFwiLCB0aGlzKTtcXG4gICAgfSksXFxuXFxuICAgIG9wZXJhdGlvbjogZnVuY3Rpb24oZil7cmV0dXJuIHJ1bkluT3AodGhpcywgZik7fSxcXG5cXG4gICAgcmVmcmVzaDogbWV0aG9kT3AoZnVuY3Rpb24oKSB7XFxuICAgICAgdmFyIG9sZEhlaWdodCA9IHRoaXMuZGlzcGxheS5jYWNoZWRUZXh0SGVpZ2h0O1xcbiAgICAgIHJlZ0NoYW5nZSh0aGlzKTtcXG4gICAgICB0aGlzLmN1ck9wLmZvcmNlVXBkYXRlID0gdHJ1ZTtcXG4gICAgICBjbGVhckNhY2hlcyh0aGlzKTtcXG4gICAgICB0aGlzLnNjcm9sbFRvKHRoaXMuZG9jLnNjcm9sbExlZnQsIHRoaXMuZG9jLnNjcm9sbFRvcCk7XFxuICAgICAgdXBkYXRlR3V0dGVyU3BhY2UodGhpcyk7XFxuICAgICAgaWYgKG9sZEhlaWdodCA9PSBudWxsIHx8IE1hdGguYWJzKG9sZEhlaWdodCAtIHRleHRIZWlnaHQodGhpcy5kaXNwbGF5KSkgPiAuNSlcXG4gICAgICAgIGVzdGltYXRlTGluZUhlaWdodHModGhpcyk7XFxuICAgICAgc2lnbmFsKHRoaXMsIFxcXCJyZWZyZXNoXFxcIiwgdGhpcyk7XFxuICAgIH0pLFxcblxcbiAgICBzd2FwRG9jOiBtZXRob2RPcChmdW5jdGlvbihkb2MpIHtcXG4gICAgICB2YXIgb2xkID0gdGhpcy5kb2M7XFxuICAgICAgb2xkLmNtID0gbnVsbDtcXG4gICAgICBhdHRhY2hEb2ModGhpcywgZG9jKTtcXG4gICAgICBjbGVhckNhY2hlcyh0aGlzKTtcXG4gICAgICB0aGlzLmRpc3BsYXkuaW5wdXQucmVzZXQoKTtcXG4gICAgICB0aGlzLnNjcm9sbFRvKGRvYy5zY3JvbGxMZWZ0LCBkb2Muc2Nyb2xsVG9wKTtcXG4gICAgICB0aGlzLmN1ck9wLmZvcmNlU2Nyb2xsID0gdHJ1ZTtcXG4gICAgICBzaWduYWxMYXRlcih0aGlzLCBcXFwic3dhcERvY1xcXCIsIHRoaXMsIG9sZCk7XFxuICAgICAgcmV0dXJuIG9sZDtcXG4gICAgfSksXFxuXFxuICAgIGdldElucHV0RmllbGQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZGlzcGxheS5pbnB1dC5nZXRGaWVsZCgpO30sXFxuICAgIGdldFdyYXBwZXJFbGVtZW50OiBmdW5jdGlvbigpe3JldHVybiB0aGlzLmRpc3BsYXkud3JhcHBlcjt9LFxcbiAgICBnZXRTY3JvbGxlckVsZW1lbnQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZGlzcGxheS5zY3JvbGxlcjt9LFxcbiAgICBnZXRHdXR0ZXJFbGVtZW50OiBmdW5jdGlvbigpe3JldHVybiB0aGlzLmRpc3BsYXkuZ3V0dGVyczt9XFxuICB9O1xcbiAgZXZlbnRNaXhpbihDb2RlTWlycm9yKTtcXG5cXG4gIC8vIE9QVElPTiBERUZBVUxUU1xcblxcbiAgLy8gVGhlIGRlZmF1bHQgY29uZmlndXJhdGlvbiBvcHRpb25zLlxcbiAgdmFyIGRlZmF1bHRzID0gQ29kZU1pcnJvci5kZWZhdWx0cyA9IHt9O1xcbiAgLy8gRnVuY3Rpb25zIHRvIHJ1biB3aGVuIG9wdGlvbnMgYXJlIGNoYW5nZWQuXFxuICB2YXIgb3B0aW9uSGFuZGxlcnMgPSBDb2RlTWlycm9yLm9wdGlvbkhhbmRsZXJzID0ge307XFxuXFxuICBmdW5jdGlvbiBvcHRpb24obmFtZSwgZGVmbHQsIGhhbmRsZSwgbm90T25Jbml0KSB7XFxuICAgIENvZGVNaXJyb3IuZGVmYXVsdHNbbmFtZV0gPSBkZWZsdDtcXG4gICAgaWYgKGhhbmRsZSkgb3B0aW9uSGFuZGxlcnNbbmFtZV0gPVxcbiAgICAgIG5vdE9uSW5pdCA/IGZ1bmN0aW9uKGNtLCB2YWwsIG9sZCkge2lmIChvbGQgIT0gSW5pdCkgaGFuZGxlKGNtLCB2YWwsIG9sZCk7fSA6IGhhbmRsZTtcXG4gIH1cXG5cXG4gIC8vIFBhc3NlZCB0byBvcHRpb24gaGFuZGxlcnMgd2hlbiB0aGVyZSBpcyBubyBvbGQgdmFsdWUuXFxuICB2YXIgSW5pdCA9IENvZGVNaXJyb3IuSW5pdCA9IHt0b1N0cmluZzogZnVuY3Rpb24oKXtyZXR1cm4gXFxcIkNvZGVNaXJyb3IuSW5pdFxcXCI7fX07XFxuXFxuICAvLyBUaGVzZSB0d28gYXJlLCBvbiBpbml0LCBjYWxsZWQgZnJvbSB0aGUgY29uc3RydWN0b3IgYmVjYXVzZSB0aGV5XFxuICAvLyBoYXZlIHRvIGJlIGluaXRpYWxpemVkIGJlZm9yZSB0aGUgZWRpdG9yIGNhbiBzdGFydCBhdCBhbGwuXFxuICBvcHRpb24oXFxcInZhbHVlXFxcIiwgXFxcIlxcXCIsIGZ1bmN0aW9uKGNtLCB2YWwpIHtcXG4gICAgY20uc2V0VmFsdWUodmFsKTtcXG4gIH0sIHRydWUpO1xcbiAgb3B0aW9uKFxcXCJtb2RlXFxcIiwgbnVsbCwgZnVuY3Rpb24oY20sIHZhbCkge1xcbiAgICBjbS5kb2MubW9kZU9wdGlvbiA9IHZhbDtcXG4gICAgbG9hZE1vZGUoY20pO1xcbiAgfSwgdHJ1ZSk7XFxuXFxuICBvcHRpb24oXFxcImluZGVudFVuaXRcXFwiLCAyLCBsb2FkTW9kZSwgdHJ1ZSk7XFxuICBvcHRpb24oXFxcImluZGVudFdpdGhUYWJzXFxcIiwgZmFsc2UpO1xcbiAgb3B0aW9uKFxcXCJzbWFydEluZGVudFxcXCIsIHRydWUpO1xcbiAgb3B0aW9uKFxcXCJ0YWJTaXplXFxcIiwgNCwgZnVuY3Rpb24oY20pIHtcXG4gICAgcmVzZXRNb2RlU3RhdGUoY20pO1xcbiAgICBjbGVhckNhY2hlcyhjbSk7XFxuICAgIHJlZ0NoYW5nZShjbSk7XFxuICB9LCB0cnVlKTtcXG4gIG9wdGlvbihcXFwibGluZVNlcGFyYXRvclxcXCIsIG51bGwsIGZ1bmN0aW9uKGNtLCB2YWwpIHtcXG4gICAgY20uZG9jLmxpbmVTZXAgPSB2YWw7XFxuICAgIGlmICghdmFsKSByZXR1cm47XFxuICAgIHZhciBuZXdCcmVha3MgPSBbXSwgbGluZU5vID0gY20uZG9jLmZpcnN0O1xcbiAgICBjbS5kb2MuaXRlcihmdW5jdGlvbihsaW5lKSB7XFxuICAgICAgZm9yICh2YXIgcG9zID0gMDs7KSB7XFxuICAgICAgICB2YXIgZm91bmQgPSBsaW5lLnRleHQuaW5kZXhPZih2YWwsIHBvcyk7XFxuICAgICAgICBpZiAoZm91bmQgPT0gLTEpIGJyZWFrO1xcbiAgICAgICAgcG9zID0gZm91bmQgKyB2YWwubGVuZ3RoO1xcbiAgICAgICAgbmV3QnJlYWtzLnB1c2goUG9zKGxpbmVObywgZm91bmQpKTtcXG4gICAgICB9XFxuICAgICAgbGluZU5vKys7XFxuICAgIH0pO1xcbiAgICBmb3IgKHZhciBpID0gbmV3QnJlYWtzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxcbiAgICAgIHJlcGxhY2VSYW5nZShjbS5kb2MsIHZhbCwgbmV3QnJlYWtzW2ldLCBQb3MobmV3QnJlYWtzW2ldLmxpbmUsIG5ld0JyZWFrc1tpXS5jaCArIHZhbC5sZW5ndGgpKVxcbiAgfSk7XFxuICBvcHRpb24oXFxcInNwZWNpYWxDaGFyc1xcXCIsIC9bXFxcXHUwMDAwLVxcXFx1MDAxZlxcXFx1MDA3ZlxcXFx1MDBhZFxcXFx1MjAwYi1cXFxcdTIwMGZcXFxcdTIwMjhcXFxcdTIwMjlcXFxcdWZlZmZdL2csIGZ1bmN0aW9uKGNtLCB2YWwsIG9sZCkge1xcbiAgICBjbS5zdGF0ZS5zcGVjaWFsQ2hhcnMgPSBuZXcgUmVnRXhwKHZhbC5zb3VyY2UgKyAodmFsLnRlc3QoXFxcIlxcXFx0XFxcIikgPyBcXFwiXFxcIiA6IFxcXCJ8XFxcXHRcXFwiKSwgXFxcImdcXFwiKTtcXG4gICAgaWYgKG9sZCAhPSBDb2RlTWlycm9yLkluaXQpIGNtLnJlZnJlc2goKTtcXG4gIH0pO1xcbiAgb3B0aW9uKFxcXCJzcGVjaWFsQ2hhclBsYWNlaG9sZGVyXFxcIiwgZGVmYXVsdFNwZWNpYWxDaGFyUGxhY2Vob2xkZXIsIGZ1bmN0aW9uKGNtKSB7Y20ucmVmcmVzaCgpO30sIHRydWUpO1xcbiAgb3B0aW9uKFxcXCJlbGVjdHJpY0NoYXJzXFxcIiwgdHJ1ZSk7XFxuICBvcHRpb24oXFxcImlucHV0U3R5bGVcXFwiLCBtb2JpbGUgPyBcXFwiY29udGVudGVkaXRhYmxlXFxcIiA6IFxcXCJ0ZXh0YXJlYVxcXCIsIGZ1bmN0aW9uKCkge1xcbiAgICB0aHJvdyBuZXcgRXJyb3IoXFxcImlucHV0U3R5bGUgY2FuIG5vdCAoeWV0KSBiZSBjaGFuZ2VkIGluIGEgcnVubmluZyBlZGl0b3JcXFwiKTsgLy8gRklYTUVcXG4gIH0sIHRydWUpO1xcbiAgb3B0aW9uKFxcXCJzcGVsbGNoZWNrXFxcIiwgZmFsc2UsIGZ1bmN0aW9uKGNtLCB2YWwpIHtcXG4gICAgY20uZ2V0SW5wdXRGaWVsZCgpLnNwZWxsY2hlY2sgPSB2YWxcXG4gIH0sIHRydWUpO1xcbiAgb3B0aW9uKFxcXCJydGxNb3ZlVmlzdWFsbHlcXFwiLCAhd2luZG93cyk7XFxuICBvcHRpb24oXFxcIndob2xlTGluZVVwZGF0ZUJlZm9yZVxcXCIsIHRydWUpO1xcblxcbiAgb3B0aW9uKFxcXCJ0aGVtZVxcXCIsIFxcXCJkZWZhdWx0XFxcIiwgZnVuY3Rpb24oY20pIHtcXG4gICAgdGhlbWVDaGFuZ2VkKGNtKTtcXG4gICAgZ3V0dGVyc0NoYW5nZWQoY20pO1xcbiAgfSwgdHJ1ZSk7XFxuICBvcHRpb24oXFxcImtleU1hcFxcXCIsIFxcXCJkZWZhdWx0XFxcIiwgZnVuY3Rpb24oY20sIHZhbCwgb2xkKSB7XFxuICAgIHZhciBuZXh0ID0gZ2V0S2V5TWFwKHZhbCk7XFxuICAgIHZhciBwcmV2ID0gb2xkICE9IENvZGVNaXJyb3IuSW5pdCAmJiBnZXRLZXlNYXAob2xkKTtcXG4gICAgaWYgKHByZXYgJiYgcHJldi5kZXRhY2gpIHByZXYuZGV0YWNoKGNtLCBuZXh0KTtcXG4gICAgaWYgKG5leHQuYXR0YWNoKSBuZXh0LmF0dGFjaChjbSwgcHJldiB8fCBudWxsKTtcXG4gIH0pO1xcbiAgb3B0aW9uKFxcXCJleHRyYUtleXNcXFwiLCBudWxsKTtcXG5cXG4gIG9wdGlvbihcXFwibGluZVdyYXBwaW5nXFxcIiwgZmFsc2UsIHdyYXBwaW5nQ2hhbmdlZCwgdHJ1ZSk7XFxuICBvcHRpb24oXFxcImd1dHRlcnNcXFwiLCBbXSwgZnVuY3Rpb24oY20pIHtcXG4gICAgc2V0R3V0dGVyc0ZvckxpbmVOdW1iZXJzKGNtLm9wdGlvbnMpO1xcbiAgICBndXR0ZXJzQ2hhbmdlZChjbSk7XFxuICB9LCB0cnVlKTtcXG4gIG9wdGlvbihcXFwiZml4ZWRHdXR0ZXJcXFwiLCB0cnVlLCBmdW5jdGlvbihjbSwgdmFsKSB7XFxuICAgIGNtLmRpc3BsYXkuZ3V0dGVycy5zdHlsZS5sZWZ0ID0gdmFsID8gY29tcGVuc2F0ZUZvckhTY3JvbGwoY20uZGlzcGxheSkgKyBcXFwicHhcXFwiIDogXFxcIjBcXFwiO1xcbiAgICBjbS5yZWZyZXNoKCk7XFxuICB9LCB0cnVlKTtcXG4gIG9wdGlvbihcXFwiY292ZXJHdXR0ZXJOZXh0VG9TY3JvbGxiYXJcXFwiLCBmYWxzZSwgZnVuY3Rpb24oY20pIHt1cGRhdGVTY3JvbGxiYXJzKGNtKTt9LCB0cnVlKTtcXG4gIG9wdGlvbihcXFwic2Nyb2xsYmFyU3R5bGVcXFwiLCBcXFwibmF0aXZlXFxcIiwgZnVuY3Rpb24oY20pIHtcXG4gICAgaW5pdFNjcm9sbGJhcnMoY20pO1xcbiAgICB1cGRhdGVTY3JvbGxiYXJzKGNtKTtcXG4gICAgY20uZGlzcGxheS5zY3JvbGxiYXJzLnNldFNjcm9sbFRvcChjbS5kb2Muc2Nyb2xsVG9wKTtcXG4gICAgY20uZGlzcGxheS5zY3JvbGxiYXJzLnNldFNjcm9sbExlZnQoY20uZG9jLnNjcm9sbExlZnQpO1xcbiAgfSwgdHJ1ZSk7XFxuICBvcHRpb24oXFxcImxpbmVOdW1iZXJzXFxcIiwgZmFsc2UsIGZ1bmN0aW9uKGNtKSB7XFxuICAgIHNldEd1dHRlcnNGb3JMaW5lTnVtYmVycyhjbS5vcHRpb25zKTtcXG4gICAgZ3V0dGVyc0NoYW5nZWQoY20pO1xcbiAgfSwgdHJ1ZSk7XFxuICBvcHRpb24oXFxcImZpcnN0TGluZU51bWJlclxcXCIsIDEsIGd1dHRlcnNDaGFuZ2VkLCB0cnVlKTtcXG4gIG9wdGlvbihcXFwibGluZU51bWJlckZvcm1hdHRlclxcXCIsIGZ1bmN0aW9uKGludGVnZXIpIHtyZXR1cm4gaW50ZWdlcjt9LCBndXR0ZXJzQ2hhbmdlZCwgdHJ1ZSk7XFxuICBvcHRpb24oXFxcInNob3dDdXJzb3JXaGVuU2VsZWN0aW5nXFxcIiwgZmFsc2UsIHVwZGF0ZVNlbGVjdGlvbiwgdHJ1ZSk7XFxuXFxuICBvcHRpb24oXFxcInJlc2V0U2VsZWN0aW9uT25Db250ZXh0TWVudVxcXCIsIHRydWUpO1xcbiAgb3B0aW9uKFxcXCJsaW5lV2lzZUNvcHlDdXRcXFwiLCB0cnVlKTtcXG5cXG4gIG9wdGlvbihcXFwicmVhZE9ubHlcXFwiLCBmYWxzZSwgZnVuY3Rpb24oY20sIHZhbCkge1xcbiAgICBpZiAodmFsID09IFxcXCJub2N1cnNvclxcXCIpIHtcXG4gICAgICBvbkJsdXIoY20pO1xcbiAgICAgIGNtLmRpc3BsYXkuaW5wdXQuYmx1cigpO1xcbiAgICAgIGNtLmRpc3BsYXkuZGlzYWJsZWQgPSB0cnVlO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIGNtLmRpc3BsYXkuZGlzYWJsZWQgPSBmYWxzZTtcXG4gICAgfVxcbiAgICBjbS5kaXNwbGF5LmlucHV0LnJlYWRPbmx5Q2hhbmdlZCh2YWwpXFxuICB9KTtcXG4gIG9wdGlvbihcXFwiZGlzYWJsZUlucHV0XFxcIiwgZmFsc2UsIGZ1bmN0aW9uKGNtLCB2YWwpIHtpZiAoIXZhbCkgY20uZGlzcGxheS5pbnB1dC5yZXNldCgpO30sIHRydWUpO1xcbiAgb3B0aW9uKFxcXCJkcmFnRHJvcFxcXCIsIHRydWUsIGRyYWdEcm9wQ2hhbmdlZCk7XFxuICBvcHRpb24oXFxcImFsbG93RHJvcEZpbGVUeXBlc1xcXCIsIG51bGwpO1xcblxcbiAgb3B0aW9uKFxcXCJjdXJzb3JCbGlua1JhdGVcXFwiLCA1MzApO1xcbiAgb3B0aW9uKFxcXCJjdXJzb3JTY3JvbGxNYXJnaW5cXFwiLCAwKTtcXG4gIG9wdGlvbihcXFwiY3Vyc29ySGVpZ2h0XFxcIiwgMSwgdXBkYXRlU2VsZWN0aW9uLCB0cnVlKTtcXG4gIG9wdGlvbihcXFwic2luZ2xlQ3Vyc29ySGVpZ2h0UGVyTGluZVxcXCIsIHRydWUsIHVwZGF0ZVNlbGVjdGlvbiwgdHJ1ZSk7XFxuICBvcHRpb24oXFxcIndvcmtUaW1lXFxcIiwgMTAwKTtcXG4gIG9wdGlvbihcXFwid29ya0RlbGF5XFxcIiwgMTAwKTtcXG4gIG9wdGlvbihcXFwiZmxhdHRlblNwYW5zXFxcIiwgdHJ1ZSwgcmVzZXRNb2RlU3RhdGUsIHRydWUpO1xcbiAgb3B0aW9uKFxcXCJhZGRNb2RlQ2xhc3NcXFwiLCBmYWxzZSwgcmVzZXRNb2RlU3RhdGUsIHRydWUpO1xcbiAgb3B0aW9uKFxcXCJwb2xsSW50ZXJ2YWxcXFwiLCAxMDApO1xcbiAgb3B0aW9uKFxcXCJ1bmRvRGVwdGhcXFwiLCAyMDAsIGZ1bmN0aW9uKGNtLCB2YWwpe2NtLmRvYy5oaXN0b3J5LnVuZG9EZXB0aCA9IHZhbDt9KTtcXG4gIG9wdGlvbihcXFwiaGlzdG9yeUV2ZW50RGVsYXlcXFwiLCAxMjUwKTtcXG4gIG9wdGlvbihcXFwidmlld3BvcnRNYXJnaW5cXFwiLCAxMCwgZnVuY3Rpb24oY20pe2NtLnJlZnJlc2goKTt9LCB0cnVlKTtcXG4gIG9wdGlvbihcXFwibWF4SGlnaGxpZ2h0TGVuZ3RoXFxcIiwgMTAwMDAsIHJlc2V0TW9kZVN0YXRlLCB0cnVlKTtcXG4gIG9wdGlvbihcXFwibW92ZUlucHV0V2l0aEN1cnNvclxcXCIsIHRydWUsIGZ1bmN0aW9uKGNtLCB2YWwpIHtcXG4gICAgaWYgKCF2YWwpIGNtLmRpc3BsYXkuaW5wdXQucmVzZXRQb3NpdGlvbigpO1xcbiAgfSk7XFxuXFxuICBvcHRpb24oXFxcInRhYmluZGV4XFxcIiwgbnVsbCwgZnVuY3Rpb24oY20sIHZhbCkge1xcbiAgICBjbS5kaXNwbGF5LmlucHV0LmdldEZpZWxkKCkudGFiSW5kZXggPSB2YWwgfHwgXFxcIlxcXCI7XFxuICB9KTtcXG4gIG9wdGlvbihcXFwiYXV0b2ZvY3VzXFxcIiwgbnVsbCk7XFxuXFxuICAvLyBNT0RFIERFRklOSVRJT04gQU5EIFFVRVJZSU5HXFxuXFxuICAvLyBLbm93biBtb2RlcywgYnkgbmFtZSBhbmQgYnkgTUlNRVxcbiAgdmFyIG1vZGVzID0gQ29kZU1pcnJvci5tb2RlcyA9IHt9LCBtaW1lTW9kZXMgPSBDb2RlTWlycm9yLm1pbWVNb2RlcyA9IHt9O1xcblxcbiAgLy8gRXh0cmEgYXJndW1lbnRzIGFyZSBzdG9yZWQgYXMgdGhlIG1vZGUncyBkZXBlbmRlbmNpZXMsIHdoaWNoIGlzXFxuICAvLyB1c2VkIGJ5IChsZWdhY3kpIG1lY2hhbmlzbXMgbGlrZSBsb2FkbW9kZS5qcyB0byBhdXRvbWF0aWNhbGx5XFxuICAvLyBsb2FkIGEgbW9kZS4gKFByZWZlcnJlZCBtZWNoYW5pc20gaXMgdGhlIHJlcXVpcmUvZGVmaW5lIGNhbGxzLilcXG4gIENvZGVNaXJyb3IuZGVmaW5lTW9kZSA9IGZ1bmN0aW9uKG5hbWUsIG1vZGUpIHtcXG4gICAgaWYgKCFDb2RlTWlycm9yLmRlZmF1bHRzLm1vZGUgJiYgbmFtZSAhPSBcXFwibnVsbFxcXCIpIENvZGVNaXJyb3IuZGVmYXVsdHMubW9kZSA9IG5hbWU7XFxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMilcXG4gICAgICBtb2RlLmRlcGVuZGVuY2llcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMik7XFxuICAgIG1vZGVzW25hbWVdID0gbW9kZTtcXG4gIH07XFxuXFxuICBDb2RlTWlycm9yLmRlZmluZU1JTUUgPSBmdW5jdGlvbihtaW1lLCBzcGVjKSB7XFxuICAgIG1pbWVNb2Rlc1ttaW1lXSA9IHNwZWM7XFxuICB9O1xcblxcbiAgLy8gR2l2ZW4gYSBNSU1FIHR5cGUsIGEge25hbWUsIC4uLm9wdGlvbnN9IGNvbmZpZyBvYmplY3QsIG9yIGEgbmFtZVxcbiAgLy8gc3RyaW5nLCByZXR1cm4gYSBtb2RlIGNvbmZpZyBvYmplY3QuXFxuICBDb2RlTWlycm9yLnJlc29sdmVNb2RlID0gZnVuY3Rpb24oc3BlYykge1xcbiAgICBpZiAodHlwZW9mIHNwZWMgPT0gXFxcInN0cmluZ1xcXCIgJiYgbWltZU1vZGVzLmhhc093blByb3BlcnR5KHNwZWMpKSB7XFxuICAgICAgc3BlYyA9IG1pbWVNb2Rlc1tzcGVjXTtcXG4gICAgfSBlbHNlIGlmIChzcGVjICYmIHR5cGVvZiBzcGVjLm5hbWUgPT0gXFxcInN0cmluZ1xcXCIgJiYgbWltZU1vZGVzLmhhc093blByb3BlcnR5KHNwZWMubmFtZSkpIHtcXG4gICAgICB2YXIgZm91bmQgPSBtaW1lTW9kZXNbc3BlYy5uYW1lXTtcXG4gICAgICBpZiAodHlwZW9mIGZvdW5kID09IFxcXCJzdHJpbmdcXFwiKSBmb3VuZCA9IHtuYW1lOiBmb3VuZH07XFxuICAgICAgc3BlYyA9IGNyZWF0ZU9iaihmb3VuZCwgc3BlYyk7XFxuICAgICAgc3BlYy5uYW1lID0gZm91bmQubmFtZTtcXG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygc3BlYyA9PSBcXFwic3RyaW5nXFxcIiAmJiAvXltcXFxcd1xcXFwtXStcXFxcL1tcXFxcd1xcXFwtXStcXFxcK3htbCQvLnRlc3Qoc3BlYykpIHtcXG4gICAgICByZXR1cm4gQ29kZU1pcnJvci5yZXNvbHZlTW9kZShcXFwiYXBwbGljYXRpb24veG1sXFxcIik7XFxuICAgIH0gZWxzZSBpZiAodHlwZW9mIHNwZWMgPT0gXFxcInN0cmluZ1xcXCIgJiYgL15bXFxcXHdcXFxcLV0rXFxcXC9bXFxcXHdcXFxcLV0rXFxcXCtqc29uJC8udGVzdChzcGVjKSkge1xcbiAgICAgIHJldHVybiBDb2RlTWlycm9yLnJlc29sdmVNb2RlKFxcXCJhcHBsaWNhdGlvbi9qc29uXFxcIik7XFxuICAgIH1cXG4gICAgaWYgKHR5cGVvZiBzcGVjID09IFxcXCJzdHJpbmdcXFwiKSByZXR1cm4ge25hbWU6IHNwZWN9O1xcbiAgICBlbHNlIHJldHVybiBzcGVjIHx8IHtuYW1lOiBcXFwibnVsbFxcXCJ9O1xcbiAgfTtcXG5cXG4gIC8vIEdpdmVuIGEgbW9kZSBzcGVjIChhbnl0aGluZyB0aGF0IHJlc29sdmVNb2RlIGFjY2VwdHMpLCBmaW5kIGFuZFxcbiAgLy8gaW5pdGlhbGl6ZSBhbiBhY3R1YWwgbW9kZSBvYmplY3QuXFxuICBDb2RlTWlycm9yLmdldE1vZGUgPSBmdW5jdGlvbihvcHRpb25zLCBzcGVjKSB7XFxuICAgIHZhciBzcGVjID0gQ29kZU1pcnJvci5yZXNvbHZlTW9kZShzcGVjKTtcXG4gICAgdmFyIG1mYWN0b3J5ID0gbW9kZXNbc3BlYy5uYW1lXTtcXG4gICAgaWYgKCFtZmFjdG9yeSkgcmV0dXJuIENvZGVNaXJyb3IuZ2V0TW9kZShvcHRpb25zLCBcXFwidGV4dC9wbGFpblxcXCIpO1xcbiAgICB2YXIgbW9kZU9iaiA9IG1mYWN0b3J5KG9wdGlvbnMsIHNwZWMpO1xcbiAgICBpZiAobW9kZUV4dGVuc2lvbnMuaGFzT3duUHJvcGVydHkoc3BlYy5uYW1lKSkge1xcbiAgICAgIHZhciBleHRzID0gbW9kZUV4dGVuc2lvbnNbc3BlYy5uYW1lXTtcXG4gICAgICBmb3IgKHZhciBwcm9wIGluIGV4dHMpIHtcXG4gICAgICAgIGlmICghZXh0cy5oYXNPd25Qcm9wZXJ0eShwcm9wKSkgY29udGludWU7XFxuICAgICAgICBpZiAobW9kZU9iai5oYXNPd25Qcm9wZXJ0eShwcm9wKSkgbW9kZU9ialtcXFwiX1xcXCIgKyBwcm9wXSA9IG1vZGVPYmpbcHJvcF07XFxuICAgICAgICBtb2RlT2JqW3Byb3BdID0gZXh0c1twcm9wXTtcXG4gICAgICB9XFxuICAgIH1cXG4gICAgbW9kZU9iai5uYW1lID0gc3BlYy5uYW1lO1xcbiAgICBpZiAoc3BlYy5oZWxwZXJUeXBlKSBtb2RlT2JqLmhlbHBlclR5cGUgPSBzcGVjLmhlbHBlclR5cGU7XFxuICAgIGlmIChzcGVjLm1vZGVQcm9wcykgZm9yICh2YXIgcHJvcCBpbiBzcGVjLm1vZGVQcm9wcylcXG4gICAgICBtb2RlT2JqW3Byb3BdID0gc3BlYy5tb2RlUHJvcHNbcHJvcF07XFxuXFxuICAgIHJldHVybiBtb2RlT2JqO1xcbiAgfTtcXG5cXG4gIC8vIE1pbmltYWwgZGVmYXVsdCBtb2RlLlxcbiAgQ29kZU1pcnJvci5kZWZpbmVNb2RlKFxcXCJudWxsXFxcIiwgZnVuY3Rpb24oKSB7XFxuICAgIHJldHVybiB7dG9rZW46IGZ1bmN0aW9uKHN0cmVhbSkge3N0cmVhbS5za2lwVG9FbmQoKTt9fTtcXG4gIH0pO1xcbiAgQ29kZU1pcnJvci5kZWZpbmVNSU1FKFxcXCJ0ZXh0L3BsYWluXFxcIiwgXFxcIm51bGxcXFwiKTtcXG5cXG4gIC8vIFRoaXMgY2FuIGJlIHVzZWQgdG8gYXR0YWNoIHByb3BlcnRpZXMgdG8gbW9kZSBvYmplY3RzIGZyb21cXG4gIC8vIG91dHNpZGUgdGhlIGFjdHVhbCBtb2RlIGRlZmluaXRpb24uXFxuICB2YXIgbW9kZUV4dGVuc2lvbnMgPSBDb2RlTWlycm9yLm1vZGVFeHRlbnNpb25zID0ge307XFxuICBDb2RlTWlycm9yLmV4dGVuZE1vZGUgPSBmdW5jdGlvbihtb2RlLCBwcm9wZXJ0aWVzKSB7XFxuICAgIHZhciBleHRzID0gbW9kZUV4dGVuc2lvbnMuaGFzT3duUHJvcGVydHkobW9kZSkgPyBtb2RlRXh0ZW5zaW9uc1ttb2RlXSA6IChtb2RlRXh0ZW5zaW9uc1ttb2RlXSA9IHt9KTtcXG4gICAgY29weU9iaihwcm9wZXJ0aWVzLCBleHRzKTtcXG4gIH07XFxuXFxuICAvLyBFWFRFTlNJT05TXFxuXFxuICBDb2RlTWlycm9yLmRlZmluZUV4dGVuc2lvbiA9IGZ1bmN0aW9uKG5hbWUsIGZ1bmMpIHtcXG4gICAgQ29kZU1pcnJvci5wcm90b3R5cGVbbmFtZV0gPSBmdW5jO1xcbiAgfTtcXG4gIENvZGVNaXJyb3IuZGVmaW5lRG9jRXh0ZW5zaW9uID0gZnVuY3Rpb24obmFtZSwgZnVuYykge1xcbiAgICBEb2MucHJvdG90eXBlW25hbWVdID0gZnVuYztcXG4gIH07XFxuICBDb2RlTWlycm9yLmRlZmluZU9wdGlvbiA9IG9wdGlvbjtcXG5cXG4gIHZhciBpbml0SG9va3MgPSBbXTtcXG4gIENvZGVNaXJyb3IuZGVmaW5lSW5pdEhvb2sgPSBmdW5jdGlvbihmKSB7aW5pdEhvb2tzLnB1c2goZik7fTtcXG5cXG4gIHZhciBoZWxwZXJzID0gQ29kZU1pcnJvci5oZWxwZXJzID0ge307XFxuICBDb2RlTWlycm9yLnJlZ2lzdGVySGVscGVyID0gZnVuY3Rpb24odHlwZSwgbmFtZSwgdmFsdWUpIHtcXG4gICAgaWYgKCFoZWxwZXJzLmhhc093blByb3BlcnR5KHR5cGUpKSBoZWxwZXJzW3R5cGVdID0gQ29kZU1pcnJvclt0eXBlXSA9IHtfZ2xvYmFsOiBbXX07XFxuICAgIGhlbHBlcnNbdHlwZV1bbmFtZV0gPSB2YWx1ZTtcXG4gIH07XFxuICBDb2RlTWlycm9yLnJlZ2lzdGVyR2xvYmFsSGVscGVyID0gZnVuY3Rpb24odHlwZSwgbmFtZSwgcHJlZGljYXRlLCB2YWx1ZSkge1xcbiAgICBDb2RlTWlycm9yLnJlZ2lzdGVySGVscGVyKHR5cGUsIG5hbWUsIHZhbHVlKTtcXG4gICAgaGVscGVyc1t0eXBlXS5fZ2xvYmFsLnB1c2goe3ByZWQ6IHByZWRpY2F0ZSwgdmFsOiB2YWx1ZX0pO1xcbiAgfTtcXG5cXG4gIC8vIE1PREUgU1RBVEUgSEFORExJTkdcXG5cXG4gIC8vIFV0aWxpdHkgZnVuY3Rpb25zIGZvciB3b3JraW5nIHdpdGggc3RhdGUuIEV4cG9ydGVkIGJlY2F1c2UgbmVzdGVkXFxuICAvLyBtb2RlcyBuZWVkIHRvIGRvIHRoaXMgZm9yIHRoZWlyIGlubmVyIG1vZGVzLlxcblxcbiAgdmFyIGNvcHlTdGF0ZSA9IENvZGVNaXJyb3IuY29weVN0YXRlID0gZnVuY3Rpb24obW9kZSwgc3RhdGUpIHtcXG4gICAgaWYgKHN0YXRlID09PSB0cnVlKSByZXR1cm4gc3RhdGU7XFxuICAgIGlmIChtb2RlLmNvcHlTdGF0ZSkgcmV0dXJuIG1vZGUuY29weVN0YXRlKHN0YXRlKTtcXG4gICAgdmFyIG5zdGF0ZSA9IHt9O1xcbiAgICBmb3IgKHZhciBuIGluIHN0YXRlKSB7XFxuICAgICAgdmFyIHZhbCA9IHN0YXRlW25dO1xcbiAgICAgIGlmICh2YWwgaW5zdGFuY2VvZiBBcnJheSkgdmFsID0gdmFsLmNvbmNhdChbXSk7XFxuICAgICAgbnN0YXRlW25dID0gdmFsO1xcbiAgICB9XFxuICAgIHJldHVybiBuc3RhdGU7XFxuICB9O1xcblxcbiAgdmFyIHN0YXJ0U3RhdGUgPSBDb2RlTWlycm9yLnN0YXJ0U3RhdGUgPSBmdW5jdGlvbihtb2RlLCBhMSwgYTIpIHtcXG4gICAgcmV0dXJuIG1vZGUuc3RhcnRTdGF0ZSA/IG1vZGUuc3RhcnRTdGF0ZShhMSwgYTIpIDogdHJ1ZTtcXG4gIH07XFxuXFxuICAvLyBHaXZlbiBhIG1vZGUgYW5kIGEgc3RhdGUgKGZvciB0aGF0IG1vZGUpLCBmaW5kIHRoZSBpbm5lciBtb2RlIGFuZFxcbiAgLy8gc3RhdGUgYXQgdGhlIHBvc2l0aW9uIHRoYXQgdGhlIHN0YXRlIHJlZmVycyB0by5cXG4gIENvZGVNaXJyb3IuaW5uZXJNb2RlID0gZnVuY3Rpb24obW9kZSwgc3RhdGUpIHtcXG4gICAgd2hpbGUgKG1vZGUuaW5uZXJNb2RlKSB7XFxuICAgICAgdmFyIGluZm8gPSBtb2RlLmlubmVyTW9kZShzdGF0ZSk7XFxuICAgICAgaWYgKCFpbmZvIHx8IGluZm8ubW9kZSA9PSBtb2RlKSBicmVhaztcXG4gICAgICBzdGF0ZSA9IGluZm8uc3RhdGU7XFxuICAgICAgbW9kZSA9IGluZm8ubW9kZTtcXG4gICAgfVxcbiAgICByZXR1cm4gaW5mbyB8fCB7bW9kZTogbW9kZSwgc3RhdGU6IHN0YXRlfTtcXG4gIH07XFxuXFxuICAvLyBTVEFOREFSRCBDT01NQU5EU1xcblxcbiAgLy8gQ29tbWFuZHMgYXJlIHBhcmFtZXRlci1sZXNzIGFjdGlvbnMgdGhhdCBjYW4gYmUgcGVyZm9ybWVkIG9uIGFuXFxuICAvLyBlZGl0b3IsIG1vc3RseSB1c2VkIGZvciBrZXliaW5kaW5ncy5cXG4gIHZhciBjb21tYW5kcyA9IENvZGVNaXJyb3IuY29tbWFuZHMgPSB7XFxuICAgIHNlbGVjdEFsbDogZnVuY3Rpb24oY20pIHtjbS5zZXRTZWxlY3Rpb24oUG9zKGNtLmZpcnN0TGluZSgpLCAwKSwgUG9zKGNtLmxhc3RMaW5lKCkpLCBzZWxfZG9udFNjcm9sbCk7fSxcXG4gICAgc2luZ2xlU2VsZWN0aW9uOiBmdW5jdGlvbihjbSkge1xcbiAgICAgIGNtLnNldFNlbGVjdGlvbihjbS5nZXRDdXJzb3IoXFxcImFuY2hvclxcXCIpLCBjbS5nZXRDdXJzb3IoXFxcImhlYWRcXFwiKSwgc2VsX2RvbnRTY3JvbGwpO1xcbiAgICB9LFxcbiAgICBraWxsTGluZTogZnVuY3Rpb24oY20pIHtcXG4gICAgICBkZWxldGVOZWFyU2VsZWN0aW9uKGNtLCBmdW5jdGlvbihyYW5nZSkge1xcbiAgICAgICAgaWYgKHJhbmdlLmVtcHR5KCkpIHtcXG4gICAgICAgICAgdmFyIGxlbiA9IGdldExpbmUoY20uZG9jLCByYW5nZS5oZWFkLmxpbmUpLnRleHQubGVuZ3RoO1xcbiAgICAgICAgICBpZiAocmFuZ2UuaGVhZC5jaCA9PSBsZW4gJiYgcmFuZ2UuaGVhZC5saW5lIDwgY20ubGFzdExpbmUoKSlcXG4gICAgICAgICAgICByZXR1cm4ge2Zyb206IHJhbmdlLmhlYWQsIHRvOiBQb3MocmFuZ2UuaGVhZC5saW5lICsgMSwgMCl9O1xcbiAgICAgICAgICBlbHNlXFxuICAgICAgICAgICAgcmV0dXJuIHtmcm9tOiByYW5nZS5oZWFkLCB0bzogUG9zKHJhbmdlLmhlYWQubGluZSwgbGVuKX07XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICByZXR1cm4ge2Zyb206IHJhbmdlLmZyb20oKSwgdG86IHJhbmdlLnRvKCl9O1xcbiAgICAgICAgfVxcbiAgICAgIH0pO1xcbiAgICB9LFxcbiAgICBkZWxldGVMaW5lOiBmdW5jdGlvbihjbSkge1xcbiAgICAgIGRlbGV0ZU5lYXJTZWxlY3Rpb24oY20sIGZ1bmN0aW9uKHJhbmdlKSB7XFxuICAgICAgICByZXR1cm4ge2Zyb206IFBvcyhyYW5nZS5mcm9tKCkubGluZSwgMCksXFxuICAgICAgICAgICAgICAgIHRvOiBjbGlwUG9zKGNtLmRvYywgUG9zKHJhbmdlLnRvKCkubGluZSArIDEsIDApKX07XFxuICAgICAgfSk7XFxuICAgIH0sXFxuICAgIGRlbExpbmVMZWZ0OiBmdW5jdGlvbihjbSkge1xcbiAgICAgIGRlbGV0ZU5lYXJTZWxlY3Rpb24oY20sIGZ1bmN0aW9uKHJhbmdlKSB7XFxuICAgICAgICByZXR1cm4ge2Zyb206IFBvcyhyYW5nZS5mcm9tKCkubGluZSwgMCksIHRvOiByYW5nZS5mcm9tKCl9O1xcbiAgICAgIH0pO1xcbiAgICB9LFxcbiAgICBkZWxXcmFwcGVkTGluZUxlZnQ6IGZ1bmN0aW9uKGNtKSB7XFxuICAgICAgZGVsZXRlTmVhclNlbGVjdGlvbihjbSwgZnVuY3Rpb24ocmFuZ2UpIHtcXG4gICAgICAgIHZhciB0b3AgPSBjbS5jaGFyQ29vcmRzKHJhbmdlLmhlYWQsIFxcXCJkaXZcXFwiKS50b3AgKyA1O1xcbiAgICAgICAgdmFyIGxlZnRQb3MgPSBjbS5jb29yZHNDaGFyKHtsZWZ0OiAwLCB0b3A6IHRvcH0sIFxcXCJkaXZcXFwiKTtcXG4gICAgICAgIHJldHVybiB7ZnJvbTogbGVmdFBvcywgdG86IHJhbmdlLmZyb20oKX07XFxuICAgICAgfSk7XFxuICAgIH0sXFxuICAgIGRlbFdyYXBwZWRMaW5lUmlnaHQ6IGZ1bmN0aW9uKGNtKSB7XFxuICAgICAgZGVsZXRlTmVhclNlbGVjdGlvbihjbSwgZnVuY3Rpb24ocmFuZ2UpIHtcXG4gICAgICAgIHZhciB0b3AgPSBjbS5jaGFyQ29vcmRzKHJhbmdlLmhlYWQsIFxcXCJkaXZcXFwiKS50b3AgKyA1O1xcbiAgICAgICAgdmFyIHJpZ2h0UG9zID0gY20uY29vcmRzQ2hhcih7bGVmdDogY20uZGlzcGxheS5saW5lRGl2Lm9mZnNldFdpZHRoICsgMTAwLCB0b3A6IHRvcH0sIFxcXCJkaXZcXFwiKTtcXG4gICAgICAgIHJldHVybiB7ZnJvbTogcmFuZ2UuZnJvbSgpLCB0bzogcmlnaHRQb3MgfTtcXG4gICAgICB9KTtcXG4gICAgfSxcXG4gICAgdW5kbzogZnVuY3Rpb24oY20pIHtjbS51bmRvKCk7fSxcXG4gICAgcmVkbzogZnVuY3Rpb24oY20pIHtjbS5yZWRvKCk7fSxcXG4gICAgdW5kb1NlbGVjdGlvbjogZnVuY3Rpb24oY20pIHtjbS51bmRvU2VsZWN0aW9uKCk7fSxcXG4gICAgcmVkb1NlbGVjdGlvbjogZnVuY3Rpb24oY20pIHtjbS5yZWRvU2VsZWN0aW9uKCk7fSxcXG4gICAgZ29Eb2NTdGFydDogZnVuY3Rpb24oY20pIHtjbS5leHRlbmRTZWxlY3Rpb24oUG9zKGNtLmZpcnN0TGluZSgpLCAwKSk7fSxcXG4gICAgZ29Eb2NFbmQ6IGZ1bmN0aW9uKGNtKSB7Y20uZXh0ZW5kU2VsZWN0aW9uKFBvcyhjbS5sYXN0TGluZSgpKSk7fSxcXG4gICAgZ29MaW5lU3RhcnQ6IGZ1bmN0aW9uKGNtKSB7XFxuICAgICAgY20uZXh0ZW5kU2VsZWN0aW9uc0J5KGZ1bmN0aW9uKHJhbmdlKSB7IHJldHVybiBsaW5lU3RhcnQoY20sIHJhbmdlLmhlYWQubGluZSk7IH0sXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtvcmlnaW46IFxcXCIrbW92ZVxcXCIsIGJpYXM6IDF9KTtcXG4gICAgfSxcXG4gICAgZ29MaW5lU3RhcnRTbWFydDogZnVuY3Rpb24oY20pIHtcXG4gICAgICBjbS5leHRlbmRTZWxlY3Rpb25zQnkoZnVuY3Rpb24ocmFuZ2UpIHtcXG4gICAgICAgIHJldHVybiBsaW5lU3RhcnRTbWFydChjbSwgcmFuZ2UuaGVhZCk7XFxuICAgICAgfSwge29yaWdpbjogXFxcIittb3ZlXFxcIiwgYmlhczogMX0pO1xcbiAgICB9LFxcbiAgICBnb0xpbmVFbmQ6IGZ1bmN0aW9uKGNtKSB7XFxuICAgICAgY20uZXh0ZW5kU2VsZWN0aW9uc0J5KGZ1bmN0aW9uKHJhbmdlKSB7IHJldHVybiBsaW5lRW5kKGNtLCByYW5nZS5oZWFkLmxpbmUpOyB9LFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7b3JpZ2luOiBcXFwiK21vdmVcXFwiLCBiaWFzOiAtMX0pO1xcbiAgICB9LFxcbiAgICBnb0xpbmVSaWdodDogZnVuY3Rpb24oY20pIHtcXG4gICAgICBjbS5leHRlbmRTZWxlY3Rpb25zQnkoZnVuY3Rpb24ocmFuZ2UpIHtcXG4gICAgICAgIHZhciB0b3AgPSBjbS5jaGFyQ29vcmRzKHJhbmdlLmhlYWQsIFxcXCJkaXZcXFwiKS50b3AgKyA1O1xcbiAgICAgICAgcmV0dXJuIGNtLmNvb3Jkc0NoYXIoe2xlZnQ6IGNtLmRpc3BsYXkubGluZURpdi5vZmZzZXRXaWR0aCArIDEwMCwgdG9wOiB0b3B9LCBcXFwiZGl2XFxcIik7XFxuICAgICAgfSwgc2VsX21vdmUpO1xcbiAgICB9LFxcbiAgICBnb0xpbmVMZWZ0OiBmdW5jdGlvbihjbSkge1xcbiAgICAgIGNtLmV4dGVuZFNlbGVjdGlvbnNCeShmdW5jdGlvbihyYW5nZSkge1xcbiAgICAgICAgdmFyIHRvcCA9IGNtLmNoYXJDb29yZHMocmFuZ2UuaGVhZCwgXFxcImRpdlxcXCIpLnRvcCArIDU7XFxuICAgICAgICByZXR1cm4gY20uY29vcmRzQ2hhcih7bGVmdDogMCwgdG9wOiB0b3B9LCBcXFwiZGl2XFxcIik7XFxuICAgICAgfSwgc2VsX21vdmUpO1xcbiAgICB9LFxcbiAgICBnb0xpbmVMZWZ0U21hcnQ6IGZ1bmN0aW9uKGNtKSB7XFxuICAgICAgY20uZXh0ZW5kU2VsZWN0aW9uc0J5KGZ1bmN0aW9uKHJhbmdlKSB7XFxuICAgICAgICB2YXIgdG9wID0gY20uY2hhckNvb3JkcyhyYW5nZS5oZWFkLCBcXFwiZGl2XFxcIikudG9wICsgNTtcXG4gICAgICAgIHZhciBwb3MgPSBjbS5jb29yZHNDaGFyKHtsZWZ0OiAwLCB0b3A6IHRvcH0sIFxcXCJkaXZcXFwiKTtcXG4gICAgICAgIGlmIChwb3MuY2ggPCBjbS5nZXRMaW5lKHBvcy5saW5lKS5zZWFyY2goL1xcXFxTLykpIHJldHVybiBsaW5lU3RhcnRTbWFydChjbSwgcmFuZ2UuaGVhZCk7XFxuICAgICAgICByZXR1cm4gcG9zO1xcbiAgICAgIH0sIHNlbF9tb3ZlKTtcXG4gICAgfSxcXG4gICAgZ29MaW5lVXA6IGZ1bmN0aW9uKGNtKSB7Y20ubW92ZVYoLTEsIFxcXCJsaW5lXFxcIik7fSxcXG4gICAgZ29MaW5lRG93bjogZnVuY3Rpb24oY20pIHtjbS5tb3ZlVigxLCBcXFwibGluZVxcXCIpO30sXFxuICAgIGdvUGFnZVVwOiBmdW5jdGlvbihjbSkge2NtLm1vdmVWKC0xLCBcXFwicGFnZVxcXCIpO30sXFxuICAgIGdvUGFnZURvd246IGZ1bmN0aW9uKGNtKSB7Y20ubW92ZVYoMSwgXFxcInBhZ2VcXFwiKTt9LFxcbiAgICBnb0NoYXJMZWZ0OiBmdW5jdGlvbihjbSkge2NtLm1vdmVIKC0xLCBcXFwiY2hhclxcXCIpO30sXFxuICAgIGdvQ2hhclJpZ2h0OiBmdW5jdGlvbihjbSkge2NtLm1vdmVIKDEsIFxcXCJjaGFyXFxcIik7fSxcXG4gICAgZ29Db2x1bW5MZWZ0OiBmdW5jdGlvbihjbSkge2NtLm1vdmVIKC0xLCBcXFwiY29sdW1uXFxcIik7fSxcXG4gICAgZ29Db2x1bW5SaWdodDogZnVuY3Rpb24oY20pIHtjbS5tb3ZlSCgxLCBcXFwiY29sdW1uXFxcIik7fSxcXG4gICAgZ29Xb3JkTGVmdDogZnVuY3Rpb24oY20pIHtjbS5tb3ZlSCgtMSwgXFxcIndvcmRcXFwiKTt9LFxcbiAgICBnb0dyb3VwUmlnaHQ6IGZ1bmN0aW9uKGNtKSB7Y20ubW92ZUgoMSwgXFxcImdyb3VwXFxcIik7fSxcXG4gICAgZ29Hcm91cExlZnQ6IGZ1bmN0aW9uKGNtKSB7Y20ubW92ZUgoLTEsIFxcXCJncm91cFxcXCIpO30sXFxuICAgIGdvV29yZFJpZ2h0OiBmdW5jdGlvbihjbSkge2NtLm1vdmVIKDEsIFxcXCJ3b3JkXFxcIik7fSxcXG4gICAgZGVsQ2hhckJlZm9yZTogZnVuY3Rpb24oY20pIHtjbS5kZWxldGVIKC0xLCBcXFwiY2hhclxcXCIpO30sXFxuICAgIGRlbENoYXJBZnRlcjogZnVuY3Rpb24oY20pIHtjbS5kZWxldGVIKDEsIFxcXCJjaGFyXFxcIik7fSxcXG4gICAgZGVsV29yZEJlZm9yZTogZnVuY3Rpb24oY20pIHtjbS5kZWxldGVIKC0xLCBcXFwid29yZFxcXCIpO30sXFxuICAgIGRlbFdvcmRBZnRlcjogZnVuY3Rpb24oY20pIHtjbS5kZWxldGVIKDEsIFxcXCJ3b3JkXFxcIik7fSxcXG4gICAgZGVsR3JvdXBCZWZvcmU6IGZ1bmN0aW9uKGNtKSB7Y20uZGVsZXRlSCgtMSwgXFxcImdyb3VwXFxcIik7fSxcXG4gICAgZGVsR3JvdXBBZnRlcjogZnVuY3Rpb24oY20pIHtjbS5kZWxldGVIKDEsIFxcXCJncm91cFxcXCIpO30sXFxuICAgIGluZGVudEF1dG86IGZ1bmN0aW9uKGNtKSB7Y20uaW5kZW50U2VsZWN0aW9uKFxcXCJzbWFydFxcXCIpO30sXFxuICAgIGluZGVudE1vcmU6IGZ1bmN0aW9uKGNtKSB7Y20uaW5kZW50U2VsZWN0aW9uKFxcXCJhZGRcXFwiKTt9LFxcbiAgICBpbmRlbnRMZXNzOiBmdW5jdGlvbihjbSkge2NtLmluZGVudFNlbGVjdGlvbihcXFwic3VidHJhY3RcXFwiKTt9LFxcbiAgICBpbnNlcnRUYWI6IGZ1bmN0aW9uKGNtKSB7Y20ucmVwbGFjZVNlbGVjdGlvbihcXFwiXFxcXHRcXFwiKTt9LFxcbiAgICBpbnNlcnRTb2Z0VGFiOiBmdW5jdGlvbihjbSkge1xcbiAgICAgIHZhciBzcGFjZXMgPSBbXSwgcmFuZ2VzID0gY20ubGlzdFNlbGVjdGlvbnMoKSwgdGFiU2l6ZSA9IGNtLm9wdGlvbnMudGFiU2l6ZTtcXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJhbmdlcy5sZW5ndGg7IGkrKykge1xcbiAgICAgICAgdmFyIHBvcyA9IHJhbmdlc1tpXS5mcm9tKCk7XFxuICAgICAgICB2YXIgY29sID0gY291bnRDb2x1bW4oY20uZ2V0TGluZShwb3MubGluZSksIHBvcy5jaCwgdGFiU2l6ZSk7XFxuICAgICAgICBzcGFjZXMucHVzaChzcGFjZVN0cih0YWJTaXplIC0gY29sICUgdGFiU2l6ZSkpO1xcbiAgICAgIH1cXG4gICAgICBjbS5yZXBsYWNlU2VsZWN0aW9ucyhzcGFjZXMpO1xcbiAgICB9LFxcbiAgICBkZWZhdWx0VGFiOiBmdW5jdGlvbihjbSkge1xcbiAgICAgIGlmIChjbS5zb21ldGhpbmdTZWxlY3RlZCgpKSBjbS5pbmRlbnRTZWxlY3Rpb24oXFxcImFkZFxcXCIpO1xcbiAgICAgIGVsc2UgY20uZXhlY0NvbW1hbmQoXFxcImluc2VydFRhYlxcXCIpO1xcbiAgICB9LFxcbiAgICB0cmFuc3Bvc2VDaGFyczogZnVuY3Rpb24oY20pIHtcXG4gICAgICBydW5Jbk9wKGNtLCBmdW5jdGlvbigpIHtcXG4gICAgICAgIHZhciByYW5nZXMgPSBjbS5saXN0U2VsZWN0aW9ucygpLCBuZXdTZWwgPSBbXTtcXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmFuZ2VzLmxlbmd0aDsgaSsrKSB7XFxuICAgICAgICAgIHZhciBjdXIgPSByYW5nZXNbaV0uaGVhZCwgbGluZSA9IGdldExpbmUoY20uZG9jLCBjdXIubGluZSkudGV4dDtcXG4gICAgICAgICAgaWYgKGxpbmUpIHtcXG4gICAgICAgICAgICBpZiAoY3VyLmNoID09IGxpbmUubGVuZ3RoKSBjdXIgPSBuZXcgUG9zKGN1ci5saW5lLCBjdXIuY2ggLSAxKTtcXG4gICAgICAgICAgICBpZiAoY3VyLmNoID4gMCkge1xcbiAgICAgICAgICAgICAgY3VyID0gbmV3IFBvcyhjdXIubGluZSwgY3VyLmNoICsgMSk7XFxuICAgICAgICAgICAgICBjbS5yZXBsYWNlUmFuZ2UobGluZS5jaGFyQXQoY3VyLmNoIC0gMSkgKyBsaW5lLmNoYXJBdChjdXIuY2ggLSAyKSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBQb3MoY3VyLmxpbmUsIGN1ci5jaCAtIDIpLCBjdXIsIFxcXCIrdHJhbnNwb3NlXFxcIik7XFxuICAgICAgICAgICAgfSBlbHNlIGlmIChjdXIubGluZSA+IGNtLmRvYy5maXJzdCkge1xcbiAgICAgICAgICAgICAgdmFyIHByZXYgPSBnZXRMaW5lKGNtLmRvYywgY3VyLmxpbmUgLSAxKS50ZXh0O1xcbiAgICAgICAgICAgICAgaWYgKHByZXYpXFxuICAgICAgICAgICAgICAgIGNtLnJlcGxhY2VSYW5nZShsaW5lLmNoYXJBdCgwKSArIGNtLmRvYy5saW5lU2VwYXJhdG9yKCkgK1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJldi5jaGFyQXQocHJldi5sZW5ndGggLSAxKSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFBvcyhjdXIubGluZSAtIDEsIHByZXYubGVuZ3RoIC0gMSksIFBvcyhjdXIubGluZSwgMSksIFxcXCIrdHJhbnNwb3NlXFxcIik7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICAgIG5ld1NlbC5wdXNoKG5ldyBSYW5nZShjdXIsIGN1cikpO1xcbiAgICAgICAgfVxcbiAgICAgICAgY20uc2V0U2VsZWN0aW9ucyhuZXdTZWwpO1xcbiAgICAgIH0pO1xcbiAgICB9LFxcbiAgICBuZXdsaW5lQW5kSW5kZW50OiBmdW5jdGlvbihjbSkge1xcbiAgICAgIHJ1bkluT3AoY20sIGZ1bmN0aW9uKCkge1xcbiAgICAgICAgdmFyIGxlbiA9IGNtLmxpc3RTZWxlY3Rpb25zKCkubGVuZ3RoO1xcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xcbiAgICAgICAgICB2YXIgcmFuZ2UgPSBjbS5saXN0U2VsZWN0aW9ucygpW2ldO1xcbiAgICAgICAgICBjbS5yZXBsYWNlUmFuZ2UoY20uZG9jLmxpbmVTZXBhcmF0b3IoKSwgcmFuZ2UuYW5jaG9yLCByYW5nZS5oZWFkLCBcXFwiK2lucHV0XFxcIik7XFxuICAgICAgICAgIGNtLmluZGVudExpbmUocmFuZ2UuZnJvbSgpLmxpbmUgKyAxLCBudWxsLCB0cnVlKTtcXG4gICAgICAgIH1cXG4gICAgICAgIGVuc3VyZUN1cnNvclZpc2libGUoY20pO1xcbiAgICAgIH0pO1xcbiAgICB9LFxcbiAgICBvcGVuTGluZTogZnVuY3Rpb24oY20pIHtjbS5yZXBsYWNlU2VsZWN0aW9uKFxcXCJcXFxcblxcXCIsIFxcXCJzdGFydFxcXCIpfSxcXG4gICAgdG9nZ2xlT3ZlcndyaXRlOiBmdW5jdGlvbihjbSkge2NtLnRvZ2dsZU92ZXJ3cml0ZSgpO31cXG4gIH07XFxuXFxuXFxuICAvLyBTVEFOREFSRCBLRVlNQVBTXFxuXFxuICB2YXIga2V5TWFwID0gQ29kZU1pcnJvci5rZXlNYXAgPSB7fTtcXG5cXG4gIGtleU1hcC5iYXNpYyA9IHtcXG4gICAgXFxcIkxlZnRcXFwiOiBcXFwiZ29DaGFyTGVmdFxcXCIsIFxcXCJSaWdodFxcXCI6IFxcXCJnb0NoYXJSaWdodFxcXCIsIFxcXCJVcFxcXCI6IFxcXCJnb0xpbmVVcFxcXCIsIFxcXCJEb3duXFxcIjogXFxcImdvTGluZURvd25cXFwiLFxcbiAgICBcXFwiRW5kXFxcIjogXFxcImdvTGluZUVuZFxcXCIsIFxcXCJIb21lXFxcIjogXFxcImdvTGluZVN0YXJ0U21hcnRcXFwiLCBcXFwiUGFnZVVwXFxcIjogXFxcImdvUGFnZVVwXFxcIiwgXFxcIlBhZ2VEb3duXFxcIjogXFxcImdvUGFnZURvd25cXFwiLFxcbiAgICBcXFwiRGVsZXRlXFxcIjogXFxcImRlbENoYXJBZnRlclxcXCIsIFxcXCJCYWNrc3BhY2VcXFwiOiBcXFwiZGVsQ2hhckJlZm9yZVxcXCIsIFxcXCJTaGlmdC1CYWNrc3BhY2VcXFwiOiBcXFwiZGVsQ2hhckJlZm9yZVxcXCIsXFxuICAgIFxcXCJUYWJcXFwiOiBcXFwiZGVmYXVsdFRhYlxcXCIsIFxcXCJTaGlmdC1UYWJcXFwiOiBcXFwiaW5kZW50QXV0b1xcXCIsXFxuICAgIFxcXCJFbnRlclxcXCI6IFxcXCJuZXdsaW5lQW5kSW5kZW50XFxcIiwgXFxcIkluc2VydFxcXCI6IFxcXCJ0b2dnbGVPdmVyd3JpdGVcXFwiLFxcbiAgICBcXFwiRXNjXFxcIjogXFxcInNpbmdsZVNlbGVjdGlvblxcXCJcXG4gIH07XFxuICAvLyBOb3RlIHRoYXQgdGhlIHNhdmUgYW5kIGZpbmQtcmVsYXRlZCBjb21tYW5kcyBhcmVuJ3QgZGVmaW5lZCBieVxcbiAgLy8gZGVmYXVsdC4gVXNlciBjb2RlIG9yIGFkZG9ucyBjYW4gZGVmaW5lIHRoZW0uIFVua25vd24gY29tbWFuZHNcXG4gIC8vIGFyZSBzaW1wbHkgaWdub3JlZC5cXG4gIGtleU1hcC5wY0RlZmF1bHQgPSB7XFxuICAgIFxcXCJDdHJsLUFcXFwiOiBcXFwic2VsZWN0QWxsXFxcIiwgXFxcIkN0cmwtRFxcXCI6IFxcXCJkZWxldGVMaW5lXFxcIiwgXFxcIkN0cmwtWlxcXCI6IFxcXCJ1bmRvXFxcIiwgXFxcIlNoaWZ0LUN0cmwtWlxcXCI6IFxcXCJyZWRvXFxcIiwgXFxcIkN0cmwtWVxcXCI6IFxcXCJyZWRvXFxcIixcXG4gICAgXFxcIkN0cmwtSG9tZVxcXCI6IFxcXCJnb0RvY1N0YXJ0XFxcIiwgXFxcIkN0cmwtRW5kXFxcIjogXFxcImdvRG9jRW5kXFxcIiwgXFxcIkN0cmwtVXBcXFwiOiBcXFwiZ29MaW5lVXBcXFwiLCBcXFwiQ3RybC1Eb3duXFxcIjogXFxcImdvTGluZURvd25cXFwiLFxcbiAgICBcXFwiQ3RybC1MZWZ0XFxcIjogXFxcImdvR3JvdXBMZWZ0XFxcIiwgXFxcIkN0cmwtUmlnaHRcXFwiOiBcXFwiZ29Hcm91cFJpZ2h0XFxcIiwgXFxcIkFsdC1MZWZ0XFxcIjogXFxcImdvTGluZVN0YXJ0XFxcIiwgXFxcIkFsdC1SaWdodFxcXCI6IFxcXCJnb0xpbmVFbmRcXFwiLFxcbiAgICBcXFwiQ3RybC1CYWNrc3BhY2VcXFwiOiBcXFwiZGVsR3JvdXBCZWZvcmVcXFwiLCBcXFwiQ3RybC1EZWxldGVcXFwiOiBcXFwiZGVsR3JvdXBBZnRlclxcXCIsIFxcXCJDdHJsLVNcXFwiOiBcXFwic2F2ZVxcXCIsIFxcXCJDdHJsLUZcXFwiOiBcXFwiZmluZFxcXCIsXFxuICAgIFxcXCJDdHJsLUdcXFwiOiBcXFwiZmluZE5leHRcXFwiLCBcXFwiU2hpZnQtQ3RybC1HXFxcIjogXFxcImZpbmRQcmV2XFxcIiwgXFxcIlNoaWZ0LUN0cmwtRlxcXCI6IFxcXCJyZXBsYWNlXFxcIiwgXFxcIlNoaWZ0LUN0cmwtUlxcXCI6IFxcXCJyZXBsYWNlQWxsXFxcIixcXG4gICAgXFxcIkN0cmwtW1xcXCI6IFxcXCJpbmRlbnRMZXNzXFxcIiwgXFxcIkN0cmwtXVxcXCI6IFxcXCJpbmRlbnRNb3JlXFxcIixcXG4gICAgXFxcIkN0cmwtVVxcXCI6IFxcXCJ1bmRvU2VsZWN0aW9uXFxcIiwgXFxcIlNoaWZ0LUN0cmwtVVxcXCI6IFxcXCJyZWRvU2VsZWN0aW9uXFxcIiwgXFxcIkFsdC1VXFxcIjogXFxcInJlZG9TZWxlY3Rpb25cXFwiLFxcbiAgICBmYWxsdGhyb3VnaDogXFxcImJhc2ljXFxcIlxcbiAgfTtcXG4gIC8vIFZlcnkgYmFzaWMgcmVhZGxpbmUvZW1hY3Mtc3R5bGUgYmluZGluZ3MsIHdoaWNoIGFyZSBzdGFuZGFyZCBvbiBNYWMuXFxuICBrZXlNYXAuZW1hY3N5ID0ge1xcbiAgICBcXFwiQ3RybC1GXFxcIjogXFxcImdvQ2hhclJpZ2h0XFxcIiwgXFxcIkN0cmwtQlxcXCI6IFxcXCJnb0NoYXJMZWZ0XFxcIiwgXFxcIkN0cmwtUFxcXCI6IFxcXCJnb0xpbmVVcFxcXCIsIFxcXCJDdHJsLU5cXFwiOiBcXFwiZ29MaW5lRG93blxcXCIsXFxuICAgIFxcXCJBbHQtRlxcXCI6IFxcXCJnb1dvcmRSaWdodFxcXCIsIFxcXCJBbHQtQlxcXCI6IFxcXCJnb1dvcmRMZWZ0XFxcIiwgXFxcIkN0cmwtQVxcXCI6IFxcXCJnb0xpbmVTdGFydFxcXCIsIFxcXCJDdHJsLUVcXFwiOiBcXFwiZ29MaW5lRW5kXFxcIixcXG4gICAgXFxcIkN0cmwtVlxcXCI6IFxcXCJnb1BhZ2VEb3duXFxcIiwgXFxcIlNoaWZ0LUN0cmwtVlxcXCI6IFxcXCJnb1BhZ2VVcFxcXCIsIFxcXCJDdHJsLURcXFwiOiBcXFwiZGVsQ2hhckFmdGVyXFxcIiwgXFxcIkN0cmwtSFxcXCI6IFxcXCJkZWxDaGFyQmVmb3JlXFxcIixcXG4gICAgXFxcIkFsdC1EXFxcIjogXFxcImRlbFdvcmRBZnRlclxcXCIsIFxcXCJBbHQtQmFja3NwYWNlXFxcIjogXFxcImRlbFdvcmRCZWZvcmVcXFwiLCBcXFwiQ3RybC1LXFxcIjogXFxcImtpbGxMaW5lXFxcIiwgXFxcIkN0cmwtVFxcXCI6IFxcXCJ0cmFuc3Bvc2VDaGFyc1xcXCIsXFxuICAgIFxcXCJDdHJsLU9cXFwiOiBcXFwib3BlbkxpbmVcXFwiXFxuICB9O1xcbiAga2V5TWFwLm1hY0RlZmF1bHQgPSB7XFxuICAgIFxcXCJDbWQtQVxcXCI6IFxcXCJzZWxlY3RBbGxcXFwiLCBcXFwiQ21kLURcXFwiOiBcXFwiZGVsZXRlTGluZVxcXCIsIFxcXCJDbWQtWlxcXCI6IFxcXCJ1bmRvXFxcIiwgXFxcIlNoaWZ0LUNtZC1aXFxcIjogXFxcInJlZG9cXFwiLCBcXFwiQ21kLVlcXFwiOiBcXFwicmVkb1xcXCIsXFxuICAgIFxcXCJDbWQtSG9tZVxcXCI6IFxcXCJnb0RvY1N0YXJ0XFxcIiwgXFxcIkNtZC1VcFxcXCI6IFxcXCJnb0RvY1N0YXJ0XFxcIiwgXFxcIkNtZC1FbmRcXFwiOiBcXFwiZ29Eb2NFbmRcXFwiLCBcXFwiQ21kLURvd25cXFwiOiBcXFwiZ29Eb2NFbmRcXFwiLCBcXFwiQWx0LUxlZnRcXFwiOiBcXFwiZ29Hcm91cExlZnRcXFwiLFxcbiAgICBcXFwiQWx0LVJpZ2h0XFxcIjogXFxcImdvR3JvdXBSaWdodFxcXCIsIFxcXCJDbWQtTGVmdFxcXCI6IFxcXCJnb0xpbmVMZWZ0XFxcIiwgXFxcIkNtZC1SaWdodFxcXCI6IFxcXCJnb0xpbmVSaWdodFxcXCIsIFxcXCJBbHQtQmFja3NwYWNlXFxcIjogXFxcImRlbEdyb3VwQmVmb3JlXFxcIixcXG4gICAgXFxcIkN0cmwtQWx0LUJhY2tzcGFjZVxcXCI6IFxcXCJkZWxHcm91cEFmdGVyXFxcIiwgXFxcIkFsdC1EZWxldGVcXFwiOiBcXFwiZGVsR3JvdXBBZnRlclxcXCIsIFxcXCJDbWQtU1xcXCI6IFxcXCJzYXZlXFxcIiwgXFxcIkNtZC1GXFxcIjogXFxcImZpbmRcXFwiLFxcbiAgICBcXFwiQ21kLUdcXFwiOiBcXFwiZmluZE5leHRcXFwiLCBcXFwiU2hpZnQtQ21kLUdcXFwiOiBcXFwiZmluZFByZXZcXFwiLCBcXFwiQ21kLUFsdC1GXFxcIjogXFxcInJlcGxhY2VcXFwiLCBcXFwiU2hpZnQtQ21kLUFsdC1GXFxcIjogXFxcInJlcGxhY2VBbGxcXFwiLFxcbiAgICBcXFwiQ21kLVtcXFwiOiBcXFwiaW5kZW50TGVzc1xcXCIsIFxcXCJDbWQtXVxcXCI6IFxcXCJpbmRlbnRNb3JlXFxcIiwgXFxcIkNtZC1CYWNrc3BhY2VcXFwiOiBcXFwiZGVsV3JhcHBlZExpbmVMZWZ0XFxcIiwgXFxcIkNtZC1EZWxldGVcXFwiOiBcXFwiZGVsV3JhcHBlZExpbmVSaWdodFxcXCIsXFxuICAgIFxcXCJDbWQtVVxcXCI6IFxcXCJ1bmRvU2VsZWN0aW9uXFxcIiwgXFxcIlNoaWZ0LUNtZC1VXFxcIjogXFxcInJlZG9TZWxlY3Rpb25cXFwiLCBcXFwiQ3RybC1VcFxcXCI6IFxcXCJnb0RvY1N0YXJ0XFxcIiwgXFxcIkN0cmwtRG93blxcXCI6IFxcXCJnb0RvY0VuZFxcXCIsXFxuICAgIGZhbGx0aHJvdWdoOiBbXFxcImJhc2ljXFxcIiwgXFxcImVtYWNzeVxcXCJdXFxuICB9O1xcbiAga2V5TWFwW1xcXCJkZWZhdWx0XFxcIl0gPSBtYWMgPyBrZXlNYXAubWFjRGVmYXVsdCA6IGtleU1hcC5wY0RlZmF1bHQ7XFxuXFxuICAvLyBLRVlNQVAgRElTUEFUQ0hcXG5cXG4gIGZ1bmN0aW9uIG5vcm1hbGl6ZUtleU5hbWUobmFtZSkge1xcbiAgICB2YXIgcGFydHMgPSBuYW1lLnNwbGl0KC8tKD8hJCkvKSwgbmFtZSA9IHBhcnRzW3BhcnRzLmxlbmd0aCAtIDFdO1xcbiAgICB2YXIgYWx0LCBjdHJsLCBzaGlmdCwgY21kO1xcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcnRzLmxlbmd0aCAtIDE7IGkrKykge1xcbiAgICAgIHZhciBtb2QgPSBwYXJ0c1tpXTtcXG4gICAgICBpZiAoL14oY21kfG1ldGF8bSkkL2kudGVzdChtb2QpKSBjbWQgPSB0cnVlO1xcbiAgICAgIGVsc2UgaWYgKC9eYShsdCk/JC9pLnRlc3QobW9kKSkgYWx0ID0gdHJ1ZTtcXG4gICAgICBlbHNlIGlmICgvXihjfGN0cmx8Y29udHJvbCkkL2kudGVzdChtb2QpKSBjdHJsID0gdHJ1ZTtcXG4gICAgICBlbHNlIGlmICgvXnMoaGlmdCkkL2kudGVzdChtb2QpKSBzaGlmdCA9IHRydWU7XFxuICAgICAgZWxzZSB0aHJvdyBuZXcgRXJyb3IoXFxcIlVucmVjb2duaXplZCBtb2RpZmllciBuYW1lOiBcXFwiICsgbW9kKTtcXG4gICAgfVxcbiAgICBpZiAoYWx0KSBuYW1lID0gXFxcIkFsdC1cXFwiICsgbmFtZTtcXG4gICAgaWYgKGN0cmwpIG5hbWUgPSBcXFwiQ3RybC1cXFwiICsgbmFtZTtcXG4gICAgaWYgKGNtZCkgbmFtZSA9IFxcXCJDbWQtXFxcIiArIG5hbWU7XFxuICAgIGlmIChzaGlmdCkgbmFtZSA9IFxcXCJTaGlmdC1cXFwiICsgbmFtZTtcXG4gICAgcmV0dXJuIG5hbWU7XFxuICB9XFxuXFxuICAvLyBUaGlzIGlzIGEga2x1ZGdlIHRvIGtlZXAga2V5bWFwcyBtb3N0bHkgd29ya2luZyBhcyByYXcgb2JqZWN0c1xcbiAgLy8gKGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5KSB3aGlsZSBhdCB0aGUgc2FtZSB0aW1lIHN1cHBvcnQgZmVhdHVyZXNcXG4gIC8vIGxpa2Ugbm9ybWFsaXphdGlvbiBhbmQgbXVsdGktc3Ryb2tlIGtleSBiaW5kaW5ncy4gSXQgY29tcGlsZXMgYVxcbiAgLy8gbmV3IG5vcm1hbGl6ZWQga2V5bWFwLCBhbmQgdGhlbiB1cGRhdGVzIHRoZSBvbGQgb2JqZWN0IHRvIHJlZmxlY3RcXG4gIC8vIHRoaXMuXFxuICBDb2RlTWlycm9yLm5vcm1hbGl6ZUtleU1hcCA9IGZ1bmN0aW9uKGtleW1hcCkge1xcbiAgICB2YXIgY29weSA9IHt9O1xcbiAgICBmb3IgKHZhciBrZXluYW1lIGluIGtleW1hcCkgaWYgKGtleW1hcC5oYXNPd25Qcm9wZXJ0eShrZXluYW1lKSkge1xcbiAgICAgIHZhciB2YWx1ZSA9IGtleW1hcFtrZXluYW1lXTtcXG4gICAgICBpZiAoL14obmFtZXxmYWxsdGhyb3VnaHwoZGV8YXQpdGFjaCkkLy50ZXN0KGtleW5hbWUpKSBjb250aW51ZTtcXG4gICAgICBpZiAodmFsdWUgPT0gXFxcIi4uLlxcXCIpIHsgZGVsZXRlIGtleW1hcFtrZXluYW1lXTsgY29udGludWU7IH1cXG5cXG4gICAgICB2YXIga2V5cyA9IG1hcChrZXluYW1lLnNwbGl0KFxcXCIgXFxcIiksIG5vcm1hbGl6ZUtleU5hbWUpO1xcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xcbiAgICAgICAgdmFyIHZhbCwgbmFtZTtcXG4gICAgICAgIGlmIChpID09IGtleXMubGVuZ3RoIC0gMSkge1xcbiAgICAgICAgICBuYW1lID0ga2V5cy5qb2luKFxcXCIgXFxcIik7XFxuICAgICAgICAgIHZhbCA9IHZhbHVlO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgbmFtZSA9IGtleXMuc2xpY2UoMCwgaSArIDEpLmpvaW4oXFxcIiBcXFwiKTtcXG4gICAgICAgICAgdmFsID0gXFxcIi4uLlxcXCI7XFxuICAgICAgICB9XFxuICAgICAgICB2YXIgcHJldiA9IGNvcHlbbmFtZV07XFxuICAgICAgICBpZiAoIXByZXYpIGNvcHlbbmFtZV0gPSB2YWw7XFxuICAgICAgICBlbHNlIGlmIChwcmV2ICE9IHZhbCkgdGhyb3cgbmV3IEVycm9yKFxcXCJJbmNvbnNpc3RlbnQgYmluZGluZ3MgZm9yIFxcXCIgKyBuYW1lKTtcXG4gICAgICB9XFxuICAgICAgZGVsZXRlIGtleW1hcFtrZXluYW1lXTtcXG4gICAgfVxcbiAgICBmb3IgKHZhciBwcm9wIGluIGNvcHkpIGtleW1hcFtwcm9wXSA9IGNvcHlbcHJvcF07XFxuICAgIHJldHVybiBrZXltYXA7XFxuICB9O1xcblxcbiAgdmFyIGxvb2t1cEtleSA9IENvZGVNaXJyb3IubG9va3VwS2V5ID0gZnVuY3Rpb24oa2V5LCBtYXAsIGhhbmRsZSwgY29udGV4dCkge1xcbiAgICBtYXAgPSBnZXRLZXlNYXAobWFwKTtcXG4gICAgdmFyIGZvdW5kID0gbWFwLmNhbGwgPyBtYXAuY2FsbChrZXksIGNvbnRleHQpIDogbWFwW2tleV07XFxuICAgIGlmIChmb3VuZCA9PT0gZmFsc2UpIHJldHVybiBcXFwibm90aGluZ1xcXCI7XFxuICAgIGlmIChmb3VuZCA9PT0gXFxcIi4uLlxcXCIpIHJldHVybiBcXFwibXVsdGlcXFwiO1xcbiAgICBpZiAoZm91bmQgIT0gbnVsbCAmJiBoYW5kbGUoZm91bmQpKSByZXR1cm4gXFxcImhhbmRsZWRcXFwiO1xcblxcbiAgICBpZiAobWFwLmZhbGx0aHJvdWdoKSB7XFxuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChtYXAuZmFsbHRocm91Z2gpICE9IFxcXCJbb2JqZWN0IEFycmF5XVxcXCIpXFxuICAgICAgICByZXR1cm4gbG9va3VwS2V5KGtleSwgbWFwLmZhbGx0aHJvdWdoLCBoYW5kbGUsIGNvbnRleHQpO1xcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWFwLmZhbGx0aHJvdWdoLmxlbmd0aDsgaSsrKSB7XFxuICAgICAgICB2YXIgcmVzdWx0ID0gbG9va3VwS2V5KGtleSwgbWFwLmZhbGx0aHJvdWdoW2ldLCBoYW5kbGUsIGNvbnRleHQpO1xcbiAgICAgICAgaWYgKHJlc3VsdCkgcmV0dXJuIHJlc3VsdDtcXG4gICAgICB9XFxuICAgIH1cXG4gIH07XFxuXFxuICAvLyBNb2RpZmllciBrZXkgcHJlc3NlcyBkb24ndCBjb3VudCBhcyAncmVhbCcga2V5IHByZXNzZXMgZm9yIHRoZVxcbiAgLy8gcHVycG9zZSBvZiBrZXltYXAgZmFsbHRocm91Z2guXFxuICB2YXIgaXNNb2RpZmllcktleSA9IENvZGVNaXJyb3IuaXNNb2RpZmllcktleSA9IGZ1bmN0aW9uKHZhbHVlKSB7XFxuICAgIHZhciBuYW1lID0gdHlwZW9mIHZhbHVlID09IFxcXCJzdHJpbmdcXFwiID8gdmFsdWUgOiBrZXlOYW1lc1t2YWx1ZS5rZXlDb2RlXTtcXG4gICAgcmV0dXJuIG5hbWUgPT0gXFxcIkN0cmxcXFwiIHx8IG5hbWUgPT0gXFxcIkFsdFxcXCIgfHwgbmFtZSA9PSBcXFwiU2hpZnRcXFwiIHx8IG5hbWUgPT0gXFxcIk1vZFxcXCI7XFxuICB9O1xcblxcbiAgLy8gTG9vayB1cCB0aGUgbmFtZSBvZiBhIGtleSBhcyBpbmRpY2F0ZWQgYnkgYW4gZXZlbnQgb2JqZWN0LlxcbiAgdmFyIGtleU5hbWUgPSBDb2RlTWlycm9yLmtleU5hbWUgPSBmdW5jdGlvbihldmVudCwgbm9TaGlmdCkge1xcbiAgICBpZiAocHJlc3RvICYmIGV2ZW50LmtleUNvZGUgPT0gMzQgJiYgZXZlbnRbXFxcImNoYXJcXFwiXSkgcmV0dXJuIGZhbHNlO1xcbiAgICB2YXIgYmFzZSA9IGtleU5hbWVzW2V2ZW50LmtleUNvZGVdLCBuYW1lID0gYmFzZTtcXG4gICAgaWYgKG5hbWUgPT0gbnVsbCB8fCBldmVudC5hbHRHcmFwaEtleSkgcmV0dXJuIGZhbHNlO1xcbiAgICBpZiAoZXZlbnQuYWx0S2V5ICYmIGJhc2UgIT0gXFxcIkFsdFxcXCIpIG5hbWUgPSBcXFwiQWx0LVxcXCIgKyBuYW1lO1xcbiAgICBpZiAoKGZsaXBDdHJsQ21kID8gZXZlbnQubWV0YUtleSA6IGV2ZW50LmN0cmxLZXkpICYmIGJhc2UgIT0gXFxcIkN0cmxcXFwiKSBuYW1lID0gXFxcIkN0cmwtXFxcIiArIG5hbWU7XFxuICAgIGlmICgoZmxpcEN0cmxDbWQgPyBldmVudC5jdHJsS2V5IDogZXZlbnQubWV0YUtleSkgJiYgYmFzZSAhPSBcXFwiQ21kXFxcIikgbmFtZSA9IFxcXCJDbWQtXFxcIiArIG5hbWU7XFxuICAgIGlmICghbm9TaGlmdCAmJiBldmVudC5zaGlmdEtleSAmJiBiYXNlICE9IFxcXCJTaGlmdFxcXCIpIG5hbWUgPSBcXFwiU2hpZnQtXFxcIiArIG5hbWU7XFxuICAgIHJldHVybiBuYW1lO1xcbiAgfTtcXG5cXG4gIGZ1bmN0aW9uIGdldEtleU1hcCh2YWwpIHtcXG4gICAgcmV0dXJuIHR5cGVvZiB2YWwgPT0gXFxcInN0cmluZ1xcXCIgPyBrZXlNYXBbdmFsXSA6IHZhbDtcXG4gIH1cXG5cXG4gIC8vIEZST01URVhUQVJFQVxcblxcbiAgQ29kZU1pcnJvci5mcm9tVGV4dEFyZWEgPSBmdW5jdGlvbih0ZXh0YXJlYSwgb3B0aW9ucykge1xcbiAgICBvcHRpb25zID0gb3B0aW9ucyA/IGNvcHlPYmoob3B0aW9ucykgOiB7fTtcXG4gICAgb3B0aW9ucy52YWx1ZSA9IHRleHRhcmVhLnZhbHVlO1xcbiAgICBpZiAoIW9wdGlvbnMudGFiaW5kZXggJiYgdGV4dGFyZWEudGFiSW5kZXgpXFxuICAgICAgb3B0aW9ucy50YWJpbmRleCA9IHRleHRhcmVhLnRhYkluZGV4O1xcbiAgICBpZiAoIW9wdGlvbnMucGxhY2Vob2xkZXIgJiYgdGV4dGFyZWEucGxhY2Vob2xkZXIpXFxuICAgICAgb3B0aW9ucy5wbGFjZWhvbGRlciA9IHRleHRhcmVhLnBsYWNlaG9sZGVyO1xcbiAgICAvLyBTZXQgYXV0b2ZvY3VzIHRvIHRydWUgaWYgdGhpcyB0ZXh0YXJlYSBpcyBmb2N1c2VkLCBvciBpZiBpdCBoYXNcXG4gICAgLy8gYXV0b2ZvY3VzIGFuZCBubyBvdGhlciBlbGVtZW50IGlzIGZvY3VzZWQuXFxuICAgIGlmIChvcHRpb25zLmF1dG9mb2N1cyA9PSBudWxsKSB7XFxuICAgICAgdmFyIGhhc0ZvY3VzID0gYWN0aXZlRWx0KCk7XFxuICAgICAgb3B0aW9ucy5hdXRvZm9jdXMgPSBoYXNGb2N1cyA9PSB0ZXh0YXJlYSB8fFxcbiAgICAgICAgdGV4dGFyZWEuZ2V0QXR0cmlidXRlKFxcXCJhdXRvZm9jdXNcXFwiKSAhPSBudWxsICYmIGhhc0ZvY3VzID09IGRvY3VtZW50LmJvZHk7XFxuICAgIH1cXG5cXG4gICAgZnVuY3Rpb24gc2F2ZSgpIHt0ZXh0YXJlYS52YWx1ZSA9IGNtLmdldFZhbHVlKCk7fVxcbiAgICBpZiAodGV4dGFyZWEuZm9ybSkge1xcbiAgICAgIG9uKHRleHRhcmVhLmZvcm0sIFxcXCJzdWJtaXRcXFwiLCBzYXZlKTtcXG4gICAgICAvLyBEZXBsb3JhYmxlIGhhY2sgdG8gbWFrZSB0aGUgc3VibWl0IG1ldGhvZCBkbyB0aGUgcmlnaHQgdGhpbmcuXFxuICAgICAgaWYgKCFvcHRpb25zLmxlYXZlU3VibWl0TWV0aG9kQWxvbmUpIHtcXG4gICAgICAgIHZhciBmb3JtID0gdGV4dGFyZWEuZm9ybSwgcmVhbFN1Ym1pdCA9IGZvcm0uc3VibWl0O1xcbiAgICAgICAgdHJ5IHtcXG4gICAgICAgICAgdmFyIHdyYXBwZWRTdWJtaXQgPSBmb3JtLnN1Ym1pdCA9IGZ1bmN0aW9uKCkge1xcbiAgICAgICAgICAgIHNhdmUoKTtcXG4gICAgICAgICAgICBmb3JtLnN1Ym1pdCA9IHJlYWxTdWJtaXQ7XFxuICAgICAgICAgICAgZm9ybS5zdWJtaXQoKTtcXG4gICAgICAgICAgICBmb3JtLnN1Ym1pdCA9IHdyYXBwZWRTdWJtaXQ7XFxuICAgICAgICAgIH07XFxuICAgICAgICB9IGNhdGNoKGUpIHt9XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIG9wdGlvbnMuZmluaXNoSW5pdCA9IGZ1bmN0aW9uKGNtKSB7XFxuICAgICAgY20uc2F2ZSA9IHNhdmU7XFxuICAgICAgY20uZ2V0VGV4dEFyZWEgPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRleHRhcmVhOyB9O1xcbiAgICAgIGNtLnRvVGV4dEFyZWEgPSBmdW5jdGlvbigpIHtcXG4gICAgICAgIGNtLnRvVGV4dEFyZWEgPSBpc05hTjsgLy8gUHJldmVudCB0aGlzIGZyb20gYmVpbmcgcmFuIHR3aWNlXFxuICAgICAgICBzYXZlKCk7XFxuICAgICAgICB0ZXh0YXJlYS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGNtLmdldFdyYXBwZXJFbGVtZW50KCkpO1xcbiAgICAgICAgdGV4dGFyZWEuc3R5bGUuZGlzcGxheSA9IFxcXCJcXFwiO1xcbiAgICAgICAgaWYgKHRleHRhcmVhLmZvcm0pIHtcXG4gICAgICAgICAgb2ZmKHRleHRhcmVhLmZvcm0sIFxcXCJzdWJtaXRcXFwiLCBzYXZlKTtcXG4gICAgICAgICAgaWYgKHR5cGVvZiB0ZXh0YXJlYS5mb3JtLnN1Ym1pdCA9PSBcXFwiZnVuY3Rpb25cXFwiKVxcbiAgICAgICAgICAgIHRleHRhcmVhLmZvcm0uc3VibWl0ID0gcmVhbFN1Ym1pdDtcXG4gICAgICAgIH1cXG4gICAgICB9O1xcbiAgICB9O1xcblxcbiAgICB0ZXh0YXJlYS5zdHlsZS5kaXNwbGF5ID0gXFxcIm5vbmVcXFwiO1xcbiAgICB2YXIgY20gPSBDb2RlTWlycm9yKGZ1bmN0aW9uKG5vZGUpIHtcXG4gICAgICB0ZXh0YXJlYS5wYXJlbnROb2RlLmluc2VydEJlZm9yZShub2RlLCB0ZXh0YXJlYS5uZXh0U2libGluZyk7XFxuICAgIH0sIG9wdGlvbnMpO1xcbiAgICByZXR1cm4gY207XFxuICB9O1xcblxcbiAgLy8gU1RSSU5HIFNUUkVBTVxcblxcbiAgLy8gRmVkIHRvIHRoZSBtb2RlIHBhcnNlcnMsIHByb3ZpZGVzIGhlbHBlciBmdW5jdGlvbnMgdG8gbWFrZVxcbiAgLy8gcGFyc2VycyBtb3JlIHN1Y2NpbmN0LlxcblxcbiAgdmFyIFN0cmluZ1N0cmVhbSA9IENvZGVNaXJyb3IuU3RyaW5nU3RyZWFtID0gZnVuY3Rpb24oc3RyaW5nLCB0YWJTaXplKSB7XFxuICAgIHRoaXMucG9zID0gdGhpcy5zdGFydCA9IDA7XFxuICAgIHRoaXMuc3RyaW5nID0gc3RyaW5nO1xcbiAgICB0aGlzLnRhYlNpemUgPSB0YWJTaXplIHx8IDg7XFxuICAgIHRoaXMubGFzdENvbHVtblBvcyA9IHRoaXMubGFzdENvbHVtblZhbHVlID0gMDtcXG4gICAgdGhpcy5saW5lU3RhcnQgPSAwO1xcbiAgfTtcXG5cXG4gIFN0cmluZ1N0cmVhbS5wcm90b3R5cGUgPSB7XFxuICAgIGVvbDogZnVuY3Rpb24oKSB7cmV0dXJuIHRoaXMucG9zID49IHRoaXMuc3RyaW5nLmxlbmd0aDt9LFxcbiAgICBzb2w6IGZ1bmN0aW9uKCkge3JldHVybiB0aGlzLnBvcyA9PSB0aGlzLmxpbmVTdGFydDt9LFxcbiAgICBwZWVrOiBmdW5jdGlvbigpIHtyZXR1cm4gdGhpcy5zdHJpbmcuY2hhckF0KHRoaXMucG9zKSB8fCB1bmRlZmluZWQ7fSxcXG4gICAgbmV4dDogZnVuY3Rpb24oKSB7XFxuICAgICAgaWYgKHRoaXMucG9zIDwgdGhpcy5zdHJpbmcubGVuZ3RoKVxcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RyaW5nLmNoYXJBdCh0aGlzLnBvcysrKTtcXG4gICAgfSxcXG4gICAgZWF0OiBmdW5jdGlvbihtYXRjaCkge1xcbiAgICAgIHZhciBjaCA9IHRoaXMuc3RyaW5nLmNoYXJBdCh0aGlzLnBvcyk7XFxuICAgICAgaWYgKHR5cGVvZiBtYXRjaCA9PSBcXFwic3RyaW5nXFxcIikgdmFyIG9rID0gY2ggPT0gbWF0Y2g7XFxuICAgICAgZWxzZSB2YXIgb2sgPSBjaCAmJiAobWF0Y2gudGVzdCA/IG1hdGNoLnRlc3QoY2gpIDogbWF0Y2goY2gpKTtcXG4gICAgICBpZiAob2spIHsrK3RoaXMucG9zOyByZXR1cm4gY2g7fVxcbiAgICB9LFxcbiAgICBlYXRXaGlsZTogZnVuY3Rpb24obWF0Y2gpIHtcXG4gICAgICB2YXIgc3RhcnQgPSB0aGlzLnBvcztcXG4gICAgICB3aGlsZSAodGhpcy5lYXQobWF0Y2gpKXt9XFxuICAgICAgcmV0dXJuIHRoaXMucG9zID4gc3RhcnQ7XFxuICAgIH0sXFxuICAgIGVhdFNwYWNlOiBmdW5jdGlvbigpIHtcXG4gICAgICB2YXIgc3RhcnQgPSB0aGlzLnBvcztcXG4gICAgICB3aGlsZSAoL1tcXFxcc1xcXFx1MDBhMF0vLnRlc3QodGhpcy5zdHJpbmcuY2hhckF0KHRoaXMucG9zKSkpICsrdGhpcy5wb3M7XFxuICAgICAgcmV0dXJuIHRoaXMucG9zID4gc3RhcnQ7XFxuICAgIH0sXFxuICAgIHNraXBUb0VuZDogZnVuY3Rpb24oKSB7dGhpcy5wb3MgPSB0aGlzLnN0cmluZy5sZW5ndGg7fSxcXG4gICAgc2tpcFRvOiBmdW5jdGlvbihjaCkge1xcbiAgICAgIHZhciBmb3VuZCA9IHRoaXMuc3RyaW5nLmluZGV4T2YoY2gsIHRoaXMucG9zKTtcXG4gICAgICBpZiAoZm91bmQgPiAtMSkge3RoaXMucG9zID0gZm91bmQ7IHJldHVybiB0cnVlO31cXG4gICAgfSxcXG4gICAgYmFja1VwOiBmdW5jdGlvbihuKSB7dGhpcy5wb3MgLT0gbjt9LFxcbiAgICBjb2x1bW46IGZ1bmN0aW9uKCkge1xcbiAgICAgIGlmICh0aGlzLmxhc3RDb2x1bW5Qb3MgPCB0aGlzLnN0YXJ0KSB7XFxuICAgICAgICB0aGlzLmxhc3RDb2x1bW5WYWx1ZSA9IGNvdW50Q29sdW1uKHRoaXMuc3RyaW5nLCB0aGlzLnN0YXJ0LCB0aGlzLnRhYlNpemUsIHRoaXMubGFzdENvbHVtblBvcywgdGhpcy5sYXN0Q29sdW1uVmFsdWUpO1xcbiAgICAgICAgdGhpcy5sYXN0Q29sdW1uUG9zID0gdGhpcy5zdGFydDtcXG4gICAgICB9XFxuICAgICAgcmV0dXJuIHRoaXMubGFzdENvbHVtblZhbHVlIC0gKHRoaXMubGluZVN0YXJ0ID8gY291bnRDb2x1bW4odGhpcy5zdHJpbmcsIHRoaXMubGluZVN0YXJ0LCB0aGlzLnRhYlNpemUpIDogMCk7XFxuICAgIH0sXFxuICAgIGluZGVudGF0aW9uOiBmdW5jdGlvbigpIHtcXG4gICAgICByZXR1cm4gY291bnRDb2x1bW4odGhpcy5zdHJpbmcsIG51bGwsIHRoaXMudGFiU2l6ZSkgLVxcbiAgICAgICAgKHRoaXMubGluZVN0YXJ0ID8gY291bnRDb2x1bW4odGhpcy5zdHJpbmcsIHRoaXMubGluZVN0YXJ0LCB0aGlzLnRhYlNpemUpIDogMCk7XFxuICAgIH0sXFxuICAgIG1hdGNoOiBmdW5jdGlvbihwYXR0ZXJuLCBjb25zdW1lLCBjYXNlSW5zZW5zaXRpdmUpIHtcXG4gICAgICBpZiAodHlwZW9mIHBhdHRlcm4gPT0gXFxcInN0cmluZ1xcXCIpIHtcXG4gICAgICAgIHZhciBjYXNlZCA9IGZ1bmN0aW9uKHN0cikge3JldHVybiBjYXNlSW5zZW5zaXRpdmUgPyBzdHIudG9Mb3dlckNhc2UoKSA6IHN0cjt9O1xcbiAgICAgICAgdmFyIHN1YnN0ciA9IHRoaXMuc3RyaW5nLnN1YnN0cih0aGlzLnBvcywgcGF0dGVybi5sZW5ndGgpO1xcbiAgICAgICAgaWYgKGNhc2VkKHN1YnN0cikgPT0gY2FzZWQocGF0dGVybikpIHtcXG4gICAgICAgICAgaWYgKGNvbnN1bWUgIT09IGZhbHNlKSB0aGlzLnBvcyArPSBwYXR0ZXJuLmxlbmd0aDtcXG4gICAgICAgICAgcmV0dXJuIHRydWU7XFxuICAgICAgICB9XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIHZhciBtYXRjaCA9IHRoaXMuc3RyaW5nLnNsaWNlKHRoaXMucG9zKS5tYXRjaChwYXR0ZXJuKTtcXG4gICAgICAgIGlmIChtYXRjaCAmJiBtYXRjaC5pbmRleCA+IDApIHJldHVybiBudWxsO1xcbiAgICAgICAgaWYgKG1hdGNoICYmIGNvbnN1bWUgIT09IGZhbHNlKSB0aGlzLnBvcyArPSBtYXRjaFswXS5sZW5ndGg7XFxuICAgICAgICByZXR1cm4gbWF0Y2g7XFxuICAgICAgfVxcbiAgICB9LFxcbiAgICBjdXJyZW50OiBmdW5jdGlvbigpe3JldHVybiB0aGlzLnN0cmluZy5zbGljZSh0aGlzLnN0YXJ0LCB0aGlzLnBvcyk7fSxcXG4gICAgaGlkZUZpcnN0Q2hhcnM6IGZ1bmN0aW9uKG4sIGlubmVyKSB7XFxuICAgICAgdGhpcy5saW5lU3RhcnQgKz0gbjtcXG4gICAgICB0cnkgeyByZXR1cm4gaW5uZXIoKTsgfVxcbiAgICAgIGZpbmFsbHkgeyB0aGlzLmxpbmVTdGFydCAtPSBuOyB9XFxuICAgIH1cXG4gIH07XFxuXFxuICAvLyBURVhUTUFSS0VSU1xcblxcbiAgLy8gQ3JlYXRlZCB3aXRoIG1hcmtUZXh0IGFuZCBzZXRCb29rbWFyayBtZXRob2RzLiBBIFRleHRNYXJrZXIgaXMgYVxcbiAgLy8gaGFuZGxlIHRoYXQgY2FuIGJlIHVzZWQgdG8gY2xlYXIgb3IgZmluZCBhIG1hcmtlZCBwb3NpdGlvbiBpbiB0aGVcXG4gIC8vIGRvY3VtZW50LiBMaW5lIG9iamVjdHMgaG9sZCBhcnJheXMgKG1hcmtlZFNwYW5zKSBjb250YWluaW5nXFxuICAvLyB7ZnJvbSwgdG8sIG1hcmtlcn0gb2JqZWN0IHBvaW50aW5nIHRvIHN1Y2ggbWFya2VyIG9iamVjdHMsIGFuZFxcbiAgLy8gaW5kaWNhdGluZyB0aGF0IHN1Y2ggYSBtYXJrZXIgaXMgcHJlc2VudCBvbiB0aGF0IGxpbmUuIE11bHRpcGxlXFxuICAvLyBsaW5lcyBtYXkgcG9pbnQgdG8gdGhlIHNhbWUgbWFya2VyIHdoZW4gaXQgc3BhbnMgYWNyb3NzIGxpbmVzLlxcbiAgLy8gVGhlIHNwYW5zIHdpbGwgaGF2ZSBudWxsIGZvciB0aGVpciBmcm9tL3RvIHByb3BlcnRpZXMgd2hlbiB0aGVcXG4gIC8vIG1hcmtlciBjb250aW51ZXMgYmV5b25kIHRoZSBzdGFydC9lbmQgb2YgdGhlIGxpbmUuIE1hcmtlcnMgaGF2ZVxcbiAgLy8gbGlua3MgYmFjayB0byB0aGUgbGluZXMgdGhleSBjdXJyZW50bHkgdG91Y2guXFxuXFxuICB2YXIgbmV4dE1hcmtlcklkID0gMDtcXG5cXG4gIHZhciBUZXh0TWFya2VyID0gQ29kZU1pcnJvci5UZXh0TWFya2VyID0gZnVuY3Rpb24oZG9jLCB0eXBlKSB7XFxuICAgIHRoaXMubGluZXMgPSBbXTtcXG4gICAgdGhpcy50eXBlID0gdHlwZTtcXG4gICAgdGhpcy5kb2MgPSBkb2M7XFxuICAgIHRoaXMuaWQgPSArK25leHRNYXJrZXJJZDtcXG4gIH07XFxuICBldmVudE1peGluKFRleHRNYXJrZXIpO1xcblxcbiAgLy8gQ2xlYXIgdGhlIG1hcmtlci5cXG4gIFRleHRNYXJrZXIucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24oKSB7XFxuICAgIGlmICh0aGlzLmV4cGxpY2l0bHlDbGVhcmVkKSByZXR1cm47XFxuICAgIHZhciBjbSA9IHRoaXMuZG9jLmNtLCB3aXRoT3AgPSBjbSAmJiAhY20uY3VyT3A7XFxuICAgIGlmICh3aXRoT3ApIHN0YXJ0T3BlcmF0aW9uKGNtKTtcXG4gICAgaWYgKGhhc0hhbmRsZXIodGhpcywgXFxcImNsZWFyXFxcIikpIHtcXG4gICAgICB2YXIgZm91bmQgPSB0aGlzLmZpbmQoKTtcXG4gICAgICBpZiAoZm91bmQpIHNpZ25hbExhdGVyKHRoaXMsIFxcXCJjbGVhclxcXCIsIGZvdW5kLmZyb20sIGZvdW5kLnRvKTtcXG4gICAgfVxcbiAgICB2YXIgbWluID0gbnVsbCwgbWF4ID0gbnVsbDtcXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxpbmVzLmxlbmd0aDsgKytpKSB7XFxuICAgICAgdmFyIGxpbmUgPSB0aGlzLmxpbmVzW2ldO1xcbiAgICAgIHZhciBzcGFuID0gZ2V0TWFya2VkU3BhbkZvcihsaW5lLm1hcmtlZFNwYW5zLCB0aGlzKTtcXG4gICAgICBpZiAoY20gJiYgIXRoaXMuY29sbGFwc2VkKSByZWdMaW5lQ2hhbmdlKGNtLCBsaW5lTm8obGluZSksIFxcXCJ0ZXh0XFxcIik7XFxuICAgICAgZWxzZSBpZiAoY20pIHtcXG4gICAgICAgIGlmIChzcGFuLnRvICE9IG51bGwpIG1heCA9IGxpbmVObyhsaW5lKTtcXG4gICAgICAgIGlmIChzcGFuLmZyb20gIT0gbnVsbCkgbWluID0gbGluZU5vKGxpbmUpO1xcbiAgICAgIH1cXG4gICAgICBsaW5lLm1hcmtlZFNwYW5zID0gcmVtb3ZlTWFya2VkU3BhbihsaW5lLm1hcmtlZFNwYW5zLCBzcGFuKTtcXG4gICAgICBpZiAoc3Bhbi5mcm9tID09IG51bGwgJiYgdGhpcy5jb2xsYXBzZWQgJiYgIWxpbmVJc0hpZGRlbih0aGlzLmRvYywgbGluZSkgJiYgY20pXFxuICAgICAgICB1cGRhdGVMaW5lSGVpZ2h0KGxpbmUsIHRleHRIZWlnaHQoY20uZGlzcGxheSkpO1xcbiAgICB9XFxuICAgIGlmIChjbSAmJiB0aGlzLmNvbGxhcHNlZCAmJiAhY20ub3B0aW9ucy5saW5lV3JhcHBpbmcpIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5saW5lcy5sZW5ndGg7ICsraSkge1xcbiAgICAgIHZhciB2aXN1YWwgPSB2aXN1YWxMaW5lKHRoaXMubGluZXNbaV0pLCBsZW4gPSBsaW5lTGVuZ3RoKHZpc3VhbCk7XFxuICAgICAgaWYgKGxlbiA+IGNtLmRpc3BsYXkubWF4TGluZUxlbmd0aCkge1xcbiAgICAgICAgY20uZGlzcGxheS5tYXhMaW5lID0gdmlzdWFsO1xcbiAgICAgICAgY20uZGlzcGxheS5tYXhMaW5lTGVuZ3RoID0gbGVuO1xcbiAgICAgICAgY20uZGlzcGxheS5tYXhMaW5lQ2hhbmdlZCA9IHRydWU7XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIGlmIChtaW4gIT0gbnVsbCAmJiBjbSAmJiB0aGlzLmNvbGxhcHNlZCkgcmVnQ2hhbmdlKGNtLCBtaW4sIG1heCArIDEpO1xcbiAgICB0aGlzLmxpbmVzLmxlbmd0aCA9IDA7XFxuICAgIHRoaXMuZXhwbGljaXRseUNsZWFyZWQgPSB0cnVlO1xcbiAgICBpZiAodGhpcy5hdG9taWMgJiYgdGhpcy5kb2MuY2FudEVkaXQpIHtcXG4gICAgICB0aGlzLmRvYy5jYW50RWRpdCA9IGZhbHNlO1xcbiAgICAgIGlmIChjbSkgcmVDaGVja1NlbGVjdGlvbihjbS5kb2MpO1xcbiAgICB9XFxuICAgIGlmIChjbSkgc2lnbmFsTGF0ZXIoY20sIFxcXCJtYXJrZXJDbGVhcmVkXFxcIiwgY20sIHRoaXMpO1xcbiAgICBpZiAod2l0aE9wKSBlbmRPcGVyYXRpb24oY20pO1xcbiAgICBpZiAodGhpcy5wYXJlbnQpIHRoaXMucGFyZW50LmNsZWFyKCk7XFxuICB9O1xcblxcbiAgLy8gRmluZCB0aGUgcG9zaXRpb24gb2YgdGhlIG1hcmtlciBpbiB0aGUgZG9jdW1lbnQuIFJldHVybnMgYSB7ZnJvbSxcXG4gIC8vIHRvfSBvYmplY3QgYnkgZGVmYXVsdC4gU2lkZSBjYW4gYmUgcGFzc2VkIHRvIGdldCBhIHNwZWNpZmljIHNpZGVcXG4gIC8vIC0tIDAgKGJvdGgpLCAtMSAobGVmdCksIG9yIDEgKHJpZ2h0KS4gV2hlbiBsaW5lT2JqIGlzIHRydWUsIHRoZVxcbiAgLy8gUG9zIG9iamVjdHMgcmV0dXJuZWQgY29udGFpbiBhIGxpbmUgb2JqZWN0LCByYXRoZXIgdGhhbiBhIGxpbmVcXG4gIC8vIG51bWJlciAodXNlZCB0byBwcmV2ZW50IGxvb2tpbmcgdXAgdGhlIHNhbWUgbGluZSB0d2ljZSkuXFxuICBUZXh0TWFya2VyLnByb3RvdHlwZS5maW5kID0gZnVuY3Rpb24oc2lkZSwgbGluZU9iaikge1xcbiAgICBpZiAoc2lkZSA9PSBudWxsICYmIHRoaXMudHlwZSA9PSBcXFwiYm9va21hcmtcXFwiKSBzaWRlID0gMTtcXG4gICAgdmFyIGZyb20sIHRvO1xcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGluZXMubGVuZ3RoOyArK2kpIHtcXG4gICAgICB2YXIgbGluZSA9IHRoaXMubGluZXNbaV07XFxuICAgICAgdmFyIHNwYW4gPSBnZXRNYXJrZWRTcGFuRm9yKGxpbmUubWFya2VkU3BhbnMsIHRoaXMpO1xcbiAgICAgIGlmIChzcGFuLmZyb20gIT0gbnVsbCkge1xcbiAgICAgICAgZnJvbSA9IFBvcyhsaW5lT2JqID8gbGluZSA6IGxpbmVObyhsaW5lKSwgc3Bhbi5mcm9tKTtcXG4gICAgICAgIGlmIChzaWRlID09IC0xKSByZXR1cm4gZnJvbTtcXG4gICAgICB9XFxuICAgICAgaWYgKHNwYW4udG8gIT0gbnVsbCkge1xcbiAgICAgICAgdG8gPSBQb3MobGluZU9iaiA/IGxpbmUgOiBsaW5lTm8obGluZSksIHNwYW4udG8pO1xcbiAgICAgICAgaWYgKHNpZGUgPT0gMSkgcmV0dXJuIHRvO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgICByZXR1cm4gZnJvbSAmJiB7ZnJvbTogZnJvbSwgdG86IHRvfTtcXG4gIH07XFxuXFxuICAvLyBTaWduYWxzIHRoYXQgdGhlIG1hcmtlcidzIHdpZGdldCBjaGFuZ2VkLCBhbmQgc3Vycm91bmRpbmcgbGF5b3V0XFxuICAvLyBzaG91bGQgYmUgcmVjb21wdXRlZC5cXG4gIFRleHRNYXJrZXIucHJvdG90eXBlLmNoYW5nZWQgPSBmdW5jdGlvbigpIHtcXG4gICAgdmFyIHBvcyA9IHRoaXMuZmluZCgtMSwgdHJ1ZSksIHdpZGdldCA9IHRoaXMsIGNtID0gdGhpcy5kb2MuY207XFxuICAgIGlmICghcG9zIHx8ICFjbSkgcmV0dXJuO1xcbiAgICBydW5Jbk9wKGNtLCBmdW5jdGlvbigpIHtcXG4gICAgICB2YXIgbGluZSA9IHBvcy5saW5lLCBsaW5lTiA9IGxpbmVObyhwb3MubGluZSk7XFxuICAgICAgdmFyIHZpZXcgPSBmaW5kVmlld0ZvckxpbmUoY20sIGxpbmVOKTtcXG4gICAgICBpZiAodmlldykge1xcbiAgICAgICAgY2xlYXJMaW5lTWVhc3VyZW1lbnRDYWNoZUZvcih2aWV3KTtcXG4gICAgICAgIGNtLmN1ck9wLnNlbGVjdGlvbkNoYW5nZWQgPSBjbS5jdXJPcC5mb3JjZVVwZGF0ZSA9IHRydWU7XFxuICAgICAgfVxcbiAgICAgIGNtLmN1ck9wLnVwZGF0ZU1heExpbmUgPSB0cnVlO1xcbiAgICAgIGlmICghbGluZUlzSGlkZGVuKHdpZGdldC5kb2MsIGxpbmUpICYmIHdpZGdldC5oZWlnaHQgIT0gbnVsbCkge1xcbiAgICAgICAgdmFyIG9sZEhlaWdodCA9IHdpZGdldC5oZWlnaHQ7XFxuICAgICAgICB3aWRnZXQuaGVpZ2h0ID0gbnVsbDtcXG4gICAgICAgIHZhciBkSGVpZ2h0ID0gd2lkZ2V0SGVpZ2h0KHdpZGdldCkgLSBvbGRIZWlnaHQ7XFxuICAgICAgICBpZiAoZEhlaWdodClcXG4gICAgICAgICAgdXBkYXRlTGluZUhlaWdodChsaW5lLCBsaW5lLmhlaWdodCArIGRIZWlnaHQpO1xcbiAgICAgIH1cXG4gICAgfSk7XFxuICB9O1xcblxcbiAgVGV4dE1hcmtlci5wcm90b3R5cGUuYXR0YWNoTGluZSA9IGZ1bmN0aW9uKGxpbmUpIHtcXG4gICAgaWYgKCF0aGlzLmxpbmVzLmxlbmd0aCAmJiB0aGlzLmRvYy5jbSkge1xcbiAgICAgIHZhciBvcCA9IHRoaXMuZG9jLmNtLmN1ck9wO1xcbiAgICAgIGlmICghb3AubWF5YmVIaWRkZW5NYXJrZXJzIHx8IGluZGV4T2Yob3AubWF5YmVIaWRkZW5NYXJrZXJzLCB0aGlzKSA9PSAtMSlcXG4gICAgICAgIChvcC5tYXliZVVuaGlkZGVuTWFya2VycyB8fCAob3AubWF5YmVVbmhpZGRlbk1hcmtlcnMgPSBbXSkpLnB1c2godGhpcyk7XFxuICAgIH1cXG4gICAgdGhpcy5saW5lcy5wdXNoKGxpbmUpO1xcbiAgfTtcXG4gIFRleHRNYXJrZXIucHJvdG90eXBlLmRldGFjaExpbmUgPSBmdW5jdGlvbihsaW5lKSB7XFxuICAgIHRoaXMubGluZXMuc3BsaWNlKGluZGV4T2YodGhpcy5saW5lcywgbGluZSksIDEpO1xcbiAgICBpZiAoIXRoaXMubGluZXMubGVuZ3RoICYmIHRoaXMuZG9jLmNtKSB7XFxuICAgICAgdmFyIG9wID0gdGhpcy5kb2MuY20uY3VyT3A7XFxuICAgICAgKG9wLm1heWJlSGlkZGVuTWFya2VycyB8fCAob3AubWF5YmVIaWRkZW5NYXJrZXJzID0gW10pKS5wdXNoKHRoaXMpO1xcbiAgICB9XFxuICB9O1xcblxcbiAgLy8gQ29sbGFwc2VkIG1hcmtlcnMgaGF2ZSB1bmlxdWUgaWRzLCBpbiBvcmRlciB0byBiZSBhYmxlIHRvIG9yZGVyXFxuICAvLyB0aGVtLCB3aGljaCBpcyBuZWVkZWQgZm9yIHVuaXF1ZWx5IGRldGVybWluaW5nIGFuIG91dGVyIG1hcmtlclxcbiAgLy8gd2hlbiB0aGV5IG92ZXJsYXAgKHRoZXkgbWF5IG5lc3QsIGJ1dCBub3QgcGFydGlhbGx5IG92ZXJsYXApLlxcbiAgdmFyIG5leHRNYXJrZXJJZCA9IDA7XFxuXFxuICAvLyBDcmVhdGUgYSBtYXJrZXIsIHdpcmUgaXQgdXAgdG8gdGhlIHJpZ2h0IGxpbmVzLCBhbmRcXG4gIGZ1bmN0aW9uIG1hcmtUZXh0KGRvYywgZnJvbSwgdG8sIG9wdGlvbnMsIHR5cGUpIHtcXG4gICAgLy8gU2hhcmVkIG1hcmtlcnMgKGFjcm9zcyBsaW5rZWQgZG9jdW1lbnRzKSBhcmUgaGFuZGxlZCBzZXBhcmF0ZWx5XFxuICAgIC8vIChtYXJrVGV4dFNoYXJlZCB3aWxsIGNhbGwgb3V0IHRvIHRoaXMgYWdhaW4sIG9uY2UgcGVyXFxuICAgIC8vIGRvY3VtZW50KS5cXG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5zaGFyZWQpIHJldHVybiBtYXJrVGV4dFNoYXJlZChkb2MsIGZyb20sIHRvLCBvcHRpb25zLCB0eXBlKTtcXG4gICAgLy8gRW5zdXJlIHdlIGFyZSBpbiBhbiBvcGVyYXRpb24uXFxuICAgIGlmIChkb2MuY20gJiYgIWRvYy5jbS5jdXJPcCkgcmV0dXJuIG9wZXJhdGlvbihkb2MuY20sIG1hcmtUZXh0KShkb2MsIGZyb20sIHRvLCBvcHRpb25zLCB0eXBlKTtcXG5cXG4gICAgdmFyIG1hcmtlciA9IG5ldyBUZXh0TWFya2VyKGRvYywgdHlwZSksIGRpZmYgPSBjbXAoZnJvbSwgdG8pO1xcbiAgICBpZiAob3B0aW9ucykgY29weU9iaihvcHRpb25zLCBtYXJrZXIsIGZhbHNlKTtcXG4gICAgLy8gRG9uJ3QgY29ubmVjdCBlbXB0eSBtYXJrZXJzIHVubGVzcyBjbGVhcldoZW5FbXB0eSBpcyBmYWxzZVxcbiAgICBpZiAoZGlmZiA+IDAgfHwgZGlmZiA9PSAwICYmIG1hcmtlci5jbGVhcldoZW5FbXB0eSAhPT0gZmFsc2UpXFxuICAgICAgcmV0dXJuIG1hcmtlcjtcXG4gICAgaWYgKG1hcmtlci5yZXBsYWNlZFdpdGgpIHtcXG4gICAgICAvLyBTaG93aW5nIHVwIGFzIGEgd2lkZ2V0IGltcGxpZXMgY29sbGFwc2VkICh3aWRnZXQgcmVwbGFjZXMgdGV4dClcXG4gICAgICBtYXJrZXIuY29sbGFwc2VkID0gdHJ1ZTtcXG4gICAgICBtYXJrZXIud2lkZ2V0Tm9kZSA9IGVsdChcXFwic3BhblxcXCIsIFttYXJrZXIucmVwbGFjZWRXaXRoXSwgXFxcIkNvZGVNaXJyb3Itd2lkZ2V0XFxcIik7XFxuICAgICAgaWYgKCFvcHRpb25zLmhhbmRsZU1vdXNlRXZlbnRzKSBtYXJrZXIud2lkZ2V0Tm9kZS5zZXRBdHRyaWJ1dGUoXFxcImNtLWlnbm9yZS1ldmVudHNcXFwiLCBcXFwidHJ1ZVxcXCIpO1xcbiAgICAgIGlmIChvcHRpb25zLmluc2VydExlZnQpIG1hcmtlci53aWRnZXROb2RlLmluc2VydExlZnQgPSB0cnVlO1xcbiAgICB9XFxuICAgIGlmIChtYXJrZXIuY29sbGFwc2VkKSB7XFxuICAgICAgaWYgKGNvbmZsaWN0aW5nQ29sbGFwc2VkUmFuZ2UoZG9jLCBmcm9tLmxpbmUsIGZyb20sIHRvLCBtYXJrZXIpIHx8XFxuICAgICAgICAgIGZyb20ubGluZSAhPSB0by5saW5lICYmIGNvbmZsaWN0aW5nQ29sbGFwc2VkUmFuZ2UoZG9jLCB0by5saW5lLCBmcm9tLCB0bywgbWFya2VyKSlcXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcXFwiSW5zZXJ0aW5nIGNvbGxhcHNlZCBtYXJrZXIgcGFydGlhbGx5IG92ZXJsYXBwaW5nIGFuIGV4aXN0aW5nIG9uZVxcXCIpO1xcbiAgICAgIHNhd0NvbGxhcHNlZFNwYW5zID0gdHJ1ZTtcXG4gICAgfVxcblxcbiAgICBpZiAobWFya2VyLmFkZFRvSGlzdG9yeSlcXG4gICAgICBhZGRDaGFuZ2VUb0hpc3RvcnkoZG9jLCB7ZnJvbTogZnJvbSwgdG86IHRvLCBvcmlnaW46IFxcXCJtYXJrVGV4dFxcXCJ9LCBkb2Muc2VsLCBOYU4pO1xcblxcbiAgICB2YXIgY3VyTGluZSA9IGZyb20ubGluZSwgY20gPSBkb2MuY20sIHVwZGF0ZU1heExpbmU7XFxuICAgIGRvYy5pdGVyKGN1ckxpbmUsIHRvLmxpbmUgKyAxLCBmdW5jdGlvbihsaW5lKSB7XFxuICAgICAgaWYgKGNtICYmIG1hcmtlci5jb2xsYXBzZWQgJiYgIWNtLm9wdGlvbnMubGluZVdyYXBwaW5nICYmIHZpc3VhbExpbmUobGluZSkgPT0gY20uZGlzcGxheS5tYXhMaW5lKVxcbiAgICAgICAgdXBkYXRlTWF4TGluZSA9IHRydWU7XFxuICAgICAgaWYgKG1hcmtlci5jb2xsYXBzZWQgJiYgY3VyTGluZSAhPSBmcm9tLmxpbmUpIHVwZGF0ZUxpbmVIZWlnaHQobGluZSwgMCk7XFxuICAgICAgYWRkTWFya2VkU3BhbihsaW5lLCBuZXcgTWFya2VkU3BhbihtYXJrZXIsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJMaW5lID09IGZyb20ubGluZSA/IGZyb20uY2ggOiBudWxsLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VyTGluZSA9PSB0by5saW5lID8gdG8uY2ggOiBudWxsKSk7XFxuICAgICAgKytjdXJMaW5lO1xcbiAgICB9KTtcXG4gICAgLy8gbGluZUlzSGlkZGVuIGRlcGVuZHMgb24gdGhlIHByZXNlbmNlIG9mIHRoZSBzcGFucywgc28gbmVlZHMgYSBzZWNvbmQgcGFzc1xcbiAgICBpZiAobWFya2VyLmNvbGxhcHNlZCkgZG9jLml0ZXIoZnJvbS5saW5lLCB0by5saW5lICsgMSwgZnVuY3Rpb24obGluZSkge1xcbiAgICAgIGlmIChsaW5lSXNIaWRkZW4oZG9jLCBsaW5lKSkgdXBkYXRlTGluZUhlaWdodChsaW5lLCAwKTtcXG4gICAgfSk7XFxuXFxuICAgIGlmIChtYXJrZXIuY2xlYXJPbkVudGVyKSBvbihtYXJrZXIsIFxcXCJiZWZvcmVDdXJzb3JFbnRlclxcXCIsIGZ1bmN0aW9uKCkgeyBtYXJrZXIuY2xlYXIoKTsgfSk7XFxuXFxuICAgIGlmIChtYXJrZXIucmVhZE9ubHkpIHtcXG4gICAgICBzYXdSZWFkT25seVNwYW5zID0gdHJ1ZTtcXG4gICAgICBpZiAoZG9jLmhpc3RvcnkuZG9uZS5sZW5ndGggfHwgZG9jLmhpc3RvcnkudW5kb25lLmxlbmd0aClcXG4gICAgICAgIGRvYy5jbGVhckhpc3RvcnkoKTtcXG4gICAgfVxcbiAgICBpZiAobWFya2VyLmNvbGxhcHNlZCkge1xcbiAgICAgIG1hcmtlci5pZCA9ICsrbmV4dE1hcmtlcklkO1xcbiAgICAgIG1hcmtlci5hdG9taWMgPSB0cnVlO1xcbiAgICB9XFxuICAgIGlmIChjbSkge1xcbiAgICAgIC8vIFN5bmMgZWRpdG9yIHN0YXRlXFxuICAgICAgaWYgKHVwZGF0ZU1heExpbmUpIGNtLmN1ck9wLnVwZGF0ZU1heExpbmUgPSB0cnVlO1xcbiAgICAgIGlmIChtYXJrZXIuY29sbGFwc2VkKVxcbiAgICAgICAgcmVnQ2hhbmdlKGNtLCBmcm9tLmxpbmUsIHRvLmxpbmUgKyAxKTtcXG4gICAgICBlbHNlIGlmIChtYXJrZXIuY2xhc3NOYW1lIHx8IG1hcmtlci50aXRsZSB8fCBtYXJrZXIuc3RhcnRTdHlsZSB8fCBtYXJrZXIuZW5kU3R5bGUgfHwgbWFya2VyLmNzcylcXG4gICAgICAgIGZvciAodmFyIGkgPSBmcm9tLmxpbmU7IGkgPD0gdG8ubGluZTsgaSsrKSByZWdMaW5lQ2hhbmdlKGNtLCBpLCBcXFwidGV4dFxcXCIpO1xcbiAgICAgIGlmIChtYXJrZXIuYXRvbWljKSByZUNoZWNrU2VsZWN0aW9uKGNtLmRvYyk7XFxuICAgICAgc2lnbmFsTGF0ZXIoY20sIFxcXCJtYXJrZXJBZGRlZFxcXCIsIGNtLCBtYXJrZXIpO1xcbiAgICB9XFxuICAgIHJldHVybiBtYXJrZXI7XFxuICB9XFxuXFxuICAvLyBTSEFSRUQgVEVYVE1BUktFUlNcXG5cXG4gIC8vIEEgc2hhcmVkIG1hcmtlciBzcGFucyBtdWx0aXBsZSBsaW5rZWQgZG9jdW1lbnRzLiBJdCBpc1xcbiAgLy8gaW1wbGVtZW50ZWQgYXMgYSBtZXRhLW1hcmtlci1vYmplY3QgY29udHJvbGxpbmcgbXVsdGlwbGUgbm9ybWFsXFxuICAvLyBtYXJrZXJzLlxcbiAgdmFyIFNoYXJlZFRleHRNYXJrZXIgPSBDb2RlTWlycm9yLlNoYXJlZFRleHRNYXJrZXIgPSBmdW5jdGlvbihtYXJrZXJzLCBwcmltYXJ5KSB7XFxuICAgIHRoaXMubWFya2VycyA9IG1hcmtlcnM7XFxuICAgIHRoaXMucHJpbWFyeSA9IHByaW1hcnk7XFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWFya2Vycy5sZW5ndGg7ICsraSlcXG4gICAgICBtYXJrZXJzW2ldLnBhcmVudCA9IHRoaXM7XFxuICB9O1xcbiAgZXZlbnRNaXhpbihTaGFyZWRUZXh0TWFya2VyKTtcXG5cXG4gIFNoYXJlZFRleHRNYXJrZXIucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24oKSB7XFxuICAgIGlmICh0aGlzLmV4cGxpY2l0bHlDbGVhcmVkKSByZXR1cm47XFxuICAgIHRoaXMuZXhwbGljaXRseUNsZWFyZWQgPSB0cnVlO1xcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubWFya2Vycy5sZW5ndGg7ICsraSlcXG4gICAgICB0aGlzLm1hcmtlcnNbaV0uY2xlYXIoKTtcXG4gICAgc2lnbmFsTGF0ZXIodGhpcywgXFxcImNsZWFyXFxcIik7XFxuICB9O1xcbiAgU2hhcmVkVGV4dE1hcmtlci5wcm90b3R5cGUuZmluZCA9IGZ1bmN0aW9uKHNpZGUsIGxpbmVPYmopIHtcXG4gICAgcmV0dXJuIHRoaXMucHJpbWFyeS5maW5kKHNpZGUsIGxpbmVPYmopO1xcbiAgfTtcXG5cXG4gIGZ1bmN0aW9uIG1hcmtUZXh0U2hhcmVkKGRvYywgZnJvbSwgdG8sIG9wdGlvbnMsIHR5cGUpIHtcXG4gICAgb3B0aW9ucyA9IGNvcHlPYmoob3B0aW9ucyk7XFxuICAgIG9wdGlvbnMuc2hhcmVkID0gZmFsc2U7XFxuICAgIHZhciBtYXJrZXJzID0gW21hcmtUZXh0KGRvYywgZnJvbSwgdG8sIG9wdGlvbnMsIHR5cGUpXSwgcHJpbWFyeSA9IG1hcmtlcnNbMF07XFxuICAgIHZhciB3aWRnZXQgPSBvcHRpb25zLndpZGdldE5vZGU7XFxuICAgIGxpbmtlZERvY3MoZG9jLCBmdW5jdGlvbihkb2MpIHtcXG4gICAgICBpZiAod2lkZ2V0KSBvcHRpb25zLndpZGdldE5vZGUgPSB3aWRnZXQuY2xvbmVOb2RlKHRydWUpO1xcbiAgICAgIG1hcmtlcnMucHVzaChtYXJrVGV4dChkb2MsIGNsaXBQb3MoZG9jLCBmcm9tKSwgY2xpcFBvcyhkb2MsIHRvKSwgb3B0aW9ucywgdHlwZSkpO1xcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZG9jLmxpbmtlZC5sZW5ndGg7ICsraSlcXG4gICAgICAgIGlmIChkb2MubGlua2VkW2ldLmlzUGFyZW50KSByZXR1cm47XFxuICAgICAgcHJpbWFyeSA9IGxzdChtYXJrZXJzKTtcXG4gICAgfSk7XFxuICAgIHJldHVybiBuZXcgU2hhcmVkVGV4dE1hcmtlcihtYXJrZXJzLCBwcmltYXJ5KTtcXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIGZpbmRTaGFyZWRNYXJrZXJzKGRvYykge1xcbiAgICByZXR1cm4gZG9jLmZpbmRNYXJrcyhQb3MoZG9jLmZpcnN0LCAwKSwgZG9jLmNsaXBQb3MoUG9zKGRvYy5sYXN0TGluZSgpKSksXFxuICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uKG0pIHsgcmV0dXJuIG0ucGFyZW50OyB9KTtcXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIGNvcHlTaGFyZWRNYXJrZXJzKGRvYywgbWFya2Vycykge1xcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1hcmtlcnMubGVuZ3RoOyBpKyspIHtcXG4gICAgICB2YXIgbWFya2VyID0gbWFya2Vyc1tpXSwgcG9zID0gbWFya2VyLmZpbmQoKTtcXG4gICAgICB2YXIgbUZyb20gPSBkb2MuY2xpcFBvcyhwb3MuZnJvbSksIG1UbyA9IGRvYy5jbGlwUG9zKHBvcy50byk7XFxuICAgICAgaWYgKGNtcChtRnJvbSwgbVRvKSkge1xcbiAgICAgICAgdmFyIHN1Yk1hcmsgPSBtYXJrVGV4dChkb2MsIG1Gcm9tLCBtVG8sIG1hcmtlci5wcmltYXJ5LCBtYXJrZXIucHJpbWFyeS50eXBlKTtcXG4gICAgICAgIG1hcmtlci5tYXJrZXJzLnB1c2goc3ViTWFyayk7XFxuICAgICAgICBzdWJNYXJrLnBhcmVudCA9IG1hcmtlcjtcXG4gICAgICB9XFxuICAgIH1cXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIGRldGFjaFNoYXJlZE1hcmtlcnMobWFya2Vycykge1xcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1hcmtlcnMubGVuZ3RoOyBpKyspIHtcXG4gICAgICB2YXIgbWFya2VyID0gbWFya2Vyc1tpXSwgbGlua2VkID0gW21hcmtlci5wcmltYXJ5LmRvY107O1xcbiAgICAgIGxpbmtlZERvY3MobWFya2VyLnByaW1hcnkuZG9jLCBmdW5jdGlvbihkKSB7IGxpbmtlZC5wdXNoKGQpOyB9KTtcXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG1hcmtlci5tYXJrZXJzLmxlbmd0aDsgaisrKSB7XFxuICAgICAgICB2YXIgc3ViTWFya2VyID0gbWFya2VyLm1hcmtlcnNbal07XFxuICAgICAgICBpZiAoaW5kZXhPZihsaW5rZWQsIHN1Yk1hcmtlci5kb2MpID09IC0xKSB7XFxuICAgICAgICAgIHN1Yk1hcmtlci5wYXJlbnQgPSBudWxsO1xcbiAgICAgICAgICBtYXJrZXIubWFya2Vycy5zcGxpY2Uoai0tLCAxKTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIH1cXG4gIH1cXG5cXG4gIC8vIFRFWFRNQVJLRVIgU1BBTlNcXG5cXG4gIGZ1bmN0aW9uIE1hcmtlZFNwYW4obWFya2VyLCBmcm9tLCB0bykge1xcbiAgICB0aGlzLm1hcmtlciA9IG1hcmtlcjtcXG4gICAgdGhpcy5mcm9tID0gZnJvbTsgdGhpcy50byA9IHRvO1xcbiAgfVxcblxcbiAgLy8gU2VhcmNoIGFuIGFycmF5IG9mIHNwYW5zIGZvciBhIHNwYW4gbWF0Y2hpbmcgdGhlIGdpdmVuIG1hcmtlci5cXG4gIGZ1bmN0aW9uIGdldE1hcmtlZFNwYW5Gb3Ioc3BhbnMsIG1hcmtlcikge1xcbiAgICBpZiAoc3BhbnMpIGZvciAodmFyIGkgPSAwOyBpIDwgc3BhbnMubGVuZ3RoOyArK2kpIHtcXG4gICAgICB2YXIgc3BhbiA9IHNwYW5zW2ldO1xcbiAgICAgIGlmIChzcGFuLm1hcmtlciA9PSBtYXJrZXIpIHJldHVybiBzcGFuO1xcbiAgICB9XFxuICB9XFxuICAvLyBSZW1vdmUgYSBzcGFuIGZyb20gYW4gYXJyYXksIHJldHVybmluZyB1bmRlZmluZWQgaWYgbm8gc3BhbnMgYXJlXFxuICAvLyBsZWZ0ICh3ZSBkb24ndCBzdG9yZSBhcnJheXMgZm9yIGxpbmVzIHdpdGhvdXQgc3BhbnMpLlxcbiAgZnVuY3Rpb24gcmVtb3ZlTWFya2VkU3BhbihzcGFucywgc3Bhbikge1xcbiAgICBmb3IgKHZhciByLCBpID0gMDsgaSA8IHNwYW5zLmxlbmd0aDsgKytpKVxcbiAgICAgIGlmIChzcGFuc1tpXSAhPSBzcGFuKSAociB8fCAociA9IFtdKSkucHVzaChzcGFuc1tpXSk7XFxuICAgIHJldHVybiByO1xcbiAgfVxcbiAgLy8gQWRkIGEgc3BhbiB0byBhIGxpbmUuXFxuICBmdW5jdGlvbiBhZGRNYXJrZWRTcGFuKGxpbmUsIHNwYW4pIHtcXG4gICAgbGluZS5tYXJrZWRTcGFucyA9IGxpbmUubWFya2VkU3BhbnMgPyBsaW5lLm1hcmtlZFNwYW5zLmNvbmNhdChbc3Bhbl0pIDogW3NwYW5dO1xcbiAgICBzcGFuLm1hcmtlci5hdHRhY2hMaW5lKGxpbmUpO1xcbiAgfVxcblxcbiAgLy8gVXNlZCBmb3IgdGhlIGFsZ29yaXRobSB0aGF0IGFkanVzdHMgbWFya2VycyBmb3IgYSBjaGFuZ2UgaW4gdGhlXFxuICAvLyBkb2N1bWVudC4gVGhlc2UgZnVuY3Rpb25zIGN1dCBhbiBhcnJheSBvZiBzcGFucyBhdCBhIGdpdmVuXFxuICAvLyBjaGFyYWN0ZXIgcG9zaXRpb24sIHJldHVybmluZyBhbiBhcnJheSBvZiByZW1haW5pbmcgY2h1bmtzIChvclxcbiAgLy8gdW5kZWZpbmVkIGlmIG5vdGhpbmcgcmVtYWlucykuXFxuICBmdW5jdGlvbiBtYXJrZWRTcGFuc0JlZm9yZShvbGQsIHN0YXJ0Q2gsIGlzSW5zZXJ0KSB7XFxuICAgIGlmIChvbGQpIGZvciAodmFyIGkgPSAwLCBudzsgaSA8IG9sZC5sZW5ndGg7ICsraSkge1xcbiAgICAgIHZhciBzcGFuID0gb2xkW2ldLCBtYXJrZXIgPSBzcGFuLm1hcmtlcjtcXG4gICAgICB2YXIgc3RhcnRzQmVmb3JlID0gc3Bhbi5mcm9tID09IG51bGwgfHwgKG1hcmtlci5pbmNsdXNpdmVMZWZ0ID8gc3Bhbi5mcm9tIDw9IHN0YXJ0Q2ggOiBzcGFuLmZyb20gPCBzdGFydENoKTtcXG4gICAgICBpZiAoc3RhcnRzQmVmb3JlIHx8IHNwYW4uZnJvbSA9PSBzdGFydENoICYmIG1hcmtlci50eXBlID09IFxcXCJib29rbWFya1xcXCIgJiYgKCFpc0luc2VydCB8fCAhc3Bhbi5tYXJrZXIuaW5zZXJ0TGVmdCkpIHtcXG4gICAgICAgIHZhciBlbmRzQWZ0ZXIgPSBzcGFuLnRvID09IG51bGwgfHwgKG1hcmtlci5pbmNsdXNpdmVSaWdodCA/IHNwYW4udG8gPj0gc3RhcnRDaCA6IHNwYW4udG8gPiBzdGFydENoKTtcXG4gICAgICAgIChudyB8fCAobncgPSBbXSkpLnB1c2gobmV3IE1hcmtlZFNwYW4obWFya2VyLCBzcGFuLmZyb20sIGVuZHNBZnRlciA/IG51bGwgOiBzcGFuLnRvKSk7XFxuICAgICAgfVxcbiAgICB9XFxuICAgIHJldHVybiBudztcXG4gIH1cXG4gIGZ1bmN0aW9uIG1hcmtlZFNwYW5zQWZ0ZXIob2xkLCBlbmRDaCwgaXNJbnNlcnQpIHtcXG4gICAgaWYgKG9sZCkgZm9yICh2YXIgaSA9IDAsIG53OyBpIDwgb2xkLmxlbmd0aDsgKytpKSB7XFxuICAgICAgdmFyIHNwYW4gPSBvbGRbaV0sIG1hcmtlciA9IHNwYW4ubWFya2VyO1xcbiAgICAgIHZhciBlbmRzQWZ0ZXIgPSBzcGFuLnRvID09IG51bGwgfHwgKG1hcmtlci5pbmNsdXNpdmVSaWdodCA/IHNwYW4udG8gPj0gZW5kQ2ggOiBzcGFuLnRvID4gZW5kQ2gpO1xcbiAgICAgIGlmIChlbmRzQWZ0ZXIgfHwgc3Bhbi5mcm9tID09IGVuZENoICYmIG1hcmtlci50eXBlID09IFxcXCJib29rbWFya1xcXCIgJiYgKCFpc0luc2VydCB8fCBzcGFuLm1hcmtlci5pbnNlcnRMZWZ0KSkge1xcbiAgICAgICAgdmFyIHN0YXJ0c0JlZm9yZSA9IHNwYW4uZnJvbSA9PSBudWxsIHx8IChtYXJrZXIuaW5jbHVzaXZlTGVmdCA/IHNwYW4uZnJvbSA8PSBlbmRDaCA6IHNwYW4uZnJvbSA8IGVuZENoKTtcXG4gICAgICAgIChudyB8fCAobncgPSBbXSkpLnB1c2gobmV3IE1hcmtlZFNwYW4obWFya2VyLCBzdGFydHNCZWZvcmUgPyBudWxsIDogc3Bhbi5mcm9tIC0gZW5kQ2gsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNwYW4udG8gPT0gbnVsbCA/IG51bGwgOiBzcGFuLnRvIC0gZW5kQ2gpKTtcXG4gICAgICB9XFxuICAgIH1cXG4gICAgcmV0dXJuIG53O1xcbiAgfVxcblxcbiAgLy8gR2l2ZW4gYSBjaGFuZ2Ugb2JqZWN0LCBjb21wdXRlIHRoZSBuZXcgc2V0IG9mIG1hcmtlciBzcGFucyB0aGF0XFxuICAvLyBjb3ZlciB0aGUgbGluZSBpbiB3aGljaCB0aGUgY2hhbmdlIHRvb2sgcGxhY2UuIFJlbW92ZXMgc3BhbnNcXG4gIC8vIGVudGlyZWx5IHdpdGhpbiB0aGUgY2hhbmdlLCByZWNvbm5lY3RzIHNwYW5zIGJlbG9uZ2luZyB0byB0aGVcXG4gIC8vIHNhbWUgbWFya2VyIHRoYXQgYXBwZWFyIG9uIGJvdGggc2lkZXMgb2YgdGhlIGNoYW5nZSwgYW5kIGN1dHMgb2ZmXFxuICAvLyBzcGFucyBwYXJ0aWFsbHkgd2l0aGluIHRoZSBjaGFuZ2UuIFJldHVybnMgYW4gYXJyYXkgb2Ygc3BhblxcbiAgLy8gYXJyYXlzIHdpdGggb25lIGVsZW1lbnQgZm9yIGVhY2ggbGluZSBpbiAoYWZ0ZXIpIHRoZSBjaGFuZ2UuXFxuICBmdW5jdGlvbiBzdHJldGNoU3BhbnNPdmVyQ2hhbmdlKGRvYywgY2hhbmdlKSB7XFxuICAgIGlmIChjaGFuZ2UuZnVsbCkgcmV0dXJuIG51bGw7XFxuICAgIHZhciBvbGRGaXJzdCA9IGlzTGluZShkb2MsIGNoYW5nZS5mcm9tLmxpbmUpICYmIGdldExpbmUoZG9jLCBjaGFuZ2UuZnJvbS5saW5lKS5tYXJrZWRTcGFucztcXG4gICAgdmFyIG9sZExhc3QgPSBpc0xpbmUoZG9jLCBjaGFuZ2UudG8ubGluZSkgJiYgZ2V0TGluZShkb2MsIGNoYW5nZS50by5saW5lKS5tYXJrZWRTcGFucztcXG4gICAgaWYgKCFvbGRGaXJzdCAmJiAhb2xkTGFzdCkgcmV0dXJuIG51bGw7XFxuXFxuICAgIHZhciBzdGFydENoID0gY2hhbmdlLmZyb20uY2gsIGVuZENoID0gY2hhbmdlLnRvLmNoLCBpc0luc2VydCA9IGNtcChjaGFuZ2UuZnJvbSwgY2hhbmdlLnRvKSA9PSAwO1xcbiAgICAvLyBHZXQgdGhlIHNwYW5zIHRoYXQgJ3N0aWNrIG91dCcgb24gYm90aCBzaWRlc1xcbiAgICB2YXIgZmlyc3QgPSBtYXJrZWRTcGFuc0JlZm9yZShvbGRGaXJzdCwgc3RhcnRDaCwgaXNJbnNlcnQpO1xcbiAgICB2YXIgbGFzdCA9IG1hcmtlZFNwYW5zQWZ0ZXIob2xkTGFzdCwgZW5kQ2gsIGlzSW5zZXJ0KTtcXG5cXG4gICAgLy8gTmV4dCwgbWVyZ2UgdGhvc2UgdHdvIGVuZHNcXG4gICAgdmFyIHNhbWVMaW5lID0gY2hhbmdlLnRleHQubGVuZ3RoID09IDEsIG9mZnNldCA9IGxzdChjaGFuZ2UudGV4dCkubGVuZ3RoICsgKHNhbWVMaW5lID8gc3RhcnRDaCA6IDApO1xcbiAgICBpZiAoZmlyc3QpIHtcXG4gICAgICAvLyBGaXggdXAgLnRvIHByb3BlcnRpZXMgb2YgZmlyc3RcXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZpcnN0Lmxlbmd0aDsgKytpKSB7XFxuICAgICAgICB2YXIgc3BhbiA9IGZpcnN0W2ldO1xcbiAgICAgICAgaWYgKHNwYW4udG8gPT0gbnVsbCkge1xcbiAgICAgICAgICB2YXIgZm91bmQgPSBnZXRNYXJrZWRTcGFuRm9yKGxhc3QsIHNwYW4ubWFya2VyKTtcXG4gICAgICAgICAgaWYgKCFmb3VuZCkgc3Bhbi50byA9IHN0YXJ0Q2g7XFxuICAgICAgICAgIGVsc2UgaWYgKHNhbWVMaW5lKSBzcGFuLnRvID0gZm91bmQudG8gPT0gbnVsbCA/IG51bGwgOiBmb3VuZC50byArIG9mZnNldDtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIH1cXG4gICAgaWYgKGxhc3QpIHtcXG4gICAgICAvLyBGaXggdXAgLmZyb20gaW4gbGFzdCAob3IgbW92ZSB0aGVtIGludG8gZmlyc3QgaW4gY2FzZSBvZiBzYW1lTGluZSlcXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxhc3QubGVuZ3RoOyArK2kpIHtcXG4gICAgICAgIHZhciBzcGFuID0gbGFzdFtpXTtcXG4gICAgICAgIGlmIChzcGFuLnRvICE9IG51bGwpIHNwYW4udG8gKz0gb2Zmc2V0O1xcbiAgICAgICAgaWYgKHNwYW4uZnJvbSA9PSBudWxsKSB7XFxuICAgICAgICAgIHZhciBmb3VuZCA9IGdldE1hcmtlZFNwYW5Gb3IoZmlyc3QsIHNwYW4ubWFya2VyKTtcXG4gICAgICAgICAgaWYgKCFmb3VuZCkge1xcbiAgICAgICAgICAgIHNwYW4uZnJvbSA9IG9mZnNldDtcXG4gICAgICAgICAgICBpZiAoc2FtZUxpbmUpIChmaXJzdCB8fCAoZmlyc3QgPSBbXSkpLnB1c2goc3Bhbik7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIHNwYW4uZnJvbSArPSBvZmZzZXQ7XFxuICAgICAgICAgIGlmIChzYW1lTGluZSkgKGZpcnN0IHx8IChmaXJzdCA9IFtdKSkucHVzaChzcGFuKTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIH1cXG4gICAgLy8gTWFrZSBzdXJlIHdlIGRpZG4ndCBjcmVhdGUgYW55IHplcm8tbGVuZ3RoIHNwYW5zXFxuICAgIGlmIChmaXJzdCkgZmlyc3QgPSBjbGVhckVtcHR5U3BhbnMoZmlyc3QpO1xcbiAgICBpZiAobGFzdCAmJiBsYXN0ICE9IGZpcnN0KSBsYXN0ID0gY2xlYXJFbXB0eVNwYW5zKGxhc3QpO1xcblxcbiAgICB2YXIgbmV3TWFya2VycyA9IFtmaXJzdF07XFxuICAgIGlmICghc2FtZUxpbmUpIHtcXG4gICAgICAvLyBGaWxsIGdhcCB3aXRoIHdob2xlLWxpbmUtc3BhbnNcXG4gICAgICB2YXIgZ2FwID0gY2hhbmdlLnRleHQubGVuZ3RoIC0gMiwgZ2FwTWFya2VycztcXG4gICAgICBpZiAoZ2FwID4gMCAmJiBmaXJzdClcXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmlyc3QubGVuZ3RoOyArK2kpXFxuICAgICAgICAgIGlmIChmaXJzdFtpXS50byA9PSBudWxsKVxcbiAgICAgICAgICAgIChnYXBNYXJrZXJzIHx8IChnYXBNYXJrZXJzID0gW10pKS5wdXNoKG5ldyBNYXJrZWRTcGFuKGZpcnN0W2ldLm1hcmtlciwgbnVsbCwgbnVsbCkpO1xcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ2FwOyArK2kpXFxuICAgICAgICBuZXdNYXJrZXJzLnB1c2goZ2FwTWFya2Vycyk7XFxuICAgICAgbmV3TWFya2Vycy5wdXNoKGxhc3QpO1xcbiAgICB9XFxuICAgIHJldHVybiBuZXdNYXJrZXJzO1xcbiAgfVxcblxcbiAgLy8gUmVtb3ZlIHNwYW5zIHRoYXQgYXJlIGVtcHR5IGFuZCBkb24ndCBoYXZlIGEgY2xlYXJXaGVuRW1wdHlcXG4gIC8vIG9wdGlvbiBvZiBmYWxzZS5cXG4gIGZ1bmN0aW9uIGNsZWFyRW1wdHlTcGFucyhzcGFucykge1xcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNwYW5zLmxlbmd0aDsgKytpKSB7XFxuICAgICAgdmFyIHNwYW4gPSBzcGFuc1tpXTtcXG4gICAgICBpZiAoc3Bhbi5mcm9tICE9IG51bGwgJiYgc3Bhbi5mcm9tID09IHNwYW4udG8gJiYgc3Bhbi5tYXJrZXIuY2xlYXJXaGVuRW1wdHkgIT09IGZhbHNlKVxcbiAgICAgICAgc3BhbnMuc3BsaWNlKGktLSwgMSk7XFxuICAgIH1cXG4gICAgaWYgKCFzcGFucy5sZW5ndGgpIHJldHVybiBudWxsO1xcbiAgICByZXR1cm4gc3BhbnM7XFxuICB9XFxuXFxuICAvLyBVc2VkIGZvciB1bi9yZS1kb2luZyBjaGFuZ2VzIGZyb20gdGhlIGhpc3RvcnkuIENvbWJpbmVzIHRoZVxcbiAgLy8gcmVzdWx0IG9mIGNvbXB1dGluZyB0aGUgZXhpc3Rpbmcgc3BhbnMgd2l0aCB0aGUgc2V0IG9mIHNwYW5zIHRoYXRcXG4gIC8vIGV4aXN0ZWQgaW4gdGhlIGhpc3RvcnkgKHNvIHRoYXQgZGVsZXRpbmcgYXJvdW5kIGEgc3BhbiBhbmQgdGhlblxcbiAgLy8gdW5kb2luZyBicmluZ3MgYmFjayB0aGUgc3BhbikuXFxuICBmdW5jdGlvbiBtZXJnZU9sZFNwYW5zKGRvYywgY2hhbmdlKSB7XFxuICAgIHZhciBvbGQgPSBnZXRPbGRTcGFucyhkb2MsIGNoYW5nZSk7XFxuICAgIHZhciBzdHJldGNoZWQgPSBzdHJldGNoU3BhbnNPdmVyQ2hhbmdlKGRvYywgY2hhbmdlKTtcXG4gICAgaWYgKCFvbGQpIHJldHVybiBzdHJldGNoZWQ7XFxuICAgIGlmICghc3RyZXRjaGVkKSByZXR1cm4gb2xkO1xcblxcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9sZC5sZW5ndGg7ICsraSkge1xcbiAgICAgIHZhciBvbGRDdXIgPSBvbGRbaV0sIHN0cmV0Y2hDdXIgPSBzdHJldGNoZWRbaV07XFxuICAgICAgaWYgKG9sZEN1ciAmJiBzdHJldGNoQ3VyKSB7XFxuICAgICAgICBzcGFuczogZm9yICh2YXIgaiA9IDA7IGogPCBzdHJldGNoQ3VyLmxlbmd0aDsgKytqKSB7XFxuICAgICAgICAgIHZhciBzcGFuID0gc3RyZXRjaEN1cltqXTtcXG4gICAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBvbGRDdXIubGVuZ3RoOyArK2spXFxuICAgICAgICAgICAgaWYgKG9sZEN1cltrXS5tYXJrZXIgPT0gc3Bhbi5tYXJrZXIpIGNvbnRpbnVlIHNwYW5zO1xcbiAgICAgICAgICBvbGRDdXIucHVzaChzcGFuKTtcXG4gICAgICAgIH1cXG4gICAgICB9IGVsc2UgaWYgKHN0cmV0Y2hDdXIpIHtcXG4gICAgICAgIG9sZFtpXSA9IHN0cmV0Y2hDdXI7XFxuICAgICAgfVxcbiAgICB9XFxuICAgIHJldHVybiBvbGQ7XFxuICB9XFxuXFxuICAvLyBVc2VkIHRvICdjbGlwJyBvdXQgcmVhZE9ubHkgcmFuZ2VzIHdoZW4gbWFraW5nIGEgY2hhbmdlLlxcbiAgZnVuY3Rpb24gcmVtb3ZlUmVhZE9ubHlSYW5nZXMoZG9jLCBmcm9tLCB0bykge1xcbiAgICB2YXIgbWFya2VycyA9IG51bGw7XFxuICAgIGRvYy5pdGVyKGZyb20ubGluZSwgdG8ubGluZSArIDEsIGZ1bmN0aW9uKGxpbmUpIHtcXG4gICAgICBpZiAobGluZS5tYXJrZWRTcGFucykgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lLm1hcmtlZFNwYW5zLmxlbmd0aDsgKytpKSB7XFxuICAgICAgICB2YXIgbWFyayA9IGxpbmUubWFya2VkU3BhbnNbaV0ubWFya2VyO1xcbiAgICAgICAgaWYgKG1hcmsucmVhZE9ubHkgJiYgKCFtYXJrZXJzIHx8IGluZGV4T2YobWFya2VycywgbWFyaykgPT0gLTEpKVxcbiAgICAgICAgICAobWFya2VycyB8fCAobWFya2VycyA9IFtdKSkucHVzaChtYXJrKTtcXG4gICAgICB9XFxuICAgIH0pO1xcbiAgICBpZiAoIW1hcmtlcnMpIHJldHVybiBudWxsO1xcbiAgICB2YXIgcGFydHMgPSBbe2Zyb206IGZyb20sIHRvOiB0b31dO1xcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1hcmtlcnMubGVuZ3RoOyArK2kpIHtcXG4gICAgICB2YXIgbWsgPSBtYXJrZXJzW2ldLCBtID0gbWsuZmluZCgwKTtcXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHBhcnRzLmxlbmd0aDsgKytqKSB7XFxuICAgICAgICB2YXIgcCA9IHBhcnRzW2pdO1xcbiAgICAgICAgaWYgKGNtcChwLnRvLCBtLmZyb20pIDwgMCB8fCBjbXAocC5mcm9tLCBtLnRvKSA+IDApIGNvbnRpbnVlO1xcbiAgICAgICAgdmFyIG5ld1BhcnRzID0gW2osIDFdLCBkZnJvbSA9IGNtcChwLmZyb20sIG0uZnJvbSksIGR0byA9IGNtcChwLnRvLCBtLnRvKTtcXG4gICAgICAgIGlmIChkZnJvbSA8IDAgfHwgIW1rLmluY2x1c2l2ZUxlZnQgJiYgIWRmcm9tKVxcbiAgICAgICAgICBuZXdQYXJ0cy5wdXNoKHtmcm9tOiBwLmZyb20sIHRvOiBtLmZyb219KTtcXG4gICAgICAgIGlmIChkdG8gPiAwIHx8ICFtay5pbmNsdXNpdmVSaWdodCAmJiAhZHRvKVxcbiAgICAgICAgICBuZXdQYXJ0cy5wdXNoKHtmcm9tOiBtLnRvLCB0bzogcC50b30pO1xcbiAgICAgICAgcGFydHMuc3BsaWNlLmFwcGx5KHBhcnRzLCBuZXdQYXJ0cyk7XFxuICAgICAgICBqICs9IG5ld1BhcnRzLmxlbmd0aCAtIDE7XFxuICAgICAgfVxcbiAgICB9XFxuICAgIHJldHVybiBwYXJ0cztcXG4gIH1cXG5cXG4gIC8vIENvbm5lY3Qgb3IgZGlzY29ubmVjdCBzcGFucyBmcm9tIGEgbGluZS5cXG4gIGZ1bmN0aW9uIGRldGFjaE1hcmtlZFNwYW5zKGxpbmUpIHtcXG4gICAgdmFyIHNwYW5zID0gbGluZS5tYXJrZWRTcGFucztcXG4gICAgaWYgKCFzcGFucykgcmV0dXJuO1xcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNwYW5zLmxlbmd0aDsgKytpKVxcbiAgICAgIHNwYW5zW2ldLm1hcmtlci5kZXRhY2hMaW5lKGxpbmUpO1xcbiAgICBsaW5lLm1hcmtlZFNwYW5zID0gbnVsbDtcXG4gIH1cXG4gIGZ1bmN0aW9uIGF0dGFjaE1hcmtlZFNwYW5zKGxpbmUsIHNwYW5zKSB7XFxuICAgIGlmICghc3BhbnMpIHJldHVybjtcXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzcGFucy5sZW5ndGg7ICsraSlcXG4gICAgICBzcGFuc1tpXS5tYXJrZXIuYXR0YWNoTGluZShsaW5lKTtcXG4gICAgbGluZS5tYXJrZWRTcGFucyA9IHNwYW5zO1xcbiAgfVxcblxcbiAgLy8gSGVscGVycyB1c2VkIHdoZW4gY29tcHV0aW5nIHdoaWNoIG92ZXJsYXBwaW5nIGNvbGxhcHNlZCBzcGFuXFxuICAvLyBjb3VudHMgYXMgdGhlIGxhcmdlciBvbmUuXFxuICBmdW5jdGlvbiBleHRyYUxlZnQobWFya2VyKSB7IHJldHVybiBtYXJrZXIuaW5jbHVzaXZlTGVmdCA/IC0xIDogMDsgfVxcbiAgZnVuY3Rpb24gZXh0cmFSaWdodChtYXJrZXIpIHsgcmV0dXJuIG1hcmtlci5pbmNsdXNpdmVSaWdodCA/IDEgOiAwOyB9XFxuXFxuICAvLyBSZXR1cm5zIGEgbnVtYmVyIGluZGljYXRpbmcgd2hpY2ggb2YgdHdvIG92ZXJsYXBwaW5nIGNvbGxhcHNlZFxcbiAgLy8gc3BhbnMgaXMgbGFyZ2VyIChhbmQgdGh1cyBpbmNsdWRlcyB0aGUgb3RoZXIpLiBGYWxscyBiYWNrIHRvXFxuICAvLyBjb21wYXJpbmcgaWRzIHdoZW4gdGhlIHNwYW5zIGNvdmVyIGV4YWN0bHkgdGhlIHNhbWUgcmFuZ2UuXFxuICBmdW5jdGlvbiBjb21wYXJlQ29sbGFwc2VkTWFya2VycyhhLCBiKSB7XFxuICAgIHZhciBsZW5EaWZmID0gYS5saW5lcy5sZW5ndGggLSBiLmxpbmVzLmxlbmd0aDtcXG4gICAgaWYgKGxlbkRpZmYgIT0gMCkgcmV0dXJuIGxlbkRpZmY7XFxuICAgIHZhciBhUG9zID0gYS5maW5kKCksIGJQb3MgPSBiLmZpbmQoKTtcXG4gICAgdmFyIGZyb21DbXAgPSBjbXAoYVBvcy5mcm9tLCBiUG9zLmZyb20pIHx8IGV4dHJhTGVmdChhKSAtIGV4dHJhTGVmdChiKTtcXG4gICAgaWYgKGZyb21DbXApIHJldHVybiAtZnJvbUNtcDtcXG4gICAgdmFyIHRvQ21wID0gY21wKGFQb3MudG8sIGJQb3MudG8pIHx8IGV4dHJhUmlnaHQoYSkgLSBleHRyYVJpZ2h0KGIpO1xcbiAgICBpZiAodG9DbXApIHJldHVybiB0b0NtcDtcXG4gICAgcmV0dXJuIGIuaWQgLSBhLmlkO1xcbiAgfVxcblxcbiAgLy8gRmluZCBvdXQgd2hldGhlciBhIGxpbmUgZW5kcyBvciBzdGFydHMgaW4gYSBjb2xsYXBzZWQgc3Bhbi4gSWZcXG4gIC8vIHNvLCByZXR1cm4gdGhlIG1hcmtlciBmb3IgdGhhdCBzcGFuLlxcbiAgZnVuY3Rpb24gY29sbGFwc2VkU3BhbkF0U2lkZShsaW5lLCBzdGFydCkge1xcbiAgICB2YXIgc3BzID0gc2F3Q29sbGFwc2VkU3BhbnMgJiYgbGluZS5tYXJrZWRTcGFucywgZm91bmQ7XFxuICAgIGlmIChzcHMpIGZvciAodmFyIHNwLCBpID0gMDsgaSA8IHNwcy5sZW5ndGg7ICsraSkge1xcbiAgICAgIHNwID0gc3BzW2ldO1xcbiAgICAgIGlmIChzcC5tYXJrZXIuY29sbGFwc2VkICYmIChzdGFydCA/IHNwLmZyb20gOiBzcC50bykgPT0gbnVsbCAmJlxcbiAgICAgICAgICAoIWZvdW5kIHx8IGNvbXBhcmVDb2xsYXBzZWRNYXJrZXJzKGZvdW5kLCBzcC5tYXJrZXIpIDwgMCkpXFxuICAgICAgICBmb3VuZCA9IHNwLm1hcmtlcjtcXG4gICAgfVxcbiAgICByZXR1cm4gZm91bmQ7XFxuICB9XFxuICBmdW5jdGlvbiBjb2xsYXBzZWRTcGFuQXRTdGFydChsaW5lKSB7IHJldHVybiBjb2xsYXBzZWRTcGFuQXRTaWRlKGxpbmUsIHRydWUpOyB9XFxuICBmdW5jdGlvbiBjb2xsYXBzZWRTcGFuQXRFbmQobGluZSkgeyByZXR1cm4gY29sbGFwc2VkU3BhbkF0U2lkZShsaW5lLCBmYWxzZSk7IH1cXG5cXG4gIC8vIFRlc3Qgd2hldGhlciB0aGVyZSBleGlzdHMgYSBjb2xsYXBzZWQgc3BhbiB0aGF0IHBhcnRpYWxseVxcbiAgLy8gb3ZlcmxhcHMgKGNvdmVycyB0aGUgc3RhcnQgb3IgZW5kLCBidXQgbm90IGJvdGgpIG9mIGEgbmV3IHNwYW4uXFxuICAvLyBTdWNoIG92ZXJsYXAgaXMgbm90IGFsbG93ZWQuXFxuICBmdW5jdGlvbiBjb25mbGljdGluZ0NvbGxhcHNlZFJhbmdlKGRvYywgbGluZU5vLCBmcm9tLCB0bywgbWFya2VyKSB7XFxuICAgIHZhciBsaW5lID0gZ2V0TGluZShkb2MsIGxpbmVObyk7XFxuICAgIHZhciBzcHMgPSBzYXdDb2xsYXBzZWRTcGFucyAmJiBsaW5lLm1hcmtlZFNwYW5zO1xcbiAgICBpZiAoc3BzKSBmb3IgKHZhciBpID0gMDsgaSA8IHNwcy5sZW5ndGg7ICsraSkge1xcbiAgICAgIHZhciBzcCA9IHNwc1tpXTtcXG4gICAgICBpZiAoIXNwLm1hcmtlci5jb2xsYXBzZWQpIGNvbnRpbnVlO1xcbiAgICAgIHZhciBmb3VuZCA9IHNwLm1hcmtlci5maW5kKDApO1xcbiAgICAgIHZhciBmcm9tQ21wID0gY21wKGZvdW5kLmZyb20sIGZyb20pIHx8IGV4dHJhTGVmdChzcC5tYXJrZXIpIC0gZXh0cmFMZWZ0KG1hcmtlcik7XFxuICAgICAgdmFyIHRvQ21wID0gY21wKGZvdW5kLnRvLCB0bykgfHwgZXh0cmFSaWdodChzcC5tYXJrZXIpIC0gZXh0cmFSaWdodChtYXJrZXIpO1xcbiAgICAgIGlmIChmcm9tQ21wID49IDAgJiYgdG9DbXAgPD0gMCB8fCBmcm9tQ21wIDw9IDAgJiYgdG9DbXAgPj0gMCkgY29udGludWU7XFxuICAgICAgaWYgKGZyb21DbXAgPD0gMCAmJiAoc3AubWFya2VyLmluY2x1c2l2ZVJpZ2h0ICYmIG1hcmtlci5pbmNsdXNpdmVMZWZ0ID8gY21wKGZvdW5kLnRvLCBmcm9tKSA+PSAwIDogY21wKGZvdW5kLnRvLCBmcm9tKSA+IDApIHx8XFxuICAgICAgICAgIGZyb21DbXAgPj0gMCAmJiAoc3AubWFya2VyLmluY2x1c2l2ZVJpZ2h0ICYmIG1hcmtlci5pbmNsdXNpdmVMZWZ0ID8gY21wKGZvdW5kLmZyb20sIHRvKSA8PSAwIDogY21wKGZvdW5kLmZyb20sIHRvKSA8IDApKVxcbiAgICAgICAgcmV0dXJuIHRydWU7XFxuICAgIH1cXG4gIH1cXG5cXG4gIC8vIEEgdmlzdWFsIGxpbmUgaXMgYSBsaW5lIGFzIGRyYXduIG9uIHRoZSBzY3JlZW4uIEZvbGRpbmcsIGZvclxcbiAgLy8gZXhhbXBsZSwgY2FuIGNhdXNlIG11bHRpcGxlIGxvZ2ljYWwgbGluZXMgdG8gYXBwZWFyIG9uIHRoZSBzYW1lXFxuICAvLyB2aXN1YWwgbGluZS4gVGhpcyBmaW5kcyB0aGUgc3RhcnQgb2YgdGhlIHZpc3VhbCBsaW5lIHRoYXQgdGhlXFxuICAvLyBnaXZlbiBsaW5lIGlzIHBhcnQgb2YgKHVzdWFsbHkgdGhhdCBpcyB0aGUgbGluZSBpdHNlbGYpLlxcbiAgZnVuY3Rpb24gdmlzdWFsTGluZShsaW5lKSB7XFxuICAgIHZhciBtZXJnZWQ7XFxuICAgIHdoaWxlIChtZXJnZWQgPSBjb2xsYXBzZWRTcGFuQXRTdGFydChsaW5lKSlcXG4gICAgICBsaW5lID0gbWVyZ2VkLmZpbmQoLTEsIHRydWUpLmxpbmU7XFxuICAgIHJldHVybiBsaW5lO1xcbiAgfVxcblxcbiAgLy8gUmV0dXJucyBhbiBhcnJheSBvZiBsb2dpY2FsIGxpbmVzIHRoYXQgY29udGludWUgdGhlIHZpc3VhbCBsaW5lXFxuICAvLyBzdGFydGVkIGJ5IHRoZSBhcmd1bWVudCwgb3IgdW5kZWZpbmVkIGlmIHRoZXJlIGFyZSBubyBzdWNoIGxpbmVzLlxcbiAgZnVuY3Rpb24gdmlzdWFsTGluZUNvbnRpbnVlZChsaW5lKSB7XFxuICAgIHZhciBtZXJnZWQsIGxpbmVzO1xcbiAgICB3aGlsZSAobWVyZ2VkID0gY29sbGFwc2VkU3BhbkF0RW5kKGxpbmUpKSB7XFxuICAgICAgbGluZSA9IG1lcmdlZC5maW5kKDEsIHRydWUpLmxpbmU7XFxuICAgICAgKGxpbmVzIHx8IChsaW5lcyA9IFtdKSkucHVzaChsaW5lKTtcXG4gICAgfVxcbiAgICByZXR1cm4gbGluZXM7XFxuICB9XFxuXFxuICAvLyBHZXQgdGhlIGxpbmUgbnVtYmVyIG9mIHRoZSBzdGFydCBvZiB0aGUgdmlzdWFsIGxpbmUgdGhhdCB0aGVcXG4gIC8vIGdpdmVuIGxpbmUgbnVtYmVyIGlzIHBhcnQgb2YuXFxuICBmdW5jdGlvbiB2aXN1YWxMaW5lTm8oZG9jLCBsaW5lTikge1xcbiAgICB2YXIgbGluZSA9IGdldExpbmUoZG9jLCBsaW5lTiksIHZpcyA9IHZpc3VhbExpbmUobGluZSk7XFxuICAgIGlmIChsaW5lID09IHZpcykgcmV0dXJuIGxpbmVOO1xcbiAgICByZXR1cm4gbGluZU5vKHZpcyk7XFxuICB9XFxuICAvLyBHZXQgdGhlIGxpbmUgbnVtYmVyIG9mIHRoZSBzdGFydCBvZiB0aGUgbmV4dCB2aXN1YWwgbGluZSBhZnRlclxcbiAgLy8gdGhlIGdpdmVuIGxpbmUuXFxuICBmdW5jdGlvbiB2aXN1YWxMaW5lRW5kTm8oZG9jLCBsaW5lTikge1xcbiAgICBpZiAobGluZU4gPiBkb2MubGFzdExpbmUoKSkgcmV0dXJuIGxpbmVOO1xcbiAgICB2YXIgbGluZSA9IGdldExpbmUoZG9jLCBsaW5lTiksIG1lcmdlZDtcXG4gICAgaWYgKCFsaW5lSXNIaWRkZW4oZG9jLCBsaW5lKSkgcmV0dXJuIGxpbmVOO1xcbiAgICB3aGlsZSAobWVyZ2VkID0gY29sbGFwc2VkU3BhbkF0RW5kKGxpbmUpKVxcbiAgICAgIGxpbmUgPSBtZXJnZWQuZmluZCgxLCB0cnVlKS5saW5lO1xcbiAgICByZXR1cm4gbGluZU5vKGxpbmUpICsgMTtcXG4gIH1cXG5cXG4gIC8vIENvbXB1dGUgd2hldGhlciBhIGxpbmUgaXMgaGlkZGVuLiBMaW5lcyBjb3VudCBhcyBoaWRkZW4gd2hlbiB0aGV5XFxuICAvLyBhcmUgcGFydCBvZiBhIHZpc3VhbCBsaW5lIHRoYXQgc3RhcnRzIHdpdGggYW5vdGhlciBsaW5lLCBvciB3aGVuXFxuICAvLyB0aGV5IGFyZSBlbnRpcmVseSBjb3ZlcmVkIGJ5IGNvbGxhcHNlZCwgbm9uLXdpZGdldCBzcGFuLlxcbiAgZnVuY3Rpb24gbGluZUlzSGlkZGVuKGRvYywgbGluZSkge1xcbiAgICB2YXIgc3BzID0gc2F3Q29sbGFwc2VkU3BhbnMgJiYgbGluZS5tYXJrZWRTcGFucztcXG4gICAgaWYgKHNwcykgZm9yICh2YXIgc3AsIGkgPSAwOyBpIDwgc3BzLmxlbmd0aDsgKytpKSB7XFxuICAgICAgc3AgPSBzcHNbaV07XFxuICAgICAgaWYgKCFzcC5tYXJrZXIuY29sbGFwc2VkKSBjb250aW51ZTtcXG4gICAgICBpZiAoc3AuZnJvbSA9PSBudWxsKSByZXR1cm4gdHJ1ZTtcXG4gICAgICBpZiAoc3AubWFya2VyLndpZGdldE5vZGUpIGNvbnRpbnVlO1xcbiAgICAgIGlmIChzcC5mcm9tID09IDAgJiYgc3AubWFya2VyLmluY2x1c2l2ZUxlZnQgJiYgbGluZUlzSGlkZGVuSW5uZXIoZG9jLCBsaW5lLCBzcCkpXFxuICAgICAgICByZXR1cm4gdHJ1ZTtcXG4gICAgfVxcbiAgfVxcbiAgZnVuY3Rpb24gbGluZUlzSGlkZGVuSW5uZXIoZG9jLCBsaW5lLCBzcGFuKSB7XFxuICAgIGlmIChzcGFuLnRvID09IG51bGwpIHtcXG4gICAgICB2YXIgZW5kID0gc3Bhbi5tYXJrZXIuZmluZCgxLCB0cnVlKTtcXG4gICAgICByZXR1cm4gbGluZUlzSGlkZGVuSW5uZXIoZG9jLCBlbmQubGluZSwgZ2V0TWFya2VkU3BhbkZvcihlbmQubGluZS5tYXJrZWRTcGFucywgc3Bhbi5tYXJrZXIpKTtcXG4gICAgfVxcbiAgICBpZiAoc3Bhbi5tYXJrZXIuaW5jbHVzaXZlUmlnaHQgJiYgc3Bhbi50byA9PSBsaW5lLnRleHQubGVuZ3RoKVxcbiAgICAgIHJldHVybiB0cnVlO1xcbiAgICBmb3IgKHZhciBzcCwgaSA9IDA7IGkgPCBsaW5lLm1hcmtlZFNwYW5zLmxlbmd0aDsgKytpKSB7XFxuICAgICAgc3AgPSBsaW5lLm1hcmtlZFNwYW5zW2ldO1xcbiAgICAgIGlmIChzcC5tYXJrZXIuY29sbGFwc2VkICYmICFzcC5tYXJrZXIud2lkZ2V0Tm9kZSAmJiBzcC5mcm9tID09IHNwYW4udG8gJiZcXG4gICAgICAgICAgKHNwLnRvID09IG51bGwgfHwgc3AudG8gIT0gc3Bhbi5mcm9tKSAmJlxcbiAgICAgICAgICAoc3AubWFya2VyLmluY2x1c2l2ZUxlZnQgfHwgc3Bhbi5tYXJrZXIuaW5jbHVzaXZlUmlnaHQpICYmXFxuICAgICAgICAgIGxpbmVJc0hpZGRlbklubmVyKGRvYywgbGluZSwgc3ApKSByZXR1cm4gdHJ1ZTtcXG4gICAgfVxcbiAgfVxcblxcbiAgLy8gTElORSBXSURHRVRTXFxuXFxuICAvLyBMaW5lIHdpZGdldHMgYXJlIGJsb2NrIGVsZW1lbnRzIGRpc3BsYXllZCBhYm92ZSBvciBiZWxvdyBhIGxpbmUuXFxuXFxuICB2YXIgTGluZVdpZGdldCA9IENvZGVNaXJyb3IuTGluZVdpZGdldCA9IGZ1bmN0aW9uKGRvYywgbm9kZSwgb3B0aW9ucykge1xcbiAgICBpZiAob3B0aW9ucykgZm9yICh2YXIgb3B0IGluIG9wdGlvbnMpIGlmIChvcHRpb25zLmhhc093blByb3BlcnR5KG9wdCkpXFxuICAgICAgdGhpc1tvcHRdID0gb3B0aW9uc1tvcHRdO1xcbiAgICB0aGlzLmRvYyA9IGRvYztcXG4gICAgdGhpcy5ub2RlID0gbm9kZTtcXG4gIH07XFxuICBldmVudE1peGluKExpbmVXaWRnZXQpO1xcblxcbiAgZnVuY3Rpb24gYWRqdXN0U2Nyb2xsV2hlbkFib3ZlVmlzaWJsZShjbSwgbGluZSwgZGlmZikge1xcbiAgICBpZiAoaGVpZ2h0QXRMaW5lKGxpbmUpIDwgKChjbS5jdXJPcCAmJiBjbS5jdXJPcC5zY3JvbGxUb3ApIHx8IGNtLmRvYy5zY3JvbGxUb3ApKVxcbiAgICAgIGFkZFRvU2Nyb2xsUG9zKGNtLCBudWxsLCBkaWZmKTtcXG4gIH1cXG5cXG4gIExpbmVXaWRnZXQucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24oKSB7XFxuICAgIHZhciBjbSA9IHRoaXMuZG9jLmNtLCB3cyA9IHRoaXMubGluZS53aWRnZXRzLCBsaW5lID0gdGhpcy5saW5lLCBubyA9IGxpbmVObyhsaW5lKTtcXG4gICAgaWYgKG5vID09IG51bGwgfHwgIXdzKSByZXR1cm47XFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgd3MubGVuZ3RoOyArK2kpIGlmICh3c1tpXSA9PSB0aGlzKSB3cy5zcGxpY2UoaS0tLCAxKTtcXG4gICAgaWYgKCF3cy5sZW5ndGgpIGxpbmUud2lkZ2V0cyA9IG51bGw7XFxuICAgIHZhciBoZWlnaHQgPSB3aWRnZXRIZWlnaHQodGhpcyk7XFxuICAgIHVwZGF0ZUxpbmVIZWlnaHQobGluZSwgTWF0aC5tYXgoMCwgbGluZS5oZWlnaHQgLSBoZWlnaHQpKTtcXG4gICAgaWYgKGNtKSBydW5Jbk9wKGNtLCBmdW5jdGlvbigpIHtcXG4gICAgICBhZGp1c3RTY3JvbGxXaGVuQWJvdmVWaXNpYmxlKGNtLCBsaW5lLCAtaGVpZ2h0KTtcXG4gICAgICByZWdMaW5lQ2hhbmdlKGNtLCBubywgXFxcIndpZGdldFxcXCIpO1xcbiAgICB9KTtcXG4gIH07XFxuICBMaW5lV2lkZ2V0LnByb3RvdHlwZS5jaGFuZ2VkID0gZnVuY3Rpb24oKSB7XFxuICAgIHZhciBvbGRIID0gdGhpcy5oZWlnaHQsIGNtID0gdGhpcy5kb2MuY20sIGxpbmUgPSB0aGlzLmxpbmU7XFxuICAgIHRoaXMuaGVpZ2h0ID0gbnVsbDtcXG4gICAgdmFyIGRpZmYgPSB3aWRnZXRIZWlnaHQodGhpcykgLSBvbGRIO1xcbiAgICBpZiAoIWRpZmYpIHJldHVybjtcXG4gICAgdXBkYXRlTGluZUhlaWdodChsaW5lLCBsaW5lLmhlaWdodCArIGRpZmYpO1xcbiAgICBpZiAoY20pIHJ1bkluT3AoY20sIGZ1bmN0aW9uKCkge1xcbiAgICAgIGNtLmN1ck9wLmZvcmNlVXBkYXRlID0gdHJ1ZTtcXG4gICAgICBhZGp1c3RTY3JvbGxXaGVuQWJvdmVWaXNpYmxlKGNtLCBsaW5lLCBkaWZmKTtcXG4gICAgfSk7XFxuICB9O1xcblxcbiAgZnVuY3Rpb24gd2lkZ2V0SGVpZ2h0KHdpZGdldCkge1xcbiAgICBpZiAod2lkZ2V0LmhlaWdodCAhPSBudWxsKSByZXR1cm4gd2lkZ2V0LmhlaWdodDtcXG4gICAgdmFyIGNtID0gd2lkZ2V0LmRvYy5jbTtcXG4gICAgaWYgKCFjbSkgcmV0dXJuIDA7XFxuICAgIGlmICghY29udGFpbnMoZG9jdW1lbnQuYm9keSwgd2lkZ2V0Lm5vZGUpKSB7XFxuICAgICAgdmFyIHBhcmVudFN0eWxlID0gXFxcInBvc2l0aW9uOiByZWxhdGl2ZTtcXFwiO1xcbiAgICAgIGlmICh3aWRnZXQuY292ZXJHdXR0ZXIpXFxuICAgICAgICBwYXJlbnRTdHlsZSArPSBcXFwibWFyZ2luLWxlZnQ6IC1cXFwiICsgY20uZGlzcGxheS5ndXR0ZXJzLm9mZnNldFdpZHRoICsgXFxcInB4O1xcXCI7XFxuICAgICAgaWYgKHdpZGdldC5ub0hTY3JvbGwpXFxuICAgICAgICBwYXJlbnRTdHlsZSArPSBcXFwid2lkdGg6IFxcXCIgKyBjbS5kaXNwbGF5LndyYXBwZXIuY2xpZW50V2lkdGggKyBcXFwicHg7XFxcIjtcXG4gICAgICByZW1vdmVDaGlsZHJlbkFuZEFkZChjbS5kaXNwbGF5Lm1lYXN1cmUsIGVsdChcXFwiZGl2XFxcIiwgW3dpZGdldC5ub2RlXSwgbnVsbCwgcGFyZW50U3R5bGUpKTtcXG4gICAgfVxcbiAgICByZXR1cm4gd2lkZ2V0LmhlaWdodCA9IHdpZGdldC5ub2RlLnBhcmVudE5vZGUub2Zmc2V0SGVpZ2h0O1xcbiAgfVxcblxcbiAgZnVuY3Rpb24gYWRkTGluZVdpZGdldChkb2MsIGhhbmRsZSwgbm9kZSwgb3B0aW9ucykge1xcbiAgICB2YXIgd2lkZ2V0ID0gbmV3IExpbmVXaWRnZXQoZG9jLCBub2RlLCBvcHRpb25zKTtcXG4gICAgdmFyIGNtID0gZG9jLmNtO1xcbiAgICBpZiAoY20gJiYgd2lkZ2V0Lm5vSFNjcm9sbCkgY20uZGlzcGxheS5hbGlnbldpZGdldHMgPSB0cnVlO1xcbiAgICBjaGFuZ2VMaW5lKGRvYywgaGFuZGxlLCBcXFwid2lkZ2V0XFxcIiwgZnVuY3Rpb24obGluZSkge1xcbiAgICAgIHZhciB3aWRnZXRzID0gbGluZS53aWRnZXRzIHx8IChsaW5lLndpZGdldHMgPSBbXSk7XFxuICAgICAgaWYgKHdpZGdldC5pbnNlcnRBdCA9PSBudWxsKSB3aWRnZXRzLnB1c2god2lkZ2V0KTtcXG4gICAgICBlbHNlIHdpZGdldHMuc3BsaWNlKE1hdGgubWluKHdpZGdldHMubGVuZ3RoIC0gMSwgTWF0aC5tYXgoMCwgd2lkZ2V0Lmluc2VydEF0KSksIDAsIHdpZGdldCk7XFxuICAgICAgd2lkZ2V0LmxpbmUgPSBsaW5lO1xcbiAgICAgIGlmIChjbSAmJiAhbGluZUlzSGlkZGVuKGRvYywgbGluZSkpIHtcXG4gICAgICAgIHZhciBhYm92ZVZpc2libGUgPSBoZWlnaHRBdExpbmUobGluZSkgPCBkb2Muc2Nyb2xsVG9wO1xcbiAgICAgICAgdXBkYXRlTGluZUhlaWdodChsaW5lLCBsaW5lLmhlaWdodCArIHdpZGdldEhlaWdodCh3aWRnZXQpKTtcXG4gICAgICAgIGlmIChhYm92ZVZpc2libGUpIGFkZFRvU2Nyb2xsUG9zKGNtLCBudWxsLCB3aWRnZXQuaGVpZ2h0KTtcXG4gICAgICAgIGNtLmN1ck9wLmZvcmNlVXBkYXRlID0gdHJ1ZTtcXG4gICAgICB9XFxuICAgICAgcmV0dXJuIHRydWU7XFxuICAgIH0pO1xcbiAgICByZXR1cm4gd2lkZ2V0O1xcbiAgfVxcblxcbiAgLy8gTElORSBEQVRBIFNUUlVDVFVSRVxcblxcbiAgLy8gTGluZSBvYmplY3RzLiBUaGVzZSBob2xkIHN0YXRlIHJlbGF0ZWQgdG8gYSBsaW5lLCBpbmNsdWRpbmdcXG4gIC8vIGhpZ2hsaWdodGluZyBpbmZvICh0aGUgc3R5bGVzIGFycmF5KS5cXG4gIHZhciBMaW5lID0gQ29kZU1pcnJvci5MaW5lID0gZnVuY3Rpb24odGV4dCwgbWFya2VkU3BhbnMsIGVzdGltYXRlSGVpZ2h0KSB7XFxuICAgIHRoaXMudGV4dCA9IHRleHQ7XFxuICAgIGF0dGFjaE1hcmtlZFNwYW5zKHRoaXMsIG1hcmtlZFNwYW5zKTtcXG4gICAgdGhpcy5oZWlnaHQgPSBlc3RpbWF0ZUhlaWdodCA/IGVzdGltYXRlSGVpZ2h0KHRoaXMpIDogMTtcXG4gIH07XFxuICBldmVudE1peGluKExpbmUpO1xcbiAgTGluZS5wcm90b3R5cGUubGluZU5vID0gZnVuY3Rpb24oKSB7IHJldHVybiBsaW5lTm8odGhpcyk7IH07XFxuXFxuICAvLyBDaGFuZ2UgdGhlIGNvbnRlbnQgKHRleHQsIG1hcmtlcnMpIG9mIGEgbGluZS4gQXV0b21hdGljYWxseVxcbiAgLy8gaW52YWxpZGF0ZXMgY2FjaGVkIGluZm9ybWF0aW9uIGFuZCB0cmllcyB0byByZS1lc3RpbWF0ZSB0aGVcXG4gIC8vIGxpbmUncyBoZWlnaHQuXFxuICBmdW5jdGlvbiB1cGRhdGVMaW5lKGxpbmUsIHRleHQsIG1hcmtlZFNwYW5zLCBlc3RpbWF0ZUhlaWdodCkge1xcbiAgICBsaW5lLnRleHQgPSB0ZXh0O1xcbiAgICBpZiAobGluZS5zdGF0ZUFmdGVyKSBsaW5lLnN0YXRlQWZ0ZXIgPSBudWxsO1xcbiAgICBpZiAobGluZS5zdHlsZXMpIGxpbmUuc3R5bGVzID0gbnVsbDtcXG4gICAgaWYgKGxpbmUub3JkZXIgIT0gbnVsbCkgbGluZS5vcmRlciA9IG51bGw7XFxuICAgIGRldGFjaE1hcmtlZFNwYW5zKGxpbmUpO1xcbiAgICBhdHRhY2hNYXJrZWRTcGFucyhsaW5lLCBtYXJrZWRTcGFucyk7XFxuICAgIHZhciBlc3RIZWlnaHQgPSBlc3RpbWF0ZUhlaWdodCA/IGVzdGltYXRlSGVpZ2h0KGxpbmUpIDogMTtcXG4gICAgaWYgKGVzdEhlaWdodCAhPSBsaW5lLmhlaWdodCkgdXBkYXRlTGluZUhlaWdodChsaW5lLCBlc3RIZWlnaHQpO1xcbiAgfVxcblxcbiAgLy8gRGV0YWNoIGEgbGluZSBmcm9tIHRoZSBkb2N1bWVudCB0cmVlIGFuZCBpdHMgbWFya2Vycy5cXG4gIGZ1bmN0aW9uIGNsZWFuVXBMaW5lKGxpbmUpIHtcXG4gICAgbGluZS5wYXJlbnQgPSBudWxsO1xcbiAgICBkZXRhY2hNYXJrZWRTcGFucyhsaW5lKTtcXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIGV4dHJhY3RMaW5lQ2xhc3Nlcyh0eXBlLCBvdXRwdXQpIHtcXG4gICAgaWYgKHR5cGUpIGZvciAoOzspIHtcXG4gICAgICB2YXIgbGluZUNsYXNzID0gdHlwZS5tYXRjaCgvKD86XnxcXFxccyspbGluZS0oYmFja2dyb3VuZC0pPyhcXFxcUyspLyk7XFxuICAgICAgaWYgKCFsaW5lQ2xhc3MpIGJyZWFrO1xcbiAgICAgIHR5cGUgPSB0eXBlLnNsaWNlKDAsIGxpbmVDbGFzcy5pbmRleCkgKyB0eXBlLnNsaWNlKGxpbmVDbGFzcy5pbmRleCArIGxpbmVDbGFzc1swXS5sZW5ndGgpO1xcbiAgICAgIHZhciBwcm9wID0gbGluZUNsYXNzWzFdID8gXFxcImJnQ2xhc3NcXFwiIDogXFxcInRleHRDbGFzc1xcXCI7XFxuICAgICAgaWYgKG91dHB1dFtwcm9wXSA9PSBudWxsKVxcbiAgICAgICAgb3V0cHV0W3Byb3BdID0gbGluZUNsYXNzWzJdO1xcbiAgICAgIGVsc2UgaWYgKCEobmV3IFJlZ0V4cChcXFwiKD86XnxcXFxccylcXFwiICsgbGluZUNsYXNzWzJdICsgXFxcIig/OiR8XFxcXHMpXFxcIikpLnRlc3Qob3V0cHV0W3Byb3BdKSlcXG4gICAgICAgIG91dHB1dFtwcm9wXSArPSBcXFwiIFxcXCIgKyBsaW5lQ2xhc3NbMl07XFxuICAgIH1cXG4gICAgcmV0dXJuIHR5cGU7XFxuICB9XFxuXFxuICBmdW5jdGlvbiBjYWxsQmxhbmtMaW5lKG1vZGUsIHN0YXRlKSB7XFxuICAgIGlmIChtb2RlLmJsYW5rTGluZSkgcmV0dXJuIG1vZGUuYmxhbmtMaW5lKHN0YXRlKTtcXG4gICAgaWYgKCFtb2RlLmlubmVyTW9kZSkgcmV0dXJuO1xcbiAgICB2YXIgaW5uZXIgPSBDb2RlTWlycm9yLmlubmVyTW9kZShtb2RlLCBzdGF0ZSk7XFxuICAgIGlmIChpbm5lci5tb2RlLmJsYW5rTGluZSkgcmV0dXJuIGlubmVyLm1vZGUuYmxhbmtMaW5lKGlubmVyLnN0YXRlKTtcXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIHJlYWRUb2tlbihtb2RlLCBzdHJlYW0sIHN0YXRlLCBpbm5lcikge1xcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IDEwOyBpKyspIHtcXG4gICAgICBpZiAoaW5uZXIpIGlubmVyWzBdID0gQ29kZU1pcnJvci5pbm5lck1vZGUobW9kZSwgc3RhdGUpLm1vZGU7XFxuICAgICAgdmFyIHN0eWxlID0gbW9kZS50b2tlbihzdHJlYW0sIHN0YXRlKTtcXG4gICAgICBpZiAoc3RyZWFtLnBvcyA+IHN0cmVhbS5zdGFydCkgcmV0dXJuIHN0eWxlO1xcbiAgICB9XFxuICAgIHRocm93IG5ldyBFcnJvcihcXFwiTW9kZSBcXFwiICsgbW9kZS5uYW1lICsgXFxcIiBmYWlsZWQgdG8gYWR2YW5jZSBzdHJlYW0uXFxcIik7XFxuICB9XFxuXFxuICAvLyBVdGlsaXR5IGZvciBnZXRUb2tlbkF0IGFuZCBnZXRMaW5lVG9rZW5zXFxuICBmdW5jdGlvbiB0YWtlVG9rZW4oY20sIHBvcywgcHJlY2lzZSwgYXNBcnJheSkge1xcbiAgICBmdW5jdGlvbiBnZXRPYmooY29weSkge1xcbiAgICAgIHJldHVybiB7c3RhcnQ6IHN0cmVhbS5zdGFydCwgZW5kOiBzdHJlYW0ucG9zLFxcbiAgICAgICAgICAgICAgc3RyaW5nOiBzdHJlYW0uY3VycmVudCgpLFxcbiAgICAgICAgICAgICAgdHlwZTogc3R5bGUgfHwgbnVsbCxcXG4gICAgICAgICAgICAgIHN0YXRlOiBjb3B5ID8gY29weVN0YXRlKGRvYy5tb2RlLCBzdGF0ZSkgOiBzdGF0ZX07XFxuICAgIH1cXG5cXG4gICAgdmFyIGRvYyA9IGNtLmRvYywgbW9kZSA9IGRvYy5tb2RlLCBzdHlsZTtcXG4gICAgcG9zID0gY2xpcFBvcyhkb2MsIHBvcyk7XFxuICAgIHZhciBsaW5lID0gZ2V0TGluZShkb2MsIHBvcy5saW5lKSwgc3RhdGUgPSBnZXRTdGF0ZUJlZm9yZShjbSwgcG9zLmxpbmUsIHByZWNpc2UpO1xcbiAgICB2YXIgc3RyZWFtID0gbmV3IFN0cmluZ1N0cmVhbShsaW5lLnRleHQsIGNtLm9wdGlvbnMudGFiU2l6ZSksIHRva2VucztcXG4gICAgaWYgKGFzQXJyYXkpIHRva2VucyA9IFtdO1xcbiAgICB3aGlsZSAoKGFzQXJyYXkgfHwgc3RyZWFtLnBvcyA8IHBvcy5jaCkgJiYgIXN0cmVhbS5lb2woKSkge1xcbiAgICAgIHN0cmVhbS5zdGFydCA9IHN0cmVhbS5wb3M7XFxuICAgICAgc3R5bGUgPSByZWFkVG9rZW4obW9kZSwgc3RyZWFtLCBzdGF0ZSk7XFxuICAgICAgaWYgKGFzQXJyYXkpIHRva2Vucy5wdXNoKGdldE9iaih0cnVlKSk7XFxuICAgIH1cXG4gICAgcmV0dXJuIGFzQXJyYXkgPyB0b2tlbnMgOiBnZXRPYmooKTtcXG4gIH1cXG5cXG4gIC8vIFJ1biB0aGUgZ2l2ZW4gbW9kZSdzIHBhcnNlciBvdmVyIGEgbGluZSwgY2FsbGluZyBmIGZvciBlYWNoIHRva2VuLlxcbiAgZnVuY3Rpb24gcnVuTW9kZShjbSwgdGV4dCwgbW9kZSwgc3RhdGUsIGYsIGxpbmVDbGFzc2VzLCBmb3JjZVRvRW5kKSB7XFxuICAgIHZhciBmbGF0dGVuU3BhbnMgPSBtb2RlLmZsYXR0ZW5TcGFucztcXG4gICAgaWYgKGZsYXR0ZW5TcGFucyA9PSBudWxsKSBmbGF0dGVuU3BhbnMgPSBjbS5vcHRpb25zLmZsYXR0ZW5TcGFucztcXG4gICAgdmFyIGN1clN0YXJ0ID0gMCwgY3VyU3R5bGUgPSBudWxsO1xcbiAgICB2YXIgc3RyZWFtID0gbmV3IFN0cmluZ1N0cmVhbSh0ZXh0LCBjbS5vcHRpb25zLnRhYlNpemUpLCBzdHlsZTtcXG4gICAgdmFyIGlubmVyID0gY20ub3B0aW9ucy5hZGRNb2RlQ2xhc3MgJiYgW251bGxdO1xcbiAgICBpZiAodGV4dCA9PSBcXFwiXFxcIikgZXh0cmFjdExpbmVDbGFzc2VzKGNhbGxCbGFua0xpbmUobW9kZSwgc3RhdGUpLCBsaW5lQ2xhc3Nlcyk7XFxuICAgIHdoaWxlICghc3RyZWFtLmVvbCgpKSB7XFxuICAgICAgaWYgKHN0cmVhbS5wb3MgPiBjbS5vcHRpb25zLm1heEhpZ2hsaWdodExlbmd0aCkge1xcbiAgICAgICAgZmxhdHRlblNwYW5zID0gZmFsc2U7XFxuICAgICAgICBpZiAoZm9yY2VUb0VuZCkgcHJvY2Vzc0xpbmUoY20sIHRleHQsIHN0YXRlLCBzdHJlYW0ucG9zKTtcXG4gICAgICAgIHN0cmVhbS5wb3MgPSB0ZXh0Lmxlbmd0aDtcXG4gICAgICAgIHN0eWxlID0gbnVsbDtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgc3R5bGUgPSBleHRyYWN0TGluZUNsYXNzZXMocmVhZFRva2VuKG1vZGUsIHN0cmVhbSwgc3RhdGUsIGlubmVyKSwgbGluZUNsYXNzZXMpO1xcbiAgICAgIH1cXG4gICAgICBpZiAoaW5uZXIpIHtcXG4gICAgICAgIHZhciBtTmFtZSA9IGlubmVyWzBdLm5hbWU7XFxuICAgICAgICBpZiAobU5hbWUpIHN0eWxlID0gXFxcIm0tXFxcIiArIChzdHlsZSA/IG1OYW1lICsgXFxcIiBcXFwiICsgc3R5bGUgOiBtTmFtZSk7XFxuICAgICAgfVxcbiAgICAgIGlmICghZmxhdHRlblNwYW5zIHx8IGN1clN0eWxlICE9IHN0eWxlKSB7XFxuICAgICAgICB3aGlsZSAoY3VyU3RhcnQgPCBzdHJlYW0uc3RhcnQpIHtcXG4gICAgICAgICAgY3VyU3RhcnQgPSBNYXRoLm1pbihzdHJlYW0uc3RhcnQsIGN1clN0YXJ0ICsgNTAwMCk7XFxuICAgICAgICAgIGYoY3VyU3RhcnQsIGN1clN0eWxlKTtcXG4gICAgICAgIH1cXG4gICAgICAgIGN1clN0eWxlID0gc3R5bGU7XFxuICAgICAgfVxcbiAgICAgIHN0cmVhbS5zdGFydCA9IHN0cmVhbS5wb3M7XFxuICAgIH1cXG4gICAgd2hpbGUgKGN1clN0YXJ0IDwgc3RyZWFtLnBvcykge1xcbiAgICAgIC8vIFdlYmtpdCBzZWVtcyB0byByZWZ1c2UgdG8gcmVuZGVyIHRleHQgbm9kZXMgbG9uZ2VyIHRoYW4gNTc0NDRcXG4gICAgICAvLyBjaGFyYWN0ZXJzLCBhbmQgcmV0dXJucyBpbmFjY3VyYXRlIG1lYXN1cmVtZW50cyBpbiBub2Rlc1xcbiAgICAgIC8vIHN0YXJ0aW5nIGFyb3VuZCA1MDAwIGNoYXJzLlxcbiAgICAgIHZhciBwb3MgPSBNYXRoLm1pbihzdHJlYW0ucG9zLCBjdXJTdGFydCArIDUwMDApO1xcbiAgICAgIGYocG9zLCBjdXJTdHlsZSk7XFxuICAgICAgY3VyU3RhcnQgPSBwb3M7XFxuICAgIH1cXG4gIH1cXG5cXG4gIC8vIENvbXB1dGUgYSBzdHlsZSBhcnJheSAoYW4gYXJyYXkgc3RhcnRpbmcgd2l0aCBhIG1vZGUgZ2VuZXJhdGlvblxcbiAgLy8gLS0gZm9yIGludmFsaWRhdGlvbiAtLSBmb2xsb3dlZCBieSBwYWlycyBvZiBlbmQgcG9zaXRpb25zIGFuZFxcbiAgLy8gc3R5bGUgc3RyaW5ncyksIHdoaWNoIGlzIHVzZWQgdG8gaGlnaGxpZ2h0IHRoZSB0b2tlbnMgb24gdGhlXFxuICAvLyBsaW5lLlxcbiAgZnVuY3Rpb24gaGlnaGxpZ2h0TGluZShjbSwgbGluZSwgc3RhdGUsIGZvcmNlVG9FbmQpIHtcXG4gICAgLy8gQSBzdHlsZXMgYXJyYXkgYWx3YXlzIHN0YXJ0cyB3aXRoIGEgbnVtYmVyIGlkZW50aWZ5aW5nIHRoZVxcbiAgICAvLyBtb2RlL292ZXJsYXlzIHRoYXQgaXQgaXMgYmFzZWQgb24gKGZvciBlYXN5IGludmFsaWRhdGlvbikuXFxuICAgIHZhciBzdCA9IFtjbS5zdGF0ZS5tb2RlR2VuXSwgbGluZUNsYXNzZXMgPSB7fTtcXG4gICAgLy8gQ29tcHV0ZSB0aGUgYmFzZSBhcnJheSBvZiBzdHlsZXNcXG4gICAgcnVuTW9kZShjbSwgbGluZS50ZXh0LCBjbS5kb2MubW9kZSwgc3RhdGUsIGZ1bmN0aW9uKGVuZCwgc3R5bGUpIHtcXG4gICAgICBzdC5wdXNoKGVuZCwgc3R5bGUpO1xcbiAgICB9LCBsaW5lQ2xhc3NlcywgZm9yY2VUb0VuZCk7XFxuXFxuICAgIC8vIFJ1biBvdmVybGF5cywgYWRqdXN0IHN0eWxlIGFycmF5LlxcbiAgICBmb3IgKHZhciBvID0gMDsgbyA8IGNtLnN0YXRlLm92ZXJsYXlzLmxlbmd0aDsgKytvKSB7XFxuICAgICAgdmFyIG92ZXJsYXkgPSBjbS5zdGF0ZS5vdmVybGF5c1tvXSwgaSA9IDEsIGF0ID0gMDtcXG4gICAgICBydW5Nb2RlKGNtLCBsaW5lLnRleHQsIG92ZXJsYXkubW9kZSwgdHJ1ZSwgZnVuY3Rpb24oZW5kLCBzdHlsZSkge1xcbiAgICAgICAgdmFyIHN0YXJ0ID0gaTtcXG4gICAgICAgIC8vIEVuc3VyZSB0aGVyZSdzIGEgdG9rZW4gZW5kIGF0IHRoZSBjdXJyZW50IHBvc2l0aW9uLCBhbmQgdGhhdCBpIHBvaW50cyBhdCBpdFxcbiAgICAgICAgd2hpbGUgKGF0IDwgZW5kKSB7XFxuICAgICAgICAgIHZhciBpX2VuZCA9IHN0W2ldO1xcbiAgICAgICAgICBpZiAoaV9lbmQgPiBlbmQpXFxuICAgICAgICAgICAgc3Quc3BsaWNlKGksIDEsIGVuZCwgc3RbaSsxXSwgaV9lbmQpO1xcbiAgICAgICAgICBpICs9IDI7XFxuICAgICAgICAgIGF0ID0gTWF0aC5taW4oZW5kLCBpX2VuZCk7XFxuICAgICAgICB9XFxuICAgICAgICBpZiAoIXN0eWxlKSByZXR1cm47XFxuICAgICAgICBpZiAob3ZlcmxheS5vcGFxdWUpIHtcXG4gICAgICAgICAgc3Quc3BsaWNlKHN0YXJ0LCBpIC0gc3RhcnQsIGVuZCwgXFxcImNtLW92ZXJsYXkgXFxcIiArIHN0eWxlKTtcXG4gICAgICAgICAgaSA9IHN0YXJ0ICsgMjtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIGZvciAoOyBzdGFydCA8IGk7IHN0YXJ0ICs9IDIpIHtcXG4gICAgICAgICAgICB2YXIgY3VyID0gc3Rbc3RhcnQrMV07XFxuICAgICAgICAgICAgc3Rbc3RhcnQrMV0gPSAoY3VyID8gY3VyICsgXFxcIiBcXFwiIDogXFxcIlxcXCIpICsgXFxcImNtLW92ZXJsYXkgXFxcIiArIHN0eWxlO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgfSwgbGluZUNsYXNzZXMpO1xcbiAgICB9XFxuXFxuICAgIHJldHVybiB7c3R5bGVzOiBzdCwgY2xhc3NlczogbGluZUNsYXNzZXMuYmdDbGFzcyB8fCBsaW5lQ2xhc3Nlcy50ZXh0Q2xhc3MgPyBsaW5lQ2xhc3NlcyA6IG51bGx9O1xcbiAgfVxcblxcbiAgZnVuY3Rpb24gZ2V0TGluZVN0eWxlcyhjbSwgbGluZSwgdXBkYXRlRnJvbnRpZXIpIHtcXG4gICAgaWYgKCFsaW5lLnN0eWxlcyB8fCBsaW5lLnN0eWxlc1swXSAhPSBjbS5zdGF0ZS5tb2RlR2VuKSB7XFxuICAgICAgdmFyIHN0YXRlID0gZ2V0U3RhdGVCZWZvcmUoY20sIGxpbmVObyhsaW5lKSk7XFxuICAgICAgdmFyIHJlc3VsdCA9IGhpZ2hsaWdodExpbmUoY20sIGxpbmUsIGxpbmUudGV4dC5sZW5ndGggPiBjbS5vcHRpb25zLm1heEhpZ2hsaWdodExlbmd0aCA/IGNvcHlTdGF0ZShjbS5kb2MubW9kZSwgc3RhdGUpIDogc3RhdGUpO1xcbiAgICAgIGxpbmUuc3RhdGVBZnRlciA9IHN0YXRlO1xcbiAgICAgIGxpbmUuc3R5bGVzID0gcmVzdWx0LnN0eWxlcztcXG4gICAgICBpZiAocmVzdWx0LmNsYXNzZXMpIGxpbmUuc3R5bGVDbGFzc2VzID0gcmVzdWx0LmNsYXNzZXM7XFxuICAgICAgZWxzZSBpZiAobGluZS5zdHlsZUNsYXNzZXMpIGxpbmUuc3R5bGVDbGFzc2VzID0gbnVsbDtcXG4gICAgICBpZiAodXBkYXRlRnJvbnRpZXIgPT09IGNtLmRvYy5mcm9udGllcikgY20uZG9jLmZyb250aWVyKys7XFxuICAgIH1cXG4gICAgcmV0dXJuIGxpbmUuc3R5bGVzO1xcbiAgfVxcblxcbiAgLy8gTGlnaHR3ZWlnaHQgZm9ybSBvZiBoaWdobGlnaHQgLS0gcHJvY2VlZCBvdmVyIHRoaXMgbGluZSBhbmRcXG4gIC8vIHVwZGF0ZSBzdGF0ZSwgYnV0IGRvbid0IHNhdmUgYSBzdHlsZSBhcnJheS4gVXNlZCBmb3IgbGluZXMgdGhhdFxcbiAgLy8gYXJlbid0IGN1cnJlbnRseSB2aXNpYmxlLlxcbiAgZnVuY3Rpb24gcHJvY2Vzc0xpbmUoY20sIHRleHQsIHN0YXRlLCBzdGFydEF0KSB7XFxuICAgIHZhciBtb2RlID0gY20uZG9jLm1vZGU7XFxuICAgIHZhciBzdHJlYW0gPSBuZXcgU3RyaW5nU3RyZWFtKHRleHQsIGNtLm9wdGlvbnMudGFiU2l6ZSk7XFxuICAgIHN0cmVhbS5zdGFydCA9IHN0cmVhbS5wb3MgPSBzdGFydEF0IHx8IDA7XFxuICAgIGlmICh0ZXh0ID09IFxcXCJcXFwiKSBjYWxsQmxhbmtMaW5lKG1vZGUsIHN0YXRlKTtcXG4gICAgd2hpbGUgKCFzdHJlYW0uZW9sKCkpIHtcXG4gICAgICByZWFkVG9rZW4obW9kZSwgc3RyZWFtLCBzdGF0ZSk7XFxuICAgICAgc3RyZWFtLnN0YXJ0ID0gc3RyZWFtLnBvcztcXG4gICAgfVxcbiAgfVxcblxcbiAgLy8gQ29udmVydCBhIHN0eWxlIGFzIHJldHVybmVkIGJ5IGEgbW9kZSAoZWl0aGVyIG51bGwsIG9yIGEgc3RyaW5nXFxuICAvLyBjb250YWluaW5nIG9uZSBvciBtb3JlIHN0eWxlcykgdG8gYSBDU1Mgc3R5bGUuIFRoaXMgaXMgY2FjaGVkLFxcbiAgLy8gYW5kIGFsc28gbG9va3MgZm9yIGxpbmUtd2lkZSBzdHlsZXMuXFxuICB2YXIgc3R5bGVUb0NsYXNzQ2FjaGUgPSB7fSwgc3R5bGVUb0NsYXNzQ2FjaGVXaXRoTW9kZSA9IHt9O1xcbiAgZnVuY3Rpb24gaW50ZXJwcmV0VG9rZW5TdHlsZShzdHlsZSwgb3B0aW9ucykge1xcbiAgICBpZiAoIXN0eWxlIHx8IC9eXFxcXHMqJC8udGVzdChzdHlsZSkpIHJldHVybiBudWxsO1xcbiAgICB2YXIgY2FjaGUgPSBvcHRpb25zLmFkZE1vZGVDbGFzcyA/IHN0eWxlVG9DbGFzc0NhY2hlV2l0aE1vZGUgOiBzdHlsZVRvQ2xhc3NDYWNoZTtcXG4gICAgcmV0dXJuIGNhY2hlW3N0eWxlXSB8fFxcbiAgICAgIChjYWNoZVtzdHlsZV0gPSBzdHlsZS5yZXBsYWNlKC9cXFxcUysvZywgXFxcImNtLSQmXFxcIikpO1xcbiAgfVxcblxcbiAgLy8gUmVuZGVyIHRoZSBET00gcmVwcmVzZW50YXRpb24gb2YgdGhlIHRleHQgb2YgYSBsaW5lLiBBbHNvIGJ1aWxkc1xcbiAgLy8gdXAgYSAnbGluZSBtYXAnLCB3aGljaCBwb2ludHMgYXQgdGhlIERPTSBub2RlcyB0aGF0IHJlcHJlc2VudFxcbiAgLy8gc3BlY2lmaWMgc3RyZXRjaGVzIG9mIHRleHQsIGFuZCBpcyB1c2VkIGJ5IHRoZSBtZWFzdXJpbmcgY29kZS5cXG4gIC8vIFRoZSByZXR1cm5lZCBvYmplY3QgY29udGFpbnMgdGhlIERPTSBub2RlLCB0aGlzIG1hcCwgYW5kXFxuICAvLyBpbmZvcm1hdGlvbiBhYm91dCBsaW5lLXdpZGUgc3R5bGVzIHRoYXQgd2VyZSBzZXQgYnkgdGhlIG1vZGUuXFxuICBmdW5jdGlvbiBidWlsZExpbmVDb250ZW50KGNtLCBsaW5lVmlldykge1xcbiAgICAvLyBUaGUgcGFkZGluZy1yaWdodCBmb3JjZXMgdGhlIGVsZW1lbnQgdG8gaGF2ZSBhICdib3JkZXInLCB3aGljaFxcbiAgICAvLyBpcyBuZWVkZWQgb24gV2Via2l0IHRvIGJlIGFibGUgdG8gZ2V0IGxpbmUtbGV2ZWwgYm91bmRpbmdcXG4gICAgLy8gcmVjdGFuZ2xlcyBmb3IgaXQgKGluIG1lYXN1cmVDaGFyKS5cXG4gICAgdmFyIGNvbnRlbnQgPSBlbHQoXFxcInNwYW5cXFwiLCBudWxsLCBudWxsLCB3ZWJraXQgPyBcXFwicGFkZGluZy1yaWdodDogLjFweFxcXCIgOiBudWxsKTtcXG4gICAgdmFyIGJ1aWxkZXIgPSB7cHJlOiBlbHQoXFxcInByZVxcXCIsIFtjb250ZW50XSwgXFxcIkNvZGVNaXJyb3ItbGluZVxcXCIpLCBjb250ZW50OiBjb250ZW50LFxcbiAgICAgICAgICAgICAgICAgICBjb2w6IDAsIHBvczogMCwgY206IGNtLFxcbiAgICAgICAgICAgICAgICAgICB0cmFpbGluZ1NwYWNlOiBmYWxzZSxcXG4gICAgICAgICAgICAgICAgICAgc3BsaXRTcGFjZXM6IChpZSB8fCB3ZWJraXQpICYmIGNtLmdldE9wdGlvbihcXFwibGluZVdyYXBwaW5nXFxcIil9O1xcbiAgICBsaW5lVmlldy5tZWFzdXJlID0ge307XFxuXFxuICAgIC8vIEl0ZXJhdGUgb3ZlciB0aGUgbG9naWNhbCBsaW5lcyB0aGF0IG1ha2UgdXAgdGhpcyB2aXN1YWwgbGluZS5cXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPD0gKGxpbmVWaWV3LnJlc3QgPyBsaW5lVmlldy5yZXN0Lmxlbmd0aCA6IDApOyBpKyspIHtcXG4gICAgICB2YXIgbGluZSA9IGkgPyBsaW5lVmlldy5yZXN0W2kgLSAxXSA6IGxpbmVWaWV3LmxpbmUsIG9yZGVyO1xcbiAgICAgIGJ1aWxkZXIucG9zID0gMDtcXG4gICAgICBidWlsZGVyLmFkZFRva2VuID0gYnVpbGRUb2tlbjtcXG4gICAgICAvLyBPcHRpb25hbGx5IHdpcmUgaW4gc29tZSBoYWNrcyBpbnRvIHRoZSB0b2tlbi1yZW5kZXJpbmdcXG4gICAgICAvLyBhbGdvcml0aG0sIHRvIGRlYWwgd2l0aCBicm93c2VyIHF1aXJrcy5cXG4gICAgICBpZiAoaGFzQmFkQmlkaVJlY3RzKGNtLmRpc3BsYXkubWVhc3VyZSkgJiYgKG9yZGVyID0gZ2V0T3JkZXIobGluZSkpKVxcbiAgICAgICAgYnVpbGRlci5hZGRUb2tlbiA9IGJ1aWxkVG9rZW5CYWRCaWRpKGJ1aWxkZXIuYWRkVG9rZW4sIG9yZGVyKTtcXG4gICAgICBidWlsZGVyLm1hcCA9IFtdO1xcbiAgICAgIHZhciBhbGxvd0Zyb250aWVyVXBkYXRlID0gbGluZVZpZXcgIT0gY20uZGlzcGxheS5leHRlcm5hbE1lYXN1cmVkICYmIGxpbmVObyhsaW5lKTtcXG4gICAgICBpbnNlcnRMaW5lQ29udGVudChsaW5lLCBidWlsZGVyLCBnZXRMaW5lU3R5bGVzKGNtLCBsaW5lLCBhbGxvd0Zyb250aWVyVXBkYXRlKSk7XFxuICAgICAgaWYgKGxpbmUuc3R5bGVDbGFzc2VzKSB7XFxuICAgICAgICBpZiAobGluZS5zdHlsZUNsYXNzZXMuYmdDbGFzcylcXG4gICAgICAgICAgYnVpbGRlci5iZ0NsYXNzID0gam9pbkNsYXNzZXMobGluZS5zdHlsZUNsYXNzZXMuYmdDbGFzcywgYnVpbGRlci5iZ0NsYXNzIHx8IFxcXCJcXFwiKTtcXG4gICAgICAgIGlmIChsaW5lLnN0eWxlQ2xhc3Nlcy50ZXh0Q2xhc3MpXFxuICAgICAgICAgIGJ1aWxkZXIudGV4dENsYXNzID0gam9pbkNsYXNzZXMobGluZS5zdHlsZUNsYXNzZXMudGV4dENsYXNzLCBidWlsZGVyLnRleHRDbGFzcyB8fCBcXFwiXFxcIik7XFxuICAgICAgfVxcblxcbiAgICAgIC8vIEVuc3VyZSBhdCBsZWFzdCBhIHNpbmdsZSBub2RlIGlzIHByZXNlbnQsIGZvciBtZWFzdXJpbmcuXFxuICAgICAgaWYgKGJ1aWxkZXIubWFwLmxlbmd0aCA9PSAwKVxcbiAgICAgICAgYnVpbGRlci5tYXAucHVzaCgwLCAwLCBidWlsZGVyLmNvbnRlbnQuYXBwZW5kQ2hpbGQoemVyb1dpZHRoRWxlbWVudChjbS5kaXNwbGF5Lm1lYXN1cmUpKSk7XFxuXFxuICAgICAgLy8gU3RvcmUgdGhlIG1hcCBhbmQgYSBjYWNoZSBvYmplY3QgZm9yIHRoZSBjdXJyZW50IGxvZ2ljYWwgbGluZVxcbiAgICAgIGlmIChpID09IDApIHtcXG4gICAgICAgIGxpbmVWaWV3Lm1lYXN1cmUubWFwID0gYnVpbGRlci5tYXA7XFxuICAgICAgICBsaW5lVmlldy5tZWFzdXJlLmNhY2hlID0ge307XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIChsaW5lVmlldy5tZWFzdXJlLm1hcHMgfHwgKGxpbmVWaWV3Lm1lYXN1cmUubWFwcyA9IFtdKSkucHVzaChidWlsZGVyLm1hcCk7XFxuICAgICAgICAobGluZVZpZXcubWVhc3VyZS5jYWNoZXMgfHwgKGxpbmVWaWV3Lm1lYXN1cmUuY2FjaGVzID0gW10pKS5wdXNoKHt9KTtcXG4gICAgICB9XFxuICAgIH1cXG5cXG4gICAgLy8gU2VlIGlzc3VlICMyOTAxXFxuICAgIGlmICh3ZWJraXQpIHtcXG4gICAgICB2YXIgbGFzdCA9IGJ1aWxkZXIuY29udGVudC5sYXN0Q2hpbGRcXG4gICAgICBpZiAoL1xcXFxiY20tdGFiXFxcXGIvLnRlc3QobGFzdC5jbGFzc05hbWUpIHx8IChsYXN0LnF1ZXJ5U2VsZWN0b3IgJiYgbGFzdC5xdWVyeVNlbGVjdG9yKFxcXCIuY20tdGFiXFxcIikpKVxcbiAgICAgICAgYnVpbGRlci5jb250ZW50LmNsYXNzTmFtZSA9IFxcXCJjbS10YWItd3JhcC1oYWNrXFxcIjtcXG4gICAgfVxcblxcbiAgICBzaWduYWwoY20sIFxcXCJyZW5kZXJMaW5lXFxcIiwgY20sIGxpbmVWaWV3LmxpbmUsIGJ1aWxkZXIucHJlKTtcXG4gICAgaWYgKGJ1aWxkZXIucHJlLmNsYXNzTmFtZSlcXG4gICAgICBidWlsZGVyLnRleHRDbGFzcyA9IGpvaW5DbGFzc2VzKGJ1aWxkZXIucHJlLmNsYXNzTmFtZSwgYnVpbGRlci50ZXh0Q2xhc3MgfHwgXFxcIlxcXCIpO1xcblxcbiAgICByZXR1cm4gYnVpbGRlcjtcXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIGRlZmF1bHRTcGVjaWFsQ2hhclBsYWNlaG9sZGVyKGNoKSB7XFxuICAgIHZhciB0b2tlbiA9IGVsdChcXFwic3BhblxcXCIsIFxcXCJcXFxcdTIwMjJcXFwiLCBcXFwiY20taW52YWxpZGNoYXJcXFwiKTtcXG4gICAgdG9rZW4udGl0bGUgPSBcXFwiXFxcXFxcXFx1XFxcIiArIGNoLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpO1xcbiAgICB0b2tlbi5zZXRBdHRyaWJ1dGUoXFxcImFyaWEtbGFiZWxcXFwiLCB0b2tlbi50aXRsZSk7XFxuICAgIHJldHVybiB0b2tlbjtcXG4gIH1cXG5cXG4gIC8vIEJ1aWxkIHVwIHRoZSBET00gcmVwcmVzZW50YXRpb24gZm9yIGEgc2luZ2xlIHRva2VuLCBhbmQgYWRkIGl0IHRvXFxuICAvLyB0aGUgbGluZSBtYXAuIFRha2VzIGNhcmUgdG8gcmVuZGVyIHNwZWNpYWwgY2hhcmFjdGVycyBzZXBhcmF0ZWx5LlxcbiAgZnVuY3Rpb24gYnVpbGRUb2tlbihidWlsZGVyLCB0ZXh0LCBzdHlsZSwgc3RhcnRTdHlsZSwgZW5kU3R5bGUsIHRpdGxlLCBjc3MpIHtcXG4gICAgaWYgKCF0ZXh0KSByZXR1cm47XFxuICAgIHZhciBkaXNwbGF5VGV4dCA9IGJ1aWxkZXIuc3BsaXRTcGFjZXMgPyBzcGxpdFNwYWNlcyh0ZXh0LCBidWlsZGVyLnRyYWlsaW5nU3BhY2UpIDogdGV4dFxcbiAgICB2YXIgc3BlY2lhbCA9IGJ1aWxkZXIuY20uc3RhdGUuc3BlY2lhbENoYXJzLCBtdXN0V3JhcCA9IGZhbHNlO1xcbiAgICBpZiAoIXNwZWNpYWwudGVzdCh0ZXh0KSkge1xcbiAgICAgIGJ1aWxkZXIuY29sICs9IHRleHQubGVuZ3RoO1xcbiAgICAgIHZhciBjb250ZW50ID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoZGlzcGxheVRleHQpO1xcbiAgICAgIGJ1aWxkZXIubWFwLnB1c2goYnVpbGRlci5wb3MsIGJ1aWxkZXIucG9zICsgdGV4dC5sZW5ndGgsIGNvbnRlbnQpO1xcbiAgICAgIGlmIChpZSAmJiBpZV92ZXJzaW9uIDwgOSkgbXVzdFdyYXAgPSB0cnVlO1xcbiAgICAgIGJ1aWxkZXIucG9zICs9IHRleHQubGVuZ3RoO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIHZhciBjb250ZW50ID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpLCBwb3MgPSAwO1xcbiAgICAgIHdoaWxlICh0cnVlKSB7XFxuICAgICAgICBzcGVjaWFsLmxhc3RJbmRleCA9IHBvcztcXG4gICAgICAgIHZhciBtID0gc3BlY2lhbC5leGVjKHRleHQpO1xcbiAgICAgICAgdmFyIHNraXBwZWQgPSBtID8gbS5pbmRleCAtIHBvcyA6IHRleHQubGVuZ3RoIC0gcG9zO1xcbiAgICAgICAgaWYgKHNraXBwZWQpIHtcXG4gICAgICAgICAgdmFyIHR4dCA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGRpc3BsYXlUZXh0LnNsaWNlKHBvcywgcG9zICsgc2tpcHBlZCkpO1xcbiAgICAgICAgICBpZiAoaWUgJiYgaWVfdmVyc2lvbiA8IDkpIGNvbnRlbnQuYXBwZW5kQ2hpbGQoZWx0KFxcXCJzcGFuXFxcIiwgW3R4dF0pKTtcXG4gICAgICAgICAgZWxzZSBjb250ZW50LmFwcGVuZENoaWxkKHR4dCk7XFxuICAgICAgICAgIGJ1aWxkZXIubWFwLnB1c2goYnVpbGRlci5wb3MsIGJ1aWxkZXIucG9zICsgc2tpcHBlZCwgdHh0KTtcXG4gICAgICAgICAgYnVpbGRlci5jb2wgKz0gc2tpcHBlZDtcXG4gICAgICAgICAgYnVpbGRlci5wb3MgKz0gc2tpcHBlZDtcXG4gICAgICAgIH1cXG4gICAgICAgIGlmICghbSkgYnJlYWs7XFxuICAgICAgICBwb3MgKz0gc2tpcHBlZCArIDE7XFxuICAgICAgICBpZiAobVswXSA9PSBcXFwiXFxcXHRcXFwiKSB7XFxuICAgICAgICAgIHZhciB0YWJTaXplID0gYnVpbGRlci5jbS5vcHRpb25zLnRhYlNpemUsIHRhYldpZHRoID0gdGFiU2l6ZSAtIGJ1aWxkZXIuY29sICUgdGFiU2l6ZTtcXG4gICAgICAgICAgdmFyIHR4dCA9IGNvbnRlbnQuYXBwZW5kQ2hpbGQoZWx0KFxcXCJzcGFuXFxcIiwgc3BhY2VTdHIodGFiV2lkdGgpLCBcXFwiY20tdGFiXFxcIikpO1xcbiAgICAgICAgICB0eHQuc2V0QXR0cmlidXRlKFxcXCJyb2xlXFxcIiwgXFxcInByZXNlbnRhdGlvblxcXCIpO1xcbiAgICAgICAgICB0eHQuc2V0QXR0cmlidXRlKFxcXCJjbS10ZXh0XFxcIiwgXFxcIlxcXFx0XFxcIik7XFxuICAgICAgICAgIGJ1aWxkZXIuY29sICs9IHRhYldpZHRoO1xcbiAgICAgICAgfSBlbHNlIGlmIChtWzBdID09IFxcXCJcXFxcclxcXCIgfHwgbVswXSA9PSBcXFwiXFxcXG5cXFwiKSB7XFxuICAgICAgICAgIHZhciB0eHQgPSBjb250ZW50LmFwcGVuZENoaWxkKGVsdChcXFwic3BhblxcXCIsIG1bMF0gPT0gXFxcIlxcXFxyXFxcIiA/IFxcXCJcXFxcdTI0MGRcXFwiIDogXFxcIlxcXFx1MjQyNFxcXCIsIFxcXCJjbS1pbnZhbGlkY2hhclxcXCIpKTtcXG4gICAgICAgICAgdHh0LnNldEF0dHJpYnV0ZShcXFwiY20tdGV4dFxcXCIsIG1bMF0pO1xcbiAgICAgICAgICBidWlsZGVyLmNvbCArPSAxO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgdmFyIHR4dCA9IGJ1aWxkZXIuY20ub3B0aW9ucy5zcGVjaWFsQ2hhclBsYWNlaG9sZGVyKG1bMF0pO1xcbiAgICAgICAgICB0eHQuc2V0QXR0cmlidXRlKFxcXCJjbS10ZXh0XFxcIiwgbVswXSk7XFxuICAgICAgICAgIGlmIChpZSAmJiBpZV92ZXJzaW9uIDwgOSkgY29udGVudC5hcHBlbmRDaGlsZChlbHQoXFxcInNwYW5cXFwiLCBbdHh0XSkpO1xcbiAgICAgICAgICBlbHNlIGNvbnRlbnQuYXBwZW5kQ2hpbGQodHh0KTtcXG4gICAgICAgICAgYnVpbGRlci5jb2wgKz0gMTtcXG4gICAgICAgIH1cXG4gICAgICAgIGJ1aWxkZXIubWFwLnB1c2goYnVpbGRlci5wb3MsIGJ1aWxkZXIucG9zICsgMSwgdHh0KTtcXG4gICAgICAgIGJ1aWxkZXIucG9zKys7XFxuICAgICAgfVxcbiAgICB9XFxuICAgIGJ1aWxkZXIudHJhaWxpbmdTcGFjZSA9IGRpc3BsYXlUZXh0LmNoYXJDb2RlQXQodGV4dC5sZW5ndGggLSAxKSA9PSAzMlxcbiAgICBpZiAoc3R5bGUgfHwgc3RhcnRTdHlsZSB8fCBlbmRTdHlsZSB8fCBtdXN0V3JhcCB8fCBjc3MpIHtcXG4gICAgICB2YXIgZnVsbFN0eWxlID0gc3R5bGUgfHwgXFxcIlxcXCI7XFxuICAgICAgaWYgKHN0YXJ0U3R5bGUpIGZ1bGxTdHlsZSArPSBzdGFydFN0eWxlO1xcbiAgICAgIGlmIChlbmRTdHlsZSkgZnVsbFN0eWxlICs9IGVuZFN0eWxlO1xcbiAgICAgIHZhciB0b2tlbiA9IGVsdChcXFwic3BhblxcXCIsIFtjb250ZW50XSwgZnVsbFN0eWxlLCBjc3MpO1xcbiAgICAgIGlmICh0aXRsZSkgdG9rZW4udGl0bGUgPSB0aXRsZTtcXG4gICAgICByZXR1cm4gYnVpbGRlci5jb250ZW50LmFwcGVuZENoaWxkKHRva2VuKTtcXG4gICAgfVxcbiAgICBidWlsZGVyLmNvbnRlbnQuYXBwZW5kQ2hpbGQoY29udGVudCk7XFxuICB9XFxuXFxuICBmdW5jdGlvbiBzcGxpdFNwYWNlcyh0ZXh0LCB0cmFpbGluZ0JlZm9yZSkge1xcbiAgICBpZiAodGV4dC5sZW5ndGggPiAxICYmICEvICAvLnRlc3QodGV4dCkpIHJldHVybiB0ZXh0XFxuICAgIHZhciBzcGFjZUJlZm9yZSA9IHRyYWlsaW5nQmVmb3JlLCByZXN1bHQgPSBcXFwiXFxcIlxcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRleHQubGVuZ3RoOyBpKyspIHtcXG4gICAgICB2YXIgY2ggPSB0ZXh0LmNoYXJBdChpKVxcbiAgICAgIGlmIChjaCA9PSBcXFwiIFxcXCIgJiYgc3BhY2VCZWZvcmUgJiYgKGkgPT0gdGV4dC5sZW5ndGggLSAxIHx8IHRleHQuY2hhckNvZGVBdChpICsgMSkgPT0gMzIpKVxcbiAgICAgICAgY2ggPSBcXFwiXFxcXHUwMGEwXFxcIlxcbiAgICAgIHJlc3VsdCArPSBjaFxcbiAgICAgIHNwYWNlQmVmb3JlID0gY2ggPT0gXFxcIiBcXFwiXFxuICAgIH1cXG4gICAgcmV0dXJuIHJlc3VsdFxcbiAgfVxcblxcbiAgLy8gV29yayBhcm91bmQgbm9uc2Vuc2UgZGltZW5zaW9ucyBiZWluZyByZXBvcnRlZCBmb3Igc3RyZXRjaGVzIG9mXFxuICAvLyByaWdodC10by1sZWZ0IHRleHQuXFxuICBmdW5jdGlvbiBidWlsZFRva2VuQmFkQmlkaShpbm5lciwgb3JkZXIpIHtcXG4gICAgcmV0dXJuIGZ1bmN0aW9uKGJ1aWxkZXIsIHRleHQsIHN0eWxlLCBzdGFydFN0eWxlLCBlbmRTdHlsZSwgdGl0bGUsIGNzcykge1xcbiAgICAgIHN0eWxlID0gc3R5bGUgPyBzdHlsZSArIFxcXCIgY20tZm9yY2UtYm9yZGVyXFxcIiA6IFxcXCJjbS1mb3JjZS1ib3JkZXJcXFwiO1xcbiAgICAgIHZhciBzdGFydCA9IGJ1aWxkZXIucG9zLCBlbmQgPSBzdGFydCArIHRleHQubGVuZ3RoO1xcbiAgICAgIGZvciAoOzspIHtcXG4gICAgICAgIC8vIEZpbmQgdGhlIHBhcnQgdGhhdCBvdmVybGFwcyB3aXRoIHRoZSBzdGFydCBvZiB0aGlzIHRleHRcXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3JkZXIubGVuZ3RoOyBpKyspIHtcXG4gICAgICAgICAgdmFyIHBhcnQgPSBvcmRlcltpXTtcXG4gICAgICAgICAgaWYgKHBhcnQudG8gPiBzdGFydCAmJiBwYXJ0LmZyb20gPD0gc3RhcnQpIGJyZWFrO1xcbiAgICAgICAgfVxcbiAgICAgICAgaWYgKHBhcnQudG8gPj0gZW5kKSByZXR1cm4gaW5uZXIoYnVpbGRlciwgdGV4dCwgc3R5bGUsIHN0YXJ0U3R5bGUsIGVuZFN0eWxlLCB0aXRsZSwgY3NzKTtcXG4gICAgICAgIGlubmVyKGJ1aWxkZXIsIHRleHQuc2xpY2UoMCwgcGFydC50byAtIHN0YXJ0KSwgc3R5bGUsIHN0YXJ0U3R5bGUsIG51bGwsIHRpdGxlLCBjc3MpO1xcbiAgICAgICAgc3RhcnRTdHlsZSA9IG51bGw7XFxuICAgICAgICB0ZXh0ID0gdGV4dC5zbGljZShwYXJ0LnRvIC0gc3RhcnQpO1xcbiAgICAgICAgc3RhcnQgPSBwYXJ0LnRvO1xcbiAgICAgIH1cXG4gICAgfTtcXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIGJ1aWxkQ29sbGFwc2VkU3BhbihidWlsZGVyLCBzaXplLCBtYXJrZXIsIGlnbm9yZVdpZGdldCkge1xcbiAgICB2YXIgd2lkZ2V0ID0gIWlnbm9yZVdpZGdldCAmJiBtYXJrZXIud2lkZ2V0Tm9kZTtcXG4gICAgaWYgKHdpZGdldCkgYnVpbGRlci5tYXAucHVzaChidWlsZGVyLnBvcywgYnVpbGRlci5wb3MgKyBzaXplLCB3aWRnZXQpO1xcbiAgICBpZiAoIWlnbm9yZVdpZGdldCAmJiBidWlsZGVyLmNtLmRpc3BsYXkuaW5wdXQubmVlZHNDb250ZW50QXR0cmlidXRlKSB7XFxuICAgICAgaWYgKCF3aWRnZXQpXFxuICAgICAgICB3aWRnZXQgPSBidWlsZGVyLmNvbnRlbnQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcXFwic3BhblxcXCIpKTtcXG4gICAgICB3aWRnZXQuc2V0QXR0cmlidXRlKFxcXCJjbS1tYXJrZXJcXFwiLCBtYXJrZXIuaWQpO1xcbiAgICB9XFxuICAgIGlmICh3aWRnZXQpIHtcXG4gICAgICBidWlsZGVyLmNtLmRpc3BsYXkuaW5wdXQuc2V0VW5lZGl0YWJsZSh3aWRnZXQpO1xcbiAgICAgIGJ1aWxkZXIuY29udGVudC5hcHBlbmRDaGlsZCh3aWRnZXQpO1xcbiAgICB9XFxuICAgIGJ1aWxkZXIucG9zICs9IHNpemU7XFxuICAgIGJ1aWxkZXIudHJhaWxpbmdTcGFjZSA9IGZhbHNlXFxuICB9XFxuXFxuICAvLyBPdXRwdXRzIGEgbnVtYmVyIG9mIHNwYW5zIHRvIG1ha2UgdXAgYSBsaW5lLCB0YWtpbmcgaGlnaGxpZ2h0aW5nXFxuICAvLyBhbmQgbWFya2VkIHRleHQgaW50byBhY2NvdW50LlxcbiAgZnVuY3Rpb24gaW5zZXJ0TGluZUNvbnRlbnQobGluZSwgYnVpbGRlciwgc3R5bGVzKSB7XFxuICAgIHZhciBzcGFucyA9IGxpbmUubWFya2VkU3BhbnMsIGFsbFRleHQgPSBsaW5lLnRleHQsIGF0ID0gMDtcXG4gICAgaWYgKCFzcGFucykge1xcbiAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgc3R5bGVzLmxlbmd0aDsgaSs9MilcXG4gICAgICAgIGJ1aWxkZXIuYWRkVG9rZW4oYnVpbGRlciwgYWxsVGV4dC5zbGljZShhdCwgYXQgPSBzdHlsZXNbaV0pLCBpbnRlcnByZXRUb2tlblN0eWxlKHN0eWxlc1tpKzFdLCBidWlsZGVyLmNtLm9wdGlvbnMpKTtcXG4gICAgICByZXR1cm47XFxuICAgIH1cXG5cXG4gICAgdmFyIGxlbiA9IGFsbFRleHQubGVuZ3RoLCBwb3MgPSAwLCBpID0gMSwgdGV4dCA9IFxcXCJcXFwiLCBzdHlsZSwgY3NzO1xcbiAgICB2YXIgbmV4dENoYW5nZSA9IDAsIHNwYW5TdHlsZSwgc3BhbkVuZFN0eWxlLCBzcGFuU3RhcnRTdHlsZSwgdGl0bGUsIGNvbGxhcHNlZDtcXG4gICAgZm9yICg7Oykge1xcbiAgICAgIGlmIChuZXh0Q2hhbmdlID09IHBvcykgeyAvLyBVcGRhdGUgY3VycmVudCBtYXJrZXIgc2V0XFxuICAgICAgICBzcGFuU3R5bGUgPSBzcGFuRW5kU3R5bGUgPSBzcGFuU3RhcnRTdHlsZSA9IHRpdGxlID0gY3NzID0gXFxcIlxcXCI7XFxuICAgICAgICBjb2xsYXBzZWQgPSBudWxsOyBuZXh0Q2hhbmdlID0gSW5maW5pdHk7XFxuICAgICAgICB2YXIgZm91bmRCb29rbWFya3MgPSBbXSwgZW5kU3R5bGVzXFxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHNwYW5zLmxlbmd0aDsgKytqKSB7XFxuICAgICAgICAgIHZhciBzcCA9IHNwYW5zW2pdLCBtID0gc3AubWFya2VyO1xcbiAgICAgICAgICBpZiAobS50eXBlID09IFxcXCJib29rbWFya1xcXCIgJiYgc3AuZnJvbSA9PSBwb3MgJiYgbS53aWRnZXROb2RlKSB7XFxuICAgICAgICAgICAgZm91bmRCb29rbWFya3MucHVzaChtKTtcXG4gICAgICAgICAgfSBlbHNlIGlmIChzcC5mcm9tIDw9IHBvcyAmJiAoc3AudG8gPT0gbnVsbCB8fCBzcC50byA+IHBvcyB8fCBtLmNvbGxhcHNlZCAmJiBzcC50byA9PSBwb3MgJiYgc3AuZnJvbSA9PSBwb3MpKSB7XFxuICAgICAgICAgICAgaWYgKHNwLnRvICE9IG51bGwgJiYgc3AudG8gIT0gcG9zICYmIG5leHRDaGFuZ2UgPiBzcC50bykge1xcbiAgICAgICAgICAgICAgbmV4dENoYW5nZSA9IHNwLnRvO1xcbiAgICAgICAgICAgICAgc3BhbkVuZFN0eWxlID0gXFxcIlxcXCI7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGlmIChtLmNsYXNzTmFtZSkgc3BhblN0eWxlICs9IFxcXCIgXFxcIiArIG0uY2xhc3NOYW1lO1xcbiAgICAgICAgICAgIGlmIChtLmNzcykgY3NzID0gKGNzcyA/IGNzcyArIFxcXCI7XFxcIiA6IFxcXCJcXFwiKSArIG0uY3NzO1xcbiAgICAgICAgICAgIGlmIChtLnN0YXJ0U3R5bGUgJiYgc3AuZnJvbSA9PSBwb3MpIHNwYW5TdGFydFN0eWxlICs9IFxcXCIgXFxcIiArIG0uc3RhcnRTdHlsZTtcXG4gICAgICAgICAgICBpZiAobS5lbmRTdHlsZSAmJiBzcC50byA9PSBuZXh0Q2hhbmdlKSAoZW5kU3R5bGVzIHx8IChlbmRTdHlsZXMgPSBbXSkpLnB1c2gobS5lbmRTdHlsZSwgc3AudG8pXFxuICAgICAgICAgICAgaWYgKG0udGl0bGUgJiYgIXRpdGxlKSB0aXRsZSA9IG0udGl0bGU7XFxuICAgICAgICAgICAgaWYgKG0uY29sbGFwc2VkICYmICghY29sbGFwc2VkIHx8IGNvbXBhcmVDb2xsYXBzZWRNYXJrZXJzKGNvbGxhcHNlZC5tYXJrZXIsIG0pIDwgMCkpXFxuICAgICAgICAgICAgICBjb2xsYXBzZWQgPSBzcDtcXG4gICAgICAgICAgfSBlbHNlIGlmIChzcC5mcm9tID4gcG9zICYmIG5leHRDaGFuZ2UgPiBzcC5mcm9tKSB7XFxuICAgICAgICAgICAgbmV4dENoYW5nZSA9IHNwLmZyb207XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIGlmIChlbmRTdHlsZXMpIGZvciAodmFyIGogPSAwOyBqIDwgZW5kU3R5bGVzLmxlbmd0aDsgaiArPSAyKVxcbiAgICAgICAgICBpZiAoZW5kU3R5bGVzW2ogKyAxXSA9PSBuZXh0Q2hhbmdlKSBzcGFuRW5kU3R5bGUgKz0gXFxcIiBcXFwiICsgZW5kU3R5bGVzW2pdXFxuXFxuICAgICAgICBpZiAoIWNvbGxhcHNlZCB8fCBjb2xsYXBzZWQuZnJvbSA9PSBwb3MpIGZvciAodmFyIGogPSAwOyBqIDwgZm91bmRCb29rbWFya3MubGVuZ3RoOyArK2opXFxuICAgICAgICAgIGJ1aWxkQ29sbGFwc2VkU3BhbihidWlsZGVyLCAwLCBmb3VuZEJvb2ttYXJrc1tqXSk7XFxuICAgICAgICBpZiAoY29sbGFwc2VkICYmIChjb2xsYXBzZWQuZnJvbSB8fCAwKSA9PSBwb3MpIHtcXG4gICAgICAgICAgYnVpbGRDb2xsYXBzZWRTcGFuKGJ1aWxkZXIsIChjb2xsYXBzZWQudG8gPT0gbnVsbCA/IGxlbiArIDEgOiBjb2xsYXBzZWQudG8pIC0gcG9zLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sbGFwc2VkLm1hcmtlciwgY29sbGFwc2VkLmZyb20gPT0gbnVsbCk7XFxuICAgICAgICAgIGlmIChjb2xsYXBzZWQudG8gPT0gbnVsbCkgcmV0dXJuO1xcbiAgICAgICAgICBpZiAoY29sbGFwc2VkLnRvID09IHBvcykgY29sbGFwc2VkID0gZmFsc2U7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICAgIGlmIChwb3MgPj0gbGVuKSBicmVhaztcXG5cXG4gICAgICB2YXIgdXB0byA9IE1hdGgubWluKGxlbiwgbmV4dENoYW5nZSk7XFxuICAgICAgd2hpbGUgKHRydWUpIHtcXG4gICAgICAgIGlmICh0ZXh0KSB7XFxuICAgICAgICAgIHZhciBlbmQgPSBwb3MgKyB0ZXh0Lmxlbmd0aDtcXG4gICAgICAgICAgaWYgKCFjb2xsYXBzZWQpIHtcXG4gICAgICAgICAgICB2YXIgdG9rZW5UZXh0ID0gZW5kID4gdXB0byA/IHRleHQuc2xpY2UoMCwgdXB0byAtIHBvcykgOiB0ZXh0O1xcbiAgICAgICAgICAgIGJ1aWxkZXIuYWRkVG9rZW4oYnVpbGRlciwgdG9rZW5UZXh0LCBzdHlsZSA/IHN0eWxlICsgc3BhblN0eWxlIDogc3BhblN0eWxlLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3BhblN0YXJ0U3R5bGUsIHBvcyArIHRva2VuVGV4dC5sZW5ndGggPT0gbmV4dENoYW5nZSA/IHNwYW5FbmRTdHlsZSA6IFxcXCJcXFwiLCB0aXRsZSwgY3NzKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgICBpZiAoZW5kID49IHVwdG8pIHt0ZXh0ID0gdGV4dC5zbGljZSh1cHRvIC0gcG9zKTsgcG9zID0gdXB0bzsgYnJlYWs7fVxcbiAgICAgICAgICBwb3MgPSBlbmQ7XFxuICAgICAgICAgIHNwYW5TdGFydFN0eWxlID0gXFxcIlxcXCI7XFxuICAgICAgICB9XFxuICAgICAgICB0ZXh0ID0gYWxsVGV4dC5zbGljZShhdCwgYXQgPSBzdHlsZXNbaSsrXSk7XFxuICAgICAgICBzdHlsZSA9IGludGVycHJldFRva2VuU3R5bGUoc3R5bGVzW2krK10sIGJ1aWxkZXIuY20ub3B0aW9ucyk7XFxuICAgICAgfVxcbiAgICB9XFxuICB9XFxuXFxuICAvLyBET0NVTUVOVCBEQVRBIFNUUlVDVFVSRVxcblxcbiAgLy8gQnkgZGVmYXVsdCwgdXBkYXRlcyB0aGF0IHN0YXJ0IGFuZCBlbmQgYXQgdGhlIGJlZ2lubmluZyBvZiBhIGxpbmVcXG4gIC8vIGFyZSB0cmVhdGVkIHNwZWNpYWxseSwgaW4gb3JkZXIgdG8gbWFrZSB0aGUgYXNzb2NpYXRpb24gb2YgbGluZVxcbiAgLy8gd2lkZ2V0cyBhbmQgbWFya2VyIGVsZW1lbnRzIHdpdGggdGhlIHRleHQgYmVoYXZlIG1vcmUgaW50dWl0aXZlLlxcbiAgZnVuY3Rpb24gaXNXaG9sZUxpbmVVcGRhdGUoZG9jLCBjaGFuZ2UpIHtcXG4gICAgcmV0dXJuIGNoYW5nZS5mcm9tLmNoID09IDAgJiYgY2hhbmdlLnRvLmNoID09IDAgJiYgbHN0KGNoYW5nZS50ZXh0KSA9PSBcXFwiXFxcIiAmJlxcbiAgICAgICghZG9jLmNtIHx8IGRvYy5jbS5vcHRpb25zLndob2xlTGluZVVwZGF0ZUJlZm9yZSk7XFxuICB9XFxuXFxuICAvLyBQZXJmb3JtIGEgY2hhbmdlIG9uIHRoZSBkb2N1bWVudCBkYXRhIHN0cnVjdHVyZS5cXG4gIGZ1bmN0aW9uIHVwZGF0ZURvYyhkb2MsIGNoYW5nZSwgbWFya2VkU3BhbnMsIGVzdGltYXRlSGVpZ2h0KSB7XFxuICAgIGZ1bmN0aW9uIHNwYW5zRm9yKG4pIHtyZXR1cm4gbWFya2VkU3BhbnMgPyBtYXJrZWRTcGFuc1tuXSA6IG51bGw7fVxcbiAgICBmdW5jdGlvbiB1cGRhdGUobGluZSwgdGV4dCwgc3BhbnMpIHtcXG4gICAgICB1cGRhdGVMaW5lKGxpbmUsIHRleHQsIHNwYW5zLCBlc3RpbWF0ZUhlaWdodCk7XFxuICAgICAgc2lnbmFsTGF0ZXIobGluZSwgXFxcImNoYW5nZVxcXCIsIGxpbmUsIGNoYW5nZSk7XFxuICAgIH1cXG4gICAgZnVuY3Rpb24gbGluZXNGb3Ioc3RhcnQsIGVuZCkge1xcbiAgICAgIGZvciAodmFyIGkgPSBzdGFydCwgcmVzdWx0ID0gW107IGkgPCBlbmQ7ICsraSlcXG4gICAgICAgIHJlc3VsdC5wdXNoKG5ldyBMaW5lKHRleHRbaV0sIHNwYW5zRm9yKGkpLCBlc3RpbWF0ZUhlaWdodCkpO1xcbiAgICAgIHJldHVybiByZXN1bHQ7XFxuICAgIH1cXG5cXG4gICAgdmFyIGZyb20gPSBjaGFuZ2UuZnJvbSwgdG8gPSBjaGFuZ2UudG8sIHRleHQgPSBjaGFuZ2UudGV4dDtcXG4gICAgdmFyIGZpcnN0TGluZSA9IGdldExpbmUoZG9jLCBmcm9tLmxpbmUpLCBsYXN0TGluZSA9IGdldExpbmUoZG9jLCB0by5saW5lKTtcXG4gICAgdmFyIGxhc3RUZXh0ID0gbHN0KHRleHQpLCBsYXN0U3BhbnMgPSBzcGFuc0Zvcih0ZXh0Lmxlbmd0aCAtIDEpLCBubGluZXMgPSB0by5saW5lIC0gZnJvbS5saW5lO1xcblxcbiAgICAvLyBBZGp1c3QgdGhlIGxpbmUgc3RydWN0dXJlXFxuICAgIGlmIChjaGFuZ2UuZnVsbCkge1xcbiAgICAgIGRvYy5pbnNlcnQoMCwgbGluZXNGb3IoMCwgdGV4dC5sZW5ndGgpKTtcXG4gICAgICBkb2MucmVtb3ZlKHRleHQubGVuZ3RoLCBkb2Muc2l6ZSAtIHRleHQubGVuZ3RoKTtcXG4gICAgfSBlbHNlIGlmIChpc1dob2xlTGluZVVwZGF0ZShkb2MsIGNoYW5nZSkpIHtcXG4gICAgICAvLyBUaGlzIGlzIGEgd2hvbGUtbGluZSByZXBsYWNlLiBUcmVhdGVkIHNwZWNpYWxseSB0byBtYWtlXFxuICAgICAgLy8gc3VyZSBsaW5lIG9iamVjdHMgbW92ZSB0aGUgd2F5IHRoZXkgYXJlIHN1cHBvc2VkIHRvLlxcbiAgICAgIHZhciBhZGRlZCA9IGxpbmVzRm9yKDAsIHRleHQubGVuZ3RoIC0gMSk7XFxuICAgICAgdXBkYXRlKGxhc3RMaW5lLCBsYXN0TGluZS50ZXh0LCBsYXN0U3BhbnMpO1xcbiAgICAgIGlmIChubGluZXMpIGRvYy5yZW1vdmUoZnJvbS5saW5lLCBubGluZXMpO1xcbiAgICAgIGlmIChhZGRlZC5sZW5ndGgpIGRvYy5pbnNlcnQoZnJvbS5saW5lLCBhZGRlZCk7XFxuICAgIH0gZWxzZSBpZiAoZmlyc3RMaW5lID09IGxhc3RMaW5lKSB7XFxuICAgICAgaWYgKHRleHQubGVuZ3RoID09IDEpIHtcXG4gICAgICAgIHVwZGF0ZShmaXJzdExpbmUsIGZpcnN0TGluZS50ZXh0LnNsaWNlKDAsIGZyb20uY2gpICsgbGFzdFRleHQgKyBmaXJzdExpbmUudGV4dC5zbGljZSh0by5jaCksIGxhc3RTcGFucyk7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIHZhciBhZGRlZCA9IGxpbmVzRm9yKDEsIHRleHQubGVuZ3RoIC0gMSk7XFxuICAgICAgICBhZGRlZC5wdXNoKG5ldyBMaW5lKGxhc3RUZXh0ICsgZmlyc3RMaW5lLnRleHQuc2xpY2UodG8uY2gpLCBsYXN0U3BhbnMsIGVzdGltYXRlSGVpZ2h0KSk7XFxuICAgICAgICB1cGRhdGUoZmlyc3RMaW5lLCBmaXJzdExpbmUudGV4dC5zbGljZSgwLCBmcm9tLmNoKSArIHRleHRbMF0sIHNwYW5zRm9yKDApKTtcXG4gICAgICAgIGRvYy5pbnNlcnQoZnJvbS5saW5lICsgMSwgYWRkZWQpO1xcbiAgICAgIH1cXG4gICAgfSBlbHNlIGlmICh0ZXh0Lmxlbmd0aCA9PSAxKSB7XFxuICAgICAgdXBkYXRlKGZpcnN0TGluZSwgZmlyc3RMaW5lLnRleHQuc2xpY2UoMCwgZnJvbS5jaCkgKyB0ZXh0WzBdICsgbGFzdExpbmUudGV4dC5zbGljZSh0by5jaCksIHNwYW5zRm9yKDApKTtcXG4gICAgICBkb2MucmVtb3ZlKGZyb20ubGluZSArIDEsIG5saW5lcyk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgdXBkYXRlKGZpcnN0TGluZSwgZmlyc3RMaW5lLnRleHQuc2xpY2UoMCwgZnJvbS5jaCkgKyB0ZXh0WzBdLCBzcGFuc0ZvcigwKSk7XFxuICAgICAgdXBkYXRlKGxhc3RMaW5lLCBsYXN0VGV4dCArIGxhc3RMaW5lLnRleHQuc2xpY2UodG8uY2gpLCBsYXN0U3BhbnMpO1xcbiAgICAgIHZhciBhZGRlZCA9IGxpbmVzRm9yKDEsIHRleHQubGVuZ3RoIC0gMSk7XFxuICAgICAgaWYgKG5saW5lcyA+IDEpIGRvYy5yZW1vdmUoZnJvbS5saW5lICsgMSwgbmxpbmVzIC0gMSk7XFxuICAgICAgZG9jLmluc2VydChmcm9tLmxpbmUgKyAxLCBhZGRlZCk7XFxuICAgIH1cXG5cXG4gICAgc2lnbmFsTGF0ZXIoZG9jLCBcXFwiY2hhbmdlXFxcIiwgZG9jLCBjaGFuZ2UpO1xcbiAgfVxcblxcbiAgLy8gVGhlIGRvY3VtZW50IGlzIHJlcHJlc2VudGVkIGFzIGEgQlRyZWUgY29uc2lzdGluZyBvZiBsZWF2ZXMsIHdpdGhcXG4gIC8vIGNodW5rIG9mIGxpbmVzIGluIHRoZW0sIGFuZCBicmFuY2hlcywgd2l0aCB1cCB0byB0ZW4gbGVhdmVzIG9yXFxuICAvLyBvdGhlciBicmFuY2ggbm9kZXMgYmVsb3cgdGhlbS4gVGhlIHRvcCBub2RlIGlzIGFsd2F5cyBhIGJyYW5jaFxcbiAgLy8gbm9kZSwgYW5kIGlzIHRoZSBkb2N1bWVudCBvYmplY3QgaXRzZWxmIChtZWFuaW5nIGl0IGhhc1xcbiAgLy8gYWRkaXRpb25hbCBtZXRob2RzIGFuZCBwcm9wZXJ0aWVzKS5cXG4gIC8vXFxuICAvLyBBbGwgbm9kZXMgaGF2ZSBwYXJlbnQgbGlua3MuIFRoZSB0cmVlIGlzIHVzZWQgYm90aCB0byBnbyBmcm9tXFxuICAvLyBsaW5lIG51bWJlcnMgdG8gbGluZSBvYmplY3RzLCBhbmQgdG8gZ28gZnJvbSBvYmplY3RzIHRvIG51bWJlcnMuXFxuICAvLyBJdCBhbHNvIGluZGV4ZXMgYnkgaGVpZ2h0LCBhbmQgaXMgdXNlZCB0byBjb252ZXJ0IGJldHdlZW4gaGVpZ2h0XFxuICAvLyBhbmQgbGluZSBvYmplY3QsIGFuZCB0byBmaW5kIHRoZSB0b3RhbCBoZWlnaHQgb2YgdGhlIGRvY3VtZW50LlxcbiAgLy9cXG4gIC8vIFNlZSBhbHNvIGh0dHA6Ly9tYXJpam5oYXZlcmJla2UubmwvYmxvZy9jb2RlbWlycm9yLWxpbmUtdHJlZS5odG1sXFxuXFxuICBmdW5jdGlvbiBMZWFmQ2h1bmsobGluZXMpIHtcXG4gICAgdGhpcy5saW5lcyA9IGxpbmVzO1xcbiAgICB0aGlzLnBhcmVudCA9IG51bGw7XFxuICAgIGZvciAodmFyIGkgPSAwLCBoZWlnaHQgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyArK2kpIHtcXG4gICAgICBsaW5lc1tpXS5wYXJlbnQgPSB0aGlzO1xcbiAgICAgIGhlaWdodCArPSBsaW5lc1tpXS5oZWlnaHQ7XFxuICAgIH1cXG4gICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XFxuICB9XFxuXFxuICBMZWFmQ2h1bmsucHJvdG90eXBlID0ge1xcbiAgICBjaHVua1NpemU6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5saW5lcy5sZW5ndGg7IH0sXFxuICAgIC8vIFJlbW92ZSB0aGUgbiBsaW5lcyBhdCBvZmZzZXQgJ2F0Jy5cXG4gICAgcmVtb3ZlSW5uZXI6IGZ1bmN0aW9uKGF0LCBuKSB7XFxuICAgICAgZm9yICh2YXIgaSA9IGF0LCBlID0gYXQgKyBuOyBpIDwgZTsgKytpKSB7XFxuICAgICAgICB2YXIgbGluZSA9IHRoaXMubGluZXNbaV07XFxuICAgICAgICB0aGlzLmhlaWdodCAtPSBsaW5lLmhlaWdodDtcXG4gICAgICAgIGNsZWFuVXBMaW5lKGxpbmUpO1xcbiAgICAgICAgc2lnbmFsTGF0ZXIobGluZSwgXFxcImRlbGV0ZVxcXCIpO1xcbiAgICAgIH1cXG4gICAgICB0aGlzLmxpbmVzLnNwbGljZShhdCwgbik7XFxuICAgIH0sXFxuICAgIC8vIEhlbHBlciB1c2VkIHRvIGNvbGxhcHNlIGEgc21hbGwgYnJhbmNoIGludG8gYSBzaW5nbGUgbGVhZi5cXG4gICAgY29sbGFwc2U6IGZ1bmN0aW9uKGxpbmVzKSB7XFxuICAgICAgbGluZXMucHVzaC5hcHBseShsaW5lcywgdGhpcy5saW5lcyk7XFxuICAgIH0sXFxuICAgIC8vIEluc2VydCB0aGUgZ2l2ZW4gYXJyYXkgb2YgbGluZXMgYXQgb2Zmc2V0ICdhdCcsIGNvdW50IHRoZW0gYXNcXG4gICAgLy8gaGF2aW5nIHRoZSBnaXZlbiBoZWlnaHQuXFxuICAgIGluc2VydElubmVyOiBmdW5jdGlvbihhdCwgbGluZXMsIGhlaWdodCkge1xcbiAgICAgIHRoaXMuaGVpZ2h0ICs9IGhlaWdodDtcXG4gICAgICB0aGlzLmxpbmVzID0gdGhpcy5saW5lcy5zbGljZSgwLCBhdCkuY29uY2F0KGxpbmVzKS5jb25jYXQodGhpcy5saW5lcy5zbGljZShhdCkpO1xcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyArK2kpIGxpbmVzW2ldLnBhcmVudCA9IHRoaXM7XFxuICAgIH0sXFxuICAgIC8vIFVzZWQgdG8gaXRlcmF0ZSBvdmVyIGEgcGFydCBvZiB0aGUgdHJlZS5cXG4gICAgaXRlck46IGZ1bmN0aW9uKGF0LCBuLCBvcCkge1xcbiAgICAgIGZvciAodmFyIGUgPSBhdCArIG47IGF0IDwgZTsgKythdClcXG4gICAgICAgIGlmIChvcCh0aGlzLmxpbmVzW2F0XSkpIHJldHVybiB0cnVlO1xcbiAgICB9XFxuICB9O1xcblxcbiAgZnVuY3Rpb24gQnJhbmNoQ2h1bmsoY2hpbGRyZW4pIHtcXG4gICAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xcbiAgICB2YXIgc2l6ZSA9IDAsIGhlaWdodCA9IDA7XFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyArK2kpIHtcXG4gICAgICB2YXIgY2ggPSBjaGlsZHJlbltpXTtcXG4gICAgICBzaXplICs9IGNoLmNodW5rU2l6ZSgpOyBoZWlnaHQgKz0gY2guaGVpZ2h0O1xcbiAgICAgIGNoLnBhcmVudCA9IHRoaXM7XFxuICAgIH1cXG4gICAgdGhpcy5zaXplID0gc2l6ZTtcXG4gICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XFxuICAgIHRoaXMucGFyZW50ID0gbnVsbDtcXG4gIH1cXG5cXG4gIEJyYW5jaENodW5rLnByb3RvdHlwZSA9IHtcXG4gICAgY2h1bmtTaXplOiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuc2l6ZTsgfSxcXG4gICAgcmVtb3ZlSW5uZXI6IGZ1bmN0aW9uKGF0LCBuKSB7XFxuICAgICAgdGhpcy5zaXplIC09IG47XFxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgKytpKSB7XFxuICAgICAgICB2YXIgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW2ldLCBzeiA9IGNoaWxkLmNodW5rU2l6ZSgpO1xcbiAgICAgICAgaWYgKGF0IDwgc3opIHtcXG4gICAgICAgICAgdmFyIHJtID0gTWF0aC5taW4obiwgc3ogLSBhdCksIG9sZEhlaWdodCA9IGNoaWxkLmhlaWdodDtcXG4gICAgICAgICAgY2hpbGQucmVtb3ZlSW5uZXIoYXQsIHJtKTtcXG4gICAgICAgICAgdGhpcy5oZWlnaHQgLT0gb2xkSGVpZ2h0IC0gY2hpbGQuaGVpZ2h0O1xcbiAgICAgICAgICBpZiAoc3ogPT0gcm0pIHsgdGhpcy5jaGlsZHJlbi5zcGxpY2UoaS0tLCAxKTsgY2hpbGQucGFyZW50ID0gbnVsbDsgfVxcbiAgICAgICAgICBpZiAoKG4gLT0gcm0pID09IDApIGJyZWFrO1xcbiAgICAgICAgICBhdCA9IDA7XFxuICAgICAgICB9IGVsc2UgYXQgLT0gc3o7XFxuICAgICAgfVxcbiAgICAgIC8vIElmIHRoZSByZXN1bHQgaXMgc21hbGxlciB0aGFuIDI1IGxpbmVzLCBlbnN1cmUgdGhhdCBpdCBpcyBhXFxuICAgICAgLy8gc2luZ2xlIGxlYWYgbm9kZS5cXG4gICAgICBpZiAodGhpcy5zaXplIC0gbiA8IDI1ICYmXFxuICAgICAgICAgICh0aGlzLmNoaWxkcmVuLmxlbmd0aCA+IDEgfHwgISh0aGlzLmNoaWxkcmVuWzBdIGluc3RhbmNlb2YgTGVhZkNodW5rKSkpIHtcXG4gICAgICAgIHZhciBsaW5lcyA9IFtdO1xcbiAgICAgICAgdGhpcy5jb2xsYXBzZShsaW5lcyk7XFxuICAgICAgICB0aGlzLmNoaWxkcmVuID0gW25ldyBMZWFmQ2h1bmsobGluZXMpXTtcXG4gICAgICAgIHRoaXMuY2hpbGRyZW5bMF0ucGFyZW50ID0gdGhpcztcXG4gICAgICB9XFxuICAgIH0sXFxuICAgIGNvbGxhcHNlOiBmdW5jdGlvbihsaW5lcykge1xcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7ICsraSkgdGhpcy5jaGlsZHJlbltpXS5jb2xsYXBzZShsaW5lcyk7XFxuICAgIH0sXFxuICAgIGluc2VydElubmVyOiBmdW5jdGlvbihhdCwgbGluZXMsIGhlaWdodCkge1xcbiAgICAgIHRoaXMuc2l6ZSArPSBsaW5lcy5sZW5ndGg7XFxuICAgICAgdGhpcy5oZWlnaHQgKz0gaGVpZ2h0O1xcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7ICsraSkge1xcbiAgICAgICAgdmFyIGNoaWxkID0gdGhpcy5jaGlsZHJlbltpXSwgc3ogPSBjaGlsZC5jaHVua1NpemUoKTtcXG4gICAgICAgIGlmIChhdCA8PSBzeikge1xcbiAgICAgICAgICBjaGlsZC5pbnNlcnRJbm5lcihhdCwgbGluZXMsIGhlaWdodCk7XFxuICAgICAgICAgIGlmIChjaGlsZC5saW5lcyAmJiBjaGlsZC5saW5lcy5sZW5ndGggPiA1MCkge1xcbiAgICAgICAgICAgIC8vIFRvIGF2b2lkIG1lbW9yeSB0aHJhc2hpbmcgd2hlbiBjaGlsZC5saW5lcyBpcyBodWdlIChlLmcuIGZpcnN0IHZpZXcgb2YgYSBsYXJnZSBmaWxlKSwgaXQncyBuZXZlciBzcGxpY2VkLlxcbiAgICAgICAgICAgIC8vIEluc3RlYWQsIHNtYWxsIHNsaWNlcyBhcmUgdGFrZW4uIFRoZXkncmUgdGFrZW4gaW4gb3JkZXIgYmVjYXVzZSBzZXF1ZW50aWFsIG1lbW9yeSBhY2Nlc3NlcyBhcmUgZmFzdGVzdC5cXG4gICAgICAgICAgICB2YXIgcmVtYWluaW5nID0gY2hpbGQubGluZXMubGVuZ3RoICUgMjUgKyAyNVxcbiAgICAgICAgICAgIGZvciAodmFyIHBvcyA9IHJlbWFpbmluZzsgcG9zIDwgY2hpbGQubGluZXMubGVuZ3RoOykge1xcbiAgICAgICAgICAgICAgdmFyIGxlYWYgPSBuZXcgTGVhZkNodW5rKGNoaWxkLmxpbmVzLnNsaWNlKHBvcywgcG9zICs9IDI1KSk7XFxuICAgICAgICAgICAgICBjaGlsZC5oZWlnaHQgLT0gbGVhZi5oZWlnaHQ7XFxuICAgICAgICAgICAgICB0aGlzLmNoaWxkcmVuLnNwbGljZSgrK2ksIDAsIGxlYWYpO1xcbiAgICAgICAgICAgICAgbGVhZi5wYXJlbnQgPSB0aGlzO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBjaGlsZC5saW5lcyA9IGNoaWxkLmxpbmVzLnNsaWNlKDAsIHJlbWFpbmluZyk7XFxuICAgICAgICAgICAgdGhpcy5tYXliZVNwaWxsKCk7XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgYnJlYWs7XFxuICAgICAgICB9XFxuICAgICAgICBhdCAtPSBzejtcXG4gICAgICB9XFxuICAgIH0sXFxuICAgIC8vIFdoZW4gYSBub2RlIGhhcyBncm93biwgY2hlY2sgd2hldGhlciBpdCBzaG91bGQgYmUgc3BsaXQuXFxuICAgIG1heWJlU3BpbGw6IGZ1bmN0aW9uKCkge1xcbiAgICAgIGlmICh0aGlzLmNoaWxkcmVuLmxlbmd0aCA8PSAxMCkgcmV0dXJuO1xcbiAgICAgIHZhciBtZSA9IHRoaXM7XFxuICAgICAgZG8ge1xcbiAgICAgICAgdmFyIHNwaWxsZWQgPSBtZS5jaGlsZHJlbi5zcGxpY2UobWUuY2hpbGRyZW4ubGVuZ3RoIC0gNSwgNSk7XFxuICAgICAgICB2YXIgc2libGluZyA9IG5ldyBCcmFuY2hDaHVuayhzcGlsbGVkKTtcXG4gICAgICAgIGlmICghbWUucGFyZW50KSB7IC8vIEJlY29tZSB0aGUgcGFyZW50IG5vZGVcXG4gICAgICAgICAgdmFyIGNvcHkgPSBuZXcgQnJhbmNoQ2h1bmsobWUuY2hpbGRyZW4pO1xcbiAgICAgICAgICBjb3B5LnBhcmVudCA9IG1lO1xcbiAgICAgICAgICBtZS5jaGlsZHJlbiA9IFtjb3B5LCBzaWJsaW5nXTtcXG4gICAgICAgICAgbWUgPSBjb3B5O1xcbiAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICBtZS5zaXplIC09IHNpYmxpbmcuc2l6ZTtcXG4gICAgICAgICAgbWUuaGVpZ2h0IC09IHNpYmxpbmcuaGVpZ2h0O1xcbiAgICAgICAgICB2YXIgbXlJbmRleCA9IGluZGV4T2YobWUucGFyZW50LmNoaWxkcmVuLCBtZSk7XFxuICAgICAgICAgIG1lLnBhcmVudC5jaGlsZHJlbi5zcGxpY2UobXlJbmRleCArIDEsIDAsIHNpYmxpbmcpO1xcbiAgICAgICAgfVxcbiAgICAgICAgc2libGluZy5wYXJlbnQgPSBtZS5wYXJlbnQ7XFxuICAgICAgfSB3aGlsZSAobWUuY2hpbGRyZW4ubGVuZ3RoID4gMTApO1xcbiAgICAgIG1lLnBhcmVudC5tYXliZVNwaWxsKCk7XFxuICAgIH0sXFxuICAgIGl0ZXJOOiBmdW5jdGlvbihhdCwgbiwgb3ApIHtcXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyArK2kpIHtcXG4gICAgICAgIHZhciBjaGlsZCA9IHRoaXMuY2hpbGRyZW5baV0sIHN6ID0gY2hpbGQuY2h1bmtTaXplKCk7XFxuICAgICAgICBpZiAoYXQgPCBzeikge1xcbiAgICAgICAgICB2YXIgdXNlZCA9IE1hdGgubWluKG4sIHN6IC0gYXQpO1xcbiAgICAgICAgICBpZiAoY2hpbGQuaXRlck4oYXQsIHVzZWQsIG9wKSkgcmV0dXJuIHRydWU7XFxuICAgICAgICAgIGlmICgobiAtPSB1c2VkKSA9PSAwKSBicmVhaztcXG4gICAgICAgICAgYXQgPSAwO1xcbiAgICAgICAgfSBlbHNlIGF0IC09IHN6O1xcbiAgICAgIH1cXG4gICAgfVxcbiAgfTtcXG5cXG4gIHZhciBuZXh0RG9jSWQgPSAwO1xcbiAgdmFyIERvYyA9IENvZGVNaXJyb3IuRG9jID0gZnVuY3Rpb24odGV4dCwgbW9kZSwgZmlyc3RMaW5lLCBsaW5lU2VwKSB7XFxuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBEb2MpKSByZXR1cm4gbmV3IERvYyh0ZXh0LCBtb2RlLCBmaXJzdExpbmUsIGxpbmVTZXApO1xcbiAgICBpZiAoZmlyc3RMaW5lID09IG51bGwpIGZpcnN0TGluZSA9IDA7XFxuXFxuICAgIEJyYW5jaENodW5rLmNhbGwodGhpcywgW25ldyBMZWFmQ2h1bmsoW25ldyBMaW5lKFxcXCJcXFwiLCBudWxsKV0pXSk7XFxuICAgIHRoaXMuZmlyc3QgPSBmaXJzdExpbmU7XFxuICAgIHRoaXMuc2Nyb2xsVG9wID0gdGhpcy5zY3JvbGxMZWZ0ID0gMDtcXG4gICAgdGhpcy5jYW50RWRpdCA9IGZhbHNlO1xcbiAgICB0aGlzLmNsZWFuR2VuZXJhdGlvbiA9IDE7XFxuICAgIHRoaXMuZnJvbnRpZXIgPSBmaXJzdExpbmU7XFxuICAgIHZhciBzdGFydCA9IFBvcyhmaXJzdExpbmUsIDApO1xcbiAgICB0aGlzLnNlbCA9IHNpbXBsZVNlbGVjdGlvbihzdGFydCk7XFxuICAgIHRoaXMuaGlzdG9yeSA9IG5ldyBIaXN0b3J5KG51bGwpO1xcbiAgICB0aGlzLmlkID0gKytuZXh0RG9jSWQ7XFxuICAgIHRoaXMubW9kZU9wdGlvbiA9IG1vZGU7XFxuICAgIHRoaXMubGluZVNlcCA9IGxpbmVTZXA7XFxuICAgIHRoaXMuZXh0ZW5kID0gZmFsc2U7XFxuXFxuICAgIGlmICh0eXBlb2YgdGV4dCA9PSBcXFwic3RyaW5nXFxcIikgdGV4dCA9IHRoaXMuc3BsaXRMaW5lcyh0ZXh0KTtcXG4gICAgdXBkYXRlRG9jKHRoaXMsIHtmcm9tOiBzdGFydCwgdG86IHN0YXJ0LCB0ZXh0OiB0ZXh0fSk7XFxuICAgIHNldFNlbGVjdGlvbih0aGlzLCBzaW1wbGVTZWxlY3Rpb24oc3RhcnQpLCBzZWxfZG9udFNjcm9sbCk7XFxuICB9O1xcblxcbiAgRG9jLnByb3RvdHlwZSA9IGNyZWF0ZU9iaihCcmFuY2hDaHVuay5wcm90b3R5cGUsIHtcXG4gICAgY29uc3RydWN0b3I6IERvYyxcXG4gICAgLy8gSXRlcmF0ZSBvdmVyIHRoZSBkb2N1bWVudC4gU3VwcG9ydHMgdHdvIGZvcm1zIC0tIHdpdGggb25seSBvbmVcXG4gICAgLy8gYXJndW1lbnQsIGl0IGNhbGxzIHRoYXQgZm9yIGVhY2ggbGluZSBpbiB0aGUgZG9jdW1lbnQuIFdpdGhcXG4gICAgLy8gdGhyZWUsIGl0IGl0ZXJhdGVzIG92ZXIgdGhlIHJhbmdlIGdpdmVuIGJ5IHRoZSBmaXJzdCB0d28gKHdpdGhcXG4gICAgLy8gdGhlIHNlY29uZCBiZWluZyBub24taW5jbHVzaXZlKS5cXG4gICAgaXRlcjogZnVuY3Rpb24oZnJvbSwgdG8sIG9wKSB7XFxuICAgICAgaWYgKG9wKSB0aGlzLml0ZXJOKGZyb20gLSB0aGlzLmZpcnN0LCB0byAtIGZyb20sIG9wKTtcXG4gICAgICBlbHNlIHRoaXMuaXRlck4odGhpcy5maXJzdCwgdGhpcy5maXJzdCArIHRoaXMuc2l6ZSwgZnJvbSk7XFxuICAgIH0sXFxuXFxuICAgIC8vIE5vbi1wdWJsaWMgaW50ZXJmYWNlIGZvciBhZGRpbmcgYW5kIHJlbW92aW5nIGxpbmVzLlxcbiAgICBpbnNlcnQ6IGZ1bmN0aW9uKGF0LCBsaW5lcykge1xcbiAgICAgIHZhciBoZWlnaHQgPSAwO1xcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyArK2kpIGhlaWdodCArPSBsaW5lc1tpXS5oZWlnaHQ7XFxuICAgICAgdGhpcy5pbnNlcnRJbm5lcihhdCAtIHRoaXMuZmlyc3QsIGxpbmVzLCBoZWlnaHQpO1xcbiAgICB9LFxcbiAgICByZW1vdmU6IGZ1bmN0aW9uKGF0LCBuKSB7IHRoaXMucmVtb3ZlSW5uZXIoYXQgLSB0aGlzLmZpcnN0LCBuKTsgfSxcXG5cXG4gICAgLy8gRnJvbSBoZXJlLCB0aGUgbWV0aG9kcyBhcmUgcGFydCBvZiB0aGUgcHVibGljIGludGVyZmFjZS4gTW9zdFxcbiAgICAvLyBhcmUgYWxzbyBhdmFpbGFibGUgZnJvbSBDb2RlTWlycm9yIChlZGl0b3IpIGluc3RhbmNlcy5cXG5cXG4gICAgZ2V0VmFsdWU6IGZ1bmN0aW9uKGxpbmVTZXApIHtcXG4gICAgICB2YXIgbGluZXMgPSBnZXRMaW5lcyh0aGlzLCB0aGlzLmZpcnN0LCB0aGlzLmZpcnN0ICsgdGhpcy5zaXplKTtcXG4gICAgICBpZiAobGluZVNlcCA9PT0gZmFsc2UpIHJldHVybiBsaW5lcztcXG4gICAgICByZXR1cm4gbGluZXMuam9pbihsaW5lU2VwIHx8IHRoaXMubGluZVNlcGFyYXRvcigpKTtcXG4gICAgfSxcXG4gICAgc2V0VmFsdWU6IGRvY01ldGhvZE9wKGZ1bmN0aW9uKGNvZGUpIHtcXG4gICAgICB2YXIgdG9wID0gUG9zKHRoaXMuZmlyc3QsIDApLCBsYXN0ID0gdGhpcy5maXJzdCArIHRoaXMuc2l6ZSAtIDE7XFxuICAgICAgbWFrZUNoYW5nZSh0aGlzLCB7ZnJvbTogdG9wLCB0bzogUG9zKGxhc3QsIGdldExpbmUodGhpcywgbGFzdCkudGV4dC5sZW5ndGgpLFxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IHRoaXMuc3BsaXRMaW5lcyhjb2RlKSwgb3JpZ2luOiBcXFwic2V0VmFsdWVcXFwiLCBmdWxsOiB0cnVlfSwgdHJ1ZSk7XFxuICAgICAgc2V0U2VsZWN0aW9uKHRoaXMsIHNpbXBsZVNlbGVjdGlvbih0b3ApKTtcXG4gICAgfSksXFxuICAgIHJlcGxhY2VSYW5nZTogZnVuY3Rpb24oY29kZSwgZnJvbSwgdG8sIG9yaWdpbikge1xcbiAgICAgIGZyb20gPSBjbGlwUG9zKHRoaXMsIGZyb20pO1xcbiAgICAgIHRvID0gdG8gPyBjbGlwUG9zKHRoaXMsIHRvKSA6IGZyb207XFxuICAgICAgcmVwbGFjZVJhbmdlKHRoaXMsIGNvZGUsIGZyb20sIHRvLCBvcmlnaW4pO1xcbiAgICB9LFxcbiAgICBnZXRSYW5nZTogZnVuY3Rpb24oZnJvbSwgdG8sIGxpbmVTZXApIHtcXG4gICAgICB2YXIgbGluZXMgPSBnZXRCZXR3ZWVuKHRoaXMsIGNsaXBQb3ModGhpcywgZnJvbSksIGNsaXBQb3ModGhpcywgdG8pKTtcXG4gICAgICBpZiAobGluZVNlcCA9PT0gZmFsc2UpIHJldHVybiBsaW5lcztcXG4gICAgICByZXR1cm4gbGluZXMuam9pbihsaW5lU2VwIHx8IHRoaXMubGluZVNlcGFyYXRvcigpKTtcXG4gICAgfSxcXG5cXG4gICAgZ2V0TGluZTogZnVuY3Rpb24obGluZSkge3ZhciBsID0gdGhpcy5nZXRMaW5lSGFuZGxlKGxpbmUpOyByZXR1cm4gbCAmJiBsLnRleHQ7fSxcXG5cXG4gICAgZ2V0TGluZUhhbmRsZTogZnVuY3Rpb24obGluZSkge2lmIChpc0xpbmUodGhpcywgbGluZSkpIHJldHVybiBnZXRMaW5lKHRoaXMsIGxpbmUpO30sXFxuICAgIGdldExpbmVOdW1iZXI6IGZ1bmN0aW9uKGxpbmUpIHtyZXR1cm4gbGluZU5vKGxpbmUpO30sXFxuXFxuICAgIGdldExpbmVIYW5kbGVWaXN1YWxTdGFydDogZnVuY3Rpb24obGluZSkge1xcbiAgICAgIGlmICh0eXBlb2YgbGluZSA9PSBcXFwibnVtYmVyXFxcIikgbGluZSA9IGdldExpbmUodGhpcywgbGluZSk7XFxuICAgICAgcmV0dXJuIHZpc3VhbExpbmUobGluZSk7XFxuICAgIH0sXFxuXFxuICAgIGxpbmVDb3VudDogZnVuY3Rpb24oKSB7cmV0dXJuIHRoaXMuc2l6ZTt9LFxcbiAgICBmaXJzdExpbmU6IGZ1bmN0aW9uKCkge3JldHVybiB0aGlzLmZpcnN0O30sXFxuICAgIGxhc3RMaW5lOiBmdW5jdGlvbigpIHtyZXR1cm4gdGhpcy5maXJzdCArIHRoaXMuc2l6ZSAtIDE7fSxcXG5cXG4gICAgY2xpcFBvczogZnVuY3Rpb24ocG9zKSB7cmV0dXJuIGNsaXBQb3ModGhpcywgcG9zKTt9LFxcblxcbiAgICBnZXRDdXJzb3I6IGZ1bmN0aW9uKHN0YXJ0KSB7XFxuICAgICAgdmFyIHJhbmdlID0gdGhpcy5zZWwucHJpbWFyeSgpLCBwb3M7XFxuICAgICAgaWYgKHN0YXJ0ID09IG51bGwgfHwgc3RhcnQgPT0gXFxcImhlYWRcXFwiKSBwb3MgPSByYW5nZS5oZWFkO1xcbiAgICAgIGVsc2UgaWYgKHN0YXJ0ID09IFxcXCJhbmNob3JcXFwiKSBwb3MgPSByYW5nZS5hbmNob3I7XFxuICAgICAgZWxzZSBpZiAoc3RhcnQgPT0gXFxcImVuZFxcXCIgfHwgc3RhcnQgPT0gXFxcInRvXFxcIiB8fCBzdGFydCA9PT0gZmFsc2UpIHBvcyA9IHJhbmdlLnRvKCk7XFxuICAgICAgZWxzZSBwb3MgPSByYW5nZS5mcm9tKCk7XFxuICAgICAgcmV0dXJuIHBvcztcXG4gICAgfSxcXG4gICAgbGlzdFNlbGVjdGlvbnM6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5zZWwucmFuZ2VzOyB9LFxcbiAgICBzb21ldGhpbmdTZWxlY3RlZDogZnVuY3Rpb24oKSB7cmV0dXJuIHRoaXMuc2VsLnNvbWV0aGluZ1NlbGVjdGVkKCk7fSxcXG5cXG4gICAgc2V0Q3Vyc29yOiBkb2NNZXRob2RPcChmdW5jdGlvbihsaW5lLCBjaCwgb3B0aW9ucykge1xcbiAgICAgIHNldFNpbXBsZVNlbGVjdGlvbih0aGlzLCBjbGlwUG9zKHRoaXMsIHR5cGVvZiBsaW5lID09IFxcXCJudW1iZXJcXFwiID8gUG9zKGxpbmUsIGNoIHx8IDApIDogbGluZSksIG51bGwsIG9wdGlvbnMpO1xcbiAgICB9KSxcXG4gICAgc2V0U2VsZWN0aW9uOiBkb2NNZXRob2RPcChmdW5jdGlvbihhbmNob3IsIGhlYWQsIG9wdGlvbnMpIHtcXG4gICAgICBzZXRTaW1wbGVTZWxlY3Rpb24odGhpcywgY2xpcFBvcyh0aGlzLCBhbmNob3IpLCBjbGlwUG9zKHRoaXMsIGhlYWQgfHwgYW5jaG9yKSwgb3B0aW9ucyk7XFxuICAgIH0pLFxcbiAgICBleHRlbmRTZWxlY3Rpb246IGRvY01ldGhvZE9wKGZ1bmN0aW9uKGhlYWQsIG90aGVyLCBvcHRpb25zKSB7XFxuICAgICAgZXh0ZW5kU2VsZWN0aW9uKHRoaXMsIGNsaXBQb3ModGhpcywgaGVhZCksIG90aGVyICYmIGNsaXBQb3ModGhpcywgb3RoZXIpLCBvcHRpb25zKTtcXG4gICAgfSksXFxuICAgIGV4dGVuZFNlbGVjdGlvbnM6IGRvY01ldGhvZE9wKGZ1bmN0aW9uKGhlYWRzLCBvcHRpb25zKSB7XFxuICAgICAgZXh0ZW5kU2VsZWN0aW9ucyh0aGlzLCBjbGlwUG9zQXJyYXkodGhpcywgaGVhZHMpLCBvcHRpb25zKTtcXG4gICAgfSksXFxuICAgIGV4dGVuZFNlbGVjdGlvbnNCeTogZG9jTWV0aG9kT3AoZnVuY3Rpb24oZiwgb3B0aW9ucykge1xcbiAgICAgIHZhciBoZWFkcyA9IG1hcCh0aGlzLnNlbC5yYW5nZXMsIGYpO1xcbiAgICAgIGV4dGVuZFNlbGVjdGlvbnModGhpcywgY2xpcFBvc0FycmF5KHRoaXMsIGhlYWRzKSwgb3B0aW9ucyk7XFxuICAgIH0pLFxcbiAgICBzZXRTZWxlY3Rpb25zOiBkb2NNZXRob2RPcChmdW5jdGlvbihyYW5nZXMsIHByaW1hcnksIG9wdGlvbnMpIHtcXG4gICAgICBpZiAoIXJhbmdlcy5sZW5ndGgpIHJldHVybjtcXG4gICAgICBmb3IgKHZhciBpID0gMCwgb3V0ID0gW107IGkgPCByYW5nZXMubGVuZ3RoOyBpKyspXFxuICAgICAgICBvdXRbaV0gPSBuZXcgUmFuZ2UoY2xpcFBvcyh0aGlzLCByYW5nZXNbaV0uYW5jaG9yKSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBjbGlwUG9zKHRoaXMsIHJhbmdlc1tpXS5oZWFkKSk7XFxuICAgICAgaWYgKHByaW1hcnkgPT0gbnVsbCkgcHJpbWFyeSA9IE1hdGgubWluKHJhbmdlcy5sZW5ndGggLSAxLCB0aGlzLnNlbC5wcmltSW5kZXgpO1xcbiAgICAgIHNldFNlbGVjdGlvbih0aGlzLCBub3JtYWxpemVTZWxlY3Rpb24ob3V0LCBwcmltYXJ5KSwgb3B0aW9ucyk7XFxuICAgIH0pLFxcbiAgICBhZGRTZWxlY3Rpb246IGRvY01ldGhvZE9wKGZ1bmN0aW9uKGFuY2hvciwgaGVhZCwgb3B0aW9ucykge1xcbiAgICAgIHZhciByYW5nZXMgPSB0aGlzLnNlbC5yYW5nZXMuc2xpY2UoMCk7XFxuICAgICAgcmFuZ2VzLnB1c2gobmV3IFJhbmdlKGNsaXBQb3ModGhpcywgYW5jaG9yKSwgY2xpcFBvcyh0aGlzLCBoZWFkIHx8IGFuY2hvcikpKTtcXG4gICAgICBzZXRTZWxlY3Rpb24odGhpcywgbm9ybWFsaXplU2VsZWN0aW9uKHJhbmdlcywgcmFuZ2VzLmxlbmd0aCAtIDEpLCBvcHRpb25zKTtcXG4gICAgfSksXFxuXFxuICAgIGdldFNlbGVjdGlvbjogZnVuY3Rpb24obGluZVNlcCkge1xcbiAgICAgIHZhciByYW5nZXMgPSB0aGlzLnNlbC5yYW5nZXMsIGxpbmVzO1xcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmFuZ2VzLmxlbmd0aDsgaSsrKSB7XFxuICAgICAgICB2YXIgc2VsID0gZ2V0QmV0d2Vlbih0aGlzLCByYW5nZXNbaV0uZnJvbSgpLCByYW5nZXNbaV0udG8oKSk7XFxuICAgICAgICBsaW5lcyA9IGxpbmVzID8gbGluZXMuY29uY2F0KHNlbCkgOiBzZWw7XFxuICAgICAgfVxcbiAgICAgIGlmIChsaW5lU2VwID09PSBmYWxzZSkgcmV0dXJuIGxpbmVzO1xcbiAgICAgIGVsc2UgcmV0dXJuIGxpbmVzLmpvaW4obGluZVNlcCB8fCB0aGlzLmxpbmVTZXBhcmF0b3IoKSk7XFxuICAgIH0sXFxuICAgIGdldFNlbGVjdGlvbnM6IGZ1bmN0aW9uKGxpbmVTZXApIHtcXG4gICAgICB2YXIgcGFydHMgPSBbXSwgcmFuZ2VzID0gdGhpcy5zZWwucmFuZ2VzO1xcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmFuZ2VzLmxlbmd0aDsgaSsrKSB7XFxuICAgICAgICB2YXIgc2VsID0gZ2V0QmV0d2Vlbih0aGlzLCByYW5nZXNbaV0uZnJvbSgpLCByYW5nZXNbaV0udG8oKSk7XFxuICAgICAgICBpZiAobGluZVNlcCAhPT0gZmFsc2UpIHNlbCA9IHNlbC5qb2luKGxpbmVTZXAgfHwgdGhpcy5saW5lU2VwYXJhdG9yKCkpO1xcbiAgICAgICAgcGFydHNbaV0gPSBzZWw7XFxuICAgICAgfVxcbiAgICAgIHJldHVybiBwYXJ0cztcXG4gICAgfSxcXG4gICAgcmVwbGFjZVNlbGVjdGlvbjogZnVuY3Rpb24oY29kZSwgY29sbGFwc2UsIG9yaWdpbikge1xcbiAgICAgIHZhciBkdXAgPSBbXTtcXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuc2VsLnJhbmdlcy5sZW5ndGg7IGkrKylcXG4gICAgICAgIGR1cFtpXSA9IGNvZGU7XFxuICAgICAgdGhpcy5yZXBsYWNlU2VsZWN0aW9ucyhkdXAsIGNvbGxhcHNlLCBvcmlnaW4gfHwgXFxcIitpbnB1dFxcXCIpO1xcbiAgICB9LFxcbiAgICByZXBsYWNlU2VsZWN0aW9uczogZG9jTWV0aG9kT3AoZnVuY3Rpb24oY29kZSwgY29sbGFwc2UsIG9yaWdpbikge1xcbiAgICAgIHZhciBjaGFuZ2VzID0gW10sIHNlbCA9IHRoaXMuc2VsO1xcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VsLnJhbmdlcy5sZW5ndGg7IGkrKykge1xcbiAgICAgICAgdmFyIHJhbmdlID0gc2VsLnJhbmdlc1tpXTtcXG4gICAgICAgIGNoYW5nZXNbaV0gPSB7ZnJvbTogcmFuZ2UuZnJvbSgpLCB0bzogcmFuZ2UudG8oKSwgdGV4dDogdGhpcy5zcGxpdExpbmVzKGNvZGVbaV0pLCBvcmlnaW46IG9yaWdpbn07XFxuICAgICAgfVxcbiAgICAgIHZhciBuZXdTZWwgPSBjb2xsYXBzZSAmJiBjb2xsYXBzZSAhPSBcXFwiZW5kXFxcIiAmJiBjb21wdXRlUmVwbGFjZWRTZWwodGhpcywgY2hhbmdlcywgY29sbGFwc2UpO1xcbiAgICAgIGZvciAodmFyIGkgPSBjaGFuZ2VzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxcbiAgICAgICAgbWFrZUNoYW5nZSh0aGlzLCBjaGFuZ2VzW2ldKTtcXG4gICAgICBpZiAobmV3U2VsKSBzZXRTZWxlY3Rpb25SZXBsYWNlSGlzdG9yeSh0aGlzLCBuZXdTZWwpO1xcbiAgICAgIGVsc2UgaWYgKHRoaXMuY20pIGVuc3VyZUN1cnNvclZpc2libGUodGhpcy5jbSk7XFxuICAgIH0pLFxcbiAgICB1bmRvOiBkb2NNZXRob2RPcChmdW5jdGlvbigpIHttYWtlQ2hhbmdlRnJvbUhpc3RvcnkodGhpcywgXFxcInVuZG9cXFwiKTt9KSxcXG4gICAgcmVkbzogZG9jTWV0aG9kT3AoZnVuY3Rpb24oKSB7bWFrZUNoYW5nZUZyb21IaXN0b3J5KHRoaXMsIFxcXCJyZWRvXFxcIik7fSksXFxuICAgIHVuZG9TZWxlY3Rpb246IGRvY01ldGhvZE9wKGZ1bmN0aW9uKCkge21ha2VDaGFuZ2VGcm9tSGlzdG9yeSh0aGlzLCBcXFwidW5kb1xcXCIsIHRydWUpO30pLFxcbiAgICByZWRvU2VsZWN0aW9uOiBkb2NNZXRob2RPcChmdW5jdGlvbigpIHttYWtlQ2hhbmdlRnJvbUhpc3RvcnkodGhpcywgXFxcInJlZG9cXFwiLCB0cnVlKTt9KSxcXG5cXG4gICAgc2V0RXh0ZW5kaW5nOiBmdW5jdGlvbih2YWwpIHt0aGlzLmV4dGVuZCA9IHZhbDt9LFxcbiAgICBnZXRFeHRlbmRpbmc6IGZ1bmN0aW9uKCkge3JldHVybiB0aGlzLmV4dGVuZDt9LFxcblxcbiAgICBoaXN0b3J5U2l6ZTogZnVuY3Rpb24oKSB7XFxuICAgICAgdmFyIGhpc3QgPSB0aGlzLmhpc3RvcnksIGRvbmUgPSAwLCB1bmRvbmUgPSAwO1xcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaGlzdC5kb25lLmxlbmd0aDsgaSsrKSBpZiAoIWhpc3QuZG9uZVtpXS5yYW5nZXMpICsrZG9uZTtcXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhpc3QudW5kb25lLmxlbmd0aDsgaSsrKSBpZiAoIWhpc3QudW5kb25lW2ldLnJhbmdlcykgKyt1bmRvbmU7XFxuICAgICAgcmV0dXJuIHt1bmRvOiBkb25lLCByZWRvOiB1bmRvbmV9O1xcbiAgICB9LFxcbiAgICBjbGVhckhpc3Rvcnk6IGZ1bmN0aW9uKCkge3RoaXMuaGlzdG9yeSA9IG5ldyBIaXN0b3J5KHRoaXMuaGlzdG9yeS5tYXhHZW5lcmF0aW9uKTt9LFxcblxcbiAgICBtYXJrQ2xlYW46IGZ1bmN0aW9uKCkge1xcbiAgICAgIHRoaXMuY2xlYW5HZW5lcmF0aW9uID0gdGhpcy5jaGFuZ2VHZW5lcmF0aW9uKHRydWUpO1xcbiAgICB9LFxcbiAgICBjaGFuZ2VHZW5lcmF0aW9uOiBmdW5jdGlvbihmb3JjZVNwbGl0KSB7XFxuICAgICAgaWYgKGZvcmNlU3BsaXQpXFxuICAgICAgICB0aGlzLmhpc3RvcnkubGFzdE9wID0gdGhpcy5oaXN0b3J5Lmxhc3RTZWxPcCA9IHRoaXMuaGlzdG9yeS5sYXN0T3JpZ2luID0gbnVsbDtcXG4gICAgICByZXR1cm4gdGhpcy5oaXN0b3J5LmdlbmVyYXRpb247XFxuICAgIH0sXFxuICAgIGlzQ2xlYW46IGZ1bmN0aW9uIChnZW4pIHtcXG4gICAgICByZXR1cm4gdGhpcy5oaXN0b3J5LmdlbmVyYXRpb24gPT0gKGdlbiB8fCB0aGlzLmNsZWFuR2VuZXJhdGlvbik7XFxuICAgIH0sXFxuXFxuICAgIGdldEhpc3Rvcnk6IGZ1bmN0aW9uKCkge1xcbiAgICAgIHJldHVybiB7ZG9uZTogY29weUhpc3RvcnlBcnJheSh0aGlzLmhpc3RvcnkuZG9uZSksXFxuICAgICAgICAgICAgICB1bmRvbmU6IGNvcHlIaXN0b3J5QXJyYXkodGhpcy5oaXN0b3J5LnVuZG9uZSl9O1xcbiAgICB9LFxcbiAgICBzZXRIaXN0b3J5OiBmdW5jdGlvbihoaXN0RGF0YSkge1xcbiAgICAgIHZhciBoaXN0ID0gdGhpcy5oaXN0b3J5ID0gbmV3IEhpc3RvcnkodGhpcy5oaXN0b3J5Lm1heEdlbmVyYXRpb24pO1xcbiAgICAgIGhpc3QuZG9uZSA9IGNvcHlIaXN0b3J5QXJyYXkoaGlzdERhdGEuZG9uZS5zbGljZSgwKSwgbnVsbCwgdHJ1ZSk7XFxuICAgICAgaGlzdC51bmRvbmUgPSBjb3B5SGlzdG9yeUFycmF5KGhpc3REYXRhLnVuZG9uZS5zbGljZSgwKSwgbnVsbCwgdHJ1ZSk7XFxuICAgIH0sXFxuXFxuICAgIGFkZExpbmVDbGFzczogZG9jTWV0aG9kT3AoZnVuY3Rpb24oaGFuZGxlLCB3aGVyZSwgY2xzKSB7XFxuICAgICAgcmV0dXJuIGNoYW5nZUxpbmUodGhpcywgaGFuZGxlLCB3aGVyZSA9PSBcXFwiZ3V0dGVyXFxcIiA/IFxcXCJndXR0ZXJcXFwiIDogXFxcImNsYXNzXFxcIiwgZnVuY3Rpb24obGluZSkge1xcbiAgICAgICAgdmFyIHByb3AgPSB3aGVyZSA9PSBcXFwidGV4dFxcXCIgPyBcXFwidGV4dENsYXNzXFxcIlxcbiAgICAgICAgICAgICAgICAgOiB3aGVyZSA9PSBcXFwiYmFja2dyb3VuZFxcXCIgPyBcXFwiYmdDbGFzc1xcXCJcXG4gICAgICAgICAgICAgICAgIDogd2hlcmUgPT0gXFxcImd1dHRlclxcXCIgPyBcXFwiZ3V0dGVyQ2xhc3NcXFwiIDogXFxcIndyYXBDbGFzc1xcXCI7XFxuICAgICAgICBpZiAoIWxpbmVbcHJvcF0pIGxpbmVbcHJvcF0gPSBjbHM7XFxuICAgICAgICBlbHNlIGlmIChjbGFzc1Rlc3QoY2xzKS50ZXN0KGxpbmVbcHJvcF0pKSByZXR1cm4gZmFsc2U7XFxuICAgICAgICBlbHNlIGxpbmVbcHJvcF0gKz0gXFxcIiBcXFwiICsgY2xzO1xcbiAgICAgICAgcmV0dXJuIHRydWU7XFxuICAgICAgfSk7XFxuICAgIH0pLFxcbiAgICByZW1vdmVMaW5lQ2xhc3M6IGRvY01ldGhvZE9wKGZ1bmN0aW9uKGhhbmRsZSwgd2hlcmUsIGNscykge1xcbiAgICAgIHJldHVybiBjaGFuZ2VMaW5lKHRoaXMsIGhhbmRsZSwgd2hlcmUgPT0gXFxcImd1dHRlclxcXCIgPyBcXFwiZ3V0dGVyXFxcIiA6IFxcXCJjbGFzc1xcXCIsIGZ1bmN0aW9uKGxpbmUpIHtcXG4gICAgICAgIHZhciBwcm9wID0gd2hlcmUgPT0gXFxcInRleHRcXFwiID8gXFxcInRleHRDbGFzc1xcXCJcXG4gICAgICAgICAgICAgICAgIDogd2hlcmUgPT0gXFxcImJhY2tncm91bmRcXFwiID8gXFxcImJnQ2xhc3NcXFwiXFxuICAgICAgICAgICAgICAgICA6IHdoZXJlID09IFxcXCJndXR0ZXJcXFwiID8gXFxcImd1dHRlckNsYXNzXFxcIiA6IFxcXCJ3cmFwQ2xhc3NcXFwiO1xcbiAgICAgICAgdmFyIGN1ciA9IGxpbmVbcHJvcF07XFxuICAgICAgICBpZiAoIWN1cikgcmV0dXJuIGZhbHNlO1xcbiAgICAgICAgZWxzZSBpZiAoY2xzID09IG51bGwpIGxpbmVbcHJvcF0gPSBudWxsO1xcbiAgICAgICAgZWxzZSB7XFxuICAgICAgICAgIHZhciBmb3VuZCA9IGN1ci5tYXRjaChjbGFzc1Rlc3QoY2xzKSk7XFxuICAgICAgICAgIGlmICghZm91bmQpIHJldHVybiBmYWxzZTtcXG4gICAgICAgICAgdmFyIGVuZCA9IGZvdW5kLmluZGV4ICsgZm91bmRbMF0ubGVuZ3RoO1xcbiAgICAgICAgICBsaW5lW3Byb3BdID0gY3VyLnNsaWNlKDAsIGZvdW5kLmluZGV4KSArICghZm91bmQuaW5kZXggfHwgZW5kID09IGN1ci5sZW5ndGggPyBcXFwiXFxcIiA6IFxcXCIgXFxcIikgKyBjdXIuc2xpY2UoZW5kKSB8fCBudWxsO1xcbiAgICAgICAgfVxcbiAgICAgICAgcmV0dXJuIHRydWU7XFxuICAgICAgfSk7XFxuICAgIH0pLFxcblxcbiAgICBhZGRMaW5lV2lkZ2V0OiBkb2NNZXRob2RPcChmdW5jdGlvbihoYW5kbGUsIG5vZGUsIG9wdGlvbnMpIHtcXG4gICAgICByZXR1cm4gYWRkTGluZVdpZGdldCh0aGlzLCBoYW5kbGUsIG5vZGUsIG9wdGlvbnMpO1xcbiAgICB9KSxcXG4gICAgcmVtb3ZlTGluZVdpZGdldDogZnVuY3Rpb24od2lkZ2V0KSB7IHdpZGdldC5jbGVhcigpOyB9LFxcblxcbiAgICBtYXJrVGV4dDogZnVuY3Rpb24oZnJvbSwgdG8sIG9wdGlvbnMpIHtcXG4gICAgICByZXR1cm4gbWFya1RleHQodGhpcywgY2xpcFBvcyh0aGlzLCBmcm9tKSwgY2xpcFBvcyh0aGlzLCB0byksIG9wdGlvbnMsIG9wdGlvbnMgJiYgb3B0aW9ucy50eXBlIHx8IFxcXCJyYW5nZVxcXCIpO1xcbiAgICB9LFxcbiAgICBzZXRCb29rbWFyazogZnVuY3Rpb24ocG9zLCBvcHRpb25zKSB7XFxuICAgICAgdmFyIHJlYWxPcHRzID0ge3JlcGxhY2VkV2l0aDogb3B0aW9ucyAmJiAob3B0aW9ucy5ub2RlVHlwZSA9PSBudWxsID8gb3B0aW9ucy53aWRnZXQgOiBvcHRpb25zKSxcXG4gICAgICAgICAgICAgICAgICAgICAgaW5zZXJ0TGVmdDogb3B0aW9ucyAmJiBvcHRpb25zLmluc2VydExlZnQsXFxuICAgICAgICAgICAgICAgICAgICAgIGNsZWFyV2hlbkVtcHR5OiBmYWxzZSwgc2hhcmVkOiBvcHRpb25zICYmIG9wdGlvbnMuc2hhcmVkLFxcbiAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVNb3VzZUV2ZW50czogb3B0aW9ucyAmJiBvcHRpb25zLmhhbmRsZU1vdXNlRXZlbnRzfTtcXG4gICAgICBwb3MgPSBjbGlwUG9zKHRoaXMsIHBvcyk7XFxuICAgICAgcmV0dXJuIG1hcmtUZXh0KHRoaXMsIHBvcywgcG9zLCByZWFsT3B0cywgXFxcImJvb2ttYXJrXFxcIik7XFxuICAgIH0sXFxuICAgIGZpbmRNYXJrc0F0OiBmdW5jdGlvbihwb3MpIHtcXG4gICAgICBwb3MgPSBjbGlwUG9zKHRoaXMsIHBvcyk7XFxuICAgICAgdmFyIG1hcmtlcnMgPSBbXSwgc3BhbnMgPSBnZXRMaW5lKHRoaXMsIHBvcy5saW5lKS5tYXJrZWRTcGFucztcXG4gICAgICBpZiAoc3BhbnMpIGZvciAodmFyIGkgPSAwOyBpIDwgc3BhbnMubGVuZ3RoOyArK2kpIHtcXG4gICAgICAgIHZhciBzcGFuID0gc3BhbnNbaV07XFxuICAgICAgICBpZiAoKHNwYW4uZnJvbSA9PSBudWxsIHx8IHNwYW4uZnJvbSA8PSBwb3MuY2gpICYmXFxuICAgICAgICAgICAgKHNwYW4udG8gPT0gbnVsbCB8fCBzcGFuLnRvID49IHBvcy5jaCkpXFxuICAgICAgICAgIG1hcmtlcnMucHVzaChzcGFuLm1hcmtlci5wYXJlbnQgfHwgc3Bhbi5tYXJrZXIpO1xcbiAgICAgIH1cXG4gICAgICByZXR1cm4gbWFya2VycztcXG4gICAgfSxcXG4gICAgZmluZE1hcmtzOiBmdW5jdGlvbihmcm9tLCB0bywgZmlsdGVyKSB7XFxuICAgICAgZnJvbSA9IGNsaXBQb3ModGhpcywgZnJvbSk7IHRvID0gY2xpcFBvcyh0aGlzLCB0byk7XFxuICAgICAgdmFyIGZvdW5kID0gW10sIGxpbmVObyA9IGZyb20ubGluZTtcXG4gICAgICB0aGlzLml0ZXIoZnJvbS5saW5lLCB0by5saW5lICsgMSwgZnVuY3Rpb24obGluZSkge1xcbiAgICAgICAgdmFyIHNwYW5zID0gbGluZS5tYXJrZWRTcGFucztcXG4gICAgICAgIGlmIChzcGFucykgZm9yICh2YXIgaSA9IDA7IGkgPCBzcGFucy5sZW5ndGg7IGkrKykge1xcbiAgICAgICAgICB2YXIgc3BhbiA9IHNwYW5zW2ldO1xcbiAgICAgICAgICBpZiAoIShzcGFuLnRvICE9IG51bGwgJiYgbGluZU5vID09IGZyb20ubGluZSAmJiBmcm9tLmNoID49IHNwYW4udG8gfHxcXG4gICAgICAgICAgICAgICAgc3Bhbi5mcm9tID09IG51bGwgJiYgbGluZU5vICE9IGZyb20ubGluZSB8fFxcbiAgICAgICAgICAgICAgICBzcGFuLmZyb20gIT0gbnVsbCAmJiBsaW5lTm8gPT0gdG8ubGluZSAmJiBzcGFuLmZyb20gPj0gdG8uY2gpICYmXFxuICAgICAgICAgICAgICAoIWZpbHRlciB8fCBmaWx0ZXIoc3Bhbi5tYXJrZXIpKSlcXG4gICAgICAgICAgICBmb3VuZC5wdXNoKHNwYW4ubWFya2VyLnBhcmVudCB8fCBzcGFuLm1hcmtlcik7XFxuICAgICAgICB9XFxuICAgICAgICArK2xpbmVObztcXG4gICAgICB9KTtcXG4gICAgICByZXR1cm4gZm91bmQ7XFxuICAgIH0sXFxuICAgIGdldEFsbE1hcmtzOiBmdW5jdGlvbigpIHtcXG4gICAgICB2YXIgbWFya2VycyA9IFtdO1xcbiAgICAgIHRoaXMuaXRlcihmdW5jdGlvbihsaW5lKSB7XFxuICAgICAgICB2YXIgc3BzID0gbGluZS5tYXJrZWRTcGFucztcXG4gICAgICAgIGlmIChzcHMpIGZvciAodmFyIGkgPSAwOyBpIDwgc3BzLmxlbmd0aDsgKytpKVxcbiAgICAgICAgICBpZiAoc3BzW2ldLmZyb20gIT0gbnVsbCkgbWFya2Vycy5wdXNoKHNwc1tpXS5tYXJrZXIpO1xcbiAgICAgIH0pO1xcbiAgICAgIHJldHVybiBtYXJrZXJzO1xcbiAgICB9LFxcblxcbiAgICBwb3NGcm9tSW5kZXg6IGZ1bmN0aW9uKG9mZikge1xcbiAgICAgIHZhciBjaCwgbGluZU5vID0gdGhpcy5maXJzdCwgc2VwU2l6ZSA9IHRoaXMubGluZVNlcGFyYXRvcigpLmxlbmd0aDtcXG4gICAgICB0aGlzLml0ZXIoZnVuY3Rpb24obGluZSkge1xcbiAgICAgICAgdmFyIHN6ID0gbGluZS50ZXh0Lmxlbmd0aCArIHNlcFNpemU7XFxuICAgICAgICBpZiAoc3ogPiBvZmYpIHsgY2ggPSBvZmY7IHJldHVybiB0cnVlOyB9XFxuICAgICAgICBvZmYgLT0gc3o7XFxuICAgICAgICArK2xpbmVObztcXG4gICAgICB9KTtcXG4gICAgICByZXR1cm4gY2xpcFBvcyh0aGlzLCBQb3MobGluZU5vLCBjaCkpO1xcbiAgICB9LFxcbiAgICBpbmRleEZyb21Qb3M6IGZ1bmN0aW9uIChjb29yZHMpIHtcXG4gICAgICBjb29yZHMgPSBjbGlwUG9zKHRoaXMsIGNvb3Jkcyk7XFxuICAgICAgdmFyIGluZGV4ID0gY29vcmRzLmNoO1xcbiAgICAgIGlmIChjb29yZHMubGluZSA8IHRoaXMuZmlyc3QgfHwgY29vcmRzLmNoIDwgMCkgcmV0dXJuIDA7XFxuICAgICAgdmFyIHNlcFNpemUgPSB0aGlzLmxpbmVTZXBhcmF0b3IoKS5sZW5ndGg7XFxuICAgICAgdGhpcy5pdGVyKHRoaXMuZmlyc3QsIGNvb3Jkcy5saW5lLCBmdW5jdGlvbiAobGluZSkge1xcbiAgICAgICAgaW5kZXggKz0gbGluZS50ZXh0Lmxlbmd0aCArIHNlcFNpemU7XFxuICAgICAgfSk7XFxuICAgICAgcmV0dXJuIGluZGV4O1xcbiAgICB9LFxcblxcbiAgICBjb3B5OiBmdW5jdGlvbihjb3B5SGlzdG9yeSkge1xcbiAgICAgIHZhciBkb2MgPSBuZXcgRG9jKGdldExpbmVzKHRoaXMsIHRoaXMuZmlyc3QsIHRoaXMuZmlyc3QgKyB0aGlzLnNpemUpLFxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubW9kZU9wdGlvbiwgdGhpcy5maXJzdCwgdGhpcy5saW5lU2VwKTtcXG4gICAgICBkb2Muc2Nyb2xsVG9wID0gdGhpcy5zY3JvbGxUb3A7IGRvYy5zY3JvbGxMZWZ0ID0gdGhpcy5zY3JvbGxMZWZ0O1xcbiAgICAgIGRvYy5zZWwgPSB0aGlzLnNlbDtcXG4gICAgICBkb2MuZXh0ZW5kID0gZmFsc2U7XFxuICAgICAgaWYgKGNvcHlIaXN0b3J5KSB7XFxuICAgICAgICBkb2MuaGlzdG9yeS51bmRvRGVwdGggPSB0aGlzLmhpc3RvcnkudW5kb0RlcHRoO1xcbiAgICAgICAgZG9jLnNldEhpc3RvcnkodGhpcy5nZXRIaXN0b3J5KCkpO1xcbiAgICAgIH1cXG4gICAgICByZXR1cm4gZG9jO1xcbiAgICB9LFxcblxcbiAgICBsaW5rZWREb2M6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcXG4gICAgICBpZiAoIW9wdGlvbnMpIG9wdGlvbnMgPSB7fTtcXG4gICAgICB2YXIgZnJvbSA9IHRoaXMuZmlyc3QsIHRvID0gdGhpcy5maXJzdCArIHRoaXMuc2l6ZTtcXG4gICAgICBpZiAob3B0aW9ucy5mcm9tICE9IG51bGwgJiYgb3B0aW9ucy5mcm9tID4gZnJvbSkgZnJvbSA9IG9wdGlvbnMuZnJvbTtcXG4gICAgICBpZiAob3B0aW9ucy50byAhPSBudWxsICYmIG9wdGlvbnMudG8gPCB0bykgdG8gPSBvcHRpb25zLnRvO1xcbiAgICAgIHZhciBjb3B5ID0gbmV3IERvYyhnZXRMaW5lcyh0aGlzLCBmcm9tLCB0byksIG9wdGlvbnMubW9kZSB8fCB0aGlzLm1vZGVPcHRpb24sIGZyb20sIHRoaXMubGluZVNlcCk7XFxuICAgICAgaWYgKG9wdGlvbnMuc2hhcmVkSGlzdCkgY29weS5oaXN0b3J5ID0gdGhpcy5oaXN0b3J5O1xcbiAgICAgICh0aGlzLmxpbmtlZCB8fCAodGhpcy5saW5rZWQgPSBbXSkpLnB1c2goe2RvYzogY29weSwgc2hhcmVkSGlzdDogb3B0aW9ucy5zaGFyZWRIaXN0fSk7XFxuICAgICAgY29weS5saW5rZWQgPSBbe2RvYzogdGhpcywgaXNQYXJlbnQ6IHRydWUsIHNoYXJlZEhpc3Q6IG9wdGlvbnMuc2hhcmVkSGlzdH1dO1xcbiAgICAgIGNvcHlTaGFyZWRNYXJrZXJzKGNvcHksIGZpbmRTaGFyZWRNYXJrZXJzKHRoaXMpKTtcXG4gICAgICByZXR1cm4gY29weTtcXG4gICAgfSxcXG4gICAgdW5saW5rRG9jOiBmdW5jdGlvbihvdGhlcikge1xcbiAgICAgIGlmIChvdGhlciBpbnN0YW5jZW9mIENvZGVNaXJyb3IpIG90aGVyID0gb3RoZXIuZG9jO1xcbiAgICAgIGlmICh0aGlzLmxpbmtlZCkgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxpbmtlZC5sZW5ndGg7ICsraSkge1xcbiAgICAgICAgdmFyIGxpbmsgPSB0aGlzLmxpbmtlZFtpXTtcXG4gICAgICAgIGlmIChsaW5rLmRvYyAhPSBvdGhlcikgY29udGludWU7XFxuICAgICAgICB0aGlzLmxpbmtlZC5zcGxpY2UoaSwgMSk7XFxuICAgICAgICBvdGhlci51bmxpbmtEb2ModGhpcyk7XFxuICAgICAgICBkZXRhY2hTaGFyZWRNYXJrZXJzKGZpbmRTaGFyZWRNYXJrZXJzKHRoaXMpKTtcXG4gICAgICAgIGJyZWFrO1xcbiAgICAgIH1cXG4gICAgICAvLyBJZiB0aGUgaGlzdG9yaWVzIHdlcmUgc2hhcmVkLCBzcGxpdCB0aGVtIGFnYWluXFxuICAgICAgaWYgKG90aGVyLmhpc3RvcnkgPT0gdGhpcy5oaXN0b3J5KSB7XFxuICAgICAgICB2YXIgc3BsaXRJZHMgPSBbb3RoZXIuaWRdO1xcbiAgICAgICAgbGlua2VkRG9jcyhvdGhlciwgZnVuY3Rpb24oZG9jKSB7c3BsaXRJZHMucHVzaChkb2MuaWQpO30sIHRydWUpO1xcbiAgICAgICAgb3RoZXIuaGlzdG9yeSA9IG5ldyBIaXN0b3J5KG51bGwpO1xcbiAgICAgICAgb3RoZXIuaGlzdG9yeS5kb25lID0gY29weUhpc3RvcnlBcnJheSh0aGlzLmhpc3RvcnkuZG9uZSwgc3BsaXRJZHMpO1xcbiAgICAgICAgb3RoZXIuaGlzdG9yeS51bmRvbmUgPSBjb3B5SGlzdG9yeUFycmF5KHRoaXMuaGlzdG9yeS51bmRvbmUsIHNwbGl0SWRzKTtcXG4gICAgICB9XFxuICAgIH0sXFxuICAgIGl0ZXJMaW5rZWREb2NzOiBmdW5jdGlvbihmKSB7bGlua2VkRG9jcyh0aGlzLCBmKTt9LFxcblxcbiAgICBnZXRNb2RlOiBmdW5jdGlvbigpIHtyZXR1cm4gdGhpcy5tb2RlO30sXFxuICAgIGdldEVkaXRvcjogZnVuY3Rpb24oKSB7cmV0dXJuIHRoaXMuY207fSxcXG5cXG4gICAgc3BsaXRMaW5lczogZnVuY3Rpb24oc3RyKSB7XFxuICAgICAgaWYgKHRoaXMubGluZVNlcCkgcmV0dXJuIHN0ci5zcGxpdCh0aGlzLmxpbmVTZXApO1xcbiAgICAgIHJldHVybiBzcGxpdExpbmVzQXV0byhzdHIpO1xcbiAgICB9LFxcbiAgICBsaW5lU2VwYXJhdG9yOiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMubGluZVNlcCB8fCBcXFwiXFxcXG5cXFwiOyB9XFxuICB9KTtcXG5cXG4gIC8vIFB1YmxpYyBhbGlhcy5cXG4gIERvYy5wcm90b3R5cGUuZWFjaExpbmUgPSBEb2MucHJvdG90eXBlLml0ZXI7XFxuXFxuICAvLyBTZXQgdXAgbWV0aG9kcyBvbiBDb2RlTWlycm9yJ3MgcHJvdG90eXBlIHRvIHJlZGlyZWN0IHRvIHRoZSBlZGl0b3IncyBkb2N1bWVudC5cXG4gIHZhciBkb250RGVsZWdhdGUgPSBcXFwiaXRlciBpbnNlcnQgcmVtb3ZlIGNvcHkgZ2V0RWRpdG9yIGNvbnN0cnVjdG9yXFxcIi5zcGxpdChcXFwiIFxcXCIpO1xcbiAgZm9yICh2YXIgcHJvcCBpbiBEb2MucHJvdG90eXBlKSBpZiAoRG9jLnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eShwcm9wKSAmJiBpbmRleE9mKGRvbnREZWxlZ2F0ZSwgcHJvcCkgPCAwKVxcbiAgICBDb2RlTWlycm9yLnByb3RvdHlwZVtwcm9wXSA9IChmdW5jdGlvbihtZXRob2QpIHtcXG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7cmV0dXJuIG1ldGhvZC5hcHBseSh0aGlzLmRvYywgYXJndW1lbnRzKTt9O1xcbiAgICB9KShEb2MucHJvdG90eXBlW3Byb3BdKTtcXG5cXG4gIGV2ZW50TWl4aW4oRG9jKTtcXG5cXG4gIC8vIENhbGwgZiBmb3IgYWxsIGxpbmtlZCBkb2N1bWVudHMuXFxuICBmdW5jdGlvbiBsaW5rZWREb2NzKGRvYywgZiwgc2hhcmVkSGlzdE9ubHkpIHtcXG4gICAgZnVuY3Rpb24gcHJvcGFnYXRlKGRvYywgc2tpcCwgc2hhcmVkSGlzdCkge1xcbiAgICAgIGlmIChkb2MubGlua2VkKSBmb3IgKHZhciBpID0gMDsgaSA8IGRvYy5saW5rZWQubGVuZ3RoOyArK2kpIHtcXG4gICAgICAgIHZhciByZWwgPSBkb2MubGlua2VkW2ldO1xcbiAgICAgICAgaWYgKHJlbC5kb2MgPT0gc2tpcCkgY29udGludWU7XFxuICAgICAgICB2YXIgc2hhcmVkID0gc2hhcmVkSGlzdCAmJiByZWwuc2hhcmVkSGlzdDtcXG4gICAgICAgIGlmIChzaGFyZWRIaXN0T25seSAmJiAhc2hhcmVkKSBjb250aW51ZTtcXG4gICAgICAgIGYocmVsLmRvYywgc2hhcmVkKTtcXG4gICAgICAgIHByb3BhZ2F0ZShyZWwuZG9jLCBkb2MsIHNoYXJlZCk7XFxuICAgICAgfVxcbiAgICB9XFxuICAgIHByb3BhZ2F0ZShkb2MsIG51bGwsIHRydWUpO1xcbiAgfVxcblxcbiAgLy8gQXR0YWNoIGEgZG9jdW1lbnQgdG8gYW4gZWRpdG9yLlxcbiAgZnVuY3Rpb24gYXR0YWNoRG9jKGNtLCBkb2MpIHtcXG4gICAgaWYgKGRvYy5jbSkgdGhyb3cgbmV3IEVycm9yKFxcXCJUaGlzIGRvY3VtZW50IGlzIGFscmVhZHkgaW4gdXNlLlxcXCIpO1xcbiAgICBjbS5kb2MgPSBkb2M7XFxuICAgIGRvYy5jbSA9IGNtO1xcbiAgICBlc3RpbWF0ZUxpbmVIZWlnaHRzKGNtKTtcXG4gICAgbG9hZE1vZGUoY20pO1xcbiAgICBpZiAoIWNtLm9wdGlvbnMubGluZVdyYXBwaW5nKSBmaW5kTWF4TGluZShjbSk7XFxuICAgIGNtLm9wdGlvbnMubW9kZSA9IGRvYy5tb2RlT3B0aW9uO1xcbiAgICByZWdDaGFuZ2UoY20pO1xcbiAgfVxcblxcbiAgLy8gTElORSBVVElMSVRJRVNcXG5cXG4gIC8vIEZpbmQgdGhlIGxpbmUgb2JqZWN0IGNvcnJlc3BvbmRpbmcgdG8gdGhlIGdpdmVuIGxpbmUgbnVtYmVyLlxcbiAgZnVuY3Rpb24gZ2V0TGluZShkb2MsIG4pIHtcXG4gICAgbiAtPSBkb2MuZmlyc3Q7XFxuICAgIGlmIChuIDwgMCB8fCBuID49IGRvYy5zaXplKSB0aHJvdyBuZXcgRXJyb3IoXFxcIlRoZXJlIGlzIG5vIGxpbmUgXFxcIiArIChuICsgZG9jLmZpcnN0KSArIFxcXCIgaW4gdGhlIGRvY3VtZW50LlxcXCIpO1xcbiAgICBmb3IgKHZhciBjaHVuayA9IGRvYzsgIWNodW5rLmxpbmVzOykge1xcbiAgICAgIGZvciAodmFyIGkgPSAwOzsgKytpKSB7XFxuICAgICAgICB2YXIgY2hpbGQgPSBjaHVuay5jaGlsZHJlbltpXSwgc3ogPSBjaGlsZC5jaHVua1NpemUoKTtcXG4gICAgICAgIGlmIChuIDwgc3opIHsgY2h1bmsgPSBjaGlsZDsgYnJlYWs7IH1cXG4gICAgICAgIG4gLT0gc3o7XFxuICAgICAgfVxcbiAgICB9XFxuICAgIHJldHVybiBjaHVuay5saW5lc1tuXTtcXG4gIH1cXG5cXG4gIC8vIEdldCB0aGUgcGFydCBvZiBhIGRvY3VtZW50IGJldHdlZW4gdHdvIHBvc2l0aW9ucywgYXMgYW4gYXJyYXkgb2ZcXG4gIC8vIHN0cmluZ3MuXFxuICBmdW5jdGlvbiBnZXRCZXR3ZWVuKGRvYywgc3RhcnQsIGVuZCkge1xcbiAgICB2YXIgb3V0ID0gW10sIG4gPSBzdGFydC5saW5lO1xcbiAgICBkb2MuaXRlcihzdGFydC5saW5lLCBlbmQubGluZSArIDEsIGZ1bmN0aW9uKGxpbmUpIHtcXG4gICAgICB2YXIgdGV4dCA9IGxpbmUudGV4dDtcXG4gICAgICBpZiAobiA9PSBlbmQubGluZSkgdGV4dCA9IHRleHQuc2xpY2UoMCwgZW5kLmNoKTtcXG4gICAgICBpZiAobiA9PSBzdGFydC5saW5lKSB0ZXh0ID0gdGV4dC5zbGljZShzdGFydC5jaCk7XFxuICAgICAgb3V0LnB1c2godGV4dCk7XFxuICAgICAgKytuO1xcbiAgICB9KTtcXG4gICAgcmV0dXJuIG91dDtcXG4gIH1cXG4gIC8vIEdldCB0aGUgbGluZXMgYmV0d2VlbiBmcm9tIGFuZCB0bywgYXMgYXJyYXkgb2Ygc3RyaW5ncy5cXG4gIGZ1bmN0aW9uIGdldExpbmVzKGRvYywgZnJvbSwgdG8pIHtcXG4gICAgdmFyIG91dCA9IFtdO1xcbiAgICBkb2MuaXRlcihmcm9tLCB0bywgZnVuY3Rpb24obGluZSkgeyBvdXQucHVzaChsaW5lLnRleHQpOyB9KTtcXG4gICAgcmV0dXJuIG91dDtcXG4gIH1cXG5cXG4gIC8vIFVwZGF0ZSB0aGUgaGVpZ2h0IG9mIGEgbGluZSwgcHJvcGFnYXRpbmcgdGhlIGhlaWdodCBjaGFuZ2VcXG4gIC8vIHVwd2FyZHMgdG8gcGFyZW50IG5vZGVzLlxcbiAgZnVuY3Rpb24gdXBkYXRlTGluZUhlaWdodChsaW5lLCBoZWlnaHQpIHtcXG4gICAgdmFyIGRpZmYgPSBoZWlnaHQgLSBsaW5lLmhlaWdodDtcXG4gICAgaWYgKGRpZmYpIGZvciAodmFyIG4gPSBsaW5lOyBuOyBuID0gbi5wYXJlbnQpIG4uaGVpZ2h0ICs9IGRpZmY7XFxuICB9XFxuXFxuICAvLyBHaXZlbiBhIGxpbmUgb2JqZWN0LCBmaW5kIGl0cyBsaW5lIG51bWJlciBieSB3YWxraW5nIHVwIHRocm91Z2hcXG4gIC8vIGl0cyBwYXJlbnQgbGlua3MuXFxuICBmdW5jdGlvbiBsaW5lTm8obGluZSkge1xcbiAgICBpZiAobGluZS5wYXJlbnQgPT0gbnVsbCkgcmV0dXJuIG51bGw7XFxuICAgIHZhciBjdXIgPSBsaW5lLnBhcmVudCwgbm8gPSBpbmRleE9mKGN1ci5saW5lcywgbGluZSk7XFxuICAgIGZvciAodmFyIGNodW5rID0gY3VyLnBhcmVudDsgY2h1bms7IGN1ciA9IGNodW5rLCBjaHVuayA9IGNodW5rLnBhcmVudCkge1xcbiAgICAgIGZvciAodmFyIGkgPSAwOzsgKytpKSB7XFxuICAgICAgICBpZiAoY2h1bmsuY2hpbGRyZW5baV0gPT0gY3VyKSBicmVhaztcXG4gICAgICAgIG5vICs9IGNodW5rLmNoaWxkcmVuW2ldLmNodW5rU2l6ZSgpO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgICByZXR1cm4gbm8gKyBjdXIuZmlyc3Q7XFxuICB9XFxuXFxuICAvLyBGaW5kIHRoZSBsaW5lIGF0IHRoZSBnaXZlbiB2ZXJ0aWNhbCBwb3NpdGlvbiwgdXNpbmcgdGhlIGhlaWdodFxcbiAgLy8gaW5mb3JtYXRpb24gaW4gdGhlIGRvY3VtZW50IHRyZWUuXFxuICBmdW5jdGlvbiBsaW5lQXRIZWlnaHQoY2h1bmssIGgpIHtcXG4gICAgdmFyIG4gPSBjaHVuay5maXJzdDtcXG4gICAgb3V0ZXI6IGRvIHtcXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNodW5rLmNoaWxkcmVuLmxlbmd0aDsgKytpKSB7XFxuICAgICAgICB2YXIgY2hpbGQgPSBjaHVuay5jaGlsZHJlbltpXSwgY2ggPSBjaGlsZC5oZWlnaHQ7XFxuICAgICAgICBpZiAoaCA8IGNoKSB7IGNodW5rID0gY2hpbGQ7IGNvbnRpbnVlIG91dGVyOyB9XFxuICAgICAgICBoIC09IGNoO1xcbiAgICAgICAgbiArPSBjaGlsZC5jaHVua1NpemUoKTtcXG4gICAgICB9XFxuICAgICAgcmV0dXJuIG47XFxuICAgIH0gd2hpbGUgKCFjaHVuay5saW5lcyk7XFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2h1bmsubGluZXMubGVuZ3RoOyArK2kpIHtcXG4gICAgICB2YXIgbGluZSA9IGNodW5rLmxpbmVzW2ldLCBsaCA9IGxpbmUuaGVpZ2h0O1xcbiAgICAgIGlmIChoIDwgbGgpIGJyZWFrO1xcbiAgICAgIGggLT0gbGg7XFxuICAgIH1cXG4gICAgcmV0dXJuIG4gKyBpO1xcbiAgfVxcblxcblxcbiAgLy8gRmluZCB0aGUgaGVpZ2h0IGFib3ZlIHRoZSBnaXZlbiBsaW5lLlxcbiAgZnVuY3Rpb24gaGVpZ2h0QXRMaW5lKGxpbmVPYmopIHtcXG4gICAgbGluZU9iaiA9IHZpc3VhbExpbmUobGluZU9iaik7XFxuXFxuICAgIHZhciBoID0gMCwgY2h1bmsgPSBsaW5lT2JqLnBhcmVudDtcXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaHVuay5saW5lcy5sZW5ndGg7ICsraSkge1xcbiAgICAgIHZhciBsaW5lID0gY2h1bmsubGluZXNbaV07XFxuICAgICAgaWYgKGxpbmUgPT0gbGluZU9iaikgYnJlYWs7XFxuICAgICAgZWxzZSBoICs9IGxpbmUuaGVpZ2h0O1xcbiAgICB9XFxuICAgIGZvciAodmFyIHAgPSBjaHVuay5wYXJlbnQ7IHA7IGNodW5rID0gcCwgcCA9IGNodW5rLnBhcmVudCkge1xcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcC5jaGlsZHJlbi5sZW5ndGg7ICsraSkge1xcbiAgICAgICAgdmFyIGN1ciA9IHAuY2hpbGRyZW5baV07XFxuICAgICAgICBpZiAoY3VyID09IGNodW5rKSBicmVhaztcXG4gICAgICAgIGVsc2UgaCArPSBjdXIuaGVpZ2h0O1xcbiAgICAgIH1cXG4gICAgfVxcbiAgICByZXR1cm4gaDtcXG4gIH1cXG5cXG4gIC8vIEdldCB0aGUgYmlkaSBvcmRlcmluZyBmb3IgdGhlIGdpdmVuIGxpbmUgKGFuZCBjYWNoZSBpdCkuIFJldHVybnNcXG4gIC8vIGZhbHNlIGZvciBsaW5lcyB0aGF0IGFyZSBmdWxseSBsZWZ0LXRvLXJpZ2h0LCBhbmQgYW4gYXJyYXkgb2ZcXG4gIC8vIEJpZGlTcGFuIG9iamVjdHMgb3RoZXJ3aXNlLlxcbiAgZnVuY3Rpb24gZ2V0T3JkZXIobGluZSkge1xcbiAgICB2YXIgb3JkZXIgPSBsaW5lLm9yZGVyO1xcbiAgICBpZiAob3JkZXIgPT0gbnVsbCkgb3JkZXIgPSBsaW5lLm9yZGVyID0gYmlkaU9yZGVyaW5nKGxpbmUudGV4dCk7XFxuICAgIHJldHVybiBvcmRlcjtcXG4gIH1cXG5cXG4gIC8vIEhJU1RPUllcXG5cXG4gIGZ1bmN0aW9uIEhpc3Rvcnkoc3RhcnRHZW4pIHtcXG4gICAgLy8gQXJyYXlzIG9mIGNoYW5nZSBldmVudHMgYW5kIHNlbGVjdGlvbnMuIERvaW5nIHNvbWV0aGluZyBhZGRzIGFuXFxuICAgIC8vIGV2ZW50IHRvIGRvbmUgYW5kIGNsZWFycyB1bmRvLiBVbmRvaW5nIG1vdmVzIGV2ZW50cyBmcm9tIGRvbmVcXG4gICAgLy8gdG8gdW5kb25lLCByZWRvaW5nIG1vdmVzIHRoZW0gaW4gdGhlIG90aGVyIGRpcmVjdGlvbi5cXG4gICAgdGhpcy5kb25lID0gW107IHRoaXMudW5kb25lID0gW107XFxuICAgIHRoaXMudW5kb0RlcHRoID0gSW5maW5pdHk7XFxuICAgIC8vIFVzZWQgdG8gdHJhY2sgd2hlbiBjaGFuZ2VzIGNhbiBiZSBtZXJnZWQgaW50byBhIHNpbmdsZSB1bmRvXFxuICAgIC8vIGV2ZW50XFxuICAgIHRoaXMubGFzdE1vZFRpbWUgPSB0aGlzLmxhc3RTZWxUaW1lID0gMDtcXG4gICAgdGhpcy5sYXN0T3AgPSB0aGlzLmxhc3RTZWxPcCA9IG51bGw7XFxuICAgIHRoaXMubGFzdE9yaWdpbiA9IHRoaXMubGFzdFNlbE9yaWdpbiA9IG51bGw7XFxuICAgIC8vIFVzZWQgYnkgdGhlIGlzQ2xlYW4oKSBtZXRob2RcXG4gICAgdGhpcy5nZW5lcmF0aW9uID0gdGhpcy5tYXhHZW5lcmF0aW9uID0gc3RhcnRHZW4gfHwgMTtcXG4gIH1cXG5cXG4gIC8vIENyZWF0ZSBhIGhpc3RvcnkgY2hhbmdlIGV2ZW50IGZyb20gYW4gdXBkYXRlRG9jLXN0eWxlIGNoYW5nZVxcbiAgLy8gb2JqZWN0LlxcbiAgZnVuY3Rpb24gaGlzdG9yeUNoYW5nZUZyb21DaGFuZ2UoZG9jLCBjaGFuZ2UpIHtcXG4gICAgdmFyIGhpc3RDaGFuZ2UgPSB7ZnJvbTogY29weVBvcyhjaGFuZ2UuZnJvbSksIHRvOiBjaGFuZ2VFbmQoY2hhbmdlKSwgdGV4dDogZ2V0QmV0d2Vlbihkb2MsIGNoYW5nZS5mcm9tLCBjaGFuZ2UudG8pfTtcXG4gICAgYXR0YWNoTG9jYWxTcGFucyhkb2MsIGhpc3RDaGFuZ2UsIGNoYW5nZS5mcm9tLmxpbmUsIGNoYW5nZS50by5saW5lICsgMSk7XFxuICAgIGxpbmtlZERvY3MoZG9jLCBmdW5jdGlvbihkb2MpIHthdHRhY2hMb2NhbFNwYW5zKGRvYywgaGlzdENoYW5nZSwgY2hhbmdlLmZyb20ubGluZSwgY2hhbmdlLnRvLmxpbmUgKyAxKTt9LCB0cnVlKTtcXG4gICAgcmV0dXJuIGhpc3RDaGFuZ2U7XFxuICB9XFxuXFxuICAvLyBQb3AgYWxsIHNlbGVjdGlvbiBldmVudHMgb2ZmIHRoZSBlbmQgb2YgYSBoaXN0b3J5IGFycmF5LiBTdG9wIGF0XFxuICAvLyBhIGNoYW5nZSBldmVudC5cXG4gIGZ1bmN0aW9uIGNsZWFyU2VsZWN0aW9uRXZlbnRzKGFycmF5KSB7XFxuICAgIHdoaWxlIChhcnJheS5sZW5ndGgpIHtcXG4gICAgICB2YXIgbGFzdCA9IGxzdChhcnJheSk7XFxuICAgICAgaWYgKGxhc3QucmFuZ2VzKSBhcnJheS5wb3AoKTtcXG4gICAgICBlbHNlIGJyZWFrO1xcbiAgICB9XFxuICB9XFxuXFxuICAvLyBGaW5kIHRoZSB0b3AgY2hhbmdlIGV2ZW50IGluIHRoZSBoaXN0b3J5LiBQb3Agb2ZmIHNlbGVjdGlvblxcbiAgLy8gZXZlbnRzIHRoYXQgYXJlIGluIHRoZSB3YXkuXFxuICBmdW5jdGlvbiBsYXN0Q2hhbmdlRXZlbnQoaGlzdCwgZm9yY2UpIHtcXG4gICAgaWYgKGZvcmNlKSB7XFxuICAgICAgY2xlYXJTZWxlY3Rpb25FdmVudHMoaGlzdC5kb25lKTtcXG4gICAgICByZXR1cm4gbHN0KGhpc3QuZG9uZSk7XFxuICAgIH0gZWxzZSBpZiAoaGlzdC5kb25lLmxlbmd0aCAmJiAhbHN0KGhpc3QuZG9uZSkucmFuZ2VzKSB7XFxuICAgICAgcmV0dXJuIGxzdChoaXN0LmRvbmUpO1xcbiAgICB9IGVsc2UgaWYgKGhpc3QuZG9uZS5sZW5ndGggPiAxICYmICFoaXN0LmRvbmVbaGlzdC5kb25lLmxlbmd0aCAtIDJdLnJhbmdlcykge1xcbiAgICAgIGhpc3QuZG9uZS5wb3AoKTtcXG4gICAgICByZXR1cm4gbHN0KGhpc3QuZG9uZSk7XFxuICAgIH1cXG4gIH1cXG5cXG4gIC8vIFJlZ2lzdGVyIGEgY2hhbmdlIGluIHRoZSBoaXN0b3J5LiBNZXJnZXMgY2hhbmdlcyB0aGF0IGFyZSB3aXRoaW5cXG4gIC8vIGEgc2luZ2xlIG9wZXJhdGlvbiwgb3IgYXJlIGNsb3NlIHRvZ2V0aGVyIHdpdGggYW4gb3JpZ2luIHRoYXRcXG4gIC8vIGFsbG93cyBtZXJnaW5nIChzdGFydGluZyB3aXRoIFxcXCIrXFxcIikgaW50byBhIHNpbmdsZSBldmVudC5cXG4gIGZ1bmN0aW9uIGFkZENoYW5nZVRvSGlzdG9yeShkb2MsIGNoYW5nZSwgc2VsQWZ0ZXIsIG9wSWQpIHtcXG4gICAgdmFyIGhpc3QgPSBkb2MuaGlzdG9yeTtcXG4gICAgaGlzdC51bmRvbmUubGVuZ3RoID0gMDtcXG4gICAgdmFyIHRpbWUgPSArbmV3IERhdGUsIGN1cjtcXG5cXG4gICAgaWYgKChoaXN0Lmxhc3RPcCA9PSBvcElkIHx8XFxuICAgICAgICAgaGlzdC5sYXN0T3JpZ2luID09IGNoYW5nZS5vcmlnaW4gJiYgY2hhbmdlLm9yaWdpbiAmJlxcbiAgICAgICAgICgoY2hhbmdlLm9yaWdpbi5jaGFyQXQoMCkgPT0gXFxcIitcXFwiICYmIGRvYy5jbSAmJiBoaXN0Lmxhc3RNb2RUaW1lID4gdGltZSAtIGRvYy5jbS5vcHRpb25zLmhpc3RvcnlFdmVudERlbGF5KSB8fFxcbiAgICAgICAgICBjaGFuZ2Uub3JpZ2luLmNoYXJBdCgwKSA9PSBcXFwiKlxcXCIpKSAmJlxcbiAgICAgICAgKGN1ciA9IGxhc3RDaGFuZ2VFdmVudChoaXN0LCBoaXN0Lmxhc3RPcCA9PSBvcElkKSkpIHtcXG4gICAgICAvLyBNZXJnZSB0aGlzIGNoYW5nZSBpbnRvIHRoZSBsYXN0IGV2ZW50XFxuICAgICAgdmFyIGxhc3QgPSBsc3QoY3VyLmNoYW5nZXMpO1xcbiAgICAgIGlmIChjbXAoY2hhbmdlLmZyb20sIGNoYW5nZS50bykgPT0gMCAmJiBjbXAoY2hhbmdlLmZyb20sIGxhc3QudG8pID09IDApIHtcXG4gICAgICAgIC8vIE9wdGltaXplZCBjYXNlIGZvciBzaW1wbGUgaW5zZXJ0aW9uIC0tIGRvbid0IHdhbnQgdG8gYWRkXFxuICAgICAgICAvLyBuZXcgY2hhbmdlc2V0cyBmb3IgZXZlcnkgY2hhcmFjdGVyIHR5cGVkXFxuICAgICAgICBsYXN0LnRvID0gY2hhbmdlRW5kKGNoYW5nZSk7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIC8vIEFkZCBuZXcgc3ViLWV2ZW50XFxuICAgICAgICBjdXIuY2hhbmdlcy5wdXNoKGhpc3RvcnlDaGFuZ2VGcm9tQ2hhbmdlKGRvYywgY2hhbmdlKSk7XFxuICAgICAgfVxcbiAgICB9IGVsc2Uge1xcbiAgICAgIC8vIENhbiBub3QgYmUgbWVyZ2VkLCBzdGFydCBhIG5ldyBldmVudC5cXG4gICAgICB2YXIgYmVmb3JlID0gbHN0KGhpc3QuZG9uZSk7XFxuICAgICAgaWYgKCFiZWZvcmUgfHwgIWJlZm9yZS5yYW5nZXMpXFxuICAgICAgICBwdXNoU2VsZWN0aW9uVG9IaXN0b3J5KGRvYy5zZWwsIGhpc3QuZG9uZSk7XFxuICAgICAgY3VyID0ge2NoYW5nZXM6IFtoaXN0b3J5Q2hhbmdlRnJvbUNoYW5nZShkb2MsIGNoYW5nZSldLFxcbiAgICAgICAgICAgICBnZW5lcmF0aW9uOiBoaXN0LmdlbmVyYXRpb259O1xcbiAgICAgIGhpc3QuZG9uZS5wdXNoKGN1cik7XFxuICAgICAgd2hpbGUgKGhpc3QuZG9uZS5sZW5ndGggPiBoaXN0LnVuZG9EZXB0aCkge1xcbiAgICAgICAgaGlzdC5kb25lLnNoaWZ0KCk7XFxuICAgICAgICBpZiAoIWhpc3QuZG9uZVswXS5yYW5nZXMpIGhpc3QuZG9uZS5zaGlmdCgpO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgICBoaXN0LmRvbmUucHVzaChzZWxBZnRlcik7XFxuICAgIGhpc3QuZ2VuZXJhdGlvbiA9ICsraGlzdC5tYXhHZW5lcmF0aW9uO1xcbiAgICBoaXN0Lmxhc3RNb2RUaW1lID0gaGlzdC5sYXN0U2VsVGltZSA9IHRpbWU7XFxuICAgIGhpc3QubGFzdE9wID0gaGlzdC5sYXN0U2VsT3AgPSBvcElkO1xcbiAgICBoaXN0Lmxhc3RPcmlnaW4gPSBoaXN0Lmxhc3RTZWxPcmlnaW4gPSBjaGFuZ2Uub3JpZ2luO1xcblxcbiAgICBpZiAoIWxhc3QpIHNpZ25hbChkb2MsIFxcXCJoaXN0b3J5QWRkZWRcXFwiKTtcXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIHNlbGVjdGlvbkV2ZW50Q2FuQmVNZXJnZWQoZG9jLCBvcmlnaW4sIHByZXYsIHNlbCkge1xcbiAgICB2YXIgY2ggPSBvcmlnaW4uY2hhckF0KDApO1xcbiAgICByZXR1cm4gY2ggPT0gXFxcIipcXFwiIHx8XFxuICAgICAgY2ggPT0gXFxcIitcXFwiICYmXFxuICAgICAgcHJldi5yYW5nZXMubGVuZ3RoID09IHNlbC5yYW5nZXMubGVuZ3RoICYmXFxuICAgICAgcHJldi5zb21ldGhpbmdTZWxlY3RlZCgpID09IHNlbC5zb21ldGhpbmdTZWxlY3RlZCgpICYmXFxuICAgICAgbmV3IERhdGUgLSBkb2MuaGlzdG9yeS5sYXN0U2VsVGltZSA8PSAoZG9jLmNtID8gZG9jLmNtLm9wdGlvbnMuaGlzdG9yeUV2ZW50RGVsYXkgOiA1MDApO1xcbiAgfVxcblxcbiAgLy8gQ2FsbGVkIHdoZW5ldmVyIHRoZSBzZWxlY3Rpb24gY2hhbmdlcywgc2V0cyB0aGUgbmV3IHNlbGVjdGlvbiBhc1xcbiAgLy8gdGhlIHBlbmRpbmcgc2VsZWN0aW9uIGluIHRoZSBoaXN0b3J5LCBhbmQgcHVzaGVzIHRoZSBvbGQgcGVuZGluZ1xcbiAgLy8gc2VsZWN0aW9uIGludG8gdGhlICdkb25lJyBhcnJheSB3aGVuIGl0IHdhcyBzaWduaWZpY2FudGx5XFxuICAvLyBkaWZmZXJlbnQgKGluIG51bWJlciBvZiBzZWxlY3RlZCByYW5nZXMsIGVtcHRpbmVzcywgb3IgdGltZSkuXFxuICBmdW5jdGlvbiBhZGRTZWxlY3Rpb25Ub0hpc3RvcnkoZG9jLCBzZWwsIG9wSWQsIG9wdGlvbnMpIHtcXG4gICAgdmFyIGhpc3QgPSBkb2MuaGlzdG9yeSwgb3JpZ2luID0gb3B0aW9ucyAmJiBvcHRpb25zLm9yaWdpbjtcXG5cXG4gICAgLy8gQSBuZXcgZXZlbnQgaXMgc3RhcnRlZCB3aGVuIHRoZSBwcmV2aW91cyBvcmlnaW4gZG9lcyBub3QgbWF0Y2hcXG4gICAgLy8gdGhlIGN1cnJlbnQsIG9yIHRoZSBvcmlnaW5zIGRvbid0IGFsbG93IG1hdGNoaW5nLiBPcmlnaW5zXFxuICAgIC8vIHN0YXJ0aW5nIHdpdGggKiBhcmUgYWx3YXlzIG1lcmdlZCwgdGhvc2Ugc3RhcnRpbmcgd2l0aCArIGFyZVxcbiAgICAvLyBtZXJnZWQgd2hlbiBzaW1pbGFyIGFuZCBjbG9zZSB0b2dldGhlciBpbiB0aW1lLlxcbiAgICBpZiAob3BJZCA9PSBoaXN0Lmxhc3RTZWxPcCB8fFxcbiAgICAgICAgKG9yaWdpbiAmJiBoaXN0Lmxhc3RTZWxPcmlnaW4gPT0gb3JpZ2luICYmXFxuICAgICAgICAgKGhpc3QubGFzdE1vZFRpbWUgPT0gaGlzdC5sYXN0U2VsVGltZSAmJiBoaXN0Lmxhc3RPcmlnaW4gPT0gb3JpZ2luIHx8XFxuICAgICAgICAgIHNlbGVjdGlvbkV2ZW50Q2FuQmVNZXJnZWQoZG9jLCBvcmlnaW4sIGxzdChoaXN0LmRvbmUpLCBzZWwpKSkpXFxuICAgICAgaGlzdC5kb25lW2hpc3QuZG9uZS5sZW5ndGggLSAxXSA9IHNlbDtcXG4gICAgZWxzZVxcbiAgICAgIHB1c2hTZWxlY3Rpb25Ub0hpc3Rvcnkoc2VsLCBoaXN0LmRvbmUpO1xcblxcbiAgICBoaXN0Lmxhc3RTZWxUaW1lID0gK25ldyBEYXRlO1xcbiAgICBoaXN0Lmxhc3RTZWxPcmlnaW4gPSBvcmlnaW47XFxuICAgIGhpc3QubGFzdFNlbE9wID0gb3BJZDtcXG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5jbGVhclJlZG8gIT09IGZhbHNlKVxcbiAgICAgIGNsZWFyU2VsZWN0aW9uRXZlbnRzKGhpc3QudW5kb25lKTtcXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIHB1c2hTZWxlY3Rpb25Ub0hpc3Rvcnkoc2VsLCBkZXN0KSB7XFxuICAgIHZhciB0b3AgPSBsc3QoZGVzdCk7XFxuICAgIGlmICghKHRvcCAmJiB0b3AucmFuZ2VzICYmIHRvcC5lcXVhbHMoc2VsKSkpXFxuICAgICAgZGVzdC5wdXNoKHNlbCk7XFxuICB9XFxuXFxuICAvLyBVc2VkIHRvIHN0b3JlIG1hcmtlZCBzcGFuIGluZm9ybWF0aW9uIGluIHRoZSBoaXN0b3J5LlxcbiAgZnVuY3Rpb24gYXR0YWNoTG9jYWxTcGFucyhkb2MsIGNoYW5nZSwgZnJvbSwgdG8pIHtcXG4gICAgdmFyIGV4aXN0aW5nID0gY2hhbmdlW1xcXCJzcGFuc19cXFwiICsgZG9jLmlkXSwgbiA9IDA7XFxuICAgIGRvYy5pdGVyKE1hdGgubWF4KGRvYy5maXJzdCwgZnJvbSksIE1hdGgubWluKGRvYy5maXJzdCArIGRvYy5zaXplLCB0byksIGZ1bmN0aW9uKGxpbmUpIHtcXG4gICAgICBpZiAobGluZS5tYXJrZWRTcGFucylcXG4gICAgICAgIChleGlzdGluZyB8fCAoZXhpc3RpbmcgPSBjaGFuZ2VbXFxcInNwYW5zX1xcXCIgKyBkb2MuaWRdID0ge30pKVtuXSA9IGxpbmUubWFya2VkU3BhbnM7XFxuICAgICAgKytuO1xcbiAgICB9KTtcXG4gIH1cXG5cXG4gIC8vIFdoZW4gdW4vcmUtZG9pbmcgcmVzdG9yZXMgdGV4dCBjb250YWluaW5nIG1hcmtlZCBzcGFucywgdGhvc2VcXG4gIC8vIHRoYXQgaGF2ZSBiZWVuIGV4cGxpY2l0bHkgY2xlYXJlZCBzaG91bGQgbm90IGJlIHJlc3RvcmVkLlxcbiAgZnVuY3Rpb24gcmVtb3ZlQ2xlYXJlZFNwYW5zKHNwYW5zKSB7XFxuICAgIGlmICghc3BhbnMpIHJldHVybiBudWxsO1xcbiAgICBmb3IgKHZhciBpID0gMCwgb3V0OyBpIDwgc3BhbnMubGVuZ3RoOyArK2kpIHtcXG4gICAgICBpZiAoc3BhbnNbaV0ubWFya2VyLmV4cGxpY2l0bHlDbGVhcmVkKSB7IGlmICghb3V0KSBvdXQgPSBzcGFucy5zbGljZSgwLCBpKTsgfVxcbiAgICAgIGVsc2UgaWYgKG91dCkgb3V0LnB1c2goc3BhbnNbaV0pO1xcbiAgICB9XFxuICAgIHJldHVybiAhb3V0ID8gc3BhbnMgOiBvdXQubGVuZ3RoID8gb3V0IDogbnVsbDtcXG4gIH1cXG5cXG4gIC8vIFJldHJpZXZlIGFuZCBmaWx0ZXIgdGhlIG9sZCBtYXJrZWQgc3BhbnMgc3RvcmVkIGluIGEgY2hhbmdlIGV2ZW50LlxcbiAgZnVuY3Rpb24gZ2V0T2xkU3BhbnMoZG9jLCBjaGFuZ2UpIHtcXG4gICAgdmFyIGZvdW5kID0gY2hhbmdlW1xcXCJzcGFuc19cXFwiICsgZG9jLmlkXTtcXG4gICAgaWYgKCFmb3VuZCkgcmV0dXJuIG51bGw7XFxuICAgIGZvciAodmFyIGkgPSAwLCBudyA9IFtdOyBpIDwgY2hhbmdlLnRleHQubGVuZ3RoOyArK2kpXFxuICAgICAgbncucHVzaChyZW1vdmVDbGVhcmVkU3BhbnMoZm91bmRbaV0pKTtcXG4gICAgcmV0dXJuIG53O1xcbiAgfVxcblxcbiAgLy8gVXNlZCBib3RoIHRvIHByb3ZpZGUgYSBKU09OLXNhZmUgb2JqZWN0IGluIC5nZXRIaXN0b3J5LCBhbmQsIHdoZW5cXG4gIC8vIGRldGFjaGluZyBhIGRvY3VtZW50LCB0byBzcGxpdCB0aGUgaGlzdG9yeSBpbiB0d29cXG4gIGZ1bmN0aW9uIGNvcHlIaXN0b3J5QXJyYXkoZXZlbnRzLCBuZXdHcm91cCwgaW5zdGFudGlhdGVTZWwpIHtcXG4gICAgZm9yICh2YXIgaSA9IDAsIGNvcHkgPSBbXTsgaSA8IGV2ZW50cy5sZW5ndGg7ICsraSkge1xcbiAgICAgIHZhciBldmVudCA9IGV2ZW50c1tpXTtcXG4gICAgICBpZiAoZXZlbnQucmFuZ2VzKSB7XFxuICAgICAgICBjb3B5LnB1c2goaW5zdGFudGlhdGVTZWwgPyBTZWxlY3Rpb24ucHJvdG90eXBlLmRlZXBDb3B5LmNhbGwoZXZlbnQpIDogZXZlbnQpO1xcbiAgICAgICAgY29udGludWU7XFxuICAgICAgfVxcbiAgICAgIHZhciBjaGFuZ2VzID0gZXZlbnQuY2hhbmdlcywgbmV3Q2hhbmdlcyA9IFtdO1xcbiAgICAgIGNvcHkucHVzaCh7Y2hhbmdlczogbmV3Q2hhbmdlc30pO1xcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgY2hhbmdlcy5sZW5ndGg7ICsraikge1xcbiAgICAgICAgdmFyIGNoYW5nZSA9IGNoYW5nZXNbal0sIG07XFxuICAgICAgICBuZXdDaGFuZ2VzLnB1c2goe2Zyb206IGNoYW5nZS5mcm9tLCB0bzogY2hhbmdlLnRvLCB0ZXh0OiBjaGFuZ2UudGV4dH0pO1xcbiAgICAgICAgaWYgKG5ld0dyb3VwKSBmb3IgKHZhciBwcm9wIGluIGNoYW5nZSkgaWYgKG0gPSBwcm9wLm1hdGNoKC9ec3BhbnNfKFxcXFxkKykkLykpIHtcXG4gICAgICAgICAgaWYgKGluZGV4T2YobmV3R3JvdXAsIE51bWJlcihtWzFdKSkgPiAtMSkge1xcbiAgICAgICAgICAgIGxzdChuZXdDaGFuZ2VzKVtwcm9wXSA9IGNoYW5nZVtwcm9wXTtcXG4gICAgICAgICAgICBkZWxldGUgY2hhbmdlW3Byb3BdO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICB9XFxuICAgIHJldHVybiBjb3B5O1xcbiAgfVxcblxcbiAgLy8gUmViYXNpbmcvcmVzZXR0aW5nIGhpc3RvcnkgdG8gZGVhbCB3aXRoIGV4dGVybmFsbHktc291cmNlZCBjaGFuZ2VzXFxuXFxuICBmdW5jdGlvbiByZWJhc2VIaXN0U2VsU2luZ2xlKHBvcywgZnJvbSwgdG8sIGRpZmYpIHtcXG4gICAgaWYgKHRvIDwgcG9zLmxpbmUpIHtcXG4gICAgICBwb3MubGluZSArPSBkaWZmO1xcbiAgICB9IGVsc2UgaWYgKGZyb20gPCBwb3MubGluZSkge1xcbiAgICAgIHBvcy5saW5lID0gZnJvbTtcXG4gICAgICBwb3MuY2ggPSAwO1xcbiAgICB9XFxuICB9XFxuXFxuICAvLyBUcmllcyB0byByZWJhc2UgYW4gYXJyYXkgb2YgaGlzdG9yeSBldmVudHMgZ2l2ZW4gYSBjaGFuZ2UgaW4gdGhlXFxuICAvLyBkb2N1bWVudC4gSWYgdGhlIGNoYW5nZSB0b3VjaGVzIHRoZSBzYW1lIGxpbmVzIGFzIHRoZSBldmVudCwgdGhlXFxuICAvLyBldmVudCwgYW5kIGV2ZXJ5dGhpbmcgJ2JlaGluZCcgaXQsIGlzIGRpc2NhcmRlZC4gSWYgdGhlIGNoYW5nZSBpc1xcbiAgLy8gYmVmb3JlIHRoZSBldmVudCwgdGhlIGV2ZW50J3MgcG9zaXRpb25zIGFyZSB1cGRhdGVkLiBVc2VzIGFcXG4gIC8vIGNvcHktb24td3JpdGUgc2NoZW1lIGZvciB0aGUgcG9zaXRpb25zLCB0byBhdm9pZCBoYXZpbmcgdG9cXG4gIC8vIHJlYWxsb2NhdGUgdGhlbSBhbGwgb24gZXZlcnkgcmViYXNlLCBidXQgYWxzbyBhdm9pZCBwcm9ibGVtcyB3aXRoXFxuICAvLyBzaGFyZWQgcG9zaXRpb24gb2JqZWN0cyBiZWluZyB1bnNhZmVseSB1cGRhdGVkLlxcbiAgZnVuY3Rpb24gcmViYXNlSGlzdEFycmF5KGFycmF5LCBmcm9tLCB0bywgZGlmZikge1xcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgKytpKSB7XFxuICAgICAgdmFyIHN1YiA9IGFycmF5W2ldLCBvayA9IHRydWU7XFxuICAgICAgaWYgKHN1Yi5yYW5nZXMpIHtcXG4gICAgICAgIGlmICghc3ViLmNvcGllZCkgeyBzdWIgPSBhcnJheVtpXSA9IHN1Yi5kZWVwQ29weSgpOyBzdWIuY29waWVkID0gdHJ1ZTsgfVxcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBzdWIucmFuZ2VzLmxlbmd0aDsgaisrKSB7XFxuICAgICAgICAgIHJlYmFzZUhpc3RTZWxTaW5nbGUoc3ViLnJhbmdlc1tqXS5hbmNob3IsIGZyb20sIHRvLCBkaWZmKTtcXG4gICAgICAgICAgcmViYXNlSGlzdFNlbFNpbmdsZShzdWIucmFuZ2VzW2pdLmhlYWQsIGZyb20sIHRvLCBkaWZmKTtcXG4gICAgICAgIH1cXG4gICAgICAgIGNvbnRpbnVlO1xcbiAgICAgIH1cXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHN1Yi5jaGFuZ2VzLmxlbmd0aDsgKytqKSB7XFxuICAgICAgICB2YXIgY3VyID0gc3ViLmNoYW5nZXNbal07XFxuICAgICAgICBpZiAodG8gPCBjdXIuZnJvbS5saW5lKSB7XFxuICAgICAgICAgIGN1ci5mcm9tID0gUG9zKGN1ci5mcm9tLmxpbmUgKyBkaWZmLCBjdXIuZnJvbS5jaCk7XFxuICAgICAgICAgIGN1ci50byA9IFBvcyhjdXIudG8ubGluZSArIGRpZmYsIGN1ci50by5jaCk7XFxuICAgICAgICB9IGVsc2UgaWYgKGZyb20gPD0gY3VyLnRvLmxpbmUpIHtcXG4gICAgICAgICAgb2sgPSBmYWxzZTtcXG4gICAgICAgICAgYnJlYWs7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICAgIGlmICghb2spIHtcXG4gICAgICAgIGFycmF5LnNwbGljZSgwLCBpICsgMSk7XFxuICAgICAgICBpID0gMDtcXG4gICAgICB9XFxuICAgIH1cXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIHJlYmFzZUhpc3QoaGlzdCwgY2hhbmdlKSB7XFxuICAgIHZhciBmcm9tID0gY2hhbmdlLmZyb20ubGluZSwgdG8gPSBjaGFuZ2UudG8ubGluZSwgZGlmZiA9IGNoYW5nZS50ZXh0Lmxlbmd0aCAtICh0byAtIGZyb20pIC0gMTtcXG4gICAgcmViYXNlSGlzdEFycmF5KGhpc3QuZG9uZSwgZnJvbSwgdG8sIGRpZmYpO1xcbiAgICByZWJhc2VIaXN0QXJyYXkoaGlzdC51bmRvbmUsIGZyb20sIHRvLCBkaWZmKTtcXG4gIH1cXG5cXG4gIC8vIEVWRU5UIFVUSUxJVElFU1xcblxcbiAgLy8gRHVlIHRvIHRoZSBmYWN0IHRoYXQgd2Ugc3RpbGwgc3VwcG9ydCBqdXJhc3NpYyBJRSB2ZXJzaW9ucywgc29tZVxcbiAgLy8gY29tcGF0aWJpbGl0eSB3cmFwcGVycyBhcmUgbmVlZGVkLlxcblxcbiAgdmFyIGVfcHJldmVudERlZmF1bHQgPSBDb2RlTWlycm9yLmVfcHJldmVudERlZmF1bHQgPSBmdW5jdGlvbihlKSB7XFxuICAgIGlmIChlLnByZXZlbnREZWZhdWx0KSBlLnByZXZlbnREZWZhdWx0KCk7XFxuICAgIGVsc2UgZS5yZXR1cm5WYWx1ZSA9IGZhbHNlO1xcbiAgfTtcXG4gIHZhciBlX3N0b3BQcm9wYWdhdGlvbiA9IENvZGVNaXJyb3IuZV9zdG9wUHJvcGFnYXRpb24gPSBmdW5jdGlvbihlKSB7XFxuICAgIGlmIChlLnN0b3BQcm9wYWdhdGlvbikgZS5zdG9wUHJvcGFnYXRpb24oKTtcXG4gICAgZWxzZSBlLmNhbmNlbEJ1YmJsZSA9IHRydWU7XFxuICB9O1xcbiAgZnVuY3Rpb24gZV9kZWZhdWx0UHJldmVudGVkKGUpIHtcXG4gICAgcmV0dXJuIGUuZGVmYXVsdFByZXZlbnRlZCAhPSBudWxsID8gZS5kZWZhdWx0UHJldmVudGVkIDogZS5yZXR1cm5WYWx1ZSA9PSBmYWxzZTtcXG4gIH1cXG4gIHZhciBlX3N0b3AgPSBDb2RlTWlycm9yLmVfc3RvcCA9IGZ1bmN0aW9uKGUpIHtlX3ByZXZlbnREZWZhdWx0KGUpOyBlX3N0b3BQcm9wYWdhdGlvbihlKTt9O1xcblxcbiAgZnVuY3Rpb24gZV90YXJnZXQoZSkge3JldHVybiBlLnRhcmdldCB8fCBlLnNyY0VsZW1lbnQ7fVxcbiAgZnVuY3Rpb24gZV9idXR0b24oZSkge1xcbiAgICB2YXIgYiA9IGUud2hpY2g7XFxuICAgIGlmIChiID09IG51bGwpIHtcXG4gICAgICBpZiAoZS5idXR0b24gJiAxKSBiID0gMTtcXG4gICAgICBlbHNlIGlmIChlLmJ1dHRvbiAmIDIpIGIgPSAzO1xcbiAgICAgIGVsc2UgaWYgKGUuYnV0dG9uICYgNCkgYiA9IDI7XFxuICAgIH1cXG4gICAgaWYgKG1hYyAmJiBlLmN0cmxLZXkgJiYgYiA9PSAxKSBiID0gMztcXG4gICAgcmV0dXJuIGI7XFxuICB9XFxuXFxuICAvLyBFVkVOVCBIQU5ETElOR1xcblxcbiAgLy8gTGlnaHR3ZWlnaHQgZXZlbnQgZnJhbWV3b3JrLiBvbi9vZmYgYWxzbyB3b3JrIG9uIERPTSBub2RlcyxcXG4gIC8vIHJlZ2lzdGVyaW5nIG5hdGl2ZSBET00gaGFuZGxlcnMuXFxuXFxuICB2YXIgb24gPSBDb2RlTWlycm9yLm9uID0gZnVuY3Rpb24oZW1pdHRlciwgdHlwZSwgZikge1xcbiAgICBpZiAoZW1pdHRlci5hZGRFdmVudExpc3RlbmVyKVxcbiAgICAgIGVtaXR0ZXIuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBmLCBmYWxzZSk7XFxuICAgIGVsc2UgaWYgKGVtaXR0ZXIuYXR0YWNoRXZlbnQpXFxuICAgICAgZW1pdHRlci5hdHRhY2hFdmVudChcXFwib25cXFwiICsgdHlwZSwgZik7XFxuICAgIGVsc2Uge1xcbiAgICAgIHZhciBtYXAgPSBlbWl0dGVyLl9oYW5kbGVycyB8fCAoZW1pdHRlci5faGFuZGxlcnMgPSB7fSk7XFxuICAgICAgdmFyIGFyciA9IG1hcFt0eXBlXSB8fCAobWFwW3R5cGVdID0gW10pO1xcbiAgICAgIGFyci5wdXNoKGYpO1xcbiAgICB9XFxuICB9O1xcblxcbiAgdmFyIG5vSGFuZGxlcnMgPSBbXVxcbiAgZnVuY3Rpb24gZ2V0SGFuZGxlcnMoZW1pdHRlciwgdHlwZSwgY29weSkge1xcbiAgICB2YXIgYXJyID0gZW1pdHRlci5faGFuZGxlcnMgJiYgZW1pdHRlci5faGFuZGxlcnNbdHlwZV1cXG4gICAgaWYgKGNvcHkpIHJldHVybiBhcnIgJiYgYXJyLmxlbmd0aCA+IDAgPyBhcnIuc2xpY2UoKSA6IG5vSGFuZGxlcnNcXG4gICAgZWxzZSByZXR1cm4gYXJyIHx8IG5vSGFuZGxlcnNcXG4gIH1cXG5cXG4gIHZhciBvZmYgPSBDb2RlTWlycm9yLm9mZiA9IGZ1bmN0aW9uKGVtaXR0ZXIsIHR5cGUsIGYpIHtcXG4gICAgaWYgKGVtaXR0ZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcilcXG4gICAgICBlbWl0dGVyLnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgZiwgZmFsc2UpO1xcbiAgICBlbHNlIGlmIChlbWl0dGVyLmRldGFjaEV2ZW50KVxcbiAgICAgIGVtaXR0ZXIuZGV0YWNoRXZlbnQoXFxcIm9uXFxcIiArIHR5cGUsIGYpO1xcbiAgICBlbHNlIHtcXG4gICAgICB2YXIgaGFuZGxlcnMgPSBnZXRIYW5kbGVycyhlbWl0dGVyLCB0eXBlLCBmYWxzZSlcXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhhbmRsZXJzLmxlbmd0aDsgKytpKVxcbiAgICAgICAgaWYgKGhhbmRsZXJzW2ldID09IGYpIHsgaGFuZGxlcnMuc3BsaWNlKGksIDEpOyBicmVhazsgfVxcbiAgICB9XFxuICB9O1xcblxcbiAgdmFyIHNpZ25hbCA9IENvZGVNaXJyb3Iuc2lnbmFsID0gZnVuY3Rpb24oZW1pdHRlciwgdHlwZSAvKiwgdmFsdWVzLi4uKi8pIHtcXG4gICAgdmFyIGhhbmRsZXJzID0gZ2V0SGFuZGxlcnMoZW1pdHRlciwgdHlwZSwgdHJ1ZSlcXG4gICAgaWYgKCFoYW5kbGVycy5sZW5ndGgpIHJldHVybjtcXG4gICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhhbmRsZXJzLmxlbmd0aDsgKytpKSBoYW5kbGVyc1tpXS5hcHBseShudWxsLCBhcmdzKTtcXG4gIH07XFxuXFxuICB2YXIgb3JwaGFuRGVsYXllZENhbGxiYWNrcyA9IG51bGw7XFxuXFxuICAvLyBPZnRlbiwgd2Ugd2FudCB0byBzaWduYWwgZXZlbnRzIGF0IGEgcG9pbnQgd2hlcmUgd2UgYXJlIGluIHRoZVxcbiAgLy8gbWlkZGxlIG9mIHNvbWUgd29yaywgYnV0IGRvbid0IHdhbnQgdGhlIGhhbmRsZXIgdG8gc3RhcnQgY2FsbGluZ1xcbiAgLy8gb3RoZXIgbWV0aG9kcyBvbiB0aGUgZWRpdG9yLCB3aGljaCBtaWdodCBiZSBpbiBhbiBpbmNvbnNpc3RlbnRcXG4gIC8vIHN0YXRlIG9yIHNpbXBseSBub3QgZXhwZWN0IGFueSBvdGhlciBldmVudHMgdG8gaGFwcGVuLlxcbiAgLy8gc2lnbmFsTGF0ZXIgbG9va3Mgd2hldGhlciB0aGVyZSBhcmUgYW55IGhhbmRsZXJzLCBhbmQgc2NoZWR1bGVzXFxuICAvLyB0aGVtIHRvIGJlIGV4ZWN1dGVkIHdoZW4gdGhlIGxhc3Qgb3BlcmF0aW9uIGVuZHMsIG9yLCBpZiBub1xcbiAgLy8gb3BlcmF0aW9uIGlzIGFjdGl2ZSwgd2hlbiBhIHRpbWVvdXQgZmlyZXMuXFxuICBmdW5jdGlvbiBzaWduYWxMYXRlcihlbWl0dGVyLCB0eXBlIC8qLCB2YWx1ZXMuLi4qLykge1xcbiAgICB2YXIgYXJyID0gZ2V0SGFuZGxlcnMoZW1pdHRlciwgdHlwZSwgZmFsc2UpXFxuICAgIGlmICghYXJyLmxlbmd0aCkgcmV0dXJuO1xcbiAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMiksIGxpc3Q7XFxuICAgIGlmIChvcGVyYXRpb25Hcm91cCkge1xcbiAgICAgIGxpc3QgPSBvcGVyYXRpb25Hcm91cC5kZWxheWVkQ2FsbGJhY2tzO1xcbiAgICB9IGVsc2UgaWYgKG9ycGhhbkRlbGF5ZWRDYWxsYmFja3MpIHtcXG4gICAgICBsaXN0ID0gb3JwaGFuRGVsYXllZENhbGxiYWNrcztcXG4gICAgfSBlbHNlIHtcXG4gICAgICBsaXN0ID0gb3JwaGFuRGVsYXllZENhbGxiYWNrcyA9IFtdO1xcbiAgICAgIHNldFRpbWVvdXQoZmlyZU9ycGhhbkRlbGF5ZWQsIDApO1xcbiAgICB9XFxuICAgIGZ1bmN0aW9uIGJuZChmKSB7cmV0dXJuIGZ1bmN0aW9uKCl7Zi5hcHBseShudWxsLCBhcmdzKTt9O307XFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgKytpKVxcbiAgICAgIGxpc3QucHVzaChibmQoYXJyW2ldKSk7XFxuICB9XFxuXFxuICBmdW5jdGlvbiBmaXJlT3JwaGFuRGVsYXllZCgpIHtcXG4gICAgdmFyIGRlbGF5ZWQgPSBvcnBoYW5EZWxheWVkQ2FsbGJhY2tzO1xcbiAgICBvcnBoYW5EZWxheWVkQ2FsbGJhY2tzID0gbnVsbDtcXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkZWxheWVkLmxlbmd0aDsgKytpKSBkZWxheWVkW2ldKCk7XFxuICB9XFxuXFxuICAvLyBUaGUgRE9NIGV2ZW50cyB0aGF0IENvZGVNaXJyb3IgaGFuZGxlcyBjYW4gYmUgb3ZlcnJpZGRlbiBieVxcbiAgLy8gcmVnaXN0ZXJpbmcgYSAobm9uLURPTSkgaGFuZGxlciBvbiB0aGUgZWRpdG9yIGZvciB0aGUgZXZlbnQgbmFtZSxcXG4gIC8vIGFuZCBwcmV2ZW50RGVmYXVsdC1pbmcgdGhlIGV2ZW50IGluIHRoYXQgaGFuZGxlci5cXG4gIGZ1bmN0aW9uIHNpZ25hbERPTUV2ZW50KGNtLCBlLCBvdmVycmlkZSkge1xcbiAgICBpZiAodHlwZW9mIGUgPT0gXFxcInN0cmluZ1xcXCIpXFxuICAgICAgZSA9IHt0eXBlOiBlLCBwcmV2ZW50RGVmYXVsdDogZnVuY3Rpb24oKSB7IHRoaXMuZGVmYXVsdFByZXZlbnRlZCA9IHRydWU7IH19O1xcbiAgICBzaWduYWwoY20sIG92ZXJyaWRlIHx8IGUudHlwZSwgY20sIGUpO1xcbiAgICByZXR1cm4gZV9kZWZhdWx0UHJldmVudGVkKGUpIHx8IGUuY29kZW1pcnJvcklnbm9yZTtcXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIHNpZ25hbEN1cnNvckFjdGl2aXR5KGNtKSB7XFxuICAgIHZhciBhcnIgPSBjbS5faGFuZGxlcnMgJiYgY20uX2hhbmRsZXJzLmN1cnNvckFjdGl2aXR5O1xcbiAgICBpZiAoIWFycikgcmV0dXJuO1xcbiAgICB2YXIgc2V0ID0gY20uY3VyT3AuY3Vyc29yQWN0aXZpdHlIYW5kbGVycyB8fCAoY20uY3VyT3AuY3Vyc29yQWN0aXZpdHlIYW5kbGVycyA9IFtdKTtcXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyArK2kpIGlmIChpbmRleE9mKHNldCwgYXJyW2ldKSA9PSAtMSlcXG4gICAgICBzZXQucHVzaChhcnJbaV0pO1xcbiAgfVxcblxcbiAgZnVuY3Rpb24gaGFzSGFuZGxlcihlbWl0dGVyLCB0eXBlKSB7XFxuICAgIHJldHVybiBnZXRIYW5kbGVycyhlbWl0dGVyLCB0eXBlKS5sZW5ndGggPiAwXFxuICB9XFxuXFxuICAvLyBBZGQgb24gYW5kIG9mZiBtZXRob2RzIHRvIGEgY29uc3RydWN0b3IncyBwcm90b3R5cGUsIHRvIG1ha2VcXG4gIC8vIHJlZ2lzdGVyaW5nIGV2ZW50cyBvbiBzdWNoIG9iamVjdHMgbW9yZSBjb252ZW5pZW50LlxcbiAgZnVuY3Rpb24gZXZlbnRNaXhpbihjdG9yKSB7XFxuICAgIGN0b3IucHJvdG90eXBlLm9uID0gZnVuY3Rpb24odHlwZSwgZikge29uKHRoaXMsIHR5cGUsIGYpO307XFxuICAgIGN0b3IucHJvdG90eXBlLm9mZiA9IGZ1bmN0aW9uKHR5cGUsIGYpIHtvZmYodGhpcywgdHlwZSwgZik7fTtcXG4gIH1cXG5cXG4gIC8vIE1JU0MgVVRJTElUSUVTXFxuXFxuICAvLyBOdW1iZXIgb2YgcGl4ZWxzIGFkZGVkIHRvIHNjcm9sbGVyIGFuZCBzaXplciB0byBoaWRlIHNjcm9sbGJhclxcbiAgdmFyIHNjcm9sbGVyR2FwID0gMzA7XFxuXFxuICAvLyBSZXR1cm5lZCBvciB0aHJvd24gYnkgdmFyaW91cyBwcm90b2NvbHMgdG8gc2lnbmFsICdJJ20gbm90XFxuICAvLyBoYW5kbGluZyB0aGlzJy5cXG4gIHZhciBQYXNzID0gQ29kZU1pcnJvci5QYXNzID0ge3RvU3RyaW5nOiBmdW5jdGlvbigpe3JldHVybiBcXFwiQ29kZU1pcnJvci5QYXNzXFxcIjt9fTtcXG5cXG4gIC8vIFJldXNlZCBvcHRpb24gb2JqZWN0cyBmb3Igc2V0U2VsZWN0aW9uICYgZnJpZW5kc1xcbiAgdmFyIHNlbF9kb250U2Nyb2xsID0ge3Njcm9sbDogZmFsc2V9LCBzZWxfbW91c2UgPSB7b3JpZ2luOiBcXFwiKm1vdXNlXFxcIn0sIHNlbF9tb3ZlID0ge29yaWdpbjogXFxcIittb3ZlXFxcIn07XFxuXFxuICBmdW5jdGlvbiBEZWxheWVkKCkge3RoaXMuaWQgPSBudWxsO31cXG4gIERlbGF5ZWQucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uKG1zLCBmKSB7XFxuICAgIGNsZWFyVGltZW91dCh0aGlzLmlkKTtcXG4gICAgdGhpcy5pZCA9IHNldFRpbWVvdXQoZiwgbXMpO1xcbiAgfTtcXG5cXG4gIC8vIENvdW50cyB0aGUgY29sdW1uIG9mZnNldCBpbiBhIHN0cmluZywgdGFraW5nIHRhYnMgaW50byBhY2NvdW50LlxcbiAgLy8gVXNlZCBtb3N0bHkgdG8gZmluZCBpbmRlbnRhdGlvbi5cXG4gIHZhciBjb3VudENvbHVtbiA9IENvZGVNaXJyb3IuY291bnRDb2x1bW4gPSBmdW5jdGlvbihzdHJpbmcsIGVuZCwgdGFiU2l6ZSwgc3RhcnRJbmRleCwgc3RhcnRWYWx1ZSkge1xcbiAgICBpZiAoZW5kID09IG51bGwpIHtcXG4gICAgICBlbmQgPSBzdHJpbmcuc2VhcmNoKC9bXlxcXFxzXFxcXHUwMGEwXS8pO1xcbiAgICAgIGlmIChlbmQgPT0gLTEpIGVuZCA9IHN0cmluZy5sZW5ndGg7XFxuICAgIH1cXG4gICAgZm9yICh2YXIgaSA9IHN0YXJ0SW5kZXggfHwgMCwgbiA9IHN0YXJ0VmFsdWUgfHwgMDs7KSB7XFxuICAgICAgdmFyIG5leHRUYWIgPSBzdHJpbmcuaW5kZXhPZihcXFwiXFxcXHRcXFwiLCBpKTtcXG4gICAgICBpZiAobmV4dFRhYiA8IDAgfHwgbmV4dFRhYiA+PSBlbmQpXFxuICAgICAgICByZXR1cm4gbiArIChlbmQgLSBpKTtcXG4gICAgICBuICs9IG5leHRUYWIgLSBpO1xcbiAgICAgIG4gKz0gdGFiU2l6ZSAtIChuICUgdGFiU2l6ZSk7XFxuICAgICAgaSA9IG5leHRUYWIgKyAxO1xcbiAgICB9XFxuICB9O1xcblxcbiAgLy8gVGhlIGludmVyc2Ugb2YgY291bnRDb2x1bW4gLS0gZmluZCB0aGUgb2Zmc2V0IHRoYXQgY29ycmVzcG9uZHMgdG9cXG4gIC8vIGEgcGFydGljdWxhciBjb2x1bW4uXFxuICB2YXIgZmluZENvbHVtbiA9IENvZGVNaXJyb3IuZmluZENvbHVtbiA9IGZ1bmN0aW9uKHN0cmluZywgZ29hbCwgdGFiU2l6ZSkge1xcbiAgICBmb3IgKHZhciBwb3MgPSAwLCBjb2wgPSAwOzspIHtcXG4gICAgICB2YXIgbmV4dFRhYiA9IHN0cmluZy5pbmRleE9mKFxcXCJcXFxcdFxcXCIsIHBvcyk7XFxuICAgICAgaWYgKG5leHRUYWIgPT0gLTEpIG5leHRUYWIgPSBzdHJpbmcubGVuZ3RoO1xcbiAgICAgIHZhciBza2lwcGVkID0gbmV4dFRhYiAtIHBvcztcXG4gICAgICBpZiAobmV4dFRhYiA9PSBzdHJpbmcubGVuZ3RoIHx8IGNvbCArIHNraXBwZWQgPj0gZ29hbClcXG4gICAgICAgIHJldHVybiBwb3MgKyBNYXRoLm1pbihza2lwcGVkLCBnb2FsIC0gY29sKTtcXG4gICAgICBjb2wgKz0gbmV4dFRhYiAtIHBvcztcXG4gICAgICBjb2wgKz0gdGFiU2l6ZSAtIChjb2wgJSB0YWJTaXplKTtcXG4gICAgICBwb3MgPSBuZXh0VGFiICsgMTtcXG4gICAgICBpZiAoY29sID49IGdvYWwpIHJldHVybiBwb3M7XFxuICAgIH1cXG4gIH1cXG5cXG4gIHZhciBzcGFjZVN0cnMgPSBbXFxcIlxcXCJdO1xcbiAgZnVuY3Rpb24gc3BhY2VTdHIobikge1xcbiAgICB3aGlsZSAoc3BhY2VTdHJzLmxlbmd0aCA8PSBuKVxcbiAgICAgIHNwYWNlU3Rycy5wdXNoKGxzdChzcGFjZVN0cnMpICsgXFxcIiBcXFwiKTtcXG4gICAgcmV0dXJuIHNwYWNlU3Ryc1tuXTtcXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIGxzdChhcnIpIHsgcmV0dXJuIGFyclthcnIubGVuZ3RoLTFdOyB9XFxuXFxuICB2YXIgc2VsZWN0SW5wdXQgPSBmdW5jdGlvbihub2RlKSB7IG5vZGUuc2VsZWN0KCk7IH07XFxuICBpZiAoaW9zKSAvLyBNb2JpbGUgU2FmYXJpIGFwcGFyZW50bHkgaGFzIGEgYnVnIHdoZXJlIHNlbGVjdCgpIGlzIGJyb2tlbi5cXG4gICAgc2VsZWN0SW5wdXQgPSBmdW5jdGlvbihub2RlKSB7IG5vZGUuc2VsZWN0aW9uU3RhcnQgPSAwOyBub2RlLnNlbGVjdGlvbkVuZCA9IG5vZGUudmFsdWUubGVuZ3RoOyB9O1xcbiAgZWxzZSBpZiAoaWUpIC8vIFN1cHByZXNzIG15c3RlcmlvdXMgSUUxMCBlcnJvcnNcXG4gICAgc2VsZWN0SW5wdXQgPSBmdW5jdGlvbihub2RlKSB7IHRyeSB7IG5vZGUuc2VsZWN0KCk7IH0gY2F0Y2goX2UpIHt9IH07XFxuXFxuICBmdW5jdGlvbiBpbmRleE9mKGFycmF5LCBlbHQpIHtcXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7ICsraSlcXG4gICAgICBpZiAoYXJyYXlbaV0gPT0gZWx0KSByZXR1cm4gaTtcXG4gICAgcmV0dXJuIC0xO1xcbiAgfVxcbiAgZnVuY3Rpb24gbWFwKGFycmF5LCBmKSB7XFxuICAgIHZhciBvdXQgPSBbXTtcXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykgb3V0W2ldID0gZihhcnJheVtpXSwgaSk7XFxuICAgIHJldHVybiBvdXQ7XFxuICB9XFxuXFxuICBmdW5jdGlvbiBpbnNlcnRTb3J0ZWQoYXJyYXksIHZhbHVlLCBzY29yZSkge1xcbiAgICB2YXIgcG9zID0gMCwgcHJpb3JpdHkgPSBzY29yZSh2YWx1ZSlcXG4gICAgd2hpbGUgKHBvcyA8IGFycmF5Lmxlbmd0aCAmJiBzY29yZShhcnJheVtwb3NdKSA8PSBwcmlvcml0eSkgcG9zKytcXG4gICAgYXJyYXkuc3BsaWNlKHBvcywgMCwgdmFsdWUpXFxuICB9XFxuXFxuICBmdW5jdGlvbiBub3RoaW5nKCkge31cXG5cXG4gIGZ1bmN0aW9uIGNyZWF0ZU9iaihiYXNlLCBwcm9wcykge1xcbiAgICB2YXIgaW5zdDtcXG4gICAgaWYgKE9iamVjdC5jcmVhdGUpIHtcXG4gICAgICBpbnN0ID0gT2JqZWN0LmNyZWF0ZShiYXNlKTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICBub3RoaW5nLnByb3RvdHlwZSA9IGJhc2U7XFxuICAgICAgaW5zdCA9IG5ldyBub3RoaW5nKCk7XFxuICAgIH1cXG4gICAgaWYgKHByb3BzKSBjb3B5T2JqKHByb3BzLCBpbnN0KTtcXG4gICAgcmV0dXJuIGluc3Q7XFxuICB9O1xcblxcbiAgZnVuY3Rpb24gY29weU9iaihvYmosIHRhcmdldCwgb3ZlcndyaXRlKSB7XFxuICAgIGlmICghdGFyZ2V0KSB0YXJnZXQgPSB7fTtcXG4gICAgZm9yICh2YXIgcHJvcCBpbiBvYmopXFxuICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShwcm9wKSAmJiAob3ZlcndyaXRlICE9PSBmYWxzZSB8fCAhdGFyZ2V0Lmhhc093blByb3BlcnR5KHByb3ApKSlcXG4gICAgICAgIHRhcmdldFtwcm9wXSA9IG9ialtwcm9wXTtcXG4gICAgcmV0dXJuIHRhcmdldDtcXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIGJpbmQoZikge1xcbiAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XFxuICAgIHJldHVybiBmdW5jdGlvbigpe3JldHVybiBmLmFwcGx5KG51bGwsIGFyZ3MpO307XFxuICB9XFxuXFxuICB2YXIgbm9uQVNDSUlTaW5nbGVDYXNlV29yZENoYXIgPSAvW1xcXFx1MDBkZlxcXFx1MDU4N1xcXFx1MDU5MC1cXFxcdTA1ZjRcXFxcdTA2MDAtXFxcXHUwNmZmXFxcXHUzMDQwLVxcXFx1MzA5ZlxcXFx1MzBhMC1cXFxcdTMwZmZcXFxcdTM0MDAtXFxcXHU0ZGI1XFxcXHU0ZTAwLVxcXFx1OWZjY1xcXFx1YWMwMC1cXFxcdWQ3YWZdLztcXG4gIHZhciBpc1dvcmRDaGFyQmFzaWMgPSBDb2RlTWlycm9yLmlzV29yZENoYXIgPSBmdW5jdGlvbihjaCkge1xcbiAgICByZXR1cm4gL1xcXFx3Ly50ZXN0KGNoKSB8fCBjaCA+IFxcXCJcXFxceDgwXFxcIiAmJlxcbiAgICAgIChjaC50b1VwcGVyQ2FzZSgpICE9IGNoLnRvTG93ZXJDYXNlKCkgfHwgbm9uQVNDSUlTaW5nbGVDYXNlV29yZENoYXIudGVzdChjaCkpO1xcbiAgfTtcXG4gIGZ1bmN0aW9uIGlzV29yZENoYXIoY2gsIGhlbHBlcikge1xcbiAgICBpZiAoIWhlbHBlcikgcmV0dXJuIGlzV29yZENoYXJCYXNpYyhjaCk7XFxuICAgIGlmIChoZWxwZXIuc291cmNlLmluZGV4T2YoXFxcIlxcXFxcXFxcd1xcXCIpID4gLTEgJiYgaXNXb3JkQ2hhckJhc2ljKGNoKSkgcmV0dXJuIHRydWU7XFxuICAgIHJldHVybiBoZWxwZXIudGVzdChjaCk7XFxuICB9XFxuXFxuICBmdW5jdGlvbiBpc0VtcHR5KG9iaikge1xcbiAgICBmb3IgKHZhciBuIGluIG9iaikgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShuKSAmJiBvYmpbbl0pIHJldHVybiBmYWxzZTtcXG4gICAgcmV0dXJuIHRydWU7XFxuICB9XFxuXFxuICAvLyBFeHRlbmRpbmcgdW5pY29kZSBjaGFyYWN0ZXJzLiBBIHNlcmllcyBvZiBhIG5vbi1leHRlbmRpbmcgY2hhciArXFxuICAvLyBhbnkgbnVtYmVyIG9mIGV4dGVuZGluZyBjaGFycyBpcyB0cmVhdGVkIGFzIGEgc2luZ2xlIHVuaXQgYXMgZmFyXFxuICAvLyBhcyBlZGl0aW5nIGFuZCBtZWFzdXJpbmcgaXMgY29uY2VybmVkLiBUaGlzIGlzIG5vdCBmdWxseSBjb3JyZWN0LFxcbiAgLy8gc2luY2Ugc29tZSBzY3JpcHRzL2ZvbnRzL2Jyb3dzZXJzIGFsc28gdHJlYXQgb3RoZXIgY29uZmlndXJhdGlvbnNcXG4gIC8vIG9mIGNvZGUgcG9pbnRzIGFzIGEgZ3JvdXAuXFxuICB2YXIgZXh0ZW5kaW5nQ2hhcnMgPSAvW1xcXFx1MDMwMC1cXFxcdTAzNmZcXFxcdTA0ODMtXFxcXHUwNDg5XFxcXHUwNTkxLVxcXFx1MDViZFxcXFx1MDViZlxcXFx1MDVjMVxcXFx1MDVjMlxcXFx1MDVjNFxcXFx1MDVjNVxcXFx1MDVjN1xcXFx1MDYxMC1cXFxcdTA2MWFcXFxcdTA2NGItXFxcXHUwNjVlXFxcXHUwNjcwXFxcXHUwNmQ2LVxcXFx1MDZkY1xcXFx1MDZkZS1cXFxcdTA2ZTRcXFxcdTA2ZTdcXFxcdTA2ZThcXFxcdTA2ZWEtXFxcXHUwNmVkXFxcXHUwNzExXFxcXHUwNzMwLVxcXFx1MDc0YVxcXFx1MDdhNi1cXFxcdTA3YjBcXFxcdTA3ZWItXFxcXHUwN2YzXFxcXHUwODE2LVxcXFx1MDgxOVxcXFx1MDgxYi1cXFxcdTA4MjNcXFxcdTA4MjUtXFxcXHUwODI3XFxcXHUwODI5LVxcXFx1MDgyZFxcXFx1MDkwMC1cXFxcdTA5MDJcXFxcdTA5M2NcXFxcdTA5NDEtXFxcXHUwOTQ4XFxcXHUwOTRkXFxcXHUwOTUxLVxcXFx1MDk1NVxcXFx1MDk2MlxcXFx1MDk2M1xcXFx1MDk4MVxcXFx1MDliY1xcXFx1MDliZVxcXFx1MDljMS1cXFxcdTA5YzRcXFxcdTA5Y2RcXFxcdTA5ZDdcXFxcdTA5ZTJcXFxcdTA5ZTNcXFxcdTBhMDFcXFxcdTBhMDJcXFxcdTBhM2NcXFxcdTBhNDFcXFxcdTBhNDJcXFxcdTBhNDdcXFxcdTBhNDhcXFxcdTBhNGItXFxcXHUwYTRkXFxcXHUwYTUxXFxcXHUwYTcwXFxcXHUwYTcxXFxcXHUwYTc1XFxcXHUwYTgxXFxcXHUwYTgyXFxcXHUwYWJjXFxcXHUwYWMxLVxcXFx1MGFjNVxcXFx1MGFjN1xcXFx1MGFjOFxcXFx1MGFjZFxcXFx1MGFlMlxcXFx1MGFlM1xcXFx1MGIwMVxcXFx1MGIzY1xcXFx1MGIzZVxcXFx1MGIzZlxcXFx1MGI0MS1cXFxcdTBiNDRcXFxcdTBiNGRcXFxcdTBiNTZcXFxcdTBiNTdcXFxcdTBiNjJcXFxcdTBiNjNcXFxcdTBiODJcXFxcdTBiYmVcXFxcdTBiYzBcXFxcdTBiY2RcXFxcdTBiZDdcXFxcdTBjM2UtXFxcXHUwYzQwXFxcXHUwYzQ2LVxcXFx1MGM0OFxcXFx1MGM0YS1cXFxcdTBjNGRcXFxcdTBjNTVcXFxcdTBjNTZcXFxcdTBjNjJcXFxcdTBjNjNcXFxcdTBjYmNcXFxcdTBjYmZcXFxcdTBjYzJcXFxcdTBjYzZcXFxcdTBjY2NcXFxcdTBjY2RcXFxcdTBjZDVcXFxcdTBjZDZcXFxcdTBjZTJcXFxcdTBjZTNcXFxcdTBkM2VcXFxcdTBkNDEtXFxcXHUwZDQ0XFxcXHUwZDRkXFxcXHUwZDU3XFxcXHUwZDYyXFxcXHUwZDYzXFxcXHUwZGNhXFxcXHUwZGNmXFxcXHUwZGQyLVxcXFx1MGRkNFxcXFx1MGRkNlxcXFx1MGRkZlxcXFx1MGUzMVxcXFx1MGUzNC1cXFxcdTBlM2FcXFxcdTBlNDctXFxcXHUwZTRlXFxcXHUwZWIxXFxcXHUwZWI0LVxcXFx1MGViOVxcXFx1MGViYlxcXFx1MGViY1xcXFx1MGVjOC1cXFxcdTBlY2RcXFxcdTBmMThcXFxcdTBmMTlcXFxcdTBmMzVcXFxcdTBmMzdcXFxcdTBmMzlcXFxcdTBmNzEtXFxcXHUwZjdlXFxcXHUwZjgwLVxcXFx1MGY4NFxcXFx1MGY4NlxcXFx1MGY4N1xcXFx1MGY5MC1cXFxcdTBmOTdcXFxcdTBmOTktXFxcXHUwZmJjXFxcXHUwZmM2XFxcXHUxMDJkLVxcXFx1MTAzMFxcXFx1MTAzMi1cXFxcdTEwMzdcXFxcdTEwMzlcXFxcdTEwM2FcXFxcdTEwM2RcXFxcdTEwM2VcXFxcdTEwNThcXFxcdTEwNTlcXFxcdTEwNWUtXFxcXHUxMDYwXFxcXHUxMDcxLVxcXFx1MTA3NFxcXFx1MTA4MlxcXFx1MTA4NVxcXFx1MTA4NlxcXFx1MTA4ZFxcXFx1MTA5ZFxcXFx1MTM1ZlxcXFx1MTcxMi1cXFxcdTE3MTRcXFxcdTE3MzItXFxcXHUxNzM0XFxcXHUxNzUyXFxcXHUxNzUzXFxcXHUxNzcyXFxcXHUxNzczXFxcXHUxN2I3LVxcXFx1MTdiZFxcXFx1MTdjNlxcXFx1MTdjOS1cXFxcdTE3ZDNcXFxcdTE3ZGRcXFxcdTE4MGItXFxcXHUxODBkXFxcXHUxOGE5XFxcXHUxOTIwLVxcXFx1MTkyMlxcXFx1MTkyN1xcXFx1MTkyOFxcXFx1MTkzMlxcXFx1MTkzOS1cXFxcdTE5M2JcXFxcdTFhMTdcXFxcdTFhMThcXFxcdTFhNTZcXFxcdTFhNTgtXFxcXHUxYTVlXFxcXHUxYTYwXFxcXHUxYTYyXFxcXHUxYTY1LVxcXFx1MWE2Y1xcXFx1MWE3My1cXFxcdTFhN2NcXFxcdTFhN2ZcXFxcdTFiMDAtXFxcXHUxYjAzXFxcXHUxYjM0XFxcXHUxYjM2LVxcXFx1MWIzYVxcXFx1MWIzY1xcXFx1MWI0MlxcXFx1MWI2Yi1cXFxcdTFiNzNcXFxcdTFiODBcXFxcdTFiODFcXFxcdTFiYTItXFxcXHUxYmE1XFxcXHUxYmE4XFxcXHUxYmE5XFxcXHUxYzJjLVxcXFx1MWMzM1xcXFx1MWMzNlxcXFx1MWMzN1xcXFx1MWNkMC1cXFxcdTFjZDJcXFxcdTFjZDQtXFxcXHUxY2UwXFxcXHUxY2UyLVxcXFx1MWNlOFxcXFx1MWNlZFxcXFx1MWRjMC1cXFxcdTFkZTZcXFxcdTFkZmQtXFxcXHUxZGZmXFxcXHUyMDBjXFxcXHUyMDBkXFxcXHUyMGQwLVxcXFx1MjBmMFxcXFx1MmNlZi1cXFxcdTJjZjFcXFxcdTJkZTAtXFxcXHUyZGZmXFxcXHUzMDJhLVxcXFx1MzAyZlxcXFx1MzA5OVxcXFx1MzA5YVxcXFx1YTY2Zi1cXFxcdWE2NzJcXFxcdWE2N2NcXFxcdWE2N2RcXFxcdWE2ZjBcXFxcdWE2ZjFcXFxcdWE4MDJcXFxcdWE4MDZcXFxcdWE4MGJcXFxcdWE4MjVcXFxcdWE4MjZcXFxcdWE4YzRcXFxcdWE4ZTAtXFxcXHVhOGYxXFxcXHVhOTI2LVxcXFx1YTkyZFxcXFx1YTk0Ny1cXFxcdWE5NTFcXFxcdWE5ODAtXFxcXHVhOTgyXFxcXHVhOWIzXFxcXHVhOWI2LVxcXFx1YTliOVxcXFx1YTliY1xcXFx1YWEyOS1cXFxcdWFhMmVcXFxcdWFhMzFcXFxcdWFhMzJcXFxcdWFhMzVcXFxcdWFhMzZcXFxcdWFhNDNcXFxcdWFhNGNcXFxcdWFhYjBcXFxcdWFhYjItXFxcXHVhYWI0XFxcXHVhYWI3XFxcXHVhYWI4XFxcXHVhYWJlXFxcXHVhYWJmXFxcXHVhYWMxXFxcXHVhYmU1XFxcXHVhYmU4XFxcXHVhYmVkXFxcXHVkYzAwLVxcXFx1ZGZmZlxcXFx1ZmIxZVxcXFx1ZmUwMC1cXFxcdWZlMGZcXFxcdWZlMjAtXFxcXHVmZTI2XFxcXHVmZjllXFxcXHVmZjlmXS87XFxuICBmdW5jdGlvbiBpc0V4dGVuZGluZ0NoYXIoY2gpIHsgcmV0dXJuIGNoLmNoYXJDb2RlQXQoMCkgPj0gNzY4ICYmIGV4dGVuZGluZ0NoYXJzLnRlc3QoY2gpOyB9XFxuXFxuICAvLyBET00gVVRJTElUSUVTXFxuXFxuICBmdW5jdGlvbiBlbHQodGFnLCBjb250ZW50LCBjbGFzc05hbWUsIHN0eWxlKSB7XFxuICAgIHZhciBlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xcbiAgICBpZiAoY2xhc3NOYW1lKSBlLmNsYXNzTmFtZSA9IGNsYXNzTmFtZTtcXG4gICAgaWYgKHN0eWxlKSBlLnN0eWxlLmNzc1RleHQgPSBzdHlsZTtcXG4gICAgaWYgKHR5cGVvZiBjb250ZW50ID09IFxcXCJzdHJpbmdcXFwiKSBlLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNvbnRlbnQpKTtcXG4gICAgZWxzZSBpZiAoY29udGVudCkgZm9yICh2YXIgaSA9IDA7IGkgPCBjb250ZW50Lmxlbmd0aDsgKytpKSBlLmFwcGVuZENoaWxkKGNvbnRlbnRbaV0pO1xcbiAgICByZXR1cm4gZTtcXG4gIH1cXG5cXG4gIHZhciByYW5nZTtcXG4gIGlmIChkb2N1bWVudC5jcmVhdGVSYW5nZSkgcmFuZ2UgPSBmdW5jdGlvbihub2RlLCBzdGFydCwgZW5kLCBlbmROb2RlKSB7XFxuICAgIHZhciByID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcXG4gICAgci5zZXRFbmQoZW5kTm9kZSB8fCBub2RlLCBlbmQpO1xcbiAgICByLnNldFN0YXJ0KG5vZGUsIHN0YXJ0KTtcXG4gICAgcmV0dXJuIHI7XFxuICB9O1xcbiAgZWxzZSByYW5nZSA9IGZ1bmN0aW9uKG5vZGUsIHN0YXJ0LCBlbmQpIHtcXG4gICAgdmFyIHIgPSBkb2N1bWVudC5ib2R5LmNyZWF0ZVRleHRSYW5nZSgpO1xcbiAgICB0cnkgeyByLm1vdmVUb0VsZW1lbnRUZXh0KG5vZGUucGFyZW50Tm9kZSk7IH1cXG4gICAgY2F0Y2goZSkgeyByZXR1cm4gcjsgfVxcbiAgICByLmNvbGxhcHNlKHRydWUpO1xcbiAgICByLm1vdmVFbmQoXFxcImNoYXJhY3RlclxcXCIsIGVuZCk7XFxuICAgIHIubW92ZVN0YXJ0KFxcXCJjaGFyYWN0ZXJcXFwiLCBzdGFydCk7XFxuICAgIHJldHVybiByO1xcbiAgfTtcXG5cXG4gIGZ1bmN0aW9uIHJlbW92ZUNoaWxkcmVuKGUpIHtcXG4gICAgZm9yICh2YXIgY291bnQgPSBlLmNoaWxkTm9kZXMubGVuZ3RoOyBjb3VudCA+IDA7IC0tY291bnQpXFxuICAgICAgZS5yZW1vdmVDaGlsZChlLmZpcnN0Q2hpbGQpO1xcbiAgICByZXR1cm4gZTtcXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIHJlbW92ZUNoaWxkcmVuQW5kQWRkKHBhcmVudCwgZSkge1xcbiAgICByZXR1cm4gcmVtb3ZlQ2hpbGRyZW4ocGFyZW50KS5hcHBlbmRDaGlsZChlKTtcXG4gIH1cXG5cXG4gIHZhciBjb250YWlucyA9IENvZGVNaXJyb3IuY29udGFpbnMgPSBmdW5jdGlvbihwYXJlbnQsIGNoaWxkKSB7XFxuICAgIGlmIChjaGlsZC5ub2RlVHlwZSA9PSAzKSAvLyBBbmRyb2lkIGJyb3dzZXIgYWx3YXlzIHJldHVybnMgZmFsc2Ugd2hlbiBjaGlsZCBpcyBhIHRleHRub2RlXFxuICAgICAgY2hpbGQgPSBjaGlsZC5wYXJlbnROb2RlO1xcbiAgICBpZiAocGFyZW50LmNvbnRhaW5zKVxcbiAgICAgIHJldHVybiBwYXJlbnQuY29udGFpbnMoY2hpbGQpO1xcbiAgICBkbyB7XFxuICAgICAgaWYgKGNoaWxkLm5vZGVUeXBlID09IDExKSBjaGlsZCA9IGNoaWxkLmhvc3Q7XFxuICAgICAgaWYgKGNoaWxkID09IHBhcmVudCkgcmV0dXJuIHRydWU7XFxuICAgIH0gd2hpbGUgKGNoaWxkID0gY2hpbGQucGFyZW50Tm9kZSk7XFxuICB9O1xcblxcbiAgZnVuY3Rpb24gYWN0aXZlRWx0KCkge1xcbiAgICB2YXIgYWN0aXZlRWxlbWVudCA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XFxuICAgIHdoaWxlIChhY3RpdmVFbGVtZW50ICYmIGFjdGl2ZUVsZW1lbnQucm9vdCAmJiBhY3RpdmVFbGVtZW50LnJvb3QuYWN0aXZlRWxlbWVudClcXG4gICAgICBhY3RpdmVFbGVtZW50ID0gYWN0aXZlRWxlbWVudC5yb290LmFjdGl2ZUVsZW1lbnQ7XFxuICAgIHJldHVybiBhY3RpdmVFbGVtZW50O1xcbiAgfVxcbiAgLy8gT2xkZXIgdmVyc2lvbnMgb2YgSUUgdGhyb3dzIHVuc3BlY2lmaWVkIGVycm9yIHdoZW4gdG91Y2hpbmdcXG4gIC8vIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgaW4gc29tZSBjYXNlcyAoZHVyaW5nIGxvYWRpbmcsIGluIGlmcmFtZSlcXG4gIGlmIChpZSAmJiBpZV92ZXJzaW9uIDwgMTEpIGFjdGl2ZUVsdCA9IGZ1bmN0aW9uKCkge1xcbiAgICB0cnkgeyByZXR1cm4gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDsgfVxcbiAgICBjYXRjaChlKSB7IHJldHVybiBkb2N1bWVudC5ib2R5OyB9XFxuICB9O1xcblxcbiAgZnVuY3Rpb24gY2xhc3NUZXN0KGNscykgeyByZXR1cm4gbmV3IFJlZ0V4cChcXFwiKF58XFxcXFxcXFxzKVxcXCIgKyBjbHMgKyBcXFwiKD86JHxcXFxcXFxcXHMpXFxcXFxcXFxzKlxcXCIpOyB9XFxuICB2YXIgcm1DbGFzcyA9IENvZGVNaXJyb3Iucm1DbGFzcyA9IGZ1bmN0aW9uKG5vZGUsIGNscykge1xcbiAgICB2YXIgY3VycmVudCA9IG5vZGUuY2xhc3NOYW1lO1xcbiAgICB2YXIgbWF0Y2ggPSBjbGFzc1Rlc3QoY2xzKS5leGVjKGN1cnJlbnQpO1xcbiAgICBpZiAobWF0Y2gpIHtcXG4gICAgICB2YXIgYWZ0ZXIgPSBjdXJyZW50LnNsaWNlKG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoKTtcXG4gICAgICBub2RlLmNsYXNzTmFtZSA9IGN1cnJlbnQuc2xpY2UoMCwgbWF0Y2guaW5kZXgpICsgKGFmdGVyID8gbWF0Y2hbMV0gKyBhZnRlciA6IFxcXCJcXFwiKTtcXG4gICAgfVxcbiAgfTtcXG4gIHZhciBhZGRDbGFzcyA9IENvZGVNaXJyb3IuYWRkQ2xhc3MgPSBmdW5jdGlvbihub2RlLCBjbHMpIHtcXG4gICAgdmFyIGN1cnJlbnQgPSBub2RlLmNsYXNzTmFtZTtcXG4gICAgaWYgKCFjbGFzc1Rlc3QoY2xzKS50ZXN0KGN1cnJlbnQpKSBub2RlLmNsYXNzTmFtZSArPSAoY3VycmVudCA/IFxcXCIgXFxcIiA6IFxcXCJcXFwiKSArIGNscztcXG4gIH07XFxuICBmdW5jdGlvbiBqb2luQ2xhc3NlcyhhLCBiKSB7XFxuICAgIHZhciBhcyA9IGEuc3BsaXQoXFxcIiBcXFwiKTtcXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcy5sZW5ndGg7IGkrKylcXG4gICAgICBpZiAoYXNbaV0gJiYgIWNsYXNzVGVzdChhc1tpXSkudGVzdChiKSkgYiArPSBcXFwiIFxcXCIgKyBhc1tpXTtcXG4gICAgcmV0dXJuIGI7XFxuICB9XFxuXFxuICAvLyBXSU5ET1ctV0lERSBFVkVOVFNcXG5cXG4gIC8vIFRoZXNlIG11c3QgYmUgaGFuZGxlZCBjYXJlZnVsbHksIGJlY2F1c2UgbmFpdmVseSByZWdpc3RlcmluZyBhXFxuICAvLyBoYW5kbGVyIGZvciBlYWNoIGVkaXRvciB3aWxsIGNhdXNlIHRoZSBlZGl0b3JzIHRvIG5ldmVyIGJlXFxuICAvLyBnYXJiYWdlIGNvbGxlY3RlZC5cXG5cXG4gIGZ1bmN0aW9uIGZvckVhY2hDb2RlTWlycm9yKGYpIHtcXG4gICAgaWYgKCFkb2N1bWVudC5ib2R5LmdldEVsZW1lbnRzQnlDbGFzc05hbWUpIHJldHVybjtcXG4gICAgdmFyIGJ5Q2xhc3MgPSBkb2N1bWVudC5ib2R5LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoXFxcIkNvZGVNaXJyb3JcXFwiKTtcXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBieUNsYXNzLmxlbmd0aDsgaSsrKSB7XFxuICAgICAgdmFyIGNtID0gYnlDbGFzc1tpXS5Db2RlTWlycm9yO1xcbiAgICAgIGlmIChjbSkgZihjbSk7XFxuICAgIH1cXG4gIH1cXG5cXG4gIHZhciBnbG9iYWxzUmVnaXN0ZXJlZCA9IGZhbHNlO1xcbiAgZnVuY3Rpb24gZW5zdXJlR2xvYmFsSGFuZGxlcnMoKSB7XFxuICAgIGlmIChnbG9iYWxzUmVnaXN0ZXJlZCkgcmV0dXJuO1xcbiAgICByZWdpc3Rlckdsb2JhbEhhbmRsZXJzKCk7XFxuICAgIGdsb2JhbHNSZWdpc3RlcmVkID0gdHJ1ZTtcXG4gIH1cXG4gIGZ1bmN0aW9uIHJlZ2lzdGVyR2xvYmFsSGFuZGxlcnMoKSB7XFxuICAgIC8vIFdoZW4gdGhlIHdpbmRvdyByZXNpemVzLCB3ZSBuZWVkIHRvIHJlZnJlc2ggYWN0aXZlIGVkaXRvcnMuXFxuICAgIHZhciByZXNpemVUaW1lcjtcXG4gICAgb24od2luZG93LCBcXFwicmVzaXplXFxcIiwgZnVuY3Rpb24oKSB7XFxuICAgICAgaWYgKHJlc2l6ZVRpbWVyID09IG51bGwpIHJlc2l6ZVRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcXG4gICAgICAgIHJlc2l6ZVRpbWVyID0gbnVsbDtcXG4gICAgICAgIGZvckVhY2hDb2RlTWlycm9yKG9uUmVzaXplKTtcXG4gICAgICB9LCAxMDApO1xcbiAgICB9KTtcXG4gICAgLy8gV2hlbiB0aGUgd2luZG93IGxvc2VzIGZvY3VzLCB3ZSB3YW50IHRvIHNob3cgdGhlIGVkaXRvciBhcyBibHVycmVkXFxuICAgIG9uKHdpbmRvdywgXFxcImJsdXJcXFwiLCBmdW5jdGlvbigpIHtcXG4gICAgICBmb3JFYWNoQ29kZU1pcnJvcihvbkJsdXIpO1xcbiAgICB9KTtcXG4gIH1cXG5cXG4gIC8vIEZFQVRVUkUgREVURUNUSU9OXFxuXFxuICAvLyBEZXRlY3QgZHJhZy1hbmQtZHJvcFxcbiAgdmFyIGRyYWdBbmREcm9wID0gZnVuY3Rpb24oKSB7XFxuICAgIC8vIFRoZXJlIGlzICpzb21lKiBraW5kIG9mIGRyYWctYW5kLWRyb3Agc3VwcG9ydCBpbiBJRTYtOCwgYnV0IElcXG4gICAgLy8gY291bGRuJ3QgZ2V0IGl0IHRvIHdvcmsgeWV0LlxcbiAgICBpZiAoaWUgJiYgaWVfdmVyc2lvbiA8IDkpIHJldHVybiBmYWxzZTtcXG4gICAgdmFyIGRpdiA9IGVsdCgnZGl2Jyk7XFxuICAgIHJldHVybiBcXFwiZHJhZ2dhYmxlXFxcIiBpbiBkaXYgfHwgXFxcImRyYWdEcm9wXFxcIiBpbiBkaXY7XFxuICB9KCk7XFxuXFxuICB2YXIgendzcFN1cHBvcnRlZDtcXG4gIGZ1bmN0aW9uIHplcm9XaWR0aEVsZW1lbnQobWVhc3VyZSkge1xcbiAgICBpZiAoendzcFN1cHBvcnRlZCA9PSBudWxsKSB7XFxuICAgICAgdmFyIHRlc3QgPSBlbHQoXFxcInNwYW5cXFwiLCBcXFwiXFxcXHUyMDBiXFxcIik7XFxuICAgICAgcmVtb3ZlQ2hpbGRyZW5BbmRBZGQobWVhc3VyZSwgZWx0KFxcXCJzcGFuXFxcIiwgW3Rlc3QsIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFxcXCJ4XFxcIildKSk7XFxuICAgICAgaWYgKG1lYXN1cmUuZmlyc3RDaGlsZC5vZmZzZXRIZWlnaHQgIT0gMClcXG4gICAgICAgIHp3c3BTdXBwb3J0ZWQgPSB0ZXN0Lm9mZnNldFdpZHRoIDw9IDEgJiYgdGVzdC5vZmZzZXRIZWlnaHQgPiAyICYmICEoaWUgJiYgaWVfdmVyc2lvbiA8IDgpO1xcbiAgICB9XFxuICAgIHZhciBub2RlID0gendzcFN1cHBvcnRlZCA/IGVsdChcXFwic3BhblxcXCIsIFxcXCJcXFxcdTIwMGJcXFwiKSA6XFxuICAgICAgZWx0KFxcXCJzcGFuXFxcIiwgXFxcIlxcXFx1MDBhMFxcXCIsIG51bGwsIFxcXCJkaXNwbGF5OiBpbmxpbmUtYmxvY2s7IHdpZHRoOiAxcHg7IG1hcmdpbi1yaWdodDogLTFweFxcXCIpO1xcbiAgICBub2RlLnNldEF0dHJpYnV0ZShcXFwiY20tdGV4dFxcXCIsIFxcXCJcXFwiKTtcXG4gICAgcmV0dXJuIG5vZGU7XFxuICB9XFxuXFxuICAvLyBGZWF0dXJlLWRldGVjdCBJRSdzIGNydW1teSBjbGllbnQgcmVjdCByZXBvcnRpbmcgZm9yIGJpZGkgdGV4dFxcbiAgdmFyIGJhZEJpZGlSZWN0cztcXG4gIGZ1bmN0aW9uIGhhc0JhZEJpZGlSZWN0cyhtZWFzdXJlKSB7XFxuICAgIGlmIChiYWRCaWRpUmVjdHMgIT0gbnVsbCkgcmV0dXJuIGJhZEJpZGlSZWN0cztcXG4gICAgdmFyIHR4dCA9IHJlbW92ZUNoaWxkcmVuQW5kQWRkKG1lYXN1cmUsIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFxcXCJBXFxcXHUwNjJlQVxcXCIpKTtcXG4gICAgdmFyIHIwID0gcmFuZ2UodHh0LCAwLCAxKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcXG4gICAgdmFyIHIxID0gcmFuZ2UodHh0LCAxLCAyKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcXG4gICAgcmVtb3ZlQ2hpbGRyZW4obWVhc3VyZSk7XFxuICAgIGlmICghcjAgfHwgcjAubGVmdCA9PSByMC5yaWdodCkgcmV0dXJuIGZhbHNlOyAvLyBTYWZhcmkgcmV0dXJucyBudWxsIGluIHNvbWUgY2FzZXMgKCMyNzgwKVxcbiAgICByZXR1cm4gYmFkQmlkaVJlY3RzID0gKHIxLnJpZ2h0IC0gcjAucmlnaHQgPCAzKTtcXG4gIH1cXG5cXG4gIC8vIFNlZSBpZiBcXFwiXFxcIi5zcGxpdCBpcyB0aGUgYnJva2VuIElFIHZlcnNpb24sIGlmIHNvLCBwcm92aWRlIGFuXFxuICAvLyBhbHRlcm5hdGl2ZSB3YXkgdG8gc3BsaXQgbGluZXMuXFxuICB2YXIgc3BsaXRMaW5lc0F1dG8gPSBDb2RlTWlycm9yLnNwbGl0TGluZXMgPSBcXFwiXFxcXG5cXFxcbmJcXFwiLnNwbGl0KC9cXFxcbi8pLmxlbmd0aCAhPSAzID8gZnVuY3Rpb24oc3RyaW5nKSB7XFxuICAgIHZhciBwb3MgPSAwLCByZXN1bHQgPSBbXSwgbCA9IHN0cmluZy5sZW5ndGg7XFxuICAgIHdoaWxlIChwb3MgPD0gbCkge1xcbiAgICAgIHZhciBubCA9IHN0cmluZy5pbmRleE9mKFxcXCJcXFxcblxcXCIsIHBvcyk7XFxuICAgICAgaWYgKG5sID09IC0xKSBubCA9IHN0cmluZy5sZW5ndGg7XFxuICAgICAgdmFyIGxpbmUgPSBzdHJpbmcuc2xpY2UocG9zLCBzdHJpbmcuY2hhckF0KG5sIC0gMSkgPT0gXFxcIlxcXFxyXFxcIiA/IG5sIC0gMSA6IG5sKTtcXG4gICAgICB2YXIgcnQgPSBsaW5lLmluZGV4T2YoXFxcIlxcXFxyXFxcIik7XFxuICAgICAgaWYgKHJ0ICE9IC0xKSB7XFxuICAgICAgICByZXN1bHQucHVzaChsaW5lLnNsaWNlKDAsIHJ0KSk7XFxuICAgICAgICBwb3MgKz0gcnQgKyAxO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICByZXN1bHQucHVzaChsaW5lKTtcXG4gICAgICAgIHBvcyA9IG5sICsgMTtcXG4gICAgICB9XFxuICAgIH1cXG4gICAgcmV0dXJuIHJlc3VsdDtcXG4gIH0gOiBmdW5jdGlvbihzdHJpbmcpe3JldHVybiBzdHJpbmcuc3BsaXQoL1xcXFxyXFxcXG4/fFxcXFxuLyk7fTtcXG5cXG4gIHZhciBoYXNTZWxlY3Rpb24gPSB3aW5kb3cuZ2V0U2VsZWN0aW9uID8gZnVuY3Rpb24odGUpIHtcXG4gICAgdHJ5IHsgcmV0dXJuIHRlLnNlbGVjdGlvblN0YXJ0ICE9IHRlLnNlbGVjdGlvbkVuZDsgfVxcbiAgICBjYXRjaChlKSB7IHJldHVybiBmYWxzZTsgfVxcbiAgfSA6IGZ1bmN0aW9uKHRlKSB7XFxuICAgIHRyeSB7dmFyIHJhbmdlID0gdGUub3duZXJEb2N1bWVudC5zZWxlY3Rpb24uY3JlYXRlUmFuZ2UoKTt9XFxuICAgIGNhdGNoKGUpIHt9XFxuICAgIGlmICghcmFuZ2UgfHwgcmFuZ2UucGFyZW50RWxlbWVudCgpICE9IHRlKSByZXR1cm4gZmFsc2U7XFxuICAgIHJldHVybiByYW5nZS5jb21wYXJlRW5kUG9pbnRzKFxcXCJTdGFydFRvRW5kXFxcIiwgcmFuZ2UpICE9IDA7XFxuICB9O1xcblxcbiAgdmFyIGhhc0NvcHlFdmVudCA9IChmdW5jdGlvbigpIHtcXG4gICAgdmFyIGUgPSBlbHQoXFxcImRpdlxcXCIpO1xcbiAgICBpZiAoXFxcIm9uY29weVxcXCIgaW4gZSkgcmV0dXJuIHRydWU7XFxuICAgIGUuc2V0QXR0cmlidXRlKFxcXCJvbmNvcHlcXFwiLCBcXFwicmV0dXJuO1xcXCIpO1xcbiAgICByZXR1cm4gdHlwZW9mIGUub25jb3B5ID09IFxcXCJmdW5jdGlvblxcXCI7XFxuICB9KSgpO1xcblxcbiAgdmFyIGJhZFpvb21lZFJlY3RzID0gbnVsbDtcXG4gIGZ1bmN0aW9uIGhhc0JhZFpvb21lZFJlY3RzKG1lYXN1cmUpIHtcXG4gICAgaWYgKGJhZFpvb21lZFJlY3RzICE9IG51bGwpIHJldHVybiBiYWRab29tZWRSZWN0cztcXG4gICAgdmFyIG5vZGUgPSByZW1vdmVDaGlsZHJlbkFuZEFkZChtZWFzdXJlLCBlbHQoXFxcInNwYW5cXFwiLCBcXFwieFxcXCIpKTtcXG4gICAgdmFyIG5vcm1hbCA9IG5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XFxuICAgIHZhciBmcm9tUmFuZ2UgPSByYW5nZShub2RlLCAwLCAxKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcXG4gICAgcmV0dXJuIGJhZFpvb21lZFJlY3RzID0gTWF0aC5hYnMobm9ybWFsLmxlZnQgLSBmcm9tUmFuZ2UubGVmdCkgPiAxO1xcbiAgfVxcblxcbiAgLy8gS0VZIE5BTUVTXFxuXFxuICB2YXIga2V5TmFtZXMgPSBDb2RlTWlycm9yLmtleU5hbWVzID0ge1xcbiAgICAzOiBcXFwiRW50ZXJcXFwiLCA4OiBcXFwiQmFja3NwYWNlXFxcIiwgOTogXFxcIlRhYlxcXCIsIDEzOiBcXFwiRW50ZXJcXFwiLCAxNjogXFxcIlNoaWZ0XFxcIiwgMTc6IFxcXCJDdHJsXFxcIiwgMTg6IFxcXCJBbHRcXFwiLFxcbiAgICAxOTogXFxcIlBhdXNlXFxcIiwgMjA6IFxcXCJDYXBzTG9ja1xcXCIsIDI3OiBcXFwiRXNjXFxcIiwgMzI6IFxcXCJTcGFjZVxcXCIsIDMzOiBcXFwiUGFnZVVwXFxcIiwgMzQ6IFxcXCJQYWdlRG93blxcXCIsIDM1OiBcXFwiRW5kXFxcIixcXG4gICAgMzY6IFxcXCJIb21lXFxcIiwgMzc6IFxcXCJMZWZ0XFxcIiwgMzg6IFxcXCJVcFxcXCIsIDM5OiBcXFwiUmlnaHRcXFwiLCA0MDogXFxcIkRvd25cXFwiLCA0NDogXFxcIlByaW50U2NyblxcXCIsIDQ1OiBcXFwiSW5zZXJ0XFxcIixcXG4gICAgNDY6IFxcXCJEZWxldGVcXFwiLCA1OTogXFxcIjtcXFwiLCA2MTogXFxcIj1cXFwiLCA5MTogXFxcIk1vZFxcXCIsIDkyOiBcXFwiTW9kXFxcIiwgOTM6IFxcXCJNb2RcXFwiLFxcbiAgICAxMDY6IFxcXCIqXFxcIiwgMTA3OiBcXFwiPVxcXCIsIDEwOTogXFxcIi1cXFwiLCAxMTA6IFxcXCIuXFxcIiwgMTExOiBcXFwiL1xcXCIsIDEyNzogXFxcIkRlbGV0ZVxcXCIsXFxuICAgIDE3MzogXFxcIi1cXFwiLCAxODY6IFxcXCI7XFxcIiwgMTg3OiBcXFwiPVxcXCIsIDE4ODogXFxcIixcXFwiLCAxODk6IFxcXCItXFxcIiwgMTkwOiBcXFwiLlxcXCIsIDE5MTogXFxcIi9cXFwiLCAxOTI6IFxcXCJgXFxcIiwgMjE5OiBcXFwiW1xcXCIsIDIyMDogXFxcIlxcXFxcXFxcXFxcIixcXG4gICAgMjIxOiBcXFwiXVxcXCIsIDIyMjogXFxcIidcXFwiLCA2MzIzMjogXFxcIlVwXFxcIiwgNjMyMzM6IFxcXCJEb3duXFxcIiwgNjMyMzQ6IFxcXCJMZWZ0XFxcIiwgNjMyMzU6IFxcXCJSaWdodFxcXCIsIDYzMjcyOiBcXFwiRGVsZXRlXFxcIixcXG4gICAgNjMyNzM6IFxcXCJIb21lXFxcIiwgNjMyNzU6IFxcXCJFbmRcXFwiLCA2MzI3NjogXFxcIlBhZ2VVcFxcXCIsIDYzMjc3OiBcXFwiUGFnZURvd25cXFwiLCA2MzMwMjogXFxcIkluc2VydFxcXCJcXG4gIH07XFxuICAoZnVuY3Rpb24oKSB7XFxuICAgIC8vIE51bWJlciBrZXlzXFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMTA7IGkrKykga2V5TmFtZXNbaSArIDQ4XSA9IGtleU5hbWVzW2kgKyA5Nl0gPSBTdHJpbmcoaSk7XFxuICAgIC8vIEFscGhhYmV0aWMga2V5c1xcbiAgICBmb3IgKHZhciBpID0gNjU7IGkgPD0gOTA7IGkrKykga2V5TmFtZXNbaV0gPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGkpO1xcbiAgICAvLyBGdW5jdGlvbiBrZXlzXFxuICAgIGZvciAodmFyIGkgPSAxOyBpIDw9IDEyOyBpKyspIGtleU5hbWVzW2kgKyAxMTFdID0ga2V5TmFtZXNbaSArIDYzMjM1XSA9IFxcXCJGXFxcIiArIGk7XFxuICB9KSgpO1xcblxcbiAgLy8gQklESSBIRUxQRVJTXFxuXFxuICBmdW5jdGlvbiBpdGVyYXRlQmlkaVNlY3Rpb25zKG9yZGVyLCBmcm9tLCB0bywgZikge1xcbiAgICBpZiAoIW9yZGVyKSByZXR1cm4gZihmcm9tLCB0bywgXFxcImx0clxcXCIpO1xcbiAgICB2YXIgZm91bmQgPSBmYWxzZTtcXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcmRlci5sZW5ndGg7ICsraSkge1xcbiAgICAgIHZhciBwYXJ0ID0gb3JkZXJbaV07XFxuICAgICAgaWYgKHBhcnQuZnJvbSA8IHRvICYmIHBhcnQudG8gPiBmcm9tIHx8IGZyb20gPT0gdG8gJiYgcGFydC50byA9PSBmcm9tKSB7XFxuICAgICAgICBmKE1hdGgubWF4KHBhcnQuZnJvbSwgZnJvbSksIE1hdGgubWluKHBhcnQudG8sIHRvKSwgcGFydC5sZXZlbCA9PSAxID8gXFxcInJ0bFxcXCIgOiBcXFwibHRyXFxcIik7XFxuICAgICAgICBmb3VuZCA9IHRydWU7XFxuICAgICAgfVxcbiAgICB9XFxuICAgIGlmICghZm91bmQpIGYoZnJvbSwgdG8sIFxcXCJsdHJcXFwiKTtcXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIGJpZGlMZWZ0KHBhcnQpIHsgcmV0dXJuIHBhcnQubGV2ZWwgJSAyID8gcGFydC50byA6IHBhcnQuZnJvbTsgfVxcbiAgZnVuY3Rpb24gYmlkaVJpZ2h0KHBhcnQpIHsgcmV0dXJuIHBhcnQubGV2ZWwgJSAyID8gcGFydC5mcm9tIDogcGFydC50bzsgfVxcblxcbiAgZnVuY3Rpb24gbGluZUxlZnQobGluZSkgeyB2YXIgb3JkZXIgPSBnZXRPcmRlcihsaW5lKTsgcmV0dXJuIG9yZGVyID8gYmlkaUxlZnQob3JkZXJbMF0pIDogMDsgfVxcbiAgZnVuY3Rpb24gbGluZVJpZ2h0KGxpbmUpIHtcXG4gICAgdmFyIG9yZGVyID0gZ2V0T3JkZXIobGluZSk7XFxuICAgIGlmICghb3JkZXIpIHJldHVybiBsaW5lLnRleHQubGVuZ3RoO1xcbiAgICByZXR1cm4gYmlkaVJpZ2h0KGxzdChvcmRlcikpO1xcbiAgfVxcblxcbiAgZnVuY3Rpb24gbGluZVN0YXJ0KGNtLCBsaW5lTikge1xcbiAgICB2YXIgbGluZSA9IGdldExpbmUoY20uZG9jLCBsaW5lTik7XFxuICAgIHZhciB2aXN1YWwgPSB2aXN1YWxMaW5lKGxpbmUpO1xcbiAgICBpZiAodmlzdWFsICE9IGxpbmUpIGxpbmVOID0gbGluZU5vKHZpc3VhbCk7XFxuICAgIHZhciBvcmRlciA9IGdldE9yZGVyKHZpc3VhbCk7XFxuICAgIHZhciBjaCA9ICFvcmRlciA/IDAgOiBvcmRlclswXS5sZXZlbCAlIDIgPyBsaW5lUmlnaHQodmlzdWFsKSA6IGxpbmVMZWZ0KHZpc3VhbCk7XFxuICAgIHJldHVybiBQb3MobGluZU4sIGNoKTtcXG4gIH1cXG4gIGZ1bmN0aW9uIGxpbmVFbmQoY20sIGxpbmVOKSB7XFxuICAgIHZhciBtZXJnZWQsIGxpbmUgPSBnZXRMaW5lKGNtLmRvYywgbGluZU4pO1xcbiAgICB3aGlsZSAobWVyZ2VkID0gY29sbGFwc2VkU3BhbkF0RW5kKGxpbmUpKSB7XFxuICAgICAgbGluZSA9IG1lcmdlZC5maW5kKDEsIHRydWUpLmxpbmU7XFxuICAgICAgbGluZU4gPSBudWxsO1xcbiAgICB9XFxuICAgIHZhciBvcmRlciA9IGdldE9yZGVyKGxpbmUpO1xcbiAgICB2YXIgY2ggPSAhb3JkZXIgPyBsaW5lLnRleHQubGVuZ3RoIDogb3JkZXJbMF0ubGV2ZWwgJSAyID8gbGluZUxlZnQobGluZSkgOiBsaW5lUmlnaHQobGluZSk7XFxuICAgIHJldHVybiBQb3MobGluZU4gPT0gbnVsbCA/IGxpbmVObyhsaW5lKSA6IGxpbmVOLCBjaCk7XFxuICB9XFxuICBmdW5jdGlvbiBsaW5lU3RhcnRTbWFydChjbSwgcG9zKSB7XFxuICAgIHZhciBzdGFydCA9IGxpbmVTdGFydChjbSwgcG9zLmxpbmUpO1xcbiAgICB2YXIgbGluZSA9IGdldExpbmUoY20uZG9jLCBzdGFydC5saW5lKTtcXG4gICAgdmFyIG9yZGVyID0gZ2V0T3JkZXIobGluZSk7XFxuICAgIGlmICghb3JkZXIgfHwgb3JkZXJbMF0ubGV2ZWwgPT0gMCkge1xcbiAgICAgIHZhciBmaXJzdE5vbldTID0gTWF0aC5tYXgoMCwgbGluZS50ZXh0LnNlYXJjaCgvXFxcXFMvKSk7XFxuICAgICAgdmFyIGluV1MgPSBwb3MubGluZSA9PSBzdGFydC5saW5lICYmIHBvcy5jaCA8PSBmaXJzdE5vbldTICYmIHBvcy5jaDtcXG4gICAgICByZXR1cm4gUG9zKHN0YXJ0LmxpbmUsIGluV1MgPyAwIDogZmlyc3ROb25XUyk7XFxuICAgIH1cXG4gICAgcmV0dXJuIHN0YXJ0O1xcbiAgfVxcblxcbiAgZnVuY3Rpb24gY29tcGFyZUJpZGlMZXZlbChvcmRlciwgYSwgYikge1xcbiAgICB2YXIgbGluZWRpciA9IG9yZGVyWzBdLmxldmVsO1xcbiAgICBpZiAoYSA9PSBsaW5lZGlyKSByZXR1cm4gdHJ1ZTtcXG4gICAgaWYgKGIgPT0gbGluZWRpcikgcmV0dXJuIGZhbHNlO1xcbiAgICByZXR1cm4gYSA8IGI7XFxuICB9XFxuICB2YXIgYmlkaU90aGVyO1xcbiAgZnVuY3Rpb24gZ2V0QmlkaVBhcnRBdChvcmRlciwgcG9zKSB7XFxuICAgIGJpZGlPdGhlciA9IG51bGw7XFxuICAgIGZvciAodmFyIGkgPSAwLCBmb3VuZDsgaSA8IG9yZGVyLmxlbmd0aDsgKytpKSB7XFxuICAgICAgdmFyIGN1ciA9IG9yZGVyW2ldO1xcbiAgICAgIGlmIChjdXIuZnJvbSA8IHBvcyAmJiBjdXIudG8gPiBwb3MpIHJldHVybiBpO1xcbiAgICAgIGlmICgoY3VyLmZyb20gPT0gcG9zIHx8IGN1ci50byA9PSBwb3MpKSB7XFxuICAgICAgICBpZiAoZm91bmQgPT0gbnVsbCkge1xcbiAgICAgICAgICBmb3VuZCA9IGk7XFxuICAgICAgICB9IGVsc2UgaWYgKGNvbXBhcmVCaWRpTGV2ZWwob3JkZXIsIGN1ci5sZXZlbCwgb3JkZXJbZm91bmRdLmxldmVsKSkge1xcbiAgICAgICAgICBpZiAoY3VyLmZyb20gIT0gY3VyLnRvKSBiaWRpT3RoZXIgPSBmb3VuZDtcXG4gICAgICAgICAgcmV0dXJuIGk7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICBpZiAoY3VyLmZyb20gIT0gY3VyLnRvKSBiaWRpT3RoZXIgPSBpO1xcbiAgICAgICAgICByZXR1cm4gZm91bmQ7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICB9XFxuICAgIHJldHVybiBmb3VuZDtcXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIG1vdmVJbkxpbmUobGluZSwgcG9zLCBkaXIsIGJ5VW5pdCkge1xcbiAgICBpZiAoIWJ5VW5pdCkgcmV0dXJuIHBvcyArIGRpcjtcXG4gICAgZG8gcG9zICs9IGRpcjtcXG4gICAgd2hpbGUgKHBvcyA+IDAgJiYgaXNFeHRlbmRpbmdDaGFyKGxpbmUudGV4dC5jaGFyQXQocG9zKSkpO1xcbiAgICByZXR1cm4gcG9zO1xcbiAgfVxcblxcbiAgLy8gVGhpcyBpcyBuZWVkZWQgaW4gb3JkZXIgdG8gbW92ZSAndmlzdWFsbHknIHRocm91Z2ggYmktZGlyZWN0aW9uYWxcXG4gIC8vIHRleHQgLS0gaS5lLiwgcHJlc3NpbmcgbGVmdCBzaG91bGQgbWFrZSB0aGUgY3Vyc29yIGdvIGxlZnQsIGV2ZW5cXG4gIC8vIHdoZW4gaW4gUlRMIHRleHQuIFRoZSB0cmlja3kgcGFydCBpcyB0aGUgJ2p1bXBzJywgd2hlcmUgUlRMIGFuZFxcbiAgLy8gTFRSIHRleHQgdG91Y2ggZWFjaCBvdGhlci4gVGhpcyBvZnRlbiByZXF1aXJlcyB0aGUgY3Vyc29yIG9mZnNldFxcbiAgLy8gdG8gbW92ZSBtb3JlIHRoYW4gb25lIHVuaXQsIGluIG9yZGVyIHRvIHZpc3VhbGx5IG1vdmUgb25lIHVuaXQuXFxuICBmdW5jdGlvbiBtb3ZlVmlzdWFsbHkobGluZSwgc3RhcnQsIGRpciwgYnlVbml0KSB7XFxuICAgIHZhciBiaWRpID0gZ2V0T3JkZXIobGluZSk7XFxuICAgIGlmICghYmlkaSkgcmV0dXJuIG1vdmVMb2dpY2FsbHkobGluZSwgc3RhcnQsIGRpciwgYnlVbml0KTtcXG4gICAgdmFyIHBvcyA9IGdldEJpZGlQYXJ0QXQoYmlkaSwgc3RhcnQpLCBwYXJ0ID0gYmlkaVtwb3NdO1xcbiAgICB2YXIgdGFyZ2V0ID0gbW92ZUluTGluZShsaW5lLCBzdGFydCwgcGFydC5sZXZlbCAlIDIgPyAtZGlyIDogZGlyLCBieVVuaXQpO1xcblxcbiAgICBmb3IgKDs7KSB7XFxuICAgICAgaWYgKHRhcmdldCA+IHBhcnQuZnJvbSAmJiB0YXJnZXQgPCBwYXJ0LnRvKSByZXR1cm4gdGFyZ2V0O1xcbiAgICAgIGlmICh0YXJnZXQgPT0gcGFydC5mcm9tIHx8IHRhcmdldCA9PSBwYXJ0LnRvKSB7XFxuICAgICAgICBpZiAoZ2V0QmlkaVBhcnRBdChiaWRpLCB0YXJnZXQpID09IHBvcykgcmV0dXJuIHRhcmdldDtcXG4gICAgICAgIHBhcnQgPSBiaWRpW3BvcyArPSBkaXJdO1xcbiAgICAgICAgcmV0dXJuIChkaXIgPiAwKSA9PSBwYXJ0LmxldmVsICUgMiA/IHBhcnQudG8gOiBwYXJ0LmZyb207XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIHBhcnQgPSBiaWRpW3BvcyArPSBkaXJdO1xcbiAgICAgICAgaWYgKCFwYXJ0KSByZXR1cm4gbnVsbDtcXG4gICAgICAgIGlmICgoZGlyID4gMCkgPT0gcGFydC5sZXZlbCAlIDIpXFxuICAgICAgICAgIHRhcmdldCA9IG1vdmVJbkxpbmUobGluZSwgcGFydC50bywgLTEsIGJ5VW5pdCk7XFxuICAgICAgICBlbHNlXFxuICAgICAgICAgIHRhcmdldCA9IG1vdmVJbkxpbmUobGluZSwgcGFydC5mcm9tLCAxLCBieVVuaXQpO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgfVxcblxcbiAgZnVuY3Rpb24gbW92ZUxvZ2ljYWxseShsaW5lLCBzdGFydCwgZGlyLCBieVVuaXQpIHtcXG4gICAgdmFyIHRhcmdldCA9IHN0YXJ0ICsgZGlyO1xcbiAgICBpZiAoYnlVbml0KSB3aGlsZSAodGFyZ2V0ID4gMCAmJiBpc0V4dGVuZGluZ0NoYXIobGluZS50ZXh0LmNoYXJBdCh0YXJnZXQpKSkgdGFyZ2V0ICs9IGRpcjtcXG4gICAgcmV0dXJuIHRhcmdldCA8IDAgfHwgdGFyZ2V0ID4gbGluZS50ZXh0Lmxlbmd0aCA/IG51bGwgOiB0YXJnZXQ7XFxuICB9XFxuXFxuICAvLyBCaWRpcmVjdGlvbmFsIG9yZGVyaW5nIGFsZ29yaXRobVxcbiAgLy8gU2VlIGh0dHA6Ly91bmljb2RlLm9yZy9yZXBvcnRzL3RyOS90cjktMTMuaHRtbCBmb3IgdGhlIGFsZ29yaXRobVxcbiAgLy8gdGhhdCB0aGlzIChwYXJ0aWFsbHkpIGltcGxlbWVudHMuXFxuXFxuICAvLyBPbmUtY2hhciBjb2RlcyB1c2VkIGZvciBjaGFyYWN0ZXIgdHlwZXM6XFxuICAvLyBMIChMKTogICBMZWZ0LXRvLVJpZ2h0XFxuICAvLyBSIChSKTogICBSaWdodC10by1MZWZ0XFxuICAvLyByIChBTCk6ICBSaWdodC10by1MZWZ0IEFyYWJpY1xcbiAgLy8gMSAoRU4pOiAgRXVyb3BlYW4gTnVtYmVyXFxuICAvLyArIChFUyk6ICBFdXJvcGVhbiBOdW1iZXIgU2VwYXJhdG9yXFxuICAvLyAlIChFVCk6ICBFdXJvcGVhbiBOdW1iZXIgVGVybWluYXRvclxcbiAgLy8gbiAoQU4pOiAgQXJhYmljIE51bWJlclxcbiAgLy8gLCAoQ1MpOiAgQ29tbW9uIE51bWJlciBTZXBhcmF0b3JcXG4gIC8vIG0gKE5TTSk6IE5vbi1TcGFjaW5nIE1hcmtcXG4gIC8vIGIgKEJOKTogIEJvdW5kYXJ5IE5ldXRyYWxcXG4gIC8vIHMgKEIpOiAgIFBhcmFncmFwaCBTZXBhcmF0b3JcXG4gIC8vIHQgKFMpOiAgIFNlZ21lbnQgU2VwYXJhdG9yXFxuICAvLyB3IChXUyk6ICBXaGl0ZXNwYWNlXFxuICAvLyBOIChPTik6ICBPdGhlciBOZXV0cmFsc1xcblxcbiAgLy8gUmV0dXJucyBudWxsIGlmIGNoYXJhY3RlcnMgYXJlIG9yZGVyZWQgYXMgdGhleSBhcHBlYXJcXG4gIC8vIChsZWZ0LXRvLXJpZ2h0KSwgb3IgYW4gYXJyYXkgb2Ygc2VjdGlvbnMgKHtmcm9tLCB0bywgbGV2ZWx9XFxuICAvLyBvYmplY3RzKSBpbiB0aGUgb3JkZXIgaW4gd2hpY2ggdGhleSBvY2N1ciB2aXN1YWxseS5cXG4gIHZhciBiaWRpT3JkZXJpbmcgPSAoZnVuY3Rpb24oKSB7XFxuICAgIC8vIENoYXJhY3RlciB0eXBlcyBmb3IgY29kZXBvaW50cyAwIHRvIDB4ZmZcXG4gICAgdmFyIGxvd1R5cGVzID0gXFxcImJiYmJiYmJiYnRzdHdzYmJiYmJiYmJiYmJiYmJzc3N0d05OJSUlTk5OTk5OLE4sTjExMTExMTExMTFOTk5OTk5OTExMTExMTExMTExMTExMTExMTExMTExMTExOTk5OTk5MTExMTExMTExMTExMTExMTExMTExMTExMTE5OTk5iYmJiYmJzYmJiYmJiYmJiYmJiYmJiYmJiYmJiYmJiYmIsTiUlJSVOTk5OTE5OTk5OJSUxMU5MTk5OMUxOTk5OTkxMTExMTExMTExMTExMTExMTExMTExMTkxMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExOXFxcIjtcXG4gICAgLy8gQ2hhcmFjdGVyIHR5cGVzIGZvciBjb2RlcG9pbnRzIDB4NjAwIHRvIDB4NmZmXFxuICAgIHZhciBhcmFiaWNUeXBlcyA9IFxcXCJycnJycnJycnJycnIsck5ObW1tbW1tcnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJtbW1tbW1tbW1tbW1tbXJycnJycnJubm5ubm5ubm5uJW5ucnJybXJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJybW1tbW1tbW1tbW1tbW1tbW1tbU5tbW1tXFxcIjtcXG4gICAgZnVuY3Rpb24gY2hhclR5cGUoY29kZSkge1xcbiAgICAgIGlmIChjb2RlIDw9IDB4ZjcpIHJldHVybiBsb3dUeXBlcy5jaGFyQXQoY29kZSk7XFxuICAgICAgZWxzZSBpZiAoMHg1OTAgPD0gY29kZSAmJiBjb2RlIDw9IDB4NWY0KSByZXR1cm4gXFxcIlJcXFwiO1xcbiAgICAgIGVsc2UgaWYgKDB4NjAwIDw9IGNvZGUgJiYgY29kZSA8PSAweDZlZCkgcmV0dXJuIGFyYWJpY1R5cGVzLmNoYXJBdChjb2RlIC0gMHg2MDApO1xcbiAgICAgIGVsc2UgaWYgKDB4NmVlIDw9IGNvZGUgJiYgY29kZSA8PSAweDhhYykgcmV0dXJuIFxcXCJyXFxcIjtcXG4gICAgICBlbHNlIGlmICgweDIwMDAgPD0gY29kZSAmJiBjb2RlIDw9IDB4MjAwYikgcmV0dXJuIFxcXCJ3XFxcIjtcXG4gICAgICBlbHNlIGlmIChjb2RlID09IDB4MjAwYykgcmV0dXJuIFxcXCJiXFxcIjtcXG4gICAgICBlbHNlIHJldHVybiBcXFwiTFxcXCI7XFxuICAgIH1cXG5cXG4gICAgdmFyIGJpZGlSRSA9IC9bXFxcXHUwNTkwLVxcXFx1MDVmNFxcXFx1MDYwMC1cXFxcdTA2ZmZcXFxcdTA3MDAtXFxcXHUwOGFjXS87XFxuICAgIHZhciBpc05ldXRyYWwgPSAvW3N0d05dLywgaXNTdHJvbmcgPSAvW0xScl0vLCBjb3VudHNBc0xlZnQgPSAvW0xiMW5dLywgY291bnRzQXNOdW0gPSAvWzFuXS87XFxuICAgIC8vIEJyb3dzZXJzIHNlZW0gdG8gYWx3YXlzIHRyZWF0IHRoZSBib3VuZGFyaWVzIG9mIGJsb2NrIGVsZW1lbnRzIGFzIGJlaW5nIEwuXFxuICAgIHZhciBvdXRlclR5cGUgPSBcXFwiTFxcXCI7XFxuXFxuICAgIGZ1bmN0aW9uIEJpZGlTcGFuKGxldmVsLCBmcm9tLCB0bykge1xcbiAgICAgIHRoaXMubGV2ZWwgPSBsZXZlbDtcXG4gICAgICB0aGlzLmZyb20gPSBmcm9tOyB0aGlzLnRvID0gdG87XFxuICAgIH1cXG5cXG4gICAgcmV0dXJuIGZ1bmN0aW9uKHN0cikge1xcbiAgICAgIGlmICghYmlkaVJFLnRlc3Qoc3RyKSkgcmV0dXJuIGZhbHNlO1xcbiAgICAgIHZhciBsZW4gPSBzdHIubGVuZ3RoLCB0eXBlcyA9IFtdO1xcbiAgICAgIGZvciAodmFyIGkgPSAwLCB0eXBlOyBpIDwgbGVuOyArK2kpXFxuICAgICAgICB0eXBlcy5wdXNoKHR5cGUgPSBjaGFyVHlwZShzdHIuY2hhckNvZGVBdChpKSkpO1xcblxcbiAgICAgIC8vIFcxLiBFeGFtaW5lIGVhY2ggbm9uLXNwYWNpbmcgbWFyayAoTlNNKSBpbiB0aGUgbGV2ZWwgcnVuLCBhbmRcXG4gICAgICAvLyBjaGFuZ2UgdGhlIHR5cGUgb2YgdGhlIE5TTSB0byB0aGUgdHlwZSBvZiB0aGUgcHJldmlvdXNcXG4gICAgICAvLyBjaGFyYWN0ZXIuIElmIHRoZSBOU00gaXMgYXQgdGhlIHN0YXJ0IG9mIHRoZSBsZXZlbCBydW4sIGl0IHdpbGxcXG4gICAgICAvLyBnZXQgdGhlIHR5cGUgb2Ygc29yLlxcbiAgICAgIGZvciAodmFyIGkgPSAwLCBwcmV2ID0gb3V0ZXJUeXBlOyBpIDwgbGVuOyArK2kpIHtcXG4gICAgICAgIHZhciB0eXBlID0gdHlwZXNbaV07XFxuICAgICAgICBpZiAodHlwZSA9PSBcXFwibVxcXCIpIHR5cGVzW2ldID0gcHJldjtcXG4gICAgICAgIGVsc2UgcHJldiA9IHR5cGU7XFxuICAgICAgfVxcblxcbiAgICAgIC8vIFcyLiBTZWFyY2ggYmFja3dhcmRzIGZyb20gZWFjaCBpbnN0YW5jZSBvZiBhIEV1cm9wZWFuIG51bWJlclxcbiAgICAgIC8vIHVudGlsIHRoZSBmaXJzdCBzdHJvbmcgdHlwZSAoUiwgTCwgQUwsIG9yIHNvcikgaXMgZm91bmQuIElmIGFuXFxuICAgICAgLy8gQUwgaXMgZm91bmQsIGNoYW5nZSB0aGUgdHlwZSBvZiB0aGUgRXVyb3BlYW4gbnVtYmVyIHRvIEFyYWJpY1xcbiAgICAgIC8vIG51bWJlci5cXG4gICAgICAvLyBXMy4gQ2hhbmdlIGFsbCBBTHMgdG8gUi5cXG4gICAgICBmb3IgKHZhciBpID0gMCwgY3VyID0gb3V0ZXJUeXBlOyBpIDwgbGVuOyArK2kpIHtcXG4gICAgICAgIHZhciB0eXBlID0gdHlwZXNbaV07XFxuICAgICAgICBpZiAodHlwZSA9PSBcXFwiMVxcXCIgJiYgY3VyID09IFxcXCJyXFxcIikgdHlwZXNbaV0gPSBcXFwiblxcXCI7XFxuICAgICAgICBlbHNlIGlmIChpc1N0cm9uZy50ZXN0KHR5cGUpKSB7IGN1ciA9IHR5cGU7IGlmICh0eXBlID09IFxcXCJyXFxcIikgdHlwZXNbaV0gPSBcXFwiUlxcXCI7IH1cXG4gICAgICB9XFxuXFxuICAgICAgLy8gVzQuIEEgc2luZ2xlIEV1cm9wZWFuIHNlcGFyYXRvciBiZXR3ZWVuIHR3byBFdXJvcGVhbiBudW1iZXJzXFxuICAgICAgLy8gY2hhbmdlcyB0byBhIEV1cm9wZWFuIG51bWJlci4gQSBzaW5nbGUgY29tbW9uIHNlcGFyYXRvciBiZXR3ZWVuXFxuICAgICAgLy8gdHdvIG51bWJlcnMgb2YgdGhlIHNhbWUgdHlwZSBjaGFuZ2VzIHRvIHRoYXQgdHlwZS5cXG4gICAgICBmb3IgKHZhciBpID0gMSwgcHJldiA9IHR5cGVzWzBdOyBpIDwgbGVuIC0gMTsgKytpKSB7XFxuICAgICAgICB2YXIgdHlwZSA9IHR5cGVzW2ldO1xcbiAgICAgICAgaWYgKHR5cGUgPT0gXFxcIitcXFwiICYmIHByZXYgPT0gXFxcIjFcXFwiICYmIHR5cGVzW2krMV0gPT0gXFxcIjFcXFwiKSB0eXBlc1tpXSA9IFxcXCIxXFxcIjtcXG4gICAgICAgIGVsc2UgaWYgKHR5cGUgPT0gXFxcIixcXFwiICYmIHByZXYgPT0gdHlwZXNbaSsxXSAmJlxcbiAgICAgICAgICAgICAgICAgKHByZXYgPT0gXFxcIjFcXFwiIHx8IHByZXYgPT0gXFxcIm5cXFwiKSkgdHlwZXNbaV0gPSBwcmV2O1xcbiAgICAgICAgcHJldiA9IHR5cGU7XFxuICAgICAgfVxcblxcbiAgICAgIC8vIFc1LiBBIHNlcXVlbmNlIG9mIEV1cm9wZWFuIHRlcm1pbmF0b3JzIGFkamFjZW50IHRvIEV1cm9wZWFuXFxuICAgICAgLy8gbnVtYmVycyBjaGFuZ2VzIHRvIGFsbCBFdXJvcGVhbiBudW1iZXJzLlxcbiAgICAgIC8vIFc2LiBPdGhlcndpc2UsIHNlcGFyYXRvcnMgYW5kIHRlcm1pbmF0b3JzIGNoYW5nZSB0byBPdGhlclxcbiAgICAgIC8vIE5ldXRyYWwuXFxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xcbiAgICAgICAgdmFyIHR5cGUgPSB0eXBlc1tpXTtcXG4gICAgICAgIGlmICh0eXBlID09IFxcXCIsXFxcIikgdHlwZXNbaV0gPSBcXFwiTlxcXCI7XFxuICAgICAgICBlbHNlIGlmICh0eXBlID09IFxcXCIlXFxcIikge1xcbiAgICAgICAgICBmb3IgKHZhciBlbmQgPSBpICsgMTsgZW5kIDwgbGVuICYmIHR5cGVzW2VuZF0gPT0gXFxcIiVcXFwiOyArK2VuZCkge31cXG4gICAgICAgICAgdmFyIHJlcGxhY2UgPSAoaSAmJiB0eXBlc1tpLTFdID09IFxcXCIhXFxcIikgfHwgKGVuZCA8IGxlbiAmJiB0eXBlc1tlbmRdID09IFxcXCIxXFxcIikgPyBcXFwiMVxcXCIgOiBcXFwiTlxcXCI7XFxuICAgICAgICAgIGZvciAodmFyIGogPSBpOyBqIDwgZW5kOyArK2opIHR5cGVzW2pdID0gcmVwbGFjZTtcXG4gICAgICAgICAgaSA9IGVuZCAtIDE7XFxuICAgICAgICB9XFxuICAgICAgfVxcblxcbiAgICAgIC8vIFc3LiBTZWFyY2ggYmFja3dhcmRzIGZyb20gZWFjaCBpbnN0YW5jZSBvZiBhIEV1cm9wZWFuIG51bWJlclxcbiAgICAgIC8vIHVudGlsIHRoZSBmaXJzdCBzdHJvbmcgdHlwZSAoUiwgTCwgb3Igc29yKSBpcyBmb3VuZC4gSWYgYW4gTCBpc1xcbiAgICAgIC8vIGZvdW5kLCB0aGVuIGNoYW5nZSB0aGUgdHlwZSBvZiB0aGUgRXVyb3BlYW4gbnVtYmVyIHRvIEwuXFxuICAgICAgZm9yICh2YXIgaSA9IDAsIGN1ciA9IG91dGVyVHlwZTsgaSA8IGxlbjsgKytpKSB7XFxuICAgICAgICB2YXIgdHlwZSA9IHR5cGVzW2ldO1xcbiAgICAgICAgaWYgKGN1ciA9PSBcXFwiTFxcXCIgJiYgdHlwZSA9PSBcXFwiMVxcXCIpIHR5cGVzW2ldID0gXFxcIkxcXFwiO1xcbiAgICAgICAgZWxzZSBpZiAoaXNTdHJvbmcudGVzdCh0eXBlKSkgY3VyID0gdHlwZTtcXG4gICAgICB9XFxuXFxuICAgICAgLy8gTjEuIEEgc2VxdWVuY2Ugb2YgbmV1dHJhbHMgdGFrZXMgdGhlIGRpcmVjdGlvbiBvZiB0aGVcXG4gICAgICAvLyBzdXJyb3VuZGluZyBzdHJvbmcgdGV4dCBpZiB0aGUgdGV4dCBvbiBib3RoIHNpZGVzIGhhcyB0aGUgc2FtZVxcbiAgICAgIC8vIGRpcmVjdGlvbi4gRXVyb3BlYW4gYW5kIEFyYWJpYyBudW1iZXJzIGFjdCBhcyBpZiB0aGV5IHdlcmUgUiBpblxcbiAgICAgIC8vIHRlcm1zIG9mIHRoZWlyIGluZmx1ZW5jZSBvbiBuZXV0cmFscy4gU3RhcnQtb2YtbGV2ZWwtcnVuIChzb3IpXFxuICAgICAgLy8gYW5kIGVuZC1vZi1sZXZlbC1ydW4gKGVvcikgYXJlIHVzZWQgYXQgbGV2ZWwgcnVuIGJvdW5kYXJpZXMuXFxuICAgICAgLy8gTjIuIEFueSByZW1haW5pbmcgbmV1dHJhbHMgdGFrZSB0aGUgZW1iZWRkaW5nIGRpcmVjdGlvbi5cXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XFxuICAgICAgICBpZiAoaXNOZXV0cmFsLnRlc3QodHlwZXNbaV0pKSB7XFxuICAgICAgICAgIGZvciAodmFyIGVuZCA9IGkgKyAxOyBlbmQgPCBsZW4gJiYgaXNOZXV0cmFsLnRlc3QodHlwZXNbZW5kXSk7ICsrZW5kKSB7fVxcbiAgICAgICAgICB2YXIgYmVmb3JlID0gKGkgPyB0eXBlc1tpLTFdIDogb3V0ZXJUeXBlKSA9PSBcXFwiTFxcXCI7XFxuICAgICAgICAgIHZhciBhZnRlciA9IChlbmQgPCBsZW4gPyB0eXBlc1tlbmRdIDogb3V0ZXJUeXBlKSA9PSBcXFwiTFxcXCI7XFxuICAgICAgICAgIHZhciByZXBsYWNlID0gYmVmb3JlIHx8IGFmdGVyID8gXFxcIkxcXFwiIDogXFxcIlJcXFwiO1xcbiAgICAgICAgICBmb3IgKHZhciBqID0gaTsgaiA8IGVuZDsgKytqKSB0eXBlc1tqXSA9IHJlcGxhY2U7XFxuICAgICAgICAgIGkgPSBlbmQgLSAxO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG5cXG4gICAgICAvLyBIZXJlIHdlIGRlcGFydCBmcm9tIHRoZSBkb2N1bWVudGVkIGFsZ29yaXRobSwgaW4gb3JkZXIgdG8gYXZvaWRcXG4gICAgICAvLyBidWlsZGluZyB1cCBhbiBhY3R1YWwgbGV2ZWxzIGFycmF5LiBTaW5jZSB0aGVyZSBhcmUgb25seSB0aHJlZVxcbiAgICAgIC8vIGxldmVscyAoMCwgMSwgMikgaW4gYW4gaW1wbGVtZW50YXRpb24gdGhhdCBkb2Vzbid0IHRha2VcXG4gICAgICAvLyBleHBsaWNpdCBlbWJlZGRpbmcgaW50byBhY2NvdW50LCB3ZSBjYW4gYnVpbGQgdXAgdGhlIG9yZGVyIG9uXFxuICAgICAgLy8gdGhlIGZseSwgd2l0aG91dCBmb2xsb3dpbmcgdGhlIGxldmVsLWJhc2VkIGFsZ29yaXRobS5cXG4gICAgICB2YXIgb3JkZXIgPSBbXSwgbTtcXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjspIHtcXG4gICAgICAgIGlmIChjb3VudHNBc0xlZnQudGVzdCh0eXBlc1tpXSkpIHtcXG4gICAgICAgICAgdmFyIHN0YXJ0ID0gaTtcXG4gICAgICAgICAgZm9yICgrK2k7IGkgPCBsZW4gJiYgY291bnRzQXNMZWZ0LnRlc3QodHlwZXNbaV0pOyArK2kpIHt9XFxuICAgICAgICAgIG9yZGVyLnB1c2gobmV3IEJpZGlTcGFuKDAsIHN0YXJ0LCBpKSk7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICB2YXIgcG9zID0gaSwgYXQgPSBvcmRlci5sZW5ndGg7XFxuICAgICAgICAgIGZvciAoKytpOyBpIDwgbGVuICYmIHR5cGVzW2ldICE9IFxcXCJMXFxcIjsgKytpKSB7fVxcbiAgICAgICAgICBmb3IgKHZhciBqID0gcG9zOyBqIDwgaTspIHtcXG4gICAgICAgICAgICBpZiAoY291bnRzQXNOdW0udGVzdCh0eXBlc1tqXSkpIHtcXG4gICAgICAgICAgICAgIGlmIChwb3MgPCBqKSBvcmRlci5zcGxpY2UoYXQsIDAsIG5ldyBCaWRpU3BhbigxLCBwb3MsIGopKTtcXG4gICAgICAgICAgICAgIHZhciBuc3RhcnQgPSBqO1xcbiAgICAgICAgICAgICAgZm9yICgrK2o7IGogPCBpICYmIGNvdW50c0FzTnVtLnRlc3QodHlwZXNbal0pOyArK2opIHt9XFxuICAgICAgICAgICAgICBvcmRlci5zcGxpY2UoYXQsIDAsIG5ldyBCaWRpU3BhbigyLCBuc3RhcnQsIGopKTtcXG4gICAgICAgICAgICAgIHBvcyA9IGo7XFxuICAgICAgICAgICAgfSBlbHNlICsrajtcXG4gICAgICAgICAgfVxcbiAgICAgICAgICBpZiAocG9zIDwgaSkgb3JkZXIuc3BsaWNlKGF0LCAwLCBuZXcgQmlkaVNwYW4oMSwgcG9zLCBpKSk7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICAgIGlmIChvcmRlclswXS5sZXZlbCA9PSAxICYmIChtID0gc3RyLm1hdGNoKC9eXFxcXHMrLykpKSB7XFxuICAgICAgICBvcmRlclswXS5mcm9tID0gbVswXS5sZW5ndGg7XFxuICAgICAgICBvcmRlci51bnNoaWZ0KG5ldyBCaWRpU3BhbigwLCAwLCBtWzBdLmxlbmd0aCkpO1xcbiAgICAgIH1cXG4gICAgICBpZiAobHN0KG9yZGVyKS5sZXZlbCA9PSAxICYmIChtID0gc3RyLm1hdGNoKC9cXFxccyskLykpKSB7XFxuICAgICAgICBsc3Qob3JkZXIpLnRvIC09IG1bMF0ubGVuZ3RoO1xcbiAgICAgICAgb3JkZXIucHVzaChuZXcgQmlkaVNwYW4oMCwgbGVuIC0gbVswXS5sZW5ndGgsIGxlbikpO1xcbiAgICAgIH1cXG4gICAgICBpZiAob3JkZXJbMF0ubGV2ZWwgPT0gMilcXG4gICAgICAgIG9yZGVyLnVuc2hpZnQobmV3IEJpZGlTcGFuKDEsIG9yZGVyWzBdLnRvLCBvcmRlclswXS50bykpO1xcbiAgICAgIGlmIChvcmRlclswXS5sZXZlbCAhPSBsc3Qob3JkZXIpLmxldmVsKVxcbiAgICAgICAgb3JkZXIucHVzaChuZXcgQmlkaVNwYW4ob3JkZXJbMF0ubGV2ZWwsIGxlbiwgbGVuKSk7XFxuXFxuICAgICAgcmV0dXJuIG9yZGVyO1xcbiAgICB9O1xcbiAgfSkoKTtcXG5cXG4gIC8vIFRIRSBFTkRcXG5cXG4gIENvZGVNaXJyb3IudmVyc2lvbiA9IFxcXCI1LjE5LjBcXFwiO1xcblxcbiAgcmV0dXJuIENvZGVNaXJyb3I7XFxufSk7XFxuXCJcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yYXctbG9hZGVyIS4vfi9jb2RlbWlycm9yL2xpYi9jb2RlbWlycm9yLmpzXG4gKiogbW9kdWxlIGlkID0gNVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIl0sIm1hcHBpbmdzIjoiQUFBQSIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	eval("__webpack_require__(2)(__webpack_require__(7))//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL34vY29kZW1pcnJvci9tb2RlL3htbC94bWwuanM/ODBhNyJdLCJzb3VyY2VzQ29udGVudCI6WyJyZXF1aXJlKFwiISEvdmFyL2FwcC93ZWIvanMvbm9kZV9tb2R1bGVzL3NjcmlwdC1sb2FkZXIvYWRkU2NyaXB0LmpzXCIpKHJlcXVpcmUoXCIhIS92YXIvYXBwL3dlYi9qcy9ub2RlX21vZHVsZXMvcmF3LWxvYWRlci9pbmRleC5qcyEvdmFyL2FwcC93ZWIvanMvbm9kZV9tb2R1bGVzL2NvZGVtaXJyb3IvbW9kZS94bWwveG1sLmpzXCIpKVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3NjcmlwdC1sb2FkZXIhLi9+L2NvZGVtaXJyb3IvbW9kZS94bWwveG1sLmpzXG4gKiogbW9kdWxlIGlkID0gNlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIl0sIm1hcHBpbmdzIjoiQUFBQSIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 7 */
/***/ function(module, exports) {

	eval("module.exports = \"// CodeMirror, copyright (c) by Marijn Haverbeke and others\\n// Distributed under an MIT license: http://codemirror.net/LICENSE\\n\\n(function(mod) {\\n  if (typeof exports == \\\"object\\\" && typeof module == \\\"object\\\") // CommonJS\\n    mod(require(\\\"../../lib/codemirror\\\"));\\n  else if (typeof define == \\\"function\\\" && define.amd) // AMD\\n    define([\\\"../../lib/codemirror\\\"], mod);\\n  else // Plain browser env\\n    mod(CodeMirror);\\n})(function(CodeMirror) {\\n\\\"use strict\\\";\\n\\nvar htmlConfig = {\\n  autoSelfClosers: {'area': true, 'base': true, 'br': true, 'col': true, 'command': true,\\n                    'embed': true, 'frame': true, 'hr': true, 'img': true, 'input': true,\\n                    'keygen': true, 'link': true, 'meta': true, 'param': true, 'source': true,\\n                    'track': true, 'wbr': true, 'menuitem': true},\\n  implicitlyClosed: {'dd': true, 'li': true, 'optgroup': true, 'option': true, 'p': true,\\n                     'rp': true, 'rt': true, 'tbody': true, 'td': true, 'tfoot': true,\\n                     'th': true, 'tr': true},\\n  contextGrabbers: {\\n    'dd': {'dd': true, 'dt': true},\\n    'dt': {'dd': true, 'dt': true},\\n    'li': {'li': true},\\n    'option': {'option': true, 'optgroup': true},\\n    'optgroup': {'optgroup': true},\\n    'p': {'address': true, 'article': true, 'aside': true, 'blockquote': true, 'dir': true,\\n          'div': true, 'dl': true, 'fieldset': true, 'footer': true, 'form': true,\\n          'h1': true, 'h2': true, 'h3': true, 'h4': true, 'h5': true, 'h6': true,\\n          'header': true, 'hgroup': true, 'hr': true, 'menu': true, 'nav': true, 'ol': true,\\n          'p': true, 'pre': true, 'section': true, 'table': true, 'ul': true},\\n    'rp': {'rp': true, 'rt': true},\\n    'rt': {'rp': true, 'rt': true},\\n    'tbody': {'tbody': true, 'tfoot': true},\\n    'td': {'td': true, 'th': true},\\n    'tfoot': {'tbody': true},\\n    'th': {'td': true, 'th': true},\\n    'thead': {'tbody': true, 'tfoot': true},\\n    'tr': {'tr': true}\\n  },\\n  doNotIndent: {\\\"pre\\\": true},\\n  allowUnquoted: true,\\n  allowMissing: true,\\n  caseFold: true\\n}\\n\\nvar xmlConfig = {\\n  autoSelfClosers: {},\\n  implicitlyClosed: {},\\n  contextGrabbers: {},\\n  doNotIndent: {},\\n  allowUnquoted: false,\\n  allowMissing: false,\\n  caseFold: false\\n}\\n\\nCodeMirror.defineMode(\\\"xml\\\", function(editorConf, config_) {\\n  var indentUnit = editorConf.indentUnit\\n  var config = {}\\n  var defaults = config_.htmlMode ? htmlConfig : xmlConfig\\n  for (var prop in defaults) config[prop] = defaults[prop]\\n  for (var prop in config_) config[prop] = config_[prop]\\n\\n  // Return variables for tokenizers\\n  var type, setStyle;\\n\\n  function inText(stream, state) {\\n    function chain(parser) {\\n      state.tokenize = parser;\\n      return parser(stream, state);\\n    }\\n\\n    var ch = stream.next();\\n    if (ch == \\\"<\\\") {\\n      if (stream.eat(\\\"!\\\")) {\\n        if (stream.eat(\\\"[\\\")) {\\n          if (stream.match(\\\"CDATA[\\\")) return chain(inBlock(\\\"atom\\\", \\\"]]>\\\"));\\n          else return null;\\n        } else if (stream.match(\\\"--\\\")) {\\n          return chain(inBlock(\\\"comment\\\", \\\"-->\\\"));\\n        } else if (stream.match(\\\"DOCTYPE\\\", true, true)) {\\n          stream.eatWhile(/[\\\\w\\\\._\\\\-]/);\\n          return chain(doctype(1));\\n        } else {\\n          return null;\\n        }\\n      } else if (stream.eat(\\\"?\\\")) {\\n        stream.eatWhile(/[\\\\w\\\\._\\\\-]/);\\n        state.tokenize = inBlock(\\\"meta\\\", \\\"?>\\\");\\n        return \\\"meta\\\";\\n      } else {\\n        type = stream.eat(\\\"/\\\") ? \\\"closeTag\\\" : \\\"openTag\\\";\\n        state.tokenize = inTag;\\n        return \\\"tag bracket\\\";\\n      }\\n    } else if (ch == \\\"&\\\") {\\n      var ok;\\n      if (stream.eat(\\\"#\\\")) {\\n        if (stream.eat(\\\"x\\\")) {\\n          ok = stream.eatWhile(/[a-fA-F\\\\d]/) && stream.eat(\\\";\\\");\\n        } else {\\n          ok = stream.eatWhile(/[\\\\d]/) && stream.eat(\\\";\\\");\\n        }\\n      } else {\\n        ok = stream.eatWhile(/[\\\\w\\\\.\\\\-:]/) && stream.eat(\\\";\\\");\\n      }\\n      return ok ? \\\"atom\\\" : \\\"error\\\";\\n    } else {\\n      stream.eatWhile(/[^&<]/);\\n      return null;\\n    }\\n  }\\n  inText.isInText = true;\\n\\n  function inTag(stream, state) {\\n    var ch = stream.next();\\n    if (ch == \\\">\\\" || (ch == \\\"/\\\" && stream.eat(\\\">\\\"))) {\\n      state.tokenize = inText;\\n      type = ch == \\\">\\\" ? \\\"endTag\\\" : \\\"selfcloseTag\\\";\\n      return \\\"tag bracket\\\";\\n    } else if (ch == \\\"=\\\") {\\n      type = \\\"equals\\\";\\n      return null;\\n    } else if (ch == \\\"<\\\") {\\n      state.tokenize = inText;\\n      state.state = baseState;\\n      state.tagName = state.tagStart = null;\\n      var next = state.tokenize(stream, state);\\n      return next ? next + \\\" tag error\\\" : \\\"tag error\\\";\\n    } else if (/[\\\\'\\\\\\\"]/.test(ch)) {\\n      state.tokenize = inAttribute(ch);\\n      state.stringStartCol = stream.column();\\n      return state.tokenize(stream, state);\\n    } else {\\n      stream.match(/^[^\\\\s\\\\u00a0=<>\\\\\\\"\\\\']*[^\\\\s\\\\u00a0=<>\\\\\\\"\\\\'\\\\/]/);\\n      return \\\"word\\\";\\n    }\\n  }\\n\\n  function inAttribute(quote) {\\n    var closure = function(stream, state) {\\n      while (!stream.eol()) {\\n        if (stream.next() == quote) {\\n          state.tokenize = inTag;\\n          break;\\n        }\\n      }\\n      return \\\"string\\\";\\n    };\\n    closure.isInAttribute = true;\\n    return closure;\\n  }\\n\\n  function inBlock(style, terminator) {\\n    return function(stream, state) {\\n      while (!stream.eol()) {\\n        if (stream.match(terminator)) {\\n          state.tokenize = inText;\\n          break;\\n        }\\n        stream.next();\\n      }\\n      return style;\\n    };\\n  }\\n  function doctype(depth) {\\n    return function(stream, state) {\\n      var ch;\\n      while ((ch = stream.next()) != null) {\\n        if (ch == \\\"<\\\") {\\n          state.tokenize = doctype(depth + 1);\\n          return state.tokenize(stream, state);\\n        } else if (ch == \\\">\\\") {\\n          if (depth == 1) {\\n            state.tokenize = inText;\\n            break;\\n          } else {\\n            state.tokenize = doctype(depth - 1);\\n            return state.tokenize(stream, state);\\n          }\\n        }\\n      }\\n      return \\\"meta\\\";\\n    };\\n  }\\n\\n  function Context(state, tagName, startOfLine) {\\n    this.prev = state.context;\\n    this.tagName = tagName;\\n    this.indent = state.indented;\\n    this.startOfLine = startOfLine;\\n    if (config.doNotIndent.hasOwnProperty(tagName) || (state.context && state.context.noIndent))\\n      this.noIndent = true;\\n  }\\n  function popContext(state) {\\n    if (state.context) state.context = state.context.prev;\\n  }\\n  function maybePopContext(state, nextTagName) {\\n    var parentTagName;\\n    while (true) {\\n      if (!state.context) {\\n        return;\\n      }\\n      parentTagName = state.context.tagName;\\n      if (!config.contextGrabbers.hasOwnProperty(parentTagName) ||\\n          !config.contextGrabbers[parentTagName].hasOwnProperty(nextTagName)) {\\n        return;\\n      }\\n      popContext(state);\\n    }\\n  }\\n\\n  function baseState(type, stream, state) {\\n    if (type == \\\"openTag\\\") {\\n      state.tagStart = stream.column();\\n      return tagNameState;\\n    } else if (type == \\\"closeTag\\\") {\\n      return closeTagNameState;\\n    } else {\\n      return baseState;\\n    }\\n  }\\n  function tagNameState(type, stream, state) {\\n    if (type == \\\"word\\\") {\\n      state.tagName = stream.current();\\n      setStyle = \\\"tag\\\";\\n      return attrState;\\n    } else {\\n      setStyle = \\\"error\\\";\\n      return tagNameState;\\n    }\\n  }\\n  function closeTagNameState(type, stream, state) {\\n    if (type == \\\"word\\\") {\\n      var tagName = stream.current();\\n      if (state.context && state.context.tagName != tagName &&\\n          config.implicitlyClosed.hasOwnProperty(state.context.tagName))\\n        popContext(state);\\n      if ((state.context && state.context.tagName == tagName) || config.matchClosing === false) {\\n        setStyle = \\\"tag\\\";\\n        return closeState;\\n      } else {\\n        setStyle = \\\"tag error\\\";\\n        return closeStateErr;\\n      }\\n    } else {\\n      setStyle = \\\"error\\\";\\n      return closeStateErr;\\n    }\\n  }\\n\\n  function closeState(type, _stream, state) {\\n    if (type != \\\"endTag\\\") {\\n      setStyle = \\\"error\\\";\\n      return closeState;\\n    }\\n    popContext(state);\\n    return baseState;\\n  }\\n  function closeStateErr(type, stream, state) {\\n    setStyle = \\\"error\\\";\\n    return closeState(type, stream, state);\\n  }\\n\\n  function attrState(type, _stream, state) {\\n    if (type == \\\"word\\\") {\\n      setStyle = \\\"attribute\\\";\\n      return attrEqState;\\n    } else if (type == \\\"endTag\\\" || type == \\\"selfcloseTag\\\") {\\n      var tagName = state.tagName, tagStart = state.tagStart;\\n      state.tagName = state.tagStart = null;\\n      if (type == \\\"selfcloseTag\\\" ||\\n          config.autoSelfClosers.hasOwnProperty(tagName)) {\\n        maybePopContext(state, tagName);\\n      } else {\\n        maybePopContext(state, tagName);\\n        state.context = new Context(state, tagName, tagStart == state.indented);\\n      }\\n      return baseState;\\n    }\\n    setStyle = \\\"error\\\";\\n    return attrState;\\n  }\\n  function attrEqState(type, stream, state) {\\n    if (type == \\\"equals\\\") return attrValueState;\\n    if (!config.allowMissing) setStyle = \\\"error\\\";\\n    return attrState(type, stream, state);\\n  }\\n  function attrValueState(type, stream, state) {\\n    if (type == \\\"string\\\") return attrContinuedState;\\n    if (type == \\\"word\\\" && config.allowUnquoted) {setStyle = \\\"string\\\"; return attrState;}\\n    setStyle = \\\"error\\\";\\n    return attrState(type, stream, state);\\n  }\\n  function attrContinuedState(type, stream, state) {\\n    if (type == \\\"string\\\") return attrContinuedState;\\n    return attrState(type, stream, state);\\n  }\\n\\n  return {\\n    startState: function(baseIndent) {\\n      var state = {tokenize: inText,\\n                   state: baseState,\\n                   indented: baseIndent || 0,\\n                   tagName: null, tagStart: null,\\n                   context: null}\\n      if (baseIndent != null) state.baseIndent = baseIndent\\n      return state\\n    },\\n\\n    token: function(stream, state) {\\n      if (!state.tagName && stream.sol())\\n        state.indented = stream.indentation();\\n\\n      if (stream.eatSpace()) return null;\\n      type = null;\\n      var style = state.tokenize(stream, state);\\n      if ((style || type) && style != \\\"comment\\\") {\\n        setStyle = null;\\n        state.state = state.state(type || style, stream, state);\\n        if (setStyle)\\n          style = setStyle == \\\"error\\\" ? style + \\\" error\\\" : setStyle;\\n      }\\n      return style;\\n    },\\n\\n    indent: function(state, textAfter, fullLine) {\\n      var context = state.context;\\n      // Indent multi-line strings (e.g. css).\\n      if (state.tokenize.isInAttribute) {\\n        if (state.tagStart == state.indented)\\n          return state.stringStartCol + 1;\\n        else\\n          return state.indented + indentUnit;\\n      }\\n      if (context && context.noIndent) return CodeMirror.Pass;\\n      if (state.tokenize != inTag && state.tokenize != inText)\\n        return fullLine ? fullLine.match(/^(\\\\s*)/)[0].length : 0;\\n      // Indent the starts of attribute names.\\n      if (state.tagName) {\\n        if (config.multilineTagIndentPastTag !== false)\\n          return state.tagStart + state.tagName.length + 2;\\n        else\\n          return state.tagStart + indentUnit * (config.multilineTagIndentFactor || 1);\\n      }\\n      if (config.alignCDATA && /<!\\\\[CDATA\\\\[/.test(textAfter)) return 0;\\n      var tagAfter = textAfter && /^<(\\\\/)?([\\\\w_:\\\\.-]*)/.exec(textAfter);\\n      if (tagAfter && tagAfter[1]) { // Closing tag spotted\\n        while (context) {\\n          if (context.tagName == tagAfter[2]) {\\n            context = context.prev;\\n            break;\\n          } else if (config.implicitlyClosed.hasOwnProperty(context.tagName)) {\\n            context = context.prev;\\n          } else {\\n            break;\\n          }\\n        }\\n      } else if (tagAfter) { // Opening tag spotted\\n        while (context) {\\n          var grabbers = config.contextGrabbers[context.tagName];\\n          if (grabbers && grabbers.hasOwnProperty(tagAfter[2]))\\n            context = context.prev;\\n          else\\n            break;\\n        }\\n      }\\n      while (context && context.prev && !context.startOfLine)\\n        context = context.prev;\\n      if (context) return context.indent + indentUnit;\\n      else return state.baseIndent || 0;\\n    },\\n\\n    electricInput: /<\\\\/[\\\\s\\\\w:]+>$/,\\n    blockCommentStart: \\\"<!--\\\",\\n    blockCommentEnd: \\\"-->\\\",\\n\\n    configuration: config.htmlMode ? \\\"html\\\" : \\\"xml\\\",\\n    helperType: config.htmlMode ? \\\"html\\\" : \\\"xml\\\",\\n\\n    skipAttribute: function(state) {\\n      if (state.state == attrValueState)\\n        state.state = attrState\\n    }\\n  };\\n});\\n\\nCodeMirror.defineMIME(\\\"text/xml\\\", \\\"xml\\\");\\nCodeMirror.defineMIME(\\\"application/xml\\\", \\\"xml\\\");\\nif (!CodeMirror.mimeModes.hasOwnProperty(\\\"text/html\\\"))\\n  CodeMirror.defineMIME(\\\"text/html\\\", {name: \\\"xml\\\", htmlMode: true});\\n\\n});\\n\"//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL34vY29kZW1pcnJvci9tb2RlL3htbC94bWwuanM/Y2MzNSJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IFwiLy8gQ29kZU1pcnJvciwgY29weXJpZ2h0IChjKSBieSBNYXJpam4gSGF2ZXJiZWtlIGFuZCBvdGhlcnNcXG4vLyBEaXN0cmlidXRlZCB1bmRlciBhbiBNSVQgbGljZW5zZTogaHR0cDovL2NvZGVtaXJyb3IubmV0L0xJQ0VOU0VcXG5cXG4oZnVuY3Rpb24obW9kKSB7XFxuICBpZiAodHlwZW9mIGV4cG9ydHMgPT0gXFxcIm9iamVjdFxcXCIgJiYgdHlwZW9mIG1vZHVsZSA9PSBcXFwib2JqZWN0XFxcIikgLy8gQ29tbW9uSlNcXG4gICAgbW9kKHJlcXVpcmUoXFxcIi4uLy4uL2xpYi9jb2RlbWlycm9yXFxcIikpO1xcbiAgZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PSBcXFwiZnVuY3Rpb25cXFwiICYmIGRlZmluZS5hbWQpIC8vIEFNRFxcbiAgICBkZWZpbmUoW1xcXCIuLi8uLi9saWIvY29kZW1pcnJvclxcXCJdLCBtb2QpO1xcbiAgZWxzZSAvLyBQbGFpbiBicm93c2VyIGVudlxcbiAgICBtb2QoQ29kZU1pcnJvcik7XFxufSkoZnVuY3Rpb24oQ29kZU1pcnJvcikge1xcblxcXCJ1c2Ugc3RyaWN0XFxcIjtcXG5cXG52YXIgaHRtbENvbmZpZyA9IHtcXG4gIGF1dG9TZWxmQ2xvc2VyczogeydhcmVhJzogdHJ1ZSwgJ2Jhc2UnOiB0cnVlLCAnYnInOiB0cnVlLCAnY29sJzogdHJ1ZSwgJ2NvbW1hbmQnOiB0cnVlLFxcbiAgICAgICAgICAgICAgICAgICAgJ2VtYmVkJzogdHJ1ZSwgJ2ZyYW1lJzogdHJ1ZSwgJ2hyJzogdHJ1ZSwgJ2ltZyc6IHRydWUsICdpbnB1dCc6IHRydWUsXFxuICAgICAgICAgICAgICAgICAgICAna2V5Z2VuJzogdHJ1ZSwgJ2xpbmsnOiB0cnVlLCAnbWV0YSc6IHRydWUsICdwYXJhbSc6IHRydWUsICdzb3VyY2UnOiB0cnVlLFxcbiAgICAgICAgICAgICAgICAgICAgJ3RyYWNrJzogdHJ1ZSwgJ3dicic6IHRydWUsICdtZW51aXRlbSc6IHRydWV9LFxcbiAgaW1wbGljaXRseUNsb3NlZDogeydkZCc6IHRydWUsICdsaSc6IHRydWUsICdvcHRncm91cCc6IHRydWUsICdvcHRpb24nOiB0cnVlLCAncCc6IHRydWUsXFxuICAgICAgICAgICAgICAgICAgICAgJ3JwJzogdHJ1ZSwgJ3J0JzogdHJ1ZSwgJ3Rib2R5JzogdHJ1ZSwgJ3RkJzogdHJ1ZSwgJ3Rmb290JzogdHJ1ZSxcXG4gICAgICAgICAgICAgICAgICAgICAndGgnOiB0cnVlLCAndHInOiB0cnVlfSxcXG4gIGNvbnRleHRHcmFiYmVyczoge1xcbiAgICAnZGQnOiB7J2RkJzogdHJ1ZSwgJ2R0JzogdHJ1ZX0sXFxuICAgICdkdCc6IHsnZGQnOiB0cnVlLCAnZHQnOiB0cnVlfSxcXG4gICAgJ2xpJzogeydsaSc6IHRydWV9LFxcbiAgICAnb3B0aW9uJzogeydvcHRpb24nOiB0cnVlLCAnb3B0Z3JvdXAnOiB0cnVlfSxcXG4gICAgJ29wdGdyb3VwJzogeydvcHRncm91cCc6IHRydWV9LFxcbiAgICAncCc6IHsnYWRkcmVzcyc6IHRydWUsICdhcnRpY2xlJzogdHJ1ZSwgJ2FzaWRlJzogdHJ1ZSwgJ2Jsb2NrcXVvdGUnOiB0cnVlLCAnZGlyJzogdHJ1ZSxcXG4gICAgICAgICAgJ2Rpdic6IHRydWUsICdkbCc6IHRydWUsICdmaWVsZHNldCc6IHRydWUsICdmb290ZXInOiB0cnVlLCAnZm9ybSc6IHRydWUsXFxuICAgICAgICAgICdoMSc6IHRydWUsICdoMic6IHRydWUsICdoMyc6IHRydWUsICdoNCc6IHRydWUsICdoNSc6IHRydWUsICdoNic6IHRydWUsXFxuICAgICAgICAgICdoZWFkZXInOiB0cnVlLCAnaGdyb3VwJzogdHJ1ZSwgJ2hyJzogdHJ1ZSwgJ21lbnUnOiB0cnVlLCAnbmF2JzogdHJ1ZSwgJ29sJzogdHJ1ZSxcXG4gICAgICAgICAgJ3AnOiB0cnVlLCAncHJlJzogdHJ1ZSwgJ3NlY3Rpb24nOiB0cnVlLCAndGFibGUnOiB0cnVlLCAndWwnOiB0cnVlfSxcXG4gICAgJ3JwJzogeydycCc6IHRydWUsICdydCc6IHRydWV9LFxcbiAgICAncnQnOiB7J3JwJzogdHJ1ZSwgJ3J0JzogdHJ1ZX0sXFxuICAgICd0Ym9keSc6IHsndGJvZHknOiB0cnVlLCAndGZvb3QnOiB0cnVlfSxcXG4gICAgJ3RkJzogeyd0ZCc6IHRydWUsICd0aCc6IHRydWV9LFxcbiAgICAndGZvb3QnOiB7J3Rib2R5JzogdHJ1ZX0sXFxuICAgICd0aCc6IHsndGQnOiB0cnVlLCAndGgnOiB0cnVlfSxcXG4gICAgJ3RoZWFkJzogeyd0Ym9keSc6IHRydWUsICd0Zm9vdCc6IHRydWV9LFxcbiAgICAndHInOiB7J3RyJzogdHJ1ZX1cXG4gIH0sXFxuICBkb05vdEluZGVudDoge1xcXCJwcmVcXFwiOiB0cnVlfSxcXG4gIGFsbG93VW5xdW90ZWQ6IHRydWUsXFxuICBhbGxvd01pc3Npbmc6IHRydWUsXFxuICBjYXNlRm9sZDogdHJ1ZVxcbn1cXG5cXG52YXIgeG1sQ29uZmlnID0ge1xcbiAgYXV0b1NlbGZDbG9zZXJzOiB7fSxcXG4gIGltcGxpY2l0bHlDbG9zZWQ6IHt9LFxcbiAgY29udGV4dEdyYWJiZXJzOiB7fSxcXG4gIGRvTm90SW5kZW50OiB7fSxcXG4gIGFsbG93VW5xdW90ZWQ6IGZhbHNlLFxcbiAgYWxsb3dNaXNzaW5nOiBmYWxzZSxcXG4gIGNhc2VGb2xkOiBmYWxzZVxcbn1cXG5cXG5Db2RlTWlycm9yLmRlZmluZU1vZGUoXFxcInhtbFxcXCIsIGZ1bmN0aW9uKGVkaXRvckNvbmYsIGNvbmZpZ18pIHtcXG4gIHZhciBpbmRlbnRVbml0ID0gZWRpdG9yQ29uZi5pbmRlbnRVbml0XFxuICB2YXIgY29uZmlnID0ge31cXG4gIHZhciBkZWZhdWx0cyA9IGNvbmZpZ18uaHRtbE1vZGUgPyBodG1sQ29uZmlnIDogeG1sQ29uZmlnXFxuICBmb3IgKHZhciBwcm9wIGluIGRlZmF1bHRzKSBjb25maWdbcHJvcF0gPSBkZWZhdWx0c1twcm9wXVxcbiAgZm9yICh2YXIgcHJvcCBpbiBjb25maWdfKSBjb25maWdbcHJvcF0gPSBjb25maWdfW3Byb3BdXFxuXFxuICAvLyBSZXR1cm4gdmFyaWFibGVzIGZvciB0b2tlbml6ZXJzXFxuICB2YXIgdHlwZSwgc2V0U3R5bGU7XFxuXFxuICBmdW5jdGlvbiBpblRleHQoc3RyZWFtLCBzdGF0ZSkge1xcbiAgICBmdW5jdGlvbiBjaGFpbihwYXJzZXIpIHtcXG4gICAgICBzdGF0ZS50b2tlbml6ZSA9IHBhcnNlcjtcXG4gICAgICByZXR1cm4gcGFyc2VyKHN0cmVhbSwgc3RhdGUpO1xcbiAgICB9XFxuXFxuICAgIHZhciBjaCA9IHN0cmVhbS5uZXh0KCk7XFxuICAgIGlmIChjaCA9PSBcXFwiPFxcXCIpIHtcXG4gICAgICBpZiAoc3RyZWFtLmVhdChcXFwiIVxcXCIpKSB7XFxuICAgICAgICBpZiAoc3RyZWFtLmVhdChcXFwiW1xcXCIpKSB7XFxuICAgICAgICAgIGlmIChzdHJlYW0ubWF0Y2goXFxcIkNEQVRBW1xcXCIpKSByZXR1cm4gY2hhaW4oaW5CbG9jayhcXFwiYXRvbVxcXCIsIFxcXCJdXT5cXFwiKSk7XFxuICAgICAgICAgIGVsc2UgcmV0dXJuIG51bGw7XFxuICAgICAgICB9IGVsc2UgaWYgKHN0cmVhbS5tYXRjaChcXFwiLS1cXFwiKSkge1xcbiAgICAgICAgICByZXR1cm4gY2hhaW4oaW5CbG9jayhcXFwiY29tbWVudFxcXCIsIFxcXCItLT5cXFwiKSk7XFxuICAgICAgICB9IGVsc2UgaWYgKHN0cmVhbS5tYXRjaChcXFwiRE9DVFlQRVxcXCIsIHRydWUsIHRydWUpKSB7XFxuICAgICAgICAgIHN0cmVhbS5lYXRXaGlsZSgvW1xcXFx3XFxcXC5fXFxcXC1dLyk7XFxuICAgICAgICAgIHJldHVybiBjaGFpbihkb2N0eXBlKDEpKTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIHJldHVybiBudWxsO1xcbiAgICAgICAgfVxcbiAgICAgIH0gZWxzZSBpZiAoc3RyZWFtLmVhdChcXFwiP1xcXCIpKSB7XFxuICAgICAgICBzdHJlYW0uZWF0V2hpbGUoL1tcXFxcd1xcXFwuX1xcXFwtXS8pO1xcbiAgICAgICAgc3RhdGUudG9rZW5pemUgPSBpbkJsb2NrKFxcXCJtZXRhXFxcIiwgXFxcIj8+XFxcIik7XFxuICAgICAgICByZXR1cm4gXFxcIm1ldGFcXFwiO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICB0eXBlID0gc3RyZWFtLmVhdChcXFwiL1xcXCIpID8gXFxcImNsb3NlVGFnXFxcIiA6IFxcXCJvcGVuVGFnXFxcIjtcXG4gICAgICAgIHN0YXRlLnRva2VuaXplID0gaW5UYWc7XFxuICAgICAgICByZXR1cm4gXFxcInRhZyBicmFja2V0XFxcIjtcXG4gICAgICB9XFxuICAgIH0gZWxzZSBpZiAoY2ggPT0gXFxcIiZcXFwiKSB7XFxuICAgICAgdmFyIG9rO1xcbiAgICAgIGlmIChzdHJlYW0uZWF0KFxcXCIjXFxcIikpIHtcXG4gICAgICAgIGlmIChzdHJlYW0uZWF0KFxcXCJ4XFxcIikpIHtcXG4gICAgICAgICAgb2sgPSBzdHJlYW0uZWF0V2hpbGUoL1thLWZBLUZcXFxcZF0vKSAmJiBzdHJlYW0uZWF0KFxcXCI7XFxcIik7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICBvayA9IHN0cmVhbS5lYXRXaGlsZSgvW1xcXFxkXS8pICYmIHN0cmVhbS5lYXQoXFxcIjtcXFwiKTtcXG4gICAgICAgIH1cXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgb2sgPSBzdHJlYW0uZWF0V2hpbGUoL1tcXFxcd1xcXFwuXFxcXC06XS8pICYmIHN0cmVhbS5lYXQoXFxcIjtcXFwiKTtcXG4gICAgICB9XFxuICAgICAgcmV0dXJuIG9rID8gXFxcImF0b21cXFwiIDogXFxcImVycm9yXFxcIjtcXG4gICAgfSBlbHNlIHtcXG4gICAgICBzdHJlYW0uZWF0V2hpbGUoL1teJjxdLyk7XFxuICAgICAgcmV0dXJuIG51bGw7XFxuICAgIH1cXG4gIH1cXG4gIGluVGV4dC5pc0luVGV4dCA9IHRydWU7XFxuXFxuICBmdW5jdGlvbiBpblRhZyhzdHJlYW0sIHN0YXRlKSB7XFxuICAgIHZhciBjaCA9IHN0cmVhbS5uZXh0KCk7XFxuICAgIGlmIChjaCA9PSBcXFwiPlxcXCIgfHwgKGNoID09IFxcXCIvXFxcIiAmJiBzdHJlYW0uZWF0KFxcXCI+XFxcIikpKSB7XFxuICAgICAgc3RhdGUudG9rZW5pemUgPSBpblRleHQ7XFxuICAgICAgdHlwZSA9IGNoID09IFxcXCI+XFxcIiA/IFxcXCJlbmRUYWdcXFwiIDogXFxcInNlbGZjbG9zZVRhZ1xcXCI7XFxuICAgICAgcmV0dXJuIFxcXCJ0YWcgYnJhY2tldFxcXCI7XFxuICAgIH0gZWxzZSBpZiAoY2ggPT0gXFxcIj1cXFwiKSB7XFxuICAgICAgdHlwZSA9IFxcXCJlcXVhbHNcXFwiO1xcbiAgICAgIHJldHVybiBudWxsO1xcbiAgICB9IGVsc2UgaWYgKGNoID09IFxcXCI8XFxcIikge1xcbiAgICAgIHN0YXRlLnRva2VuaXplID0gaW5UZXh0O1xcbiAgICAgIHN0YXRlLnN0YXRlID0gYmFzZVN0YXRlO1xcbiAgICAgIHN0YXRlLnRhZ05hbWUgPSBzdGF0ZS50YWdTdGFydCA9IG51bGw7XFxuICAgICAgdmFyIG5leHQgPSBzdGF0ZS50b2tlbml6ZShzdHJlYW0sIHN0YXRlKTtcXG4gICAgICByZXR1cm4gbmV4dCA/IG5leHQgKyBcXFwiIHRhZyBlcnJvclxcXCIgOiBcXFwidGFnIGVycm9yXFxcIjtcXG4gICAgfSBlbHNlIGlmICgvW1xcXFwnXFxcXFxcXCJdLy50ZXN0KGNoKSkge1xcbiAgICAgIHN0YXRlLnRva2VuaXplID0gaW5BdHRyaWJ1dGUoY2gpO1xcbiAgICAgIHN0YXRlLnN0cmluZ1N0YXJ0Q29sID0gc3RyZWFtLmNvbHVtbigpO1xcbiAgICAgIHJldHVybiBzdGF0ZS50b2tlbml6ZShzdHJlYW0sIHN0YXRlKTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICBzdHJlYW0ubWF0Y2goL15bXlxcXFxzXFxcXHUwMGEwPTw+XFxcXFxcXCJcXFxcJ10qW15cXFxcc1xcXFx1MDBhMD08PlxcXFxcXFwiXFxcXCdcXFxcL10vKTtcXG4gICAgICByZXR1cm4gXFxcIndvcmRcXFwiO1xcbiAgICB9XFxuICB9XFxuXFxuICBmdW5jdGlvbiBpbkF0dHJpYnV0ZShxdW90ZSkge1xcbiAgICB2YXIgY2xvc3VyZSA9IGZ1bmN0aW9uKHN0cmVhbSwgc3RhdGUpIHtcXG4gICAgICB3aGlsZSAoIXN0cmVhbS5lb2woKSkge1xcbiAgICAgICAgaWYgKHN0cmVhbS5uZXh0KCkgPT0gcXVvdGUpIHtcXG4gICAgICAgICAgc3RhdGUudG9rZW5pemUgPSBpblRhZztcXG4gICAgICAgICAgYnJlYWs7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICAgIHJldHVybiBcXFwic3RyaW5nXFxcIjtcXG4gICAgfTtcXG4gICAgY2xvc3VyZS5pc0luQXR0cmlidXRlID0gdHJ1ZTtcXG4gICAgcmV0dXJuIGNsb3N1cmU7XFxuICB9XFxuXFxuICBmdW5jdGlvbiBpbkJsb2NrKHN0eWxlLCB0ZXJtaW5hdG9yKSB7XFxuICAgIHJldHVybiBmdW5jdGlvbihzdHJlYW0sIHN0YXRlKSB7XFxuICAgICAgd2hpbGUgKCFzdHJlYW0uZW9sKCkpIHtcXG4gICAgICAgIGlmIChzdHJlYW0ubWF0Y2godGVybWluYXRvcikpIHtcXG4gICAgICAgICAgc3RhdGUudG9rZW5pemUgPSBpblRleHQ7XFxuICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgfVxcbiAgICAgICAgc3RyZWFtLm5leHQoKTtcXG4gICAgICB9XFxuICAgICAgcmV0dXJuIHN0eWxlO1xcbiAgICB9O1xcbiAgfVxcbiAgZnVuY3Rpb24gZG9jdHlwZShkZXB0aCkge1xcbiAgICByZXR1cm4gZnVuY3Rpb24oc3RyZWFtLCBzdGF0ZSkge1xcbiAgICAgIHZhciBjaDtcXG4gICAgICB3aGlsZSAoKGNoID0gc3RyZWFtLm5leHQoKSkgIT0gbnVsbCkge1xcbiAgICAgICAgaWYgKGNoID09IFxcXCI8XFxcIikge1xcbiAgICAgICAgICBzdGF0ZS50b2tlbml6ZSA9IGRvY3R5cGUoZGVwdGggKyAxKTtcXG4gICAgICAgICAgcmV0dXJuIHN0YXRlLnRva2VuaXplKHN0cmVhbSwgc3RhdGUpO1xcbiAgICAgICAgfSBlbHNlIGlmIChjaCA9PSBcXFwiPlxcXCIpIHtcXG4gICAgICAgICAgaWYgKGRlcHRoID09IDEpIHtcXG4gICAgICAgICAgICBzdGF0ZS50b2tlbml6ZSA9IGluVGV4dDtcXG4gICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICBzdGF0ZS50b2tlbml6ZSA9IGRvY3R5cGUoZGVwdGggLSAxKTtcXG4gICAgICAgICAgICByZXR1cm4gc3RhdGUudG9rZW5pemUoc3RyZWFtLCBzdGF0ZSk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgICAgcmV0dXJuIFxcXCJtZXRhXFxcIjtcXG4gICAgfTtcXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIENvbnRleHQoc3RhdGUsIHRhZ05hbWUsIHN0YXJ0T2ZMaW5lKSB7XFxuICAgIHRoaXMucHJldiA9IHN0YXRlLmNvbnRleHQ7XFxuICAgIHRoaXMudGFnTmFtZSA9IHRhZ05hbWU7XFxuICAgIHRoaXMuaW5kZW50ID0gc3RhdGUuaW5kZW50ZWQ7XFxuICAgIHRoaXMuc3RhcnRPZkxpbmUgPSBzdGFydE9mTGluZTtcXG4gICAgaWYgKGNvbmZpZy5kb05vdEluZGVudC5oYXNPd25Qcm9wZXJ0eSh0YWdOYW1lKSB8fCAoc3RhdGUuY29udGV4dCAmJiBzdGF0ZS5jb250ZXh0Lm5vSW5kZW50KSlcXG4gICAgICB0aGlzLm5vSW5kZW50ID0gdHJ1ZTtcXG4gIH1cXG4gIGZ1bmN0aW9uIHBvcENvbnRleHQoc3RhdGUpIHtcXG4gICAgaWYgKHN0YXRlLmNvbnRleHQpIHN0YXRlLmNvbnRleHQgPSBzdGF0ZS5jb250ZXh0LnByZXY7XFxuICB9XFxuICBmdW5jdGlvbiBtYXliZVBvcENvbnRleHQoc3RhdGUsIG5leHRUYWdOYW1lKSB7XFxuICAgIHZhciBwYXJlbnRUYWdOYW1lO1xcbiAgICB3aGlsZSAodHJ1ZSkge1xcbiAgICAgIGlmICghc3RhdGUuY29udGV4dCkge1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICAgIH1cXG4gICAgICBwYXJlbnRUYWdOYW1lID0gc3RhdGUuY29udGV4dC50YWdOYW1lO1xcbiAgICAgIGlmICghY29uZmlnLmNvbnRleHRHcmFiYmVycy5oYXNPd25Qcm9wZXJ0eShwYXJlbnRUYWdOYW1lKSB8fFxcbiAgICAgICAgICAhY29uZmlnLmNvbnRleHRHcmFiYmVyc1twYXJlbnRUYWdOYW1lXS5oYXNPd25Qcm9wZXJ0eShuZXh0VGFnTmFtZSkpIHtcXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9XFxuICAgICAgcG9wQ29udGV4dChzdGF0ZSk7XFxuICAgIH1cXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIGJhc2VTdGF0ZSh0eXBlLCBzdHJlYW0sIHN0YXRlKSB7XFxuICAgIGlmICh0eXBlID09IFxcXCJvcGVuVGFnXFxcIikge1xcbiAgICAgIHN0YXRlLnRhZ1N0YXJ0ID0gc3RyZWFtLmNvbHVtbigpO1xcbiAgICAgIHJldHVybiB0YWdOYW1lU3RhdGU7XFxuICAgIH0gZWxzZSBpZiAodHlwZSA9PSBcXFwiY2xvc2VUYWdcXFwiKSB7XFxuICAgICAgcmV0dXJuIGNsb3NlVGFnTmFtZVN0YXRlO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIHJldHVybiBiYXNlU3RhdGU7XFxuICAgIH1cXG4gIH1cXG4gIGZ1bmN0aW9uIHRhZ05hbWVTdGF0ZSh0eXBlLCBzdHJlYW0sIHN0YXRlKSB7XFxuICAgIGlmICh0eXBlID09IFxcXCJ3b3JkXFxcIikge1xcbiAgICAgIHN0YXRlLnRhZ05hbWUgPSBzdHJlYW0uY3VycmVudCgpO1xcbiAgICAgIHNldFN0eWxlID0gXFxcInRhZ1xcXCI7XFxuICAgICAgcmV0dXJuIGF0dHJTdGF0ZTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICBzZXRTdHlsZSA9IFxcXCJlcnJvclxcXCI7XFxuICAgICAgcmV0dXJuIHRhZ05hbWVTdGF0ZTtcXG4gICAgfVxcbiAgfVxcbiAgZnVuY3Rpb24gY2xvc2VUYWdOYW1lU3RhdGUodHlwZSwgc3RyZWFtLCBzdGF0ZSkge1xcbiAgICBpZiAodHlwZSA9PSBcXFwid29yZFxcXCIpIHtcXG4gICAgICB2YXIgdGFnTmFtZSA9IHN0cmVhbS5jdXJyZW50KCk7XFxuICAgICAgaWYgKHN0YXRlLmNvbnRleHQgJiYgc3RhdGUuY29udGV4dC50YWdOYW1lICE9IHRhZ05hbWUgJiZcXG4gICAgICAgICAgY29uZmlnLmltcGxpY2l0bHlDbG9zZWQuaGFzT3duUHJvcGVydHkoc3RhdGUuY29udGV4dC50YWdOYW1lKSlcXG4gICAgICAgIHBvcENvbnRleHQoc3RhdGUpO1xcbiAgICAgIGlmICgoc3RhdGUuY29udGV4dCAmJiBzdGF0ZS5jb250ZXh0LnRhZ05hbWUgPT0gdGFnTmFtZSkgfHwgY29uZmlnLm1hdGNoQ2xvc2luZyA9PT0gZmFsc2UpIHtcXG4gICAgICAgIHNldFN0eWxlID0gXFxcInRhZ1xcXCI7XFxuICAgICAgICByZXR1cm4gY2xvc2VTdGF0ZTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgc2V0U3R5bGUgPSBcXFwidGFnIGVycm9yXFxcIjtcXG4gICAgICAgIHJldHVybiBjbG9zZVN0YXRlRXJyO1xcbiAgICAgIH1cXG4gICAgfSBlbHNlIHtcXG4gICAgICBzZXRTdHlsZSA9IFxcXCJlcnJvclxcXCI7XFxuICAgICAgcmV0dXJuIGNsb3NlU3RhdGVFcnI7XFxuICAgIH1cXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIGNsb3NlU3RhdGUodHlwZSwgX3N0cmVhbSwgc3RhdGUpIHtcXG4gICAgaWYgKHR5cGUgIT0gXFxcImVuZFRhZ1xcXCIpIHtcXG4gICAgICBzZXRTdHlsZSA9IFxcXCJlcnJvclxcXCI7XFxuICAgICAgcmV0dXJuIGNsb3NlU3RhdGU7XFxuICAgIH1cXG4gICAgcG9wQ29udGV4dChzdGF0ZSk7XFxuICAgIHJldHVybiBiYXNlU3RhdGU7XFxuICB9XFxuICBmdW5jdGlvbiBjbG9zZVN0YXRlRXJyKHR5cGUsIHN0cmVhbSwgc3RhdGUpIHtcXG4gICAgc2V0U3R5bGUgPSBcXFwiZXJyb3JcXFwiO1xcbiAgICByZXR1cm4gY2xvc2VTdGF0ZSh0eXBlLCBzdHJlYW0sIHN0YXRlKTtcXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIGF0dHJTdGF0ZSh0eXBlLCBfc3RyZWFtLCBzdGF0ZSkge1xcbiAgICBpZiAodHlwZSA9PSBcXFwid29yZFxcXCIpIHtcXG4gICAgICBzZXRTdHlsZSA9IFxcXCJhdHRyaWJ1dGVcXFwiO1xcbiAgICAgIHJldHVybiBhdHRyRXFTdGF0ZTtcXG4gICAgfSBlbHNlIGlmICh0eXBlID09IFxcXCJlbmRUYWdcXFwiIHx8IHR5cGUgPT0gXFxcInNlbGZjbG9zZVRhZ1xcXCIpIHtcXG4gICAgICB2YXIgdGFnTmFtZSA9IHN0YXRlLnRhZ05hbWUsIHRhZ1N0YXJ0ID0gc3RhdGUudGFnU3RhcnQ7XFxuICAgICAgc3RhdGUudGFnTmFtZSA9IHN0YXRlLnRhZ1N0YXJ0ID0gbnVsbDtcXG4gICAgICBpZiAodHlwZSA9PSBcXFwic2VsZmNsb3NlVGFnXFxcIiB8fFxcbiAgICAgICAgICBjb25maWcuYXV0b1NlbGZDbG9zZXJzLmhhc093blByb3BlcnR5KHRhZ05hbWUpKSB7XFxuICAgICAgICBtYXliZVBvcENvbnRleHQoc3RhdGUsIHRhZ05hbWUpO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBtYXliZVBvcENvbnRleHQoc3RhdGUsIHRhZ05hbWUpO1xcbiAgICAgICAgc3RhdGUuY29udGV4dCA9IG5ldyBDb250ZXh0KHN0YXRlLCB0YWdOYW1lLCB0YWdTdGFydCA9PSBzdGF0ZS5pbmRlbnRlZCk7XFxuICAgICAgfVxcbiAgICAgIHJldHVybiBiYXNlU3RhdGU7XFxuICAgIH1cXG4gICAgc2V0U3R5bGUgPSBcXFwiZXJyb3JcXFwiO1xcbiAgICByZXR1cm4gYXR0clN0YXRlO1xcbiAgfVxcbiAgZnVuY3Rpb24gYXR0ckVxU3RhdGUodHlwZSwgc3RyZWFtLCBzdGF0ZSkge1xcbiAgICBpZiAodHlwZSA9PSBcXFwiZXF1YWxzXFxcIikgcmV0dXJuIGF0dHJWYWx1ZVN0YXRlO1xcbiAgICBpZiAoIWNvbmZpZy5hbGxvd01pc3NpbmcpIHNldFN0eWxlID0gXFxcImVycm9yXFxcIjtcXG4gICAgcmV0dXJuIGF0dHJTdGF0ZSh0eXBlLCBzdHJlYW0sIHN0YXRlKTtcXG4gIH1cXG4gIGZ1bmN0aW9uIGF0dHJWYWx1ZVN0YXRlKHR5cGUsIHN0cmVhbSwgc3RhdGUpIHtcXG4gICAgaWYgKHR5cGUgPT0gXFxcInN0cmluZ1xcXCIpIHJldHVybiBhdHRyQ29udGludWVkU3RhdGU7XFxuICAgIGlmICh0eXBlID09IFxcXCJ3b3JkXFxcIiAmJiBjb25maWcuYWxsb3dVbnF1b3RlZCkge3NldFN0eWxlID0gXFxcInN0cmluZ1xcXCI7IHJldHVybiBhdHRyU3RhdGU7fVxcbiAgICBzZXRTdHlsZSA9IFxcXCJlcnJvclxcXCI7XFxuICAgIHJldHVybiBhdHRyU3RhdGUodHlwZSwgc3RyZWFtLCBzdGF0ZSk7XFxuICB9XFxuICBmdW5jdGlvbiBhdHRyQ29udGludWVkU3RhdGUodHlwZSwgc3RyZWFtLCBzdGF0ZSkge1xcbiAgICBpZiAodHlwZSA9PSBcXFwic3RyaW5nXFxcIikgcmV0dXJuIGF0dHJDb250aW51ZWRTdGF0ZTtcXG4gICAgcmV0dXJuIGF0dHJTdGF0ZSh0eXBlLCBzdHJlYW0sIHN0YXRlKTtcXG4gIH1cXG5cXG4gIHJldHVybiB7XFxuICAgIHN0YXJ0U3RhdGU6IGZ1bmN0aW9uKGJhc2VJbmRlbnQpIHtcXG4gICAgICB2YXIgc3RhdGUgPSB7dG9rZW5pemU6IGluVGV4dCxcXG4gICAgICAgICAgICAgICAgICAgc3RhdGU6IGJhc2VTdGF0ZSxcXG4gICAgICAgICAgICAgICAgICAgaW5kZW50ZWQ6IGJhc2VJbmRlbnQgfHwgMCxcXG4gICAgICAgICAgICAgICAgICAgdGFnTmFtZTogbnVsbCwgdGFnU3RhcnQ6IG51bGwsXFxuICAgICAgICAgICAgICAgICAgIGNvbnRleHQ6IG51bGx9XFxuICAgICAgaWYgKGJhc2VJbmRlbnQgIT0gbnVsbCkgc3RhdGUuYmFzZUluZGVudCA9IGJhc2VJbmRlbnRcXG4gICAgICByZXR1cm4gc3RhdGVcXG4gICAgfSxcXG5cXG4gICAgdG9rZW46IGZ1bmN0aW9uKHN0cmVhbSwgc3RhdGUpIHtcXG4gICAgICBpZiAoIXN0YXRlLnRhZ05hbWUgJiYgc3RyZWFtLnNvbCgpKVxcbiAgICAgICAgc3RhdGUuaW5kZW50ZWQgPSBzdHJlYW0uaW5kZW50YXRpb24oKTtcXG5cXG4gICAgICBpZiAoc3RyZWFtLmVhdFNwYWNlKCkpIHJldHVybiBudWxsO1xcbiAgICAgIHR5cGUgPSBudWxsO1xcbiAgICAgIHZhciBzdHlsZSA9IHN0YXRlLnRva2VuaXplKHN0cmVhbSwgc3RhdGUpO1xcbiAgICAgIGlmICgoc3R5bGUgfHwgdHlwZSkgJiYgc3R5bGUgIT0gXFxcImNvbW1lbnRcXFwiKSB7XFxuICAgICAgICBzZXRTdHlsZSA9IG51bGw7XFxuICAgICAgICBzdGF0ZS5zdGF0ZSA9IHN0YXRlLnN0YXRlKHR5cGUgfHwgc3R5bGUsIHN0cmVhbSwgc3RhdGUpO1xcbiAgICAgICAgaWYgKHNldFN0eWxlKVxcbiAgICAgICAgICBzdHlsZSA9IHNldFN0eWxlID09IFxcXCJlcnJvclxcXCIgPyBzdHlsZSArIFxcXCIgZXJyb3JcXFwiIDogc2V0U3R5bGU7XFxuICAgICAgfVxcbiAgICAgIHJldHVybiBzdHlsZTtcXG4gICAgfSxcXG5cXG4gICAgaW5kZW50OiBmdW5jdGlvbihzdGF0ZSwgdGV4dEFmdGVyLCBmdWxsTGluZSkge1xcbiAgICAgIHZhciBjb250ZXh0ID0gc3RhdGUuY29udGV4dDtcXG4gICAgICAvLyBJbmRlbnQgbXVsdGktbGluZSBzdHJpbmdzIChlLmcuIGNzcykuXFxuICAgICAgaWYgKHN0YXRlLnRva2VuaXplLmlzSW5BdHRyaWJ1dGUpIHtcXG4gICAgICAgIGlmIChzdGF0ZS50YWdTdGFydCA9PSBzdGF0ZS5pbmRlbnRlZClcXG4gICAgICAgICAgcmV0dXJuIHN0YXRlLnN0cmluZ1N0YXJ0Q29sICsgMTtcXG4gICAgICAgIGVsc2VcXG4gICAgICAgICAgcmV0dXJuIHN0YXRlLmluZGVudGVkICsgaW5kZW50VW5pdDtcXG4gICAgICB9XFxuICAgICAgaWYgKGNvbnRleHQgJiYgY29udGV4dC5ub0luZGVudCkgcmV0dXJuIENvZGVNaXJyb3IuUGFzcztcXG4gICAgICBpZiAoc3RhdGUudG9rZW5pemUgIT0gaW5UYWcgJiYgc3RhdGUudG9rZW5pemUgIT0gaW5UZXh0KVxcbiAgICAgICAgcmV0dXJuIGZ1bGxMaW5lID8gZnVsbExpbmUubWF0Y2goL14oXFxcXHMqKS8pWzBdLmxlbmd0aCA6IDA7XFxuICAgICAgLy8gSW5kZW50IHRoZSBzdGFydHMgb2YgYXR0cmlidXRlIG5hbWVzLlxcbiAgICAgIGlmIChzdGF0ZS50YWdOYW1lKSB7XFxuICAgICAgICBpZiAoY29uZmlnLm11bHRpbGluZVRhZ0luZGVudFBhc3RUYWcgIT09IGZhbHNlKVxcbiAgICAgICAgICByZXR1cm4gc3RhdGUudGFnU3RhcnQgKyBzdGF0ZS50YWdOYW1lLmxlbmd0aCArIDI7XFxuICAgICAgICBlbHNlXFxuICAgICAgICAgIHJldHVybiBzdGF0ZS50YWdTdGFydCArIGluZGVudFVuaXQgKiAoY29uZmlnLm11bHRpbGluZVRhZ0luZGVudEZhY3RvciB8fCAxKTtcXG4gICAgICB9XFxuICAgICAgaWYgKGNvbmZpZy5hbGlnbkNEQVRBICYmIC88IVxcXFxbQ0RBVEFcXFxcWy8udGVzdCh0ZXh0QWZ0ZXIpKSByZXR1cm4gMDtcXG4gICAgICB2YXIgdGFnQWZ0ZXIgPSB0ZXh0QWZ0ZXIgJiYgL148KFxcXFwvKT8oW1xcXFx3XzpcXFxcLi1dKikvLmV4ZWModGV4dEFmdGVyKTtcXG4gICAgICBpZiAodGFnQWZ0ZXIgJiYgdGFnQWZ0ZXJbMV0pIHsgLy8gQ2xvc2luZyB0YWcgc3BvdHRlZFxcbiAgICAgICAgd2hpbGUgKGNvbnRleHQpIHtcXG4gICAgICAgICAgaWYgKGNvbnRleHQudGFnTmFtZSA9PSB0YWdBZnRlclsyXSkge1xcbiAgICAgICAgICAgIGNvbnRleHQgPSBjb250ZXh0LnByZXY7XFxuICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgIH0gZWxzZSBpZiAoY29uZmlnLmltcGxpY2l0bHlDbG9zZWQuaGFzT3duUHJvcGVydHkoY29udGV4dC50YWdOYW1lKSkge1xcbiAgICAgICAgICAgIGNvbnRleHQgPSBjb250ZXh0LnByZXY7XFxuICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICB9IGVsc2UgaWYgKHRhZ0FmdGVyKSB7IC8vIE9wZW5pbmcgdGFnIHNwb3R0ZWRcXG4gICAgICAgIHdoaWxlIChjb250ZXh0KSB7XFxuICAgICAgICAgIHZhciBncmFiYmVycyA9IGNvbmZpZy5jb250ZXh0R3JhYmJlcnNbY29udGV4dC50YWdOYW1lXTtcXG4gICAgICAgICAgaWYgKGdyYWJiZXJzICYmIGdyYWJiZXJzLmhhc093blByb3BlcnR5KHRhZ0FmdGVyWzJdKSlcXG4gICAgICAgICAgICBjb250ZXh0ID0gY29udGV4dC5wcmV2O1xcbiAgICAgICAgICBlbHNlXFxuICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICAgIHdoaWxlIChjb250ZXh0ICYmIGNvbnRleHQucHJldiAmJiAhY29udGV4dC5zdGFydE9mTGluZSlcXG4gICAgICAgIGNvbnRleHQgPSBjb250ZXh0LnByZXY7XFxuICAgICAgaWYgKGNvbnRleHQpIHJldHVybiBjb250ZXh0LmluZGVudCArIGluZGVudFVuaXQ7XFxuICAgICAgZWxzZSByZXR1cm4gc3RhdGUuYmFzZUluZGVudCB8fCAwO1xcbiAgICB9LFxcblxcbiAgICBlbGVjdHJpY0lucHV0OiAvPFxcXFwvW1xcXFxzXFxcXHc6XSs+JC8sXFxuICAgIGJsb2NrQ29tbWVudFN0YXJ0OiBcXFwiPCEtLVxcXCIsXFxuICAgIGJsb2NrQ29tbWVudEVuZDogXFxcIi0tPlxcXCIsXFxuXFxuICAgIGNvbmZpZ3VyYXRpb246IGNvbmZpZy5odG1sTW9kZSA/IFxcXCJodG1sXFxcIiA6IFxcXCJ4bWxcXFwiLFxcbiAgICBoZWxwZXJUeXBlOiBjb25maWcuaHRtbE1vZGUgPyBcXFwiaHRtbFxcXCIgOiBcXFwieG1sXFxcIixcXG5cXG4gICAgc2tpcEF0dHJpYnV0ZTogZnVuY3Rpb24oc3RhdGUpIHtcXG4gICAgICBpZiAoc3RhdGUuc3RhdGUgPT0gYXR0clZhbHVlU3RhdGUpXFxuICAgICAgICBzdGF0ZS5zdGF0ZSA9IGF0dHJTdGF0ZVxcbiAgICB9XFxuICB9O1xcbn0pO1xcblxcbkNvZGVNaXJyb3IuZGVmaW5lTUlNRShcXFwidGV4dC94bWxcXFwiLCBcXFwieG1sXFxcIik7XFxuQ29kZU1pcnJvci5kZWZpbmVNSU1FKFxcXCJhcHBsaWNhdGlvbi94bWxcXFwiLCBcXFwieG1sXFxcIik7XFxuaWYgKCFDb2RlTWlycm9yLm1pbWVNb2Rlcy5oYXNPd25Qcm9wZXJ0eShcXFwidGV4dC9odG1sXFxcIikpXFxuICBDb2RlTWlycm9yLmRlZmluZU1JTUUoXFxcInRleHQvaHRtbFxcXCIsIHtuYW1lOiBcXFwieG1sXFxcIiwgaHRtbE1vZGU6IHRydWV9KTtcXG5cXG59KTtcXG5cIlxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3Jhdy1sb2FkZXIhLi9+L2NvZGVtaXJyb3IvbW9kZS94bWwveG1sLmpzXG4gKiogbW9kdWxlIGlkID0gN1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIl0sIm1hcHBpbmdzIjoiQUFBQSIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	eval("__webpack_require__(2)(__webpack_require__(9))//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL34vZnJvYWxhLWVkaXRvci9qcy9wbHVnaW5zL2FsaWduLm1pbi5qcz9jYzMxIl0sInNvdXJjZXNDb250ZW50IjpbInJlcXVpcmUoXCIhIS92YXIvYXBwL3dlYi9qcy9ub2RlX21vZHVsZXMvc2NyaXB0LWxvYWRlci9hZGRTY3JpcHQuanNcIikocmVxdWlyZShcIiEhL3Zhci9hcHAvd2ViL2pzL25vZGVfbW9kdWxlcy9yYXctbG9hZGVyL2luZGV4LmpzIS92YXIvYXBwL3dlYi9qcy9ub2RlX21vZHVsZXMvZnJvYWxhLWVkaXRvci9qcy9wbHVnaW5zL2FsaWduLm1pbi5qc1wiKSlcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9zY3JpcHQtbG9hZGVyIS4vfi9mcm9hbGEtZWRpdG9yL2pzL3BsdWdpbnMvYWxpZ24ubWluLmpzXG4gKiogbW9kdWxlIGlkID0gOFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIl0sIm1hcHBpbmdzIjoiQUFBQSIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 9 */
/***/ function(module, exports) {

	eval("module.exports = \"/*!\\n * froala_editor v2.3.4 (https://www.froala.com/wysiwyg-editor)\\n * License https://froala.com/wysiwyg-editor/terms/\\n * Copyright 2014-2016 Froala Labs\\n */\\n\\n!function(a){\\\"function\\\"==typeof define&&define.amd?define([\\\"jquery\\\"],a):\\\"object\\\"==typeof module&&module.exports?module.exports=function(b,c){return void 0===c&&(c=\\\"undefined\\\"!=typeof window?require(\\\"jquery\\\"):require(\\\"jquery\\\")(b)),a(c),c}:a(jQuery)}(function(a){\\\"use strict\\\";a.FE.PLUGINS.align=function(b){function c(c){b.selection.save(),b.html.wrap(!0,!0,!0,!0),b.selection.restore();for(var d=b.selection.blocks(),e=0;e<d.length;e++)a(d[e]).css(\\\"text-align\\\",c).removeClass(\\\"fr-temp-div\\\"),\\\"\\\"===a(d[e]).attr(\\\"class\\\")&&a(d[e]).removeAttr(\\\"class\\\");b.selection.save(),b.html.unwrap(),b.selection.restore()}function d(c){var d=b.selection.blocks();if(d.length){var e=b.helpers.getAlignment(a(d[0]));c.find(\\\"> *:first\\\").replaceWith(b.icon.create(\\\"align-\\\"+e))}}function e(c,d){var e=b.selection.blocks();if(e.length){var f=b.helpers.getAlignment(a(e[0]));d.find('a.fr-command[data-param1=\\\"'+f+'\\\"]').addClass(\\\"fr-active\\\")}}return{apply:c,refresh:d,refreshOnShow:e}},a.FE.DefineIcon(\\\"align\\\",{NAME:\\\"align-left\\\"}),a.FE.DefineIcon(\\\"align-left\\\",{NAME:\\\"align-left\\\"}),a.FE.DefineIcon(\\\"align-right\\\",{NAME:\\\"align-right\\\"}),a.FE.DefineIcon(\\\"align-center\\\",{NAME:\\\"align-center\\\"}),a.FE.DefineIcon(\\\"align-justify\\\",{NAME:\\\"align-justify\\\"}),a.FE.RegisterCommand(\\\"align\\\",{type:\\\"dropdown\\\",title:\\\"Align\\\",options:{left:\\\"Align Left\\\",center:\\\"Align Center\\\",right:\\\"Align Right\\\",justify:\\\"Align Justify\\\"},html:function(){var b='<ul class=\\\"fr-dropdown-list\\\">',c=a.FE.COMMANDS.align.options;for(var d in c)c.hasOwnProperty(d)&&(b+='<li><a class=\\\"fr-command fr-title\\\" data-cmd=\\\"align\\\" data-param1=\\\"'+d+'\\\" title=\\\"'+this.language.translate(c[d])+'\\\">'+this.icon.create(\\\"align-\\\"+d)+\\\"</a></li>\\\");return b+=\\\"</ul>\\\"},callback:function(a,b){this.align.apply(b)},refresh:function(a){this.align.refresh(a)},refreshOnShow:function(a,b){this.align.refreshOnShow(a,b)},plugin:\\\"align\\\"})});\"//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL34vZnJvYWxhLWVkaXRvci9qcy9wbHVnaW5zL2FsaWduLm1pbi5qcz9iYmFkIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gXCIvKiFcXG4gKiBmcm9hbGFfZWRpdG9yIHYyLjMuNCAoaHR0cHM6Ly93d3cuZnJvYWxhLmNvbS93eXNpd3lnLWVkaXRvcilcXG4gKiBMaWNlbnNlIGh0dHBzOi8vZnJvYWxhLmNvbS93eXNpd3lnLWVkaXRvci90ZXJtcy9cXG4gKiBDb3B5cmlnaHQgMjAxNC0yMDE2IEZyb2FsYSBMYWJzXFxuICovXFxuXFxuIWZ1bmN0aW9uKGEpe1xcXCJmdW5jdGlvblxcXCI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQ/ZGVmaW5lKFtcXFwianF1ZXJ5XFxcIl0sYSk6XFxcIm9iamVjdFxcXCI9PXR5cGVvZiBtb2R1bGUmJm1vZHVsZS5leHBvcnRzP21vZHVsZS5leHBvcnRzPWZ1bmN0aW9uKGIsYyl7cmV0dXJuIHZvaWQgMD09PWMmJihjPVxcXCJ1bmRlZmluZWRcXFwiIT10eXBlb2Ygd2luZG93P3JlcXVpcmUoXFxcImpxdWVyeVxcXCIpOnJlcXVpcmUoXFxcImpxdWVyeVxcXCIpKGIpKSxhKGMpLGN9OmEoalF1ZXJ5KX0oZnVuY3Rpb24oYSl7XFxcInVzZSBzdHJpY3RcXFwiO2EuRkUuUExVR0lOUy5hbGlnbj1mdW5jdGlvbihiKXtmdW5jdGlvbiBjKGMpe2Iuc2VsZWN0aW9uLnNhdmUoKSxiLmh0bWwud3JhcCghMCwhMCwhMCwhMCksYi5zZWxlY3Rpb24ucmVzdG9yZSgpO2Zvcih2YXIgZD1iLnNlbGVjdGlvbi5ibG9ja3MoKSxlPTA7ZTxkLmxlbmd0aDtlKyspYShkW2VdKS5jc3MoXFxcInRleHQtYWxpZ25cXFwiLGMpLnJlbW92ZUNsYXNzKFxcXCJmci10ZW1wLWRpdlxcXCIpLFxcXCJcXFwiPT09YShkW2VdKS5hdHRyKFxcXCJjbGFzc1xcXCIpJiZhKGRbZV0pLnJlbW92ZUF0dHIoXFxcImNsYXNzXFxcIik7Yi5zZWxlY3Rpb24uc2F2ZSgpLGIuaHRtbC51bndyYXAoKSxiLnNlbGVjdGlvbi5yZXN0b3JlKCl9ZnVuY3Rpb24gZChjKXt2YXIgZD1iLnNlbGVjdGlvbi5ibG9ja3MoKTtpZihkLmxlbmd0aCl7dmFyIGU9Yi5oZWxwZXJzLmdldEFsaWdubWVudChhKGRbMF0pKTtjLmZpbmQoXFxcIj4gKjpmaXJzdFxcXCIpLnJlcGxhY2VXaXRoKGIuaWNvbi5jcmVhdGUoXFxcImFsaWduLVxcXCIrZSkpfX1mdW5jdGlvbiBlKGMsZCl7dmFyIGU9Yi5zZWxlY3Rpb24uYmxvY2tzKCk7aWYoZS5sZW5ndGgpe3ZhciBmPWIuaGVscGVycy5nZXRBbGlnbm1lbnQoYShlWzBdKSk7ZC5maW5kKCdhLmZyLWNvbW1hbmRbZGF0YS1wYXJhbTE9XFxcIicrZisnXFxcIl0nKS5hZGRDbGFzcyhcXFwiZnItYWN0aXZlXFxcIil9fXJldHVybnthcHBseTpjLHJlZnJlc2g6ZCxyZWZyZXNoT25TaG93OmV9fSxhLkZFLkRlZmluZUljb24oXFxcImFsaWduXFxcIix7TkFNRTpcXFwiYWxpZ24tbGVmdFxcXCJ9KSxhLkZFLkRlZmluZUljb24oXFxcImFsaWduLWxlZnRcXFwiLHtOQU1FOlxcXCJhbGlnbi1sZWZ0XFxcIn0pLGEuRkUuRGVmaW5lSWNvbihcXFwiYWxpZ24tcmlnaHRcXFwiLHtOQU1FOlxcXCJhbGlnbi1yaWdodFxcXCJ9KSxhLkZFLkRlZmluZUljb24oXFxcImFsaWduLWNlbnRlclxcXCIse05BTUU6XFxcImFsaWduLWNlbnRlclxcXCJ9KSxhLkZFLkRlZmluZUljb24oXFxcImFsaWduLWp1c3RpZnlcXFwiLHtOQU1FOlxcXCJhbGlnbi1qdXN0aWZ5XFxcIn0pLGEuRkUuUmVnaXN0ZXJDb21tYW5kKFxcXCJhbGlnblxcXCIse3R5cGU6XFxcImRyb3Bkb3duXFxcIix0aXRsZTpcXFwiQWxpZ25cXFwiLG9wdGlvbnM6e2xlZnQ6XFxcIkFsaWduIExlZnRcXFwiLGNlbnRlcjpcXFwiQWxpZ24gQ2VudGVyXFxcIixyaWdodDpcXFwiQWxpZ24gUmlnaHRcXFwiLGp1c3RpZnk6XFxcIkFsaWduIEp1c3RpZnlcXFwifSxodG1sOmZ1bmN0aW9uKCl7dmFyIGI9Jzx1bCBjbGFzcz1cXFwiZnItZHJvcGRvd24tbGlzdFxcXCI+JyxjPWEuRkUuQ09NTUFORFMuYWxpZ24ub3B0aW9ucztmb3IodmFyIGQgaW4gYyljLmhhc093blByb3BlcnR5KGQpJiYoYis9JzxsaT48YSBjbGFzcz1cXFwiZnItY29tbWFuZCBmci10aXRsZVxcXCIgZGF0YS1jbWQ9XFxcImFsaWduXFxcIiBkYXRhLXBhcmFtMT1cXFwiJytkKydcXFwiIHRpdGxlPVxcXCInK3RoaXMubGFuZ3VhZ2UudHJhbnNsYXRlKGNbZF0pKydcXFwiPicrdGhpcy5pY29uLmNyZWF0ZShcXFwiYWxpZ24tXFxcIitkKStcXFwiPC9hPjwvbGk+XFxcIik7cmV0dXJuIGIrPVxcXCI8L3VsPlxcXCJ9LGNhbGxiYWNrOmZ1bmN0aW9uKGEsYil7dGhpcy5hbGlnbi5hcHBseShiKX0scmVmcmVzaDpmdW5jdGlvbihhKXt0aGlzLmFsaWduLnJlZnJlc2goYSl9LHJlZnJlc2hPblNob3c6ZnVuY3Rpb24oYSxiKXt0aGlzLmFsaWduLnJlZnJlc2hPblNob3coYSxiKX0scGx1Z2luOlxcXCJhbGlnblxcXCJ9KX0pO1wiXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmF3LWxvYWRlciEuL34vZnJvYWxhLWVkaXRvci9qcy9wbHVnaW5zL2FsaWduLm1pbi5qc1xuICoqIG1vZHVsZSBpZCA9IDlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	eval("__webpack_require__(2)(__webpack_require__(11))//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTAuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2Zyb2FsYS1lZGl0b3IvanMvcGx1Z2lucy9jaGFyX2NvdW50ZXIubWluLmpzPzc3YjEiXSwic291cmNlc0NvbnRlbnQiOlsicmVxdWlyZShcIiEhL3Zhci9hcHAvd2ViL2pzL25vZGVfbW9kdWxlcy9zY3JpcHQtbG9hZGVyL2FkZFNjcmlwdC5qc1wiKShyZXF1aXJlKFwiISEvdmFyL2FwcC93ZWIvanMvbm9kZV9tb2R1bGVzL3Jhdy1sb2FkZXIvaW5kZXguanMhL3Zhci9hcHAvd2ViL2pzL25vZGVfbW9kdWxlcy9mcm9hbGEtZWRpdG9yL2pzL3BsdWdpbnMvY2hhcl9jb3VudGVyLm1pbi5qc1wiKSlcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9zY3JpcHQtbG9hZGVyIS4vfi9mcm9hbGEtZWRpdG9yL2pzL3BsdWdpbnMvY2hhcl9jb3VudGVyLm1pbi5qc1xuICoqIG1vZHVsZSBpZCA9IDEwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 11 */
/***/ function(module, exports) {

	eval("module.exports = \"/*!\\n * froala_editor v2.3.4 (https://www.froala.com/wysiwyg-editor)\\n * License https://froala.com/wysiwyg-editor/terms/\\n * Copyright 2014-2016 Froala Labs\\n */\\n\\n!function(a){\\\"function\\\"==typeof define&&define.amd?define([\\\"jquery\\\"],a):\\\"object\\\"==typeof module&&module.exports?module.exports=function(b,c){return void 0===c&&(c=\\\"undefined\\\"!=typeof window?require(\\\"jquery\\\"):require(\\\"jquery\\\")(b)),a(c),c}:a(jQuery)}(function(a){\\\"use strict\\\";a.extend(a.FE.DEFAULTS,{charCounterMax:-1,charCounterCount:!0}),a.FE.PLUGINS.charCounter=function(b){function c(){return b.$el.text().length}function d(a){if(b.opts.charCounterMax<0)return!0;if(c()<b.opts.charCounterMax)return!0;var d=a.which;return!b.keys.ctrlKey(a)&&b.keys.isCharacter(d)?(a.preventDefault(),a.stopPropagation(),b.events.trigger(\\\"charCounter.exceeded\\\"),!1):!0}function e(d){if(b.opts.charCounterMax<0)return d;var e=a(\\\"<div>\\\").html(d).text().length;return e+c()<=b.opts.charCounterMax?d:(b.events.trigger(\\\"charCounter.exceeded\\\"),\\\"\\\")}function f(){if(b.opts.charCounterCount){var a=c()+(b.opts.charCounterMax>0?\\\"/\\\"+b.opts.charCounterMax:\\\"\\\");h.text(a),b.opts.toolbarBottom&&h.css(\\\"margin-bottom\\\",b.$tb.outerHeight(!0));var d=b.$wp.get(0).offsetWidth-b.$wp.get(0).clientWidth;d>=0&&(\\\"rtl\\\"==b.opts.direction?h.css(\\\"margin-left\\\",d):h.css(\\\"margin-right\\\",d))}}function g(){return b.$wp&&b.opts.charCounterCount?(h=a('<span class=\\\"fr-counter\\\"></span>'),h.css(\\\"bottom\\\",b.$wp.css(\\\"border-bottom-width\\\")),b.$box.append(h),b.events.on(\\\"keydown\\\",d,!0),b.events.on(\\\"paste.afterCleanup\\\",e),b.events.on(\\\"keyup contentChanged\\\",function(){b.events.trigger(\\\"charCounter.update\\\")}),b.events.on(\\\"charCounter.update\\\",f),b.events.trigger(\\\"charCounter.update\\\"),void b.events.on(\\\"destroy\\\",function(){a(b.o_win).off(\\\"resize.char\\\"+b.id),h.removeData().remove(),h=null})):!1}var h;return{_init:g,count:c}}});\"//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTEuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2Zyb2FsYS1lZGl0b3IvanMvcGx1Z2lucy9jaGFyX2NvdW50ZXIubWluLmpzPzUwMWQiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBcIi8qIVxcbiAqIGZyb2FsYV9lZGl0b3IgdjIuMy40IChodHRwczovL3d3dy5mcm9hbGEuY29tL3d5c2l3eWctZWRpdG9yKVxcbiAqIExpY2Vuc2UgaHR0cHM6Ly9mcm9hbGEuY29tL3d5c2l3eWctZWRpdG9yL3Rlcm1zL1xcbiAqIENvcHlyaWdodCAyMDE0LTIwMTYgRnJvYWxhIExhYnNcXG4gKi9cXG5cXG4hZnVuY3Rpb24oYSl7XFxcImZ1bmN0aW9uXFxcIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUoW1xcXCJqcXVlcnlcXFwiXSxhKTpcXFwib2JqZWN0XFxcIj09dHlwZW9mIG1vZHVsZSYmbW9kdWxlLmV4cG9ydHM/bW9kdWxlLmV4cG9ydHM9ZnVuY3Rpb24oYixjKXtyZXR1cm4gdm9pZCAwPT09YyYmKGM9XFxcInVuZGVmaW5lZFxcXCIhPXR5cGVvZiB3aW5kb3c/cmVxdWlyZShcXFwianF1ZXJ5XFxcIik6cmVxdWlyZShcXFwianF1ZXJ5XFxcIikoYikpLGEoYyksY306YShqUXVlcnkpfShmdW5jdGlvbihhKXtcXFwidXNlIHN0cmljdFxcXCI7YS5leHRlbmQoYS5GRS5ERUZBVUxUUyx7Y2hhckNvdW50ZXJNYXg6LTEsY2hhckNvdW50ZXJDb3VudDohMH0pLGEuRkUuUExVR0lOUy5jaGFyQ291bnRlcj1mdW5jdGlvbihiKXtmdW5jdGlvbiBjKCl7cmV0dXJuIGIuJGVsLnRleHQoKS5sZW5ndGh9ZnVuY3Rpb24gZChhKXtpZihiLm9wdHMuY2hhckNvdW50ZXJNYXg8MClyZXR1cm4hMDtpZihjKCk8Yi5vcHRzLmNoYXJDb3VudGVyTWF4KXJldHVybiEwO3ZhciBkPWEud2hpY2g7cmV0dXJuIWIua2V5cy5jdHJsS2V5KGEpJiZiLmtleXMuaXNDaGFyYWN0ZXIoZCk/KGEucHJldmVudERlZmF1bHQoKSxhLnN0b3BQcm9wYWdhdGlvbigpLGIuZXZlbnRzLnRyaWdnZXIoXFxcImNoYXJDb3VudGVyLmV4Y2VlZGVkXFxcIiksITEpOiEwfWZ1bmN0aW9uIGUoZCl7aWYoYi5vcHRzLmNoYXJDb3VudGVyTWF4PDApcmV0dXJuIGQ7dmFyIGU9YShcXFwiPGRpdj5cXFwiKS5odG1sKGQpLnRleHQoKS5sZW5ndGg7cmV0dXJuIGUrYygpPD1iLm9wdHMuY2hhckNvdW50ZXJNYXg/ZDooYi5ldmVudHMudHJpZ2dlcihcXFwiY2hhckNvdW50ZXIuZXhjZWVkZWRcXFwiKSxcXFwiXFxcIil9ZnVuY3Rpb24gZigpe2lmKGIub3B0cy5jaGFyQ291bnRlckNvdW50KXt2YXIgYT1jKCkrKGIub3B0cy5jaGFyQ291bnRlck1heD4wP1xcXCIvXFxcIitiLm9wdHMuY2hhckNvdW50ZXJNYXg6XFxcIlxcXCIpO2gudGV4dChhKSxiLm9wdHMudG9vbGJhckJvdHRvbSYmaC5jc3MoXFxcIm1hcmdpbi1ib3R0b21cXFwiLGIuJHRiLm91dGVySGVpZ2h0KCEwKSk7dmFyIGQ9Yi4kd3AuZ2V0KDApLm9mZnNldFdpZHRoLWIuJHdwLmdldCgwKS5jbGllbnRXaWR0aDtkPj0wJiYoXFxcInJ0bFxcXCI9PWIub3B0cy5kaXJlY3Rpb24/aC5jc3MoXFxcIm1hcmdpbi1sZWZ0XFxcIixkKTpoLmNzcyhcXFwibWFyZ2luLXJpZ2h0XFxcIixkKSl9fWZ1bmN0aW9uIGcoKXtyZXR1cm4gYi4kd3AmJmIub3B0cy5jaGFyQ291bnRlckNvdW50PyhoPWEoJzxzcGFuIGNsYXNzPVxcXCJmci1jb3VudGVyXFxcIj48L3NwYW4+JyksaC5jc3MoXFxcImJvdHRvbVxcXCIsYi4kd3AuY3NzKFxcXCJib3JkZXItYm90dG9tLXdpZHRoXFxcIikpLGIuJGJveC5hcHBlbmQoaCksYi5ldmVudHMub24oXFxcImtleWRvd25cXFwiLGQsITApLGIuZXZlbnRzLm9uKFxcXCJwYXN0ZS5hZnRlckNsZWFudXBcXFwiLGUpLGIuZXZlbnRzLm9uKFxcXCJrZXl1cCBjb250ZW50Q2hhbmdlZFxcXCIsZnVuY3Rpb24oKXtiLmV2ZW50cy50cmlnZ2VyKFxcXCJjaGFyQ291bnRlci51cGRhdGVcXFwiKX0pLGIuZXZlbnRzLm9uKFxcXCJjaGFyQ291bnRlci51cGRhdGVcXFwiLGYpLGIuZXZlbnRzLnRyaWdnZXIoXFxcImNoYXJDb3VudGVyLnVwZGF0ZVxcXCIpLHZvaWQgYi5ldmVudHMub24oXFxcImRlc3Ryb3lcXFwiLGZ1bmN0aW9uKCl7YShiLm9fd2luKS5vZmYoXFxcInJlc2l6ZS5jaGFyXFxcIitiLmlkKSxoLnJlbW92ZURhdGEoKS5yZW1vdmUoKSxoPW51bGx9KSk6ITF9dmFyIGg7cmV0dXJue19pbml0OmcsY291bnQ6Y319fSk7XCJcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yYXctbG9hZGVyIS4vfi9mcm9hbGEtZWRpdG9yL2pzL3BsdWdpbnMvY2hhcl9jb3VudGVyLm1pbi5qc1xuICoqIG1vZHVsZSBpZCA9IDExXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	eval("__webpack_require__(2)(__webpack_require__(13))//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTIuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2Zyb2FsYS1lZGl0b3IvanMvcGx1Z2lucy9jb2RlX3ZpZXcubWluLmpzPzljNWIiXSwic291cmNlc0NvbnRlbnQiOlsicmVxdWlyZShcIiEhL3Zhci9hcHAvd2ViL2pzL25vZGVfbW9kdWxlcy9zY3JpcHQtbG9hZGVyL2FkZFNjcmlwdC5qc1wiKShyZXF1aXJlKFwiISEvdmFyL2FwcC93ZWIvanMvbm9kZV9tb2R1bGVzL3Jhdy1sb2FkZXIvaW5kZXguanMhL3Zhci9hcHAvd2ViL2pzL25vZGVfbW9kdWxlcy9mcm9hbGEtZWRpdG9yL2pzL3BsdWdpbnMvY29kZV92aWV3Lm1pbi5qc1wiKSlcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9zY3JpcHQtbG9hZGVyIS4vfi9mcm9hbGEtZWRpdG9yL2pzL3BsdWdpbnMvY29kZV92aWV3Lm1pbi5qc1xuICoqIG1vZHVsZSBpZCA9IDEyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 13 */
/***/ function(module, exports) {

	eval("module.exports = \"/*!\\n * froala_editor v2.3.4 (https://www.froala.com/wysiwyg-editor)\\n * License https://froala.com/wysiwyg-editor/terms/\\n * Copyright 2014-2016 Froala Labs\\n */\\n\\n!function(a){\\\"function\\\"==typeof define&&define.amd?define([\\\"jquery\\\"],a):\\\"object\\\"==typeof module&&module.exports?module.exports=function(b,c){return void 0===c&&(c=\\\"undefined\\\"!=typeof window?require(\\\"jquery\\\"):require(\\\"jquery\\\")(b)),a(c),c}:a(jQuery)}(function(a){\\\"use strict\\\";a.extend(a.FE.DEFAULTS,{codeMirror:!0,codeMirrorOptions:{lineNumbers:!0,tabMode:\\\"indent\\\",indentWithTabs:!0,lineWrapping:!0,mode:\\\"text/html\\\",tabSize:2},codeBeautifierOptions:{end_with_newline:!0,indent_inner_html:!0,extra_liners:[\\\"p\\\",\\\"h1\\\",\\\"h2\\\",\\\"h3\\\",\\\"h4\\\",\\\"h5\\\",\\\"h6\\\",\\\"blockquote\\\",\\\"pre\\\",\\\"ul\\\",\\\"ol\\\",\\\"table\\\",\\\"dl\\\"],brace_style:\\\"expand\\\",indent_char:\\\"\\t\\\",indent_size:1,wrap_line_length:0}}),a.FE.PLUGINS.codeView=function(b){function c(){return b.$box.hasClass(\\\"fr-code-view\\\")}function d(){return l?l.getValue():k.val()}function e(a){var c=d();b.html.set(c),b.$el.blur(),b.$tb.find(\\\" > .fr-command\\\").not(a).removeClass(\\\"fr-disabled\\\"),a.removeClass(\\\"fr-active\\\"),b.events.focus(!0),b.placeholder.refresh(),b.undo.saveStep()}function f(c){k||(i(),!l&&b.opts.codeMirror&&\\\"undefined\\\"!=typeof CodeMirror?l=CodeMirror.fromTextArea(k.get(0),b.opts.codeMirrorOptions):b.events.$on(k,\\\"keydown keyup change input\\\",function(){if(b.opts.height)this.rows=null;else if(this.rows||(this.rows=1),0===this.value.length)this.rows=1;else{for(this.style.height=\\\"auto\\\";this.rows>1&&this.scrollHeight<=this.offsetHeight;)this.rows-=1;for(;this.scrollHeight>this.offsetHeight&&(!b.opts.heightMax||this.offsetHeight<b.opts.heightMax);)this.rows+=1}})),b.undo.saveStep(),b.html.cleanEmptyTags(),b.html.cleanWhiteTags(!0),b.core.hasFocus()&&(b.core.isEmpty()||(b.selection.save(),b.$el.find('.fr-marker[data-type=\\\"true\\\"]:first').replaceWith('<span class=\\\"fr-tmp fr-sm\\\">F</span>'),b.$el.find('.fr-marker[data-type=\\\"false\\\"]:last').replaceWith('<span class=\\\"fr-tmp fr-em\\\">F</span>')));var d=b.html.get(!1,!0);b.$el.find(\\\"span.fr-tmp\\\").remove(),b.core.hasFocus()&&b.$el.blur(),d=d.replace(/<span class=\\\"fr-tmp fr-sm\\\">F<\\\\/span>/,\\\"FROALA-SM\\\"),d=d.replace(/<span class=\\\"fr-tmp fr-em\\\">F<\\\\/span>/,\\\"FROALA-EM\\\"),b.codeBeautifier&&(d=b.codeBeautifier.run(d,b.opts.codeBeautifierOptions));var e,f;if(l){e=d.indexOf(\\\"FROALA-SM\\\"),f=d.indexOf(\\\"FROALA-EM\\\"),e>f?e=f:f-=9,d=d.replace(/FROALA-SM/g,\\\"\\\").replace(/FROALA-EM/g,\\\"\\\");var g=d.substring(0,e).length-d.substring(0,e).replace(/\\\\n/g,\\\"\\\").length,h=d.substring(0,f).length-d.substring(0,f).replace(/\\\\n/g,\\\"\\\").length;e=d.substring(0,e).length-d.substring(0,d.substring(0,e).lastIndexOf(\\\"\\\\n\\\")+1).length,f=d.substring(0,f).length-d.substring(0,d.substring(0,f).lastIndexOf(\\\"\\\\n\\\")+1).length,l.setSize(null,b.opts.height?b.opts.height:\\\"auto\\\"),b.opts.heightMin&&b.$box.find(\\\".CodeMirror-scroll\\\").css(\\\"min-height\\\",b.opts.heightMin),l.setValue(d),l.focus(),l.setSelection({line:g,ch:e},{line:h,ch:f}),l.refresh(),l.clearHistory()}else{e=d.indexOf(\\\"FROALA-SM\\\"),f=d.indexOf(\\\"FROALA-EM\\\")-9,b.opts.heightMin&&k.css(\\\"min-height\\\",b.opts.heightMin),b.opts.height&&k.css(\\\"height\\\",b.opts.height),b.opts.heightMax&&k.css(\\\"max-height\\\",b.opts.height||b.opts.heightMax),k.val(d.replace(/FROALA-SM/g,\\\"\\\").replace(/FROALA-EM/g,\\\"\\\")).trigger(\\\"change\\\");var j=a(b.o_doc).scrollTop();k.focus(),k.get(0).setSelectionRange(e,f),a(b.o_doc).scrollTop(j)}b.$tb.find(\\\" > .fr-command\\\").not(c).addClass(\\\"fr-disabled\\\"),c.addClass(\\\"fr-active\\\"),!b.helpers.isMobile()&&b.opts.toolbarInline&&b.toolbar.hide()}function g(a){\\\"undefined\\\"==typeof a&&(a=!c());var d=b.$tb.find('.fr-command[data-cmd=\\\"html\\\"]');a?(b.popups.hideAll(),b.$box.toggleClass(\\\"fr-code-view\\\",!0),f(d)):(b.$box.toggleClass(\\\"fr-code-view\\\",!1),e(d))}function h(){c()&&g(b.$tb.find('button[data-cmd=\\\"html\\\"]')),l&&l.toTextArea(),k.val(\\\"\\\").removeData().remove(),k=null,m&&(m.remove(),m=null)}function i(){k=a('<textarea class=\\\"fr-code\\\" tabindex=\\\"-1\\\">'),b.$wp.append(k),k.attr(\\\"dir\\\",b.opts.direction),b.$box.hasClass(\\\"fr-basic\\\")||(m=a('<a data-cmd=\\\"html\\\" title=\\\"Code View\\\" class=\\\"fr-command fr-btn html-switch'+(b.helpers.isMobile()?\\\"\\\":\\\" fr-desktop\\\")+'\\\" role=\\\"button\\\" tabindex=\\\"-1\\\"><i class=\\\"fa fa-code\\\"></i></button>'),b.$box.append(m),b.events.bindClick(b.$box,\\\"a.html-switch\\\",function(){g(!1)}));var e=function(){return!c()};b.events.on(\\\"buttons.refresh\\\",e),b.events.on(\\\"copy\\\",e,!0),b.events.on(\\\"cut\\\",e,!0),b.events.on(\\\"paste\\\",e,!0),b.events.on(\\\"destroy\\\",h,!0),b.events.on(\\\"html.set\\\",function(){c()&&g(!0)}),b.events.on(\\\"form.submit\\\",function(){c()&&(b.html.set(d()),b.events.trigger(\\\"contentChanged\\\",[],!0))},!0)}function j(){return b.$wp?void 0:!1}var k,l,m;return{_init:j,toggle:g,isActive:c,get:d}},a.FE.RegisterCommand(\\\"html\\\",{title:\\\"Code View\\\",undo:!1,focus:!1,forcedRefresh:!0,callback:function(){this.codeView.toggle()},plugin:\\\"codeView\\\"}),a.FE.DefineIcon(\\\"html\\\",{NAME:\\\"code\\\"})});\"//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2Zyb2FsYS1lZGl0b3IvanMvcGx1Z2lucy9jb2RlX3ZpZXcubWluLmpzPzg0ZjMiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBcIi8qIVxcbiAqIGZyb2FsYV9lZGl0b3IgdjIuMy40IChodHRwczovL3d3dy5mcm9hbGEuY29tL3d5c2l3eWctZWRpdG9yKVxcbiAqIExpY2Vuc2UgaHR0cHM6Ly9mcm9hbGEuY29tL3d5c2l3eWctZWRpdG9yL3Rlcm1zL1xcbiAqIENvcHlyaWdodCAyMDE0LTIwMTYgRnJvYWxhIExhYnNcXG4gKi9cXG5cXG4hZnVuY3Rpb24oYSl7XFxcImZ1bmN0aW9uXFxcIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUoW1xcXCJqcXVlcnlcXFwiXSxhKTpcXFwib2JqZWN0XFxcIj09dHlwZW9mIG1vZHVsZSYmbW9kdWxlLmV4cG9ydHM/bW9kdWxlLmV4cG9ydHM9ZnVuY3Rpb24oYixjKXtyZXR1cm4gdm9pZCAwPT09YyYmKGM9XFxcInVuZGVmaW5lZFxcXCIhPXR5cGVvZiB3aW5kb3c/cmVxdWlyZShcXFwianF1ZXJ5XFxcIik6cmVxdWlyZShcXFwianF1ZXJ5XFxcIikoYikpLGEoYyksY306YShqUXVlcnkpfShmdW5jdGlvbihhKXtcXFwidXNlIHN0cmljdFxcXCI7YS5leHRlbmQoYS5GRS5ERUZBVUxUUyx7Y29kZU1pcnJvcjohMCxjb2RlTWlycm9yT3B0aW9uczp7bGluZU51bWJlcnM6ITAsdGFiTW9kZTpcXFwiaW5kZW50XFxcIixpbmRlbnRXaXRoVGFiczohMCxsaW5lV3JhcHBpbmc6ITAsbW9kZTpcXFwidGV4dC9odG1sXFxcIix0YWJTaXplOjJ9LGNvZGVCZWF1dGlmaWVyT3B0aW9uczp7ZW5kX3dpdGhfbmV3bGluZTohMCxpbmRlbnRfaW5uZXJfaHRtbDohMCxleHRyYV9saW5lcnM6W1xcXCJwXFxcIixcXFwiaDFcXFwiLFxcXCJoMlxcXCIsXFxcImgzXFxcIixcXFwiaDRcXFwiLFxcXCJoNVxcXCIsXFxcImg2XFxcIixcXFwiYmxvY2txdW90ZVxcXCIsXFxcInByZVxcXCIsXFxcInVsXFxcIixcXFwib2xcXFwiLFxcXCJ0YWJsZVxcXCIsXFxcImRsXFxcIl0sYnJhY2Vfc3R5bGU6XFxcImV4cGFuZFxcXCIsaW5kZW50X2NoYXI6XFxcIlxcdFxcXCIsaW5kZW50X3NpemU6MSx3cmFwX2xpbmVfbGVuZ3RoOjB9fSksYS5GRS5QTFVHSU5TLmNvZGVWaWV3PWZ1bmN0aW9uKGIpe2Z1bmN0aW9uIGMoKXtyZXR1cm4gYi4kYm94Lmhhc0NsYXNzKFxcXCJmci1jb2RlLXZpZXdcXFwiKX1mdW5jdGlvbiBkKCl7cmV0dXJuIGw/bC5nZXRWYWx1ZSgpOmsudmFsKCl9ZnVuY3Rpb24gZShhKXt2YXIgYz1kKCk7Yi5odG1sLnNldChjKSxiLiRlbC5ibHVyKCksYi4kdGIuZmluZChcXFwiID4gLmZyLWNvbW1hbmRcXFwiKS5ub3QoYSkucmVtb3ZlQ2xhc3MoXFxcImZyLWRpc2FibGVkXFxcIiksYS5yZW1vdmVDbGFzcyhcXFwiZnItYWN0aXZlXFxcIiksYi5ldmVudHMuZm9jdXMoITApLGIucGxhY2Vob2xkZXIucmVmcmVzaCgpLGIudW5kby5zYXZlU3RlcCgpfWZ1bmN0aW9uIGYoYyl7a3x8KGkoKSwhbCYmYi5vcHRzLmNvZGVNaXJyb3ImJlxcXCJ1bmRlZmluZWRcXFwiIT10eXBlb2YgQ29kZU1pcnJvcj9sPUNvZGVNaXJyb3IuZnJvbVRleHRBcmVhKGsuZ2V0KDApLGIub3B0cy5jb2RlTWlycm9yT3B0aW9ucyk6Yi5ldmVudHMuJG9uKGssXFxcImtleWRvd24ga2V5dXAgY2hhbmdlIGlucHV0XFxcIixmdW5jdGlvbigpe2lmKGIub3B0cy5oZWlnaHQpdGhpcy5yb3dzPW51bGw7ZWxzZSBpZih0aGlzLnJvd3N8fCh0aGlzLnJvd3M9MSksMD09PXRoaXMudmFsdWUubGVuZ3RoKXRoaXMucm93cz0xO2Vsc2V7Zm9yKHRoaXMuc3R5bGUuaGVpZ2h0PVxcXCJhdXRvXFxcIjt0aGlzLnJvd3M+MSYmdGhpcy5zY3JvbGxIZWlnaHQ8PXRoaXMub2Zmc2V0SGVpZ2h0Oyl0aGlzLnJvd3MtPTE7Zm9yKDt0aGlzLnNjcm9sbEhlaWdodD50aGlzLm9mZnNldEhlaWdodCYmKCFiLm9wdHMuaGVpZ2h0TWF4fHx0aGlzLm9mZnNldEhlaWdodDxiLm9wdHMuaGVpZ2h0TWF4KTspdGhpcy5yb3dzKz0xfX0pKSxiLnVuZG8uc2F2ZVN0ZXAoKSxiLmh0bWwuY2xlYW5FbXB0eVRhZ3MoKSxiLmh0bWwuY2xlYW5XaGl0ZVRhZ3MoITApLGIuY29yZS5oYXNGb2N1cygpJiYoYi5jb3JlLmlzRW1wdHkoKXx8KGIuc2VsZWN0aW9uLnNhdmUoKSxiLiRlbC5maW5kKCcuZnItbWFya2VyW2RhdGEtdHlwZT1cXFwidHJ1ZVxcXCJdOmZpcnN0JykucmVwbGFjZVdpdGgoJzxzcGFuIGNsYXNzPVxcXCJmci10bXAgZnItc21cXFwiPkY8L3NwYW4+JyksYi4kZWwuZmluZCgnLmZyLW1hcmtlcltkYXRhLXR5cGU9XFxcImZhbHNlXFxcIl06bGFzdCcpLnJlcGxhY2VXaXRoKCc8c3BhbiBjbGFzcz1cXFwiZnItdG1wIGZyLWVtXFxcIj5GPC9zcGFuPicpKSk7dmFyIGQ9Yi5odG1sLmdldCghMSwhMCk7Yi4kZWwuZmluZChcXFwic3Bhbi5mci10bXBcXFwiKS5yZW1vdmUoKSxiLmNvcmUuaGFzRm9jdXMoKSYmYi4kZWwuYmx1cigpLGQ9ZC5yZXBsYWNlKC88c3BhbiBjbGFzcz1cXFwiZnItdG1wIGZyLXNtXFxcIj5GPFxcXFwvc3Bhbj4vLFxcXCJGUk9BTEEtU01cXFwiKSxkPWQucmVwbGFjZSgvPHNwYW4gY2xhc3M9XFxcImZyLXRtcCBmci1lbVxcXCI+RjxcXFxcL3NwYW4+LyxcXFwiRlJPQUxBLUVNXFxcIiksYi5jb2RlQmVhdXRpZmllciYmKGQ9Yi5jb2RlQmVhdXRpZmllci5ydW4oZCxiLm9wdHMuY29kZUJlYXV0aWZpZXJPcHRpb25zKSk7dmFyIGUsZjtpZihsKXtlPWQuaW5kZXhPZihcXFwiRlJPQUxBLVNNXFxcIiksZj1kLmluZGV4T2YoXFxcIkZST0FMQS1FTVxcXCIpLGU+Zj9lPWY6Zi09OSxkPWQucmVwbGFjZSgvRlJPQUxBLVNNL2csXFxcIlxcXCIpLnJlcGxhY2UoL0ZST0FMQS1FTS9nLFxcXCJcXFwiKTt2YXIgZz1kLnN1YnN0cmluZygwLGUpLmxlbmd0aC1kLnN1YnN0cmluZygwLGUpLnJlcGxhY2UoL1xcXFxuL2csXFxcIlxcXCIpLmxlbmd0aCxoPWQuc3Vic3RyaW5nKDAsZikubGVuZ3RoLWQuc3Vic3RyaW5nKDAsZikucmVwbGFjZSgvXFxcXG4vZyxcXFwiXFxcIikubGVuZ3RoO2U9ZC5zdWJzdHJpbmcoMCxlKS5sZW5ndGgtZC5zdWJzdHJpbmcoMCxkLnN1YnN0cmluZygwLGUpLmxhc3RJbmRleE9mKFxcXCJcXFxcblxcXCIpKzEpLmxlbmd0aCxmPWQuc3Vic3RyaW5nKDAsZikubGVuZ3RoLWQuc3Vic3RyaW5nKDAsZC5zdWJzdHJpbmcoMCxmKS5sYXN0SW5kZXhPZihcXFwiXFxcXG5cXFwiKSsxKS5sZW5ndGgsbC5zZXRTaXplKG51bGwsYi5vcHRzLmhlaWdodD9iLm9wdHMuaGVpZ2h0OlxcXCJhdXRvXFxcIiksYi5vcHRzLmhlaWdodE1pbiYmYi4kYm94LmZpbmQoXFxcIi5Db2RlTWlycm9yLXNjcm9sbFxcXCIpLmNzcyhcXFwibWluLWhlaWdodFxcXCIsYi5vcHRzLmhlaWdodE1pbiksbC5zZXRWYWx1ZShkKSxsLmZvY3VzKCksbC5zZXRTZWxlY3Rpb24oe2xpbmU6ZyxjaDplfSx7bGluZTpoLGNoOmZ9KSxsLnJlZnJlc2goKSxsLmNsZWFySGlzdG9yeSgpfWVsc2V7ZT1kLmluZGV4T2YoXFxcIkZST0FMQS1TTVxcXCIpLGY9ZC5pbmRleE9mKFxcXCJGUk9BTEEtRU1cXFwiKS05LGIub3B0cy5oZWlnaHRNaW4mJmsuY3NzKFxcXCJtaW4taGVpZ2h0XFxcIixiLm9wdHMuaGVpZ2h0TWluKSxiLm9wdHMuaGVpZ2h0JiZrLmNzcyhcXFwiaGVpZ2h0XFxcIixiLm9wdHMuaGVpZ2h0KSxiLm9wdHMuaGVpZ2h0TWF4JiZrLmNzcyhcXFwibWF4LWhlaWdodFxcXCIsYi5vcHRzLmhlaWdodHx8Yi5vcHRzLmhlaWdodE1heCksay52YWwoZC5yZXBsYWNlKC9GUk9BTEEtU00vZyxcXFwiXFxcIikucmVwbGFjZSgvRlJPQUxBLUVNL2csXFxcIlxcXCIpKS50cmlnZ2VyKFxcXCJjaGFuZ2VcXFwiKTt2YXIgaj1hKGIub19kb2MpLnNjcm9sbFRvcCgpO2suZm9jdXMoKSxrLmdldCgwKS5zZXRTZWxlY3Rpb25SYW5nZShlLGYpLGEoYi5vX2RvYykuc2Nyb2xsVG9wKGopfWIuJHRiLmZpbmQoXFxcIiA+IC5mci1jb21tYW5kXFxcIikubm90KGMpLmFkZENsYXNzKFxcXCJmci1kaXNhYmxlZFxcXCIpLGMuYWRkQ2xhc3MoXFxcImZyLWFjdGl2ZVxcXCIpLCFiLmhlbHBlcnMuaXNNb2JpbGUoKSYmYi5vcHRzLnRvb2xiYXJJbmxpbmUmJmIudG9vbGJhci5oaWRlKCl9ZnVuY3Rpb24gZyhhKXtcXFwidW5kZWZpbmVkXFxcIj09dHlwZW9mIGEmJihhPSFjKCkpO3ZhciBkPWIuJHRiLmZpbmQoJy5mci1jb21tYW5kW2RhdGEtY21kPVxcXCJodG1sXFxcIl0nKTthPyhiLnBvcHVwcy5oaWRlQWxsKCksYi4kYm94LnRvZ2dsZUNsYXNzKFxcXCJmci1jb2RlLXZpZXdcXFwiLCEwKSxmKGQpKTooYi4kYm94LnRvZ2dsZUNsYXNzKFxcXCJmci1jb2RlLXZpZXdcXFwiLCExKSxlKGQpKX1mdW5jdGlvbiBoKCl7YygpJiZnKGIuJHRiLmZpbmQoJ2J1dHRvbltkYXRhLWNtZD1cXFwiaHRtbFxcXCJdJykpLGwmJmwudG9UZXh0QXJlYSgpLGsudmFsKFxcXCJcXFwiKS5yZW1vdmVEYXRhKCkucmVtb3ZlKCksaz1udWxsLG0mJihtLnJlbW92ZSgpLG09bnVsbCl9ZnVuY3Rpb24gaSgpe2s9YSgnPHRleHRhcmVhIGNsYXNzPVxcXCJmci1jb2RlXFxcIiB0YWJpbmRleD1cXFwiLTFcXFwiPicpLGIuJHdwLmFwcGVuZChrKSxrLmF0dHIoXFxcImRpclxcXCIsYi5vcHRzLmRpcmVjdGlvbiksYi4kYm94Lmhhc0NsYXNzKFxcXCJmci1iYXNpY1xcXCIpfHwobT1hKCc8YSBkYXRhLWNtZD1cXFwiaHRtbFxcXCIgdGl0bGU9XFxcIkNvZGUgVmlld1xcXCIgY2xhc3M9XFxcImZyLWNvbW1hbmQgZnItYnRuIGh0bWwtc3dpdGNoJysoYi5oZWxwZXJzLmlzTW9iaWxlKCk/XFxcIlxcXCI6XFxcIiBmci1kZXNrdG9wXFxcIikrJ1xcXCIgcm9sZT1cXFwiYnV0dG9uXFxcIiB0YWJpbmRleD1cXFwiLTFcXFwiPjxpIGNsYXNzPVxcXCJmYSBmYS1jb2RlXFxcIj48L2k+PC9idXR0b24+JyksYi4kYm94LmFwcGVuZChtKSxiLmV2ZW50cy5iaW5kQ2xpY2soYi4kYm94LFxcXCJhLmh0bWwtc3dpdGNoXFxcIixmdW5jdGlvbigpe2coITEpfSkpO3ZhciBlPWZ1bmN0aW9uKCl7cmV0dXJuIWMoKX07Yi5ldmVudHMub24oXFxcImJ1dHRvbnMucmVmcmVzaFxcXCIsZSksYi5ldmVudHMub24oXFxcImNvcHlcXFwiLGUsITApLGIuZXZlbnRzLm9uKFxcXCJjdXRcXFwiLGUsITApLGIuZXZlbnRzLm9uKFxcXCJwYXN0ZVxcXCIsZSwhMCksYi5ldmVudHMub24oXFxcImRlc3Ryb3lcXFwiLGgsITApLGIuZXZlbnRzLm9uKFxcXCJodG1sLnNldFxcXCIsZnVuY3Rpb24oKXtjKCkmJmcoITApfSksYi5ldmVudHMub24oXFxcImZvcm0uc3VibWl0XFxcIixmdW5jdGlvbigpe2MoKSYmKGIuaHRtbC5zZXQoZCgpKSxiLmV2ZW50cy50cmlnZ2VyKFxcXCJjb250ZW50Q2hhbmdlZFxcXCIsW10sITApKX0sITApfWZ1bmN0aW9uIGooKXtyZXR1cm4gYi4kd3A/dm9pZCAwOiExfXZhciBrLGwsbTtyZXR1cm57X2luaXQ6aix0b2dnbGU6Zyxpc0FjdGl2ZTpjLGdldDpkfX0sYS5GRS5SZWdpc3RlckNvbW1hbmQoXFxcImh0bWxcXFwiLHt0aXRsZTpcXFwiQ29kZSBWaWV3XFxcIix1bmRvOiExLGZvY3VzOiExLGZvcmNlZFJlZnJlc2g6ITAsY2FsbGJhY2s6ZnVuY3Rpb24oKXt0aGlzLmNvZGVWaWV3LnRvZ2dsZSgpfSxwbHVnaW46XFxcImNvZGVWaWV3XFxcIn0pLGEuRkUuRGVmaW5lSWNvbihcXFwiaHRtbFxcXCIse05BTUU6XFxcImNvZGVcXFwifSl9KTtcIlxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3Jhdy1sb2FkZXIhLi9+L2Zyb2FsYS1lZGl0b3IvanMvcGx1Z2lucy9jb2RlX3ZpZXcubWluLmpzXG4gKiogbW9kdWxlIGlkID0gMTNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

	eval("__webpack_require__(2)(__webpack_require__(15))//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTQuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2Zyb2FsYS1lZGl0b3IvanMvcGx1Z2lucy9lbnRpdGllcy5taW4uanM/OTY4OCJdLCJzb3VyY2VzQ29udGVudCI6WyJyZXF1aXJlKFwiISEvdmFyL2FwcC93ZWIvanMvbm9kZV9tb2R1bGVzL3NjcmlwdC1sb2FkZXIvYWRkU2NyaXB0LmpzXCIpKHJlcXVpcmUoXCIhIS92YXIvYXBwL3dlYi9qcy9ub2RlX21vZHVsZXMvcmF3LWxvYWRlci9pbmRleC5qcyEvdmFyL2FwcC93ZWIvanMvbm9kZV9tb2R1bGVzL2Zyb2FsYS1lZGl0b3IvanMvcGx1Z2lucy9lbnRpdGllcy5taW4uanNcIikpXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vc2NyaXB0LWxvYWRlciEuL34vZnJvYWxhLWVkaXRvci9qcy9wbHVnaW5zL2VudGl0aWVzLm1pbi5qc1xuICoqIG1vZHVsZSBpZCA9IDE0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 15 */
/***/ function(module, exports) {

	eval("module.exports = \"/*!\\n * froala_editor v2.3.4 (https://www.froala.com/wysiwyg-editor)\\n * License https://froala.com/wysiwyg-editor/terms/\\n * Copyright 2014-2016 Froala Labs\\n */\\n\\n!function(a){\\\"function\\\"==typeof define&&define.amd?define([\\\"jquery\\\"],a):\\\"object\\\"==typeof module&&module.exports?module.exports=function(b,c){return void 0===c&&(c=\\\"undefined\\\"!=typeof window?require(\\\"jquery\\\"):require(\\\"jquery\\\")(b)),a(c),c}:a(jQuery)}(function(a){\\\"use strict\\\";a.extend(a.FE.DEFAULTS,{entities:\\\"&amp;&lt;&gt;&quot;&apos;&iexcl;&cent;&pound;&curren;&yen;&brvbar;&sect;&uml;&copy;&ordf;&laquo;&not;&shy;&reg;&macr;&deg;&plusmn;&sup2;&sup3;&acute;&micro;&para;&middot;&cedil;&sup1;&ordm;&raquo;&frac14;&frac12;&frac34;&iquest;&Agrave;&Aacute;&Acirc;&Atilde;&Auml;&Aring;&AElig;&Ccedil;&Egrave;&Eacute;&Ecirc;&Euml;&Igrave;&Iacute;&Icirc;&Iuml;&ETH;&Ntilde;&Ograve;&Oacute;&Ocirc;&Otilde;&Ouml;&times;&Oslash;&Ugrave;&Uacute;&Ucirc;&Uuml;&Yacute;&THORN;&szlig;&agrave;&aacute;&acirc;&atilde;&auml;&aring;&aelig;&ccedil;&egrave;&eacute;&ecirc;&euml;&igrave;&iacute;&icirc;&iuml;&eth;&ntilde;&ograve;&oacute;&ocirc;&otilde;&ouml;&divide;&oslash;&ugrave;&uacute;&ucirc;&uuml;&yacute;&thorn;&yuml;&OElig;&oelig;&Scaron;&scaron;&Yuml;&fnof;&circ;&tilde;&Alpha;&Beta;&Gamma;&Delta;&Epsilon;&Zeta;&Eta;&Theta;&Iota;&Kappa;&Lambda;&Mu;&Nu;&Xi;&Omicron;&Pi;&Rho;&Sigma;&Tau;&Upsilon;&Phi;&Chi;&Psi;&Omega;&alpha;&beta;&gamma;&delta;&epsilon;&zeta;&eta;&theta;&iota;&kappa;&lambda;&mu;&nu;&xi;&omicron;&pi;&rho;&sigmaf;&sigma;&tau;&upsilon;&phi;&chi;&psi;&omega;&thetasym;&upsih;&piv;&ensp;&emsp;&thinsp;&zwnj;&zwj;&lrm;&rlm;&ndash;&mdash;&lsquo;&rsquo;&sbquo;&ldquo;&rdquo;&bdquo;&dagger;&Dagger;&bull;&hellip;&permil;&prime;&Prime;&lsaquo;&rsaquo;&oline;&frasl;&euro;&image;&weierp;&real;&trade;&alefsym;&larr;&uarr;&rarr;&darr;&harr;&crarr;&lArr;&uArr;&rArr;&dArr;&hArr;&forall;&part;&exist;&empty;&nabla;&isin;&notin;&ni;&prod;&sum;&minus;&lowast;&radic;&prop;&infin;&ang;&and;&or;&cap;&cup;&int;&there4;&sim;&cong;&asymp;&ne;&equiv;&le;&ge;&sub;&sup;&nsub;&sube;&supe;&oplus;&otimes;&perp;&sdot;&lceil;&rceil;&lfloor;&rfloor;&lang;&rang;&loz;&spades;&clubs;&hearts;&diams;\\\"}),a.FE.PLUGINS.entities=function(b){function c(a){var b=a.textContent;if(b.match(g)){for(var c=\\\"\\\",d=0;d<b.length;d++)c+=h[b[d]]?h[b[d]]:b[d];a.textContent=c}}function d(a){if(a&&[\\\"STYLE\\\",\\\"SCRIPT\\\"].indexOf(a.tagName)>=0)return!0;for(var e=b.node.contents(a),f=0;f<e.length;f++)e[f].nodeType==Node.TEXT_NODE?c(e[f]):d(e[f]);a.nodeType==Node.TEXT_NODE&&c(a)}function e(a){return 0===a.length?\\\"\\\":b.clean.exec(a,d)}function f(){b.opts.htmlSimpleAmpersand&&(b.opts.entities=b.opts.entities.replace(\\\"&amp;\\\",\\\"\\\"));var c=a(\\\"<div>\\\").html(b.opts.entities).text(),d=b.opts.entities.split(\\\";\\\");h={},g=\\\"\\\";for(var f=0;f<c.length;f++){var i=c.charAt(f);h[i]=d[f]+\\\";\\\",g+=\\\"\\\\\\\\\\\"+i+(f<c.length-1?\\\"|\\\":\\\"\\\")}g=new RegExp(\\\"(\\\"+g+\\\")\\\",\\\"g\\\"),b.events.on(\\\"html.get\\\",e,!0)}var g,h;return{_init:f}}});\"//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTUuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2Zyb2FsYS1lZGl0b3IvanMvcGx1Z2lucy9lbnRpdGllcy5taW4uanM/ODViMiJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IFwiLyohXFxuICogZnJvYWxhX2VkaXRvciB2Mi4zLjQgKGh0dHBzOi8vd3d3LmZyb2FsYS5jb20vd3lzaXd5Zy1lZGl0b3IpXFxuICogTGljZW5zZSBodHRwczovL2Zyb2FsYS5jb20vd3lzaXd5Zy1lZGl0b3IvdGVybXMvXFxuICogQ29weXJpZ2h0IDIwMTQtMjAxNiBGcm9hbGEgTGFic1xcbiAqL1xcblxcbiFmdW5jdGlvbihhKXtcXFwiZnVuY3Rpb25cXFwiPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZShbXFxcImpxdWVyeVxcXCJdLGEpOlxcXCJvYmplY3RcXFwiPT10eXBlb2YgbW9kdWxlJiZtb2R1bGUuZXhwb3J0cz9tb2R1bGUuZXhwb3J0cz1mdW5jdGlvbihiLGMpe3JldHVybiB2b2lkIDA9PT1jJiYoYz1cXFwidW5kZWZpbmVkXFxcIiE9dHlwZW9mIHdpbmRvdz9yZXF1aXJlKFxcXCJqcXVlcnlcXFwiKTpyZXF1aXJlKFxcXCJqcXVlcnlcXFwiKShiKSksYShjKSxjfTphKGpRdWVyeSl9KGZ1bmN0aW9uKGEpe1xcXCJ1c2Ugc3RyaWN0XFxcIjthLmV4dGVuZChhLkZFLkRFRkFVTFRTLHtlbnRpdGllczpcXFwiJmFtcDsmbHQ7Jmd0OyZxdW90OyZhcG9zOyZpZXhjbDsmY2VudDsmcG91bmQ7JmN1cnJlbjsmeWVuOyZicnZiYXI7JnNlY3Q7JnVtbDsmY29weTsmb3JkZjsmbGFxdW87Jm5vdDsmc2h5OyZyZWc7Jm1hY3I7JmRlZzsmcGx1c21uOyZzdXAyOyZzdXAzOyZhY3V0ZTsmbWljcm87JnBhcmE7Jm1pZGRvdDsmY2VkaWw7JnN1cDE7Jm9yZG07JnJhcXVvOyZmcmFjMTQ7JmZyYWMxMjsmZnJhYzM0OyZpcXVlc3Q7JkFncmF2ZTsmQWFjdXRlOyZBY2lyYzsmQXRpbGRlOyZBdW1sOyZBcmluZzsmQUVsaWc7JkNjZWRpbDsmRWdyYXZlOyZFYWN1dGU7JkVjaXJjOyZFdW1sOyZJZ3JhdmU7JklhY3V0ZTsmSWNpcmM7Jkl1bWw7JkVUSDsmTnRpbGRlOyZPZ3JhdmU7Jk9hY3V0ZTsmT2NpcmM7Jk90aWxkZTsmT3VtbDsmdGltZXM7Jk9zbGFzaDsmVWdyYXZlOyZVYWN1dGU7JlVjaXJjOyZVdW1sOyZZYWN1dGU7JlRIT1JOOyZzemxpZzsmYWdyYXZlOyZhYWN1dGU7JmFjaXJjOyZhdGlsZGU7JmF1bWw7JmFyaW5nOyZhZWxpZzsmY2NlZGlsOyZlZ3JhdmU7JmVhY3V0ZTsmZWNpcmM7JmV1bWw7JmlncmF2ZTsmaWFjdXRlOyZpY2lyYzsmaXVtbDsmZXRoOyZudGlsZGU7Jm9ncmF2ZTsmb2FjdXRlOyZvY2lyYzsmb3RpbGRlOyZvdW1sOyZkaXZpZGU7Jm9zbGFzaDsmdWdyYXZlOyZ1YWN1dGU7JnVjaXJjOyZ1dW1sOyZ5YWN1dGU7JnRob3JuOyZ5dW1sOyZPRWxpZzsmb2VsaWc7JlNjYXJvbjsmc2Nhcm9uOyZZdW1sOyZmbm9mOyZjaXJjOyZ0aWxkZTsmQWxwaGE7JkJldGE7JkdhbW1hOyZEZWx0YTsmRXBzaWxvbjsmWmV0YTsmRXRhOyZUaGV0YTsmSW90YTsmS2FwcGE7JkxhbWJkYTsmTXU7Jk51OyZYaTsmT21pY3JvbjsmUGk7JlJobzsmU2lnbWE7JlRhdTsmVXBzaWxvbjsmUGhpOyZDaGk7JlBzaTsmT21lZ2E7JmFscGhhOyZiZXRhOyZnYW1tYTsmZGVsdGE7JmVwc2lsb247JnpldGE7JmV0YTsmdGhldGE7JmlvdGE7JmthcHBhOyZsYW1iZGE7Jm11OyZudTsmeGk7Jm9taWNyb247JnBpOyZyaG87JnNpZ21hZjsmc2lnbWE7JnRhdTsmdXBzaWxvbjsmcGhpOyZjaGk7JnBzaTsmb21lZ2E7JnRoZXRhc3ltOyZ1cHNpaDsmcGl2OyZlbnNwOyZlbXNwOyZ0aGluc3A7Jnp3bmo7Jnp3ajsmbHJtOyZybG07Jm5kYXNoOyZtZGFzaDsmbHNxdW87JnJzcXVvOyZzYnF1bzsmbGRxdW87JnJkcXVvOyZiZHF1bzsmZGFnZ2VyOyZEYWdnZXI7JmJ1bGw7JmhlbGxpcDsmcGVybWlsOyZwcmltZTsmUHJpbWU7JmxzYXF1bzsmcnNhcXVvOyZvbGluZTsmZnJhc2w7JmV1cm87JmltYWdlOyZ3ZWllcnA7JnJlYWw7JnRyYWRlOyZhbGVmc3ltOyZsYXJyOyZ1YXJyOyZyYXJyOyZkYXJyOyZoYXJyOyZjcmFycjsmbEFycjsmdUFycjsmckFycjsmZEFycjsmaEFycjsmZm9yYWxsOyZwYXJ0OyZleGlzdDsmZW1wdHk7Jm5hYmxhOyZpc2luOyZub3Rpbjsmbmk7JnByb2Q7JnN1bTsmbWludXM7Jmxvd2FzdDsmcmFkaWM7JnByb3A7JmluZmluOyZhbmc7JmFuZDsmb3I7JmNhcDsmY3VwOyZpbnQ7JnRoZXJlNDsmc2ltOyZjb25nOyZhc3ltcDsmbmU7JmVxdWl2OyZsZTsmZ2U7JnN1Yjsmc3VwOyZuc3ViOyZzdWJlOyZzdXBlOyZvcGx1czsmb3RpbWVzOyZwZXJwOyZzZG90OyZsY2VpbDsmcmNlaWw7JmxmbG9vcjsmcmZsb29yOyZsYW5nOyZyYW5nOyZsb3o7JnNwYWRlczsmY2x1YnM7JmhlYXJ0czsmZGlhbXM7XFxcIn0pLGEuRkUuUExVR0lOUy5lbnRpdGllcz1mdW5jdGlvbihiKXtmdW5jdGlvbiBjKGEpe3ZhciBiPWEudGV4dENvbnRlbnQ7aWYoYi5tYXRjaChnKSl7Zm9yKHZhciBjPVxcXCJcXFwiLGQ9MDtkPGIubGVuZ3RoO2QrKyljKz1oW2JbZF1dP2hbYltkXV06YltkXTthLnRleHRDb250ZW50PWN9fWZ1bmN0aW9uIGQoYSl7aWYoYSYmW1xcXCJTVFlMRVxcXCIsXFxcIlNDUklQVFxcXCJdLmluZGV4T2YoYS50YWdOYW1lKT49MClyZXR1cm4hMDtmb3IodmFyIGU9Yi5ub2RlLmNvbnRlbnRzKGEpLGY9MDtmPGUubGVuZ3RoO2YrKyllW2ZdLm5vZGVUeXBlPT1Ob2RlLlRFWFRfTk9ERT9jKGVbZl0pOmQoZVtmXSk7YS5ub2RlVHlwZT09Tm9kZS5URVhUX05PREUmJmMoYSl9ZnVuY3Rpb24gZShhKXtyZXR1cm4gMD09PWEubGVuZ3RoP1xcXCJcXFwiOmIuY2xlYW4uZXhlYyhhLGQpfWZ1bmN0aW9uIGYoKXtiLm9wdHMuaHRtbFNpbXBsZUFtcGVyc2FuZCYmKGIub3B0cy5lbnRpdGllcz1iLm9wdHMuZW50aXRpZXMucmVwbGFjZShcXFwiJmFtcDtcXFwiLFxcXCJcXFwiKSk7dmFyIGM9YShcXFwiPGRpdj5cXFwiKS5odG1sKGIub3B0cy5lbnRpdGllcykudGV4dCgpLGQ9Yi5vcHRzLmVudGl0aWVzLnNwbGl0KFxcXCI7XFxcIik7aD17fSxnPVxcXCJcXFwiO2Zvcih2YXIgZj0wO2Y8Yy5sZW5ndGg7ZisrKXt2YXIgaT1jLmNoYXJBdChmKTtoW2ldPWRbZl0rXFxcIjtcXFwiLGcrPVxcXCJcXFxcXFxcXFxcXCIraSsoZjxjLmxlbmd0aC0xP1xcXCJ8XFxcIjpcXFwiXFxcIil9Zz1uZXcgUmVnRXhwKFxcXCIoXFxcIitnK1xcXCIpXFxcIixcXFwiZ1xcXCIpLGIuZXZlbnRzLm9uKFxcXCJodG1sLmdldFxcXCIsZSwhMCl9dmFyIGcsaDtyZXR1cm57X2luaXQ6Zn19fSk7XCJcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yYXctbG9hZGVyIS4vfi9mcm9hbGEtZWRpdG9yL2pzL3BsdWdpbnMvZW50aXRpZXMubWluLmpzXG4gKiogbW9kdWxlIGlkID0gMTVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

	eval("__webpack_require__(2)(__webpack_require__(17))//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTYuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2Zyb2FsYS1lZGl0b3IvanMvcGx1Z2lucy9saW5rLm1pbi5qcz9lNGE2Il0sInNvdXJjZXNDb250ZW50IjpbInJlcXVpcmUoXCIhIS92YXIvYXBwL3dlYi9qcy9ub2RlX21vZHVsZXMvc2NyaXB0LWxvYWRlci9hZGRTY3JpcHQuanNcIikocmVxdWlyZShcIiEhL3Zhci9hcHAvd2ViL2pzL25vZGVfbW9kdWxlcy9yYXctbG9hZGVyL2luZGV4LmpzIS92YXIvYXBwL3dlYi9qcy9ub2RlX21vZHVsZXMvZnJvYWxhLWVkaXRvci9qcy9wbHVnaW5zL2xpbmsubWluLmpzXCIpKVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3NjcmlwdC1sb2FkZXIhLi9+L2Zyb2FsYS1lZGl0b3IvanMvcGx1Z2lucy9saW5rLm1pbi5qc1xuICoqIG1vZHVsZSBpZCA9IDE2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 17 */
/***/ function(module, exports) {

	eval("module.exports = \"/*!\\n * froala_editor v2.3.4 (https://www.froala.com/wysiwyg-editor)\\n * License https://froala.com/wysiwyg-editor/terms/\\n * Copyright 2014-2016 Froala Labs\\n */\\n\\n!function(a){\\\"function\\\"==typeof define&&define.amd?define([\\\"jquery\\\"],a):\\\"object\\\"==typeof module&&module.exports?module.exports=function(b,c){return void 0===c&&(c=\\\"undefined\\\"!=typeof window?require(\\\"jquery\\\"):require(\\\"jquery\\\")(b)),a(c),c}:a(jQuery)}(function(a){\\\"use strict\\\";a.extend(a.FE.POPUP_TEMPLATES,{\\\"link.edit\\\":\\\"[_BUTTONS_]\\\",\\\"link.insert\\\":\\\"[_BUTTONS_][_INPUT_LAYER_]\\\"}),a.extend(a.FE.DEFAULTS,{linkEditButtons:[\\\"linkOpen\\\",\\\"linkStyle\\\",\\\"linkEdit\\\",\\\"linkRemove\\\"],linkInsertButtons:[\\\"linkBack\\\",\\\"|\\\",\\\"linkList\\\"],linkAttributes:{},linkAutoPrefix:\\\"http://\\\",linkStyles:{\\\"fr-green\\\":\\\"Green\\\",\\\"fr-strong\\\":\\\"Thick\\\"},linkMultipleStyles:!0,linkConvertEmailAddress:!0,linkAlwaysBlank:!1,linkAlwaysNoFollow:!1,linkList:[{text:\\\"Froala\\\",href:\\\"https://froala.com\\\",target:\\\"_blank\\\"},{text:\\\"Google\\\",href:\\\"https://google.com\\\",target:\\\"_blank\\\"},{displayText:\\\"Facebook\\\",href:\\\"https://facebook.com\\\"}],linkText:!0}),a.FE.PLUGINS.link=function(b){function c(){var c=b.image?b.image.get():null;if(!c&&b.$wp){var d=b.selection.element(),e=b.selection.endElement();return\\\"A\\\"==d.tagName||b.node.isElement(d)||(d=a(d).parentsUntil(b.$el,\\\"a:first\\\").get(0)),\\\"A\\\"==e.tagName||b.node.isElement(e)||(e=a(e).parentsUntil(b.$el,\\\"a:first\\\").get(0)),e&&e==d&&\\\"A\\\"==e.tagName?d:null}return\\\"A\\\"==b.$el.get(0).tagName&&b.core.hasFocus()?b.$el.get(0):c&&c.get(0).parentNode&&\\\"A\\\"==c.get(0).parentNode.tagName?c.get(0).parentNode:void 0}function d(){var a=b.image?b.image.get():null,c=[];if(a)\\\"A\\\"==a.get(0).parentNode.tagName&&c.push(a.get(0).parentNode);else{var d,e,f,g;if(b.win.getSelection){var h=b.win.getSelection();if(h.getRangeAt&&h.rangeCount){g=b.doc.createRange();for(var i=0;i<h.rangeCount;++i)if(d=h.getRangeAt(i),e=d.commonAncestorContainer,e&&1!=e.nodeType&&(e=e.parentNode),e&&\\\"a\\\"==e.nodeName.toLowerCase())c.push(e);else{f=e.getElementsByTagName(\\\"a\\\");for(var j=0;j<f.length;++j)g.selectNodeContents(f[j]),g.compareBoundaryPoints(d.END_TO_START,d)<1&&g.compareBoundaryPoints(d.START_TO_END,d)>-1&&c.push(f[j])}}}else if(b.doc.selection&&\\\"Control\\\"!=b.doc.selection.type)if(d=b.doc.selection.createRange(),e=d.parentElement(),\\\"a\\\"==e.nodeName.toLowerCase())c.push(e);else{f=e.getElementsByTagName(\\\"a\\\"),g=b.doc.body.createTextRange();for(var k=0;k<f.length;++k)g.moveToElementText(f[k]),g.compareEndPoints(\\\"StartToEnd\\\",d)>-1&&g.compareEndPoints(\\\"EndToStart\\\",d)<1&&c.push(f[k])}}return c}function e(d){g(),setTimeout(function(){if(!d||d&&(1==d.which||\\\"mouseup\\\"!=d.type)){var e=c(),g=b.image?b.image.get():null;if(e&&!g){if(b.image){var h=b.node.contents(e);if(1==h.length&&\\\"IMG\\\"==h[0].tagName){var i=b.selection.ranges(0);return 0===i.startOffset&&0===i.endOffset?a(e).before(a.FE.MARKERS):a(e).after(a.FE.MARKERS),b.selection.restore(),!1}}d&&d.stopPropagation(),f(e)}}},b.helpers.isIOS()?100:0)}function f(c){var d=b.popups.get(\\\"link.edit\\\");d||(d=h());var e=a(c);b.popups.isVisible(\\\"link.edit\\\")||b.popups.refresh(\\\"link.edit\\\"),b.popups.setContainer(\\\"link.edit\\\",a(b.opts.scrollableContainer));var f=e.offset().left+a(c).outerWidth()/2,g=e.offset().top+e.outerHeight();b.popups.show(\\\"link.edit\\\",f,g,e.outerHeight())}function g(){b.popups.hide(\\\"link.edit\\\")}function h(){var a=\\\"\\\";b.opts.linkEditButtons.length>1&&(\\\"A\\\"==b.$el.get(0).tagName&&b.opts.linkEditButtons.indexOf(\\\"linkRemove\\\")>=0&&b.opts.linkEditButtons.splice(b.opts.linkEditButtons.indexOf(\\\"linkRemove\\\"),1),a='<div class=\\\"fr-buttons\\\">'+b.button.buildList(b.opts.linkEditButtons)+\\\"</div>\\\");var d={buttons:a},e=b.popups.create(\\\"link.edit\\\",d);return b.$wp&&b.events.$on(b.$wp,\\\"scroll.link-edit\\\",function(){c()&&b.popups.isVisible(\\\"link.edit\\\")&&f(c())}),e}function i(){}function j(){var d=b.popups.get(\\\"link.insert\\\"),e=c();if(e){var f,g,h=a(e),i=d.find('input.fr-link-attr[type=\\\"text\\\"]'),j=d.find('input.fr-link-attr[type=\\\"checkbox\\\"]');for(f=0;f<i.length;f++)g=a(i[f]),g.val(h.attr(g.attr(\\\"name\\\")||\\\"\\\"));for(j.prop(\\\"checked\\\",!1),f=0;f<j.length;f++)g=a(j[f]),h.attr(g.attr(\\\"name\\\"))==g.data(\\\"checked\\\")&&g.prop(\\\"checked\\\",!0);d.find('input.fr-link-attr[type=\\\"text\\\"][name=\\\"text\\\"]').val(h.text())}else d.find('input.fr-link-attr[type=\\\"text\\\"]').val(\\\"\\\"),d.find('input.fr-link-attr[type=\\\"checkbox\\\"]').prop(\\\"checked\\\",!1),d.find('input.fr-link-attr[type=\\\"text\\\"][name=\\\"text\\\"]').val(b.selection.text());d.find(\\\"input.fr-link-attr\\\").trigger(\\\"change\\\");var k=b.image?b.image.get():null;k?d.find('.fr-link-attr[name=\\\"text\\\"]').parent().hide():d.find('.fr-link-attr[name=\\\"text\\\"]').parent().show()}function k(){var c=b.$tb.find('.fr-command[data-cmd=\\\"insertLink\\\"]'),d=b.popups.get(\\\"link.insert\\\");if(d||(d=l()),!d.hasClass(\\\"fr-active\\\"))if(b.popups.refresh(\\\"link.insert\\\"),b.popups.setContainer(\\\"link.insert\\\",b.$tb||a(b.opts.scrollableContainer)),c.is(\\\":visible\\\")){var e=c.offset().left+c.outerWidth()/2,f=c.offset().top+(b.opts.toolbarBottom?10:c.outerHeight()-10);b.popups.show(\\\"link.insert\\\",e,f,c.outerHeight())}else b.position.forSelection(d),b.popups.show(\\\"link.insert\\\")}function l(a){if(a)return b.popups.onRefresh(\\\"link.insert\\\",j),b.popups.onHide(\\\"link.insert\\\",i),!0;var d=\\\"\\\";b.opts.linkInsertButtons.length>=1&&(d='<div class=\\\"fr-buttons\\\">'+b.button.buildList(b.opts.linkInsertButtons)+\\\"</div>\\\");var e='<svg version=\\\"1.1\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\" xmlns:xlink=\\\"http://www.w3.org/1999/xlink\\\" width=\\\"10\\\" height=\\\"10\\\" viewBox=\\\"0 0 32 32\\\"><path d=\\\"M27 4l-15 15-7-7-5 5 12 12 20-20z\\\" fill=\\\"#FFF\\\"></path></svg>',f=\\\"\\\",g=0;f='<div class=\\\"fr-link-insert-layer fr-layer fr-active\\\" id=\\\"fr-link-insert-layer-'+b.id+'\\\">',f+='<div class=\\\"fr-input-line\\\"><input name=\\\"href\\\" type=\\\"text\\\" class=\\\"fr-link-attr\\\" placeholder=\\\"URL\\\" tabIndex=\\\"'+ ++g+'\\\"></div>',b.opts.linkText&&(f+='<div class=\\\"fr-input-line\\\"><input name=\\\"text\\\" type=\\\"text\\\" class=\\\"fr-link-attr\\\" placeholder=\\\"'+b.language.translate(\\\"Text\\\")+'\\\" tabIndex=\\\"'+ ++g+'\\\"></div>');for(var h in b.opts.linkAttributes)if(b.opts.linkAttributes.hasOwnProperty(h)){var k=b.opts.linkAttributes[h];f+='<div class=\\\"fr-input-line\\\"><input name=\\\"'+h+'\\\" type=\\\"text\\\" class=\\\"fr-link-attr\\\" placeholder=\\\"'+b.language.translate(k)+'\\\" tabIndex=\\\"'+ ++g+'\\\"></div>'}b.opts.linkAlwaysBlank||(f+='<div class=\\\"fr-checkbox-line\\\"><span class=\\\"fr-checkbox\\\"><input name=\\\"target\\\" class=\\\"fr-link-attr\\\" data-checked=\\\"_blank\\\" type=\\\"checkbox\\\" id=\\\"fr-link-target-'+b.id+'\\\" tabIndex=\\\"'+ ++g+'\\\"><span>'+e+'</span></span><label for=\\\"fr-link-target-'+b.id+'\\\">'+b.language.translate(\\\"Open in new tab\\\")+\\\"</label></div>\\\"),f+='<div class=\\\"fr-action-buttons\\\"><button class=\\\"fr-command fr-submit\\\" data-cmd=\\\"linkInsert\\\" href=\\\"#\\\" tabIndex=\\\"'+ ++g+'\\\" type=\\\"button\\\">'+b.language.translate(\\\"Insert\\\")+\\\"</button></div></div>\\\";var l={buttons:d,input_layer:f},m=b.popups.create(\\\"link.insert\\\",l);return b.$wp&&b.events.$on(b.$wp,\\\"scroll.link-insert\\\",function(){var a=b.image?b.image.get():null;a&&b.popups.isVisible(\\\"link.insert\\\")&&u(),c&&b.popups.isVisible(\\\"link.insert\\\")&&s()}),m}function m(){var d=c(),e=b.image?b.image.get():null;return b.events.trigger(\\\"link.beforeRemove\\\",[d])===!1?!1:void(e&&d?(e.unwrap(),b.image.edit(e)):d&&(b.selection.save(),a(d).replaceWith(a(d).html()),b.selection.restore(),g()))}function n(){b.events.on(\\\"keyup\\\",function(b){b.which!=a.FE.KEYCODE.ESC&&e(b)}),b.events.on(\\\"window.mouseup\\\",e),b.helpers.isMobile()&&b.events.$on(b.$doc,\\\"selectionchange\\\",e),l(!0),\\\"A\\\"==b.$el.get(0).tagName&&b.$el.addClass(\\\"fr-view\\\")}function o(c){var d,e,f=b.opts.linkList[c],g=b.popups.get(\\\"link.insert\\\"),h=g.find('input.fr-link-attr[type=\\\"text\\\"]'),i=g.find('input.fr-link-attr[type=\\\"checkbox\\\"]');for(e=0;e<h.length;e++)d=a(h[e]),f[d.attr(\\\"name\\\")]?d.val(f[d.attr(\\\"name\\\")]):\\\"text\\\"!=d.attr(\\\"name\\\")&&d.val(\\\"\\\");for(e=0;e<i.length;e++)d=a(i[e]),d.prop(\\\"checked\\\",d.data(\\\"checked\\\")==f[d.attr(\\\"name\\\")])}function p(){var c,d,e=b.popups.get(\\\"link.insert\\\"),f=e.find('input.fr-link-attr[type=\\\"text\\\"]'),g=e.find('input.fr-link-attr[type=\\\"checkbox\\\"]'),h=f.filter('[name=\\\"href\\\"]').val(),i=f.filter('[name=\\\"text\\\"]').val(),j={};for(d=0;d<f.length;d++)c=a(f[d]),[\\\"href\\\",\\\"text\\\"].indexOf(c.attr(\\\"name\\\"))<0&&(j[c.attr(\\\"name\\\")]=c.val());for(d=0;d<g.length;d++)c=a(g[d]),c.is(\\\":checked\\\")?j[c.attr(\\\"name\\\")]=c.data(\\\"checked\\\"):j[c.attr(\\\"name\\\")]=c.data(\\\"unchecked\\\");var k=a(b.o_win).scrollTop();r(h,i,j),a(b.o_win).scrollTop(k)}function q(){if(!b.selection.isCollapsed()){b.selection.save();for(var c=b.$el.find(\\\".fr-marker\\\").addClass(\\\"fr-unprocessed\\\").toArray();c.length;){var d=a(c.pop());d.removeClass(\\\"fr-unprocessed\\\");var e=b.node.deepestParent(d.get(0));if(e){var f=d.get(0),g=\\\"\\\",h=\\\"\\\";do f=f.parentNode,b.node.isBlock(f)||(g+=b.node.closeTagString(f),h=b.node.openTagString(f)+h);while(f!=e);var i=b.node.openTagString(d.get(0))+d.html()+b.node.closeTagString(d.get(0));d.replaceWith('<span id=\\\"fr-break\\\"></span>');var j=a(e).html();j=j.replace(/<span id=\\\"fr-break\\\"><\\\\/span>/g,g+i+h),a(e).html(j)}c=b.$el.find(\\\".fr-marker.fr-unprocessed\\\").toArray()}b.selection.restore()}}function r(f,g,h){\\\"undefined\\\"==typeof h&&(h={});var i=b.image?b.image.get():null;i||\\\"A\\\"==b.$el.get(0).tagName?\\\"A\\\"==b.$el.get(0).tagName&&b.$el.focus():(b.selection.restore(),b.popups.hide(\\\"link.insert\\\"));var j=f;if(b.opts.linkConvertEmailAddress){var k=/^[\\\\w._]+@[a-z\\\\u00a1-\\\\uffff0-9_-]+?\\\\.[a-z\\\\u00a1-\\\\uffff0-9]{2,}$/i;k.test(f)&&!/^mailto:.*/i.test(f)&&(f=\\\"mailto:\\\"+f)}if(\\\"\\\"===b.opts.linkAutoPrefix||/^(mailto|tel|sms|notes|data):.*/i.test(f)||/^data:image.*/i.test(f)||/^(https?:|ftps?:|file:|)\\\\/\\\\//i.test(f)||[\\\"/\\\",\\\"{\\\",\\\"[\\\",\\\"#\\\",\\\"(\\\"].indexOf((f||\\\"\\\")[0])<0&&(f=b.opts.linkAutoPrefix+f),f=b.helpers.sanitizeURL(f),b.opts.linkAlwaysBlank&&(h.target=\\\"_blank\\\"),b.opts.linkAlwaysNoFollow&&(h.rel=\\\"nofollow\\\"),g=g||\\\"\\\",f===b.opts.linkAutoPrefix){var l=b.popups.get(\\\"link.insert\\\");return l.find('input[name=\\\"href\\\"]').addClass(\\\"fr-error\\\"),b.events.trigger(\\\"link.bad\\\",[j]),!1}var m,n=c();if(n){m=a(n);var o=b.node.rawAttributes(n);for(var p in o)o.hasOwnProperty(p)&&\\\"class\\\"!=p&&\\\"style\\\"!=p&&m.removeAttr(p);m.attr(\\\"href\\\",f),g.length>0&&m.text()!=g&&!i&&m.text(g),i||m.prepend(a.FE.START_MARKER).append(a.FE.END_MARKER),m.attr(h),i||b.selection.restore()}else{i?i.wrap('<a href=\\\"'+f+'\\\"></a>'):(b.format.remove(\\\"a\\\"),b.selection.isCollapsed()?(g=0===g.length?j:g,b.html.insert('<a href=\\\"'+f+'\\\">'+a.FE.START_MARKER+g+a.FE.END_MARKER+\\\"</a>\\\"),b.selection.restore()):g.length>0&&g!=b.selection.text().replace(/\\\\n/g,\\\"\\\")?(b.selection.remove(),b.html.insert('<a href=\\\"'+f+'\\\">'+a.FE.START_MARKER+g+a.FE.END_MARKER+\\\"</a>\\\"),b.selection.restore()):(q(),b.format.apply(\\\"a\\\",{href:f})));for(var r=d(),s=0;s<r.length;s++)m=a(r[s]),m.attr(h),m.removeAttr(\\\"_moz_dirty\\\");1==r.length&&b.$wp&&!i&&(a(r[0]).prepend(a.FE.START_MARKER).append(a.FE.END_MARKER),b.selection.restore())}if(i){var t=b.popups.get(\\\"link.insert\\\");t.find(\\\"input:focus\\\").blur(),b.image.edit(i)}else e()}function s(){g();var d=c();if(d){var e=b.popups.get(\\\"link.insert\\\");e||(e=l()),b.popups.isVisible(\\\"link.insert\\\")||(b.popups.refresh(\\\"link.insert\\\"),b.selection.save(),b.helpers.isMobile()&&(b.events.disableBlur(),b.$el.blur(),b.events.enableBlur())),b.popups.setContainer(\\\"link.insert\\\",a(b.opts.scrollableContainer));var f=(b.image?b.image.get():null)||a(d),h=f.offset().left+f.outerWidth()/2,i=f.offset().top+f.outerHeight();b.popups.show(\\\"link.insert\\\",h,i,f.outerHeight())}}function t(){var a=b.image?b.image.get():null;if(a)b.image.back();else{b.events.disableBlur(),b.selection.restore(),b.events.enableBlur();var d=c();d&&b.$wp?(b.selection.restore(),g(),e()):\\\"A\\\"==b.$el.get(0).tagName?(b.$el.focus(),e()):(b.popups.hide(\\\"link.insert\\\"),b.toolbar.showInline())}}function u(){var c=b.image?b.image.get():null;if(c){var d=b.popups.get(\\\"link.insert\\\");d||(d=l()),j(!0),b.popups.setContainer(\\\"link.insert\\\",a(b.opts.scrollableContainer));var e=c.offset().left+c.outerWidth()/2,f=c.offset().top+c.outerHeight();b.popups.show(\\\"link.insert\\\",e,f,c.outerHeight())}}function v(d,f,g){\\\"undefined\\\"==typeof g&&(g=b.opts.linkMultipleStyles),\\\"undefined\\\"==typeof f&&(f=b.opts.linkStyles);var h=c();if(!h)return!1;if(!g){var i=Object.keys(f);i.splice(i.indexOf(d),1),a(h).removeClass(i.join(\\\" \\\"))}a(h).toggleClass(d),e()}return{_init:n,remove:m,showInsertPopup:k,usePredefined:o,insertCallback:p,insert:r,update:s,get:c,allSelected:d,back:t,imageLink:u,applyStyle:v}},a.FE.DefineIcon(\\\"insertLink\\\",{NAME:\\\"link\\\"}),a.FE.RegisterShortcut(a.FE.KEYCODE.K,\\\"insertLink\\\",null,\\\"K\\\"),a.FE.RegisterCommand(\\\"insertLink\\\",{title:\\\"Insert Link\\\",undo:!1,focus:!0,refreshOnCallback:!1,popup:!0,callback:function(){this.popups.isVisible(\\\"link.insert\\\")?(this.$el.find(\\\".fr-marker\\\")&&(this.events.disableBlur(),this.selection.restore()),this.popups.hide(\\\"link.insert\\\")):this.link.showInsertPopup()},plugin:\\\"link\\\"}),a.FE.DefineIcon(\\\"linkOpen\\\",{NAME:\\\"external-link\\\"}),a.FE.RegisterCommand(\\\"linkOpen\\\",{title:\\\"Open Link\\\",undo:!1,refresh:function(a){var b=this.link.get();b?a.removeClass(\\\"fr-hidden\\\"):a.addClass(\\\"fr-hidden\\\")},callback:function(){var a=this.link.get();a&&this.o_win.open(a.href)}}),a.FE.DefineIcon(\\\"linkEdit\\\",{NAME:\\\"edit\\\"}),a.FE.RegisterCommand(\\\"linkEdit\\\",{title:\\\"Edit Link\\\",undo:!1,refreshAfterCallback:!1,callback:function(){this.link.update()},refresh:function(a){var b=this.link.get();b?a.removeClass(\\\"fr-hidden\\\"):a.addClass(\\\"fr-hidden\\\")}}),a.FE.DefineIcon(\\\"linkRemove\\\",{NAME:\\\"unlink\\\"}),a.FE.RegisterCommand(\\\"linkRemove\\\",{title:\\\"Unlink\\\",callback:function(){this.link.remove()},refresh:function(a){var b=this.link.get();b?a.removeClass(\\\"fr-hidden\\\"):a.addClass(\\\"fr-hidden\\\")}}),a.FE.DefineIcon(\\\"linkBack\\\",{NAME:\\\"arrow-left\\\"}),a.FE.RegisterCommand(\\\"linkBack\\\",{title:\\\"Back\\\",undo:!1,focus:!1,back:!0,refreshAfterCallback:!1,callback:function(){this.link.back()},refresh:function(a){var b=this.link.get(),c=this.image?this.image.get():null;c||b||this.opts.toolbarInline?(a.removeClass(\\\"fr-hidden\\\"),a.next(\\\".fr-separator\\\").removeClass(\\\"fr-hidden\\\")):(a.addClass(\\\"fr-hidden\\\"),a.next(\\\".fr-separator\\\").addClass(\\\"fr-hidden\\\"))}}),a.FE.DefineIcon(\\\"linkList\\\",{NAME:\\\"search\\\"}),a.FE.RegisterCommand(\\\"linkList\\\",{title:\\\"Choose Link\\\",type:\\\"dropdown\\\",focus:!1,undo:!1,refreshAfterCallback:!1,html:function(){for(var a='<ul class=\\\"fr-dropdown-list\\\">',b=this.opts.linkList,c=0;c<b.length;c++)a+='<li><a class=\\\"fr-command\\\" data-cmd=\\\"linkList\\\" data-param1=\\\"'+c+'\\\">'+(b[c].displayText||b[c].text)+\\\"</a></li>\\\";return a+=\\\"</ul>\\\"},callback:function(a,b){this.link.usePredefined(b)}}),a.FE.RegisterCommand(\\\"linkInsert\\\",{focus:!1,refreshAfterCallback:!1,callback:function(){this.link.insertCallback()},refresh:function(a){var b=this.link.get();b?a.text(this.language.translate(\\\"Update\\\")):a.text(this.language.translate(\\\"Insert\\\"))}}),a.FE.DefineIcon(\\\"imageLink\\\",{NAME:\\\"link\\\"}),a.FE.RegisterCommand(\\\"imageLink\\\",{title:\\\"Insert Link\\\",undo:!1,focus:!1,callback:function(){this.link.imageLink()},refresh:function(a){var b,c=this.link.get();c?(b=a.prev(),b.hasClass(\\\"fr-separator\\\")&&b.removeClass(\\\"fr-hidden\\\"),a.addClass(\\\"fr-hidden\\\")):(b=a.prev(),b.hasClass(\\\"fr-separator\\\")&&b.addClass(\\\"fr-hidden\\\"),a.removeClass(\\\"fr-hidden\\\"))}}),a.FE.DefineIcon(\\\"linkStyle\\\",{NAME:\\\"magic\\\"}),a.FE.RegisterCommand(\\\"linkStyle\\\",{title:\\\"Style\\\",type:\\\"dropdown\\\",html:function(){var a='<ul class=\\\"fr-dropdown-list\\\">',b=this.opts.linkStyles;for(var c in b)b.hasOwnProperty(c)&&(a+='<li><a class=\\\"fr-command\\\" data-cmd=\\\"linkStyle\\\" data-param1=\\\"'+c+'\\\">'+this.language.translate(b[c])+\\\"</a></li>\\\");return a+=\\\"</ul>\\\"},callback:function(a,b){this.link.applyStyle(b)},refreshOnShow:function(b,c){var d=this.link.get();if(d){var e=a(d);c.find(\\\".fr-command\\\").each(function(){var b=a(this).data(\\\"param1\\\");a(this).toggleClass(\\\"fr-active\\\",e.hasClass(b))})}}})});\"//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTcuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2Zyb2FsYS1lZGl0b3IvanMvcGx1Z2lucy9saW5rLm1pbi5qcz81MmY1Il0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gXCIvKiFcXG4gKiBmcm9hbGFfZWRpdG9yIHYyLjMuNCAoaHR0cHM6Ly93d3cuZnJvYWxhLmNvbS93eXNpd3lnLWVkaXRvcilcXG4gKiBMaWNlbnNlIGh0dHBzOi8vZnJvYWxhLmNvbS93eXNpd3lnLWVkaXRvci90ZXJtcy9cXG4gKiBDb3B5cmlnaHQgMjAxNC0yMDE2IEZyb2FsYSBMYWJzXFxuICovXFxuXFxuIWZ1bmN0aW9uKGEpe1xcXCJmdW5jdGlvblxcXCI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQ/ZGVmaW5lKFtcXFwianF1ZXJ5XFxcIl0sYSk6XFxcIm9iamVjdFxcXCI9PXR5cGVvZiBtb2R1bGUmJm1vZHVsZS5leHBvcnRzP21vZHVsZS5leHBvcnRzPWZ1bmN0aW9uKGIsYyl7cmV0dXJuIHZvaWQgMD09PWMmJihjPVxcXCJ1bmRlZmluZWRcXFwiIT10eXBlb2Ygd2luZG93P3JlcXVpcmUoXFxcImpxdWVyeVxcXCIpOnJlcXVpcmUoXFxcImpxdWVyeVxcXCIpKGIpKSxhKGMpLGN9OmEoalF1ZXJ5KX0oZnVuY3Rpb24oYSl7XFxcInVzZSBzdHJpY3RcXFwiO2EuZXh0ZW5kKGEuRkUuUE9QVVBfVEVNUExBVEVTLHtcXFwibGluay5lZGl0XFxcIjpcXFwiW19CVVRUT05TX11cXFwiLFxcXCJsaW5rLmluc2VydFxcXCI6XFxcIltfQlVUVE9OU19dW19JTlBVVF9MQVlFUl9dXFxcIn0pLGEuZXh0ZW5kKGEuRkUuREVGQVVMVFMse2xpbmtFZGl0QnV0dG9uczpbXFxcImxpbmtPcGVuXFxcIixcXFwibGlua1N0eWxlXFxcIixcXFwibGlua0VkaXRcXFwiLFxcXCJsaW5rUmVtb3ZlXFxcIl0sbGlua0luc2VydEJ1dHRvbnM6W1xcXCJsaW5rQmFja1xcXCIsXFxcInxcXFwiLFxcXCJsaW5rTGlzdFxcXCJdLGxpbmtBdHRyaWJ1dGVzOnt9LGxpbmtBdXRvUHJlZml4OlxcXCJodHRwOi8vXFxcIixsaW5rU3R5bGVzOntcXFwiZnItZ3JlZW5cXFwiOlxcXCJHcmVlblxcXCIsXFxcImZyLXN0cm9uZ1xcXCI6XFxcIlRoaWNrXFxcIn0sbGlua011bHRpcGxlU3R5bGVzOiEwLGxpbmtDb252ZXJ0RW1haWxBZGRyZXNzOiEwLGxpbmtBbHdheXNCbGFuazohMSxsaW5rQWx3YXlzTm9Gb2xsb3c6ITEsbGlua0xpc3Q6W3t0ZXh0OlxcXCJGcm9hbGFcXFwiLGhyZWY6XFxcImh0dHBzOi8vZnJvYWxhLmNvbVxcXCIsdGFyZ2V0OlxcXCJfYmxhbmtcXFwifSx7dGV4dDpcXFwiR29vZ2xlXFxcIixocmVmOlxcXCJodHRwczovL2dvb2dsZS5jb21cXFwiLHRhcmdldDpcXFwiX2JsYW5rXFxcIn0se2Rpc3BsYXlUZXh0OlxcXCJGYWNlYm9va1xcXCIsaHJlZjpcXFwiaHR0cHM6Ly9mYWNlYm9vay5jb21cXFwifV0sbGlua1RleHQ6ITB9KSxhLkZFLlBMVUdJTlMubGluaz1mdW5jdGlvbihiKXtmdW5jdGlvbiBjKCl7dmFyIGM9Yi5pbWFnZT9iLmltYWdlLmdldCgpOm51bGw7aWYoIWMmJmIuJHdwKXt2YXIgZD1iLnNlbGVjdGlvbi5lbGVtZW50KCksZT1iLnNlbGVjdGlvbi5lbmRFbGVtZW50KCk7cmV0dXJuXFxcIkFcXFwiPT1kLnRhZ05hbWV8fGIubm9kZS5pc0VsZW1lbnQoZCl8fChkPWEoZCkucGFyZW50c1VudGlsKGIuJGVsLFxcXCJhOmZpcnN0XFxcIikuZ2V0KDApKSxcXFwiQVxcXCI9PWUudGFnTmFtZXx8Yi5ub2RlLmlzRWxlbWVudChlKXx8KGU9YShlKS5wYXJlbnRzVW50aWwoYi4kZWwsXFxcImE6Zmlyc3RcXFwiKS5nZXQoMCkpLGUmJmU9PWQmJlxcXCJBXFxcIj09ZS50YWdOYW1lP2Q6bnVsbH1yZXR1cm5cXFwiQVxcXCI9PWIuJGVsLmdldCgwKS50YWdOYW1lJiZiLmNvcmUuaGFzRm9jdXMoKT9iLiRlbC5nZXQoMCk6YyYmYy5nZXQoMCkucGFyZW50Tm9kZSYmXFxcIkFcXFwiPT1jLmdldCgwKS5wYXJlbnROb2RlLnRhZ05hbWU/Yy5nZXQoMCkucGFyZW50Tm9kZTp2b2lkIDB9ZnVuY3Rpb24gZCgpe3ZhciBhPWIuaW1hZ2U/Yi5pbWFnZS5nZXQoKTpudWxsLGM9W107aWYoYSlcXFwiQVxcXCI9PWEuZ2V0KDApLnBhcmVudE5vZGUudGFnTmFtZSYmYy5wdXNoKGEuZ2V0KDApLnBhcmVudE5vZGUpO2Vsc2V7dmFyIGQsZSxmLGc7aWYoYi53aW4uZ2V0U2VsZWN0aW9uKXt2YXIgaD1iLndpbi5nZXRTZWxlY3Rpb24oKTtpZihoLmdldFJhbmdlQXQmJmgucmFuZ2VDb3VudCl7Zz1iLmRvYy5jcmVhdGVSYW5nZSgpO2Zvcih2YXIgaT0wO2k8aC5yYW5nZUNvdW50OysraSlpZihkPWguZ2V0UmFuZ2VBdChpKSxlPWQuY29tbW9uQW5jZXN0b3JDb250YWluZXIsZSYmMSE9ZS5ub2RlVHlwZSYmKGU9ZS5wYXJlbnROb2RlKSxlJiZcXFwiYVxcXCI9PWUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSljLnB1c2goZSk7ZWxzZXtmPWUuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXFxcImFcXFwiKTtmb3IodmFyIGo9MDtqPGYubGVuZ3RoOysrailnLnNlbGVjdE5vZGVDb250ZW50cyhmW2pdKSxnLmNvbXBhcmVCb3VuZGFyeVBvaW50cyhkLkVORF9UT19TVEFSVCxkKTwxJiZnLmNvbXBhcmVCb3VuZGFyeVBvaW50cyhkLlNUQVJUX1RPX0VORCxkKT4tMSYmYy5wdXNoKGZbal0pfX19ZWxzZSBpZihiLmRvYy5zZWxlY3Rpb24mJlxcXCJDb250cm9sXFxcIiE9Yi5kb2Muc2VsZWN0aW9uLnR5cGUpaWYoZD1iLmRvYy5zZWxlY3Rpb24uY3JlYXRlUmFuZ2UoKSxlPWQucGFyZW50RWxlbWVudCgpLFxcXCJhXFxcIj09ZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpKWMucHVzaChlKTtlbHNle2Y9ZS5nZXRFbGVtZW50c0J5VGFnTmFtZShcXFwiYVxcXCIpLGc9Yi5kb2MuYm9keS5jcmVhdGVUZXh0UmFuZ2UoKTtmb3IodmFyIGs9MDtrPGYubGVuZ3RoOysraylnLm1vdmVUb0VsZW1lbnRUZXh0KGZba10pLGcuY29tcGFyZUVuZFBvaW50cyhcXFwiU3RhcnRUb0VuZFxcXCIsZCk+LTEmJmcuY29tcGFyZUVuZFBvaW50cyhcXFwiRW5kVG9TdGFydFxcXCIsZCk8MSYmYy5wdXNoKGZba10pfX1yZXR1cm4gY31mdW5jdGlvbiBlKGQpe2coKSxzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7aWYoIWR8fGQmJigxPT1kLndoaWNofHxcXFwibW91c2V1cFxcXCIhPWQudHlwZSkpe3ZhciBlPWMoKSxnPWIuaW1hZ2U/Yi5pbWFnZS5nZXQoKTpudWxsO2lmKGUmJiFnKXtpZihiLmltYWdlKXt2YXIgaD1iLm5vZGUuY29udGVudHMoZSk7aWYoMT09aC5sZW5ndGgmJlxcXCJJTUdcXFwiPT1oWzBdLnRhZ05hbWUpe3ZhciBpPWIuc2VsZWN0aW9uLnJhbmdlcygwKTtyZXR1cm4gMD09PWkuc3RhcnRPZmZzZXQmJjA9PT1pLmVuZE9mZnNldD9hKGUpLmJlZm9yZShhLkZFLk1BUktFUlMpOmEoZSkuYWZ0ZXIoYS5GRS5NQVJLRVJTKSxiLnNlbGVjdGlvbi5yZXN0b3JlKCksITF9fWQmJmQuc3RvcFByb3BhZ2F0aW9uKCksZihlKX19fSxiLmhlbHBlcnMuaXNJT1MoKT8xMDA6MCl9ZnVuY3Rpb24gZihjKXt2YXIgZD1iLnBvcHVwcy5nZXQoXFxcImxpbmsuZWRpdFxcXCIpO2R8fChkPWgoKSk7dmFyIGU9YShjKTtiLnBvcHVwcy5pc1Zpc2libGUoXFxcImxpbmsuZWRpdFxcXCIpfHxiLnBvcHVwcy5yZWZyZXNoKFxcXCJsaW5rLmVkaXRcXFwiKSxiLnBvcHVwcy5zZXRDb250YWluZXIoXFxcImxpbmsuZWRpdFxcXCIsYShiLm9wdHMuc2Nyb2xsYWJsZUNvbnRhaW5lcikpO3ZhciBmPWUub2Zmc2V0KCkubGVmdCthKGMpLm91dGVyV2lkdGgoKS8yLGc9ZS5vZmZzZXQoKS50b3ArZS5vdXRlckhlaWdodCgpO2IucG9wdXBzLnNob3coXFxcImxpbmsuZWRpdFxcXCIsZixnLGUub3V0ZXJIZWlnaHQoKSl9ZnVuY3Rpb24gZygpe2IucG9wdXBzLmhpZGUoXFxcImxpbmsuZWRpdFxcXCIpfWZ1bmN0aW9uIGgoKXt2YXIgYT1cXFwiXFxcIjtiLm9wdHMubGlua0VkaXRCdXR0b25zLmxlbmd0aD4xJiYoXFxcIkFcXFwiPT1iLiRlbC5nZXQoMCkudGFnTmFtZSYmYi5vcHRzLmxpbmtFZGl0QnV0dG9ucy5pbmRleE9mKFxcXCJsaW5rUmVtb3ZlXFxcIik+PTAmJmIub3B0cy5saW5rRWRpdEJ1dHRvbnMuc3BsaWNlKGIub3B0cy5saW5rRWRpdEJ1dHRvbnMuaW5kZXhPZihcXFwibGlua1JlbW92ZVxcXCIpLDEpLGE9JzxkaXYgY2xhc3M9XFxcImZyLWJ1dHRvbnNcXFwiPicrYi5idXR0b24uYnVpbGRMaXN0KGIub3B0cy5saW5rRWRpdEJ1dHRvbnMpK1xcXCI8L2Rpdj5cXFwiKTt2YXIgZD17YnV0dG9uczphfSxlPWIucG9wdXBzLmNyZWF0ZShcXFwibGluay5lZGl0XFxcIixkKTtyZXR1cm4gYi4kd3AmJmIuZXZlbnRzLiRvbihiLiR3cCxcXFwic2Nyb2xsLmxpbmstZWRpdFxcXCIsZnVuY3Rpb24oKXtjKCkmJmIucG9wdXBzLmlzVmlzaWJsZShcXFwibGluay5lZGl0XFxcIikmJmYoYygpKX0pLGV9ZnVuY3Rpb24gaSgpe31mdW5jdGlvbiBqKCl7dmFyIGQ9Yi5wb3B1cHMuZ2V0KFxcXCJsaW5rLmluc2VydFxcXCIpLGU9YygpO2lmKGUpe3ZhciBmLGcsaD1hKGUpLGk9ZC5maW5kKCdpbnB1dC5mci1saW5rLWF0dHJbdHlwZT1cXFwidGV4dFxcXCJdJyksaj1kLmZpbmQoJ2lucHV0LmZyLWxpbmstYXR0clt0eXBlPVxcXCJjaGVja2JveFxcXCJdJyk7Zm9yKGY9MDtmPGkubGVuZ3RoO2YrKylnPWEoaVtmXSksZy52YWwoaC5hdHRyKGcuYXR0cihcXFwibmFtZVxcXCIpfHxcXFwiXFxcIikpO2ZvcihqLnByb3AoXFxcImNoZWNrZWRcXFwiLCExKSxmPTA7ZjxqLmxlbmd0aDtmKyspZz1hKGpbZl0pLGguYXR0cihnLmF0dHIoXFxcIm5hbWVcXFwiKSk9PWcuZGF0YShcXFwiY2hlY2tlZFxcXCIpJiZnLnByb3AoXFxcImNoZWNrZWRcXFwiLCEwKTtkLmZpbmQoJ2lucHV0LmZyLWxpbmstYXR0clt0eXBlPVxcXCJ0ZXh0XFxcIl1bbmFtZT1cXFwidGV4dFxcXCJdJykudmFsKGgudGV4dCgpKX1lbHNlIGQuZmluZCgnaW5wdXQuZnItbGluay1hdHRyW3R5cGU9XFxcInRleHRcXFwiXScpLnZhbChcXFwiXFxcIiksZC5maW5kKCdpbnB1dC5mci1saW5rLWF0dHJbdHlwZT1cXFwiY2hlY2tib3hcXFwiXScpLnByb3AoXFxcImNoZWNrZWRcXFwiLCExKSxkLmZpbmQoJ2lucHV0LmZyLWxpbmstYXR0clt0eXBlPVxcXCJ0ZXh0XFxcIl1bbmFtZT1cXFwidGV4dFxcXCJdJykudmFsKGIuc2VsZWN0aW9uLnRleHQoKSk7ZC5maW5kKFxcXCJpbnB1dC5mci1saW5rLWF0dHJcXFwiKS50cmlnZ2VyKFxcXCJjaGFuZ2VcXFwiKTt2YXIgaz1iLmltYWdlP2IuaW1hZ2UuZ2V0KCk6bnVsbDtrP2QuZmluZCgnLmZyLWxpbmstYXR0cltuYW1lPVxcXCJ0ZXh0XFxcIl0nKS5wYXJlbnQoKS5oaWRlKCk6ZC5maW5kKCcuZnItbGluay1hdHRyW25hbWU9XFxcInRleHRcXFwiXScpLnBhcmVudCgpLnNob3coKX1mdW5jdGlvbiBrKCl7dmFyIGM9Yi4kdGIuZmluZCgnLmZyLWNvbW1hbmRbZGF0YS1jbWQ9XFxcImluc2VydExpbmtcXFwiXScpLGQ9Yi5wb3B1cHMuZ2V0KFxcXCJsaW5rLmluc2VydFxcXCIpO2lmKGR8fChkPWwoKSksIWQuaGFzQ2xhc3MoXFxcImZyLWFjdGl2ZVxcXCIpKWlmKGIucG9wdXBzLnJlZnJlc2goXFxcImxpbmsuaW5zZXJ0XFxcIiksYi5wb3B1cHMuc2V0Q29udGFpbmVyKFxcXCJsaW5rLmluc2VydFxcXCIsYi4kdGJ8fGEoYi5vcHRzLnNjcm9sbGFibGVDb250YWluZXIpKSxjLmlzKFxcXCI6dmlzaWJsZVxcXCIpKXt2YXIgZT1jLm9mZnNldCgpLmxlZnQrYy5vdXRlcldpZHRoKCkvMixmPWMub2Zmc2V0KCkudG9wKyhiLm9wdHMudG9vbGJhckJvdHRvbT8xMDpjLm91dGVySGVpZ2h0KCktMTApO2IucG9wdXBzLnNob3coXFxcImxpbmsuaW5zZXJ0XFxcIixlLGYsYy5vdXRlckhlaWdodCgpKX1lbHNlIGIucG9zaXRpb24uZm9yU2VsZWN0aW9uKGQpLGIucG9wdXBzLnNob3coXFxcImxpbmsuaW5zZXJ0XFxcIil9ZnVuY3Rpb24gbChhKXtpZihhKXJldHVybiBiLnBvcHVwcy5vblJlZnJlc2goXFxcImxpbmsuaW5zZXJ0XFxcIixqKSxiLnBvcHVwcy5vbkhpZGUoXFxcImxpbmsuaW5zZXJ0XFxcIixpKSwhMDt2YXIgZD1cXFwiXFxcIjtiLm9wdHMubGlua0luc2VydEJ1dHRvbnMubGVuZ3RoPj0xJiYoZD0nPGRpdiBjbGFzcz1cXFwiZnItYnV0dG9uc1xcXCI+JytiLmJ1dHRvbi5idWlsZExpc3QoYi5vcHRzLmxpbmtJbnNlcnRCdXR0b25zKStcXFwiPC9kaXY+XFxcIik7dmFyIGU9JzxzdmcgdmVyc2lvbj1cXFwiMS4xXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiIHhtbG5zOnhsaW5rPVxcXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rXFxcIiB3aWR0aD1cXFwiMTBcXFwiIGhlaWdodD1cXFwiMTBcXFwiIHZpZXdCb3g9XFxcIjAgMCAzMiAzMlxcXCI+PHBhdGggZD1cXFwiTTI3IDRsLTE1IDE1LTctNy01IDUgMTIgMTIgMjAtMjB6XFxcIiBmaWxsPVxcXCIjRkZGXFxcIj48L3BhdGg+PC9zdmc+JyxmPVxcXCJcXFwiLGc9MDtmPSc8ZGl2IGNsYXNzPVxcXCJmci1saW5rLWluc2VydC1sYXllciBmci1sYXllciBmci1hY3RpdmVcXFwiIGlkPVxcXCJmci1saW5rLWluc2VydC1sYXllci0nK2IuaWQrJ1xcXCI+JyxmKz0nPGRpdiBjbGFzcz1cXFwiZnItaW5wdXQtbGluZVxcXCI+PGlucHV0IG5hbWU9XFxcImhyZWZcXFwiIHR5cGU9XFxcInRleHRcXFwiIGNsYXNzPVxcXCJmci1saW5rLWF0dHJcXFwiIHBsYWNlaG9sZGVyPVxcXCJVUkxcXFwiIHRhYkluZGV4PVxcXCInKyArK2crJ1xcXCI+PC9kaXY+JyxiLm9wdHMubGlua1RleHQmJihmKz0nPGRpdiBjbGFzcz1cXFwiZnItaW5wdXQtbGluZVxcXCI+PGlucHV0IG5hbWU9XFxcInRleHRcXFwiIHR5cGU9XFxcInRleHRcXFwiIGNsYXNzPVxcXCJmci1saW5rLWF0dHJcXFwiIHBsYWNlaG9sZGVyPVxcXCInK2IubGFuZ3VhZ2UudHJhbnNsYXRlKFxcXCJUZXh0XFxcIikrJ1xcXCIgdGFiSW5kZXg9XFxcIicrICsrZysnXFxcIj48L2Rpdj4nKTtmb3IodmFyIGggaW4gYi5vcHRzLmxpbmtBdHRyaWJ1dGVzKWlmKGIub3B0cy5saW5rQXR0cmlidXRlcy5oYXNPd25Qcm9wZXJ0eShoKSl7dmFyIGs9Yi5vcHRzLmxpbmtBdHRyaWJ1dGVzW2hdO2YrPSc8ZGl2IGNsYXNzPVxcXCJmci1pbnB1dC1saW5lXFxcIj48aW5wdXQgbmFtZT1cXFwiJytoKydcXFwiIHR5cGU9XFxcInRleHRcXFwiIGNsYXNzPVxcXCJmci1saW5rLWF0dHJcXFwiIHBsYWNlaG9sZGVyPVxcXCInK2IubGFuZ3VhZ2UudHJhbnNsYXRlKGspKydcXFwiIHRhYkluZGV4PVxcXCInKyArK2crJ1xcXCI+PC9kaXY+J31iLm9wdHMubGlua0Fsd2F5c0JsYW5rfHwoZis9JzxkaXYgY2xhc3M9XFxcImZyLWNoZWNrYm94LWxpbmVcXFwiPjxzcGFuIGNsYXNzPVxcXCJmci1jaGVja2JveFxcXCI+PGlucHV0IG5hbWU9XFxcInRhcmdldFxcXCIgY2xhc3M9XFxcImZyLWxpbmstYXR0clxcXCIgZGF0YS1jaGVja2VkPVxcXCJfYmxhbmtcXFwiIHR5cGU9XFxcImNoZWNrYm94XFxcIiBpZD1cXFwiZnItbGluay10YXJnZXQtJytiLmlkKydcXFwiIHRhYkluZGV4PVxcXCInKyArK2crJ1xcXCI+PHNwYW4+JytlKyc8L3NwYW4+PC9zcGFuPjxsYWJlbCBmb3I9XFxcImZyLWxpbmstdGFyZ2V0LScrYi5pZCsnXFxcIj4nK2IubGFuZ3VhZ2UudHJhbnNsYXRlKFxcXCJPcGVuIGluIG5ldyB0YWJcXFwiKStcXFwiPC9sYWJlbD48L2Rpdj5cXFwiKSxmKz0nPGRpdiBjbGFzcz1cXFwiZnItYWN0aW9uLWJ1dHRvbnNcXFwiPjxidXR0b24gY2xhc3M9XFxcImZyLWNvbW1hbmQgZnItc3VibWl0XFxcIiBkYXRhLWNtZD1cXFwibGlua0luc2VydFxcXCIgaHJlZj1cXFwiI1xcXCIgdGFiSW5kZXg9XFxcIicrICsrZysnXFxcIiB0eXBlPVxcXCJidXR0b25cXFwiPicrYi5sYW5ndWFnZS50cmFuc2xhdGUoXFxcIkluc2VydFxcXCIpK1xcXCI8L2J1dHRvbj48L2Rpdj48L2Rpdj5cXFwiO3ZhciBsPXtidXR0b25zOmQsaW5wdXRfbGF5ZXI6Zn0sbT1iLnBvcHVwcy5jcmVhdGUoXFxcImxpbmsuaW5zZXJ0XFxcIixsKTtyZXR1cm4gYi4kd3AmJmIuZXZlbnRzLiRvbihiLiR3cCxcXFwic2Nyb2xsLmxpbmstaW5zZXJ0XFxcIixmdW5jdGlvbigpe3ZhciBhPWIuaW1hZ2U/Yi5pbWFnZS5nZXQoKTpudWxsO2EmJmIucG9wdXBzLmlzVmlzaWJsZShcXFwibGluay5pbnNlcnRcXFwiKSYmdSgpLGMmJmIucG9wdXBzLmlzVmlzaWJsZShcXFwibGluay5pbnNlcnRcXFwiKSYmcygpfSksbX1mdW5jdGlvbiBtKCl7dmFyIGQ9YygpLGU9Yi5pbWFnZT9iLmltYWdlLmdldCgpOm51bGw7cmV0dXJuIGIuZXZlbnRzLnRyaWdnZXIoXFxcImxpbmsuYmVmb3JlUmVtb3ZlXFxcIixbZF0pPT09ITE/ITE6dm9pZChlJiZkPyhlLnVud3JhcCgpLGIuaW1hZ2UuZWRpdChlKSk6ZCYmKGIuc2VsZWN0aW9uLnNhdmUoKSxhKGQpLnJlcGxhY2VXaXRoKGEoZCkuaHRtbCgpKSxiLnNlbGVjdGlvbi5yZXN0b3JlKCksZygpKSl9ZnVuY3Rpb24gbigpe2IuZXZlbnRzLm9uKFxcXCJrZXl1cFxcXCIsZnVuY3Rpb24oYil7Yi53aGljaCE9YS5GRS5LRVlDT0RFLkVTQyYmZShiKX0pLGIuZXZlbnRzLm9uKFxcXCJ3aW5kb3cubW91c2V1cFxcXCIsZSksYi5oZWxwZXJzLmlzTW9iaWxlKCkmJmIuZXZlbnRzLiRvbihiLiRkb2MsXFxcInNlbGVjdGlvbmNoYW5nZVxcXCIsZSksbCghMCksXFxcIkFcXFwiPT1iLiRlbC5nZXQoMCkudGFnTmFtZSYmYi4kZWwuYWRkQ2xhc3MoXFxcImZyLXZpZXdcXFwiKX1mdW5jdGlvbiBvKGMpe3ZhciBkLGUsZj1iLm9wdHMubGlua0xpc3RbY10sZz1iLnBvcHVwcy5nZXQoXFxcImxpbmsuaW5zZXJ0XFxcIiksaD1nLmZpbmQoJ2lucHV0LmZyLWxpbmstYXR0clt0eXBlPVxcXCJ0ZXh0XFxcIl0nKSxpPWcuZmluZCgnaW5wdXQuZnItbGluay1hdHRyW3R5cGU9XFxcImNoZWNrYm94XFxcIl0nKTtmb3IoZT0wO2U8aC5sZW5ndGg7ZSsrKWQ9YShoW2VdKSxmW2QuYXR0cihcXFwibmFtZVxcXCIpXT9kLnZhbChmW2QuYXR0cihcXFwibmFtZVxcXCIpXSk6XFxcInRleHRcXFwiIT1kLmF0dHIoXFxcIm5hbWVcXFwiKSYmZC52YWwoXFxcIlxcXCIpO2ZvcihlPTA7ZTxpLmxlbmd0aDtlKyspZD1hKGlbZV0pLGQucHJvcChcXFwiY2hlY2tlZFxcXCIsZC5kYXRhKFxcXCJjaGVja2VkXFxcIik9PWZbZC5hdHRyKFxcXCJuYW1lXFxcIildKX1mdW5jdGlvbiBwKCl7dmFyIGMsZCxlPWIucG9wdXBzLmdldChcXFwibGluay5pbnNlcnRcXFwiKSxmPWUuZmluZCgnaW5wdXQuZnItbGluay1hdHRyW3R5cGU9XFxcInRleHRcXFwiXScpLGc9ZS5maW5kKCdpbnB1dC5mci1saW5rLWF0dHJbdHlwZT1cXFwiY2hlY2tib3hcXFwiXScpLGg9Zi5maWx0ZXIoJ1tuYW1lPVxcXCJocmVmXFxcIl0nKS52YWwoKSxpPWYuZmlsdGVyKCdbbmFtZT1cXFwidGV4dFxcXCJdJykudmFsKCksaj17fTtmb3IoZD0wO2Q8Zi5sZW5ndGg7ZCsrKWM9YShmW2RdKSxbXFxcImhyZWZcXFwiLFxcXCJ0ZXh0XFxcIl0uaW5kZXhPZihjLmF0dHIoXFxcIm5hbWVcXFwiKSk8MCYmKGpbYy5hdHRyKFxcXCJuYW1lXFxcIildPWMudmFsKCkpO2ZvcihkPTA7ZDxnLmxlbmd0aDtkKyspYz1hKGdbZF0pLGMuaXMoXFxcIjpjaGVja2VkXFxcIik/altjLmF0dHIoXFxcIm5hbWVcXFwiKV09Yy5kYXRhKFxcXCJjaGVja2VkXFxcIik6altjLmF0dHIoXFxcIm5hbWVcXFwiKV09Yy5kYXRhKFxcXCJ1bmNoZWNrZWRcXFwiKTt2YXIgaz1hKGIub193aW4pLnNjcm9sbFRvcCgpO3IoaCxpLGopLGEoYi5vX3dpbikuc2Nyb2xsVG9wKGspfWZ1bmN0aW9uIHEoKXtpZighYi5zZWxlY3Rpb24uaXNDb2xsYXBzZWQoKSl7Yi5zZWxlY3Rpb24uc2F2ZSgpO2Zvcih2YXIgYz1iLiRlbC5maW5kKFxcXCIuZnItbWFya2VyXFxcIikuYWRkQ2xhc3MoXFxcImZyLXVucHJvY2Vzc2VkXFxcIikudG9BcnJheSgpO2MubGVuZ3RoOyl7dmFyIGQ9YShjLnBvcCgpKTtkLnJlbW92ZUNsYXNzKFxcXCJmci11bnByb2Nlc3NlZFxcXCIpO3ZhciBlPWIubm9kZS5kZWVwZXN0UGFyZW50KGQuZ2V0KDApKTtpZihlKXt2YXIgZj1kLmdldCgwKSxnPVxcXCJcXFwiLGg9XFxcIlxcXCI7ZG8gZj1mLnBhcmVudE5vZGUsYi5ub2RlLmlzQmxvY2soZil8fChnKz1iLm5vZGUuY2xvc2VUYWdTdHJpbmcoZiksaD1iLm5vZGUub3BlblRhZ1N0cmluZyhmKStoKTt3aGlsZShmIT1lKTt2YXIgaT1iLm5vZGUub3BlblRhZ1N0cmluZyhkLmdldCgwKSkrZC5odG1sKCkrYi5ub2RlLmNsb3NlVGFnU3RyaW5nKGQuZ2V0KDApKTtkLnJlcGxhY2VXaXRoKCc8c3BhbiBpZD1cXFwiZnItYnJlYWtcXFwiPjwvc3Bhbj4nKTt2YXIgaj1hKGUpLmh0bWwoKTtqPWoucmVwbGFjZSgvPHNwYW4gaWQ9XFxcImZyLWJyZWFrXFxcIj48XFxcXC9zcGFuPi9nLGcraStoKSxhKGUpLmh0bWwoail9Yz1iLiRlbC5maW5kKFxcXCIuZnItbWFya2VyLmZyLXVucHJvY2Vzc2VkXFxcIikudG9BcnJheSgpfWIuc2VsZWN0aW9uLnJlc3RvcmUoKX19ZnVuY3Rpb24gcihmLGcsaCl7XFxcInVuZGVmaW5lZFxcXCI9PXR5cGVvZiBoJiYoaD17fSk7dmFyIGk9Yi5pbWFnZT9iLmltYWdlLmdldCgpOm51bGw7aXx8XFxcIkFcXFwiPT1iLiRlbC5nZXQoMCkudGFnTmFtZT9cXFwiQVxcXCI9PWIuJGVsLmdldCgwKS50YWdOYW1lJiZiLiRlbC5mb2N1cygpOihiLnNlbGVjdGlvbi5yZXN0b3JlKCksYi5wb3B1cHMuaGlkZShcXFwibGluay5pbnNlcnRcXFwiKSk7dmFyIGo9ZjtpZihiLm9wdHMubGlua0NvbnZlcnRFbWFpbEFkZHJlc3Mpe3ZhciBrPS9eW1xcXFx3Ll9dK0BbYS16XFxcXHUwMGExLVxcXFx1ZmZmZjAtOV8tXSs/XFxcXC5bYS16XFxcXHUwMGExLVxcXFx1ZmZmZjAtOV17Mix9JC9pO2sudGVzdChmKSYmIS9ebWFpbHRvOi4qL2kudGVzdChmKSYmKGY9XFxcIm1haWx0bzpcXFwiK2YpfWlmKFxcXCJcXFwiPT09Yi5vcHRzLmxpbmtBdXRvUHJlZml4fHwvXihtYWlsdG98dGVsfHNtc3xub3Rlc3xkYXRhKTouKi9pLnRlc3QoZil8fC9eZGF0YTppbWFnZS4qL2kudGVzdChmKXx8L14oaHR0cHM/OnxmdHBzPzp8ZmlsZTp8KVxcXFwvXFxcXC8vaS50ZXN0KGYpfHxbXFxcIi9cXFwiLFxcXCJ7XFxcIixcXFwiW1xcXCIsXFxcIiNcXFwiLFxcXCIoXFxcIl0uaW5kZXhPZigoZnx8XFxcIlxcXCIpWzBdKTwwJiYoZj1iLm9wdHMubGlua0F1dG9QcmVmaXgrZiksZj1iLmhlbHBlcnMuc2FuaXRpemVVUkwoZiksYi5vcHRzLmxpbmtBbHdheXNCbGFuayYmKGgudGFyZ2V0PVxcXCJfYmxhbmtcXFwiKSxiLm9wdHMubGlua0Fsd2F5c05vRm9sbG93JiYoaC5yZWw9XFxcIm5vZm9sbG93XFxcIiksZz1nfHxcXFwiXFxcIixmPT09Yi5vcHRzLmxpbmtBdXRvUHJlZml4KXt2YXIgbD1iLnBvcHVwcy5nZXQoXFxcImxpbmsuaW5zZXJ0XFxcIik7cmV0dXJuIGwuZmluZCgnaW5wdXRbbmFtZT1cXFwiaHJlZlxcXCJdJykuYWRkQ2xhc3MoXFxcImZyLWVycm9yXFxcIiksYi5ldmVudHMudHJpZ2dlcihcXFwibGluay5iYWRcXFwiLFtqXSksITF9dmFyIG0sbj1jKCk7aWYobil7bT1hKG4pO3ZhciBvPWIubm9kZS5yYXdBdHRyaWJ1dGVzKG4pO2Zvcih2YXIgcCBpbiBvKW8uaGFzT3duUHJvcGVydHkocCkmJlxcXCJjbGFzc1xcXCIhPXAmJlxcXCJzdHlsZVxcXCIhPXAmJm0ucmVtb3ZlQXR0cihwKTttLmF0dHIoXFxcImhyZWZcXFwiLGYpLGcubGVuZ3RoPjAmJm0udGV4dCgpIT1nJiYhaSYmbS50ZXh0KGcpLGl8fG0ucHJlcGVuZChhLkZFLlNUQVJUX01BUktFUikuYXBwZW5kKGEuRkUuRU5EX01BUktFUiksbS5hdHRyKGgpLGl8fGIuc2VsZWN0aW9uLnJlc3RvcmUoKX1lbHNle2k/aS53cmFwKCc8YSBocmVmPVxcXCInK2YrJ1xcXCI+PC9hPicpOihiLmZvcm1hdC5yZW1vdmUoXFxcImFcXFwiKSxiLnNlbGVjdGlvbi5pc0NvbGxhcHNlZCgpPyhnPTA9PT1nLmxlbmd0aD9qOmcsYi5odG1sLmluc2VydCgnPGEgaHJlZj1cXFwiJytmKydcXFwiPicrYS5GRS5TVEFSVF9NQVJLRVIrZythLkZFLkVORF9NQVJLRVIrXFxcIjwvYT5cXFwiKSxiLnNlbGVjdGlvbi5yZXN0b3JlKCkpOmcubGVuZ3RoPjAmJmchPWIuc2VsZWN0aW9uLnRleHQoKS5yZXBsYWNlKC9cXFxcbi9nLFxcXCJcXFwiKT8oYi5zZWxlY3Rpb24ucmVtb3ZlKCksYi5odG1sLmluc2VydCgnPGEgaHJlZj1cXFwiJytmKydcXFwiPicrYS5GRS5TVEFSVF9NQVJLRVIrZythLkZFLkVORF9NQVJLRVIrXFxcIjwvYT5cXFwiKSxiLnNlbGVjdGlvbi5yZXN0b3JlKCkpOihxKCksYi5mb3JtYXQuYXBwbHkoXFxcImFcXFwiLHtocmVmOmZ9KSkpO2Zvcih2YXIgcj1kKCkscz0wO3M8ci5sZW5ndGg7cysrKW09YShyW3NdKSxtLmF0dHIoaCksbS5yZW1vdmVBdHRyKFxcXCJfbW96X2RpcnR5XFxcIik7MT09ci5sZW5ndGgmJmIuJHdwJiYhaSYmKGEoclswXSkucHJlcGVuZChhLkZFLlNUQVJUX01BUktFUikuYXBwZW5kKGEuRkUuRU5EX01BUktFUiksYi5zZWxlY3Rpb24ucmVzdG9yZSgpKX1pZihpKXt2YXIgdD1iLnBvcHVwcy5nZXQoXFxcImxpbmsuaW5zZXJ0XFxcIik7dC5maW5kKFxcXCJpbnB1dDpmb2N1c1xcXCIpLmJsdXIoKSxiLmltYWdlLmVkaXQoaSl9ZWxzZSBlKCl9ZnVuY3Rpb24gcygpe2coKTt2YXIgZD1jKCk7aWYoZCl7dmFyIGU9Yi5wb3B1cHMuZ2V0KFxcXCJsaW5rLmluc2VydFxcXCIpO2V8fChlPWwoKSksYi5wb3B1cHMuaXNWaXNpYmxlKFxcXCJsaW5rLmluc2VydFxcXCIpfHwoYi5wb3B1cHMucmVmcmVzaChcXFwibGluay5pbnNlcnRcXFwiKSxiLnNlbGVjdGlvbi5zYXZlKCksYi5oZWxwZXJzLmlzTW9iaWxlKCkmJihiLmV2ZW50cy5kaXNhYmxlQmx1cigpLGIuJGVsLmJsdXIoKSxiLmV2ZW50cy5lbmFibGVCbHVyKCkpKSxiLnBvcHVwcy5zZXRDb250YWluZXIoXFxcImxpbmsuaW5zZXJ0XFxcIixhKGIub3B0cy5zY3JvbGxhYmxlQ29udGFpbmVyKSk7dmFyIGY9KGIuaW1hZ2U/Yi5pbWFnZS5nZXQoKTpudWxsKXx8YShkKSxoPWYub2Zmc2V0KCkubGVmdCtmLm91dGVyV2lkdGgoKS8yLGk9Zi5vZmZzZXQoKS50b3ArZi5vdXRlckhlaWdodCgpO2IucG9wdXBzLnNob3coXFxcImxpbmsuaW5zZXJ0XFxcIixoLGksZi5vdXRlckhlaWdodCgpKX19ZnVuY3Rpb24gdCgpe3ZhciBhPWIuaW1hZ2U/Yi5pbWFnZS5nZXQoKTpudWxsO2lmKGEpYi5pbWFnZS5iYWNrKCk7ZWxzZXtiLmV2ZW50cy5kaXNhYmxlQmx1cigpLGIuc2VsZWN0aW9uLnJlc3RvcmUoKSxiLmV2ZW50cy5lbmFibGVCbHVyKCk7dmFyIGQ9YygpO2QmJmIuJHdwPyhiLnNlbGVjdGlvbi5yZXN0b3JlKCksZygpLGUoKSk6XFxcIkFcXFwiPT1iLiRlbC5nZXQoMCkudGFnTmFtZT8oYi4kZWwuZm9jdXMoKSxlKCkpOihiLnBvcHVwcy5oaWRlKFxcXCJsaW5rLmluc2VydFxcXCIpLGIudG9vbGJhci5zaG93SW5saW5lKCkpfX1mdW5jdGlvbiB1KCl7dmFyIGM9Yi5pbWFnZT9iLmltYWdlLmdldCgpOm51bGw7aWYoYyl7dmFyIGQ9Yi5wb3B1cHMuZ2V0KFxcXCJsaW5rLmluc2VydFxcXCIpO2R8fChkPWwoKSksaighMCksYi5wb3B1cHMuc2V0Q29udGFpbmVyKFxcXCJsaW5rLmluc2VydFxcXCIsYShiLm9wdHMuc2Nyb2xsYWJsZUNvbnRhaW5lcikpO3ZhciBlPWMub2Zmc2V0KCkubGVmdCtjLm91dGVyV2lkdGgoKS8yLGY9Yy5vZmZzZXQoKS50b3ArYy5vdXRlckhlaWdodCgpO2IucG9wdXBzLnNob3coXFxcImxpbmsuaW5zZXJ0XFxcIixlLGYsYy5vdXRlckhlaWdodCgpKX19ZnVuY3Rpb24gdihkLGYsZyl7XFxcInVuZGVmaW5lZFxcXCI9PXR5cGVvZiBnJiYoZz1iLm9wdHMubGlua011bHRpcGxlU3R5bGVzKSxcXFwidW5kZWZpbmVkXFxcIj09dHlwZW9mIGYmJihmPWIub3B0cy5saW5rU3R5bGVzKTt2YXIgaD1jKCk7aWYoIWgpcmV0dXJuITE7aWYoIWcpe3ZhciBpPU9iamVjdC5rZXlzKGYpO2kuc3BsaWNlKGkuaW5kZXhPZihkKSwxKSxhKGgpLnJlbW92ZUNsYXNzKGkuam9pbihcXFwiIFxcXCIpKX1hKGgpLnRvZ2dsZUNsYXNzKGQpLGUoKX1yZXR1cm57X2luaXQ6bixyZW1vdmU6bSxzaG93SW5zZXJ0UG9wdXA6ayx1c2VQcmVkZWZpbmVkOm8saW5zZXJ0Q2FsbGJhY2s6cCxpbnNlcnQ6cix1cGRhdGU6cyxnZXQ6YyxhbGxTZWxlY3RlZDpkLGJhY2s6dCxpbWFnZUxpbms6dSxhcHBseVN0eWxlOnZ9fSxhLkZFLkRlZmluZUljb24oXFxcImluc2VydExpbmtcXFwiLHtOQU1FOlxcXCJsaW5rXFxcIn0pLGEuRkUuUmVnaXN0ZXJTaG9ydGN1dChhLkZFLktFWUNPREUuSyxcXFwiaW5zZXJ0TGlua1xcXCIsbnVsbCxcXFwiS1xcXCIpLGEuRkUuUmVnaXN0ZXJDb21tYW5kKFxcXCJpbnNlcnRMaW5rXFxcIix7dGl0bGU6XFxcIkluc2VydCBMaW5rXFxcIix1bmRvOiExLGZvY3VzOiEwLHJlZnJlc2hPbkNhbGxiYWNrOiExLHBvcHVwOiEwLGNhbGxiYWNrOmZ1bmN0aW9uKCl7dGhpcy5wb3B1cHMuaXNWaXNpYmxlKFxcXCJsaW5rLmluc2VydFxcXCIpPyh0aGlzLiRlbC5maW5kKFxcXCIuZnItbWFya2VyXFxcIikmJih0aGlzLmV2ZW50cy5kaXNhYmxlQmx1cigpLHRoaXMuc2VsZWN0aW9uLnJlc3RvcmUoKSksdGhpcy5wb3B1cHMuaGlkZShcXFwibGluay5pbnNlcnRcXFwiKSk6dGhpcy5saW5rLnNob3dJbnNlcnRQb3B1cCgpfSxwbHVnaW46XFxcImxpbmtcXFwifSksYS5GRS5EZWZpbmVJY29uKFxcXCJsaW5rT3BlblxcXCIse05BTUU6XFxcImV4dGVybmFsLWxpbmtcXFwifSksYS5GRS5SZWdpc3RlckNvbW1hbmQoXFxcImxpbmtPcGVuXFxcIix7dGl0bGU6XFxcIk9wZW4gTGlua1xcXCIsdW5kbzohMSxyZWZyZXNoOmZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMubGluay5nZXQoKTtiP2EucmVtb3ZlQ2xhc3MoXFxcImZyLWhpZGRlblxcXCIpOmEuYWRkQ2xhc3MoXFxcImZyLWhpZGRlblxcXCIpfSxjYWxsYmFjazpmdW5jdGlvbigpe3ZhciBhPXRoaXMubGluay5nZXQoKTthJiZ0aGlzLm9fd2luLm9wZW4oYS5ocmVmKX19KSxhLkZFLkRlZmluZUljb24oXFxcImxpbmtFZGl0XFxcIix7TkFNRTpcXFwiZWRpdFxcXCJ9KSxhLkZFLlJlZ2lzdGVyQ29tbWFuZChcXFwibGlua0VkaXRcXFwiLHt0aXRsZTpcXFwiRWRpdCBMaW5rXFxcIix1bmRvOiExLHJlZnJlc2hBZnRlckNhbGxiYWNrOiExLGNhbGxiYWNrOmZ1bmN0aW9uKCl7dGhpcy5saW5rLnVwZGF0ZSgpfSxyZWZyZXNoOmZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMubGluay5nZXQoKTtiP2EucmVtb3ZlQ2xhc3MoXFxcImZyLWhpZGRlblxcXCIpOmEuYWRkQ2xhc3MoXFxcImZyLWhpZGRlblxcXCIpfX0pLGEuRkUuRGVmaW5lSWNvbihcXFwibGlua1JlbW92ZVxcXCIse05BTUU6XFxcInVubGlua1xcXCJ9KSxhLkZFLlJlZ2lzdGVyQ29tbWFuZChcXFwibGlua1JlbW92ZVxcXCIse3RpdGxlOlxcXCJVbmxpbmtcXFwiLGNhbGxiYWNrOmZ1bmN0aW9uKCl7dGhpcy5saW5rLnJlbW92ZSgpfSxyZWZyZXNoOmZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMubGluay5nZXQoKTtiP2EucmVtb3ZlQ2xhc3MoXFxcImZyLWhpZGRlblxcXCIpOmEuYWRkQ2xhc3MoXFxcImZyLWhpZGRlblxcXCIpfX0pLGEuRkUuRGVmaW5lSWNvbihcXFwibGlua0JhY2tcXFwiLHtOQU1FOlxcXCJhcnJvdy1sZWZ0XFxcIn0pLGEuRkUuUmVnaXN0ZXJDb21tYW5kKFxcXCJsaW5rQmFja1xcXCIse3RpdGxlOlxcXCJCYWNrXFxcIix1bmRvOiExLGZvY3VzOiExLGJhY2s6ITAscmVmcmVzaEFmdGVyQ2FsbGJhY2s6ITEsY2FsbGJhY2s6ZnVuY3Rpb24oKXt0aGlzLmxpbmsuYmFjaygpfSxyZWZyZXNoOmZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMubGluay5nZXQoKSxjPXRoaXMuaW1hZ2U/dGhpcy5pbWFnZS5nZXQoKTpudWxsO2N8fGJ8fHRoaXMub3B0cy50b29sYmFySW5saW5lPyhhLnJlbW92ZUNsYXNzKFxcXCJmci1oaWRkZW5cXFwiKSxhLm5leHQoXFxcIi5mci1zZXBhcmF0b3JcXFwiKS5yZW1vdmVDbGFzcyhcXFwiZnItaGlkZGVuXFxcIikpOihhLmFkZENsYXNzKFxcXCJmci1oaWRkZW5cXFwiKSxhLm5leHQoXFxcIi5mci1zZXBhcmF0b3JcXFwiKS5hZGRDbGFzcyhcXFwiZnItaGlkZGVuXFxcIikpfX0pLGEuRkUuRGVmaW5lSWNvbihcXFwibGlua0xpc3RcXFwiLHtOQU1FOlxcXCJzZWFyY2hcXFwifSksYS5GRS5SZWdpc3RlckNvbW1hbmQoXFxcImxpbmtMaXN0XFxcIix7dGl0bGU6XFxcIkNob29zZSBMaW5rXFxcIix0eXBlOlxcXCJkcm9wZG93blxcXCIsZm9jdXM6ITEsdW5kbzohMSxyZWZyZXNoQWZ0ZXJDYWxsYmFjazohMSxodG1sOmZ1bmN0aW9uKCl7Zm9yKHZhciBhPSc8dWwgY2xhc3M9XFxcImZyLWRyb3Bkb3duLWxpc3RcXFwiPicsYj10aGlzLm9wdHMubGlua0xpc3QsYz0wO2M8Yi5sZW5ndGg7YysrKWErPSc8bGk+PGEgY2xhc3M9XFxcImZyLWNvbW1hbmRcXFwiIGRhdGEtY21kPVxcXCJsaW5rTGlzdFxcXCIgZGF0YS1wYXJhbTE9XFxcIicrYysnXFxcIj4nKyhiW2NdLmRpc3BsYXlUZXh0fHxiW2NdLnRleHQpK1xcXCI8L2E+PC9saT5cXFwiO3JldHVybiBhKz1cXFwiPC91bD5cXFwifSxjYWxsYmFjazpmdW5jdGlvbihhLGIpe3RoaXMubGluay51c2VQcmVkZWZpbmVkKGIpfX0pLGEuRkUuUmVnaXN0ZXJDb21tYW5kKFxcXCJsaW5rSW5zZXJ0XFxcIix7Zm9jdXM6ITEscmVmcmVzaEFmdGVyQ2FsbGJhY2s6ITEsY2FsbGJhY2s6ZnVuY3Rpb24oKXt0aGlzLmxpbmsuaW5zZXJ0Q2FsbGJhY2soKX0scmVmcmVzaDpmdW5jdGlvbihhKXt2YXIgYj10aGlzLmxpbmsuZ2V0KCk7Yj9hLnRleHQodGhpcy5sYW5ndWFnZS50cmFuc2xhdGUoXFxcIlVwZGF0ZVxcXCIpKTphLnRleHQodGhpcy5sYW5ndWFnZS50cmFuc2xhdGUoXFxcIkluc2VydFxcXCIpKX19KSxhLkZFLkRlZmluZUljb24oXFxcImltYWdlTGlua1xcXCIse05BTUU6XFxcImxpbmtcXFwifSksYS5GRS5SZWdpc3RlckNvbW1hbmQoXFxcImltYWdlTGlua1xcXCIse3RpdGxlOlxcXCJJbnNlcnQgTGlua1xcXCIsdW5kbzohMSxmb2N1czohMSxjYWxsYmFjazpmdW5jdGlvbigpe3RoaXMubGluay5pbWFnZUxpbmsoKX0scmVmcmVzaDpmdW5jdGlvbihhKXt2YXIgYixjPXRoaXMubGluay5nZXQoKTtjPyhiPWEucHJldigpLGIuaGFzQ2xhc3MoXFxcImZyLXNlcGFyYXRvclxcXCIpJiZiLnJlbW92ZUNsYXNzKFxcXCJmci1oaWRkZW5cXFwiKSxhLmFkZENsYXNzKFxcXCJmci1oaWRkZW5cXFwiKSk6KGI9YS5wcmV2KCksYi5oYXNDbGFzcyhcXFwiZnItc2VwYXJhdG9yXFxcIikmJmIuYWRkQ2xhc3MoXFxcImZyLWhpZGRlblxcXCIpLGEucmVtb3ZlQ2xhc3MoXFxcImZyLWhpZGRlblxcXCIpKX19KSxhLkZFLkRlZmluZUljb24oXFxcImxpbmtTdHlsZVxcXCIse05BTUU6XFxcIm1hZ2ljXFxcIn0pLGEuRkUuUmVnaXN0ZXJDb21tYW5kKFxcXCJsaW5rU3R5bGVcXFwiLHt0aXRsZTpcXFwiU3R5bGVcXFwiLHR5cGU6XFxcImRyb3Bkb3duXFxcIixodG1sOmZ1bmN0aW9uKCl7dmFyIGE9Jzx1bCBjbGFzcz1cXFwiZnItZHJvcGRvd24tbGlzdFxcXCI+JyxiPXRoaXMub3B0cy5saW5rU3R5bGVzO2Zvcih2YXIgYyBpbiBiKWIuaGFzT3duUHJvcGVydHkoYykmJihhKz0nPGxpPjxhIGNsYXNzPVxcXCJmci1jb21tYW5kXFxcIiBkYXRhLWNtZD1cXFwibGlua1N0eWxlXFxcIiBkYXRhLXBhcmFtMT1cXFwiJytjKydcXFwiPicrdGhpcy5sYW5ndWFnZS50cmFuc2xhdGUoYltjXSkrXFxcIjwvYT48L2xpPlxcXCIpO3JldHVybiBhKz1cXFwiPC91bD5cXFwifSxjYWxsYmFjazpmdW5jdGlvbihhLGIpe3RoaXMubGluay5hcHBseVN0eWxlKGIpfSxyZWZyZXNoT25TaG93OmZ1bmN0aW9uKGIsYyl7dmFyIGQ9dGhpcy5saW5rLmdldCgpO2lmKGQpe3ZhciBlPWEoZCk7Yy5maW5kKFxcXCIuZnItY29tbWFuZFxcXCIpLmVhY2goZnVuY3Rpb24oKXt2YXIgYj1hKHRoaXMpLmRhdGEoXFxcInBhcmFtMVxcXCIpO2EodGhpcykudG9nZ2xlQ2xhc3MoXFxcImZyLWFjdGl2ZVxcXCIsZS5oYXNDbGFzcyhiKSl9KX19fSl9KTtcIlxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3Jhdy1sb2FkZXIhLi9+L2Zyb2FsYS1lZGl0b3IvanMvcGx1Z2lucy9saW5rLm1pbi5qc1xuICoqIG1vZHVsZSBpZCA9IDE3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

	eval("__webpack_require__(2)(__webpack_require__(19))//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTguanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2Zyb2FsYS1lZGl0b3IvanMvcGx1Z2lucy91cmwubWluLmpzPzY2NWYiXSwic291cmNlc0NvbnRlbnQiOlsicmVxdWlyZShcIiEhL3Zhci9hcHAvd2ViL2pzL25vZGVfbW9kdWxlcy9zY3JpcHQtbG9hZGVyL2FkZFNjcmlwdC5qc1wiKShyZXF1aXJlKFwiISEvdmFyL2FwcC93ZWIvanMvbm9kZV9tb2R1bGVzL3Jhdy1sb2FkZXIvaW5kZXguanMhL3Zhci9hcHAvd2ViL2pzL25vZGVfbW9kdWxlcy9mcm9hbGEtZWRpdG9yL2pzL3BsdWdpbnMvdXJsLm1pbi5qc1wiKSlcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9zY3JpcHQtbG9hZGVyIS4vfi9mcm9hbGEtZWRpdG9yL2pzL3BsdWdpbnMvdXJsLm1pbi5qc1xuICoqIG1vZHVsZSBpZCA9IDE4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 19 */
/***/ function(module, exports) {

	eval("module.exports = \"/*!\\n * froala_editor v2.3.4 (https://www.froala.com/wysiwyg-editor)\\n * License https://froala.com/wysiwyg-editor/terms/\\n * Copyright 2014-2016 Froala Labs\\n */\\n\\n!function(a){\\\"function\\\"==typeof define&&define.amd?define([\\\"jquery\\\"],a):\\\"object\\\"==typeof module&&module.exports?module.exports=function(b,c){return void 0===c&&(c=\\\"undefined\\\"!=typeof window?require(\\\"jquery\\\"):require(\\\"jquery\\\")(b)),a(c),c}:a(jQuery)}(function(a){\\\"use strict\\\";a.extend(a.FE.DEFAULTS,{}),a.FE.URLRegEx=/(\\\\s|^|>)((http|https|ftp|ftps)\\\\:\\\\/\\\\/[a-zA-Z0-9\\\\-\\\\.]+(\\\\.[a-zA-Z]{2,3})?(:\\\\d*)?(\\\\/[^\\\\s<]*)?)(\\\\s|$|<)/gi,a.FE.PLUGINS.url=function(b){function c(d){d.each(function(){if(\\\"IFRAME\\\"!=this.tagName)if(3==this.nodeType){var d=this.textContent.replace(/&nbsp;/gi,\\\"\\\");a.FE.URLRegEx.test(d)&&(a(this).before(d.replace(a.FE.URLRegEx,'$1<a href=\\\"$2\\\">$2</a>$7')),a(this).remove())}else 1==this.nodeType&&[\\\"A\\\",\\\"BUTTON\\\",\\\"TEXTAREA\\\"].indexOf(this.tagName)<0&&c(b.node.contents(this))})}function d(){b.events.on(\\\"paste.afterCleanup\\\",function(b){return a.FE.URLRegEx.test(b)?b.replace(a.FE.URLRegEx,'$1<a href=\\\"$2\\\">$2</a>$7'):void 0}),b.events.on(\\\"keyup\\\",function(d){var e=d.which;(e==a.FE.KEYCODE.ENTER||e==a.FE.KEYCODE.SPACE)&&c(b.node.contents(b.$el.get(0)))}),b.events.on(\\\"keydown\\\",function(c){var d=c.which;if(d==a.FE.KEYCODE.ENTER){var e=b.selection.element();if((\\\"A\\\"==e.tagName||a(e).parents(\\\"a\\\").length)&&b.selection.info(e).atEnd)return c.stopImmediatePropagation(),\\\"A\\\"!==e.tagName&&(e=a(e).parents(\\\"a\\\")[0]),a(e).after(\\\"&nbsp;\\\"+a.FE.MARKERS),b.selection.restore(),!1}})}return{_init:d}}});\"//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTkuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2Zyb2FsYS1lZGl0b3IvanMvcGx1Z2lucy91cmwubWluLmpzP2E1NmIiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBcIi8qIVxcbiAqIGZyb2FsYV9lZGl0b3IgdjIuMy40IChodHRwczovL3d3dy5mcm9hbGEuY29tL3d5c2l3eWctZWRpdG9yKVxcbiAqIExpY2Vuc2UgaHR0cHM6Ly9mcm9hbGEuY29tL3d5c2l3eWctZWRpdG9yL3Rlcm1zL1xcbiAqIENvcHlyaWdodCAyMDE0LTIwMTYgRnJvYWxhIExhYnNcXG4gKi9cXG5cXG4hZnVuY3Rpb24oYSl7XFxcImZ1bmN0aW9uXFxcIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUoW1xcXCJqcXVlcnlcXFwiXSxhKTpcXFwib2JqZWN0XFxcIj09dHlwZW9mIG1vZHVsZSYmbW9kdWxlLmV4cG9ydHM/bW9kdWxlLmV4cG9ydHM9ZnVuY3Rpb24oYixjKXtyZXR1cm4gdm9pZCAwPT09YyYmKGM9XFxcInVuZGVmaW5lZFxcXCIhPXR5cGVvZiB3aW5kb3c/cmVxdWlyZShcXFwianF1ZXJ5XFxcIik6cmVxdWlyZShcXFwianF1ZXJ5XFxcIikoYikpLGEoYyksY306YShqUXVlcnkpfShmdW5jdGlvbihhKXtcXFwidXNlIHN0cmljdFxcXCI7YS5leHRlbmQoYS5GRS5ERUZBVUxUUyx7fSksYS5GRS5VUkxSZWdFeD0vKFxcXFxzfF58PikoKGh0dHB8aHR0cHN8ZnRwfGZ0cHMpXFxcXDpcXFxcL1xcXFwvW2EtekEtWjAtOVxcXFwtXFxcXC5dKyhcXFxcLlthLXpBLVpdezIsM30pPyg6XFxcXGQqKT8oXFxcXC9bXlxcXFxzPF0qKT8pKFxcXFxzfCR8PCkvZ2ksYS5GRS5QTFVHSU5TLnVybD1mdW5jdGlvbihiKXtmdW5jdGlvbiBjKGQpe2QuZWFjaChmdW5jdGlvbigpe2lmKFxcXCJJRlJBTUVcXFwiIT10aGlzLnRhZ05hbWUpaWYoMz09dGhpcy5ub2RlVHlwZSl7dmFyIGQ9dGhpcy50ZXh0Q29udGVudC5yZXBsYWNlKC8mbmJzcDsvZ2ksXFxcIlxcXCIpO2EuRkUuVVJMUmVnRXgudGVzdChkKSYmKGEodGhpcykuYmVmb3JlKGQucmVwbGFjZShhLkZFLlVSTFJlZ0V4LCckMTxhIGhyZWY9XFxcIiQyXFxcIj4kMjwvYT4kNycpKSxhKHRoaXMpLnJlbW92ZSgpKX1lbHNlIDE9PXRoaXMubm9kZVR5cGUmJltcXFwiQVxcXCIsXFxcIkJVVFRPTlxcXCIsXFxcIlRFWFRBUkVBXFxcIl0uaW5kZXhPZih0aGlzLnRhZ05hbWUpPDAmJmMoYi5ub2RlLmNvbnRlbnRzKHRoaXMpKX0pfWZ1bmN0aW9uIGQoKXtiLmV2ZW50cy5vbihcXFwicGFzdGUuYWZ0ZXJDbGVhbnVwXFxcIixmdW5jdGlvbihiKXtyZXR1cm4gYS5GRS5VUkxSZWdFeC50ZXN0KGIpP2IucmVwbGFjZShhLkZFLlVSTFJlZ0V4LCckMTxhIGhyZWY9XFxcIiQyXFxcIj4kMjwvYT4kNycpOnZvaWQgMH0pLGIuZXZlbnRzLm9uKFxcXCJrZXl1cFxcXCIsZnVuY3Rpb24oZCl7dmFyIGU9ZC53aGljaDsoZT09YS5GRS5LRVlDT0RFLkVOVEVSfHxlPT1hLkZFLktFWUNPREUuU1BBQ0UpJiZjKGIubm9kZS5jb250ZW50cyhiLiRlbC5nZXQoMCkpKX0pLGIuZXZlbnRzLm9uKFxcXCJrZXlkb3duXFxcIixmdW5jdGlvbihjKXt2YXIgZD1jLndoaWNoO2lmKGQ9PWEuRkUuS0VZQ09ERS5FTlRFUil7dmFyIGU9Yi5zZWxlY3Rpb24uZWxlbWVudCgpO2lmKChcXFwiQVxcXCI9PWUudGFnTmFtZXx8YShlKS5wYXJlbnRzKFxcXCJhXFxcIikubGVuZ3RoKSYmYi5zZWxlY3Rpb24uaW5mbyhlKS5hdEVuZClyZXR1cm4gYy5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKSxcXFwiQVxcXCIhPT1lLnRhZ05hbWUmJihlPWEoZSkucGFyZW50cyhcXFwiYVxcXCIpWzBdKSxhKGUpLmFmdGVyKFxcXCImbmJzcDtcXFwiK2EuRkUuTUFSS0VSUyksYi5zZWxlY3Rpb24ucmVzdG9yZSgpLCExfX0pfXJldHVybntfaW5pdDpkfX19KTtcIlxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3Jhdy1sb2FkZXIhLi9+L2Zyb2FsYS1lZGl0b3IvanMvcGx1Z2lucy91cmwubWluLmpzXG4gKiogbW9kdWxlIGlkID0gMTlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {

	eval("__webpack_require__(2)(__webpack_require__(21))//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjAuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2Zyb2FsYS1lZGl0b3IvanMvbGFuZ3VhZ2VzL2VuX2diLmpzPzczYTgiXSwic291cmNlc0NvbnRlbnQiOlsicmVxdWlyZShcIiEhL3Zhci9hcHAvd2ViL2pzL25vZGVfbW9kdWxlcy9zY3JpcHQtbG9hZGVyL2FkZFNjcmlwdC5qc1wiKShyZXF1aXJlKFwiISEvdmFyL2FwcC93ZWIvanMvbm9kZV9tb2R1bGVzL3Jhdy1sb2FkZXIvaW5kZXguanMhL3Zhci9hcHAvd2ViL2pzL25vZGVfbW9kdWxlcy9mcm9hbGEtZWRpdG9yL2pzL2xhbmd1YWdlcy9lbl9nYi5qc1wiKSlcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9zY3JpcHQtbG9hZGVyIS4vfi9mcm9hbGEtZWRpdG9yL2pzL2xhbmd1YWdlcy9lbl9nYi5qc1xuICoqIG1vZHVsZSBpZCA9IDIwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 21 */
/***/ function(module, exports) {

	eval("module.exports = \"/*!\\n * froala_editor v2.3.4 (https://www.froala.com/wysiwyg-editor)\\n * License https://froala.com/wysiwyg-editor/terms/\\n * Copyright 2014-2016 Froala Labs\\n */\\n\\n/**\\n * English spoken in Great Britain\\n */\\n\\n$.FE.LANGUAGE['en_gb'] = {\\n  translation: {\\n    // Place holder\\n    \\\"Type something\\\": \\\"Type something\\\",\\n\\n    // Basic formatting\\n    \\\"Bold\\\": \\\"Bold\\\",\\n    \\\"Italic\\\": \\\"Italic\\\",\\n    \\\"Underline\\\": \\\"Underline\\\",\\n    \\\"Strikethrough\\\": \\\"Strikethrough\\\",\\n\\n    // Main buttons\\n    \\\"Insert\\\": \\\"Insert\\\",\\n    \\\"Delete\\\": \\\"Delete\\\",\\n    \\\"Cancel\\\": \\\"Cancel\\\",\\n    \\\"OK\\\": \\\"OK\\\",\\n    \\\"Back\\\": \\\"Back\\\",\\n    \\\"Remove\\\": \\\"Remove\\\",\\n    \\\"More\\\": \\\"More\\\",\\n    \\\"Update\\\": \\\"Update\\\",\\n    \\\"Style\\\": \\\"Style\\\",\\n\\n    // Font\\n    \\\"Font Family\\\": \\\"Font Family\\\",\\n    \\\"Font Size\\\": \\\"Font Size\\\",\\n\\n    // Colors\\n    \\\"Colors\\\": \\\"Colours\\\",\\n    \\\"Background\\\": \\\"Background\\\",\\n    \\\"Text\\\": \\\"Text\\\",\\n\\n    // Paragraphs\\n    \\\"Paragraph Format\\\": \\\"Paragraph Format\\\",\\n    \\\"Normal\\\": \\\"Normal\\\",\\n    \\\"Code\\\": \\\"Code\\\",\\n    \\\"Heading 1\\\": \\\"Heading 1\\\",\\n    \\\"Heading 2\\\": \\\"Heading 2\\\",\\n    \\\"Heading 3\\\": \\\"Heading 3\\\",\\n    \\\"Heading 4\\\": \\\"Heading 4\\\",\\n\\n    // Style\\n    \\\"Paragraph Style\\\": \\\"Paragraph Style\\\",\\n    \\\"Inline Style\\\": \\\"Inline Style\\\",\\n\\n    // Alignment\\n    \\\"Align\\\": \\\"Align\\\",\\n    \\\"Align Left\\\": \\\"Align Left\\\",\\n    \\\"Align Center\\\": \\\"Align Centre\\\",\\n    \\\"Align Right\\\": \\\"Alight Right\\\",\\n    \\\"Align Justify\\\": \\\"Align Justify\\\",\\n    \\\"None\\\": \\\"None\\\",\\n\\n    // Lists\\n    \\\"Ordered List\\\": \\\"Ordered List\\\",\\n    \\\"Unordered List\\\": \\\"Unordered List\\\",\\n\\n    // Indent\\n    \\\"Decrease Indent\\\": \\\"Decrease Indent\\\",\\n    \\\"Increase Indent\\\": \\\"Increase Indent\\\",\\n\\n    // Links\\n    \\\"Insert Link\\\": \\\"Insert Link\\\",\\n    \\\"Open in new tab\\\": \\\"Open in new tab\\\",\\n    \\\"Open Link\\\": \\\"Open Link\\\",\\n    \\\"Edit Link\\\": \\\"Edit Link\\\",\\n    \\\"Unlink\\\": \\\"Unlink\\\",\\n    \\\"Choose Link\\\": \\\"Choose Link\\\",\\n\\n    // Images\\n    \\\"Insert Image\\\": \\\"Insert Image\\\",\\n    \\\"Upload Image\\\": \\\"Upload Image\\\",\\n    \\\"By URL\\\": \\\"By URL\\\",\\n    \\\"Browse\\\": \\\"Browse\\\",\\n    \\\"Drop image\\\": \\\"Drop image\\\",\\n    \\\"or click\\\": \\\"or click\\\",\\n    \\\"Manage Images\\\": \\\"Manage Images\\\",\\n    \\\"Loading\\\": \\\"Loading\\\",\\n    \\\"Deleting\\\": \\\"Deleting\\\",\\n    \\\"Tags\\\": \\\"Tags\\\",\\n    \\\"Are you sure? Image will be deleted.\\\": \\\"Are you sure? Image will be deleted.\\\",\\n    \\\"Replace\\\": \\\"Replace\\\",\\n    \\\"Uploading\\\": \\\"Uploading\\\",\\n    \\\"Loading image\\\": \\\"Loading image\\\",\\n    \\\"Display\\\": \\\"Display\\\",\\n    \\\"Inline\\\": \\\"Inline\\\",\\n    \\\"Break Text\\\": \\\"Break Text\\\",\\n    \\\"Alternate Text\\\": \\\"Alternate Text\\\",\\n    \\\"Change Size\\\": \\\"Change Size\\\",\\n    \\\"Width\\\": \\\"Width\\\",\\n    \\\"Height\\\": \\\"Height\\\",\\n    \\\"Something went wrong. Please try again.\\\": \\\"Something went wrong. Please try again.\\\",\\n\\n    // Video\\n    \\\"Insert Video\\\": \\\"Insert Video\\\",\\n    \\\"Embedded Code\\\": \\\"Embedded Code\\\",\\n\\n    // Tables\\n    \\\"Insert Table\\\": \\\"Insert Table\\\",\\n    \\\"Table Header\\\": \\\"Table Header\\\",\\n    \\\"Remove Table\\\": \\\"Remove Table\\\",\\n    \\\"Table Style\\\": \\\"Table Style\\\",\\n    \\\"Horizontal Align\\\": \\\"Horizontal Align\\\",\\n    \\\"Row\\\": \\\"Row\\\",\\n    \\\"Insert row above\\\": \\\"Insert row above\\\",\\n    \\\"Insert row below\\\": \\\"Insert row below\\\",\\n    \\\"Delete row\\\": \\\"Delete row\\\",\\n    \\\"Column\\\": \\\"Column\\\",\\n    \\\"Insert column before\\\": \\\"Insert column before\\\",\\n    \\\"Insert column after\\\": \\\"Insert column after\\\",\\n    \\\"Delete column\\\": \\\"Delete column\\\",\\n    \\\"Cell\\\": \\\"Cell\\\",\\n    \\\"Merge cells\\\": \\\"Merge cells\\\",\\n    \\\"Horizontal split\\\": \\\"Horizontal split\\\",\\n    \\\"Vertical split\\\": \\\"Vertical split\\\",\\n    \\\"Cell Background\\\": \\\"Cell Background\\\",\\n    \\\"Vertical Align\\\": \\\"Vertical Align\\\",\\n    \\\"Top\\\": \\\"Top\\\",\\n    \\\"Middle\\\": \\\"Middle\\\",\\n    \\\"Bottom\\\": \\\"Bottom\\\",\\n    \\\"Align Top\\\": \\\"Align Top\\\",\\n    \\\"Align Middle\\\": \\\"Align Middle\\\",\\n    \\\"Align Bottom\\\": \\\"Align Bottom\\\",\\n    \\\"Cell Style\\\": \\\"Cell Style\\\",\\n\\n    // Files\\n    \\\"Upload File\\\": \\\"Upload File\\\",\\n    \\\"Drop file\\\": \\\"Drop file\\\",\\n\\n    // Emoticons\\n    \\\"Emoticons\\\": \\\"Emoticons\\\",\\n\\n    // Line breaker\\n    \\\"Break\\\": \\\"Break\\\",\\n\\n    // Math\\n    \\\"Subscript\\\": \\\"Subscript\\\",\\n    \\\"Superscript\\\": \\\"Superscript\\\",\\n\\n    // Full screen\\n    \\\"Fullscreen\\\": \\\"Fullscreen\\\",\\n\\n    // Horizontal line\\n    \\\"Insert Horizontal Line\\\": \\\"Insert Horizontal Line\\\",\\n\\n    // Clear formatting\\n    \\\"Clear Formatting\\\": \\\"Cell Formatting\\\",\\n\\n    // Undo, redo\\n    \\\"Undo\\\": \\\"Undo\\\",\\n    \\\"Redo\\\": \\\"Redo\\\",\\n\\n    // Select all\\n    \\\"Select All\\\": \\\"Select All\\\",\\n\\n    // Code view\\n    \\\"Code View\\\": \\\"Code View\\\",\\n\\n    // Quote\\n    \\\"Quote\\\": \\\"Quote\\\",\\n    \\\"Increase\\\": \\\"Increase\\\",\\n    \\\"Decrease\\\": \\\"Decrease\\\",\\n\\n    // Quick Insert\\n    \\\"Quick Insert\\\": \\\"Quick Insert\\\"\\n  },\\n  direction: \\\"ltr\\\"\\n};\\n\"//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjEuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2Zyb2FsYS1lZGl0b3IvanMvbGFuZ3VhZ2VzL2VuX2diLmpzP2U4NTUiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBcIi8qIVxcbiAqIGZyb2FsYV9lZGl0b3IgdjIuMy40IChodHRwczovL3d3dy5mcm9hbGEuY29tL3d5c2l3eWctZWRpdG9yKVxcbiAqIExpY2Vuc2UgaHR0cHM6Ly9mcm9hbGEuY29tL3d5c2l3eWctZWRpdG9yL3Rlcm1zL1xcbiAqIENvcHlyaWdodCAyMDE0LTIwMTYgRnJvYWxhIExhYnNcXG4gKi9cXG5cXG4vKipcXG4gKiBFbmdsaXNoIHNwb2tlbiBpbiBHcmVhdCBCcml0YWluXFxuICovXFxuXFxuJC5GRS5MQU5HVUFHRVsnZW5fZ2InXSA9IHtcXG4gIHRyYW5zbGF0aW9uOiB7XFxuICAgIC8vIFBsYWNlIGhvbGRlclxcbiAgICBcXFwiVHlwZSBzb21ldGhpbmdcXFwiOiBcXFwiVHlwZSBzb21ldGhpbmdcXFwiLFxcblxcbiAgICAvLyBCYXNpYyBmb3JtYXR0aW5nXFxuICAgIFxcXCJCb2xkXFxcIjogXFxcIkJvbGRcXFwiLFxcbiAgICBcXFwiSXRhbGljXFxcIjogXFxcIkl0YWxpY1xcXCIsXFxuICAgIFxcXCJVbmRlcmxpbmVcXFwiOiBcXFwiVW5kZXJsaW5lXFxcIixcXG4gICAgXFxcIlN0cmlrZXRocm91Z2hcXFwiOiBcXFwiU3RyaWtldGhyb3VnaFxcXCIsXFxuXFxuICAgIC8vIE1haW4gYnV0dG9uc1xcbiAgICBcXFwiSW5zZXJ0XFxcIjogXFxcIkluc2VydFxcXCIsXFxuICAgIFxcXCJEZWxldGVcXFwiOiBcXFwiRGVsZXRlXFxcIixcXG4gICAgXFxcIkNhbmNlbFxcXCI6IFxcXCJDYW5jZWxcXFwiLFxcbiAgICBcXFwiT0tcXFwiOiBcXFwiT0tcXFwiLFxcbiAgICBcXFwiQmFja1xcXCI6IFxcXCJCYWNrXFxcIixcXG4gICAgXFxcIlJlbW92ZVxcXCI6IFxcXCJSZW1vdmVcXFwiLFxcbiAgICBcXFwiTW9yZVxcXCI6IFxcXCJNb3JlXFxcIixcXG4gICAgXFxcIlVwZGF0ZVxcXCI6IFxcXCJVcGRhdGVcXFwiLFxcbiAgICBcXFwiU3R5bGVcXFwiOiBcXFwiU3R5bGVcXFwiLFxcblxcbiAgICAvLyBGb250XFxuICAgIFxcXCJGb250IEZhbWlseVxcXCI6IFxcXCJGb250IEZhbWlseVxcXCIsXFxuICAgIFxcXCJGb250IFNpemVcXFwiOiBcXFwiRm9udCBTaXplXFxcIixcXG5cXG4gICAgLy8gQ29sb3JzXFxuICAgIFxcXCJDb2xvcnNcXFwiOiBcXFwiQ29sb3Vyc1xcXCIsXFxuICAgIFxcXCJCYWNrZ3JvdW5kXFxcIjogXFxcIkJhY2tncm91bmRcXFwiLFxcbiAgICBcXFwiVGV4dFxcXCI6IFxcXCJUZXh0XFxcIixcXG5cXG4gICAgLy8gUGFyYWdyYXBoc1xcbiAgICBcXFwiUGFyYWdyYXBoIEZvcm1hdFxcXCI6IFxcXCJQYXJhZ3JhcGggRm9ybWF0XFxcIixcXG4gICAgXFxcIk5vcm1hbFxcXCI6IFxcXCJOb3JtYWxcXFwiLFxcbiAgICBcXFwiQ29kZVxcXCI6IFxcXCJDb2RlXFxcIixcXG4gICAgXFxcIkhlYWRpbmcgMVxcXCI6IFxcXCJIZWFkaW5nIDFcXFwiLFxcbiAgICBcXFwiSGVhZGluZyAyXFxcIjogXFxcIkhlYWRpbmcgMlxcXCIsXFxuICAgIFxcXCJIZWFkaW5nIDNcXFwiOiBcXFwiSGVhZGluZyAzXFxcIixcXG4gICAgXFxcIkhlYWRpbmcgNFxcXCI6IFxcXCJIZWFkaW5nIDRcXFwiLFxcblxcbiAgICAvLyBTdHlsZVxcbiAgICBcXFwiUGFyYWdyYXBoIFN0eWxlXFxcIjogXFxcIlBhcmFncmFwaCBTdHlsZVxcXCIsXFxuICAgIFxcXCJJbmxpbmUgU3R5bGVcXFwiOiBcXFwiSW5saW5lIFN0eWxlXFxcIixcXG5cXG4gICAgLy8gQWxpZ25tZW50XFxuICAgIFxcXCJBbGlnblxcXCI6IFxcXCJBbGlnblxcXCIsXFxuICAgIFxcXCJBbGlnbiBMZWZ0XFxcIjogXFxcIkFsaWduIExlZnRcXFwiLFxcbiAgICBcXFwiQWxpZ24gQ2VudGVyXFxcIjogXFxcIkFsaWduIENlbnRyZVxcXCIsXFxuICAgIFxcXCJBbGlnbiBSaWdodFxcXCI6IFxcXCJBbGlnaHQgUmlnaHRcXFwiLFxcbiAgICBcXFwiQWxpZ24gSnVzdGlmeVxcXCI6IFxcXCJBbGlnbiBKdXN0aWZ5XFxcIixcXG4gICAgXFxcIk5vbmVcXFwiOiBcXFwiTm9uZVxcXCIsXFxuXFxuICAgIC8vIExpc3RzXFxuICAgIFxcXCJPcmRlcmVkIExpc3RcXFwiOiBcXFwiT3JkZXJlZCBMaXN0XFxcIixcXG4gICAgXFxcIlVub3JkZXJlZCBMaXN0XFxcIjogXFxcIlVub3JkZXJlZCBMaXN0XFxcIixcXG5cXG4gICAgLy8gSW5kZW50XFxuICAgIFxcXCJEZWNyZWFzZSBJbmRlbnRcXFwiOiBcXFwiRGVjcmVhc2UgSW5kZW50XFxcIixcXG4gICAgXFxcIkluY3JlYXNlIEluZGVudFxcXCI6IFxcXCJJbmNyZWFzZSBJbmRlbnRcXFwiLFxcblxcbiAgICAvLyBMaW5rc1xcbiAgICBcXFwiSW5zZXJ0IExpbmtcXFwiOiBcXFwiSW5zZXJ0IExpbmtcXFwiLFxcbiAgICBcXFwiT3BlbiBpbiBuZXcgdGFiXFxcIjogXFxcIk9wZW4gaW4gbmV3IHRhYlxcXCIsXFxuICAgIFxcXCJPcGVuIExpbmtcXFwiOiBcXFwiT3BlbiBMaW5rXFxcIixcXG4gICAgXFxcIkVkaXQgTGlua1xcXCI6IFxcXCJFZGl0IExpbmtcXFwiLFxcbiAgICBcXFwiVW5saW5rXFxcIjogXFxcIlVubGlua1xcXCIsXFxuICAgIFxcXCJDaG9vc2UgTGlua1xcXCI6IFxcXCJDaG9vc2UgTGlua1xcXCIsXFxuXFxuICAgIC8vIEltYWdlc1xcbiAgICBcXFwiSW5zZXJ0IEltYWdlXFxcIjogXFxcIkluc2VydCBJbWFnZVxcXCIsXFxuICAgIFxcXCJVcGxvYWQgSW1hZ2VcXFwiOiBcXFwiVXBsb2FkIEltYWdlXFxcIixcXG4gICAgXFxcIkJ5IFVSTFxcXCI6IFxcXCJCeSBVUkxcXFwiLFxcbiAgICBcXFwiQnJvd3NlXFxcIjogXFxcIkJyb3dzZVxcXCIsXFxuICAgIFxcXCJEcm9wIGltYWdlXFxcIjogXFxcIkRyb3AgaW1hZ2VcXFwiLFxcbiAgICBcXFwib3IgY2xpY2tcXFwiOiBcXFwib3IgY2xpY2tcXFwiLFxcbiAgICBcXFwiTWFuYWdlIEltYWdlc1xcXCI6IFxcXCJNYW5hZ2UgSW1hZ2VzXFxcIixcXG4gICAgXFxcIkxvYWRpbmdcXFwiOiBcXFwiTG9hZGluZ1xcXCIsXFxuICAgIFxcXCJEZWxldGluZ1xcXCI6IFxcXCJEZWxldGluZ1xcXCIsXFxuICAgIFxcXCJUYWdzXFxcIjogXFxcIlRhZ3NcXFwiLFxcbiAgICBcXFwiQXJlIHlvdSBzdXJlPyBJbWFnZSB3aWxsIGJlIGRlbGV0ZWQuXFxcIjogXFxcIkFyZSB5b3Ugc3VyZT8gSW1hZ2Ugd2lsbCBiZSBkZWxldGVkLlxcXCIsXFxuICAgIFxcXCJSZXBsYWNlXFxcIjogXFxcIlJlcGxhY2VcXFwiLFxcbiAgICBcXFwiVXBsb2FkaW5nXFxcIjogXFxcIlVwbG9hZGluZ1xcXCIsXFxuICAgIFxcXCJMb2FkaW5nIGltYWdlXFxcIjogXFxcIkxvYWRpbmcgaW1hZ2VcXFwiLFxcbiAgICBcXFwiRGlzcGxheVxcXCI6IFxcXCJEaXNwbGF5XFxcIixcXG4gICAgXFxcIklubGluZVxcXCI6IFxcXCJJbmxpbmVcXFwiLFxcbiAgICBcXFwiQnJlYWsgVGV4dFxcXCI6IFxcXCJCcmVhayBUZXh0XFxcIixcXG4gICAgXFxcIkFsdGVybmF0ZSBUZXh0XFxcIjogXFxcIkFsdGVybmF0ZSBUZXh0XFxcIixcXG4gICAgXFxcIkNoYW5nZSBTaXplXFxcIjogXFxcIkNoYW5nZSBTaXplXFxcIixcXG4gICAgXFxcIldpZHRoXFxcIjogXFxcIldpZHRoXFxcIixcXG4gICAgXFxcIkhlaWdodFxcXCI6IFxcXCJIZWlnaHRcXFwiLFxcbiAgICBcXFwiU29tZXRoaW5nIHdlbnQgd3JvbmcuIFBsZWFzZSB0cnkgYWdhaW4uXFxcIjogXFxcIlNvbWV0aGluZyB3ZW50IHdyb25nLiBQbGVhc2UgdHJ5IGFnYWluLlxcXCIsXFxuXFxuICAgIC8vIFZpZGVvXFxuICAgIFxcXCJJbnNlcnQgVmlkZW9cXFwiOiBcXFwiSW5zZXJ0IFZpZGVvXFxcIixcXG4gICAgXFxcIkVtYmVkZGVkIENvZGVcXFwiOiBcXFwiRW1iZWRkZWQgQ29kZVxcXCIsXFxuXFxuICAgIC8vIFRhYmxlc1xcbiAgICBcXFwiSW5zZXJ0IFRhYmxlXFxcIjogXFxcIkluc2VydCBUYWJsZVxcXCIsXFxuICAgIFxcXCJUYWJsZSBIZWFkZXJcXFwiOiBcXFwiVGFibGUgSGVhZGVyXFxcIixcXG4gICAgXFxcIlJlbW92ZSBUYWJsZVxcXCI6IFxcXCJSZW1vdmUgVGFibGVcXFwiLFxcbiAgICBcXFwiVGFibGUgU3R5bGVcXFwiOiBcXFwiVGFibGUgU3R5bGVcXFwiLFxcbiAgICBcXFwiSG9yaXpvbnRhbCBBbGlnblxcXCI6IFxcXCJIb3Jpem9udGFsIEFsaWduXFxcIixcXG4gICAgXFxcIlJvd1xcXCI6IFxcXCJSb3dcXFwiLFxcbiAgICBcXFwiSW5zZXJ0IHJvdyBhYm92ZVxcXCI6IFxcXCJJbnNlcnQgcm93IGFib3ZlXFxcIixcXG4gICAgXFxcIkluc2VydCByb3cgYmVsb3dcXFwiOiBcXFwiSW5zZXJ0IHJvdyBiZWxvd1xcXCIsXFxuICAgIFxcXCJEZWxldGUgcm93XFxcIjogXFxcIkRlbGV0ZSByb3dcXFwiLFxcbiAgICBcXFwiQ29sdW1uXFxcIjogXFxcIkNvbHVtblxcXCIsXFxuICAgIFxcXCJJbnNlcnQgY29sdW1uIGJlZm9yZVxcXCI6IFxcXCJJbnNlcnQgY29sdW1uIGJlZm9yZVxcXCIsXFxuICAgIFxcXCJJbnNlcnQgY29sdW1uIGFmdGVyXFxcIjogXFxcIkluc2VydCBjb2x1bW4gYWZ0ZXJcXFwiLFxcbiAgICBcXFwiRGVsZXRlIGNvbHVtblxcXCI6IFxcXCJEZWxldGUgY29sdW1uXFxcIixcXG4gICAgXFxcIkNlbGxcXFwiOiBcXFwiQ2VsbFxcXCIsXFxuICAgIFxcXCJNZXJnZSBjZWxsc1xcXCI6IFxcXCJNZXJnZSBjZWxsc1xcXCIsXFxuICAgIFxcXCJIb3Jpem9udGFsIHNwbGl0XFxcIjogXFxcIkhvcml6b250YWwgc3BsaXRcXFwiLFxcbiAgICBcXFwiVmVydGljYWwgc3BsaXRcXFwiOiBcXFwiVmVydGljYWwgc3BsaXRcXFwiLFxcbiAgICBcXFwiQ2VsbCBCYWNrZ3JvdW5kXFxcIjogXFxcIkNlbGwgQmFja2dyb3VuZFxcXCIsXFxuICAgIFxcXCJWZXJ0aWNhbCBBbGlnblxcXCI6IFxcXCJWZXJ0aWNhbCBBbGlnblxcXCIsXFxuICAgIFxcXCJUb3BcXFwiOiBcXFwiVG9wXFxcIixcXG4gICAgXFxcIk1pZGRsZVxcXCI6IFxcXCJNaWRkbGVcXFwiLFxcbiAgICBcXFwiQm90dG9tXFxcIjogXFxcIkJvdHRvbVxcXCIsXFxuICAgIFxcXCJBbGlnbiBUb3BcXFwiOiBcXFwiQWxpZ24gVG9wXFxcIixcXG4gICAgXFxcIkFsaWduIE1pZGRsZVxcXCI6IFxcXCJBbGlnbiBNaWRkbGVcXFwiLFxcbiAgICBcXFwiQWxpZ24gQm90dG9tXFxcIjogXFxcIkFsaWduIEJvdHRvbVxcXCIsXFxuICAgIFxcXCJDZWxsIFN0eWxlXFxcIjogXFxcIkNlbGwgU3R5bGVcXFwiLFxcblxcbiAgICAvLyBGaWxlc1xcbiAgICBcXFwiVXBsb2FkIEZpbGVcXFwiOiBcXFwiVXBsb2FkIEZpbGVcXFwiLFxcbiAgICBcXFwiRHJvcCBmaWxlXFxcIjogXFxcIkRyb3AgZmlsZVxcXCIsXFxuXFxuICAgIC8vIEVtb3RpY29uc1xcbiAgICBcXFwiRW1vdGljb25zXFxcIjogXFxcIkVtb3RpY29uc1xcXCIsXFxuXFxuICAgIC8vIExpbmUgYnJlYWtlclxcbiAgICBcXFwiQnJlYWtcXFwiOiBcXFwiQnJlYWtcXFwiLFxcblxcbiAgICAvLyBNYXRoXFxuICAgIFxcXCJTdWJzY3JpcHRcXFwiOiBcXFwiU3Vic2NyaXB0XFxcIixcXG4gICAgXFxcIlN1cGVyc2NyaXB0XFxcIjogXFxcIlN1cGVyc2NyaXB0XFxcIixcXG5cXG4gICAgLy8gRnVsbCBzY3JlZW5cXG4gICAgXFxcIkZ1bGxzY3JlZW5cXFwiOiBcXFwiRnVsbHNjcmVlblxcXCIsXFxuXFxuICAgIC8vIEhvcml6b250YWwgbGluZVxcbiAgICBcXFwiSW5zZXJ0IEhvcml6b250YWwgTGluZVxcXCI6IFxcXCJJbnNlcnQgSG9yaXpvbnRhbCBMaW5lXFxcIixcXG5cXG4gICAgLy8gQ2xlYXIgZm9ybWF0dGluZ1xcbiAgICBcXFwiQ2xlYXIgRm9ybWF0dGluZ1xcXCI6IFxcXCJDZWxsIEZvcm1hdHRpbmdcXFwiLFxcblxcbiAgICAvLyBVbmRvLCByZWRvXFxuICAgIFxcXCJVbmRvXFxcIjogXFxcIlVuZG9cXFwiLFxcbiAgICBcXFwiUmVkb1xcXCI6IFxcXCJSZWRvXFxcIixcXG5cXG4gICAgLy8gU2VsZWN0IGFsbFxcbiAgICBcXFwiU2VsZWN0IEFsbFxcXCI6IFxcXCJTZWxlY3QgQWxsXFxcIixcXG5cXG4gICAgLy8gQ29kZSB2aWV3XFxuICAgIFxcXCJDb2RlIFZpZXdcXFwiOiBcXFwiQ29kZSBWaWV3XFxcIixcXG5cXG4gICAgLy8gUXVvdGVcXG4gICAgXFxcIlF1b3RlXFxcIjogXFxcIlF1b3RlXFxcIixcXG4gICAgXFxcIkluY3JlYXNlXFxcIjogXFxcIkluY3JlYXNlXFxcIixcXG4gICAgXFxcIkRlY3JlYXNlXFxcIjogXFxcIkRlY3JlYXNlXFxcIixcXG5cXG4gICAgLy8gUXVpY2sgSW5zZXJ0XFxuICAgIFxcXCJRdWljayBJbnNlcnRcXFwiOiBcXFwiUXVpY2sgSW5zZXJ0XFxcIlxcbiAgfSxcXG4gIGRpcmVjdGlvbjogXFxcImx0clxcXCJcXG59O1xcblwiXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmF3LWxvYWRlciEuL34vZnJvYWxhLWVkaXRvci9qcy9sYW5ndWFnZXMvZW5fZ2IuanNcbiAqKiBtb2R1bGUgaWQgPSAyMVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIl0sIm1hcHBpbmdzIjoiQUFBQSIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }
]);