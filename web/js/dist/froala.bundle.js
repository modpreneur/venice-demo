webpackJsonp([0],[
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\n__webpack_require__(1);\n\n__webpack_require__(4);\n\n__webpack_require__(6);\n\n__webpack_require__(8);\n\n__webpack_require__(10);\n\n__webpack_require__(12);\n\n__webpack_require__(14);\n\n__webpack_require__(16);\n\n__webpack_require__(18);\n\n__webpack_require__(20);//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9ub2RlX21vZHVsZXMvdmVuaWNlLWpzL21haW5Gcm9hbGEuanM/NWM3MyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENyZWF0ZWQgYnkgYnVyMDEgb24gOS8xMi8xNi5cbiAqL1xuaW1wb3J0ICdzY3JpcHQhZnJvYWxhLWVkaXRvci9qcy9mcm9hbGFfZWRpdG9yLm1pbi5qcyc7XG5pbXBvcnQgJ3NjcmlwdCFjb2RlbWlycm9yL2xpYi9jb2RlbWlycm9yLmpzJztcbmltcG9ydCAnc2NyaXB0IWNvZGVtaXJyb3IvbW9kZS94bWwveG1sLmpzJztcbmltcG9ydCAnc2NyaXB0IWZyb2FsYS1lZGl0b3IvanMvcGx1Z2lucy9hbGlnbi5taW4uanMnO1xuaW1wb3J0ICdzY3JpcHQhZnJvYWxhLWVkaXRvci9qcy9wbHVnaW5zL2NoYXJfY291bnRlci5taW4uanMnO1xuaW1wb3J0ICdzY3JpcHQhZnJvYWxhLWVkaXRvci9qcy9wbHVnaW5zL2NvZGVfdmlldy5taW4uanMnO1xuaW1wb3J0ICdzY3JpcHQhZnJvYWxhLWVkaXRvci9qcy9wbHVnaW5zL2VudGl0aWVzLm1pbi5qcyc7XG5pbXBvcnQgJ3NjcmlwdCFmcm9hbGEtZWRpdG9yL2pzL3BsdWdpbnMvbGluay5taW4uanMnO1xuaW1wb3J0ICdzY3JpcHQhZnJvYWxhLWVkaXRvci9qcy9wbHVnaW5zL3VybC5taW4uanMnO1xuaW1wb3J0ICdzY3JpcHQhZnJvYWxhLWVkaXRvci9qcy9sYW5ndWFnZXMvZW5fZ2IuanMnO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIG5vZGVfbW9kdWxlcy92ZW5pY2UtanMvbWFpbkZyb2FsYS5qcyJdLCJtYXBwaW5ncyI6Ijs7QUFHQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQSIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	eval("__webpack_require__(2)(__webpack_require__(3))//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL34vZnJvYWxhLWVkaXRvci9qcy9mcm9hbGFfZWRpdG9yLm1pbi5qcz9hOWQwIl0sInNvdXJjZXNDb250ZW50IjpbInJlcXVpcmUoXCIhIS92YXIvYXBwL3dlYi9qcy9ub2RlX21vZHVsZXMvc2NyaXB0LWxvYWRlci9hZGRTY3JpcHQuanNcIikocmVxdWlyZShcIiEhL3Zhci9hcHAvd2ViL2pzL25vZGVfbW9kdWxlcy9yYXctbG9hZGVyL2luZGV4LmpzIS92YXIvYXBwL3dlYi9qcy9ub2RlX21vZHVsZXMvZnJvYWxhLWVkaXRvci9qcy9mcm9hbGFfZWRpdG9yLm1pbi5qc1wiKSlcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vc2NyaXB0LWxvYWRlciEuL34vZnJvYWxhLWVkaXRvci9qcy9mcm9hbGFfZWRpdG9yLm1pbi5qc1xuLy8gbW9kdWxlIGlkID0gMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 2 */
/***/ function(module, exports) {

	eval("/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\r\nmodule.exports = function(src) {\r\n\tif (typeof execScript !== \"undefined\")\r\n\t\texecScript(src);\r\n\telse\r\n\t\teval.call(null, src);\r\n}\r\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL34vc2NyaXB0LWxvYWRlci9hZGRTY3JpcHQuanM/ODEwNyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxyXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXHJcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxyXG4qL1xyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHNyYykge1xyXG5cdGlmICh0eXBlb2YgZXhlY1NjcmlwdCAhPT0gXCJ1bmRlZmluZWRcIilcclxuXHRcdGV4ZWNTY3JpcHQoc3JjKTtcclxuXHRlbHNlXHJcblx0XHRldmFsLmNhbGwobnVsbCwgc3JjKTtcclxufVxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vc2NyaXB0LWxvYWRlci9hZGRTY3JpcHQuanNcbi8vIG1vZHVsZSBpZCA9IDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 3 */
/***/ function(module, exports) {

	eval("module.exports = \"/*!\\n * froala_editor v2.4.0 (https://www.froala.com/wysiwyg-editor)\\n * License https://froala.com/wysiwyg-editor/terms/\\n * Copyright 2014-2016 Froala Labs\\n */\\n\\n!function(a){\\\"function\\\"==typeof define&&define.amd?define([\\\"jquery\\\"],a):\\\"object\\\"==typeof module&&module.exports?module.exports=function(b,c){return void 0===c&&(c=\\\"undefined\\\"!=typeof window?require(\\\"jquery\\\"):require(\\\"jquery\\\")(b)),a(c),c}:a(jQuery)}(function(a){var b=function(c,d){this.id=++a.FE.ID,this.opts=a.extend(!0,{},a.extend({},b.DEFAULTS,\\\"object\\\"==typeof d&&d));var e=JSON.stringify(this.opts);a.FE.OPTS_MAPPING[e]=a.FE.OPTS_MAPPING[e]||this.id,this.sid=a.FE.OPTS_MAPPING[e],a.FE.SHARED[this.sid]=a.FE.SHARED[this.sid]||{},this.shared=a.FE.SHARED[this.sid],this.shared.count=(this.shared.count||0)+1,this.$oel=a(c),this.$oel.data(\\\"froala.editor\\\",this),this.o_doc=c.ownerDocument,this.o_win=\\\"defaultView\\\"in this.o_doc?this.o_doc.defaultView:this.o_doc.parentWindow;var f=a(this.o_win).scrollTop();this.$oel.on(\\\"froala.doInit\\\",a.proxy(function(){this.$oel.off(\\\"froala.doInit\\\"),this.doc=this.$el.get(0).ownerDocument,this.win=\\\"defaultView\\\"in this.doc?this.doc.defaultView:this.doc.parentWindow,this.$doc=a(this.doc),this.$win=a(this.win),this.opts.pluginsEnabled||(this.opts.pluginsEnabled=Object.keys(a.FE.PLUGINS)),this.opts.initOnClick?(this.load(a.FE.MODULES),this.$el.on(\\\"touchstart.init\\\",function(){a(this).data(\\\"touched\\\",!0)}),this.$el.on(\\\"touchmove.init\\\",function(){a(this).removeData(\\\"touched\\\")}),this.$el.on(\\\"mousedown.init touchend.init dragenter.init focus.init\\\",a.proxy(function(b){if(\\\"touchend\\\"==b.type&&!this.$el.data(\\\"touched\\\"))return!0;if(1===b.which||!b.which){this.$el.off(\\\"mousedown.init touchstart.init touchmove.init touchend.init dragenter.init focus.init\\\"),this.load(a.FE.MODULES),this.load(a.FE.PLUGINS);var c=b.originalEvent&&b.originalEvent.originalTarget;c&&\\\"IMG\\\"==c.tagName&&a(c).trigger(\\\"mousedown\\\"),\\\"undefined\\\"==typeof this.ul&&this.destroy(),\\\"touchend\\\"==b.type&&this.image&&b.originalEvent&&b.originalEvent.target&&a(b.originalEvent.target).is(\\\"img\\\")&&setTimeout(a.proxy(function(){this.image.edit(a(b.originalEvent.target))},this),100),this.ready=!0,this.events.trigger(\\\"initialized\\\")}},this))):(this.load(a.FE.MODULES),this.load(a.FE.PLUGINS),a(this.o_win).scrollTop(f),\\\"undefined\\\"==typeof this.ul&&this.destroy(),this.ready=!0,this.events.trigger(\\\"initialized\\\"))},this)),this._init()};b.DEFAULTS={initOnClick:!1,pluginsEnabled:null},b.MODULES={},b.PLUGINS={},b.VERSION=\\\"2.4.0\\\",b.INSTANCES=[],b.OPTS_MAPPING={},b.SHARED={},b.ID=0,b.prototype._init=function(){var b=this.$oel.prop(\\\"tagName\\\"),c=a.proxy(function(){\\\"TEXTAREA\\\"!=b&&(this._original_html=this._original_html||this.$oel.html()),this.$box=this.$box||this.$oel,this.opts.fullPage&&(this.opts.iframe=!0),this.opts.iframe?(this.$iframe=a('<iframe src=\\\"about:blank\\\" frameBorder=\\\"0\\\">'),this.$wp=a(\\\"<div></div>\\\"),this.$box.html(this.$wp),this.$wp.append(this.$iframe),this.$iframe.get(0).contentWindow.document.open(),this.$iframe.get(0).contentWindow.document.write(\\\"<!DOCTYPE html>\\\"),this.$iframe.get(0).contentWindow.document.write(\\\"<html><head></head><body></body></html>\\\"),this.$iframe.get(0).contentWindow.document.close(),this.$el=this.$iframe.contents().find(\\\"body\\\"),this.el=this.$el.get(0),this.$head=this.$iframe.contents().find(\\\"head\\\"),this.$html=this.$iframe.contents().find(\\\"html\\\"),this.iframe_document=this.$iframe.get(0).contentWindow.document,this.$oel.trigger(\\\"froala.doInit\\\")):(this.$el=a(\\\"<div></div>\\\"),this.el=this.$el.get(0),this.$wp=a(\\\"<div></div>\\\").append(this.$el),this.$box.html(this.$wp),this.$oel.trigger(\\\"froala.doInit\\\"))},this),d=a.proxy(function(){this.$box=a(\\\"<div>\\\"),this.$oel.before(this.$box).hide(),this._original_html=this.$oel.val(),this.$oel.parents(\\\"form\\\").on(\\\"submit.\\\"+this.id,a.proxy(function(){this.events.trigger(\\\"form.submit\\\")},this)),this.$oel.parents(\\\"form\\\").on(\\\"reset.\\\"+this.id,a.proxy(function(){this.events.trigger(\\\"form.reset\\\")},this)),c()},this),e=a.proxy(function(){this.$el=this.$oel,this.el=this.$el.get(0),this.$el.attr(\\\"contenteditable\\\",!0).css(\\\"outline\\\",\\\"none\\\").css(\\\"display\\\",\\\"inline-block\\\"),this.opts.multiLine=!1,this.opts.toolbarInline=!1,this.$oel.trigger(\\\"froala.doInit\\\")},this),f=a.proxy(function(){this.$el=this.$oel,this.el=this.$el.get(0),this.opts.toolbarInline=!1,this.$oel.trigger(\\\"froala.doInit\\\")},this),g=a.proxy(function(){this.$el=this.$oel,this.el=this.$el.get(0),this.opts.toolbarInline=!1,this.$oel.on(\\\"click.popup\\\",function(a){a.preventDefault()}),this.$oel.trigger(\\\"froala.doInit\\\")},this);this.opts.editInPopup?g():\\\"TEXTAREA\\\"==b?d():\\\"A\\\"==b?e():\\\"IMG\\\"==b?f():\\\"BUTTON\\\"==b||\\\"INPUT\\\"==b?(this.opts.editInPopup=!0,this.opts.toolbarInline=!1,g()):c()},b.prototype.load=function(b){for(var c in b)if(b.hasOwnProperty(c)){if(this[c])continue;if(a.FE.PLUGINS[c]&&this.opts.pluginsEnabled.indexOf(c)<0)continue;if(this[c]=new b[c](this),this[c]._init&&(this[c]._init(),this.opts.initOnClick&&\\\"core\\\"==c))return!1}},b.prototype.destroy=function(){this.shared.count--,this.events.$off();var b=this.html.get();if(this.events.trigger(\\\"destroy\\\",[],!0),this.events.trigger(\\\"shared.destroy\\\",void 0,!0),0===this.shared.count){for(var c in this.shared)this.shared.hasOwnProperty(c)&&(null==this.shared[c],a.FE.SHARED[this.sid][c]=null);a.FE.SHARED[this.sid]={}}this.$oel.parents(\\\"form\\\").off(\\\".\\\"+this.id),this.$oel.off(\\\"click.popup\\\"),this.$oel.removeData(\\\"froala.editor\\\"),this.$oel.off(\\\"froalaEditor\\\"),this.core.destroy(b),a.FE.INSTANCES.splice(a.FE.INSTANCES.indexOf(this),1)},a.fn.froalaEditor=function(c){for(var d=[],e=0;e<arguments.length;e++)d.push(arguments[e]);if(\\\"string\\\"==typeof c){var f=[];return this.each(function(){var b=a(this),e=b.data(\\\"froala.editor\\\");if(e){var g,h;if(c.indexOf(\\\".\\\")>0&&e[c.split(\\\".\\\")[0]]?(e[c.split(\\\".\\\")[0]]&&(g=e[c.split(\\\".\\\")[0]]),h=c.split(\\\".\\\")[1]):(g=e,h=c.split(\\\".\\\")[0]),!g[h])return a.error(\\\"Method \\\"+c+\\\" does not exist in Froala Editor.\\\");var i=g[h].apply(e,d.slice(1));void 0===i?f.push(this):0===f.length&&f.push(i)}}),1==f.length?f[0]:f}if(\\\"object\\\"==typeof c||!c)return this.each(function(){var d=a(this).data(\\\"froala.editor\\\");if(!d){var e=this;new b(e,c)}})},a.fn.froalaEditor.Constructor=b,a.FroalaEditor=b,a.FE=b,a.FE.XS=0,a.FE.SM=1,a.FE.MD=2,a.FE.LG=3,a.FE.MODULES.helpers=function(b){function c(){var a,b,c=-1;return\\\"Microsoft Internet Explorer\\\"==navigator.appName?(a=navigator.userAgent,b=new RegExp(\\\"MSIE ([0-9]{1,}[\\\\\\\\.0-9]{0,})\\\"),null!==b.exec(a)&&(c=parseFloat(RegExp.$1))):\\\"Netscape\\\"==navigator.appName&&(a=navigator.userAgent,b=new RegExp(\\\"Trident/.*rv:([0-9]{1,}[\\\\\\\\.0-9]{0,})\\\"),null!==b.exec(a)&&(c=parseFloat(RegExp.$1))),c}function d(){var a={},b=c();if(b>0)a.msie=!0;else{var d=navigator.userAgent.toLowerCase(),e=/(edge)[ \\\\/]([\\\\w.]+)/.exec(d)||/(chrome)[ \\\\/]([\\\\w.]+)/.exec(d)||/(webkit)[ \\\\/]([\\\\w.]+)/.exec(d)||/(opera)(?:.*version|)[ \\\\/]([\\\\w.]+)/.exec(d)||/(msie) ([\\\\w.]+)/.exec(d)||d.indexOf(\\\"compatible\\\")<0&&/(mozilla)(?:.*? rv:([\\\\w.]+)|)/.exec(d)||[],f={browser:e[1]||\\\"\\\",version:e[2]||\\\"0\\\"};e[1]&&(a[f.browser]=!0),a.chrome?a.webkit=!0:a.webkit&&(a.safari=!0)}return a.msie&&(a.version=b),a}function e(){return/(iPad|iPhone|iPod)/g.test(navigator.userAgent)&&!h()}function f(){return/(Android)/g.test(navigator.userAgent)&&!h()}function g(){return/(Blackberry)/g.test(navigator.userAgent)}function h(){return/(Windows Phone)/gi.test(navigator.userAgent)}function i(){return f()||e()||g()}function j(){return window.requestAnimationFrame||window.webkitRequestAnimationFrame||window.mozRequestAnimationFrame||function(a){window.setTimeout(a,1e3/60)}}function k(a){return parseInt(a,10)||0}function l(){var b=a('<div class=\\\"fr-visibility-helper\\\"></div>').appendTo(\\\"body\\\"),c=k(b.css(\\\"margin-left\\\"));return b.remove(),c}function m(){return\\\"ontouchstart\\\"in window||window.DocumentTouch&&document instanceof DocumentTouch}function n(a){if(!/^(https?:|ftps?:|)\\\\/\\\\//i.test(a))return!1;a=String(a).replace(/</g,\\\"%3C\\\").replace(/>/g,\\\"%3E\\\").replace(/\\\"/g,\\\"%22\\\").replace(/ /g,\\\"%20\\\");var b=/(http|ftp|https):\\\\/\\\\/[a-z\\\\u00a1-\\\\uffff0-9{}]+(\\\\.[a-z\\\\u00a1-\\\\uffff0-9{}]*)*([a-z\\\\u00a1-\\\\uffff0-9.,@?^=%&amp;:\\\\/~+#-_{}]*[a-z\\\\u00a1-\\\\uffff0-9@?^=%&amp;\\\\/~+#-_{}])?/gi;return b.test(a)}function o(a){if(/^(https?:|ftps?:|)\\\\/\\\\//i.test(a)){if(!n(a)&&!n(\\\"http:\\\"+a))return\\\"\\\"}else a=encodeURIComponent(a).replace(/%23/g,\\\"#\\\").replace(/%2F/g,\\\"/\\\").replace(/%25/g,\\\"%\\\").replace(/mailto%3A/gi,\\\"mailto:\\\").replace(/file%3A/gi,\\\"file:\\\").replace(/sms%3A/gi,\\\"sms:\\\").replace(/tel%3A/gi,\\\"tel:\\\").replace(/notes%3A/gi,\\\"notes:\\\").replace(/data%3Aimage/gi,\\\"data:image\\\").replace(/blob%3A/gi,\\\"blob:\\\").replace(/webkit-fake-url%3A/gi,\\\"webkit-fake-url:\\\").replace(/%3F/g,\\\"?\\\").replace(/%3D/g,\\\"=\\\").replace(/%26/g,\\\"&\\\").replace(/&amp;/g,\\\"&\\\").replace(/%2C/g,\\\",\\\").replace(/%3B/g,\\\";\\\").replace(/%2B/g,\\\"+\\\").replace(/%40/g,\\\"@\\\").replace(/%5B/g,\\\"[\\\").replace(/%5D/g,\\\"]\\\").replace(/%7B/g,\\\"{\\\").replace(/%7D/g,\\\"}\\\");return a}function p(a){return a&&!a.propertyIsEnumerable(\\\"length\\\")&&\\\"object\\\"==typeof a&&\\\"number\\\"==typeof a.length}function q(a){function b(a){return(\\\"0\\\"+parseInt(a,10).toString(16)).slice(-2)}try{return a&&\\\"transparent\\\"!==a?/^#[0-9A-F]{6}$/i.test(a)?a:(a=a.match(/^rgb\\\\((\\\\d+),\\\\s*(\\\\d+),\\\\s*(\\\\d+)\\\\)$/),(\\\"#\\\"+b(a[1])+b(a[2])+b(a[3])).toUpperCase()):\\\"\\\"}catch(c){return null}}function r(a){var b=/^#?([a-f\\\\d])([a-f\\\\d])([a-f\\\\d])$/i;a=a.replace(b,function(a,b,c,d){return b+b+c+c+d+d});var c=/^#?([a-f\\\\d]{2})([a-f\\\\d]{2})([a-f\\\\d]{2})$/i.exec(a);return c?\\\"rgb(\\\"+parseInt(c[1],16)+\\\", \\\"+parseInt(c[2],16)+\\\", \\\"+parseInt(c[3],16)+\\\")\\\":\\\"\\\"}function s(b){var c=(b.css(\\\"text-align\\\")||\\\"\\\").replace(/-(.*)-/g,\\\"\\\");if([\\\"left\\\",\\\"right\\\",\\\"justify\\\",\\\"center\\\"].indexOf(c)<0){if(!w){var d=a('<div dir=\\\"auto\\\" style=\\\"text-align: initial; position: fixed; left: -3000px;\\\"><span id=\\\"s1\\\">.</span><span id=\\\"s2\\\">.</span></div>');a(\\\"body\\\").append(d);var e=d.find(\\\"#s1\\\").get(0).getBoundingClientRect().left,f=d.find(\\\"#s2\\\").get(0).getBoundingClientRect().left;d.remove(),w=e<f?\\\"left\\\":\\\"right\\\"}c=w}return c}function t(){return null==x&&(x=navigator.platform.toUpperCase().indexOf(\\\"MAC\\\")>=0),x}function u(){function a(a,b){var d=a[b];a[b]=function(a){var b,f=!1,g=!1;if(a.match(e)){a=a.replace(e,\\\"\\\"),this.parentNode||(c.appendChild(this),g=!0);var h=this.parentNode;return this.id||(this.id=\\\"rootedQuerySelector_id_\\\"+(new Date).getTime(),f=!0),b=d.call(h,\\\"#\\\"+this.id+\\\" \\\"+a),f&&(this.id=\\\"\\\"),g&&c.removeChild(this),b}return d.call(this,a)}}var c=b.o_doc.createElement(\\\"div\\\");try{c.querySelectorAll(\\\":scope *\\\")}catch(d){var e=/^\\\\s*:scope/gi;a(HTMLElement.prototype,\\\"querySelector\\\"),a(HTMLElement.prototype,\\\"querySelectorAll\\\")}}function v(){b.browser=d(),u()}var w,x=null;return{_init:v,isIOS:e,isMac:t,isAndroid:f,isBlackberry:g,isWindowsPhone:h,isMobile:i,requestAnimationFrame:j,getPX:k,screenSize:l,isTouch:m,sanitizeURL:o,isArray:p,RGBToHex:q,HEXtoRGB:r,isURL:n,getAlignment:s}},a.FE.MODULES.events=function(b){function c(a,b,c){s(a,b,c)}function d(){c(b.$el,\\\"cut copy paste beforepaste\\\",function(a){v(a.type,[a])})}function e(){c(b.$el,\\\"click mouseup mousedown touchstart touchend dragenter dragover dragleave dragend drop dragstart\\\",function(a){v(a.type,[a])}),r(\\\"mousedown\\\",function(){for(var c=0;c<a.FE.INSTANCES.length;c++)a.FE.INSTANCES[c]!=b&&a.FE.INSTANCES[c].popups&&a.FE.INSTANCES[c].popups.areVisible()&&a.FE.INSTANCES[c].$el.find(\\\".fr-marker\\\").remove()})}function f(){c(b.$el,\\\"keydown keypress keyup input\\\",function(a){v(a.type,[a])})}function g(){c(b.$win,b._mousedown,function(a){v(\\\"window.mousedown\\\",[a]),n()}),c(b.$win,b._mouseup,function(a){v(\\\"window.mouseup\\\",[a])}),c(b.$win,\\\"cut copy keydown keyup touchmove touchend\\\",function(a){v(\\\"window.\\\"+a.type,[a])})}function h(){c(b.$doc,\\\"dragend drop\\\",function(a){v(\\\"document.\\\"+a.type,[a])})}function i(c){if(\\\"undefined\\\"==typeof c&&(c=!0),!b.$wp)return!1;if(b.helpers.isIOS()&&b.$win.get(0).focus(),!b.core.hasFocus()&&c){var d=b.$win.scrollTop();return b.$el.focus(),d!=b.$win.scrollTop()&&b.$win.scrollTop(d),!1}if(!b.core.hasFocus()||b.$el.find(\\\".fr-marker\\\").length>0)return!1;var e=b.selection.info(b.el);if(e.atStart&&b.selection.isCollapsed()&&null!=b.html.defaultTag()){var f=b.markers.insert();if(f&&!b.node.blockParent(f)){a(f).remove();var g=b.$el.find(b.html.blockTagsQuery()).get(0);g&&(a(g).prepend(a.FE.MARKERS),b.selection.restore())}else f&&a(f).remove()}}function j(){c(b.$el,\\\"focus\\\",function(a){p()&&(i(!1),C===!1&&v(a.type,[a]))}),c(b.$el,\\\"blur\\\",function(a){p()&&C===!0&&(v(a.type,[a]),n())}),r(\\\"focus\\\",function(){C=!0}),r(\\\"blur\\\",function(){C=!1})}function k(){b.helpers.isMobile()?(b._mousedown=\\\"touchstart\\\",b._mouseup=\\\"touchend\\\",b._move=\\\"touchmove\\\",b._mousemove=\\\"touchmove\\\"):(b._mousedown=\\\"mousedown\\\",b._mouseup=\\\"mouseup\\\",b._move=\\\"\\\",b._mousemove=\\\"mousemove\\\")}function l(c){var d=a(c.currentTarget);return b.edit.isDisabled()||b.node.hasClass(d.get(0),\\\"fr-disabled\\\")?(c.preventDefault(),!1):\\\"mousedown\\\"===c.type&&1!==c.which||(b.helpers.isMobile()||c.preventDefault(),(b.helpers.isAndroid()||b.helpers.isWindowsPhone())&&0===d.parents(\\\".fr-dropdown-menu\\\").length&&(c.preventDefault(),c.stopPropagation()),d.addClass(\\\"fr-selected\\\"),void b.events.trigger(\\\"commands.mousedown\\\",[d]))}function m(c,d){var e=a(c.currentTarget);if(b.edit.isDisabled()||b.node.hasClass(e.get(0),\\\"fr-disabled\\\"))return c.preventDefault(),!1;if(\\\"mouseup\\\"===c.type&&1!==c.which)return!0;if(!b.node.hasClass(e.get(0),\\\"fr-selected\\\"))return!0;if(\\\"touchmove\\\"!=c.type){if(c.stopPropagation(),c.stopImmediatePropagation(),c.preventDefault(),!b.node.hasClass(e.get(0),\\\"fr-selected\\\"))return a(\\\".fr-selected\\\").removeClass(\\\"fr-selected\\\"),!1;if(a(\\\".fr-selected\\\").removeClass(\\\"fr-selected\\\"),e.data(\\\"dragging\\\")||e.attr(\\\"disabled\\\"))return e.removeData(\\\"dragging\\\"),!1;var f=e.data(\\\"timeout\\\");f&&(clearTimeout(f),e.removeData(\\\"timeout\\\")),d.apply(b,[c])}else e.data(\\\"timeout\\\")||e.data(\\\"timeout\\\",setTimeout(function(){e.data(\\\"dragging\\\",!0)},100))}function n(){A=!0}function o(){A=!1}function p(){return A}function q(a,c,d){s(a,b._mousedown,c,function(a){b.edit.isDisabled()||l(a)},!0),s(a,b._mouseup+\\\" \\\"+b._move,c,function(a){b.edit.isDisabled()||m(a,d)},!0),s(a,\\\"mousedown click mouseup\\\",c,function(a){b.edit.isDisabled()||a.stopPropagation()},!0),r(\\\"window.mouseup\\\",function(){b.edit.isDisabled()||(a.find(c).removeClass(\\\"fr-selected\\\"),n())})}function r(a,c,d){var e=a.split(\\\" \\\");if(e.length>1){for(var f=0;f<e.length;f++)r(e[f],c,d);return!0}\\\"undefined\\\"==typeof d&&(d=!1);var g;g=0!=a.indexOf(\\\"shared.\\\")?B[a]=B[a]||[]:b.shared._events[a]=b.shared._events[a]||[],d?g.unshift(c):g.push(c)}function s(a,c,d,e,f){\\\"function\\\"==typeof d&&(f=e,e=d,d=!1);var g=f?b.shared.$_events:D,h=f?b.sid:b.id;d?a.on(c.split(\\\" \\\").join(\\\".ed\\\"+h+\\\" \\\")+\\\".ed\\\"+h,d,e):a.on(c.split(\\\" \\\").join(\\\".ed\\\"+h+\\\" \\\")+\\\".ed\\\"+h,e),g.indexOf(a.get(0))<0&&g.push(a.get(0))}function t(b,c){for(var d=0;d<b.length;d++)a(b[d]).off(\\\".ed\\\"+c)}function u(){t(D,b.id),D=[],0==b.shared.count&&(t(b.shared.$_events,b.sid),b.shared.$_events=null)}function v(c,d,e){if(!b.edit.isDisabled()||e){var f;if(0!=c.indexOf(\\\"shared.\\\"))f=B[c];else{if(b.shared.count>0)return!1;f=b.shared._events[c]}var g;if(f)for(var h=0;h<f.length;h++)if(g=f[h].apply(b,d),g===!1)return!1;return g=b.$oel.triggerHandler(\\\"froalaEditor.\\\"+c,a.merge([b],d||[])),g!==!1&&g}}function w(c,d,e){if(!b.edit.isDisabled()||e){var f;if(0!=c.indexOf(\\\"shared.\\\"))f=B[c];else{if(b.shared.count>0)return!1;f=b.shared._events[c]}var g;if(f)for(var h=0;h<f.length;h++)g=f[h].apply(b,[d]),\\\"undefined\\\"!=typeof g&&(d=g);return g=b.$oel.triggerHandler(\\\"froalaEditor.\\\"+c,a.merge([b],[d])),\\\"undefined\\\"!=typeof g&&(d=g),d}}function x(){for(var a in B)B.hasOwnProperty(a)&&delete B[a]}function y(){for(var a in b.shared._events)b.shared._events.hasOwnProperty(a)&&delete b.shared._events[a]}function z(){b.shared.$_events=b.shared.$_events||[],b.shared._events={},k(),e(),g(),h(),f(),j(),n(),d(),r(\\\"destroy\\\",x),r(\\\"shared.destroy\\\",y)}var A,B={},C=!1,D=[];return{_init:z,on:r,trigger:v,bindClick:q,disableBlur:o,enableBlur:n,blurActive:p,focus:i,chainTrigger:w,$on:s,$off:u}},a.FE.MODULES.node=function(b){function c(a){return a&&\\\"IFRAME\\\"!=a.tagName?Array.prototype.slice.call(a.childNodes||[]):[]}function d(b){return!!b&&(b.nodeType==Node.ELEMENT_NODE&&a.FE.BLOCK_TAGS.indexOf(b.tagName.toLowerCase())>=0)}function e(e,f){if(!e)return!0;if(e.querySelector(\\\"table\\\"))return!1;var g=c(e);1==g.length&&d(g[0])&&(g=c(g[0]));for(var h=!1,i=0;i<g.length;i++){var j=g[i];if(!(f&&b.node.hasClass(j,\\\"fr-marker\\\")||j.nodeType==Node.TEXT_NODE&&0==j.textContent.length)){if(\\\"BR\\\"!=j.tagName&&(j.textContent||\\\"\\\").replace(/\\\\u200B/gi,\\\"\\\").replace(/\\\\n/g,\\\"\\\").length>0)return!1;if(h)return!1;\\\"BR\\\"==j.tagName&&(h=!0)}}return!(e.querySelectorAll(a.FE.VOID_ELEMENTS.join(\\\",\\\")).length-e.querySelectorAll(\\\"br\\\").length)&&(!e.querySelector(b.opts.htmlAllowedEmptyTags.join(\\\":not(.fr-marker),\\\")+\\\":not(.fr-marker)\\\")&&(!(e.querySelectorAll(a.FE.BLOCK_TAGS.join(\\\",\\\")).length>1)&&!e.querySelector(b.opts.htmlDoNotWrapTags.join(\\\":not(.fr-marker),\\\")+\\\":not(.fr-marker)\\\")))}function f(a){for(;a&&a.parentNode!==b.el&&(!a.parentNode||!b.node.hasClass(a.parentNode,\\\"fr-inner\\\"));)if(a=a.parentNode,d(a))return a;return null}function g(c,e,f){if(\\\"undefined\\\"==typeof e&&(e=[]),\\\"undefined\\\"==typeof f&&(f=!0),e.push(b.el),e.indexOf(c.parentNode)>=0||c.parentNode&&b.node.hasClass(c.parentNode,\\\"fr-inner\\\")||c.parentNode&&a.FE.SIMPLE_ENTER_TAGS.indexOf(c.parentNode.tagName)>=0&&f)return null;for(;e.indexOf(c.parentNode)<0&&c.parentNode&&!b.node.hasClass(c.parentNode,\\\"fr-inner\\\")&&(a.FE.SIMPLE_ENTER_TAGS.indexOf(c.parentNode.tagName)<0||!f)&&(!d(c)||!d(c.parentNode)||!f);)c=c.parentNode;return c}function h(a){var b={},c=a.attributes;if(c)for(var d=0;d<c.length;d++){var e=c[d];b[e.nodeName]=e.value}return b}function i(a){for(var b=\\\"\\\",c=h(a),d=Object.keys(c).sort(),e=0;e<d.length;e++){var f=d[e],g=c[f];b+=g.indexOf('\\\"')<0?\\\" \\\"+f+'=\\\"'+g+'\\\"':\\\" \\\"+f+\\\"='\\\"+g+\\\"'\\\"}return b}function j(a){for(var b=a.attributes,c=0;c<b.length;c++){var d=b[c];a.removeAttribute(d.nodeName)}}function k(a){return\\\"<\\\"+a.tagName.toLowerCase()+i(a)+\\\">\\\"}function l(a){return\\\"</\\\"+a.tagName.toLowerCase()+\\\">\\\"}function m(a,c){\\\"undefined\\\"==typeof c&&(c=!0);for(var d=a.previousSibling;d&&c&&b.node.hasClass(d,\\\"fr-marker\\\");)d=d.previousSibling;return!d||d.nodeType==Node.TEXT_NODE&&\\\"\\\"===d.textContent&&m(d)}function n(a,c){\\\"undefined\\\"==typeof c&&(c=!0);for(var d=a.nextSibling;d&&c&&b.node.hasClass(d,\\\"fr-marker\\\");)d=d.nextSibling;return!d||d.nodeType==Node.TEXT_NODE&&\\\"\\\"===d.textContent&&n(d)}function o(b){return b&&b.nodeType==Node.ELEMENT_NODE&&a.FE.VOID_ELEMENTS.indexOf((b.tagName||\\\"\\\").toLowerCase())>=0}function p(a){return!!a&&[\\\"UL\\\",\\\"OL\\\"].indexOf(a.tagName)>=0}function q(a){return a===b.el}function r(a){return a&&a.nodeType==Node.ELEMENT_NODE&&a.getAttribute(\\\"class\\\")&&(a.getAttribute(\\\"class\\\")||\\\"\\\").indexOf(\\\"fr-deletable\\\")>=0}function s(a){return a===b.doc.activeElement&&(!b.doc.hasFocus||b.doc.hasFocus())&&!!(q(a)||a.type||a.href||~a.tabIndex)}function t(a){return(!a.getAttribute||\\\"false\\\"!=a.getAttribute(\\\"contenteditable\\\"))&&[\\\"STYLE\\\",\\\"SCRIPT\\\"].indexOf(a.tagName)<0}function u(a,b){return a instanceof jQuery&&(a=a.get(0)),a&&a.classList&&a.classList.contains(b)}function v(a){return b.browser.msie?a:{acceptNode:a}}return{isBlock:d,isEmpty:e,blockParent:f,deepestParent:g,rawAttributes:h,attributes:i,clearAttributes:j,openTagString:k,closeTagString:l,isFirstSibling:m,isLastSibling:n,isList:p,isElement:q,contents:c,isVoid:o,hasFocus:s,isEditable:t,isDeletable:r,hasClass:u,filter:v}},a.FE.INVISIBLE_SPACE=\\\"&#8203;\\\",a.FE.START_MARKER='<span class=\\\"fr-marker\\\" data-id=\\\"0\\\" data-type=\\\"true\\\" style=\\\"display: none; line-height: 0;\\\">'+a.FE.INVISIBLE_SPACE+\\\"</span>\\\",a.FE.END_MARKER='<span class=\\\"fr-marker\\\" data-id=\\\"0\\\" data-type=\\\"false\\\" style=\\\"display: none; line-height: 0;\\\">'+a.FE.INVISIBLE_SPACE+\\\"</span>\\\",a.FE.MARKERS=a.FE.START_MARKER+a.FE.END_MARKER,a.FE.MODULES.markers=function(b){function c(c,d){return a('<span class=\\\"fr-marker\\\" data-id=\\\"'+d+'\\\" data-type=\\\"'+c+'\\\" style=\\\"display: '+(b.browser.safari?\\\"none\\\":\\\"inline-block\\\")+'; line-height: 0;\\\">'+a.FE.INVISIBLE_SPACE+\\\"</span>\\\",b.doc)[0]}function d(d,e,f){try{var g=d.cloneRange();if(g.collapse(e),g.insertNode(c(e,f)),e===!0&&d.collapsed)for(var h=b.$el.find('span.fr-marker[data-type=\\\"true\\\"][data-id=\\\"'+f+'\\\"]'),i=h.get(0).nextSibling;i&&i.nodeType===Node.TEXT_NODE&&0===i.textContent.length;)a(i).remove(),i=h.nextSibling;if(e===!0&&!d.collapsed){var h=b.$el.find('span.fr-marker[data-type=\\\"true\\\"][data-id=\\\"'+f+'\\\"]').get(0),i=h.nextSibling;if(i&&i.nodeType===Node.ELEMENT_NODE&&b.node.isBlock(i)){var j=[i];do i=j[0],j=b.node.contents(i);while(j[0]&&b.node.isBlock(j[0]));a(i).prepend(a(h))}}if(e===!1&&!d.collapsed){var h=b.$el.find('span.fr-marker[data-type=\\\"false\\\"][data-id=\\\"'+f+'\\\"]').get(0),i=h.previousSibling;if(i&&i.nodeType===Node.ELEMENT_NODE&&b.node.isBlock(i)){var j=[i];do i=j[j.length-1],j=b.node.contents(i);while(j[j.length-1]&&b.node.isBlock(j[j.length-1]));a(i).append(a(h))}h.parentNode&&[\\\"TD\\\",\\\"TH\\\"].indexOf(h.parentNode.tagName)>=0&&h.parentNode.previousSibling&&!h.previousSibling&&a(h.parentNode.previousSibling).append(h)}var k=b.$el.find('span.fr-marker[data-type=\\\"'+e+'\\\"][data-id=\\\"'+f+'\\\"]').get(0);return k&&(k.style.display=\\\"none\\\"),k}catch(l){return null}}function e(){if(!b.$wp)return null;try{var c=b.selection.ranges(0),d=c.commonAncestorContainer;if(d!=b.el&&0==b.$el.find(d).length)return null;var e=c.cloneRange(),f=c.cloneRange();e.collapse(!0);var g=a('<span class=\\\"fr-marker\\\" style=\\\"display: none; line-height: 0;\\\">'+a.FE.INVISIBLE_SPACE+\\\"</span>\\\",b.doc)[0];if(e.insertNode(g),g=b.$el.find(\\\"span.fr-marker\\\").get(0)){for(var h=g.nextSibling;h&&h.nodeType===Node.TEXT_NODE&&0===h.textContent.length;)a(h).remove(),h=b.$el.find(\\\"span.fr-marker\\\").get(0).nextSibling;return b.selection.clear(),b.selection.get().addRange(f),g}return null}catch(i){}}function f(){b.selection.isCollapsed()||b.selection.remove();var c=b.$el.find(\\\".fr-marker\\\").get(0);if(null==c&&(c=e()),null==c)return null;var d=b.node.deepestParent(c);if(d||(d=b.node.blockParent(c),d&&\\\"LI\\\"!=d.tagName&&(d=null)),d)if(b.node.isBlock(d)&&b.node.isEmpty(d))a(d).replaceWith('<span class=\\\"fr-marker\\\"></span>');else if(b.cursor.isAtStart(c,d))a(d).before('<span class=\\\"fr-marker\\\"></span>'),a(c).remove();else if(b.cursor.isAtEnd(c,d))a(d).after('<span class=\\\"fr-marker\\\"></span>'),a(c).remove();else{var f=c,g=\\\"\\\",h=\\\"\\\";do f=f.parentNode,g+=b.node.closeTagString(f),h=b.node.openTagString(f)+h;while(f!=d);a(c).replaceWith('<span id=\\\"fr-break\\\"></span>');var i=b.node.openTagString(d)+a(d).html()+b.node.closeTagString(d);i=i.replace(/<span id=\\\"fr-break\\\"><\\\\/span>/g,g+'<span class=\\\"fr-marker\\\"></span>'+h),a(d).replaceWith(i)}return b.$el.find(\\\".fr-marker\\\").get(0)}function g(a){var c=a.clientX,d=a.clientY;h();var f,g=null;if(\\\"undefined\\\"!=typeof b.doc.caretPositionFromPoint?(f=b.doc.caretPositionFromPoint(c,d),g=b.doc.createRange(),g.setStart(f.offsetNode,f.offset),g.setEnd(f.offsetNode,f.offset)):\\\"undefined\\\"!=typeof b.doc.caretRangeFromPoint&&(f=b.doc.caretRangeFromPoint(c,d),g=b.doc.createRange(),g.setStart(f.startContainer,f.startOffset),g.setEnd(f.startContainer,f.startOffset)),null!==g&&\\\"undefined\\\"!=typeof b.win.getSelection){var i=b.win.getSelection();i.removeAllRanges(),i.addRange(g)}else if(\\\"undefined\\\"!=typeof b.doc.body.createTextRange)try{g=b.doc.body.createTextRange(),g.moveToPoint(c,d);var j=g.duplicate();j.moveToPoint(c,d),g.setEndPoint(\\\"EndToEnd\\\",j),g.select()}catch(k){return!1}e()}function h(){b.$el.find(\\\".fr-marker\\\").remove()}return{place:d,insert:e,split:f,insertAtPoint:g,remove:h}},a.FE.MODULES.selection=function(b){function c(){var a=\\\"\\\";return b.win.getSelection?a=b.win.getSelection():b.doc.getSelection?a=b.doc.getSelection():b.doc.selection&&(a=b.doc.selection.createRange().text),a.toString()}function d(){var a=\\\"\\\";return a=b.win.getSelection?b.win.getSelection():b.doc.getSelection?b.doc.getSelection():b.doc.selection.createRange()}function e(a){var c=d(),e=[];if(c&&c.getRangeAt&&c.rangeCount)for(var e=[],f=0;f<c.rangeCount;f++)e.push(c.getRangeAt(f));else e=b.doc.createRange?[b.doc.createRange()]:[];return\\\"undefined\\\"!=typeof a?e[a]:e}function f(){var a=d();try{a.removeAllRanges?a.removeAllRanges():a.empty?a.empty():a.clear&&a.clear()}catch(b){}}function g(){var f=d();try{if(f.rangeCount){var g=e(0),h=g.startContainer;if(h.nodeType==Node.TEXT_NODE&&g.startOffset==(h.textContent||\\\"\\\").length&&h.nextSibling&&(h=h.nextSibling),h.nodeType==Node.ELEMENT_NODE){var i=!1;if(h.childNodes.length>0&&h.childNodes[g.startOffset]){for(var j=h.childNodes[g.startOffset];j&&j.nodeType==Node.TEXT_NODE&&0==j.textContent.length;)j=j.nextSibling;if(j&&j.textContent.replace(/\\\\u200B/g,\\\"\\\")===c().replace(/\\\\u200B/g,\\\"\\\")&&(h=j,i=!0),!i&&h.childNodes.length>1&&g.startOffset>0&&h.childNodes[g.startOffset-1]){for(var j=h.childNodes[g.startOffset-1];j&&j.nodeType==Node.TEXT_NODE&&0==j.textContent.length;)j=j.nextSibling;j&&j.textContent.replace(/\\\\u200B/g,\\\"\\\")===c().replace(/\\\\u200B/g,\\\"\\\")&&(h=j,i=!0)}}else if(!g.collapsed&&h.nextSibling&&h.nextSibling.nodeType==Node.ELEMENT_NODE){var j=h.nextSibling;j&&j.textContent.replace(/\\\\u200B/g,\\\"\\\")===c().replace(/\\\\u200B/g,\\\"\\\")&&(h=j,i=!0)}!i&&h.childNodes.length>0&&a(h.childNodes[0]).text().replace(/\\\\u200B/g,\\\"\\\")===c().replace(/\\\\u200B/g,\\\"\\\")&&[\\\"BR\\\",\\\"IMG\\\",\\\"HR\\\"].indexOf(h.childNodes[0].tagName)<0&&(h=h.childNodes[0])}for(;h.nodeType!=Node.ELEMENT_NODE&&h.parentNode;)h=h.parentNode;for(var k=h;k&&\\\"HTML\\\"!=k.tagName;){if(k==b.el)return h;k=a(k).parent()[0]}}}catch(l){}return b.el}function h(){var f=d();try{if(f.rangeCount){var g=e(0),h=g.endContainer;if(h.nodeType==Node.ELEMENT_NODE){var i=!1;if(h.childNodes.length>0&&h.childNodes[g.endOffset]&&a(h.childNodes[g.endOffset]).text()===c())h=h.childNodes[g.endOffset],i=!0;else if(!g.collapsed&&h.previousSibling&&h.previousSibling.nodeType==Node.ELEMENT_NODE){var j=h.previousSibling;j&&j.textContent.replace(/\\\\u200B/g,\\\"\\\")===c().replace(/\\\\u200B/g,\\\"\\\")&&(h=j,i=!0)}else if(!g.collapsed&&h.childNodes.length>0&&h.childNodes[g.endOffset]){var j=h.childNodes[g.endOffset].previousSibling;j.nodeType==Node.ELEMENT_NODE&&j&&j.textContent.replace(/\\\\u200B/g,\\\"\\\")===c().replace(/\\\\u200B/g,\\\"\\\")&&(h=j,i=!0)}!i&&h.childNodes.length>0&&a(h.childNodes[h.childNodes.length-1]).text()===c()&&[\\\"BR\\\",\\\"IMG\\\",\\\"HR\\\"].indexOf(h.childNodes[h.childNodes.length-1].tagName)<0&&(h=h.childNodes[h.childNodes.length-1])}for(h.nodeType==Node.TEXT_NODE&&0==g.endOffset&&h.previousSibling&&h.previousSibling.nodeType==Node.ELEMENT_NODE&&(h=h.previousSibling);h.nodeType!=Node.ELEMENT_NODE&&h.parentNode;)h=h.parentNode;for(var k=h;k&&\\\"HTML\\\"!=k.tagName;){if(k==b.el)return h;k=a(k).parent()[0]}}}catch(l){}return b.el}function i(a,b){var c=a;return c.nodeType==Node.ELEMENT_NODE&&c.childNodes.length>0&&c.childNodes[b]&&(c=c.childNodes[b]),c.nodeType==Node.TEXT_NODE&&(c=c.parentNode),c}function j(){var c=[],f=d();if(t()&&f.rangeCount)for(var g=e(),h=0;h<g.length;h++){var j=g[h],k=i(j.startContainer,j.startOffset),l=i(j.endContainer,j.endOffset);b.node.isBlock(k)&&c.indexOf(k)<0&&c.push(k);var m=b.node.blockParent(k);m&&c.indexOf(m)<0&&c.push(m);for(var n=[],o=k;o!==l&&o!==b.el;)n.indexOf(o)<0&&o.children&&o.children.length?(n.push(o),o=o.children[0]):o.nextSibling?o=o.nextSibling:o.parentNode&&(o=o.parentNode,n.push(o)),b.node.isBlock(o)&&n.indexOf(o)<0&&c.indexOf(o)<0&&(o!==l||j.endOffset>0)&&c.push(o);b.node.isBlock(l)&&c.indexOf(l)<0&&j.endOffset>0&&c.push(l);var m=b.node.blockParent(l);m&&c.indexOf(m)<0&&c.push(m)}for(var h=c.length-1;h>0;h--)a(c[h]).find(c).length&&(\\\"LI\\\"!=c[h].tagName||1==c[h].children.length&&c.indexOf(c[h].children[0])>=0)&&c.splice(h,1);return c}function k(){if(b.$wp){b.markers.remove();for(var a=e(),c=[],d=0;d<a.length;d++)if(a[d].startContainer!==b.doc){var f=a[d],g=f.collapsed,h=b.markers.place(f,!0,d),i=b.markers.place(f,!1,d);if(b.el.normalize(),b.browser.safari&&!g){var f=b.doc.createRange();f.setStartAfter(h),f.setEndBefore(i),c.push(f)}}if(b.browser.safari&&c.length){b.selection.clear();for(var d=0;d<c.length;d++)b.selection.get().addRange(c[d])}}}function l(){var c=b.el.querySelectorAll('.fr-marker[data-type=\\\"true\\\"]');if(!b.$wp)return b.markers.remove(),!1;if(0===c.length)return!1;if(b.browser.msie||b.browser.edge)for(var e=0;e<c.length;e++)c[e].style.display=\\\"inline-block\\\";b.core.hasFocus()||b.browser.msie||b.browser.webkit||b.$el.focus(),f();for(var g=d(),e=0;e<c.length;e++){var h=a(c[e]).data(\\\"id\\\"),i=c[e],j=b.doc.createRange(),k=b.$el.find('.fr-marker[data-type=\\\"false\\\"][data-id=\\\"'+h+'\\\"]');(b.browser.msie||b.browser.edge)&&k.css(\\\"display\\\",\\\"inline-block\\\");var l=null;if(k.length>0){k=k[0];try{for(var n=!1,o=i.nextSibling;o&&o.nodeType==Node.TEXT_NODE&&0==o.textContent.length;){var p=o;o=o.nextSibling,a(p).remove()}for(var q=k.nextSibling;q&&q.nodeType==Node.TEXT_NODE&&0==q.textContent.length;){var p=q;q=q.nextSibling,a(p).remove()}if(i.nextSibling==k||k.nextSibling==i){for(var r=i.nextSibling==k?i:k,s=r==i?k:i,t=r.previousSibling;t&&t.nodeType==Node.TEXT_NODE&&0==t.length;){var p=t;t=t.previousSibling,a(p).remove()}if(t&&t.nodeType==Node.TEXT_NODE)for(;t&&t.previousSibling&&t.previousSibling.nodeType==Node.TEXT_NODE;)t.previousSibling.textContent=t.previousSibling.textContent+t.textContent,t=t.previousSibling,a(t.nextSibling).remove();for(var u=s.nextSibling;u&&u.nodeType==Node.TEXT_NODE&&0==u.length;){var p=u;u=u.nextSibling,a(p).remove()}if(u&&u.nodeType==Node.TEXT_NODE)for(;u&&u.nextSibling&&u.nextSibling.nodeType==Node.TEXT_NODE;)u.nextSibling.textContent=u.textContent+u.nextSibling.textContent,u=u.nextSibling,a(u.previousSibling).remove();if(t&&(b.node.isVoid(t)||b.node.isBlock(t))&&(t=null),u&&(b.node.isVoid(u)||b.node.isBlock(u))&&(u=null),t&&u&&t.nodeType==Node.TEXT_NODE&&u.nodeType==Node.TEXT_NODE){a(i).remove(),a(k).remove();var v=t.textContent.length;t.textContent=t.textContent+u.textContent,a(u).remove(),b.spaces.normalize(t),j.setStart(t,v),j.setEnd(t,v),n=!0}else!t&&u&&u.nodeType==Node.TEXT_NODE?(a(i).remove(),a(k).remove(),b.spaces.normalize(u),l=a(b.doc.createTextNode(\\\"\\\\u200b\\\")),a(u).before(l),j.setStart(u,0),j.setEnd(u,0),n=!0):!u&&t&&t.nodeType==Node.TEXT_NODE&&(a(i).remove(),a(k).remove(),b.spaces.normalize(t),l=a(b.doc.createTextNode(\\\"\\\\u200b\\\")),a(t).after(l),j.setStart(t,t.textContent.length),j.setEnd(t,t.textContent.length),n=!0)}if(!n){var w,x;if(b.browser.chrome&&i.nextSibling==k)w=m(k,j,!0)||j.setStartAfter(k),x=m(i,j,!1)||j.setEndBefore(i);else{i.previousSibling==k&&(i=k,k=i.nextSibling),k.nextSibling&&\\\"BR\\\"===k.nextSibling.tagName||!k.nextSibling&&b.node.isBlock(i.previousSibling)||i.previousSibling&&\\\"BR\\\"==i.previousSibling.tagName||(i.style.display=\\\"inline\\\",k.style.display=\\\"inline\\\",l=a(b.doc.createTextNode(\\\"\\\\u200b\\\")));var y=i.previousSibling;y&&y.style&&\\\"block\\\"==b.win.getComputedStyle(y).display&&!b.opts.enter==a.FE.ENTER_BR?(j.setEndAfter(y),j.setStartAfter(y)):(w=m(i,j,!0)||a(i).before(l)&&j.setStartBefore(i),x=m(k,j,!1)||a(k).after(l)&&j.setEndAfter(k))}\\\"function\\\"==typeof w&&w(),\\\"function\\\"==typeof x&&x()}}catch(z){}}l&&l.remove();try{g.addRange(j)}catch(z){}}b.markers.remove()}function m(c,d,e){var f=c.previousSibling,g=c.nextSibling;if(f&&g&&f.nodeType==Node.TEXT_NODE&&g.nodeType==Node.TEXT_NODE){var h=f.textContent.length;return e?(g.textContent=f.textContent+g.textContent,a(f).remove(),a(c).remove(),b.spaces.normalize(g),function(){d.setStart(g,h)}):(f.textContent=f.textContent+g.textContent,a(g).remove(),a(c).remove(),b.spaces.normalize(f),function(){d.setEnd(f,h)})}if(f&&!g&&f.nodeType==Node.TEXT_NODE){var h=f.textContent.length;return e?(b.spaces.normalize(f),function(){d.setStart(f,h)}):(b.spaces.normalize(f),function(){d.setEnd(f,h)})}return!(!g||f||g.nodeType!=Node.TEXT_NODE)&&(e?(b.spaces.normalize(g),function(){d.setStart(g,0)}):(b.spaces.normalize(g),function(){d.setEnd(g,0)}))}function n(){return!0}function o(){for(var a=e(),b=0;b<a.length;b++)if(!a[b].collapsed)return!1;return!0}function p(a){var c,d,e=!1,f=!1;if(b.win.getSelection){var g=b.win.getSelection();g.rangeCount&&(c=g.getRangeAt(0),d=c.cloneRange(),d.selectNodeContents(a),d.setEnd(c.startContainer,c.startOffset),e=\\\"\\\"===d.toString(),d.selectNodeContents(a),d.setStart(c.endContainer,c.endOffset),f=\\\"\\\"===d.toString())}else b.doc.selection&&\\\"Control\\\"!=b.doc.selection.type&&(c=b.doc.selection.createRange(),d=c.duplicate(),d.moveToElementText(a),d.setEndPoint(\\\"EndToStart\\\",c),\\ne=\\\"\\\"===d.text,d.moveToElementText(a),d.setEndPoint(\\\"StartToEnd\\\",c),f=\\\"\\\"===d.text);return{atStart:e,atEnd:f}}function q(){if(o())return!1;b.$el.find(\\\"td, th, img\\\").prepend('<span class=\\\"fr-mk\\\">'+a.FE.INVISIBLE_SPACE+\\\"</span>\\\");var c=!1,d=p(b.el);return d.atStart&&d.atEnd&&(c=!0),b.$el.find(\\\".fr-mk\\\").remove(),c}function r(c,d){\\\"undefined\\\"==typeof d&&(d=!0);var e=a(c).html();e&&e.replace(/\\\\u200b/g,\\\"\\\").length!=e.length&&a(c).html(e.replace(/\\\\u200b/g,\\\"\\\"));for(var f=b.node.contents(c),g=0;g<f.length;g++)f[g].nodeType!=Node.ELEMENT_NODE?a(f[g]).remove():(r(f[g],0==g),0==g&&(d=!1));c.nodeType==Node.TEXT_NODE?a(c).replaceWith('<span data-first=\\\"true\\\" data-text=\\\"true\\\"></span>'):d&&a(c).attr(\\\"data-first\\\",!0)}function s(c,d){var e=b.node.contents(c.get(0));[\\\"TD\\\",\\\"TH\\\"].indexOf(c.get(0).tagName)>=0&&1==c.find(\\\".fr-marker\\\").length&&b.node.hasClass(e[0],\\\"fr-marker\\\")&&c.attr(\\\"data-del-cell\\\",!0);for(var f=0;f<e.length;f++){var g=e[f];b.node.hasClass(g,\\\"fr-marker\\\")?d=(d+1)%2:d?a(g).find(\\\".fr-marker\\\").length>0?d=s(a(g),d):[\\\"TD\\\",\\\"TH\\\"].indexOf(g.tagName)<0&&!b.node.hasClass(g,\\\"fr-inner\\\")?!b.opts.keepFormatOnDelete||b.$el.find(\\\"[data-first]\\\").length>0?a(g).remove():r(g):b.node.hasClass(g,\\\"fr-inner\\\")?0==a(g).find(\\\".fr-inner\\\").length?a(g).html(\\\"<br>\\\"):a(g).find(\\\".fr-inner\\\").filter(function(){return 0==a(this).find(\\\"fr-inner\\\").length}).html(\\\"<br>\\\"):(a(g).empty(),a(g).attr(\\\"data-del-cell\\\",!0)):a(g).find(\\\".fr-marker\\\").length>0&&(d=s(a(g),d))}return d}function t(){try{if(!b.$wp)return!1;for(var a=e(0),c=a.commonAncestorContainer;c&&!b.node.isElement(c);)c=c.parentNode;return!!b.node.isElement(c)}catch(d){return!1}}function u(){if(o())return!0;k();for(var c=function(b){for(var c=b.previousSibling;c&&c.nodeType==Node.TEXT_NODE&&0==c.textContent.length;){var d=c,c=c.previousSibling;a(d).remove()}return c},d=function(b){for(var c=b.nextSibling;c&&c.nodeType==Node.TEXT_NODE&&0==c.textContent.length;){var d=c,c=c.nextSibling;a(d).remove()}return c},e=b.$el.find('.fr-marker[data-type=\\\"true\\\"]'),f=0;f<e.length;f++)for(var g=e[f];!c(g)&&!b.node.isBlock(g.parentNode)&&!b.$el.is(g.parentNode);)a(g.parentNode).before(g);for(var h=b.$el.find('.fr-marker[data-type=\\\"false\\\"]'),f=0;f<h.length;f++){for(var i=h[f];!d(i)&&!b.node.isBlock(i.parentNode)&&!b.$el.is(i.parentNode);)a(i.parentNode).after(i);i.parentNode&&b.node.isBlock(i.parentNode)&&b.node.isEmpty(i.parentNode)&&!b.$el.is(i.parentNode)&&b.opts.keepFormatOnDelete&&a(i.parentNode).after(i)}if(n()){s(b.$el,0);var j=b.$el.find('[data-first=\\\"true\\\"]');if(j.length)b.$el.find(\\\".fr-marker\\\").remove(),j.append(a.FE.INVISIBLE_SPACE+a.FE.MARKERS).removeAttr(\\\"data-first\\\"),j.attr(\\\"data-text\\\")&&j.replaceWith(j.html());else{b.$el.find(\\\"table\\\").filter(function(){var b=a(this).find(\\\"[data-del-cell]\\\").length>0&&a(this).find(\\\"[data-del-cell]\\\").length==a(this).find(\\\"td, th\\\").length;return b}).remove(),b.$el.find(\\\"[data-del-cell]\\\").removeAttr(\\\"data-del-cell\\\");for(var e=b.$el.find('.fr-marker[data-type=\\\"true\\\"]'),f=0;f<e.length;f++){var m=e[f],p=m.nextSibling,q=b.$el.find('.fr-marker[data-type=\\\"false\\\"][data-id=\\\"'+a(m).data(\\\"id\\\")+'\\\"]').get(0);if(q){if(p&&p==q);else if(m){var r=b.node.blockParent(m),t=b.node.blockParent(q),u=!1,v=!1;if(r&&[\\\"UL\\\",\\\"OL\\\"].indexOf(r.tagName)>=0&&(r=null,u=!0),t&&[\\\"UL\\\",\\\"OL\\\"].indexOf(t.tagName)>=0&&(t=null,v=!0),a(m).after(q),r==t);else if(null!=r||u)if(null!=t||v||0!=a(r).parentsUntil(b.$el,\\\"table\\\").length)r&&t&&0==a(r).parentsUntil(b.$el,\\\"table\\\").length&&0==a(t).parentsUntil(b.$el,\\\"table\\\").length&&(a(r).append(a(t).html()),a(t).remove());else{for(var p=r;!p.nextSibling&&p.parentNode!=b.el;)p=p.parentNode;for(p=p.nextSibling;p&&\\\"BR\\\"!=p.tagName;){var w=p.nextSibling;a(r).append(p),p=w}p&&\\\"BR\\\"==p.tagName&&a(p).remove()}else{var x=b.node.deepestParent(m);x?(a(x).after(a(t).html()),a(t).remove()):0==a(t).parentsUntil(b.$el,\\\"table\\\").length&&(a(m).next().after(a(t).html()),a(t).remove())}}}else q=a(m).clone().attr(\\\"data-type\\\",!1),a(m).after(q)}}}b.opts.keepFormatOnDelete||b.html.fillEmptyBlocks(),b.html.cleanEmptyTags(!0),b.clean.lists(),b.spaces.normalize();var y=b.$el.find(\\\".fr-marker:last\\\").get(0),z=b.$el.find(\\\".fr-marker:first\\\").get(0);!y.nextSibling&&z.previousSibling&&\\\"BR\\\"==z.previousSibling.tagName&&b.node.isElement(y.parentNode)&&b.node.isElement(z.parentNode)&&b.$el.append(\\\"<br>\\\"),l()}function v(c){if(!c||c.getElementsByClassName(\\\"fr-marker\\\").length>0)return!1;for(var d=c.firstChild;d&&b.node.isBlock(d);)c=d,d=d.firstChild;c.innerHTML=a.FE.MARKERS+c.innerHTML}function w(c){if(!c||c.getElementsByClassName(\\\"fr-marker\\\").length>0)return!1;for(var d=c.lastChild;d&&b.node.isBlock(d);)c=d,d=d.lastChild;c.innerHTML=c.innerHTML+a.FE.MARKERS}function x(c,d){\\\"undefined\\\"==typeof d&&(d=!0);for(var e=c.previousSibling;e&&e.nodeType==Node.TEXT_NODE&&0==e.textContent.length;)e=e.previousSibling;return e?(b.node.isBlock(e)?w(e):\\\"BR\\\"==e.tagName?a(e).before(a.FE.MARKERS):a(e).after(a.FE.MARKERS),!0):!!d&&(b.node.isBlock(c)?v(c):a(c).before(a.FE.MARKERS),!0)}function y(c,d){\\\"undefined\\\"==typeof d&&(d=!0);for(var e=c.nextSibling;e&&e.nodeType==Node.TEXT_NODE&&0==e.textContent.length;)e=e.nextSibling;return e?(b.node.isBlock(e)?v(e):a(e).before(a.FE.MARKERS),!0):!!d&&(b.node.isBlock(c)?w(c):a(c).after(a.FE.MARKERS),!0)}return{text:c,get:d,ranges:e,clear:f,element:g,endElement:h,save:k,restore:l,isCollapsed:o,isFull:q,inEditor:t,remove:u,blocks:j,info:p,setAtEnd:w,setAtStart:v,setBefore:x,setAfter:y,rangeElement:i}},a.extend(a.FE.DEFAULTS,{htmlAllowedTags:[\\\"a\\\",\\\"abbr\\\",\\\"address\\\",\\\"area\\\",\\\"article\\\",\\\"aside\\\",\\\"audio\\\",\\\"b\\\",\\\"base\\\",\\\"bdi\\\",\\\"bdo\\\",\\\"blockquote\\\",\\\"br\\\",\\\"button\\\",\\\"canvas\\\",\\\"caption\\\",\\\"cite\\\",\\\"code\\\",\\\"col\\\",\\\"colgroup\\\",\\\"datalist\\\",\\\"dd\\\",\\\"del\\\",\\\"details\\\",\\\"dfn\\\",\\\"dialog\\\",\\\"div\\\",\\\"dl\\\",\\\"dt\\\",\\\"em\\\",\\\"embed\\\",\\\"fieldset\\\",\\\"figcaption\\\",\\\"figure\\\",\\\"footer\\\",\\\"form\\\",\\\"h1\\\",\\\"h2\\\",\\\"h3\\\",\\\"h4\\\",\\\"h5\\\",\\\"h6\\\",\\\"header\\\",\\\"hgroup\\\",\\\"hr\\\",\\\"i\\\",\\\"iframe\\\",\\\"img\\\",\\\"input\\\",\\\"ins\\\",\\\"kbd\\\",\\\"keygen\\\",\\\"label\\\",\\\"legend\\\",\\\"li\\\",\\\"link\\\",\\\"main\\\",\\\"map\\\",\\\"mark\\\",\\\"menu\\\",\\\"menuitem\\\",\\\"meter\\\",\\\"nav\\\",\\\"noscript\\\",\\\"object\\\",\\\"ol\\\",\\\"optgroup\\\",\\\"option\\\",\\\"output\\\",\\\"p\\\",\\\"param\\\",\\\"pre\\\",\\\"progress\\\",\\\"queue\\\",\\\"rp\\\",\\\"rt\\\",\\\"ruby\\\",\\\"s\\\",\\\"samp\\\",\\\"script\\\",\\\"style\\\",\\\"section\\\",\\\"select\\\",\\\"small\\\",\\\"source\\\",\\\"span\\\",\\\"strike\\\",\\\"strong\\\",\\\"sub\\\",\\\"summary\\\",\\\"sup\\\",\\\"table\\\",\\\"tbody\\\",\\\"td\\\",\\\"textarea\\\",\\\"tfoot\\\",\\\"th\\\",\\\"thead\\\",\\\"time\\\",\\\"tr\\\",\\\"track\\\",\\\"u\\\",\\\"ul\\\",\\\"var\\\",\\\"video\\\",\\\"wbr\\\"],htmlRemoveTags:[\\\"script\\\",\\\"style\\\"],htmlAllowedAttrs:[\\\"accept\\\",\\\"accept-charset\\\",\\\"accesskey\\\",\\\"action\\\",\\\"align\\\",\\\"allowfullscreen\\\",\\\"allowtransparency\\\",\\\"alt\\\",\\\"async\\\",\\\"autocomplete\\\",\\\"autofocus\\\",\\\"autoplay\\\",\\\"autosave\\\",\\\"background\\\",\\\"bgcolor\\\",\\\"border\\\",\\\"charset\\\",\\\"cellpadding\\\",\\\"cellspacing\\\",\\\"checked\\\",\\\"cite\\\",\\\"class\\\",\\\"color\\\",\\\"cols\\\",\\\"colspan\\\",\\\"content\\\",\\\"contenteditable\\\",\\\"contextmenu\\\",\\\"controls\\\",\\\"coords\\\",\\\"data\\\",\\\"data-.*\\\",\\\"datetime\\\",\\\"default\\\",\\\"defer\\\",\\\"dir\\\",\\\"dirname\\\",\\\"disabled\\\",\\\"download\\\",\\\"draggable\\\",\\\"dropzone\\\",\\\"enctype\\\",\\\"for\\\",\\\"form\\\",\\\"formaction\\\",\\\"frameborder\\\",\\\"headers\\\",\\\"height\\\",\\\"hidden\\\",\\\"high\\\",\\\"href\\\",\\\"hreflang\\\",\\\"http-equiv\\\",\\\"icon\\\",\\\"id\\\",\\\"ismap\\\",\\\"itemprop\\\",\\\"keytype\\\",\\\"kind\\\",\\\"label\\\",\\\"lang\\\",\\\"language\\\",\\\"list\\\",\\\"loop\\\",\\\"low\\\",\\\"max\\\",\\\"maxlength\\\",\\\"media\\\",\\\"method\\\",\\\"min\\\",\\\"mozallowfullscreen\\\",\\\"multiple\\\",\\\"name\\\",\\\"novalidate\\\",\\\"open\\\",\\\"optimum\\\",\\\"pattern\\\",\\\"ping\\\",\\\"placeholder\\\",\\\"poster\\\",\\\"preload\\\",\\\"pubdate\\\",\\\"radiogroup\\\",\\\"readonly\\\",\\\"rel\\\",\\\"required\\\",\\\"reversed\\\",\\\"rows\\\",\\\"rowspan\\\",\\\"sandbox\\\",\\\"scope\\\",\\\"scoped\\\",\\\"scrolling\\\",\\\"seamless\\\",\\\"selected\\\",\\\"shape\\\",\\\"size\\\",\\\"sizes\\\",\\\"span\\\",\\\"src\\\",\\\"srcdoc\\\",\\\"srclang\\\",\\\"srcset\\\",\\\"start\\\",\\\"step\\\",\\\"summary\\\",\\\"spellcheck\\\",\\\"style\\\",\\\"tabindex\\\",\\\"target\\\",\\\"title\\\",\\\"type\\\",\\\"translate\\\",\\\"usemap\\\",\\\"value\\\",\\\"valign\\\",\\\"webkitallowfullscreen\\\",\\\"width\\\",\\\"wrap\\\"],htmlAllowComments:!0,fullPage:!1}),a.FE.HTML5Map={B:\\\"STRONG\\\",I:\\\"EM\\\",STRIKE:\\\"S\\\"},a.FE.MODULES.clean=function(b){function c(a){if(a.nodeType==Node.ELEMENT_NODE&&a.getAttribute(\\\"class\\\")&&a.getAttribute(\\\"class\\\").indexOf(\\\"fr-marker\\\")>=0)return!1;var d,e=b.node.contents(a),f=[];for(d=0;d<e.length;d++)e[d].nodeType!=Node.ELEMENT_NODE||b.node.isVoid(e[d])?e[d].nodeType==Node.TEXT_NODE&&(e[d].textContent=e[d].textContent.replace(/\\\\u200b/g,\\\"\\\").replace(/&/g,\\\"&amp;\\\")):e[d].textContent.replace(/\\\\u200b/g,\\\"\\\").length!=e[d].textContent.length&&c(e[d]);if(a.nodeType==Node.ELEMENT_NODE&&!b.node.isVoid(a)&&(a.normalize(),e=b.node.contents(a),f=a.querySelectorAll(\\\".fr-marker\\\"),e.length-f.length==0)){for(d=0;d<e.length;d++)if((e[d].getAttribute(\\\"class\\\")||\\\"\\\").indexOf(\\\"fr-marker\\\")<0)return!1;for(d=0;d<f.length;d++)a.parentNode.insertBefore(f[d].cloneNode(!0),a);return a.parentNode.removeChild(a),!1}}function d(a){if(a.nodeType==Node.COMMENT_NODE)return\\\"<!--\\\"+a.nodeValue+\\\"-->\\\";if(a.nodeType==Node.TEXT_NODE)return a.textContent.replace(/\\\\&/g,\\\"&amp;\\\").replace(/\\\\</g,\\\"&lt;\\\").replace(/\\\\>/g,\\\"&gt;\\\").replace(/\\\\u00A0/g,\\\"&nbsp;\\\");if(a.nodeType!=Node.ELEMENT_NODE)return a.outerHTML;if(a.nodeType==Node.ELEMENT_NODE&&[\\\"STYLE\\\",\\\"SCRIPT\\\"].indexOf(a.tagName)>=0)return a.outerHTML;if(a.nodeType==Node.ELEMENT_NODE&&\\\"svg\\\"==a.tagName){var c=document.createElement(\\\"div\\\"),e=a.cloneNode(!0);return c.appendChild(e),c.innerHTML}if(\\\"IFRAME\\\"==a.tagName)return a.outerHTML;var f=a.childNodes;if(0===f.length)return a.outerHTML;for(var g=\\\"\\\",h=0;h<f.length;h++)g+=d(f[h]);return b.node.openTagString(a)+g+b.node.closeTagString(a)}function e(a){return H=[],a=a.replace(/<script\\\\b[^<]*(?:(?!<\\\\/script>)<[^<]*)*<\\\\/script>/gi,function(a){return H.push(a),\\\"[FROALA.EDITOR.SCRIPT \\\"+(H.length-1)+\\\"]\\\"}),a=a.replace(/<img((?:[\\\\w\\\\W]*?)) src=\\\"/g,'<img$1 data-fr-src=\\\"')}function f(a){return a=a.replace(/\\\\[FROALA\\\\.EDITOR\\\\.SCRIPT ([\\\\d]*)\\\\]/gi,function(a,c){return b.opts.htmlRemoveTags.indexOf(\\\"script\\\")>=0?\\\"\\\":H[parseInt(c,10)]}),a=a.replace(/<img((?:[\\\\w\\\\W]*?)) data-fr-src=\\\"/g,'<img$1 src=\\\"')}function g(a){var b;for(b in a)a.hasOwnProperty(b)&&(b.match(G)||delete a[b]);for(var c=\\\"\\\",d=Object.keys(a).sort(),e=0;e<d.length;e++)b=d[e],c+=a[b].indexOf('\\\"')<0?\\\" \\\"+b+'=\\\"'+a[b]+'\\\"':\\\" \\\"+b+\\\"='\\\"+a[b]+\\\"'\\\";return c}function h(a,c,d){if(b.opts.fullPage){var e=b.html.extractDoctype(d),f=g(b.html.extractNodeAttrs(d,\\\"html\\\"));c=null==c?b.html.extractNode(d,\\\"head\\\")||\\\"<title></title>\\\":c;var h=g(b.html.extractNodeAttrs(d,\\\"head\\\")),i=g(b.html.extractNodeAttrs(d,\\\"body\\\"));return e+\\\"<html\\\"+f+\\\"><head\\\"+h+\\\">\\\"+c+\\\"</head><body\\\"+i+\\\">\\\"+a+\\\"</body></html>\\\"}return a}function i(c,e){var f=a(\\\"<div>\\\"+c+\\\"</div>\\\"),g=\\\"\\\";if(f){for(var h=b.node.contents(f.get(0)),i=0;i<h.length;i++)e(h[i]);h=b.node.contents(f.get(0));for(var i=0;i<h.length;i++)g+=d(h[i])}return g}function j(a,c,d){a=e(a);var g=a,j=null;if(b.opts.fullPage){var g=b.html.extractNode(a,\\\"body\\\")||(a.indexOf(\\\"<body\\\")>=0?\\\"\\\":a);d&&(j=b.html.extractNode(a,\\\"head\\\")||\\\"\\\")}g=i(g,c),j&&(j=i(j,c));var k=h(g,j,a);return f(k)}function k(a){return a.replace(/\\\\u200b/g,\\\"\\\").length==a.length?a:b.clean.exec(a,c)}function l(){var c=b.el.querySelectorAll(Object.keys(a.FE.HTML5Map).join(\\\",\\\"));if(c.length){var d=!1;b.el.querySelector(\\\".fr-marker\\\")||(b.selection.save(),d=!0);for(var e=0;e<c.length;e++)\\\"\\\"===b.node.attributes(c[e])&&a(c[e]).replaceWith(\\\"<\\\"+a.FE.HTML5Map[c[e].tagName]+\\\">\\\"+c[e].innerHTML+\\\"</\\\"+a.FE.HTML5Map[c[e].tagName]+\\\">\\\");d&&b.selection.restore()}}function m(c){if(\\\"SPAN\\\"==c.tagName&&(c.getAttribute(\\\"class\\\")||\\\"\\\").indexOf(\\\"fr-marker\\\")>=0)return!1;if(\\\"PRE\\\"==c.tagName&&o(c),c.nodeType==Node.ELEMENT_NODE&&(c.getAttribute(\\\"data-fr-src\\\")&&c.setAttribute(\\\"data-fr-src\\\",b.helpers.sanitizeURL(c.getAttribute(\\\"data-fr-src\\\"))),c.getAttribute(\\\"href\\\")&&c.setAttribute(\\\"href\\\",b.helpers.sanitizeURL(c.getAttribute(\\\"href\\\"))),[\\\"TABLE\\\",\\\"TBODY\\\",\\\"TFOOT\\\",\\\"TR\\\"].indexOf(c.tagName)>=0&&(c.innerHTML=c.innerHTML.trim())),!b.opts.pasteAllowLocalImages&&c.nodeType==Node.ELEMENT_NODE&&\\\"IMG\\\"==c.tagName&&c.getAttribute(\\\"data-fr-src\\\")&&0==c.getAttribute(\\\"data-fr-src\\\").indexOf(\\\"file://\\\"))return c.parentNode.removeChild(c),!1;if(c.nodeType==Node.ELEMENT_NODE&&a.FE.HTML5Map[c.tagName]&&\\\"\\\"===b.node.attributes(c)){var d=a.FE.HTML5Map[c.tagName],e=\\\"<\\\"+d+\\\">\\\"+c.innerHTML+\\\"</\\\"+d+\\\">\\\";c.insertAdjacentHTML(\\\"beforebegin\\\",e),c=c.previousSibling,c.parentNode.removeChild(c.nextSibling)}if(b.opts.htmlAllowComments||c.nodeType!=Node.COMMENT_NODE)if(c.tagName&&c.tagName.match(F))c.parentNode.removeChild(c);else if(c.tagName&&!c.tagName.match(E))c.outerHTML=c.innerHTML;else{var f=c.attributes;if(f)for(var g=f.length-1;g>=0;g--){var h=f[g];h.nodeName.match(G)||c.removeAttribute(h.nodeName)}}else 0!==c.data.indexOf(\\\"[FROALA.EDITOR\\\")&&c.parentNode.removeChild(c)}function n(a){for(var c=b.node.contents(a),d=0;d<c.length;d++)c[d].nodeType!=Node.TEXT_NODE&&n(c[d]);m(a)}function o(a){var b=a.innerHTML;b.indexOf(\\\"\\\\n\\\")>=0&&(a.innerHTML=b.replace(/\\\\n/g,\\\"<br>\\\"))}function p(c,d,e,f){\\\"undefined\\\"==typeof d&&(d=[]),\\\"undefined\\\"==typeof e&&(e=[]),\\\"undefined\\\"==typeof f&&(f=!1),c=c.replace(/\\\\u0009/g,\\\"\\\");var g,h=a.merge([],b.opts.htmlAllowedTags);for(g=0;g<d.length;g++)h.indexOf(d[g])>=0&&h.splice(h.indexOf(d[g]),1);var i=a.merge([],b.opts.htmlAllowedAttrs);for(g=0;g<e.length;g++)i.indexOf(e[g])>=0&&i.splice(i.indexOf(e[g]),1);return i.push(\\\"data-fr-.*\\\"),i.push(\\\"fr-.*\\\"),E=new RegExp(\\\"^\\\"+h.join(\\\"$|^\\\")+\\\"$\\\",\\\"gi\\\"),G=new RegExp(\\\"^\\\"+i.join(\\\"$|^\\\")+\\\"$\\\",\\\"gi\\\"),F=new RegExp(\\\"^\\\"+b.opts.htmlRemoveTags.join(\\\"$|^\\\")+\\\"$\\\",\\\"gi\\\"),c=j(c,n,!0)}function q(){for(var c=b.el.querySelectorAll(\\\"blockquote + blockquote\\\"),d=0;d<c.length;d++){var e=c[d];b.node.attributes(e)==b.node.attributes(e.previousSibling)&&(a(e).prev().append(a(e).html()),a(e).remove())}}function r(){for(var a=b.el.querySelectorAll(\\\"tr\\\"),c=0;c<a.length;c++){for(var d=a[c].children,e=!0,f=0;f<d.length;f++)if(\\\"TH\\\"!=d[f].tagName){e=!1;break}if(0!=e&&0!=d.length){for(var g=a[c];g&&\\\"TABLE\\\"!=g.tagName&&\\\"THEAD\\\"!=g.tagName;)g=g.parentNode;var h=g;\\\"THEAD\\\"!=h.tagName&&(h=b.doc.createElement(\\\"THEAD\\\"),g.insertBefore(h,g.firstChild)),h.appendChild(a[c])}}}function s(){var c=b.html.defaultTag();if(c)for(var d=b.el.querySelectorAll(\\\"td > \\\"+c+\\\", th > \\\"+c),e=0;e<d.length;e++)\\\"\\\"===b.node.attributes(d[e])&&a(d[e]).replaceWith(d[e].innerHTML+\\\"<br>\\\")}function t(){r(),s()}function u(){var a=[],c=function(a){return!b.node.isList(a.parentNode)};do{if(a.length){var d=a[0],e=b.doc.createElement(\\\"ul\\\");d.parentNode.insertBefore(e,d);do{var f=d;d=d.nextSibling,e.appendChild(f)}while(d&&\\\"LI\\\"==d.tagName)}a=[];for(var g=b.el.querySelectorAll(\\\"li\\\"),h=0;h<g.length;h++)c(g[h])&&a.push(g[h])}while(a.length>0)}function v(){for(var a=b.el.querySelectorAll(\\\"ol + ol, ul + ul\\\"),c=0;c<a.length;c++){var d=a[c];if(b.node.isList(d.previousSibling)&&b.node.openTagString(d)==b.node.openTagString(d.previousSibling)){for(var e=b.node.contents(d),f=0;f<e.length;f++)d.previousSibling.appendChild(e[f]);d.parentNode.removeChild(d)}}}function w(){var a,c=function(b){b.querySelector(\\\"LI\\\")||(a=!0,b.parentNode.removeChild(b))};do{a=!1;for(var d=b.el.querySelectorAll(\\\"li:empty\\\"),e=0;e<d.length;e++)d[e].parentNode.removeChild(d[e]);for(var f=b.el.querySelectorAll(\\\"ul, ol\\\"),e=0;e<f.length;e++)c(f[e])}while(a===!0)}function x(){for(var c=b.el.querySelectorAll(\\\"ul > ul, ol > ol, ul > ol, ol > ul\\\"),d=0;d<c.length;d++){var e=c[d],f=e.previousSibling;f&&(\\\"LI\\\"==f.tagName?f.appendChild(e):a(e).wrap(\\\"<li></li>\\\"))}}function y(){for(var c=b.el.querySelectorAll(\\\"li > ul, li > ol\\\"),d=0;d<c.length;d++){var e=c[d];if(e.nextSibling){var f=e.nextSibling,g=a(\\\"<li>\\\");a(e.parentNode).after(g);do{var h=f;f=f.nextSibling,g.append(h)}while(f)}}}function z(){for(var c=b.el.querySelectorAll(\\\"li > ul, li > ol\\\"),d=0;d<c.length;d++){var e=c[d];if(b.node.isFirstSibling(e))a(e).before(\\\"<br/>\\\");else if(e.previousSibling&&\\\"BR\\\"==e.previousSibling.tagName){for(var f=e.previousSibling.previousSibling;f&&b.node.hasClass(f,\\\"fr-marker\\\");)f=f.previousSibling;f&&\\\"BR\\\"!=f.tagName&&a(e.previousSibling).remove()}}}function A(){for(var c=b.el.querySelectorAll(\\\"li:empty\\\"),d=0;d<c.length;d++)a(c[d]).remove()}function B(){for(var c=b.el.querySelectorAll(\\\"ul, ol\\\"),d=0;d<c.length;d++)for(var e=b.node.contents(c[d]),f=null,g=e.length-1;g>=0;g--)\\\"LI\\\"!=e[g].tagName?(f||(f=a(\\\"<li>\\\"),f.insertBefore(e[g])),f.prepend(e[g])):f=null}function C(){u(),v(),w(),x(),y(),z(),B(),A()}function D(){b.opts.fullPage&&a.merge(b.opts.htmlAllowedTags,[\\\"head\\\",\\\"title\\\",\\\"style\\\",\\\"link\\\",\\\"base\\\",\\\"body\\\",\\\"html\\\",\\\"meta\\\"])}var E,F,G,H=[],H=[];return{_init:D,html:p,toHTML5:l,tables:t,lists:C,quotes:q,invisibleSpaces:k,exec:j}},a.FE.MODULES.spaces=function(b){function c(c,d){var e=c.previousSibling,f=c.nextSibling,g=c.textContent,h=c.parentNode;d&&(g=g.replace(/[\\\\f\\\\n\\\\r\\\\t\\\\v ]{2,}/g,\\\" \\\"),(!f||b.node.isVoid(f)||b.node.isBlock(f))&&b.node.isBlock(h)&&(g=g.replace(/[\\\\f\\\\n\\\\r\\\\t\\\\v ]{1,}$/g,\\\"\\\")),(!e||b.node.isVoid(e)||b.node.isBlock(e))&&b.node.isBlock(h)&&(g=g.replace(/^[\\\\f\\\\n\\\\r\\\\t\\\\v ]{1,}/g,\\\"\\\"))),g=g.replace(new RegExp(a.FE.UNICODE_NBSP,\\\"g\\\"),\\\" \\\");for(var i=\\\"\\\",j=0;j<g.length;j++)i+=32!=g.charCodeAt(j)||0!==j&&32!=i.charCodeAt(j-1)?g[j]:a.FE.UNICODE_NBSP;(!f||b.node.isBlock(f)||f.nodeType==Node.ELEMENT_NODE&&b.win.getComputedStyle(f)&&\\\"block\\\"==b.win.getComputedStyle(f).display)&&(i=i.replace(/ $/,a.FE.UNICODE_NBSP)),!e||b.node.isVoid(e)||b.node.isBlock(e)||(i=i.replace(/^\\\\u00A0([^ $])/,\\\" $1\\\"),1!==i.length||160!==i.charCodeAt(0)||!f||b.node.isVoid(f)||b.node.isBlock(f)||(i=\\\" \\\")),i=i.replace(/([^ \\\\u00A0])\\\\u00A0([^ \\\\u00A0])/g,\\\"$1 $2\\\"),c.textContent!=i&&(c.textContent=i)}function d(a,d){if(\\\"undefined\\\"!=typeof a&&a||(a=b.el),\\\"undefined\\\"==typeof d&&(d=!1),!a.getAttribute||\\\"false\\\"!=a.getAttribute(\\\"contenteditable\\\"))if(a.nodeType==Node.TEXT_NODE)c(a,d);else if(a.nodeType==Node.ELEMENT_NODE)for(var e=b.doc.createTreeWalker(a,NodeFilter.SHOW_TEXT,b.node.filter(function(a){return null!=a.textContent.match(/([ \\\\u00A0\\\\f\\\\n\\\\r\\\\t\\\\v]{2,})|(^[ \\\\u00A0\\\\f\\\\n\\\\r\\\\t\\\\v]{1,})|([ \\\\u00A0\\\\f\\\\n\\\\r\\\\t\\\\v]{1,}$)/g)&&!b.node.hasClass(a.parentNode,\\\"fr-marker\\\")}),!1);e.nextNode();)c(e.currentNode,d)}function e(){for(var a=[],c=b.el.querySelectorAll(\\\".fr-marker\\\"),e=0;e<c.length;e++){var f=null,g=b.node.blockParent(c[e]);f=g?g:c[e];for(var h=f.nextSibling,i=f.previousSibling;h&&\\\"BR\\\"==h.tagName;)h=h.nextSibling;for(;i&&\\\"BR\\\"==i.tagName;)i=i.previousSibling;f&&a.indexOf(f)<0&&a.push(f),i&&a.indexOf(i)<0&&a.push(i),h&&a.indexOf(h)<0&&a.push(h)}for(var j=0;j<a.length;j++)d(a[j])}return{normalize:d,normalizeAroundCursor:e}},a.FE.UNICODE_NBSP=String.fromCharCode(160),a.FE.VOID_ELEMENTS=[\\\"area\\\",\\\"base\\\",\\\"br\\\",\\\"col\\\",\\\"embed\\\",\\\"hr\\\",\\\"img\\\",\\\"input\\\",\\\"keygen\\\",\\\"link\\\",\\\"menuitem\\\",\\\"meta\\\",\\\"param\\\",\\\"source\\\",\\\"track\\\",\\\"wbr\\\"],a.FE.BLOCK_TAGS=[\\\"address\\\",\\\"article\\\",\\\"aside\\\",\\\"audio\\\",\\\"blockquote\\\",\\\"canvas\\\",\\\"dd\\\",\\\"div\\\",\\\"dl\\\",\\\"dt\\\",\\\"fieldset\\\",\\\"figcaption\\\",\\\"figure\\\",\\\"footer\\\",\\\"form\\\",\\\"h1\\\",\\\"h2\\\",\\\"h3\\\",\\\"h4\\\",\\\"h5\\\",\\\"h6\\\",\\\"header\\\",\\\"hgroup\\\",\\\"hr\\\",\\\"li\\\",\\\"main\\\",\\\"nav\\\",\\\"noscript\\\",\\\"ol\\\",\\\"output\\\",\\\"p\\\",\\\"pre\\\",\\\"section\\\",\\\"table\\\",\\\"tbody\\\",\\\"td\\\",\\\"tfoot\\\",\\\"th\\\",\\\"thead\\\",\\\"tr\\\",\\\"ul\\\",\\\"video\\\"],a.extend(a.FE.DEFAULTS,{htmlAllowedEmptyTags:[\\\"textarea\\\",\\\"a\\\",\\\"iframe\\\",\\\"object\\\",\\\"video\\\",\\\"style\\\",\\\"script\\\",\\\".fa\\\",\\\".fr-emoticon\\\"],htmlDoNotWrapTags:[\\\"script\\\",\\\"style\\\"],htmlSimpleAmpersand:!1,htmlIgnoreCSSProperties:[]}),a.FE.MODULES.html=function(b){function c(){return b.opts.enter==a.FE.ENTER_P?\\\"p\\\":b.opts.enter==a.FE.ENTER_DIV?\\\"div\\\":b.opts.enter==a.FE.ENTER_BR?null:void 0}function d(c){var d=[],e=[];if(c)for(var g=b.el.querySelectorAll(\\\".fr-marker\\\"),h=0;h<g.length;h++){var i=b.node.blockParent(g[h])||g[h];if(i){var j=i.nextSibling,k=i.previousSibling;i&&e.indexOf(i)<0&&b.node.isBlock(i)&&e.push(i),k&&b.node.isBlock(k)&&e.indexOf(k)<0&&e.push(k),j&&b.node.isBlock(j)&&e.indexOf(j)<0&&e.push(j)}}else e=b.el.querySelectorAll(f());var l=f();l+=\\\",\\\"+a.FE.VOID_ELEMENTS.join(\\\",\\\"),l+=\\\",\\\"+b.opts.htmlAllowedEmptyTags.join(\\\":not(.fr-marker),\\\")+\\\":not(.fr-marker)\\\";for(var h=e.length-1;h>=0;h--)if(!(e[h].textContent&&e[h].textContent.replace(/\\\\u200B|\\\\n/g,\\\"\\\").length>0||e[h].querySelectorAll(l).length>0)){for(var m=b.node.contents(e[h]),n=!1,o=0;o<m.length;o++)if(m[o].nodeType!=Node.COMMENT_NODE&&m[o].textContent&&m[o].textContent.replace(/\\\\u200B|\\\\n/g,\\\"\\\").length>0){n=!0;break}n||d.push(e[h])}return d}function e(){return a.FE.BLOCK_TAGS.join(\\\":empty, \\\")+\\\":empty\\\"}function f(){return a.FE.BLOCK_TAGS.join(\\\", \\\")}function g(c){var d=a.merge([],a.FE.VOID_ELEMENTS);d=a.merge(d,b.opts.htmlAllowedEmptyTags),\\\"undefined\\\"==typeof c&&(d=a.merge(d,a.FE.BLOCK_TAGS));var e,f;e=b.el.querySelectorAll(\\\"*:empty:not(\\\"+d.join(\\\"):not(\\\")+\\\"):not(.fr-marker)\\\");do{f=!1;for(var g=0;g<e.length;g++)0!==e[g].attributes.length&&\\\"undefined\\\"==typeof e[g].getAttribute(\\\"href\\\")||(e[g].parentNode.removeChild(e[g]),f=!0);e=b.el.querySelectorAll(\\\"*:empty:not(\\\"+d.join(\\\"):not(\\\")+\\\"):not(.fr-marker)\\\")}while(e.length&&f)}function h(a,d){var e=c();if(d&&(e=\\\"div\\\"),e){for(var f=b.doc.createDocumentFragment(),g=null,h=!1,i=a.firstChild;i;){var j=i.nextSibling;if(i.nodeType==Node.ELEMENT_NODE&&(b.node.isBlock(i)||b.opts.htmlDoNotWrapTags.indexOf(i.tagName.toLowerCase())>=0&&!b.node.hasClass(i,\\\"fr-marker\\\")))g=null,f.appendChild(i);else if(i.nodeType!=Node.ELEMENT_NODE&&i.nodeType!=Node.TEXT_NODE)g=null,f.appendChild(i);else if(\\\"BR\\\"==i.tagName)j&&\\\"BR\\\"==j.tagName&&(j=j.nextSibling),null==g?(g=b.doc.createElement(e),d&&g.setAttribute(\\\"data-empty\\\",!0),g.appendChild(i),f.appendChild(g)):h===!1&&(g.appendChild(b.doc.createElement(\\\"br\\\")),g.setAttribute(\\\"data-empty\\\",!0)),g=null;else{var k=i.textContent;i.nodeType==Node.TEXT_NODE&&0==k.replace(/\\\\n/g,\\\"\\\").replace(/(^ *)|( *$)/g,\\\"\\\").length||(null==g&&(g=b.doc.createElement(e),d&&g.setAttribute(\\\"class\\\",\\\"fr-temp-div\\\"),f.appendChild(g),h=!1),g.appendChild(i),h||b.node.hasClass(i,\\\"fr-marker\\\")||i.nodeType==Node.TEXT_NODE&&0===k.replace(/ /g,\\\"\\\").length||(h=!0))}i=j}a.innerHTML=\\\"\\\",a.appendChild(f)}}function i(a,b){for(var c=0;c<a.length;c++)h(a[c],b)}function j(a,c,d,e){return!!b.$wp&&(\\\"undefined\\\"==typeof a&&(a=!1),\\\"undefined\\\"==typeof c&&(c=!1),\\\"undefined\\\"==typeof d&&(d=!1),\\\"undefined\\\"==typeof e&&(e=!1),h(b.el,a),e&&i(b.el.querySelectorAll(\\\".fr-inner\\\"),a),c&&i(b.el.querySelectorAll(\\\"td, th\\\"),a),void(d&&i(b.el.querySelectorAll(\\\"blockquote\\\"),a)))}function k(){b.$el.find(\\\"div.fr-temp-div\\\").each(function(){a(this).data(\\\"empty\\\")||\\\"LI\\\"==this.parentNode.tagName||b.node.isBlock(this.previousSibling)?a(this).replaceWith(a(this).html()):a(this).replaceWith(a(this).html()+\\\"<br>\\\")}),b.$el.find(\\\".fr-temp-div\\\").removeClass(\\\"fr-temp-div\\\").filter(function(){return\\\"\\\"==a(this).attr(\\\"class\\\")}).removeAttr(\\\"class\\\")}function l(c){for(var e=d(c),f=0;f<e.length;f++){var g=e[f];\\\"false\\\"==g.getAttribute(\\\"contenteditable\\\")||g.querySelector(b.opts.htmlAllowedEmptyTags.join(\\\":not(.fr-marker),\\\")+\\\":not(.fr-marker)\\\")||b.node.isVoid(g)||\\\"TABLE\\\"!=g.tagName&&\\\"TBODY\\\"!=g.tagName&&\\\"TR\\\"!=g.tagName&&g.appendChild(b.doc.createElement(\\\"br\\\"))}if(b.browser.msie&&b.opts.enter==a.FE.ENTER_BR){var h=b.node.contents(b.el);h.length&&h[h.length-1].nodeType==Node.TEXT_NODE&&b.$el.append(\\\"<br>\\\")}}function m(){return b.$el.get(0).querySelectorAll(f())}function n(a){if(\\\"undefined\\\"==typeof a&&(a=b.el),a&&[\\\"SCRIPT\\\",\\\"STYLE\\\",\\\"PRE\\\"].indexOf(a.tagName)>=0)return!1;for(var c=b.doc.createTreeWalker(a,NodeFilter.SHOW_TEXT,b.node.filter(function(a){return null!=a.textContent.match(/([ \\\\n]{2,})|(^[ \\\\n]{1,})|([ \\\\n]{1,}$)/g)}),!1);c.nextNode();){var d=c.currentNode,e=b.node.isBlock(d.parentNode)||b.node.isElement(d.parentNode),f=d.textContent.replace(/(?!^)( ){2,}(?!$)/g,\\\" \\\").replace(/\\\\n/g,\\\" \\\").replace(/^[ ]{2,}/g,\\\" \\\").replace(/[ ]{2,}$/g,\\\" \\\");if(e){var g=d.previousSibling,h=d.nextSibling;g&&h&&\\\" \\\"==f?f=b.node.isBlock(g)&&b.node.isBlock(h)?\\\"\\\":\\\"\\\\n\\\":(g||(f=f.replace(/^ */,\\\"\\\")),h||(f=f.replace(/ *$/,\\\"\\\")))}d.textContent=f}}function o(a,b,c){var d=new RegExp(b,\\\"gi\\\"),e=d.exec(a);return e?e[c]:null}function p(a,b){var c=a.match(/<!DOCTYPE ?([^ ]*) ?([^ ]*) ?\\\"?([^\\\"]*)\\\"? ?\\\"?([^\\\"]*)\\\"?>/i);return c?b.implementation.createDocumentType(c[1],c[3],c[4]):b.implementation.createDocumentType(\\\"html\\\")}function q(a){var b=a.doctype,c=\\\"<!DOCTYPE html>\\\";return b&&(c=\\\"<!DOCTYPE \\\"+b.name+(b.publicId?' PUBLIC \\\"'+b.publicId+'\\\"':\\\"\\\")+(!b.publicId&&b.systemId?\\\" SYSTEM\\\":\\\"\\\")+(b.systemId?' \\\"'+b.systemId+'\\\"':\\\"\\\")+\\\">\\\"),c}function r(c,d){var e=c.parentNode;if(e&&(b.node.isBlock(e)||b.node.isElement(e))&&[\\\"TD\\\",\\\"TH\\\"].indexOf(e.tagName)<0){var f=c.previousSibling,g=c.nextSibling;f&&e&&\\\"BR\\\"!=f.tagName&&!b.node.isBlock(f)&&!g&&e.textContent.replace(/\\\\u200B/g,\\\"\\\").length>0&&f.textContent.length>0&&!b.node.hasClass(f,\\\"fr-marker\\\")&&(b.el==e&&!g&&b.opts.enter==a.FE.ENTER_BR&&b.browser.msie||(d&&b.selection.save(),c.parentNode.removeChild(c),d&&b.selection.restore()))}}function s(){var a,c=b.selection.element();a=b.node.isBlock(c)?c:b.node.blockParent(c);var d=[];if(a){var e=a.nextSibling,f=a.previousSibling;a&&d.indexOf(a)<0&&d.push(a),f&&b.node.isBlock(f)&&d.indexOf(f)<0&&d.push(f),e&&b.node.isBlock(e)&&d.indexOf(e)<0&&d.push(e)}for(var g=[],h=0;h<d.length;h++)for(var i=d[h].querySelectorAll(\\\"br\\\"),j=0;j<i.length;j++)g.indexOf(i[j])<0&&g.push(i[j]);if(c.parentNode==b.el)for(var k=b.el.children,h=0;h<k.length;h++)\\\"BR\\\"==k[h].tagName&&g.indexOf(k[h])<0&&g.push(k[h]);return g}function t(a,c){var d;if(a){d=s();for(var e=0;e<d.length;e++)r(d[e],c)}else{d=b.el.getElementsByTagName(\\\"br\\\");for(var e=0;e<d.length;e++)r(d[e],c)}}function u(){g(),j(),n(),b.spaces.normalize(null,!0),b.html.fillEmptyBlocks(),b.clean.quotes(),b.clean.lists(),b.clean.tables(),b.clean.toHTML5(),b.html.cleanBRs(),b.selection.restore(),v(),b.placeholder.refresh()}function v(){b.core.isEmpty()&&(null!=c()?b.el.querySelector(f())||b.el.querySelector(b.opts.htmlDoNotWrapTags.join(\\\":not(.fr-marker),\\\")+\\\":not(.fr-marker)\\\")||(b.core.hasFocus()?(b.$el.html(\\\"<\\\"+c()+\\\">\\\"+a.FE.MARKERS+\\\"<br/></\\\"+c()+\\\">\\\"),b.selection.restore()):b.$el.html(\\\"<\\\"+c()+\\\"><br/></\\\"+c()+\\\">\\\")):b.el.querySelector(\\\"*:not(.fr-marker):not(br)\\\")||(b.core.hasFocus()?(b.$el.html(a.FE.MARKERS+\\\"<br/>\\\"),b.selection.restore()):b.$el.html(\\\"<br/>\\\")))}function w(a,b){return o(a,\\\"<\\\"+b+\\\"[^>]*?>([\\\\\\\\w\\\\\\\\W]*)</\\\"+b+\\\">\\\",1)}function x(c,d){var e=a(\\\"<div \\\"+(o(c,\\\"<\\\"+d+\\\"([^>]*?)>\\\",1)||\\\"\\\")+\\\">\\\");return b.node.rawAttributes(e.get(0))}function y(a){return o(a,\\\"<!DOCTYPE([^>]*?)>\\\",0)||\\\"<!DOCTYPE html>\\\"}function z(c){var d=b.clean.html(c||\\\"\\\",[],[],b.opts.fullPage);if(b.opts.fullPage){var e=w(d,\\\"body\\\")||(d.indexOf(\\\"<body\\\")>=0?\\\"\\\":d),f=x(d,\\\"body\\\"),g=w(d,\\\"head\\\")||\\\"<title></title>\\\",h=x(d,\\\"head\\\"),i=a(\\\"<div>\\\").append(g).contents().each(function(){(this.nodeType==Node.COMMENT_NODE||[\\\"BASE\\\",\\\"LINK\\\",\\\"META\\\",\\\"NOSCRIPT\\\",\\\"SCRIPT\\\",\\\"STYLE\\\",\\\"TEMPLATE\\\",\\\"TITLE\\\"].indexOf(this.tagName)>=0)&&this.parentNode.removeChild(this)}).end().html().trim();g=a(\\\"<div>\\\").append(g).contents().map(function(){return this.nodeType==Node.COMMENT_NODE?\\\"<!--\\\"+this.nodeValue+\\\"-->\\\":[\\\"BASE\\\",\\\"LINK\\\",\\\"META\\\",\\\"NOSCRIPT\\\",\\\"SCRIPT\\\",\\\"STYLE\\\",\\\"TEMPLATE\\\",\\\"TITLE\\\"].indexOf(this.tagName)>=0?this.outerHTML:\\\"\\\"}).toArray().join(\\\"\\\");var j=y(d),k=x(d,\\\"html\\\");b.$el.html(i+\\\"\\\\n\\\"+e),b.node.clearAttributes(b.el),b.$el.attr(f),b.$el.addClass(\\\"fr-view\\\"),b.$el.attr(\\\"spellcheck\\\",b.opts.spellcheck),b.$el.attr(\\\"dir\\\",b.opts.direction),b.$head.html(g),b.node.clearAttributes(b.$head.get(0)),b.$head.attr(h),b.node.clearAttributes(b.$html.get(0)),b.$html.attr(k),b.iframe_document.doctype.parentNode.replaceChild(p(j,b.iframe_document),b.iframe_document.doctype)}else b.$el.html(d);var l=b.edit.isDisabled();b.edit.on(),b.core.injectStyle(b.opts.iframeStyle),u(),b.opts.useClasses||(b.$el.find(\\\"[fr-original-class]\\\").each(function(){this.setAttribute(\\\"class\\\",this.getAttribute(\\\"fr-original-class\\\")),this.removeAttribute(\\\"fr-original-class\\\")}),b.$el.find(\\\"[fr-original-style]\\\").each(function(){this.setAttribute(\\\"style\\\",this.getAttribute(\\\"fr-original-style\\\")),this.removeAttribute(\\\"fr-original-style\\\")})),l&&b.edit.off(),b.events.trigger(\\\"html.set\\\")}function A(a,c){if(!b.$wp)return b.$oel.clone().removeClass(\\\"fr-view\\\").removeAttr(\\\"contenteditable\\\").get(0).outerHTML;var d=\\\"\\\";b.events.trigger(\\\"html.beforeGet\\\");var e,f=function(a){var b=/(#[^\\\\s\\\\+>~\\\\.\\\\[:]+)/g,c=/(\\\\[[^\\\\]]+\\\\])/g,d=/(\\\\.[^\\\\s\\\\+>~\\\\.\\\\[:]+)/g,e=/(::[^\\\\s\\\\+>~\\\\.\\\\[:]+|:first-line|:first-letter|:before|:after)/gi,f=/(:[\\\\w-]+\\\\([^\\\\)]*\\\\))/gi,g=/(:[^\\\\s\\\\+>~\\\\.\\\\[:]+)/g,h=/([^\\\\s\\\\+>~\\\\.\\\\[:]+)/g;!function(){var b=/:not\\\\(([^\\\\)]*)\\\\)/g;b.test(a)&&(a=a.replace(b,\\\"     $1 \\\"))}();var i=100*(a.match(b)||[]).length+10*(a.match(c)||[]).length+10*(a.match(d)||[]).length+10*(a.match(f)||[]).length+10*(a.match(g)||[]).length+(a.match(e)||[]).length;return a=a.replace(/[\\\\*\\\\s\\\\+>~]/g,\\\" \\\"),a=a.replace(/[#\\\\.]/g,\\\" \\\"),i+=(a.match(h)||[]).length},g=[],h={};if(!b.opts.useClasses&&!c){var i=new RegExp(\\\"^\\\"+b.opts.htmlIgnoreCSSProperties.join(\\\"$|^\\\")+\\\"$\\\",\\\"gi\\\");for(e=0;e<b.doc.styleSheets.length;e++){var j,k=0;try{j=b.doc.styleSheets[e].cssRules,b.doc.styleSheets[e].ownerNode&&\\\"STYLE\\\"==b.doc.styleSheets[e].ownerNode.nodeType&&(k=1)}catch(l){}if(j)for(var m=0,n=j.length;m<n;m++)if(j[m].selectorText&&j[m].style.cssText.length>0){var o,p=j[m].selectorText.replace(/body |\\\\.fr-view /g,\\\"\\\").replace(/::/g,\\\":\\\");try{o=b.el.querySelectorAll(p)}catch(l){o=[]}for(var r=0;r<o.length;r++){!o[r].getAttribute(\\\"fr-original-style\\\")&&o[r].getAttribute(\\\"style\\\")?(o[r].setAttribute(\\\"fr-original-style\\\",o[r].getAttribute(\\\"style\\\")),g.push(o[r])):o[r].getAttribute(\\\"fr-original-style\\\")||g.push(o[r]),h[o[r]]||(h[o[r]]={});for(var s=1e3*k+f(j[m].selectorText),t=j[m].style.cssText.split(\\\";\\\"),u=0;u<t.length;u++){var v=t[u].trim().split(\\\":\\\")[0];v.match(i)||(h[o[r]][v]||(h[o[r]][v]=0,(o[r].getAttribute(\\\"fr-original-style\\\")||\\\"\\\").indexOf(v+\\\":\\\")>=0&&(h[o[r]][v]=1e4)),s>=h[o[r]][v]&&(h[o[r]][v]=s,t[u].trim().length&&(o[r].style[v.trim()]=t[u].trim().split(\\\":\\\")[1].trim())))}}}}for(e=0;e<g.length;e++)if(g[e].getAttribute(\\\"class\\\")&&(g[e].setAttribute(\\\"fr-original-class\\\",g[e].getAttribute(\\\"class\\\")),g[e].removeAttribute(\\\"class\\\")),(g[e].getAttribute(\\\"fr-original-style\\\")||\\\"\\\").trim().length>0)for(var w=g[e].getAttribute(\\\"fr-original-style\\\").split(\\\";\\\"),r=0;r<w.length;r++)w[r].indexOf(\\\":\\\")>0&&(g[e].style[w[r].split(\\\":\\\")[0].trim()]=w[r].split(\\\":\\\")[1].trim())}if(b.core.isEmpty()?b.opts.fullPage&&(d=q(b.iframe_document),d+=\\\"<html\\\"+b.node.attributes(b.$html.get(0))+\\\">\\\"+b.$html.find(\\\"head\\\").get(0).outerHTML+\\\"<body></body></html>\\\"):(\\\"undefined\\\"==typeof a&&(a=!1),b.opts.fullPage?(d=q(b.iframe_document),b.$el.removeClass(\\\"fr-view\\\"),d+=\\\"<html\\\"+b.node.attributes(b.$html.get(0))+\\\">\\\"+b.$html.html()+\\\"</html>\\\",b.$el.addClass(\\\"fr-view\\\")):d=b.$el.html()),!b.opts.useClasses&&!c)for(e=0;e<g.length;e++)g[e].getAttribute(\\\"fr-original-class\\\")&&(g[e].setAttribute(\\\"class\\\",g[e].getAttribute(\\\"fr-original-class\\\")),g[e].removeAttribute(\\\"fr-original-class\\\")),g[e].getAttribute(\\\"fr-original-style\\\")?(g[e].setAttribute(\\\"style\\\",g[e].getAttribute(\\\"fr-original-style\\\")),g[e].removeAttribute(\\\"fr-original-style\\\")):g[e].removeAttribute(\\\"style\\\");b.opts.fullPage&&(d=d.replace(/<style data-fr-style=\\\"true\\\">(?:[\\\\w\\\\W]*?)<\\\\/style>/g,\\\"\\\"),d=d.replace(/<link([^>]*)data-fr-style=\\\"true\\\"([^>]*)>/g,\\\"\\\"),d=d.replace(/<style(?:[\\\\w\\\\W]*?)class=\\\"firebugResetStyles\\\"(?:[\\\\w\\\\W]*?)>(?:[\\\\w\\\\W]*?)<\\\\/style>/g,\\\"\\\"),d=d.replace(/<body((?:[\\\\w\\\\W]*?)) spellcheck=\\\"true\\\"((?:[\\\\w\\\\W]*?))>((?:[\\\\w\\\\W]*?))<\\\\/body>/g,\\\"<body$1$2>$3</body>\\\"),d=d.replace(/<body((?:[\\\\w\\\\W]*?)) contenteditable=\\\"(true|false)\\\"((?:[\\\\w\\\\W]*?))>((?:[\\\\w\\\\W]*?))<\\\\/body>/g,\\\"<body$1$3>$4</body>\\\"),d=d.replace(/<body((?:[\\\\w\\\\W]*?)) dir=\\\"([\\\\w]*)\\\"((?:[\\\\w\\\\W]*?))>((?:[\\\\w\\\\W]*?))<\\\\/body>/g,\\\"<body$1$3>$4</body>\\\"),d=d.replace(/<body((?:[\\\\w\\\\W]*?))class=\\\"([\\\\w\\\\W]*?)(fr-rtl|fr-ltr)([\\\\w\\\\W]*?)\\\"((?:[\\\\w\\\\W]*?))>((?:[\\\\w\\\\W]*?))<\\\\/body>/g,'<body$1class=\\\"$2$4\\\"$5>$6</body>'),d=d.replace(/<body((?:[\\\\w\\\\W]*?)) class=\\\"\\\"((?:[\\\\w\\\\W]*?))>((?:[\\\\w\\\\W]*?))<\\\\/body>/g,\\\"<body$1$2>$3</body>\\\")),b.opts.htmlSimpleAmpersand&&(d=d.replace(/\\\\&amp;/gi,\\\"&\\\")),b.events.trigger(\\\"html.afterGet\\\"),a||(d=d.replace(/<span[^>]*? class\\\\s*=\\\\s*[\\\"']?fr-marker[\\\"']?[^>]+>\\\\u200b<\\\\/span>/gi,\\\"\\\")),d=b.clean.invisibleSpaces(d);var x=b.events.chainTrigger(\\\"html.get\\\",d);return\\\"string\\\"==typeof x&&(d=x),d=d.replace(/<pre(?:[\\\\w\\\\W]*?)>(?:[\\\\w\\\\W]*?)<\\\\/pre>/g,function(a){return a.replace(/<br>/g,\\\"\\\\n\\\")})}function B(){var c=function(c,d){for(;d&&(d.nodeType==Node.TEXT_NODE||!b.node.isBlock(d))&&!b.node.isElement(d);)d&&d.nodeType!=Node.TEXT_NODE&&a(c).wrapInner(b.node.openTagString(d)+b.node.closeTagString(d)),d=d.parentNode;d&&c.innerHTML==d.innerHTML&&(c.innerHTML=d.outerHTML)},d=function(){var c,d=null;return b.win.getSelection?(c=b.win.getSelection(),c&&c.rangeCount&&(d=c.getRangeAt(0).commonAncestorContainer,d.nodeType!=Node.ELEMENT_NODE&&(d=d.parentNode))):(c=b.doc.selection)&&\\\"Control\\\"!=c.type&&(d=c.createRange().parentElement()),null!=d&&(a.inArray(b.el,a(d).parents())>=0||d==b.el)?d:null},e=\\\"\\\";if(\\\"undefined\\\"!=typeof b.win.getSelection){\\nb.browser.mozilla&&(b.selection.save(),b.$el.find('.fr-marker[data-type=\\\"false\\\"]').length>1&&(b.$el.find('.fr-marker[data-type=\\\"false\\\"][data-id=\\\"0\\\"]').remove(),b.$el.find('.fr-marker[data-type=\\\"false\\\"]:last').attr(\\\"data-id\\\",\\\"0\\\"),b.$el.find(\\\".fr-marker\\\").not('[data-id=\\\"0\\\"]').remove()),b.selection.restore());for(var f=b.selection.ranges(),g=0;g<f.length;g++){var h=document.createElement(\\\"div\\\");h.appendChild(f[g].cloneContents()),c(h,d()),a(h).find(\\\".fr-element\\\").length>0&&(h=b.el),e+=h.innerHTML}}else\\\"undefined\\\"!=typeof b.doc.selection&&\\\"Text\\\"==b.doc.selection.type&&(e=b.doc.selection.createRange().htmlText);return e}function C(a){var c=b.doc.createElement(\\\"div\\\");return c.innerHTML=a,null!==c.querySelector(f())}function D(a){var c=b.doc.createElement(\\\"div\\\");return c.innerHTML=a,b.selection.setAtEnd(c),c.innerHTML}function E(a){return a.replace(/</gi,\\\"&lt;\\\").replace(/>/gi,\\\"&gt;\\\").replace(/\\\"/gi,\\\"&quot;\\\").replace(/'/gi,\\\"&#39;\\\")}function F(a,c,d){b.selection.isCollapsed()||b.selection.remove();var e;if(e=c?a:b.clean.html(a),e=e.replace(/\\\\r|\\\\n/g,\\\" \\\"),a.indexOf('class=\\\"fr-marker\\\"')<0&&(e=D(e)),b.core.isEmpty()&&!b.opts.keepFormatOnDelete)b.el.innerHTML=e;else{var f=b.markers.insert();if(f){var g,h=b.node.blockParent(f);if((C(e)||d)&&(g=b.node.deepestParent(f)||h&&\\\"LI\\\"==h.tagName)){var f=b.markers.split();if(!f)return!1;f.outerHTML=e}else f.outerHTML=e}else b.el.innerHTML=b.el.innerHTML+e}u(),b.events.trigger(\\\"html.inserted\\\")}function G(c){var d=null;if(\\\"undefined\\\"==typeof c&&(d=b.selection.element()),b.opts.keepFormatOnDelete)return!1;var e=d?(d.textContent.match(/\\\\u200B/g)||[]).length-d.querySelectorAll(\\\".fr-marker\\\").length:0,f=(b.el.textContent.match(/\\\\u200B/g)||[]).length-b.el.querySelectorAll(\\\".fr-marker\\\").length;if(f==e)return!1;var g,h;do{h=!1,g=b.el.querySelectorAll(\\\"*:not(.fr-marker)\\\");for(var i=0;i<g.length;i++){var j=g[i];if(d!=j){var k=j.textContent;0===j.children.length&&1===k.length&&8203==k.charCodeAt(0)&&(a(j).remove(),h=!0)}}}while(h)}function H(){var a=function(){G(),b.placeholder&&b.placeholder.refresh()};b.events.on(\\\"mouseup\\\",a),b.events.on(\\\"keydown\\\",a),b.events.on(\\\"contentChanged\\\",v)}return{defaultTag:c,emptyBlocks:d,emptyBlockTagsQuery:e,blockTagsQuery:f,fillEmptyBlocks:l,cleanEmptyTags:g,cleanWhiteTags:G,cleanBlankSpaces:n,blocks:m,getDoctype:q,set:z,get:A,getSelected:B,insert:F,wrap:j,unwrap:k,escapeEntities:E,checkIfEmpty:v,extractNode:w,extractNodeAttrs:x,extractDoctype:y,cleanBRs:t,_init:H}},a.extend(a.FE.DEFAULTS,{height:null,heightMax:null,heightMin:null,width:null}),a.FE.MODULES.size=function(a){function b(){c(),a.opts.height&&a.$el.css(\\\"minHeight\\\",a.opts.height-a.helpers.getPX(a.$el.css(\\\"padding-top\\\"))-a.helpers.getPX(a.$el.css(\\\"padding-bottom\\\"))),a.$iframe.height(a.$el.outerHeight(!0))}function c(){a.opts.heightMin?a.$el.css(\\\"minHeight\\\",a.opts.heightMin):a.$el.css(\\\"minHeight\\\",\\\"\\\"),a.opts.heightMax?(a.$wp.css(\\\"maxHeight\\\",a.opts.heightMax),a.$wp.css(\\\"overflow\\\",\\\"auto\\\")):(a.$wp.css(\\\"maxHeight\\\",\\\"\\\"),a.$wp.css(\\\"overflow\\\",\\\"\\\")),a.opts.height?(a.$wp.height(a.opts.height),a.$el.css(\\\"minHeight\\\",a.opts.height-a.helpers.getPX(a.$el.css(\\\"padding-top\\\"))-a.helpers.getPX(a.$el.css(\\\"padding-bottom\\\"))),a.$wp.css(\\\"overflow\\\",\\\"auto\\\")):(a.$wp.css(\\\"height\\\",\\\"\\\"),a.opts.heightMin||a.$el.css(\\\"minHeight\\\",\\\"\\\"),a.opts.heightMax||a.$wp.css(\\\"overflow\\\",\\\"\\\")),a.opts.width&&a.$box.width(a.opts.width)}function d(){return!!a.$wp&&(c(),void(a.$iframe&&(a.events.on(\\\"keyup\\\",b),a.events.on(\\\"commands.after\\\",b),a.events.on(\\\"html.set\\\",b),a.events.on(\\\"init\\\",b),a.events.on(\\\"initialized\\\",b))))}return{_init:d,syncIframe:b,refresh:c}},a.extend(a.FE.DEFAULTS,{language:null}),a.FE.LANGUAGE={},a.FE.MODULES.language=function(b){function c(a){return e&&e.translation[a]?e.translation[a]:a}function d(){a.FE.LANGUAGE&&(e=a.FE.LANGUAGE[b.opts.language]),e&&e.direction&&(b.opts.direction=e.direction)}var e;return{_init:d,translate:c}},a.extend(a.FE.DEFAULTS,{placeholderText:\\\"Type something\\\"}),a.FE.MODULES.placeholder=function(b){function c(){b.$placeholder||g();var c=0,d=0,e=0,f=0,h=0,i=0,j=b.node.contents(b.el),k=a(b.selection.element()).css(\\\"text-align\\\");if(j.length&&j[0].nodeType==Node.ELEMENT_NODE){var l=a(j[0]);!b.opts.toolbarInline&&b.ready&&(c=b.helpers.getPX(l.css(\\\"margin-top\\\")),f=b.helpers.getPX(l.css(\\\"padding-top\\\")),d=b.helpers.getPX(l.css(\\\"margin-left\\\")),e=b.helpers.getPX(l.css(\\\"margin-right\\\")),h=b.helpers.getPX(l.css(\\\"padding-left\\\")),i=b.helpers.getPX(l.css(\\\"padding-right\\\"))),b.$placeholder.css(\\\"font-size\\\",l.css(\\\"font-size\\\")),b.$placeholder.css(\\\"line-height\\\",l.css(\\\"line-height\\\"))}else b.$placeholder.css(\\\"font-size\\\",b.$el.css(\\\"font-size\\\")),b.$placeholder.css(\\\"line-height\\\",b.$el.css(\\\"line-height\\\"));b.$wp.addClass(\\\"show-placeholder\\\"),b.$placeholder.css({marginTop:Math.max(b.helpers.getPX(b.$el.css(\\\"margin-top\\\")),c),paddingTop:Math.max(b.helpers.getPX(b.$el.css(\\\"padding-top\\\")),f),paddingLeft:Math.max(b.helpers.getPX(b.$el.css(\\\"padding-left\\\")),h),marginLeft:Math.max(b.helpers.getPX(b.$el.css(\\\"margin-left\\\")),d),paddingRight:Math.max(b.helpers.getPX(b.$el.css(\\\"padding-right\\\")),i),marginRight:Math.max(b.helpers.getPX(b.$el.css(\\\"margin-right\\\")),e),textAlign:k}).text(b.language.translate(b.opts.placeholderText||b.$oel.attr(\\\"placeholder\\\")||\\\"\\\")),b.$placeholder.html(b.$placeholder.text().replace(/\\\\n/g,\\\"<br>\\\"))}function d(){b.$wp.removeClass(\\\"show-placeholder\\\")}function e(){return!b.$wp||b.node.hasClass(b.$wp.get(0),\\\"show-placeholder\\\")}function f(){return!!b.$wp&&void(b.core.isEmpty()?c():d())}function g(){b.$placeholder=a('<span class=\\\"fr-placeholder\\\"></span>'),b.$wp.append(b.$placeholder)}function h(){return!!b.$wp&&void b.events.on(\\\"init input keydown keyup contentChanged initialized\\\",f)}return{_init:h,show:c,hide:d,refresh:f,isVisible:e}},a.FE.MODULES.edit=function(a){function b(){if(a.browser.mozilla)try{a.doc.execCommand(\\\"enableObjectResizing\\\",!1,\\\"false\\\"),a.doc.execCommand(\\\"enableInlineTableEditing\\\",!1,\\\"false\\\")}catch(b){}if(a.browser.msie)try{a.doc.body.addEventListener(\\\"mscontrolselect\\\",function(a){return a.preventDefault(),!1})}catch(b){}}function c(){a.$wp?(a.$el.attr(\\\"contenteditable\\\",!0),a.$el.removeClass(\\\"fr-disabled\\\").attr(\\\"aria-disabled\\\",!1),a.$tb&&a.$tb.removeClass(\\\"fr-disabled\\\").attr(\\\"aria-disabled\\\",!1),b()):a.$el.is(\\\"a\\\")&&a.$el.attr(\\\"contenteditable\\\",!0),f=!1}function d(){a.$wp?(a.$el.attr(\\\"contenteditable\\\",!1),a.$el.addClass(\\\"fr-disabled\\\").attr(\\\"aria-disabled\\\",!0),a.$tb&&a.$tb.addClass(\\\"fr-disabled\\\").attr(\\\"aria-disabled\\\",!0)):a.$el.is(\\\"a\\\")&&a.$el.attr(\\\"contenteditable\\\",!1),f=!0}function e(){return f}var f=!1;return{on:c,off:d,disableDesign:b,isDisabled:e}},a.extend(a.FE.DEFAULTS,{editorClass:null,typingTimer:500,iframe:!1,requestWithCORS:!0,requestWithCredentials:!1,requestHeaders:{},useClasses:!0,spellcheck:!0,iframeStyle:'html{margin:0px;height:auto;}body{height:auto;padding:10px;background:transparent;color:#000000;position:relative;z-index: 2;-webkit-user-select:auto;margin:0px;overflow:hidden;min-height:20px;}body:after{content:\\\"\\\";display:block;clear:both;}',iframeStyleFiles:[],direction:\\\"auto\\\",zIndex:1,disableRightClick:!1,scrollableContainer:\\\"body\\\",keepFormatOnDelete:!1,theme:null}),a.FE.MODULES.core=function(b){function c(c){if(b.opts.iframe){b.$head.find(\\\"style[data-fr-style], link[data-fr-style]\\\").remove(),b.$head.append('<style data-fr-style=\\\"true\\\">'+c+\\\"</style>\\\");for(var d=0;d<b.opts.iframeStyleFiles.length;d++){var e=a('<link data-fr-style=\\\"true\\\" rel=\\\"stylesheet\\\" href=\\\"'+b.opts.iframeStyleFiles[d]+'\\\">');e.get(0).addEventListener(\\\"load\\\",b.size.syncIframe),b.$head.append(e)}}}function d(){b.opts.iframe||b.$el.addClass(\\\"fr-element fr-view\\\")}function e(){if(b.$box.addClass(\\\"fr-box\\\"+(b.opts.editorClass?\\\" \\\"+b.opts.editorClass:\\\"\\\")),b.$wp.addClass(\\\"fr-wrapper\\\"),d(),b.opts.iframe){b.$iframe.addClass(\\\"fr-iframe\\\"),b.$el.addClass(\\\"fr-view\\\");for(var a=0;a<b.o_doc.styleSheets.length;a++){var c;try{c=b.o_doc.styleSheets[a].cssRules}catch(e){}if(c)for(var f=0,g=c.length;f<g;f++)!c[f].selectorText||0!==c[f].selectorText.indexOf(\\\".fr-view\\\")&&0!==c[f].selectorText.indexOf(\\\".fr-element\\\")||c[f].style.cssText.length>0&&(0===c[f].selectorText.indexOf(\\\".fr-view\\\")?b.opts.iframeStyle+=c[f].selectorText.replace(/\\\\.fr-view/g,\\\"body\\\")+\\\"{\\\"+c[f].style.cssText+\\\"}\\\":b.opts.iframeStyle+=c[f].selectorText.replace(/\\\\.fr-element/g,\\\"body\\\")+\\\"{\\\"+c[f].style.cssText+\\\"}\\\")}}\\\"auto\\\"!=b.opts.direction&&b.$box.removeClass(\\\"fr-ltr fr-rtl\\\").addClass(\\\"fr-\\\"+b.opts.direction),b.$el.attr(\\\"dir\\\",b.opts.direction),b.$wp.attr(\\\"dir\\\",b.opts.direction),b.opts.zIndex>1&&b.$box.css(\\\"z-index\\\",b.opts.zIndex),b.opts.theme&&b.$box.addClass(b.opts.theme+\\\"-theme\\\")}function f(){return b.node.isEmpty(b.el)}function g(){b.drag_support={filereader:\\\"undefined\\\"!=typeof FileReader,formdata:!!b.win.FormData,progress:\\\"upload\\\"in new XMLHttpRequest}}function h(a,c){var d=new XMLHttpRequest;d.open(c,a,!0),b.opts.requestWithCredentials&&(d.withCredentials=!0);for(var e in b.opts.requestHeaders)b.opts.requestHeaders.hasOwnProperty(e)&&d.setRequestHeader(e,b.opts.requestHeaders[e]);return d}function i(a){\\\"TEXTAREA\\\"==b.$oel.get(0).tagName&&b.$oel.val(a),b.$wp&&(\\\"TEXTAREA\\\"==b.$oel.get(0).tagName?(b.$el.html(\\\"\\\"),b.$wp.html(\\\"\\\"),b.$box.replaceWith(b.$oel),b.$oel.show()):(b.$wp.replaceWith(a),b.$el.html(\\\"\\\"),b.$box.removeClass(\\\"fr-view fr-ltr fr-box \\\"+(b.opts.editorClass||\\\"\\\")),b.opts.theme&&b.$box.addClass(b.opts.theme+\\\"-theme\\\"))),this.$wp=null,this.$el=null,this.el=null,this.$box=null}function j(){return b.browser.mozilla&&b.helpers.isMobile()?b.selection.inEditor():b.node.hasFocus(b.el)||b.$el.find(\\\"*:focus\\\").length>0}function k(a){if(!a)return!1;var c=a.data(\\\"instance\\\");return!!c&&c.id==b.id}function l(){if(a.FE.INSTANCES.push(b),g(),b.$wp){e(),b.html.set(b._original_html),b.$el.attr(\\\"spellcheck\\\",b.opts.spellcheck),b.helpers.isMobile()&&(b.$el.attr(\\\"autocomplete\\\",b.opts.spellcheck?\\\"on\\\":\\\"off\\\"),b.$el.attr(\\\"autocorrect\\\",b.opts.spellcheck?\\\"on\\\":\\\"off\\\"),b.$el.attr(\\\"autocapitalize\\\",b.opts.spellcheck?\\\"on\\\":\\\"off\\\")),b.opts.disableRightClick&&b.events.$on(b.$el,\\\"contextmenu\\\",function(a){if(2==a.button)return!1});try{b.doc.execCommand(\\\"styleWithCSS\\\",!1,!1)}catch(c){}}b.events.on(\\\"drop\\\",function(a){a.preventDefault(),a.stopPropagation()}),\\\"TEXTAREA\\\"==b.$oel.get(0).tagName&&(b.events.on(\\\"contentChanged\\\",function(){b.$oel.val(b.html.get())}),b.events.on(\\\"form.submit\\\",function(){b.$oel.val(b.html.get())}),b.events.on(\\\"form.reset\\\",function(){b.html.set(b._original_html)}),b.$oel.val(b.html.get())),b.helpers.isIOS()&&b.events.$on(b.$doc,\\\"selectionchange\\\",function(){b.$doc.get(0).hasFocus()||b.$win.get(0).focus()}),b.events.trigger(\\\"init\\\")}return{_init:l,destroy:i,isEmpty:f,getXHR:h,injectStyle:c,hasFocus:j,sameInstance:k}},a.FE.MODULES.cursorLists=function(b){function c(a){for(var b=a;\\\"LI\\\"!=b.tagName;)b=b.parentNode;return b}function d(a){for(var c=a;!b.node.isList(c);)c=c.parentNode;return c}function e(e){var f,g=c(e),h=g.nextSibling,i=g.previousSibling,j=b.html.defaultTag();if(b.node.isEmpty(g,!0)&&h){for(var k=\\\"\\\",l=\\\"\\\",m=e.parentNode;!b.node.isList(m)&&m.parentNode&&\\\"LI\\\"!==m.parentNode.tagName;)k=b.node.openTagString(m)+k,l+=b.node.closeTagString(m),m=m.parentNode;k=b.node.openTagString(m)+k,l+=b.node.closeTagString(m);var n=\\\"\\\";for(n=m.parentNode&&\\\"LI\\\"==m.parentNode.tagName?l+\\\"<li>\\\"+a.FE.MARKERS+\\\"<br>\\\"+k:j?l+\\\"<\\\"+j+\\\">\\\"+a.FE.MARKERS+\\\"<br></\\\"+j+\\\">\\\"+k:l+a.FE.MARKERS+\\\"<br>\\\"+k,a(g).html('<span id=\\\"fr-break\\\"></span>');[\\\"UL\\\",\\\"OL\\\"].indexOf(m.tagName)<0||m.parentNode&&\\\"LI\\\"===m.parentNode.tagName;)m=m.parentNode;var o=b.node.openTagString(m)+a(m).html()+b.node.closeTagString(m);o=o.replace(/<span id=\\\"fr-break\\\"><\\\\/span>/g,n),a(m).replaceWith(o),b.$el.find(\\\"li:empty\\\").remove()}else i&&h||!b.node.isEmpty(g,!0)?(a(g).before(\\\"<li><br></li>\\\"),a(e).remove()):i?(f=d(g),f.parentNode&&\\\"LI\\\"==f.parentNode.tagName?a(f.parentNode).after(\\\"<li>\\\"+a.FE.MARKERS+\\\"<br></li>\\\"):j?a(f).after(\\\"<\\\"+j+\\\">\\\"+a.FE.MARKERS+\\\"<br></\\\"+j+\\\">\\\"):a(f).after(a.FE.MARKERS+\\\"<br>\\\"),a(g).remove()):(f=d(g),f.parentNode&&\\\"LI\\\"==f.parentNode.tagName?h?a(f.parentNode).before(\\\"<li>\\\"+a.FE.MARKERS+\\\"<br></li>\\\"):a(f.parentNode).after(\\\"<li>\\\"+a.FE.MARKERS+\\\"<br></li>\\\"):j?a(f).before(\\\"<\\\"+j+\\\">\\\"+a.FE.MARKERS+\\\"<br></\\\"+j+\\\">\\\"):a(f).before(a.FE.MARKERS+\\\"<br>\\\"),a(g).remove())}function f(d){for(var e=c(d),f=\\\"\\\",g=d,h=\\\"\\\",i=\\\"\\\";g!=e;){g=g.parentNode;var j=\\\"A\\\"==g.tagName&&b.cursor.isAtEnd(d,g)?\\\"fr-to-remove\\\":\\\"\\\";h=b.node.openTagString(a(g).clone().addClass(j).get(0))+h,i=b.node.closeTagString(g)+i}f=i+f+h+a.FE.MARKERS,a(d).replaceWith('<span id=\\\"fr-break\\\"></span>');var k=b.node.openTagString(e)+a(e).html()+b.node.closeTagString(e);k=k.replace(/<span id=\\\"fr-break\\\"><\\\\/span>/g,f),a(e).replaceWith(k)}function g(d){for(var e=c(d),f=a.FE.MARKERS,g=\\\"\\\",h=d,i=!1;h!=e;){h=h.parentNode;var j=\\\"A\\\"==h.tagName&&b.cursor.isAtEnd(d,h)?\\\"fr-to-remove\\\":\\\"\\\";i||h==e||b.node.isBlock(h)||(i=!0,g+=a.FE.INVISIBLE_SPACE),g=b.node.openTagString(a(h).clone().addClass(j).get(0))+g,f+=b.node.closeTagString(h)}var k=g+f;a(d).remove(),a(e).after(k)}function h(e){var f=c(e),g=f.previousSibling;if(g){g=a(g).find(b.html.blockTagsQuery()).get(-1)||g,a(e).replaceWith(a.FE.MARKERS);var h=b.node.contents(g);h.length&&\\\"BR\\\"==h[h.length-1].tagName&&a(h[h.length-1]).remove(),a(f).find(b.html.blockTagsQuery()).not(\\\"ol, ul, table\\\").each(function(){this.parentNode==f&&a(this).replaceWith(a(this).html()+(b.node.isEmpty(this)?\\\"\\\":\\\"<br>\\\"))});for(var i,j=b.node.contents(f)[0];j&&!b.node.isList(j);)i=j.nextSibling,a(g).append(j),j=i;for(g=f.previousSibling;j;)i=j.nextSibling,a(g).append(j),j=i;a(f).remove()}else{var k=d(f);if(a(e).replaceWith(a.FE.MARKERS),k.parentNode&&\\\"LI\\\"==k.parentNode.tagName){var l=k.previousSibling;b.node.isBlock(l)?(a(f).find(b.html.blockTagsQuery()).not(\\\"ol, ul, table\\\").each(function(){this.parentNode==f&&a(this).replaceWith(a(this).html()+(b.node.isEmpty(this)?\\\"\\\":\\\"<br>\\\"))}),a(l).append(a(f).html())):a(k).before(a(f).html())}else{var m=b.html.defaultTag();m&&0===a(f).find(b.html.blockTagsQuery()).length?a(k).before(\\\"<\\\"+m+\\\">\\\"+a(f).html()+\\\"</\\\"+m+\\\">\\\"):a(k).before(a(f).html())}a(f).remove(),0===a(k).find(\\\"li\\\").length&&a(k).remove()}}function i(d){var e,f=c(d),g=f.nextSibling;if(g){e=b.node.contents(g),e.length&&\\\"BR\\\"==e[0].tagName&&a(e[0]).remove(),a(g).find(b.html.blockTagsQuery()).not(\\\"ol, ul, table\\\").each(function(){this.parentNode==g&&a(this).replaceWith(a(this).html()+(b.node.isEmpty(this)?\\\"\\\":\\\"<br>\\\"))});for(var h,i=d,j=b.node.contents(g)[0];j&&!b.node.isList(j);)h=j.nextSibling,a(i).after(j),i=j,j=h;for(;j;)h=j.nextSibling,a(f).append(j),j=h;a(d).replaceWith(a.FE.MARKERS),a(g).remove()}else{for(var k=f;!k.nextSibling&&k!=b.el;)k=k.parentNode;if(k==b.el)return!1;if(k=k.nextSibling,b.node.isBlock(k))a.FE.NO_DELETE_TAGS.indexOf(k.tagName)<0&&(a(d).replaceWith(a.FE.MARKERS),e=b.node.contents(f),e.length&&\\\"BR\\\"==e[e.length-1].tagName&&a(e[e.length-1]).remove(),a(f).append(a(k).html()),a(k).remove());else for(e=b.node.contents(f),e.length&&\\\"BR\\\"==e[e.length-1].tagName&&a(e[e.length-1]).remove(),a(d).replaceWith(a.FE.MARKERS);k&&!b.node.isBlock(k)&&\\\"BR\\\"!=k.tagName;)a(f).append(a(k)),k=k.nextSibling}}return{_startEnter:e,_middleEnter:f,_endEnter:g,_backspace:h,_del:i}},a.FE.NO_DELETE_TAGS=[\\\"TH\\\",\\\"TD\\\",\\\"TR\\\",\\\"TABLE\\\",\\\"FORM\\\"],a.FE.SIMPLE_ENTER_TAGS=[\\\"TH\\\",\\\"TD\\\",\\\"LI\\\",\\\"DL\\\",\\\"DT\\\",\\\"FORM\\\"],a.FE.MODULES.cursor=function(b){function c(a){return!!a&&(!!b.node.isBlock(a)||(a.nextSibling&&a.nextSibling.nodeType==Node.TEXT_NODE&&0==a.nextSibling.textContent.replace(/\\\\u200b/g,\\\"\\\").length?c(a.nextSibling):!a.nextSibling&&c(a.parentNode)))}function d(a){return!!a&&(!!b.node.isBlock(a)||(a.previousSibling&&a.previousSibling.nodeType==Node.TEXT_NODE&&0==a.previousSibling.textContent.replace(/\\\\u200b/g,\\\"\\\").length?d(a.previousSibling):!a.previousSibling&&d(a.parentNode)))}function e(a,c){return!!a&&(a!=b.$wp.get(0)&&(a.previousSibling&&a.previousSibling.nodeType==Node.TEXT_NODE&&0==a.previousSibling.textContent.replace(/\\\\u200b/g,\\\"\\\").length?e(a.previousSibling,c):!a.previousSibling&&(a.parentNode==c||e(a.parentNode,c))))}function f(a,c){return!!a&&(a!=b.$wp.get(0)&&(a.nextSibling&&a.nextSibling.nodeType==Node.TEXT_NODE&&0==a.nextSibling.textContent.replace(/\\\\u200b/g,\\\"\\\").length?f(a.nextSibling,c):!a.nextSibling&&(a.parentNode==c||f(a.parentNode,c))))}function g(c){return a(c).parentsUntil(b.$el,\\\"LI\\\").length>0&&0===a(c).parentsUntil(\\\"LI\\\",\\\"TABLE\\\").length}function h(c){var d=a(c).parentsUntil(b.$el,\\\"BLOCKQUOTE\\\").length>0,e=b.node.deepestParent(c,[],!d);if(e&&\\\"BLOCKQUOTE\\\"==e.tagName){var f=b.node.deepestParent(c,[a(c).parentsUntil(b.$el,\\\"BLOCKQUOTE\\\").get(0)]);f&&f.previousSibling&&(e=f)}if(null!==e){var g,h=e.previousSibling;if(b.node.isBlock(e)&&b.node.isEditable(e)&&h&&a.FE.NO_DELETE_TAGS.indexOf(h.tagName)<0)if(b.node.isDeletable(h))a(h).remove(),a(c).replaceWith(a.FE.MARKERS);else if(b.node.isEditable(h))if(b.node.isBlock(h))if(b.node.isEmpty(h)&&!b.node.isList(h))a(h).remove();else{if(b.node.isList(h)&&(h=a(h).find(\\\"li:last\\\").get(0)),g=b.node.contents(h),g.length&&\\\"BR\\\"==g[g.length-1].tagName&&a(g[g.length-1]).remove(),\\\"BLOCKQUOTE\\\"==h.tagName&&\\\"BLOCKQUOTE\\\"!=e.tagName)for(g=b.node.contents(h);g.length&&b.node.isBlock(g[g.length-1]);)h=g[g.length-1],g=b.node.contents(h);else if(\\\"BLOCKQUOTE\\\"!=h.tagName&&\\\"BLOCKQUOTE\\\"==e.tagName)for(g=b.node.contents(e);g.length&&b.node.isBlock(g[0]);)e=g[0],g=b.node.contents(e);a(c).replaceWith(a.FE.MARKERS),a(h).append(b.node.isEmpty(e)?a.FE.MARKERS:e.innerHTML),a(e).remove()}else a(c).replaceWith(a.FE.MARKERS),\\\"BLOCKQUOTE\\\"==e.tagName&&h.nodeType==Node.ELEMENT_NODE?a(h).remove():(a(h).after(b.node.isEmpty(e)?\\\"\\\":a(e).html()),a(e).remove(),\\\"BR\\\"==h.tagName&&a(h).remove())}}function i(c){for(var d=c;!d.previousSibling;)if(d=d.parentNode,b.node.isElement(d))return!1;d=d.previousSibling;var e;if(!b.node.isBlock(d)&&b.node.isEditable(d)){for(e=b.node.contents(d);d.nodeType!=Node.TEXT_NODE&&!b.node.isDeletable(d)&&e.length&&b.node.isEditable(d);)d=e[e.length-1],e=b.node.contents(d);if(d.nodeType==Node.TEXT_NODE){if(b.helpers.isIOS())return!0;var f=d.textContent,g=f.length-1;if(b.opts.tabSpaces&&f.length>=b.opts.tabSpaces){var h=f.substr(f.length-b.opts.tabSpaces,f.length-1);0==h.replace(/ /g,\\\"\\\").replace(new RegExp(a.FE.UNICODE_NBSP,\\\"g\\\"),\\\"\\\").length&&(g=f.length-b.opts.tabSpaces)}d.textContent=f.substring(0,g),d.textContent.length&&55357==d.textContent.charCodeAt(d.textContent.length-1)&&(d.textContent=d.textContent.substr(0,d.textContent.length-1));var i=f.length!=d.textContent.length;0==d.textContent.length?i&&b.opts.keepFormatOnDelete?a(d).after(a.FE.INVISIBLE_SPACE+a.FE.MARKERS):2!=d.parentNode.childNodes.length||d.parentNode!=c.parentNode||b.node.isBlock(d.parentNode)||b.node.isElement(d.parentNode)?(a(d).after(a.FE.MARKERS),b.node.isElement(d.parentNode)&&!c.nextSibling&&d.previousSibling&&\\\"BR\\\"==d.previousSibling.tagName&&a(c).after(\\\"<br>\\\"),d.parentNode.removeChild(d)):(a(d.parentNode).after(a.FE.MARKERS),a(d.parentNode).remove()):a(d).after(a.FE.MARKERS)}else b.node.isDeletable(d)?(a(d).after(a.FE.MARKERS),a(d).remove()):b.events.trigger(\\\"node.remove\\\",[a(d)])!==!1&&(a(d).after(a.FE.MARKERS),a(d).remove())}else if(a.FE.NO_DELETE_TAGS.indexOf(d.tagName)<0&&(b.node.isEditable(d)||b.node.isDeletable(d)))if(b.node.isDeletable(d))a(c).replaceWith(a.FE.MARKERS),a(d).remove();else if(b.node.isEmpty(d)&&!b.node.isList(d))a(d).remove(),a(c).replaceWith(a.FE.MARKERS);else{for(b.node.isList(d)&&(d=a(d).find(\\\"li:last\\\").get(0)),e=b.node.contents(d),e&&\\\"BR\\\"==e[e.length-1].tagName&&a(e[e.length-1]).remove(),e=b.node.contents(d);e&&b.node.isBlock(e[e.length-1]);)d=e[e.length-1],e=b.node.contents(d);a(d).append(a.FE.MARKERS);for(var j=c;!j.previousSibling;)j=j.parentNode;for(;j&&\\\"BR\\\"!==j.tagName&&!b.node.isBlock(j);){var k=j;j=j.nextSibling,a(d).append(k)}j&&\\\"BR\\\"==j.tagName&&a(j).remove(),a(c).remove()}else c.nextSibling&&\\\"BR\\\"==c.nextSibling.tagName&&a(c.nextSibling).remove()}function j(){var f=!1,j=b.markers.insert();if(!j)return!0;b.el.normalize();var k=j.previousSibling;if(k){var l=k.textContent;l&&l.length&&8203==l.charCodeAt(l.length-1)&&(1==l.length?a(k).remove():(k.textContent=k.textContent.substr(0,l.length-1),k.textContent.length&&55357==k.textContent.charCodeAt(k.textContent.length-1)&&(k.textContent=k.textContent.substr(0,k.textContent.length-1))))}return c(j)?f=i(j):d(j)?g(j)&&e(j,a(j).parents(\\\"li:first\\\").get(0))?b.cursorLists._backspace(j):h(j):f=i(j),a(j).remove(),n(),b.html.fillEmptyBlocks(!0),b.html.cleanEmptyTags(),b.clean.quotes(),b.clean.lists(),b.spaces.normalizeAroundCursor(),b.selection.restore(),f}function k(c){var d=a(c).parentsUntil(b.$el,\\\"BLOCKQUOTE\\\").length>0,e=b.node.deepestParent(c,[],!d);if(e&&\\\"BLOCKQUOTE\\\"==e.tagName){var f=b.node.deepestParent(c,[a(c).parentsUntil(b.$el,\\\"BLOCKQUOTE\\\").get(0)]);f&&f.nextSibling&&(e=f)}if(null!==e){var g,h=e.nextSibling;if(b.node.isBlock(e)&&(b.node.isEditable(e)||b.node.isDeletable(e))&&h&&a.FE.NO_DELETE_TAGS.indexOf(h.tagName)<0)if(b.node.isDeletable(h))a(h).remove(),a(c).replaceWith(a.FE.MARKERS);else if(b.node.isBlock(h)&&b.node.isEditable(h))if(b.node.isList(h))if(b.node.isEmpty(e,!0))a(e).remove(),a(h).find(\\\"li:first\\\").prepend(a.FE.MARKERS);else{var i=a(h).find(\\\"li:first\\\");\\\"BLOCKQUOTE\\\"==e.tagName&&(g=b.node.contents(e),g.length&&b.node.isBlock(g[g.length-1])&&(e=g[g.length-1])),0===i.find(\\\"ul, ol\\\").length&&(a(c).replaceWith(a.FE.MARKERS),i.find(b.html.blockTagsQuery()).not(\\\"ol, ul, table\\\").each(function(){this.parentNode==i.get(0)&&a(this).replaceWith(a(this).html()+(b.node.isEmpty(this)?\\\"\\\":\\\"<br>\\\"))}),a(e).append(b.node.contents(i.get(0))),i.remove(),0===a(h).find(\\\"li\\\").length&&a(h).remove())}else{if(g=b.node.contents(h),g.length&&\\\"BR\\\"==g[0].tagName&&a(g[0]).remove(),\\\"BLOCKQUOTE\\\"!=h.tagName&&\\\"BLOCKQUOTE\\\"==e.tagName)for(g=b.node.contents(e);g.length&&b.node.isBlock(g[g.length-1]);)e=g[g.length-1],g=b.node.contents(e);else if(\\\"BLOCKQUOTE\\\"==h.tagName&&\\\"BLOCKQUOTE\\\"!=e.tagName)for(g=b.node.contents(h);g.length&&b.node.isBlock(g[0]);)h=g[0],g=b.node.contents(h);a(c).replaceWith(a.FE.MARKERS),a(e).append(h.innerHTML),a(h).remove()}else{for(a(c).replaceWith(a.FE.MARKERS);h&&\\\"BR\\\"!==h.tagName&&!b.node.isBlock(h)&&b.node.isEditable(h);){var j=h;h=h.nextSibling,a(e).append(j)}h&&\\\"BR\\\"==h.tagName&&b.node.isEditable(h)&&a(h).remove()}}}function l(d){for(var e=d;!e.nextSibling;)if(e=e.parentNode,b.node.isElement(e))return!1;if(e=e.nextSibling,\\\"BR\\\"==e.tagName&&b.node.isEditable(e))if(e.nextSibling){if(b.node.isBlock(e.nextSibling)&&b.node.isEditable(e.nextSibling)){if(!(a.FE.NO_DELETE_TAGS.indexOf(e.nextSibling.tagName)<0))return void a(e).remove();e=e.nextSibling,a(e.previousSibling).remove()}}else if(c(e)){if(g(d))b.cursorLists._del(d);else{var f=b.node.deepestParent(e);f&&(a(e).remove(),k(d))}return}var h;if(!b.node.isBlock(e)&&b.node.isEditable(e)){for(h=b.node.contents(e);e.nodeType!=Node.TEXT_NODE&&h.length&&!b.node.isDeletable(e)&&b.node.isEditable(e);)e=h[0],h=b.node.contents(e);e.nodeType==Node.TEXT_NODE?(a(e).before(a.FE.MARKERS),e.textContent.length&&55357==e.textContent.charCodeAt(0)?e.textContent=e.textContent.substring(2,e.textContent.length):e.textContent=e.textContent.substring(1,e.textContent.length)):b.node.isDeletable(e)?(a(e).before(a.FE.MARKERS),a(e).remove()):b.events.trigger(\\\"node.remove\\\",[a(e)])!==!1&&(a(e).before(a.FE.MARKERS),a(e).remove()),a(d).remove()}else if(a.FE.NO_DELETE_TAGS.indexOf(e.tagName)<0&&(b.node.isEditable(e)||b.node.isDeletable(e)))if(b.node.isDeletable(e))a(d).replaceWith(a.FE.MARKERS),a(e).remove();else if(b.node.isList(e))d.previousSibling?(a(e).find(\\\"li:first\\\").prepend(d),b.cursorLists._backspace(d)):(a(e).find(\\\"li:first\\\").prepend(a.FE.MARKERS),a(d).remove());else if(h=b.node.contents(e),h&&\\\"BR\\\"==h[0].tagName&&a(h[0]).remove(),h&&\\\"BLOCKQUOTE\\\"==e.tagName){var i=h[0];for(a(d).before(a.FE.MARKERS);i&&\\\"BR\\\"!=i.tagName;){var j=i;i=i.nextSibling,a(d).before(j)}i&&\\\"BR\\\"==i.tagName&&a(i).remove()}else a(d).after(a(e).html()).after(a.FE.MARKERS),a(e).remove()}function m(){var e=b.markers.insert();if(!e)return!1;if(b.el.normalize(),c(e))if(g(e))if(0===a(e).parents(\\\"li:first\\\").find(\\\"ul, ol\\\").length)b.cursorLists._del(e);else{var f=a(e).parents(\\\"li:first\\\").find(\\\"ul:first, ol:first\\\").find(\\\"li:first\\\");f=f.find(b.html.blockTagsQuery()).get(-1)||f,f.prepend(e),b.cursorLists._backspace(e)}else k(e);else l(d(e)?e:e);a(e).remove(),n(),b.html.fillEmptyBlocks(!0),b.html.cleanEmptyTags(),b.clean.quotes(),b.clean.lists(),b.spaces.normalizeAroundCursor(),b.selection.restore()}function n(){for(var a=b.el.querySelectorAll(\\\"blockquote:empty\\\"),c=0;c<a.length;c++)a[c].parentNode.removeChild(a[c])}function o(){b.$el.find(\\\".fr-to-remove\\\").each(function(){for(var c=b.node.contents(this),d=0;d<c.length;d++)c[d].nodeType==Node.TEXT_NODE&&(c[d].textContent=c[d].textContent.replace(/\\\\u200B/g,\\\"\\\"));a(this).replaceWith(this.innerHTML)})}function p(c,d,e){var g,h=b.node.deepestParent(c,[],!e);if(h&&\\\"BLOCKQUOTE\\\"==h.tagName)return f(c,h)?(g=b.html.defaultTag(),g?a(h).after(\\\"<\\\"+g+\\\">\\\"+a.FE.MARKERS+\\\"<br></\\\"+g+\\\">\\\"):a(h).after(a.FE.MARKERS+\\\"<br>\\\"),a(c).remove(),!1):(r(c,d,e),!1);if(null==h)g=b.html.defaultTag(),g&&b.node.isElement(c.parentNode)?a(c).replaceWith(\\\"<\\\"+g+\\\">\\\"+a.FE.MARKERS+\\\"<br></\\\"+g+\\\">\\\"):a(c).replaceWith((b.node.isEmpty(c.parentNode,!0)?\\\"\\\":\\\"<br/>\\\")+a.FE.MARKERS+\\\"<br/>\\\");else{var i=c,j=\\\"\\\";b.node.isBlock(h)&&!d||(j=\\\"<br/>\\\");var k=\\\"\\\",l=\\\"\\\";g=b.html.defaultTag();var m=\\\"\\\",n=\\\"\\\";g&&b.node.isBlock(h)&&(m=\\\"<\\\"+g+\\\">\\\",n=\\\"</\\\"+g+\\\">\\\",h.tagName==g.toUpperCase()&&(m=b.node.openTagString(a(h).clone().removeAttr(\\\"id\\\").get(0))));do if(i=i.parentNode,!d||i!=h||d&&!b.node.isBlock(h))if(k+=b.node.closeTagString(i),i==h&&b.node.isBlock(h))l=m+l;else{var o=\\\"A\\\"==i.tagName&&f(c,i)?\\\"fr-to-remove\\\":\\\"\\\";l=b.node.openTagString(a(i).clone().addClass(o).get(0))+l}while(i!=h);j=k+j+l+(c.parentNode==h&&b.node.isBlock(h)?\\\"\\\":a.FE.INVISIBLE_SPACE)+a.FE.MARKERS,b.node.isBlock(h)&&!a(h).find(\\\"*:last\\\").is(\\\"br\\\")&&a(h).append(\\\"<br/>\\\"),a(c).after('<span id=\\\"fr-break\\\"></span>'),a(c).remove(),h.nextSibling&&!b.node.isBlock(h.nextSibling)||b.node.isBlock(h)||a(h).after(\\\"<br>\\\");var p;p=!d&&b.node.isBlock(h)?b.node.openTagString(h)+a(h).html()+n:b.node.openTagString(h)+a(h).html()+b.node.closeTagString(h),p=p.replace(/<span id=\\\"fr-break\\\"><\\\\/span>/g,j),a(h).replaceWith(p)}}function q(c,d,g){var h,i=b.node.deepestParent(c,[],!g);if(i&&\\\"TABLE\\\"==i.tagName)return a(i).find(\\\"td:first, th:first\\\").prepend(c),q(c,d,g);if(i&&\\\"BLOCKQUOTE\\\"==i.tagName){if(e(c,i))return h=b.html.defaultTag(),h?a(i).before(\\\"<\\\"+h+\\\">\\\"+a.FE.MARKERS+\\\"<br></\\\"+h+\\\">\\\"):a(i).before(a.FE.MARKERS+\\\"<br>\\\"),a(c).remove(),!1;f(c,i)?p(c,d,!0):r(c,d,!0)}if(null==i)h=b.html.defaultTag(),h&&b.node.isElement(c.parentNode)?a(c).replaceWith(\\\"<\\\"+h+\\\">\\\"+a.FE.MARKERS+\\\"<br></\\\"+h+\\\">\\\"):a(c).replaceWith(\\\"<br>\\\"+a.FE.MARKERS);else{if(b.node.isBlock(i))if(d)a(c).remove(),a(i).prepend(\\\"<br>\\\"+a.FE.MARKERS);else{if(b.node.isEmpty(i,!0))return p(c,d,g);a(i).before(b.node.openTagString(a(i).clone().removeAttr(\\\"id\\\").get(0))+\\\"<br>\\\"+b.node.closeTagString(i))}else a(i).before(\\\"<br>\\\");a(c).remove()}}function r(c,d,g){var h=b.node.deepestParent(c,[],!g);if(null==h)b.html.defaultTag()&&c.parentNode===b.el?a(c).replaceWith(\\\"<\\\"+b.html.defaultTag()+\\\">\\\"+a.FE.MARKERS+\\\"<br></\\\"+b.html.defaultTag()+\\\">\\\"):(c.nextSibling&&!b.node.isBlock(c.nextSibling)||a(c).after(\\\"<br>\\\"),a(c).replaceWith(\\\"<br>\\\"+a.FE.MARKERS));else{var i=c,j=\\\"\\\";\\\"PRE\\\"==h.tagName&&(d=!0),b.node.isBlock(h)&&!d||(j=\\\"<br>\\\");var k=\\\"\\\",l=\\\"\\\";do{var m=i;if(i=i.parentNode,\\\"BLOCKQUOTE\\\"==h.tagName&&b.node.isEmpty(m)&&!b.node.hasClass(m,\\\"fr-marker\\\")&&a(m).find(c).length>0&&a(m).after(c),(\\\"BLOCKQUOTE\\\"!=h.tagName||!f(c,i)&&!e(c,i))&&(!d||i!=h||d&&!b.node.isBlock(h))){k+=b.node.closeTagString(i);var n=\\\"A\\\"==i.tagName&&f(c,i)?\\\"fr-to-remove\\\":\\\"\\\";l=b.node.openTagString(a(i).clone().addClass(n).removeAttr(\\\"id\\\").get(0))+l}}while(i!=h);var o=h==c.parentNode&&b.node.isBlock(h)||c.nextSibling;if(\\\"BLOCKQUOTE\\\"==h.tagName){c.previousSibling&&b.node.isBlock(c.previousSibling)&&c.nextSibling&&\\\"BR\\\"==c.nextSibling.tagName&&(a(c.nextSibling).after(c),c.nextSibling&&\\\"BR\\\"==c.nextSibling.tagName&&a(c.nextSibling).remove());var p=b.html.defaultTag();j=k+j+(p?\\\"<\\\"+p+\\\">\\\":\\\"\\\")+a.FE.MARKERS+\\\"<br>\\\"+(p?\\\"</\\\"+p+\\\">\\\":\\\"\\\")+l}else j=k+j+l+(o?\\\"\\\":a.FE.INVISIBLE_SPACE)+a.FE.MARKERS;a(c).replaceWith('<span id=\\\"fr-break\\\"></span>');var q=b.node.openTagString(h)+a(h).html()+b.node.closeTagString(h);q=q.replace(/<span id=\\\"fr-break\\\"><\\\\/span>/g,j),a(h).replaceWith(q)}}function s(e){var f=b.markers.insert();if(!f)return!0;b.el.normalize();var h=!1;a(f).parentsUntil(b.$el,\\\"BLOCKQUOTE\\\").length>0&&(e=!1,h=!0),a(f).parentsUntil(b.$el,\\\"TD, TH\\\").length&&(h=!1),c(f)?!g(f)||e||h?p(f,e,h):b.cursorLists._endEnter(f):d(f)?!g(f)||e||h?q(f,e,h):b.cursorLists._startEnter(f):!g(f)||e||h?r(f,e,h):b.cursorLists._middleEnter(f),o(),b.html.fillEmptyBlocks(!0),b.html.cleanEmptyTags(),b.clean.lists(),b.spaces.normalizeAroundCursor(),b.selection.restore()}return{enter:s,backspace:j,del:m,isAtEnd:f,isAtStart:e}},a.FE.ENTER_P=0,a.FE.ENTER_DIV=1,a.FE.ENTER_BR=2,a.FE.KEYCODE={BACKSPACE:8,TAB:9,ENTER:13,SHIFT:16,CTRL:17,ALT:18,ESC:27,SPACE:32,ARROW_LEFT:37,ARROW_UP:38,ARROW_RIGHT:39,ARROW_DOWN:40,DELETE:46,ZERO:48,ONE:49,TWO:50,THREE:51,FOUR:52,FIVE:53,SIX:54,SEVEN:55,EIGHT:56,NINE:57,FF_SEMICOLON:59,FF_EQUALS:61,QUESTION_MARK:63,A:65,B:66,C:67,D:68,E:69,F:70,G:71,H:72,I:73,J:74,K:75,L:76,M:77,N:78,O:79,P:80,Q:81,R:82,S:83,T:84,U:85,V:86,W:87,X:88,Y:89,Z:90,META:91,NUM_ZERO:96,NUM_ONE:97,NUM_TWO:98,NUM_THREE:99,NUM_FOUR:100,NUM_FIVE:101,NUM_SIX:102,NUM_SEVEN:103,NUM_EIGHT:104,NUM_NINE:105,NUM_MULTIPLY:106,NUM_PLUS:107,NUM_MINUS:109,NUM_PERIOD:110,NUM_DIVISION:111,F1:112,F2:113,F3:114,F4:115,F5:116,F6:117,F7:118,F8:119,F9:120,F10:121,F11:122,F12:123,FF_HYPHEN:173,SEMICOLON:186,DASH:189,EQUALS:187,COMMA:188,HYPHEN:189,PERIOD:190,SLASH:191,APOSTROPHE:192,TILDE:192,SINGLE_QUOTE:222,OPEN_SQUARE_BRACKET:219,BACKSLASH:220,CLOSE_SQUARE_BRACKET:221},a.extend(a.FE.DEFAULTS,{enter:a.FE.ENTER_P,multiLine:!0,tabSpaces:0}),a.FE.MODULES.keys=function(b){function c(a){b.opts.multiLine?b.helpers.isIOS()||(a.preventDefault(),a.stopPropagation(),b.selection.isCollapsed()||b.selection.remove(),b.cursor.enter()):(a.preventDefault(),a.stopPropagation())}function d(a){a.preventDefault(),a.stopPropagation(),b.opts.multiLine&&(b.selection.isCollapsed()||b.selection.remove(),b.cursor.enter(!0))}function e(a){b.selection.isCollapsed()?b.cursor.backspace()||(a.preventDefault(),a.stopPropagation(),z=!1):(a.preventDefault(),a.stopPropagation(),b.selection.remove(),b.html.fillEmptyBlocks(),z=!1),b.placeholder.refresh()}function f(a){a.preventDefault(),a.stopPropagation(),\\\"\\\"===b.selection.text()?b.cursor.del():b.selection.remove(),b.placeholder.refresh()}function g(c){var d=b.selection.element();if(!b.helpers.isMobile()&&(b.browser.mozilla||d&&\\\"A\\\"==d.tagName)){c.preventDefault(),c.stopPropagation(),b.selection.isCollapsed()||b.selection.remove();var e=b.markers.insert();if(e){var f=e.previousSibling,g=e.nextSibling;!g&&e.parentNode&&\\\"A\\\"==e.parentNode.tagName?(e.parentNode.insertAdjacentHTML(\\\"afterend\\\",\\\"&nbsp;\\\"+a.FE.MARKERS),e.parentNode.removeChild(e)):(f&&f.nodeType==Node.TEXT_NODE&&1==f.textContent.length&&160==f.textContent.charCodeAt(0)?f.textContent=f.textContent+\\\" \\\":e.insertAdjacentHTML(\\\"beforebegin\\\",\\\"&nbsp;\\\"),e.outerHTML=a.FE.MARKERS),b.selection.restore()}}}function h(){if(b.browser.mozilla&&b.selection.isCollapsed()&&!C){var a=b.selection.ranges(0),c=a.startContainer,d=a.startOffset;c&&c.nodeType==Node.TEXT_NODE&&d<=c.textContent.length&&d>0&&32==c.textContent.charCodeAt(d-1)&&(b.selection.save(),b.spaces.normalize(),b.selection.restore())}}function i(){b.selection.isFull()&&setTimeout(function(){var c=b.html.defaultTag();c?b.$el.html(\\\"<\\\"+c+\\\">\\\"+a.FE.MARKERS+\\\"<br/></\\\"+c+\\\">\\\"):b.$el.html(a.FE.MARKERS+\\\"<br/>\\\"),b.selection.restore(),b.placeholder.refresh(),b.button.bulkRefresh(),b.undo.saveStep()},0)}function j(a){if(b.opts.tabSpaces>0)if(b.selection.isCollapsed()){b.undo.saveStep(),a.preventDefault(),a.stopPropagation();for(var c=\\\"\\\",d=0;d<b.opts.tabSpaces;d++)c+=\\\"&nbsp;\\\";b.html.insert(c),b.placeholder.refresh(),b.undo.saveStep()}else a.preventDefault(),a.stopPropagation(),a.shiftKey?b.commands.outdent():b.commands.indent()}function k(a){C=!1}function l(){return C}function m(h){\\nb.events.disableBlur(),z=!0;var i=h.which;if(16===i)return!0;if(229===i)return C=!0,!0;C=!1;var k=t(i)&&!r(h),l=i==a.FE.KEYCODE.BACKSPACE||i==a.FE.KEYCODE.DELETE;if((b.selection.isFull()&&!b.opts.keepFormatOnDelete&&!b.placeholder.isVisible()||l&&b.placeholder.isVisible()&&b.opts.keepFormatOnDelete)&&(k||l)){var m=b.html.defaultTag();if(m?b.$el.html(\\\"<\\\"+m+\\\">\\\"+a.FE.MARKERS+\\\"<br/></\\\"+m+\\\">\\\"):b.$el.html(a.FE.MARKERS+\\\"<br/>\\\"),b.selection.restore(),!t(i))return h.preventDefault(),!0}i==a.FE.KEYCODE.ENTER?h.shiftKey?d(h):c(h):i!=a.FE.KEYCODE.BACKSPACE||r(h)||h.altKey?i!=a.FE.KEYCODE.DELETE||r(h)||h.altKey?i==a.FE.KEYCODE.SPACE?g(h):i==a.FE.KEYCODE.TAB?j(h):r(h)||!t(h.which)||b.selection.isCollapsed()||h.ctrlKey||b.selection.remove():b.placeholder.isVisible()?(h.preventDefault(),h.stopPropagation()):f(h):b.placeholder.isVisible()?(h.preventDefault(),h.stopPropagation()):e(h),b.events.enableBlur()}function n(a){for(var c=b.doc.createTreeWalker(a,NodeFilter.SHOW_TEXT,b.node.filter(function(a){return/\\\\u200B/gi.test(a.textContent)}),!1);c.nextNode();){var d=c.currentNode;d.textContent=d.textContent.replace(/\\\\u200B/gi,\\\"\\\")}}function o(){if(!b.$wp)return!0;var c;b.opts.height||b.opts.heightMax?(c=b.position.getBoundingRect().top,b.helpers.isIOS()&&(c-=a(b.o_win).scrollTop()),b.opts.iframe&&(c+=b.$iframe.offset().top),c>b.$wp.offset().top-a(b.o_win).scrollTop()+b.$wp.height()-20&&b.$wp.scrollTop(c+b.$wp.scrollTop()-(b.$wp.height()+b.$wp.offset().top)+a(b.o_win).scrollTop()+20)):(c=b.position.getBoundingRect().top,b.opts.toolbarBottom&&(c+=b.opts.toolbarStickyOffset),b.helpers.isIOS()&&(c-=a(b.o_win).scrollTop()),b.opts.iframe&&(c+=b.$iframe.offset().top),c+=b.opts.toolbarStickyOffset,c>b.o_win.innerHeight-20&&a(b.o_win).scrollTop(c+a(b.o_win).scrollTop()-b.o_win.innerHeight+20),c=b.position.getBoundingRect().top,b.opts.toolbarBottom||(c-=b.opts.toolbarStickyOffset),b.helpers.isIOS()&&(c-=a(b.o_win).scrollTop()),b.opts.iframe&&(c+=b.$iframe.offset().top),c<b.$tb.height()+20&&a(b.o_win).scrollTop(c+a(b.o_win).scrollTop()-b.$tb.height()-20))}function p(){var c=b.selection.element(),d=b.node.blockParent(c);if(d&&\\\"DIV\\\"==d.tagName&&b.selection.info(d).atStart){var e=b.html.defaultTag();d.previousSibling&&\\\"DIV\\\"!=d.previousSibling.tagName&&e&&\\\"div\\\"!=e&&(b.selection.save(),a(d).replaceWith(\\\"<\\\"+e+\\\">\\\"+d.innerHTML+\\\"</\\\"+e+\\\">\\\"),b.selection.restore())}}function q(c){if(C)return C=!1,!1;if(!b.selection.isCollapsed())return!0;if(c&&(c.which===a.FE.KEYCODE.META||c.which==a.FE.KEYCODE.CTRL))return!0;if(c&&s(c.which))return!0;c&&c.which==a.FE.KEYCODE.ENTER&&b.helpers.isIOS()&&p(),c&&(c.which==a.FE.KEYCODE.ENTER||c.which==a.FE.KEYCODE.BACKSPACE||c.which>=37&&c.which<=40&&!b.browser.msie)&&(c.which==a.FE.KEYCODE.BACKSPACE&&z||o()),b.html.cleanBRs(!0,!0);var d=function(a){if(!a)return!1;var b=a.innerHTML;return b=b.replace(/<span[^>]*? class\\\\s*=\\\\s*[\\\"']?fr-marker[\\\"']?[^>]+>\\\\u200b<\\\\/span>/gi,\\\"\\\"),!!(b&&/\\\\u200B/.test(b)&&b.replace(/\\\\u200B/gi,\\\"\\\").length>0)},e=function(a){var c=/[\\\\u3041-\\\\u3096\\\\u30A0-\\\\u30FF\\\\u4E00-\\\\u9FFF\\\\u3130-\\\\u318F\\\\uAC00-\\\\uD7AF]/gi;return!b.helpers.isIOS()||0===((a.textContent||\\\"\\\").match(c)||[]).length},f=b.selection.element();d(f)&&!b.node.hasClass(f,\\\"fr-marker\\\")&&\\\"IFRAME\\\"!=f.tagName&&e(f)&&(b.selection.save(),n(f),b.selection.restore())}function r(a){if(navigator.userAgent.indexOf(\\\"Mac OS X\\\")!=-1){if(a.metaKey&&!a.altKey)return!0}else if(a.ctrlKey&&!a.altKey)return!0;return!1}function s(b){if(b>=a.FE.KEYCODE.ARROW_LEFT&&b<=a.FE.KEYCODE.ARROW_DOWN)return!0}function t(c){if(c>=a.FE.KEYCODE.ZERO&&c<=a.FE.KEYCODE.NINE)return!0;if(c>=a.FE.KEYCODE.NUM_ZERO&&c<=a.FE.KEYCODE.NUM_MULTIPLY)return!0;if(c>=a.FE.KEYCODE.A&&c<=a.FE.KEYCODE.Z)return!0;if(b.browser.webkit&&0===c)return!0;switch(c){case a.FE.KEYCODE.SPACE:case a.FE.KEYCODE.QUESTION_MARK:case a.FE.KEYCODE.NUM_PLUS:case a.FE.KEYCODE.NUM_MINUS:case a.FE.KEYCODE.NUM_PERIOD:case a.FE.KEYCODE.NUM_DIVISION:case a.FE.KEYCODE.SEMICOLON:case a.FE.KEYCODE.FF_SEMICOLON:case a.FE.KEYCODE.DASH:case a.FE.KEYCODE.EQUALS:case a.FE.KEYCODE.FF_EQUALS:case a.FE.KEYCODE.COMMA:case a.FE.KEYCODE.PERIOD:case a.FE.KEYCODE.SLASH:case a.FE.KEYCODE.APOSTROPHE:case a.FE.KEYCODE.SINGLE_QUOTE:case a.FE.KEYCODE.OPEN_SQUARE_BRACKET:case a.FE.KEYCODE.BACKSLASH:case a.FE.KEYCODE.CLOSE_SQUARE_BRACKET:return!0;default:return!1}}function u(c){var d=c.which;return!!(r(c)||d>=37&&d<=40||!t(d)&&d!=a.FE.KEYCODE.DELETE&&d!=a.FE.KEYCODE.BACKSPACE&&d!=a.FE.KEYCODE.ENTER)||(A||(B=b.snapshot.get()),clearTimeout(A),void(A=setTimeout(function(){A=null,b.undo.saveStep()},Math.max(250,b.opts.typingTimer))))}function v(a){var c=a.which;return!!(r(a)||c>=37&&c<=40)||void(B&&A&&(b.undo.saveStep(B),B=null))}function w(){A&&(clearTimeout(A),b.undo.saveStep(),B=null)}function x(b){var c=b.which;return r(b)||c==a.FE.KEYCODE.F5}function y(){if(b.events.on(\\\"keydown\\\",u),b.events.on(\\\"input\\\",h),b.events.on(\\\"keyup input\\\",v),b.events.on(\\\"keypress\\\",k),b.events.on(\\\"keydown\\\",m),b.events.on(\\\"keyup\\\",q),b.events.on(\\\"html.inserted\\\",q),b.events.on(\\\"cut\\\",i),b.el.msGetInputContext)try{b.el.msGetInputContext().addEventListener(\\\"MSCandidateWindowShow\\\",function(){C=!0}),b.el.msGetInputContext().addEventListener(\\\"MSCandidateWindowHide\\\",function(){C=!1,q()})}catch(a){}}var z,A,B,C=!1;return{_init:y,ctrlKey:r,isCharacter:t,isArrow:s,forceUndo:w,isIME:l,isBrowserAction:x}},a.FE.MODULES.accessibility=function(b){function c(a){a&&a.length&&(a.data(\\\"blur-event-set\\\")||a.parents(\\\".fr-popup\\\").length||(b.events.$on(a,\\\"blur\\\",function(c){var d=a.parents(\\\".fr-toolbar, .fr-popup\\\").data(\\\"instance\\\")||b;d.events.blurActive()&&d.events.trigger(\\\"blur\\\"),d.events.enableBlur()},!0),a.data(\\\"blur-event-set\\\",!0)),b.events.disableBlur(),a.focus(),b.shared.$f_el=a)}function d(a,b){var d=b?\\\"last\\\":\\\"first\\\",e=a.find(\\\"button:visible:not(.fr-disabled), .fr-group span.fr-command:visible\\\")[d]();if(e.length)return c(e),!0}function e(a){return a.is(\\\"input, textarea\\\")&&g(),b.events.disableBlur(),a.focus(),!0}function f(a,c){var d=a.find(\\\"input, textarea, button, select\\\").filter(\\\":visible\\\").not(\\\":disabled\\\").filter(c?\\\":last\\\":\\\":first\\\");if(d.length)return e(d);if(b.shared.with_kb){var f=a.find(\\\".fr-active-item:visible:first\\\");if(f.length)return e(f);var g=a.find(\\\"[tabIndex]:visible:first\\\");if(g.length)return e(g)}}function g(){0===b.$el.find(\\\".fr-marker\\\").length&&b.core.hasFocus()&&b.selection.save()}function h(a){a.$el.find(\\\".fr-marker\\\").length&&(a.events.disableBlur(),a.selection.restore(),a.events.enableBlur())}function i(a){var c=a.children().not(\\\".fr-buttons\\\");c.data(\\\"mouseenter-event-set\\\")||(b.events.$on(c,\\\"mouseenter\\\",\\\"[tabIndex]\\\",function(d){var e=a.data(\\\"instance\\\")||b;if(!E)return d.stopPropagation(),void d.preventDefault();var f=c.find(\\\":focus:first\\\");f.length&&!f.is(\\\"input, button\\\")&&(e.events.disableBlur(),f.blur(),e.events.disableBlur(),e.events.focus())}),c.data(\\\"mouseenter-event-set\\\",!0)),!f(c)&&b.shared.with_kb&&d(a.find(\\\".fr-buttons\\\"))}function j(){var a=b.popups.areVisible();if(a){var c=a.find(\\\".fr-buttons\\\");return c.find(\\\"button:focus, .fr-group span:focus\\\").length?!d(a.data(\\\"instance\\\").$tb):!d(c)}return!d(b.$tb)}function k(){var a=null;return b.shared.$f_el.is(\\\".fr-dropdown.fr-active\\\")?a=b.shared.$f_el:b.shared.$f_el.closest(\\\".fr-dropdown-menu\\\").prev().is(\\\".fr-dropdown.fr-active\\\")&&(a=b.shared.$f_el.closest(\\\".fr-dropdown-menu\\\").prev()),a}function l(e,g,h){if(b.shared.$f_el){var i=k();i&&(b.button.click(i),b.shared.$f_el=i);var j=e.find(\\\"button:visible:not(.fr-disabled), .fr-group span.fr-command:visible\\\"),l=j.index(b.shared.$f_el);if(0==l&&!h||l==j.length-1&&h){var m;if(g){if(e.parent().is(\\\".fr-popup\\\")){var n=e.parent().children().not(\\\".fr-buttons\\\");m=!f(n,!h)}m===!1&&(b.shared.$f_el=null)}g&&m===!1||d(e,!h)}else c(a(j.get(l+(h?1:-1))));return!1}}function m(a,b){return l(a,b,!0)}function n(a,b){return l(a,b)}function o(a){if(b.shared.$f_el){if(b.shared.$f_el.is(\\\".fr-dropdown.fr-active\\\")){var d;return d=a?b.shared.$f_el.next().find(\\\".fr-command:not(.fr-disabled)\\\").first():b.shared.$f_el.next().find(\\\".fr-command:not(.fr-disabled)\\\").last(),c(d),!1}if(b.shared.$f_el.is(\\\"a.fr-command\\\")){var d;return d=a?b.shared.$f_el.closest(\\\"li\\\").nextAll(\\\":visible:first\\\").find(\\\".fr-command:not(.fr-disabled)\\\").first():b.shared.$f_el.closest(\\\"li\\\").prevAll(\\\":visible:first\\\").find(\\\".fr-command:not(.fr-disabled)\\\").first(),d.length||(d=a?b.shared.$f_el.closest(\\\".fr-dropdown-menu\\\").find(\\\".fr-command:not(.fr-disabled)\\\").first():b.shared.$f_el.closest(\\\".fr-dropdown-menu\\\").find(\\\".fr-command:not(.fr-disabled)\\\").last()),c(d),!1}}}function p(){return b.shared.$f_el&&b.shared.$f_el.is(\\\".fr-dropdown:not(.fr-active)\\\")?r():o(!0)}function q(){return o()}function r(){if(b.shared.$f_el){if(b.shared.$f_el.hasClass(\\\"fr-dropdown\\\"))b.button.click(b.shared.$f_el);else if(b.shared.$f_el.is(\\\"button.fr-back\\\")){b.opts.toolbarInline&&(b.events.disableBlur(),b.events.focus());var a=b.popups.areVisible(b);a&&(b.shared.with_kb=!1),b.button.click(b.shared.$f_el),y(a)}else{if(b.events.disableBlur(),b.button.click(b.shared.$f_el),b.shared.$f_el.attr(\\\"data-popup\\\")){var c=b.popups.areVisible(b);c&&c.data(\\\"popup-button\\\",b.shared.$f_el)}else if(b.shared.$f_el.attr(\\\"data-modal\\\")){var d=b.modals.areVisible(b);d&&d.data(\\\"modal-button\\\",b.shared.$f_el)}b.shared.$f_el=null}return!1}}function s(){b.shared.$f_el&&(b.events.disableBlur(),b.shared.$f_el.blur(),b.shared.$f_el=null),b.events.disableBlur(),b.events.focus()}function t(a){if(b.shared.$f_el){var d=k();return d?(b.button.click(d),c(d)):a.parent().find(\\\".fr-back:visible\\\").length?(b.shared.with_kb=!1,b.opts.toolbarInline&&(b.events.disableBlur(),b.events.focus()),b.button.exec(a.parent().find(\\\".fr-back:visible:first\\\")),y(a.parent())):b.shared.$f_el.is(\\\"button, .fr-group span\\\")&&(a.parent().is(\\\".fr-popup\\\")?(h(b),b.shared.$f_el=null,b.events.trigger(\\\"toolbar.esc\\\")!==!1&&(b.popups.hide(a.parent()),b.opts.toolbarInline&&b.toolbar.showInline(null,!0),y(a.parent()))):s()),!1}}function u(c,d){var e=navigator.userAgent.indexOf(\\\"Mac OS X\\\")!=-1?c.metaKey:c.ctrlKey,f=c.which,g=!1;return f!=a.FE.KEYCODE.TAB||e||c.shiftKey||c.altKey?f!=a.FE.KEYCODE.ARROW_RIGHT||e||c.shiftKey||c.altKey?f!=a.FE.KEYCODE.TAB||e||!c.shiftKey||c.altKey?f!=a.FE.KEYCODE.ARROW_LEFT||e||c.shiftKey||c.altKey?f!=a.FE.KEYCODE.ARROW_UP||e||c.shiftKey||c.altKey?f!=a.FE.KEYCODE.ARROW_DOWN||e||c.shiftKey||c.altKey?f!=a.FE.KEYCODE.ENTER||e||c.shiftKey||c.altKey?f!=a.FE.KEYCODE.ESC||e||c.shiftKey||c.altKey?f!=a.FE.KEYCODE.F10||e||c.shiftKey||!c.altKey||(g=j()):g=t(d):g=r():g=p():g=q():g=n(d):g=n(d,!0):g=m(d):g=m(d,!0),b.shared.$f_el||void 0!==g||(g=!0),!g&&b.keys.isBrowserAction(c)&&(g=!0),!!g||(c.preventDefault(),c.stopPropagation(),!1)}function v(c){c&&c.length&&(b.events.$on(c,\\\"keydown\\\",function(d){if(!a(d.target).is(\\\"a.fr-command, button.fr-command, .fr-group span.fr-command\\\"))return!0;var e=c.parents(\\\".fr-popup\\\").data(\\\"instance\\\")||c.data(\\\"instance\\\")||b;b.shared.with_kb=!0;var f=e.accessibility.exec(d,c);return b.shared.with_kb=!1,f},!0),b.events.$on(c,\\\"mouseenter\\\",\\\"[tabIndex]\\\",function(d){var e=c.parents(\\\".fr-popup\\\").data(\\\"instance\\\")||c.data(\\\"instance\\\")||b;if(!E)return d.stopPropagation(),void d.preventDefault();var f=a(d.currentTarget);e.shared.$f_el&&e.shared.$f_el.not(f)&&e.accessibility.focusEditor()},!0))}function w(a){var c=b.popups.get(a),d=x(a);v(c.find(\\\".fr-buttons\\\")),b.events.$on(c,\\\"mouseenter\\\",\\\"tabIndex\\\",d._tiMouseenter,!0),b.events.$on(c.children().not(\\\".fr-buttons\\\"),\\\"keydown\\\",\\\"[tabIndex]\\\",d._tiKeydown,!0),b.popups.onHide(a,function(){h(c.data(\\\"instance\\\")||b)}),b.popups.onShow(a,function(){E=!1,setTimeout(function(){E=!0},0)})}function x(c){var e=b.popups.get(c);return{_tiKeydown:function(g){var i=e.data(\\\"instance\\\")||b;if(i.events.trigger(\\\"popup.tab\\\",[g])===!1)return!1;var j=g.which,k=e.find(\\\":focus:first\\\");if(a.FE.KEYCODE.TAB==j){g.preventDefault();var l=e.children().not(\\\".fr-buttons\\\"),m=l.find(\\\"input, textarea, button, select\\\").filter(\\\":visible\\\").not(\\\".fr-no-touch input, .fr-no-touch textarea, .fr-no-touch button, .fr-no-touch select, :disabled\\\").toArray(),n=m.indexOf(this)+(g.shiftKey?-1:1);if(0<=n&&n<m.length)return i.events.disableBlur(),a(m[n]).focus(),g.stopPropagation(),!1;var o=e.find(\\\".fr-buttons\\\");if(o.length&&d(o,!!g.shiftKey))return g.stopPropagation(),!1;if(f(l))return g.stopPropagation(),!1}else{if(a.FE.KEYCODE.ENTER!=j)return a.FE.KEYCODE.ESC==j?(g.preventDefault(),g.stopPropagation(),h(i),i.popups.isVisible(c)&&e.find(\\\".fr-back:visible\\\").length?(i.opts.toolbarInline&&(i.events.disableBlur(),i.events.focus()),i.button.exec(e.find(\\\".fr-back:visible:first\\\")),y(e)):i.popups.isVisible(c)&&e.find(\\\".fr-dismiss:visible\\\").length?i.button.exec(e.find(\\\".fr-dismiss:visible:first\\\")):(i.popups.hide(c),i.opts.toolbarInline&&i.toolbar.showInline(null,!0),y(e)),!1):a.FE.KEYCODE.SPACE==j&&(k.is(\\\".fr-submit\\\")||k.is(\\\".fr-dismiss\\\"))?(g.preventDefault(),g.stopPropagation(),i.events.disableBlur(),i.button.exec(k),!0):i.keys.isBrowserAction(g)?void g.stopPropagation():k.is(\\\"input[type=text], textarea\\\")?void g.stopPropagation():a.FE.KEYCODE.SPACE==j&&(k.is(\\\".fr-link-attr\\\")||k.is(\\\"input[type=file]\\\"))?void g.stopPropagation():(g.stopPropagation(),g.preventDefault(),!1);var p=null;e.find(\\\".fr-submit:visible\\\").length>0?p=e.find(\\\".fr-submit:visible:first\\\"):e.find(\\\".fr-dismiss:visible\\\").length&&(p=e.find(\\\".fr-dismiss:visible:first\\\")),p&&(g.preventDefault(),g.stopPropagation(),i.events.disableBlur(),i.button.exec(p))}},_tiMouseenter:function(a){var c=e.data(\\\"instance\\\")||b;B(c)}}}function y(a){var b=a.data(\\\"popup-button\\\");b&&setTimeout(function(){c(b),a.data(\\\"popup-button\\\",null)},0)}function z(a){var b=a.data(\\\"modal-button\\\");b&&setTimeout(function(){c(b),a.data(\\\"modal-button\\\",null)},0)}function A(){return null!=b.shared.$f_el}function B(a){var c=b.popups.areVisible(a);c&&c.data(\\\"popup-button\\\",null)}function C(c){var d=navigator.userAgent.indexOf(\\\"Mac OS X\\\")!=-1?c.metaKey:c.ctrlKey,e=c.which;if(e==a.FE.KEYCODE.F10&&!d&&!c.shiftKey&&c.altKey){b.shared.with_kb=!0;var g=b.popups.areVisible(b),h=!1;return g&&(h=f(g.children().not(\\\".fr-buttons\\\"))),h||j(),b.shared.with_kb=!1,c.preventDefault(),c.stopPropagation(),!1}return!0}function D(){b.$wp?b.events.on(\\\"keydown\\\",C,!0):b.events.$on(b.$win,\\\"keydown\\\",C,!0),b.events.on(\\\"mousedown\\\",function(a){B(b),b.shared.$f_el&&(h(b),a.stopPropagation(),b.events.disableBlur(),b.shared.$f_el=null)},!0),b.events.on(\\\"blur\\\",function(a){b.shared.$f_el=null,B(b)},!0)}var E=!0;return{_init:D,registerPopup:w,registerToolbar:v,focusToolbarElement:c,focusToolbar:d,focusContent:f,focusPopup:i,focusEditor:s,focusPopupButton:y,focusModalButton:z,hasFocus:A,exec:u,saveSelection:g,restoreSelection:h}},a.FE.MODULES.format=function(b){function c(a,b){var c=\\\"<\\\"+a;for(var d in b)b.hasOwnProperty(d)&&(c+=\\\" \\\"+d+'=\\\"'+b[d]+'\\\"');return c+=\\\">\\\"}function d(a){return\\\"</\\\"+a+\\\">\\\"}function e(a,b){var c=a;for(var d in b)b.hasOwnProperty(d)&&(a+=\\\"id\\\"==d?\\\"#\\\"+b[d]:\\\"class\\\"==d?\\\".\\\"+b[d]:\\\"[\\\"+d+'=\\\"'+b[d]+'\\\"]');return c}function f(a,b){return!(!a||a.nodeType!=Node.ELEMENT_NODE)&&(a.matches||a.matchesSelector||a.msMatchesSelector||a.mozMatchesSelector||a.webkitMatchesSelector||a.oMatchesSelector).call(a,b)}function g(d,e,f){if(d){if(b.node.isBlock(d))return g(d.firstChild,e,f),!1;for(var h=a(c(e,f)).insertBefore(d),i=d;i&&!a(i).is(\\\".fr-marker\\\")&&0==a(i).find(\\\".fr-marker\\\").length;){var j=i;i=i.nextSibling,h.append(j)}if(i)a(i).find(\\\".fr-marker\\\").length&&g(i.firstChild,e,f);else{for(var k=h.get(0).parentNode;k&&!k.nextSibling&&!b.node.isElement(k);)k=k.parentNode;if(k){var l=k.nextSibling;l&&(b.node.isBlock(l)?g(l.firstChild,e,f):g(l,e,f))}}h.is(\\\":empty\\\")&&h.remove()}}function h(h,i){if(\\\"undefined\\\"==typeof i&&(i={}),i.style&&delete i.style,b.selection.isCollapsed()){b.markers.insert();var j=b.$el.find(\\\".fr-marker\\\");j.replaceWith(c(h,i)+a.FE.INVISIBLE_SPACE+a.FE.MARKERS+d(h)),b.selection.restore()}else{b.selection.save();var k=b.$el.find('.fr-marker[data-type=\\\"true\\\"]').get(0).nextSibling;g(k,h,i);var l;do l=b.$el.find(e(h,i)+\\\" > \\\"+e(h,i)),l.each(function(){a(this).replaceWith(this.innerHTML)});while(l.length);b.el.normalize();for(var m=b.el.querySelectorAll(\\\".fr-marker\\\"),n=0;n<m.length;n++){var o=a(m[n]);1==o.data(\\\"type\\\")?f(o.get(0).nextSibling,e(h,i))&&o.next().prepend(o):f(o.get(0).previousSibling,e(h,i))&&o.prev().append(o)}b.selection.restore()}}function i(a,c,d,g){if(!g){var h=!1;if(a.data(\\\"type\\\")===!0)for(;b.node.isFirstSibling(a.get(0))&&!a.parent().is(b.$el);)a.parent().before(a),h=!0;else if(a.data(\\\"type\\\")===!1)for(;b.node.isLastSibling(a.get(0))&&!a.parent().is(b.$el);)a.parent().after(a),h=!0;if(h)return!0}if(a.parents(c).length||\\\"undefined\\\"==typeof c){var i=\\\"\\\",j=\\\"\\\",k=a.parent();if(k.is(b.$el)||b.node.isBlock(k.get(0)))return!1;for(;\\\"undefined\\\"==typeof c&&!b.node.isBlock(k.parent().get(0))||\\\"undefined\\\"!=typeof c&&!f(k.get(0),e(c,d));)i+=b.node.closeTagString(k.get(0)),j=b.node.openTagString(k.get(0))+j,k=k.parent();var l=a.get(0).outerHTML;a.replaceWith('<span id=\\\"mark\\\"></span>');var m=k.html().replace(/<span id=\\\"mark\\\"><\\\\/span>/,i+b.node.closeTagString(k.get(0))+j+l+i+b.node.openTagString(k.get(0))+j);return k.replaceWith(b.node.openTagString(k.get(0))+m+b.node.closeTagString(k.get(0))),!0}return!1}function j(c,d,g,h){for(var i=b.node.contents(c.get(0)),k=0;k<i.length;k++){var l=i[k];b.node.hasClass(l,\\\"fr-marker\\\")?d=(d+1)%2:d?a(l).find(\\\".fr-marker\\\").length>0?d=j(a(l),d,g,h):(a(a(l).find(g||\\\"*\\\").get().reverse()).each(function(){b.node.isBlock(this)||b.node.isVoid(this)||a(this).replaceWith(this.innerHTML)}),\\\"undefined\\\"==typeof g&&l.nodeType==Node.ELEMENT_NODE&&!b.node.isVoid(l)&&!b.node.isBlock(l)||f(l,e(g,h))?a(l).replaceWith(l.innerHTML):\\\"undefined\\\"==typeof g&&l.nodeType==Node.ELEMENT_NODE&&b.node.isBlock(l)&&a(l).removeAttr(\\\"style\\\")):a(l).find(\\\".fr-marker\\\").length>0&&(d=j(a(l),d,g,h))}return d}function k(c,d){\\\"undefined\\\"==typeof d&&(d={}),d.style&&delete d.style;var e=b.selection.isCollapsed();b.selection.save();for(var f=!0;f;){f=!1;for(var g=b.$el.find(\\\".fr-marker\\\"),h=0;h<g.length;h++)if(i(a(g[h]),c,d,e)){f=!0;break}}j(b.$el,0,c,d),e&&b.$el.find(\\\".fr-marker\\\").before(a.FE.INVISIBLE_SPACE).after(a.FE.INVISIBLE_SPACE),b.html.cleanEmptyTags(),b.el.normalize(),b.selection.restore()}function l(a,b){q(a,b)?k(a,b):h(a,b)}function m(b,c){var d=a(b);d.css(c,\\\"\\\"),\\\"\\\"===d.attr(\\\"style\\\")&&d.replaceWith(d.html())}function n(b,c){return 0===a(b).attr(\\\"style\\\").indexOf(c+\\\":\\\")||a(b).attr(\\\"style\\\").indexOf(\\\";\\\"+c+\\\":\\\")>=0||a(b).attr(\\\"style\\\").indexOf(\\\"; \\\"+c+\\\":\\\")>=0}function o(c,d){if(b.selection.isCollapsed()){b.markers.insert();var e=b.$el.find(\\\".fr-marker\\\"),f=e.parent();if(b.node.openTagString(f.get(0))=='<span style=\\\"'+c+\\\": \\\"+f.css(c)+';\\\">')if(b.node.isEmpty(f.get(0)))f.replaceWith('<span style=\\\"'+c+\\\": \\\"+d+';\\\">'+a.FE.INVISIBLE_SPACE+a.FE.MARKERS+\\\"</span>\\\");else{var h={};h[c]=d,i(e,\\\"span\\\",h,!0),e=b.$el.find(\\\".fr-marker\\\"),e.replaceWith('<span style=\\\"'+c+\\\": \\\"+d+';\\\">'+a.FE.INVISIBLE_SPACE+a.FE.MARKERS+\\\"</span>\\\")}else b.node.isEmpty(f.get(0))&&f.is(\\\"span\\\")?(e.replaceWith(a.FE.MARKERS),f.css(c,d)):e.replaceWith('<span style=\\\"'+c+\\\": \\\"+d+';\\\">'+a.FE.INVISIBLE_SPACE+a.FE.MARKERS+\\\"</span>\\\");b.selection.restore()}else{b.selection.save();for(var j=b.$el.find(\\\".fr-marker\\\"),k=0;k<j.length;k++){var e=a(j[k]);if(e.data(\\\"type\\\")===!0)for(;b.node.isFirstSibling(e.get(0))&&!e.parent().is(b.$el);)e.parent().before(e);else for(;b.node.isLastSibling(e.get(0))&&!e.parent().is(b.$el);)e.parent().after(e)}var l=b.$el.find('.fr-marker[data-type=\\\"true\\\"]').get(0).nextSibling,o={class:\\\"fr-unprocessed\\\"};for(d&&(o.style=c+\\\": \\\"+d+\\\";\\\"),g(l,\\\"span\\\",o),b.$el.find(\\\".fr-marker + .fr-unprocessed\\\").each(function(){a(this).prepend(a(this).prev())}),b.$el.find(\\\".fr-unprocessed + .fr-marker\\\").each(function(){a(this).prev().append(this)});b.$el.find(\\\"span.fr-unprocessed\\\").length>0;){var p=b.$el.find(\\\"span.fr-unprocessed:first\\\").removeClass(\\\"fr-unprocessed\\\");if(p.parent().get(0).normalize(),p.parent().is(\\\"span\\\")&&1==p.parent().get(0).childNodes.length){p.parent().css(c,d);var q=p;p=p.parent(),q.replaceWith(q.html())}for(var r=p.find(\\\"span\\\"),k=r.length-1;k>=0;k--)m(r[k],c);var s=p.parentsUntil(b.$el,\\\"span[style]\\\").filter(function(){return n(this,c)});if(s.length){var t=\\\"\\\",u=\\\"\\\",v=\\\"\\\",w=\\\"\\\",x=p.get(0);do x=x.parentNode,a(x).addClass(\\\"fr-split\\\"),t+=b.node.closeTagString(x),u=b.node.openTagString(a(x).clone().addClass(\\\"fr-split\\\").get(0))+u,s.get(0)!=x&&(v+=b.node.closeTagString(x),w=b.node.openTagString(a(x).clone().addClass(\\\"fr-split\\\").get(0))+w);while(s.get(0)!=x);var y=t+b.node.openTagString(a(s.get(0)).clone().css(c,d||\\\"\\\").get(0))+w+p.css(c,\\\"\\\").get(0).outerHTML+v+\\\"</span>\\\"+u;p.replaceWith('<span id=\\\"fr-break\\\"></span>');var z=s.get(0).outerHTML;a(s.get(0)).replaceWith(z.replace(/<span id=\\\"fr-break\\\"><\\\\/span>/g,y))}}for(;b.$el.find(\\\".fr-split:empty\\\").length>0;)b.$el.find(\\\".fr-split:empty\\\").remove();b.$el.find(\\\".fr-split\\\").removeClass(\\\"fr-split\\\"),b.$el.find('span[style=\\\"\\\"]').removeAttr(\\\"style\\\"),b.$el.find('span[class=\\\"\\\"]').removeAttr(\\\"class\\\"),b.html.cleanEmptyTags(),a(b.$el.find(\\\"span\\\").get().reverse()).each(function(){this.attributes&&0!=this.attributes.length||a(this).replaceWith(this.innerHTML)}),b.el.normalize();var A=b.$el.find(\\\"span[style] + span[style]\\\");for(k=0;k<A.length;k++){var B=a(A[k]),C=a(A[k]).prev();B.get(0).previousSibling==C.get(0)&&b.node.openTagString(B.get(0))==b.node.openTagString(C.get(0))&&(B.prepend(C.html()),C.remove())}b.el.normalize(),b.selection.restore()}}function p(a){o(a,null)}function q(a,c){\\\"undefined\\\"==typeof c&&(c={}),c.style&&delete c.style;var d=b.selection.ranges(0),g=d.startContainer;g.nodeType==Node.ELEMENT_NODE&&g.childNodes.length>0&&g.childNodes[d.startOffset]&&(g=g.childNodes[d.startOffset]);for(var h=g;h&&h.nodeType==Node.ELEMENT_NODE&&!f(h,e(a,c));)h=h.firstChild;if(h&&h.nodeType==Node.ELEMENT_NODE&&f(h,e(a,c)))return!0;var i=g;for(i&&i.nodeType!=Node.ELEMENT_NODE&&(i=i.parentNode);i&&i.nodeType==Node.ELEMENT_NODE&&i!=b.el&&!f(i,e(a,c));)i=i.parentNode;return!(!i||i.nodeType!=Node.ELEMENT_NODE||i==b.el||!f(i,e(a,c)))}return{is:q,toggle:l,apply:h,remove:k,applyStyle:o,removeStyle:p}},a.FE.COMMANDS={bold:{title:\\\"Bold\\\",toggle:!0,refresh:function(a){var b=this.format.is(\\\"strong\\\");a.toggleClass(\\\"fr-active\\\",b).attr(\\\"aria-pressed\\\",b)}},italic:{title:\\\"Italic\\\",toggle:!0,refresh:function(a){var b=this.format.is(\\\"em\\\");a.toggleClass(\\\"fr-active\\\",b).attr(\\\"aria-pressed\\\",b)}},underline:{title:\\\"Underline\\\",toggle:!0,refresh:function(a){var b=this.format.is(\\\"u\\\");a.toggleClass(\\\"fr-active\\\",b).attr(\\\"aria-pressed\\\",b)}},strikeThrough:{title:\\\"Strikethrough\\\",toggle:!0,refresh:function(a){var b=this.format.is(\\\"s\\\");a.toggleClass(\\\"fr-active\\\",b).attr(\\\"aria-pressed\\\",b)}},subscript:{title:\\\"Subscript\\\",toggle:!0,refresh:function(a){var b=this.format.is(\\\"sub\\\");a.toggleClass(\\\"fr-active\\\",b).attr(\\\"aria-pressed\\\",b)}},superscript:{title:\\\"Superscript\\\",toggle:!0,refresh:function(a){var b=this.format.is(\\\"sup\\\");a.toggleClass(\\\"fr-active\\\",b).attr(\\\"aria-pressed\\\",b)}},outdent:{title:\\\"Decrease Indent\\\"},indent:{title:\\\"Increase Indent\\\"},undo:{title:\\\"Undo\\\",undo:!1,forcedRefresh:!0,disabled:!0},redo:{title:\\\"Redo\\\",undo:!1,forcedRefresh:!0,disabled:!0},insertHR:{title:\\\"Insert Horizontal Line\\\"},clearFormatting:{title:\\\"Clear Formatting\\\"},selectAll:{title:\\\"Select All\\\",undo:!1}},a.FE.RegisterCommand=function(b,c){a.FE.COMMANDS[b]=c},a.FE.MODULES.commands=function(b){function c(c,d){if(b.events.trigger(\\\"commands.before\\\",a.merge([c],d||[]))!==!1){var e=a.FE.COMMANDS[c]&&a.FE.COMMANDS[c].callback||h[c],f=!0,g=!1;a.FE.COMMANDS[c]&&(\\\"undefined\\\"!=typeof a.FE.COMMANDS[c].focus&&(f=a.FE.COMMANDS[c].focus),\\\"undefined\\\"!=typeof a.FE.COMMANDS[c].accessibilityFocus&&(g=a.FE.COMMANDS[c].accessibilityFocus)),(!b.core.hasFocus()&&f&&!b.popups.areVisible()||!b.core.hasFocus()&&g&&b.accessibility.hasFocus())&&b.events.focus(!0),a.FE.COMMANDS[c]&&a.FE.COMMANDS[c].undo!==!1&&(b.$el.find(\\\".fr-marker\\\").length&&(b.events.disableBlur(),b.selection.restore()),b.undo.saveStep()),e&&e.apply(b,a.merge([c],d||[])),b.events.trigger(\\\"commands.after\\\",a.merge([c],d||[])),a.FE.COMMANDS[c]&&a.FE.COMMANDS[c].undo!==!1&&b.undo.saveStep()}}function d(a,c){b.format.toggle(c)}function e(c){b.selection.save(),b.html.wrap(!0,!0,!0,!0),b.selection.restore();for(var d=b.selection.blocks(),e=0;e<d.length;e++)if(\\\"LI\\\"!=d[e].tagName&&\\\"LI\\\"!=d[e].parentNode.tagName){var f=a(d[e]),g=\\\"rtl\\\"==b.opts.direction||\\\"rtl\\\"==f.css(\\\"direction\\\")?\\\"margin-right\\\":\\\"margin-left\\\",h=b.helpers.getPX(f.css(g));f.css(g,Math.max(h+20*c,0)||\\\"\\\"),f.removeClass(\\\"fr-temp-div\\\")}b.selection.save(),b.html.unwrap(),b.selection.restore()}function f(a){return function(){c(a)}}function g(){b.events.on(\\\"keydown\\\",function(a){var c=b.selection.element();if(c&&\\\"HR\\\"==c.tagName&&!b.keys.isArrow(a.which))return a.preventDefault(),!1}),b.events.on(\\\"keyup\\\",function(c){var d=b.selection.element();if(d&&\\\"HR\\\"==d.tagName)if(c.which==a.FE.KEYCODE.ARROW_LEFT||c.which==a.FE.KEYCODE.ARROW_UP){if(d.previousSibling)return b.node.isBlock(d.previousSibling)?b.selection.setAtEnd(d.previousSibling):a(d).before(a.FE.MARKERS),b.selection.restore(),!1}else if((c.which==a.FE.KEYCODE.ARROW_RIGHT||c.which==a.FE.KEYCODE.ARROW_DOWN)&&d.nextSibling)return b.node.isBlock(d.nextSibling)?b.selection.setAtStart(d.nextSibling):a(d).after(a.FE.MARKERS),b.selection.restore(),!1}),b.events.on(\\\"mousedown\\\",function(a){if(a.target&&\\\"HR\\\"==a.target.tagName)return a.preventDefault(),a.stopPropagation(),!1}),b.events.on(\\\"mouseup\\\",function(c){var d=b.selection.element(),e=b.selection.endElement();d==e&&d&&\\\"HR\\\"==d.tagName&&(d.nextSibling&&(b.node.isBlock(d.nextSibling)?b.selection.setAtStart(d.nextSibling):a(d).after(a.FE.MARKERS)),b.selection.restore())})}var h={bold:function(){d(\\\"bold\\\",\\\"strong\\\")},subscript:function(){d(\\\"subscript\\\",\\\"sub\\\")},superscript:function(){d(\\\"superscript\\\",\\\"sup\\\")},italic:function(){d(\\\"italic\\\",\\\"em\\\")},strikeThrough:function(){d(\\\"strikeThrough\\\",\\\"s\\\")},underline:function(){d(\\\"underline\\\",\\\"u\\\")},undo:function(){b.undo.run()},redo:function(){b.undo.redo()},indent:function(){e(1)},outdent:function(){e(-1)},show:function(){b.opts.toolbarInline&&b.toolbar.showInline(null,!0)},insertHR:function(){b.selection.remove();var a=\\\"\\\";b.core.isEmpty()&&(a=\\\"<br>\\\",b.html.defaultTag()&&(a=\\\"<\\\"+b.html.defaultTag()+\\\">\\\"+a+\\\"</\\\"+b.html.defaultTag()+\\\">\\\")),b.html.insert('<hr id=\\\"fr-just\\\">'+a);var c=b.$el.find(\\\"hr#fr-just\\\");c.removeAttr(\\\"id\\\"),b.selection.setAfter(c.get(0),!1)||b.selection.setBefore(c.get(0),!1),b.selection.restore()},clearFormatting:function(){b.format.remove()},selectAll:function(){b.doc.execCommand(\\\"selectAll\\\",!1,!1)}},i={};for(var j in h)h.hasOwnProperty(j)&&(i[j]=f(j));return a.extend(i,{exec:c,_init:g})},a.FE.MODULES.data=function(a){function b(a){return a}function c(a){if(!a)return a;for(var c=\\\"\\\",f=b(\\\"charCodeAt\\\"),g=b(\\\"fromCharCode\\\"),h=l.indexOf(a[0]),i=1;i<a.length-2;i++){for(var j=d(++h),k=a[f](i),m=\\\"\\\";/[0-9-]/.test(a[i+1]);)m+=a[++i];m=parseInt(m,10)||0,k=e(k,j,m),k^=h-1&31,c+=String[g](k)}return c}function d(a){for(var b=a.toString(),c=0,d=0;d<b.length;d++)c+=parseInt(b.charAt(d),10);return c>10?c%9+1:c}function e(a,b,c){for(var d=Math.abs(c);d-- >0;)a-=b;return c<0&&(a+=123),a}function f(a){return!(!a||\\\"none\\\"!=a.css(\\\"display\\\")||(a.remove(),0))}function g(){return f(j)||f(k)}function h(){return!!a.$box&&(a.$box.append(n(b(n(\\\"kTDD4spmKD1klaMB1C7A5RA1G3RA10YA5qhrjuvnmE1D3FD2bcG-7noHE6B2JB4C3xXA8WF6F-10RG2C3G3B-21zZE3C3H3xCA16NC4DC1f1hOF1MB3B-21whzQH5UA2WB10kc1C2F4D3XC2YD4D1C4F3GF2eJ2lfcD-13HF1IE1TC11TC7WE4TA4d1A2YA6XA4d1A3yCG2qmB-13GF4A1B1KH1HD2fzfbeQC3TD9VE4wd1H2A20A2B-22ujB3nBG2A13jBC10D3C2HD5D1H1KB11uD-16uWF2D4A3F-7C9D-17c1E4D4B3d1D2CA6B2B-13qlwzJF2NC2C-13E-11ND1A3xqUA8UE6bsrrF-7C-22ia1D2CF2H1E2akCD2OE1HH1dlKA6PA5jcyfzB-22cXB4f1C3qvdiC4gjGG2H2gklC3D-16wJC1UG4dgaWE2D5G4g1I2H3B7vkqrxH1H2EC9C3E4gdgzKF1OA1A5PF5C4WWC3VA6XA4e1E3YA2YA5HE4oGH4F2H2IB10D3D2NC5G1B1qWA9PD6PG5fQA13A10XA4C4A3e1H2BA17kC-22cmOB1lmoA2fyhcptwWA3RA8A-13xB-11nf1I3f1B7GB3aD3pavFC10D5gLF2OG1LSB2D9E7fQC1F4F3wpSB5XD3NkklhhaE-11naKA9BnIA6D1F5bQA3A10c1QC6Kjkvitc2B6BE3AF3E2DA6A4JD2IC1jgA-64MB11D6C4==\\\")))),j=a.$box.find(\\\"> div:last\\\"),k=j.find(\\\"> a\\\"),void(\\\"rtl\\\"==a.opts.direction&&j.css(\\\"left\\\",\\\"auto\\\").css(\\\"right\\\",0)))}function i(){var c=a.opts.key||[\\\"\\\"];\\\"string\\\"==typeof c&&(c=[c]),a.ul=!0;for(var d=0;d<c.length;d++){var e=n(c[d])||\\\"\\\";if(!(e!==n(b(n(\\\"mcVRDoB1BGILD7YFe1BTXBA7B6==\\\")))&&e.indexOf(m,e.length-m.length)<0&&[n(\\\"9qqG-7amjlwq==\\\"),n(\\\"KA3B3C2A6D1D5H5H1A3==\\\"),n(\\\"QzbzvxyB2yA-9m==\\\"),n(\\\"naamngiA3dA-16xtE-11C-9B1H-8sc==\\\")].indexOf(m)<0)){a.ul=!1;break}}a.ul===!0&&h(),a.events.on(\\\"contentChanged\\\",function(){a.ul===!0&&g()&&h()}),a.events.on(\\\"destroy\\\",function(){j&&j.length&&j.remove()},!0)}var j,k,l=\\\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\\\",m=function(){for(var a=0,b=document.domain,c=b.split(\\\".\\\"),d=\\\"_gd\\\"+(new Date).getTime();a<c.length-1&&document.cookie.indexOf(d+\\\"=\\\"+d)==-1;)b=c.slice(-1-++a).join(\\\".\\\"),document.cookie=d+\\\"=\\\"+d+\\\";domain=\\\"+b+\\\";\\\";return document.cookie=d+\\\"=;expires=Thu, 01 Jan 1970 00:00:01 GMT;domain=\\\"+b+\\\";\\\",(b||\\\"\\\").replace(/(^\\\\.*)|(\\\\.*$)/g,\\\"\\\")}(),n=b(c);return{_init:i}},a.extend(a.FE.DEFAULTS,{pastePlain:!1,pasteDeniedTags:[\\\"colgroup\\\",\\\"col\\\"],pasteDeniedAttrs:[\\\"class\\\",\\\"id\\\",\\\"style\\\"],pasteAllowLocalImages:!1}),a.FE.MODULES.paste=function(b){function c(c){a.FE.copied_html=b.html.getSelected(),a.FE.copied_text=a(\\\"<div>\\\").html(a.FE.copied_html).text(),\\\"cut\\\"==c.type&&(b.undo.saveStep(),setTimeout(function(){b.selection.save(),b.html.wrap(),b.selection.restore(),b.events.focus(),b.undo.saveStep()},0))}function d(a){if(o)return!1;if(a.originalEvent&&(a=a.originalEvent),b.events.trigger(\\\"paste.before\\\",[a])===!1)return a.preventDefault(),!1;if(l=b.$win.scrollTop(),a&&a.clipboardData&&a.clipboardData.getData){var c=\\\"\\\",d=a.clipboardData.types;if(b.helpers.isArray(d))for(var f=0;f<d.length;f++)c+=d[f]+\\\";\\\";else c=d;if(m=\\\"\\\",/text\\\\/html/.test(c)?m=a.clipboardData.getData(\\\"text/html\\\"):/text\\\\/rtf/.test(c)&&b.browser.safari?m=a.clipboardData.getData(\\\"text/rtf\\\"):/text\\\\/plain/.test(c)&&!this.browser.mozilla&&(m=b.html.escapeEntities(a.clipboardData.getData(\\\"text/plain\\\")).replace(/\\\\n/g,\\\"<br>\\\")),\\\"\\\"!==m)return h(),a.preventDefault&&(a.stopPropagation(),a.preventDefault()),!1;m=null}e()}function e(){b.selection.save(),b.events.disableBlur(),m=null,n?n.html(\\\"\\\"):(n=a('<div contenteditable=\\\"true\\\" style=\\\"position: fixed; top: 0; left: -9999px; height: 100%; width: 0; word-break: break-all; overflow:hidden; z-index: 9999; line-height: 140%;\\\" tabIndex=\\\"-1\\\"></div>'),b.$box.after(n),b.events.on(\\\"destroy\\\",function(){n.remove()})),n.focus(),b.win.setTimeout(h,1)}function f(a){a=a.replace(/<p(.*?)class=\\\"?'?MsoListParagraph\\\"?'? ([\\\\s\\\\S]*?)>([\\\\s\\\\S]*?)<\\\\/p>/gi,\\\"<ul><li>$3</li></ul>\\\"),a=a.replace(/<p(.*?)class=\\\"?'?NumberedText\\\"?'? ([\\\\s\\\\S]*?)>([\\\\s\\\\S]*?)<\\\\/p>/gi,\\\"<ol><li>$3</li></ol>\\\"),a=a.replace(/<p(.*?)class=\\\"?'?MsoListParagraphCxSpFirst\\\"?'?([\\\\s\\\\S]*?)(level\\\\d)?([\\\\s\\\\S]*?)>([\\\\s\\\\S]*?)<\\\\/p>/gi,\\\"<ul><li$3>$5</li>\\\"),a=a.replace(/<p(.*?)class=\\\"?'?NumberedTextCxSpFirst\\\"?'?([\\\\s\\\\S]*?)(level\\\\d)?([\\\\s\\\\S]*?)>([\\\\s\\\\S]*?)<\\\\/p>/gi,\\\"<ol><li$3>$5</li>\\\"),a=a.replace(/<p(.*?)class=\\\"?'?MsoListParagraphCxSpMiddle\\\"?'?([\\\\s\\\\S]*?)(level\\\\d)?([\\\\s\\\\S]*?)>([\\\\s\\\\S]*?)<\\\\/p>/gi,\\\"<li$3>$5</li>\\\"),a=a.replace(/<p(.*?)class=\\\"?'?NumberedTextCxSpMiddle\\\"?'?([\\\\s\\\\S]*?)(level\\\\d)?([\\\\s\\\\S]*?)>([\\\\s\\\\S]*?)<\\\\/p>/gi,\\\"<li$3>$5</li>\\\"),a=a.replace(/<p(.*?)class=\\\"?'?MsoListBullet\\\"?'?([\\\\s\\\\S]*?)(level\\\\d)?([\\\\s\\\\S]*?)>([\\\\s\\\\S]*?)<\\\\/p>/gi,\\\"<li$3>$5</li>\\\"),a=a.replace(/<p(.*?)class=\\\"?'?MsoListParagraphCxSpLast\\\"?'?([\\\\s\\\\S]*?)(level\\\\d)?([\\\\s\\\\S]*?)>([\\\\s\\\\S]*?)<\\\\/p>/gi,\\\"<li$3>$5</li></ul>\\\"),a=a.replace(/<p(.*?)class=\\\"?'?NumberedTextCxSpLast\\\"?'?([\\\\s\\\\S]*?)(level\\\\d)?([\\\\s\\\\S]*?)>([\\\\s\\\\S]*?)<\\\\/p>/gi,\\\"<li$3>$5</li></ol>\\\"),a=a.replace(/<span([^<]*?)style=\\\"?'?mso-list:Ignore\\\"?'?([\\\\s\\\\S]*?)>([\\\\s\\\\S]*?)<span/gi,\\\"<span><span\\\"),a=a.replace(/<!--\\\\[if \\\\!supportLists\\\\]-->([\\\\s\\\\S]*?)<!--\\\\[endif\\\\]-->/gi,\\\"\\\"),a=a.replace(/<!\\\\[if \\\\!supportLists\\\\]>([\\\\s\\\\S]*?)<!\\\\[endif\\\\]>/gi,\\\"\\\"),a=a.replace(/(\\\\n|\\\\r| class=(\\\")?Mso[a-zA-Z0-9]+(\\\")?)/gi,\\\" \\\"),a=a.replace(/<!--[\\\\s\\\\S]*?-->/gi,\\\"\\\"),a=a.replace(/<(\\\\/)*(meta|link|span|\\\\\\\\?xml:|st1:|o:|font)(.*?)>/gi,\\\"\\\");for(var c=[\\\"style\\\",\\\"script\\\",\\\"applet\\\",\\\"embed\\\",\\\"noframes\\\",\\\"noscript\\\"],d=0;d<c.length;d++){var e=new RegExp(\\\"<\\\"+c[d]+\\\".*?\\\"+c[d]+\\\"(.*?)>\\\",\\\"gi\\\");\\na=a.replace(e,\\\"\\\")}a=a.replace(/&nbsp;/gi,\\\" \\\"),a=a.replace(/<td([^>]*)><\\\\/td>/g,\\\"<td$1><br></td>\\\"),a=a.replace(/<th([^>]*)><\\\\/th>/g,\\\"<th$1><br></th>\\\");var f;do f=a,a=a.replace(/<[^\\\\/>][^>]*><\\\\/[^>]+>/gi,\\\"\\\");while(a!=f);a=a.replace(/<lilevel([^1])([^>]*)>/gi,'<li data-indent=\\\"true\\\"$2>'),a=a.replace(/<lilevel1([^>]*)>/gi,\\\"<li$1>\\\"),a=b.clean.html(a,b.opts.pasteDeniedTags,b.opts.pasteDeniedAttrs),a=a.replace(/<a>(.[^<]+)<\\\\/a>/gi,\\\"$1\\\"),a=a.replace(/<br> */g,\\\"<br>\\\");var g=b.doc.createElement(\\\"div\\\");g.innerHTML=a;for(var h=g.querySelectorAll(\\\"li[data-indent]\\\"),d=0;d<h.length;d++){var i=h[d],j=i.previousElementSibling;if(j&&\\\"LI\\\"==j.tagName){var k=j.querySelector(\\\":scope > ul, :scope > ol\\\");k||(k=document.createElement(\\\"ul\\\"),j.appendChild(k)),k.appendChild(i)}else i.removeAttribute(\\\"data-indent\\\")}return b.html.cleanBlankSpaces(g),a=g.innerHTML}function g(a){var c=b.doc.createElement(\\\"div\\\");c.innerHTML=a;for(var d=c.querySelectorAll(\\\"p, div, h1, h2, h3, h4, h5, h6, pre, blockquote\\\"),e=0;e<d.length;e++){var f=d[e];f.outerHTML=\\\"<\\\"+(b.html.defaultTag()||\\\"DIV\\\")+\\\">\\\"+f.innerHTML+\\\"</\\\"+(b.html.defaultTag()||\\\"DIV\\\")+\\\">\\\"}d=c.querySelectorAll(\\\"*:not(\\\"+\\\"p, div, h1, h2, h3, h4, h5, h6, pre, blockquote, ul, ol, li, table, tbody, thead, tr, td, br, img\\\".split(\\\",\\\").join(\\\"):not(\\\")+\\\")\\\");for(var e=d.length-1;e>=0;e--){var f=d[e];f.outerHTML=f.innerHTML}var g=function(a){for(var c=b.node.contents(a),d=0;d<c.length;d++)c[d].nodeType!=Node.TEXT_NODE&&c[d].nodeType!=Node.ELEMENT_NODE?c[d].parentNode.removeChild(c[d]):g(c[d])};return g(c),c.innerHTML}function h(){b.keys.forceUndo();var c=b.snapshot.get();null===m&&(m=n.get(0).innerHTML,b.selection.restore(),b.events.enableBlur());var d=b.events.chainTrigger(\\\"paste.beforeCleanup\\\",m);\\\"string\\\"==typeof d&&(m=d);var e=!1;m.match(/(class=\\\\\\\"?Mso|class=\\\\'?Mso|style=\\\\\\\"[^\\\\\\\"]*\\\\bmso\\\\-|style=\\\\'[^\\\\']*\\\\bmso\\\\-|w:WordDocument)/gi)&&(e=!0),m.indexOf(\\\"<body\\\")>=0&&(m=m.replace(/[.\\\\s\\\\S\\\\w\\\\W<>]*<body[^>]*>([.\\\\s\\\\S\\\\w\\\\W<>]*)<\\\\/body>[.\\\\s\\\\S\\\\w\\\\W<>]*/g,\\\"$1\\\"));var h=!1;if(m.indexOf('id=\\\"docs-internal-guid')>=0&&(m=m.replace(/^.* id=\\\"docs-internal-guid[^>]*>(.*)<\\\\/b>.*$/,\\\"$1\\\"),h=!0),e)m=m.replace(/^\\\\n*/g,\\\"\\\").replace(/^ /g,\\\"\\\"),0===m.indexOf(\\\"<colgroup>\\\")&&(m=\\\"<table>\\\"+m+\\\"</table>\\\"),m=f(m),m=j(m);else{b.opts.htmlAllowComments=!1,m=b.clean.html(m,b.opts.pasteDeniedTags,b.opts.pasteDeniedAttrs),b.opts.htmlAllowComments=!0,m=j(m),m=m.replace(/\\\\r|\\\\n|\\\\t/g,\\\"\\\");var k=b.doc.createElement(\\\"div\\\");k.innerHTML=m,a.FE.copied_text&&k.textContent.replace(/(\\\\u00A0)/gi,\\\" \\\").replace(/\\\\r|\\\\n/gi,\\\"\\\")==a.FE.copied_text.replace(/(\\\\u00A0)/gi,\\\" \\\").replace(/\\\\r|\\\\n/gi,\\\"\\\")&&(m=a.FE.copied_html),m=m.replace(/^ */g,\\\"\\\").replace(/ *$/g,\\\"\\\")}if(b.opts.pastePlain&&(m=g(m)),d=b.events.chainTrigger(\\\"paste.afterCleanup\\\",m),\\\"string\\\"==typeof d&&(m=d),\\\"\\\"!==m){var l=b.o_doc.createElement(\\\"div\\\");l.innerHTML=m,b.spaces.normalize(l);for(var o=l.getElementsByTagName(\\\"span\\\"),p=0;p<o.length;p++){var q=o[p];0===q.attributes.length&&(q.outerHTML=q.innerHTML)}var r=l.children;if(1==r.length&&[\\\"OL\\\",\\\"UL\\\"].indexOf(r[0].tagName)&&(r[0].outerHTML=r[0].innerHTML),!h)for(var s=l.getElementsByTagName(\\\"br\\\"),p=0;p<s.length;p++){var t=s[p];b.node.isBlock(t.previousSibling)&&t.parentNode.removeChild(t)}if(b.opts.enter==a.FE.ENTER_BR)for(var u=l.querySelectorAll(\\\"p, div\\\"),p=0;p<u.length;p++){var v=u[p];v.outerHTML=v.innerHTML+(v.nextSibling&&!b.node.isEmpty(v)?\\\"<br>\\\":\\\"\\\")}else if(b.opts.enter==a.FE.ENTER_DIV)for(var u=l.getElementsByTagName(\\\"p\\\"),p=0;p<u.length;p++){var v=u[p];v.outerHTML=\\\"<div>\\\"+v.innerHTML+\\\"</div>\\\"}m=l.innerHTML,b.html.insert(m,!0)}i(),b.undo.saveStep(c),b.undo.saveStep()}function i(){b.events.trigger(\\\"paste.after\\\")}function j(a){var c=b.doc.createElement(\\\"div\\\");c.innerHTML=a;for(var d=c.querySelectorAll(\\\"*:empty:not(br):not(img):not(td):not(th)\\\");d.length;){for(var e=0;e<d.length;e++)d[e].parentNode.removeChild(d[e]);d=c.querySelectorAll(\\\"*:empty:not(br):not(img):not(td):not(th)\\\")}for(var f=c.querySelectorAll(\\\":scope > div:not([style]), td > div, th > div, li > div\\\");f.length;){var g=f[f.length-1];if(b.html.defaultTag()&&\\\"div\\\"!=b.html.defaultTag())g.outerHTML=\\\"<\\\"+b.html.defaultTag()+\\\">\\\"+g.innerHTML+\\\"</\\\"+b.html.defaultTag()+\\\">\\\";else{var h=g.querySelector(\\\"*:last\\\");h&&\\\"BR\\\"==h.tagName?g.outerHTML=g.innerHTML:g.outerHTML=g.innerHTML+\\\"<br>\\\"}f=c.querySelectorAll(\\\":scope > div:not([style]), td > div, th > div, li > div\\\")}for(f=c.querySelectorAll(\\\"div:not([style])\\\");f.length;){for(e=0;e<f.length;e++){var i=f[e],j=i.innerHTML.replace(/\\\\u0009/gi,\\\"\\\").trim();i.outerHTML=j}f=c.querySelectorAll(\\\"div:not([style])\\\")}return c.innerHTML}function k(){b.events.on(\\\"copy\\\",c),b.events.on(\\\"cut\\\",c),b.events.on(\\\"paste\\\",d),b.browser.msie&&b.browser.version<11&&(b.events.on(\\\"mouseup\\\",function(a){2==a.button&&(setTimeout(function(){o=!1},50),o=!0)},!0),b.events.on(\\\"beforepaste\\\",d))}var l,m,n,o=!1;return{_init:k}},a.extend(a.FE.DEFAULTS,{shortcutsEnabled:[\\\"show\\\",\\\"bold\\\",\\\"italic\\\",\\\"underline\\\",\\\"strikeThrough\\\",\\\"indent\\\",\\\"outdent\\\",\\\"undo\\\",\\\"redo\\\"],shortcutsHint:!0}),a.FE.SHORTCUTS_MAP={},a.FE.RegisterShortcut=function(b,c,d,e,f,g){a.FE.SHORTCUTS_MAP[(f?\\\"^\\\":\\\"\\\")+(g?\\\"@\\\":\\\"\\\")+b]={cmd:c,val:d,letter:e,shift:f,option:g},a.FE.DEFAULTS.shortcutsEnabled.push(c)},a.FE.RegisterShortcut(a.FE.KEYCODE.E,\\\"show\\\",null,\\\"E\\\",!1,!1),a.FE.RegisterShortcut(a.FE.KEYCODE.B,\\\"bold\\\",null,\\\"B\\\",!1,!1),a.FE.RegisterShortcut(a.FE.KEYCODE.I,\\\"italic\\\",null,\\\"I\\\",!1,!1),a.FE.RegisterShortcut(a.FE.KEYCODE.U,\\\"underline\\\",null,\\\"U\\\",!1,!1),a.FE.RegisterShortcut(a.FE.KEYCODE.S,\\\"strikeThrough\\\",null,\\\"S\\\",!1,!1),a.FE.RegisterShortcut(a.FE.KEYCODE.CLOSE_SQUARE_BRACKET,\\\"indent\\\",null,\\\"]\\\",!1,!1),a.FE.RegisterShortcut(a.FE.KEYCODE.OPEN_SQUARE_BRACKET,\\\"outdent\\\",null,\\\"[\\\",!1,!1),a.FE.RegisterShortcut(a.FE.KEYCODE.Z,\\\"undo\\\",null,\\\"Z\\\",!1,!1),a.FE.RegisterShortcut(a.FE.KEYCODE.Z,\\\"redo\\\",null,\\\"Z\\\",!0,!1),a.FE.MODULES.shortcuts=function(b){function c(c){if(!b.opts.shortcutsHint)return null;if(!f){f={};for(var d in a.FE.SHORTCUTS_MAP)a.FE.SHORTCUTS_MAP.hasOwnProperty(d)&&b.opts.shortcutsEnabled.indexOf(a.FE.SHORTCUTS_MAP[d].cmd)>=0&&(f[a.FE.SHORTCUTS_MAP[d].cmd+\\\".\\\"+(a.FE.SHORTCUTS_MAP[d].val||\\\"\\\")]={shift:a.FE.SHORTCUTS_MAP[d].shift,option:a.FE.SHORTCUTS_MAP[d].option,letter:a.FE.SHORTCUTS_MAP[d].letter})}var e=f[c];return e?(b.helpers.isMac()?String.fromCharCode(8984):\\\"Ctrl+\\\")+(e.shift?b.helpers.isMac()?String.fromCharCode(8679):\\\"Shift+\\\":\\\"\\\")+(e.option?b.helpers.isMac()?String.fromCharCode(8997):\\\"Alt+\\\":\\\"\\\")+e.letter:null}function d(c){if(!b.core.hasFocus())return!0;var d=c.which,e=navigator.userAgent.indexOf(\\\"Mac OS X\\\")!=-1?c.metaKey:c.ctrlKey;if(\\\"keyup\\\"==c.type&&g&&d!=a.FE.KEYCODE.META)return g=!1,!1;\\\"keydown\\\"==c.type&&(g=!1);var f=(c.shiftKey?\\\"^\\\":\\\"\\\")+(c.altKey?\\\"@\\\":\\\"\\\")+d;if(e&&a.FE.SHORTCUTS_MAP[f]){var h=a.FE.SHORTCUTS_MAP[f].cmd;if(h&&b.opts.shortcutsEnabled.indexOf(h)>=0){var i,j=a.FE.SHORTCUTS_MAP[f].val;if(h&&!j?i=b.$tb.find('.fr-command[data-cmd=\\\"'+h+'\\\"]'):h&&j&&(i=b.$tb.find('.fr-command[data-cmd=\\\"'+h+'\\\"][data-param1=\\\"'+j+'\\\"]')),i.length)return c.preventDefault(),c.stopPropagation(),i.parents(\\\".fr-toolbar\\\").data(\\\"instance\\\",b),\\\"keydown\\\"==c.type&&(b.button.exec(i),g=!0),!1;if(h&&b.commands[h])return c.preventDefault(),c.stopPropagation(),\\\"keydown\\\"==c.type&&(b.commands[h](),g=!0),!1}}}function e(){b.events.on(\\\"keydown\\\",d,!0),b.events.on(\\\"keyup\\\",d,!0)}var f=null,g=!1;return{_init:e,get:c}},a.FE.MODULES.snapshot=function(a){function b(a){for(var b=a.parentNode.childNodes,c=0,d=null,e=0;e<b.length;e++){if(d){var f=b[e].nodeType===Node.TEXT_NODE&&\\\"\\\"===b[e].textContent,g=d.nodeType===Node.TEXT_NODE&&b[e].nodeType===Node.TEXT_NODE;f||g||c++}if(b[e]==a)return c;d=b[e]}}function c(c){var d=[];if(!c.parentNode)return[];for(;!a.node.isElement(c);)d.push(b(c)),c=c.parentNode;return d.reverse()}function d(a,b){for(;a&&a.nodeType===Node.TEXT_NODE;){var c=a.previousSibling;c&&c.nodeType==Node.TEXT_NODE&&(b+=c.textContent.length),a=c}return b}function e(a){return{scLoc:c(a.startContainer),scOffset:d(a.startContainer,a.startOffset),ecLoc:c(a.endContainer),ecOffset:d(a.endContainer,a.endOffset)}}function f(){var b={};if(a.events.trigger(\\\"snapshot.before\\\"),b.html=(a.$wp?a.$el.html():a.$oel.get(0).outerHTML).replace(/ style=\\\"\\\"/g,\\\"\\\"),b.ranges=[],a.$wp&&a.selection.inEditor()&&a.core.hasFocus())for(var c=a.selection.ranges(),d=0;d<c.length;d++)b.ranges.push(e(c[d]));return a.events.trigger(\\\"snapshot.after\\\"),b}function g(b){for(var c=a.el,d=0;d<b.length;d++)c=c.childNodes[b[d]];return c}function h(b,c){try{var d=g(c.scLoc),e=c.scOffset,f=g(c.ecLoc),h=c.ecOffset,i=a.doc.createRange();i.setStart(d,e),i.setEnd(f,h),b.addRange(i)}catch(j){}}function i(b){a.$el.html()!=b.html&&a.$el.html(b.html);var c=a.selection.get();a.selection.clear(),a.events.focus(!0);for(var d=0;d<b.ranges.length;d++)h(c,b.ranges[d])}function j(b,c){return b.html==c.html&&(!a.core.hasFocus()||JSON.stringify(b.ranges)==JSON.stringify(c.ranges))}return{get:f,restore:i,equal:j}},a.FE.MODULES.undo=function(a){function b(b){var c=b.which,d=a.keys.ctrlKey(b);d&&(90==c&&b.shiftKey&&b.preventDefault(),90==c&&b.preventDefault())}function c(){return!(0===a.undo_stack.length||a.undo_index<=1)}function d(){return a.undo_index!=a.undo_stack.length}function e(b){return!(!a.undo_stack||a.undoing||a.el.querySelector(\\\".fr-marker\\\"))&&void(\\\"undefined\\\"==typeof b?(b=a.snapshot.get(),a.undo_stack[a.undo_index-1]&&a.snapshot.equal(a.undo_stack[a.undo_index-1],b)||(f(),a.undo_stack.push(b),a.undo_index++,b.html!=l&&(a.events.trigger(\\\"contentChanged\\\"),l=b.html))):(f(),a.undo_index>0?a.undo_stack[a.undo_index-1]=b:(a.undo_stack.push(b),a.undo_index++)))}function f(){if(!a.undo_stack||a.undoing)return!1;for(;a.undo_stack.length>a.undo_index;)a.undo_stack.pop()}function g(){if(a.undo_index>1){a.undoing=!0;var b=a.undo_stack[--a.undo_index-1];clearTimeout(a._content_changed_timer),a.snapshot.restore(b),l=b.html,a.popups.hideAll(),a.toolbar.enable(),a.events.trigger(\\\"contentChanged\\\"),a.events.trigger(\\\"commands.undo\\\"),a.undoing=!1}}function h(){if(a.undo_index<a.undo_stack.length){a.undoing=!0;var b=a.undo_stack[a.undo_index++];clearTimeout(a._content_changed_timer),a.snapshot.restore(b),l=b.html,a.popups.hideAll(),a.toolbar.enable(),a.events.trigger(\\\"contentChanged\\\"),a.events.trigger(\\\"commands.redo\\\"),a.undoing=!1}}function i(){a.undo_index=0,a.undo_stack=[]}function j(){a.undo_stack=[]}function k(){i(),a.events.on(\\\"initialized\\\",function(){l=(a.$wp?a.$el.html():a.$oel.get(0).outerHTML).replace(/ style=\\\"\\\"/g,\\\"\\\")}),a.events.on(\\\"blur\\\",function(){a.el.querySelector(\\\".fr-dragging\\\")||a.undo.saveStep()}),a.events.on(\\\"keydown\\\",b),a.events.on(\\\"destroy\\\",j)}var l=null;return{_init:k,run:g,redo:h,canDo:c,canRedo:d,dropRedo:f,reset:i,saveStep:e}},a.FE.ICON_DEFAULT_TEMPLATE=\\\"font_awesome\\\",a.FE.ICON_TEMPLATES={font_awesome:'<i class=\\\"fa fa-[NAME]\\\" aria-hidden=\\\"true\\\"></i>',text:'<span style=\\\"text-align: center;\\\">[NAME]</span>',image:\\\"<img src=[SRC] alt=[ALT] />\\\",svg:'<svg viewBox=\\\"0 0 32 32\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\">[PATH]</svg>'},a.FE.ICONS={bold:{NAME:\\\"bold\\\"},italic:{NAME:\\\"italic\\\"},underline:{NAME:\\\"underline\\\"},strikeThrough:{NAME:\\\"strikethrough\\\"},subscript:{NAME:\\\"subscript\\\"},superscript:{NAME:\\\"superscript\\\"},color:{NAME:\\\"tint\\\"},outdent:{NAME:\\\"outdent\\\"},indent:{NAME:\\\"indent\\\"},undo:{NAME:\\\"rotate-left\\\"},redo:{NAME:\\\"rotate-right\\\"},insertHR:{NAME:\\\"minus\\\"},clearFormatting:{NAME:\\\"eraser\\\"},selectAll:{NAME:\\\"mouse-pointer\\\"}},a.FE.DefineIconTemplate=function(b,c){a.FE.ICON_TEMPLATES[b]=c},a.FE.DefineIcon=function(b,c){a.FE.ICONS[b]=c},a.FE.MODULES.icon=function(b){function c(b){var c=null,d=a.FE.ICONS[b];if(\\\"undefined\\\"!=typeof d){var e=d.template||a.FE.ICON_DEFAULT_TEMPLATE;e&&(e=a.FE.ICON_TEMPLATES[e])&&(c=e.replace(/\\\\[([a-zA-Z]*)\\\\]/g,function(a,c){return\\\"NAME\\\"==c?d[c]||b:d[c]}))}return c||b}function d(b){var c=a.FE.ICONS[b],d=a.FE.ICON_DEFAULT_TEMPLATE;if(\\\"undefined\\\"!=typeof c){var d=c.template||a.FE.ICON_DEFAULT_TEMPLATE;return d}return d}return{create:c,getTemplate:d}},a.extend(a.FE.DEFAULTS,{tooltips:!0}),a.FE.MODULES.tooltip=function(b){function c(){b.$tooltip&&b.$tooltip.removeClass(\\\"fr-visible\\\").css(\\\"left\\\",\\\"-3000px\\\").css(\\\"position\\\",\\\"fixed\\\")}function d(c,d){if(c.data(\\\"title\\\")||c.data(\\\"title\\\",c.attr(\\\"title\\\")),!c.data(\\\"title\\\"))return!1;b.$tooltip||f(),c.removeAttr(\\\"title\\\"),b.$tooltip.text(c.data(\\\"title\\\")),b.$tooltip.addClass(\\\"fr-visible\\\");var e=c.offset().left+(c.outerWidth()-b.$tooltip.outerWidth())/2;e<0&&(e=0),e+b.$tooltip.outerWidth()>a(b.o_win).width()&&(e=a(b.o_win).width()-b.$tooltip.outerWidth()),\\\"undefined\\\"==typeof d&&(d=b.opts.toolbarBottom);var g=d?c.offset().top-b.$tooltip.height():c.offset().top+c.outerHeight();b.$tooltip.css(\\\"position\\\",\\\"\\\"),b.$tooltip.css(\\\"left\\\",e),b.$tooltip.css(\\\"top\\\",Math.ceil(g)),\\\"static\\\"!=a(b.o_doc).find(\\\"body\\\").css(\\\"position\\\")?(b.$tooltip.css(\\\"margin-left\\\",-a(b.o_doc).find(\\\"body\\\").offset().left),b.$tooltip.css(\\\"margin-top\\\",-a(b.o_doc).find(\\\"body\\\").offset().top)):(b.$tooltip.css(\\\"margin-left\\\",\\\"\\\"),b.$tooltip.css(\\\"margin-top\\\",\\\"\\\"))}function e(e,f,g){b.opts.tooltips&&!b.helpers.isMobile()&&(b.events.$on(e,\\\"mouseenter\\\",f,function(c){b.node.hasClass(c.currentTarget,\\\"fr-disabled\\\")||b.edit.isDisabled()||d(a(c.currentTarget),g)},!0),b.events.$on(e,\\\"mouseleave \\\"+b._mousedown+\\\" \\\"+b._mouseup,f,function(a){c()},!0))}function f(){b.opts.tooltips&&!b.helpers.isMobile()&&(b.shared.$tooltip?b.$tooltip=b.shared.$tooltip:(b.shared.$tooltip=a('<div class=\\\"fr-tooltip\\\"></div>'),b.$tooltip=b.shared.$tooltip,b.opts.theme&&b.$tooltip.addClass(b.opts.theme+\\\"-theme\\\"),a(b.o_doc).find(\\\"body\\\").append(b.$tooltip)),b.events.on(\\\"shared.destroy\\\",function(){b.$tooltip.html(\\\"\\\").removeData().remove(),b.$tooltip=null},!0))}return{hide:c,to:d,bind:e}},a.FE.MODULES.button=function(b){function c(c){var d=c.next(),e=b.node.hasClass(c.get(0),\\\"fr-active\\\"),f=(b.helpers.isMobile(),a(\\\".fr-dropdown.fr-active\\\").not(c)),g=c.parents(\\\".fr-toolbar, .fr-popup\\\").data(\\\"instance\\\")||b;if(g.helpers.isIOS()&&!g.el.querySelector(\\\".fr-marker\\\")&&(g.selection.save(),g.selection.clear(),g.selection.restore()),!e){var h=c.data(\\\"cmd\\\");d.find(\\\".fr-command\\\").removeClass(\\\"fr-active\\\").attr(\\\"aria-selected\\\",!1),a.FE.COMMANDS[h]&&a.FE.COMMANDS[h].refreshOnShow&&a.FE.COMMANDS[h].refreshOnShow.apply(g,[c,d]),d.css(\\\"left\\\",c.offset().left-c.parent().offset().left-(\\\"rtl\\\"==b.opts.direction?d.width()-c.outerWidth():0)),b.opts.toolbarBottom?d.css(\\\"bottom\\\",b.$tb.height()-c.position().top):d.css(\\\"top\\\",c.position().top+c.outerHeight())}c.addClass(\\\"fr-blink\\\").toggleClass(\\\"fr-active\\\"),c.hasClass(\\\"fr-active\\\")?(d.attr(\\\"aria-hidden\\\",!1),c.attr(\\\"aria-expanded\\\",!0)):(d.attr(\\\"aria-hidden\\\",!0),c.attr(\\\"aria-expanded\\\",!1)),setTimeout(function(){c.removeClass(\\\"fr-blink\\\")},300),d.offset().left+d.outerWidth()>a(b.opts.scrollableContainer).offset().left+a(b.opts.scrollableContainer).outerWidth()&&d.css(\\\"margin-left\\\",-(d.offset().left+d.outerWidth()-a(b.opts.scrollableContainer).offset().left-a(b.opts.scrollableContainer).outerWidth())),f.removeClass(\\\"fr-active\\\").attr(\\\"aria-expanded\\\",!1).next().attr(\\\"aria-hidden\\\",!0),f.parent(\\\".fr-toolbar:not(.fr-inline)\\\").css(\\\"zIndex\\\",\\\"\\\"),0!=c.parents(\\\".fr-popup\\\").length||b.opts.toolbarInline||(b.node.hasClass(c.get(0),\\\"fr-active\\\")?b.$tb.css(\\\"zIndex\\\",(b.opts.zIndex||1)+4):b.$tb.css(\\\"zIndex\\\",\\\"\\\"));var i=d.find(\\\"a.fr-command.fr-active\\\");i.length?b.accessibility.focusToolbarElement(i):b.accessibility.focusToolbarElement(c)}function d(b){b.addClass(\\\"fr-blink\\\"),setTimeout(function(){b.removeClass(\\\"fr-blink\\\")},500);for(var c=b.data(\\\"cmd\\\"),d=[];\\\"undefined\\\"!=typeof b.data(\\\"param\\\"+(d.length+1));)d.push(b.data(\\\"param\\\"+(d.length+1)));var e=a(\\\".fr-dropdown.fr-active\\\");e.length&&(e.removeClass(\\\"fr-active\\\").attr(\\\"aria-expanded\\\",!1).next().attr(\\\"aria-hidden\\\",!0),e.parent(\\\".fr-toolbar:not(.fr-inline)\\\").css(\\\"zIndex\\\",\\\"\\\")),b.parents(\\\".fr-popup, .fr-toolbar\\\").data(\\\"instance\\\").commands.exec(c,d)}function e(a){d(a)}function f(d){var f=d.parents(\\\".fr-popup, .fr-toolbar\\\").data(\\\"instance\\\");if(0!=d.parents(\\\".fr-popup\\\").length||d.data(\\\"popup\\\")||f.popups.hideAll(),f.popups.areVisible()&&!f.popups.areVisible(f)){for(var g=0;g<a.FE.INSTANCES.length;g++)a.FE.INSTANCES[g]!=f&&a.FE.INSTANCES[g].popups&&a.FE.INSTANCES[g].popups.areVisible()&&a.FE.INSTANCES[g].$el.find(\\\".fr-marker\\\").remove();f.popups.hideAll()}b.node.hasClass(d.get(0),\\\"fr-dropdown\\\")?c(d):(e(d),a.FE.COMMANDS[d.data(\\\"cmd\\\")]&&0!=a.FE.COMMANDS[d.data(\\\"cmd\\\")].refreshAfterCallback&&f.button.bulkRefresh())}function g(b){var c=a(b.currentTarget);f(c)}function h(a){var b=a.find(\\\".fr-dropdown.fr-active\\\");b.length&&(b.removeClass(\\\"fr-active\\\").attr(\\\"aria-expanded\\\",!1).next().attr(\\\"aria-hidden\\\",!0),b.parent(\\\".fr-toolbar:not(.fr-inline)\\\").css(\\\"zIndex\\\",\\\"\\\"))}function i(a){a.preventDefault(),a.stopPropagation()}function j(a){if(a.stopPropagation(),!b.helpers.isMobile())return!1}function k(c,d){b.events.bindClick(c,\\\".fr-command:not(.fr-disabled)\\\",g),b.events.$on(c,b._mousedown+\\\" \\\"+b._mouseup+\\\" \\\"+b._move,\\\".fr-dropdown-menu\\\",i,!0),b.events.$on(c,b._mousedown+\\\" \\\"+b._mouseup+\\\" \\\"+b._move,\\\".fr-dropdown-menu .fr-dropdown-wrapper\\\",j,!0);var e=c.get(0).ownerDocument,f=\\\"defaultView\\\"in e?e.defaultView:e.parentWindow,k=function(d){(!d||d.type==b._mouseup&&d.target!=a(\\\"html\\\").get(0)||\\\"keydown\\\"==d.type&&(b.keys.isCharacter(d.which)&&!b.keys.ctrlKey(d)||d.which==a.FE.KEYCODE.ESC))&&h(c)};b.events.$on(a(f),b._mouseup+\\\" resize keydown\\\",k,!0),b.opts.iframe&&b.events.$on(b.$win,b._mouseup,k,!0),b.node.hasClass(c.get(0),\\\"fr-popup\\\")?a.merge(u,c.find(\\\".fr-btn\\\").toArray()):a.merge(t,c.find(\\\".fr-btn\\\").toArray()),b.tooltip.bind(c,\\\".fr-btn, .fr-title\\\",d)}function l(a,c){var d=\\\"\\\";if(c.html)d+=\\\"function\\\"==typeof c.html?c.html.call(b):c.html;else{var e=c.options;\\\"function\\\"==typeof e&&(e=e()),d+='<ul class=\\\"fr-dropdown-list\\\" role=\\\"presentation\\\">';for(var f in e)if(e.hasOwnProperty(f)){var g=b.shortcuts.get(a+\\\".\\\"+f);g=g?'<span class=\\\"fr-shortcut\\\">'+g+\\\"</span>\\\":\\\"\\\",d+='<li role=\\\"presentation\\\"><a class=\\\"fr-command\\\" tabIndex=\\\"-1\\\" role=\\\"option\\\" data-cmd=\\\"'+a+'\\\" data-param1=\\\"'+f+'\\\" title=\\\"'+e[f]+'\\\">'+b.language.translate(e[f])+\\\"</a></li>\\\"}d+=\\\"</ul>\\\"}return d}function m(a,c,d){if(b.helpers.isMobile()&&c.showOnMobile===!1)return\\\"\\\";var e=c.displaySelection;\\\"function\\\"==typeof e&&(e=e(b));var f;if(e){var g=\\\"function\\\"==typeof c.defaultSelection?c.defaultSelection(b):c.defaultSelection;f='<span style=\\\"width:'+(c.displaySelectionWidth||100)+'px\\\">'+(g||b.language.translate(c.title))+\\\"</span>\\\"}else f=b.icon.create(c.icon||a),f+='<span class=\\\"fr-sr-only\\\">'+(b.language.translate(c.title)||\\\"\\\")+\\\"</span>\\\";var h=c.popup?' data-popup=\\\"true\\\"':\\\"\\\",i=c.modal?' data-modal=\\\"true\\\"':\\\"\\\",j=b.shortcuts.get(a+\\\".\\\");j=j?\\\" (\\\"+j+\\\")\\\":\\\"\\\";var k=a+\\\"-\\\"+b.id,m='<button id=\\\"'+k+'\\\"type=\\\"button\\\" tabIndex=\\\"-1\\\" role=\\\"button\\\"'+(c.toggle?' aria-pressed=\\\"false\\\"':\\\"\\\")+(\\\"dropdown\\\"==c.type?' aria-controls=\\\"drop\\\" aria-expanded=\\\"false\\\" aria-haspopup=\\\"true\\\"':\\\"\\\")+(c.disabled?' aria-disabled=\\\"true\\\"':\\\"\\\")+' title=\\\"'+(b.language.translate(c.title)||\\\"\\\")+j+'\\\" class=\\\"fr-command fr-btn'+(\\\"dropdown\\\"==c.type?\\\" fr-dropdown\\\":\\\"\\\")+(\\\" fr-btn-\\\"+b.icon.getTemplate(c.icon))+(c.displaySelection?\\\" fr-selection\\\":\\\"\\\")+(c.back?\\\" fr-back\\\":\\\"\\\")+(c.disabled?\\\" fr-disabled\\\":\\\"\\\")+(d?\\\"\\\":\\\" fr-hidden\\\")+'\\\" data-cmd=\\\"'+a+'\\\"'+h+i+\\\">\\\"+f+\\\"</button>\\\";if(\\\"dropdown\\\"==c.type){var n='<div class=\\\"fr-dropdown-menu\\\" role=\\\"listbox\\\" aria-labelledby=\\\"'+k+'\\\" aria-hidden=\\\"true\\\"><div class=\\\"fr-dropdown-wrapper\\\" role=\\\"presentation\\\"><div class=\\\"fr-dropdown-content\\\" role=\\\"presentation\\\">';n+=l(a,c),n+=\\\"</div></div></div>\\\",m+=n}return m}function n(c,d){for(var e=\\\"\\\",f=0;f<c.length;f++){var g=c[f],h=a.FE.COMMANDS[g];if(!(h&&\\\"undefined\\\"!=typeof h.plugin&&b.opts.pluginsEnabled.indexOf(h.plugin)<0))if(h){var i=\\\"undefined\\\"==typeof d||d.indexOf(g)>=0;e+=m(g,h,i)}else\\\"|\\\"==g?e+='<div class=\\\"fr-separator fr-vs\\\" role=\\\"separator\\\" aria-orientation=\\\"vertical\\\"></div>':\\\"-\\\"==g&&(e+='<div class=\\\"fr-separator fr-hs\\\" role=\\\"separator\\\" aria-orientation=\\\"horizontal\\\"></div>')}return e}function o(c){var d,e=c.parents(\\\".fr-popup, .fr-toolbar\\\").data(\\\"instance\\\")||b,f=c.data(\\\"cmd\\\");b.node.hasClass(c.get(0),\\\"fr-dropdown\\\")?d=c.next():(c.removeClass(\\\"fr-active\\\"),c.attr(\\\"aria-pressed\\\")&&c.attr(\\\"aria-pressed\\\",!1)),a.FE.COMMANDS[f]&&a.FE.COMMANDS[f].refresh?a.FE.COMMANDS[f].refresh.apply(e,[c,d]):b.refresh[f]&&e.refresh[f](c,d)}function p(c){var d=b.$tb?b.$tb.data(\\\"instance\\\")||b:b;return 0==b.events.trigger(\\\"buttons.refresh\\\")||void setTimeout(function(){for(var e=d.selection.inEditor()&&d.core.hasFocus(),f=0;f<c.length;f++){var g=a(c[f]),h=g.data(\\\"cmd\\\");0==g.parents(\\\".fr-popup\\\").length?e||a.FE.COMMANDS[h]&&a.FE.COMMANDS[h].forcedRefresh?d.button.refresh(g):b.node.hasClass(g.get(0),\\\"fr-dropdown\\\")||(g.removeClass(\\\"fr-active\\\"),g.attr(\\\"aria-pressed\\\")&&g.attr(\\\"aria-pressed\\\",!1)):g.parents(\\\".fr-popup\\\").is(\\\":visible\\\")&&d.button.refresh(g)}},0)}function q(){p(t),p(u)}function r(){t=[],u=[]}function s(){b.opts.toolbarInline?b.events.on(\\\"toolbar.show\\\",q):(b.events.on(\\\"mouseup\\\",q),b.events.on(\\\"keyup\\\",q),b.events.on(\\\"blur\\\",q),b.events.on(\\\"focus\\\",q),b.events.on(\\\"contentChanged\\\",q)),b.events.on(\\\"shared.destroy\\\",r)}var t=[];(b.opts.toolbarInline||b.opts.toolbarContainer)&&(b.shared.buttons||(b.shared.buttons=[]),t=b.shared.buttons);var u=[];return b.shared.popup_buttons||(b.shared.popup_buttons=[]),u=b.shared.popup_buttons,{_init:s,buildList:n,bindCommands:k,refresh:o,bulkRefresh:q,exec:d,click:f}},a.FE.MODULES.modals=function(b){function c(a){return n[a]}function d(c,d){var e='<div tabIndex=\\\"-1\\\" class=\\\"fr-modal'+(b.opts.theme?\\\" \\\"+b.opts.theme+\\\"-theme\\\":\\\"\\\")+'\\\"><div class=\\\"fr-modal-wrapper\\\">',f='<i title=\\\"'+b.language.translate(\\\"Cancel\\\")+'\\\" class=\\\"fa fa-times fr-modal-close\\\"></i>';return e+='<div class=\\\"fr-modal-head\\\">'+c+f+\\\"</div>\\\",e+='<div tabIndex=\\\"-1\\\" class=\\\"fr-modal-body\\\">'+d+\\\"</div>\\\",e+=\\\"</div></div>\\\",a(e)}function e(c,e,f){if(b.shared.$overlay||(b.shared.$overlay=a('<div class=\\\"fr-overlay\\\">').appendTo(\\\"body\\\")),m=b.shared.$overlay,b.opts.theme&&m.addClass(b.opts.theme+\\\"-theme\\\"),!n[c]){var g=d(e,f);n[c]={$modal:g,$head:g.find(\\\".fr-modal-head\\\"),$body:g.find(\\\".fr-modal-body\\\")},b.helpers.isMobile()||g.addClass(\\\"fr-desktop\\\"),g.appendTo(\\\"body\\\"),b.events.bindClick(g,\\\"i.fr-modal-close\\\",function(){h(c)}),n[c].$body.css(\\\"margin-top\\\",n[c].$head.outerHeight()),b.events.$on(g,\\\"keydown\\\",function(d){var e=d.which;return e==a.FE.KEYCODE.ESC?(h(c),b.accessibility.focusModalButton(g),!1):!(!a(d.currentTarget).is(\\\"input[type=text], textarea\\\")&&e!=a.FE.KEYCODE.ARROW_UP&&e!=a.FE.KEYCODE.ARROW_DOWN)||(d.preventDefault(),d.stopPropagation(),!1)},!0),h(c)}return n[c]}function f(){for(var a in n){var b=n[a];b&&b.$modal&&b.$modal.removeData().remove()}m&&m.removeData().remove(),n={}}function g(a){if(n[a]){var c=n[a].$modal;c.data(\\\"instance\\\",b),c.show(),m.show(),b.$doc.find(\\\"body\\\").addClass(\\\"prevent-scroll\\\"),b.helpers.isMobile()&&b.$doc.find(\\\"body\\\").addClass(\\\"fr-mobile\\\"),c.addClass(\\\"fr-active\\\"),b.core.hasFocus()||(b.events.disableBlur(),b.events.focus()),b.accessibility.saveSelection(),b.events.disableBlur(),b.$el.blur(),b.selection.clear(),b.events.disableBlur(),c.find(\\\"[tabIndex]:first\\\").focus()}}function h(a){if(n[a]){var c=n[a].$modal,d=c.data(\\\"instance\\\")||b;d.events.enableBlur(),c.hide(),m.hide(),d.$doc.find(\\\"body\\\").removeClass(\\\"prevent-scroll fr-mobile\\\"),c.removeClass(\\\"fr-active\\\"),b.accessibility.restoreSelection(d)}}function i(a){if(n[a]){var c=n[a],d=c.$modal,e=c.$body,f=b.$win.height(),g=d.find(\\\".fr-modal-wrapper\\\"),h=g.outerHeight(!0),i=g.height()-(e.outerHeight(!0)-e.height()),j=f-h+i,k=e.get(0).scrollHeight,l=\\\"auto\\\";k>j&&(l=j),e.height(l)}}function j(a){var c;if(\\\"string\\\"==typeof a){if(!n[a])return;c=n[a].$modal}else c=a;return c&&b.node.hasClass(c,\\\"fr-active\\\")&&b.core.sameInstance(c)||!1}function k(a){for(var b in n)if(n.hasOwnProperty(b)&&j(b)&&(\\\"undefined\\\"==typeof a||n[b].$modal.data(\\\"instance\\\")==a))return n[b].$modal;return!1}function l(){b.events.on(\\\"shared.destroy\\\",f,!0)}b.shared.modals||(b.shared.modals={});var m,n=b.shared.modals;return{_init:l,get:c,create:e,show:g,hide:h,resize:i,isVisible:j,areVisible:k}},a.FE.POPUP_TEMPLATES={\\\"text.edit\\\":\\\"[_EDIT_]\\\"},a.FE.RegisterTemplate=function(b,c){a.FE.POPUP_TEMPLATES[b]=c},a.FE.MODULES.popups=function(b){function c(c,d){d.is(\\\":visible\\\")||(d=a(b.opts.scrollableContainer)),d.is(x[c].data(\\\"container\\\"))||(x[c].data(\\\"container\\\",d),d.append(x[c]))}function d(d,e,h,i){if(g()&&b.$el.find(\\\".fr-marker\\\").length>0?(b.events.disableBlur(),b.selection.restore()):(b.events.disableBlur(),b.events.focus()),m([d]),!x[d])return!1;var j=a(\\\".fr-dropdown.fr-active\\\");j.removeClass(\\\"fr-active\\\").attr(\\\"aria-expanded\\\",!1).parent(\\\".fr-toolbar\\\").css(\\\"zIndex\\\",\\\"\\\"),j.next().attr(\\\"aria-hidden\\\",!0),x[d].data(\\\"instance\\\",b),b.$tb&&b.$tb.data(\\\"instance\\\",b);var k=x[d].outerWidth(),l=(x[d].outerHeight(),f(d));x[d].addClass(\\\"fr-active\\\").removeClass(\\\"fr-hidden\\\").find(\\\"input, textarea\\\").removeAttr(\\\"disabled\\\");var n=x[d].data(\\\"container\\\");b.opts.toolbarInline&&n&&b.$tb&&n.get(0)==b.$tb.get(0)&&(c(d,a(b.opts.scrollableContainer)),h=b.$tb.offset().top-b.helpers.getPX(b.$tb.css(\\\"margin-top\\\")),e=b.$tb.offset().left+b.$tb.outerWidth()/2+(parseFloat(b.$tb.find(\\\".fr-arrow\\\").css(\\\"margin-left\\\"))||0)+b.$tb.find(\\\".fr-arrow\\\").outerWidth()/2,b.node.hasClass(b.$tb.get(0),\\\"fr-above\\\")&&h&&(h+=b.$tb.outerHeight()),i=0),n=x[d].data(\\\"container\\\"),!b.opts.iframe||i||l||(e&&(e-=b.$iframe.offset().left),h&&(h-=b.$iframe.offset().top)),n.is(b.$tb)?b.$tb.css(\\\"zIndex\\\",(b.opts.zIndex||1)+4):x[d].css(\\\"zIndex\\\",(b.opts.zIndex||1)+4),e&&(e-=k/2),b.opts.toolbarBottom&&n&&b.$tb&&n.get(0)==b.$tb.get(0)&&(x[d].addClass(\\\"fr-above\\\"),h&&(h-=x[d].outerHeight())),x[d].removeClass(\\\"fr-active\\\"),b.position.at(e,h,x[d],i||0),x[d].addClass(\\\"fr-active\\\"),l||b.accessibility.focusPopup(x[d]),b.opts.toolbarInline&&b.toolbar.hide(),b.events.trigger(\\\"popups.show.\\\"+d),s(d)._repositionPopup(),o()}function e(a,c){b.events.on(\\\"popups.show.\\\"+a,c)}function f(a){return x[a]&&b.node.hasClass(x[a],\\\"fr-active\\\")&&b.core.sameInstance(x[a])||!1}function g(a){for(var b in x)if(x.hasOwnProperty(b)&&f(b)&&(\\\"undefined\\\"==typeof a||x[b].data(\\\"instance\\\")==a))return x[b];return!1}function h(a){var c=null;c=\\\"string\\\"!=typeof a?a:x[a],c&&b.node.hasClass(c,\\\"fr-active\\\")&&(c.removeClass(\\\"fr-active fr-above\\\"),b.events.trigger(\\\"popups.hide.\\\"+a),b.$tb&&(b.opts.zIndex>1?b.$tb.css(\\\"zIndex\\\",b.opts.zIndex+1):b.$tb.css(\\\"zIndex\\\",\\\"\\\")),b.events.disableBlur(),c.find(\\\"input, textarea, button\\\").filter(\\\":focus\\\").blur(),c.find(\\\"input, textarea\\\").attr(\\\"disabled\\\",\\\"disabled\\\"))}function i(a,c){b.events.on(\\\"popups.hide.\\\"+a,c)}function j(a){var c=x[a];if(c&&!c.data(\\\"inst\\\"+b.id)){var d=s(a);t(d,a)}return c}function k(a,c){b.events.on(\\\"popups.refresh.\\\"+a,c)}function l(c){b.events.trigger(\\\"popups.refresh.\\\"+c);for(var d=x[c].find(\\\".fr-command\\\"),e=0;e<d.length;e++){var f=a(d[e]);0==f.parents(\\\".fr-dropdown-menu\\\").length&&b.button.refresh(f)}}function m(a){\\\"undefined\\\"==typeof a&&(a=[]);for(var b in x)x.hasOwnProperty(b)&&a.indexOf(b)<0&&h(b)}function n(){b.shared.exit_flag=!0}function o(){b.shared.exit_flag=!1}function p(){return b.shared.exit_flag}function q(c,d){var e=a.FE.POPUP_TEMPLATES[c];\\\"function\\\"==typeof e&&(e=e.apply(b));for(var f in d)d.hasOwnProperty(f)&&(e=e.replace(\\\"[_\\\"+f.toUpperCase()+\\\"_]\\\",d[f]));return e}function r(c,d){var e=q(c,d),f=a('<div class=\\\"fr-popup'+(b.helpers.isMobile()?\\\" fr-mobile\\\":\\\" fr-desktop\\\")+(b.opts.toolbarInline?\\\" fr-inline\\\":\\\"\\\")+'\\\"><span class=\\\"fr-arrow\\\"></span>'+e+\\\"</div>\\\");b.opts.theme&&f.addClass(b.opts.theme+\\\"-theme\\\"),b.opts.zIndex>1&&b.$tb.css(\\\"z-index\\\",b.opts.zIndex+2),\\\"auto\\\"!=b.opts.direction&&f.removeClass(\\\"fr-ltr fr-rtl\\\").addClass(\\\"fr-\\\"+b.opts.direction),f.find(\\\"input, textarea\\\").attr(\\\"dir\\\",b.opts.direction).attr(\\\"disabled\\\",\\\"disabled\\\");var g=a(\\\"body\\\");return g.append(f),f.data(\\\"container\\\",g),x[c]=f,b.button.bindCommands(f,!1),f}function s(c){var d=x[c];return{_windowResize:function(){var a=d.data(\\\"instance\\\")||b;!a.helpers.isMobile()&&d.is(\\\":visible\\\")&&(a.events.disableBlur(),a.popups.hide(c),a.events.enableBlur())},_inputFocus:function(c){var e=d.data(\\\"instance\\\")||b,f=a(c.currentTarget);if(f.is(\\\"input:file\\\")&&f.closest(\\\".fr-layer\\\").addClass(\\\"fr-input-focus\\\"),c.preventDefault(),c.stopPropagation(),setTimeout(function(){e.events.enableBlur()},0),e.helpers.isMobile()){var g=a(e.o_win).scrollTop();setTimeout(function(){a(e.o_win).scrollTop(g)},0)}},_inputBlur:function(c){var e=d.data(\\\"instance\\\")||b,f=a(c.currentTarget);f.is(\\\"input:file\\\")&&f.closest(\\\".fr-layer\\\").removeClass(\\\"fr-input-focus\\\"),document.activeElement!=this&&a(this).is(\\\":visible\\\")&&(e.events.blurActive()&&e.events.trigger(\\\"blur\\\"),e.events.enableBlur())},_editorKeydown:function(e){var g=d.data(\\\"instance\\\")||b;g.keys.ctrlKey(e)||e.which==a.FE.KEYCODE.ALT||e.which==a.FE.KEYCODE.ESC||(f(c)&&d.find(\\\".fr-back:visible\\\").length?g.button.exec(d.find(\\\".fr-back:visible:first\\\")):e.which!=a.FE.KEYCODE.ALT&&g.popups.hide(c))},_preventFocus:function(c){var e=d.data(\\\"instance\\\")||b;e.events.disableBlur();var f=c.originalEvent?c.originalEvent.target||c.originalEvent.originalTarget:null,g=\\\"input, textarea, button, select, label, .fr-command\\\";return f&&!a(f).is(g)&&0===a(f).parents(g).length?(c.stopPropagation(),!1):(f&&a(f).is(g)&&c.stopPropagation(),void o())},_editorMouseup:function(a){d.is(\\\":visible\\\")&&p()&&d.find(\\\"input:focus, textarea:focus, button:focus, select:focus\\\").filter(\\\":visible\\\").length>0&&b.events.disableBlur()},_windowMouseup:function(a){if(!b.core.sameInstance(d))return!0;var e=d.data(\\\"instance\\\")||b;d.is(\\\":visible\\\")&&p()&&(a.stopPropagation(),e.markers.remove(),e.popups.hide(c),o())},_windowKeydown:function(e){if(!b.core.sameInstance(d))return!0;var f=d.data(\\\"instance\\\")||b,g=e.which;if(a.FE.KEYCODE.ESC==g){if(f.popups.isVisible(c)&&f.opts.toolbarInline)return e.stopPropagation(),f.popups.isVisible(c)&&(d.find(\\\".fr-back:visible\\\").length?(f.button.exec(d.find(\\\".fr-back:visible:first\\\")),f.accessibility.focusPopupButton(d)):d.find(\\\".fr-dismiss:visible\\\").length?f.button.exec(d.find(\\\".fr-dismiss:visible:first\\\")):(f.popups.hide(c),f.toolbar.showInline(null,!0),f.accessibility.FocusPopupButton(d))),!1;if(f.popups.isVisible(c))return d.find(\\\".fr-back:visible\\\").length?(f.button.exec(d.find(\\\".fr-back:visible:first\\\")),f.accessibility.focusPopupButton(d)):d.find(\\\".fr-dismiss:visible\\\").length?f.button.exec(d.find(\\\".fr-dismiss:visible:first\\\")):(f.popups.hide(c),f.accessibility.focusPopupButton(d)),!1}},_doPlaceholder:function(b){var c=a(this).next();0==c.length&&a(this).attr(\\\"placeholder\\\")&&a(this).after('<label for=\\\"'+a(this).attr(\\\"id\\\")+'\\\">'+a(this).attr(\\\"placeholder\\\")+\\\"</label>\\\"),a(this).toggleClass(\\\"fr-not-empty\\\",\\\"\\\"!=a(this).val())},_repositionPopup:function(e){if(!b.opts.height&&!b.opts.heightMax||b.opts.toolbarInline)return!0;if(b.$wp&&f(c)&&d.parent().get(0)==a(b.opts.scrollableContainer).get(0)){var g=d.offset().top-b.$wp.offset().top,h=b.$wp.outerHeight();b.node.hasClass(d.get(0),\\\"fr-above\\\")&&(g+=d.outerHeight()),g>h||g<0?d.addClass(\\\"fr-hidden\\\"):d.removeClass(\\\"fr-hidden\\\")}}}}function t(a,c){b.events.on(\\\"mouseup\\\",a._editorMouseup,!0),b.$wp&&b.events.on(\\\"keydown\\\",a._editorKeydown),b.events.on(\\\"blur\\\",function(a){g()&&b.markers.remove(),m()}),b.$wp&&!b.helpers.isMobile()&&b.events.$on(b.$wp,\\\"scroll.popup\\\"+c,a._repositionPopup),b.events.on(\\\"window.mouseup\\\",a._windowMouseup,!0),b.events.on(\\\"window.keydown\\\",a._windowKeydown,!0),x[c].data(\\\"inst\\\"+b.id,!0),b.events.on(\\\"destroy\\\",function(){b.core.sameInstance(x[c])&&x[c].removeClass(\\\"fr-active\\\").appendTo(\\\"body\\\")},!0)}function u(c,d){var e=r(c,d),f=s(c);return t(f,c),b.events.$on(e,\\\"mousedown mouseup touchstart touchend touch\\\",\\\"*\\\",f._preventFocus,!0),b.events.$on(e,\\\"focus\\\",\\\"input, textarea, button, select\\\",f._inputFocus,!0),b.events.$on(e,\\\"blur\\\",\\\"input, textarea, button, select\\\",f._inputBlur,!0),b.accessibility.registerPopup(c),b.events.$on(e,\\\"keydown keyup change input\\\",\\\"input, textarea\\\",f._doPlaceholder,!0),b.helpers.isIOS()&&b.events.$on(e,\\\"touchend\\\",\\\"label\\\",function(){a(\\\"#\\\"+a(this).attr(\\\"for\\\")).prop(\\\"checked\\\",function(a,b){return!b})},!0),b.events.$on(a(b.o_win),\\\"resize\\\",f._windowResize,!0),e}function v(){for(var a in x)if(x.hasOwnProperty(a)){var b=x[a];b.html(\\\"\\\").removeData().remove(),x[a]=null}x=[]}function w(){b.events.on(\\\"shared.destroy\\\",v,!0),b.events.on(\\\"window.mousedown\\\",n),b.events.on(\\\"window.touchmove\\\",o),b.events.on(\\\"mousedown\\\",function(a){\\ng()&&(a.stopPropagation(),b.$el.find(\\\".fr-marker\\\").remove(),n(),b.events.disableBlur())})}b.shared.popups||(b.shared.popups={});var x=b.shared.popups;return b.shared.exit_flag=!1,{_init:w,create:u,get:j,show:d,hide:h,onHide:i,hideAll:m,setContainer:c,refresh:l,onRefresh:k,onShow:e,isVisible:f,areVisible:g}},a.FE.MODULES.position=function(b){function c(){var c,d=b.selection.ranges(0);if(d&&d.collapsed&&b.selection.inEditor()){var e=!1;0==b.$el.find(\\\".fr-marker\\\").length&&(b.selection.save(),e=!0);var f=b.$el.find(\\\".fr-marker:first\\\");f.css(\\\"display\\\",\\\"inline\\\"),f.css(\\\"line-height\\\",\\\"\\\");var g=f.offset(),h=f.outerHeight();f.css(\\\"display\\\",\\\"none\\\"),f.css(\\\"line-height\\\",0),c={},c.left=g.left,c.width=0,c.height=h,c.top=g.top-(b.helpers.isIOS()?0:a(b.o_win).scrollTop()),c.right=1,c.bottom=1,c.ok=!0,e&&b.selection.restore()}else d&&(c=d.getBoundingClientRect());return c}function d(c,d,e){var f=c.outerHeight();if(!b.helpers.isMobile()&&b.$tb&&c.parent().get(0)!=b.$tb.get(0)){var g=(c.parent().height()-20-(b.opts.toolbarBottom?b.$tb.outerHeight():0),c.parent().offset().top),h=d-f-(e||0);c.parent().get(0)==a(b.opts.scrollableContainer).get(0)&&(g-=c.parent().position().top);var i=a(b.opts.scrollableContainer).get(0).scrollHeight;g+d+f>a(b.opts.scrollableContainer).offset().top+i&&c.parent().offset().top+h>0?(d=h,c.addClass(\\\"fr-above\\\")):c.removeClass(\\\"fr-above\\\")}return d}function e(c,d){var e=c.outerWidth();return d+e>a(b.opts.scrollableContainer).width()-10&&(d=a(b.opts.scrollableContainer).width()-e-10),d<0&&(d=10),d}function f(d){var e=c();d.css(\\\"top\\\",0).css(\\\"left\\\",0);var f=e.top+e.height,h=e.left+e.width/2-d.outerWidth()/2+a(b.o_win).scrollLeft();b.opts.iframe||(f+=a(b.o_win).scrollTop()),g(h,f,d,e.height)}function g(a,c,f,g){var h=f.data(\\\"container\\\");!h||h.is(\\\"body\\\")&&\\\"static\\\"==h.css(\\\"position\\\")||(a&&(a-=h.offset().left),c&&(c-=h.offset().top),\\\"BODY\\\"!=h.get(0).tagName?(a&&(a+=h.scrollLeft()),c&&(c+=h.scrollTop())):\\\"absolute\\\"==h.css(\\\"position\\\")&&(a&&(a+=h.position().left),c&&(c+=h.position().top))),b.opts.iframe&&h&&b.$tb&&h.get(0)!=b.$tb.get(0)&&(a&&(a+=b.$iframe.offset().left),c&&(c+=b.$iframe.offset().top));var i=e(f,a);if(a){f.css(\\\"left\\\",i);var j=f.find(\\\".fr-arrow\\\");j.data(\\\"margin-left\\\")||j.data(\\\"margin-left\\\",b.helpers.getPX(j.css(\\\"margin-left\\\"))),j.css(\\\"margin-left\\\",a-i+j.data(\\\"margin-left\\\"))}c&&f.css(\\\"top\\\",d(f,c,g))}function h(c){var d=a(c),e=d.is(\\\".fr-sticky-on\\\"),f=d.data(\\\"sticky-top\\\"),g=d.data(\\\"sticky-scheduled\\\");if(\\\"undefined\\\"==typeof f){d.data(\\\"sticky-top\\\",0);var h=a('<div class=\\\"fr-sticky-dummy\\\" style=\\\"height: '+d.outerHeight()+'px;\\\"></div>');b.$box.prepend(h)}else b.$box.find(\\\".fr-sticky-dummy\\\").css(\\\"height\\\",d.outerHeight());if(b.core.hasFocus()||b.$tb.find(\\\"input:visible:focus\\\").length>0){var i=a(window).scrollTop(),j=Math.min(Math.max(i-b.$tb.parent().offset().top,0),b.$tb.parent().outerHeight()-d.outerHeight());j!=f&&j!=g&&(clearTimeout(d.data(\\\"sticky-timeout\\\")),d.data(\\\"sticky-scheduled\\\",j),d.outerHeight()<i-b.$tb.parent().offset().top&&d.addClass(\\\"fr-opacity-0\\\"),d.data(\\\"sticky-timeout\\\",setTimeout(function(){var c=a(window).scrollTop(),e=Math.min(Math.max(c-b.$tb.parent().offset().top,0),b.$tb.parent().outerHeight()-d.outerHeight());e>0&&\\\"BODY\\\"==b.$tb.parent().get(0).tagName&&(e+=b.$tb.parent().position().top),e!=f&&(d.css(\\\"top\\\",Math.max(e,0)),d.data(\\\"sticky-top\\\",e),d.data(\\\"sticky-scheduled\\\",e)),d.removeClass(\\\"fr-opacity-0\\\")},100))),e||(d.css(\\\"top\\\",\\\"0\\\"),d.width(b.$tb.parent().width()),d.addClass(\\\"fr-sticky-on\\\"),b.$box.addClass(\\\"fr-sticky-box\\\"))}else clearTimeout(a(c).css(\\\"sticky-timeout\\\")),d.css(\\\"top\\\",\\\"0\\\"),d.css(\\\"position\\\",\\\"\\\"),d.width(\\\"\\\"),d.data(\\\"sticky-top\\\",0),d.removeClass(\\\"fr-sticky-on\\\"),b.$box.removeClass(\\\"fr-sticky-box\\\")}function i(c){if(c.offsetWidth){var d,e,f=a(c),g=f.outerHeight(),h=f.data(\\\"sticky-position\\\"),i=a(\\\"body\\\"==b.opts.scrollableContainer?b.o_win:b.opts.scrollableContainer).outerHeight(),j=0,k=0;\\\"body\\\"!==b.opts.scrollableContainer&&(j=a(b.opts.scrollableContainer).offset().top,k=a(b.o_win).outerHeight()-j-i);var l=\\\"body\\\"==b.opts.scrollableContainer?a(b.o_win).scrollTop():j,m=f.is(\\\".fr-sticky-on\\\");f.data(\\\"sticky-parent\\\")||f.data(\\\"sticky-parent\\\",f.parent());var n=f.data(\\\"sticky-parent\\\"),o=n.offset().top,p=n.outerHeight();if(f.data(\\\"sticky-offset\\\")||(f.data(\\\"sticky-offset\\\",!0),f.after('<div class=\\\"fr-sticky-dummy\\\" style=\\\"height: '+g+'px;\\\"></div>')),!h){var q=\\\"auto\\\"!==f.css(\\\"top\\\")||\\\"auto\\\"!==f.css(\\\"bottom\\\");q||f.css(\\\"position\\\",\\\"fixed\\\"),h={top:b.node.hasClass(f.get(0),\\\"fr-top\\\"),bottom:b.node.hasClass(f.get(0),\\\"fr-bottom\\\")},q||f.css(\\\"position\\\",\\\"\\\"),f.data(\\\"sticky-position\\\",h),f.data(\\\"top\\\",b.node.hasClass(f.get(0),\\\"fr-top\\\")?f.css(\\\"top\\\"):\\\"auto\\\"),f.data(\\\"bottom\\\",b.node.hasClass(f.get(0),\\\"fr-bottom\\\")?f.css(\\\"bottom\\\"):\\\"auto\\\")}var r=function(){return o<l+d&&o+p-g>=l+d},s=function(){return o+g<l+i-e&&o+p>l+i-e};d=b.helpers.getPX(f.data(\\\"top\\\")),e=b.helpers.getPX(f.data(\\\"bottom\\\"));var t=h.top&&r(),u=h.bottom&&s();t||u?(f.css(\\\"width\\\",n.width()+\\\"px\\\"),m||(f.addClass(\\\"fr-sticky-on\\\"),f.removeClass(\\\"fr-sticky-off\\\"),f.css(\\\"top\\\")&&(\\\"auto\\\"!=f.data(\\\"top\\\")?f.css(\\\"top\\\",b.helpers.getPX(f.data(\\\"top\\\"))+j):f.data(\\\"top\\\",\\\"auto\\\")),f.css(\\\"bottom\\\")&&(\\\"auto\\\"!=f.data(\\\"bottom\\\")?f.css(\\\"bottom\\\",b.helpers.getPX(f.data(\\\"bottom\\\"))+k):f.css(\\\"bottom\\\",\\\"auto\\\")))):b.node.hasClass(f.get(0),\\\"fr-sticky-off\\\")||(f.width(\\\"\\\"),f.removeClass(\\\"fr-sticky-on\\\"),f.addClass(\\\"fr-sticky-off\\\"),f.css(\\\"top\\\")&&\\\"auto\\\"!=f.data(\\\"top\\\")&&h.top&&f.css(\\\"top\\\",0),f.css(\\\"bottom\\\")&&\\\"auto\\\"!=f.data(\\\"bottom\\\")&&h.bottom&&f.css(\\\"bottom\\\",0))}}function j(){var a=document.createElement(\\\"test\\\"),c=a.style;return c.cssText=\\\"position:\\\"+[\\\"-webkit-\\\",\\\"-moz-\\\",\\\"-ms-\\\",\\\"-o-\\\",\\\"\\\"].join(\\\"sticky; position:\\\")+\\\" sticky;\\\",c.position.indexOf(\\\"sticky\\\")!==-1&&!b.helpers.isIOS()&&!b.helpers.isAndroid()}function k(){if(!j())if(b._stickyElements=[],b.helpers.isIOS()){var c=function(){b.helpers.requestAnimationFrame()(c);for(var a=0;a<b._stickyElements.length;a++)h(b._stickyElements[a])};c(),b.events.$on(a(b.o_win),\\\"scroll\\\",function(){if(b.core.hasFocus())for(var c=0;c<b._stickyElements.length;c++){var d=a(b._stickyElements[c]),e=d.parent(),f=a(window).scrollTop();d.outerHeight()<f-e.offset().top&&(d.addClass(\\\"fr-opacity-0\\\"),d.data(\\\"sticky-top\\\",-1),d.data(\\\"sticky-scheduled\\\",-1))}},!0)}else b.events.$on(a(\\\"body\\\"==b.opts.scrollableContainer?b.o_win:b.opts.scrollableContainer),\\\"scroll\\\",l,!0),b.events.$on(a(b.o_win),\\\"resize\\\",l,!0),b.events.on(\\\"initialized\\\",l),b.events.on(\\\"focus\\\",l),b.events.$on(a(b.o_win),\\\"resize\\\",\\\"textarea\\\",l,!0);b.events.on(\\\"destroy\\\",function(a){b._stickyElements=[]})}function l(){for(var a=0;a<b._stickyElements.length;a++)i(b._stickyElements[a])}function m(a){a.addClass(\\\"fr-sticky\\\"),b.helpers.isIOS()&&a.addClass(\\\"fr-sticky-ios\\\"),j()||b._stickyElements.push(a.get(0))}function n(){k()}return{_init:n,forSelection:f,addSticky:m,refresh:l,at:g,getBoundingRect:c}},a.FE.MODULES.refresh=function(b){function c(a){g(a,!b.undo.canDo())}function d(a){g(a,!b.undo.canRedo())}function e(a){if(b.node.hasClass(a.get(0),\\\"fr-no-refresh\\\"))return!1;for(var c=b.selection.blocks(),d=0;d<c.length;d++){for(var e=c[d].previousSibling;e&&e.nodeType==Node.TEXT_NODE&&0===e.textContent.length;)e=e.previousSibling;if(\\\"LI\\\"!=c[d].tagName||e)return g(a,!1),!0;g(a,!0)}}function f(c){if(b.node.hasClass(c.get(0),\\\"fr-no-refresh\\\"))return!1;for(var d=b.selection.blocks(),e=0;e<d.length;e++){var f=\\\"rtl\\\"==b.opts.direction||\\\"rtl\\\"==a(d[e]).css(\\\"direction\\\")?\\\"margin-right\\\":\\\"margin-left\\\";if(\\\"LI\\\"==d[e].tagName||\\\"LI\\\"==d[e].parentNode.tagName)return g(c,!1),!0;if(b.helpers.getPX(a(d[e]).css(f))>0)return g(c,!1),!0}g(c,!0)}function g(a,b){a.toggleClass(\\\"fr-disabled\\\",b).attr(\\\"aria-disabled\\\",b)}return{undo:c,redo:d,outdent:f,indent:e}},a.extend(a.FE.DEFAULTS,{editInPopup:!1}),a.FE.MODULES.textEdit=function(b){function c(){var a='<div id=\\\"fr-text-edit-'+b.id+'\\\" class=\\\"fr-layer fr-text-edit-layer\\\"><div class=\\\"fr-input-line\\\"><input type=\\\"text\\\" placeholder=\\\"'+b.language.translate(\\\"Text\\\")+'\\\" tabIndex=\\\"1\\\"></div><div class=\\\"fr-action-buttons\\\"><button type=\\\"button\\\" class=\\\"fr-command fr-submit\\\" data-cmd=\\\"updateText\\\" tabIndex=\\\"2\\\">'+b.language.translate(\\\"Update\\\")+\\\"</button></div></div>\\\",c={edit:a};b.popups.create(\\\"text.edit\\\",c)}function d(){var c,d=b.popups.get(\\\"text.edit\\\");c=\\\"INPUT\\\"===b.$el.prop(\\\"tagName\\\")?b.$el.attr(\\\"placeholder\\\"):b.$el.text(),d.find(\\\"input\\\").val(c).trigger(\\\"change\\\"),b.popups.setContainer(\\\"text.edit\\\",a(\\\"body\\\")),b.popups.show(\\\"text.edit\\\",b.$el.offset().left+b.$el.outerWidth()/2,b.$el.offset().top+b.$el.outerHeight(),b.$el.outerHeight())}function e(){b.events.$on(b.$el,b._mouseup,function(a){setTimeout(function(){d()},10)})}function f(){var a=b.popups.get(\\\"text.edit\\\"),c=a.find(\\\"input\\\").val();0==c.length&&(c=b.opts.placeholderText),\\\"INPUT\\\"===b.$el.prop(\\\"tagName\\\")?b.$el.attr(\\\"placeholder\\\",c):b.$el.text(c),b.events.trigger(\\\"contentChanged\\\"),b.popups.hide(\\\"text.edit\\\")}function g(){b.opts.editInPopup&&(c(),e())}return{_init:g,update:f}},a.FE.RegisterCommand(\\\"updateText\\\",{focus:!1,undo:!1,callback:function(){this.textEdit.update()}}),a.extend(a.FE.DEFAULTS,{toolbarBottom:!1,toolbarButtons:[\\\"fullscreen\\\",\\\"bold\\\",\\\"italic\\\",\\\"underline\\\",\\\"strikeThrough\\\",\\\"subscript\\\",\\\"superscript\\\",\\\"fontFamily\\\",\\\"fontSize\\\",\\\"|\\\",\\\"color\\\",\\\"emoticons\\\",\\\"inlineStyle\\\",\\\"paragraphStyle\\\",\\\"|\\\",\\\"paragraphFormat\\\",\\\"align\\\",\\\"formatOL\\\",\\\"formatUL\\\",\\\"outdent\\\",\\\"indent\\\",\\\"quote\\\",\\\"insertHR\\\",\\\"-\\\",\\\"insertLink\\\",\\\"insertImage\\\",\\\"insertVideo\\\",\\\"insertFile\\\",\\\"insertTable\\\",\\\"undo\\\",\\\"redo\\\",\\\"clearFormatting\\\",\\\"selectAll\\\",\\\"html\\\",\\\"applyFormat\\\",\\\"removeFormat\\\",\\\"help\\\"],toolbarButtonsXS:[\\\"bold\\\",\\\"italic\\\",\\\"fontFamily\\\",\\\"fontSize\\\",\\\"|\\\",\\\"undo\\\",\\\"redo\\\",\\\"help\\\"],toolbarButtonsSM:[\\\"bold\\\",\\\"italic\\\",\\\"underline\\\",\\\"|\\\",\\\"fontFamily\\\",\\\"fontSize\\\",\\\"insertLink\\\",\\\"insertImage\\\",\\\"table\\\",\\\"|\\\",\\\"undo\\\",\\\"redo\\\",\\\"help\\\"],toolbarButtonsMD:[\\\"fullscreen\\\",\\\"bold\\\",\\\"italic\\\",\\\"underline\\\",\\\"fontFamily\\\",\\\"fontSize\\\",\\\"color\\\",\\\"paragraphStyle\\\",\\\"paragraphFormat\\\",\\\"align\\\",\\\"formatOL\\\",\\\"formatUL\\\",\\\"outdent\\\",\\\"indent\\\",\\\"quote\\\",\\\"insertHR\\\",\\\"-\\\",\\\"insertLink\\\",\\\"insertImage\\\",\\\"insertVideo\\\",\\\"insertFile\\\",\\\"insertTable\\\",\\\"undo\\\",\\\"redo\\\",\\\"clearFormatting\\\",\\\"help\\\"],toolbarContainer:null,toolbarInline:!1,toolbarSticky:!0,toolbarStickyOffset:0,toolbarVisibleWithoutSelection:!1}),a.FE.MODULES.toolbar=function(b){function c(a,b){for(var c=0;c<b.length;c++)\\\"-\\\"!=b[c]&&\\\"|\\\"!=b[c]&&a.indexOf(b[c])<0&&a.push(b[c])}function d(){var d=a.merge([],e());c(d,b.opts.toolbarButtonsXS||[]),c(d,b.opts.toolbarButtonsSM||[]),c(d,b.opts.toolbarButtonsMD||[]),c(d,b.opts.toolbarButtons);for(var f=d.length-1;f>=0;f--)\\\"-\\\"!=d[f]&&\\\"|\\\"!=d[f]&&d.indexOf(d[f])<f&&d.splice(f,1);var g=b.button.buildList(d,e());b.$tb.append(g),b.button.bindCommands(b.$tb)}function e(){var a=b.helpers.screenSize();return u[a]}function f(){var a=e();b.$tb.find(\\\".fr-separator\\\").remove(),b.$tb.find(\\\"> .fr-command\\\").addClass(\\\"fr-hidden\\\");for(var c=0;c<a.length;c++)if(\\\"|\\\"==a[c]||\\\"-\\\"==a[c])b.$tb.append(b.button.buildList([a[c]]));else{var d=b.$tb.find('> .fr-command[data-cmd=\\\"'+a[c]+'\\\"]'),f=null;b.node.hasClass(d.next().get(0),\\\"fr-dropdown-menu\\\")&&(f=d.next()),d.removeClass(\\\"fr-hidden\\\").appendTo(b.$tb),f&&f.appendTo(b.$tb)}}function g(){b.events.$on(a(b.o_win),\\\"resize\\\",f),b.events.$on(a(b.o_win),\\\"orientationchange\\\",f)}function h(c,d){setTimeout(function(){if(c&&c.which==a.FE.KEYCODE.ESC);else if(b.selection.inEditor()&&b.core.hasFocus()&&!b.popups.areVisible()&&(b.opts.toolbarVisibleWithoutSelection&&c&&\\\"keyup\\\"!=c.type||!b.selection.isCollapsed()&&!b.keys.isIME()||d)){if(b.$tb.data(\\\"instance\\\",b),0==b.events.trigger(\\\"toolbar.show\\\",[c]))return!1;b.opts.toolbarContainer||b.position.forSelection(b.$tb),b.opts.zIndex>1?b.$tb.css(\\\"z-index\\\",b.opts.zIndex+1):b.$tb.css(\\\"z-index\\\",null),b.$tb.show()}},0)}function i(c){var d=a(\\\".fr-dropdown.fr-active\\\");return!!d.next().find(b.o_doc.activeElement).length||void(b.events.trigger(\\\"toolbar.hide\\\")!==!1&&b.$tb.hide())}function j(){return 0!=b.events.trigger(\\\"toolbar.show\\\")&&void b.$tb.show()}function k(){b.events.on(\\\"window.mousedown\\\",i),b.events.on(\\\"keydown\\\",i),b.events.on(\\\"blur\\\",i),b.events.on(\\\"window.mouseup\\\",h),b.helpers.isMobile()?b.helpers.isIOS()||(b.events.on(\\\"window.touchend\\\",h),b.browser.mozilla&&setInterval(h,200)):b.events.on(\\\"window.keyup\\\",h),b.events.on(\\\"keydown\\\",function(b){b&&b.which==a.FE.KEYCODE.ESC&&i()}),b.events.on(\\\"keydown\\\",function(b){if(b.which==a.FE.KEYCODE.ALT)return b.stopPropagation(),!1},!0),b.events.$on(b.$wp,\\\"scroll.toolbar\\\",h),b.events.on(\\\"commands.after\\\",h),b.helpers.isMobile()&&(b.events.$on(b.$doc,\\\"selectionchange\\\",h),b.events.$on(b.$doc,\\\"orientationchange\\\",h))}function l(){b.opts.toolbarInline?(a(b.opts.scrollableContainer).append(b.$tb),b.$tb.data(\\\"container\\\",a(b.opts.scrollableContainer)),b.$tb.addClass(\\\"fr-inline\\\"),b.$tb.prepend('<span class=\\\"fr-arrow\\\"></span>'),k(),b.opts.toolbarBottom=!1):(b.opts.toolbarBottom&&!b.helpers.isIOS()?(b.$box.append(b.$tb),b.$tb.addClass(\\\"fr-bottom\\\"),b.$box.addClass(\\\"fr-bottom\\\")):(b.opts.toolbarBottom=!1,b.$box.prepend(b.$tb),b.$tb.addClass(\\\"fr-top\\\"),b.$box.addClass(\\\"fr-top\\\")),b.$tb.addClass(\\\"fr-basic\\\"),b.opts.toolbarSticky&&(b.opts.toolbarStickyOffset&&(b.opts.toolbarBottom?b.$tb.css(\\\"bottom\\\",b.opts.toolbarStickyOffset):b.$tb.css(\\\"top\\\",b.opts.toolbarStickyOffset)),b.position.addSticky(b.$tb)))}function m(){b.$tb.html(\\\"\\\").removeData().remove(),b.$tb=null}function n(){b.$box.removeClass(\\\"fr-top fr-bottom fr-inline fr-basic\\\"),b.$box.find(\\\".fr-sticky-dummy\\\").remove()}function o(){b.opts.theme&&b.$tb.addClass(b.opts.theme+\\\"-theme\\\"),b.opts.zIndex>1&&b.$tb.css(\\\"z-index\\\",b.opts.zIndex+1),\\\"auto\\\"!=b.opts.direction&&b.$tb.removeClass(\\\"fr-ltr fr-rtl\\\").addClass(\\\"fr-\\\"+b.opts.direction),b.helpers.isMobile()?b.$tb.addClass(\\\"fr-mobile\\\"):b.$tb.addClass(\\\"fr-desktop\\\"),b.opts.toolbarContainer?(b.opts.toolbarInline&&(k(),i()),b.opts.toolbarBottom?b.$tb.addClass(\\\"fr-bottom\\\"):b.$tb.addClass(\\\"fr-top\\\")):l(),s=b.$tb.get(0).ownerDocument,t=\\\"defaultView\\\"in s?s.defaultView:s.parentWindow,d(),g(),b.accessibility.registerToolbar(b.$tb),b.events.$on(b.$tb,b._mousedown+\\\" \\\"+b._mouseup,function(a){var c=a.originalEvent?a.originalEvent.target||a.originalEvent.originalTarget:null;if(c&&\\\"INPUT\\\"!=c.tagName&&!b.edit.isDisabled())return a.stopPropagation(),a.preventDefault(),!1},!0)}function p(){return!!b.$wp&&(b.opts.toolbarContainer?(b.shared.$tb?(b.$tb=b.shared.$tb,b.opts.toolbarInline&&k()):(b.shared.$tb=a('<div class=\\\"fr-toolbar\\\"></div>'),b.$tb=b.shared.$tb,a(b.opts.toolbarContainer).append(b.$tb),o(),b.$tb.data(\\\"instance\\\",b)),b.opts.toolbarInline?b.$box.addClass(\\\"fr-inline\\\"):b.$box.addClass(\\\"fr-basic\\\"),b.events.on(\\\"focus\\\",function(){b.$tb.data(\\\"instance\\\",b)},!0),b.opts.toolbarInline=!1):b.opts.toolbarInline?(b.$box.addClass(\\\"fr-inline\\\"),b.shared.$tb?(b.$tb=b.shared.$tb,k()):(b.shared.$tb=a('<div class=\\\"fr-toolbar\\\"></div>'),b.$tb=b.shared.$tb,o())):(b.$box.addClass(\\\"fr-basic\\\"),b.$tb=a('<div class=\\\"fr-toolbar\\\"></div>'),o(),b.$tb.data(\\\"instance\\\",b)),b.events.on(\\\"destroy\\\",n,!0),void b.events.on(b.opts.toolbarInline||b.opts.toolbarContainer?\\\"shared.destroy\\\":\\\"destroy\\\",m,!0))}function q(){!v&&b.$tb&&(b.$tb.find(\\\"> .fr-command\\\").addClass(\\\"fr-disabled fr-no-refresh\\\").attr(\\\"aria-disabled\\\",!0),v=!0)}function r(){v&&b.$tb&&(b.$tb.find(\\\"> .fr-command\\\").removeClass(\\\"fr-disabled fr-no-refresh\\\").attr(\\\"aria-disabled\\\",!1),v=!1),b.button.bulkRefresh()}var s,t,u=[];u[a.FE.XS]=b.opts.toolbarButtonsXS||b.opts.toolbarButtons,u[a.FE.SM]=b.opts.toolbarButtonsSM||b.opts.toolbarButtons,u[a.FE.MD]=b.opts.toolbarButtonsMD||b.opts.toolbarButtons,u[a.FE.LG]=b.opts.toolbarButtons;var v=!1;return{_init:p,hide:i,show:j,showInline:h,disable:q,enable:r}}});\"//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL34vZnJvYWxhLWVkaXRvci9qcy9mcm9hbGFfZWRpdG9yLm1pbi5qcz81NDRiIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gXCIvKiFcXG4gKiBmcm9hbGFfZWRpdG9yIHYyLjQuMCAoaHR0cHM6Ly93d3cuZnJvYWxhLmNvbS93eXNpd3lnLWVkaXRvcilcXG4gKiBMaWNlbnNlIGh0dHBzOi8vZnJvYWxhLmNvbS93eXNpd3lnLWVkaXRvci90ZXJtcy9cXG4gKiBDb3B5cmlnaHQgMjAxNC0yMDE2IEZyb2FsYSBMYWJzXFxuICovXFxuXFxuIWZ1bmN0aW9uKGEpe1xcXCJmdW5jdGlvblxcXCI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQ/ZGVmaW5lKFtcXFwianF1ZXJ5XFxcIl0sYSk6XFxcIm9iamVjdFxcXCI9PXR5cGVvZiBtb2R1bGUmJm1vZHVsZS5leHBvcnRzP21vZHVsZS5leHBvcnRzPWZ1bmN0aW9uKGIsYyl7cmV0dXJuIHZvaWQgMD09PWMmJihjPVxcXCJ1bmRlZmluZWRcXFwiIT10eXBlb2Ygd2luZG93P3JlcXVpcmUoXFxcImpxdWVyeVxcXCIpOnJlcXVpcmUoXFxcImpxdWVyeVxcXCIpKGIpKSxhKGMpLGN9OmEoalF1ZXJ5KX0oZnVuY3Rpb24oYSl7dmFyIGI9ZnVuY3Rpb24oYyxkKXt0aGlzLmlkPSsrYS5GRS5JRCx0aGlzLm9wdHM9YS5leHRlbmQoITAse30sYS5leHRlbmQoe30sYi5ERUZBVUxUUyxcXFwib2JqZWN0XFxcIj09dHlwZW9mIGQmJmQpKTt2YXIgZT1KU09OLnN0cmluZ2lmeSh0aGlzLm9wdHMpO2EuRkUuT1BUU19NQVBQSU5HW2VdPWEuRkUuT1BUU19NQVBQSU5HW2VdfHx0aGlzLmlkLHRoaXMuc2lkPWEuRkUuT1BUU19NQVBQSU5HW2VdLGEuRkUuU0hBUkVEW3RoaXMuc2lkXT1hLkZFLlNIQVJFRFt0aGlzLnNpZF18fHt9LHRoaXMuc2hhcmVkPWEuRkUuU0hBUkVEW3RoaXMuc2lkXSx0aGlzLnNoYXJlZC5jb3VudD0odGhpcy5zaGFyZWQuY291bnR8fDApKzEsdGhpcy4kb2VsPWEoYyksdGhpcy4kb2VsLmRhdGEoXFxcImZyb2FsYS5lZGl0b3JcXFwiLHRoaXMpLHRoaXMub19kb2M9Yy5vd25lckRvY3VtZW50LHRoaXMub193aW49XFxcImRlZmF1bHRWaWV3XFxcImluIHRoaXMub19kb2M/dGhpcy5vX2RvYy5kZWZhdWx0Vmlldzp0aGlzLm9fZG9jLnBhcmVudFdpbmRvdzt2YXIgZj1hKHRoaXMub193aW4pLnNjcm9sbFRvcCgpO3RoaXMuJG9lbC5vbihcXFwiZnJvYWxhLmRvSW5pdFxcXCIsYS5wcm94eShmdW5jdGlvbigpe3RoaXMuJG9lbC5vZmYoXFxcImZyb2FsYS5kb0luaXRcXFwiKSx0aGlzLmRvYz10aGlzLiRlbC5nZXQoMCkub3duZXJEb2N1bWVudCx0aGlzLndpbj1cXFwiZGVmYXVsdFZpZXdcXFwiaW4gdGhpcy5kb2M/dGhpcy5kb2MuZGVmYXVsdFZpZXc6dGhpcy5kb2MucGFyZW50V2luZG93LHRoaXMuJGRvYz1hKHRoaXMuZG9jKSx0aGlzLiR3aW49YSh0aGlzLndpbiksdGhpcy5vcHRzLnBsdWdpbnNFbmFibGVkfHwodGhpcy5vcHRzLnBsdWdpbnNFbmFibGVkPU9iamVjdC5rZXlzKGEuRkUuUExVR0lOUykpLHRoaXMub3B0cy5pbml0T25DbGljaz8odGhpcy5sb2FkKGEuRkUuTU9EVUxFUyksdGhpcy4kZWwub24oXFxcInRvdWNoc3RhcnQuaW5pdFxcXCIsZnVuY3Rpb24oKXthKHRoaXMpLmRhdGEoXFxcInRvdWNoZWRcXFwiLCEwKX0pLHRoaXMuJGVsLm9uKFxcXCJ0b3VjaG1vdmUuaW5pdFxcXCIsZnVuY3Rpb24oKXthKHRoaXMpLnJlbW92ZURhdGEoXFxcInRvdWNoZWRcXFwiKX0pLHRoaXMuJGVsLm9uKFxcXCJtb3VzZWRvd24uaW5pdCB0b3VjaGVuZC5pbml0IGRyYWdlbnRlci5pbml0IGZvY3VzLmluaXRcXFwiLGEucHJveHkoZnVuY3Rpb24oYil7aWYoXFxcInRvdWNoZW5kXFxcIj09Yi50eXBlJiYhdGhpcy4kZWwuZGF0YShcXFwidG91Y2hlZFxcXCIpKXJldHVybiEwO2lmKDE9PT1iLndoaWNofHwhYi53aGljaCl7dGhpcy4kZWwub2ZmKFxcXCJtb3VzZWRvd24uaW5pdCB0b3VjaHN0YXJ0LmluaXQgdG91Y2htb3ZlLmluaXQgdG91Y2hlbmQuaW5pdCBkcmFnZW50ZXIuaW5pdCBmb2N1cy5pbml0XFxcIiksdGhpcy5sb2FkKGEuRkUuTU9EVUxFUyksdGhpcy5sb2FkKGEuRkUuUExVR0lOUyk7dmFyIGM9Yi5vcmlnaW5hbEV2ZW50JiZiLm9yaWdpbmFsRXZlbnQub3JpZ2luYWxUYXJnZXQ7YyYmXFxcIklNR1xcXCI9PWMudGFnTmFtZSYmYShjKS50cmlnZ2VyKFxcXCJtb3VzZWRvd25cXFwiKSxcXFwidW5kZWZpbmVkXFxcIj09dHlwZW9mIHRoaXMudWwmJnRoaXMuZGVzdHJveSgpLFxcXCJ0b3VjaGVuZFxcXCI9PWIudHlwZSYmdGhpcy5pbWFnZSYmYi5vcmlnaW5hbEV2ZW50JiZiLm9yaWdpbmFsRXZlbnQudGFyZ2V0JiZhKGIub3JpZ2luYWxFdmVudC50YXJnZXQpLmlzKFxcXCJpbWdcXFwiKSYmc2V0VGltZW91dChhLnByb3h5KGZ1bmN0aW9uKCl7dGhpcy5pbWFnZS5lZGl0KGEoYi5vcmlnaW5hbEV2ZW50LnRhcmdldCkpfSx0aGlzKSwxMDApLHRoaXMucmVhZHk9ITAsdGhpcy5ldmVudHMudHJpZ2dlcihcXFwiaW5pdGlhbGl6ZWRcXFwiKX19LHRoaXMpKSk6KHRoaXMubG9hZChhLkZFLk1PRFVMRVMpLHRoaXMubG9hZChhLkZFLlBMVUdJTlMpLGEodGhpcy5vX3dpbikuc2Nyb2xsVG9wKGYpLFxcXCJ1bmRlZmluZWRcXFwiPT10eXBlb2YgdGhpcy51bCYmdGhpcy5kZXN0cm95KCksdGhpcy5yZWFkeT0hMCx0aGlzLmV2ZW50cy50cmlnZ2VyKFxcXCJpbml0aWFsaXplZFxcXCIpKX0sdGhpcykpLHRoaXMuX2luaXQoKX07Yi5ERUZBVUxUUz17aW5pdE9uQ2xpY2s6ITEscGx1Z2luc0VuYWJsZWQ6bnVsbH0sYi5NT0RVTEVTPXt9LGIuUExVR0lOUz17fSxiLlZFUlNJT049XFxcIjIuNC4wXFxcIixiLklOU1RBTkNFUz1bXSxiLk9QVFNfTUFQUElORz17fSxiLlNIQVJFRD17fSxiLklEPTAsYi5wcm90b3R5cGUuX2luaXQ9ZnVuY3Rpb24oKXt2YXIgYj10aGlzLiRvZWwucHJvcChcXFwidGFnTmFtZVxcXCIpLGM9YS5wcm94eShmdW5jdGlvbigpe1xcXCJURVhUQVJFQVxcXCIhPWImJih0aGlzLl9vcmlnaW5hbF9odG1sPXRoaXMuX29yaWdpbmFsX2h0bWx8fHRoaXMuJG9lbC5odG1sKCkpLHRoaXMuJGJveD10aGlzLiRib3h8fHRoaXMuJG9lbCx0aGlzLm9wdHMuZnVsbFBhZ2UmJih0aGlzLm9wdHMuaWZyYW1lPSEwKSx0aGlzLm9wdHMuaWZyYW1lPyh0aGlzLiRpZnJhbWU9YSgnPGlmcmFtZSBzcmM9XFxcImFib3V0OmJsYW5rXFxcIiBmcmFtZUJvcmRlcj1cXFwiMFxcXCI+JyksdGhpcy4kd3A9YShcXFwiPGRpdj48L2Rpdj5cXFwiKSx0aGlzLiRib3guaHRtbCh0aGlzLiR3cCksdGhpcy4kd3AuYXBwZW5kKHRoaXMuJGlmcmFtZSksdGhpcy4kaWZyYW1lLmdldCgwKS5jb250ZW50V2luZG93LmRvY3VtZW50Lm9wZW4oKSx0aGlzLiRpZnJhbWUuZ2V0KDApLmNvbnRlbnRXaW5kb3cuZG9jdW1lbnQud3JpdGUoXFxcIjwhRE9DVFlQRSBodG1sPlxcXCIpLHRoaXMuJGlmcmFtZS5nZXQoMCkuY29udGVudFdpbmRvdy5kb2N1bWVudC53cml0ZShcXFwiPGh0bWw+PGhlYWQ+PC9oZWFkPjxib2R5PjwvYm9keT48L2h0bWw+XFxcIiksdGhpcy4kaWZyYW1lLmdldCgwKS5jb250ZW50V2luZG93LmRvY3VtZW50LmNsb3NlKCksdGhpcy4kZWw9dGhpcy4kaWZyYW1lLmNvbnRlbnRzKCkuZmluZChcXFwiYm9keVxcXCIpLHRoaXMuZWw9dGhpcy4kZWwuZ2V0KDApLHRoaXMuJGhlYWQ9dGhpcy4kaWZyYW1lLmNvbnRlbnRzKCkuZmluZChcXFwiaGVhZFxcXCIpLHRoaXMuJGh0bWw9dGhpcy4kaWZyYW1lLmNvbnRlbnRzKCkuZmluZChcXFwiaHRtbFxcXCIpLHRoaXMuaWZyYW1lX2RvY3VtZW50PXRoaXMuJGlmcmFtZS5nZXQoMCkuY29udGVudFdpbmRvdy5kb2N1bWVudCx0aGlzLiRvZWwudHJpZ2dlcihcXFwiZnJvYWxhLmRvSW5pdFxcXCIpKToodGhpcy4kZWw9YShcXFwiPGRpdj48L2Rpdj5cXFwiKSx0aGlzLmVsPXRoaXMuJGVsLmdldCgwKSx0aGlzLiR3cD1hKFxcXCI8ZGl2PjwvZGl2PlxcXCIpLmFwcGVuZCh0aGlzLiRlbCksdGhpcy4kYm94Lmh0bWwodGhpcy4kd3ApLHRoaXMuJG9lbC50cmlnZ2VyKFxcXCJmcm9hbGEuZG9Jbml0XFxcIikpfSx0aGlzKSxkPWEucHJveHkoZnVuY3Rpb24oKXt0aGlzLiRib3g9YShcXFwiPGRpdj5cXFwiKSx0aGlzLiRvZWwuYmVmb3JlKHRoaXMuJGJveCkuaGlkZSgpLHRoaXMuX29yaWdpbmFsX2h0bWw9dGhpcy4kb2VsLnZhbCgpLHRoaXMuJG9lbC5wYXJlbnRzKFxcXCJmb3JtXFxcIikub24oXFxcInN1Ym1pdC5cXFwiK3RoaXMuaWQsYS5wcm94eShmdW5jdGlvbigpe3RoaXMuZXZlbnRzLnRyaWdnZXIoXFxcImZvcm0uc3VibWl0XFxcIil9LHRoaXMpKSx0aGlzLiRvZWwucGFyZW50cyhcXFwiZm9ybVxcXCIpLm9uKFxcXCJyZXNldC5cXFwiK3RoaXMuaWQsYS5wcm94eShmdW5jdGlvbigpe3RoaXMuZXZlbnRzLnRyaWdnZXIoXFxcImZvcm0ucmVzZXRcXFwiKX0sdGhpcykpLGMoKX0sdGhpcyksZT1hLnByb3h5KGZ1bmN0aW9uKCl7dGhpcy4kZWw9dGhpcy4kb2VsLHRoaXMuZWw9dGhpcy4kZWwuZ2V0KDApLHRoaXMuJGVsLmF0dHIoXFxcImNvbnRlbnRlZGl0YWJsZVxcXCIsITApLmNzcyhcXFwib3V0bGluZVxcXCIsXFxcIm5vbmVcXFwiKS5jc3MoXFxcImRpc3BsYXlcXFwiLFxcXCJpbmxpbmUtYmxvY2tcXFwiKSx0aGlzLm9wdHMubXVsdGlMaW5lPSExLHRoaXMub3B0cy50b29sYmFySW5saW5lPSExLHRoaXMuJG9lbC50cmlnZ2VyKFxcXCJmcm9hbGEuZG9Jbml0XFxcIil9LHRoaXMpLGY9YS5wcm94eShmdW5jdGlvbigpe3RoaXMuJGVsPXRoaXMuJG9lbCx0aGlzLmVsPXRoaXMuJGVsLmdldCgwKSx0aGlzLm9wdHMudG9vbGJhcklubGluZT0hMSx0aGlzLiRvZWwudHJpZ2dlcihcXFwiZnJvYWxhLmRvSW5pdFxcXCIpfSx0aGlzKSxnPWEucHJveHkoZnVuY3Rpb24oKXt0aGlzLiRlbD10aGlzLiRvZWwsdGhpcy5lbD10aGlzLiRlbC5nZXQoMCksdGhpcy5vcHRzLnRvb2xiYXJJbmxpbmU9ITEsdGhpcy4kb2VsLm9uKFxcXCJjbGljay5wb3B1cFxcXCIsZnVuY3Rpb24oYSl7YS5wcmV2ZW50RGVmYXVsdCgpfSksdGhpcy4kb2VsLnRyaWdnZXIoXFxcImZyb2FsYS5kb0luaXRcXFwiKX0sdGhpcyk7dGhpcy5vcHRzLmVkaXRJblBvcHVwP2coKTpcXFwiVEVYVEFSRUFcXFwiPT1iP2QoKTpcXFwiQVxcXCI9PWI/ZSgpOlxcXCJJTUdcXFwiPT1iP2YoKTpcXFwiQlVUVE9OXFxcIj09Ynx8XFxcIklOUFVUXFxcIj09Yj8odGhpcy5vcHRzLmVkaXRJblBvcHVwPSEwLHRoaXMub3B0cy50b29sYmFySW5saW5lPSExLGcoKSk6YygpfSxiLnByb3RvdHlwZS5sb2FkPWZ1bmN0aW9uKGIpe2Zvcih2YXIgYyBpbiBiKWlmKGIuaGFzT3duUHJvcGVydHkoYykpe2lmKHRoaXNbY10pY29udGludWU7aWYoYS5GRS5QTFVHSU5TW2NdJiZ0aGlzLm9wdHMucGx1Z2luc0VuYWJsZWQuaW5kZXhPZihjKTwwKWNvbnRpbnVlO2lmKHRoaXNbY109bmV3IGJbY10odGhpcyksdGhpc1tjXS5faW5pdCYmKHRoaXNbY10uX2luaXQoKSx0aGlzLm9wdHMuaW5pdE9uQ2xpY2smJlxcXCJjb3JlXFxcIj09YykpcmV0dXJuITF9fSxiLnByb3RvdHlwZS5kZXN0cm95PWZ1bmN0aW9uKCl7dGhpcy5zaGFyZWQuY291bnQtLSx0aGlzLmV2ZW50cy4kb2ZmKCk7dmFyIGI9dGhpcy5odG1sLmdldCgpO2lmKHRoaXMuZXZlbnRzLnRyaWdnZXIoXFxcImRlc3Ryb3lcXFwiLFtdLCEwKSx0aGlzLmV2ZW50cy50cmlnZ2VyKFxcXCJzaGFyZWQuZGVzdHJveVxcXCIsdm9pZCAwLCEwKSwwPT09dGhpcy5zaGFyZWQuY291bnQpe2Zvcih2YXIgYyBpbiB0aGlzLnNoYXJlZCl0aGlzLnNoYXJlZC5oYXNPd25Qcm9wZXJ0eShjKSYmKG51bGw9PXRoaXMuc2hhcmVkW2NdLGEuRkUuU0hBUkVEW3RoaXMuc2lkXVtjXT1udWxsKTthLkZFLlNIQVJFRFt0aGlzLnNpZF09e319dGhpcy4kb2VsLnBhcmVudHMoXFxcImZvcm1cXFwiKS5vZmYoXFxcIi5cXFwiK3RoaXMuaWQpLHRoaXMuJG9lbC5vZmYoXFxcImNsaWNrLnBvcHVwXFxcIiksdGhpcy4kb2VsLnJlbW92ZURhdGEoXFxcImZyb2FsYS5lZGl0b3JcXFwiKSx0aGlzLiRvZWwub2ZmKFxcXCJmcm9hbGFFZGl0b3JcXFwiKSx0aGlzLmNvcmUuZGVzdHJveShiKSxhLkZFLklOU1RBTkNFUy5zcGxpY2UoYS5GRS5JTlNUQU5DRVMuaW5kZXhPZih0aGlzKSwxKX0sYS5mbi5mcm9hbGFFZGl0b3I9ZnVuY3Rpb24oYyl7Zm9yKHZhciBkPVtdLGU9MDtlPGFyZ3VtZW50cy5sZW5ndGg7ZSsrKWQucHVzaChhcmd1bWVudHNbZV0pO2lmKFxcXCJzdHJpbmdcXFwiPT10eXBlb2YgYyl7dmFyIGY9W107cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpe3ZhciBiPWEodGhpcyksZT1iLmRhdGEoXFxcImZyb2FsYS5lZGl0b3JcXFwiKTtpZihlKXt2YXIgZyxoO2lmKGMuaW5kZXhPZihcXFwiLlxcXCIpPjAmJmVbYy5zcGxpdChcXFwiLlxcXCIpWzBdXT8oZVtjLnNwbGl0KFxcXCIuXFxcIilbMF1dJiYoZz1lW2Muc3BsaXQoXFxcIi5cXFwiKVswXV0pLGg9Yy5zcGxpdChcXFwiLlxcXCIpWzFdKTooZz1lLGg9Yy5zcGxpdChcXFwiLlxcXCIpWzBdKSwhZ1toXSlyZXR1cm4gYS5lcnJvcihcXFwiTWV0aG9kIFxcXCIrYytcXFwiIGRvZXMgbm90IGV4aXN0IGluIEZyb2FsYSBFZGl0b3IuXFxcIik7dmFyIGk9Z1toXS5hcHBseShlLGQuc2xpY2UoMSkpO3ZvaWQgMD09PWk/Zi5wdXNoKHRoaXMpOjA9PT1mLmxlbmd0aCYmZi5wdXNoKGkpfX0pLDE9PWYubGVuZ3RoP2ZbMF06Zn1pZihcXFwib2JqZWN0XFxcIj09dHlwZW9mIGN8fCFjKXJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKXt2YXIgZD1hKHRoaXMpLmRhdGEoXFxcImZyb2FsYS5lZGl0b3JcXFwiKTtpZighZCl7dmFyIGU9dGhpcztuZXcgYihlLGMpfX0pfSxhLmZuLmZyb2FsYUVkaXRvci5Db25zdHJ1Y3Rvcj1iLGEuRnJvYWxhRWRpdG9yPWIsYS5GRT1iLGEuRkUuWFM9MCxhLkZFLlNNPTEsYS5GRS5NRD0yLGEuRkUuTEc9MyxhLkZFLk1PRFVMRVMuaGVscGVycz1mdW5jdGlvbihiKXtmdW5jdGlvbiBjKCl7dmFyIGEsYixjPS0xO3JldHVyblxcXCJNaWNyb3NvZnQgSW50ZXJuZXQgRXhwbG9yZXJcXFwiPT1uYXZpZ2F0b3IuYXBwTmFtZT8oYT1uYXZpZ2F0b3IudXNlckFnZW50LGI9bmV3IFJlZ0V4cChcXFwiTVNJRSAoWzAtOV17MSx9W1xcXFxcXFxcLjAtOV17MCx9KVxcXCIpLG51bGwhPT1iLmV4ZWMoYSkmJihjPXBhcnNlRmxvYXQoUmVnRXhwLiQxKSkpOlxcXCJOZXRzY2FwZVxcXCI9PW5hdmlnYXRvci5hcHBOYW1lJiYoYT1uYXZpZ2F0b3IudXNlckFnZW50LGI9bmV3IFJlZ0V4cChcXFwiVHJpZGVudC8uKnJ2OihbMC05XXsxLH1bXFxcXFxcXFwuMC05XXswLH0pXFxcIiksbnVsbCE9PWIuZXhlYyhhKSYmKGM9cGFyc2VGbG9hdChSZWdFeHAuJDEpKSksY31mdW5jdGlvbiBkKCl7dmFyIGE9e30sYj1jKCk7aWYoYj4wKWEubXNpZT0hMDtlbHNle3ZhciBkPW5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKSxlPS8oZWRnZSlbIFxcXFwvXShbXFxcXHcuXSspLy5leGVjKGQpfHwvKGNocm9tZSlbIFxcXFwvXShbXFxcXHcuXSspLy5leGVjKGQpfHwvKHdlYmtpdClbIFxcXFwvXShbXFxcXHcuXSspLy5leGVjKGQpfHwvKG9wZXJhKSg/Oi4qdmVyc2lvbnwpWyBcXFxcL10oW1xcXFx3Ll0rKS8uZXhlYyhkKXx8Lyhtc2llKSAoW1xcXFx3Ll0rKS8uZXhlYyhkKXx8ZC5pbmRleE9mKFxcXCJjb21wYXRpYmxlXFxcIik8MCYmLyhtb3ppbGxhKSg/Oi4qPyBydjooW1xcXFx3Ll0rKXwpLy5leGVjKGQpfHxbXSxmPXticm93c2VyOmVbMV18fFxcXCJcXFwiLHZlcnNpb246ZVsyXXx8XFxcIjBcXFwifTtlWzFdJiYoYVtmLmJyb3dzZXJdPSEwKSxhLmNocm9tZT9hLndlYmtpdD0hMDphLndlYmtpdCYmKGEuc2FmYXJpPSEwKX1yZXR1cm4gYS5tc2llJiYoYS52ZXJzaW9uPWIpLGF9ZnVuY3Rpb24gZSgpe3JldHVybi8oaVBhZHxpUGhvbmV8aVBvZCkvZy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpJiYhaCgpfWZ1bmN0aW9uIGYoKXtyZXR1cm4vKEFuZHJvaWQpL2cudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSYmIWgoKX1mdW5jdGlvbiBnKCl7cmV0dXJuLyhCbGFja2JlcnJ5KS9nLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCl9ZnVuY3Rpb24gaCgpe3JldHVybi8oV2luZG93cyBQaG9uZSkvZ2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KX1mdW5jdGlvbiBpKCl7cmV0dXJuIGYoKXx8ZSgpfHxnKCl9ZnVuY3Rpb24gaigpe3JldHVybiB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lfHx3aW5kb3cud2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lfHx3aW5kb3cubW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lfHxmdW5jdGlvbihhKXt3aW5kb3cuc2V0VGltZW91dChhLDFlMy82MCl9fWZ1bmN0aW9uIGsoYSl7cmV0dXJuIHBhcnNlSW50KGEsMTApfHwwfWZ1bmN0aW9uIGwoKXt2YXIgYj1hKCc8ZGl2IGNsYXNzPVxcXCJmci12aXNpYmlsaXR5LWhlbHBlclxcXCI+PC9kaXY+JykuYXBwZW5kVG8oXFxcImJvZHlcXFwiKSxjPWsoYi5jc3MoXFxcIm1hcmdpbi1sZWZ0XFxcIikpO3JldHVybiBiLnJlbW92ZSgpLGN9ZnVuY3Rpb24gbSgpe3JldHVyblxcXCJvbnRvdWNoc3RhcnRcXFwiaW4gd2luZG93fHx3aW5kb3cuRG9jdW1lbnRUb3VjaCYmZG9jdW1lbnQgaW5zdGFuY2VvZiBEb2N1bWVudFRvdWNofWZ1bmN0aW9uIG4oYSl7aWYoIS9eKGh0dHBzPzp8ZnRwcz86fClcXFxcL1xcXFwvL2kudGVzdChhKSlyZXR1cm4hMTthPVN0cmluZyhhKS5yZXBsYWNlKC88L2csXFxcIiUzQ1xcXCIpLnJlcGxhY2UoLz4vZyxcXFwiJTNFXFxcIikucmVwbGFjZSgvXFxcIi9nLFxcXCIlMjJcXFwiKS5yZXBsYWNlKC8gL2csXFxcIiUyMFxcXCIpO3ZhciBiPS8oaHR0cHxmdHB8aHR0cHMpOlxcXFwvXFxcXC9bYS16XFxcXHUwMGExLVxcXFx1ZmZmZjAtOXt9XSsoXFxcXC5bYS16XFxcXHUwMGExLVxcXFx1ZmZmZjAtOXt9XSopKihbYS16XFxcXHUwMGExLVxcXFx1ZmZmZjAtOS4sQD9ePSUmYW1wOzpcXFxcL34rIy1fe31dKlthLXpcXFxcdTAwYTEtXFxcXHVmZmZmMC05QD9ePSUmYW1wO1xcXFwvfisjLV97fV0pPy9naTtyZXR1cm4gYi50ZXN0KGEpfWZ1bmN0aW9uIG8oYSl7aWYoL14oaHR0cHM/OnxmdHBzPzp8KVxcXFwvXFxcXC8vaS50ZXN0KGEpKXtpZighbihhKSYmIW4oXFxcImh0dHA6XFxcIithKSlyZXR1cm5cXFwiXFxcIn1lbHNlIGE9ZW5jb2RlVVJJQ29tcG9uZW50KGEpLnJlcGxhY2UoLyUyMy9nLFxcXCIjXFxcIikucmVwbGFjZSgvJTJGL2csXFxcIi9cXFwiKS5yZXBsYWNlKC8lMjUvZyxcXFwiJVxcXCIpLnJlcGxhY2UoL21haWx0byUzQS9naSxcXFwibWFpbHRvOlxcXCIpLnJlcGxhY2UoL2ZpbGUlM0EvZ2ksXFxcImZpbGU6XFxcIikucmVwbGFjZSgvc21zJTNBL2dpLFxcXCJzbXM6XFxcIikucmVwbGFjZSgvdGVsJTNBL2dpLFxcXCJ0ZWw6XFxcIikucmVwbGFjZSgvbm90ZXMlM0EvZ2ksXFxcIm5vdGVzOlxcXCIpLnJlcGxhY2UoL2RhdGElM0FpbWFnZS9naSxcXFwiZGF0YTppbWFnZVxcXCIpLnJlcGxhY2UoL2Jsb2IlM0EvZ2ksXFxcImJsb2I6XFxcIikucmVwbGFjZSgvd2Via2l0LWZha2UtdXJsJTNBL2dpLFxcXCJ3ZWJraXQtZmFrZS11cmw6XFxcIikucmVwbGFjZSgvJTNGL2csXFxcIj9cXFwiKS5yZXBsYWNlKC8lM0QvZyxcXFwiPVxcXCIpLnJlcGxhY2UoLyUyNi9nLFxcXCImXFxcIikucmVwbGFjZSgvJmFtcDsvZyxcXFwiJlxcXCIpLnJlcGxhY2UoLyUyQy9nLFxcXCIsXFxcIikucmVwbGFjZSgvJTNCL2csXFxcIjtcXFwiKS5yZXBsYWNlKC8lMkIvZyxcXFwiK1xcXCIpLnJlcGxhY2UoLyU0MC9nLFxcXCJAXFxcIikucmVwbGFjZSgvJTVCL2csXFxcIltcXFwiKS5yZXBsYWNlKC8lNUQvZyxcXFwiXVxcXCIpLnJlcGxhY2UoLyU3Qi9nLFxcXCJ7XFxcIikucmVwbGFjZSgvJTdEL2csXFxcIn1cXFwiKTtyZXR1cm4gYX1mdW5jdGlvbiBwKGEpe3JldHVybiBhJiYhYS5wcm9wZXJ0eUlzRW51bWVyYWJsZShcXFwibGVuZ3RoXFxcIikmJlxcXCJvYmplY3RcXFwiPT10eXBlb2YgYSYmXFxcIm51bWJlclxcXCI9PXR5cGVvZiBhLmxlbmd0aH1mdW5jdGlvbiBxKGEpe2Z1bmN0aW9uIGIoYSl7cmV0dXJuKFxcXCIwXFxcIitwYXJzZUludChhLDEwKS50b1N0cmluZygxNikpLnNsaWNlKC0yKX10cnl7cmV0dXJuIGEmJlxcXCJ0cmFuc3BhcmVudFxcXCIhPT1hPy9eI1swLTlBLUZdezZ9JC9pLnRlc3QoYSk/YTooYT1hLm1hdGNoKC9ecmdiXFxcXCgoXFxcXGQrKSxcXFxccyooXFxcXGQrKSxcXFxccyooXFxcXGQrKVxcXFwpJC8pLChcXFwiI1xcXCIrYihhWzFdKStiKGFbMl0pK2IoYVszXSkpLnRvVXBwZXJDYXNlKCkpOlxcXCJcXFwifWNhdGNoKGMpe3JldHVybiBudWxsfX1mdW5jdGlvbiByKGEpe3ZhciBiPS9eIz8oW2EtZlxcXFxkXSkoW2EtZlxcXFxkXSkoW2EtZlxcXFxkXSkkL2k7YT1hLnJlcGxhY2UoYixmdW5jdGlvbihhLGIsYyxkKXtyZXR1cm4gYitiK2MrYytkK2R9KTt2YXIgYz0vXiM/KFthLWZcXFxcZF17Mn0pKFthLWZcXFxcZF17Mn0pKFthLWZcXFxcZF17Mn0pJC9pLmV4ZWMoYSk7cmV0dXJuIGM/XFxcInJnYihcXFwiK3BhcnNlSW50KGNbMV0sMTYpK1xcXCIsIFxcXCIrcGFyc2VJbnQoY1syXSwxNikrXFxcIiwgXFxcIitwYXJzZUludChjWzNdLDE2KStcXFwiKVxcXCI6XFxcIlxcXCJ9ZnVuY3Rpb24gcyhiKXt2YXIgYz0oYi5jc3MoXFxcInRleHQtYWxpZ25cXFwiKXx8XFxcIlxcXCIpLnJlcGxhY2UoLy0oLiopLS9nLFxcXCJcXFwiKTtpZihbXFxcImxlZnRcXFwiLFxcXCJyaWdodFxcXCIsXFxcImp1c3RpZnlcXFwiLFxcXCJjZW50ZXJcXFwiXS5pbmRleE9mKGMpPDApe2lmKCF3KXt2YXIgZD1hKCc8ZGl2IGRpcj1cXFwiYXV0b1xcXCIgc3R5bGU9XFxcInRleHQtYWxpZ246IGluaXRpYWw7IHBvc2l0aW9uOiBmaXhlZDsgbGVmdDogLTMwMDBweDtcXFwiPjxzcGFuIGlkPVxcXCJzMVxcXCI+Ljwvc3Bhbj48c3BhbiBpZD1cXFwiczJcXFwiPi48L3NwYW4+PC9kaXY+Jyk7YShcXFwiYm9keVxcXCIpLmFwcGVuZChkKTt2YXIgZT1kLmZpbmQoXFxcIiNzMVxcXCIpLmdldCgwKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0LGY9ZC5maW5kKFxcXCIjczJcXFwiKS5nZXQoMCkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdDtkLnJlbW92ZSgpLHc9ZTxmP1xcXCJsZWZ0XFxcIjpcXFwicmlnaHRcXFwifWM9d31yZXR1cm4gY31mdW5jdGlvbiB0KCl7cmV0dXJuIG51bGw9PXgmJih4PW5hdmlnYXRvci5wbGF0Zm9ybS50b1VwcGVyQ2FzZSgpLmluZGV4T2YoXFxcIk1BQ1xcXCIpPj0wKSx4fWZ1bmN0aW9uIHUoKXtmdW5jdGlvbiBhKGEsYil7dmFyIGQ9YVtiXTthW2JdPWZ1bmN0aW9uKGEpe3ZhciBiLGY9ITEsZz0hMTtpZihhLm1hdGNoKGUpKXthPWEucmVwbGFjZShlLFxcXCJcXFwiKSx0aGlzLnBhcmVudE5vZGV8fChjLmFwcGVuZENoaWxkKHRoaXMpLGc9ITApO3ZhciBoPXRoaXMucGFyZW50Tm9kZTtyZXR1cm4gdGhpcy5pZHx8KHRoaXMuaWQ9XFxcInJvb3RlZFF1ZXJ5U2VsZWN0b3JfaWRfXFxcIisobmV3IERhdGUpLmdldFRpbWUoKSxmPSEwKSxiPWQuY2FsbChoLFxcXCIjXFxcIit0aGlzLmlkK1xcXCIgXFxcIithKSxmJiYodGhpcy5pZD1cXFwiXFxcIiksZyYmYy5yZW1vdmVDaGlsZCh0aGlzKSxifXJldHVybiBkLmNhbGwodGhpcyxhKX19dmFyIGM9Yi5vX2RvYy5jcmVhdGVFbGVtZW50KFxcXCJkaXZcXFwiKTt0cnl7Yy5xdWVyeVNlbGVjdG9yQWxsKFxcXCI6c2NvcGUgKlxcXCIpfWNhdGNoKGQpe3ZhciBlPS9eXFxcXHMqOnNjb3BlL2dpO2EoSFRNTEVsZW1lbnQucHJvdG90eXBlLFxcXCJxdWVyeVNlbGVjdG9yXFxcIiksYShIVE1MRWxlbWVudC5wcm90b3R5cGUsXFxcInF1ZXJ5U2VsZWN0b3JBbGxcXFwiKX19ZnVuY3Rpb24gdigpe2IuYnJvd3Nlcj1kKCksdSgpfXZhciB3LHg9bnVsbDtyZXR1cm57X2luaXQ6dixpc0lPUzplLGlzTWFjOnQsaXNBbmRyb2lkOmYsaXNCbGFja2JlcnJ5OmcsaXNXaW5kb3dzUGhvbmU6aCxpc01vYmlsZTppLHJlcXVlc3RBbmltYXRpb25GcmFtZTpqLGdldFBYOmssc2NyZWVuU2l6ZTpsLGlzVG91Y2g6bSxzYW5pdGl6ZVVSTDpvLGlzQXJyYXk6cCxSR0JUb0hleDpxLEhFWHRvUkdCOnIsaXNVUkw6bixnZXRBbGlnbm1lbnQ6c319LGEuRkUuTU9EVUxFUy5ldmVudHM9ZnVuY3Rpb24oYil7ZnVuY3Rpb24gYyhhLGIsYyl7cyhhLGIsYyl9ZnVuY3Rpb24gZCgpe2MoYi4kZWwsXFxcImN1dCBjb3B5IHBhc3RlIGJlZm9yZXBhc3RlXFxcIixmdW5jdGlvbihhKXt2KGEudHlwZSxbYV0pfSl9ZnVuY3Rpb24gZSgpe2MoYi4kZWwsXFxcImNsaWNrIG1vdXNldXAgbW91c2Vkb3duIHRvdWNoc3RhcnQgdG91Y2hlbmQgZHJhZ2VudGVyIGRyYWdvdmVyIGRyYWdsZWF2ZSBkcmFnZW5kIGRyb3AgZHJhZ3N0YXJ0XFxcIixmdW5jdGlvbihhKXt2KGEudHlwZSxbYV0pfSkscihcXFwibW91c2Vkb3duXFxcIixmdW5jdGlvbigpe2Zvcih2YXIgYz0wO2M8YS5GRS5JTlNUQU5DRVMubGVuZ3RoO2MrKylhLkZFLklOU1RBTkNFU1tjXSE9YiYmYS5GRS5JTlNUQU5DRVNbY10ucG9wdXBzJiZhLkZFLklOU1RBTkNFU1tjXS5wb3B1cHMuYXJlVmlzaWJsZSgpJiZhLkZFLklOU1RBTkNFU1tjXS4kZWwuZmluZChcXFwiLmZyLW1hcmtlclxcXCIpLnJlbW92ZSgpfSl9ZnVuY3Rpb24gZigpe2MoYi4kZWwsXFxcImtleWRvd24ga2V5cHJlc3Mga2V5dXAgaW5wdXRcXFwiLGZ1bmN0aW9uKGEpe3YoYS50eXBlLFthXSl9KX1mdW5jdGlvbiBnKCl7YyhiLiR3aW4sYi5fbW91c2Vkb3duLGZ1bmN0aW9uKGEpe3YoXFxcIndpbmRvdy5tb3VzZWRvd25cXFwiLFthXSksbigpfSksYyhiLiR3aW4sYi5fbW91c2V1cCxmdW5jdGlvbihhKXt2KFxcXCJ3aW5kb3cubW91c2V1cFxcXCIsW2FdKX0pLGMoYi4kd2luLFxcXCJjdXQgY29weSBrZXlkb3duIGtleXVwIHRvdWNobW92ZSB0b3VjaGVuZFxcXCIsZnVuY3Rpb24oYSl7dihcXFwid2luZG93LlxcXCIrYS50eXBlLFthXSl9KX1mdW5jdGlvbiBoKCl7YyhiLiRkb2MsXFxcImRyYWdlbmQgZHJvcFxcXCIsZnVuY3Rpb24oYSl7dihcXFwiZG9jdW1lbnQuXFxcIithLnR5cGUsW2FdKX0pfWZ1bmN0aW9uIGkoYyl7aWYoXFxcInVuZGVmaW5lZFxcXCI9PXR5cGVvZiBjJiYoYz0hMCksIWIuJHdwKXJldHVybiExO2lmKGIuaGVscGVycy5pc0lPUygpJiZiLiR3aW4uZ2V0KDApLmZvY3VzKCksIWIuY29yZS5oYXNGb2N1cygpJiZjKXt2YXIgZD1iLiR3aW4uc2Nyb2xsVG9wKCk7cmV0dXJuIGIuJGVsLmZvY3VzKCksZCE9Yi4kd2luLnNjcm9sbFRvcCgpJiZiLiR3aW4uc2Nyb2xsVG9wKGQpLCExfWlmKCFiLmNvcmUuaGFzRm9jdXMoKXx8Yi4kZWwuZmluZChcXFwiLmZyLW1hcmtlclxcXCIpLmxlbmd0aD4wKXJldHVybiExO3ZhciBlPWIuc2VsZWN0aW9uLmluZm8oYi5lbCk7aWYoZS5hdFN0YXJ0JiZiLnNlbGVjdGlvbi5pc0NvbGxhcHNlZCgpJiZudWxsIT1iLmh0bWwuZGVmYXVsdFRhZygpKXt2YXIgZj1iLm1hcmtlcnMuaW5zZXJ0KCk7aWYoZiYmIWIubm9kZS5ibG9ja1BhcmVudChmKSl7YShmKS5yZW1vdmUoKTt2YXIgZz1iLiRlbC5maW5kKGIuaHRtbC5ibG9ja1RhZ3NRdWVyeSgpKS5nZXQoMCk7ZyYmKGEoZykucHJlcGVuZChhLkZFLk1BUktFUlMpLGIuc2VsZWN0aW9uLnJlc3RvcmUoKSl9ZWxzZSBmJiZhKGYpLnJlbW92ZSgpfX1mdW5jdGlvbiBqKCl7YyhiLiRlbCxcXFwiZm9jdXNcXFwiLGZ1bmN0aW9uKGEpe3AoKSYmKGkoITEpLEM9PT0hMSYmdihhLnR5cGUsW2FdKSl9KSxjKGIuJGVsLFxcXCJibHVyXFxcIixmdW5jdGlvbihhKXtwKCkmJkM9PT0hMCYmKHYoYS50eXBlLFthXSksbigpKX0pLHIoXFxcImZvY3VzXFxcIixmdW5jdGlvbigpe0M9ITB9KSxyKFxcXCJibHVyXFxcIixmdW5jdGlvbigpe0M9ITF9KX1mdW5jdGlvbiBrKCl7Yi5oZWxwZXJzLmlzTW9iaWxlKCk/KGIuX21vdXNlZG93bj1cXFwidG91Y2hzdGFydFxcXCIsYi5fbW91c2V1cD1cXFwidG91Y2hlbmRcXFwiLGIuX21vdmU9XFxcInRvdWNobW92ZVxcXCIsYi5fbW91c2Vtb3ZlPVxcXCJ0b3VjaG1vdmVcXFwiKTooYi5fbW91c2Vkb3duPVxcXCJtb3VzZWRvd25cXFwiLGIuX21vdXNldXA9XFxcIm1vdXNldXBcXFwiLGIuX21vdmU9XFxcIlxcXCIsYi5fbW91c2Vtb3ZlPVxcXCJtb3VzZW1vdmVcXFwiKX1mdW5jdGlvbiBsKGMpe3ZhciBkPWEoYy5jdXJyZW50VGFyZ2V0KTtyZXR1cm4gYi5lZGl0LmlzRGlzYWJsZWQoKXx8Yi5ub2RlLmhhc0NsYXNzKGQuZ2V0KDApLFxcXCJmci1kaXNhYmxlZFxcXCIpPyhjLnByZXZlbnREZWZhdWx0KCksITEpOlxcXCJtb3VzZWRvd25cXFwiPT09Yy50eXBlJiYxIT09Yy53aGljaHx8KGIuaGVscGVycy5pc01vYmlsZSgpfHxjLnByZXZlbnREZWZhdWx0KCksKGIuaGVscGVycy5pc0FuZHJvaWQoKXx8Yi5oZWxwZXJzLmlzV2luZG93c1Bob25lKCkpJiYwPT09ZC5wYXJlbnRzKFxcXCIuZnItZHJvcGRvd24tbWVudVxcXCIpLmxlbmd0aCYmKGMucHJldmVudERlZmF1bHQoKSxjLnN0b3BQcm9wYWdhdGlvbigpKSxkLmFkZENsYXNzKFxcXCJmci1zZWxlY3RlZFxcXCIpLHZvaWQgYi5ldmVudHMudHJpZ2dlcihcXFwiY29tbWFuZHMubW91c2Vkb3duXFxcIixbZF0pKX1mdW5jdGlvbiBtKGMsZCl7dmFyIGU9YShjLmN1cnJlbnRUYXJnZXQpO2lmKGIuZWRpdC5pc0Rpc2FibGVkKCl8fGIubm9kZS5oYXNDbGFzcyhlLmdldCgwKSxcXFwiZnItZGlzYWJsZWRcXFwiKSlyZXR1cm4gYy5wcmV2ZW50RGVmYXVsdCgpLCExO2lmKFxcXCJtb3VzZXVwXFxcIj09PWMudHlwZSYmMSE9PWMud2hpY2gpcmV0dXJuITA7aWYoIWIubm9kZS5oYXNDbGFzcyhlLmdldCgwKSxcXFwiZnItc2VsZWN0ZWRcXFwiKSlyZXR1cm4hMDtpZihcXFwidG91Y2htb3ZlXFxcIiE9Yy50eXBlKXtpZihjLnN0b3BQcm9wYWdhdGlvbigpLGMuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCksYy5wcmV2ZW50RGVmYXVsdCgpLCFiLm5vZGUuaGFzQ2xhc3MoZS5nZXQoMCksXFxcImZyLXNlbGVjdGVkXFxcIikpcmV0dXJuIGEoXFxcIi5mci1zZWxlY3RlZFxcXCIpLnJlbW92ZUNsYXNzKFxcXCJmci1zZWxlY3RlZFxcXCIpLCExO2lmKGEoXFxcIi5mci1zZWxlY3RlZFxcXCIpLnJlbW92ZUNsYXNzKFxcXCJmci1zZWxlY3RlZFxcXCIpLGUuZGF0YShcXFwiZHJhZ2dpbmdcXFwiKXx8ZS5hdHRyKFxcXCJkaXNhYmxlZFxcXCIpKXJldHVybiBlLnJlbW92ZURhdGEoXFxcImRyYWdnaW5nXFxcIiksITE7dmFyIGY9ZS5kYXRhKFxcXCJ0aW1lb3V0XFxcIik7ZiYmKGNsZWFyVGltZW91dChmKSxlLnJlbW92ZURhdGEoXFxcInRpbWVvdXRcXFwiKSksZC5hcHBseShiLFtjXSl9ZWxzZSBlLmRhdGEoXFxcInRpbWVvdXRcXFwiKXx8ZS5kYXRhKFxcXCJ0aW1lb3V0XFxcIixzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7ZS5kYXRhKFxcXCJkcmFnZ2luZ1xcXCIsITApfSwxMDApKX1mdW5jdGlvbiBuKCl7QT0hMH1mdW5jdGlvbiBvKCl7QT0hMX1mdW5jdGlvbiBwKCl7cmV0dXJuIEF9ZnVuY3Rpb24gcShhLGMsZCl7cyhhLGIuX21vdXNlZG93bixjLGZ1bmN0aW9uKGEpe2IuZWRpdC5pc0Rpc2FibGVkKCl8fGwoYSl9LCEwKSxzKGEsYi5fbW91c2V1cCtcXFwiIFxcXCIrYi5fbW92ZSxjLGZ1bmN0aW9uKGEpe2IuZWRpdC5pc0Rpc2FibGVkKCl8fG0oYSxkKX0sITApLHMoYSxcXFwibW91c2Vkb3duIGNsaWNrIG1vdXNldXBcXFwiLGMsZnVuY3Rpb24oYSl7Yi5lZGl0LmlzRGlzYWJsZWQoKXx8YS5zdG9wUHJvcGFnYXRpb24oKX0sITApLHIoXFxcIndpbmRvdy5tb3VzZXVwXFxcIixmdW5jdGlvbigpe2IuZWRpdC5pc0Rpc2FibGVkKCl8fChhLmZpbmQoYykucmVtb3ZlQ2xhc3MoXFxcImZyLXNlbGVjdGVkXFxcIiksbigpKX0pfWZ1bmN0aW9uIHIoYSxjLGQpe3ZhciBlPWEuc3BsaXQoXFxcIiBcXFwiKTtpZihlLmxlbmd0aD4xKXtmb3IodmFyIGY9MDtmPGUubGVuZ3RoO2YrKylyKGVbZl0sYyxkKTtyZXR1cm4hMH1cXFwidW5kZWZpbmVkXFxcIj09dHlwZW9mIGQmJihkPSExKTt2YXIgZztnPTAhPWEuaW5kZXhPZihcXFwic2hhcmVkLlxcXCIpP0JbYV09QlthXXx8W106Yi5zaGFyZWQuX2V2ZW50c1thXT1iLnNoYXJlZC5fZXZlbnRzW2FdfHxbXSxkP2cudW5zaGlmdChjKTpnLnB1c2goYyl9ZnVuY3Rpb24gcyhhLGMsZCxlLGYpe1xcXCJmdW5jdGlvblxcXCI9PXR5cGVvZiBkJiYoZj1lLGU9ZCxkPSExKTt2YXIgZz1mP2Iuc2hhcmVkLiRfZXZlbnRzOkQsaD1mP2Iuc2lkOmIuaWQ7ZD9hLm9uKGMuc3BsaXQoXFxcIiBcXFwiKS5qb2luKFxcXCIuZWRcXFwiK2grXFxcIiBcXFwiKStcXFwiLmVkXFxcIitoLGQsZSk6YS5vbihjLnNwbGl0KFxcXCIgXFxcIikuam9pbihcXFwiLmVkXFxcIitoK1xcXCIgXFxcIikrXFxcIi5lZFxcXCIraCxlKSxnLmluZGV4T2YoYS5nZXQoMCkpPDAmJmcucHVzaChhLmdldCgwKSl9ZnVuY3Rpb24gdChiLGMpe2Zvcih2YXIgZD0wO2Q8Yi5sZW5ndGg7ZCsrKWEoYltkXSkub2ZmKFxcXCIuZWRcXFwiK2MpfWZ1bmN0aW9uIHUoKXt0KEQsYi5pZCksRD1bXSwwPT1iLnNoYXJlZC5jb3VudCYmKHQoYi5zaGFyZWQuJF9ldmVudHMsYi5zaWQpLGIuc2hhcmVkLiRfZXZlbnRzPW51bGwpfWZ1bmN0aW9uIHYoYyxkLGUpe2lmKCFiLmVkaXQuaXNEaXNhYmxlZCgpfHxlKXt2YXIgZjtpZigwIT1jLmluZGV4T2YoXFxcInNoYXJlZC5cXFwiKSlmPUJbY107ZWxzZXtpZihiLnNoYXJlZC5jb3VudD4wKXJldHVybiExO2Y9Yi5zaGFyZWQuX2V2ZW50c1tjXX12YXIgZztpZihmKWZvcih2YXIgaD0wO2g8Zi5sZW5ndGg7aCsrKWlmKGc9ZltoXS5hcHBseShiLGQpLGc9PT0hMSlyZXR1cm4hMTtyZXR1cm4gZz1iLiRvZWwudHJpZ2dlckhhbmRsZXIoXFxcImZyb2FsYUVkaXRvci5cXFwiK2MsYS5tZXJnZShbYl0sZHx8W10pKSxnIT09ITEmJmd9fWZ1bmN0aW9uIHcoYyxkLGUpe2lmKCFiLmVkaXQuaXNEaXNhYmxlZCgpfHxlKXt2YXIgZjtpZigwIT1jLmluZGV4T2YoXFxcInNoYXJlZC5cXFwiKSlmPUJbY107ZWxzZXtpZihiLnNoYXJlZC5jb3VudD4wKXJldHVybiExO2Y9Yi5zaGFyZWQuX2V2ZW50c1tjXX12YXIgZztpZihmKWZvcih2YXIgaD0wO2g8Zi5sZW5ndGg7aCsrKWc9ZltoXS5hcHBseShiLFtkXSksXFxcInVuZGVmaW5lZFxcXCIhPXR5cGVvZiBnJiYoZD1nKTtyZXR1cm4gZz1iLiRvZWwudHJpZ2dlckhhbmRsZXIoXFxcImZyb2FsYUVkaXRvci5cXFwiK2MsYS5tZXJnZShbYl0sW2RdKSksXFxcInVuZGVmaW5lZFxcXCIhPXR5cGVvZiBnJiYoZD1nKSxkfX1mdW5jdGlvbiB4KCl7Zm9yKHZhciBhIGluIEIpQi5oYXNPd25Qcm9wZXJ0eShhKSYmZGVsZXRlIEJbYV19ZnVuY3Rpb24geSgpe2Zvcih2YXIgYSBpbiBiLnNoYXJlZC5fZXZlbnRzKWIuc2hhcmVkLl9ldmVudHMuaGFzT3duUHJvcGVydHkoYSkmJmRlbGV0ZSBiLnNoYXJlZC5fZXZlbnRzW2FdfWZ1bmN0aW9uIHooKXtiLnNoYXJlZC4kX2V2ZW50cz1iLnNoYXJlZC4kX2V2ZW50c3x8W10sYi5zaGFyZWQuX2V2ZW50cz17fSxrKCksZSgpLGcoKSxoKCksZigpLGooKSxuKCksZCgpLHIoXFxcImRlc3Ryb3lcXFwiLHgpLHIoXFxcInNoYXJlZC5kZXN0cm95XFxcIix5KX12YXIgQSxCPXt9LEM9ITEsRD1bXTtyZXR1cm57X2luaXQ6eixvbjpyLHRyaWdnZXI6dixiaW5kQ2xpY2s6cSxkaXNhYmxlQmx1cjpvLGVuYWJsZUJsdXI6bixibHVyQWN0aXZlOnAsZm9jdXM6aSxjaGFpblRyaWdnZXI6dywkb246cywkb2ZmOnV9fSxhLkZFLk1PRFVMRVMubm9kZT1mdW5jdGlvbihiKXtmdW5jdGlvbiBjKGEpe3JldHVybiBhJiZcXFwiSUZSQU1FXFxcIiE9YS50YWdOYW1lP0FycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGEuY2hpbGROb2Rlc3x8W10pOltdfWZ1bmN0aW9uIGQoYil7cmV0dXJuISFiJiYoYi5ub2RlVHlwZT09Tm9kZS5FTEVNRU5UX05PREUmJmEuRkUuQkxPQ0tfVEFHUy5pbmRleE9mKGIudGFnTmFtZS50b0xvd2VyQ2FzZSgpKT49MCl9ZnVuY3Rpb24gZShlLGYpe2lmKCFlKXJldHVybiEwO2lmKGUucXVlcnlTZWxlY3RvcihcXFwidGFibGVcXFwiKSlyZXR1cm4hMTt2YXIgZz1jKGUpOzE9PWcubGVuZ3RoJiZkKGdbMF0pJiYoZz1jKGdbMF0pKTtmb3IodmFyIGg9ITEsaT0wO2k8Zy5sZW5ndGg7aSsrKXt2YXIgaj1nW2ldO2lmKCEoZiYmYi5ub2RlLmhhc0NsYXNzKGosXFxcImZyLW1hcmtlclxcXCIpfHxqLm5vZGVUeXBlPT1Ob2RlLlRFWFRfTk9ERSYmMD09ai50ZXh0Q29udGVudC5sZW5ndGgpKXtpZihcXFwiQlJcXFwiIT1qLnRhZ05hbWUmJihqLnRleHRDb250ZW50fHxcXFwiXFxcIikucmVwbGFjZSgvXFxcXHUyMDBCL2dpLFxcXCJcXFwiKS5yZXBsYWNlKC9cXFxcbi9nLFxcXCJcXFwiKS5sZW5ndGg+MClyZXR1cm4hMTtpZihoKXJldHVybiExO1xcXCJCUlxcXCI9PWoudGFnTmFtZSYmKGg9ITApfX1yZXR1cm4hKGUucXVlcnlTZWxlY3RvckFsbChhLkZFLlZPSURfRUxFTUVOVFMuam9pbihcXFwiLFxcXCIpKS5sZW5ndGgtZS5xdWVyeVNlbGVjdG9yQWxsKFxcXCJiclxcXCIpLmxlbmd0aCkmJighZS5xdWVyeVNlbGVjdG9yKGIub3B0cy5odG1sQWxsb3dlZEVtcHR5VGFncy5qb2luKFxcXCI6bm90KC5mci1tYXJrZXIpLFxcXCIpK1xcXCI6bm90KC5mci1tYXJrZXIpXFxcIikmJighKGUucXVlcnlTZWxlY3RvckFsbChhLkZFLkJMT0NLX1RBR1Muam9pbihcXFwiLFxcXCIpKS5sZW5ndGg+MSkmJiFlLnF1ZXJ5U2VsZWN0b3IoYi5vcHRzLmh0bWxEb05vdFdyYXBUYWdzLmpvaW4oXFxcIjpub3QoLmZyLW1hcmtlciksXFxcIikrXFxcIjpub3QoLmZyLW1hcmtlcilcXFwiKSkpfWZ1bmN0aW9uIGYoYSl7Zm9yKDthJiZhLnBhcmVudE5vZGUhPT1iLmVsJiYoIWEucGFyZW50Tm9kZXx8IWIubm9kZS5oYXNDbGFzcyhhLnBhcmVudE5vZGUsXFxcImZyLWlubmVyXFxcIikpOylpZihhPWEucGFyZW50Tm9kZSxkKGEpKXJldHVybiBhO3JldHVybiBudWxsfWZ1bmN0aW9uIGcoYyxlLGYpe2lmKFxcXCJ1bmRlZmluZWRcXFwiPT10eXBlb2YgZSYmKGU9W10pLFxcXCJ1bmRlZmluZWRcXFwiPT10eXBlb2YgZiYmKGY9ITApLGUucHVzaChiLmVsKSxlLmluZGV4T2YoYy5wYXJlbnROb2RlKT49MHx8Yy5wYXJlbnROb2RlJiZiLm5vZGUuaGFzQ2xhc3MoYy5wYXJlbnROb2RlLFxcXCJmci1pbm5lclxcXCIpfHxjLnBhcmVudE5vZGUmJmEuRkUuU0lNUExFX0VOVEVSX1RBR1MuaW5kZXhPZihjLnBhcmVudE5vZGUudGFnTmFtZSk+PTAmJmYpcmV0dXJuIG51bGw7Zm9yKDtlLmluZGV4T2YoYy5wYXJlbnROb2RlKTwwJiZjLnBhcmVudE5vZGUmJiFiLm5vZGUuaGFzQ2xhc3MoYy5wYXJlbnROb2RlLFxcXCJmci1pbm5lclxcXCIpJiYoYS5GRS5TSU1QTEVfRU5URVJfVEFHUy5pbmRleE9mKGMucGFyZW50Tm9kZS50YWdOYW1lKTwwfHwhZikmJighZChjKXx8IWQoYy5wYXJlbnROb2RlKXx8IWYpOyljPWMucGFyZW50Tm9kZTtyZXR1cm4gY31mdW5jdGlvbiBoKGEpe3ZhciBiPXt9LGM9YS5hdHRyaWJ1dGVzO2lmKGMpZm9yKHZhciBkPTA7ZDxjLmxlbmd0aDtkKyspe3ZhciBlPWNbZF07YltlLm5vZGVOYW1lXT1lLnZhbHVlfXJldHVybiBifWZ1bmN0aW9uIGkoYSl7Zm9yKHZhciBiPVxcXCJcXFwiLGM9aChhKSxkPU9iamVjdC5rZXlzKGMpLnNvcnQoKSxlPTA7ZTxkLmxlbmd0aDtlKyspe3ZhciBmPWRbZV0sZz1jW2ZdO2IrPWcuaW5kZXhPZignXFxcIicpPDA/XFxcIiBcXFwiK2YrJz1cXFwiJytnKydcXFwiJzpcXFwiIFxcXCIrZitcXFwiPSdcXFwiK2crXFxcIidcXFwifXJldHVybiBifWZ1bmN0aW9uIGooYSl7Zm9yKHZhciBiPWEuYXR0cmlidXRlcyxjPTA7YzxiLmxlbmd0aDtjKyspe3ZhciBkPWJbY107YS5yZW1vdmVBdHRyaWJ1dGUoZC5ub2RlTmFtZSl9fWZ1bmN0aW9uIGsoYSl7cmV0dXJuXFxcIjxcXFwiK2EudGFnTmFtZS50b0xvd2VyQ2FzZSgpK2koYSkrXFxcIj5cXFwifWZ1bmN0aW9uIGwoYSl7cmV0dXJuXFxcIjwvXFxcIithLnRhZ05hbWUudG9Mb3dlckNhc2UoKStcXFwiPlxcXCJ9ZnVuY3Rpb24gbShhLGMpe1xcXCJ1bmRlZmluZWRcXFwiPT10eXBlb2YgYyYmKGM9ITApO2Zvcih2YXIgZD1hLnByZXZpb3VzU2libGluZztkJiZjJiZiLm5vZGUuaGFzQ2xhc3MoZCxcXFwiZnItbWFya2VyXFxcIik7KWQ9ZC5wcmV2aW91c1NpYmxpbmc7cmV0dXJuIWR8fGQubm9kZVR5cGU9PU5vZGUuVEVYVF9OT0RFJiZcXFwiXFxcIj09PWQudGV4dENvbnRlbnQmJm0oZCl9ZnVuY3Rpb24gbihhLGMpe1xcXCJ1bmRlZmluZWRcXFwiPT10eXBlb2YgYyYmKGM9ITApO2Zvcih2YXIgZD1hLm5leHRTaWJsaW5nO2QmJmMmJmIubm9kZS5oYXNDbGFzcyhkLFxcXCJmci1tYXJrZXJcXFwiKTspZD1kLm5leHRTaWJsaW5nO3JldHVybiFkfHxkLm5vZGVUeXBlPT1Ob2RlLlRFWFRfTk9ERSYmXFxcIlxcXCI9PT1kLnRleHRDb250ZW50JiZuKGQpfWZ1bmN0aW9uIG8oYil7cmV0dXJuIGImJmIubm9kZVR5cGU9PU5vZGUuRUxFTUVOVF9OT0RFJiZhLkZFLlZPSURfRUxFTUVOVFMuaW5kZXhPZigoYi50YWdOYW1lfHxcXFwiXFxcIikudG9Mb3dlckNhc2UoKSk+PTB9ZnVuY3Rpb24gcChhKXtyZXR1cm4hIWEmJltcXFwiVUxcXFwiLFxcXCJPTFxcXCJdLmluZGV4T2YoYS50YWdOYW1lKT49MH1mdW5jdGlvbiBxKGEpe3JldHVybiBhPT09Yi5lbH1mdW5jdGlvbiByKGEpe3JldHVybiBhJiZhLm5vZGVUeXBlPT1Ob2RlLkVMRU1FTlRfTk9ERSYmYS5nZXRBdHRyaWJ1dGUoXFxcImNsYXNzXFxcIikmJihhLmdldEF0dHJpYnV0ZShcXFwiY2xhc3NcXFwiKXx8XFxcIlxcXCIpLmluZGV4T2YoXFxcImZyLWRlbGV0YWJsZVxcXCIpPj0wfWZ1bmN0aW9uIHMoYSl7cmV0dXJuIGE9PT1iLmRvYy5hY3RpdmVFbGVtZW50JiYoIWIuZG9jLmhhc0ZvY3VzfHxiLmRvYy5oYXNGb2N1cygpKSYmISEocShhKXx8YS50eXBlfHxhLmhyZWZ8fH5hLnRhYkluZGV4KX1mdW5jdGlvbiB0KGEpe3JldHVybighYS5nZXRBdHRyaWJ1dGV8fFxcXCJmYWxzZVxcXCIhPWEuZ2V0QXR0cmlidXRlKFxcXCJjb250ZW50ZWRpdGFibGVcXFwiKSkmJltcXFwiU1RZTEVcXFwiLFxcXCJTQ1JJUFRcXFwiXS5pbmRleE9mKGEudGFnTmFtZSk8MH1mdW5jdGlvbiB1KGEsYil7cmV0dXJuIGEgaW5zdGFuY2VvZiBqUXVlcnkmJihhPWEuZ2V0KDApKSxhJiZhLmNsYXNzTGlzdCYmYS5jbGFzc0xpc3QuY29udGFpbnMoYil9ZnVuY3Rpb24gdihhKXtyZXR1cm4gYi5icm93c2VyLm1zaWU/YTp7YWNjZXB0Tm9kZTphfX1yZXR1cm57aXNCbG9jazpkLGlzRW1wdHk6ZSxibG9ja1BhcmVudDpmLGRlZXBlc3RQYXJlbnQ6ZyxyYXdBdHRyaWJ1dGVzOmgsYXR0cmlidXRlczppLGNsZWFyQXR0cmlidXRlczpqLG9wZW5UYWdTdHJpbmc6ayxjbG9zZVRhZ1N0cmluZzpsLGlzRmlyc3RTaWJsaW5nOm0saXNMYXN0U2libGluZzpuLGlzTGlzdDpwLGlzRWxlbWVudDpxLGNvbnRlbnRzOmMsaXNWb2lkOm8saGFzRm9jdXM6cyxpc0VkaXRhYmxlOnQsaXNEZWxldGFibGU6cixoYXNDbGFzczp1LGZpbHRlcjp2fX0sYS5GRS5JTlZJU0lCTEVfU1BBQ0U9XFxcIiYjODIwMztcXFwiLGEuRkUuU1RBUlRfTUFSS0VSPSc8c3BhbiBjbGFzcz1cXFwiZnItbWFya2VyXFxcIiBkYXRhLWlkPVxcXCIwXFxcIiBkYXRhLXR5cGU9XFxcInRydWVcXFwiIHN0eWxlPVxcXCJkaXNwbGF5OiBub25lOyBsaW5lLWhlaWdodDogMDtcXFwiPicrYS5GRS5JTlZJU0lCTEVfU1BBQ0UrXFxcIjwvc3Bhbj5cXFwiLGEuRkUuRU5EX01BUktFUj0nPHNwYW4gY2xhc3M9XFxcImZyLW1hcmtlclxcXCIgZGF0YS1pZD1cXFwiMFxcXCIgZGF0YS10eXBlPVxcXCJmYWxzZVxcXCIgc3R5bGU9XFxcImRpc3BsYXk6IG5vbmU7IGxpbmUtaGVpZ2h0OiAwO1xcXCI+JythLkZFLklOVklTSUJMRV9TUEFDRStcXFwiPC9zcGFuPlxcXCIsYS5GRS5NQVJLRVJTPWEuRkUuU1RBUlRfTUFSS0VSK2EuRkUuRU5EX01BUktFUixhLkZFLk1PRFVMRVMubWFya2Vycz1mdW5jdGlvbihiKXtmdW5jdGlvbiBjKGMsZCl7cmV0dXJuIGEoJzxzcGFuIGNsYXNzPVxcXCJmci1tYXJrZXJcXFwiIGRhdGEtaWQ9XFxcIicrZCsnXFxcIiBkYXRhLXR5cGU9XFxcIicrYysnXFxcIiBzdHlsZT1cXFwiZGlzcGxheTogJysoYi5icm93c2VyLnNhZmFyaT9cXFwibm9uZVxcXCI6XFxcImlubGluZS1ibG9ja1xcXCIpKyc7IGxpbmUtaGVpZ2h0OiAwO1xcXCI+JythLkZFLklOVklTSUJMRV9TUEFDRStcXFwiPC9zcGFuPlxcXCIsYi5kb2MpWzBdfWZ1bmN0aW9uIGQoZCxlLGYpe3RyeXt2YXIgZz1kLmNsb25lUmFuZ2UoKTtpZihnLmNvbGxhcHNlKGUpLGcuaW5zZXJ0Tm9kZShjKGUsZikpLGU9PT0hMCYmZC5jb2xsYXBzZWQpZm9yKHZhciBoPWIuJGVsLmZpbmQoJ3NwYW4uZnItbWFya2VyW2RhdGEtdHlwZT1cXFwidHJ1ZVxcXCJdW2RhdGEtaWQ9XFxcIicrZisnXFxcIl0nKSxpPWguZ2V0KDApLm5leHRTaWJsaW5nO2kmJmkubm9kZVR5cGU9PT1Ob2RlLlRFWFRfTk9ERSYmMD09PWkudGV4dENvbnRlbnQubGVuZ3RoOylhKGkpLnJlbW92ZSgpLGk9aC5uZXh0U2libGluZztpZihlPT09ITAmJiFkLmNvbGxhcHNlZCl7dmFyIGg9Yi4kZWwuZmluZCgnc3Bhbi5mci1tYXJrZXJbZGF0YS10eXBlPVxcXCJ0cnVlXFxcIl1bZGF0YS1pZD1cXFwiJytmKydcXFwiXScpLmdldCgwKSxpPWgubmV4dFNpYmxpbmc7aWYoaSYmaS5ub2RlVHlwZT09PU5vZGUuRUxFTUVOVF9OT0RFJiZiLm5vZGUuaXNCbG9jayhpKSl7dmFyIGo9W2ldO2RvIGk9alswXSxqPWIubm9kZS5jb250ZW50cyhpKTt3aGlsZShqWzBdJiZiLm5vZGUuaXNCbG9jayhqWzBdKSk7YShpKS5wcmVwZW5kKGEoaCkpfX1pZihlPT09ITEmJiFkLmNvbGxhcHNlZCl7dmFyIGg9Yi4kZWwuZmluZCgnc3Bhbi5mci1tYXJrZXJbZGF0YS10eXBlPVxcXCJmYWxzZVxcXCJdW2RhdGEtaWQ9XFxcIicrZisnXFxcIl0nKS5nZXQoMCksaT1oLnByZXZpb3VzU2libGluZztpZihpJiZpLm5vZGVUeXBlPT09Tm9kZS5FTEVNRU5UX05PREUmJmIubm9kZS5pc0Jsb2NrKGkpKXt2YXIgaj1baV07ZG8gaT1qW2oubGVuZ3RoLTFdLGo9Yi5ub2RlLmNvbnRlbnRzKGkpO3doaWxlKGpbai5sZW5ndGgtMV0mJmIubm9kZS5pc0Jsb2NrKGpbai5sZW5ndGgtMV0pKTthKGkpLmFwcGVuZChhKGgpKX1oLnBhcmVudE5vZGUmJltcXFwiVERcXFwiLFxcXCJUSFxcXCJdLmluZGV4T2YoaC5wYXJlbnROb2RlLnRhZ05hbWUpPj0wJiZoLnBhcmVudE5vZGUucHJldmlvdXNTaWJsaW5nJiYhaC5wcmV2aW91c1NpYmxpbmcmJmEoaC5wYXJlbnROb2RlLnByZXZpb3VzU2libGluZykuYXBwZW5kKGgpfXZhciBrPWIuJGVsLmZpbmQoJ3NwYW4uZnItbWFya2VyW2RhdGEtdHlwZT1cXFwiJytlKydcXFwiXVtkYXRhLWlkPVxcXCInK2YrJ1xcXCJdJykuZ2V0KDApO3JldHVybiBrJiYoay5zdHlsZS5kaXNwbGF5PVxcXCJub25lXFxcIiksa31jYXRjaChsKXtyZXR1cm4gbnVsbH19ZnVuY3Rpb24gZSgpe2lmKCFiLiR3cClyZXR1cm4gbnVsbDt0cnl7dmFyIGM9Yi5zZWxlY3Rpb24ucmFuZ2VzKDApLGQ9Yy5jb21tb25BbmNlc3RvckNvbnRhaW5lcjtpZihkIT1iLmVsJiYwPT1iLiRlbC5maW5kKGQpLmxlbmd0aClyZXR1cm4gbnVsbDt2YXIgZT1jLmNsb25lUmFuZ2UoKSxmPWMuY2xvbmVSYW5nZSgpO2UuY29sbGFwc2UoITApO3ZhciBnPWEoJzxzcGFuIGNsYXNzPVxcXCJmci1tYXJrZXJcXFwiIHN0eWxlPVxcXCJkaXNwbGF5OiBub25lOyBsaW5lLWhlaWdodDogMDtcXFwiPicrYS5GRS5JTlZJU0lCTEVfU1BBQ0UrXFxcIjwvc3Bhbj5cXFwiLGIuZG9jKVswXTtpZihlLmluc2VydE5vZGUoZyksZz1iLiRlbC5maW5kKFxcXCJzcGFuLmZyLW1hcmtlclxcXCIpLmdldCgwKSl7Zm9yKHZhciBoPWcubmV4dFNpYmxpbmc7aCYmaC5ub2RlVHlwZT09PU5vZGUuVEVYVF9OT0RFJiYwPT09aC50ZXh0Q29udGVudC5sZW5ndGg7KWEoaCkucmVtb3ZlKCksaD1iLiRlbC5maW5kKFxcXCJzcGFuLmZyLW1hcmtlclxcXCIpLmdldCgwKS5uZXh0U2libGluZztyZXR1cm4gYi5zZWxlY3Rpb24uY2xlYXIoKSxiLnNlbGVjdGlvbi5nZXQoKS5hZGRSYW5nZShmKSxnfXJldHVybiBudWxsfWNhdGNoKGkpe319ZnVuY3Rpb24gZigpe2Iuc2VsZWN0aW9uLmlzQ29sbGFwc2VkKCl8fGIuc2VsZWN0aW9uLnJlbW92ZSgpO3ZhciBjPWIuJGVsLmZpbmQoXFxcIi5mci1tYXJrZXJcXFwiKS5nZXQoMCk7aWYobnVsbD09YyYmKGM9ZSgpKSxudWxsPT1jKXJldHVybiBudWxsO3ZhciBkPWIubm9kZS5kZWVwZXN0UGFyZW50KGMpO2lmKGR8fChkPWIubm9kZS5ibG9ja1BhcmVudChjKSxkJiZcXFwiTElcXFwiIT1kLnRhZ05hbWUmJihkPW51bGwpKSxkKWlmKGIubm9kZS5pc0Jsb2NrKGQpJiZiLm5vZGUuaXNFbXB0eShkKSlhKGQpLnJlcGxhY2VXaXRoKCc8c3BhbiBjbGFzcz1cXFwiZnItbWFya2VyXFxcIj48L3NwYW4+Jyk7ZWxzZSBpZihiLmN1cnNvci5pc0F0U3RhcnQoYyxkKSlhKGQpLmJlZm9yZSgnPHNwYW4gY2xhc3M9XFxcImZyLW1hcmtlclxcXCI+PC9zcGFuPicpLGEoYykucmVtb3ZlKCk7ZWxzZSBpZihiLmN1cnNvci5pc0F0RW5kKGMsZCkpYShkKS5hZnRlcignPHNwYW4gY2xhc3M9XFxcImZyLW1hcmtlclxcXCI+PC9zcGFuPicpLGEoYykucmVtb3ZlKCk7ZWxzZXt2YXIgZj1jLGc9XFxcIlxcXCIsaD1cXFwiXFxcIjtkbyBmPWYucGFyZW50Tm9kZSxnKz1iLm5vZGUuY2xvc2VUYWdTdHJpbmcoZiksaD1iLm5vZGUub3BlblRhZ1N0cmluZyhmKStoO3doaWxlKGYhPWQpO2EoYykucmVwbGFjZVdpdGgoJzxzcGFuIGlkPVxcXCJmci1icmVha1xcXCI+PC9zcGFuPicpO3ZhciBpPWIubm9kZS5vcGVuVGFnU3RyaW5nKGQpK2EoZCkuaHRtbCgpK2Iubm9kZS5jbG9zZVRhZ1N0cmluZyhkKTtpPWkucmVwbGFjZSgvPHNwYW4gaWQ9XFxcImZyLWJyZWFrXFxcIj48XFxcXC9zcGFuPi9nLGcrJzxzcGFuIGNsYXNzPVxcXCJmci1tYXJrZXJcXFwiPjwvc3Bhbj4nK2gpLGEoZCkucmVwbGFjZVdpdGgoaSl9cmV0dXJuIGIuJGVsLmZpbmQoXFxcIi5mci1tYXJrZXJcXFwiKS5nZXQoMCl9ZnVuY3Rpb24gZyhhKXt2YXIgYz1hLmNsaWVudFgsZD1hLmNsaWVudFk7aCgpO3ZhciBmLGc9bnVsbDtpZihcXFwidW5kZWZpbmVkXFxcIiE9dHlwZW9mIGIuZG9jLmNhcmV0UG9zaXRpb25Gcm9tUG9pbnQ/KGY9Yi5kb2MuY2FyZXRQb3NpdGlvbkZyb21Qb2ludChjLGQpLGc9Yi5kb2MuY3JlYXRlUmFuZ2UoKSxnLnNldFN0YXJ0KGYub2Zmc2V0Tm9kZSxmLm9mZnNldCksZy5zZXRFbmQoZi5vZmZzZXROb2RlLGYub2Zmc2V0KSk6XFxcInVuZGVmaW5lZFxcXCIhPXR5cGVvZiBiLmRvYy5jYXJldFJhbmdlRnJvbVBvaW50JiYoZj1iLmRvYy5jYXJldFJhbmdlRnJvbVBvaW50KGMsZCksZz1iLmRvYy5jcmVhdGVSYW5nZSgpLGcuc2V0U3RhcnQoZi5zdGFydENvbnRhaW5lcixmLnN0YXJ0T2Zmc2V0KSxnLnNldEVuZChmLnN0YXJ0Q29udGFpbmVyLGYuc3RhcnRPZmZzZXQpKSxudWxsIT09ZyYmXFxcInVuZGVmaW5lZFxcXCIhPXR5cGVvZiBiLndpbi5nZXRTZWxlY3Rpb24pe3ZhciBpPWIud2luLmdldFNlbGVjdGlvbigpO2kucmVtb3ZlQWxsUmFuZ2VzKCksaS5hZGRSYW5nZShnKX1lbHNlIGlmKFxcXCJ1bmRlZmluZWRcXFwiIT10eXBlb2YgYi5kb2MuYm9keS5jcmVhdGVUZXh0UmFuZ2UpdHJ5e2c9Yi5kb2MuYm9keS5jcmVhdGVUZXh0UmFuZ2UoKSxnLm1vdmVUb1BvaW50KGMsZCk7dmFyIGo9Zy5kdXBsaWNhdGUoKTtqLm1vdmVUb1BvaW50KGMsZCksZy5zZXRFbmRQb2ludChcXFwiRW5kVG9FbmRcXFwiLGopLGcuc2VsZWN0KCl9Y2F0Y2goayl7cmV0dXJuITF9ZSgpfWZ1bmN0aW9uIGgoKXtiLiRlbC5maW5kKFxcXCIuZnItbWFya2VyXFxcIikucmVtb3ZlKCl9cmV0dXJue3BsYWNlOmQsaW5zZXJ0OmUsc3BsaXQ6ZixpbnNlcnRBdFBvaW50OmcscmVtb3ZlOmh9fSxhLkZFLk1PRFVMRVMuc2VsZWN0aW9uPWZ1bmN0aW9uKGIpe2Z1bmN0aW9uIGMoKXt2YXIgYT1cXFwiXFxcIjtyZXR1cm4gYi53aW4uZ2V0U2VsZWN0aW9uP2E9Yi53aW4uZ2V0U2VsZWN0aW9uKCk6Yi5kb2MuZ2V0U2VsZWN0aW9uP2E9Yi5kb2MuZ2V0U2VsZWN0aW9uKCk6Yi5kb2Muc2VsZWN0aW9uJiYoYT1iLmRvYy5zZWxlY3Rpb24uY3JlYXRlUmFuZ2UoKS50ZXh0KSxhLnRvU3RyaW5nKCl9ZnVuY3Rpb24gZCgpe3ZhciBhPVxcXCJcXFwiO3JldHVybiBhPWIud2luLmdldFNlbGVjdGlvbj9iLndpbi5nZXRTZWxlY3Rpb24oKTpiLmRvYy5nZXRTZWxlY3Rpb24/Yi5kb2MuZ2V0U2VsZWN0aW9uKCk6Yi5kb2Muc2VsZWN0aW9uLmNyZWF0ZVJhbmdlKCl9ZnVuY3Rpb24gZShhKXt2YXIgYz1kKCksZT1bXTtpZihjJiZjLmdldFJhbmdlQXQmJmMucmFuZ2VDb3VudClmb3IodmFyIGU9W10sZj0wO2Y8Yy5yYW5nZUNvdW50O2YrKyllLnB1c2goYy5nZXRSYW5nZUF0KGYpKTtlbHNlIGU9Yi5kb2MuY3JlYXRlUmFuZ2U/W2IuZG9jLmNyZWF0ZVJhbmdlKCldOltdO3JldHVyblxcXCJ1bmRlZmluZWRcXFwiIT10eXBlb2YgYT9lW2FdOmV9ZnVuY3Rpb24gZigpe3ZhciBhPWQoKTt0cnl7YS5yZW1vdmVBbGxSYW5nZXM/YS5yZW1vdmVBbGxSYW5nZXMoKTphLmVtcHR5P2EuZW1wdHkoKTphLmNsZWFyJiZhLmNsZWFyKCl9Y2F0Y2goYil7fX1mdW5jdGlvbiBnKCl7dmFyIGY9ZCgpO3RyeXtpZihmLnJhbmdlQ291bnQpe3ZhciBnPWUoMCksaD1nLnN0YXJ0Q29udGFpbmVyO2lmKGgubm9kZVR5cGU9PU5vZGUuVEVYVF9OT0RFJiZnLnN0YXJ0T2Zmc2V0PT0oaC50ZXh0Q29udGVudHx8XFxcIlxcXCIpLmxlbmd0aCYmaC5uZXh0U2libGluZyYmKGg9aC5uZXh0U2libGluZyksaC5ub2RlVHlwZT09Tm9kZS5FTEVNRU5UX05PREUpe3ZhciBpPSExO2lmKGguY2hpbGROb2Rlcy5sZW5ndGg+MCYmaC5jaGlsZE5vZGVzW2cuc3RhcnRPZmZzZXRdKXtmb3IodmFyIGo9aC5jaGlsZE5vZGVzW2cuc3RhcnRPZmZzZXRdO2omJmoubm9kZVR5cGU9PU5vZGUuVEVYVF9OT0RFJiYwPT1qLnRleHRDb250ZW50Lmxlbmd0aDspaj1qLm5leHRTaWJsaW5nO2lmKGomJmoudGV4dENvbnRlbnQucmVwbGFjZSgvXFxcXHUyMDBCL2csXFxcIlxcXCIpPT09YygpLnJlcGxhY2UoL1xcXFx1MjAwQi9nLFxcXCJcXFwiKSYmKGg9aixpPSEwKSwhaSYmaC5jaGlsZE5vZGVzLmxlbmd0aD4xJiZnLnN0YXJ0T2Zmc2V0PjAmJmguY2hpbGROb2Rlc1tnLnN0YXJ0T2Zmc2V0LTFdKXtmb3IodmFyIGo9aC5jaGlsZE5vZGVzW2cuc3RhcnRPZmZzZXQtMV07aiYmai5ub2RlVHlwZT09Tm9kZS5URVhUX05PREUmJjA9PWoudGV4dENvbnRlbnQubGVuZ3RoOylqPWoubmV4dFNpYmxpbmc7aiYmai50ZXh0Q29udGVudC5yZXBsYWNlKC9cXFxcdTIwMEIvZyxcXFwiXFxcIik9PT1jKCkucmVwbGFjZSgvXFxcXHUyMDBCL2csXFxcIlxcXCIpJiYoaD1qLGk9ITApfX1lbHNlIGlmKCFnLmNvbGxhcHNlZCYmaC5uZXh0U2libGluZyYmaC5uZXh0U2libGluZy5ub2RlVHlwZT09Tm9kZS5FTEVNRU5UX05PREUpe3ZhciBqPWgubmV4dFNpYmxpbmc7aiYmai50ZXh0Q29udGVudC5yZXBsYWNlKC9cXFxcdTIwMEIvZyxcXFwiXFxcIik9PT1jKCkucmVwbGFjZSgvXFxcXHUyMDBCL2csXFxcIlxcXCIpJiYoaD1qLGk9ITApfSFpJiZoLmNoaWxkTm9kZXMubGVuZ3RoPjAmJmEoaC5jaGlsZE5vZGVzWzBdKS50ZXh0KCkucmVwbGFjZSgvXFxcXHUyMDBCL2csXFxcIlxcXCIpPT09YygpLnJlcGxhY2UoL1xcXFx1MjAwQi9nLFxcXCJcXFwiKSYmW1xcXCJCUlxcXCIsXFxcIklNR1xcXCIsXFxcIkhSXFxcIl0uaW5kZXhPZihoLmNoaWxkTm9kZXNbMF0udGFnTmFtZSk8MCYmKGg9aC5jaGlsZE5vZGVzWzBdKX1mb3IoO2gubm9kZVR5cGUhPU5vZGUuRUxFTUVOVF9OT0RFJiZoLnBhcmVudE5vZGU7KWg9aC5wYXJlbnROb2RlO2Zvcih2YXIgaz1oO2smJlxcXCJIVE1MXFxcIiE9ay50YWdOYW1lOyl7aWYoaz09Yi5lbClyZXR1cm4gaDtrPWEoaykucGFyZW50KClbMF19fX1jYXRjaChsKXt9cmV0dXJuIGIuZWx9ZnVuY3Rpb24gaCgpe3ZhciBmPWQoKTt0cnl7aWYoZi5yYW5nZUNvdW50KXt2YXIgZz1lKDApLGg9Zy5lbmRDb250YWluZXI7aWYoaC5ub2RlVHlwZT09Tm9kZS5FTEVNRU5UX05PREUpe3ZhciBpPSExO2lmKGguY2hpbGROb2Rlcy5sZW5ndGg+MCYmaC5jaGlsZE5vZGVzW2cuZW5kT2Zmc2V0XSYmYShoLmNoaWxkTm9kZXNbZy5lbmRPZmZzZXRdKS50ZXh0KCk9PT1jKCkpaD1oLmNoaWxkTm9kZXNbZy5lbmRPZmZzZXRdLGk9ITA7ZWxzZSBpZighZy5jb2xsYXBzZWQmJmgucHJldmlvdXNTaWJsaW5nJiZoLnByZXZpb3VzU2libGluZy5ub2RlVHlwZT09Tm9kZS5FTEVNRU5UX05PREUpe3ZhciBqPWgucHJldmlvdXNTaWJsaW5nO2omJmoudGV4dENvbnRlbnQucmVwbGFjZSgvXFxcXHUyMDBCL2csXFxcIlxcXCIpPT09YygpLnJlcGxhY2UoL1xcXFx1MjAwQi9nLFxcXCJcXFwiKSYmKGg9aixpPSEwKX1lbHNlIGlmKCFnLmNvbGxhcHNlZCYmaC5jaGlsZE5vZGVzLmxlbmd0aD4wJiZoLmNoaWxkTm9kZXNbZy5lbmRPZmZzZXRdKXt2YXIgaj1oLmNoaWxkTm9kZXNbZy5lbmRPZmZzZXRdLnByZXZpb3VzU2libGluZztqLm5vZGVUeXBlPT1Ob2RlLkVMRU1FTlRfTk9ERSYmaiYmai50ZXh0Q29udGVudC5yZXBsYWNlKC9cXFxcdTIwMEIvZyxcXFwiXFxcIik9PT1jKCkucmVwbGFjZSgvXFxcXHUyMDBCL2csXFxcIlxcXCIpJiYoaD1qLGk9ITApfSFpJiZoLmNoaWxkTm9kZXMubGVuZ3RoPjAmJmEoaC5jaGlsZE5vZGVzW2guY2hpbGROb2Rlcy5sZW5ndGgtMV0pLnRleHQoKT09PWMoKSYmW1xcXCJCUlxcXCIsXFxcIklNR1xcXCIsXFxcIkhSXFxcIl0uaW5kZXhPZihoLmNoaWxkTm9kZXNbaC5jaGlsZE5vZGVzLmxlbmd0aC0xXS50YWdOYW1lKTwwJiYoaD1oLmNoaWxkTm9kZXNbaC5jaGlsZE5vZGVzLmxlbmd0aC0xXSl9Zm9yKGgubm9kZVR5cGU9PU5vZGUuVEVYVF9OT0RFJiYwPT1nLmVuZE9mZnNldCYmaC5wcmV2aW91c1NpYmxpbmcmJmgucHJldmlvdXNTaWJsaW5nLm5vZGVUeXBlPT1Ob2RlLkVMRU1FTlRfTk9ERSYmKGg9aC5wcmV2aW91c1NpYmxpbmcpO2gubm9kZVR5cGUhPU5vZGUuRUxFTUVOVF9OT0RFJiZoLnBhcmVudE5vZGU7KWg9aC5wYXJlbnROb2RlO2Zvcih2YXIgaz1oO2smJlxcXCJIVE1MXFxcIiE9ay50YWdOYW1lOyl7aWYoaz09Yi5lbClyZXR1cm4gaDtrPWEoaykucGFyZW50KClbMF19fX1jYXRjaChsKXt9cmV0dXJuIGIuZWx9ZnVuY3Rpb24gaShhLGIpe3ZhciBjPWE7cmV0dXJuIGMubm9kZVR5cGU9PU5vZGUuRUxFTUVOVF9OT0RFJiZjLmNoaWxkTm9kZXMubGVuZ3RoPjAmJmMuY2hpbGROb2Rlc1tiXSYmKGM9Yy5jaGlsZE5vZGVzW2JdKSxjLm5vZGVUeXBlPT1Ob2RlLlRFWFRfTk9ERSYmKGM9Yy5wYXJlbnROb2RlKSxjfWZ1bmN0aW9uIGooKXt2YXIgYz1bXSxmPWQoKTtpZih0KCkmJmYucmFuZ2VDb3VudClmb3IodmFyIGc9ZSgpLGg9MDtoPGcubGVuZ3RoO2grKyl7dmFyIGo9Z1toXSxrPWkoai5zdGFydENvbnRhaW5lcixqLnN0YXJ0T2Zmc2V0KSxsPWkoai5lbmRDb250YWluZXIsai5lbmRPZmZzZXQpO2Iubm9kZS5pc0Jsb2NrKGspJiZjLmluZGV4T2Yoayk8MCYmYy5wdXNoKGspO3ZhciBtPWIubm9kZS5ibG9ja1BhcmVudChrKTttJiZjLmluZGV4T2YobSk8MCYmYy5wdXNoKG0pO2Zvcih2YXIgbj1bXSxvPWs7byE9PWwmJm8hPT1iLmVsOyluLmluZGV4T2Yobyk8MCYmby5jaGlsZHJlbiYmby5jaGlsZHJlbi5sZW5ndGg/KG4ucHVzaChvKSxvPW8uY2hpbGRyZW5bMF0pOm8ubmV4dFNpYmxpbmc/bz1vLm5leHRTaWJsaW5nOm8ucGFyZW50Tm9kZSYmKG89by5wYXJlbnROb2RlLG4ucHVzaChvKSksYi5ub2RlLmlzQmxvY2sobykmJm4uaW5kZXhPZihvKTwwJiZjLmluZGV4T2Yobyk8MCYmKG8hPT1sfHxqLmVuZE9mZnNldD4wKSYmYy5wdXNoKG8pO2Iubm9kZS5pc0Jsb2NrKGwpJiZjLmluZGV4T2YobCk8MCYmai5lbmRPZmZzZXQ+MCYmYy5wdXNoKGwpO3ZhciBtPWIubm9kZS5ibG9ja1BhcmVudChsKTttJiZjLmluZGV4T2YobSk8MCYmYy5wdXNoKG0pfWZvcih2YXIgaD1jLmxlbmd0aC0xO2g+MDtoLS0pYShjW2hdKS5maW5kKGMpLmxlbmd0aCYmKFxcXCJMSVxcXCIhPWNbaF0udGFnTmFtZXx8MT09Y1toXS5jaGlsZHJlbi5sZW5ndGgmJmMuaW5kZXhPZihjW2hdLmNoaWxkcmVuWzBdKT49MCkmJmMuc3BsaWNlKGgsMSk7cmV0dXJuIGN9ZnVuY3Rpb24gaygpe2lmKGIuJHdwKXtiLm1hcmtlcnMucmVtb3ZlKCk7Zm9yKHZhciBhPWUoKSxjPVtdLGQ9MDtkPGEubGVuZ3RoO2QrKylpZihhW2RdLnN0YXJ0Q29udGFpbmVyIT09Yi5kb2Mpe3ZhciBmPWFbZF0sZz1mLmNvbGxhcHNlZCxoPWIubWFya2Vycy5wbGFjZShmLCEwLGQpLGk9Yi5tYXJrZXJzLnBsYWNlKGYsITEsZCk7aWYoYi5lbC5ub3JtYWxpemUoKSxiLmJyb3dzZXIuc2FmYXJpJiYhZyl7dmFyIGY9Yi5kb2MuY3JlYXRlUmFuZ2UoKTtmLnNldFN0YXJ0QWZ0ZXIoaCksZi5zZXRFbmRCZWZvcmUoaSksYy5wdXNoKGYpfX1pZihiLmJyb3dzZXIuc2FmYXJpJiZjLmxlbmd0aCl7Yi5zZWxlY3Rpb24uY2xlYXIoKTtmb3IodmFyIGQ9MDtkPGMubGVuZ3RoO2QrKyliLnNlbGVjdGlvbi5nZXQoKS5hZGRSYW5nZShjW2RdKX19fWZ1bmN0aW9uIGwoKXt2YXIgYz1iLmVsLnF1ZXJ5U2VsZWN0b3JBbGwoJy5mci1tYXJrZXJbZGF0YS10eXBlPVxcXCJ0cnVlXFxcIl0nKTtpZighYi4kd3ApcmV0dXJuIGIubWFya2Vycy5yZW1vdmUoKSwhMTtpZigwPT09Yy5sZW5ndGgpcmV0dXJuITE7aWYoYi5icm93c2VyLm1zaWV8fGIuYnJvd3Nlci5lZGdlKWZvcih2YXIgZT0wO2U8Yy5sZW5ndGg7ZSsrKWNbZV0uc3R5bGUuZGlzcGxheT1cXFwiaW5saW5lLWJsb2NrXFxcIjtiLmNvcmUuaGFzRm9jdXMoKXx8Yi5icm93c2VyLm1zaWV8fGIuYnJvd3Nlci53ZWJraXR8fGIuJGVsLmZvY3VzKCksZigpO2Zvcih2YXIgZz1kKCksZT0wO2U8Yy5sZW5ndGg7ZSsrKXt2YXIgaD1hKGNbZV0pLmRhdGEoXFxcImlkXFxcIiksaT1jW2VdLGo9Yi5kb2MuY3JlYXRlUmFuZ2UoKSxrPWIuJGVsLmZpbmQoJy5mci1tYXJrZXJbZGF0YS10eXBlPVxcXCJmYWxzZVxcXCJdW2RhdGEtaWQ9XFxcIicraCsnXFxcIl0nKTsoYi5icm93c2VyLm1zaWV8fGIuYnJvd3Nlci5lZGdlKSYmay5jc3MoXFxcImRpc3BsYXlcXFwiLFxcXCJpbmxpbmUtYmxvY2tcXFwiKTt2YXIgbD1udWxsO2lmKGsubGVuZ3RoPjApe2s9a1swXTt0cnl7Zm9yKHZhciBuPSExLG89aS5uZXh0U2libGluZztvJiZvLm5vZGVUeXBlPT1Ob2RlLlRFWFRfTk9ERSYmMD09by50ZXh0Q29udGVudC5sZW5ndGg7KXt2YXIgcD1vO289by5uZXh0U2libGluZyxhKHApLnJlbW92ZSgpfWZvcih2YXIgcT1rLm5leHRTaWJsaW5nO3EmJnEubm9kZVR5cGU9PU5vZGUuVEVYVF9OT0RFJiYwPT1xLnRleHRDb250ZW50Lmxlbmd0aDspe3ZhciBwPXE7cT1xLm5leHRTaWJsaW5nLGEocCkucmVtb3ZlKCl9aWYoaS5uZXh0U2libGluZz09a3x8ay5uZXh0U2libGluZz09aSl7Zm9yKHZhciByPWkubmV4dFNpYmxpbmc9PWs/aTprLHM9cj09aT9rOmksdD1yLnByZXZpb3VzU2libGluZzt0JiZ0Lm5vZGVUeXBlPT1Ob2RlLlRFWFRfTk9ERSYmMD09dC5sZW5ndGg7KXt2YXIgcD10O3Q9dC5wcmV2aW91c1NpYmxpbmcsYShwKS5yZW1vdmUoKX1pZih0JiZ0Lm5vZGVUeXBlPT1Ob2RlLlRFWFRfTk9ERSlmb3IoO3QmJnQucHJldmlvdXNTaWJsaW5nJiZ0LnByZXZpb3VzU2libGluZy5ub2RlVHlwZT09Tm9kZS5URVhUX05PREU7KXQucHJldmlvdXNTaWJsaW5nLnRleHRDb250ZW50PXQucHJldmlvdXNTaWJsaW5nLnRleHRDb250ZW50K3QudGV4dENvbnRlbnQsdD10LnByZXZpb3VzU2libGluZyxhKHQubmV4dFNpYmxpbmcpLnJlbW92ZSgpO2Zvcih2YXIgdT1zLm5leHRTaWJsaW5nO3UmJnUubm9kZVR5cGU9PU5vZGUuVEVYVF9OT0RFJiYwPT11Lmxlbmd0aDspe3ZhciBwPXU7dT11Lm5leHRTaWJsaW5nLGEocCkucmVtb3ZlKCl9aWYodSYmdS5ub2RlVHlwZT09Tm9kZS5URVhUX05PREUpZm9yKDt1JiZ1Lm5leHRTaWJsaW5nJiZ1Lm5leHRTaWJsaW5nLm5vZGVUeXBlPT1Ob2RlLlRFWFRfTk9ERTspdS5uZXh0U2libGluZy50ZXh0Q29udGVudD11LnRleHRDb250ZW50K3UubmV4dFNpYmxpbmcudGV4dENvbnRlbnQsdT11Lm5leHRTaWJsaW5nLGEodS5wcmV2aW91c1NpYmxpbmcpLnJlbW92ZSgpO2lmKHQmJihiLm5vZGUuaXNWb2lkKHQpfHxiLm5vZGUuaXNCbG9jayh0KSkmJih0PW51bGwpLHUmJihiLm5vZGUuaXNWb2lkKHUpfHxiLm5vZGUuaXNCbG9jayh1KSkmJih1PW51bGwpLHQmJnUmJnQubm9kZVR5cGU9PU5vZGUuVEVYVF9OT0RFJiZ1Lm5vZGVUeXBlPT1Ob2RlLlRFWFRfTk9ERSl7YShpKS5yZW1vdmUoKSxhKGspLnJlbW92ZSgpO3ZhciB2PXQudGV4dENvbnRlbnQubGVuZ3RoO3QudGV4dENvbnRlbnQ9dC50ZXh0Q29udGVudCt1LnRleHRDb250ZW50LGEodSkucmVtb3ZlKCksYi5zcGFjZXMubm9ybWFsaXplKHQpLGouc2V0U3RhcnQodCx2KSxqLnNldEVuZCh0LHYpLG49ITB9ZWxzZSF0JiZ1JiZ1Lm5vZGVUeXBlPT1Ob2RlLlRFWFRfTk9ERT8oYShpKS5yZW1vdmUoKSxhKGspLnJlbW92ZSgpLGIuc3BhY2VzLm5vcm1hbGl6ZSh1KSxsPWEoYi5kb2MuY3JlYXRlVGV4dE5vZGUoXFxcIlxcXFx1MjAwYlxcXCIpKSxhKHUpLmJlZm9yZShsKSxqLnNldFN0YXJ0KHUsMCksai5zZXRFbmQodSwwKSxuPSEwKTohdSYmdCYmdC5ub2RlVHlwZT09Tm9kZS5URVhUX05PREUmJihhKGkpLnJlbW92ZSgpLGEoaykucmVtb3ZlKCksYi5zcGFjZXMubm9ybWFsaXplKHQpLGw9YShiLmRvYy5jcmVhdGVUZXh0Tm9kZShcXFwiXFxcXHUyMDBiXFxcIikpLGEodCkuYWZ0ZXIobCksai5zZXRTdGFydCh0LHQudGV4dENvbnRlbnQubGVuZ3RoKSxqLnNldEVuZCh0LHQudGV4dENvbnRlbnQubGVuZ3RoKSxuPSEwKX1pZighbil7dmFyIHcseDtpZihiLmJyb3dzZXIuY2hyb21lJiZpLm5leHRTaWJsaW5nPT1rKXc9bShrLGosITApfHxqLnNldFN0YXJ0QWZ0ZXIoaykseD1tKGksaiwhMSl8fGouc2V0RW5kQmVmb3JlKGkpO2Vsc2V7aS5wcmV2aW91c1NpYmxpbmc9PWsmJihpPWssaz1pLm5leHRTaWJsaW5nKSxrLm5leHRTaWJsaW5nJiZcXFwiQlJcXFwiPT09ay5uZXh0U2libGluZy50YWdOYW1lfHwhay5uZXh0U2libGluZyYmYi5ub2RlLmlzQmxvY2soaS5wcmV2aW91c1NpYmxpbmcpfHxpLnByZXZpb3VzU2libGluZyYmXFxcIkJSXFxcIj09aS5wcmV2aW91c1NpYmxpbmcudGFnTmFtZXx8KGkuc3R5bGUuZGlzcGxheT1cXFwiaW5saW5lXFxcIixrLnN0eWxlLmRpc3BsYXk9XFxcImlubGluZVxcXCIsbD1hKGIuZG9jLmNyZWF0ZVRleHROb2RlKFxcXCJcXFxcdTIwMGJcXFwiKSkpO3ZhciB5PWkucHJldmlvdXNTaWJsaW5nO3kmJnkuc3R5bGUmJlxcXCJibG9ja1xcXCI9PWIud2luLmdldENvbXB1dGVkU3R5bGUoeSkuZGlzcGxheSYmIWIub3B0cy5lbnRlcj09YS5GRS5FTlRFUl9CUj8oai5zZXRFbmRBZnRlcih5KSxqLnNldFN0YXJ0QWZ0ZXIoeSkpOih3PW0oaSxqLCEwKXx8YShpKS5iZWZvcmUobCkmJmouc2V0U3RhcnRCZWZvcmUoaSkseD1tKGssaiwhMSl8fGEoaykuYWZ0ZXIobCkmJmouc2V0RW5kQWZ0ZXIoaykpfVxcXCJmdW5jdGlvblxcXCI9PXR5cGVvZiB3JiZ3KCksXFxcImZ1bmN0aW9uXFxcIj09dHlwZW9mIHgmJngoKX19Y2F0Y2goeil7fX1sJiZsLnJlbW92ZSgpO3RyeXtnLmFkZFJhbmdlKGopfWNhdGNoKHope319Yi5tYXJrZXJzLnJlbW92ZSgpfWZ1bmN0aW9uIG0oYyxkLGUpe3ZhciBmPWMucHJldmlvdXNTaWJsaW5nLGc9Yy5uZXh0U2libGluZztpZihmJiZnJiZmLm5vZGVUeXBlPT1Ob2RlLlRFWFRfTk9ERSYmZy5ub2RlVHlwZT09Tm9kZS5URVhUX05PREUpe3ZhciBoPWYudGV4dENvbnRlbnQubGVuZ3RoO3JldHVybiBlPyhnLnRleHRDb250ZW50PWYudGV4dENvbnRlbnQrZy50ZXh0Q29udGVudCxhKGYpLnJlbW92ZSgpLGEoYykucmVtb3ZlKCksYi5zcGFjZXMubm9ybWFsaXplKGcpLGZ1bmN0aW9uKCl7ZC5zZXRTdGFydChnLGgpfSk6KGYudGV4dENvbnRlbnQ9Zi50ZXh0Q29udGVudCtnLnRleHRDb250ZW50LGEoZykucmVtb3ZlKCksYShjKS5yZW1vdmUoKSxiLnNwYWNlcy5ub3JtYWxpemUoZiksZnVuY3Rpb24oKXtkLnNldEVuZChmLGgpfSl9aWYoZiYmIWcmJmYubm9kZVR5cGU9PU5vZGUuVEVYVF9OT0RFKXt2YXIgaD1mLnRleHRDb250ZW50Lmxlbmd0aDtyZXR1cm4gZT8oYi5zcGFjZXMubm9ybWFsaXplKGYpLGZ1bmN0aW9uKCl7ZC5zZXRTdGFydChmLGgpfSk6KGIuc3BhY2VzLm5vcm1hbGl6ZShmKSxmdW5jdGlvbigpe2Quc2V0RW5kKGYsaCl9KX1yZXR1cm4hKCFnfHxmfHxnLm5vZGVUeXBlIT1Ob2RlLlRFWFRfTk9ERSkmJihlPyhiLnNwYWNlcy5ub3JtYWxpemUoZyksZnVuY3Rpb24oKXtkLnNldFN0YXJ0KGcsMCl9KTooYi5zcGFjZXMubm9ybWFsaXplKGcpLGZ1bmN0aW9uKCl7ZC5zZXRFbmQoZywwKX0pKX1mdW5jdGlvbiBuKCl7cmV0dXJuITB9ZnVuY3Rpb24gbygpe2Zvcih2YXIgYT1lKCksYj0wO2I8YS5sZW5ndGg7YisrKWlmKCFhW2JdLmNvbGxhcHNlZClyZXR1cm4hMTtyZXR1cm4hMH1mdW5jdGlvbiBwKGEpe3ZhciBjLGQsZT0hMSxmPSExO2lmKGIud2luLmdldFNlbGVjdGlvbil7dmFyIGc9Yi53aW4uZ2V0U2VsZWN0aW9uKCk7Zy5yYW5nZUNvdW50JiYoYz1nLmdldFJhbmdlQXQoMCksZD1jLmNsb25lUmFuZ2UoKSxkLnNlbGVjdE5vZGVDb250ZW50cyhhKSxkLnNldEVuZChjLnN0YXJ0Q29udGFpbmVyLGMuc3RhcnRPZmZzZXQpLGU9XFxcIlxcXCI9PT1kLnRvU3RyaW5nKCksZC5zZWxlY3ROb2RlQ29udGVudHMoYSksZC5zZXRTdGFydChjLmVuZENvbnRhaW5lcixjLmVuZE9mZnNldCksZj1cXFwiXFxcIj09PWQudG9TdHJpbmcoKSl9ZWxzZSBiLmRvYy5zZWxlY3Rpb24mJlxcXCJDb250cm9sXFxcIiE9Yi5kb2Muc2VsZWN0aW9uLnR5cGUmJihjPWIuZG9jLnNlbGVjdGlvbi5jcmVhdGVSYW5nZSgpLGQ9Yy5kdXBsaWNhdGUoKSxkLm1vdmVUb0VsZW1lbnRUZXh0KGEpLGQuc2V0RW5kUG9pbnQoXFxcIkVuZFRvU3RhcnRcXFwiLGMpLFxcbmU9XFxcIlxcXCI9PT1kLnRleHQsZC5tb3ZlVG9FbGVtZW50VGV4dChhKSxkLnNldEVuZFBvaW50KFxcXCJTdGFydFRvRW5kXFxcIixjKSxmPVxcXCJcXFwiPT09ZC50ZXh0KTtyZXR1cm57YXRTdGFydDplLGF0RW5kOmZ9fWZ1bmN0aW9uIHEoKXtpZihvKCkpcmV0dXJuITE7Yi4kZWwuZmluZChcXFwidGQsIHRoLCBpbWdcXFwiKS5wcmVwZW5kKCc8c3BhbiBjbGFzcz1cXFwiZnItbWtcXFwiPicrYS5GRS5JTlZJU0lCTEVfU1BBQ0UrXFxcIjwvc3Bhbj5cXFwiKTt2YXIgYz0hMSxkPXAoYi5lbCk7cmV0dXJuIGQuYXRTdGFydCYmZC5hdEVuZCYmKGM9ITApLGIuJGVsLmZpbmQoXFxcIi5mci1ta1xcXCIpLnJlbW92ZSgpLGN9ZnVuY3Rpb24gcihjLGQpe1xcXCJ1bmRlZmluZWRcXFwiPT10eXBlb2YgZCYmKGQ9ITApO3ZhciBlPWEoYykuaHRtbCgpO2UmJmUucmVwbGFjZSgvXFxcXHUyMDBiL2csXFxcIlxcXCIpLmxlbmd0aCE9ZS5sZW5ndGgmJmEoYykuaHRtbChlLnJlcGxhY2UoL1xcXFx1MjAwYi9nLFxcXCJcXFwiKSk7Zm9yKHZhciBmPWIubm9kZS5jb250ZW50cyhjKSxnPTA7ZzxmLmxlbmd0aDtnKyspZltnXS5ub2RlVHlwZSE9Tm9kZS5FTEVNRU5UX05PREU/YShmW2ddKS5yZW1vdmUoKToocihmW2ddLDA9PWcpLDA9PWcmJihkPSExKSk7Yy5ub2RlVHlwZT09Tm9kZS5URVhUX05PREU/YShjKS5yZXBsYWNlV2l0aCgnPHNwYW4gZGF0YS1maXJzdD1cXFwidHJ1ZVxcXCIgZGF0YS10ZXh0PVxcXCJ0cnVlXFxcIj48L3NwYW4+Jyk6ZCYmYShjKS5hdHRyKFxcXCJkYXRhLWZpcnN0XFxcIiwhMCl9ZnVuY3Rpb24gcyhjLGQpe3ZhciBlPWIubm9kZS5jb250ZW50cyhjLmdldCgwKSk7W1xcXCJURFxcXCIsXFxcIlRIXFxcIl0uaW5kZXhPZihjLmdldCgwKS50YWdOYW1lKT49MCYmMT09Yy5maW5kKFxcXCIuZnItbWFya2VyXFxcIikubGVuZ3RoJiZiLm5vZGUuaGFzQ2xhc3MoZVswXSxcXFwiZnItbWFya2VyXFxcIikmJmMuYXR0cihcXFwiZGF0YS1kZWwtY2VsbFxcXCIsITApO2Zvcih2YXIgZj0wO2Y8ZS5sZW5ndGg7ZisrKXt2YXIgZz1lW2ZdO2Iubm9kZS5oYXNDbGFzcyhnLFxcXCJmci1tYXJrZXJcXFwiKT9kPShkKzEpJTI6ZD9hKGcpLmZpbmQoXFxcIi5mci1tYXJrZXJcXFwiKS5sZW5ndGg+MD9kPXMoYShnKSxkKTpbXFxcIlREXFxcIixcXFwiVEhcXFwiXS5pbmRleE9mKGcudGFnTmFtZSk8MCYmIWIubm9kZS5oYXNDbGFzcyhnLFxcXCJmci1pbm5lclxcXCIpPyFiLm9wdHMua2VlcEZvcm1hdE9uRGVsZXRlfHxiLiRlbC5maW5kKFxcXCJbZGF0YS1maXJzdF1cXFwiKS5sZW5ndGg+MD9hKGcpLnJlbW92ZSgpOnIoZyk6Yi5ub2RlLmhhc0NsYXNzKGcsXFxcImZyLWlubmVyXFxcIik/MD09YShnKS5maW5kKFxcXCIuZnItaW5uZXJcXFwiKS5sZW5ndGg/YShnKS5odG1sKFxcXCI8YnI+XFxcIik6YShnKS5maW5kKFxcXCIuZnItaW5uZXJcXFwiKS5maWx0ZXIoZnVuY3Rpb24oKXtyZXR1cm4gMD09YSh0aGlzKS5maW5kKFxcXCJmci1pbm5lclxcXCIpLmxlbmd0aH0pLmh0bWwoXFxcIjxicj5cXFwiKTooYShnKS5lbXB0eSgpLGEoZykuYXR0cihcXFwiZGF0YS1kZWwtY2VsbFxcXCIsITApKTphKGcpLmZpbmQoXFxcIi5mci1tYXJrZXJcXFwiKS5sZW5ndGg+MCYmKGQ9cyhhKGcpLGQpKX1yZXR1cm4gZH1mdW5jdGlvbiB0KCl7dHJ5e2lmKCFiLiR3cClyZXR1cm4hMTtmb3IodmFyIGE9ZSgwKSxjPWEuY29tbW9uQW5jZXN0b3JDb250YWluZXI7YyYmIWIubm9kZS5pc0VsZW1lbnQoYyk7KWM9Yy5wYXJlbnROb2RlO3JldHVybiEhYi5ub2RlLmlzRWxlbWVudChjKX1jYXRjaChkKXtyZXR1cm4hMX19ZnVuY3Rpb24gdSgpe2lmKG8oKSlyZXR1cm4hMDtrKCk7Zm9yKHZhciBjPWZ1bmN0aW9uKGIpe2Zvcih2YXIgYz1iLnByZXZpb3VzU2libGluZztjJiZjLm5vZGVUeXBlPT1Ob2RlLlRFWFRfTk9ERSYmMD09Yy50ZXh0Q29udGVudC5sZW5ndGg7KXt2YXIgZD1jLGM9Yy5wcmV2aW91c1NpYmxpbmc7YShkKS5yZW1vdmUoKX1yZXR1cm4gY30sZD1mdW5jdGlvbihiKXtmb3IodmFyIGM9Yi5uZXh0U2libGluZztjJiZjLm5vZGVUeXBlPT1Ob2RlLlRFWFRfTk9ERSYmMD09Yy50ZXh0Q29udGVudC5sZW5ndGg7KXt2YXIgZD1jLGM9Yy5uZXh0U2libGluZzthKGQpLnJlbW92ZSgpfXJldHVybiBjfSxlPWIuJGVsLmZpbmQoJy5mci1tYXJrZXJbZGF0YS10eXBlPVxcXCJ0cnVlXFxcIl0nKSxmPTA7ZjxlLmxlbmd0aDtmKyspZm9yKHZhciBnPWVbZl07IWMoZykmJiFiLm5vZGUuaXNCbG9jayhnLnBhcmVudE5vZGUpJiYhYi4kZWwuaXMoZy5wYXJlbnROb2RlKTspYShnLnBhcmVudE5vZGUpLmJlZm9yZShnKTtmb3IodmFyIGg9Yi4kZWwuZmluZCgnLmZyLW1hcmtlcltkYXRhLXR5cGU9XFxcImZhbHNlXFxcIl0nKSxmPTA7ZjxoLmxlbmd0aDtmKyspe2Zvcih2YXIgaT1oW2ZdOyFkKGkpJiYhYi5ub2RlLmlzQmxvY2soaS5wYXJlbnROb2RlKSYmIWIuJGVsLmlzKGkucGFyZW50Tm9kZSk7KWEoaS5wYXJlbnROb2RlKS5hZnRlcihpKTtpLnBhcmVudE5vZGUmJmIubm9kZS5pc0Jsb2NrKGkucGFyZW50Tm9kZSkmJmIubm9kZS5pc0VtcHR5KGkucGFyZW50Tm9kZSkmJiFiLiRlbC5pcyhpLnBhcmVudE5vZGUpJiZiLm9wdHMua2VlcEZvcm1hdE9uRGVsZXRlJiZhKGkucGFyZW50Tm9kZSkuYWZ0ZXIoaSl9aWYobigpKXtzKGIuJGVsLDApO3ZhciBqPWIuJGVsLmZpbmQoJ1tkYXRhLWZpcnN0PVxcXCJ0cnVlXFxcIl0nKTtpZihqLmxlbmd0aCliLiRlbC5maW5kKFxcXCIuZnItbWFya2VyXFxcIikucmVtb3ZlKCksai5hcHBlbmQoYS5GRS5JTlZJU0lCTEVfU1BBQ0UrYS5GRS5NQVJLRVJTKS5yZW1vdmVBdHRyKFxcXCJkYXRhLWZpcnN0XFxcIiksai5hdHRyKFxcXCJkYXRhLXRleHRcXFwiKSYmai5yZXBsYWNlV2l0aChqLmh0bWwoKSk7ZWxzZXtiLiRlbC5maW5kKFxcXCJ0YWJsZVxcXCIpLmZpbHRlcihmdW5jdGlvbigpe3ZhciBiPWEodGhpcykuZmluZChcXFwiW2RhdGEtZGVsLWNlbGxdXFxcIikubGVuZ3RoPjAmJmEodGhpcykuZmluZChcXFwiW2RhdGEtZGVsLWNlbGxdXFxcIikubGVuZ3RoPT1hKHRoaXMpLmZpbmQoXFxcInRkLCB0aFxcXCIpLmxlbmd0aDtyZXR1cm4gYn0pLnJlbW92ZSgpLGIuJGVsLmZpbmQoXFxcIltkYXRhLWRlbC1jZWxsXVxcXCIpLnJlbW92ZUF0dHIoXFxcImRhdGEtZGVsLWNlbGxcXFwiKTtmb3IodmFyIGU9Yi4kZWwuZmluZCgnLmZyLW1hcmtlcltkYXRhLXR5cGU9XFxcInRydWVcXFwiXScpLGY9MDtmPGUubGVuZ3RoO2YrKyl7dmFyIG09ZVtmXSxwPW0ubmV4dFNpYmxpbmcscT1iLiRlbC5maW5kKCcuZnItbWFya2VyW2RhdGEtdHlwZT1cXFwiZmFsc2VcXFwiXVtkYXRhLWlkPVxcXCInK2EobSkuZGF0YShcXFwiaWRcXFwiKSsnXFxcIl0nKS5nZXQoMCk7aWYocSl7aWYocCYmcD09cSk7ZWxzZSBpZihtKXt2YXIgcj1iLm5vZGUuYmxvY2tQYXJlbnQobSksdD1iLm5vZGUuYmxvY2tQYXJlbnQocSksdT0hMSx2PSExO2lmKHImJltcXFwiVUxcXFwiLFxcXCJPTFxcXCJdLmluZGV4T2Yoci50YWdOYW1lKT49MCYmKHI9bnVsbCx1PSEwKSx0JiZbXFxcIlVMXFxcIixcXFwiT0xcXFwiXS5pbmRleE9mKHQudGFnTmFtZSk+PTAmJih0PW51bGwsdj0hMCksYShtKS5hZnRlcihxKSxyPT10KTtlbHNlIGlmKG51bGwhPXJ8fHUpaWYobnVsbCE9dHx8dnx8MCE9YShyKS5wYXJlbnRzVW50aWwoYi4kZWwsXFxcInRhYmxlXFxcIikubGVuZ3RoKXImJnQmJjA9PWEocikucGFyZW50c1VudGlsKGIuJGVsLFxcXCJ0YWJsZVxcXCIpLmxlbmd0aCYmMD09YSh0KS5wYXJlbnRzVW50aWwoYi4kZWwsXFxcInRhYmxlXFxcIikubGVuZ3RoJiYoYShyKS5hcHBlbmQoYSh0KS5odG1sKCkpLGEodCkucmVtb3ZlKCkpO2Vsc2V7Zm9yKHZhciBwPXI7IXAubmV4dFNpYmxpbmcmJnAucGFyZW50Tm9kZSE9Yi5lbDspcD1wLnBhcmVudE5vZGU7Zm9yKHA9cC5uZXh0U2libGluZztwJiZcXFwiQlJcXFwiIT1wLnRhZ05hbWU7KXt2YXIgdz1wLm5leHRTaWJsaW5nO2EocikuYXBwZW5kKHApLHA9d31wJiZcXFwiQlJcXFwiPT1wLnRhZ05hbWUmJmEocCkucmVtb3ZlKCl9ZWxzZXt2YXIgeD1iLm5vZGUuZGVlcGVzdFBhcmVudChtKTt4PyhhKHgpLmFmdGVyKGEodCkuaHRtbCgpKSxhKHQpLnJlbW92ZSgpKTowPT1hKHQpLnBhcmVudHNVbnRpbChiLiRlbCxcXFwidGFibGVcXFwiKS5sZW5ndGgmJihhKG0pLm5leHQoKS5hZnRlcihhKHQpLmh0bWwoKSksYSh0KS5yZW1vdmUoKSl9fX1lbHNlIHE9YShtKS5jbG9uZSgpLmF0dHIoXFxcImRhdGEtdHlwZVxcXCIsITEpLGEobSkuYWZ0ZXIocSl9fX1iLm9wdHMua2VlcEZvcm1hdE9uRGVsZXRlfHxiLmh0bWwuZmlsbEVtcHR5QmxvY2tzKCksYi5odG1sLmNsZWFuRW1wdHlUYWdzKCEwKSxiLmNsZWFuLmxpc3RzKCksYi5zcGFjZXMubm9ybWFsaXplKCk7dmFyIHk9Yi4kZWwuZmluZChcXFwiLmZyLW1hcmtlcjpsYXN0XFxcIikuZ2V0KDApLHo9Yi4kZWwuZmluZChcXFwiLmZyLW1hcmtlcjpmaXJzdFxcXCIpLmdldCgwKTsheS5uZXh0U2libGluZyYmei5wcmV2aW91c1NpYmxpbmcmJlxcXCJCUlxcXCI9PXoucHJldmlvdXNTaWJsaW5nLnRhZ05hbWUmJmIubm9kZS5pc0VsZW1lbnQoeS5wYXJlbnROb2RlKSYmYi5ub2RlLmlzRWxlbWVudCh6LnBhcmVudE5vZGUpJiZiLiRlbC5hcHBlbmQoXFxcIjxicj5cXFwiKSxsKCl9ZnVuY3Rpb24gdihjKXtpZighY3x8Yy5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKFxcXCJmci1tYXJrZXJcXFwiKS5sZW5ndGg+MClyZXR1cm4hMTtmb3IodmFyIGQ9Yy5maXJzdENoaWxkO2QmJmIubm9kZS5pc0Jsb2NrKGQpOyljPWQsZD1kLmZpcnN0Q2hpbGQ7Yy5pbm5lckhUTUw9YS5GRS5NQVJLRVJTK2MuaW5uZXJIVE1MfWZ1bmN0aW9uIHcoYyl7aWYoIWN8fGMuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShcXFwiZnItbWFya2VyXFxcIikubGVuZ3RoPjApcmV0dXJuITE7Zm9yKHZhciBkPWMubGFzdENoaWxkO2QmJmIubm9kZS5pc0Jsb2NrKGQpOyljPWQsZD1kLmxhc3RDaGlsZDtjLmlubmVySFRNTD1jLmlubmVySFRNTCthLkZFLk1BUktFUlN9ZnVuY3Rpb24geChjLGQpe1xcXCJ1bmRlZmluZWRcXFwiPT10eXBlb2YgZCYmKGQ9ITApO2Zvcih2YXIgZT1jLnByZXZpb3VzU2libGluZztlJiZlLm5vZGVUeXBlPT1Ob2RlLlRFWFRfTk9ERSYmMD09ZS50ZXh0Q29udGVudC5sZW5ndGg7KWU9ZS5wcmV2aW91c1NpYmxpbmc7cmV0dXJuIGU/KGIubm9kZS5pc0Jsb2NrKGUpP3coZSk6XFxcIkJSXFxcIj09ZS50YWdOYW1lP2EoZSkuYmVmb3JlKGEuRkUuTUFSS0VSUyk6YShlKS5hZnRlcihhLkZFLk1BUktFUlMpLCEwKTohIWQmJihiLm5vZGUuaXNCbG9jayhjKT92KGMpOmEoYykuYmVmb3JlKGEuRkUuTUFSS0VSUyksITApfWZ1bmN0aW9uIHkoYyxkKXtcXFwidW5kZWZpbmVkXFxcIj09dHlwZW9mIGQmJihkPSEwKTtmb3IodmFyIGU9Yy5uZXh0U2libGluZztlJiZlLm5vZGVUeXBlPT1Ob2RlLlRFWFRfTk9ERSYmMD09ZS50ZXh0Q29udGVudC5sZW5ndGg7KWU9ZS5uZXh0U2libGluZztyZXR1cm4gZT8oYi5ub2RlLmlzQmxvY2soZSk/dihlKTphKGUpLmJlZm9yZShhLkZFLk1BUktFUlMpLCEwKTohIWQmJihiLm5vZGUuaXNCbG9jayhjKT93KGMpOmEoYykuYWZ0ZXIoYS5GRS5NQVJLRVJTKSwhMCl9cmV0dXJue3RleHQ6YyxnZXQ6ZCxyYW5nZXM6ZSxjbGVhcjpmLGVsZW1lbnQ6ZyxlbmRFbGVtZW50Omgsc2F2ZTprLHJlc3RvcmU6bCxpc0NvbGxhcHNlZDpvLGlzRnVsbDpxLGluRWRpdG9yOnQscmVtb3ZlOnUsYmxvY2tzOmosaW5mbzpwLHNldEF0RW5kOncsc2V0QXRTdGFydDp2LHNldEJlZm9yZTp4LHNldEFmdGVyOnkscmFuZ2VFbGVtZW50Oml9fSxhLmV4dGVuZChhLkZFLkRFRkFVTFRTLHtodG1sQWxsb3dlZFRhZ3M6W1xcXCJhXFxcIixcXFwiYWJiclxcXCIsXFxcImFkZHJlc3NcXFwiLFxcXCJhcmVhXFxcIixcXFwiYXJ0aWNsZVxcXCIsXFxcImFzaWRlXFxcIixcXFwiYXVkaW9cXFwiLFxcXCJiXFxcIixcXFwiYmFzZVxcXCIsXFxcImJkaVxcXCIsXFxcImJkb1xcXCIsXFxcImJsb2NrcXVvdGVcXFwiLFxcXCJiclxcXCIsXFxcImJ1dHRvblxcXCIsXFxcImNhbnZhc1xcXCIsXFxcImNhcHRpb25cXFwiLFxcXCJjaXRlXFxcIixcXFwiY29kZVxcXCIsXFxcImNvbFxcXCIsXFxcImNvbGdyb3VwXFxcIixcXFwiZGF0YWxpc3RcXFwiLFxcXCJkZFxcXCIsXFxcImRlbFxcXCIsXFxcImRldGFpbHNcXFwiLFxcXCJkZm5cXFwiLFxcXCJkaWFsb2dcXFwiLFxcXCJkaXZcXFwiLFxcXCJkbFxcXCIsXFxcImR0XFxcIixcXFwiZW1cXFwiLFxcXCJlbWJlZFxcXCIsXFxcImZpZWxkc2V0XFxcIixcXFwiZmlnY2FwdGlvblxcXCIsXFxcImZpZ3VyZVxcXCIsXFxcImZvb3RlclxcXCIsXFxcImZvcm1cXFwiLFxcXCJoMVxcXCIsXFxcImgyXFxcIixcXFwiaDNcXFwiLFxcXCJoNFxcXCIsXFxcImg1XFxcIixcXFwiaDZcXFwiLFxcXCJoZWFkZXJcXFwiLFxcXCJoZ3JvdXBcXFwiLFxcXCJoclxcXCIsXFxcImlcXFwiLFxcXCJpZnJhbWVcXFwiLFxcXCJpbWdcXFwiLFxcXCJpbnB1dFxcXCIsXFxcImluc1xcXCIsXFxcImtiZFxcXCIsXFxcImtleWdlblxcXCIsXFxcImxhYmVsXFxcIixcXFwibGVnZW5kXFxcIixcXFwibGlcXFwiLFxcXCJsaW5rXFxcIixcXFwibWFpblxcXCIsXFxcIm1hcFxcXCIsXFxcIm1hcmtcXFwiLFxcXCJtZW51XFxcIixcXFwibWVudWl0ZW1cXFwiLFxcXCJtZXRlclxcXCIsXFxcIm5hdlxcXCIsXFxcIm5vc2NyaXB0XFxcIixcXFwib2JqZWN0XFxcIixcXFwib2xcXFwiLFxcXCJvcHRncm91cFxcXCIsXFxcIm9wdGlvblxcXCIsXFxcIm91dHB1dFxcXCIsXFxcInBcXFwiLFxcXCJwYXJhbVxcXCIsXFxcInByZVxcXCIsXFxcInByb2dyZXNzXFxcIixcXFwicXVldWVcXFwiLFxcXCJycFxcXCIsXFxcInJ0XFxcIixcXFwicnVieVxcXCIsXFxcInNcXFwiLFxcXCJzYW1wXFxcIixcXFwic2NyaXB0XFxcIixcXFwic3R5bGVcXFwiLFxcXCJzZWN0aW9uXFxcIixcXFwic2VsZWN0XFxcIixcXFwic21hbGxcXFwiLFxcXCJzb3VyY2VcXFwiLFxcXCJzcGFuXFxcIixcXFwic3RyaWtlXFxcIixcXFwic3Ryb25nXFxcIixcXFwic3ViXFxcIixcXFwic3VtbWFyeVxcXCIsXFxcInN1cFxcXCIsXFxcInRhYmxlXFxcIixcXFwidGJvZHlcXFwiLFxcXCJ0ZFxcXCIsXFxcInRleHRhcmVhXFxcIixcXFwidGZvb3RcXFwiLFxcXCJ0aFxcXCIsXFxcInRoZWFkXFxcIixcXFwidGltZVxcXCIsXFxcInRyXFxcIixcXFwidHJhY2tcXFwiLFxcXCJ1XFxcIixcXFwidWxcXFwiLFxcXCJ2YXJcXFwiLFxcXCJ2aWRlb1xcXCIsXFxcIndiclxcXCJdLGh0bWxSZW1vdmVUYWdzOltcXFwic2NyaXB0XFxcIixcXFwic3R5bGVcXFwiXSxodG1sQWxsb3dlZEF0dHJzOltcXFwiYWNjZXB0XFxcIixcXFwiYWNjZXB0LWNoYXJzZXRcXFwiLFxcXCJhY2Nlc3NrZXlcXFwiLFxcXCJhY3Rpb25cXFwiLFxcXCJhbGlnblxcXCIsXFxcImFsbG93ZnVsbHNjcmVlblxcXCIsXFxcImFsbG93dHJhbnNwYXJlbmN5XFxcIixcXFwiYWx0XFxcIixcXFwiYXN5bmNcXFwiLFxcXCJhdXRvY29tcGxldGVcXFwiLFxcXCJhdXRvZm9jdXNcXFwiLFxcXCJhdXRvcGxheVxcXCIsXFxcImF1dG9zYXZlXFxcIixcXFwiYmFja2dyb3VuZFxcXCIsXFxcImJnY29sb3JcXFwiLFxcXCJib3JkZXJcXFwiLFxcXCJjaGFyc2V0XFxcIixcXFwiY2VsbHBhZGRpbmdcXFwiLFxcXCJjZWxsc3BhY2luZ1xcXCIsXFxcImNoZWNrZWRcXFwiLFxcXCJjaXRlXFxcIixcXFwiY2xhc3NcXFwiLFxcXCJjb2xvclxcXCIsXFxcImNvbHNcXFwiLFxcXCJjb2xzcGFuXFxcIixcXFwiY29udGVudFxcXCIsXFxcImNvbnRlbnRlZGl0YWJsZVxcXCIsXFxcImNvbnRleHRtZW51XFxcIixcXFwiY29udHJvbHNcXFwiLFxcXCJjb29yZHNcXFwiLFxcXCJkYXRhXFxcIixcXFwiZGF0YS0uKlxcXCIsXFxcImRhdGV0aW1lXFxcIixcXFwiZGVmYXVsdFxcXCIsXFxcImRlZmVyXFxcIixcXFwiZGlyXFxcIixcXFwiZGlybmFtZVxcXCIsXFxcImRpc2FibGVkXFxcIixcXFwiZG93bmxvYWRcXFwiLFxcXCJkcmFnZ2FibGVcXFwiLFxcXCJkcm9wem9uZVxcXCIsXFxcImVuY3R5cGVcXFwiLFxcXCJmb3JcXFwiLFxcXCJmb3JtXFxcIixcXFwiZm9ybWFjdGlvblxcXCIsXFxcImZyYW1lYm9yZGVyXFxcIixcXFwiaGVhZGVyc1xcXCIsXFxcImhlaWdodFxcXCIsXFxcImhpZGRlblxcXCIsXFxcImhpZ2hcXFwiLFxcXCJocmVmXFxcIixcXFwiaHJlZmxhbmdcXFwiLFxcXCJodHRwLWVxdWl2XFxcIixcXFwiaWNvblxcXCIsXFxcImlkXFxcIixcXFwiaXNtYXBcXFwiLFxcXCJpdGVtcHJvcFxcXCIsXFxcImtleXR5cGVcXFwiLFxcXCJraW5kXFxcIixcXFwibGFiZWxcXFwiLFxcXCJsYW5nXFxcIixcXFwibGFuZ3VhZ2VcXFwiLFxcXCJsaXN0XFxcIixcXFwibG9vcFxcXCIsXFxcImxvd1xcXCIsXFxcIm1heFxcXCIsXFxcIm1heGxlbmd0aFxcXCIsXFxcIm1lZGlhXFxcIixcXFwibWV0aG9kXFxcIixcXFwibWluXFxcIixcXFwibW96YWxsb3dmdWxsc2NyZWVuXFxcIixcXFwibXVsdGlwbGVcXFwiLFxcXCJuYW1lXFxcIixcXFwibm92YWxpZGF0ZVxcXCIsXFxcIm9wZW5cXFwiLFxcXCJvcHRpbXVtXFxcIixcXFwicGF0dGVyblxcXCIsXFxcInBpbmdcXFwiLFxcXCJwbGFjZWhvbGRlclxcXCIsXFxcInBvc3RlclxcXCIsXFxcInByZWxvYWRcXFwiLFxcXCJwdWJkYXRlXFxcIixcXFwicmFkaW9ncm91cFxcXCIsXFxcInJlYWRvbmx5XFxcIixcXFwicmVsXFxcIixcXFwicmVxdWlyZWRcXFwiLFxcXCJyZXZlcnNlZFxcXCIsXFxcInJvd3NcXFwiLFxcXCJyb3dzcGFuXFxcIixcXFwic2FuZGJveFxcXCIsXFxcInNjb3BlXFxcIixcXFwic2NvcGVkXFxcIixcXFwic2Nyb2xsaW5nXFxcIixcXFwic2VhbWxlc3NcXFwiLFxcXCJzZWxlY3RlZFxcXCIsXFxcInNoYXBlXFxcIixcXFwic2l6ZVxcXCIsXFxcInNpemVzXFxcIixcXFwic3BhblxcXCIsXFxcInNyY1xcXCIsXFxcInNyY2RvY1xcXCIsXFxcInNyY2xhbmdcXFwiLFxcXCJzcmNzZXRcXFwiLFxcXCJzdGFydFxcXCIsXFxcInN0ZXBcXFwiLFxcXCJzdW1tYXJ5XFxcIixcXFwic3BlbGxjaGVja1xcXCIsXFxcInN0eWxlXFxcIixcXFwidGFiaW5kZXhcXFwiLFxcXCJ0YXJnZXRcXFwiLFxcXCJ0aXRsZVxcXCIsXFxcInR5cGVcXFwiLFxcXCJ0cmFuc2xhdGVcXFwiLFxcXCJ1c2VtYXBcXFwiLFxcXCJ2YWx1ZVxcXCIsXFxcInZhbGlnblxcXCIsXFxcIndlYmtpdGFsbG93ZnVsbHNjcmVlblxcXCIsXFxcIndpZHRoXFxcIixcXFwid3JhcFxcXCJdLGh0bWxBbGxvd0NvbW1lbnRzOiEwLGZ1bGxQYWdlOiExfSksYS5GRS5IVE1MNU1hcD17QjpcXFwiU1RST05HXFxcIixJOlxcXCJFTVxcXCIsU1RSSUtFOlxcXCJTXFxcIn0sYS5GRS5NT0RVTEVTLmNsZWFuPWZ1bmN0aW9uKGIpe2Z1bmN0aW9uIGMoYSl7aWYoYS5ub2RlVHlwZT09Tm9kZS5FTEVNRU5UX05PREUmJmEuZ2V0QXR0cmlidXRlKFxcXCJjbGFzc1xcXCIpJiZhLmdldEF0dHJpYnV0ZShcXFwiY2xhc3NcXFwiKS5pbmRleE9mKFxcXCJmci1tYXJrZXJcXFwiKT49MClyZXR1cm4hMTt2YXIgZCxlPWIubm9kZS5jb250ZW50cyhhKSxmPVtdO2ZvcihkPTA7ZDxlLmxlbmd0aDtkKyspZVtkXS5ub2RlVHlwZSE9Tm9kZS5FTEVNRU5UX05PREV8fGIubm9kZS5pc1ZvaWQoZVtkXSk/ZVtkXS5ub2RlVHlwZT09Tm9kZS5URVhUX05PREUmJihlW2RdLnRleHRDb250ZW50PWVbZF0udGV4dENvbnRlbnQucmVwbGFjZSgvXFxcXHUyMDBiL2csXFxcIlxcXCIpLnJlcGxhY2UoLyYvZyxcXFwiJmFtcDtcXFwiKSk6ZVtkXS50ZXh0Q29udGVudC5yZXBsYWNlKC9cXFxcdTIwMGIvZyxcXFwiXFxcIikubGVuZ3RoIT1lW2RdLnRleHRDb250ZW50Lmxlbmd0aCYmYyhlW2RdKTtpZihhLm5vZGVUeXBlPT1Ob2RlLkVMRU1FTlRfTk9ERSYmIWIubm9kZS5pc1ZvaWQoYSkmJihhLm5vcm1hbGl6ZSgpLGU9Yi5ub2RlLmNvbnRlbnRzKGEpLGY9YS5xdWVyeVNlbGVjdG9yQWxsKFxcXCIuZnItbWFya2VyXFxcIiksZS5sZW5ndGgtZi5sZW5ndGg9PTApKXtmb3IoZD0wO2Q8ZS5sZW5ndGg7ZCsrKWlmKChlW2RdLmdldEF0dHJpYnV0ZShcXFwiY2xhc3NcXFwiKXx8XFxcIlxcXCIpLmluZGV4T2YoXFxcImZyLW1hcmtlclxcXCIpPDApcmV0dXJuITE7Zm9yKGQ9MDtkPGYubGVuZ3RoO2QrKylhLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGZbZF0uY2xvbmVOb2RlKCEwKSxhKTtyZXR1cm4gYS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGEpLCExfX1mdW5jdGlvbiBkKGEpe2lmKGEubm9kZVR5cGU9PU5vZGUuQ09NTUVOVF9OT0RFKXJldHVyblxcXCI8IS0tXFxcIithLm5vZGVWYWx1ZStcXFwiLS0+XFxcIjtpZihhLm5vZGVUeXBlPT1Ob2RlLlRFWFRfTk9ERSlyZXR1cm4gYS50ZXh0Q29udGVudC5yZXBsYWNlKC9cXFxcJi9nLFxcXCImYW1wO1xcXCIpLnJlcGxhY2UoL1xcXFw8L2csXFxcIiZsdDtcXFwiKS5yZXBsYWNlKC9cXFxcPi9nLFxcXCImZ3Q7XFxcIikucmVwbGFjZSgvXFxcXHUwMEEwL2csXFxcIiZuYnNwO1xcXCIpO2lmKGEubm9kZVR5cGUhPU5vZGUuRUxFTUVOVF9OT0RFKXJldHVybiBhLm91dGVySFRNTDtpZihhLm5vZGVUeXBlPT1Ob2RlLkVMRU1FTlRfTk9ERSYmW1xcXCJTVFlMRVxcXCIsXFxcIlNDUklQVFxcXCJdLmluZGV4T2YoYS50YWdOYW1lKT49MClyZXR1cm4gYS5vdXRlckhUTUw7aWYoYS5ub2RlVHlwZT09Tm9kZS5FTEVNRU5UX05PREUmJlxcXCJzdmdcXFwiPT1hLnRhZ05hbWUpe3ZhciBjPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXFxcImRpdlxcXCIpLGU9YS5jbG9uZU5vZGUoITApO3JldHVybiBjLmFwcGVuZENoaWxkKGUpLGMuaW5uZXJIVE1MfWlmKFxcXCJJRlJBTUVcXFwiPT1hLnRhZ05hbWUpcmV0dXJuIGEub3V0ZXJIVE1MO3ZhciBmPWEuY2hpbGROb2RlcztpZigwPT09Zi5sZW5ndGgpcmV0dXJuIGEub3V0ZXJIVE1MO2Zvcih2YXIgZz1cXFwiXFxcIixoPTA7aDxmLmxlbmd0aDtoKyspZys9ZChmW2hdKTtyZXR1cm4gYi5ub2RlLm9wZW5UYWdTdHJpbmcoYSkrZytiLm5vZGUuY2xvc2VUYWdTdHJpbmcoYSl9ZnVuY3Rpb24gZShhKXtyZXR1cm4gSD1bXSxhPWEucmVwbGFjZSgvPHNjcmlwdFxcXFxiW148XSooPzooPyE8XFxcXC9zY3JpcHQ+KTxbXjxdKikqPFxcXFwvc2NyaXB0Pi9naSxmdW5jdGlvbihhKXtyZXR1cm4gSC5wdXNoKGEpLFxcXCJbRlJPQUxBLkVESVRPUi5TQ1JJUFQgXFxcIisoSC5sZW5ndGgtMSkrXFxcIl1cXFwifSksYT1hLnJlcGxhY2UoLzxpbWcoKD86W1xcXFx3XFxcXFddKj8pKSBzcmM9XFxcIi9nLCc8aW1nJDEgZGF0YS1mci1zcmM9XFxcIicpfWZ1bmN0aW9uIGYoYSl7cmV0dXJuIGE9YS5yZXBsYWNlKC9cXFxcW0ZST0FMQVxcXFwuRURJVE9SXFxcXC5TQ1JJUFQgKFtcXFxcZF0qKVxcXFxdL2dpLGZ1bmN0aW9uKGEsYyl7cmV0dXJuIGIub3B0cy5odG1sUmVtb3ZlVGFncy5pbmRleE9mKFxcXCJzY3JpcHRcXFwiKT49MD9cXFwiXFxcIjpIW3BhcnNlSW50KGMsMTApXX0pLGE9YS5yZXBsYWNlKC88aW1nKCg/OltcXFxcd1xcXFxXXSo/KSkgZGF0YS1mci1zcmM9XFxcIi9nLCc8aW1nJDEgc3JjPVxcXCInKX1mdW5jdGlvbiBnKGEpe3ZhciBiO2ZvcihiIGluIGEpYS5oYXNPd25Qcm9wZXJ0eShiKSYmKGIubWF0Y2goRyl8fGRlbGV0ZSBhW2JdKTtmb3IodmFyIGM9XFxcIlxcXCIsZD1PYmplY3Qua2V5cyhhKS5zb3J0KCksZT0wO2U8ZC5sZW5ndGg7ZSsrKWI9ZFtlXSxjKz1hW2JdLmluZGV4T2YoJ1xcXCInKTwwP1xcXCIgXFxcIitiKyc9XFxcIicrYVtiXSsnXFxcIic6XFxcIiBcXFwiK2IrXFxcIj0nXFxcIithW2JdK1xcXCInXFxcIjtyZXR1cm4gY31mdW5jdGlvbiBoKGEsYyxkKXtpZihiLm9wdHMuZnVsbFBhZ2Upe3ZhciBlPWIuaHRtbC5leHRyYWN0RG9jdHlwZShkKSxmPWcoYi5odG1sLmV4dHJhY3ROb2RlQXR0cnMoZCxcXFwiaHRtbFxcXCIpKTtjPW51bGw9PWM/Yi5odG1sLmV4dHJhY3ROb2RlKGQsXFxcImhlYWRcXFwiKXx8XFxcIjx0aXRsZT48L3RpdGxlPlxcXCI6Yzt2YXIgaD1nKGIuaHRtbC5leHRyYWN0Tm9kZUF0dHJzKGQsXFxcImhlYWRcXFwiKSksaT1nKGIuaHRtbC5leHRyYWN0Tm9kZUF0dHJzKGQsXFxcImJvZHlcXFwiKSk7cmV0dXJuIGUrXFxcIjxodG1sXFxcIitmK1xcXCI+PGhlYWRcXFwiK2grXFxcIj5cXFwiK2MrXFxcIjwvaGVhZD48Ym9keVxcXCIraStcXFwiPlxcXCIrYStcXFwiPC9ib2R5PjwvaHRtbD5cXFwifXJldHVybiBhfWZ1bmN0aW9uIGkoYyxlKXt2YXIgZj1hKFxcXCI8ZGl2PlxcXCIrYytcXFwiPC9kaXY+XFxcIiksZz1cXFwiXFxcIjtpZihmKXtmb3IodmFyIGg9Yi5ub2RlLmNvbnRlbnRzKGYuZ2V0KDApKSxpPTA7aTxoLmxlbmd0aDtpKyspZShoW2ldKTtoPWIubm9kZS5jb250ZW50cyhmLmdldCgwKSk7Zm9yKHZhciBpPTA7aTxoLmxlbmd0aDtpKyspZys9ZChoW2ldKX1yZXR1cm4gZ31mdW5jdGlvbiBqKGEsYyxkKXthPWUoYSk7dmFyIGc9YSxqPW51bGw7aWYoYi5vcHRzLmZ1bGxQYWdlKXt2YXIgZz1iLmh0bWwuZXh0cmFjdE5vZGUoYSxcXFwiYm9keVxcXCIpfHwoYS5pbmRleE9mKFxcXCI8Ym9keVxcXCIpPj0wP1xcXCJcXFwiOmEpO2QmJihqPWIuaHRtbC5leHRyYWN0Tm9kZShhLFxcXCJoZWFkXFxcIil8fFxcXCJcXFwiKX1nPWkoZyxjKSxqJiYoaj1pKGosYykpO3ZhciBrPWgoZyxqLGEpO3JldHVybiBmKGspfWZ1bmN0aW9uIGsoYSl7cmV0dXJuIGEucmVwbGFjZSgvXFxcXHUyMDBiL2csXFxcIlxcXCIpLmxlbmd0aD09YS5sZW5ndGg/YTpiLmNsZWFuLmV4ZWMoYSxjKX1mdW5jdGlvbiBsKCl7dmFyIGM9Yi5lbC5xdWVyeVNlbGVjdG9yQWxsKE9iamVjdC5rZXlzKGEuRkUuSFRNTDVNYXApLmpvaW4oXFxcIixcXFwiKSk7aWYoYy5sZW5ndGgpe3ZhciBkPSExO2IuZWwucXVlcnlTZWxlY3RvcihcXFwiLmZyLW1hcmtlclxcXCIpfHwoYi5zZWxlY3Rpb24uc2F2ZSgpLGQ9ITApO2Zvcih2YXIgZT0wO2U8Yy5sZW5ndGg7ZSsrKVxcXCJcXFwiPT09Yi5ub2RlLmF0dHJpYnV0ZXMoY1tlXSkmJmEoY1tlXSkucmVwbGFjZVdpdGgoXFxcIjxcXFwiK2EuRkUuSFRNTDVNYXBbY1tlXS50YWdOYW1lXStcXFwiPlxcXCIrY1tlXS5pbm5lckhUTUwrXFxcIjwvXFxcIithLkZFLkhUTUw1TWFwW2NbZV0udGFnTmFtZV0rXFxcIj5cXFwiKTtkJiZiLnNlbGVjdGlvbi5yZXN0b3JlKCl9fWZ1bmN0aW9uIG0oYyl7aWYoXFxcIlNQQU5cXFwiPT1jLnRhZ05hbWUmJihjLmdldEF0dHJpYnV0ZShcXFwiY2xhc3NcXFwiKXx8XFxcIlxcXCIpLmluZGV4T2YoXFxcImZyLW1hcmtlclxcXCIpPj0wKXJldHVybiExO2lmKFxcXCJQUkVcXFwiPT1jLnRhZ05hbWUmJm8oYyksYy5ub2RlVHlwZT09Tm9kZS5FTEVNRU5UX05PREUmJihjLmdldEF0dHJpYnV0ZShcXFwiZGF0YS1mci1zcmNcXFwiKSYmYy5zZXRBdHRyaWJ1dGUoXFxcImRhdGEtZnItc3JjXFxcIixiLmhlbHBlcnMuc2FuaXRpemVVUkwoYy5nZXRBdHRyaWJ1dGUoXFxcImRhdGEtZnItc3JjXFxcIikpKSxjLmdldEF0dHJpYnV0ZShcXFwiaHJlZlxcXCIpJiZjLnNldEF0dHJpYnV0ZShcXFwiaHJlZlxcXCIsYi5oZWxwZXJzLnNhbml0aXplVVJMKGMuZ2V0QXR0cmlidXRlKFxcXCJocmVmXFxcIikpKSxbXFxcIlRBQkxFXFxcIixcXFwiVEJPRFlcXFwiLFxcXCJURk9PVFxcXCIsXFxcIlRSXFxcIl0uaW5kZXhPZihjLnRhZ05hbWUpPj0wJiYoYy5pbm5lckhUTUw9Yy5pbm5lckhUTUwudHJpbSgpKSksIWIub3B0cy5wYXN0ZUFsbG93TG9jYWxJbWFnZXMmJmMubm9kZVR5cGU9PU5vZGUuRUxFTUVOVF9OT0RFJiZcXFwiSU1HXFxcIj09Yy50YWdOYW1lJiZjLmdldEF0dHJpYnV0ZShcXFwiZGF0YS1mci1zcmNcXFwiKSYmMD09Yy5nZXRBdHRyaWJ1dGUoXFxcImRhdGEtZnItc3JjXFxcIikuaW5kZXhPZihcXFwiZmlsZTovL1xcXCIpKXJldHVybiBjLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoYyksITE7aWYoYy5ub2RlVHlwZT09Tm9kZS5FTEVNRU5UX05PREUmJmEuRkUuSFRNTDVNYXBbYy50YWdOYW1lXSYmXFxcIlxcXCI9PT1iLm5vZGUuYXR0cmlidXRlcyhjKSl7dmFyIGQ9YS5GRS5IVE1MNU1hcFtjLnRhZ05hbWVdLGU9XFxcIjxcXFwiK2QrXFxcIj5cXFwiK2MuaW5uZXJIVE1MK1xcXCI8L1xcXCIrZCtcXFwiPlxcXCI7Yy5pbnNlcnRBZGphY2VudEhUTUwoXFxcImJlZm9yZWJlZ2luXFxcIixlKSxjPWMucHJldmlvdXNTaWJsaW5nLGMucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChjLm5leHRTaWJsaW5nKX1pZihiLm9wdHMuaHRtbEFsbG93Q29tbWVudHN8fGMubm9kZVR5cGUhPU5vZGUuQ09NTUVOVF9OT0RFKWlmKGMudGFnTmFtZSYmYy50YWdOYW1lLm1hdGNoKEYpKWMucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChjKTtlbHNlIGlmKGMudGFnTmFtZSYmIWMudGFnTmFtZS5tYXRjaChFKSljLm91dGVySFRNTD1jLmlubmVySFRNTDtlbHNle3ZhciBmPWMuYXR0cmlidXRlcztpZihmKWZvcih2YXIgZz1mLmxlbmd0aC0xO2c+PTA7Zy0tKXt2YXIgaD1mW2ddO2gubm9kZU5hbWUubWF0Y2goRyl8fGMucmVtb3ZlQXR0cmlidXRlKGgubm9kZU5hbWUpfX1lbHNlIDAhPT1jLmRhdGEuaW5kZXhPZihcXFwiW0ZST0FMQS5FRElUT1JcXFwiKSYmYy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGMpfWZ1bmN0aW9uIG4oYSl7Zm9yKHZhciBjPWIubm9kZS5jb250ZW50cyhhKSxkPTA7ZDxjLmxlbmd0aDtkKyspY1tkXS5ub2RlVHlwZSE9Tm9kZS5URVhUX05PREUmJm4oY1tkXSk7bShhKX1mdW5jdGlvbiBvKGEpe3ZhciBiPWEuaW5uZXJIVE1MO2IuaW5kZXhPZihcXFwiXFxcXG5cXFwiKT49MCYmKGEuaW5uZXJIVE1MPWIucmVwbGFjZSgvXFxcXG4vZyxcXFwiPGJyPlxcXCIpKX1mdW5jdGlvbiBwKGMsZCxlLGYpe1xcXCJ1bmRlZmluZWRcXFwiPT10eXBlb2YgZCYmKGQ9W10pLFxcXCJ1bmRlZmluZWRcXFwiPT10eXBlb2YgZSYmKGU9W10pLFxcXCJ1bmRlZmluZWRcXFwiPT10eXBlb2YgZiYmKGY9ITEpLGM9Yy5yZXBsYWNlKC9cXFxcdTAwMDkvZyxcXFwiXFxcIik7dmFyIGcsaD1hLm1lcmdlKFtdLGIub3B0cy5odG1sQWxsb3dlZFRhZ3MpO2ZvcihnPTA7ZzxkLmxlbmd0aDtnKyspaC5pbmRleE9mKGRbZ10pPj0wJiZoLnNwbGljZShoLmluZGV4T2YoZFtnXSksMSk7dmFyIGk9YS5tZXJnZShbXSxiLm9wdHMuaHRtbEFsbG93ZWRBdHRycyk7Zm9yKGc9MDtnPGUubGVuZ3RoO2crKylpLmluZGV4T2YoZVtnXSk+PTAmJmkuc3BsaWNlKGkuaW5kZXhPZihlW2ddKSwxKTtyZXR1cm4gaS5wdXNoKFxcXCJkYXRhLWZyLS4qXFxcIiksaS5wdXNoKFxcXCJmci0uKlxcXCIpLEU9bmV3IFJlZ0V4cChcXFwiXlxcXCIraC5qb2luKFxcXCIkfF5cXFwiKStcXFwiJFxcXCIsXFxcImdpXFxcIiksRz1uZXcgUmVnRXhwKFxcXCJeXFxcIitpLmpvaW4oXFxcIiR8XlxcXCIpK1xcXCIkXFxcIixcXFwiZ2lcXFwiKSxGPW5ldyBSZWdFeHAoXFxcIl5cXFwiK2Iub3B0cy5odG1sUmVtb3ZlVGFncy5qb2luKFxcXCIkfF5cXFwiKStcXFwiJFxcXCIsXFxcImdpXFxcIiksYz1qKGMsbiwhMCl9ZnVuY3Rpb24gcSgpe2Zvcih2YXIgYz1iLmVsLnF1ZXJ5U2VsZWN0b3JBbGwoXFxcImJsb2NrcXVvdGUgKyBibG9ja3F1b3RlXFxcIiksZD0wO2Q8Yy5sZW5ndGg7ZCsrKXt2YXIgZT1jW2RdO2Iubm9kZS5hdHRyaWJ1dGVzKGUpPT1iLm5vZGUuYXR0cmlidXRlcyhlLnByZXZpb3VzU2libGluZykmJihhKGUpLnByZXYoKS5hcHBlbmQoYShlKS5odG1sKCkpLGEoZSkucmVtb3ZlKCkpfX1mdW5jdGlvbiByKCl7Zm9yKHZhciBhPWIuZWwucXVlcnlTZWxlY3RvckFsbChcXFwidHJcXFwiKSxjPTA7YzxhLmxlbmd0aDtjKyspe2Zvcih2YXIgZD1hW2NdLmNoaWxkcmVuLGU9ITAsZj0wO2Y8ZC5sZW5ndGg7ZisrKWlmKFxcXCJUSFxcXCIhPWRbZl0udGFnTmFtZSl7ZT0hMTticmVha31pZigwIT1lJiYwIT1kLmxlbmd0aCl7Zm9yKHZhciBnPWFbY107ZyYmXFxcIlRBQkxFXFxcIiE9Zy50YWdOYW1lJiZcXFwiVEhFQURcXFwiIT1nLnRhZ05hbWU7KWc9Zy5wYXJlbnROb2RlO3ZhciBoPWc7XFxcIlRIRUFEXFxcIiE9aC50YWdOYW1lJiYoaD1iLmRvYy5jcmVhdGVFbGVtZW50KFxcXCJUSEVBRFxcXCIpLGcuaW5zZXJ0QmVmb3JlKGgsZy5maXJzdENoaWxkKSksaC5hcHBlbmRDaGlsZChhW2NdKX19fWZ1bmN0aW9uIHMoKXt2YXIgYz1iLmh0bWwuZGVmYXVsdFRhZygpO2lmKGMpZm9yKHZhciBkPWIuZWwucXVlcnlTZWxlY3RvckFsbChcXFwidGQgPiBcXFwiK2MrXFxcIiwgdGggPiBcXFwiK2MpLGU9MDtlPGQubGVuZ3RoO2UrKylcXFwiXFxcIj09PWIubm9kZS5hdHRyaWJ1dGVzKGRbZV0pJiZhKGRbZV0pLnJlcGxhY2VXaXRoKGRbZV0uaW5uZXJIVE1MK1xcXCI8YnI+XFxcIil9ZnVuY3Rpb24gdCgpe3IoKSxzKCl9ZnVuY3Rpb24gdSgpe3ZhciBhPVtdLGM9ZnVuY3Rpb24oYSl7cmV0dXJuIWIubm9kZS5pc0xpc3QoYS5wYXJlbnROb2RlKX07ZG97aWYoYS5sZW5ndGgpe3ZhciBkPWFbMF0sZT1iLmRvYy5jcmVhdGVFbGVtZW50KFxcXCJ1bFxcXCIpO2QucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoZSxkKTtkb3t2YXIgZj1kO2Q9ZC5uZXh0U2libGluZyxlLmFwcGVuZENoaWxkKGYpfXdoaWxlKGQmJlxcXCJMSVxcXCI9PWQudGFnTmFtZSl9YT1bXTtmb3IodmFyIGc9Yi5lbC5xdWVyeVNlbGVjdG9yQWxsKFxcXCJsaVxcXCIpLGg9MDtoPGcubGVuZ3RoO2grKyljKGdbaF0pJiZhLnB1c2goZ1toXSl9d2hpbGUoYS5sZW5ndGg+MCl9ZnVuY3Rpb24gdigpe2Zvcih2YXIgYT1iLmVsLnF1ZXJ5U2VsZWN0b3JBbGwoXFxcIm9sICsgb2wsIHVsICsgdWxcXFwiKSxjPTA7YzxhLmxlbmd0aDtjKyspe3ZhciBkPWFbY107aWYoYi5ub2RlLmlzTGlzdChkLnByZXZpb3VzU2libGluZykmJmIubm9kZS5vcGVuVGFnU3RyaW5nKGQpPT1iLm5vZGUub3BlblRhZ1N0cmluZyhkLnByZXZpb3VzU2libGluZykpe2Zvcih2YXIgZT1iLm5vZGUuY29udGVudHMoZCksZj0wO2Y8ZS5sZW5ndGg7ZisrKWQucHJldmlvdXNTaWJsaW5nLmFwcGVuZENoaWxkKGVbZl0pO2QucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChkKX19fWZ1bmN0aW9uIHcoKXt2YXIgYSxjPWZ1bmN0aW9uKGIpe2IucXVlcnlTZWxlY3RvcihcXFwiTElcXFwiKXx8KGE9ITAsYi5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGIpKX07ZG97YT0hMTtmb3IodmFyIGQ9Yi5lbC5xdWVyeVNlbGVjdG9yQWxsKFxcXCJsaTplbXB0eVxcXCIpLGU9MDtlPGQubGVuZ3RoO2UrKylkW2VdLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZFtlXSk7Zm9yKHZhciBmPWIuZWwucXVlcnlTZWxlY3RvckFsbChcXFwidWwsIG9sXFxcIiksZT0wO2U8Zi5sZW5ndGg7ZSsrKWMoZltlXSl9d2hpbGUoYT09PSEwKX1mdW5jdGlvbiB4KCl7Zm9yKHZhciBjPWIuZWwucXVlcnlTZWxlY3RvckFsbChcXFwidWwgPiB1bCwgb2wgPiBvbCwgdWwgPiBvbCwgb2wgPiB1bFxcXCIpLGQ9MDtkPGMubGVuZ3RoO2QrKyl7dmFyIGU9Y1tkXSxmPWUucHJldmlvdXNTaWJsaW5nO2YmJihcXFwiTElcXFwiPT1mLnRhZ05hbWU/Zi5hcHBlbmRDaGlsZChlKTphKGUpLndyYXAoXFxcIjxsaT48L2xpPlxcXCIpKX19ZnVuY3Rpb24geSgpe2Zvcih2YXIgYz1iLmVsLnF1ZXJ5U2VsZWN0b3JBbGwoXFxcImxpID4gdWwsIGxpID4gb2xcXFwiKSxkPTA7ZDxjLmxlbmd0aDtkKyspe3ZhciBlPWNbZF07aWYoZS5uZXh0U2libGluZyl7dmFyIGY9ZS5uZXh0U2libGluZyxnPWEoXFxcIjxsaT5cXFwiKTthKGUucGFyZW50Tm9kZSkuYWZ0ZXIoZyk7ZG97dmFyIGg9ZjtmPWYubmV4dFNpYmxpbmcsZy5hcHBlbmQoaCl9d2hpbGUoZil9fX1mdW5jdGlvbiB6KCl7Zm9yKHZhciBjPWIuZWwucXVlcnlTZWxlY3RvckFsbChcXFwibGkgPiB1bCwgbGkgPiBvbFxcXCIpLGQ9MDtkPGMubGVuZ3RoO2QrKyl7dmFyIGU9Y1tkXTtpZihiLm5vZGUuaXNGaXJzdFNpYmxpbmcoZSkpYShlKS5iZWZvcmUoXFxcIjxici8+XFxcIik7ZWxzZSBpZihlLnByZXZpb3VzU2libGluZyYmXFxcIkJSXFxcIj09ZS5wcmV2aW91c1NpYmxpbmcudGFnTmFtZSl7Zm9yKHZhciBmPWUucHJldmlvdXNTaWJsaW5nLnByZXZpb3VzU2libGluZztmJiZiLm5vZGUuaGFzQ2xhc3MoZixcXFwiZnItbWFya2VyXFxcIik7KWY9Zi5wcmV2aW91c1NpYmxpbmc7ZiYmXFxcIkJSXFxcIiE9Zi50YWdOYW1lJiZhKGUucHJldmlvdXNTaWJsaW5nKS5yZW1vdmUoKX19fWZ1bmN0aW9uIEEoKXtmb3IodmFyIGM9Yi5lbC5xdWVyeVNlbGVjdG9yQWxsKFxcXCJsaTplbXB0eVxcXCIpLGQ9MDtkPGMubGVuZ3RoO2QrKylhKGNbZF0pLnJlbW92ZSgpfWZ1bmN0aW9uIEIoKXtmb3IodmFyIGM9Yi5lbC5xdWVyeVNlbGVjdG9yQWxsKFxcXCJ1bCwgb2xcXFwiKSxkPTA7ZDxjLmxlbmd0aDtkKyspZm9yKHZhciBlPWIubm9kZS5jb250ZW50cyhjW2RdKSxmPW51bGwsZz1lLmxlbmd0aC0xO2c+PTA7Zy0tKVxcXCJMSVxcXCIhPWVbZ10udGFnTmFtZT8oZnx8KGY9YShcXFwiPGxpPlxcXCIpLGYuaW5zZXJ0QmVmb3JlKGVbZ10pKSxmLnByZXBlbmQoZVtnXSkpOmY9bnVsbH1mdW5jdGlvbiBDKCl7dSgpLHYoKSx3KCkseCgpLHkoKSx6KCksQigpLEEoKX1mdW5jdGlvbiBEKCl7Yi5vcHRzLmZ1bGxQYWdlJiZhLm1lcmdlKGIub3B0cy5odG1sQWxsb3dlZFRhZ3MsW1xcXCJoZWFkXFxcIixcXFwidGl0bGVcXFwiLFxcXCJzdHlsZVxcXCIsXFxcImxpbmtcXFwiLFxcXCJiYXNlXFxcIixcXFwiYm9keVxcXCIsXFxcImh0bWxcXFwiLFxcXCJtZXRhXFxcIl0pfXZhciBFLEYsRyxIPVtdLEg9W107cmV0dXJue19pbml0OkQsaHRtbDpwLHRvSFRNTDU6bCx0YWJsZXM6dCxsaXN0czpDLHF1b3RlczpxLGludmlzaWJsZVNwYWNlczprLGV4ZWM6an19LGEuRkUuTU9EVUxFUy5zcGFjZXM9ZnVuY3Rpb24oYil7ZnVuY3Rpb24gYyhjLGQpe3ZhciBlPWMucHJldmlvdXNTaWJsaW5nLGY9Yy5uZXh0U2libGluZyxnPWMudGV4dENvbnRlbnQsaD1jLnBhcmVudE5vZGU7ZCYmKGc9Zy5yZXBsYWNlKC9bXFxcXGZcXFxcblxcXFxyXFxcXHRcXFxcdiBdezIsfS9nLFxcXCIgXFxcIiksKCFmfHxiLm5vZGUuaXNWb2lkKGYpfHxiLm5vZGUuaXNCbG9jayhmKSkmJmIubm9kZS5pc0Jsb2NrKGgpJiYoZz1nLnJlcGxhY2UoL1tcXFxcZlxcXFxuXFxcXHJcXFxcdFxcXFx2IF17MSx9JC9nLFxcXCJcXFwiKSksKCFlfHxiLm5vZGUuaXNWb2lkKGUpfHxiLm5vZGUuaXNCbG9jayhlKSkmJmIubm9kZS5pc0Jsb2NrKGgpJiYoZz1nLnJlcGxhY2UoL15bXFxcXGZcXFxcblxcXFxyXFxcXHRcXFxcdiBdezEsfS9nLFxcXCJcXFwiKSkpLGc9Zy5yZXBsYWNlKG5ldyBSZWdFeHAoYS5GRS5VTklDT0RFX05CU1AsXFxcImdcXFwiKSxcXFwiIFxcXCIpO2Zvcih2YXIgaT1cXFwiXFxcIixqPTA7ajxnLmxlbmd0aDtqKyspaSs9MzIhPWcuY2hhckNvZGVBdChqKXx8MCE9PWomJjMyIT1pLmNoYXJDb2RlQXQoai0xKT9nW2pdOmEuRkUuVU5JQ09ERV9OQlNQOyghZnx8Yi5ub2RlLmlzQmxvY2soZil8fGYubm9kZVR5cGU9PU5vZGUuRUxFTUVOVF9OT0RFJiZiLndpbi5nZXRDb21wdXRlZFN0eWxlKGYpJiZcXFwiYmxvY2tcXFwiPT1iLndpbi5nZXRDb21wdXRlZFN0eWxlKGYpLmRpc3BsYXkpJiYoaT1pLnJlcGxhY2UoLyAkLyxhLkZFLlVOSUNPREVfTkJTUCkpLCFlfHxiLm5vZGUuaXNWb2lkKGUpfHxiLm5vZGUuaXNCbG9jayhlKXx8KGk9aS5yZXBsYWNlKC9eXFxcXHUwMEEwKFteICRdKS8sXFxcIiAkMVxcXCIpLDEhPT1pLmxlbmd0aHx8MTYwIT09aS5jaGFyQ29kZUF0KDApfHwhZnx8Yi5ub2RlLmlzVm9pZChmKXx8Yi5ub2RlLmlzQmxvY2soZil8fChpPVxcXCIgXFxcIikpLGk9aS5yZXBsYWNlKC8oW14gXFxcXHUwMEEwXSlcXFxcdTAwQTAoW14gXFxcXHUwMEEwXSkvZyxcXFwiJDEgJDJcXFwiKSxjLnRleHRDb250ZW50IT1pJiYoYy50ZXh0Q29udGVudD1pKX1mdW5jdGlvbiBkKGEsZCl7aWYoXFxcInVuZGVmaW5lZFxcXCIhPXR5cGVvZiBhJiZhfHwoYT1iLmVsKSxcXFwidW5kZWZpbmVkXFxcIj09dHlwZW9mIGQmJihkPSExKSwhYS5nZXRBdHRyaWJ1dGV8fFxcXCJmYWxzZVxcXCIhPWEuZ2V0QXR0cmlidXRlKFxcXCJjb250ZW50ZWRpdGFibGVcXFwiKSlpZihhLm5vZGVUeXBlPT1Ob2RlLlRFWFRfTk9ERSljKGEsZCk7ZWxzZSBpZihhLm5vZGVUeXBlPT1Ob2RlLkVMRU1FTlRfTk9ERSlmb3IodmFyIGU9Yi5kb2MuY3JlYXRlVHJlZVdhbGtlcihhLE5vZGVGaWx0ZXIuU0hPV19URVhULGIubm9kZS5maWx0ZXIoZnVuY3Rpb24oYSl7cmV0dXJuIG51bGwhPWEudGV4dENvbnRlbnQubWF0Y2goLyhbIFxcXFx1MDBBMFxcXFxmXFxcXG5cXFxcclxcXFx0XFxcXHZdezIsfSl8KF5bIFxcXFx1MDBBMFxcXFxmXFxcXG5cXFxcclxcXFx0XFxcXHZdezEsfSl8KFsgXFxcXHUwMEEwXFxcXGZcXFxcblxcXFxyXFxcXHRcXFxcdl17MSx9JCkvZykmJiFiLm5vZGUuaGFzQ2xhc3MoYS5wYXJlbnROb2RlLFxcXCJmci1tYXJrZXJcXFwiKX0pLCExKTtlLm5leHROb2RlKCk7KWMoZS5jdXJyZW50Tm9kZSxkKX1mdW5jdGlvbiBlKCl7Zm9yKHZhciBhPVtdLGM9Yi5lbC5xdWVyeVNlbGVjdG9yQWxsKFxcXCIuZnItbWFya2VyXFxcIiksZT0wO2U8Yy5sZW5ndGg7ZSsrKXt2YXIgZj1udWxsLGc9Yi5ub2RlLmJsb2NrUGFyZW50KGNbZV0pO2Y9Zz9nOmNbZV07Zm9yKHZhciBoPWYubmV4dFNpYmxpbmcsaT1mLnByZXZpb3VzU2libGluZztoJiZcXFwiQlJcXFwiPT1oLnRhZ05hbWU7KWg9aC5uZXh0U2libGluZztmb3IoO2kmJlxcXCJCUlxcXCI9PWkudGFnTmFtZTspaT1pLnByZXZpb3VzU2libGluZztmJiZhLmluZGV4T2YoZik8MCYmYS5wdXNoKGYpLGkmJmEuaW5kZXhPZihpKTwwJiZhLnB1c2goaSksaCYmYS5pbmRleE9mKGgpPDAmJmEucHVzaChoKX1mb3IodmFyIGo9MDtqPGEubGVuZ3RoO2orKylkKGFbal0pfXJldHVybntub3JtYWxpemU6ZCxub3JtYWxpemVBcm91bmRDdXJzb3I6ZX19LGEuRkUuVU5JQ09ERV9OQlNQPVN0cmluZy5mcm9tQ2hhckNvZGUoMTYwKSxhLkZFLlZPSURfRUxFTUVOVFM9W1xcXCJhcmVhXFxcIixcXFwiYmFzZVxcXCIsXFxcImJyXFxcIixcXFwiY29sXFxcIixcXFwiZW1iZWRcXFwiLFxcXCJoclxcXCIsXFxcImltZ1xcXCIsXFxcImlucHV0XFxcIixcXFwia2V5Z2VuXFxcIixcXFwibGlua1xcXCIsXFxcIm1lbnVpdGVtXFxcIixcXFwibWV0YVxcXCIsXFxcInBhcmFtXFxcIixcXFwic291cmNlXFxcIixcXFwidHJhY2tcXFwiLFxcXCJ3YnJcXFwiXSxhLkZFLkJMT0NLX1RBR1M9W1xcXCJhZGRyZXNzXFxcIixcXFwiYXJ0aWNsZVxcXCIsXFxcImFzaWRlXFxcIixcXFwiYXVkaW9cXFwiLFxcXCJibG9ja3F1b3RlXFxcIixcXFwiY2FudmFzXFxcIixcXFwiZGRcXFwiLFxcXCJkaXZcXFwiLFxcXCJkbFxcXCIsXFxcImR0XFxcIixcXFwiZmllbGRzZXRcXFwiLFxcXCJmaWdjYXB0aW9uXFxcIixcXFwiZmlndXJlXFxcIixcXFwiZm9vdGVyXFxcIixcXFwiZm9ybVxcXCIsXFxcImgxXFxcIixcXFwiaDJcXFwiLFxcXCJoM1xcXCIsXFxcImg0XFxcIixcXFwiaDVcXFwiLFxcXCJoNlxcXCIsXFxcImhlYWRlclxcXCIsXFxcImhncm91cFxcXCIsXFxcImhyXFxcIixcXFwibGlcXFwiLFxcXCJtYWluXFxcIixcXFwibmF2XFxcIixcXFwibm9zY3JpcHRcXFwiLFxcXCJvbFxcXCIsXFxcIm91dHB1dFxcXCIsXFxcInBcXFwiLFxcXCJwcmVcXFwiLFxcXCJzZWN0aW9uXFxcIixcXFwidGFibGVcXFwiLFxcXCJ0Ym9keVxcXCIsXFxcInRkXFxcIixcXFwidGZvb3RcXFwiLFxcXCJ0aFxcXCIsXFxcInRoZWFkXFxcIixcXFwidHJcXFwiLFxcXCJ1bFxcXCIsXFxcInZpZGVvXFxcIl0sYS5leHRlbmQoYS5GRS5ERUZBVUxUUyx7aHRtbEFsbG93ZWRFbXB0eVRhZ3M6W1xcXCJ0ZXh0YXJlYVxcXCIsXFxcImFcXFwiLFxcXCJpZnJhbWVcXFwiLFxcXCJvYmplY3RcXFwiLFxcXCJ2aWRlb1xcXCIsXFxcInN0eWxlXFxcIixcXFwic2NyaXB0XFxcIixcXFwiLmZhXFxcIixcXFwiLmZyLWVtb3RpY29uXFxcIl0saHRtbERvTm90V3JhcFRhZ3M6W1xcXCJzY3JpcHRcXFwiLFxcXCJzdHlsZVxcXCJdLGh0bWxTaW1wbGVBbXBlcnNhbmQ6ITEsaHRtbElnbm9yZUNTU1Byb3BlcnRpZXM6W119KSxhLkZFLk1PRFVMRVMuaHRtbD1mdW5jdGlvbihiKXtmdW5jdGlvbiBjKCl7cmV0dXJuIGIub3B0cy5lbnRlcj09YS5GRS5FTlRFUl9QP1xcXCJwXFxcIjpiLm9wdHMuZW50ZXI9PWEuRkUuRU5URVJfRElWP1xcXCJkaXZcXFwiOmIub3B0cy5lbnRlcj09YS5GRS5FTlRFUl9CUj9udWxsOnZvaWQgMH1mdW5jdGlvbiBkKGMpe3ZhciBkPVtdLGU9W107aWYoYylmb3IodmFyIGc9Yi5lbC5xdWVyeVNlbGVjdG9yQWxsKFxcXCIuZnItbWFya2VyXFxcIiksaD0wO2g8Zy5sZW5ndGg7aCsrKXt2YXIgaT1iLm5vZGUuYmxvY2tQYXJlbnQoZ1toXSl8fGdbaF07aWYoaSl7dmFyIGo9aS5uZXh0U2libGluZyxrPWkucHJldmlvdXNTaWJsaW5nO2kmJmUuaW5kZXhPZihpKTwwJiZiLm5vZGUuaXNCbG9jayhpKSYmZS5wdXNoKGkpLGsmJmIubm9kZS5pc0Jsb2NrKGspJiZlLmluZGV4T2Yoayk8MCYmZS5wdXNoKGspLGomJmIubm9kZS5pc0Jsb2NrKGopJiZlLmluZGV4T2Yoaik8MCYmZS5wdXNoKGopfX1lbHNlIGU9Yi5lbC5xdWVyeVNlbGVjdG9yQWxsKGYoKSk7dmFyIGw9ZigpO2wrPVxcXCIsXFxcIithLkZFLlZPSURfRUxFTUVOVFMuam9pbihcXFwiLFxcXCIpLGwrPVxcXCIsXFxcIitiLm9wdHMuaHRtbEFsbG93ZWRFbXB0eVRhZ3Muam9pbihcXFwiOm5vdCguZnItbWFya2VyKSxcXFwiKStcXFwiOm5vdCguZnItbWFya2VyKVxcXCI7Zm9yKHZhciBoPWUubGVuZ3RoLTE7aD49MDtoLS0paWYoIShlW2hdLnRleHRDb250ZW50JiZlW2hdLnRleHRDb250ZW50LnJlcGxhY2UoL1xcXFx1MjAwQnxcXFxcbi9nLFxcXCJcXFwiKS5sZW5ndGg+MHx8ZVtoXS5xdWVyeVNlbGVjdG9yQWxsKGwpLmxlbmd0aD4wKSl7Zm9yKHZhciBtPWIubm9kZS5jb250ZW50cyhlW2hdKSxuPSExLG89MDtvPG0ubGVuZ3RoO28rKylpZihtW29dLm5vZGVUeXBlIT1Ob2RlLkNPTU1FTlRfTk9ERSYmbVtvXS50ZXh0Q29udGVudCYmbVtvXS50ZXh0Q29udGVudC5yZXBsYWNlKC9cXFxcdTIwMEJ8XFxcXG4vZyxcXFwiXFxcIikubGVuZ3RoPjApe249ITA7YnJlYWt9bnx8ZC5wdXNoKGVbaF0pfXJldHVybiBkfWZ1bmN0aW9uIGUoKXtyZXR1cm4gYS5GRS5CTE9DS19UQUdTLmpvaW4oXFxcIjplbXB0eSwgXFxcIikrXFxcIjplbXB0eVxcXCJ9ZnVuY3Rpb24gZigpe3JldHVybiBhLkZFLkJMT0NLX1RBR1Muam9pbihcXFwiLCBcXFwiKX1mdW5jdGlvbiBnKGMpe3ZhciBkPWEubWVyZ2UoW10sYS5GRS5WT0lEX0VMRU1FTlRTKTtkPWEubWVyZ2UoZCxiLm9wdHMuaHRtbEFsbG93ZWRFbXB0eVRhZ3MpLFxcXCJ1bmRlZmluZWRcXFwiPT10eXBlb2YgYyYmKGQ9YS5tZXJnZShkLGEuRkUuQkxPQ0tfVEFHUykpO3ZhciBlLGY7ZT1iLmVsLnF1ZXJ5U2VsZWN0b3JBbGwoXFxcIio6ZW1wdHk6bm90KFxcXCIrZC5qb2luKFxcXCIpOm5vdChcXFwiKStcXFwiKTpub3QoLmZyLW1hcmtlcilcXFwiKTtkb3tmPSExO2Zvcih2YXIgZz0wO2c8ZS5sZW5ndGg7ZysrKTAhPT1lW2ddLmF0dHJpYnV0ZXMubGVuZ3RoJiZcXFwidW5kZWZpbmVkXFxcIj09dHlwZW9mIGVbZ10uZ2V0QXR0cmlidXRlKFxcXCJocmVmXFxcIil8fChlW2ddLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZVtnXSksZj0hMCk7ZT1iLmVsLnF1ZXJ5U2VsZWN0b3JBbGwoXFxcIio6ZW1wdHk6bm90KFxcXCIrZC5qb2luKFxcXCIpOm5vdChcXFwiKStcXFwiKTpub3QoLmZyLW1hcmtlcilcXFwiKX13aGlsZShlLmxlbmd0aCYmZil9ZnVuY3Rpb24gaChhLGQpe3ZhciBlPWMoKTtpZihkJiYoZT1cXFwiZGl2XFxcIiksZSl7Zm9yKHZhciBmPWIuZG9jLmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSxnPW51bGwsaD0hMSxpPWEuZmlyc3RDaGlsZDtpOyl7dmFyIGo9aS5uZXh0U2libGluZztpZihpLm5vZGVUeXBlPT1Ob2RlLkVMRU1FTlRfTk9ERSYmKGIubm9kZS5pc0Jsb2NrKGkpfHxiLm9wdHMuaHRtbERvTm90V3JhcFRhZ3MuaW5kZXhPZihpLnRhZ05hbWUudG9Mb3dlckNhc2UoKSk+PTAmJiFiLm5vZGUuaGFzQ2xhc3MoaSxcXFwiZnItbWFya2VyXFxcIikpKWc9bnVsbCxmLmFwcGVuZENoaWxkKGkpO2Vsc2UgaWYoaS5ub2RlVHlwZSE9Tm9kZS5FTEVNRU5UX05PREUmJmkubm9kZVR5cGUhPU5vZGUuVEVYVF9OT0RFKWc9bnVsbCxmLmFwcGVuZENoaWxkKGkpO2Vsc2UgaWYoXFxcIkJSXFxcIj09aS50YWdOYW1lKWomJlxcXCJCUlxcXCI9PWoudGFnTmFtZSYmKGo9ai5uZXh0U2libGluZyksbnVsbD09Zz8oZz1iLmRvYy5jcmVhdGVFbGVtZW50KGUpLGQmJmcuc2V0QXR0cmlidXRlKFxcXCJkYXRhLWVtcHR5XFxcIiwhMCksZy5hcHBlbmRDaGlsZChpKSxmLmFwcGVuZENoaWxkKGcpKTpoPT09ITEmJihnLmFwcGVuZENoaWxkKGIuZG9jLmNyZWF0ZUVsZW1lbnQoXFxcImJyXFxcIikpLGcuc2V0QXR0cmlidXRlKFxcXCJkYXRhLWVtcHR5XFxcIiwhMCkpLGc9bnVsbDtlbHNle3ZhciBrPWkudGV4dENvbnRlbnQ7aS5ub2RlVHlwZT09Tm9kZS5URVhUX05PREUmJjA9PWsucmVwbGFjZSgvXFxcXG4vZyxcXFwiXFxcIikucmVwbGFjZSgvKF4gKil8KCAqJCkvZyxcXFwiXFxcIikubGVuZ3RofHwobnVsbD09ZyYmKGc9Yi5kb2MuY3JlYXRlRWxlbWVudChlKSxkJiZnLnNldEF0dHJpYnV0ZShcXFwiY2xhc3NcXFwiLFxcXCJmci10ZW1wLWRpdlxcXCIpLGYuYXBwZW5kQ2hpbGQoZyksaD0hMSksZy5hcHBlbmRDaGlsZChpKSxofHxiLm5vZGUuaGFzQ2xhc3MoaSxcXFwiZnItbWFya2VyXFxcIil8fGkubm9kZVR5cGU9PU5vZGUuVEVYVF9OT0RFJiYwPT09ay5yZXBsYWNlKC8gL2csXFxcIlxcXCIpLmxlbmd0aHx8KGg9ITApKX1pPWp9YS5pbm5lckhUTUw9XFxcIlxcXCIsYS5hcHBlbmRDaGlsZChmKX19ZnVuY3Rpb24gaShhLGIpe2Zvcih2YXIgYz0wO2M8YS5sZW5ndGg7YysrKWgoYVtjXSxiKX1mdW5jdGlvbiBqKGEsYyxkLGUpe3JldHVybiEhYi4kd3AmJihcXFwidW5kZWZpbmVkXFxcIj09dHlwZW9mIGEmJihhPSExKSxcXFwidW5kZWZpbmVkXFxcIj09dHlwZW9mIGMmJihjPSExKSxcXFwidW5kZWZpbmVkXFxcIj09dHlwZW9mIGQmJihkPSExKSxcXFwidW5kZWZpbmVkXFxcIj09dHlwZW9mIGUmJihlPSExKSxoKGIuZWwsYSksZSYmaShiLmVsLnF1ZXJ5U2VsZWN0b3JBbGwoXFxcIi5mci1pbm5lclxcXCIpLGEpLGMmJmkoYi5lbC5xdWVyeVNlbGVjdG9yQWxsKFxcXCJ0ZCwgdGhcXFwiKSxhKSx2b2lkKGQmJmkoYi5lbC5xdWVyeVNlbGVjdG9yQWxsKFxcXCJibG9ja3F1b3RlXFxcIiksYSkpKX1mdW5jdGlvbiBrKCl7Yi4kZWwuZmluZChcXFwiZGl2LmZyLXRlbXAtZGl2XFxcIikuZWFjaChmdW5jdGlvbigpe2EodGhpcykuZGF0YShcXFwiZW1wdHlcXFwiKXx8XFxcIkxJXFxcIj09dGhpcy5wYXJlbnROb2RlLnRhZ05hbWV8fGIubm9kZS5pc0Jsb2NrKHRoaXMucHJldmlvdXNTaWJsaW5nKT9hKHRoaXMpLnJlcGxhY2VXaXRoKGEodGhpcykuaHRtbCgpKTphKHRoaXMpLnJlcGxhY2VXaXRoKGEodGhpcykuaHRtbCgpK1xcXCI8YnI+XFxcIil9KSxiLiRlbC5maW5kKFxcXCIuZnItdGVtcC1kaXZcXFwiKS5yZW1vdmVDbGFzcyhcXFwiZnItdGVtcC1kaXZcXFwiKS5maWx0ZXIoZnVuY3Rpb24oKXtyZXR1cm5cXFwiXFxcIj09YSh0aGlzKS5hdHRyKFxcXCJjbGFzc1xcXCIpfSkucmVtb3ZlQXR0cihcXFwiY2xhc3NcXFwiKX1mdW5jdGlvbiBsKGMpe2Zvcih2YXIgZT1kKGMpLGY9MDtmPGUubGVuZ3RoO2YrKyl7dmFyIGc9ZVtmXTtcXFwiZmFsc2VcXFwiPT1nLmdldEF0dHJpYnV0ZShcXFwiY29udGVudGVkaXRhYmxlXFxcIil8fGcucXVlcnlTZWxlY3RvcihiLm9wdHMuaHRtbEFsbG93ZWRFbXB0eVRhZ3Muam9pbihcXFwiOm5vdCguZnItbWFya2VyKSxcXFwiKStcXFwiOm5vdCguZnItbWFya2VyKVxcXCIpfHxiLm5vZGUuaXNWb2lkKGcpfHxcXFwiVEFCTEVcXFwiIT1nLnRhZ05hbWUmJlxcXCJUQk9EWVxcXCIhPWcudGFnTmFtZSYmXFxcIlRSXFxcIiE9Zy50YWdOYW1lJiZnLmFwcGVuZENoaWxkKGIuZG9jLmNyZWF0ZUVsZW1lbnQoXFxcImJyXFxcIikpfWlmKGIuYnJvd3Nlci5tc2llJiZiLm9wdHMuZW50ZXI9PWEuRkUuRU5URVJfQlIpe3ZhciBoPWIubm9kZS5jb250ZW50cyhiLmVsKTtoLmxlbmd0aCYmaFtoLmxlbmd0aC0xXS5ub2RlVHlwZT09Tm9kZS5URVhUX05PREUmJmIuJGVsLmFwcGVuZChcXFwiPGJyPlxcXCIpfX1mdW5jdGlvbiBtKCl7cmV0dXJuIGIuJGVsLmdldCgwKS5xdWVyeVNlbGVjdG9yQWxsKGYoKSl9ZnVuY3Rpb24gbihhKXtpZihcXFwidW5kZWZpbmVkXFxcIj09dHlwZW9mIGEmJihhPWIuZWwpLGEmJltcXFwiU0NSSVBUXFxcIixcXFwiU1RZTEVcXFwiLFxcXCJQUkVcXFwiXS5pbmRleE9mKGEudGFnTmFtZSk+PTApcmV0dXJuITE7Zm9yKHZhciBjPWIuZG9jLmNyZWF0ZVRyZWVXYWxrZXIoYSxOb2RlRmlsdGVyLlNIT1dfVEVYVCxiLm5vZGUuZmlsdGVyKGZ1bmN0aW9uKGEpe3JldHVybiBudWxsIT1hLnRleHRDb250ZW50Lm1hdGNoKC8oWyBcXFxcbl17Mix9KXwoXlsgXFxcXG5dezEsfSl8KFsgXFxcXG5dezEsfSQpL2cpfSksITEpO2MubmV4dE5vZGUoKTspe3ZhciBkPWMuY3VycmVudE5vZGUsZT1iLm5vZGUuaXNCbG9jayhkLnBhcmVudE5vZGUpfHxiLm5vZGUuaXNFbGVtZW50KGQucGFyZW50Tm9kZSksZj1kLnRleHRDb250ZW50LnJlcGxhY2UoLyg/IV4pKCApezIsfSg/ISQpL2csXFxcIiBcXFwiKS5yZXBsYWNlKC9cXFxcbi9nLFxcXCIgXFxcIikucmVwbGFjZSgvXlsgXXsyLH0vZyxcXFwiIFxcXCIpLnJlcGxhY2UoL1sgXXsyLH0kL2csXFxcIiBcXFwiKTtpZihlKXt2YXIgZz1kLnByZXZpb3VzU2libGluZyxoPWQubmV4dFNpYmxpbmc7ZyYmaCYmXFxcIiBcXFwiPT1mP2Y9Yi5ub2RlLmlzQmxvY2soZykmJmIubm9kZS5pc0Jsb2NrKGgpP1xcXCJcXFwiOlxcXCJcXFxcblxcXCI6KGd8fChmPWYucmVwbGFjZSgvXiAqLyxcXFwiXFxcIikpLGh8fChmPWYucmVwbGFjZSgvICokLyxcXFwiXFxcIikpKX1kLnRleHRDb250ZW50PWZ9fWZ1bmN0aW9uIG8oYSxiLGMpe3ZhciBkPW5ldyBSZWdFeHAoYixcXFwiZ2lcXFwiKSxlPWQuZXhlYyhhKTtyZXR1cm4gZT9lW2NdOm51bGx9ZnVuY3Rpb24gcChhLGIpe3ZhciBjPWEubWF0Y2goLzwhRE9DVFlQRSA/KFteIF0qKSA/KFteIF0qKSA/XFxcIj8oW15cXFwiXSopXFxcIj8gP1xcXCI/KFteXFxcIl0qKVxcXCI/Pi9pKTtyZXR1cm4gYz9iLmltcGxlbWVudGF0aW9uLmNyZWF0ZURvY3VtZW50VHlwZShjWzFdLGNbM10sY1s0XSk6Yi5pbXBsZW1lbnRhdGlvbi5jcmVhdGVEb2N1bWVudFR5cGUoXFxcImh0bWxcXFwiKX1mdW5jdGlvbiBxKGEpe3ZhciBiPWEuZG9jdHlwZSxjPVxcXCI8IURPQ1RZUEUgaHRtbD5cXFwiO3JldHVybiBiJiYoYz1cXFwiPCFET0NUWVBFIFxcXCIrYi5uYW1lKyhiLnB1YmxpY0lkPycgUFVCTElDIFxcXCInK2IucHVibGljSWQrJ1xcXCInOlxcXCJcXFwiKSsoIWIucHVibGljSWQmJmIuc3lzdGVtSWQ/XFxcIiBTWVNURU1cXFwiOlxcXCJcXFwiKSsoYi5zeXN0ZW1JZD8nIFxcXCInK2Iuc3lzdGVtSWQrJ1xcXCInOlxcXCJcXFwiKStcXFwiPlxcXCIpLGN9ZnVuY3Rpb24gcihjLGQpe3ZhciBlPWMucGFyZW50Tm9kZTtpZihlJiYoYi5ub2RlLmlzQmxvY2soZSl8fGIubm9kZS5pc0VsZW1lbnQoZSkpJiZbXFxcIlREXFxcIixcXFwiVEhcXFwiXS5pbmRleE9mKGUudGFnTmFtZSk8MCl7dmFyIGY9Yy5wcmV2aW91c1NpYmxpbmcsZz1jLm5leHRTaWJsaW5nO2YmJmUmJlxcXCJCUlxcXCIhPWYudGFnTmFtZSYmIWIubm9kZS5pc0Jsb2NrKGYpJiYhZyYmZS50ZXh0Q29udGVudC5yZXBsYWNlKC9cXFxcdTIwMEIvZyxcXFwiXFxcIikubGVuZ3RoPjAmJmYudGV4dENvbnRlbnQubGVuZ3RoPjAmJiFiLm5vZGUuaGFzQ2xhc3MoZixcXFwiZnItbWFya2VyXFxcIikmJihiLmVsPT1lJiYhZyYmYi5vcHRzLmVudGVyPT1hLkZFLkVOVEVSX0JSJiZiLmJyb3dzZXIubXNpZXx8KGQmJmIuc2VsZWN0aW9uLnNhdmUoKSxjLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoYyksZCYmYi5zZWxlY3Rpb24ucmVzdG9yZSgpKSl9fWZ1bmN0aW9uIHMoKXt2YXIgYSxjPWIuc2VsZWN0aW9uLmVsZW1lbnQoKTthPWIubm9kZS5pc0Jsb2NrKGMpP2M6Yi5ub2RlLmJsb2NrUGFyZW50KGMpO3ZhciBkPVtdO2lmKGEpe3ZhciBlPWEubmV4dFNpYmxpbmcsZj1hLnByZXZpb3VzU2libGluZzthJiZkLmluZGV4T2YoYSk8MCYmZC5wdXNoKGEpLGYmJmIubm9kZS5pc0Jsb2NrKGYpJiZkLmluZGV4T2YoZik8MCYmZC5wdXNoKGYpLGUmJmIubm9kZS5pc0Jsb2NrKGUpJiZkLmluZGV4T2YoZSk8MCYmZC5wdXNoKGUpfWZvcih2YXIgZz1bXSxoPTA7aDxkLmxlbmd0aDtoKyspZm9yKHZhciBpPWRbaF0ucXVlcnlTZWxlY3RvckFsbChcXFwiYnJcXFwiKSxqPTA7ajxpLmxlbmd0aDtqKyspZy5pbmRleE9mKGlbal0pPDAmJmcucHVzaChpW2pdKTtpZihjLnBhcmVudE5vZGU9PWIuZWwpZm9yKHZhciBrPWIuZWwuY2hpbGRyZW4saD0wO2g8ay5sZW5ndGg7aCsrKVxcXCJCUlxcXCI9PWtbaF0udGFnTmFtZSYmZy5pbmRleE9mKGtbaF0pPDAmJmcucHVzaChrW2hdKTtyZXR1cm4gZ31mdW5jdGlvbiB0KGEsYyl7dmFyIGQ7aWYoYSl7ZD1zKCk7Zm9yKHZhciBlPTA7ZTxkLmxlbmd0aDtlKyspcihkW2VdLGMpfWVsc2V7ZD1iLmVsLmdldEVsZW1lbnRzQnlUYWdOYW1lKFxcXCJiclxcXCIpO2Zvcih2YXIgZT0wO2U8ZC5sZW5ndGg7ZSsrKXIoZFtlXSxjKX19ZnVuY3Rpb24gdSgpe2coKSxqKCksbigpLGIuc3BhY2VzLm5vcm1hbGl6ZShudWxsLCEwKSxiLmh0bWwuZmlsbEVtcHR5QmxvY2tzKCksYi5jbGVhbi5xdW90ZXMoKSxiLmNsZWFuLmxpc3RzKCksYi5jbGVhbi50YWJsZXMoKSxiLmNsZWFuLnRvSFRNTDUoKSxiLmh0bWwuY2xlYW5CUnMoKSxiLnNlbGVjdGlvbi5yZXN0b3JlKCksdigpLGIucGxhY2Vob2xkZXIucmVmcmVzaCgpfWZ1bmN0aW9uIHYoKXtiLmNvcmUuaXNFbXB0eSgpJiYobnVsbCE9YygpP2IuZWwucXVlcnlTZWxlY3RvcihmKCkpfHxiLmVsLnF1ZXJ5U2VsZWN0b3IoYi5vcHRzLmh0bWxEb05vdFdyYXBUYWdzLmpvaW4oXFxcIjpub3QoLmZyLW1hcmtlciksXFxcIikrXFxcIjpub3QoLmZyLW1hcmtlcilcXFwiKXx8KGIuY29yZS5oYXNGb2N1cygpPyhiLiRlbC5odG1sKFxcXCI8XFxcIitjKCkrXFxcIj5cXFwiK2EuRkUuTUFSS0VSUytcXFwiPGJyLz48L1xcXCIrYygpK1xcXCI+XFxcIiksYi5zZWxlY3Rpb24ucmVzdG9yZSgpKTpiLiRlbC5odG1sKFxcXCI8XFxcIitjKCkrXFxcIj48YnIvPjwvXFxcIitjKCkrXFxcIj5cXFwiKSk6Yi5lbC5xdWVyeVNlbGVjdG9yKFxcXCIqOm5vdCguZnItbWFya2VyKTpub3QoYnIpXFxcIil8fChiLmNvcmUuaGFzRm9jdXMoKT8oYi4kZWwuaHRtbChhLkZFLk1BUktFUlMrXFxcIjxici8+XFxcIiksYi5zZWxlY3Rpb24ucmVzdG9yZSgpKTpiLiRlbC5odG1sKFxcXCI8YnIvPlxcXCIpKSl9ZnVuY3Rpb24gdyhhLGIpe3JldHVybiBvKGEsXFxcIjxcXFwiK2IrXFxcIltePl0qPz4oW1xcXFxcXFxcd1xcXFxcXFxcV10qKTwvXFxcIitiK1xcXCI+XFxcIiwxKX1mdW5jdGlvbiB4KGMsZCl7dmFyIGU9YShcXFwiPGRpdiBcXFwiKyhvKGMsXFxcIjxcXFwiK2QrXFxcIihbXj5dKj8pPlxcXCIsMSl8fFxcXCJcXFwiKStcXFwiPlxcXCIpO3JldHVybiBiLm5vZGUucmF3QXR0cmlidXRlcyhlLmdldCgwKSl9ZnVuY3Rpb24geShhKXtyZXR1cm4gbyhhLFxcXCI8IURPQ1RZUEUoW14+XSo/KT5cXFwiLDApfHxcXFwiPCFET0NUWVBFIGh0bWw+XFxcIn1mdW5jdGlvbiB6KGMpe3ZhciBkPWIuY2xlYW4uaHRtbChjfHxcXFwiXFxcIixbXSxbXSxiLm9wdHMuZnVsbFBhZ2UpO2lmKGIub3B0cy5mdWxsUGFnZSl7dmFyIGU9dyhkLFxcXCJib2R5XFxcIil8fChkLmluZGV4T2YoXFxcIjxib2R5XFxcIik+PTA/XFxcIlxcXCI6ZCksZj14KGQsXFxcImJvZHlcXFwiKSxnPXcoZCxcXFwiaGVhZFxcXCIpfHxcXFwiPHRpdGxlPjwvdGl0bGU+XFxcIixoPXgoZCxcXFwiaGVhZFxcXCIpLGk9YShcXFwiPGRpdj5cXFwiKS5hcHBlbmQoZykuY29udGVudHMoKS5lYWNoKGZ1bmN0aW9uKCl7KHRoaXMubm9kZVR5cGU9PU5vZGUuQ09NTUVOVF9OT0RFfHxbXFxcIkJBU0VcXFwiLFxcXCJMSU5LXFxcIixcXFwiTUVUQVxcXCIsXFxcIk5PU0NSSVBUXFxcIixcXFwiU0NSSVBUXFxcIixcXFwiU1RZTEVcXFwiLFxcXCJURU1QTEFURVxcXCIsXFxcIlRJVExFXFxcIl0uaW5kZXhPZih0aGlzLnRhZ05hbWUpPj0wKSYmdGhpcy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMpfSkuZW5kKCkuaHRtbCgpLnRyaW0oKTtnPWEoXFxcIjxkaXY+XFxcIikuYXBwZW5kKGcpLmNvbnRlbnRzKCkubWFwKGZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubm9kZVR5cGU9PU5vZGUuQ09NTUVOVF9OT0RFP1xcXCI8IS0tXFxcIit0aGlzLm5vZGVWYWx1ZStcXFwiLS0+XFxcIjpbXFxcIkJBU0VcXFwiLFxcXCJMSU5LXFxcIixcXFwiTUVUQVxcXCIsXFxcIk5PU0NSSVBUXFxcIixcXFwiU0NSSVBUXFxcIixcXFwiU1RZTEVcXFwiLFxcXCJURU1QTEFURVxcXCIsXFxcIlRJVExFXFxcIl0uaW5kZXhPZih0aGlzLnRhZ05hbWUpPj0wP3RoaXMub3V0ZXJIVE1MOlxcXCJcXFwifSkudG9BcnJheSgpLmpvaW4oXFxcIlxcXCIpO3ZhciBqPXkoZCksaz14KGQsXFxcImh0bWxcXFwiKTtiLiRlbC5odG1sKGkrXFxcIlxcXFxuXFxcIitlKSxiLm5vZGUuY2xlYXJBdHRyaWJ1dGVzKGIuZWwpLGIuJGVsLmF0dHIoZiksYi4kZWwuYWRkQ2xhc3MoXFxcImZyLXZpZXdcXFwiKSxiLiRlbC5hdHRyKFxcXCJzcGVsbGNoZWNrXFxcIixiLm9wdHMuc3BlbGxjaGVjayksYi4kZWwuYXR0cihcXFwiZGlyXFxcIixiLm9wdHMuZGlyZWN0aW9uKSxiLiRoZWFkLmh0bWwoZyksYi5ub2RlLmNsZWFyQXR0cmlidXRlcyhiLiRoZWFkLmdldCgwKSksYi4kaGVhZC5hdHRyKGgpLGIubm9kZS5jbGVhckF0dHJpYnV0ZXMoYi4kaHRtbC5nZXQoMCkpLGIuJGh0bWwuYXR0cihrKSxiLmlmcmFtZV9kb2N1bWVudC5kb2N0eXBlLnBhcmVudE5vZGUucmVwbGFjZUNoaWxkKHAoaixiLmlmcmFtZV9kb2N1bWVudCksYi5pZnJhbWVfZG9jdW1lbnQuZG9jdHlwZSl9ZWxzZSBiLiRlbC5odG1sKGQpO3ZhciBsPWIuZWRpdC5pc0Rpc2FibGVkKCk7Yi5lZGl0Lm9uKCksYi5jb3JlLmluamVjdFN0eWxlKGIub3B0cy5pZnJhbWVTdHlsZSksdSgpLGIub3B0cy51c2VDbGFzc2VzfHwoYi4kZWwuZmluZChcXFwiW2ZyLW9yaWdpbmFsLWNsYXNzXVxcXCIpLmVhY2goZnVuY3Rpb24oKXt0aGlzLnNldEF0dHJpYnV0ZShcXFwiY2xhc3NcXFwiLHRoaXMuZ2V0QXR0cmlidXRlKFxcXCJmci1vcmlnaW5hbC1jbGFzc1xcXCIpKSx0aGlzLnJlbW92ZUF0dHJpYnV0ZShcXFwiZnItb3JpZ2luYWwtY2xhc3NcXFwiKX0pLGIuJGVsLmZpbmQoXFxcIltmci1vcmlnaW5hbC1zdHlsZV1cXFwiKS5lYWNoKGZ1bmN0aW9uKCl7dGhpcy5zZXRBdHRyaWJ1dGUoXFxcInN0eWxlXFxcIix0aGlzLmdldEF0dHJpYnV0ZShcXFwiZnItb3JpZ2luYWwtc3R5bGVcXFwiKSksdGhpcy5yZW1vdmVBdHRyaWJ1dGUoXFxcImZyLW9yaWdpbmFsLXN0eWxlXFxcIil9KSksbCYmYi5lZGl0Lm9mZigpLGIuZXZlbnRzLnRyaWdnZXIoXFxcImh0bWwuc2V0XFxcIil9ZnVuY3Rpb24gQShhLGMpe2lmKCFiLiR3cClyZXR1cm4gYi4kb2VsLmNsb25lKCkucmVtb3ZlQ2xhc3MoXFxcImZyLXZpZXdcXFwiKS5yZW1vdmVBdHRyKFxcXCJjb250ZW50ZWRpdGFibGVcXFwiKS5nZXQoMCkub3V0ZXJIVE1MO3ZhciBkPVxcXCJcXFwiO2IuZXZlbnRzLnRyaWdnZXIoXFxcImh0bWwuYmVmb3JlR2V0XFxcIik7dmFyIGUsZj1mdW5jdGlvbihhKXt2YXIgYj0vKCNbXlxcXFxzXFxcXCs+flxcXFwuXFxcXFs6XSspL2csYz0vKFxcXFxbW15cXFxcXV0rXFxcXF0pL2csZD0vKFxcXFwuW15cXFxcc1xcXFwrPn5cXFxcLlxcXFxbOl0rKS9nLGU9Lyg6OlteXFxcXHNcXFxcKz5+XFxcXC5cXFxcWzpdK3w6Zmlyc3QtbGluZXw6Zmlyc3QtbGV0dGVyfDpiZWZvcmV8OmFmdGVyKS9naSxmPS8oOltcXFxcdy1dK1xcXFwoW15cXFxcKV0qXFxcXCkpL2dpLGc9Lyg6W15cXFxcc1xcXFwrPn5cXFxcLlxcXFxbOl0rKS9nLGg9LyhbXlxcXFxzXFxcXCs+flxcXFwuXFxcXFs6XSspL2c7IWZ1bmN0aW9uKCl7dmFyIGI9Lzpub3RcXFxcKChbXlxcXFwpXSopXFxcXCkvZztiLnRlc3QoYSkmJihhPWEucmVwbGFjZShiLFxcXCIgICAgICQxIFxcXCIpKX0oKTt2YXIgaT0xMDAqKGEubWF0Y2goYil8fFtdKS5sZW5ndGgrMTAqKGEubWF0Y2goYyl8fFtdKS5sZW5ndGgrMTAqKGEubWF0Y2goZCl8fFtdKS5sZW5ndGgrMTAqKGEubWF0Y2goZil8fFtdKS5sZW5ndGgrMTAqKGEubWF0Y2goZyl8fFtdKS5sZW5ndGgrKGEubWF0Y2goZSl8fFtdKS5sZW5ndGg7cmV0dXJuIGE9YS5yZXBsYWNlKC9bXFxcXCpcXFxcc1xcXFwrPn5dL2csXFxcIiBcXFwiKSxhPWEucmVwbGFjZSgvWyNcXFxcLl0vZyxcXFwiIFxcXCIpLGkrPShhLm1hdGNoKGgpfHxbXSkubGVuZ3RofSxnPVtdLGg9e307aWYoIWIub3B0cy51c2VDbGFzc2VzJiYhYyl7dmFyIGk9bmV3IFJlZ0V4cChcXFwiXlxcXCIrYi5vcHRzLmh0bWxJZ25vcmVDU1NQcm9wZXJ0aWVzLmpvaW4oXFxcIiR8XlxcXCIpK1xcXCIkXFxcIixcXFwiZ2lcXFwiKTtmb3IoZT0wO2U8Yi5kb2Muc3R5bGVTaGVldHMubGVuZ3RoO2UrKyl7dmFyIGosaz0wO3RyeXtqPWIuZG9jLnN0eWxlU2hlZXRzW2VdLmNzc1J1bGVzLGIuZG9jLnN0eWxlU2hlZXRzW2VdLm93bmVyTm9kZSYmXFxcIlNUWUxFXFxcIj09Yi5kb2Muc3R5bGVTaGVldHNbZV0ub3duZXJOb2RlLm5vZGVUeXBlJiYoaz0xKX1jYXRjaChsKXt9aWYoailmb3IodmFyIG09MCxuPWoubGVuZ3RoO208bjttKyspaWYoalttXS5zZWxlY3RvclRleHQmJmpbbV0uc3R5bGUuY3NzVGV4dC5sZW5ndGg+MCl7dmFyIG8scD1qW21dLnNlbGVjdG9yVGV4dC5yZXBsYWNlKC9ib2R5IHxcXFxcLmZyLXZpZXcgL2csXFxcIlxcXCIpLnJlcGxhY2UoLzo6L2csXFxcIjpcXFwiKTt0cnl7bz1iLmVsLnF1ZXJ5U2VsZWN0b3JBbGwocCl9Y2F0Y2gobCl7bz1bXX1mb3IodmFyIHI9MDtyPG8ubGVuZ3RoO3IrKyl7IW9bcl0uZ2V0QXR0cmlidXRlKFxcXCJmci1vcmlnaW5hbC1zdHlsZVxcXCIpJiZvW3JdLmdldEF0dHJpYnV0ZShcXFwic3R5bGVcXFwiKT8ob1tyXS5zZXRBdHRyaWJ1dGUoXFxcImZyLW9yaWdpbmFsLXN0eWxlXFxcIixvW3JdLmdldEF0dHJpYnV0ZShcXFwic3R5bGVcXFwiKSksZy5wdXNoKG9bcl0pKTpvW3JdLmdldEF0dHJpYnV0ZShcXFwiZnItb3JpZ2luYWwtc3R5bGVcXFwiKXx8Zy5wdXNoKG9bcl0pLGhbb1tyXV18fChoW29bcl1dPXt9KTtmb3IodmFyIHM9MWUzKmsrZihqW21dLnNlbGVjdG9yVGV4dCksdD1qW21dLnN0eWxlLmNzc1RleHQuc3BsaXQoXFxcIjtcXFwiKSx1PTA7dTx0Lmxlbmd0aDt1Kyspe3ZhciB2PXRbdV0udHJpbSgpLnNwbGl0KFxcXCI6XFxcIilbMF07di5tYXRjaChpKXx8KGhbb1tyXV1bdl18fChoW29bcl1dW3ZdPTAsKG9bcl0uZ2V0QXR0cmlidXRlKFxcXCJmci1vcmlnaW5hbC1zdHlsZVxcXCIpfHxcXFwiXFxcIikuaW5kZXhPZih2K1xcXCI6XFxcIik+PTAmJihoW29bcl1dW3ZdPTFlNCkpLHM+PWhbb1tyXV1bdl0mJihoW29bcl1dW3ZdPXMsdFt1XS50cmltKCkubGVuZ3RoJiYob1tyXS5zdHlsZVt2LnRyaW0oKV09dFt1XS50cmltKCkuc3BsaXQoXFxcIjpcXFwiKVsxXS50cmltKCkpKSl9fX19Zm9yKGU9MDtlPGcubGVuZ3RoO2UrKylpZihnW2VdLmdldEF0dHJpYnV0ZShcXFwiY2xhc3NcXFwiKSYmKGdbZV0uc2V0QXR0cmlidXRlKFxcXCJmci1vcmlnaW5hbC1jbGFzc1xcXCIsZ1tlXS5nZXRBdHRyaWJ1dGUoXFxcImNsYXNzXFxcIikpLGdbZV0ucmVtb3ZlQXR0cmlidXRlKFxcXCJjbGFzc1xcXCIpKSwoZ1tlXS5nZXRBdHRyaWJ1dGUoXFxcImZyLW9yaWdpbmFsLXN0eWxlXFxcIil8fFxcXCJcXFwiKS50cmltKCkubGVuZ3RoPjApZm9yKHZhciB3PWdbZV0uZ2V0QXR0cmlidXRlKFxcXCJmci1vcmlnaW5hbC1zdHlsZVxcXCIpLnNwbGl0KFxcXCI7XFxcIikscj0wO3I8dy5sZW5ndGg7cisrKXdbcl0uaW5kZXhPZihcXFwiOlxcXCIpPjAmJihnW2VdLnN0eWxlW3dbcl0uc3BsaXQoXFxcIjpcXFwiKVswXS50cmltKCldPXdbcl0uc3BsaXQoXFxcIjpcXFwiKVsxXS50cmltKCkpfWlmKGIuY29yZS5pc0VtcHR5KCk/Yi5vcHRzLmZ1bGxQYWdlJiYoZD1xKGIuaWZyYW1lX2RvY3VtZW50KSxkKz1cXFwiPGh0bWxcXFwiK2Iubm9kZS5hdHRyaWJ1dGVzKGIuJGh0bWwuZ2V0KDApKStcXFwiPlxcXCIrYi4kaHRtbC5maW5kKFxcXCJoZWFkXFxcIikuZ2V0KDApLm91dGVySFRNTCtcXFwiPGJvZHk+PC9ib2R5PjwvaHRtbD5cXFwiKTooXFxcInVuZGVmaW5lZFxcXCI9PXR5cGVvZiBhJiYoYT0hMSksYi5vcHRzLmZ1bGxQYWdlPyhkPXEoYi5pZnJhbWVfZG9jdW1lbnQpLGIuJGVsLnJlbW92ZUNsYXNzKFxcXCJmci12aWV3XFxcIiksZCs9XFxcIjxodG1sXFxcIitiLm5vZGUuYXR0cmlidXRlcyhiLiRodG1sLmdldCgwKSkrXFxcIj5cXFwiK2IuJGh0bWwuaHRtbCgpK1xcXCI8L2h0bWw+XFxcIixiLiRlbC5hZGRDbGFzcyhcXFwiZnItdmlld1xcXCIpKTpkPWIuJGVsLmh0bWwoKSksIWIub3B0cy51c2VDbGFzc2VzJiYhYylmb3IoZT0wO2U8Zy5sZW5ndGg7ZSsrKWdbZV0uZ2V0QXR0cmlidXRlKFxcXCJmci1vcmlnaW5hbC1jbGFzc1xcXCIpJiYoZ1tlXS5zZXRBdHRyaWJ1dGUoXFxcImNsYXNzXFxcIixnW2VdLmdldEF0dHJpYnV0ZShcXFwiZnItb3JpZ2luYWwtY2xhc3NcXFwiKSksZ1tlXS5yZW1vdmVBdHRyaWJ1dGUoXFxcImZyLW9yaWdpbmFsLWNsYXNzXFxcIikpLGdbZV0uZ2V0QXR0cmlidXRlKFxcXCJmci1vcmlnaW5hbC1zdHlsZVxcXCIpPyhnW2VdLnNldEF0dHJpYnV0ZShcXFwic3R5bGVcXFwiLGdbZV0uZ2V0QXR0cmlidXRlKFxcXCJmci1vcmlnaW5hbC1zdHlsZVxcXCIpKSxnW2VdLnJlbW92ZUF0dHJpYnV0ZShcXFwiZnItb3JpZ2luYWwtc3R5bGVcXFwiKSk6Z1tlXS5yZW1vdmVBdHRyaWJ1dGUoXFxcInN0eWxlXFxcIik7Yi5vcHRzLmZ1bGxQYWdlJiYoZD1kLnJlcGxhY2UoLzxzdHlsZSBkYXRhLWZyLXN0eWxlPVxcXCJ0cnVlXFxcIj4oPzpbXFxcXHdcXFxcV10qPyk8XFxcXC9zdHlsZT4vZyxcXFwiXFxcIiksZD1kLnJlcGxhY2UoLzxsaW5rKFtePl0qKWRhdGEtZnItc3R5bGU9XFxcInRydWVcXFwiKFtePl0qKT4vZyxcXFwiXFxcIiksZD1kLnJlcGxhY2UoLzxzdHlsZSg/OltcXFxcd1xcXFxXXSo/KWNsYXNzPVxcXCJmaXJlYnVnUmVzZXRTdHlsZXNcXFwiKD86W1xcXFx3XFxcXFddKj8pPig/OltcXFxcd1xcXFxXXSo/KTxcXFxcL3N0eWxlPi9nLFxcXCJcXFwiKSxkPWQucmVwbGFjZSgvPGJvZHkoKD86W1xcXFx3XFxcXFddKj8pKSBzcGVsbGNoZWNrPVxcXCJ0cnVlXFxcIigoPzpbXFxcXHdcXFxcV10qPykpPigoPzpbXFxcXHdcXFxcV10qPykpPFxcXFwvYm9keT4vZyxcXFwiPGJvZHkkMSQyPiQzPC9ib2R5PlxcXCIpLGQ9ZC5yZXBsYWNlKC88Ym9keSgoPzpbXFxcXHdcXFxcV10qPykpIGNvbnRlbnRlZGl0YWJsZT1cXFwiKHRydWV8ZmFsc2UpXFxcIigoPzpbXFxcXHdcXFxcV10qPykpPigoPzpbXFxcXHdcXFxcV10qPykpPFxcXFwvYm9keT4vZyxcXFwiPGJvZHkkMSQzPiQ0PC9ib2R5PlxcXCIpLGQ9ZC5yZXBsYWNlKC88Ym9keSgoPzpbXFxcXHdcXFxcV10qPykpIGRpcj1cXFwiKFtcXFxcd10qKVxcXCIoKD86W1xcXFx3XFxcXFddKj8pKT4oKD86W1xcXFx3XFxcXFddKj8pKTxcXFxcL2JvZHk+L2csXFxcIjxib2R5JDEkMz4kNDwvYm9keT5cXFwiKSxkPWQucmVwbGFjZSgvPGJvZHkoKD86W1xcXFx3XFxcXFddKj8pKWNsYXNzPVxcXCIoW1xcXFx3XFxcXFddKj8pKGZyLXJ0bHxmci1sdHIpKFtcXFxcd1xcXFxXXSo/KVxcXCIoKD86W1xcXFx3XFxcXFddKj8pKT4oKD86W1xcXFx3XFxcXFddKj8pKTxcXFxcL2JvZHk+L2csJzxib2R5JDFjbGFzcz1cXFwiJDIkNFxcXCIkNT4kNjwvYm9keT4nKSxkPWQucmVwbGFjZSgvPGJvZHkoKD86W1xcXFx3XFxcXFddKj8pKSBjbGFzcz1cXFwiXFxcIigoPzpbXFxcXHdcXFxcV10qPykpPigoPzpbXFxcXHdcXFxcV10qPykpPFxcXFwvYm9keT4vZyxcXFwiPGJvZHkkMSQyPiQzPC9ib2R5PlxcXCIpKSxiLm9wdHMuaHRtbFNpbXBsZUFtcGVyc2FuZCYmKGQ9ZC5yZXBsYWNlKC9cXFxcJmFtcDsvZ2ksXFxcIiZcXFwiKSksYi5ldmVudHMudHJpZ2dlcihcXFwiaHRtbC5hZnRlckdldFxcXCIpLGF8fChkPWQucmVwbGFjZSgvPHNwYW5bXj5dKj8gY2xhc3NcXFxccyo9XFxcXHMqW1xcXCInXT9mci1tYXJrZXJbXFxcIiddP1tePl0rPlxcXFx1MjAwYjxcXFxcL3NwYW4+L2dpLFxcXCJcXFwiKSksZD1iLmNsZWFuLmludmlzaWJsZVNwYWNlcyhkKTt2YXIgeD1iLmV2ZW50cy5jaGFpblRyaWdnZXIoXFxcImh0bWwuZ2V0XFxcIixkKTtyZXR1cm5cXFwic3RyaW5nXFxcIj09dHlwZW9mIHgmJihkPXgpLGQ9ZC5yZXBsYWNlKC88cHJlKD86W1xcXFx3XFxcXFddKj8pPig/OltcXFxcd1xcXFxXXSo/KTxcXFxcL3ByZT4vZyxmdW5jdGlvbihhKXtyZXR1cm4gYS5yZXBsYWNlKC88YnI+L2csXFxcIlxcXFxuXFxcIil9KX1mdW5jdGlvbiBCKCl7dmFyIGM9ZnVuY3Rpb24oYyxkKXtmb3IoO2QmJihkLm5vZGVUeXBlPT1Ob2RlLlRFWFRfTk9ERXx8IWIubm9kZS5pc0Jsb2NrKGQpKSYmIWIubm9kZS5pc0VsZW1lbnQoZCk7KWQmJmQubm9kZVR5cGUhPU5vZGUuVEVYVF9OT0RFJiZhKGMpLndyYXBJbm5lcihiLm5vZGUub3BlblRhZ1N0cmluZyhkKStiLm5vZGUuY2xvc2VUYWdTdHJpbmcoZCkpLGQ9ZC5wYXJlbnROb2RlO2QmJmMuaW5uZXJIVE1MPT1kLmlubmVySFRNTCYmKGMuaW5uZXJIVE1MPWQub3V0ZXJIVE1MKX0sZD1mdW5jdGlvbigpe3ZhciBjLGQ9bnVsbDtyZXR1cm4gYi53aW4uZ2V0U2VsZWN0aW9uPyhjPWIud2luLmdldFNlbGVjdGlvbigpLGMmJmMucmFuZ2VDb3VudCYmKGQ9Yy5nZXRSYW5nZUF0KDApLmNvbW1vbkFuY2VzdG9yQ29udGFpbmVyLGQubm9kZVR5cGUhPU5vZGUuRUxFTUVOVF9OT0RFJiYoZD1kLnBhcmVudE5vZGUpKSk6KGM9Yi5kb2Muc2VsZWN0aW9uKSYmXFxcIkNvbnRyb2xcXFwiIT1jLnR5cGUmJihkPWMuY3JlYXRlUmFuZ2UoKS5wYXJlbnRFbGVtZW50KCkpLG51bGwhPWQmJihhLmluQXJyYXkoYi5lbCxhKGQpLnBhcmVudHMoKSk+PTB8fGQ9PWIuZWwpP2Q6bnVsbH0sZT1cXFwiXFxcIjtpZihcXFwidW5kZWZpbmVkXFxcIiE9dHlwZW9mIGIud2luLmdldFNlbGVjdGlvbil7XFxuYi5icm93c2VyLm1vemlsbGEmJihiLnNlbGVjdGlvbi5zYXZlKCksYi4kZWwuZmluZCgnLmZyLW1hcmtlcltkYXRhLXR5cGU9XFxcImZhbHNlXFxcIl0nKS5sZW5ndGg+MSYmKGIuJGVsLmZpbmQoJy5mci1tYXJrZXJbZGF0YS10eXBlPVxcXCJmYWxzZVxcXCJdW2RhdGEtaWQ9XFxcIjBcXFwiXScpLnJlbW92ZSgpLGIuJGVsLmZpbmQoJy5mci1tYXJrZXJbZGF0YS10eXBlPVxcXCJmYWxzZVxcXCJdOmxhc3QnKS5hdHRyKFxcXCJkYXRhLWlkXFxcIixcXFwiMFxcXCIpLGIuJGVsLmZpbmQoXFxcIi5mci1tYXJrZXJcXFwiKS5ub3QoJ1tkYXRhLWlkPVxcXCIwXFxcIl0nKS5yZW1vdmUoKSksYi5zZWxlY3Rpb24ucmVzdG9yZSgpKTtmb3IodmFyIGY9Yi5zZWxlY3Rpb24ucmFuZ2VzKCksZz0wO2c8Zi5sZW5ndGg7ZysrKXt2YXIgaD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFxcXCJkaXZcXFwiKTtoLmFwcGVuZENoaWxkKGZbZ10uY2xvbmVDb250ZW50cygpKSxjKGgsZCgpKSxhKGgpLmZpbmQoXFxcIi5mci1lbGVtZW50XFxcIikubGVuZ3RoPjAmJihoPWIuZWwpLGUrPWguaW5uZXJIVE1MfX1lbHNlXFxcInVuZGVmaW5lZFxcXCIhPXR5cGVvZiBiLmRvYy5zZWxlY3Rpb24mJlxcXCJUZXh0XFxcIj09Yi5kb2Muc2VsZWN0aW9uLnR5cGUmJihlPWIuZG9jLnNlbGVjdGlvbi5jcmVhdGVSYW5nZSgpLmh0bWxUZXh0KTtyZXR1cm4gZX1mdW5jdGlvbiBDKGEpe3ZhciBjPWIuZG9jLmNyZWF0ZUVsZW1lbnQoXFxcImRpdlxcXCIpO3JldHVybiBjLmlubmVySFRNTD1hLG51bGwhPT1jLnF1ZXJ5U2VsZWN0b3IoZigpKX1mdW5jdGlvbiBEKGEpe3ZhciBjPWIuZG9jLmNyZWF0ZUVsZW1lbnQoXFxcImRpdlxcXCIpO3JldHVybiBjLmlubmVySFRNTD1hLGIuc2VsZWN0aW9uLnNldEF0RW5kKGMpLGMuaW5uZXJIVE1MfWZ1bmN0aW9uIEUoYSl7cmV0dXJuIGEucmVwbGFjZSgvPC9naSxcXFwiJmx0O1xcXCIpLnJlcGxhY2UoLz4vZ2ksXFxcIiZndDtcXFwiKS5yZXBsYWNlKC9cXFwiL2dpLFxcXCImcXVvdDtcXFwiKS5yZXBsYWNlKC8nL2dpLFxcXCImIzM5O1xcXCIpfWZ1bmN0aW9uIEYoYSxjLGQpe2Iuc2VsZWN0aW9uLmlzQ29sbGFwc2VkKCl8fGIuc2VsZWN0aW9uLnJlbW92ZSgpO3ZhciBlO2lmKGU9Yz9hOmIuY2xlYW4uaHRtbChhKSxlPWUucmVwbGFjZSgvXFxcXHJ8XFxcXG4vZyxcXFwiIFxcXCIpLGEuaW5kZXhPZignY2xhc3M9XFxcImZyLW1hcmtlclxcXCInKTwwJiYoZT1EKGUpKSxiLmNvcmUuaXNFbXB0eSgpJiYhYi5vcHRzLmtlZXBGb3JtYXRPbkRlbGV0ZSliLmVsLmlubmVySFRNTD1lO2Vsc2V7dmFyIGY9Yi5tYXJrZXJzLmluc2VydCgpO2lmKGYpe3ZhciBnLGg9Yi5ub2RlLmJsb2NrUGFyZW50KGYpO2lmKChDKGUpfHxkKSYmKGc9Yi5ub2RlLmRlZXBlc3RQYXJlbnQoZil8fGgmJlxcXCJMSVxcXCI9PWgudGFnTmFtZSkpe3ZhciBmPWIubWFya2Vycy5zcGxpdCgpO2lmKCFmKXJldHVybiExO2Yub3V0ZXJIVE1MPWV9ZWxzZSBmLm91dGVySFRNTD1lfWVsc2UgYi5lbC5pbm5lckhUTUw9Yi5lbC5pbm5lckhUTUwrZX11KCksYi5ldmVudHMudHJpZ2dlcihcXFwiaHRtbC5pbnNlcnRlZFxcXCIpfWZ1bmN0aW9uIEcoYyl7dmFyIGQ9bnVsbDtpZihcXFwidW5kZWZpbmVkXFxcIj09dHlwZW9mIGMmJihkPWIuc2VsZWN0aW9uLmVsZW1lbnQoKSksYi5vcHRzLmtlZXBGb3JtYXRPbkRlbGV0ZSlyZXR1cm4hMTt2YXIgZT1kPyhkLnRleHRDb250ZW50Lm1hdGNoKC9cXFxcdTIwMEIvZyl8fFtdKS5sZW5ndGgtZC5xdWVyeVNlbGVjdG9yQWxsKFxcXCIuZnItbWFya2VyXFxcIikubGVuZ3RoOjAsZj0oYi5lbC50ZXh0Q29udGVudC5tYXRjaCgvXFxcXHUyMDBCL2cpfHxbXSkubGVuZ3RoLWIuZWwucXVlcnlTZWxlY3RvckFsbChcXFwiLmZyLW1hcmtlclxcXCIpLmxlbmd0aDtpZihmPT1lKXJldHVybiExO3ZhciBnLGg7ZG97aD0hMSxnPWIuZWwucXVlcnlTZWxlY3RvckFsbChcXFwiKjpub3QoLmZyLW1hcmtlcilcXFwiKTtmb3IodmFyIGk9MDtpPGcubGVuZ3RoO2krKyl7dmFyIGo9Z1tpXTtpZihkIT1qKXt2YXIgaz1qLnRleHRDb250ZW50OzA9PT1qLmNoaWxkcmVuLmxlbmd0aCYmMT09PWsubGVuZ3RoJiY4MjAzPT1rLmNoYXJDb2RlQXQoMCkmJihhKGopLnJlbW92ZSgpLGg9ITApfX19d2hpbGUoaCl9ZnVuY3Rpb24gSCgpe3ZhciBhPWZ1bmN0aW9uKCl7RygpLGIucGxhY2Vob2xkZXImJmIucGxhY2Vob2xkZXIucmVmcmVzaCgpfTtiLmV2ZW50cy5vbihcXFwibW91c2V1cFxcXCIsYSksYi5ldmVudHMub24oXFxcImtleWRvd25cXFwiLGEpLGIuZXZlbnRzLm9uKFxcXCJjb250ZW50Q2hhbmdlZFxcXCIsdil9cmV0dXJue2RlZmF1bHRUYWc6YyxlbXB0eUJsb2NrczpkLGVtcHR5QmxvY2tUYWdzUXVlcnk6ZSxibG9ja1RhZ3NRdWVyeTpmLGZpbGxFbXB0eUJsb2NrczpsLGNsZWFuRW1wdHlUYWdzOmcsY2xlYW5XaGl0ZVRhZ3M6RyxjbGVhbkJsYW5rU3BhY2VzOm4sYmxvY2tzOm0sZ2V0RG9jdHlwZTpxLHNldDp6LGdldDpBLGdldFNlbGVjdGVkOkIsaW5zZXJ0OkYsd3JhcDpqLHVud3JhcDprLGVzY2FwZUVudGl0aWVzOkUsY2hlY2tJZkVtcHR5OnYsZXh0cmFjdE5vZGU6dyxleHRyYWN0Tm9kZUF0dHJzOngsZXh0cmFjdERvY3R5cGU6eSxjbGVhbkJSczp0LF9pbml0Okh9fSxhLmV4dGVuZChhLkZFLkRFRkFVTFRTLHtoZWlnaHQ6bnVsbCxoZWlnaHRNYXg6bnVsbCxoZWlnaHRNaW46bnVsbCx3aWR0aDpudWxsfSksYS5GRS5NT0RVTEVTLnNpemU9ZnVuY3Rpb24oYSl7ZnVuY3Rpb24gYigpe2MoKSxhLm9wdHMuaGVpZ2h0JiZhLiRlbC5jc3MoXFxcIm1pbkhlaWdodFxcXCIsYS5vcHRzLmhlaWdodC1hLmhlbHBlcnMuZ2V0UFgoYS4kZWwuY3NzKFxcXCJwYWRkaW5nLXRvcFxcXCIpKS1hLmhlbHBlcnMuZ2V0UFgoYS4kZWwuY3NzKFxcXCJwYWRkaW5nLWJvdHRvbVxcXCIpKSksYS4kaWZyYW1lLmhlaWdodChhLiRlbC5vdXRlckhlaWdodCghMCkpfWZ1bmN0aW9uIGMoKXthLm9wdHMuaGVpZ2h0TWluP2EuJGVsLmNzcyhcXFwibWluSGVpZ2h0XFxcIixhLm9wdHMuaGVpZ2h0TWluKTphLiRlbC5jc3MoXFxcIm1pbkhlaWdodFxcXCIsXFxcIlxcXCIpLGEub3B0cy5oZWlnaHRNYXg/KGEuJHdwLmNzcyhcXFwibWF4SGVpZ2h0XFxcIixhLm9wdHMuaGVpZ2h0TWF4KSxhLiR3cC5jc3MoXFxcIm92ZXJmbG93XFxcIixcXFwiYXV0b1xcXCIpKTooYS4kd3AuY3NzKFxcXCJtYXhIZWlnaHRcXFwiLFxcXCJcXFwiKSxhLiR3cC5jc3MoXFxcIm92ZXJmbG93XFxcIixcXFwiXFxcIikpLGEub3B0cy5oZWlnaHQ/KGEuJHdwLmhlaWdodChhLm9wdHMuaGVpZ2h0KSxhLiRlbC5jc3MoXFxcIm1pbkhlaWdodFxcXCIsYS5vcHRzLmhlaWdodC1hLmhlbHBlcnMuZ2V0UFgoYS4kZWwuY3NzKFxcXCJwYWRkaW5nLXRvcFxcXCIpKS1hLmhlbHBlcnMuZ2V0UFgoYS4kZWwuY3NzKFxcXCJwYWRkaW5nLWJvdHRvbVxcXCIpKSksYS4kd3AuY3NzKFxcXCJvdmVyZmxvd1xcXCIsXFxcImF1dG9cXFwiKSk6KGEuJHdwLmNzcyhcXFwiaGVpZ2h0XFxcIixcXFwiXFxcIiksYS5vcHRzLmhlaWdodE1pbnx8YS4kZWwuY3NzKFxcXCJtaW5IZWlnaHRcXFwiLFxcXCJcXFwiKSxhLm9wdHMuaGVpZ2h0TWF4fHxhLiR3cC5jc3MoXFxcIm92ZXJmbG93XFxcIixcXFwiXFxcIikpLGEub3B0cy53aWR0aCYmYS4kYm94LndpZHRoKGEub3B0cy53aWR0aCl9ZnVuY3Rpb24gZCgpe3JldHVybiEhYS4kd3AmJihjKCksdm9pZChhLiRpZnJhbWUmJihhLmV2ZW50cy5vbihcXFwia2V5dXBcXFwiLGIpLGEuZXZlbnRzLm9uKFxcXCJjb21tYW5kcy5hZnRlclxcXCIsYiksYS5ldmVudHMub24oXFxcImh0bWwuc2V0XFxcIixiKSxhLmV2ZW50cy5vbihcXFwiaW5pdFxcXCIsYiksYS5ldmVudHMub24oXFxcImluaXRpYWxpemVkXFxcIixiKSkpKX1yZXR1cm57X2luaXQ6ZCxzeW5jSWZyYW1lOmIscmVmcmVzaDpjfX0sYS5leHRlbmQoYS5GRS5ERUZBVUxUUyx7bGFuZ3VhZ2U6bnVsbH0pLGEuRkUuTEFOR1VBR0U9e30sYS5GRS5NT0RVTEVTLmxhbmd1YWdlPWZ1bmN0aW9uKGIpe2Z1bmN0aW9uIGMoYSl7cmV0dXJuIGUmJmUudHJhbnNsYXRpb25bYV0/ZS50cmFuc2xhdGlvblthXTphfWZ1bmN0aW9uIGQoKXthLkZFLkxBTkdVQUdFJiYoZT1hLkZFLkxBTkdVQUdFW2Iub3B0cy5sYW5ndWFnZV0pLGUmJmUuZGlyZWN0aW9uJiYoYi5vcHRzLmRpcmVjdGlvbj1lLmRpcmVjdGlvbil9dmFyIGU7cmV0dXJue19pbml0OmQsdHJhbnNsYXRlOmN9fSxhLmV4dGVuZChhLkZFLkRFRkFVTFRTLHtwbGFjZWhvbGRlclRleHQ6XFxcIlR5cGUgc29tZXRoaW5nXFxcIn0pLGEuRkUuTU9EVUxFUy5wbGFjZWhvbGRlcj1mdW5jdGlvbihiKXtmdW5jdGlvbiBjKCl7Yi4kcGxhY2Vob2xkZXJ8fGcoKTt2YXIgYz0wLGQ9MCxlPTAsZj0wLGg9MCxpPTAsaj1iLm5vZGUuY29udGVudHMoYi5lbCksaz1hKGIuc2VsZWN0aW9uLmVsZW1lbnQoKSkuY3NzKFxcXCJ0ZXh0LWFsaWduXFxcIik7aWYoai5sZW5ndGgmJmpbMF0ubm9kZVR5cGU9PU5vZGUuRUxFTUVOVF9OT0RFKXt2YXIgbD1hKGpbMF0pOyFiLm9wdHMudG9vbGJhcklubGluZSYmYi5yZWFkeSYmKGM9Yi5oZWxwZXJzLmdldFBYKGwuY3NzKFxcXCJtYXJnaW4tdG9wXFxcIikpLGY9Yi5oZWxwZXJzLmdldFBYKGwuY3NzKFxcXCJwYWRkaW5nLXRvcFxcXCIpKSxkPWIuaGVscGVycy5nZXRQWChsLmNzcyhcXFwibWFyZ2luLWxlZnRcXFwiKSksZT1iLmhlbHBlcnMuZ2V0UFgobC5jc3MoXFxcIm1hcmdpbi1yaWdodFxcXCIpKSxoPWIuaGVscGVycy5nZXRQWChsLmNzcyhcXFwicGFkZGluZy1sZWZ0XFxcIikpLGk9Yi5oZWxwZXJzLmdldFBYKGwuY3NzKFxcXCJwYWRkaW5nLXJpZ2h0XFxcIikpKSxiLiRwbGFjZWhvbGRlci5jc3MoXFxcImZvbnQtc2l6ZVxcXCIsbC5jc3MoXFxcImZvbnQtc2l6ZVxcXCIpKSxiLiRwbGFjZWhvbGRlci5jc3MoXFxcImxpbmUtaGVpZ2h0XFxcIixsLmNzcyhcXFwibGluZS1oZWlnaHRcXFwiKSl9ZWxzZSBiLiRwbGFjZWhvbGRlci5jc3MoXFxcImZvbnQtc2l6ZVxcXCIsYi4kZWwuY3NzKFxcXCJmb250LXNpemVcXFwiKSksYi4kcGxhY2Vob2xkZXIuY3NzKFxcXCJsaW5lLWhlaWdodFxcXCIsYi4kZWwuY3NzKFxcXCJsaW5lLWhlaWdodFxcXCIpKTtiLiR3cC5hZGRDbGFzcyhcXFwic2hvdy1wbGFjZWhvbGRlclxcXCIpLGIuJHBsYWNlaG9sZGVyLmNzcyh7bWFyZ2luVG9wOk1hdGgubWF4KGIuaGVscGVycy5nZXRQWChiLiRlbC5jc3MoXFxcIm1hcmdpbi10b3BcXFwiKSksYykscGFkZGluZ1RvcDpNYXRoLm1heChiLmhlbHBlcnMuZ2V0UFgoYi4kZWwuY3NzKFxcXCJwYWRkaW5nLXRvcFxcXCIpKSxmKSxwYWRkaW5nTGVmdDpNYXRoLm1heChiLmhlbHBlcnMuZ2V0UFgoYi4kZWwuY3NzKFxcXCJwYWRkaW5nLWxlZnRcXFwiKSksaCksbWFyZ2luTGVmdDpNYXRoLm1heChiLmhlbHBlcnMuZ2V0UFgoYi4kZWwuY3NzKFxcXCJtYXJnaW4tbGVmdFxcXCIpKSxkKSxwYWRkaW5nUmlnaHQ6TWF0aC5tYXgoYi5oZWxwZXJzLmdldFBYKGIuJGVsLmNzcyhcXFwicGFkZGluZy1yaWdodFxcXCIpKSxpKSxtYXJnaW5SaWdodDpNYXRoLm1heChiLmhlbHBlcnMuZ2V0UFgoYi4kZWwuY3NzKFxcXCJtYXJnaW4tcmlnaHRcXFwiKSksZSksdGV4dEFsaWduOmt9KS50ZXh0KGIubGFuZ3VhZ2UudHJhbnNsYXRlKGIub3B0cy5wbGFjZWhvbGRlclRleHR8fGIuJG9lbC5hdHRyKFxcXCJwbGFjZWhvbGRlclxcXCIpfHxcXFwiXFxcIikpLGIuJHBsYWNlaG9sZGVyLmh0bWwoYi4kcGxhY2Vob2xkZXIudGV4dCgpLnJlcGxhY2UoL1xcXFxuL2csXFxcIjxicj5cXFwiKSl9ZnVuY3Rpb24gZCgpe2IuJHdwLnJlbW92ZUNsYXNzKFxcXCJzaG93LXBsYWNlaG9sZGVyXFxcIil9ZnVuY3Rpb24gZSgpe3JldHVybiFiLiR3cHx8Yi5ub2RlLmhhc0NsYXNzKGIuJHdwLmdldCgwKSxcXFwic2hvdy1wbGFjZWhvbGRlclxcXCIpfWZ1bmN0aW9uIGYoKXtyZXR1cm4hIWIuJHdwJiZ2b2lkKGIuY29yZS5pc0VtcHR5KCk/YygpOmQoKSl9ZnVuY3Rpb24gZygpe2IuJHBsYWNlaG9sZGVyPWEoJzxzcGFuIGNsYXNzPVxcXCJmci1wbGFjZWhvbGRlclxcXCI+PC9zcGFuPicpLGIuJHdwLmFwcGVuZChiLiRwbGFjZWhvbGRlcil9ZnVuY3Rpb24gaCgpe3JldHVybiEhYi4kd3AmJnZvaWQgYi5ldmVudHMub24oXFxcImluaXQgaW5wdXQga2V5ZG93biBrZXl1cCBjb250ZW50Q2hhbmdlZCBpbml0aWFsaXplZFxcXCIsZil9cmV0dXJue19pbml0Omgsc2hvdzpjLGhpZGU6ZCxyZWZyZXNoOmYsaXNWaXNpYmxlOmV9fSxhLkZFLk1PRFVMRVMuZWRpdD1mdW5jdGlvbihhKXtmdW5jdGlvbiBiKCl7aWYoYS5icm93c2VyLm1vemlsbGEpdHJ5e2EuZG9jLmV4ZWNDb21tYW5kKFxcXCJlbmFibGVPYmplY3RSZXNpemluZ1xcXCIsITEsXFxcImZhbHNlXFxcIiksYS5kb2MuZXhlY0NvbW1hbmQoXFxcImVuYWJsZUlubGluZVRhYmxlRWRpdGluZ1xcXCIsITEsXFxcImZhbHNlXFxcIil9Y2F0Y2goYil7fWlmKGEuYnJvd3Nlci5tc2llKXRyeXthLmRvYy5ib2R5LmFkZEV2ZW50TGlzdGVuZXIoXFxcIm1zY29udHJvbHNlbGVjdFxcXCIsZnVuY3Rpb24oYSl7cmV0dXJuIGEucHJldmVudERlZmF1bHQoKSwhMX0pfWNhdGNoKGIpe319ZnVuY3Rpb24gYygpe2EuJHdwPyhhLiRlbC5hdHRyKFxcXCJjb250ZW50ZWRpdGFibGVcXFwiLCEwKSxhLiRlbC5yZW1vdmVDbGFzcyhcXFwiZnItZGlzYWJsZWRcXFwiKS5hdHRyKFxcXCJhcmlhLWRpc2FibGVkXFxcIiwhMSksYS4kdGImJmEuJHRiLnJlbW92ZUNsYXNzKFxcXCJmci1kaXNhYmxlZFxcXCIpLmF0dHIoXFxcImFyaWEtZGlzYWJsZWRcXFwiLCExKSxiKCkpOmEuJGVsLmlzKFxcXCJhXFxcIikmJmEuJGVsLmF0dHIoXFxcImNvbnRlbnRlZGl0YWJsZVxcXCIsITApLGY9ITF9ZnVuY3Rpb24gZCgpe2EuJHdwPyhhLiRlbC5hdHRyKFxcXCJjb250ZW50ZWRpdGFibGVcXFwiLCExKSxhLiRlbC5hZGRDbGFzcyhcXFwiZnItZGlzYWJsZWRcXFwiKS5hdHRyKFxcXCJhcmlhLWRpc2FibGVkXFxcIiwhMCksYS4kdGImJmEuJHRiLmFkZENsYXNzKFxcXCJmci1kaXNhYmxlZFxcXCIpLmF0dHIoXFxcImFyaWEtZGlzYWJsZWRcXFwiLCEwKSk6YS4kZWwuaXMoXFxcImFcXFwiKSYmYS4kZWwuYXR0cihcXFwiY29udGVudGVkaXRhYmxlXFxcIiwhMSksZj0hMH1mdW5jdGlvbiBlKCl7cmV0dXJuIGZ9dmFyIGY9ITE7cmV0dXJue29uOmMsb2ZmOmQsZGlzYWJsZURlc2lnbjpiLGlzRGlzYWJsZWQ6ZX19LGEuZXh0ZW5kKGEuRkUuREVGQVVMVFMse2VkaXRvckNsYXNzOm51bGwsdHlwaW5nVGltZXI6NTAwLGlmcmFtZTohMSxyZXF1ZXN0V2l0aENPUlM6ITAscmVxdWVzdFdpdGhDcmVkZW50aWFsczohMSxyZXF1ZXN0SGVhZGVyczp7fSx1c2VDbGFzc2VzOiEwLHNwZWxsY2hlY2s6ITAsaWZyYW1lU3R5bGU6J2h0bWx7bWFyZ2luOjBweDtoZWlnaHQ6YXV0bzt9Ym9keXtoZWlnaHQ6YXV0bztwYWRkaW5nOjEwcHg7YmFja2dyb3VuZDp0cmFuc3BhcmVudDtjb2xvcjojMDAwMDAwO3Bvc2l0aW9uOnJlbGF0aXZlO3otaW5kZXg6IDI7LXdlYmtpdC11c2VyLXNlbGVjdDphdXRvO21hcmdpbjowcHg7b3ZlcmZsb3c6aGlkZGVuO21pbi1oZWlnaHQ6MjBweDt9Ym9keTphZnRlcntjb250ZW50OlxcXCJcXFwiO2Rpc3BsYXk6YmxvY2s7Y2xlYXI6Ym90aDt9JyxpZnJhbWVTdHlsZUZpbGVzOltdLGRpcmVjdGlvbjpcXFwiYXV0b1xcXCIsekluZGV4OjEsZGlzYWJsZVJpZ2h0Q2xpY2s6ITEsc2Nyb2xsYWJsZUNvbnRhaW5lcjpcXFwiYm9keVxcXCIsa2VlcEZvcm1hdE9uRGVsZXRlOiExLHRoZW1lOm51bGx9KSxhLkZFLk1PRFVMRVMuY29yZT1mdW5jdGlvbihiKXtmdW5jdGlvbiBjKGMpe2lmKGIub3B0cy5pZnJhbWUpe2IuJGhlYWQuZmluZChcXFwic3R5bGVbZGF0YS1mci1zdHlsZV0sIGxpbmtbZGF0YS1mci1zdHlsZV1cXFwiKS5yZW1vdmUoKSxiLiRoZWFkLmFwcGVuZCgnPHN0eWxlIGRhdGEtZnItc3R5bGU9XFxcInRydWVcXFwiPicrYytcXFwiPC9zdHlsZT5cXFwiKTtmb3IodmFyIGQ9MDtkPGIub3B0cy5pZnJhbWVTdHlsZUZpbGVzLmxlbmd0aDtkKyspe3ZhciBlPWEoJzxsaW5rIGRhdGEtZnItc3R5bGU9XFxcInRydWVcXFwiIHJlbD1cXFwic3R5bGVzaGVldFxcXCIgaHJlZj1cXFwiJytiLm9wdHMuaWZyYW1lU3R5bGVGaWxlc1tkXSsnXFxcIj4nKTtlLmdldCgwKS5hZGRFdmVudExpc3RlbmVyKFxcXCJsb2FkXFxcIixiLnNpemUuc3luY0lmcmFtZSksYi4kaGVhZC5hcHBlbmQoZSl9fX1mdW5jdGlvbiBkKCl7Yi5vcHRzLmlmcmFtZXx8Yi4kZWwuYWRkQ2xhc3MoXFxcImZyLWVsZW1lbnQgZnItdmlld1xcXCIpfWZ1bmN0aW9uIGUoKXtpZihiLiRib3guYWRkQ2xhc3MoXFxcImZyLWJveFxcXCIrKGIub3B0cy5lZGl0b3JDbGFzcz9cXFwiIFxcXCIrYi5vcHRzLmVkaXRvckNsYXNzOlxcXCJcXFwiKSksYi4kd3AuYWRkQ2xhc3MoXFxcImZyLXdyYXBwZXJcXFwiKSxkKCksYi5vcHRzLmlmcmFtZSl7Yi4kaWZyYW1lLmFkZENsYXNzKFxcXCJmci1pZnJhbWVcXFwiKSxiLiRlbC5hZGRDbGFzcyhcXFwiZnItdmlld1xcXCIpO2Zvcih2YXIgYT0wO2E8Yi5vX2RvYy5zdHlsZVNoZWV0cy5sZW5ndGg7YSsrKXt2YXIgYzt0cnl7Yz1iLm9fZG9jLnN0eWxlU2hlZXRzW2FdLmNzc1J1bGVzfWNhdGNoKGUpe31pZihjKWZvcih2YXIgZj0wLGc9Yy5sZW5ndGg7ZjxnO2YrKykhY1tmXS5zZWxlY3RvclRleHR8fDAhPT1jW2ZdLnNlbGVjdG9yVGV4dC5pbmRleE9mKFxcXCIuZnItdmlld1xcXCIpJiYwIT09Y1tmXS5zZWxlY3RvclRleHQuaW5kZXhPZihcXFwiLmZyLWVsZW1lbnRcXFwiKXx8Y1tmXS5zdHlsZS5jc3NUZXh0Lmxlbmd0aD4wJiYoMD09PWNbZl0uc2VsZWN0b3JUZXh0LmluZGV4T2YoXFxcIi5mci12aWV3XFxcIik/Yi5vcHRzLmlmcmFtZVN0eWxlKz1jW2ZdLnNlbGVjdG9yVGV4dC5yZXBsYWNlKC9cXFxcLmZyLXZpZXcvZyxcXFwiYm9keVxcXCIpK1xcXCJ7XFxcIitjW2ZdLnN0eWxlLmNzc1RleHQrXFxcIn1cXFwiOmIub3B0cy5pZnJhbWVTdHlsZSs9Y1tmXS5zZWxlY3RvclRleHQucmVwbGFjZSgvXFxcXC5mci1lbGVtZW50L2csXFxcImJvZHlcXFwiKStcXFwie1xcXCIrY1tmXS5zdHlsZS5jc3NUZXh0K1xcXCJ9XFxcIil9fVxcXCJhdXRvXFxcIiE9Yi5vcHRzLmRpcmVjdGlvbiYmYi4kYm94LnJlbW92ZUNsYXNzKFxcXCJmci1sdHIgZnItcnRsXFxcIikuYWRkQ2xhc3MoXFxcImZyLVxcXCIrYi5vcHRzLmRpcmVjdGlvbiksYi4kZWwuYXR0cihcXFwiZGlyXFxcIixiLm9wdHMuZGlyZWN0aW9uKSxiLiR3cC5hdHRyKFxcXCJkaXJcXFwiLGIub3B0cy5kaXJlY3Rpb24pLGIub3B0cy56SW5kZXg+MSYmYi4kYm94LmNzcyhcXFwiei1pbmRleFxcXCIsYi5vcHRzLnpJbmRleCksYi5vcHRzLnRoZW1lJiZiLiRib3guYWRkQ2xhc3MoYi5vcHRzLnRoZW1lK1xcXCItdGhlbWVcXFwiKX1mdW5jdGlvbiBmKCl7cmV0dXJuIGIubm9kZS5pc0VtcHR5KGIuZWwpfWZ1bmN0aW9uIGcoKXtiLmRyYWdfc3VwcG9ydD17ZmlsZXJlYWRlcjpcXFwidW5kZWZpbmVkXFxcIiE9dHlwZW9mIEZpbGVSZWFkZXIsZm9ybWRhdGE6ISFiLndpbi5Gb3JtRGF0YSxwcm9ncmVzczpcXFwidXBsb2FkXFxcImluIG5ldyBYTUxIdHRwUmVxdWVzdH19ZnVuY3Rpb24gaChhLGMpe3ZhciBkPW5ldyBYTUxIdHRwUmVxdWVzdDtkLm9wZW4oYyxhLCEwKSxiLm9wdHMucmVxdWVzdFdpdGhDcmVkZW50aWFscyYmKGQud2l0aENyZWRlbnRpYWxzPSEwKTtmb3IodmFyIGUgaW4gYi5vcHRzLnJlcXVlc3RIZWFkZXJzKWIub3B0cy5yZXF1ZXN0SGVhZGVycy5oYXNPd25Qcm9wZXJ0eShlKSYmZC5zZXRSZXF1ZXN0SGVhZGVyKGUsYi5vcHRzLnJlcXVlc3RIZWFkZXJzW2VdKTtyZXR1cm4gZH1mdW5jdGlvbiBpKGEpe1xcXCJURVhUQVJFQVxcXCI9PWIuJG9lbC5nZXQoMCkudGFnTmFtZSYmYi4kb2VsLnZhbChhKSxiLiR3cCYmKFxcXCJURVhUQVJFQVxcXCI9PWIuJG9lbC5nZXQoMCkudGFnTmFtZT8oYi4kZWwuaHRtbChcXFwiXFxcIiksYi4kd3AuaHRtbChcXFwiXFxcIiksYi4kYm94LnJlcGxhY2VXaXRoKGIuJG9lbCksYi4kb2VsLnNob3coKSk6KGIuJHdwLnJlcGxhY2VXaXRoKGEpLGIuJGVsLmh0bWwoXFxcIlxcXCIpLGIuJGJveC5yZW1vdmVDbGFzcyhcXFwiZnItdmlldyBmci1sdHIgZnItYm94IFxcXCIrKGIub3B0cy5lZGl0b3JDbGFzc3x8XFxcIlxcXCIpKSxiLm9wdHMudGhlbWUmJmIuJGJveC5hZGRDbGFzcyhiLm9wdHMudGhlbWUrXFxcIi10aGVtZVxcXCIpKSksdGhpcy4kd3A9bnVsbCx0aGlzLiRlbD1udWxsLHRoaXMuZWw9bnVsbCx0aGlzLiRib3g9bnVsbH1mdW5jdGlvbiBqKCl7cmV0dXJuIGIuYnJvd3Nlci5tb3ppbGxhJiZiLmhlbHBlcnMuaXNNb2JpbGUoKT9iLnNlbGVjdGlvbi5pbkVkaXRvcigpOmIubm9kZS5oYXNGb2N1cyhiLmVsKXx8Yi4kZWwuZmluZChcXFwiKjpmb2N1c1xcXCIpLmxlbmd0aD4wfWZ1bmN0aW9uIGsoYSl7aWYoIWEpcmV0dXJuITE7dmFyIGM9YS5kYXRhKFxcXCJpbnN0YW5jZVxcXCIpO3JldHVybiEhYyYmYy5pZD09Yi5pZH1mdW5jdGlvbiBsKCl7aWYoYS5GRS5JTlNUQU5DRVMucHVzaChiKSxnKCksYi4kd3Ape2UoKSxiLmh0bWwuc2V0KGIuX29yaWdpbmFsX2h0bWwpLGIuJGVsLmF0dHIoXFxcInNwZWxsY2hlY2tcXFwiLGIub3B0cy5zcGVsbGNoZWNrKSxiLmhlbHBlcnMuaXNNb2JpbGUoKSYmKGIuJGVsLmF0dHIoXFxcImF1dG9jb21wbGV0ZVxcXCIsYi5vcHRzLnNwZWxsY2hlY2s/XFxcIm9uXFxcIjpcXFwib2ZmXFxcIiksYi4kZWwuYXR0cihcXFwiYXV0b2NvcnJlY3RcXFwiLGIub3B0cy5zcGVsbGNoZWNrP1xcXCJvblxcXCI6XFxcIm9mZlxcXCIpLGIuJGVsLmF0dHIoXFxcImF1dG9jYXBpdGFsaXplXFxcIixiLm9wdHMuc3BlbGxjaGVjaz9cXFwib25cXFwiOlxcXCJvZmZcXFwiKSksYi5vcHRzLmRpc2FibGVSaWdodENsaWNrJiZiLmV2ZW50cy4kb24oYi4kZWwsXFxcImNvbnRleHRtZW51XFxcIixmdW5jdGlvbihhKXtpZigyPT1hLmJ1dHRvbilyZXR1cm4hMX0pO3RyeXtiLmRvYy5leGVjQ29tbWFuZChcXFwic3R5bGVXaXRoQ1NTXFxcIiwhMSwhMSl9Y2F0Y2goYyl7fX1iLmV2ZW50cy5vbihcXFwiZHJvcFxcXCIsZnVuY3Rpb24oYSl7YS5wcmV2ZW50RGVmYXVsdCgpLGEuc3RvcFByb3BhZ2F0aW9uKCl9KSxcXFwiVEVYVEFSRUFcXFwiPT1iLiRvZWwuZ2V0KDApLnRhZ05hbWUmJihiLmV2ZW50cy5vbihcXFwiY29udGVudENoYW5nZWRcXFwiLGZ1bmN0aW9uKCl7Yi4kb2VsLnZhbChiLmh0bWwuZ2V0KCkpfSksYi5ldmVudHMub24oXFxcImZvcm0uc3VibWl0XFxcIixmdW5jdGlvbigpe2IuJG9lbC52YWwoYi5odG1sLmdldCgpKX0pLGIuZXZlbnRzLm9uKFxcXCJmb3JtLnJlc2V0XFxcIixmdW5jdGlvbigpe2IuaHRtbC5zZXQoYi5fb3JpZ2luYWxfaHRtbCl9KSxiLiRvZWwudmFsKGIuaHRtbC5nZXQoKSkpLGIuaGVscGVycy5pc0lPUygpJiZiLmV2ZW50cy4kb24oYi4kZG9jLFxcXCJzZWxlY3Rpb25jaGFuZ2VcXFwiLGZ1bmN0aW9uKCl7Yi4kZG9jLmdldCgwKS5oYXNGb2N1cygpfHxiLiR3aW4uZ2V0KDApLmZvY3VzKCl9KSxiLmV2ZW50cy50cmlnZ2VyKFxcXCJpbml0XFxcIil9cmV0dXJue19pbml0OmwsZGVzdHJveTppLGlzRW1wdHk6ZixnZXRYSFI6aCxpbmplY3RTdHlsZTpjLGhhc0ZvY3VzOmosc2FtZUluc3RhbmNlOmt9fSxhLkZFLk1PRFVMRVMuY3Vyc29yTGlzdHM9ZnVuY3Rpb24oYil7ZnVuY3Rpb24gYyhhKXtmb3IodmFyIGI9YTtcXFwiTElcXFwiIT1iLnRhZ05hbWU7KWI9Yi5wYXJlbnROb2RlO3JldHVybiBifWZ1bmN0aW9uIGQoYSl7Zm9yKHZhciBjPWE7IWIubm9kZS5pc0xpc3QoYyk7KWM9Yy5wYXJlbnROb2RlO3JldHVybiBjfWZ1bmN0aW9uIGUoZSl7dmFyIGYsZz1jKGUpLGg9Zy5uZXh0U2libGluZyxpPWcucHJldmlvdXNTaWJsaW5nLGo9Yi5odG1sLmRlZmF1bHRUYWcoKTtpZihiLm5vZGUuaXNFbXB0eShnLCEwKSYmaCl7Zm9yKHZhciBrPVxcXCJcXFwiLGw9XFxcIlxcXCIsbT1lLnBhcmVudE5vZGU7IWIubm9kZS5pc0xpc3QobSkmJm0ucGFyZW50Tm9kZSYmXFxcIkxJXFxcIiE9PW0ucGFyZW50Tm9kZS50YWdOYW1lOylrPWIubm9kZS5vcGVuVGFnU3RyaW5nKG0pK2ssbCs9Yi5ub2RlLmNsb3NlVGFnU3RyaW5nKG0pLG09bS5wYXJlbnROb2RlO2s9Yi5ub2RlLm9wZW5UYWdTdHJpbmcobSkrayxsKz1iLm5vZGUuY2xvc2VUYWdTdHJpbmcobSk7dmFyIG49XFxcIlxcXCI7Zm9yKG49bS5wYXJlbnROb2RlJiZcXFwiTElcXFwiPT1tLnBhcmVudE5vZGUudGFnTmFtZT9sK1xcXCI8bGk+XFxcIithLkZFLk1BUktFUlMrXFxcIjxicj5cXFwiK2s6aj9sK1xcXCI8XFxcIitqK1xcXCI+XFxcIithLkZFLk1BUktFUlMrXFxcIjxicj48L1xcXCIraitcXFwiPlxcXCIrazpsK2EuRkUuTUFSS0VSUytcXFwiPGJyPlxcXCIrayxhKGcpLmh0bWwoJzxzcGFuIGlkPVxcXCJmci1icmVha1xcXCI+PC9zcGFuPicpO1tcXFwiVUxcXFwiLFxcXCJPTFxcXCJdLmluZGV4T2YobS50YWdOYW1lKTwwfHxtLnBhcmVudE5vZGUmJlxcXCJMSVxcXCI9PT1tLnBhcmVudE5vZGUudGFnTmFtZTspbT1tLnBhcmVudE5vZGU7dmFyIG89Yi5ub2RlLm9wZW5UYWdTdHJpbmcobSkrYShtKS5odG1sKCkrYi5ub2RlLmNsb3NlVGFnU3RyaW5nKG0pO289by5yZXBsYWNlKC88c3BhbiBpZD1cXFwiZnItYnJlYWtcXFwiPjxcXFxcL3NwYW4+L2csbiksYShtKS5yZXBsYWNlV2l0aChvKSxiLiRlbC5maW5kKFxcXCJsaTplbXB0eVxcXCIpLnJlbW92ZSgpfWVsc2UgaSYmaHx8IWIubm9kZS5pc0VtcHR5KGcsITApPyhhKGcpLmJlZm9yZShcXFwiPGxpPjxicj48L2xpPlxcXCIpLGEoZSkucmVtb3ZlKCkpOmk/KGY9ZChnKSxmLnBhcmVudE5vZGUmJlxcXCJMSVxcXCI9PWYucGFyZW50Tm9kZS50YWdOYW1lP2EoZi5wYXJlbnROb2RlKS5hZnRlcihcXFwiPGxpPlxcXCIrYS5GRS5NQVJLRVJTK1xcXCI8YnI+PC9saT5cXFwiKTpqP2EoZikuYWZ0ZXIoXFxcIjxcXFwiK2orXFxcIj5cXFwiK2EuRkUuTUFSS0VSUytcXFwiPGJyPjwvXFxcIitqK1xcXCI+XFxcIik6YShmKS5hZnRlcihhLkZFLk1BUktFUlMrXFxcIjxicj5cXFwiKSxhKGcpLnJlbW92ZSgpKTooZj1kKGcpLGYucGFyZW50Tm9kZSYmXFxcIkxJXFxcIj09Zi5wYXJlbnROb2RlLnRhZ05hbWU/aD9hKGYucGFyZW50Tm9kZSkuYmVmb3JlKFxcXCI8bGk+XFxcIithLkZFLk1BUktFUlMrXFxcIjxicj48L2xpPlxcXCIpOmEoZi5wYXJlbnROb2RlKS5hZnRlcihcXFwiPGxpPlxcXCIrYS5GRS5NQVJLRVJTK1xcXCI8YnI+PC9saT5cXFwiKTpqP2EoZikuYmVmb3JlKFxcXCI8XFxcIitqK1xcXCI+XFxcIithLkZFLk1BUktFUlMrXFxcIjxicj48L1xcXCIraitcXFwiPlxcXCIpOmEoZikuYmVmb3JlKGEuRkUuTUFSS0VSUytcXFwiPGJyPlxcXCIpLGEoZykucmVtb3ZlKCkpfWZ1bmN0aW9uIGYoZCl7Zm9yKHZhciBlPWMoZCksZj1cXFwiXFxcIixnPWQsaD1cXFwiXFxcIixpPVxcXCJcXFwiO2chPWU7KXtnPWcucGFyZW50Tm9kZTt2YXIgaj1cXFwiQVxcXCI9PWcudGFnTmFtZSYmYi5jdXJzb3IuaXNBdEVuZChkLGcpP1xcXCJmci10by1yZW1vdmVcXFwiOlxcXCJcXFwiO2g9Yi5ub2RlLm9wZW5UYWdTdHJpbmcoYShnKS5jbG9uZSgpLmFkZENsYXNzKGopLmdldCgwKSkraCxpPWIubm9kZS5jbG9zZVRhZ1N0cmluZyhnKStpfWY9aStmK2grYS5GRS5NQVJLRVJTLGEoZCkucmVwbGFjZVdpdGgoJzxzcGFuIGlkPVxcXCJmci1icmVha1xcXCI+PC9zcGFuPicpO3ZhciBrPWIubm9kZS5vcGVuVGFnU3RyaW5nKGUpK2EoZSkuaHRtbCgpK2Iubm9kZS5jbG9zZVRhZ1N0cmluZyhlKTtrPWsucmVwbGFjZSgvPHNwYW4gaWQ9XFxcImZyLWJyZWFrXFxcIj48XFxcXC9zcGFuPi9nLGYpLGEoZSkucmVwbGFjZVdpdGgoayl9ZnVuY3Rpb24gZyhkKXtmb3IodmFyIGU9YyhkKSxmPWEuRkUuTUFSS0VSUyxnPVxcXCJcXFwiLGg9ZCxpPSExO2ghPWU7KXtoPWgucGFyZW50Tm9kZTt2YXIgaj1cXFwiQVxcXCI9PWgudGFnTmFtZSYmYi5jdXJzb3IuaXNBdEVuZChkLGgpP1xcXCJmci10by1yZW1vdmVcXFwiOlxcXCJcXFwiO2l8fGg9PWV8fGIubm9kZS5pc0Jsb2NrKGgpfHwoaT0hMCxnKz1hLkZFLklOVklTSUJMRV9TUEFDRSksZz1iLm5vZGUub3BlblRhZ1N0cmluZyhhKGgpLmNsb25lKCkuYWRkQ2xhc3MoaikuZ2V0KDApKStnLGYrPWIubm9kZS5jbG9zZVRhZ1N0cmluZyhoKX12YXIgaz1nK2Y7YShkKS5yZW1vdmUoKSxhKGUpLmFmdGVyKGspfWZ1bmN0aW9uIGgoZSl7dmFyIGY9YyhlKSxnPWYucHJldmlvdXNTaWJsaW5nO2lmKGcpe2c9YShnKS5maW5kKGIuaHRtbC5ibG9ja1RhZ3NRdWVyeSgpKS5nZXQoLTEpfHxnLGEoZSkucmVwbGFjZVdpdGgoYS5GRS5NQVJLRVJTKTt2YXIgaD1iLm5vZGUuY29udGVudHMoZyk7aC5sZW5ndGgmJlxcXCJCUlxcXCI9PWhbaC5sZW5ndGgtMV0udGFnTmFtZSYmYShoW2gubGVuZ3RoLTFdKS5yZW1vdmUoKSxhKGYpLmZpbmQoYi5odG1sLmJsb2NrVGFnc1F1ZXJ5KCkpLm5vdChcXFwib2wsIHVsLCB0YWJsZVxcXCIpLmVhY2goZnVuY3Rpb24oKXt0aGlzLnBhcmVudE5vZGU9PWYmJmEodGhpcykucmVwbGFjZVdpdGgoYSh0aGlzKS5odG1sKCkrKGIubm9kZS5pc0VtcHR5KHRoaXMpP1xcXCJcXFwiOlxcXCI8YnI+XFxcIikpfSk7Zm9yKHZhciBpLGo9Yi5ub2RlLmNvbnRlbnRzKGYpWzBdO2omJiFiLm5vZGUuaXNMaXN0KGopOylpPWoubmV4dFNpYmxpbmcsYShnKS5hcHBlbmQoaiksaj1pO2ZvcihnPWYucHJldmlvdXNTaWJsaW5nO2o7KWk9ai5uZXh0U2libGluZyxhKGcpLmFwcGVuZChqKSxqPWk7YShmKS5yZW1vdmUoKX1lbHNle3ZhciBrPWQoZik7aWYoYShlKS5yZXBsYWNlV2l0aChhLkZFLk1BUktFUlMpLGsucGFyZW50Tm9kZSYmXFxcIkxJXFxcIj09ay5wYXJlbnROb2RlLnRhZ05hbWUpe3ZhciBsPWsucHJldmlvdXNTaWJsaW5nO2Iubm9kZS5pc0Jsb2NrKGwpPyhhKGYpLmZpbmQoYi5odG1sLmJsb2NrVGFnc1F1ZXJ5KCkpLm5vdChcXFwib2wsIHVsLCB0YWJsZVxcXCIpLmVhY2goZnVuY3Rpb24oKXt0aGlzLnBhcmVudE5vZGU9PWYmJmEodGhpcykucmVwbGFjZVdpdGgoYSh0aGlzKS5odG1sKCkrKGIubm9kZS5pc0VtcHR5KHRoaXMpP1xcXCJcXFwiOlxcXCI8YnI+XFxcIikpfSksYShsKS5hcHBlbmQoYShmKS5odG1sKCkpKTphKGspLmJlZm9yZShhKGYpLmh0bWwoKSl9ZWxzZXt2YXIgbT1iLmh0bWwuZGVmYXVsdFRhZygpO20mJjA9PT1hKGYpLmZpbmQoYi5odG1sLmJsb2NrVGFnc1F1ZXJ5KCkpLmxlbmd0aD9hKGspLmJlZm9yZShcXFwiPFxcXCIrbStcXFwiPlxcXCIrYShmKS5odG1sKCkrXFxcIjwvXFxcIittK1xcXCI+XFxcIik6YShrKS5iZWZvcmUoYShmKS5odG1sKCkpfWEoZikucmVtb3ZlKCksMD09PWEoaykuZmluZChcXFwibGlcXFwiKS5sZW5ndGgmJmEoaykucmVtb3ZlKCl9fWZ1bmN0aW9uIGkoZCl7dmFyIGUsZj1jKGQpLGc9Zi5uZXh0U2libGluZztpZihnKXtlPWIubm9kZS5jb250ZW50cyhnKSxlLmxlbmd0aCYmXFxcIkJSXFxcIj09ZVswXS50YWdOYW1lJiZhKGVbMF0pLnJlbW92ZSgpLGEoZykuZmluZChiLmh0bWwuYmxvY2tUYWdzUXVlcnkoKSkubm90KFxcXCJvbCwgdWwsIHRhYmxlXFxcIikuZWFjaChmdW5jdGlvbigpe3RoaXMucGFyZW50Tm9kZT09ZyYmYSh0aGlzKS5yZXBsYWNlV2l0aChhKHRoaXMpLmh0bWwoKSsoYi5ub2RlLmlzRW1wdHkodGhpcyk/XFxcIlxcXCI6XFxcIjxicj5cXFwiKSl9KTtmb3IodmFyIGgsaT1kLGo9Yi5ub2RlLmNvbnRlbnRzKGcpWzBdO2omJiFiLm5vZGUuaXNMaXN0KGopOyloPWoubmV4dFNpYmxpbmcsYShpKS5hZnRlcihqKSxpPWosaj1oO2Zvcig7ajspaD1qLm5leHRTaWJsaW5nLGEoZikuYXBwZW5kKGopLGo9aDthKGQpLnJlcGxhY2VXaXRoKGEuRkUuTUFSS0VSUyksYShnKS5yZW1vdmUoKX1lbHNle2Zvcih2YXIgaz1mOyFrLm5leHRTaWJsaW5nJiZrIT1iLmVsOylrPWsucGFyZW50Tm9kZTtpZihrPT1iLmVsKXJldHVybiExO2lmKGs9ay5uZXh0U2libGluZyxiLm5vZGUuaXNCbG9jayhrKSlhLkZFLk5PX0RFTEVURV9UQUdTLmluZGV4T2Yoay50YWdOYW1lKTwwJiYoYShkKS5yZXBsYWNlV2l0aChhLkZFLk1BUktFUlMpLGU9Yi5ub2RlLmNvbnRlbnRzKGYpLGUubGVuZ3RoJiZcXFwiQlJcXFwiPT1lW2UubGVuZ3RoLTFdLnRhZ05hbWUmJmEoZVtlLmxlbmd0aC0xXSkucmVtb3ZlKCksYShmKS5hcHBlbmQoYShrKS5odG1sKCkpLGEoaykucmVtb3ZlKCkpO2Vsc2UgZm9yKGU9Yi5ub2RlLmNvbnRlbnRzKGYpLGUubGVuZ3RoJiZcXFwiQlJcXFwiPT1lW2UubGVuZ3RoLTFdLnRhZ05hbWUmJmEoZVtlLmxlbmd0aC0xXSkucmVtb3ZlKCksYShkKS5yZXBsYWNlV2l0aChhLkZFLk1BUktFUlMpO2smJiFiLm5vZGUuaXNCbG9jayhrKSYmXFxcIkJSXFxcIiE9ay50YWdOYW1lOylhKGYpLmFwcGVuZChhKGspKSxrPWsubmV4dFNpYmxpbmd9fXJldHVybntfc3RhcnRFbnRlcjplLF9taWRkbGVFbnRlcjpmLF9lbmRFbnRlcjpnLF9iYWNrc3BhY2U6aCxfZGVsOml9fSxhLkZFLk5PX0RFTEVURV9UQUdTPVtcXFwiVEhcXFwiLFxcXCJURFxcXCIsXFxcIlRSXFxcIixcXFwiVEFCTEVcXFwiLFxcXCJGT1JNXFxcIl0sYS5GRS5TSU1QTEVfRU5URVJfVEFHUz1bXFxcIlRIXFxcIixcXFwiVERcXFwiLFxcXCJMSVxcXCIsXFxcIkRMXFxcIixcXFwiRFRcXFwiLFxcXCJGT1JNXFxcIl0sYS5GRS5NT0RVTEVTLmN1cnNvcj1mdW5jdGlvbihiKXtmdW5jdGlvbiBjKGEpe3JldHVybiEhYSYmKCEhYi5ub2RlLmlzQmxvY2soYSl8fChhLm5leHRTaWJsaW5nJiZhLm5leHRTaWJsaW5nLm5vZGVUeXBlPT1Ob2RlLlRFWFRfTk9ERSYmMD09YS5uZXh0U2libGluZy50ZXh0Q29udGVudC5yZXBsYWNlKC9cXFxcdTIwMGIvZyxcXFwiXFxcIikubGVuZ3RoP2MoYS5uZXh0U2libGluZyk6IWEubmV4dFNpYmxpbmcmJmMoYS5wYXJlbnROb2RlKSkpfWZ1bmN0aW9uIGQoYSl7cmV0dXJuISFhJiYoISFiLm5vZGUuaXNCbG9jayhhKXx8KGEucHJldmlvdXNTaWJsaW5nJiZhLnByZXZpb3VzU2libGluZy5ub2RlVHlwZT09Tm9kZS5URVhUX05PREUmJjA9PWEucHJldmlvdXNTaWJsaW5nLnRleHRDb250ZW50LnJlcGxhY2UoL1xcXFx1MjAwYi9nLFxcXCJcXFwiKS5sZW5ndGg/ZChhLnByZXZpb3VzU2libGluZyk6IWEucHJldmlvdXNTaWJsaW5nJiZkKGEucGFyZW50Tm9kZSkpKX1mdW5jdGlvbiBlKGEsYyl7cmV0dXJuISFhJiYoYSE9Yi4kd3AuZ2V0KDApJiYoYS5wcmV2aW91c1NpYmxpbmcmJmEucHJldmlvdXNTaWJsaW5nLm5vZGVUeXBlPT1Ob2RlLlRFWFRfTk9ERSYmMD09YS5wcmV2aW91c1NpYmxpbmcudGV4dENvbnRlbnQucmVwbGFjZSgvXFxcXHUyMDBiL2csXFxcIlxcXCIpLmxlbmd0aD9lKGEucHJldmlvdXNTaWJsaW5nLGMpOiFhLnByZXZpb3VzU2libGluZyYmKGEucGFyZW50Tm9kZT09Y3x8ZShhLnBhcmVudE5vZGUsYykpKSl9ZnVuY3Rpb24gZihhLGMpe3JldHVybiEhYSYmKGEhPWIuJHdwLmdldCgwKSYmKGEubmV4dFNpYmxpbmcmJmEubmV4dFNpYmxpbmcubm9kZVR5cGU9PU5vZGUuVEVYVF9OT0RFJiYwPT1hLm5leHRTaWJsaW5nLnRleHRDb250ZW50LnJlcGxhY2UoL1xcXFx1MjAwYi9nLFxcXCJcXFwiKS5sZW5ndGg/ZihhLm5leHRTaWJsaW5nLGMpOiFhLm5leHRTaWJsaW5nJiYoYS5wYXJlbnROb2RlPT1jfHxmKGEucGFyZW50Tm9kZSxjKSkpKX1mdW5jdGlvbiBnKGMpe3JldHVybiBhKGMpLnBhcmVudHNVbnRpbChiLiRlbCxcXFwiTElcXFwiKS5sZW5ndGg+MCYmMD09PWEoYykucGFyZW50c1VudGlsKFxcXCJMSVxcXCIsXFxcIlRBQkxFXFxcIikubGVuZ3RofWZ1bmN0aW9uIGgoYyl7dmFyIGQ9YShjKS5wYXJlbnRzVW50aWwoYi4kZWwsXFxcIkJMT0NLUVVPVEVcXFwiKS5sZW5ndGg+MCxlPWIubm9kZS5kZWVwZXN0UGFyZW50KGMsW10sIWQpO2lmKGUmJlxcXCJCTE9DS1FVT1RFXFxcIj09ZS50YWdOYW1lKXt2YXIgZj1iLm5vZGUuZGVlcGVzdFBhcmVudChjLFthKGMpLnBhcmVudHNVbnRpbChiLiRlbCxcXFwiQkxPQ0tRVU9URVxcXCIpLmdldCgwKV0pO2YmJmYucHJldmlvdXNTaWJsaW5nJiYoZT1mKX1pZihudWxsIT09ZSl7dmFyIGcsaD1lLnByZXZpb3VzU2libGluZztpZihiLm5vZGUuaXNCbG9jayhlKSYmYi5ub2RlLmlzRWRpdGFibGUoZSkmJmgmJmEuRkUuTk9fREVMRVRFX1RBR1MuaW5kZXhPZihoLnRhZ05hbWUpPDApaWYoYi5ub2RlLmlzRGVsZXRhYmxlKGgpKWEoaCkucmVtb3ZlKCksYShjKS5yZXBsYWNlV2l0aChhLkZFLk1BUktFUlMpO2Vsc2UgaWYoYi5ub2RlLmlzRWRpdGFibGUoaCkpaWYoYi5ub2RlLmlzQmxvY2soaCkpaWYoYi5ub2RlLmlzRW1wdHkoaCkmJiFiLm5vZGUuaXNMaXN0KGgpKWEoaCkucmVtb3ZlKCk7ZWxzZXtpZihiLm5vZGUuaXNMaXN0KGgpJiYoaD1hKGgpLmZpbmQoXFxcImxpOmxhc3RcXFwiKS5nZXQoMCkpLGc9Yi5ub2RlLmNvbnRlbnRzKGgpLGcubGVuZ3RoJiZcXFwiQlJcXFwiPT1nW2cubGVuZ3RoLTFdLnRhZ05hbWUmJmEoZ1tnLmxlbmd0aC0xXSkucmVtb3ZlKCksXFxcIkJMT0NLUVVPVEVcXFwiPT1oLnRhZ05hbWUmJlxcXCJCTE9DS1FVT1RFXFxcIiE9ZS50YWdOYW1lKWZvcihnPWIubm9kZS5jb250ZW50cyhoKTtnLmxlbmd0aCYmYi5ub2RlLmlzQmxvY2soZ1tnLmxlbmd0aC0xXSk7KWg9Z1tnLmxlbmd0aC0xXSxnPWIubm9kZS5jb250ZW50cyhoKTtlbHNlIGlmKFxcXCJCTE9DS1FVT1RFXFxcIiE9aC50YWdOYW1lJiZcXFwiQkxPQ0tRVU9URVxcXCI9PWUudGFnTmFtZSlmb3IoZz1iLm5vZGUuY29udGVudHMoZSk7Zy5sZW5ndGgmJmIubm9kZS5pc0Jsb2NrKGdbMF0pOyllPWdbMF0sZz1iLm5vZGUuY29udGVudHMoZSk7YShjKS5yZXBsYWNlV2l0aChhLkZFLk1BUktFUlMpLGEoaCkuYXBwZW5kKGIubm9kZS5pc0VtcHR5KGUpP2EuRkUuTUFSS0VSUzplLmlubmVySFRNTCksYShlKS5yZW1vdmUoKX1lbHNlIGEoYykucmVwbGFjZVdpdGgoYS5GRS5NQVJLRVJTKSxcXFwiQkxPQ0tRVU9URVxcXCI9PWUudGFnTmFtZSYmaC5ub2RlVHlwZT09Tm9kZS5FTEVNRU5UX05PREU/YShoKS5yZW1vdmUoKTooYShoKS5hZnRlcihiLm5vZGUuaXNFbXB0eShlKT9cXFwiXFxcIjphKGUpLmh0bWwoKSksYShlKS5yZW1vdmUoKSxcXFwiQlJcXFwiPT1oLnRhZ05hbWUmJmEoaCkucmVtb3ZlKCkpfX1mdW5jdGlvbiBpKGMpe2Zvcih2YXIgZD1jOyFkLnByZXZpb3VzU2libGluZzspaWYoZD1kLnBhcmVudE5vZGUsYi5ub2RlLmlzRWxlbWVudChkKSlyZXR1cm4hMTtkPWQucHJldmlvdXNTaWJsaW5nO3ZhciBlO2lmKCFiLm5vZGUuaXNCbG9jayhkKSYmYi5ub2RlLmlzRWRpdGFibGUoZCkpe2ZvcihlPWIubm9kZS5jb250ZW50cyhkKTtkLm5vZGVUeXBlIT1Ob2RlLlRFWFRfTk9ERSYmIWIubm9kZS5pc0RlbGV0YWJsZShkKSYmZS5sZW5ndGgmJmIubm9kZS5pc0VkaXRhYmxlKGQpOylkPWVbZS5sZW5ndGgtMV0sZT1iLm5vZGUuY29udGVudHMoZCk7aWYoZC5ub2RlVHlwZT09Tm9kZS5URVhUX05PREUpe2lmKGIuaGVscGVycy5pc0lPUygpKXJldHVybiEwO3ZhciBmPWQudGV4dENvbnRlbnQsZz1mLmxlbmd0aC0xO2lmKGIub3B0cy50YWJTcGFjZXMmJmYubGVuZ3RoPj1iLm9wdHMudGFiU3BhY2VzKXt2YXIgaD1mLnN1YnN0cihmLmxlbmd0aC1iLm9wdHMudGFiU3BhY2VzLGYubGVuZ3RoLTEpOzA9PWgucmVwbGFjZSgvIC9nLFxcXCJcXFwiKS5yZXBsYWNlKG5ldyBSZWdFeHAoYS5GRS5VTklDT0RFX05CU1AsXFxcImdcXFwiKSxcXFwiXFxcIikubGVuZ3RoJiYoZz1mLmxlbmd0aC1iLm9wdHMudGFiU3BhY2VzKX1kLnRleHRDb250ZW50PWYuc3Vic3RyaW5nKDAsZyksZC50ZXh0Q29udGVudC5sZW5ndGgmJjU1MzU3PT1kLnRleHRDb250ZW50LmNoYXJDb2RlQXQoZC50ZXh0Q29udGVudC5sZW5ndGgtMSkmJihkLnRleHRDb250ZW50PWQudGV4dENvbnRlbnQuc3Vic3RyKDAsZC50ZXh0Q29udGVudC5sZW5ndGgtMSkpO3ZhciBpPWYubGVuZ3RoIT1kLnRleHRDb250ZW50Lmxlbmd0aDswPT1kLnRleHRDb250ZW50Lmxlbmd0aD9pJiZiLm9wdHMua2VlcEZvcm1hdE9uRGVsZXRlP2EoZCkuYWZ0ZXIoYS5GRS5JTlZJU0lCTEVfU1BBQ0UrYS5GRS5NQVJLRVJTKToyIT1kLnBhcmVudE5vZGUuY2hpbGROb2Rlcy5sZW5ndGh8fGQucGFyZW50Tm9kZSE9Yy5wYXJlbnROb2RlfHxiLm5vZGUuaXNCbG9jayhkLnBhcmVudE5vZGUpfHxiLm5vZGUuaXNFbGVtZW50KGQucGFyZW50Tm9kZSk/KGEoZCkuYWZ0ZXIoYS5GRS5NQVJLRVJTKSxiLm5vZGUuaXNFbGVtZW50KGQucGFyZW50Tm9kZSkmJiFjLm5leHRTaWJsaW5nJiZkLnByZXZpb3VzU2libGluZyYmXFxcIkJSXFxcIj09ZC5wcmV2aW91c1NpYmxpbmcudGFnTmFtZSYmYShjKS5hZnRlcihcXFwiPGJyPlxcXCIpLGQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChkKSk6KGEoZC5wYXJlbnROb2RlKS5hZnRlcihhLkZFLk1BUktFUlMpLGEoZC5wYXJlbnROb2RlKS5yZW1vdmUoKSk6YShkKS5hZnRlcihhLkZFLk1BUktFUlMpfWVsc2UgYi5ub2RlLmlzRGVsZXRhYmxlKGQpPyhhKGQpLmFmdGVyKGEuRkUuTUFSS0VSUyksYShkKS5yZW1vdmUoKSk6Yi5ldmVudHMudHJpZ2dlcihcXFwibm9kZS5yZW1vdmVcXFwiLFthKGQpXSkhPT0hMSYmKGEoZCkuYWZ0ZXIoYS5GRS5NQVJLRVJTKSxhKGQpLnJlbW92ZSgpKX1lbHNlIGlmKGEuRkUuTk9fREVMRVRFX1RBR1MuaW5kZXhPZihkLnRhZ05hbWUpPDAmJihiLm5vZGUuaXNFZGl0YWJsZShkKXx8Yi5ub2RlLmlzRGVsZXRhYmxlKGQpKSlpZihiLm5vZGUuaXNEZWxldGFibGUoZCkpYShjKS5yZXBsYWNlV2l0aChhLkZFLk1BUktFUlMpLGEoZCkucmVtb3ZlKCk7ZWxzZSBpZihiLm5vZGUuaXNFbXB0eShkKSYmIWIubm9kZS5pc0xpc3QoZCkpYShkKS5yZW1vdmUoKSxhKGMpLnJlcGxhY2VXaXRoKGEuRkUuTUFSS0VSUyk7ZWxzZXtmb3IoYi5ub2RlLmlzTGlzdChkKSYmKGQ9YShkKS5maW5kKFxcXCJsaTpsYXN0XFxcIikuZ2V0KDApKSxlPWIubm9kZS5jb250ZW50cyhkKSxlJiZcXFwiQlJcXFwiPT1lW2UubGVuZ3RoLTFdLnRhZ05hbWUmJmEoZVtlLmxlbmd0aC0xXSkucmVtb3ZlKCksZT1iLm5vZGUuY29udGVudHMoZCk7ZSYmYi5ub2RlLmlzQmxvY2soZVtlLmxlbmd0aC0xXSk7KWQ9ZVtlLmxlbmd0aC0xXSxlPWIubm9kZS5jb250ZW50cyhkKTthKGQpLmFwcGVuZChhLkZFLk1BUktFUlMpO2Zvcih2YXIgaj1jOyFqLnByZXZpb3VzU2libGluZzspaj1qLnBhcmVudE5vZGU7Zm9yKDtqJiZcXFwiQlJcXFwiIT09ai50YWdOYW1lJiYhYi5ub2RlLmlzQmxvY2soaik7KXt2YXIgaz1qO2o9ai5uZXh0U2libGluZyxhKGQpLmFwcGVuZChrKX1qJiZcXFwiQlJcXFwiPT1qLnRhZ05hbWUmJmEoaikucmVtb3ZlKCksYShjKS5yZW1vdmUoKX1lbHNlIGMubmV4dFNpYmxpbmcmJlxcXCJCUlxcXCI9PWMubmV4dFNpYmxpbmcudGFnTmFtZSYmYShjLm5leHRTaWJsaW5nKS5yZW1vdmUoKX1mdW5jdGlvbiBqKCl7dmFyIGY9ITEsaj1iLm1hcmtlcnMuaW5zZXJ0KCk7aWYoIWopcmV0dXJuITA7Yi5lbC5ub3JtYWxpemUoKTt2YXIgaz1qLnByZXZpb3VzU2libGluZztpZihrKXt2YXIgbD1rLnRleHRDb250ZW50O2wmJmwubGVuZ3RoJiY4MjAzPT1sLmNoYXJDb2RlQXQobC5sZW5ndGgtMSkmJigxPT1sLmxlbmd0aD9hKGspLnJlbW92ZSgpOihrLnRleHRDb250ZW50PWsudGV4dENvbnRlbnQuc3Vic3RyKDAsbC5sZW5ndGgtMSksay50ZXh0Q29udGVudC5sZW5ndGgmJjU1MzU3PT1rLnRleHRDb250ZW50LmNoYXJDb2RlQXQoay50ZXh0Q29udGVudC5sZW5ndGgtMSkmJihrLnRleHRDb250ZW50PWsudGV4dENvbnRlbnQuc3Vic3RyKDAsay50ZXh0Q29udGVudC5sZW5ndGgtMSkpKSl9cmV0dXJuIGMoaik/Zj1pKGopOmQoaik/ZyhqKSYmZShqLGEoaikucGFyZW50cyhcXFwibGk6Zmlyc3RcXFwiKS5nZXQoMCkpP2IuY3Vyc29yTGlzdHMuX2JhY2tzcGFjZShqKTpoKGopOmY9aShqKSxhKGopLnJlbW92ZSgpLG4oKSxiLmh0bWwuZmlsbEVtcHR5QmxvY2tzKCEwKSxiLmh0bWwuY2xlYW5FbXB0eVRhZ3MoKSxiLmNsZWFuLnF1b3RlcygpLGIuY2xlYW4ubGlzdHMoKSxiLnNwYWNlcy5ub3JtYWxpemVBcm91bmRDdXJzb3IoKSxiLnNlbGVjdGlvbi5yZXN0b3JlKCksZn1mdW5jdGlvbiBrKGMpe3ZhciBkPWEoYykucGFyZW50c1VudGlsKGIuJGVsLFxcXCJCTE9DS1FVT1RFXFxcIikubGVuZ3RoPjAsZT1iLm5vZGUuZGVlcGVzdFBhcmVudChjLFtdLCFkKTtpZihlJiZcXFwiQkxPQ0tRVU9URVxcXCI9PWUudGFnTmFtZSl7dmFyIGY9Yi5ub2RlLmRlZXBlc3RQYXJlbnQoYyxbYShjKS5wYXJlbnRzVW50aWwoYi4kZWwsXFxcIkJMT0NLUVVPVEVcXFwiKS5nZXQoMCldKTtmJiZmLm5leHRTaWJsaW5nJiYoZT1mKX1pZihudWxsIT09ZSl7dmFyIGcsaD1lLm5leHRTaWJsaW5nO2lmKGIubm9kZS5pc0Jsb2NrKGUpJiYoYi5ub2RlLmlzRWRpdGFibGUoZSl8fGIubm9kZS5pc0RlbGV0YWJsZShlKSkmJmgmJmEuRkUuTk9fREVMRVRFX1RBR1MuaW5kZXhPZihoLnRhZ05hbWUpPDApaWYoYi5ub2RlLmlzRGVsZXRhYmxlKGgpKWEoaCkucmVtb3ZlKCksYShjKS5yZXBsYWNlV2l0aChhLkZFLk1BUktFUlMpO2Vsc2UgaWYoYi5ub2RlLmlzQmxvY2soaCkmJmIubm9kZS5pc0VkaXRhYmxlKGgpKWlmKGIubm9kZS5pc0xpc3QoaCkpaWYoYi5ub2RlLmlzRW1wdHkoZSwhMCkpYShlKS5yZW1vdmUoKSxhKGgpLmZpbmQoXFxcImxpOmZpcnN0XFxcIikucHJlcGVuZChhLkZFLk1BUktFUlMpO2Vsc2V7dmFyIGk9YShoKS5maW5kKFxcXCJsaTpmaXJzdFxcXCIpO1xcXCJCTE9DS1FVT1RFXFxcIj09ZS50YWdOYW1lJiYoZz1iLm5vZGUuY29udGVudHMoZSksZy5sZW5ndGgmJmIubm9kZS5pc0Jsb2NrKGdbZy5sZW5ndGgtMV0pJiYoZT1nW2cubGVuZ3RoLTFdKSksMD09PWkuZmluZChcXFwidWwsIG9sXFxcIikubGVuZ3RoJiYoYShjKS5yZXBsYWNlV2l0aChhLkZFLk1BUktFUlMpLGkuZmluZChiLmh0bWwuYmxvY2tUYWdzUXVlcnkoKSkubm90KFxcXCJvbCwgdWwsIHRhYmxlXFxcIikuZWFjaChmdW5jdGlvbigpe3RoaXMucGFyZW50Tm9kZT09aS5nZXQoMCkmJmEodGhpcykucmVwbGFjZVdpdGgoYSh0aGlzKS5odG1sKCkrKGIubm9kZS5pc0VtcHR5KHRoaXMpP1xcXCJcXFwiOlxcXCI8YnI+XFxcIikpfSksYShlKS5hcHBlbmQoYi5ub2RlLmNvbnRlbnRzKGkuZ2V0KDApKSksaS5yZW1vdmUoKSwwPT09YShoKS5maW5kKFxcXCJsaVxcXCIpLmxlbmd0aCYmYShoKS5yZW1vdmUoKSl9ZWxzZXtpZihnPWIubm9kZS5jb250ZW50cyhoKSxnLmxlbmd0aCYmXFxcIkJSXFxcIj09Z1swXS50YWdOYW1lJiZhKGdbMF0pLnJlbW92ZSgpLFxcXCJCTE9DS1FVT1RFXFxcIiE9aC50YWdOYW1lJiZcXFwiQkxPQ0tRVU9URVxcXCI9PWUudGFnTmFtZSlmb3IoZz1iLm5vZGUuY29udGVudHMoZSk7Zy5sZW5ndGgmJmIubm9kZS5pc0Jsb2NrKGdbZy5sZW5ndGgtMV0pOyllPWdbZy5sZW5ndGgtMV0sZz1iLm5vZGUuY29udGVudHMoZSk7ZWxzZSBpZihcXFwiQkxPQ0tRVU9URVxcXCI9PWgudGFnTmFtZSYmXFxcIkJMT0NLUVVPVEVcXFwiIT1lLnRhZ05hbWUpZm9yKGc9Yi5ub2RlLmNvbnRlbnRzKGgpO2cubGVuZ3RoJiZiLm5vZGUuaXNCbG9jayhnWzBdKTspaD1nWzBdLGc9Yi5ub2RlLmNvbnRlbnRzKGgpO2EoYykucmVwbGFjZVdpdGgoYS5GRS5NQVJLRVJTKSxhKGUpLmFwcGVuZChoLmlubmVySFRNTCksYShoKS5yZW1vdmUoKX1lbHNle2ZvcihhKGMpLnJlcGxhY2VXaXRoKGEuRkUuTUFSS0VSUyk7aCYmXFxcIkJSXFxcIiE9PWgudGFnTmFtZSYmIWIubm9kZS5pc0Jsb2NrKGgpJiZiLm5vZGUuaXNFZGl0YWJsZShoKTspe3ZhciBqPWg7aD1oLm5leHRTaWJsaW5nLGEoZSkuYXBwZW5kKGopfWgmJlxcXCJCUlxcXCI9PWgudGFnTmFtZSYmYi5ub2RlLmlzRWRpdGFibGUoaCkmJmEoaCkucmVtb3ZlKCl9fX1mdW5jdGlvbiBsKGQpe2Zvcih2YXIgZT1kOyFlLm5leHRTaWJsaW5nOylpZihlPWUucGFyZW50Tm9kZSxiLm5vZGUuaXNFbGVtZW50KGUpKXJldHVybiExO2lmKGU9ZS5uZXh0U2libGluZyxcXFwiQlJcXFwiPT1lLnRhZ05hbWUmJmIubm9kZS5pc0VkaXRhYmxlKGUpKWlmKGUubmV4dFNpYmxpbmcpe2lmKGIubm9kZS5pc0Jsb2NrKGUubmV4dFNpYmxpbmcpJiZiLm5vZGUuaXNFZGl0YWJsZShlLm5leHRTaWJsaW5nKSl7aWYoIShhLkZFLk5PX0RFTEVURV9UQUdTLmluZGV4T2YoZS5uZXh0U2libGluZy50YWdOYW1lKTwwKSlyZXR1cm4gdm9pZCBhKGUpLnJlbW92ZSgpO2U9ZS5uZXh0U2libGluZyxhKGUucHJldmlvdXNTaWJsaW5nKS5yZW1vdmUoKX19ZWxzZSBpZihjKGUpKXtpZihnKGQpKWIuY3Vyc29yTGlzdHMuX2RlbChkKTtlbHNle3ZhciBmPWIubm9kZS5kZWVwZXN0UGFyZW50KGUpO2YmJihhKGUpLnJlbW92ZSgpLGsoZCkpfXJldHVybn12YXIgaDtpZighYi5ub2RlLmlzQmxvY2soZSkmJmIubm9kZS5pc0VkaXRhYmxlKGUpKXtmb3IoaD1iLm5vZGUuY29udGVudHMoZSk7ZS5ub2RlVHlwZSE9Tm9kZS5URVhUX05PREUmJmgubGVuZ3RoJiYhYi5ub2RlLmlzRGVsZXRhYmxlKGUpJiZiLm5vZGUuaXNFZGl0YWJsZShlKTspZT1oWzBdLGg9Yi5ub2RlLmNvbnRlbnRzKGUpO2Uubm9kZVR5cGU9PU5vZGUuVEVYVF9OT0RFPyhhKGUpLmJlZm9yZShhLkZFLk1BUktFUlMpLGUudGV4dENvbnRlbnQubGVuZ3RoJiY1NTM1Nz09ZS50ZXh0Q29udGVudC5jaGFyQ29kZUF0KDApP2UudGV4dENvbnRlbnQ9ZS50ZXh0Q29udGVudC5zdWJzdHJpbmcoMixlLnRleHRDb250ZW50Lmxlbmd0aCk6ZS50ZXh0Q29udGVudD1lLnRleHRDb250ZW50LnN1YnN0cmluZygxLGUudGV4dENvbnRlbnQubGVuZ3RoKSk6Yi5ub2RlLmlzRGVsZXRhYmxlKGUpPyhhKGUpLmJlZm9yZShhLkZFLk1BUktFUlMpLGEoZSkucmVtb3ZlKCkpOmIuZXZlbnRzLnRyaWdnZXIoXFxcIm5vZGUucmVtb3ZlXFxcIixbYShlKV0pIT09ITEmJihhKGUpLmJlZm9yZShhLkZFLk1BUktFUlMpLGEoZSkucmVtb3ZlKCkpLGEoZCkucmVtb3ZlKCl9ZWxzZSBpZihhLkZFLk5PX0RFTEVURV9UQUdTLmluZGV4T2YoZS50YWdOYW1lKTwwJiYoYi5ub2RlLmlzRWRpdGFibGUoZSl8fGIubm9kZS5pc0RlbGV0YWJsZShlKSkpaWYoYi5ub2RlLmlzRGVsZXRhYmxlKGUpKWEoZCkucmVwbGFjZVdpdGgoYS5GRS5NQVJLRVJTKSxhKGUpLnJlbW92ZSgpO2Vsc2UgaWYoYi5ub2RlLmlzTGlzdChlKSlkLnByZXZpb3VzU2libGluZz8oYShlKS5maW5kKFxcXCJsaTpmaXJzdFxcXCIpLnByZXBlbmQoZCksYi5jdXJzb3JMaXN0cy5fYmFja3NwYWNlKGQpKTooYShlKS5maW5kKFxcXCJsaTpmaXJzdFxcXCIpLnByZXBlbmQoYS5GRS5NQVJLRVJTKSxhKGQpLnJlbW92ZSgpKTtlbHNlIGlmKGg9Yi5ub2RlLmNvbnRlbnRzKGUpLGgmJlxcXCJCUlxcXCI9PWhbMF0udGFnTmFtZSYmYShoWzBdKS5yZW1vdmUoKSxoJiZcXFwiQkxPQ0tRVU9URVxcXCI9PWUudGFnTmFtZSl7dmFyIGk9aFswXTtmb3IoYShkKS5iZWZvcmUoYS5GRS5NQVJLRVJTKTtpJiZcXFwiQlJcXFwiIT1pLnRhZ05hbWU7KXt2YXIgaj1pO2k9aS5uZXh0U2libGluZyxhKGQpLmJlZm9yZShqKX1pJiZcXFwiQlJcXFwiPT1pLnRhZ05hbWUmJmEoaSkucmVtb3ZlKCl9ZWxzZSBhKGQpLmFmdGVyKGEoZSkuaHRtbCgpKS5hZnRlcihhLkZFLk1BUktFUlMpLGEoZSkucmVtb3ZlKCl9ZnVuY3Rpb24gbSgpe3ZhciBlPWIubWFya2Vycy5pbnNlcnQoKTtpZighZSlyZXR1cm4hMTtpZihiLmVsLm5vcm1hbGl6ZSgpLGMoZSkpaWYoZyhlKSlpZigwPT09YShlKS5wYXJlbnRzKFxcXCJsaTpmaXJzdFxcXCIpLmZpbmQoXFxcInVsLCBvbFxcXCIpLmxlbmd0aCliLmN1cnNvckxpc3RzLl9kZWwoZSk7ZWxzZXt2YXIgZj1hKGUpLnBhcmVudHMoXFxcImxpOmZpcnN0XFxcIikuZmluZChcXFwidWw6Zmlyc3QsIG9sOmZpcnN0XFxcIikuZmluZChcXFwibGk6Zmlyc3RcXFwiKTtmPWYuZmluZChiLmh0bWwuYmxvY2tUYWdzUXVlcnkoKSkuZ2V0KC0xKXx8ZixmLnByZXBlbmQoZSksYi5jdXJzb3JMaXN0cy5fYmFja3NwYWNlKGUpfWVsc2UgayhlKTtlbHNlIGwoZChlKT9lOmUpO2EoZSkucmVtb3ZlKCksbigpLGIuaHRtbC5maWxsRW1wdHlCbG9ja3MoITApLGIuaHRtbC5jbGVhbkVtcHR5VGFncygpLGIuY2xlYW4ucXVvdGVzKCksYi5jbGVhbi5saXN0cygpLGIuc3BhY2VzLm5vcm1hbGl6ZUFyb3VuZEN1cnNvcigpLGIuc2VsZWN0aW9uLnJlc3RvcmUoKX1mdW5jdGlvbiBuKCl7Zm9yKHZhciBhPWIuZWwucXVlcnlTZWxlY3RvckFsbChcXFwiYmxvY2txdW90ZTplbXB0eVxcXCIpLGM9MDtjPGEubGVuZ3RoO2MrKylhW2NdLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoYVtjXSl9ZnVuY3Rpb24gbygpe2IuJGVsLmZpbmQoXFxcIi5mci10by1yZW1vdmVcXFwiKS5lYWNoKGZ1bmN0aW9uKCl7Zm9yKHZhciBjPWIubm9kZS5jb250ZW50cyh0aGlzKSxkPTA7ZDxjLmxlbmd0aDtkKyspY1tkXS5ub2RlVHlwZT09Tm9kZS5URVhUX05PREUmJihjW2RdLnRleHRDb250ZW50PWNbZF0udGV4dENvbnRlbnQucmVwbGFjZSgvXFxcXHUyMDBCL2csXFxcIlxcXCIpKTthKHRoaXMpLnJlcGxhY2VXaXRoKHRoaXMuaW5uZXJIVE1MKX0pfWZ1bmN0aW9uIHAoYyxkLGUpe3ZhciBnLGg9Yi5ub2RlLmRlZXBlc3RQYXJlbnQoYyxbXSwhZSk7aWYoaCYmXFxcIkJMT0NLUVVPVEVcXFwiPT1oLnRhZ05hbWUpcmV0dXJuIGYoYyxoKT8oZz1iLmh0bWwuZGVmYXVsdFRhZygpLGc/YShoKS5hZnRlcihcXFwiPFxcXCIrZytcXFwiPlxcXCIrYS5GRS5NQVJLRVJTK1xcXCI8YnI+PC9cXFwiK2crXFxcIj5cXFwiKTphKGgpLmFmdGVyKGEuRkUuTUFSS0VSUytcXFwiPGJyPlxcXCIpLGEoYykucmVtb3ZlKCksITEpOihyKGMsZCxlKSwhMSk7aWYobnVsbD09aClnPWIuaHRtbC5kZWZhdWx0VGFnKCksZyYmYi5ub2RlLmlzRWxlbWVudChjLnBhcmVudE5vZGUpP2EoYykucmVwbGFjZVdpdGgoXFxcIjxcXFwiK2crXFxcIj5cXFwiK2EuRkUuTUFSS0VSUytcXFwiPGJyPjwvXFxcIitnK1xcXCI+XFxcIik6YShjKS5yZXBsYWNlV2l0aCgoYi5ub2RlLmlzRW1wdHkoYy5wYXJlbnROb2RlLCEwKT9cXFwiXFxcIjpcXFwiPGJyLz5cXFwiKSthLkZFLk1BUktFUlMrXFxcIjxici8+XFxcIik7ZWxzZXt2YXIgaT1jLGo9XFxcIlxcXCI7Yi5ub2RlLmlzQmxvY2soaCkmJiFkfHwoaj1cXFwiPGJyLz5cXFwiKTt2YXIgaz1cXFwiXFxcIixsPVxcXCJcXFwiO2c9Yi5odG1sLmRlZmF1bHRUYWcoKTt2YXIgbT1cXFwiXFxcIixuPVxcXCJcXFwiO2cmJmIubm9kZS5pc0Jsb2NrKGgpJiYobT1cXFwiPFxcXCIrZytcXFwiPlxcXCIsbj1cXFwiPC9cXFwiK2crXFxcIj5cXFwiLGgudGFnTmFtZT09Zy50b1VwcGVyQ2FzZSgpJiYobT1iLm5vZGUub3BlblRhZ1N0cmluZyhhKGgpLmNsb25lKCkucmVtb3ZlQXR0cihcXFwiaWRcXFwiKS5nZXQoMCkpKSk7ZG8gaWYoaT1pLnBhcmVudE5vZGUsIWR8fGkhPWh8fGQmJiFiLm5vZGUuaXNCbG9jayhoKSlpZihrKz1iLm5vZGUuY2xvc2VUYWdTdHJpbmcoaSksaT09aCYmYi5ub2RlLmlzQmxvY2soaCkpbD1tK2w7ZWxzZXt2YXIgbz1cXFwiQVxcXCI9PWkudGFnTmFtZSYmZihjLGkpP1xcXCJmci10by1yZW1vdmVcXFwiOlxcXCJcXFwiO2w9Yi5ub2RlLm9wZW5UYWdTdHJpbmcoYShpKS5jbG9uZSgpLmFkZENsYXNzKG8pLmdldCgwKSkrbH13aGlsZShpIT1oKTtqPWsraitsKyhjLnBhcmVudE5vZGU9PWgmJmIubm9kZS5pc0Jsb2NrKGgpP1xcXCJcXFwiOmEuRkUuSU5WSVNJQkxFX1NQQUNFKSthLkZFLk1BUktFUlMsYi5ub2RlLmlzQmxvY2soaCkmJiFhKGgpLmZpbmQoXFxcIio6bGFzdFxcXCIpLmlzKFxcXCJiclxcXCIpJiZhKGgpLmFwcGVuZChcXFwiPGJyLz5cXFwiKSxhKGMpLmFmdGVyKCc8c3BhbiBpZD1cXFwiZnItYnJlYWtcXFwiPjwvc3Bhbj4nKSxhKGMpLnJlbW92ZSgpLGgubmV4dFNpYmxpbmcmJiFiLm5vZGUuaXNCbG9jayhoLm5leHRTaWJsaW5nKXx8Yi5ub2RlLmlzQmxvY2soaCl8fGEoaCkuYWZ0ZXIoXFxcIjxicj5cXFwiKTt2YXIgcDtwPSFkJiZiLm5vZGUuaXNCbG9jayhoKT9iLm5vZGUub3BlblRhZ1N0cmluZyhoKSthKGgpLmh0bWwoKStuOmIubm9kZS5vcGVuVGFnU3RyaW5nKGgpK2EoaCkuaHRtbCgpK2Iubm9kZS5jbG9zZVRhZ1N0cmluZyhoKSxwPXAucmVwbGFjZSgvPHNwYW4gaWQ9XFxcImZyLWJyZWFrXFxcIj48XFxcXC9zcGFuPi9nLGopLGEoaCkucmVwbGFjZVdpdGgocCl9fWZ1bmN0aW9uIHEoYyxkLGcpe3ZhciBoLGk9Yi5ub2RlLmRlZXBlc3RQYXJlbnQoYyxbXSwhZyk7aWYoaSYmXFxcIlRBQkxFXFxcIj09aS50YWdOYW1lKXJldHVybiBhKGkpLmZpbmQoXFxcInRkOmZpcnN0LCB0aDpmaXJzdFxcXCIpLnByZXBlbmQoYykscShjLGQsZyk7aWYoaSYmXFxcIkJMT0NLUVVPVEVcXFwiPT1pLnRhZ05hbWUpe2lmKGUoYyxpKSlyZXR1cm4gaD1iLmh0bWwuZGVmYXVsdFRhZygpLGg/YShpKS5iZWZvcmUoXFxcIjxcXFwiK2grXFxcIj5cXFwiK2EuRkUuTUFSS0VSUytcXFwiPGJyPjwvXFxcIitoK1xcXCI+XFxcIik6YShpKS5iZWZvcmUoYS5GRS5NQVJLRVJTK1xcXCI8YnI+XFxcIiksYShjKS5yZW1vdmUoKSwhMTtmKGMsaSk/cChjLGQsITApOnIoYyxkLCEwKX1pZihudWxsPT1pKWg9Yi5odG1sLmRlZmF1bHRUYWcoKSxoJiZiLm5vZGUuaXNFbGVtZW50KGMucGFyZW50Tm9kZSk/YShjKS5yZXBsYWNlV2l0aChcXFwiPFxcXCIraCtcXFwiPlxcXCIrYS5GRS5NQVJLRVJTK1xcXCI8YnI+PC9cXFwiK2grXFxcIj5cXFwiKTphKGMpLnJlcGxhY2VXaXRoKFxcXCI8YnI+XFxcIithLkZFLk1BUktFUlMpO2Vsc2V7aWYoYi5ub2RlLmlzQmxvY2soaSkpaWYoZClhKGMpLnJlbW92ZSgpLGEoaSkucHJlcGVuZChcXFwiPGJyPlxcXCIrYS5GRS5NQVJLRVJTKTtlbHNle2lmKGIubm9kZS5pc0VtcHR5KGksITApKXJldHVybiBwKGMsZCxnKTthKGkpLmJlZm9yZShiLm5vZGUub3BlblRhZ1N0cmluZyhhKGkpLmNsb25lKCkucmVtb3ZlQXR0cihcXFwiaWRcXFwiKS5nZXQoMCkpK1xcXCI8YnI+XFxcIitiLm5vZGUuY2xvc2VUYWdTdHJpbmcoaSkpfWVsc2UgYShpKS5iZWZvcmUoXFxcIjxicj5cXFwiKTthKGMpLnJlbW92ZSgpfX1mdW5jdGlvbiByKGMsZCxnKXt2YXIgaD1iLm5vZGUuZGVlcGVzdFBhcmVudChjLFtdLCFnKTtpZihudWxsPT1oKWIuaHRtbC5kZWZhdWx0VGFnKCkmJmMucGFyZW50Tm9kZT09PWIuZWw/YShjKS5yZXBsYWNlV2l0aChcXFwiPFxcXCIrYi5odG1sLmRlZmF1bHRUYWcoKStcXFwiPlxcXCIrYS5GRS5NQVJLRVJTK1xcXCI8YnI+PC9cXFwiK2IuaHRtbC5kZWZhdWx0VGFnKCkrXFxcIj5cXFwiKTooYy5uZXh0U2libGluZyYmIWIubm9kZS5pc0Jsb2NrKGMubmV4dFNpYmxpbmcpfHxhKGMpLmFmdGVyKFxcXCI8YnI+XFxcIiksYShjKS5yZXBsYWNlV2l0aChcXFwiPGJyPlxcXCIrYS5GRS5NQVJLRVJTKSk7ZWxzZXt2YXIgaT1jLGo9XFxcIlxcXCI7XFxcIlBSRVxcXCI9PWgudGFnTmFtZSYmKGQ9ITApLGIubm9kZS5pc0Jsb2NrKGgpJiYhZHx8KGo9XFxcIjxicj5cXFwiKTt2YXIgaz1cXFwiXFxcIixsPVxcXCJcXFwiO2Rve3ZhciBtPWk7aWYoaT1pLnBhcmVudE5vZGUsXFxcIkJMT0NLUVVPVEVcXFwiPT1oLnRhZ05hbWUmJmIubm9kZS5pc0VtcHR5KG0pJiYhYi5ub2RlLmhhc0NsYXNzKG0sXFxcImZyLW1hcmtlclxcXCIpJiZhKG0pLmZpbmQoYykubGVuZ3RoPjAmJmEobSkuYWZ0ZXIoYyksKFxcXCJCTE9DS1FVT1RFXFxcIiE9aC50YWdOYW1lfHwhZihjLGkpJiYhZShjLGkpKSYmKCFkfHxpIT1ofHxkJiYhYi5ub2RlLmlzQmxvY2soaCkpKXtrKz1iLm5vZGUuY2xvc2VUYWdTdHJpbmcoaSk7dmFyIG49XFxcIkFcXFwiPT1pLnRhZ05hbWUmJmYoYyxpKT9cXFwiZnItdG8tcmVtb3ZlXFxcIjpcXFwiXFxcIjtsPWIubm9kZS5vcGVuVGFnU3RyaW5nKGEoaSkuY2xvbmUoKS5hZGRDbGFzcyhuKS5yZW1vdmVBdHRyKFxcXCJpZFxcXCIpLmdldCgwKSkrbH19d2hpbGUoaSE9aCk7dmFyIG89aD09Yy5wYXJlbnROb2RlJiZiLm5vZGUuaXNCbG9jayhoKXx8Yy5uZXh0U2libGluZztpZihcXFwiQkxPQ0tRVU9URVxcXCI9PWgudGFnTmFtZSl7Yy5wcmV2aW91c1NpYmxpbmcmJmIubm9kZS5pc0Jsb2NrKGMucHJldmlvdXNTaWJsaW5nKSYmYy5uZXh0U2libGluZyYmXFxcIkJSXFxcIj09Yy5uZXh0U2libGluZy50YWdOYW1lJiYoYShjLm5leHRTaWJsaW5nKS5hZnRlcihjKSxjLm5leHRTaWJsaW5nJiZcXFwiQlJcXFwiPT1jLm5leHRTaWJsaW5nLnRhZ05hbWUmJmEoYy5uZXh0U2libGluZykucmVtb3ZlKCkpO3ZhciBwPWIuaHRtbC5kZWZhdWx0VGFnKCk7aj1rK2orKHA/XFxcIjxcXFwiK3ArXFxcIj5cXFwiOlxcXCJcXFwiKSthLkZFLk1BUktFUlMrXFxcIjxicj5cXFwiKyhwP1xcXCI8L1xcXCIrcCtcXFwiPlxcXCI6XFxcIlxcXCIpK2x9ZWxzZSBqPWsraitsKyhvP1xcXCJcXFwiOmEuRkUuSU5WSVNJQkxFX1NQQUNFKSthLkZFLk1BUktFUlM7YShjKS5yZXBsYWNlV2l0aCgnPHNwYW4gaWQ9XFxcImZyLWJyZWFrXFxcIj48L3NwYW4+Jyk7dmFyIHE9Yi5ub2RlLm9wZW5UYWdTdHJpbmcoaCkrYShoKS5odG1sKCkrYi5ub2RlLmNsb3NlVGFnU3RyaW5nKGgpO3E9cS5yZXBsYWNlKC88c3BhbiBpZD1cXFwiZnItYnJlYWtcXFwiPjxcXFxcL3NwYW4+L2csaiksYShoKS5yZXBsYWNlV2l0aChxKX19ZnVuY3Rpb24gcyhlKXt2YXIgZj1iLm1hcmtlcnMuaW5zZXJ0KCk7aWYoIWYpcmV0dXJuITA7Yi5lbC5ub3JtYWxpemUoKTt2YXIgaD0hMTthKGYpLnBhcmVudHNVbnRpbChiLiRlbCxcXFwiQkxPQ0tRVU9URVxcXCIpLmxlbmd0aD4wJiYoZT0hMSxoPSEwKSxhKGYpLnBhcmVudHNVbnRpbChiLiRlbCxcXFwiVEQsIFRIXFxcIikubGVuZ3RoJiYoaD0hMSksYyhmKT8hZyhmKXx8ZXx8aD9wKGYsZSxoKTpiLmN1cnNvckxpc3RzLl9lbmRFbnRlcihmKTpkKGYpPyFnKGYpfHxlfHxoP3EoZixlLGgpOmIuY3Vyc29yTGlzdHMuX3N0YXJ0RW50ZXIoZik6IWcoZil8fGV8fGg/cihmLGUsaCk6Yi5jdXJzb3JMaXN0cy5fbWlkZGxlRW50ZXIoZiksbygpLGIuaHRtbC5maWxsRW1wdHlCbG9ja3MoITApLGIuaHRtbC5jbGVhbkVtcHR5VGFncygpLGIuY2xlYW4ubGlzdHMoKSxiLnNwYWNlcy5ub3JtYWxpemVBcm91bmRDdXJzb3IoKSxiLnNlbGVjdGlvbi5yZXN0b3JlKCl9cmV0dXJue2VudGVyOnMsYmFja3NwYWNlOmosZGVsOm0saXNBdEVuZDpmLGlzQXRTdGFydDplfX0sYS5GRS5FTlRFUl9QPTAsYS5GRS5FTlRFUl9ESVY9MSxhLkZFLkVOVEVSX0JSPTIsYS5GRS5LRVlDT0RFPXtCQUNLU1BBQ0U6OCxUQUI6OSxFTlRFUjoxMyxTSElGVDoxNixDVFJMOjE3LEFMVDoxOCxFU0M6MjcsU1BBQ0U6MzIsQVJST1dfTEVGVDozNyxBUlJPV19VUDozOCxBUlJPV19SSUdIVDozOSxBUlJPV19ET1dOOjQwLERFTEVURTo0NixaRVJPOjQ4LE9ORTo0OSxUV086NTAsVEhSRUU6NTEsRk9VUjo1MixGSVZFOjUzLFNJWDo1NCxTRVZFTjo1NSxFSUdIVDo1NixOSU5FOjU3LEZGX1NFTUlDT0xPTjo1OSxGRl9FUVVBTFM6NjEsUVVFU1RJT05fTUFSSzo2MyxBOjY1LEI6NjYsQzo2NyxEOjY4LEU6NjksRjo3MCxHOjcxLEg6NzIsSTo3MyxKOjc0LEs6NzUsTDo3NixNOjc3LE46NzgsTzo3OSxQOjgwLFE6ODEsUjo4MixTOjgzLFQ6ODQsVTo4NSxWOjg2LFc6ODcsWDo4OCxZOjg5LFo6OTAsTUVUQTo5MSxOVU1fWkVSTzo5NixOVU1fT05FOjk3LE5VTV9UV086OTgsTlVNX1RIUkVFOjk5LE5VTV9GT1VSOjEwMCxOVU1fRklWRToxMDEsTlVNX1NJWDoxMDIsTlVNX1NFVkVOOjEwMyxOVU1fRUlHSFQ6MTA0LE5VTV9OSU5FOjEwNSxOVU1fTVVMVElQTFk6MTA2LE5VTV9QTFVTOjEwNyxOVU1fTUlOVVM6MTA5LE5VTV9QRVJJT0Q6MTEwLE5VTV9ESVZJU0lPTjoxMTEsRjE6MTEyLEYyOjExMyxGMzoxMTQsRjQ6MTE1LEY1OjExNixGNjoxMTcsRjc6MTE4LEY4OjExOSxGOToxMjAsRjEwOjEyMSxGMTE6MTIyLEYxMjoxMjMsRkZfSFlQSEVOOjE3MyxTRU1JQ09MT046MTg2LERBU0g6MTg5LEVRVUFMUzoxODcsQ09NTUE6MTg4LEhZUEhFTjoxODksUEVSSU9EOjE5MCxTTEFTSDoxOTEsQVBPU1RST1BIRToxOTIsVElMREU6MTkyLFNJTkdMRV9RVU9URToyMjIsT1BFTl9TUVVBUkVfQlJBQ0tFVDoyMTksQkFDS1NMQVNIOjIyMCxDTE9TRV9TUVVBUkVfQlJBQ0tFVDoyMjF9LGEuZXh0ZW5kKGEuRkUuREVGQVVMVFMse2VudGVyOmEuRkUuRU5URVJfUCxtdWx0aUxpbmU6ITAsdGFiU3BhY2VzOjB9KSxhLkZFLk1PRFVMRVMua2V5cz1mdW5jdGlvbihiKXtmdW5jdGlvbiBjKGEpe2Iub3B0cy5tdWx0aUxpbmU/Yi5oZWxwZXJzLmlzSU9TKCl8fChhLnByZXZlbnREZWZhdWx0KCksYS5zdG9wUHJvcGFnYXRpb24oKSxiLnNlbGVjdGlvbi5pc0NvbGxhcHNlZCgpfHxiLnNlbGVjdGlvbi5yZW1vdmUoKSxiLmN1cnNvci5lbnRlcigpKTooYS5wcmV2ZW50RGVmYXVsdCgpLGEuc3RvcFByb3BhZ2F0aW9uKCkpfWZ1bmN0aW9uIGQoYSl7YS5wcmV2ZW50RGVmYXVsdCgpLGEuc3RvcFByb3BhZ2F0aW9uKCksYi5vcHRzLm11bHRpTGluZSYmKGIuc2VsZWN0aW9uLmlzQ29sbGFwc2VkKCl8fGIuc2VsZWN0aW9uLnJlbW92ZSgpLGIuY3Vyc29yLmVudGVyKCEwKSl9ZnVuY3Rpb24gZShhKXtiLnNlbGVjdGlvbi5pc0NvbGxhcHNlZCgpP2IuY3Vyc29yLmJhY2tzcGFjZSgpfHwoYS5wcmV2ZW50RGVmYXVsdCgpLGEuc3RvcFByb3BhZ2F0aW9uKCksej0hMSk6KGEucHJldmVudERlZmF1bHQoKSxhLnN0b3BQcm9wYWdhdGlvbigpLGIuc2VsZWN0aW9uLnJlbW92ZSgpLGIuaHRtbC5maWxsRW1wdHlCbG9ja3MoKSx6PSExKSxiLnBsYWNlaG9sZGVyLnJlZnJlc2goKX1mdW5jdGlvbiBmKGEpe2EucHJldmVudERlZmF1bHQoKSxhLnN0b3BQcm9wYWdhdGlvbigpLFxcXCJcXFwiPT09Yi5zZWxlY3Rpb24udGV4dCgpP2IuY3Vyc29yLmRlbCgpOmIuc2VsZWN0aW9uLnJlbW92ZSgpLGIucGxhY2Vob2xkZXIucmVmcmVzaCgpfWZ1bmN0aW9uIGcoYyl7dmFyIGQ9Yi5zZWxlY3Rpb24uZWxlbWVudCgpO2lmKCFiLmhlbHBlcnMuaXNNb2JpbGUoKSYmKGIuYnJvd3Nlci5tb3ppbGxhfHxkJiZcXFwiQVxcXCI9PWQudGFnTmFtZSkpe2MucHJldmVudERlZmF1bHQoKSxjLnN0b3BQcm9wYWdhdGlvbigpLGIuc2VsZWN0aW9uLmlzQ29sbGFwc2VkKCl8fGIuc2VsZWN0aW9uLnJlbW92ZSgpO3ZhciBlPWIubWFya2Vycy5pbnNlcnQoKTtpZihlKXt2YXIgZj1lLnByZXZpb3VzU2libGluZyxnPWUubmV4dFNpYmxpbmc7IWcmJmUucGFyZW50Tm9kZSYmXFxcIkFcXFwiPT1lLnBhcmVudE5vZGUudGFnTmFtZT8oZS5wYXJlbnROb2RlLmluc2VydEFkamFjZW50SFRNTChcXFwiYWZ0ZXJlbmRcXFwiLFxcXCImbmJzcDtcXFwiK2EuRkUuTUFSS0VSUyksZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGUpKTooZiYmZi5ub2RlVHlwZT09Tm9kZS5URVhUX05PREUmJjE9PWYudGV4dENvbnRlbnQubGVuZ3RoJiYxNjA9PWYudGV4dENvbnRlbnQuY2hhckNvZGVBdCgwKT9mLnRleHRDb250ZW50PWYudGV4dENvbnRlbnQrXFxcIiBcXFwiOmUuaW5zZXJ0QWRqYWNlbnRIVE1MKFxcXCJiZWZvcmViZWdpblxcXCIsXFxcIiZuYnNwO1xcXCIpLGUub3V0ZXJIVE1MPWEuRkUuTUFSS0VSUyksYi5zZWxlY3Rpb24ucmVzdG9yZSgpfX19ZnVuY3Rpb24gaCgpe2lmKGIuYnJvd3Nlci5tb3ppbGxhJiZiLnNlbGVjdGlvbi5pc0NvbGxhcHNlZCgpJiYhQyl7dmFyIGE9Yi5zZWxlY3Rpb24ucmFuZ2VzKDApLGM9YS5zdGFydENvbnRhaW5lcixkPWEuc3RhcnRPZmZzZXQ7YyYmYy5ub2RlVHlwZT09Tm9kZS5URVhUX05PREUmJmQ8PWMudGV4dENvbnRlbnQubGVuZ3RoJiZkPjAmJjMyPT1jLnRleHRDb250ZW50LmNoYXJDb2RlQXQoZC0xKSYmKGIuc2VsZWN0aW9uLnNhdmUoKSxiLnNwYWNlcy5ub3JtYWxpemUoKSxiLnNlbGVjdGlvbi5yZXN0b3JlKCkpfX1mdW5jdGlvbiBpKCl7Yi5zZWxlY3Rpb24uaXNGdWxsKCkmJnNldFRpbWVvdXQoZnVuY3Rpb24oKXt2YXIgYz1iLmh0bWwuZGVmYXVsdFRhZygpO2M/Yi4kZWwuaHRtbChcXFwiPFxcXCIrYytcXFwiPlxcXCIrYS5GRS5NQVJLRVJTK1xcXCI8YnIvPjwvXFxcIitjK1xcXCI+XFxcIik6Yi4kZWwuaHRtbChhLkZFLk1BUktFUlMrXFxcIjxici8+XFxcIiksYi5zZWxlY3Rpb24ucmVzdG9yZSgpLGIucGxhY2Vob2xkZXIucmVmcmVzaCgpLGIuYnV0dG9uLmJ1bGtSZWZyZXNoKCksYi51bmRvLnNhdmVTdGVwKCl9LDApfWZ1bmN0aW9uIGooYSl7aWYoYi5vcHRzLnRhYlNwYWNlcz4wKWlmKGIuc2VsZWN0aW9uLmlzQ29sbGFwc2VkKCkpe2IudW5kby5zYXZlU3RlcCgpLGEucHJldmVudERlZmF1bHQoKSxhLnN0b3BQcm9wYWdhdGlvbigpO2Zvcih2YXIgYz1cXFwiXFxcIixkPTA7ZDxiLm9wdHMudGFiU3BhY2VzO2QrKyljKz1cXFwiJm5ic3A7XFxcIjtiLmh0bWwuaW5zZXJ0KGMpLGIucGxhY2Vob2xkZXIucmVmcmVzaCgpLGIudW5kby5zYXZlU3RlcCgpfWVsc2UgYS5wcmV2ZW50RGVmYXVsdCgpLGEuc3RvcFByb3BhZ2F0aW9uKCksYS5zaGlmdEtleT9iLmNvbW1hbmRzLm91dGRlbnQoKTpiLmNvbW1hbmRzLmluZGVudCgpfWZ1bmN0aW9uIGsoYSl7Qz0hMX1mdW5jdGlvbiBsKCl7cmV0dXJuIEN9ZnVuY3Rpb24gbShoKXtcXG5iLmV2ZW50cy5kaXNhYmxlQmx1cigpLHo9ITA7dmFyIGk9aC53aGljaDtpZigxNj09PWkpcmV0dXJuITA7aWYoMjI5PT09aSlyZXR1cm4gQz0hMCwhMDtDPSExO3ZhciBrPXQoaSkmJiFyKGgpLGw9aT09YS5GRS5LRVlDT0RFLkJBQ0tTUEFDRXx8aT09YS5GRS5LRVlDT0RFLkRFTEVURTtpZigoYi5zZWxlY3Rpb24uaXNGdWxsKCkmJiFiLm9wdHMua2VlcEZvcm1hdE9uRGVsZXRlJiYhYi5wbGFjZWhvbGRlci5pc1Zpc2libGUoKXx8bCYmYi5wbGFjZWhvbGRlci5pc1Zpc2libGUoKSYmYi5vcHRzLmtlZXBGb3JtYXRPbkRlbGV0ZSkmJihrfHxsKSl7dmFyIG09Yi5odG1sLmRlZmF1bHRUYWcoKTtpZihtP2IuJGVsLmh0bWwoXFxcIjxcXFwiK20rXFxcIj5cXFwiK2EuRkUuTUFSS0VSUytcXFwiPGJyLz48L1xcXCIrbStcXFwiPlxcXCIpOmIuJGVsLmh0bWwoYS5GRS5NQVJLRVJTK1xcXCI8YnIvPlxcXCIpLGIuc2VsZWN0aW9uLnJlc3RvcmUoKSwhdChpKSlyZXR1cm4gaC5wcmV2ZW50RGVmYXVsdCgpLCEwfWk9PWEuRkUuS0VZQ09ERS5FTlRFUj9oLnNoaWZ0S2V5P2QoaCk6YyhoKTppIT1hLkZFLktFWUNPREUuQkFDS1NQQUNFfHxyKGgpfHxoLmFsdEtleT9pIT1hLkZFLktFWUNPREUuREVMRVRFfHxyKGgpfHxoLmFsdEtleT9pPT1hLkZFLktFWUNPREUuU1BBQ0U/ZyhoKTppPT1hLkZFLktFWUNPREUuVEFCP2ooaCk6cihoKXx8IXQoaC53aGljaCl8fGIuc2VsZWN0aW9uLmlzQ29sbGFwc2VkKCl8fGguY3RybEtleXx8Yi5zZWxlY3Rpb24ucmVtb3ZlKCk6Yi5wbGFjZWhvbGRlci5pc1Zpc2libGUoKT8oaC5wcmV2ZW50RGVmYXVsdCgpLGguc3RvcFByb3BhZ2F0aW9uKCkpOmYoaCk6Yi5wbGFjZWhvbGRlci5pc1Zpc2libGUoKT8oaC5wcmV2ZW50RGVmYXVsdCgpLGguc3RvcFByb3BhZ2F0aW9uKCkpOmUoaCksYi5ldmVudHMuZW5hYmxlQmx1cigpfWZ1bmN0aW9uIG4oYSl7Zm9yKHZhciBjPWIuZG9jLmNyZWF0ZVRyZWVXYWxrZXIoYSxOb2RlRmlsdGVyLlNIT1dfVEVYVCxiLm5vZGUuZmlsdGVyKGZ1bmN0aW9uKGEpe3JldHVybi9cXFxcdTIwMEIvZ2kudGVzdChhLnRleHRDb250ZW50KX0pLCExKTtjLm5leHROb2RlKCk7KXt2YXIgZD1jLmN1cnJlbnROb2RlO2QudGV4dENvbnRlbnQ9ZC50ZXh0Q29udGVudC5yZXBsYWNlKC9cXFxcdTIwMEIvZ2ksXFxcIlxcXCIpfX1mdW5jdGlvbiBvKCl7aWYoIWIuJHdwKXJldHVybiEwO3ZhciBjO2Iub3B0cy5oZWlnaHR8fGIub3B0cy5oZWlnaHRNYXg/KGM9Yi5wb3NpdGlvbi5nZXRCb3VuZGluZ1JlY3QoKS50b3AsYi5oZWxwZXJzLmlzSU9TKCkmJihjLT1hKGIub193aW4pLnNjcm9sbFRvcCgpKSxiLm9wdHMuaWZyYW1lJiYoYys9Yi4kaWZyYW1lLm9mZnNldCgpLnRvcCksYz5iLiR3cC5vZmZzZXQoKS50b3AtYShiLm9fd2luKS5zY3JvbGxUb3AoKStiLiR3cC5oZWlnaHQoKS0yMCYmYi4kd3Auc2Nyb2xsVG9wKGMrYi4kd3Auc2Nyb2xsVG9wKCktKGIuJHdwLmhlaWdodCgpK2IuJHdwLm9mZnNldCgpLnRvcCkrYShiLm9fd2luKS5zY3JvbGxUb3AoKSsyMCkpOihjPWIucG9zaXRpb24uZ2V0Qm91bmRpbmdSZWN0KCkudG9wLGIub3B0cy50b29sYmFyQm90dG9tJiYoYys9Yi5vcHRzLnRvb2xiYXJTdGlja3lPZmZzZXQpLGIuaGVscGVycy5pc0lPUygpJiYoYy09YShiLm9fd2luKS5zY3JvbGxUb3AoKSksYi5vcHRzLmlmcmFtZSYmKGMrPWIuJGlmcmFtZS5vZmZzZXQoKS50b3ApLGMrPWIub3B0cy50b29sYmFyU3RpY2t5T2Zmc2V0LGM+Yi5vX3dpbi5pbm5lckhlaWdodC0yMCYmYShiLm9fd2luKS5zY3JvbGxUb3AoYythKGIub193aW4pLnNjcm9sbFRvcCgpLWIub193aW4uaW5uZXJIZWlnaHQrMjApLGM9Yi5wb3NpdGlvbi5nZXRCb3VuZGluZ1JlY3QoKS50b3AsYi5vcHRzLnRvb2xiYXJCb3R0b218fChjLT1iLm9wdHMudG9vbGJhclN0aWNreU9mZnNldCksYi5oZWxwZXJzLmlzSU9TKCkmJihjLT1hKGIub193aW4pLnNjcm9sbFRvcCgpKSxiLm9wdHMuaWZyYW1lJiYoYys9Yi4kaWZyYW1lLm9mZnNldCgpLnRvcCksYzxiLiR0Yi5oZWlnaHQoKSsyMCYmYShiLm9fd2luKS5zY3JvbGxUb3AoYythKGIub193aW4pLnNjcm9sbFRvcCgpLWIuJHRiLmhlaWdodCgpLTIwKSl9ZnVuY3Rpb24gcCgpe3ZhciBjPWIuc2VsZWN0aW9uLmVsZW1lbnQoKSxkPWIubm9kZS5ibG9ja1BhcmVudChjKTtpZihkJiZcXFwiRElWXFxcIj09ZC50YWdOYW1lJiZiLnNlbGVjdGlvbi5pbmZvKGQpLmF0U3RhcnQpe3ZhciBlPWIuaHRtbC5kZWZhdWx0VGFnKCk7ZC5wcmV2aW91c1NpYmxpbmcmJlxcXCJESVZcXFwiIT1kLnByZXZpb3VzU2libGluZy50YWdOYW1lJiZlJiZcXFwiZGl2XFxcIiE9ZSYmKGIuc2VsZWN0aW9uLnNhdmUoKSxhKGQpLnJlcGxhY2VXaXRoKFxcXCI8XFxcIitlK1xcXCI+XFxcIitkLmlubmVySFRNTCtcXFwiPC9cXFwiK2UrXFxcIj5cXFwiKSxiLnNlbGVjdGlvbi5yZXN0b3JlKCkpfX1mdW5jdGlvbiBxKGMpe2lmKEMpcmV0dXJuIEM9ITEsITE7aWYoIWIuc2VsZWN0aW9uLmlzQ29sbGFwc2VkKCkpcmV0dXJuITA7aWYoYyYmKGMud2hpY2g9PT1hLkZFLktFWUNPREUuTUVUQXx8Yy53aGljaD09YS5GRS5LRVlDT0RFLkNUUkwpKXJldHVybiEwO2lmKGMmJnMoYy53aGljaCkpcmV0dXJuITA7YyYmYy53aGljaD09YS5GRS5LRVlDT0RFLkVOVEVSJiZiLmhlbHBlcnMuaXNJT1MoKSYmcCgpLGMmJihjLndoaWNoPT1hLkZFLktFWUNPREUuRU5URVJ8fGMud2hpY2g9PWEuRkUuS0VZQ09ERS5CQUNLU1BBQ0V8fGMud2hpY2g+PTM3JiZjLndoaWNoPD00MCYmIWIuYnJvd3Nlci5tc2llKSYmKGMud2hpY2g9PWEuRkUuS0VZQ09ERS5CQUNLU1BBQ0UmJnp8fG8oKSksYi5odG1sLmNsZWFuQlJzKCEwLCEwKTt2YXIgZD1mdW5jdGlvbihhKXtpZighYSlyZXR1cm4hMTt2YXIgYj1hLmlubmVySFRNTDtyZXR1cm4gYj1iLnJlcGxhY2UoLzxzcGFuW14+XSo/IGNsYXNzXFxcXHMqPVxcXFxzKltcXFwiJ10/ZnItbWFya2VyW1xcXCInXT9bXj5dKz5cXFxcdTIwMGI8XFxcXC9zcGFuPi9naSxcXFwiXFxcIiksISEoYiYmL1xcXFx1MjAwQi8udGVzdChiKSYmYi5yZXBsYWNlKC9cXFxcdTIwMEIvZ2ksXFxcIlxcXCIpLmxlbmd0aD4wKX0sZT1mdW5jdGlvbihhKXt2YXIgYz0vW1xcXFx1MzA0MS1cXFxcdTMwOTZcXFxcdTMwQTAtXFxcXHUzMEZGXFxcXHU0RTAwLVxcXFx1OUZGRlxcXFx1MzEzMC1cXFxcdTMxOEZcXFxcdUFDMDAtXFxcXHVEN0FGXS9naTtyZXR1cm4hYi5oZWxwZXJzLmlzSU9TKCl8fDA9PT0oKGEudGV4dENvbnRlbnR8fFxcXCJcXFwiKS5tYXRjaChjKXx8W10pLmxlbmd0aH0sZj1iLnNlbGVjdGlvbi5lbGVtZW50KCk7ZChmKSYmIWIubm9kZS5oYXNDbGFzcyhmLFxcXCJmci1tYXJrZXJcXFwiKSYmXFxcIklGUkFNRVxcXCIhPWYudGFnTmFtZSYmZShmKSYmKGIuc2VsZWN0aW9uLnNhdmUoKSxuKGYpLGIuc2VsZWN0aW9uLnJlc3RvcmUoKSl9ZnVuY3Rpb24gcihhKXtpZihuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoXFxcIk1hYyBPUyBYXFxcIikhPS0xKXtpZihhLm1ldGFLZXkmJiFhLmFsdEtleSlyZXR1cm4hMH1lbHNlIGlmKGEuY3RybEtleSYmIWEuYWx0S2V5KXJldHVybiEwO3JldHVybiExfWZ1bmN0aW9uIHMoYil7aWYoYj49YS5GRS5LRVlDT0RFLkFSUk9XX0xFRlQmJmI8PWEuRkUuS0VZQ09ERS5BUlJPV19ET1dOKXJldHVybiEwfWZ1bmN0aW9uIHQoYyl7aWYoYz49YS5GRS5LRVlDT0RFLlpFUk8mJmM8PWEuRkUuS0VZQ09ERS5OSU5FKXJldHVybiEwO2lmKGM+PWEuRkUuS0VZQ09ERS5OVU1fWkVSTyYmYzw9YS5GRS5LRVlDT0RFLk5VTV9NVUxUSVBMWSlyZXR1cm4hMDtpZihjPj1hLkZFLktFWUNPREUuQSYmYzw9YS5GRS5LRVlDT0RFLlopcmV0dXJuITA7aWYoYi5icm93c2VyLndlYmtpdCYmMD09PWMpcmV0dXJuITA7c3dpdGNoKGMpe2Nhc2UgYS5GRS5LRVlDT0RFLlNQQUNFOmNhc2UgYS5GRS5LRVlDT0RFLlFVRVNUSU9OX01BUks6Y2FzZSBhLkZFLktFWUNPREUuTlVNX1BMVVM6Y2FzZSBhLkZFLktFWUNPREUuTlVNX01JTlVTOmNhc2UgYS5GRS5LRVlDT0RFLk5VTV9QRVJJT0Q6Y2FzZSBhLkZFLktFWUNPREUuTlVNX0RJVklTSU9OOmNhc2UgYS5GRS5LRVlDT0RFLlNFTUlDT0xPTjpjYXNlIGEuRkUuS0VZQ09ERS5GRl9TRU1JQ09MT046Y2FzZSBhLkZFLktFWUNPREUuREFTSDpjYXNlIGEuRkUuS0VZQ09ERS5FUVVBTFM6Y2FzZSBhLkZFLktFWUNPREUuRkZfRVFVQUxTOmNhc2UgYS5GRS5LRVlDT0RFLkNPTU1BOmNhc2UgYS5GRS5LRVlDT0RFLlBFUklPRDpjYXNlIGEuRkUuS0VZQ09ERS5TTEFTSDpjYXNlIGEuRkUuS0VZQ09ERS5BUE9TVFJPUEhFOmNhc2UgYS5GRS5LRVlDT0RFLlNJTkdMRV9RVU9URTpjYXNlIGEuRkUuS0VZQ09ERS5PUEVOX1NRVUFSRV9CUkFDS0VUOmNhc2UgYS5GRS5LRVlDT0RFLkJBQ0tTTEFTSDpjYXNlIGEuRkUuS0VZQ09ERS5DTE9TRV9TUVVBUkVfQlJBQ0tFVDpyZXR1cm4hMDtkZWZhdWx0OnJldHVybiExfX1mdW5jdGlvbiB1KGMpe3ZhciBkPWMud2hpY2g7cmV0dXJuISEocihjKXx8ZD49MzcmJmQ8PTQwfHwhdChkKSYmZCE9YS5GRS5LRVlDT0RFLkRFTEVURSYmZCE9YS5GRS5LRVlDT0RFLkJBQ0tTUEFDRSYmZCE9YS5GRS5LRVlDT0RFLkVOVEVSKXx8KEF8fChCPWIuc25hcHNob3QuZ2V0KCkpLGNsZWFyVGltZW91dChBKSx2b2lkKEE9c2V0VGltZW91dChmdW5jdGlvbigpe0E9bnVsbCxiLnVuZG8uc2F2ZVN0ZXAoKX0sTWF0aC5tYXgoMjUwLGIub3B0cy50eXBpbmdUaW1lcikpKSl9ZnVuY3Rpb24gdihhKXt2YXIgYz1hLndoaWNoO3JldHVybiEhKHIoYSl8fGM+PTM3JiZjPD00MCl8fHZvaWQoQiYmQSYmKGIudW5kby5zYXZlU3RlcChCKSxCPW51bGwpKX1mdW5jdGlvbiB3KCl7QSYmKGNsZWFyVGltZW91dChBKSxiLnVuZG8uc2F2ZVN0ZXAoKSxCPW51bGwpfWZ1bmN0aW9uIHgoYil7dmFyIGM9Yi53aGljaDtyZXR1cm4gcihiKXx8Yz09YS5GRS5LRVlDT0RFLkY1fWZ1bmN0aW9uIHkoKXtpZihiLmV2ZW50cy5vbihcXFwia2V5ZG93blxcXCIsdSksYi5ldmVudHMub24oXFxcImlucHV0XFxcIixoKSxiLmV2ZW50cy5vbihcXFwia2V5dXAgaW5wdXRcXFwiLHYpLGIuZXZlbnRzLm9uKFxcXCJrZXlwcmVzc1xcXCIsayksYi5ldmVudHMub24oXFxcImtleWRvd25cXFwiLG0pLGIuZXZlbnRzLm9uKFxcXCJrZXl1cFxcXCIscSksYi5ldmVudHMub24oXFxcImh0bWwuaW5zZXJ0ZWRcXFwiLHEpLGIuZXZlbnRzLm9uKFxcXCJjdXRcXFwiLGkpLGIuZWwubXNHZXRJbnB1dENvbnRleHQpdHJ5e2IuZWwubXNHZXRJbnB1dENvbnRleHQoKS5hZGRFdmVudExpc3RlbmVyKFxcXCJNU0NhbmRpZGF0ZVdpbmRvd1Nob3dcXFwiLGZ1bmN0aW9uKCl7Qz0hMH0pLGIuZWwubXNHZXRJbnB1dENvbnRleHQoKS5hZGRFdmVudExpc3RlbmVyKFxcXCJNU0NhbmRpZGF0ZVdpbmRvd0hpZGVcXFwiLGZ1bmN0aW9uKCl7Qz0hMSxxKCl9KX1jYXRjaChhKXt9fXZhciB6LEEsQixDPSExO3JldHVybntfaW5pdDp5LGN0cmxLZXk6cixpc0NoYXJhY3Rlcjp0LGlzQXJyb3c6cyxmb3JjZVVuZG86dyxpc0lNRTpsLGlzQnJvd3NlckFjdGlvbjp4fX0sYS5GRS5NT0RVTEVTLmFjY2Vzc2liaWxpdHk9ZnVuY3Rpb24oYil7ZnVuY3Rpb24gYyhhKXthJiZhLmxlbmd0aCYmKGEuZGF0YShcXFwiYmx1ci1ldmVudC1zZXRcXFwiKXx8YS5wYXJlbnRzKFxcXCIuZnItcG9wdXBcXFwiKS5sZW5ndGh8fChiLmV2ZW50cy4kb24oYSxcXFwiYmx1clxcXCIsZnVuY3Rpb24oYyl7dmFyIGQ9YS5wYXJlbnRzKFxcXCIuZnItdG9vbGJhciwgLmZyLXBvcHVwXFxcIikuZGF0YShcXFwiaW5zdGFuY2VcXFwiKXx8YjtkLmV2ZW50cy5ibHVyQWN0aXZlKCkmJmQuZXZlbnRzLnRyaWdnZXIoXFxcImJsdXJcXFwiKSxkLmV2ZW50cy5lbmFibGVCbHVyKCl9LCEwKSxhLmRhdGEoXFxcImJsdXItZXZlbnQtc2V0XFxcIiwhMCkpLGIuZXZlbnRzLmRpc2FibGVCbHVyKCksYS5mb2N1cygpLGIuc2hhcmVkLiRmX2VsPWEpfWZ1bmN0aW9uIGQoYSxiKXt2YXIgZD1iP1xcXCJsYXN0XFxcIjpcXFwiZmlyc3RcXFwiLGU9YS5maW5kKFxcXCJidXR0b246dmlzaWJsZTpub3QoLmZyLWRpc2FibGVkKSwgLmZyLWdyb3VwIHNwYW4uZnItY29tbWFuZDp2aXNpYmxlXFxcIilbZF0oKTtpZihlLmxlbmd0aClyZXR1cm4gYyhlKSwhMH1mdW5jdGlvbiBlKGEpe3JldHVybiBhLmlzKFxcXCJpbnB1dCwgdGV4dGFyZWFcXFwiKSYmZygpLGIuZXZlbnRzLmRpc2FibGVCbHVyKCksYS5mb2N1cygpLCEwfWZ1bmN0aW9uIGYoYSxjKXt2YXIgZD1hLmZpbmQoXFxcImlucHV0LCB0ZXh0YXJlYSwgYnV0dG9uLCBzZWxlY3RcXFwiKS5maWx0ZXIoXFxcIjp2aXNpYmxlXFxcIikubm90KFxcXCI6ZGlzYWJsZWRcXFwiKS5maWx0ZXIoYz9cXFwiOmxhc3RcXFwiOlxcXCI6Zmlyc3RcXFwiKTtpZihkLmxlbmd0aClyZXR1cm4gZShkKTtpZihiLnNoYXJlZC53aXRoX2tiKXt2YXIgZj1hLmZpbmQoXFxcIi5mci1hY3RpdmUtaXRlbTp2aXNpYmxlOmZpcnN0XFxcIik7aWYoZi5sZW5ndGgpcmV0dXJuIGUoZik7dmFyIGc9YS5maW5kKFxcXCJbdGFiSW5kZXhdOnZpc2libGU6Zmlyc3RcXFwiKTtpZihnLmxlbmd0aClyZXR1cm4gZShnKX19ZnVuY3Rpb24gZygpezA9PT1iLiRlbC5maW5kKFxcXCIuZnItbWFya2VyXFxcIikubGVuZ3RoJiZiLmNvcmUuaGFzRm9jdXMoKSYmYi5zZWxlY3Rpb24uc2F2ZSgpfWZ1bmN0aW9uIGgoYSl7YS4kZWwuZmluZChcXFwiLmZyLW1hcmtlclxcXCIpLmxlbmd0aCYmKGEuZXZlbnRzLmRpc2FibGVCbHVyKCksYS5zZWxlY3Rpb24ucmVzdG9yZSgpLGEuZXZlbnRzLmVuYWJsZUJsdXIoKSl9ZnVuY3Rpb24gaShhKXt2YXIgYz1hLmNoaWxkcmVuKCkubm90KFxcXCIuZnItYnV0dG9uc1xcXCIpO2MuZGF0YShcXFwibW91c2VlbnRlci1ldmVudC1zZXRcXFwiKXx8KGIuZXZlbnRzLiRvbihjLFxcXCJtb3VzZWVudGVyXFxcIixcXFwiW3RhYkluZGV4XVxcXCIsZnVuY3Rpb24oZCl7dmFyIGU9YS5kYXRhKFxcXCJpbnN0YW5jZVxcXCIpfHxiO2lmKCFFKXJldHVybiBkLnN0b3BQcm9wYWdhdGlvbigpLHZvaWQgZC5wcmV2ZW50RGVmYXVsdCgpO3ZhciBmPWMuZmluZChcXFwiOmZvY3VzOmZpcnN0XFxcIik7Zi5sZW5ndGgmJiFmLmlzKFxcXCJpbnB1dCwgYnV0dG9uXFxcIikmJihlLmV2ZW50cy5kaXNhYmxlQmx1cigpLGYuYmx1cigpLGUuZXZlbnRzLmRpc2FibGVCbHVyKCksZS5ldmVudHMuZm9jdXMoKSl9KSxjLmRhdGEoXFxcIm1vdXNlZW50ZXItZXZlbnQtc2V0XFxcIiwhMCkpLCFmKGMpJiZiLnNoYXJlZC53aXRoX2tiJiZkKGEuZmluZChcXFwiLmZyLWJ1dHRvbnNcXFwiKSl9ZnVuY3Rpb24gaigpe3ZhciBhPWIucG9wdXBzLmFyZVZpc2libGUoKTtpZihhKXt2YXIgYz1hLmZpbmQoXFxcIi5mci1idXR0b25zXFxcIik7cmV0dXJuIGMuZmluZChcXFwiYnV0dG9uOmZvY3VzLCAuZnItZ3JvdXAgc3Bhbjpmb2N1c1xcXCIpLmxlbmd0aD8hZChhLmRhdGEoXFxcImluc3RhbmNlXFxcIikuJHRiKTohZChjKX1yZXR1cm4hZChiLiR0Yil9ZnVuY3Rpb24gaygpe3ZhciBhPW51bGw7cmV0dXJuIGIuc2hhcmVkLiRmX2VsLmlzKFxcXCIuZnItZHJvcGRvd24uZnItYWN0aXZlXFxcIik/YT1iLnNoYXJlZC4kZl9lbDpiLnNoYXJlZC4kZl9lbC5jbG9zZXN0KFxcXCIuZnItZHJvcGRvd24tbWVudVxcXCIpLnByZXYoKS5pcyhcXFwiLmZyLWRyb3Bkb3duLmZyLWFjdGl2ZVxcXCIpJiYoYT1iLnNoYXJlZC4kZl9lbC5jbG9zZXN0KFxcXCIuZnItZHJvcGRvd24tbWVudVxcXCIpLnByZXYoKSksYX1mdW5jdGlvbiBsKGUsZyxoKXtpZihiLnNoYXJlZC4kZl9lbCl7dmFyIGk9aygpO2kmJihiLmJ1dHRvbi5jbGljayhpKSxiLnNoYXJlZC4kZl9lbD1pKTt2YXIgaj1lLmZpbmQoXFxcImJ1dHRvbjp2aXNpYmxlOm5vdCguZnItZGlzYWJsZWQpLCAuZnItZ3JvdXAgc3Bhbi5mci1jb21tYW5kOnZpc2libGVcXFwiKSxsPWouaW5kZXgoYi5zaGFyZWQuJGZfZWwpO2lmKDA9PWwmJiFofHxsPT1qLmxlbmd0aC0xJiZoKXt2YXIgbTtpZihnKXtpZihlLnBhcmVudCgpLmlzKFxcXCIuZnItcG9wdXBcXFwiKSl7dmFyIG49ZS5wYXJlbnQoKS5jaGlsZHJlbigpLm5vdChcXFwiLmZyLWJ1dHRvbnNcXFwiKTttPSFmKG4sIWgpfW09PT0hMSYmKGIuc2hhcmVkLiRmX2VsPW51bGwpfWcmJm09PT0hMXx8ZChlLCFoKX1lbHNlIGMoYShqLmdldChsKyhoPzE6LTEpKSkpO3JldHVybiExfX1mdW5jdGlvbiBtKGEsYil7cmV0dXJuIGwoYSxiLCEwKX1mdW5jdGlvbiBuKGEsYil7cmV0dXJuIGwoYSxiKX1mdW5jdGlvbiBvKGEpe2lmKGIuc2hhcmVkLiRmX2VsKXtpZihiLnNoYXJlZC4kZl9lbC5pcyhcXFwiLmZyLWRyb3Bkb3duLmZyLWFjdGl2ZVxcXCIpKXt2YXIgZDtyZXR1cm4gZD1hP2Iuc2hhcmVkLiRmX2VsLm5leHQoKS5maW5kKFxcXCIuZnItY29tbWFuZDpub3QoLmZyLWRpc2FibGVkKVxcXCIpLmZpcnN0KCk6Yi5zaGFyZWQuJGZfZWwubmV4dCgpLmZpbmQoXFxcIi5mci1jb21tYW5kOm5vdCguZnItZGlzYWJsZWQpXFxcIikubGFzdCgpLGMoZCksITF9aWYoYi5zaGFyZWQuJGZfZWwuaXMoXFxcImEuZnItY29tbWFuZFxcXCIpKXt2YXIgZDtyZXR1cm4gZD1hP2Iuc2hhcmVkLiRmX2VsLmNsb3Nlc3QoXFxcImxpXFxcIikubmV4dEFsbChcXFwiOnZpc2libGU6Zmlyc3RcXFwiKS5maW5kKFxcXCIuZnItY29tbWFuZDpub3QoLmZyLWRpc2FibGVkKVxcXCIpLmZpcnN0KCk6Yi5zaGFyZWQuJGZfZWwuY2xvc2VzdChcXFwibGlcXFwiKS5wcmV2QWxsKFxcXCI6dmlzaWJsZTpmaXJzdFxcXCIpLmZpbmQoXFxcIi5mci1jb21tYW5kOm5vdCguZnItZGlzYWJsZWQpXFxcIikuZmlyc3QoKSxkLmxlbmd0aHx8KGQ9YT9iLnNoYXJlZC4kZl9lbC5jbG9zZXN0KFxcXCIuZnItZHJvcGRvd24tbWVudVxcXCIpLmZpbmQoXFxcIi5mci1jb21tYW5kOm5vdCguZnItZGlzYWJsZWQpXFxcIikuZmlyc3QoKTpiLnNoYXJlZC4kZl9lbC5jbG9zZXN0KFxcXCIuZnItZHJvcGRvd24tbWVudVxcXCIpLmZpbmQoXFxcIi5mci1jb21tYW5kOm5vdCguZnItZGlzYWJsZWQpXFxcIikubGFzdCgpKSxjKGQpLCExfX19ZnVuY3Rpb24gcCgpe3JldHVybiBiLnNoYXJlZC4kZl9lbCYmYi5zaGFyZWQuJGZfZWwuaXMoXFxcIi5mci1kcm9wZG93bjpub3QoLmZyLWFjdGl2ZSlcXFwiKT9yKCk6byghMCl9ZnVuY3Rpb24gcSgpe3JldHVybiBvKCl9ZnVuY3Rpb24gcigpe2lmKGIuc2hhcmVkLiRmX2VsKXtpZihiLnNoYXJlZC4kZl9lbC5oYXNDbGFzcyhcXFwiZnItZHJvcGRvd25cXFwiKSliLmJ1dHRvbi5jbGljayhiLnNoYXJlZC4kZl9lbCk7ZWxzZSBpZihiLnNoYXJlZC4kZl9lbC5pcyhcXFwiYnV0dG9uLmZyLWJhY2tcXFwiKSl7Yi5vcHRzLnRvb2xiYXJJbmxpbmUmJihiLmV2ZW50cy5kaXNhYmxlQmx1cigpLGIuZXZlbnRzLmZvY3VzKCkpO3ZhciBhPWIucG9wdXBzLmFyZVZpc2libGUoYik7YSYmKGIuc2hhcmVkLndpdGhfa2I9ITEpLGIuYnV0dG9uLmNsaWNrKGIuc2hhcmVkLiRmX2VsKSx5KGEpfWVsc2V7aWYoYi5ldmVudHMuZGlzYWJsZUJsdXIoKSxiLmJ1dHRvbi5jbGljayhiLnNoYXJlZC4kZl9lbCksYi5zaGFyZWQuJGZfZWwuYXR0cihcXFwiZGF0YS1wb3B1cFxcXCIpKXt2YXIgYz1iLnBvcHVwcy5hcmVWaXNpYmxlKGIpO2MmJmMuZGF0YShcXFwicG9wdXAtYnV0dG9uXFxcIixiLnNoYXJlZC4kZl9lbCl9ZWxzZSBpZihiLnNoYXJlZC4kZl9lbC5hdHRyKFxcXCJkYXRhLW1vZGFsXFxcIikpe3ZhciBkPWIubW9kYWxzLmFyZVZpc2libGUoYik7ZCYmZC5kYXRhKFxcXCJtb2RhbC1idXR0b25cXFwiLGIuc2hhcmVkLiRmX2VsKX1iLnNoYXJlZC4kZl9lbD1udWxsfXJldHVybiExfX1mdW5jdGlvbiBzKCl7Yi5zaGFyZWQuJGZfZWwmJihiLmV2ZW50cy5kaXNhYmxlQmx1cigpLGIuc2hhcmVkLiRmX2VsLmJsdXIoKSxiLnNoYXJlZC4kZl9lbD1udWxsKSxiLmV2ZW50cy5kaXNhYmxlQmx1cigpLGIuZXZlbnRzLmZvY3VzKCl9ZnVuY3Rpb24gdChhKXtpZihiLnNoYXJlZC4kZl9lbCl7dmFyIGQ9aygpO3JldHVybiBkPyhiLmJ1dHRvbi5jbGljayhkKSxjKGQpKTphLnBhcmVudCgpLmZpbmQoXFxcIi5mci1iYWNrOnZpc2libGVcXFwiKS5sZW5ndGg/KGIuc2hhcmVkLndpdGhfa2I9ITEsYi5vcHRzLnRvb2xiYXJJbmxpbmUmJihiLmV2ZW50cy5kaXNhYmxlQmx1cigpLGIuZXZlbnRzLmZvY3VzKCkpLGIuYnV0dG9uLmV4ZWMoYS5wYXJlbnQoKS5maW5kKFxcXCIuZnItYmFjazp2aXNpYmxlOmZpcnN0XFxcIikpLHkoYS5wYXJlbnQoKSkpOmIuc2hhcmVkLiRmX2VsLmlzKFxcXCJidXR0b24sIC5mci1ncm91cCBzcGFuXFxcIikmJihhLnBhcmVudCgpLmlzKFxcXCIuZnItcG9wdXBcXFwiKT8oaChiKSxiLnNoYXJlZC4kZl9lbD1udWxsLGIuZXZlbnRzLnRyaWdnZXIoXFxcInRvb2xiYXIuZXNjXFxcIikhPT0hMSYmKGIucG9wdXBzLmhpZGUoYS5wYXJlbnQoKSksYi5vcHRzLnRvb2xiYXJJbmxpbmUmJmIudG9vbGJhci5zaG93SW5saW5lKG51bGwsITApLHkoYS5wYXJlbnQoKSkpKTpzKCkpLCExfX1mdW5jdGlvbiB1KGMsZCl7dmFyIGU9bmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKFxcXCJNYWMgT1MgWFxcXCIpIT0tMT9jLm1ldGFLZXk6Yy5jdHJsS2V5LGY9Yy53aGljaCxnPSExO3JldHVybiBmIT1hLkZFLktFWUNPREUuVEFCfHxlfHxjLnNoaWZ0S2V5fHxjLmFsdEtleT9mIT1hLkZFLktFWUNPREUuQVJST1dfUklHSFR8fGV8fGMuc2hpZnRLZXl8fGMuYWx0S2V5P2YhPWEuRkUuS0VZQ09ERS5UQUJ8fGV8fCFjLnNoaWZ0S2V5fHxjLmFsdEtleT9mIT1hLkZFLktFWUNPREUuQVJST1dfTEVGVHx8ZXx8Yy5zaGlmdEtleXx8Yy5hbHRLZXk/ZiE9YS5GRS5LRVlDT0RFLkFSUk9XX1VQfHxlfHxjLnNoaWZ0S2V5fHxjLmFsdEtleT9mIT1hLkZFLktFWUNPREUuQVJST1dfRE9XTnx8ZXx8Yy5zaGlmdEtleXx8Yy5hbHRLZXk/ZiE9YS5GRS5LRVlDT0RFLkVOVEVSfHxlfHxjLnNoaWZ0S2V5fHxjLmFsdEtleT9mIT1hLkZFLktFWUNPREUuRVNDfHxlfHxjLnNoaWZ0S2V5fHxjLmFsdEtleT9mIT1hLkZFLktFWUNPREUuRjEwfHxlfHxjLnNoaWZ0S2V5fHwhYy5hbHRLZXl8fChnPWooKSk6Zz10KGQpOmc9cigpOmc9cCgpOmc9cSgpOmc9bihkKTpnPW4oZCwhMCk6Zz1tKGQpOmc9bShkLCEwKSxiLnNoYXJlZC4kZl9lbHx8dm9pZCAwIT09Z3x8KGc9ITApLCFnJiZiLmtleXMuaXNCcm93c2VyQWN0aW9uKGMpJiYoZz0hMCksISFnfHwoYy5wcmV2ZW50RGVmYXVsdCgpLGMuc3RvcFByb3BhZ2F0aW9uKCksITEpfWZ1bmN0aW9uIHYoYyl7YyYmYy5sZW5ndGgmJihiLmV2ZW50cy4kb24oYyxcXFwia2V5ZG93blxcXCIsZnVuY3Rpb24oZCl7aWYoIWEoZC50YXJnZXQpLmlzKFxcXCJhLmZyLWNvbW1hbmQsIGJ1dHRvbi5mci1jb21tYW5kLCAuZnItZ3JvdXAgc3Bhbi5mci1jb21tYW5kXFxcIikpcmV0dXJuITA7dmFyIGU9Yy5wYXJlbnRzKFxcXCIuZnItcG9wdXBcXFwiKS5kYXRhKFxcXCJpbnN0YW5jZVxcXCIpfHxjLmRhdGEoXFxcImluc3RhbmNlXFxcIil8fGI7Yi5zaGFyZWQud2l0aF9rYj0hMDt2YXIgZj1lLmFjY2Vzc2liaWxpdHkuZXhlYyhkLGMpO3JldHVybiBiLnNoYXJlZC53aXRoX2tiPSExLGZ9LCEwKSxiLmV2ZW50cy4kb24oYyxcXFwibW91c2VlbnRlclxcXCIsXFxcIlt0YWJJbmRleF1cXFwiLGZ1bmN0aW9uKGQpe3ZhciBlPWMucGFyZW50cyhcXFwiLmZyLXBvcHVwXFxcIikuZGF0YShcXFwiaW5zdGFuY2VcXFwiKXx8Yy5kYXRhKFxcXCJpbnN0YW5jZVxcXCIpfHxiO2lmKCFFKXJldHVybiBkLnN0b3BQcm9wYWdhdGlvbigpLHZvaWQgZC5wcmV2ZW50RGVmYXVsdCgpO3ZhciBmPWEoZC5jdXJyZW50VGFyZ2V0KTtlLnNoYXJlZC4kZl9lbCYmZS5zaGFyZWQuJGZfZWwubm90KGYpJiZlLmFjY2Vzc2liaWxpdHkuZm9jdXNFZGl0b3IoKX0sITApKX1mdW5jdGlvbiB3KGEpe3ZhciBjPWIucG9wdXBzLmdldChhKSxkPXgoYSk7dihjLmZpbmQoXFxcIi5mci1idXR0b25zXFxcIikpLGIuZXZlbnRzLiRvbihjLFxcXCJtb3VzZWVudGVyXFxcIixcXFwidGFiSW5kZXhcXFwiLGQuX3RpTW91c2VlbnRlciwhMCksYi5ldmVudHMuJG9uKGMuY2hpbGRyZW4oKS5ub3QoXFxcIi5mci1idXR0b25zXFxcIiksXFxcImtleWRvd25cXFwiLFxcXCJbdGFiSW5kZXhdXFxcIixkLl90aUtleWRvd24sITApLGIucG9wdXBzLm9uSGlkZShhLGZ1bmN0aW9uKCl7aChjLmRhdGEoXFxcImluc3RhbmNlXFxcIil8fGIpfSksYi5wb3B1cHMub25TaG93KGEsZnVuY3Rpb24oKXtFPSExLHNldFRpbWVvdXQoZnVuY3Rpb24oKXtFPSEwfSwwKX0pfWZ1bmN0aW9uIHgoYyl7dmFyIGU9Yi5wb3B1cHMuZ2V0KGMpO3JldHVybntfdGlLZXlkb3duOmZ1bmN0aW9uKGcpe3ZhciBpPWUuZGF0YShcXFwiaW5zdGFuY2VcXFwiKXx8YjtpZihpLmV2ZW50cy50cmlnZ2VyKFxcXCJwb3B1cC50YWJcXFwiLFtnXSk9PT0hMSlyZXR1cm4hMTt2YXIgaj1nLndoaWNoLGs9ZS5maW5kKFxcXCI6Zm9jdXM6Zmlyc3RcXFwiKTtpZihhLkZFLktFWUNPREUuVEFCPT1qKXtnLnByZXZlbnREZWZhdWx0KCk7dmFyIGw9ZS5jaGlsZHJlbigpLm5vdChcXFwiLmZyLWJ1dHRvbnNcXFwiKSxtPWwuZmluZChcXFwiaW5wdXQsIHRleHRhcmVhLCBidXR0b24sIHNlbGVjdFxcXCIpLmZpbHRlcihcXFwiOnZpc2libGVcXFwiKS5ub3QoXFxcIi5mci1uby10b3VjaCBpbnB1dCwgLmZyLW5vLXRvdWNoIHRleHRhcmVhLCAuZnItbm8tdG91Y2ggYnV0dG9uLCAuZnItbm8tdG91Y2ggc2VsZWN0LCA6ZGlzYWJsZWRcXFwiKS50b0FycmF5KCksbj1tLmluZGV4T2YodGhpcykrKGcuc2hpZnRLZXk/LTE6MSk7aWYoMDw9biYmbjxtLmxlbmd0aClyZXR1cm4gaS5ldmVudHMuZGlzYWJsZUJsdXIoKSxhKG1bbl0pLmZvY3VzKCksZy5zdG9wUHJvcGFnYXRpb24oKSwhMTt2YXIgbz1lLmZpbmQoXFxcIi5mci1idXR0b25zXFxcIik7aWYoby5sZW5ndGgmJmQobywhIWcuc2hpZnRLZXkpKXJldHVybiBnLnN0b3BQcm9wYWdhdGlvbigpLCExO2lmKGYobCkpcmV0dXJuIGcuc3RvcFByb3BhZ2F0aW9uKCksITF9ZWxzZXtpZihhLkZFLktFWUNPREUuRU5URVIhPWopcmV0dXJuIGEuRkUuS0VZQ09ERS5FU0M9PWo/KGcucHJldmVudERlZmF1bHQoKSxnLnN0b3BQcm9wYWdhdGlvbigpLGgoaSksaS5wb3B1cHMuaXNWaXNpYmxlKGMpJiZlLmZpbmQoXFxcIi5mci1iYWNrOnZpc2libGVcXFwiKS5sZW5ndGg/KGkub3B0cy50b29sYmFySW5saW5lJiYoaS5ldmVudHMuZGlzYWJsZUJsdXIoKSxpLmV2ZW50cy5mb2N1cygpKSxpLmJ1dHRvbi5leGVjKGUuZmluZChcXFwiLmZyLWJhY2s6dmlzaWJsZTpmaXJzdFxcXCIpKSx5KGUpKTppLnBvcHVwcy5pc1Zpc2libGUoYykmJmUuZmluZChcXFwiLmZyLWRpc21pc3M6dmlzaWJsZVxcXCIpLmxlbmd0aD9pLmJ1dHRvbi5leGVjKGUuZmluZChcXFwiLmZyLWRpc21pc3M6dmlzaWJsZTpmaXJzdFxcXCIpKTooaS5wb3B1cHMuaGlkZShjKSxpLm9wdHMudG9vbGJhcklubGluZSYmaS50b29sYmFyLnNob3dJbmxpbmUobnVsbCwhMCkseShlKSksITEpOmEuRkUuS0VZQ09ERS5TUEFDRT09aiYmKGsuaXMoXFxcIi5mci1zdWJtaXRcXFwiKXx8ay5pcyhcXFwiLmZyLWRpc21pc3NcXFwiKSk/KGcucHJldmVudERlZmF1bHQoKSxnLnN0b3BQcm9wYWdhdGlvbigpLGkuZXZlbnRzLmRpc2FibGVCbHVyKCksaS5idXR0b24uZXhlYyhrKSwhMCk6aS5rZXlzLmlzQnJvd3NlckFjdGlvbihnKT92b2lkIGcuc3RvcFByb3BhZ2F0aW9uKCk6ay5pcyhcXFwiaW5wdXRbdHlwZT10ZXh0XSwgdGV4dGFyZWFcXFwiKT92b2lkIGcuc3RvcFByb3BhZ2F0aW9uKCk6YS5GRS5LRVlDT0RFLlNQQUNFPT1qJiYoay5pcyhcXFwiLmZyLWxpbmstYXR0clxcXCIpfHxrLmlzKFxcXCJpbnB1dFt0eXBlPWZpbGVdXFxcIikpP3ZvaWQgZy5zdG9wUHJvcGFnYXRpb24oKTooZy5zdG9wUHJvcGFnYXRpb24oKSxnLnByZXZlbnREZWZhdWx0KCksITEpO3ZhciBwPW51bGw7ZS5maW5kKFxcXCIuZnItc3VibWl0OnZpc2libGVcXFwiKS5sZW5ndGg+MD9wPWUuZmluZChcXFwiLmZyLXN1Ym1pdDp2aXNpYmxlOmZpcnN0XFxcIik6ZS5maW5kKFxcXCIuZnItZGlzbWlzczp2aXNpYmxlXFxcIikubGVuZ3RoJiYocD1lLmZpbmQoXFxcIi5mci1kaXNtaXNzOnZpc2libGU6Zmlyc3RcXFwiKSkscCYmKGcucHJldmVudERlZmF1bHQoKSxnLnN0b3BQcm9wYWdhdGlvbigpLGkuZXZlbnRzLmRpc2FibGVCbHVyKCksaS5idXR0b24uZXhlYyhwKSl9fSxfdGlNb3VzZWVudGVyOmZ1bmN0aW9uKGEpe3ZhciBjPWUuZGF0YShcXFwiaW5zdGFuY2VcXFwiKXx8YjtCKGMpfX19ZnVuY3Rpb24geShhKXt2YXIgYj1hLmRhdGEoXFxcInBvcHVwLWJ1dHRvblxcXCIpO2ImJnNldFRpbWVvdXQoZnVuY3Rpb24oKXtjKGIpLGEuZGF0YShcXFwicG9wdXAtYnV0dG9uXFxcIixudWxsKX0sMCl9ZnVuY3Rpb24geihhKXt2YXIgYj1hLmRhdGEoXFxcIm1vZGFsLWJ1dHRvblxcXCIpO2ImJnNldFRpbWVvdXQoZnVuY3Rpb24oKXtjKGIpLGEuZGF0YShcXFwibW9kYWwtYnV0dG9uXFxcIixudWxsKX0sMCl9ZnVuY3Rpb24gQSgpe3JldHVybiBudWxsIT1iLnNoYXJlZC4kZl9lbH1mdW5jdGlvbiBCKGEpe3ZhciBjPWIucG9wdXBzLmFyZVZpc2libGUoYSk7YyYmYy5kYXRhKFxcXCJwb3B1cC1idXR0b25cXFwiLG51bGwpfWZ1bmN0aW9uIEMoYyl7dmFyIGQ9bmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKFxcXCJNYWMgT1MgWFxcXCIpIT0tMT9jLm1ldGFLZXk6Yy5jdHJsS2V5LGU9Yy53aGljaDtpZihlPT1hLkZFLktFWUNPREUuRjEwJiYhZCYmIWMuc2hpZnRLZXkmJmMuYWx0S2V5KXtiLnNoYXJlZC53aXRoX2tiPSEwO3ZhciBnPWIucG9wdXBzLmFyZVZpc2libGUoYiksaD0hMTtyZXR1cm4gZyYmKGg9ZihnLmNoaWxkcmVuKCkubm90KFxcXCIuZnItYnV0dG9uc1xcXCIpKSksaHx8aigpLGIuc2hhcmVkLndpdGhfa2I9ITEsYy5wcmV2ZW50RGVmYXVsdCgpLGMuc3RvcFByb3BhZ2F0aW9uKCksITF9cmV0dXJuITB9ZnVuY3Rpb24gRCgpe2IuJHdwP2IuZXZlbnRzLm9uKFxcXCJrZXlkb3duXFxcIixDLCEwKTpiLmV2ZW50cy4kb24oYi4kd2luLFxcXCJrZXlkb3duXFxcIixDLCEwKSxiLmV2ZW50cy5vbihcXFwibW91c2Vkb3duXFxcIixmdW5jdGlvbihhKXtCKGIpLGIuc2hhcmVkLiRmX2VsJiYoaChiKSxhLnN0b3BQcm9wYWdhdGlvbigpLGIuZXZlbnRzLmRpc2FibGVCbHVyKCksYi5zaGFyZWQuJGZfZWw9bnVsbCl9LCEwKSxiLmV2ZW50cy5vbihcXFwiYmx1clxcXCIsZnVuY3Rpb24oYSl7Yi5zaGFyZWQuJGZfZWw9bnVsbCxCKGIpfSwhMCl9dmFyIEU9ITA7cmV0dXJue19pbml0OkQscmVnaXN0ZXJQb3B1cDp3LHJlZ2lzdGVyVG9vbGJhcjp2LGZvY3VzVG9vbGJhckVsZW1lbnQ6Yyxmb2N1c1Rvb2xiYXI6ZCxmb2N1c0NvbnRlbnQ6Zixmb2N1c1BvcHVwOmksZm9jdXNFZGl0b3I6cyxmb2N1c1BvcHVwQnV0dG9uOnksZm9jdXNNb2RhbEJ1dHRvbjp6LGhhc0ZvY3VzOkEsZXhlYzp1LHNhdmVTZWxlY3Rpb246ZyxyZXN0b3JlU2VsZWN0aW9uOmh9fSxhLkZFLk1PRFVMRVMuZm9ybWF0PWZ1bmN0aW9uKGIpe2Z1bmN0aW9uIGMoYSxiKXt2YXIgYz1cXFwiPFxcXCIrYTtmb3IodmFyIGQgaW4gYiliLmhhc093blByb3BlcnR5KGQpJiYoYys9XFxcIiBcXFwiK2QrJz1cXFwiJytiW2RdKydcXFwiJyk7cmV0dXJuIGMrPVxcXCI+XFxcIn1mdW5jdGlvbiBkKGEpe3JldHVyblxcXCI8L1xcXCIrYStcXFwiPlxcXCJ9ZnVuY3Rpb24gZShhLGIpe3ZhciBjPWE7Zm9yKHZhciBkIGluIGIpYi5oYXNPd25Qcm9wZXJ0eShkKSYmKGErPVxcXCJpZFxcXCI9PWQ/XFxcIiNcXFwiK2JbZF06XFxcImNsYXNzXFxcIj09ZD9cXFwiLlxcXCIrYltkXTpcXFwiW1xcXCIrZCsnPVxcXCInK2JbZF0rJ1xcXCJdJyk7cmV0dXJuIGN9ZnVuY3Rpb24gZihhLGIpe3JldHVybiEoIWF8fGEubm9kZVR5cGUhPU5vZGUuRUxFTUVOVF9OT0RFKSYmKGEubWF0Y2hlc3x8YS5tYXRjaGVzU2VsZWN0b3J8fGEubXNNYXRjaGVzU2VsZWN0b3J8fGEubW96TWF0Y2hlc1NlbGVjdG9yfHxhLndlYmtpdE1hdGNoZXNTZWxlY3Rvcnx8YS5vTWF0Y2hlc1NlbGVjdG9yKS5jYWxsKGEsYil9ZnVuY3Rpb24gZyhkLGUsZil7aWYoZCl7aWYoYi5ub2RlLmlzQmxvY2soZCkpcmV0dXJuIGcoZC5maXJzdENoaWxkLGUsZiksITE7Zm9yKHZhciBoPWEoYyhlLGYpKS5pbnNlcnRCZWZvcmUoZCksaT1kO2kmJiFhKGkpLmlzKFxcXCIuZnItbWFya2VyXFxcIikmJjA9PWEoaSkuZmluZChcXFwiLmZyLW1hcmtlclxcXCIpLmxlbmd0aDspe3ZhciBqPWk7aT1pLm5leHRTaWJsaW5nLGguYXBwZW5kKGopfWlmKGkpYShpKS5maW5kKFxcXCIuZnItbWFya2VyXFxcIikubGVuZ3RoJiZnKGkuZmlyc3RDaGlsZCxlLGYpO2Vsc2V7Zm9yKHZhciBrPWguZ2V0KDApLnBhcmVudE5vZGU7ayYmIWsubmV4dFNpYmxpbmcmJiFiLm5vZGUuaXNFbGVtZW50KGspOylrPWsucGFyZW50Tm9kZTtpZihrKXt2YXIgbD1rLm5leHRTaWJsaW5nO2wmJihiLm5vZGUuaXNCbG9jayhsKT9nKGwuZmlyc3RDaGlsZCxlLGYpOmcobCxlLGYpKX19aC5pcyhcXFwiOmVtcHR5XFxcIikmJmgucmVtb3ZlKCl9fWZ1bmN0aW9uIGgoaCxpKXtpZihcXFwidW5kZWZpbmVkXFxcIj09dHlwZW9mIGkmJihpPXt9KSxpLnN0eWxlJiZkZWxldGUgaS5zdHlsZSxiLnNlbGVjdGlvbi5pc0NvbGxhcHNlZCgpKXtiLm1hcmtlcnMuaW5zZXJ0KCk7dmFyIGo9Yi4kZWwuZmluZChcXFwiLmZyLW1hcmtlclxcXCIpO2oucmVwbGFjZVdpdGgoYyhoLGkpK2EuRkUuSU5WSVNJQkxFX1NQQUNFK2EuRkUuTUFSS0VSUytkKGgpKSxiLnNlbGVjdGlvbi5yZXN0b3JlKCl9ZWxzZXtiLnNlbGVjdGlvbi5zYXZlKCk7dmFyIGs9Yi4kZWwuZmluZCgnLmZyLW1hcmtlcltkYXRhLXR5cGU9XFxcInRydWVcXFwiXScpLmdldCgwKS5uZXh0U2libGluZztnKGssaCxpKTt2YXIgbDtkbyBsPWIuJGVsLmZpbmQoZShoLGkpK1xcXCIgPiBcXFwiK2UoaCxpKSksbC5lYWNoKGZ1bmN0aW9uKCl7YSh0aGlzKS5yZXBsYWNlV2l0aCh0aGlzLmlubmVySFRNTCl9KTt3aGlsZShsLmxlbmd0aCk7Yi5lbC5ub3JtYWxpemUoKTtmb3IodmFyIG09Yi5lbC5xdWVyeVNlbGVjdG9yQWxsKFxcXCIuZnItbWFya2VyXFxcIiksbj0wO248bS5sZW5ndGg7bisrKXt2YXIgbz1hKG1bbl0pOzE9PW8uZGF0YShcXFwidHlwZVxcXCIpP2Yoby5nZXQoMCkubmV4dFNpYmxpbmcsZShoLGkpKSYmby5uZXh0KCkucHJlcGVuZChvKTpmKG8uZ2V0KDApLnByZXZpb3VzU2libGluZyxlKGgsaSkpJiZvLnByZXYoKS5hcHBlbmQobyl9Yi5zZWxlY3Rpb24ucmVzdG9yZSgpfX1mdW5jdGlvbiBpKGEsYyxkLGcpe2lmKCFnKXt2YXIgaD0hMTtpZihhLmRhdGEoXFxcInR5cGVcXFwiKT09PSEwKWZvcig7Yi5ub2RlLmlzRmlyc3RTaWJsaW5nKGEuZ2V0KDApKSYmIWEucGFyZW50KCkuaXMoYi4kZWwpOylhLnBhcmVudCgpLmJlZm9yZShhKSxoPSEwO2Vsc2UgaWYoYS5kYXRhKFxcXCJ0eXBlXFxcIik9PT0hMSlmb3IoO2Iubm9kZS5pc0xhc3RTaWJsaW5nKGEuZ2V0KDApKSYmIWEucGFyZW50KCkuaXMoYi4kZWwpOylhLnBhcmVudCgpLmFmdGVyKGEpLGg9ITA7aWYoaClyZXR1cm4hMH1pZihhLnBhcmVudHMoYykubGVuZ3RofHxcXFwidW5kZWZpbmVkXFxcIj09dHlwZW9mIGMpe3ZhciBpPVxcXCJcXFwiLGo9XFxcIlxcXCIsaz1hLnBhcmVudCgpO2lmKGsuaXMoYi4kZWwpfHxiLm5vZGUuaXNCbG9jayhrLmdldCgwKSkpcmV0dXJuITE7Zm9yKDtcXFwidW5kZWZpbmVkXFxcIj09dHlwZW9mIGMmJiFiLm5vZGUuaXNCbG9jayhrLnBhcmVudCgpLmdldCgwKSl8fFxcXCJ1bmRlZmluZWRcXFwiIT10eXBlb2YgYyYmIWYoay5nZXQoMCksZShjLGQpKTspaSs9Yi5ub2RlLmNsb3NlVGFnU3RyaW5nKGsuZ2V0KDApKSxqPWIubm9kZS5vcGVuVGFnU3RyaW5nKGsuZ2V0KDApKStqLGs9ay5wYXJlbnQoKTt2YXIgbD1hLmdldCgwKS5vdXRlckhUTUw7YS5yZXBsYWNlV2l0aCgnPHNwYW4gaWQ9XFxcIm1hcmtcXFwiPjwvc3Bhbj4nKTt2YXIgbT1rLmh0bWwoKS5yZXBsYWNlKC88c3BhbiBpZD1cXFwibWFya1xcXCI+PFxcXFwvc3Bhbj4vLGkrYi5ub2RlLmNsb3NlVGFnU3RyaW5nKGsuZ2V0KDApKStqK2wraStiLm5vZGUub3BlblRhZ1N0cmluZyhrLmdldCgwKSkraik7cmV0dXJuIGsucmVwbGFjZVdpdGgoYi5ub2RlLm9wZW5UYWdTdHJpbmcoay5nZXQoMCkpK20rYi5ub2RlLmNsb3NlVGFnU3RyaW5nKGsuZ2V0KDApKSksITB9cmV0dXJuITF9ZnVuY3Rpb24gaihjLGQsZyxoKXtmb3IodmFyIGk9Yi5ub2RlLmNvbnRlbnRzKGMuZ2V0KDApKSxrPTA7azxpLmxlbmd0aDtrKyspe3ZhciBsPWlba107Yi5ub2RlLmhhc0NsYXNzKGwsXFxcImZyLW1hcmtlclxcXCIpP2Q9KGQrMSklMjpkP2EobCkuZmluZChcXFwiLmZyLW1hcmtlclxcXCIpLmxlbmd0aD4wP2Q9aihhKGwpLGQsZyxoKTooYShhKGwpLmZpbmQoZ3x8XFxcIipcXFwiKS5nZXQoKS5yZXZlcnNlKCkpLmVhY2goZnVuY3Rpb24oKXtiLm5vZGUuaXNCbG9jayh0aGlzKXx8Yi5ub2RlLmlzVm9pZCh0aGlzKXx8YSh0aGlzKS5yZXBsYWNlV2l0aCh0aGlzLmlubmVySFRNTCl9KSxcXFwidW5kZWZpbmVkXFxcIj09dHlwZW9mIGcmJmwubm9kZVR5cGU9PU5vZGUuRUxFTUVOVF9OT0RFJiYhYi5ub2RlLmlzVm9pZChsKSYmIWIubm9kZS5pc0Jsb2NrKGwpfHxmKGwsZShnLGgpKT9hKGwpLnJlcGxhY2VXaXRoKGwuaW5uZXJIVE1MKTpcXFwidW5kZWZpbmVkXFxcIj09dHlwZW9mIGcmJmwubm9kZVR5cGU9PU5vZGUuRUxFTUVOVF9OT0RFJiZiLm5vZGUuaXNCbG9jayhsKSYmYShsKS5yZW1vdmVBdHRyKFxcXCJzdHlsZVxcXCIpKTphKGwpLmZpbmQoXFxcIi5mci1tYXJrZXJcXFwiKS5sZW5ndGg+MCYmKGQ9aihhKGwpLGQsZyxoKSl9cmV0dXJuIGR9ZnVuY3Rpb24gayhjLGQpe1xcXCJ1bmRlZmluZWRcXFwiPT10eXBlb2YgZCYmKGQ9e30pLGQuc3R5bGUmJmRlbGV0ZSBkLnN0eWxlO3ZhciBlPWIuc2VsZWN0aW9uLmlzQ29sbGFwc2VkKCk7Yi5zZWxlY3Rpb24uc2F2ZSgpO2Zvcih2YXIgZj0hMDtmOyl7Zj0hMTtmb3IodmFyIGc9Yi4kZWwuZmluZChcXFwiLmZyLW1hcmtlclxcXCIpLGg9MDtoPGcubGVuZ3RoO2grKylpZihpKGEoZ1toXSksYyxkLGUpKXtmPSEwO2JyZWFrfX1qKGIuJGVsLDAsYyxkKSxlJiZiLiRlbC5maW5kKFxcXCIuZnItbWFya2VyXFxcIikuYmVmb3JlKGEuRkUuSU5WSVNJQkxFX1NQQUNFKS5hZnRlcihhLkZFLklOVklTSUJMRV9TUEFDRSksYi5odG1sLmNsZWFuRW1wdHlUYWdzKCksYi5lbC5ub3JtYWxpemUoKSxiLnNlbGVjdGlvbi5yZXN0b3JlKCl9ZnVuY3Rpb24gbChhLGIpe3EoYSxiKT9rKGEsYik6aChhLGIpfWZ1bmN0aW9uIG0oYixjKXt2YXIgZD1hKGIpO2QuY3NzKGMsXFxcIlxcXCIpLFxcXCJcXFwiPT09ZC5hdHRyKFxcXCJzdHlsZVxcXCIpJiZkLnJlcGxhY2VXaXRoKGQuaHRtbCgpKX1mdW5jdGlvbiBuKGIsYyl7cmV0dXJuIDA9PT1hKGIpLmF0dHIoXFxcInN0eWxlXFxcIikuaW5kZXhPZihjK1xcXCI6XFxcIil8fGEoYikuYXR0cihcXFwic3R5bGVcXFwiKS5pbmRleE9mKFxcXCI7XFxcIitjK1xcXCI6XFxcIik+PTB8fGEoYikuYXR0cihcXFwic3R5bGVcXFwiKS5pbmRleE9mKFxcXCI7IFxcXCIrYytcXFwiOlxcXCIpPj0wfWZ1bmN0aW9uIG8oYyxkKXtpZihiLnNlbGVjdGlvbi5pc0NvbGxhcHNlZCgpKXtiLm1hcmtlcnMuaW5zZXJ0KCk7dmFyIGU9Yi4kZWwuZmluZChcXFwiLmZyLW1hcmtlclxcXCIpLGY9ZS5wYXJlbnQoKTtpZihiLm5vZGUub3BlblRhZ1N0cmluZyhmLmdldCgwKSk9PSc8c3BhbiBzdHlsZT1cXFwiJytjK1xcXCI6IFxcXCIrZi5jc3MoYykrJztcXFwiPicpaWYoYi5ub2RlLmlzRW1wdHkoZi5nZXQoMCkpKWYucmVwbGFjZVdpdGgoJzxzcGFuIHN0eWxlPVxcXCInK2MrXFxcIjogXFxcIitkKyc7XFxcIj4nK2EuRkUuSU5WSVNJQkxFX1NQQUNFK2EuRkUuTUFSS0VSUytcXFwiPC9zcGFuPlxcXCIpO2Vsc2V7dmFyIGg9e307aFtjXT1kLGkoZSxcXFwic3BhblxcXCIsaCwhMCksZT1iLiRlbC5maW5kKFxcXCIuZnItbWFya2VyXFxcIiksZS5yZXBsYWNlV2l0aCgnPHNwYW4gc3R5bGU9XFxcIicrYytcXFwiOiBcXFwiK2QrJztcXFwiPicrYS5GRS5JTlZJU0lCTEVfU1BBQ0UrYS5GRS5NQVJLRVJTK1xcXCI8L3NwYW4+XFxcIil9ZWxzZSBiLm5vZGUuaXNFbXB0eShmLmdldCgwKSkmJmYuaXMoXFxcInNwYW5cXFwiKT8oZS5yZXBsYWNlV2l0aChhLkZFLk1BUktFUlMpLGYuY3NzKGMsZCkpOmUucmVwbGFjZVdpdGgoJzxzcGFuIHN0eWxlPVxcXCInK2MrXFxcIjogXFxcIitkKyc7XFxcIj4nK2EuRkUuSU5WSVNJQkxFX1NQQUNFK2EuRkUuTUFSS0VSUytcXFwiPC9zcGFuPlxcXCIpO2Iuc2VsZWN0aW9uLnJlc3RvcmUoKX1lbHNle2Iuc2VsZWN0aW9uLnNhdmUoKTtmb3IodmFyIGo9Yi4kZWwuZmluZChcXFwiLmZyLW1hcmtlclxcXCIpLGs9MDtrPGoubGVuZ3RoO2srKyl7dmFyIGU9YShqW2tdKTtpZihlLmRhdGEoXFxcInR5cGVcXFwiKT09PSEwKWZvcig7Yi5ub2RlLmlzRmlyc3RTaWJsaW5nKGUuZ2V0KDApKSYmIWUucGFyZW50KCkuaXMoYi4kZWwpOyllLnBhcmVudCgpLmJlZm9yZShlKTtlbHNlIGZvcig7Yi5ub2RlLmlzTGFzdFNpYmxpbmcoZS5nZXQoMCkpJiYhZS5wYXJlbnQoKS5pcyhiLiRlbCk7KWUucGFyZW50KCkuYWZ0ZXIoZSl9dmFyIGw9Yi4kZWwuZmluZCgnLmZyLW1hcmtlcltkYXRhLXR5cGU9XFxcInRydWVcXFwiXScpLmdldCgwKS5uZXh0U2libGluZyxvPXtjbGFzczpcXFwiZnItdW5wcm9jZXNzZWRcXFwifTtmb3IoZCYmKG8uc3R5bGU9YytcXFwiOiBcXFwiK2QrXFxcIjtcXFwiKSxnKGwsXFxcInNwYW5cXFwiLG8pLGIuJGVsLmZpbmQoXFxcIi5mci1tYXJrZXIgKyAuZnItdW5wcm9jZXNzZWRcXFwiKS5lYWNoKGZ1bmN0aW9uKCl7YSh0aGlzKS5wcmVwZW5kKGEodGhpcykucHJldigpKX0pLGIuJGVsLmZpbmQoXFxcIi5mci11bnByb2Nlc3NlZCArIC5mci1tYXJrZXJcXFwiKS5lYWNoKGZ1bmN0aW9uKCl7YSh0aGlzKS5wcmV2KCkuYXBwZW5kKHRoaXMpfSk7Yi4kZWwuZmluZChcXFwic3Bhbi5mci11bnByb2Nlc3NlZFxcXCIpLmxlbmd0aD4wOyl7dmFyIHA9Yi4kZWwuZmluZChcXFwic3Bhbi5mci11bnByb2Nlc3NlZDpmaXJzdFxcXCIpLnJlbW92ZUNsYXNzKFxcXCJmci11bnByb2Nlc3NlZFxcXCIpO2lmKHAucGFyZW50KCkuZ2V0KDApLm5vcm1hbGl6ZSgpLHAucGFyZW50KCkuaXMoXFxcInNwYW5cXFwiKSYmMT09cC5wYXJlbnQoKS5nZXQoMCkuY2hpbGROb2Rlcy5sZW5ndGgpe3AucGFyZW50KCkuY3NzKGMsZCk7dmFyIHE9cDtwPXAucGFyZW50KCkscS5yZXBsYWNlV2l0aChxLmh0bWwoKSl9Zm9yKHZhciByPXAuZmluZChcXFwic3BhblxcXCIpLGs9ci5sZW5ndGgtMTtrPj0wO2stLSltKHJba10sYyk7dmFyIHM9cC5wYXJlbnRzVW50aWwoYi4kZWwsXFxcInNwYW5bc3R5bGVdXFxcIikuZmlsdGVyKGZ1bmN0aW9uKCl7cmV0dXJuIG4odGhpcyxjKX0pO2lmKHMubGVuZ3RoKXt2YXIgdD1cXFwiXFxcIix1PVxcXCJcXFwiLHY9XFxcIlxcXCIsdz1cXFwiXFxcIix4PXAuZ2V0KDApO2RvIHg9eC5wYXJlbnROb2RlLGEoeCkuYWRkQ2xhc3MoXFxcImZyLXNwbGl0XFxcIiksdCs9Yi5ub2RlLmNsb3NlVGFnU3RyaW5nKHgpLHU9Yi5ub2RlLm9wZW5UYWdTdHJpbmcoYSh4KS5jbG9uZSgpLmFkZENsYXNzKFxcXCJmci1zcGxpdFxcXCIpLmdldCgwKSkrdSxzLmdldCgwKSE9eCYmKHYrPWIubm9kZS5jbG9zZVRhZ1N0cmluZyh4KSx3PWIubm9kZS5vcGVuVGFnU3RyaW5nKGEoeCkuY2xvbmUoKS5hZGRDbGFzcyhcXFwiZnItc3BsaXRcXFwiKS5nZXQoMCkpK3cpO3doaWxlKHMuZ2V0KDApIT14KTt2YXIgeT10K2Iubm9kZS5vcGVuVGFnU3RyaW5nKGEocy5nZXQoMCkpLmNsb25lKCkuY3NzKGMsZHx8XFxcIlxcXCIpLmdldCgwKSkrdytwLmNzcyhjLFxcXCJcXFwiKS5nZXQoMCkub3V0ZXJIVE1MK3YrXFxcIjwvc3Bhbj5cXFwiK3U7cC5yZXBsYWNlV2l0aCgnPHNwYW4gaWQ9XFxcImZyLWJyZWFrXFxcIj48L3NwYW4+Jyk7dmFyIHo9cy5nZXQoMCkub3V0ZXJIVE1MO2Eocy5nZXQoMCkpLnJlcGxhY2VXaXRoKHoucmVwbGFjZSgvPHNwYW4gaWQ9XFxcImZyLWJyZWFrXFxcIj48XFxcXC9zcGFuPi9nLHkpKX19Zm9yKDtiLiRlbC5maW5kKFxcXCIuZnItc3BsaXQ6ZW1wdHlcXFwiKS5sZW5ndGg+MDspYi4kZWwuZmluZChcXFwiLmZyLXNwbGl0OmVtcHR5XFxcIikucmVtb3ZlKCk7Yi4kZWwuZmluZChcXFwiLmZyLXNwbGl0XFxcIikucmVtb3ZlQ2xhc3MoXFxcImZyLXNwbGl0XFxcIiksYi4kZWwuZmluZCgnc3BhbltzdHlsZT1cXFwiXFxcIl0nKS5yZW1vdmVBdHRyKFxcXCJzdHlsZVxcXCIpLGIuJGVsLmZpbmQoJ3NwYW5bY2xhc3M9XFxcIlxcXCJdJykucmVtb3ZlQXR0cihcXFwiY2xhc3NcXFwiKSxiLmh0bWwuY2xlYW5FbXB0eVRhZ3MoKSxhKGIuJGVsLmZpbmQoXFxcInNwYW5cXFwiKS5nZXQoKS5yZXZlcnNlKCkpLmVhY2goZnVuY3Rpb24oKXt0aGlzLmF0dHJpYnV0ZXMmJjAhPXRoaXMuYXR0cmlidXRlcy5sZW5ndGh8fGEodGhpcykucmVwbGFjZVdpdGgodGhpcy5pbm5lckhUTUwpfSksYi5lbC5ub3JtYWxpemUoKTt2YXIgQT1iLiRlbC5maW5kKFxcXCJzcGFuW3N0eWxlXSArIHNwYW5bc3R5bGVdXFxcIik7Zm9yKGs9MDtrPEEubGVuZ3RoO2srKyl7dmFyIEI9YShBW2tdKSxDPWEoQVtrXSkucHJldigpO0IuZ2V0KDApLnByZXZpb3VzU2libGluZz09Qy5nZXQoMCkmJmIubm9kZS5vcGVuVGFnU3RyaW5nKEIuZ2V0KDApKT09Yi5ub2RlLm9wZW5UYWdTdHJpbmcoQy5nZXQoMCkpJiYoQi5wcmVwZW5kKEMuaHRtbCgpKSxDLnJlbW92ZSgpKX1iLmVsLm5vcm1hbGl6ZSgpLGIuc2VsZWN0aW9uLnJlc3RvcmUoKX19ZnVuY3Rpb24gcChhKXtvKGEsbnVsbCl9ZnVuY3Rpb24gcShhLGMpe1xcXCJ1bmRlZmluZWRcXFwiPT10eXBlb2YgYyYmKGM9e30pLGMuc3R5bGUmJmRlbGV0ZSBjLnN0eWxlO3ZhciBkPWIuc2VsZWN0aW9uLnJhbmdlcygwKSxnPWQuc3RhcnRDb250YWluZXI7Zy5ub2RlVHlwZT09Tm9kZS5FTEVNRU5UX05PREUmJmcuY2hpbGROb2Rlcy5sZW5ndGg+MCYmZy5jaGlsZE5vZGVzW2Quc3RhcnRPZmZzZXRdJiYoZz1nLmNoaWxkTm9kZXNbZC5zdGFydE9mZnNldF0pO2Zvcih2YXIgaD1nO2gmJmgubm9kZVR5cGU9PU5vZGUuRUxFTUVOVF9OT0RFJiYhZihoLGUoYSxjKSk7KWg9aC5maXJzdENoaWxkO2lmKGgmJmgubm9kZVR5cGU9PU5vZGUuRUxFTUVOVF9OT0RFJiZmKGgsZShhLGMpKSlyZXR1cm4hMDt2YXIgaT1nO2ZvcihpJiZpLm5vZGVUeXBlIT1Ob2RlLkVMRU1FTlRfTk9ERSYmKGk9aS5wYXJlbnROb2RlKTtpJiZpLm5vZGVUeXBlPT1Ob2RlLkVMRU1FTlRfTk9ERSYmaSE9Yi5lbCYmIWYoaSxlKGEsYykpOylpPWkucGFyZW50Tm9kZTtyZXR1cm4hKCFpfHxpLm5vZGVUeXBlIT1Ob2RlLkVMRU1FTlRfTk9ERXx8aT09Yi5lbHx8IWYoaSxlKGEsYykpKX1yZXR1cm57aXM6cSx0b2dnbGU6bCxhcHBseTpoLHJlbW92ZTprLGFwcGx5U3R5bGU6byxyZW1vdmVTdHlsZTpwfX0sYS5GRS5DT01NQU5EUz17Ym9sZDp7dGl0bGU6XFxcIkJvbGRcXFwiLHRvZ2dsZTohMCxyZWZyZXNoOmZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMuZm9ybWF0LmlzKFxcXCJzdHJvbmdcXFwiKTthLnRvZ2dsZUNsYXNzKFxcXCJmci1hY3RpdmVcXFwiLGIpLmF0dHIoXFxcImFyaWEtcHJlc3NlZFxcXCIsYil9fSxpdGFsaWM6e3RpdGxlOlxcXCJJdGFsaWNcXFwiLHRvZ2dsZTohMCxyZWZyZXNoOmZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMuZm9ybWF0LmlzKFxcXCJlbVxcXCIpO2EudG9nZ2xlQ2xhc3MoXFxcImZyLWFjdGl2ZVxcXCIsYikuYXR0cihcXFwiYXJpYS1wcmVzc2VkXFxcIixiKX19LHVuZGVybGluZTp7dGl0bGU6XFxcIlVuZGVybGluZVxcXCIsdG9nZ2xlOiEwLHJlZnJlc2g6ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5mb3JtYXQuaXMoXFxcInVcXFwiKTthLnRvZ2dsZUNsYXNzKFxcXCJmci1hY3RpdmVcXFwiLGIpLmF0dHIoXFxcImFyaWEtcHJlc3NlZFxcXCIsYil9fSxzdHJpa2VUaHJvdWdoOnt0aXRsZTpcXFwiU3RyaWtldGhyb3VnaFxcXCIsdG9nZ2xlOiEwLHJlZnJlc2g6ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5mb3JtYXQuaXMoXFxcInNcXFwiKTthLnRvZ2dsZUNsYXNzKFxcXCJmci1hY3RpdmVcXFwiLGIpLmF0dHIoXFxcImFyaWEtcHJlc3NlZFxcXCIsYil9fSxzdWJzY3JpcHQ6e3RpdGxlOlxcXCJTdWJzY3JpcHRcXFwiLHRvZ2dsZTohMCxyZWZyZXNoOmZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMuZm9ybWF0LmlzKFxcXCJzdWJcXFwiKTthLnRvZ2dsZUNsYXNzKFxcXCJmci1hY3RpdmVcXFwiLGIpLmF0dHIoXFxcImFyaWEtcHJlc3NlZFxcXCIsYil9fSxzdXBlcnNjcmlwdDp7dGl0bGU6XFxcIlN1cGVyc2NyaXB0XFxcIix0b2dnbGU6ITAscmVmcmVzaDpmdW5jdGlvbihhKXt2YXIgYj10aGlzLmZvcm1hdC5pcyhcXFwic3VwXFxcIik7YS50b2dnbGVDbGFzcyhcXFwiZnItYWN0aXZlXFxcIixiKS5hdHRyKFxcXCJhcmlhLXByZXNzZWRcXFwiLGIpfX0sb3V0ZGVudDp7dGl0bGU6XFxcIkRlY3JlYXNlIEluZGVudFxcXCJ9LGluZGVudDp7dGl0bGU6XFxcIkluY3JlYXNlIEluZGVudFxcXCJ9LHVuZG86e3RpdGxlOlxcXCJVbmRvXFxcIix1bmRvOiExLGZvcmNlZFJlZnJlc2g6ITAsZGlzYWJsZWQ6ITB9LHJlZG86e3RpdGxlOlxcXCJSZWRvXFxcIix1bmRvOiExLGZvcmNlZFJlZnJlc2g6ITAsZGlzYWJsZWQ6ITB9LGluc2VydEhSOnt0aXRsZTpcXFwiSW5zZXJ0IEhvcml6b250YWwgTGluZVxcXCJ9LGNsZWFyRm9ybWF0dGluZzp7dGl0bGU6XFxcIkNsZWFyIEZvcm1hdHRpbmdcXFwifSxzZWxlY3RBbGw6e3RpdGxlOlxcXCJTZWxlY3QgQWxsXFxcIix1bmRvOiExfX0sYS5GRS5SZWdpc3RlckNvbW1hbmQ9ZnVuY3Rpb24oYixjKXthLkZFLkNPTU1BTkRTW2JdPWN9LGEuRkUuTU9EVUxFUy5jb21tYW5kcz1mdW5jdGlvbihiKXtmdW5jdGlvbiBjKGMsZCl7aWYoYi5ldmVudHMudHJpZ2dlcihcXFwiY29tbWFuZHMuYmVmb3JlXFxcIixhLm1lcmdlKFtjXSxkfHxbXSkpIT09ITEpe3ZhciBlPWEuRkUuQ09NTUFORFNbY10mJmEuRkUuQ09NTUFORFNbY10uY2FsbGJhY2t8fGhbY10sZj0hMCxnPSExO2EuRkUuQ09NTUFORFNbY10mJihcXFwidW5kZWZpbmVkXFxcIiE9dHlwZW9mIGEuRkUuQ09NTUFORFNbY10uZm9jdXMmJihmPWEuRkUuQ09NTUFORFNbY10uZm9jdXMpLFxcXCJ1bmRlZmluZWRcXFwiIT10eXBlb2YgYS5GRS5DT01NQU5EU1tjXS5hY2Nlc3NpYmlsaXR5Rm9jdXMmJihnPWEuRkUuQ09NTUFORFNbY10uYWNjZXNzaWJpbGl0eUZvY3VzKSksKCFiLmNvcmUuaGFzRm9jdXMoKSYmZiYmIWIucG9wdXBzLmFyZVZpc2libGUoKXx8IWIuY29yZS5oYXNGb2N1cygpJiZnJiZiLmFjY2Vzc2liaWxpdHkuaGFzRm9jdXMoKSkmJmIuZXZlbnRzLmZvY3VzKCEwKSxhLkZFLkNPTU1BTkRTW2NdJiZhLkZFLkNPTU1BTkRTW2NdLnVuZG8hPT0hMSYmKGIuJGVsLmZpbmQoXFxcIi5mci1tYXJrZXJcXFwiKS5sZW5ndGgmJihiLmV2ZW50cy5kaXNhYmxlQmx1cigpLGIuc2VsZWN0aW9uLnJlc3RvcmUoKSksYi51bmRvLnNhdmVTdGVwKCkpLGUmJmUuYXBwbHkoYixhLm1lcmdlKFtjXSxkfHxbXSkpLGIuZXZlbnRzLnRyaWdnZXIoXFxcImNvbW1hbmRzLmFmdGVyXFxcIixhLm1lcmdlKFtjXSxkfHxbXSkpLGEuRkUuQ09NTUFORFNbY10mJmEuRkUuQ09NTUFORFNbY10udW5kbyE9PSExJiZiLnVuZG8uc2F2ZVN0ZXAoKX19ZnVuY3Rpb24gZChhLGMpe2IuZm9ybWF0LnRvZ2dsZShjKX1mdW5jdGlvbiBlKGMpe2Iuc2VsZWN0aW9uLnNhdmUoKSxiLmh0bWwud3JhcCghMCwhMCwhMCwhMCksYi5zZWxlY3Rpb24ucmVzdG9yZSgpO2Zvcih2YXIgZD1iLnNlbGVjdGlvbi5ibG9ja3MoKSxlPTA7ZTxkLmxlbmd0aDtlKyspaWYoXFxcIkxJXFxcIiE9ZFtlXS50YWdOYW1lJiZcXFwiTElcXFwiIT1kW2VdLnBhcmVudE5vZGUudGFnTmFtZSl7dmFyIGY9YShkW2VdKSxnPVxcXCJydGxcXFwiPT1iLm9wdHMuZGlyZWN0aW9ufHxcXFwicnRsXFxcIj09Zi5jc3MoXFxcImRpcmVjdGlvblxcXCIpP1xcXCJtYXJnaW4tcmlnaHRcXFwiOlxcXCJtYXJnaW4tbGVmdFxcXCIsaD1iLmhlbHBlcnMuZ2V0UFgoZi5jc3MoZykpO2YuY3NzKGcsTWF0aC5tYXgoaCsyMCpjLDApfHxcXFwiXFxcIiksZi5yZW1vdmVDbGFzcyhcXFwiZnItdGVtcC1kaXZcXFwiKX1iLnNlbGVjdGlvbi5zYXZlKCksYi5odG1sLnVud3JhcCgpLGIuc2VsZWN0aW9uLnJlc3RvcmUoKX1mdW5jdGlvbiBmKGEpe3JldHVybiBmdW5jdGlvbigpe2MoYSl9fWZ1bmN0aW9uIGcoKXtiLmV2ZW50cy5vbihcXFwia2V5ZG93blxcXCIsZnVuY3Rpb24oYSl7dmFyIGM9Yi5zZWxlY3Rpb24uZWxlbWVudCgpO2lmKGMmJlxcXCJIUlxcXCI9PWMudGFnTmFtZSYmIWIua2V5cy5pc0Fycm93KGEud2hpY2gpKXJldHVybiBhLnByZXZlbnREZWZhdWx0KCksITF9KSxiLmV2ZW50cy5vbihcXFwia2V5dXBcXFwiLGZ1bmN0aW9uKGMpe3ZhciBkPWIuc2VsZWN0aW9uLmVsZW1lbnQoKTtpZihkJiZcXFwiSFJcXFwiPT1kLnRhZ05hbWUpaWYoYy53aGljaD09YS5GRS5LRVlDT0RFLkFSUk9XX0xFRlR8fGMud2hpY2g9PWEuRkUuS0VZQ09ERS5BUlJPV19VUCl7aWYoZC5wcmV2aW91c1NpYmxpbmcpcmV0dXJuIGIubm9kZS5pc0Jsb2NrKGQucHJldmlvdXNTaWJsaW5nKT9iLnNlbGVjdGlvbi5zZXRBdEVuZChkLnByZXZpb3VzU2libGluZyk6YShkKS5iZWZvcmUoYS5GRS5NQVJLRVJTKSxiLnNlbGVjdGlvbi5yZXN0b3JlKCksITF9ZWxzZSBpZigoYy53aGljaD09YS5GRS5LRVlDT0RFLkFSUk9XX1JJR0hUfHxjLndoaWNoPT1hLkZFLktFWUNPREUuQVJST1dfRE9XTikmJmQubmV4dFNpYmxpbmcpcmV0dXJuIGIubm9kZS5pc0Jsb2NrKGQubmV4dFNpYmxpbmcpP2Iuc2VsZWN0aW9uLnNldEF0U3RhcnQoZC5uZXh0U2libGluZyk6YShkKS5hZnRlcihhLkZFLk1BUktFUlMpLGIuc2VsZWN0aW9uLnJlc3RvcmUoKSwhMX0pLGIuZXZlbnRzLm9uKFxcXCJtb3VzZWRvd25cXFwiLGZ1bmN0aW9uKGEpe2lmKGEudGFyZ2V0JiZcXFwiSFJcXFwiPT1hLnRhcmdldC50YWdOYW1lKXJldHVybiBhLnByZXZlbnREZWZhdWx0KCksYS5zdG9wUHJvcGFnYXRpb24oKSwhMX0pLGIuZXZlbnRzLm9uKFxcXCJtb3VzZXVwXFxcIixmdW5jdGlvbihjKXt2YXIgZD1iLnNlbGVjdGlvbi5lbGVtZW50KCksZT1iLnNlbGVjdGlvbi5lbmRFbGVtZW50KCk7ZD09ZSYmZCYmXFxcIkhSXFxcIj09ZC50YWdOYW1lJiYoZC5uZXh0U2libGluZyYmKGIubm9kZS5pc0Jsb2NrKGQubmV4dFNpYmxpbmcpP2Iuc2VsZWN0aW9uLnNldEF0U3RhcnQoZC5uZXh0U2libGluZyk6YShkKS5hZnRlcihhLkZFLk1BUktFUlMpKSxiLnNlbGVjdGlvbi5yZXN0b3JlKCkpfSl9dmFyIGg9e2JvbGQ6ZnVuY3Rpb24oKXtkKFxcXCJib2xkXFxcIixcXFwic3Ryb25nXFxcIil9LHN1YnNjcmlwdDpmdW5jdGlvbigpe2QoXFxcInN1YnNjcmlwdFxcXCIsXFxcInN1YlxcXCIpfSxzdXBlcnNjcmlwdDpmdW5jdGlvbigpe2QoXFxcInN1cGVyc2NyaXB0XFxcIixcXFwic3VwXFxcIil9LGl0YWxpYzpmdW5jdGlvbigpe2QoXFxcIml0YWxpY1xcXCIsXFxcImVtXFxcIil9LHN0cmlrZVRocm91Z2g6ZnVuY3Rpb24oKXtkKFxcXCJzdHJpa2VUaHJvdWdoXFxcIixcXFwic1xcXCIpfSx1bmRlcmxpbmU6ZnVuY3Rpb24oKXtkKFxcXCJ1bmRlcmxpbmVcXFwiLFxcXCJ1XFxcIil9LHVuZG86ZnVuY3Rpb24oKXtiLnVuZG8ucnVuKCl9LHJlZG86ZnVuY3Rpb24oKXtiLnVuZG8ucmVkbygpfSxpbmRlbnQ6ZnVuY3Rpb24oKXtlKDEpfSxvdXRkZW50OmZ1bmN0aW9uKCl7ZSgtMSl9LHNob3c6ZnVuY3Rpb24oKXtiLm9wdHMudG9vbGJhcklubGluZSYmYi50b29sYmFyLnNob3dJbmxpbmUobnVsbCwhMCl9LGluc2VydEhSOmZ1bmN0aW9uKCl7Yi5zZWxlY3Rpb24ucmVtb3ZlKCk7dmFyIGE9XFxcIlxcXCI7Yi5jb3JlLmlzRW1wdHkoKSYmKGE9XFxcIjxicj5cXFwiLGIuaHRtbC5kZWZhdWx0VGFnKCkmJihhPVxcXCI8XFxcIitiLmh0bWwuZGVmYXVsdFRhZygpK1xcXCI+XFxcIithK1xcXCI8L1xcXCIrYi5odG1sLmRlZmF1bHRUYWcoKStcXFwiPlxcXCIpKSxiLmh0bWwuaW5zZXJ0KCc8aHIgaWQ9XFxcImZyLWp1c3RcXFwiPicrYSk7dmFyIGM9Yi4kZWwuZmluZChcXFwiaHIjZnItanVzdFxcXCIpO2MucmVtb3ZlQXR0cihcXFwiaWRcXFwiKSxiLnNlbGVjdGlvbi5zZXRBZnRlcihjLmdldCgwKSwhMSl8fGIuc2VsZWN0aW9uLnNldEJlZm9yZShjLmdldCgwKSwhMSksYi5zZWxlY3Rpb24ucmVzdG9yZSgpfSxjbGVhckZvcm1hdHRpbmc6ZnVuY3Rpb24oKXtiLmZvcm1hdC5yZW1vdmUoKX0sc2VsZWN0QWxsOmZ1bmN0aW9uKCl7Yi5kb2MuZXhlY0NvbW1hbmQoXFxcInNlbGVjdEFsbFxcXCIsITEsITEpfX0saT17fTtmb3IodmFyIGogaW4gaCloLmhhc093blByb3BlcnR5KGopJiYoaVtqXT1mKGopKTtyZXR1cm4gYS5leHRlbmQoaSx7ZXhlYzpjLF9pbml0Omd9KX0sYS5GRS5NT0RVTEVTLmRhdGE9ZnVuY3Rpb24oYSl7ZnVuY3Rpb24gYihhKXtyZXR1cm4gYX1mdW5jdGlvbiBjKGEpe2lmKCFhKXJldHVybiBhO2Zvcih2YXIgYz1cXFwiXFxcIixmPWIoXFxcImNoYXJDb2RlQXRcXFwiKSxnPWIoXFxcImZyb21DaGFyQ29kZVxcXCIpLGg9bC5pbmRleE9mKGFbMF0pLGk9MTtpPGEubGVuZ3RoLTI7aSsrKXtmb3IodmFyIGo9ZCgrK2gpLGs9YVtmXShpKSxtPVxcXCJcXFwiOy9bMC05LV0vLnRlc3QoYVtpKzFdKTspbSs9YVsrK2ldO209cGFyc2VJbnQobSwxMCl8fDAsaz1lKGssaixtKSxrXj1oLTEmMzEsYys9U3RyaW5nW2ddKGspfXJldHVybiBjfWZ1bmN0aW9uIGQoYSl7Zm9yKHZhciBiPWEudG9TdHJpbmcoKSxjPTAsZD0wO2Q8Yi5sZW5ndGg7ZCsrKWMrPXBhcnNlSW50KGIuY2hhckF0KGQpLDEwKTtyZXR1cm4gYz4xMD9jJTkrMTpjfWZ1bmN0aW9uIGUoYSxiLGMpe2Zvcih2YXIgZD1NYXRoLmFicyhjKTtkLS0gPjA7KWEtPWI7cmV0dXJuIGM8MCYmKGErPTEyMyksYX1mdW5jdGlvbiBmKGEpe3JldHVybiEoIWF8fFxcXCJub25lXFxcIiE9YS5jc3MoXFxcImRpc3BsYXlcXFwiKXx8KGEucmVtb3ZlKCksMCkpfWZ1bmN0aW9uIGcoKXtyZXR1cm4gZihqKXx8ZihrKX1mdW5jdGlvbiBoKCl7cmV0dXJuISFhLiRib3gmJihhLiRib3guYXBwZW5kKG4oYihuKFxcXCJrVERENHNwbUtEMWtsYU1CMUM3QTVSQTFHM1JBMTBZQTVxaHJqdXZubUUxRDNGRDJiY0ctN25vSEU2QjJKQjRDM3hYQThXRjZGLTEwUkcyQzNHM0ItMjF6WkUzQzNIM3hDQTE2TkM0REMxZjFoT0YxTUIzQi0yMXdoelFINVVBMldCMTBrYzFDMkY0RDNYQzJZRDREMUM0RjNHRjJlSjJsZmNELTEzSEYxSUUxVEMxMVRDN1dFNFRBNGQxQTJZQTZYQTRkMUEzeUNHMnFtQi0xM0dGNEExQjFLSDFIRDJmemZiZVFDM1REOVZFNHdkMUgyQTIwQTJCLTIydWpCM25CRzJBMTNqQkMxMEQzQzJIRDVEMUgxS0IxMXVELTE2dVdGMkQ0QTNGLTdDOUQtMTdjMUU0RDRCM2QxRDJDQTZCMkItMTNxbHd6SkYyTkMyQy0xM0UtMTFORDFBM3hxVUE4VUU2YnNyckYtN0MtMjJpYTFEMkNGMkgxRTJha0NEMk9FMUhIMWRsS0E2UEE1amN5ZnpCLTIyY1hCNGYxQzNxdmRpQzRnakdHMkgyZ2tsQzNELTE2d0pDMVVHNGRnYVdFMkQ1RzRnMUkySDNCN3ZrcXJ4SDFIMkVDOUMzRTRnZGd6S0YxT0ExQTVQRjVDNFdXQzNWQTZYQTRlMUUzWUEyWUE1SEU0b0dINEYySDJJQjEwRDNEMk5DNUcxQjFxV0E5UEQ2UEc1ZlFBMTNBMTBYQTRDNEEzZTFIMkJBMTdrQy0yMmNtT0IxbG1vQTJmeWhjcHR3V0EzUkE4QS0xM3hCLTExbmYxSTNmMUI3R0IzYUQzcGF2RkMxMEQ1Z0xGMk9HMUxTQjJEOUU3ZlFDMUY0RjN3cFNCNVhEM05ra2xoaGFFLTExbmFLQTlCbklBNkQxRjViUUEzQTEwYzFRQzZLamt2aXRjMkI2QkUzQUYzRTJEQTZBNEpEMklDMWpnQS02NE1CMTFENkM0PT1cXFwiKSkpKSxqPWEuJGJveC5maW5kKFxcXCI+IGRpdjpsYXN0XFxcIiksaz1qLmZpbmQoXFxcIj4gYVxcXCIpLHZvaWQoXFxcInJ0bFxcXCI9PWEub3B0cy5kaXJlY3Rpb24mJmouY3NzKFxcXCJsZWZ0XFxcIixcXFwiYXV0b1xcXCIpLmNzcyhcXFwicmlnaHRcXFwiLDApKSl9ZnVuY3Rpb24gaSgpe3ZhciBjPWEub3B0cy5rZXl8fFtcXFwiXFxcIl07XFxcInN0cmluZ1xcXCI9PXR5cGVvZiBjJiYoYz1bY10pLGEudWw9ITA7Zm9yKHZhciBkPTA7ZDxjLmxlbmd0aDtkKyspe3ZhciBlPW4oY1tkXSl8fFxcXCJcXFwiO2lmKCEoZSE9PW4oYihuKFxcXCJtY1ZSRG9CMUJHSUxEN1lGZTFCVFhCQTdCNj09XFxcIikpKSYmZS5pbmRleE9mKG0sZS5sZW5ndGgtbS5sZW5ndGgpPDAmJltuKFxcXCI5cXFHLTdhbWpsd3E9PVxcXCIpLG4oXFxcIktBM0IzQzJBNkQxRDVINUgxQTM9PVxcXCIpLG4oXFxcIlF6Ynp2eHlCMnlBLTltPT1cXFwiKSxuKFxcXCJuYWFtbmdpQTNkQS0xNnh0RS0xMUMtOUIxSC04c2M9PVxcXCIpXS5pbmRleE9mKG0pPDApKXthLnVsPSExO2JyZWFrfX1hLnVsPT09ITAmJmgoKSxhLmV2ZW50cy5vbihcXFwiY29udGVudENoYW5nZWRcXFwiLGZ1bmN0aW9uKCl7YS51bD09PSEwJiZnKCkmJmgoKX0pLGEuZXZlbnRzLm9uKFxcXCJkZXN0cm95XFxcIixmdW5jdGlvbigpe2omJmoubGVuZ3RoJiZqLnJlbW92ZSgpfSwhMCl9dmFyIGosayxsPVxcXCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OVxcXCIsbT1mdW5jdGlvbigpe2Zvcih2YXIgYT0wLGI9ZG9jdW1lbnQuZG9tYWluLGM9Yi5zcGxpdChcXFwiLlxcXCIpLGQ9XFxcIl9nZFxcXCIrKG5ldyBEYXRlKS5nZXRUaW1lKCk7YTxjLmxlbmd0aC0xJiZkb2N1bWVudC5jb29raWUuaW5kZXhPZihkK1xcXCI9XFxcIitkKT09LTE7KWI9Yy5zbGljZSgtMS0rK2EpLmpvaW4oXFxcIi5cXFwiKSxkb2N1bWVudC5jb29raWU9ZCtcXFwiPVxcXCIrZCtcXFwiO2RvbWFpbj1cXFwiK2IrXFxcIjtcXFwiO3JldHVybiBkb2N1bWVudC5jb29raWU9ZCtcXFwiPTtleHBpcmVzPVRodSwgMDEgSmFuIDE5NzAgMDA6MDA6MDEgR01UO2RvbWFpbj1cXFwiK2IrXFxcIjtcXFwiLChifHxcXFwiXFxcIikucmVwbGFjZSgvKF5cXFxcLiopfChcXFxcLiokKS9nLFxcXCJcXFwiKX0oKSxuPWIoYyk7cmV0dXJue19pbml0Oml9fSxhLmV4dGVuZChhLkZFLkRFRkFVTFRTLHtwYXN0ZVBsYWluOiExLHBhc3RlRGVuaWVkVGFnczpbXFxcImNvbGdyb3VwXFxcIixcXFwiY29sXFxcIl0scGFzdGVEZW5pZWRBdHRyczpbXFxcImNsYXNzXFxcIixcXFwiaWRcXFwiLFxcXCJzdHlsZVxcXCJdLHBhc3RlQWxsb3dMb2NhbEltYWdlczohMX0pLGEuRkUuTU9EVUxFUy5wYXN0ZT1mdW5jdGlvbihiKXtmdW5jdGlvbiBjKGMpe2EuRkUuY29waWVkX2h0bWw9Yi5odG1sLmdldFNlbGVjdGVkKCksYS5GRS5jb3BpZWRfdGV4dD1hKFxcXCI8ZGl2PlxcXCIpLmh0bWwoYS5GRS5jb3BpZWRfaHRtbCkudGV4dCgpLFxcXCJjdXRcXFwiPT1jLnR5cGUmJihiLnVuZG8uc2F2ZVN0ZXAoKSxzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7Yi5zZWxlY3Rpb24uc2F2ZSgpLGIuaHRtbC53cmFwKCksYi5zZWxlY3Rpb24ucmVzdG9yZSgpLGIuZXZlbnRzLmZvY3VzKCksYi51bmRvLnNhdmVTdGVwKCl9LDApKX1mdW5jdGlvbiBkKGEpe2lmKG8pcmV0dXJuITE7aWYoYS5vcmlnaW5hbEV2ZW50JiYoYT1hLm9yaWdpbmFsRXZlbnQpLGIuZXZlbnRzLnRyaWdnZXIoXFxcInBhc3RlLmJlZm9yZVxcXCIsW2FdKT09PSExKXJldHVybiBhLnByZXZlbnREZWZhdWx0KCksITE7aWYobD1iLiR3aW4uc2Nyb2xsVG9wKCksYSYmYS5jbGlwYm9hcmREYXRhJiZhLmNsaXBib2FyZERhdGEuZ2V0RGF0YSl7dmFyIGM9XFxcIlxcXCIsZD1hLmNsaXBib2FyZERhdGEudHlwZXM7aWYoYi5oZWxwZXJzLmlzQXJyYXkoZCkpZm9yKHZhciBmPTA7ZjxkLmxlbmd0aDtmKyspYys9ZFtmXStcXFwiO1xcXCI7ZWxzZSBjPWQ7aWYobT1cXFwiXFxcIiwvdGV4dFxcXFwvaHRtbC8udGVzdChjKT9tPWEuY2xpcGJvYXJkRGF0YS5nZXREYXRhKFxcXCJ0ZXh0L2h0bWxcXFwiKTovdGV4dFxcXFwvcnRmLy50ZXN0KGMpJiZiLmJyb3dzZXIuc2FmYXJpP209YS5jbGlwYm9hcmREYXRhLmdldERhdGEoXFxcInRleHQvcnRmXFxcIik6L3RleHRcXFxcL3BsYWluLy50ZXN0KGMpJiYhdGhpcy5icm93c2VyLm1vemlsbGEmJihtPWIuaHRtbC5lc2NhcGVFbnRpdGllcyhhLmNsaXBib2FyZERhdGEuZ2V0RGF0YShcXFwidGV4dC9wbGFpblxcXCIpKS5yZXBsYWNlKC9cXFxcbi9nLFxcXCI8YnI+XFxcIikpLFxcXCJcXFwiIT09bSlyZXR1cm4gaCgpLGEucHJldmVudERlZmF1bHQmJihhLnN0b3BQcm9wYWdhdGlvbigpLGEucHJldmVudERlZmF1bHQoKSksITE7bT1udWxsfWUoKX1mdW5jdGlvbiBlKCl7Yi5zZWxlY3Rpb24uc2F2ZSgpLGIuZXZlbnRzLmRpc2FibGVCbHVyKCksbT1udWxsLG4/bi5odG1sKFxcXCJcXFwiKToobj1hKCc8ZGl2IGNvbnRlbnRlZGl0YWJsZT1cXFwidHJ1ZVxcXCIgc3R5bGU9XFxcInBvc2l0aW9uOiBmaXhlZDsgdG9wOiAwOyBsZWZ0OiAtOTk5OXB4OyBoZWlnaHQ6IDEwMCU7IHdpZHRoOiAwOyB3b3JkLWJyZWFrOiBicmVhay1hbGw7IG92ZXJmbG93OmhpZGRlbjsgei1pbmRleDogOTk5OTsgbGluZS1oZWlnaHQ6IDE0MCU7XFxcIiB0YWJJbmRleD1cXFwiLTFcXFwiPjwvZGl2PicpLGIuJGJveC5hZnRlcihuKSxiLmV2ZW50cy5vbihcXFwiZGVzdHJveVxcXCIsZnVuY3Rpb24oKXtuLnJlbW92ZSgpfSkpLG4uZm9jdXMoKSxiLndpbi5zZXRUaW1lb3V0KGgsMSl9ZnVuY3Rpb24gZihhKXthPWEucmVwbGFjZSgvPHAoLio/KWNsYXNzPVxcXCI/Jz9Nc29MaXN0UGFyYWdyYXBoXFxcIj8nPyAoW1xcXFxzXFxcXFNdKj8pPihbXFxcXHNcXFxcU10qPyk8XFxcXC9wPi9naSxcXFwiPHVsPjxsaT4kMzwvbGk+PC91bD5cXFwiKSxhPWEucmVwbGFjZSgvPHAoLio/KWNsYXNzPVxcXCI/Jz9OdW1iZXJlZFRleHRcXFwiPyc/IChbXFxcXHNcXFxcU10qPyk+KFtcXFxcc1xcXFxTXSo/KTxcXFxcL3A+L2dpLFxcXCI8b2w+PGxpPiQzPC9saT48L29sPlxcXCIpLGE9YS5yZXBsYWNlKC88cCguKj8pY2xhc3M9XFxcIj8nP01zb0xpc3RQYXJhZ3JhcGhDeFNwRmlyc3RcXFwiPyc/KFtcXFxcc1xcXFxTXSo/KShsZXZlbFxcXFxkKT8oW1xcXFxzXFxcXFNdKj8pPihbXFxcXHNcXFxcU10qPyk8XFxcXC9wPi9naSxcXFwiPHVsPjxsaSQzPiQ1PC9saT5cXFwiKSxhPWEucmVwbGFjZSgvPHAoLio/KWNsYXNzPVxcXCI/Jz9OdW1iZXJlZFRleHRDeFNwRmlyc3RcXFwiPyc/KFtcXFxcc1xcXFxTXSo/KShsZXZlbFxcXFxkKT8oW1xcXFxzXFxcXFNdKj8pPihbXFxcXHNcXFxcU10qPyk8XFxcXC9wPi9naSxcXFwiPG9sPjxsaSQzPiQ1PC9saT5cXFwiKSxhPWEucmVwbGFjZSgvPHAoLio/KWNsYXNzPVxcXCI/Jz9Nc29MaXN0UGFyYWdyYXBoQ3hTcE1pZGRsZVxcXCI/Jz8oW1xcXFxzXFxcXFNdKj8pKGxldmVsXFxcXGQpPyhbXFxcXHNcXFxcU10qPyk+KFtcXFxcc1xcXFxTXSo/KTxcXFxcL3A+L2dpLFxcXCI8bGkkMz4kNTwvbGk+XFxcIiksYT1hLnJlcGxhY2UoLzxwKC4qPyljbGFzcz1cXFwiPyc/TnVtYmVyZWRUZXh0Q3hTcE1pZGRsZVxcXCI/Jz8oW1xcXFxzXFxcXFNdKj8pKGxldmVsXFxcXGQpPyhbXFxcXHNcXFxcU10qPyk+KFtcXFxcc1xcXFxTXSo/KTxcXFxcL3A+L2dpLFxcXCI8bGkkMz4kNTwvbGk+XFxcIiksYT1hLnJlcGxhY2UoLzxwKC4qPyljbGFzcz1cXFwiPyc/TXNvTGlzdEJ1bGxldFxcXCI/Jz8oW1xcXFxzXFxcXFNdKj8pKGxldmVsXFxcXGQpPyhbXFxcXHNcXFxcU10qPyk+KFtcXFxcc1xcXFxTXSo/KTxcXFxcL3A+L2dpLFxcXCI8bGkkMz4kNTwvbGk+XFxcIiksYT1hLnJlcGxhY2UoLzxwKC4qPyljbGFzcz1cXFwiPyc/TXNvTGlzdFBhcmFncmFwaEN4U3BMYXN0XFxcIj8nPyhbXFxcXHNcXFxcU10qPykobGV2ZWxcXFxcZCk/KFtcXFxcc1xcXFxTXSo/KT4oW1xcXFxzXFxcXFNdKj8pPFxcXFwvcD4vZ2ksXFxcIjxsaSQzPiQ1PC9saT48L3VsPlxcXCIpLGE9YS5yZXBsYWNlKC88cCguKj8pY2xhc3M9XFxcIj8nP051bWJlcmVkVGV4dEN4U3BMYXN0XFxcIj8nPyhbXFxcXHNcXFxcU10qPykobGV2ZWxcXFxcZCk/KFtcXFxcc1xcXFxTXSo/KT4oW1xcXFxzXFxcXFNdKj8pPFxcXFwvcD4vZ2ksXFxcIjxsaSQzPiQ1PC9saT48L29sPlxcXCIpLGE9YS5yZXBsYWNlKC88c3BhbihbXjxdKj8pc3R5bGU9XFxcIj8nP21zby1saXN0Oklnbm9yZVxcXCI/Jz8oW1xcXFxzXFxcXFNdKj8pPihbXFxcXHNcXFxcU10qPyk8c3Bhbi9naSxcXFwiPHNwYW4+PHNwYW5cXFwiKSxhPWEucmVwbGFjZSgvPCEtLVxcXFxbaWYgXFxcXCFzdXBwb3J0TGlzdHNcXFxcXS0tPihbXFxcXHNcXFxcU10qPyk8IS0tXFxcXFtlbmRpZlxcXFxdLS0+L2dpLFxcXCJcXFwiKSxhPWEucmVwbGFjZSgvPCFcXFxcW2lmIFxcXFwhc3VwcG9ydExpc3RzXFxcXF0+KFtcXFxcc1xcXFxTXSo/KTwhXFxcXFtlbmRpZlxcXFxdPi9naSxcXFwiXFxcIiksYT1hLnJlcGxhY2UoLyhcXFxcbnxcXFxccnwgY2xhc3M9KFxcXCIpP01zb1thLXpBLVowLTldKyhcXFwiKT8pL2dpLFxcXCIgXFxcIiksYT1hLnJlcGxhY2UoLzwhLS1bXFxcXHNcXFxcU10qPy0tPi9naSxcXFwiXFxcIiksYT1hLnJlcGxhY2UoLzwoXFxcXC8pKihtZXRhfGxpbmt8c3BhbnxcXFxcXFxcXD94bWw6fHN0MTp8bzp8Zm9udCkoLio/KT4vZ2ksXFxcIlxcXCIpO2Zvcih2YXIgYz1bXFxcInN0eWxlXFxcIixcXFwic2NyaXB0XFxcIixcXFwiYXBwbGV0XFxcIixcXFwiZW1iZWRcXFwiLFxcXCJub2ZyYW1lc1xcXCIsXFxcIm5vc2NyaXB0XFxcIl0sZD0wO2Q8Yy5sZW5ndGg7ZCsrKXt2YXIgZT1uZXcgUmVnRXhwKFxcXCI8XFxcIitjW2RdK1xcXCIuKj9cXFwiK2NbZF0rXFxcIiguKj8pPlxcXCIsXFxcImdpXFxcIik7XFxuYT1hLnJlcGxhY2UoZSxcXFwiXFxcIil9YT1hLnJlcGxhY2UoLyZuYnNwOy9naSxcXFwiIFxcXCIpLGE9YS5yZXBsYWNlKC88dGQoW14+XSopPjxcXFxcL3RkPi9nLFxcXCI8dGQkMT48YnI+PC90ZD5cXFwiKSxhPWEucmVwbGFjZSgvPHRoKFtePl0qKT48XFxcXC90aD4vZyxcXFwiPHRoJDE+PGJyPjwvdGg+XFxcIik7dmFyIGY7ZG8gZj1hLGE9YS5yZXBsYWNlKC88W15cXFxcLz5dW14+XSo+PFxcXFwvW14+XSs+L2dpLFxcXCJcXFwiKTt3aGlsZShhIT1mKTthPWEucmVwbGFjZSgvPGxpbGV2ZWwoW14xXSkoW14+XSopPi9naSwnPGxpIGRhdGEtaW5kZW50PVxcXCJ0cnVlXFxcIiQyPicpLGE9YS5yZXBsYWNlKC88bGlsZXZlbDEoW14+XSopPi9naSxcXFwiPGxpJDE+XFxcIiksYT1iLmNsZWFuLmh0bWwoYSxiLm9wdHMucGFzdGVEZW5pZWRUYWdzLGIub3B0cy5wYXN0ZURlbmllZEF0dHJzKSxhPWEucmVwbGFjZSgvPGE+KC5bXjxdKyk8XFxcXC9hPi9naSxcXFwiJDFcXFwiKSxhPWEucmVwbGFjZSgvPGJyPiAqL2csXFxcIjxicj5cXFwiKTt2YXIgZz1iLmRvYy5jcmVhdGVFbGVtZW50KFxcXCJkaXZcXFwiKTtnLmlubmVySFRNTD1hO2Zvcih2YXIgaD1nLnF1ZXJ5U2VsZWN0b3JBbGwoXFxcImxpW2RhdGEtaW5kZW50XVxcXCIpLGQ9MDtkPGgubGVuZ3RoO2QrKyl7dmFyIGk9aFtkXSxqPWkucHJldmlvdXNFbGVtZW50U2libGluZztpZihqJiZcXFwiTElcXFwiPT1qLnRhZ05hbWUpe3ZhciBrPWoucXVlcnlTZWxlY3RvcihcXFwiOnNjb3BlID4gdWwsIDpzY29wZSA+IG9sXFxcIik7a3x8KGs9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcXFwidWxcXFwiKSxqLmFwcGVuZENoaWxkKGspKSxrLmFwcGVuZENoaWxkKGkpfWVsc2UgaS5yZW1vdmVBdHRyaWJ1dGUoXFxcImRhdGEtaW5kZW50XFxcIil9cmV0dXJuIGIuaHRtbC5jbGVhbkJsYW5rU3BhY2VzKGcpLGE9Zy5pbm5lckhUTUx9ZnVuY3Rpb24gZyhhKXt2YXIgYz1iLmRvYy5jcmVhdGVFbGVtZW50KFxcXCJkaXZcXFwiKTtjLmlubmVySFRNTD1hO2Zvcih2YXIgZD1jLnF1ZXJ5U2VsZWN0b3JBbGwoXFxcInAsIGRpdiwgaDEsIGgyLCBoMywgaDQsIGg1LCBoNiwgcHJlLCBibG9ja3F1b3RlXFxcIiksZT0wO2U8ZC5sZW5ndGg7ZSsrKXt2YXIgZj1kW2VdO2Yub3V0ZXJIVE1MPVxcXCI8XFxcIisoYi5odG1sLmRlZmF1bHRUYWcoKXx8XFxcIkRJVlxcXCIpK1xcXCI+XFxcIitmLmlubmVySFRNTCtcXFwiPC9cXFwiKyhiLmh0bWwuZGVmYXVsdFRhZygpfHxcXFwiRElWXFxcIikrXFxcIj5cXFwifWQ9Yy5xdWVyeVNlbGVjdG9yQWxsKFxcXCIqOm5vdChcXFwiK1xcXCJwLCBkaXYsIGgxLCBoMiwgaDMsIGg0LCBoNSwgaDYsIHByZSwgYmxvY2txdW90ZSwgdWwsIG9sLCBsaSwgdGFibGUsIHRib2R5LCB0aGVhZCwgdHIsIHRkLCBiciwgaW1nXFxcIi5zcGxpdChcXFwiLFxcXCIpLmpvaW4oXFxcIik6bm90KFxcXCIpK1xcXCIpXFxcIik7Zm9yKHZhciBlPWQubGVuZ3RoLTE7ZT49MDtlLS0pe3ZhciBmPWRbZV07Zi5vdXRlckhUTUw9Zi5pbm5lckhUTUx9dmFyIGc9ZnVuY3Rpb24oYSl7Zm9yKHZhciBjPWIubm9kZS5jb250ZW50cyhhKSxkPTA7ZDxjLmxlbmd0aDtkKyspY1tkXS5ub2RlVHlwZSE9Tm9kZS5URVhUX05PREUmJmNbZF0ubm9kZVR5cGUhPU5vZGUuRUxFTUVOVF9OT0RFP2NbZF0ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChjW2RdKTpnKGNbZF0pfTtyZXR1cm4gZyhjKSxjLmlubmVySFRNTH1mdW5jdGlvbiBoKCl7Yi5rZXlzLmZvcmNlVW5kbygpO3ZhciBjPWIuc25hcHNob3QuZ2V0KCk7bnVsbD09PW0mJihtPW4uZ2V0KDApLmlubmVySFRNTCxiLnNlbGVjdGlvbi5yZXN0b3JlKCksYi5ldmVudHMuZW5hYmxlQmx1cigpKTt2YXIgZD1iLmV2ZW50cy5jaGFpblRyaWdnZXIoXFxcInBhc3RlLmJlZm9yZUNsZWFudXBcXFwiLG0pO1xcXCJzdHJpbmdcXFwiPT10eXBlb2YgZCYmKG09ZCk7dmFyIGU9ITE7bS5tYXRjaCgvKGNsYXNzPVxcXFxcXFwiP01zb3xjbGFzcz1cXFxcJz9Nc298c3R5bGU9XFxcXFxcXCJbXlxcXFxcXFwiXSpcXFxcYm1zb1xcXFwtfHN0eWxlPVxcXFwnW15cXFxcJ10qXFxcXGJtc29cXFxcLXx3OldvcmREb2N1bWVudCkvZ2kpJiYoZT0hMCksbS5pbmRleE9mKFxcXCI8Ym9keVxcXCIpPj0wJiYobT1tLnJlcGxhY2UoL1suXFxcXHNcXFxcU1xcXFx3XFxcXFc8Pl0qPGJvZHlbXj5dKj4oWy5cXFxcc1xcXFxTXFxcXHdcXFxcVzw+XSopPFxcXFwvYm9keT5bLlxcXFxzXFxcXFNcXFxcd1xcXFxXPD5dKi9nLFxcXCIkMVxcXCIpKTt2YXIgaD0hMTtpZihtLmluZGV4T2YoJ2lkPVxcXCJkb2NzLWludGVybmFsLWd1aWQnKT49MCYmKG09bS5yZXBsYWNlKC9eLiogaWQ9XFxcImRvY3MtaW50ZXJuYWwtZ3VpZFtePl0qPiguKik8XFxcXC9iPi4qJC8sXFxcIiQxXFxcIiksaD0hMCksZSltPW0ucmVwbGFjZSgvXlxcXFxuKi9nLFxcXCJcXFwiKS5yZXBsYWNlKC9eIC9nLFxcXCJcXFwiKSwwPT09bS5pbmRleE9mKFxcXCI8Y29sZ3JvdXA+XFxcIikmJihtPVxcXCI8dGFibGU+XFxcIittK1xcXCI8L3RhYmxlPlxcXCIpLG09ZihtKSxtPWoobSk7ZWxzZXtiLm9wdHMuaHRtbEFsbG93Q29tbWVudHM9ITEsbT1iLmNsZWFuLmh0bWwobSxiLm9wdHMucGFzdGVEZW5pZWRUYWdzLGIub3B0cy5wYXN0ZURlbmllZEF0dHJzKSxiLm9wdHMuaHRtbEFsbG93Q29tbWVudHM9ITAsbT1qKG0pLG09bS5yZXBsYWNlKC9cXFxccnxcXFxcbnxcXFxcdC9nLFxcXCJcXFwiKTt2YXIgaz1iLmRvYy5jcmVhdGVFbGVtZW50KFxcXCJkaXZcXFwiKTtrLmlubmVySFRNTD1tLGEuRkUuY29waWVkX3RleHQmJmsudGV4dENvbnRlbnQucmVwbGFjZSgvKFxcXFx1MDBBMCkvZ2ksXFxcIiBcXFwiKS5yZXBsYWNlKC9cXFxccnxcXFxcbi9naSxcXFwiXFxcIik9PWEuRkUuY29waWVkX3RleHQucmVwbGFjZSgvKFxcXFx1MDBBMCkvZ2ksXFxcIiBcXFwiKS5yZXBsYWNlKC9cXFxccnxcXFxcbi9naSxcXFwiXFxcIikmJihtPWEuRkUuY29waWVkX2h0bWwpLG09bS5yZXBsYWNlKC9eICovZyxcXFwiXFxcIikucmVwbGFjZSgvICokL2csXFxcIlxcXCIpfWlmKGIub3B0cy5wYXN0ZVBsYWluJiYobT1nKG0pKSxkPWIuZXZlbnRzLmNoYWluVHJpZ2dlcihcXFwicGFzdGUuYWZ0ZXJDbGVhbnVwXFxcIixtKSxcXFwic3RyaW5nXFxcIj09dHlwZW9mIGQmJihtPWQpLFxcXCJcXFwiIT09bSl7dmFyIGw9Yi5vX2RvYy5jcmVhdGVFbGVtZW50KFxcXCJkaXZcXFwiKTtsLmlubmVySFRNTD1tLGIuc3BhY2VzLm5vcm1hbGl6ZShsKTtmb3IodmFyIG89bC5nZXRFbGVtZW50c0J5VGFnTmFtZShcXFwic3BhblxcXCIpLHA9MDtwPG8ubGVuZ3RoO3ArKyl7dmFyIHE9b1twXTswPT09cS5hdHRyaWJ1dGVzLmxlbmd0aCYmKHEub3V0ZXJIVE1MPXEuaW5uZXJIVE1MKX12YXIgcj1sLmNoaWxkcmVuO2lmKDE9PXIubGVuZ3RoJiZbXFxcIk9MXFxcIixcXFwiVUxcXFwiXS5pbmRleE9mKHJbMF0udGFnTmFtZSkmJihyWzBdLm91dGVySFRNTD1yWzBdLmlubmVySFRNTCksIWgpZm9yKHZhciBzPWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXFxcImJyXFxcIikscD0wO3A8cy5sZW5ndGg7cCsrKXt2YXIgdD1zW3BdO2Iubm9kZS5pc0Jsb2NrKHQucHJldmlvdXNTaWJsaW5nKSYmdC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHQpfWlmKGIub3B0cy5lbnRlcj09YS5GRS5FTlRFUl9CUilmb3IodmFyIHU9bC5xdWVyeVNlbGVjdG9yQWxsKFxcXCJwLCBkaXZcXFwiKSxwPTA7cDx1Lmxlbmd0aDtwKyspe3ZhciB2PXVbcF07di5vdXRlckhUTUw9di5pbm5lckhUTUwrKHYubmV4dFNpYmxpbmcmJiFiLm5vZGUuaXNFbXB0eSh2KT9cXFwiPGJyPlxcXCI6XFxcIlxcXCIpfWVsc2UgaWYoYi5vcHRzLmVudGVyPT1hLkZFLkVOVEVSX0RJVilmb3IodmFyIHU9bC5nZXRFbGVtZW50c0J5VGFnTmFtZShcXFwicFxcXCIpLHA9MDtwPHUubGVuZ3RoO3ArKyl7dmFyIHY9dVtwXTt2Lm91dGVySFRNTD1cXFwiPGRpdj5cXFwiK3YuaW5uZXJIVE1MK1xcXCI8L2Rpdj5cXFwifW09bC5pbm5lckhUTUwsYi5odG1sLmluc2VydChtLCEwKX1pKCksYi51bmRvLnNhdmVTdGVwKGMpLGIudW5kby5zYXZlU3RlcCgpfWZ1bmN0aW9uIGkoKXtiLmV2ZW50cy50cmlnZ2VyKFxcXCJwYXN0ZS5hZnRlclxcXCIpfWZ1bmN0aW9uIGooYSl7dmFyIGM9Yi5kb2MuY3JlYXRlRWxlbWVudChcXFwiZGl2XFxcIik7Yy5pbm5lckhUTUw9YTtmb3IodmFyIGQ9Yy5xdWVyeVNlbGVjdG9yQWxsKFxcXCIqOmVtcHR5Om5vdChicik6bm90KGltZyk6bm90KHRkKTpub3QodGgpXFxcIik7ZC5sZW5ndGg7KXtmb3IodmFyIGU9MDtlPGQubGVuZ3RoO2UrKylkW2VdLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZFtlXSk7ZD1jLnF1ZXJ5U2VsZWN0b3JBbGwoXFxcIio6ZW1wdHk6bm90KGJyKTpub3QoaW1nKTpub3QodGQpOm5vdCh0aClcXFwiKX1mb3IodmFyIGY9Yy5xdWVyeVNlbGVjdG9yQWxsKFxcXCI6c2NvcGUgPiBkaXY6bm90KFtzdHlsZV0pLCB0ZCA+IGRpdiwgdGggPiBkaXYsIGxpID4gZGl2XFxcIik7Zi5sZW5ndGg7KXt2YXIgZz1mW2YubGVuZ3RoLTFdO2lmKGIuaHRtbC5kZWZhdWx0VGFnKCkmJlxcXCJkaXZcXFwiIT1iLmh0bWwuZGVmYXVsdFRhZygpKWcub3V0ZXJIVE1MPVxcXCI8XFxcIitiLmh0bWwuZGVmYXVsdFRhZygpK1xcXCI+XFxcIitnLmlubmVySFRNTCtcXFwiPC9cXFwiK2IuaHRtbC5kZWZhdWx0VGFnKCkrXFxcIj5cXFwiO2Vsc2V7dmFyIGg9Zy5xdWVyeVNlbGVjdG9yKFxcXCIqOmxhc3RcXFwiKTtoJiZcXFwiQlJcXFwiPT1oLnRhZ05hbWU/Zy5vdXRlckhUTUw9Zy5pbm5lckhUTUw6Zy5vdXRlckhUTUw9Zy5pbm5lckhUTUwrXFxcIjxicj5cXFwifWY9Yy5xdWVyeVNlbGVjdG9yQWxsKFxcXCI6c2NvcGUgPiBkaXY6bm90KFtzdHlsZV0pLCB0ZCA+IGRpdiwgdGggPiBkaXYsIGxpID4gZGl2XFxcIil9Zm9yKGY9Yy5xdWVyeVNlbGVjdG9yQWxsKFxcXCJkaXY6bm90KFtzdHlsZV0pXFxcIik7Zi5sZW5ndGg7KXtmb3IoZT0wO2U8Zi5sZW5ndGg7ZSsrKXt2YXIgaT1mW2VdLGo9aS5pbm5lckhUTUwucmVwbGFjZSgvXFxcXHUwMDA5L2dpLFxcXCJcXFwiKS50cmltKCk7aS5vdXRlckhUTUw9an1mPWMucXVlcnlTZWxlY3RvckFsbChcXFwiZGl2Om5vdChbc3R5bGVdKVxcXCIpfXJldHVybiBjLmlubmVySFRNTH1mdW5jdGlvbiBrKCl7Yi5ldmVudHMub24oXFxcImNvcHlcXFwiLGMpLGIuZXZlbnRzLm9uKFxcXCJjdXRcXFwiLGMpLGIuZXZlbnRzLm9uKFxcXCJwYXN0ZVxcXCIsZCksYi5icm93c2VyLm1zaWUmJmIuYnJvd3Nlci52ZXJzaW9uPDExJiYoYi5ldmVudHMub24oXFxcIm1vdXNldXBcXFwiLGZ1bmN0aW9uKGEpezI9PWEuYnV0dG9uJiYoc2V0VGltZW91dChmdW5jdGlvbigpe289ITF9LDUwKSxvPSEwKX0sITApLGIuZXZlbnRzLm9uKFxcXCJiZWZvcmVwYXN0ZVxcXCIsZCkpfXZhciBsLG0sbixvPSExO3JldHVybntfaW5pdDprfX0sYS5leHRlbmQoYS5GRS5ERUZBVUxUUyx7c2hvcnRjdXRzRW5hYmxlZDpbXFxcInNob3dcXFwiLFxcXCJib2xkXFxcIixcXFwiaXRhbGljXFxcIixcXFwidW5kZXJsaW5lXFxcIixcXFwic3RyaWtlVGhyb3VnaFxcXCIsXFxcImluZGVudFxcXCIsXFxcIm91dGRlbnRcXFwiLFxcXCJ1bmRvXFxcIixcXFwicmVkb1xcXCJdLHNob3J0Y3V0c0hpbnQ6ITB9KSxhLkZFLlNIT1JUQ1VUU19NQVA9e30sYS5GRS5SZWdpc3RlclNob3J0Y3V0PWZ1bmN0aW9uKGIsYyxkLGUsZixnKXthLkZFLlNIT1JUQ1VUU19NQVBbKGY/XFxcIl5cXFwiOlxcXCJcXFwiKSsoZz9cXFwiQFxcXCI6XFxcIlxcXCIpK2JdPXtjbWQ6Yyx2YWw6ZCxsZXR0ZXI6ZSxzaGlmdDpmLG9wdGlvbjpnfSxhLkZFLkRFRkFVTFRTLnNob3J0Y3V0c0VuYWJsZWQucHVzaChjKX0sYS5GRS5SZWdpc3RlclNob3J0Y3V0KGEuRkUuS0VZQ09ERS5FLFxcXCJzaG93XFxcIixudWxsLFxcXCJFXFxcIiwhMSwhMSksYS5GRS5SZWdpc3RlclNob3J0Y3V0KGEuRkUuS0VZQ09ERS5CLFxcXCJib2xkXFxcIixudWxsLFxcXCJCXFxcIiwhMSwhMSksYS5GRS5SZWdpc3RlclNob3J0Y3V0KGEuRkUuS0VZQ09ERS5JLFxcXCJpdGFsaWNcXFwiLG51bGwsXFxcIklcXFwiLCExLCExKSxhLkZFLlJlZ2lzdGVyU2hvcnRjdXQoYS5GRS5LRVlDT0RFLlUsXFxcInVuZGVybGluZVxcXCIsbnVsbCxcXFwiVVxcXCIsITEsITEpLGEuRkUuUmVnaXN0ZXJTaG9ydGN1dChhLkZFLktFWUNPREUuUyxcXFwic3RyaWtlVGhyb3VnaFxcXCIsbnVsbCxcXFwiU1xcXCIsITEsITEpLGEuRkUuUmVnaXN0ZXJTaG9ydGN1dChhLkZFLktFWUNPREUuQ0xPU0VfU1FVQVJFX0JSQUNLRVQsXFxcImluZGVudFxcXCIsbnVsbCxcXFwiXVxcXCIsITEsITEpLGEuRkUuUmVnaXN0ZXJTaG9ydGN1dChhLkZFLktFWUNPREUuT1BFTl9TUVVBUkVfQlJBQ0tFVCxcXFwib3V0ZGVudFxcXCIsbnVsbCxcXFwiW1xcXCIsITEsITEpLGEuRkUuUmVnaXN0ZXJTaG9ydGN1dChhLkZFLktFWUNPREUuWixcXFwidW5kb1xcXCIsbnVsbCxcXFwiWlxcXCIsITEsITEpLGEuRkUuUmVnaXN0ZXJTaG9ydGN1dChhLkZFLktFWUNPREUuWixcXFwicmVkb1xcXCIsbnVsbCxcXFwiWlxcXCIsITAsITEpLGEuRkUuTU9EVUxFUy5zaG9ydGN1dHM9ZnVuY3Rpb24oYil7ZnVuY3Rpb24gYyhjKXtpZighYi5vcHRzLnNob3J0Y3V0c0hpbnQpcmV0dXJuIG51bGw7aWYoIWYpe2Y9e307Zm9yKHZhciBkIGluIGEuRkUuU0hPUlRDVVRTX01BUClhLkZFLlNIT1JUQ1VUU19NQVAuaGFzT3duUHJvcGVydHkoZCkmJmIub3B0cy5zaG9ydGN1dHNFbmFibGVkLmluZGV4T2YoYS5GRS5TSE9SVENVVFNfTUFQW2RdLmNtZCk+PTAmJihmW2EuRkUuU0hPUlRDVVRTX01BUFtkXS5jbWQrXFxcIi5cXFwiKyhhLkZFLlNIT1JUQ1VUU19NQVBbZF0udmFsfHxcXFwiXFxcIildPXtzaGlmdDphLkZFLlNIT1JUQ1VUU19NQVBbZF0uc2hpZnQsb3B0aW9uOmEuRkUuU0hPUlRDVVRTX01BUFtkXS5vcHRpb24sbGV0dGVyOmEuRkUuU0hPUlRDVVRTX01BUFtkXS5sZXR0ZXJ9KX12YXIgZT1mW2NdO3JldHVybiBlPyhiLmhlbHBlcnMuaXNNYWMoKT9TdHJpbmcuZnJvbUNoYXJDb2RlKDg5ODQpOlxcXCJDdHJsK1xcXCIpKyhlLnNoaWZ0P2IuaGVscGVycy5pc01hYygpP1N0cmluZy5mcm9tQ2hhckNvZGUoODY3OSk6XFxcIlNoaWZ0K1xcXCI6XFxcIlxcXCIpKyhlLm9wdGlvbj9iLmhlbHBlcnMuaXNNYWMoKT9TdHJpbmcuZnJvbUNoYXJDb2RlKDg5OTcpOlxcXCJBbHQrXFxcIjpcXFwiXFxcIikrZS5sZXR0ZXI6bnVsbH1mdW5jdGlvbiBkKGMpe2lmKCFiLmNvcmUuaGFzRm9jdXMoKSlyZXR1cm4hMDt2YXIgZD1jLndoaWNoLGU9bmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKFxcXCJNYWMgT1MgWFxcXCIpIT0tMT9jLm1ldGFLZXk6Yy5jdHJsS2V5O2lmKFxcXCJrZXl1cFxcXCI9PWMudHlwZSYmZyYmZCE9YS5GRS5LRVlDT0RFLk1FVEEpcmV0dXJuIGc9ITEsITE7XFxcImtleWRvd25cXFwiPT1jLnR5cGUmJihnPSExKTt2YXIgZj0oYy5zaGlmdEtleT9cXFwiXlxcXCI6XFxcIlxcXCIpKyhjLmFsdEtleT9cXFwiQFxcXCI6XFxcIlxcXCIpK2Q7aWYoZSYmYS5GRS5TSE9SVENVVFNfTUFQW2ZdKXt2YXIgaD1hLkZFLlNIT1JUQ1VUU19NQVBbZl0uY21kO2lmKGgmJmIub3B0cy5zaG9ydGN1dHNFbmFibGVkLmluZGV4T2YoaCk+PTApe3ZhciBpLGo9YS5GRS5TSE9SVENVVFNfTUFQW2ZdLnZhbDtpZihoJiYhaj9pPWIuJHRiLmZpbmQoJy5mci1jb21tYW5kW2RhdGEtY21kPVxcXCInK2grJ1xcXCJdJyk6aCYmaiYmKGk9Yi4kdGIuZmluZCgnLmZyLWNvbW1hbmRbZGF0YS1jbWQ9XFxcIicraCsnXFxcIl1bZGF0YS1wYXJhbTE9XFxcIicraisnXFxcIl0nKSksaS5sZW5ndGgpcmV0dXJuIGMucHJldmVudERlZmF1bHQoKSxjLnN0b3BQcm9wYWdhdGlvbigpLGkucGFyZW50cyhcXFwiLmZyLXRvb2xiYXJcXFwiKS5kYXRhKFxcXCJpbnN0YW5jZVxcXCIsYiksXFxcImtleWRvd25cXFwiPT1jLnR5cGUmJihiLmJ1dHRvbi5leGVjKGkpLGc9ITApLCExO2lmKGgmJmIuY29tbWFuZHNbaF0pcmV0dXJuIGMucHJldmVudERlZmF1bHQoKSxjLnN0b3BQcm9wYWdhdGlvbigpLFxcXCJrZXlkb3duXFxcIj09Yy50eXBlJiYoYi5jb21tYW5kc1toXSgpLGc9ITApLCExfX19ZnVuY3Rpb24gZSgpe2IuZXZlbnRzLm9uKFxcXCJrZXlkb3duXFxcIixkLCEwKSxiLmV2ZW50cy5vbihcXFwia2V5dXBcXFwiLGQsITApfXZhciBmPW51bGwsZz0hMTtyZXR1cm57X2luaXQ6ZSxnZXQ6Y319LGEuRkUuTU9EVUxFUy5zbmFwc2hvdD1mdW5jdGlvbihhKXtmdW5jdGlvbiBiKGEpe2Zvcih2YXIgYj1hLnBhcmVudE5vZGUuY2hpbGROb2RlcyxjPTAsZD1udWxsLGU9MDtlPGIubGVuZ3RoO2UrKyl7aWYoZCl7dmFyIGY9YltlXS5ub2RlVHlwZT09PU5vZGUuVEVYVF9OT0RFJiZcXFwiXFxcIj09PWJbZV0udGV4dENvbnRlbnQsZz1kLm5vZGVUeXBlPT09Tm9kZS5URVhUX05PREUmJmJbZV0ubm9kZVR5cGU9PT1Ob2RlLlRFWFRfTk9ERTtmfHxnfHxjKyt9aWYoYltlXT09YSlyZXR1cm4gYztkPWJbZV19fWZ1bmN0aW9uIGMoYyl7dmFyIGQ9W107aWYoIWMucGFyZW50Tm9kZSlyZXR1cm5bXTtmb3IoOyFhLm5vZGUuaXNFbGVtZW50KGMpOylkLnB1c2goYihjKSksYz1jLnBhcmVudE5vZGU7cmV0dXJuIGQucmV2ZXJzZSgpfWZ1bmN0aW9uIGQoYSxiKXtmb3IoO2EmJmEubm9kZVR5cGU9PT1Ob2RlLlRFWFRfTk9ERTspe3ZhciBjPWEucHJldmlvdXNTaWJsaW5nO2MmJmMubm9kZVR5cGU9PU5vZGUuVEVYVF9OT0RFJiYoYis9Yy50ZXh0Q29udGVudC5sZW5ndGgpLGE9Y31yZXR1cm4gYn1mdW5jdGlvbiBlKGEpe3JldHVybntzY0xvYzpjKGEuc3RhcnRDb250YWluZXIpLHNjT2Zmc2V0OmQoYS5zdGFydENvbnRhaW5lcixhLnN0YXJ0T2Zmc2V0KSxlY0xvYzpjKGEuZW5kQ29udGFpbmVyKSxlY09mZnNldDpkKGEuZW5kQ29udGFpbmVyLGEuZW5kT2Zmc2V0KX19ZnVuY3Rpb24gZigpe3ZhciBiPXt9O2lmKGEuZXZlbnRzLnRyaWdnZXIoXFxcInNuYXBzaG90LmJlZm9yZVxcXCIpLGIuaHRtbD0oYS4kd3A/YS4kZWwuaHRtbCgpOmEuJG9lbC5nZXQoMCkub3V0ZXJIVE1MKS5yZXBsYWNlKC8gc3R5bGU9XFxcIlxcXCIvZyxcXFwiXFxcIiksYi5yYW5nZXM9W10sYS4kd3AmJmEuc2VsZWN0aW9uLmluRWRpdG9yKCkmJmEuY29yZS5oYXNGb2N1cygpKWZvcih2YXIgYz1hLnNlbGVjdGlvbi5yYW5nZXMoKSxkPTA7ZDxjLmxlbmd0aDtkKyspYi5yYW5nZXMucHVzaChlKGNbZF0pKTtyZXR1cm4gYS5ldmVudHMudHJpZ2dlcihcXFwic25hcHNob3QuYWZ0ZXJcXFwiKSxifWZ1bmN0aW9uIGcoYil7Zm9yKHZhciBjPWEuZWwsZD0wO2Q8Yi5sZW5ndGg7ZCsrKWM9Yy5jaGlsZE5vZGVzW2JbZF1dO3JldHVybiBjfWZ1bmN0aW9uIGgoYixjKXt0cnl7dmFyIGQ9ZyhjLnNjTG9jKSxlPWMuc2NPZmZzZXQsZj1nKGMuZWNMb2MpLGg9Yy5lY09mZnNldCxpPWEuZG9jLmNyZWF0ZVJhbmdlKCk7aS5zZXRTdGFydChkLGUpLGkuc2V0RW5kKGYsaCksYi5hZGRSYW5nZShpKX1jYXRjaChqKXt9fWZ1bmN0aW9uIGkoYil7YS4kZWwuaHRtbCgpIT1iLmh0bWwmJmEuJGVsLmh0bWwoYi5odG1sKTt2YXIgYz1hLnNlbGVjdGlvbi5nZXQoKTthLnNlbGVjdGlvbi5jbGVhcigpLGEuZXZlbnRzLmZvY3VzKCEwKTtmb3IodmFyIGQ9MDtkPGIucmFuZ2VzLmxlbmd0aDtkKyspaChjLGIucmFuZ2VzW2RdKX1mdW5jdGlvbiBqKGIsYyl7cmV0dXJuIGIuaHRtbD09Yy5odG1sJiYoIWEuY29yZS5oYXNGb2N1cygpfHxKU09OLnN0cmluZ2lmeShiLnJhbmdlcyk9PUpTT04uc3RyaW5naWZ5KGMucmFuZ2VzKSl9cmV0dXJue2dldDpmLHJlc3RvcmU6aSxlcXVhbDpqfX0sYS5GRS5NT0RVTEVTLnVuZG89ZnVuY3Rpb24oYSl7ZnVuY3Rpb24gYihiKXt2YXIgYz1iLndoaWNoLGQ9YS5rZXlzLmN0cmxLZXkoYik7ZCYmKDkwPT1jJiZiLnNoaWZ0S2V5JiZiLnByZXZlbnREZWZhdWx0KCksOTA9PWMmJmIucHJldmVudERlZmF1bHQoKSl9ZnVuY3Rpb24gYygpe3JldHVybiEoMD09PWEudW5kb19zdGFjay5sZW5ndGh8fGEudW5kb19pbmRleDw9MSl9ZnVuY3Rpb24gZCgpe3JldHVybiBhLnVuZG9faW5kZXghPWEudW5kb19zdGFjay5sZW5ndGh9ZnVuY3Rpb24gZShiKXtyZXR1cm4hKCFhLnVuZG9fc3RhY2t8fGEudW5kb2luZ3x8YS5lbC5xdWVyeVNlbGVjdG9yKFxcXCIuZnItbWFya2VyXFxcIikpJiZ2b2lkKFxcXCJ1bmRlZmluZWRcXFwiPT10eXBlb2YgYj8oYj1hLnNuYXBzaG90LmdldCgpLGEudW5kb19zdGFja1thLnVuZG9faW5kZXgtMV0mJmEuc25hcHNob3QuZXF1YWwoYS51bmRvX3N0YWNrW2EudW5kb19pbmRleC0xXSxiKXx8KGYoKSxhLnVuZG9fc3RhY2sucHVzaChiKSxhLnVuZG9faW5kZXgrKyxiLmh0bWwhPWwmJihhLmV2ZW50cy50cmlnZ2VyKFxcXCJjb250ZW50Q2hhbmdlZFxcXCIpLGw9Yi5odG1sKSkpOihmKCksYS51bmRvX2luZGV4PjA/YS51bmRvX3N0YWNrW2EudW5kb19pbmRleC0xXT1iOihhLnVuZG9fc3RhY2sucHVzaChiKSxhLnVuZG9faW5kZXgrKykpKX1mdW5jdGlvbiBmKCl7aWYoIWEudW5kb19zdGFja3x8YS51bmRvaW5nKXJldHVybiExO2Zvcig7YS51bmRvX3N0YWNrLmxlbmd0aD5hLnVuZG9faW5kZXg7KWEudW5kb19zdGFjay5wb3AoKX1mdW5jdGlvbiBnKCl7aWYoYS51bmRvX2luZGV4PjEpe2EudW5kb2luZz0hMDt2YXIgYj1hLnVuZG9fc3RhY2tbLS1hLnVuZG9faW5kZXgtMV07Y2xlYXJUaW1lb3V0KGEuX2NvbnRlbnRfY2hhbmdlZF90aW1lciksYS5zbmFwc2hvdC5yZXN0b3JlKGIpLGw9Yi5odG1sLGEucG9wdXBzLmhpZGVBbGwoKSxhLnRvb2xiYXIuZW5hYmxlKCksYS5ldmVudHMudHJpZ2dlcihcXFwiY29udGVudENoYW5nZWRcXFwiKSxhLmV2ZW50cy50cmlnZ2VyKFxcXCJjb21tYW5kcy51bmRvXFxcIiksYS51bmRvaW5nPSExfX1mdW5jdGlvbiBoKCl7aWYoYS51bmRvX2luZGV4PGEudW5kb19zdGFjay5sZW5ndGgpe2EudW5kb2luZz0hMDt2YXIgYj1hLnVuZG9fc3RhY2tbYS51bmRvX2luZGV4KytdO2NsZWFyVGltZW91dChhLl9jb250ZW50X2NoYW5nZWRfdGltZXIpLGEuc25hcHNob3QucmVzdG9yZShiKSxsPWIuaHRtbCxhLnBvcHVwcy5oaWRlQWxsKCksYS50b29sYmFyLmVuYWJsZSgpLGEuZXZlbnRzLnRyaWdnZXIoXFxcImNvbnRlbnRDaGFuZ2VkXFxcIiksYS5ldmVudHMudHJpZ2dlcihcXFwiY29tbWFuZHMucmVkb1xcXCIpLGEudW5kb2luZz0hMX19ZnVuY3Rpb24gaSgpe2EudW5kb19pbmRleD0wLGEudW5kb19zdGFjaz1bXX1mdW5jdGlvbiBqKCl7YS51bmRvX3N0YWNrPVtdfWZ1bmN0aW9uIGsoKXtpKCksYS5ldmVudHMub24oXFxcImluaXRpYWxpemVkXFxcIixmdW5jdGlvbigpe2w9KGEuJHdwP2EuJGVsLmh0bWwoKTphLiRvZWwuZ2V0KDApLm91dGVySFRNTCkucmVwbGFjZSgvIHN0eWxlPVxcXCJcXFwiL2csXFxcIlxcXCIpfSksYS5ldmVudHMub24oXFxcImJsdXJcXFwiLGZ1bmN0aW9uKCl7YS5lbC5xdWVyeVNlbGVjdG9yKFxcXCIuZnItZHJhZ2dpbmdcXFwiKXx8YS51bmRvLnNhdmVTdGVwKCl9KSxhLmV2ZW50cy5vbihcXFwia2V5ZG93blxcXCIsYiksYS5ldmVudHMub24oXFxcImRlc3Ryb3lcXFwiLGopfXZhciBsPW51bGw7cmV0dXJue19pbml0OmsscnVuOmcscmVkbzpoLGNhbkRvOmMsY2FuUmVkbzpkLGRyb3BSZWRvOmYscmVzZXQ6aSxzYXZlU3RlcDplfX0sYS5GRS5JQ09OX0RFRkFVTFRfVEVNUExBVEU9XFxcImZvbnRfYXdlc29tZVxcXCIsYS5GRS5JQ09OX1RFTVBMQVRFUz17Zm9udF9hd2Vzb21lOic8aSBjbGFzcz1cXFwiZmEgZmEtW05BTUVdXFxcIiBhcmlhLWhpZGRlbj1cXFwidHJ1ZVxcXCI+PC9pPicsdGV4dDonPHNwYW4gc3R5bGU9XFxcInRleHQtYWxpZ246IGNlbnRlcjtcXFwiPltOQU1FXTwvc3Bhbj4nLGltYWdlOlxcXCI8aW1nIHNyYz1bU1JDXSBhbHQ9W0FMVF0gLz5cXFwiLHN2ZzonPHN2ZyB2aWV3Qm94PVxcXCIwIDAgMzIgMzJcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+W1BBVEhdPC9zdmc+J30sYS5GRS5JQ09OUz17Ym9sZDp7TkFNRTpcXFwiYm9sZFxcXCJ9LGl0YWxpYzp7TkFNRTpcXFwiaXRhbGljXFxcIn0sdW5kZXJsaW5lOntOQU1FOlxcXCJ1bmRlcmxpbmVcXFwifSxzdHJpa2VUaHJvdWdoOntOQU1FOlxcXCJzdHJpa2V0aHJvdWdoXFxcIn0sc3Vic2NyaXB0OntOQU1FOlxcXCJzdWJzY3JpcHRcXFwifSxzdXBlcnNjcmlwdDp7TkFNRTpcXFwic3VwZXJzY3JpcHRcXFwifSxjb2xvcjp7TkFNRTpcXFwidGludFxcXCJ9LG91dGRlbnQ6e05BTUU6XFxcIm91dGRlbnRcXFwifSxpbmRlbnQ6e05BTUU6XFxcImluZGVudFxcXCJ9LHVuZG86e05BTUU6XFxcInJvdGF0ZS1sZWZ0XFxcIn0scmVkbzp7TkFNRTpcXFwicm90YXRlLXJpZ2h0XFxcIn0saW5zZXJ0SFI6e05BTUU6XFxcIm1pbnVzXFxcIn0sY2xlYXJGb3JtYXR0aW5nOntOQU1FOlxcXCJlcmFzZXJcXFwifSxzZWxlY3RBbGw6e05BTUU6XFxcIm1vdXNlLXBvaW50ZXJcXFwifX0sYS5GRS5EZWZpbmVJY29uVGVtcGxhdGU9ZnVuY3Rpb24oYixjKXthLkZFLklDT05fVEVNUExBVEVTW2JdPWN9LGEuRkUuRGVmaW5lSWNvbj1mdW5jdGlvbihiLGMpe2EuRkUuSUNPTlNbYl09Y30sYS5GRS5NT0RVTEVTLmljb249ZnVuY3Rpb24oYil7ZnVuY3Rpb24gYyhiKXt2YXIgYz1udWxsLGQ9YS5GRS5JQ09OU1tiXTtpZihcXFwidW5kZWZpbmVkXFxcIiE9dHlwZW9mIGQpe3ZhciBlPWQudGVtcGxhdGV8fGEuRkUuSUNPTl9ERUZBVUxUX1RFTVBMQVRFO2UmJihlPWEuRkUuSUNPTl9URU1QTEFURVNbZV0pJiYoYz1lLnJlcGxhY2UoL1xcXFxbKFthLXpBLVpdKilcXFxcXS9nLGZ1bmN0aW9uKGEsYyl7cmV0dXJuXFxcIk5BTUVcXFwiPT1jP2RbY118fGI6ZFtjXX0pKX1yZXR1cm4gY3x8Yn1mdW5jdGlvbiBkKGIpe3ZhciBjPWEuRkUuSUNPTlNbYl0sZD1hLkZFLklDT05fREVGQVVMVF9URU1QTEFURTtpZihcXFwidW5kZWZpbmVkXFxcIiE9dHlwZW9mIGMpe3ZhciBkPWMudGVtcGxhdGV8fGEuRkUuSUNPTl9ERUZBVUxUX1RFTVBMQVRFO3JldHVybiBkfXJldHVybiBkfXJldHVybntjcmVhdGU6YyxnZXRUZW1wbGF0ZTpkfX0sYS5leHRlbmQoYS5GRS5ERUZBVUxUUyx7dG9vbHRpcHM6ITB9KSxhLkZFLk1PRFVMRVMudG9vbHRpcD1mdW5jdGlvbihiKXtmdW5jdGlvbiBjKCl7Yi4kdG9vbHRpcCYmYi4kdG9vbHRpcC5yZW1vdmVDbGFzcyhcXFwiZnItdmlzaWJsZVxcXCIpLmNzcyhcXFwibGVmdFxcXCIsXFxcIi0zMDAwcHhcXFwiKS5jc3MoXFxcInBvc2l0aW9uXFxcIixcXFwiZml4ZWRcXFwiKX1mdW5jdGlvbiBkKGMsZCl7aWYoYy5kYXRhKFxcXCJ0aXRsZVxcXCIpfHxjLmRhdGEoXFxcInRpdGxlXFxcIixjLmF0dHIoXFxcInRpdGxlXFxcIikpLCFjLmRhdGEoXFxcInRpdGxlXFxcIikpcmV0dXJuITE7Yi4kdG9vbHRpcHx8ZigpLGMucmVtb3ZlQXR0cihcXFwidGl0bGVcXFwiKSxiLiR0b29sdGlwLnRleHQoYy5kYXRhKFxcXCJ0aXRsZVxcXCIpKSxiLiR0b29sdGlwLmFkZENsYXNzKFxcXCJmci12aXNpYmxlXFxcIik7dmFyIGU9Yy5vZmZzZXQoKS5sZWZ0KyhjLm91dGVyV2lkdGgoKS1iLiR0b29sdGlwLm91dGVyV2lkdGgoKSkvMjtlPDAmJihlPTApLGUrYi4kdG9vbHRpcC5vdXRlcldpZHRoKCk+YShiLm9fd2luKS53aWR0aCgpJiYoZT1hKGIub193aW4pLndpZHRoKCktYi4kdG9vbHRpcC5vdXRlcldpZHRoKCkpLFxcXCJ1bmRlZmluZWRcXFwiPT10eXBlb2YgZCYmKGQ9Yi5vcHRzLnRvb2xiYXJCb3R0b20pO3ZhciBnPWQ/Yy5vZmZzZXQoKS50b3AtYi4kdG9vbHRpcC5oZWlnaHQoKTpjLm9mZnNldCgpLnRvcCtjLm91dGVySGVpZ2h0KCk7Yi4kdG9vbHRpcC5jc3MoXFxcInBvc2l0aW9uXFxcIixcXFwiXFxcIiksYi4kdG9vbHRpcC5jc3MoXFxcImxlZnRcXFwiLGUpLGIuJHRvb2x0aXAuY3NzKFxcXCJ0b3BcXFwiLE1hdGguY2VpbChnKSksXFxcInN0YXRpY1xcXCIhPWEoYi5vX2RvYykuZmluZChcXFwiYm9keVxcXCIpLmNzcyhcXFwicG9zaXRpb25cXFwiKT8oYi4kdG9vbHRpcC5jc3MoXFxcIm1hcmdpbi1sZWZ0XFxcIiwtYShiLm9fZG9jKS5maW5kKFxcXCJib2R5XFxcIikub2Zmc2V0KCkubGVmdCksYi4kdG9vbHRpcC5jc3MoXFxcIm1hcmdpbi10b3BcXFwiLC1hKGIub19kb2MpLmZpbmQoXFxcImJvZHlcXFwiKS5vZmZzZXQoKS50b3ApKTooYi4kdG9vbHRpcC5jc3MoXFxcIm1hcmdpbi1sZWZ0XFxcIixcXFwiXFxcIiksYi4kdG9vbHRpcC5jc3MoXFxcIm1hcmdpbi10b3BcXFwiLFxcXCJcXFwiKSl9ZnVuY3Rpb24gZShlLGYsZyl7Yi5vcHRzLnRvb2x0aXBzJiYhYi5oZWxwZXJzLmlzTW9iaWxlKCkmJihiLmV2ZW50cy4kb24oZSxcXFwibW91c2VlbnRlclxcXCIsZixmdW5jdGlvbihjKXtiLm5vZGUuaGFzQ2xhc3MoYy5jdXJyZW50VGFyZ2V0LFxcXCJmci1kaXNhYmxlZFxcXCIpfHxiLmVkaXQuaXNEaXNhYmxlZCgpfHxkKGEoYy5jdXJyZW50VGFyZ2V0KSxnKX0sITApLGIuZXZlbnRzLiRvbihlLFxcXCJtb3VzZWxlYXZlIFxcXCIrYi5fbW91c2Vkb3duK1xcXCIgXFxcIitiLl9tb3VzZXVwLGYsZnVuY3Rpb24oYSl7YygpfSwhMCkpfWZ1bmN0aW9uIGYoKXtiLm9wdHMudG9vbHRpcHMmJiFiLmhlbHBlcnMuaXNNb2JpbGUoKSYmKGIuc2hhcmVkLiR0b29sdGlwP2IuJHRvb2x0aXA9Yi5zaGFyZWQuJHRvb2x0aXA6KGIuc2hhcmVkLiR0b29sdGlwPWEoJzxkaXYgY2xhc3M9XFxcImZyLXRvb2x0aXBcXFwiPjwvZGl2PicpLGIuJHRvb2x0aXA9Yi5zaGFyZWQuJHRvb2x0aXAsYi5vcHRzLnRoZW1lJiZiLiR0b29sdGlwLmFkZENsYXNzKGIub3B0cy50aGVtZStcXFwiLXRoZW1lXFxcIiksYShiLm9fZG9jKS5maW5kKFxcXCJib2R5XFxcIikuYXBwZW5kKGIuJHRvb2x0aXApKSxiLmV2ZW50cy5vbihcXFwic2hhcmVkLmRlc3Ryb3lcXFwiLGZ1bmN0aW9uKCl7Yi4kdG9vbHRpcC5odG1sKFxcXCJcXFwiKS5yZW1vdmVEYXRhKCkucmVtb3ZlKCksYi4kdG9vbHRpcD1udWxsfSwhMCkpfXJldHVybntoaWRlOmMsdG86ZCxiaW5kOmV9fSxhLkZFLk1PRFVMRVMuYnV0dG9uPWZ1bmN0aW9uKGIpe2Z1bmN0aW9uIGMoYyl7dmFyIGQ9Yy5uZXh0KCksZT1iLm5vZGUuaGFzQ2xhc3MoYy5nZXQoMCksXFxcImZyLWFjdGl2ZVxcXCIpLGY9KGIuaGVscGVycy5pc01vYmlsZSgpLGEoXFxcIi5mci1kcm9wZG93bi5mci1hY3RpdmVcXFwiKS5ub3QoYykpLGc9Yy5wYXJlbnRzKFxcXCIuZnItdG9vbGJhciwgLmZyLXBvcHVwXFxcIikuZGF0YShcXFwiaW5zdGFuY2VcXFwiKXx8YjtpZihnLmhlbHBlcnMuaXNJT1MoKSYmIWcuZWwucXVlcnlTZWxlY3RvcihcXFwiLmZyLW1hcmtlclxcXCIpJiYoZy5zZWxlY3Rpb24uc2F2ZSgpLGcuc2VsZWN0aW9uLmNsZWFyKCksZy5zZWxlY3Rpb24ucmVzdG9yZSgpKSwhZSl7dmFyIGg9Yy5kYXRhKFxcXCJjbWRcXFwiKTtkLmZpbmQoXFxcIi5mci1jb21tYW5kXFxcIikucmVtb3ZlQ2xhc3MoXFxcImZyLWFjdGl2ZVxcXCIpLmF0dHIoXFxcImFyaWEtc2VsZWN0ZWRcXFwiLCExKSxhLkZFLkNPTU1BTkRTW2hdJiZhLkZFLkNPTU1BTkRTW2hdLnJlZnJlc2hPblNob3cmJmEuRkUuQ09NTUFORFNbaF0ucmVmcmVzaE9uU2hvdy5hcHBseShnLFtjLGRdKSxkLmNzcyhcXFwibGVmdFxcXCIsYy5vZmZzZXQoKS5sZWZ0LWMucGFyZW50KCkub2Zmc2V0KCkubGVmdC0oXFxcInJ0bFxcXCI9PWIub3B0cy5kaXJlY3Rpb24/ZC53aWR0aCgpLWMub3V0ZXJXaWR0aCgpOjApKSxiLm9wdHMudG9vbGJhckJvdHRvbT9kLmNzcyhcXFwiYm90dG9tXFxcIixiLiR0Yi5oZWlnaHQoKS1jLnBvc2l0aW9uKCkudG9wKTpkLmNzcyhcXFwidG9wXFxcIixjLnBvc2l0aW9uKCkudG9wK2Mub3V0ZXJIZWlnaHQoKSl9Yy5hZGRDbGFzcyhcXFwiZnItYmxpbmtcXFwiKS50b2dnbGVDbGFzcyhcXFwiZnItYWN0aXZlXFxcIiksYy5oYXNDbGFzcyhcXFwiZnItYWN0aXZlXFxcIik/KGQuYXR0cihcXFwiYXJpYS1oaWRkZW5cXFwiLCExKSxjLmF0dHIoXFxcImFyaWEtZXhwYW5kZWRcXFwiLCEwKSk6KGQuYXR0cihcXFwiYXJpYS1oaWRkZW5cXFwiLCEwKSxjLmF0dHIoXFxcImFyaWEtZXhwYW5kZWRcXFwiLCExKSksc2V0VGltZW91dChmdW5jdGlvbigpe2MucmVtb3ZlQ2xhc3MoXFxcImZyLWJsaW5rXFxcIil9LDMwMCksZC5vZmZzZXQoKS5sZWZ0K2Qub3V0ZXJXaWR0aCgpPmEoYi5vcHRzLnNjcm9sbGFibGVDb250YWluZXIpLm9mZnNldCgpLmxlZnQrYShiLm9wdHMuc2Nyb2xsYWJsZUNvbnRhaW5lcikub3V0ZXJXaWR0aCgpJiZkLmNzcyhcXFwibWFyZ2luLWxlZnRcXFwiLC0oZC5vZmZzZXQoKS5sZWZ0K2Qub3V0ZXJXaWR0aCgpLWEoYi5vcHRzLnNjcm9sbGFibGVDb250YWluZXIpLm9mZnNldCgpLmxlZnQtYShiLm9wdHMuc2Nyb2xsYWJsZUNvbnRhaW5lcikub3V0ZXJXaWR0aCgpKSksZi5yZW1vdmVDbGFzcyhcXFwiZnItYWN0aXZlXFxcIikuYXR0cihcXFwiYXJpYS1leHBhbmRlZFxcXCIsITEpLm5leHQoKS5hdHRyKFxcXCJhcmlhLWhpZGRlblxcXCIsITApLGYucGFyZW50KFxcXCIuZnItdG9vbGJhcjpub3QoLmZyLWlubGluZSlcXFwiKS5jc3MoXFxcInpJbmRleFxcXCIsXFxcIlxcXCIpLDAhPWMucGFyZW50cyhcXFwiLmZyLXBvcHVwXFxcIikubGVuZ3RofHxiLm9wdHMudG9vbGJhcklubGluZXx8KGIubm9kZS5oYXNDbGFzcyhjLmdldCgwKSxcXFwiZnItYWN0aXZlXFxcIik/Yi4kdGIuY3NzKFxcXCJ6SW5kZXhcXFwiLChiLm9wdHMuekluZGV4fHwxKSs0KTpiLiR0Yi5jc3MoXFxcInpJbmRleFxcXCIsXFxcIlxcXCIpKTt2YXIgaT1kLmZpbmQoXFxcImEuZnItY29tbWFuZC5mci1hY3RpdmVcXFwiKTtpLmxlbmd0aD9iLmFjY2Vzc2liaWxpdHkuZm9jdXNUb29sYmFyRWxlbWVudChpKTpiLmFjY2Vzc2liaWxpdHkuZm9jdXNUb29sYmFyRWxlbWVudChjKX1mdW5jdGlvbiBkKGIpe2IuYWRkQ2xhc3MoXFxcImZyLWJsaW5rXFxcIiksc2V0VGltZW91dChmdW5jdGlvbigpe2IucmVtb3ZlQ2xhc3MoXFxcImZyLWJsaW5rXFxcIil9LDUwMCk7Zm9yKHZhciBjPWIuZGF0YShcXFwiY21kXFxcIiksZD1bXTtcXFwidW5kZWZpbmVkXFxcIiE9dHlwZW9mIGIuZGF0YShcXFwicGFyYW1cXFwiKyhkLmxlbmd0aCsxKSk7KWQucHVzaChiLmRhdGEoXFxcInBhcmFtXFxcIisoZC5sZW5ndGgrMSkpKTt2YXIgZT1hKFxcXCIuZnItZHJvcGRvd24uZnItYWN0aXZlXFxcIik7ZS5sZW5ndGgmJihlLnJlbW92ZUNsYXNzKFxcXCJmci1hY3RpdmVcXFwiKS5hdHRyKFxcXCJhcmlhLWV4cGFuZGVkXFxcIiwhMSkubmV4dCgpLmF0dHIoXFxcImFyaWEtaGlkZGVuXFxcIiwhMCksZS5wYXJlbnQoXFxcIi5mci10b29sYmFyOm5vdCguZnItaW5saW5lKVxcXCIpLmNzcyhcXFwiekluZGV4XFxcIixcXFwiXFxcIikpLGIucGFyZW50cyhcXFwiLmZyLXBvcHVwLCAuZnItdG9vbGJhclxcXCIpLmRhdGEoXFxcImluc3RhbmNlXFxcIikuY29tbWFuZHMuZXhlYyhjLGQpfWZ1bmN0aW9uIGUoYSl7ZChhKX1mdW5jdGlvbiBmKGQpe3ZhciBmPWQucGFyZW50cyhcXFwiLmZyLXBvcHVwLCAuZnItdG9vbGJhclxcXCIpLmRhdGEoXFxcImluc3RhbmNlXFxcIik7aWYoMCE9ZC5wYXJlbnRzKFxcXCIuZnItcG9wdXBcXFwiKS5sZW5ndGh8fGQuZGF0YShcXFwicG9wdXBcXFwiKXx8Zi5wb3B1cHMuaGlkZUFsbCgpLGYucG9wdXBzLmFyZVZpc2libGUoKSYmIWYucG9wdXBzLmFyZVZpc2libGUoZikpe2Zvcih2YXIgZz0wO2c8YS5GRS5JTlNUQU5DRVMubGVuZ3RoO2crKylhLkZFLklOU1RBTkNFU1tnXSE9ZiYmYS5GRS5JTlNUQU5DRVNbZ10ucG9wdXBzJiZhLkZFLklOU1RBTkNFU1tnXS5wb3B1cHMuYXJlVmlzaWJsZSgpJiZhLkZFLklOU1RBTkNFU1tnXS4kZWwuZmluZChcXFwiLmZyLW1hcmtlclxcXCIpLnJlbW92ZSgpO2YucG9wdXBzLmhpZGVBbGwoKX1iLm5vZGUuaGFzQ2xhc3MoZC5nZXQoMCksXFxcImZyLWRyb3Bkb3duXFxcIik/YyhkKTooZShkKSxhLkZFLkNPTU1BTkRTW2QuZGF0YShcXFwiY21kXFxcIildJiYwIT1hLkZFLkNPTU1BTkRTW2QuZGF0YShcXFwiY21kXFxcIildLnJlZnJlc2hBZnRlckNhbGxiYWNrJiZmLmJ1dHRvbi5idWxrUmVmcmVzaCgpKX1mdW5jdGlvbiBnKGIpe3ZhciBjPWEoYi5jdXJyZW50VGFyZ2V0KTtmKGMpfWZ1bmN0aW9uIGgoYSl7dmFyIGI9YS5maW5kKFxcXCIuZnItZHJvcGRvd24uZnItYWN0aXZlXFxcIik7Yi5sZW5ndGgmJihiLnJlbW92ZUNsYXNzKFxcXCJmci1hY3RpdmVcXFwiKS5hdHRyKFxcXCJhcmlhLWV4cGFuZGVkXFxcIiwhMSkubmV4dCgpLmF0dHIoXFxcImFyaWEtaGlkZGVuXFxcIiwhMCksYi5wYXJlbnQoXFxcIi5mci10b29sYmFyOm5vdCguZnItaW5saW5lKVxcXCIpLmNzcyhcXFwiekluZGV4XFxcIixcXFwiXFxcIikpfWZ1bmN0aW9uIGkoYSl7YS5wcmV2ZW50RGVmYXVsdCgpLGEuc3RvcFByb3BhZ2F0aW9uKCl9ZnVuY3Rpb24gaihhKXtpZihhLnN0b3BQcm9wYWdhdGlvbigpLCFiLmhlbHBlcnMuaXNNb2JpbGUoKSlyZXR1cm4hMX1mdW5jdGlvbiBrKGMsZCl7Yi5ldmVudHMuYmluZENsaWNrKGMsXFxcIi5mci1jb21tYW5kOm5vdCguZnItZGlzYWJsZWQpXFxcIixnKSxiLmV2ZW50cy4kb24oYyxiLl9tb3VzZWRvd24rXFxcIiBcXFwiK2IuX21vdXNldXArXFxcIiBcXFwiK2IuX21vdmUsXFxcIi5mci1kcm9wZG93bi1tZW51XFxcIixpLCEwKSxiLmV2ZW50cy4kb24oYyxiLl9tb3VzZWRvd24rXFxcIiBcXFwiK2IuX21vdXNldXArXFxcIiBcXFwiK2IuX21vdmUsXFxcIi5mci1kcm9wZG93bi1tZW51IC5mci1kcm9wZG93bi13cmFwcGVyXFxcIixqLCEwKTt2YXIgZT1jLmdldCgwKS5vd25lckRvY3VtZW50LGY9XFxcImRlZmF1bHRWaWV3XFxcImluIGU/ZS5kZWZhdWx0VmlldzplLnBhcmVudFdpbmRvdyxrPWZ1bmN0aW9uKGQpeyghZHx8ZC50eXBlPT1iLl9tb3VzZXVwJiZkLnRhcmdldCE9YShcXFwiaHRtbFxcXCIpLmdldCgwKXx8XFxcImtleWRvd25cXFwiPT1kLnR5cGUmJihiLmtleXMuaXNDaGFyYWN0ZXIoZC53aGljaCkmJiFiLmtleXMuY3RybEtleShkKXx8ZC53aGljaD09YS5GRS5LRVlDT0RFLkVTQykpJiZoKGMpfTtiLmV2ZW50cy4kb24oYShmKSxiLl9tb3VzZXVwK1xcXCIgcmVzaXplIGtleWRvd25cXFwiLGssITApLGIub3B0cy5pZnJhbWUmJmIuZXZlbnRzLiRvbihiLiR3aW4sYi5fbW91c2V1cCxrLCEwKSxiLm5vZGUuaGFzQ2xhc3MoYy5nZXQoMCksXFxcImZyLXBvcHVwXFxcIik/YS5tZXJnZSh1LGMuZmluZChcXFwiLmZyLWJ0blxcXCIpLnRvQXJyYXkoKSk6YS5tZXJnZSh0LGMuZmluZChcXFwiLmZyLWJ0blxcXCIpLnRvQXJyYXkoKSksYi50b29sdGlwLmJpbmQoYyxcXFwiLmZyLWJ0biwgLmZyLXRpdGxlXFxcIixkKX1mdW5jdGlvbiBsKGEsYyl7dmFyIGQ9XFxcIlxcXCI7aWYoYy5odG1sKWQrPVxcXCJmdW5jdGlvblxcXCI9PXR5cGVvZiBjLmh0bWw/Yy5odG1sLmNhbGwoYik6Yy5odG1sO2Vsc2V7dmFyIGU9Yy5vcHRpb25zO1xcXCJmdW5jdGlvblxcXCI9PXR5cGVvZiBlJiYoZT1lKCkpLGQrPSc8dWwgY2xhc3M9XFxcImZyLWRyb3Bkb3duLWxpc3RcXFwiIHJvbGU9XFxcInByZXNlbnRhdGlvblxcXCI+Jztmb3IodmFyIGYgaW4gZSlpZihlLmhhc093blByb3BlcnR5KGYpKXt2YXIgZz1iLnNob3J0Y3V0cy5nZXQoYStcXFwiLlxcXCIrZik7Zz1nPyc8c3BhbiBjbGFzcz1cXFwiZnItc2hvcnRjdXRcXFwiPicrZytcXFwiPC9zcGFuPlxcXCI6XFxcIlxcXCIsZCs9JzxsaSByb2xlPVxcXCJwcmVzZW50YXRpb25cXFwiPjxhIGNsYXNzPVxcXCJmci1jb21tYW5kXFxcIiB0YWJJbmRleD1cXFwiLTFcXFwiIHJvbGU9XFxcIm9wdGlvblxcXCIgZGF0YS1jbWQ9XFxcIicrYSsnXFxcIiBkYXRhLXBhcmFtMT1cXFwiJytmKydcXFwiIHRpdGxlPVxcXCInK2VbZl0rJ1xcXCI+JytiLmxhbmd1YWdlLnRyYW5zbGF0ZShlW2ZdKStcXFwiPC9hPjwvbGk+XFxcIn1kKz1cXFwiPC91bD5cXFwifXJldHVybiBkfWZ1bmN0aW9uIG0oYSxjLGQpe2lmKGIuaGVscGVycy5pc01vYmlsZSgpJiZjLnNob3dPbk1vYmlsZT09PSExKXJldHVyblxcXCJcXFwiO3ZhciBlPWMuZGlzcGxheVNlbGVjdGlvbjtcXFwiZnVuY3Rpb25cXFwiPT10eXBlb2YgZSYmKGU9ZShiKSk7dmFyIGY7aWYoZSl7dmFyIGc9XFxcImZ1bmN0aW9uXFxcIj09dHlwZW9mIGMuZGVmYXVsdFNlbGVjdGlvbj9jLmRlZmF1bHRTZWxlY3Rpb24oYik6Yy5kZWZhdWx0U2VsZWN0aW9uO2Y9JzxzcGFuIHN0eWxlPVxcXCJ3aWR0aDonKyhjLmRpc3BsYXlTZWxlY3Rpb25XaWR0aHx8MTAwKSsncHhcXFwiPicrKGd8fGIubGFuZ3VhZ2UudHJhbnNsYXRlKGMudGl0bGUpKStcXFwiPC9zcGFuPlxcXCJ9ZWxzZSBmPWIuaWNvbi5jcmVhdGUoYy5pY29ufHxhKSxmKz0nPHNwYW4gY2xhc3M9XFxcImZyLXNyLW9ubHlcXFwiPicrKGIubGFuZ3VhZ2UudHJhbnNsYXRlKGMudGl0bGUpfHxcXFwiXFxcIikrXFxcIjwvc3Bhbj5cXFwiO3ZhciBoPWMucG9wdXA/JyBkYXRhLXBvcHVwPVxcXCJ0cnVlXFxcIic6XFxcIlxcXCIsaT1jLm1vZGFsPycgZGF0YS1tb2RhbD1cXFwidHJ1ZVxcXCInOlxcXCJcXFwiLGo9Yi5zaG9ydGN1dHMuZ2V0KGErXFxcIi5cXFwiKTtqPWo/XFxcIiAoXFxcIitqK1xcXCIpXFxcIjpcXFwiXFxcIjt2YXIgaz1hK1xcXCItXFxcIitiLmlkLG09JzxidXR0b24gaWQ9XFxcIicraysnXFxcInR5cGU9XFxcImJ1dHRvblxcXCIgdGFiSW5kZXg9XFxcIi0xXFxcIiByb2xlPVxcXCJidXR0b25cXFwiJysoYy50b2dnbGU/JyBhcmlhLXByZXNzZWQ9XFxcImZhbHNlXFxcIic6XFxcIlxcXCIpKyhcXFwiZHJvcGRvd25cXFwiPT1jLnR5cGU/JyBhcmlhLWNvbnRyb2xzPVxcXCJkcm9wXFxcIiBhcmlhLWV4cGFuZGVkPVxcXCJmYWxzZVxcXCIgYXJpYS1oYXNwb3B1cD1cXFwidHJ1ZVxcXCInOlxcXCJcXFwiKSsoYy5kaXNhYmxlZD8nIGFyaWEtZGlzYWJsZWQ9XFxcInRydWVcXFwiJzpcXFwiXFxcIikrJyB0aXRsZT1cXFwiJysoYi5sYW5ndWFnZS50cmFuc2xhdGUoYy50aXRsZSl8fFxcXCJcXFwiKStqKydcXFwiIGNsYXNzPVxcXCJmci1jb21tYW5kIGZyLWJ0bicrKFxcXCJkcm9wZG93blxcXCI9PWMudHlwZT9cXFwiIGZyLWRyb3Bkb3duXFxcIjpcXFwiXFxcIikrKFxcXCIgZnItYnRuLVxcXCIrYi5pY29uLmdldFRlbXBsYXRlKGMuaWNvbikpKyhjLmRpc3BsYXlTZWxlY3Rpb24/XFxcIiBmci1zZWxlY3Rpb25cXFwiOlxcXCJcXFwiKSsoYy5iYWNrP1xcXCIgZnItYmFja1xcXCI6XFxcIlxcXCIpKyhjLmRpc2FibGVkP1xcXCIgZnItZGlzYWJsZWRcXFwiOlxcXCJcXFwiKSsoZD9cXFwiXFxcIjpcXFwiIGZyLWhpZGRlblxcXCIpKydcXFwiIGRhdGEtY21kPVxcXCInK2ErJ1xcXCInK2graStcXFwiPlxcXCIrZitcXFwiPC9idXR0b24+XFxcIjtpZihcXFwiZHJvcGRvd25cXFwiPT1jLnR5cGUpe3ZhciBuPSc8ZGl2IGNsYXNzPVxcXCJmci1kcm9wZG93bi1tZW51XFxcIiByb2xlPVxcXCJsaXN0Ym94XFxcIiBhcmlhLWxhYmVsbGVkYnk9XFxcIicraysnXFxcIiBhcmlhLWhpZGRlbj1cXFwidHJ1ZVxcXCI+PGRpdiBjbGFzcz1cXFwiZnItZHJvcGRvd24td3JhcHBlclxcXCIgcm9sZT1cXFwicHJlc2VudGF0aW9uXFxcIj48ZGl2IGNsYXNzPVxcXCJmci1kcm9wZG93bi1jb250ZW50XFxcIiByb2xlPVxcXCJwcmVzZW50YXRpb25cXFwiPic7bis9bChhLGMpLG4rPVxcXCI8L2Rpdj48L2Rpdj48L2Rpdj5cXFwiLG0rPW59cmV0dXJuIG19ZnVuY3Rpb24gbihjLGQpe2Zvcih2YXIgZT1cXFwiXFxcIixmPTA7ZjxjLmxlbmd0aDtmKyspe3ZhciBnPWNbZl0saD1hLkZFLkNPTU1BTkRTW2ddO2lmKCEoaCYmXFxcInVuZGVmaW5lZFxcXCIhPXR5cGVvZiBoLnBsdWdpbiYmYi5vcHRzLnBsdWdpbnNFbmFibGVkLmluZGV4T2YoaC5wbHVnaW4pPDApKWlmKGgpe3ZhciBpPVxcXCJ1bmRlZmluZWRcXFwiPT10eXBlb2YgZHx8ZC5pbmRleE9mKGcpPj0wO2UrPW0oZyxoLGkpfWVsc2VcXFwifFxcXCI9PWc/ZSs9JzxkaXYgY2xhc3M9XFxcImZyLXNlcGFyYXRvciBmci12c1xcXCIgcm9sZT1cXFwic2VwYXJhdG9yXFxcIiBhcmlhLW9yaWVudGF0aW9uPVxcXCJ2ZXJ0aWNhbFxcXCI+PC9kaXY+JzpcXFwiLVxcXCI9PWcmJihlKz0nPGRpdiBjbGFzcz1cXFwiZnItc2VwYXJhdG9yIGZyLWhzXFxcIiByb2xlPVxcXCJzZXBhcmF0b3JcXFwiIGFyaWEtb3JpZW50YXRpb249XFxcImhvcml6b250YWxcXFwiPjwvZGl2PicpfXJldHVybiBlfWZ1bmN0aW9uIG8oYyl7dmFyIGQsZT1jLnBhcmVudHMoXFxcIi5mci1wb3B1cCwgLmZyLXRvb2xiYXJcXFwiKS5kYXRhKFxcXCJpbnN0YW5jZVxcXCIpfHxiLGY9Yy5kYXRhKFxcXCJjbWRcXFwiKTtiLm5vZGUuaGFzQ2xhc3MoYy5nZXQoMCksXFxcImZyLWRyb3Bkb3duXFxcIik/ZD1jLm5leHQoKTooYy5yZW1vdmVDbGFzcyhcXFwiZnItYWN0aXZlXFxcIiksYy5hdHRyKFxcXCJhcmlhLXByZXNzZWRcXFwiKSYmYy5hdHRyKFxcXCJhcmlhLXByZXNzZWRcXFwiLCExKSksYS5GRS5DT01NQU5EU1tmXSYmYS5GRS5DT01NQU5EU1tmXS5yZWZyZXNoP2EuRkUuQ09NTUFORFNbZl0ucmVmcmVzaC5hcHBseShlLFtjLGRdKTpiLnJlZnJlc2hbZl0mJmUucmVmcmVzaFtmXShjLGQpfWZ1bmN0aW9uIHAoYyl7dmFyIGQ9Yi4kdGI/Yi4kdGIuZGF0YShcXFwiaW5zdGFuY2VcXFwiKXx8YjpiO3JldHVybiAwPT1iLmV2ZW50cy50cmlnZ2VyKFxcXCJidXR0b25zLnJlZnJlc2hcXFwiKXx8dm9pZCBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7Zm9yKHZhciBlPWQuc2VsZWN0aW9uLmluRWRpdG9yKCkmJmQuY29yZS5oYXNGb2N1cygpLGY9MDtmPGMubGVuZ3RoO2YrKyl7dmFyIGc9YShjW2ZdKSxoPWcuZGF0YShcXFwiY21kXFxcIik7MD09Zy5wYXJlbnRzKFxcXCIuZnItcG9wdXBcXFwiKS5sZW5ndGg/ZXx8YS5GRS5DT01NQU5EU1toXSYmYS5GRS5DT01NQU5EU1toXS5mb3JjZWRSZWZyZXNoP2QuYnV0dG9uLnJlZnJlc2goZyk6Yi5ub2RlLmhhc0NsYXNzKGcuZ2V0KDApLFxcXCJmci1kcm9wZG93blxcXCIpfHwoZy5yZW1vdmVDbGFzcyhcXFwiZnItYWN0aXZlXFxcIiksZy5hdHRyKFxcXCJhcmlhLXByZXNzZWRcXFwiKSYmZy5hdHRyKFxcXCJhcmlhLXByZXNzZWRcXFwiLCExKSk6Zy5wYXJlbnRzKFxcXCIuZnItcG9wdXBcXFwiKS5pcyhcXFwiOnZpc2libGVcXFwiKSYmZC5idXR0b24ucmVmcmVzaChnKX19LDApfWZ1bmN0aW9uIHEoKXtwKHQpLHAodSl9ZnVuY3Rpb24gcigpe3Q9W10sdT1bXX1mdW5jdGlvbiBzKCl7Yi5vcHRzLnRvb2xiYXJJbmxpbmU/Yi5ldmVudHMub24oXFxcInRvb2xiYXIuc2hvd1xcXCIscSk6KGIuZXZlbnRzLm9uKFxcXCJtb3VzZXVwXFxcIixxKSxiLmV2ZW50cy5vbihcXFwia2V5dXBcXFwiLHEpLGIuZXZlbnRzLm9uKFxcXCJibHVyXFxcIixxKSxiLmV2ZW50cy5vbihcXFwiZm9jdXNcXFwiLHEpLGIuZXZlbnRzLm9uKFxcXCJjb250ZW50Q2hhbmdlZFxcXCIscSkpLGIuZXZlbnRzLm9uKFxcXCJzaGFyZWQuZGVzdHJveVxcXCIscil9dmFyIHQ9W107KGIub3B0cy50b29sYmFySW5saW5lfHxiLm9wdHMudG9vbGJhckNvbnRhaW5lcikmJihiLnNoYXJlZC5idXR0b25zfHwoYi5zaGFyZWQuYnV0dG9ucz1bXSksdD1iLnNoYXJlZC5idXR0b25zKTt2YXIgdT1bXTtyZXR1cm4gYi5zaGFyZWQucG9wdXBfYnV0dG9uc3x8KGIuc2hhcmVkLnBvcHVwX2J1dHRvbnM9W10pLHU9Yi5zaGFyZWQucG9wdXBfYnV0dG9ucyx7X2luaXQ6cyxidWlsZExpc3Q6bixiaW5kQ29tbWFuZHM6ayxyZWZyZXNoOm8sYnVsa1JlZnJlc2g6cSxleGVjOmQsY2xpY2s6Zn19LGEuRkUuTU9EVUxFUy5tb2RhbHM9ZnVuY3Rpb24oYil7ZnVuY3Rpb24gYyhhKXtyZXR1cm4gblthXX1mdW5jdGlvbiBkKGMsZCl7dmFyIGU9JzxkaXYgdGFiSW5kZXg9XFxcIi0xXFxcIiBjbGFzcz1cXFwiZnItbW9kYWwnKyhiLm9wdHMudGhlbWU/XFxcIiBcXFwiK2Iub3B0cy50aGVtZStcXFwiLXRoZW1lXFxcIjpcXFwiXFxcIikrJ1xcXCI+PGRpdiBjbGFzcz1cXFwiZnItbW9kYWwtd3JhcHBlclxcXCI+JyxmPSc8aSB0aXRsZT1cXFwiJytiLmxhbmd1YWdlLnRyYW5zbGF0ZShcXFwiQ2FuY2VsXFxcIikrJ1xcXCIgY2xhc3M9XFxcImZhIGZhLXRpbWVzIGZyLW1vZGFsLWNsb3NlXFxcIj48L2k+JztyZXR1cm4gZSs9JzxkaXYgY2xhc3M9XFxcImZyLW1vZGFsLWhlYWRcXFwiPicrYytmK1xcXCI8L2Rpdj5cXFwiLGUrPSc8ZGl2IHRhYkluZGV4PVxcXCItMVxcXCIgY2xhc3M9XFxcImZyLW1vZGFsLWJvZHlcXFwiPicrZCtcXFwiPC9kaXY+XFxcIixlKz1cXFwiPC9kaXY+PC9kaXY+XFxcIixhKGUpfWZ1bmN0aW9uIGUoYyxlLGYpe2lmKGIuc2hhcmVkLiRvdmVybGF5fHwoYi5zaGFyZWQuJG92ZXJsYXk9YSgnPGRpdiBjbGFzcz1cXFwiZnItb3ZlcmxheVxcXCI+JykuYXBwZW5kVG8oXFxcImJvZHlcXFwiKSksbT1iLnNoYXJlZC4kb3ZlcmxheSxiLm9wdHMudGhlbWUmJm0uYWRkQ2xhc3MoYi5vcHRzLnRoZW1lK1xcXCItdGhlbWVcXFwiKSwhbltjXSl7dmFyIGc9ZChlLGYpO25bY109eyRtb2RhbDpnLCRoZWFkOmcuZmluZChcXFwiLmZyLW1vZGFsLWhlYWRcXFwiKSwkYm9keTpnLmZpbmQoXFxcIi5mci1tb2RhbC1ib2R5XFxcIil9LGIuaGVscGVycy5pc01vYmlsZSgpfHxnLmFkZENsYXNzKFxcXCJmci1kZXNrdG9wXFxcIiksZy5hcHBlbmRUbyhcXFwiYm9keVxcXCIpLGIuZXZlbnRzLmJpbmRDbGljayhnLFxcXCJpLmZyLW1vZGFsLWNsb3NlXFxcIixmdW5jdGlvbigpe2goYyl9KSxuW2NdLiRib2R5LmNzcyhcXFwibWFyZ2luLXRvcFxcXCIsbltjXS4kaGVhZC5vdXRlckhlaWdodCgpKSxiLmV2ZW50cy4kb24oZyxcXFwia2V5ZG93blxcXCIsZnVuY3Rpb24oZCl7dmFyIGU9ZC53aGljaDtyZXR1cm4gZT09YS5GRS5LRVlDT0RFLkVTQz8oaChjKSxiLmFjY2Vzc2liaWxpdHkuZm9jdXNNb2RhbEJ1dHRvbihnKSwhMSk6ISghYShkLmN1cnJlbnRUYXJnZXQpLmlzKFxcXCJpbnB1dFt0eXBlPXRleHRdLCB0ZXh0YXJlYVxcXCIpJiZlIT1hLkZFLktFWUNPREUuQVJST1dfVVAmJmUhPWEuRkUuS0VZQ09ERS5BUlJPV19ET1dOKXx8KGQucHJldmVudERlZmF1bHQoKSxkLnN0b3BQcm9wYWdhdGlvbigpLCExKX0sITApLGgoYyl9cmV0dXJuIG5bY119ZnVuY3Rpb24gZigpe2Zvcih2YXIgYSBpbiBuKXt2YXIgYj1uW2FdO2ImJmIuJG1vZGFsJiZiLiRtb2RhbC5yZW1vdmVEYXRhKCkucmVtb3ZlKCl9bSYmbS5yZW1vdmVEYXRhKCkucmVtb3ZlKCksbj17fX1mdW5jdGlvbiBnKGEpe2lmKG5bYV0pe3ZhciBjPW5bYV0uJG1vZGFsO2MuZGF0YShcXFwiaW5zdGFuY2VcXFwiLGIpLGMuc2hvdygpLG0uc2hvdygpLGIuJGRvYy5maW5kKFxcXCJib2R5XFxcIikuYWRkQ2xhc3MoXFxcInByZXZlbnQtc2Nyb2xsXFxcIiksYi5oZWxwZXJzLmlzTW9iaWxlKCkmJmIuJGRvYy5maW5kKFxcXCJib2R5XFxcIikuYWRkQ2xhc3MoXFxcImZyLW1vYmlsZVxcXCIpLGMuYWRkQ2xhc3MoXFxcImZyLWFjdGl2ZVxcXCIpLGIuY29yZS5oYXNGb2N1cygpfHwoYi5ldmVudHMuZGlzYWJsZUJsdXIoKSxiLmV2ZW50cy5mb2N1cygpKSxiLmFjY2Vzc2liaWxpdHkuc2F2ZVNlbGVjdGlvbigpLGIuZXZlbnRzLmRpc2FibGVCbHVyKCksYi4kZWwuYmx1cigpLGIuc2VsZWN0aW9uLmNsZWFyKCksYi5ldmVudHMuZGlzYWJsZUJsdXIoKSxjLmZpbmQoXFxcIlt0YWJJbmRleF06Zmlyc3RcXFwiKS5mb2N1cygpfX1mdW5jdGlvbiBoKGEpe2lmKG5bYV0pe3ZhciBjPW5bYV0uJG1vZGFsLGQ9Yy5kYXRhKFxcXCJpbnN0YW5jZVxcXCIpfHxiO2QuZXZlbnRzLmVuYWJsZUJsdXIoKSxjLmhpZGUoKSxtLmhpZGUoKSxkLiRkb2MuZmluZChcXFwiYm9keVxcXCIpLnJlbW92ZUNsYXNzKFxcXCJwcmV2ZW50LXNjcm9sbCBmci1tb2JpbGVcXFwiKSxjLnJlbW92ZUNsYXNzKFxcXCJmci1hY3RpdmVcXFwiKSxiLmFjY2Vzc2liaWxpdHkucmVzdG9yZVNlbGVjdGlvbihkKX19ZnVuY3Rpb24gaShhKXtpZihuW2FdKXt2YXIgYz1uW2FdLGQ9Yy4kbW9kYWwsZT1jLiRib2R5LGY9Yi4kd2luLmhlaWdodCgpLGc9ZC5maW5kKFxcXCIuZnItbW9kYWwtd3JhcHBlclxcXCIpLGg9Zy5vdXRlckhlaWdodCghMCksaT1nLmhlaWdodCgpLShlLm91dGVySGVpZ2h0KCEwKS1lLmhlaWdodCgpKSxqPWYtaCtpLGs9ZS5nZXQoMCkuc2Nyb2xsSGVpZ2h0LGw9XFxcImF1dG9cXFwiO2s+aiYmKGw9aiksZS5oZWlnaHQobCl9fWZ1bmN0aW9uIGooYSl7dmFyIGM7aWYoXFxcInN0cmluZ1xcXCI9PXR5cGVvZiBhKXtpZighblthXSlyZXR1cm47Yz1uW2FdLiRtb2RhbH1lbHNlIGM9YTtyZXR1cm4gYyYmYi5ub2RlLmhhc0NsYXNzKGMsXFxcImZyLWFjdGl2ZVxcXCIpJiZiLmNvcmUuc2FtZUluc3RhbmNlKGMpfHwhMX1mdW5jdGlvbiBrKGEpe2Zvcih2YXIgYiBpbiBuKWlmKG4uaGFzT3duUHJvcGVydHkoYikmJmooYikmJihcXFwidW5kZWZpbmVkXFxcIj09dHlwZW9mIGF8fG5bYl0uJG1vZGFsLmRhdGEoXFxcImluc3RhbmNlXFxcIik9PWEpKXJldHVybiBuW2JdLiRtb2RhbDtyZXR1cm4hMX1mdW5jdGlvbiBsKCl7Yi5ldmVudHMub24oXFxcInNoYXJlZC5kZXN0cm95XFxcIixmLCEwKX1iLnNoYXJlZC5tb2RhbHN8fChiLnNoYXJlZC5tb2RhbHM9e30pO3ZhciBtLG49Yi5zaGFyZWQubW9kYWxzO3JldHVybntfaW5pdDpsLGdldDpjLGNyZWF0ZTplLHNob3c6ZyxoaWRlOmgscmVzaXplOmksaXNWaXNpYmxlOmosYXJlVmlzaWJsZTprfX0sYS5GRS5QT1BVUF9URU1QTEFURVM9e1xcXCJ0ZXh0LmVkaXRcXFwiOlxcXCJbX0VESVRfXVxcXCJ9LGEuRkUuUmVnaXN0ZXJUZW1wbGF0ZT1mdW5jdGlvbihiLGMpe2EuRkUuUE9QVVBfVEVNUExBVEVTW2JdPWN9LGEuRkUuTU9EVUxFUy5wb3B1cHM9ZnVuY3Rpb24oYil7ZnVuY3Rpb24gYyhjLGQpe2QuaXMoXFxcIjp2aXNpYmxlXFxcIil8fChkPWEoYi5vcHRzLnNjcm9sbGFibGVDb250YWluZXIpKSxkLmlzKHhbY10uZGF0YShcXFwiY29udGFpbmVyXFxcIikpfHwoeFtjXS5kYXRhKFxcXCJjb250YWluZXJcXFwiLGQpLGQuYXBwZW5kKHhbY10pKX1mdW5jdGlvbiBkKGQsZSxoLGkpe2lmKGcoKSYmYi4kZWwuZmluZChcXFwiLmZyLW1hcmtlclxcXCIpLmxlbmd0aD4wPyhiLmV2ZW50cy5kaXNhYmxlQmx1cigpLGIuc2VsZWN0aW9uLnJlc3RvcmUoKSk6KGIuZXZlbnRzLmRpc2FibGVCbHVyKCksYi5ldmVudHMuZm9jdXMoKSksbShbZF0pLCF4W2RdKXJldHVybiExO3ZhciBqPWEoXFxcIi5mci1kcm9wZG93bi5mci1hY3RpdmVcXFwiKTtqLnJlbW92ZUNsYXNzKFxcXCJmci1hY3RpdmVcXFwiKS5hdHRyKFxcXCJhcmlhLWV4cGFuZGVkXFxcIiwhMSkucGFyZW50KFxcXCIuZnItdG9vbGJhclxcXCIpLmNzcyhcXFwiekluZGV4XFxcIixcXFwiXFxcIiksai5uZXh0KCkuYXR0cihcXFwiYXJpYS1oaWRkZW5cXFwiLCEwKSx4W2RdLmRhdGEoXFxcImluc3RhbmNlXFxcIixiKSxiLiR0YiYmYi4kdGIuZGF0YShcXFwiaW5zdGFuY2VcXFwiLGIpO3ZhciBrPXhbZF0ub3V0ZXJXaWR0aCgpLGw9KHhbZF0ub3V0ZXJIZWlnaHQoKSxmKGQpKTt4W2RdLmFkZENsYXNzKFxcXCJmci1hY3RpdmVcXFwiKS5yZW1vdmVDbGFzcyhcXFwiZnItaGlkZGVuXFxcIikuZmluZChcXFwiaW5wdXQsIHRleHRhcmVhXFxcIikucmVtb3ZlQXR0cihcXFwiZGlzYWJsZWRcXFwiKTt2YXIgbj14W2RdLmRhdGEoXFxcImNvbnRhaW5lclxcXCIpO2Iub3B0cy50b29sYmFySW5saW5lJiZuJiZiLiR0YiYmbi5nZXQoMCk9PWIuJHRiLmdldCgwKSYmKGMoZCxhKGIub3B0cy5zY3JvbGxhYmxlQ29udGFpbmVyKSksaD1iLiR0Yi5vZmZzZXQoKS50b3AtYi5oZWxwZXJzLmdldFBYKGIuJHRiLmNzcyhcXFwibWFyZ2luLXRvcFxcXCIpKSxlPWIuJHRiLm9mZnNldCgpLmxlZnQrYi4kdGIub3V0ZXJXaWR0aCgpLzIrKHBhcnNlRmxvYXQoYi4kdGIuZmluZChcXFwiLmZyLWFycm93XFxcIikuY3NzKFxcXCJtYXJnaW4tbGVmdFxcXCIpKXx8MCkrYi4kdGIuZmluZChcXFwiLmZyLWFycm93XFxcIikub3V0ZXJXaWR0aCgpLzIsYi5ub2RlLmhhc0NsYXNzKGIuJHRiLmdldCgwKSxcXFwiZnItYWJvdmVcXFwiKSYmaCYmKGgrPWIuJHRiLm91dGVySGVpZ2h0KCkpLGk9MCksbj14W2RdLmRhdGEoXFxcImNvbnRhaW5lclxcXCIpLCFiLm9wdHMuaWZyYW1lfHxpfHxsfHwoZSYmKGUtPWIuJGlmcmFtZS5vZmZzZXQoKS5sZWZ0KSxoJiYoaC09Yi4kaWZyYW1lLm9mZnNldCgpLnRvcCkpLG4uaXMoYi4kdGIpP2IuJHRiLmNzcyhcXFwiekluZGV4XFxcIiwoYi5vcHRzLnpJbmRleHx8MSkrNCk6eFtkXS5jc3MoXFxcInpJbmRleFxcXCIsKGIub3B0cy56SW5kZXh8fDEpKzQpLGUmJihlLT1rLzIpLGIub3B0cy50b29sYmFyQm90dG9tJiZuJiZiLiR0YiYmbi5nZXQoMCk9PWIuJHRiLmdldCgwKSYmKHhbZF0uYWRkQ2xhc3MoXFxcImZyLWFib3ZlXFxcIiksaCYmKGgtPXhbZF0ub3V0ZXJIZWlnaHQoKSkpLHhbZF0ucmVtb3ZlQ2xhc3MoXFxcImZyLWFjdGl2ZVxcXCIpLGIucG9zaXRpb24uYXQoZSxoLHhbZF0saXx8MCkseFtkXS5hZGRDbGFzcyhcXFwiZnItYWN0aXZlXFxcIiksbHx8Yi5hY2Nlc3NpYmlsaXR5LmZvY3VzUG9wdXAoeFtkXSksYi5vcHRzLnRvb2xiYXJJbmxpbmUmJmIudG9vbGJhci5oaWRlKCksYi5ldmVudHMudHJpZ2dlcihcXFwicG9wdXBzLnNob3cuXFxcIitkKSxzKGQpLl9yZXBvc2l0aW9uUG9wdXAoKSxvKCl9ZnVuY3Rpb24gZShhLGMpe2IuZXZlbnRzLm9uKFxcXCJwb3B1cHMuc2hvdy5cXFwiK2EsYyl9ZnVuY3Rpb24gZihhKXtyZXR1cm4geFthXSYmYi5ub2RlLmhhc0NsYXNzKHhbYV0sXFxcImZyLWFjdGl2ZVxcXCIpJiZiLmNvcmUuc2FtZUluc3RhbmNlKHhbYV0pfHwhMX1mdW5jdGlvbiBnKGEpe2Zvcih2YXIgYiBpbiB4KWlmKHguaGFzT3duUHJvcGVydHkoYikmJmYoYikmJihcXFwidW5kZWZpbmVkXFxcIj09dHlwZW9mIGF8fHhbYl0uZGF0YShcXFwiaW5zdGFuY2VcXFwiKT09YSkpcmV0dXJuIHhbYl07cmV0dXJuITF9ZnVuY3Rpb24gaChhKXt2YXIgYz1udWxsO2M9XFxcInN0cmluZ1xcXCIhPXR5cGVvZiBhP2E6eFthXSxjJiZiLm5vZGUuaGFzQ2xhc3MoYyxcXFwiZnItYWN0aXZlXFxcIikmJihjLnJlbW92ZUNsYXNzKFxcXCJmci1hY3RpdmUgZnItYWJvdmVcXFwiKSxiLmV2ZW50cy50cmlnZ2VyKFxcXCJwb3B1cHMuaGlkZS5cXFwiK2EpLGIuJHRiJiYoYi5vcHRzLnpJbmRleD4xP2IuJHRiLmNzcyhcXFwiekluZGV4XFxcIixiLm9wdHMuekluZGV4KzEpOmIuJHRiLmNzcyhcXFwiekluZGV4XFxcIixcXFwiXFxcIikpLGIuZXZlbnRzLmRpc2FibGVCbHVyKCksYy5maW5kKFxcXCJpbnB1dCwgdGV4dGFyZWEsIGJ1dHRvblxcXCIpLmZpbHRlcihcXFwiOmZvY3VzXFxcIikuYmx1cigpLGMuZmluZChcXFwiaW5wdXQsIHRleHRhcmVhXFxcIikuYXR0cihcXFwiZGlzYWJsZWRcXFwiLFxcXCJkaXNhYmxlZFxcXCIpKX1mdW5jdGlvbiBpKGEsYyl7Yi5ldmVudHMub24oXFxcInBvcHVwcy5oaWRlLlxcXCIrYSxjKX1mdW5jdGlvbiBqKGEpe3ZhciBjPXhbYV07aWYoYyYmIWMuZGF0YShcXFwiaW5zdFxcXCIrYi5pZCkpe3ZhciBkPXMoYSk7dChkLGEpfXJldHVybiBjfWZ1bmN0aW9uIGsoYSxjKXtiLmV2ZW50cy5vbihcXFwicG9wdXBzLnJlZnJlc2guXFxcIithLGMpfWZ1bmN0aW9uIGwoYyl7Yi5ldmVudHMudHJpZ2dlcihcXFwicG9wdXBzLnJlZnJlc2guXFxcIitjKTtmb3IodmFyIGQ9eFtjXS5maW5kKFxcXCIuZnItY29tbWFuZFxcXCIpLGU9MDtlPGQubGVuZ3RoO2UrKyl7dmFyIGY9YShkW2VdKTswPT1mLnBhcmVudHMoXFxcIi5mci1kcm9wZG93bi1tZW51XFxcIikubGVuZ3RoJiZiLmJ1dHRvbi5yZWZyZXNoKGYpfX1mdW5jdGlvbiBtKGEpe1xcXCJ1bmRlZmluZWRcXFwiPT10eXBlb2YgYSYmKGE9W10pO2Zvcih2YXIgYiBpbiB4KXguaGFzT3duUHJvcGVydHkoYikmJmEuaW5kZXhPZihiKTwwJiZoKGIpfWZ1bmN0aW9uIG4oKXtiLnNoYXJlZC5leGl0X2ZsYWc9ITB9ZnVuY3Rpb24gbygpe2Iuc2hhcmVkLmV4aXRfZmxhZz0hMX1mdW5jdGlvbiBwKCl7cmV0dXJuIGIuc2hhcmVkLmV4aXRfZmxhZ31mdW5jdGlvbiBxKGMsZCl7dmFyIGU9YS5GRS5QT1BVUF9URU1QTEFURVNbY107XFxcImZ1bmN0aW9uXFxcIj09dHlwZW9mIGUmJihlPWUuYXBwbHkoYikpO2Zvcih2YXIgZiBpbiBkKWQuaGFzT3duUHJvcGVydHkoZikmJihlPWUucmVwbGFjZShcXFwiW19cXFwiK2YudG9VcHBlckNhc2UoKStcXFwiX11cXFwiLGRbZl0pKTtyZXR1cm4gZX1mdW5jdGlvbiByKGMsZCl7dmFyIGU9cShjLGQpLGY9YSgnPGRpdiBjbGFzcz1cXFwiZnItcG9wdXAnKyhiLmhlbHBlcnMuaXNNb2JpbGUoKT9cXFwiIGZyLW1vYmlsZVxcXCI6XFxcIiBmci1kZXNrdG9wXFxcIikrKGIub3B0cy50b29sYmFySW5saW5lP1xcXCIgZnItaW5saW5lXFxcIjpcXFwiXFxcIikrJ1xcXCI+PHNwYW4gY2xhc3M9XFxcImZyLWFycm93XFxcIj48L3NwYW4+JytlK1xcXCI8L2Rpdj5cXFwiKTtiLm9wdHMudGhlbWUmJmYuYWRkQ2xhc3MoYi5vcHRzLnRoZW1lK1xcXCItdGhlbWVcXFwiKSxiLm9wdHMuekluZGV4PjEmJmIuJHRiLmNzcyhcXFwiei1pbmRleFxcXCIsYi5vcHRzLnpJbmRleCsyKSxcXFwiYXV0b1xcXCIhPWIub3B0cy5kaXJlY3Rpb24mJmYucmVtb3ZlQ2xhc3MoXFxcImZyLWx0ciBmci1ydGxcXFwiKS5hZGRDbGFzcyhcXFwiZnItXFxcIitiLm9wdHMuZGlyZWN0aW9uKSxmLmZpbmQoXFxcImlucHV0LCB0ZXh0YXJlYVxcXCIpLmF0dHIoXFxcImRpclxcXCIsYi5vcHRzLmRpcmVjdGlvbikuYXR0cihcXFwiZGlzYWJsZWRcXFwiLFxcXCJkaXNhYmxlZFxcXCIpO3ZhciBnPWEoXFxcImJvZHlcXFwiKTtyZXR1cm4gZy5hcHBlbmQoZiksZi5kYXRhKFxcXCJjb250YWluZXJcXFwiLGcpLHhbY109ZixiLmJ1dHRvbi5iaW5kQ29tbWFuZHMoZiwhMSksZn1mdW5jdGlvbiBzKGMpe3ZhciBkPXhbY107cmV0dXJue193aW5kb3dSZXNpemU6ZnVuY3Rpb24oKXt2YXIgYT1kLmRhdGEoXFxcImluc3RhbmNlXFxcIil8fGI7IWEuaGVscGVycy5pc01vYmlsZSgpJiZkLmlzKFxcXCI6dmlzaWJsZVxcXCIpJiYoYS5ldmVudHMuZGlzYWJsZUJsdXIoKSxhLnBvcHVwcy5oaWRlKGMpLGEuZXZlbnRzLmVuYWJsZUJsdXIoKSl9LF9pbnB1dEZvY3VzOmZ1bmN0aW9uKGMpe3ZhciBlPWQuZGF0YShcXFwiaW5zdGFuY2VcXFwiKXx8YixmPWEoYy5jdXJyZW50VGFyZ2V0KTtpZihmLmlzKFxcXCJpbnB1dDpmaWxlXFxcIikmJmYuY2xvc2VzdChcXFwiLmZyLWxheWVyXFxcIikuYWRkQ2xhc3MoXFxcImZyLWlucHV0LWZvY3VzXFxcIiksYy5wcmV2ZW50RGVmYXVsdCgpLGMuc3RvcFByb3BhZ2F0aW9uKCksc2V0VGltZW91dChmdW5jdGlvbigpe2UuZXZlbnRzLmVuYWJsZUJsdXIoKX0sMCksZS5oZWxwZXJzLmlzTW9iaWxlKCkpe3ZhciBnPWEoZS5vX3dpbikuc2Nyb2xsVG9wKCk7c2V0VGltZW91dChmdW5jdGlvbigpe2EoZS5vX3dpbikuc2Nyb2xsVG9wKGcpfSwwKX19LF9pbnB1dEJsdXI6ZnVuY3Rpb24oYyl7dmFyIGU9ZC5kYXRhKFxcXCJpbnN0YW5jZVxcXCIpfHxiLGY9YShjLmN1cnJlbnRUYXJnZXQpO2YuaXMoXFxcImlucHV0OmZpbGVcXFwiKSYmZi5jbG9zZXN0KFxcXCIuZnItbGF5ZXJcXFwiKS5yZW1vdmVDbGFzcyhcXFwiZnItaW5wdXQtZm9jdXNcXFwiKSxkb2N1bWVudC5hY3RpdmVFbGVtZW50IT10aGlzJiZhKHRoaXMpLmlzKFxcXCI6dmlzaWJsZVxcXCIpJiYoZS5ldmVudHMuYmx1ckFjdGl2ZSgpJiZlLmV2ZW50cy50cmlnZ2VyKFxcXCJibHVyXFxcIiksZS5ldmVudHMuZW5hYmxlQmx1cigpKX0sX2VkaXRvcktleWRvd246ZnVuY3Rpb24oZSl7dmFyIGc9ZC5kYXRhKFxcXCJpbnN0YW5jZVxcXCIpfHxiO2cua2V5cy5jdHJsS2V5KGUpfHxlLndoaWNoPT1hLkZFLktFWUNPREUuQUxUfHxlLndoaWNoPT1hLkZFLktFWUNPREUuRVNDfHwoZihjKSYmZC5maW5kKFxcXCIuZnItYmFjazp2aXNpYmxlXFxcIikubGVuZ3RoP2cuYnV0dG9uLmV4ZWMoZC5maW5kKFxcXCIuZnItYmFjazp2aXNpYmxlOmZpcnN0XFxcIikpOmUud2hpY2ghPWEuRkUuS0VZQ09ERS5BTFQmJmcucG9wdXBzLmhpZGUoYykpfSxfcHJldmVudEZvY3VzOmZ1bmN0aW9uKGMpe3ZhciBlPWQuZGF0YShcXFwiaW5zdGFuY2VcXFwiKXx8YjtlLmV2ZW50cy5kaXNhYmxlQmx1cigpO3ZhciBmPWMub3JpZ2luYWxFdmVudD9jLm9yaWdpbmFsRXZlbnQudGFyZ2V0fHxjLm9yaWdpbmFsRXZlbnQub3JpZ2luYWxUYXJnZXQ6bnVsbCxnPVxcXCJpbnB1dCwgdGV4dGFyZWEsIGJ1dHRvbiwgc2VsZWN0LCBsYWJlbCwgLmZyLWNvbW1hbmRcXFwiO3JldHVybiBmJiYhYShmKS5pcyhnKSYmMD09PWEoZikucGFyZW50cyhnKS5sZW5ndGg/KGMuc3RvcFByb3BhZ2F0aW9uKCksITEpOihmJiZhKGYpLmlzKGcpJiZjLnN0b3BQcm9wYWdhdGlvbigpLHZvaWQgbygpKX0sX2VkaXRvck1vdXNldXA6ZnVuY3Rpb24oYSl7ZC5pcyhcXFwiOnZpc2libGVcXFwiKSYmcCgpJiZkLmZpbmQoXFxcImlucHV0OmZvY3VzLCB0ZXh0YXJlYTpmb2N1cywgYnV0dG9uOmZvY3VzLCBzZWxlY3Q6Zm9jdXNcXFwiKS5maWx0ZXIoXFxcIjp2aXNpYmxlXFxcIikubGVuZ3RoPjAmJmIuZXZlbnRzLmRpc2FibGVCbHVyKCl9LF93aW5kb3dNb3VzZXVwOmZ1bmN0aW9uKGEpe2lmKCFiLmNvcmUuc2FtZUluc3RhbmNlKGQpKXJldHVybiEwO3ZhciBlPWQuZGF0YShcXFwiaW5zdGFuY2VcXFwiKXx8YjtkLmlzKFxcXCI6dmlzaWJsZVxcXCIpJiZwKCkmJihhLnN0b3BQcm9wYWdhdGlvbigpLGUubWFya2Vycy5yZW1vdmUoKSxlLnBvcHVwcy5oaWRlKGMpLG8oKSl9LF93aW5kb3dLZXlkb3duOmZ1bmN0aW9uKGUpe2lmKCFiLmNvcmUuc2FtZUluc3RhbmNlKGQpKXJldHVybiEwO3ZhciBmPWQuZGF0YShcXFwiaW5zdGFuY2VcXFwiKXx8YixnPWUud2hpY2g7aWYoYS5GRS5LRVlDT0RFLkVTQz09Zyl7aWYoZi5wb3B1cHMuaXNWaXNpYmxlKGMpJiZmLm9wdHMudG9vbGJhcklubGluZSlyZXR1cm4gZS5zdG9wUHJvcGFnYXRpb24oKSxmLnBvcHVwcy5pc1Zpc2libGUoYykmJihkLmZpbmQoXFxcIi5mci1iYWNrOnZpc2libGVcXFwiKS5sZW5ndGg/KGYuYnV0dG9uLmV4ZWMoZC5maW5kKFxcXCIuZnItYmFjazp2aXNpYmxlOmZpcnN0XFxcIikpLGYuYWNjZXNzaWJpbGl0eS5mb2N1c1BvcHVwQnV0dG9uKGQpKTpkLmZpbmQoXFxcIi5mci1kaXNtaXNzOnZpc2libGVcXFwiKS5sZW5ndGg/Zi5idXR0b24uZXhlYyhkLmZpbmQoXFxcIi5mci1kaXNtaXNzOnZpc2libGU6Zmlyc3RcXFwiKSk6KGYucG9wdXBzLmhpZGUoYyksZi50b29sYmFyLnNob3dJbmxpbmUobnVsbCwhMCksZi5hY2Nlc3NpYmlsaXR5LkZvY3VzUG9wdXBCdXR0b24oZCkpKSwhMTtpZihmLnBvcHVwcy5pc1Zpc2libGUoYykpcmV0dXJuIGQuZmluZChcXFwiLmZyLWJhY2s6dmlzaWJsZVxcXCIpLmxlbmd0aD8oZi5idXR0b24uZXhlYyhkLmZpbmQoXFxcIi5mci1iYWNrOnZpc2libGU6Zmlyc3RcXFwiKSksZi5hY2Nlc3NpYmlsaXR5LmZvY3VzUG9wdXBCdXR0b24oZCkpOmQuZmluZChcXFwiLmZyLWRpc21pc3M6dmlzaWJsZVxcXCIpLmxlbmd0aD9mLmJ1dHRvbi5leGVjKGQuZmluZChcXFwiLmZyLWRpc21pc3M6dmlzaWJsZTpmaXJzdFxcXCIpKTooZi5wb3B1cHMuaGlkZShjKSxmLmFjY2Vzc2liaWxpdHkuZm9jdXNQb3B1cEJ1dHRvbihkKSksITF9fSxfZG9QbGFjZWhvbGRlcjpmdW5jdGlvbihiKXt2YXIgYz1hKHRoaXMpLm5leHQoKTswPT1jLmxlbmd0aCYmYSh0aGlzKS5hdHRyKFxcXCJwbGFjZWhvbGRlclxcXCIpJiZhKHRoaXMpLmFmdGVyKCc8bGFiZWwgZm9yPVxcXCInK2EodGhpcykuYXR0cihcXFwiaWRcXFwiKSsnXFxcIj4nK2EodGhpcykuYXR0cihcXFwicGxhY2Vob2xkZXJcXFwiKStcXFwiPC9sYWJlbD5cXFwiKSxhKHRoaXMpLnRvZ2dsZUNsYXNzKFxcXCJmci1ub3QtZW1wdHlcXFwiLFxcXCJcXFwiIT1hKHRoaXMpLnZhbCgpKX0sX3JlcG9zaXRpb25Qb3B1cDpmdW5jdGlvbihlKXtpZighYi5vcHRzLmhlaWdodCYmIWIub3B0cy5oZWlnaHRNYXh8fGIub3B0cy50b29sYmFySW5saW5lKXJldHVybiEwO2lmKGIuJHdwJiZmKGMpJiZkLnBhcmVudCgpLmdldCgwKT09YShiLm9wdHMuc2Nyb2xsYWJsZUNvbnRhaW5lcikuZ2V0KDApKXt2YXIgZz1kLm9mZnNldCgpLnRvcC1iLiR3cC5vZmZzZXQoKS50b3AsaD1iLiR3cC5vdXRlckhlaWdodCgpO2Iubm9kZS5oYXNDbGFzcyhkLmdldCgwKSxcXFwiZnItYWJvdmVcXFwiKSYmKGcrPWQub3V0ZXJIZWlnaHQoKSksZz5ofHxnPDA/ZC5hZGRDbGFzcyhcXFwiZnItaGlkZGVuXFxcIik6ZC5yZW1vdmVDbGFzcyhcXFwiZnItaGlkZGVuXFxcIil9fX19ZnVuY3Rpb24gdChhLGMpe2IuZXZlbnRzLm9uKFxcXCJtb3VzZXVwXFxcIixhLl9lZGl0b3JNb3VzZXVwLCEwKSxiLiR3cCYmYi5ldmVudHMub24oXFxcImtleWRvd25cXFwiLGEuX2VkaXRvcktleWRvd24pLGIuZXZlbnRzLm9uKFxcXCJibHVyXFxcIixmdW5jdGlvbihhKXtnKCkmJmIubWFya2Vycy5yZW1vdmUoKSxtKCl9KSxiLiR3cCYmIWIuaGVscGVycy5pc01vYmlsZSgpJiZiLmV2ZW50cy4kb24oYi4kd3AsXFxcInNjcm9sbC5wb3B1cFxcXCIrYyxhLl9yZXBvc2l0aW9uUG9wdXApLGIuZXZlbnRzLm9uKFxcXCJ3aW5kb3cubW91c2V1cFxcXCIsYS5fd2luZG93TW91c2V1cCwhMCksYi5ldmVudHMub24oXFxcIndpbmRvdy5rZXlkb3duXFxcIixhLl93aW5kb3dLZXlkb3duLCEwKSx4W2NdLmRhdGEoXFxcImluc3RcXFwiK2IuaWQsITApLGIuZXZlbnRzLm9uKFxcXCJkZXN0cm95XFxcIixmdW5jdGlvbigpe2IuY29yZS5zYW1lSW5zdGFuY2UoeFtjXSkmJnhbY10ucmVtb3ZlQ2xhc3MoXFxcImZyLWFjdGl2ZVxcXCIpLmFwcGVuZFRvKFxcXCJib2R5XFxcIil9LCEwKX1mdW5jdGlvbiB1KGMsZCl7dmFyIGU9cihjLGQpLGY9cyhjKTtyZXR1cm4gdChmLGMpLGIuZXZlbnRzLiRvbihlLFxcXCJtb3VzZWRvd24gbW91c2V1cCB0b3VjaHN0YXJ0IHRvdWNoZW5kIHRvdWNoXFxcIixcXFwiKlxcXCIsZi5fcHJldmVudEZvY3VzLCEwKSxiLmV2ZW50cy4kb24oZSxcXFwiZm9jdXNcXFwiLFxcXCJpbnB1dCwgdGV4dGFyZWEsIGJ1dHRvbiwgc2VsZWN0XFxcIixmLl9pbnB1dEZvY3VzLCEwKSxiLmV2ZW50cy4kb24oZSxcXFwiYmx1clxcXCIsXFxcImlucHV0LCB0ZXh0YXJlYSwgYnV0dG9uLCBzZWxlY3RcXFwiLGYuX2lucHV0Qmx1ciwhMCksYi5hY2Nlc3NpYmlsaXR5LnJlZ2lzdGVyUG9wdXAoYyksYi5ldmVudHMuJG9uKGUsXFxcImtleWRvd24ga2V5dXAgY2hhbmdlIGlucHV0XFxcIixcXFwiaW5wdXQsIHRleHRhcmVhXFxcIixmLl9kb1BsYWNlaG9sZGVyLCEwKSxiLmhlbHBlcnMuaXNJT1MoKSYmYi5ldmVudHMuJG9uKGUsXFxcInRvdWNoZW5kXFxcIixcXFwibGFiZWxcXFwiLGZ1bmN0aW9uKCl7YShcXFwiI1xcXCIrYSh0aGlzKS5hdHRyKFxcXCJmb3JcXFwiKSkucHJvcChcXFwiY2hlY2tlZFxcXCIsZnVuY3Rpb24oYSxiKXtyZXR1cm4hYn0pfSwhMCksYi5ldmVudHMuJG9uKGEoYi5vX3dpbiksXFxcInJlc2l6ZVxcXCIsZi5fd2luZG93UmVzaXplLCEwKSxlfWZ1bmN0aW9uIHYoKXtmb3IodmFyIGEgaW4geClpZih4Lmhhc093blByb3BlcnR5KGEpKXt2YXIgYj14W2FdO2IuaHRtbChcXFwiXFxcIikucmVtb3ZlRGF0YSgpLnJlbW92ZSgpLHhbYV09bnVsbH14PVtdfWZ1bmN0aW9uIHcoKXtiLmV2ZW50cy5vbihcXFwic2hhcmVkLmRlc3Ryb3lcXFwiLHYsITApLGIuZXZlbnRzLm9uKFxcXCJ3aW5kb3cubW91c2Vkb3duXFxcIixuKSxiLmV2ZW50cy5vbihcXFwid2luZG93LnRvdWNobW92ZVxcXCIsbyksYi5ldmVudHMub24oXFxcIm1vdXNlZG93blxcXCIsZnVuY3Rpb24oYSl7XFxuZygpJiYoYS5zdG9wUHJvcGFnYXRpb24oKSxiLiRlbC5maW5kKFxcXCIuZnItbWFya2VyXFxcIikucmVtb3ZlKCksbigpLGIuZXZlbnRzLmRpc2FibGVCbHVyKCkpfSl9Yi5zaGFyZWQucG9wdXBzfHwoYi5zaGFyZWQucG9wdXBzPXt9KTt2YXIgeD1iLnNoYXJlZC5wb3B1cHM7cmV0dXJuIGIuc2hhcmVkLmV4aXRfZmxhZz0hMSx7X2luaXQ6dyxjcmVhdGU6dSxnZXQ6aixzaG93OmQsaGlkZTpoLG9uSGlkZTppLGhpZGVBbGw6bSxzZXRDb250YWluZXI6YyxyZWZyZXNoOmwsb25SZWZyZXNoOmssb25TaG93OmUsaXNWaXNpYmxlOmYsYXJlVmlzaWJsZTpnfX0sYS5GRS5NT0RVTEVTLnBvc2l0aW9uPWZ1bmN0aW9uKGIpe2Z1bmN0aW9uIGMoKXt2YXIgYyxkPWIuc2VsZWN0aW9uLnJhbmdlcygwKTtpZihkJiZkLmNvbGxhcHNlZCYmYi5zZWxlY3Rpb24uaW5FZGl0b3IoKSl7dmFyIGU9ITE7MD09Yi4kZWwuZmluZChcXFwiLmZyLW1hcmtlclxcXCIpLmxlbmd0aCYmKGIuc2VsZWN0aW9uLnNhdmUoKSxlPSEwKTt2YXIgZj1iLiRlbC5maW5kKFxcXCIuZnItbWFya2VyOmZpcnN0XFxcIik7Zi5jc3MoXFxcImRpc3BsYXlcXFwiLFxcXCJpbmxpbmVcXFwiKSxmLmNzcyhcXFwibGluZS1oZWlnaHRcXFwiLFxcXCJcXFwiKTt2YXIgZz1mLm9mZnNldCgpLGg9Zi5vdXRlckhlaWdodCgpO2YuY3NzKFxcXCJkaXNwbGF5XFxcIixcXFwibm9uZVxcXCIpLGYuY3NzKFxcXCJsaW5lLWhlaWdodFxcXCIsMCksYz17fSxjLmxlZnQ9Zy5sZWZ0LGMud2lkdGg9MCxjLmhlaWdodD1oLGMudG9wPWcudG9wLShiLmhlbHBlcnMuaXNJT1MoKT8wOmEoYi5vX3dpbikuc2Nyb2xsVG9wKCkpLGMucmlnaHQ9MSxjLmJvdHRvbT0xLGMub2s9ITAsZSYmYi5zZWxlY3Rpb24ucmVzdG9yZSgpfWVsc2UgZCYmKGM9ZC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSk7cmV0dXJuIGN9ZnVuY3Rpb24gZChjLGQsZSl7dmFyIGY9Yy5vdXRlckhlaWdodCgpO2lmKCFiLmhlbHBlcnMuaXNNb2JpbGUoKSYmYi4kdGImJmMucGFyZW50KCkuZ2V0KDApIT1iLiR0Yi5nZXQoMCkpe3ZhciBnPShjLnBhcmVudCgpLmhlaWdodCgpLTIwLShiLm9wdHMudG9vbGJhckJvdHRvbT9iLiR0Yi5vdXRlckhlaWdodCgpOjApLGMucGFyZW50KCkub2Zmc2V0KCkudG9wKSxoPWQtZi0oZXx8MCk7Yy5wYXJlbnQoKS5nZXQoMCk9PWEoYi5vcHRzLnNjcm9sbGFibGVDb250YWluZXIpLmdldCgwKSYmKGctPWMucGFyZW50KCkucG9zaXRpb24oKS50b3ApO3ZhciBpPWEoYi5vcHRzLnNjcm9sbGFibGVDb250YWluZXIpLmdldCgwKS5zY3JvbGxIZWlnaHQ7ZytkK2Y+YShiLm9wdHMuc2Nyb2xsYWJsZUNvbnRhaW5lcikub2Zmc2V0KCkudG9wK2kmJmMucGFyZW50KCkub2Zmc2V0KCkudG9wK2g+MD8oZD1oLGMuYWRkQ2xhc3MoXFxcImZyLWFib3ZlXFxcIikpOmMucmVtb3ZlQ2xhc3MoXFxcImZyLWFib3ZlXFxcIil9cmV0dXJuIGR9ZnVuY3Rpb24gZShjLGQpe3ZhciBlPWMub3V0ZXJXaWR0aCgpO3JldHVybiBkK2U+YShiLm9wdHMuc2Nyb2xsYWJsZUNvbnRhaW5lcikud2lkdGgoKS0xMCYmKGQ9YShiLm9wdHMuc2Nyb2xsYWJsZUNvbnRhaW5lcikud2lkdGgoKS1lLTEwKSxkPDAmJihkPTEwKSxkfWZ1bmN0aW9uIGYoZCl7dmFyIGU9YygpO2QuY3NzKFxcXCJ0b3BcXFwiLDApLmNzcyhcXFwibGVmdFxcXCIsMCk7dmFyIGY9ZS50b3ArZS5oZWlnaHQsaD1lLmxlZnQrZS53aWR0aC8yLWQub3V0ZXJXaWR0aCgpLzIrYShiLm9fd2luKS5zY3JvbGxMZWZ0KCk7Yi5vcHRzLmlmcmFtZXx8KGYrPWEoYi5vX3dpbikuc2Nyb2xsVG9wKCkpLGcoaCxmLGQsZS5oZWlnaHQpfWZ1bmN0aW9uIGcoYSxjLGYsZyl7dmFyIGg9Zi5kYXRhKFxcXCJjb250YWluZXJcXFwiKTshaHx8aC5pcyhcXFwiYm9keVxcXCIpJiZcXFwic3RhdGljXFxcIj09aC5jc3MoXFxcInBvc2l0aW9uXFxcIil8fChhJiYoYS09aC5vZmZzZXQoKS5sZWZ0KSxjJiYoYy09aC5vZmZzZXQoKS50b3ApLFxcXCJCT0RZXFxcIiE9aC5nZXQoMCkudGFnTmFtZT8oYSYmKGErPWguc2Nyb2xsTGVmdCgpKSxjJiYoYys9aC5zY3JvbGxUb3AoKSkpOlxcXCJhYnNvbHV0ZVxcXCI9PWguY3NzKFxcXCJwb3NpdGlvblxcXCIpJiYoYSYmKGErPWgucG9zaXRpb24oKS5sZWZ0KSxjJiYoYys9aC5wb3NpdGlvbigpLnRvcCkpKSxiLm9wdHMuaWZyYW1lJiZoJiZiLiR0YiYmaC5nZXQoMCkhPWIuJHRiLmdldCgwKSYmKGEmJihhKz1iLiRpZnJhbWUub2Zmc2V0KCkubGVmdCksYyYmKGMrPWIuJGlmcmFtZS5vZmZzZXQoKS50b3ApKTt2YXIgaT1lKGYsYSk7aWYoYSl7Zi5jc3MoXFxcImxlZnRcXFwiLGkpO3ZhciBqPWYuZmluZChcXFwiLmZyLWFycm93XFxcIik7ai5kYXRhKFxcXCJtYXJnaW4tbGVmdFxcXCIpfHxqLmRhdGEoXFxcIm1hcmdpbi1sZWZ0XFxcIixiLmhlbHBlcnMuZ2V0UFgoai5jc3MoXFxcIm1hcmdpbi1sZWZ0XFxcIikpKSxqLmNzcyhcXFwibWFyZ2luLWxlZnRcXFwiLGEtaStqLmRhdGEoXFxcIm1hcmdpbi1sZWZ0XFxcIikpfWMmJmYuY3NzKFxcXCJ0b3BcXFwiLGQoZixjLGcpKX1mdW5jdGlvbiBoKGMpe3ZhciBkPWEoYyksZT1kLmlzKFxcXCIuZnItc3RpY2t5LW9uXFxcIiksZj1kLmRhdGEoXFxcInN0aWNreS10b3BcXFwiKSxnPWQuZGF0YShcXFwic3RpY2t5LXNjaGVkdWxlZFxcXCIpO2lmKFxcXCJ1bmRlZmluZWRcXFwiPT10eXBlb2YgZil7ZC5kYXRhKFxcXCJzdGlja3ktdG9wXFxcIiwwKTt2YXIgaD1hKCc8ZGl2IGNsYXNzPVxcXCJmci1zdGlja3ktZHVtbXlcXFwiIHN0eWxlPVxcXCJoZWlnaHQ6ICcrZC5vdXRlckhlaWdodCgpKydweDtcXFwiPjwvZGl2PicpO2IuJGJveC5wcmVwZW5kKGgpfWVsc2UgYi4kYm94LmZpbmQoXFxcIi5mci1zdGlja3ktZHVtbXlcXFwiKS5jc3MoXFxcImhlaWdodFxcXCIsZC5vdXRlckhlaWdodCgpKTtpZihiLmNvcmUuaGFzRm9jdXMoKXx8Yi4kdGIuZmluZChcXFwiaW5wdXQ6dmlzaWJsZTpmb2N1c1xcXCIpLmxlbmd0aD4wKXt2YXIgaT1hKHdpbmRvdykuc2Nyb2xsVG9wKCksaj1NYXRoLm1pbihNYXRoLm1heChpLWIuJHRiLnBhcmVudCgpLm9mZnNldCgpLnRvcCwwKSxiLiR0Yi5wYXJlbnQoKS5vdXRlckhlaWdodCgpLWQub3V0ZXJIZWlnaHQoKSk7aiE9ZiYmaiE9ZyYmKGNsZWFyVGltZW91dChkLmRhdGEoXFxcInN0aWNreS10aW1lb3V0XFxcIikpLGQuZGF0YShcXFwic3RpY2t5LXNjaGVkdWxlZFxcXCIsaiksZC5vdXRlckhlaWdodCgpPGktYi4kdGIucGFyZW50KCkub2Zmc2V0KCkudG9wJiZkLmFkZENsYXNzKFxcXCJmci1vcGFjaXR5LTBcXFwiKSxkLmRhdGEoXFxcInN0aWNreS10aW1lb3V0XFxcIixzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7dmFyIGM9YSh3aW5kb3cpLnNjcm9sbFRvcCgpLGU9TWF0aC5taW4oTWF0aC5tYXgoYy1iLiR0Yi5wYXJlbnQoKS5vZmZzZXQoKS50b3AsMCksYi4kdGIucGFyZW50KCkub3V0ZXJIZWlnaHQoKS1kLm91dGVySGVpZ2h0KCkpO2U+MCYmXFxcIkJPRFlcXFwiPT1iLiR0Yi5wYXJlbnQoKS5nZXQoMCkudGFnTmFtZSYmKGUrPWIuJHRiLnBhcmVudCgpLnBvc2l0aW9uKCkudG9wKSxlIT1mJiYoZC5jc3MoXFxcInRvcFxcXCIsTWF0aC5tYXgoZSwwKSksZC5kYXRhKFxcXCJzdGlja3ktdG9wXFxcIixlKSxkLmRhdGEoXFxcInN0aWNreS1zY2hlZHVsZWRcXFwiLGUpKSxkLnJlbW92ZUNsYXNzKFxcXCJmci1vcGFjaXR5LTBcXFwiKX0sMTAwKSkpLGV8fChkLmNzcyhcXFwidG9wXFxcIixcXFwiMFxcXCIpLGQud2lkdGgoYi4kdGIucGFyZW50KCkud2lkdGgoKSksZC5hZGRDbGFzcyhcXFwiZnItc3RpY2t5LW9uXFxcIiksYi4kYm94LmFkZENsYXNzKFxcXCJmci1zdGlja3ktYm94XFxcIikpfWVsc2UgY2xlYXJUaW1lb3V0KGEoYykuY3NzKFxcXCJzdGlja3ktdGltZW91dFxcXCIpKSxkLmNzcyhcXFwidG9wXFxcIixcXFwiMFxcXCIpLGQuY3NzKFxcXCJwb3NpdGlvblxcXCIsXFxcIlxcXCIpLGQud2lkdGgoXFxcIlxcXCIpLGQuZGF0YShcXFwic3RpY2t5LXRvcFxcXCIsMCksZC5yZW1vdmVDbGFzcyhcXFwiZnItc3RpY2t5LW9uXFxcIiksYi4kYm94LnJlbW92ZUNsYXNzKFxcXCJmci1zdGlja3ktYm94XFxcIil9ZnVuY3Rpb24gaShjKXtpZihjLm9mZnNldFdpZHRoKXt2YXIgZCxlLGY9YShjKSxnPWYub3V0ZXJIZWlnaHQoKSxoPWYuZGF0YShcXFwic3RpY2t5LXBvc2l0aW9uXFxcIiksaT1hKFxcXCJib2R5XFxcIj09Yi5vcHRzLnNjcm9sbGFibGVDb250YWluZXI/Yi5vX3dpbjpiLm9wdHMuc2Nyb2xsYWJsZUNvbnRhaW5lcikub3V0ZXJIZWlnaHQoKSxqPTAsaz0wO1xcXCJib2R5XFxcIiE9PWIub3B0cy5zY3JvbGxhYmxlQ29udGFpbmVyJiYoaj1hKGIub3B0cy5zY3JvbGxhYmxlQ29udGFpbmVyKS5vZmZzZXQoKS50b3Asaz1hKGIub193aW4pLm91dGVySGVpZ2h0KCktai1pKTt2YXIgbD1cXFwiYm9keVxcXCI9PWIub3B0cy5zY3JvbGxhYmxlQ29udGFpbmVyP2EoYi5vX3dpbikuc2Nyb2xsVG9wKCk6aixtPWYuaXMoXFxcIi5mci1zdGlja3ktb25cXFwiKTtmLmRhdGEoXFxcInN0aWNreS1wYXJlbnRcXFwiKXx8Zi5kYXRhKFxcXCJzdGlja3ktcGFyZW50XFxcIixmLnBhcmVudCgpKTt2YXIgbj1mLmRhdGEoXFxcInN0aWNreS1wYXJlbnRcXFwiKSxvPW4ub2Zmc2V0KCkudG9wLHA9bi5vdXRlckhlaWdodCgpO2lmKGYuZGF0YShcXFwic3RpY2t5LW9mZnNldFxcXCIpfHwoZi5kYXRhKFxcXCJzdGlja3ktb2Zmc2V0XFxcIiwhMCksZi5hZnRlcignPGRpdiBjbGFzcz1cXFwiZnItc3RpY2t5LWR1bW15XFxcIiBzdHlsZT1cXFwiaGVpZ2h0OiAnK2crJ3B4O1xcXCI+PC9kaXY+JykpLCFoKXt2YXIgcT1cXFwiYXV0b1xcXCIhPT1mLmNzcyhcXFwidG9wXFxcIil8fFxcXCJhdXRvXFxcIiE9PWYuY3NzKFxcXCJib3R0b21cXFwiKTtxfHxmLmNzcyhcXFwicG9zaXRpb25cXFwiLFxcXCJmaXhlZFxcXCIpLGg9e3RvcDpiLm5vZGUuaGFzQ2xhc3MoZi5nZXQoMCksXFxcImZyLXRvcFxcXCIpLGJvdHRvbTpiLm5vZGUuaGFzQ2xhc3MoZi5nZXQoMCksXFxcImZyLWJvdHRvbVxcXCIpfSxxfHxmLmNzcyhcXFwicG9zaXRpb25cXFwiLFxcXCJcXFwiKSxmLmRhdGEoXFxcInN0aWNreS1wb3NpdGlvblxcXCIsaCksZi5kYXRhKFxcXCJ0b3BcXFwiLGIubm9kZS5oYXNDbGFzcyhmLmdldCgwKSxcXFwiZnItdG9wXFxcIik/Zi5jc3MoXFxcInRvcFxcXCIpOlxcXCJhdXRvXFxcIiksZi5kYXRhKFxcXCJib3R0b21cXFwiLGIubm9kZS5oYXNDbGFzcyhmLmdldCgwKSxcXFwiZnItYm90dG9tXFxcIik/Zi5jc3MoXFxcImJvdHRvbVxcXCIpOlxcXCJhdXRvXFxcIil9dmFyIHI9ZnVuY3Rpb24oKXtyZXR1cm4gbzxsK2QmJm8rcC1nPj1sK2R9LHM9ZnVuY3Rpb24oKXtyZXR1cm4gbytnPGwraS1lJiZvK3A+bCtpLWV9O2Q9Yi5oZWxwZXJzLmdldFBYKGYuZGF0YShcXFwidG9wXFxcIikpLGU9Yi5oZWxwZXJzLmdldFBYKGYuZGF0YShcXFwiYm90dG9tXFxcIikpO3ZhciB0PWgudG9wJiZyKCksdT1oLmJvdHRvbSYmcygpO3R8fHU/KGYuY3NzKFxcXCJ3aWR0aFxcXCIsbi53aWR0aCgpK1xcXCJweFxcXCIpLG18fChmLmFkZENsYXNzKFxcXCJmci1zdGlja3ktb25cXFwiKSxmLnJlbW92ZUNsYXNzKFxcXCJmci1zdGlja3ktb2ZmXFxcIiksZi5jc3MoXFxcInRvcFxcXCIpJiYoXFxcImF1dG9cXFwiIT1mLmRhdGEoXFxcInRvcFxcXCIpP2YuY3NzKFxcXCJ0b3BcXFwiLGIuaGVscGVycy5nZXRQWChmLmRhdGEoXFxcInRvcFxcXCIpKStqKTpmLmRhdGEoXFxcInRvcFxcXCIsXFxcImF1dG9cXFwiKSksZi5jc3MoXFxcImJvdHRvbVxcXCIpJiYoXFxcImF1dG9cXFwiIT1mLmRhdGEoXFxcImJvdHRvbVxcXCIpP2YuY3NzKFxcXCJib3R0b21cXFwiLGIuaGVscGVycy5nZXRQWChmLmRhdGEoXFxcImJvdHRvbVxcXCIpKStrKTpmLmNzcyhcXFwiYm90dG9tXFxcIixcXFwiYXV0b1xcXCIpKSkpOmIubm9kZS5oYXNDbGFzcyhmLmdldCgwKSxcXFwiZnItc3RpY2t5LW9mZlxcXCIpfHwoZi53aWR0aChcXFwiXFxcIiksZi5yZW1vdmVDbGFzcyhcXFwiZnItc3RpY2t5LW9uXFxcIiksZi5hZGRDbGFzcyhcXFwiZnItc3RpY2t5LW9mZlxcXCIpLGYuY3NzKFxcXCJ0b3BcXFwiKSYmXFxcImF1dG9cXFwiIT1mLmRhdGEoXFxcInRvcFxcXCIpJiZoLnRvcCYmZi5jc3MoXFxcInRvcFxcXCIsMCksZi5jc3MoXFxcImJvdHRvbVxcXCIpJiZcXFwiYXV0b1xcXCIhPWYuZGF0YShcXFwiYm90dG9tXFxcIikmJmguYm90dG9tJiZmLmNzcyhcXFwiYm90dG9tXFxcIiwwKSl9fWZ1bmN0aW9uIGooKXt2YXIgYT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFxcXCJ0ZXN0XFxcIiksYz1hLnN0eWxlO3JldHVybiBjLmNzc1RleHQ9XFxcInBvc2l0aW9uOlxcXCIrW1xcXCItd2Via2l0LVxcXCIsXFxcIi1tb3otXFxcIixcXFwiLW1zLVxcXCIsXFxcIi1vLVxcXCIsXFxcIlxcXCJdLmpvaW4oXFxcInN0aWNreTsgcG9zaXRpb246XFxcIikrXFxcIiBzdGlja3k7XFxcIixjLnBvc2l0aW9uLmluZGV4T2YoXFxcInN0aWNreVxcXCIpIT09LTEmJiFiLmhlbHBlcnMuaXNJT1MoKSYmIWIuaGVscGVycy5pc0FuZHJvaWQoKX1mdW5jdGlvbiBrKCl7aWYoIWooKSlpZihiLl9zdGlja3lFbGVtZW50cz1bXSxiLmhlbHBlcnMuaXNJT1MoKSl7dmFyIGM9ZnVuY3Rpb24oKXtiLmhlbHBlcnMucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCkoYyk7Zm9yKHZhciBhPTA7YTxiLl9zdGlja3lFbGVtZW50cy5sZW5ndGg7YSsrKWgoYi5fc3RpY2t5RWxlbWVudHNbYV0pfTtjKCksYi5ldmVudHMuJG9uKGEoYi5vX3dpbiksXFxcInNjcm9sbFxcXCIsZnVuY3Rpb24oKXtpZihiLmNvcmUuaGFzRm9jdXMoKSlmb3IodmFyIGM9MDtjPGIuX3N0aWNreUVsZW1lbnRzLmxlbmd0aDtjKyspe3ZhciBkPWEoYi5fc3RpY2t5RWxlbWVudHNbY10pLGU9ZC5wYXJlbnQoKSxmPWEod2luZG93KS5zY3JvbGxUb3AoKTtkLm91dGVySGVpZ2h0KCk8Zi1lLm9mZnNldCgpLnRvcCYmKGQuYWRkQ2xhc3MoXFxcImZyLW9wYWNpdHktMFxcXCIpLGQuZGF0YShcXFwic3RpY2t5LXRvcFxcXCIsLTEpLGQuZGF0YShcXFwic3RpY2t5LXNjaGVkdWxlZFxcXCIsLTEpKX19LCEwKX1lbHNlIGIuZXZlbnRzLiRvbihhKFxcXCJib2R5XFxcIj09Yi5vcHRzLnNjcm9sbGFibGVDb250YWluZXI/Yi5vX3dpbjpiLm9wdHMuc2Nyb2xsYWJsZUNvbnRhaW5lciksXFxcInNjcm9sbFxcXCIsbCwhMCksYi5ldmVudHMuJG9uKGEoYi5vX3dpbiksXFxcInJlc2l6ZVxcXCIsbCwhMCksYi5ldmVudHMub24oXFxcImluaXRpYWxpemVkXFxcIixsKSxiLmV2ZW50cy5vbihcXFwiZm9jdXNcXFwiLGwpLGIuZXZlbnRzLiRvbihhKGIub193aW4pLFxcXCJyZXNpemVcXFwiLFxcXCJ0ZXh0YXJlYVxcXCIsbCwhMCk7Yi5ldmVudHMub24oXFxcImRlc3Ryb3lcXFwiLGZ1bmN0aW9uKGEpe2IuX3N0aWNreUVsZW1lbnRzPVtdfSl9ZnVuY3Rpb24gbCgpe2Zvcih2YXIgYT0wO2E8Yi5fc3RpY2t5RWxlbWVudHMubGVuZ3RoO2ErKylpKGIuX3N0aWNreUVsZW1lbnRzW2FdKX1mdW5jdGlvbiBtKGEpe2EuYWRkQ2xhc3MoXFxcImZyLXN0aWNreVxcXCIpLGIuaGVscGVycy5pc0lPUygpJiZhLmFkZENsYXNzKFxcXCJmci1zdGlja3ktaW9zXFxcIiksaigpfHxiLl9zdGlja3lFbGVtZW50cy5wdXNoKGEuZ2V0KDApKX1mdW5jdGlvbiBuKCl7aygpfXJldHVybntfaW5pdDpuLGZvclNlbGVjdGlvbjpmLGFkZFN0aWNreTptLHJlZnJlc2g6bCxhdDpnLGdldEJvdW5kaW5nUmVjdDpjfX0sYS5GRS5NT0RVTEVTLnJlZnJlc2g9ZnVuY3Rpb24oYil7ZnVuY3Rpb24gYyhhKXtnKGEsIWIudW5kby5jYW5EbygpKX1mdW5jdGlvbiBkKGEpe2coYSwhYi51bmRvLmNhblJlZG8oKSl9ZnVuY3Rpb24gZShhKXtpZihiLm5vZGUuaGFzQ2xhc3MoYS5nZXQoMCksXFxcImZyLW5vLXJlZnJlc2hcXFwiKSlyZXR1cm4hMTtmb3IodmFyIGM9Yi5zZWxlY3Rpb24uYmxvY2tzKCksZD0wO2Q8Yy5sZW5ndGg7ZCsrKXtmb3IodmFyIGU9Y1tkXS5wcmV2aW91c1NpYmxpbmc7ZSYmZS5ub2RlVHlwZT09Tm9kZS5URVhUX05PREUmJjA9PT1lLnRleHRDb250ZW50Lmxlbmd0aDspZT1lLnByZXZpb3VzU2libGluZztpZihcXFwiTElcXFwiIT1jW2RdLnRhZ05hbWV8fGUpcmV0dXJuIGcoYSwhMSksITA7ZyhhLCEwKX19ZnVuY3Rpb24gZihjKXtpZihiLm5vZGUuaGFzQ2xhc3MoYy5nZXQoMCksXFxcImZyLW5vLXJlZnJlc2hcXFwiKSlyZXR1cm4hMTtmb3IodmFyIGQ9Yi5zZWxlY3Rpb24uYmxvY2tzKCksZT0wO2U8ZC5sZW5ndGg7ZSsrKXt2YXIgZj1cXFwicnRsXFxcIj09Yi5vcHRzLmRpcmVjdGlvbnx8XFxcInJ0bFxcXCI9PWEoZFtlXSkuY3NzKFxcXCJkaXJlY3Rpb25cXFwiKT9cXFwibWFyZ2luLXJpZ2h0XFxcIjpcXFwibWFyZ2luLWxlZnRcXFwiO2lmKFxcXCJMSVxcXCI9PWRbZV0udGFnTmFtZXx8XFxcIkxJXFxcIj09ZFtlXS5wYXJlbnROb2RlLnRhZ05hbWUpcmV0dXJuIGcoYywhMSksITA7aWYoYi5oZWxwZXJzLmdldFBYKGEoZFtlXSkuY3NzKGYpKT4wKXJldHVybiBnKGMsITEpLCEwfWcoYywhMCl9ZnVuY3Rpb24gZyhhLGIpe2EudG9nZ2xlQ2xhc3MoXFxcImZyLWRpc2FibGVkXFxcIixiKS5hdHRyKFxcXCJhcmlhLWRpc2FibGVkXFxcIixiKX1yZXR1cm57dW5kbzpjLHJlZG86ZCxvdXRkZW50OmYsaW5kZW50OmV9fSxhLmV4dGVuZChhLkZFLkRFRkFVTFRTLHtlZGl0SW5Qb3B1cDohMX0pLGEuRkUuTU9EVUxFUy50ZXh0RWRpdD1mdW5jdGlvbihiKXtmdW5jdGlvbiBjKCl7dmFyIGE9JzxkaXYgaWQ9XFxcImZyLXRleHQtZWRpdC0nK2IuaWQrJ1xcXCIgY2xhc3M9XFxcImZyLWxheWVyIGZyLXRleHQtZWRpdC1sYXllclxcXCI+PGRpdiBjbGFzcz1cXFwiZnItaW5wdXQtbGluZVxcXCI+PGlucHV0IHR5cGU9XFxcInRleHRcXFwiIHBsYWNlaG9sZGVyPVxcXCInK2IubGFuZ3VhZ2UudHJhbnNsYXRlKFxcXCJUZXh0XFxcIikrJ1xcXCIgdGFiSW5kZXg9XFxcIjFcXFwiPjwvZGl2PjxkaXYgY2xhc3M9XFxcImZyLWFjdGlvbi1idXR0b25zXFxcIj48YnV0dG9uIHR5cGU9XFxcImJ1dHRvblxcXCIgY2xhc3M9XFxcImZyLWNvbW1hbmQgZnItc3VibWl0XFxcIiBkYXRhLWNtZD1cXFwidXBkYXRlVGV4dFxcXCIgdGFiSW5kZXg9XFxcIjJcXFwiPicrYi5sYW5ndWFnZS50cmFuc2xhdGUoXFxcIlVwZGF0ZVxcXCIpK1xcXCI8L2J1dHRvbj48L2Rpdj48L2Rpdj5cXFwiLGM9e2VkaXQ6YX07Yi5wb3B1cHMuY3JlYXRlKFxcXCJ0ZXh0LmVkaXRcXFwiLGMpfWZ1bmN0aW9uIGQoKXt2YXIgYyxkPWIucG9wdXBzLmdldChcXFwidGV4dC5lZGl0XFxcIik7Yz1cXFwiSU5QVVRcXFwiPT09Yi4kZWwucHJvcChcXFwidGFnTmFtZVxcXCIpP2IuJGVsLmF0dHIoXFxcInBsYWNlaG9sZGVyXFxcIik6Yi4kZWwudGV4dCgpLGQuZmluZChcXFwiaW5wdXRcXFwiKS52YWwoYykudHJpZ2dlcihcXFwiY2hhbmdlXFxcIiksYi5wb3B1cHMuc2V0Q29udGFpbmVyKFxcXCJ0ZXh0LmVkaXRcXFwiLGEoXFxcImJvZHlcXFwiKSksYi5wb3B1cHMuc2hvdyhcXFwidGV4dC5lZGl0XFxcIixiLiRlbC5vZmZzZXQoKS5sZWZ0K2IuJGVsLm91dGVyV2lkdGgoKS8yLGIuJGVsLm9mZnNldCgpLnRvcCtiLiRlbC5vdXRlckhlaWdodCgpLGIuJGVsLm91dGVySGVpZ2h0KCkpfWZ1bmN0aW9uIGUoKXtiLmV2ZW50cy4kb24oYi4kZWwsYi5fbW91c2V1cCxmdW5jdGlvbihhKXtzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7ZCgpfSwxMCl9KX1mdW5jdGlvbiBmKCl7dmFyIGE9Yi5wb3B1cHMuZ2V0KFxcXCJ0ZXh0LmVkaXRcXFwiKSxjPWEuZmluZChcXFwiaW5wdXRcXFwiKS52YWwoKTswPT1jLmxlbmd0aCYmKGM9Yi5vcHRzLnBsYWNlaG9sZGVyVGV4dCksXFxcIklOUFVUXFxcIj09PWIuJGVsLnByb3AoXFxcInRhZ05hbWVcXFwiKT9iLiRlbC5hdHRyKFxcXCJwbGFjZWhvbGRlclxcXCIsYyk6Yi4kZWwudGV4dChjKSxiLmV2ZW50cy50cmlnZ2VyKFxcXCJjb250ZW50Q2hhbmdlZFxcXCIpLGIucG9wdXBzLmhpZGUoXFxcInRleHQuZWRpdFxcXCIpfWZ1bmN0aW9uIGcoKXtiLm9wdHMuZWRpdEluUG9wdXAmJihjKCksZSgpKX1yZXR1cm57X2luaXQ6Zyx1cGRhdGU6Zn19LGEuRkUuUmVnaXN0ZXJDb21tYW5kKFxcXCJ1cGRhdGVUZXh0XFxcIix7Zm9jdXM6ITEsdW5kbzohMSxjYWxsYmFjazpmdW5jdGlvbigpe3RoaXMudGV4dEVkaXQudXBkYXRlKCl9fSksYS5leHRlbmQoYS5GRS5ERUZBVUxUUyx7dG9vbGJhckJvdHRvbTohMSx0b29sYmFyQnV0dG9uczpbXFxcImZ1bGxzY3JlZW5cXFwiLFxcXCJib2xkXFxcIixcXFwiaXRhbGljXFxcIixcXFwidW5kZXJsaW5lXFxcIixcXFwic3RyaWtlVGhyb3VnaFxcXCIsXFxcInN1YnNjcmlwdFxcXCIsXFxcInN1cGVyc2NyaXB0XFxcIixcXFwiZm9udEZhbWlseVxcXCIsXFxcImZvbnRTaXplXFxcIixcXFwifFxcXCIsXFxcImNvbG9yXFxcIixcXFwiZW1vdGljb25zXFxcIixcXFwiaW5saW5lU3R5bGVcXFwiLFxcXCJwYXJhZ3JhcGhTdHlsZVxcXCIsXFxcInxcXFwiLFxcXCJwYXJhZ3JhcGhGb3JtYXRcXFwiLFxcXCJhbGlnblxcXCIsXFxcImZvcm1hdE9MXFxcIixcXFwiZm9ybWF0VUxcXFwiLFxcXCJvdXRkZW50XFxcIixcXFwiaW5kZW50XFxcIixcXFwicXVvdGVcXFwiLFxcXCJpbnNlcnRIUlxcXCIsXFxcIi1cXFwiLFxcXCJpbnNlcnRMaW5rXFxcIixcXFwiaW5zZXJ0SW1hZ2VcXFwiLFxcXCJpbnNlcnRWaWRlb1xcXCIsXFxcImluc2VydEZpbGVcXFwiLFxcXCJpbnNlcnRUYWJsZVxcXCIsXFxcInVuZG9cXFwiLFxcXCJyZWRvXFxcIixcXFwiY2xlYXJGb3JtYXR0aW5nXFxcIixcXFwic2VsZWN0QWxsXFxcIixcXFwiaHRtbFxcXCIsXFxcImFwcGx5Rm9ybWF0XFxcIixcXFwicmVtb3ZlRm9ybWF0XFxcIixcXFwiaGVscFxcXCJdLHRvb2xiYXJCdXR0b25zWFM6W1xcXCJib2xkXFxcIixcXFwiaXRhbGljXFxcIixcXFwiZm9udEZhbWlseVxcXCIsXFxcImZvbnRTaXplXFxcIixcXFwifFxcXCIsXFxcInVuZG9cXFwiLFxcXCJyZWRvXFxcIixcXFwiaGVscFxcXCJdLHRvb2xiYXJCdXR0b25zU006W1xcXCJib2xkXFxcIixcXFwiaXRhbGljXFxcIixcXFwidW5kZXJsaW5lXFxcIixcXFwifFxcXCIsXFxcImZvbnRGYW1pbHlcXFwiLFxcXCJmb250U2l6ZVxcXCIsXFxcImluc2VydExpbmtcXFwiLFxcXCJpbnNlcnRJbWFnZVxcXCIsXFxcInRhYmxlXFxcIixcXFwifFxcXCIsXFxcInVuZG9cXFwiLFxcXCJyZWRvXFxcIixcXFwiaGVscFxcXCJdLHRvb2xiYXJCdXR0b25zTUQ6W1xcXCJmdWxsc2NyZWVuXFxcIixcXFwiYm9sZFxcXCIsXFxcIml0YWxpY1xcXCIsXFxcInVuZGVybGluZVxcXCIsXFxcImZvbnRGYW1pbHlcXFwiLFxcXCJmb250U2l6ZVxcXCIsXFxcImNvbG9yXFxcIixcXFwicGFyYWdyYXBoU3R5bGVcXFwiLFxcXCJwYXJhZ3JhcGhGb3JtYXRcXFwiLFxcXCJhbGlnblxcXCIsXFxcImZvcm1hdE9MXFxcIixcXFwiZm9ybWF0VUxcXFwiLFxcXCJvdXRkZW50XFxcIixcXFwiaW5kZW50XFxcIixcXFwicXVvdGVcXFwiLFxcXCJpbnNlcnRIUlxcXCIsXFxcIi1cXFwiLFxcXCJpbnNlcnRMaW5rXFxcIixcXFwiaW5zZXJ0SW1hZ2VcXFwiLFxcXCJpbnNlcnRWaWRlb1xcXCIsXFxcImluc2VydEZpbGVcXFwiLFxcXCJpbnNlcnRUYWJsZVxcXCIsXFxcInVuZG9cXFwiLFxcXCJyZWRvXFxcIixcXFwiY2xlYXJGb3JtYXR0aW5nXFxcIixcXFwiaGVscFxcXCJdLHRvb2xiYXJDb250YWluZXI6bnVsbCx0b29sYmFySW5saW5lOiExLHRvb2xiYXJTdGlja3k6ITAsdG9vbGJhclN0aWNreU9mZnNldDowLHRvb2xiYXJWaXNpYmxlV2l0aG91dFNlbGVjdGlvbjohMX0pLGEuRkUuTU9EVUxFUy50b29sYmFyPWZ1bmN0aW9uKGIpe2Z1bmN0aW9uIGMoYSxiKXtmb3IodmFyIGM9MDtjPGIubGVuZ3RoO2MrKylcXFwiLVxcXCIhPWJbY10mJlxcXCJ8XFxcIiE9YltjXSYmYS5pbmRleE9mKGJbY10pPDAmJmEucHVzaChiW2NdKX1mdW5jdGlvbiBkKCl7dmFyIGQ9YS5tZXJnZShbXSxlKCkpO2MoZCxiLm9wdHMudG9vbGJhckJ1dHRvbnNYU3x8W10pLGMoZCxiLm9wdHMudG9vbGJhckJ1dHRvbnNTTXx8W10pLGMoZCxiLm9wdHMudG9vbGJhckJ1dHRvbnNNRHx8W10pLGMoZCxiLm9wdHMudG9vbGJhckJ1dHRvbnMpO2Zvcih2YXIgZj1kLmxlbmd0aC0xO2Y+PTA7Zi0tKVxcXCItXFxcIiE9ZFtmXSYmXFxcInxcXFwiIT1kW2ZdJiZkLmluZGV4T2YoZFtmXSk8ZiYmZC5zcGxpY2UoZiwxKTt2YXIgZz1iLmJ1dHRvbi5idWlsZExpc3QoZCxlKCkpO2IuJHRiLmFwcGVuZChnKSxiLmJ1dHRvbi5iaW5kQ29tbWFuZHMoYi4kdGIpfWZ1bmN0aW9uIGUoKXt2YXIgYT1iLmhlbHBlcnMuc2NyZWVuU2l6ZSgpO3JldHVybiB1W2FdfWZ1bmN0aW9uIGYoKXt2YXIgYT1lKCk7Yi4kdGIuZmluZChcXFwiLmZyLXNlcGFyYXRvclxcXCIpLnJlbW92ZSgpLGIuJHRiLmZpbmQoXFxcIj4gLmZyLWNvbW1hbmRcXFwiKS5hZGRDbGFzcyhcXFwiZnItaGlkZGVuXFxcIik7Zm9yKHZhciBjPTA7YzxhLmxlbmd0aDtjKyspaWYoXFxcInxcXFwiPT1hW2NdfHxcXFwiLVxcXCI9PWFbY10pYi4kdGIuYXBwZW5kKGIuYnV0dG9uLmJ1aWxkTGlzdChbYVtjXV0pKTtlbHNle3ZhciBkPWIuJHRiLmZpbmQoJz4gLmZyLWNvbW1hbmRbZGF0YS1jbWQ9XFxcIicrYVtjXSsnXFxcIl0nKSxmPW51bGw7Yi5ub2RlLmhhc0NsYXNzKGQubmV4dCgpLmdldCgwKSxcXFwiZnItZHJvcGRvd24tbWVudVxcXCIpJiYoZj1kLm5leHQoKSksZC5yZW1vdmVDbGFzcyhcXFwiZnItaGlkZGVuXFxcIikuYXBwZW5kVG8oYi4kdGIpLGYmJmYuYXBwZW5kVG8oYi4kdGIpfX1mdW5jdGlvbiBnKCl7Yi5ldmVudHMuJG9uKGEoYi5vX3dpbiksXFxcInJlc2l6ZVxcXCIsZiksYi5ldmVudHMuJG9uKGEoYi5vX3dpbiksXFxcIm9yaWVudGF0aW9uY2hhbmdlXFxcIixmKX1mdW5jdGlvbiBoKGMsZCl7c2V0VGltZW91dChmdW5jdGlvbigpe2lmKGMmJmMud2hpY2g9PWEuRkUuS0VZQ09ERS5FU0MpO2Vsc2UgaWYoYi5zZWxlY3Rpb24uaW5FZGl0b3IoKSYmYi5jb3JlLmhhc0ZvY3VzKCkmJiFiLnBvcHVwcy5hcmVWaXNpYmxlKCkmJihiLm9wdHMudG9vbGJhclZpc2libGVXaXRob3V0U2VsZWN0aW9uJiZjJiZcXFwia2V5dXBcXFwiIT1jLnR5cGV8fCFiLnNlbGVjdGlvbi5pc0NvbGxhcHNlZCgpJiYhYi5rZXlzLmlzSU1FKCl8fGQpKXtpZihiLiR0Yi5kYXRhKFxcXCJpbnN0YW5jZVxcXCIsYiksMD09Yi5ldmVudHMudHJpZ2dlcihcXFwidG9vbGJhci5zaG93XFxcIixbY10pKXJldHVybiExO2Iub3B0cy50b29sYmFyQ29udGFpbmVyfHxiLnBvc2l0aW9uLmZvclNlbGVjdGlvbihiLiR0YiksYi5vcHRzLnpJbmRleD4xP2IuJHRiLmNzcyhcXFwiei1pbmRleFxcXCIsYi5vcHRzLnpJbmRleCsxKTpiLiR0Yi5jc3MoXFxcInotaW5kZXhcXFwiLG51bGwpLGIuJHRiLnNob3coKX19LDApfWZ1bmN0aW9uIGkoYyl7dmFyIGQ9YShcXFwiLmZyLWRyb3Bkb3duLmZyLWFjdGl2ZVxcXCIpO3JldHVybiEhZC5uZXh0KCkuZmluZChiLm9fZG9jLmFjdGl2ZUVsZW1lbnQpLmxlbmd0aHx8dm9pZChiLmV2ZW50cy50cmlnZ2VyKFxcXCJ0b29sYmFyLmhpZGVcXFwiKSE9PSExJiZiLiR0Yi5oaWRlKCkpfWZ1bmN0aW9uIGooKXtyZXR1cm4gMCE9Yi5ldmVudHMudHJpZ2dlcihcXFwidG9vbGJhci5zaG93XFxcIikmJnZvaWQgYi4kdGIuc2hvdygpfWZ1bmN0aW9uIGsoKXtiLmV2ZW50cy5vbihcXFwid2luZG93Lm1vdXNlZG93blxcXCIsaSksYi5ldmVudHMub24oXFxcImtleWRvd25cXFwiLGkpLGIuZXZlbnRzLm9uKFxcXCJibHVyXFxcIixpKSxiLmV2ZW50cy5vbihcXFwid2luZG93Lm1vdXNldXBcXFwiLGgpLGIuaGVscGVycy5pc01vYmlsZSgpP2IuaGVscGVycy5pc0lPUygpfHwoYi5ldmVudHMub24oXFxcIndpbmRvdy50b3VjaGVuZFxcXCIsaCksYi5icm93c2VyLm1vemlsbGEmJnNldEludGVydmFsKGgsMjAwKSk6Yi5ldmVudHMub24oXFxcIndpbmRvdy5rZXl1cFxcXCIsaCksYi5ldmVudHMub24oXFxcImtleWRvd25cXFwiLGZ1bmN0aW9uKGIpe2ImJmIud2hpY2g9PWEuRkUuS0VZQ09ERS5FU0MmJmkoKX0pLGIuZXZlbnRzLm9uKFxcXCJrZXlkb3duXFxcIixmdW5jdGlvbihiKXtpZihiLndoaWNoPT1hLkZFLktFWUNPREUuQUxUKXJldHVybiBiLnN0b3BQcm9wYWdhdGlvbigpLCExfSwhMCksYi5ldmVudHMuJG9uKGIuJHdwLFxcXCJzY3JvbGwudG9vbGJhclxcXCIsaCksYi5ldmVudHMub24oXFxcImNvbW1hbmRzLmFmdGVyXFxcIixoKSxiLmhlbHBlcnMuaXNNb2JpbGUoKSYmKGIuZXZlbnRzLiRvbihiLiRkb2MsXFxcInNlbGVjdGlvbmNoYW5nZVxcXCIsaCksYi5ldmVudHMuJG9uKGIuJGRvYyxcXFwib3JpZW50YXRpb25jaGFuZ2VcXFwiLGgpKX1mdW5jdGlvbiBsKCl7Yi5vcHRzLnRvb2xiYXJJbmxpbmU/KGEoYi5vcHRzLnNjcm9sbGFibGVDb250YWluZXIpLmFwcGVuZChiLiR0YiksYi4kdGIuZGF0YShcXFwiY29udGFpbmVyXFxcIixhKGIub3B0cy5zY3JvbGxhYmxlQ29udGFpbmVyKSksYi4kdGIuYWRkQ2xhc3MoXFxcImZyLWlubGluZVxcXCIpLGIuJHRiLnByZXBlbmQoJzxzcGFuIGNsYXNzPVxcXCJmci1hcnJvd1xcXCI+PC9zcGFuPicpLGsoKSxiLm9wdHMudG9vbGJhckJvdHRvbT0hMSk6KGIub3B0cy50b29sYmFyQm90dG9tJiYhYi5oZWxwZXJzLmlzSU9TKCk/KGIuJGJveC5hcHBlbmQoYi4kdGIpLGIuJHRiLmFkZENsYXNzKFxcXCJmci1ib3R0b21cXFwiKSxiLiRib3guYWRkQ2xhc3MoXFxcImZyLWJvdHRvbVxcXCIpKTooYi5vcHRzLnRvb2xiYXJCb3R0b209ITEsYi4kYm94LnByZXBlbmQoYi4kdGIpLGIuJHRiLmFkZENsYXNzKFxcXCJmci10b3BcXFwiKSxiLiRib3guYWRkQ2xhc3MoXFxcImZyLXRvcFxcXCIpKSxiLiR0Yi5hZGRDbGFzcyhcXFwiZnItYmFzaWNcXFwiKSxiLm9wdHMudG9vbGJhclN0aWNreSYmKGIub3B0cy50b29sYmFyU3RpY2t5T2Zmc2V0JiYoYi5vcHRzLnRvb2xiYXJCb3R0b20/Yi4kdGIuY3NzKFxcXCJib3R0b21cXFwiLGIub3B0cy50b29sYmFyU3RpY2t5T2Zmc2V0KTpiLiR0Yi5jc3MoXFxcInRvcFxcXCIsYi5vcHRzLnRvb2xiYXJTdGlja3lPZmZzZXQpKSxiLnBvc2l0aW9uLmFkZFN0aWNreShiLiR0YikpKX1mdW5jdGlvbiBtKCl7Yi4kdGIuaHRtbChcXFwiXFxcIikucmVtb3ZlRGF0YSgpLnJlbW92ZSgpLGIuJHRiPW51bGx9ZnVuY3Rpb24gbigpe2IuJGJveC5yZW1vdmVDbGFzcyhcXFwiZnItdG9wIGZyLWJvdHRvbSBmci1pbmxpbmUgZnItYmFzaWNcXFwiKSxiLiRib3guZmluZChcXFwiLmZyLXN0aWNreS1kdW1teVxcXCIpLnJlbW92ZSgpfWZ1bmN0aW9uIG8oKXtiLm9wdHMudGhlbWUmJmIuJHRiLmFkZENsYXNzKGIub3B0cy50aGVtZStcXFwiLXRoZW1lXFxcIiksYi5vcHRzLnpJbmRleD4xJiZiLiR0Yi5jc3MoXFxcInotaW5kZXhcXFwiLGIub3B0cy56SW5kZXgrMSksXFxcImF1dG9cXFwiIT1iLm9wdHMuZGlyZWN0aW9uJiZiLiR0Yi5yZW1vdmVDbGFzcyhcXFwiZnItbHRyIGZyLXJ0bFxcXCIpLmFkZENsYXNzKFxcXCJmci1cXFwiK2Iub3B0cy5kaXJlY3Rpb24pLGIuaGVscGVycy5pc01vYmlsZSgpP2IuJHRiLmFkZENsYXNzKFxcXCJmci1tb2JpbGVcXFwiKTpiLiR0Yi5hZGRDbGFzcyhcXFwiZnItZGVza3RvcFxcXCIpLGIub3B0cy50b29sYmFyQ29udGFpbmVyPyhiLm9wdHMudG9vbGJhcklubGluZSYmKGsoKSxpKCkpLGIub3B0cy50b29sYmFyQm90dG9tP2IuJHRiLmFkZENsYXNzKFxcXCJmci1ib3R0b21cXFwiKTpiLiR0Yi5hZGRDbGFzcyhcXFwiZnItdG9wXFxcIikpOmwoKSxzPWIuJHRiLmdldCgwKS5vd25lckRvY3VtZW50LHQ9XFxcImRlZmF1bHRWaWV3XFxcImluIHM/cy5kZWZhdWx0VmlldzpzLnBhcmVudFdpbmRvdyxkKCksZygpLGIuYWNjZXNzaWJpbGl0eS5yZWdpc3RlclRvb2xiYXIoYi4kdGIpLGIuZXZlbnRzLiRvbihiLiR0YixiLl9tb3VzZWRvd24rXFxcIiBcXFwiK2IuX21vdXNldXAsZnVuY3Rpb24oYSl7dmFyIGM9YS5vcmlnaW5hbEV2ZW50P2Eub3JpZ2luYWxFdmVudC50YXJnZXR8fGEub3JpZ2luYWxFdmVudC5vcmlnaW5hbFRhcmdldDpudWxsO2lmKGMmJlxcXCJJTlBVVFxcXCIhPWMudGFnTmFtZSYmIWIuZWRpdC5pc0Rpc2FibGVkKCkpcmV0dXJuIGEuc3RvcFByb3BhZ2F0aW9uKCksYS5wcmV2ZW50RGVmYXVsdCgpLCExfSwhMCl9ZnVuY3Rpb24gcCgpe3JldHVybiEhYi4kd3AmJihiLm9wdHMudG9vbGJhckNvbnRhaW5lcj8oYi5zaGFyZWQuJHRiPyhiLiR0Yj1iLnNoYXJlZC4kdGIsYi5vcHRzLnRvb2xiYXJJbmxpbmUmJmsoKSk6KGIuc2hhcmVkLiR0Yj1hKCc8ZGl2IGNsYXNzPVxcXCJmci10b29sYmFyXFxcIj48L2Rpdj4nKSxiLiR0Yj1iLnNoYXJlZC4kdGIsYShiLm9wdHMudG9vbGJhckNvbnRhaW5lcikuYXBwZW5kKGIuJHRiKSxvKCksYi4kdGIuZGF0YShcXFwiaW5zdGFuY2VcXFwiLGIpKSxiLm9wdHMudG9vbGJhcklubGluZT9iLiRib3guYWRkQ2xhc3MoXFxcImZyLWlubGluZVxcXCIpOmIuJGJveC5hZGRDbGFzcyhcXFwiZnItYmFzaWNcXFwiKSxiLmV2ZW50cy5vbihcXFwiZm9jdXNcXFwiLGZ1bmN0aW9uKCl7Yi4kdGIuZGF0YShcXFwiaW5zdGFuY2VcXFwiLGIpfSwhMCksYi5vcHRzLnRvb2xiYXJJbmxpbmU9ITEpOmIub3B0cy50b29sYmFySW5saW5lPyhiLiRib3guYWRkQ2xhc3MoXFxcImZyLWlubGluZVxcXCIpLGIuc2hhcmVkLiR0Yj8oYi4kdGI9Yi5zaGFyZWQuJHRiLGsoKSk6KGIuc2hhcmVkLiR0Yj1hKCc8ZGl2IGNsYXNzPVxcXCJmci10b29sYmFyXFxcIj48L2Rpdj4nKSxiLiR0Yj1iLnNoYXJlZC4kdGIsbygpKSk6KGIuJGJveC5hZGRDbGFzcyhcXFwiZnItYmFzaWNcXFwiKSxiLiR0Yj1hKCc8ZGl2IGNsYXNzPVxcXCJmci10b29sYmFyXFxcIj48L2Rpdj4nKSxvKCksYi4kdGIuZGF0YShcXFwiaW5zdGFuY2VcXFwiLGIpKSxiLmV2ZW50cy5vbihcXFwiZGVzdHJveVxcXCIsbiwhMCksdm9pZCBiLmV2ZW50cy5vbihiLm9wdHMudG9vbGJhcklubGluZXx8Yi5vcHRzLnRvb2xiYXJDb250YWluZXI/XFxcInNoYXJlZC5kZXN0cm95XFxcIjpcXFwiZGVzdHJveVxcXCIsbSwhMCkpfWZ1bmN0aW9uIHEoKXshdiYmYi4kdGImJihiLiR0Yi5maW5kKFxcXCI+IC5mci1jb21tYW5kXFxcIikuYWRkQ2xhc3MoXFxcImZyLWRpc2FibGVkIGZyLW5vLXJlZnJlc2hcXFwiKS5hdHRyKFxcXCJhcmlhLWRpc2FibGVkXFxcIiwhMCksdj0hMCl9ZnVuY3Rpb24gcigpe3YmJmIuJHRiJiYoYi4kdGIuZmluZChcXFwiPiAuZnItY29tbWFuZFxcXCIpLnJlbW92ZUNsYXNzKFxcXCJmci1kaXNhYmxlZCBmci1uby1yZWZyZXNoXFxcIikuYXR0cihcXFwiYXJpYS1kaXNhYmxlZFxcXCIsITEpLHY9ITEpLGIuYnV0dG9uLmJ1bGtSZWZyZXNoKCl9dmFyIHMsdCx1PVtdO3VbYS5GRS5YU109Yi5vcHRzLnRvb2xiYXJCdXR0b25zWFN8fGIub3B0cy50b29sYmFyQnV0dG9ucyx1W2EuRkUuU01dPWIub3B0cy50b29sYmFyQnV0dG9uc1NNfHxiLm9wdHMudG9vbGJhckJ1dHRvbnMsdVthLkZFLk1EXT1iLm9wdHMudG9vbGJhckJ1dHRvbnNNRHx8Yi5vcHRzLnRvb2xiYXJCdXR0b25zLHVbYS5GRS5MR109Yi5vcHRzLnRvb2xiYXJCdXR0b25zO3ZhciB2PSExO3JldHVybntfaW5pdDpwLGhpZGU6aSxzaG93Omosc2hvd0lubGluZTpoLGRpc2FibGU6cSxlbmFibGU6cn19fSk7XCJcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcmF3LWxvYWRlciEuL34vZnJvYWxhLWVkaXRvci9qcy9mcm9hbGFfZWRpdG9yLm1pbi5qc1xuLy8gbW9kdWxlIGlkID0gM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	eval("__webpack_require__(2)(__webpack_require__(5))//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL34vY29kZW1pcnJvci9saWIvY29kZW1pcnJvci5qcz8yNTI1Il0sInNvdXJjZXNDb250ZW50IjpbInJlcXVpcmUoXCIhIS92YXIvYXBwL3dlYi9qcy9ub2RlX21vZHVsZXMvc2NyaXB0LWxvYWRlci9hZGRTY3JpcHQuanNcIikocmVxdWlyZShcIiEhL3Zhci9hcHAvd2ViL2pzL25vZGVfbW9kdWxlcy9yYXctbG9hZGVyL2luZGV4LmpzIS92YXIvYXBwL3dlYi9qcy9ub2RlX21vZHVsZXMvY29kZW1pcnJvci9saWIvY29kZW1pcnJvci5qc1wiKSlcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vc2NyaXB0LWxvYWRlciEuL34vY29kZW1pcnJvci9saWIvY29kZW1pcnJvci5qc1xuLy8gbW9kdWxlIGlkID0gNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 5 */
/***/ function(module, exports) {

	eval("module.exports = \"// CodeMirror, copyright (c) by Marijn Haverbeke and others\\n// Distributed under an MIT license: http://codemirror.net/LICENSE\\n\\n// This is CodeMirror (http://codemirror.net), a code editor\\n// implemented in JavaScript on top of the browser's DOM.\\n//\\n// You can find some technical background for some of the code below\\n// at http://marijnhaverbeke.nl/blog/#cm-internals .\\n\\n(function (global, factory) {\\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\\n  typeof define === 'function' && define.amd ? define(factory) :\\n  (global.CodeMirror = factory());\\n}(this, (function () { 'use strict';\\n\\n// Kludges for bugs and behavior differences that can't be feature\\n// detected are enabled based on userAgent etc sniffing.\\nvar userAgent = navigator.userAgent\\nvar platform = navigator.platform\\n\\nvar gecko = /gecko\\\\/\\\\d/i.test(userAgent)\\nvar ie_upto10 = /MSIE \\\\d/.test(userAgent)\\nvar ie_11up = /Trident\\\\/(?:[7-9]|\\\\d{2,})\\\\..*rv:(\\\\d+)/.exec(userAgent)\\nvar ie = ie_upto10 || ie_11up\\nvar ie_version = ie && (ie_upto10 ? document.documentMode || 6 : ie_11up[1])\\nvar webkit = /WebKit\\\\//.test(userAgent)\\nvar qtwebkit = webkit && /Qt\\\\/\\\\d+\\\\.\\\\d+/.test(userAgent)\\nvar chrome = /Chrome\\\\//.test(userAgent)\\nvar presto = /Opera\\\\//.test(userAgent)\\nvar safari = /Apple Computer/.test(navigator.vendor)\\nvar mac_geMountainLion = /Mac OS X 1\\\\d\\\\D([8-9]|\\\\d\\\\d)\\\\D/.test(userAgent)\\nvar phantom = /PhantomJS/.test(userAgent)\\n\\nvar ios = /AppleWebKit/.test(userAgent) && /Mobile\\\\/\\\\w+/.test(userAgent)\\n// This is woefully incomplete. Suggestions for alternative methods welcome.\\nvar mobile = ios || /Android|webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(userAgent)\\nvar mac = ios || /Mac/.test(platform)\\nvar chromeOS = /\\\\bCrOS\\\\b/.test(userAgent)\\nvar windows = /win/i.test(platform)\\n\\nvar presto_version = presto && userAgent.match(/Version\\\\/(\\\\d*\\\\.\\\\d*)/)\\nif (presto_version) { presto_version = Number(presto_version[1]) }\\nif (presto_version && presto_version >= 15) { presto = false; webkit = true }\\n// Some browsers use the wrong event properties to signal cmd/ctrl on OS X\\nvar flipCtrlCmd = mac && (qtwebkit || presto && (presto_version == null || presto_version < 12.11))\\nvar captureRightClick = gecko || (ie && ie_version >= 9)\\n\\nfunction classTest(cls) { return new RegExp(\\\"(^|\\\\\\\\s)\\\" + cls + \\\"(?:$|\\\\\\\\s)\\\\\\\\s*\\\") }\\n\\nvar rmClass = function(node, cls) {\\n  var current = node.className\\n  var match = classTest(cls).exec(current)\\n  if (match) {\\n    var after = current.slice(match.index + match[0].length)\\n    node.className = current.slice(0, match.index) + (after ? match[1] + after : \\\"\\\")\\n  }\\n}\\n\\nfunction removeChildren(e) {\\n  for (var count = e.childNodes.length; count > 0; --count)\\n    { e.removeChild(e.firstChild) }\\n  return e\\n}\\n\\nfunction removeChildrenAndAdd(parent, e) {\\n  return removeChildren(parent).appendChild(e)\\n}\\n\\nfunction elt(tag, content, className, style) {\\n  var e = document.createElement(tag)\\n  if (className) { e.className = className }\\n  if (style) { e.style.cssText = style }\\n  if (typeof content == \\\"string\\\") { e.appendChild(document.createTextNode(content)) }\\n  else if (content) { for (var i = 0; i < content.length; ++i) { e.appendChild(content[i]) } }\\n  return e\\n}\\n\\nvar range\\nif (document.createRange) { range = function(node, start, end, endNode) {\\n  var r = document.createRange()\\n  r.setEnd(endNode || node, end)\\n  r.setStart(node, start)\\n  return r\\n} }\\nelse { range = function(node, start, end) {\\n  var r = document.body.createTextRange()\\n  try { r.moveToElementText(node.parentNode) }\\n  catch(e) { return r }\\n  r.collapse(true)\\n  r.moveEnd(\\\"character\\\", end)\\n  r.moveStart(\\\"character\\\", start)\\n  return r\\n} }\\n\\nfunction contains(parent, child) {\\n  if (child.nodeType == 3) // Android browser always returns false when child is a textnode\\n    { child = child.parentNode }\\n  if (parent.contains)\\n    { return parent.contains(child) }\\n  do {\\n    if (child.nodeType == 11) { child = child.host }\\n    if (child == parent) { return true }\\n  } while (child = child.parentNode)\\n}\\n\\nfunction activeElt() {\\n  // IE and Edge may throw an \\\"Unspecified Error\\\" when accessing document.activeElement.\\n  // IE < 10 will throw when accessed while the page is loading or in an iframe.\\n  // IE > 9 and Edge will throw when accessed in an iframe if document.body is unavailable.\\n  var activeElement\\n  try {\\n    activeElement = document.activeElement\\n  } catch(e) {\\n    activeElement = document.body || null\\n  }\\n  while (activeElement && activeElement.root && activeElement.root.activeElement)\\n    { activeElement = activeElement.root.activeElement }\\n  return activeElement\\n}\\n\\nfunction addClass(node, cls) {\\n  var current = node.className\\n  if (!classTest(cls).test(current)) { node.className += (current ? \\\" \\\" : \\\"\\\") + cls }\\n}\\nfunction joinClasses(a, b) {\\n  var as = a.split(\\\" \\\")\\n  for (var i = 0; i < as.length; i++)\\n    { if (as[i] && !classTest(as[i]).test(b)) { b += \\\" \\\" + as[i] } }\\n  return b\\n}\\n\\nvar selectInput = function(node) { node.select() }\\nif (ios) // Mobile Safari apparently has a bug where select() is broken.\\n  { selectInput = function(node) { node.selectionStart = 0; node.selectionEnd = node.value.length } }\\nelse if (ie) // Suppress mysterious IE10 errors\\n  { selectInput = function(node) { try { node.select() } catch(_e) {} } }\\n\\nfunction bind(f) {\\n  var args = Array.prototype.slice.call(arguments, 1)\\n  return function(){return f.apply(null, args)}\\n}\\n\\nfunction copyObj(obj, target, overwrite) {\\n  if (!target) { target = {} }\\n  for (var prop in obj)\\n    { if (obj.hasOwnProperty(prop) && (overwrite !== false || !target.hasOwnProperty(prop)))\\n      { target[prop] = obj[prop] } }\\n  return target\\n}\\n\\n// Counts the column offset in a string, taking tabs into account.\\n// Used mostly to find indentation.\\nfunction countColumn(string, end, tabSize, startIndex, startValue) {\\n  if (end == null) {\\n    end = string.search(/[^\\\\s\\\\u00a0]/)\\n    if (end == -1) { end = string.length }\\n  }\\n  for (var i = startIndex || 0, n = startValue || 0;;) {\\n    var nextTab = string.indexOf(\\\"\\\\t\\\", i)\\n    if (nextTab < 0 || nextTab >= end)\\n      { return n + (end - i) }\\n    n += nextTab - i\\n    n += tabSize - (n % tabSize)\\n    i = nextTab + 1\\n  }\\n}\\n\\nfunction Delayed() {this.id = null}\\nDelayed.prototype.set = function(ms, f) {\\n  clearTimeout(this.id)\\n  this.id = setTimeout(f, ms)\\n}\\n\\nfunction indexOf(array, elt) {\\n  for (var i = 0; i < array.length; ++i)\\n    { if (array[i] == elt) { return i } }\\n  return -1\\n}\\n\\n// Number of pixels added to scroller and sizer to hide scrollbar\\nvar scrollerGap = 30\\n\\n// Returned or thrown by various protocols to signal 'I'm not\\n// handling this'.\\nvar Pass = {toString: function(){return \\\"CodeMirror.Pass\\\"}}\\n\\n// Reused option objects for setSelection & friends\\nvar sel_dontScroll = {scroll: false};\\nvar sel_mouse = {origin: \\\"*mouse\\\"};\\nvar sel_move = {origin: \\\"+move\\\"};\\n// The inverse of countColumn -- find the offset that corresponds to\\n// a particular column.\\nfunction findColumn(string, goal, tabSize) {\\n  for (var pos = 0, col = 0;;) {\\n    var nextTab = string.indexOf(\\\"\\\\t\\\", pos)\\n    if (nextTab == -1) { nextTab = string.length }\\n    var skipped = nextTab - pos\\n    if (nextTab == string.length || col + skipped >= goal)\\n      { return pos + Math.min(skipped, goal - col) }\\n    col += nextTab - pos\\n    col += tabSize - (col % tabSize)\\n    pos = nextTab + 1\\n    if (col >= goal) { return pos }\\n  }\\n}\\n\\nvar spaceStrs = [\\\"\\\"]\\nfunction spaceStr(n) {\\n  while (spaceStrs.length <= n)\\n    { spaceStrs.push(lst(spaceStrs) + \\\" \\\") }\\n  return spaceStrs[n]\\n}\\n\\nfunction lst(arr) { return arr[arr.length-1] }\\n\\nfunction map(array, f) {\\n  var out = []\\n  for (var i = 0; i < array.length; i++) { out[i] = f(array[i], i) }\\n  return out\\n}\\n\\nfunction insertSorted(array, value, score) {\\n  var pos = 0, priority = score(value)\\n  while (pos < array.length && score(array[pos]) <= priority) { pos++ }\\n  array.splice(pos, 0, value)\\n}\\n\\nfunction nothing() {}\\n\\nfunction createObj(base, props) {\\n  var inst\\n  if (Object.create) {\\n    inst = Object.create(base)\\n  } else {\\n    nothing.prototype = base\\n    inst = new nothing()\\n  }\\n  if (props) { copyObj(props, inst) }\\n  return inst\\n}\\n\\nvar nonASCIISingleCaseWordChar = /[\\\\u00df\\\\u0587\\\\u0590-\\\\u05f4\\\\u0600-\\\\u06ff\\\\u3040-\\\\u309f\\\\u30a0-\\\\u30ff\\\\u3400-\\\\u4db5\\\\u4e00-\\\\u9fcc\\\\uac00-\\\\ud7af]/\\nfunction isWordCharBasic(ch) {\\n  return /\\\\w/.test(ch) || ch > \\\"\\\\x80\\\" &&\\n    (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch))\\n}\\nfunction isWordChar(ch, helper) {\\n  if (!helper) { return isWordCharBasic(ch) }\\n  if (helper.source.indexOf(\\\"\\\\\\\\w\\\") > -1 && isWordCharBasic(ch)) { return true }\\n  return helper.test(ch)\\n}\\n\\nfunction isEmpty(obj) {\\n  for (var n in obj) { if (obj.hasOwnProperty(n) && obj[n]) { return false } }\\n  return true\\n}\\n\\n// Extending unicode characters. A series of a non-extending char +\\n// any number of extending chars is treated as a single unit as far\\n// as editing and measuring is concerned. This is not fully correct,\\n// since some scripts/fonts/browsers also treat other configurations\\n// of code points as a group.\\nvar extendingChars = /[\\\\u0300-\\\\u036f\\\\u0483-\\\\u0489\\\\u0591-\\\\u05bd\\\\u05bf\\\\u05c1\\\\u05c2\\\\u05c4\\\\u05c5\\\\u05c7\\\\u0610-\\\\u061a\\\\u064b-\\\\u065e\\\\u0670\\\\u06d6-\\\\u06dc\\\\u06de-\\\\u06e4\\\\u06e7\\\\u06e8\\\\u06ea-\\\\u06ed\\\\u0711\\\\u0730-\\\\u074a\\\\u07a6-\\\\u07b0\\\\u07eb-\\\\u07f3\\\\u0816-\\\\u0819\\\\u081b-\\\\u0823\\\\u0825-\\\\u0827\\\\u0829-\\\\u082d\\\\u0900-\\\\u0902\\\\u093c\\\\u0941-\\\\u0948\\\\u094d\\\\u0951-\\\\u0955\\\\u0962\\\\u0963\\\\u0981\\\\u09bc\\\\u09be\\\\u09c1-\\\\u09c4\\\\u09cd\\\\u09d7\\\\u09e2\\\\u09e3\\\\u0a01\\\\u0a02\\\\u0a3c\\\\u0a41\\\\u0a42\\\\u0a47\\\\u0a48\\\\u0a4b-\\\\u0a4d\\\\u0a51\\\\u0a70\\\\u0a71\\\\u0a75\\\\u0a81\\\\u0a82\\\\u0abc\\\\u0ac1-\\\\u0ac5\\\\u0ac7\\\\u0ac8\\\\u0acd\\\\u0ae2\\\\u0ae3\\\\u0b01\\\\u0b3c\\\\u0b3e\\\\u0b3f\\\\u0b41-\\\\u0b44\\\\u0b4d\\\\u0b56\\\\u0b57\\\\u0b62\\\\u0b63\\\\u0b82\\\\u0bbe\\\\u0bc0\\\\u0bcd\\\\u0bd7\\\\u0c3e-\\\\u0c40\\\\u0c46-\\\\u0c48\\\\u0c4a-\\\\u0c4d\\\\u0c55\\\\u0c56\\\\u0c62\\\\u0c63\\\\u0cbc\\\\u0cbf\\\\u0cc2\\\\u0cc6\\\\u0ccc\\\\u0ccd\\\\u0cd5\\\\u0cd6\\\\u0ce2\\\\u0ce3\\\\u0d3e\\\\u0d41-\\\\u0d44\\\\u0d4d\\\\u0d57\\\\u0d62\\\\u0d63\\\\u0dca\\\\u0dcf\\\\u0dd2-\\\\u0dd4\\\\u0dd6\\\\u0ddf\\\\u0e31\\\\u0e34-\\\\u0e3a\\\\u0e47-\\\\u0e4e\\\\u0eb1\\\\u0eb4-\\\\u0eb9\\\\u0ebb\\\\u0ebc\\\\u0ec8-\\\\u0ecd\\\\u0f18\\\\u0f19\\\\u0f35\\\\u0f37\\\\u0f39\\\\u0f71-\\\\u0f7e\\\\u0f80-\\\\u0f84\\\\u0f86\\\\u0f87\\\\u0f90-\\\\u0f97\\\\u0f99-\\\\u0fbc\\\\u0fc6\\\\u102d-\\\\u1030\\\\u1032-\\\\u1037\\\\u1039\\\\u103a\\\\u103d\\\\u103e\\\\u1058\\\\u1059\\\\u105e-\\\\u1060\\\\u1071-\\\\u1074\\\\u1082\\\\u1085\\\\u1086\\\\u108d\\\\u109d\\\\u135f\\\\u1712-\\\\u1714\\\\u1732-\\\\u1734\\\\u1752\\\\u1753\\\\u1772\\\\u1773\\\\u17b7-\\\\u17bd\\\\u17c6\\\\u17c9-\\\\u17d3\\\\u17dd\\\\u180b-\\\\u180d\\\\u18a9\\\\u1920-\\\\u1922\\\\u1927\\\\u1928\\\\u1932\\\\u1939-\\\\u193b\\\\u1a17\\\\u1a18\\\\u1a56\\\\u1a58-\\\\u1a5e\\\\u1a60\\\\u1a62\\\\u1a65-\\\\u1a6c\\\\u1a73-\\\\u1a7c\\\\u1a7f\\\\u1b00-\\\\u1b03\\\\u1b34\\\\u1b36-\\\\u1b3a\\\\u1b3c\\\\u1b42\\\\u1b6b-\\\\u1b73\\\\u1b80\\\\u1b81\\\\u1ba2-\\\\u1ba5\\\\u1ba8\\\\u1ba9\\\\u1c2c-\\\\u1c33\\\\u1c36\\\\u1c37\\\\u1cd0-\\\\u1cd2\\\\u1cd4-\\\\u1ce0\\\\u1ce2-\\\\u1ce8\\\\u1ced\\\\u1dc0-\\\\u1de6\\\\u1dfd-\\\\u1dff\\\\u200c\\\\u200d\\\\u20d0-\\\\u20f0\\\\u2cef-\\\\u2cf1\\\\u2de0-\\\\u2dff\\\\u302a-\\\\u302f\\\\u3099\\\\u309a\\\\ua66f-\\\\ua672\\\\ua67c\\\\ua67d\\\\ua6f0\\\\ua6f1\\\\ua802\\\\ua806\\\\ua80b\\\\ua825\\\\ua826\\\\ua8c4\\\\ua8e0-\\\\ua8f1\\\\ua926-\\\\ua92d\\\\ua947-\\\\ua951\\\\ua980-\\\\ua982\\\\ua9b3\\\\ua9b6-\\\\ua9b9\\\\ua9bc\\\\uaa29-\\\\uaa2e\\\\uaa31\\\\uaa32\\\\uaa35\\\\uaa36\\\\uaa43\\\\uaa4c\\\\uaab0\\\\uaab2-\\\\uaab4\\\\uaab7\\\\uaab8\\\\uaabe\\\\uaabf\\\\uaac1\\\\uabe5\\\\uabe8\\\\uabed\\\\udc00-\\\\udfff\\\\ufb1e\\\\ufe00-\\\\ufe0f\\\\ufe20-\\\\ufe26\\\\uff9e\\\\uff9f]/\\nfunction isExtendingChar(ch) { return ch.charCodeAt(0) >= 768 && extendingChars.test(ch) }\\n\\n// The display handles the DOM integration, both for input reading\\n// and content drawing. It holds references to DOM nodes and\\n// display-related state.\\n\\nfunction Display(place, doc, input) {\\n  var d = this\\n  this.input = input\\n\\n  // Covers bottom-right square when both scrollbars are present.\\n  d.scrollbarFiller = elt(\\\"div\\\", null, \\\"CodeMirror-scrollbar-filler\\\")\\n  d.scrollbarFiller.setAttribute(\\\"cm-not-content\\\", \\\"true\\\")\\n  // Covers bottom of gutter when coverGutterNextToScrollbar is on\\n  // and h scrollbar is present.\\n  d.gutterFiller = elt(\\\"div\\\", null, \\\"CodeMirror-gutter-filler\\\")\\n  d.gutterFiller.setAttribute(\\\"cm-not-content\\\", \\\"true\\\")\\n  // Will contain the actual code, positioned to cover the viewport.\\n  d.lineDiv = elt(\\\"div\\\", null, \\\"CodeMirror-code\\\")\\n  // Elements are added to these to represent selection and cursors.\\n  d.selectionDiv = elt(\\\"div\\\", null, null, \\\"position: relative; z-index: 1\\\")\\n  d.cursorDiv = elt(\\\"div\\\", null, \\\"CodeMirror-cursors\\\")\\n  // A visibility: hidden element used to find the size of things.\\n  d.measure = elt(\\\"div\\\", null, \\\"CodeMirror-measure\\\")\\n  // When lines outside of the viewport are measured, they are drawn in this.\\n  d.lineMeasure = elt(\\\"div\\\", null, \\\"CodeMirror-measure\\\")\\n  // Wraps everything that needs to exist inside the vertically-padded coordinate system\\n  d.lineSpace = elt(\\\"div\\\", [d.measure, d.lineMeasure, d.selectionDiv, d.cursorDiv, d.lineDiv],\\n                    null, \\\"position: relative; outline: none\\\")\\n  // Moved around its parent to cover visible view.\\n  d.mover = elt(\\\"div\\\", [elt(\\\"div\\\", [d.lineSpace], \\\"CodeMirror-lines\\\")], null, \\\"position: relative\\\")\\n  // Set to the height of the document, allowing scrolling.\\n  d.sizer = elt(\\\"div\\\", [d.mover], \\\"CodeMirror-sizer\\\")\\n  d.sizerWidth = null\\n  // Behavior of elts with overflow: auto and padding is\\n  // inconsistent across browsers. This is used to ensure the\\n  // scrollable area is big enough.\\n  d.heightForcer = elt(\\\"div\\\", null, null, \\\"position: absolute; height: \\\" + scrollerGap + \\\"px; width: 1px;\\\")\\n  // Will contain the gutters, if any.\\n  d.gutters = elt(\\\"div\\\", null, \\\"CodeMirror-gutters\\\")\\n  d.lineGutter = null\\n  // Actual scrollable element.\\n  d.scroller = elt(\\\"div\\\", [d.sizer, d.heightForcer, d.gutters], \\\"CodeMirror-scroll\\\")\\n  d.scroller.setAttribute(\\\"tabIndex\\\", \\\"-1\\\")\\n  // The element in which the editor lives.\\n  d.wrapper = elt(\\\"div\\\", [d.scrollbarFiller, d.gutterFiller, d.scroller], \\\"CodeMirror\\\")\\n\\n  // Work around IE7 z-index bug (not perfect, hence IE7 not really being supported)\\n  if (ie && ie_version < 8) { d.gutters.style.zIndex = -1; d.scroller.style.paddingRight = 0 }\\n  if (!webkit && !(gecko && mobile)) { d.scroller.draggable = true }\\n\\n  if (place) {\\n    if (place.appendChild) { place.appendChild(d.wrapper) }\\n    else { place(d.wrapper) }\\n  }\\n\\n  // Current rendered range (may be bigger than the view window).\\n  d.viewFrom = d.viewTo = doc.first\\n  d.reportedViewFrom = d.reportedViewTo = doc.first\\n  // Information about the rendered lines.\\n  d.view = []\\n  d.renderedView = null\\n  // Holds info about a single rendered line when it was rendered\\n  // for measurement, while not in view.\\n  d.externalMeasured = null\\n  // Empty space (in pixels) above the view\\n  d.viewOffset = 0\\n  d.lastWrapHeight = d.lastWrapWidth = 0\\n  d.updateLineNumbers = null\\n\\n  d.nativeBarWidth = d.barHeight = d.barWidth = 0\\n  d.scrollbarsClipped = false\\n\\n  // Used to only resize the line number gutter when necessary (when\\n  // the amount of lines crosses a boundary that makes its width change)\\n  d.lineNumWidth = d.lineNumInnerWidth = d.lineNumChars = null\\n  // Set to true when a non-horizontal-scrolling line widget is\\n  // added. As an optimization, line widget aligning is skipped when\\n  // this is false.\\n  d.alignWidgets = false\\n\\n  d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null\\n\\n  // Tracks the maximum line length so that the horizontal scrollbar\\n  // can be kept static when scrolling.\\n  d.maxLine = null\\n  d.maxLineLength = 0\\n  d.maxLineChanged = false\\n\\n  // Used for measuring wheel scrolling granularity\\n  d.wheelDX = d.wheelDY = d.wheelStartX = d.wheelStartY = null\\n\\n  // True when shift is held down.\\n  d.shift = false\\n\\n  // Used to track whether anything happened since the context menu\\n  // was opened.\\n  d.selForContextMenu = null\\n\\n  d.activeTouch = null\\n\\n  input.init(d)\\n}\\n\\n// Find the line object corresponding to the given line number.\\nfunction getLine(doc, n) {\\n  n -= doc.first\\n  if (n < 0 || n >= doc.size) { throw new Error(\\\"There is no line \\\" + (n + doc.first) + \\\" in the document.\\\") }\\n  var chunk = doc\\n  while (!chunk.lines) {\\n    for (var i = 0;; ++i) {\\n      var child = chunk.children[i], sz = child.chunkSize()\\n      if (n < sz) { chunk = child; break }\\n      n -= sz\\n    }\\n  }\\n  return chunk.lines[n]\\n}\\n\\n// Get the part of a document between two positions, as an array of\\n// strings.\\nfunction getBetween(doc, start, end) {\\n  var out = [], n = start.line\\n  doc.iter(start.line, end.line + 1, function (line) {\\n    var text = line.text\\n    if (n == end.line) { text = text.slice(0, end.ch) }\\n    if (n == start.line) { text = text.slice(start.ch) }\\n    out.push(text)\\n    ++n\\n  })\\n  return out\\n}\\n// Get the lines between from and to, as array of strings.\\nfunction getLines(doc, from, to) {\\n  var out = []\\n  doc.iter(from, to, function (line) { out.push(line.text) }) // iter aborts when callback returns truthy value\\n  return out\\n}\\n\\n// Update the height of a line, propagating the height change\\n// upwards to parent nodes.\\nfunction updateLineHeight(line, height) {\\n  var diff = height - line.height\\n  if (diff) { for (var n = line; n; n = n.parent) { n.height += diff } }\\n}\\n\\n// Given a line object, find its line number by walking up through\\n// its parent links.\\nfunction lineNo(line) {\\n  if (line.parent == null) { return null }\\n  var cur = line.parent, no = indexOf(cur.lines, line)\\n  for (var chunk = cur.parent; chunk; cur = chunk, chunk = chunk.parent) {\\n    for (var i = 0;; ++i) {\\n      if (chunk.children[i] == cur) { break }\\n      no += chunk.children[i].chunkSize()\\n    }\\n  }\\n  return no + cur.first\\n}\\n\\n// Find the line at the given vertical position, using the height\\n// information in the document tree.\\nfunction lineAtHeight(chunk, h) {\\n  var n = chunk.first\\n  outer: do {\\n    for (var i$1 = 0; i$1 < chunk.children.length; ++i$1) {\\n      var child = chunk.children[i$1], ch = child.height\\n      if (h < ch) { chunk = child; continue outer }\\n      h -= ch\\n      n += child.chunkSize()\\n    }\\n    return n\\n  } while (!chunk.lines)\\n  var i = 0\\n  for (; i < chunk.lines.length; ++i) {\\n    var line = chunk.lines[i], lh = line.height\\n    if (h < lh) { break }\\n    h -= lh\\n  }\\n  return n + i\\n}\\n\\nfunction isLine(doc, l) {return l >= doc.first && l < doc.first + doc.size}\\n\\nfunction lineNumberFor(options, i) {\\n  return String(options.lineNumberFormatter(i + options.firstLineNumber))\\n}\\n\\n// A Pos instance represents a position within the text.\\nfunction Pos (line, ch) {\\n  if (!(this instanceof Pos)) { return new Pos(line, ch) }\\n  this.line = line; this.ch = ch\\n}\\n\\n// Compare two positions, return 0 if they are the same, a negative\\n// number when a is less, and a positive number otherwise.\\nfunction cmp(a, b) { return a.line - b.line || a.ch - b.ch }\\n\\nfunction copyPos(x) {return Pos(x.line, x.ch)}\\nfunction maxPos(a, b) { return cmp(a, b) < 0 ? b : a }\\nfunction minPos(a, b) { return cmp(a, b) < 0 ? a : b }\\n\\n// Most of the external API clips given positions to make sure they\\n// actually exist within the document.\\nfunction clipLine(doc, n) {return Math.max(doc.first, Math.min(n, doc.first + doc.size - 1))}\\nfunction clipPos(doc, pos) {\\n  if (pos.line < doc.first) { return Pos(doc.first, 0) }\\n  var last = doc.first + doc.size - 1\\n  if (pos.line > last) { return Pos(last, getLine(doc, last).text.length) }\\n  return clipToLen(pos, getLine(doc, pos.line).text.length)\\n}\\nfunction clipToLen(pos, linelen) {\\n  var ch = pos.ch\\n  if (ch == null || ch > linelen) { return Pos(pos.line, linelen) }\\n  else if (ch < 0) { return Pos(pos.line, 0) }\\n  else { return pos }\\n}\\nfunction clipPosArray(doc, array) {\\n  var out = []\\n  for (var i = 0; i < array.length; i++) { out[i] = clipPos(doc, array[i]) }\\n  return out\\n}\\n\\n// Optimize some code when these features are not used.\\nvar sawReadOnlySpans = false;\\nvar sawCollapsedSpans = false;\\nfunction seeReadOnlySpans() {\\n  sawReadOnlySpans = true\\n}\\n\\nfunction seeCollapsedSpans() {\\n  sawCollapsedSpans = true\\n}\\n\\n// TEXTMARKER SPANS\\n\\nfunction MarkedSpan(marker, from, to) {\\n  this.marker = marker\\n  this.from = from; this.to = to\\n}\\n\\n// Search an array of spans for a span matching the given marker.\\nfunction getMarkedSpanFor(spans, marker) {\\n  if (spans) { for (var i = 0; i < spans.length; ++i) {\\n    var span = spans[i]\\n    if (span.marker == marker) { return span }\\n  } }\\n}\\n// Remove a span from an array, returning undefined if no spans are\\n// left (we don't store arrays for lines without spans).\\nfunction removeMarkedSpan(spans, span) {\\n  var r\\n  for (var i = 0; i < spans.length; ++i)\\n    { if (spans[i] != span) { (r || (r = [])).push(spans[i]) } }\\n  return r\\n}\\n// Add a span to a line.\\nfunction addMarkedSpan(line, span) {\\n  line.markedSpans = line.markedSpans ? line.markedSpans.concat([span]) : [span]\\n  span.marker.attachLine(line)\\n}\\n\\n// Used for the algorithm that adjusts markers for a change in the\\n// document. These functions cut an array of spans at a given\\n// character position, returning an array of remaining chunks (or\\n// undefined if nothing remains).\\nfunction markedSpansBefore(old, startCh, isInsert) {\\n  var nw\\n  if (old) { for (var i = 0; i < old.length; ++i) {\\n    var span = old[i], marker = span.marker\\n    var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= startCh : span.from < startCh)\\n    if (startsBefore || span.from == startCh && marker.type == \\\"bookmark\\\" && (!isInsert || !span.marker.insertLeft)) {\\n      var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= startCh : span.to > startCh)\\n      ;(nw || (nw = [])).push(new MarkedSpan(marker, span.from, endsAfter ? null : span.to))\\n    }\\n  } }\\n  return nw\\n}\\nfunction markedSpansAfter(old, endCh, isInsert) {\\n  var nw\\n  if (old) { for (var i = 0; i < old.length; ++i) {\\n    var span = old[i], marker = span.marker\\n    var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= endCh : span.to > endCh)\\n    if (endsAfter || span.from == endCh && marker.type == \\\"bookmark\\\" && (!isInsert || span.marker.insertLeft)) {\\n      var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= endCh : span.from < endCh)\\n      ;(nw || (nw = [])).push(new MarkedSpan(marker, startsBefore ? null : span.from - endCh,\\n                                            span.to == null ? null : span.to - endCh))\\n    }\\n  } }\\n  return nw\\n}\\n\\n// Given a change object, compute the new set of marker spans that\\n// cover the line in which the change took place. Removes spans\\n// entirely within the change, reconnects spans belonging to the\\n// same marker that appear on both sides of the change, and cuts off\\n// spans partially within the change. Returns an array of span\\n// arrays with one element for each line in (after) the change.\\nfunction stretchSpansOverChange(doc, change) {\\n  if (change.full) { return null }\\n  var oldFirst = isLine(doc, change.from.line) && getLine(doc, change.from.line).markedSpans\\n  var oldLast = isLine(doc, change.to.line) && getLine(doc, change.to.line).markedSpans\\n  if (!oldFirst && !oldLast) { return null }\\n\\n  var startCh = change.from.ch, endCh = change.to.ch, isInsert = cmp(change.from, change.to) == 0\\n  // Get the spans that 'stick out' on both sides\\n  var first = markedSpansBefore(oldFirst, startCh, isInsert)\\n  var last = markedSpansAfter(oldLast, endCh, isInsert)\\n\\n  // Next, merge those two ends\\n  var sameLine = change.text.length == 1, offset = lst(change.text).length + (sameLine ? startCh : 0)\\n  if (first) {\\n    // Fix up .to properties of first\\n    for (var i = 0; i < first.length; ++i) {\\n      var span = first[i]\\n      if (span.to == null) {\\n        var found = getMarkedSpanFor(last, span.marker)\\n        if (!found) { span.to = startCh }\\n        else if (sameLine) { span.to = found.to == null ? null : found.to + offset }\\n      }\\n    }\\n  }\\n  if (last) {\\n    // Fix up .from in last (or move them into first in case of sameLine)\\n    for (var i$1 = 0; i$1 < last.length; ++i$1) {\\n      var span$1 = last[i$1]\\n      if (span$1.to != null) { span$1.to += offset }\\n      if (span$1.from == null) {\\n        var found$1 = getMarkedSpanFor(first, span$1.marker)\\n        if (!found$1) {\\n          span$1.from = offset\\n          if (sameLine) { (first || (first = [])).push(span$1) }\\n        }\\n      } else {\\n        span$1.from += offset\\n        if (sameLine) { (first || (first = [])).push(span$1) }\\n      }\\n    }\\n  }\\n  // Make sure we didn't create any zero-length spans\\n  if (first) { first = clearEmptySpans(first) }\\n  if (last && last != first) { last = clearEmptySpans(last) }\\n\\n  var newMarkers = [first]\\n  if (!sameLine) {\\n    // Fill gap with whole-line-spans\\n    var gap = change.text.length - 2, gapMarkers\\n    if (gap > 0 && first)\\n      { for (var i$2 = 0; i$2 < first.length; ++i$2)\\n        { if (first[i$2].to == null)\\n          { (gapMarkers || (gapMarkers = [])).push(new MarkedSpan(first[i$2].marker, null, null)) } } }\\n    for (var i$3 = 0; i$3 < gap; ++i$3)\\n      { newMarkers.push(gapMarkers) }\\n    newMarkers.push(last)\\n  }\\n  return newMarkers\\n}\\n\\n// Remove spans that are empty and don't have a clearWhenEmpty\\n// option of false.\\nfunction clearEmptySpans(spans) {\\n  for (var i = 0; i < spans.length; ++i) {\\n    var span = spans[i]\\n    if (span.from != null && span.from == span.to && span.marker.clearWhenEmpty !== false)\\n      { spans.splice(i--, 1) }\\n  }\\n  if (!spans.length) { return null }\\n  return spans\\n}\\n\\n// Used to 'clip' out readOnly ranges when making a change.\\nfunction removeReadOnlyRanges(doc, from, to) {\\n  var markers = null\\n  doc.iter(from.line, to.line + 1, function (line) {\\n    if (line.markedSpans) { for (var i = 0; i < line.markedSpans.length; ++i) {\\n      var mark = line.markedSpans[i].marker\\n      if (mark.readOnly && (!markers || indexOf(markers, mark) == -1))\\n        { (markers || (markers = [])).push(mark) }\\n    } }\\n  })\\n  if (!markers) { return null }\\n  var parts = [{from: from, to: to}]\\n  for (var i = 0; i < markers.length; ++i) {\\n    var mk = markers[i], m = mk.find(0)\\n    for (var j = 0; j < parts.length; ++j) {\\n      var p = parts[j]\\n      if (cmp(p.to, m.from) < 0 || cmp(p.from, m.to) > 0) { continue }\\n      var newParts = [j, 1], dfrom = cmp(p.from, m.from), dto = cmp(p.to, m.to)\\n      if (dfrom < 0 || !mk.inclusiveLeft && !dfrom)\\n        { newParts.push({from: p.from, to: m.from}) }\\n      if (dto > 0 || !mk.inclusiveRight && !dto)\\n        { newParts.push({from: m.to, to: p.to}) }\\n      parts.splice.apply(parts, newParts)\\n      j += newParts.length - 1\\n    }\\n  }\\n  return parts\\n}\\n\\n// Connect or disconnect spans from a line.\\nfunction detachMarkedSpans(line) {\\n  var spans = line.markedSpans\\n  if (!spans) { return }\\n  for (var i = 0; i < spans.length; ++i)\\n    { spans[i].marker.detachLine(line) }\\n  line.markedSpans = null\\n}\\nfunction attachMarkedSpans(line, spans) {\\n  if (!spans) { return }\\n  for (var i = 0; i < spans.length; ++i)\\n    { spans[i].marker.attachLine(line) }\\n  line.markedSpans = spans\\n}\\n\\n// Helpers used when computing which overlapping collapsed span\\n// counts as the larger one.\\nfunction extraLeft(marker) { return marker.inclusiveLeft ? -1 : 0 }\\nfunction extraRight(marker) { return marker.inclusiveRight ? 1 : 0 }\\n\\n// Returns a number indicating which of two overlapping collapsed\\n// spans is larger (and thus includes the other). Falls back to\\n// comparing ids when the spans cover exactly the same range.\\nfunction compareCollapsedMarkers(a, b) {\\n  var lenDiff = a.lines.length - b.lines.length\\n  if (lenDiff != 0) { return lenDiff }\\n  var aPos = a.find(), bPos = b.find()\\n  var fromCmp = cmp(aPos.from, bPos.from) || extraLeft(a) - extraLeft(b)\\n  if (fromCmp) { return -fromCmp }\\n  var toCmp = cmp(aPos.to, bPos.to) || extraRight(a) - extraRight(b)\\n  if (toCmp) { return toCmp }\\n  return b.id - a.id\\n}\\n\\n// Find out whether a line ends or starts in a collapsed span. If\\n// so, return the marker for that span.\\nfunction collapsedSpanAtSide(line, start) {\\n  var sps = sawCollapsedSpans && line.markedSpans, found\\n  if (sps) { for (var sp = (void 0), i = 0; i < sps.length; ++i) {\\n    sp = sps[i]\\n    if (sp.marker.collapsed && (start ? sp.from : sp.to) == null &&\\n        (!found || compareCollapsedMarkers(found, sp.marker) < 0))\\n      { found = sp.marker }\\n  } }\\n  return found\\n}\\nfunction collapsedSpanAtStart(line) { return collapsedSpanAtSide(line, true) }\\nfunction collapsedSpanAtEnd(line) { return collapsedSpanAtSide(line, false) }\\n\\n// Test whether there exists a collapsed span that partially\\n// overlaps (covers the start or end, but not both) of a new span.\\n// Such overlap is not allowed.\\nfunction conflictingCollapsedRange(doc, lineNo, from, to, marker) {\\n  var line = getLine(doc, lineNo)\\n  var sps = sawCollapsedSpans && line.markedSpans\\n  if (sps) { for (var i = 0; i < sps.length; ++i) {\\n    var sp = sps[i]\\n    if (!sp.marker.collapsed) { continue }\\n    var found = sp.marker.find(0)\\n    var fromCmp = cmp(found.from, from) || extraLeft(sp.marker) - extraLeft(marker)\\n    var toCmp = cmp(found.to, to) || extraRight(sp.marker) - extraRight(marker)\\n    if (fromCmp >= 0 && toCmp <= 0 || fromCmp <= 0 && toCmp >= 0) { continue }\\n    if (fromCmp <= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.to, from) >= 0 : cmp(found.to, from) > 0) ||\\n        fromCmp >= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.from, to) <= 0 : cmp(found.from, to) < 0))\\n      { return true }\\n  } }\\n}\\n\\n// A visual line is a line as drawn on the screen. Folding, for\\n// example, can cause multiple logical lines to appear on the same\\n// visual line. This finds the start of the visual line that the\\n// given line is part of (usually that is the line itself).\\nfunction visualLine(line) {\\n  var merged\\n  while (merged = collapsedSpanAtStart(line))\\n    { line = merged.find(-1, true).line }\\n  return line\\n}\\n\\n// Returns an array of logical lines that continue the visual line\\n// started by the argument, or undefined if there are no such lines.\\nfunction visualLineContinued(line) {\\n  var merged, lines\\n  while (merged = collapsedSpanAtEnd(line)) {\\n    line = merged.find(1, true).line\\n    ;(lines || (lines = [])).push(line)\\n  }\\n  return lines\\n}\\n\\n// Get the line number of the start of the visual line that the\\n// given line number is part of.\\nfunction visualLineNo(doc, lineN) {\\n  var line = getLine(doc, lineN), vis = visualLine(line)\\n  if (line == vis) { return lineN }\\n  return lineNo(vis)\\n}\\n\\n// Get the line number of the start of the next visual line after\\n// the given line.\\nfunction visualLineEndNo(doc, lineN) {\\n  if (lineN > doc.lastLine()) { return lineN }\\n  var line = getLine(doc, lineN), merged\\n  if (!lineIsHidden(doc, line)) { return lineN }\\n  while (merged = collapsedSpanAtEnd(line))\\n    { line = merged.find(1, true).line }\\n  return lineNo(line) + 1\\n}\\n\\n// Compute whether a line is hidden. Lines count as hidden when they\\n// are part of a visual line that starts with another line, or when\\n// they are entirely covered by collapsed, non-widget span.\\nfunction lineIsHidden(doc, line) {\\n  var sps = sawCollapsedSpans && line.markedSpans\\n  if (sps) { for (var sp = (void 0), i = 0; i < sps.length; ++i) {\\n    sp = sps[i]\\n    if (!sp.marker.collapsed) { continue }\\n    if (sp.from == null) { return true }\\n    if (sp.marker.widgetNode) { continue }\\n    if (sp.from == 0 && sp.marker.inclusiveLeft && lineIsHiddenInner(doc, line, sp))\\n      { return true }\\n  } }\\n}\\nfunction lineIsHiddenInner(doc, line, span) {\\n  if (span.to == null) {\\n    var end = span.marker.find(1, true)\\n    return lineIsHiddenInner(doc, end.line, getMarkedSpanFor(end.line.markedSpans, span.marker))\\n  }\\n  if (span.marker.inclusiveRight && span.to == line.text.length)\\n    { return true }\\n  for (var sp = (void 0), i = 0; i < line.markedSpans.length; ++i) {\\n    sp = line.markedSpans[i]\\n    if (sp.marker.collapsed && !sp.marker.widgetNode && sp.from == span.to &&\\n        (sp.to == null || sp.to != span.from) &&\\n        (sp.marker.inclusiveLeft || span.marker.inclusiveRight) &&\\n        lineIsHiddenInner(doc, line, sp)) { return true }\\n  }\\n}\\n\\n// Find the height above the given line.\\nfunction heightAtLine(lineObj) {\\n  lineObj = visualLine(lineObj)\\n\\n  var h = 0, chunk = lineObj.parent\\n  for (var i = 0; i < chunk.lines.length; ++i) {\\n    var line = chunk.lines[i]\\n    if (line == lineObj) { break }\\n    else { h += line.height }\\n  }\\n  for (var p = chunk.parent; p; chunk = p, p = chunk.parent) {\\n    for (var i$1 = 0; i$1 < p.children.length; ++i$1) {\\n      var cur = p.children[i$1]\\n      if (cur == chunk) { break }\\n      else { h += cur.height }\\n    }\\n  }\\n  return h\\n}\\n\\n// Compute the character length of a line, taking into account\\n// collapsed ranges (see markText) that might hide parts, and join\\n// other lines onto it.\\nfunction lineLength(line) {\\n  if (line.height == 0) { return 0 }\\n  var len = line.text.length, merged, cur = line\\n  while (merged = collapsedSpanAtStart(cur)) {\\n    var found = merged.find(0, true)\\n    cur = found.from.line\\n    len += found.from.ch - found.to.ch\\n  }\\n  cur = line\\n  while (merged = collapsedSpanAtEnd(cur)) {\\n    var found$1 = merged.find(0, true)\\n    len -= cur.text.length - found$1.from.ch\\n    cur = found$1.to.line\\n    len += cur.text.length - found$1.to.ch\\n  }\\n  return len\\n}\\n\\n// Find the longest line in the document.\\nfunction findMaxLine(cm) {\\n  var d = cm.display, doc = cm.doc\\n  d.maxLine = getLine(doc, doc.first)\\n  d.maxLineLength = lineLength(d.maxLine)\\n  d.maxLineChanged = true\\n  doc.iter(function (line) {\\n    var len = lineLength(line)\\n    if (len > d.maxLineLength) {\\n      d.maxLineLength = len\\n      d.maxLine = line\\n    }\\n  })\\n}\\n\\n// BIDI HELPERS\\n\\nfunction iterateBidiSections(order, from, to, f) {\\n  if (!order) { return f(from, to, \\\"ltr\\\") }\\n  var found = false\\n  for (var i = 0; i < order.length; ++i) {\\n    var part = order[i]\\n    if (part.from < to && part.to > from || from == to && part.to == from) {\\n      f(Math.max(part.from, from), Math.min(part.to, to), part.level == 1 ? \\\"rtl\\\" : \\\"ltr\\\")\\n      found = true\\n    }\\n  }\\n  if (!found) { f(from, to, \\\"ltr\\\") }\\n}\\n\\nfunction bidiLeft(part) { return part.level % 2 ? part.to : part.from }\\nfunction bidiRight(part) { return part.level % 2 ? part.from : part.to }\\n\\nfunction lineLeft(line) { var order = getOrder(line); return order ? bidiLeft(order[0]) : 0 }\\nfunction lineRight(line) {\\n  var order = getOrder(line)\\n  if (!order) { return line.text.length }\\n  return bidiRight(lst(order))\\n}\\n\\nfunction compareBidiLevel(order, a, b) {\\n  var linedir = order[0].level\\n  if (a == linedir) { return true }\\n  if (b == linedir) { return false }\\n  return a < b\\n}\\n\\nvar bidiOther = null\\nfunction getBidiPartAt(order, pos) {\\n  var found\\n  bidiOther = null\\n  for (var i = 0; i < order.length; ++i) {\\n    var cur = order[i]\\n    if (cur.from < pos && cur.to > pos) { return i }\\n    if ((cur.from == pos || cur.to == pos)) {\\n      if (found == null) {\\n        found = i\\n      } else if (compareBidiLevel(order, cur.level, order[found].level)) {\\n        if (cur.from != cur.to) { bidiOther = found }\\n        return i\\n      } else {\\n        if (cur.from != cur.to) { bidiOther = i }\\n        return found\\n      }\\n    }\\n  }\\n  return found\\n}\\n\\nfunction moveInLine(line, pos, dir, byUnit) {\\n  if (!byUnit) { return pos + dir }\\n  do { pos += dir }\\n  while (pos > 0 && isExtendingChar(line.text.charAt(pos)))\\n  return pos\\n}\\n\\n// This is needed in order to move 'visually' through bi-directional\\n// text -- i.e., pressing left should make the cursor go left, even\\n// when in RTL text. The tricky part is the 'jumps', where RTL and\\n// LTR text touch each other. This often requires the cursor offset\\n// to move more than one unit, in order to visually move one unit.\\nfunction moveVisually(line, start, dir, byUnit) {\\n  var bidi = getOrder(line)\\n  if (!bidi) { return moveLogically(line, start, dir, byUnit) }\\n  var pos = getBidiPartAt(bidi, start), part = bidi[pos]\\n  var target = moveInLine(line, start, part.level % 2 ? -dir : dir, byUnit)\\n\\n  for (;;) {\\n    if (target > part.from && target < part.to) { return target }\\n    if (target == part.from || target == part.to) {\\n      if (getBidiPartAt(bidi, target) == pos) { return target }\\n      part = bidi[pos += dir]\\n      return (dir > 0) == part.level % 2 ? part.to : part.from\\n    } else {\\n      part = bidi[pos += dir]\\n      if (!part) { return null }\\n      if ((dir > 0) == part.level % 2)\\n        { target = moveInLine(line, part.to, -1, byUnit) }\\n      else\\n        { target = moveInLine(line, part.from, 1, byUnit) }\\n    }\\n  }\\n}\\n\\nfunction moveLogically(line, start, dir, byUnit) {\\n  var target = start + dir\\n  if (byUnit) { while (target > 0 && isExtendingChar(line.text.charAt(target))) { target += dir } }\\n  return target < 0 || target > line.text.length ? null : target\\n}\\n\\n// Bidirectional ordering algorithm\\n// See http://unicode.org/reports/tr9/tr9-13.html for the algorithm\\n// that this (partially) implements.\\n\\n// One-char codes used for character types:\\n// L (L):   Left-to-Right\\n// R (R):   Right-to-Left\\n// r (AL):  Right-to-Left Arabic\\n// 1 (EN):  European Number\\n// + (ES):  European Number Separator\\n// % (ET):  European Number Terminator\\n// n (AN):  Arabic Number\\n// , (CS):  Common Number Separator\\n// m (NSM): Non-Spacing Mark\\n// b (BN):  Boundary Neutral\\n// s (B):   Paragraph Separator\\n// t (S):   Segment Separator\\n// w (WS):  Whitespace\\n// N (ON):  Other Neutrals\\n\\n// Returns null if characters are ordered as they appear\\n// (left-to-right), or an array of sections ({from, to, level}\\n// objects) in the order in which they occur visually.\\nvar bidiOrdering = (function() {\\n  // Character types for codepoints 0 to 0xff\\n  var lowTypes = \\\"bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN\\\"\\n  // Character types for codepoints 0x600 to 0x6f9\\n  var arabicTypes = \\\"nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111\\\"\\n  function charType(code) {\\n    if (code <= 0xf7) { return lowTypes.charAt(code) }\\n    else if (0x590 <= code && code <= 0x5f4) { return \\\"R\\\" }\\n    else if (0x600 <= code && code <= 0x6f9) { return arabicTypes.charAt(code - 0x600) }\\n    else if (0x6ee <= code && code <= 0x8ac) { return \\\"r\\\" }\\n    else if (0x2000 <= code && code <= 0x200b) { return \\\"w\\\" }\\n    else if (code == 0x200c) { return \\\"b\\\" }\\n    else { return \\\"L\\\" }\\n  }\\n\\n  var bidiRE = /[\\\\u0590-\\\\u05f4\\\\u0600-\\\\u06ff\\\\u0700-\\\\u08ac]/\\n  var isNeutral = /[stwN]/, isStrong = /[LRr]/, countsAsLeft = /[Lb1n]/, countsAsNum = /[1n]/\\n  // Browsers seem to always treat the boundaries of block elements as being L.\\n  var outerType = \\\"L\\\"\\n\\n  function BidiSpan(level, from, to) {\\n    this.level = level\\n    this.from = from; this.to = to\\n  }\\n\\n  return function(str) {\\n    if (!bidiRE.test(str)) { return false }\\n    var len = str.length, types = []\\n    for (var i = 0; i < len; ++i)\\n      { types.push(charType(str.charCodeAt(i))) }\\n\\n    // W1. Examine each non-spacing mark (NSM) in the level run, and\\n    // change the type of the NSM to the type of the previous\\n    // character. If the NSM is at the start of the level run, it will\\n    // get the type of sor.\\n    for (var i$1 = 0, prev = outerType; i$1 < len; ++i$1) {\\n      var type = types[i$1]\\n      if (type == \\\"m\\\") { types[i$1] = prev }\\n      else { prev = type }\\n    }\\n\\n    // W2. Search backwards from each instance of a European number\\n    // until the first strong type (R, L, AL, or sor) is found. If an\\n    // AL is found, change the type of the European number to Arabic\\n    // number.\\n    // W3. Change all ALs to R.\\n    for (var i$2 = 0, cur = outerType; i$2 < len; ++i$2) {\\n      var type$1 = types[i$2]\\n      if (type$1 == \\\"1\\\" && cur == \\\"r\\\") { types[i$2] = \\\"n\\\" }\\n      else if (isStrong.test(type$1)) { cur = type$1; if (type$1 == \\\"r\\\") { types[i$2] = \\\"R\\\" } }\\n    }\\n\\n    // W4. A single European separator between two European numbers\\n    // changes to a European number. A single common separator between\\n    // two numbers of the same type changes to that type.\\n    for (var i$3 = 1, prev$1 = types[0]; i$3 < len - 1; ++i$3) {\\n      var type$2 = types[i$3]\\n      if (type$2 == \\\"+\\\" && prev$1 == \\\"1\\\" && types[i$3+1] == \\\"1\\\") { types[i$3] = \\\"1\\\" }\\n      else if (type$2 == \\\",\\\" && prev$1 == types[i$3+1] &&\\n               (prev$1 == \\\"1\\\" || prev$1 == \\\"n\\\")) { types[i$3] = prev$1 }\\n      prev$1 = type$2\\n    }\\n\\n    // W5. A sequence of European terminators adjacent to European\\n    // numbers changes to all European numbers.\\n    // W6. Otherwise, separators and terminators change to Other\\n    // Neutral.\\n    for (var i$4 = 0; i$4 < len; ++i$4) {\\n      var type$3 = types[i$4]\\n      if (type$3 == \\\",\\\") { types[i$4] = \\\"N\\\" }\\n      else if (type$3 == \\\"%\\\") {\\n        var end = (void 0)\\n        for (end = i$4 + 1; end < len && types[end] == \\\"%\\\"; ++end) {}\\n        var replace = (i$4 && types[i$4-1] == \\\"!\\\") || (end < len && types[end] == \\\"1\\\") ? \\\"1\\\" : \\\"N\\\"\\n        for (var j = i$4; j < end; ++j) { types[j] = replace }\\n        i$4 = end - 1\\n      }\\n    }\\n\\n    // W7. Search backwards from each instance of a European number\\n    // until the first strong type (R, L, or sor) is found. If an L is\\n    // found, then change the type of the European number to L.\\n    for (var i$5 = 0, cur$1 = outerType; i$5 < len; ++i$5) {\\n      var type$4 = types[i$5]\\n      if (cur$1 == \\\"L\\\" && type$4 == \\\"1\\\") { types[i$5] = \\\"L\\\" }\\n      else if (isStrong.test(type$4)) { cur$1 = type$4 }\\n    }\\n\\n    // N1. A sequence of neutrals takes the direction of the\\n    // surrounding strong text if the text on both sides has the same\\n    // direction. European and Arabic numbers act as if they were R in\\n    // terms of their influence on neutrals. Start-of-level-run (sor)\\n    // and end-of-level-run (eor) are used at level run boundaries.\\n    // N2. Any remaining neutrals take the embedding direction.\\n    for (var i$6 = 0; i$6 < len; ++i$6) {\\n      if (isNeutral.test(types[i$6])) {\\n        var end$1 = (void 0)\\n        for (end$1 = i$6 + 1; end$1 < len && isNeutral.test(types[end$1]); ++end$1) {}\\n        var before = (i$6 ? types[i$6-1] : outerType) == \\\"L\\\"\\n        var after = (end$1 < len ? types[end$1] : outerType) == \\\"L\\\"\\n        var replace$1 = before || after ? \\\"L\\\" : \\\"R\\\"\\n        for (var j$1 = i$6; j$1 < end$1; ++j$1) { types[j$1] = replace$1 }\\n        i$6 = end$1 - 1\\n      }\\n    }\\n\\n    // Here we depart from the documented algorithm, in order to avoid\\n    // building up an actual levels array. Since there are only three\\n    // levels (0, 1, 2) in an implementation that doesn't take\\n    // explicit embedding into account, we can build up the order on\\n    // the fly, without following the level-based algorithm.\\n    var order = [], m\\n    for (var i$7 = 0; i$7 < len;) {\\n      if (countsAsLeft.test(types[i$7])) {\\n        var start = i$7\\n        for (++i$7; i$7 < len && countsAsLeft.test(types[i$7]); ++i$7) {}\\n        order.push(new BidiSpan(0, start, i$7))\\n      } else {\\n        var pos = i$7, at = order.length\\n        for (++i$7; i$7 < len && types[i$7] != \\\"L\\\"; ++i$7) {}\\n        for (var j$2 = pos; j$2 < i$7;) {\\n          if (countsAsNum.test(types[j$2])) {\\n            if (pos < j$2) { order.splice(at, 0, new BidiSpan(1, pos, j$2)) }\\n            var nstart = j$2\\n            for (++j$2; j$2 < i$7 && countsAsNum.test(types[j$2]); ++j$2) {}\\n            order.splice(at, 0, new BidiSpan(2, nstart, j$2))\\n            pos = j$2\\n          } else { ++j$2 }\\n        }\\n        if (pos < i$7) { order.splice(at, 0, new BidiSpan(1, pos, i$7)) }\\n      }\\n    }\\n    if (order[0].level == 1 && (m = str.match(/^\\\\s+/))) {\\n      order[0].from = m[0].length\\n      order.unshift(new BidiSpan(0, 0, m[0].length))\\n    }\\n    if (lst(order).level == 1 && (m = str.match(/\\\\s+$/))) {\\n      lst(order).to -= m[0].length\\n      order.push(new BidiSpan(0, len - m[0].length, len))\\n    }\\n    if (order[0].level == 2)\\n      { order.unshift(new BidiSpan(1, order[0].to, order[0].to)) }\\n    if (order[0].level != lst(order).level)\\n      { order.push(new BidiSpan(order[0].level, len, len)) }\\n\\n    return order\\n  }\\n})()\\n\\n// Get the bidi ordering for the given line (and cache it). Returns\\n// false for lines that are fully left-to-right, and an array of\\n// BidiSpan objects otherwise.\\nfunction getOrder(line) {\\n  var order = line.order\\n  if (order == null) { order = line.order = bidiOrdering(line.text) }\\n  return order\\n}\\n\\n// EVENT HANDLING\\n\\n// Lightweight event framework. on/off also work on DOM nodes,\\n// registering native DOM handlers.\\n\\nvar noHandlers = []\\n\\nvar on = function(emitter, type, f) {\\n  if (emitter.addEventListener) {\\n    emitter.addEventListener(type, f, false)\\n  } else if (emitter.attachEvent) {\\n    emitter.attachEvent(\\\"on\\\" + type, f)\\n  } else {\\n    var map = emitter._handlers || (emitter._handlers = {})\\n    map[type] = (map[type] || noHandlers).concat(f)\\n  }\\n}\\n\\nfunction getHandlers(emitter, type) {\\n  return emitter._handlers && emitter._handlers[type] || noHandlers\\n}\\n\\nfunction off(emitter, type, f) {\\n  if (emitter.removeEventListener) {\\n    emitter.removeEventListener(type, f, false)\\n  } else if (emitter.detachEvent) {\\n    emitter.detachEvent(\\\"on\\\" + type, f)\\n  } else {\\n    var map = emitter._handlers, arr = map && map[type]\\n    if (arr) {\\n      var index = indexOf(arr, f)\\n      if (index > -1)\\n        { map[type] = arr.slice(0, index).concat(arr.slice(index + 1)) }\\n    }\\n  }\\n}\\n\\nfunction signal(emitter, type /*, values...*/) {\\n  var handlers = getHandlers(emitter, type)\\n  if (!handlers.length) { return }\\n  var args = Array.prototype.slice.call(arguments, 2)\\n  for (var i = 0; i < handlers.length; ++i) { handlers[i].apply(null, args) }\\n}\\n\\n// The DOM events that CodeMirror handles can be overridden by\\n// registering a (non-DOM) handler on the editor for the event name,\\n// and preventDefault-ing the event in that handler.\\nfunction signalDOMEvent(cm, e, override) {\\n  if (typeof e == \\\"string\\\")\\n    { e = {type: e, preventDefault: function() { this.defaultPrevented = true }} }\\n  signal(cm, override || e.type, cm, e)\\n  return e_defaultPrevented(e) || e.codemirrorIgnore\\n}\\n\\nfunction signalCursorActivity(cm) {\\n  var arr = cm._handlers && cm._handlers.cursorActivity\\n  if (!arr) { return }\\n  var set = cm.curOp.cursorActivityHandlers || (cm.curOp.cursorActivityHandlers = [])\\n  for (var i = 0; i < arr.length; ++i) { if (indexOf(set, arr[i]) == -1)\\n    { set.push(arr[i]) } }\\n}\\n\\nfunction hasHandler(emitter, type) {\\n  return getHandlers(emitter, type).length > 0\\n}\\n\\n// Add on and off methods to a constructor's prototype, to make\\n// registering events on such objects more convenient.\\nfunction eventMixin(ctor) {\\n  ctor.prototype.on = function(type, f) {on(this, type, f)}\\n  ctor.prototype.off = function(type, f) {off(this, type, f)}\\n}\\n\\n// Due to the fact that we still support jurassic IE versions, some\\n// compatibility wrappers are needed.\\n\\nfunction e_preventDefault(e) {\\n  if (e.preventDefault) { e.preventDefault() }\\n  else { e.returnValue = false }\\n}\\nfunction e_stopPropagation(e) {\\n  if (e.stopPropagation) { e.stopPropagation() }\\n  else { e.cancelBubble = true }\\n}\\nfunction e_defaultPrevented(e) {\\n  return e.defaultPrevented != null ? e.defaultPrevented : e.returnValue == false\\n}\\nfunction e_stop(e) {e_preventDefault(e); e_stopPropagation(e)}\\n\\nfunction e_target(e) {return e.target || e.srcElement}\\nfunction e_button(e) {\\n  var b = e.which\\n  if (b == null) {\\n    if (e.button & 1) { b = 1 }\\n    else if (e.button & 2) { b = 3 }\\n    else if (e.button & 4) { b = 2 }\\n  }\\n  if (mac && e.ctrlKey && b == 1) { b = 3 }\\n  return b\\n}\\n\\n// Detect drag-and-drop\\nvar dragAndDrop = function() {\\n  // There is *some* kind of drag-and-drop support in IE6-8, but I\\n  // couldn't get it to work yet.\\n  if (ie && ie_version < 9) { return false }\\n  var div = elt('div')\\n  return \\\"draggable\\\" in div || \\\"dragDrop\\\" in div\\n}()\\n\\nvar zwspSupported\\nfunction zeroWidthElement(measure) {\\n  if (zwspSupported == null) {\\n    var test = elt(\\\"span\\\", \\\"\\\\u200b\\\")\\n    removeChildrenAndAdd(measure, elt(\\\"span\\\", [test, document.createTextNode(\\\"x\\\")]))\\n    if (measure.firstChild.offsetHeight != 0)\\n      { zwspSupported = test.offsetWidth <= 1 && test.offsetHeight > 2 && !(ie && ie_version < 8) }\\n  }\\n  var node = zwspSupported ? elt(\\\"span\\\", \\\"\\\\u200b\\\") :\\n    elt(\\\"span\\\", \\\"\\\\u00a0\\\", null, \\\"display: inline-block; width: 1px; margin-right: -1px\\\")\\n  node.setAttribute(\\\"cm-text\\\", \\\"\\\")\\n  return node\\n}\\n\\n// Feature-detect IE's crummy client rect reporting for bidi text\\nvar badBidiRects\\nfunction hasBadBidiRects(measure) {\\n  if (badBidiRects != null) { return badBidiRects }\\n  var txt = removeChildrenAndAdd(measure, document.createTextNode(\\\"A\\\\u062eA\\\"))\\n  var r0 = range(txt, 0, 1).getBoundingClientRect()\\n  var r1 = range(txt, 1, 2).getBoundingClientRect()\\n  removeChildren(measure)\\n  if (!r0 || r0.left == r0.right) { return false } // Safari returns null in some cases (#2780)\\n  return badBidiRects = (r1.right - r0.right < 3)\\n}\\n\\n// See if \\\"\\\".split is the broken IE version, if so, provide an\\n// alternative way to split lines.\\nvar splitLinesAuto = \\\"\\\\n\\\\nb\\\".split(/\\\\n/).length != 3 ? function (string) {\\n  var pos = 0, result = [], l = string.length\\n  while (pos <= l) {\\n    var nl = string.indexOf(\\\"\\\\n\\\", pos)\\n    if (nl == -1) { nl = string.length }\\n    var line = string.slice(pos, string.charAt(nl - 1) == \\\"\\\\r\\\" ? nl - 1 : nl)\\n    var rt = line.indexOf(\\\"\\\\r\\\")\\n    if (rt != -1) {\\n      result.push(line.slice(0, rt))\\n      pos += rt + 1\\n    } else {\\n      result.push(line)\\n      pos = nl + 1\\n    }\\n  }\\n  return result\\n} : function (string) { return string.split(/\\\\r\\\\n?|\\\\n/); }\\n\\nvar hasSelection = window.getSelection ? function (te) {\\n  try { return te.selectionStart != te.selectionEnd }\\n  catch(e) { return false }\\n} : function (te) {\\n  var range\\n  try {range = te.ownerDocument.selection.createRange()}\\n  catch(e) {}\\n  if (!range || range.parentElement() != te) { return false }\\n  return range.compareEndPoints(\\\"StartToEnd\\\", range) != 0\\n}\\n\\nvar hasCopyEvent = (function () {\\n  var e = elt(\\\"div\\\")\\n  if (\\\"oncopy\\\" in e) { return true }\\n  e.setAttribute(\\\"oncopy\\\", \\\"return;\\\")\\n  return typeof e.oncopy == \\\"function\\\"\\n})()\\n\\nvar badZoomedRects = null\\nfunction hasBadZoomedRects(measure) {\\n  if (badZoomedRects != null) { return badZoomedRects }\\n  var node = removeChildrenAndAdd(measure, elt(\\\"span\\\", \\\"x\\\"))\\n  var normal = node.getBoundingClientRect()\\n  var fromRange = range(node, 0, 1).getBoundingClientRect()\\n  return badZoomedRects = Math.abs(normal.left - fromRange.left) > 1\\n}\\n\\nvar modes = {};\\nvar mimeModes = {};\\n// Extra arguments are stored as the mode's dependencies, which is\\n// used by (legacy) mechanisms like loadmode.js to automatically\\n// load a mode. (Preferred mechanism is the require/define calls.)\\nfunction defineMode(name, mode) {\\n  if (arguments.length > 2)\\n    { mode.dependencies = Array.prototype.slice.call(arguments, 2) }\\n  modes[name] = mode\\n}\\n\\nfunction defineMIME(mime, spec) {\\n  mimeModes[mime] = spec\\n}\\n\\n// Given a MIME type, a {name, ...options} config object, or a name\\n// string, return a mode config object.\\nfunction resolveMode(spec) {\\n  if (typeof spec == \\\"string\\\" && mimeModes.hasOwnProperty(spec)) {\\n    spec = mimeModes[spec]\\n  } else if (spec && typeof spec.name == \\\"string\\\" && mimeModes.hasOwnProperty(spec.name)) {\\n    var found = mimeModes[spec.name]\\n    if (typeof found == \\\"string\\\") { found = {name: found} }\\n    spec = createObj(found, spec)\\n    spec.name = found.name\\n  } else if (typeof spec == \\\"string\\\" && /^[\\\\w\\\\-]+\\\\/[\\\\w\\\\-]+\\\\+xml$/.test(spec)) {\\n    return resolveMode(\\\"application/xml\\\")\\n  } else if (typeof spec == \\\"string\\\" && /^[\\\\w\\\\-]+\\\\/[\\\\w\\\\-]+\\\\+json$/.test(spec)) {\\n    return resolveMode(\\\"application/json\\\")\\n  }\\n  if (typeof spec == \\\"string\\\") { return {name: spec} }\\n  else { return spec || {name: \\\"null\\\"} }\\n}\\n\\n// Given a mode spec (anything that resolveMode accepts), find and\\n// initialize an actual mode object.\\nfunction getMode(options, spec) {\\n  spec = resolveMode(spec)\\n  var mfactory = modes[spec.name]\\n  if (!mfactory) { return getMode(options, \\\"text/plain\\\") }\\n  var modeObj = mfactory(options, spec)\\n  if (modeExtensions.hasOwnProperty(spec.name)) {\\n    var exts = modeExtensions[spec.name]\\n    for (var prop in exts) {\\n      if (!exts.hasOwnProperty(prop)) { continue }\\n      if (modeObj.hasOwnProperty(prop)) { modeObj[\\\"_\\\" + prop] = modeObj[prop] }\\n      modeObj[prop] = exts[prop]\\n    }\\n  }\\n  modeObj.name = spec.name\\n  if (spec.helperType) { modeObj.helperType = spec.helperType }\\n  if (spec.modeProps) { for (var prop$1 in spec.modeProps)\\n    { modeObj[prop$1] = spec.modeProps[prop$1] } }\\n\\n  return modeObj\\n}\\n\\n// This can be used to attach properties to mode objects from\\n// outside the actual mode definition.\\nvar modeExtensions = {}\\nfunction extendMode(mode, properties) {\\n  var exts = modeExtensions.hasOwnProperty(mode) ? modeExtensions[mode] : (modeExtensions[mode] = {})\\n  copyObj(properties, exts)\\n}\\n\\nfunction copyState(mode, state) {\\n  if (state === true) { return state }\\n  if (mode.copyState) { return mode.copyState(state) }\\n  var nstate = {}\\n  for (var n in state) {\\n    var val = state[n]\\n    if (val instanceof Array) { val = val.concat([]) }\\n    nstate[n] = val\\n  }\\n  return nstate\\n}\\n\\n// Given a mode and a state (for that mode), find the inner mode and\\n// state at the position that the state refers to.\\nfunction innerMode(mode, state) {\\n  var info\\n  while (mode.innerMode) {\\n    info = mode.innerMode(state)\\n    if (!info || info.mode == mode) { break }\\n    state = info.state\\n    mode = info.mode\\n  }\\n  return info || {mode: mode, state: state}\\n}\\n\\nfunction startState(mode, a1, a2) {\\n  return mode.startState ? mode.startState(a1, a2) : true\\n}\\n\\n// STRING STREAM\\n\\n// Fed to the mode parsers, provides helper functions to make\\n// parsers more succinct.\\n\\nvar StringStream = function(string, tabSize) {\\n  this.pos = this.start = 0\\n  this.string = string\\n  this.tabSize = tabSize || 8\\n  this.lastColumnPos = this.lastColumnValue = 0\\n  this.lineStart = 0\\n}\\n\\nStringStream.prototype = {\\n  eol: function() {return this.pos >= this.string.length},\\n  sol: function() {return this.pos == this.lineStart},\\n  peek: function() {return this.string.charAt(this.pos) || undefined},\\n  next: function() {\\n    if (this.pos < this.string.length)\\n      { return this.string.charAt(this.pos++) }\\n  },\\n  eat: function(match) {\\n    var ch = this.string.charAt(this.pos)\\n    var ok\\n    if (typeof match == \\\"string\\\") { ok = ch == match }\\n    else { ok = ch && (match.test ? match.test(ch) : match(ch)) }\\n    if (ok) {++this.pos; return ch}\\n  },\\n  eatWhile: function(match) {\\n    var start = this.pos\\n    while (this.eat(match)){}\\n    return this.pos > start\\n  },\\n  eatSpace: function() {\\n    var this$1 = this;\\n\\n    var start = this.pos\\n    while (/[\\\\s\\\\u00a0]/.test(this.string.charAt(this.pos))) { ++this$1.pos }\\n    return this.pos > start\\n  },\\n  skipToEnd: function() {this.pos = this.string.length},\\n  skipTo: function(ch) {\\n    var found = this.string.indexOf(ch, this.pos)\\n    if (found > -1) {this.pos = found; return true}\\n  },\\n  backUp: function(n) {this.pos -= n},\\n  column: function() {\\n    if (this.lastColumnPos < this.start) {\\n      this.lastColumnValue = countColumn(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue)\\n      this.lastColumnPos = this.start\\n    }\\n    return this.lastColumnValue - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0)\\n  },\\n  indentation: function() {\\n    return countColumn(this.string, null, this.tabSize) -\\n      (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0)\\n  },\\n  match: function(pattern, consume, caseInsensitive) {\\n    if (typeof pattern == \\\"string\\\") {\\n      var cased = function (str) { return caseInsensitive ? str.toLowerCase() : str; }\\n      var substr = this.string.substr(this.pos, pattern.length)\\n      if (cased(substr) == cased(pattern)) {\\n        if (consume !== false) { this.pos += pattern.length }\\n        return true\\n      }\\n    } else {\\n      var match = this.string.slice(this.pos).match(pattern)\\n      if (match && match.index > 0) { return null }\\n      if (match && consume !== false) { this.pos += match[0].length }\\n      return match\\n    }\\n  },\\n  current: function(){return this.string.slice(this.start, this.pos)},\\n  hideFirstChars: function(n, inner) {\\n    this.lineStart += n\\n    try { return inner() }\\n    finally { this.lineStart -= n }\\n  }\\n}\\n\\n// Compute a style array (an array starting with a mode generation\\n// -- for invalidation -- followed by pairs of end positions and\\n// style strings), which is used to highlight the tokens on the\\n// line.\\nfunction highlightLine(cm, line, state, forceToEnd) {\\n  // A styles array always starts with a number identifying the\\n  // mode/overlays that it is based on (for easy invalidation).\\n  var st = [cm.state.modeGen], lineClasses = {}\\n  // Compute the base array of styles\\n  runMode(cm, line.text, cm.doc.mode, state, function (end, style) { return st.push(end, style); },\\n    lineClasses, forceToEnd)\\n\\n  // Run overlays, adjust style array.\\n  var loop = function ( o ) {\\n    var overlay = cm.state.overlays[o], i = 1, at = 0\\n    runMode(cm, line.text, overlay.mode, true, function (end, style) {\\n      var start = i\\n      // Ensure there's a token end at the current position, and that i points at it\\n      while (at < end) {\\n        var i_end = st[i]\\n        if (i_end > end)\\n          { st.splice(i, 1, end, st[i+1], i_end) }\\n        i += 2\\n        at = Math.min(end, i_end)\\n      }\\n      if (!style) { return }\\n      if (overlay.opaque) {\\n        st.splice(start, i - start, end, \\\"overlay \\\" + style)\\n        i = start + 2\\n      } else {\\n        for (; start < i; start += 2) {\\n          var cur = st[start+1]\\n          st[start+1] = (cur ? cur + \\\" \\\" : \\\"\\\") + \\\"overlay \\\" + style\\n        }\\n      }\\n    }, lineClasses)\\n  };\\n\\n  for (var o = 0; o < cm.state.overlays.length; ++o) loop( o );\\n\\n  return {styles: st, classes: lineClasses.bgClass || lineClasses.textClass ? lineClasses : null}\\n}\\n\\nfunction getLineStyles(cm, line, updateFrontier) {\\n  if (!line.styles || line.styles[0] != cm.state.modeGen) {\\n    var state = getStateBefore(cm, lineNo(line))\\n    var result = highlightLine(cm, line, line.text.length > cm.options.maxHighlightLength ? copyState(cm.doc.mode, state) : state)\\n    line.stateAfter = state\\n    line.styles = result.styles\\n    if (result.classes) { line.styleClasses = result.classes }\\n    else if (line.styleClasses) { line.styleClasses = null }\\n    if (updateFrontier === cm.doc.frontier) { cm.doc.frontier++ }\\n  }\\n  return line.styles\\n}\\n\\nfunction getStateBefore(cm, n, precise) {\\n  var doc = cm.doc, display = cm.display\\n  if (!doc.mode.startState) { return true }\\n  var pos = findStartLine(cm, n, precise), state = pos > doc.first && getLine(doc, pos-1).stateAfter\\n  if (!state) { state = startState(doc.mode) }\\n  else { state = copyState(doc.mode, state) }\\n  doc.iter(pos, n, function (line) {\\n    processLine(cm, line.text, state)\\n    var save = pos == n - 1 || pos % 5 == 0 || pos >= display.viewFrom && pos < display.viewTo\\n    line.stateAfter = save ? copyState(doc.mode, state) : null\\n    ++pos\\n  })\\n  if (precise) { doc.frontier = pos }\\n  return state\\n}\\n\\n// Lightweight form of highlight -- proceed over this line and\\n// update state, but don't save a style array. Used for lines that\\n// aren't currently visible.\\nfunction processLine(cm, text, state, startAt) {\\n  var mode = cm.doc.mode\\n  var stream = new StringStream(text, cm.options.tabSize)\\n  stream.start = stream.pos = startAt || 0\\n  if (text == \\\"\\\") { callBlankLine(mode, state) }\\n  while (!stream.eol()) {\\n    readToken(mode, stream, state)\\n    stream.start = stream.pos\\n  }\\n}\\n\\nfunction callBlankLine(mode, state) {\\n  if (mode.blankLine) { return mode.blankLine(state) }\\n  if (!mode.innerMode) { return }\\n  var inner = innerMode(mode, state)\\n  if (inner.mode.blankLine) { return inner.mode.blankLine(inner.state) }\\n}\\n\\nfunction readToken(mode, stream, state, inner) {\\n  for (var i = 0; i < 10; i++) {\\n    if (inner) { inner[0] = innerMode(mode, state).mode }\\n    var style = mode.token(stream, state)\\n    if (stream.pos > stream.start) { return style }\\n  }\\n  throw new Error(\\\"Mode \\\" + mode.name + \\\" failed to advance stream.\\\")\\n}\\n\\n// Utility for getTokenAt and getLineTokens\\nfunction takeToken(cm, pos, precise, asArray) {\\n  var getObj = function (copy) { return ({\\n    start: stream.start, end: stream.pos,\\n    string: stream.current(),\\n    type: style || null,\\n    state: copy ? copyState(doc.mode, state) : state\\n  }); }\\n\\n  var doc = cm.doc, mode = doc.mode, style\\n  pos = clipPos(doc, pos)\\n  var line = getLine(doc, pos.line), state = getStateBefore(cm, pos.line, precise)\\n  var stream = new StringStream(line.text, cm.options.tabSize), tokens\\n  if (asArray) { tokens = [] }\\n  while ((asArray || stream.pos < pos.ch) && !stream.eol()) {\\n    stream.start = stream.pos\\n    style = readToken(mode, stream, state)\\n    if (asArray) { tokens.push(getObj(true)) }\\n  }\\n  return asArray ? tokens : getObj()\\n}\\n\\nfunction extractLineClasses(type, output) {\\n  if (type) { for (;;) {\\n    var lineClass = type.match(/(?:^|\\\\s+)line-(background-)?(\\\\S+)/)\\n    if (!lineClass) { break }\\n    type = type.slice(0, lineClass.index) + type.slice(lineClass.index + lineClass[0].length)\\n    var prop = lineClass[1] ? \\\"bgClass\\\" : \\\"textClass\\\"\\n    if (output[prop] == null)\\n      { output[prop] = lineClass[2] }\\n    else if (!(new RegExp(\\\"(?:^|\\\\s)\\\" + lineClass[2] + \\\"(?:$|\\\\s)\\\")).test(output[prop]))\\n      { output[prop] += \\\" \\\" + lineClass[2] }\\n  } }\\n  return type\\n}\\n\\n// Run the given mode's parser over a line, calling f for each token.\\nfunction runMode(cm, text, mode, state, f, lineClasses, forceToEnd) {\\n  var flattenSpans = mode.flattenSpans\\n  if (flattenSpans == null) { flattenSpans = cm.options.flattenSpans }\\n  var curStart = 0, curStyle = null\\n  var stream = new StringStream(text, cm.options.tabSize), style\\n  var inner = cm.options.addModeClass && [null]\\n  if (text == \\\"\\\") { extractLineClasses(callBlankLine(mode, state), lineClasses) }\\n  while (!stream.eol()) {\\n    if (stream.pos > cm.options.maxHighlightLength) {\\n      flattenSpans = false\\n      if (forceToEnd) { processLine(cm, text, state, stream.pos) }\\n      stream.pos = text.length\\n      style = null\\n    } else {\\n      style = extractLineClasses(readToken(mode, stream, state, inner), lineClasses)\\n    }\\n    if (inner) {\\n      var mName = inner[0].name\\n      if (mName) { style = \\\"m-\\\" + (style ? mName + \\\" \\\" + style : mName) }\\n    }\\n    if (!flattenSpans || curStyle != style) {\\n      while (curStart < stream.start) {\\n        curStart = Math.min(stream.start, curStart + 5000)\\n        f(curStart, curStyle)\\n      }\\n      curStyle = style\\n    }\\n    stream.start = stream.pos\\n  }\\n  while (curStart < stream.pos) {\\n    // Webkit seems to refuse to render text nodes longer than 57444\\n    // characters, and returns inaccurate measurements in nodes\\n    // starting around 5000 chars.\\n    var pos = Math.min(stream.pos, curStart + 5000)\\n    f(pos, curStyle)\\n    curStart = pos\\n  }\\n}\\n\\n// Finds the line to start with when starting a parse. Tries to\\n// find a line with a stateAfter, so that it can start with a\\n// valid state. If that fails, it returns the line with the\\n// smallest indentation, which tends to need the least context to\\n// parse correctly.\\nfunction findStartLine(cm, n, precise) {\\n  var minindent, minline, doc = cm.doc\\n  var lim = precise ? -1 : n - (cm.doc.mode.innerMode ? 1000 : 100)\\n  for (var search = n; search > lim; --search) {\\n    if (search <= doc.first) { return doc.first }\\n    var line = getLine(doc, search - 1)\\n    if (line.stateAfter && (!precise || search <= doc.frontier)) { return search }\\n    var indented = countColumn(line.text, null, cm.options.tabSize)\\n    if (minline == null || minindent > indented) {\\n      minline = search - 1\\n      minindent = indented\\n    }\\n  }\\n  return minline\\n}\\n\\n// LINE DATA STRUCTURE\\n\\n// Line objects. These hold state related to a line, including\\n// highlighting info (the styles array).\\nfunction Line(text, markedSpans, estimateHeight) {\\n  this.text = text\\n  attachMarkedSpans(this, markedSpans)\\n  this.height = estimateHeight ? estimateHeight(this) : 1\\n}\\neventMixin(Line)\\nLine.prototype.lineNo = function() { return lineNo(this) }\\n\\n// Change the content (text, markers) of a line. Automatically\\n// invalidates cached information and tries to re-estimate the\\n// line's height.\\nfunction updateLine(line, text, markedSpans, estimateHeight) {\\n  line.text = text\\n  if (line.stateAfter) { line.stateAfter = null }\\n  if (line.styles) { line.styles = null }\\n  if (line.order != null) { line.order = null }\\n  detachMarkedSpans(line)\\n  attachMarkedSpans(line, markedSpans)\\n  var estHeight = estimateHeight ? estimateHeight(line) : 1\\n  if (estHeight != line.height) { updateLineHeight(line, estHeight) }\\n}\\n\\n// Detach a line from the document tree and its markers.\\nfunction cleanUpLine(line) {\\n  line.parent = null\\n  detachMarkedSpans(line)\\n}\\n\\n// Convert a style as returned by a mode (either null, or a string\\n// containing one or more styles) to a CSS style. This is cached,\\n// and also looks for line-wide styles.\\nvar styleToClassCache = {};\\nvar styleToClassCacheWithMode = {};\\nfunction interpretTokenStyle(style, options) {\\n  if (!style || /^\\\\s*$/.test(style)) { return null }\\n  var cache = options.addModeClass ? styleToClassCacheWithMode : styleToClassCache\\n  return cache[style] ||\\n    (cache[style] = style.replace(/\\\\S+/g, \\\"cm-$&\\\"))\\n}\\n\\n// Render the DOM representation of the text of a line. Also builds\\n// up a 'line map', which points at the DOM nodes that represent\\n// specific stretches of text, and is used by the measuring code.\\n// The returned object contains the DOM node, this map, and\\n// information about line-wide styles that were set by the mode.\\nfunction buildLineContent(cm, lineView) {\\n  // The padding-right forces the element to have a 'border', which\\n  // is needed on Webkit to be able to get line-level bounding\\n  // rectangles for it (in measureChar).\\n  var content = elt(\\\"span\\\", null, null, webkit ? \\\"padding-right: .1px\\\" : null)\\n  var builder = {pre: elt(\\\"pre\\\", [content], \\\"CodeMirror-line\\\"), content: content,\\n                 col: 0, pos: 0, cm: cm,\\n                 trailingSpace: false,\\n                 splitSpaces: (ie || webkit) && cm.getOption(\\\"lineWrapping\\\")}\\n  // hide from accessibility tree\\n  content.setAttribute(\\\"role\\\", \\\"presentation\\\")\\n  builder.pre.setAttribute(\\\"role\\\", \\\"presentation\\\")\\n  lineView.measure = {}\\n\\n  // Iterate over the logical lines that make up this visual line.\\n  for (var i = 0; i <= (lineView.rest ? lineView.rest.length : 0); i++) {\\n    var line = i ? lineView.rest[i - 1] : lineView.line, order = (void 0)\\n    builder.pos = 0\\n    builder.addToken = buildToken\\n    // Optionally wire in some hacks into the token-rendering\\n    // algorithm, to deal with browser quirks.\\n    if (hasBadBidiRects(cm.display.measure) && (order = getOrder(line)))\\n      { builder.addToken = buildTokenBadBidi(builder.addToken, order) }\\n    builder.map = []\\n    var allowFrontierUpdate = lineView != cm.display.externalMeasured && lineNo(line)\\n    insertLineContent(line, builder, getLineStyles(cm, line, allowFrontierUpdate))\\n    if (line.styleClasses) {\\n      if (line.styleClasses.bgClass)\\n        { builder.bgClass = joinClasses(line.styleClasses.bgClass, builder.bgClass || \\\"\\\") }\\n      if (line.styleClasses.textClass)\\n        { builder.textClass = joinClasses(line.styleClasses.textClass, builder.textClass || \\\"\\\") }\\n    }\\n\\n    // Ensure at least a single node is present, for measuring.\\n    if (builder.map.length == 0)\\n      { builder.map.push(0, 0, builder.content.appendChild(zeroWidthElement(cm.display.measure))) }\\n\\n    // Store the map and a cache object for the current logical line\\n    if (i == 0) {\\n      lineView.measure.map = builder.map\\n      lineView.measure.cache = {}\\n    } else {\\n      ;(lineView.measure.maps || (lineView.measure.maps = [])).push(builder.map)\\n      ;(lineView.measure.caches || (lineView.measure.caches = [])).push({})\\n    }\\n  }\\n\\n  // See issue #2901\\n  if (webkit) {\\n    var last = builder.content.lastChild\\n    if (/\\\\bcm-tab\\\\b/.test(last.className) || (last.querySelector && last.querySelector(\\\".cm-tab\\\")))\\n      { builder.content.className = \\\"cm-tab-wrap-hack\\\" }\\n  }\\n\\n  signal(cm, \\\"renderLine\\\", cm, lineView.line, builder.pre)\\n  if (builder.pre.className)\\n    { builder.textClass = joinClasses(builder.pre.className, builder.textClass || \\\"\\\") }\\n\\n  return builder\\n}\\n\\nfunction defaultSpecialCharPlaceholder(ch) {\\n  var token = elt(\\\"span\\\", \\\"\\\\u2022\\\", \\\"cm-invalidchar\\\")\\n  token.title = \\\"\\\\\\\\u\\\" + ch.charCodeAt(0).toString(16)\\n  token.setAttribute(\\\"aria-label\\\", token.title)\\n  return token\\n}\\n\\n// Build up the DOM representation for a single token, and add it to\\n// the line map. Takes care to render special characters separately.\\nfunction buildToken(builder, text, style, startStyle, endStyle, title, css) {\\n  if (!text) { return }\\n  var displayText = builder.splitSpaces ? splitSpaces(text, builder.trailingSpace) : text\\n  var special = builder.cm.state.specialChars, mustWrap = false\\n  var content\\n  if (!special.test(text)) {\\n    builder.col += text.length\\n    content = document.createTextNode(displayText)\\n    builder.map.push(builder.pos, builder.pos + text.length, content)\\n    if (ie && ie_version < 9) { mustWrap = true }\\n    builder.pos += text.length\\n  } else {\\n    content = document.createDocumentFragment()\\n    var pos = 0\\n    while (true) {\\n      special.lastIndex = pos\\n      var m = special.exec(text)\\n      var skipped = m ? m.index - pos : text.length - pos\\n      if (skipped) {\\n        var txt = document.createTextNode(displayText.slice(pos, pos + skipped))\\n        if (ie && ie_version < 9) { content.appendChild(elt(\\\"span\\\", [txt])) }\\n        else { content.appendChild(txt) }\\n        builder.map.push(builder.pos, builder.pos + skipped, txt)\\n        builder.col += skipped\\n        builder.pos += skipped\\n      }\\n      if (!m) { break }\\n      pos += skipped + 1\\n      var txt$1 = (void 0)\\n      if (m[0] == \\\"\\\\t\\\") {\\n        var tabSize = builder.cm.options.tabSize, tabWidth = tabSize - builder.col % tabSize\\n        txt$1 = content.appendChild(elt(\\\"span\\\", spaceStr(tabWidth), \\\"cm-tab\\\"))\\n        txt$1.setAttribute(\\\"role\\\", \\\"presentation\\\")\\n        txt$1.setAttribute(\\\"cm-text\\\", \\\"\\\\t\\\")\\n        builder.col += tabWidth\\n      } else if (m[0] == \\\"\\\\r\\\" || m[0] == \\\"\\\\n\\\") {\\n        txt$1 = content.appendChild(elt(\\\"span\\\", m[0] == \\\"\\\\r\\\" ? \\\"\\\\u240d\\\" : \\\"\\\\u2424\\\", \\\"cm-invalidchar\\\"))\\n        txt$1.setAttribute(\\\"cm-text\\\", m[0])\\n        builder.col += 1\\n      } else {\\n        txt$1 = builder.cm.options.specialCharPlaceholder(m[0])\\n        txt$1.setAttribute(\\\"cm-text\\\", m[0])\\n        if (ie && ie_version < 9) { content.appendChild(elt(\\\"span\\\", [txt$1])) }\\n        else { content.appendChild(txt$1) }\\n        builder.col += 1\\n      }\\n      builder.map.push(builder.pos, builder.pos + 1, txt$1)\\n      builder.pos++\\n    }\\n  }\\n  builder.trailingSpace = displayText.charCodeAt(text.length - 1) == 32\\n  if (style || startStyle || endStyle || mustWrap || css) {\\n    var fullStyle = style || \\\"\\\"\\n    if (startStyle) { fullStyle += startStyle }\\n    if (endStyle) { fullStyle += endStyle }\\n    var token = elt(\\\"span\\\", [content], fullStyle, css)\\n    if (title) { token.title = title }\\n    return builder.content.appendChild(token)\\n  }\\n  builder.content.appendChild(content)\\n}\\n\\nfunction splitSpaces(text, trailingBefore) {\\n  if (text.length > 1 && !/  /.test(text)) { return text }\\n  var spaceBefore = trailingBefore, result = \\\"\\\"\\n  for (var i = 0; i < text.length; i++) {\\n    var ch = text.charAt(i)\\n    if (ch == \\\" \\\" && spaceBefore && (i == text.length - 1 || text.charCodeAt(i + 1) == 32))\\n      { ch = \\\"\\\\u00a0\\\" }\\n    result += ch\\n    spaceBefore = ch == \\\" \\\"\\n  }\\n  return result\\n}\\n\\n// Work around nonsense dimensions being reported for stretches of\\n// right-to-left text.\\nfunction buildTokenBadBidi(inner, order) {\\n  return function (builder, text, style, startStyle, endStyle, title, css) {\\n    style = style ? style + \\\" cm-force-border\\\" : \\\"cm-force-border\\\"\\n    var start = builder.pos, end = start + text.length\\n    for (;;) {\\n      // Find the part that overlaps with the start of this text\\n      var part = (void 0)\\n      for (var i = 0; i < order.length; i++) {\\n        part = order[i]\\n        if (part.to > start && part.from <= start) { break }\\n      }\\n      if (part.to >= end) { return inner(builder, text, style, startStyle, endStyle, title, css) }\\n      inner(builder, text.slice(0, part.to - start), style, startStyle, null, title, css)\\n      startStyle = null\\n      text = text.slice(part.to - start)\\n      start = part.to\\n    }\\n  }\\n}\\n\\nfunction buildCollapsedSpan(builder, size, marker, ignoreWidget) {\\n  var widget = !ignoreWidget && marker.widgetNode\\n  if (widget) { builder.map.push(builder.pos, builder.pos + size, widget) }\\n  if (!ignoreWidget && builder.cm.display.input.needsContentAttribute) {\\n    if (!widget)\\n      { widget = builder.content.appendChild(document.createElement(\\\"span\\\")) }\\n    widget.setAttribute(\\\"cm-marker\\\", marker.id)\\n  }\\n  if (widget) {\\n    builder.cm.display.input.setUneditable(widget)\\n    builder.content.appendChild(widget)\\n  }\\n  builder.pos += size\\n  builder.trailingSpace = false\\n}\\n\\n// Outputs a number of spans to make up a line, taking highlighting\\n// and marked text into account.\\nfunction insertLineContent(line, builder, styles) {\\n  var spans = line.markedSpans, allText = line.text, at = 0\\n  if (!spans) {\\n    for (var i$1 = 1; i$1 < styles.length; i$1+=2)\\n      { builder.addToken(builder, allText.slice(at, at = styles[i$1]), interpretTokenStyle(styles[i$1+1], builder.cm.options)) }\\n    return\\n  }\\n\\n  var len = allText.length, pos = 0, i = 1, text = \\\"\\\", style, css\\n  var nextChange = 0, spanStyle, spanEndStyle, spanStartStyle, title, collapsed\\n  for (;;) {\\n    if (nextChange == pos) { // Update current marker set\\n      spanStyle = spanEndStyle = spanStartStyle = title = css = \\\"\\\"\\n      collapsed = null; nextChange = Infinity\\n      var foundBookmarks = [], endStyles = (void 0)\\n      for (var j = 0; j < spans.length; ++j) {\\n        var sp = spans[j], m = sp.marker\\n        if (m.type == \\\"bookmark\\\" && sp.from == pos && m.widgetNode) {\\n          foundBookmarks.push(m)\\n        } else if (sp.from <= pos && (sp.to == null || sp.to > pos || m.collapsed && sp.to == pos && sp.from == pos)) {\\n          if (sp.to != null && sp.to != pos && nextChange > sp.to) {\\n            nextChange = sp.to\\n            spanEndStyle = \\\"\\\"\\n          }\\n          if (m.className) { spanStyle += \\\" \\\" + m.className }\\n          if (m.css) { css = (css ? css + \\\";\\\" : \\\"\\\") + m.css }\\n          if (m.startStyle && sp.from == pos) { spanStartStyle += \\\" \\\" + m.startStyle }\\n          if (m.endStyle && sp.to == nextChange) { (endStyles || (endStyles = [])).push(m.endStyle, sp.to) }\\n          if (m.title && !title) { title = m.title }\\n          if (m.collapsed && (!collapsed || compareCollapsedMarkers(collapsed.marker, m) < 0))\\n            { collapsed = sp }\\n        } else if (sp.from > pos && nextChange > sp.from) {\\n          nextChange = sp.from\\n        }\\n      }\\n      if (endStyles) { for (var j$1 = 0; j$1 < endStyles.length; j$1 += 2)\\n        { if (endStyles[j$1 + 1] == nextChange) { spanEndStyle += \\\" \\\" + endStyles[j$1] } } }\\n\\n      if (!collapsed || collapsed.from == pos) { for (var j$2 = 0; j$2 < foundBookmarks.length; ++j$2)\\n        { buildCollapsedSpan(builder, 0, foundBookmarks[j$2]) } }\\n      if (collapsed && (collapsed.from || 0) == pos) {\\n        buildCollapsedSpan(builder, (collapsed.to == null ? len + 1 : collapsed.to) - pos,\\n                           collapsed.marker, collapsed.from == null)\\n        if (collapsed.to == null) { return }\\n        if (collapsed.to == pos) { collapsed = false }\\n      }\\n    }\\n    if (pos >= len) { break }\\n\\n    var upto = Math.min(len, nextChange)\\n    while (true) {\\n      if (text) {\\n        var end = pos + text.length\\n        if (!collapsed) {\\n          var tokenText = end > upto ? text.slice(0, upto - pos) : text\\n          builder.addToken(builder, tokenText, style ? style + spanStyle : spanStyle,\\n                           spanStartStyle, pos + tokenText.length == nextChange ? spanEndStyle : \\\"\\\", title, css)\\n        }\\n        if (end >= upto) {text = text.slice(upto - pos); pos = upto; break}\\n        pos = end\\n        spanStartStyle = \\\"\\\"\\n      }\\n      text = allText.slice(at, at = styles[i++])\\n      style = interpretTokenStyle(styles[i++], builder.cm.options)\\n    }\\n  }\\n}\\n\\n\\n// These objects are used to represent the visible (currently drawn)\\n// part of the document. A LineView may correspond to multiple\\n// logical lines, if those are connected by collapsed ranges.\\nfunction LineView(doc, line, lineN) {\\n  // The starting line\\n  this.line = line\\n  // Continuing lines, if any\\n  this.rest = visualLineContinued(line)\\n  // Number of logical lines in this visual line\\n  this.size = this.rest ? lineNo(lst(this.rest)) - lineN + 1 : 1\\n  this.node = this.text = null\\n  this.hidden = lineIsHidden(doc, line)\\n}\\n\\n// Create a range of LineView objects for the given lines.\\nfunction buildViewArray(cm, from, to) {\\n  var array = [], nextPos\\n  for (var pos = from; pos < to; pos = nextPos) {\\n    var view = new LineView(cm.doc, getLine(cm.doc, pos), pos)\\n    nextPos = pos + view.size\\n    array.push(view)\\n  }\\n  return array\\n}\\n\\nvar operationGroup = null\\n\\nfunction pushOperation(op) {\\n  if (operationGroup) {\\n    operationGroup.ops.push(op)\\n  } else {\\n    op.ownsGroup = operationGroup = {\\n      ops: [op],\\n      delayedCallbacks: []\\n    }\\n  }\\n}\\n\\nfunction fireCallbacksForOps(group) {\\n  // Calls delayed callbacks and cursorActivity handlers until no\\n  // new ones appear\\n  var callbacks = group.delayedCallbacks, i = 0\\n  do {\\n    for (; i < callbacks.length; i++)\\n      { callbacks[i].call(null) }\\n    for (var j = 0; j < group.ops.length; j++) {\\n      var op = group.ops[j]\\n      if (op.cursorActivityHandlers)\\n        { while (op.cursorActivityCalled < op.cursorActivityHandlers.length)\\n          { op.cursorActivityHandlers[op.cursorActivityCalled++].call(null, op.cm) } }\\n    }\\n  } while (i < callbacks.length)\\n}\\n\\nfunction finishOperation(op, endCb) {\\n  var group = op.ownsGroup\\n  if (!group) { return }\\n\\n  try { fireCallbacksForOps(group) }\\n  finally {\\n    operationGroup = null\\n    endCb(group)\\n  }\\n}\\n\\nvar orphanDelayedCallbacks = null\\n\\n// Often, we want to signal events at a point where we are in the\\n// middle of some work, but don't want the handler to start calling\\n// other methods on the editor, which might be in an inconsistent\\n// state or simply not expect any other events to happen.\\n// signalLater looks whether there are any handlers, and schedules\\n// them to be executed when the last operation ends, or, if no\\n// operation is active, when a timeout fires.\\nfunction signalLater(emitter, type /*, values...*/) {\\n  var arr = getHandlers(emitter, type)\\n  if (!arr.length) { return }\\n  var args = Array.prototype.slice.call(arguments, 2), list\\n  if (operationGroup) {\\n    list = operationGroup.delayedCallbacks\\n  } else if (orphanDelayedCallbacks) {\\n    list = orphanDelayedCallbacks\\n  } else {\\n    list = orphanDelayedCallbacks = []\\n    setTimeout(fireOrphanDelayed, 0)\\n  }\\n  var loop = function ( i ) {\\n    list.push(function () { return arr[i].apply(null, args); })\\n  };\\n\\n  for (var i = 0; i < arr.length; ++i)\\n    loop( i );\\n}\\n\\nfunction fireOrphanDelayed() {\\n  var delayed = orphanDelayedCallbacks\\n  orphanDelayedCallbacks = null\\n  for (var i = 0; i < delayed.length; ++i) { delayed[i]() }\\n}\\n\\n// When an aspect of a line changes, a string is added to\\n// lineView.changes. This updates the relevant part of the line's\\n// DOM structure.\\nfunction updateLineForChanges(cm, lineView, lineN, dims) {\\n  for (var j = 0; j < lineView.changes.length; j++) {\\n    var type = lineView.changes[j]\\n    if (type == \\\"text\\\") { updateLineText(cm, lineView) }\\n    else if (type == \\\"gutter\\\") { updateLineGutter(cm, lineView, lineN, dims) }\\n    else if (type == \\\"class\\\") { updateLineClasses(lineView) }\\n    else if (type == \\\"widget\\\") { updateLineWidgets(cm, lineView, dims) }\\n  }\\n  lineView.changes = null\\n}\\n\\n// Lines with gutter elements, widgets or a background class need to\\n// be wrapped, and have the extra elements added to the wrapper div\\nfunction ensureLineWrapped(lineView) {\\n  if (lineView.node == lineView.text) {\\n    lineView.node = elt(\\\"div\\\", null, null, \\\"position: relative\\\")\\n    if (lineView.text.parentNode)\\n      { lineView.text.parentNode.replaceChild(lineView.node, lineView.text) }\\n    lineView.node.appendChild(lineView.text)\\n    if (ie && ie_version < 8) { lineView.node.style.zIndex = 2 }\\n  }\\n  return lineView.node\\n}\\n\\nfunction updateLineBackground(lineView) {\\n  var cls = lineView.bgClass ? lineView.bgClass + \\\" \\\" + (lineView.line.bgClass || \\\"\\\") : lineView.line.bgClass\\n  if (cls) { cls += \\\" CodeMirror-linebackground\\\" }\\n  if (lineView.background) {\\n    if (cls) { lineView.background.className = cls }\\n    else { lineView.background.parentNode.removeChild(lineView.background); lineView.background = null }\\n  } else if (cls) {\\n    var wrap = ensureLineWrapped(lineView)\\n    lineView.background = wrap.insertBefore(elt(\\\"div\\\", null, cls), wrap.firstChild)\\n  }\\n}\\n\\n// Wrapper around buildLineContent which will reuse the structure\\n// in display.externalMeasured when possible.\\nfunction getLineContent(cm, lineView) {\\n  var ext = cm.display.externalMeasured\\n  if (ext && ext.line == lineView.line) {\\n    cm.display.externalMeasured = null\\n    lineView.measure = ext.measure\\n    return ext.built\\n  }\\n  return buildLineContent(cm, lineView)\\n}\\n\\n// Redraw the line's text. Interacts with the background and text\\n// classes because the mode may output tokens that influence these\\n// classes.\\nfunction updateLineText(cm, lineView) {\\n  var cls = lineView.text.className\\n  var built = getLineContent(cm, lineView)\\n  if (lineView.text == lineView.node) { lineView.node = built.pre }\\n  lineView.text.parentNode.replaceChild(built.pre, lineView.text)\\n  lineView.text = built.pre\\n  if (built.bgClass != lineView.bgClass || built.textClass != lineView.textClass) {\\n    lineView.bgClass = built.bgClass\\n    lineView.textClass = built.textClass\\n    updateLineClasses(lineView)\\n  } else if (cls) {\\n    lineView.text.className = cls\\n  }\\n}\\n\\nfunction updateLineClasses(lineView) {\\n  updateLineBackground(lineView)\\n  if (lineView.line.wrapClass)\\n    { ensureLineWrapped(lineView).className = lineView.line.wrapClass }\\n  else if (lineView.node != lineView.text)\\n    { lineView.node.className = \\\"\\\" }\\n  var textClass = lineView.textClass ? lineView.textClass + \\\" \\\" + (lineView.line.textClass || \\\"\\\") : lineView.line.textClass\\n  lineView.text.className = textClass || \\\"\\\"\\n}\\n\\nfunction updateLineGutter(cm, lineView, lineN, dims) {\\n  if (lineView.gutter) {\\n    lineView.node.removeChild(lineView.gutter)\\n    lineView.gutter = null\\n  }\\n  if (lineView.gutterBackground) {\\n    lineView.node.removeChild(lineView.gutterBackground)\\n    lineView.gutterBackground = null\\n  }\\n  if (lineView.line.gutterClass) {\\n    var wrap = ensureLineWrapped(lineView)\\n    lineView.gutterBackground = elt(\\\"div\\\", null, \\\"CodeMirror-gutter-background \\\" + lineView.line.gutterClass,\\n                                    (\\\"left: \\\" + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + \\\"px; width: \\\" + (dims.gutterTotalWidth) + \\\"px\\\"))\\n    wrap.insertBefore(lineView.gutterBackground, lineView.text)\\n  }\\n  var markers = lineView.line.gutterMarkers\\n  if (cm.options.lineNumbers || markers) {\\n    var wrap$1 = ensureLineWrapped(lineView)\\n    var gutterWrap = lineView.gutter = elt(\\\"div\\\", null, \\\"CodeMirror-gutter-wrapper\\\", (\\\"left: \\\" + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + \\\"px\\\"))\\n    cm.display.input.setUneditable(gutterWrap)\\n    wrap$1.insertBefore(gutterWrap, lineView.text)\\n    if (lineView.line.gutterClass)\\n      { gutterWrap.className += \\\" \\\" + lineView.line.gutterClass }\\n    if (cm.options.lineNumbers && (!markers || !markers[\\\"CodeMirror-linenumbers\\\"]))\\n      { lineView.lineNumber = gutterWrap.appendChild(\\n        elt(\\\"div\\\", lineNumberFor(cm.options, lineN),\\n            \\\"CodeMirror-linenumber CodeMirror-gutter-elt\\\",\\n            (\\\"left: \\\" + (dims.gutterLeft[\\\"CodeMirror-linenumbers\\\"]) + \\\"px; width: \\\" + (cm.display.lineNumInnerWidth) + \\\"px\\\"))) }\\n    if (markers) { for (var k = 0; k < cm.options.gutters.length; ++k) {\\n      var id = cm.options.gutters[k], found = markers.hasOwnProperty(id) && markers[id]\\n      if (found)\\n        { gutterWrap.appendChild(elt(\\\"div\\\", [found], \\\"CodeMirror-gutter-elt\\\",\\n                                   (\\\"left: \\\" + (dims.gutterLeft[id]) + \\\"px; width: \\\" + (dims.gutterWidth[id]) + \\\"px\\\"))) }\\n    } }\\n  }\\n}\\n\\nfunction updateLineWidgets(cm, lineView, dims) {\\n  if (lineView.alignable) { lineView.alignable = null }\\n  for (var node = lineView.node.firstChild, next = (void 0); node; node = next) {\\n    next = node.nextSibling\\n    if (node.className == \\\"CodeMirror-linewidget\\\")\\n      { lineView.node.removeChild(node) }\\n  }\\n  insertLineWidgets(cm, lineView, dims)\\n}\\n\\n// Build a line's DOM representation from scratch\\nfunction buildLineElement(cm, lineView, lineN, dims) {\\n  var built = getLineContent(cm, lineView)\\n  lineView.text = lineView.node = built.pre\\n  if (built.bgClass) { lineView.bgClass = built.bgClass }\\n  if (built.textClass) { lineView.textClass = built.textClass }\\n\\n  updateLineClasses(lineView)\\n  updateLineGutter(cm, lineView, lineN, dims)\\n  insertLineWidgets(cm, lineView, dims)\\n  return lineView.node\\n}\\n\\n// A lineView may contain multiple logical lines (when merged by\\n// collapsed spans). The widgets for all of them need to be drawn.\\nfunction insertLineWidgets(cm, lineView, dims) {\\n  insertLineWidgetsFor(cm, lineView.line, lineView, dims, true)\\n  if (lineView.rest) { for (var i = 0; i < lineView.rest.length; i++)\\n    { insertLineWidgetsFor(cm, lineView.rest[i], lineView, dims, false) } }\\n}\\n\\nfunction insertLineWidgetsFor(cm, line, lineView, dims, allowAbove) {\\n  if (!line.widgets) { return }\\n  var wrap = ensureLineWrapped(lineView)\\n  for (var i = 0, ws = line.widgets; i < ws.length; ++i) {\\n    var widget = ws[i], node = elt(\\\"div\\\", [widget.node], \\\"CodeMirror-linewidget\\\")\\n    if (!widget.handleMouseEvents) { node.setAttribute(\\\"cm-ignore-events\\\", \\\"true\\\") }\\n    positionLineWidget(widget, node, lineView, dims)\\n    cm.display.input.setUneditable(node)\\n    if (allowAbove && widget.above)\\n      { wrap.insertBefore(node, lineView.gutter || lineView.text) }\\n    else\\n      { wrap.appendChild(node) }\\n    signalLater(widget, \\\"redraw\\\")\\n  }\\n}\\n\\nfunction positionLineWidget(widget, node, lineView, dims) {\\n  if (widget.noHScroll) {\\n    ;(lineView.alignable || (lineView.alignable = [])).push(node)\\n    var width = dims.wrapperWidth\\n    node.style.left = dims.fixedPos + \\\"px\\\"\\n    if (!widget.coverGutter) {\\n      width -= dims.gutterTotalWidth\\n      node.style.paddingLeft = dims.gutterTotalWidth + \\\"px\\\"\\n    }\\n    node.style.width = width + \\\"px\\\"\\n  }\\n  if (widget.coverGutter) {\\n    node.style.zIndex = 5\\n    node.style.position = \\\"relative\\\"\\n    if (!widget.noHScroll) { node.style.marginLeft = -dims.gutterTotalWidth + \\\"px\\\" }\\n  }\\n}\\n\\nfunction widgetHeight(widget) {\\n  if (widget.height != null) { return widget.height }\\n  var cm = widget.doc.cm\\n  if (!cm) { return 0 }\\n  if (!contains(document.body, widget.node)) {\\n    var parentStyle = \\\"position: relative;\\\"\\n    if (widget.coverGutter)\\n      { parentStyle += \\\"margin-left: -\\\" + cm.display.gutters.offsetWidth + \\\"px;\\\" }\\n    if (widget.noHScroll)\\n      { parentStyle += \\\"width: \\\" + cm.display.wrapper.clientWidth + \\\"px;\\\" }\\n    removeChildrenAndAdd(cm.display.measure, elt(\\\"div\\\", [widget.node], null, parentStyle))\\n  }\\n  return widget.height = widget.node.parentNode.offsetHeight\\n}\\n\\n// Return true when the given mouse event happened in a widget\\nfunction eventInWidget(display, e) {\\n  for (var n = e_target(e); n != display.wrapper; n = n.parentNode) {\\n    if (!n || (n.nodeType == 1 && n.getAttribute(\\\"cm-ignore-events\\\") == \\\"true\\\") ||\\n        (n.parentNode == display.sizer && n != display.mover))\\n      { return true }\\n  }\\n}\\n\\n// POSITION MEASUREMENT\\n\\nfunction paddingTop(display) {return display.lineSpace.offsetTop}\\nfunction paddingVert(display) {return display.mover.offsetHeight - display.lineSpace.offsetHeight}\\nfunction paddingH(display) {\\n  if (display.cachedPaddingH) { return display.cachedPaddingH }\\n  var e = removeChildrenAndAdd(display.measure, elt(\\\"pre\\\", \\\"x\\\"))\\n  var style = window.getComputedStyle ? window.getComputedStyle(e) : e.currentStyle\\n  var data = {left: parseInt(style.paddingLeft), right: parseInt(style.paddingRight)}\\n  if (!isNaN(data.left) && !isNaN(data.right)) { display.cachedPaddingH = data }\\n  return data\\n}\\n\\nfunction scrollGap(cm) { return scrollerGap - cm.display.nativeBarWidth }\\nfunction displayWidth(cm) {\\n  return cm.display.scroller.clientWidth - scrollGap(cm) - cm.display.barWidth\\n}\\nfunction displayHeight(cm) {\\n  return cm.display.scroller.clientHeight - scrollGap(cm) - cm.display.barHeight\\n}\\n\\n// Ensure the lineView.wrapping.heights array is populated. This is\\n// an array of bottom offsets for the lines that make up a drawn\\n// line. When lineWrapping is on, there might be more than one\\n// height.\\nfunction ensureLineHeights(cm, lineView, rect) {\\n  var wrapping = cm.options.lineWrapping\\n  var curWidth = wrapping && displayWidth(cm)\\n  if (!lineView.measure.heights || wrapping && lineView.measure.width != curWidth) {\\n    var heights = lineView.measure.heights = []\\n    if (wrapping) {\\n      lineView.measure.width = curWidth\\n      var rects = lineView.text.firstChild.getClientRects()\\n      for (var i = 0; i < rects.length - 1; i++) {\\n        var cur = rects[i], next = rects[i + 1]\\n        if (Math.abs(cur.bottom - next.bottom) > 2)\\n          { heights.push((cur.bottom + next.top) / 2 - rect.top) }\\n      }\\n    }\\n    heights.push(rect.bottom - rect.top)\\n  }\\n}\\n\\n// Find a line map (mapping character offsets to text nodes) and a\\n// measurement cache for the given line number. (A line view might\\n// contain multiple lines when collapsed ranges are present.)\\nfunction mapFromLineView(lineView, line, lineN) {\\n  if (lineView.line == line)\\n    { return {map: lineView.measure.map, cache: lineView.measure.cache} }\\n  for (var i = 0; i < lineView.rest.length; i++)\\n    { if (lineView.rest[i] == line)\\n      { return {map: lineView.measure.maps[i], cache: lineView.measure.caches[i]} } }\\n  for (var i$1 = 0; i$1 < lineView.rest.length; i$1++)\\n    { if (lineNo(lineView.rest[i$1]) > lineN)\\n      { return {map: lineView.measure.maps[i$1], cache: lineView.measure.caches[i$1], before: true} } }\\n}\\n\\n// Render a line into the hidden node display.externalMeasured. Used\\n// when measurement is needed for a line that's not in the viewport.\\nfunction updateExternalMeasurement(cm, line) {\\n  line = visualLine(line)\\n  var lineN = lineNo(line)\\n  var view = cm.display.externalMeasured = new LineView(cm.doc, line, lineN)\\n  view.lineN = lineN\\n  var built = view.built = buildLineContent(cm, view)\\n  view.text = built.pre\\n  removeChildrenAndAdd(cm.display.lineMeasure, built.pre)\\n  return view\\n}\\n\\n// Get a {top, bottom, left, right} box (in line-local coordinates)\\n// for a given character.\\nfunction measureChar(cm, line, ch, bias) {\\n  return measureCharPrepared(cm, prepareMeasureForLine(cm, line), ch, bias)\\n}\\n\\n// Find a line view that corresponds to the given line number.\\nfunction findViewForLine(cm, lineN) {\\n  if (lineN >= cm.display.viewFrom && lineN < cm.display.viewTo)\\n    { return cm.display.view[findViewIndex(cm, lineN)] }\\n  var ext = cm.display.externalMeasured\\n  if (ext && lineN >= ext.lineN && lineN < ext.lineN + ext.size)\\n    { return ext }\\n}\\n\\n// Measurement can be split in two steps, the set-up work that\\n// applies to the whole line, and the measurement of the actual\\n// character. Functions like coordsChar, that need to do a lot of\\n// measurements in a row, can thus ensure that the set-up work is\\n// only done once.\\nfunction prepareMeasureForLine(cm, line) {\\n  var lineN = lineNo(line)\\n  var view = findViewForLine(cm, lineN)\\n  if (view && !view.text) {\\n    view = null\\n  } else if (view && view.changes) {\\n    updateLineForChanges(cm, view, lineN, getDimensions(cm))\\n    cm.curOp.forceUpdate = true\\n  }\\n  if (!view)\\n    { view = updateExternalMeasurement(cm, line) }\\n\\n  var info = mapFromLineView(view, line, lineN)\\n  return {\\n    line: line, view: view, rect: null,\\n    map: info.map, cache: info.cache, before: info.before,\\n    hasHeights: false\\n  }\\n}\\n\\n// Given a prepared measurement object, measures the position of an\\n// actual character (or fetches it from the cache).\\nfunction measureCharPrepared(cm, prepared, ch, bias, varHeight) {\\n  if (prepared.before) { ch = -1 }\\n  var key = ch + (bias || \\\"\\\"), found\\n  if (prepared.cache.hasOwnProperty(key)) {\\n    found = prepared.cache[key]\\n  } else {\\n    if (!prepared.rect)\\n      { prepared.rect = prepared.view.text.getBoundingClientRect() }\\n    if (!prepared.hasHeights) {\\n      ensureLineHeights(cm, prepared.view, prepared.rect)\\n      prepared.hasHeights = true\\n    }\\n    found = measureCharInner(cm, prepared, ch, bias)\\n    if (!found.bogus) { prepared.cache[key] = found }\\n  }\\n  return {left: found.left, right: found.right,\\n          top: varHeight ? found.rtop : found.top,\\n          bottom: varHeight ? found.rbottom : found.bottom}\\n}\\n\\nvar nullRect = {left: 0, right: 0, top: 0, bottom: 0}\\n\\nfunction nodeAndOffsetInLineMap(map, ch, bias) {\\n  var node, start, end, collapse, mStart, mEnd\\n  // First, search the line map for the text node corresponding to,\\n  // or closest to, the target character.\\n  for (var i = 0; i < map.length; i += 3) {\\n    mStart = map[i]\\n    mEnd = map[i + 1]\\n    if (ch < mStart) {\\n      start = 0; end = 1\\n      collapse = \\\"left\\\"\\n    } else if (ch < mEnd) {\\n      start = ch - mStart\\n      end = start + 1\\n    } else if (i == map.length - 3 || ch == mEnd && map[i + 3] > ch) {\\n      end = mEnd - mStart\\n      start = end - 1\\n      if (ch >= mEnd) { collapse = \\\"right\\\" }\\n    }\\n    if (start != null) {\\n      node = map[i + 2]\\n      if (mStart == mEnd && bias == (node.insertLeft ? \\\"left\\\" : \\\"right\\\"))\\n        { collapse = bias }\\n      if (bias == \\\"left\\\" && start == 0)\\n        { while (i && map[i - 2] == map[i - 3] && map[i - 1].insertLeft) {\\n          node = map[(i -= 3) + 2]\\n          collapse = \\\"left\\\"\\n        } }\\n      if (bias == \\\"right\\\" && start == mEnd - mStart)\\n        { while (i < map.length - 3 && map[i + 3] == map[i + 4] && !map[i + 5].insertLeft) {\\n          node = map[(i += 3) + 2]\\n          collapse = \\\"right\\\"\\n        } }\\n      break\\n    }\\n  }\\n  return {node: node, start: start, end: end, collapse: collapse, coverStart: mStart, coverEnd: mEnd}\\n}\\n\\nfunction getUsefulRect(rects, bias) {\\n  var rect = nullRect\\n  if (bias == \\\"left\\\") { for (var i = 0; i < rects.length; i++) {\\n    if ((rect = rects[i]).left != rect.right) { break }\\n  } } else { for (var i$1 = rects.length - 1; i$1 >= 0; i$1--) {\\n    if ((rect = rects[i$1]).left != rect.right) { break }\\n  } }\\n  return rect\\n}\\n\\nfunction measureCharInner(cm, prepared, ch, bias) {\\n  var place = nodeAndOffsetInLineMap(prepared.map, ch, bias)\\n  var node = place.node, start = place.start, end = place.end, collapse = place.collapse\\n\\n  var rect\\n  if (node.nodeType == 3) { // If it is a text node, use a range to retrieve the coordinates.\\n    for (var i$1 = 0; i$1 < 4; i$1++) { // Retry a maximum of 4 times when nonsense rectangles are returned\\n      while (start && isExtendingChar(prepared.line.text.charAt(place.coverStart + start))) { --start }\\n      while (place.coverStart + end < place.coverEnd && isExtendingChar(prepared.line.text.charAt(place.coverStart + end))) { ++end }\\n      if (ie && ie_version < 9 && start == 0 && end == place.coverEnd - place.coverStart)\\n        { rect = node.parentNode.getBoundingClientRect() }\\n      else\\n        { rect = getUsefulRect(range(node, start, end).getClientRects(), bias) }\\n      if (rect.left || rect.right || start == 0) { break }\\n      end = start\\n      start = start - 1\\n      collapse = \\\"right\\\"\\n    }\\n    if (ie && ie_version < 11) { rect = maybeUpdateRectForZooming(cm.display.measure, rect) }\\n  } else { // If it is a widget, simply get the box for the whole widget.\\n    if (start > 0) { collapse = bias = \\\"right\\\" }\\n    var rects\\n    if (cm.options.lineWrapping && (rects = node.getClientRects()).length > 1)\\n      { rect = rects[bias == \\\"right\\\" ? rects.length - 1 : 0] }\\n    else\\n      { rect = node.getBoundingClientRect() }\\n  }\\n  if (ie && ie_version < 9 && !start && (!rect || !rect.left && !rect.right)) {\\n    var rSpan = node.parentNode.getClientRects()[0]\\n    if (rSpan)\\n      { rect = {left: rSpan.left, right: rSpan.left + charWidth(cm.display), top: rSpan.top, bottom: rSpan.bottom} }\\n    else\\n      { rect = nullRect }\\n  }\\n\\n  var rtop = rect.top - prepared.rect.top, rbot = rect.bottom - prepared.rect.top\\n  var mid = (rtop + rbot) / 2\\n  var heights = prepared.view.measure.heights\\n  var i = 0\\n  for (; i < heights.length - 1; i++)\\n    { if (mid < heights[i]) { break } }\\n  var top = i ? heights[i - 1] : 0, bot = heights[i]\\n  var result = {left: (collapse == \\\"right\\\" ? rect.right : rect.left) - prepared.rect.left,\\n                right: (collapse == \\\"left\\\" ? rect.left : rect.right) - prepared.rect.left,\\n                top: top, bottom: bot}\\n  if (!rect.left && !rect.right) { result.bogus = true }\\n  if (!cm.options.singleCursorHeightPerLine) { result.rtop = rtop; result.rbottom = rbot }\\n\\n  return result\\n}\\n\\n// Work around problem with bounding client rects on ranges being\\n// returned incorrectly when zoomed on IE10 and below.\\nfunction maybeUpdateRectForZooming(measure, rect) {\\n  if (!window.screen || screen.logicalXDPI == null ||\\n      screen.logicalXDPI == screen.deviceXDPI || !hasBadZoomedRects(measure))\\n    { return rect }\\n  var scaleX = screen.logicalXDPI / screen.deviceXDPI\\n  var scaleY = screen.logicalYDPI / screen.deviceYDPI\\n  return {left: rect.left * scaleX, right: rect.right * scaleX,\\n          top: rect.top * scaleY, bottom: rect.bottom * scaleY}\\n}\\n\\nfunction clearLineMeasurementCacheFor(lineView) {\\n  if (lineView.measure) {\\n    lineView.measure.cache = {}\\n    lineView.measure.heights = null\\n    if (lineView.rest) { for (var i = 0; i < lineView.rest.length; i++)\\n      { lineView.measure.caches[i] = {} } }\\n  }\\n}\\n\\nfunction clearLineMeasurementCache(cm) {\\n  cm.display.externalMeasure = null\\n  removeChildren(cm.display.lineMeasure)\\n  for (var i = 0; i < cm.display.view.length; i++)\\n    { clearLineMeasurementCacheFor(cm.display.view[i]) }\\n}\\n\\nfunction clearCaches(cm) {\\n  clearLineMeasurementCache(cm)\\n  cm.display.cachedCharWidth = cm.display.cachedTextHeight = cm.display.cachedPaddingH = null\\n  if (!cm.options.lineWrapping) { cm.display.maxLineChanged = true }\\n  cm.display.lineNumChars = null\\n}\\n\\nfunction pageScrollX() { return window.pageXOffset || (document.documentElement || document.body).scrollLeft }\\nfunction pageScrollY() { return window.pageYOffset || (document.documentElement || document.body).scrollTop }\\n\\n// Converts a {top, bottom, left, right} box from line-local\\n// coordinates into another coordinate system. Context may be one of\\n// \\\"line\\\", \\\"div\\\" (display.lineDiv), \\\"local\\\"./null (editor), \\\"window\\\",\\n// or \\\"page\\\".\\nfunction intoCoordSystem(cm, lineObj, rect, context, includeWidgets) {\\n  if (!includeWidgets && lineObj.widgets) { for (var i = 0; i < lineObj.widgets.length; ++i) { if (lineObj.widgets[i].above) {\\n    var size = widgetHeight(lineObj.widgets[i])\\n    rect.top += size; rect.bottom += size\\n  } } }\\n  if (context == \\\"line\\\") { return rect }\\n  if (!context) { context = \\\"local\\\" }\\n  var yOff = heightAtLine(lineObj)\\n  if (context == \\\"local\\\") { yOff += paddingTop(cm.display) }\\n  else { yOff -= cm.display.viewOffset }\\n  if (context == \\\"page\\\" || context == \\\"window\\\") {\\n    var lOff = cm.display.lineSpace.getBoundingClientRect()\\n    yOff += lOff.top + (context == \\\"window\\\" ? 0 : pageScrollY())\\n    var xOff = lOff.left + (context == \\\"window\\\" ? 0 : pageScrollX())\\n    rect.left += xOff; rect.right += xOff\\n  }\\n  rect.top += yOff; rect.bottom += yOff\\n  return rect\\n}\\n\\n// Coverts a box from \\\"div\\\" coords to another coordinate system.\\n// Context may be \\\"window\\\", \\\"page\\\", \\\"div\\\", or \\\"local\\\"./null.\\nfunction fromCoordSystem(cm, coords, context) {\\n  if (context == \\\"div\\\") { return coords }\\n  var left = coords.left, top = coords.top\\n  // First move into \\\"page\\\" coordinate system\\n  if (context == \\\"page\\\") {\\n    left -= pageScrollX()\\n    top -= pageScrollY()\\n  } else if (context == \\\"local\\\" || !context) {\\n    var localBox = cm.display.sizer.getBoundingClientRect()\\n    left += localBox.left\\n    top += localBox.top\\n  }\\n\\n  var lineSpaceBox = cm.display.lineSpace.getBoundingClientRect()\\n  return {left: left - lineSpaceBox.left, top: top - lineSpaceBox.top}\\n}\\n\\nfunction charCoords(cm, pos, context, lineObj, bias) {\\n  if (!lineObj) { lineObj = getLine(cm.doc, pos.line) }\\n  return intoCoordSystem(cm, lineObj, measureChar(cm, lineObj, pos.ch, bias), context)\\n}\\n\\n// Returns a box for a given cursor position, which may have an\\n// 'other' property containing the position of the secondary cursor\\n// on a bidi boundary.\\nfunction cursorCoords(cm, pos, context, lineObj, preparedMeasure, varHeight) {\\n  lineObj = lineObj || getLine(cm.doc, pos.line)\\n  if (!preparedMeasure) { preparedMeasure = prepareMeasureForLine(cm, lineObj) }\\n  function get(ch, right) {\\n    var m = measureCharPrepared(cm, preparedMeasure, ch, right ? \\\"right\\\" : \\\"left\\\", varHeight)\\n    if (right) { m.left = m.right; } else { m.right = m.left }\\n    return intoCoordSystem(cm, lineObj, m, context)\\n  }\\n  function getBidi(ch, partPos) {\\n    var part = order[partPos], right = part.level % 2\\n    if (ch == bidiLeft(part) && partPos && part.level < order[partPos - 1].level) {\\n      part = order[--partPos]\\n      ch = bidiRight(part) - (part.level % 2 ? 0 : 1)\\n      right = true\\n    } else if (ch == bidiRight(part) && partPos < order.length - 1 && part.level < order[partPos + 1].level) {\\n      part = order[++partPos]\\n      ch = bidiLeft(part) - part.level % 2\\n      right = false\\n    }\\n    if (right && ch == part.to && ch > part.from) { return get(ch - 1) }\\n    return get(ch, right)\\n  }\\n  var order = getOrder(lineObj), ch = pos.ch\\n  if (!order) { return get(ch) }\\n  var partPos = getBidiPartAt(order, ch)\\n  var val = getBidi(ch, partPos)\\n  if (bidiOther != null) { val.other = getBidi(ch, bidiOther) }\\n  return val\\n}\\n\\n// Used to cheaply estimate the coordinates for a position. Used for\\n// intermediate scroll updates.\\nfunction estimateCoords(cm, pos) {\\n  var left = 0\\n  pos = clipPos(cm.doc, pos)\\n  if (!cm.options.lineWrapping) { left = charWidth(cm.display) * pos.ch }\\n  var lineObj = getLine(cm.doc, pos.line)\\n  var top = heightAtLine(lineObj) + paddingTop(cm.display)\\n  return {left: left, right: left, top: top, bottom: top + lineObj.height}\\n}\\n\\n// Positions returned by coordsChar contain some extra information.\\n// xRel is the relative x position of the input coordinates compared\\n// to the found position (so xRel > 0 means the coordinates are to\\n// the right of the character position, for example). When outside\\n// is true, that means the coordinates lie outside the line's\\n// vertical range.\\nfunction PosWithInfo(line, ch, outside, xRel) {\\n  var pos = Pos(line, ch)\\n  pos.xRel = xRel\\n  if (outside) { pos.outside = true }\\n  return pos\\n}\\n\\n// Compute the character position closest to the given coordinates.\\n// Input must be lineSpace-local (\\\"div\\\" coordinate system).\\nfunction coordsChar(cm, x, y) {\\n  var doc = cm.doc\\n  y += cm.display.viewOffset\\n  if (y < 0) { return PosWithInfo(doc.first, 0, true, -1) }\\n  var lineN = lineAtHeight(doc, y), last = doc.first + doc.size - 1\\n  if (lineN > last)\\n    { return PosWithInfo(doc.first + doc.size - 1, getLine(doc, last).text.length, true, 1) }\\n  if (x < 0) { x = 0 }\\n\\n  var lineObj = getLine(doc, lineN)\\n  for (;;) {\\n    var found = coordsCharInner(cm, lineObj, lineN, x, y)\\n    var merged = collapsedSpanAtEnd(lineObj)\\n    var mergedPos = merged && merged.find(0, true)\\n    if (merged && (found.ch > mergedPos.from.ch || found.ch == mergedPos.from.ch && found.xRel > 0))\\n      { lineN = lineNo(lineObj = mergedPos.to.line) }\\n    else\\n      { return found }\\n  }\\n}\\n\\nfunction coordsCharInner(cm, lineObj, lineNo, x, y) {\\n  var innerOff = y - heightAtLine(lineObj)\\n  var wrongLine = false, adjust = 2 * cm.display.wrapper.clientWidth\\n  var preparedMeasure = prepareMeasureForLine(cm, lineObj)\\n\\n  function getX(ch) {\\n    var sp = cursorCoords(cm, Pos(lineNo, ch), \\\"line\\\", lineObj, preparedMeasure)\\n    wrongLine = true\\n    if (innerOff > sp.bottom) { return sp.left - adjust }\\n    else if (innerOff < sp.top) { return sp.left + adjust }\\n    else { wrongLine = false }\\n    return sp.left\\n  }\\n\\n  var bidi = getOrder(lineObj), dist = lineObj.text.length\\n  var from = lineLeft(lineObj), to = lineRight(lineObj)\\n  var fromX = getX(from), fromOutside = wrongLine, toX = getX(to), toOutside = wrongLine\\n\\n  if (x > toX) { return PosWithInfo(lineNo, to, toOutside, 1) }\\n  // Do a binary search between these bounds.\\n  for (;;) {\\n    if (bidi ? to == from || to == moveVisually(lineObj, from, 1) : to - from <= 1) {\\n      var ch = x < fromX || x - fromX <= toX - x ? from : to\\n      var outside = ch == from ? fromOutside : toOutside\\n      var xDiff = x - (ch == from ? fromX : toX)\\n      // This is a kludge to handle the case where the coordinates\\n      // are after a line-wrapped line. We should replace it with a\\n      // more general handling of cursor positions around line\\n      // breaks. (Issue #4078)\\n      if (toOutside && !bidi && !/\\\\s/.test(lineObj.text.charAt(ch)) && xDiff > 0 &&\\n          ch < lineObj.text.length && preparedMeasure.view.measure.heights.length > 1) {\\n        var charSize = measureCharPrepared(cm, preparedMeasure, ch, \\\"right\\\")\\n        if (innerOff <= charSize.bottom && innerOff >= charSize.top && Math.abs(x - charSize.right) < xDiff) {\\n          outside = false\\n          ch++\\n          xDiff = x - charSize.right\\n        }\\n      }\\n      while (isExtendingChar(lineObj.text.charAt(ch))) { ++ch }\\n      var pos = PosWithInfo(lineNo, ch, outside, xDiff < -1 ? -1 : xDiff > 1 ? 1 : 0)\\n      return pos\\n    }\\n    var step = Math.ceil(dist / 2), middle = from + step\\n    if (bidi) {\\n      middle = from\\n      for (var i = 0; i < step; ++i) { middle = moveVisually(lineObj, middle, 1) }\\n    }\\n    var middleX = getX(middle)\\n    if (middleX > x) {to = middle; toX = middleX; if (toOutside = wrongLine) { toX += 1000; } dist = step}\\n    else {from = middle; fromX = middleX; fromOutside = wrongLine; dist -= step}\\n  }\\n}\\n\\nvar measureText\\n// Compute the default text height.\\nfunction textHeight(display) {\\n  if (display.cachedTextHeight != null) { return display.cachedTextHeight }\\n  if (measureText == null) {\\n    measureText = elt(\\\"pre\\\")\\n    // Measure a bunch of lines, for browsers that compute\\n    // fractional heights.\\n    for (var i = 0; i < 49; ++i) {\\n      measureText.appendChild(document.createTextNode(\\\"x\\\"))\\n      measureText.appendChild(elt(\\\"br\\\"))\\n    }\\n    measureText.appendChild(document.createTextNode(\\\"x\\\"))\\n  }\\n  removeChildrenAndAdd(display.measure, measureText)\\n  var height = measureText.offsetHeight / 50\\n  if (height > 3) { display.cachedTextHeight = height }\\n  removeChildren(display.measure)\\n  return height || 1\\n}\\n\\n// Compute the default character width.\\nfunction charWidth(display) {\\n  if (display.cachedCharWidth != null) { return display.cachedCharWidth }\\n  var anchor = elt(\\\"span\\\", \\\"xxxxxxxxxx\\\")\\n  var pre = elt(\\\"pre\\\", [anchor])\\n  removeChildrenAndAdd(display.measure, pre)\\n  var rect = anchor.getBoundingClientRect(), width = (rect.right - rect.left) / 10\\n  if (width > 2) { display.cachedCharWidth = width }\\n  return width || 10\\n}\\n\\n// Do a bulk-read of the DOM positions and sizes needed to draw the\\n// view, so that we don't interleave reading and writing to the DOM.\\nfunction getDimensions(cm) {\\n  var d = cm.display, left = {}, width = {}\\n  var gutterLeft = d.gutters.clientLeft\\n  for (var n = d.gutters.firstChild, i = 0; n; n = n.nextSibling, ++i) {\\n    left[cm.options.gutters[i]] = n.offsetLeft + n.clientLeft + gutterLeft\\n    width[cm.options.gutters[i]] = n.clientWidth\\n  }\\n  return {fixedPos: compensateForHScroll(d),\\n          gutterTotalWidth: d.gutters.offsetWidth,\\n          gutterLeft: left,\\n          gutterWidth: width,\\n          wrapperWidth: d.wrapper.clientWidth}\\n}\\n\\n// Computes display.scroller.scrollLeft + display.gutters.offsetWidth,\\n// but using getBoundingClientRect to get a sub-pixel-accurate\\n// result.\\nfunction compensateForHScroll(display) {\\n  return display.scroller.getBoundingClientRect().left - display.sizer.getBoundingClientRect().left\\n}\\n\\n// Returns a function that estimates the height of a line, to use as\\n// first approximation until the line becomes visible (and is thus\\n// properly measurable).\\nfunction estimateHeight(cm) {\\n  var th = textHeight(cm.display), wrapping = cm.options.lineWrapping\\n  var perLine = wrapping && Math.max(5, cm.display.scroller.clientWidth / charWidth(cm.display) - 3)\\n  return function (line) {\\n    if (lineIsHidden(cm.doc, line)) { return 0 }\\n\\n    var widgetsHeight = 0\\n    if (line.widgets) { for (var i = 0; i < line.widgets.length; i++) {\\n      if (line.widgets[i].height) { widgetsHeight += line.widgets[i].height }\\n    } }\\n\\n    if (wrapping)\\n      { return widgetsHeight + (Math.ceil(line.text.length / perLine) || 1) * th }\\n    else\\n      { return widgetsHeight + th }\\n  }\\n}\\n\\nfunction estimateLineHeights(cm) {\\n  var doc = cm.doc, est = estimateHeight(cm)\\n  doc.iter(function (line) {\\n    var estHeight = est(line)\\n    if (estHeight != line.height) { updateLineHeight(line, estHeight) }\\n  })\\n}\\n\\n// Given a mouse event, find the corresponding position. If liberal\\n// is false, it checks whether a gutter or scrollbar was clicked,\\n// and returns null if it was. forRect is used by rectangular\\n// selections, and tries to estimate a character position even for\\n// coordinates beyond the right of the text.\\nfunction posFromMouse(cm, e, liberal, forRect) {\\n  var display = cm.display\\n  if (!liberal && e_target(e).getAttribute(\\\"cm-not-content\\\") == \\\"true\\\") { return null }\\n\\n  var x, y, space = display.lineSpace.getBoundingClientRect()\\n  // Fails unpredictably on IE[67] when mouse is dragged around quickly.\\n  try { x = e.clientX - space.left; y = e.clientY - space.top }\\n  catch (e) { return null }\\n  var coords = coordsChar(cm, x, y), line\\n  if (forRect && coords.xRel == 1 && (line = getLine(cm.doc, coords.line).text).length == coords.ch) {\\n    var colDiff = countColumn(line, line.length, cm.options.tabSize) - line.length\\n    coords = Pos(coords.line, Math.max(0, Math.round((x - paddingH(cm.display).left) / charWidth(cm.display)) - colDiff))\\n  }\\n  return coords\\n}\\n\\n// Find the view element corresponding to a given line. Return null\\n// when the line isn't visible.\\nfunction findViewIndex(cm, n) {\\n  if (n >= cm.display.viewTo) { return null }\\n  n -= cm.display.viewFrom\\n  if (n < 0) { return null }\\n  var view = cm.display.view\\n  for (var i = 0; i < view.length; i++) {\\n    n -= view[i].size\\n    if (n < 0) { return i }\\n  }\\n}\\n\\nfunction updateSelection(cm) {\\n  cm.display.input.showSelection(cm.display.input.prepareSelection())\\n}\\n\\nfunction prepareSelection(cm, primary) {\\n  var doc = cm.doc, result = {}\\n  var curFragment = result.cursors = document.createDocumentFragment()\\n  var selFragment = result.selection = document.createDocumentFragment()\\n\\n  for (var i = 0; i < doc.sel.ranges.length; i++) {\\n    if (primary === false && i == doc.sel.primIndex) { continue }\\n    var range = doc.sel.ranges[i]\\n    if (range.from().line >= cm.display.viewTo || range.to().line < cm.display.viewFrom) { continue }\\n    var collapsed = range.empty()\\n    if (collapsed || cm.options.showCursorWhenSelecting)\\n      { drawSelectionCursor(cm, range.head, curFragment) }\\n    if (!collapsed)\\n      { drawSelectionRange(cm, range, selFragment) }\\n  }\\n  return result\\n}\\n\\n// Draws a cursor for the given range\\nfunction drawSelectionCursor(cm, head, output) {\\n  var pos = cursorCoords(cm, head, \\\"div\\\", null, null, !cm.options.singleCursorHeightPerLine)\\n\\n  var cursor = output.appendChild(elt(\\\"div\\\", \\\"\\\\u00a0\\\", \\\"CodeMirror-cursor\\\"))\\n  cursor.style.left = pos.left + \\\"px\\\"\\n  cursor.style.top = pos.top + \\\"px\\\"\\n  cursor.style.height = Math.max(0, pos.bottom - pos.top) * cm.options.cursorHeight + \\\"px\\\"\\n\\n  if (pos.other) {\\n    // Secondary cursor, shown when on a 'jump' in bi-directional text\\n    var otherCursor = output.appendChild(elt(\\\"div\\\", \\\"\\\\u00a0\\\", \\\"CodeMirror-cursor CodeMirror-secondarycursor\\\"))\\n    otherCursor.style.display = \\\"\\\"\\n    otherCursor.style.left = pos.other.left + \\\"px\\\"\\n    otherCursor.style.top = pos.other.top + \\\"px\\\"\\n    otherCursor.style.height = (pos.other.bottom - pos.other.top) * .85 + \\\"px\\\"\\n  }\\n}\\n\\n// Draws the given range as a highlighted selection\\nfunction drawSelectionRange(cm, range, output) {\\n  var display = cm.display, doc = cm.doc\\n  var fragment = document.createDocumentFragment()\\n  var padding = paddingH(cm.display), leftSide = padding.left\\n  var rightSide = Math.max(display.sizerWidth, displayWidth(cm) - display.sizer.offsetLeft) - padding.right\\n\\n  function add(left, top, width, bottom) {\\n    if (top < 0) { top = 0 }\\n    top = Math.round(top)\\n    bottom = Math.round(bottom)\\n    fragment.appendChild(elt(\\\"div\\\", null, \\\"CodeMirror-selected\\\", (\\\"position: absolute; left: \\\" + left + \\\"px;\\\\n                             top: \\\" + top + \\\"px; width: \\\" + (width == null ? rightSide - left : width) + \\\"px;\\\\n                             height: \\\" + (bottom - top) + \\\"px\\\")))\\n  }\\n\\n  function drawForLine(line, fromArg, toArg) {\\n    var lineObj = getLine(doc, line)\\n    var lineLen = lineObj.text.length\\n    var start, end\\n    function coords(ch, bias) {\\n      return charCoords(cm, Pos(line, ch), \\\"div\\\", lineObj, bias)\\n    }\\n\\n    iterateBidiSections(getOrder(lineObj), fromArg || 0, toArg == null ? lineLen : toArg, function (from, to, dir) {\\n      var leftPos = coords(from, \\\"left\\\"), rightPos, left, right\\n      if (from == to) {\\n        rightPos = leftPos\\n        left = right = leftPos.left\\n      } else {\\n        rightPos = coords(to - 1, \\\"right\\\")\\n        if (dir == \\\"rtl\\\") { var tmp = leftPos; leftPos = rightPos; rightPos = tmp }\\n        left = leftPos.left\\n        right = rightPos.right\\n      }\\n      if (fromArg == null && from == 0) { left = leftSide }\\n      if (rightPos.top - leftPos.top > 3) { // Different lines, draw top part\\n        add(left, leftPos.top, null, leftPos.bottom)\\n        left = leftSide\\n        if (leftPos.bottom < rightPos.top) { add(left, leftPos.bottom, null, rightPos.top) }\\n      }\\n      if (toArg == null && to == lineLen) { right = rightSide }\\n      if (!start || leftPos.top < start.top || leftPos.top == start.top && leftPos.left < start.left)\\n        { start = leftPos }\\n      if (!end || rightPos.bottom > end.bottom || rightPos.bottom == end.bottom && rightPos.right > end.right)\\n        { end = rightPos }\\n      if (left < leftSide + 1) { left = leftSide }\\n      add(left, rightPos.top, right - left, rightPos.bottom)\\n    })\\n    return {start: start, end: end}\\n  }\\n\\n  var sFrom = range.from(), sTo = range.to()\\n  if (sFrom.line == sTo.line) {\\n    drawForLine(sFrom.line, sFrom.ch, sTo.ch)\\n  } else {\\n    var fromLine = getLine(doc, sFrom.line), toLine = getLine(doc, sTo.line)\\n    var singleVLine = visualLine(fromLine) == visualLine(toLine)\\n    var leftEnd = drawForLine(sFrom.line, sFrom.ch, singleVLine ? fromLine.text.length + 1 : null).end\\n    var rightStart = drawForLine(sTo.line, singleVLine ? 0 : null, sTo.ch).start\\n    if (singleVLine) {\\n      if (leftEnd.top < rightStart.top - 2) {\\n        add(leftEnd.right, leftEnd.top, null, leftEnd.bottom)\\n        add(leftSide, rightStart.top, rightStart.left, rightStart.bottom)\\n      } else {\\n        add(leftEnd.right, leftEnd.top, rightStart.left - leftEnd.right, leftEnd.bottom)\\n      }\\n    }\\n    if (leftEnd.bottom < rightStart.top)\\n      { add(leftSide, leftEnd.bottom, null, rightStart.top) }\\n  }\\n\\n  output.appendChild(fragment)\\n}\\n\\n// Cursor-blinking\\nfunction restartBlink(cm) {\\n  if (!cm.state.focused) { return }\\n  var display = cm.display\\n  clearInterval(display.blinker)\\n  var on = true\\n  display.cursorDiv.style.visibility = \\\"\\\"\\n  if (cm.options.cursorBlinkRate > 0)\\n    { display.blinker = setInterval(function () { return display.cursorDiv.style.visibility = (on = !on) ? \\\"\\\" : \\\"hidden\\\"; },\\n      cm.options.cursorBlinkRate) }\\n  else if (cm.options.cursorBlinkRate < 0)\\n    { display.cursorDiv.style.visibility = \\\"hidden\\\" }\\n}\\n\\nfunction ensureFocus(cm) {\\n  if (!cm.state.focused) { cm.display.input.focus(); onFocus(cm) }\\n}\\n\\nfunction delayBlurEvent(cm) {\\n  cm.state.delayingBlurEvent = true\\n  setTimeout(function () { if (cm.state.delayingBlurEvent) {\\n    cm.state.delayingBlurEvent = false\\n    onBlur(cm)\\n  } }, 100)\\n}\\n\\nfunction onFocus(cm, e) {\\n  if (cm.state.delayingBlurEvent) { cm.state.delayingBlurEvent = false }\\n\\n  if (cm.options.readOnly == \\\"nocursor\\\") { return }\\n  if (!cm.state.focused) {\\n    signal(cm, \\\"focus\\\", cm, e)\\n    cm.state.focused = true\\n    addClass(cm.display.wrapper, \\\"CodeMirror-focused\\\")\\n    // This test prevents this from firing when a context\\n    // menu is closed (since the input reset would kill the\\n    // select-all detection hack)\\n    if (!cm.curOp && cm.display.selForContextMenu != cm.doc.sel) {\\n      cm.display.input.reset()\\n      if (webkit) { setTimeout(function () { return cm.display.input.reset(true); }, 20) } // Issue #1730\\n    }\\n    cm.display.input.receivedFocus()\\n  }\\n  restartBlink(cm)\\n}\\nfunction onBlur(cm, e) {\\n  if (cm.state.delayingBlurEvent) { return }\\n\\n  if (cm.state.focused) {\\n    signal(cm, \\\"blur\\\", cm, e)\\n    cm.state.focused = false\\n    rmClass(cm.display.wrapper, \\\"CodeMirror-focused\\\")\\n  }\\n  clearInterval(cm.display.blinker)\\n  setTimeout(function () { if (!cm.state.focused) { cm.display.shift = false } }, 150)\\n}\\n\\n// Re-align line numbers and gutter marks to compensate for\\n// horizontal scrolling.\\nfunction alignHorizontally(cm) {\\n  var display = cm.display, view = display.view\\n  if (!display.alignWidgets && (!display.gutters.firstChild || !cm.options.fixedGutter)) { return }\\n  var comp = compensateForHScroll(display) - display.scroller.scrollLeft + cm.doc.scrollLeft\\n  var gutterW = display.gutters.offsetWidth, left = comp + \\\"px\\\"\\n  for (var i = 0; i < view.length; i++) { if (!view[i].hidden) {\\n    if (cm.options.fixedGutter) {\\n      if (view[i].gutter)\\n        { view[i].gutter.style.left = left }\\n      if (view[i].gutterBackground)\\n        { view[i].gutterBackground.style.left = left }\\n    }\\n    var align = view[i].alignable\\n    if (align) { for (var j = 0; j < align.length; j++)\\n      { align[j].style.left = left } }\\n  } }\\n  if (cm.options.fixedGutter)\\n    { display.gutters.style.left = (comp + gutterW) + \\\"px\\\" }\\n}\\n\\n// Used to ensure that the line number gutter is still the right\\n// size for the current document size. Returns true when an update\\n// is needed.\\nfunction maybeUpdateLineNumberWidth(cm) {\\n  if (!cm.options.lineNumbers) { return false }\\n  var doc = cm.doc, last = lineNumberFor(cm.options, doc.first + doc.size - 1), display = cm.display\\n  if (last.length != display.lineNumChars) {\\n    var test = display.measure.appendChild(elt(\\\"div\\\", [elt(\\\"div\\\", last)],\\n                                               \\\"CodeMirror-linenumber CodeMirror-gutter-elt\\\"))\\n    var innerW = test.firstChild.offsetWidth, padding = test.offsetWidth - innerW\\n    display.lineGutter.style.width = \\\"\\\"\\n    display.lineNumInnerWidth = Math.max(innerW, display.lineGutter.offsetWidth - padding) + 1\\n    display.lineNumWidth = display.lineNumInnerWidth + padding\\n    display.lineNumChars = display.lineNumInnerWidth ? last.length : -1\\n    display.lineGutter.style.width = display.lineNumWidth + \\\"px\\\"\\n    updateGutterSpace(cm)\\n    return true\\n  }\\n  return false\\n}\\n\\n// Read the actual heights of the rendered lines, and update their\\n// stored heights to match.\\nfunction updateHeightsInViewport(cm) {\\n  var display = cm.display\\n  var prevBottom = display.lineDiv.offsetTop\\n  for (var i = 0; i < display.view.length; i++) {\\n    var cur = display.view[i], height = (void 0)\\n    if (cur.hidden) { continue }\\n    if (ie && ie_version < 8) {\\n      var bot = cur.node.offsetTop + cur.node.offsetHeight\\n      height = bot - prevBottom\\n      prevBottom = bot\\n    } else {\\n      var box = cur.node.getBoundingClientRect()\\n      height = box.bottom - box.top\\n    }\\n    var diff = cur.line.height - height\\n    if (height < 2) { height = textHeight(display) }\\n    if (diff > .001 || diff < -.001) {\\n      updateLineHeight(cur.line, height)\\n      updateWidgetHeight(cur.line)\\n      if (cur.rest) { for (var j = 0; j < cur.rest.length; j++)\\n        { updateWidgetHeight(cur.rest[j]) } }\\n    }\\n  }\\n}\\n\\n// Read and store the height of line widgets associated with the\\n// given line.\\nfunction updateWidgetHeight(line) {\\n  if (line.widgets) { for (var i = 0; i < line.widgets.length; ++i)\\n    { line.widgets[i].height = line.widgets[i].node.parentNode.offsetHeight } }\\n}\\n\\n// Compute the lines that are visible in a given viewport (defaults\\n// the the current scroll position). viewport may contain top,\\n// height, and ensure (see op.scrollToPos) properties.\\nfunction visibleLines(display, doc, viewport) {\\n  var top = viewport && viewport.top != null ? Math.max(0, viewport.top) : display.scroller.scrollTop\\n  top = Math.floor(top - paddingTop(display))\\n  var bottom = viewport && viewport.bottom != null ? viewport.bottom : top + display.wrapper.clientHeight\\n\\n  var from = lineAtHeight(doc, top), to = lineAtHeight(doc, bottom)\\n  // Ensure is a {from: {line, ch}, to: {line, ch}} object, and\\n  // forces those lines into the viewport (if possible).\\n  if (viewport && viewport.ensure) {\\n    var ensureFrom = viewport.ensure.from.line, ensureTo = viewport.ensure.to.line\\n    if (ensureFrom < from) {\\n      from = ensureFrom\\n      to = lineAtHeight(doc, heightAtLine(getLine(doc, ensureFrom)) + display.wrapper.clientHeight)\\n    } else if (Math.min(ensureTo, doc.lastLine()) >= to) {\\n      from = lineAtHeight(doc, heightAtLine(getLine(doc, ensureTo)) - display.wrapper.clientHeight)\\n      to = ensureTo\\n    }\\n  }\\n  return {from: from, to: Math.max(to, from + 1)}\\n}\\n\\n// Sync the scrollable area and scrollbars, ensure the viewport\\n// covers the visible area.\\nfunction setScrollTop(cm, val) {\\n  if (Math.abs(cm.doc.scrollTop - val) < 2) { return }\\n  cm.doc.scrollTop = val\\n  if (!gecko) { updateDisplaySimple(cm, {top: val}) }\\n  if (cm.display.scroller.scrollTop != val) { cm.display.scroller.scrollTop = val }\\n  cm.display.scrollbars.setScrollTop(val)\\n  if (gecko) { updateDisplaySimple(cm) }\\n  startWorker(cm, 100)\\n}\\n// Sync scroller and scrollbar, ensure the gutter elements are\\n// aligned.\\nfunction setScrollLeft(cm, val, isScroller) {\\n  if (isScroller ? val == cm.doc.scrollLeft : Math.abs(cm.doc.scrollLeft - val) < 2) { return }\\n  val = Math.min(val, cm.display.scroller.scrollWidth - cm.display.scroller.clientWidth)\\n  cm.doc.scrollLeft = val\\n  alignHorizontally(cm)\\n  if (cm.display.scroller.scrollLeft != val) { cm.display.scroller.scrollLeft = val }\\n  cm.display.scrollbars.setScrollLeft(val)\\n}\\n\\n// Since the delta values reported on mouse wheel events are\\n// unstandardized between browsers and even browser versions, and\\n// generally horribly unpredictable, this code starts by measuring\\n// the scroll effect that the first few mouse wheel events have,\\n// and, from that, detects the way it can convert deltas to pixel\\n// offsets afterwards.\\n//\\n// The reason we want to know the amount a wheel event will scroll\\n// is that it gives us a chance to update the display before the\\n// actual scrolling happens, reducing flickering.\\n\\nvar wheelSamples = 0;\\nvar wheelPixelsPerUnit = null;\\n// Fill in a browser-detected starting value on browsers where we\\n// know one. These don't have to be accurate -- the result of them\\n// being wrong would just be a slight flicker on the first wheel\\n// scroll (if it is large enough).\\nif (ie) { wheelPixelsPerUnit = -.53 }\\nelse if (gecko) { wheelPixelsPerUnit = 15 }\\nelse if (chrome) { wheelPixelsPerUnit = -.7 }\\nelse if (safari) { wheelPixelsPerUnit = -1/3 }\\n\\nfunction wheelEventDelta(e) {\\n  var dx = e.wheelDeltaX, dy = e.wheelDeltaY\\n  if (dx == null && e.detail && e.axis == e.HORIZONTAL_AXIS) { dx = e.detail }\\n  if (dy == null && e.detail && e.axis == e.VERTICAL_AXIS) { dy = e.detail }\\n  else if (dy == null) { dy = e.wheelDelta }\\n  return {x: dx, y: dy}\\n}\\nfunction wheelEventPixels(e) {\\n  var delta = wheelEventDelta(e)\\n  delta.x *= wheelPixelsPerUnit\\n  delta.y *= wheelPixelsPerUnit\\n  return delta\\n}\\n\\nfunction onScrollWheel(cm, e) {\\n  var delta = wheelEventDelta(e), dx = delta.x, dy = delta.y\\n\\n  var display = cm.display, scroll = display.scroller\\n  // Quit if there's nothing to scroll here\\n  var canScrollX = scroll.scrollWidth > scroll.clientWidth\\n  var canScrollY = scroll.scrollHeight > scroll.clientHeight\\n  if (!(dx && canScrollX || dy && canScrollY)) { return }\\n\\n  // Webkit browsers on OS X abort momentum scrolls when the target\\n  // of the scroll event is removed from the scrollable element.\\n  // This hack (see related code in patchDisplay) makes sure the\\n  // element is kept around.\\n  if (dy && mac && webkit) {\\n    outer: for (var cur = e.target, view = display.view; cur != scroll; cur = cur.parentNode) {\\n      for (var i = 0; i < view.length; i++) {\\n        if (view[i].node == cur) {\\n          cm.display.currentWheelTarget = cur\\n          break outer\\n        }\\n      }\\n    }\\n  }\\n\\n  // On some browsers, horizontal scrolling will cause redraws to\\n  // happen before the gutter has been realigned, causing it to\\n  // wriggle around in a most unseemly way. When we have an\\n  // estimated pixels/delta value, we just handle horizontal\\n  // scrolling entirely here. It'll be slightly off from native, but\\n  // better than glitching out.\\n  if (dx && !gecko && !presto && wheelPixelsPerUnit != null) {\\n    if (dy && canScrollY)\\n      { setScrollTop(cm, Math.max(0, Math.min(scroll.scrollTop + dy * wheelPixelsPerUnit, scroll.scrollHeight - scroll.clientHeight))) }\\n    setScrollLeft(cm, Math.max(0, Math.min(scroll.scrollLeft + dx * wheelPixelsPerUnit, scroll.scrollWidth - scroll.clientWidth)))\\n    // Only prevent default scrolling if vertical scrolling is\\n    // actually possible. Otherwise, it causes vertical scroll\\n    // jitter on OSX trackpads when deltaX is small and deltaY\\n    // is large (issue #3579)\\n    if (!dy || (dy && canScrollY))\\n      { e_preventDefault(e) }\\n    display.wheelStartX = null // Abort measurement, if in progress\\n    return\\n  }\\n\\n  // 'Project' the visible viewport to cover the area that is being\\n  // scrolled into view (if we know enough to estimate it).\\n  if (dy && wheelPixelsPerUnit != null) {\\n    var pixels = dy * wheelPixelsPerUnit\\n    var top = cm.doc.scrollTop, bot = top + display.wrapper.clientHeight\\n    if (pixels < 0) { top = Math.max(0, top + pixels - 50) }\\n    else { bot = Math.min(cm.doc.height, bot + pixels + 50) }\\n    updateDisplaySimple(cm, {top: top, bottom: bot})\\n  }\\n\\n  if (wheelSamples < 20) {\\n    if (display.wheelStartX == null) {\\n      display.wheelStartX = scroll.scrollLeft; display.wheelStartY = scroll.scrollTop\\n      display.wheelDX = dx; display.wheelDY = dy\\n      setTimeout(function () {\\n        if (display.wheelStartX == null) { return }\\n        var movedX = scroll.scrollLeft - display.wheelStartX\\n        var movedY = scroll.scrollTop - display.wheelStartY\\n        var sample = (movedY && display.wheelDY && movedY / display.wheelDY) ||\\n          (movedX && display.wheelDX && movedX / display.wheelDX)\\n        display.wheelStartX = display.wheelStartY = null\\n        if (!sample) { return }\\n        wheelPixelsPerUnit = (wheelPixelsPerUnit * wheelSamples + sample) / (wheelSamples + 1)\\n        ++wheelSamples\\n      }, 200)\\n    } else {\\n      display.wheelDX += dx; display.wheelDY += dy\\n    }\\n  }\\n}\\n\\n// SCROLLBARS\\n\\n// Prepare DOM reads needed to update the scrollbars. Done in one\\n// shot to minimize update/measure roundtrips.\\nfunction measureForScrollbars(cm) {\\n  var d = cm.display, gutterW = d.gutters.offsetWidth\\n  var docH = Math.round(cm.doc.height + paddingVert(cm.display))\\n  return {\\n    clientHeight: d.scroller.clientHeight,\\n    viewHeight: d.wrapper.clientHeight,\\n    scrollWidth: d.scroller.scrollWidth, clientWidth: d.scroller.clientWidth,\\n    viewWidth: d.wrapper.clientWidth,\\n    barLeft: cm.options.fixedGutter ? gutterW : 0,\\n    docHeight: docH,\\n    scrollHeight: docH + scrollGap(cm) + d.barHeight,\\n    nativeBarWidth: d.nativeBarWidth,\\n    gutterWidth: gutterW\\n  }\\n}\\n\\nvar NativeScrollbars = function(place, scroll, cm) {\\n  this.cm = cm\\n  var vert = this.vert = elt(\\\"div\\\", [elt(\\\"div\\\", null, null, \\\"min-width: 1px\\\")], \\\"CodeMirror-vscrollbar\\\")\\n  var horiz = this.horiz = elt(\\\"div\\\", [elt(\\\"div\\\", null, null, \\\"height: 100%; min-height: 1px\\\")], \\\"CodeMirror-hscrollbar\\\")\\n  place(vert); place(horiz)\\n\\n  on(vert, \\\"scroll\\\", function () {\\n    if (vert.clientHeight) { scroll(vert.scrollTop, \\\"vertical\\\") }\\n  })\\n  on(horiz, \\\"scroll\\\", function () {\\n    if (horiz.clientWidth) { scroll(horiz.scrollLeft, \\\"horizontal\\\") }\\n  })\\n\\n  this.checkedZeroWidth = false\\n  // Need to set a minimum width to see the scrollbar on IE7 (but must not set it on IE8).\\n  if (ie && ie_version < 8) { this.horiz.style.minHeight = this.vert.style.minWidth = \\\"18px\\\" }\\n};\\n\\nNativeScrollbars.prototype.update = function (measure) {\\n  var needsH = measure.scrollWidth > measure.clientWidth + 1\\n  var needsV = measure.scrollHeight > measure.clientHeight + 1\\n  var sWidth = measure.nativeBarWidth\\n\\n  if (needsV) {\\n    this.vert.style.display = \\\"block\\\"\\n    this.vert.style.bottom = needsH ? sWidth + \\\"px\\\" : \\\"0\\\"\\n    var totalHeight = measure.viewHeight - (needsH ? sWidth : 0)\\n    // A bug in IE8 can cause this value to be negative, so guard it.\\n    this.vert.firstChild.style.height =\\n      Math.max(0, measure.scrollHeight - measure.clientHeight + totalHeight) + \\\"px\\\"\\n  } else {\\n    this.vert.style.display = \\\"\\\"\\n    this.vert.firstChild.style.height = \\\"0\\\"\\n  }\\n\\n  if (needsH) {\\n    this.horiz.style.display = \\\"block\\\"\\n    this.horiz.style.right = needsV ? sWidth + \\\"px\\\" : \\\"0\\\"\\n    this.horiz.style.left = measure.barLeft + \\\"px\\\"\\n    var totalWidth = measure.viewWidth - measure.barLeft - (needsV ? sWidth : 0)\\n    this.horiz.firstChild.style.width =\\n      (measure.scrollWidth - measure.clientWidth + totalWidth) + \\\"px\\\"\\n  } else {\\n    this.horiz.style.display = \\\"\\\"\\n    this.horiz.firstChild.style.width = \\\"0\\\"\\n  }\\n\\n  if (!this.checkedZeroWidth && measure.clientHeight > 0) {\\n    if (sWidth == 0) { this.zeroWidthHack() }\\n    this.checkedZeroWidth = true\\n  }\\n\\n  return {right: needsV ? sWidth : 0, bottom: needsH ? sWidth : 0}\\n};\\n\\nNativeScrollbars.prototype.setScrollLeft = function (pos) {\\n  if (this.horiz.scrollLeft != pos) { this.horiz.scrollLeft = pos }\\n  if (this.disableHoriz) { this.enableZeroWidthBar(this.horiz, this.disableHoriz) }\\n};\\n\\nNativeScrollbars.prototype.setScrollTop = function (pos) {\\n  if (this.vert.scrollTop != pos) { this.vert.scrollTop = pos }\\n  if (this.disableVert) { this.enableZeroWidthBar(this.vert, this.disableVert) }\\n};\\n\\nNativeScrollbars.prototype.zeroWidthHack = function () {\\n  var w = mac && !mac_geMountainLion ? \\\"12px\\\" : \\\"18px\\\"\\n  this.horiz.style.height = this.vert.style.width = w\\n  this.horiz.style.pointerEvents = this.vert.style.pointerEvents = \\\"none\\\"\\n  this.disableHoriz = new Delayed\\n  this.disableVert = new Delayed\\n};\\n\\nNativeScrollbars.prototype.enableZeroWidthBar = function (bar, delay) {\\n  bar.style.pointerEvents = \\\"auto\\\"\\n  function maybeDisable() {\\n    // To find out whether the scrollbar is still visible, we\\n    // check whether the element under the pixel in the bottom\\n    // left corner of the scrollbar box is the scrollbar box\\n    // itself (when the bar is still visible) or its filler child\\n    // (when the bar is hidden). If it is still visible, we keep\\n    // it enabled, if it's hidden, we disable pointer events.\\n    var box = bar.getBoundingClientRect()\\n    var elt = document.elementFromPoint(box.left + 1, box.bottom - 1)\\n    if (elt != bar) { bar.style.pointerEvents = \\\"none\\\" }\\n    else { delay.set(1000, maybeDisable) }\\n  }\\n  delay.set(1000, maybeDisable)\\n};\\n\\nNativeScrollbars.prototype.clear = function () {\\n  var parent = this.horiz.parentNode\\n  parent.removeChild(this.horiz)\\n  parent.removeChild(this.vert)\\n};\\n\\nvar NullScrollbars = function () {};\\n\\nNullScrollbars.prototype.update = function () { return {bottom: 0, right: 0} };\\nNullScrollbars.prototype.setScrollLeft = function () {};\\nNullScrollbars.prototype.setScrollTop = function () {};\\nNullScrollbars.prototype.clear = function () {};\\n\\nfunction updateScrollbars(cm, measure) {\\n  if (!measure) { measure = measureForScrollbars(cm) }\\n  var startWidth = cm.display.barWidth, startHeight = cm.display.barHeight\\n  updateScrollbarsInner(cm, measure)\\n  for (var i = 0; i < 4 && startWidth != cm.display.barWidth || startHeight != cm.display.barHeight; i++) {\\n    if (startWidth != cm.display.barWidth && cm.options.lineWrapping)\\n      { updateHeightsInViewport(cm) }\\n    updateScrollbarsInner(cm, measureForScrollbars(cm))\\n    startWidth = cm.display.barWidth; startHeight = cm.display.barHeight\\n  }\\n}\\n\\n// Re-synchronize the fake scrollbars with the actual size of the\\n// content.\\nfunction updateScrollbarsInner(cm, measure) {\\n  var d = cm.display\\n  var sizes = d.scrollbars.update(measure)\\n\\n  d.sizer.style.paddingRight = (d.barWidth = sizes.right) + \\\"px\\\"\\n  d.sizer.style.paddingBottom = (d.barHeight = sizes.bottom) + \\\"px\\\"\\n  d.heightForcer.style.borderBottom = sizes.bottom + \\\"px solid transparent\\\"\\n\\n  if (sizes.right && sizes.bottom) {\\n    d.scrollbarFiller.style.display = \\\"block\\\"\\n    d.scrollbarFiller.style.height = sizes.bottom + \\\"px\\\"\\n    d.scrollbarFiller.style.width = sizes.right + \\\"px\\\"\\n  } else { d.scrollbarFiller.style.display = \\\"\\\" }\\n  if (sizes.bottom && cm.options.coverGutterNextToScrollbar && cm.options.fixedGutter) {\\n    d.gutterFiller.style.display = \\\"block\\\"\\n    d.gutterFiller.style.height = sizes.bottom + \\\"px\\\"\\n    d.gutterFiller.style.width = measure.gutterWidth + \\\"px\\\"\\n  } else { d.gutterFiller.style.display = \\\"\\\" }\\n}\\n\\nvar scrollbarModel = {\\\"native\\\": NativeScrollbars, \\\"null\\\": NullScrollbars}\\n\\nfunction initScrollbars(cm) {\\n  if (cm.display.scrollbars) {\\n    cm.display.scrollbars.clear()\\n    if (cm.display.scrollbars.addClass)\\n      { rmClass(cm.display.wrapper, cm.display.scrollbars.addClass) }\\n  }\\n\\n  cm.display.scrollbars = new scrollbarModel[cm.options.scrollbarStyle](function (node) {\\n    cm.display.wrapper.insertBefore(node, cm.display.scrollbarFiller)\\n    // Prevent clicks in the scrollbars from killing focus\\n    on(node, \\\"mousedown\\\", function () {\\n      if (cm.state.focused) { setTimeout(function () { return cm.display.input.focus(); }, 0) }\\n    })\\n    node.setAttribute(\\\"cm-not-content\\\", \\\"true\\\")\\n  }, function (pos, axis) {\\n    if (axis == \\\"horizontal\\\") { setScrollLeft(cm, pos) }\\n    else { setScrollTop(cm, pos) }\\n  }, cm)\\n  if (cm.display.scrollbars.addClass)\\n    { addClass(cm.display.wrapper, cm.display.scrollbars.addClass) }\\n}\\n\\n// SCROLLING THINGS INTO VIEW\\n\\n// If an editor sits on the top or bottom of the window, partially\\n// scrolled out of view, this ensures that the cursor is visible.\\nfunction maybeScrollWindow(cm, coords) {\\n  if (signalDOMEvent(cm, \\\"scrollCursorIntoView\\\")) { return }\\n\\n  var display = cm.display, box = display.sizer.getBoundingClientRect(), doScroll = null\\n  if (coords.top + box.top < 0) { doScroll = true }\\n  else if (coords.bottom + box.top > (window.innerHeight || document.documentElement.clientHeight)) { doScroll = false }\\n  if (doScroll != null && !phantom) {\\n    var scrollNode = elt(\\\"div\\\", \\\"\\\\u200b\\\", null, (\\\"position: absolute;\\\\n                         top: \\\" + (coords.top - display.viewOffset - paddingTop(cm.display)) + \\\"px;\\\\n                         height: \\\" + (coords.bottom - coords.top + scrollGap(cm) + display.barHeight) + \\\"px;\\\\n                         left: \\\" + (coords.left) + \\\"px; width: 2px;\\\"))\\n    cm.display.lineSpace.appendChild(scrollNode)\\n    scrollNode.scrollIntoView(doScroll)\\n    cm.display.lineSpace.removeChild(scrollNode)\\n  }\\n}\\n\\n// Scroll a given position into view (immediately), verifying that\\n// it actually became visible (as line heights are accurately\\n// measured, the position of something may 'drift' during drawing).\\nfunction scrollPosIntoView(cm, pos, end, margin) {\\n  if (margin == null) { margin = 0 }\\n  var coords\\n  for (var limit = 0; limit < 5; limit++) {\\n    var changed = false\\n    coords = cursorCoords(cm, pos)\\n    var endCoords = !end || end == pos ? coords : cursorCoords(cm, end)\\n    var scrollPos = calculateScrollPos(cm, Math.min(coords.left, endCoords.left),\\n                                       Math.min(coords.top, endCoords.top) - margin,\\n                                       Math.max(coords.left, endCoords.left),\\n                                       Math.max(coords.bottom, endCoords.bottom) + margin)\\n    var startTop = cm.doc.scrollTop, startLeft = cm.doc.scrollLeft\\n    if (scrollPos.scrollTop != null) {\\n      setScrollTop(cm, scrollPos.scrollTop)\\n      if (Math.abs(cm.doc.scrollTop - startTop) > 1) { changed = true }\\n    }\\n    if (scrollPos.scrollLeft != null) {\\n      setScrollLeft(cm, scrollPos.scrollLeft)\\n      if (Math.abs(cm.doc.scrollLeft - startLeft) > 1) { changed = true }\\n    }\\n    if (!changed) { break }\\n  }\\n  return coords\\n}\\n\\n// Scroll a given set of coordinates into view (immediately).\\nfunction scrollIntoView(cm, x1, y1, x2, y2) {\\n  var scrollPos = calculateScrollPos(cm, x1, y1, x2, y2)\\n  if (scrollPos.scrollTop != null) { setScrollTop(cm, scrollPos.scrollTop) }\\n  if (scrollPos.scrollLeft != null) { setScrollLeft(cm, scrollPos.scrollLeft) }\\n}\\n\\n// Calculate a new scroll position needed to scroll the given\\n// rectangle into view. Returns an object with scrollTop and\\n// scrollLeft properties. When these are undefined, the\\n// vertical/horizontal position does not need to be adjusted.\\nfunction calculateScrollPos(cm, x1, y1, x2, y2) {\\n  var display = cm.display, snapMargin = textHeight(cm.display)\\n  if (y1 < 0) { y1 = 0 }\\n  var screentop = cm.curOp && cm.curOp.scrollTop != null ? cm.curOp.scrollTop : display.scroller.scrollTop\\n  var screen = displayHeight(cm), result = {}\\n  if (y2 - y1 > screen) { y2 = y1 + screen }\\n  var docBottom = cm.doc.height + paddingVert(display)\\n  var atTop = y1 < snapMargin, atBottom = y2 > docBottom - snapMargin\\n  if (y1 < screentop) {\\n    result.scrollTop = atTop ? 0 : y1\\n  } else if (y2 > screentop + screen) {\\n    var newTop = Math.min(y1, (atBottom ? docBottom : y2) - screen)\\n    if (newTop != screentop) { result.scrollTop = newTop }\\n  }\\n\\n  var screenleft = cm.curOp && cm.curOp.scrollLeft != null ? cm.curOp.scrollLeft : display.scroller.scrollLeft\\n  var screenw = displayWidth(cm) - (cm.options.fixedGutter ? display.gutters.offsetWidth : 0)\\n  var tooWide = x2 - x1 > screenw\\n  if (tooWide) { x2 = x1 + screenw }\\n  if (x1 < 10)\\n    { result.scrollLeft = 0 }\\n  else if (x1 < screenleft)\\n    { result.scrollLeft = Math.max(0, x1 - (tooWide ? 0 : 10)) }\\n  else if (x2 > screenw + screenleft - 3)\\n    { result.scrollLeft = x2 + (tooWide ? 0 : 10) - screenw }\\n  return result\\n}\\n\\n// Store a relative adjustment to the scroll position in the current\\n// operation (to be applied when the operation finishes).\\nfunction addToScrollPos(cm, left, top) {\\n  if (left != null || top != null) { resolveScrollToPos(cm) }\\n  if (left != null)\\n    { cm.curOp.scrollLeft = (cm.curOp.scrollLeft == null ? cm.doc.scrollLeft : cm.curOp.scrollLeft) + left }\\n  if (top != null)\\n    { cm.curOp.scrollTop = (cm.curOp.scrollTop == null ? cm.doc.scrollTop : cm.curOp.scrollTop) + top }\\n}\\n\\n// Make sure that at the end of the operation the current cursor is\\n// shown.\\nfunction ensureCursorVisible(cm) {\\n  resolveScrollToPos(cm)\\n  var cur = cm.getCursor(), from = cur, to = cur\\n  if (!cm.options.lineWrapping) {\\n    from = cur.ch ? Pos(cur.line, cur.ch - 1) : cur\\n    to = Pos(cur.line, cur.ch + 1)\\n  }\\n  cm.curOp.scrollToPos = {from: from, to: to, margin: cm.options.cursorScrollMargin, isCursor: true}\\n}\\n\\n// When an operation has its scrollToPos property set, and another\\n// scroll action is applied before the end of the operation, this\\n// 'simulates' scrolling that position into view in a cheap way, so\\n// that the effect of intermediate scroll commands is not ignored.\\nfunction resolveScrollToPos(cm) {\\n  var range = cm.curOp.scrollToPos\\n  if (range) {\\n    cm.curOp.scrollToPos = null\\n    var from = estimateCoords(cm, range.from), to = estimateCoords(cm, range.to)\\n    var sPos = calculateScrollPos(cm, Math.min(from.left, to.left),\\n                                  Math.min(from.top, to.top) - range.margin,\\n                                  Math.max(from.right, to.right),\\n                                  Math.max(from.bottom, to.bottom) + range.margin)\\n    cm.scrollTo(sPos.scrollLeft, sPos.scrollTop)\\n  }\\n}\\n\\n// Operations are used to wrap a series of changes to the editor\\n// state in such a way that each change won't have to update the\\n// cursor and display (which would be awkward, slow, and\\n// error-prone). Instead, display updates are batched and then all\\n// combined and executed at once.\\n\\nvar nextOpId = 0\\n// Start a new operation.\\nfunction startOperation(cm) {\\n  cm.curOp = {\\n    cm: cm,\\n    viewChanged: false,      // Flag that indicates that lines might need to be redrawn\\n    startHeight: cm.doc.height, // Used to detect need to update scrollbar\\n    forceUpdate: false,      // Used to force a redraw\\n    updateInput: null,       // Whether to reset the input textarea\\n    typing: false,           // Whether this reset should be careful to leave existing text (for compositing)\\n    changeObjs: null,        // Accumulated changes, for firing change events\\n    cursorActivityHandlers: null, // Set of handlers to fire cursorActivity on\\n    cursorActivityCalled: 0, // Tracks which cursorActivity handlers have been called already\\n    selectionChanged: false, // Whether the selection needs to be redrawn\\n    updateMaxLine: false,    // Set when the widest line needs to be determined anew\\n    scrollLeft: null, scrollTop: null, // Intermediate scroll position, not pushed to DOM yet\\n    scrollToPos: null,       // Used to scroll to a specific position\\n    focus: false,\\n    id: ++nextOpId           // Unique ID\\n  }\\n  pushOperation(cm.curOp)\\n}\\n\\n// Finish an operation, updating the display and signalling delayed events\\nfunction endOperation(cm) {\\n  var op = cm.curOp\\n  finishOperation(op, function (group) {\\n    for (var i = 0; i < group.ops.length; i++)\\n      { group.ops[i].cm.curOp = null }\\n    endOperations(group)\\n  })\\n}\\n\\n// The DOM updates done when an operation finishes are batched so\\n// that the minimum number of relayouts are required.\\nfunction endOperations(group) {\\n  var ops = group.ops\\n  for (var i = 0; i < ops.length; i++) // Read DOM\\n    { endOperation_R1(ops[i]) }\\n  for (var i$1 = 0; i$1 < ops.length; i$1++) // Write DOM (maybe)\\n    { endOperation_W1(ops[i$1]) }\\n  for (var i$2 = 0; i$2 < ops.length; i$2++) // Read DOM\\n    { endOperation_R2(ops[i$2]) }\\n  for (var i$3 = 0; i$3 < ops.length; i$3++) // Write DOM (maybe)\\n    { endOperation_W2(ops[i$3]) }\\n  for (var i$4 = 0; i$4 < ops.length; i$4++) // Read DOM\\n    { endOperation_finish(ops[i$4]) }\\n}\\n\\nfunction endOperation_R1(op) {\\n  var cm = op.cm, display = cm.display\\n  maybeClipScrollbars(cm)\\n  if (op.updateMaxLine) { findMaxLine(cm) }\\n\\n  op.mustUpdate = op.viewChanged || op.forceUpdate || op.scrollTop != null ||\\n    op.scrollToPos && (op.scrollToPos.from.line < display.viewFrom ||\\n                       op.scrollToPos.to.line >= display.viewTo) ||\\n    display.maxLineChanged && cm.options.lineWrapping\\n  op.update = op.mustUpdate &&\\n    new DisplayUpdate(cm, op.mustUpdate && {top: op.scrollTop, ensure: op.scrollToPos}, op.forceUpdate)\\n}\\n\\nfunction endOperation_W1(op) {\\n  op.updatedDisplay = op.mustUpdate && updateDisplayIfNeeded(op.cm, op.update)\\n}\\n\\nfunction endOperation_R2(op) {\\n  var cm = op.cm, display = cm.display\\n  if (op.updatedDisplay) { updateHeightsInViewport(cm) }\\n\\n  op.barMeasure = measureForScrollbars(cm)\\n\\n  // If the max line changed since it was last measured, measure it,\\n  // and ensure the document's width matches it.\\n  // updateDisplay_W2 will use these properties to do the actual resizing\\n  if (display.maxLineChanged && !cm.options.lineWrapping) {\\n    op.adjustWidthTo = measureChar(cm, display.maxLine, display.maxLine.text.length).left + 3\\n    cm.display.sizerWidth = op.adjustWidthTo\\n    op.barMeasure.scrollWidth =\\n      Math.max(display.scroller.clientWidth, display.sizer.offsetLeft + op.adjustWidthTo + scrollGap(cm) + cm.display.barWidth)\\n    op.maxScrollLeft = Math.max(0, display.sizer.offsetLeft + op.adjustWidthTo - displayWidth(cm))\\n  }\\n\\n  if (op.updatedDisplay || op.selectionChanged)\\n    { op.preparedSelection = display.input.prepareSelection(op.focus) }\\n}\\n\\nfunction endOperation_W2(op) {\\n  var cm = op.cm\\n\\n  if (op.adjustWidthTo != null) {\\n    cm.display.sizer.style.minWidth = op.adjustWidthTo + \\\"px\\\"\\n    if (op.maxScrollLeft < cm.doc.scrollLeft)\\n      { setScrollLeft(cm, Math.min(cm.display.scroller.scrollLeft, op.maxScrollLeft), true) }\\n    cm.display.maxLineChanged = false\\n  }\\n\\n  var takeFocus = op.focus && op.focus == activeElt() && (!document.hasFocus || document.hasFocus())\\n  if (op.preparedSelection)\\n    { cm.display.input.showSelection(op.preparedSelection, takeFocus) }\\n  if (op.updatedDisplay || op.startHeight != cm.doc.height)\\n    { updateScrollbars(cm, op.barMeasure) }\\n  if (op.updatedDisplay)\\n    { setDocumentHeight(cm, op.barMeasure) }\\n\\n  if (op.selectionChanged) { restartBlink(cm) }\\n\\n  if (cm.state.focused && op.updateInput)\\n    { cm.display.input.reset(op.typing) }\\n  if (takeFocus) { ensureFocus(op.cm) }\\n}\\n\\nfunction endOperation_finish(op) {\\n  var cm = op.cm, display = cm.display, doc = cm.doc\\n\\n  if (op.updatedDisplay) { postUpdateDisplay(cm, op.update) }\\n\\n  // Abort mouse wheel delta measurement, when scrolling explicitly\\n  if (display.wheelStartX != null && (op.scrollTop != null || op.scrollLeft != null || op.scrollToPos))\\n    { display.wheelStartX = display.wheelStartY = null }\\n\\n  // Propagate the scroll position to the actual DOM scroller\\n  if (op.scrollTop != null && (display.scroller.scrollTop != op.scrollTop || op.forceScroll)) {\\n    doc.scrollTop = Math.max(0, Math.min(display.scroller.scrollHeight - display.scroller.clientHeight, op.scrollTop))\\n    display.scrollbars.setScrollTop(doc.scrollTop)\\n    display.scroller.scrollTop = doc.scrollTop\\n  }\\n  if (op.scrollLeft != null && (display.scroller.scrollLeft != op.scrollLeft || op.forceScroll)) {\\n    doc.scrollLeft = Math.max(0, Math.min(display.scroller.scrollWidth - display.scroller.clientWidth, op.scrollLeft))\\n    display.scrollbars.setScrollLeft(doc.scrollLeft)\\n    display.scroller.scrollLeft = doc.scrollLeft\\n    alignHorizontally(cm)\\n  }\\n  // If we need to scroll a specific position into view, do so.\\n  if (op.scrollToPos) {\\n    var coords = scrollPosIntoView(cm, clipPos(doc, op.scrollToPos.from),\\n                                   clipPos(doc, op.scrollToPos.to), op.scrollToPos.margin)\\n    if (op.scrollToPos.isCursor && cm.state.focused) { maybeScrollWindow(cm, coords) }\\n  }\\n\\n  // Fire events for markers that are hidden/unidden by editing or\\n  // undoing\\n  var hidden = op.maybeHiddenMarkers, unhidden = op.maybeUnhiddenMarkers\\n  if (hidden) { for (var i = 0; i < hidden.length; ++i)\\n    { if (!hidden[i].lines.length) { signal(hidden[i], \\\"hide\\\") } } }\\n  if (unhidden) { for (var i$1 = 0; i$1 < unhidden.length; ++i$1)\\n    { if (unhidden[i$1].lines.length) { signal(unhidden[i$1], \\\"unhide\\\") } } }\\n\\n  if (display.wrapper.offsetHeight)\\n    { doc.scrollTop = cm.display.scroller.scrollTop }\\n\\n  // Fire change events, and delayed event handlers\\n  if (op.changeObjs)\\n    { signal(cm, \\\"changes\\\", cm, op.changeObjs) }\\n  if (op.update)\\n    { op.update.finish() }\\n}\\n\\n// Run the given function in an operation\\nfunction runInOp(cm, f) {\\n  if (cm.curOp) { return f() }\\n  startOperation(cm)\\n  try { return f() }\\n  finally { endOperation(cm) }\\n}\\n// Wraps a function in an operation. Returns the wrapped function.\\nfunction operation(cm, f) {\\n  return function() {\\n    if (cm.curOp) { return f.apply(cm, arguments) }\\n    startOperation(cm)\\n    try { return f.apply(cm, arguments) }\\n    finally { endOperation(cm) }\\n  }\\n}\\n// Used to add methods to editor and doc instances, wrapping them in\\n// operations.\\nfunction methodOp(f) {\\n  return function() {\\n    if (this.curOp) { return f.apply(this, arguments) }\\n    startOperation(this)\\n    try { return f.apply(this, arguments) }\\n    finally { endOperation(this) }\\n  }\\n}\\nfunction docMethodOp(f) {\\n  return function() {\\n    var cm = this.cm\\n    if (!cm || cm.curOp) { return f.apply(this, arguments) }\\n    startOperation(cm)\\n    try { return f.apply(this, arguments) }\\n    finally { endOperation(cm) }\\n  }\\n}\\n\\n// Updates the display.view data structure for a given change to the\\n// document. From and to are in pre-change coordinates. Lendiff is\\n// the amount of lines added or subtracted by the change. This is\\n// used for changes that span multiple lines, or change the way\\n// lines are divided into visual lines. regLineChange (below)\\n// registers single-line changes.\\nfunction regChange(cm, from, to, lendiff) {\\n  if (from == null) { from = cm.doc.first }\\n  if (to == null) { to = cm.doc.first + cm.doc.size }\\n  if (!lendiff) { lendiff = 0 }\\n\\n  var display = cm.display\\n  if (lendiff && to < display.viewTo &&\\n      (display.updateLineNumbers == null || display.updateLineNumbers > from))\\n    { display.updateLineNumbers = from }\\n\\n  cm.curOp.viewChanged = true\\n\\n  if (from >= display.viewTo) { // Change after\\n    if (sawCollapsedSpans && visualLineNo(cm.doc, from) < display.viewTo)\\n      { resetView(cm) }\\n  } else if (to <= display.viewFrom) { // Change before\\n    if (sawCollapsedSpans && visualLineEndNo(cm.doc, to + lendiff) > display.viewFrom) {\\n      resetView(cm)\\n    } else {\\n      display.viewFrom += lendiff\\n      display.viewTo += lendiff\\n    }\\n  } else if (from <= display.viewFrom && to >= display.viewTo) { // Full overlap\\n    resetView(cm)\\n  } else if (from <= display.viewFrom) { // Top overlap\\n    var cut = viewCuttingPoint(cm, to, to + lendiff, 1)\\n    if (cut) {\\n      display.view = display.view.slice(cut.index)\\n      display.viewFrom = cut.lineN\\n      display.viewTo += lendiff\\n    } else {\\n      resetView(cm)\\n    }\\n  } else if (to >= display.viewTo) { // Bottom overlap\\n    var cut$1 = viewCuttingPoint(cm, from, from, -1)\\n    if (cut$1) {\\n      display.view = display.view.slice(0, cut$1.index)\\n      display.viewTo = cut$1.lineN\\n    } else {\\n      resetView(cm)\\n    }\\n  } else { // Gap in the middle\\n    var cutTop = viewCuttingPoint(cm, from, from, -1)\\n    var cutBot = viewCuttingPoint(cm, to, to + lendiff, 1)\\n    if (cutTop && cutBot) {\\n      display.view = display.view.slice(0, cutTop.index)\\n        .concat(buildViewArray(cm, cutTop.lineN, cutBot.lineN))\\n        .concat(display.view.slice(cutBot.index))\\n      display.viewTo += lendiff\\n    } else {\\n      resetView(cm)\\n    }\\n  }\\n\\n  var ext = display.externalMeasured\\n  if (ext) {\\n    if (to < ext.lineN)\\n      { ext.lineN += lendiff }\\n    else if (from < ext.lineN + ext.size)\\n      { display.externalMeasured = null }\\n  }\\n}\\n\\n// Register a change to a single line. Type must be one of \\\"text\\\",\\n// \\\"gutter\\\", \\\"class\\\", \\\"widget\\\"\\nfunction regLineChange(cm, line, type) {\\n  cm.curOp.viewChanged = true\\n  var display = cm.display, ext = cm.display.externalMeasured\\n  if (ext && line >= ext.lineN && line < ext.lineN + ext.size)\\n    { display.externalMeasured = null }\\n\\n  if (line < display.viewFrom || line >= display.viewTo) { return }\\n  var lineView = display.view[findViewIndex(cm, line)]\\n  if (lineView.node == null) { return }\\n  var arr = lineView.changes || (lineView.changes = [])\\n  if (indexOf(arr, type) == -1) { arr.push(type) }\\n}\\n\\n// Clear the view.\\nfunction resetView(cm) {\\n  cm.display.viewFrom = cm.display.viewTo = cm.doc.first\\n  cm.display.view = []\\n  cm.display.viewOffset = 0\\n}\\n\\nfunction viewCuttingPoint(cm, oldN, newN, dir) {\\n  var index = findViewIndex(cm, oldN), diff, view = cm.display.view\\n  if (!sawCollapsedSpans || newN == cm.doc.first + cm.doc.size)\\n    { return {index: index, lineN: newN} }\\n  var n = cm.display.viewFrom\\n  for (var i = 0; i < index; i++)\\n    { n += view[i].size }\\n  if (n != oldN) {\\n    if (dir > 0) {\\n      if (index == view.length - 1) { return null }\\n      diff = (n + view[index].size) - oldN\\n      index++\\n    } else {\\n      diff = n - oldN\\n    }\\n    oldN += diff; newN += diff\\n  }\\n  while (visualLineNo(cm.doc, newN) != newN) {\\n    if (index == (dir < 0 ? 0 : view.length - 1)) { return null }\\n    newN += dir * view[index - (dir < 0 ? 1 : 0)].size\\n    index += dir\\n  }\\n  return {index: index, lineN: newN}\\n}\\n\\n// Force the view to cover a given range, adding empty view element\\n// or clipping off existing ones as needed.\\nfunction adjustView(cm, from, to) {\\n  var display = cm.display, view = display.view\\n  if (view.length == 0 || from >= display.viewTo || to <= display.viewFrom) {\\n    display.view = buildViewArray(cm, from, to)\\n    display.viewFrom = from\\n  } else {\\n    if (display.viewFrom > from)\\n      { display.view = buildViewArray(cm, from, display.viewFrom).concat(display.view) }\\n    else if (display.viewFrom < from)\\n      { display.view = display.view.slice(findViewIndex(cm, from)) }\\n    display.viewFrom = from\\n    if (display.viewTo < to)\\n      { display.view = display.view.concat(buildViewArray(cm, display.viewTo, to)) }\\n    else if (display.viewTo > to)\\n      { display.view = display.view.slice(0, findViewIndex(cm, to)) }\\n  }\\n  display.viewTo = to\\n}\\n\\n// Count the number of lines in the view whose DOM representation is\\n// out of date (or nonexistent).\\nfunction countDirtyView(cm) {\\n  var view = cm.display.view, dirty = 0\\n  for (var i = 0; i < view.length; i++) {\\n    var lineView = view[i]\\n    if (!lineView.hidden && (!lineView.node || lineView.changes)) { ++dirty }\\n  }\\n  return dirty\\n}\\n\\n// HIGHLIGHT WORKER\\n\\nfunction startWorker(cm, time) {\\n  if (cm.doc.mode.startState && cm.doc.frontier < cm.display.viewTo)\\n    { cm.state.highlight.set(time, bind(highlightWorker, cm)) }\\n}\\n\\nfunction highlightWorker(cm) {\\n  var doc = cm.doc\\n  if (doc.frontier < doc.first) { doc.frontier = doc.first }\\n  if (doc.frontier >= cm.display.viewTo) { return }\\n  var end = +new Date + cm.options.workTime\\n  var state = copyState(doc.mode, getStateBefore(cm, doc.frontier))\\n  var changedLines = []\\n\\n  doc.iter(doc.frontier, Math.min(doc.first + doc.size, cm.display.viewTo + 500), function (line) {\\n    if (doc.frontier >= cm.display.viewFrom) { // Visible\\n      var oldStyles = line.styles, tooLong = line.text.length > cm.options.maxHighlightLength\\n      var highlighted = highlightLine(cm, line, tooLong ? copyState(doc.mode, state) : state, true)\\n      line.styles = highlighted.styles\\n      var oldCls = line.styleClasses, newCls = highlighted.classes\\n      if (newCls) { line.styleClasses = newCls }\\n      else if (oldCls) { line.styleClasses = null }\\n      var ischange = !oldStyles || oldStyles.length != line.styles.length ||\\n        oldCls != newCls && (!oldCls || !newCls || oldCls.bgClass != newCls.bgClass || oldCls.textClass != newCls.textClass)\\n      for (var i = 0; !ischange && i < oldStyles.length; ++i) { ischange = oldStyles[i] != line.styles[i] }\\n      if (ischange) { changedLines.push(doc.frontier) }\\n      line.stateAfter = tooLong ? state : copyState(doc.mode, state)\\n    } else {\\n      if (line.text.length <= cm.options.maxHighlightLength)\\n        { processLine(cm, line.text, state) }\\n      line.stateAfter = doc.frontier % 5 == 0 ? copyState(doc.mode, state) : null\\n    }\\n    ++doc.frontier\\n    if (+new Date > end) {\\n      startWorker(cm, cm.options.workDelay)\\n      return true\\n    }\\n  })\\n  if (changedLines.length) { runInOp(cm, function () {\\n    for (var i = 0; i < changedLines.length; i++)\\n      { regLineChange(cm, changedLines[i], \\\"text\\\") }\\n  }) }\\n}\\n\\n// DISPLAY DRAWING\\n\\nvar DisplayUpdate = function(cm, viewport, force) {\\n  var display = cm.display\\n\\n  this.viewport = viewport\\n  // Store some values that we'll need later (but don't want to force a relayout for)\\n  this.visible = visibleLines(display, cm.doc, viewport)\\n  this.editorIsHidden = !display.wrapper.offsetWidth\\n  this.wrapperHeight = display.wrapper.clientHeight\\n  this.wrapperWidth = display.wrapper.clientWidth\\n  this.oldDisplayWidth = displayWidth(cm)\\n  this.force = force\\n  this.dims = getDimensions(cm)\\n  this.events = []\\n};\\n\\nDisplayUpdate.prototype.signal = function (emitter, type) {\\n  if (hasHandler(emitter, type))\\n    { this.events.push(arguments) }\\n};\\nDisplayUpdate.prototype.finish = function () {\\n    var this$1 = this;\\n\\n  for (var i = 0; i < this.events.length; i++)\\n    { signal.apply(null, this$1.events[i]) }\\n};\\n\\nfunction maybeClipScrollbars(cm) {\\n  var display = cm.display\\n  if (!display.scrollbarsClipped && display.scroller.offsetWidth) {\\n    display.nativeBarWidth = display.scroller.offsetWidth - display.scroller.clientWidth\\n    display.heightForcer.style.height = scrollGap(cm) + \\\"px\\\"\\n    display.sizer.style.marginBottom = -display.nativeBarWidth + \\\"px\\\"\\n    display.sizer.style.borderRightWidth = scrollGap(cm) + \\\"px\\\"\\n    display.scrollbarsClipped = true\\n  }\\n}\\n\\n// Does the actual updating of the line display. Bails out\\n// (returning false) when there is nothing to be done and forced is\\n// false.\\nfunction updateDisplayIfNeeded(cm, update) {\\n  var display = cm.display, doc = cm.doc\\n\\n  if (update.editorIsHidden) {\\n    resetView(cm)\\n    return false\\n  }\\n\\n  // Bail out if the visible area is already rendered and nothing changed.\\n  if (!update.force &&\\n      update.visible.from >= display.viewFrom && update.visible.to <= display.viewTo &&\\n      (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo) &&\\n      display.renderedView == display.view && countDirtyView(cm) == 0)\\n    { return false }\\n\\n  if (maybeUpdateLineNumberWidth(cm)) {\\n    resetView(cm)\\n    update.dims = getDimensions(cm)\\n  }\\n\\n  // Compute a suitable new viewport (from & to)\\n  var end = doc.first + doc.size\\n  var from = Math.max(update.visible.from - cm.options.viewportMargin, doc.first)\\n  var to = Math.min(end, update.visible.to + cm.options.viewportMargin)\\n  if (display.viewFrom < from && from - display.viewFrom < 20) { from = Math.max(doc.first, display.viewFrom) }\\n  if (display.viewTo > to && display.viewTo - to < 20) { to = Math.min(end, display.viewTo) }\\n  if (sawCollapsedSpans) {\\n    from = visualLineNo(cm.doc, from)\\n    to = visualLineEndNo(cm.doc, to)\\n  }\\n\\n  var different = from != display.viewFrom || to != display.viewTo ||\\n    display.lastWrapHeight != update.wrapperHeight || display.lastWrapWidth != update.wrapperWidth\\n  adjustView(cm, from, to)\\n\\n  display.viewOffset = heightAtLine(getLine(cm.doc, display.viewFrom))\\n  // Position the mover div to align with the current scroll position\\n  cm.display.mover.style.top = display.viewOffset + \\\"px\\\"\\n\\n  var toUpdate = countDirtyView(cm)\\n  if (!different && toUpdate == 0 && !update.force && display.renderedView == display.view &&\\n      (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo))\\n    { return false }\\n\\n  // For big changes, we hide the enclosing element during the\\n  // update, since that speeds up the operations on most browsers.\\n  var focused = activeElt()\\n  if (toUpdate > 4) { display.lineDiv.style.display = \\\"none\\\" }\\n  patchDisplay(cm, display.updateLineNumbers, update.dims)\\n  if (toUpdate > 4) { display.lineDiv.style.display = \\\"\\\" }\\n  display.renderedView = display.view\\n  // There might have been a widget with a focused element that got\\n  // hidden or updated, if so re-focus it.\\n  if (focused && activeElt() != focused && focused.offsetHeight) { focused.focus() }\\n\\n  // Prevent selection and cursors from interfering with the scroll\\n  // width and height.\\n  removeChildren(display.cursorDiv)\\n  removeChildren(display.selectionDiv)\\n  display.gutters.style.height = display.sizer.style.minHeight = 0\\n\\n  if (different) {\\n    display.lastWrapHeight = update.wrapperHeight\\n    display.lastWrapWidth = update.wrapperWidth\\n    startWorker(cm, 400)\\n  }\\n\\n  display.updateLineNumbers = null\\n\\n  return true\\n}\\n\\nfunction postUpdateDisplay(cm, update) {\\n  var viewport = update.viewport\\n\\n  for (var first = true;; first = false) {\\n    if (!first || !cm.options.lineWrapping || update.oldDisplayWidth == displayWidth(cm)) {\\n      // Clip forced viewport to actual scrollable area.\\n      if (viewport && viewport.top != null)\\n        { viewport = {top: Math.min(cm.doc.height + paddingVert(cm.display) - displayHeight(cm), viewport.top)} }\\n      // Updated line heights might result in the drawn area not\\n      // actually covering the viewport. Keep looping until it does.\\n      update.visible = visibleLines(cm.display, cm.doc, viewport)\\n      if (update.visible.from >= cm.display.viewFrom && update.visible.to <= cm.display.viewTo)\\n        { break }\\n    }\\n    if (!updateDisplayIfNeeded(cm, update)) { break }\\n    updateHeightsInViewport(cm)\\n    var barMeasure = measureForScrollbars(cm)\\n    updateSelection(cm)\\n    updateScrollbars(cm, barMeasure)\\n    setDocumentHeight(cm, barMeasure)\\n  }\\n\\n  update.signal(cm, \\\"update\\\", cm)\\n  if (cm.display.viewFrom != cm.display.reportedViewFrom || cm.display.viewTo != cm.display.reportedViewTo) {\\n    update.signal(cm, \\\"viewportChange\\\", cm, cm.display.viewFrom, cm.display.viewTo)\\n    cm.display.reportedViewFrom = cm.display.viewFrom; cm.display.reportedViewTo = cm.display.viewTo\\n  }\\n}\\n\\nfunction updateDisplaySimple(cm, viewport) {\\n  var update = new DisplayUpdate(cm, viewport)\\n  if (updateDisplayIfNeeded(cm, update)) {\\n    updateHeightsInViewport(cm)\\n    postUpdateDisplay(cm, update)\\n    var barMeasure = measureForScrollbars(cm)\\n    updateSelection(cm)\\n    updateScrollbars(cm, barMeasure)\\n    setDocumentHeight(cm, barMeasure)\\n    update.finish()\\n  }\\n}\\n\\n// Sync the actual display DOM structure with display.view, removing\\n// nodes for lines that are no longer in view, and creating the ones\\n// that are not there yet, and updating the ones that are out of\\n// date.\\nfunction patchDisplay(cm, updateNumbersFrom, dims) {\\n  var display = cm.display, lineNumbers = cm.options.lineNumbers\\n  var container = display.lineDiv, cur = container.firstChild\\n\\n  function rm(node) {\\n    var next = node.nextSibling\\n    // Works around a throw-scroll bug in OS X Webkit\\n    if (webkit && mac && cm.display.currentWheelTarget == node)\\n      { node.style.display = \\\"none\\\" }\\n    else\\n      { node.parentNode.removeChild(node) }\\n    return next\\n  }\\n\\n  var view = display.view, lineN = display.viewFrom\\n  // Loop over the elements in the view, syncing cur (the DOM nodes\\n  // in display.lineDiv) with the view as we go.\\n  for (var i = 0; i < view.length; i++) {\\n    var lineView = view[i]\\n    if (lineView.hidden) {\\n    } else if (!lineView.node || lineView.node.parentNode != container) { // Not drawn yet\\n      var node = buildLineElement(cm, lineView, lineN, dims)\\n      container.insertBefore(node, cur)\\n    } else { // Already drawn\\n      while (cur != lineView.node) { cur = rm(cur) }\\n      var updateNumber = lineNumbers && updateNumbersFrom != null &&\\n        updateNumbersFrom <= lineN && lineView.lineNumber\\n      if (lineView.changes) {\\n        if (indexOf(lineView.changes, \\\"gutter\\\") > -1) { updateNumber = false }\\n        updateLineForChanges(cm, lineView, lineN, dims)\\n      }\\n      if (updateNumber) {\\n        removeChildren(lineView.lineNumber)\\n        lineView.lineNumber.appendChild(document.createTextNode(lineNumberFor(cm.options, lineN)))\\n      }\\n      cur = lineView.node.nextSibling\\n    }\\n    lineN += lineView.size\\n  }\\n  while (cur) { cur = rm(cur) }\\n}\\n\\nfunction updateGutterSpace(cm) {\\n  var width = cm.display.gutters.offsetWidth\\n  cm.display.sizer.style.marginLeft = width + \\\"px\\\"\\n}\\n\\nfunction setDocumentHeight(cm, measure) {\\n  cm.display.sizer.style.minHeight = measure.docHeight + \\\"px\\\"\\n  cm.display.heightForcer.style.top = measure.docHeight + \\\"px\\\"\\n  cm.display.gutters.style.height = (measure.docHeight + cm.display.barHeight + scrollGap(cm)) + \\\"px\\\"\\n}\\n\\n// Rebuild the gutter elements, ensure the margin to the left of the\\n// code matches their width.\\nfunction updateGutters(cm) {\\n  var gutters = cm.display.gutters, specs = cm.options.gutters\\n  removeChildren(gutters)\\n  var i = 0\\n  for (; i < specs.length; ++i) {\\n    var gutterClass = specs[i]\\n    var gElt = gutters.appendChild(elt(\\\"div\\\", null, \\\"CodeMirror-gutter \\\" + gutterClass))\\n    if (gutterClass == \\\"CodeMirror-linenumbers\\\") {\\n      cm.display.lineGutter = gElt\\n      gElt.style.width = (cm.display.lineNumWidth || 1) + \\\"px\\\"\\n    }\\n  }\\n  gutters.style.display = i ? \\\"\\\" : \\\"none\\\"\\n  updateGutterSpace(cm)\\n}\\n\\n// Make sure the gutters options contains the element\\n// \\\"CodeMirror-linenumbers\\\" when the lineNumbers option is true.\\nfunction setGuttersForLineNumbers(options) {\\n  var found = indexOf(options.gutters, \\\"CodeMirror-linenumbers\\\")\\n  if (found == -1 && options.lineNumbers) {\\n    options.gutters = options.gutters.concat([\\\"CodeMirror-linenumbers\\\"])\\n  } else if (found > -1 && !options.lineNumbers) {\\n    options.gutters = options.gutters.slice(0)\\n    options.gutters.splice(found, 1)\\n  }\\n}\\n\\n// Selection objects are immutable. A new one is created every time\\n// the selection changes. A selection is one or more non-overlapping\\n// (and non-touching) ranges, sorted, and an integer that indicates\\n// which one is the primary selection (the one that's scrolled into\\n// view, that getCursor returns, etc).\\nfunction Selection(ranges, primIndex) {\\n  this.ranges = ranges\\n  this.primIndex = primIndex\\n}\\n\\nSelection.prototype = {\\n  primary: function() { return this.ranges[this.primIndex] },\\n  equals: function(other) {\\n    var this$1 = this;\\n\\n    if (other == this) { return true }\\n    if (other.primIndex != this.primIndex || other.ranges.length != this.ranges.length) { return false }\\n    for (var i = 0; i < this.ranges.length; i++) {\\n      var here = this$1.ranges[i], there = other.ranges[i]\\n      if (cmp(here.anchor, there.anchor) != 0 || cmp(here.head, there.head) != 0) { return false }\\n    }\\n    return true\\n  },\\n  deepCopy: function() {\\n    var this$1 = this;\\n\\n    var out = []\\n    for (var i = 0; i < this.ranges.length; i++)\\n      { out[i] = new Range(copyPos(this$1.ranges[i].anchor), copyPos(this$1.ranges[i].head)) }\\n    return new Selection(out, this.primIndex)\\n  },\\n  somethingSelected: function() {\\n    var this$1 = this;\\n\\n    for (var i = 0; i < this.ranges.length; i++)\\n      { if (!this$1.ranges[i].empty()) { return true } }\\n    return false\\n  },\\n  contains: function(pos, end) {\\n    var this$1 = this;\\n\\n    if (!end) { end = pos }\\n    for (var i = 0; i < this.ranges.length; i++) {\\n      var range = this$1.ranges[i]\\n      if (cmp(end, range.from()) >= 0 && cmp(pos, range.to()) <= 0)\\n        { return i }\\n    }\\n    return -1\\n  }\\n}\\n\\nfunction Range(anchor, head) {\\n  this.anchor = anchor; this.head = head\\n}\\n\\nRange.prototype = {\\n  from: function() { return minPos(this.anchor, this.head) },\\n  to: function() { return maxPos(this.anchor, this.head) },\\n  empty: function() {\\n    return this.head.line == this.anchor.line && this.head.ch == this.anchor.ch\\n  }\\n}\\n\\n// Take an unsorted, potentially overlapping set of ranges, and\\n// build a selection out of it. 'Consumes' ranges array (modifying\\n// it).\\nfunction normalizeSelection(ranges, primIndex) {\\n  var prim = ranges[primIndex]\\n  ranges.sort(function (a, b) { return cmp(a.from(), b.from()); })\\n  primIndex = indexOf(ranges, prim)\\n  for (var i = 1; i < ranges.length; i++) {\\n    var cur = ranges[i], prev = ranges[i - 1]\\n    if (cmp(prev.to(), cur.from()) >= 0) {\\n      var from = minPos(prev.from(), cur.from()), to = maxPos(prev.to(), cur.to())\\n      var inv = prev.empty() ? cur.from() == cur.head : prev.from() == prev.head\\n      if (i <= primIndex) { --primIndex }\\n      ranges.splice(--i, 2, new Range(inv ? to : from, inv ? from : to))\\n    }\\n  }\\n  return new Selection(ranges, primIndex)\\n}\\n\\nfunction simpleSelection(anchor, head) {\\n  return new Selection([new Range(anchor, head || anchor)], 0)\\n}\\n\\n// Compute the position of the end of a change (its 'to' property\\n// refers to the pre-change end).\\nfunction changeEnd(change) {\\n  if (!change.text) { return change.to }\\n  return Pos(change.from.line + change.text.length - 1,\\n             lst(change.text).length + (change.text.length == 1 ? change.from.ch : 0))\\n}\\n\\n// Adjust a position to refer to the post-change position of the\\n// same text, or the end of the change if the change covers it.\\nfunction adjustForChange(pos, change) {\\n  if (cmp(pos, change.from) < 0) { return pos }\\n  if (cmp(pos, change.to) <= 0) { return changeEnd(change) }\\n\\n  var line = pos.line + change.text.length - (change.to.line - change.from.line) - 1, ch = pos.ch\\n  if (pos.line == change.to.line) { ch += changeEnd(change).ch - change.to.ch }\\n  return Pos(line, ch)\\n}\\n\\nfunction computeSelAfterChange(doc, change) {\\n  var out = []\\n  for (var i = 0; i < doc.sel.ranges.length; i++) {\\n    var range = doc.sel.ranges[i]\\n    out.push(new Range(adjustForChange(range.anchor, change),\\n                       adjustForChange(range.head, change)))\\n  }\\n  return normalizeSelection(out, doc.sel.primIndex)\\n}\\n\\nfunction offsetPos(pos, old, nw) {\\n  if (pos.line == old.line)\\n    { return Pos(nw.line, pos.ch - old.ch + nw.ch) }\\n  else\\n    { return Pos(nw.line + (pos.line - old.line), pos.ch) }\\n}\\n\\n// Used by replaceSelections to allow moving the selection to the\\n// start or around the replaced test. Hint may be \\\"start\\\" or \\\"around\\\".\\nfunction computeReplacedSel(doc, changes, hint) {\\n  var out = []\\n  var oldPrev = Pos(doc.first, 0), newPrev = oldPrev\\n  for (var i = 0; i < changes.length; i++) {\\n    var change = changes[i]\\n    var from = offsetPos(change.from, oldPrev, newPrev)\\n    var to = offsetPos(changeEnd(change), oldPrev, newPrev)\\n    oldPrev = change.to\\n    newPrev = to\\n    if (hint == \\\"around\\\") {\\n      var range = doc.sel.ranges[i], inv = cmp(range.head, range.anchor) < 0\\n      out[i] = new Range(inv ? to : from, inv ? from : to)\\n    } else {\\n      out[i] = new Range(from, from)\\n    }\\n  }\\n  return new Selection(out, doc.sel.primIndex)\\n}\\n\\n// Used to get the editor into a consistent state again when options change.\\n\\nfunction loadMode(cm) {\\n  cm.doc.mode = getMode(cm.options, cm.doc.modeOption)\\n  resetModeState(cm)\\n}\\n\\nfunction resetModeState(cm) {\\n  cm.doc.iter(function (line) {\\n    if (line.stateAfter) { line.stateAfter = null }\\n    if (line.styles) { line.styles = null }\\n  })\\n  cm.doc.frontier = cm.doc.first\\n  startWorker(cm, 100)\\n  cm.state.modeGen++\\n  if (cm.curOp) { regChange(cm) }\\n}\\n\\n// DOCUMENT DATA STRUCTURE\\n\\n// By default, updates that start and end at the beginning of a line\\n// are treated specially, in order to make the association of line\\n// widgets and marker elements with the text behave more intuitive.\\nfunction isWholeLineUpdate(doc, change) {\\n  return change.from.ch == 0 && change.to.ch == 0 && lst(change.text) == \\\"\\\" &&\\n    (!doc.cm || doc.cm.options.wholeLineUpdateBefore)\\n}\\n\\n// Perform a change on the document data structure.\\nfunction updateDoc(doc, change, markedSpans, estimateHeight) {\\n  function spansFor(n) {return markedSpans ? markedSpans[n] : null}\\n  function update(line, text, spans) {\\n    updateLine(line, text, spans, estimateHeight)\\n    signalLater(line, \\\"change\\\", line, change)\\n  }\\n  function linesFor(start, end) {\\n    var result = []\\n    for (var i = start; i < end; ++i)\\n      { result.push(new Line(text[i], spansFor(i), estimateHeight)) }\\n    return result\\n  }\\n\\n  var from = change.from, to = change.to, text = change.text\\n  var firstLine = getLine(doc, from.line), lastLine = getLine(doc, to.line)\\n  var lastText = lst(text), lastSpans = spansFor(text.length - 1), nlines = to.line - from.line\\n\\n  // Adjust the line structure\\n  if (change.full) {\\n    doc.insert(0, linesFor(0, text.length))\\n    doc.remove(text.length, doc.size - text.length)\\n  } else if (isWholeLineUpdate(doc, change)) {\\n    // This is a whole-line replace. Treated specially to make\\n    // sure line objects move the way they are supposed to.\\n    var added = linesFor(0, text.length - 1)\\n    update(lastLine, lastLine.text, lastSpans)\\n    if (nlines) { doc.remove(from.line, nlines) }\\n    if (added.length) { doc.insert(from.line, added) }\\n  } else if (firstLine == lastLine) {\\n    if (text.length == 1) {\\n      update(firstLine, firstLine.text.slice(0, from.ch) + lastText + firstLine.text.slice(to.ch), lastSpans)\\n    } else {\\n      var added$1 = linesFor(1, text.length - 1)\\n      added$1.push(new Line(lastText + firstLine.text.slice(to.ch), lastSpans, estimateHeight))\\n      update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0))\\n      doc.insert(from.line + 1, added$1)\\n    }\\n  } else if (text.length == 1) {\\n    update(firstLine, firstLine.text.slice(0, from.ch) + text[0] + lastLine.text.slice(to.ch), spansFor(0))\\n    doc.remove(from.line + 1, nlines)\\n  } else {\\n    update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0))\\n    update(lastLine, lastText + lastLine.text.slice(to.ch), lastSpans)\\n    var added$2 = linesFor(1, text.length - 1)\\n    if (nlines > 1) { doc.remove(from.line + 1, nlines - 1) }\\n    doc.insert(from.line + 1, added$2)\\n  }\\n\\n  signalLater(doc, \\\"change\\\", doc, change)\\n}\\n\\n// Call f for all linked documents.\\nfunction linkedDocs(doc, f, sharedHistOnly) {\\n  function propagate(doc, skip, sharedHist) {\\n    if (doc.linked) { for (var i = 0; i < doc.linked.length; ++i) {\\n      var rel = doc.linked[i]\\n      if (rel.doc == skip) { continue }\\n      var shared = sharedHist && rel.sharedHist\\n      if (sharedHistOnly && !shared) { continue }\\n      f(rel.doc, shared)\\n      propagate(rel.doc, doc, shared)\\n    } }\\n  }\\n  propagate(doc, null, true)\\n}\\n\\n// Attach a document to an editor.\\nfunction attachDoc(cm, doc) {\\n  if (doc.cm) { throw new Error(\\\"This document is already in use.\\\") }\\n  cm.doc = doc\\n  doc.cm = cm\\n  estimateLineHeights(cm)\\n  loadMode(cm)\\n  if (!cm.options.lineWrapping) { findMaxLine(cm) }\\n  cm.options.mode = doc.modeOption\\n  regChange(cm)\\n}\\n\\nfunction History(startGen) {\\n  // Arrays of change events and selections. Doing something adds an\\n  // event to done and clears undo. Undoing moves events from done\\n  // to undone, redoing moves them in the other direction.\\n  this.done = []; this.undone = []\\n  this.undoDepth = Infinity\\n  // Used to track when changes can be merged into a single undo\\n  // event\\n  this.lastModTime = this.lastSelTime = 0\\n  this.lastOp = this.lastSelOp = null\\n  this.lastOrigin = this.lastSelOrigin = null\\n  // Used by the isClean() method\\n  this.generation = this.maxGeneration = startGen || 1\\n}\\n\\n// Create a history change event from an updateDoc-style change\\n// object.\\nfunction historyChangeFromChange(doc, change) {\\n  var histChange = {from: copyPos(change.from), to: changeEnd(change), text: getBetween(doc, change.from, change.to)}\\n  attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1)\\n  linkedDocs(doc, function (doc) { return attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1); }, true)\\n  return histChange\\n}\\n\\n// Pop all selection events off the end of a history array. Stop at\\n// a change event.\\nfunction clearSelectionEvents(array) {\\n  while (array.length) {\\n    var last = lst(array)\\n    if (last.ranges) { array.pop() }\\n    else { break }\\n  }\\n}\\n\\n// Find the top change event in the history. Pop off selection\\n// events that are in the way.\\nfunction lastChangeEvent(hist, force) {\\n  if (force) {\\n    clearSelectionEvents(hist.done)\\n    return lst(hist.done)\\n  } else if (hist.done.length && !lst(hist.done).ranges) {\\n    return lst(hist.done)\\n  } else if (hist.done.length > 1 && !hist.done[hist.done.length - 2].ranges) {\\n    hist.done.pop()\\n    return lst(hist.done)\\n  }\\n}\\n\\n// Register a change in the history. Merges changes that are within\\n// a single operation, or are close together with an origin that\\n// allows merging (starting with \\\"+\\\") into a single event.\\nfunction addChangeToHistory(doc, change, selAfter, opId) {\\n  var hist = doc.history\\n  hist.undone.length = 0\\n  var time = +new Date, cur\\n  var last\\n\\n  if ((hist.lastOp == opId ||\\n       hist.lastOrigin == change.origin && change.origin &&\\n       ((change.origin.charAt(0) == \\\"+\\\" && doc.cm && hist.lastModTime > time - doc.cm.options.historyEventDelay) ||\\n        change.origin.charAt(0) == \\\"*\\\")) &&\\n      (cur = lastChangeEvent(hist, hist.lastOp == opId))) {\\n    // Merge this change into the last event\\n    last = lst(cur.changes)\\n    if (cmp(change.from, change.to) == 0 && cmp(change.from, last.to) == 0) {\\n      // Optimized case for simple insertion -- don't want to add\\n      // new changesets for every character typed\\n      last.to = changeEnd(change)\\n    } else {\\n      // Add new sub-event\\n      cur.changes.push(historyChangeFromChange(doc, change))\\n    }\\n  } else {\\n    // Can not be merged, start a new event.\\n    var before = lst(hist.done)\\n    if (!before || !before.ranges)\\n      { pushSelectionToHistory(doc.sel, hist.done) }\\n    cur = {changes: [historyChangeFromChange(doc, change)],\\n           generation: hist.generation}\\n    hist.done.push(cur)\\n    while (hist.done.length > hist.undoDepth) {\\n      hist.done.shift()\\n      if (!hist.done[0].ranges) { hist.done.shift() }\\n    }\\n  }\\n  hist.done.push(selAfter)\\n  hist.generation = ++hist.maxGeneration\\n  hist.lastModTime = hist.lastSelTime = time\\n  hist.lastOp = hist.lastSelOp = opId\\n  hist.lastOrigin = hist.lastSelOrigin = change.origin\\n\\n  if (!last) { signal(doc, \\\"historyAdded\\\") }\\n}\\n\\nfunction selectionEventCanBeMerged(doc, origin, prev, sel) {\\n  var ch = origin.charAt(0)\\n  return ch == \\\"*\\\" ||\\n    ch == \\\"+\\\" &&\\n    prev.ranges.length == sel.ranges.length &&\\n    prev.somethingSelected() == sel.somethingSelected() &&\\n    new Date - doc.history.lastSelTime <= (doc.cm ? doc.cm.options.historyEventDelay : 500)\\n}\\n\\n// Called whenever the selection changes, sets the new selection as\\n// the pending selection in the history, and pushes the old pending\\n// selection into the 'done' array when it was significantly\\n// different (in number of selected ranges, emptiness, or time).\\nfunction addSelectionToHistory(doc, sel, opId, options) {\\n  var hist = doc.history, origin = options && options.origin\\n\\n  // A new event is started when the previous origin does not match\\n  // the current, or the origins don't allow matching. Origins\\n  // starting with * are always merged, those starting with + are\\n  // merged when similar and close together in time.\\n  if (opId == hist.lastSelOp ||\\n      (origin && hist.lastSelOrigin == origin &&\\n       (hist.lastModTime == hist.lastSelTime && hist.lastOrigin == origin ||\\n        selectionEventCanBeMerged(doc, origin, lst(hist.done), sel))))\\n    { hist.done[hist.done.length - 1] = sel }\\n  else\\n    { pushSelectionToHistory(sel, hist.done) }\\n\\n  hist.lastSelTime = +new Date\\n  hist.lastSelOrigin = origin\\n  hist.lastSelOp = opId\\n  if (options && options.clearRedo !== false)\\n    { clearSelectionEvents(hist.undone) }\\n}\\n\\nfunction pushSelectionToHistory(sel, dest) {\\n  var top = lst(dest)\\n  if (!(top && top.ranges && top.equals(sel)))\\n    { dest.push(sel) }\\n}\\n\\n// Used to store marked span information in the history.\\nfunction attachLocalSpans(doc, change, from, to) {\\n  var existing = change[\\\"spans_\\\" + doc.id], n = 0\\n  doc.iter(Math.max(doc.first, from), Math.min(doc.first + doc.size, to), function (line) {\\n    if (line.markedSpans)\\n      { (existing || (existing = change[\\\"spans_\\\" + doc.id] = {}))[n] = line.markedSpans }\\n    ++n\\n  })\\n}\\n\\n// When un/re-doing restores text containing marked spans, those\\n// that have been explicitly cleared should not be restored.\\nfunction removeClearedSpans(spans) {\\n  if (!spans) { return null }\\n  var out\\n  for (var i = 0; i < spans.length; ++i) {\\n    if (spans[i].marker.explicitlyCleared) { if (!out) { out = spans.slice(0, i) } }\\n    else if (out) { out.push(spans[i]) }\\n  }\\n  return !out ? spans : out.length ? out : null\\n}\\n\\n// Retrieve and filter the old marked spans stored in a change event.\\nfunction getOldSpans(doc, change) {\\n  var found = change[\\\"spans_\\\" + doc.id]\\n  if (!found) { return null }\\n  var nw = []\\n  for (var i = 0; i < change.text.length; ++i)\\n    { nw.push(removeClearedSpans(found[i])) }\\n  return nw\\n}\\n\\n// Used for un/re-doing changes from the history. Combines the\\n// result of computing the existing spans with the set of spans that\\n// existed in the history (so that deleting around a span and then\\n// undoing brings back the span).\\nfunction mergeOldSpans(doc, change) {\\n  var old = getOldSpans(doc, change)\\n  var stretched = stretchSpansOverChange(doc, change)\\n  if (!old) { return stretched }\\n  if (!stretched) { return old }\\n\\n  for (var i = 0; i < old.length; ++i) {\\n    var oldCur = old[i], stretchCur = stretched[i]\\n    if (oldCur && stretchCur) {\\n      spans: for (var j = 0; j < stretchCur.length; ++j) {\\n        var span = stretchCur[j]\\n        for (var k = 0; k < oldCur.length; ++k)\\n          { if (oldCur[k].marker == span.marker) { continue spans } }\\n        oldCur.push(span)\\n      }\\n    } else if (stretchCur) {\\n      old[i] = stretchCur\\n    }\\n  }\\n  return old\\n}\\n\\n// Used both to provide a JSON-safe object in .getHistory, and, when\\n// detaching a document, to split the history in two\\nfunction copyHistoryArray(events, newGroup, instantiateSel) {\\n  var copy = []\\n  for (var i = 0; i < events.length; ++i) {\\n    var event = events[i]\\n    if (event.ranges) {\\n      copy.push(instantiateSel ? Selection.prototype.deepCopy.call(event) : event)\\n      continue\\n    }\\n    var changes = event.changes, newChanges = []\\n    copy.push({changes: newChanges})\\n    for (var j = 0; j < changes.length; ++j) {\\n      var change = changes[j], m = (void 0)\\n      newChanges.push({from: change.from, to: change.to, text: change.text})\\n      if (newGroup) { for (var prop in change) { if (m = prop.match(/^spans_(\\\\d+)$/)) {\\n        if (indexOf(newGroup, Number(m[1])) > -1) {\\n          lst(newChanges)[prop] = change[prop]\\n          delete change[prop]\\n        }\\n      } } }\\n    }\\n  }\\n  return copy\\n}\\n\\n// The 'scroll' parameter given to many of these indicated whether\\n// the new cursor position should be scrolled into view after\\n// modifying the selection.\\n\\n// If shift is held or the extend flag is set, extends a range to\\n// include a given position (and optionally a second position).\\n// Otherwise, simply returns the range between the given positions.\\n// Used for cursor motion and such.\\nfunction extendRange(doc, range, head, other) {\\n  if (doc.cm && doc.cm.display.shift || doc.extend) {\\n    var anchor = range.anchor\\n    if (other) {\\n      var posBefore = cmp(head, anchor) < 0\\n      if (posBefore != (cmp(other, anchor) < 0)) {\\n        anchor = head\\n        head = other\\n      } else if (posBefore != (cmp(head, other) < 0)) {\\n        head = other\\n      }\\n    }\\n    return new Range(anchor, head)\\n  } else {\\n    return new Range(other || head, head)\\n  }\\n}\\n\\n// Extend the primary selection range, discard the rest.\\nfunction extendSelection(doc, head, other, options) {\\n  setSelection(doc, new Selection([extendRange(doc, doc.sel.primary(), head, other)], 0), options)\\n}\\n\\n// Extend all selections (pos is an array of selections with length\\n// equal the number of selections)\\nfunction extendSelections(doc, heads, options) {\\n  var out = []\\n  for (var i = 0; i < doc.sel.ranges.length; i++)\\n    { out[i] = extendRange(doc, doc.sel.ranges[i], heads[i], null) }\\n  var newSel = normalizeSelection(out, doc.sel.primIndex)\\n  setSelection(doc, newSel, options)\\n}\\n\\n// Updates a single range in the selection.\\nfunction replaceOneSelection(doc, i, range, options) {\\n  var ranges = doc.sel.ranges.slice(0)\\n  ranges[i] = range\\n  setSelection(doc, normalizeSelection(ranges, doc.sel.primIndex), options)\\n}\\n\\n// Reset the selection to a single range.\\nfunction setSimpleSelection(doc, anchor, head, options) {\\n  setSelection(doc, simpleSelection(anchor, head), options)\\n}\\n\\n// Give beforeSelectionChange handlers a change to influence a\\n// selection update.\\nfunction filterSelectionChange(doc, sel, options) {\\n  var obj = {\\n    ranges: sel.ranges,\\n    update: function(ranges) {\\n      var this$1 = this;\\n\\n      this.ranges = []\\n      for (var i = 0; i < ranges.length; i++)\\n        { this$1.ranges[i] = new Range(clipPos(doc, ranges[i].anchor),\\n                                   clipPos(doc, ranges[i].head)) }\\n    },\\n    origin: options && options.origin\\n  }\\n  signal(doc, \\\"beforeSelectionChange\\\", doc, obj)\\n  if (doc.cm) { signal(doc.cm, \\\"beforeSelectionChange\\\", doc.cm, obj) }\\n  if (obj.ranges != sel.ranges) { return normalizeSelection(obj.ranges, obj.ranges.length - 1) }\\n  else { return sel }\\n}\\n\\nfunction setSelectionReplaceHistory(doc, sel, options) {\\n  var done = doc.history.done, last = lst(done)\\n  if (last && last.ranges) {\\n    done[done.length - 1] = sel\\n    setSelectionNoUndo(doc, sel, options)\\n  } else {\\n    setSelection(doc, sel, options)\\n  }\\n}\\n\\n// Set a new selection.\\nfunction setSelection(doc, sel, options) {\\n  setSelectionNoUndo(doc, sel, options)\\n  addSelectionToHistory(doc, doc.sel, doc.cm ? doc.cm.curOp.id : NaN, options)\\n}\\n\\nfunction setSelectionNoUndo(doc, sel, options) {\\n  if (hasHandler(doc, \\\"beforeSelectionChange\\\") || doc.cm && hasHandler(doc.cm, \\\"beforeSelectionChange\\\"))\\n    { sel = filterSelectionChange(doc, sel, options) }\\n\\n  var bias = options && options.bias ||\\n    (cmp(sel.primary().head, doc.sel.primary().head) < 0 ? -1 : 1)\\n  setSelectionInner(doc, skipAtomicInSelection(doc, sel, bias, true))\\n\\n  if (!(options && options.scroll === false) && doc.cm)\\n    { ensureCursorVisible(doc.cm) }\\n}\\n\\nfunction setSelectionInner(doc, sel) {\\n  if (sel.equals(doc.sel)) { return }\\n\\n  doc.sel = sel\\n\\n  if (doc.cm) {\\n    doc.cm.curOp.updateInput = doc.cm.curOp.selectionChanged = true\\n    signalCursorActivity(doc.cm)\\n  }\\n  signalLater(doc, \\\"cursorActivity\\\", doc)\\n}\\n\\n// Verify that the selection does not partially select any atomic\\n// marked ranges.\\nfunction reCheckSelection(doc) {\\n  setSelectionInner(doc, skipAtomicInSelection(doc, doc.sel, null, false), sel_dontScroll)\\n}\\n\\n// Return a selection that does not partially select any atomic\\n// ranges.\\nfunction skipAtomicInSelection(doc, sel, bias, mayClear) {\\n  var out\\n  for (var i = 0; i < sel.ranges.length; i++) {\\n    var range = sel.ranges[i]\\n    var old = sel.ranges.length == doc.sel.ranges.length && doc.sel.ranges[i]\\n    var newAnchor = skipAtomic(doc, range.anchor, old && old.anchor, bias, mayClear)\\n    var newHead = skipAtomic(doc, range.head, old && old.head, bias, mayClear)\\n    if (out || newAnchor != range.anchor || newHead != range.head) {\\n      if (!out) { out = sel.ranges.slice(0, i) }\\n      out[i] = new Range(newAnchor, newHead)\\n    }\\n  }\\n  return out ? normalizeSelection(out, sel.primIndex) : sel\\n}\\n\\nfunction skipAtomicInner(doc, pos, oldPos, dir, mayClear) {\\n  var line = getLine(doc, pos.line)\\n  if (line.markedSpans) { for (var i = 0; i < line.markedSpans.length; ++i) {\\n    var sp = line.markedSpans[i], m = sp.marker\\n    if ((sp.from == null || (m.inclusiveLeft ? sp.from <= pos.ch : sp.from < pos.ch)) &&\\n        (sp.to == null || (m.inclusiveRight ? sp.to >= pos.ch : sp.to > pos.ch))) {\\n      if (mayClear) {\\n        signal(m, \\\"beforeCursorEnter\\\")\\n        if (m.explicitlyCleared) {\\n          if (!line.markedSpans) { break }\\n          else {--i; continue}\\n        }\\n      }\\n      if (!m.atomic) { continue }\\n\\n      if (oldPos) {\\n        var near = m.find(dir < 0 ? 1 : -1), diff = (void 0)\\n        if (dir < 0 ? m.inclusiveRight : m.inclusiveLeft)\\n          { near = movePos(doc, near, -dir, near && near.line == pos.line ? line : null) }\\n        if (near && near.line == pos.line && (diff = cmp(near, oldPos)) && (dir < 0 ? diff < 0 : diff > 0))\\n          { return skipAtomicInner(doc, near, pos, dir, mayClear) }\\n      }\\n\\n      var far = m.find(dir < 0 ? -1 : 1)\\n      if (dir < 0 ? m.inclusiveLeft : m.inclusiveRight)\\n        { far = movePos(doc, far, dir, far.line == pos.line ? line : null) }\\n      return far ? skipAtomicInner(doc, far, pos, dir, mayClear) : null\\n    }\\n  } }\\n  return pos\\n}\\n\\n// Ensure a given position is not inside an atomic range.\\nfunction skipAtomic(doc, pos, oldPos, bias, mayClear) {\\n  var dir = bias || 1\\n  var found = skipAtomicInner(doc, pos, oldPos, dir, mayClear) ||\\n      (!mayClear && skipAtomicInner(doc, pos, oldPos, dir, true)) ||\\n      skipAtomicInner(doc, pos, oldPos, -dir, mayClear) ||\\n      (!mayClear && skipAtomicInner(doc, pos, oldPos, -dir, true))\\n  if (!found) {\\n    doc.cantEdit = true\\n    return Pos(doc.first, 0)\\n  }\\n  return found\\n}\\n\\nfunction movePos(doc, pos, dir, line) {\\n  if (dir < 0 && pos.ch == 0) {\\n    if (pos.line > doc.first) { return clipPos(doc, Pos(pos.line - 1)) }\\n    else { return null }\\n  } else if (dir > 0 && pos.ch == (line || getLine(doc, pos.line)).text.length) {\\n    if (pos.line < doc.first + doc.size - 1) { return Pos(pos.line + 1, 0) }\\n    else { return null }\\n  } else {\\n    return new Pos(pos.line, pos.ch + dir)\\n  }\\n}\\n\\nfunction selectAll(cm) {\\n  cm.setSelection(Pos(cm.firstLine(), 0), Pos(cm.lastLine()), sel_dontScroll)\\n}\\n\\n// UPDATING\\n\\n// Allow \\\"beforeChange\\\" event handlers to influence a change\\nfunction filterChange(doc, change, update) {\\n  var obj = {\\n    canceled: false,\\n    from: change.from,\\n    to: change.to,\\n    text: change.text,\\n    origin: change.origin,\\n    cancel: function () { return obj.canceled = true; }\\n  }\\n  if (update) { obj.update = function (from, to, text, origin) {\\n    if (from) { obj.from = clipPos(doc, from) }\\n    if (to) { obj.to = clipPos(doc, to) }\\n    if (text) { obj.text = text }\\n    if (origin !== undefined) { obj.origin = origin }\\n  } }\\n  signal(doc, \\\"beforeChange\\\", doc, obj)\\n  if (doc.cm) { signal(doc.cm, \\\"beforeChange\\\", doc.cm, obj) }\\n\\n  if (obj.canceled) { return null }\\n  return {from: obj.from, to: obj.to, text: obj.text, origin: obj.origin}\\n}\\n\\n// Apply a change to a document, and add it to the document's\\n// history, and propagating it to all linked documents.\\nfunction makeChange(doc, change, ignoreReadOnly) {\\n  if (doc.cm) {\\n    if (!doc.cm.curOp) { return operation(doc.cm, makeChange)(doc, change, ignoreReadOnly) }\\n    if (doc.cm.state.suppressEdits) { return }\\n  }\\n\\n  if (hasHandler(doc, \\\"beforeChange\\\") || doc.cm && hasHandler(doc.cm, \\\"beforeChange\\\")) {\\n    change = filterChange(doc, change, true)\\n    if (!change) { return }\\n  }\\n\\n  // Possibly split or suppress the update based on the presence\\n  // of read-only spans in its range.\\n  var split = sawReadOnlySpans && !ignoreReadOnly && removeReadOnlyRanges(doc, change.from, change.to)\\n  if (split) {\\n    for (var i = split.length - 1; i >= 0; --i)\\n      { makeChangeInner(doc, {from: split[i].from, to: split[i].to, text: i ? [\\\"\\\"] : change.text}) }\\n  } else {\\n    makeChangeInner(doc, change)\\n  }\\n}\\n\\nfunction makeChangeInner(doc, change) {\\n  if (change.text.length == 1 && change.text[0] == \\\"\\\" && cmp(change.from, change.to) == 0) { return }\\n  var selAfter = computeSelAfterChange(doc, change)\\n  addChangeToHistory(doc, change, selAfter, doc.cm ? doc.cm.curOp.id : NaN)\\n\\n  makeChangeSingleDoc(doc, change, selAfter, stretchSpansOverChange(doc, change))\\n  var rebased = []\\n\\n  linkedDocs(doc, function (doc, sharedHist) {\\n    if (!sharedHist && indexOf(rebased, doc.history) == -1) {\\n      rebaseHist(doc.history, change)\\n      rebased.push(doc.history)\\n    }\\n    makeChangeSingleDoc(doc, change, null, stretchSpansOverChange(doc, change))\\n  })\\n}\\n\\n// Revert a change stored in a document's history.\\nfunction makeChangeFromHistory(doc, type, allowSelectionOnly) {\\n  if (doc.cm && doc.cm.state.suppressEdits && !allowSelectionOnly) { return }\\n\\n  var hist = doc.history, event, selAfter = doc.sel\\n  var source = type == \\\"undo\\\" ? hist.done : hist.undone, dest = type == \\\"undo\\\" ? hist.undone : hist.done\\n\\n  // Verify that there is a useable event (so that ctrl-z won't\\n  // needlessly clear selection events)\\n  var i = 0\\n  for (; i < source.length; i++) {\\n    event = source[i]\\n    if (allowSelectionOnly ? event.ranges && !event.equals(doc.sel) : !event.ranges)\\n      { break }\\n  }\\n  if (i == source.length) { return }\\n  hist.lastOrigin = hist.lastSelOrigin = null\\n\\n  for (;;) {\\n    event = source.pop()\\n    if (event.ranges) {\\n      pushSelectionToHistory(event, dest)\\n      if (allowSelectionOnly && !event.equals(doc.sel)) {\\n        setSelection(doc, event, {clearRedo: false})\\n        return\\n      }\\n      selAfter = event\\n    }\\n    else { break }\\n  }\\n\\n  // Build up a reverse change object to add to the opposite history\\n  // stack (redo when undoing, and vice versa).\\n  var antiChanges = []\\n  pushSelectionToHistory(selAfter, dest)\\n  dest.push({changes: antiChanges, generation: hist.generation})\\n  hist.generation = event.generation || ++hist.maxGeneration\\n\\n  var filter = hasHandler(doc, \\\"beforeChange\\\") || doc.cm && hasHandler(doc.cm, \\\"beforeChange\\\")\\n\\n  var loop = function ( i ) {\\n    var change = event.changes[i]\\n    change.origin = type\\n    if (filter && !filterChange(doc, change, false)) {\\n      source.length = 0\\n      return {}\\n    }\\n\\n    antiChanges.push(historyChangeFromChange(doc, change))\\n\\n    var after = i ? computeSelAfterChange(doc, change) : lst(source)\\n    makeChangeSingleDoc(doc, change, after, mergeOldSpans(doc, change))\\n    if (!i && doc.cm) { doc.cm.scrollIntoView({from: change.from, to: changeEnd(change)}) }\\n    var rebased = []\\n\\n    // Propagate to the linked documents\\n    linkedDocs(doc, function (doc, sharedHist) {\\n      if (!sharedHist && indexOf(rebased, doc.history) == -1) {\\n        rebaseHist(doc.history, change)\\n        rebased.push(doc.history)\\n      }\\n      makeChangeSingleDoc(doc, change, null, mergeOldSpans(doc, change))\\n    })\\n  };\\n\\n  for (var i$1 = event.changes.length - 1; i$1 >= 0; --i$1) {\\n    var returned = loop( i$1 );\\n\\n    if ( returned ) return returned.v;\\n  }\\n}\\n\\n// Sub-views need their line numbers shifted when text is added\\n// above or below them in the parent document.\\nfunction shiftDoc(doc, distance) {\\n  if (distance == 0) { return }\\n  doc.first += distance\\n  doc.sel = new Selection(map(doc.sel.ranges, function (range) { return new Range(\\n    Pos(range.anchor.line + distance, range.anchor.ch),\\n    Pos(range.head.line + distance, range.head.ch)\\n  ); }), doc.sel.primIndex)\\n  if (doc.cm) {\\n    regChange(doc.cm, doc.first, doc.first - distance, distance)\\n    for (var d = doc.cm.display, l = d.viewFrom; l < d.viewTo; l++)\\n      { regLineChange(doc.cm, l, \\\"gutter\\\") }\\n  }\\n}\\n\\n// More lower-level change function, handling only a single document\\n// (not linked ones).\\nfunction makeChangeSingleDoc(doc, change, selAfter, spans) {\\n  if (doc.cm && !doc.cm.curOp)\\n    { return operation(doc.cm, makeChangeSingleDoc)(doc, change, selAfter, spans) }\\n\\n  if (change.to.line < doc.first) {\\n    shiftDoc(doc, change.text.length - 1 - (change.to.line - change.from.line))\\n    return\\n  }\\n  if (change.from.line > doc.lastLine()) { return }\\n\\n  // Clip the change to the size of this doc\\n  if (change.from.line < doc.first) {\\n    var shift = change.text.length - 1 - (doc.first - change.from.line)\\n    shiftDoc(doc, shift)\\n    change = {from: Pos(doc.first, 0), to: Pos(change.to.line + shift, change.to.ch),\\n              text: [lst(change.text)], origin: change.origin}\\n  }\\n  var last = doc.lastLine()\\n  if (change.to.line > last) {\\n    change = {from: change.from, to: Pos(last, getLine(doc, last).text.length),\\n              text: [change.text[0]], origin: change.origin}\\n  }\\n\\n  change.removed = getBetween(doc, change.from, change.to)\\n\\n  if (!selAfter) { selAfter = computeSelAfterChange(doc, change) }\\n  if (doc.cm) { makeChangeSingleDocInEditor(doc.cm, change, spans) }\\n  else { updateDoc(doc, change, spans) }\\n  setSelectionNoUndo(doc, selAfter, sel_dontScroll)\\n}\\n\\n// Handle the interaction of a change to a document with the editor\\n// that this document is part of.\\nfunction makeChangeSingleDocInEditor(cm, change, spans) {\\n  var doc = cm.doc, display = cm.display, from = change.from, to = change.to\\n\\n  var recomputeMaxLength = false, checkWidthStart = from.line\\n  if (!cm.options.lineWrapping) {\\n    checkWidthStart = lineNo(visualLine(getLine(doc, from.line)))\\n    doc.iter(checkWidthStart, to.line + 1, function (line) {\\n      if (line == display.maxLine) {\\n        recomputeMaxLength = true\\n        return true\\n      }\\n    })\\n  }\\n\\n  if (doc.sel.contains(change.from, change.to) > -1)\\n    { signalCursorActivity(cm) }\\n\\n  updateDoc(doc, change, spans, estimateHeight(cm))\\n\\n  if (!cm.options.lineWrapping) {\\n    doc.iter(checkWidthStart, from.line + change.text.length, function (line) {\\n      var len = lineLength(line)\\n      if (len > display.maxLineLength) {\\n        display.maxLine = line\\n        display.maxLineLength = len\\n        display.maxLineChanged = true\\n        recomputeMaxLength = false\\n      }\\n    })\\n    if (recomputeMaxLength) { cm.curOp.updateMaxLine = true }\\n  }\\n\\n  // Adjust frontier, schedule worker\\n  doc.frontier = Math.min(doc.frontier, from.line)\\n  startWorker(cm, 400)\\n\\n  var lendiff = change.text.length - (to.line - from.line) - 1\\n  // Remember that these lines changed, for updating the display\\n  if (change.full)\\n    { regChange(cm) }\\n  else if (from.line == to.line && change.text.length == 1 && !isWholeLineUpdate(cm.doc, change))\\n    { regLineChange(cm, from.line, \\\"text\\\") }\\n  else\\n    { regChange(cm, from.line, to.line + 1, lendiff) }\\n\\n  var changesHandler = hasHandler(cm, \\\"changes\\\"), changeHandler = hasHandler(cm, \\\"change\\\")\\n  if (changeHandler || changesHandler) {\\n    var obj = {\\n      from: from, to: to,\\n      text: change.text,\\n      removed: change.removed,\\n      origin: change.origin\\n    }\\n    if (changeHandler) { signalLater(cm, \\\"change\\\", cm, obj) }\\n    if (changesHandler) { (cm.curOp.changeObjs || (cm.curOp.changeObjs = [])).push(obj) }\\n  }\\n  cm.display.selForContextMenu = null\\n}\\n\\nfunction replaceRange(doc, code, from, to, origin) {\\n  if (!to) { to = from }\\n  if (cmp(to, from) < 0) { var tmp = to; to = from; from = tmp }\\n  if (typeof code == \\\"string\\\") { code = doc.splitLines(code) }\\n  makeChange(doc, {from: from, to: to, text: code, origin: origin})\\n}\\n\\n// Rebasing/resetting history to deal with externally-sourced changes\\n\\nfunction rebaseHistSelSingle(pos, from, to, diff) {\\n  if (to < pos.line) {\\n    pos.line += diff\\n  } else if (from < pos.line) {\\n    pos.line = from\\n    pos.ch = 0\\n  }\\n}\\n\\n// Tries to rebase an array of history events given a change in the\\n// document. If the change touches the same lines as the event, the\\n// event, and everything 'behind' it, is discarded. If the change is\\n// before the event, the event's positions are updated. Uses a\\n// copy-on-write scheme for the positions, to avoid having to\\n// reallocate them all on every rebase, but also avoid problems with\\n// shared position objects being unsafely updated.\\nfunction rebaseHistArray(array, from, to, diff) {\\n  for (var i = 0; i < array.length; ++i) {\\n    var sub = array[i], ok = true\\n    if (sub.ranges) {\\n      if (!sub.copied) { sub = array[i] = sub.deepCopy(); sub.copied = true }\\n      for (var j = 0; j < sub.ranges.length; j++) {\\n        rebaseHistSelSingle(sub.ranges[j].anchor, from, to, diff)\\n        rebaseHistSelSingle(sub.ranges[j].head, from, to, diff)\\n      }\\n      continue\\n    }\\n    for (var j$1 = 0; j$1 < sub.changes.length; ++j$1) {\\n      var cur = sub.changes[j$1]\\n      if (to < cur.from.line) {\\n        cur.from = Pos(cur.from.line + diff, cur.from.ch)\\n        cur.to = Pos(cur.to.line + diff, cur.to.ch)\\n      } else if (from <= cur.to.line) {\\n        ok = false\\n        break\\n      }\\n    }\\n    if (!ok) {\\n      array.splice(0, i + 1)\\n      i = 0\\n    }\\n  }\\n}\\n\\nfunction rebaseHist(hist, change) {\\n  var from = change.from.line, to = change.to.line, diff = change.text.length - (to - from) - 1\\n  rebaseHistArray(hist.done, from, to, diff)\\n  rebaseHistArray(hist.undone, from, to, diff)\\n}\\n\\n// Utility for applying a change to a line by handle or number,\\n// returning the number and optionally registering the line as\\n// changed.\\nfunction changeLine(doc, handle, changeType, op) {\\n  var no = handle, line = handle\\n  if (typeof handle == \\\"number\\\") { line = getLine(doc, clipLine(doc, handle)) }\\n  else { no = lineNo(handle) }\\n  if (no == null) { return null }\\n  if (op(line, no) && doc.cm) { regLineChange(doc.cm, no, changeType) }\\n  return line\\n}\\n\\n// The document is represented as a BTree consisting of leaves, with\\n// chunk of lines in them, and branches, with up to ten leaves or\\n// other branch nodes below them. The top node is always a branch\\n// node, and is the document object itself (meaning it has\\n// additional methods and properties).\\n//\\n// All nodes have parent links. The tree is used both to go from\\n// line numbers to line objects, and to go from objects to numbers.\\n// It also indexes by height, and is used to convert between height\\n// and line object, and to find the total height of the document.\\n//\\n// See also http://marijnhaverbeke.nl/blog/codemirror-line-tree.html\\n\\nfunction LeafChunk(lines) {\\n  var this$1 = this;\\n\\n  this.lines = lines\\n  this.parent = null\\n  var height = 0\\n  for (var i = 0; i < lines.length; ++i) {\\n    lines[i].parent = this$1\\n    height += lines[i].height\\n  }\\n  this.height = height\\n}\\n\\nLeafChunk.prototype = {\\n  chunkSize: function() { return this.lines.length },\\n  // Remove the n lines at offset 'at'.\\n  removeInner: function(at, n) {\\n    var this$1 = this;\\n\\n    for (var i = at, e = at + n; i < e; ++i) {\\n      var line = this$1.lines[i]\\n      this$1.height -= line.height\\n      cleanUpLine(line)\\n      signalLater(line, \\\"delete\\\")\\n    }\\n    this.lines.splice(at, n)\\n  },\\n  // Helper used to collapse a small branch into a single leaf.\\n  collapse: function(lines) {\\n    lines.push.apply(lines, this.lines)\\n  },\\n  // Insert the given array of lines at offset 'at', count them as\\n  // having the given height.\\n  insertInner: function(at, lines, height) {\\n    var this$1 = this;\\n\\n    this.height += height\\n    this.lines = this.lines.slice(0, at).concat(lines).concat(this.lines.slice(at))\\n    for (var i = 0; i < lines.length; ++i) { lines[i].parent = this$1 }\\n  },\\n  // Used to iterate over a part of the tree.\\n  iterN: function(at, n, op) {\\n    var this$1 = this;\\n\\n    for (var e = at + n; at < e; ++at)\\n      { if (op(this$1.lines[at])) { return true } }\\n  }\\n}\\n\\nfunction BranchChunk(children) {\\n  var this$1 = this;\\n\\n  this.children = children\\n  var size = 0, height = 0\\n  for (var i = 0; i < children.length; ++i) {\\n    var ch = children[i]\\n    size += ch.chunkSize(); height += ch.height\\n    ch.parent = this$1\\n  }\\n  this.size = size\\n  this.height = height\\n  this.parent = null\\n}\\n\\nBranchChunk.prototype = {\\n  chunkSize: function() { return this.size },\\n  removeInner: function(at, n) {\\n    var this$1 = this;\\n\\n    this.size -= n\\n    for (var i = 0; i < this.children.length; ++i) {\\n      var child = this$1.children[i], sz = child.chunkSize()\\n      if (at < sz) {\\n        var rm = Math.min(n, sz - at), oldHeight = child.height\\n        child.removeInner(at, rm)\\n        this$1.height -= oldHeight - child.height\\n        if (sz == rm) { this$1.children.splice(i--, 1); child.parent = null }\\n        if ((n -= rm) == 0) { break }\\n        at = 0\\n      } else { at -= sz }\\n    }\\n    // If the result is smaller than 25 lines, ensure that it is a\\n    // single leaf node.\\n    if (this.size - n < 25 &&\\n        (this.children.length > 1 || !(this.children[0] instanceof LeafChunk))) {\\n      var lines = []\\n      this.collapse(lines)\\n      this.children = [new LeafChunk(lines)]\\n      this.children[0].parent = this\\n    }\\n  },\\n  collapse: function(lines) {\\n    var this$1 = this;\\n\\n    for (var i = 0; i < this.children.length; ++i) { this$1.children[i].collapse(lines) }\\n  },\\n  insertInner: function(at, lines, height) {\\n    var this$1 = this;\\n\\n    this.size += lines.length\\n    this.height += height\\n    for (var i = 0; i < this.children.length; ++i) {\\n      var child = this$1.children[i], sz = child.chunkSize()\\n      if (at <= sz) {\\n        child.insertInner(at, lines, height)\\n        if (child.lines && child.lines.length > 50) {\\n          // To avoid memory thrashing when child.lines is huge (e.g. first view of a large file), it's never spliced.\\n          // Instead, small slices are taken. They're taken in order because sequential memory accesses are fastest.\\n          var remaining = child.lines.length % 25 + 25\\n          for (var pos = remaining; pos < child.lines.length;) {\\n            var leaf = new LeafChunk(child.lines.slice(pos, pos += 25))\\n            child.height -= leaf.height\\n            this$1.children.splice(++i, 0, leaf)\\n            leaf.parent = this$1\\n          }\\n          child.lines = child.lines.slice(0, remaining)\\n          this$1.maybeSpill()\\n        }\\n        break\\n      }\\n      at -= sz\\n    }\\n  },\\n  // When a node has grown, check whether it should be split.\\n  maybeSpill: function() {\\n    if (this.children.length <= 10) { return }\\n    var me = this\\n    do {\\n      var spilled = me.children.splice(me.children.length - 5, 5)\\n      var sibling = new BranchChunk(spilled)\\n      if (!me.parent) { // Become the parent node\\n        var copy = new BranchChunk(me.children)\\n        copy.parent = me\\n        me.children = [copy, sibling]\\n        me = copy\\n     } else {\\n        me.size -= sibling.size\\n        me.height -= sibling.height\\n        var myIndex = indexOf(me.parent.children, me)\\n        me.parent.children.splice(myIndex + 1, 0, sibling)\\n      }\\n      sibling.parent = me.parent\\n    } while (me.children.length > 10)\\n    me.parent.maybeSpill()\\n  },\\n  iterN: function(at, n, op) {\\n    var this$1 = this;\\n\\n    for (var i = 0; i < this.children.length; ++i) {\\n      var child = this$1.children[i], sz = child.chunkSize()\\n      if (at < sz) {\\n        var used = Math.min(n, sz - at)\\n        if (child.iterN(at, used, op)) { return true }\\n        if ((n -= used) == 0) { break }\\n        at = 0\\n      } else { at -= sz }\\n    }\\n  }\\n}\\n\\n// Line widgets are block elements displayed above or below a line.\\n\\nfunction LineWidget(doc, node, options) {\\n  var this$1 = this;\\n\\n  if (options) { for (var opt in options) { if (options.hasOwnProperty(opt))\\n    { this$1[opt] = options[opt] } } }\\n  this.doc = doc\\n  this.node = node\\n}\\neventMixin(LineWidget)\\n\\nfunction adjustScrollWhenAboveVisible(cm, line, diff) {\\n  if (heightAtLine(line) < ((cm.curOp && cm.curOp.scrollTop) || cm.doc.scrollTop))\\n    { addToScrollPos(cm, null, diff) }\\n}\\n\\nLineWidget.prototype.clear = function() {\\n  var this$1 = this;\\n\\n  var cm = this.doc.cm, ws = this.line.widgets, line = this.line, no = lineNo(line)\\n  if (no == null || !ws) { return }\\n  for (var i = 0; i < ws.length; ++i) { if (ws[i] == this$1) { ws.splice(i--, 1) } }\\n  if (!ws.length) { line.widgets = null }\\n  var height = widgetHeight(this)\\n  updateLineHeight(line, Math.max(0, line.height - height))\\n  if (cm) { runInOp(cm, function () {\\n    adjustScrollWhenAboveVisible(cm, line, -height)\\n    regLineChange(cm, no, \\\"widget\\\")\\n  }) }\\n}\\nLineWidget.prototype.changed = function() {\\n  var oldH = this.height, cm = this.doc.cm, line = this.line\\n  this.height = null\\n  var diff = widgetHeight(this) - oldH\\n  if (!diff) { return }\\n  updateLineHeight(line, line.height + diff)\\n  if (cm) { runInOp(cm, function () {\\n    cm.curOp.forceUpdate = true\\n    adjustScrollWhenAboveVisible(cm, line, diff)\\n  }) }\\n}\\n\\nfunction addLineWidget(doc, handle, node, options) {\\n  var widget = new LineWidget(doc, node, options)\\n  var cm = doc.cm\\n  if (cm && widget.noHScroll) { cm.display.alignWidgets = true }\\n  changeLine(doc, handle, \\\"widget\\\", function (line) {\\n    var widgets = line.widgets || (line.widgets = [])\\n    if (widget.insertAt == null) { widgets.push(widget) }\\n    else { widgets.splice(Math.min(widgets.length - 1, Math.max(0, widget.insertAt)), 0, widget) }\\n    widget.line = line\\n    if (cm && !lineIsHidden(doc, line)) {\\n      var aboveVisible = heightAtLine(line) < doc.scrollTop\\n      updateLineHeight(line, line.height + widgetHeight(widget))\\n      if (aboveVisible) { addToScrollPos(cm, null, widget.height) }\\n      cm.curOp.forceUpdate = true\\n    }\\n    return true\\n  })\\n  return widget\\n}\\n\\n// TEXTMARKERS\\n\\n// Created with markText and setBookmark methods. A TextMarker is a\\n// handle that can be used to clear or find a marked position in the\\n// document. Line objects hold arrays (markedSpans) containing\\n// {from, to, marker} object pointing to such marker objects, and\\n// indicating that such a marker is present on that line. Multiple\\n// lines may point to the same marker when it spans across lines.\\n// The spans will have null for their from/to properties when the\\n// marker continues beyond the start/end of the line. Markers have\\n// links back to the lines they currently touch.\\n\\n// Collapsed markers have unique ids, in order to be able to order\\n// them, which is needed for uniquely determining an outer marker\\n// when they overlap (they may nest, but not partially overlap).\\nvar nextMarkerId = 0\\n\\nfunction TextMarker(doc, type) {\\n  this.lines = []\\n  this.type = type\\n  this.doc = doc\\n  this.id = ++nextMarkerId\\n}\\neventMixin(TextMarker)\\n\\n// Clear the marker.\\nTextMarker.prototype.clear = function() {\\n  var this$1 = this;\\n\\n  if (this.explicitlyCleared) { return }\\n  var cm = this.doc.cm, withOp = cm && !cm.curOp\\n  if (withOp) { startOperation(cm) }\\n  if (hasHandler(this, \\\"clear\\\")) {\\n    var found = this.find()\\n    if (found) { signalLater(this, \\\"clear\\\", found.from, found.to) }\\n  }\\n  var min = null, max = null\\n  for (var i = 0; i < this.lines.length; ++i) {\\n    var line = this$1.lines[i]\\n    var span = getMarkedSpanFor(line.markedSpans, this$1)\\n    if (cm && !this$1.collapsed) { regLineChange(cm, lineNo(line), \\\"text\\\") }\\n    else if (cm) {\\n      if (span.to != null) { max = lineNo(line) }\\n      if (span.from != null) { min = lineNo(line) }\\n    }\\n    line.markedSpans = removeMarkedSpan(line.markedSpans, span)\\n    if (span.from == null && this$1.collapsed && !lineIsHidden(this$1.doc, line) && cm)\\n      { updateLineHeight(line, textHeight(cm.display)) }\\n  }\\n  if (cm && this.collapsed && !cm.options.lineWrapping) { for (var i$1 = 0; i$1 < this.lines.length; ++i$1) {\\n    var visual = visualLine(this$1.lines[i$1]), len = lineLength(visual)\\n    if (len > cm.display.maxLineLength) {\\n      cm.display.maxLine = visual\\n      cm.display.maxLineLength = len\\n      cm.display.maxLineChanged = true\\n    }\\n  } }\\n\\n  if (min != null && cm && this.collapsed) { regChange(cm, min, max + 1) }\\n  this.lines.length = 0\\n  this.explicitlyCleared = true\\n  if (this.atomic && this.doc.cantEdit) {\\n    this.doc.cantEdit = false\\n    if (cm) { reCheckSelection(cm.doc) }\\n  }\\n  if (cm) { signalLater(cm, \\\"markerCleared\\\", cm, this) }\\n  if (withOp) { endOperation(cm) }\\n  if (this.parent) { this.parent.clear() }\\n}\\n\\n// Find the position of the marker in the document. Returns a {from,\\n// to} object by default. Side can be passed to get a specific side\\n// -- 0 (both), -1 (left), or 1 (right). When lineObj is true, the\\n// Pos objects returned contain a line object, rather than a line\\n// number (used to prevent looking up the same line twice).\\nTextMarker.prototype.find = function(side, lineObj) {\\n  var this$1 = this;\\n\\n  if (side == null && this.type == \\\"bookmark\\\") { side = 1 }\\n  var from, to\\n  for (var i = 0; i < this.lines.length; ++i) {\\n    var line = this$1.lines[i]\\n    var span = getMarkedSpanFor(line.markedSpans, this$1)\\n    if (span.from != null) {\\n      from = Pos(lineObj ? line : lineNo(line), span.from)\\n      if (side == -1) { return from }\\n    }\\n    if (span.to != null) {\\n      to = Pos(lineObj ? line : lineNo(line), span.to)\\n      if (side == 1) { return to }\\n    }\\n  }\\n  return from && {from: from, to: to}\\n}\\n\\n// Signals that the marker's widget changed, and surrounding layout\\n// should be recomputed.\\nTextMarker.prototype.changed = function() {\\n  var pos = this.find(-1, true), widget = this, cm = this.doc.cm\\n  if (!pos || !cm) { return }\\n  runInOp(cm, function () {\\n    var line = pos.line, lineN = lineNo(pos.line)\\n    var view = findViewForLine(cm, lineN)\\n    if (view) {\\n      clearLineMeasurementCacheFor(view)\\n      cm.curOp.selectionChanged = cm.curOp.forceUpdate = true\\n    }\\n    cm.curOp.updateMaxLine = true\\n    if (!lineIsHidden(widget.doc, line) && widget.height != null) {\\n      var oldHeight = widget.height\\n      widget.height = null\\n      var dHeight = widgetHeight(widget) - oldHeight\\n      if (dHeight)\\n        { updateLineHeight(line, line.height + dHeight) }\\n    }\\n  })\\n}\\n\\nTextMarker.prototype.attachLine = function(line) {\\n  if (!this.lines.length && this.doc.cm) {\\n    var op = this.doc.cm.curOp\\n    if (!op.maybeHiddenMarkers || indexOf(op.maybeHiddenMarkers, this) == -1)\\n      { (op.maybeUnhiddenMarkers || (op.maybeUnhiddenMarkers = [])).push(this) }\\n  }\\n  this.lines.push(line)\\n}\\nTextMarker.prototype.detachLine = function(line) {\\n  this.lines.splice(indexOf(this.lines, line), 1)\\n  if (!this.lines.length && this.doc.cm) {\\n    var op = this.doc.cm.curOp\\n    ;(op.maybeHiddenMarkers || (op.maybeHiddenMarkers = [])).push(this)\\n  }\\n}\\n\\n// Create a marker, wire it up to the right lines, and\\nfunction markText(doc, from, to, options, type) {\\n  // Shared markers (across linked documents) are handled separately\\n  // (markTextShared will call out to this again, once per\\n  // document).\\n  if (options && options.shared) { return markTextShared(doc, from, to, options, type) }\\n  // Ensure we are in an operation.\\n  if (doc.cm && !doc.cm.curOp) { return operation(doc.cm, markText)(doc, from, to, options, type) }\\n\\n  var marker = new TextMarker(doc, type), diff = cmp(from, to)\\n  if (options) { copyObj(options, marker, false) }\\n  // Don't connect empty markers unless clearWhenEmpty is false\\n  if (diff > 0 || diff == 0 && marker.clearWhenEmpty !== false)\\n    { return marker }\\n  if (marker.replacedWith) {\\n    // Showing up as a widget implies collapsed (widget replaces text)\\n    marker.collapsed = true\\n    marker.widgetNode = elt(\\\"span\\\", [marker.replacedWith], \\\"CodeMirror-widget\\\")\\n    marker.widgetNode.setAttribute(\\\"role\\\", \\\"presentation\\\") // hide from accessibility tree\\n    if (!options.handleMouseEvents) { marker.widgetNode.setAttribute(\\\"cm-ignore-events\\\", \\\"true\\\") }\\n    if (options.insertLeft) { marker.widgetNode.insertLeft = true }\\n  }\\n  if (marker.collapsed) {\\n    if (conflictingCollapsedRange(doc, from.line, from, to, marker) ||\\n        from.line != to.line && conflictingCollapsedRange(doc, to.line, from, to, marker))\\n      { throw new Error(\\\"Inserting collapsed marker partially overlapping an existing one\\\") }\\n    seeCollapsedSpans()\\n  }\\n\\n  if (marker.addToHistory)\\n    { addChangeToHistory(doc, {from: from, to: to, origin: \\\"markText\\\"}, doc.sel, NaN) }\\n\\n  var curLine = from.line, cm = doc.cm, updateMaxLine\\n  doc.iter(curLine, to.line + 1, function (line) {\\n    if (cm && marker.collapsed && !cm.options.lineWrapping && visualLine(line) == cm.display.maxLine)\\n      { updateMaxLine = true }\\n    if (marker.collapsed && curLine != from.line) { updateLineHeight(line, 0) }\\n    addMarkedSpan(line, new MarkedSpan(marker,\\n                                       curLine == from.line ? from.ch : null,\\n                                       curLine == to.line ? to.ch : null))\\n    ++curLine\\n  })\\n  // lineIsHidden depends on the presence of the spans, so needs a second pass\\n  if (marker.collapsed) { doc.iter(from.line, to.line + 1, function (line) {\\n    if (lineIsHidden(doc, line)) { updateLineHeight(line, 0) }\\n  }) }\\n\\n  if (marker.clearOnEnter) { on(marker, \\\"beforeCursorEnter\\\", function () { return marker.clear(); }) }\\n\\n  if (marker.readOnly) {\\n    seeReadOnlySpans()\\n    if (doc.history.done.length || doc.history.undone.length)\\n      { doc.clearHistory() }\\n  }\\n  if (marker.collapsed) {\\n    marker.id = ++nextMarkerId\\n    marker.atomic = true\\n  }\\n  if (cm) {\\n    // Sync editor state\\n    if (updateMaxLine) { cm.curOp.updateMaxLine = true }\\n    if (marker.collapsed)\\n      { regChange(cm, from.line, to.line + 1) }\\n    else if (marker.className || marker.title || marker.startStyle || marker.endStyle || marker.css)\\n      { for (var i = from.line; i <= to.line; i++) { regLineChange(cm, i, \\\"text\\\") } }\\n    if (marker.atomic) { reCheckSelection(cm.doc) }\\n    signalLater(cm, \\\"markerAdded\\\", cm, marker)\\n  }\\n  return marker\\n}\\n\\n// SHARED TEXTMARKERS\\n\\n// A shared marker spans multiple linked documents. It is\\n// implemented as a meta-marker-object controlling multiple normal\\n// markers.\\nfunction SharedTextMarker(markers, primary) {\\n  var this$1 = this;\\n\\n  this.markers = markers\\n  this.primary = primary\\n  for (var i = 0; i < markers.length; ++i)\\n    { markers[i].parent = this$1 }\\n}\\neventMixin(SharedTextMarker)\\n\\nSharedTextMarker.prototype.clear = function() {\\n  var this$1 = this;\\n\\n  if (this.explicitlyCleared) { return }\\n  this.explicitlyCleared = true\\n  for (var i = 0; i < this.markers.length; ++i)\\n    { this$1.markers[i].clear() }\\n  signalLater(this, \\\"clear\\\")\\n}\\nSharedTextMarker.prototype.find = function(side, lineObj) {\\n  return this.primary.find(side, lineObj)\\n}\\n\\nfunction markTextShared(doc, from, to, options, type) {\\n  options = copyObj(options)\\n  options.shared = false\\n  var markers = [markText(doc, from, to, options, type)], primary = markers[0]\\n  var widget = options.widgetNode\\n  linkedDocs(doc, function (doc) {\\n    if (widget) { options.widgetNode = widget.cloneNode(true) }\\n    markers.push(markText(doc, clipPos(doc, from), clipPos(doc, to), options, type))\\n    for (var i = 0; i < doc.linked.length; ++i)\\n      { if (doc.linked[i].isParent) { return } }\\n    primary = lst(markers)\\n  })\\n  return new SharedTextMarker(markers, primary)\\n}\\n\\nfunction findSharedMarkers(doc) {\\n  return doc.findMarks(Pos(doc.first, 0), doc.clipPos(Pos(doc.lastLine())), function (m) { return m.parent; })\\n}\\n\\nfunction copySharedMarkers(doc, markers) {\\n  for (var i = 0; i < markers.length; i++) {\\n    var marker = markers[i], pos = marker.find()\\n    var mFrom = doc.clipPos(pos.from), mTo = doc.clipPos(pos.to)\\n    if (cmp(mFrom, mTo)) {\\n      var subMark = markText(doc, mFrom, mTo, marker.primary, marker.primary.type)\\n      marker.markers.push(subMark)\\n      subMark.parent = marker\\n    }\\n  }\\n}\\n\\nfunction detachSharedMarkers(markers) {\\n  var loop = function ( i ) {\\n    var marker = markers[i], linked = [marker.primary.doc]\\n    linkedDocs(marker.primary.doc, function (d) { return linked.push(d); })\\n    for (var j = 0; j < marker.markers.length; j++) {\\n      var subMarker = marker.markers[j]\\n      if (indexOf(linked, subMarker.doc) == -1) {\\n        subMarker.parent = null\\n        marker.markers.splice(j--, 1)\\n      }\\n    }\\n  };\\n\\n  for (var i = 0; i < markers.length; i++) loop( i );\\n}\\n\\nvar nextDocId = 0\\nvar Doc = function(text, mode, firstLine, lineSep) {\\n  if (!(this instanceof Doc)) { return new Doc(text, mode, firstLine, lineSep) }\\n  if (firstLine == null) { firstLine = 0 }\\n\\n  BranchChunk.call(this, [new LeafChunk([new Line(\\\"\\\", null)])])\\n  this.first = firstLine\\n  this.scrollTop = this.scrollLeft = 0\\n  this.cantEdit = false\\n  this.cleanGeneration = 1\\n  this.frontier = firstLine\\n  var start = Pos(firstLine, 0)\\n  this.sel = simpleSelection(start)\\n  this.history = new History(null)\\n  this.id = ++nextDocId\\n  this.modeOption = mode\\n  this.lineSep = lineSep\\n  this.extend = false\\n\\n  if (typeof text == \\\"string\\\") { text = this.splitLines(text) }\\n  updateDoc(this, {from: start, to: start, text: text})\\n  setSelection(this, simpleSelection(start), sel_dontScroll)\\n}\\n\\nDoc.prototype = createObj(BranchChunk.prototype, {\\n  constructor: Doc,\\n  // Iterate over the document. Supports two forms -- with only one\\n  // argument, it calls that for each line in the document. With\\n  // three, it iterates over the range given by the first two (with\\n  // the second being non-inclusive).\\n  iter: function(from, to, op) {\\n    if (op) { this.iterN(from - this.first, to - from, op) }\\n    else { this.iterN(this.first, this.first + this.size, from) }\\n  },\\n\\n  // Non-public interface for adding and removing lines.\\n  insert: function(at, lines) {\\n    var height = 0\\n    for (var i = 0; i < lines.length; ++i) { height += lines[i].height }\\n    this.insertInner(at - this.first, lines, height)\\n  },\\n  remove: function(at, n) { this.removeInner(at - this.first, n) },\\n\\n  // From here, the methods are part of the public interface. Most\\n  // are also available from CodeMirror (editor) instances.\\n\\n  getValue: function(lineSep) {\\n    var lines = getLines(this, this.first, this.first + this.size)\\n    if (lineSep === false) { return lines }\\n    return lines.join(lineSep || this.lineSeparator())\\n  },\\n  setValue: docMethodOp(function(code) {\\n    var top = Pos(this.first, 0), last = this.first + this.size - 1\\n    makeChange(this, {from: top, to: Pos(last, getLine(this, last).text.length),\\n                      text: this.splitLines(code), origin: \\\"setValue\\\", full: true}, true)\\n    setSelection(this, simpleSelection(top))\\n  }),\\n  replaceRange: function(code, from, to, origin) {\\n    from = clipPos(this, from)\\n    to = to ? clipPos(this, to) : from\\n    replaceRange(this, code, from, to, origin)\\n  },\\n  getRange: function(from, to, lineSep) {\\n    var lines = getBetween(this, clipPos(this, from), clipPos(this, to))\\n    if (lineSep === false) { return lines }\\n    return lines.join(lineSep || this.lineSeparator())\\n  },\\n\\n  getLine: function(line) {var l = this.getLineHandle(line); return l && l.text},\\n\\n  getLineHandle: function(line) {if (isLine(this, line)) { return getLine(this, line) }},\\n  getLineNumber: function(line) {return lineNo(line)},\\n\\n  getLineHandleVisualStart: function(line) {\\n    if (typeof line == \\\"number\\\") { line = getLine(this, line) }\\n    return visualLine(line)\\n  },\\n\\n  lineCount: function() {return this.size},\\n  firstLine: function() {return this.first},\\n  lastLine: function() {return this.first + this.size - 1},\\n\\n  clipPos: function(pos) {return clipPos(this, pos)},\\n\\n  getCursor: function(start) {\\n    var range = this.sel.primary(), pos\\n    if (start == null || start == \\\"head\\\") { pos = range.head }\\n    else if (start == \\\"anchor\\\") { pos = range.anchor }\\n    else if (start == \\\"end\\\" || start == \\\"to\\\" || start === false) { pos = range.to() }\\n    else { pos = range.from() }\\n    return pos\\n  },\\n  listSelections: function() { return this.sel.ranges },\\n  somethingSelected: function() {return this.sel.somethingSelected()},\\n\\n  setCursor: docMethodOp(function(line, ch, options) {\\n    setSimpleSelection(this, clipPos(this, typeof line == \\\"number\\\" ? Pos(line, ch || 0) : line), null, options)\\n  }),\\n  setSelection: docMethodOp(function(anchor, head, options) {\\n    setSimpleSelection(this, clipPos(this, anchor), clipPos(this, head || anchor), options)\\n  }),\\n  extendSelection: docMethodOp(function(head, other, options) {\\n    extendSelection(this, clipPos(this, head), other && clipPos(this, other), options)\\n  }),\\n  extendSelections: docMethodOp(function(heads, options) {\\n    extendSelections(this, clipPosArray(this, heads), options)\\n  }),\\n  extendSelectionsBy: docMethodOp(function(f, options) {\\n    var heads = map(this.sel.ranges, f)\\n    extendSelections(this, clipPosArray(this, heads), options)\\n  }),\\n  setSelections: docMethodOp(function(ranges, primary, options) {\\n    var this$1 = this;\\n\\n    if (!ranges.length) { return }\\n    var out = []\\n    for (var i = 0; i < ranges.length; i++)\\n      { out[i] = new Range(clipPos(this$1, ranges[i].anchor),\\n                         clipPos(this$1, ranges[i].head)) }\\n    if (primary == null) { primary = Math.min(ranges.length - 1, this.sel.primIndex) }\\n    setSelection(this, normalizeSelection(out, primary), options)\\n  }),\\n  addSelection: docMethodOp(function(anchor, head, options) {\\n    var ranges = this.sel.ranges.slice(0)\\n    ranges.push(new Range(clipPos(this, anchor), clipPos(this, head || anchor)))\\n    setSelection(this, normalizeSelection(ranges, ranges.length - 1), options)\\n  }),\\n\\n  getSelection: function(lineSep) {\\n    var this$1 = this;\\n\\n    var ranges = this.sel.ranges, lines\\n    for (var i = 0; i < ranges.length; i++) {\\n      var sel = getBetween(this$1, ranges[i].from(), ranges[i].to())\\n      lines = lines ? lines.concat(sel) : sel\\n    }\\n    if (lineSep === false) { return lines }\\n    else { return lines.join(lineSep || this.lineSeparator()) }\\n  },\\n  getSelections: function(lineSep) {\\n    var this$1 = this;\\n\\n    var parts = [], ranges = this.sel.ranges\\n    for (var i = 0; i < ranges.length; i++) {\\n      var sel = getBetween(this$1, ranges[i].from(), ranges[i].to())\\n      if (lineSep !== false) { sel = sel.join(lineSep || this$1.lineSeparator()) }\\n      parts[i] = sel\\n    }\\n    return parts\\n  },\\n  replaceSelection: function(code, collapse, origin) {\\n    var dup = []\\n    for (var i = 0; i < this.sel.ranges.length; i++)\\n      { dup[i] = code }\\n    this.replaceSelections(dup, collapse, origin || \\\"+input\\\")\\n  },\\n  replaceSelections: docMethodOp(function(code, collapse, origin) {\\n    var this$1 = this;\\n\\n    var changes = [], sel = this.sel\\n    for (var i = 0; i < sel.ranges.length; i++) {\\n      var range = sel.ranges[i]\\n      changes[i] = {from: range.from(), to: range.to(), text: this$1.splitLines(code[i]), origin: origin}\\n    }\\n    var newSel = collapse && collapse != \\\"end\\\" && computeReplacedSel(this, changes, collapse)\\n    for (var i$1 = changes.length - 1; i$1 >= 0; i$1--)\\n      { makeChange(this$1, changes[i$1]) }\\n    if (newSel) { setSelectionReplaceHistory(this, newSel) }\\n    else if (this.cm) { ensureCursorVisible(this.cm) }\\n  }),\\n  undo: docMethodOp(function() {makeChangeFromHistory(this, \\\"undo\\\")}),\\n  redo: docMethodOp(function() {makeChangeFromHistory(this, \\\"redo\\\")}),\\n  undoSelection: docMethodOp(function() {makeChangeFromHistory(this, \\\"undo\\\", true)}),\\n  redoSelection: docMethodOp(function() {makeChangeFromHistory(this, \\\"redo\\\", true)}),\\n\\n  setExtending: function(val) {this.extend = val},\\n  getExtending: function() {return this.extend},\\n\\n  historySize: function() {\\n    var hist = this.history, done = 0, undone = 0\\n    for (var i = 0; i < hist.done.length; i++) { if (!hist.done[i].ranges) { ++done } }\\n    for (var i$1 = 0; i$1 < hist.undone.length; i$1++) { if (!hist.undone[i$1].ranges) { ++undone } }\\n    return {undo: done, redo: undone}\\n  },\\n  clearHistory: function() {this.history = new History(this.history.maxGeneration)},\\n\\n  markClean: function() {\\n    this.cleanGeneration = this.changeGeneration(true)\\n  },\\n  changeGeneration: function(forceSplit) {\\n    if (forceSplit)\\n      { this.history.lastOp = this.history.lastSelOp = this.history.lastOrigin = null }\\n    return this.history.generation\\n  },\\n  isClean: function (gen) {\\n    return this.history.generation == (gen || this.cleanGeneration)\\n  },\\n\\n  getHistory: function() {\\n    return {done: copyHistoryArray(this.history.done),\\n            undone: copyHistoryArray(this.history.undone)}\\n  },\\n  setHistory: function(histData) {\\n    var hist = this.history = new History(this.history.maxGeneration)\\n    hist.done = copyHistoryArray(histData.done.slice(0), null, true)\\n    hist.undone = copyHistoryArray(histData.undone.slice(0), null, true)\\n  },\\n\\n  setGutterMarker: docMethodOp(function(line, gutterID, value) {\\n    return changeLine(this, line, \\\"gutter\\\", function (line) {\\n      var markers = line.gutterMarkers || (line.gutterMarkers = {})\\n      markers[gutterID] = value\\n      if (!value && isEmpty(markers)) { line.gutterMarkers = null }\\n      return true\\n    })\\n  }),\\n\\n  clearGutter: docMethodOp(function(gutterID) {\\n    var this$1 = this;\\n\\n    this.iter(function (line) {\\n      if (line.gutterMarkers && line.gutterMarkers[gutterID]) {\\n        changeLine(this$1, line, \\\"gutter\\\", function () {\\n          line.gutterMarkers[gutterID] = null\\n          if (isEmpty(line.gutterMarkers)) { line.gutterMarkers = null }\\n          return true\\n        })\\n      }\\n    })\\n  }),\\n\\n  lineInfo: function(line) {\\n    var n\\n    if (typeof line == \\\"number\\\") {\\n      if (!isLine(this, line)) { return null }\\n      n = line\\n      line = getLine(this, line)\\n      if (!line) { return null }\\n    } else {\\n      n = lineNo(line)\\n      if (n == null) { return null }\\n    }\\n    return {line: n, handle: line, text: line.text, gutterMarkers: line.gutterMarkers,\\n            textClass: line.textClass, bgClass: line.bgClass, wrapClass: line.wrapClass,\\n            widgets: line.widgets}\\n  },\\n\\n  addLineClass: docMethodOp(function(handle, where, cls) {\\n    return changeLine(this, handle, where == \\\"gutter\\\" ? \\\"gutter\\\" : \\\"class\\\", function (line) {\\n      var prop = where == \\\"text\\\" ? \\\"textClass\\\"\\n               : where == \\\"background\\\" ? \\\"bgClass\\\"\\n               : where == \\\"gutter\\\" ? \\\"gutterClass\\\" : \\\"wrapClass\\\"\\n      if (!line[prop]) { line[prop] = cls }\\n      else if (classTest(cls).test(line[prop])) { return false }\\n      else { line[prop] += \\\" \\\" + cls }\\n      return true\\n    })\\n  }),\\n  removeLineClass: docMethodOp(function(handle, where, cls) {\\n    return changeLine(this, handle, where == \\\"gutter\\\" ? \\\"gutter\\\" : \\\"class\\\", function (line) {\\n      var prop = where == \\\"text\\\" ? \\\"textClass\\\"\\n               : where == \\\"background\\\" ? \\\"bgClass\\\"\\n               : where == \\\"gutter\\\" ? \\\"gutterClass\\\" : \\\"wrapClass\\\"\\n      var cur = line[prop]\\n      if (!cur) { return false }\\n      else if (cls == null) { line[prop] = null }\\n      else {\\n        var found = cur.match(classTest(cls))\\n        if (!found) { return false }\\n        var end = found.index + found[0].length\\n        line[prop] = cur.slice(0, found.index) + (!found.index || end == cur.length ? \\\"\\\" : \\\" \\\") + cur.slice(end) || null\\n      }\\n      return true\\n    })\\n  }),\\n\\n  addLineWidget: docMethodOp(function(handle, node, options) {\\n    return addLineWidget(this, handle, node, options)\\n  }),\\n  removeLineWidget: function(widget) { widget.clear() },\\n\\n  markText: function(from, to, options) {\\n    return markText(this, clipPos(this, from), clipPos(this, to), options, options && options.type || \\\"range\\\")\\n  },\\n  setBookmark: function(pos, options) {\\n    var realOpts = {replacedWith: options && (options.nodeType == null ? options.widget : options),\\n                    insertLeft: options && options.insertLeft,\\n                    clearWhenEmpty: false, shared: options && options.shared,\\n                    handleMouseEvents: options && options.handleMouseEvents}\\n    pos = clipPos(this, pos)\\n    return markText(this, pos, pos, realOpts, \\\"bookmark\\\")\\n  },\\n  findMarksAt: function(pos) {\\n    pos = clipPos(this, pos)\\n    var markers = [], spans = getLine(this, pos.line).markedSpans\\n    if (spans) { for (var i = 0; i < spans.length; ++i) {\\n      var span = spans[i]\\n      if ((span.from == null || span.from <= pos.ch) &&\\n          (span.to == null || span.to >= pos.ch))\\n        { markers.push(span.marker.parent || span.marker) }\\n    } }\\n    return markers\\n  },\\n  findMarks: function(from, to, filter) {\\n    from = clipPos(this, from); to = clipPos(this, to)\\n    var found = [], lineNo = from.line\\n    this.iter(from.line, to.line + 1, function (line) {\\n      var spans = line.markedSpans\\n      if (spans) { for (var i = 0; i < spans.length; i++) {\\n        var span = spans[i]\\n        if (!(span.to != null && lineNo == from.line && from.ch >= span.to ||\\n              span.from == null && lineNo != from.line ||\\n              span.from != null && lineNo == to.line && span.from >= to.ch) &&\\n            (!filter || filter(span.marker)))\\n          { found.push(span.marker.parent || span.marker) }\\n      } }\\n      ++lineNo\\n    })\\n    return found\\n  },\\n  getAllMarks: function() {\\n    var markers = []\\n    this.iter(function (line) {\\n      var sps = line.markedSpans\\n      if (sps) { for (var i = 0; i < sps.length; ++i)\\n        { if (sps[i].from != null) { markers.push(sps[i].marker) } } }\\n    })\\n    return markers\\n  },\\n\\n  posFromIndex: function(off) {\\n    var ch, lineNo = this.first, sepSize = this.lineSeparator().length\\n    this.iter(function (line) {\\n      var sz = line.text.length + sepSize\\n      if (sz > off) { ch = off; return true }\\n      off -= sz\\n      ++lineNo\\n    })\\n    return clipPos(this, Pos(lineNo, ch))\\n  },\\n  indexFromPos: function (coords) {\\n    coords = clipPos(this, coords)\\n    var index = coords.ch\\n    if (coords.line < this.first || coords.ch < 0) { return 0 }\\n    var sepSize = this.lineSeparator().length\\n    this.iter(this.first, coords.line, function (line) { // iter aborts when callback returns a truthy value\\n      index += line.text.length + sepSize\\n    })\\n    return index\\n  },\\n\\n  copy: function(copyHistory) {\\n    var doc = new Doc(getLines(this, this.first, this.first + this.size),\\n                      this.modeOption, this.first, this.lineSep)\\n    doc.scrollTop = this.scrollTop; doc.scrollLeft = this.scrollLeft\\n    doc.sel = this.sel\\n    doc.extend = false\\n    if (copyHistory) {\\n      doc.history.undoDepth = this.history.undoDepth\\n      doc.setHistory(this.getHistory())\\n    }\\n    return doc\\n  },\\n\\n  linkedDoc: function(options) {\\n    if (!options) { options = {} }\\n    var from = this.first, to = this.first + this.size\\n    if (options.from != null && options.from > from) { from = options.from }\\n    if (options.to != null && options.to < to) { to = options.to }\\n    var copy = new Doc(getLines(this, from, to), options.mode || this.modeOption, from, this.lineSep)\\n    if (options.sharedHist) { copy.history = this.history\\n    ; }(this.linked || (this.linked = [])).push({doc: copy, sharedHist: options.sharedHist})\\n    copy.linked = [{doc: this, isParent: true, sharedHist: options.sharedHist}]\\n    copySharedMarkers(copy, findSharedMarkers(this))\\n    return copy\\n  },\\n  unlinkDoc: function(other) {\\n    var this$1 = this;\\n\\n    if (other instanceof CodeMirror) { other = other.doc }\\n    if (this.linked) { for (var i = 0; i < this.linked.length; ++i) {\\n      var link = this$1.linked[i]\\n      if (link.doc != other) { continue }\\n      this$1.linked.splice(i, 1)\\n      other.unlinkDoc(this$1)\\n      detachSharedMarkers(findSharedMarkers(this$1))\\n      break\\n    } }\\n    // If the histories were shared, split them again\\n    if (other.history == this.history) {\\n      var splitIds = [other.id]\\n      linkedDocs(other, function (doc) { return splitIds.push(doc.id); }, true)\\n      other.history = new History(null)\\n      other.history.done = copyHistoryArray(this.history.done, splitIds)\\n      other.history.undone = copyHistoryArray(this.history.undone, splitIds)\\n    }\\n  },\\n  iterLinkedDocs: function(f) {linkedDocs(this, f)},\\n\\n  getMode: function() {return this.mode},\\n  getEditor: function() {return this.cm},\\n\\n  splitLines: function(str) {\\n    if (this.lineSep) { return str.split(this.lineSep) }\\n    return splitLinesAuto(str)\\n  },\\n  lineSeparator: function() { return this.lineSep || \\\"\\\\n\\\" }\\n})\\n\\n// Public alias.\\nDoc.prototype.eachLine = Doc.prototype.iter\\n\\n// Kludge to work around strange IE behavior where it'll sometimes\\n// re-fire a series of drag-related events right after the drop (#1551)\\nvar lastDrop = 0\\n\\nfunction onDrop(e) {\\n  var cm = this\\n  clearDragCursor(cm)\\n  if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e))\\n    { return }\\n  e_preventDefault(e)\\n  if (ie) { lastDrop = +new Date }\\n  var pos = posFromMouse(cm, e, true), files = e.dataTransfer.files\\n  if (!pos || cm.isReadOnly()) { return }\\n  // Might be a file drop, in which case we simply extract the text\\n  // and insert it.\\n  if (files && files.length && window.FileReader && window.File) {\\n    var n = files.length, text = Array(n), read = 0\\n    var loadFile = function (file, i) {\\n      if (cm.options.allowDropFileTypes &&\\n          indexOf(cm.options.allowDropFileTypes, file.type) == -1)\\n        { return }\\n\\n      var reader = new FileReader\\n      reader.onload = operation(cm, function () {\\n        var content = reader.result\\n        if (/[\\\\x00-\\\\x08\\\\x0e-\\\\x1f]{2}/.test(content)) { content = \\\"\\\" }\\n        text[i] = content\\n        if (++read == n) {\\n          pos = clipPos(cm.doc, pos)\\n          var change = {from: pos, to: pos,\\n                        text: cm.doc.splitLines(text.join(cm.doc.lineSeparator())),\\n                        origin: \\\"paste\\\"}\\n          makeChange(cm.doc, change)\\n          setSelectionReplaceHistory(cm.doc, simpleSelection(pos, changeEnd(change)))\\n        }\\n      })\\n      reader.readAsText(file)\\n    }\\n    for (var i = 0; i < n; ++i) { loadFile(files[i], i) }\\n  } else { // Normal drop\\n    // Don't do a replace if the drop happened inside of the selected text.\\n    if (cm.state.draggingText && cm.doc.sel.contains(pos) > -1) {\\n      cm.state.draggingText(e)\\n      // Ensure the editor is re-focused\\n      setTimeout(function () { return cm.display.input.focus(); }, 20)\\n      return\\n    }\\n    try {\\n      var text$1 = e.dataTransfer.getData(\\\"Text\\\")\\n      if (text$1) {\\n        var selected\\n        if (cm.state.draggingText && !cm.state.draggingText.copy)\\n          { selected = cm.listSelections() }\\n        setSelectionNoUndo(cm.doc, simpleSelection(pos, pos))\\n        if (selected) { for (var i$1 = 0; i$1 < selected.length; ++i$1)\\n          { replaceRange(cm.doc, \\\"\\\", selected[i$1].anchor, selected[i$1].head, \\\"drag\\\") } }\\n        cm.replaceSelection(text$1, \\\"around\\\", \\\"paste\\\")\\n        cm.display.input.focus()\\n      }\\n    }\\n    catch(e){}\\n  }\\n}\\n\\nfunction onDragStart(cm, e) {\\n  if (ie && (!cm.state.draggingText || +new Date - lastDrop < 100)) { e_stop(e); return }\\n  if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e)) { return }\\n\\n  e.dataTransfer.setData(\\\"Text\\\", cm.getSelection())\\n  e.dataTransfer.effectAllowed = \\\"copyMove\\\"\\n\\n  // Use dummy image instead of default browsers image.\\n  // Recent Safari (~6.0.2) have a tendency to segfault when this happens, so we don't do it there.\\n  if (e.dataTransfer.setDragImage && !safari) {\\n    var img = elt(\\\"img\\\", null, null, \\\"position: fixed; left: 0; top: 0;\\\")\\n    img.src = \\\"data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\\\"\\n    if (presto) {\\n      img.width = img.height = 1\\n      cm.display.wrapper.appendChild(img)\\n      // Force a relayout, or Opera won't use our image for some obscure reason\\n      img._top = img.offsetTop\\n    }\\n    e.dataTransfer.setDragImage(img, 0, 0)\\n    if (presto) { img.parentNode.removeChild(img) }\\n  }\\n}\\n\\nfunction onDragOver(cm, e) {\\n  var pos = posFromMouse(cm, e)\\n  if (!pos) { return }\\n  var frag = document.createDocumentFragment()\\n  drawSelectionCursor(cm, pos, frag)\\n  if (!cm.display.dragCursor) {\\n    cm.display.dragCursor = elt(\\\"div\\\", null, \\\"CodeMirror-cursors CodeMirror-dragcursors\\\")\\n    cm.display.lineSpace.insertBefore(cm.display.dragCursor, cm.display.cursorDiv)\\n  }\\n  removeChildrenAndAdd(cm.display.dragCursor, frag)\\n}\\n\\nfunction clearDragCursor(cm) {\\n  if (cm.display.dragCursor) {\\n    cm.display.lineSpace.removeChild(cm.display.dragCursor)\\n    cm.display.dragCursor = null\\n  }\\n}\\n\\n// These must be handled carefully, because naively registering a\\n// handler for each editor will cause the editors to never be\\n// garbage collected.\\n\\nfunction forEachCodeMirror(f) {\\n  if (!document.body.getElementsByClassName) { return }\\n  var byClass = document.body.getElementsByClassName(\\\"CodeMirror\\\")\\n  for (var i = 0; i < byClass.length; i++) {\\n    var cm = byClass[i].CodeMirror\\n    if (cm) { f(cm) }\\n  }\\n}\\n\\nvar globalsRegistered = false\\nfunction ensureGlobalHandlers() {\\n  if (globalsRegistered) { return }\\n  registerGlobalHandlers()\\n  globalsRegistered = true\\n}\\nfunction registerGlobalHandlers() {\\n  // When the window resizes, we need to refresh active editors.\\n  var resizeTimer\\n  on(window, \\\"resize\\\", function () {\\n    if (resizeTimer == null) { resizeTimer = setTimeout(function () {\\n      resizeTimer = null\\n      forEachCodeMirror(onResize)\\n    }, 100) }\\n  })\\n  // When the window loses focus, we want to show the editor as blurred\\n  on(window, \\\"blur\\\", function () { return forEachCodeMirror(onBlur); })\\n}\\n// Called when the window resizes\\nfunction onResize(cm) {\\n  var d = cm.display\\n  if (d.lastWrapHeight == d.wrapper.clientHeight && d.lastWrapWidth == d.wrapper.clientWidth)\\n    { return }\\n  // Might be a text scaling operation, clear size caches.\\n  d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null\\n  d.scrollbarsClipped = false\\n  cm.setSize()\\n}\\n\\nvar keyNames = {\\n  3: \\\"Enter\\\", 8: \\\"Backspace\\\", 9: \\\"Tab\\\", 13: \\\"Enter\\\", 16: \\\"Shift\\\", 17: \\\"Ctrl\\\", 18: \\\"Alt\\\",\\n  19: \\\"Pause\\\", 20: \\\"CapsLock\\\", 27: \\\"Esc\\\", 32: \\\"Space\\\", 33: \\\"PageUp\\\", 34: \\\"PageDown\\\", 35: \\\"End\\\",\\n  36: \\\"Home\\\", 37: \\\"Left\\\", 38: \\\"Up\\\", 39: \\\"Right\\\", 40: \\\"Down\\\", 44: \\\"PrintScrn\\\", 45: \\\"Insert\\\",\\n  46: \\\"Delete\\\", 59: \\\";\\\", 61: \\\"=\\\", 91: \\\"Mod\\\", 92: \\\"Mod\\\", 93: \\\"Mod\\\",\\n  106: \\\"*\\\", 107: \\\"=\\\", 109: \\\"-\\\", 110: \\\".\\\", 111: \\\"/\\\", 127: \\\"Delete\\\",\\n  173: \\\"-\\\", 186: \\\";\\\", 187: \\\"=\\\", 188: \\\",\\\", 189: \\\"-\\\", 190: \\\".\\\", 191: \\\"/\\\", 192: \\\"`\\\", 219: \\\"[\\\", 220: \\\"\\\\\\\\\\\",\\n  221: \\\"]\\\", 222: \\\"'\\\", 63232: \\\"Up\\\", 63233: \\\"Down\\\", 63234: \\\"Left\\\", 63235: \\\"Right\\\", 63272: \\\"Delete\\\",\\n  63273: \\\"Home\\\", 63275: \\\"End\\\", 63276: \\\"PageUp\\\", 63277: \\\"PageDown\\\", 63302: \\\"Insert\\\"\\n}\\n\\n// Number keys\\nfor (var i = 0; i < 10; i++) { keyNames[i + 48] = keyNames[i + 96] = String(i) }\\n// Alphabetic keys\\nfor (var i$1 = 65; i$1 <= 90; i$1++) { keyNames[i$1] = String.fromCharCode(i$1) }\\n// Function keys\\nfor (var i$2 = 1; i$2 <= 12; i$2++) { keyNames[i$2 + 111] = keyNames[i$2 + 63235] = \\\"F\\\" + i$2 }\\n\\nvar keyMap = {}\\n\\nkeyMap.basic = {\\n  \\\"Left\\\": \\\"goCharLeft\\\", \\\"Right\\\": \\\"goCharRight\\\", \\\"Up\\\": \\\"goLineUp\\\", \\\"Down\\\": \\\"goLineDown\\\",\\n  \\\"End\\\": \\\"goLineEnd\\\", \\\"Home\\\": \\\"goLineStartSmart\\\", \\\"PageUp\\\": \\\"goPageUp\\\", \\\"PageDown\\\": \\\"goPageDown\\\",\\n  \\\"Delete\\\": \\\"delCharAfter\\\", \\\"Backspace\\\": \\\"delCharBefore\\\", \\\"Shift-Backspace\\\": \\\"delCharBefore\\\",\\n  \\\"Tab\\\": \\\"defaultTab\\\", \\\"Shift-Tab\\\": \\\"indentAuto\\\",\\n  \\\"Enter\\\": \\\"newlineAndIndent\\\", \\\"Insert\\\": \\\"toggleOverwrite\\\",\\n  \\\"Esc\\\": \\\"singleSelection\\\"\\n}\\n// Note that the save and find-related commands aren't defined by\\n// default. User code or addons can define them. Unknown commands\\n// are simply ignored.\\nkeyMap.pcDefault = {\\n  \\\"Ctrl-A\\\": \\\"selectAll\\\", \\\"Ctrl-D\\\": \\\"deleteLine\\\", \\\"Ctrl-Z\\\": \\\"undo\\\", \\\"Shift-Ctrl-Z\\\": \\\"redo\\\", \\\"Ctrl-Y\\\": \\\"redo\\\",\\n  \\\"Ctrl-Home\\\": \\\"goDocStart\\\", \\\"Ctrl-End\\\": \\\"goDocEnd\\\", \\\"Ctrl-Up\\\": \\\"goLineUp\\\", \\\"Ctrl-Down\\\": \\\"goLineDown\\\",\\n  \\\"Ctrl-Left\\\": \\\"goGroupLeft\\\", \\\"Ctrl-Right\\\": \\\"goGroupRight\\\", \\\"Alt-Left\\\": \\\"goLineStart\\\", \\\"Alt-Right\\\": \\\"goLineEnd\\\",\\n  \\\"Ctrl-Backspace\\\": \\\"delGroupBefore\\\", \\\"Ctrl-Delete\\\": \\\"delGroupAfter\\\", \\\"Ctrl-S\\\": \\\"save\\\", \\\"Ctrl-F\\\": \\\"find\\\",\\n  \\\"Ctrl-G\\\": \\\"findNext\\\", \\\"Shift-Ctrl-G\\\": \\\"findPrev\\\", \\\"Shift-Ctrl-F\\\": \\\"replace\\\", \\\"Shift-Ctrl-R\\\": \\\"replaceAll\\\",\\n  \\\"Ctrl-[\\\": \\\"indentLess\\\", \\\"Ctrl-]\\\": \\\"indentMore\\\",\\n  \\\"Ctrl-U\\\": \\\"undoSelection\\\", \\\"Shift-Ctrl-U\\\": \\\"redoSelection\\\", \\\"Alt-U\\\": \\\"redoSelection\\\",\\n  fallthrough: \\\"basic\\\"\\n}\\n// Very basic readline/emacs-style bindings, which are standard on Mac.\\nkeyMap.emacsy = {\\n  \\\"Ctrl-F\\\": \\\"goCharRight\\\", \\\"Ctrl-B\\\": \\\"goCharLeft\\\", \\\"Ctrl-P\\\": \\\"goLineUp\\\", \\\"Ctrl-N\\\": \\\"goLineDown\\\",\\n  \\\"Alt-F\\\": \\\"goWordRight\\\", \\\"Alt-B\\\": \\\"goWordLeft\\\", \\\"Ctrl-A\\\": \\\"goLineStart\\\", \\\"Ctrl-E\\\": \\\"goLineEnd\\\",\\n  \\\"Ctrl-V\\\": \\\"goPageDown\\\", \\\"Shift-Ctrl-V\\\": \\\"goPageUp\\\", \\\"Ctrl-D\\\": \\\"delCharAfter\\\", \\\"Ctrl-H\\\": \\\"delCharBefore\\\",\\n  \\\"Alt-D\\\": \\\"delWordAfter\\\", \\\"Alt-Backspace\\\": \\\"delWordBefore\\\", \\\"Ctrl-K\\\": \\\"killLine\\\", \\\"Ctrl-T\\\": \\\"transposeChars\\\",\\n  \\\"Ctrl-O\\\": \\\"openLine\\\"\\n}\\nkeyMap.macDefault = {\\n  \\\"Cmd-A\\\": \\\"selectAll\\\", \\\"Cmd-D\\\": \\\"deleteLine\\\", \\\"Cmd-Z\\\": \\\"undo\\\", \\\"Shift-Cmd-Z\\\": \\\"redo\\\", \\\"Cmd-Y\\\": \\\"redo\\\",\\n  \\\"Cmd-Home\\\": \\\"goDocStart\\\", \\\"Cmd-Up\\\": \\\"goDocStart\\\", \\\"Cmd-End\\\": \\\"goDocEnd\\\", \\\"Cmd-Down\\\": \\\"goDocEnd\\\", \\\"Alt-Left\\\": \\\"goGroupLeft\\\",\\n  \\\"Alt-Right\\\": \\\"goGroupRight\\\", \\\"Cmd-Left\\\": \\\"goLineLeft\\\", \\\"Cmd-Right\\\": \\\"goLineRight\\\", \\\"Alt-Backspace\\\": \\\"delGroupBefore\\\",\\n  \\\"Ctrl-Alt-Backspace\\\": \\\"delGroupAfter\\\", \\\"Alt-Delete\\\": \\\"delGroupAfter\\\", \\\"Cmd-S\\\": \\\"save\\\", \\\"Cmd-F\\\": \\\"find\\\",\\n  \\\"Cmd-G\\\": \\\"findNext\\\", \\\"Shift-Cmd-G\\\": \\\"findPrev\\\", \\\"Cmd-Alt-F\\\": \\\"replace\\\", \\\"Shift-Cmd-Alt-F\\\": \\\"replaceAll\\\",\\n  \\\"Cmd-[\\\": \\\"indentLess\\\", \\\"Cmd-]\\\": \\\"indentMore\\\", \\\"Cmd-Backspace\\\": \\\"delWrappedLineLeft\\\", \\\"Cmd-Delete\\\": \\\"delWrappedLineRight\\\",\\n  \\\"Cmd-U\\\": \\\"undoSelection\\\", \\\"Shift-Cmd-U\\\": \\\"redoSelection\\\", \\\"Ctrl-Up\\\": \\\"goDocStart\\\", \\\"Ctrl-Down\\\": \\\"goDocEnd\\\",\\n  fallthrough: [\\\"basic\\\", \\\"emacsy\\\"]\\n}\\nkeyMap[\\\"default\\\"] = mac ? keyMap.macDefault : keyMap.pcDefault\\n\\n// KEYMAP DISPATCH\\n\\nfunction normalizeKeyName(name) {\\n  var parts = name.split(/-(?!$)/)\\n  name = parts[parts.length - 1]\\n  var alt, ctrl, shift, cmd\\n  for (var i = 0; i < parts.length - 1; i++) {\\n    var mod = parts[i]\\n    if (/^(cmd|meta|m)$/i.test(mod)) { cmd = true }\\n    else if (/^a(lt)?$/i.test(mod)) { alt = true }\\n    else if (/^(c|ctrl|control)$/i.test(mod)) { ctrl = true }\\n    else if (/^s(hift)?$/i.test(mod)) { shift = true }\\n    else { throw new Error(\\\"Unrecognized modifier name: \\\" + mod) }\\n  }\\n  if (alt) { name = \\\"Alt-\\\" + name }\\n  if (ctrl) { name = \\\"Ctrl-\\\" + name }\\n  if (cmd) { name = \\\"Cmd-\\\" + name }\\n  if (shift) { name = \\\"Shift-\\\" + name }\\n  return name\\n}\\n\\n// This is a kludge to keep keymaps mostly working as raw objects\\n// (backwards compatibility) while at the same time support features\\n// like normalization and multi-stroke key bindings. It compiles a\\n// new normalized keymap, and then updates the old object to reflect\\n// this.\\nfunction normalizeKeyMap(keymap) {\\n  var copy = {}\\n  for (var keyname in keymap) { if (keymap.hasOwnProperty(keyname)) {\\n    var value = keymap[keyname]\\n    if (/^(name|fallthrough|(de|at)tach)$/.test(keyname)) { continue }\\n    if (value == \\\"...\\\") { delete keymap[keyname]; continue }\\n\\n    var keys = map(keyname.split(\\\" \\\"), normalizeKeyName)\\n    for (var i = 0; i < keys.length; i++) {\\n      var val = (void 0), name = (void 0)\\n      if (i == keys.length - 1) {\\n        name = keys.join(\\\" \\\")\\n        val = value\\n      } else {\\n        name = keys.slice(0, i + 1).join(\\\" \\\")\\n        val = \\\"...\\\"\\n      }\\n      var prev = copy[name]\\n      if (!prev) { copy[name] = val }\\n      else if (prev != val) { throw new Error(\\\"Inconsistent bindings for \\\" + name) }\\n    }\\n    delete keymap[keyname]\\n  } }\\n  for (var prop in copy) { keymap[prop] = copy[prop] }\\n  return keymap\\n}\\n\\nfunction lookupKey(key, map, handle, context) {\\n  map = getKeyMap(map)\\n  var found = map.call ? map.call(key, context) : map[key]\\n  if (found === false) { return \\\"nothing\\\" }\\n  if (found === \\\"...\\\") { return \\\"multi\\\" }\\n  if (found != null && handle(found)) { return \\\"handled\\\" }\\n\\n  if (map.fallthrough) {\\n    if (Object.prototype.toString.call(map.fallthrough) != \\\"[object Array]\\\")\\n      { return lookupKey(key, map.fallthrough, handle, context) }\\n    for (var i = 0; i < map.fallthrough.length; i++) {\\n      var result = lookupKey(key, map.fallthrough[i], handle, context)\\n      if (result) { return result }\\n    }\\n  }\\n}\\n\\n// Modifier key presses don't count as 'real' key presses for the\\n// purpose of keymap fallthrough.\\nfunction isModifierKey(value) {\\n  var name = typeof value == \\\"string\\\" ? value : keyNames[value.keyCode]\\n  return name == \\\"Ctrl\\\" || name == \\\"Alt\\\" || name == \\\"Shift\\\" || name == \\\"Mod\\\"\\n}\\n\\n// Look up the name of a key as indicated by an event object.\\nfunction keyName(event, noShift) {\\n  if (presto && event.keyCode == 34 && event[\\\"char\\\"]) { return false }\\n  var base = keyNames[event.keyCode], name = base\\n  if (name == null || event.altGraphKey) { return false }\\n  if (event.altKey && base != \\\"Alt\\\") { name = \\\"Alt-\\\" + name }\\n  if ((flipCtrlCmd ? event.metaKey : event.ctrlKey) && base != \\\"Ctrl\\\") { name = \\\"Ctrl-\\\" + name }\\n  if ((flipCtrlCmd ? event.ctrlKey : event.metaKey) && base != \\\"Cmd\\\") { name = \\\"Cmd-\\\" + name }\\n  if (!noShift && event.shiftKey && base != \\\"Shift\\\") { name = \\\"Shift-\\\" + name }\\n  return name\\n}\\n\\nfunction getKeyMap(val) {\\n  return typeof val == \\\"string\\\" ? keyMap[val] : val\\n}\\n\\n// Helper for deleting text near the selection(s), used to implement\\n// backspace, delete, and similar functionality.\\nfunction deleteNearSelection(cm, compute) {\\n  var ranges = cm.doc.sel.ranges, kill = []\\n  // Build up a set of ranges to kill first, merging overlapping\\n  // ranges.\\n  for (var i = 0; i < ranges.length; i++) {\\n    var toKill = compute(ranges[i])\\n    while (kill.length && cmp(toKill.from, lst(kill).to) <= 0) {\\n      var replaced = kill.pop()\\n      if (cmp(replaced.from, toKill.from) < 0) {\\n        toKill.from = replaced.from\\n        break\\n      }\\n    }\\n    kill.push(toKill)\\n  }\\n  // Next, remove those actual ranges.\\n  runInOp(cm, function () {\\n    for (var i = kill.length - 1; i >= 0; i--)\\n      { replaceRange(cm.doc, \\\"\\\", kill[i].from, kill[i].to, \\\"+delete\\\") }\\n    ensureCursorVisible(cm)\\n  })\\n}\\n\\n// Commands are parameter-less actions that can be performed on an\\n// editor, mostly used for keybindings.\\nvar commands = {\\n  selectAll: selectAll,\\n  singleSelection: function (cm) { return cm.setSelection(cm.getCursor(\\\"anchor\\\"), cm.getCursor(\\\"head\\\"), sel_dontScroll); },\\n  killLine: function (cm) { return deleteNearSelection(cm, function (range) {\\n    if (range.empty()) {\\n      var len = getLine(cm.doc, range.head.line).text.length\\n      if (range.head.ch == len && range.head.line < cm.lastLine())\\n        { return {from: range.head, to: Pos(range.head.line + 1, 0)} }\\n      else\\n        { return {from: range.head, to: Pos(range.head.line, len)} }\\n    } else {\\n      return {from: range.from(), to: range.to()}\\n    }\\n  }); },\\n  deleteLine: function (cm) { return deleteNearSelection(cm, function (range) { return ({\\n    from: Pos(range.from().line, 0),\\n    to: clipPos(cm.doc, Pos(range.to().line + 1, 0))\\n  }); }); },\\n  delLineLeft: function (cm) { return deleteNearSelection(cm, function (range) { return ({\\n    from: Pos(range.from().line, 0), to: range.from()\\n  }); }); },\\n  delWrappedLineLeft: function (cm) { return deleteNearSelection(cm, function (range) {\\n    var top = cm.charCoords(range.head, \\\"div\\\").top + 5\\n    var leftPos = cm.coordsChar({left: 0, top: top}, \\\"div\\\")\\n    return {from: leftPos, to: range.from()}\\n  }); },\\n  delWrappedLineRight: function (cm) { return deleteNearSelection(cm, function (range) {\\n    var top = cm.charCoords(range.head, \\\"div\\\").top + 5\\n    var rightPos = cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, \\\"div\\\")\\n    return {from: range.from(), to: rightPos }\\n  }); },\\n  undo: function (cm) { return cm.undo(); },\\n  redo: function (cm) { return cm.redo(); },\\n  undoSelection: function (cm) { return cm.undoSelection(); },\\n  redoSelection: function (cm) { return cm.redoSelection(); },\\n  goDocStart: function (cm) { return cm.extendSelection(Pos(cm.firstLine(), 0)); },\\n  goDocEnd: function (cm) { return cm.extendSelection(Pos(cm.lastLine())); },\\n  goLineStart: function (cm) { return cm.extendSelectionsBy(function (range) { return lineStart(cm, range.head.line); },\\n    {origin: \\\"+move\\\", bias: 1}\\n  ); },\\n  goLineStartSmart: function (cm) { return cm.extendSelectionsBy(function (range) { return lineStartSmart(cm, range.head); },\\n    {origin: \\\"+move\\\", bias: 1}\\n  ); },\\n  goLineEnd: function (cm) { return cm.extendSelectionsBy(function (range) { return lineEnd(cm, range.head.line); },\\n    {origin: \\\"+move\\\", bias: -1}\\n  ); },\\n  goLineRight: function (cm) { return cm.extendSelectionsBy(function (range) {\\n    var top = cm.charCoords(range.head, \\\"div\\\").top + 5\\n    return cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, \\\"div\\\")\\n  }, sel_move); },\\n  goLineLeft: function (cm) { return cm.extendSelectionsBy(function (range) {\\n    var top = cm.charCoords(range.head, \\\"div\\\").top + 5\\n    return cm.coordsChar({left: 0, top: top}, \\\"div\\\")\\n  }, sel_move); },\\n  goLineLeftSmart: function (cm) { return cm.extendSelectionsBy(function (range) {\\n    var top = cm.charCoords(range.head, \\\"div\\\").top + 5\\n    var pos = cm.coordsChar({left: 0, top: top}, \\\"div\\\")\\n    if (pos.ch < cm.getLine(pos.line).search(/\\\\S/)) { return lineStartSmart(cm, range.head) }\\n    return pos\\n  }, sel_move); },\\n  goLineUp: function (cm) { return cm.moveV(-1, \\\"line\\\"); },\\n  goLineDown: function (cm) { return cm.moveV(1, \\\"line\\\"); },\\n  goPageUp: function (cm) { return cm.moveV(-1, \\\"page\\\"); },\\n  goPageDown: function (cm) { return cm.moveV(1, \\\"page\\\"); },\\n  goCharLeft: function (cm) { return cm.moveH(-1, \\\"char\\\"); },\\n  goCharRight: function (cm) { return cm.moveH(1, \\\"char\\\"); },\\n  goColumnLeft: function (cm) { return cm.moveH(-1, \\\"column\\\"); },\\n  goColumnRight: function (cm) { return cm.moveH(1, \\\"column\\\"); },\\n  goWordLeft: function (cm) { return cm.moveH(-1, \\\"word\\\"); },\\n  goGroupRight: function (cm) { return cm.moveH(1, \\\"group\\\"); },\\n  goGroupLeft: function (cm) { return cm.moveH(-1, \\\"group\\\"); },\\n  goWordRight: function (cm) { return cm.moveH(1, \\\"word\\\"); },\\n  delCharBefore: function (cm) { return cm.deleteH(-1, \\\"char\\\"); },\\n  delCharAfter: function (cm) { return cm.deleteH(1, \\\"char\\\"); },\\n  delWordBefore: function (cm) { return cm.deleteH(-1, \\\"word\\\"); },\\n  delWordAfter: function (cm) { return cm.deleteH(1, \\\"word\\\"); },\\n  delGroupBefore: function (cm) { return cm.deleteH(-1, \\\"group\\\"); },\\n  delGroupAfter: function (cm) { return cm.deleteH(1, \\\"group\\\"); },\\n  indentAuto: function (cm) { return cm.indentSelection(\\\"smart\\\"); },\\n  indentMore: function (cm) { return cm.indentSelection(\\\"add\\\"); },\\n  indentLess: function (cm) { return cm.indentSelection(\\\"subtract\\\"); },\\n  insertTab: function (cm) { return cm.replaceSelection(\\\"\\\\t\\\"); },\\n  insertSoftTab: function (cm) {\\n    var spaces = [], ranges = cm.listSelections(), tabSize = cm.options.tabSize\\n    for (var i = 0; i < ranges.length; i++) {\\n      var pos = ranges[i].from()\\n      var col = countColumn(cm.getLine(pos.line), pos.ch, tabSize)\\n      spaces.push(spaceStr(tabSize - col % tabSize))\\n    }\\n    cm.replaceSelections(spaces)\\n  },\\n  defaultTab: function (cm) {\\n    if (cm.somethingSelected()) { cm.indentSelection(\\\"add\\\") }\\n    else { cm.execCommand(\\\"insertTab\\\") }\\n  },\\n  // Swap the two chars left and right of each selection's head.\\n  // Move cursor behind the two swapped characters afterwards.\\n  //\\n  // Doesn't consider line feeds a character.\\n  // Doesn't scan more than one line above to find a character.\\n  // Doesn't do anything on an empty line.\\n  // Doesn't do anything with non-empty selections.\\n  transposeChars: function (cm) { return runInOp(cm, function () {\\n    var ranges = cm.listSelections(), newSel = []\\n    for (var i = 0; i < ranges.length; i++) {\\n      if (!ranges[i].empty()) { continue }\\n      var cur = ranges[i].head, line = getLine(cm.doc, cur.line).text\\n      if (line) {\\n        if (cur.ch == line.length) { cur = new Pos(cur.line, cur.ch - 1) }\\n        if (cur.ch > 0) {\\n          cur = new Pos(cur.line, cur.ch + 1)\\n          cm.replaceRange(line.charAt(cur.ch - 1) + line.charAt(cur.ch - 2),\\n                          Pos(cur.line, cur.ch - 2), cur, \\\"+transpose\\\")\\n        } else if (cur.line > cm.doc.first) {\\n          var prev = getLine(cm.doc, cur.line - 1).text\\n          if (prev) {\\n            cur = new Pos(cur.line, 1)\\n            cm.replaceRange(line.charAt(0) + cm.doc.lineSeparator() +\\n                            prev.charAt(prev.length - 1),\\n                            Pos(cur.line - 1, prev.length - 1), cur, \\\"+transpose\\\")\\n          }\\n        }\\n      }\\n      newSel.push(new Range(cur, cur))\\n    }\\n    cm.setSelections(newSel)\\n  }); },\\n  newlineAndIndent: function (cm) { return runInOp(cm, function () {\\n    var sels = cm.listSelections()\\n    for (var i = sels.length - 1; i >= 0; i--)\\n      { cm.replaceRange(cm.doc.lineSeparator(), sels[i].anchor, sels[i].head, \\\"+input\\\") }\\n    sels = cm.listSelections()\\n    for (var i$1 = 0; i$1 < sels.length; i$1++)\\n      { cm.indentLine(sels[i$1].from().line, null, true) }\\n    ensureCursorVisible(cm)\\n  }); },\\n  openLine: function (cm) { return cm.replaceSelection(\\\"\\\\n\\\", \\\"start\\\"); },\\n  toggleOverwrite: function (cm) { return cm.toggleOverwrite(); }\\n}\\n\\n\\nfunction lineStart(cm, lineN) {\\n  var line = getLine(cm.doc, lineN)\\n  var visual = visualLine(line)\\n  if (visual != line) { lineN = lineNo(visual) }\\n  var order = getOrder(visual)\\n  var ch = !order ? 0 : order[0].level % 2 ? lineRight(visual) : lineLeft(visual)\\n  return Pos(lineN, ch)\\n}\\nfunction lineEnd(cm, lineN) {\\n  var merged, line = getLine(cm.doc, lineN)\\n  while (merged = collapsedSpanAtEnd(line)) {\\n    line = merged.find(1, true).line\\n    lineN = null\\n  }\\n  var order = getOrder(line)\\n  var ch = !order ? line.text.length : order[0].level % 2 ? lineLeft(line) : lineRight(line)\\n  return Pos(lineN == null ? lineNo(line) : lineN, ch)\\n}\\nfunction lineStartSmart(cm, pos) {\\n  var start = lineStart(cm, pos.line)\\n  var line = getLine(cm.doc, start.line)\\n  var order = getOrder(line)\\n  if (!order || order[0].level == 0) {\\n    var firstNonWS = Math.max(0, line.text.search(/\\\\S/))\\n    var inWS = pos.line == start.line && pos.ch <= firstNonWS && pos.ch\\n    return Pos(start.line, inWS ? 0 : firstNonWS)\\n  }\\n  return start\\n}\\n\\n// Run a handler that was bound to a key.\\nfunction doHandleBinding(cm, bound, dropShift) {\\n  if (typeof bound == \\\"string\\\") {\\n    bound = commands[bound]\\n    if (!bound) { return false }\\n  }\\n  // Ensure previous input has been read, so that the handler sees a\\n  // consistent view of the document\\n  cm.display.input.ensurePolled()\\n  var prevShift = cm.display.shift, done = false\\n  try {\\n    if (cm.isReadOnly()) { cm.state.suppressEdits = true }\\n    if (dropShift) { cm.display.shift = false }\\n    done = bound(cm) != Pass\\n  } finally {\\n    cm.display.shift = prevShift\\n    cm.state.suppressEdits = false\\n  }\\n  return done\\n}\\n\\nfunction lookupKeyForEditor(cm, name, handle) {\\n  for (var i = 0; i < cm.state.keyMaps.length; i++) {\\n    var result = lookupKey(name, cm.state.keyMaps[i], handle, cm)\\n    if (result) { return result }\\n  }\\n  return (cm.options.extraKeys && lookupKey(name, cm.options.extraKeys, handle, cm))\\n    || lookupKey(name, cm.options.keyMap, handle, cm)\\n}\\n\\nvar stopSeq = new Delayed\\nfunction dispatchKey(cm, name, e, handle) {\\n  var seq = cm.state.keySeq\\n  if (seq) {\\n    if (isModifierKey(name)) { return \\\"handled\\\" }\\n    stopSeq.set(50, function () {\\n      if (cm.state.keySeq == seq) {\\n        cm.state.keySeq = null\\n        cm.display.input.reset()\\n      }\\n    })\\n    name = seq + \\\" \\\" + name\\n  }\\n  var result = lookupKeyForEditor(cm, name, handle)\\n\\n  if (result == \\\"multi\\\")\\n    { cm.state.keySeq = name }\\n  if (result == \\\"handled\\\")\\n    { signalLater(cm, \\\"keyHandled\\\", cm, name, e) }\\n\\n  if (result == \\\"handled\\\" || result == \\\"multi\\\") {\\n    e_preventDefault(e)\\n    restartBlink(cm)\\n  }\\n\\n  if (seq && !result && /\\\\'$/.test(name)) {\\n    e_preventDefault(e)\\n    return true\\n  }\\n  return !!result\\n}\\n\\n// Handle a key from the keydown event.\\nfunction handleKeyBinding(cm, e) {\\n  var name = keyName(e, true)\\n  if (!name) { return false }\\n\\n  if (e.shiftKey && !cm.state.keySeq) {\\n    // First try to resolve full name (including 'Shift-'). Failing\\n    // that, see if there is a cursor-motion command (starting with\\n    // 'go') bound to the keyname without 'Shift-'.\\n    return dispatchKey(cm, \\\"Shift-\\\" + name, e, function (b) { return doHandleBinding(cm, b, true); })\\n        || dispatchKey(cm, name, e, function (b) {\\n             if (typeof b == \\\"string\\\" ? /^go[A-Z]/.test(b) : b.motion)\\n               { return doHandleBinding(cm, b) }\\n           })\\n  } else {\\n    return dispatchKey(cm, name, e, function (b) { return doHandleBinding(cm, b); })\\n  }\\n}\\n\\n// Handle a key from the keypress event\\nfunction handleCharBinding(cm, e, ch) {\\n  return dispatchKey(cm, \\\"'\\\" + ch + \\\"'\\\", e, function (b) { return doHandleBinding(cm, b, true); })\\n}\\n\\nvar lastStoppedKey = null\\nfunction onKeyDown(e) {\\n  var cm = this\\n  cm.curOp.focus = activeElt()\\n  if (signalDOMEvent(cm, e)) { return }\\n  // IE does strange things with escape.\\n  if (ie && ie_version < 11 && e.keyCode == 27) { e.returnValue = false }\\n  var code = e.keyCode\\n  cm.display.shift = code == 16 || e.shiftKey\\n  var handled = handleKeyBinding(cm, e)\\n  if (presto) {\\n    lastStoppedKey = handled ? code : null\\n    // Opera has no cut event... we try to at least catch the key combo\\n    if (!handled && code == 88 && !hasCopyEvent && (mac ? e.metaKey : e.ctrlKey))\\n      { cm.replaceSelection(\\\"\\\", null, \\\"cut\\\") }\\n  }\\n\\n  // Turn mouse into crosshair when Alt is held on Mac.\\n  if (code == 18 && !/\\\\bCodeMirror-crosshair\\\\b/.test(cm.display.lineDiv.className))\\n    { showCrossHair(cm) }\\n}\\n\\nfunction showCrossHair(cm) {\\n  var lineDiv = cm.display.lineDiv\\n  addClass(lineDiv, \\\"CodeMirror-crosshair\\\")\\n\\n  function up(e) {\\n    if (e.keyCode == 18 || !e.altKey) {\\n      rmClass(lineDiv, \\\"CodeMirror-crosshair\\\")\\n      off(document, \\\"keyup\\\", up)\\n      off(document, \\\"mouseover\\\", up)\\n    }\\n  }\\n  on(document, \\\"keyup\\\", up)\\n  on(document, \\\"mouseover\\\", up)\\n}\\n\\nfunction onKeyUp(e) {\\n  if (e.keyCode == 16) { this.doc.sel.shift = false }\\n  signalDOMEvent(this, e)\\n}\\n\\nfunction onKeyPress(e) {\\n  var cm = this\\n  if (eventInWidget(cm.display, e) || signalDOMEvent(cm, e) || e.ctrlKey && !e.altKey || mac && e.metaKey) { return }\\n  var keyCode = e.keyCode, charCode = e.charCode\\n  if (presto && keyCode == lastStoppedKey) {lastStoppedKey = null; e_preventDefault(e); return}\\n  if ((presto && (!e.which || e.which < 10)) && handleKeyBinding(cm, e)) { return }\\n  var ch = String.fromCharCode(charCode == null ? keyCode : charCode)\\n  // Some browsers fire keypress events for backspace\\n  if (ch == \\\"\\\\x08\\\") { return }\\n  if (handleCharBinding(cm, e, ch)) { return }\\n  cm.display.input.onKeyPress(e)\\n}\\n\\n// A mouse down can be a single click, double click, triple click,\\n// start of selection drag, start of text drag, new cursor\\n// (ctrl-click), rectangle drag (alt-drag), or xwin\\n// middle-click-paste. Or it might be a click on something we should\\n// not interfere with, such as a scrollbar or widget.\\nfunction onMouseDown(e) {\\n  var cm = this, display = cm.display\\n  if (signalDOMEvent(cm, e) || display.activeTouch && display.input.supportsTouch()) { return }\\n  display.input.ensurePolled()\\n  display.shift = e.shiftKey\\n\\n  if (eventInWidget(display, e)) {\\n    if (!webkit) {\\n      // Briefly turn off draggability, to allow widgets to do\\n      // normal dragging things.\\n      display.scroller.draggable = false\\n      setTimeout(function () { return display.scroller.draggable = true; }, 100)\\n    }\\n    return\\n  }\\n  if (clickInGutter(cm, e)) { return }\\n  var start = posFromMouse(cm, e)\\n  window.focus()\\n\\n  switch (e_button(e)) {\\n  case 1:\\n    // #3261: make sure, that we're not starting a second selection\\n    if (cm.state.selectingText)\\n      { cm.state.selectingText(e) }\\n    else if (start)\\n      { leftButtonDown(cm, e, start) }\\n    else if (e_target(e) == display.scroller)\\n      { e_preventDefault(e) }\\n    break\\n  case 2:\\n    if (webkit) { cm.state.lastMiddleDown = +new Date }\\n    if (start) { extendSelection(cm.doc, start) }\\n    setTimeout(function () { return display.input.focus(); }, 20)\\n    e_preventDefault(e)\\n    break\\n  case 3:\\n    if (captureRightClick) { onContextMenu(cm, e) }\\n    else { delayBlurEvent(cm) }\\n    break\\n  }\\n}\\n\\nvar lastClick;\\nvar lastDoubleClick;\\nfunction leftButtonDown(cm, e, start) {\\n  if (ie) { setTimeout(bind(ensureFocus, cm), 0) }\\n  else { cm.curOp.focus = activeElt() }\\n\\n  var now = +new Date, type\\n  if (lastDoubleClick && lastDoubleClick.time > now - 400 && cmp(lastDoubleClick.pos, start) == 0) {\\n    type = \\\"triple\\\"\\n  } else if (lastClick && lastClick.time > now - 400 && cmp(lastClick.pos, start) == 0) {\\n    type = \\\"double\\\"\\n    lastDoubleClick = {time: now, pos: start}\\n  } else {\\n    type = \\\"single\\\"\\n    lastClick = {time: now, pos: start}\\n  }\\n\\n  var sel = cm.doc.sel, modifier = mac ? e.metaKey : e.ctrlKey, contained\\n  if (cm.options.dragDrop && dragAndDrop && !cm.isReadOnly() &&\\n      type == \\\"single\\\" && (contained = sel.contains(start)) > -1 &&\\n      (cmp((contained = sel.ranges[contained]).from(), start) < 0 || start.xRel > 0) &&\\n      (cmp(contained.to(), start) > 0 || start.xRel < 0))\\n    { leftButtonStartDrag(cm, e, start, modifier) }\\n  else\\n    { leftButtonSelect(cm, e, start, type, modifier) }\\n}\\n\\n// Start a text drag. When it ends, see if any dragging actually\\n// happen, and treat as a click if it didn't.\\nfunction leftButtonStartDrag(cm, e, start, modifier) {\\n  var display = cm.display, startTime = +new Date\\n  var dragEnd = operation(cm, function (e2) {\\n    if (webkit) { display.scroller.draggable = false }\\n    cm.state.draggingText = false\\n    off(document, \\\"mouseup\\\", dragEnd)\\n    off(display.scroller, \\\"drop\\\", dragEnd)\\n    if (Math.abs(e.clientX - e2.clientX) + Math.abs(e.clientY - e2.clientY) < 10) {\\n      e_preventDefault(e2)\\n      if (!modifier && +new Date - 200 < startTime)\\n        { extendSelection(cm.doc, start) }\\n      // Work around unexplainable focus problem in IE9 (#2127) and Chrome (#3081)\\n      if (webkit || ie && ie_version == 9)\\n        { setTimeout(function () {document.body.focus(); display.input.focus()}, 20) }\\n      else\\n        { display.input.focus() }\\n    }\\n  })\\n  // Let the drag handler handle this.\\n  if (webkit) { display.scroller.draggable = true }\\n  cm.state.draggingText = dragEnd\\n  dragEnd.copy = mac ? e.altKey : e.ctrlKey\\n  // IE's approach to draggable\\n  if (display.scroller.dragDrop) { display.scroller.dragDrop() }\\n  on(document, \\\"mouseup\\\", dragEnd)\\n  on(display.scroller, \\\"drop\\\", dragEnd)\\n}\\n\\n// Normal selection, as opposed to text dragging.\\nfunction leftButtonSelect(cm, e, start, type, addNew) {\\n  var display = cm.display, doc = cm.doc\\n  e_preventDefault(e)\\n\\n  var ourRange, ourIndex, startSel = doc.sel, ranges = startSel.ranges\\n  if (addNew && !e.shiftKey) {\\n    ourIndex = doc.sel.contains(start)\\n    if (ourIndex > -1)\\n      { ourRange = ranges[ourIndex] }\\n    else\\n      { ourRange = new Range(start, start) }\\n  } else {\\n    ourRange = doc.sel.primary()\\n    ourIndex = doc.sel.primIndex\\n  }\\n\\n  if (chromeOS ? e.shiftKey && e.metaKey : e.altKey) {\\n    type = \\\"rect\\\"\\n    if (!addNew) { ourRange = new Range(start, start) }\\n    start = posFromMouse(cm, e, true, true)\\n    ourIndex = -1\\n  } else if (type == \\\"double\\\") {\\n    var word = cm.findWordAt(start)\\n    if (cm.display.shift || doc.extend)\\n      { ourRange = extendRange(doc, ourRange, word.anchor, word.head) }\\n    else\\n      { ourRange = word }\\n  } else if (type == \\\"triple\\\") {\\n    var line = new Range(Pos(start.line, 0), clipPos(doc, Pos(start.line + 1, 0)))\\n    if (cm.display.shift || doc.extend)\\n      { ourRange = extendRange(doc, ourRange, line.anchor, line.head) }\\n    else\\n      { ourRange = line }\\n  } else {\\n    ourRange = extendRange(doc, ourRange, start)\\n  }\\n\\n  if (!addNew) {\\n    ourIndex = 0\\n    setSelection(doc, new Selection([ourRange], 0), sel_mouse)\\n    startSel = doc.sel\\n  } else if (ourIndex == -1) {\\n    ourIndex = ranges.length\\n    setSelection(doc, normalizeSelection(ranges.concat([ourRange]), ourIndex),\\n                 {scroll: false, origin: \\\"*mouse\\\"})\\n  } else if (ranges.length > 1 && ranges[ourIndex].empty() && type == \\\"single\\\" && !e.shiftKey) {\\n    setSelection(doc, normalizeSelection(ranges.slice(0, ourIndex).concat(ranges.slice(ourIndex + 1)), 0),\\n                 {scroll: false, origin: \\\"*mouse\\\"})\\n    startSel = doc.sel\\n  } else {\\n    replaceOneSelection(doc, ourIndex, ourRange, sel_mouse)\\n  }\\n\\n  var lastPos = start\\n  function extendTo(pos) {\\n    if (cmp(lastPos, pos) == 0) { return }\\n    lastPos = pos\\n\\n    if (type == \\\"rect\\\") {\\n      var ranges = [], tabSize = cm.options.tabSize\\n      var startCol = countColumn(getLine(doc, start.line).text, start.ch, tabSize)\\n      var posCol = countColumn(getLine(doc, pos.line).text, pos.ch, tabSize)\\n      var left = Math.min(startCol, posCol), right = Math.max(startCol, posCol)\\n      for (var line = Math.min(start.line, pos.line), end = Math.min(cm.lastLine(), Math.max(start.line, pos.line));\\n           line <= end; line++) {\\n        var text = getLine(doc, line).text, leftPos = findColumn(text, left, tabSize)\\n        if (left == right)\\n          { ranges.push(new Range(Pos(line, leftPos), Pos(line, leftPos))) }\\n        else if (text.length > leftPos)\\n          { ranges.push(new Range(Pos(line, leftPos), Pos(line, findColumn(text, right, tabSize)))) }\\n      }\\n      if (!ranges.length) { ranges.push(new Range(start, start)) }\\n      setSelection(doc, normalizeSelection(startSel.ranges.slice(0, ourIndex).concat(ranges), ourIndex),\\n                   {origin: \\\"*mouse\\\", scroll: false})\\n      cm.scrollIntoView(pos)\\n    } else {\\n      var oldRange = ourRange\\n      var anchor = oldRange.anchor, head = pos\\n      if (type != \\\"single\\\") {\\n        var range\\n        if (type == \\\"double\\\")\\n          { range = cm.findWordAt(pos) }\\n        else\\n          { range = new Range(Pos(pos.line, 0), clipPos(doc, Pos(pos.line + 1, 0))) }\\n        if (cmp(range.anchor, anchor) > 0) {\\n          head = range.head\\n          anchor = minPos(oldRange.from(), range.anchor)\\n        } else {\\n          head = range.anchor\\n          anchor = maxPos(oldRange.to(), range.head)\\n        }\\n      }\\n      var ranges$1 = startSel.ranges.slice(0)\\n      ranges$1[ourIndex] = new Range(clipPos(doc, anchor), head)\\n      setSelection(doc, normalizeSelection(ranges$1, ourIndex), sel_mouse)\\n    }\\n  }\\n\\n  var editorSize = display.wrapper.getBoundingClientRect()\\n  // Used to ensure timeout re-tries don't fire when another extend\\n  // happened in the meantime (clearTimeout isn't reliable -- at\\n  // least on Chrome, the timeouts still happen even when cleared,\\n  // if the clear happens after their scheduled firing time).\\n  var counter = 0\\n\\n  function extend(e) {\\n    var curCount = ++counter\\n    var cur = posFromMouse(cm, e, true, type == \\\"rect\\\")\\n    if (!cur) { return }\\n    if (cmp(cur, lastPos) != 0) {\\n      cm.curOp.focus = activeElt()\\n      extendTo(cur)\\n      var visible = visibleLines(display, doc)\\n      if (cur.line >= visible.to || cur.line < visible.from)\\n        { setTimeout(operation(cm, function () {if (counter == curCount) { extend(e) }}), 150) }\\n    } else {\\n      var outside = e.clientY < editorSize.top ? -20 : e.clientY > editorSize.bottom ? 20 : 0\\n      if (outside) { setTimeout(operation(cm, function () {\\n        if (counter != curCount) { return }\\n        display.scroller.scrollTop += outside\\n        extend(e)\\n      }), 50) }\\n    }\\n  }\\n\\n  function done(e) {\\n    cm.state.selectingText = false\\n    counter = Infinity\\n    e_preventDefault(e)\\n    display.input.focus()\\n    off(document, \\\"mousemove\\\", move)\\n    off(document, \\\"mouseup\\\", up)\\n    doc.history.lastSelOrigin = null\\n  }\\n\\n  var move = operation(cm, function (e) {\\n    if (!e_button(e)) { done(e) }\\n    else { extend(e) }\\n  })\\n  var up = operation(cm, done)\\n  cm.state.selectingText = up\\n  on(document, \\\"mousemove\\\", move)\\n  on(document, \\\"mouseup\\\", up)\\n}\\n\\n\\n// Determines whether an event happened in the gutter, and fires the\\n// handlers for the corresponding event.\\nfunction gutterEvent(cm, e, type, prevent) {\\n  var mX, mY\\n  try { mX = e.clientX; mY = e.clientY }\\n  catch(e) { return false }\\n  if (mX >= Math.floor(cm.display.gutters.getBoundingClientRect().right)) { return false }\\n  if (prevent) { e_preventDefault(e) }\\n\\n  var display = cm.display\\n  var lineBox = display.lineDiv.getBoundingClientRect()\\n\\n  if (mY > lineBox.bottom || !hasHandler(cm, type)) { return e_defaultPrevented(e) }\\n  mY -= lineBox.top - display.viewOffset\\n\\n  for (var i = 0; i < cm.options.gutters.length; ++i) {\\n    var g = display.gutters.childNodes[i]\\n    if (g && g.getBoundingClientRect().right >= mX) {\\n      var line = lineAtHeight(cm.doc, mY)\\n      var gutter = cm.options.gutters[i]\\n      signal(cm, type, cm, line, gutter, e)\\n      return e_defaultPrevented(e)\\n    }\\n  }\\n}\\n\\nfunction clickInGutter(cm, e) {\\n  return gutterEvent(cm, e, \\\"gutterClick\\\", true)\\n}\\n\\n// CONTEXT MENU HANDLING\\n\\n// To make the context menu work, we need to briefly unhide the\\n// textarea (making it as unobtrusive as possible) to let the\\n// right-click take effect on it.\\nfunction onContextMenu(cm, e) {\\n  if (eventInWidget(cm.display, e) || contextMenuInGutter(cm, e)) { return }\\n  if (signalDOMEvent(cm, e, \\\"contextmenu\\\")) { return }\\n  cm.display.input.onContextMenu(e)\\n}\\n\\nfunction contextMenuInGutter(cm, e) {\\n  if (!hasHandler(cm, \\\"gutterContextMenu\\\")) { return false }\\n  return gutterEvent(cm, e, \\\"gutterContextMenu\\\", false)\\n}\\n\\nfunction themeChanged(cm) {\\n  cm.display.wrapper.className = cm.display.wrapper.className.replace(/\\\\s*cm-s-\\\\S+/g, \\\"\\\") +\\n    cm.options.theme.replace(/(^|\\\\s)\\\\s*/g, \\\" cm-s-\\\")\\n  clearCaches(cm)\\n}\\n\\nvar Init = {toString: function(){return \\\"CodeMirror.Init\\\"}}\\n\\nvar defaults = {}\\nvar optionHandlers = {}\\n\\nfunction defineOptions(CodeMirror) {\\n  var optionHandlers = CodeMirror.optionHandlers\\n\\n  function option(name, deflt, handle, notOnInit) {\\n    CodeMirror.defaults[name] = deflt\\n    if (handle) { optionHandlers[name] =\\n      notOnInit ? function (cm, val, old) {if (old != Init) { handle(cm, val, old) }} : handle }\\n  }\\n\\n  CodeMirror.defineOption = option\\n\\n  // Passed to option handlers when there is no old value.\\n  CodeMirror.Init = Init\\n\\n  // These two are, on init, called from the constructor because they\\n  // have to be initialized before the editor can start at all.\\n  option(\\\"value\\\", \\\"\\\", function (cm, val) { return cm.setValue(val); }, true)\\n  option(\\\"mode\\\", null, function (cm, val) {\\n    cm.doc.modeOption = val\\n    loadMode(cm)\\n  }, true)\\n\\n  option(\\\"indentUnit\\\", 2, loadMode, true)\\n  option(\\\"indentWithTabs\\\", false)\\n  option(\\\"smartIndent\\\", true)\\n  option(\\\"tabSize\\\", 4, function (cm) {\\n    resetModeState(cm)\\n    clearCaches(cm)\\n    regChange(cm)\\n  }, true)\\n  option(\\\"lineSeparator\\\", null, function (cm, val) {\\n    cm.doc.lineSep = val\\n    if (!val) { return }\\n    var newBreaks = [], lineNo = cm.doc.first\\n    cm.doc.iter(function (line) {\\n      for (var pos = 0;;) {\\n        var found = line.text.indexOf(val, pos)\\n        if (found == -1) { break }\\n        pos = found + val.length\\n        newBreaks.push(Pos(lineNo, found))\\n      }\\n      lineNo++\\n    })\\n    for (var i = newBreaks.length - 1; i >= 0; i--)\\n      { replaceRange(cm.doc, val, newBreaks[i], Pos(newBreaks[i].line, newBreaks[i].ch + val.length)) }\\n  })\\n  option(\\\"specialChars\\\", /[\\\\u0000-\\\\u001f\\\\u007f\\\\u00ad\\\\u061c\\\\u200b-\\\\u200f\\\\u2028\\\\u2029\\\\ufeff]/g, function (cm, val, old) {\\n    cm.state.specialChars = new RegExp(val.source + (val.test(\\\"\\\\t\\\") ? \\\"\\\" : \\\"|\\\\t\\\"), \\\"g\\\")\\n    if (old != Init) { cm.refresh() }\\n  })\\n  option(\\\"specialCharPlaceholder\\\", defaultSpecialCharPlaceholder, function (cm) { return cm.refresh(); }, true)\\n  option(\\\"electricChars\\\", true)\\n  option(\\\"inputStyle\\\", mobile ? \\\"contenteditable\\\" : \\\"textarea\\\", function () {\\n    throw new Error(\\\"inputStyle can not (yet) be changed in a running editor\\\") // FIXME\\n  }, true)\\n  option(\\\"spellcheck\\\", false, function (cm, val) { return cm.getInputField().spellcheck = val; }, true)\\n  option(\\\"rtlMoveVisually\\\", !windows)\\n  option(\\\"wholeLineUpdateBefore\\\", true)\\n\\n  option(\\\"theme\\\", \\\"default\\\", function (cm) {\\n    themeChanged(cm)\\n    guttersChanged(cm)\\n  }, true)\\n  option(\\\"keyMap\\\", \\\"default\\\", function (cm, val, old) {\\n    var next = getKeyMap(val)\\n    var prev = old != Init && getKeyMap(old)\\n    if (prev && prev.detach) { prev.detach(cm, next) }\\n    if (next.attach) { next.attach(cm, prev || null) }\\n  })\\n  option(\\\"extraKeys\\\", null)\\n\\n  option(\\\"lineWrapping\\\", false, wrappingChanged, true)\\n  option(\\\"gutters\\\", [], function (cm) {\\n    setGuttersForLineNumbers(cm.options)\\n    guttersChanged(cm)\\n  }, true)\\n  option(\\\"fixedGutter\\\", true, function (cm, val) {\\n    cm.display.gutters.style.left = val ? compensateForHScroll(cm.display) + \\\"px\\\" : \\\"0\\\"\\n    cm.refresh()\\n  }, true)\\n  option(\\\"coverGutterNextToScrollbar\\\", false, function (cm) { return updateScrollbars(cm); }, true)\\n  option(\\\"scrollbarStyle\\\", \\\"native\\\", function (cm) {\\n    initScrollbars(cm)\\n    updateScrollbars(cm)\\n    cm.display.scrollbars.setScrollTop(cm.doc.scrollTop)\\n    cm.display.scrollbars.setScrollLeft(cm.doc.scrollLeft)\\n  }, true)\\n  option(\\\"lineNumbers\\\", false, function (cm) {\\n    setGuttersForLineNumbers(cm.options)\\n    guttersChanged(cm)\\n  }, true)\\n  option(\\\"firstLineNumber\\\", 1, guttersChanged, true)\\n  option(\\\"lineNumberFormatter\\\", function (integer) { return integer; }, guttersChanged, true)\\n  option(\\\"showCursorWhenSelecting\\\", false, updateSelection, true)\\n\\n  option(\\\"resetSelectionOnContextMenu\\\", true)\\n  option(\\\"lineWiseCopyCut\\\", true)\\n\\n  option(\\\"readOnly\\\", false, function (cm, val) {\\n    if (val == \\\"nocursor\\\") {\\n      onBlur(cm)\\n      cm.display.input.blur()\\n      cm.display.disabled = true\\n    } else {\\n      cm.display.disabled = false\\n    }\\n    cm.display.input.readOnlyChanged(val)\\n  })\\n  option(\\\"disableInput\\\", false, function (cm, val) {if (!val) { cm.display.input.reset() }}, true)\\n  option(\\\"dragDrop\\\", true, dragDropChanged)\\n  option(\\\"allowDropFileTypes\\\", null)\\n\\n  option(\\\"cursorBlinkRate\\\", 530)\\n  option(\\\"cursorScrollMargin\\\", 0)\\n  option(\\\"cursorHeight\\\", 1, updateSelection, true)\\n  option(\\\"singleCursorHeightPerLine\\\", true, updateSelection, true)\\n  option(\\\"workTime\\\", 100)\\n  option(\\\"workDelay\\\", 100)\\n  option(\\\"flattenSpans\\\", true, resetModeState, true)\\n  option(\\\"addModeClass\\\", false, resetModeState, true)\\n  option(\\\"pollInterval\\\", 100)\\n  option(\\\"undoDepth\\\", 200, function (cm, val) { return cm.doc.history.undoDepth = val; })\\n  option(\\\"historyEventDelay\\\", 1250)\\n  option(\\\"viewportMargin\\\", 10, function (cm) { return cm.refresh(); }, true)\\n  option(\\\"maxHighlightLength\\\", 10000, resetModeState, true)\\n  option(\\\"moveInputWithCursor\\\", true, function (cm, val) {\\n    if (!val) { cm.display.input.resetPosition() }\\n  })\\n\\n  option(\\\"tabindex\\\", null, function (cm, val) { return cm.display.input.getField().tabIndex = val || \\\"\\\"; })\\n  option(\\\"autofocus\\\", null)\\n}\\n\\nfunction guttersChanged(cm) {\\n  updateGutters(cm)\\n  regChange(cm)\\n  alignHorizontally(cm)\\n}\\n\\nfunction dragDropChanged(cm, value, old) {\\n  var wasOn = old && old != Init\\n  if (!value != !wasOn) {\\n    var funcs = cm.display.dragFunctions\\n    var toggle = value ? on : off\\n    toggle(cm.display.scroller, \\\"dragstart\\\", funcs.start)\\n    toggle(cm.display.scroller, \\\"dragenter\\\", funcs.enter)\\n    toggle(cm.display.scroller, \\\"dragover\\\", funcs.over)\\n    toggle(cm.display.scroller, \\\"dragleave\\\", funcs.leave)\\n    toggle(cm.display.scroller, \\\"drop\\\", funcs.drop)\\n  }\\n}\\n\\nfunction wrappingChanged(cm) {\\n  if (cm.options.lineWrapping) {\\n    addClass(cm.display.wrapper, \\\"CodeMirror-wrap\\\")\\n    cm.display.sizer.style.minWidth = \\\"\\\"\\n    cm.display.sizerWidth = null\\n  } else {\\n    rmClass(cm.display.wrapper, \\\"CodeMirror-wrap\\\")\\n    findMaxLine(cm)\\n  }\\n  estimateLineHeights(cm)\\n  regChange(cm)\\n  clearCaches(cm)\\n  setTimeout(function () { return updateScrollbars(cm); }, 100)\\n}\\n\\n// A CodeMirror instance represents an editor. This is the object\\n// that user code is usually dealing with.\\n\\nfunction CodeMirror(place, options) {\\n  var this$1 = this;\\n\\n  if (!(this instanceof CodeMirror)) { return new CodeMirror(place, options) }\\n\\n  this.options = options = options ? copyObj(options) : {}\\n  // Determine effective options based on given values and defaults.\\n  copyObj(defaults, options, false)\\n  setGuttersForLineNumbers(options)\\n\\n  var doc = options.value\\n  if (typeof doc == \\\"string\\\") { doc = new Doc(doc, options.mode, null, options.lineSeparator) }\\n  this.doc = doc\\n\\n  var input = new CodeMirror.inputStyles[options.inputStyle](this)\\n  var display = this.display = new Display(place, doc, input)\\n  display.wrapper.CodeMirror = this\\n  updateGutters(this)\\n  themeChanged(this)\\n  if (options.lineWrapping)\\n    { this.display.wrapper.className += \\\" CodeMirror-wrap\\\" }\\n  initScrollbars(this)\\n\\n  this.state = {\\n    keyMaps: [],  // stores maps added by addKeyMap\\n    overlays: [], // highlighting overlays, as added by addOverlay\\n    modeGen: 0,   // bumped when mode/overlay changes, used to invalidate highlighting info\\n    overwrite: false,\\n    delayingBlurEvent: false,\\n    focused: false,\\n    suppressEdits: false, // used to disable editing during key handlers when in readOnly mode\\n    pasteIncoming: false, cutIncoming: false, // help recognize paste/cut edits in input.poll\\n    selectingText: false,\\n    draggingText: false,\\n    highlight: new Delayed(), // stores highlight worker timeout\\n    keySeq: null,  // Unfinished key sequence\\n    specialChars: null\\n  }\\n\\n  if (options.autofocus && !mobile) { display.input.focus() }\\n\\n  // Override magic textarea content restore that IE sometimes does\\n  // on our hidden textarea on reload\\n  if (ie && ie_version < 11) { setTimeout(function () { return this$1.display.input.reset(true); }, 20) }\\n\\n  registerEventHandlers(this)\\n  ensureGlobalHandlers()\\n\\n  startOperation(this)\\n  this.curOp.forceUpdate = true\\n  attachDoc(this, doc)\\n\\n  if ((options.autofocus && !mobile) || this.hasFocus())\\n    { setTimeout(bind(onFocus, this), 20) }\\n  else\\n    { onBlur(this) }\\n\\n  for (var opt in optionHandlers) { if (optionHandlers.hasOwnProperty(opt))\\n    { optionHandlers[opt](this$1, options[opt], Init) } }\\n  maybeUpdateLineNumberWidth(this)\\n  if (options.finishInit) { options.finishInit(this) }\\n  for (var i = 0; i < initHooks.length; ++i) { initHooks[i](this$1) }\\n  endOperation(this)\\n  // Suppress optimizelegibility in Webkit, since it breaks text\\n  // measuring on line wrapping boundaries.\\n  if (webkit && options.lineWrapping &&\\n      getComputedStyle(display.lineDiv).textRendering == \\\"optimizelegibility\\\")\\n    { display.lineDiv.style.textRendering = \\\"auto\\\" }\\n}\\n\\n// The default configuration options.\\nCodeMirror.defaults = defaults\\n// Functions to run when options are changed.\\nCodeMirror.optionHandlers = optionHandlers\\n\\n// Attach the necessary event handlers when initializing the editor\\nfunction registerEventHandlers(cm) {\\n  var d = cm.display\\n  on(d.scroller, \\\"mousedown\\\", operation(cm, onMouseDown))\\n  // Older IE's will not fire a second mousedown for a double click\\n  if (ie && ie_version < 11)\\n    { on(d.scroller, \\\"dblclick\\\", operation(cm, function (e) {\\n      if (signalDOMEvent(cm, e)) { return }\\n      var pos = posFromMouse(cm, e)\\n      if (!pos || clickInGutter(cm, e) || eventInWidget(cm.display, e)) { return }\\n      e_preventDefault(e)\\n      var word = cm.findWordAt(pos)\\n      extendSelection(cm.doc, word.anchor, word.head)\\n    })) }\\n  else\\n    { on(d.scroller, \\\"dblclick\\\", function (e) { return signalDOMEvent(cm, e) || e_preventDefault(e); }) }\\n  // Some browsers fire contextmenu *after* opening the menu, at\\n  // which point we can't mess with it anymore. Context menu is\\n  // handled in onMouseDown for these browsers.\\n  if (!captureRightClick) { on(d.scroller, \\\"contextmenu\\\", function (e) { return onContextMenu(cm, e); }) }\\n\\n  // Used to suppress mouse event handling when a touch happens\\n  var touchFinished, prevTouch = {end: 0}\\n  function finishTouch() {\\n    if (d.activeTouch) {\\n      touchFinished = setTimeout(function () { return d.activeTouch = null; }, 1000)\\n      prevTouch = d.activeTouch\\n      prevTouch.end = +new Date\\n    }\\n  }\\n  function isMouseLikeTouchEvent(e) {\\n    if (e.touches.length != 1) { return false }\\n    var touch = e.touches[0]\\n    return touch.radiusX <= 1 && touch.radiusY <= 1\\n  }\\n  function farAway(touch, other) {\\n    if (other.left == null) { return true }\\n    var dx = other.left - touch.left, dy = other.top - touch.top\\n    return dx * dx + dy * dy > 20 * 20\\n  }\\n  on(d.scroller, \\\"touchstart\\\", function (e) {\\n    if (!signalDOMEvent(cm, e) && !isMouseLikeTouchEvent(e)) {\\n      d.input.ensurePolled()\\n      clearTimeout(touchFinished)\\n      var now = +new Date\\n      d.activeTouch = {start: now, moved: false,\\n                       prev: now - prevTouch.end <= 300 ? prevTouch : null}\\n      if (e.touches.length == 1) {\\n        d.activeTouch.left = e.touches[0].pageX\\n        d.activeTouch.top = e.touches[0].pageY\\n      }\\n    }\\n  })\\n  on(d.scroller, \\\"touchmove\\\", function () {\\n    if (d.activeTouch) { d.activeTouch.moved = true }\\n  })\\n  on(d.scroller, \\\"touchend\\\", function (e) {\\n    var touch = d.activeTouch\\n    if (touch && !eventInWidget(d, e) && touch.left != null &&\\n        !touch.moved && new Date - touch.start < 300) {\\n      var pos = cm.coordsChar(d.activeTouch, \\\"page\\\"), range\\n      if (!touch.prev || farAway(touch, touch.prev)) // Single tap\\n        { range = new Range(pos, pos) }\\n      else if (!touch.prev.prev || farAway(touch, touch.prev.prev)) // Double tap\\n        { range = cm.findWordAt(pos) }\\n      else // Triple tap\\n        { range = new Range(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0))) }\\n      cm.setSelection(range.anchor, range.head)\\n      cm.focus()\\n      e_preventDefault(e)\\n    }\\n    finishTouch()\\n  })\\n  on(d.scroller, \\\"touchcancel\\\", finishTouch)\\n\\n  // Sync scrolling between fake scrollbars and real scrollable\\n  // area, ensure viewport is updated when scrolling.\\n  on(d.scroller, \\\"scroll\\\", function () {\\n    if (d.scroller.clientHeight) {\\n      setScrollTop(cm, d.scroller.scrollTop)\\n      setScrollLeft(cm, d.scroller.scrollLeft, true)\\n      signal(cm, \\\"scroll\\\", cm)\\n    }\\n  })\\n\\n  // Listen to wheel events in order to try and update the viewport on time.\\n  on(d.scroller, \\\"mousewheel\\\", function (e) { return onScrollWheel(cm, e); })\\n  on(d.scroller, \\\"DOMMouseScroll\\\", function (e) { return onScrollWheel(cm, e); })\\n\\n  // Prevent wrapper from ever scrolling\\n  on(d.wrapper, \\\"scroll\\\", function () { return d.wrapper.scrollTop = d.wrapper.scrollLeft = 0; })\\n\\n  d.dragFunctions = {\\n    enter: function (e) {if (!signalDOMEvent(cm, e)) { e_stop(e) }},\\n    over: function (e) {if (!signalDOMEvent(cm, e)) { onDragOver(cm, e); e_stop(e) }},\\n    start: function (e) { return onDragStart(cm, e); },\\n    drop: operation(cm, onDrop),\\n    leave: function (e) {if (!signalDOMEvent(cm, e)) { clearDragCursor(cm) }}\\n  }\\n\\n  var inp = d.input.getField()\\n  on(inp, \\\"keyup\\\", function (e) { return onKeyUp.call(cm, e); })\\n  on(inp, \\\"keydown\\\", operation(cm, onKeyDown))\\n  on(inp, \\\"keypress\\\", operation(cm, onKeyPress))\\n  on(inp, \\\"focus\\\", function (e) { return onFocus(cm, e); })\\n  on(inp, \\\"blur\\\", function (e) { return onBlur(cm, e); })\\n}\\n\\nvar initHooks = []\\nCodeMirror.defineInitHook = function (f) { return initHooks.push(f); }\\n\\n// Indent the given line. The how parameter can be \\\"smart\\\",\\n// \\\"add\\\"/null, \\\"subtract\\\", or \\\"prev\\\". When aggressive is false\\n// (typically set to true for forced single-line indents), empty\\n// lines are not indented, and places where the mode returns Pass\\n// are left alone.\\nfunction indentLine(cm, n, how, aggressive) {\\n  var doc = cm.doc, state\\n  if (how == null) { how = \\\"add\\\" }\\n  if (how == \\\"smart\\\") {\\n    // Fall back to \\\"prev\\\" when the mode doesn't have an indentation\\n    // method.\\n    if (!doc.mode.indent) { how = \\\"prev\\\" }\\n    else { state = getStateBefore(cm, n) }\\n  }\\n\\n  var tabSize = cm.options.tabSize\\n  var line = getLine(doc, n), curSpace = countColumn(line.text, null, tabSize)\\n  if (line.stateAfter) { line.stateAfter = null }\\n  var curSpaceString = line.text.match(/^\\\\s*/)[0], indentation\\n  if (!aggressive && !/\\\\S/.test(line.text)) {\\n    indentation = 0\\n    how = \\\"not\\\"\\n  } else if (how == \\\"smart\\\") {\\n    indentation = doc.mode.indent(state, line.text.slice(curSpaceString.length), line.text)\\n    if (indentation == Pass || indentation > 150) {\\n      if (!aggressive) { return }\\n      how = \\\"prev\\\"\\n    }\\n  }\\n  if (how == \\\"prev\\\") {\\n    if (n > doc.first) { indentation = countColumn(getLine(doc, n-1).text, null, tabSize) }\\n    else { indentation = 0 }\\n  } else if (how == \\\"add\\\") {\\n    indentation = curSpace + cm.options.indentUnit\\n  } else if (how == \\\"subtract\\\") {\\n    indentation = curSpace - cm.options.indentUnit\\n  } else if (typeof how == \\\"number\\\") {\\n    indentation = curSpace + how\\n  }\\n  indentation = Math.max(0, indentation)\\n\\n  var indentString = \\\"\\\", pos = 0\\n  if (cm.options.indentWithTabs)\\n    { for (var i = Math.floor(indentation / tabSize); i; --i) {pos += tabSize; indentString += \\\"\\\\t\\\"} }\\n  if (pos < indentation) { indentString += spaceStr(indentation - pos) }\\n\\n  if (indentString != curSpaceString) {\\n    replaceRange(doc, indentString, Pos(n, 0), Pos(n, curSpaceString.length), \\\"+input\\\")\\n    line.stateAfter = null\\n    return true\\n  } else {\\n    // Ensure that, if the cursor was in the whitespace at the start\\n    // of the line, it is moved to the end of that space.\\n    for (var i$1 = 0; i$1 < doc.sel.ranges.length; i$1++) {\\n      var range = doc.sel.ranges[i$1]\\n      if (range.head.line == n && range.head.ch < curSpaceString.length) {\\n        var pos$1 = Pos(n, curSpaceString.length)\\n        replaceOneSelection(doc, i$1, new Range(pos$1, pos$1))\\n        break\\n      }\\n    }\\n  }\\n}\\n\\n// This will be set to a {lineWise: bool, text: [string]} object, so\\n// that, when pasting, we know what kind of selections the copied\\n// text was made out of.\\nvar lastCopied = null\\n\\nfunction setLastCopied(newLastCopied) {\\n  lastCopied = newLastCopied\\n}\\n\\nfunction applyTextInput(cm, inserted, deleted, sel, origin) {\\n  var doc = cm.doc\\n  cm.display.shift = false\\n  if (!sel) { sel = doc.sel }\\n\\n  var paste = cm.state.pasteIncoming || origin == \\\"paste\\\"\\n  var textLines = splitLinesAuto(inserted), multiPaste = null\\n  // When pasing N lines into N selections, insert one line per selection\\n  if (paste && sel.ranges.length > 1) {\\n    if (lastCopied && lastCopied.text.join(\\\"\\\\n\\\") == inserted) {\\n      if (sel.ranges.length % lastCopied.text.length == 0) {\\n        multiPaste = []\\n        for (var i = 0; i < lastCopied.text.length; i++)\\n          { multiPaste.push(doc.splitLines(lastCopied.text[i])) }\\n      }\\n    } else if (textLines.length == sel.ranges.length) {\\n      multiPaste = map(textLines, function (l) { return [l]; })\\n    }\\n  }\\n\\n  var updateInput\\n  // Normal behavior is to insert the new text into every selection\\n  for (var i$1 = sel.ranges.length - 1; i$1 >= 0; i$1--) {\\n    var range = sel.ranges[i$1]\\n    var from = range.from(), to = range.to()\\n    if (range.empty()) {\\n      if (deleted && deleted > 0) // Handle deletion\\n        { from = Pos(from.line, from.ch - deleted) }\\n      else if (cm.state.overwrite && !paste) // Handle overwrite\\n        { to = Pos(to.line, Math.min(getLine(doc, to.line).text.length, to.ch + lst(textLines).length)) }\\n      else if (lastCopied && lastCopied.lineWise && lastCopied.text.join(\\\"\\\\n\\\") == inserted)\\n        { from = to = Pos(from.line, 0) }\\n    }\\n    updateInput = cm.curOp.updateInput\\n    var changeEvent = {from: from, to: to, text: multiPaste ? multiPaste[i$1 % multiPaste.length] : textLines,\\n                       origin: origin || (paste ? \\\"paste\\\" : cm.state.cutIncoming ? \\\"cut\\\" : \\\"+input\\\")}\\n    makeChange(cm.doc, changeEvent)\\n    signalLater(cm, \\\"inputRead\\\", cm, changeEvent)\\n  }\\n  if (inserted && !paste)\\n    { triggerElectric(cm, inserted) }\\n\\n  ensureCursorVisible(cm)\\n  cm.curOp.updateInput = updateInput\\n  cm.curOp.typing = true\\n  cm.state.pasteIncoming = cm.state.cutIncoming = false\\n}\\n\\nfunction handlePaste(e, cm) {\\n  var pasted = e.clipboardData && e.clipboardData.getData(\\\"Text\\\")\\n  if (pasted) {\\n    e.preventDefault()\\n    if (!cm.isReadOnly() && !cm.options.disableInput)\\n      { runInOp(cm, function () { return applyTextInput(cm, pasted, 0, null, \\\"paste\\\"); }) }\\n    return true\\n  }\\n}\\n\\nfunction triggerElectric(cm, inserted) {\\n  // When an 'electric' character is inserted, immediately trigger a reindent\\n  if (!cm.options.electricChars || !cm.options.smartIndent) { return }\\n  var sel = cm.doc.sel\\n\\n  for (var i = sel.ranges.length - 1; i >= 0; i--) {\\n    var range = sel.ranges[i]\\n    if (range.head.ch > 100 || (i && sel.ranges[i - 1].head.line == range.head.line)) { continue }\\n    var mode = cm.getModeAt(range.head)\\n    var indented = false\\n    if (mode.electricChars) {\\n      for (var j = 0; j < mode.electricChars.length; j++)\\n        { if (inserted.indexOf(mode.electricChars.charAt(j)) > -1) {\\n          indented = indentLine(cm, range.head.line, \\\"smart\\\")\\n          break\\n        } }\\n    } else if (mode.electricInput) {\\n      if (mode.electricInput.test(getLine(cm.doc, range.head.line).text.slice(0, range.head.ch)))\\n        { indented = indentLine(cm, range.head.line, \\\"smart\\\") }\\n    }\\n    if (indented) { signalLater(cm, \\\"electricInput\\\", cm, range.head.line) }\\n  }\\n}\\n\\nfunction copyableRanges(cm) {\\n  var text = [], ranges = []\\n  for (var i = 0; i < cm.doc.sel.ranges.length; i++) {\\n    var line = cm.doc.sel.ranges[i].head.line\\n    var lineRange = {anchor: Pos(line, 0), head: Pos(line + 1, 0)}\\n    ranges.push(lineRange)\\n    text.push(cm.getRange(lineRange.anchor, lineRange.head))\\n  }\\n  return {text: text, ranges: ranges}\\n}\\n\\nfunction disableBrowserMagic(field, spellcheck) {\\n  field.setAttribute(\\\"autocorrect\\\", \\\"off\\\")\\n  field.setAttribute(\\\"autocapitalize\\\", \\\"off\\\")\\n  field.setAttribute(\\\"spellcheck\\\", !!spellcheck)\\n}\\n\\nfunction hiddenTextarea() {\\n  var te = elt(\\\"textarea\\\", null, null, \\\"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none\\\")\\n  var div = elt(\\\"div\\\", [te], null, \\\"overflow: hidden; position: relative; width: 3px; height: 0px;\\\")\\n  // The textarea is kept positioned near the cursor to prevent the\\n  // fact that it'll be scrolled into view on input from scrolling\\n  // our fake cursor out of view. On webkit, when wrap=off, paste is\\n  // very slow. So make the area wide instead.\\n  if (webkit) { te.style.width = \\\"1000px\\\" }\\n  else { te.setAttribute(\\\"wrap\\\", \\\"off\\\") }\\n  // If border: 0; -- iOS fails to open keyboard (issue #1287)\\n  if (ios) { te.style.border = \\\"1px solid black\\\" }\\n  disableBrowserMagic(te)\\n  return div\\n}\\n\\n// The publicly visible API. Note that methodOp(f) means\\n// 'wrap f in an operation, performed on its `this` parameter'.\\n\\n// This is not the complete set of editor methods. Most of the\\n// methods defined on the Doc type are also injected into\\n// CodeMirror.prototype, for backwards compatibility and\\n// convenience.\\n\\nfunction addEditorMethods(CodeMirror) {\\n  var optionHandlers = CodeMirror.optionHandlers\\n\\n  var helpers = CodeMirror.helpers = {}\\n\\n  CodeMirror.prototype = {\\n    constructor: CodeMirror,\\n    focus: function(){window.focus(); this.display.input.focus()},\\n\\n    setOption: function(option, value) {\\n      var options = this.options, old = options[option]\\n      if (options[option] == value && option != \\\"mode\\\") { return }\\n      options[option] = value\\n      if (optionHandlers.hasOwnProperty(option))\\n        { operation(this, optionHandlers[option])(this, value, old) }\\n      signal(this, \\\"optionChange\\\", this, option)\\n    },\\n\\n    getOption: function(option) {return this.options[option]},\\n    getDoc: function() {return this.doc},\\n\\n    addKeyMap: function(map, bottom) {\\n      this.state.keyMaps[bottom ? \\\"push\\\" : \\\"unshift\\\"](getKeyMap(map))\\n    },\\n    removeKeyMap: function(map) {\\n      var maps = this.state.keyMaps\\n      for (var i = 0; i < maps.length; ++i)\\n        { if (maps[i] == map || maps[i].name == map) {\\n          maps.splice(i, 1)\\n          return true\\n        } }\\n    },\\n\\n    addOverlay: methodOp(function(spec, options) {\\n      var mode = spec.token ? spec : CodeMirror.getMode(this.options, spec)\\n      if (mode.startState) { throw new Error(\\\"Overlays may not be stateful.\\\") }\\n      insertSorted(this.state.overlays,\\n                   {mode: mode, modeSpec: spec, opaque: options && options.opaque,\\n                    priority: (options && options.priority) || 0},\\n                   function (overlay) { return overlay.priority; })\\n      this.state.modeGen++\\n      regChange(this)\\n    }),\\n    removeOverlay: methodOp(function(spec) {\\n      var this$1 = this;\\n\\n      var overlays = this.state.overlays\\n      for (var i = 0; i < overlays.length; ++i) {\\n        var cur = overlays[i].modeSpec\\n        if (cur == spec || typeof spec == \\\"string\\\" && cur.name == spec) {\\n          overlays.splice(i, 1)\\n          this$1.state.modeGen++\\n          regChange(this$1)\\n          return\\n        }\\n      }\\n    }),\\n\\n    indentLine: methodOp(function(n, dir, aggressive) {\\n      if (typeof dir != \\\"string\\\" && typeof dir != \\\"number\\\") {\\n        if (dir == null) { dir = this.options.smartIndent ? \\\"smart\\\" : \\\"prev\\\" }\\n        else { dir = dir ? \\\"add\\\" : \\\"subtract\\\" }\\n      }\\n      if (isLine(this.doc, n)) { indentLine(this, n, dir, aggressive) }\\n    }),\\n    indentSelection: methodOp(function(how) {\\n      var this$1 = this;\\n\\n      var ranges = this.doc.sel.ranges, end = -1\\n      for (var i = 0; i < ranges.length; i++) {\\n        var range = ranges[i]\\n        if (!range.empty()) {\\n          var from = range.from(), to = range.to()\\n          var start = Math.max(end, from.line)\\n          end = Math.min(this$1.lastLine(), to.line - (to.ch ? 0 : 1)) + 1\\n          for (var j = start; j < end; ++j)\\n            { indentLine(this$1, j, how) }\\n          var newRanges = this$1.doc.sel.ranges\\n          if (from.ch == 0 && ranges.length == newRanges.length && newRanges[i].from().ch > 0)\\n            { replaceOneSelection(this$1.doc, i, new Range(from, newRanges[i].to()), sel_dontScroll) }\\n        } else if (range.head.line > end) {\\n          indentLine(this$1, range.head.line, how, true)\\n          end = range.head.line\\n          if (i == this$1.doc.sel.primIndex) { ensureCursorVisible(this$1) }\\n        }\\n      }\\n    }),\\n\\n    // Fetch the parser token for a given character. Useful for hacks\\n    // that want to inspect the mode state (say, for completion).\\n    getTokenAt: function(pos, precise) {\\n      return takeToken(this, pos, precise)\\n    },\\n\\n    getLineTokens: function(line, precise) {\\n      return takeToken(this, Pos(line), precise, true)\\n    },\\n\\n    getTokenTypeAt: function(pos) {\\n      pos = clipPos(this.doc, pos)\\n      var styles = getLineStyles(this, getLine(this.doc, pos.line))\\n      var before = 0, after = (styles.length - 1) / 2, ch = pos.ch\\n      var type\\n      if (ch == 0) { type = styles[2] }\\n      else { for (;;) {\\n        var mid = (before + after) >> 1\\n        if ((mid ? styles[mid * 2 - 1] : 0) >= ch) { after = mid }\\n        else if (styles[mid * 2 + 1] < ch) { before = mid + 1 }\\n        else { type = styles[mid * 2 + 2]; break }\\n      } }\\n      var cut = type ? type.indexOf(\\\"overlay \\\") : -1\\n      return cut < 0 ? type : cut == 0 ? null : type.slice(0, cut - 1)\\n    },\\n\\n    getModeAt: function(pos) {\\n      var mode = this.doc.mode\\n      if (!mode.innerMode) { return mode }\\n      return CodeMirror.innerMode(mode, this.getTokenAt(pos).state).mode\\n    },\\n\\n    getHelper: function(pos, type) {\\n      return this.getHelpers(pos, type)[0]\\n    },\\n\\n    getHelpers: function(pos, type) {\\n      var this$1 = this;\\n\\n      var found = []\\n      if (!helpers.hasOwnProperty(type)) { return found }\\n      var help = helpers[type], mode = this.getModeAt(pos)\\n      if (typeof mode[type] == \\\"string\\\") {\\n        if (help[mode[type]]) { found.push(help[mode[type]]) }\\n      } else if (mode[type]) {\\n        for (var i = 0; i < mode[type].length; i++) {\\n          var val = help[mode[type][i]]\\n          if (val) { found.push(val) }\\n        }\\n      } else if (mode.helperType && help[mode.helperType]) {\\n        found.push(help[mode.helperType])\\n      } else if (help[mode.name]) {\\n        found.push(help[mode.name])\\n      }\\n      for (var i$1 = 0; i$1 < help._global.length; i$1++) {\\n        var cur = help._global[i$1]\\n        if (cur.pred(mode, this$1) && indexOf(found, cur.val) == -1)\\n          { found.push(cur.val) }\\n      }\\n      return found\\n    },\\n\\n    getStateAfter: function(line, precise) {\\n      var doc = this.doc\\n      line = clipLine(doc, line == null ? doc.first + doc.size - 1: line)\\n      return getStateBefore(this, line + 1, precise)\\n    },\\n\\n    cursorCoords: function(start, mode) {\\n      var pos, range = this.doc.sel.primary()\\n      if (start == null) { pos = range.head }\\n      else if (typeof start == \\\"object\\\") { pos = clipPos(this.doc, start) }\\n      else { pos = start ? range.from() : range.to() }\\n      return cursorCoords(this, pos, mode || \\\"page\\\")\\n    },\\n\\n    charCoords: function(pos, mode) {\\n      return charCoords(this, clipPos(this.doc, pos), mode || \\\"page\\\")\\n    },\\n\\n    coordsChar: function(coords, mode) {\\n      coords = fromCoordSystem(this, coords, mode || \\\"page\\\")\\n      return coordsChar(this, coords.left, coords.top)\\n    },\\n\\n    lineAtHeight: function(height, mode) {\\n      height = fromCoordSystem(this, {top: height, left: 0}, mode || \\\"page\\\").top\\n      return lineAtHeight(this.doc, height + this.display.viewOffset)\\n    },\\n    heightAtLine: function(line, mode, includeWidgets) {\\n      var end = false, lineObj\\n      if (typeof line == \\\"number\\\") {\\n        var last = this.doc.first + this.doc.size - 1\\n        if (line < this.doc.first) { line = this.doc.first }\\n        else if (line > last) { line = last; end = true }\\n        lineObj = getLine(this.doc, line)\\n      } else {\\n        lineObj = line\\n      }\\n      return intoCoordSystem(this, lineObj, {top: 0, left: 0}, mode || \\\"page\\\", includeWidgets).top +\\n        (end ? this.doc.height - heightAtLine(lineObj) : 0)\\n    },\\n\\n    defaultTextHeight: function() { return textHeight(this.display) },\\n    defaultCharWidth: function() { return charWidth(this.display) },\\n\\n    getViewport: function() { return {from: this.display.viewFrom, to: this.display.viewTo}},\\n\\n    addWidget: function(pos, node, scroll, vert, horiz) {\\n      var display = this.display\\n      pos = cursorCoords(this, clipPos(this.doc, pos))\\n      var top = pos.bottom, left = pos.left\\n      node.style.position = \\\"absolute\\\"\\n      node.setAttribute(\\\"cm-ignore-events\\\", \\\"true\\\")\\n      this.display.input.setUneditable(node)\\n      display.sizer.appendChild(node)\\n      if (vert == \\\"over\\\") {\\n        top = pos.top\\n      } else if (vert == \\\"above\\\" || vert == \\\"near\\\") {\\n        var vspace = Math.max(display.wrapper.clientHeight, this.doc.height),\\n        hspace = Math.max(display.sizer.clientWidth, display.lineSpace.clientWidth)\\n        // Default to positioning above (if specified and possible); otherwise default to positioning below\\n        if ((vert == 'above' || pos.bottom + node.offsetHeight > vspace) && pos.top > node.offsetHeight)\\n          { top = pos.top - node.offsetHeight }\\n        else if (pos.bottom + node.offsetHeight <= vspace)\\n          { top = pos.bottom }\\n        if (left + node.offsetWidth > hspace)\\n          { left = hspace - node.offsetWidth }\\n      }\\n      node.style.top = top + \\\"px\\\"\\n      node.style.left = node.style.right = \\\"\\\"\\n      if (horiz == \\\"right\\\") {\\n        left = display.sizer.clientWidth - node.offsetWidth\\n        node.style.right = \\\"0px\\\"\\n      } else {\\n        if (horiz == \\\"left\\\") { left = 0 }\\n        else if (horiz == \\\"middle\\\") { left = (display.sizer.clientWidth - node.offsetWidth) / 2 }\\n        node.style.left = left + \\\"px\\\"\\n      }\\n      if (scroll)\\n        { scrollIntoView(this, left, top, left + node.offsetWidth, top + node.offsetHeight) }\\n    },\\n\\n    triggerOnKeyDown: methodOp(onKeyDown),\\n    triggerOnKeyPress: methodOp(onKeyPress),\\n    triggerOnKeyUp: onKeyUp,\\n\\n    execCommand: function(cmd) {\\n      if (commands.hasOwnProperty(cmd))\\n        { return commands[cmd].call(null, this) }\\n    },\\n\\n    triggerElectric: methodOp(function(text) { triggerElectric(this, text) }),\\n\\n    findPosH: function(from, amount, unit, visually) {\\n      var this$1 = this;\\n\\n      var dir = 1\\n      if (amount < 0) { dir = -1; amount = -amount }\\n      var cur = clipPos(this.doc, from)\\n      for (var i = 0; i < amount; ++i) {\\n        cur = findPosH(this$1.doc, cur, dir, unit, visually)\\n        if (cur.hitSide) { break }\\n      }\\n      return cur\\n    },\\n\\n    moveH: methodOp(function(dir, unit) {\\n      var this$1 = this;\\n\\n      this.extendSelectionsBy(function (range) {\\n        if (this$1.display.shift || this$1.doc.extend || range.empty())\\n          { return findPosH(this$1.doc, range.head, dir, unit, this$1.options.rtlMoveVisually) }\\n        else\\n          { return dir < 0 ? range.from() : range.to() }\\n      }, sel_move)\\n    }),\\n\\n    deleteH: methodOp(function(dir, unit) {\\n      var sel = this.doc.sel, doc = this.doc\\n      if (sel.somethingSelected())\\n        { doc.replaceSelection(\\\"\\\", null, \\\"+delete\\\") }\\n      else\\n        { deleteNearSelection(this, function (range) {\\n          var other = findPosH(doc, range.head, dir, unit, false)\\n          return dir < 0 ? {from: other, to: range.head} : {from: range.head, to: other}\\n        }) }\\n    }),\\n\\n    findPosV: function(from, amount, unit, goalColumn) {\\n      var this$1 = this;\\n\\n      var dir = 1, x = goalColumn\\n      if (amount < 0) { dir = -1; amount = -amount }\\n      var cur = clipPos(this.doc, from)\\n      for (var i = 0; i < amount; ++i) {\\n        var coords = cursorCoords(this$1, cur, \\\"div\\\")\\n        if (x == null) { x = coords.left }\\n        else { coords.left = x }\\n        cur = findPosV(this$1, coords, dir, unit)\\n        if (cur.hitSide) { break }\\n      }\\n      return cur\\n    },\\n\\n    moveV: methodOp(function(dir, unit) {\\n      var this$1 = this;\\n\\n      var doc = this.doc, goals = []\\n      var collapse = !this.display.shift && !doc.extend && doc.sel.somethingSelected()\\n      doc.extendSelectionsBy(function (range) {\\n        if (collapse)\\n          { return dir < 0 ? range.from() : range.to() }\\n        var headPos = cursorCoords(this$1, range.head, \\\"div\\\")\\n        if (range.goalColumn != null) { headPos.left = range.goalColumn }\\n        goals.push(headPos.left)\\n        var pos = findPosV(this$1, headPos, dir, unit)\\n        if (unit == \\\"page\\\" && range == doc.sel.primary())\\n          { addToScrollPos(this$1, null, charCoords(this$1, pos, \\\"div\\\").top - headPos.top) }\\n        return pos\\n      }, sel_move)\\n      if (goals.length) { for (var i = 0; i < doc.sel.ranges.length; i++)\\n        { doc.sel.ranges[i].goalColumn = goals[i] } }\\n    }),\\n\\n    // Find the word at the given position (as returned by coordsChar).\\n    findWordAt: function(pos) {\\n      var doc = this.doc, line = getLine(doc, pos.line).text\\n      var start = pos.ch, end = pos.ch\\n      if (line) {\\n        var helper = this.getHelper(pos, \\\"wordChars\\\")\\n        if ((pos.xRel < 0 || end == line.length) && start) { --start; } else { ++end }\\n        var startChar = line.charAt(start)\\n        var check = isWordChar(startChar, helper)\\n          ? function (ch) { return isWordChar(ch, helper); }\\n          : /\\\\s/.test(startChar) ? function (ch) { return /\\\\s/.test(ch); }\\n          : function (ch) { return (!/\\\\s/.test(ch) && !isWordChar(ch)); }\\n        while (start > 0 && check(line.charAt(start - 1))) { --start }\\n        while (end < line.length && check(line.charAt(end))) { ++end }\\n      }\\n      return new Range(Pos(pos.line, start), Pos(pos.line, end))\\n    },\\n\\n    toggleOverwrite: function(value) {\\n      if (value != null && value == this.state.overwrite) { return }\\n      if (this.state.overwrite = !this.state.overwrite)\\n        { addClass(this.display.cursorDiv, \\\"CodeMirror-overwrite\\\") }\\n      else\\n        { rmClass(this.display.cursorDiv, \\\"CodeMirror-overwrite\\\") }\\n\\n      signal(this, \\\"overwriteToggle\\\", this, this.state.overwrite)\\n    },\\n    hasFocus: function() { return this.display.input.getField() == activeElt() },\\n    isReadOnly: function() { return !!(this.options.readOnly || this.doc.cantEdit) },\\n\\n    scrollTo: methodOp(function(x, y) {\\n      if (x != null || y != null) { resolveScrollToPos(this) }\\n      if (x != null) { this.curOp.scrollLeft = x }\\n      if (y != null) { this.curOp.scrollTop = y }\\n    }),\\n    getScrollInfo: function() {\\n      var scroller = this.display.scroller\\n      return {left: scroller.scrollLeft, top: scroller.scrollTop,\\n              height: scroller.scrollHeight - scrollGap(this) - this.display.barHeight,\\n              width: scroller.scrollWidth - scrollGap(this) - this.display.barWidth,\\n              clientHeight: displayHeight(this), clientWidth: displayWidth(this)}\\n    },\\n\\n    scrollIntoView: methodOp(function(range, margin) {\\n      if (range == null) {\\n        range = {from: this.doc.sel.primary().head, to: null}\\n        if (margin == null) { margin = this.options.cursorScrollMargin }\\n      } else if (typeof range == \\\"number\\\") {\\n        range = {from: Pos(range, 0), to: null}\\n      } else if (range.from == null) {\\n        range = {from: range, to: null}\\n      }\\n      if (!range.to) { range.to = range.from }\\n      range.margin = margin || 0\\n\\n      if (range.from.line != null) {\\n        resolveScrollToPos(this)\\n        this.curOp.scrollToPos = range\\n      } else {\\n        var sPos = calculateScrollPos(this, Math.min(range.from.left, range.to.left),\\n                                      Math.min(range.from.top, range.to.top) - range.margin,\\n                                      Math.max(range.from.right, range.to.right),\\n                                      Math.max(range.from.bottom, range.to.bottom) + range.margin)\\n        this.scrollTo(sPos.scrollLeft, sPos.scrollTop)\\n      }\\n    }),\\n\\n    setSize: methodOp(function(width, height) {\\n      var this$1 = this;\\n\\n      var interpret = function (val) { return typeof val == \\\"number\\\" || /^\\\\d+$/.test(String(val)) ? val + \\\"px\\\" : val; }\\n      if (width != null) { this.display.wrapper.style.width = interpret(width) }\\n      if (height != null) { this.display.wrapper.style.height = interpret(height) }\\n      if (this.options.lineWrapping) { clearLineMeasurementCache(this) }\\n      var lineNo = this.display.viewFrom\\n      this.doc.iter(lineNo, this.display.viewTo, function (line) {\\n        if (line.widgets) { for (var i = 0; i < line.widgets.length; i++)\\n          { if (line.widgets[i].noHScroll) { regLineChange(this$1, lineNo, \\\"widget\\\"); break } } }\\n        ++lineNo\\n      })\\n      this.curOp.forceUpdate = true\\n      signal(this, \\\"refresh\\\", this)\\n    }),\\n\\n    operation: function(f){return runInOp(this, f)},\\n\\n    refresh: methodOp(function() {\\n      var oldHeight = this.display.cachedTextHeight\\n      regChange(this)\\n      this.curOp.forceUpdate = true\\n      clearCaches(this)\\n      this.scrollTo(this.doc.scrollLeft, this.doc.scrollTop)\\n      updateGutterSpace(this)\\n      if (oldHeight == null || Math.abs(oldHeight - textHeight(this.display)) > .5)\\n        { estimateLineHeights(this) }\\n      signal(this, \\\"refresh\\\", this)\\n    }),\\n\\n    swapDoc: methodOp(function(doc) {\\n      var old = this.doc\\n      old.cm = null\\n      attachDoc(this, doc)\\n      clearCaches(this)\\n      this.display.input.reset()\\n      this.scrollTo(doc.scrollLeft, doc.scrollTop)\\n      this.curOp.forceScroll = true\\n      signalLater(this, \\\"swapDoc\\\", this, old)\\n      return old\\n    }),\\n\\n    getInputField: function(){return this.display.input.getField()},\\n    getWrapperElement: function(){return this.display.wrapper},\\n    getScrollerElement: function(){return this.display.scroller},\\n    getGutterElement: function(){return this.display.gutters}\\n  }\\n  eventMixin(CodeMirror)\\n\\n  CodeMirror.registerHelper = function(type, name, value) {\\n    if (!helpers.hasOwnProperty(type)) { helpers[type] = CodeMirror[type] = {_global: []} }\\n    helpers[type][name] = value\\n  }\\n  CodeMirror.registerGlobalHelper = function(type, name, predicate, value) {\\n    CodeMirror.registerHelper(type, name, value)\\n    helpers[type]._global.push({pred: predicate, val: value})\\n  }\\n}\\n\\n// Used for horizontal relative motion. Dir is -1 or 1 (left or\\n// right), unit can be \\\"char\\\", \\\"column\\\" (like char, but doesn't\\n// cross line boundaries), \\\"word\\\" (across next word), or \\\"group\\\" (to\\n// the start of next group of word or non-word-non-whitespace\\n// chars). The visually param controls whether, in right-to-left\\n// text, direction 1 means to move towards the next index in the\\n// string, or towards the character to the right of the current\\n// position. The resulting position will have a hitSide=true\\n// property if it reached the end of the document.\\nfunction findPosH(doc, pos, dir, unit, visually) {\\n  var line = pos.line, ch = pos.ch, origDir = dir\\n  var lineObj = getLine(doc, line)\\n  function findNextLine() {\\n    var l = line + dir\\n    if (l < doc.first || l >= doc.first + doc.size) { return false }\\n    line = l\\n    return lineObj = getLine(doc, l)\\n  }\\n  function moveOnce(boundToLine) {\\n    var next = (visually ? moveVisually : moveLogically)(lineObj, ch, dir, true)\\n    if (next == null) {\\n      if (!boundToLine && findNextLine()) {\\n        if (visually) { ch = (dir < 0 ? lineRight : lineLeft)(lineObj) }\\n        else { ch = dir < 0 ? lineObj.text.length : 0 }\\n      } else { return false }\\n    } else { ch = next }\\n    return true\\n  }\\n\\n  if (unit == \\\"char\\\") {\\n    moveOnce()\\n  } else if (unit == \\\"column\\\") {\\n    moveOnce(true)\\n  } else if (unit == \\\"word\\\" || unit == \\\"group\\\") {\\n    var sawType = null, group = unit == \\\"group\\\"\\n    var helper = doc.cm && doc.cm.getHelper(pos, \\\"wordChars\\\")\\n    for (var first = true;; first = false) {\\n      if (dir < 0 && !moveOnce(!first)) { break }\\n      var cur = lineObj.text.charAt(ch) || \\\"\\\\n\\\"\\n      var type = isWordChar(cur, helper) ? \\\"w\\\"\\n        : group && cur == \\\"\\\\n\\\" ? \\\"n\\\"\\n        : !group || /\\\\s/.test(cur) ? null\\n        : \\\"p\\\"\\n      if (group && !first && !type) { type = \\\"s\\\" }\\n      if (sawType && sawType != type) {\\n        if (dir < 0) {dir = 1; moveOnce()}\\n        break\\n      }\\n\\n      if (type) { sawType = type }\\n      if (dir > 0 && !moveOnce(!first)) { break }\\n    }\\n  }\\n  var result = skipAtomic(doc, Pos(line, ch), pos, origDir, true)\\n  if (!cmp(pos, result)) { result.hitSide = true }\\n  return result\\n}\\n\\n// For relative vertical movement. Dir may be -1 or 1. Unit can be\\n// \\\"page\\\" or \\\"line\\\". The resulting position will have a hitSide=true\\n// property if it reached the end of the document.\\nfunction findPosV(cm, pos, dir, unit) {\\n  var doc = cm.doc, x = pos.left, y\\n  if (unit == \\\"page\\\") {\\n    var pageSize = Math.min(cm.display.wrapper.clientHeight, window.innerHeight || document.documentElement.clientHeight)\\n    var moveAmount = Math.max(pageSize - .5 * textHeight(cm.display), 3)\\n    y = (dir > 0 ? pos.bottom : pos.top) + dir * moveAmount\\n\\n  } else if (unit == \\\"line\\\") {\\n    y = dir > 0 ? pos.bottom + 3 : pos.top - 3\\n  }\\n  var target\\n  for (;;) {\\n    target = coordsChar(cm, x, y)\\n    if (!target.outside) { break }\\n    if (dir < 0 ? y <= 0 : y >= doc.height) { target.hitSide = true; break }\\n    y += dir * 5\\n  }\\n  return target\\n}\\n\\n// CONTENTEDITABLE INPUT STYLE\\n\\nvar ContentEditableInput = function(cm) {\\n  this.cm = cm\\n  this.lastAnchorNode = this.lastAnchorOffset = this.lastFocusNode = this.lastFocusOffset = null\\n  this.polling = new Delayed()\\n  this.composing = null\\n  this.gracePeriod = false\\n  this.readDOMTimeout = null\\n};\\n\\nContentEditableInput.prototype.init = function (display) {\\n    var this$1 = this;\\n\\n  var input = this, cm = input.cm\\n  var div = input.div = display.lineDiv\\n  disableBrowserMagic(div, cm.options.spellcheck)\\n\\n  on(div, \\\"paste\\\", function (e) {\\n    if (signalDOMEvent(cm, e) || handlePaste(e, cm)) { return }\\n    // IE doesn't fire input events, so we schedule a read for the pasted content in this way\\n    if (ie_version <= 11) { setTimeout(operation(cm, function () {\\n      if (!input.pollContent()) { regChange(cm) }\\n    }), 20) }\\n  })\\n\\n  on(div, \\\"compositionstart\\\", function (e) {\\n    this$1.composing = {data: e.data, done: false}\\n  })\\n  on(div, \\\"compositionupdate\\\", function (e) {\\n    if (!this$1.composing) { this$1.composing = {data: e.data, done: false} }\\n  })\\n  on(div, \\\"compositionend\\\", function (e) {\\n    if (this$1.composing) {\\n      if (e.data != this$1.composing.data) { this$1.readFromDOMSoon() }\\n      this$1.composing.done = true\\n    }\\n  })\\n\\n  on(div, \\\"touchstart\\\", function () { return input.forceCompositionEnd(); })\\n\\n  on(div, \\\"input\\\", function () {\\n    if (!this$1.composing) { this$1.readFromDOMSoon() }\\n  })\\n\\n  function onCopyCut(e) {\\n    if (signalDOMEvent(cm, e)) { return }\\n    if (cm.somethingSelected()) {\\n      setLastCopied({lineWise: false, text: cm.getSelections()})\\n      if (e.type == \\\"cut\\\") { cm.replaceSelection(\\\"\\\", null, \\\"cut\\\") }\\n    } else if (!cm.options.lineWiseCopyCut) {\\n      return\\n    } else {\\n      var ranges = copyableRanges(cm)\\n      setLastCopied({lineWise: true, text: ranges.text})\\n      if (e.type == \\\"cut\\\") {\\n        cm.operation(function () {\\n          cm.setSelections(ranges.ranges, 0, sel_dontScroll)\\n          cm.replaceSelection(\\\"\\\", null, \\\"cut\\\")\\n        })\\n      }\\n    }\\n    if (e.clipboardData) {\\n      e.clipboardData.clearData()\\n      var content = lastCopied.text.join(\\\"\\\\n\\\")\\n      // iOS exposes the clipboard API, but seems to discard content inserted into it\\n      e.clipboardData.setData(\\\"Text\\\", content)\\n      if (e.clipboardData.getData(\\\"Text\\\") == content) {\\n        e.preventDefault()\\n        return\\n      }\\n    }\\n    // Old-fashioned briefly-focus-a-textarea hack\\n    var kludge = hiddenTextarea(), te = kludge.firstChild\\n    cm.display.lineSpace.insertBefore(kludge, cm.display.lineSpace.firstChild)\\n    te.value = lastCopied.text.join(\\\"\\\\n\\\")\\n    var hadFocus = document.activeElement\\n    selectInput(te)\\n    setTimeout(function () {\\n      cm.display.lineSpace.removeChild(kludge)\\n      hadFocus.focus()\\n      if (hadFocus == div) { input.showPrimarySelection() }\\n    }, 50)\\n  }\\n  on(div, \\\"copy\\\", onCopyCut)\\n  on(div, \\\"cut\\\", onCopyCut)\\n};\\n\\nContentEditableInput.prototype.prepareSelection = function () {\\n  var result = prepareSelection(this.cm, false)\\n  result.focus = this.cm.state.focused\\n  return result\\n};\\n\\nContentEditableInput.prototype.showSelection = function (info, takeFocus) {\\n  if (!info || !this.cm.display.view.length) { return }\\n  if (info.focus || takeFocus) { this.showPrimarySelection() }\\n  this.showMultipleSelections(info)\\n};\\n\\nContentEditableInput.prototype.showPrimarySelection = function () {\\n  var sel = window.getSelection(), prim = this.cm.doc.sel.primary()\\n  var curAnchor = domToPos(this.cm, sel.anchorNode, sel.anchorOffset)\\n  var curFocus = domToPos(this.cm, sel.focusNode, sel.focusOffset)\\n  if (curAnchor && !curAnchor.bad && curFocus && !curFocus.bad &&\\n      cmp(minPos(curAnchor, curFocus), prim.from()) == 0 &&\\n      cmp(maxPos(curAnchor, curFocus), prim.to()) == 0)\\n    { return }\\n\\n  var start = posToDOM(this.cm, prim.from())\\n  var end = posToDOM(this.cm, prim.to())\\n  if (!start && !end) { return }\\n\\n  var view = this.cm.display.view\\n  var old = sel.rangeCount && sel.getRangeAt(0)\\n  if (!start) {\\n    start = {node: view[0].measure.map[2], offset: 0}\\n  } else if (!end) { // FIXME dangerously hacky\\n    var measure = view[view.length - 1].measure\\n    var map = measure.maps ? measure.maps[measure.maps.length - 1] : measure.map\\n    end = {node: map[map.length - 1], offset: map[map.length - 2] - map[map.length - 3]}\\n  }\\n\\n  var rng\\n  try { rng = range(start.node, start.offset, end.offset, end.node) }\\n  catch(e) {} // Our model of the DOM might be outdated, in which case the range we try to set can be impossible\\n  if (rng) {\\n    if (!gecko && this.cm.state.focused) {\\n      sel.collapse(start.node, start.offset)\\n      if (!rng.collapsed) {\\n        sel.removeAllRanges()\\n        sel.addRange(rng)\\n      }\\n    } else {\\n      sel.removeAllRanges()\\n      sel.addRange(rng)\\n    }\\n    if (old && sel.anchorNode == null) { sel.addRange(old) }\\n    else if (gecko) { this.startGracePeriod() }\\n  }\\n  this.rememberSelection()\\n};\\n\\nContentEditableInput.prototype.startGracePeriod = function () {\\n    var this$1 = this;\\n\\n  clearTimeout(this.gracePeriod)\\n  this.gracePeriod = setTimeout(function () {\\n    this$1.gracePeriod = false\\n    if (this$1.selectionChanged())\\n      { this$1.cm.operation(function () { return this$1.cm.curOp.selectionChanged = true; }) }\\n  }, 20)\\n};\\n\\nContentEditableInput.prototype.showMultipleSelections = function (info) {\\n  removeChildrenAndAdd(this.cm.display.cursorDiv, info.cursors)\\n  removeChildrenAndAdd(this.cm.display.selectionDiv, info.selection)\\n};\\n\\nContentEditableInput.prototype.rememberSelection = function () {\\n  var sel = window.getSelection()\\n  this.lastAnchorNode = sel.anchorNode; this.lastAnchorOffset = sel.anchorOffset\\n  this.lastFocusNode = sel.focusNode; this.lastFocusOffset = sel.focusOffset\\n};\\n\\nContentEditableInput.prototype.selectionInEditor = function () {\\n  var sel = window.getSelection()\\n  if (!sel.rangeCount) { return false }\\n  var node = sel.getRangeAt(0).commonAncestorContainer\\n  return contains(this.div, node)\\n};\\n\\nContentEditableInput.prototype.focus = function () {\\n  if (this.cm.options.readOnly != \\\"nocursor\\\") {\\n    if (!this.selectionInEditor())\\n      { this.showSelection(this.prepareSelection(), true) }\\n    this.div.focus()\\n  }\\n};\\nContentEditableInput.prototype.blur = function () { this.div.blur() };\\nContentEditableInput.prototype.getField = function () { return this.div };\\n\\nContentEditableInput.prototype.supportsTouch = function () { return true };\\n\\nContentEditableInput.prototype.receivedFocus = function () {\\n  var input = this\\n  if (this.selectionInEditor())\\n    { this.pollSelection() }\\n  else\\n    { runInOp(this.cm, function () { return input.cm.curOp.selectionChanged = true; }) }\\n\\n  function poll() {\\n    if (input.cm.state.focused) {\\n      input.pollSelection()\\n      input.polling.set(input.cm.options.pollInterval, poll)\\n    }\\n  }\\n  this.polling.set(this.cm.options.pollInterval, poll)\\n};\\n\\nContentEditableInput.prototype.selectionChanged = function () {\\n  var sel = window.getSelection()\\n  return sel.anchorNode != this.lastAnchorNode || sel.anchorOffset != this.lastAnchorOffset ||\\n    sel.focusNode != this.lastFocusNode || sel.focusOffset != this.lastFocusOffset\\n};\\n\\nContentEditableInput.prototype.pollSelection = function () {\\n  if (!this.composing && this.readDOMTimeout == null && !this.gracePeriod && this.selectionChanged()) {\\n    var sel = window.getSelection(), cm = this.cm\\n    this.rememberSelection()\\n    var anchor = domToPos(cm, sel.anchorNode, sel.anchorOffset)\\n    var head = domToPos(cm, sel.focusNode, sel.focusOffset)\\n    if (anchor && head) { runInOp(cm, function () {\\n      setSelection(cm.doc, simpleSelection(anchor, head), sel_dontScroll)\\n      if (anchor.bad || head.bad) { cm.curOp.selectionChanged = true }\\n    }) }\\n  }\\n};\\n\\nContentEditableInput.prototype.pollContent = function () {\\n  if (this.readDOMTimeout != null) {\\n    clearTimeout(this.readDOMTimeout)\\n    this.readDOMTimeout = null\\n  }\\n\\n  var cm = this.cm, display = cm.display, sel = cm.doc.sel.primary()\\n  var from = sel.from(), to = sel.to()\\n  if (from.ch == 0 && from.line > cm.firstLine())\\n    { from = Pos(from.line - 1, getLine(cm.doc, from.line - 1).length) }\\n  if (to.ch == getLine(cm.doc, to.line).text.length && to.line < cm.lastLine())\\n    { to = Pos(to.line + 1, 0) }\\n  if (from.line < display.viewFrom || to.line > display.viewTo - 1) { return false }\\n\\n  var fromIndex, fromLine, fromNode\\n  if (from.line == display.viewFrom || (fromIndex = findViewIndex(cm, from.line)) == 0) {\\n    fromLine = lineNo(display.view[0].line)\\n    fromNode = display.view[0].node\\n  } else {\\n    fromLine = lineNo(display.view[fromIndex].line)\\n    fromNode = display.view[fromIndex - 1].node.nextSibling\\n  }\\n  var toIndex = findViewIndex(cm, to.line)\\n  var toLine, toNode\\n  if (toIndex == display.view.length - 1) {\\n    toLine = display.viewTo - 1\\n    toNode = display.lineDiv.lastChild\\n  } else {\\n    toLine = lineNo(display.view[toIndex + 1].line) - 1\\n    toNode = display.view[toIndex + 1].node.previousSibling\\n  }\\n\\n  if (!fromNode) { return false }\\n  var newText = cm.doc.splitLines(domTextBetween(cm, fromNode, toNode, fromLine, toLine))\\n  var oldText = getBetween(cm.doc, Pos(fromLine, 0), Pos(toLine, getLine(cm.doc, toLine).text.length))\\n  while (newText.length > 1 && oldText.length > 1) {\\n    if (lst(newText) == lst(oldText)) { newText.pop(); oldText.pop(); toLine-- }\\n    else if (newText[0] == oldText[0]) { newText.shift(); oldText.shift(); fromLine++ }\\n    else { break }\\n  }\\n\\n  var cutFront = 0, cutEnd = 0\\n  var newTop = newText[0], oldTop = oldText[0], maxCutFront = Math.min(newTop.length, oldTop.length)\\n  while (cutFront < maxCutFront && newTop.charCodeAt(cutFront) == oldTop.charCodeAt(cutFront))\\n    { ++cutFront }\\n  var newBot = lst(newText), oldBot = lst(oldText)\\n  var maxCutEnd = Math.min(newBot.length - (newText.length == 1 ? cutFront : 0),\\n                           oldBot.length - (oldText.length == 1 ? cutFront : 0))\\n  while (cutEnd < maxCutEnd &&\\n         newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1))\\n    { ++cutEnd }\\n\\n  newText[newText.length - 1] = newBot.slice(0, newBot.length - cutEnd).replace(/^\\\\u200b+/, \\\"\\\")\\n  newText[0] = newText[0].slice(cutFront).replace(/\\\\u200b+$/, \\\"\\\")\\n\\n  var chFrom = Pos(fromLine, cutFront)\\n  var chTo = Pos(toLine, oldText.length ? lst(oldText).length - cutEnd : 0)\\n  if (newText.length > 1 || newText[0] || cmp(chFrom, chTo)) {\\n    replaceRange(cm.doc, newText, chFrom, chTo, \\\"+input\\\")\\n    return true\\n  }\\n};\\n\\nContentEditableInput.prototype.ensurePolled = function () {\\n  this.forceCompositionEnd()\\n};\\nContentEditableInput.prototype.reset = function () {\\n  this.forceCompositionEnd()\\n};\\nContentEditableInput.prototype.forceCompositionEnd = function () {\\n  if (!this.composing) { return }\\n  clearTimeout(this.readDOMTimeout)\\n  this.composing = null\\n  if (!this.pollContent()) { regChange(this.cm) }\\n  this.div.blur()\\n  this.div.focus()\\n};\\nContentEditableInput.prototype.readFromDOMSoon = function () {\\n    var this$1 = this;\\n\\n  if (this.readDOMTimeout != null) { return }\\n  this.readDOMTimeout = setTimeout(function () {\\n    this$1.readDOMTimeout = null\\n    if (this$1.composing) {\\n      if (this$1.composing.done) { this$1.composing = null }\\n      else { return }\\n    }\\n    if (this$1.cm.isReadOnly() || !this$1.pollContent())\\n      { runInOp(this$1.cm, function () { return regChange(this$1.cm); }) }\\n  }, 80)\\n};\\n\\nContentEditableInput.prototype.setUneditable = function (node) {\\n  node.contentEditable = \\\"false\\\"\\n};\\n\\nContentEditableInput.prototype.onKeyPress = function (e) {\\n  e.preventDefault()\\n  if (!this.cm.isReadOnly())\\n    { operation(this.cm, applyTextInput)(this.cm, String.fromCharCode(e.charCode == null ? e.keyCode : e.charCode), 0) }\\n};\\n\\nContentEditableInput.prototype.readOnlyChanged = function (val) {\\n  this.div.contentEditable = String(val != \\\"nocursor\\\")\\n};\\n\\nContentEditableInput.prototype.onContextMenu = function () {};\\nContentEditableInput.prototype.resetPosition = function () {};\\n\\nContentEditableInput.prototype.needsContentAttribute = true\\n\\nfunction posToDOM(cm, pos) {\\n  var view = findViewForLine(cm, pos.line)\\n  if (!view || view.hidden) { return null }\\n  var line = getLine(cm.doc, pos.line)\\n  var info = mapFromLineView(view, line, pos.line)\\n\\n  var order = getOrder(line), side = \\\"left\\\"\\n  if (order) {\\n    var partPos = getBidiPartAt(order, pos.ch)\\n    side = partPos % 2 ? \\\"right\\\" : \\\"left\\\"\\n  }\\n  var result = nodeAndOffsetInLineMap(info.map, pos.ch, side)\\n  result.offset = result.collapse == \\\"right\\\" ? result.end : result.start\\n  return result\\n}\\n\\nfunction badPos(pos, bad) { if (bad) { pos.bad = true; } return pos }\\n\\nfunction domTextBetween(cm, from, to, fromLine, toLine) {\\n  var text = \\\"\\\", closing = false, lineSep = cm.doc.lineSeparator()\\n  function recognizeMarker(id) { return function (marker) { return marker.id == id; } }\\n  function walk(node) {\\n    if (node.nodeType == 1) {\\n      var cmText = node.getAttribute(\\\"cm-text\\\")\\n      if (cmText != null) {\\n        if (cmText == \\\"\\\") { text += node.textContent.replace(/\\\\u200b/g, \\\"\\\") }\\n        else { text += cmText }\\n        return\\n      }\\n      var markerID = node.getAttribute(\\\"cm-marker\\\"), range\\n      if (markerID) {\\n        var found = cm.findMarks(Pos(fromLine, 0), Pos(toLine + 1, 0), recognizeMarker(+markerID))\\n        if (found.length && (range = found[0].find()))\\n          { text += getBetween(cm.doc, range.from, range.to).join(lineSep) }\\n        return\\n      }\\n      if (node.getAttribute(\\\"contenteditable\\\") == \\\"false\\\") { return }\\n      for (var i = 0; i < node.childNodes.length; i++)\\n        { walk(node.childNodes[i]) }\\n      if (/^(pre|div|p)$/i.test(node.nodeName))\\n        { closing = true }\\n    } else if (node.nodeType == 3) {\\n      var val = node.nodeValue\\n      if (!val) { return }\\n      if (closing) {\\n        text += lineSep\\n        closing = false\\n      }\\n      text += val\\n    }\\n  }\\n  for (;;) {\\n    walk(from)\\n    if (from == to) { break }\\n    from = from.nextSibling\\n  }\\n  return text\\n}\\n\\nfunction domToPos(cm, node, offset) {\\n  var lineNode\\n  if (node == cm.display.lineDiv) {\\n    lineNode = cm.display.lineDiv.childNodes[offset]\\n    if (!lineNode) { return badPos(cm.clipPos(Pos(cm.display.viewTo - 1)), true) }\\n    node = null; offset = 0\\n  } else {\\n    for (lineNode = node;; lineNode = lineNode.parentNode) {\\n      if (!lineNode || lineNode == cm.display.lineDiv) { return null }\\n      if (lineNode.parentNode && lineNode.parentNode == cm.display.lineDiv) { break }\\n    }\\n  }\\n  for (var i = 0; i < cm.display.view.length; i++) {\\n    var lineView = cm.display.view[i]\\n    if (lineView.node == lineNode)\\n      { return locateNodeInLineView(lineView, node, offset) }\\n  }\\n}\\n\\nfunction locateNodeInLineView(lineView, node, offset) {\\n  var wrapper = lineView.text.firstChild, bad = false\\n  if (!node || !contains(wrapper, node)) { return badPos(Pos(lineNo(lineView.line), 0), true) }\\n  if (node == wrapper) {\\n    bad = true\\n    node = wrapper.childNodes[offset]\\n    offset = 0\\n    if (!node) {\\n      var line = lineView.rest ? lst(lineView.rest) : lineView.line\\n      return badPos(Pos(lineNo(line), line.text.length), bad)\\n    }\\n  }\\n\\n  var textNode = node.nodeType == 3 ? node : null, topNode = node\\n  if (!textNode && node.childNodes.length == 1 && node.firstChild.nodeType == 3) {\\n    textNode = node.firstChild\\n    if (offset) { offset = textNode.nodeValue.length }\\n  }\\n  while (topNode.parentNode != wrapper) { topNode = topNode.parentNode }\\n  var measure = lineView.measure, maps = measure.maps\\n\\n  function find(textNode, topNode, offset) {\\n    for (var i = -1; i < (maps ? maps.length : 0); i++) {\\n      var map = i < 0 ? measure.map : maps[i]\\n      for (var j = 0; j < map.length; j += 3) {\\n        var curNode = map[j + 2]\\n        if (curNode == textNode || curNode == topNode) {\\n          var line = lineNo(i < 0 ? lineView.line : lineView.rest[i])\\n          var ch = map[j] + offset\\n          if (offset < 0 || curNode != textNode) { ch = map[j + (offset ? 1 : 0)] }\\n          return Pos(line, ch)\\n        }\\n      }\\n    }\\n  }\\n  var found = find(textNode, topNode, offset)\\n  if (found) { return badPos(found, bad) }\\n\\n  // FIXME this is all really shaky. might handle the few cases it needs to handle, but likely to cause problems\\n  for (var after = topNode.nextSibling, dist = textNode ? textNode.nodeValue.length - offset : 0; after; after = after.nextSibling) {\\n    found = find(after, after.firstChild, 0)\\n    if (found)\\n      { return badPos(Pos(found.line, found.ch - dist), bad) }\\n    else\\n      { dist += after.textContent.length }\\n  }\\n  for (var before = topNode.previousSibling, dist$1 = offset; before; before = before.previousSibling) {\\n    found = find(before, before.firstChild, -1)\\n    if (found)\\n      { return badPos(Pos(found.line, found.ch + dist$1), bad) }\\n    else\\n      { dist$1 += before.textContent.length }\\n  }\\n}\\n\\n// TEXTAREA INPUT STYLE\\n\\nvar TextareaInput = function(cm) {\\n  this.cm = cm\\n  // See input.poll and input.reset\\n  this.prevInput = \\\"\\\"\\n\\n  // Flag that indicates whether we expect input to appear real soon\\n  // now (after some event like 'keypress' or 'input') and are\\n  // polling intensively.\\n  this.pollingFast = false\\n  // Self-resetting timeout for the poller\\n  this.polling = new Delayed()\\n  // Tracks when input.reset has punted to just putting a short\\n  // string into the textarea instead of the full selection.\\n  this.inaccurateSelection = false\\n  // Used to work around IE issue with selection being forgotten when focus moves away from textarea\\n  this.hasSelection = false\\n  this.composing = null\\n};\\n\\nTextareaInput.prototype.init = function (display) {\\n    var this$1 = this;\\n\\n  var input = this, cm = this.cm\\n\\n  // Wraps and hides input textarea\\n  var div = this.wrapper = hiddenTextarea()\\n  // The semihidden textarea that is focused when the editor is\\n  // focused, and receives input.\\n  var te = this.textarea = div.firstChild\\n  display.wrapper.insertBefore(div, display.wrapper.firstChild)\\n\\n  // Needed to hide big blue blinking cursor on Mobile Safari (doesn't seem to work in iOS 8 anymore)\\n  if (ios) { te.style.width = \\\"0px\\\" }\\n\\n  on(te, \\\"input\\\", function () {\\n    if (ie && ie_version >= 9 && this$1.hasSelection) { this$1.hasSelection = null }\\n    input.poll()\\n  })\\n\\n  on(te, \\\"paste\\\", function (e) {\\n    if (signalDOMEvent(cm, e) || handlePaste(e, cm)) { return }\\n\\n    cm.state.pasteIncoming = true\\n    input.fastPoll()\\n  })\\n\\n  function prepareCopyCut(e) {\\n    if (signalDOMEvent(cm, e)) { return }\\n    if (cm.somethingSelected()) {\\n      setLastCopied({lineWise: false, text: cm.getSelections()})\\n      if (input.inaccurateSelection) {\\n        input.prevInput = \\\"\\\"\\n        input.inaccurateSelection = false\\n        te.value = lastCopied.text.join(\\\"\\\\n\\\")\\n        selectInput(te)\\n      }\\n    } else if (!cm.options.lineWiseCopyCut) {\\n      return\\n    } else {\\n      var ranges = copyableRanges(cm)\\n      setLastCopied({lineWise: true, text: ranges.text})\\n      if (e.type == \\\"cut\\\") {\\n        cm.setSelections(ranges.ranges, null, sel_dontScroll)\\n      } else {\\n        input.prevInput = \\\"\\\"\\n        te.value = ranges.text.join(\\\"\\\\n\\\")\\n        selectInput(te)\\n      }\\n    }\\n    if (e.type == \\\"cut\\\") { cm.state.cutIncoming = true }\\n  }\\n  on(te, \\\"cut\\\", prepareCopyCut)\\n  on(te, \\\"copy\\\", prepareCopyCut)\\n\\n  on(display.scroller, \\\"paste\\\", function (e) {\\n    if (eventInWidget(display, e) || signalDOMEvent(cm, e)) { return }\\n    cm.state.pasteIncoming = true\\n    input.focus()\\n  })\\n\\n  // Prevent normal selection in the editor (we handle our own)\\n  on(display.lineSpace, \\\"selectstart\\\", function (e) {\\n    if (!eventInWidget(display, e)) { e_preventDefault(e) }\\n  })\\n\\n  on(te, \\\"compositionstart\\\", function () {\\n    var start = cm.getCursor(\\\"from\\\")\\n    if (input.composing) { input.composing.range.clear() }\\n    input.composing = {\\n      start: start,\\n      range: cm.markText(start, cm.getCursor(\\\"to\\\"), {className: \\\"CodeMirror-composing\\\"})\\n    }\\n  })\\n  on(te, \\\"compositionend\\\", function () {\\n    if (input.composing) {\\n      input.poll()\\n      input.composing.range.clear()\\n      input.composing = null\\n    }\\n  })\\n};\\n\\nTextareaInput.prototype.prepareSelection = function () {\\n  // Redraw the selection and/or cursor\\n  var cm = this.cm, display = cm.display, doc = cm.doc\\n  var result = prepareSelection(cm)\\n\\n  // Move the hidden textarea near the cursor to prevent scrolling artifacts\\n  if (cm.options.moveInputWithCursor) {\\n    var headPos = cursorCoords(cm, doc.sel.primary().head, \\\"div\\\")\\n    var wrapOff = display.wrapper.getBoundingClientRect(), lineOff = display.lineDiv.getBoundingClientRect()\\n    result.teTop = Math.max(0, Math.min(display.wrapper.clientHeight - 10,\\n                                        headPos.top + lineOff.top - wrapOff.top))\\n    result.teLeft = Math.max(0, Math.min(display.wrapper.clientWidth - 10,\\n                                         headPos.left + lineOff.left - wrapOff.left))\\n  }\\n\\n  return result\\n};\\n\\nTextareaInput.prototype.showSelection = function (drawn) {\\n  var cm = this.cm, display = cm.display\\n  removeChildrenAndAdd(display.cursorDiv, drawn.cursors)\\n  removeChildrenAndAdd(display.selectionDiv, drawn.selection)\\n  if (drawn.teTop != null) {\\n    this.wrapper.style.top = drawn.teTop + \\\"px\\\"\\n    this.wrapper.style.left = drawn.teLeft + \\\"px\\\"\\n  }\\n};\\n\\n// Reset the input to correspond to the selection (or to be empty,\\n// when not typing and nothing is selected)\\nTextareaInput.prototype.reset = function (typing) {\\n  if (this.contextMenuPending) { return }\\n  var minimal, selected, cm = this.cm, doc = cm.doc\\n  if (cm.somethingSelected()) {\\n    this.prevInput = \\\"\\\"\\n    var range = doc.sel.primary()\\n    minimal = hasCopyEvent &&\\n      (range.to().line - range.from().line > 100 || (selected = cm.getSelection()).length > 1000)\\n    var content = minimal ? \\\"-\\\" : selected || cm.getSelection()\\n    this.textarea.value = content\\n    if (cm.state.focused) { selectInput(this.textarea) }\\n    if (ie && ie_version >= 9) { this.hasSelection = content }\\n  } else if (!typing) {\\n    this.prevInput = this.textarea.value = \\\"\\\"\\n    if (ie && ie_version >= 9) { this.hasSelection = null }\\n  }\\n  this.inaccurateSelection = minimal\\n};\\n\\nTextareaInput.prototype.getField = function () { return this.textarea };\\n\\nTextareaInput.prototype.supportsTouch = function () { return false };\\n\\nTextareaInput.prototype.focus = function () {\\n  if (this.cm.options.readOnly != \\\"nocursor\\\" && (!mobile || activeElt() != this.textarea)) {\\n    try { this.textarea.focus() }\\n    catch (e) {} // IE8 will throw if the textarea is display: none or not in DOM\\n  }\\n};\\n\\nTextareaInput.prototype.blur = function () { this.textarea.blur() };\\n\\nTextareaInput.prototype.resetPosition = function () {\\n  this.wrapper.style.top = this.wrapper.style.left = 0\\n};\\n\\nTextareaInput.prototype.receivedFocus = function () { this.slowPoll() };\\n\\n// Poll for input changes, using the normal rate of polling. This\\n// runs as long as the editor is focused.\\nTextareaInput.prototype.slowPoll = function () {\\n    var this$1 = this;\\n\\n  if (this.pollingFast) { return }\\n  this.polling.set(this.cm.options.pollInterval, function () {\\n    this$1.poll()\\n    if (this$1.cm.state.focused) { this$1.slowPoll() }\\n  })\\n};\\n\\n// When an event has just come in that is likely to add or change\\n// something in the input textarea, we poll faster, to ensure that\\n// the change appears on the screen quickly.\\nTextareaInput.prototype.fastPoll = function () {\\n  var missed = false, input = this\\n  input.pollingFast = true\\n  function p() {\\n    var changed = input.poll()\\n    if (!changed && !missed) {missed = true; input.polling.set(60, p)}\\n    else {input.pollingFast = false; input.slowPoll()}\\n  }\\n  input.polling.set(20, p)\\n};\\n\\n// Read input from the textarea, and update the document to match.\\n// When something is selected, it is present in the textarea, and\\n// selected (unless it is huge, in which case a placeholder is\\n// used). When nothing is selected, the cursor sits after previously\\n// seen text (can be empty), which is stored in prevInput (we must\\n// not reset the textarea when typing, because that breaks IME).\\nTextareaInput.prototype.poll = function () {\\n    var this$1 = this;\\n\\n  var cm = this.cm, input = this.textarea, prevInput = this.prevInput\\n  // Since this is called a *lot*, try to bail out as cheaply as\\n  // possible when it is clear that nothing happened. hasSelection\\n  // will be the case when there is a lot of text in the textarea,\\n  // in which case reading its value would be expensive.\\n  if (this.contextMenuPending || !cm.state.focused ||\\n      (hasSelection(input) && !prevInput && !this.composing) ||\\n      cm.isReadOnly() || cm.options.disableInput || cm.state.keySeq)\\n    { return false }\\n\\n  var text = input.value\\n  // If nothing changed, bail.\\n  if (text == prevInput && !cm.somethingSelected()) { return false }\\n  // Work around nonsensical selection resetting in IE9/10, and\\n  // inexplicable appearance of private area unicode characters on\\n  // some key combos in Mac (#2689).\\n  if (ie && ie_version >= 9 && this.hasSelection === text ||\\n      mac && /[\\\\uf700-\\\\uf7ff]/.test(text)) {\\n    cm.display.input.reset()\\n    return false\\n  }\\n\\n  if (cm.doc.sel == cm.display.selForContextMenu) {\\n    var first = text.charCodeAt(0)\\n    if (first == 0x200b && !prevInput) { prevInput = \\\"\\\\u200b\\\" }\\n    if (first == 0x21da) { this.reset(); return this.cm.execCommand(\\\"undo\\\") }\\n  }\\n  // Find the part of the input that is actually new\\n  var same = 0, l = Math.min(prevInput.length, text.length)\\n  while (same < l && prevInput.charCodeAt(same) == text.charCodeAt(same)) { ++same }\\n\\n  runInOp(cm, function () {\\n    applyTextInput(cm, text.slice(same), prevInput.length - same,\\n                   null, this$1.composing ? \\\"*compose\\\" : null)\\n\\n    // Don't leave long text in the textarea, since it makes further polling slow\\n    if (text.length > 1000 || text.indexOf(\\\"\\\\n\\\") > -1) { input.value = this$1.prevInput = \\\"\\\" }\\n    else { this$1.prevInput = text }\\n\\n    if (this$1.composing) {\\n      this$1.composing.range.clear()\\n      this$1.composing.range = cm.markText(this$1.composing.start, cm.getCursor(\\\"to\\\"),\\n                                         {className: \\\"CodeMirror-composing\\\"})\\n    }\\n  })\\n  return true\\n};\\n\\nTextareaInput.prototype.ensurePolled = function () {\\n  if (this.pollingFast && this.poll()) { this.pollingFast = false }\\n};\\n\\nTextareaInput.prototype.onKeyPress = function () {\\n  if (ie && ie_version >= 9) { this.hasSelection = null }\\n  this.fastPoll()\\n};\\n\\nTextareaInput.prototype.onContextMenu = function (e) {\\n  var input = this, cm = input.cm, display = cm.display, te = input.textarea\\n  var pos = posFromMouse(cm, e), scrollPos = display.scroller.scrollTop\\n  if (!pos || presto) { return } // Opera is difficult.\\n\\n  // Reset the current text selection only if the click is done outside of the selection\\n  // and 'resetSelectionOnContextMenu' option is true.\\n  var reset = cm.options.resetSelectionOnContextMenu\\n  if (reset && cm.doc.sel.contains(pos) == -1)\\n    { operation(cm, setSelection)(cm.doc, simpleSelection(pos), sel_dontScroll) }\\n\\n  var oldCSS = te.style.cssText, oldWrapperCSS = input.wrapper.style.cssText\\n  input.wrapper.style.cssText = \\\"position: absolute\\\"\\n  var wrapperBox = input.wrapper.getBoundingClientRect()\\n  te.style.cssText = \\\"position: absolute; width: 30px; height: 30px;\\\\n      top: \\\" + (e.clientY - wrapperBox.top - 5) + \\\"px; left: \\\" + (e.clientX - wrapperBox.left - 5) + \\\"px;\\\\n      z-index: 1000; background: \\\" + (ie ? \\\"rgba(255, 255, 255, .05)\\\" : \\\"transparent\\\") + \\\";\\\\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);\\\"\\n  var oldScrollY\\n  if (webkit) { oldScrollY = window.scrollY } // Work around Chrome issue (#2712)\\n  display.input.focus()\\n  if (webkit) { window.scrollTo(null, oldScrollY) }\\n  display.input.reset()\\n  // Adds \\\"Select all\\\" to context menu in FF\\n  if (!cm.somethingSelected()) { te.value = input.prevInput = \\\" \\\" }\\n  input.contextMenuPending = true\\n  display.selForContextMenu = cm.doc.sel\\n  clearTimeout(display.detectingSelectAll)\\n\\n  // Select-all will be greyed out if there's nothing to select, so\\n  // this adds a zero-width space so that we can later check whether\\n  // it got selected.\\n  function prepareSelectAllHack() {\\n    if (te.selectionStart != null) {\\n      var selected = cm.somethingSelected()\\n      var extval = \\\"\\\\u200b\\\" + (selected ? te.value : \\\"\\\")\\n      te.value = \\\"\\\\u21da\\\" // Used to catch context-menu undo\\n      te.value = extval\\n      input.prevInput = selected ? \\\"\\\" : \\\"\\\\u200b\\\"\\n      te.selectionStart = 1; te.selectionEnd = extval.length\\n      // Re-set this, in case some other handler touched the\\n      // selection in the meantime.\\n      display.selForContextMenu = cm.doc.sel\\n    }\\n  }\\n  function rehide() {\\n    input.contextMenuPending = false\\n    input.wrapper.style.cssText = oldWrapperCSS\\n    te.style.cssText = oldCSS\\n    if (ie && ie_version < 9) { display.scrollbars.setScrollTop(display.scroller.scrollTop = scrollPos) }\\n\\n    // Try to detect the user choosing select-all\\n    if (te.selectionStart != null) {\\n      if (!ie || (ie && ie_version < 9)) { prepareSelectAllHack() }\\n      var i = 0, poll = function () {\\n        if (display.selForContextMenu == cm.doc.sel && te.selectionStart == 0 &&\\n            te.selectionEnd > 0 && input.prevInput == \\\"\\\\u200b\\\")\\n          { operation(cm, selectAll)(cm) }\\n        else if (i++ < 10) { display.detectingSelectAll = setTimeout(poll, 500) }\\n        else { display.input.reset() }\\n      }\\n      display.detectingSelectAll = setTimeout(poll, 200)\\n    }\\n  }\\n\\n  if (ie && ie_version >= 9) { prepareSelectAllHack() }\\n  if (captureRightClick) {\\n    e_stop(e)\\n    var mouseup = function () {\\n      off(window, \\\"mouseup\\\", mouseup)\\n      setTimeout(rehide, 20)\\n    }\\n    on(window, \\\"mouseup\\\", mouseup)\\n  } else {\\n    setTimeout(rehide, 50)\\n  }\\n};\\n\\nTextareaInput.prototype.readOnlyChanged = function (val) {\\n  if (!val) { this.reset() }\\n};\\n\\nTextareaInput.prototype.setUneditable = function () {};\\n\\nTextareaInput.prototype.needsContentAttribute = false\\n\\nfunction fromTextArea(textarea, options) {\\n  options = options ? copyObj(options) : {}\\n  options.value = textarea.value\\n  if (!options.tabindex && textarea.tabIndex)\\n    { options.tabindex = textarea.tabIndex }\\n  if (!options.placeholder && textarea.placeholder)\\n    { options.placeholder = textarea.placeholder }\\n  // Set autofocus to true if this textarea is focused, or if it has\\n  // autofocus and no other element is focused.\\n  if (options.autofocus == null) {\\n    var hasFocus = activeElt()\\n    options.autofocus = hasFocus == textarea ||\\n      textarea.getAttribute(\\\"autofocus\\\") != null && hasFocus == document.body\\n  }\\n\\n  function save() {textarea.value = cm.getValue()}\\n\\n  var realSubmit\\n  if (textarea.form) {\\n    on(textarea.form, \\\"submit\\\", save)\\n    // Deplorable hack to make the submit method do the right thing.\\n    if (!options.leaveSubmitMethodAlone) {\\n      var form = textarea.form\\n      realSubmit = form.submit\\n      try {\\n        var wrappedSubmit = form.submit = function () {\\n          save()\\n          form.submit = realSubmit\\n          form.submit()\\n          form.submit = wrappedSubmit\\n        }\\n      } catch(e) {}\\n    }\\n  }\\n\\n  options.finishInit = function (cm) {\\n    cm.save = save\\n    cm.getTextArea = function () { return textarea; }\\n    cm.toTextArea = function () {\\n      cm.toTextArea = isNaN // Prevent this from being ran twice\\n      save()\\n      textarea.parentNode.removeChild(cm.getWrapperElement())\\n      textarea.style.display = \\\"\\\"\\n      if (textarea.form) {\\n        off(textarea.form, \\\"submit\\\", save)\\n        if (typeof textarea.form.submit == \\\"function\\\")\\n          { textarea.form.submit = realSubmit }\\n      }\\n    }\\n  }\\n\\n  textarea.style.display = \\\"none\\\"\\n  var cm = CodeMirror(function (node) { return textarea.parentNode.insertBefore(node, textarea.nextSibling); },\\n    options)\\n  return cm\\n}\\n\\nfunction addLegacyProps(CodeMirror) {\\n  CodeMirror.off = off\\n  CodeMirror.on = on\\n  CodeMirror.wheelEventPixels = wheelEventPixels\\n  CodeMirror.Doc = Doc\\n  CodeMirror.splitLines = splitLinesAuto\\n  CodeMirror.countColumn = countColumn\\n  CodeMirror.findColumn = findColumn\\n  CodeMirror.isWordChar = isWordCharBasic\\n  CodeMirror.Pass = Pass\\n  CodeMirror.signal = signal\\n  CodeMirror.Line = Line\\n  CodeMirror.changeEnd = changeEnd\\n  CodeMirror.scrollbarModel = scrollbarModel\\n  CodeMirror.Pos = Pos\\n  CodeMirror.cmpPos = cmp\\n  CodeMirror.modes = modes\\n  CodeMirror.mimeModes = mimeModes\\n  CodeMirror.resolveMode = resolveMode\\n  CodeMirror.getMode = getMode\\n  CodeMirror.modeExtensions = modeExtensions\\n  CodeMirror.extendMode = extendMode\\n  CodeMirror.copyState = copyState\\n  CodeMirror.startState = startState\\n  CodeMirror.innerMode = innerMode\\n  CodeMirror.commands = commands\\n  CodeMirror.keyMap = keyMap\\n  CodeMirror.keyName = keyName\\n  CodeMirror.isModifierKey = isModifierKey\\n  CodeMirror.lookupKey = lookupKey\\n  CodeMirror.normalizeKeyMap = normalizeKeyMap\\n  CodeMirror.StringStream = StringStream\\n  CodeMirror.SharedTextMarker = SharedTextMarker\\n  CodeMirror.TextMarker = TextMarker\\n  CodeMirror.LineWidget = LineWidget\\n  CodeMirror.e_preventDefault = e_preventDefault\\n  CodeMirror.e_stopPropagation = e_stopPropagation\\n  CodeMirror.e_stop = e_stop\\n  CodeMirror.addClass = addClass\\n  CodeMirror.contains = contains\\n  CodeMirror.rmClass = rmClass\\n  CodeMirror.keyNames = keyNames\\n}\\n\\n// EDITOR CONSTRUCTOR\\n\\ndefineOptions(CodeMirror)\\n\\naddEditorMethods(CodeMirror)\\n\\n// Set up methods on CodeMirror's prototype to redirect to the editor's document.\\nvar dontDelegate = \\\"iter insert remove copy getEditor constructor\\\".split(\\\" \\\")\\nfor (var prop in Doc.prototype) { if (Doc.prototype.hasOwnProperty(prop) && indexOf(dontDelegate, prop) < 0)\\n  { CodeMirror.prototype[prop] = (function(method) {\\n    return function() {return method.apply(this.doc, arguments)}\\n  })(Doc.prototype[prop]) } }\\n\\neventMixin(Doc)\\n\\n// INPUT HANDLING\\n\\nCodeMirror.inputStyles = {\\\"textarea\\\": TextareaInput, \\\"contenteditable\\\": ContentEditableInput}\\n\\n// MODE DEFINITION AND QUERYING\\n\\n// Extra arguments are stored as the mode's dependencies, which is\\n// used by (legacy) mechanisms like loadmode.js to automatically\\n// load a mode. (Preferred mechanism is the require/define calls.)\\nCodeMirror.defineMode = function(name/*, mode, */) {\\n  if (!CodeMirror.defaults.mode && name != \\\"null\\\") { CodeMirror.defaults.mode = name }\\n  defineMode.apply(this, arguments)\\n}\\n\\nCodeMirror.defineMIME = defineMIME\\n\\n// Minimal default mode.\\nCodeMirror.defineMode(\\\"null\\\", function () { return ({token: function (stream) { return stream.skipToEnd(); }}); })\\nCodeMirror.defineMIME(\\\"text/plain\\\", \\\"null\\\")\\n\\n// EXTENSIONS\\n\\nCodeMirror.defineExtension = function (name, func) {\\n  CodeMirror.prototype[name] = func\\n}\\nCodeMirror.defineDocExtension = function (name, func) {\\n  Doc.prototype[name] = func\\n}\\n\\nCodeMirror.fromTextArea = fromTextArea\\n\\naddLegacyProps(CodeMirror)\\n\\nCodeMirror.version = \\\"5.23.0\\\"\\n\\nreturn CodeMirror;\\n\\n})));\"//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL34vY29kZW1pcnJvci9saWIvY29kZW1pcnJvci5qcz9iMGIxIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gXCIvLyBDb2RlTWlycm9yLCBjb3B5cmlnaHQgKGMpIGJ5IE1hcmlqbiBIYXZlcmJla2UgYW5kIG90aGVyc1xcbi8vIERpc3RyaWJ1dGVkIHVuZGVyIGFuIE1JVCBsaWNlbnNlOiBodHRwOi8vY29kZW1pcnJvci5uZXQvTElDRU5TRVxcblxcbi8vIFRoaXMgaXMgQ29kZU1pcnJvciAoaHR0cDovL2NvZGVtaXJyb3IubmV0KSwgYSBjb2RlIGVkaXRvclxcbi8vIGltcGxlbWVudGVkIGluIEphdmFTY3JpcHQgb24gdG9wIG9mIHRoZSBicm93c2VyJ3MgRE9NLlxcbi8vXFxuLy8gWW91IGNhbiBmaW5kIHNvbWUgdGVjaG5pY2FsIGJhY2tncm91bmQgZm9yIHNvbWUgb2YgdGhlIGNvZGUgYmVsb3dcXG4vLyBhdCBodHRwOi8vbWFyaWpuaGF2ZXJiZWtlLm5sL2Jsb2cvI2NtLWludGVybmFscyAuXFxuXFxuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcXG4gIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpIDpcXG4gIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShmYWN0b3J5KSA6XFxuICAoZ2xvYmFsLkNvZGVNaXJyb3IgPSBmYWN0b3J5KCkpO1xcbn0odGhpcywgKGZ1bmN0aW9uICgpIHsgJ3VzZSBzdHJpY3QnO1xcblxcbi8vIEtsdWRnZXMgZm9yIGJ1Z3MgYW5kIGJlaGF2aW9yIGRpZmZlcmVuY2VzIHRoYXQgY2FuJ3QgYmUgZmVhdHVyZVxcbi8vIGRldGVjdGVkIGFyZSBlbmFibGVkIGJhc2VkIG9uIHVzZXJBZ2VudCBldGMgc25pZmZpbmcuXFxudmFyIHVzZXJBZ2VudCA9IG5hdmlnYXRvci51c2VyQWdlbnRcXG52YXIgcGxhdGZvcm0gPSBuYXZpZ2F0b3IucGxhdGZvcm1cXG5cXG52YXIgZ2Vja28gPSAvZ2Vja29cXFxcL1xcXFxkL2kudGVzdCh1c2VyQWdlbnQpXFxudmFyIGllX3VwdG8xMCA9IC9NU0lFIFxcXFxkLy50ZXN0KHVzZXJBZ2VudClcXG52YXIgaWVfMTF1cCA9IC9UcmlkZW50XFxcXC8oPzpbNy05XXxcXFxcZHsyLH0pXFxcXC4uKnJ2OihcXFxcZCspLy5leGVjKHVzZXJBZ2VudClcXG52YXIgaWUgPSBpZV91cHRvMTAgfHwgaWVfMTF1cFxcbnZhciBpZV92ZXJzaW9uID0gaWUgJiYgKGllX3VwdG8xMCA/IGRvY3VtZW50LmRvY3VtZW50TW9kZSB8fCA2IDogaWVfMTF1cFsxXSlcXG52YXIgd2Via2l0ID0gL1dlYktpdFxcXFwvLy50ZXN0KHVzZXJBZ2VudClcXG52YXIgcXR3ZWJraXQgPSB3ZWJraXQgJiYgL1F0XFxcXC9cXFxcZCtcXFxcLlxcXFxkKy8udGVzdCh1c2VyQWdlbnQpXFxudmFyIGNocm9tZSA9IC9DaHJvbWVcXFxcLy8udGVzdCh1c2VyQWdlbnQpXFxudmFyIHByZXN0byA9IC9PcGVyYVxcXFwvLy50ZXN0KHVzZXJBZ2VudClcXG52YXIgc2FmYXJpID0gL0FwcGxlIENvbXB1dGVyLy50ZXN0KG5hdmlnYXRvci52ZW5kb3IpXFxudmFyIG1hY19nZU1vdW50YWluTGlvbiA9IC9NYWMgT1MgWCAxXFxcXGRcXFxcRChbOC05XXxcXFxcZFxcXFxkKVxcXFxELy50ZXN0KHVzZXJBZ2VudClcXG52YXIgcGhhbnRvbSA9IC9QaGFudG9tSlMvLnRlc3QodXNlckFnZW50KVxcblxcbnZhciBpb3MgPSAvQXBwbGVXZWJLaXQvLnRlc3QodXNlckFnZW50KSAmJiAvTW9iaWxlXFxcXC9cXFxcdysvLnRlc3QodXNlckFnZW50KVxcbi8vIFRoaXMgaXMgd29lZnVsbHkgaW5jb21wbGV0ZS4gU3VnZ2VzdGlvbnMgZm9yIGFsdGVybmF0aXZlIG1ldGhvZHMgd2VsY29tZS5cXG52YXIgbW9iaWxlID0gaW9zIHx8IC9BbmRyb2lkfHdlYk9TfEJsYWNrQmVycnl8T3BlcmEgTWluaXxPcGVyYSBNb2JpfElFTW9iaWxlL2kudGVzdCh1c2VyQWdlbnQpXFxudmFyIG1hYyA9IGlvcyB8fCAvTWFjLy50ZXN0KHBsYXRmb3JtKVxcbnZhciBjaHJvbWVPUyA9IC9cXFxcYkNyT1NcXFxcYi8udGVzdCh1c2VyQWdlbnQpXFxudmFyIHdpbmRvd3MgPSAvd2luL2kudGVzdChwbGF0Zm9ybSlcXG5cXG52YXIgcHJlc3RvX3ZlcnNpb24gPSBwcmVzdG8gJiYgdXNlckFnZW50Lm1hdGNoKC9WZXJzaW9uXFxcXC8oXFxcXGQqXFxcXC5cXFxcZCopLylcXG5pZiAocHJlc3RvX3ZlcnNpb24pIHsgcHJlc3RvX3ZlcnNpb24gPSBOdW1iZXIocHJlc3RvX3ZlcnNpb25bMV0pIH1cXG5pZiAocHJlc3RvX3ZlcnNpb24gJiYgcHJlc3RvX3ZlcnNpb24gPj0gMTUpIHsgcHJlc3RvID0gZmFsc2U7IHdlYmtpdCA9IHRydWUgfVxcbi8vIFNvbWUgYnJvd3NlcnMgdXNlIHRoZSB3cm9uZyBldmVudCBwcm9wZXJ0aWVzIHRvIHNpZ25hbCBjbWQvY3RybCBvbiBPUyBYXFxudmFyIGZsaXBDdHJsQ21kID0gbWFjICYmIChxdHdlYmtpdCB8fCBwcmVzdG8gJiYgKHByZXN0b192ZXJzaW9uID09IG51bGwgfHwgcHJlc3RvX3ZlcnNpb24gPCAxMi4xMSkpXFxudmFyIGNhcHR1cmVSaWdodENsaWNrID0gZ2Vja28gfHwgKGllICYmIGllX3ZlcnNpb24gPj0gOSlcXG5cXG5mdW5jdGlvbiBjbGFzc1Rlc3QoY2xzKSB7IHJldHVybiBuZXcgUmVnRXhwKFxcXCIoXnxcXFxcXFxcXHMpXFxcIiArIGNscyArIFxcXCIoPzokfFxcXFxcXFxccylcXFxcXFxcXHMqXFxcIikgfVxcblxcbnZhciBybUNsYXNzID0gZnVuY3Rpb24obm9kZSwgY2xzKSB7XFxuICB2YXIgY3VycmVudCA9IG5vZGUuY2xhc3NOYW1lXFxuICB2YXIgbWF0Y2ggPSBjbGFzc1Rlc3QoY2xzKS5leGVjKGN1cnJlbnQpXFxuICBpZiAobWF0Y2gpIHtcXG4gICAgdmFyIGFmdGVyID0gY3VycmVudC5zbGljZShtYXRjaC5pbmRleCArIG1hdGNoWzBdLmxlbmd0aClcXG4gICAgbm9kZS5jbGFzc05hbWUgPSBjdXJyZW50LnNsaWNlKDAsIG1hdGNoLmluZGV4KSArIChhZnRlciA/IG1hdGNoWzFdICsgYWZ0ZXIgOiBcXFwiXFxcIilcXG4gIH1cXG59XFxuXFxuZnVuY3Rpb24gcmVtb3ZlQ2hpbGRyZW4oZSkge1xcbiAgZm9yICh2YXIgY291bnQgPSBlLmNoaWxkTm9kZXMubGVuZ3RoOyBjb3VudCA+IDA7IC0tY291bnQpXFxuICAgIHsgZS5yZW1vdmVDaGlsZChlLmZpcnN0Q2hpbGQpIH1cXG4gIHJldHVybiBlXFxufVxcblxcbmZ1bmN0aW9uIHJlbW92ZUNoaWxkcmVuQW5kQWRkKHBhcmVudCwgZSkge1xcbiAgcmV0dXJuIHJlbW92ZUNoaWxkcmVuKHBhcmVudCkuYXBwZW5kQ2hpbGQoZSlcXG59XFxuXFxuZnVuY3Rpb24gZWx0KHRhZywgY29udGVudCwgY2xhc3NOYW1lLCBzdHlsZSkge1xcbiAgdmFyIGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZylcXG4gIGlmIChjbGFzc05hbWUpIHsgZS5jbGFzc05hbWUgPSBjbGFzc05hbWUgfVxcbiAgaWYgKHN0eWxlKSB7IGUuc3R5bGUuY3NzVGV4dCA9IHN0eWxlIH1cXG4gIGlmICh0eXBlb2YgY29udGVudCA9PSBcXFwic3RyaW5nXFxcIikgeyBlLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNvbnRlbnQpKSB9XFxuICBlbHNlIGlmIChjb250ZW50KSB7IGZvciAodmFyIGkgPSAwOyBpIDwgY29udGVudC5sZW5ndGg7ICsraSkgeyBlLmFwcGVuZENoaWxkKGNvbnRlbnRbaV0pIH0gfVxcbiAgcmV0dXJuIGVcXG59XFxuXFxudmFyIHJhbmdlXFxuaWYgKGRvY3VtZW50LmNyZWF0ZVJhbmdlKSB7IHJhbmdlID0gZnVuY3Rpb24obm9kZSwgc3RhcnQsIGVuZCwgZW5kTm9kZSkge1xcbiAgdmFyIHIgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpXFxuICByLnNldEVuZChlbmROb2RlIHx8IG5vZGUsIGVuZClcXG4gIHIuc2V0U3RhcnQobm9kZSwgc3RhcnQpXFxuICByZXR1cm4gclxcbn0gfVxcbmVsc2UgeyByYW5nZSA9IGZ1bmN0aW9uKG5vZGUsIHN0YXJ0LCBlbmQpIHtcXG4gIHZhciByID0gZG9jdW1lbnQuYm9keS5jcmVhdGVUZXh0UmFuZ2UoKVxcbiAgdHJ5IHsgci5tb3ZlVG9FbGVtZW50VGV4dChub2RlLnBhcmVudE5vZGUpIH1cXG4gIGNhdGNoKGUpIHsgcmV0dXJuIHIgfVxcbiAgci5jb2xsYXBzZSh0cnVlKVxcbiAgci5tb3ZlRW5kKFxcXCJjaGFyYWN0ZXJcXFwiLCBlbmQpXFxuICByLm1vdmVTdGFydChcXFwiY2hhcmFjdGVyXFxcIiwgc3RhcnQpXFxuICByZXR1cm4gclxcbn0gfVxcblxcbmZ1bmN0aW9uIGNvbnRhaW5zKHBhcmVudCwgY2hpbGQpIHtcXG4gIGlmIChjaGlsZC5ub2RlVHlwZSA9PSAzKSAvLyBBbmRyb2lkIGJyb3dzZXIgYWx3YXlzIHJldHVybnMgZmFsc2Ugd2hlbiBjaGlsZCBpcyBhIHRleHRub2RlXFxuICAgIHsgY2hpbGQgPSBjaGlsZC5wYXJlbnROb2RlIH1cXG4gIGlmIChwYXJlbnQuY29udGFpbnMpXFxuICAgIHsgcmV0dXJuIHBhcmVudC5jb250YWlucyhjaGlsZCkgfVxcbiAgZG8ge1xcbiAgICBpZiAoY2hpbGQubm9kZVR5cGUgPT0gMTEpIHsgY2hpbGQgPSBjaGlsZC5ob3N0IH1cXG4gICAgaWYgKGNoaWxkID09IHBhcmVudCkgeyByZXR1cm4gdHJ1ZSB9XFxuICB9IHdoaWxlIChjaGlsZCA9IGNoaWxkLnBhcmVudE5vZGUpXFxufVxcblxcbmZ1bmN0aW9uIGFjdGl2ZUVsdCgpIHtcXG4gIC8vIElFIGFuZCBFZGdlIG1heSB0aHJvdyBhbiBcXFwiVW5zcGVjaWZpZWQgRXJyb3JcXFwiIHdoZW4gYWNjZXNzaW5nIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQuXFxuICAvLyBJRSA8IDEwIHdpbGwgdGhyb3cgd2hlbiBhY2Nlc3NlZCB3aGlsZSB0aGUgcGFnZSBpcyBsb2FkaW5nIG9yIGluIGFuIGlmcmFtZS5cXG4gIC8vIElFID4gOSBhbmQgRWRnZSB3aWxsIHRocm93IHdoZW4gYWNjZXNzZWQgaW4gYW4gaWZyYW1lIGlmIGRvY3VtZW50LmJvZHkgaXMgdW5hdmFpbGFibGUuXFxuICB2YXIgYWN0aXZlRWxlbWVudFxcbiAgdHJ5IHtcXG4gICAgYWN0aXZlRWxlbWVudCA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnRcXG4gIH0gY2F0Y2goZSkge1xcbiAgICBhY3RpdmVFbGVtZW50ID0gZG9jdW1lbnQuYm9keSB8fCBudWxsXFxuICB9XFxuICB3aGlsZSAoYWN0aXZlRWxlbWVudCAmJiBhY3RpdmVFbGVtZW50LnJvb3QgJiYgYWN0aXZlRWxlbWVudC5yb290LmFjdGl2ZUVsZW1lbnQpXFxuICAgIHsgYWN0aXZlRWxlbWVudCA9IGFjdGl2ZUVsZW1lbnQucm9vdC5hY3RpdmVFbGVtZW50IH1cXG4gIHJldHVybiBhY3RpdmVFbGVtZW50XFxufVxcblxcbmZ1bmN0aW9uIGFkZENsYXNzKG5vZGUsIGNscykge1xcbiAgdmFyIGN1cnJlbnQgPSBub2RlLmNsYXNzTmFtZVxcbiAgaWYgKCFjbGFzc1Rlc3QoY2xzKS50ZXN0KGN1cnJlbnQpKSB7IG5vZGUuY2xhc3NOYW1lICs9IChjdXJyZW50ID8gXFxcIiBcXFwiIDogXFxcIlxcXCIpICsgY2xzIH1cXG59XFxuZnVuY3Rpb24gam9pbkNsYXNzZXMoYSwgYikge1xcbiAgdmFyIGFzID0gYS5zcGxpdChcXFwiIFxcXCIpXFxuICBmb3IgKHZhciBpID0gMDsgaSA8IGFzLmxlbmd0aDsgaSsrKVxcbiAgICB7IGlmIChhc1tpXSAmJiAhY2xhc3NUZXN0KGFzW2ldKS50ZXN0KGIpKSB7IGIgKz0gXFxcIiBcXFwiICsgYXNbaV0gfSB9XFxuICByZXR1cm4gYlxcbn1cXG5cXG52YXIgc2VsZWN0SW5wdXQgPSBmdW5jdGlvbihub2RlKSB7IG5vZGUuc2VsZWN0KCkgfVxcbmlmIChpb3MpIC8vIE1vYmlsZSBTYWZhcmkgYXBwYXJlbnRseSBoYXMgYSBidWcgd2hlcmUgc2VsZWN0KCkgaXMgYnJva2VuLlxcbiAgeyBzZWxlY3RJbnB1dCA9IGZ1bmN0aW9uKG5vZGUpIHsgbm9kZS5zZWxlY3Rpb25TdGFydCA9IDA7IG5vZGUuc2VsZWN0aW9uRW5kID0gbm9kZS52YWx1ZS5sZW5ndGggfSB9XFxuZWxzZSBpZiAoaWUpIC8vIFN1cHByZXNzIG15c3RlcmlvdXMgSUUxMCBlcnJvcnNcXG4gIHsgc2VsZWN0SW5wdXQgPSBmdW5jdGlvbihub2RlKSB7IHRyeSB7IG5vZGUuc2VsZWN0KCkgfSBjYXRjaChfZSkge30gfSB9XFxuXFxuZnVuY3Rpb24gYmluZChmKSB7XFxuICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSlcXG4gIHJldHVybiBmdW5jdGlvbigpe3JldHVybiBmLmFwcGx5KG51bGwsIGFyZ3MpfVxcbn1cXG5cXG5mdW5jdGlvbiBjb3B5T2JqKG9iaiwgdGFyZ2V0LCBvdmVyd3JpdGUpIHtcXG4gIGlmICghdGFyZ2V0KSB7IHRhcmdldCA9IHt9IH1cXG4gIGZvciAodmFyIHByb3AgaW4gb2JqKVxcbiAgICB7IGlmIChvYmouaGFzT3duUHJvcGVydHkocHJvcCkgJiYgKG92ZXJ3cml0ZSAhPT0gZmFsc2UgfHwgIXRhcmdldC5oYXNPd25Qcm9wZXJ0eShwcm9wKSkpXFxuICAgICAgeyB0YXJnZXRbcHJvcF0gPSBvYmpbcHJvcF0gfSB9XFxuICByZXR1cm4gdGFyZ2V0XFxufVxcblxcbi8vIENvdW50cyB0aGUgY29sdW1uIG9mZnNldCBpbiBhIHN0cmluZywgdGFraW5nIHRhYnMgaW50byBhY2NvdW50Llxcbi8vIFVzZWQgbW9zdGx5IHRvIGZpbmQgaW5kZW50YXRpb24uXFxuZnVuY3Rpb24gY291bnRDb2x1bW4oc3RyaW5nLCBlbmQsIHRhYlNpemUsIHN0YXJ0SW5kZXgsIHN0YXJ0VmFsdWUpIHtcXG4gIGlmIChlbmQgPT0gbnVsbCkge1xcbiAgICBlbmQgPSBzdHJpbmcuc2VhcmNoKC9bXlxcXFxzXFxcXHUwMGEwXS8pXFxuICAgIGlmIChlbmQgPT0gLTEpIHsgZW5kID0gc3RyaW5nLmxlbmd0aCB9XFxuICB9XFxuICBmb3IgKHZhciBpID0gc3RhcnRJbmRleCB8fCAwLCBuID0gc3RhcnRWYWx1ZSB8fCAwOzspIHtcXG4gICAgdmFyIG5leHRUYWIgPSBzdHJpbmcuaW5kZXhPZihcXFwiXFxcXHRcXFwiLCBpKVxcbiAgICBpZiAobmV4dFRhYiA8IDAgfHwgbmV4dFRhYiA+PSBlbmQpXFxuICAgICAgeyByZXR1cm4gbiArIChlbmQgLSBpKSB9XFxuICAgIG4gKz0gbmV4dFRhYiAtIGlcXG4gICAgbiArPSB0YWJTaXplIC0gKG4gJSB0YWJTaXplKVxcbiAgICBpID0gbmV4dFRhYiArIDFcXG4gIH1cXG59XFxuXFxuZnVuY3Rpb24gRGVsYXllZCgpIHt0aGlzLmlkID0gbnVsbH1cXG5EZWxheWVkLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbihtcywgZikge1xcbiAgY2xlYXJUaW1lb3V0KHRoaXMuaWQpXFxuICB0aGlzLmlkID0gc2V0VGltZW91dChmLCBtcylcXG59XFxuXFxuZnVuY3Rpb24gaW5kZXhPZihhcnJheSwgZWx0KSB7XFxuICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgKytpKVxcbiAgICB7IGlmIChhcnJheVtpXSA9PSBlbHQpIHsgcmV0dXJuIGkgfSB9XFxuICByZXR1cm4gLTFcXG59XFxuXFxuLy8gTnVtYmVyIG9mIHBpeGVscyBhZGRlZCB0byBzY3JvbGxlciBhbmQgc2l6ZXIgdG8gaGlkZSBzY3JvbGxiYXJcXG52YXIgc2Nyb2xsZXJHYXAgPSAzMFxcblxcbi8vIFJldHVybmVkIG9yIHRocm93biBieSB2YXJpb3VzIHByb3RvY29scyB0byBzaWduYWwgJ0knbSBub3RcXG4vLyBoYW5kbGluZyB0aGlzJy5cXG52YXIgUGFzcyA9IHt0b1N0cmluZzogZnVuY3Rpb24oKXtyZXR1cm4gXFxcIkNvZGVNaXJyb3IuUGFzc1xcXCJ9fVxcblxcbi8vIFJldXNlZCBvcHRpb24gb2JqZWN0cyBmb3Igc2V0U2VsZWN0aW9uICYgZnJpZW5kc1xcbnZhciBzZWxfZG9udFNjcm9sbCA9IHtzY3JvbGw6IGZhbHNlfTtcXG52YXIgc2VsX21vdXNlID0ge29yaWdpbjogXFxcIiptb3VzZVxcXCJ9O1xcbnZhciBzZWxfbW92ZSA9IHtvcmlnaW46IFxcXCIrbW92ZVxcXCJ9O1xcbi8vIFRoZSBpbnZlcnNlIG9mIGNvdW50Q29sdW1uIC0tIGZpbmQgdGhlIG9mZnNldCB0aGF0IGNvcnJlc3BvbmRzIHRvXFxuLy8gYSBwYXJ0aWN1bGFyIGNvbHVtbi5cXG5mdW5jdGlvbiBmaW5kQ29sdW1uKHN0cmluZywgZ29hbCwgdGFiU2l6ZSkge1xcbiAgZm9yICh2YXIgcG9zID0gMCwgY29sID0gMDs7KSB7XFxuICAgIHZhciBuZXh0VGFiID0gc3RyaW5nLmluZGV4T2YoXFxcIlxcXFx0XFxcIiwgcG9zKVxcbiAgICBpZiAobmV4dFRhYiA9PSAtMSkgeyBuZXh0VGFiID0gc3RyaW5nLmxlbmd0aCB9XFxuICAgIHZhciBza2lwcGVkID0gbmV4dFRhYiAtIHBvc1xcbiAgICBpZiAobmV4dFRhYiA9PSBzdHJpbmcubGVuZ3RoIHx8IGNvbCArIHNraXBwZWQgPj0gZ29hbClcXG4gICAgICB7IHJldHVybiBwb3MgKyBNYXRoLm1pbihza2lwcGVkLCBnb2FsIC0gY29sKSB9XFxuICAgIGNvbCArPSBuZXh0VGFiIC0gcG9zXFxuICAgIGNvbCArPSB0YWJTaXplIC0gKGNvbCAlIHRhYlNpemUpXFxuICAgIHBvcyA9IG5leHRUYWIgKyAxXFxuICAgIGlmIChjb2wgPj0gZ29hbCkgeyByZXR1cm4gcG9zIH1cXG4gIH1cXG59XFxuXFxudmFyIHNwYWNlU3RycyA9IFtcXFwiXFxcIl1cXG5mdW5jdGlvbiBzcGFjZVN0cihuKSB7XFxuICB3aGlsZSAoc3BhY2VTdHJzLmxlbmd0aCA8PSBuKVxcbiAgICB7IHNwYWNlU3Rycy5wdXNoKGxzdChzcGFjZVN0cnMpICsgXFxcIiBcXFwiKSB9XFxuICByZXR1cm4gc3BhY2VTdHJzW25dXFxufVxcblxcbmZ1bmN0aW9uIGxzdChhcnIpIHsgcmV0dXJuIGFyclthcnIubGVuZ3RoLTFdIH1cXG5cXG5mdW5jdGlvbiBtYXAoYXJyYXksIGYpIHtcXG4gIHZhciBvdXQgPSBbXVxcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykgeyBvdXRbaV0gPSBmKGFycmF5W2ldLCBpKSB9XFxuICByZXR1cm4gb3V0XFxufVxcblxcbmZ1bmN0aW9uIGluc2VydFNvcnRlZChhcnJheSwgdmFsdWUsIHNjb3JlKSB7XFxuICB2YXIgcG9zID0gMCwgcHJpb3JpdHkgPSBzY29yZSh2YWx1ZSlcXG4gIHdoaWxlIChwb3MgPCBhcnJheS5sZW5ndGggJiYgc2NvcmUoYXJyYXlbcG9zXSkgPD0gcHJpb3JpdHkpIHsgcG9zKysgfVxcbiAgYXJyYXkuc3BsaWNlKHBvcywgMCwgdmFsdWUpXFxufVxcblxcbmZ1bmN0aW9uIG5vdGhpbmcoKSB7fVxcblxcbmZ1bmN0aW9uIGNyZWF0ZU9iaihiYXNlLCBwcm9wcykge1xcbiAgdmFyIGluc3RcXG4gIGlmIChPYmplY3QuY3JlYXRlKSB7XFxuICAgIGluc3QgPSBPYmplY3QuY3JlYXRlKGJhc2UpXFxuICB9IGVsc2Uge1xcbiAgICBub3RoaW5nLnByb3RvdHlwZSA9IGJhc2VcXG4gICAgaW5zdCA9IG5ldyBub3RoaW5nKClcXG4gIH1cXG4gIGlmIChwcm9wcykgeyBjb3B5T2JqKHByb3BzLCBpbnN0KSB9XFxuICByZXR1cm4gaW5zdFxcbn1cXG5cXG52YXIgbm9uQVNDSUlTaW5nbGVDYXNlV29yZENoYXIgPSAvW1xcXFx1MDBkZlxcXFx1MDU4N1xcXFx1MDU5MC1cXFxcdTA1ZjRcXFxcdTA2MDAtXFxcXHUwNmZmXFxcXHUzMDQwLVxcXFx1MzA5ZlxcXFx1MzBhMC1cXFxcdTMwZmZcXFxcdTM0MDAtXFxcXHU0ZGI1XFxcXHU0ZTAwLVxcXFx1OWZjY1xcXFx1YWMwMC1cXFxcdWQ3YWZdL1xcbmZ1bmN0aW9uIGlzV29yZENoYXJCYXNpYyhjaCkge1xcbiAgcmV0dXJuIC9cXFxcdy8udGVzdChjaCkgfHwgY2ggPiBcXFwiXFxcXHg4MFxcXCIgJiZcXG4gICAgKGNoLnRvVXBwZXJDYXNlKCkgIT0gY2gudG9Mb3dlckNhc2UoKSB8fCBub25BU0NJSVNpbmdsZUNhc2VXb3JkQ2hhci50ZXN0KGNoKSlcXG59XFxuZnVuY3Rpb24gaXNXb3JkQ2hhcihjaCwgaGVscGVyKSB7XFxuICBpZiAoIWhlbHBlcikgeyByZXR1cm4gaXNXb3JkQ2hhckJhc2ljKGNoKSB9XFxuICBpZiAoaGVscGVyLnNvdXJjZS5pbmRleE9mKFxcXCJcXFxcXFxcXHdcXFwiKSA+IC0xICYmIGlzV29yZENoYXJCYXNpYyhjaCkpIHsgcmV0dXJuIHRydWUgfVxcbiAgcmV0dXJuIGhlbHBlci50ZXN0KGNoKVxcbn1cXG5cXG5mdW5jdGlvbiBpc0VtcHR5KG9iaikge1xcbiAgZm9yICh2YXIgbiBpbiBvYmopIHsgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShuKSAmJiBvYmpbbl0pIHsgcmV0dXJuIGZhbHNlIH0gfVxcbiAgcmV0dXJuIHRydWVcXG59XFxuXFxuLy8gRXh0ZW5kaW5nIHVuaWNvZGUgY2hhcmFjdGVycy4gQSBzZXJpZXMgb2YgYSBub24tZXh0ZW5kaW5nIGNoYXIgK1xcbi8vIGFueSBudW1iZXIgb2YgZXh0ZW5kaW5nIGNoYXJzIGlzIHRyZWF0ZWQgYXMgYSBzaW5nbGUgdW5pdCBhcyBmYXJcXG4vLyBhcyBlZGl0aW5nIGFuZCBtZWFzdXJpbmcgaXMgY29uY2VybmVkLiBUaGlzIGlzIG5vdCBmdWxseSBjb3JyZWN0LFxcbi8vIHNpbmNlIHNvbWUgc2NyaXB0cy9mb250cy9icm93c2VycyBhbHNvIHRyZWF0IG90aGVyIGNvbmZpZ3VyYXRpb25zXFxuLy8gb2YgY29kZSBwb2ludHMgYXMgYSBncm91cC5cXG52YXIgZXh0ZW5kaW5nQ2hhcnMgPSAvW1xcXFx1MDMwMC1cXFxcdTAzNmZcXFxcdTA0ODMtXFxcXHUwNDg5XFxcXHUwNTkxLVxcXFx1MDViZFxcXFx1MDViZlxcXFx1MDVjMVxcXFx1MDVjMlxcXFx1MDVjNFxcXFx1MDVjNVxcXFx1MDVjN1xcXFx1MDYxMC1cXFxcdTA2MWFcXFxcdTA2NGItXFxcXHUwNjVlXFxcXHUwNjcwXFxcXHUwNmQ2LVxcXFx1MDZkY1xcXFx1MDZkZS1cXFxcdTA2ZTRcXFxcdTA2ZTdcXFxcdTA2ZThcXFxcdTA2ZWEtXFxcXHUwNmVkXFxcXHUwNzExXFxcXHUwNzMwLVxcXFx1MDc0YVxcXFx1MDdhNi1cXFxcdTA3YjBcXFxcdTA3ZWItXFxcXHUwN2YzXFxcXHUwODE2LVxcXFx1MDgxOVxcXFx1MDgxYi1cXFxcdTA4MjNcXFxcdTA4MjUtXFxcXHUwODI3XFxcXHUwODI5LVxcXFx1MDgyZFxcXFx1MDkwMC1cXFxcdTA5MDJcXFxcdTA5M2NcXFxcdTA5NDEtXFxcXHUwOTQ4XFxcXHUwOTRkXFxcXHUwOTUxLVxcXFx1MDk1NVxcXFx1MDk2MlxcXFx1MDk2M1xcXFx1MDk4MVxcXFx1MDliY1xcXFx1MDliZVxcXFx1MDljMS1cXFxcdTA5YzRcXFxcdTA5Y2RcXFxcdTA5ZDdcXFxcdTA5ZTJcXFxcdTA5ZTNcXFxcdTBhMDFcXFxcdTBhMDJcXFxcdTBhM2NcXFxcdTBhNDFcXFxcdTBhNDJcXFxcdTBhNDdcXFxcdTBhNDhcXFxcdTBhNGItXFxcXHUwYTRkXFxcXHUwYTUxXFxcXHUwYTcwXFxcXHUwYTcxXFxcXHUwYTc1XFxcXHUwYTgxXFxcXHUwYTgyXFxcXHUwYWJjXFxcXHUwYWMxLVxcXFx1MGFjNVxcXFx1MGFjN1xcXFx1MGFjOFxcXFx1MGFjZFxcXFx1MGFlMlxcXFx1MGFlM1xcXFx1MGIwMVxcXFx1MGIzY1xcXFx1MGIzZVxcXFx1MGIzZlxcXFx1MGI0MS1cXFxcdTBiNDRcXFxcdTBiNGRcXFxcdTBiNTZcXFxcdTBiNTdcXFxcdTBiNjJcXFxcdTBiNjNcXFxcdTBiODJcXFxcdTBiYmVcXFxcdTBiYzBcXFxcdTBiY2RcXFxcdTBiZDdcXFxcdTBjM2UtXFxcXHUwYzQwXFxcXHUwYzQ2LVxcXFx1MGM0OFxcXFx1MGM0YS1cXFxcdTBjNGRcXFxcdTBjNTVcXFxcdTBjNTZcXFxcdTBjNjJcXFxcdTBjNjNcXFxcdTBjYmNcXFxcdTBjYmZcXFxcdTBjYzJcXFxcdTBjYzZcXFxcdTBjY2NcXFxcdTBjY2RcXFxcdTBjZDVcXFxcdTBjZDZcXFxcdTBjZTJcXFxcdTBjZTNcXFxcdTBkM2VcXFxcdTBkNDEtXFxcXHUwZDQ0XFxcXHUwZDRkXFxcXHUwZDU3XFxcXHUwZDYyXFxcXHUwZDYzXFxcXHUwZGNhXFxcXHUwZGNmXFxcXHUwZGQyLVxcXFx1MGRkNFxcXFx1MGRkNlxcXFx1MGRkZlxcXFx1MGUzMVxcXFx1MGUzNC1cXFxcdTBlM2FcXFxcdTBlNDctXFxcXHUwZTRlXFxcXHUwZWIxXFxcXHUwZWI0LVxcXFx1MGViOVxcXFx1MGViYlxcXFx1MGViY1xcXFx1MGVjOC1cXFxcdTBlY2RcXFxcdTBmMThcXFxcdTBmMTlcXFxcdTBmMzVcXFxcdTBmMzdcXFxcdTBmMzlcXFxcdTBmNzEtXFxcXHUwZjdlXFxcXHUwZjgwLVxcXFx1MGY4NFxcXFx1MGY4NlxcXFx1MGY4N1xcXFx1MGY5MC1cXFxcdTBmOTdcXFxcdTBmOTktXFxcXHUwZmJjXFxcXHUwZmM2XFxcXHUxMDJkLVxcXFx1MTAzMFxcXFx1MTAzMi1cXFxcdTEwMzdcXFxcdTEwMzlcXFxcdTEwM2FcXFxcdTEwM2RcXFxcdTEwM2VcXFxcdTEwNThcXFxcdTEwNTlcXFxcdTEwNWUtXFxcXHUxMDYwXFxcXHUxMDcxLVxcXFx1MTA3NFxcXFx1MTA4MlxcXFx1MTA4NVxcXFx1MTA4NlxcXFx1MTA4ZFxcXFx1MTA5ZFxcXFx1MTM1ZlxcXFx1MTcxMi1cXFxcdTE3MTRcXFxcdTE3MzItXFxcXHUxNzM0XFxcXHUxNzUyXFxcXHUxNzUzXFxcXHUxNzcyXFxcXHUxNzczXFxcXHUxN2I3LVxcXFx1MTdiZFxcXFx1MTdjNlxcXFx1MTdjOS1cXFxcdTE3ZDNcXFxcdTE3ZGRcXFxcdTE4MGItXFxcXHUxODBkXFxcXHUxOGE5XFxcXHUxOTIwLVxcXFx1MTkyMlxcXFx1MTkyN1xcXFx1MTkyOFxcXFx1MTkzMlxcXFx1MTkzOS1cXFxcdTE5M2JcXFxcdTFhMTdcXFxcdTFhMThcXFxcdTFhNTZcXFxcdTFhNTgtXFxcXHUxYTVlXFxcXHUxYTYwXFxcXHUxYTYyXFxcXHUxYTY1LVxcXFx1MWE2Y1xcXFx1MWE3My1cXFxcdTFhN2NcXFxcdTFhN2ZcXFxcdTFiMDAtXFxcXHUxYjAzXFxcXHUxYjM0XFxcXHUxYjM2LVxcXFx1MWIzYVxcXFx1MWIzY1xcXFx1MWI0MlxcXFx1MWI2Yi1cXFxcdTFiNzNcXFxcdTFiODBcXFxcdTFiODFcXFxcdTFiYTItXFxcXHUxYmE1XFxcXHUxYmE4XFxcXHUxYmE5XFxcXHUxYzJjLVxcXFx1MWMzM1xcXFx1MWMzNlxcXFx1MWMzN1xcXFx1MWNkMC1cXFxcdTFjZDJcXFxcdTFjZDQtXFxcXHUxY2UwXFxcXHUxY2UyLVxcXFx1MWNlOFxcXFx1MWNlZFxcXFx1MWRjMC1cXFxcdTFkZTZcXFxcdTFkZmQtXFxcXHUxZGZmXFxcXHUyMDBjXFxcXHUyMDBkXFxcXHUyMGQwLVxcXFx1MjBmMFxcXFx1MmNlZi1cXFxcdTJjZjFcXFxcdTJkZTAtXFxcXHUyZGZmXFxcXHUzMDJhLVxcXFx1MzAyZlxcXFx1MzA5OVxcXFx1MzA5YVxcXFx1YTY2Zi1cXFxcdWE2NzJcXFxcdWE2N2NcXFxcdWE2N2RcXFxcdWE2ZjBcXFxcdWE2ZjFcXFxcdWE4MDJcXFxcdWE4MDZcXFxcdWE4MGJcXFxcdWE4MjVcXFxcdWE4MjZcXFxcdWE4YzRcXFxcdWE4ZTAtXFxcXHVhOGYxXFxcXHVhOTI2LVxcXFx1YTkyZFxcXFx1YTk0Ny1cXFxcdWE5NTFcXFxcdWE5ODAtXFxcXHVhOTgyXFxcXHVhOWIzXFxcXHVhOWI2LVxcXFx1YTliOVxcXFx1YTliY1xcXFx1YWEyOS1cXFxcdWFhMmVcXFxcdWFhMzFcXFxcdWFhMzJcXFxcdWFhMzVcXFxcdWFhMzZcXFxcdWFhNDNcXFxcdWFhNGNcXFxcdWFhYjBcXFxcdWFhYjItXFxcXHVhYWI0XFxcXHVhYWI3XFxcXHVhYWI4XFxcXHVhYWJlXFxcXHVhYWJmXFxcXHVhYWMxXFxcXHVhYmU1XFxcXHVhYmU4XFxcXHVhYmVkXFxcXHVkYzAwLVxcXFx1ZGZmZlxcXFx1ZmIxZVxcXFx1ZmUwMC1cXFxcdWZlMGZcXFxcdWZlMjAtXFxcXHVmZTI2XFxcXHVmZjllXFxcXHVmZjlmXS9cXG5mdW5jdGlvbiBpc0V4dGVuZGluZ0NoYXIoY2gpIHsgcmV0dXJuIGNoLmNoYXJDb2RlQXQoMCkgPj0gNzY4ICYmIGV4dGVuZGluZ0NoYXJzLnRlc3QoY2gpIH1cXG5cXG4vLyBUaGUgZGlzcGxheSBoYW5kbGVzIHRoZSBET00gaW50ZWdyYXRpb24sIGJvdGggZm9yIGlucHV0IHJlYWRpbmdcXG4vLyBhbmQgY29udGVudCBkcmF3aW5nLiBJdCBob2xkcyByZWZlcmVuY2VzIHRvIERPTSBub2RlcyBhbmRcXG4vLyBkaXNwbGF5LXJlbGF0ZWQgc3RhdGUuXFxuXFxuZnVuY3Rpb24gRGlzcGxheShwbGFjZSwgZG9jLCBpbnB1dCkge1xcbiAgdmFyIGQgPSB0aGlzXFxuICB0aGlzLmlucHV0ID0gaW5wdXRcXG5cXG4gIC8vIENvdmVycyBib3R0b20tcmlnaHQgc3F1YXJlIHdoZW4gYm90aCBzY3JvbGxiYXJzIGFyZSBwcmVzZW50LlxcbiAgZC5zY3JvbGxiYXJGaWxsZXIgPSBlbHQoXFxcImRpdlxcXCIsIG51bGwsIFxcXCJDb2RlTWlycm9yLXNjcm9sbGJhci1maWxsZXJcXFwiKVxcbiAgZC5zY3JvbGxiYXJGaWxsZXIuc2V0QXR0cmlidXRlKFxcXCJjbS1ub3QtY29udGVudFxcXCIsIFxcXCJ0cnVlXFxcIilcXG4gIC8vIENvdmVycyBib3R0b20gb2YgZ3V0dGVyIHdoZW4gY292ZXJHdXR0ZXJOZXh0VG9TY3JvbGxiYXIgaXMgb25cXG4gIC8vIGFuZCBoIHNjcm9sbGJhciBpcyBwcmVzZW50LlxcbiAgZC5ndXR0ZXJGaWxsZXIgPSBlbHQoXFxcImRpdlxcXCIsIG51bGwsIFxcXCJDb2RlTWlycm9yLWd1dHRlci1maWxsZXJcXFwiKVxcbiAgZC5ndXR0ZXJGaWxsZXIuc2V0QXR0cmlidXRlKFxcXCJjbS1ub3QtY29udGVudFxcXCIsIFxcXCJ0cnVlXFxcIilcXG4gIC8vIFdpbGwgY29udGFpbiB0aGUgYWN0dWFsIGNvZGUsIHBvc2l0aW9uZWQgdG8gY292ZXIgdGhlIHZpZXdwb3J0LlxcbiAgZC5saW5lRGl2ID0gZWx0KFxcXCJkaXZcXFwiLCBudWxsLCBcXFwiQ29kZU1pcnJvci1jb2RlXFxcIilcXG4gIC8vIEVsZW1lbnRzIGFyZSBhZGRlZCB0byB0aGVzZSB0byByZXByZXNlbnQgc2VsZWN0aW9uIGFuZCBjdXJzb3JzLlxcbiAgZC5zZWxlY3Rpb25EaXYgPSBlbHQoXFxcImRpdlxcXCIsIG51bGwsIG51bGwsIFxcXCJwb3NpdGlvbjogcmVsYXRpdmU7IHotaW5kZXg6IDFcXFwiKVxcbiAgZC5jdXJzb3JEaXYgPSBlbHQoXFxcImRpdlxcXCIsIG51bGwsIFxcXCJDb2RlTWlycm9yLWN1cnNvcnNcXFwiKVxcbiAgLy8gQSB2aXNpYmlsaXR5OiBoaWRkZW4gZWxlbWVudCB1c2VkIHRvIGZpbmQgdGhlIHNpemUgb2YgdGhpbmdzLlxcbiAgZC5tZWFzdXJlID0gZWx0KFxcXCJkaXZcXFwiLCBudWxsLCBcXFwiQ29kZU1pcnJvci1tZWFzdXJlXFxcIilcXG4gIC8vIFdoZW4gbGluZXMgb3V0c2lkZSBvZiB0aGUgdmlld3BvcnQgYXJlIG1lYXN1cmVkLCB0aGV5IGFyZSBkcmF3biBpbiB0aGlzLlxcbiAgZC5saW5lTWVhc3VyZSA9IGVsdChcXFwiZGl2XFxcIiwgbnVsbCwgXFxcIkNvZGVNaXJyb3ItbWVhc3VyZVxcXCIpXFxuICAvLyBXcmFwcyBldmVyeXRoaW5nIHRoYXQgbmVlZHMgdG8gZXhpc3QgaW5zaWRlIHRoZSB2ZXJ0aWNhbGx5LXBhZGRlZCBjb29yZGluYXRlIHN5c3RlbVxcbiAgZC5saW5lU3BhY2UgPSBlbHQoXFxcImRpdlxcXCIsIFtkLm1lYXN1cmUsIGQubGluZU1lYXN1cmUsIGQuc2VsZWN0aW9uRGl2LCBkLmN1cnNvckRpdiwgZC5saW5lRGl2XSxcXG4gICAgICAgICAgICAgICAgICAgIG51bGwsIFxcXCJwb3NpdGlvbjogcmVsYXRpdmU7IG91dGxpbmU6IG5vbmVcXFwiKVxcbiAgLy8gTW92ZWQgYXJvdW5kIGl0cyBwYXJlbnQgdG8gY292ZXIgdmlzaWJsZSB2aWV3LlxcbiAgZC5tb3ZlciA9IGVsdChcXFwiZGl2XFxcIiwgW2VsdChcXFwiZGl2XFxcIiwgW2QubGluZVNwYWNlXSwgXFxcIkNvZGVNaXJyb3ItbGluZXNcXFwiKV0sIG51bGwsIFxcXCJwb3NpdGlvbjogcmVsYXRpdmVcXFwiKVxcbiAgLy8gU2V0IHRvIHRoZSBoZWlnaHQgb2YgdGhlIGRvY3VtZW50LCBhbGxvd2luZyBzY3JvbGxpbmcuXFxuICBkLnNpemVyID0gZWx0KFxcXCJkaXZcXFwiLCBbZC5tb3Zlcl0sIFxcXCJDb2RlTWlycm9yLXNpemVyXFxcIilcXG4gIGQuc2l6ZXJXaWR0aCA9IG51bGxcXG4gIC8vIEJlaGF2aW9yIG9mIGVsdHMgd2l0aCBvdmVyZmxvdzogYXV0byBhbmQgcGFkZGluZyBpc1xcbiAgLy8gaW5jb25zaXN0ZW50IGFjcm9zcyBicm93c2Vycy4gVGhpcyBpcyB1c2VkIHRvIGVuc3VyZSB0aGVcXG4gIC8vIHNjcm9sbGFibGUgYXJlYSBpcyBiaWcgZW5vdWdoLlxcbiAgZC5oZWlnaHRGb3JjZXIgPSBlbHQoXFxcImRpdlxcXCIsIG51bGwsIG51bGwsIFxcXCJwb3NpdGlvbjogYWJzb2x1dGU7IGhlaWdodDogXFxcIiArIHNjcm9sbGVyR2FwICsgXFxcInB4OyB3aWR0aDogMXB4O1xcXCIpXFxuICAvLyBXaWxsIGNvbnRhaW4gdGhlIGd1dHRlcnMsIGlmIGFueS5cXG4gIGQuZ3V0dGVycyA9IGVsdChcXFwiZGl2XFxcIiwgbnVsbCwgXFxcIkNvZGVNaXJyb3ItZ3V0dGVyc1xcXCIpXFxuICBkLmxpbmVHdXR0ZXIgPSBudWxsXFxuICAvLyBBY3R1YWwgc2Nyb2xsYWJsZSBlbGVtZW50LlxcbiAgZC5zY3JvbGxlciA9IGVsdChcXFwiZGl2XFxcIiwgW2Quc2l6ZXIsIGQuaGVpZ2h0Rm9yY2VyLCBkLmd1dHRlcnNdLCBcXFwiQ29kZU1pcnJvci1zY3JvbGxcXFwiKVxcbiAgZC5zY3JvbGxlci5zZXRBdHRyaWJ1dGUoXFxcInRhYkluZGV4XFxcIiwgXFxcIi0xXFxcIilcXG4gIC8vIFRoZSBlbGVtZW50IGluIHdoaWNoIHRoZSBlZGl0b3IgbGl2ZXMuXFxuICBkLndyYXBwZXIgPSBlbHQoXFxcImRpdlxcXCIsIFtkLnNjcm9sbGJhckZpbGxlciwgZC5ndXR0ZXJGaWxsZXIsIGQuc2Nyb2xsZXJdLCBcXFwiQ29kZU1pcnJvclxcXCIpXFxuXFxuICAvLyBXb3JrIGFyb3VuZCBJRTcgei1pbmRleCBidWcgKG5vdCBwZXJmZWN0LCBoZW5jZSBJRTcgbm90IHJlYWxseSBiZWluZyBzdXBwb3J0ZWQpXFxuICBpZiAoaWUgJiYgaWVfdmVyc2lvbiA8IDgpIHsgZC5ndXR0ZXJzLnN0eWxlLnpJbmRleCA9IC0xOyBkLnNjcm9sbGVyLnN0eWxlLnBhZGRpbmdSaWdodCA9IDAgfVxcbiAgaWYgKCF3ZWJraXQgJiYgIShnZWNrbyAmJiBtb2JpbGUpKSB7IGQuc2Nyb2xsZXIuZHJhZ2dhYmxlID0gdHJ1ZSB9XFxuXFxuICBpZiAocGxhY2UpIHtcXG4gICAgaWYgKHBsYWNlLmFwcGVuZENoaWxkKSB7IHBsYWNlLmFwcGVuZENoaWxkKGQud3JhcHBlcikgfVxcbiAgICBlbHNlIHsgcGxhY2UoZC53cmFwcGVyKSB9XFxuICB9XFxuXFxuICAvLyBDdXJyZW50IHJlbmRlcmVkIHJhbmdlIChtYXkgYmUgYmlnZ2VyIHRoYW4gdGhlIHZpZXcgd2luZG93KS5cXG4gIGQudmlld0Zyb20gPSBkLnZpZXdUbyA9IGRvYy5maXJzdFxcbiAgZC5yZXBvcnRlZFZpZXdGcm9tID0gZC5yZXBvcnRlZFZpZXdUbyA9IGRvYy5maXJzdFxcbiAgLy8gSW5mb3JtYXRpb24gYWJvdXQgdGhlIHJlbmRlcmVkIGxpbmVzLlxcbiAgZC52aWV3ID0gW11cXG4gIGQucmVuZGVyZWRWaWV3ID0gbnVsbFxcbiAgLy8gSG9sZHMgaW5mbyBhYm91dCBhIHNpbmdsZSByZW5kZXJlZCBsaW5lIHdoZW4gaXQgd2FzIHJlbmRlcmVkXFxuICAvLyBmb3IgbWVhc3VyZW1lbnQsIHdoaWxlIG5vdCBpbiB2aWV3LlxcbiAgZC5leHRlcm5hbE1lYXN1cmVkID0gbnVsbFxcbiAgLy8gRW1wdHkgc3BhY2UgKGluIHBpeGVscykgYWJvdmUgdGhlIHZpZXdcXG4gIGQudmlld09mZnNldCA9IDBcXG4gIGQubGFzdFdyYXBIZWlnaHQgPSBkLmxhc3RXcmFwV2lkdGggPSAwXFxuICBkLnVwZGF0ZUxpbmVOdW1iZXJzID0gbnVsbFxcblxcbiAgZC5uYXRpdmVCYXJXaWR0aCA9IGQuYmFySGVpZ2h0ID0gZC5iYXJXaWR0aCA9IDBcXG4gIGQuc2Nyb2xsYmFyc0NsaXBwZWQgPSBmYWxzZVxcblxcbiAgLy8gVXNlZCB0byBvbmx5IHJlc2l6ZSB0aGUgbGluZSBudW1iZXIgZ3V0dGVyIHdoZW4gbmVjZXNzYXJ5ICh3aGVuXFxuICAvLyB0aGUgYW1vdW50IG9mIGxpbmVzIGNyb3NzZXMgYSBib3VuZGFyeSB0aGF0IG1ha2VzIGl0cyB3aWR0aCBjaGFuZ2UpXFxuICBkLmxpbmVOdW1XaWR0aCA9IGQubGluZU51bUlubmVyV2lkdGggPSBkLmxpbmVOdW1DaGFycyA9IG51bGxcXG4gIC8vIFNldCB0byB0cnVlIHdoZW4gYSBub24taG9yaXpvbnRhbC1zY3JvbGxpbmcgbGluZSB3aWRnZXQgaXNcXG4gIC8vIGFkZGVkLiBBcyBhbiBvcHRpbWl6YXRpb24sIGxpbmUgd2lkZ2V0IGFsaWduaW5nIGlzIHNraXBwZWQgd2hlblxcbiAgLy8gdGhpcyBpcyBmYWxzZS5cXG4gIGQuYWxpZ25XaWRnZXRzID0gZmFsc2VcXG5cXG4gIGQuY2FjaGVkQ2hhcldpZHRoID0gZC5jYWNoZWRUZXh0SGVpZ2h0ID0gZC5jYWNoZWRQYWRkaW5nSCA9IG51bGxcXG5cXG4gIC8vIFRyYWNrcyB0aGUgbWF4aW11bSBsaW5lIGxlbmd0aCBzbyB0aGF0IHRoZSBob3Jpem9udGFsIHNjcm9sbGJhclxcbiAgLy8gY2FuIGJlIGtlcHQgc3RhdGljIHdoZW4gc2Nyb2xsaW5nLlxcbiAgZC5tYXhMaW5lID0gbnVsbFxcbiAgZC5tYXhMaW5lTGVuZ3RoID0gMFxcbiAgZC5tYXhMaW5lQ2hhbmdlZCA9IGZhbHNlXFxuXFxuICAvLyBVc2VkIGZvciBtZWFzdXJpbmcgd2hlZWwgc2Nyb2xsaW5nIGdyYW51bGFyaXR5XFxuICBkLndoZWVsRFggPSBkLndoZWVsRFkgPSBkLndoZWVsU3RhcnRYID0gZC53aGVlbFN0YXJ0WSA9IG51bGxcXG5cXG4gIC8vIFRydWUgd2hlbiBzaGlmdCBpcyBoZWxkIGRvd24uXFxuICBkLnNoaWZ0ID0gZmFsc2VcXG5cXG4gIC8vIFVzZWQgdG8gdHJhY2sgd2hldGhlciBhbnl0aGluZyBoYXBwZW5lZCBzaW5jZSB0aGUgY29udGV4dCBtZW51XFxuICAvLyB3YXMgb3BlbmVkLlxcbiAgZC5zZWxGb3JDb250ZXh0TWVudSA9IG51bGxcXG5cXG4gIGQuYWN0aXZlVG91Y2ggPSBudWxsXFxuXFxuICBpbnB1dC5pbml0KGQpXFxufVxcblxcbi8vIEZpbmQgdGhlIGxpbmUgb2JqZWN0IGNvcnJlc3BvbmRpbmcgdG8gdGhlIGdpdmVuIGxpbmUgbnVtYmVyLlxcbmZ1bmN0aW9uIGdldExpbmUoZG9jLCBuKSB7XFxuICBuIC09IGRvYy5maXJzdFxcbiAgaWYgKG4gPCAwIHx8IG4gPj0gZG9jLnNpemUpIHsgdGhyb3cgbmV3IEVycm9yKFxcXCJUaGVyZSBpcyBubyBsaW5lIFxcXCIgKyAobiArIGRvYy5maXJzdCkgKyBcXFwiIGluIHRoZSBkb2N1bWVudC5cXFwiKSB9XFxuICB2YXIgY2h1bmsgPSBkb2NcXG4gIHdoaWxlICghY2h1bmsubGluZXMpIHtcXG4gICAgZm9yICh2YXIgaSA9IDA7OyArK2kpIHtcXG4gICAgICB2YXIgY2hpbGQgPSBjaHVuay5jaGlsZHJlbltpXSwgc3ogPSBjaGlsZC5jaHVua1NpemUoKVxcbiAgICAgIGlmIChuIDwgc3opIHsgY2h1bmsgPSBjaGlsZDsgYnJlYWsgfVxcbiAgICAgIG4gLT0gc3pcXG4gICAgfVxcbiAgfVxcbiAgcmV0dXJuIGNodW5rLmxpbmVzW25dXFxufVxcblxcbi8vIEdldCB0aGUgcGFydCBvZiBhIGRvY3VtZW50IGJldHdlZW4gdHdvIHBvc2l0aW9ucywgYXMgYW4gYXJyYXkgb2ZcXG4vLyBzdHJpbmdzLlxcbmZ1bmN0aW9uIGdldEJldHdlZW4oZG9jLCBzdGFydCwgZW5kKSB7XFxuICB2YXIgb3V0ID0gW10sIG4gPSBzdGFydC5saW5lXFxuICBkb2MuaXRlcihzdGFydC5saW5lLCBlbmQubGluZSArIDEsIGZ1bmN0aW9uIChsaW5lKSB7XFxuICAgIHZhciB0ZXh0ID0gbGluZS50ZXh0XFxuICAgIGlmIChuID09IGVuZC5saW5lKSB7IHRleHQgPSB0ZXh0LnNsaWNlKDAsIGVuZC5jaCkgfVxcbiAgICBpZiAobiA9PSBzdGFydC5saW5lKSB7IHRleHQgPSB0ZXh0LnNsaWNlKHN0YXJ0LmNoKSB9XFxuICAgIG91dC5wdXNoKHRleHQpXFxuICAgICsrblxcbiAgfSlcXG4gIHJldHVybiBvdXRcXG59XFxuLy8gR2V0IHRoZSBsaW5lcyBiZXR3ZWVuIGZyb20gYW5kIHRvLCBhcyBhcnJheSBvZiBzdHJpbmdzLlxcbmZ1bmN0aW9uIGdldExpbmVzKGRvYywgZnJvbSwgdG8pIHtcXG4gIHZhciBvdXQgPSBbXVxcbiAgZG9jLml0ZXIoZnJvbSwgdG8sIGZ1bmN0aW9uIChsaW5lKSB7IG91dC5wdXNoKGxpbmUudGV4dCkgfSkgLy8gaXRlciBhYm9ydHMgd2hlbiBjYWxsYmFjayByZXR1cm5zIHRydXRoeSB2YWx1ZVxcbiAgcmV0dXJuIG91dFxcbn1cXG5cXG4vLyBVcGRhdGUgdGhlIGhlaWdodCBvZiBhIGxpbmUsIHByb3BhZ2F0aW5nIHRoZSBoZWlnaHQgY2hhbmdlXFxuLy8gdXB3YXJkcyB0byBwYXJlbnQgbm9kZXMuXFxuZnVuY3Rpb24gdXBkYXRlTGluZUhlaWdodChsaW5lLCBoZWlnaHQpIHtcXG4gIHZhciBkaWZmID0gaGVpZ2h0IC0gbGluZS5oZWlnaHRcXG4gIGlmIChkaWZmKSB7IGZvciAodmFyIG4gPSBsaW5lOyBuOyBuID0gbi5wYXJlbnQpIHsgbi5oZWlnaHQgKz0gZGlmZiB9IH1cXG59XFxuXFxuLy8gR2l2ZW4gYSBsaW5lIG9iamVjdCwgZmluZCBpdHMgbGluZSBudW1iZXIgYnkgd2Fsa2luZyB1cCB0aHJvdWdoXFxuLy8gaXRzIHBhcmVudCBsaW5rcy5cXG5mdW5jdGlvbiBsaW5lTm8obGluZSkge1xcbiAgaWYgKGxpbmUucGFyZW50ID09IG51bGwpIHsgcmV0dXJuIG51bGwgfVxcbiAgdmFyIGN1ciA9IGxpbmUucGFyZW50LCBubyA9IGluZGV4T2YoY3VyLmxpbmVzLCBsaW5lKVxcbiAgZm9yICh2YXIgY2h1bmsgPSBjdXIucGFyZW50OyBjaHVuazsgY3VyID0gY2h1bmssIGNodW5rID0gY2h1bmsucGFyZW50KSB7XFxuICAgIGZvciAodmFyIGkgPSAwOzsgKytpKSB7XFxuICAgICAgaWYgKGNodW5rLmNoaWxkcmVuW2ldID09IGN1cikgeyBicmVhayB9XFxuICAgICAgbm8gKz0gY2h1bmsuY2hpbGRyZW5baV0uY2h1bmtTaXplKClcXG4gICAgfVxcbiAgfVxcbiAgcmV0dXJuIG5vICsgY3VyLmZpcnN0XFxufVxcblxcbi8vIEZpbmQgdGhlIGxpbmUgYXQgdGhlIGdpdmVuIHZlcnRpY2FsIHBvc2l0aW9uLCB1c2luZyB0aGUgaGVpZ2h0XFxuLy8gaW5mb3JtYXRpb24gaW4gdGhlIGRvY3VtZW50IHRyZWUuXFxuZnVuY3Rpb24gbGluZUF0SGVpZ2h0KGNodW5rLCBoKSB7XFxuICB2YXIgbiA9IGNodW5rLmZpcnN0XFxuICBvdXRlcjogZG8ge1xcbiAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBjaHVuay5jaGlsZHJlbi5sZW5ndGg7ICsraSQxKSB7XFxuICAgICAgdmFyIGNoaWxkID0gY2h1bmsuY2hpbGRyZW5baSQxXSwgY2ggPSBjaGlsZC5oZWlnaHRcXG4gICAgICBpZiAoaCA8IGNoKSB7IGNodW5rID0gY2hpbGQ7IGNvbnRpbnVlIG91dGVyIH1cXG4gICAgICBoIC09IGNoXFxuICAgICAgbiArPSBjaGlsZC5jaHVua1NpemUoKVxcbiAgICB9XFxuICAgIHJldHVybiBuXFxuICB9IHdoaWxlICghY2h1bmsubGluZXMpXFxuICB2YXIgaSA9IDBcXG4gIGZvciAoOyBpIDwgY2h1bmsubGluZXMubGVuZ3RoOyArK2kpIHtcXG4gICAgdmFyIGxpbmUgPSBjaHVuay5saW5lc1tpXSwgbGggPSBsaW5lLmhlaWdodFxcbiAgICBpZiAoaCA8IGxoKSB7IGJyZWFrIH1cXG4gICAgaCAtPSBsaFxcbiAgfVxcbiAgcmV0dXJuIG4gKyBpXFxufVxcblxcbmZ1bmN0aW9uIGlzTGluZShkb2MsIGwpIHtyZXR1cm4gbCA+PSBkb2MuZmlyc3QgJiYgbCA8IGRvYy5maXJzdCArIGRvYy5zaXplfVxcblxcbmZ1bmN0aW9uIGxpbmVOdW1iZXJGb3Iob3B0aW9ucywgaSkge1xcbiAgcmV0dXJuIFN0cmluZyhvcHRpb25zLmxpbmVOdW1iZXJGb3JtYXR0ZXIoaSArIG9wdGlvbnMuZmlyc3RMaW5lTnVtYmVyKSlcXG59XFxuXFxuLy8gQSBQb3MgaW5zdGFuY2UgcmVwcmVzZW50cyBhIHBvc2l0aW9uIHdpdGhpbiB0aGUgdGV4dC5cXG5mdW5jdGlvbiBQb3MgKGxpbmUsIGNoKSB7XFxuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUG9zKSkgeyByZXR1cm4gbmV3IFBvcyhsaW5lLCBjaCkgfVxcbiAgdGhpcy5saW5lID0gbGluZTsgdGhpcy5jaCA9IGNoXFxufVxcblxcbi8vIENvbXBhcmUgdHdvIHBvc2l0aW9ucywgcmV0dXJuIDAgaWYgdGhleSBhcmUgdGhlIHNhbWUsIGEgbmVnYXRpdmVcXG4vLyBudW1iZXIgd2hlbiBhIGlzIGxlc3MsIGFuZCBhIHBvc2l0aXZlIG51bWJlciBvdGhlcndpc2UuXFxuZnVuY3Rpb24gY21wKGEsIGIpIHsgcmV0dXJuIGEubGluZSAtIGIubGluZSB8fCBhLmNoIC0gYi5jaCB9XFxuXFxuZnVuY3Rpb24gY29weVBvcyh4KSB7cmV0dXJuIFBvcyh4LmxpbmUsIHguY2gpfVxcbmZ1bmN0aW9uIG1heFBvcyhhLCBiKSB7IHJldHVybiBjbXAoYSwgYikgPCAwID8gYiA6IGEgfVxcbmZ1bmN0aW9uIG1pblBvcyhhLCBiKSB7IHJldHVybiBjbXAoYSwgYikgPCAwID8gYSA6IGIgfVxcblxcbi8vIE1vc3Qgb2YgdGhlIGV4dGVybmFsIEFQSSBjbGlwcyBnaXZlbiBwb3NpdGlvbnMgdG8gbWFrZSBzdXJlIHRoZXlcXG4vLyBhY3R1YWxseSBleGlzdCB3aXRoaW4gdGhlIGRvY3VtZW50LlxcbmZ1bmN0aW9uIGNsaXBMaW5lKGRvYywgbikge3JldHVybiBNYXRoLm1heChkb2MuZmlyc3QsIE1hdGgubWluKG4sIGRvYy5maXJzdCArIGRvYy5zaXplIC0gMSkpfVxcbmZ1bmN0aW9uIGNsaXBQb3MoZG9jLCBwb3MpIHtcXG4gIGlmIChwb3MubGluZSA8IGRvYy5maXJzdCkgeyByZXR1cm4gUG9zKGRvYy5maXJzdCwgMCkgfVxcbiAgdmFyIGxhc3QgPSBkb2MuZmlyc3QgKyBkb2Muc2l6ZSAtIDFcXG4gIGlmIChwb3MubGluZSA+IGxhc3QpIHsgcmV0dXJuIFBvcyhsYXN0LCBnZXRMaW5lKGRvYywgbGFzdCkudGV4dC5sZW5ndGgpIH1cXG4gIHJldHVybiBjbGlwVG9MZW4ocG9zLCBnZXRMaW5lKGRvYywgcG9zLmxpbmUpLnRleHQubGVuZ3RoKVxcbn1cXG5mdW5jdGlvbiBjbGlwVG9MZW4ocG9zLCBsaW5lbGVuKSB7XFxuICB2YXIgY2ggPSBwb3MuY2hcXG4gIGlmIChjaCA9PSBudWxsIHx8IGNoID4gbGluZWxlbikgeyByZXR1cm4gUG9zKHBvcy5saW5lLCBsaW5lbGVuKSB9XFxuICBlbHNlIGlmIChjaCA8IDApIHsgcmV0dXJuIFBvcyhwb3MubGluZSwgMCkgfVxcbiAgZWxzZSB7IHJldHVybiBwb3MgfVxcbn1cXG5mdW5jdGlvbiBjbGlwUG9zQXJyYXkoZG9jLCBhcnJheSkge1xcbiAgdmFyIG91dCA9IFtdXFxuICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7IG91dFtpXSA9IGNsaXBQb3MoZG9jLCBhcnJheVtpXSkgfVxcbiAgcmV0dXJuIG91dFxcbn1cXG5cXG4vLyBPcHRpbWl6ZSBzb21lIGNvZGUgd2hlbiB0aGVzZSBmZWF0dXJlcyBhcmUgbm90IHVzZWQuXFxudmFyIHNhd1JlYWRPbmx5U3BhbnMgPSBmYWxzZTtcXG52YXIgc2F3Q29sbGFwc2VkU3BhbnMgPSBmYWxzZTtcXG5mdW5jdGlvbiBzZWVSZWFkT25seVNwYW5zKCkge1xcbiAgc2F3UmVhZE9ubHlTcGFucyA9IHRydWVcXG59XFxuXFxuZnVuY3Rpb24gc2VlQ29sbGFwc2VkU3BhbnMoKSB7XFxuICBzYXdDb2xsYXBzZWRTcGFucyA9IHRydWVcXG59XFxuXFxuLy8gVEVYVE1BUktFUiBTUEFOU1xcblxcbmZ1bmN0aW9uIE1hcmtlZFNwYW4obWFya2VyLCBmcm9tLCB0bykge1xcbiAgdGhpcy5tYXJrZXIgPSBtYXJrZXJcXG4gIHRoaXMuZnJvbSA9IGZyb207IHRoaXMudG8gPSB0b1xcbn1cXG5cXG4vLyBTZWFyY2ggYW4gYXJyYXkgb2Ygc3BhbnMgZm9yIGEgc3BhbiBtYXRjaGluZyB0aGUgZ2l2ZW4gbWFya2VyLlxcbmZ1bmN0aW9uIGdldE1hcmtlZFNwYW5Gb3Ioc3BhbnMsIG1hcmtlcikge1xcbiAgaWYgKHNwYW5zKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgc3BhbnMubGVuZ3RoOyArK2kpIHtcXG4gICAgdmFyIHNwYW4gPSBzcGFuc1tpXVxcbiAgICBpZiAoc3Bhbi5tYXJrZXIgPT0gbWFya2VyKSB7IHJldHVybiBzcGFuIH1cXG4gIH0gfVxcbn1cXG4vLyBSZW1vdmUgYSBzcGFuIGZyb20gYW4gYXJyYXksIHJldHVybmluZyB1bmRlZmluZWQgaWYgbm8gc3BhbnMgYXJlXFxuLy8gbGVmdCAod2UgZG9uJ3Qgc3RvcmUgYXJyYXlzIGZvciBsaW5lcyB3aXRob3V0IHNwYW5zKS5cXG5mdW5jdGlvbiByZW1vdmVNYXJrZWRTcGFuKHNwYW5zLCBzcGFuKSB7XFxuICB2YXIgclxcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzcGFucy5sZW5ndGg7ICsraSlcXG4gICAgeyBpZiAoc3BhbnNbaV0gIT0gc3BhbikgeyAociB8fCAociA9IFtdKSkucHVzaChzcGFuc1tpXSkgfSB9XFxuICByZXR1cm4gclxcbn1cXG4vLyBBZGQgYSBzcGFuIHRvIGEgbGluZS5cXG5mdW5jdGlvbiBhZGRNYXJrZWRTcGFuKGxpbmUsIHNwYW4pIHtcXG4gIGxpbmUubWFya2VkU3BhbnMgPSBsaW5lLm1hcmtlZFNwYW5zID8gbGluZS5tYXJrZWRTcGFucy5jb25jYXQoW3NwYW5dKSA6IFtzcGFuXVxcbiAgc3Bhbi5tYXJrZXIuYXR0YWNoTGluZShsaW5lKVxcbn1cXG5cXG4vLyBVc2VkIGZvciB0aGUgYWxnb3JpdGhtIHRoYXQgYWRqdXN0cyBtYXJrZXJzIGZvciBhIGNoYW5nZSBpbiB0aGVcXG4vLyBkb2N1bWVudC4gVGhlc2UgZnVuY3Rpb25zIGN1dCBhbiBhcnJheSBvZiBzcGFucyBhdCBhIGdpdmVuXFxuLy8gY2hhcmFjdGVyIHBvc2l0aW9uLCByZXR1cm5pbmcgYW4gYXJyYXkgb2YgcmVtYWluaW5nIGNodW5rcyAob3JcXG4vLyB1bmRlZmluZWQgaWYgbm90aGluZyByZW1haW5zKS5cXG5mdW5jdGlvbiBtYXJrZWRTcGFuc0JlZm9yZShvbGQsIHN0YXJ0Q2gsIGlzSW5zZXJ0KSB7XFxuICB2YXIgbndcXG4gIGlmIChvbGQpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBvbGQubGVuZ3RoOyArK2kpIHtcXG4gICAgdmFyIHNwYW4gPSBvbGRbaV0sIG1hcmtlciA9IHNwYW4ubWFya2VyXFxuICAgIHZhciBzdGFydHNCZWZvcmUgPSBzcGFuLmZyb20gPT0gbnVsbCB8fCAobWFya2VyLmluY2x1c2l2ZUxlZnQgPyBzcGFuLmZyb20gPD0gc3RhcnRDaCA6IHNwYW4uZnJvbSA8IHN0YXJ0Q2gpXFxuICAgIGlmIChzdGFydHNCZWZvcmUgfHwgc3Bhbi5mcm9tID09IHN0YXJ0Q2ggJiYgbWFya2VyLnR5cGUgPT0gXFxcImJvb2ttYXJrXFxcIiAmJiAoIWlzSW5zZXJ0IHx8ICFzcGFuLm1hcmtlci5pbnNlcnRMZWZ0KSkge1xcbiAgICAgIHZhciBlbmRzQWZ0ZXIgPSBzcGFuLnRvID09IG51bGwgfHwgKG1hcmtlci5pbmNsdXNpdmVSaWdodCA/IHNwYW4udG8gPj0gc3RhcnRDaCA6IHNwYW4udG8gPiBzdGFydENoKVxcbiAgICAgIDsobncgfHwgKG53ID0gW10pKS5wdXNoKG5ldyBNYXJrZWRTcGFuKG1hcmtlciwgc3Bhbi5mcm9tLCBlbmRzQWZ0ZXIgPyBudWxsIDogc3Bhbi50bykpXFxuICAgIH1cXG4gIH0gfVxcbiAgcmV0dXJuIG53XFxufVxcbmZ1bmN0aW9uIG1hcmtlZFNwYW5zQWZ0ZXIob2xkLCBlbmRDaCwgaXNJbnNlcnQpIHtcXG4gIHZhciBud1xcbiAgaWYgKG9sZCkgeyBmb3IgKHZhciBpID0gMDsgaSA8IG9sZC5sZW5ndGg7ICsraSkge1xcbiAgICB2YXIgc3BhbiA9IG9sZFtpXSwgbWFya2VyID0gc3Bhbi5tYXJrZXJcXG4gICAgdmFyIGVuZHNBZnRlciA9IHNwYW4udG8gPT0gbnVsbCB8fCAobWFya2VyLmluY2x1c2l2ZVJpZ2h0ID8gc3Bhbi50byA+PSBlbmRDaCA6IHNwYW4udG8gPiBlbmRDaClcXG4gICAgaWYgKGVuZHNBZnRlciB8fCBzcGFuLmZyb20gPT0gZW5kQ2ggJiYgbWFya2VyLnR5cGUgPT0gXFxcImJvb2ttYXJrXFxcIiAmJiAoIWlzSW5zZXJ0IHx8IHNwYW4ubWFya2VyLmluc2VydExlZnQpKSB7XFxuICAgICAgdmFyIHN0YXJ0c0JlZm9yZSA9IHNwYW4uZnJvbSA9PSBudWxsIHx8IChtYXJrZXIuaW5jbHVzaXZlTGVmdCA/IHNwYW4uZnJvbSA8PSBlbmRDaCA6IHNwYW4uZnJvbSA8IGVuZENoKVxcbiAgICAgIDsobncgfHwgKG53ID0gW10pKS5wdXNoKG5ldyBNYXJrZWRTcGFuKG1hcmtlciwgc3RhcnRzQmVmb3JlID8gbnVsbCA6IHNwYW4uZnJvbSAtIGVuZENoLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3Bhbi50byA9PSBudWxsID8gbnVsbCA6IHNwYW4udG8gLSBlbmRDaCkpXFxuICAgIH1cXG4gIH0gfVxcbiAgcmV0dXJuIG53XFxufVxcblxcbi8vIEdpdmVuIGEgY2hhbmdlIG9iamVjdCwgY29tcHV0ZSB0aGUgbmV3IHNldCBvZiBtYXJrZXIgc3BhbnMgdGhhdFxcbi8vIGNvdmVyIHRoZSBsaW5lIGluIHdoaWNoIHRoZSBjaGFuZ2UgdG9vayBwbGFjZS4gUmVtb3ZlcyBzcGFuc1xcbi8vIGVudGlyZWx5IHdpdGhpbiB0aGUgY2hhbmdlLCByZWNvbm5lY3RzIHNwYW5zIGJlbG9uZ2luZyB0byB0aGVcXG4vLyBzYW1lIG1hcmtlciB0aGF0IGFwcGVhciBvbiBib3RoIHNpZGVzIG9mIHRoZSBjaGFuZ2UsIGFuZCBjdXRzIG9mZlxcbi8vIHNwYW5zIHBhcnRpYWxseSB3aXRoaW4gdGhlIGNoYW5nZS4gUmV0dXJucyBhbiBhcnJheSBvZiBzcGFuXFxuLy8gYXJyYXlzIHdpdGggb25lIGVsZW1lbnQgZm9yIGVhY2ggbGluZSBpbiAoYWZ0ZXIpIHRoZSBjaGFuZ2UuXFxuZnVuY3Rpb24gc3RyZXRjaFNwYW5zT3ZlckNoYW5nZShkb2MsIGNoYW5nZSkge1xcbiAgaWYgKGNoYW5nZS5mdWxsKSB7IHJldHVybiBudWxsIH1cXG4gIHZhciBvbGRGaXJzdCA9IGlzTGluZShkb2MsIGNoYW5nZS5mcm9tLmxpbmUpICYmIGdldExpbmUoZG9jLCBjaGFuZ2UuZnJvbS5saW5lKS5tYXJrZWRTcGFuc1xcbiAgdmFyIG9sZExhc3QgPSBpc0xpbmUoZG9jLCBjaGFuZ2UudG8ubGluZSkgJiYgZ2V0TGluZShkb2MsIGNoYW5nZS50by5saW5lKS5tYXJrZWRTcGFuc1xcbiAgaWYgKCFvbGRGaXJzdCAmJiAhb2xkTGFzdCkgeyByZXR1cm4gbnVsbCB9XFxuXFxuICB2YXIgc3RhcnRDaCA9IGNoYW5nZS5mcm9tLmNoLCBlbmRDaCA9IGNoYW5nZS50by5jaCwgaXNJbnNlcnQgPSBjbXAoY2hhbmdlLmZyb20sIGNoYW5nZS50bykgPT0gMFxcbiAgLy8gR2V0IHRoZSBzcGFucyB0aGF0ICdzdGljayBvdXQnIG9uIGJvdGggc2lkZXNcXG4gIHZhciBmaXJzdCA9IG1hcmtlZFNwYW5zQmVmb3JlKG9sZEZpcnN0LCBzdGFydENoLCBpc0luc2VydClcXG4gIHZhciBsYXN0ID0gbWFya2VkU3BhbnNBZnRlcihvbGRMYXN0LCBlbmRDaCwgaXNJbnNlcnQpXFxuXFxuICAvLyBOZXh0LCBtZXJnZSB0aG9zZSB0d28gZW5kc1xcbiAgdmFyIHNhbWVMaW5lID0gY2hhbmdlLnRleHQubGVuZ3RoID09IDEsIG9mZnNldCA9IGxzdChjaGFuZ2UudGV4dCkubGVuZ3RoICsgKHNhbWVMaW5lID8gc3RhcnRDaCA6IDApXFxuICBpZiAoZmlyc3QpIHtcXG4gICAgLy8gRml4IHVwIC50byBwcm9wZXJ0aWVzIG9mIGZpcnN0XFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmlyc3QubGVuZ3RoOyArK2kpIHtcXG4gICAgICB2YXIgc3BhbiA9IGZpcnN0W2ldXFxuICAgICAgaWYgKHNwYW4udG8gPT0gbnVsbCkge1xcbiAgICAgICAgdmFyIGZvdW5kID0gZ2V0TWFya2VkU3BhbkZvcihsYXN0LCBzcGFuLm1hcmtlcilcXG4gICAgICAgIGlmICghZm91bmQpIHsgc3Bhbi50byA9IHN0YXJ0Q2ggfVxcbiAgICAgICAgZWxzZSBpZiAoc2FtZUxpbmUpIHsgc3Bhbi50byA9IGZvdW5kLnRvID09IG51bGwgPyBudWxsIDogZm91bmQudG8gKyBvZmZzZXQgfVxcbiAgICAgIH1cXG4gICAgfVxcbiAgfVxcbiAgaWYgKGxhc3QpIHtcXG4gICAgLy8gRml4IHVwIC5mcm9tIGluIGxhc3QgKG9yIG1vdmUgdGhlbSBpbnRvIGZpcnN0IGluIGNhc2Ugb2Ygc2FtZUxpbmUpXFxuICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IGxhc3QubGVuZ3RoOyArK2kkMSkge1xcbiAgICAgIHZhciBzcGFuJDEgPSBsYXN0W2kkMV1cXG4gICAgICBpZiAoc3BhbiQxLnRvICE9IG51bGwpIHsgc3BhbiQxLnRvICs9IG9mZnNldCB9XFxuICAgICAgaWYgKHNwYW4kMS5mcm9tID09IG51bGwpIHtcXG4gICAgICAgIHZhciBmb3VuZCQxID0gZ2V0TWFya2VkU3BhbkZvcihmaXJzdCwgc3BhbiQxLm1hcmtlcilcXG4gICAgICAgIGlmICghZm91bmQkMSkge1xcbiAgICAgICAgICBzcGFuJDEuZnJvbSA9IG9mZnNldFxcbiAgICAgICAgICBpZiAoc2FtZUxpbmUpIHsgKGZpcnN0IHx8IChmaXJzdCA9IFtdKSkucHVzaChzcGFuJDEpIH1cXG4gICAgICAgIH1cXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgc3BhbiQxLmZyb20gKz0gb2Zmc2V0XFxuICAgICAgICBpZiAoc2FtZUxpbmUpIHsgKGZpcnN0IHx8IChmaXJzdCA9IFtdKSkucHVzaChzcGFuJDEpIH1cXG4gICAgICB9XFxuICAgIH1cXG4gIH1cXG4gIC8vIE1ha2Ugc3VyZSB3ZSBkaWRuJ3QgY3JlYXRlIGFueSB6ZXJvLWxlbmd0aCBzcGFuc1xcbiAgaWYgKGZpcnN0KSB7IGZpcnN0ID0gY2xlYXJFbXB0eVNwYW5zKGZpcnN0KSB9XFxuICBpZiAobGFzdCAmJiBsYXN0ICE9IGZpcnN0KSB7IGxhc3QgPSBjbGVhckVtcHR5U3BhbnMobGFzdCkgfVxcblxcbiAgdmFyIG5ld01hcmtlcnMgPSBbZmlyc3RdXFxuICBpZiAoIXNhbWVMaW5lKSB7XFxuICAgIC8vIEZpbGwgZ2FwIHdpdGggd2hvbGUtbGluZS1zcGFuc1xcbiAgICB2YXIgZ2FwID0gY2hhbmdlLnRleHQubGVuZ3RoIC0gMiwgZ2FwTWFya2Vyc1xcbiAgICBpZiAoZ2FwID4gMCAmJiBmaXJzdClcXG4gICAgICB7IGZvciAodmFyIGkkMiA9IDA7IGkkMiA8IGZpcnN0Lmxlbmd0aDsgKytpJDIpXFxuICAgICAgICB7IGlmIChmaXJzdFtpJDJdLnRvID09IG51bGwpXFxuICAgICAgICAgIHsgKGdhcE1hcmtlcnMgfHwgKGdhcE1hcmtlcnMgPSBbXSkpLnB1c2gobmV3IE1hcmtlZFNwYW4oZmlyc3RbaSQyXS5tYXJrZXIsIG51bGwsIG51bGwpKSB9IH0gfVxcbiAgICBmb3IgKHZhciBpJDMgPSAwOyBpJDMgPCBnYXA7ICsraSQzKVxcbiAgICAgIHsgbmV3TWFya2Vycy5wdXNoKGdhcE1hcmtlcnMpIH1cXG4gICAgbmV3TWFya2Vycy5wdXNoKGxhc3QpXFxuICB9XFxuICByZXR1cm4gbmV3TWFya2Vyc1xcbn1cXG5cXG4vLyBSZW1vdmUgc3BhbnMgdGhhdCBhcmUgZW1wdHkgYW5kIGRvbid0IGhhdmUgYSBjbGVhcldoZW5FbXB0eVxcbi8vIG9wdGlvbiBvZiBmYWxzZS5cXG5mdW5jdGlvbiBjbGVhckVtcHR5U3BhbnMoc3BhbnMpIHtcXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3BhbnMubGVuZ3RoOyArK2kpIHtcXG4gICAgdmFyIHNwYW4gPSBzcGFuc1tpXVxcbiAgICBpZiAoc3Bhbi5mcm9tICE9IG51bGwgJiYgc3Bhbi5mcm9tID09IHNwYW4udG8gJiYgc3Bhbi5tYXJrZXIuY2xlYXJXaGVuRW1wdHkgIT09IGZhbHNlKVxcbiAgICAgIHsgc3BhbnMuc3BsaWNlKGktLSwgMSkgfVxcbiAgfVxcbiAgaWYgKCFzcGFucy5sZW5ndGgpIHsgcmV0dXJuIG51bGwgfVxcbiAgcmV0dXJuIHNwYW5zXFxufVxcblxcbi8vIFVzZWQgdG8gJ2NsaXAnIG91dCByZWFkT25seSByYW5nZXMgd2hlbiBtYWtpbmcgYSBjaGFuZ2UuXFxuZnVuY3Rpb24gcmVtb3ZlUmVhZE9ubHlSYW5nZXMoZG9jLCBmcm9tLCB0bykge1xcbiAgdmFyIG1hcmtlcnMgPSBudWxsXFxuICBkb2MuaXRlcihmcm9tLmxpbmUsIHRvLmxpbmUgKyAxLCBmdW5jdGlvbiAobGluZSkge1xcbiAgICBpZiAobGluZS5tYXJrZWRTcGFucykgeyBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmUubWFya2VkU3BhbnMubGVuZ3RoOyArK2kpIHtcXG4gICAgICB2YXIgbWFyayA9IGxpbmUubWFya2VkU3BhbnNbaV0ubWFya2VyXFxuICAgICAgaWYgKG1hcmsucmVhZE9ubHkgJiYgKCFtYXJrZXJzIHx8IGluZGV4T2YobWFya2VycywgbWFyaykgPT0gLTEpKVxcbiAgICAgICAgeyAobWFya2VycyB8fCAobWFya2VycyA9IFtdKSkucHVzaChtYXJrKSB9XFxuICAgIH0gfVxcbiAgfSlcXG4gIGlmICghbWFya2VycykgeyByZXR1cm4gbnVsbCB9XFxuICB2YXIgcGFydHMgPSBbe2Zyb206IGZyb20sIHRvOiB0b31dXFxuICBmb3IgKHZhciBpID0gMDsgaSA8IG1hcmtlcnMubGVuZ3RoOyArK2kpIHtcXG4gICAgdmFyIG1rID0gbWFya2Vyc1tpXSwgbSA9IG1rLmZpbmQoMClcXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBwYXJ0cy5sZW5ndGg7ICsraikge1xcbiAgICAgIHZhciBwID0gcGFydHNbal1cXG4gICAgICBpZiAoY21wKHAudG8sIG0uZnJvbSkgPCAwIHx8IGNtcChwLmZyb20sIG0udG8pID4gMCkgeyBjb250aW51ZSB9XFxuICAgICAgdmFyIG5ld1BhcnRzID0gW2osIDFdLCBkZnJvbSA9IGNtcChwLmZyb20sIG0uZnJvbSksIGR0byA9IGNtcChwLnRvLCBtLnRvKVxcbiAgICAgIGlmIChkZnJvbSA8IDAgfHwgIW1rLmluY2x1c2l2ZUxlZnQgJiYgIWRmcm9tKVxcbiAgICAgICAgeyBuZXdQYXJ0cy5wdXNoKHtmcm9tOiBwLmZyb20sIHRvOiBtLmZyb219KSB9XFxuICAgICAgaWYgKGR0byA+IDAgfHwgIW1rLmluY2x1c2l2ZVJpZ2h0ICYmICFkdG8pXFxuICAgICAgICB7IG5ld1BhcnRzLnB1c2goe2Zyb206IG0udG8sIHRvOiBwLnRvfSkgfVxcbiAgICAgIHBhcnRzLnNwbGljZS5hcHBseShwYXJ0cywgbmV3UGFydHMpXFxuICAgICAgaiArPSBuZXdQYXJ0cy5sZW5ndGggLSAxXFxuICAgIH1cXG4gIH1cXG4gIHJldHVybiBwYXJ0c1xcbn1cXG5cXG4vLyBDb25uZWN0IG9yIGRpc2Nvbm5lY3Qgc3BhbnMgZnJvbSBhIGxpbmUuXFxuZnVuY3Rpb24gZGV0YWNoTWFya2VkU3BhbnMobGluZSkge1xcbiAgdmFyIHNwYW5zID0gbGluZS5tYXJrZWRTcGFuc1xcbiAgaWYgKCFzcGFucykgeyByZXR1cm4gfVxcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzcGFucy5sZW5ndGg7ICsraSlcXG4gICAgeyBzcGFuc1tpXS5tYXJrZXIuZGV0YWNoTGluZShsaW5lKSB9XFxuICBsaW5lLm1hcmtlZFNwYW5zID0gbnVsbFxcbn1cXG5mdW5jdGlvbiBhdHRhY2hNYXJrZWRTcGFucyhsaW5lLCBzcGFucykge1xcbiAgaWYgKCFzcGFucykgeyByZXR1cm4gfVxcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzcGFucy5sZW5ndGg7ICsraSlcXG4gICAgeyBzcGFuc1tpXS5tYXJrZXIuYXR0YWNoTGluZShsaW5lKSB9XFxuICBsaW5lLm1hcmtlZFNwYW5zID0gc3BhbnNcXG59XFxuXFxuLy8gSGVscGVycyB1c2VkIHdoZW4gY29tcHV0aW5nIHdoaWNoIG92ZXJsYXBwaW5nIGNvbGxhcHNlZCBzcGFuXFxuLy8gY291bnRzIGFzIHRoZSBsYXJnZXIgb25lLlxcbmZ1bmN0aW9uIGV4dHJhTGVmdChtYXJrZXIpIHsgcmV0dXJuIG1hcmtlci5pbmNsdXNpdmVMZWZ0ID8gLTEgOiAwIH1cXG5mdW5jdGlvbiBleHRyYVJpZ2h0KG1hcmtlcikgeyByZXR1cm4gbWFya2VyLmluY2x1c2l2ZVJpZ2h0ID8gMSA6IDAgfVxcblxcbi8vIFJldHVybnMgYSBudW1iZXIgaW5kaWNhdGluZyB3aGljaCBvZiB0d28gb3ZlcmxhcHBpbmcgY29sbGFwc2VkXFxuLy8gc3BhbnMgaXMgbGFyZ2VyIChhbmQgdGh1cyBpbmNsdWRlcyB0aGUgb3RoZXIpLiBGYWxscyBiYWNrIHRvXFxuLy8gY29tcGFyaW5nIGlkcyB3aGVuIHRoZSBzcGFucyBjb3ZlciBleGFjdGx5IHRoZSBzYW1lIHJhbmdlLlxcbmZ1bmN0aW9uIGNvbXBhcmVDb2xsYXBzZWRNYXJrZXJzKGEsIGIpIHtcXG4gIHZhciBsZW5EaWZmID0gYS5saW5lcy5sZW5ndGggLSBiLmxpbmVzLmxlbmd0aFxcbiAgaWYgKGxlbkRpZmYgIT0gMCkgeyByZXR1cm4gbGVuRGlmZiB9XFxuICB2YXIgYVBvcyA9IGEuZmluZCgpLCBiUG9zID0gYi5maW5kKClcXG4gIHZhciBmcm9tQ21wID0gY21wKGFQb3MuZnJvbSwgYlBvcy5mcm9tKSB8fCBleHRyYUxlZnQoYSkgLSBleHRyYUxlZnQoYilcXG4gIGlmIChmcm9tQ21wKSB7IHJldHVybiAtZnJvbUNtcCB9XFxuICB2YXIgdG9DbXAgPSBjbXAoYVBvcy50bywgYlBvcy50bykgfHwgZXh0cmFSaWdodChhKSAtIGV4dHJhUmlnaHQoYilcXG4gIGlmICh0b0NtcCkgeyByZXR1cm4gdG9DbXAgfVxcbiAgcmV0dXJuIGIuaWQgLSBhLmlkXFxufVxcblxcbi8vIEZpbmQgb3V0IHdoZXRoZXIgYSBsaW5lIGVuZHMgb3Igc3RhcnRzIGluIGEgY29sbGFwc2VkIHNwYW4uIElmXFxuLy8gc28sIHJldHVybiB0aGUgbWFya2VyIGZvciB0aGF0IHNwYW4uXFxuZnVuY3Rpb24gY29sbGFwc2VkU3BhbkF0U2lkZShsaW5lLCBzdGFydCkge1xcbiAgdmFyIHNwcyA9IHNhd0NvbGxhcHNlZFNwYW5zICYmIGxpbmUubWFya2VkU3BhbnMsIGZvdW5kXFxuICBpZiAoc3BzKSB7IGZvciAodmFyIHNwID0gKHZvaWQgMCksIGkgPSAwOyBpIDwgc3BzLmxlbmd0aDsgKytpKSB7XFxuICAgIHNwID0gc3BzW2ldXFxuICAgIGlmIChzcC5tYXJrZXIuY29sbGFwc2VkICYmIChzdGFydCA/IHNwLmZyb20gOiBzcC50bykgPT0gbnVsbCAmJlxcbiAgICAgICAgKCFmb3VuZCB8fCBjb21wYXJlQ29sbGFwc2VkTWFya2Vycyhmb3VuZCwgc3AubWFya2VyKSA8IDApKVxcbiAgICAgIHsgZm91bmQgPSBzcC5tYXJrZXIgfVxcbiAgfSB9XFxuICByZXR1cm4gZm91bmRcXG59XFxuZnVuY3Rpb24gY29sbGFwc2VkU3BhbkF0U3RhcnQobGluZSkgeyByZXR1cm4gY29sbGFwc2VkU3BhbkF0U2lkZShsaW5lLCB0cnVlKSB9XFxuZnVuY3Rpb24gY29sbGFwc2VkU3BhbkF0RW5kKGxpbmUpIHsgcmV0dXJuIGNvbGxhcHNlZFNwYW5BdFNpZGUobGluZSwgZmFsc2UpIH1cXG5cXG4vLyBUZXN0IHdoZXRoZXIgdGhlcmUgZXhpc3RzIGEgY29sbGFwc2VkIHNwYW4gdGhhdCBwYXJ0aWFsbHlcXG4vLyBvdmVybGFwcyAoY292ZXJzIHRoZSBzdGFydCBvciBlbmQsIGJ1dCBub3QgYm90aCkgb2YgYSBuZXcgc3Bhbi5cXG4vLyBTdWNoIG92ZXJsYXAgaXMgbm90IGFsbG93ZWQuXFxuZnVuY3Rpb24gY29uZmxpY3RpbmdDb2xsYXBzZWRSYW5nZShkb2MsIGxpbmVObywgZnJvbSwgdG8sIG1hcmtlcikge1xcbiAgdmFyIGxpbmUgPSBnZXRMaW5lKGRvYywgbGluZU5vKVxcbiAgdmFyIHNwcyA9IHNhd0NvbGxhcHNlZFNwYW5zICYmIGxpbmUubWFya2VkU3BhbnNcXG4gIGlmIChzcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBzcHMubGVuZ3RoOyArK2kpIHtcXG4gICAgdmFyIHNwID0gc3BzW2ldXFxuICAgIGlmICghc3AubWFya2VyLmNvbGxhcHNlZCkgeyBjb250aW51ZSB9XFxuICAgIHZhciBmb3VuZCA9IHNwLm1hcmtlci5maW5kKDApXFxuICAgIHZhciBmcm9tQ21wID0gY21wKGZvdW5kLmZyb20sIGZyb20pIHx8IGV4dHJhTGVmdChzcC5tYXJrZXIpIC0gZXh0cmFMZWZ0KG1hcmtlcilcXG4gICAgdmFyIHRvQ21wID0gY21wKGZvdW5kLnRvLCB0bykgfHwgZXh0cmFSaWdodChzcC5tYXJrZXIpIC0gZXh0cmFSaWdodChtYXJrZXIpXFxuICAgIGlmIChmcm9tQ21wID49IDAgJiYgdG9DbXAgPD0gMCB8fCBmcm9tQ21wIDw9IDAgJiYgdG9DbXAgPj0gMCkgeyBjb250aW51ZSB9XFxuICAgIGlmIChmcm9tQ21wIDw9IDAgJiYgKHNwLm1hcmtlci5pbmNsdXNpdmVSaWdodCAmJiBtYXJrZXIuaW5jbHVzaXZlTGVmdCA/IGNtcChmb3VuZC50bywgZnJvbSkgPj0gMCA6IGNtcChmb3VuZC50bywgZnJvbSkgPiAwKSB8fFxcbiAgICAgICAgZnJvbUNtcCA+PSAwICYmIChzcC5tYXJrZXIuaW5jbHVzaXZlUmlnaHQgJiYgbWFya2VyLmluY2x1c2l2ZUxlZnQgPyBjbXAoZm91bmQuZnJvbSwgdG8pIDw9IDAgOiBjbXAoZm91bmQuZnJvbSwgdG8pIDwgMCkpXFxuICAgICAgeyByZXR1cm4gdHJ1ZSB9XFxuICB9IH1cXG59XFxuXFxuLy8gQSB2aXN1YWwgbGluZSBpcyBhIGxpbmUgYXMgZHJhd24gb24gdGhlIHNjcmVlbi4gRm9sZGluZywgZm9yXFxuLy8gZXhhbXBsZSwgY2FuIGNhdXNlIG11bHRpcGxlIGxvZ2ljYWwgbGluZXMgdG8gYXBwZWFyIG9uIHRoZSBzYW1lXFxuLy8gdmlzdWFsIGxpbmUuIFRoaXMgZmluZHMgdGhlIHN0YXJ0IG9mIHRoZSB2aXN1YWwgbGluZSB0aGF0IHRoZVxcbi8vIGdpdmVuIGxpbmUgaXMgcGFydCBvZiAodXN1YWxseSB0aGF0IGlzIHRoZSBsaW5lIGl0c2VsZikuXFxuZnVuY3Rpb24gdmlzdWFsTGluZShsaW5lKSB7XFxuICB2YXIgbWVyZ2VkXFxuICB3aGlsZSAobWVyZ2VkID0gY29sbGFwc2VkU3BhbkF0U3RhcnQobGluZSkpXFxuICAgIHsgbGluZSA9IG1lcmdlZC5maW5kKC0xLCB0cnVlKS5saW5lIH1cXG4gIHJldHVybiBsaW5lXFxufVxcblxcbi8vIFJldHVybnMgYW4gYXJyYXkgb2YgbG9naWNhbCBsaW5lcyB0aGF0IGNvbnRpbnVlIHRoZSB2aXN1YWwgbGluZVxcbi8vIHN0YXJ0ZWQgYnkgdGhlIGFyZ3VtZW50LCBvciB1bmRlZmluZWQgaWYgdGhlcmUgYXJlIG5vIHN1Y2ggbGluZXMuXFxuZnVuY3Rpb24gdmlzdWFsTGluZUNvbnRpbnVlZChsaW5lKSB7XFxuICB2YXIgbWVyZ2VkLCBsaW5lc1xcbiAgd2hpbGUgKG1lcmdlZCA9IGNvbGxhcHNlZFNwYW5BdEVuZChsaW5lKSkge1xcbiAgICBsaW5lID0gbWVyZ2VkLmZpbmQoMSwgdHJ1ZSkubGluZVxcbiAgICA7KGxpbmVzIHx8IChsaW5lcyA9IFtdKSkucHVzaChsaW5lKVxcbiAgfVxcbiAgcmV0dXJuIGxpbmVzXFxufVxcblxcbi8vIEdldCB0aGUgbGluZSBudW1iZXIgb2YgdGhlIHN0YXJ0IG9mIHRoZSB2aXN1YWwgbGluZSB0aGF0IHRoZVxcbi8vIGdpdmVuIGxpbmUgbnVtYmVyIGlzIHBhcnQgb2YuXFxuZnVuY3Rpb24gdmlzdWFsTGluZU5vKGRvYywgbGluZU4pIHtcXG4gIHZhciBsaW5lID0gZ2V0TGluZShkb2MsIGxpbmVOKSwgdmlzID0gdmlzdWFsTGluZShsaW5lKVxcbiAgaWYgKGxpbmUgPT0gdmlzKSB7IHJldHVybiBsaW5lTiB9XFxuICByZXR1cm4gbGluZU5vKHZpcylcXG59XFxuXFxuLy8gR2V0IHRoZSBsaW5lIG51bWJlciBvZiB0aGUgc3RhcnQgb2YgdGhlIG5leHQgdmlzdWFsIGxpbmUgYWZ0ZXJcXG4vLyB0aGUgZ2l2ZW4gbGluZS5cXG5mdW5jdGlvbiB2aXN1YWxMaW5lRW5kTm8oZG9jLCBsaW5lTikge1xcbiAgaWYgKGxpbmVOID4gZG9jLmxhc3RMaW5lKCkpIHsgcmV0dXJuIGxpbmVOIH1cXG4gIHZhciBsaW5lID0gZ2V0TGluZShkb2MsIGxpbmVOKSwgbWVyZ2VkXFxuICBpZiAoIWxpbmVJc0hpZGRlbihkb2MsIGxpbmUpKSB7IHJldHVybiBsaW5lTiB9XFxuICB3aGlsZSAobWVyZ2VkID0gY29sbGFwc2VkU3BhbkF0RW5kKGxpbmUpKVxcbiAgICB7IGxpbmUgPSBtZXJnZWQuZmluZCgxLCB0cnVlKS5saW5lIH1cXG4gIHJldHVybiBsaW5lTm8obGluZSkgKyAxXFxufVxcblxcbi8vIENvbXB1dGUgd2hldGhlciBhIGxpbmUgaXMgaGlkZGVuLiBMaW5lcyBjb3VudCBhcyBoaWRkZW4gd2hlbiB0aGV5XFxuLy8gYXJlIHBhcnQgb2YgYSB2aXN1YWwgbGluZSB0aGF0IHN0YXJ0cyB3aXRoIGFub3RoZXIgbGluZSwgb3Igd2hlblxcbi8vIHRoZXkgYXJlIGVudGlyZWx5IGNvdmVyZWQgYnkgY29sbGFwc2VkLCBub24td2lkZ2V0IHNwYW4uXFxuZnVuY3Rpb24gbGluZUlzSGlkZGVuKGRvYywgbGluZSkge1xcbiAgdmFyIHNwcyA9IHNhd0NvbGxhcHNlZFNwYW5zICYmIGxpbmUubWFya2VkU3BhbnNcXG4gIGlmIChzcHMpIHsgZm9yICh2YXIgc3AgPSAodm9pZCAwKSwgaSA9IDA7IGkgPCBzcHMubGVuZ3RoOyArK2kpIHtcXG4gICAgc3AgPSBzcHNbaV1cXG4gICAgaWYgKCFzcC5tYXJrZXIuY29sbGFwc2VkKSB7IGNvbnRpbnVlIH1cXG4gICAgaWYgKHNwLmZyb20gPT0gbnVsbCkgeyByZXR1cm4gdHJ1ZSB9XFxuICAgIGlmIChzcC5tYXJrZXIud2lkZ2V0Tm9kZSkgeyBjb250aW51ZSB9XFxuICAgIGlmIChzcC5mcm9tID09IDAgJiYgc3AubWFya2VyLmluY2x1c2l2ZUxlZnQgJiYgbGluZUlzSGlkZGVuSW5uZXIoZG9jLCBsaW5lLCBzcCkpXFxuICAgICAgeyByZXR1cm4gdHJ1ZSB9XFxuICB9IH1cXG59XFxuZnVuY3Rpb24gbGluZUlzSGlkZGVuSW5uZXIoZG9jLCBsaW5lLCBzcGFuKSB7XFxuICBpZiAoc3Bhbi50byA9PSBudWxsKSB7XFxuICAgIHZhciBlbmQgPSBzcGFuLm1hcmtlci5maW5kKDEsIHRydWUpXFxuICAgIHJldHVybiBsaW5lSXNIaWRkZW5Jbm5lcihkb2MsIGVuZC5saW5lLCBnZXRNYXJrZWRTcGFuRm9yKGVuZC5saW5lLm1hcmtlZFNwYW5zLCBzcGFuLm1hcmtlcikpXFxuICB9XFxuICBpZiAoc3Bhbi5tYXJrZXIuaW5jbHVzaXZlUmlnaHQgJiYgc3Bhbi50byA9PSBsaW5lLnRleHQubGVuZ3RoKVxcbiAgICB7IHJldHVybiB0cnVlIH1cXG4gIGZvciAodmFyIHNwID0gKHZvaWQgMCksIGkgPSAwOyBpIDwgbGluZS5tYXJrZWRTcGFucy5sZW5ndGg7ICsraSkge1xcbiAgICBzcCA9IGxpbmUubWFya2VkU3BhbnNbaV1cXG4gICAgaWYgKHNwLm1hcmtlci5jb2xsYXBzZWQgJiYgIXNwLm1hcmtlci53aWRnZXROb2RlICYmIHNwLmZyb20gPT0gc3Bhbi50byAmJlxcbiAgICAgICAgKHNwLnRvID09IG51bGwgfHwgc3AudG8gIT0gc3Bhbi5mcm9tKSAmJlxcbiAgICAgICAgKHNwLm1hcmtlci5pbmNsdXNpdmVMZWZ0IHx8IHNwYW4ubWFya2VyLmluY2x1c2l2ZVJpZ2h0KSAmJlxcbiAgICAgICAgbGluZUlzSGlkZGVuSW5uZXIoZG9jLCBsaW5lLCBzcCkpIHsgcmV0dXJuIHRydWUgfVxcbiAgfVxcbn1cXG5cXG4vLyBGaW5kIHRoZSBoZWlnaHQgYWJvdmUgdGhlIGdpdmVuIGxpbmUuXFxuZnVuY3Rpb24gaGVpZ2h0QXRMaW5lKGxpbmVPYmopIHtcXG4gIGxpbmVPYmogPSB2aXN1YWxMaW5lKGxpbmVPYmopXFxuXFxuICB2YXIgaCA9IDAsIGNodW5rID0gbGluZU9iai5wYXJlbnRcXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY2h1bmsubGluZXMubGVuZ3RoOyArK2kpIHtcXG4gICAgdmFyIGxpbmUgPSBjaHVuay5saW5lc1tpXVxcbiAgICBpZiAobGluZSA9PSBsaW5lT2JqKSB7IGJyZWFrIH1cXG4gICAgZWxzZSB7IGggKz0gbGluZS5oZWlnaHQgfVxcbiAgfVxcbiAgZm9yICh2YXIgcCA9IGNodW5rLnBhcmVudDsgcDsgY2h1bmsgPSBwLCBwID0gY2h1bmsucGFyZW50KSB7XFxuICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IHAuY2hpbGRyZW4ubGVuZ3RoOyArK2kkMSkge1xcbiAgICAgIHZhciBjdXIgPSBwLmNoaWxkcmVuW2kkMV1cXG4gICAgICBpZiAoY3VyID09IGNodW5rKSB7IGJyZWFrIH1cXG4gICAgICBlbHNlIHsgaCArPSBjdXIuaGVpZ2h0IH1cXG4gICAgfVxcbiAgfVxcbiAgcmV0dXJuIGhcXG59XFxuXFxuLy8gQ29tcHV0ZSB0aGUgY2hhcmFjdGVyIGxlbmd0aCBvZiBhIGxpbmUsIHRha2luZyBpbnRvIGFjY291bnRcXG4vLyBjb2xsYXBzZWQgcmFuZ2VzIChzZWUgbWFya1RleHQpIHRoYXQgbWlnaHQgaGlkZSBwYXJ0cywgYW5kIGpvaW5cXG4vLyBvdGhlciBsaW5lcyBvbnRvIGl0LlxcbmZ1bmN0aW9uIGxpbmVMZW5ndGgobGluZSkge1xcbiAgaWYgKGxpbmUuaGVpZ2h0ID09IDApIHsgcmV0dXJuIDAgfVxcbiAgdmFyIGxlbiA9IGxpbmUudGV4dC5sZW5ndGgsIG1lcmdlZCwgY3VyID0gbGluZVxcbiAgd2hpbGUgKG1lcmdlZCA9IGNvbGxhcHNlZFNwYW5BdFN0YXJ0KGN1cikpIHtcXG4gICAgdmFyIGZvdW5kID0gbWVyZ2VkLmZpbmQoMCwgdHJ1ZSlcXG4gICAgY3VyID0gZm91bmQuZnJvbS5saW5lXFxuICAgIGxlbiArPSBmb3VuZC5mcm9tLmNoIC0gZm91bmQudG8uY2hcXG4gIH1cXG4gIGN1ciA9IGxpbmVcXG4gIHdoaWxlIChtZXJnZWQgPSBjb2xsYXBzZWRTcGFuQXRFbmQoY3VyKSkge1xcbiAgICB2YXIgZm91bmQkMSA9IG1lcmdlZC5maW5kKDAsIHRydWUpXFxuICAgIGxlbiAtPSBjdXIudGV4dC5sZW5ndGggLSBmb3VuZCQxLmZyb20uY2hcXG4gICAgY3VyID0gZm91bmQkMS50by5saW5lXFxuICAgIGxlbiArPSBjdXIudGV4dC5sZW5ndGggLSBmb3VuZCQxLnRvLmNoXFxuICB9XFxuICByZXR1cm4gbGVuXFxufVxcblxcbi8vIEZpbmQgdGhlIGxvbmdlc3QgbGluZSBpbiB0aGUgZG9jdW1lbnQuXFxuZnVuY3Rpb24gZmluZE1heExpbmUoY20pIHtcXG4gIHZhciBkID0gY20uZGlzcGxheSwgZG9jID0gY20uZG9jXFxuICBkLm1heExpbmUgPSBnZXRMaW5lKGRvYywgZG9jLmZpcnN0KVxcbiAgZC5tYXhMaW5lTGVuZ3RoID0gbGluZUxlbmd0aChkLm1heExpbmUpXFxuICBkLm1heExpbmVDaGFuZ2VkID0gdHJ1ZVxcbiAgZG9jLml0ZXIoZnVuY3Rpb24gKGxpbmUpIHtcXG4gICAgdmFyIGxlbiA9IGxpbmVMZW5ndGgobGluZSlcXG4gICAgaWYgKGxlbiA+IGQubWF4TGluZUxlbmd0aCkge1xcbiAgICAgIGQubWF4TGluZUxlbmd0aCA9IGxlblxcbiAgICAgIGQubWF4TGluZSA9IGxpbmVcXG4gICAgfVxcbiAgfSlcXG59XFxuXFxuLy8gQklESSBIRUxQRVJTXFxuXFxuZnVuY3Rpb24gaXRlcmF0ZUJpZGlTZWN0aW9ucyhvcmRlciwgZnJvbSwgdG8sIGYpIHtcXG4gIGlmICghb3JkZXIpIHsgcmV0dXJuIGYoZnJvbSwgdG8sIFxcXCJsdHJcXFwiKSB9XFxuICB2YXIgZm91bmQgPSBmYWxzZVxcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcmRlci5sZW5ndGg7ICsraSkge1xcbiAgICB2YXIgcGFydCA9IG9yZGVyW2ldXFxuICAgIGlmIChwYXJ0LmZyb20gPCB0byAmJiBwYXJ0LnRvID4gZnJvbSB8fCBmcm9tID09IHRvICYmIHBhcnQudG8gPT0gZnJvbSkge1xcbiAgICAgIGYoTWF0aC5tYXgocGFydC5mcm9tLCBmcm9tKSwgTWF0aC5taW4ocGFydC50bywgdG8pLCBwYXJ0LmxldmVsID09IDEgPyBcXFwicnRsXFxcIiA6IFxcXCJsdHJcXFwiKVxcbiAgICAgIGZvdW5kID0gdHJ1ZVxcbiAgICB9XFxuICB9XFxuICBpZiAoIWZvdW5kKSB7IGYoZnJvbSwgdG8sIFxcXCJsdHJcXFwiKSB9XFxufVxcblxcbmZ1bmN0aW9uIGJpZGlMZWZ0KHBhcnQpIHsgcmV0dXJuIHBhcnQubGV2ZWwgJSAyID8gcGFydC50byA6IHBhcnQuZnJvbSB9XFxuZnVuY3Rpb24gYmlkaVJpZ2h0KHBhcnQpIHsgcmV0dXJuIHBhcnQubGV2ZWwgJSAyID8gcGFydC5mcm9tIDogcGFydC50byB9XFxuXFxuZnVuY3Rpb24gbGluZUxlZnQobGluZSkgeyB2YXIgb3JkZXIgPSBnZXRPcmRlcihsaW5lKTsgcmV0dXJuIG9yZGVyID8gYmlkaUxlZnQob3JkZXJbMF0pIDogMCB9XFxuZnVuY3Rpb24gbGluZVJpZ2h0KGxpbmUpIHtcXG4gIHZhciBvcmRlciA9IGdldE9yZGVyKGxpbmUpXFxuICBpZiAoIW9yZGVyKSB7IHJldHVybiBsaW5lLnRleHQubGVuZ3RoIH1cXG4gIHJldHVybiBiaWRpUmlnaHQobHN0KG9yZGVyKSlcXG59XFxuXFxuZnVuY3Rpb24gY29tcGFyZUJpZGlMZXZlbChvcmRlciwgYSwgYikge1xcbiAgdmFyIGxpbmVkaXIgPSBvcmRlclswXS5sZXZlbFxcbiAgaWYgKGEgPT0gbGluZWRpcikgeyByZXR1cm4gdHJ1ZSB9XFxuICBpZiAoYiA9PSBsaW5lZGlyKSB7IHJldHVybiBmYWxzZSB9XFxuICByZXR1cm4gYSA8IGJcXG59XFxuXFxudmFyIGJpZGlPdGhlciA9IG51bGxcXG5mdW5jdGlvbiBnZXRCaWRpUGFydEF0KG9yZGVyLCBwb3MpIHtcXG4gIHZhciBmb3VuZFxcbiAgYmlkaU90aGVyID0gbnVsbFxcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcmRlci5sZW5ndGg7ICsraSkge1xcbiAgICB2YXIgY3VyID0gb3JkZXJbaV1cXG4gICAgaWYgKGN1ci5mcm9tIDwgcG9zICYmIGN1ci50byA+IHBvcykgeyByZXR1cm4gaSB9XFxuICAgIGlmICgoY3VyLmZyb20gPT0gcG9zIHx8IGN1ci50byA9PSBwb3MpKSB7XFxuICAgICAgaWYgKGZvdW5kID09IG51bGwpIHtcXG4gICAgICAgIGZvdW5kID0gaVxcbiAgICAgIH0gZWxzZSBpZiAoY29tcGFyZUJpZGlMZXZlbChvcmRlciwgY3VyLmxldmVsLCBvcmRlcltmb3VuZF0ubGV2ZWwpKSB7XFxuICAgICAgICBpZiAoY3VyLmZyb20gIT0gY3VyLnRvKSB7IGJpZGlPdGhlciA9IGZvdW5kIH1cXG4gICAgICAgIHJldHVybiBpXFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIGlmIChjdXIuZnJvbSAhPSBjdXIudG8pIHsgYmlkaU90aGVyID0gaSB9XFxuICAgICAgICByZXR1cm4gZm91bmRcXG4gICAgICB9XFxuICAgIH1cXG4gIH1cXG4gIHJldHVybiBmb3VuZFxcbn1cXG5cXG5mdW5jdGlvbiBtb3ZlSW5MaW5lKGxpbmUsIHBvcywgZGlyLCBieVVuaXQpIHtcXG4gIGlmICghYnlVbml0KSB7IHJldHVybiBwb3MgKyBkaXIgfVxcbiAgZG8geyBwb3MgKz0gZGlyIH1cXG4gIHdoaWxlIChwb3MgPiAwICYmIGlzRXh0ZW5kaW5nQ2hhcihsaW5lLnRleHQuY2hhckF0KHBvcykpKVxcbiAgcmV0dXJuIHBvc1xcbn1cXG5cXG4vLyBUaGlzIGlzIG5lZWRlZCBpbiBvcmRlciB0byBtb3ZlICd2aXN1YWxseScgdGhyb3VnaCBiaS1kaXJlY3Rpb25hbFxcbi8vIHRleHQgLS0gaS5lLiwgcHJlc3NpbmcgbGVmdCBzaG91bGQgbWFrZSB0aGUgY3Vyc29yIGdvIGxlZnQsIGV2ZW5cXG4vLyB3aGVuIGluIFJUTCB0ZXh0LiBUaGUgdHJpY2t5IHBhcnQgaXMgdGhlICdqdW1wcycsIHdoZXJlIFJUTCBhbmRcXG4vLyBMVFIgdGV4dCB0b3VjaCBlYWNoIG90aGVyLiBUaGlzIG9mdGVuIHJlcXVpcmVzIHRoZSBjdXJzb3Igb2Zmc2V0XFxuLy8gdG8gbW92ZSBtb3JlIHRoYW4gb25lIHVuaXQsIGluIG9yZGVyIHRvIHZpc3VhbGx5IG1vdmUgb25lIHVuaXQuXFxuZnVuY3Rpb24gbW92ZVZpc3VhbGx5KGxpbmUsIHN0YXJ0LCBkaXIsIGJ5VW5pdCkge1xcbiAgdmFyIGJpZGkgPSBnZXRPcmRlcihsaW5lKVxcbiAgaWYgKCFiaWRpKSB7IHJldHVybiBtb3ZlTG9naWNhbGx5KGxpbmUsIHN0YXJ0LCBkaXIsIGJ5VW5pdCkgfVxcbiAgdmFyIHBvcyA9IGdldEJpZGlQYXJ0QXQoYmlkaSwgc3RhcnQpLCBwYXJ0ID0gYmlkaVtwb3NdXFxuICB2YXIgdGFyZ2V0ID0gbW92ZUluTGluZShsaW5lLCBzdGFydCwgcGFydC5sZXZlbCAlIDIgPyAtZGlyIDogZGlyLCBieVVuaXQpXFxuXFxuICBmb3IgKDs7KSB7XFxuICAgIGlmICh0YXJnZXQgPiBwYXJ0LmZyb20gJiYgdGFyZ2V0IDwgcGFydC50bykgeyByZXR1cm4gdGFyZ2V0IH1cXG4gICAgaWYgKHRhcmdldCA9PSBwYXJ0LmZyb20gfHwgdGFyZ2V0ID09IHBhcnQudG8pIHtcXG4gICAgICBpZiAoZ2V0QmlkaVBhcnRBdChiaWRpLCB0YXJnZXQpID09IHBvcykgeyByZXR1cm4gdGFyZ2V0IH1cXG4gICAgICBwYXJ0ID0gYmlkaVtwb3MgKz0gZGlyXVxcbiAgICAgIHJldHVybiAoZGlyID4gMCkgPT0gcGFydC5sZXZlbCAlIDIgPyBwYXJ0LnRvIDogcGFydC5mcm9tXFxuICAgIH0gZWxzZSB7XFxuICAgICAgcGFydCA9IGJpZGlbcG9zICs9IGRpcl1cXG4gICAgICBpZiAoIXBhcnQpIHsgcmV0dXJuIG51bGwgfVxcbiAgICAgIGlmICgoZGlyID4gMCkgPT0gcGFydC5sZXZlbCAlIDIpXFxuICAgICAgICB7IHRhcmdldCA9IG1vdmVJbkxpbmUobGluZSwgcGFydC50bywgLTEsIGJ5VW5pdCkgfVxcbiAgICAgIGVsc2VcXG4gICAgICAgIHsgdGFyZ2V0ID0gbW92ZUluTGluZShsaW5lLCBwYXJ0LmZyb20sIDEsIGJ5VW5pdCkgfVxcbiAgICB9XFxuICB9XFxufVxcblxcbmZ1bmN0aW9uIG1vdmVMb2dpY2FsbHkobGluZSwgc3RhcnQsIGRpciwgYnlVbml0KSB7XFxuICB2YXIgdGFyZ2V0ID0gc3RhcnQgKyBkaXJcXG4gIGlmIChieVVuaXQpIHsgd2hpbGUgKHRhcmdldCA+IDAgJiYgaXNFeHRlbmRpbmdDaGFyKGxpbmUudGV4dC5jaGFyQXQodGFyZ2V0KSkpIHsgdGFyZ2V0ICs9IGRpciB9IH1cXG4gIHJldHVybiB0YXJnZXQgPCAwIHx8IHRhcmdldCA+IGxpbmUudGV4dC5sZW5ndGggPyBudWxsIDogdGFyZ2V0XFxufVxcblxcbi8vIEJpZGlyZWN0aW9uYWwgb3JkZXJpbmcgYWxnb3JpdGhtXFxuLy8gU2VlIGh0dHA6Ly91bmljb2RlLm9yZy9yZXBvcnRzL3RyOS90cjktMTMuaHRtbCBmb3IgdGhlIGFsZ29yaXRobVxcbi8vIHRoYXQgdGhpcyAocGFydGlhbGx5KSBpbXBsZW1lbnRzLlxcblxcbi8vIE9uZS1jaGFyIGNvZGVzIHVzZWQgZm9yIGNoYXJhY3RlciB0eXBlczpcXG4vLyBMIChMKTogICBMZWZ0LXRvLVJpZ2h0XFxuLy8gUiAoUik6ICAgUmlnaHQtdG8tTGVmdFxcbi8vIHIgKEFMKTogIFJpZ2h0LXRvLUxlZnQgQXJhYmljXFxuLy8gMSAoRU4pOiAgRXVyb3BlYW4gTnVtYmVyXFxuLy8gKyAoRVMpOiAgRXVyb3BlYW4gTnVtYmVyIFNlcGFyYXRvclxcbi8vICUgKEVUKTogIEV1cm9wZWFuIE51bWJlciBUZXJtaW5hdG9yXFxuLy8gbiAoQU4pOiAgQXJhYmljIE51bWJlclxcbi8vICwgKENTKTogIENvbW1vbiBOdW1iZXIgU2VwYXJhdG9yXFxuLy8gbSAoTlNNKTogTm9uLVNwYWNpbmcgTWFya1xcbi8vIGIgKEJOKTogIEJvdW5kYXJ5IE5ldXRyYWxcXG4vLyBzIChCKTogICBQYXJhZ3JhcGggU2VwYXJhdG9yXFxuLy8gdCAoUyk6ICAgU2VnbWVudCBTZXBhcmF0b3JcXG4vLyB3IChXUyk6ICBXaGl0ZXNwYWNlXFxuLy8gTiAoT04pOiAgT3RoZXIgTmV1dHJhbHNcXG5cXG4vLyBSZXR1cm5zIG51bGwgaWYgY2hhcmFjdGVycyBhcmUgb3JkZXJlZCBhcyB0aGV5IGFwcGVhclxcbi8vIChsZWZ0LXRvLXJpZ2h0KSwgb3IgYW4gYXJyYXkgb2Ygc2VjdGlvbnMgKHtmcm9tLCB0bywgbGV2ZWx9XFxuLy8gb2JqZWN0cykgaW4gdGhlIG9yZGVyIGluIHdoaWNoIHRoZXkgb2NjdXIgdmlzdWFsbHkuXFxudmFyIGJpZGlPcmRlcmluZyA9IChmdW5jdGlvbigpIHtcXG4gIC8vIENoYXJhY3RlciB0eXBlcyBmb3IgY29kZXBvaW50cyAwIHRvIDB4ZmZcXG4gIHZhciBsb3dUeXBlcyA9IFxcXCJiYmJiYmJiYmJ0c3R3c2JiYmJiYmJiYmJiYmJic3NzdHdOTiUlJU5OTk5OTixOLE4xMTExMTExMTExTk5OTk5OTkxMTExMTExMTExMTExMTExMTExMTExMTExMTk5OTk5OTExMTExMTExMTExMTExMTExMTExMTExMTExOTk5OYmJiYmJic2JiYmJiYmJiYmJiYmJiYmJiYmJiYmJiYmJiLE4lJSUlTk5OTkxOTk5OTiUlMTFOTE5OTjFMTk5OTk5MTExMTExMTExMTExMTExMTExMTExMTE5MTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTlxcXCJcXG4gIC8vIENoYXJhY3RlciB0eXBlcyBmb3IgY29kZXBvaW50cyAweDYwMCB0byAweDZmOVxcbiAgdmFyIGFyYWJpY1R5cGVzID0gXFxcIm5ubm5ubk5OciUlcixyTk5tbW1tbW1tbW1tbXJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycm1tbW1tbW1tbW1tbW1tbW1tbW1tbW5ubm5ubm5ubm4lbm5ycnJtcnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJtbW1tbW1tbk5tbW1tbW1ycm1tTm1tbW1ycjExMTExMTExMTFcXFwiXFxuICBmdW5jdGlvbiBjaGFyVHlwZShjb2RlKSB7XFxuICAgIGlmIChjb2RlIDw9IDB4ZjcpIHsgcmV0dXJuIGxvd1R5cGVzLmNoYXJBdChjb2RlKSB9XFxuICAgIGVsc2UgaWYgKDB4NTkwIDw9IGNvZGUgJiYgY29kZSA8PSAweDVmNCkgeyByZXR1cm4gXFxcIlJcXFwiIH1cXG4gICAgZWxzZSBpZiAoMHg2MDAgPD0gY29kZSAmJiBjb2RlIDw9IDB4NmY5KSB7IHJldHVybiBhcmFiaWNUeXBlcy5jaGFyQXQoY29kZSAtIDB4NjAwKSB9XFxuICAgIGVsc2UgaWYgKDB4NmVlIDw9IGNvZGUgJiYgY29kZSA8PSAweDhhYykgeyByZXR1cm4gXFxcInJcXFwiIH1cXG4gICAgZWxzZSBpZiAoMHgyMDAwIDw9IGNvZGUgJiYgY29kZSA8PSAweDIwMGIpIHsgcmV0dXJuIFxcXCJ3XFxcIiB9XFxuICAgIGVsc2UgaWYgKGNvZGUgPT0gMHgyMDBjKSB7IHJldHVybiBcXFwiYlxcXCIgfVxcbiAgICBlbHNlIHsgcmV0dXJuIFxcXCJMXFxcIiB9XFxuICB9XFxuXFxuICB2YXIgYmlkaVJFID0gL1tcXFxcdTA1OTAtXFxcXHUwNWY0XFxcXHUwNjAwLVxcXFx1MDZmZlxcXFx1MDcwMC1cXFxcdTA4YWNdL1xcbiAgdmFyIGlzTmV1dHJhbCA9IC9bc3R3Tl0vLCBpc1N0cm9uZyA9IC9bTFJyXS8sIGNvdW50c0FzTGVmdCA9IC9bTGIxbl0vLCBjb3VudHNBc051bSA9IC9bMW5dL1xcbiAgLy8gQnJvd3NlcnMgc2VlbSB0byBhbHdheXMgdHJlYXQgdGhlIGJvdW5kYXJpZXMgb2YgYmxvY2sgZWxlbWVudHMgYXMgYmVpbmcgTC5cXG4gIHZhciBvdXRlclR5cGUgPSBcXFwiTFxcXCJcXG5cXG4gIGZ1bmN0aW9uIEJpZGlTcGFuKGxldmVsLCBmcm9tLCB0bykge1xcbiAgICB0aGlzLmxldmVsID0gbGV2ZWxcXG4gICAgdGhpcy5mcm9tID0gZnJvbTsgdGhpcy50byA9IHRvXFxuICB9XFxuXFxuICByZXR1cm4gZnVuY3Rpb24oc3RyKSB7XFxuICAgIGlmICghYmlkaVJFLnRlc3Qoc3RyKSkgeyByZXR1cm4gZmFsc2UgfVxcbiAgICB2YXIgbGVuID0gc3RyLmxlbmd0aCwgdHlwZXMgPSBbXVxcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKVxcbiAgICAgIHsgdHlwZXMucHVzaChjaGFyVHlwZShzdHIuY2hhckNvZGVBdChpKSkpIH1cXG5cXG4gICAgLy8gVzEuIEV4YW1pbmUgZWFjaCBub24tc3BhY2luZyBtYXJrIChOU00pIGluIHRoZSBsZXZlbCBydW4sIGFuZFxcbiAgICAvLyBjaGFuZ2UgdGhlIHR5cGUgb2YgdGhlIE5TTSB0byB0aGUgdHlwZSBvZiB0aGUgcHJldmlvdXNcXG4gICAgLy8gY2hhcmFjdGVyLiBJZiB0aGUgTlNNIGlzIGF0IHRoZSBzdGFydCBvZiB0aGUgbGV2ZWwgcnVuLCBpdCB3aWxsXFxuICAgIC8vIGdldCB0aGUgdHlwZSBvZiBzb3IuXFxuICAgIGZvciAodmFyIGkkMSA9IDAsIHByZXYgPSBvdXRlclR5cGU7IGkkMSA8IGxlbjsgKytpJDEpIHtcXG4gICAgICB2YXIgdHlwZSA9IHR5cGVzW2kkMV1cXG4gICAgICBpZiAodHlwZSA9PSBcXFwibVxcXCIpIHsgdHlwZXNbaSQxXSA9IHByZXYgfVxcbiAgICAgIGVsc2UgeyBwcmV2ID0gdHlwZSB9XFxuICAgIH1cXG5cXG4gICAgLy8gVzIuIFNlYXJjaCBiYWNrd2FyZHMgZnJvbSBlYWNoIGluc3RhbmNlIG9mIGEgRXVyb3BlYW4gbnVtYmVyXFxuICAgIC8vIHVudGlsIHRoZSBmaXJzdCBzdHJvbmcgdHlwZSAoUiwgTCwgQUwsIG9yIHNvcikgaXMgZm91bmQuIElmIGFuXFxuICAgIC8vIEFMIGlzIGZvdW5kLCBjaGFuZ2UgdGhlIHR5cGUgb2YgdGhlIEV1cm9wZWFuIG51bWJlciB0byBBcmFiaWNcXG4gICAgLy8gbnVtYmVyLlxcbiAgICAvLyBXMy4gQ2hhbmdlIGFsbCBBTHMgdG8gUi5cXG4gICAgZm9yICh2YXIgaSQyID0gMCwgY3VyID0gb3V0ZXJUeXBlOyBpJDIgPCBsZW47ICsraSQyKSB7XFxuICAgICAgdmFyIHR5cGUkMSA9IHR5cGVzW2kkMl1cXG4gICAgICBpZiAodHlwZSQxID09IFxcXCIxXFxcIiAmJiBjdXIgPT0gXFxcInJcXFwiKSB7IHR5cGVzW2kkMl0gPSBcXFwiblxcXCIgfVxcbiAgICAgIGVsc2UgaWYgKGlzU3Ryb25nLnRlc3QodHlwZSQxKSkgeyBjdXIgPSB0eXBlJDE7IGlmICh0eXBlJDEgPT0gXFxcInJcXFwiKSB7IHR5cGVzW2kkMl0gPSBcXFwiUlxcXCIgfSB9XFxuICAgIH1cXG5cXG4gICAgLy8gVzQuIEEgc2luZ2xlIEV1cm9wZWFuIHNlcGFyYXRvciBiZXR3ZWVuIHR3byBFdXJvcGVhbiBudW1iZXJzXFxuICAgIC8vIGNoYW5nZXMgdG8gYSBFdXJvcGVhbiBudW1iZXIuIEEgc2luZ2xlIGNvbW1vbiBzZXBhcmF0b3IgYmV0d2VlblxcbiAgICAvLyB0d28gbnVtYmVycyBvZiB0aGUgc2FtZSB0eXBlIGNoYW5nZXMgdG8gdGhhdCB0eXBlLlxcbiAgICBmb3IgKHZhciBpJDMgPSAxLCBwcmV2JDEgPSB0eXBlc1swXTsgaSQzIDwgbGVuIC0gMTsgKytpJDMpIHtcXG4gICAgICB2YXIgdHlwZSQyID0gdHlwZXNbaSQzXVxcbiAgICAgIGlmICh0eXBlJDIgPT0gXFxcIitcXFwiICYmIHByZXYkMSA9PSBcXFwiMVxcXCIgJiYgdHlwZXNbaSQzKzFdID09IFxcXCIxXFxcIikgeyB0eXBlc1tpJDNdID0gXFxcIjFcXFwiIH1cXG4gICAgICBlbHNlIGlmICh0eXBlJDIgPT0gXFxcIixcXFwiICYmIHByZXYkMSA9PSB0eXBlc1tpJDMrMV0gJiZcXG4gICAgICAgICAgICAgICAocHJldiQxID09IFxcXCIxXFxcIiB8fCBwcmV2JDEgPT0gXFxcIm5cXFwiKSkgeyB0eXBlc1tpJDNdID0gcHJldiQxIH1cXG4gICAgICBwcmV2JDEgPSB0eXBlJDJcXG4gICAgfVxcblxcbiAgICAvLyBXNS4gQSBzZXF1ZW5jZSBvZiBFdXJvcGVhbiB0ZXJtaW5hdG9ycyBhZGphY2VudCB0byBFdXJvcGVhblxcbiAgICAvLyBudW1iZXJzIGNoYW5nZXMgdG8gYWxsIEV1cm9wZWFuIG51bWJlcnMuXFxuICAgIC8vIFc2LiBPdGhlcndpc2UsIHNlcGFyYXRvcnMgYW5kIHRlcm1pbmF0b3JzIGNoYW5nZSB0byBPdGhlclxcbiAgICAvLyBOZXV0cmFsLlxcbiAgICBmb3IgKHZhciBpJDQgPSAwOyBpJDQgPCBsZW47ICsraSQ0KSB7XFxuICAgICAgdmFyIHR5cGUkMyA9IHR5cGVzW2kkNF1cXG4gICAgICBpZiAodHlwZSQzID09IFxcXCIsXFxcIikgeyB0eXBlc1tpJDRdID0gXFxcIk5cXFwiIH1cXG4gICAgICBlbHNlIGlmICh0eXBlJDMgPT0gXFxcIiVcXFwiKSB7XFxuICAgICAgICB2YXIgZW5kID0gKHZvaWQgMClcXG4gICAgICAgIGZvciAoZW5kID0gaSQ0ICsgMTsgZW5kIDwgbGVuICYmIHR5cGVzW2VuZF0gPT0gXFxcIiVcXFwiOyArK2VuZCkge31cXG4gICAgICAgIHZhciByZXBsYWNlID0gKGkkNCAmJiB0eXBlc1tpJDQtMV0gPT0gXFxcIiFcXFwiKSB8fCAoZW5kIDwgbGVuICYmIHR5cGVzW2VuZF0gPT0gXFxcIjFcXFwiKSA/IFxcXCIxXFxcIiA6IFxcXCJOXFxcIlxcbiAgICAgICAgZm9yICh2YXIgaiA9IGkkNDsgaiA8IGVuZDsgKytqKSB7IHR5cGVzW2pdID0gcmVwbGFjZSB9XFxuICAgICAgICBpJDQgPSBlbmQgLSAxXFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIC8vIFc3LiBTZWFyY2ggYmFja3dhcmRzIGZyb20gZWFjaCBpbnN0YW5jZSBvZiBhIEV1cm9wZWFuIG51bWJlclxcbiAgICAvLyB1bnRpbCB0aGUgZmlyc3Qgc3Ryb25nIHR5cGUgKFIsIEwsIG9yIHNvcikgaXMgZm91bmQuIElmIGFuIEwgaXNcXG4gICAgLy8gZm91bmQsIHRoZW4gY2hhbmdlIHRoZSB0eXBlIG9mIHRoZSBFdXJvcGVhbiBudW1iZXIgdG8gTC5cXG4gICAgZm9yICh2YXIgaSQ1ID0gMCwgY3VyJDEgPSBvdXRlclR5cGU7IGkkNSA8IGxlbjsgKytpJDUpIHtcXG4gICAgICB2YXIgdHlwZSQ0ID0gdHlwZXNbaSQ1XVxcbiAgICAgIGlmIChjdXIkMSA9PSBcXFwiTFxcXCIgJiYgdHlwZSQ0ID09IFxcXCIxXFxcIikgeyB0eXBlc1tpJDVdID0gXFxcIkxcXFwiIH1cXG4gICAgICBlbHNlIGlmIChpc1N0cm9uZy50ZXN0KHR5cGUkNCkpIHsgY3VyJDEgPSB0eXBlJDQgfVxcbiAgICB9XFxuXFxuICAgIC8vIE4xLiBBIHNlcXVlbmNlIG9mIG5ldXRyYWxzIHRha2VzIHRoZSBkaXJlY3Rpb24gb2YgdGhlXFxuICAgIC8vIHN1cnJvdW5kaW5nIHN0cm9uZyB0ZXh0IGlmIHRoZSB0ZXh0IG9uIGJvdGggc2lkZXMgaGFzIHRoZSBzYW1lXFxuICAgIC8vIGRpcmVjdGlvbi4gRXVyb3BlYW4gYW5kIEFyYWJpYyBudW1iZXJzIGFjdCBhcyBpZiB0aGV5IHdlcmUgUiBpblxcbiAgICAvLyB0ZXJtcyBvZiB0aGVpciBpbmZsdWVuY2Ugb24gbmV1dHJhbHMuIFN0YXJ0LW9mLWxldmVsLXJ1biAoc29yKVxcbiAgICAvLyBhbmQgZW5kLW9mLWxldmVsLXJ1biAoZW9yKSBhcmUgdXNlZCBhdCBsZXZlbCBydW4gYm91bmRhcmllcy5cXG4gICAgLy8gTjIuIEFueSByZW1haW5pbmcgbmV1dHJhbHMgdGFrZSB0aGUgZW1iZWRkaW5nIGRpcmVjdGlvbi5cXG4gICAgZm9yICh2YXIgaSQ2ID0gMDsgaSQ2IDwgbGVuOyArK2kkNikge1xcbiAgICAgIGlmIChpc05ldXRyYWwudGVzdCh0eXBlc1tpJDZdKSkge1xcbiAgICAgICAgdmFyIGVuZCQxID0gKHZvaWQgMClcXG4gICAgICAgIGZvciAoZW5kJDEgPSBpJDYgKyAxOyBlbmQkMSA8IGxlbiAmJiBpc05ldXRyYWwudGVzdCh0eXBlc1tlbmQkMV0pOyArK2VuZCQxKSB7fVxcbiAgICAgICAgdmFyIGJlZm9yZSA9IChpJDYgPyB0eXBlc1tpJDYtMV0gOiBvdXRlclR5cGUpID09IFxcXCJMXFxcIlxcbiAgICAgICAgdmFyIGFmdGVyID0gKGVuZCQxIDwgbGVuID8gdHlwZXNbZW5kJDFdIDogb3V0ZXJUeXBlKSA9PSBcXFwiTFxcXCJcXG4gICAgICAgIHZhciByZXBsYWNlJDEgPSBiZWZvcmUgfHwgYWZ0ZXIgPyBcXFwiTFxcXCIgOiBcXFwiUlxcXCJcXG4gICAgICAgIGZvciAodmFyIGokMSA9IGkkNjsgaiQxIDwgZW5kJDE7ICsraiQxKSB7IHR5cGVzW2okMV0gPSByZXBsYWNlJDEgfVxcbiAgICAgICAgaSQ2ID0gZW5kJDEgLSAxXFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIC8vIEhlcmUgd2UgZGVwYXJ0IGZyb20gdGhlIGRvY3VtZW50ZWQgYWxnb3JpdGhtLCBpbiBvcmRlciB0byBhdm9pZFxcbiAgICAvLyBidWlsZGluZyB1cCBhbiBhY3R1YWwgbGV2ZWxzIGFycmF5LiBTaW5jZSB0aGVyZSBhcmUgb25seSB0aHJlZVxcbiAgICAvLyBsZXZlbHMgKDAsIDEsIDIpIGluIGFuIGltcGxlbWVudGF0aW9uIHRoYXQgZG9lc24ndCB0YWtlXFxuICAgIC8vIGV4cGxpY2l0IGVtYmVkZGluZyBpbnRvIGFjY291bnQsIHdlIGNhbiBidWlsZCB1cCB0aGUgb3JkZXIgb25cXG4gICAgLy8gdGhlIGZseSwgd2l0aG91dCBmb2xsb3dpbmcgdGhlIGxldmVsLWJhc2VkIGFsZ29yaXRobS5cXG4gICAgdmFyIG9yZGVyID0gW10sIG1cXG4gICAgZm9yICh2YXIgaSQ3ID0gMDsgaSQ3IDwgbGVuOykge1xcbiAgICAgIGlmIChjb3VudHNBc0xlZnQudGVzdCh0eXBlc1tpJDddKSkge1xcbiAgICAgICAgdmFyIHN0YXJ0ID0gaSQ3XFxuICAgICAgICBmb3IgKCsraSQ3OyBpJDcgPCBsZW4gJiYgY291bnRzQXNMZWZ0LnRlc3QodHlwZXNbaSQ3XSk7ICsraSQ3KSB7fVxcbiAgICAgICAgb3JkZXIucHVzaChuZXcgQmlkaVNwYW4oMCwgc3RhcnQsIGkkNykpXFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIHZhciBwb3MgPSBpJDcsIGF0ID0gb3JkZXIubGVuZ3RoXFxuICAgICAgICBmb3IgKCsraSQ3OyBpJDcgPCBsZW4gJiYgdHlwZXNbaSQ3XSAhPSBcXFwiTFxcXCI7ICsraSQ3KSB7fVxcbiAgICAgICAgZm9yICh2YXIgaiQyID0gcG9zOyBqJDIgPCBpJDc7KSB7XFxuICAgICAgICAgIGlmIChjb3VudHNBc051bS50ZXN0KHR5cGVzW2okMl0pKSB7XFxuICAgICAgICAgICAgaWYgKHBvcyA8IGokMikgeyBvcmRlci5zcGxpY2UoYXQsIDAsIG5ldyBCaWRpU3BhbigxLCBwb3MsIGokMikpIH1cXG4gICAgICAgICAgICB2YXIgbnN0YXJ0ID0gaiQyXFxuICAgICAgICAgICAgZm9yICgrK2okMjsgaiQyIDwgaSQ3ICYmIGNvdW50c0FzTnVtLnRlc3QodHlwZXNbaiQyXSk7ICsraiQyKSB7fVxcbiAgICAgICAgICAgIG9yZGVyLnNwbGljZShhdCwgMCwgbmV3IEJpZGlTcGFuKDIsIG5zdGFydCwgaiQyKSlcXG4gICAgICAgICAgICBwb3MgPSBqJDJcXG4gICAgICAgICAgfSBlbHNlIHsgKytqJDIgfVxcbiAgICAgICAgfVxcbiAgICAgICAgaWYgKHBvcyA8IGkkNykgeyBvcmRlci5zcGxpY2UoYXQsIDAsIG5ldyBCaWRpU3BhbigxLCBwb3MsIGkkNykpIH1cXG4gICAgICB9XFxuICAgIH1cXG4gICAgaWYgKG9yZGVyWzBdLmxldmVsID09IDEgJiYgKG0gPSBzdHIubWF0Y2goL15cXFxccysvKSkpIHtcXG4gICAgICBvcmRlclswXS5mcm9tID0gbVswXS5sZW5ndGhcXG4gICAgICBvcmRlci51bnNoaWZ0KG5ldyBCaWRpU3BhbigwLCAwLCBtWzBdLmxlbmd0aCkpXFxuICAgIH1cXG4gICAgaWYgKGxzdChvcmRlcikubGV2ZWwgPT0gMSAmJiAobSA9IHN0ci5tYXRjaCgvXFxcXHMrJC8pKSkge1xcbiAgICAgIGxzdChvcmRlcikudG8gLT0gbVswXS5sZW5ndGhcXG4gICAgICBvcmRlci5wdXNoKG5ldyBCaWRpU3BhbigwLCBsZW4gLSBtWzBdLmxlbmd0aCwgbGVuKSlcXG4gICAgfVxcbiAgICBpZiAob3JkZXJbMF0ubGV2ZWwgPT0gMilcXG4gICAgICB7IG9yZGVyLnVuc2hpZnQobmV3IEJpZGlTcGFuKDEsIG9yZGVyWzBdLnRvLCBvcmRlclswXS50bykpIH1cXG4gICAgaWYgKG9yZGVyWzBdLmxldmVsICE9IGxzdChvcmRlcikubGV2ZWwpXFxuICAgICAgeyBvcmRlci5wdXNoKG5ldyBCaWRpU3BhbihvcmRlclswXS5sZXZlbCwgbGVuLCBsZW4pKSB9XFxuXFxuICAgIHJldHVybiBvcmRlclxcbiAgfVxcbn0pKClcXG5cXG4vLyBHZXQgdGhlIGJpZGkgb3JkZXJpbmcgZm9yIHRoZSBnaXZlbiBsaW5lIChhbmQgY2FjaGUgaXQpLiBSZXR1cm5zXFxuLy8gZmFsc2UgZm9yIGxpbmVzIHRoYXQgYXJlIGZ1bGx5IGxlZnQtdG8tcmlnaHQsIGFuZCBhbiBhcnJheSBvZlxcbi8vIEJpZGlTcGFuIG9iamVjdHMgb3RoZXJ3aXNlLlxcbmZ1bmN0aW9uIGdldE9yZGVyKGxpbmUpIHtcXG4gIHZhciBvcmRlciA9IGxpbmUub3JkZXJcXG4gIGlmIChvcmRlciA9PSBudWxsKSB7IG9yZGVyID0gbGluZS5vcmRlciA9IGJpZGlPcmRlcmluZyhsaW5lLnRleHQpIH1cXG4gIHJldHVybiBvcmRlclxcbn1cXG5cXG4vLyBFVkVOVCBIQU5ETElOR1xcblxcbi8vIExpZ2h0d2VpZ2h0IGV2ZW50IGZyYW1ld29yay4gb24vb2ZmIGFsc28gd29yayBvbiBET00gbm9kZXMsXFxuLy8gcmVnaXN0ZXJpbmcgbmF0aXZlIERPTSBoYW5kbGVycy5cXG5cXG52YXIgbm9IYW5kbGVycyA9IFtdXFxuXFxudmFyIG9uID0gZnVuY3Rpb24oZW1pdHRlciwgdHlwZSwgZikge1xcbiAgaWYgKGVtaXR0ZXIuYWRkRXZlbnRMaXN0ZW5lcikge1xcbiAgICBlbWl0dGVyLmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgZiwgZmFsc2UpXFxuICB9IGVsc2UgaWYgKGVtaXR0ZXIuYXR0YWNoRXZlbnQpIHtcXG4gICAgZW1pdHRlci5hdHRhY2hFdmVudChcXFwib25cXFwiICsgdHlwZSwgZilcXG4gIH0gZWxzZSB7XFxuICAgIHZhciBtYXAgPSBlbWl0dGVyLl9oYW5kbGVycyB8fCAoZW1pdHRlci5faGFuZGxlcnMgPSB7fSlcXG4gICAgbWFwW3R5cGVdID0gKG1hcFt0eXBlXSB8fCBub0hhbmRsZXJzKS5jb25jYXQoZilcXG4gIH1cXG59XFxuXFxuZnVuY3Rpb24gZ2V0SGFuZGxlcnMoZW1pdHRlciwgdHlwZSkge1xcbiAgcmV0dXJuIGVtaXR0ZXIuX2hhbmRsZXJzICYmIGVtaXR0ZXIuX2hhbmRsZXJzW3R5cGVdIHx8IG5vSGFuZGxlcnNcXG59XFxuXFxuZnVuY3Rpb24gb2ZmKGVtaXR0ZXIsIHR5cGUsIGYpIHtcXG4gIGlmIChlbWl0dGVyLnJlbW92ZUV2ZW50TGlzdGVuZXIpIHtcXG4gICAgZW1pdHRlci5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGYsIGZhbHNlKVxcbiAgfSBlbHNlIGlmIChlbWl0dGVyLmRldGFjaEV2ZW50KSB7XFxuICAgIGVtaXR0ZXIuZGV0YWNoRXZlbnQoXFxcIm9uXFxcIiArIHR5cGUsIGYpXFxuICB9IGVsc2Uge1xcbiAgICB2YXIgbWFwID0gZW1pdHRlci5faGFuZGxlcnMsIGFyciA9IG1hcCAmJiBtYXBbdHlwZV1cXG4gICAgaWYgKGFycikge1xcbiAgICAgIHZhciBpbmRleCA9IGluZGV4T2YoYXJyLCBmKVxcbiAgICAgIGlmIChpbmRleCA+IC0xKVxcbiAgICAgICAgeyBtYXBbdHlwZV0gPSBhcnIuc2xpY2UoMCwgaW5kZXgpLmNvbmNhdChhcnIuc2xpY2UoaW5kZXggKyAxKSkgfVxcbiAgICB9XFxuICB9XFxufVxcblxcbmZ1bmN0aW9uIHNpZ25hbChlbWl0dGVyLCB0eXBlIC8qLCB2YWx1ZXMuLi4qLykge1xcbiAgdmFyIGhhbmRsZXJzID0gZ2V0SGFuZGxlcnMoZW1pdHRlciwgdHlwZSlcXG4gIGlmICghaGFuZGxlcnMubGVuZ3RoKSB7IHJldHVybiB9XFxuICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMilcXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgaGFuZGxlcnMubGVuZ3RoOyArK2kpIHsgaGFuZGxlcnNbaV0uYXBwbHkobnVsbCwgYXJncykgfVxcbn1cXG5cXG4vLyBUaGUgRE9NIGV2ZW50cyB0aGF0IENvZGVNaXJyb3IgaGFuZGxlcyBjYW4gYmUgb3ZlcnJpZGRlbiBieVxcbi8vIHJlZ2lzdGVyaW5nIGEgKG5vbi1ET00pIGhhbmRsZXIgb24gdGhlIGVkaXRvciBmb3IgdGhlIGV2ZW50IG5hbWUsXFxuLy8gYW5kIHByZXZlbnREZWZhdWx0LWluZyB0aGUgZXZlbnQgaW4gdGhhdCBoYW5kbGVyLlxcbmZ1bmN0aW9uIHNpZ25hbERPTUV2ZW50KGNtLCBlLCBvdmVycmlkZSkge1xcbiAgaWYgKHR5cGVvZiBlID09IFxcXCJzdHJpbmdcXFwiKVxcbiAgICB7IGUgPSB7dHlwZTogZSwgcHJldmVudERlZmF1bHQ6IGZ1bmN0aW9uKCkgeyB0aGlzLmRlZmF1bHRQcmV2ZW50ZWQgPSB0cnVlIH19IH1cXG4gIHNpZ25hbChjbSwgb3ZlcnJpZGUgfHwgZS50eXBlLCBjbSwgZSlcXG4gIHJldHVybiBlX2RlZmF1bHRQcmV2ZW50ZWQoZSkgfHwgZS5jb2RlbWlycm9ySWdub3JlXFxufVxcblxcbmZ1bmN0aW9uIHNpZ25hbEN1cnNvckFjdGl2aXR5KGNtKSB7XFxuICB2YXIgYXJyID0gY20uX2hhbmRsZXJzICYmIGNtLl9oYW5kbGVycy5jdXJzb3JBY3Rpdml0eVxcbiAgaWYgKCFhcnIpIHsgcmV0dXJuIH1cXG4gIHZhciBzZXQgPSBjbS5jdXJPcC5jdXJzb3JBY3Rpdml0eUhhbmRsZXJzIHx8IChjbS5jdXJPcC5jdXJzb3JBY3Rpdml0eUhhbmRsZXJzID0gW10pXFxuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7ICsraSkgeyBpZiAoaW5kZXhPZihzZXQsIGFycltpXSkgPT0gLTEpXFxuICAgIHsgc2V0LnB1c2goYXJyW2ldKSB9IH1cXG59XFxuXFxuZnVuY3Rpb24gaGFzSGFuZGxlcihlbWl0dGVyLCB0eXBlKSB7XFxuICByZXR1cm4gZ2V0SGFuZGxlcnMoZW1pdHRlciwgdHlwZSkubGVuZ3RoID4gMFxcbn1cXG5cXG4vLyBBZGQgb24gYW5kIG9mZiBtZXRob2RzIHRvIGEgY29uc3RydWN0b3IncyBwcm90b3R5cGUsIHRvIG1ha2VcXG4vLyByZWdpc3RlcmluZyBldmVudHMgb24gc3VjaCBvYmplY3RzIG1vcmUgY29udmVuaWVudC5cXG5mdW5jdGlvbiBldmVudE1peGluKGN0b3IpIHtcXG4gIGN0b3IucHJvdG90eXBlLm9uID0gZnVuY3Rpb24odHlwZSwgZikge29uKHRoaXMsIHR5cGUsIGYpfVxcbiAgY3Rvci5wcm90b3R5cGUub2ZmID0gZnVuY3Rpb24odHlwZSwgZikge29mZih0aGlzLCB0eXBlLCBmKX1cXG59XFxuXFxuLy8gRHVlIHRvIHRoZSBmYWN0IHRoYXQgd2Ugc3RpbGwgc3VwcG9ydCBqdXJhc3NpYyBJRSB2ZXJzaW9ucywgc29tZVxcbi8vIGNvbXBhdGliaWxpdHkgd3JhcHBlcnMgYXJlIG5lZWRlZC5cXG5cXG5mdW5jdGlvbiBlX3ByZXZlbnREZWZhdWx0KGUpIHtcXG4gIGlmIChlLnByZXZlbnREZWZhdWx0KSB7IGUucHJldmVudERlZmF1bHQoKSB9XFxuICBlbHNlIHsgZS5yZXR1cm5WYWx1ZSA9IGZhbHNlIH1cXG59XFxuZnVuY3Rpb24gZV9zdG9wUHJvcGFnYXRpb24oZSkge1xcbiAgaWYgKGUuc3RvcFByb3BhZ2F0aW9uKSB7IGUuc3RvcFByb3BhZ2F0aW9uKCkgfVxcbiAgZWxzZSB7IGUuY2FuY2VsQnViYmxlID0gdHJ1ZSB9XFxufVxcbmZ1bmN0aW9uIGVfZGVmYXVsdFByZXZlbnRlZChlKSB7XFxuICByZXR1cm4gZS5kZWZhdWx0UHJldmVudGVkICE9IG51bGwgPyBlLmRlZmF1bHRQcmV2ZW50ZWQgOiBlLnJldHVyblZhbHVlID09IGZhbHNlXFxufVxcbmZ1bmN0aW9uIGVfc3RvcChlKSB7ZV9wcmV2ZW50RGVmYXVsdChlKTsgZV9zdG9wUHJvcGFnYXRpb24oZSl9XFxuXFxuZnVuY3Rpb24gZV90YXJnZXQoZSkge3JldHVybiBlLnRhcmdldCB8fCBlLnNyY0VsZW1lbnR9XFxuZnVuY3Rpb24gZV9idXR0b24oZSkge1xcbiAgdmFyIGIgPSBlLndoaWNoXFxuICBpZiAoYiA9PSBudWxsKSB7XFxuICAgIGlmIChlLmJ1dHRvbiAmIDEpIHsgYiA9IDEgfVxcbiAgICBlbHNlIGlmIChlLmJ1dHRvbiAmIDIpIHsgYiA9IDMgfVxcbiAgICBlbHNlIGlmIChlLmJ1dHRvbiAmIDQpIHsgYiA9IDIgfVxcbiAgfVxcbiAgaWYgKG1hYyAmJiBlLmN0cmxLZXkgJiYgYiA9PSAxKSB7IGIgPSAzIH1cXG4gIHJldHVybiBiXFxufVxcblxcbi8vIERldGVjdCBkcmFnLWFuZC1kcm9wXFxudmFyIGRyYWdBbmREcm9wID0gZnVuY3Rpb24oKSB7XFxuICAvLyBUaGVyZSBpcyAqc29tZSoga2luZCBvZiBkcmFnLWFuZC1kcm9wIHN1cHBvcnQgaW4gSUU2LTgsIGJ1dCBJXFxuICAvLyBjb3VsZG4ndCBnZXQgaXQgdG8gd29yayB5ZXQuXFxuICBpZiAoaWUgJiYgaWVfdmVyc2lvbiA8IDkpIHsgcmV0dXJuIGZhbHNlIH1cXG4gIHZhciBkaXYgPSBlbHQoJ2RpdicpXFxuICByZXR1cm4gXFxcImRyYWdnYWJsZVxcXCIgaW4gZGl2IHx8IFxcXCJkcmFnRHJvcFxcXCIgaW4gZGl2XFxufSgpXFxuXFxudmFyIHp3c3BTdXBwb3J0ZWRcXG5mdW5jdGlvbiB6ZXJvV2lkdGhFbGVtZW50KG1lYXN1cmUpIHtcXG4gIGlmICh6d3NwU3VwcG9ydGVkID09IG51bGwpIHtcXG4gICAgdmFyIHRlc3QgPSBlbHQoXFxcInNwYW5cXFwiLCBcXFwiXFxcXHUyMDBiXFxcIilcXG4gICAgcmVtb3ZlQ2hpbGRyZW5BbmRBZGQobWVhc3VyZSwgZWx0KFxcXCJzcGFuXFxcIiwgW3Rlc3QsIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFxcXCJ4XFxcIildKSlcXG4gICAgaWYgKG1lYXN1cmUuZmlyc3RDaGlsZC5vZmZzZXRIZWlnaHQgIT0gMClcXG4gICAgICB7IHp3c3BTdXBwb3J0ZWQgPSB0ZXN0Lm9mZnNldFdpZHRoIDw9IDEgJiYgdGVzdC5vZmZzZXRIZWlnaHQgPiAyICYmICEoaWUgJiYgaWVfdmVyc2lvbiA8IDgpIH1cXG4gIH1cXG4gIHZhciBub2RlID0gendzcFN1cHBvcnRlZCA/IGVsdChcXFwic3BhblxcXCIsIFxcXCJcXFxcdTIwMGJcXFwiKSA6XFxuICAgIGVsdChcXFwic3BhblxcXCIsIFxcXCJcXFxcdTAwYTBcXFwiLCBudWxsLCBcXFwiZGlzcGxheTogaW5saW5lLWJsb2NrOyB3aWR0aDogMXB4OyBtYXJnaW4tcmlnaHQ6IC0xcHhcXFwiKVxcbiAgbm9kZS5zZXRBdHRyaWJ1dGUoXFxcImNtLXRleHRcXFwiLCBcXFwiXFxcIilcXG4gIHJldHVybiBub2RlXFxufVxcblxcbi8vIEZlYXR1cmUtZGV0ZWN0IElFJ3MgY3J1bW15IGNsaWVudCByZWN0IHJlcG9ydGluZyBmb3IgYmlkaSB0ZXh0XFxudmFyIGJhZEJpZGlSZWN0c1xcbmZ1bmN0aW9uIGhhc0JhZEJpZGlSZWN0cyhtZWFzdXJlKSB7XFxuICBpZiAoYmFkQmlkaVJlY3RzICE9IG51bGwpIHsgcmV0dXJuIGJhZEJpZGlSZWN0cyB9XFxuICB2YXIgdHh0ID0gcmVtb3ZlQ2hpbGRyZW5BbmRBZGQobWVhc3VyZSwgZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXFxcIkFcXFxcdTA2MmVBXFxcIikpXFxuICB2YXIgcjAgPSByYW5nZSh0eHQsIDAsIDEpLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXFxuICB2YXIgcjEgPSByYW5nZSh0eHQsIDEsIDIpLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXFxuICByZW1vdmVDaGlsZHJlbihtZWFzdXJlKVxcbiAgaWYgKCFyMCB8fCByMC5sZWZ0ID09IHIwLnJpZ2h0KSB7IHJldHVybiBmYWxzZSB9IC8vIFNhZmFyaSByZXR1cm5zIG51bGwgaW4gc29tZSBjYXNlcyAoIzI3ODApXFxuICByZXR1cm4gYmFkQmlkaVJlY3RzID0gKHIxLnJpZ2h0IC0gcjAucmlnaHQgPCAzKVxcbn1cXG5cXG4vLyBTZWUgaWYgXFxcIlxcXCIuc3BsaXQgaXMgdGhlIGJyb2tlbiBJRSB2ZXJzaW9uLCBpZiBzbywgcHJvdmlkZSBhblxcbi8vIGFsdGVybmF0aXZlIHdheSB0byBzcGxpdCBsaW5lcy5cXG52YXIgc3BsaXRMaW5lc0F1dG8gPSBcXFwiXFxcXG5cXFxcbmJcXFwiLnNwbGl0KC9cXFxcbi8pLmxlbmd0aCAhPSAzID8gZnVuY3Rpb24gKHN0cmluZykge1xcbiAgdmFyIHBvcyA9IDAsIHJlc3VsdCA9IFtdLCBsID0gc3RyaW5nLmxlbmd0aFxcbiAgd2hpbGUgKHBvcyA8PSBsKSB7XFxuICAgIHZhciBubCA9IHN0cmluZy5pbmRleE9mKFxcXCJcXFxcblxcXCIsIHBvcylcXG4gICAgaWYgKG5sID09IC0xKSB7IG5sID0gc3RyaW5nLmxlbmd0aCB9XFxuICAgIHZhciBsaW5lID0gc3RyaW5nLnNsaWNlKHBvcywgc3RyaW5nLmNoYXJBdChubCAtIDEpID09IFxcXCJcXFxcclxcXCIgPyBubCAtIDEgOiBubClcXG4gICAgdmFyIHJ0ID0gbGluZS5pbmRleE9mKFxcXCJcXFxcclxcXCIpXFxuICAgIGlmIChydCAhPSAtMSkge1xcbiAgICAgIHJlc3VsdC5wdXNoKGxpbmUuc2xpY2UoMCwgcnQpKVxcbiAgICAgIHBvcyArPSBydCArIDFcXG4gICAgfSBlbHNlIHtcXG4gICAgICByZXN1bHQucHVzaChsaW5lKVxcbiAgICAgIHBvcyA9IG5sICsgMVxcbiAgICB9XFxuICB9XFxuICByZXR1cm4gcmVzdWx0XFxufSA6IGZ1bmN0aW9uIChzdHJpbmcpIHsgcmV0dXJuIHN0cmluZy5zcGxpdCgvXFxcXHJcXFxcbj98XFxcXG4vKTsgfVxcblxcbnZhciBoYXNTZWxlY3Rpb24gPSB3aW5kb3cuZ2V0U2VsZWN0aW9uID8gZnVuY3Rpb24gKHRlKSB7XFxuICB0cnkgeyByZXR1cm4gdGUuc2VsZWN0aW9uU3RhcnQgIT0gdGUuc2VsZWN0aW9uRW5kIH1cXG4gIGNhdGNoKGUpIHsgcmV0dXJuIGZhbHNlIH1cXG59IDogZnVuY3Rpb24gKHRlKSB7XFxuICB2YXIgcmFuZ2VcXG4gIHRyeSB7cmFuZ2UgPSB0ZS5vd25lckRvY3VtZW50LnNlbGVjdGlvbi5jcmVhdGVSYW5nZSgpfVxcbiAgY2F0Y2goZSkge31cXG4gIGlmICghcmFuZ2UgfHwgcmFuZ2UucGFyZW50RWxlbWVudCgpICE9IHRlKSB7IHJldHVybiBmYWxzZSB9XFxuICByZXR1cm4gcmFuZ2UuY29tcGFyZUVuZFBvaW50cyhcXFwiU3RhcnRUb0VuZFxcXCIsIHJhbmdlKSAhPSAwXFxufVxcblxcbnZhciBoYXNDb3B5RXZlbnQgPSAoZnVuY3Rpb24gKCkge1xcbiAgdmFyIGUgPSBlbHQoXFxcImRpdlxcXCIpXFxuICBpZiAoXFxcIm9uY29weVxcXCIgaW4gZSkgeyByZXR1cm4gdHJ1ZSB9XFxuICBlLnNldEF0dHJpYnV0ZShcXFwib25jb3B5XFxcIiwgXFxcInJldHVybjtcXFwiKVxcbiAgcmV0dXJuIHR5cGVvZiBlLm9uY29weSA9PSBcXFwiZnVuY3Rpb25cXFwiXFxufSkoKVxcblxcbnZhciBiYWRab29tZWRSZWN0cyA9IG51bGxcXG5mdW5jdGlvbiBoYXNCYWRab29tZWRSZWN0cyhtZWFzdXJlKSB7XFxuICBpZiAoYmFkWm9vbWVkUmVjdHMgIT0gbnVsbCkgeyByZXR1cm4gYmFkWm9vbWVkUmVjdHMgfVxcbiAgdmFyIG5vZGUgPSByZW1vdmVDaGlsZHJlbkFuZEFkZChtZWFzdXJlLCBlbHQoXFxcInNwYW5cXFwiLCBcXFwieFxcXCIpKVxcbiAgdmFyIG5vcm1hbCA9IG5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClcXG4gIHZhciBmcm9tUmFuZ2UgPSByYW5nZShub2RlLCAwLCAxKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxcbiAgcmV0dXJuIGJhZFpvb21lZFJlY3RzID0gTWF0aC5hYnMobm9ybWFsLmxlZnQgLSBmcm9tUmFuZ2UubGVmdCkgPiAxXFxufVxcblxcbnZhciBtb2RlcyA9IHt9O1xcbnZhciBtaW1lTW9kZXMgPSB7fTtcXG4vLyBFeHRyYSBhcmd1bWVudHMgYXJlIHN0b3JlZCBhcyB0aGUgbW9kZSdzIGRlcGVuZGVuY2llcywgd2hpY2ggaXNcXG4vLyB1c2VkIGJ5IChsZWdhY3kpIG1lY2hhbmlzbXMgbGlrZSBsb2FkbW9kZS5qcyB0byBhdXRvbWF0aWNhbGx5XFxuLy8gbG9hZCBhIG1vZGUuIChQcmVmZXJyZWQgbWVjaGFuaXNtIGlzIHRoZSByZXF1aXJlL2RlZmluZSBjYWxscy4pXFxuZnVuY3Rpb24gZGVmaW5lTW9kZShuYW1lLCBtb2RlKSB7XFxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDIpXFxuICAgIHsgbW9kZS5kZXBlbmRlbmNpZXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpIH1cXG4gIG1vZGVzW25hbWVdID0gbW9kZVxcbn1cXG5cXG5mdW5jdGlvbiBkZWZpbmVNSU1FKG1pbWUsIHNwZWMpIHtcXG4gIG1pbWVNb2Rlc1ttaW1lXSA9IHNwZWNcXG59XFxuXFxuLy8gR2l2ZW4gYSBNSU1FIHR5cGUsIGEge25hbWUsIC4uLm9wdGlvbnN9IGNvbmZpZyBvYmplY3QsIG9yIGEgbmFtZVxcbi8vIHN0cmluZywgcmV0dXJuIGEgbW9kZSBjb25maWcgb2JqZWN0LlxcbmZ1bmN0aW9uIHJlc29sdmVNb2RlKHNwZWMpIHtcXG4gIGlmICh0eXBlb2Ygc3BlYyA9PSBcXFwic3RyaW5nXFxcIiAmJiBtaW1lTW9kZXMuaGFzT3duUHJvcGVydHkoc3BlYykpIHtcXG4gICAgc3BlYyA9IG1pbWVNb2Rlc1tzcGVjXVxcbiAgfSBlbHNlIGlmIChzcGVjICYmIHR5cGVvZiBzcGVjLm5hbWUgPT0gXFxcInN0cmluZ1xcXCIgJiYgbWltZU1vZGVzLmhhc093blByb3BlcnR5KHNwZWMubmFtZSkpIHtcXG4gICAgdmFyIGZvdW5kID0gbWltZU1vZGVzW3NwZWMubmFtZV1cXG4gICAgaWYgKHR5cGVvZiBmb3VuZCA9PSBcXFwic3RyaW5nXFxcIikgeyBmb3VuZCA9IHtuYW1lOiBmb3VuZH0gfVxcbiAgICBzcGVjID0gY3JlYXRlT2JqKGZvdW5kLCBzcGVjKVxcbiAgICBzcGVjLm5hbWUgPSBmb3VuZC5uYW1lXFxuICB9IGVsc2UgaWYgKHR5cGVvZiBzcGVjID09IFxcXCJzdHJpbmdcXFwiICYmIC9eW1xcXFx3XFxcXC1dK1xcXFwvW1xcXFx3XFxcXC1dK1xcXFwreG1sJC8udGVzdChzcGVjKSkge1xcbiAgICByZXR1cm4gcmVzb2x2ZU1vZGUoXFxcImFwcGxpY2F0aW9uL3htbFxcXCIpXFxuICB9IGVsc2UgaWYgKHR5cGVvZiBzcGVjID09IFxcXCJzdHJpbmdcXFwiICYmIC9eW1xcXFx3XFxcXC1dK1xcXFwvW1xcXFx3XFxcXC1dK1xcXFwranNvbiQvLnRlc3Qoc3BlYykpIHtcXG4gICAgcmV0dXJuIHJlc29sdmVNb2RlKFxcXCJhcHBsaWNhdGlvbi9qc29uXFxcIilcXG4gIH1cXG4gIGlmICh0eXBlb2Ygc3BlYyA9PSBcXFwic3RyaW5nXFxcIikgeyByZXR1cm4ge25hbWU6IHNwZWN9IH1cXG4gIGVsc2UgeyByZXR1cm4gc3BlYyB8fCB7bmFtZTogXFxcIm51bGxcXFwifSB9XFxufVxcblxcbi8vIEdpdmVuIGEgbW9kZSBzcGVjIChhbnl0aGluZyB0aGF0IHJlc29sdmVNb2RlIGFjY2VwdHMpLCBmaW5kIGFuZFxcbi8vIGluaXRpYWxpemUgYW4gYWN0dWFsIG1vZGUgb2JqZWN0LlxcbmZ1bmN0aW9uIGdldE1vZGUob3B0aW9ucywgc3BlYykge1xcbiAgc3BlYyA9IHJlc29sdmVNb2RlKHNwZWMpXFxuICB2YXIgbWZhY3RvcnkgPSBtb2Rlc1tzcGVjLm5hbWVdXFxuICBpZiAoIW1mYWN0b3J5KSB7IHJldHVybiBnZXRNb2RlKG9wdGlvbnMsIFxcXCJ0ZXh0L3BsYWluXFxcIikgfVxcbiAgdmFyIG1vZGVPYmogPSBtZmFjdG9yeShvcHRpb25zLCBzcGVjKVxcbiAgaWYgKG1vZGVFeHRlbnNpb25zLmhhc093blByb3BlcnR5KHNwZWMubmFtZSkpIHtcXG4gICAgdmFyIGV4dHMgPSBtb2RlRXh0ZW5zaW9uc1tzcGVjLm5hbWVdXFxuICAgIGZvciAodmFyIHByb3AgaW4gZXh0cykge1xcbiAgICAgIGlmICghZXh0cy5oYXNPd25Qcm9wZXJ0eShwcm9wKSkgeyBjb250aW51ZSB9XFxuICAgICAgaWYgKG1vZGVPYmouaGFzT3duUHJvcGVydHkocHJvcCkpIHsgbW9kZU9ialtcXFwiX1xcXCIgKyBwcm9wXSA9IG1vZGVPYmpbcHJvcF0gfVxcbiAgICAgIG1vZGVPYmpbcHJvcF0gPSBleHRzW3Byb3BdXFxuICAgIH1cXG4gIH1cXG4gIG1vZGVPYmoubmFtZSA9IHNwZWMubmFtZVxcbiAgaWYgKHNwZWMuaGVscGVyVHlwZSkgeyBtb2RlT2JqLmhlbHBlclR5cGUgPSBzcGVjLmhlbHBlclR5cGUgfVxcbiAgaWYgKHNwZWMubW9kZVByb3BzKSB7IGZvciAodmFyIHByb3AkMSBpbiBzcGVjLm1vZGVQcm9wcylcXG4gICAgeyBtb2RlT2JqW3Byb3AkMV0gPSBzcGVjLm1vZGVQcm9wc1twcm9wJDFdIH0gfVxcblxcbiAgcmV0dXJuIG1vZGVPYmpcXG59XFxuXFxuLy8gVGhpcyBjYW4gYmUgdXNlZCB0byBhdHRhY2ggcHJvcGVydGllcyB0byBtb2RlIG9iamVjdHMgZnJvbVxcbi8vIG91dHNpZGUgdGhlIGFjdHVhbCBtb2RlIGRlZmluaXRpb24uXFxudmFyIG1vZGVFeHRlbnNpb25zID0ge31cXG5mdW5jdGlvbiBleHRlbmRNb2RlKG1vZGUsIHByb3BlcnRpZXMpIHtcXG4gIHZhciBleHRzID0gbW9kZUV4dGVuc2lvbnMuaGFzT3duUHJvcGVydHkobW9kZSkgPyBtb2RlRXh0ZW5zaW9uc1ttb2RlXSA6IChtb2RlRXh0ZW5zaW9uc1ttb2RlXSA9IHt9KVxcbiAgY29weU9iaihwcm9wZXJ0aWVzLCBleHRzKVxcbn1cXG5cXG5mdW5jdGlvbiBjb3B5U3RhdGUobW9kZSwgc3RhdGUpIHtcXG4gIGlmIChzdGF0ZSA9PT0gdHJ1ZSkgeyByZXR1cm4gc3RhdGUgfVxcbiAgaWYgKG1vZGUuY29weVN0YXRlKSB7IHJldHVybiBtb2RlLmNvcHlTdGF0ZShzdGF0ZSkgfVxcbiAgdmFyIG5zdGF0ZSA9IHt9XFxuICBmb3IgKHZhciBuIGluIHN0YXRlKSB7XFxuICAgIHZhciB2YWwgPSBzdGF0ZVtuXVxcbiAgICBpZiAodmFsIGluc3RhbmNlb2YgQXJyYXkpIHsgdmFsID0gdmFsLmNvbmNhdChbXSkgfVxcbiAgICBuc3RhdGVbbl0gPSB2YWxcXG4gIH1cXG4gIHJldHVybiBuc3RhdGVcXG59XFxuXFxuLy8gR2l2ZW4gYSBtb2RlIGFuZCBhIHN0YXRlIChmb3IgdGhhdCBtb2RlKSwgZmluZCB0aGUgaW5uZXIgbW9kZSBhbmRcXG4vLyBzdGF0ZSBhdCB0aGUgcG9zaXRpb24gdGhhdCB0aGUgc3RhdGUgcmVmZXJzIHRvLlxcbmZ1bmN0aW9uIGlubmVyTW9kZShtb2RlLCBzdGF0ZSkge1xcbiAgdmFyIGluZm9cXG4gIHdoaWxlIChtb2RlLmlubmVyTW9kZSkge1xcbiAgICBpbmZvID0gbW9kZS5pbm5lck1vZGUoc3RhdGUpXFxuICAgIGlmICghaW5mbyB8fCBpbmZvLm1vZGUgPT0gbW9kZSkgeyBicmVhayB9XFxuICAgIHN0YXRlID0gaW5mby5zdGF0ZVxcbiAgICBtb2RlID0gaW5mby5tb2RlXFxuICB9XFxuICByZXR1cm4gaW5mbyB8fCB7bW9kZTogbW9kZSwgc3RhdGU6IHN0YXRlfVxcbn1cXG5cXG5mdW5jdGlvbiBzdGFydFN0YXRlKG1vZGUsIGExLCBhMikge1xcbiAgcmV0dXJuIG1vZGUuc3RhcnRTdGF0ZSA/IG1vZGUuc3RhcnRTdGF0ZShhMSwgYTIpIDogdHJ1ZVxcbn1cXG5cXG4vLyBTVFJJTkcgU1RSRUFNXFxuXFxuLy8gRmVkIHRvIHRoZSBtb2RlIHBhcnNlcnMsIHByb3ZpZGVzIGhlbHBlciBmdW5jdGlvbnMgdG8gbWFrZVxcbi8vIHBhcnNlcnMgbW9yZSBzdWNjaW5jdC5cXG5cXG52YXIgU3RyaW5nU3RyZWFtID0gZnVuY3Rpb24oc3RyaW5nLCB0YWJTaXplKSB7XFxuICB0aGlzLnBvcyA9IHRoaXMuc3RhcnQgPSAwXFxuICB0aGlzLnN0cmluZyA9IHN0cmluZ1xcbiAgdGhpcy50YWJTaXplID0gdGFiU2l6ZSB8fCA4XFxuICB0aGlzLmxhc3RDb2x1bW5Qb3MgPSB0aGlzLmxhc3RDb2x1bW5WYWx1ZSA9IDBcXG4gIHRoaXMubGluZVN0YXJ0ID0gMFxcbn1cXG5cXG5TdHJpbmdTdHJlYW0ucHJvdG90eXBlID0ge1xcbiAgZW9sOiBmdW5jdGlvbigpIHtyZXR1cm4gdGhpcy5wb3MgPj0gdGhpcy5zdHJpbmcubGVuZ3RofSxcXG4gIHNvbDogZnVuY3Rpb24oKSB7cmV0dXJuIHRoaXMucG9zID09IHRoaXMubGluZVN0YXJ0fSxcXG4gIHBlZWs6IGZ1bmN0aW9uKCkge3JldHVybiB0aGlzLnN0cmluZy5jaGFyQXQodGhpcy5wb3MpIHx8IHVuZGVmaW5lZH0sXFxuICBuZXh0OiBmdW5jdGlvbigpIHtcXG4gICAgaWYgKHRoaXMucG9zIDwgdGhpcy5zdHJpbmcubGVuZ3RoKVxcbiAgICAgIHsgcmV0dXJuIHRoaXMuc3RyaW5nLmNoYXJBdCh0aGlzLnBvcysrKSB9XFxuICB9LFxcbiAgZWF0OiBmdW5jdGlvbihtYXRjaCkge1xcbiAgICB2YXIgY2ggPSB0aGlzLnN0cmluZy5jaGFyQXQodGhpcy5wb3MpXFxuICAgIHZhciBva1xcbiAgICBpZiAodHlwZW9mIG1hdGNoID09IFxcXCJzdHJpbmdcXFwiKSB7IG9rID0gY2ggPT0gbWF0Y2ggfVxcbiAgICBlbHNlIHsgb2sgPSBjaCAmJiAobWF0Y2gudGVzdCA/IG1hdGNoLnRlc3QoY2gpIDogbWF0Y2goY2gpKSB9XFxuICAgIGlmIChvaykgeysrdGhpcy5wb3M7IHJldHVybiBjaH1cXG4gIH0sXFxuICBlYXRXaGlsZTogZnVuY3Rpb24obWF0Y2gpIHtcXG4gICAgdmFyIHN0YXJ0ID0gdGhpcy5wb3NcXG4gICAgd2hpbGUgKHRoaXMuZWF0KG1hdGNoKSl7fVxcbiAgICByZXR1cm4gdGhpcy5wb3MgPiBzdGFydFxcbiAgfSxcXG4gIGVhdFNwYWNlOiBmdW5jdGlvbigpIHtcXG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XFxuXFxuICAgIHZhciBzdGFydCA9IHRoaXMucG9zXFxuICAgIHdoaWxlICgvW1xcXFxzXFxcXHUwMGEwXS8udGVzdCh0aGlzLnN0cmluZy5jaGFyQXQodGhpcy5wb3MpKSkgeyArK3RoaXMkMS5wb3MgfVxcbiAgICByZXR1cm4gdGhpcy5wb3MgPiBzdGFydFxcbiAgfSxcXG4gIHNraXBUb0VuZDogZnVuY3Rpb24oKSB7dGhpcy5wb3MgPSB0aGlzLnN0cmluZy5sZW5ndGh9LFxcbiAgc2tpcFRvOiBmdW5jdGlvbihjaCkge1xcbiAgICB2YXIgZm91bmQgPSB0aGlzLnN0cmluZy5pbmRleE9mKGNoLCB0aGlzLnBvcylcXG4gICAgaWYgKGZvdW5kID4gLTEpIHt0aGlzLnBvcyA9IGZvdW5kOyByZXR1cm4gdHJ1ZX1cXG4gIH0sXFxuICBiYWNrVXA6IGZ1bmN0aW9uKG4pIHt0aGlzLnBvcyAtPSBufSxcXG4gIGNvbHVtbjogZnVuY3Rpb24oKSB7XFxuICAgIGlmICh0aGlzLmxhc3RDb2x1bW5Qb3MgPCB0aGlzLnN0YXJ0KSB7XFxuICAgICAgdGhpcy5sYXN0Q29sdW1uVmFsdWUgPSBjb3VudENvbHVtbih0aGlzLnN0cmluZywgdGhpcy5zdGFydCwgdGhpcy50YWJTaXplLCB0aGlzLmxhc3RDb2x1bW5Qb3MsIHRoaXMubGFzdENvbHVtblZhbHVlKVxcbiAgICAgIHRoaXMubGFzdENvbHVtblBvcyA9IHRoaXMuc3RhcnRcXG4gICAgfVxcbiAgICByZXR1cm4gdGhpcy5sYXN0Q29sdW1uVmFsdWUgLSAodGhpcy5saW5lU3RhcnQgPyBjb3VudENvbHVtbih0aGlzLnN0cmluZywgdGhpcy5saW5lU3RhcnQsIHRoaXMudGFiU2l6ZSkgOiAwKVxcbiAgfSxcXG4gIGluZGVudGF0aW9uOiBmdW5jdGlvbigpIHtcXG4gICAgcmV0dXJuIGNvdW50Q29sdW1uKHRoaXMuc3RyaW5nLCBudWxsLCB0aGlzLnRhYlNpemUpIC1cXG4gICAgICAodGhpcy5saW5lU3RhcnQgPyBjb3VudENvbHVtbih0aGlzLnN0cmluZywgdGhpcy5saW5lU3RhcnQsIHRoaXMudGFiU2l6ZSkgOiAwKVxcbiAgfSxcXG4gIG1hdGNoOiBmdW5jdGlvbihwYXR0ZXJuLCBjb25zdW1lLCBjYXNlSW5zZW5zaXRpdmUpIHtcXG4gICAgaWYgKHR5cGVvZiBwYXR0ZXJuID09IFxcXCJzdHJpbmdcXFwiKSB7XFxuICAgICAgdmFyIGNhc2VkID0gZnVuY3Rpb24gKHN0cikgeyByZXR1cm4gY2FzZUluc2Vuc2l0aXZlID8gc3RyLnRvTG93ZXJDYXNlKCkgOiBzdHI7IH1cXG4gICAgICB2YXIgc3Vic3RyID0gdGhpcy5zdHJpbmcuc3Vic3RyKHRoaXMucG9zLCBwYXR0ZXJuLmxlbmd0aClcXG4gICAgICBpZiAoY2FzZWQoc3Vic3RyKSA9PSBjYXNlZChwYXR0ZXJuKSkge1xcbiAgICAgICAgaWYgKGNvbnN1bWUgIT09IGZhbHNlKSB7IHRoaXMucG9zICs9IHBhdHRlcm4ubGVuZ3RoIH1cXG4gICAgICAgIHJldHVybiB0cnVlXFxuICAgICAgfVxcbiAgICB9IGVsc2Uge1xcbiAgICAgIHZhciBtYXRjaCA9IHRoaXMuc3RyaW5nLnNsaWNlKHRoaXMucG9zKS5tYXRjaChwYXR0ZXJuKVxcbiAgICAgIGlmIChtYXRjaCAmJiBtYXRjaC5pbmRleCA+IDApIHsgcmV0dXJuIG51bGwgfVxcbiAgICAgIGlmIChtYXRjaCAmJiBjb25zdW1lICE9PSBmYWxzZSkgeyB0aGlzLnBvcyArPSBtYXRjaFswXS5sZW5ndGggfVxcbiAgICAgIHJldHVybiBtYXRjaFxcbiAgICB9XFxuICB9LFxcbiAgY3VycmVudDogZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zdHJpbmcuc2xpY2UodGhpcy5zdGFydCwgdGhpcy5wb3MpfSxcXG4gIGhpZGVGaXJzdENoYXJzOiBmdW5jdGlvbihuLCBpbm5lcikge1xcbiAgICB0aGlzLmxpbmVTdGFydCArPSBuXFxuICAgIHRyeSB7IHJldHVybiBpbm5lcigpIH1cXG4gICAgZmluYWxseSB7IHRoaXMubGluZVN0YXJ0IC09IG4gfVxcbiAgfVxcbn1cXG5cXG4vLyBDb21wdXRlIGEgc3R5bGUgYXJyYXkgKGFuIGFycmF5IHN0YXJ0aW5nIHdpdGggYSBtb2RlIGdlbmVyYXRpb25cXG4vLyAtLSBmb3IgaW52YWxpZGF0aW9uIC0tIGZvbGxvd2VkIGJ5IHBhaXJzIG9mIGVuZCBwb3NpdGlvbnMgYW5kXFxuLy8gc3R5bGUgc3RyaW5ncyksIHdoaWNoIGlzIHVzZWQgdG8gaGlnaGxpZ2h0IHRoZSB0b2tlbnMgb24gdGhlXFxuLy8gbGluZS5cXG5mdW5jdGlvbiBoaWdobGlnaHRMaW5lKGNtLCBsaW5lLCBzdGF0ZSwgZm9yY2VUb0VuZCkge1xcbiAgLy8gQSBzdHlsZXMgYXJyYXkgYWx3YXlzIHN0YXJ0cyB3aXRoIGEgbnVtYmVyIGlkZW50aWZ5aW5nIHRoZVxcbiAgLy8gbW9kZS9vdmVybGF5cyB0aGF0IGl0IGlzIGJhc2VkIG9uIChmb3IgZWFzeSBpbnZhbGlkYXRpb24pLlxcbiAgdmFyIHN0ID0gW2NtLnN0YXRlLm1vZGVHZW5dLCBsaW5lQ2xhc3NlcyA9IHt9XFxuICAvLyBDb21wdXRlIHRoZSBiYXNlIGFycmF5IG9mIHN0eWxlc1xcbiAgcnVuTW9kZShjbSwgbGluZS50ZXh0LCBjbS5kb2MubW9kZSwgc3RhdGUsIGZ1bmN0aW9uIChlbmQsIHN0eWxlKSB7IHJldHVybiBzdC5wdXNoKGVuZCwgc3R5bGUpOyB9LFxcbiAgICBsaW5lQ2xhc3NlcywgZm9yY2VUb0VuZClcXG5cXG4gIC8vIFJ1biBvdmVybGF5cywgYWRqdXN0IHN0eWxlIGFycmF5LlxcbiAgdmFyIGxvb3AgPSBmdW5jdGlvbiAoIG8gKSB7XFxuICAgIHZhciBvdmVybGF5ID0gY20uc3RhdGUub3ZlcmxheXNbb10sIGkgPSAxLCBhdCA9IDBcXG4gICAgcnVuTW9kZShjbSwgbGluZS50ZXh0LCBvdmVybGF5Lm1vZGUsIHRydWUsIGZ1bmN0aW9uIChlbmQsIHN0eWxlKSB7XFxuICAgICAgdmFyIHN0YXJ0ID0gaVxcbiAgICAgIC8vIEVuc3VyZSB0aGVyZSdzIGEgdG9rZW4gZW5kIGF0IHRoZSBjdXJyZW50IHBvc2l0aW9uLCBhbmQgdGhhdCBpIHBvaW50cyBhdCBpdFxcbiAgICAgIHdoaWxlIChhdCA8IGVuZCkge1xcbiAgICAgICAgdmFyIGlfZW5kID0gc3RbaV1cXG4gICAgICAgIGlmIChpX2VuZCA+IGVuZClcXG4gICAgICAgICAgeyBzdC5zcGxpY2UoaSwgMSwgZW5kLCBzdFtpKzFdLCBpX2VuZCkgfVxcbiAgICAgICAgaSArPSAyXFxuICAgICAgICBhdCA9IE1hdGgubWluKGVuZCwgaV9lbmQpXFxuICAgICAgfVxcbiAgICAgIGlmICghc3R5bGUpIHsgcmV0dXJuIH1cXG4gICAgICBpZiAob3ZlcmxheS5vcGFxdWUpIHtcXG4gICAgICAgIHN0LnNwbGljZShzdGFydCwgaSAtIHN0YXJ0LCBlbmQsIFxcXCJvdmVybGF5IFxcXCIgKyBzdHlsZSlcXG4gICAgICAgIGkgPSBzdGFydCArIDJcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgZm9yICg7IHN0YXJ0IDwgaTsgc3RhcnQgKz0gMikge1xcbiAgICAgICAgICB2YXIgY3VyID0gc3Rbc3RhcnQrMV1cXG4gICAgICAgICAgc3Rbc3RhcnQrMV0gPSAoY3VyID8gY3VyICsgXFxcIiBcXFwiIDogXFxcIlxcXCIpICsgXFxcIm92ZXJsYXkgXFxcIiArIHN0eWxlXFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICB9LCBsaW5lQ2xhc3NlcylcXG4gIH07XFxuXFxuICBmb3IgKHZhciBvID0gMDsgbyA8IGNtLnN0YXRlLm92ZXJsYXlzLmxlbmd0aDsgKytvKSBsb29wKCBvICk7XFxuXFxuICByZXR1cm4ge3N0eWxlczogc3QsIGNsYXNzZXM6IGxpbmVDbGFzc2VzLmJnQ2xhc3MgfHwgbGluZUNsYXNzZXMudGV4dENsYXNzID8gbGluZUNsYXNzZXMgOiBudWxsfVxcbn1cXG5cXG5mdW5jdGlvbiBnZXRMaW5lU3R5bGVzKGNtLCBsaW5lLCB1cGRhdGVGcm9udGllcikge1xcbiAgaWYgKCFsaW5lLnN0eWxlcyB8fCBsaW5lLnN0eWxlc1swXSAhPSBjbS5zdGF0ZS5tb2RlR2VuKSB7XFxuICAgIHZhciBzdGF0ZSA9IGdldFN0YXRlQmVmb3JlKGNtLCBsaW5lTm8obGluZSkpXFxuICAgIHZhciByZXN1bHQgPSBoaWdobGlnaHRMaW5lKGNtLCBsaW5lLCBsaW5lLnRleHQubGVuZ3RoID4gY20ub3B0aW9ucy5tYXhIaWdobGlnaHRMZW5ndGggPyBjb3B5U3RhdGUoY20uZG9jLm1vZGUsIHN0YXRlKSA6IHN0YXRlKVxcbiAgICBsaW5lLnN0YXRlQWZ0ZXIgPSBzdGF0ZVxcbiAgICBsaW5lLnN0eWxlcyA9IHJlc3VsdC5zdHlsZXNcXG4gICAgaWYgKHJlc3VsdC5jbGFzc2VzKSB7IGxpbmUuc3R5bGVDbGFzc2VzID0gcmVzdWx0LmNsYXNzZXMgfVxcbiAgICBlbHNlIGlmIChsaW5lLnN0eWxlQ2xhc3NlcykgeyBsaW5lLnN0eWxlQ2xhc3NlcyA9IG51bGwgfVxcbiAgICBpZiAodXBkYXRlRnJvbnRpZXIgPT09IGNtLmRvYy5mcm9udGllcikgeyBjbS5kb2MuZnJvbnRpZXIrKyB9XFxuICB9XFxuICByZXR1cm4gbGluZS5zdHlsZXNcXG59XFxuXFxuZnVuY3Rpb24gZ2V0U3RhdGVCZWZvcmUoY20sIG4sIHByZWNpc2UpIHtcXG4gIHZhciBkb2MgPSBjbS5kb2MsIGRpc3BsYXkgPSBjbS5kaXNwbGF5XFxuICBpZiAoIWRvYy5tb2RlLnN0YXJ0U3RhdGUpIHsgcmV0dXJuIHRydWUgfVxcbiAgdmFyIHBvcyA9IGZpbmRTdGFydExpbmUoY20sIG4sIHByZWNpc2UpLCBzdGF0ZSA9IHBvcyA+IGRvYy5maXJzdCAmJiBnZXRMaW5lKGRvYywgcG9zLTEpLnN0YXRlQWZ0ZXJcXG4gIGlmICghc3RhdGUpIHsgc3RhdGUgPSBzdGFydFN0YXRlKGRvYy5tb2RlKSB9XFxuICBlbHNlIHsgc3RhdGUgPSBjb3B5U3RhdGUoZG9jLm1vZGUsIHN0YXRlKSB9XFxuICBkb2MuaXRlcihwb3MsIG4sIGZ1bmN0aW9uIChsaW5lKSB7XFxuICAgIHByb2Nlc3NMaW5lKGNtLCBsaW5lLnRleHQsIHN0YXRlKVxcbiAgICB2YXIgc2F2ZSA9IHBvcyA9PSBuIC0gMSB8fCBwb3MgJSA1ID09IDAgfHwgcG9zID49IGRpc3BsYXkudmlld0Zyb20gJiYgcG9zIDwgZGlzcGxheS52aWV3VG9cXG4gICAgbGluZS5zdGF0ZUFmdGVyID0gc2F2ZSA/IGNvcHlTdGF0ZShkb2MubW9kZSwgc3RhdGUpIDogbnVsbFxcbiAgICArK3Bvc1xcbiAgfSlcXG4gIGlmIChwcmVjaXNlKSB7IGRvYy5mcm9udGllciA9IHBvcyB9XFxuICByZXR1cm4gc3RhdGVcXG59XFxuXFxuLy8gTGlnaHR3ZWlnaHQgZm9ybSBvZiBoaWdobGlnaHQgLS0gcHJvY2VlZCBvdmVyIHRoaXMgbGluZSBhbmRcXG4vLyB1cGRhdGUgc3RhdGUsIGJ1dCBkb24ndCBzYXZlIGEgc3R5bGUgYXJyYXkuIFVzZWQgZm9yIGxpbmVzIHRoYXRcXG4vLyBhcmVuJ3QgY3VycmVudGx5IHZpc2libGUuXFxuZnVuY3Rpb24gcHJvY2Vzc0xpbmUoY20sIHRleHQsIHN0YXRlLCBzdGFydEF0KSB7XFxuICB2YXIgbW9kZSA9IGNtLmRvYy5tb2RlXFxuICB2YXIgc3RyZWFtID0gbmV3IFN0cmluZ1N0cmVhbSh0ZXh0LCBjbS5vcHRpb25zLnRhYlNpemUpXFxuICBzdHJlYW0uc3RhcnQgPSBzdHJlYW0ucG9zID0gc3RhcnRBdCB8fCAwXFxuICBpZiAodGV4dCA9PSBcXFwiXFxcIikgeyBjYWxsQmxhbmtMaW5lKG1vZGUsIHN0YXRlKSB9XFxuICB3aGlsZSAoIXN0cmVhbS5lb2woKSkge1xcbiAgICByZWFkVG9rZW4obW9kZSwgc3RyZWFtLCBzdGF0ZSlcXG4gICAgc3RyZWFtLnN0YXJ0ID0gc3RyZWFtLnBvc1xcbiAgfVxcbn1cXG5cXG5mdW5jdGlvbiBjYWxsQmxhbmtMaW5lKG1vZGUsIHN0YXRlKSB7XFxuICBpZiAobW9kZS5ibGFua0xpbmUpIHsgcmV0dXJuIG1vZGUuYmxhbmtMaW5lKHN0YXRlKSB9XFxuICBpZiAoIW1vZGUuaW5uZXJNb2RlKSB7IHJldHVybiB9XFxuICB2YXIgaW5uZXIgPSBpbm5lck1vZGUobW9kZSwgc3RhdGUpXFxuICBpZiAoaW5uZXIubW9kZS5ibGFua0xpbmUpIHsgcmV0dXJuIGlubmVyLm1vZGUuYmxhbmtMaW5lKGlubmVyLnN0YXRlKSB9XFxufVxcblxcbmZ1bmN0aW9uIHJlYWRUb2tlbihtb2RlLCBzdHJlYW0sIHN0YXRlLCBpbm5lcikge1xcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCAxMDsgaSsrKSB7XFxuICAgIGlmIChpbm5lcikgeyBpbm5lclswXSA9IGlubmVyTW9kZShtb2RlLCBzdGF0ZSkubW9kZSB9XFxuICAgIHZhciBzdHlsZSA9IG1vZGUudG9rZW4oc3RyZWFtLCBzdGF0ZSlcXG4gICAgaWYgKHN0cmVhbS5wb3MgPiBzdHJlYW0uc3RhcnQpIHsgcmV0dXJuIHN0eWxlIH1cXG4gIH1cXG4gIHRocm93IG5ldyBFcnJvcihcXFwiTW9kZSBcXFwiICsgbW9kZS5uYW1lICsgXFxcIiBmYWlsZWQgdG8gYWR2YW5jZSBzdHJlYW0uXFxcIilcXG59XFxuXFxuLy8gVXRpbGl0eSBmb3IgZ2V0VG9rZW5BdCBhbmQgZ2V0TGluZVRva2Vuc1xcbmZ1bmN0aW9uIHRha2VUb2tlbihjbSwgcG9zLCBwcmVjaXNlLCBhc0FycmF5KSB7XFxuICB2YXIgZ2V0T2JqID0gZnVuY3Rpb24gKGNvcHkpIHsgcmV0dXJuICh7XFxuICAgIHN0YXJ0OiBzdHJlYW0uc3RhcnQsIGVuZDogc3RyZWFtLnBvcyxcXG4gICAgc3RyaW5nOiBzdHJlYW0uY3VycmVudCgpLFxcbiAgICB0eXBlOiBzdHlsZSB8fCBudWxsLFxcbiAgICBzdGF0ZTogY29weSA/IGNvcHlTdGF0ZShkb2MubW9kZSwgc3RhdGUpIDogc3RhdGVcXG4gIH0pOyB9XFxuXFxuICB2YXIgZG9jID0gY20uZG9jLCBtb2RlID0gZG9jLm1vZGUsIHN0eWxlXFxuICBwb3MgPSBjbGlwUG9zKGRvYywgcG9zKVxcbiAgdmFyIGxpbmUgPSBnZXRMaW5lKGRvYywgcG9zLmxpbmUpLCBzdGF0ZSA9IGdldFN0YXRlQmVmb3JlKGNtLCBwb3MubGluZSwgcHJlY2lzZSlcXG4gIHZhciBzdHJlYW0gPSBuZXcgU3RyaW5nU3RyZWFtKGxpbmUudGV4dCwgY20ub3B0aW9ucy50YWJTaXplKSwgdG9rZW5zXFxuICBpZiAoYXNBcnJheSkgeyB0b2tlbnMgPSBbXSB9XFxuICB3aGlsZSAoKGFzQXJyYXkgfHwgc3RyZWFtLnBvcyA8IHBvcy5jaCkgJiYgIXN0cmVhbS5lb2woKSkge1xcbiAgICBzdHJlYW0uc3RhcnQgPSBzdHJlYW0ucG9zXFxuICAgIHN0eWxlID0gcmVhZFRva2VuKG1vZGUsIHN0cmVhbSwgc3RhdGUpXFxuICAgIGlmIChhc0FycmF5KSB7IHRva2Vucy5wdXNoKGdldE9iaih0cnVlKSkgfVxcbiAgfVxcbiAgcmV0dXJuIGFzQXJyYXkgPyB0b2tlbnMgOiBnZXRPYmooKVxcbn1cXG5cXG5mdW5jdGlvbiBleHRyYWN0TGluZUNsYXNzZXModHlwZSwgb3V0cHV0KSB7XFxuICBpZiAodHlwZSkgeyBmb3IgKDs7KSB7XFxuICAgIHZhciBsaW5lQ2xhc3MgPSB0eXBlLm1hdGNoKC8oPzpefFxcXFxzKylsaW5lLShiYWNrZ3JvdW5kLSk/KFxcXFxTKykvKVxcbiAgICBpZiAoIWxpbmVDbGFzcykgeyBicmVhayB9XFxuICAgIHR5cGUgPSB0eXBlLnNsaWNlKDAsIGxpbmVDbGFzcy5pbmRleCkgKyB0eXBlLnNsaWNlKGxpbmVDbGFzcy5pbmRleCArIGxpbmVDbGFzc1swXS5sZW5ndGgpXFxuICAgIHZhciBwcm9wID0gbGluZUNsYXNzWzFdID8gXFxcImJnQ2xhc3NcXFwiIDogXFxcInRleHRDbGFzc1xcXCJcXG4gICAgaWYgKG91dHB1dFtwcm9wXSA9PSBudWxsKVxcbiAgICAgIHsgb3V0cHV0W3Byb3BdID0gbGluZUNsYXNzWzJdIH1cXG4gICAgZWxzZSBpZiAoIShuZXcgUmVnRXhwKFxcXCIoPzpefFxcXFxzKVxcXCIgKyBsaW5lQ2xhc3NbMl0gKyBcXFwiKD86JHxcXFxccylcXFwiKSkudGVzdChvdXRwdXRbcHJvcF0pKVxcbiAgICAgIHsgb3V0cHV0W3Byb3BdICs9IFxcXCIgXFxcIiArIGxpbmVDbGFzc1syXSB9XFxuICB9IH1cXG4gIHJldHVybiB0eXBlXFxufVxcblxcbi8vIFJ1biB0aGUgZ2l2ZW4gbW9kZSdzIHBhcnNlciBvdmVyIGEgbGluZSwgY2FsbGluZyBmIGZvciBlYWNoIHRva2VuLlxcbmZ1bmN0aW9uIHJ1bk1vZGUoY20sIHRleHQsIG1vZGUsIHN0YXRlLCBmLCBsaW5lQ2xhc3NlcywgZm9yY2VUb0VuZCkge1xcbiAgdmFyIGZsYXR0ZW5TcGFucyA9IG1vZGUuZmxhdHRlblNwYW5zXFxuICBpZiAoZmxhdHRlblNwYW5zID09IG51bGwpIHsgZmxhdHRlblNwYW5zID0gY20ub3B0aW9ucy5mbGF0dGVuU3BhbnMgfVxcbiAgdmFyIGN1clN0YXJ0ID0gMCwgY3VyU3R5bGUgPSBudWxsXFxuICB2YXIgc3RyZWFtID0gbmV3IFN0cmluZ1N0cmVhbSh0ZXh0LCBjbS5vcHRpb25zLnRhYlNpemUpLCBzdHlsZVxcbiAgdmFyIGlubmVyID0gY20ub3B0aW9ucy5hZGRNb2RlQ2xhc3MgJiYgW251bGxdXFxuICBpZiAodGV4dCA9PSBcXFwiXFxcIikgeyBleHRyYWN0TGluZUNsYXNzZXMoY2FsbEJsYW5rTGluZShtb2RlLCBzdGF0ZSksIGxpbmVDbGFzc2VzKSB9XFxuICB3aGlsZSAoIXN0cmVhbS5lb2woKSkge1xcbiAgICBpZiAoc3RyZWFtLnBvcyA+IGNtLm9wdGlvbnMubWF4SGlnaGxpZ2h0TGVuZ3RoKSB7XFxuICAgICAgZmxhdHRlblNwYW5zID0gZmFsc2VcXG4gICAgICBpZiAoZm9yY2VUb0VuZCkgeyBwcm9jZXNzTGluZShjbSwgdGV4dCwgc3RhdGUsIHN0cmVhbS5wb3MpIH1cXG4gICAgICBzdHJlYW0ucG9zID0gdGV4dC5sZW5ndGhcXG4gICAgICBzdHlsZSA9IG51bGxcXG4gICAgfSBlbHNlIHtcXG4gICAgICBzdHlsZSA9IGV4dHJhY3RMaW5lQ2xhc3NlcyhyZWFkVG9rZW4obW9kZSwgc3RyZWFtLCBzdGF0ZSwgaW5uZXIpLCBsaW5lQ2xhc3NlcylcXG4gICAgfVxcbiAgICBpZiAoaW5uZXIpIHtcXG4gICAgICB2YXIgbU5hbWUgPSBpbm5lclswXS5uYW1lXFxuICAgICAgaWYgKG1OYW1lKSB7IHN0eWxlID0gXFxcIm0tXFxcIiArIChzdHlsZSA/IG1OYW1lICsgXFxcIiBcXFwiICsgc3R5bGUgOiBtTmFtZSkgfVxcbiAgICB9XFxuICAgIGlmICghZmxhdHRlblNwYW5zIHx8IGN1clN0eWxlICE9IHN0eWxlKSB7XFxuICAgICAgd2hpbGUgKGN1clN0YXJ0IDwgc3RyZWFtLnN0YXJ0KSB7XFxuICAgICAgICBjdXJTdGFydCA9IE1hdGgubWluKHN0cmVhbS5zdGFydCwgY3VyU3RhcnQgKyA1MDAwKVxcbiAgICAgICAgZihjdXJTdGFydCwgY3VyU3R5bGUpXFxuICAgICAgfVxcbiAgICAgIGN1clN0eWxlID0gc3R5bGVcXG4gICAgfVxcbiAgICBzdHJlYW0uc3RhcnQgPSBzdHJlYW0ucG9zXFxuICB9XFxuICB3aGlsZSAoY3VyU3RhcnQgPCBzdHJlYW0ucG9zKSB7XFxuICAgIC8vIFdlYmtpdCBzZWVtcyB0byByZWZ1c2UgdG8gcmVuZGVyIHRleHQgbm9kZXMgbG9uZ2VyIHRoYW4gNTc0NDRcXG4gICAgLy8gY2hhcmFjdGVycywgYW5kIHJldHVybnMgaW5hY2N1cmF0ZSBtZWFzdXJlbWVudHMgaW4gbm9kZXNcXG4gICAgLy8gc3RhcnRpbmcgYXJvdW5kIDUwMDAgY2hhcnMuXFxuICAgIHZhciBwb3MgPSBNYXRoLm1pbihzdHJlYW0ucG9zLCBjdXJTdGFydCArIDUwMDApXFxuICAgIGYocG9zLCBjdXJTdHlsZSlcXG4gICAgY3VyU3RhcnQgPSBwb3NcXG4gIH1cXG59XFxuXFxuLy8gRmluZHMgdGhlIGxpbmUgdG8gc3RhcnQgd2l0aCB3aGVuIHN0YXJ0aW5nIGEgcGFyc2UuIFRyaWVzIHRvXFxuLy8gZmluZCBhIGxpbmUgd2l0aCBhIHN0YXRlQWZ0ZXIsIHNvIHRoYXQgaXQgY2FuIHN0YXJ0IHdpdGggYVxcbi8vIHZhbGlkIHN0YXRlLiBJZiB0aGF0IGZhaWxzLCBpdCByZXR1cm5zIHRoZSBsaW5lIHdpdGggdGhlXFxuLy8gc21hbGxlc3QgaW5kZW50YXRpb24sIHdoaWNoIHRlbmRzIHRvIG5lZWQgdGhlIGxlYXN0IGNvbnRleHQgdG9cXG4vLyBwYXJzZSBjb3JyZWN0bHkuXFxuZnVuY3Rpb24gZmluZFN0YXJ0TGluZShjbSwgbiwgcHJlY2lzZSkge1xcbiAgdmFyIG1pbmluZGVudCwgbWlubGluZSwgZG9jID0gY20uZG9jXFxuICB2YXIgbGltID0gcHJlY2lzZSA/IC0xIDogbiAtIChjbS5kb2MubW9kZS5pbm5lck1vZGUgPyAxMDAwIDogMTAwKVxcbiAgZm9yICh2YXIgc2VhcmNoID0gbjsgc2VhcmNoID4gbGltOyAtLXNlYXJjaCkge1xcbiAgICBpZiAoc2VhcmNoIDw9IGRvYy5maXJzdCkgeyByZXR1cm4gZG9jLmZpcnN0IH1cXG4gICAgdmFyIGxpbmUgPSBnZXRMaW5lKGRvYywgc2VhcmNoIC0gMSlcXG4gICAgaWYgKGxpbmUuc3RhdGVBZnRlciAmJiAoIXByZWNpc2UgfHwgc2VhcmNoIDw9IGRvYy5mcm9udGllcikpIHsgcmV0dXJuIHNlYXJjaCB9XFxuICAgIHZhciBpbmRlbnRlZCA9IGNvdW50Q29sdW1uKGxpbmUudGV4dCwgbnVsbCwgY20ub3B0aW9ucy50YWJTaXplKVxcbiAgICBpZiAobWlubGluZSA9PSBudWxsIHx8IG1pbmluZGVudCA+IGluZGVudGVkKSB7XFxuICAgICAgbWlubGluZSA9IHNlYXJjaCAtIDFcXG4gICAgICBtaW5pbmRlbnQgPSBpbmRlbnRlZFxcbiAgICB9XFxuICB9XFxuICByZXR1cm4gbWlubGluZVxcbn1cXG5cXG4vLyBMSU5FIERBVEEgU1RSVUNUVVJFXFxuXFxuLy8gTGluZSBvYmplY3RzLiBUaGVzZSBob2xkIHN0YXRlIHJlbGF0ZWQgdG8gYSBsaW5lLCBpbmNsdWRpbmdcXG4vLyBoaWdobGlnaHRpbmcgaW5mbyAodGhlIHN0eWxlcyBhcnJheSkuXFxuZnVuY3Rpb24gTGluZSh0ZXh0LCBtYXJrZWRTcGFucywgZXN0aW1hdGVIZWlnaHQpIHtcXG4gIHRoaXMudGV4dCA9IHRleHRcXG4gIGF0dGFjaE1hcmtlZFNwYW5zKHRoaXMsIG1hcmtlZFNwYW5zKVxcbiAgdGhpcy5oZWlnaHQgPSBlc3RpbWF0ZUhlaWdodCA/IGVzdGltYXRlSGVpZ2h0KHRoaXMpIDogMVxcbn1cXG5ldmVudE1peGluKExpbmUpXFxuTGluZS5wcm90b3R5cGUubGluZU5vID0gZnVuY3Rpb24oKSB7IHJldHVybiBsaW5lTm8odGhpcykgfVxcblxcbi8vIENoYW5nZSB0aGUgY29udGVudCAodGV4dCwgbWFya2Vycykgb2YgYSBsaW5lLiBBdXRvbWF0aWNhbGx5XFxuLy8gaW52YWxpZGF0ZXMgY2FjaGVkIGluZm9ybWF0aW9uIGFuZCB0cmllcyB0byByZS1lc3RpbWF0ZSB0aGVcXG4vLyBsaW5lJ3MgaGVpZ2h0LlxcbmZ1bmN0aW9uIHVwZGF0ZUxpbmUobGluZSwgdGV4dCwgbWFya2VkU3BhbnMsIGVzdGltYXRlSGVpZ2h0KSB7XFxuICBsaW5lLnRleHQgPSB0ZXh0XFxuICBpZiAobGluZS5zdGF0ZUFmdGVyKSB7IGxpbmUuc3RhdGVBZnRlciA9IG51bGwgfVxcbiAgaWYgKGxpbmUuc3R5bGVzKSB7IGxpbmUuc3R5bGVzID0gbnVsbCB9XFxuICBpZiAobGluZS5vcmRlciAhPSBudWxsKSB7IGxpbmUub3JkZXIgPSBudWxsIH1cXG4gIGRldGFjaE1hcmtlZFNwYW5zKGxpbmUpXFxuICBhdHRhY2hNYXJrZWRTcGFucyhsaW5lLCBtYXJrZWRTcGFucylcXG4gIHZhciBlc3RIZWlnaHQgPSBlc3RpbWF0ZUhlaWdodCA/IGVzdGltYXRlSGVpZ2h0KGxpbmUpIDogMVxcbiAgaWYgKGVzdEhlaWdodCAhPSBsaW5lLmhlaWdodCkgeyB1cGRhdGVMaW5lSGVpZ2h0KGxpbmUsIGVzdEhlaWdodCkgfVxcbn1cXG5cXG4vLyBEZXRhY2ggYSBsaW5lIGZyb20gdGhlIGRvY3VtZW50IHRyZWUgYW5kIGl0cyBtYXJrZXJzLlxcbmZ1bmN0aW9uIGNsZWFuVXBMaW5lKGxpbmUpIHtcXG4gIGxpbmUucGFyZW50ID0gbnVsbFxcbiAgZGV0YWNoTWFya2VkU3BhbnMobGluZSlcXG59XFxuXFxuLy8gQ29udmVydCBhIHN0eWxlIGFzIHJldHVybmVkIGJ5IGEgbW9kZSAoZWl0aGVyIG51bGwsIG9yIGEgc3RyaW5nXFxuLy8gY29udGFpbmluZyBvbmUgb3IgbW9yZSBzdHlsZXMpIHRvIGEgQ1NTIHN0eWxlLiBUaGlzIGlzIGNhY2hlZCxcXG4vLyBhbmQgYWxzbyBsb29rcyBmb3IgbGluZS13aWRlIHN0eWxlcy5cXG52YXIgc3R5bGVUb0NsYXNzQ2FjaGUgPSB7fTtcXG52YXIgc3R5bGVUb0NsYXNzQ2FjaGVXaXRoTW9kZSA9IHt9O1xcbmZ1bmN0aW9uIGludGVycHJldFRva2VuU3R5bGUoc3R5bGUsIG9wdGlvbnMpIHtcXG4gIGlmICghc3R5bGUgfHwgL15cXFxccyokLy50ZXN0KHN0eWxlKSkgeyByZXR1cm4gbnVsbCB9XFxuICB2YXIgY2FjaGUgPSBvcHRpb25zLmFkZE1vZGVDbGFzcyA/IHN0eWxlVG9DbGFzc0NhY2hlV2l0aE1vZGUgOiBzdHlsZVRvQ2xhc3NDYWNoZVxcbiAgcmV0dXJuIGNhY2hlW3N0eWxlXSB8fFxcbiAgICAoY2FjaGVbc3R5bGVdID0gc3R5bGUucmVwbGFjZSgvXFxcXFMrL2csIFxcXCJjbS0kJlxcXCIpKVxcbn1cXG5cXG4vLyBSZW5kZXIgdGhlIERPTSByZXByZXNlbnRhdGlvbiBvZiB0aGUgdGV4dCBvZiBhIGxpbmUuIEFsc28gYnVpbGRzXFxuLy8gdXAgYSAnbGluZSBtYXAnLCB3aGljaCBwb2ludHMgYXQgdGhlIERPTSBub2RlcyB0aGF0IHJlcHJlc2VudFxcbi8vIHNwZWNpZmljIHN0cmV0Y2hlcyBvZiB0ZXh0LCBhbmQgaXMgdXNlZCBieSB0aGUgbWVhc3VyaW5nIGNvZGUuXFxuLy8gVGhlIHJldHVybmVkIG9iamVjdCBjb250YWlucyB0aGUgRE9NIG5vZGUsIHRoaXMgbWFwLCBhbmRcXG4vLyBpbmZvcm1hdGlvbiBhYm91dCBsaW5lLXdpZGUgc3R5bGVzIHRoYXQgd2VyZSBzZXQgYnkgdGhlIG1vZGUuXFxuZnVuY3Rpb24gYnVpbGRMaW5lQ29udGVudChjbSwgbGluZVZpZXcpIHtcXG4gIC8vIFRoZSBwYWRkaW5nLXJpZ2h0IGZvcmNlcyB0aGUgZWxlbWVudCB0byBoYXZlIGEgJ2JvcmRlcicsIHdoaWNoXFxuICAvLyBpcyBuZWVkZWQgb24gV2Via2l0IHRvIGJlIGFibGUgdG8gZ2V0IGxpbmUtbGV2ZWwgYm91bmRpbmdcXG4gIC8vIHJlY3RhbmdsZXMgZm9yIGl0IChpbiBtZWFzdXJlQ2hhcikuXFxuICB2YXIgY29udGVudCA9IGVsdChcXFwic3BhblxcXCIsIG51bGwsIG51bGwsIHdlYmtpdCA/IFxcXCJwYWRkaW5nLXJpZ2h0OiAuMXB4XFxcIiA6IG51bGwpXFxuICB2YXIgYnVpbGRlciA9IHtwcmU6IGVsdChcXFwicHJlXFxcIiwgW2NvbnRlbnRdLCBcXFwiQ29kZU1pcnJvci1saW5lXFxcIiksIGNvbnRlbnQ6IGNvbnRlbnQsXFxuICAgICAgICAgICAgICAgICBjb2w6IDAsIHBvczogMCwgY206IGNtLFxcbiAgICAgICAgICAgICAgICAgdHJhaWxpbmdTcGFjZTogZmFsc2UsXFxuICAgICAgICAgICAgICAgICBzcGxpdFNwYWNlczogKGllIHx8IHdlYmtpdCkgJiYgY20uZ2V0T3B0aW9uKFxcXCJsaW5lV3JhcHBpbmdcXFwiKX1cXG4gIC8vIGhpZGUgZnJvbSBhY2Nlc3NpYmlsaXR5IHRyZWVcXG4gIGNvbnRlbnQuc2V0QXR0cmlidXRlKFxcXCJyb2xlXFxcIiwgXFxcInByZXNlbnRhdGlvblxcXCIpXFxuICBidWlsZGVyLnByZS5zZXRBdHRyaWJ1dGUoXFxcInJvbGVcXFwiLCBcXFwicHJlc2VudGF0aW9uXFxcIilcXG4gIGxpbmVWaWV3Lm1lYXN1cmUgPSB7fVxcblxcbiAgLy8gSXRlcmF0ZSBvdmVyIHRoZSBsb2dpY2FsIGxpbmVzIHRoYXQgbWFrZSB1cCB0aGlzIHZpc3VhbCBsaW5lLlxcbiAgZm9yICh2YXIgaSA9IDA7IGkgPD0gKGxpbmVWaWV3LnJlc3QgPyBsaW5lVmlldy5yZXN0Lmxlbmd0aCA6IDApOyBpKyspIHtcXG4gICAgdmFyIGxpbmUgPSBpID8gbGluZVZpZXcucmVzdFtpIC0gMV0gOiBsaW5lVmlldy5saW5lLCBvcmRlciA9ICh2b2lkIDApXFxuICAgIGJ1aWxkZXIucG9zID0gMFxcbiAgICBidWlsZGVyLmFkZFRva2VuID0gYnVpbGRUb2tlblxcbiAgICAvLyBPcHRpb25hbGx5IHdpcmUgaW4gc29tZSBoYWNrcyBpbnRvIHRoZSB0b2tlbi1yZW5kZXJpbmdcXG4gICAgLy8gYWxnb3JpdGhtLCB0byBkZWFsIHdpdGggYnJvd3NlciBxdWlya3MuXFxuICAgIGlmIChoYXNCYWRCaWRpUmVjdHMoY20uZGlzcGxheS5tZWFzdXJlKSAmJiAob3JkZXIgPSBnZXRPcmRlcihsaW5lKSkpXFxuICAgICAgeyBidWlsZGVyLmFkZFRva2VuID0gYnVpbGRUb2tlbkJhZEJpZGkoYnVpbGRlci5hZGRUb2tlbiwgb3JkZXIpIH1cXG4gICAgYnVpbGRlci5tYXAgPSBbXVxcbiAgICB2YXIgYWxsb3dGcm9udGllclVwZGF0ZSA9IGxpbmVWaWV3ICE9IGNtLmRpc3BsYXkuZXh0ZXJuYWxNZWFzdXJlZCAmJiBsaW5lTm8obGluZSlcXG4gICAgaW5zZXJ0TGluZUNvbnRlbnQobGluZSwgYnVpbGRlciwgZ2V0TGluZVN0eWxlcyhjbSwgbGluZSwgYWxsb3dGcm9udGllclVwZGF0ZSkpXFxuICAgIGlmIChsaW5lLnN0eWxlQ2xhc3Nlcykge1xcbiAgICAgIGlmIChsaW5lLnN0eWxlQ2xhc3Nlcy5iZ0NsYXNzKVxcbiAgICAgICAgeyBidWlsZGVyLmJnQ2xhc3MgPSBqb2luQ2xhc3NlcyhsaW5lLnN0eWxlQ2xhc3Nlcy5iZ0NsYXNzLCBidWlsZGVyLmJnQ2xhc3MgfHwgXFxcIlxcXCIpIH1cXG4gICAgICBpZiAobGluZS5zdHlsZUNsYXNzZXMudGV4dENsYXNzKVxcbiAgICAgICAgeyBidWlsZGVyLnRleHRDbGFzcyA9IGpvaW5DbGFzc2VzKGxpbmUuc3R5bGVDbGFzc2VzLnRleHRDbGFzcywgYnVpbGRlci50ZXh0Q2xhc3MgfHwgXFxcIlxcXCIpIH1cXG4gICAgfVxcblxcbiAgICAvLyBFbnN1cmUgYXQgbGVhc3QgYSBzaW5nbGUgbm9kZSBpcyBwcmVzZW50LCBmb3IgbWVhc3VyaW5nLlxcbiAgICBpZiAoYnVpbGRlci5tYXAubGVuZ3RoID09IDApXFxuICAgICAgeyBidWlsZGVyLm1hcC5wdXNoKDAsIDAsIGJ1aWxkZXIuY29udGVudC5hcHBlbmRDaGlsZCh6ZXJvV2lkdGhFbGVtZW50KGNtLmRpc3BsYXkubWVhc3VyZSkpKSB9XFxuXFxuICAgIC8vIFN0b3JlIHRoZSBtYXAgYW5kIGEgY2FjaGUgb2JqZWN0IGZvciB0aGUgY3VycmVudCBsb2dpY2FsIGxpbmVcXG4gICAgaWYgKGkgPT0gMCkge1xcbiAgICAgIGxpbmVWaWV3Lm1lYXN1cmUubWFwID0gYnVpbGRlci5tYXBcXG4gICAgICBsaW5lVmlldy5tZWFzdXJlLmNhY2hlID0ge31cXG4gICAgfSBlbHNlIHtcXG4gICAgICA7KGxpbmVWaWV3Lm1lYXN1cmUubWFwcyB8fCAobGluZVZpZXcubWVhc3VyZS5tYXBzID0gW10pKS5wdXNoKGJ1aWxkZXIubWFwKVxcbiAgICAgIDsobGluZVZpZXcubWVhc3VyZS5jYWNoZXMgfHwgKGxpbmVWaWV3Lm1lYXN1cmUuY2FjaGVzID0gW10pKS5wdXNoKHt9KVxcbiAgICB9XFxuICB9XFxuXFxuICAvLyBTZWUgaXNzdWUgIzI5MDFcXG4gIGlmICh3ZWJraXQpIHtcXG4gICAgdmFyIGxhc3QgPSBidWlsZGVyLmNvbnRlbnQubGFzdENoaWxkXFxuICAgIGlmICgvXFxcXGJjbS10YWJcXFxcYi8udGVzdChsYXN0LmNsYXNzTmFtZSkgfHwgKGxhc3QucXVlcnlTZWxlY3RvciAmJiBsYXN0LnF1ZXJ5U2VsZWN0b3IoXFxcIi5jbS10YWJcXFwiKSkpXFxuICAgICAgeyBidWlsZGVyLmNvbnRlbnQuY2xhc3NOYW1lID0gXFxcImNtLXRhYi13cmFwLWhhY2tcXFwiIH1cXG4gIH1cXG5cXG4gIHNpZ25hbChjbSwgXFxcInJlbmRlckxpbmVcXFwiLCBjbSwgbGluZVZpZXcubGluZSwgYnVpbGRlci5wcmUpXFxuICBpZiAoYnVpbGRlci5wcmUuY2xhc3NOYW1lKVxcbiAgICB7IGJ1aWxkZXIudGV4dENsYXNzID0gam9pbkNsYXNzZXMoYnVpbGRlci5wcmUuY2xhc3NOYW1lLCBidWlsZGVyLnRleHRDbGFzcyB8fCBcXFwiXFxcIikgfVxcblxcbiAgcmV0dXJuIGJ1aWxkZXJcXG59XFxuXFxuZnVuY3Rpb24gZGVmYXVsdFNwZWNpYWxDaGFyUGxhY2Vob2xkZXIoY2gpIHtcXG4gIHZhciB0b2tlbiA9IGVsdChcXFwic3BhblxcXCIsIFxcXCJcXFxcdTIwMjJcXFwiLCBcXFwiY20taW52YWxpZGNoYXJcXFwiKVxcbiAgdG9rZW4udGl0bGUgPSBcXFwiXFxcXFxcXFx1XFxcIiArIGNoLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpXFxuICB0b2tlbi5zZXRBdHRyaWJ1dGUoXFxcImFyaWEtbGFiZWxcXFwiLCB0b2tlbi50aXRsZSlcXG4gIHJldHVybiB0b2tlblxcbn1cXG5cXG4vLyBCdWlsZCB1cCB0aGUgRE9NIHJlcHJlc2VudGF0aW9uIGZvciBhIHNpbmdsZSB0b2tlbiwgYW5kIGFkZCBpdCB0b1xcbi8vIHRoZSBsaW5lIG1hcC4gVGFrZXMgY2FyZSB0byByZW5kZXIgc3BlY2lhbCBjaGFyYWN0ZXJzIHNlcGFyYXRlbHkuXFxuZnVuY3Rpb24gYnVpbGRUb2tlbihidWlsZGVyLCB0ZXh0LCBzdHlsZSwgc3RhcnRTdHlsZSwgZW5kU3R5bGUsIHRpdGxlLCBjc3MpIHtcXG4gIGlmICghdGV4dCkgeyByZXR1cm4gfVxcbiAgdmFyIGRpc3BsYXlUZXh0ID0gYnVpbGRlci5zcGxpdFNwYWNlcyA/IHNwbGl0U3BhY2VzKHRleHQsIGJ1aWxkZXIudHJhaWxpbmdTcGFjZSkgOiB0ZXh0XFxuICB2YXIgc3BlY2lhbCA9IGJ1aWxkZXIuY20uc3RhdGUuc3BlY2lhbENoYXJzLCBtdXN0V3JhcCA9IGZhbHNlXFxuICB2YXIgY29udGVudFxcbiAgaWYgKCFzcGVjaWFsLnRlc3QodGV4dCkpIHtcXG4gICAgYnVpbGRlci5jb2wgKz0gdGV4dC5sZW5ndGhcXG4gICAgY29udGVudCA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGRpc3BsYXlUZXh0KVxcbiAgICBidWlsZGVyLm1hcC5wdXNoKGJ1aWxkZXIucG9zLCBidWlsZGVyLnBvcyArIHRleHQubGVuZ3RoLCBjb250ZW50KVxcbiAgICBpZiAoaWUgJiYgaWVfdmVyc2lvbiA8IDkpIHsgbXVzdFdyYXAgPSB0cnVlIH1cXG4gICAgYnVpbGRlci5wb3MgKz0gdGV4dC5sZW5ndGhcXG4gIH0gZWxzZSB7XFxuICAgIGNvbnRlbnQgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KClcXG4gICAgdmFyIHBvcyA9IDBcXG4gICAgd2hpbGUgKHRydWUpIHtcXG4gICAgICBzcGVjaWFsLmxhc3RJbmRleCA9IHBvc1xcbiAgICAgIHZhciBtID0gc3BlY2lhbC5leGVjKHRleHQpXFxuICAgICAgdmFyIHNraXBwZWQgPSBtID8gbS5pbmRleCAtIHBvcyA6IHRleHQubGVuZ3RoIC0gcG9zXFxuICAgICAgaWYgKHNraXBwZWQpIHtcXG4gICAgICAgIHZhciB0eHQgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShkaXNwbGF5VGV4dC5zbGljZShwb3MsIHBvcyArIHNraXBwZWQpKVxcbiAgICAgICAgaWYgKGllICYmIGllX3ZlcnNpb24gPCA5KSB7IGNvbnRlbnQuYXBwZW5kQ2hpbGQoZWx0KFxcXCJzcGFuXFxcIiwgW3R4dF0pKSB9XFxuICAgICAgICBlbHNlIHsgY29udGVudC5hcHBlbmRDaGlsZCh0eHQpIH1cXG4gICAgICAgIGJ1aWxkZXIubWFwLnB1c2goYnVpbGRlci5wb3MsIGJ1aWxkZXIucG9zICsgc2tpcHBlZCwgdHh0KVxcbiAgICAgICAgYnVpbGRlci5jb2wgKz0gc2tpcHBlZFxcbiAgICAgICAgYnVpbGRlci5wb3MgKz0gc2tpcHBlZFxcbiAgICAgIH1cXG4gICAgICBpZiAoIW0pIHsgYnJlYWsgfVxcbiAgICAgIHBvcyArPSBza2lwcGVkICsgMVxcbiAgICAgIHZhciB0eHQkMSA9ICh2b2lkIDApXFxuICAgICAgaWYgKG1bMF0gPT0gXFxcIlxcXFx0XFxcIikge1xcbiAgICAgICAgdmFyIHRhYlNpemUgPSBidWlsZGVyLmNtLm9wdGlvbnMudGFiU2l6ZSwgdGFiV2lkdGggPSB0YWJTaXplIC0gYnVpbGRlci5jb2wgJSB0YWJTaXplXFxuICAgICAgICB0eHQkMSA9IGNvbnRlbnQuYXBwZW5kQ2hpbGQoZWx0KFxcXCJzcGFuXFxcIiwgc3BhY2VTdHIodGFiV2lkdGgpLCBcXFwiY20tdGFiXFxcIikpXFxuICAgICAgICB0eHQkMS5zZXRBdHRyaWJ1dGUoXFxcInJvbGVcXFwiLCBcXFwicHJlc2VudGF0aW9uXFxcIilcXG4gICAgICAgIHR4dCQxLnNldEF0dHJpYnV0ZShcXFwiY20tdGV4dFxcXCIsIFxcXCJcXFxcdFxcXCIpXFxuICAgICAgICBidWlsZGVyLmNvbCArPSB0YWJXaWR0aFxcbiAgICAgIH0gZWxzZSBpZiAobVswXSA9PSBcXFwiXFxcXHJcXFwiIHx8IG1bMF0gPT0gXFxcIlxcXFxuXFxcIikge1xcbiAgICAgICAgdHh0JDEgPSBjb250ZW50LmFwcGVuZENoaWxkKGVsdChcXFwic3BhblxcXCIsIG1bMF0gPT0gXFxcIlxcXFxyXFxcIiA/IFxcXCJcXFxcdTI0MGRcXFwiIDogXFxcIlxcXFx1MjQyNFxcXCIsIFxcXCJjbS1pbnZhbGlkY2hhclxcXCIpKVxcbiAgICAgICAgdHh0JDEuc2V0QXR0cmlidXRlKFxcXCJjbS10ZXh0XFxcIiwgbVswXSlcXG4gICAgICAgIGJ1aWxkZXIuY29sICs9IDFcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgdHh0JDEgPSBidWlsZGVyLmNtLm9wdGlvbnMuc3BlY2lhbENoYXJQbGFjZWhvbGRlcihtWzBdKVxcbiAgICAgICAgdHh0JDEuc2V0QXR0cmlidXRlKFxcXCJjbS10ZXh0XFxcIiwgbVswXSlcXG4gICAgICAgIGlmIChpZSAmJiBpZV92ZXJzaW9uIDwgOSkgeyBjb250ZW50LmFwcGVuZENoaWxkKGVsdChcXFwic3BhblxcXCIsIFt0eHQkMV0pKSB9XFxuICAgICAgICBlbHNlIHsgY29udGVudC5hcHBlbmRDaGlsZCh0eHQkMSkgfVxcbiAgICAgICAgYnVpbGRlci5jb2wgKz0gMVxcbiAgICAgIH1cXG4gICAgICBidWlsZGVyLm1hcC5wdXNoKGJ1aWxkZXIucG9zLCBidWlsZGVyLnBvcyArIDEsIHR4dCQxKVxcbiAgICAgIGJ1aWxkZXIucG9zKytcXG4gICAgfVxcbiAgfVxcbiAgYnVpbGRlci50cmFpbGluZ1NwYWNlID0gZGlzcGxheVRleHQuY2hhckNvZGVBdCh0ZXh0Lmxlbmd0aCAtIDEpID09IDMyXFxuICBpZiAoc3R5bGUgfHwgc3RhcnRTdHlsZSB8fCBlbmRTdHlsZSB8fCBtdXN0V3JhcCB8fCBjc3MpIHtcXG4gICAgdmFyIGZ1bGxTdHlsZSA9IHN0eWxlIHx8IFxcXCJcXFwiXFxuICAgIGlmIChzdGFydFN0eWxlKSB7IGZ1bGxTdHlsZSArPSBzdGFydFN0eWxlIH1cXG4gICAgaWYgKGVuZFN0eWxlKSB7IGZ1bGxTdHlsZSArPSBlbmRTdHlsZSB9XFxuICAgIHZhciB0b2tlbiA9IGVsdChcXFwic3BhblxcXCIsIFtjb250ZW50XSwgZnVsbFN0eWxlLCBjc3MpXFxuICAgIGlmICh0aXRsZSkgeyB0b2tlbi50aXRsZSA9IHRpdGxlIH1cXG4gICAgcmV0dXJuIGJ1aWxkZXIuY29udGVudC5hcHBlbmRDaGlsZCh0b2tlbilcXG4gIH1cXG4gIGJ1aWxkZXIuY29udGVudC5hcHBlbmRDaGlsZChjb250ZW50KVxcbn1cXG5cXG5mdW5jdGlvbiBzcGxpdFNwYWNlcyh0ZXh0LCB0cmFpbGluZ0JlZm9yZSkge1xcbiAgaWYgKHRleHQubGVuZ3RoID4gMSAmJiAhLyAgLy50ZXN0KHRleHQpKSB7IHJldHVybiB0ZXh0IH1cXG4gIHZhciBzcGFjZUJlZm9yZSA9IHRyYWlsaW5nQmVmb3JlLCByZXN1bHQgPSBcXFwiXFxcIlxcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0ZXh0Lmxlbmd0aDsgaSsrKSB7XFxuICAgIHZhciBjaCA9IHRleHQuY2hhckF0KGkpXFxuICAgIGlmIChjaCA9PSBcXFwiIFxcXCIgJiYgc3BhY2VCZWZvcmUgJiYgKGkgPT0gdGV4dC5sZW5ndGggLSAxIHx8IHRleHQuY2hhckNvZGVBdChpICsgMSkgPT0gMzIpKVxcbiAgICAgIHsgY2ggPSBcXFwiXFxcXHUwMGEwXFxcIiB9XFxuICAgIHJlc3VsdCArPSBjaFxcbiAgICBzcGFjZUJlZm9yZSA9IGNoID09IFxcXCIgXFxcIlxcbiAgfVxcbiAgcmV0dXJuIHJlc3VsdFxcbn1cXG5cXG4vLyBXb3JrIGFyb3VuZCBub25zZW5zZSBkaW1lbnNpb25zIGJlaW5nIHJlcG9ydGVkIGZvciBzdHJldGNoZXMgb2ZcXG4vLyByaWdodC10by1sZWZ0IHRleHQuXFxuZnVuY3Rpb24gYnVpbGRUb2tlbkJhZEJpZGkoaW5uZXIsIG9yZGVyKSB7XFxuICByZXR1cm4gZnVuY3Rpb24gKGJ1aWxkZXIsIHRleHQsIHN0eWxlLCBzdGFydFN0eWxlLCBlbmRTdHlsZSwgdGl0bGUsIGNzcykge1xcbiAgICBzdHlsZSA9IHN0eWxlID8gc3R5bGUgKyBcXFwiIGNtLWZvcmNlLWJvcmRlclxcXCIgOiBcXFwiY20tZm9yY2UtYm9yZGVyXFxcIlxcbiAgICB2YXIgc3RhcnQgPSBidWlsZGVyLnBvcywgZW5kID0gc3RhcnQgKyB0ZXh0Lmxlbmd0aFxcbiAgICBmb3IgKDs7KSB7XFxuICAgICAgLy8gRmluZCB0aGUgcGFydCB0aGF0IG92ZXJsYXBzIHdpdGggdGhlIHN0YXJ0IG9mIHRoaXMgdGV4dFxcbiAgICAgIHZhciBwYXJ0ID0gKHZvaWQgMClcXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9yZGVyLmxlbmd0aDsgaSsrKSB7XFxuICAgICAgICBwYXJ0ID0gb3JkZXJbaV1cXG4gICAgICAgIGlmIChwYXJ0LnRvID4gc3RhcnQgJiYgcGFydC5mcm9tIDw9IHN0YXJ0KSB7IGJyZWFrIH1cXG4gICAgICB9XFxuICAgICAgaWYgKHBhcnQudG8gPj0gZW5kKSB7IHJldHVybiBpbm5lcihidWlsZGVyLCB0ZXh0LCBzdHlsZSwgc3RhcnRTdHlsZSwgZW5kU3R5bGUsIHRpdGxlLCBjc3MpIH1cXG4gICAgICBpbm5lcihidWlsZGVyLCB0ZXh0LnNsaWNlKDAsIHBhcnQudG8gLSBzdGFydCksIHN0eWxlLCBzdGFydFN0eWxlLCBudWxsLCB0aXRsZSwgY3NzKVxcbiAgICAgIHN0YXJ0U3R5bGUgPSBudWxsXFxuICAgICAgdGV4dCA9IHRleHQuc2xpY2UocGFydC50byAtIHN0YXJ0KVxcbiAgICAgIHN0YXJ0ID0gcGFydC50b1xcbiAgICB9XFxuICB9XFxufVxcblxcbmZ1bmN0aW9uIGJ1aWxkQ29sbGFwc2VkU3BhbihidWlsZGVyLCBzaXplLCBtYXJrZXIsIGlnbm9yZVdpZGdldCkge1xcbiAgdmFyIHdpZGdldCA9ICFpZ25vcmVXaWRnZXQgJiYgbWFya2VyLndpZGdldE5vZGVcXG4gIGlmICh3aWRnZXQpIHsgYnVpbGRlci5tYXAucHVzaChidWlsZGVyLnBvcywgYnVpbGRlci5wb3MgKyBzaXplLCB3aWRnZXQpIH1cXG4gIGlmICghaWdub3JlV2lkZ2V0ICYmIGJ1aWxkZXIuY20uZGlzcGxheS5pbnB1dC5uZWVkc0NvbnRlbnRBdHRyaWJ1dGUpIHtcXG4gICAgaWYgKCF3aWRnZXQpXFxuICAgICAgeyB3aWRnZXQgPSBidWlsZGVyLmNvbnRlbnQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcXFwic3BhblxcXCIpKSB9XFxuICAgIHdpZGdldC5zZXRBdHRyaWJ1dGUoXFxcImNtLW1hcmtlclxcXCIsIG1hcmtlci5pZClcXG4gIH1cXG4gIGlmICh3aWRnZXQpIHtcXG4gICAgYnVpbGRlci5jbS5kaXNwbGF5LmlucHV0LnNldFVuZWRpdGFibGUod2lkZ2V0KVxcbiAgICBidWlsZGVyLmNvbnRlbnQuYXBwZW5kQ2hpbGQod2lkZ2V0KVxcbiAgfVxcbiAgYnVpbGRlci5wb3MgKz0gc2l6ZVxcbiAgYnVpbGRlci50cmFpbGluZ1NwYWNlID0gZmFsc2VcXG59XFxuXFxuLy8gT3V0cHV0cyBhIG51bWJlciBvZiBzcGFucyB0byBtYWtlIHVwIGEgbGluZSwgdGFraW5nIGhpZ2hsaWdodGluZ1xcbi8vIGFuZCBtYXJrZWQgdGV4dCBpbnRvIGFjY291bnQuXFxuZnVuY3Rpb24gaW5zZXJ0TGluZUNvbnRlbnQobGluZSwgYnVpbGRlciwgc3R5bGVzKSB7XFxuICB2YXIgc3BhbnMgPSBsaW5lLm1hcmtlZFNwYW5zLCBhbGxUZXh0ID0gbGluZS50ZXh0LCBhdCA9IDBcXG4gIGlmICghc3BhbnMpIHtcXG4gICAgZm9yICh2YXIgaSQxID0gMTsgaSQxIDwgc3R5bGVzLmxlbmd0aDsgaSQxKz0yKVxcbiAgICAgIHsgYnVpbGRlci5hZGRUb2tlbihidWlsZGVyLCBhbGxUZXh0LnNsaWNlKGF0LCBhdCA9IHN0eWxlc1tpJDFdKSwgaW50ZXJwcmV0VG9rZW5TdHlsZShzdHlsZXNbaSQxKzFdLCBidWlsZGVyLmNtLm9wdGlvbnMpKSB9XFxuICAgIHJldHVyblxcbiAgfVxcblxcbiAgdmFyIGxlbiA9IGFsbFRleHQubGVuZ3RoLCBwb3MgPSAwLCBpID0gMSwgdGV4dCA9IFxcXCJcXFwiLCBzdHlsZSwgY3NzXFxuICB2YXIgbmV4dENoYW5nZSA9IDAsIHNwYW5TdHlsZSwgc3BhbkVuZFN0eWxlLCBzcGFuU3RhcnRTdHlsZSwgdGl0bGUsIGNvbGxhcHNlZFxcbiAgZm9yICg7Oykge1xcbiAgICBpZiAobmV4dENoYW5nZSA9PSBwb3MpIHsgLy8gVXBkYXRlIGN1cnJlbnQgbWFya2VyIHNldFxcbiAgICAgIHNwYW5TdHlsZSA9IHNwYW5FbmRTdHlsZSA9IHNwYW5TdGFydFN0eWxlID0gdGl0bGUgPSBjc3MgPSBcXFwiXFxcIlxcbiAgICAgIGNvbGxhcHNlZCA9IG51bGw7IG5leHRDaGFuZ2UgPSBJbmZpbml0eVxcbiAgICAgIHZhciBmb3VuZEJvb2ttYXJrcyA9IFtdLCBlbmRTdHlsZXMgPSAodm9pZCAwKVxcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgc3BhbnMubGVuZ3RoOyArK2opIHtcXG4gICAgICAgIHZhciBzcCA9IHNwYW5zW2pdLCBtID0gc3AubWFya2VyXFxuICAgICAgICBpZiAobS50eXBlID09IFxcXCJib29rbWFya1xcXCIgJiYgc3AuZnJvbSA9PSBwb3MgJiYgbS53aWRnZXROb2RlKSB7XFxuICAgICAgICAgIGZvdW5kQm9va21hcmtzLnB1c2gobSlcXG4gICAgICAgIH0gZWxzZSBpZiAoc3AuZnJvbSA8PSBwb3MgJiYgKHNwLnRvID09IG51bGwgfHwgc3AudG8gPiBwb3MgfHwgbS5jb2xsYXBzZWQgJiYgc3AudG8gPT0gcG9zICYmIHNwLmZyb20gPT0gcG9zKSkge1xcbiAgICAgICAgICBpZiAoc3AudG8gIT0gbnVsbCAmJiBzcC50byAhPSBwb3MgJiYgbmV4dENoYW5nZSA+IHNwLnRvKSB7XFxuICAgICAgICAgICAgbmV4dENoYW5nZSA9IHNwLnRvXFxuICAgICAgICAgICAgc3BhbkVuZFN0eWxlID0gXFxcIlxcXCJcXG4gICAgICAgICAgfVxcbiAgICAgICAgICBpZiAobS5jbGFzc05hbWUpIHsgc3BhblN0eWxlICs9IFxcXCIgXFxcIiArIG0uY2xhc3NOYW1lIH1cXG4gICAgICAgICAgaWYgKG0uY3NzKSB7IGNzcyA9IChjc3MgPyBjc3MgKyBcXFwiO1xcXCIgOiBcXFwiXFxcIikgKyBtLmNzcyB9XFxuICAgICAgICAgIGlmIChtLnN0YXJ0U3R5bGUgJiYgc3AuZnJvbSA9PSBwb3MpIHsgc3BhblN0YXJ0U3R5bGUgKz0gXFxcIiBcXFwiICsgbS5zdGFydFN0eWxlIH1cXG4gICAgICAgICAgaWYgKG0uZW5kU3R5bGUgJiYgc3AudG8gPT0gbmV4dENoYW5nZSkgeyAoZW5kU3R5bGVzIHx8IChlbmRTdHlsZXMgPSBbXSkpLnB1c2gobS5lbmRTdHlsZSwgc3AudG8pIH1cXG4gICAgICAgICAgaWYgKG0udGl0bGUgJiYgIXRpdGxlKSB7IHRpdGxlID0gbS50aXRsZSB9XFxuICAgICAgICAgIGlmIChtLmNvbGxhcHNlZCAmJiAoIWNvbGxhcHNlZCB8fCBjb21wYXJlQ29sbGFwc2VkTWFya2Vycyhjb2xsYXBzZWQubWFya2VyLCBtKSA8IDApKVxcbiAgICAgICAgICAgIHsgY29sbGFwc2VkID0gc3AgfVxcbiAgICAgICAgfSBlbHNlIGlmIChzcC5mcm9tID4gcG9zICYmIG5leHRDaGFuZ2UgPiBzcC5mcm9tKSB7XFxuICAgICAgICAgIG5leHRDaGFuZ2UgPSBzcC5mcm9tXFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICAgIGlmIChlbmRTdHlsZXMpIHsgZm9yICh2YXIgaiQxID0gMDsgaiQxIDwgZW5kU3R5bGVzLmxlbmd0aDsgaiQxICs9IDIpXFxuICAgICAgICB7IGlmIChlbmRTdHlsZXNbaiQxICsgMV0gPT0gbmV4dENoYW5nZSkgeyBzcGFuRW5kU3R5bGUgKz0gXFxcIiBcXFwiICsgZW5kU3R5bGVzW2okMV0gfSB9IH1cXG5cXG4gICAgICBpZiAoIWNvbGxhcHNlZCB8fCBjb2xsYXBzZWQuZnJvbSA9PSBwb3MpIHsgZm9yICh2YXIgaiQyID0gMDsgaiQyIDwgZm91bmRCb29rbWFya3MubGVuZ3RoOyArK2okMilcXG4gICAgICAgIHsgYnVpbGRDb2xsYXBzZWRTcGFuKGJ1aWxkZXIsIDAsIGZvdW5kQm9va21hcmtzW2okMl0pIH0gfVxcbiAgICAgIGlmIChjb2xsYXBzZWQgJiYgKGNvbGxhcHNlZC5mcm9tIHx8IDApID09IHBvcykge1xcbiAgICAgICAgYnVpbGRDb2xsYXBzZWRTcGFuKGJ1aWxkZXIsIChjb2xsYXBzZWQudG8gPT0gbnVsbCA/IGxlbiArIDEgOiBjb2xsYXBzZWQudG8pIC0gcG9zLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbGxhcHNlZC5tYXJrZXIsIGNvbGxhcHNlZC5mcm9tID09IG51bGwpXFxuICAgICAgICBpZiAoY29sbGFwc2VkLnRvID09IG51bGwpIHsgcmV0dXJuIH1cXG4gICAgICAgIGlmIChjb2xsYXBzZWQudG8gPT0gcG9zKSB7IGNvbGxhcHNlZCA9IGZhbHNlIH1cXG4gICAgICB9XFxuICAgIH1cXG4gICAgaWYgKHBvcyA+PSBsZW4pIHsgYnJlYWsgfVxcblxcbiAgICB2YXIgdXB0byA9IE1hdGgubWluKGxlbiwgbmV4dENoYW5nZSlcXG4gICAgd2hpbGUgKHRydWUpIHtcXG4gICAgICBpZiAodGV4dCkge1xcbiAgICAgICAgdmFyIGVuZCA9IHBvcyArIHRleHQubGVuZ3RoXFxuICAgICAgICBpZiAoIWNvbGxhcHNlZCkge1xcbiAgICAgICAgICB2YXIgdG9rZW5UZXh0ID0gZW5kID4gdXB0byA/IHRleHQuc2xpY2UoMCwgdXB0byAtIHBvcykgOiB0ZXh0XFxuICAgICAgICAgIGJ1aWxkZXIuYWRkVG9rZW4oYnVpbGRlciwgdG9rZW5UZXh0LCBzdHlsZSA/IHN0eWxlICsgc3BhblN0eWxlIDogc3BhblN0eWxlLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHNwYW5TdGFydFN0eWxlLCBwb3MgKyB0b2tlblRleHQubGVuZ3RoID09IG5leHRDaGFuZ2UgPyBzcGFuRW5kU3R5bGUgOiBcXFwiXFxcIiwgdGl0bGUsIGNzcylcXG4gICAgICAgIH1cXG4gICAgICAgIGlmIChlbmQgPj0gdXB0bykge3RleHQgPSB0ZXh0LnNsaWNlKHVwdG8gLSBwb3MpOyBwb3MgPSB1cHRvOyBicmVha31cXG4gICAgICAgIHBvcyA9IGVuZFxcbiAgICAgICAgc3BhblN0YXJ0U3R5bGUgPSBcXFwiXFxcIlxcbiAgICAgIH1cXG4gICAgICB0ZXh0ID0gYWxsVGV4dC5zbGljZShhdCwgYXQgPSBzdHlsZXNbaSsrXSlcXG4gICAgICBzdHlsZSA9IGludGVycHJldFRva2VuU3R5bGUoc3R5bGVzW2krK10sIGJ1aWxkZXIuY20ub3B0aW9ucylcXG4gICAgfVxcbiAgfVxcbn1cXG5cXG5cXG4vLyBUaGVzZSBvYmplY3RzIGFyZSB1c2VkIHRvIHJlcHJlc2VudCB0aGUgdmlzaWJsZSAoY3VycmVudGx5IGRyYXduKVxcbi8vIHBhcnQgb2YgdGhlIGRvY3VtZW50LiBBIExpbmVWaWV3IG1heSBjb3JyZXNwb25kIHRvIG11bHRpcGxlXFxuLy8gbG9naWNhbCBsaW5lcywgaWYgdGhvc2UgYXJlIGNvbm5lY3RlZCBieSBjb2xsYXBzZWQgcmFuZ2VzLlxcbmZ1bmN0aW9uIExpbmVWaWV3KGRvYywgbGluZSwgbGluZU4pIHtcXG4gIC8vIFRoZSBzdGFydGluZyBsaW5lXFxuICB0aGlzLmxpbmUgPSBsaW5lXFxuICAvLyBDb250aW51aW5nIGxpbmVzLCBpZiBhbnlcXG4gIHRoaXMucmVzdCA9IHZpc3VhbExpbmVDb250aW51ZWQobGluZSlcXG4gIC8vIE51bWJlciBvZiBsb2dpY2FsIGxpbmVzIGluIHRoaXMgdmlzdWFsIGxpbmVcXG4gIHRoaXMuc2l6ZSA9IHRoaXMucmVzdCA/IGxpbmVObyhsc3QodGhpcy5yZXN0KSkgLSBsaW5lTiArIDEgOiAxXFxuICB0aGlzLm5vZGUgPSB0aGlzLnRleHQgPSBudWxsXFxuICB0aGlzLmhpZGRlbiA9IGxpbmVJc0hpZGRlbihkb2MsIGxpbmUpXFxufVxcblxcbi8vIENyZWF0ZSBhIHJhbmdlIG9mIExpbmVWaWV3IG9iamVjdHMgZm9yIHRoZSBnaXZlbiBsaW5lcy5cXG5mdW5jdGlvbiBidWlsZFZpZXdBcnJheShjbSwgZnJvbSwgdG8pIHtcXG4gIHZhciBhcnJheSA9IFtdLCBuZXh0UG9zXFxuICBmb3IgKHZhciBwb3MgPSBmcm9tOyBwb3MgPCB0bzsgcG9zID0gbmV4dFBvcykge1xcbiAgICB2YXIgdmlldyA9IG5ldyBMaW5lVmlldyhjbS5kb2MsIGdldExpbmUoY20uZG9jLCBwb3MpLCBwb3MpXFxuICAgIG5leHRQb3MgPSBwb3MgKyB2aWV3LnNpemVcXG4gICAgYXJyYXkucHVzaCh2aWV3KVxcbiAgfVxcbiAgcmV0dXJuIGFycmF5XFxufVxcblxcbnZhciBvcGVyYXRpb25Hcm91cCA9IG51bGxcXG5cXG5mdW5jdGlvbiBwdXNoT3BlcmF0aW9uKG9wKSB7XFxuICBpZiAob3BlcmF0aW9uR3JvdXApIHtcXG4gICAgb3BlcmF0aW9uR3JvdXAub3BzLnB1c2gob3ApXFxuICB9IGVsc2Uge1xcbiAgICBvcC5vd25zR3JvdXAgPSBvcGVyYXRpb25Hcm91cCA9IHtcXG4gICAgICBvcHM6IFtvcF0sXFxuICAgICAgZGVsYXllZENhbGxiYWNrczogW11cXG4gICAgfVxcbiAgfVxcbn1cXG5cXG5mdW5jdGlvbiBmaXJlQ2FsbGJhY2tzRm9yT3BzKGdyb3VwKSB7XFxuICAvLyBDYWxscyBkZWxheWVkIGNhbGxiYWNrcyBhbmQgY3Vyc29yQWN0aXZpdHkgaGFuZGxlcnMgdW50aWwgbm9cXG4gIC8vIG5ldyBvbmVzIGFwcGVhclxcbiAgdmFyIGNhbGxiYWNrcyA9IGdyb3VwLmRlbGF5ZWRDYWxsYmFja3MsIGkgPSAwXFxuICBkbyB7XFxuICAgIGZvciAoOyBpIDwgY2FsbGJhY2tzLmxlbmd0aDsgaSsrKVxcbiAgICAgIHsgY2FsbGJhY2tzW2ldLmNhbGwobnVsbCkgfVxcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IGdyb3VwLm9wcy5sZW5ndGg7IGorKykge1xcbiAgICAgIHZhciBvcCA9IGdyb3VwLm9wc1tqXVxcbiAgICAgIGlmIChvcC5jdXJzb3JBY3Rpdml0eUhhbmRsZXJzKVxcbiAgICAgICAgeyB3aGlsZSAob3AuY3Vyc29yQWN0aXZpdHlDYWxsZWQgPCBvcC5jdXJzb3JBY3Rpdml0eUhhbmRsZXJzLmxlbmd0aClcXG4gICAgICAgICAgeyBvcC5jdXJzb3JBY3Rpdml0eUhhbmRsZXJzW29wLmN1cnNvckFjdGl2aXR5Q2FsbGVkKytdLmNhbGwobnVsbCwgb3AuY20pIH0gfVxcbiAgICB9XFxuICB9IHdoaWxlIChpIDwgY2FsbGJhY2tzLmxlbmd0aClcXG59XFxuXFxuZnVuY3Rpb24gZmluaXNoT3BlcmF0aW9uKG9wLCBlbmRDYikge1xcbiAgdmFyIGdyb3VwID0gb3Aub3duc0dyb3VwXFxuICBpZiAoIWdyb3VwKSB7IHJldHVybiB9XFxuXFxuICB0cnkgeyBmaXJlQ2FsbGJhY2tzRm9yT3BzKGdyb3VwKSB9XFxuICBmaW5hbGx5IHtcXG4gICAgb3BlcmF0aW9uR3JvdXAgPSBudWxsXFxuICAgIGVuZENiKGdyb3VwKVxcbiAgfVxcbn1cXG5cXG52YXIgb3JwaGFuRGVsYXllZENhbGxiYWNrcyA9IG51bGxcXG5cXG4vLyBPZnRlbiwgd2Ugd2FudCB0byBzaWduYWwgZXZlbnRzIGF0IGEgcG9pbnQgd2hlcmUgd2UgYXJlIGluIHRoZVxcbi8vIG1pZGRsZSBvZiBzb21lIHdvcmssIGJ1dCBkb24ndCB3YW50IHRoZSBoYW5kbGVyIHRvIHN0YXJ0IGNhbGxpbmdcXG4vLyBvdGhlciBtZXRob2RzIG9uIHRoZSBlZGl0b3IsIHdoaWNoIG1pZ2h0IGJlIGluIGFuIGluY29uc2lzdGVudFxcbi8vIHN0YXRlIG9yIHNpbXBseSBub3QgZXhwZWN0IGFueSBvdGhlciBldmVudHMgdG8gaGFwcGVuLlxcbi8vIHNpZ25hbExhdGVyIGxvb2tzIHdoZXRoZXIgdGhlcmUgYXJlIGFueSBoYW5kbGVycywgYW5kIHNjaGVkdWxlc1xcbi8vIHRoZW0gdG8gYmUgZXhlY3V0ZWQgd2hlbiB0aGUgbGFzdCBvcGVyYXRpb24gZW5kcywgb3IsIGlmIG5vXFxuLy8gb3BlcmF0aW9uIGlzIGFjdGl2ZSwgd2hlbiBhIHRpbWVvdXQgZmlyZXMuXFxuZnVuY3Rpb24gc2lnbmFsTGF0ZXIoZW1pdHRlciwgdHlwZSAvKiwgdmFsdWVzLi4uKi8pIHtcXG4gIHZhciBhcnIgPSBnZXRIYW5kbGVycyhlbWl0dGVyLCB0eXBlKVxcbiAgaWYgKCFhcnIubGVuZ3RoKSB7IHJldHVybiB9XFxuICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMiksIGxpc3RcXG4gIGlmIChvcGVyYXRpb25Hcm91cCkge1xcbiAgICBsaXN0ID0gb3BlcmF0aW9uR3JvdXAuZGVsYXllZENhbGxiYWNrc1xcbiAgfSBlbHNlIGlmIChvcnBoYW5EZWxheWVkQ2FsbGJhY2tzKSB7XFxuICAgIGxpc3QgPSBvcnBoYW5EZWxheWVkQ2FsbGJhY2tzXFxuICB9IGVsc2Uge1xcbiAgICBsaXN0ID0gb3JwaGFuRGVsYXllZENhbGxiYWNrcyA9IFtdXFxuICAgIHNldFRpbWVvdXQoZmlyZU9ycGhhbkRlbGF5ZWQsIDApXFxuICB9XFxuICB2YXIgbG9vcCA9IGZ1bmN0aW9uICggaSApIHtcXG4gICAgbGlzdC5wdXNoKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGFycltpXS5hcHBseShudWxsLCBhcmdzKTsgfSlcXG4gIH07XFxuXFxuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7ICsraSlcXG4gICAgbG9vcCggaSApO1xcbn1cXG5cXG5mdW5jdGlvbiBmaXJlT3JwaGFuRGVsYXllZCgpIHtcXG4gIHZhciBkZWxheWVkID0gb3JwaGFuRGVsYXllZENhbGxiYWNrc1xcbiAgb3JwaGFuRGVsYXllZENhbGxiYWNrcyA9IG51bGxcXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZGVsYXllZC5sZW5ndGg7ICsraSkgeyBkZWxheWVkW2ldKCkgfVxcbn1cXG5cXG4vLyBXaGVuIGFuIGFzcGVjdCBvZiBhIGxpbmUgY2hhbmdlcywgYSBzdHJpbmcgaXMgYWRkZWQgdG9cXG4vLyBsaW5lVmlldy5jaGFuZ2VzLiBUaGlzIHVwZGF0ZXMgdGhlIHJlbGV2YW50IHBhcnQgb2YgdGhlIGxpbmUnc1xcbi8vIERPTSBzdHJ1Y3R1cmUuXFxuZnVuY3Rpb24gdXBkYXRlTGluZUZvckNoYW5nZXMoY20sIGxpbmVWaWV3LCBsaW5lTiwgZGltcykge1xcbiAgZm9yICh2YXIgaiA9IDA7IGogPCBsaW5lVmlldy5jaGFuZ2VzLmxlbmd0aDsgaisrKSB7XFxuICAgIHZhciB0eXBlID0gbGluZVZpZXcuY2hhbmdlc1tqXVxcbiAgICBpZiAodHlwZSA9PSBcXFwidGV4dFxcXCIpIHsgdXBkYXRlTGluZVRleHQoY20sIGxpbmVWaWV3KSB9XFxuICAgIGVsc2UgaWYgKHR5cGUgPT0gXFxcImd1dHRlclxcXCIpIHsgdXBkYXRlTGluZUd1dHRlcihjbSwgbGluZVZpZXcsIGxpbmVOLCBkaW1zKSB9XFxuICAgIGVsc2UgaWYgKHR5cGUgPT0gXFxcImNsYXNzXFxcIikgeyB1cGRhdGVMaW5lQ2xhc3NlcyhsaW5lVmlldykgfVxcbiAgICBlbHNlIGlmICh0eXBlID09IFxcXCJ3aWRnZXRcXFwiKSB7IHVwZGF0ZUxpbmVXaWRnZXRzKGNtLCBsaW5lVmlldywgZGltcykgfVxcbiAgfVxcbiAgbGluZVZpZXcuY2hhbmdlcyA9IG51bGxcXG59XFxuXFxuLy8gTGluZXMgd2l0aCBndXR0ZXIgZWxlbWVudHMsIHdpZGdldHMgb3IgYSBiYWNrZ3JvdW5kIGNsYXNzIG5lZWQgdG9cXG4vLyBiZSB3cmFwcGVkLCBhbmQgaGF2ZSB0aGUgZXh0cmEgZWxlbWVudHMgYWRkZWQgdG8gdGhlIHdyYXBwZXIgZGl2XFxuZnVuY3Rpb24gZW5zdXJlTGluZVdyYXBwZWQobGluZVZpZXcpIHtcXG4gIGlmIChsaW5lVmlldy5ub2RlID09IGxpbmVWaWV3LnRleHQpIHtcXG4gICAgbGluZVZpZXcubm9kZSA9IGVsdChcXFwiZGl2XFxcIiwgbnVsbCwgbnVsbCwgXFxcInBvc2l0aW9uOiByZWxhdGl2ZVxcXCIpXFxuICAgIGlmIChsaW5lVmlldy50ZXh0LnBhcmVudE5vZGUpXFxuICAgICAgeyBsaW5lVmlldy50ZXh0LnBhcmVudE5vZGUucmVwbGFjZUNoaWxkKGxpbmVWaWV3Lm5vZGUsIGxpbmVWaWV3LnRleHQpIH1cXG4gICAgbGluZVZpZXcubm9kZS5hcHBlbmRDaGlsZChsaW5lVmlldy50ZXh0KVxcbiAgICBpZiAoaWUgJiYgaWVfdmVyc2lvbiA8IDgpIHsgbGluZVZpZXcubm9kZS5zdHlsZS56SW5kZXggPSAyIH1cXG4gIH1cXG4gIHJldHVybiBsaW5lVmlldy5ub2RlXFxufVxcblxcbmZ1bmN0aW9uIHVwZGF0ZUxpbmVCYWNrZ3JvdW5kKGxpbmVWaWV3KSB7XFxuICB2YXIgY2xzID0gbGluZVZpZXcuYmdDbGFzcyA/IGxpbmVWaWV3LmJnQ2xhc3MgKyBcXFwiIFxcXCIgKyAobGluZVZpZXcubGluZS5iZ0NsYXNzIHx8IFxcXCJcXFwiKSA6IGxpbmVWaWV3LmxpbmUuYmdDbGFzc1xcbiAgaWYgKGNscykgeyBjbHMgKz0gXFxcIiBDb2RlTWlycm9yLWxpbmViYWNrZ3JvdW5kXFxcIiB9XFxuICBpZiAobGluZVZpZXcuYmFja2dyb3VuZCkge1xcbiAgICBpZiAoY2xzKSB7IGxpbmVWaWV3LmJhY2tncm91bmQuY2xhc3NOYW1lID0gY2xzIH1cXG4gICAgZWxzZSB7IGxpbmVWaWV3LmJhY2tncm91bmQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChsaW5lVmlldy5iYWNrZ3JvdW5kKTsgbGluZVZpZXcuYmFja2dyb3VuZCA9IG51bGwgfVxcbiAgfSBlbHNlIGlmIChjbHMpIHtcXG4gICAgdmFyIHdyYXAgPSBlbnN1cmVMaW5lV3JhcHBlZChsaW5lVmlldylcXG4gICAgbGluZVZpZXcuYmFja2dyb3VuZCA9IHdyYXAuaW5zZXJ0QmVmb3JlKGVsdChcXFwiZGl2XFxcIiwgbnVsbCwgY2xzKSwgd3JhcC5maXJzdENoaWxkKVxcbiAgfVxcbn1cXG5cXG4vLyBXcmFwcGVyIGFyb3VuZCBidWlsZExpbmVDb250ZW50IHdoaWNoIHdpbGwgcmV1c2UgdGhlIHN0cnVjdHVyZVxcbi8vIGluIGRpc3BsYXkuZXh0ZXJuYWxNZWFzdXJlZCB3aGVuIHBvc3NpYmxlLlxcbmZ1bmN0aW9uIGdldExpbmVDb250ZW50KGNtLCBsaW5lVmlldykge1xcbiAgdmFyIGV4dCA9IGNtLmRpc3BsYXkuZXh0ZXJuYWxNZWFzdXJlZFxcbiAgaWYgKGV4dCAmJiBleHQubGluZSA9PSBsaW5lVmlldy5saW5lKSB7XFxuICAgIGNtLmRpc3BsYXkuZXh0ZXJuYWxNZWFzdXJlZCA9IG51bGxcXG4gICAgbGluZVZpZXcubWVhc3VyZSA9IGV4dC5tZWFzdXJlXFxuICAgIHJldHVybiBleHQuYnVpbHRcXG4gIH1cXG4gIHJldHVybiBidWlsZExpbmVDb250ZW50KGNtLCBsaW5lVmlldylcXG59XFxuXFxuLy8gUmVkcmF3IHRoZSBsaW5lJ3MgdGV4dC4gSW50ZXJhY3RzIHdpdGggdGhlIGJhY2tncm91bmQgYW5kIHRleHRcXG4vLyBjbGFzc2VzIGJlY2F1c2UgdGhlIG1vZGUgbWF5IG91dHB1dCB0b2tlbnMgdGhhdCBpbmZsdWVuY2UgdGhlc2VcXG4vLyBjbGFzc2VzLlxcbmZ1bmN0aW9uIHVwZGF0ZUxpbmVUZXh0KGNtLCBsaW5lVmlldykge1xcbiAgdmFyIGNscyA9IGxpbmVWaWV3LnRleHQuY2xhc3NOYW1lXFxuICB2YXIgYnVpbHQgPSBnZXRMaW5lQ29udGVudChjbSwgbGluZVZpZXcpXFxuICBpZiAobGluZVZpZXcudGV4dCA9PSBsaW5lVmlldy5ub2RlKSB7IGxpbmVWaWV3Lm5vZGUgPSBidWlsdC5wcmUgfVxcbiAgbGluZVZpZXcudGV4dC5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZChidWlsdC5wcmUsIGxpbmVWaWV3LnRleHQpXFxuICBsaW5lVmlldy50ZXh0ID0gYnVpbHQucHJlXFxuICBpZiAoYnVpbHQuYmdDbGFzcyAhPSBsaW5lVmlldy5iZ0NsYXNzIHx8IGJ1aWx0LnRleHRDbGFzcyAhPSBsaW5lVmlldy50ZXh0Q2xhc3MpIHtcXG4gICAgbGluZVZpZXcuYmdDbGFzcyA9IGJ1aWx0LmJnQ2xhc3NcXG4gICAgbGluZVZpZXcudGV4dENsYXNzID0gYnVpbHQudGV4dENsYXNzXFxuICAgIHVwZGF0ZUxpbmVDbGFzc2VzKGxpbmVWaWV3KVxcbiAgfSBlbHNlIGlmIChjbHMpIHtcXG4gICAgbGluZVZpZXcudGV4dC5jbGFzc05hbWUgPSBjbHNcXG4gIH1cXG59XFxuXFxuZnVuY3Rpb24gdXBkYXRlTGluZUNsYXNzZXMobGluZVZpZXcpIHtcXG4gIHVwZGF0ZUxpbmVCYWNrZ3JvdW5kKGxpbmVWaWV3KVxcbiAgaWYgKGxpbmVWaWV3LmxpbmUud3JhcENsYXNzKVxcbiAgICB7IGVuc3VyZUxpbmVXcmFwcGVkKGxpbmVWaWV3KS5jbGFzc05hbWUgPSBsaW5lVmlldy5saW5lLndyYXBDbGFzcyB9XFxuICBlbHNlIGlmIChsaW5lVmlldy5ub2RlICE9IGxpbmVWaWV3LnRleHQpXFxuICAgIHsgbGluZVZpZXcubm9kZS5jbGFzc05hbWUgPSBcXFwiXFxcIiB9XFxuICB2YXIgdGV4dENsYXNzID0gbGluZVZpZXcudGV4dENsYXNzID8gbGluZVZpZXcudGV4dENsYXNzICsgXFxcIiBcXFwiICsgKGxpbmVWaWV3LmxpbmUudGV4dENsYXNzIHx8IFxcXCJcXFwiKSA6IGxpbmVWaWV3LmxpbmUudGV4dENsYXNzXFxuICBsaW5lVmlldy50ZXh0LmNsYXNzTmFtZSA9IHRleHRDbGFzcyB8fCBcXFwiXFxcIlxcbn1cXG5cXG5mdW5jdGlvbiB1cGRhdGVMaW5lR3V0dGVyKGNtLCBsaW5lVmlldywgbGluZU4sIGRpbXMpIHtcXG4gIGlmIChsaW5lVmlldy5ndXR0ZXIpIHtcXG4gICAgbGluZVZpZXcubm9kZS5yZW1vdmVDaGlsZChsaW5lVmlldy5ndXR0ZXIpXFxuICAgIGxpbmVWaWV3Lmd1dHRlciA9IG51bGxcXG4gIH1cXG4gIGlmIChsaW5lVmlldy5ndXR0ZXJCYWNrZ3JvdW5kKSB7XFxuICAgIGxpbmVWaWV3Lm5vZGUucmVtb3ZlQ2hpbGQobGluZVZpZXcuZ3V0dGVyQmFja2dyb3VuZClcXG4gICAgbGluZVZpZXcuZ3V0dGVyQmFja2dyb3VuZCA9IG51bGxcXG4gIH1cXG4gIGlmIChsaW5lVmlldy5saW5lLmd1dHRlckNsYXNzKSB7XFxuICAgIHZhciB3cmFwID0gZW5zdXJlTGluZVdyYXBwZWQobGluZVZpZXcpXFxuICAgIGxpbmVWaWV3Lmd1dHRlckJhY2tncm91bmQgPSBlbHQoXFxcImRpdlxcXCIsIG51bGwsIFxcXCJDb2RlTWlycm9yLWd1dHRlci1iYWNrZ3JvdW5kIFxcXCIgKyBsaW5lVmlldy5saW5lLmd1dHRlckNsYXNzLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChcXFwibGVmdDogXFxcIiArIChjbS5vcHRpb25zLmZpeGVkR3V0dGVyID8gZGltcy5maXhlZFBvcyA6IC1kaW1zLmd1dHRlclRvdGFsV2lkdGgpICsgXFxcInB4OyB3aWR0aDogXFxcIiArIChkaW1zLmd1dHRlclRvdGFsV2lkdGgpICsgXFxcInB4XFxcIikpXFxuICAgIHdyYXAuaW5zZXJ0QmVmb3JlKGxpbmVWaWV3Lmd1dHRlckJhY2tncm91bmQsIGxpbmVWaWV3LnRleHQpXFxuICB9XFxuICB2YXIgbWFya2VycyA9IGxpbmVWaWV3LmxpbmUuZ3V0dGVyTWFya2Vyc1xcbiAgaWYgKGNtLm9wdGlvbnMubGluZU51bWJlcnMgfHwgbWFya2Vycykge1xcbiAgICB2YXIgd3JhcCQxID0gZW5zdXJlTGluZVdyYXBwZWQobGluZVZpZXcpXFxuICAgIHZhciBndXR0ZXJXcmFwID0gbGluZVZpZXcuZ3V0dGVyID0gZWx0KFxcXCJkaXZcXFwiLCBudWxsLCBcXFwiQ29kZU1pcnJvci1ndXR0ZXItd3JhcHBlclxcXCIsIChcXFwibGVmdDogXFxcIiArIChjbS5vcHRpb25zLmZpeGVkR3V0dGVyID8gZGltcy5maXhlZFBvcyA6IC1kaW1zLmd1dHRlclRvdGFsV2lkdGgpICsgXFxcInB4XFxcIikpXFxuICAgIGNtLmRpc3BsYXkuaW5wdXQuc2V0VW5lZGl0YWJsZShndXR0ZXJXcmFwKVxcbiAgICB3cmFwJDEuaW5zZXJ0QmVmb3JlKGd1dHRlcldyYXAsIGxpbmVWaWV3LnRleHQpXFxuICAgIGlmIChsaW5lVmlldy5saW5lLmd1dHRlckNsYXNzKVxcbiAgICAgIHsgZ3V0dGVyV3JhcC5jbGFzc05hbWUgKz0gXFxcIiBcXFwiICsgbGluZVZpZXcubGluZS5ndXR0ZXJDbGFzcyB9XFxuICAgIGlmIChjbS5vcHRpb25zLmxpbmVOdW1iZXJzICYmICghbWFya2VycyB8fCAhbWFya2Vyc1tcXFwiQ29kZU1pcnJvci1saW5lbnVtYmVyc1xcXCJdKSlcXG4gICAgICB7IGxpbmVWaWV3LmxpbmVOdW1iZXIgPSBndXR0ZXJXcmFwLmFwcGVuZENoaWxkKFxcbiAgICAgICAgZWx0KFxcXCJkaXZcXFwiLCBsaW5lTnVtYmVyRm9yKGNtLm9wdGlvbnMsIGxpbmVOKSxcXG4gICAgICAgICAgICBcXFwiQ29kZU1pcnJvci1saW5lbnVtYmVyIENvZGVNaXJyb3ItZ3V0dGVyLWVsdFxcXCIsXFxuICAgICAgICAgICAgKFxcXCJsZWZ0OiBcXFwiICsgKGRpbXMuZ3V0dGVyTGVmdFtcXFwiQ29kZU1pcnJvci1saW5lbnVtYmVyc1xcXCJdKSArIFxcXCJweDsgd2lkdGg6IFxcXCIgKyAoY20uZGlzcGxheS5saW5lTnVtSW5uZXJXaWR0aCkgKyBcXFwicHhcXFwiKSkpIH1cXG4gICAgaWYgKG1hcmtlcnMpIHsgZm9yICh2YXIgayA9IDA7IGsgPCBjbS5vcHRpb25zLmd1dHRlcnMubGVuZ3RoOyArK2spIHtcXG4gICAgICB2YXIgaWQgPSBjbS5vcHRpb25zLmd1dHRlcnNba10sIGZvdW5kID0gbWFya2Vycy5oYXNPd25Qcm9wZXJ0eShpZCkgJiYgbWFya2Vyc1tpZF1cXG4gICAgICBpZiAoZm91bmQpXFxuICAgICAgICB7IGd1dHRlcldyYXAuYXBwZW5kQ2hpbGQoZWx0KFxcXCJkaXZcXFwiLCBbZm91bmRdLCBcXFwiQ29kZU1pcnJvci1ndXR0ZXItZWx0XFxcIixcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChcXFwibGVmdDogXFxcIiArIChkaW1zLmd1dHRlckxlZnRbaWRdKSArIFxcXCJweDsgd2lkdGg6IFxcXCIgKyAoZGltcy5ndXR0ZXJXaWR0aFtpZF0pICsgXFxcInB4XFxcIikpKSB9XFxuICAgIH0gfVxcbiAgfVxcbn1cXG5cXG5mdW5jdGlvbiB1cGRhdGVMaW5lV2lkZ2V0cyhjbSwgbGluZVZpZXcsIGRpbXMpIHtcXG4gIGlmIChsaW5lVmlldy5hbGlnbmFibGUpIHsgbGluZVZpZXcuYWxpZ25hYmxlID0gbnVsbCB9XFxuICBmb3IgKHZhciBub2RlID0gbGluZVZpZXcubm9kZS5maXJzdENoaWxkLCBuZXh0ID0gKHZvaWQgMCk7IG5vZGU7IG5vZGUgPSBuZXh0KSB7XFxuICAgIG5leHQgPSBub2RlLm5leHRTaWJsaW5nXFxuICAgIGlmIChub2RlLmNsYXNzTmFtZSA9PSBcXFwiQ29kZU1pcnJvci1saW5ld2lkZ2V0XFxcIilcXG4gICAgICB7IGxpbmVWaWV3Lm5vZGUucmVtb3ZlQ2hpbGQobm9kZSkgfVxcbiAgfVxcbiAgaW5zZXJ0TGluZVdpZGdldHMoY20sIGxpbmVWaWV3LCBkaW1zKVxcbn1cXG5cXG4vLyBCdWlsZCBhIGxpbmUncyBET00gcmVwcmVzZW50YXRpb24gZnJvbSBzY3JhdGNoXFxuZnVuY3Rpb24gYnVpbGRMaW5lRWxlbWVudChjbSwgbGluZVZpZXcsIGxpbmVOLCBkaW1zKSB7XFxuICB2YXIgYnVpbHQgPSBnZXRMaW5lQ29udGVudChjbSwgbGluZVZpZXcpXFxuICBsaW5lVmlldy50ZXh0ID0gbGluZVZpZXcubm9kZSA9IGJ1aWx0LnByZVxcbiAgaWYgKGJ1aWx0LmJnQ2xhc3MpIHsgbGluZVZpZXcuYmdDbGFzcyA9IGJ1aWx0LmJnQ2xhc3MgfVxcbiAgaWYgKGJ1aWx0LnRleHRDbGFzcykgeyBsaW5lVmlldy50ZXh0Q2xhc3MgPSBidWlsdC50ZXh0Q2xhc3MgfVxcblxcbiAgdXBkYXRlTGluZUNsYXNzZXMobGluZVZpZXcpXFxuICB1cGRhdGVMaW5lR3V0dGVyKGNtLCBsaW5lVmlldywgbGluZU4sIGRpbXMpXFxuICBpbnNlcnRMaW5lV2lkZ2V0cyhjbSwgbGluZVZpZXcsIGRpbXMpXFxuICByZXR1cm4gbGluZVZpZXcubm9kZVxcbn1cXG5cXG4vLyBBIGxpbmVWaWV3IG1heSBjb250YWluIG11bHRpcGxlIGxvZ2ljYWwgbGluZXMgKHdoZW4gbWVyZ2VkIGJ5XFxuLy8gY29sbGFwc2VkIHNwYW5zKS4gVGhlIHdpZGdldHMgZm9yIGFsbCBvZiB0aGVtIG5lZWQgdG8gYmUgZHJhd24uXFxuZnVuY3Rpb24gaW5zZXJ0TGluZVdpZGdldHMoY20sIGxpbmVWaWV3LCBkaW1zKSB7XFxuICBpbnNlcnRMaW5lV2lkZ2V0c0ZvcihjbSwgbGluZVZpZXcubGluZSwgbGluZVZpZXcsIGRpbXMsIHRydWUpXFxuICBpZiAobGluZVZpZXcucmVzdCkgeyBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmVWaWV3LnJlc3QubGVuZ3RoOyBpKyspXFxuICAgIHsgaW5zZXJ0TGluZVdpZGdldHNGb3IoY20sIGxpbmVWaWV3LnJlc3RbaV0sIGxpbmVWaWV3LCBkaW1zLCBmYWxzZSkgfSB9XFxufVxcblxcbmZ1bmN0aW9uIGluc2VydExpbmVXaWRnZXRzRm9yKGNtLCBsaW5lLCBsaW5lVmlldywgZGltcywgYWxsb3dBYm92ZSkge1xcbiAgaWYgKCFsaW5lLndpZGdldHMpIHsgcmV0dXJuIH1cXG4gIHZhciB3cmFwID0gZW5zdXJlTGluZVdyYXBwZWQobGluZVZpZXcpXFxuICBmb3IgKHZhciBpID0gMCwgd3MgPSBsaW5lLndpZGdldHM7IGkgPCB3cy5sZW5ndGg7ICsraSkge1xcbiAgICB2YXIgd2lkZ2V0ID0gd3NbaV0sIG5vZGUgPSBlbHQoXFxcImRpdlxcXCIsIFt3aWRnZXQubm9kZV0sIFxcXCJDb2RlTWlycm9yLWxpbmV3aWRnZXRcXFwiKVxcbiAgICBpZiAoIXdpZGdldC5oYW5kbGVNb3VzZUV2ZW50cykgeyBub2RlLnNldEF0dHJpYnV0ZShcXFwiY20taWdub3JlLWV2ZW50c1xcXCIsIFxcXCJ0cnVlXFxcIikgfVxcbiAgICBwb3NpdGlvbkxpbmVXaWRnZXQod2lkZ2V0LCBub2RlLCBsaW5lVmlldywgZGltcylcXG4gICAgY20uZGlzcGxheS5pbnB1dC5zZXRVbmVkaXRhYmxlKG5vZGUpXFxuICAgIGlmIChhbGxvd0Fib3ZlICYmIHdpZGdldC5hYm92ZSlcXG4gICAgICB7IHdyYXAuaW5zZXJ0QmVmb3JlKG5vZGUsIGxpbmVWaWV3Lmd1dHRlciB8fCBsaW5lVmlldy50ZXh0KSB9XFxuICAgIGVsc2VcXG4gICAgICB7IHdyYXAuYXBwZW5kQ2hpbGQobm9kZSkgfVxcbiAgICBzaWduYWxMYXRlcih3aWRnZXQsIFxcXCJyZWRyYXdcXFwiKVxcbiAgfVxcbn1cXG5cXG5mdW5jdGlvbiBwb3NpdGlvbkxpbmVXaWRnZXQod2lkZ2V0LCBub2RlLCBsaW5lVmlldywgZGltcykge1xcbiAgaWYgKHdpZGdldC5ub0hTY3JvbGwpIHtcXG4gICAgOyhsaW5lVmlldy5hbGlnbmFibGUgfHwgKGxpbmVWaWV3LmFsaWduYWJsZSA9IFtdKSkucHVzaChub2RlKVxcbiAgICB2YXIgd2lkdGggPSBkaW1zLndyYXBwZXJXaWR0aFxcbiAgICBub2RlLnN0eWxlLmxlZnQgPSBkaW1zLmZpeGVkUG9zICsgXFxcInB4XFxcIlxcbiAgICBpZiAoIXdpZGdldC5jb3Zlckd1dHRlcikge1xcbiAgICAgIHdpZHRoIC09IGRpbXMuZ3V0dGVyVG90YWxXaWR0aFxcbiAgICAgIG5vZGUuc3R5bGUucGFkZGluZ0xlZnQgPSBkaW1zLmd1dHRlclRvdGFsV2lkdGggKyBcXFwicHhcXFwiXFxuICAgIH1cXG4gICAgbm9kZS5zdHlsZS53aWR0aCA9IHdpZHRoICsgXFxcInB4XFxcIlxcbiAgfVxcbiAgaWYgKHdpZGdldC5jb3Zlckd1dHRlcikge1xcbiAgICBub2RlLnN0eWxlLnpJbmRleCA9IDVcXG4gICAgbm9kZS5zdHlsZS5wb3NpdGlvbiA9IFxcXCJyZWxhdGl2ZVxcXCJcXG4gICAgaWYgKCF3aWRnZXQubm9IU2Nyb2xsKSB7IG5vZGUuc3R5bGUubWFyZ2luTGVmdCA9IC1kaW1zLmd1dHRlclRvdGFsV2lkdGggKyBcXFwicHhcXFwiIH1cXG4gIH1cXG59XFxuXFxuZnVuY3Rpb24gd2lkZ2V0SGVpZ2h0KHdpZGdldCkge1xcbiAgaWYgKHdpZGdldC5oZWlnaHQgIT0gbnVsbCkgeyByZXR1cm4gd2lkZ2V0LmhlaWdodCB9XFxuICB2YXIgY20gPSB3aWRnZXQuZG9jLmNtXFxuICBpZiAoIWNtKSB7IHJldHVybiAwIH1cXG4gIGlmICghY29udGFpbnMoZG9jdW1lbnQuYm9keSwgd2lkZ2V0Lm5vZGUpKSB7XFxuICAgIHZhciBwYXJlbnRTdHlsZSA9IFxcXCJwb3NpdGlvbjogcmVsYXRpdmU7XFxcIlxcbiAgICBpZiAod2lkZ2V0LmNvdmVyR3V0dGVyKVxcbiAgICAgIHsgcGFyZW50U3R5bGUgKz0gXFxcIm1hcmdpbi1sZWZ0OiAtXFxcIiArIGNtLmRpc3BsYXkuZ3V0dGVycy5vZmZzZXRXaWR0aCArIFxcXCJweDtcXFwiIH1cXG4gICAgaWYgKHdpZGdldC5ub0hTY3JvbGwpXFxuICAgICAgeyBwYXJlbnRTdHlsZSArPSBcXFwid2lkdGg6IFxcXCIgKyBjbS5kaXNwbGF5LndyYXBwZXIuY2xpZW50V2lkdGggKyBcXFwicHg7XFxcIiB9XFxuICAgIHJlbW92ZUNoaWxkcmVuQW5kQWRkKGNtLmRpc3BsYXkubWVhc3VyZSwgZWx0KFxcXCJkaXZcXFwiLCBbd2lkZ2V0Lm5vZGVdLCBudWxsLCBwYXJlbnRTdHlsZSkpXFxuICB9XFxuICByZXR1cm4gd2lkZ2V0LmhlaWdodCA9IHdpZGdldC5ub2RlLnBhcmVudE5vZGUub2Zmc2V0SGVpZ2h0XFxufVxcblxcbi8vIFJldHVybiB0cnVlIHdoZW4gdGhlIGdpdmVuIG1vdXNlIGV2ZW50IGhhcHBlbmVkIGluIGEgd2lkZ2V0XFxuZnVuY3Rpb24gZXZlbnRJbldpZGdldChkaXNwbGF5LCBlKSB7XFxuICBmb3IgKHZhciBuID0gZV90YXJnZXQoZSk7IG4gIT0gZGlzcGxheS53cmFwcGVyOyBuID0gbi5wYXJlbnROb2RlKSB7XFxuICAgIGlmICghbiB8fCAobi5ub2RlVHlwZSA9PSAxICYmIG4uZ2V0QXR0cmlidXRlKFxcXCJjbS1pZ25vcmUtZXZlbnRzXFxcIikgPT0gXFxcInRydWVcXFwiKSB8fFxcbiAgICAgICAgKG4ucGFyZW50Tm9kZSA9PSBkaXNwbGF5LnNpemVyICYmIG4gIT0gZGlzcGxheS5tb3ZlcikpXFxuICAgICAgeyByZXR1cm4gdHJ1ZSB9XFxuICB9XFxufVxcblxcbi8vIFBPU0lUSU9OIE1FQVNVUkVNRU5UXFxuXFxuZnVuY3Rpb24gcGFkZGluZ1RvcChkaXNwbGF5KSB7cmV0dXJuIGRpc3BsYXkubGluZVNwYWNlLm9mZnNldFRvcH1cXG5mdW5jdGlvbiBwYWRkaW5nVmVydChkaXNwbGF5KSB7cmV0dXJuIGRpc3BsYXkubW92ZXIub2Zmc2V0SGVpZ2h0IC0gZGlzcGxheS5saW5lU3BhY2Uub2Zmc2V0SGVpZ2h0fVxcbmZ1bmN0aW9uIHBhZGRpbmdIKGRpc3BsYXkpIHtcXG4gIGlmIChkaXNwbGF5LmNhY2hlZFBhZGRpbmdIKSB7IHJldHVybiBkaXNwbGF5LmNhY2hlZFBhZGRpbmdIIH1cXG4gIHZhciBlID0gcmVtb3ZlQ2hpbGRyZW5BbmRBZGQoZGlzcGxheS5tZWFzdXJlLCBlbHQoXFxcInByZVxcXCIsIFxcXCJ4XFxcIikpXFxuICB2YXIgc3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSA/IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGUpIDogZS5jdXJyZW50U3R5bGVcXG4gIHZhciBkYXRhID0ge2xlZnQ6IHBhcnNlSW50KHN0eWxlLnBhZGRpbmdMZWZ0KSwgcmlnaHQ6IHBhcnNlSW50KHN0eWxlLnBhZGRpbmdSaWdodCl9XFxuICBpZiAoIWlzTmFOKGRhdGEubGVmdCkgJiYgIWlzTmFOKGRhdGEucmlnaHQpKSB7IGRpc3BsYXkuY2FjaGVkUGFkZGluZ0ggPSBkYXRhIH1cXG4gIHJldHVybiBkYXRhXFxufVxcblxcbmZ1bmN0aW9uIHNjcm9sbEdhcChjbSkgeyByZXR1cm4gc2Nyb2xsZXJHYXAgLSBjbS5kaXNwbGF5Lm5hdGl2ZUJhcldpZHRoIH1cXG5mdW5jdGlvbiBkaXNwbGF5V2lkdGgoY20pIHtcXG4gIHJldHVybiBjbS5kaXNwbGF5LnNjcm9sbGVyLmNsaWVudFdpZHRoIC0gc2Nyb2xsR2FwKGNtKSAtIGNtLmRpc3BsYXkuYmFyV2lkdGhcXG59XFxuZnVuY3Rpb24gZGlzcGxheUhlaWdodChjbSkge1xcbiAgcmV0dXJuIGNtLmRpc3BsYXkuc2Nyb2xsZXIuY2xpZW50SGVpZ2h0IC0gc2Nyb2xsR2FwKGNtKSAtIGNtLmRpc3BsYXkuYmFySGVpZ2h0XFxufVxcblxcbi8vIEVuc3VyZSB0aGUgbGluZVZpZXcud3JhcHBpbmcuaGVpZ2h0cyBhcnJheSBpcyBwb3B1bGF0ZWQuIFRoaXMgaXNcXG4vLyBhbiBhcnJheSBvZiBib3R0b20gb2Zmc2V0cyBmb3IgdGhlIGxpbmVzIHRoYXQgbWFrZSB1cCBhIGRyYXduXFxuLy8gbGluZS4gV2hlbiBsaW5lV3JhcHBpbmcgaXMgb24sIHRoZXJlIG1pZ2h0IGJlIG1vcmUgdGhhbiBvbmVcXG4vLyBoZWlnaHQuXFxuZnVuY3Rpb24gZW5zdXJlTGluZUhlaWdodHMoY20sIGxpbmVWaWV3LCByZWN0KSB7XFxuICB2YXIgd3JhcHBpbmcgPSBjbS5vcHRpb25zLmxpbmVXcmFwcGluZ1xcbiAgdmFyIGN1cldpZHRoID0gd3JhcHBpbmcgJiYgZGlzcGxheVdpZHRoKGNtKVxcbiAgaWYgKCFsaW5lVmlldy5tZWFzdXJlLmhlaWdodHMgfHwgd3JhcHBpbmcgJiYgbGluZVZpZXcubWVhc3VyZS53aWR0aCAhPSBjdXJXaWR0aCkge1xcbiAgICB2YXIgaGVpZ2h0cyA9IGxpbmVWaWV3Lm1lYXN1cmUuaGVpZ2h0cyA9IFtdXFxuICAgIGlmICh3cmFwcGluZykge1xcbiAgICAgIGxpbmVWaWV3Lm1lYXN1cmUud2lkdGggPSBjdXJXaWR0aFxcbiAgICAgIHZhciByZWN0cyA9IGxpbmVWaWV3LnRleHQuZmlyc3RDaGlsZC5nZXRDbGllbnRSZWN0cygpXFxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZWN0cy5sZW5ndGggLSAxOyBpKyspIHtcXG4gICAgICAgIHZhciBjdXIgPSByZWN0c1tpXSwgbmV4dCA9IHJlY3RzW2kgKyAxXVxcbiAgICAgICAgaWYgKE1hdGguYWJzKGN1ci5ib3R0b20gLSBuZXh0LmJvdHRvbSkgPiAyKVxcbiAgICAgICAgICB7IGhlaWdodHMucHVzaCgoY3VyLmJvdHRvbSArIG5leHQudG9wKSAvIDIgLSByZWN0LnRvcCkgfVxcbiAgICAgIH1cXG4gICAgfVxcbiAgICBoZWlnaHRzLnB1c2gocmVjdC5ib3R0b20gLSByZWN0LnRvcClcXG4gIH1cXG59XFxuXFxuLy8gRmluZCBhIGxpbmUgbWFwIChtYXBwaW5nIGNoYXJhY3RlciBvZmZzZXRzIHRvIHRleHQgbm9kZXMpIGFuZCBhXFxuLy8gbWVhc3VyZW1lbnQgY2FjaGUgZm9yIHRoZSBnaXZlbiBsaW5lIG51bWJlci4gKEEgbGluZSB2aWV3IG1pZ2h0XFxuLy8gY29udGFpbiBtdWx0aXBsZSBsaW5lcyB3aGVuIGNvbGxhcHNlZCByYW5nZXMgYXJlIHByZXNlbnQuKVxcbmZ1bmN0aW9uIG1hcEZyb21MaW5lVmlldyhsaW5lVmlldywgbGluZSwgbGluZU4pIHtcXG4gIGlmIChsaW5lVmlldy5saW5lID09IGxpbmUpXFxuICAgIHsgcmV0dXJuIHttYXA6IGxpbmVWaWV3Lm1lYXN1cmUubWFwLCBjYWNoZTogbGluZVZpZXcubWVhc3VyZS5jYWNoZX0gfVxcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lVmlldy5yZXN0Lmxlbmd0aDsgaSsrKVxcbiAgICB7IGlmIChsaW5lVmlldy5yZXN0W2ldID09IGxpbmUpXFxuICAgICAgeyByZXR1cm4ge21hcDogbGluZVZpZXcubWVhc3VyZS5tYXBzW2ldLCBjYWNoZTogbGluZVZpZXcubWVhc3VyZS5jYWNoZXNbaV19IH0gfVxcbiAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgbGluZVZpZXcucmVzdC5sZW5ndGg7IGkkMSsrKVxcbiAgICB7IGlmIChsaW5lTm8obGluZVZpZXcucmVzdFtpJDFdKSA+IGxpbmVOKVxcbiAgICAgIHsgcmV0dXJuIHttYXA6IGxpbmVWaWV3Lm1lYXN1cmUubWFwc1tpJDFdLCBjYWNoZTogbGluZVZpZXcubWVhc3VyZS5jYWNoZXNbaSQxXSwgYmVmb3JlOiB0cnVlfSB9IH1cXG59XFxuXFxuLy8gUmVuZGVyIGEgbGluZSBpbnRvIHRoZSBoaWRkZW4gbm9kZSBkaXNwbGF5LmV4dGVybmFsTWVhc3VyZWQuIFVzZWRcXG4vLyB3aGVuIG1lYXN1cmVtZW50IGlzIG5lZWRlZCBmb3IgYSBsaW5lIHRoYXQncyBub3QgaW4gdGhlIHZpZXdwb3J0LlxcbmZ1bmN0aW9uIHVwZGF0ZUV4dGVybmFsTWVhc3VyZW1lbnQoY20sIGxpbmUpIHtcXG4gIGxpbmUgPSB2aXN1YWxMaW5lKGxpbmUpXFxuICB2YXIgbGluZU4gPSBsaW5lTm8obGluZSlcXG4gIHZhciB2aWV3ID0gY20uZGlzcGxheS5leHRlcm5hbE1lYXN1cmVkID0gbmV3IExpbmVWaWV3KGNtLmRvYywgbGluZSwgbGluZU4pXFxuICB2aWV3LmxpbmVOID0gbGluZU5cXG4gIHZhciBidWlsdCA9IHZpZXcuYnVpbHQgPSBidWlsZExpbmVDb250ZW50KGNtLCB2aWV3KVxcbiAgdmlldy50ZXh0ID0gYnVpbHQucHJlXFxuICByZW1vdmVDaGlsZHJlbkFuZEFkZChjbS5kaXNwbGF5LmxpbmVNZWFzdXJlLCBidWlsdC5wcmUpXFxuICByZXR1cm4gdmlld1xcbn1cXG5cXG4vLyBHZXQgYSB7dG9wLCBib3R0b20sIGxlZnQsIHJpZ2h0fSBib3ggKGluIGxpbmUtbG9jYWwgY29vcmRpbmF0ZXMpXFxuLy8gZm9yIGEgZ2l2ZW4gY2hhcmFjdGVyLlxcbmZ1bmN0aW9uIG1lYXN1cmVDaGFyKGNtLCBsaW5lLCBjaCwgYmlhcykge1xcbiAgcmV0dXJuIG1lYXN1cmVDaGFyUHJlcGFyZWQoY20sIHByZXBhcmVNZWFzdXJlRm9yTGluZShjbSwgbGluZSksIGNoLCBiaWFzKVxcbn1cXG5cXG4vLyBGaW5kIGEgbGluZSB2aWV3IHRoYXQgY29ycmVzcG9uZHMgdG8gdGhlIGdpdmVuIGxpbmUgbnVtYmVyLlxcbmZ1bmN0aW9uIGZpbmRWaWV3Rm9yTGluZShjbSwgbGluZU4pIHtcXG4gIGlmIChsaW5lTiA+PSBjbS5kaXNwbGF5LnZpZXdGcm9tICYmIGxpbmVOIDwgY20uZGlzcGxheS52aWV3VG8pXFxuICAgIHsgcmV0dXJuIGNtLmRpc3BsYXkudmlld1tmaW5kVmlld0luZGV4KGNtLCBsaW5lTildIH1cXG4gIHZhciBleHQgPSBjbS5kaXNwbGF5LmV4dGVybmFsTWVhc3VyZWRcXG4gIGlmIChleHQgJiYgbGluZU4gPj0gZXh0LmxpbmVOICYmIGxpbmVOIDwgZXh0LmxpbmVOICsgZXh0LnNpemUpXFxuICAgIHsgcmV0dXJuIGV4dCB9XFxufVxcblxcbi8vIE1lYXN1cmVtZW50IGNhbiBiZSBzcGxpdCBpbiB0d28gc3RlcHMsIHRoZSBzZXQtdXAgd29yayB0aGF0XFxuLy8gYXBwbGllcyB0byB0aGUgd2hvbGUgbGluZSwgYW5kIHRoZSBtZWFzdXJlbWVudCBvZiB0aGUgYWN0dWFsXFxuLy8gY2hhcmFjdGVyLiBGdW5jdGlvbnMgbGlrZSBjb29yZHNDaGFyLCB0aGF0IG5lZWQgdG8gZG8gYSBsb3Qgb2ZcXG4vLyBtZWFzdXJlbWVudHMgaW4gYSByb3csIGNhbiB0aHVzIGVuc3VyZSB0aGF0IHRoZSBzZXQtdXAgd29yayBpc1xcbi8vIG9ubHkgZG9uZSBvbmNlLlxcbmZ1bmN0aW9uIHByZXBhcmVNZWFzdXJlRm9yTGluZShjbSwgbGluZSkge1xcbiAgdmFyIGxpbmVOID0gbGluZU5vKGxpbmUpXFxuICB2YXIgdmlldyA9IGZpbmRWaWV3Rm9yTGluZShjbSwgbGluZU4pXFxuICBpZiAodmlldyAmJiAhdmlldy50ZXh0KSB7XFxuICAgIHZpZXcgPSBudWxsXFxuICB9IGVsc2UgaWYgKHZpZXcgJiYgdmlldy5jaGFuZ2VzKSB7XFxuICAgIHVwZGF0ZUxpbmVGb3JDaGFuZ2VzKGNtLCB2aWV3LCBsaW5lTiwgZ2V0RGltZW5zaW9ucyhjbSkpXFxuICAgIGNtLmN1ck9wLmZvcmNlVXBkYXRlID0gdHJ1ZVxcbiAgfVxcbiAgaWYgKCF2aWV3KVxcbiAgICB7IHZpZXcgPSB1cGRhdGVFeHRlcm5hbE1lYXN1cmVtZW50KGNtLCBsaW5lKSB9XFxuXFxuICB2YXIgaW5mbyA9IG1hcEZyb21MaW5lVmlldyh2aWV3LCBsaW5lLCBsaW5lTilcXG4gIHJldHVybiB7XFxuICAgIGxpbmU6IGxpbmUsIHZpZXc6IHZpZXcsIHJlY3Q6IG51bGwsXFxuICAgIG1hcDogaW5mby5tYXAsIGNhY2hlOiBpbmZvLmNhY2hlLCBiZWZvcmU6IGluZm8uYmVmb3JlLFxcbiAgICBoYXNIZWlnaHRzOiBmYWxzZVxcbiAgfVxcbn1cXG5cXG4vLyBHaXZlbiBhIHByZXBhcmVkIG1lYXN1cmVtZW50IG9iamVjdCwgbWVhc3VyZXMgdGhlIHBvc2l0aW9uIG9mIGFuXFxuLy8gYWN0dWFsIGNoYXJhY3RlciAob3IgZmV0Y2hlcyBpdCBmcm9tIHRoZSBjYWNoZSkuXFxuZnVuY3Rpb24gbWVhc3VyZUNoYXJQcmVwYXJlZChjbSwgcHJlcGFyZWQsIGNoLCBiaWFzLCB2YXJIZWlnaHQpIHtcXG4gIGlmIChwcmVwYXJlZC5iZWZvcmUpIHsgY2ggPSAtMSB9XFxuICB2YXIga2V5ID0gY2ggKyAoYmlhcyB8fCBcXFwiXFxcIiksIGZvdW5kXFxuICBpZiAocHJlcGFyZWQuY2FjaGUuaGFzT3duUHJvcGVydHkoa2V5KSkge1xcbiAgICBmb3VuZCA9IHByZXBhcmVkLmNhY2hlW2tleV1cXG4gIH0gZWxzZSB7XFxuICAgIGlmICghcHJlcGFyZWQucmVjdClcXG4gICAgICB7IHByZXBhcmVkLnJlY3QgPSBwcmVwYXJlZC52aWV3LnRleHQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkgfVxcbiAgICBpZiAoIXByZXBhcmVkLmhhc0hlaWdodHMpIHtcXG4gICAgICBlbnN1cmVMaW5lSGVpZ2h0cyhjbSwgcHJlcGFyZWQudmlldywgcHJlcGFyZWQucmVjdClcXG4gICAgICBwcmVwYXJlZC5oYXNIZWlnaHRzID0gdHJ1ZVxcbiAgICB9XFxuICAgIGZvdW5kID0gbWVhc3VyZUNoYXJJbm5lcihjbSwgcHJlcGFyZWQsIGNoLCBiaWFzKVxcbiAgICBpZiAoIWZvdW5kLmJvZ3VzKSB7IHByZXBhcmVkLmNhY2hlW2tleV0gPSBmb3VuZCB9XFxuICB9XFxuICByZXR1cm4ge2xlZnQ6IGZvdW5kLmxlZnQsIHJpZ2h0OiBmb3VuZC5yaWdodCxcXG4gICAgICAgICAgdG9wOiB2YXJIZWlnaHQgPyBmb3VuZC5ydG9wIDogZm91bmQudG9wLFxcbiAgICAgICAgICBib3R0b206IHZhckhlaWdodCA/IGZvdW5kLnJib3R0b20gOiBmb3VuZC5ib3R0b219XFxufVxcblxcbnZhciBudWxsUmVjdCA9IHtsZWZ0OiAwLCByaWdodDogMCwgdG9wOiAwLCBib3R0b206IDB9XFxuXFxuZnVuY3Rpb24gbm9kZUFuZE9mZnNldEluTGluZU1hcChtYXAsIGNoLCBiaWFzKSB7XFxuICB2YXIgbm9kZSwgc3RhcnQsIGVuZCwgY29sbGFwc2UsIG1TdGFydCwgbUVuZFxcbiAgLy8gRmlyc3QsIHNlYXJjaCB0aGUgbGluZSBtYXAgZm9yIHRoZSB0ZXh0IG5vZGUgY29ycmVzcG9uZGluZyB0byxcXG4gIC8vIG9yIGNsb3Nlc3QgdG8sIHRoZSB0YXJnZXQgY2hhcmFjdGVyLlxcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXAubGVuZ3RoOyBpICs9IDMpIHtcXG4gICAgbVN0YXJ0ID0gbWFwW2ldXFxuICAgIG1FbmQgPSBtYXBbaSArIDFdXFxuICAgIGlmIChjaCA8IG1TdGFydCkge1xcbiAgICAgIHN0YXJ0ID0gMDsgZW5kID0gMVxcbiAgICAgIGNvbGxhcHNlID0gXFxcImxlZnRcXFwiXFxuICAgIH0gZWxzZSBpZiAoY2ggPCBtRW5kKSB7XFxuICAgICAgc3RhcnQgPSBjaCAtIG1TdGFydFxcbiAgICAgIGVuZCA9IHN0YXJ0ICsgMVxcbiAgICB9IGVsc2UgaWYgKGkgPT0gbWFwLmxlbmd0aCAtIDMgfHwgY2ggPT0gbUVuZCAmJiBtYXBbaSArIDNdID4gY2gpIHtcXG4gICAgICBlbmQgPSBtRW5kIC0gbVN0YXJ0XFxuICAgICAgc3RhcnQgPSBlbmQgLSAxXFxuICAgICAgaWYgKGNoID49IG1FbmQpIHsgY29sbGFwc2UgPSBcXFwicmlnaHRcXFwiIH1cXG4gICAgfVxcbiAgICBpZiAoc3RhcnQgIT0gbnVsbCkge1xcbiAgICAgIG5vZGUgPSBtYXBbaSArIDJdXFxuICAgICAgaWYgKG1TdGFydCA9PSBtRW5kICYmIGJpYXMgPT0gKG5vZGUuaW5zZXJ0TGVmdCA/IFxcXCJsZWZ0XFxcIiA6IFxcXCJyaWdodFxcXCIpKVxcbiAgICAgICAgeyBjb2xsYXBzZSA9IGJpYXMgfVxcbiAgICAgIGlmIChiaWFzID09IFxcXCJsZWZ0XFxcIiAmJiBzdGFydCA9PSAwKVxcbiAgICAgICAgeyB3aGlsZSAoaSAmJiBtYXBbaSAtIDJdID09IG1hcFtpIC0gM10gJiYgbWFwW2kgLSAxXS5pbnNlcnRMZWZ0KSB7XFxuICAgICAgICAgIG5vZGUgPSBtYXBbKGkgLT0gMykgKyAyXVxcbiAgICAgICAgICBjb2xsYXBzZSA9IFxcXCJsZWZ0XFxcIlxcbiAgICAgICAgfSB9XFxuICAgICAgaWYgKGJpYXMgPT0gXFxcInJpZ2h0XFxcIiAmJiBzdGFydCA9PSBtRW5kIC0gbVN0YXJ0KVxcbiAgICAgICAgeyB3aGlsZSAoaSA8IG1hcC5sZW5ndGggLSAzICYmIG1hcFtpICsgM10gPT0gbWFwW2kgKyA0XSAmJiAhbWFwW2kgKyA1XS5pbnNlcnRMZWZ0KSB7XFxuICAgICAgICAgIG5vZGUgPSBtYXBbKGkgKz0gMykgKyAyXVxcbiAgICAgICAgICBjb2xsYXBzZSA9IFxcXCJyaWdodFxcXCJcXG4gICAgICAgIH0gfVxcbiAgICAgIGJyZWFrXFxuICAgIH1cXG4gIH1cXG4gIHJldHVybiB7bm9kZTogbm9kZSwgc3RhcnQ6IHN0YXJ0LCBlbmQ6IGVuZCwgY29sbGFwc2U6IGNvbGxhcHNlLCBjb3ZlclN0YXJ0OiBtU3RhcnQsIGNvdmVyRW5kOiBtRW5kfVxcbn1cXG5cXG5mdW5jdGlvbiBnZXRVc2VmdWxSZWN0KHJlY3RzLCBiaWFzKSB7XFxuICB2YXIgcmVjdCA9IG51bGxSZWN0XFxuICBpZiAoYmlhcyA9PSBcXFwibGVmdFxcXCIpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCByZWN0cy5sZW5ndGg7IGkrKykge1xcbiAgICBpZiAoKHJlY3QgPSByZWN0c1tpXSkubGVmdCAhPSByZWN0LnJpZ2h0KSB7IGJyZWFrIH1cXG4gIH0gfSBlbHNlIHsgZm9yICh2YXIgaSQxID0gcmVjdHMubGVuZ3RoIC0gMTsgaSQxID49IDA7IGkkMS0tKSB7XFxuICAgIGlmICgocmVjdCA9IHJlY3RzW2kkMV0pLmxlZnQgIT0gcmVjdC5yaWdodCkgeyBicmVhayB9XFxuICB9IH1cXG4gIHJldHVybiByZWN0XFxufVxcblxcbmZ1bmN0aW9uIG1lYXN1cmVDaGFySW5uZXIoY20sIHByZXBhcmVkLCBjaCwgYmlhcykge1xcbiAgdmFyIHBsYWNlID0gbm9kZUFuZE9mZnNldEluTGluZU1hcChwcmVwYXJlZC5tYXAsIGNoLCBiaWFzKVxcbiAgdmFyIG5vZGUgPSBwbGFjZS5ub2RlLCBzdGFydCA9IHBsYWNlLnN0YXJ0LCBlbmQgPSBwbGFjZS5lbmQsIGNvbGxhcHNlID0gcGxhY2UuY29sbGFwc2VcXG5cXG4gIHZhciByZWN0XFxuICBpZiAobm9kZS5ub2RlVHlwZSA9PSAzKSB7IC8vIElmIGl0IGlzIGEgdGV4dCBub2RlLCB1c2UgYSByYW5nZSB0byByZXRyaWV2ZSB0aGUgY29vcmRpbmF0ZXMuXFxuICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IDQ7IGkkMSsrKSB7IC8vIFJldHJ5IGEgbWF4aW11bSBvZiA0IHRpbWVzIHdoZW4gbm9uc2Vuc2UgcmVjdGFuZ2xlcyBhcmUgcmV0dXJuZWRcXG4gICAgICB3aGlsZSAoc3RhcnQgJiYgaXNFeHRlbmRpbmdDaGFyKHByZXBhcmVkLmxpbmUudGV4dC5jaGFyQXQocGxhY2UuY292ZXJTdGFydCArIHN0YXJ0KSkpIHsgLS1zdGFydCB9XFxuICAgICAgd2hpbGUgKHBsYWNlLmNvdmVyU3RhcnQgKyBlbmQgPCBwbGFjZS5jb3ZlckVuZCAmJiBpc0V4dGVuZGluZ0NoYXIocHJlcGFyZWQubGluZS50ZXh0LmNoYXJBdChwbGFjZS5jb3ZlclN0YXJ0ICsgZW5kKSkpIHsgKytlbmQgfVxcbiAgICAgIGlmIChpZSAmJiBpZV92ZXJzaW9uIDwgOSAmJiBzdGFydCA9PSAwICYmIGVuZCA9PSBwbGFjZS5jb3ZlckVuZCAtIHBsYWNlLmNvdmVyU3RhcnQpXFxuICAgICAgICB7IHJlY3QgPSBub2RlLnBhcmVudE5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkgfVxcbiAgICAgIGVsc2VcXG4gICAgICAgIHsgcmVjdCA9IGdldFVzZWZ1bFJlY3QocmFuZ2Uobm9kZSwgc3RhcnQsIGVuZCkuZ2V0Q2xpZW50UmVjdHMoKSwgYmlhcykgfVxcbiAgICAgIGlmIChyZWN0LmxlZnQgfHwgcmVjdC5yaWdodCB8fCBzdGFydCA9PSAwKSB7IGJyZWFrIH1cXG4gICAgICBlbmQgPSBzdGFydFxcbiAgICAgIHN0YXJ0ID0gc3RhcnQgLSAxXFxuICAgICAgY29sbGFwc2UgPSBcXFwicmlnaHRcXFwiXFxuICAgIH1cXG4gICAgaWYgKGllICYmIGllX3ZlcnNpb24gPCAxMSkgeyByZWN0ID0gbWF5YmVVcGRhdGVSZWN0Rm9yWm9vbWluZyhjbS5kaXNwbGF5Lm1lYXN1cmUsIHJlY3QpIH1cXG4gIH0gZWxzZSB7IC8vIElmIGl0IGlzIGEgd2lkZ2V0LCBzaW1wbHkgZ2V0IHRoZSBib3ggZm9yIHRoZSB3aG9sZSB3aWRnZXQuXFxuICAgIGlmIChzdGFydCA+IDApIHsgY29sbGFwc2UgPSBiaWFzID0gXFxcInJpZ2h0XFxcIiB9XFxuICAgIHZhciByZWN0c1xcbiAgICBpZiAoY20ub3B0aW9ucy5saW5lV3JhcHBpbmcgJiYgKHJlY3RzID0gbm9kZS5nZXRDbGllbnRSZWN0cygpKS5sZW5ndGggPiAxKVxcbiAgICAgIHsgcmVjdCA9IHJlY3RzW2JpYXMgPT0gXFxcInJpZ2h0XFxcIiA/IHJlY3RzLmxlbmd0aCAtIDEgOiAwXSB9XFxuICAgIGVsc2VcXG4gICAgICB7IHJlY3QgPSBub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpIH1cXG4gIH1cXG4gIGlmIChpZSAmJiBpZV92ZXJzaW9uIDwgOSAmJiAhc3RhcnQgJiYgKCFyZWN0IHx8ICFyZWN0LmxlZnQgJiYgIXJlY3QucmlnaHQpKSB7XFxuICAgIHZhciByU3BhbiA9IG5vZGUucGFyZW50Tm9kZS5nZXRDbGllbnRSZWN0cygpWzBdXFxuICAgIGlmIChyU3BhbilcXG4gICAgICB7IHJlY3QgPSB7bGVmdDogclNwYW4ubGVmdCwgcmlnaHQ6IHJTcGFuLmxlZnQgKyBjaGFyV2lkdGgoY20uZGlzcGxheSksIHRvcDogclNwYW4udG9wLCBib3R0b206IHJTcGFuLmJvdHRvbX0gfVxcbiAgICBlbHNlXFxuICAgICAgeyByZWN0ID0gbnVsbFJlY3QgfVxcbiAgfVxcblxcbiAgdmFyIHJ0b3AgPSByZWN0LnRvcCAtIHByZXBhcmVkLnJlY3QudG9wLCByYm90ID0gcmVjdC5ib3R0b20gLSBwcmVwYXJlZC5yZWN0LnRvcFxcbiAgdmFyIG1pZCA9IChydG9wICsgcmJvdCkgLyAyXFxuICB2YXIgaGVpZ2h0cyA9IHByZXBhcmVkLnZpZXcubWVhc3VyZS5oZWlnaHRzXFxuICB2YXIgaSA9IDBcXG4gIGZvciAoOyBpIDwgaGVpZ2h0cy5sZW5ndGggLSAxOyBpKyspXFxuICAgIHsgaWYgKG1pZCA8IGhlaWdodHNbaV0pIHsgYnJlYWsgfSB9XFxuICB2YXIgdG9wID0gaSA/IGhlaWdodHNbaSAtIDFdIDogMCwgYm90ID0gaGVpZ2h0c1tpXVxcbiAgdmFyIHJlc3VsdCA9IHtsZWZ0OiAoY29sbGFwc2UgPT0gXFxcInJpZ2h0XFxcIiA/IHJlY3QucmlnaHQgOiByZWN0LmxlZnQpIC0gcHJlcGFyZWQucmVjdC5sZWZ0LFxcbiAgICAgICAgICAgICAgICByaWdodDogKGNvbGxhcHNlID09IFxcXCJsZWZ0XFxcIiA/IHJlY3QubGVmdCA6IHJlY3QucmlnaHQpIC0gcHJlcGFyZWQucmVjdC5sZWZ0LFxcbiAgICAgICAgICAgICAgICB0b3A6IHRvcCwgYm90dG9tOiBib3R9XFxuICBpZiAoIXJlY3QubGVmdCAmJiAhcmVjdC5yaWdodCkgeyByZXN1bHQuYm9ndXMgPSB0cnVlIH1cXG4gIGlmICghY20ub3B0aW9ucy5zaW5nbGVDdXJzb3JIZWlnaHRQZXJMaW5lKSB7IHJlc3VsdC5ydG9wID0gcnRvcDsgcmVzdWx0LnJib3R0b20gPSByYm90IH1cXG5cXG4gIHJldHVybiByZXN1bHRcXG59XFxuXFxuLy8gV29yayBhcm91bmQgcHJvYmxlbSB3aXRoIGJvdW5kaW5nIGNsaWVudCByZWN0cyBvbiByYW5nZXMgYmVpbmdcXG4vLyByZXR1cm5lZCBpbmNvcnJlY3RseSB3aGVuIHpvb21lZCBvbiBJRTEwIGFuZCBiZWxvdy5cXG5mdW5jdGlvbiBtYXliZVVwZGF0ZVJlY3RGb3Jab29taW5nKG1lYXN1cmUsIHJlY3QpIHtcXG4gIGlmICghd2luZG93LnNjcmVlbiB8fCBzY3JlZW4ubG9naWNhbFhEUEkgPT0gbnVsbCB8fFxcbiAgICAgIHNjcmVlbi5sb2dpY2FsWERQSSA9PSBzY3JlZW4uZGV2aWNlWERQSSB8fCAhaGFzQmFkWm9vbWVkUmVjdHMobWVhc3VyZSkpXFxuICAgIHsgcmV0dXJuIHJlY3QgfVxcbiAgdmFyIHNjYWxlWCA9IHNjcmVlbi5sb2dpY2FsWERQSSAvIHNjcmVlbi5kZXZpY2VYRFBJXFxuICB2YXIgc2NhbGVZID0gc2NyZWVuLmxvZ2ljYWxZRFBJIC8gc2NyZWVuLmRldmljZVlEUElcXG4gIHJldHVybiB7bGVmdDogcmVjdC5sZWZ0ICogc2NhbGVYLCByaWdodDogcmVjdC5yaWdodCAqIHNjYWxlWCxcXG4gICAgICAgICAgdG9wOiByZWN0LnRvcCAqIHNjYWxlWSwgYm90dG9tOiByZWN0LmJvdHRvbSAqIHNjYWxlWX1cXG59XFxuXFxuZnVuY3Rpb24gY2xlYXJMaW5lTWVhc3VyZW1lbnRDYWNoZUZvcihsaW5lVmlldykge1xcbiAgaWYgKGxpbmVWaWV3Lm1lYXN1cmUpIHtcXG4gICAgbGluZVZpZXcubWVhc3VyZS5jYWNoZSA9IHt9XFxuICAgIGxpbmVWaWV3Lm1lYXN1cmUuaGVpZ2h0cyA9IG51bGxcXG4gICAgaWYgKGxpbmVWaWV3LnJlc3QpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lVmlldy5yZXN0Lmxlbmd0aDsgaSsrKVxcbiAgICAgIHsgbGluZVZpZXcubWVhc3VyZS5jYWNoZXNbaV0gPSB7fSB9IH1cXG4gIH1cXG59XFxuXFxuZnVuY3Rpb24gY2xlYXJMaW5lTWVhc3VyZW1lbnRDYWNoZShjbSkge1xcbiAgY20uZGlzcGxheS5leHRlcm5hbE1lYXN1cmUgPSBudWxsXFxuICByZW1vdmVDaGlsZHJlbihjbS5kaXNwbGF5LmxpbmVNZWFzdXJlKVxcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjbS5kaXNwbGF5LnZpZXcubGVuZ3RoOyBpKyspXFxuICAgIHsgY2xlYXJMaW5lTWVhc3VyZW1lbnRDYWNoZUZvcihjbS5kaXNwbGF5LnZpZXdbaV0pIH1cXG59XFxuXFxuZnVuY3Rpb24gY2xlYXJDYWNoZXMoY20pIHtcXG4gIGNsZWFyTGluZU1lYXN1cmVtZW50Q2FjaGUoY20pXFxuICBjbS5kaXNwbGF5LmNhY2hlZENoYXJXaWR0aCA9IGNtLmRpc3BsYXkuY2FjaGVkVGV4dEhlaWdodCA9IGNtLmRpc3BsYXkuY2FjaGVkUGFkZGluZ0ggPSBudWxsXFxuICBpZiAoIWNtLm9wdGlvbnMubGluZVdyYXBwaW5nKSB7IGNtLmRpc3BsYXkubWF4TGluZUNoYW5nZWQgPSB0cnVlIH1cXG4gIGNtLmRpc3BsYXkubGluZU51bUNoYXJzID0gbnVsbFxcbn1cXG5cXG5mdW5jdGlvbiBwYWdlU2Nyb2xsWCgpIHsgcmV0dXJuIHdpbmRvdy5wYWdlWE9mZnNldCB8fCAoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50IHx8IGRvY3VtZW50LmJvZHkpLnNjcm9sbExlZnQgfVxcbmZ1bmN0aW9uIHBhZ2VTY3JvbGxZKCkgeyByZXR1cm4gd2luZG93LnBhZ2VZT2Zmc2V0IHx8IChkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgfHwgZG9jdW1lbnQuYm9keSkuc2Nyb2xsVG9wIH1cXG5cXG4vLyBDb252ZXJ0cyBhIHt0b3AsIGJvdHRvbSwgbGVmdCwgcmlnaHR9IGJveCBmcm9tIGxpbmUtbG9jYWxcXG4vLyBjb29yZGluYXRlcyBpbnRvIGFub3RoZXIgY29vcmRpbmF0ZSBzeXN0ZW0uIENvbnRleHQgbWF5IGJlIG9uZSBvZlxcbi8vIFxcXCJsaW5lXFxcIiwgXFxcImRpdlxcXCIgKGRpc3BsYXkubGluZURpdiksIFxcXCJsb2NhbFxcXCIuL251bGwgKGVkaXRvciksIFxcXCJ3aW5kb3dcXFwiLFxcbi8vIG9yIFxcXCJwYWdlXFxcIi5cXG5mdW5jdGlvbiBpbnRvQ29vcmRTeXN0ZW0oY20sIGxpbmVPYmosIHJlY3QsIGNvbnRleHQsIGluY2x1ZGVXaWRnZXRzKSB7XFxuICBpZiAoIWluY2x1ZGVXaWRnZXRzICYmIGxpbmVPYmoud2lkZ2V0cykgeyBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmVPYmoud2lkZ2V0cy5sZW5ndGg7ICsraSkgeyBpZiAobGluZU9iai53aWRnZXRzW2ldLmFib3ZlKSB7XFxuICAgIHZhciBzaXplID0gd2lkZ2V0SGVpZ2h0KGxpbmVPYmoud2lkZ2V0c1tpXSlcXG4gICAgcmVjdC50b3AgKz0gc2l6ZTsgcmVjdC5ib3R0b20gKz0gc2l6ZVxcbiAgfSB9IH1cXG4gIGlmIChjb250ZXh0ID09IFxcXCJsaW5lXFxcIikgeyByZXR1cm4gcmVjdCB9XFxuICBpZiAoIWNvbnRleHQpIHsgY29udGV4dCA9IFxcXCJsb2NhbFxcXCIgfVxcbiAgdmFyIHlPZmYgPSBoZWlnaHRBdExpbmUobGluZU9iailcXG4gIGlmIChjb250ZXh0ID09IFxcXCJsb2NhbFxcXCIpIHsgeU9mZiArPSBwYWRkaW5nVG9wKGNtLmRpc3BsYXkpIH1cXG4gIGVsc2UgeyB5T2ZmIC09IGNtLmRpc3BsYXkudmlld09mZnNldCB9XFxuICBpZiAoY29udGV4dCA9PSBcXFwicGFnZVxcXCIgfHwgY29udGV4dCA9PSBcXFwid2luZG93XFxcIikge1xcbiAgICB2YXIgbE9mZiA9IGNtLmRpc3BsYXkubGluZVNwYWNlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXFxuICAgIHlPZmYgKz0gbE9mZi50b3AgKyAoY29udGV4dCA9PSBcXFwid2luZG93XFxcIiA/IDAgOiBwYWdlU2Nyb2xsWSgpKVxcbiAgICB2YXIgeE9mZiA9IGxPZmYubGVmdCArIChjb250ZXh0ID09IFxcXCJ3aW5kb3dcXFwiID8gMCA6IHBhZ2VTY3JvbGxYKCkpXFxuICAgIHJlY3QubGVmdCArPSB4T2ZmOyByZWN0LnJpZ2h0ICs9IHhPZmZcXG4gIH1cXG4gIHJlY3QudG9wICs9IHlPZmY7IHJlY3QuYm90dG9tICs9IHlPZmZcXG4gIHJldHVybiByZWN0XFxufVxcblxcbi8vIENvdmVydHMgYSBib3ggZnJvbSBcXFwiZGl2XFxcIiBjb29yZHMgdG8gYW5vdGhlciBjb29yZGluYXRlIHN5c3RlbS5cXG4vLyBDb250ZXh0IG1heSBiZSBcXFwid2luZG93XFxcIiwgXFxcInBhZ2VcXFwiLCBcXFwiZGl2XFxcIiwgb3IgXFxcImxvY2FsXFxcIi4vbnVsbC5cXG5mdW5jdGlvbiBmcm9tQ29vcmRTeXN0ZW0oY20sIGNvb3JkcywgY29udGV4dCkge1xcbiAgaWYgKGNvbnRleHQgPT0gXFxcImRpdlxcXCIpIHsgcmV0dXJuIGNvb3JkcyB9XFxuICB2YXIgbGVmdCA9IGNvb3Jkcy5sZWZ0LCB0b3AgPSBjb29yZHMudG9wXFxuICAvLyBGaXJzdCBtb3ZlIGludG8gXFxcInBhZ2VcXFwiIGNvb3JkaW5hdGUgc3lzdGVtXFxuICBpZiAoY29udGV4dCA9PSBcXFwicGFnZVxcXCIpIHtcXG4gICAgbGVmdCAtPSBwYWdlU2Nyb2xsWCgpXFxuICAgIHRvcCAtPSBwYWdlU2Nyb2xsWSgpXFxuICB9IGVsc2UgaWYgKGNvbnRleHQgPT0gXFxcImxvY2FsXFxcIiB8fCAhY29udGV4dCkge1xcbiAgICB2YXIgbG9jYWxCb3ggPSBjbS5kaXNwbGF5LnNpemVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXFxuICAgIGxlZnQgKz0gbG9jYWxCb3gubGVmdFxcbiAgICB0b3AgKz0gbG9jYWxCb3gudG9wXFxuICB9XFxuXFxuICB2YXIgbGluZVNwYWNlQm94ID0gY20uZGlzcGxheS5saW5lU3BhY2UuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClcXG4gIHJldHVybiB7bGVmdDogbGVmdCAtIGxpbmVTcGFjZUJveC5sZWZ0LCB0b3A6IHRvcCAtIGxpbmVTcGFjZUJveC50b3B9XFxufVxcblxcbmZ1bmN0aW9uIGNoYXJDb29yZHMoY20sIHBvcywgY29udGV4dCwgbGluZU9iaiwgYmlhcykge1xcbiAgaWYgKCFsaW5lT2JqKSB7IGxpbmVPYmogPSBnZXRMaW5lKGNtLmRvYywgcG9zLmxpbmUpIH1cXG4gIHJldHVybiBpbnRvQ29vcmRTeXN0ZW0oY20sIGxpbmVPYmosIG1lYXN1cmVDaGFyKGNtLCBsaW5lT2JqLCBwb3MuY2gsIGJpYXMpLCBjb250ZXh0KVxcbn1cXG5cXG4vLyBSZXR1cm5zIGEgYm94IGZvciBhIGdpdmVuIGN1cnNvciBwb3NpdGlvbiwgd2hpY2ggbWF5IGhhdmUgYW5cXG4vLyAnb3RoZXInIHByb3BlcnR5IGNvbnRhaW5pbmcgdGhlIHBvc2l0aW9uIG9mIHRoZSBzZWNvbmRhcnkgY3Vyc29yXFxuLy8gb24gYSBiaWRpIGJvdW5kYXJ5LlxcbmZ1bmN0aW9uIGN1cnNvckNvb3JkcyhjbSwgcG9zLCBjb250ZXh0LCBsaW5lT2JqLCBwcmVwYXJlZE1lYXN1cmUsIHZhckhlaWdodCkge1xcbiAgbGluZU9iaiA9IGxpbmVPYmogfHwgZ2V0TGluZShjbS5kb2MsIHBvcy5saW5lKVxcbiAgaWYgKCFwcmVwYXJlZE1lYXN1cmUpIHsgcHJlcGFyZWRNZWFzdXJlID0gcHJlcGFyZU1lYXN1cmVGb3JMaW5lKGNtLCBsaW5lT2JqKSB9XFxuICBmdW5jdGlvbiBnZXQoY2gsIHJpZ2h0KSB7XFxuICAgIHZhciBtID0gbWVhc3VyZUNoYXJQcmVwYXJlZChjbSwgcHJlcGFyZWRNZWFzdXJlLCBjaCwgcmlnaHQgPyBcXFwicmlnaHRcXFwiIDogXFxcImxlZnRcXFwiLCB2YXJIZWlnaHQpXFxuICAgIGlmIChyaWdodCkgeyBtLmxlZnQgPSBtLnJpZ2h0OyB9IGVsc2UgeyBtLnJpZ2h0ID0gbS5sZWZ0IH1cXG4gICAgcmV0dXJuIGludG9Db29yZFN5c3RlbShjbSwgbGluZU9iaiwgbSwgY29udGV4dClcXG4gIH1cXG4gIGZ1bmN0aW9uIGdldEJpZGkoY2gsIHBhcnRQb3MpIHtcXG4gICAgdmFyIHBhcnQgPSBvcmRlcltwYXJ0UG9zXSwgcmlnaHQgPSBwYXJ0LmxldmVsICUgMlxcbiAgICBpZiAoY2ggPT0gYmlkaUxlZnQocGFydCkgJiYgcGFydFBvcyAmJiBwYXJ0LmxldmVsIDwgb3JkZXJbcGFydFBvcyAtIDFdLmxldmVsKSB7XFxuICAgICAgcGFydCA9IG9yZGVyWy0tcGFydFBvc11cXG4gICAgICBjaCA9IGJpZGlSaWdodChwYXJ0KSAtIChwYXJ0LmxldmVsICUgMiA/IDAgOiAxKVxcbiAgICAgIHJpZ2h0ID0gdHJ1ZVxcbiAgICB9IGVsc2UgaWYgKGNoID09IGJpZGlSaWdodChwYXJ0KSAmJiBwYXJ0UG9zIDwgb3JkZXIubGVuZ3RoIC0gMSAmJiBwYXJ0LmxldmVsIDwgb3JkZXJbcGFydFBvcyArIDFdLmxldmVsKSB7XFxuICAgICAgcGFydCA9IG9yZGVyWysrcGFydFBvc11cXG4gICAgICBjaCA9IGJpZGlMZWZ0KHBhcnQpIC0gcGFydC5sZXZlbCAlIDJcXG4gICAgICByaWdodCA9IGZhbHNlXFxuICAgIH1cXG4gICAgaWYgKHJpZ2h0ICYmIGNoID09IHBhcnQudG8gJiYgY2ggPiBwYXJ0LmZyb20pIHsgcmV0dXJuIGdldChjaCAtIDEpIH1cXG4gICAgcmV0dXJuIGdldChjaCwgcmlnaHQpXFxuICB9XFxuICB2YXIgb3JkZXIgPSBnZXRPcmRlcihsaW5lT2JqKSwgY2ggPSBwb3MuY2hcXG4gIGlmICghb3JkZXIpIHsgcmV0dXJuIGdldChjaCkgfVxcbiAgdmFyIHBhcnRQb3MgPSBnZXRCaWRpUGFydEF0KG9yZGVyLCBjaClcXG4gIHZhciB2YWwgPSBnZXRCaWRpKGNoLCBwYXJ0UG9zKVxcbiAgaWYgKGJpZGlPdGhlciAhPSBudWxsKSB7IHZhbC5vdGhlciA9IGdldEJpZGkoY2gsIGJpZGlPdGhlcikgfVxcbiAgcmV0dXJuIHZhbFxcbn1cXG5cXG4vLyBVc2VkIHRvIGNoZWFwbHkgZXN0aW1hdGUgdGhlIGNvb3JkaW5hdGVzIGZvciBhIHBvc2l0aW9uLiBVc2VkIGZvclxcbi8vIGludGVybWVkaWF0ZSBzY3JvbGwgdXBkYXRlcy5cXG5mdW5jdGlvbiBlc3RpbWF0ZUNvb3JkcyhjbSwgcG9zKSB7XFxuICB2YXIgbGVmdCA9IDBcXG4gIHBvcyA9IGNsaXBQb3MoY20uZG9jLCBwb3MpXFxuICBpZiAoIWNtLm9wdGlvbnMubGluZVdyYXBwaW5nKSB7IGxlZnQgPSBjaGFyV2lkdGgoY20uZGlzcGxheSkgKiBwb3MuY2ggfVxcbiAgdmFyIGxpbmVPYmogPSBnZXRMaW5lKGNtLmRvYywgcG9zLmxpbmUpXFxuICB2YXIgdG9wID0gaGVpZ2h0QXRMaW5lKGxpbmVPYmopICsgcGFkZGluZ1RvcChjbS5kaXNwbGF5KVxcbiAgcmV0dXJuIHtsZWZ0OiBsZWZ0LCByaWdodDogbGVmdCwgdG9wOiB0b3AsIGJvdHRvbTogdG9wICsgbGluZU9iai5oZWlnaHR9XFxufVxcblxcbi8vIFBvc2l0aW9ucyByZXR1cm5lZCBieSBjb29yZHNDaGFyIGNvbnRhaW4gc29tZSBleHRyYSBpbmZvcm1hdGlvbi5cXG4vLyB4UmVsIGlzIHRoZSByZWxhdGl2ZSB4IHBvc2l0aW9uIG9mIHRoZSBpbnB1dCBjb29yZGluYXRlcyBjb21wYXJlZFxcbi8vIHRvIHRoZSBmb3VuZCBwb3NpdGlvbiAoc28geFJlbCA+IDAgbWVhbnMgdGhlIGNvb3JkaW5hdGVzIGFyZSB0b1xcbi8vIHRoZSByaWdodCBvZiB0aGUgY2hhcmFjdGVyIHBvc2l0aW9uLCBmb3IgZXhhbXBsZSkuIFdoZW4gb3V0c2lkZVxcbi8vIGlzIHRydWUsIHRoYXQgbWVhbnMgdGhlIGNvb3JkaW5hdGVzIGxpZSBvdXRzaWRlIHRoZSBsaW5lJ3NcXG4vLyB2ZXJ0aWNhbCByYW5nZS5cXG5mdW5jdGlvbiBQb3NXaXRoSW5mbyhsaW5lLCBjaCwgb3V0c2lkZSwgeFJlbCkge1xcbiAgdmFyIHBvcyA9IFBvcyhsaW5lLCBjaClcXG4gIHBvcy54UmVsID0geFJlbFxcbiAgaWYgKG91dHNpZGUpIHsgcG9zLm91dHNpZGUgPSB0cnVlIH1cXG4gIHJldHVybiBwb3NcXG59XFxuXFxuLy8gQ29tcHV0ZSB0aGUgY2hhcmFjdGVyIHBvc2l0aW9uIGNsb3Nlc3QgdG8gdGhlIGdpdmVuIGNvb3JkaW5hdGVzLlxcbi8vIElucHV0IG11c3QgYmUgbGluZVNwYWNlLWxvY2FsIChcXFwiZGl2XFxcIiBjb29yZGluYXRlIHN5c3RlbSkuXFxuZnVuY3Rpb24gY29vcmRzQ2hhcihjbSwgeCwgeSkge1xcbiAgdmFyIGRvYyA9IGNtLmRvY1xcbiAgeSArPSBjbS5kaXNwbGF5LnZpZXdPZmZzZXRcXG4gIGlmICh5IDwgMCkgeyByZXR1cm4gUG9zV2l0aEluZm8oZG9jLmZpcnN0LCAwLCB0cnVlLCAtMSkgfVxcbiAgdmFyIGxpbmVOID0gbGluZUF0SGVpZ2h0KGRvYywgeSksIGxhc3QgPSBkb2MuZmlyc3QgKyBkb2Muc2l6ZSAtIDFcXG4gIGlmIChsaW5lTiA+IGxhc3QpXFxuICAgIHsgcmV0dXJuIFBvc1dpdGhJbmZvKGRvYy5maXJzdCArIGRvYy5zaXplIC0gMSwgZ2V0TGluZShkb2MsIGxhc3QpLnRleHQubGVuZ3RoLCB0cnVlLCAxKSB9XFxuICBpZiAoeCA8IDApIHsgeCA9IDAgfVxcblxcbiAgdmFyIGxpbmVPYmogPSBnZXRMaW5lKGRvYywgbGluZU4pXFxuICBmb3IgKDs7KSB7XFxuICAgIHZhciBmb3VuZCA9IGNvb3Jkc0NoYXJJbm5lcihjbSwgbGluZU9iaiwgbGluZU4sIHgsIHkpXFxuICAgIHZhciBtZXJnZWQgPSBjb2xsYXBzZWRTcGFuQXRFbmQobGluZU9iailcXG4gICAgdmFyIG1lcmdlZFBvcyA9IG1lcmdlZCAmJiBtZXJnZWQuZmluZCgwLCB0cnVlKVxcbiAgICBpZiAobWVyZ2VkICYmIChmb3VuZC5jaCA+IG1lcmdlZFBvcy5mcm9tLmNoIHx8IGZvdW5kLmNoID09IG1lcmdlZFBvcy5mcm9tLmNoICYmIGZvdW5kLnhSZWwgPiAwKSlcXG4gICAgICB7IGxpbmVOID0gbGluZU5vKGxpbmVPYmogPSBtZXJnZWRQb3MudG8ubGluZSkgfVxcbiAgICBlbHNlXFxuICAgICAgeyByZXR1cm4gZm91bmQgfVxcbiAgfVxcbn1cXG5cXG5mdW5jdGlvbiBjb29yZHNDaGFySW5uZXIoY20sIGxpbmVPYmosIGxpbmVObywgeCwgeSkge1xcbiAgdmFyIGlubmVyT2ZmID0geSAtIGhlaWdodEF0TGluZShsaW5lT2JqKVxcbiAgdmFyIHdyb25nTGluZSA9IGZhbHNlLCBhZGp1c3QgPSAyICogY20uZGlzcGxheS53cmFwcGVyLmNsaWVudFdpZHRoXFxuICB2YXIgcHJlcGFyZWRNZWFzdXJlID0gcHJlcGFyZU1lYXN1cmVGb3JMaW5lKGNtLCBsaW5lT2JqKVxcblxcbiAgZnVuY3Rpb24gZ2V0WChjaCkge1xcbiAgICB2YXIgc3AgPSBjdXJzb3JDb29yZHMoY20sIFBvcyhsaW5lTm8sIGNoKSwgXFxcImxpbmVcXFwiLCBsaW5lT2JqLCBwcmVwYXJlZE1lYXN1cmUpXFxuICAgIHdyb25nTGluZSA9IHRydWVcXG4gICAgaWYgKGlubmVyT2ZmID4gc3AuYm90dG9tKSB7IHJldHVybiBzcC5sZWZ0IC0gYWRqdXN0IH1cXG4gICAgZWxzZSBpZiAoaW5uZXJPZmYgPCBzcC50b3ApIHsgcmV0dXJuIHNwLmxlZnQgKyBhZGp1c3QgfVxcbiAgICBlbHNlIHsgd3JvbmdMaW5lID0gZmFsc2UgfVxcbiAgICByZXR1cm4gc3AubGVmdFxcbiAgfVxcblxcbiAgdmFyIGJpZGkgPSBnZXRPcmRlcihsaW5lT2JqKSwgZGlzdCA9IGxpbmVPYmoudGV4dC5sZW5ndGhcXG4gIHZhciBmcm9tID0gbGluZUxlZnQobGluZU9iaiksIHRvID0gbGluZVJpZ2h0KGxpbmVPYmopXFxuICB2YXIgZnJvbVggPSBnZXRYKGZyb20pLCBmcm9tT3V0c2lkZSA9IHdyb25nTGluZSwgdG9YID0gZ2V0WCh0byksIHRvT3V0c2lkZSA9IHdyb25nTGluZVxcblxcbiAgaWYgKHggPiB0b1gpIHsgcmV0dXJuIFBvc1dpdGhJbmZvKGxpbmVObywgdG8sIHRvT3V0c2lkZSwgMSkgfVxcbiAgLy8gRG8gYSBiaW5hcnkgc2VhcmNoIGJldHdlZW4gdGhlc2UgYm91bmRzLlxcbiAgZm9yICg7Oykge1xcbiAgICBpZiAoYmlkaSA/IHRvID09IGZyb20gfHwgdG8gPT0gbW92ZVZpc3VhbGx5KGxpbmVPYmosIGZyb20sIDEpIDogdG8gLSBmcm9tIDw9IDEpIHtcXG4gICAgICB2YXIgY2ggPSB4IDwgZnJvbVggfHwgeCAtIGZyb21YIDw9IHRvWCAtIHggPyBmcm9tIDogdG9cXG4gICAgICB2YXIgb3V0c2lkZSA9IGNoID09IGZyb20gPyBmcm9tT3V0c2lkZSA6IHRvT3V0c2lkZVxcbiAgICAgIHZhciB4RGlmZiA9IHggLSAoY2ggPT0gZnJvbSA/IGZyb21YIDogdG9YKVxcbiAgICAgIC8vIFRoaXMgaXMgYSBrbHVkZ2UgdG8gaGFuZGxlIHRoZSBjYXNlIHdoZXJlIHRoZSBjb29yZGluYXRlc1xcbiAgICAgIC8vIGFyZSBhZnRlciBhIGxpbmUtd3JhcHBlZCBsaW5lLiBXZSBzaG91bGQgcmVwbGFjZSBpdCB3aXRoIGFcXG4gICAgICAvLyBtb3JlIGdlbmVyYWwgaGFuZGxpbmcgb2YgY3Vyc29yIHBvc2l0aW9ucyBhcm91bmQgbGluZVxcbiAgICAgIC8vIGJyZWFrcy4gKElzc3VlICM0MDc4KVxcbiAgICAgIGlmICh0b091dHNpZGUgJiYgIWJpZGkgJiYgIS9cXFxccy8udGVzdChsaW5lT2JqLnRleHQuY2hhckF0KGNoKSkgJiYgeERpZmYgPiAwICYmXFxuICAgICAgICAgIGNoIDwgbGluZU9iai50ZXh0Lmxlbmd0aCAmJiBwcmVwYXJlZE1lYXN1cmUudmlldy5tZWFzdXJlLmhlaWdodHMubGVuZ3RoID4gMSkge1xcbiAgICAgICAgdmFyIGNoYXJTaXplID0gbWVhc3VyZUNoYXJQcmVwYXJlZChjbSwgcHJlcGFyZWRNZWFzdXJlLCBjaCwgXFxcInJpZ2h0XFxcIilcXG4gICAgICAgIGlmIChpbm5lck9mZiA8PSBjaGFyU2l6ZS5ib3R0b20gJiYgaW5uZXJPZmYgPj0gY2hhclNpemUudG9wICYmIE1hdGguYWJzKHggLSBjaGFyU2l6ZS5yaWdodCkgPCB4RGlmZikge1xcbiAgICAgICAgICBvdXRzaWRlID0gZmFsc2VcXG4gICAgICAgICAgY2grK1xcbiAgICAgICAgICB4RGlmZiA9IHggLSBjaGFyU2l6ZS5yaWdodFxcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgICB3aGlsZSAoaXNFeHRlbmRpbmdDaGFyKGxpbmVPYmoudGV4dC5jaGFyQXQoY2gpKSkgeyArK2NoIH1cXG4gICAgICB2YXIgcG9zID0gUG9zV2l0aEluZm8obGluZU5vLCBjaCwgb3V0c2lkZSwgeERpZmYgPCAtMSA/IC0xIDogeERpZmYgPiAxID8gMSA6IDApXFxuICAgICAgcmV0dXJuIHBvc1xcbiAgICB9XFxuICAgIHZhciBzdGVwID0gTWF0aC5jZWlsKGRpc3QgLyAyKSwgbWlkZGxlID0gZnJvbSArIHN0ZXBcXG4gICAgaWYgKGJpZGkpIHtcXG4gICAgICBtaWRkbGUgPSBmcm9tXFxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdGVwOyArK2kpIHsgbWlkZGxlID0gbW92ZVZpc3VhbGx5KGxpbmVPYmosIG1pZGRsZSwgMSkgfVxcbiAgICB9XFxuICAgIHZhciBtaWRkbGVYID0gZ2V0WChtaWRkbGUpXFxuICAgIGlmIChtaWRkbGVYID4geCkge3RvID0gbWlkZGxlOyB0b1ggPSBtaWRkbGVYOyBpZiAodG9PdXRzaWRlID0gd3JvbmdMaW5lKSB7IHRvWCArPSAxMDAwOyB9IGRpc3QgPSBzdGVwfVxcbiAgICBlbHNlIHtmcm9tID0gbWlkZGxlOyBmcm9tWCA9IG1pZGRsZVg7IGZyb21PdXRzaWRlID0gd3JvbmdMaW5lOyBkaXN0IC09IHN0ZXB9XFxuICB9XFxufVxcblxcbnZhciBtZWFzdXJlVGV4dFxcbi8vIENvbXB1dGUgdGhlIGRlZmF1bHQgdGV4dCBoZWlnaHQuXFxuZnVuY3Rpb24gdGV4dEhlaWdodChkaXNwbGF5KSB7XFxuICBpZiAoZGlzcGxheS5jYWNoZWRUZXh0SGVpZ2h0ICE9IG51bGwpIHsgcmV0dXJuIGRpc3BsYXkuY2FjaGVkVGV4dEhlaWdodCB9XFxuICBpZiAobWVhc3VyZVRleHQgPT0gbnVsbCkge1xcbiAgICBtZWFzdXJlVGV4dCA9IGVsdChcXFwicHJlXFxcIilcXG4gICAgLy8gTWVhc3VyZSBhIGJ1bmNoIG9mIGxpbmVzLCBmb3IgYnJvd3NlcnMgdGhhdCBjb21wdXRlXFxuICAgIC8vIGZyYWN0aW9uYWwgaGVpZ2h0cy5cXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCA0OTsgKytpKSB7XFxuICAgICAgbWVhc3VyZVRleHQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXFxcInhcXFwiKSlcXG4gICAgICBtZWFzdXJlVGV4dC5hcHBlbmRDaGlsZChlbHQoXFxcImJyXFxcIikpXFxuICAgIH1cXG4gICAgbWVhc3VyZVRleHQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXFxcInhcXFwiKSlcXG4gIH1cXG4gIHJlbW92ZUNoaWxkcmVuQW5kQWRkKGRpc3BsYXkubWVhc3VyZSwgbWVhc3VyZVRleHQpXFxuICB2YXIgaGVpZ2h0ID0gbWVhc3VyZVRleHQub2Zmc2V0SGVpZ2h0IC8gNTBcXG4gIGlmIChoZWlnaHQgPiAzKSB7IGRpc3BsYXkuY2FjaGVkVGV4dEhlaWdodCA9IGhlaWdodCB9XFxuICByZW1vdmVDaGlsZHJlbihkaXNwbGF5Lm1lYXN1cmUpXFxuICByZXR1cm4gaGVpZ2h0IHx8IDFcXG59XFxuXFxuLy8gQ29tcHV0ZSB0aGUgZGVmYXVsdCBjaGFyYWN0ZXIgd2lkdGguXFxuZnVuY3Rpb24gY2hhcldpZHRoKGRpc3BsYXkpIHtcXG4gIGlmIChkaXNwbGF5LmNhY2hlZENoYXJXaWR0aCAhPSBudWxsKSB7IHJldHVybiBkaXNwbGF5LmNhY2hlZENoYXJXaWR0aCB9XFxuICB2YXIgYW5jaG9yID0gZWx0KFxcXCJzcGFuXFxcIiwgXFxcInh4eHh4eHh4eHhcXFwiKVxcbiAgdmFyIHByZSA9IGVsdChcXFwicHJlXFxcIiwgW2FuY2hvcl0pXFxuICByZW1vdmVDaGlsZHJlbkFuZEFkZChkaXNwbGF5Lm1lYXN1cmUsIHByZSlcXG4gIHZhciByZWN0ID0gYW5jaG9yLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLCB3aWR0aCA9IChyZWN0LnJpZ2h0IC0gcmVjdC5sZWZ0KSAvIDEwXFxuICBpZiAod2lkdGggPiAyKSB7IGRpc3BsYXkuY2FjaGVkQ2hhcldpZHRoID0gd2lkdGggfVxcbiAgcmV0dXJuIHdpZHRoIHx8IDEwXFxufVxcblxcbi8vIERvIGEgYnVsay1yZWFkIG9mIHRoZSBET00gcG9zaXRpb25zIGFuZCBzaXplcyBuZWVkZWQgdG8gZHJhdyB0aGVcXG4vLyB2aWV3LCBzbyB0aGF0IHdlIGRvbid0IGludGVybGVhdmUgcmVhZGluZyBhbmQgd3JpdGluZyB0byB0aGUgRE9NLlxcbmZ1bmN0aW9uIGdldERpbWVuc2lvbnMoY20pIHtcXG4gIHZhciBkID0gY20uZGlzcGxheSwgbGVmdCA9IHt9LCB3aWR0aCA9IHt9XFxuICB2YXIgZ3V0dGVyTGVmdCA9IGQuZ3V0dGVycy5jbGllbnRMZWZ0XFxuICBmb3IgKHZhciBuID0gZC5ndXR0ZXJzLmZpcnN0Q2hpbGQsIGkgPSAwOyBuOyBuID0gbi5uZXh0U2libGluZywgKytpKSB7XFxuICAgIGxlZnRbY20ub3B0aW9ucy5ndXR0ZXJzW2ldXSA9IG4ub2Zmc2V0TGVmdCArIG4uY2xpZW50TGVmdCArIGd1dHRlckxlZnRcXG4gICAgd2lkdGhbY20ub3B0aW9ucy5ndXR0ZXJzW2ldXSA9IG4uY2xpZW50V2lkdGhcXG4gIH1cXG4gIHJldHVybiB7Zml4ZWRQb3M6IGNvbXBlbnNhdGVGb3JIU2Nyb2xsKGQpLFxcbiAgICAgICAgICBndXR0ZXJUb3RhbFdpZHRoOiBkLmd1dHRlcnMub2Zmc2V0V2lkdGgsXFxuICAgICAgICAgIGd1dHRlckxlZnQ6IGxlZnQsXFxuICAgICAgICAgIGd1dHRlcldpZHRoOiB3aWR0aCxcXG4gICAgICAgICAgd3JhcHBlcldpZHRoOiBkLndyYXBwZXIuY2xpZW50V2lkdGh9XFxufVxcblxcbi8vIENvbXB1dGVzIGRpc3BsYXkuc2Nyb2xsZXIuc2Nyb2xsTGVmdCArIGRpc3BsYXkuZ3V0dGVycy5vZmZzZXRXaWR0aCxcXG4vLyBidXQgdXNpbmcgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IHRvIGdldCBhIHN1Yi1waXhlbC1hY2N1cmF0ZVxcbi8vIHJlc3VsdC5cXG5mdW5jdGlvbiBjb21wZW5zYXRlRm9ySFNjcm9sbChkaXNwbGF5KSB7XFxuICByZXR1cm4gZGlzcGxheS5zY3JvbGxlci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0IC0gZGlzcGxheS5zaXplci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0XFxufVxcblxcbi8vIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IGVzdGltYXRlcyB0aGUgaGVpZ2h0IG9mIGEgbGluZSwgdG8gdXNlIGFzXFxuLy8gZmlyc3QgYXBwcm94aW1hdGlvbiB1bnRpbCB0aGUgbGluZSBiZWNvbWVzIHZpc2libGUgKGFuZCBpcyB0aHVzXFxuLy8gcHJvcGVybHkgbWVhc3VyYWJsZSkuXFxuZnVuY3Rpb24gZXN0aW1hdGVIZWlnaHQoY20pIHtcXG4gIHZhciB0aCA9IHRleHRIZWlnaHQoY20uZGlzcGxheSksIHdyYXBwaW5nID0gY20ub3B0aW9ucy5saW5lV3JhcHBpbmdcXG4gIHZhciBwZXJMaW5lID0gd3JhcHBpbmcgJiYgTWF0aC5tYXgoNSwgY20uZGlzcGxheS5zY3JvbGxlci5jbGllbnRXaWR0aCAvIGNoYXJXaWR0aChjbS5kaXNwbGF5KSAtIDMpXFxuICByZXR1cm4gZnVuY3Rpb24gKGxpbmUpIHtcXG4gICAgaWYgKGxpbmVJc0hpZGRlbihjbS5kb2MsIGxpbmUpKSB7IHJldHVybiAwIH1cXG5cXG4gICAgdmFyIHdpZGdldHNIZWlnaHQgPSAwXFxuICAgIGlmIChsaW5lLndpZGdldHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lLndpZGdldHMubGVuZ3RoOyBpKyspIHtcXG4gICAgICBpZiAobGluZS53aWRnZXRzW2ldLmhlaWdodCkgeyB3aWRnZXRzSGVpZ2h0ICs9IGxpbmUud2lkZ2V0c1tpXS5oZWlnaHQgfVxcbiAgICB9IH1cXG5cXG4gICAgaWYgKHdyYXBwaW5nKVxcbiAgICAgIHsgcmV0dXJuIHdpZGdldHNIZWlnaHQgKyAoTWF0aC5jZWlsKGxpbmUudGV4dC5sZW5ndGggLyBwZXJMaW5lKSB8fCAxKSAqIHRoIH1cXG4gICAgZWxzZVxcbiAgICAgIHsgcmV0dXJuIHdpZGdldHNIZWlnaHQgKyB0aCB9XFxuICB9XFxufVxcblxcbmZ1bmN0aW9uIGVzdGltYXRlTGluZUhlaWdodHMoY20pIHtcXG4gIHZhciBkb2MgPSBjbS5kb2MsIGVzdCA9IGVzdGltYXRlSGVpZ2h0KGNtKVxcbiAgZG9jLml0ZXIoZnVuY3Rpb24gKGxpbmUpIHtcXG4gICAgdmFyIGVzdEhlaWdodCA9IGVzdChsaW5lKVxcbiAgICBpZiAoZXN0SGVpZ2h0ICE9IGxpbmUuaGVpZ2h0KSB7IHVwZGF0ZUxpbmVIZWlnaHQobGluZSwgZXN0SGVpZ2h0KSB9XFxuICB9KVxcbn1cXG5cXG4vLyBHaXZlbiBhIG1vdXNlIGV2ZW50LCBmaW5kIHRoZSBjb3JyZXNwb25kaW5nIHBvc2l0aW9uLiBJZiBsaWJlcmFsXFxuLy8gaXMgZmFsc2UsIGl0IGNoZWNrcyB3aGV0aGVyIGEgZ3V0dGVyIG9yIHNjcm9sbGJhciB3YXMgY2xpY2tlZCxcXG4vLyBhbmQgcmV0dXJucyBudWxsIGlmIGl0IHdhcy4gZm9yUmVjdCBpcyB1c2VkIGJ5IHJlY3Rhbmd1bGFyXFxuLy8gc2VsZWN0aW9ucywgYW5kIHRyaWVzIHRvIGVzdGltYXRlIGEgY2hhcmFjdGVyIHBvc2l0aW9uIGV2ZW4gZm9yXFxuLy8gY29vcmRpbmF0ZXMgYmV5b25kIHRoZSByaWdodCBvZiB0aGUgdGV4dC5cXG5mdW5jdGlvbiBwb3NGcm9tTW91c2UoY20sIGUsIGxpYmVyYWwsIGZvclJlY3QpIHtcXG4gIHZhciBkaXNwbGF5ID0gY20uZGlzcGxheVxcbiAgaWYgKCFsaWJlcmFsICYmIGVfdGFyZ2V0KGUpLmdldEF0dHJpYnV0ZShcXFwiY20tbm90LWNvbnRlbnRcXFwiKSA9PSBcXFwidHJ1ZVxcXCIpIHsgcmV0dXJuIG51bGwgfVxcblxcbiAgdmFyIHgsIHksIHNwYWNlID0gZGlzcGxheS5saW5lU3BhY2UuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClcXG4gIC8vIEZhaWxzIHVucHJlZGljdGFibHkgb24gSUVbNjddIHdoZW4gbW91c2UgaXMgZHJhZ2dlZCBhcm91bmQgcXVpY2tseS5cXG4gIHRyeSB7IHggPSBlLmNsaWVudFggLSBzcGFjZS5sZWZ0OyB5ID0gZS5jbGllbnRZIC0gc3BhY2UudG9wIH1cXG4gIGNhdGNoIChlKSB7IHJldHVybiBudWxsIH1cXG4gIHZhciBjb29yZHMgPSBjb29yZHNDaGFyKGNtLCB4LCB5KSwgbGluZVxcbiAgaWYgKGZvclJlY3QgJiYgY29vcmRzLnhSZWwgPT0gMSAmJiAobGluZSA9IGdldExpbmUoY20uZG9jLCBjb29yZHMubGluZSkudGV4dCkubGVuZ3RoID09IGNvb3Jkcy5jaCkge1xcbiAgICB2YXIgY29sRGlmZiA9IGNvdW50Q29sdW1uKGxpbmUsIGxpbmUubGVuZ3RoLCBjbS5vcHRpb25zLnRhYlNpemUpIC0gbGluZS5sZW5ndGhcXG4gICAgY29vcmRzID0gUG9zKGNvb3Jkcy5saW5lLCBNYXRoLm1heCgwLCBNYXRoLnJvdW5kKCh4IC0gcGFkZGluZ0goY20uZGlzcGxheSkubGVmdCkgLyBjaGFyV2lkdGgoY20uZGlzcGxheSkpIC0gY29sRGlmZikpXFxuICB9XFxuICByZXR1cm4gY29vcmRzXFxufVxcblxcbi8vIEZpbmQgdGhlIHZpZXcgZWxlbWVudCBjb3JyZXNwb25kaW5nIHRvIGEgZ2l2ZW4gbGluZS4gUmV0dXJuIG51bGxcXG4vLyB3aGVuIHRoZSBsaW5lIGlzbid0IHZpc2libGUuXFxuZnVuY3Rpb24gZmluZFZpZXdJbmRleChjbSwgbikge1xcbiAgaWYgKG4gPj0gY20uZGlzcGxheS52aWV3VG8pIHsgcmV0dXJuIG51bGwgfVxcbiAgbiAtPSBjbS5kaXNwbGF5LnZpZXdGcm9tXFxuICBpZiAobiA8IDApIHsgcmV0dXJuIG51bGwgfVxcbiAgdmFyIHZpZXcgPSBjbS5kaXNwbGF5LnZpZXdcXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdmlldy5sZW5ndGg7IGkrKykge1xcbiAgICBuIC09IHZpZXdbaV0uc2l6ZVxcbiAgICBpZiAobiA8IDApIHsgcmV0dXJuIGkgfVxcbiAgfVxcbn1cXG5cXG5mdW5jdGlvbiB1cGRhdGVTZWxlY3Rpb24oY20pIHtcXG4gIGNtLmRpc3BsYXkuaW5wdXQuc2hvd1NlbGVjdGlvbihjbS5kaXNwbGF5LmlucHV0LnByZXBhcmVTZWxlY3Rpb24oKSlcXG59XFxuXFxuZnVuY3Rpb24gcHJlcGFyZVNlbGVjdGlvbihjbSwgcHJpbWFyeSkge1xcbiAgdmFyIGRvYyA9IGNtLmRvYywgcmVzdWx0ID0ge31cXG4gIHZhciBjdXJGcmFnbWVudCA9IHJlc3VsdC5jdXJzb3JzID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpXFxuICB2YXIgc2VsRnJhZ21lbnQgPSByZXN1bHQuc2VsZWN0aW9uID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpXFxuXFxuICBmb3IgKHZhciBpID0gMDsgaSA8IGRvYy5zZWwucmFuZ2VzLmxlbmd0aDsgaSsrKSB7XFxuICAgIGlmIChwcmltYXJ5ID09PSBmYWxzZSAmJiBpID09IGRvYy5zZWwucHJpbUluZGV4KSB7IGNvbnRpbnVlIH1cXG4gICAgdmFyIHJhbmdlID0gZG9jLnNlbC5yYW5nZXNbaV1cXG4gICAgaWYgKHJhbmdlLmZyb20oKS5saW5lID49IGNtLmRpc3BsYXkudmlld1RvIHx8IHJhbmdlLnRvKCkubGluZSA8IGNtLmRpc3BsYXkudmlld0Zyb20pIHsgY29udGludWUgfVxcbiAgICB2YXIgY29sbGFwc2VkID0gcmFuZ2UuZW1wdHkoKVxcbiAgICBpZiAoY29sbGFwc2VkIHx8IGNtLm9wdGlvbnMuc2hvd0N1cnNvcldoZW5TZWxlY3RpbmcpXFxuICAgICAgeyBkcmF3U2VsZWN0aW9uQ3Vyc29yKGNtLCByYW5nZS5oZWFkLCBjdXJGcmFnbWVudCkgfVxcbiAgICBpZiAoIWNvbGxhcHNlZClcXG4gICAgICB7IGRyYXdTZWxlY3Rpb25SYW5nZShjbSwgcmFuZ2UsIHNlbEZyYWdtZW50KSB9XFxuICB9XFxuICByZXR1cm4gcmVzdWx0XFxufVxcblxcbi8vIERyYXdzIGEgY3Vyc29yIGZvciB0aGUgZ2l2ZW4gcmFuZ2VcXG5mdW5jdGlvbiBkcmF3U2VsZWN0aW9uQ3Vyc29yKGNtLCBoZWFkLCBvdXRwdXQpIHtcXG4gIHZhciBwb3MgPSBjdXJzb3JDb29yZHMoY20sIGhlYWQsIFxcXCJkaXZcXFwiLCBudWxsLCBudWxsLCAhY20ub3B0aW9ucy5zaW5nbGVDdXJzb3JIZWlnaHRQZXJMaW5lKVxcblxcbiAgdmFyIGN1cnNvciA9IG91dHB1dC5hcHBlbmRDaGlsZChlbHQoXFxcImRpdlxcXCIsIFxcXCJcXFxcdTAwYTBcXFwiLCBcXFwiQ29kZU1pcnJvci1jdXJzb3JcXFwiKSlcXG4gIGN1cnNvci5zdHlsZS5sZWZ0ID0gcG9zLmxlZnQgKyBcXFwicHhcXFwiXFxuICBjdXJzb3Iuc3R5bGUudG9wID0gcG9zLnRvcCArIFxcXCJweFxcXCJcXG4gIGN1cnNvci5zdHlsZS5oZWlnaHQgPSBNYXRoLm1heCgwLCBwb3MuYm90dG9tIC0gcG9zLnRvcCkgKiBjbS5vcHRpb25zLmN1cnNvckhlaWdodCArIFxcXCJweFxcXCJcXG5cXG4gIGlmIChwb3Mub3RoZXIpIHtcXG4gICAgLy8gU2Vjb25kYXJ5IGN1cnNvciwgc2hvd24gd2hlbiBvbiBhICdqdW1wJyBpbiBiaS1kaXJlY3Rpb25hbCB0ZXh0XFxuICAgIHZhciBvdGhlckN1cnNvciA9IG91dHB1dC5hcHBlbmRDaGlsZChlbHQoXFxcImRpdlxcXCIsIFxcXCJcXFxcdTAwYTBcXFwiLCBcXFwiQ29kZU1pcnJvci1jdXJzb3IgQ29kZU1pcnJvci1zZWNvbmRhcnljdXJzb3JcXFwiKSlcXG4gICAgb3RoZXJDdXJzb3Iuc3R5bGUuZGlzcGxheSA9IFxcXCJcXFwiXFxuICAgIG90aGVyQ3Vyc29yLnN0eWxlLmxlZnQgPSBwb3Mub3RoZXIubGVmdCArIFxcXCJweFxcXCJcXG4gICAgb3RoZXJDdXJzb3Iuc3R5bGUudG9wID0gcG9zLm90aGVyLnRvcCArIFxcXCJweFxcXCJcXG4gICAgb3RoZXJDdXJzb3Iuc3R5bGUuaGVpZ2h0ID0gKHBvcy5vdGhlci5ib3R0b20gLSBwb3Mub3RoZXIudG9wKSAqIC44NSArIFxcXCJweFxcXCJcXG4gIH1cXG59XFxuXFxuLy8gRHJhd3MgdGhlIGdpdmVuIHJhbmdlIGFzIGEgaGlnaGxpZ2h0ZWQgc2VsZWN0aW9uXFxuZnVuY3Rpb24gZHJhd1NlbGVjdGlvblJhbmdlKGNtLCByYW5nZSwgb3V0cHV0KSB7XFxuICB2YXIgZGlzcGxheSA9IGNtLmRpc3BsYXksIGRvYyA9IGNtLmRvY1xcbiAgdmFyIGZyYWdtZW50ID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpXFxuICB2YXIgcGFkZGluZyA9IHBhZGRpbmdIKGNtLmRpc3BsYXkpLCBsZWZ0U2lkZSA9IHBhZGRpbmcubGVmdFxcbiAgdmFyIHJpZ2h0U2lkZSA9IE1hdGgubWF4KGRpc3BsYXkuc2l6ZXJXaWR0aCwgZGlzcGxheVdpZHRoKGNtKSAtIGRpc3BsYXkuc2l6ZXIub2Zmc2V0TGVmdCkgLSBwYWRkaW5nLnJpZ2h0XFxuXFxuICBmdW5jdGlvbiBhZGQobGVmdCwgdG9wLCB3aWR0aCwgYm90dG9tKSB7XFxuICAgIGlmICh0b3AgPCAwKSB7IHRvcCA9IDAgfVxcbiAgICB0b3AgPSBNYXRoLnJvdW5kKHRvcClcXG4gICAgYm90dG9tID0gTWF0aC5yb3VuZChib3R0b20pXFxuICAgIGZyYWdtZW50LmFwcGVuZENoaWxkKGVsdChcXFwiZGl2XFxcIiwgbnVsbCwgXFxcIkNvZGVNaXJyb3Itc2VsZWN0ZWRcXFwiLCAoXFxcInBvc2l0aW9uOiBhYnNvbHV0ZTsgbGVmdDogXFxcIiArIGxlZnQgKyBcXFwicHg7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvcDogXFxcIiArIHRvcCArIFxcXCJweDsgd2lkdGg6IFxcXCIgKyAod2lkdGggPT0gbnVsbCA/IHJpZ2h0U2lkZSAtIGxlZnQgOiB3aWR0aCkgKyBcXFwicHg7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogXFxcIiArIChib3R0b20gLSB0b3ApICsgXFxcInB4XFxcIikpKVxcbiAgfVxcblxcbiAgZnVuY3Rpb24gZHJhd0ZvckxpbmUobGluZSwgZnJvbUFyZywgdG9BcmcpIHtcXG4gICAgdmFyIGxpbmVPYmogPSBnZXRMaW5lKGRvYywgbGluZSlcXG4gICAgdmFyIGxpbmVMZW4gPSBsaW5lT2JqLnRleHQubGVuZ3RoXFxuICAgIHZhciBzdGFydCwgZW5kXFxuICAgIGZ1bmN0aW9uIGNvb3JkcyhjaCwgYmlhcykge1xcbiAgICAgIHJldHVybiBjaGFyQ29vcmRzKGNtLCBQb3MobGluZSwgY2gpLCBcXFwiZGl2XFxcIiwgbGluZU9iaiwgYmlhcylcXG4gICAgfVxcblxcbiAgICBpdGVyYXRlQmlkaVNlY3Rpb25zKGdldE9yZGVyKGxpbmVPYmopLCBmcm9tQXJnIHx8IDAsIHRvQXJnID09IG51bGwgPyBsaW5lTGVuIDogdG9BcmcsIGZ1bmN0aW9uIChmcm9tLCB0bywgZGlyKSB7XFxuICAgICAgdmFyIGxlZnRQb3MgPSBjb29yZHMoZnJvbSwgXFxcImxlZnRcXFwiKSwgcmlnaHRQb3MsIGxlZnQsIHJpZ2h0XFxuICAgICAgaWYgKGZyb20gPT0gdG8pIHtcXG4gICAgICAgIHJpZ2h0UG9zID0gbGVmdFBvc1xcbiAgICAgICAgbGVmdCA9IHJpZ2h0ID0gbGVmdFBvcy5sZWZ0XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIHJpZ2h0UG9zID0gY29vcmRzKHRvIC0gMSwgXFxcInJpZ2h0XFxcIilcXG4gICAgICAgIGlmIChkaXIgPT0gXFxcInJ0bFxcXCIpIHsgdmFyIHRtcCA9IGxlZnRQb3M7IGxlZnRQb3MgPSByaWdodFBvczsgcmlnaHRQb3MgPSB0bXAgfVxcbiAgICAgICAgbGVmdCA9IGxlZnRQb3MubGVmdFxcbiAgICAgICAgcmlnaHQgPSByaWdodFBvcy5yaWdodFxcbiAgICAgIH1cXG4gICAgICBpZiAoZnJvbUFyZyA9PSBudWxsICYmIGZyb20gPT0gMCkgeyBsZWZ0ID0gbGVmdFNpZGUgfVxcbiAgICAgIGlmIChyaWdodFBvcy50b3AgLSBsZWZ0UG9zLnRvcCA+IDMpIHsgLy8gRGlmZmVyZW50IGxpbmVzLCBkcmF3IHRvcCBwYXJ0XFxuICAgICAgICBhZGQobGVmdCwgbGVmdFBvcy50b3AsIG51bGwsIGxlZnRQb3MuYm90dG9tKVxcbiAgICAgICAgbGVmdCA9IGxlZnRTaWRlXFxuICAgICAgICBpZiAobGVmdFBvcy5ib3R0b20gPCByaWdodFBvcy50b3ApIHsgYWRkKGxlZnQsIGxlZnRQb3MuYm90dG9tLCBudWxsLCByaWdodFBvcy50b3ApIH1cXG4gICAgICB9XFxuICAgICAgaWYgKHRvQXJnID09IG51bGwgJiYgdG8gPT0gbGluZUxlbikgeyByaWdodCA9IHJpZ2h0U2lkZSB9XFxuICAgICAgaWYgKCFzdGFydCB8fCBsZWZ0UG9zLnRvcCA8IHN0YXJ0LnRvcCB8fCBsZWZ0UG9zLnRvcCA9PSBzdGFydC50b3AgJiYgbGVmdFBvcy5sZWZ0IDwgc3RhcnQubGVmdClcXG4gICAgICAgIHsgc3RhcnQgPSBsZWZ0UG9zIH1cXG4gICAgICBpZiAoIWVuZCB8fCByaWdodFBvcy5ib3R0b20gPiBlbmQuYm90dG9tIHx8IHJpZ2h0UG9zLmJvdHRvbSA9PSBlbmQuYm90dG9tICYmIHJpZ2h0UG9zLnJpZ2h0ID4gZW5kLnJpZ2h0KVxcbiAgICAgICAgeyBlbmQgPSByaWdodFBvcyB9XFxuICAgICAgaWYgKGxlZnQgPCBsZWZ0U2lkZSArIDEpIHsgbGVmdCA9IGxlZnRTaWRlIH1cXG4gICAgICBhZGQobGVmdCwgcmlnaHRQb3MudG9wLCByaWdodCAtIGxlZnQsIHJpZ2h0UG9zLmJvdHRvbSlcXG4gICAgfSlcXG4gICAgcmV0dXJuIHtzdGFydDogc3RhcnQsIGVuZDogZW5kfVxcbiAgfVxcblxcbiAgdmFyIHNGcm9tID0gcmFuZ2UuZnJvbSgpLCBzVG8gPSByYW5nZS50bygpXFxuICBpZiAoc0Zyb20ubGluZSA9PSBzVG8ubGluZSkge1xcbiAgICBkcmF3Rm9yTGluZShzRnJvbS5saW5lLCBzRnJvbS5jaCwgc1RvLmNoKVxcbiAgfSBlbHNlIHtcXG4gICAgdmFyIGZyb21MaW5lID0gZ2V0TGluZShkb2MsIHNGcm9tLmxpbmUpLCB0b0xpbmUgPSBnZXRMaW5lKGRvYywgc1RvLmxpbmUpXFxuICAgIHZhciBzaW5nbGVWTGluZSA9IHZpc3VhbExpbmUoZnJvbUxpbmUpID09IHZpc3VhbExpbmUodG9MaW5lKVxcbiAgICB2YXIgbGVmdEVuZCA9IGRyYXdGb3JMaW5lKHNGcm9tLmxpbmUsIHNGcm9tLmNoLCBzaW5nbGVWTGluZSA/IGZyb21MaW5lLnRleHQubGVuZ3RoICsgMSA6IG51bGwpLmVuZFxcbiAgICB2YXIgcmlnaHRTdGFydCA9IGRyYXdGb3JMaW5lKHNUby5saW5lLCBzaW5nbGVWTGluZSA/IDAgOiBudWxsLCBzVG8uY2gpLnN0YXJ0XFxuICAgIGlmIChzaW5nbGVWTGluZSkge1xcbiAgICAgIGlmIChsZWZ0RW5kLnRvcCA8IHJpZ2h0U3RhcnQudG9wIC0gMikge1xcbiAgICAgICAgYWRkKGxlZnRFbmQucmlnaHQsIGxlZnRFbmQudG9wLCBudWxsLCBsZWZ0RW5kLmJvdHRvbSlcXG4gICAgICAgIGFkZChsZWZ0U2lkZSwgcmlnaHRTdGFydC50b3AsIHJpZ2h0U3RhcnQubGVmdCwgcmlnaHRTdGFydC5ib3R0b20pXFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIGFkZChsZWZ0RW5kLnJpZ2h0LCBsZWZ0RW5kLnRvcCwgcmlnaHRTdGFydC5sZWZ0IC0gbGVmdEVuZC5yaWdodCwgbGVmdEVuZC5ib3R0b20pXFxuICAgICAgfVxcbiAgICB9XFxuICAgIGlmIChsZWZ0RW5kLmJvdHRvbSA8IHJpZ2h0U3RhcnQudG9wKVxcbiAgICAgIHsgYWRkKGxlZnRTaWRlLCBsZWZ0RW5kLmJvdHRvbSwgbnVsbCwgcmlnaHRTdGFydC50b3ApIH1cXG4gIH1cXG5cXG4gIG91dHB1dC5hcHBlbmRDaGlsZChmcmFnbWVudClcXG59XFxuXFxuLy8gQ3Vyc29yLWJsaW5raW5nXFxuZnVuY3Rpb24gcmVzdGFydEJsaW5rKGNtKSB7XFxuICBpZiAoIWNtLnN0YXRlLmZvY3VzZWQpIHsgcmV0dXJuIH1cXG4gIHZhciBkaXNwbGF5ID0gY20uZGlzcGxheVxcbiAgY2xlYXJJbnRlcnZhbChkaXNwbGF5LmJsaW5rZXIpXFxuICB2YXIgb24gPSB0cnVlXFxuICBkaXNwbGF5LmN1cnNvckRpdi5zdHlsZS52aXNpYmlsaXR5ID0gXFxcIlxcXCJcXG4gIGlmIChjbS5vcHRpb25zLmN1cnNvckJsaW5rUmF0ZSA+IDApXFxuICAgIHsgZGlzcGxheS5ibGlua2VyID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24gKCkgeyByZXR1cm4gZGlzcGxheS5jdXJzb3JEaXYuc3R5bGUudmlzaWJpbGl0eSA9IChvbiA9ICFvbikgPyBcXFwiXFxcIiA6IFxcXCJoaWRkZW5cXFwiOyB9LFxcbiAgICAgIGNtLm9wdGlvbnMuY3Vyc29yQmxpbmtSYXRlKSB9XFxuICBlbHNlIGlmIChjbS5vcHRpb25zLmN1cnNvckJsaW5rUmF0ZSA8IDApXFxuICAgIHsgZGlzcGxheS5jdXJzb3JEaXYuc3R5bGUudmlzaWJpbGl0eSA9IFxcXCJoaWRkZW5cXFwiIH1cXG59XFxuXFxuZnVuY3Rpb24gZW5zdXJlRm9jdXMoY20pIHtcXG4gIGlmICghY20uc3RhdGUuZm9jdXNlZCkgeyBjbS5kaXNwbGF5LmlucHV0LmZvY3VzKCk7IG9uRm9jdXMoY20pIH1cXG59XFxuXFxuZnVuY3Rpb24gZGVsYXlCbHVyRXZlbnQoY20pIHtcXG4gIGNtLnN0YXRlLmRlbGF5aW5nQmx1ckV2ZW50ID0gdHJ1ZVxcbiAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IGlmIChjbS5zdGF0ZS5kZWxheWluZ0JsdXJFdmVudCkge1xcbiAgICBjbS5zdGF0ZS5kZWxheWluZ0JsdXJFdmVudCA9IGZhbHNlXFxuICAgIG9uQmx1cihjbSlcXG4gIH0gfSwgMTAwKVxcbn1cXG5cXG5mdW5jdGlvbiBvbkZvY3VzKGNtLCBlKSB7XFxuICBpZiAoY20uc3RhdGUuZGVsYXlpbmdCbHVyRXZlbnQpIHsgY20uc3RhdGUuZGVsYXlpbmdCbHVyRXZlbnQgPSBmYWxzZSB9XFxuXFxuICBpZiAoY20ub3B0aW9ucy5yZWFkT25seSA9PSBcXFwibm9jdXJzb3JcXFwiKSB7IHJldHVybiB9XFxuICBpZiAoIWNtLnN0YXRlLmZvY3VzZWQpIHtcXG4gICAgc2lnbmFsKGNtLCBcXFwiZm9jdXNcXFwiLCBjbSwgZSlcXG4gICAgY20uc3RhdGUuZm9jdXNlZCA9IHRydWVcXG4gICAgYWRkQ2xhc3MoY20uZGlzcGxheS53cmFwcGVyLCBcXFwiQ29kZU1pcnJvci1mb2N1c2VkXFxcIilcXG4gICAgLy8gVGhpcyB0ZXN0IHByZXZlbnRzIHRoaXMgZnJvbSBmaXJpbmcgd2hlbiBhIGNvbnRleHRcXG4gICAgLy8gbWVudSBpcyBjbG9zZWQgKHNpbmNlIHRoZSBpbnB1dCByZXNldCB3b3VsZCBraWxsIHRoZVxcbiAgICAvLyBzZWxlY3QtYWxsIGRldGVjdGlvbiBoYWNrKVxcbiAgICBpZiAoIWNtLmN1ck9wICYmIGNtLmRpc3BsYXkuc2VsRm9yQ29udGV4dE1lbnUgIT0gY20uZG9jLnNlbCkge1xcbiAgICAgIGNtLmRpc3BsYXkuaW5wdXQucmVzZXQoKVxcbiAgICAgIGlmICh3ZWJraXQpIHsgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHJldHVybiBjbS5kaXNwbGF5LmlucHV0LnJlc2V0KHRydWUpOyB9LCAyMCkgfSAvLyBJc3N1ZSAjMTczMFxcbiAgICB9XFxuICAgIGNtLmRpc3BsYXkuaW5wdXQucmVjZWl2ZWRGb2N1cygpXFxuICB9XFxuICByZXN0YXJ0QmxpbmsoY20pXFxufVxcbmZ1bmN0aW9uIG9uQmx1cihjbSwgZSkge1xcbiAgaWYgKGNtLnN0YXRlLmRlbGF5aW5nQmx1ckV2ZW50KSB7IHJldHVybiB9XFxuXFxuICBpZiAoY20uc3RhdGUuZm9jdXNlZCkge1xcbiAgICBzaWduYWwoY20sIFxcXCJibHVyXFxcIiwgY20sIGUpXFxuICAgIGNtLnN0YXRlLmZvY3VzZWQgPSBmYWxzZVxcbiAgICBybUNsYXNzKGNtLmRpc3BsYXkud3JhcHBlciwgXFxcIkNvZGVNaXJyb3ItZm9jdXNlZFxcXCIpXFxuICB9XFxuICBjbGVhckludGVydmFsKGNtLmRpc3BsYXkuYmxpbmtlcilcXG4gIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyBpZiAoIWNtLnN0YXRlLmZvY3VzZWQpIHsgY20uZGlzcGxheS5zaGlmdCA9IGZhbHNlIH0gfSwgMTUwKVxcbn1cXG5cXG4vLyBSZS1hbGlnbiBsaW5lIG51bWJlcnMgYW5kIGd1dHRlciBtYXJrcyB0byBjb21wZW5zYXRlIGZvclxcbi8vIGhvcml6b250YWwgc2Nyb2xsaW5nLlxcbmZ1bmN0aW9uIGFsaWduSG9yaXpvbnRhbGx5KGNtKSB7XFxuICB2YXIgZGlzcGxheSA9IGNtLmRpc3BsYXksIHZpZXcgPSBkaXNwbGF5LnZpZXdcXG4gIGlmICghZGlzcGxheS5hbGlnbldpZGdldHMgJiYgKCFkaXNwbGF5Lmd1dHRlcnMuZmlyc3RDaGlsZCB8fCAhY20ub3B0aW9ucy5maXhlZEd1dHRlcikpIHsgcmV0dXJuIH1cXG4gIHZhciBjb21wID0gY29tcGVuc2F0ZUZvckhTY3JvbGwoZGlzcGxheSkgLSBkaXNwbGF5LnNjcm9sbGVyLnNjcm9sbExlZnQgKyBjbS5kb2Muc2Nyb2xsTGVmdFxcbiAgdmFyIGd1dHRlclcgPSBkaXNwbGF5Lmd1dHRlcnMub2Zmc2V0V2lkdGgsIGxlZnQgPSBjb21wICsgXFxcInB4XFxcIlxcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB2aWV3Lmxlbmd0aDsgaSsrKSB7IGlmICghdmlld1tpXS5oaWRkZW4pIHtcXG4gICAgaWYgKGNtLm9wdGlvbnMuZml4ZWRHdXR0ZXIpIHtcXG4gICAgICBpZiAodmlld1tpXS5ndXR0ZXIpXFxuICAgICAgICB7IHZpZXdbaV0uZ3V0dGVyLnN0eWxlLmxlZnQgPSBsZWZ0IH1cXG4gICAgICBpZiAodmlld1tpXS5ndXR0ZXJCYWNrZ3JvdW5kKVxcbiAgICAgICAgeyB2aWV3W2ldLmd1dHRlckJhY2tncm91bmQuc3R5bGUubGVmdCA9IGxlZnQgfVxcbiAgICB9XFxuICAgIHZhciBhbGlnbiA9IHZpZXdbaV0uYWxpZ25hYmxlXFxuICAgIGlmIChhbGlnbikgeyBmb3IgKHZhciBqID0gMDsgaiA8IGFsaWduLmxlbmd0aDsgaisrKVxcbiAgICAgIHsgYWxpZ25bal0uc3R5bGUubGVmdCA9IGxlZnQgfSB9XFxuICB9IH1cXG4gIGlmIChjbS5vcHRpb25zLmZpeGVkR3V0dGVyKVxcbiAgICB7IGRpc3BsYXkuZ3V0dGVycy5zdHlsZS5sZWZ0ID0gKGNvbXAgKyBndXR0ZXJXKSArIFxcXCJweFxcXCIgfVxcbn1cXG5cXG4vLyBVc2VkIHRvIGVuc3VyZSB0aGF0IHRoZSBsaW5lIG51bWJlciBndXR0ZXIgaXMgc3RpbGwgdGhlIHJpZ2h0XFxuLy8gc2l6ZSBmb3IgdGhlIGN1cnJlbnQgZG9jdW1lbnQgc2l6ZS4gUmV0dXJucyB0cnVlIHdoZW4gYW4gdXBkYXRlXFxuLy8gaXMgbmVlZGVkLlxcbmZ1bmN0aW9uIG1heWJlVXBkYXRlTGluZU51bWJlcldpZHRoKGNtKSB7XFxuICBpZiAoIWNtLm9wdGlvbnMubGluZU51bWJlcnMpIHsgcmV0dXJuIGZhbHNlIH1cXG4gIHZhciBkb2MgPSBjbS5kb2MsIGxhc3QgPSBsaW5lTnVtYmVyRm9yKGNtLm9wdGlvbnMsIGRvYy5maXJzdCArIGRvYy5zaXplIC0gMSksIGRpc3BsYXkgPSBjbS5kaXNwbGF5XFxuICBpZiAobGFzdC5sZW5ndGggIT0gZGlzcGxheS5saW5lTnVtQ2hhcnMpIHtcXG4gICAgdmFyIHRlc3QgPSBkaXNwbGF5Lm1lYXN1cmUuYXBwZW5kQ2hpbGQoZWx0KFxcXCJkaXZcXFwiLCBbZWx0KFxcXCJkaXZcXFwiLCBsYXN0KV0sXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXFwiQ29kZU1pcnJvci1saW5lbnVtYmVyIENvZGVNaXJyb3ItZ3V0dGVyLWVsdFxcXCIpKVxcbiAgICB2YXIgaW5uZXJXID0gdGVzdC5maXJzdENoaWxkLm9mZnNldFdpZHRoLCBwYWRkaW5nID0gdGVzdC5vZmZzZXRXaWR0aCAtIGlubmVyV1xcbiAgICBkaXNwbGF5LmxpbmVHdXR0ZXIuc3R5bGUud2lkdGggPSBcXFwiXFxcIlxcbiAgICBkaXNwbGF5LmxpbmVOdW1Jbm5lcldpZHRoID0gTWF0aC5tYXgoaW5uZXJXLCBkaXNwbGF5LmxpbmVHdXR0ZXIub2Zmc2V0V2lkdGggLSBwYWRkaW5nKSArIDFcXG4gICAgZGlzcGxheS5saW5lTnVtV2lkdGggPSBkaXNwbGF5LmxpbmVOdW1Jbm5lcldpZHRoICsgcGFkZGluZ1xcbiAgICBkaXNwbGF5LmxpbmVOdW1DaGFycyA9IGRpc3BsYXkubGluZU51bUlubmVyV2lkdGggPyBsYXN0Lmxlbmd0aCA6IC0xXFxuICAgIGRpc3BsYXkubGluZUd1dHRlci5zdHlsZS53aWR0aCA9IGRpc3BsYXkubGluZU51bVdpZHRoICsgXFxcInB4XFxcIlxcbiAgICB1cGRhdGVHdXR0ZXJTcGFjZShjbSlcXG4gICAgcmV0dXJuIHRydWVcXG4gIH1cXG4gIHJldHVybiBmYWxzZVxcbn1cXG5cXG4vLyBSZWFkIHRoZSBhY3R1YWwgaGVpZ2h0cyBvZiB0aGUgcmVuZGVyZWQgbGluZXMsIGFuZCB1cGRhdGUgdGhlaXJcXG4vLyBzdG9yZWQgaGVpZ2h0cyB0byBtYXRjaC5cXG5mdW5jdGlvbiB1cGRhdGVIZWlnaHRzSW5WaWV3cG9ydChjbSkge1xcbiAgdmFyIGRpc3BsYXkgPSBjbS5kaXNwbGF5XFxuICB2YXIgcHJldkJvdHRvbSA9IGRpc3BsYXkubGluZURpdi5vZmZzZXRUb3BcXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZGlzcGxheS52aWV3Lmxlbmd0aDsgaSsrKSB7XFxuICAgIHZhciBjdXIgPSBkaXNwbGF5LnZpZXdbaV0sIGhlaWdodCA9ICh2b2lkIDApXFxuICAgIGlmIChjdXIuaGlkZGVuKSB7IGNvbnRpbnVlIH1cXG4gICAgaWYgKGllICYmIGllX3ZlcnNpb24gPCA4KSB7XFxuICAgICAgdmFyIGJvdCA9IGN1ci5ub2RlLm9mZnNldFRvcCArIGN1ci5ub2RlLm9mZnNldEhlaWdodFxcbiAgICAgIGhlaWdodCA9IGJvdCAtIHByZXZCb3R0b21cXG4gICAgICBwcmV2Qm90dG9tID0gYm90XFxuICAgIH0gZWxzZSB7XFxuICAgICAgdmFyIGJveCA9IGN1ci5ub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXFxuICAgICAgaGVpZ2h0ID0gYm94LmJvdHRvbSAtIGJveC50b3BcXG4gICAgfVxcbiAgICB2YXIgZGlmZiA9IGN1ci5saW5lLmhlaWdodCAtIGhlaWdodFxcbiAgICBpZiAoaGVpZ2h0IDwgMikgeyBoZWlnaHQgPSB0ZXh0SGVpZ2h0KGRpc3BsYXkpIH1cXG4gICAgaWYgKGRpZmYgPiAuMDAxIHx8IGRpZmYgPCAtLjAwMSkge1xcbiAgICAgIHVwZGF0ZUxpbmVIZWlnaHQoY3VyLmxpbmUsIGhlaWdodClcXG4gICAgICB1cGRhdGVXaWRnZXRIZWlnaHQoY3VyLmxpbmUpXFxuICAgICAgaWYgKGN1ci5yZXN0KSB7IGZvciAodmFyIGogPSAwOyBqIDwgY3VyLnJlc3QubGVuZ3RoOyBqKyspXFxuICAgICAgICB7IHVwZGF0ZVdpZGdldEhlaWdodChjdXIucmVzdFtqXSkgfSB9XFxuICAgIH1cXG4gIH1cXG59XFxuXFxuLy8gUmVhZCBhbmQgc3RvcmUgdGhlIGhlaWdodCBvZiBsaW5lIHdpZGdldHMgYXNzb2NpYXRlZCB3aXRoIHRoZVxcbi8vIGdpdmVuIGxpbmUuXFxuZnVuY3Rpb24gdXBkYXRlV2lkZ2V0SGVpZ2h0KGxpbmUpIHtcXG4gIGlmIChsaW5lLndpZGdldHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lLndpZGdldHMubGVuZ3RoOyArK2kpXFxuICAgIHsgbGluZS53aWRnZXRzW2ldLmhlaWdodCA9IGxpbmUud2lkZ2V0c1tpXS5ub2RlLnBhcmVudE5vZGUub2Zmc2V0SGVpZ2h0IH0gfVxcbn1cXG5cXG4vLyBDb21wdXRlIHRoZSBsaW5lcyB0aGF0IGFyZSB2aXNpYmxlIGluIGEgZ2l2ZW4gdmlld3BvcnQgKGRlZmF1bHRzXFxuLy8gdGhlIHRoZSBjdXJyZW50IHNjcm9sbCBwb3NpdGlvbikuIHZpZXdwb3J0IG1heSBjb250YWluIHRvcCxcXG4vLyBoZWlnaHQsIGFuZCBlbnN1cmUgKHNlZSBvcC5zY3JvbGxUb1BvcykgcHJvcGVydGllcy5cXG5mdW5jdGlvbiB2aXNpYmxlTGluZXMoZGlzcGxheSwgZG9jLCB2aWV3cG9ydCkge1xcbiAgdmFyIHRvcCA9IHZpZXdwb3J0ICYmIHZpZXdwb3J0LnRvcCAhPSBudWxsID8gTWF0aC5tYXgoMCwgdmlld3BvcnQudG9wKSA6IGRpc3BsYXkuc2Nyb2xsZXIuc2Nyb2xsVG9wXFxuICB0b3AgPSBNYXRoLmZsb29yKHRvcCAtIHBhZGRpbmdUb3AoZGlzcGxheSkpXFxuICB2YXIgYm90dG9tID0gdmlld3BvcnQgJiYgdmlld3BvcnQuYm90dG9tICE9IG51bGwgPyB2aWV3cG9ydC5ib3R0b20gOiB0b3AgKyBkaXNwbGF5LndyYXBwZXIuY2xpZW50SGVpZ2h0XFxuXFxuICB2YXIgZnJvbSA9IGxpbmVBdEhlaWdodChkb2MsIHRvcCksIHRvID0gbGluZUF0SGVpZ2h0KGRvYywgYm90dG9tKVxcbiAgLy8gRW5zdXJlIGlzIGEge2Zyb206IHtsaW5lLCBjaH0sIHRvOiB7bGluZSwgY2h9fSBvYmplY3QsIGFuZFxcbiAgLy8gZm9yY2VzIHRob3NlIGxpbmVzIGludG8gdGhlIHZpZXdwb3J0IChpZiBwb3NzaWJsZSkuXFxuICBpZiAodmlld3BvcnQgJiYgdmlld3BvcnQuZW5zdXJlKSB7XFxuICAgIHZhciBlbnN1cmVGcm9tID0gdmlld3BvcnQuZW5zdXJlLmZyb20ubGluZSwgZW5zdXJlVG8gPSB2aWV3cG9ydC5lbnN1cmUudG8ubGluZVxcbiAgICBpZiAoZW5zdXJlRnJvbSA8IGZyb20pIHtcXG4gICAgICBmcm9tID0gZW5zdXJlRnJvbVxcbiAgICAgIHRvID0gbGluZUF0SGVpZ2h0KGRvYywgaGVpZ2h0QXRMaW5lKGdldExpbmUoZG9jLCBlbnN1cmVGcm9tKSkgKyBkaXNwbGF5LndyYXBwZXIuY2xpZW50SGVpZ2h0KVxcbiAgICB9IGVsc2UgaWYgKE1hdGgubWluKGVuc3VyZVRvLCBkb2MubGFzdExpbmUoKSkgPj0gdG8pIHtcXG4gICAgICBmcm9tID0gbGluZUF0SGVpZ2h0KGRvYywgaGVpZ2h0QXRMaW5lKGdldExpbmUoZG9jLCBlbnN1cmVUbykpIC0gZGlzcGxheS53cmFwcGVyLmNsaWVudEhlaWdodClcXG4gICAgICB0byA9IGVuc3VyZVRvXFxuICAgIH1cXG4gIH1cXG4gIHJldHVybiB7ZnJvbTogZnJvbSwgdG86IE1hdGgubWF4KHRvLCBmcm9tICsgMSl9XFxufVxcblxcbi8vIFN5bmMgdGhlIHNjcm9sbGFibGUgYXJlYSBhbmQgc2Nyb2xsYmFycywgZW5zdXJlIHRoZSB2aWV3cG9ydFxcbi8vIGNvdmVycyB0aGUgdmlzaWJsZSBhcmVhLlxcbmZ1bmN0aW9uIHNldFNjcm9sbFRvcChjbSwgdmFsKSB7XFxuICBpZiAoTWF0aC5hYnMoY20uZG9jLnNjcm9sbFRvcCAtIHZhbCkgPCAyKSB7IHJldHVybiB9XFxuICBjbS5kb2Muc2Nyb2xsVG9wID0gdmFsXFxuICBpZiAoIWdlY2tvKSB7IHVwZGF0ZURpc3BsYXlTaW1wbGUoY20sIHt0b3A6IHZhbH0pIH1cXG4gIGlmIChjbS5kaXNwbGF5LnNjcm9sbGVyLnNjcm9sbFRvcCAhPSB2YWwpIHsgY20uZGlzcGxheS5zY3JvbGxlci5zY3JvbGxUb3AgPSB2YWwgfVxcbiAgY20uZGlzcGxheS5zY3JvbGxiYXJzLnNldFNjcm9sbFRvcCh2YWwpXFxuICBpZiAoZ2Vja28pIHsgdXBkYXRlRGlzcGxheVNpbXBsZShjbSkgfVxcbiAgc3RhcnRXb3JrZXIoY20sIDEwMClcXG59XFxuLy8gU3luYyBzY3JvbGxlciBhbmQgc2Nyb2xsYmFyLCBlbnN1cmUgdGhlIGd1dHRlciBlbGVtZW50cyBhcmVcXG4vLyBhbGlnbmVkLlxcbmZ1bmN0aW9uIHNldFNjcm9sbExlZnQoY20sIHZhbCwgaXNTY3JvbGxlcikge1xcbiAgaWYgKGlzU2Nyb2xsZXIgPyB2YWwgPT0gY20uZG9jLnNjcm9sbExlZnQgOiBNYXRoLmFicyhjbS5kb2Muc2Nyb2xsTGVmdCAtIHZhbCkgPCAyKSB7IHJldHVybiB9XFxuICB2YWwgPSBNYXRoLm1pbih2YWwsIGNtLmRpc3BsYXkuc2Nyb2xsZXIuc2Nyb2xsV2lkdGggLSBjbS5kaXNwbGF5LnNjcm9sbGVyLmNsaWVudFdpZHRoKVxcbiAgY20uZG9jLnNjcm9sbExlZnQgPSB2YWxcXG4gIGFsaWduSG9yaXpvbnRhbGx5KGNtKVxcbiAgaWYgKGNtLmRpc3BsYXkuc2Nyb2xsZXIuc2Nyb2xsTGVmdCAhPSB2YWwpIHsgY20uZGlzcGxheS5zY3JvbGxlci5zY3JvbGxMZWZ0ID0gdmFsIH1cXG4gIGNtLmRpc3BsYXkuc2Nyb2xsYmFycy5zZXRTY3JvbGxMZWZ0KHZhbClcXG59XFxuXFxuLy8gU2luY2UgdGhlIGRlbHRhIHZhbHVlcyByZXBvcnRlZCBvbiBtb3VzZSB3aGVlbCBldmVudHMgYXJlXFxuLy8gdW5zdGFuZGFyZGl6ZWQgYmV0d2VlbiBicm93c2VycyBhbmQgZXZlbiBicm93c2VyIHZlcnNpb25zLCBhbmRcXG4vLyBnZW5lcmFsbHkgaG9ycmlibHkgdW5wcmVkaWN0YWJsZSwgdGhpcyBjb2RlIHN0YXJ0cyBieSBtZWFzdXJpbmdcXG4vLyB0aGUgc2Nyb2xsIGVmZmVjdCB0aGF0IHRoZSBmaXJzdCBmZXcgbW91c2Ugd2hlZWwgZXZlbnRzIGhhdmUsXFxuLy8gYW5kLCBmcm9tIHRoYXQsIGRldGVjdHMgdGhlIHdheSBpdCBjYW4gY29udmVydCBkZWx0YXMgdG8gcGl4ZWxcXG4vLyBvZmZzZXRzIGFmdGVyd2FyZHMuXFxuLy9cXG4vLyBUaGUgcmVhc29uIHdlIHdhbnQgdG8ga25vdyB0aGUgYW1vdW50IGEgd2hlZWwgZXZlbnQgd2lsbCBzY3JvbGxcXG4vLyBpcyB0aGF0IGl0IGdpdmVzIHVzIGEgY2hhbmNlIHRvIHVwZGF0ZSB0aGUgZGlzcGxheSBiZWZvcmUgdGhlXFxuLy8gYWN0dWFsIHNjcm9sbGluZyBoYXBwZW5zLCByZWR1Y2luZyBmbGlja2VyaW5nLlxcblxcbnZhciB3aGVlbFNhbXBsZXMgPSAwO1xcbnZhciB3aGVlbFBpeGVsc1BlclVuaXQgPSBudWxsO1xcbi8vIEZpbGwgaW4gYSBicm93c2VyLWRldGVjdGVkIHN0YXJ0aW5nIHZhbHVlIG9uIGJyb3dzZXJzIHdoZXJlIHdlXFxuLy8ga25vdyBvbmUuIFRoZXNlIGRvbid0IGhhdmUgdG8gYmUgYWNjdXJhdGUgLS0gdGhlIHJlc3VsdCBvZiB0aGVtXFxuLy8gYmVpbmcgd3Jvbmcgd291bGQganVzdCBiZSBhIHNsaWdodCBmbGlja2VyIG9uIHRoZSBmaXJzdCB3aGVlbFxcbi8vIHNjcm9sbCAoaWYgaXQgaXMgbGFyZ2UgZW5vdWdoKS5cXG5pZiAoaWUpIHsgd2hlZWxQaXhlbHNQZXJVbml0ID0gLS41MyB9XFxuZWxzZSBpZiAoZ2Vja28pIHsgd2hlZWxQaXhlbHNQZXJVbml0ID0gMTUgfVxcbmVsc2UgaWYgKGNocm9tZSkgeyB3aGVlbFBpeGVsc1BlclVuaXQgPSAtLjcgfVxcbmVsc2UgaWYgKHNhZmFyaSkgeyB3aGVlbFBpeGVsc1BlclVuaXQgPSAtMS8zIH1cXG5cXG5mdW5jdGlvbiB3aGVlbEV2ZW50RGVsdGEoZSkge1xcbiAgdmFyIGR4ID0gZS53aGVlbERlbHRhWCwgZHkgPSBlLndoZWVsRGVsdGFZXFxuICBpZiAoZHggPT0gbnVsbCAmJiBlLmRldGFpbCAmJiBlLmF4aXMgPT0gZS5IT1JJWk9OVEFMX0FYSVMpIHsgZHggPSBlLmRldGFpbCB9XFxuICBpZiAoZHkgPT0gbnVsbCAmJiBlLmRldGFpbCAmJiBlLmF4aXMgPT0gZS5WRVJUSUNBTF9BWElTKSB7IGR5ID0gZS5kZXRhaWwgfVxcbiAgZWxzZSBpZiAoZHkgPT0gbnVsbCkgeyBkeSA9IGUud2hlZWxEZWx0YSB9XFxuICByZXR1cm4ge3g6IGR4LCB5OiBkeX1cXG59XFxuZnVuY3Rpb24gd2hlZWxFdmVudFBpeGVscyhlKSB7XFxuICB2YXIgZGVsdGEgPSB3aGVlbEV2ZW50RGVsdGEoZSlcXG4gIGRlbHRhLnggKj0gd2hlZWxQaXhlbHNQZXJVbml0XFxuICBkZWx0YS55ICo9IHdoZWVsUGl4ZWxzUGVyVW5pdFxcbiAgcmV0dXJuIGRlbHRhXFxufVxcblxcbmZ1bmN0aW9uIG9uU2Nyb2xsV2hlZWwoY20sIGUpIHtcXG4gIHZhciBkZWx0YSA9IHdoZWVsRXZlbnREZWx0YShlKSwgZHggPSBkZWx0YS54LCBkeSA9IGRlbHRhLnlcXG5cXG4gIHZhciBkaXNwbGF5ID0gY20uZGlzcGxheSwgc2Nyb2xsID0gZGlzcGxheS5zY3JvbGxlclxcbiAgLy8gUXVpdCBpZiB0aGVyZSdzIG5vdGhpbmcgdG8gc2Nyb2xsIGhlcmVcXG4gIHZhciBjYW5TY3JvbGxYID0gc2Nyb2xsLnNjcm9sbFdpZHRoID4gc2Nyb2xsLmNsaWVudFdpZHRoXFxuICB2YXIgY2FuU2Nyb2xsWSA9IHNjcm9sbC5zY3JvbGxIZWlnaHQgPiBzY3JvbGwuY2xpZW50SGVpZ2h0XFxuICBpZiAoIShkeCAmJiBjYW5TY3JvbGxYIHx8IGR5ICYmIGNhblNjcm9sbFkpKSB7IHJldHVybiB9XFxuXFxuICAvLyBXZWJraXQgYnJvd3NlcnMgb24gT1MgWCBhYm9ydCBtb21lbnR1bSBzY3JvbGxzIHdoZW4gdGhlIHRhcmdldFxcbiAgLy8gb2YgdGhlIHNjcm9sbCBldmVudCBpcyByZW1vdmVkIGZyb20gdGhlIHNjcm9sbGFibGUgZWxlbWVudC5cXG4gIC8vIFRoaXMgaGFjayAoc2VlIHJlbGF0ZWQgY29kZSBpbiBwYXRjaERpc3BsYXkpIG1ha2VzIHN1cmUgdGhlXFxuICAvLyBlbGVtZW50IGlzIGtlcHQgYXJvdW5kLlxcbiAgaWYgKGR5ICYmIG1hYyAmJiB3ZWJraXQpIHtcXG4gICAgb3V0ZXI6IGZvciAodmFyIGN1ciA9IGUudGFyZ2V0LCB2aWV3ID0gZGlzcGxheS52aWV3OyBjdXIgIT0gc2Nyb2xsOyBjdXIgPSBjdXIucGFyZW50Tm9kZSkge1xcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmlldy5sZW5ndGg7IGkrKykge1xcbiAgICAgICAgaWYgKHZpZXdbaV0ubm9kZSA9PSBjdXIpIHtcXG4gICAgICAgICAgY20uZGlzcGxheS5jdXJyZW50V2hlZWxUYXJnZXQgPSBjdXJcXG4gICAgICAgICAgYnJlYWsgb3V0ZXJcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIH1cXG4gIH1cXG5cXG4gIC8vIE9uIHNvbWUgYnJvd3NlcnMsIGhvcml6b250YWwgc2Nyb2xsaW5nIHdpbGwgY2F1c2UgcmVkcmF3cyB0b1xcbiAgLy8gaGFwcGVuIGJlZm9yZSB0aGUgZ3V0dGVyIGhhcyBiZWVuIHJlYWxpZ25lZCwgY2F1c2luZyBpdCB0b1xcbiAgLy8gd3JpZ2dsZSBhcm91bmQgaW4gYSBtb3N0IHVuc2VlbWx5IHdheS4gV2hlbiB3ZSBoYXZlIGFuXFxuICAvLyBlc3RpbWF0ZWQgcGl4ZWxzL2RlbHRhIHZhbHVlLCB3ZSBqdXN0IGhhbmRsZSBob3Jpem9udGFsXFxuICAvLyBzY3JvbGxpbmcgZW50aXJlbHkgaGVyZS4gSXQnbGwgYmUgc2xpZ2h0bHkgb2ZmIGZyb20gbmF0aXZlLCBidXRcXG4gIC8vIGJldHRlciB0aGFuIGdsaXRjaGluZyBvdXQuXFxuICBpZiAoZHggJiYgIWdlY2tvICYmICFwcmVzdG8gJiYgd2hlZWxQaXhlbHNQZXJVbml0ICE9IG51bGwpIHtcXG4gICAgaWYgKGR5ICYmIGNhblNjcm9sbFkpXFxuICAgICAgeyBzZXRTY3JvbGxUb3AoY20sIE1hdGgubWF4KDAsIE1hdGgubWluKHNjcm9sbC5zY3JvbGxUb3AgKyBkeSAqIHdoZWVsUGl4ZWxzUGVyVW5pdCwgc2Nyb2xsLnNjcm9sbEhlaWdodCAtIHNjcm9sbC5jbGllbnRIZWlnaHQpKSkgfVxcbiAgICBzZXRTY3JvbGxMZWZ0KGNtLCBNYXRoLm1heCgwLCBNYXRoLm1pbihzY3JvbGwuc2Nyb2xsTGVmdCArIGR4ICogd2hlZWxQaXhlbHNQZXJVbml0LCBzY3JvbGwuc2Nyb2xsV2lkdGggLSBzY3JvbGwuY2xpZW50V2lkdGgpKSlcXG4gICAgLy8gT25seSBwcmV2ZW50IGRlZmF1bHQgc2Nyb2xsaW5nIGlmIHZlcnRpY2FsIHNjcm9sbGluZyBpc1xcbiAgICAvLyBhY3R1YWxseSBwb3NzaWJsZS4gT3RoZXJ3aXNlLCBpdCBjYXVzZXMgdmVydGljYWwgc2Nyb2xsXFxuICAgIC8vIGppdHRlciBvbiBPU1ggdHJhY2twYWRzIHdoZW4gZGVsdGFYIGlzIHNtYWxsIGFuZCBkZWx0YVlcXG4gICAgLy8gaXMgbGFyZ2UgKGlzc3VlICMzNTc5KVxcbiAgICBpZiAoIWR5IHx8IChkeSAmJiBjYW5TY3JvbGxZKSlcXG4gICAgICB7IGVfcHJldmVudERlZmF1bHQoZSkgfVxcbiAgICBkaXNwbGF5LndoZWVsU3RhcnRYID0gbnVsbCAvLyBBYm9ydCBtZWFzdXJlbWVudCwgaWYgaW4gcHJvZ3Jlc3NcXG4gICAgcmV0dXJuXFxuICB9XFxuXFxuICAvLyAnUHJvamVjdCcgdGhlIHZpc2libGUgdmlld3BvcnQgdG8gY292ZXIgdGhlIGFyZWEgdGhhdCBpcyBiZWluZ1xcbiAgLy8gc2Nyb2xsZWQgaW50byB2aWV3IChpZiB3ZSBrbm93IGVub3VnaCB0byBlc3RpbWF0ZSBpdCkuXFxuICBpZiAoZHkgJiYgd2hlZWxQaXhlbHNQZXJVbml0ICE9IG51bGwpIHtcXG4gICAgdmFyIHBpeGVscyA9IGR5ICogd2hlZWxQaXhlbHNQZXJVbml0XFxuICAgIHZhciB0b3AgPSBjbS5kb2Muc2Nyb2xsVG9wLCBib3QgPSB0b3AgKyBkaXNwbGF5LndyYXBwZXIuY2xpZW50SGVpZ2h0XFxuICAgIGlmIChwaXhlbHMgPCAwKSB7IHRvcCA9IE1hdGgubWF4KDAsIHRvcCArIHBpeGVscyAtIDUwKSB9XFxuICAgIGVsc2UgeyBib3QgPSBNYXRoLm1pbihjbS5kb2MuaGVpZ2h0LCBib3QgKyBwaXhlbHMgKyA1MCkgfVxcbiAgICB1cGRhdGVEaXNwbGF5U2ltcGxlKGNtLCB7dG9wOiB0b3AsIGJvdHRvbTogYm90fSlcXG4gIH1cXG5cXG4gIGlmICh3aGVlbFNhbXBsZXMgPCAyMCkge1xcbiAgICBpZiAoZGlzcGxheS53aGVlbFN0YXJ0WCA9PSBudWxsKSB7XFxuICAgICAgZGlzcGxheS53aGVlbFN0YXJ0WCA9IHNjcm9sbC5zY3JvbGxMZWZ0OyBkaXNwbGF5LndoZWVsU3RhcnRZID0gc2Nyb2xsLnNjcm9sbFRvcFxcbiAgICAgIGRpc3BsYXkud2hlZWxEWCA9IGR4OyBkaXNwbGF5LndoZWVsRFkgPSBkeVxcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xcbiAgICAgICAgaWYgKGRpc3BsYXkud2hlZWxTdGFydFggPT0gbnVsbCkgeyByZXR1cm4gfVxcbiAgICAgICAgdmFyIG1vdmVkWCA9IHNjcm9sbC5zY3JvbGxMZWZ0IC0gZGlzcGxheS53aGVlbFN0YXJ0WFxcbiAgICAgICAgdmFyIG1vdmVkWSA9IHNjcm9sbC5zY3JvbGxUb3AgLSBkaXNwbGF5LndoZWVsU3RhcnRZXFxuICAgICAgICB2YXIgc2FtcGxlID0gKG1vdmVkWSAmJiBkaXNwbGF5LndoZWVsRFkgJiYgbW92ZWRZIC8gZGlzcGxheS53aGVlbERZKSB8fFxcbiAgICAgICAgICAobW92ZWRYICYmIGRpc3BsYXkud2hlZWxEWCAmJiBtb3ZlZFggLyBkaXNwbGF5LndoZWVsRFgpXFxuICAgICAgICBkaXNwbGF5LndoZWVsU3RhcnRYID0gZGlzcGxheS53aGVlbFN0YXJ0WSA9IG51bGxcXG4gICAgICAgIGlmICghc2FtcGxlKSB7IHJldHVybiB9XFxuICAgICAgICB3aGVlbFBpeGVsc1BlclVuaXQgPSAod2hlZWxQaXhlbHNQZXJVbml0ICogd2hlZWxTYW1wbGVzICsgc2FtcGxlKSAvICh3aGVlbFNhbXBsZXMgKyAxKVxcbiAgICAgICAgKyt3aGVlbFNhbXBsZXNcXG4gICAgICB9LCAyMDApXFxuICAgIH0gZWxzZSB7XFxuICAgICAgZGlzcGxheS53aGVlbERYICs9IGR4OyBkaXNwbGF5LndoZWVsRFkgKz0gZHlcXG4gICAgfVxcbiAgfVxcbn1cXG5cXG4vLyBTQ1JPTExCQVJTXFxuXFxuLy8gUHJlcGFyZSBET00gcmVhZHMgbmVlZGVkIHRvIHVwZGF0ZSB0aGUgc2Nyb2xsYmFycy4gRG9uZSBpbiBvbmVcXG4vLyBzaG90IHRvIG1pbmltaXplIHVwZGF0ZS9tZWFzdXJlIHJvdW5kdHJpcHMuXFxuZnVuY3Rpb24gbWVhc3VyZUZvclNjcm9sbGJhcnMoY20pIHtcXG4gIHZhciBkID0gY20uZGlzcGxheSwgZ3V0dGVyVyA9IGQuZ3V0dGVycy5vZmZzZXRXaWR0aFxcbiAgdmFyIGRvY0ggPSBNYXRoLnJvdW5kKGNtLmRvYy5oZWlnaHQgKyBwYWRkaW5nVmVydChjbS5kaXNwbGF5KSlcXG4gIHJldHVybiB7XFxuICAgIGNsaWVudEhlaWdodDogZC5zY3JvbGxlci5jbGllbnRIZWlnaHQsXFxuICAgIHZpZXdIZWlnaHQ6IGQud3JhcHBlci5jbGllbnRIZWlnaHQsXFxuICAgIHNjcm9sbFdpZHRoOiBkLnNjcm9sbGVyLnNjcm9sbFdpZHRoLCBjbGllbnRXaWR0aDogZC5zY3JvbGxlci5jbGllbnRXaWR0aCxcXG4gICAgdmlld1dpZHRoOiBkLndyYXBwZXIuY2xpZW50V2lkdGgsXFxuICAgIGJhckxlZnQ6IGNtLm9wdGlvbnMuZml4ZWRHdXR0ZXIgPyBndXR0ZXJXIDogMCxcXG4gICAgZG9jSGVpZ2h0OiBkb2NILFxcbiAgICBzY3JvbGxIZWlnaHQ6IGRvY0ggKyBzY3JvbGxHYXAoY20pICsgZC5iYXJIZWlnaHQsXFxuICAgIG5hdGl2ZUJhcldpZHRoOiBkLm5hdGl2ZUJhcldpZHRoLFxcbiAgICBndXR0ZXJXaWR0aDogZ3V0dGVyV1xcbiAgfVxcbn1cXG5cXG52YXIgTmF0aXZlU2Nyb2xsYmFycyA9IGZ1bmN0aW9uKHBsYWNlLCBzY3JvbGwsIGNtKSB7XFxuICB0aGlzLmNtID0gY21cXG4gIHZhciB2ZXJ0ID0gdGhpcy52ZXJ0ID0gZWx0KFxcXCJkaXZcXFwiLCBbZWx0KFxcXCJkaXZcXFwiLCBudWxsLCBudWxsLCBcXFwibWluLXdpZHRoOiAxcHhcXFwiKV0sIFxcXCJDb2RlTWlycm9yLXZzY3JvbGxiYXJcXFwiKVxcbiAgdmFyIGhvcml6ID0gdGhpcy5ob3JpeiA9IGVsdChcXFwiZGl2XFxcIiwgW2VsdChcXFwiZGl2XFxcIiwgbnVsbCwgbnVsbCwgXFxcImhlaWdodDogMTAwJTsgbWluLWhlaWdodDogMXB4XFxcIildLCBcXFwiQ29kZU1pcnJvci1oc2Nyb2xsYmFyXFxcIilcXG4gIHBsYWNlKHZlcnQpOyBwbGFjZShob3JpeilcXG5cXG4gIG9uKHZlcnQsIFxcXCJzY3JvbGxcXFwiLCBmdW5jdGlvbiAoKSB7XFxuICAgIGlmICh2ZXJ0LmNsaWVudEhlaWdodCkgeyBzY3JvbGwodmVydC5zY3JvbGxUb3AsIFxcXCJ2ZXJ0aWNhbFxcXCIpIH1cXG4gIH0pXFxuICBvbihob3JpeiwgXFxcInNjcm9sbFxcXCIsIGZ1bmN0aW9uICgpIHtcXG4gICAgaWYgKGhvcml6LmNsaWVudFdpZHRoKSB7IHNjcm9sbChob3Jpei5zY3JvbGxMZWZ0LCBcXFwiaG9yaXpvbnRhbFxcXCIpIH1cXG4gIH0pXFxuXFxuICB0aGlzLmNoZWNrZWRaZXJvV2lkdGggPSBmYWxzZVxcbiAgLy8gTmVlZCB0byBzZXQgYSBtaW5pbXVtIHdpZHRoIHRvIHNlZSB0aGUgc2Nyb2xsYmFyIG9uIElFNyAoYnV0IG11c3Qgbm90IHNldCBpdCBvbiBJRTgpLlxcbiAgaWYgKGllICYmIGllX3ZlcnNpb24gPCA4KSB7IHRoaXMuaG9yaXouc3R5bGUubWluSGVpZ2h0ID0gdGhpcy52ZXJ0LnN0eWxlLm1pbldpZHRoID0gXFxcIjE4cHhcXFwiIH1cXG59O1xcblxcbk5hdGl2ZVNjcm9sbGJhcnMucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChtZWFzdXJlKSB7XFxuICB2YXIgbmVlZHNIID0gbWVhc3VyZS5zY3JvbGxXaWR0aCA+IG1lYXN1cmUuY2xpZW50V2lkdGggKyAxXFxuICB2YXIgbmVlZHNWID0gbWVhc3VyZS5zY3JvbGxIZWlnaHQgPiBtZWFzdXJlLmNsaWVudEhlaWdodCArIDFcXG4gIHZhciBzV2lkdGggPSBtZWFzdXJlLm5hdGl2ZUJhcldpZHRoXFxuXFxuICBpZiAobmVlZHNWKSB7XFxuICAgIHRoaXMudmVydC5zdHlsZS5kaXNwbGF5ID0gXFxcImJsb2NrXFxcIlxcbiAgICB0aGlzLnZlcnQuc3R5bGUuYm90dG9tID0gbmVlZHNIID8gc1dpZHRoICsgXFxcInB4XFxcIiA6IFxcXCIwXFxcIlxcbiAgICB2YXIgdG90YWxIZWlnaHQgPSBtZWFzdXJlLnZpZXdIZWlnaHQgLSAobmVlZHNIID8gc1dpZHRoIDogMClcXG4gICAgLy8gQSBidWcgaW4gSUU4IGNhbiBjYXVzZSB0aGlzIHZhbHVlIHRvIGJlIG5lZ2F0aXZlLCBzbyBndWFyZCBpdC5cXG4gICAgdGhpcy52ZXJ0LmZpcnN0Q2hpbGQuc3R5bGUuaGVpZ2h0ID1cXG4gICAgICBNYXRoLm1heCgwLCBtZWFzdXJlLnNjcm9sbEhlaWdodCAtIG1lYXN1cmUuY2xpZW50SGVpZ2h0ICsgdG90YWxIZWlnaHQpICsgXFxcInB4XFxcIlxcbiAgfSBlbHNlIHtcXG4gICAgdGhpcy52ZXJ0LnN0eWxlLmRpc3BsYXkgPSBcXFwiXFxcIlxcbiAgICB0aGlzLnZlcnQuZmlyc3RDaGlsZC5zdHlsZS5oZWlnaHQgPSBcXFwiMFxcXCJcXG4gIH1cXG5cXG4gIGlmIChuZWVkc0gpIHtcXG4gICAgdGhpcy5ob3Jpei5zdHlsZS5kaXNwbGF5ID0gXFxcImJsb2NrXFxcIlxcbiAgICB0aGlzLmhvcml6LnN0eWxlLnJpZ2h0ID0gbmVlZHNWID8gc1dpZHRoICsgXFxcInB4XFxcIiA6IFxcXCIwXFxcIlxcbiAgICB0aGlzLmhvcml6LnN0eWxlLmxlZnQgPSBtZWFzdXJlLmJhckxlZnQgKyBcXFwicHhcXFwiXFxuICAgIHZhciB0b3RhbFdpZHRoID0gbWVhc3VyZS52aWV3V2lkdGggLSBtZWFzdXJlLmJhckxlZnQgLSAobmVlZHNWID8gc1dpZHRoIDogMClcXG4gICAgdGhpcy5ob3Jpei5maXJzdENoaWxkLnN0eWxlLndpZHRoID1cXG4gICAgICAobWVhc3VyZS5zY3JvbGxXaWR0aCAtIG1lYXN1cmUuY2xpZW50V2lkdGggKyB0b3RhbFdpZHRoKSArIFxcXCJweFxcXCJcXG4gIH0gZWxzZSB7XFxuICAgIHRoaXMuaG9yaXouc3R5bGUuZGlzcGxheSA9IFxcXCJcXFwiXFxuICAgIHRoaXMuaG9yaXouZmlyc3RDaGlsZC5zdHlsZS53aWR0aCA9IFxcXCIwXFxcIlxcbiAgfVxcblxcbiAgaWYgKCF0aGlzLmNoZWNrZWRaZXJvV2lkdGggJiYgbWVhc3VyZS5jbGllbnRIZWlnaHQgPiAwKSB7XFxuICAgIGlmIChzV2lkdGggPT0gMCkgeyB0aGlzLnplcm9XaWR0aEhhY2soKSB9XFxuICAgIHRoaXMuY2hlY2tlZFplcm9XaWR0aCA9IHRydWVcXG4gIH1cXG5cXG4gIHJldHVybiB7cmlnaHQ6IG5lZWRzViA/IHNXaWR0aCA6IDAsIGJvdHRvbTogbmVlZHNIID8gc1dpZHRoIDogMH1cXG59O1xcblxcbk5hdGl2ZVNjcm9sbGJhcnMucHJvdG90eXBlLnNldFNjcm9sbExlZnQgPSBmdW5jdGlvbiAocG9zKSB7XFxuICBpZiAodGhpcy5ob3Jpei5zY3JvbGxMZWZ0ICE9IHBvcykgeyB0aGlzLmhvcml6LnNjcm9sbExlZnQgPSBwb3MgfVxcbiAgaWYgKHRoaXMuZGlzYWJsZUhvcml6KSB7IHRoaXMuZW5hYmxlWmVyb1dpZHRoQmFyKHRoaXMuaG9yaXosIHRoaXMuZGlzYWJsZUhvcml6KSB9XFxufTtcXG5cXG5OYXRpdmVTY3JvbGxiYXJzLnByb3RvdHlwZS5zZXRTY3JvbGxUb3AgPSBmdW5jdGlvbiAocG9zKSB7XFxuICBpZiAodGhpcy52ZXJ0LnNjcm9sbFRvcCAhPSBwb3MpIHsgdGhpcy52ZXJ0LnNjcm9sbFRvcCA9IHBvcyB9XFxuICBpZiAodGhpcy5kaXNhYmxlVmVydCkgeyB0aGlzLmVuYWJsZVplcm9XaWR0aEJhcih0aGlzLnZlcnQsIHRoaXMuZGlzYWJsZVZlcnQpIH1cXG59O1xcblxcbk5hdGl2ZVNjcm9sbGJhcnMucHJvdG90eXBlLnplcm9XaWR0aEhhY2sgPSBmdW5jdGlvbiAoKSB7XFxuICB2YXIgdyA9IG1hYyAmJiAhbWFjX2dlTW91bnRhaW5MaW9uID8gXFxcIjEycHhcXFwiIDogXFxcIjE4cHhcXFwiXFxuICB0aGlzLmhvcml6LnN0eWxlLmhlaWdodCA9IHRoaXMudmVydC5zdHlsZS53aWR0aCA9IHdcXG4gIHRoaXMuaG9yaXouc3R5bGUucG9pbnRlckV2ZW50cyA9IHRoaXMudmVydC5zdHlsZS5wb2ludGVyRXZlbnRzID0gXFxcIm5vbmVcXFwiXFxuICB0aGlzLmRpc2FibGVIb3JpeiA9IG5ldyBEZWxheWVkXFxuICB0aGlzLmRpc2FibGVWZXJ0ID0gbmV3IERlbGF5ZWRcXG59O1xcblxcbk5hdGl2ZVNjcm9sbGJhcnMucHJvdG90eXBlLmVuYWJsZVplcm9XaWR0aEJhciA9IGZ1bmN0aW9uIChiYXIsIGRlbGF5KSB7XFxuICBiYXIuc3R5bGUucG9pbnRlckV2ZW50cyA9IFxcXCJhdXRvXFxcIlxcbiAgZnVuY3Rpb24gbWF5YmVEaXNhYmxlKCkge1xcbiAgICAvLyBUbyBmaW5kIG91dCB3aGV0aGVyIHRoZSBzY3JvbGxiYXIgaXMgc3RpbGwgdmlzaWJsZSwgd2VcXG4gICAgLy8gY2hlY2sgd2hldGhlciB0aGUgZWxlbWVudCB1bmRlciB0aGUgcGl4ZWwgaW4gdGhlIGJvdHRvbVxcbiAgICAvLyBsZWZ0IGNvcm5lciBvZiB0aGUgc2Nyb2xsYmFyIGJveCBpcyB0aGUgc2Nyb2xsYmFyIGJveFxcbiAgICAvLyBpdHNlbGYgKHdoZW4gdGhlIGJhciBpcyBzdGlsbCB2aXNpYmxlKSBvciBpdHMgZmlsbGVyIGNoaWxkXFxuICAgIC8vICh3aGVuIHRoZSBiYXIgaXMgaGlkZGVuKS4gSWYgaXQgaXMgc3RpbGwgdmlzaWJsZSwgd2Uga2VlcFxcbiAgICAvLyBpdCBlbmFibGVkLCBpZiBpdCdzIGhpZGRlbiwgd2UgZGlzYWJsZSBwb2ludGVyIGV2ZW50cy5cXG4gICAgdmFyIGJveCA9IGJhci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxcbiAgICB2YXIgZWx0ID0gZG9jdW1lbnQuZWxlbWVudEZyb21Qb2ludChib3gubGVmdCArIDEsIGJveC5ib3R0b20gLSAxKVxcbiAgICBpZiAoZWx0ICE9IGJhcikgeyBiYXIuc3R5bGUucG9pbnRlckV2ZW50cyA9IFxcXCJub25lXFxcIiB9XFxuICAgIGVsc2UgeyBkZWxheS5zZXQoMTAwMCwgbWF5YmVEaXNhYmxlKSB9XFxuICB9XFxuICBkZWxheS5zZXQoMTAwMCwgbWF5YmVEaXNhYmxlKVxcbn07XFxuXFxuTmF0aXZlU2Nyb2xsYmFycy5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XFxuICB2YXIgcGFyZW50ID0gdGhpcy5ob3Jpei5wYXJlbnROb2RlXFxuICBwYXJlbnQucmVtb3ZlQ2hpbGQodGhpcy5ob3JpeilcXG4gIHBhcmVudC5yZW1vdmVDaGlsZCh0aGlzLnZlcnQpXFxufTtcXG5cXG52YXIgTnVsbFNjcm9sbGJhcnMgPSBmdW5jdGlvbiAoKSB7fTtcXG5cXG5OdWxsU2Nyb2xsYmFycy5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkgeyByZXR1cm4ge2JvdHRvbTogMCwgcmlnaHQ6IDB9IH07XFxuTnVsbFNjcm9sbGJhcnMucHJvdG90eXBlLnNldFNjcm9sbExlZnQgPSBmdW5jdGlvbiAoKSB7fTtcXG5OdWxsU2Nyb2xsYmFycy5wcm90b3R5cGUuc2V0U2Nyb2xsVG9wID0gZnVuY3Rpb24gKCkge307XFxuTnVsbFNjcm9sbGJhcnMucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge307XFxuXFxuZnVuY3Rpb24gdXBkYXRlU2Nyb2xsYmFycyhjbSwgbWVhc3VyZSkge1xcbiAgaWYgKCFtZWFzdXJlKSB7IG1lYXN1cmUgPSBtZWFzdXJlRm9yU2Nyb2xsYmFycyhjbSkgfVxcbiAgdmFyIHN0YXJ0V2lkdGggPSBjbS5kaXNwbGF5LmJhcldpZHRoLCBzdGFydEhlaWdodCA9IGNtLmRpc3BsYXkuYmFySGVpZ2h0XFxuICB1cGRhdGVTY3JvbGxiYXJzSW5uZXIoY20sIG1lYXN1cmUpXFxuICBmb3IgKHZhciBpID0gMDsgaSA8IDQgJiYgc3RhcnRXaWR0aCAhPSBjbS5kaXNwbGF5LmJhcldpZHRoIHx8IHN0YXJ0SGVpZ2h0ICE9IGNtLmRpc3BsYXkuYmFySGVpZ2h0OyBpKyspIHtcXG4gICAgaWYgKHN0YXJ0V2lkdGggIT0gY20uZGlzcGxheS5iYXJXaWR0aCAmJiBjbS5vcHRpb25zLmxpbmVXcmFwcGluZylcXG4gICAgICB7IHVwZGF0ZUhlaWdodHNJblZpZXdwb3J0KGNtKSB9XFxuICAgIHVwZGF0ZVNjcm9sbGJhcnNJbm5lcihjbSwgbWVhc3VyZUZvclNjcm9sbGJhcnMoY20pKVxcbiAgICBzdGFydFdpZHRoID0gY20uZGlzcGxheS5iYXJXaWR0aDsgc3RhcnRIZWlnaHQgPSBjbS5kaXNwbGF5LmJhckhlaWdodFxcbiAgfVxcbn1cXG5cXG4vLyBSZS1zeW5jaHJvbml6ZSB0aGUgZmFrZSBzY3JvbGxiYXJzIHdpdGggdGhlIGFjdHVhbCBzaXplIG9mIHRoZVxcbi8vIGNvbnRlbnQuXFxuZnVuY3Rpb24gdXBkYXRlU2Nyb2xsYmFyc0lubmVyKGNtLCBtZWFzdXJlKSB7XFxuICB2YXIgZCA9IGNtLmRpc3BsYXlcXG4gIHZhciBzaXplcyA9IGQuc2Nyb2xsYmFycy51cGRhdGUobWVhc3VyZSlcXG5cXG4gIGQuc2l6ZXIuc3R5bGUucGFkZGluZ1JpZ2h0ID0gKGQuYmFyV2lkdGggPSBzaXplcy5yaWdodCkgKyBcXFwicHhcXFwiXFxuICBkLnNpemVyLnN0eWxlLnBhZGRpbmdCb3R0b20gPSAoZC5iYXJIZWlnaHQgPSBzaXplcy5ib3R0b20pICsgXFxcInB4XFxcIlxcbiAgZC5oZWlnaHRGb3JjZXIuc3R5bGUuYm9yZGVyQm90dG9tID0gc2l6ZXMuYm90dG9tICsgXFxcInB4IHNvbGlkIHRyYW5zcGFyZW50XFxcIlxcblxcbiAgaWYgKHNpemVzLnJpZ2h0ICYmIHNpemVzLmJvdHRvbSkge1xcbiAgICBkLnNjcm9sbGJhckZpbGxlci5zdHlsZS5kaXNwbGF5ID0gXFxcImJsb2NrXFxcIlxcbiAgICBkLnNjcm9sbGJhckZpbGxlci5zdHlsZS5oZWlnaHQgPSBzaXplcy5ib3R0b20gKyBcXFwicHhcXFwiXFxuICAgIGQuc2Nyb2xsYmFyRmlsbGVyLnN0eWxlLndpZHRoID0gc2l6ZXMucmlnaHQgKyBcXFwicHhcXFwiXFxuICB9IGVsc2UgeyBkLnNjcm9sbGJhckZpbGxlci5zdHlsZS5kaXNwbGF5ID0gXFxcIlxcXCIgfVxcbiAgaWYgKHNpemVzLmJvdHRvbSAmJiBjbS5vcHRpb25zLmNvdmVyR3V0dGVyTmV4dFRvU2Nyb2xsYmFyICYmIGNtLm9wdGlvbnMuZml4ZWRHdXR0ZXIpIHtcXG4gICAgZC5ndXR0ZXJGaWxsZXIuc3R5bGUuZGlzcGxheSA9IFxcXCJibG9ja1xcXCJcXG4gICAgZC5ndXR0ZXJGaWxsZXIuc3R5bGUuaGVpZ2h0ID0gc2l6ZXMuYm90dG9tICsgXFxcInB4XFxcIlxcbiAgICBkLmd1dHRlckZpbGxlci5zdHlsZS53aWR0aCA9IG1lYXN1cmUuZ3V0dGVyV2lkdGggKyBcXFwicHhcXFwiXFxuICB9IGVsc2UgeyBkLmd1dHRlckZpbGxlci5zdHlsZS5kaXNwbGF5ID0gXFxcIlxcXCIgfVxcbn1cXG5cXG52YXIgc2Nyb2xsYmFyTW9kZWwgPSB7XFxcIm5hdGl2ZVxcXCI6IE5hdGl2ZVNjcm9sbGJhcnMsIFxcXCJudWxsXFxcIjogTnVsbFNjcm9sbGJhcnN9XFxuXFxuZnVuY3Rpb24gaW5pdFNjcm9sbGJhcnMoY20pIHtcXG4gIGlmIChjbS5kaXNwbGF5LnNjcm9sbGJhcnMpIHtcXG4gICAgY20uZGlzcGxheS5zY3JvbGxiYXJzLmNsZWFyKClcXG4gICAgaWYgKGNtLmRpc3BsYXkuc2Nyb2xsYmFycy5hZGRDbGFzcylcXG4gICAgICB7IHJtQ2xhc3MoY20uZGlzcGxheS53cmFwcGVyLCBjbS5kaXNwbGF5LnNjcm9sbGJhcnMuYWRkQ2xhc3MpIH1cXG4gIH1cXG5cXG4gIGNtLmRpc3BsYXkuc2Nyb2xsYmFycyA9IG5ldyBzY3JvbGxiYXJNb2RlbFtjbS5vcHRpb25zLnNjcm9sbGJhclN0eWxlXShmdW5jdGlvbiAobm9kZSkge1xcbiAgICBjbS5kaXNwbGF5LndyYXBwZXIuaW5zZXJ0QmVmb3JlKG5vZGUsIGNtLmRpc3BsYXkuc2Nyb2xsYmFyRmlsbGVyKVxcbiAgICAvLyBQcmV2ZW50IGNsaWNrcyBpbiB0aGUgc2Nyb2xsYmFycyBmcm9tIGtpbGxpbmcgZm9jdXNcXG4gICAgb24obm9kZSwgXFxcIm1vdXNlZG93blxcXCIsIGZ1bmN0aW9uICgpIHtcXG4gICAgICBpZiAoY20uc3RhdGUuZm9jdXNlZCkgeyBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNtLmRpc3BsYXkuaW5wdXQuZm9jdXMoKTsgfSwgMCkgfVxcbiAgICB9KVxcbiAgICBub2RlLnNldEF0dHJpYnV0ZShcXFwiY20tbm90LWNvbnRlbnRcXFwiLCBcXFwidHJ1ZVxcXCIpXFxuICB9LCBmdW5jdGlvbiAocG9zLCBheGlzKSB7XFxuICAgIGlmIChheGlzID09IFxcXCJob3Jpem9udGFsXFxcIikgeyBzZXRTY3JvbGxMZWZ0KGNtLCBwb3MpIH1cXG4gICAgZWxzZSB7IHNldFNjcm9sbFRvcChjbSwgcG9zKSB9XFxuICB9LCBjbSlcXG4gIGlmIChjbS5kaXNwbGF5LnNjcm9sbGJhcnMuYWRkQ2xhc3MpXFxuICAgIHsgYWRkQ2xhc3MoY20uZGlzcGxheS53cmFwcGVyLCBjbS5kaXNwbGF5LnNjcm9sbGJhcnMuYWRkQ2xhc3MpIH1cXG59XFxuXFxuLy8gU0NST0xMSU5HIFRISU5HUyBJTlRPIFZJRVdcXG5cXG4vLyBJZiBhbiBlZGl0b3Igc2l0cyBvbiB0aGUgdG9wIG9yIGJvdHRvbSBvZiB0aGUgd2luZG93LCBwYXJ0aWFsbHlcXG4vLyBzY3JvbGxlZCBvdXQgb2YgdmlldywgdGhpcyBlbnN1cmVzIHRoYXQgdGhlIGN1cnNvciBpcyB2aXNpYmxlLlxcbmZ1bmN0aW9uIG1heWJlU2Nyb2xsV2luZG93KGNtLCBjb29yZHMpIHtcXG4gIGlmIChzaWduYWxET01FdmVudChjbSwgXFxcInNjcm9sbEN1cnNvckludG9WaWV3XFxcIikpIHsgcmV0dXJuIH1cXG5cXG4gIHZhciBkaXNwbGF5ID0gY20uZGlzcGxheSwgYm94ID0gZGlzcGxheS5zaXplci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgZG9TY3JvbGwgPSBudWxsXFxuICBpZiAoY29vcmRzLnRvcCArIGJveC50b3AgPCAwKSB7IGRvU2Nyb2xsID0gdHJ1ZSB9XFxuICBlbHNlIGlmIChjb29yZHMuYm90dG9tICsgYm94LnRvcCA+ICh3aW5kb3cuaW5uZXJIZWlnaHQgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodCkpIHsgZG9TY3JvbGwgPSBmYWxzZSB9XFxuICBpZiAoZG9TY3JvbGwgIT0gbnVsbCAmJiAhcGhhbnRvbSkge1xcbiAgICB2YXIgc2Nyb2xsTm9kZSA9IGVsdChcXFwiZGl2XFxcIiwgXFxcIlxcXFx1MjAwYlxcXCIsIG51bGwsIChcXFwicG9zaXRpb246IGFic29sdXRlO1xcXFxuICAgICAgICAgICAgICAgICAgICAgICAgIHRvcDogXFxcIiArIChjb29yZHMudG9wIC0gZGlzcGxheS52aWV3T2Zmc2V0IC0gcGFkZGluZ1RvcChjbS5kaXNwbGF5KSkgKyBcXFwicHg7XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBcXFwiICsgKGNvb3Jkcy5ib3R0b20gLSBjb29yZHMudG9wICsgc2Nyb2xsR2FwKGNtKSArIGRpc3BsYXkuYmFySGVpZ2h0KSArIFxcXCJweDtcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICBsZWZ0OiBcXFwiICsgKGNvb3Jkcy5sZWZ0KSArIFxcXCJweDsgd2lkdGg6IDJweDtcXFwiKSlcXG4gICAgY20uZGlzcGxheS5saW5lU3BhY2UuYXBwZW5kQ2hpbGQoc2Nyb2xsTm9kZSlcXG4gICAgc2Nyb2xsTm9kZS5zY3JvbGxJbnRvVmlldyhkb1Njcm9sbClcXG4gICAgY20uZGlzcGxheS5saW5lU3BhY2UucmVtb3ZlQ2hpbGQoc2Nyb2xsTm9kZSlcXG4gIH1cXG59XFxuXFxuLy8gU2Nyb2xsIGEgZ2l2ZW4gcG9zaXRpb24gaW50byB2aWV3IChpbW1lZGlhdGVseSksIHZlcmlmeWluZyB0aGF0XFxuLy8gaXQgYWN0dWFsbHkgYmVjYW1lIHZpc2libGUgKGFzIGxpbmUgaGVpZ2h0cyBhcmUgYWNjdXJhdGVseVxcbi8vIG1lYXN1cmVkLCB0aGUgcG9zaXRpb24gb2Ygc29tZXRoaW5nIG1heSAnZHJpZnQnIGR1cmluZyBkcmF3aW5nKS5cXG5mdW5jdGlvbiBzY3JvbGxQb3NJbnRvVmlldyhjbSwgcG9zLCBlbmQsIG1hcmdpbikge1xcbiAgaWYgKG1hcmdpbiA9PSBudWxsKSB7IG1hcmdpbiA9IDAgfVxcbiAgdmFyIGNvb3Jkc1xcbiAgZm9yICh2YXIgbGltaXQgPSAwOyBsaW1pdCA8IDU7IGxpbWl0KyspIHtcXG4gICAgdmFyIGNoYW5nZWQgPSBmYWxzZVxcbiAgICBjb29yZHMgPSBjdXJzb3JDb29yZHMoY20sIHBvcylcXG4gICAgdmFyIGVuZENvb3JkcyA9ICFlbmQgfHwgZW5kID09IHBvcyA/IGNvb3JkcyA6IGN1cnNvckNvb3JkcyhjbSwgZW5kKVxcbiAgICB2YXIgc2Nyb2xsUG9zID0gY2FsY3VsYXRlU2Nyb2xsUG9zKGNtLCBNYXRoLm1pbihjb29yZHMubGVmdCwgZW5kQ29vcmRzLmxlZnQpLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1hdGgubWluKGNvb3Jkcy50b3AsIGVuZENvb3Jkcy50b3ApIC0gbWFyZ2luLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1hdGgubWF4KGNvb3Jkcy5sZWZ0LCBlbmRDb29yZHMubGVmdCksXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5tYXgoY29vcmRzLmJvdHRvbSwgZW5kQ29vcmRzLmJvdHRvbSkgKyBtYXJnaW4pXFxuICAgIHZhciBzdGFydFRvcCA9IGNtLmRvYy5zY3JvbGxUb3AsIHN0YXJ0TGVmdCA9IGNtLmRvYy5zY3JvbGxMZWZ0XFxuICAgIGlmIChzY3JvbGxQb3Muc2Nyb2xsVG9wICE9IG51bGwpIHtcXG4gICAgICBzZXRTY3JvbGxUb3AoY20sIHNjcm9sbFBvcy5zY3JvbGxUb3ApXFxuICAgICAgaWYgKE1hdGguYWJzKGNtLmRvYy5zY3JvbGxUb3AgLSBzdGFydFRvcCkgPiAxKSB7IGNoYW5nZWQgPSB0cnVlIH1cXG4gICAgfVxcbiAgICBpZiAoc2Nyb2xsUG9zLnNjcm9sbExlZnQgIT0gbnVsbCkge1xcbiAgICAgIHNldFNjcm9sbExlZnQoY20sIHNjcm9sbFBvcy5zY3JvbGxMZWZ0KVxcbiAgICAgIGlmIChNYXRoLmFicyhjbS5kb2Muc2Nyb2xsTGVmdCAtIHN0YXJ0TGVmdCkgPiAxKSB7IGNoYW5nZWQgPSB0cnVlIH1cXG4gICAgfVxcbiAgICBpZiAoIWNoYW5nZWQpIHsgYnJlYWsgfVxcbiAgfVxcbiAgcmV0dXJuIGNvb3Jkc1xcbn1cXG5cXG4vLyBTY3JvbGwgYSBnaXZlbiBzZXQgb2YgY29vcmRpbmF0ZXMgaW50byB2aWV3IChpbW1lZGlhdGVseSkuXFxuZnVuY3Rpb24gc2Nyb2xsSW50b1ZpZXcoY20sIHgxLCB5MSwgeDIsIHkyKSB7XFxuICB2YXIgc2Nyb2xsUG9zID0gY2FsY3VsYXRlU2Nyb2xsUG9zKGNtLCB4MSwgeTEsIHgyLCB5MilcXG4gIGlmIChzY3JvbGxQb3Muc2Nyb2xsVG9wICE9IG51bGwpIHsgc2V0U2Nyb2xsVG9wKGNtLCBzY3JvbGxQb3Muc2Nyb2xsVG9wKSB9XFxuICBpZiAoc2Nyb2xsUG9zLnNjcm9sbExlZnQgIT0gbnVsbCkgeyBzZXRTY3JvbGxMZWZ0KGNtLCBzY3JvbGxQb3Muc2Nyb2xsTGVmdCkgfVxcbn1cXG5cXG4vLyBDYWxjdWxhdGUgYSBuZXcgc2Nyb2xsIHBvc2l0aW9uIG5lZWRlZCB0byBzY3JvbGwgdGhlIGdpdmVuXFxuLy8gcmVjdGFuZ2xlIGludG8gdmlldy4gUmV0dXJucyBhbiBvYmplY3Qgd2l0aCBzY3JvbGxUb3AgYW5kXFxuLy8gc2Nyb2xsTGVmdCBwcm9wZXJ0aWVzLiBXaGVuIHRoZXNlIGFyZSB1bmRlZmluZWQsIHRoZVxcbi8vIHZlcnRpY2FsL2hvcml6b250YWwgcG9zaXRpb24gZG9lcyBub3QgbmVlZCB0byBiZSBhZGp1c3RlZC5cXG5mdW5jdGlvbiBjYWxjdWxhdGVTY3JvbGxQb3MoY20sIHgxLCB5MSwgeDIsIHkyKSB7XFxuICB2YXIgZGlzcGxheSA9IGNtLmRpc3BsYXksIHNuYXBNYXJnaW4gPSB0ZXh0SGVpZ2h0KGNtLmRpc3BsYXkpXFxuICBpZiAoeTEgPCAwKSB7IHkxID0gMCB9XFxuICB2YXIgc2NyZWVudG9wID0gY20uY3VyT3AgJiYgY20uY3VyT3Auc2Nyb2xsVG9wICE9IG51bGwgPyBjbS5jdXJPcC5zY3JvbGxUb3AgOiBkaXNwbGF5LnNjcm9sbGVyLnNjcm9sbFRvcFxcbiAgdmFyIHNjcmVlbiA9IGRpc3BsYXlIZWlnaHQoY20pLCByZXN1bHQgPSB7fVxcbiAgaWYgKHkyIC0geTEgPiBzY3JlZW4pIHsgeTIgPSB5MSArIHNjcmVlbiB9XFxuICB2YXIgZG9jQm90dG9tID0gY20uZG9jLmhlaWdodCArIHBhZGRpbmdWZXJ0KGRpc3BsYXkpXFxuICB2YXIgYXRUb3AgPSB5MSA8IHNuYXBNYXJnaW4sIGF0Qm90dG9tID0geTIgPiBkb2NCb3R0b20gLSBzbmFwTWFyZ2luXFxuICBpZiAoeTEgPCBzY3JlZW50b3ApIHtcXG4gICAgcmVzdWx0LnNjcm9sbFRvcCA9IGF0VG9wID8gMCA6IHkxXFxuICB9IGVsc2UgaWYgKHkyID4gc2NyZWVudG9wICsgc2NyZWVuKSB7XFxuICAgIHZhciBuZXdUb3AgPSBNYXRoLm1pbih5MSwgKGF0Qm90dG9tID8gZG9jQm90dG9tIDogeTIpIC0gc2NyZWVuKVxcbiAgICBpZiAobmV3VG9wICE9IHNjcmVlbnRvcCkgeyByZXN1bHQuc2Nyb2xsVG9wID0gbmV3VG9wIH1cXG4gIH1cXG5cXG4gIHZhciBzY3JlZW5sZWZ0ID0gY20uY3VyT3AgJiYgY20uY3VyT3Auc2Nyb2xsTGVmdCAhPSBudWxsID8gY20uY3VyT3Auc2Nyb2xsTGVmdCA6IGRpc3BsYXkuc2Nyb2xsZXIuc2Nyb2xsTGVmdFxcbiAgdmFyIHNjcmVlbncgPSBkaXNwbGF5V2lkdGgoY20pIC0gKGNtLm9wdGlvbnMuZml4ZWRHdXR0ZXIgPyBkaXNwbGF5Lmd1dHRlcnMub2Zmc2V0V2lkdGggOiAwKVxcbiAgdmFyIHRvb1dpZGUgPSB4MiAtIHgxID4gc2NyZWVud1xcbiAgaWYgKHRvb1dpZGUpIHsgeDIgPSB4MSArIHNjcmVlbncgfVxcbiAgaWYgKHgxIDwgMTApXFxuICAgIHsgcmVzdWx0LnNjcm9sbExlZnQgPSAwIH1cXG4gIGVsc2UgaWYgKHgxIDwgc2NyZWVubGVmdClcXG4gICAgeyByZXN1bHQuc2Nyb2xsTGVmdCA9IE1hdGgubWF4KDAsIHgxIC0gKHRvb1dpZGUgPyAwIDogMTApKSB9XFxuICBlbHNlIGlmICh4MiA+IHNjcmVlbncgKyBzY3JlZW5sZWZ0IC0gMylcXG4gICAgeyByZXN1bHQuc2Nyb2xsTGVmdCA9IHgyICsgKHRvb1dpZGUgPyAwIDogMTApIC0gc2NyZWVudyB9XFxuICByZXR1cm4gcmVzdWx0XFxufVxcblxcbi8vIFN0b3JlIGEgcmVsYXRpdmUgYWRqdXN0bWVudCB0byB0aGUgc2Nyb2xsIHBvc2l0aW9uIGluIHRoZSBjdXJyZW50XFxuLy8gb3BlcmF0aW9uICh0byBiZSBhcHBsaWVkIHdoZW4gdGhlIG9wZXJhdGlvbiBmaW5pc2hlcykuXFxuZnVuY3Rpb24gYWRkVG9TY3JvbGxQb3MoY20sIGxlZnQsIHRvcCkge1xcbiAgaWYgKGxlZnQgIT0gbnVsbCB8fCB0b3AgIT0gbnVsbCkgeyByZXNvbHZlU2Nyb2xsVG9Qb3MoY20pIH1cXG4gIGlmIChsZWZ0ICE9IG51bGwpXFxuICAgIHsgY20uY3VyT3Auc2Nyb2xsTGVmdCA9IChjbS5jdXJPcC5zY3JvbGxMZWZ0ID09IG51bGwgPyBjbS5kb2Muc2Nyb2xsTGVmdCA6IGNtLmN1ck9wLnNjcm9sbExlZnQpICsgbGVmdCB9XFxuICBpZiAodG9wICE9IG51bGwpXFxuICAgIHsgY20uY3VyT3Auc2Nyb2xsVG9wID0gKGNtLmN1ck9wLnNjcm9sbFRvcCA9PSBudWxsID8gY20uZG9jLnNjcm9sbFRvcCA6IGNtLmN1ck9wLnNjcm9sbFRvcCkgKyB0b3AgfVxcbn1cXG5cXG4vLyBNYWtlIHN1cmUgdGhhdCBhdCB0aGUgZW5kIG9mIHRoZSBvcGVyYXRpb24gdGhlIGN1cnJlbnQgY3Vyc29yIGlzXFxuLy8gc2hvd24uXFxuZnVuY3Rpb24gZW5zdXJlQ3Vyc29yVmlzaWJsZShjbSkge1xcbiAgcmVzb2x2ZVNjcm9sbFRvUG9zKGNtKVxcbiAgdmFyIGN1ciA9IGNtLmdldEN1cnNvcigpLCBmcm9tID0gY3VyLCB0byA9IGN1clxcbiAgaWYgKCFjbS5vcHRpb25zLmxpbmVXcmFwcGluZykge1xcbiAgICBmcm9tID0gY3VyLmNoID8gUG9zKGN1ci5saW5lLCBjdXIuY2ggLSAxKSA6IGN1clxcbiAgICB0byA9IFBvcyhjdXIubGluZSwgY3VyLmNoICsgMSlcXG4gIH1cXG4gIGNtLmN1ck9wLnNjcm9sbFRvUG9zID0ge2Zyb206IGZyb20sIHRvOiB0bywgbWFyZ2luOiBjbS5vcHRpb25zLmN1cnNvclNjcm9sbE1hcmdpbiwgaXNDdXJzb3I6IHRydWV9XFxufVxcblxcbi8vIFdoZW4gYW4gb3BlcmF0aW9uIGhhcyBpdHMgc2Nyb2xsVG9Qb3MgcHJvcGVydHkgc2V0LCBhbmQgYW5vdGhlclxcbi8vIHNjcm9sbCBhY3Rpb24gaXMgYXBwbGllZCBiZWZvcmUgdGhlIGVuZCBvZiB0aGUgb3BlcmF0aW9uLCB0aGlzXFxuLy8gJ3NpbXVsYXRlcycgc2Nyb2xsaW5nIHRoYXQgcG9zaXRpb24gaW50byB2aWV3IGluIGEgY2hlYXAgd2F5LCBzb1xcbi8vIHRoYXQgdGhlIGVmZmVjdCBvZiBpbnRlcm1lZGlhdGUgc2Nyb2xsIGNvbW1hbmRzIGlzIG5vdCBpZ25vcmVkLlxcbmZ1bmN0aW9uIHJlc29sdmVTY3JvbGxUb1BvcyhjbSkge1xcbiAgdmFyIHJhbmdlID0gY20uY3VyT3Auc2Nyb2xsVG9Qb3NcXG4gIGlmIChyYW5nZSkge1xcbiAgICBjbS5jdXJPcC5zY3JvbGxUb1BvcyA9IG51bGxcXG4gICAgdmFyIGZyb20gPSBlc3RpbWF0ZUNvb3JkcyhjbSwgcmFuZ2UuZnJvbSksIHRvID0gZXN0aW1hdGVDb29yZHMoY20sIHJhbmdlLnRvKVxcbiAgICB2YXIgc1BvcyA9IGNhbGN1bGF0ZVNjcm9sbFBvcyhjbSwgTWF0aC5taW4oZnJvbS5sZWZ0LCB0by5sZWZ0KSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5taW4oZnJvbS50b3AsIHRvLnRvcCkgLSByYW5nZS5tYXJnaW4sXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1hdGgubWF4KGZyb20ucmlnaHQsIHRvLnJpZ2h0KSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5tYXgoZnJvbS5ib3R0b20sIHRvLmJvdHRvbSkgKyByYW5nZS5tYXJnaW4pXFxuICAgIGNtLnNjcm9sbFRvKHNQb3Muc2Nyb2xsTGVmdCwgc1Bvcy5zY3JvbGxUb3ApXFxuICB9XFxufVxcblxcbi8vIE9wZXJhdGlvbnMgYXJlIHVzZWQgdG8gd3JhcCBhIHNlcmllcyBvZiBjaGFuZ2VzIHRvIHRoZSBlZGl0b3JcXG4vLyBzdGF0ZSBpbiBzdWNoIGEgd2F5IHRoYXQgZWFjaCBjaGFuZ2Ugd29uJ3QgaGF2ZSB0byB1cGRhdGUgdGhlXFxuLy8gY3Vyc29yIGFuZCBkaXNwbGF5ICh3aGljaCB3b3VsZCBiZSBhd2t3YXJkLCBzbG93LCBhbmRcXG4vLyBlcnJvci1wcm9uZSkuIEluc3RlYWQsIGRpc3BsYXkgdXBkYXRlcyBhcmUgYmF0Y2hlZCBhbmQgdGhlbiBhbGxcXG4vLyBjb21iaW5lZCBhbmQgZXhlY3V0ZWQgYXQgb25jZS5cXG5cXG52YXIgbmV4dE9wSWQgPSAwXFxuLy8gU3RhcnQgYSBuZXcgb3BlcmF0aW9uLlxcbmZ1bmN0aW9uIHN0YXJ0T3BlcmF0aW9uKGNtKSB7XFxuICBjbS5jdXJPcCA9IHtcXG4gICAgY206IGNtLFxcbiAgICB2aWV3Q2hhbmdlZDogZmFsc2UsICAgICAgLy8gRmxhZyB0aGF0IGluZGljYXRlcyB0aGF0IGxpbmVzIG1pZ2h0IG5lZWQgdG8gYmUgcmVkcmF3blxcbiAgICBzdGFydEhlaWdodDogY20uZG9jLmhlaWdodCwgLy8gVXNlZCB0byBkZXRlY3QgbmVlZCB0byB1cGRhdGUgc2Nyb2xsYmFyXFxuICAgIGZvcmNlVXBkYXRlOiBmYWxzZSwgICAgICAvLyBVc2VkIHRvIGZvcmNlIGEgcmVkcmF3XFxuICAgIHVwZGF0ZUlucHV0OiBudWxsLCAgICAgICAvLyBXaGV0aGVyIHRvIHJlc2V0IHRoZSBpbnB1dCB0ZXh0YXJlYVxcbiAgICB0eXBpbmc6IGZhbHNlLCAgICAgICAgICAgLy8gV2hldGhlciB0aGlzIHJlc2V0IHNob3VsZCBiZSBjYXJlZnVsIHRvIGxlYXZlIGV4aXN0aW5nIHRleHQgKGZvciBjb21wb3NpdGluZylcXG4gICAgY2hhbmdlT2JqczogbnVsbCwgICAgICAgIC8vIEFjY3VtdWxhdGVkIGNoYW5nZXMsIGZvciBmaXJpbmcgY2hhbmdlIGV2ZW50c1xcbiAgICBjdXJzb3JBY3Rpdml0eUhhbmRsZXJzOiBudWxsLCAvLyBTZXQgb2YgaGFuZGxlcnMgdG8gZmlyZSBjdXJzb3JBY3Rpdml0eSBvblxcbiAgICBjdXJzb3JBY3Rpdml0eUNhbGxlZDogMCwgLy8gVHJhY2tzIHdoaWNoIGN1cnNvckFjdGl2aXR5IGhhbmRsZXJzIGhhdmUgYmVlbiBjYWxsZWQgYWxyZWFkeVxcbiAgICBzZWxlY3Rpb25DaGFuZ2VkOiBmYWxzZSwgLy8gV2hldGhlciB0aGUgc2VsZWN0aW9uIG5lZWRzIHRvIGJlIHJlZHJhd25cXG4gICAgdXBkYXRlTWF4TGluZTogZmFsc2UsICAgIC8vIFNldCB3aGVuIHRoZSB3aWRlc3QgbGluZSBuZWVkcyB0byBiZSBkZXRlcm1pbmVkIGFuZXdcXG4gICAgc2Nyb2xsTGVmdDogbnVsbCwgc2Nyb2xsVG9wOiBudWxsLCAvLyBJbnRlcm1lZGlhdGUgc2Nyb2xsIHBvc2l0aW9uLCBub3QgcHVzaGVkIHRvIERPTSB5ZXRcXG4gICAgc2Nyb2xsVG9Qb3M6IG51bGwsICAgICAgIC8vIFVzZWQgdG8gc2Nyb2xsIHRvIGEgc3BlY2lmaWMgcG9zaXRpb25cXG4gICAgZm9jdXM6IGZhbHNlLFxcbiAgICBpZDogKytuZXh0T3BJZCAgICAgICAgICAgLy8gVW5pcXVlIElEXFxuICB9XFxuICBwdXNoT3BlcmF0aW9uKGNtLmN1ck9wKVxcbn1cXG5cXG4vLyBGaW5pc2ggYW4gb3BlcmF0aW9uLCB1cGRhdGluZyB0aGUgZGlzcGxheSBhbmQgc2lnbmFsbGluZyBkZWxheWVkIGV2ZW50c1xcbmZ1bmN0aW9uIGVuZE9wZXJhdGlvbihjbSkge1xcbiAgdmFyIG9wID0gY20uY3VyT3BcXG4gIGZpbmlzaE9wZXJhdGlvbihvcCwgZnVuY3Rpb24gKGdyb3VwKSB7XFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ3JvdXAub3BzLmxlbmd0aDsgaSsrKVxcbiAgICAgIHsgZ3JvdXAub3BzW2ldLmNtLmN1ck9wID0gbnVsbCB9XFxuICAgIGVuZE9wZXJhdGlvbnMoZ3JvdXApXFxuICB9KVxcbn1cXG5cXG4vLyBUaGUgRE9NIHVwZGF0ZXMgZG9uZSB3aGVuIGFuIG9wZXJhdGlvbiBmaW5pc2hlcyBhcmUgYmF0Y2hlZCBzb1xcbi8vIHRoYXQgdGhlIG1pbmltdW0gbnVtYmVyIG9mIHJlbGF5b3V0cyBhcmUgcmVxdWlyZWQuXFxuZnVuY3Rpb24gZW5kT3BlcmF0aW9ucyhncm91cCkge1xcbiAgdmFyIG9wcyA9IGdyb3VwLm9wc1xcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcHMubGVuZ3RoOyBpKyspIC8vIFJlYWQgRE9NXFxuICAgIHsgZW5kT3BlcmF0aW9uX1IxKG9wc1tpXSkgfVxcbiAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgb3BzLmxlbmd0aDsgaSQxKyspIC8vIFdyaXRlIERPTSAobWF5YmUpXFxuICAgIHsgZW5kT3BlcmF0aW9uX1cxKG9wc1tpJDFdKSB9XFxuICBmb3IgKHZhciBpJDIgPSAwOyBpJDIgPCBvcHMubGVuZ3RoOyBpJDIrKykgLy8gUmVhZCBET01cXG4gICAgeyBlbmRPcGVyYXRpb25fUjIob3BzW2kkMl0pIH1cXG4gIGZvciAodmFyIGkkMyA9IDA7IGkkMyA8IG9wcy5sZW5ndGg7IGkkMysrKSAvLyBXcml0ZSBET00gKG1heWJlKVxcbiAgICB7IGVuZE9wZXJhdGlvbl9XMihvcHNbaSQzXSkgfVxcbiAgZm9yICh2YXIgaSQ0ID0gMDsgaSQ0IDwgb3BzLmxlbmd0aDsgaSQ0KyspIC8vIFJlYWQgRE9NXFxuICAgIHsgZW5kT3BlcmF0aW9uX2ZpbmlzaChvcHNbaSQ0XSkgfVxcbn1cXG5cXG5mdW5jdGlvbiBlbmRPcGVyYXRpb25fUjEob3ApIHtcXG4gIHZhciBjbSA9IG9wLmNtLCBkaXNwbGF5ID0gY20uZGlzcGxheVxcbiAgbWF5YmVDbGlwU2Nyb2xsYmFycyhjbSlcXG4gIGlmIChvcC51cGRhdGVNYXhMaW5lKSB7IGZpbmRNYXhMaW5lKGNtKSB9XFxuXFxuICBvcC5tdXN0VXBkYXRlID0gb3Audmlld0NoYW5nZWQgfHwgb3AuZm9yY2VVcGRhdGUgfHwgb3Auc2Nyb2xsVG9wICE9IG51bGwgfHxcXG4gICAgb3Auc2Nyb2xsVG9Qb3MgJiYgKG9wLnNjcm9sbFRvUG9zLmZyb20ubGluZSA8IGRpc3BsYXkudmlld0Zyb20gfHxcXG4gICAgICAgICAgICAgICAgICAgICAgIG9wLnNjcm9sbFRvUG9zLnRvLmxpbmUgPj0gZGlzcGxheS52aWV3VG8pIHx8XFxuICAgIGRpc3BsYXkubWF4TGluZUNoYW5nZWQgJiYgY20ub3B0aW9ucy5saW5lV3JhcHBpbmdcXG4gIG9wLnVwZGF0ZSA9IG9wLm11c3RVcGRhdGUgJiZcXG4gICAgbmV3IERpc3BsYXlVcGRhdGUoY20sIG9wLm11c3RVcGRhdGUgJiYge3RvcDogb3Auc2Nyb2xsVG9wLCBlbnN1cmU6IG9wLnNjcm9sbFRvUG9zfSwgb3AuZm9yY2VVcGRhdGUpXFxufVxcblxcbmZ1bmN0aW9uIGVuZE9wZXJhdGlvbl9XMShvcCkge1xcbiAgb3AudXBkYXRlZERpc3BsYXkgPSBvcC5tdXN0VXBkYXRlICYmIHVwZGF0ZURpc3BsYXlJZk5lZWRlZChvcC5jbSwgb3AudXBkYXRlKVxcbn1cXG5cXG5mdW5jdGlvbiBlbmRPcGVyYXRpb25fUjIob3ApIHtcXG4gIHZhciBjbSA9IG9wLmNtLCBkaXNwbGF5ID0gY20uZGlzcGxheVxcbiAgaWYgKG9wLnVwZGF0ZWREaXNwbGF5KSB7IHVwZGF0ZUhlaWdodHNJblZpZXdwb3J0KGNtKSB9XFxuXFxuICBvcC5iYXJNZWFzdXJlID0gbWVhc3VyZUZvclNjcm9sbGJhcnMoY20pXFxuXFxuICAvLyBJZiB0aGUgbWF4IGxpbmUgY2hhbmdlZCBzaW5jZSBpdCB3YXMgbGFzdCBtZWFzdXJlZCwgbWVhc3VyZSBpdCxcXG4gIC8vIGFuZCBlbnN1cmUgdGhlIGRvY3VtZW50J3Mgd2lkdGggbWF0Y2hlcyBpdC5cXG4gIC8vIHVwZGF0ZURpc3BsYXlfVzIgd2lsbCB1c2UgdGhlc2UgcHJvcGVydGllcyB0byBkbyB0aGUgYWN0dWFsIHJlc2l6aW5nXFxuICBpZiAoZGlzcGxheS5tYXhMaW5lQ2hhbmdlZCAmJiAhY20ub3B0aW9ucy5saW5lV3JhcHBpbmcpIHtcXG4gICAgb3AuYWRqdXN0V2lkdGhUbyA9IG1lYXN1cmVDaGFyKGNtLCBkaXNwbGF5Lm1heExpbmUsIGRpc3BsYXkubWF4TGluZS50ZXh0Lmxlbmd0aCkubGVmdCArIDNcXG4gICAgY20uZGlzcGxheS5zaXplcldpZHRoID0gb3AuYWRqdXN0V2lkdGhUb1xcbiAgICBvcC5iYXJNZWFzdXJlLnNjcm9sbFdpZHRoID1cXG4gICAgICBNYXRoLm1heChkaXNwbGF5LnNjcm9sbGVyLmNsaWVudFdpZHRoLCBkaXNwbGF5LnNpemVyLm9mZnNldExlZnQgKyBvcC5hZGp1c3RXaWR0aFRvICsgc2Nyb2xsR2FwKGNtKSArIGNtLmRpc3BsYXkuYmFyV2lkdGgpXFxuICAgIG9wLm1heFNjcm9sbExlZnQgPSBNYXRoLm1heCgwLCBkaXNwbGF5LnNpemVyLm9mZnNldExlZnQgKyBvcC5hZGp1c3RXaWR0aFRvIC0gZGlzcGxheVdpZHRoKGNtKSlcXG4gIH1cXG5cXG4gIGlmIChvcC51cGRhdGVkRGlzcGxheSB8fCBvcC5zZWxlY3Rpb25DaGFuZ2VkKVxcbiAgICB7IG9wLnByZXBhcmVkU2VsZWN0aW9uID0gZGlzcGxheS5pbnB1dC5wcmVwYXJlU2VsZWN0aW9uKG9wLmZvY3VzKSB9XFxufVxcblxcbmZ1bmN0aW9uIGVuZE9wZXJhdGlvbl9XMihvcCkge1xcbiAgdmFyIGNtID0gb3AuY21cXG5cXG4gIGlmIChvcC5hZGp1c3RXaWR0aFRvICE9IG51bGwpIHtcXG4gICAgY20uZGlzcGxheS5zaXplci5zdHlsZS5taW5XaWR0aCA9IG9wLmFkanVzdFdpZHRoVG8gKyBcXFwicHhcXFwiXFxuICAgIGlmIChvcC5tYXhTY3JvbGxMZWZ0IDwgY20uZG9jLnNjcm9sbExlZnQpXFxuICAgICAgeyBzZXRTY3JvbGxMZWZ0KGNtLCBNYXRoLm1pbihjbS5kaXNwbGF5LnNjcm9sbGVyLnNjcm9sbExlZnQsIG9wLm1heFNjcm9sbExlZnQpLCB0cnVlKSB9XFxuICAgIGNtLmRpc3BsYXkubWF4TGluZUNoYW5nZWQgPSBmYWxzZVxcbiAgfVxcblxcbiAgdmFyIHRha2VGb2N1cyA9IG9wLmZvY3VzICYmIG9wLmZvY3VzID09IGFjdGl2ZUVsdCgpICYmICghZG9jdW1lbnQuaGFzRm9jdXMgfHwgZG9jdW1lbnQuaGFzRm9jdXMoKSlcXG4gIGlmIChvcC5wcmVwYXJlZFNlbGVjdGlvbilcXG4gICAgeyBjbS5kaXNwbGF5LmlucHV0LnNob3dTZWxlY3Rpb24ob3AucHJlcGFyZWRTZWxlY3Rpb24sIHRha2VGb2N1cykgfVxcbiAgaWYgKG9wLnVwZGF0ZWREaXNwbGF5IHx8IG9wLnN0YXJ0SGVpZ2h0ICE9IGNtLmRvYy5oZWlnaHQpXFxuICAgIHsgdXBkYXRlU2Nyb2xsYmFycyhjbSwgb3AuYmFyTWVhc3VyZSkgfVxcbiAgaWYgKG9wLnVwZGF0ZWREaXNwbGF5KVxcbiAgICB7IHNldERvY3VtZW50SGVpZ2h0KGNtLCBvcC5iYXJNZWFzdXJlKSB9XFxuXFxuICBpZiAob3Auc2VsZWN0aW9uQ2hhbmdlZCkgeyByZXN0YXJ0QmxpbmsoY20pIH1cXG5cXG4gIGlmIChjbS5zdGF0ZS5mb2N1c2VkICYmIG9wLnVwZGF0ZUlucHV0KVxcbiAgICB7IGNtLmRpc3BsYXkuaW5wdXQucmVzZXQob3AudHlwaW5nKSB9XFxuICBpZiAodGFrZUZvY3VzKSB7IGVuc3VyZUZvY3VzKG9wLmNtKSB9XFxufVxcblxcbmZ1bmN0aW9uIGVuZE9wZXJhdGlvbl9maW5pc2gob3ApIHtcXG4gIHZhciBjbSA9IG9wLmNtLCBkaXNwbGF5ID0gY20uZGlzcGxheSwgZG9jID0gY20uZG9jXFxuXFxuICBpZiAob3AudXBkYXRlZERpc3BsYXkpIHsgcG9zdFVwZGF0ZURpc3BsYXkoY20sIG9wLnVwZGF0ZSkgfVxcblxcbiAgLy8gQWJvcnQgbW91c2Ugd2hlZWwgZGVsdGEgbWVhc3VyZW1lbnQsIHdoZW4gc2Nyb2xsaW5nIGV4cGxpY2l0bHlcXG4gIGlmIChkaXNwbGF5LndoZWVsU3RhcnRYICE9IG51bGwgJiYgKG9wLnNjcm9sbFRvcCAhPSBudWxsIHx8IG9wLnNjcm9sbExlZnQgIT0gbnVsbCB8fCBvcC5zY3JvbGxUb1BvcykpXFxuICAgIHsgZGlzcGxheS53aGVlbFN0YXJ0WCA9IGRpc3BsYXkud2hlZWxTdGFydFkgPSBudWxsIH1cXG5cXG4gIC8vIFByb3BhZ2F0ZSB0aGUgc2Nyb2xsIHBvc2l0aW9uIHRvIHRoZSBhY3R1YWwgRE9NIHNjcm9sbGVyXFxuICBpZiAob3Auc2Nyb2xsVG9wICE9IG51bGwgJiYgKGRpc3BsYXkuc2Nyb2xsZXIuc2Nyb2xsVG9wICE9IG9wLnNjcm9sbFRvcCB8fCBvcC5mb3JjZVNjcm9sbCkpIHtcXG4gICAgZG9jLnNjcm9sbFRvcCA9IE1hdGgubWF4KDAsIE1hdGgubWluKGRpc3BsYXkuc2Nyb2xsZXIuc2Nyb2xsSGVpZ2h0IC0gZGlzcGxheS5zY3JvbGxlci5jbGllbnRIZWlnaHQsIG9wLnNjcm9sbFRvcCkpXFxuICAgIGRpc3BsYXkuc2Nyb2xsYmFycy5zZXRTY3JvbGxUb3AoZG9jLnNjcm9sbFRvcClcXG4gICAgZGlzcGxheS5zY3JvbGxlci5zY3JvbGxUb3AgPSBkb2Muc2Nyb2xsVG9wXFxuICB9XFxuICBpZiAob3Auc2Nyb2xsTGVmdCAhPSBudWxsICYmIChkaXNwbGF5LnNjcm9sbGVyLnNjcm9sbExlZnQgIT0gb3Auc2Nyb2xsTGVmdCB8fCBvcC5mb3JjZVNjcm9sbCkpIHtcXG4gICAgZG9jLnNjcm9sbExlZnQgPSBNYXRoLm1heCgwLCBNYXRoLm1pbihkaXNwbGF5LnNjcm9sbGVyLnNjcm9sbFdpZHRoIC0gZGlzcGxheS5zY3JvbGxlci5jbGllbnRXaWR0aCwgb3Auc2Nyb2xsTGVmdCkpXFxuICAgIGRpc3BsYXkuc2Nyb2xsYmFycy5zZXRTY3JvbGxMZWZ0KGRvYy5zY3JvbGxMZWZ0KVxcbiAgICBkaXNwbGF5LnNjcm9sbGVyLnNjcm9sbExlZnQgPSBkb2Muc2Nyb2xsTGVmdFxcbiAgICBhbGlnbkhvcml6b250YWxseShjbSlcXG4gIH1cXG4gIC8vIElmIHdlIG5lZWQgdG8gc2Nyb2xsIGEgc3BlY2lmaWMgcG9zaXRpb24gaW50byB2aWV3LCBkbyBzby5cXG4gIGlmIChvcC5zY3JvbGxUb1Bvcykge1xcbiAgICB2YXIgY29vcmRzID0gc2Nyb2xsUG9zSW50b1ZpZXcoY20sIGNsaXBQb3MoZG9jLCBvcC5zY3JvbGxUb1Bvcy5mcm9tKSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsaXBQb3MoZG9jLCBvcC5zY3JvbGxUb1Bvcy50byksIG9wLnNjcm9sbFRvUG9zLm1hcmdpbilcXG4gICAgaWYgKG9wLnNjcm9sbFRvUG9zLmlzQ3Vyc29yICYmIGNtLnN0YXRlLmZvY3VzZWQpIHsgbWF5YmVTY3JvbGxXaW5kb3coY20sIGNvb3JkcykgfVxcbiAgfVxcblxcbiAgLy8gRmlyZSBldmVudHMgZm9yIG1hcmtlcnMgdGhhdCBhcmUgaGlkZGVuL3VuaWRkZW4gYnkgZWRpdGluZyBvclxcbiAgLy8gdW5kb2luZ1xcbiAgdmFyIGhpZGRlbiA9IG9wLm1heWJlSGlkZGVuTWFya2VycywgdW5oaWRkZW4gPSBvcC5tYXliZVVuaGlkZGVuTWFya2Vyc1xcbiAgaWYgKGhpZGRlbikgeyBmb3IgKHZhciBpID0gMDsgaSA8IGhpZGRlbi5sZW5ndGg7ICsraSlcXG4gICAgeyBpZiAoIWhpZGRlbltpXS5saW5lcy5sZW5ndGgpIHsgc2lnbmFsKGhpZGRlbltpXSwgXFxcImhpZGVcXFwiKSB9IH0gfVxcbiAgaWYgKHVuaGlkZGVuKSB7IGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IHVuaGlkZGVuLmxlbmd0aDsgKytpJDEpXFxuICAgIHsgaWYgKHVuaGlkZGVuW2kkMV0ubGluZXMubGVuZ3RoKSB7IHNpZ25hbCh1bmhpZGRlbltpJDFdLCBcXFwidW5oaWRlXFxcIikgfSB9IH1cXG5cXG4gIGlmIChkaXNwbGF5LndyYXBwZXIub2Zmc2V0SGVpZ2h0KVxcbiAgICB7IGRvYy5zY3JvbGxUb3AgPSBjbS5kaXNwbGF5LnNjcm9sbGVyLnNjcm9sbFRvcCB9XFxuXFxuICAvLyBGaXJlIGNoYW5nZSBldmVudHMsIGFuZCBkZWxheWVkIGV2ZW50IGhhbmRsZXJzXFxuICBpZiAob3AuY2hhbmdlT2JqcylcXG4gICAgeyBzaWduYWwoY20sIFxcXCJjaGFuZ2VzXFxcIiwgY20sIG9wLmNoYW5nZU9ianMpIH1cXG4gIGlmIChvcC51cGRhdGUpXFxuICAgIHsgb3AudXBkYXRlLmZpbmlzaCgpIH1cXG59XFxuXFxuLy8gUnVuIHRoZSBnaXZlbiBmdW5jdGlvbiBpbiBhbiBvcGVyYXRpb25cXG5mdW5jdGlvbiBydW5Jbk9wKGNtLCBmKSB7XFxuICBpZiAoY20uY3VyT3ApIHsgcmV0dXJuIGYoKSB9XFxuICBzdGFydE9wZXJhdGlvbihjbSlcXG4gIHRyeSB7IHJldHVybiBmKCkgfVxcbiAgZmluYWxseSB7IGVuZE9wZXJhdGlvbihjbSkgfVxcbn1cXG4vLyBXcmFwcyBhIGZ1bmN0aW9uIGluIGFuIG9wZXJhdGlvbi4gUmV0dXJucyB0aGUgd3JhcHBlZCBmdW5jdGlvbi5cXG5mdW5jdGlvbiBvcGVyYXRpb24oY20sIGYpIHtcXG4gIHJldHVybiBmdW5jdGlvbigpIHtcXG4gICAgaWYgKGNtLmN1ck9wKSB7IHJldHVybiBmLmFwcGx5KGNtLCBhcmd1bWVudHMpIH1cXG4gICAgc3RhcnRPcGVyYXRpb24oY20pXFxuICAgIHRyeSB7IHJldHVybiBmLmFwcGx5KGNtLCBhcmd1bWVudHMpIH1cXG4gICAgZmluYWxseSB7IGVuZE9wZXJhdGlvbihjbSkgfVxcbiAgfVxcbn1cXG4vLyBVc2VkIHRvIGFkZCBtZXRob2RzIHRvIGVkaXRvciBhbmQgZG9jIGluc3RhbmNlcywgd3JhcHBpbmcgdGhlbSBpblxcbi8vIG9wZXJhdGlvbnMuXFxuZnVuY3Rpb24gbWV0aG9kT3AoZikge1xcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xcbiAgICBpZiAodGhpcy5jdXJPcCkgeyByZXR1cm4gZi5hcHBseSh0aGlzLCBhcmd1bWVudHMpIH1cXG4gICAgc3RhcnRPcGVyYXRpb24odGhpcylcXG4gICAgdHJ5IHsgcmV0dXJuIGYuYXBwbHkodGhpcywgYXJndW1lbnRzKSB9XFxuICAgIGZpbmFsbHkgeyBlbmRPcGVyYXRpb24odGhpcykgfVxcbiAgfVxcbn1cXG5mdW5jdGlvbiBkb2NNZXRob2RPcChmKSB7XFxuICByZXR1cm4gZnVuY3Rpb24oKSB7XFxuICAgIHZhciBjbSA9IHRoaXMuY21cXG4gICAgaWYgKCFjbSB8fCBjbS5jdXJPcCkgeyByZXR1cm4gZi5hcHBseSh0aGlzLCBhcmd1bWVudHMpIH1cXG4gICAgc3RhcnRPcGVyYXRpb24oY20pXFxuICAgIHRyeSB7IHJldHVybiBmLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfVxcbiAgICBmaW5hbGx5IHsgZW5kT3BlcmF0aW9uKGNtKSB9XFxuICB9XFxufVxcblxcbi8vIFVwZGF0ZXMgdGhlIGRpc3BsYXkudmlldyBkYXRhIHN0cnVjdHVyZSBmb3IgYSBnaXZlbiBjaGFuZ2UgdG8gdGhlXFxuLy8gZG9jdW1lbnQuIEZyb20gYW5kIHRvIGFyZSBpbiBwcmUtY2hhbmdlIGNvb3JkaW5hdGVzLiBMZW5kaWZmIGlzXFxuLy8gdGhlIGFtb3VudCBvZiBsaW5lcyBhZGRlZCBvciBzdWJ0cmFjdGVkIGJ5IHRoZSBjaGFuZ2UuIFRoaXMgaXNcXG4vLyB1c2VkIGZvciBjaGFuZ2VzIHRoYXQgc3BhbiBtdWx0aXBsZSBsaW5lcywgb3IgY2hhbmdlIHRoZSB3YXlcXG4vLyBsaW5lcyBhcmUgZGl2aWRlZCBpbnRvIHZpc3VhbCBsaW5lcy4gcmVnTGluZUNoYW5nZSAoYmVsb3cpXFxuLy8gcmVnaXN0ZXJzIHNpbmdsZS1saW5lIGNoYW5nZXMuXFxuZnVuY3Rpb24gcmVnQ2hhbmdlKGNtLCBmcm9tLCB0bywgbGVuZGlmZikge1xcbiAgaWYgKGZyb20gPT0gbnVsbCkgeyBmcm9tID0gY20uZG9jLmZpcnN0IH1cXG4gIGlmICh0byA9PSBudWxsKSB7IHRvID0gY20uZG9jLmZpcnN0ICsgY20uZG9jLnNpemUgfVxcbiAgaWYgKCFsZW5kaWZmKSB7IGxlbmRpZmYgPSAwIH1cXG5cXG4gIHZhciBkaXNwbGF5ID0gY20uZGlzcGxheVxcbiAgaWYgKGxlbmRpZmYgJiYgdG8gPCBkaXNwbGF5LnZpZXdUbyAmJlxcbiAgICAgIChkaXNwbGF5LnVwZGF0ZUxpbmVOdW1iZXJzID09IG51bGwgfHwgZGlzcGxheS51cGRhdGVMaW5lTnVtYmVycyA+IGZyb20pKVxcbiAgICB7IGRpc3BsYXkudXBkYXRlTGluZU51bWJlcnMgPSBmcm9tIH1cXG5cXG4gIGNtLmN1ck9wLnZpZXdDaGFuZ2VkID0gdHJ1ZVxcblxcbiAgaWYgKGZyb20gPj0gZGlzcGxheS52aWV3VG8pIHsgLy8gQ2hhbmdlIGFmdGVyXFxuICAgIGlmIChzYXdDb2xsYXBzZWRTcGFucyAmJiB2aXN1YWxMaW5lTm8oY20uZG9jLCBmcm9tKSA8IGRpc3BsYXkudmlld1RvKVxcbiAgICAgIHsgcmVzZXRWaWV3KGNtKSB9XFxuICB9IGVsc2UgaWYgKHRvIDw9IGRpc3BsYXkudmlld0Zyb20pIHsgLy8gQ2hhbmdlIGJlZm9yZVxcbiAgICBpZiAoc2F3Q29sbGFwc2VkU3BhbnMgJiYgdmlzdWFsTGluZUVuZE5vKGNtLmRvYywgdG8gKyBsZW5kaWZmKSA+IGRpc3BsYXkudmlld0Zyb20pIHtcXG4gICAgICByZXNldFZpZXcoY20pXFxuICAgIH0gZWxzZSB7XFxuICAgICAgZGlzcGxheS52aWV3RnJvbSArPSBsZW5kaWZmXFxuICAgICAgZGlzcGxheS52aWV3VG8gKz0gbGVuZGlmZlxcbiAgICB9XFxuICB9IGVsc2UgaWYgKGZyb20gPD0gZGlzcGxheS52aWV3RnJvbSAmJiB0byA+PSBkaXNwbGF5LnZpZXdUbykgeyAvLyBGdWxsIG92ZXJsYXBcXG4gICAgcmVzZXRWaWV3KGNtKVxcbiAgfSBlbHNlIGlmIChmcm9tIDw9IGRpc3BsYXkudmlld0Zyb20pIHsgLy8gVG9wIG92ZXJsYXBcXG4gICAgdmFyIGN1dCA9IHZpZXdDdXR0aW5nUG9pbnQoY20sIHRvLCB0byArIGxlbmRpZmYsIDEpXFxuICAgIGlmIChjdXQpIHtcXG4gICAgICBkaXNwbGF5LnZpZXcgPSBkaXNwbGF5LnZpZXcuc2xpY2UoY3V0LmluZGV4KVxcbiAgICAgIGRpc3BsYXkudmlld0Zyb20gPSBjdXQubGluZU5cXG4gICAgICBkaXNwbGF5LnZpZXdUbyArPSBsZW5kaWZmXFxuICAgIH0gZWxzZSB7XFxuICAgICAgcmVzZXRWaWV3KGNtKVxcbiAgICB9XFxuICB9IGVsc2UgaWYgKHRvID49IGRpc3BsYXkudmlld1RvKSB7IC8vIEJvdHRvbSBvdmVybGFwXFxuICAgIHZhciBjdXQkMSA9IHZpZXdDdXR0aW5nUG9pbnQoY20sIGZyb20sIGZyb20sIC0xKVxcbiAgICBpZiAoY3V0JDEpIHtcXG4gICAgICBkaXNwbGF5LnZpZXcgPSBkaXNwbGF5LnZpZXcuc2xpY2UoMCwgY3V0JDEuaW5kZXgpXFxuICAgICAgZGlzcGxheS52aWV3VG8gPSBjdXQkMS5saW5lTlxcbiAgICB9IGVsc2Uge1xcbiAgICAgIHJlc2V0VmlldyhjbSlcXG4gICAgfVxcbiAgfSBlbHNlIHsgLy8gR2FwIGluIHRoZSBtaWRkbGVcXG4gICAgdmFyIGN1dFRvcCA9IHZpZXdDdXR0aW5nUG9pbnQoY20sIGZyb20sIGZyb20sIC0xKVxcbiAgICB2YXIgY3V0Qm90ID0gdmlld0N1dHRpbmdQb2ludChjbSwgdG8sIHRvICsgbGVuZGlmZiwgMSlcXG4gICAgaWYgKGN1dFRvcCAmJiBjdXRCb3QpIHtcXG4gICAgICBkaXNwbGF5LnZpZXcgPSBkaXNwbGF5LnZpZXcuc2xpY2UoMCwgY3V0VG9wLmluZGV4KVxcbiAgICAgICAgLmNvbmNhdChidWlsZFZpZXdBcnJheShjbSwgY3V0VG9wLmxpbmVOLCBjdXRCb3QubGluZU4pKVxcbiAgICAgICAgLmNvbmNhdChkaXNwbGF5LnZpZXcuc2xpY2UoY3V0Qm90LmluZGV4KSlcXG4gICAgICBkaXNwbGF5LnZpZXdUbyArPSBsZW5kaWZmXFxuICAgIH0gZWxzZSB7XFxuICAgICAgcmVzZXRWaWV3KGNtKVxcbiAgICB9XFxuICB9XFxuXFxuICB2YXIgZXh0ID0gZGlzcGxheS5leHRlcm5hbE1lYXN1cmVkXFxuICBpZiAoZXh0KSB7XFxuICAgIGlmICh0byA8IGV4dC5saW5lTilcXG4gICAgICB7IGV4dC5saW5lTiArPSBsZW5kaWZmIH1cXG4gICAgZWxzZSBpZiAoZnJvbSA8IGV4dC5saW5lTiArIGV4dC5zaXplKVxcbiAgICAgIHsgZGlzcGxheS5leHRlcm5hbE1lYXN1cmVkID0gbnVsbCB9XFxuICB9XFxufVxcblxcbi8vIFJlZ2lzdGVyIGEgY2hhbmdlIHRvIGEgc2luZ2xlIGxpbmUuIFR5cGUgbXVzdCBiZSBvbmUgb2YgXFxcInRleHRcXFwiLFxcbi8vIFxcXCJndXR0ZXJcXFwiLCBcXFwiY2xhc3NcXFwiLCBcXFwid2lkZ2V0XFxcIlxcbmZ1bmN0aW9uIHJlZ0xpbmVDaGFuZ2UoY20sIGxpbmUsIHR5cGUpIHtcXG4gIGNtLmN1ck9wLnZpZXdDaGFuZ2VkID0gdHJ1ZVxcbiAgdmFyIGRpc3BsYXkgPSBjbS5kaXNwbGF5LCBleHQgPSBjbS5kaXNwbGF5LmV4dGVybmFsTWVhc3VyZWRcXG4gIGlmIChleHQgJiYgbGluZSA+PSBleHQubGluZU4gJiYgbGluZSA8IGV4dC5saW5lTiArIGV4dC5zaXplKVxcbiAgICB7IGRpc3BsYXkuZXh0ZXJuYWxNZWFzdXJlZCA9IG51bGwgfVxcblxcbiAgaWYgKGxpbmUgPCBkaXNwbGF5LnZpZXdGcm9tIHx8IGxpbmUgPj0gZGlzcGxheS52aWV3VG8pIHsgcmV0dXJuIH1cXG4gIHZhciBsaW5lVmlldyA9IGRpc3BsYXkudmlld1tmaW5kVmlld0luZGV4KGNtLCBsaW5lKV1cXG4gIGlmIChsaW5lVmlldy5ub2RlID09IG51bGwpIHsgcmV0dXJuIH1cXG4gIHZhciBhcnIgPSBsaW5lVmlldy5jaGFuZ2VzIHx8IChsaW5lVmlldy5jaGFuZ2VzID0gW10pXFxuICBpZiAoaW5kZXhPZihhcnIsIHR5cGUpID09IC0xKSB7IGFyci5wdXNoKHR5cGUpIH1cXG59XFxuXFxuLy8gQ2xlYXIgdGhlIHZpZXcuXFxuZnVuY3Rpb24gcmVzZXRWaWV3KGNtKSB7XFxuICBjbS5kaXNwbGF5LnZpZXdGcm9tID0gY20uZGlzcGxheS52aWV3VG8gPSBjbS5kb2MuZmlyc3RcXG4gIGNtLmRpc3BsYXkudmlldyA9IFtdXFxuICBjbS5kaXNwbGF5LnZpZXdPZmZzZXQgPSAwXFxufVxcblxcbmZ1bmN0aW9uIHZpZXdDdXR0aW5nUG9pbnQoY20sIG9sZE4sIG5ld04sIGRpcikge1xcbiAgdmFyIGluZGV4ID0gZmluZFZpZXdJbmRleChjbSwgb2xkTiksIGRpZmYsIHZpZXcgPSBjbS5kaXNwbGF5LnZpZXdcXG4gIGlmICghc2F3Q29sbGFwc2VkU3BhbnMgfHwgbmV3TiA9PSBjbS5kb2MuZmlyc3QgKyBjbS5kb2Muc2l6ZSlcXG4gICAgeyByZXR1cm4ge2luZGV4OiBpbmRleCwgbGluZU46IG5ld059IH1cXG4gIHZhciBuID0gY20uZGlzcGxheS52aWV3RnJvbVxcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbmRleDsgaSsrKVxcbiAgICB7IG4gKz0gdmlld1tpXS5zaXplIH1cXG4gIGlmIChuICE9IG9sZE4pIHtcXG4gICAgaWYgKGRpciA+IDApIHtcXG4gICAgICBpZiAoaW5kZXggPT0gdmlldy5sZW5ndGggLSAxKSB7IHJldHVybiBudWxsIH1cXG4gICAgICBkaWZmID0gKG4gKyB2aWV3W2luZGV4XS5zaXplKSAtIG9sZE5cXG4gICAgICBpbmRleCsrXFxuICAgIH0gZWxzZSB7XFxuICAgICAgZGlmZiA9IG4gLSBvbGROXFxuICAgIH1cXG4gICAgb2xkTiArPSBkaWZmOyBuZXdOICs9IGRpZmZcXG4gIH1cXG4gIHdoaWxlICh2aXN1YWxMaW5lTm8oY20uZG9jLCBuZXdOKSAhPSBuZXdOKSB7XFxuICAgIGlmIChpbmRleCA9PSAoZGlyIDwgMCA/IDAgOiB2aWV3Lmxlbmd0aCAtIDEpKSB7IHJldHVybiBudWxsIH1cXG4gICAgbmV3TiArPSBkaXIgKiB2aWV3W2luZGV4IC0gKGRpciA8IDAgPyAxIDogMCldLnNpemVcXG4gICAgaW5kZXggKz0gZGlyXFxuICB9XFxuICByZXR1cm4ge2luZGV4OiBpbmRleCwgbGluZU46IG5ld059XFxufVxcblxcbi8vIEZvcmNlIHRoZSB2aWV3IHRvIGNvdmVyIGEgZ2l2ZW4gcmFuZ2UsIGFkZGluZyBlbXB0eSB2aWV3IGVsZW1lbnRcXG4vLyBvciBjbGlwcGluZyBvZmYgZXhpc3Rpbmcgb25lcyBhcyBuZWVkZWQuXFxuZnVuY3Rpb24gYWRqdXN0VmlldyhjbSwgZnJvbSwgdG8pIHtcXG4gIHZhciBkaXNwbGF5ID0gY20uZGlzcGxheSwgdmlldyA9IGRpc3BsYXkudmlld1xcbiAgaWYgKHZpZXcubGVuZ3RoID09IDAgfHwgZnJvbSA+PSBkaXNwbGF5LnZpZXdUbyB8fCB0byA8PSBkaXNwbGF5LnZpZXdGcm9tKSB7XFxuICAgIGRpc3BsYXkudmlldyA9IGJ1aWxkVmlld0FycmF5KGNtLCBmcm9tLCB0bylcXG4gICAgZGlzcGxheS52aWV3RnJvbSA9IGZyb21cXG4gIH0gZWxzZSB7XFxuICAgIGlmIChkaXNwbGF5LnZpZXdGcm9tID4gZnJvbSlcXG4gICAgICB7IGRpc3BsYXkudmlldyA9IGJ1aWxkVmlld0FycmF5KGNtLCBmcm9tLCBkaXNwbGF5LnZpZXdGcm9tKS5jb25jYXQoZGlzcGxheS52aWV3KSB9XFxuICAgIGVsc2UgaWYgKGRpc3BsYXkudmlld0Zyb20gPCBmcm9tKVxcbiAgICAgIHsgZGlzcGxheS52aWV3ID0gZGlzcGxheS52aWV3LnNsaWNlKGZpbmRWaWV3SW5kZXgoY20sIGZyb20pKSB9XFxuICAgIGRpc3BsYXkudmlld0Zyb20gPSBmcm9tXFxuICAgIGlmIChkaXNwbGF5LnZpZXdUbyA8IHRvKVxcbiAgICAgIHsgZGlzcGxheS52aWV3ID0gZGlzcGxheS52aWV3LmNvbmNhdChidWlsZFZpZXdBcnJheShjbSwgZGlzcGxheS52aWV3VG8sIHRvKSkgfVxcbiAgICBlbHNlIGlmIChkaXNwbGF5LnZpZXdUbyA+IHRvKVxcbiAgICAgIHsgZGlzcGxheS52aWV3ID0gZGlzcGxheS52aWV3LnNsaWNlKDAsIGZpbmRWaWV3SW5kZXgoY20sIHRvKSkgfVxcbiAgfVxcbiAgZGlzcGxheS52aWV3VG8gPSB0b1xcbn1cXG5cXG4vLyBDb3VudCB0aGUgbnVtYmVyIG9mIGxpbmVzIGluIHRoZSB2aWV3IHdob3NlIERPTSByZXByZXNlbnRhdGlvbiBpc1xcbi8vIG91dCBvZiBkYXRlIChvciBub25leGlzdGVudCkuXFxuZnVuY3Rpb24gY291bnREaXJ0eVZpZXcoY20pIHtcXG4gIHZhciB2aWV3ID0gY20uZGlzcGxheS52aWV3LCBkaXJ0eSA9IDBcXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdmlldy5sZW5ndGg7IGkrKykge1xcbiAgICB2YXIgbGluZVZpZXcgPSB2aWV3W2ldXFxuICAgIGlmICghbGluZVZpZXcuaGlkZGVuICYmICghbGluZVZpZXcubm9kZSB8fCBsaW5lVmlldy5jaGFuZ2VzKSkgeyArK2RpcnR5IH1cXG4gIH1cXG4gIHJldHVybiBkaXJ0eVxcbn1cXG5cXG4vLyBISUdITElHSFQgV09SS0VSXFxuXFxuZnVuY3Rpb24gc3RhcnRXb3JrZXIoY20sIHRpbWUpIHtcXG4gIGlmIChjbS5kb2MubW9kZS5zdGFydFN0YXRlICYmIGNtLmRvYy5mcm9udGllciA8IGNtLmRpc3BsYXkudmlld1RvKVxcbiAgICB7IGNtLnN0YXRlLmhpZ2hsaWdodC5zZXQodGltZSwgYmluZChoaWdobGlnaHRXb3JrZXIsIGNtKSkgfVxcbn1cXG5cXG5mdW5jdGlvbiBoaWdobGlnaHRXb3JrZXIoY20pIHtcXG4gIHZhciBkb2MgPSBjbS5kb2NcXG4gIGlmIChkb2MuZnJvbnRpZXIgPCBkb2MuZmlyc3QpIHsgZG9jLmZyb250aWVyID0gZG9jLmZpcnN0IH1cXG4gIGlmIChkb2MuZnJvbnRpZXIgPj0gY20uZGlzcGxheS52aWV3VG8pIHsgcmV0dXJuIH1cXG4gIHZhciBlbmQgPSArbmV3IERhdGUgKyBjbS5vcHRpb25zLndvcmtUaW1lXFxuICB2YXIgc3RhdGUgPSBjb3B5U3RhdGUoZG9jLm1vZGUsIGdldFN0YXRlQmVmb3JlKGNtLCBkb2MuZnJvbnRpZXIpKVxcbiAgdmFyIGNoYW5nZWRMaW5lcyA9IFtdXFxuXFxuICBkb2MuaXRlcihkb2MuZnJvbnRpZXIsIE1hdGgubWluKGRvYy5maXJzdCArIGRvYy5zaXplLCBjbS5kaXNwbGF5LnZpZXdUbyArIDUwMCksIGZ1bmN0aW9uIChsaW5lKSB7XFxuICAgIGlmIChkb2MuZnJvbnRpZXIgPj0gY20uZGlzcGxheS52aWV3RnJvbSkgeyAvLyBWaXNpYmxlXFxuICAgICAgdmFyIG9sZFN0eWxlcyA9IGxpbmUuc3R5bGVzLCB0b29Mb25nID0gbGluZS50ZXh0Lmxlbmd0aCA+IGNtLm9wdGlvbnMubWF4SGlnaGxpZ2h0TGVuZ3RoXFxuICAgICAgdmFyIGhpZ2hsaWdodGVkID0gaGlnaGxpZ2h0TGluZShjbSwgbGluZSwgdG9vTG9uZyA/IGNvcHlTdGF0ZShkb2MubW9kZSwgc3RhdGUpIDogc3RhdGUsIHRydWUpXFxuICAgICAgbGluZS5zdHlsZXMgPSBoaWdobGlnaHRlZC5zdHlsZXNcXG4gICAgICB2YXIgb2xkQ2xzID0gbGluZS5zdHlsZUNsYXNzZXMsIG5ld0NscyA9IGhpZ2hsaWdodGVkLmNsYXNzZXNcXG4gICAgICBpZiAobmV3Q2xzKSB7IGxpbmUuc3R5bGVDbGFzc2VzID0gbmV3Q2xzIH1cXG4gICAgICBlbHNlIGlmIChvbGRDbHMpIHsgbGluZS5zdHlsZUNsYXNzZXMgPSBudWxsIH1cXG4gICAgICB2YXIgaXNjaGFuZ2UgPSAhb2xkU3R5bGVzIHx8IG9sZFN0eWxlcy5sZW5ndGggIT0gbGluZS5zdHlsZXMubGVuZ3RoIHx8XFxuICAgICAgICBvbGRDbHMgIT0gbmV3Q2xzICYmICghb2xkQ2xzIHx8ICFuZXdDbHMgfHwgb2xkQ2xzLmJnQ2xhc3MgIT0gbmV3Q2xzLmJnQ2xhc3MgfHwgb2xkQ2xzLnRleHRDbGFzcyAhPSBuZXdDbHMudGV4dENsYXNzKVxcbiAgICAgIGZvciAodmFyIGkgPSAwOyAhaXNjaGFuZ2UgJiYgaSA8IG9sZFN0eWxlcy5sZW5ndGg7ICsraSkgeyBpc2NoYW5nZSA9IG9sZFN0eWxlc1tpXSAhPSBsaW5lLnN0eWxlc1tpXSB9XFxuICAgICAgaWYgKGlzY2hhbmdlKSB7IGNoYW5nZWRMaW5lcy5wdXNoKGRvYy5mcm9udGllcikgfVxcbiAgICAgIGxpbmUuc3RhdGVBZnRlciA9IHRvb0xvbmcgPyBzdGF0ZSA6IGNvcHlTdGF0ZShkb2MubW9kZSwgc3RhdGUpXFxuICAgIH0gZWxzZSB7XFxuICAgICAgaWYgKGxpbmUudGV4dC5sZW5ndGggPD0gY20ub3B0aW9ucy5tYXhIaWdobGlnaHRMZW5ndGgpXFxuICAgICAgICB7IHByb2Nlc3NMaW5lKGNtLCBsaW5lLnRleHQsIHN0YXRlKSB9XFxuICAgICAgbGluZS5zdGF0ZUFmdGVyID0gZG9jLmZyb250aWVyICUgNSA9PSAwID8gY29weVN0YXRlKGRvYy5tb2RlLCBzdGF0ZSkgOiBudWxsXFxuICAgIH1cXG4gICAgKytkb2MuZnJvbnRpZXJcXG4gICAgaWYgKCtuZXcgRGF0ZSA+IGVuZCkge1xcbiAgICAgIHN0YXJ0V29ya2VyKGNtLCBjbS5vcHRpb25zLndvcmtEZWxheSlcXG4gICAgICByZXR1cm4gdHJ1ZVxcbiAgICB9XFxuICB9KVxcbiAgaWYgKGNoYW5nZWRMaW5lcy5sZW5ndGgpIHsgcnVuSW5PcChjbSwgZnVuY3Rpb24gKCkge1xcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoYW5nZWRMaW5lcy5sZW5ndGg7IGkrKylcXG4gICAgICB7IHJlZ0xpbmVDaGFuZ2UoY20sIGNoYW5nZWRMaW5lc1tpXSwgXFxcInRleHRcXFwiKSB9XFxuICB9KSB9XFxufVxcblxcbi8vIERJU1BMQVkgRFJBV0lOR1xcblxcbnZhciBEaXNwbGF5VXBkYXRlID0gZnVuY3Rpb24oY20sIHZpZXdwb3J0LCBmb3JjZSkge1xcbiAgdmFyIGRpc3BsYXkgPSBjbS5kaXNwbGF5XFxuXFxuICB0aGlzLnZpZXdwb3J0ID0gdmlld3BvcnRcXG4gIC8vIFN0b3JlIHNvbWUgdmFsdWVzIHRoYXQgd2UnbGwgbmVlZCBsYXRlciAoYnV0IGRvbid0IHdhbnQgdG8gZm9yY2UgYSByZWxheW91dCBmb3IpXFxuICB0aGlzLnZpc2libGUgPSB2aXNpYmxlTGluZXMoZGlzcGxheSwgY20uZG9jLCB2aWV3cG9ydClcXG4gIHRoaXMuZWRpdG9ySXNIaWRkZW4gPSAhZGlzcGxheS53cmFwcGVyLm9mZnNldFdpZHRoXFxuICB0aGlzLndyYXBwZXJIZWlnaHQgPSBkaXNwbGF5LndyYXBwZXIuY2xpZW50SGVpZ2h0XFxuICB0aGlzLndyYXBwZXJXaWR0aCA9IGRpc3BsYXkud3JhcHBlci5jbGllbnRXaWR0aFxcbiAgdGhpcy5vbGREaXNwbGF5V2lkdGggPSBkaXNwbGF5V2lkdGgoY20pXFxuICB0aGlzLmZvcmNlID0gZm9yY2VcXG4gIHRoaXMuZGltcyA9IGdldERpbWVuc2lvbnMoY20pXFxuICB0aGlzLmV2ZW50cyA9IFtdXFxufTtcXG5cXG5EaXNwbGF5VXBkYXRlLnByb3RvdHlwZS5zaWduYWwgPSBmdW5jdGlvbiAoZW1pdHRlciwgdHlwZSkge1xcbiAgaWYgKGhhc0hhbmRsZXIoZW1pdHRlciwgdHlwZSkpXFxuICAgIHsgdGhpcy5ldmVudHMucHVzaChhcmd1bWVudHMpIH1cXG59O1xcbkRpc3BsYXlVcGRhdGUucHJvdG90eXBlLmZpbmlzaCA9IGZ1bmN0aW9uICgpIHtcXG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XFxuXFxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZXZlbnRzLmxlbmd0aDsgaSsrKVxcbiAgICB7IHNpZ25hbC5hcHBseShudWxsLCB0aGlzJDEuZXZlbnRzW2ldKSB9XFxufTtcXG5cXG5mdW5jdGlvbiBtYXliZUNsaXBTY3JvbGxiYXJzKGNtKSB7XFxuICB2YXIgZGlzcGxheSA9IGNtLmRpc3BsYXlcXG4gIGlmICghZGlzcGxheS5zY3JvbGxiYXJzQ2xpcHBlZCAmJiBkaXNwbGF5LnNjcm9sbGVyLm9mZnNldFdpZHRoKSB7XFxuICAgIGRpc3BsYXkubmF0aXZlQmFyV2lkdGggPSBkaXNwbGF5LnNjcm9sbGVyLm9mZnNldFdpZHRoIC0gZGlzcGxheS5zY3JvbGxlci5jbGllbnRXaWR0aFxcbiAgICBkaXNwbGF5LmhlaWdodEZvcmNlci5zdHlsZS5oZWlnaHQgPSBzY3JvbGxHYXAoY20pICsgXFxcInB4XFxcIlxcbiAgICBkaXNwbGF5LnNpemVyLnN0eWxlLm1hcmdpbkJvdHRvbSA9IC1kaXNwbGF5Lm5hdGl2ZUJhcldpZHRoICsgXFxcInB4XFxcIlxcbiAgICBkaXNwbGF5LnNpemVyLnN0eWxlLmJvcmRlclJpZ2h0V2lkdGggPSBzY3JvbGxHYXAoY20pICsgXFxcInB4XFxcIlxcbiAgICBkaXNwbGF5LnNjcm9sbGJhcnNDbGlwcGVkID0gdHJ1ZVxcbiAgfVxcbn1cXG5cXG4vLyBEb2VzIHRoZSBhY3R1YWwgdXBkYXRpbmcgb2YgdGhlIGxpbmUgZGlzcGxheS4gQmFpbHMgb3V0XFxuLy8gKHJldHVybmluZyBmYWxzZSkgd2hlbiB0aGVyZSBpcyBub3RoaW5nIHRvIGJlIGRvbmUgYW5kIGZvcmNlZCBpc1xcbi8vIGZhbHNlLlxcbmZ1bmN0aW9uIHVwZGF0ZURpc3BsYXlJZk5lZWRlZChjbSwgdXBkYXRlKSB7XFxuICB2YXIgZGlzcGxheSA9IGNtLmRpc3BsYXksIGRvYyA9IGNtLmRvY1xcblxcbiAgaWYgKHVwZGF0ZS5lZGl0b3JJc0hpZGRlbikge1xcbiAgICByZXNldFZpZXcoY20pXFxuICAgIHJldHVybiBmYWxzZVxcbiAgfVxcblxcbiAgLy8gQmFpbCBvdXQgaWYgdGhlIHZpc2libGUgYXJlYSBpcyBhbHJlYWR5IHJlbmRlcmVkIGFuZCBub3RoaW5nIGNoYW5nZWQuXFxuICBpZiAoIXVwZGF0ZS5mb3JjZSAmJlxcbiAgICAgIHVwZGF0ZS52aXNpYmxlLmZyb20gPj0gZGlzcGxheS52aWV3RnJvbSAmJiB1cGRhdGUudmlzaWJsZS50byA8PSBkaXNwbGF5LnZpZXdUbyAmJlxcbiAgICAgIChkaXNwbGF5LnVwZGF0ZUxpbmVOdW1iZXJzID09IG51bGwgfHwgZGlzcGxheS51cGRhdGVMaW5lTnVtYmVycyA+PSBkaXNwbGF5LnZpZXdUbykgJiZcXG4gICAgICBkaXNwbGF5LnJlbmRlcmVkVmlldyA9PSBkaXNwbGF5LnZpZXcgJiYgY291bnREaXJ0eVZpZXcoY20pID09IDApXFxuICAgIHsgcmV0dXJuIGZhbHNlIH1cXG5cXG4gIGlmIChtYXliZVVwZGF0ZUxpbmVOdW1iZXJXaWR0aChjbSkpIHtcXG4gICAgcmVzZXRWaWV3KGNtKVxcbiAgICB1cGRhdGUuZGltcyA9IGdldERpbWVuc2lvbnMoY20pXFxuICB9XFxuXFxuICAvLyBDb21wdXRlIGEgc3VpdGFibGUgbmV3IHZpZXdwb3J0IChmcm9tICYgdG8pXFxuICB2YXIgZW5kID0gZG9jLmZpcnN0ICsgZG9jLnNpemVcXG4gIHZhciBmcm9tID0gTWF0aC5tYXgodXBkYXRlLnZpc2libGUuZnJvbSAtIGNtLm9wdGlvbnMudmlld3BvcnRNYXJnaW4sIGRvYy5maXJzdClcXG4gIHZhciB0byA9IE1hdGgubWluKGVuZCwgdXBkYXRlLnZpc2libGUudG8gKyBjbS5vcHRpb25zLnZpZXdwb3J0TWFyZ2luKVxcbiAgaWYgKGRpc3BsYXkudmlld0Zyb20gPCBmcm9tICYmIGZyb20gLSBkaXNwbGF5LnZpZXdGcm9tIDwgMjApIHsgZnJvbSA9IE1hdGgubWF4KGRvYy5maXJzdCwgZGlzcGxheS52aWV3RnJvbSkgfVxcbiAgaWYgKGRpc3BsYXkudmlld1RvID4gdG8gJiYgZGlzcGxheS52aWV3VG8gLSB0byA8IDIwKSB7IHRvID0gTWF0aC5taW4oZW5kLCBkaXNwbGF5LnZpZXdUbykgfVxcbiAgaWYgKHNhd0NvbGxhcHNlZFNwYW5zKSB7XFxuICAgIGZyb20gPSB2aXN1YWxMaW5lTm8oY20uZG9jLCBmcm9tKVxcbiAgICB0byA9IHZpc3VhbExpbmVFbmRObyhjbS5kb2MsIHRvKVxcbiAgfVxcblxcbiAgdmFyIGRpZmZlcmVudCA9IGZyb20gIT0gZGlzcGxheS52aWV3RnJvbSB8fCB0byAhPSBkaXNwbGF5LnZpZXdUbyB8fFxcbiAgICBkaXNwbGF5Lmxhc3RXcmFwSGVpZ2h0ICE9IHVwZGF0ZS53cmFwcGVySGVpZ2h0IHx8IGRpc3BsYXkubGFzdFdyYXBXaWR0aCAhPSB1cGRhdGUud3JhcHBlcldpZHRoXFxuICBhZGp1c3RWaWV3KGNtLCBmcm9tLCB0bylcXG5cXG4gIGRpc3BsYXkudmlld09mZnNldCA9IGhlaWdodEF0TGluZShnZXRMaW5lKGNtLmRvYywgZGlzcGxheS52aWV3RnJvbSkpXFxuICAvLyBQb3NpdGlvbiB0aGUgbW92ZXIgZGl2IHRvIGFsaWduIHdpdGggdGhlIGN1cnJlbnQgc2Nyb2xsIHBvc2l0aW9uXFxuICBjbS5kaXNwbGF5Lm1vdmVyLnN0eWxlLnRvcCA9IGRpc3BsYXkudmlld09mZnNldCArIFxcXCJweFxcXCJcXG5cXG4gIHZhciB0b1VwZGF0ZSA9IGNvdW50RGlydHlWaWV3KGNtKVxcbiAgaWYgKCFkaWZmZXJlbnQgJiYgdG9VcGRhdGUgPT0gMCAmJiAhdXBkYXRlLmZvcmNlICYmIGRpc3BsYXkucmVuZGVyZWRWaWV3ID09IGRpc3BsYXkudmlldyAmJlxcbiAgICAgIChkaXNwbGF5LnVwZGF0ZUxpbmVOdW1iZXJzID09IG51bGwgfHwgZGlzcGxheS51cGRhdGVMaW5lTnVtYmVycyA+PSBkaXNwbGF5LnZpZXdUbykpXFxuICAgIHsgcmV0dXJuIGZhbHNlIH1cXG5cXG4gIC8vIEZvciBiaWcgY2hhbmdlcywgd2UgaGlkZSB0aGUgZW5jbG9zaW5nIGVsZW1lbnQgZHVyaW5nIHRoZVxcbiAgLy8gdXBkYXRlLCBzaW5jZSB0aGF0IHNwZWVkcyB1cCB0aGUgb3BlcmF0aW9ucyBvbiBtb3N0IGJyb3dzZXJzLlxcbiAgdmFyIGZvY3VzZWQgPSBhY3RpdmVFbHQoKVxcbiAgaWYgKHRvVXBkYXRlID4gNCkgeyBkaXNwbGF5LmxpbmVEaXYuc3R5bGUuZGlzcGxheSA9IFxcXCJub25lXFxcIiB9XFxuICBwYXRjaERpc3BsYXkoY20sIGRpc3BsYXkudXBkYXRlTGluZU51bWJlcnMsIHVwZGF0ZS5kaW1zKVxcbiAgaWYgKHRvVXBkYXRlID4gNCkgeyBkaXNwbGF5LmxpbmVEaXYuc3R5bGUuZGlzcGxheSA9IFxcXCJcXFwiIH1cXG4gIGRpc3BsYXkucmVuZGVyZWRWaWV3ID0gZGlzcGxheS52aWV3XFxuICAvLyBUaGVyZSBtaWdodCBoYXZlIGJlZW4gYSB3aWRnZXQgd2l0aCBhIGZvY3VzZWQgZWxlbWVudCB0aGF0IGdvdFxcbiAgLy8gaGlkZGVuIG9yIHVwZGF0ZWQsIGlmIHNvIHJlLWZvY3VzIGl0LlxcbiAgaWYgKGZvY3VzZWQgJiYgYWN0aXZlRWx0KCkgIT0gZm9jdXNlZCAmJiBmb2N1c2VkLm9mZnNldEhlaWdodCkgeyBmb2N1c2VkLmZvY3VzKCkgfVxcblxcbiAgLy8gUHJldmVudCBzZWxlY3Rpb24gYW5kIGN1cnNvcnMgZnJvbSBpbnRlcmZlcmluZyB3aXRoIHRoZSBzY3JvbGxcXG4gIC8vIHdpZHRoIGFuZCBoZWlnaHQuXFxuICByZW1vdmVDaGlsZHJlbihkaXNwbGF5LmN1cnNvckRpdilcXG4gIHJlbW92ZUNoaWxkcmVuKGRpc3BsYXkuc2VsZWN0aW9uRGl2KVxcbiAgZGlzcGxheS5ndXR0ZXJzLnN0eWxlLmhlaWdodCA9IGRpc3BsYXkuc2l6ZXIuc3R5bGUubWluSGVpZ2h0ID0gMFxcblxcbiAgaWYgKGRpZmZlcmVudCkge1xcbiAgICBkaXNwbGF5Lmxhc3RXcmFwSGVpZ2h0ID0gdXBkYXRlLndyYXBwZXJIZWlnaHRcXG4gICAgZGlzcGxheS5sYXN0V3JhcFdpZHRoID0gdXBkYXRlLndyYXBwZXJXaWR0aFxcbiAgICBzdGFydFdvcmtlcihjbSwgNDAwKVxcbiAgfVxcblxcbiAgZGlzcGxheS51cGRhdGVMaW5lTnVtYmVycyA9IG51bGxcXG5cXG4gIHJldHVybiB0cnVlXFxufVxcblxcbmZ1bmN0aW9uIHBvc3RVcGRhdGVEaXNwbGF5KGNtLCB1cGRhdGUpIHtcXG4gIHZhciB2aWV3cG9ydCA9IHVwZGF0ZS52aWV3cG9ydFxcblxcbiAgZm9yICh2YXIgZmlyc3QgPSB0cnVlOzsgZmlyc3QgPSBmYWxzZSkge1xcbiAgICBpZiAoIWZpcnN0IHx8ICFjbS5vcHRpb25zLmxpbmVXcmFwcGluZyB8fCB1cGRhdGUub2xkRGlzcGxheVdpZHRoID09IGRpc3BsYXlXaWR0aChjbSkpIHtcXG4gICAgICAvLyBDbGlwIGZvcmNlZCB2aWV3cG9ydCB0byBhY3R1YWwgc2Nyb2xsYWJsZSBhcmVhLlxcbiAgICAgIGlmICh2aWV3cG9ydCAmJiB2aWV3cG9ydC50b3AgIT0gbnVsbClcXG4gICAgICAgIHsgdmlld3BvcnQgPSB7dG9wOiBNYXRoLm1pbihjbS5kb2MuaGVpZ2h0ICsgcGFkZGluZ1ZlcnQoY20uZGlzcGxheSkgLSBkaXNwbGF5SGVpZ2h0KGNtKSwgdmlld3BvcnQudG9wKX0gfVxcbiAgICAgIC8vIFVwZGF0ZWQgbGluZSBoZWlnaHRzIG1pZ2h0IHJlc3VsdCBpbiB0aGUgZHJhd24gYXJlYSBub3RcXG4gICAgICAvLyBhY3R1YWxseSBjb3ZlcmluZyB0aGUgdmlld3BvcnQuIEtlZXAgbG9vcGluZyB1bnRpbCBpdCBkb2VzLlxcbiAgICAgIHVwZGF0ZS52aXNpYmxlID0gdmlzaWJsZUxpbmVzKGNtLmRpc3BsYXksIGNtLmRvYywgdmlld3BvcnQpXFxuICAgICAgaWYgKHVwZGF0ZS52aXNpYmxlLmZyb20gPj0gY20uZGlzcGxheS52aWV3RnJvbSAmJiB1cGRhdGUudmlzaWJsZS50byA8PSBjbS5kaXNwbGF5LnZpZXdUbylcXG4gICAgICAgIHsgYnJlYWsgfVxcbiAgICB9XFxuICAgIGlmICghdXBkYXRlRGlzcGxheUlmTmVlZGVkKGNtLCB1cGRhdGUpKSB7IGJyZWFrIH1cXG4gICAgdXBkYXRlSGVpZ2h0c0luVmlld3BvcnQoY20pXFxuICAgIHZhciBiYXJNZWFzdXJlID0gbWVhc3VyZUZvclNjcm9sbGJhcnMoY20pXFxuICAgIHVwZGF0ZVNlbGVjdGlvbihjbSlcXG4gICAgdXBkYXRlU2Nyb2xsYmFycyhjbSwgYmFyTWVhc3VyZSlcXG4gICAgc2V0RG9jdW1lbnRIZWlnaHQoY20sIGJhck1lYXN1cmUpXFxuICB9XFxuXFxuICB1cGRhdGUuc2lnbmFsKGNtLCBcXFwidXBkYXRlXFxcIiwgY20pXFxuICBpZiAoY20uZGlzcGxheS52aWV3RnJvbSAhPSBjbS5kaXNwbGF5LnJlcG9ydGVkVmlld0Zyb20gfHwgY20uZGlzcGxheS52aWV3VG8gIT0gY20uZGlzcGxheS5yZXBvcnRlZFZpZXdUbykge1xcbiAgICB1cGRhdGUuc2lnbmFsKGNtLCBcXFwidmlld3BvcnRDaGFuZ2VcXFwiLCBjbSwgY20uZGlzcGxheS52aWV3RnJvbSwgY20uZGlzcGxheS52aWV3VG8pXFxuICAgIGNtLmRpc3BsYXkucmVwb3J0ZWRWaWV3RnJvbSA9IGNtLmRpc3BsYXkudmlld0Zyb207IGNtLmRpc3BsYXkucmVwb3J0ZWRWaWV3VG8gPSBjbS5kaXNwbGF5LnZpZXdUb1xcbiAgfVxcbn1cXG5cXG5mdW5jdGlvbiB1cGRhdGVEaXNwbGF5U2ltcGxlKGNtLCB2aWV3cG9ydCkge1xcbiAgdmFyIHVwZGF0ZSA9IG5ldyBEaXNwbGF5VXBkYXRlKGNtLCB2aWV3cG9ydClcXG4gIGlmICh1cGRhdGVEaXNwbGF5SWZOZWVkZWQoY20sIHVwZGF0ZSkpIHtcXG4gICAgdXBkYXRlSGVpZ2h0c0luVmlld3BvcnQoY20pXFxuICAgIHBvc3RVcGRhdGVEaXNwbGF5KGNtLCB1cGRhdGUpXFxuICAgIHZhciBiYXJNZWFzdXJlID0gbWVhc3VyZUZvclNjcm9sbGJhcnMoY20pXFxuICAgIHVwZGF0ZVNlbGVjdGlvbihjbSlcXG4gICAgdXBkYXRlU2Nyb2xsYmFycyhjbSwgYmFyTWVhc3VyZSlcXG4gICAgc2V0RG9jdW1lbnRIZWlnaHQoY20sIGJhck1lYXN1cmUpXFxuICAgIHVwZGF0ZS5maW5pc2goKVxcbiAgfVxcbn1cXG5cXG4vLyBTeW5jIHRoZSBhY3R1YWwgZGlzcGxheSBET00gc3RydWN0dXJlIHdpdGggZGlzcGxheS52aWV3LCByZW1vdmluZ1xcbi8vIG5vZGVzIGZvciBsaW5lcyB0aGF0IGFyZSBubyBsb25nZXIgaW4gdmlldywgYW5kIGNyZWF0aW5nIHRoZSBvbmVzXFxuLy8gdGhhdCBhcmUgbm90IHRoZXJlIHlldCwgYW5kIHVwZGF0aW5nIHRoZSBvbmVzIHRoYXQgYXJlIG91dCBvZlxcbi8vIGRhdGUuXFxuZnVuY3Rpb24gcGF0Y2hEaXNwbGF5KGNtLCB1cGRhdGVOdW1iZXJzRnJvbSwgZGltcykge1xcbiAgdmFyIGRpc3BsYXkgPSBjbS5kaXNwbGF5LCBsaW5lTnVtYmVycyA9IGNtLm9wdGlvbnMubGluZU51bWJlcnNcXG4gIHZhciBjb250YWluZXIgPSBkaXNwbGF5LmxpbmVEaXYsIGN1ciA9IGNvbnRhaW5lci5maXJzdENoaWxkXFxuXFxuICBmdW5jdGlvbiBybShub2RlKSB7XFxuICAgIHZhciBuZXh0ID0gbm9kZS5uZXh0U2libGluZ1xcbiAgICAvLyBXb3JrcyBhcm91bmQgYSB0aHJvdy1zY3JvbGwgYnVnIGluIE9TIFggV2Via2l0XFxuICAgIGlmICh3ZWJraXQgJiYgbWFjICYmIGNtLmRpc3BsYXkuY3VycmVudFdoZWVsVGFyZ2V0ID09IG5vZGUpXFxuICAgICAgeyBub2RlLnN0eWxlLmRpc3BsYXkgPSBcXFwibm9uZVxcXCIgfVxcbiAgICBlbHNlXFxuICAgICAgeyBub2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobm9kZSkgfVxcbiAgICByZXR1cm4gbmV4dFxcbiAgfVxcblxcbiAgdmFyIHZpZXcgPSBkaXNwbGF5LnZpZXcsIGxpbmVOID0gZGlzcGxheS52aWV3RnJvbVxcbiAgLy8gTG9vcCBvdmVyIHRoZSBlbGVtZW50cyBpbiB0aGUgdmlldywgc3luY2luZyBjdXIgKHRoZSBET00gbm9kZXNcXG4gIC8vIGluIGRpc3BsYXkubGluZURpdikgd2l0aCB0aGUgdmlldyBhcyB3ZSBnby5cXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdmlldy5sZW5ndGg7IGkrKykge1xcbiAgICB2YXIgbGluZVZpZXcgPSB2aWV3W2ldXFxuICAgIGlmIChsaW5lVmlldy5oaWRkZW4pIHtcXG4gICAgfSBlbHNlIGlmICghbGluZVZpZXcubm9kZSB8fCBsaW5lVmlldy5ub2RlLnBhcmVudE5vZGUgIT0gY29udGFpbmVyKSB7IC8vIE5vdCBkcmF3biB5ZXRcXG4gICAgICB2YXIgbm9kZSA9IGJ1aWxkTGluZUVsZW1lbnQoY20sIGxpbmVWaWV3LCBsaW5lTiwgZGltcylcXG4gICAgICBjb250YWluZXIuaW5zZXJ0QmVmb3JlKG5vZGUsIGN1cilcXG4gICAgfSBlbHNlIHsgLy8gQWxyZWFkeSBkcmF3blxcbiAgICAgIHdoaWxlIChjdXIgIT0gbGluZVZpZXcubm9kZSkgeyBjdXIgPSBybShjdXIpIH1cXG4gICAgICB2YXIgdXBkYXRlTnVtYmVyID0gbGluZU51bWJlcnMgJiYgdXBkYXRlTnVtYmVyc0Zyb20gIT0gbnVsbCAmJlxcbiAgICAgICAgdXBkYXRlTnVtYmVyc0Zyb20gPD0gbGluZU4gJiYgbGluZVZpZXcubGluZU51bWJlclxcbiAgICAgIGlmIChsaW5lVmlldy5jaGFuZ2VzKSB7XFxuICAgICAgICBpZiAoaW5kZXhPZihsaW5lVmlldy5jaGFuZ2VzLCBcXFwiZ3V0dGVyXFxcIikgPiAtMSkgeyB1cGRhdGVOdW1iZXIgPSBmYWxzZSB9XFxuICAgICAgICB1cGRhdGVMaW5lRm9yQ2hhbmdlcyhjbSwgbGluZVZpZXcsIGxpbmVOLCBkaW1zKVxcbiAgICAgIH1cXG4gICAgICBpZiAodXBkYXRlTnVtYmVyKSB7XFxuICAgICAgICByZW1vdmVDaGlsZHJlbihsaW5lVmlldy5saW5lTnVtYmVyKVxcbiAgICAgICAgbGluZVZpZXcubGluZU51bWJlci5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShsaW5lTnVtYmVyRm9yKGNtLm9wdGlvbnMsIGxpbmVOKSkpXFxuICAgICAgfVxcbiAgICAgIGN1ciA9IGxpbmVWaWV3Lm5vZGUubmV4dFNpYmxpbmdcXG4gICAgfVxcbiAgICBsaW5lTiArPSBsaW5lVmlldy5zaXplXFxuICB9XFxuICB3aGlsZSAoY3VyKSB7IGN1ciA9IHJtKGN1cikgfVxcbn1cXG5cXG5mdW5jdGlvbiB1cGRhdGVHdXR0ZXJTcGFjZShjbSkge1xcbiAgdmFyIHdpZHRoID0gY20uZGlzcGxheS5ndXR0ZXJzLm9mZnNldFdpZHRoXFxuICBjbS5kaXNwbGF5LnNpemVyLnN0eWxlLm1hcmdpbkxlZnQgPSB3aWR0aCArIFxcXCJweFxcXCJcXG59XFxuXFxuZnVuY3Rpb24gc2V0RG9jdW1lbnRIZWlnaHQoY20sIG1lYXN1cmUpIHtcXG4gIGNtLmRpc3BsYXkuc2l6ZXIuc3R5bGUubWluSGVpZ2h0ID0gbWVhc3VyZS5kb2NIZWlnaHQgKyBcXFwicHhcXFwiXFxuICBjbS5kaXNwbGF5LmhlaWdodEZvcmNlci5zdHlsZS50b3AgPSBtZWFzdXJlLmRvY0hlaWdodCArIFxcXCJweFxcXCJcXG4gIGNtLmRpc3BsYXkuZ3V0dGVycy5zdHlsZS5oZWlnaHQgPSAobWVhc3VyZS5kb2NIZWlnaHQgKyBjbS5kaXNwbGF5LmJhckhlaWdodCArIHNjcm9sbEdhcChjbSkpICsgXFxcInB4XFxcIlxcbn1cXG5cXG4vLyBSZWJ1aWxkIHRoZSBndXR0ZXIgZWxlbWVudHMsIGVuc3VyZSB0aGUgbWFyZ2luIHRvIHRoZSBsZWZ0IG9mIHRoZVxcbi8vIGNvZGUgbWF0Y2hlcyB0aGVpciB3aWR0aC5cXG5mdW5jdGlvbiB1cGRhdGVHdXR0ZXJzKGNtKSB7XFxuICB2YXIgZ3V0dGVycyA9IGNtLmRpc3BsYXkuZ3V0dGVycywgc3BlY3MgPSBjbS5vcHRpb25zLmd1dHRlcnNcXG4gIHJlbW92ZUNoaWxkcmVuKGd1dHRlcnMpXFxuICB2YXIgaSA9IDBcXG4gIGZvciAoOyBpIDwgc3BlY3MubGVuZ3RoOyArK2kpIHtcXG4gICAgdmFyIGd1dHRlckNsYXNzID0gc3BlY3NbaV1cXG4gICAgdmFyIGdFbHQgPSBndXR0ZXJzLmFwcGVuZENoaWxkKGVsdChcXFwiZGl2XFxcIiwgbnVsbCwgXFxcIkNvZGVNaXJyb3ItZ3V0dGVyIFxcXCIgKyBndXR0ZXJDbGFzcykpXFxuICAgIGlmIChndXR0ZXJDbGFzcyA9PSBcXFwiQ29kZU1pcnJvci1saW5lbnVtYmVyc1xcXCIpIHtcXG4gICAgICBjbS5kaXNwbGF5LmxpbmVHdXR0ZXIgPSBnRWx0XFxuICAgICAgZ0VsdC5zdHlsZS53aWR0aCA9IChjbS5kaXNwbGF5LmxpbmVOdW1XaWR0aCB8fCAxKSArIFxcXCJweFxcXCJcXG4gICAgfVxcbiAgfVxcbiAgZ3V0dGVycy5zdHlsZS5kaXNwbGF5ID0gaSA/IFxcXCJcXFwiIDogXFxcIm5vbmVcXFwiXFxuICB1cGRhdGVHdXR0ZXJTcGFjZShjbSlcXG59XFxuXFxuLy8gTWFrZSBzdXJlIHRoZSBndXR0ZXJzIG9wdGlvbnMgY29udGFpbnMgdGhlIGVsZW1lbnRcXG4vLyBcXFwiQ29kZU1pcnJvci1saW5lbnVtYmVyc1xcXCIgd2hlbiB0aGUgbGluZU51bWJlcnMgb3B0aW9uIGlzIHRydWUuXFxuZnVuY3Rpb24gc2V0R3V0dGVyc0ZvckxpbmVOdW1iZXJzKG9wdGlvbnMpIHtcXG4gIHZhciBmb3VuZCA9IGluZGV4T2Yob3B0aW9ucy5ndXR0ZXJzLCBcXFwiQ29kZU1pcnJvci1saW5lbnVtYmVyc1xcXCIpXFxuICBpZiAoZm91bmQgPT0gLTEgJiYgb3B0aW9ucy5saW5lTnVtYmVycykge1xcbiAgICBvcHRpb25zLmd1dHRlcnMgPSBvcHRpb25zLmd1dHRlcnMuY29uY2F0KFtcXFwiQ29kZU1pcnJvci1saW5lbnVtYmVyc1xcXCJdKVxcbiAgfSBlbHNlIGlmIChmb3VuZCA+IC0xICYmICFvcHRpb25zLmxpbmVOdW1iZXJzKSB7XFxuICAgIG9wdGlvbnMuZ3V0dGVycyA9IG9wdGlvbnMuZ3V0dGVycy5zbGljZSgwKVxcbiAgICBvcHRpb25zLmd1dHRlcnMuc3BsaWNlKGZvdW5kLCAxKVxcbiAgfVxcbn1cXG5cXG4vLyBTZWxlY3Rpb24gb2JqZWN0cyBhcmUgaW1tdXRhYmxlLiBBIG5ldyBvbmUgaXMgY3JlYXRlZCBldmVyeSB0aW1lXFxuLy8gdGhlIHNlbGVjdGlvbiBjaGFuZ2VzLiBBIHNlbGVjdGlvbiBpcyBvbmUgb3IgbW9yZSBub24tb3ZlcmxhcHBpbmdcXG4vLyAoYW5kIG5vbi10b3VjaGluZykgcmFuZ2VzLCBzb3J0ZWQsIGFuZCBhbiBpbnRlZ2VyIHRoYXQgaW5kaWNhdGVzXFxuLy8gd2hpY2ggb25lIGlzIHRoZSBwcmltYXJ5IHNlbGVjdGlvbiAodGhlIG9uZSB0aGF0J3Mgc2Nyb2xsZWQgaW50b1xcbi8vIHZpZXcsIHRoYXQgZ2V0Q3Vyc29yIHJldHVybnMsIGV0YykuXFxuZnVuY3Rpb24gU2VsZWN0aW9uKHJhbmdlcywgcHJpbUluZGV4KSB7XFxuICB0aGlzLnJhbmdlcyA9IHJhbmdlc1xcbiAgdGhpcy5wcmltSW5kZXggPSBwcmltSW5kZXhcXG59XFxuXFxuU2VsZWN0aW9uLnByb3RvdHlwZSA9IHtcXG4gIHByaW1hcnk6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5yYW5nZXNbdGhpcy5wcmltSW5kZXhdIH0sXFxuICBlcXVhbHM6IGZ1bmN0aW9uKG90aGVyKSB7XFxuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xcblxcbiAgICBpZiAob3RoZXIgPT0gdGhpcykgeyByZXR1cm4gdHJ1ZSB9XFxuICAgIGlmIChvdGhlci5wcmltSW5kZXggIT0gdGhpcy5wcmltSW5kZXggfHwgb3RoZXIucmFuZ2VzLmxlbmd0aCAhPSB0aGlzLnJhbmdlcy5sZW5ndGgpIHsgcmV0dXJuIGZhbHNlIH1cXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnJhbmdlcy5sZW5ndGg7IGkrKykge1xcbiAgICAgIHZhciBoZXJlID0gdGhpcyQxLnJhbmdlc1tpXSwgdGhlcmUgPSBvdGhlci5yYW5nZXNbaV1cXG4gICAgICBpZiAoY21wKGhlcmUuYW5jaG9yLCB0aGVyZS5hbmNob3IpICE9IDAgfHwgY21wKGhlcmUuaGVhZCwgdGhlcmUuaGVhZCkgIT0gMCkgeyByZXR1cm4gZmFsc2UgfVxcbiAgICB9XFxuICAgIHJldHVybiB0cnVlXFxuICB9LFxcbiAgZGVlcENvcHk6IGZ1bmN0aW9uKCkge1xcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcXG5cXG4gICAgdmFyIG91dCA9IFtdXFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5yYW5nZXMubGVuZ3RoOyBpKyspXFxuICAgICAgeyBvdXRbaV0gPSBuZXcgUmFuZ2UoY29weVBvcyh0aGlzJDEucmFuZ2VzW2ldLmFuY2hvciksIGNvcHlQb3ModGhpcyQxLnJhbmdlc1tpXS5oZWFkKSkgfVxcbiAgICByZXR1cm4gbmV3IFNlbGVjdGlvbihvdXQsIHRoaXMucHJpbUluZGV4KVxcbiAgfSxcXG4gIHNvbWV0aGluZ1NlbGVjdGVkOiBmdW5jdGlvbigpIHtcXG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XFxuXFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5yYW5nZXMubGVuZ3RoOyBpKyspXFxuICAgICAgeyBpZiAoIXRoaXMkMS5yYW5nZXNbaV0uZW1wdHkoKSkgeyByZXR1cm4gdHJ1ZSB9IH1cXG4gICAgcmV0dXJuIGZhbHNlXFxuICB9LFxcbiAgY29udGFpbnM6IGZ1bmN0aW9uKHBvcywgZW5kKSB7XFxuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xcblxcbiAgICBpZiAoIWVuZCkgeyBlbmQgPSBwb3MgfVxcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucmFuZ2VzLmxlbmd0aDsgaSsrKSB7XFxuICAgICAgdmFyIHJhbmdlID0gdGhpcyQxLnJhbmdlc1tpXVxcbiAgICAgIGlmIChjbXAoZW5kLCByYW5nZS5mcm9tKCkpID49IDAgJiYgY21wKHBvcywgcmFuZ2UudG8oKSkgPD0gMClcXG4gICAgICAgIHsgcmV0dXJuIGkgfVxcbiAgICB9XFxuICAgIHJldHVybiAtMVxcbiAgfVxcbn1cXG5cXG5mdW5jdGlvbiBSYW5nZShhbmNob3IsIGhlYWQpIHtcXG4gIHRoaXMuYW5jaG9yID0gYW5jaG9yOyB0aGlzLmhlYWQgPSBoZWFkXFxufVxcblxcblJhbmdlLnByb3RvdHlwZSA9IHtcXG4gIGZyb206IGZ1bmN0aW9uKCkgeyByZXR1cm4gbWluUG9zKHRoaXMuYW5jaG9yLCB0aGlzLmhlYWQpIH0sXFxuICB0bzogZnVuY3Rpb24oKSB7IHJldHVybiBtYXhQb3ModGhpcy5hbmNob3IsIHRoaXMuaGVhZCkgfSxcXG4gIGVtcHR5OiBmdW5jdGlvbigpIHtcXG4gICAgcmV0dXJuIHRoaXMuaGVhZC5saW5lID09IHRoaXMuYW5jaG9yLmxpbmUgJiYgdGhpcy5oZWFkLmNoID09IHRoaXMuYW5jaG9yLmNoXFxuICB9XFxufVxcblxcbi8vIFRha2UgYW4gdW5zb3J0ZWQsIHBvdGVudGlhbGx5IG92ZXJsYXBwaW5nIHNldCBvZiByYW5nZXMsIGFuZFxcbi8vIGJ1aWxkIGEgc2VsZWN0aW9uIG91dCBvZiBpdC4gJ0NvbnN1bWVzJyByYW5nZXMgYXJyYXkgKG1vZGlmeWluZ1xcbi8vIGl0KS5cXG5mdW5jdGlvbiBub3JtYWxpemVTZWxlY3Rpb24ocmFuZ2VzLCBwcmltSW5kZXgpIHtcXG4gIHZhciBwcmltID0gcmFuZ2VzW3ByaW1JbmRleF1cXG4gIHJhbmdlcy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBjbXAoYS5mcm9tKCksIGIuZnJvbSgpKTsgfSlcXG4gIHByaW1JbmRleCA9IGluZGV4T2YocmFuZ2VzLCBwcmltKVxcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCByYW5nZXMubGVuZ3RoOyBpKyspIHtcXG4gICAgdmFyIGN1ciA9IHJhbmdlc1tpXSwgcHJldiA9IHJhbmdlc1tpIC0gMV1cXG4gICAgaWYgKGNtcChwcmV2LnRvKCksIGN1ci5mcm9tKCkpID49IDApIHtcXG4gICAgICB2YXIgZnJvbSA9IG1pblBvcyhwcmV2LmZyb20oKSwgY3VyLmZyb20oKSksIHRvID0gbWF4UG9zKHByZXYudG8oKSwgY3VyLnRvKCkpXFxuICAgICAgdmFyIGludiA9IHByZXYuZW1wdHkoKSA/IGN1ci5mcm9tKCkgPT0gY3VyLmhlYWQgOiBwcmV2LmZyb20oKSA9PSBwcmV2LmhlYWRcXG4gICAgICBpZiAoaSA8PSBwcmltSW5kZXgpIHsgLS1wcmltSW5kZXggfVxcbiAgICAgIHJhbmdlcy5zcGxpY2UoLS1pLCAyLCBuZXcgUmFuZ2UoaW52ID8gdG8gOiBmcm9tLCBpbnYgPyBmcm9tIDogdG8pKVxcbiAgICB9XFxuICB9XFxuICByZXR1cm4gbmV3IFNlbGVjdGlvbihyYW5nZXMsIHByaW1JbmRleClcXG59XFxuXFxuZnVuY3Rpb24gc2ltcGxlU2VsZWN0aW9uKGFuY2hvciwgaGVhZCkge1xcbiAgcmV0dXJuIG5ldyBTZWxlY3Rpb24oW25ldyBSYW5nZShhbmNob3IsIGhlYWQgfHwgYW5jaG9yKV0sIDApXFxufVxcblxcbi8vIENvbXB1dGUgdGhlIHBvc2l0aW9uIG9mIHRoZSBlbmQgb2YgYSBjaGFuZ2UgKGl0cyAndG8nIHByb3BlcnR5XFxuLy8gcmVmZXJzIHRvIHRoZSBwcmUtY2hhbmdlIGVuZCkuXFxuZnVuY3Rpb24gY2hhbmdlRW5kKGNoYW5nZSkge1xcbiAgaWYgKCFjaGFuZ2UudGV4dCkgeyByZXR1cm4gY2hhbmdlLnRvIH1cXG4gIHJldHVybiBQb3MoY2hhbmdlLmZyb20ubGluZSArIGNoYW5nZS50ZXh0Lmxlbmd0aCAtIDEsXFxuICAgICAgICAgICAgIGxzdChjaGFuZ2UudGV4dCkubGVuZ3RoICsgKGNoYW5nZS50ZXh0Lmxlbmd0aCA9PSAxID8gY2hhbmdlLmZyb20uY2ggOiAwKSlcXG59XFxuXFxuLy8gQWRqdXN0IGEgcG9zaXRpb24gdG8gcmVmZXIgdG8gdGhlIHBvc3QtY2hhbmdlIHBvc2l0aW9uIG9mIHRoZVxcbi8vIHNhbWUgdGV4dCwgb3IgdGhlIGVuZCBvZiB0aGUgY2hhbmdlIGlmIHRoZSBjaGFuZ2UgY292ZXJzIGl0LlxcbmZ1bmN0aW9uIGFkanVzdEZvckNoYW5nZShwb3MsIGNoYW5nZSkge1xcbiAgaWYgKGNtcChwb3MsIGNoYW5nZS5mcm9tKSA8IDApIHsgcmV0dXJuIHBvcyB9XFxuICBpZiAoY21wKHBvcywgY2hhbmdlLnRvKSA8PSAwKSB7IHJldHVybiBjaGFuZ2VFbmQoY2hhbmdlKSB9XFxuXFxuICB2YXIgbGluZSA9IHBvcy5saW5lICsgY2hhbmdlLnRleHQubGVuZ3RoIC0gKGNoYW5nZS50by5saW5lIC0gY2hhbmdlLmZyb20ubGluZSkgLSAxLCBjaCA9IHBvcy5jaFxcbiAgaWYgKHBvcy5saW5lID09IGNoYW5nZS50by5saW5lKSB7IGNoICs9IGNoYW5nZUVuZChjaGFuZ2UpLmNoIC0gY2hhbmdlLnRvLmNoIH1cXG4gIHJldHVybiBQb3MobGluZSwgY2gpXFxufVxcblxcbmZ1bmN0aW9uIGNvbXB1dGVTZWxBZnRlckNoYW5nZShkb2MsIGNoYW5nZSkge1xcbiAgdmFyIG91dCA9IFtdXFxuICBmb3IgKHZhciBpID0gMDsgaSA8IGRvYy5zZWwucmFuZ2VzLmxlbmd0aDsgaSsrKSB7XFxuICAgIHZhciByYW5nZSA9IGRvYy5zZWwucmFuZ2VzW2ldXFxuICAgIG91dC5wdXNoKG5ldyBSYW5nZShhZGp1c3RGb3JDaGFuZ2UocmFuZ2UuYW5jaG9yLCBjaGFuZ2UpLFxcbiAgICAgICAgICAgICAgICAgICAgICAgYWRqdXN0Rm9yQ2hhbmdlKHJhbmdlLmhlYWQsIGNoYW5nZSkpKVxcbiAgfVxcbiAgcmV0dXJuIG5vcm1hbGl6ZVNlbGVjdGlvbihvdXQsIGRvYy5zZWwucHJpbUluZGV4KVxcbn1cXG5cXG5mdW5jdGlvbiBvZmZzZXRQb3MocG9zLCBvbGQsIG53KSB7XFxuICBpZiAocG9zLmxpbmUgPT0gb2xkLmxpbmUpXFxuICAgIHsgcmV0dXJuIFBvcyhudy5saW5lLCBwb3MuY2ggLSBvbGQuY2ggKyBudy5jaCkgfVxcbiAgZWxzZVxcbiAgICB7IHJldHVybiBQb3MobncubGluZSArIChwb3MubGluZSAtIG9sZC5saW5lKSwgcG9zLmNoKSB9XFxufVxcblxcbi8vIFVzZWQgYnkgcmVwbGFjZVNlbGVjdGlvbnMgdG8gYWxsb3cgbW92aW5nIHRoZSBzZWxlY3Rpb24gdG8gdGhlXFxuLy8gc3RhcnQgb3IgYXJvdW5kIHRoZSByZXBsYWNlZCB0ZXN0LiBIaW50IG1heSBiZSBcXFwic3RhcnRcXFwiIG9yIFxcXCJhcm91bmRcXFwiLlxcbmZ1bmN0aW9uIGNvbXB1dGVSZXBsYWNlZFNlbChkb2MsIGNoYW5nZXMsIGhpbnQpIHtcXG4gIHZhciBvdXQgPSBbXVxcbiAgdmFyIG9sZFByZXYgPSBQb3MoZG9jLmZpcnN0LCAwKSwgbmV3UHJldiA9IG9sZFByZXZcXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY2hhbmdlcy5sZW5ndGg7IGkrKykge1xcbiAgICB2YXIgY2hhbmdlID0gY2hhbmdlc1tpXVxcbiAgICB2YXIgZnJvbSA9IG9mZnNldFBvcyhjaGFuZ2UuZnJvbSwgb2xkUHJldiwgbmV3UHJldilcXG4gICAgdmFyIHRvID0gb2Zmc2V0UG9zKGNoYW5nZUVuZChjaGFuZ2UpLCBvbGRQcmV2LCBuZXdQcmV2KVxcbiAgICBvbGRQcmV2ID0gY2hhbmdlLnRvXFxuICAgIG5ld1ByZXYgPSB0b1xcbiAgICBpZiAoaGludCA9PSBcXFwiYXJvdW5kXFxcIikge1xcbiAgICAgIHZhciByYW5nZSA9IGRvYy5zZWwucmFuZ2VzW2ldLCBpbnYgPSBjbXAocmFuZ2UuaGVhZCwgcmFuZ2UuYW5jaG9yKSA8IDBcXG4gICAgICBvdXRbaV0gPSBuZXcgUmFuZ2UoaW52ID8gdG8gOiBmcm9tLCBpbnYgPyBmcm9tIDogdG8pXFxuICAgIH0gZWxzZSB7XFxuICAgICAgb3V0W2ldID0gbmV3IFJhbmdlKGZyb20sIGZyb20pXFxuICAgIH1cXG4gIH1cXG4gIHJldHVybiBuZXcgU2VsZWN0aW9uKG91dCwgZG9jLnNlbC5wcmltSW5kZXgpXFxufVxcblxcbi8vIFVzZWQgdG8gZ2V0IHRoZSBlZGl0b3IgaW50byBhIGNvbnNpc3RlbnQgc3RhdGUgYWdhaW4gd2hlbiBvcHRpb25zIGNoYW5nZS5cXG5cXG5mdW5jdGlvbiBsb2FkTW9kZShjbSkge1xcbiAgY20uZG9jLm1vZGUgPSBnZXRNb2RlKGNtLm9wdGlvbnMsIGNtLmRvYy5tb2RlT3B0aW9uKVxcbiAgcmVzZXRNb2RlU3RhdGUoY20pXFxufVxcblxcbmZ1bmN0aW9uIHJlc2V0TW9kZVN0YXRlKGNtKSB7XFxuICBjbS5kb2MuaXRlcihmdW5jdGlvbiAobGluZSkge1xcbiAgICBpZiAobGluZS5zdGF0ZUFmdGVyKSB7IGxpbmUuc3RhdGVBZnRlciA9IG51bGwgfVxcbiAgICBpZiAobGluZS5zdHlsZXMpIHsgbGluZS5zdHlsZXMgPSBudWxsIH1cXG4gIH0pXFxuICBjbS5kb2MuZnJvbnRpZXIgPSBjbS5kb2MuZmlyc3RcXG4gIHN0YXJ0V29ya2VyKGNtLCAxMDApXFxuICBjbS5zdGF0ZS5tb2RlR2VuKytcXG4gIGlmIChjbS5jdXJPcCkgeyByZWdDaGFuZ2UoY20pIH1cXG59XFxuXFxuLy8gRE9DVU1FTlQgREFUQSBTVFJVQ1RVUkVcXG5cXG4vLyBCeSBkZWZhdWx0LCB1cGRhdGVzIHRoYXQgc3RhcnQgYW5kIGVuZCBhdCB0aGUgYmVnaW5uaW5nIG9mIGEgbGluZVxcbi8vIGFyZSB0cmVhdGVkIHNwZWNpYWxseSwgaW4gb3JkZXIgdG8gbWFrZSB0aGUgYXNzb2NpYXRpb24gb2YgbGluZVxcbi8vIHdpZGdldHMgYW5kIG1hcmtlciBlbGVtZW50cyB3aXRoIHRoZSB0ZXh0IGJlaGF2ZSBtb3JlIGludHVpdGl2ZS5cXG5mdW5jdGlvbiBpc1dob2xlTGluZVVwZGF0ZShkb2MsIGNoYW5nZSkge1xcbiAgcmV0dXJuIGNoYW5nZS5mcm9tLmNoID09IDAgJiYgY2hhbmdlLnRvLmNoID09IDAgJiYgbHN0KGNoYW5nZS50ZXh0KSA9PSBcXFwiXFxcIiAmJlxcbiAgICAoIWRvYy5jbSB8fCBkb2MuY20ub3B0aW9ucy53aG9sZUxpbmVVcGRhdGVCZWZvcmUpXFxufVxcblxcbi8vIFBlcmZvcm0gYSBjaGFuZ2Ugb24gdGhlIGRvY3VtZW50IGRhdGEgc3RydWN0dXJlLlxcbmZ1bmN0aW9uIHVwZGF0ZURvYyhkb2MsIGNoYW5nZSwgbWFya2VkU3BhbnMsIGVzdGltYXRlSGVpZ2h0KSB7XFxuICBmdW5jdGlvbiBzcGFuc0ZvcihuKSB7cmV0dXJuIG1hcmtlZFNwYW5zID8gbWFya2VkU3BhbnNbbl0gOiBudWxsfVxcbiAgZnVuY3Rpb24gdXBkYXRlKGxpbmUsIHRleHQsIHNwYW5zKSB7XFxuICAgIHVwZGF0ZUxpbmUobGluZSwgdGV4dCwgc3BhbnMsIGVzdGltYXRlSGVpZ2h0KVxcbiAgICBzaWduYWxMYXRlcihsaW5lLCBcXFwiY2hhbmdlXFxcIiwgbGluZSwgY2hhbmdlKVxcbiAgfVxcbiAgZnVuY3Rpb24gbGluZXNGb3Ioc3RhcnQsIGVuZCkge1xcbiAgICB2YXIgcmVzdWx0ID0gW11cXG4gICAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpXFxuICAgICAgeyByZXN1bHQucHVzaChuZXcgTGluZSh0ZXh0W2ldLCBzcGFuc0ZvcihpKSwgZXN0aW1hdGVIZWlnaHQpKSB9XFxuICAgIHJldHVybiByZXN1bHRcXG4gIH1cXG5cXG4gIHZhciBmcm9tID0gY2hhbmdlLmZyb20sIHRvID0gY2hhbmdlLnRvLCB0ZXh0ID0gY2hhbmdlLnRleHRcXG4gIHZhciBmaXJzdExpbmUgPSBnZXRMaW5lKGRvYywgZnJvbS5saW5lKSwgbGFzdExpbmUgPSBnZXRMaW5lKGRvYywgdG8ubGluZSlcXG4gIHZhciBsYXN0VGV4dCA9IGxzdCh0ZXh0KSwgbGFzdFNwYW5zID0gc3BhbnNGb3IodGV4dC5sZW5ndGggLSAxKSwgbmxpbmVzID0gdG8ubGluZSAtIGZyb20ubGluZVxcblxcbiAgLy8gQWRqdXN0IHRoZSBsaW5lIHN0cnVjdHVyZVxcbiAgaWYgKGNoYW5nZS5mdWxsKSB7XFxuICAgIGRvYy5pbnNlcnQoMCwgbGluZXNGb3IoMCwgdGV4dC5sZW5ndGgpKVxcbiAgICBkb2MucmVtb3ZlKHRleHQubGVuZ3RoLCBkb2Muc2l6ZSAtIHRleHQubGVuZ3RoKVxcbiAgfSBlbHNlIGlmIChpc1dob2xlTGluZVVwZGF0ZShkb2MsIGNoYW5nZSkpIHtcXG4gICAgLy8gVGhpcyBpcyBhIHdob2xlLWxpbmUgcmVwbGFjZS4gVHJlYXRlZCBzcGVjaWFsbHkgdG8gbWFrZVxcbiAgICAvLyBzdXJlIGxpbmUgb2JqZWN0cyBtb3ZlIHRoZSB3YXkgdGhleSBhcmUgc3VwcG9zZWQgdG8uXFxuICAgIHZhciBhZGRlZCA9IGxpbmVzRm9yKDAsIHRleHQubGVuZ3RoIC0gMSlcXG4gICAgdXBkYXRlKGxhc3RMaW5lLCBsYXN0TGluZS50ZXh0LCBsYXN0U3BhbnMpXFxuICAgIGlmIChubGluZXMpIHsgZG9jLnJlbW92ZShmcm9tLmxpbmUsIG5saW5lcykgfVxcbiAgICBpZiAoYWRkZWQubGVuZ3RoKSB7IGRvYy5pbnNlcnQoZnJvbS5saW5lLCBhZGRlZCkgfVxcbiAgfSBlbHNlIGlmIChmaXJzdExpbmUgPT0gbGFzdExpbmUpIHtcXG4gICAgaWYgKHRleHQubGVuZ3RoID09IDEpIHtcXG4gICAgICB1cGRhdGUoZmlyc3RMaW5lLCBmaXJzdExpbmUudGV4dC5zbGljZSgwLCBmcm9tLmNoKSArIGxhc3RUZXh0ICsgZmlyc3RMaW5lLnRleHQuc2xpY2UodG8uY2gpLCBsYXN0U3BhbnMpXFxuICAgIH0gZWxzZSB7XFxuICAgICAgdmFyIGFkZGVkJDEgPSBsaW5lc0ZvcigxLCB0ZXh0Lmxlbmd0aCAtIDEpXFxuICAgICAgYWRkZWQkMS5wdXNoKG5ldyBMaW5lKGxhc3RUZXh0ICsgZmlyc3RMaW5lLnRleHQuc2xpY2UodG8uY2gpLCBsYXN0U3BhbnMsIGVzdGltYXRlSGVpZ2h0KSlcXG4gICAgICB1cGRhdGUoZmlyc3RMaW5lLCBmaXJzdExpbmUudGV4dC5zbGljZSgwLCBmcm9tLmNoKSArIHRleHRbMF0sIHNwYW5zRm9yKDApKVxcbiAgICAgIGRvYy5pbnNlcnQoZnJvbS5saW5lICsgMSwgYWRkZWQkMSlcXG4gICAgfVxcbiAgfSBlbHNlIGlmICh0ZXh0Lmxlbmd0aCA9PSAxKSB7XFxuICAgIHVwZGF0ZShmaXJzdExpbmUsIGZpcnN0TGluZS50ZXh0LnNsaWNlKDAsIGZyb20uY2gpICsgdGV4dFswXSArIGxhc3RMaW5lLnRleHQuc2xpY2UodG8uY2gpLCBzcGFuc0ZvcigwKSlcXG4gICAgZG9jLnJlbW92ZShmcm9tLmxpbmUgKyAxLCBubGluZXMpXFxuICB9IGVsc2Uge1xcbiAgICB1cGRhdGUoZmlyc3RMaW5lLCBmaXJzdExpbmUudGV4dC5zbGljZSgwLCBmcm9tLmNoKSArIHRleHRbMF0sIHNwYW5zRm9yKDApKVxcbiAgICB1cGRhdGUobGFzdExpbmUsIGxhc3RUZXh0ICsgbGFzdExpbmUudGV4dC5zbGljZSh0by5jaCksIGxhc3RTcGFucylcXG4gICAgdmFyIGFkZGVkJDIgPSBsaW5lc0ZvcigxLCB0ZXh0Lmxlbmd0aCAtIDEpXFxuICAgIGlmIChubGluZXMgPiAxKSB7IGRvYy5yZW1vdmUoZnJvbS5saW5lICsgMSwgbmxpbmVzIC0gMSkgfVxcbiAgICBkb2MuaW5zZXJ0KGZyb20ubGluZSArIDEsIGFkZGVkJDIpXFxuICB9XFxuXFxuICBzaWduYWxMYXRlcihkb2MsIFxcXCJjaGFuZ2VcXFwiLCBkb2MsIGNoYW5nZSlcXG59XFxuXFxuLy8gQ2FsbCBmIGZvciBhbGwgbGlua2VkIGRvY3VtZW50cy5cXG5mdW5jdGlvbiBsaW5rZWREb2NzKGRvYywgZiwgc2hhcmVkSGlzdE9ubHkpIHtcXG4gIGZ1bmN0aW9uIHByb3BhZ2F0ZShkb2MsIHNraXAsIHNoYXJlZEhpc3QpIHtcXG4gICAgaWYgKGRvYy5saW5rZWQpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBkb2MubGlua2VkLmxlbmd0aDsgKytpKSB7XFxuICAgICAgdmFyIHJlbCA9IGRvYy5saW5rZWRbaV1cXG4gICAgICBpZiAocmVsLmRvYyA9PSBza2lwKSB7IGNvbnRpbnVlIH1cXG4gICAgICB2YXIgc2hhcmVkID0gc2hhcmVkSGlzdCAmJiByZWwuc2hhcmVkSGlzdFxcbiAgICAgIGlmIChzaGFyZWRIaXN0T25seSAmJiAhc2hhcmVkKSB7IGNvbnRpbnVlIH1cXG4gICAgICBmKHJlbC5kb2MsIHNoYXJlZClcXG4gICAgICBwcm9wYWdhdGUocmVsLmRvYywgZG9jLCBzaGFyZWQpXFxuICAgIH0gfVxcbiAgfVxcbiAgcHJvcGFnYXRlKGRvYywgbnVsbCwgdHJ1ZSlcXG59XFxuXFxuLy8gQXR0YWNoIGEgZG9jdW1lbnQgdG8gYW4gZWRpdG9yLlxcbmZ1bmN0aW9uIGF0dGFjaERvYyhjbSwgZG9jKSB7XFxuICBpZiAoZG9jLmNtKSB7IHRocm93IG5ldyBFcnJvcihcXFwiVGhpcyBkb2N1bWVudCBpcyBhbHJlYWR5IGluIHVzZS5cXFwiKSB9XFxuICBjbS5kb2MgPSBkb2NcXG4gIGRvYy5jbSA9IGNtXFxuICBlc3RpbWF0ZUxpbmVIZWlnaHRzKGNtKVxcbiAgbG9hZE1vZGUoY20pXFxuICBpZiAoIWNtLm9wdGlvbnMubGluZVdyYXBwaW5nKSB7IGZpbmRNYXhMaW5lKGNtKSB9XFxuICBjbS5vcHRpb25zLm1vZGUgPSBkb2MubW9kZU9wdGlvblxcbiAgcmVnQ2hhbmdlKGNtKVxcbn1cXG5cXG5mdW5jdGlvbiBIaXN0b3J5KHN0YXJ0R2VuKSB7XFxuICAvLyBBcnJheXMgb2YgY2hhbmdlIGV2ZW50cyBhbmQgc2VsZWN0aW9ucy4gRG9pbmcgc29tZXRoaW5nIGFkZHMgYW5cXG4gIC8vIGV2ZW50IHRvIGRvbmUgYW5kIGNsZWFycyB1bmRvLiBVbmRvaW5nIG1vdmVzIGV2ZW50cyBmcm9tIGRvbmVcXG4gIC8vIHRvIHVuZG9uZSwgcmVkb2luZyBtb3ZlcyB0aGVtIGluIHRoZSBvdGhlciBkaXJlY3Rpb24uXFxuICB0aGlzLmRvbmUgPSBbXTsgdGhpcy51bmRvbmUgPSBbXVxcbiAgdGhpcy51bmRvRGVwdGggPSBJbmZpbml0eVxcbiAgLy8gVXNlZCB0byB0cmFjayB3aGVuIGNoYW5nZXMgY2FuIGJlIG1lcmdlZCBpbnRvIGEgc2luZ2xlIHVuZG9cXG4gIC8vIGV2ZW50XFxuICB0aGlzLmxhc3RNb2RUaW1lID0gdGhpcy5sYXN0U2VsVGltZSA9IDBcXG4gIHRoaXMubGFzdE9wID0gdGhpcy5sYXN0U2VsT3AgPSBudWxsXFxuICB0aGlzLmxhc3RPcmlnaW4gPSB0aGlzLmxhc3RTZWxPcmlnaW4gPSBudWxsXFxuICAvLyBVc2VkIGJ5IHRoZSBpc0NsZWFuKCkgbWV0aG9kXFxuICB0aGlzLmdlbmVyYXRpb24gPSB0aGlzLm1heEdlbmVyYXRpb24gPSBzdGFydEdlbiB8fCAxXFxufVxcblxcbi8vIENyZWF0ZSBhIGhpc3RvcnkgY2hhbmdlIGV2ZW50IGZyb20gYW4gdXBkYXRlRG9jLXN0eWxlIGNoYW5nZVxcbi8vIG9iamVjdC5cXG5mdW5jdGlvbiBoaXN0b3J5Q2hhbmdlRnJvbUNoYW5nZShkb2MsIGNoYW5nZSkge1xcbiAgdmFyIGhpc3RDaGFuZ2UgPSB7ZnJvbTogY29weVBvcyhjaGFuZ2UuZnJvbSksIHRvOiBjaGFuZ2VFbmQoY2hhbmdlKSwgdGV4dDogZ2V0QmV0d2Vlbihkb2MsIGNoYW5nZS5mcm9tLCBjaGFuZ2UudG8pfVxcbiAgYXR0YWNoTG9jYWxTcGFucyhkb2MsIGhpc3RDaGFuZ2UsIGNoYW5nZS5mcm9tLmxpbmUsIGNoYW5nZS50by5saW5lICsgMSlcXG4gIGxpbmtlZERvY3MoZG9jLCBmdW5jdGlvbiAoZG9jKSB7IHJldHVybiBhdHRhY2hMb2NhbFNwYW5zKGRvYywgaGlzdENoYW5nZSwgY2hhbmdlLmZyb20ubGluZSwgY2hhbmdlLnRvLmxpbmUgKyAxKTsgfSwgdHJ1ZSlcXG4gIHJldHVybiBoaXN0Q2hhbmdlXFxufVxcblxcbi8vIFBvcCBhbGwgc2VsZWN0aW9uIGV2ZW50cyBvZmYgdGhlIGVuZCBvZiBhIGhpc3RvcnkgYXJyYXkuIFN0b3AgYXRcXG4vLyBhIGNoYW5nZSBldmVudC5cXG5mdW5jdGlvbiBjbGVhclNlbGVjdGlvbkV2ZW50cyhhcnJheSkge1xcbiAgd2hpbGUgKGFycmF5Lmxlbmd0aCkge1xcbiAgICB2YXIgbGFzdCA9IGxzdChhcnJheSlcXG4gICAgaWYgKGxhc3QucmFuZ2VzKSB7IGFycmF5LnBvcCgpIH1cXG4gICAgZWxzZSB7IGJyZWFrIH1cXG4gIH1cXG59XFxuXFxuLy8gRmluZCB0aGUgdG9wIGNoYW5nZSBldmVudCBpbiB0aGUgaGlzdG9yeS4gUG9wIG9mZiBzZWxlY3Rpb25cXG4vLyBldmVudHMgdGhhdCBhcmUgaW4gdGhlIHdheS5cXG5mdW5jdGlvbiBsYXN0Q2hhbmdlRXZlbnQoaGlzdCwgZm9yY2UpIHtcXG4gIGlmIChmb3JjZSkge1xcbiAgICBjbGVhclNlbGVjdGlvbkV2ZW50cyhoaXN0LmRvbmUpXFxuICAgIHJldHVybiBsc3QoaGlzdC5kb25lKVxcbiAgfSBlbHNlIGlmIChoaXN0LmRvbmUubGVuZ3RoICYmICFsc3QoaGlzdC5kb25lKS5yYW5nZXMpIHtcXG4gICAgcmV0dXJuIGxzdChoaXN0LmRvbmUpXFxuICB9IGVsc2UgaWYgKGhpc3QuZG9uZS5sZW5ndGggPiAxICYmICFoaXN0LmRvbmVbaGlzdC5kb25lLmxlbmd0aCAtIDJdLnJhbmdlcykge1xcbiAgICBoaXN0LmRvbmUucG9wKClcXG4gICAgcmV0dXJuIGxzdChoaXN0LmRvbmUpXFxuICB9XFxufVxcblxcbi8vIFJlZ2lzdGVyIGEgY2hhbmdlIGluIHRoZSBoaXN0b3J5LiBNZXJnZXMgY2hhbmdlcyB0aGF0IGFyZSB3aXRoaW5cXG4vLyBhIHNpbmdsZSBvcGVyYXRpb24sIG9yIGFyZSBjbG9zZSB0b2dldGhlciB3aXRoIGFuIG9yaWdpbiB0aGF0XFxuLy8gYWxsb3dzIG1lcmdpbmcgKHN0YXJ0aW5nIHdpdGggXFxcIitcXFwiKSBpbnRvIGEgc2luZ2xlIGV2ZW50LlxcbmZ1bmN0aW9uIGFkZENoYW5nZVRvSGlzdG9yeShkb2MsIGNoYW5nZSwgc2VsQWZ0ZXIsIG9wSWQpIHtcXG4gIHZhciBoaXN0ID0gZG9jLmhpc3RvcnlcXG4gIGhpc3QudW5kb25lLmxlbmd0aCA9IDBcXG4gIHZhciB0aW1lID0gK25ldyBEYXRlLCBjdXJcXG4gIHZhciBsYXN0XFxuXFxuICBpZiAoKGhpc3QubGFzdE9wID09IG9wSWQgfHxcXG4gICAgICAgaGlzdC5sYXN0T3JpZ2luID09IGNoYW5nZS5vcmlnaW4gJiYgY2hhbmdlLm9yaWdpbiAmJlxcbiAgICAgICAoKGNoYW5nZS5vcmlnaW4uY2hhckF0KDApID09IFxcXCIrXFxcIiAmJiBkb2MuY20gJiYgaGlzdC5sYXN0TW9kVGltZSA+IHRpbWUgLSBkb2MuY20ub3B0aW9ucy5oaXN0b3J5RXZlbnREZWxheSkgfHxcXG4gICAgICAgIGNoYW5nZS5vcmlnaW4uY2hhckF0KDApID09IFxcXCIqXFxcIikpICYmXFxuICAgICAgKGN1ciA9IGxhc3RDaGFuZ2VFdmVudChoaXN0LCBoaXN0Lmxhc3RPcCA9PSBvcElkKSkpIHtcXG4gICAgLy8gTWVyZ2UgdGhpcyBjaGFuZ2UgaW50byB0aGUgbGFzdCBldmVudFxcbiAgICBsYXN0ID0gbHN0KGN1ci5jaGFuZ2VzKVxcbiAgICBpZiAoY21wKGNoYW5nZS5mcm9tLCBjaGFuZ2UudG8pID09IDAgJiYgY21wKGNoYW5nZS5mcm9tLCBsYXN0LnRvKSA9PSAwKSB7XFxuICAgICAgLy8gT3B0aW1pemVkIGNhc2UgZm9yIHNpbXBsZSBpbnNlcnRpb24gLS0gZG9uJ3Qgd2FudCB0byBhZGRcXG4gICAgICAvLyBuZXcgY2hhbmdlc2V0cyBmb3IgZXZlcnkgY2hhcmFjdGVyIHR5cGVkXFxuICAgICAgbGFzdC50byA9IGNoYW5nZUVuZChjaGFuZ2UpXFxuICAgIH0gZWxzZSB7XFxuICAgICAgLy8gQWRkIG5ldyBzdWItZXZlbnRcXG4gICAgICBjdXIuY2hhbmdlcy5wdXNoKGhpc3RvcnlDaGFuZ2VGcm9tQ2hhbmdlKGRvYywgY2hhbmdlKSlcXG4gICAgfVxcbiAgfSBlbHNlIHtcXG4gICAgLy8gQ2FuIG5vdCBiZSBtZXJnZWQsIHN0YXJ0IGEgbmV3IGV2ZW50LlxcbiAgICB2YXIgYmVmb3JlID0gbHN0KGhpc3QuZG9uZSlcXG4gICAgaWYgKCFiZWZvcmUgfHwgIWJlZm9yZS5yYW5nZXMpXFxuICAgICAgeyBwdXNoU2VsZWN0aW9uVG9IaXN0b3J5KGRvYy5zZWwsIGhpc3QuZG9uZSkgfVxcbiAgICBjdXIgPSB7Y2hhbmdlczogW2hpc3RvcnlDaGFuZ2VGcm9tQ2hhbmdlKGRvYywgY2hhbmdlKV0sXFxuICAgICAgICAgICBnZW5lcmF0aW9uOiBoaXN0LmdlbmVyYXRpb259XFxuICAgIGhpc3QuZG9uZS5wdXNoKGN1cilcXG4gICAgd2hpbGUgKGhpc3QuZG9uZS5sZW5ndGggPiBoaXN0LnVuZG9EZXB0aCkge1xcbiAgICAgIGhpc3QuZG9uZS5zaGlmdCgpXFxuICAgICAgaWYgKCFoaXN0LmRvbmVbMF0ucmFuZ2VzKSB7IGhpc3QuZG9uZS5zaGlmdCgpIH1cXG4gICAgfVxcbiAgfVxcbiAgaGlzdC5kb25lLnB1c2goc2VsQWZ0ZXIpXFxuICBoaXN0LmdlbmVyYXRpb24gPSArK2hpc3QubWF4R2VuZXJhdGlvblxcbiAgaGlzdC5sYXN0TW9kVGltZSA9IGhpc3QubGFzdFNlbFRpbWUgPSB0aW1lXFxuICBoaXN0Lmxhc3RPcCA9IGhpc3QubGFzdFNlbE9wID0gb3BJZFxcbiAgaGlzdC5sYXN0T3JpZ2luID0gaGlzdC5sYXN0U2VsT3JpZ2luID0gY2hhbmdlLm9yaWdpblxcblxcbiAgaWYgKCFsYXN0KSB7IHNpZ25hbChkb2MsIFxcXCJoaXN0b3J5QWRkZWRcXFwiKSB9XFxufVxcblxcbmZ1bmN0aW9uIHNlbGVjdGlvbkV2ZW50Q2FuQmVNZXJnZWQoZG9jLCBvcmlnaW4sIHByZXYsIHNlbCkge1xcbiAgdmFyIGNoID0gb3JpZ2luLmNoYXJBdCgwKVxcbiAgcmV0dXJuIGNoID09IFxcXCIqXFxcIiB8fFxcbiAgICBjaCA9PSBcXFwiK1xcXCIgJiZcXG4gICAgcHJldi5yYW5nZXMubGVuZ3RoID09IHNlbC5yYW5nZXMubGVuZ3RoICYmXFxuICAgIHByZXYuc29tZXRoaW5nU2VsZWN0ZWQoKSA9PSBzZWwuc29tZXRoaW5nU2VsZWN0ZWQoKSAmJlxcbiAgICBuZXcgRGF0ZSAtIGRvYy5oaXN0b3J5Lmxhc3RTZWxUaW1lIDw9IChkb2MuY20gPyBkb2MuY20ub3B0aW9ucy5oaXN0b3J5RXZlbnREZWxheSA6IDUwMClcXG59XFxuXFxuLy8gQ2FsbGVkIHdoZW5ldmVyIHRoZSBzZWxlY3Rpb24gY2hhbmdlcywgc2V0cyB0aGUgbmV3IHNlbGVjdGlvbiBhc1xcbi8vIHRoZSBwZW5kaW5nIHNlbGVjdGlvbiBpbiB0aGUgaGlzdG9yeSwgYW5kIHB1c2hlcyB0aGUgb2xkIHBlbmRpbmdcXG4vLyBzZWxlY3Rpb24gaW50byB0aGUgJ2RvbmUnIGFycmF5IHdoZW4gaXQgd2FzIHNpZ25pZmljYW50bHlcXG4vLyBkaWZmZXJlbnQgKGluIG51bWJlciBvZiBzZWxlY3RlZCByYW5nZXMsIGVtcHRpbmVzcywgb3IgdGltZSkuXFxuZnVuY3Rpb24gYWRkU2VsZWN0aW9uVG9IaXN0b3J5KGRvYywgc2VsLCBvcElkLCBvcHRpb25zKSB7XFxuICB2YXIgaGlzdCA9IGRvYy5oaXN0b3J5LCBvcmlnaW4gPSBvcHRpb25zICYmIG9wdGlvbnMub3JpZ2luXFxuXFxuICAvLyBBIG5ldyBldmVudCBpcyBzdGFydGVkIHdoZW4gdGhlIHByZXZpb3VzIG9yaWdpbiBkb2VzIG5vdCBtYXRjaFxcbiAgLy8gdGhlIGN1cnJlbnQsIG9yIHRoZSBvcmlnaW5zIGRvbid0IGFsbG93IG1hdGNoaW5nLiBPcmlnaW5zXFxuICAvLyBzdGFydGluZyB3aXRoICogYXJlIGFsd2F5cyBtZXJnZWQsIHRob3NlIHN0YXJ0aW5nIHdpdGggKyBhcmVcXG4gIC8vIG1lcmdlZCB3aGVuIHNpbWlsYXIgYW5kIGNsb3NlIHRvZ2V0aGVyIGluIHRpbWUuXFxuICBpZiAob3BJZCA9PSBoaXN0Lmxhc3RTZWxPcCB8fFxcbiAgICAgIChvcmlnaW4gJiYgaGlzdC5sYXN0U2VsT3JpZ2luID09IG9yaWdpbiAmJlxcbiAgICAgICAoaGlzdC5sYXN0TW9kVGltZSA9PSBoaXN0Lmxhc3RTZWxUaW1lICYmIGhpc3QubGFzdE9yaWdpbiA9PSBvcmlnaW4gfHxcXG4gICAgICAgIHNlbGVjdGlvbkV2ZW50Q2FuQmVNZXJnZWQoZG9jLCBvcmlnaW4sIGxzdChoaXN0LmRvbmUpLCBzZWwpKSkpXFxuICAgIHsgaGlzdC5kb25lW2hpc3QuZG9uZS5sZW5ndGggLSAxXSA9IHNlbCB9XFxuICBlbHNlXFxuICAgIHsgcHVzaFNlbGVjdGlvblRvSGlzdG9yeShzZWwsIGhpc3QuZG9uZSkgfVxcblxcbiAgaGlzdC5sYXN0U2VsVGltZSA9ICtuZXcgRGF0ZVxcbiAgaGlzdC5sYXN0U2VsT3JpZ2luID0gb3JpZ2luXFxuICBoaXN0Lmxhc3RTZWxPcCA9IG9wSWRcXG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMuY2xlYXJSZWRvICE9PSBmYWxzZSlcXG4gICAgeyBjbGVhclNlbGVjdGlvbkV2ZW50cyhoaXN0LnVuZG9uZSkgfVxcbn1cXG5cXG5mdW5jdGlvbiBwdXNoU2VsZWN0aW9uVG9IaXN0b3J5KHNlbCwgZGVzdCkge1xcbiAgdmFyIHRvcCA9IGxzdChkZXN0KVxcbiAgaWYgKCEodG9wICYmIHRvcC5yYW5nZXMgJiYgdG9wLmVxdWFscyhzZWwpKSlcXG4gICAgeyBkZXN0LnB1c2goc2VsKSB9XFxufVxcblxcbi8vIFVzZWQgdG8gc3RvcmUgbWFya2VkIHNwYW4gaW5mb3JtYXRpb24gaW4gdGhlIGhpc3RvcnkuXFxuZnVuY3Rpb24gYXR0YWNoTG9jYWxTcGFucyhkb2MsIGNoYW5nZSwgZnJvbSwgdG8pIHtcXG4gIHZhciBleGlzdGluZyA9IGNoYW5nZVtcXFwic3BhbnNfXFxcIiArIGRvYy5pZF0sIG4gPSAwXFxuICBkb2MuaXRlcihNYXRoLm1heChkb2MuZmlyc3QsIGZyb20pLCBNYXRoLm1pbihkb2MuZmlyc3QgKyBkb2Muc2l6ZSwgdG8pLCBmdW5jdGlvbiAobGluZSkge1xcbiAgICBpZiAobGluZS5tYXJrZWRTcGFucylcXG4gICAgICB7IChleGlzdGluZyB8fCAoZXhpc3RpbmcgPSBjaGFuZ2VbXFxcInNwYW5zX1xcXCIgKyBkb2MuaWRdID0ge30pKVtuXSA9IGxpbmUubWFya2VkU3BhbnMgfVxcbiAgICArK25cXG4gIH0pXFxufVxcblxcbi8vIFdoZW4gdW4vcmUtZG9pbmcgcmVzdG9yZXMgdGV4dCBjb250YWluaW5nIG1hcmtlZCBzcGFucywgdGhvc2VcXG4vLyB0aGF0IGhhdmUgYmVlbiBleHBsaWNpdGx5IGNsZWFyZWQgc2hvdWxkIG5vdCBiZSByZXN0b3JlZC5cXG5mdW5jdGlvbiByZW1vdmVDbGVhcmVkU3BhbnMoc3BhbnMpIHtcXG4gIGlmICghc3BhbnMpIHsgcmV0dXJuIG51bGwgfVxcbiAgdmFyIG91dFxcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzcGFucy5sZW5ndGg7ICsraSkge1xcbiAgICBpZiAoc3BhbnNbaV0ubWFya2VyLmV4cGxpY2l0bHlDbGVhcmVkKSB7IGlmICghb3V0KSB7IG91dCA9IHNwYW5zLnNsaWNlKDAsIGkpIH0gfVxcbiAgICBlbHNlIGlmIChvdXQpIHsgb3V0LnB1c2goc3BhbnNbaV0pIH1cXG4gIH1cXG4gIHJldHVybiAhb3V0ID8gc3BhbnMgOiBvdXQubGVuZ3RoID8gb3V0IDogbnVsbFxcbn1cXG5cXG4vLyBSZXRyaWV2ZSBhbmQgZmlsdGVyIHRoZSBvbGQgbWFya2VkIHNwYW5zIHN0b3JlZCBpbiBhIGNoYW5nZSBldmVudC5cXG5mdW5jdGlvbiBnZXRPbGRTcGFucyhkb2MsIGNoYW5nZSkge1xcbiAgdmFyIGZvdW5kID0gY2hhbmdlW1xcXCJzcGFuc19cXFwiICsgZG9jLmlkXVxcbiAgaWYgKCFmb3VuZCkgeyByZXR1cm4gbnVsbCB9XFxuICB2YXIgbncgPSBbXVxcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGFuZ2UudGV4dC5sZW5ndGg7ICsraSlcXG4gICAgeyBudy5wdXNoKHJlbW92ZUNsZWFyZWRTcGFucyhmb3VuZFtpXSkpIH1cXG4gIHJldHVybiBud1xcbn1cXG5cXG4vLyBVc2VkIGZvciB1bi9yZS1kb2luZyBjaGFuZ2VzIGZyb20gdGhlIGhpc3RvcnkuIENvbWJpbmVzIHRoZVxcbi8vIHJlc3VsdCBvZiBjb21wdXRpbmcgdGhlIGV4aXN0aW5nIHNwYW5zIHdpdGggdGhlIHNldCBvZiBzcGFucyB0aGF0XFxuLy8gZXhpc3RlZCBpbiB0aGUgaGlzdG9yeSAoc28gdGhhdCBkZWxldGluZyBhcm91bmQgYSBzcGFuIGFuZCB0aGVuXFxuLy8gdW5kb2luZyBicmluZ3MgYmFjayB0aGUgc3BhbikuXFxuZnVuY3Rpb24gbWVyZ2VPbGRTcGFucyhkb2MsIGNoYW5nZSkge1xcbiAgdmFyIG9sZCA9IGdldE9sZFNwYW5zKGRvYywgY2hhbmdlKVxcbiAgdmFyIHN0cmV0Y2hlZCA9IHN0cmV0Y2hTcGFuc092ZXJDaGFuZ2UoZG9jLCBjaGFuZ2UpXFxuICBpZiAoIW9sZCkgeyByZXR1cm4gc3RyZXRjaGVkIH1cXG4gIGlmICghc3RyZXRjaGVkKSB7IHJldHVybiBvbGQgfVxcblxcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBvbGQubGVuZ3RoOyArK2kpIHtcXG4gICAgdmFyIG9sZEN1ciA9IG9sZFtpXSwgc3RyZXRjaEN1ciA9IHN0cmV0Y2hlZFtpXVxcbiAgICBpZiAob2xkQ3VyICYmIHN0cmV0Y2hDdXIpIHtcXG4gICAgICBzcGFuczogZm9yICh2YXIgaiA9IDA7IGogPCBzdHJldGNoQ3VyLmxlbmd0aDsgKytqKSB7XFxuICAgICAgICB2YXIgc3BhbiA9IHN0cmV0Y2hDdXJbal1cXG4gICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgb2xkQ3VyLmxlbmd0aDsgKytrKVxcbiAgICAgICAgICB7IGlmIChvbGRDdXJba10ubWFya2VyID09IHNwYW4ubWFya2VyKSB7IGNvbnRpbnVlIHNwYW5zIH0gfVxcbiAgICAgICAgb2xkQ3VyLnB1c2goc3BhbilcXG4gICAgICB9XFxuICAgIH0gZWxzZSBpZiAoc3RyZXRjaEN1cikge1xcbiAgICAgIG9sZFtpXSA9IHN0cmV0Y2hDdXJcXG4gICAgfVxcbiAgfVxcbiAgcmV0dXJuIG9sZFxcbn1cXG5cXG4vLyBVc2VkIGJvdGggdG8gcHJvdmlkZSBhIEpTT04tc2FmZSBvYmplY3QgaW4gLmdldEhpc3RvcnksIGFuZCwgd2hlblxcbi8vIGRldGFjaGluZyBhIGRvY3VtZW50LCB0byBzcGxpdCB0aGUgaGlzdG9yeSBpbiB0d29cXG5mdW5jdGlvbiBjb3B5SGlzdG9yeUFycmF5KGV2ZW50cywgbmV3R3JvdXAsIGluc3RhbnRpYXRlU2VsKSB7XFxuICB2YXIgY29weSA9IFtdXFxuICBmb3IgKHZhciBpID0gMDsgaSA8IGV2ZW50cy5sZW5ndGg7ICsraSkge1xcbiAgICB2YXIgZXZlbnQgPSBldmVudHNbaV1cXG4gICAgaWYgKGV2ZW50LnJhbmdlcykge1xcbiAgICAgIGNvcHkucHVzaChpbnN0YW50aWF0ZVNlbCA/IFNlbGVjdGlvbi5wcm90b3R5cGUuZGVlcENvcHkuY2FsbChldmVudCkgOiBldmVudClcXG4gICAgICBjb250aW51ZVxcbiAgICB9XFxuICAgIHZhciBjaGFuZ2VzID0gZXZlbnQuY2hhbmdlcywgbmV3Q2hhbmdlcyA9IFtdXFxuICAgIGNvcHkucHVzaCh7Y2hhbmdlczogbmV3Q2hhbmdlc30pXFxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgY2hhbmdlcy5sZW5ndGg7ICsraikge1xcbiAgICAgIHZhciBjaGFuZ2UgPSBjaGFuZ2VzW2pdLCBtID0gKHZvaWQgMClcXG4gICAgICBuZXdDaGFuZ2VzLnB1c2goe2Zyb206IGNoYW5nZS5mcm9tLCB0bzogY2hhbmdlLnRvLCB0ZXh0OiBjaGFuZ2UudGV4dH0pXFxuICAgICAgaWYgKG5ld0dyb3VwKSB7IGZvciAodmFyIHByb3AgaW4gY2hhbmdlKSB7IGlmIChtID0gcHJvcC5tYXRjaCgvXnNwYW5zXyhcXFxcZCspJC8pKSB7XFxuICAgICAgICBpZiAoaW5kZXhPZihuZXdHcm91cCwgTnVtYmVyKG1bMV0pKSA+IC0xKSB7XFxuICAgICAgICAgIGxzdChuZXdDaGFuZ2VzKVtwcm9wXSA9IGNoYW5nZVtwcm9wXVxcbiAgICAgICAgICBkZWxldGUgY2hhbmdlW3Byb3BdXFxuICAgICAgICB9XFxuICAgICAgfSB9IH1cXG4gICAgfVxcbiAgfVxcbiAgcmV0dXJuIGNvcHlcXG59XFxuXFxuLy8gVGhlICdzY3JvbGwnIHBhcmFtZXRlciBnaXZlbiB0byBtYW55IG9mIHRoZXNlIGluZGljYXRlZCB3aGV0aGVyXFxuLy8gdGhlIG5ldyBjdXJzb3IgcG9zaXRpb24gc2hvdWxkIGJlIHNjcm9sbGVkIGludG8gdmlldyBhZnRlclxcbi8vIG1vZGlmeWluZyB0aGUgc2VsZWN0aW9uLlxcblxcbi8vIElmIHNoaWZ0IGlzIGhlbGQgb3IgdGhlIGV4dGVuZCBmbGFnIGlzIHNldCwgZXh0ZW5kcyBhIHJhbmdlIHRvXFxuLy8gaW5jbHVkZSBhIGdpdmVuIHBvc2l0aW9uIChhbmQgb3B0aW9uYWxseSBhIHNlY29uZCBwb3NpdGlvbikuXFxuLy8gT3RoZXJ3aXNlLCBzaW1wbHkgcmV0dXJucyB0aGUgcmFuZ2UgYmV0d2VlbiB0aGUgZ2l2ZW4gcG9zaXRpb25zLlxcbi8vIFVzZWQgZm9yIGN1cnNvciBtb3Rpb24gYW5kIHN1Y2guXFxuZnVuY3Rpb24gZXh0ZW5kUmFuZ2UoZG9jLCByYW5nZSwgaGVhZCwgb3RoZXIpIHtcXG4gIGlmIChkb2MuY20gJiYgZG9jLmNtLmRpc3BsYXkuc2hpZnQgfHwgZG9jLmV4dGVuZCkge1xcbiAgICB2YXIgYW5jaG9yID0gcmFuZ2UuYW5jaG9yXFxuICAgIGlmIChvdGhlcikge1xcbiAgICAgIHZhciBwb3NCZWZvcmUgPSBjbXAoaGVhZCwgYW5jaG9yKSA8IDBcXG4gICAgICBpZiAocG9zQmVmb3JlICE9IChjbXAob3RoZXIsIGFuY2hvcikgPCAwKSkge1xcbiAgICAgICAgYW5jaG9yID0gaGVhZFxcbiAgICAgICAgaGVhZCA9IG90aGVyXFxuICAgICAgfSBlbHNlIGlmIChwb3NCZWZvcmUgIT0gKGNtcChoZWFkLCBvdGhlcikgPCAwKSkge1xcbiAgICAgICAgaGVhZCA9IG90aGVyXFxuICAgICAgfVxcbiAgICB9XFxuICAgIHJldHVybiBuZXcgUmFuZ2UoYW5jaG9yLCBoZWFkKVxcbiAgfSBlbHNlIHtcXG4gICAgcmV0dXJuIG5ldyBSYW5nZShvdGhlciB8fCBoZWFkLCBoZWFkKVxcbiAgfVxcbn1cXG5cXG4vLyBFeHRlbmQgdGhlIHByaW1hcnkgc2VsZWN0aW9uIHJhbmdlLCBkaXNjYXJkIHRoZSByZXN0LlxcbmZ1bmN0aW9uIGV4dGVuZFNlbGVjdGlvbihkb2MsIGhlYWQsIG90aGVyLCBvcHRpb25zKSB7XFxuICBzZXRTZWxlY3Rpb24oZG9jLCBuZXcgU2VsZWN0aW9uKFtleHRlbmRSYW5nZShkb2MsIGRvYy5zZWwucHJpbWFyeSgpLCBoZWFkLCBvdGhlcildLCAwKSwgb3B0aW9ucylcXG59XFxuXFxuLy8gRXh0ZW5kIGFsbCBzZWxlY3Rpb25zIChwb3MgaXMgYW4gYXJyYXkgb2Ygc2VsZWN0aW9ucyB3aXRoIGxlbmd0aFxcbi8vIGVxdWFsIHRoZSBudW1iZXIgb2Ygc2VsZWN0aW9ucylcXG5mdW5jdGlvbiBleHRlbmRTZWxlY3Rpb25zKGRvYywgaGVhZHMsIG9wdGlvbnMpIHtcXG4gIHZhciBvdXQgPSBbXVxcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBkb2Muc2VsLnJhbmdlcy5sZW5ndGg7IGkrKylcXG4gICAgeyBvdXRbaV0gPSBleHRlbmRSYW5nZShkb2MsIGRvYy5zZWwucmFuZ2VzW2ldLCBoZWFkc1tpXSwgbnVsbCkgfVxcbiAgdmFyIG5ld1NlbCA9IG5vcm1hbGl6ZVNlbGVjdGlvbihvdXQsIGRvYy5zZWwucHJpbUluZGV4KVxcbiAgc2V0U2VsZWN0aW9uKGRvYywgbmV3U2VsLCBvcHRpb25zKVxcbn1cXG5cXG4vLyBVcGRhdGVzIGEgc2luZ2xlIHJhbmdlIGluIHRoZSBzZWxlY3Rpb24uXFxuZnVuY3Rpb24gcmVwbGFjZU9uZVNlbGVjdGlvbihkb2MsIGksIHJhbmdlLCBvcHRpb25zKSB7XFxuICB2YXIgcmFuZ2VzID0gZG9jLnNlbC5yYW5nZXMuc2xpY2UoMClcXG4gIHJhbmdlc1tpXSA9IHJhbmdlXFxuICBzZXRTZWxlY3Rpb24oZG9jLCBub3JtYWxpemVTZWxlY3Rpb24ocmFuZ2VzLCBkb2Muc2VsLnByaW1JbmRleCksIG9wdGlvbnMpXFxufVxcblxcbi8vIFJlc2V0IHRoZSBzZWxlY3Rpb24gdG8gYSBzaW5nbGUgcmFuZ2UuXFxuZnVuY3Rpb24gc2V0U2ltcGxlU2VsZWN0aW9uKGRvYywgYW5jaG9yLCBoZWFkLCBvcHRpb25zKSB7XFxuICBzZXRTZWxlY3Rpb24oZG9jLCBzaW1wbGVTZWxlY3Rpb24oYW5jaG9yLCBoZWFkKSwgb3B0aW9ucylcXG59XFxuXFxuLy8gR2l2ZSBiZWZvcmVTZWxlY3Rpb25DaGFuZ2UgaGFuZGxlcnMgYSBjaGFuZ2UgdG8gaW5mbHVlbmNlIGFcXG4vLyBzZWxlY3Rpb24gdXBkYXRlLlxcbmZ1bmN0aW9uIGZpbHRlclNlbGVjdGlvbkNoYW5nZShkb2MsIHNlbCwgb3B0aW9ucykge1xcbiAgdmFyIG9iaiA9IHtcXG4gICAgcmFuZ2VzOiBzZWwucmFuZ2VzLFxcbiAgICB1cGRhdGU6IGZ1bmN0aW9uKHJhbmdlcykge1xcbiAgICAgIHZhciB0aGlzJDEgPSB0aGlzO1xcblxcbiAgICAgIHRoaXMucmFuZ2VzID0gW11cXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJhbmdlcy5sZW5ndGg7IGkrKylcXG4gICAgICAgIHsgdGhpcyQxLnJhbmdlc1tpXSA9IG5ldyBSYW5nZShjbGlwUG9zKGRvYywgcmFuZ2VzW2ldLmFuY2hvciksXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGlwUG9zKGRvYywgcmFuZ2VzW2ldLmhlYWQpKSB9XFxuICAgIH0sXFxuICAgIG9yaWdpbjogb3B0aW9ucyAmJiBvcHRpb25zLm9yaWdpblxcbiAgfVxcbiAgc2lnbmFsKGRvYywgXFxcImJlZm9yZVNlbGVjdGlvbkNoYW5nZVxcXCIsIGRvYywgb2JqKVxcbiAgaWYgKGRvYy5jbSkgeyBzaWduYWwoZG9jLmNtLCBcXFwiYmVmb3JlU2VsZWN0aW9uQ2hhbmdlXFxcIiwgZG9jLmNtLCBvYmopIH1cXG4gIGlmIChvYmoucmFuZ2VzICE9IHNlbC5yYW5nZXMpIHsgcmV0dXJuIG5vcm1hbGl6ZVNlbGVjdGlvbihvYmoucmFuZ2VzLCBvYmoucmFuZ2VzLmxlbmd0aCAtIDEpIH1cXG4gIGVsc2UgeyByZXR1cm4gc2VsIH1cXG59XFxuXFxuZnVuY3Rpb24gc2V0U2VsZWN0aW9uUmVwbGFjZUhpc3RvcnkoZG9jLCBzZWwsIG9wdGlvbnMpIHtcXG4gIHZhciBkb25lID0gZG9jLmhpc3RvcnkuZG9uZSwgbGFzdCA9IGxzdChkb25lKVxcbiAgaWYgKGxhc3QgJiYgbGFzdC5yYW5nZXMpIHtcXG4gICAgZG9uZVtkb25lLmxlbmd0aCAtIDFdID0gc2VsXFxuICAgIHNldFNlbGVjdGlvbk5vVW5kbyhkb2MsIHNlbCwgb3B0aW9ucylcXG4gIH0gZWxzZSB7XFxuICAgIHNldFNlbGVjdGlvbihkb2MsIHNlbCwgb3B0aW9ucylcXG4gIH1cXG59XFxuXFxuLy8gU2V0IGEgbmV3IHNlbGVjdGlvbi5cXG5mdW5jdGlvbiBzZXRTZWxlY3Rpb24oZG9jLCBzZWwsIG9wdGlvbnMpIHtcXG4gIHNldFNlbGVjdGlvbk5vVW5kbyhkb2MsIHNlbCwgb3B0aW9ucylcXG4gIGFkZFNlbGVjdGlvblRvSGlzdG9yeShkb2MsIGRvYy5zZWwsIGRvYy5jbSA/IGRvYy5jbS5jdXJPcC5pZCA6IE5hTiwgb3B0aW9ucylcXG59XFxuXFxuZnVuY3Rpb24gc2V0U2VsZWN0aW9uTm9VbmRvKGRvYywgc2VsLCBvcHRpb25zKSB7XFxuICBpZiAoaGFzSGFuZGxlcihkb2MsIFxcXCJiZWZvcmVTZWxlY3Rpb25DaGFuZ2VcXFwiKSB8fCBkb2MuY20gJiYgaGFzSGFuZGxlcihkb2MuY20sIFxcXCJiZWZvcmVTZWxlY3Rpb25DaGFuZ2VcXFwiKSlcXG4gICAgeyBzZWwgPSBmaWx0ZXJTZWxlY3Rpb25DaGFuZ2UoZG9jLCBzZWwsIG9wdGlvbnMpIH1cXG5cXG4gIHZhciBiaWFzID0gb3B0aW9ucyAmJiBvcHRpb25zLmJpYXMgfHxcXG4gICAgKGNtcChzZWwucHJpbWFyeSgpLmhlYWQsIGRvYy5zZWwucHJpbWFyeSgpLmhlYWQpIDwgMCA/IC0xIDogMSlcXG4gIHNldFNlbGVjdGlvbklubmVyKGRvYywgc2tpcEF0b21pY0luU2VsZWN0aW9uKGRvYywgc2VsLCBiaWFzLCB0cnVlKSlcXG5cXG4gIGlmICghKG9wdGlvbnMgJiYgb3B0aW9ucy5zY3JvbGwgPT09IGZhbHNlKSAmJiBkb2MuY20pXFxuICAgIHsgZW5zdXJlQ3Vyc29yVmlzaWJsZShkb2MuY20pIH1cXG59XFxuXFxuZnVuY3Rpb24gc2V0U2VsZWN0aW9uSW5uZXIoZG9jLCBzZWwpIHtcXG4gIGlmIChzZWwuZXF1YWxzKGRvYy5zZWwpKSB7IHJldHVybiB9XFxuXFxuICBkb2Muc2VsID0gc2VsXFxuXFxuICBpZiAoZG9jLmNtKSB7XFxuICAgIGRvYy5jbS5jdXJPcC51cGRhdGVJbnB1dCA9IGRvYy5jbS5jdXJPcC5zZWxlY3Rpb25DaGFuZ2VkID0gdHJ1ZVxcbiAgICBzaWduYWxDdXJzb3JBY3Rpdml0eShkb2MuY20pXFxuICB9XFxuICBzaWduYWxMYXRlcihkb2MsIFxcXCJjdXJzb3JBY3Rpdml0eVxcXCIsIGRvYylcXG59XFxuXFxuLy8gVmVyaWZ5IHRoYXQgdGhlIHNlbGVjdGlvbiBkb2VzIG5vdCBwYXJ0aWFsbHkgc2VsZWN0IGFueSBhdG9taWNcXG4vLyBtYXJrZWQgcmFuZ2VzLlxcbmZ1bmN0aW9uIHJlQ2hlY2tTZWxlY3Rpb24oZG9jKSB7XFxuICBzZXRTZWxlY3Rpb25Jbm5lcihkb2MsIHNraXBBdG9taWNJblNlbGVjdGlvbihkb2MsIGRvYy5zZWwsIG51bGwsIGZhbHNlKSwgc2VsX2RvbnRTY3JvbGwpXFxufVxcblxcbi8vIFJldHVybiBhIHNlbGVjdGlvbiB0aGF0IGRvZXMgbm90IHBhcnRpYWxseSBzZWxlY3QgYW55IGF0b21pY1xcbi8vIHJhbmdlcy5cXG5mdW5jdGlvbiBza2lwQXRvbWljSW5TZWxlY3Rpb24oZG9jLCBzZWwsIGJpYXMsIG1heUNsZWFyKSB7XFxuICB2YXIgb3V0XFxuICBmb3IgKHZhciBpID0gMDsgaSA8IHNlbC5yYW5nZXMubGVuZ3RoOyBpKyspIHtcXG4gICAgdmFyIHJhbmdlID0gc2VsLnJhbmdlc1tpXVxcbiAgICB2YXIgb2xkID0gc2VsLnJhbmdlcy5sZW5ndGggPT0gZG9jLnNlbC5yYW5nZXMubGVuZ3RoICYmIGRvYy5zZWwucmFuZ2VzW2ldXFxuICAgIHZhciBuZXdBbmNob3IgPSBza2lwQXRvbWljKGRvYywgcmFuZ2UuYW5jaG9yLCBvbGQgJiYgb2xkLmFuY2hvciwgYmlhcywgbWF5Q2xlYXIpXFxuICAgIHZhciBuZXdIZWFkID0gc2tpcEF0b21pYyhkb2MsIHJhbmdlLmhlYWQsIG9sZCAmJiBvbGQuaGVhZCwgYmlhcywgbWF5Q2xlYXIpXFxuICAgIGlmIChvdXQgfHwgbmV3QW5jaG9yICE9IHJhbmdlLmFuY2hvciB8fCBuZXdIZWFkICE9IHJhbmdlLmhlYWQpIHtcXG4gICAgICBpZiAoIW91dCkgeyBvdXQgPSBzZWwucmFuZ2VzLnNsaWNlKDAsIGkpIH1cXG4gICAgICBvdXRbaV0gPSBuZXcgUmFuZ2UobmV3QW5jaG9yLCBuZXdIZWFkKVxcbiAgICB9XFxuICB9XFxuICByZXR1cm4gb3V0ID8gbm9ybWFsaXplU2VsZWN0aW9uKG91dCwgc2VsLnByaW1JbmRleCkgOiBzZWxcXG59XFxuXFxuZnVuY3Rpb24gc2tpcEF0b21pY0lubmVyKGRvYywgcG9zLCBvbGRQb3MsIGRpciwgbWF5Q2xlYXIpIHtcXG4gIHZhciBsaW5lID0gZ2V0TGluZShkb2MsIHBvcy5saW5lKVxcbiAgaWYgKGxpbmUubWFya2VkU3BhbnMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lLm1hcmtlZFNwYW5zLmxlbmd0aDsgKytpKSB7XFxuICAgIHZhciBzcCA9IGxpbmUubWFya2VkU3BhbnNbaV0sIG0gPSBzcC5tYXJrZXJcXG4gICAgaWYgKChzcC5mcm9tID09IG51bGwgfHwgKG0uaW5jbHVzaXZlTGVmdCA/IHNwLmZyb20gPD0gcG9zLmNoIDogc3AuZnJvbSA8IHBvcy5jaCkpICYmXFxuICAgICAgICAoc3AudG8gPT0gbnVsbCB8fCAobS5pbmNsdXNpdmVSaWdodCA/IHNwLnRvID49IHBvcy5jaCA6IHNwLnRvID4gcG9zLmNoKSkpIHtcXG4gICAgICBpZiAobWF5Q2xlYXIpIHtcXG4gICAgICAgIHNpZ25hbChtLCBcXFwiYmVmb3JlQ3Vyc29yRW50ZXJcXFwiKVxcbiAgICAgICAgaWYgKG0uZXhwbGljaXRseUNsZWFyZWQpIHtcXG4gICAgICAgICAgaWYgKCFsaW5lLm1hcmtlZFNwYW5zKSB7IGJyZWFrIH1cXG4gICAgICAgICAgZWxzZSB7LS1pOyBjb250aW51ZX1cXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgICAgaWYgKCFtLmF0b21pYykgeyBjb250aW51ZSB9XFxuXFxuICAgICAgaWYgKG9sZFBvcykge1xcbiAgICAgICAgdmFyIG5lYXIgPSBtLmZpbmQoZGlyIDwgMCA/IDEgOiAtMSksIGRpZmYgPSAodm9pZCAwKVxcbiAgICAgICAgaWYgKGRpciA8IDAgPyBtLmluY2x1c2l2ZVJpZ2h0IDogbS5pbmNsdXNpdmVMZWZ0KVxcbiAgICAgICAgICB7IG5lYXIgPSBtb3ZlUG9zKGRvYywgbmVhciwgLWRpciwgbmVhciAmJiBuZWFyLmxpbmUgPT0gcG9zLmxpbmUgPyBsaW5lIDogbnVsbCkgfVxcbiAgICAgICAgaWYgKG5lYXIgJiYgbmVhci5saW5lID09IHBvcy5saW5lICYmIChkaWZmID0gY21wKG5lYXIsIG9sZFBvcykpICYmIChkaXIgPCAwID8gZGlmZiA8IDAgOiBkaWZmID4gMCkpXFxuICAgICAgICAgIHsgcmV0dXJuIHNraXBBdG9taWNJbm5lcihkb2MsIG5lYXIsIHBvcywgZGlyLCBtYXlDbGVhcikgfVxcbiAgICAgIH1cXG5cXG4gICAgICB2YXIgZmFyID0gbS5maW5kKGRpciA8IDAgPyAtMSA6IDEpXFxuICAgICAgaWYgKGRpciA8IDAgPyBtLmluY2x1c2l2ZUxlZnQgOiBtLmluY2x1c2l2ZVJpZ2h0KVxcbiAgICAgICAgeyBmYXIgPSBtb3ZlUG9zKGRvYywgZmFyLCBkaXIsIGZhci5saW5lID09IHBvcy5saW5lID8gbGluZSA6IG51bGwpIH1cXG4gICAgICByZXR1cm4gZmFyID8gc2tpcEF0b21pY0lubmVyKGRvYywgZmFyLCBwb3MsIGRpciwgbWF5Q2xlYXIpIDogbnVsbFxcbiAgICB9XFxuICB9IH1cXG4gIHJldHVybiBwb3NcXG59XFxuXFxuLy8gRW5zdXJlIGEgZ2l2ZW4gcG9zaXRpb24gaXMgbm90IGluc2lkZSBhbiBhdG9taWMgcmFuZ2UuXFxuZnVuY3Rpb24gc2tpcEF0b21pYyhkb2MsIHBvcywgb2xkUG9zLCBiaWFzLCBtYXlDbGVhcikge1xcbiAgdmFyIGRpciA9IGJpYXMgfHwgMVxcbiAgdmFyIGZvdW5kID0gc2tpcEF0b21pY0lubmVyKGRvYywgcG9zLCBvbGRQb3MsIGRpciwgbWF5Q2xlYXIpIHx8XFxuICAgICAgKCFtYXlDbGVhciAmJiBza2lwQXRvbWljSW5uZXIoZG9jLCBwb3MsIG9sZFBvcywgZGlyLCB0cnVlKSkgfHxcXG4gICAgICBza2lwQXRvbWljSW5uZXIoZG9jLCBwb3MsIG9sZFBvcywgLWRpciwgbWF5Q2xlYXIpIHx8XFxuICAgICAgKCFtYXlDbGVhciAmJiBza2lwQXRvbWljSW5uZXIoZG9jLCBwb3MsIG9sZFBvcywgLWRpciwgdHJ1ZSkpXFxuICBpZiAoIWZvdW5kKSB7XFxuICAgIGRvYy5jYW50RWRpdCA9IHRydWVcXG4gICAgcmV0dXJuIFBvcyhkb2MuZmlyc3QsIDApXFxuICB9XFxuICByZXR1cm4gZm91bmRcXG59XFxuXFxuZnVuY3Rpb24gbW92ZVBvcyhkb2MsIHBvcywgZGlyLCBsaW5lKSB7XFxuICBpZiAoZGlyIDwgMCAmJiBwb3MuY2ggPT0gMCkge1xcbiAgICBpZiAocG9zLmxpbmUgPiBkb2MuZmlyc3QpIHsgcmV0dXJuIGNsaXBQb3MoZG9jLCBQb3MocG9zLmxpbmUgLSAxKSkgfVxcbiAgICBlbHNlIHsgcmV0dXJuIG51bGwgfVxcbiAgfSBlbHNlIGlmIChkaXIgPiAwICYmIHBvcy5jaCA9PSAobGluZSB8fCBnZXRMaW5lKGRvYywgcG9zLmxpbmUpKS50ZXh0Lmxlbmd0aCkge1xcbiAgICBpZiAocG9zLmxpbmUgPCBkb2MuZmlyc3QgKyBkb2Muc2l6ZSAtIDEpIHsgcmV0dXJuIFBvcyhwb3MubGluZSArIDEsIDApIH1cXG4gICAgZWxzZSB7IHJldHVybiBudWxsIH1cXG4gIH0gZWxzZSB7XFxuICAgIHJldHVybiBuZXcgUG9zKHBvcy5saW5lLCBwb3MuY2ggKyBkaXIpXFxuICB9XFxufVxcblxcbmZ1bmN0aW9uIHNlbGVjdEFsbChjbSkge1xcbiAgY20uc2V0U2VsZWN0aW9uKFBvcyhjbS5maXJzdExpbmUoKSwgMCksIFBvcyhjbS5sYXN0TGluZSgpKSwgc2VsX2RvbnRTY3JvbGwpXFxufVxcblxcbi8vIFVQREFUSU5HXFxuXFxuLy8gQWxsb3cgXFxcImJlZm9yZUNoYW5nZVxcXCIgZXZlbnQgaGFuZGxlcnMgdG8gaW5mbHVlbmNlIGEgY2hhbmdlXFxuZnVuY3Rpb24gZmlsdGVyQ2hhbmdlKGRvYywgY2hhbmdlLCB1cGRhdGUpIHtcXG4gIHZhciBvYmogPSB7XFxuICAgIGNhbmNlbGVkOiBmYWxzZSxcXG4gICAgZnJvbTogY2hhbmdlLmZyb20sXFxuICAgIHRvOiBjaGFuZ2UudG8sXFxuICAgIHRleHQ6IGNoYW5nZS50ZXh0LFxcbiAgICBvcmlnaW46IGNoYW5nZS5vcmlnaW4sXFxuICAgIGNhbmNlbDogZnVuY3Rpb24gKCkgeyByZXR1cm4gb2JqLmNhbmNlbGVkID0gdHJ1ZTsgfVxcbiAgfVxcbiAgaWYgKHVwZGF0ZSkgeyBvYmoudXBkYXRlID0gZnVuY3Rpb24gKGZyb20sIHRvLCB0ZXh0LCBvcmlnaW4pIHtcXG4gICAgaWYgKGZyb20pIHsgb2JqLmZyb20gPSBjbGlwUG9zKGRvYywgZnJvbSkgfVxcbiAgICBpZiAodG8pIHsgb2JqLnRvID0gY2xpcFBvcyhkb2MsIHRvKSB9XFxuICAgIGlmICh0ZXh0KSB7IG9iai50ZXh0ID0gdGV4dCB9XFxuICAgIGlmIChvcmlnaW4gIT09IHVuZGVmaW5lZCkgeyBvYmoub3JpZ2luID0gb3JpZ2luIH1cXG4gIH0gfVxcbiAgc2lnbmFsKGRvYywgXFxcImJlZm9yZUNoYW5nZVxcXCIsIGRvYywgb2JqKVxcbiAgaWYgKGRvYy5jbSkgeyBzaWduYWwoZG9jLmNtLCBcXFwiYmVmb3JlQ2hhbmdlXFxcIiwgZG9jLmNtLCBvYmopIH1cXG5cXG4gIGlmIChvYmouY2FuY2VsZWQpIHsgcmV0dXJuIG51bGwgfVxcbiAgcmV0dXJuIHtmcm9tOiBvYmouZnJvbSwgdG86IG9iai50bywgdGV4dDogb2JqLnRleHQsIG9yaWdpbjogb2JqLm9yaWdpbn1cXG59XFxuXFxuLy8gQXBwbHkgYSBjaGFuZ2UgdG8gYSBkb2N1bWVudCwgYW5kIGFkZCBpdCB0byB0aGUgZG9jdW1lbnQnc1xcbi8vIGhpc3RvcnksIGFuZCBwcm9wYWdhdGluZyBpdCB0byBhbGwgbGlua2VkIGRvY3VtZW50cy5cXG5mdW5jdGlvbiBtYWtlQ2hhbmdlKGRvYywgY2hhbmdlLCBpZ25vcmVSZWFkT25seSkge1xcbiAgaWYgKGRvYy5jbSkge1xcbiAgICBpZiAoIWRvYy5jbS5jdXJPcCkgeyByZXR1cm4gb3BlcmF0aW9uKGRvYy5jbSwgbWFrZUNoYW5nZSkoZG9jLCBjaGFuZ2UsIGlnbm9yZVJlYWRPbmx5KSB9XFxuICAgIGlmIChkb2MuY20uc3RhdGUuc3VwcHJlc3NFZGl0cykgeyByZXR1cm4gfVxcbiAgfVxcblxcbiAgaWYgKGhhc0hhbmRsZXIoZG9jLCBcXFwiYmVmb3JlQ2hhbmdlXFxcIikgfHwgZG9jLmNtICYmIGhhc0hhbmRsZXIoZG9jLmNtLCBcXFwiYmVmb3JlQ2hhbmdlXFxcIikpIHtcXG4gICAgY2hhbmdlID0gZmlsdGVyQ2hhbmdlKGRvYywgY2hhbmdlLCB0cnVlKVxcbiAgICBpZiAoIWNoYW5nZSkgeyByZXR1cm4gfVxcbiAgfVxcblxcbiAgLy8gUG9zc2libHkgc3BsaXQgb3Igc3VwcHJlc3MgdGhlIHVwZGF0ZSBiYXNlZCBvbiB0aGUgcHJlc2VuY2VcXG4gIC8vIG9mIHJlYWQtb25seSBzcGFucyBpbiBpdHMgcmFuZ2UuXFxuICB2YXIgc3BsaXQgPSBzYXdSZWFkT25seVNwYW5zICYmICFpZ25vcmVSZWFkT25seSAmJiByZW1vdmVSZWFkT25seVJhbmdlcyhkb2MsIGNoYW5nZS5mcm9tLCBjaGFuZ2UudG8pXFxuICBpZiAoc3BsaXQpIHtcXG4gICAgZm9yICh2YXIgaSA9IHNwbGl0Lmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKVxcbiAgICAgIHsgbWFrZUNoYW5nZUlubmVyKGRvYywge2Zyb206IHNwbGl0W2ldLmZyb20sIHRvOiBzcGxpdFtpXS50bywgdGV4dDogaSA/IFtcXFwiXFxcIl0gOiBjaGFuZ2UudGV4dH0pIH1cXG4gIH0gZWxzZSB7XFxuICAgIG1ha2VDaGFuZ2VJbm5lcihkb2MsIGNoYW5nZSlcXG4gIH1cXG59XFxuXFxuZnVuY3Rpb24gbWFrZUNoYW5nZUlubmVyKGRvYywgY2hhbmdlKSB7XFxuICBpZiAoY2hhbmdlLnRleHQubGVuZ3RoID09IDEgJiYgY2hhbmdlLnRleHRbMF0gPT0gXFxcIlxcXCIgJiYgY21wKGNoYW5nZS5mcm9tLCBjaGFuZ2UudG8pID09IDApIHsgcmV0dXJuIH1cXG4gIHZhciBzZWxBZnRlciA9IGNvbXB1dGVTZWxBZnRlckNoYW5nZShkb2MsIGNoYW5nZSlcXG4gIGFkZENoYW5nZVRvSGlzdG9yeShkb2MsIGNoYW5nZSwgc2VsQWZ0ZXIsIGRvYy5jbSA/IGRvYy5jbS5jdXJPcC5pZCA6IE5hTilcXG5cXG4gIG1ha2VDaGFuZ2VTaW5nbGVEb2MoZG9jLCBjaGFuZ2UsIHNlbEFmdGVyLCBzdHJldGNoU3BhbnNPdmVyQ2hhbmdlKGRvYywgY2hhbmdlKSlcXG4gIHZhciByZWJhc2VkID0gW11cXG5cXG4gIGxpbmtlZERvY3MoZG9jLCBmdW5jdGlvbiAoZG9jLCBzaGFyZWRIaXN0KSB7XFxuICAgIGlmICghc2hhcmVkSGlzdCAmJiBpbmRleE9mKHJlYmFzZWQsIGRvYy5oaXN0b3J5KSA9PSAtMSkge1xcbiAgICAgIHJlYmFzZUhpc3QoZG9jLmhpc3RvcnksIGNoYW5nZSlcXG4gICAgICByZWJhc2VkLnB1c2goZG9jLmhpc3RvcnkpXFxuICAgIH1cXG4gICAgbWFrZUNoYW5nZVNpbmdsZURvYyhkb2MsIGNoYW5nZSwgbnVsbCwgc3RyZXRjaFNwYW5zT3ZlckNoYW5nZShkb2MsIGNoYW5nZSkpXFxuICB9KVxcbn1cXG5cXG4vLyBSZXZlcnQgYSBjaGFuZ2Ugc3RvcmVkIGluIGEgZG9jdW1lbnQncyBoaXN0b3J5LlxcbmZ1bmN0aW9uIG1ha2VDaGFuZ2VGcm9tSGlzdG9yeShkb2MsIHR5cGUsIGFsbG93U2VsZWN0aW9uT25seSkge1xcbiAgaWYgKGRvYy5jbSAmJiBkb2MuY20uc3RhdGUuc3VwcHJlc3NFZGl0cyAmJiAhYWxsb3dTZWxlY3Rpb25Pbmx5KSB7IHJldHVybiB9XFxuXFxuICB2YXIgaGlzdCA9IGRvYy5oaXN0b3J5LCBldmVudCwgc2VsQWZ0ZXIgPSBkb2Muc2VsXFxuICB2YXIgc291cmNlID0gdHlwZSA9PSBcXFwidW5kb1xcXCIgPyBoaXN0LmRvbmUgOiBoaXN0LnVuZG9uZSwgZGVzdCA9IHR5cGUgPT0gXFxcInVuZG9cXFwiID8gaGlzdC51bmRvbmUgOiBoaXN0LmRvbmVcXG5cXG4gIC8vIFZlcmlmeSB0aGF0IHRoZXJlIGlzIGEgdXNlYWJsZSBldmVudCAoc28gdGhhdCBjdHJsLXogd29uJ3RcXG4gIC8vIG5lZWRsZXNzbHkgY2xlYXIgc2VsZWN0aW9uIGV2ZW50cylcXG4gIHZhciBpID0gMFxcbiAgZm9yICg7IGkgPCBzb3VyY2UubGVuZ3RoOyBpKyspIHtcXG4gICAgZXZlbnQgPSBzb3VyY2VbaV1cXG4gICAgaWYgKGFsbG93U2VsZWN0aW9uT25seSA/IGV2ZW50LnJhbmdlcyAmJiAhZXZlbnQuZXF1YWxzKGRvYy5zZWwpIDogIWV2ZW50LnJhbmdlcylcXG4gICAgICB7IGJyZWFrIH1cXG4gIH1cXG4gIGlmIChpID09IHNvdXJjZS5sZW5ndGgpIHsgcmV0dXJuIH1cXG4gIGhpc3QubGFzdE9yaWdpbiA9IGhpc3QubGFzdFNlbE9yaWdpbiA9IG51bGxcXG5cXG4gIGZvciAoOzspIHtcXG4gICAgZXZlbnQgPSBzb3VyY2UucG9wKClcXG4gICAgaWYgKGV2ZW50LnJhbmdlcykge1xcbiAgICAgIHB1c2hTZWxlY3Rpb25Ub0hpc3RvcnkoZXZlbnQsIGRlc3QpXFxuICAgICAgaWYgKGFsbG93U2VsZWN0aW9uT25seSAmJiAhZXZlbnQuZXF1YWxzKGRvYy5zZWwpKSB7XFxuICAgICAgICBzZXRTZWxlY3Rpb24oZG9jLCBldmVudCwge2NsZWFyUmVkbzogZmFsc2V9KVxcbiAgICAgICAgcmV0dXJuXFxuICAgICAgfVxcbiAgICAgIHNlbEFmdGVyID0gZXZlbnRcXG4gICAgfVxcbiAgICBlbHNlIHsgYnJlYWsgfVxcbiAgfVxcblxcbiAgLy8gQnVpbGQgdXAgYSByZXZlcnNlIGNoYW5nZSBvYmplY3QgdG8gYWRkIHRvIHRoZSBvcHBvc2l0ZSBoaXN0b3J5XFxuICAvLyBzdGFjayAocmVkbyB3aGVuIHVuZG9pbmcsIGFuZCB2aWNlIHZlcnNhKS5cXG4gIHZhciBhbnRpQ2hhbmdlcyA9IFtdXFxuICBwdXNoU2VsZWN0aW9uVG9IaXN0b3J5KHNlbEFmdGVyLCBkZXN0KVxcbiAgZGVzdC5wdXNoKHtjaGFuZ2VzOiBhbnRpQ2hhbmdlcywgZ2VuZXJhdGlvbjogaGlzdC5nZW5lcmF0aW9ufSlcXG4gIGhpc3QuZ2VuZXJhdGlvbiA9IGV2ZW50LmdlbmVyYXRpb24gfHwgKytoaXN0Lm1heEdlbmVyYXRpb25cXG5cXG4gIHZhciBmaWx0ZXIgPSBoYXNIYW5kbGVyKGRvYywgXFxcImJlZm9yZUNoYW5nZVxcXCIpIHx8IGRvYy5jbSAmJiBoYXNIYW5kbGVyKGRvYy5jbSwgXFxcImJlZm9yZUNoYW5nZVxcXCIpXFxuXFxuICB2YXIgbG9vcCA9IGZ1bmN0aW9uICggaSApIHtcXG4gICAgdmFyIGNoYW5nZSA9IGV2ZW50LmNoYW5nZXNbaV1cXG4gICAgY2hhbmdlLm9yaWdpbiA9IHR5cGVcXG4gICAgaWYgKGZpbHRlciAmJiAhZmlsdGVyQ2hhbmdlKGRvYywgY2hhbmdlLCBmYWxzZSkpIHtcXG4gICAgICBzb3VyY2UubGVuZ3RoID0gMFxcbiAgICAgIHJldHVybiB7fVxcbiAgICB9XFxuXFxuICAgIGFudGlDaGFuZ2VzLnB1c2goaGlzdG9yeUNoYW5nZUZyb21DaGFuZ2UoZG9jLCBjaGFuZ2UpKVxcblxcbiAgICB2YXIgYWZ0ZXIgPSBpID8gY29tcHV0ZVNlbEFmdGVyQ2hhbmdlKGRvYywgY2hhbmdlKSA6IGxzdChzb3VyY2UpXFxuICAgIG1ha2VDaGFuZ2VTaW5nbGVEb2MoZG9jLCBjaGFuZ2UsIGFmdGVyLCBtZXJnZU9sZFNwYW5zKGRvYywgY2hhbmdlKSlcXG4gICAgaWYgKCFpICYmIGRvYy5jbSkgeyBkb2MuY20uc2Nyb2xsSW50b1ZpZXcoe2Zyb206IGNoYW5nZS5mcm9tLCB0bzogY2hhbmdlRW5kKGNoYW5nZSl9KSB9XFxuICAgIHZhciByZWJhc2VkID0gW11cXG5cXG4gICAgLy8gUHJvcGFnYXRlIHRvIHRoZSBsaW5rZWQgZG9jdW1lbnRzXFxuICAgIGxpbmtlZERvY3MoZG9jLCBmdW5jdGlvbiAoZG9jLCBzaGFyZWRIaXN0KSB7XFxuICAgICAgaWYgKCFzaGFyZWRIaXN0ICYmIGluZGV4T2YocmViYXNlZCwgZG9jLmhpc3RvcnkpID09IC0xKSB7XFxuICAgICAgICByZWJhc2VIaXN0KGRvYy5oaXN0b3J5LCBjaGFuZ2UpXFxuICAgICAgICByZWJhc2VkLnB1c2goZG9jLmhpc3RvcnkpXFxuICAgICAgfVxcbiAgICAgIG1ha2VDaGFuZ2VTaW5nbGVEb2MoZG9jLCBjaGFuZ2UsIG51bGwsIG1lcmdlT2xkU3BhbnMoZG9jLCBjaGFuZ2UpKVxcbiAgICB9KVxcbiAgfTtcXG5cXG4gIGZvciAodmFyIGkkMSA9IGV2ZW50LmNoYW5nZXMubGVuZ3RoIC0gMTsgaSQxID49IDA7IC0taSQxKSB7XFxuICAgIHZhciByZXR1cm5lZCA9IGxvb3AoIGkkMSApO1xcblxcbiAgICBpZiAoIHJldHVybmVkICkgcmV0dXJuIHJldHVybmVkLnY7XFxuICB9XFxufVxcblxcbi8vIFN1Yi12aWV3cyBuZWVkIHRoZWlyIGxpbmUgbnVtYmVycyBzaGlmdGVkIHdoZW4gdGV4dCBpcyBhZGRlZFxcbi8vIGFib3ZlIG9yIGJlbG93IHRoZW0gaW4gdGhlIHBhcmVudCBkb2N1bWVudC5cXG5mdW5jdGlvbiBzaGlmdERvYyhkb2MsIGRpc3RhbmNlKSB7XFxuICBpZiAoZGlzdGFuY2UgPT0gMCkgeyByZXR1cm4gfVxcbiAgZG9jLmZpcnN0ICs9IGRpc3RhbmNlXFxuICBkb2Muc2VsID0gbmV3IFNlbGVjdGlvbihtYXAoZG9jLnNlbC5yYW5nZXMsIGZ1bmN0aW9uIChyYW5nZSkgeyByZXR1cm4gbmV3IFJhbmdlKFxcbiAgICBQb3MocmFuZ2UuYW5jaG9yLmxpbmUgKyBkaXN0YW5jZSwgcmFuZ2UuYW5jaG9yLmNoKSxcXG4gICAgUG9zKHJhbmdlLmhlYWQubGluZSArIGRpc3RhbmNlLCByYW5nZS5oZWFkLmNoKVxcbiAgKTsgfSksIGRvYy5zZWwucHJpbUluZGV4KVxcbiAgaWYgKGRvYy5jbSkge1xcbiAgICByZWdDaGFuZ2UoZG9jLmNtLCBkb2MuZmlyc3QsIGRvYy5maXJzdCAtIGRpc3RhbmNlLCBkaXN0YW5jZSlcXG4gICAgZm9yICh2YXIgZCA9IGRvYy5jbS5kaXNwbGF5LCBsID0gZC52aWV3RnJvbTsgbCA8IGQudmlld1RvOyBsKyspXFxuICAgICAgeyByZWdMaW5lQ2hhbmdlKGRvYy5jbSwgbCwgXFxcImd1dHRlclxcXCIpIH1cXG4gIH1cXG59XFxuXFxuLy8gTW9yZSBsb3dlci1sZXZlbCBjaGFuZ2UgZnVuY3Rpb24sIGhhbmRsaW5nIG9ubHkgYSBzaW5nbGUgZG9jdW1lbnRcXG4vLyAobm90IGxpbmtlZCBvbmVzKS5cXG5mdW5jdGlvbiBtYWtlQ2hhbmdlU2luZ2xlRG9jKGRvYywgY2hhbmdlLCBzZWxBZnRlciwgc3BhbnMpIHtcXG4gIGlmIChkb2MuY20gJiYgIWRvYy5jbS5jdXJPcClcXG4gICAgeyByZXR1cm4gb3BlcmF0aW9uKGRvYy5jbSwgbWFrZUNoYW5nZVNpbmdsZURvYykoZG9jLCBjaGFuZ2UsIHNlbEFmdGVyLCBzcGFucykgfVxcblxcbiAgaWYgKGNoYW5nZS50by5saW5lIDwgZG9jLmZpcnN0KSB7XFxuICAgIHNoaWZ0RG9jKGRvYywgY2hhbmdlLnRleHQubGVuZ3RoIC0gMSAtIChjaGFuZ2UudG8ubGluZSAtIGNoYW5nZS5mcm9tLmxpbmUpKVxcbiAgICByZXR1cm5cXG4gIH1cXG4gIGlmIChjaGFuZ2UuZnJvbS5saW5lID4gZG9jLmxhc3RMaW5lKCkpIHsgcmV0dXJuIH1cXG5cXG4gIC8vIENsaXAgdGhlIGNoYW5nZSB0byB0aGUgc2l6ZSBvZiB0aGlzIGRvY1xcbiAgaWYgKGNoYW5nZS5mcm9tLmxpbmUgPCBkb2MuZmlyc3QpIHtcXG4gICAgdmFyIHNoaWZ0ID0gY2hhbmdlLnRleHQubGVuZ3RoIC0gMSAtIChkb2MuZmlyc3QgLSBjaGFuZ2UuZnJvbS5saW5lKVxcbiAgICBzaGlmdERvYyhkb2MsIHNoaWZ0KVxcbiAgICBjaGFuZ2UgPSB7ZnJvbTogUG9zKGRvYy5maXJzdCwgMCksIHRvOiBQb3MoY2hhbmdlLnRvLmxpbmUgKyBzaGlmdCwgY2hhbmdlLnRvLmNoKSxcXG4gICAgICAgICAgICAgIHRleHQ6IFtsc3QoY2hhbmdlLnRleHQpXSwgb3JpZ2luOiBjaGFuZ2Uub3JpZ2lufVxcbiAgfVxcbiAgdmFyIGxhc3QgPSBkb2MubGFzdExpbmUoKVxcbiAgaWYgKGNoYW5nZS50by5saW5lID4gbGFzdCkge1xcbiAgICBjaGFuZ2UgPSB7ZnJvbTogY2hhbmdlLmZyb20sIHRvOiBQb3MobGFzdCwgZ2V0TGluZShkb2MsIGxhc3QpLnRleHQubGVuZ3RoKSxcXG4gICAgICAgICAgICAgIHRleHQ6IFtjaGFuZ2UudGV4dFswXV0sIG9yaWdpbjogY2hhbmdlLm9yaWdpbn1cXG4gIH1cXG5cXG4gIGNoYW5nZS5yZW1vdmVkID0gZ2V0QmV0d2Vlbihkb2MsIGNoYW5nZS5mcm9tLCBjaGFuZ2UudG8pXFxuXFxuICBpZiAoIXNlbEFmdGVyKSB7IHNlbEFmdGVyID0gY29tcHV0ZVNlbEFmdGVyQ2hhbmdlKGRvYywgY2hhbmdlKSB9XFxuICBpZiAoZG9jLmNtKSB7IG1ha2VDaGFuZ2VTaW5nbGVEb2NJbkVkaXRvcihkb2MuY20sIGNoYW5nZSwgc3BhbnMpIH1cXG4gIGVsc2UgeyB1cGRhdGVEb2MoZG9jLCBjaGFuZ2UsIHNwYW5zKSB9XFxuICBzZXRTZWxlY3Rpb25Ob1VuZG8oZG9jLCBzZWxBZnRlciwgc2VsX2RvbnRTY3JvbGwpXFxufVxcblxcbi8vIEhhbmRsZSB0aGUgaW50ZXJhY3Rpb24gb2YgYSBjaGFuZ2UgdG8gYSBkb2N1bWVudCB3aXRoIHRoZSBlZGl0b3JcXG4vLyB0aGF0IHRoaXMgZG9jdW1lbnQgaXMgcGFydCBvZi5cXG5mdW5jdGlvbiBtYWtlQ2hhbmdlU2luZ2xlRG9jSW5FZGl0b3IoY20sIGNoYW5nZSwgc3BhbnMpIHtcXG4gIHZhciBkb2MgPSBjbS5kb2MsIGRpc3BsYXkgPSBjbS5kaXNwbGF5LCBmcm9tID0gY2hhbmdlLmZyb20sIHRvID0gY2hhbmdlLnRvXFxuXFxuICB2YXIgcmVjb21wdXRlTWF4TGVuZ3RoID0gZmFsc2UsIGNoZWNrV2lkdGhTdGFydCA9IGZyb20ubGluZVxcbiAgaWYgKCFjbS5vcHRpb25zLmxpbmVXcmFwcGluZykge1xcbiAgICBjaGVja1dpZHRoU3RhcnQgPSBsaW5lTm8odmlzdWFsTGluZShnZXRMaW5lKGRvYywgZnJvbS5saW5lKSkpXFxuICAgIGRvYy5pdGVyKGNoZWNrV2lkdGhTdGFydCwgdG8ubGluZSArIDEsIGZ1bmN0aW9uIChsaW5lKSB7XFxuICAgICAgaWYgKGxpbmUgPT0gZGlzcGxheS5tYXhMaW5lKSB7XFxuICAgICAgICByZWNvbXB1dGVNYXhMZW5ndGggPSB0cnVlXFxuICAgICAgICByZXR1cm4gdHJ1ZVxcbiAgICAgIH1cXG4gICAgfSlcXG4gIH1cXG5cXG4gIGlmIChkb2Muc2VsLmNvbnRhaW5zKGNoYW5nZS5mcm9tLCBjaGFuZ2UudG8pID4gLTEpXFxuICAgIHsgc2lnbmFsQ3Vyc29yQWN0aXZpdHkoY20pIH1cXG5cXG4gIHVwZGF0ZURvYyhkb2MsIGNoYW5nZSwgc3BhbnMsIGVzdGltYXRlSGVpZ2h0KGNtKSlcXG5cXG4gIGlmICghY20ub3B0aW9ucy5saW5lV3JhcHBpbmcpIHtcXG4gICAgZG9jLml0ZXIoY2hlY2tXaWR0aFN0YXJ0LCBmcm9tLmxpbmUgKyBjaGFuZ2UudGV4dC5sZW5ndGgsIGZ1bmN0aW9uIChsaW5lKSB7XFxuICAgICAgdmFyIGxlbiA9IGxpbmVMZW5ndGgobGluZSlcXG4gICAgICBpZiAobGVuID4gZGlzcGxheS5tYXhMaW5lTGVuZ3RoKSB7XFxuICAgICAgICBkaXNwbGF5Lm1heExpbmUgPSBsaW5lXFxuICAgICAgICBkaXNwbGF5Lm1heExpbmVMZW5ndGggPSBsZW5cXG4gICAgICAgIGRpc3BsYXkubWF4TGluZUNoYW5nZWQgPSB0cnVlXFxuICAgICAgICByZWNvbXB1dGVNYXhMZW5ndGggPSBmYWxzZVxcbiAgICAgIH1cXG4gICAgfSlcXG4gICAgaWYgKHJlY29tcHV0ZU1heExlbmd0aCkgeyBjbS5jdXJPcC51cGRhdGVNYXhMaW5lID0gdHJ1ZSB9XFxuICB9XFxuXFxuICAvLyBBZGp1c3QgZnJvbnRpZXIsIHNjaGVkdWxlIHdvcmtlclxcbiAgZG9jLmZyb250aWVyID0gTWF0aC5taW4oZG9jLmZyb250aWVyLCBmcm9tLmxpbmUpXFxuICBzdGFydFdvcmtlcihjbSwgNDAwKVxcblxcbiAgdmFyIGxlbmRpZmYgPSBjaGFuZ2UudGV4dC5sZW5ndGggLSAodG8ubGluZSAtIGZyb20ubGluZSkgLSAxXFxuICAvLyBSZW1lbWJlciB0aGF0IHRoZXNlIGxpbmVzIGNoYW5nZWQsIGZvciB1cGRhdGluZyB0aGUgZGlzcGxheVxcbiAgaWYgKGNoYW5nZS5mdWxsKVxcbiAgICB7IHJlZ0NoYW5nZShjbSkgfVxcbiAgZWxzZSBpZiAoZnJvbS5saW5lID09IHRvLmxpbmUgJiYgY2hhbmdlLnRleHQubGVuZ3RoID09IDEgJiYgIWlzV2hvbGVMaW5lVXBkYXRlKGNtLmRvYywgY2hhbmdlKSlcXG4gICAgeyByZWdMaW5lQ2hhbmdlKGNtLCBmcm9tLmxpbmUsIFxcXCJ0ZXh0XFxcIikgfVxcbiAgZWxzZVxcbiAgICB7IHJlZ0NoYW5nZShjbSwgZnJvbS5saW5lLCB0by5saW5lICsgMSwgbGVuZGlmZikgfVxcblxcbiAgdmFyIGNoYW5nZXNIYW5kbGVyID0gaGFzSGFuZGxlcihjbSwgXFxcImNoYW5nZXNcXFwiKSwgY2hhbmdlSGFuZGxlciA9IGhhc0hhbmRsZXIoY20sIFxcXCJjaGFuZ2VcXFwiKVxcbiAgaWYgKGNoYW5nZUhhbmRsZXIgfHwgY2hhbmdlc0hhbmRsZXIpIHtcXG4gICAgdmFyIG9iaiA9IHtcXG4gICAgICBmcm9tOiBmcm9tLCB0bzogdG8sXFxuICAgICAgdGV4dDogY2hhbmdlLnRleHQsXFxuICAgICAgcmVtb3ZlZDogY2hhbmdlLnJlbW92ZWQsXFxuICAgICAgb3JpZ2luOiBjaGFuZ2Uub3JpZ2luXFxuICAgIH1cXG4gICAgaWYgKGNoYW5nZUhhbmRsZXIpIHsgc2lnbmFsTGF0ZXIoY20sIFxcXCJjaGFuZ2VcXFwiLCBjbSwgb2JqKSB9XFxuICAgIGlmIChjaGFuZ2VzSGFuZGxlcikgeyAoY20uY3VyT3AuY2hhbmdlT2JqcyB8fCAoY20uY3VyT3AuY2hhbmdlT2JqcyA9IFtdKSkucHVzaChvYmopIH1cXG4gIH1cXG4gIGNtLmRpc3BsYXkuc2VsRm9yQ29udGV4dE1lbnUgPSBudWxsXFxufVxcblxcbmZ1bmN0aW9uIHJlcGxhY2VSYW5nZShkb2MsIGNvZGUsIGZyb20sIHRvLCBvcmlnaW4pIHtcXG4gIGlmICghdG8pIHsgdG8gPSBmcm9tIH1cXG4gIGlmIChjbXAodG8sIGZyb20pIDwgMCkgeyB2YXIgdG1wID0gdG87IHRvID0gZnJvbTsgZnJvbSA9IHRtcCB9XFxuICBpZiAodHlwZW9mIGNvZGUgPT0gXFxcInN0cmluZ1xcXCIpIHsgY29kZSA9IGRvYy5zcGxpdExpbmVzKGNvZGUpIH1cXG4gIG1ha2VDaGFuZ2UoZG9jLCB7ZnJvbTogZnJvbSwgdG86IHRvLCB0ZXh0OiBjb2RlLCBvcmlnaW46IG9yaWdpbn0pXFxufVxcblxcbi8vIFJlYmFzaW5nL3Jlc2V0dGluZyBoaXN0b3J5IHRvIGRlYWwgd2l0aCBleHRlcm5hbGx5LXNvdXJjZWQgY2hhbmdlc1xcblxcbmZ1bmN0aW9uIHJlYmFzZUhpc3RTZWxTaW5nbGUocG9zLCBmcm9tLCB0bywgZGlmZikge1xcbiAgaWYgKHRvIDwgcG9zLmxpbmUpIHtcXG4gICAgcG9zLmxpbmUgKz0gZGlmZlxcbiAgfSBlbHNlIGlmIChmcm9tIDwgcG9zLmxpbmUpIHtcXG4gICAgcG9zLmxpbmUgPSBmcm9tXFxuICAgIHBvcy5jaCA9IDBcXG4gIH1cXG59XFxuXFxuLy8gVHJpZXMgdG8gcmViYXNlIGFuIGFycmF5IG9mIGhpc3RvcnkgZXZlbnRzIGdpdmVuIGEgY2hhbmdlIGluIHRoZVxcbi8vIGRvY3VtZW50LiBJZiB0aGUgY2hhbmdlIHRvdWNoZXMgdGhlIHNhbWUgbGluZXMgYXMgdGhlIGV2ZW50LCB0aGVcXG4vLyBldmVudCwgYW5kIGV2ZXJ5dGhpbmcgJ2JlaGluZCcgaXQsIGlzIGRpc2NhcmRlZC4gSWYgdGhlIGNoYW5nZSBpc1xcbi8vIGJlZm9yZSB0aGUgZXZlbnQsIHRoZSBldmVudCdzIHBvc2l0aW9ucyBhcmUgdXBkYXRlZC4gVXNlcyBhXFxuLy8gY29weS1vbi13cml0ZSBzY2hlbWUgZm9yIHRoZSBwb3NpdGlvbnMsIHRvIGF2b2lkIGhhdmluZyB0b1xcbi8vIHJlYWxsb2NhdGUgdGhlbSBhbGwgb24gZXZlcnkgcmViYXNlLCBidXQgYWxzbyBhdm9pZCBwcm9ibGVtcyB3aXRoXFxuLy8gc2hhcmVkIHBvc2l0aW9uIG9iamVjdHMgYmVpbmcgdW5zYWZlbHkgdXBkYXRlZC5cXG5mdW5jdGlvbiByZWJhc2VIaXN0QXJyYXkoYXJyYXksIGZyb20sIHRvLCBkaWZmKSB7XFxuICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgKytpKSB7XFxuICAgIHZhciBzdWIgPSBhcnJheVtpXSwgb2sgPSB0cnVlXFxuICAgIGlmIChzdWIucmFuZ2VzKSB7XFxuICAgICAgaWYgKCFzdWIuY29waWVkKSB7IHN1YiA9IGFycmF5W2ldID0gc3ViLmRlZXBDb3B5KCk7IHN1Yi5jb3BpZWQgPSB0cnVlIH1cXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHN1Yi5yYW5nZXMubGVuZ3RoOyBqKyspIHtcXG4gICAgICAgIHJlYmFzZUhpc3RTZWxTaW5nbGUoc3ViLnJhbmdlc1tqXS5hbmNob3IsIGZyb20sIHRvLCBkaWZmKVxcbiAgICAgICAgcmViYXNlSGlzdFNlbFNpbmdsZShzdWIucmFuZ2VzW2pdLmhlYWQsIGZyb20sIHRvLCBkaWZmKVxcbiAgICAgIH1cXG4gICAgICBjb250aW51ZVxcbiAgICB9XFxuICAgIGZvciAodmFyIGokMSA9IDA7IGokMSA8IHN1Yi5jaGFuZ2VzLmxlbmd0aDsgKytqJDEpIHtcXG4gICAgICB2YXIgY3VyID0gc3ViLmNoYW5nZXNbaiQxXVxcbiAgICAgIGlmICh0byA8IGN1ci5mcm9tLmxpbmUpIHtcXG4gICAgICAgIGN1ci5mcm9tID0gUG9zKGN1ci5mcm9tLmxpbmUgKyBkaWZmLCBjdXIuZnJvbS5jaClcXG4gICAgICAgIGN1ci50byA9IFBvcyhjdXIudG8ubGluZSArIGRpZmYsIGN1ci50by5jaClcXG4gICAgICB9IGVsc2UgaWYgKGZyb20gPD0gY3VyLnRvLmxpbmUpIHtcXG4gICAgICAgIG9rID0gZmFsc2VcXG4gICAgICAgIGJyZWFrXFxuICAgICAgfVxcbiAgICB9XFxuICAgIGlmICghb2spIHtcXG4gICAgICBhcnJheS5zcGxpY2UoMCwgaSArIDEpXFxuICAgICAgaSA9IDBcXG4gICAgfVxcbiAgfVxcbn1cXG5cXG5mdW5jdGlvbiByZWJhc2VIaXN0KGhpc3QsIGNoYW5nZSkge1xcbiAgdmFyIGZyb20gPSBjaGFuZ2UuZnJvbS5saW5lLCB0byA9IGNoYW5nZS50by5saW5lLCBkaWZmID0gY2hhbmdlLnRleHQubGVuZ3RoIC0gKHRvIC0gZnJvbSkgLSAxXFxuICByZWJhc2VIaXN0QXJyYXkoaGlzdC5kb25lLCBmcm9tLCB0bywgZGlmZilcXG4gIHJlYmFzZUhpc3RBcnJheShoaXN0LnVuZG9uZSwgZnJvbSwgdG8sIGRpZmYpXFxufVxcblxcbi8vIFV0aWxpdHkgZm9yIGFwcGx5aW5nIGEgY2hhbmdlIHRvIGEgbGluZSBieSBoYW5kbGUgb3IgbnVtYmVyLFxcbi8vIHJldHVybmluZyB0aGUgbnVtYmVyIGFuZCBvcHRpb25hbGx5IHJlZ2lzdGVyaW5nIHRoZSBsaW5lIGFzXFxuLy8gY2hhbmdlZC5cXG5mdW5jdGlvbiBjaGFuZ2VMaW5lKGRvYywgaGFuZGxlLCBjaGFuZ2VUeXBlLCBvcCkge1xcbiAgdmFyIG5vID0gaGFuZGxlLCBsaW5lID0gaGFuZGxlXFxuICBpZiAodHlwZW9mIGhhbmRsZSA9PSBcXFwibnVtYmVyXFxcIikgeyBsaW5lID0gZ2V0TGluZShkb2MsIGNsaXBMaW5lKGRvYywgaGFuZGxlKSkgfVxcbiAgZWxzZSB7IG5vID0gbGluZU5vKGhhbmRsZSkgfVxcbiAgaWYgKG5vID09IG51bGwpIHsgcmV0dXJuIG51bGwgfVxcbiAgaWYgKG9wKGxpbmUsIG5vKSAmJiBkb2MuY20pIHsgcmVnTGluZUNoYW5nZShkb2MuY20sIG5vLCBjaGFuZ2VUeXBlKSB9XFxuICByZXR1cm4gbGluZVxcbn1cXG5cXG4vLyBUaGUgZG9jdW1lbnQgaXMgcmVwcmVzZW50ZWQgYXMgYSBCVHJlZSBjb25zaXN0aW5nIG9mIGxlYXZlcywgd2l0aFxcbi8vIGNodW5rIG9mIGxpbmVzIGluIHRoZW0sIGFuZCBicmFuY2hlcywgd2l0aCB1cCB0byB0ZW4gbGVhdmVzIG9yXFxuLy8gb3RoZXIgYnJhbmNoIG5vZGVzIGJlbG93IHRoZW0uIFRoZSB0b3Agbm9kZSBpcyBhbHdheXMgYSBicmFuY2hcXG4vLyBub2RlLCBhbmQgaXMgdGhlIGRvY3VtZW50IG9iamVjdCBpdHNlbGYgKG1lYW5pbmcgaXQgaGFzXFxuLy8gYWRkaXRpb25hbCBtZXRob2RzIGFuZCBwcm9wZXJ0aWVzKS5cXG4vL1xcbi8vIEFsbCBub2RlcyBoYXZlIHBhcmVudCBsaW5rcy4gVGhlIHRyZWUgaXMgdXNlZCBib3RoIHRvIGdvIGZyb21cXG4vLyBsaW5lIG51bWJlcnMgdG8gbGluZSBvYmplY3RzLCBhbmQgdG8gZ28gZnJvbSBvYmplY3RzIHRvIG51bWJlcnMuXFxuLy8gSXQgYWxzbyBpbmRleGVzIGJ5IGhlaWdodCwgYW5kIGlzIHVzZWQgdG8gY29udmVydCBiZXR3ZWVuIGhlaWdodFxcbi8vIGFuZCBsaW5lIG9iamVjdCwgYW5kIHRvIGZpbmQgdGhlIHRvdGFsIGhlaWdodCBvZiB0aGUgZG9jdW1lbnQuXFxuLy9cXG4vLyBTZWUgYWxzbyBodHRwOi8vbWFyaWpuaGF2ZXJiZWtlLm5sL2Jsb2cvY29kZW1pcnJvci1saW5lLXRyZWUuaHRtbFxcblxcbmZ1bmN0aW9uIExlYWZDaHVuayhsaW5lcykge1xcbiAgdmFyIHRoaXMkMSA9IHRoaXM7XFxuXFxuICB0aGlzLmxpbmVzID0gbGluZXNcXG4gIHRoaXMucGFyZW50ID0gbnVsbFxcbiAgdmFyIGhlaWdodCA9IDBcXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyArK2kpIHtcXG4gICAgbGluZXNbaV0ucGFyZW50ID0gdGhpcyQxXFxuICAgIGhlaWdodCArPSBsaW5lc1tpXS5oZWlnaHRcXG4gIH1cXG4gIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0XFxufVxcblxcbkxlYWZDaHVuay5wcm90b3R5cGUgPSB7XFxuICBjaHVua1NpemU6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5saW5lcy5sZW5ndGggfSxcXG4gIC8vIFJlbW92ZSB0aGUgbiBsaW5lcyBhdCBvZmZzZXQgJ2F0Jy5cXG4gIHJlbW92ZUlubmVyOiBmdW5jdGlvbihhdCwgbikge1xcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcXG5cXG4gICAgZm9yICh2YXIgaSA9IGF0LCBlID0gYXQgKyBuOyBpIDwgZTsgKytpKSB7XFxuICAgICAgdmFyIGxpbmUgPSB0aGlzJDEubGluZXNbaV1cXG4gICAgICB0aGlzJDEuaGVpZ2h0IC09IGxpbmUuaGVpZ2h0XFxuICAgICAgY2xlYW5VcExpbmUobGluZSlcXG4gICAgICBzaWduYWxMYXRlcihsaW5lLCBcXFwiZGVsZXRlXFxcIilcXG4gICAgfVxcbiAgICB0aGlzLmxpbmVzLnNwbGljZShhdCwgbilcXG4gIH0sXFxuICAvLyBIZWxwZXIgdXNlZCB0byBjb2xsYXBzZSBhIHNtYWxsIGJyYW5jaCBpbnRvIGEgc2luZ2xlIGxlYWYuXFxuICBjb2xsYXBzZTogZnVuY3Rpb24obGluZXMpIHtcXG4gICAgbGluZXMucHVzaC5hcHBseShsaW5lcywgdGhpcy5saW5lcylcXG4gIH0sXFxuICAvLyBJbnNlcnQgdGhlIGdpdmVuIGFycmF5IG9mIGxpbmVzIGF0IG9mZnNldCAnYXQnLCBjb3VudCB0aGVtIGFzXFxuICAvLyBoYXZpbmcgdGhlIGdpdmVuIGhlaWdodC5cXG4gIGluc2VydElubmVyOiBmdW5jdGlvbihhdCwgbGluZXMsIGhlaWdodCkge1xcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcXG5cXG4gICAgdGhpcy5oZWlnaHQgKz0gaGVpZ2h0XFxuICAgIHRoaXMubGluZXMgPSB0aGlzLmxpbmVzLnNsaWNlKDAsIGF0KS5jb25jYXQobGluZXMpLmNvbmNhdCh0aGlzLmxpbmVzLnNsaWNlKGF0KSlcXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7ICsraSkgeyBsaW5lc1tpXS5wYXJlbnQgPSB0aGlzJDEgfVxcbiAgfSxcXG4gIC8vIFVzZWQgdG8gaXRlcmF0ZSBvdmVyIGEgcGFydCBvZiB0aGUgdHJlZS5cXG4gIGl0ZXJOOiBmdW5jdGlvbihhdCwgbiwgb3ApIHtcXG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XFxuXFxuICAgIGZvciAodmFyIGUgPSBhdCArIG47IGF0IDwgZTsgKythdClcXG4gICAgICB7IGlmIChvcCh0aGlzJDEubGluZXNbYXRdKSkgeyByZXR1cm4gdHJ1ZSB9IH1cXG4gIH1cXG59XFxuXFxuZnVuY3Rpb24gQnJhbmNoQ2h1bmsoY2hpbGRyZW4pIHtcXG4gIHZhciB0aGlzJDEgPSB0aGlzO1xcblxcbiAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuXFxuICB2YXIgc2l6ZSA9IDAsIGhlaWdodCA9IDBcXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyArK2kpIHtcXG4gICAgdmFyIGNoID0gY2hpbGRyZW5baV1cXG4gICAgc2l6ZSArPSBjaC5jaHVua1NpemUoKTsgaGVpZ2h0ICs9IGNoLmhlaWdodFxcbiAgICBjaC5wYXJlbnQgPSB0aGlzJDFcXG4gIH1cXG4gIHRoaXMuc2l6ZSA9IHNpemVcXG4gIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0XFxuICB0aGlzLnBhcmVudCA9IG51bGxcXG59XFxuXFxuQnJhbmNoQ2h1bmsucHJvdG90eXBlID0ge1xcbiAgY2h1bmtTaXplOiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuc2l6ZSB9LFxcbiAgcmVtb3ZlSW5uZXI6IGZ1bmN0aW9uKGF0LCBuKSB7XFxuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xcblxcbiAgICB0aGlzLnNpemUgLT0gblxcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyArK2kpIHtcXG4gICAgICB2YXIgY2hpbGQgPSB0aGlzJDEuY2hpbGRyZW5baV0sIHN6ID0gY2hpbGQuY2h1bmtTaXplKClcXG4gICAgICBpZiAoYXQgPCBzeikge1xcbiAgICAgICAgdmFyIHJtID0gTWF0aC5taW4obiwgc3ogLSBhdCksIG9sZEhlaWdodCA9IGNoaWxkLmhlaWdodFxcbiAgICAgICAgY2hpbGQucmVtb3ZlSW5uZXIoYXQsIHJtKVxcbiAgICAgICAgdGhpcyQxLmhlaWdodCAtPSBvbGRIZWlnaHQgLSBjaGlsZC5oZWlnaHRcXG4gICAgICAgIGlmIChzeiA9PSBybSkgeyB0aGlzJDEuY2hpbGRyZW4uc3BsaWNlKGktLSwgMSk7IGNoaWxkLnBhcmVudCA9IG51bGwgfVxcbiAgICAgICAgaWYgKChuIC09IHJtKSA9PSAwKSB7IGJyZWFrIH1cXG4gICAgICAgIGF0ID0gMFxcbiAgICAgIH0gZWxzZSB7IGF0IC09IHN6IH1cXG4gICAgfVxcbiAgICAvLyBJZiB0aGUgcmVzdWx0IGlzIHNtYWxsZXIgdGhhbiAyNSBsaW5lcywgZW5zdXJlIHRoYXQgaXQgaXMgYVxcbiAgICAvLyBzaW5nbGUgbGVhZiBub2RlLlxcbiAgICBpZiAodGhpcy5zaXplIC0gbiA8IDI1ICYmXFxuICAgICAgICAodGhpcy5jaGlsZHJlbi5sZW5ndGggPiAxIHx8ICEodGhpcy5jaGlsZHJlblswXSBpbnN0YW5jZW9mIExlYWZDaHVuaykpKSB7XFxuICAgICAgdmFyIGxpbmVzID0gW11cXG4gICAgICB0aGlzLmNvbGxhcHNlKGxpbmVzKVxcbiAgICAgIHRoaXMuY2hpbGRyZW4gPSBbbmV3IExlYWZDaHVuayhsaW5lcyldXFxuICAgICAgdGhpcy5jaGlsZHJlblswXS5wYXJlbnQgPSB0aGlzXFxuICAgIH1cXG4gIH0sXFxuICBjb2xsYXBzZTogZnVuY3Rpb24obGluZXMpIHtcXG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XFxuXFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7ICsraSkgeyB0aGlzJDEuY2hpbGRyZW5baV0uY29sbGFwc2UobGluZXMpIH1cXG4gIH0sXFxuICBpbnNlcnRJbm5lcjogZnVuY3Rpb24oYXQsIGxpbmVzLCBoZWlnaHQpIHtcXG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XFxuXFxuICAgIHRoaXMuc2l6ZSArPSBsaW5lcy5sZW5ndGhcXG4gICAgdGhpcy5oZWlnaHQgKz0gaGVpZ2h0XFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7ICsraSkge1xcbiAgICAgIHZhciBjaGlsZCA9IHRoaXMkMS5jaGlsZHJlbltpXSwgc3ogPSBjaGlsZC5jaHVua1NpemUoKVxcbiAgICAgIGlmIChhdCA8PSBzeikge1xcbiAgICAgICAgY2hpbGQuaW5zZXJ0SW5uZXIoYXQsIGxpbmVzLCBoZWlnaHQpXFxuICAgICAgICBpZiAoY2hpbGQubGluZXMgJiYgY2hpbGQubGluZXMubGVuZ3RoID4gNTApIHtcXG4gICAgICAgICAgLy8gVG8gYXZvaWQgbWVtb3J5IHRocmFzaGluZyB3aGVuIGNoaWxkLmxpbmVzIGlzIGh1Z2UgKGUuZy4gZmlyc3QgdmlldyBvZiBhIGxhcmdlIGZpbGUpLCBpdCdzIG5ldmVyIHNwbGljZWQuXFxuICAgICAgICAgIC8vIEluc3RlYWQsIHNtYWxsIHNsaWNlcyBhcmUgdGFrZW4uIFRoZXkncmUgdGFrZW4gaW4gb3JkZXIgYmVjYXVzZSBzZXF1ZW50aWFsIG1lbW9yeSBhY2Nlc3NlcyBhcmUgZmFzdGVzdC5cXG4gICAgICAgICAgdmFyIHJlbWFpbmluZyA9IGNoaWxkLmxpbmVzLmxlbmd0aCAlIDI1ICsgMjVcXG4gICAgICAgICAgZm9yICh2YXIgcG9zID0gcmVtYWluaW5nOyBwb3MgPCBjaGlsZC5saW5lcy5sZW5ndGg7KSB7XFxuICAgICAgICAgICAgdmFyIGxlYWYgPSBuZXcgTGVhZkNodW5rKGNoaWxkLmxpbmVzLnNsaWNlKHBvcywgcG9zICs9IDI1KSlcXG4gICAgICAgICAgICBjaGlsZC5oZWlnaHQgLT0gbGVhZi5oZWlnaHRcXG4gICAgICAgICAgICB0aGlzJDEuY2hpbGRyZW4uc3BsaWNlKCsraSwgMCwgbGVhZilcXG4gICAgICAgICAgICBsZWFmLnBhcmVudCA9IHRoaXMkMVxcbiAgICAgICAgICB9XFxuICAgICAgICAgIGNoaWxkLmxpbmVzID0gY2hpbGQubGluZXMuc2xpY2UoMCwgcmVtYWluaW5nKVxcbiAgICAgICAgICB0aGlzJDEubWF5YmVTcGlsbCgpXFxuICAgICAgICB9XFxuICAgICAgICBicmVha1xcbiAgICAgIH1cXG4gICAgICBhdCAtPSBzelxcbiAgICB9XFxuICB9LFxcbiAgLy8gV2hlbiBhIG5vZGUgaGFzIGdyb3duLCBjaGVjayB3aGV0aGVyIGl0IHNob3VsZCBiZSBzcGxpdC5cXG4gIG1heWJlU3BpbGw6IGZ1bmN0aW9uKCkge1xcbiAgICBpZiAodGhpcy5jaGlsZHJlbi5sZW5ndGggPD0gMTApIHsgcmV0dXJuIH1cXG4gICAgdmFyIG1lID0gdGhpc1xcbiAgICBkbyB7XFxuICAgICAgdmFyIHNwaWxsZWQgPSBtZS5jaGlsZHJlbi5zcGxpY2UobWUuY2hpbGRyZW4ubGVuZ3RoIC0gNSwgNSlcXG4gICAgICB2YXIgc2libGluZyA9IG5ldyBCcmFuY2hDaHVuayhzcGlsbGVkKVxcbiAgICAgIGlmICghbWUucGFyZW50KSB7IC8vIEJlY29tZSB0aGUgcGFyZW50IG5vZGVcXG4gICAgICAgIHZhciBjb3B5ID0gbmV3IEJyYW5jaENodW5rKG1lLmNoaWxkcmVuKVxcbiAgICAgICAgY29weS5wYXJlbnQgPSBtZVxcbiAgICAgICAgbWUuY2hpbGRyZW4gPSBbY29weSwgc2libGluZ11cXG4gICAgICAgIG1lID0gY29weVxcbiAgICAgfSBlbHNlIHtcXG4gICAgICAgIG1lLnNpemUgLT0gc2libGluZy5zaXplXFxuICAgICAgICBtZS5oZWlnaHQgLT0gc2libGluZy5oZWlnaHRcXG4gICAgICAgIHZhciBteUluZGV4ID0gaW5kZXhPZihtZS5wYXJlbnQuY2hpbGRyZW4sIG1lKVxcbiAgICAgICAgbWUucGFyZW50LmNoaWxkcmVuLnNwbGljZShteUluZGV4ICsgMSwgMCwgc2libGluZylcXG4gICAgICB9XFxuICAgICAgc2libGluZy5wYXJlbnQgPSBtZS5wYXJlbnRcXG4gICAgfSB3aGlsZSAobWUuY2hpbGRyZW4ubGVuZ3RoID4gMTApXFxuICAgIG1lLnBhcmVudC5tYXliZVNwaWxsKClcXG4gIH0sXFxuICBpdGVyTjogZnVuY3Rpb24oYXQsIG4sIG9wKSB7XFxuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xcblxcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyArK2kpIHtcXG4gICAgICB2YXIgY2hpbGQgPSB0aGlzJDEuY2hpbGRyZW5baV0sIHN6ID0gY2hpbGQuY2h1bmtTaXplKClcXG4gICAgICBpZiAoYXQgPCBzeikge1xcbiAgICAgICAgdmFyIHVzZWQgPSBNYXRoLm1pbihuLCBzeiAtIGF0KVxcbiAgICAgICAgaWYgKGNoaWxkLml0ZXJOKGF0LCB1c2VkLCBvcCkpIHsgcmV0dXJuIHRydWUgfVxcbiAgICAgICAgaWYgKChuIC09IHVzZWQpID09IDApIHsgYnJlYWsgfVxcbiAgICAgICAgYXQgPSAwXFxuICAgICAgfSBlbHNlIHsgYXQgLT0gc3ogfVxcbiAgICB9XFxuICB9XFxufVxcblxcbi8vIExpbmUgd2lkZ2V0cyBhcmUgYmxvY2sgZWxlbWVudHMgZGlzcGxheWVkIGFib3ZlIG9yIGJlbG93IGEgbGluZS5cXG5cXG5mdW5jdGlvbiBMaW5lV2lkZ2V0KGRvYywgbm9kZSwgb3B0aW9ucykge1xcbiAgdmFyIHRoaXMkMSA9IHRoaXM7XFxuXFxuICBpZiAob3B0aW9ucykgeyBmb3IgKHZhciBvcHQgaW4gb3B0aW9ucykgeyBpZiAob3B0aW9ucy5oYXNPd25Qcm9wZXJ0eShvcHQpKVxcbiAgICB7IHRoaXMkMVtvcHRdID0gb3B0aW9uc1tvcHRdIH0gfSB9XFxuICB0aGlzLmRvYyA9IGRvY1xcbiAgdGhpcy5ub2RlID0gbm9kZVxcbn1cXG5ldmVudE1peGluKExpbmVXaWRnZXQpXFxuXFxuZnVuY3Rpb24gYWRqdXN0U2Nyb2xsV2hlbkFib3ZlVmlzaWJsZShjbSwgbGluZSwgZGlmZikge1xcbiAgaWYgKGhlaWdodEF0TGluZShsaW5lKSA8ICgoY20uY3VyT3AgJiYgY20uY3VyT3Auc2Nyb2xsVG9wKSB8fCBjbS5kb2Muc2Nyb2xsVG9wKSlcXG4gICAgeyBhZGRUb1Njcm9sbFBvcyhjbSwgbnVsbCwgZGlmZikgfVxcbn1cXG5cXG5MaW5lV2lkZ2V0LnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uKCkge1xcbiAgdmFyIHRoaXMkMSA9IHRoaXM7XFxuXFxuICB2YXIgY20gPSB0aGlzLmRvYy5jbSwgd3MgPSB0aGlzLmxpbmUud2lkZ2V0cywgbGluZSA9IHRoaXMubGluZSwgbm8gPSBsaW5lTm8obGluZSlcXG4gIGlmIChubyA9PSBudWxsIHx8ICF3cykgeyByZXR1cm4gfVxcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB3cy5sZW5ndGg7ICsraSkgeyBpZiAod3NbaV0gPT0gdGhpcyQxKSB7IHdzLnNwbGljZShpLS0sIDEpIH0gfVxcbiAgaWYgKCF3cy5sZW5ndGgpIHsgbGluZS53aWRnZXRzID0gbnVsbCB9XFxuICB2YXIgaGVpZ2h0ID0gd2lkZ2V0SGVpZ2h0KHRoaXMpXFxuICB1cGRhdGVMaW5lSGVpZ2h0KGxpbmUsIE1hdGgubWF4KDAsIGxpbmUuaGVpZ2h0IC0gaGVpZ2h0KSlcXG4gIGlmIChjbSkgeyBydW5Jbk9wKGNtLCBmdW5jdGlvbiAoKSB7XFxuICAgIGFkanVzdFNjcm9sbFdoZW5BYm92ZVZpc2libGUoY20sIGxpbmUsIC1oZWlnaHQpXFxuICAgIHJlZ0xpbmVDaGFuZ2UoY20sIG5vLCBcXFwid2lkZ2V0XFxcIilcXG4gIH0pIH1cXG59XFxuTGluZVdpZGdldC5wcm90b3R5cGUuY2hhbmdlZCA9IGZ1bmN0aW9uKCkge1xcbiAgdmFyIG9sZEggPSB0aGlzLmhlaWdodCwgY20gPSB0aGlzLmRvYy5jbSwgbGluZSA9IHRoaXMubGluZVxcbiAgdGhpcy5oZWlnaHQgPSBudWxsXFxuICB2YXIgZGlmZiA9IHdpZGdldEhlaWdodCh0aGlzKSAtIG9sZEhcXG4gIGlmICghZGlmZikgeyByZXR1cm4gfVxcbiAgdXBkYXRlTGluZUhlaWdodChsaW5lLCBsaW5lLmhlaWdodCArIGRpZmYpXFxuICBpZiAoY20pIHsgcnVuSW5PcChjbSwgZnVuY3Rpb24gKCkge1xcbiAgICBjbS5jdXJPcC5mb3JjZVVwZGF0ZSA9IHRydWVcXG4gICAgYWRqdXN0U2Nyb2xsV2hlbkFib3ZlVmlzaWJsZShjbSwgbGluZSwgZGlmZilcXG4gIH0pIH1cXG59XFxuXFxuZnVuY3Rpb24gYWRkTGluZVdpZGdldChkb2MsIGhhbmRsZSwgbm9kZSwgb3B0aW9ucykge1xcbiAgdmFyIHdpZGdldCA9IG5ldyBMaW5lV2lkZ2V0KGRvYywgbm9kZSwgb3B0aW9ucylcXG4gIHZhciBjbSA9IGRvYy5jbVxcbiAgaWYgKGNtICYmIHdpZGdldC5ub0hTY3JvbGwpIHsgY20uZGlzcGxheS5hbGlnbldpZGdldHMgPSB0cnVlIH1cXG4gIGNoYW5nZUxpbmUoZG9jLCBoYW5kbGUsIFxcXCJ3aWRnZXRcXFwiLCBmdW5jdGlvbiAobGluZSkge1xcbiAgICB2YXIgd2lkZ2V0cyA9IGxpbmUud2lkZ2V0cyB8fCAobGluZS53aWRnZXRzID0gW10pXFxuICAgIGlmICh3aWRnZXQuaW5zZXJ0QXQgPT0gbnVsbCkgeyB3aWRnZXRzLnB1c2god2lkZ2V0KSB9XFxuICAgIGVsc2UgeyB3aWRnZXRzLnNwbGljZShNYXRoLm1pbih3aWRnZXRzLmxlbmd0aCAtIDEsIE1hdGgubWF4KDAsIHdpZGdldC5pbnNlcnRBdCkpLCAwLCB3aWRnZXQpIH1cXG4gICAgd2lkZ2V0LmxpbmUgPSBsaW5lXFxuICAgIGlmIChjbSAmJiAhbGluZUlzSGlkZGVuKGRvYywgbGluZSkpIHtcXG4gICAgICB2YXIgYWJvdmVWaXNpYmxlID0gaGVpZ2h0QXRMaW5lKGxpbmUpIDwgZG9jLnNjcm9sbFRvcFxcbiAgICAgIHVwZGF0ZUxpbmVIZWlnaHQobGluZSwgbGluZS5oZWlnaHQgKyB3aWRnZXRIZWlnaHQod2lkZ2V0KSlcXG4gICAgICBpZiAoYWJvdmVWaXNpYmxlKSB7IGFkZFRvU2Nyb2xsUG9zKGNtLCBudWxsLCB3aWRnZXQuaGVpZ2h0KSB9XFxuICAgICAgY20uY3VyT3AuZm9yY2VVcGRhdGUgPSB0cnVlXFxuICAgIH1cXG4gICAgcmV0dXJuIHRydWVcXG4gIH0pXFxuICByZXR1cm4gd2lkZ2V0XFxufVxcblxcbi8vIFRFWFRNQVJLRVJTXFxuXFxuLy8gQ3JlYXRlZCB3aXRoIG1hcmtUZXh0IGFuZCBzZXRCb29rbWFyayBtZXRob2RzLiBBIFRleHRNYXJrZXIgaXMgYVxcbi8vIGhhbmRsZSB0aGF0IGNhbiBiZSB1c2VkIHRvIGNsZWFyIG9yIGZpbmQgYSBtYXJrZWQgcG9zaXRpb24gaW4gdGhlXFxuLy8gZG9jdW1lbnQuIExpbmUgb2JqZWN0cyBob2xkIGFycmF5cyAobWFya2VkU3BhbnMpIGNvbnRhaW5pbmdcXG4vLyB7ZnJvbSwgdG8sIG1hcmtlcn0gb2JqZWN0IHBvaW50aW5nIHRvIHN1Y2ggbWFya2VyIG9iamVjdHMsIGFuZFxcbi8vIGluZGljYXRpbmcgdGhhdCBzdWNoIGEgbWFya2VyIGlzIHByZXNlbnQgb24gdGhhdCBsaW5lLiBNdWx0aXBsZVxcbi8vIGxpbmVzIG1heSBwb2ludCB0byB0aGUgc2FtZSBtYXJrZXIgd2hlbiBpdCBzcGFucyBhY3Jvc3MgbGluZXMuXFxuLy8gVGhlIHNwYW5zIHdpbGwgaGF2ZSBudWxsIGZvciB0aGVpciBmcm9tL3RvIHByb3BlcnRpZXMgd2hlbiB0aGVcXG4vLyBtYXJrZXIgY29udGludWVzIGJleW9uZCB0aGUgc3RhcnQvZW5kIG9mIHRoZSBsaW5lLiBNYXJrZXJzIGhhdmVcXG4vLyBsaW5rcyBiYWNrIHRvIHRoZSBsaW5lcyB0aGV5IGN1cnJlbnRseSB0b3VjaC5cXG5cXG4vLyBDb2xsYXBzZWQgbWFya2VycyBoYXZlIHVuaXF1ZSBpZHMsIGluIG9yZGVyIHRvIGJlIGFibGUgdG8gb3JkZXJcXG4vLyB0aGVtLCB3aGljaCBpcyBuZWVkZWQgZm9yIHVuaXF1ZWx5IGRldGVybWluaW5nIGFuIG91dGVyIG1hcmtlclxcbi8vIHdoZW4gdGhleSBvdmVybGFwICh0aGV5IG1heSBuZXN0LCBidXQgbm90IHBhcnRpYWxseSBvdmVybGFwKS5cXG52YXIgbmV4dE1hcmtlcklkID0gMFxcblxcbmZ1bmN0aW9uIFRleHRNYXJrZXIoZG9jLCB0eXBlKSB7XFxuICB0aGlzLmxpbmVzID0gW11cXG4gIHRoaXMudHlwZSA9IHR5cGVcXG4gIHRoaXMuZG9jID0gZG9jXFxuICB0aGlzLmlkID0gKytuZXh0TWFya2VySWRcXG59XFxuZXZlbnRNaXhpbihUZXh0TWFya2VyKVxcblxcbi8vIENsZWFyIHRoZSBtYXJrZXIuXFxuVGV4dE1hcmtlci5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbigpIHtcXG4gIHZhciB0aGlzJDEgPSB0aGlzO1xcblxcbiAgaWYgKHRoaXMuZXhwbGljaXRseUNsZWFyZWQpIHsgcmV0dXJuIH1cXG4gIHZhciBjbSA9IHRoaXMuZG9jLmNtLCB3aXRoT3AgPSBjbSAmJiAhY20uY3VyT3BcXG4gIGlmICh3aXRoT3ApIHsgc3RhcnRPcGVyYXRpb24oY20pIH1cXG4gIGlmIChoYXNIYW5kbGVyKHRoaXMsIFxcXCJjbGVhclxcXCIpKSB7XFxuICAgIHZhciBmb3VuZCA9IHRoaXMuZmluZCgpXFxuICAgIGlmIChmb3VuZCkgeyBzaWduYWxMYXRlcih0aGlzLCBcXFwiY2xlYXJcXFwiLCBmb3VuZC5mcm9tLCBmb3VuZC50bykgfVxcbiAgfVxcbiAgdmFyIG1pbiA9IG51bGwsIG1heCA9IG51bGxcXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5saW5lcy5sZW5ndGg7ICsraSkge1xcbiAgICB2YXIgbGluZSA9IHRoaXMkMS5saW5lc1tpXVxcbiAgICB2YXIgc3BhbiA9IGdldE1hcmtlZFNwYW5Gb3IobGluZS5tYXJrZWRTcGFucywgdGhpcyQxKVxcbiAgICBpZiAoY20gJiYgIXRoaXMkMS5jb2xsYXBzZWQpIHsgcmVnTGluZUNoYW5nZShjbSwgbGluZU5vKGxpbmUpLCBcXFwidGV4dFxcXCIpIH1cXG4gICAgZWxzZSBpZiAoY20pIHtcXG4gICAgICBpZiAoc3Bhbi50byAhPSBudWxsKSB7IG1heCA9IGxpbmVObyhsaW5lKSB9XFxuICAgICAgaWYgKHNwYW4uZnJvbSAhPSBudWxsKSB7IG1pbiA9IGxpbmVObyhsaW5lKSB9XFxuICAgIH1cXG4gICAgbGluZS5tYXJrZWRTcGFucyA9IHJlbW92ZU1hcmtlZFNwYW4obGluZS5tYXJrZWRTcGFucywgc3BhbilcXG4gICAgaWYgKHNwYW4uZnJvbSA9PSBudWxsICYmIHRoaXMkMS5jb2xsYXBzZWQgJiYgIWxpbmVJc0hpZGRlbih0aGlzJDEuZG9jLCBsaW5lKSAmJiBjbSlcXG4gICAgICB7IHVwZGF0ZUxpbmVIZWlnaHQobGluZSwgdGV4dEhlaWdodChjbS5kaXNwbGF5KSkgfVxcbiAgfVxcbiAgaWYgKGNtICYmIHRoaXMuY29sbGFwc2VkICYmICFjbS5vcHRpb25zLmxpbmVXcmFwcGluZykgeyBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCB0aGlzLmxpbmVzLmxlbmd0aDsgKytpJDEpIHtcXG4gICAgdmFyIHZpc3VhbCA9IHZpc3VhbExpbmUodGhpcyQxLmxpbmVzW2kkMV0pLCBsZW4gPSBsaW5lTGVuZ3RoKHZpc3VhbClcXG4gICAgaWYgKGxlbiA+IGNtLmRpc3BsYXkubWF4TGluZUxlbmd0aCkge1xcbiAgICAgIGNtLmRpc3BsYXkubWF4TGluZSA9IHZpc3VhbFxcbiAgICAgIGNtLmRpc3BsYXkubWF4TGluZUxlbmd0aCA9IGxlblxcbiAgICAgIGNtLmRpc3BsYXkubWF4TGluZUNoYW5nZWQgPSB0cnVlXFxuICAgIH1cXG4gIH0gfVxcblxcbiAgaWYgKG1pbiAhPSBudWxsICYmIGNtICYmIHRoaXMuY29sbGFwc2VkKSB7IHJlZ0NoYW5nZShjbSwgbWluLCBtYXggKyAxKSB9XFxuICB0aGlzLmxpbmVzLmxlbmd0aCA9IDBcXG4gIHRoaXMuZXhwbGljaXRseUNsZWFyZWQgPSB0cnVlXFxuICBpZiAodGhpcy5hdG9taWMgJiYgdGhpcy5kb2MuY2FudEVkaXQpIHtcXG4gICAgdGhpcy5kb2MuY2FudEVkaXQgPSBmYWxzZVxcbiAgICBpZiAoY20pIHsgcmVDaGVja1NlbGVjdGlvbihjbS5kb2MpIH1cXG4gIH1cXG4gIGlmIChjbSkgeyBzaWduYWxMYXRlcihjbSwgXFxcIm1hcmtlckNsZWFyZWRcXFwiLCBjbSwgdGhpcykgfVxcbiAgaWYgKHdpdGhPcCkgeyBlbmRPcGVyYXRpb24oY20pIH1cXG4gIGlmICh0aGlzLnBhcmVudCkgeyB0aGlzLnBhcmVudC5jbGVhcigpIH1cXG59XFxuXFxuLy8gRmluZCB0aGUgcG9zaXRpb24gb2YgdGhlIG1hcmtlciBpbiB0aGUgZG9jdW1lbnQuIFJldHVybnMgYSB7ZnJvbSxcXG4vLyB0b30gb2JqZWN0IGJ5IGRlZmF1bHQuIFNpZGUgY2FuIGJlIHBhc3NlZCB0byBnZXQgYSBzcGVjaWZpYyBzaWRlXFxuLy8gLS0gMCAoYm90aCksIC0xIChsZWZ0KSwgb3IgMSAocmlnaHQpLiBXaGVuIGxpbmVPYmogaXMgdHJ1ZSwgdGhlXFxuLy8gUG9zIG9iamVjdHMgcmV0dXJuZWQgY29udGFpbiBhIGxpbmUgb2JqZWN0LCByYXRoZXIgdGhhbiBhIGxpbmVcXG4vLyBudW1iZXIgKHVzZWQgdG8gcHJldmVudCBsb29raW5nIHVwIHRoZSBzYW1lIGxpbmUgdHdpY2UpLlxcblRleHRNYXJrZXIucHJvdG90eXBlLmZpbmQgPSBmdW5jdGlvbihzaWRlLCBsaW5lT2JqKSB7XFxuICB2YXIgdGhpcyQxID0gdGhpcztcXG5cXG4gIGlmIChzaWRlID09IG51bGwgJiYgdGhpcy50eXBlID09IFxcXCJib29rbWFya1xcXCIpIHsgc2lkZSA9IDEgfVxcbiAgdmFyIGZyb20sIHRvXFxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGluZXMubGVuZ3RoOyArK2kpIHtcXG4gICAgdmFyIGxpbmUgPSB0aGlzJDEubGluZXNbaV1cXG4gICAgdmFyIHNwYW4gPSBnZXRNYXJrZWRTcGFuRm9yKGxpbmUubWFya2VkU3BhbnMsIHRoaXMkMSlcXG4gICAgaWYgKHNwYW4uZnJvbSAhPSBudWxsKSB7XFxuICAgICAgZnJvbSA9IFBvcyhsaW5lT2JqID8gbGluZSA6IGxpbmVObyhsaW5lKSwgc3Bhbi5mcm9tKVxcbiAgICAgIGlmIChzaWRlID09IC0xKSB7IHJldHVybiBmcm9tIH1cXG4gICAgfVxcbiAgICBpZiAoc3Bhbi50byAhPSBudWxsKSB7XFxuICAgICAgdG8gPSBQb3MobGluZU9iaiA/IGxpbmUgOiBsaW5lTm8obGluZSksIHNwYW4udG8pXFxuICAgICAgaWYgKHNpZGUgPT0gMSkgeyByZXR1cm4gdG8gfVxcbiAgICB9XFxuICB9XFxuICByZXR1cm4gZnJvbSAmJiB7ZnJvbTogZnJvbSwgdG86IHRvfVxcbn1cXG5cXG4vLyBTaWduYWxzIHRoYXQgdGhlIG1hcmtlcidzIHdpZGdldCBjaGFuZ2VkLCBhbmQgc3Vycm91bmRpbmcgbGF5b3V0XFxuLy8gc2hvdWxkIGJlIHJlY29tcHV0ZWQuXFxuVGV4dE1hcmtlci5wcm90b3R5cGUuY2hhbmdlZCA9IGZ1bmN0aW9uKCkge1xcbiAgdmFyIHBvcyA9IHRoaXMuZmluZCgtMSwgdHJ1ZSksIHdpZGdldCA9IHRoaXMsIGNtID0gdGhpcy5kb2MuY21cXG4gIGlmICghcG9zIHx8ICFjbSkgeyByZXR1cm4gfVxcbiAgcnVuSW5PcChjbSwgZnVuY3Rpb24gKCkge1xcbiAgICB2YXIgbGluZSA9IHBvcy5saW5lLCBsaW5lTiA9IGxpbmVObyhwb3MubGluZSlcXG4gICAgdmFyIHZpZXcgPSBmaW5kVmlld0ZvckxpbmUoY20sIGxpbmVOKVxcbiAgICBpZiAodmlldykge1xcbiAgICAgIGNsZWFyTGluZU1lYXN1cmVtZW50Q2FjaGVGb3IodmlldylcXG4gICAgICBjbS5jdXJPcC5zZWxlY3Rpb25DaGFuZ2VkID0gY20uY3VyT3AuZm9yY2VVcGRhdGUgPSB0cnVlXFxuICAgIH1cXG4gICAgY20uY3VyT3AudXBkYXRlTWF4TGluZSA9IHRydWVcXG4gICAgaWYgKCFsaW5lSXNIaWRkZW4od2lkZ2V0LmRvYywgbGluZSkgJiYgd2lkZ2V0LmhlaWdodCAhPSBudWxsKSB7XFxuICAgICAgdmFyIG9sZEhlaWdodCA9IHdpZGdldC5oZWlnaHRcXG4gICAgICB3aWRnZXQuaGVpZ2h0ID0gbnVsbFxcbiAgICAgIHZhciBkSGVpZ2h0ID0gd2lkZ2V0SGVpZ2h0KHdpZGdldCkgLSBvbGRIZWlnaHRcXG4gICAgICBpZiAoZEhlaWdodClcXG4gICAgICAgIHsgdXBkYXRlTGluZUhlaWdodChsaW5lLCBsaW5lLmhlaWdodCArIGRIZWlnaHQpIH1cXG4gICAgfVxcbiAgfSlcXG59XFxuXFxuVGV4dE1hcmtlci5wcm90b3R5cGUuYXR0YWNoTGluZSA9IGZ1bmN0aW9uKGxpbmUpIHtcXG4gIGlmICghdGhpcy5saW5lcy5sZW5ndGggJiYgdGhpcy5kb2MuY20pIHtcXG4gICAgdmFyIG9wID0gdGhpcy5kb2MuY20uY3VyT3BcXG4gICAgaWYgKCFvcC5tYXliZUhpZGRlbk1hcmtlcnMgfHwgaW5kZXhPZihvcC5tYXliZUhpZGRlbk1hcmtlcnMsIHRoaXMpID09IC0xKVxcbiAgICAgIHsgKG9wLm1heWJlVW5oaWRkZW5NYXJrZXJzIHx8IChvcC5tYXliZVVuaGlkZGVuTWFya2VycyA9IFtdKSkucHVzaCh0aGlzKSB9XFxuICB9XFxuICB0aGlzLmxpbmVzLnB1c2gobGluZSlcXG59XFxuVGV4dE1hcmtlci5wcm90b3R5cGUuZGV0YWNoTGluZSA9IGZ1bmN0aW9uKGxpbmUpIHtcXG4gIHRoaXMubGluZXMuc3BsaWNlKGluZGV4T2YodGhpcy5saW5lcywgbGluZSksIDEpXFxuICBpZiAoIXRoaXMubGluZXMubGVuZ3RoICYmIHRoaXMuZG9jLmNtKSB7XFxuICAgIHZhciBvcCA9IHRoaXMuZG9jLmNtLmN1ck9wXFxuICAgIDsob3AubWF5YmVIaWRkZW5NYXJrZXJzIHx8IChvcC5tYXliZUhpZGRlbk1hcmtlcnMgPSBbXSkpLnB1c2godGhpcylcXG4gIH1cXG59XFxuXFxuLy8gQ3JlYXRlIGEgbWFya2VyLCB3aXJlIGl0IHVwIHRvIHRoZSByaWdodCBsaW5lcywgYW5kXFxuZnVuY3Rpb24gbWFya1RleHQoZG9jLCBmcm9tLCB0bywgb3B0aW9ucywgdHlwZSkge1xcbiAgLy8gU2hhcmVkIG1hcmtlcnMgKGFjcm9zcyBsaW5rZWQgZG9jdW1lbnRzKSBhcmUgaGFuZGxlZCBzZXBhcmF0ZWx5XFxuICAvLyAobWFya1RleHRTaGFyZWQgd2lsbCBjYWxsIG91dCB0byB0aGlzIGFnYWluLCBvbmNlIHBlclxcbiAgLy8gZG9jdW1lbnQpLlxcbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5zaGFyZWQpIHsgcmV0dXJuIG1hcmtUZXh0U2hhcmVkKGRvYywgZnJvbSwgdG8sIG9wdGlvbnMsIHR5cGUpIH1cXG4gIC8vIEVuc3VyZSB3ZSBhcmUgaW4gYW4gb3BlcmF0aW9uLlxcbiAgaWYgKGRvYy5jbSAmJiAhZG9jLmNtLmN1ck9wKSB7IHJldHVybiBvcGVyYXRpb24oZG9jLmNtLCBtYXJrVGV4dCkoZG9jLCBmcm9tLCB0bywgb3B0aW9ucywgdHlwZSkgfVxcblxcbiAgdmFyIG1hcmtlciA9IG5ldyBUZXh0TWFya2VyKGRvYywgdHlwZSksIGRpZmYgPSBjbXAoZnJvbSwgdG8pXFxuICBpZiAob3B0aW9ucykgeyBjb3B5T2JqKG9wdGlvbnMsIG1hcmtlciwgZmFsc2UpIH1cXG4gIC8vIERvbid0IGNvbm5lY3QgZW1wdHkgbWFya2VycyB1bmxlc3MgY2xlYXJXaGVuRW1wdHkgaXMgZmFsc2VcXG4gIGlmIChkaWZmID4gMCB8fCBkaWZmID09IDAgJiYgbWFya2VyLmNsZWFyV2hlbkVtcHR5ICE9PSBmYWxzZSlcXG4gICAgeyByZXR1cm4gbWFya2VyIH1cXG4gIGlmIChtYXJrZXIucmVwbGFjZWRXaXRoKSB7XFxuICAgIC8vIFNob3dpbmcgdXAgYXMgYSB3aWRnZXQgaW1wbGllcyBjb2xsYXBzZWQgKHdpZGdldCByZXBsYWNlcyB0ZXh0KVxcbiAgICBtYXJrZXIuY29sbGFwc2VkID0gdHJ1ZVxcbiAgICBtYXJrZXIud2lkZ2V0Tm9kZSA9IGVsdChcXFwic3BhblxcXCIsIFttYXJrZXIucmVwbGFjZWRXaXRoXSwgXFxcIkNvZGVNaXJyb3Itd2lkZ2V0XFxcIilcXG4gICAgbWFya2VyLndpZGdldE5vZGUuc2V0QXR0cmlidXRlKFxcXCJyb2xlXFxcIiwgXFxcInByZXNlbnRhdGlvblxcXCIpIC8vIGhpZGUgZnJvbSBhY2Nlc3NpYmlsaXR5IHRyZWVcXG4gICAgaWYgKCFvcHRpb25zLmhhbmRsZU1vdXNlRXZlbnRzKSB7IG1hcmtlci53aWRnZXROb2RlLnNldEF0dHJpYnV0ZShcXFwiY20taWdub3JlLWV2ZW50c1xcXCIsIFxcXCJ0cnVlXFxcIikgfVxcbiAgICBpZiAob3B0aW9ucy5pbnNlcnRMZWZ0KSB7IG1hcmtlci53aWRnZXROb2RlLmluc2VydExlZnQgPSB0cnVlIH1cXG4gIH1cXG4gIGlmIChtYXJrZXIuY29sbGFwc2VkKSB7XFxuICAgIGlmIChjb25mbGljdGluZ0NvbGxhcHNlZFJhbmdlKGRvYywgZnJvbS5saW5lLCBmcm9tLCB0bywgbWFya2VyKSB8fFxcbiAgICAgICAgZnJvbS5saW5lICE9IHRvLmxpbmUgJiYgY29uZmxpY3RpbmdDb2xsYXBzZWRSYW5nZShkb2MsIHRvLmxpbmUsIGZyb20sIHRvLCBtYXJrZXIpKVxcbiAgICAgIHsgdGhyb3cgbmV3IEVycm9yKFxcXCJJbnNlcnRpbmcgY29sbGFwc2VkIG1hcmtlciBwYXJ0aWFsbHkgb3ZlcmxhcHBpbmcgYW4gZXhpc3Rpbmcgb25lXFxcIikgfVxcbiAgICBzZWVDb2xsYXBzZWRTcGFucygpXFxuICB9XFxuXFxuICBpZiAobWFya2VyLmFkZFRvSGlzdG9yeSlcXG4gICAgeyBhZGRDaGFuZ2VUb0hpc3RvcnkoZG9jLCB7ZnJvbTogZnJvbSwgdG86IHRvLCBvcmlnaW46IFxcXCJtYXJrVGV4dFxcXCJ9LCBkb2Muc2VsLCBOYU4pIH1cXG5cXG4gIHZhciBjdXJMaW5lID0gZnJvbS5saW5lLCBjbSA9IGRvYy5jbSwgdXBkYXRlTWF4TGluZVxcbiAgZG9jLml0ZXIoY3VyTGluZSwgdG8ubGluZSArIDEsIGZ1bmN0aW9uIChsaW5lKSB7XFxuICAgIGlmIChjbSAmJiBtYXJrZXIuY29sbGFwc2VkICYmICFjbS5vcHRpb25zLmxpbmVXcmFwcGluZyAmJiB2aXN1YWxMaW5lKGxpbmUpID09IGNtLmRpc3BsYXkubWF4TGluZSlcXG4gICAgICB7IHVwZGF0ZU1heExpbmUgPSB0cnVlIH1cXG4gICAgaWYgKG1hcmtlci5jb2xsYXBzZWQgJiYgY3VyTGluZSAhPSBmcm9tLmxpbmUpIHsgdXBkYXRlTGluZUhlaWdodChsaW5lLCAwKSB9XFxuICAgIGFkZE1hcmtlZFNwYW4obGluZSwgbmV3IE1hcmtlZFNwYW4obWFya2VyLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1ckxpbmUgPT0gZnJvbS5saW5lID8gZnJvbS5jaCA6IG51bGwsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VyTGluZSA9PSB0by5saW5lID8gdG8uY2ggOiBudWxsKSlcXG4gICAgKytjdXJMaW5lXFxuICB9KVxcbiAgLy8gbGluZUlzSGlkZGVuIGRlcGVuZHMgb24gdGhlIHByZXNlbmNlIG9mIHRoZSBzcGFucywgc28gbmVlZHMgYSBzZWNvbmQgcGFzc1xcbiAgaWYgKG1hcmtlci5jb2xsYXBzZWQpIHsgZG9jLml0ZXIoZnJvbS5saW5lLCB0by5saW5lICsgMSwgZnVuY3Rpb24gKGxpbmUpIHtcXG4gICAgaWYgKGxpbmVJc0hpZGRlbihkb2MsIGxpbmUpKSB7IHVwZGF0ZUxpbmVIZWlnaHQobGluZSwgMCkgfVxcbiAgfSkgfVxcblxcbiAgaWYgKG1hcmtlci5jbGVhck9uRW50ZXIpIHsgb24obWFya2VyLCBcXFwiYmVmb3JlQ3Vyc29yRW50ZXJcXFwiLCBmdW5jdGlvbiAoKSB7IHJldHVybiBtYXJrZXIuY2xlYXIoKTsgfSkgfVxcblxcbiAgaWYgKG1hcmtlci5yZWFkT25seSkge1xcbiAgICBzZWVSZWFkT25seVNwYW5zKClcXG4gICAgaWYgKGRvYy5oaXN0b3J5LmRvbmUubGVuZ3RoIHx8IGRvYy5oaXN0b3J5LnVuZG9uZS5sZW5ndGgpXFxuICAgICAgeyBkb2MuY2xlYXJIaXN0b3J5KCkgfVxcbiAgfVxcbiAgaWYgKG1hcmtlci5jb2xsYXBzZWQpIHtcXG4gICAgbWFya2VyLmlkID0gKytuZXh0TWFya2VySWRcXG4gICAgbWFya2VyLmF0b21pYyA9IHRydWVcXG4gIH1cXG4gIGlmIChjbSkge1xcbiAgICAvLyBTeW5jIGVkaXRvciBzdGF0ZVxcbiAgICBpZiAodXBkYXRlTWF4TGluZSkgeyBjbS5jdXJPcC51cGRhdGVNYXhMaW5lID0gdHJ1ZSB9XFxuICAgIGlmIChtYXJrZXIuY29sbGFwc2VkKVxcbiAgICAgIHsgcmVnQ2hhbmdlKGNtLCBmcm9tLmxpbmUsIHRvLmxpbmUgKyAxKSB9XFxuICAgIGVsc2UgaWYgKG1hcmtlci5jbGFzc05hbWUgfHwgbWFya2VyLnRpdGxlIHx8IG1hcmtlci5zdGFydFN0eWxlIHx8IG1hcmtlci5lbmRTdHlsZSB8fCBtYXJrZXIuY3NzKVxcbiAgICAgIHsgZm9yICh2YXIgaSA9IGZyb20ubGluZTsgaSA8PSB0by5saW5lOyBpKyspIHsgcmVnTGluZUNoYW5nZShjbSwgaSwgXFxcInRleHRcXFwiKSB9IH1cXG4gICAgaWYgKG1hcmtlci5hdG9taWMpIHsgcmVDaGVja1NlbGVjdGlvbihjbS5kb2MpIH1cXG4gICAgc2lnbmFsTGF0ZXIoY20sIFxcXCJtYXJrZXJBZGRlZFxcXCIsIGNtLCBtYXJrZXIpXFxuICB9XFxuICByZXR1cm4gbWFya2VyXFxufVxcblxcbi8vIFNIQVJFRCBURVhUTUFSS0VSU1xcblxcbi8vIEEgc2hhcmVkIG1hcmtlciBzcGFucyBtdWx0aXBsZSBsaW5rZWQgZG9jdW1lbnRzLiBJdCBpc1xcbi8vIGltcGxlbWVudGVkIGFzIGEgbWV0YS1tYXJrZXItb2JqZWN0IGNvbnRyb2xsaW5nIG11bHRpcGxlIG5vcm1hbFxcbi8vIG1hcmtlcnMuXFxuZnVuY3Rpb24gU2hhcmVkVGV4dE1hcmtlcihtYXJrZXJzLCBwcmltYXJ5KSB7XFxuICB2YXIgdGhpcyQxID0gdGhpcztcXG5cXG4gIHRoaXMubWFya2VycyA9IG1hcmtlcnNcXG4gIHRoaXMucHJpbWFyeSA9IHByaW1hcnlcXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbWFya2Vycy5sZW5ndGg7ICsraSlcXG4gICAgeyBtYXJrZXJzW2ldLnBhcmVudCA9IHRoaXMkMSB9XFxufVxcbmV2ZW50TWl4aW4oU2hhcmVkVGV4dE1hcmtlcilcXG5cXG5TaGFyZWRUZXh0TWFya2VyLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uKCkge1xcbiAgdmFyIHRoaXMkMSA9IHRoaXM7XFxuXFxuICBpZiAodGhpcy5leHBsaWNpdGx5Q2xlYXJlZCkgeyByZXR1cm4gfVxcbiAgdGhpcy5leHBsaWNpdGx5Q2xlYXJlZCA9IHRydWVcXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5tYXJrZXJzLmxlbmd0aDsgKytpKVxcbiAgICB7IHRoaXMkMS5tYXJrZXJzW2ldLmNsZWFyKCkgfVxcbiAgc2lnbmFsTGF0ZXIodGhpcywgXFxcImNsZWFyXFxcIilcXG59XFxuU2hhcmVkVGV4dE1hcmtlci5wcm90b3R5cGUuZmluZCA9IGZ1bmN0aW9uKHNpZGUsIGxpbmVPYmopIHtcXG4gIHJldHVybiB0aGlzLnByaW1hcnkuZmluZChzaWRlLCBsaW5lT2JqKVxcbn1cXG5cXG5mdW5jdGlvbiBtYXJrVGV4dFNoYXJlZChkb2MsIGZyb20sIHRvLCBvcHRpb25zLCB0eXBlKSB7XFxuICBvcHRpb25zID0gY29weU9iaihvcHRpb25zKVxcbiAgb3B0aW9ucy5zaGFyZWQgPSBmYWxzZVxcbiAgdmFyIG1hcmtlcnMgPSBbbWFya1RleHQoZG9jLCBmcm9tLCB0bywgb3B0aW9ucywgdHlwZSldLCBwcmltYXJ5ID0gbWFya2Vyc1swXVxcbiAgdmFyIHdpZGdldCA9IG9wdGlvbnMud2lkZ2V0Tm9kZVxcbiAgbGlua2VkRG9jcyhkb2MsIGZ1bmN0aW9uIChkb2MpIHtcXG4gICAgaWYgKHdpZGdldCkgeyBvcHRpb25zLndpZGdldE5vZGUgPSB3aWRnZXQuY2xvbmVOb2RlKHRydWUpIH1cXG4gICAgbWFya2Vycy5wdXNoKG1hcmtUZXh0KGRvYywgY2xpcFBvcyhkb2MsIGZyb20pLCBjbGlwUG9zKGRvYywgdG8pLCBvcHRpb25zLCB0eXBlKSlcXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkb2MubGlua2VkLmxlbmd0aDsgKytpKVxcbiAgICAgIHsgaWYgKGRvYy5saW5rZWRbaV0uaXNQYXJlbnQpIHsgcmV0dXJuIH0gfVxcbiAgICBwcmltYXJ5ID0gbHN0KG1hcmtlcnMpXFxuICB9KVxcbiAgcmV0dXJuIG5ldyBTaGFyZWRUZXh0TWFya2VyKG1hcmtlcnMsIHByaW1hcnkpXFxufVxcblxcbmZ1bmN0aW9uIGZpbmRTaGFyZWRNYXJrZXJzKGRvYykge1xcbiAgcmV0dXJuIGRvYy5maW5kTWFya3MoUG9zKGRvYy5maXJzdCwgMCksIGRvYy5jbGlwUG9zKFBvcyhkb2MubGFzdExpbmUoKSkpLCBmdW5jdGlvbiAobSkgeyByZXR1cm4gbS5wYXJlbnQ7IH0pXFxufVxcblxcbmZ1bmN0aW9uIGNvcHlTaGFyZWRNYXJrZXJzKGRvYywgbWFya2Vycykge1xcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXJrZXJzLmxlbmd0aDsgaSsrKSB7XFxuICAgIHZhciBtYXJrZXIgPSBtYXJrZXJzW2ldLCBwb3MgPSBtYXJrZXIuZmluZCgpXFxuICAgIHZhciBtRnJvbSA9IGRvYy5jbGlwUG9zKHBvcy5mcm9tKSwgbVRvID0gZG9jLmNsaXBQb3MocG9zLnRvKVxcbiAgICBpZiAoY21wKG1Gcm9tLCBtVG8pKSB7XFxuICAgICAgdmFyIHN1Yk1hcmsgPSBtYXJrVGV4dChkb2MsIG1Gcm9tLCBtVG8sIG1hcmtlci5wcmltYXJ5LCBtYXJrZXIucHJpbWFyeS50eXBlKVxcbiAgICAgIG1hcmtlci5tYXJrZXJzLnB1c2goc3ViTWFyaylcXG4gICAgICBzdWJNYXJrLnBhcmVudCA9IG1hcmtlclxcbiAgICB9XFxuICB9XFxufVxcblxcbmZ1bmN0aW9uIGRldGFjaFNoYXJlZE1hcmtlcnMobWFya2Vycykge1xcbiAgdmFyIGxvb3AgPSBmdW5jdGlvbiAoIGkgKSB7XFxuICAgIHZhciBtYXJrZXIgPSBtYXJrZXJzW2ldLCBsaW5rZWQgPSBbbWFya2VyLnByaW1hcnkuZG9jXVxcbiAgICBsaW5rZWREb2NzKG1hcmtlci5wcmltYXJ5LmRvYywgZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGxpbmtlZC5wdXNoKGQpOyB9KVxcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IG1hcmtlci5tYXJrZXJzLmxlbmd0aDsgaisrKSB7XFxuICAgICAgdmFyIHN1Yk1hcmtlciA9IG1hcmtlci5tYXJrZXJzW2pdXFxuICAgICAgaWYgKGluZGV4T2YobGlua2VkLCBzdWJNYXJrZXIuZG9jKSA9PSAtMSkge1xcbiAgICAgICAgc3ViTWFya2VyLnBhcmVudCA9IG51bGxcXG4gICAgICAgIG1hcmtlci5tYXJrZXJzLnNwbGljZShqLS0sIDEpXFxuICAgICAgfVxcbiAgICB9XFxuICB9O1xcblxcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXJrZXJzLmxlbmd0aDsgaSsrKSBsb29wKCBpICk7XFxufVxcblxcbnZhciBuZXh0RG9jSWQgPSAwXFxudmFyIERvYyA9IGZ1bmN0aW9uKHRleHQsIG1vZGUsIGZpcnN0TGluZSwgbGluZVNlcCkge1xcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIERvYykpIHsgcmV0dXJuIG5ldyBEb2ModGV4dCwgbW9kZSwgZmlyc3RMaW5lLCBsaW5lU2VwKSB9XFxuICBpZiAoZmlyc3RMaW5lID09IG51bGwpIHsgZmlyc3RMaW5lID0gMCB9XFxuXFxuICBCcmFuY2hDaHVuay5jYWxsKHRoaXMsIFtuZXcgTGVhZkNodW5rKFtuZXcgTGluZShcXFwiXFxcIiwgbnVsbCldKV0pXFxuICB0aGlzLmZpcnN0ID0gZmlyc3RMaW5lXFxuICB0aGlzLnNjcm9sbFRvcCA9IHRoaXMuc2Nyb2xsTGVmdCA9IDBcXG4gIHRoaXMuY2FudEVkaXQgPSBmYWxzZVxcbiAgdGhpcy5jbGVhbkdlbmVyYXRpb24gPSAxXFxuICB0aGlzLmZyb250aWVyID0gZmlyc3RMaW5lXFxuICB2YXIgc3RhcnQgPSBQb3MoZmlyc3RMaW5lLCAwKVxcbiAgdGhpcy5zZWwgPSBzaW1wbGVTZWxlY3Rpb24oc3RhcnQpXFxuICB0aGlzLmhpc3RvcnkgPSBuZXcgSGlzdG9yeShudWxsKVxcbiAgdGhpcy5pZCA9ICsrbmV4dERvY0lkXFxuICB0aGlzLm1vZGVPcHRpb24gPSBtb2RlXFxuICB0aGlzLmxpbmVTZXAgPSBsaW5lU2VwXFxuICB0aGlzLmV4dGVuZCA9IGZhbHNlXFxuXFxuICBpZiAodHlwZW9mIHRleHQgPT0gXFxcInN0cmluZ1xcXCIpIHsgdGV4dCA9IHRoaXMuc3BsaXRMaW5lcyh0ZXh0KSB9XFxuICB1cGRhdGVEb2ModGhpcywge2Zyb206IHN0YXJ0LCB0bzogc3RhcnQsIHRleHQ6IHRleHR9KVxcbiAgc2V0U2VsZWN0aW9uKHRoaXMsIHNpbXBsZVNlbGVjdGlvbihzdGFydCksIHNlbF9kb250U2Nyb2xsKVxcbn1cXG5cXG5Eb2MucHJvdG90eXBlID0gY3JlYXRlT2JqKEJyYW5jaENodW5rLnByb3RvdHlwZSwge1xcbiAgY29uc3RydWN0b3I6IERvYyxcXG4gIC8vIEl0ZXJhdGUgb3ZlciB0aGUgZG9jdW1lbnQuIFN1cHBvcnRzIHR3byBmb3JtcyAtLSB3aXRoIG9ubHkgb25lXFxuICAvLyBhcmd1bWVudCwgaXQgY2FsbHMgdGhhdCBmb3IgZWFjaCBsaW5lIGluIHRoZSBkb2N1bWVudC4gV2l0aFxcbiAgLy8gdGhyZWUsIGl0IGl0ZXJhdGVzIG92ZXIgdGhlIHJhbmdlIGdpdmVuIGJ5IHRoZSBmaXJzdCB0d28gKHdpdGhcXG4gIC8vIHRoZSBzZWNvbmQgYmVpbmcgbm9uLWluY2x1c2l2ZSkuXFxuICBpdGVyOiBmdW5jdGlvbihmcm9tLCB0bywgb3ApIHtcXG4gICAgaWYgKG9wKSB7IHRoaXMuaXRlck4oZnJvbSAtIHRoaXMuZmlyc3QsIHRvIC0gZnJvbSwgb3ApIH1cXG4gICAgZWxzZSB7IHRoaXMuaXRlck4odGhpcy5maXJzdCwgdGhpcy5maXJzdCArIHRoaXMuc2l6ZSwgZnJvbSkgfVxcbiAgfSxcXG5cXG4gIC8vIE5vbi1wdWJsaWMgaW50ZXJmYWNlIGZvciBhZGRpbmcgYW5kIHJlbW92aW5nIGxpbmVzLlxcbiAgaW5zZXJ0OiBmdW5jdGlvbihhdCwgbGluZXMpIHtcXG4gICAgdmFyIGhlaWdodCA9IDBcXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7ICsraSkgeyBoZWlnaHQgKz0gbGluZXNbaV0uaGVpZ2h0IH1cXG4gICAgdGhpcy5pbnNlcnRJbm5lcihhdCAtIHRoaXMuZmlyc3QsIGxpbmVzLCBoZWlnaHQpXFxuICB9LFxcbiAgcmVtb3ZlOiBmdW5jdGlvbihhdCwgbikgeyB0aGlzLnJlbW92ZUlubmVyKGF0IC0gdGhpcy5maXJzdCwgbikgfSxcXG5cXG4gIC8vIEZyb20gaGVyZSwgdGhlIG1ldGhvZHMgYXJlIHBhcnQgb2YgdGhlIHB1YmxpYyBpbnRlcmZhY2UuIE1vc3RcXG4gIC8vIGFyZSBhbHNvIGF2YWlsYWJsZSBmcm9tIENvZGVNaXJyb3IgKGVkaXRvcikgaW5zdGFuY2VzLlxcblxcbiAgZ2V0VmFsdWU6IGZ1bmN0aW9uKGxpbmVTZXApIHtcXG4gICAgdmFyIGxpbmVzID0gZ2V0TGluZXModGhpcywgdGhpcy5maXJzdCwgdGhpcy5maXJzdCArIHRoaXMuc2l6ZSlcXG4gICAgaWYgKGxpbmVTZXAgPT09IGZhbHNlKSB7IHJldHVybiBsaW5lcyB9XFxuICAgIHJldHVybiBsaW5lcy5qb2luKGxpbmVTZXAgfHwgdGhpcy5saW5lU2VwYXJhdG9yKCkpXFxuICB9LFxcbiAgc2V0VmFsdWU6IGRvY01ldGhvZE9wKGZ1bmN0aW9uKGNvZGUpIHtcXG4gICAgdmFyIHRvcCA9IFBvcyh0aGlzLmZpcnN0LCAwKSwgbGFzdCA9IHRoaXMuZmlyc3QgKyB0aGlzLnNpemUgLSAxXFxuICAgIG1ha2VDaGFuZ2UodGhpcywge2Zyb206IHRvcCwgdG86IFBvcyhsYXN0LCBnZXRMaW5lKHRoaXMsIGxhc3QpLnRleHQubGVuZ3RoKSxcXG4gICAgICAgICAgICAgICAgICAgICAgdGV4dDogdGhpcy5zcGxpdExpbmVzKGNvZGUpLCBvcmlnaW46IFxcXCJzZXRWYWx1ZVxcXCIsIGZ1bGw6IHRydWV9LCB0cnVlKVxcbiAgICBzZXRTZWxlY3Rpb24odGhpcywgc2ltcGxlU2VsZWN0aW9uKHRvcCkpXFxuICB9KSxcXG4gIHJlcGxhY2VSYW5nZTogZnVuY3Rpb24oY29kZSwgZnJvbSwgdG8sIG9yaWdpbikge1xcbiAgICBmcm9tID0gY2xpcFBvcyh0aGlzLCBmcm9tKVxcbiAgICB0byA9IHRvID8gY2xpcFBvcyh0aGlzLCB0bykgOiBmcm9tXFxuICAgIHJlcGxhY2VSYW5nZSh0aGlzLCBjb2RlLCBmcm9tLCB0bywgb3JpZ2luKVxcbiAgfSxcXG4gIGdldFJhbmdlOiBmdW5jdGlvbihmcm9tLCB0bywgbGluZVNlcCkge1xcbiAgICB2YXIgbGluZXMgPSBnZXRCZXR3ZWVuKHRoaXMsIGNsaXBQb3ModGhpcywgZnJvbSksIGNsaXBQb3ModGhpcywgdG8pKVxcbiAgICBpZiAobGluZVNlcCA9PT0gZmFsc2UpIHsgcmV0dXJuIGxpbmVzIH1cXG4gICAgcmV0dXJuIGxpbmVzLmpvaW4obGluZVNlcCB8fCB0aGlzLmxpbmVTZXBhcmF0b3IoKSlcXG4gIH0sXFxuXFxuICBnZXRMaW5lOiBmdW5jdGlvbihsaW5lKSB7dmFyIGwgPSB0aGlzLmdldExpbmVIYW5kbGUobGluZSk7IHJldHVybiBsICYmIGwudGV4dH0sXFxuXFxuICBnZXRMaW5lSGFuZGxlOiBmdW5jdGlvbihsaW5lKSB7aWYgKGlzTGluZSh0aGlzLCBsaW5lKSkgeyByZXR1cm4gZ2V0TGluZSh0aGlzLCBsaW5lKSB9fSxcXG4gIGdldExpbmVOdW1iZXI6IGZ1bmN0aW9uKGxpbmUpIHtyZXR1cm4gbGluZU5vKGxpbmUpfSxcXG5cXG4gIGdldExpbmVIYW5kbGVWaXN1YWxTdGFydDogZnVuY3Rpb24obGluZSkge1xcbiAgICBpZiAodHlwZW9mIGxpbmUgPT0gXFxcIm51bWJlclxcXCIpIHsgbGluZSA9IGdldExpbmUodGhpcywgbGluZSkgfVxcbiAgICByZXR1cm4gdmlzdWFsTGluZShsaW5lKVxcbiAgfSxcXG5cXG4gIGxpbmVDb3VudDogZnVuY3Rpb24oKSB7cmV0dXJuIHRoaXMuc2l6ZX0sXFxuICBmaXJzdExpbmU6IGZ1bmN0aW9uKCkge3JldHVybiB0aGlzLmZpcnN0fSxcXG4gIGxhc3RMaW5lOiBmdW5jdGlvbigpIHtyZXR1cm4gdGhpcy5maXJzdCArIHRoaXMuc2l6ZSAtIDF9LFxcblxcbiAgY2xpcFBvczogZnVuY3Rpb24ocG9zKSB7cmV0dXJuIGNsaXBQb3ModGhpcywgcG9zKX0sXFxuXFxuICBnZXRDdXJzb3I6IGZ1bmN0aW9uKHN0YXJ0KSB7XFxuICAgIHZhciByYW5nZSA9IHRoaXMuc2VsLnByaW1hcnkoKSwgcG9zXFxuICAgIGlmIChzdGFydCA9PSBudWxsIHx8IHN0YXJ0ID09IFxcXCJoZWFkXFxcIikgeyBwb3MgPSByYW5nZS5oZWFkIH1cXG4gICAgZWxzZSBpZiAoc3RhcnQgPT0gXFxcImFuY2hvclxcXCIpIHsgcG9zID0gcmFuZ2UuYW5jaG9yIH1cXG4gICAgZWxzZSBpZiAoc3RhcnQgPT0gXFxcImVuZFxcXCIgfHwgc3RhcnQgPT0gXFxcInRvXFxcIiB8fCBzdGFydCA9PT0gZmFsc2UpIHsgcG9zID0gcmFuZ2UudG8oKSB9XFxuICAgIGVsc2UgeyBwb3MgPSByYW5nZS5mcm9tKCkgfVxcbiAgICByZXR1cm4gcG9zXFxuICB9LFxcbiAgbGlzdFNlbGVjdGlvbnM6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5zZWwucmFuZ2VzIH0sXFxuICBzb21ldGhpbmdTZWxlY3RlZDogZnVuY3Rpb24oKSB7cmV0dXJuIHRoaXMuc2VsLnNvbWV0aGluZ1NlbGVjdGVkKCl9LFxcblxcbiAgc2V0Q3Vyc29yOiBkb2NNZXRob2RPcChmdW5jdGlvbihsaW5lLCBjaCwgb3B0aW9ucykge1xcbiAgICBzZXRTaW1wbGVTZWxlY3Rpb24odGhpcywgY2xpcFBvcyh0aGlzLCB0eXBlb2YgbGluZSA9PSBcXFwibnVtYmVyXFxcIiA/IFBvcyhsaW5lLCBjaCB8fCAwKSA6IGxpbmUpLCBudWxsLCBvcHRpb25zKVxcbiAgfSksXFxuICBzZXRTZWxlY3Rpb246IGRvY01ldGhvZE9wKGZ1bmN0aW9uKGFuY2hvciwgaGVhZCwgb3B0aW9ucykge1xcbiAgICBzZXRTaW1wbGVTZWxlY3Rpb24odGhpcywgY2xpcFBvcyh0aGlzLCBhbmNob3IpLCBjbGlwUG9zKHRoaXMsIGhlYWQgfHwgYW5jaG9yKSwgb3B0aW9ucylcXG4gIH0pLFxcbiAgZXh0ZW5kU2VsZWN0aW9uOiBkb2NNZXRob2RPcChmdW5jdGlvbihoZWFkLCBvdGhlciwgb3B0aW9ucykge1xcbiAgICBleHRlbmRTZWxlY3Rpb24odGhpcywgY2xpcFBvcyh0aGlzLCBoZWFkKSwgb3RoZXIgJiYgY2xpcFBvcyh0aGlzLCBvdGhlciksIG9wdGlvbnMpXFxuICB9KSxcXG4gIGV4dGVuZFNlbGVjdGlvbnM6IGRvY01ldGhvZE9wKGZ1bmN0aW9uKGhlYWRzLCBvcHRpb25zKSB7XFxuICAgIGV4dGVuZFNlbGVjdGlvbnModGhpcywgY2xpcFBvc0FycmF5KHRoaXMsIGhlYWRzKSwgb3B0aW9ucylcXG4gIH0pLFxcbiAgZXh0ZW5kU2VsZWN0aW9uc0J5OiBkb2NNZXRob2RPcChmdW5jdGlvbihmLCBvcHRpb25zKSB7XFxuICAgIHZhciBoZWFkcyA9IG1hcCh0aGlzLnNlbC5yYW5nZXMsIGYpXFxuICAgIGV4dGVuZFNlbGVjdGlvbnModGhpcywgY2xpcFBvc0FycmF5KHRoaXMsIGhlYWRzKSwgb3B0aW9ucylcXG4gIH0pLFxcbiAgc2V0U2VsZWN0aW9uczogZG9jTWV0aG9kT3AoZnVuY3Rpb24ocmFuZ2VzLCBwcmltYXJ5LCBvcHRpb25zKSB7XFxuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xcblxcbiAgICBpZiAoIXJhbmdlcy5sZW5ndGgpIHsgcmV0dXJuIH1cXG4gICAgdmFyIG91dCA9IFtdXFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmFuZ2VzLmxlbmd0aDsgaSsrKVxcbiAgICAgIHsgb3V0W2ldID0gbmV3IFJhbmdlKGNsaXBQb3ModGhpcyQxLCByYW5nZXNbaV0uYW5jaG9yKSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgY2xpcFBvcyh0aGlzJDEsIHJhbmdlc1tpXS5oZWFkKSkgfVxcbiAgICBpZiAocHJpbWFyeSA9PSBudWxsKSB7IHByaW1hcnkgPSBNYXRoLm1pbihyYW5nZXMubGVuZ3RoIC0gMSwgdGhpcy5zZWwucHJpbUluZGV4KSB9XFxuICAgIHNldFNlbGVjdGlvbih0aGlzLCBub3JtYWxpemVTZWxlY3Rpb24ob3V0LCBwcmltYXJ5KSwgb3B0aW9ucylcXG4gIH0pLFxcbiAgYWRkU2VsZWN0aW9uOiBkb2NNZXRob2RPcChmdW5jdGlvbihhbmNob3IsIGhlYWQsIG9wdGlvbnMpIHtcXG4gICAgdmFyIHJhbmdlcyA9IHRoaXMuc2VsLnJhbmdlcy5zbGljZSgwKVxcbiAgICByYW5nZXMucHVzaChuZXcgUmFuZ2UoY2xpcFBvcyh0aGlzLCBhbmNob3IpLCBjbGlwUG9zKHRoaXMsIGhlYWQgfHwgYW5jaG9yKSkpXFxuICAgIHNldFNlbGVjdGlvbih0aGlzLCBub3JtYWxpemVTZWxlY3Rpb24ocmFuZ2VzLCByYW5nZXMubGVuZ3RoIC0gMSksIG9wdGlvbnMpXFxuICB9KSxcXG5cXG4gIGdldFNlbGVjdGlvbjogZnVuY3Rpb24obGluZVNlcCkge1xcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcXG5cXG4gICAgdmFyIHJhbmdlcyA9IHRoaXMuc2VsLnJhbmdlcywgbGluZXNcXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCByYW5nZXMubGVuZ3RoOyBpKyspIHtcXG4gICAgICB2YXIgc2VsID0gZ2V0QmV0d2Vlbih0aGlzJDEsIHJhbmdlc1tpXS5mcm9tKCksIHJhbmdlc1tpXS50bygpKVxcbiAgICAgIGxpbmVzID0gbGluZXMgPyBsaW5lcy5jb25jYXQoc2VsKSA6IHNlbFxcbiAgICB9XFxuICAgIGlmIChsaW5lU2VwID09PSBmYWxzZSkgeyByZXR1cm4gbGluZXMgfVxcbiAgICBlbHNlIHsgcmV0dXJuIGxpbmVzLmpvaW4obGluZVNlcCB8fCB0aGlzLmxpbmVTZXBhcmF0b3IoKSkgfVxcbiAgfSxcXG4gIGdldFNlbGVjdGlvbnM6IGZ1bmN0aW9uKGxpbmVTZXApIHtcXG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XFxuXFxuICAgIHZhciBwYXJ0cyA9IFtdLCByYW5nZXMgPSB0aGlzLnNlbC5yYW5nZXNcXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCByYW5nZXMubGVuZ3RoOyBpKyspIHtcXG4gICAgICB2YXIgc2VsID0gZ2V0QmV0d2Vlbih0aGlzJDEsIHJhbmdlc1tpXS5mcm9tKCksIHJhbmdlc1tpXS50bygpKVxcbiAgICAgIGlmIChsaW5lU2VwICE9PSBmYWxzZSkgeyBzZWwgPSBzZWwuam9pbihsaW5lU2VwIHx8IHRoaXMkMS5saW5lU2VwYXJhdG9yKCkpIH1cXG4gICAgICBwYXJ0c1tpXSA9IHNlbFxcbiAgICB9XFxuICAgIHJldHVybiBwYXJ0c1xcbiAgfSxcXG4gIHJlcGxhY2VTZWxlY3Rpb246IGZ1bmN0aW9uKGNvZGUsIGNvbGxhcHNlLCBvcmlnaW4pIHtcXG4gICAgdmFyIGR1cCA9IFtdXFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5zZWwucmFuZ2VzLmxlbmd0aDsgaSsrKVxcbiAgICAgIHsgZHVwW2ldID0gY29kZSB9XFxuICAgIHRoaXMucmVwbGFjZVNlbGVjdGlvbnMoZHVwLCBjb2xsYXBzZSwgb3JpZ2luIHx8IFxcXCIraW5wdXRcXFwiKVxcbiAgfSxcXG4gIHJlcGxhY2VTZWxlY3Rpb25zOiBkb2NNZXRob2RPcChmdW5jdGlvbihjb2RlLCBjb2xsYXBzZSwgb3JpZ2luKSB7XFxuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xcblxcbiAgICB2YXIgY2hhbmdlcyA9IFtdLCBzZWwgPSB0aGlzLnNlbFxcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlbC5yYW5nZXMubGVuZ3RoOyBpKyspIHtcXG4gICAgICB2YXIgcmFuZ2UgPSBzZWwucmFuZ2VzW2ldXFxuICAgICAgY2hhbmdlc1tpXSA9IHtmcm9tOiByYW5nZS5mcm9tKCksIHRvOiByYW5nZS50bygpLCB0ZXh0OiB0aGlzJDEuc3BsaXRMaW5lcyhjb2RlW2ldKSwgb3JpZ2luOiBvcmlnaW59XFxuICAgIH1cXG4gICAgdmFyIG5ld1NlbCA9IGNvbGxhcHNlICYmIGNvbGxhcHNlICE9IFxcXCJlbmRcXFwiICYmIGNvbXB1dGVSZXBsYWNlZFNlbCh0aGlzLCBjaGFuZ2VzLCBjb2xsYXBzZSlcXG4gICAgZm9yICh2YXIgaSQxID0gY2hhbmdlcy5sZW5ndGggLSAxOyBpJDEgPj0gMDsgaSQxLS0pXFxuICAgICAgeyBtYWtlQ2hhbmdlKHRoaXMkMSwgY2hhbmdlc1tpJDFdKSB9XFxuICAgIGlmIChuZXdTZWwpIHsgc2V0U2VsZWN0aW9uUmVwbGFjZUhpc3RvcnkodGhpcywgbmV3U2VsKSB9XFxuICAgIGVsc2UgaWYgKHRoaXMuY20pIHsgZW5zdXJlQ3Vyc29yVmlzaWJsZSh0aGlzLmNtKSB9XFxuICB9KSxcXG4gIHVuZG86IGRvY01ldGhvZE9wKGZ1bmN0aW9uKCkge21ha2VDaGFuZ2VGcm9tSGlzdG9yeSh0aGlzLCBcXFwidW5kb1xcXCIpfSksXFxuICByZWRvOiBkb2NNZXRob2RPcChmdW5jdGlvbigpIHttYWtlQ2hhbmdlRnJvbUhpc3RvcnkodGhpcywgXFxcInJlZG9cXFwiKX0pLFxcbiAgdW5kb1NlbGVjdGlvbjogZG9jTWV0aG9kT3AoZnVuY3Rpb24oKSB7bWFrZUNoYW5nZUZyb21IaXN0b3J5KHRoaXMsIFxcXCJ1bmRvXFxcIiwgdHJ1ZSl9KSxcXG4gIHJlZG9TZWxlY3Rpb246IGRvY01ldGhvZE9wKGZ1bmN0aW9uKCkge21ha2VDaGFuZ2VGcm9tSGlzdG9yeSh0aGlzLCBcXFwicmVkb1xcXCIsIHRydWUpfSksXFxuXFxuICBzZXRFeHRlbmRpbmc6IGZ1bmN0aW9uKHZhbCkge3RoaXMuZXh0ZW5kID0gdmFsfSxcXG4gIGdldEV4dGVuZGluZzogZnVuY3Rpb24oKSB7cmV0dXJuIHRoaXMuZXh0ZW5kfSxcXG5cXG4gIGhpc3RvcnlTaXplOiBmdW5jdGlvbigpIHtcXG4gICAgdmFyIGhpc3QgPSB0aGlzLmhpc3RvcnksIGRvbmUgPSAwLCB1bmRvbmUgPSAwXFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaGlzdC5kb25lLmxlbmd0aDsgaSsrKSB7IGlmICghaGlzdC5kb25lW2ldLnJhbmdlcykgeyArK2RvbmUgfSB9XFxuICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IGhpc3QudW5kb25lLmxlbmd0aDsgaSQxKyspIHsgaWYgKCFoaXN0LnVuZG9uZVtpJDFdLnJhbmdlcykgeyArK3VuZG9uZSB9IH1cXG4gICAgcmV0dXJuIHt1bmRvOiBkb25lLCByZWRvOiB1bmRvbmV9XFxuICB9LFxcbiAgY2xlYXJIaXN0b3J5OiBmdW5jdGlvbigpIHt0aGlzLmhpc3RvcnkgPSBuZXcgSGlzdG9yeSh0aGlzLmhpc3RvcnkubWF4R2VuZXJhdGlvbil9LFxcblxcbiAgbWFya0NsZWFuOiBmdW5jdGlvbigpIHtcXG4gICAgdGhpcy5jbGVhbkdlbmVyYXRpb24gPSB0aGlzLmNoYW5nZUdlbmVyYXRpb24odHJ1ZSlcXG4gIH0sXFxuICBjaGFuZ2VHZW5lcmF0aW9uOiBmdW5jdGlvbihmb3JjZVNwbGl0KSB7XFxuICAgIGlmIChmb3JjZVNwbGl0KVxcbiAgICAgIHsgdGhpcy5oaXN0b3J5Lmxhc3RPcCA9IHRoaXMuaGlzdG9yeS5sYXN0U2VsT3AgPSB0aGlzLmhpc3RvcnkubGFzdE9yaWdpbiA9IG51bGwgfVxcbiAgICByZXR1cm4gdGhpcy5oaXN0b3J5LmdlbmVyYXRpb25cXG4gIH0sXFxuICBpc0NsZWFuOiBmdW5jdGlvbiAoZ2VuKSB7XFxuICAgIHJldHVybiB0aGlzLmhpc3RvcnkuZ2VuZXJhdGlvbiA9PSAoZ2VuIHx8IHRoaXMuY2xlYW5HZW5lcmF0aW9uKVxcbiAgfSxcXG5cXG4gIGdldEhpc3Rvcnk6IGZ1bmN0aW9uKCkge1xcbiAgICByZXR1cm4ge2RvbmU6IGNvcHlIaXN0b3J5QXJyYXkodGhpcy5oaXN0b3J5LmRvbmUpLFxcbiAgICAgICAgICAgIHVuZG9uZTogY29weUhpc3RvcnlBcnJheSh0aGlzLmhpc3RvcnkudW5kb25lKX1cXG4gIH0sXFxuICBzZXRIaXN0b3J5OiBmdW5jdGlvbihoaXN0RGF0YSkge1xcbiAgICB2YXIgaGlzdCA9IHRoaXMuaGlzdG9yeSA9IG5ldyBIaXN0b3J5KHRoaXMuaGlzdG9yeS5tYXhHZW5lcmF0aW9uKVxcbiAgICBoaXN0LmRvbmUgPSBjb3B5SGlzdG9yeUFycmF5KGhpc3REYXRhLmRvbmUuc2xpY2UoMCksIG51bGwsIHRydWUpXFxuICAgIGhpc3QudW5kb25lID0gY29weUhpc3RvcnlBcnJheShoaXN0RGF0YS51bmRvbmUuc2xpY2UoMCksIG51bGwsIHRydWUpXFxuICB9LFxcblxcbiAgc2V0R3V0dGVyTWFya2VyOiBkb2NNZXRob2RPcChmdW5jdGlvbihsaW5lLCBndXR0ZXJJRCwgdmFsdWUpIHtcXG4gICAgcmV0dXJuIGNoYW5nZUxpbmUodGhpcywgbGluZSwgXFxcImd1dHRlclxcXCIsIGZ1bmN0aW9uIChsaW5lKSB7XFxuICAgICAgdmFyIG1hcmtlcnMgPSBsaW5lLmd1dHRlck1hcmtlcnMgfHwgKGxpbmUuZ3V0dGVyTWFya2VycyA9IHt9KVxcbiAgICAgIG1hcmtlcnNbZ3V0dGVySURdID0gdmFsdWVcXG4gICAgICBpZiAoIXZhbHVlICYmIGlzRW1wdHkobWFya2VycykpIHsgbGluZS5ndXR0ZXJNYXJrZXJzID0gbnVsbCB9XFxuICAgICAgcmV0dXJuIHRydWVcXG4gICAgfSlcXG4gIH0pLFxcblxcbiAgY2xlYXJHdXR0ZXI6IGRvY01ldGhvZE9wKGZ1bmN0aW9uKGd1dHRlcklEKSB7XFxuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xcblxcbiAgICB0aGlzLml0ZXIoZnVuY3Rpb24gKGxpbmUpIHtcXG4gICAgICBpZiAobGluZS5ndXR0ZXJNYXJrZXJzICYmIGxpbmUuZ3V0dGVyTWFya2Vyc1tndXR0ZXJJRF0pIHtcXG4gICAgICAgIGNoYW5nZUxpbmUodGhpcyQxLCBsaW5lLCBcXFwiZ3V0dGVyXFxcIiwgZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICBsaW5lLmd1dHRlck1hcmtlcnNbZ3V0dGVySURdID0gbnVsbFxcbiAgICAgICAgICBpZiAoaXNFbXB0eShsaW5lLmd1dHRlck1hcmtlcnMpKSB7IGxpbmUuZ3V0dGVyTWFya2VycyA9IG51bGwgfVxcbiAgICAgICAgICByZXR1cm4gdHJ1ZVxcbiAgICAgICAgfSlcXG4gICAgICB9XFxuICAgIH0pXFxuICB9KSxcXG5cXG4gIGxpbmVJbmZvOiBmdW5jdGlvbihsaW5lKSB7XFxuICAgIHZhciBuXFxuICAgIGlmICh0eXBlb2YgbGluZSA9PSBcXFwibnVtYmVyXFxcIikge1xcbiAgICAgIGlmICghaXNMaW5lKHRoaXMsIGxpbmUpKSB7IHJldHVybiBudWxsIH1cXG4gICAgICBuID0gbGluZVxcbiAgICAgIGxpbmUgPSBnZXRMaW5lKHRoaXMsIGxpbmUpXFxuICAgICAgaWYgKCFsaW5lKSB7IHJldHVybiBudWxsIH1cXG4gICAgfSBlbHNlIHtcXG4gICAgICBuID0gbGluZU5vKGxpbmUpXFxuICAgICAgaWYgKG4gPT0gbnVsbCkgeyByZXR1cm4gbnVsbCB9XFxuICAgIH1cXG4gICAgcmV0dXJuIHtsaW5lOiBuLCBoYW5kbGU6IGxpbmUsIHRleHQ6IGxpbmUudGV4dCwgZ3V0dGVyTWFya2VyczogbGluZS5ndXR0ZXJNYXJrZXJzLFxcbiAgICAgICAgICAgIHRleHRDbGFzczogbGluZS50ZXh0Q2xhc3MsIGJnQ2xhc3M6IGxpbmUuYmdDbGFzcywgd3JhcENsYXNzOiBsaW5lLndyYXBDbGFzcyxcXG4gICAgICAgICAgICB3aWRnZXRzOiBsaW5lLndpZGdldHN9XFxuICB9LFxcblxcbiAgYWRkTGluZUNsYXNzOiBkb2NNZXRob2RPcChmdW5jdGlvbihoYW5kbGUsIHdoZXJlLCBjbHMpIHtcXG4gICAgcmV0dXJuIGNoYW5nZUxpbmUodGhpcywgaGFuZGxlLCB3aGVyZSA9PSBcXFwiZ3V0dGVyXFxcIiA/IFxcXCJndXR0ZXJcXFwiIDogXFxcImNsYXNzXFxcIiwgZnVuY3Rpb24gKGxpbmUpIHtcXG4gICAgICB2YXIgcHJvcCA9IHdoZXJlID09IFxcXCJ0ZXh0XFxcIiA/IFxcXCJ0ZXh0Q2xhc3NcXFwiXFxuICAgICAgICAgICAgICAgOiB3aGVyZSA9PSBcXFwiYmFja2dyb3VuZFxcXCIgPyBcXFwiYmdDbGFzc1xcXCJcXG4gICAgICAgICAgICAgICA6IHdoZXJlID09IFxcXCJndXR0ZXJcXFwiID8gXFxcImd1dHRlckNsYXNzXFxcIiA6IFxcXCJ3cmFwQ2xhc3NcXFwiXFxuICAgICAgaWYgKCFsaW5lW3Byb3BdKSB7IGxpbmVbcHJvcF0gPSBjbHMgfVxcbiAgICAgIGVsc2UgaWYgKGNsYXNzVGVzdChjbHMpLnRlc3QobGluZVtwcm9wXSkpIHsgcmV0dXJuIGZhbHNlIH1cXG4gICAgICBlbHNlIHsgbGluZVtwcm9wXSArPSBcXFwiIFxcXCIgKyBjbHMgfVxcbiAgICAgIHJldHVybiB0cnVlXFxuICAgIH0pXFxuICB9KSxcXG4gIHJlbW92ZUxpbmVDbGFzczogZG9jTWV0aG9kT3AoZnVuY3Rpb24oaGFuZGxlLCB3aGVyZSwgY2xzKSB7XFxuICAgIHJldHVybiBjaGFuZ2VMaW5lKHRoaXMsIGhhbmRsZSwgd2hlcmUgPT0gXFxcImd1dHRlclxcXCIgPyBcXFwiZ3V0dGVyXFxcIiA6IFxcXCJjbGFzc1xcXCIsIGZ1bmN0aW9uIChsaW5lKSB7XFxuICAgICAgdmFyIHByb3AgPSB3aGVyZSA9PSBcXFwidGV4dFxcXCIgPyBcXFwidGV4dENsYXNzXFxcIlxcbiAgICAgICAgICAgICAgIDogd2hlcmUgPT0gXFxcImJhY2tncm91bmRcXFwiID8gXFxcImJnQ2xhc3NcXFwiXFxuICAgICAgICAgICAgICAgOiB3aGVyZSA9PSBcXFwiZ3V0dGVyXFxcIiA/IFxcXCJndXR0ZXJDbGFzc1xcXCIgOiBcXFwid3JhcENsYXNzXFxcIlxcbiAgICAgIHZhciBjdXIgPSBsaW5lW3Byb3BdXFxuICAgICAgaWYgKCFjdXIpIHsgcmV0dXJuIGZhbHNlIH1cXG4gICAgICBlbHNlIGlmIChjbHMgPT0gbnVsbCkgeyBsaW5lW3Byb3BdID0gbnVsbCB9XFxuICAgICAgZWxzZSB7XFxuICAgICAgICB2YXIgZm91bmQgPSBjdXIubWF0Y2goY2xhc3NUZXN0KGNscykpXFxuICAgICAgICBpZiAoIWZvdW5kKSB7IHJldHVybiBmYWxzZSB9XFxuICAgICAgICB2YXIgZW5kID0gZm91bmQuaW5kZXggKyBmb3VuZFswXS5sZW5ndGhcXG4gICAgICAgIGxpbmVbcHJvcF0gPSBjdXIuc2xpY2UoMCwgZm91bmQuaW5kZXgpICsgKCFmb3VuZC5pbmRleCB8fCBlbmQgPT0gY3VyLmxlbmd0aCA/IFxcXCJcXFwiIDogXFxcIiBcXFwiKSArIGN1ci5zbGljZShlbmQpIHx8IG51bGxcXG4gICAgICB9XFxuICAgICAgcmV0dXJuIHRydWVcXG4gICAgfSlcXG4gIH0pLFxcblxcbiAgYWRkTGluZVdpZGdldDogZG9jTWV0aG9kT3AoZnVuY3Rpb24oaGFuZGxlLCBub2RlLCBvcHRpb25zKSB7XFxuICAgIHJldHVybiBhZGRMaW5lV2lkZ2V0KHRoaXMsIGhhbmRsZSwgbm9kZSwgb3B0aW9ucylcXG4gIH0pLFxcbiAgcmVtb3ZlTGluZVdpZGdldDogZnVuY3Rpb24od2lkZ2V0KSB7IHdpZGdldC5jbGVhcigpIH0sXFxuXFxuICBtYXJrVGV4dDogZnVuY3Rpb24oZnJvbSwgdG8sIG9wdGlvbnMpIHtcXG4gICAgcmV0dXJuIG1hcmtUZXh0KHRoaXMsIGNsaXBQb3ModGhpcywgZnJvbSksIGNsaXBQb3ModGhpcywgdG8pLCBvcHRpb25zLCBvcHRpb25zICYmIG9wdGlvbnMudHlwZSB8fCBcXFwicmFuZ2VcXFwiKVxcbiAgfSxcXG4gIHNldEJvb2ttYXJrOiBmdW5jdGlvbihwb3MsIG9wdGlvbnMpIHtcXG4gICAgdmFyIHJlYWxPcHRzID0ge3JlcGxhY2VkV2l0aDogb3B0aW9ucyAmJiAob3B0aW9ucy5ub2RlVHlwZSA9PSBudWxsID8gb3B0aW9ucy53aWRnZXQgOiBvcHRpb25zKSxcXG4gICAgICAgICAgICAgICAgICAgIGluc2VydExlZnQ6IG9wdGlvbnMgJiYgb3B0aW9ucy5pbnNlcnRMZWZ0LFxcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJXaGVuRW1wdHk6IGZhbHNlLCBzaGFyZWQ6IG9wdGlvbnMgJiYgb3B0aW9ucy5zaGFyZWQsXFxuICAgICAgICAgICAgICAgICAgICBoYW5kbGVNb3VzZUV2ZW50czogb3B0aW9ucyAmJiBvcHRpb25zLmhhbmRsZU1vdXNlRXZlbnRzfVxcbiAgICBwb3MgPSBjbGlwUG9zKHRoaXMsIHBvcylcXG4gICAgcmV0dXJuIG1hcmtUZXh0KHRoaXMsIHBvcywgcG9zLCByZWFsT3B0cywgXFxcImJvb2ttYXJrXFxcIilcXG4gIH0sXFxuICBmaW5kTWFya3NBdDogZnVuY3Rpb24ocG9zKSB7XFxuICAgIHBvcyA9IGNsaXBQb3ModGhpcywgcG9zKVxcbiAgICB2YXIgbWFya2VycyA9IFtdLCBzcGFucyA9IGdldExpbmUodGhpcywgcG9zLmxpbmUpLm1hcmtlZFNwYW5zXFxuICAgIGlmIChzcGFucykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHNwYW5zLmxlbmd0aDsgKytpKSB7XFxuICAgICAgdmFyIHNwYW4gPSBzcGFuc1tpXVxcbiAgICAgIGlmICgoc3Bhbi5mcm9tID09IG51bGwgfHwgc3Bhbi5mcm9tIDw9IHBvcy5jaCkgJiZcXG4gICAgICAgICAgKHNwYW4udG8gPT0gbnVsbCB8fCBzcGFuLnRvID49IHBvcy5jaCkpXFxuICAgICAgICB7IG1hcmtlcnMucHVzaChzcGFuLm1hcmtlci5wYXJlbnQgfHwgc3Bhbi5tYXJrZXIpIH1cXG4gICAgfSB9XFxuICAgIHJldHVybiBtYXJrZXJzXFxuICB9LFxcbiAgZmluZE1hcmtzOiBmdW5jdGlvbihmcm9tLCB0bywgZmlsdGVyKSB7XFxuICAgIGZyb20gPSBjbGlwUG9zKHRoaXMsIGZyb20pOyB0byA9IGNsaXBQb3ModGhpcywgdG8pXFxuICAgIHZhciBmb3VuZCA9IFtdLCBsaW5lTm8gPSBmcm9tLmxpbmVcXG4gICAgdGhpcy5pdGVyKGZyb20ubGluZSwgdG8ubGluZSArIDEsIGZ1bmN0aW9uIChsaW5lKSB7XFxuICAgICAgdmFyIHNwYW5zID0gbGluZS5tYXJrZWRTcGFuc1xcbiAgICAgIGlmIChzcGFucykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHNwYW5zLmxlbmd0aDsgaSsrKSB7XFxuICAgICAgICB2YXIgc3BhbiA9IHNwYW5zW2ldXFxuICAgICAgICBpZiAoIShzcGFuLnRvICE9IG51bGwgJiYgbGluZU5vID09IGZyb20ubGluZSAmJiBmcm9tLmNoID49IHNwYW4udG8gfHxcXG4gICAgICAgICAgICAgIHNwYW4uZnJvbSA9PSBudWxsICYmIGxpbmVObyAhPSBmcm9tLmxpbmUgfHxcXG4gICAgICAgICAgICAgIHNwYW4uZnJvbSAhPSBudWxsICYmIGxpbmVObyA9PSB0by5saW5lICYmIHNwYW4uZnJvbSA+PSB0by5jaCkgJiZcXG4gICAgICAgICAgICAoIWZpbHRlciB8fCBmaWx0ZXIoc3Bhbi5tYXJrZXIpKSlcXG4gICAgICAgICAgeyBmb3VuZC5wdXNoKHNwYW4ubWFya2VyLnBhcmVudCB8fCBzcGFuLm1hcmtlcikgfVxcbiAgICAgIH0gfVxcbiAgICAgICsrbGluZU5vXFxuICAgIH0pXFxuICAgIHJldHVybiBmb3VuZFxcbiAgfSxcXG4gIGdldEFsbE1hcmtzOiBmdW5jdGlvbigpIHtcXG4gICAgdmFyIG1hcmtlcnMgPSBbXVxcbiAgICB0aGlzLml0ZXIoZnVuY3Rpb24gKGxpbmUpIHtcXG4gICAgICB2YXIgc3BzID0gbGluZS5tYXJrZWRTcGFuc1xcbiAgICAgIGlmIChzcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBzcHMubGVuZ3RoOyArK2kpXFxuICAgICAgICB7IGlmIChzcHNbaV0uZnJvbSAhPSBudWxsKSB7IG1hcmtlcnMucHVzaChzcHNbaV0ubWFya2VyKSB9IH0gfVxcbiAgICB9KVxcbiAgICByZXR1cm4gbWFya2Vyc1xcbiAgfSxcXG5cXG4gIHBvc0Zyb21JbmRleDogZnVuY3Rpb24ob2ZmKSB7XFxuICAgIHZhciBjaCwgbGluZU5vID0gdGhpcy5maXJzdCwgc2VwU2l6ZSA9IHRoaXMubGluZVNlcGFyYXRvcigpLmxlbmd0aFxcbiAgICB0aGlzLml0ZXIoZnVuY3Rpb24gKGxpbmUpIHtcXG4gICAgICB2YXIgc3ogPSBsaW5lLnRleHQubGVuZ3RoICsgc2VwU2l6ZVxcbiAgICAgIGlmIChzeiA+IG9mZikgeyBjaCA9IG9mZjsgcmV0dXJuIHRydWUgfVxcbiAgICAgIG9mZiAtPSBzelxcbiAgICAgICsrbGluZU5vXFxuICAgIH0pXFxuICAgIHJldHVybiBjbGlwUG9zKHRoaXMsIFBvcyhsaW5lTm8sIGNoKSlcXG4gIH0sXFxuICBpbmRleEZyb21Qb3M6IGZ1bmN0aW9uIChjb29yZHMpIHtcXG4gICAgY29vcmRzID0gY2xpcFBvcyh0aGlzLCBjb29yZHMpXFxuICAgIHZhciBpbmRleCA9IGNvb3Jkcy5jaFxcbiAgICBpZiAoY29vcmRzLmxpbmUgPCB0aGlzLmZpcnN0IHx8IGNvb3Jkcy5jaCA8IDApIHsgcmV0dXJuIDAgfVxcbiAgICB2YXIgc2VwU2l6ZSA9IHRoaXMubGluZVNlcGFyYXRvcigpLmxlbmd0aFxcbiAgICB0aGlzLml0ZXIodGhpcy5maXJzdCwgY29vcmRzLmxpbmUsIGZ1bmN0aW9uIChsaW5lKSB7IC8vIGl0ZXIgYWJvcnRzIHdoZW4gY2FsbGJhY2sgcmV0dXJucyBhIHRydXRoeSB2YWx1ZVxcbiAgICAgIGluZGV4ICs9IGxpbmUudGV4dC5sZW5ndGggKyBzZXBTaXplXFxuICAgIH0pXFxuICAgIHJldHVybiBpbmRleFxcbiAgfSxcXG5cXG4gIGNvcHk6IGZ1bmN0aW9uKGNvcHlIaXN0b3J5KSB7XFxuICAgIHZhciBkb2MgPSBuZXcgRG9jKGdldExpbmVzKHRoaXMsIHRoaXMuZmlyc3QsIHRoaXMuZmlyc3QgKyB0aGlzLnNpemUpLFxcbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1vZGVPcHRpb24sIHRoaXMuZmlyc3QsIHRoaXMubGluZVNlcClcXG4gICAgZG9jLnNjcm9sbFRvcCA9IHRoaXMuc2Nyb2xsVG9wOyBkb2Muc2Nyb2xsTGVmdCA9IHRoaXMuc2Nyb2xsTGVmdFxcbiAgICBkb2Muc2VsID0gdGhpcy5zZWxcXG4gICAgZG9jLmV4dGVuZCA9IGZhbHNlXFxuICAgIGlmIChjb3B5SGlzdG9yeSkge1xcbiAgICAgIGRvYy5oaXN0b3J5LnVuZG9EZXB0aCA9IHRoaXMuaGlzdG9yeS51bmRvRGVwdGhcXG4gICAgICBkb2Muc2V0SGlzdG9yeSh0aGlzLmdldEhpc3RvcnkoKSlcXG4gICAgfVxcbiAgICByZXR1cm4gZG9jXFxuICB9LFxcblxcbiAgbGlua2VkRG9jOiBmdW5jdGlvbihvcHRpb25zKSB7XFxuICAgIGlmICghb3B0aW9ucykgeyBvcHRpb25zID0ge30gfVxcbiAgICB2YXIgZnJvbSA9IHRoaXMuZmlyc3QsIHRvID0gdGhpcy5maXJzdCArIHRoaXMuc2l6ZVxcbiAgICBpZiAob3B0aW9ucy5mcm9tICE9IG51bGwgJiYgb3B0aW9ucy5mcm9tID4gZnJvbSkgeyBmcm9tID0gb3B0aW9ucy5mcm9tIH1cXG4gICAgaWYgKG9wdGlvbnMudG8gIT0gbnVsbCAmJiBvcHRpb25zLnRvIDwgdG8pIHsgdG8gPSBvcHRpb25zLnRvIH1cXG4gICAgdmFyIGNvcHkgPSBuZXcgRG9jKGdldExpbmVzKHRoaXMsIGZyb20sIHRvKSwgb3B0aW9ucy5tb2RlIHx8IHRoaXMubW9kZU9wdGlvbiwgZnJvbSwgdGhpcy5saW5lU2VwKVxcbiAgICBpZiAob3B0aW9ucy5zaGFyZWRIaXN0KSB7IGNvcHkuaGlzdG9yeSA9IHRoaXMuaGlzdG9yeVxcbiAgICA7IH0odGhpcy5saW5rZWQgfHwgKHRoaXMubGlua2VkID0gW10pKS5wdXNoKHtkb2M6IGNvcHksIHNoYXJlZEhpc3Q6IG9wdGlvbnMuc2hhcmVkSGlzdH0pXFxuICAgIGNvcHkubGlua2VkID0gW3tkb2M6IHRoaXMsIGlzUGFyZW50OiB0cnVlLCBzaGFyZWRIaXN0OiBvcHRpb25zLnNoYXJlZEhpc3R9XVxcbiAgICBjb3B5U2hhcmVkTWFya2Vycyhjb3B5LCBmaW5kU2hhcmVkTWFya2Vycyh0aGlzKSlcXG4gICAgcmV0dXJuIGNvcHlcXG4gIH0sXFxuICB1bmxpbmtEb2M6IGZ1bmN0aW9uKG90aGVyKSB7XFxuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xcblxcbiAgICBpZiAob3RoZXIgaW5zdGFuY2VvZiBDb2RlTWlycm9yKSB7IG90aGVyID0gb3RoZXIuZG9jIH1cXG4gICAgaWYgKHRoaXMubGlua2VkKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5saW5rZWQubGVuZ3RoOyArK2kpIHtcXG4gICAgICB2YXIgbGluayA9IHRoaXMkMS5saW5rZWRbaV1cXG4gICAgICBpZiAobGluay5kb2MgIT0gb3RoZXIpIHsgY29udGludWUgfVxcbiAgICAgIHRoaXMkMS5saW5rZWQuc3BsaWNlKGksIDEpXFxuICAgICAgb3RoZXIudW5saW5rRG9jKHRoaXMkMSlcXG4gICAgICBkZXRhY2hTaGFyZWRNYXJrZXJzKGZpbmRTaGFyZWRNYXJrZXJzKHRoaXMkMSkpXFxuICAgICAgYnJlYWtcXG4gICAgfSB9XFxuICAgIC8vIElmIHRoZSBoaXN0b3JpZXMgd2VyZSBzaGFyZWQsIHNwbGl0IHRoZW0gYWdhaW5cXG4gICAgaWYgKG90aGVyLmhpc3RvcnkgPT0gdGhpcy5oaXN0b3J5KSB7XFxuICAgICAgdmFyIHNwbGl0SWRzID0gW290aGVyLmlkXVxcbiAgICAgIGxpbmtlZERvY3Mob3RoZXIsIGZ1bmN0aW9uIChkb2MpIHsgcmV0dXJuIHNwbGl0SWRzLnB1c2goZG9jLmlkKTsgfSwgdHJ1ZSlcXG4gICAgICBvdGhlci5oaXN0b3J5ID0gbmV3IEhpc3RvcnkobnVsbClcXG4gICAgICBvdGhlci5oaXN0b3J5LmRvbmUgPSBjb3B5SGlzdG9yeUFycmF5KHRoaXMuaGlzdG9yeS5kb25lLCBzcGxpdElkcylcXG4gICAgICBvdGhlci5oaXN0b3J5LnVuZG9uZSA9IGNvcHlIaXN0b3J5QXJyYXkodGhpcy5oaXN0b3J5LnVuZG9uZSwgc3BsaXRJZHMpXFxuICAgIH1cXG4gIH0sXFxuICBpdGVyTGlua2VkRG9jczogZnVuY3Rpb24oZikge2xpbmtlZERvY3ModGhpcywgZil9LFxcblxcbiAgZ2V0TW9kZTogZnVuY3Rpb24oKSB7cmV0dXJuIHRoaXMubW9kZX0sXFxuICBnZXRFZGl0b3I6IGZ1bmN0aW9uKCkge3JldHVybiB0aGlzLmNtfSxcXG5cXG4gIHNwbGl0TGluZXM6IGZ1bmN0aW9uKHN0cikge1xcbiAgICBpZiAodGhpcy5saW5lU2VwKSB7IHJldHVybiBzdHIuc3BsaXQodGhpcy5saW5lU2VwKSB9XFxuICAgIHJldHVybiBzcGxpdExpbmVzQXV0byhzdHIpXFxuICB9LFxcbiAgbGluZVNlcGFyYXRvcjogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLmxpbmVTZXAgfHwgXFxcIlxcXFxuXFxcIiB9XFxufSlcXG5cXG4vLyBQdWJsaWMgYWxpYXMuXFxuRG9jLnByb3RvdHlwZS5lYWNoTGluZSA9IERvYy5wcm90b3R5cGUuaXRlclxcblxcbi8vIEtsdWRnZSB0byB3b3JrIGFyb3VuZCBzdHJhbmdlIElFIGJlaGF2aW9yIHdoZXJlIGl0J2xsIHNvbWV0aW1lc1xcbi8vIHJlLWZpcmUgYSBzZXJpZXMgb2YgZHJhZy1yZWxhdGVkIGV2ZW50cyByaWdodCBhZnRlciB0aGUgZHJvcCAoIzE1NTEpXFxudmFyIGxhc3REcm9wID0gMFxcblxcbmZ1bmN0aW9uIG9uRHJvcChlKSB7XFxuICB2YXIgY20gPSB0aGlzXFxuICBjbGVhckRyYWdDdXJzb3IoY20pXFxuICBpZiAoc2lnbmFsRE9NRXZlbnQoY20sIGUpIHx8IGV2ZW50SW5XaWRnZXQoY20uZGlzcGxheSwgZSkpXFxuICAgIHsgcmV0dXJuIH1cXG4gIGVfcHJldmVudERlZmF1bHQoZSlcXG4gIGlmIChpZSkgeyBsYXN0RHJvcCA9ICtuZXcgRGF0ZSB9XFxuICB2YXIgcG9zID0gcG9zRnJvbU1vdXNlKGNtLCBlLCB0cnVlKSwgZmlsZXMgPSBlLmRhdGFUcmFuc2Zlci5maWxlc1xcbiAgaWYgKCFwb3MgfHwgY20uaXNSZWFkT25seSgpKSB7IHJldHVybiB9XFxuICAvLyBNaWdodCBiZSBhIGZpbGUgZHJvcCwgaW4gd2hpY2ggY2FzZSB3ZSBzaW1wbHkgZXh0cmFjdCB0aGUgdGV4dFxcbiAgLy8gYW5kIGluc2VydCBpdC5cXG4gIGlmIChmaWxlcyAmJiBmaWxlcy5sZW5ndGggJiYgd2luZG93LkZpbGVSZWFkZXIgJiYgd2luZG93LkZpbGUpIHtcXG4gICAgdmFyIG4gPSBmaWxlcy5sZW5ndGgsIHRleHQgPSBBcnJheShuKSwgcmVhZCA9IDBcXG4gICAgdmFyIGxvYWRGaWxlID0gZnVuY3Rpb24gKGZpbGUsIGkpIHtcXG4gICAgICBpZiAoY20ub3B0aW9ucy5hbGxvd0Ryb3BGaWxlVHlwZXMgJiZcXG4gICAgICAgICAgaW5kZXhPZihjbS5vcHRpb25zLmFsbG93RHJvcEZpbGVUeXBlcywgZmlsZS50eXBlKSA9PSAtMSlcXG4gICAgICAgIHsgcmV0dXJuIH1cXG5cXG4gICAgICB2YXIgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXJcXG4gICAgICByZWFkZXIub25sb2FkID0gb3BlcmF0aW9uKGNtLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgICB2YXIgY29udGVudCA9IHJlYWRlci5yZXN1bHRcXG4gICAgICAgIGlmICgvW1xcXFx4MDAtXFxcXHgwOFxcXFx4MGUtXFxcXHgxZl17Mn0vLnRlc3QoY29udGVudCkpIHsgY29udGVudCA9IFxcXCJcXFwiIH1cXG4gICAgICAgIHRleHRbaV0gPSBjb250ZW50XFxuICAgICAgICBpZiAoKytyZWFkID09IG4pIHtcXG4gICAgICAgICAgcG9zID0gY2xpcFBvcyhjbS5kb2MsIHBvcylcXG4gICAgICAgICAgdmFyIGNoYW5nZSA9IHtmcm9tOiBwb3MsIHRvOiBwb3MsXFxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogY20uZG9jLnNwbGl0TGluZXModGV4dC5qb2luKGNtLmRvYy5saW5lU2VwYXJhdG9yKCkpKSxcXG4gICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW46IFxcXCJwYXN0ZVxcXCJ9XFxuICAgICAgICAgIG1ha2VDaGFuZ2UoY20uZG9jLCBjaGFuZ2UpXFxuICAgICAgICAgIHNldFNlbGVjdGlvblJlcGxhY2VIaXN0b3J5KGNtLmRvYywgc2ltcGxlU2VsZWN0aW9uKHBvcywgY2hhbmdlRW5kKGNoYW5nZSkpKVxcbiAgICAgICAgfVxcbiAgICAgIH0pXFxuICAgICAgcmVhZGVyLnJlYWRBc1RleHQoZmlsZSlcXG4gICAgfVxcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47ICsraSkgeyBsb2FkRmlsZShmaWxlc1tpXSwgaSkgfVxcbiAgfSBlbHNlIHsgLy8gTm9ybWFsIGRyb3BcXG4gICAgLy8gRG9uJ3QgZG8gYSByZXBsYWNlIGlmIHRoZSBkcm9wIGhhcHBlbmVkIGluc2lkZSBvZiB0aGUgc2VsZWN0ZWQgdGV4dC5cXG4gICAgaWYgKGNtLnN0YXRlLmRyYWdnaW5nVGV4dCAmJiBjbS5kb2Muc2VsLmNvbnRhaW5zKHBvcykgPiAtMSkge1xcbiAgICAgIGNtLnN0YXRlLmRyYWdnaW5nVGV4dChlKVxcbiAgICAgIC8vIEVuc3VyZSB0aGUgZWRpdG9yIGlzIHJlLWZvY3VzZWRcXG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNtLmRpc3BsYXkuaW5wdXQuZm9jdXMoKTsgfSwgMjApXFxuICAgICAgcmV0dXJuXFxuICAgIH1cXG4gICAgdHJ5IHtcXG4gICAgICB2YXIgdGV4dCQxID0gZS5kYXRhVHJhbnNmZXIuZ2V0RGF0YShcXFwiVGV4dFxcXCIpXFxuICAgICAgaWYgKHRleHQkMSkge1xcbiAgICAgICAgdmFyIHNlbGVjdGVkXFxuICAgICAgICBpZiAoY20uc3RhdGUuZHJhZ2dpbmdUZXh0ICYmICFjbS5zdGF0ZS5kcmFnZ2luZ1RleHQuY29weSlcXG4gICAgICAgICAgeyBzZWxlY3RlZCA9IGNtLmxpc3RTZWxlY3Rpb25zKCkgfVxcbiAgICAgICAgc2V0U2VsZWN0aW9uTm9VbmRvKGNtLmRvYywgc2ltcGxlU2VsZWN0aW9uKHBvcywgcG9zKSlcXG4gICAgICAgIGlmIChzZWxlY3RlZCkgeyBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBzZWxlY3RlZC5sZW5ndGg7ICsraSQxKVxcbiAgICAgICAgICB7IHJlcGxhY2VSYW5nZShjbS5kb2MsIFxcXCJcXFwiLCBzZWxlY3RlZFtpJDFdLmFuY2hvciwgc2VsZWN0ZWRbaSQxXS5oZWFkLCBcXFwiZHJhZ1xcXCIpIH0gfVxcbiAgICAgICAgY20ucmVwbGFjZVNlbGVjdGlvbih0ZXh0JDEsIFxcXCJhcm91bmRcXFwiLCBcXFwicGFzdGVcXFwiKVxcbiAgICAgICAgY20uZGlzcGxheS5pbnB1dC5mb2N1cygpXFxuICAgICAgfVxcbiAgICB9XFxuICAgIGNhdGNoKGUpe31cXG4gIH1cXG59XFxuXFxuZnVuY3Rpb24gb25EcmFnU3RhcnQoY20sIGUpIHtcXG4gIGlmIChpZSAmJiAoIWNtLnN0YXRlLmRyYWdnaW5nVGV4dCB8fCArbmV3IERhdGUgLSBsYXN0RHJvcCA8IDEwMCkpIHsgZV9zdG9wKGUpOyByZXR1cm4gfVxcbiAgaWYgKHNpZ25hbERPTUV2ZW50KGNtLCBlKSB8fCBldmVudEluV2lkZ2V0KGNtLmRpc3BsYXksIGUpKSB7IHJldHVybiB9XFxuXFxuICBlLmRhdGFUcmFuc2Zlci5zZXREYXRhKFxcXCJUZXh0XFxcIiwgY20uZ2V0U2VsZWN0aW9uKCkpXFxuICBlLmRhdGFUcmFuc2Zlci5lZmZlY3RBbGxvd2VkID0gXFxcImNvcHlNb3ZlXFxcIlxcblxcbiAgLy8gVXNlIGR1bW15IGltYWdlIGluc3RlYWQgb2YgZGVmYXVsdCBicm93c2VycyBpbWFnZS5cXG4gIC8vIFJlY2VudCBTYWZhcmkgKH42LjAuMikgaGF2ZSBhIHRlbmRlbmN5IHRvIHNlZ2ZhdWx0IHdoZW4gdGhpcyBoYXBwZW5zLCBzbyB3ZSBkb24ndCBkbyBpdCB0aGVyZS5cXG4gIGlmIChlLmRhdGFUcmFuc2Zlci5zZXREcmFnSW1hZ2UgJiYgIXNhZmFyaSkge1xcbiAgICB2YXIgaW1nID0gZWx0KFxcXCJpbWdcXFwiLCBudWxsLCBudWxsLCBcXFwicG9zaXRpb246IGZpeGVkOyBsZWZ0OiAwOyB0b3A6IDA7XFxcIilcXG4gICAgaW1nLnNyYyA9IFxcXCJkYXRhOmltYWdlL2dpZjtiYXNlNjQsUjBsR09EbGhBUUFCQUFBQUFDSDVCQUVLQUFFQUxBQUFBQUFCQUFFQUFBSUNUQUVBT3c9PVxcXCJcXG4gICAgaWYgKHByZXN0bykge1xcbiAgICAgIGltZy53aWR0aCA9IGltZy5oZWlnaHQgPSAxXFxuICAgICAgY20uZGlzcGxheS53cmFwcGVyLmFwcGVuZENoaWxkKGltZylcXG4gICAgICAvLyBGb3JjZSBhIHJlbGF5b3V0LCBvciBPcGVyYSB3b24ndCB1c2Ugb3VyIGltYWdlIGZvciBzb21lIG9ic2N1cmUgcmVhc29uXFxuICAgICAgaW1nLl90b3AgPSBpbWcub2Zmc2V0VG9wXFxuICAgIH1cXG4gICAgZS5kYXRhVHJhbnNmZXIuc2V0RHJhZ0ltYWdlKGltZywgMCwgMClcXG4gICAgaWYgKHByZXN0bykgeyBpbWcucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChpbWcpIH1cXG4gIH1cXG59XFxuXFxuZnVuY3Rpb24gb25EcmFnT3ZlcihjbSwgZSkge1xcbiAgdmFyIHBvcyA9IHBvc0Zyb21Nb3VzZShjbSwgZSlcXG4gIGlmICghcG9zKSB7IHJldHVybiB9XFxuICB2YXIgZnJhZyA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKVxcbiAgZHJhd1NlbGVjdGlvbkN1cnNvcihjbSwgcG9zLCBmcmFnKVxcbiAgaWYgKCFjbS5kaXNwbGF5LmRyYWdDdXJzb3IpIHtcXG4gICAgY20uZGlzcGxheS5kcmFnQ3Vyc29yID0gZWx0KFxcXCJkaXZcXFwiLCBudWxsLCBcXFwiQ29kZU1pcnJvci1jdXJzb3JzIENvZGVNaXJyb3ItZHJhZ2N1cnNvcnNcXFwiKVxcbiAgICBjbS5kaXNwbGF5LmxpbmVTcGFjZS5pbnNlcnRCZWZvcmUoY20uZGlzcGxheS5kcmFnQ3Vyc29yLCBjbS5kaXNwbGF5LmN1cnNvckRpdilcXG4gIH1cXG4gIHJlbW92ZUNoaWxkcmVuQW5kQWRkKGNtLmRpc3BsYXkuZHJhZ0N1cnNvciwgZnJhZylcXG59XFxuXFxuZnVuY3Rpb24gY2xlYXJEcmFnQ3Vyc29yKGNtKSB7XFxuICBpZiAoY20uZGlzcGxheS5kcmFnQ3Vyc29yKSB7XFxuICAgIGNtLmRpc3BsYXkubGluZVNwYWNlLnJlbW92ZUNoaWxkKGNtLmRpc3BsYXkuZHJhZ0N1cnNvcilcXG4gICAgY20uZGlzcGxheS5kcmFnQ3Vyc29yID0gbnVsbFxcbiAgfVxcbn1cXG5cXG4vLyBUaGVzZSBtdXN0IGJlIGhhbmRsZWQgY2FyZWZ1bGx5LCBiZWNhdXNlIG5haXZlbHkgcmVnaXN0ZXJpbmcgYVxcbi8vIGhhbmRsZXIgZm9yIGVhY2ggZWRpdG9yIHdpbGwgY2F1c2UgdGhlIGVkaXRvcnMgdG8gbmV2ZXIgYmVcXG4vLyBnYXJiYWdlIGNvbGxlY3RlZC5cXG5cXG5mdW5jdGlvbiBmb3JFYWNoQ29kZU1pcnJvcihmKSB7XFxuICBpZiAoIWRvY3VtZW50LmJvZHkuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSkgeyByZXR1cm4gfVxcbiAgdmFyIGJ5Q2xhc3MgPSBkb2N1bWVudC5ib2R5LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoXFxcIkNvZGVNaXJyb3JcXFwiKVxcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBieUNsYXNzLmxlbmd0aDsgaSsrKSB7XFxuICAgIHZhciBjbSA9IGJ5Q2xhc3NbaV0uQ29kZU1pcnJvclxcbiAgICBpZiAoY20pIHsgZihjbSkgfVxcbiAgfVxcbn1cXG5cXG52YXIgZ2xvYmFsc1JlZ2lzdGVyZWQgPSBmYWxzZVxcbmZ1bmN0aW9uIGVuc3VyZUdsb2JhbEhhbmRsZXJzKCkge1xcbiAgaWYgKGdsb2JhbHNSZWdpc3RlcmVkKSB7IHJldHVybiB9XFxuICByZWdpc3Rlckdsb2JhbEhhbmRsZXJzKClcXG4gIGdsb2JhbHNSZWdpc3RlcmVkID0gdHJ1ZVxcbn1cXG5mdW5jdGlvbiByZWdpc3Rlckdsb2JhbEhhbmRsZXJzKCkge1xcbiAgLy8gV2hlbiB0aGUgd2luZG93IHJlc2l6ZXMsIHdlIG5lZWQgdG8gcmVmcmVzaCBhY3RpdmUgZWRpdG9ycy5cXG4gIHZhciByZXNpemVUaW1lclxcbiAgb24od2luZG93LCBcXFwicmVzaXplXFxcIiwgZnVuY3Rpb24gKCkge1xcbiAgICBpZiAocmVzaXplVGltZXIgPT0gbnVsbCkgeyByZXNpemVUaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xcbiAgICAgIHJlc2l6ZVRpbWVyID0gbnVsbFxcbiAgICAgIGZvckVhY2hDb2RlTWlycm9yKG9uUmVzaXplKVxcbiAgICB9LCAxMDApIH1cXG4gIH0pXFxuICAvLyBXaGVuIHRoZSB3aW5kb3cgbG9zZXMgZm9jdXMsIHdlIHdhbnQgdG8gc2hvdyB0aGUgZWRpdG9yIGFzIGJsdXJyZWRcXG4gIG9uKHdpbmRvdywgXFxcImJsdXJcXFwiLCBmdW5jdGlvbiAoKSB7IHJldHVybiBmb3JFYWNoQ29kZU1pcnJvcihvbkJsdXIpOyB9KVxcbn1cXG4vLyBDYWxsZWQgd2hlbiB0aGUgd2luZG93IHJlc2l6ZXNcXG5mdW5jdGlvbiBvblJlc2l6ZShjbSkge1xcbiAgdmFyIGQgPSBjbS5kaXNwbGF5XFxuICBpZiAoZC5sYXN0V3JhcEhlaWdodCA9PSBkLndyYXBwZXIuY2xpZW50SGVpZ2h0ICYmIGQubGFzdFdyYXBXaWR0aCA9PSBkLndyYXBwZXIuY2xpZW50V2lkdGgpXFxuICAgIHsgcmV0dXJuIH1cXG4gIC8vIE1pZ2h0IGJlIGEgdGV4dCBzY2FsaW5nIG9wZXJhdGlvbiwgY2xlYXIgc2l6ZSBjYWNoZXMuXFxuICBkLmNhY2hlZENoYXJXaWR0aCA9IGQuY2FjaGVkVGV4dEhlaWdodCA9IGQuY2FjaGVkUGFkZGluZ0ggPSBudWxsXFxuICBkLnNjcm9sbGJhcnNDbGlwcGVkID0gZmFsc2VcXG4gIGNtLnNldFNpemUoKVxcbn1cXG5cXG52YXIga2V5TmFtZXMgPSB7XFxuICAzOiBcXFwiRW50ZXJcXFwiLCA4OiBcXFwiQmFja3NwYWNlXFxcIiwgOTogXFxcIlRhYlxcXCIsIDEzOiBcXFwiRW50ZXJcXFwiLCAxNjogXFxcIlNoaWZ0XFxcIiwgMTc6IFxcXCJDdHJsXFxcIiwgMTg6IFxcXCJBbHRcXFwiLFxcbiAgMTk6IFxcXCJQYXVzZVxcXCIsIDIwOiBcXFwiQ2Fwc0xvY2tcXFwiLCAyNzogXFxcIkVzY1xcXCIsIDMyOiBcXFwiU3BhY2VcXFwiLCAzMzogXFxcIlBhZ2VVcFxcXCIsIDM0OiBcXFwiUGFnZURvd25cXFwiLCAzNTogXFxcIkVuZFxcXCIsXFxuICAzNjogXFxcIkhvbWVcXFwiLCAzNzogXFxcIkxlZnRcXFwiLCAzODogXFxcIlVwXFxcIiwgMzk6IFxcXCJSaWdodFxcXCIsIDQwOiBcXFwiRG93blxcXCIsIDQ0OiBcXFwiUHJpbnRTY3JuXFxcIiwgNDU6IFxcXCJJbnNlcnRcXFwiLFxcbiAgNDY6IFxcXCJEZWxldGVcXFwiLCA1OTogXFxcIjtcXFwiLCA2MTogXFxcIj1cXFwiLCA5MTogXFxcIk1vZFxcXCIsIDkyOiBcXFwiTW9kXFxcIiwgOTM6IFxcXCJNb2RcXFwiLFxcbiAgMTA2OiBcXFwiKlxcXCIsIDEwNzogXFxcIj1cXFwiLCAxMDk6IFxcXCItXFxcIiwgMTEwOiBcXFwiLlxcXCIsIDExMTogXFxcIi9cXFwiLCAxMjc6IFxcXCJEZWxldGVcXFwiLFxcbiAgMTczOiBcXFwiLVxcXCIsIDE4NjogXFxcIjtcXFwiLCAxODc6IFxcXCI9XFxcIiwgMTg4OiBcXFwiLFxcXCIsIDE4OTogXFxcIi1cXFwiLCAxOTA6IFxcXCIuXFxcIiwgMTkxOiBcXFwiL1xcXCIsIDE5MjogXFxcImBcXFwiLCAyMTk6IFxcXCJbXFxcIiwgMjIwOiBcXFwiXFxcXFxcXFxcXFwiLFxcbiAgMjIxOiBcXFwiXVxcXCIsIDIyMjogXFxcIidcXFwiLCA2MzIzMjogXFxcIlVwXFxcIiwgNjMyMzM6IFxcXCJEb3duXFxcIiwgNjMyMzQ6IFxcXCJMZWZ0XFxcIiwgNjMyMzU6IFxcXCJSaWdodFxcXCIsIDYzMjcyOiBcXFwiRGVsZXRlXFxcIixcXG4gIDYzMjczOiBcXFwiSG9tZVxcXCIsIDYzMjc1OiBcXFwiRW5kXFxcIiwgNjMyNzY6IFxcXCJQYWdlVXBcXFwiLCA2MzI3NzogXFxcIlBhZ2VEb3duXFxcIiwgNjMzMDI6IFxcXCJJbnNlcnRcXFwiXFxufVxcblxcbi8vIE51bWJlciBrZXlzXFxuZm9yICh2YXIgaSA9IDA7IGkgPCAxMDsgaSsrKSB7IGtleU5hbWVzW2kgKyA0OF0gPSBrZXlOYW1lc1tpICsgOTZdID0gU3RyaW5nKGkpIH1cXG4vLyBBbHBoYWJldGljIGtleXNcXG5mb3IgKHZhciBpJDEgPSA2NTsgaSQxIDw9IDkwOyBpJDErKykgeyBrZXlOYW1lc1tpJDFdID0gU3RyaW5nLmZyb21DaGFyQ29kZShpJDEpIH1cXG4vLyBGdW5jdGlvbiBrZXlzXFxuZm9yICh2YXIgaSQyID0gMTsgaSQyIDw9IDEyOyBpJDIrKykgeyBrZXlOYW1lc1tpJDIgKyAxMTFdID0ga2V5TmFtZXNbaSQyICsgNjMyMzVdID0gXFxcIkZcXFwiICsgaSQyIH1cXG5cXG52YXIga2V5TWFwID0ge31cXG5cXG5rZXlNYXAuYmFzaWMgPSB7XFxuICBcXFwiTGVmdFxcXCI6IFxcXCJnb0NoYXJMZWZ0XFxcIiwgXFxcIlJpZ2h0XFxcIjogXFxcImdvQ2hhclJpZ2h0XFxcIiwgXFxcIlVwXFxcIjogXFxcImdvTGluZVVwXFxcIiwgXFxcIkRvd25cXFwiOiBcXFwiZ29MaW5lRG93blxcXCIsXFxuICBcXFwiRW5kXFxcIjogXFxcImdvTGluZUVuZFxcXCIsIFxcXCJIb21lXFxcIjogXFxcImdvTGluZVN0YXJ0U21hcnRcXFwiLCBcXFwiUGFnZVVwXFxcIjogXFxcImdvUGFnZVVwXFxcIiwgXFxcIlBhZ2VEb3duXFxcIjogXFxcImdvUGFnZURvd25cXFwiLFxcbiAgXFxcIkRlbGV0ZVxcXCI6IFxcXCJkZWxDaGFyQWZ0ZXJcXFwiLCBcXFwiQmFja3NwYWNlXFxcIjogXFxcImRlbENoYXJCZWZvcmVcXFwiLCBcXFwiU2hpZnQtQmFja3NwYWNlXFxcIjogXFxcImRlbENoYXJCZWZvcmVcXFwiLFxcbiAgXFxcIlRhYlxcXCI6IFxcXCJkZWZhdWx0VGFiXFxcIiwgXFxcIlNoaWZ0LVRhYlxcXCI6IFxcXCJpbmRlbnRBdXRvXFxcIixcXG4gIFxcXCJFbnRlclxcXCI6IFxcXCJuZXdsaW5lQW5kSW5kZW50XFxcIiwgXFxcIkluc2VydFxcXCI6IFxcXCJ0b2dnbGVPdmVyd3JpdGVcXFwiLFxcbiAgXFxcIkVzY1xcXCI6IFxcXCJzaW5nbGVTZWxlY3Rpb25cXFwiXFxufVxcbi8vIE5vdGUgdGhhdCB0aGUgc2F2ZSBhbmQgZmluZC1yZWxhdGVkIGNvbW1hbmRzIGFyZW4ndCBkZWZpbmVkIGJ5XFxuLy8gZGVmYXVsdC4gVXNlciBjb2RlIG9yIGFkZG9ucyBjYW4gZGVmaW5lIHRoZW0uIFVua25vd24gY29tbWFuZHNcXG4vLyBhcmUgc2ltcGx5IGlnbm9yZWQuXFxua2V5TWFwLnBjRGVmYXVsdCA9IHtcXG4gIFxcXCJDdHJsLUFcXFwiOiBcXFwic2VsZWN0QWxsXFxcIiwgXFxcIkN0cmwtRFxcXCI6IFxcXCJkZWxldGVMaW5lXFxcIiwgXFxcIkN0cmwtWlxcXCI6IFxcXCJ1bmRvXFxcIiwgXFxcIlNoaWZ0LUN0cmwtWlxcXCI6IFxcXCJyZWRvXFxcIiwgXFxcIkN0cmwtWVxcXCI6IFxcXCJyZWRvXFxcIixcXG4gIFxcXCJDdHJsLUhvbWVcXFwiOiBcXFwiZ29Eb2NTdGFydFxcXCIsIFxcXCJDdHJsLUVuZFxcXCI6IFxcXCJnb0RvY0VuZFxcXCIsIFxcXCJDdHJsLVVwXFxcIjogXFxcImdvTGluZVVwXFxcIiwgXFxcIkN0cmwtRG93blxcXCI6IFxcXCJnb0xpbmVEb3duXFxcIixcXG4gIFxcXCJDdHJsLUxlZnRcXFwiOiBcXFwiZ29Hcm91cExlZnRcXFwiLCBcXFwiQ3RybC1SaWdodFxcXCI6IFxcXCJnb0dyb3VwUmlnaHRcXFwiLCBcXFwiQWx0LUxlZnRcXFwiOiBcXFwiZ29MaW5lU3RhcnRcXFwiLCBcXFwiQWx0LVJpZ2h0XFxcIjogXFxcImdvTGluZUVuZFxcXCIsXFxuICBcXFwiQ3RybC1CYWNrc3BhY2VcXFwiOiBcXFwiZGVsR3JvdXBCZWZvcmVcXFwiLCBcXFwiQ3RybC1EZWxldGVcXFwiOiBcXFwiZGVsR3JvdXBBZnRlclxcXCIsIFxcXCJDdHJsLVNcXFwiOiBcXFwic2F2ZVxcXCIsIFxcXCJDdHJsLUZcXFwiOiBcXFwiZmluZFxcXCIsXFxuICBcXFwiQ3RybC1HXFxcIjogXFxcImZpbmROZXh0XFxcIiwgXFxcIlNoaWZ0LUN0cmwtR1xcXCI6IFxcXCJmaW5kUHJldlxcXCIsIFxcXCJTaGlmdC1DdHJsLUZcXFwiOiBcXFwicmVwbGFjZVxcXCIsIFxcXCJTaGlmdC1DdHJsLVJcXFwiOiBcXFwicmVwbGFjZUFsbFxcXCIsXFxuICBcXFwiQ3RybC1bXFxcIjogXFxcImluZGVudExlc3NcXFwiLCBcXFwiQ3RybC1dXFxcIjogXFxcImluZGVudE1vcmVcXFwiLFxcbiAgXFxcIkN0cmwtVVxcXCI6IFxcXCJ1bmRvU2VsZWN0aW9uXFxcIiwgXFxcIlNoaWZ0LUN0cmwtVVxcXCI6IFxcXCJyZWRvU2VsZWN0aW9uXFxcIiwgXFxcIkFsdC1VXFxcIjogXFxcInJlZG9TZWxlY3Rpb25cXFwiLFxcbiAgZmFsbHRocm91Z2g6IFxcXCJiYXNpY1xcXCJcXG59XFxuLy8gVmVyeSBiYXNpYyByZWFkbGluZS9lbWFjcy1zdHlsZSBiaW5kaW5ncywgd2hpY2ggYXJlIHN0YW5kYXJkIG9uIE1hYy5cXG5rZXlNYXAuZW1hY3N5ID0ge1xcbiAgXFxcIkN0cmwtRlxcXCI6IFxcXCJnb0NoYXJSaWdodFxcXCIsIFxcXCJDdHJsLUJcXFwiOiBcXFwiZ29DaGFyTGVmdFxcXCIsIFxcXCJDdHJsLVBcXFwiOiBcXFwiZ29MaW5lVXBcXFwiLCBcXFwiQ3RybC1OXFxcIjogXFxcImdvTGluZURvd25cXFwiLFxcbiAgXFxcIkFsdC1GXFxcIjogXFxcImdvV29yZFJpZ2h0XFxcIiwgXFxcIkFsdC1CXFxcIjogXFxcImdvV29yZExlZnRcXFwiLCBcXFwiQ3RybC1BXFxcIjogXFxcImdvTGluZVN0YXJ0XFxcIiwgXFxcIkN0cmwtRVxcXCI6IFxcXCJnb0xpbmVFbmRcXFwiLFxcbiAgXFxcIkN0cmwtVlxcXCI6IFxcXCJnb1BhZ2VEb3duXFxcIiwgXFxcIlNoaWZ0LUN0cmwtVlxcXCI6IFxcXCJnb1BhZ2VVcFxcXCIsIFxcXCJDdHJsLURcXFwiOiBcXFwiZGVsQ2hhckFmdGVyXFxcIiwgXFxcIkN0cmwtSFxcXCI6IFxcXCJkZWxDaGFyQmVmb3JlXFxcIixcXG4gIFxcXCJBbHQtRFxcXCI6IFxcXCJkZWxXb3JkQWZ0ZXJcXFwiLCBcXFwiQWx0LUJhY2tzcGFjZVxcXCI6IFxcXCJkZWxXb3JkQmVmb3JlXFxcIiwgXFxcIkN0cmwtS1xcXCI6IFxcXCJraWxsTGluZVxcXCIsIFxcXCJDdHJsLVRcXFwiOiBcXFwidHJhbnNwb3NlQ2hhcnNcXFwiLFxcbiAgXFxcIkN0cmwtT1xcXCI6IFxcXCJvcGVuTGluZVxcXCJcXG59XFxua2V5TWFwLm1hY0RlZmF1bHQgPSB7XFxuICBcXFwiQ21kLUFcXFwiOiBcXFwic2VsZWN0QWxsXFxcIiwgXFxcIkNtZC1EXFxcIjogXFxcImRlbGV0ZUxpbmVcXFwiLCBcXFwiQ21kLVpcXFwiOiBcXFwidW5kb1xcXCIsIFxcXCJTaGlmdC1DbWQtWlxcXCI6IFxcXCJyZWRvXFxcIiwgXFxcIkNtZC1ZXFxcIjogXFxcInJlZG9cXFwiLFxcbiAgXFxcIkNtZC1Ib21lXFxcIjogXFxcImdvRG9jU3RhcnRcXFwiLCBcXFwiQ21kLVVwXFxcIjogXFxcImdvRG9jU3RhcnRcXFwiLCBcXFwiQ21kLUVuZFxcXCI6IFxcXCJnb0RvY0VuZFxcXCIsIFxcXCJDbWQtRG93blxcXCI6IFxcXCJnb0RvY0VuZFxcXCIsIFxcXCJBbHQtTGVmdFxcXCI6IFxcXCJnb0dyb3VwTGVmdFxcXCIsXFxuICBcXFwiQWx0LVJpZ2h0XFxcIjogXFxcImdvR3JvdXBSaWdodFxcXCIsIFxcXCJDbWQtTGVmdFxcXCI6IFxcXCJnb0xpbmVMZWZ0XFxcIiwgXFxcIkNtZC1SaWdodFxcXCI6IFxcXCJnb0xpbmVSaWdodFxcXCIsIFxcXCJBbHQtQmFja3NwYWNlXFxcIjogXFxcImRlbEdyb3VwQmVmb3JlXFxcIixcXG4gIFxcXCJDdHJsLUFsdC1CYWNrc3BhY2VcXFwiOiBcXFwiZGVsR3JvdXBBZnRlclxcXCIsIFxcXCJBbHQtRGVsZXRlXFxcIjogXFxcImRlbEdyb3VwQWZ0ZXJcXFwiLCBcXFwiQ21kLVNcXFwiOiBcXFwic2F2ZVxcXCIsIFxcXCJDbWQtRlxcXCI6IFxcXCJmaW5kXFxcIixcXG4gIFxcXCJDbWQtR1xcXCI6IFxcXCJmaW5kTmV4dFxcXCIsIFxcXCJTaGlmdC1DbWQtR1xcXCI6IFxcXCJmaW5kUHJldlxcXCIsIFxcXCJDbWQtQWx0LUZcXFwiOiBcXFwicmVwbGFjZVxcXCIsIFxcXCJTaGlmdC1DbWQtQWx0LUZcXFwiOiBcXFwicmVwbGFjZUFsbFxcXCIsXFxuICBcXFwiQ21kLVtcXFwiOiBcXFwiaW5kZW50TGVzc1xcXCIsIFxcXCJDbWQtXVxcXCI6IFxcXCJpbmRlbnRNb3JlXFxcIiwgXFxcIkNtZC1CYWNrc3BhY2VcXFwiOiBcXFwiZGVsV3JhcHBlZExpbmVMZWZ0XFxcIiwgXFxcIkNtZC1EZWxldGVcXFwiOiBcXFwiZGVsV3JhcHBlZExpbmVSaWdodFxcXCIsXFxuICBcXFwiQ21kLVVcXFwiOiBcXFwidW5kb1NlbGVjdGlvblxcXCIsIFxcXCJTaGlmdC1DbWQtVVxcXCI6IFxcXCJyZWRvU2VsZWN0aW9uXFxcIiwgXFxcIkN0cmwtVXBcXFwiOiBcXFwiZ29Eb2NTdGFydFxcXCIsIFxcXCJDdHJsLURvd25cXFwiOiBcXFwiZ29Eb2NFbmRcXFwiLFxcbiAgZmFsbHRocm91Z2g6IFtcXFwiYmFzaWNcXFwiLCBcXFwiZW1hY3N5XFxcIl1cXG59XFxua2V5TWFwW1xcXCJkZWZhdWx0XFxcIl0gPSBtYWMgPyBrZXlNYXAubWFjRGVmYXVsdCA6IGtleU1hcC5wY0RlZmF1bHRcXG5cXG4vLyBLRVlNQVAgRElTUEFUQ0hcXG5cXG5mdW5jdGlvbiBub3JtYWxpemVLZXlOYW1lKG5hbWUpIHtcXG4gIHZhciBwYXJ0cyA9IG5hbWUuc3BsaXQoLy0oPyEkKS8pXFxuICBuYW1lID0gcGFydHNbcGFydHMubGVuZ3RoIC0gMV1cXG4gIHZhciBhbHQsIGN0cmwsIHNoaWZ0LCBjbWRcXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoIC0gMTsgaSsrKSB7XFxuICAgIHZhciBtb2QgPSBwYXJ0c1tpXVxcbiAgICBpZiAoL14oY21kfG1ldGF8bSkkL2kudGVzdChtb2QpKSB7IGNtZCA9IHRydWUgfVxcbiAgICBlbHNlIGlmICgvXmEobHQpPyQvaS50ZXN0KG1vZCkpIHsgYWx0ID0gdHJ1ZSB9XFxuICAgIGVsc2UgaWYgKC9eKGN8Y3RybHxjb250cm9sKSQvaS50ZXN0KG1vZCkpIHsgY3RybCA9IHRydWUgfVxcbiAgICBlbHNlIGlmICgvXnMoaGlmdCk/JC9pLnRlc3QobW9kKSkgeyBzaGlmdCA9IHRydWUgfVxcbiAgICBlbHNlIHsgdGhyb3cgbmV3IEVycm9yKFxcXCJVbnJlY29nbml6ZWQgbW9kaWZpZXIgbmFtZTogXFxcIiArIG1vZCkgfVxcbiAgfVxcbiAgaWYgKGFsdCkgeyBuYW1lID0gXFxcIkFsdC1cXFwiICsgbmFtZSB9XFxuICBpZiAoY3RybCkgeyBuYW1lID0gXFxcIkN0cmwtXFxcIiArIG5hbWUgfVxcbiAgaWYgKGNtZCkgeyBuYW1lID0gXFxcIkNtZC1cXFwiICsgbmFtZSB9XFxuICBpZiAoc2hpZnQpIHsgbmFtZSA9IFxcXCJTaGlmdC1cXFwiICsgbmFtZSB9XFxuICByZXR1cm4gbmFtZVxcbn1cXG5cXG4vLyBUaGlzIGlzIGEga2x1ZGdlIHRvIGtlZXAga2V5bWFwcyBtb3N0bHkgd29ya2luZyBhcyByYXcgb2JqZWN0c1xcbi8vIChiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSkgd2hpbGUgYXQgdGhlIHNhbWUgdGltZSBzdXBwb3J0IGZlYXR1cmVzXFxuLy8gbGlrZSBub3JtYWxpemF0aW9uIGFuZCBtdWx0aS1zdHJva2Uga2V5IGJpbmRpbmdzLiBJdCBjb21waWxlcyBhXFxuLy8gbmV3IG5vcm1hbGl6ZWQga2V5bWFwLCBhbmQgdGhlbiB1cGRhdGVzIHRoZSBvbGQgb2JqZWN0IHRvIHJlZmxlY3RcXG4vLyB0aGlzLlxcbmZ1bmN0aW9uIG5vcm1hbGl6ZUtleU1hcChrZXltYXApIHtcXG4gIHZhciBjb3B5ID0ge31cXG4gIGZvciAodmFyIGtleW5hbWUgaW4ga2V5bWFwKSB7IGlmIChrZXltYXAuaGFzT3duUHJvcGVydHkoa2V5bmFtZSkpIHtcXG4gICAgdmFyIHZhbHVlID0ga2V5bWFwW2tleW5hbWVdXFxuICAgIGlmICgvXihuYW1lfGZhbGx0aHJvdWdofChkZXxhdCl0YWNoKSQvLnRlc3Qoa2V5bmFtZSkpIHsgY29udGludWUgfVxcbiAgICBpZiAodmFsdWUgPT0gXFxcIi4uLlxcXCIpIHsgZGVsZXRlIGtleW1hcFtrZXluYW1lXTsgY29udGludWUgfVxcblxcbiAgICB2YXIga2V5cyA9IG1hcChrZXluYW1lLnNwbGl0KFxcXCIgXFxcIiksIG5vcm1hbGl6ZUtleU5hbWUpXFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xcbiAgICAgIHZhciB2YWwgPSAodm9pZCAwKSwgbmFtZSA9ICh2b2lkIDApXFxuICAgICAgaWYgKGkgPT0ga2V5cy5sZW5ndGggLSAxKSB7XFxuICAgICAgICBuYW1lID0ga2V5cy5qb2luKFxcXCIgXFxcIilcXG4gICAgICAgIHZhbCA9IHZhbHVlXFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIG5hbWUgPSBrZXlzLnNsaWNlKDAsIGkgKyAxKS5qb2luKFxcXCIgXFxcIilcXG4gICAgICAgIHZhbCA9IFxcXCIuLi5cXFwiXFxuICAgICAgfVxcbiAgICAgIHZhciBwcmV2ID0gY29weVtuYW1lXVxcbiAgICAgIGlmICghcHJldikgeyBjb3B5W25hbWVdID0gdmFsIH1cXG4gICAgICBlbHNlIGlmIChwcmV2ICE9IHZhbCkgeyB0aHJvdyBuZXcgRXJyb3IoXFxcIkluY29uc2lzdGVudCBiaW5kaW5ncyBmb3IgXFxcIiArIG5hbWUpIH1cXG4gICAgfVxcbiAgICBkZWxldGUga2V5bWFwW2tleW5hbWVdXFxuICB9IH1cXG4gIGZvciAodmFyIHByb3AgaW4gY29weSkgeyBrZXltYXBbcHJvcF0gPSBjb3B5W3Byb3BdIH1cXG4gIHJldHVybiBrZXltYXBcXG59XFxuXFxuZnVuY3Rpb24gbG9va3VwS2V5KGtleSwgbWFwLCBoYW5kbGUsIGNvbnRleHQpIHtcXG4gIG1hcCA9IGdldEtleU1hcChtYXApXFxuICB2YXIgZm91bmQgPSBtYXAuY2FsbCA/IG1hcC5jYWxsKGtleSwgY29udGV4dCkgOiBtYXBba2V5XVxcbiAgaWYgKGZvdW5kID09PSBmYWxzZSkgeyByZXR1cm4gXFxcIm5vdGhpbmdcXFwiIH1cXG4gIGlmIChmb3VuZCA9PT0gXFxcIi4uLlxcXCIpIHsgcmV0dXJuIFxcXCJtdWx0aVxcXCIgfVxcbiAgaWYgKGZvdW5kICE9IG51bGwgJiYgaGFuZGxlKGZvdW5kKSkgeyByZXR1cm4gXFxcImhhbmRsZWRcXFwiIH1cXG5cXG4gIGlmIChtYXAuZmFsbHRocm91Z2gpIHtcXG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChtYXAuZmFsbHRocm91Z2gpICE9IFxcXCJbb2JqZWN0IEFycmF5XVxcXCIpXFxuICAgICAgeyByZXR1cm4gbG9va3VwS2V5KGtleSwgbWFwLmZhbGx0aHJvdWdoLCBoYW5kbGUsIGNvbnRleHQpIH1cXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXAuZmFsbHRocm91Z2gubGVuZ3RoOyBpKyspIHtcXG4gICAgICB2YXIgcmVzdWx0ID0gbG9va3VwS2V5KGtleSwgbWFwLmZhbGx0aHJvdWdoW2ldLCBoYW5kbGUsIGNvbnRleHQpXFxuICAgICAgaWYgKHJlc3VsdCkgeyByZXR1cm4gcmVzdWx0IH1cXG4gICAgfVxcbiAgfVxcbn1cXG5cXG4vLyBNb2RpZmllciBrZXkgcHJlc3NlcyBkb24ndCBjb3VudCBhcyAncmVhbCcga2V5IHByZXNzZXMgZm9yIHRoZVxcbi8vIHB1cnBvc2Ugb2Yga2V5bWFwIGZhbGx0aHJvdWdoLlxcbmZ1bmN0aW9uIGlzTW9kaWZpZXJLZXkodmFsdWUpIHtcXG4gIHZhciBuYW1lID0gdHlwZW9mIHZhbHVlID09IFxcXCJzdHJpbmdcXFwiID8gdmFsdWUgOiBrZXlOYW1lc1t2YWx1ZS5rZXlDb2RlXVxcbiAgcmV0dXJuIG5hbWUgPT0gXFxcIkN0cmxcXFwiIHx8IG5hbWUgPT0gXFxcIkFsdFxcXCIgfHwgbmFtZSA9PSBcXFwiU2hpZnRcXFwiIHx8IG5hbWUgPT0gXFxcIk1vZFxcXCJcXG59XFxuXFxuLy8gTG9vayB1cCB0aGUgbmFtZSBvZiBhIGtleSBhcyBpbmRpY2F0ZWQgYnkgYW4gZXZlbnQgb2JqZWN0LlxcbmZ1bmN0aW9uIGtleU5hbWUoZXZlbnQsIG5vU2hpZnQpIHtcXG4gIGlmIChwcmVzdG8gJiYgZXZlbnQua2V5Q29kZSA9PSAzNCAmJiBldmVudFtcXFwiY2hhclxcXCJdKSB7IHJldHVybiBmYWxzZSB9XFxuICB2YXIgYmFzZSA9IGtleU5hbWVzW2V2ZW50LmtleUNvZGVdLCBuYW1lID0gYmFzZVxcbiAgaWYgKG5hbWUgPT0gbnVsbCB8fCBldmVudC5hbHRHcmFwaEtleSkgeyByZXR1cm4gZmFsc2UgfVxcbiAgaWYgKGV2ZW50LmFsdEtleSAmJiBiYXNlICE9IFxcXCJBbHRcXFwiKSB7IG5hbWUgPSBcXFwiQWx0LVxcXCIgKyBuYW1lIH1cXG4gIGlmICgoZmxpcEN0cmxDbWQgPyBldmVudC5tZXRhS2V5IDogZXZlbnQuY3RybEtleSkgJiYgYmFzZSAhPSBcXFwiQ3RybFxcXCIpIHsgbmFtZSA9IFxcXCJDdHJsLVxcXCIgKyBuYW1lIH1cXG4gIGlmICgoZmxpcEN0cmxDbWQgPyBldmVudC5jdHJsS2V5IDogZXZlbnQubWV0YUtleSkgJiYgYmFzZSAhPSBcXFwiQ21kXFxcIikgeyBuYW1lID0gXFxcIkNtZC1cXFwiICsgbmFtZSB9XFxuICBpZiAoIW5vU2hpZnQgJiYgZXZlbnQuc2hpZnRLZXkgJiYgYmFzZSAhPSBcXFwiU2hpZnRcXFwiKSB7IG5hbWUgPSBcXFwiU2hpZnQtXFxcIiArIG5hbWUgfVxcbiAgcmV0dXJuIG5hbWVcXG59XFxuXFxuZnVuY3Rpb24gZ2V0S2V5TWFwKHZhbCkge1xcbiAgcmV0dXJuIHR5cGVvZiB2YWwgPT0gXFxcInN0cmluZ1xcXCIgPyBrZXlNYXBbdmFsXSA6IHZhbFxcbn1cXG5cXG4vLyBIZWxwZXIgZm9yIGRlbGV0aW5nIHRleHQgbmVhciB0aGUgc2VsZWN0aW9uKHMpLCB1c2VkIHRvIGltcGxlbWVudFxcbi8vIGJhY2tzcGFjZSwgZGVsZXRlLCBhbmQgc2ltaWxhciBmdW5jdGlvbmFsaXR5LlxcbmZ1bmN0aW9uIGRlbGV0ZU5lYXJTZWxlY3Rpb24oY20sIGNvbXB1dGUpIHtcXG4gIHZhciByYW5nZXMgPSBjbS5kb2Muc2VsLnJhbmdlcywga2lsbCA9IFtdXFxuICAvLyBCdWlsZCB1cCBhIHNldCBvZiByYW5nZXMgdG8ga2lsbCBmaXJzdCwgbWVyZ2luZyBvdmVybGFwcGluZ1xcbiAgLy8gcmFuZ2VzLlxcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCByYW5nZXMubGVuZ3RoOyBpKyspIHtcXG4gICAgdmFyIHRvS2lsbCA9IGNvbXB1dGUocmFuZ2VzW2ldKVxcbiAgICB3aGlsZSAoa2lsbC5sZW5ndGggJiYgY21wKHRvS2lsbC5mcm9tLCBsc3Qoa2lsbCkudG8pIDw9IDApIHtcXG4gICAgICB2YXIgcmVwbGFjZWQgPSBraWxsLnBvcCgpXFxuICAgICAgaWYgKGNtcChyZXBsYWNlZC5mcm9tLCB0b0tpbGwuZnJvbSkgPCAwKSB7XFxuICAgICAgICB0b0tpbGwuZnJvbSA9IHJlcGxhY2VkLmZyb21cXG4gICAgICAgIGJyZWFrXFxuICAgICAgfVxcbiAgICB9XFxuICAgIGtpbGwucHVzaCh0b0tpbGwpXFxuICB9XFxuICAvLyBOZXh0LCByZW1vdmUgdGhvc2UgYWN0dWFsIHJhbmdlcy5cXG4gIHJ1bkluT3AoY20sIGZ1bmN0aW9uICgpIHtcXG4gICAgZm9yICh2YXIgaSA9IGtpbGwubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pXFxuICAgICAgeyByZXBsYWNlUmFuZ2UoY20uZG9jLCBcXFwiXFxcIiwga2lsbFtpXS5mcm9tLCBraWxsW2ldLnRvLCBcXFwiK2RlbGV0ZVxcXCIpIH1cXG4gICAgZW5zdXJlQ3Vyc29yVmlzaWJsZShjbSlcXG4gIH0pXFxufVxcblxcbi8vIENvbW1hbmRzIGFyZSBwYXJhbWV0ZXItbGVzcyBhY3Rpb25zIHRoYXQgY2FuIGJlIHBlcmZvcm1lZCBvbiBhblxcbi8vIGVkaXRvciwgbW9zdGx5IHVzZWQgZm9yIGtleWJpbmRpbmdzLlxcbnZhciBjb21tYW5kcyA9IHtcXG4gIHNlbGVjdEFsbDogc2VsZWN0QWxsLFxcbiAgc2luZ2xlU2VsZWN0aW9uOiBmdW5jdGlvbiAoY20pIHsgcmV0dXJuIGNtLnNldFNlbGVjdGlvbihjbS5nZXRDdXJzb3IoXFxcImFuY2hvclxcXCIpLCBjbS5nZXRDdXJzb3IoXFxcImhlYWRcXFwiKSwgc2VsX2RvbnRTY3JvbGwpOyB9LFxcbiAga2lsbExpbmU6IGZ1bmN0aW9uIChjbSkgeyByZXR1cm4gZGVsZXRlTmVhclNlbGVjdGlvbihjbSwgZnVuY3Rpb24gKHJhbmdlKSB7XFxuICAgIGlmIChyYW5nZS5lbXB0eSgpKSB7XFxuICAgICAgdmFyIGxlbiA9IGdldExpbmUoY20uZG9jLCByYW5nZS5oZWFkLmxpbmUpLnRleHQubGVuZ3RoXFxuICAgICAgaWYgKHJhbmdlLmhlYWQuY2ggPT0gbGVuICYmIHJhbmdlLmhlYWQubGluZSA8IGNtLmxhc3RMaW5lKCkpXFxuICAgICAgICB7IHJldHVybiB7ZnJvbTogcmFuZ2UuaGVhZCwgdG86IFBvcyhyYW5nZS5oZWFkLmxpbmUgKyAxLCAwKX0gfVxcbiAgICAgIGVsc2VcXG4gICAgICAgIHsgcmV0dXJuIHtmcm9tOiByYW5nZS5oZWFkLCB0bzogUG9zKHJhbmdlLmhlYWQubGluZSwgbGVuKX0gfVxcbiAgICB9IGVsc2Uge1xcbiAgICAgIHJldHVybiB7ZnJvbTogcmFuZ2UuZnJvbSgpLCB0bzogcmFuZ2UudG8oKX1cXG4gICAgfVxcbiAgfSk7IH0sXFxuICBkZWxldGVMaW5lOiBmdW5jdGlvbiAoY20pIHsgcmV0dXJuIGRlbGV0ZU5lYXJTZWxlY3Rpb24oY20sIGZ1bmN0aW9uIChyYW5nZSkgeyByZXR1cm4gKHtcXG4gICAgZnJvbTogUG9zKHJhbmdlLmZyb20oKS5saW5lLCAwKSxcXG4gICAgdG86IGNsaXBQb3MoY20uZG9jLCBQb3MocmFuZ2UudG8oKS5saW5lICsgMSwgMCkpXFxuICB9KTsgfSk7IH0sXFxuICBkZWxMaW5lTGVmdDogZnVuY3Rpb24gKGNtKSB7IHJldHVybiBkZWxldGVOZWFyU2VsZWN0aW9uKGNtLCBmdW5jdGlvbiAocmFuZ2UpIHsgcmV0dXJuICh7XFxuICAgIGZyb206IFBvcyhyYW5nZS5mcm9tKCkubGluZSwgMCksIHRvOiByYW5nZS5mcm9tKClcXG4gIH0pOyB9KTsgfSxcXG4gIGRlbFdyYXBwZWRMaW5lTGVmdDogZnVuY3Rpb24gKGNtKSB7IHJldHVybiBkZWxldGVOZWFyU2VsZWN0aW9uKGNtLCBmdW5jdGlvbiAocmFuZ2UpIHtcXG4gICAgdmFyIHRvcCA9IGNtLmNoYXJDb29yZHMocmFuZ2UuaGVhZCwgXFxcImRpdlxcXCIpLnRvcCArIDVcXG4gICAgdmFyIGxlZnRQb3MgPSBjbS5jb29yZHNDaGFyKHtsZWZ0OiAwLCB0b3A6IHRvcH0sIFxcXCJkaXZcXFwiKVxcbiAgICByZXR1cm4ge2Zyb206IGxlZnRQb3MsIHRvOiByYW5nZS5mcm9tKCl9XFxuICB9KTsgfSxcXG4gIGRlbFdyYXBwZWRMaW5lUmlnaHQ6IGZ1bmN0aW9uIChjbSkgeyByZXR1cm4gZGVsZXRlTmVhclNlbGVjdGlvbihjbSwgZnVuY3Rpb24gKHJhbmdlKSB7XFxuICAgIHZhciB0b3AgPSBjbS5jaGFyQ29vcmRzKHJhbmdlLmhlYWQsIFxcXCJkaXZcXFwiKS50b3AgKyA1XFxuICAgIHZhciByaWdodFBvcyA9IGNtLmNvb3Jkc0NoYXIoe2xlZnQ6IGNtLmRpc3BsYXkubGluZURpdi5vZmZzZXRXaWR0aCArIDEwMCwgdG9wOiB0b3B9LCBcXFwiZGl2XFxcIilcXG4gICAgcmV0dXJuIHtmcm9tOiByYW5nZS5mcm9tKCksIHRvOiByaWdodFBvcyB9XFxuICB9KTsgfSxcXG4gIHVuZG86IGZ1bmN0aW9uIChjbSkgeyByZXR1cm4gY20udW5kbygpOyB9LFxcbiAgcmVkbzogZnVuY3Rpb24gKGNtKSB7IHJldHVybiBjbS5yZWRvKCk7IH0sXFxuICB1bmRvU2VsZWN0aW9uOiBmdW5jdGlvbiAoY20pIHsgcmV0dXJuIGNtLnVuZG9TZWxlY3Rpb24oKTsgfSxcXG4gIHJlZG9TZWxlY3Rpb246IGZ1bmN0aW9uIChjbSkgeyByZXR1cm4gY20ucmVkb1NlbGVjdGlvbigpOyB9LFxcbiAgZ29Eb2NTdGFydDogZnVuY3Rpb24gKGNtKSB7IHJldHVybiBjbS5leHRlbmRTZWxlY3Rpb24oUG9zKGNtLmZpcnN0TGluZSgpLCAwKSk7IH0sXFxuICBnb0RvY0VuZDogZnVuY3Rpb24gKGNtKSB7IHJldHVybiBjbS5leHRlbmRTZWxlY3Rpb24oUG9zKGNtLmxhc3RMaW5lKCkpKTsgfSxcXG4gIGdvTGluZVN0YXJ0OiBmdW5jdGlvbiAoY20pIHsgcmV0dXJuIGNtLmV4dGVuZFNlbGVjdGlvbnNCeShmdW5jdGlvbiAocmFuZ2UpIHsgcmV0dXJuIGxpbmVTdGFydChjbSwgcmFuZ2UuaGVhZC5saW5lKTsgfSxcXG4gICAge29yaWdpbjogXFxcIittb3ZlXFxcIiwgYmlhczogMX1cXG4gICk7IH0sXFxuICBnb0xpbmVTdGFydFNtYXJ0OiBmdW5jdGlvbiAoY20pIHsgcmV0dXJuIGNtLmV4dGVuZFNlbGVjdGlvbnNCeShmdW5jdGlvbiAocmFuZ2UpIHsgcmV0dXJuIGxpbmVTdGFydFNtYXJ0KGNtLCByYW5nZS5oZWFkKTsgfSxcXG4gICAge29yaWdpbjogXFxcIittb3ZlXFxcIiwgYmlhczogMX1cXG4gICk7IH0sXFxuICBnb0xpbmVFbmQ6IGZ1bmN0aW9uIChjbSkgeyByZXR1cm4gY20uZXh0ZW5kU2VsZWN0aW9uc0J5KGZ1bmN0aW9uIChyYW5nZSkgeyByZXR1cm4gbGluZUVuZChjbSwgcmFuZ2UuaGVhZC5saW5lKTsgfSxcXG4gICAge29yaWdpbjogXFxcIittb3ZlXFxcIiwgYmlhczogLTF9XFxuICApOyB9LFxcbiAgZ29MaW5lUmlnaHQ6IGZ1bmN0aW9uIChjbSkgeyByZXR1cm4gY20uZXh0ZW5kU2VsZWN0aW9uc0J5KGZ1bmN0aW9uIChyYW5nZSkge1xcbiAgICB2YXIgdG9wID0gY20uY2hhckNvb3JkcyhyYW5nZS5oZWFkLCBcXFwiZGl2XFxcIikudG9wICsgNVxcbiAgICByZXR1cm4gY20uY29vcmRzQ2hhcih7bGVmdDogY20uZGlzcGxheS5saW5lRGl2Lm9mZnNldFdpZHRoICsgMTAwLCB0b3A6IHRvcH0sIFxcXCJkaXZcXFwiKVxcbiAgfSwgc2VsX21vdmUpOyB9LFxcbiAgZ29MaW5lTGVmdDogZnVuY3Rpb24gKGNtKSB7IHJldHVybiBjbS5leHRlbmRTZWxlY3Rpb25zQnkoZnVuY3Rpb24gKHJhbmdlKSB7XFxuICAgIHZhciB0b3AgPSBjbS5jaGFyQ29vcmRzKHJhbmdlLmhlYWQsIFxcXCJkaXZcXFwiKS50b3AgKyA1XFxuICAgIHJldHVybiBjbS5jb29yZHNDaGFyKHtsZWZ0OiAwLCB0b3A6IHRvcH0sIFxcXCJkaXZcXFwiKVxcbiAgfSwgc2VsX21vdmUpOyB9LFxcbiAgZ29MaW5lTGVmdFNtYXJ0OiBmdW5jdGlvbiAoY20pIHsgcmV0dXJuIGNtLmV4dGVuZFNlbGVjdGlvbnNCeShmdW5jdGlvbiAocmFuZ2UpIHtcXG4gICAgdmFyIHRvcCA9IGNtLmNoYXJDb29yZHMocmFuZ2UuaGVhZCwgXFxcImRpdlxcXCIpLnRvcCArIDVcXG4gICAgdmFyIHBvcyA9IGNtLmNvb3Jkc0NoYXIoe2xlZnQ6IDAsIHRvcDogdG9wfSwgXFxcImRpdlxcXCIpXFxuICAgIGlmIChwb3MuY2ggPCBjbS5nZXRMaW5lKHBvcy5saW5lKS5zZWFyY2goL1xcXFxTLykpIHsgcmV0dXJuIGxpbmVTdGFydFNtYXJ0KGNtLCByYW5nZS5oZWFkKSB9XFxuICAgIHJldHVybiBwb3NcXG4gIH0sIHNlbF9tb3ZlKTsgfSxcXG4gIGdvTGluZVVwOiBmdW5jdGlvbiAoY20pIHsgcmV0dXJuIGNtLm1vdmVWKC0xLCBcXFwibGluZVxcXCIpOyB9LFxcbiAgZ29MaW5lRG93bjogZnVuY3Rpb24gKGNtKSB7IHJldHVybiBjbS5tb3ZlVigxLCBcXFwibGluZVxcXCIpOyB9LFxcbiAgZ29QYWdlVXA6IGZ1bmN0aW9uIChjbSkgeyByZXR1cm4gY20ubW92ZVYoLTEsIFxcXCJwYWdlXFxcIik7IH0sXFxuICBnb1BhZ2VEb3duOiBmdW5jdGlvbiAoY20pIHsgcmV0dXJuIGNtLm1vdmVWKDEsIFxcXCJwYWdlXFxcIik7IH0sXFxuICBnb0NoYXJMZWZ0OiBmdW5jdGlvbiAoY20pIHsgcmV0dXJuIGNtLm1vdmVIKC0xLCBcXFwiY2hhclxcXCIpOyB9LFxcbiAgZ29DaGFyUmlnaHQ6IGZ1bmN0aW9uIChjbSkgeyByZXR1cm4gY20ubW92ZUgoMSwgXFxcImNoYXJcXFwiKTsgfSxcXG4gIGdvQ29sdW1uTGVmdDogZnVuY3Rpb24gKGNtKSB7IHJldHVybiBjbS5tb3ZlSCgtMSwgXFxcImNvbHVtblxcXCIpOyB9LFxcbiAgZ29Db2x1bW5SaWdodDogZnVuY3Rpb24gKGNtKSB7IHJldHVybiBjbS5tb3ZlSCgxLCBcXFwiY29sdW1uXFxcIik7IH0sXFxuICBnb1dvcmRMZWZ0OiBmdW5jdGlvbiAoY20pIHsgcmV0dXJuIGNtLm1vdmVIKC0xLCBcXFwid29yZFxcXCIpOyB9LFxcbiAgZ29Hcm91cFJpZ2h0OiBmdW5jdGlvbiAoY20pIHsgcmV0dXJuIGNtLm1vdmVIKDEsIFxcXCJncm91cFxcXCIpOyB9LFxcbiAgZ29Hcm91cExlZnQ6IGZ1bmN0aW9uIChjbSkgeyByZXR1cm4gY20ubW92ZUgoLTEsIFxcXCJncm91cFxcXCIpOyB9LFxcbiAgZ29Xb3JkUmlnaHQ6IGZ1bmN0aW9uIChjbSkgeyByZXR1cm4gY20ubW92ZUgoMSwgXFxcIndvcmRcXFwiKTsgfSxcXG4gIGRlbENoYXJCZWZvcmU6IGZ1bmN0aW9uIChjbSkgeyByZXR1cm4gY20uZGVsZXRlSCgtMSwgXFxcImNoYXJcXFwiKTsgfSxcXG4gIGRlbENoYXJBZnRlcjogZnVuY3Rpb24gKGNtKSB7IHJldHVybiBjbS5kZWxldGVIKDEsIFxcXCJjaGFyXFxcIik7IH0sXFxuICBkZWxXb3JkQmVmb3JlOiBmdW5jdGlvbiAoY20pIHsgcmV0dXJuIGNtLmRlbGV0ZUgoLTEsIFxcXCJ3b3JkXFxcIik7IH0sXFxuICBkZWxXb3JkQWZ0ZXI6IGZ1bmN0aW9uIChjbSkgeyByZXR1cm4gY20uZGVsZXRlSCgxLCBcXFwid29yZFxcXCIpOyB9LFxcbiAgZGVsR3JvdXBCZWZvcmU6IGZ1bmN0aW9uIChjbSkgeyByZXR1cm4gY20uZGVsZXRlSCgtMSwgXFxcImdyb3VwXFxcIik7IH0sXFxuICBkZWxHcm91cEFmdGVyOiBmdW5jdGlvbiAoY20pIHsgcmV0dXJuIGNtLmRlbGV0ZUgoMSwgXFxcImdyb3VwXFxcIik7IH0sXFxuICBpbmRlbnRBdXRvOiBmdW5jdGlvbiAoY20pIHsgcmV0dXJuIGNtLmluZGVudFNlbGVjdGlvbihcXFwic21hcnRcXFwiKTsgfSxcXG4gIGluZGVudE1vcmU6IGZ1bmN0aW9uIChjbSkgeyByZXR1cm4gY20uaW5kZW50U2VsZWN0aW9uKFxcXCJhZGRcXFwiKTsgfSxcXG4gIGluZGVudExlc3M6IGZ1bmN0aW9uIChjbSkgeyByZXR1cm4gY20uaW5kZW50U2VsZWN0aW9uKFxcXCJzdWJ0cmFjdFxcXCIpOyB9LFxcbiAgaW5zZXJ0VGFiOiBmdW5jdGlvbiAoY20pIHsgcmV0dXJuIGNtLnJlcGxhY2VTZWxlY3Rpb24oXFxcIlxcXFx0XFxcIik7IH0sXFxuICBpbnNlcnRTb2Z0VGFiOiBmdW5jdGlvbiAoY20pIHtcXG4gICAgdmFyIHNwYWNlcyA9IFtdLCByYW5nZXMgPSBjbS5saXN0U2VsZWN0aW9ucygpLCB0YWJTaXplID0gY20ub3B0aW9ucy50YWJTaXplXFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmFuZ2VzLmxlbmd0aDsgaSsrKSB7XFxuICAgICAgdmFyIHBvcyA9IHJhbmdlc1tpXS5mcm9tKClcXG4gICAgICB2YXIgY29sID0gY291bnRDb2x1bW4oY20uZ2V0TGluZShwb3MubGluZSksIHBvcy5jaCwgdGFiU2l6ZSlcXG4gICAgICBzcGFjZXMucHVzaChzcGFjZVN0cih0YWJTaXplIC0gY29sICUgdGFiU2l6ZSkpXFxuICAgIH1cXG4gICAgY20ucmVwbGFjZVNlbGVjdGlvbnMoc3BhY2VzKVxcbiAgfSxcXG4gIGRlZmF1bHRUYWI6IGZ1bmN0aW9uIChjbSkge1xcbiAgICBpZiAoY20uc29tZXRoaW5nU2VsZWN0ZWQoKSkgeyBjbS5pbmRlbnRTZWxlY3Rpb24oXFxcImFkZFxcXCIpIH1cXG4gICAgZWxzZSB7IGNtLmV4ZWNDb21tYW5kKFxcXCJpbnNlcnRUYWJcXFwiKSB9XFxuICB9LFxcbiAgLy8gU3dhcCB0aGUgdHdvIGNoYXJzIGxlZnQgYW5kIHJpZ2h0IG9mIGVhY2ggc2VsZWN0aW9uJ3MgaGVhZC5cXG4gIC8vIE1vdmUgY3Vyc29yIGJlaGluZCB0aGUgdHdvIHN3YXBwZWQgY2hhcmFjdGVycyBhZnRlcndhcmRzLlxcbiAgLy9cXG4gIC8vIERvZXNuJ3QgY29uc2lkZXIgbGluZSBmZWVkcyBhIGNoYXJhY3Rlci5cXG4gIC8vIERvZXNuJ3Qgc2NhbiBtb3JlIHRoYW4gb25lIGxpbmUgYWJvdmUgdG8gZmluZCBhIGNoYXJhY3Rlci5cXG4gIC8vIERvZXNuJ3QgZG8gYW55dGhpbmcgb24gYW4gZW1wdHkgbGluZS5cXG4gIC8vIERvZXNuJ3QgZG8gYW55dGhpbmcgd2l0aCBub24tZW1wdHkgc2VsZWN0aW9ucy5cXG4gIHRyYW5zcG9zZUNoYXJzOiBmdW5jdGlvbiAoY20pIHsgcmV0dXJuIHJ1bkluT3AoY20sIGZ1bmN0aW9uICgpIHtcXG4gICAgdmFyIHJhbmdlcyA9IGNtLmxpc3RTZWxlY3Rpb25zKCksIG5ld1NlbCA9IFtdXFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmFuZ2VzLmxlbmd0aDsgaSsrKSB7XFxuICAgICAgaWYgKCFyYW5nZXNbaV0uZW1wdHkoKSkgeyBjb250aW51ZSB9XFxuICAgICAgdmFyIGN1ciA9IHJhbmdlc1tpXS5oZWFkLCBsaW5lID0gZ2V0TGluZShjbS5kb2MsIGN1ci5saW5lKS50ZXh0XFxuICAgICAgaWYgKGxpbmUpIHtcXG4gICAgICAgIGlmIChjdXIuY2ggPT0gbGluZS5sZW5ndGgpIHsgY3VyID0gbmV3IFBvcyhjdXIubGluZSwgY3VyLmNoIC0gMSkgfVxcbiAgICAgICAgaWYgKGN1ci5jaCA+IDApIHtcXG4gICAgICAgICAgY3VyID0gbmV3IFBvcyhjdXIubGluZSwgY3VyLmNoICsgMSlcXG4gICAgICAgICAgY20ucmVwbGFjZVJhbmdlKGxpbmUuY2hhckF0KGN1ci5jaCAtIDEpICsgbGluZS5jaGFyQXQoY3VyLmNoIC0gMiksXFxuICAgICAgICAgICAgICAgICAgICAgICAgICBQb3MoY3VyLmxpbmUsIGN1ci5jaCAtIDIpLCBjdXIsIFxcXCIrdHJhbnNwb3NlXFxcIilcXG4gICAgICAgIH0gZWxzZSBpZiAoY3VyLmxpbmUgPiBjbS5kb2MuZmlyc3QpIHtcXG4gICAgICAgICAgdmFyIHByZXYgPSBnZXRMaW5lKGNtLmRvYywgY3VyLmxpbmUgLSAxKS50ZXh0XFxuICAgICAgICAgIGlmIChwcmV2KSB7XFxuICAgICAgICAgICAgY3VyID0gbmV3IFBvcyhjdXIubGluZSwgMSlcXG4gICAgICAgICAgICBjbS5yZXBsYWNlUmFuZ2UobGluZS5jaGFyQXQoMCkgKyBjbS5kb2MubGluZVNlcGFyYXRvcigpICtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJldi5jaGFyQXQocHJldi5sZW5ndGggLSAxKSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgUG9zKGN1ci5saW5lIC0gMSwgcHJldi5sZW5ndGggLSAxKSwgY3VyLCBcXFwiK3RyYW5zcG9zZVxcXCIpXFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgICAgbmV3U2VsLnB1c2gobmV3IFJhbmdlKGN1ciwgY3VyKSlcXG4gICAgfVxcbiAgICBjbS5zZXRTZWxlY3Rpb25zKG5ld1NlbClcXG4gIH0pOyB9LFxcbiAgbmV3bGluZUFuZEluZGVudDogZnVuY3Rpb24gKGNtKSB7IHJldHVybiBydW5Jbk9wKGNtLCBmdW5jdGlvbiAoKSB7XFxuICAgIHZhciBzZWxzID0gY20ubGlzdFNlbGVjdGlvbnMoKVxcbiAgICBmb3IgKHZhciBpID0gc2Vscy5sZW5ndGggLSAxOyBpID49IDA7IGktLSlcXG4gICAgICB7IGNtLnJlcGxhY2VSYW5nZShjbS5kb2MubGluZVNlcGFyYXRvcigpLCBzZWxzW2ldLmFuY2hvciwgc2Vsc1tpXS5oZWFkLCBcXFwiK2lucHV0XFxcIikgfVxcbiAgICBzZWxzID0gY20ubGlzdFNlbGVjdGlvbnMoKVxcbiAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBzZWxzLmxlbmd0aDsgaSQxKyspXFxuICAgICAgeyBjbS5pbmRlbnRMaW5lKHNlbHNbaSQxXS5mcm9tKCkubGluZSwgbnVsbCwgdHJ1ZSkgfVxcbiAgICBlbnN1cmVDdXJzb3JWaXNpYmxlKGNtKVxcbiAgfSk7IH0sXFxuICBvcGVuTGluZTogZnVuY3Rpb24gKGNtKSB7IHJldHVybiBjbS5yZXBsYWNlU2VsZWN0aW9uKFxcXCJcXFxcblxcXCIsIFxcXCJzdGFydFxcXCIpOyB9LFxcbiAgdG9nZ2xlT3ZlcndyaXRlOiBmdW5jdGlvbiAoY20pIHsgcmV0dXJuIGNtLnRvZ2dsZU92ZXJ3cml0ZSgpOyB9XFxufVxcblxcblxcbmZ1bmN0aW9uIGxpbmVTdGFydChjbSwgbGluZU4pIHtcXG4gIHZhciBsaW5lID0gZ2V0TGluZShjbS5kb2MsIGxpbmVOKVxcbiAgdmFyIHZpc3VhbCA9IHZpc3VhbExpbmUobGluZSlcXG4gIGlmICh2aXN1YWwgIT0gbGluZSkgeyBsaW5lTiA9IGxpbmVObyh2aXN1YWwpIH1cXG4gIHZhciBvcmRlciA9IGdldE9yZGVyKHZpc3VhbClcXG4gIHZhciBjaCA9ICFvcmRlciA/IDAgOiBvcmRlclswXS5sZXZlbCAlIDIgPyBsaW5lUmlnaHQodmlzdWFsKSA6IGxpbmVMZWZ0KHZpc3VhbClcXG4gIHJldHVybiBQb3MobGluZU4sIGNoKVxcbn1cXG5mdW5jdGlvbiBsaW5lRW5kKGNtLCBsaW5lTikge1xcbiAgdmFyIG1lcmdlZCwgbGluZSA9IGdldExpbmUoY20uZG9jLCBsaW5lTilcXG4gIHdoaWxlIChtZXJnZWQgPSBjb2xsYXBzZWRTcGFuQXRFbmQobGluZSkpIHtcXG4gICAgbGluZSA9IG1lcmdlZC5maW5kKDEsIHRydWUpLmxpbmVcXG4gICAgbGluZU4gPSBudWxsXFxuICB9XFxuICB2YXIgb3JkZXIgPSBnZXRPcmRlcihsaW5lKVxcbiAgdmFyIGNoID0gIW9yZGVyID8gbGluZS50ZXh0Lmxlbmd0aCA6IG9yZGVyWzBdLmxldmVsICUgMiA/IGxpbmVMZWZ0KGxpbmUpIDogbGluZVJpZ2h0KGxpbmUpXFxuICByZXR1cm4gUG9zKGxpbmVOID09IG51bGwgPyBsaW5lTm8obGluZSkgOiBsaW5lTiwgY2gpXFxufVxcbmZ1bmN0aW9uIGxpbmVTdGFydFNtYXJ0KGNtLCBwb3MpIHtcXG4gIHZhciBzdGFydCA9IGxpbmVTdGFydChjbSwgcG9zLmxpbmUpXFxuICB2YXIgbGluZSA9IGdldExpbmUoY20uZG9jLCBzdGFydC5saW5lKVxcbiAgdmFyIG9yZGVyID0gZ2V0T3JkZXIobGluZSlcXG4gIGlmICghb3JkZXIgfHwgb3JkZXJbMF0ubGV2ZWwgPT0gMCkge1xcbiAgICB2YXIgZmlyc3ROb25XUyA9IE1hdGgubWF4KDAsIGxpbmUudGV4dC5zZWFyY2goL1xcXFxTLykpXFxuICAgIHZhciBpbldTID0gcG9zLmxpbmUgPT0gc3RhcnQubGluZSAmJiBwb3MuY2ggPD0gZmlyc3ROb25XUyAmJiBwb3MuY2hcXG4gICAgcmV0dXJuIFBvcyhzdGFydC5saW5lLCBpbldTID8gMCA6IGZpcnN0Tm9uV1MpXFxuICB9XFxuICByZXR1cm4gc3RhcnRcXG59XFxuXFxuLy8gUnVuIGEgaGFuZGxlciB0aGF0IHdhcyBib3VuZCB0byBhIGtleS5cXG5mdW5jdGlvbiBkb0hhbmRsZUJpbmRpbmcoY20sIGJvdW5kLCBkcm9wU2hpZnQpIHtcXG4gIGlmICh0eXBlb2YgYm91bmQgPT0gXFxcInN0cmluZ1xcXCIpIHtcXG4gICAgYm91bmQgPSBjb21tYW5kc1tib3VuZF1cXG4gICAgaWYgKCFib3VuZCkgeyByZXR1cm4gZmFsc2UgfVxcbiAgfVxcbiAgLy8gRW5zdXJlIHByZXZpb3VzIGlucHV0IGhhcyBiZWVuIHJlYWQsIHNvIHRoYXQgdGhlIGhhbmRsZXIgc2VlcyBhXFxuICAvLyBjb25zaXN0ZW50IHZpZXcgb2YgdGhlIGRvY3VtZW50XFxuICBjbS5kaXNwbGF5LmlucHV0LmVuc3VyZVBvbGxlZCgpXFxuICB2YXIgcHJldlNoaWZ0ID0gY20uZGlzcGxheS5zaGlmdCwgZG9uZSA9IGZhbHNlXFxuICB0cnkge1xcbiAgICBpZiAoY20uaXNSZWFkT25seSgpKSB7IGNtLnN0YXRlLnN1cHByZXNzRWRpdHMgPSB0cnVlIH1cXG4gICAgaWYgKGRyb3BTaGlmdCkgeyBjbS5kaXNwbGF5LnNoaWZ0ID0gZmFsc2UgfVxcbiAgICBkb25lID0gYm91bmQoY20pICE9IFBhc3NcXG4gIH0gZmluYWxseSB7XFxuICAgIGNtLmRpc3BsYXkuc2hpZnQgPSBwcmV2U2hpZnRcXG4gICAgY20uc3RhdGUuc3VwcHJlc3NFZGl0cyA9IGZhbHNlXFxuICB9XFxuICByZXR1cm4gZG9uZVxcbn1cXG5cXG5mdW5jdGlvbiBsb29rdXBLZXlGb3JFZGl0b3IoY20sIG5hbWUsIGhhbmRsZSkge1xcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjbS5zdGF0ZS5rZXlNYXBzLmxlbmd0aDsgaSsrKSB7XFxuICAgIHZhciByZXN1bHQgPSBsb29rdXBLZXkobmFtZSwgY20uc3RhdGUua2V5TWFwc1tpXSwgaGFuZGxlLCBjbSlcXG4gICAgaWYgKHJlc3VsdCkgeyByZXR1cm4gcmVzdWx0IH1cXG4gIH1cXG4gIHJldHVybiAoY20ub3B0aW9ucy5leHRyYUtleXMgJiYgbG9va3VwS2V5KG5hbWUsIGNtLm9wdGlvbnMuZXh0cmFLZXlzLCBoYW5kbGUsIGNtKSlcXG4gICAgfHwgbG9va3VwS2V5KG5hbWUsIGNtLm9wdGlvbnMua2V5TWFwLCBoYW5kbGUsIGNtKVxcbn1cXG5cXG52YXIgc3RvcFNlcSA9IG5ldyBEZWxheWVkXFxuZnVuY3Rpb24gZGlzcGF0Y2hLZXkoY20sIG5hbWUsIGUsIGhhbmRsZSkge1xcbiAgdmFyIHNlcSA9IGNtLnN0YXRlLmtleVNlcVxcbiAgaWYgKHNlcSkge1xcbiAgICBpZiAoaXNNb2RpZmllcktleShuYW1lKSkgeyByZXR1cm4gXFxcImhhbmRsZWRcXFwiIH1cXG4gICAgc3RvcFNlcS5zZXQoNTAsIGZ1bmN0aW9uICgpIHtcXG4gICAgICBpZiAoY20uc3RhdGUua2V5U2VxID09IHNlcSkge1xcbiAgICAgICAgY20uc3RhdGUua2V5U2VxID0gbnVsbFxcbiAgICAgICAgY20uZGlzcGxheS5pbnB1dC5yZXNldCgpXFxuICAgICAgfVxcbiAgICB9KVxcbiAgICBuYW1lID0gc2VxICsgXFxcIiBcXFwiICsgbmFtZVxcbiAgfVxcbiAgdmFyIHJlc3VsdCA9IGxvb2t1cEtleUZvckVkaXRvcihjbSwgbmFtZSwgaGFuZGxlKVxcblxcbiAgaWYgKHJlc3VsdCA9PSBcXFwibXVsdGlcXFwiKVxcbiAgICB7IGNtLnN0YXRlLmtleVNlcSA9IG5hbWUgfVxcbiAgaWYgKHJlc3VsdCA9PSBcXFwiaGFuZGxlZFxcXCIpXFxuICAgIHsgc2lnbmFsTGF0ZXIoY20sIFxcXCJrZXlIYW5kbGVkXFxcIiwgY20sIG5hbWUsIGUpIH1cXG5cXG4gIGlmIChyZXN1bHQgPT0gXFxcImhhbmRsZWRcXFwiIHx8IHJlc3VsdCA9PSBcXFwibXVsdGlcXFwiKSB7XFxuICAgIGVfcHJldmVudERlZmF1bHQoZSlcXG4gICAgcmVzdGFydEJsaW5rKGNtKVxcbiAgfVxcblxcbiAgaWYgKHNlcSAmJiAhcmVzdWx0ICYmIC9cXFxcJyQvLnRlc3QobmFtZSkpIHtcXG4gICAgZV9wcmV2ZW50RGVmYXVsdChlKVxcbiAgICByZXR1cm4gdHJ1ZVxcbiAgfVxcbiAgcmV0dXJuICEhcmVzdWx0XFxufVxcblxcbi8vIEhhbmRsZSBhIGtleSBmcm9tIHRoZSBrZXlkb3duIGV2ZW50LlxcbmZ1bmN0aW9uIGhhbmRsZUtleUJpbmRpbmcoY20sIGUpIHtcXG4gIHZhciBuYW1lID0ga2V5TmFtZShlLCB0cnVlKVxcbiAgaWYgKCFuYW1lKSB7IHJldHVybiBmYWxzZSB9XFxuXFxuICBpZiAoZS5zaGlmdEtleSAmJiAhY20uc3RhdGUua2V5U2VxKSB7XFxuICAgIC8vIEZpcnN0IHRyeSB0byByZXNvbHZlIGZ1bGwgbmFtZSAoaW5jbHVkaW5nICdTaGlmdC0nKS4gRmFpbGluZ1xcbiAgICAvLyB0aGF0LCBzZWUgaWYgdGhlcmUgaXMgYSBjdXJzb3ItbW90aW9uIGNvbW1hbmQgKHN0YXJ0aW5nIHdpdGhcXG4gICAgLy8gJ2dvJykgYm91bmQgdG8gdGhlIGtleW5hbWUgd2l0aG91dCAnU2hpZnQtJy5cXG4gICAgcmV0dXJuIGRpc3BhdGNoS2V5KGNtLCBcXFwiU2hpZnQtXFxcIiArIG5hbWUsIGUsIGZ1bmN0aW9uIChiKSB7IHJldHVybiBkb0hhbmRsZUJpbmRpbmcoY20sIGIsIHRydWUpOyB9KVxcbiAgICAgICAgfHwgZGlzcGF0Y2hLZXkoY20sIG5hbWUsIGUsIGZ1bmN0aW9uIChiKSB7XFxuICAgICAgICAgICAgIGlmICh0eXBlb2YgYiA9PSBcXFwic3RyaW5nXFxcIiA/IC9eZ29bQS1aXS8udGVzdChiKSA6IGIubW90aW9uKVxcbiAgICAgICAgICAgICAgIHsgcmV0dXJuIGRvSGFuZGxlQmluZGluZyhjbSwgYikgfVxcbiAgICAgICAgICAgfSlcXG4gIH0gZWxzZSB7XFxuICAgIHJldHVybiBkaXNwYXRjaEtleShjbSwgbmFtZSwgZSwgZnVuY3Rpb24gKGIpIHsgcmV0dXJuIGRvSGFuZGxlQmluZGluZyhjbSwgYik7IH0pXFxuICB9XFxufVxcblxcbi8vIEhhbmRsZSBhIGtleSBmcm9tIHRoZSBrZXlwcmVzcyBldmVudFxcbmZ1bmN0aW9uIGhhbmRsZUNoYXJCaW5kaW5nKGNtLCBlLCBjaCkge1xcbiAgcmV0dXJuIGRpc3BhdGNoS2V5KGNtLCBcXFwiJ1xcXCIgKyBjaCArIFxcXCInXFxcIiwgZSwgZnVuY3Rpb24gKGIpIHsgcmV0dXJuIGRvSGFuZGxlQmluZGluZyhjbSwgYiwgdHJ1ZSk7IH0pXFxufVxcblxcbnZhciBsYXN0U3RvcHBlZEtleSA9IG51bGxcXG5mdW5jdGlvbiBvbktleURvd24oZSkge1xcbiAgdmFyIGNtID0gdGhpc1xcbiAgY20uY3VyT3AuZm9jdXMgPSBhY3RpdmVFbHQoKVxcbiAgaWYgKHNpZ25hbERPTUV2ZW50KGNtLCBlKSkgeyByZXR1cm4gfVxcbiAgLy8gSUUgZG9lcyBzdHJhbmdlIHRoaW5ncyB3aXRoIGVzY2FwZS5cXG4gIGlmIChpZSAmJiBpZV92ZXJzaW9uIDwgMTEgJiYgZS5rZXlDb2RlID09IDI3KSB7IGUucmV0dXJuVmFsdWUgPSBmYWxzZSB9XFxuICB2YXIgY29kZSA9IGUua2V5Q29kZVxcbiAgY20uZGlzcGxheS5zaGlmdCA9IGNvZGUgPT0gMTYgfHwgZS5zaGlmdEtleVxcbiAgdmFyIGhhbmRsZWQgPSBoYW5kbGVLZXlCaW5kaW5nKGNtLCBlKVxcbiAgaWYgKHByZXN0bykge1xcbiAgICBsYXN0U3RvcHBlZEtleSA9IGhhbmRsZWQgPyBjb2RlIDogbnVsbFxcbiAgICAvLyBPcGVyYSBoYXMgbm8gY3V0IGV2ZW50Li4uIHdlIHRyeSB0byBhdCBsZWFzdCBjYXRjaCB0aGUga2V5IGNvbWJvXFxuICAgIGlmICghaGFuZGxlZCAmJiBjb2RlID09IDg4ICYmICFoYXNDb3B5RXZlbnQgJiYgKG1hYyA/IGUubWV0YUtleSA6IGUuY3RybEtleSkpXFxuICAgICAgeyBjbS5yZXBsYWNlU2VsZWN0aW9uKFxcXCJcXFwiLCBudWxsLCBcXFwiY3V0XFxcIikgfVxcbiAgfVxcblxcbiAgLy8gVHVybiBtb3VzZSBpbnRvIGNyb3NzaGFpciB3aGVuIEFsdCBpcyBoZWxkIG9uIE1hYy5cXG4gIGlmIChjb2RlID09IDE4ICYmICEvXFxcXGJDb2RlTWlycm9yLWNyb3NzaGFpclxcXFxiLy50ZXN0KGNtLmRpc3BsYXkubGluZURpdi5jbGFzc05hbWUpKVxcbiAgICB7IHNob3dDcm9zc0hhaXIoY20pIH1cXG59XFxuXFxuZnVuY3Rpb24gc2hvd0Nyb3NzSGFpcihjbSkge1xcbiAgdmFyIGxpbmVEaXYgPSBjbS5kaXNwbGF5LmxpbmVEaXZcXG4gIGFkZENsYXNzKGxpbmVEaXYsIFxcXCJDb2RlTWlycm9yLWNyb3NzaGFpclxcXCIpXFxuXFxuICBmdW5jdGlvbiB1cChlKSB7XFxuICAgIGlmIChlLmtleUNvZGUgPT0gMTggfHwgIWUuYWx0S2V5KSB7XFxuICAgICAgcm1DbGFzcyhsaW5lRGl2LCBcXFwiQ29kZU1pcnJvci1jcm9zc2hhaXJcXFwiKVxcbiAgICAgIG9mZihkb2N1bWVudCwgXFxcImtleXVwXFxcIiwgdXApXFxuICAgICAgb2ZmKGRvY3VtZW50LCBcXFwibW91c2VvdmVyXFxcIiwgdXApXFxuICAgIH1cXG4gIH1cXG4gIG9uKGRvY3VtZW50LCBcXFwia2V5dXBcXFwiLCB1cClcXG4gIG9uKGRvY3VtZW50LCBcXFwibW91c2VvdmVyXFxcIiwgdXApXFxufVxcblxcbmZ1bmN0aW9uIG9uS2V5VXAoZSkge1xcbiAgaWYgKGUua2V5Q29kZSA9PSAxNikgeyB0aGlzLmRvYy5zZWwuc2hpZnQgPSBmYWxzZSB9XFxuICBzaWduYWxET01FdmVudCh0aGlzLCBlKVxcbn1cXG5cXG5mdW5jdGlvbiBvbktleVByZXNzKGUpIHtcXG4gIHZhciBjbSA9IHRoaXNcXG4gIGlmIChldmVudEluV2lkZ2V0KGNtLmRpc3BsYXksIGUpIHx8IHNpZ25hbERPTUV2ZW50KGNtLCBlKSB8fCBlLmN0cmxLZXkgJiYgIWUuYWx0S2V5IHx8IG1hYyAmJiBlLm1ldGFLZXkpIHsgcmV0dXJuIH1cXG4gIHZhciBrZXlDb2RlID0gZS5rZXlDb2RlLCBjaGFyQ29kZSA9IGUuY2hhckNvZGVcXG4gIGlmIChwcmVzdG8gJiYga2V5Q29kZSA9PSBsYXN0U3RvcHBlZEtleSkge2xhc3RTdG9wcGVkS2V5ID0gbnVsbDsgZV9wcmV2ZW50RGVmYXVsdChlKTsgcmV0dXJufVxcbiAgaWYgKChwcmVzdG8gJiYgKCFlLndoaWNoIHx8IGUud2hpY2ggPCAxMCkpICYmIGhhbmRsZUtleUJpbmRpbmcoY20sIGUpKSB7IHJldHVybiB9XFxuICB2YXIgY2ggPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNoYXJDb2RlID09IG51bGwgPyBrZXlDb2RlIDogY2hhckNvZGUpXFxuICAvLyBTb21lIGJyb3dzZXJzIGZpcmUga2V5cHJlc3MgZXZlbnRzIGZvciBiYWNrc3BhY2VcXG4gIGlmIChjaCA9PSBcXFwiXFxcXHgwOFxcXCIpIHsgcmV0dXJuIH1cXG4gIGlmIChoYW5kbGVDaGFyQmluZGluZyhjbSwgZSwgY2gpKSB7IHJldHVybiB9XFxuICBjbS5kaXNwbGF5LmlucHV0Lm9uS2V5UHJlc3MoZSlcXG59XFxuXFxuLy8gQSBtb3VzZSBkb3duIGNhbiBiZSBhIHNpbmdsZSBjbGljaywgZG91YmxlIGNsaWNrLCB0cmlwbGUgY2xpY2ssXFxuLy8gc3RhcnQgb2Ygc2VsZWN0aW9uIGRyYWcsIHN0YXJ0IG9mIHRleHQgZHJhZywgbmV3IGN1cnNvclxcbi8vIChjdHJsLWNsaWNrKSwgcmVjdGFuZ2xlIGRyYWcgKGFsdC1kcmFnKSwgb3IgeHdpblxcbi8vIG1pZGRsZS1jbGljay1wYXN0ZS4gT3IgaXQgbWlnaHQgYmUgYSBjbGljayBvbiBzb21ldGhpbmcgd2Ugc2hvdWxkXFxuLy8gbm90IGludGVyZmVyZSB3aXRoLCBzdWNoIGFzIGEgc2Nyb2xsYmFyIG9yIHdpZGdldC5cXG5mdW5jdGlvbiBvbk1vdXNlRG93bihlKSB7XFxuICB2YXIgY20gPSB0aGlzLCBkaXNwbGF5ID0gY20uZGlzcGxheVxcbiAgaWYgKHNpZ25hbERPTUV2ZW50KGNtLCBlKSB8fCBkaXNwbGF5LmFjdGl2ZVRvdWNoICYmIGRpc3BsYXkuaW5wdXQuc3VwcG9ydHNUb3VjaCgpKSB7IHJldHVybiB9XFxuICBkaXNwbGF5LmlucHV0LmVuc3VyZVBvbGxlZCgpXFxuICBkaXNwbGF5LnNoaWZ0ID0gZS5zaGlmdEtleVxcblxcbiAgaWYgKGV2ZW50SW5XaWRnZXQoZGlzcGxheSwgZSkpIHtcXG4gICAgaWYgKCF3ZWJraXQpIHtcXG4gICAgICAvLyBCcmllZmx5IHR1cm4gb2ZmIGRyYWdnYWJpbGl0eSwgdG8gYWxsb3cgd2lkZ2V0cyB0byBkb1xcbiAgICAgIC8vIG5vcm1hbCBkcmFnZ2luZyB0aGluZ3MuXFxuICAgICAgZGlzcGxheS5zY3JvbGxlci5kcmFnZ2FibGUgPSBmYWxzZVxcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyByZXR1cm4gZGlzcGxheS5zY3JvbGxlci5kcmFnZ2FibGUgPSB0cnVlOyB9LCAxMDApXFxuICAgIH1cXG4gICAgcmV0dXJuXFxuICB9XFxuICBpZiAoY2xpY2tJbkd1dHRlcihjbSwgZSkpIHsgcmV0dXJuIH1cXG4gIHZhciBzdGFydCA9IHBvc0Zyb21Nb3VzZShjbSwgZSlcXG4gIHdpbmRvdy5mb2N1cygpXFxuXFxuICBzd2l0Y2ggKGVfYnV0dG9uKGUpKSB7XFxuICBjYXNlIDE6XFxuICAgIC8vICMzMjYxOiBtYWtlIHN1cmUsIHRoYXQgd2UncmUgbm90IHN0YXJ0aW5nIGEgc2Vjb25kIHNlbGVjdGlvblxcbiAgICBpZiAoY20uc3RhdGUuc2VsZWN0aW5nVGV4dClcXG4gICAgICB7IGNtLnN0YXRlLnNlbGVjdGluZ1RleHQoZSkgfVxcbiAgICBlbHNlIGlmIChzdGFydClcXG4gICAgICB7IGxlZnRCdXR0b25Eb3duKGNtLCBlLCBzdGFydCkgfVxcbiAgICBlbHNlIGlmIChlX3RhcmdldChlKSA9PSBkaXNwbGF5LnNjcm9sbGVyKVxcbiAgICAgIHsgZV9wcmV2ZW50RGVmYXVsdChlKSB9XFxuICAgIGJyZWFrXFxuICBjYXNlIDI6XFxuICAgIGlmICh3ZWJraXQpIHsgY20uc3RhdGUubGFzdE1pZGRsZURvd24gPSArbmV3IERhdGUgfVxcbiAgICBpZiAoc3RhcnQpIHsgZXh0ZW5kU2VsZWN0aW9uKGNtLmRvYywgc3RhcnQpIH1cXG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHJldHVybiBkaXNwbGF5LmlucHV0LmZvY3VzKCk7IH0sIDIwKVxcbiAgICBlX3ByZXZlbnREZWZhdWx0KGUpXFxuICAgIGJyZWFrXFxuICBjYXNlIDM6XFxuICAgIGlmIChjYXB0dXJlUmlnaHRDbGljaykgeyBvbkNvbnRleHRNZW51KGNtLCBlKSB9XFxuICAgIGVsc2UgeyBkZWxheUJsdXJFdmVudChjbSkgfVxcbiAgICBicmVha1xcbiAgfVxcbn1cXG5cXG52YXIgbGFzdENsaWNrO1xcbnZhciBsYXN0RG91YmxlQ2xpY2s7XFxuZnVuY3Rpb24gbGVmdEJ1dHRvbkRvd24oY20sIGUsIHN0YXJ0KSB7XFxuICBpZiAoaWUpIHsgc2V0VGltZW91dChiaW5kKGVuc3VyZUZvY3VzLCBjbSksIDApIH1cXG4gIGVsc2UgeyBjbS5jdXJPcC5mb2N1cyA9IGFjdGl2ZUVsdCgpIH1cXG5cXG4gIHZhciBub3cgPSArbmV3IERhdGUsIHR5cGVcXG4gIGlmIChsYXN0RG91YmxlQ2xpY2sgJiYgbGFzdERvdWJsZUNsaWNrLnRpbWUgPiBub3cgLSA0MDAgJiYgY21wKGxhc3REb3VibGVDbGljay5wb3MsIHN0YXJ0KSA9PSAwKSB7XFxuICAgIHR5cGUgPSBcXFwidHJpcGxlXFxcIlxcbiAgfSBlbHNlIGlmIChsYXN0Q2xpY2sgJiYgbGFzdENsaWNrLnRpbWUgPiBub3cgLSA0MDAgJiYgY21wKGxhc3RDbGljay5wb3MsIHN0YXJ0KSA9PSAwKSB7XFxuICAgIHR5cGUgPSBcXFwiZG91YmxlXFxcIlxcbiAgICBsYXN0RG91YmxlQ2xpY2sgPSB7dGltZTogbm93LCBwb3M6IHN0YXJ0fVxcbiAgfSBlbHNlIHtcXG4gICAgdHlwZSA9IFxcXCJzaW5nbGVcXFwiXFxuICAgIGxhc3RDbGljayA9IHt0aW1lOiBub3csIHBvczogc3RhcnR9XFxuICB9XFxuXFxuICB2YXIgc2VsID0gY20uZG9jLnNlbCwgbW9kaWZpZXIgPSBtYWMgPyBlLm1ldGFLZXkgOiBlLmN0cmxLZXksIGNvbnRhaW5lZFxcbiAgaWYgKGNtLm9wdGlvbnMuZHJhZ0Ryb3AgJiYgZHJhZ0FuZERyb3AgJiYgIWNtLmlzUmVhZE9ubHkoKSAmJlxcbiAgICAgIHR5cGUgPT0gXFxcInNpbmdsZVxcXCIgJiYgKGNvbnRhaW5lZCA9IHNlbC5jb250YWlucyhzdGFydCkpID4gLTEgJiZcXG4gICAgICAoY21wKChjb250YWluZWQgPSBzZWwucmFuZ2VzW2NvbnRhaW5lZF0pLmZyb20oKSwgc3RhcnQpIDwgMCB8fCBzdGFydC54UmVsID4gMCkgJiZcXG4gICAgICAoY21wKGNvbnRhaW5lZC50bygpLCBzdGFydCkgPiAwIHx8IHN0YXJ0LnhSZWwgPCAwKSlcXG4gICAgeyBsZWZ0QnV0dG9uU3RhcnREcmFnKGNtLCBlLCBzdGFydCwgbW9kaWZpZXIpIH1cXG4gIGVsc2VcXG4gICAgeyBsZWZ0QnV0dG9uU2VsZWN0KGNtLCBlLCBzdGFydCwgdHlwZSwgbW9kaWZpZXIpIH1cXG59XFxuXFxuLy8gU3RhcnQgYSB0ZXh0IGRyYWcuIFdoZW4gaXQgZW5kcywgc2VlIGlmIGFueSBkcmFnZ2luZyBhY3R1YWxseVxcbi8vIGhhcHBlbiwgYW5kIHRyZWF0IGFzIGEgY2xpY2sgaWYgaXQgZGlkbid0LlxcbmZ1bmN0aW9uIGxlZnRCdXR0b25TdGFydERyYWcoY20sIGUsIHN0YXJ0LCBtb2RpZmllcikge1xcbiAgdmFyIGRpc3BsYXkgPSBjbS5kaXNwbGF5LCBzdGFydFRpbWUgPSArbmV3IERhdGVcXG4gIHZhciBkcmFnRW5kID0gb3BlcmF0aW9uKGNtLCBmdW5jdGlvbiAoZTIpIHtcXG4gICAgaWYgKHdlYmtpdCkgeyBkaXNwbGF5LnNjcm9sbGVyLmRyYWdnYWJsZSA9IGZhbHNlIH1cXG4gICAgY20uc3RhdGUuZHJhZ2dpbmdUZXh0ID0gZmFsc2VcXG4gICAgb2ZmKGRvY3VtZW50LCBcXFwibW91c2V1cFxcXCIsIGRyYWdFbmQpXFxuICAgIG9mZihkaXNwbGF5LnNjcm9sbGVyLCBcXFwiZHJvcFxcXCIsIGRyYWdFbmQpXFxuICAgIGlmIChNYXRoLmFicyhlLmNsaWVudFggLSBlMi5jbGllbnRYKSArIE1hdGguYWJzKGUuY2xpZW50WSAtIGUyLmNsaWVudFkpIDwgMTApIHtcXG4gICAgICBlX3ByZXZlbnREZWZhdWx0KGUyKVxcbiAgICAgIGlmICghbW9kaWZpZXIgJiYgK25ldyBEYXRlIC0gMjAwIDwgc3RhcnRUaW1lKVxcbiAgICAgICAgeyBleHRlbmRTZWxlY3Rpb24oY20uZG9jLCBzdGFydCkgfVxcbiAgICAgIC8vIFdvcmsgYXJvdW5kIHVuZXhwbGFpbmFibGUgZm9jdXMgcHJvYmxlbSBpbiBJRTkgKCMyMTI3KSBhbmQgQ2hyb21lICgjMzA4MSlcXG4gICAgICBpZiAod2Via2l0IHx8IGllICYmIGllX3ZlcnNpb24gPT0gOSlcXG4gICAgICAgIHsgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7ZG9jdW1lbnQuYm9keS5mb2N1cygpOyBkaXNwbGF5LmlucHV0LmZvY3VzKCl9LCAyMCkgfVxcbiAgICAgIGVsc2VcXG4gICAgICAgIHsgZGlzcGxheS5pbnB1dC5mb2N1cygpIH1cXG4gICAgfVxcbiAgfSlcXG4gIC8vIExldCB0aGUgZHJhZyBoYW5kbGVyIGhhbmRsZSB0aGlzLlxcbiAgaWYgKHdlYmtpdCkgeyBkaXNwbGF5LnNjcm9sbGVyLmRyYWdnYWJsZSA9IHRydWUgfVxcbiAgY20uc3RhdGUuZHJhZ2dpbmdUZXh0ID0gZHJhZ0VuZFxcbiAgZHJhZ0VuZC5jb3B5ID0gbWFjID8gZS5hbHRLZXkgOiBlLmN0cmxLZXlcXG4gIC8vIElFJ3MgYXBwcm9hY2ggdG8gZHJhZ2dhYmxlXFxuICBpZiAoZGlzcGxheS5zY3JvbGxlci5kcmFnRHJvcCkgeyBkaXNwbGF5LnNjcm9sbGVyLmRyYWdEcm9wKCkgfVxcbiAgb24oZG9jdW1lbnQsIFxcXCJtb3VzZXVwXFxcIiwgZHJhZ0VuZClcXG4gIG9uKGRpc3BsYXkuc2Nyb2xsZXIsIFxcXCJkcm9wXFxcIiwgZHJhZ0VuZClcXG59XFxuXFxuLy8gTm9ybWFsIHNlbGVjdGlvbiwgYXMgb3Bwb3NlZCB0byB0ZXh0IGRyYWdnaW5nLlxcbmZ1bmN0aW9uIGxlZnRCdXR0b25TZWxlY3QoY20sIGUsIHN0YXJ0LCB0eXBlLCBhZGROZXcpIHtcXG4gIHZhciBkaXNwbGF5ID0gY20uZGlzcGxheSwgZG9jID0gY20uZG9jXFxuICBlX3ByZXZlbnREZWZhdWx0KGUpXFxuXFxuICB2YXIgb3VyUmFuZ2UsIG91ckluZGV4LCBzdGFydFNlbCA9IGRvYy5zZWwsIHJhbmdlcyA9IHN0YXJ0U2VsLnJhbmdlc1xcbiAgaWYgKGFkZE5ldyAmJiAhZS5zaGlmdEtleSkge1xcbiAgICBvdXJJbmRleCA9IGRvYy5zZWwuY29udGFpbnMoc3RhcnQpXFxuICAgIGlmIChvdXJJbmRleCA+IC0xKVxcbiAgICAgIHsgb3VyUmFuZ2UgPSByYW5nZXNbb3VySW5kZXhdIH1cXG4gICAgZWxzZVxcbiAgICAgIHsgb3VyUmFuZ2UgPSBuZXcgUmFuZ2Uoc3RhcnQsIHN0YXJ0KSB9XFxuICB9IGVsc2Uge1xcbiAgICBvdXJSYW5nZSA9IGRvYy5zZWwucHJpbWFyeSgpXFxuICAgIG91ckluZGV4ID0gZG9jLnNlbC5wcmltSW5kZXhcXG4gIH1cXG5cXG4gIGlmIChjaHJvbWVPUyA/IGUuc2hpZnRLZXkgJiYgZS5tZXRhS2V5IDogZS5hbHRLZXkpIHtcXG4gICAgdHlwZSA9IFxcXCJyZWN0XFxcIlxcbiAgICBpZiAoIWFkZE5ldykgeyBvdXJSYW5nZSA9IG5ldyBSYW5nZShzdGFydCwgc3RhcnQpIH1cXG4gICAgc3RhcnQgPSBwb3NGcm9tTW91c2UoY20sIGUsIHRydWUsIHRydWUpXFxuICAgIG91ckluZGV4ID0gLTFcXG4gIH0gZWxzZSBpZiAodHlwZSA9PSBcXFwiZG91YmxlXFxcIikge1xcbiAgICB2YXIgd29yZCA9IGNtLmZpbmRXb3JkQXQoc3RhcnQpXFxuICAgIGlmIChjbS5kaXNwbGF5LnNoaWZ0IHx8IGRvYy5leHRlbmQpXFxuICAgICAgeyBvdXJSYW5nZSA9IGV4dGVuZFJhbmdlKGRvYywgb3VyUmFuZ2UsIHdvcmQuYW5jaG9yLCB3b3JkLmhlYWQpIH1cXG4gICAgZWxzZVxcbiAgICAgIHsgb3VyUmFuZ2UgPSB3b3JkIH1cXG4gIH0gZWxzZSBpZiAodHlwZSA9PSBcXFwidHJpcGxlXFxcIikge1xcbiAgICB2YXIgbGluZSA9IG5ldyBSYW5nZShQb3Moc3RhcnQubGluZSwgMCksIGNsaXBQb3MoZG9jLCBQb3Moc3RhcnQubGluZSArIDEsIDApKSlcXG4gICAgaWYgKGNtLmRpc3BsYXkuc2hpZnQgfHwgZG9jLmV4dGVuZClcXG4gICAgICB7IG91clJhbmdlID0gZXh0ZW5kUmFuZ2UoZG9jLCBvdXJSYW5nZSwgbGluZS5hbmNob3IsIGxpbmUuaGVhZCkgfVxcbiAgICBlbHNlXFxuICAgICAgeyBvdXJSYW5nZSA9IGxpbmUgfVxcbiAgfSBlbHNlIHtcXG4gICAgb3VyUmFuZ2UgPSBleHRlbmRSYW5nZShkb2MsIG91clJhbmdlLCBzdGFydClcXG4gIH1cXG5cXG4gIGlmICghYWRkTmV3KSB7XFxuICAgIG91ckluZGV4ID0gMFxcbiAgICBzZXRTZWxlY3Rpb24oZG9jLCBuZXcgU2VsZWN0aW9uKFtvdXJSYW5nZV0sIDApLCBzZWxfbW91c2UpXFxuICAgIHN0YXJ0U2VsID0gZG9jLnNlbFxcbiAgfSBlbHNlIGlmIChvdXJJbmRleCA9PSAtMSkge1xcbiAgICBvdXJJbmRleCA9IHJhbmdlcy5sZW5ndGhcXG4gICAgc2V0U2VsZWN0aW9uKGRvYywgbm9ybWFsaXplU2VsZWN0aW9uKHJhbmdlcy5jb25jYXQoW291clJhbmdlXSksIG91ckluZGV4KSxcXG4gICAgICAgICAgICAgICAgIHtzY3JvbGw6IGZhbHNlLCBvcmlnaW46IFxcXCIqbW91c2VcXFwifSlcXG4gIH0gZWxzZSBpZiAocmFuZ2VzLmxlbmd0aCA+IDEgJiYgcmFuZ2VzW291ckluZGV4XS5lbXB0eSgpICYmIHR5cGUgPT0gXFxcInNpbmdsZVxcXCIgJiYgIWUuc2hpZnRLZXkpIHtcXG4gICAgc2V0U2VsZWN0aW9uKGRvYywgbm9ybWFsaXplU2VsZWN0aW9uKHJhbmdlcy5zbGljZSgwLCBvdXJJbmRleCkuY29uY2F0KHJhbmdlcy5zbGljZShvdXJJbmRleCArIDEpKSwgMCksXFxuICAgICAgICAgICAgICAgICB7c2Nyb2xsOiBmYWxzZSwgb3JpZ2luOiBcXFwiKm1vdXNlXFxcIn0pXFxuICAgIHN0YXJ0U2VsID0gZG9jLnNlbFxcbiAgfSBlbHNlIHtcXG4gICAgcmVwbGFjZU9uZVNlbGVjdGlvbihkb2MsIG91ckluZGV4LCBvdXJSYW5nZSwgc2VsX21vdXNlKVxcbiAgfVxcblxcbiAgdmFyIGxhc3RQb3MgPSBzdGFydFxcbiAgZnVuY3Rpb24gZXh0ZW5kVG8ocG9zKSB7XFxuICAgIGlmIChjbXAobGFzdFBvcywgcG9zKSA9PSAwKSB7IHJldHVybiB9XFxuICAgIGxhc3RQb3MgPSBwb3NcXG5cXG4gICAgaWYgKHR5cGUgPT0gXFxcInJlY3RcXFwiKSB7XFxuICAgICAgdmFyIHJhbmdlcyA9IFtdLCB0YWJTaXplID0gY20ub3B0aW9ucy50YWJTaXplXFxuICAgICAgdmFyIHN0YXJ0Q29sID0gY291bnRDb2x1bW4oZ2V0TGluZShkb2MsIHN0YXJ0LmxpbmUpLnRleHQsIHN0YXJ0LmNoLCB0YWJTaXplKVxcbiAgICAgIHZhciBwb3NDb2wgPSBjb3VudENvbHVtbihnZXRMaW5lKGRvYywgcG9zLmxpbmUpLnRleHQsIHBvcy5jaCwgdGFiU2l6ZSlcXG4gICAgICB2YXIgbGVmdCA9IE1hdGgubWluKHN0YXJ0Q29sLCBwb3NDb2wpLCByaWdodCA9IE1hdGgubWF4KHN0YXJ0Q29sLCBwb3NDb2wpXFxuICAgICAgZm9yICh2YXIgbGluZSA9IE1hdGgubWluKHN0YXJ0LmxpbmUsIHBvcy5saW5lKSwgZW5kID0gTWF0aC5taW4oY20ubGFzdExpbmUoKSwgTWF0aC5tYXgoc3RhcnQubGluZSwgcG9zLmxpbmUpKTtcXG4gICAgICAgICAgIGxpbmUgPD0gZW5kOyBsaW5lKyspIHtcXG4gICAgICAgIHZhciB0ZXh0ID0gZ2V0TGluZShkb2MsIGxpbmUpLnRleHQsIGxlZnRQb3MgPSBmaW5kQ29sdW1uKHRleHQsIGxlZnQsIHRhYlNpemUpXFxuICAgICAgICBpZiAobGVmdCA9PSByaWdodClcXG4gICAgICAgICAgeyByYW5nZXMucHVzaChuZXcgUmFuZ2UoUG9zKGxpbmUsIGxlZnRQb3MpLCBQb3MobGluZSwgbGVmdFBvcykpKSB9XFxuICAgICAgICBlbHNlIGlmICh0ZXh0Lmxlbmd0aCA+IGxlZnRQb3MpXFxuICAgICAgICAgIHsgcmFuZ2VzLnB1c2gobmV3IFJhbmdlKFBvcyhsaW5lLCBsZWZ0UG9zKSwgUG9zKGxpbmUsIGZpbmRDb2x1bW4odGV4dCwgcmlnaHQsIHRhYlNpemUpKSkpIH1cXG4gICAgICB9XFxuICAgICAgaWYgKCFyYW5nZXMubGVuZ3RoKSB7IHJhbmdlcy5wdXNoKG5ldyBSYW5nZShzdGFydCwgc3RhcnQpKSB9XFxuICAgICAgc2V0U2VsZWN0aW9uKGRvYywgbm9ybWFsaXplU2VsZWN0aW9uKHN0YXJ0U2VsLnJhbmdlcy5zbGljZSgwLCBvdXJJbmRleCkuY29uY2F0KHJhbmdlcyksIG91ckluZGV4KSxcXG4gICAgICAgICAgICAgICAgICAge29yaWdpbjogXFxcIiptb3VzZVxcXCIsIHNjcm9sbDogZmFsc2V9KVxcbiAgICAgIGNtLnNjcm9sbEludG9WaWV3KHBvcylcXG4gICAgfSBlbHNlIHtcXG4gICAgICB2YXIgb2xkUmFuZ2UgPSBvdXJSYW5nZVxcbiAgICAgIHZhciBhbmNob3IgPSBvbGRSYW5nZS5hbmNob3IsIGhlYWQgPSBwb3NcXG4gICAgICBpZiAodHlwZSAhPSBcXFwic2luZ2xlXFxcIikge1xcbiAgICAgICAgdmFyIHJhbmdlXFxuICAgICAgICBpZiAodHlwZSA9PSBcXFwiZG91YmxlXFxcIilcXG4gICAgICAgICAgeyByYW5nZSA9IGNtLmZpbmRXb3JkQXQocG9zKSB9XFxuICAgICAgICBlbHNlXFxuICAgICAgICAgIHsgcmFuZ2UgPSBuZXcgUmFuZ2UoUG9zKHBvcy5saW5lLCAwKSwgY2xpcFBvcyhkb2MsIFBvcyhwb3MubGluZSArIDEsIDApKSkgfVxcbiAgICAgICAgaWYgKGNtcChyYW5nZS5hbmNob3IsIGFuY2hvcikgPiAwKSB7XFxuICAgICAgICAgIGhlYWQgPSByYW5nZS5oZWFkXFxuICAgICAgICAgIGFuY2hvciA9IG1pblBvcyhvbGRSYW5nZS5mcm9tKCksIHJhbmdlLmFuY2hvcilcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIGhlYWQgPSByYW5nZS5hbmNob3JcXG4gICAgICAgICAgYW5jaG9yID0gbWF4UG9zKG9sZFJhbmdlLnRvKCksIHJhbmdlLmhlYWQpXFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICAgIHZhciByYW5nZXMkMSA9IHN0YXJ0U2VsLnJhbmdlcy5zbGljZSgwKVxcbiAgICAgIHJhbmdlcyQxW291ckluZGV4XSA9IG5ldyBSYW5nZShjbGlwUG9zKGRvYywgYW5jaG9yKSwgaGVhZClcXG4gICAgICBzZXRTZWxlY3Rpb24oZG9jLCBub3JtYWxpemVTZWxlY3Rpb24ocmFuZ2VzJDEsIG91ckluZGV4KSwgc2VsX21vdXNlKVxcbiAgICB9XFxuICB9XFxuXFxuICB2YXIgZWRpdG9yU2l6ZSA9IGRpc3BsYXkud3JhcHBlci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxcbiAgLy8gVXNlZCB0byBlbnN1cmUgdGltZW91dCByZS10cmllcyBkb24ndCBmaXJlIHdoZW4gYW5vdGhlciBleHRlbmRcXG4gIC8vIGhhcHBlbmVkIGluIHRoZSBtZWFudGltZSAoY2xlYXJUaW1lb3V0IGlzbid0IHJlbGlhYmxlIC0tIGF0XFxuICAvLyBsZWFzdCBvbiBDaHJvbWUsIHRoZSB0aW1lb3V0cyBzdGlsbCBoYXBwZW4gZXZlbiB3aGVuIGNsZWFyZWQsXFxuICAvLyBpZiB0aGUgY2xlYXIgaGFwcGVucyBhZnRlciB0aGVpciBzY2hlZHVsZWQgZmlyaW5nIHRpbWUpLlxcbiAgdmFyIGNvdW50ZXIgPSAwXFxuXFxuICBmdW5jdGlvbiBleHRlbmQoZSkge1xcbiAgICB2YXIgY3VyQ291bnQgPSArK2NvdW50ZXJcXG4gICAgdmFyIGN1ciA9IHBvc0Zyb21Nb3VzZShjbSwgZSwgdHJ1ZSwgdHlwZSA9PSBcXFwicmVjdFxcXCIpXFxuICAgIGlmICghY3VyKSB7IHJldHVybiB9XFxuICAgIGlmIChjbXAoY3VyLCBsYXN0UG9zKSAhPSAwKSB7XFxuICAgICAgY20uY3VyT3AuZm9jdXMgPSBhY3RpdmVFbHQoKVxcbiAgICAgIGV4dGVuZFRvKGN1cilcXG4gICAgICB2YXIgdmlzaWJsZSA9IHZpc2libGVMaW5lcyhkaXNwbGF5LCBkb2MpXFxuICAgICAgaWYgKGN1ci5saW5lID49IHZpc2libGUudG8gfHwgY3VyLmxpbmUgPCB2aXNpYmxlLmZyb20pXFxuICAgICAgICB7IHNldFRpbWVvdXQob3BlcmF0aW9uKGNtLCBmdW5jdGlvbiAoKSB7aWYgKGNvdW50ZXIgPT0gY3VyQ291bnQpIHsgZXh0ZW5kKGUpIH19KSwgMTUwKSB9XFxuICAgIH0gZWxzZSB7XFxuICAgICAgdmFyIG91dHNpZGUgPSBlLmNsaWVudFkgPCBlZGl0b3JTaXplLnRvcCA/IC0yMCA6IGUuY2xpZW50WSA+IGVkaXRvclNpemUuYm90dG9tID8gMjAgOiAwXFxuICAgICAgaWYgKG91dHNpZGUpIHsgc2V0VGltZW91dChvcGVyYXRpb24oY20sIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIGlmIChjb3VudGVyICE9IGN1ckNvdW50KSB7IHJldHVybiB9XFxuICAgICAgICBkaXNwbGF5LnNjcm9sbGVyLnNjcm9sbFRvcCArPSBvdXRzaWRlXFxuICAgICAgICBleHRlbmQoZSlcXG4gICAgICB9KSwgNTApIH1cXG4gICAgfVxcbiAgfVxcblxcbiAgZnVuY3Rpb24gZG9uZShlKSB7XFxuICAgIGNtLnN0YXRlLnNlbGVjdGluZ1RleHQgPSBmYWxzZVxcbiAgICBjb3VudGVyID0gSW5maW5pdHlcXG4gICAgZV9wcmV2ZW50RGVmYXVsdChlKVxcbiAgICBkaXNwbGF5LmlucHV0LmZvY3VzKClcXG4gICAgb2ZmKGRvY3VtZW50LCBcXFwibW91c2Vtb3ZlXFxcIiwgbW92ZSlcXG4gICAgb2ZmKGRvY3VtZW50LCBcXFwibW91c2V1cFxcXCIsIHVwKVxcbiAgICBkb2MuaGlzdG9yeS5sYXN0U2VsT3JpZ2luID0gbnVsbFxcbiAgfVxcblxcbiAgdmFyIG1vdmUgPSBvcGVyYXRpb24oY20sIGZ1bmN0aW9uIChlKSB7XFxuICAgIGlmICghZV9idXR0b24oZSkpIHsgZG9uZShlKSB9XFxuICAgIGVsc2UgeyBleHRlbmQoZSkgfVxcbiAgfSlcXG4gIHZhciB1cCA9IG9wZXJhdGlvbihjbSwgZG9uZSlcXG4gIGNtLnN0YXRlLnNlbGVjdGluZ1RleHQgPSB1cFxcbiAgb24oZG9jdW1lbnQsIFxcXCJtb3VzZW1vdmVcXFwiLCBtb3ZlKVxcbiAgb24oZG9jdW1lbnQsIFxcXCJtb3VzZXVwXFxcIiwgdXApXFxufVxcblxcblxcbi8vIERldGVybWluZXMgd2hldGhlciBhbiBldmVudCBoYXBwZW5lZCBpbiB0aGUgZ3V0dGVyLCBhbmQgZmlyZXMgdGhlXFxuLy8gaGFuZGxlcnMgZm9yIHRoZSBjb3JyZXNwb25kaW5nIGV2ZW50LlxcbmZ1bmN0aW9uIGd1dHRlckV2ZW50KGNtLCBlLCB0eXBlLCBwcmV2ZW50KSB7XFxuICB2YXIgbVgsIG1ZXFxuICB0cnkgeyBtWCA9IGUuY2xpZW50WDsgbVkgPSBlLmNsaWVudFkgfVxcbiAgY2F0Y2goZSkgeyByZXR1cm4gZmFsc2UgfVxcbiAgaWYgKG1YID49IE1hdGguZmxvb3IoY20uZGlzcGxheS5ndXR0ZXJzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnJpZ2h0KSkgeyByZXR1cm4gZmFsc2UgfVxcbiAgaWYgKHByZXZlbnQpIHsgZV9wcmV2ZW50RGVmYXVsdChlKSB9XFxuXFxuICB2YXIgZGlzcGxheSA9IGNtLmRpc3BsYXlcXG4gIHZhciBsaW5lQm94ID0gZGlzcGxheS5saW5lRGl2LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXFxuXFxuICBpZiAobVkgPiBsaW5lQm94LmJvdHRvbSB8fCAhaGFzSGFuZGxlcihjbSwgdHlwZSkpIHsgcmV0dXJuIGVfZGVmYXVsdFByZXZlbnRlZChlKSB9XFxuICBtWSAtPSBsaW5lQm94LnRvcCAtIGRpc3BsYXkudmlld09mZnNldFxcblxcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjbS5vcHRpb25zLmd1dHRlcnMubGVuZ3RoOyArK2kpIHtcXG4gICAgdmFyIGcgPSBkaXNwbGF5Lmd1dHRlcnMuY2hpbGROb2Rlc1tpXVxcbiAgICBpZiAoZyAmJiBnLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnJpZ2h0ID49IG1YKSB7XFxuICAgICAgdmFyIGxpbmUgPSBsaW5lQXRIZWlnaHQoY20uZG9jLCBtWSlcXG4gICAgICB2YXIgZ3V0dGVyID0gY20ub3B0aW9ucy5ndXR0ZXJzW2ldXFxuICAgICAgc2lnbmFsKGNtLCB0eXBlLCBjbSwgbGluZSwgZ3V0dGVyLCBlKVxcbiAgICAgIHJldHVybiBlX2RlZmF1bHRQcmV2ZW50ZWQoZSlcXG4gICAgfVxcbiAgfVxcbn1cXG5cXG5mdW5jdGlvbiBjbGlja0luR3V0dGVyKGNtLCBlKSB7XFxuICByZXR1cm4gZ3V0dGVyRXZlbnQoY20sIGUsIFxcXCJndXR0ZXJDbGlja1xcXCIsIHRydWUpXFxufVxcblxcbi8vIENPTlRFWFQgTUVOVSBIQU5ETElOR1xcblxcbi8vIFRvIG1ha2UgdGhlIGNvbnRleHQgbWVudSB3b3JrLCB3ZSBuZWVkIHRvIGJyaWVmbHkgdW5oaWRlIHRoZVxcbi8vIHRleHRhcmVhIChtYWtpbmcgaXQgYXMgdW5vYnRydXNpdmUgYXMgcG9zc2libGUpIHRvIGxldCB0aGVcXG4vLyByaWdodC1jbGljayB0YWtlIGVmZmVjdCBvbiBpdC5cXG5mdW5jdGlvbiBvbkNvbnRleHRNZW51KGNtLCBlKSB7XFxuICBpZiAoZXZlbnRJbldpZGdldChjbS5kaXNwbGF5LCBlKSB8fCBjb250ZXh0TWVudUluR3V0dGVyKGNtLCBlKSkgeyByZXR1cm4gfVxcbiAgaWYgKHNpZ25hbERPTUV2ZW50KGNtLCBlLCBcXFwiY29udGV4dG1lbnVcXFwiKSkgeyByZXR1cm4gfVxcbiAgY20uZGlzcGxheS5pbnB1dC5vbkNvbnRleHRNZW51KGUpXFxufVxcblxcbmZ1bmN0aW9uIGNvbnRleHRNZW51SW5HdXR0ZXIoY20sIGUpIHtcXG4gIGlmICghaGFzSGFuZGxlcihjbSwgXFxcImd1dHRlckNvbnRleHRNZW51XFxcIikpIHsgcmV0dXJuIGZhbHNlIH1cXG4gIHJldHVybiBndXR0ZXJFdmVudChjbSwgZSwgXFxcImd1dHRlckNvbnRleHRNZW51XFxcIiwgZmFsc2UpXFxufVxcblxcbmZ1bmN0aW9uIHRoZW1lQ2hhbmdlZChjbSkge1xcbiAgY20uZGlzcGxheS53cmFwcGVyLmNsYXNzTmFtZSA9IGNtLmRpc3BsYXkud3JhcHBlci5jbGFzc05hbWUucmVwbGFjZSgvXFxcXHMqY20tcy1cXFxcUysvZywgXFxcIlxcXCIpICtcXG4gICAgY20ub3B0aW9ucy50aGVtZS5yZXBsYWNlKC8oXnxcXFxccylcXFxccyovZywgXFxcIiBjbS1zLVxcXCIpXFxuICBjbGVhckNhY2hlcyhjbSlcXG59XFxuXFxudmFyIEluaXQgPSB7dG9TdHJpbmc6IGZ1bmN0aW9uKCl7cmV0dXJuIFxcXCJDb2RlTWlycm9yLkluaXRcXFwifX1cXG5cXG52YXIgZGVmYXVsdHMgPSB7fVxcbnZhciBvcHRpb25IYW5kbGVycyA9IHt9XFxuXFxuZnVuY3Rpb24gZGVmaW5lT3B0aW9ucyhDb2RlTWlycm9yKSB7XFxuICB2YXIgb3B0aW9uSGFuZGxlcnMgPSBDb2RlTWlycm9yLm9wdGlvbkhhbmRsZXJzXFxuXFxuICBmdW5jdGlvbiBvcHRpb24obmFtZSwgZGVmbHQsIGhhbmRsZSwgbm90T25Jbml0KSB7XFxuICAgIENvZGVNaXJyb3IuZGVmYXVsdHNbbmFtZV0gPSBkZWZsdFxcbiAgICBpZiAoaGFuZGxlKSB7IG9wdGlvbkhhbmRsZXJzW25hbWVdID1cXG4gICAgICBub3RPbkluaXQgPyBmdW5jdGlvbiAoY20sIHZhbCwgb2xkKSB7aWYgKG9sZCAhPSBJbml0KSB7IGhhbmRsZShjbSwgdmFsLCBvbGQpIH19IDogaGFuZGxlIH1cXG4gIH1cXG5cXG4gIENvZGVNaXJyb3IuZGVmaW5lT3B0aW9uID0gb3B0aW9uXFxuXFxuICAvLyBQYXNzZWQgdG8gb3B0aW9uIGhhbmRsZXJzIHdoZW4gdGhlcmUgaXMgbm8gb2xkIHZhbHVlLlxcbiAgQ29kZU1pcnJvci5Jbml0ID0gSW5pdFxcblxcbiAgLy8gVGhlc2UgdHdvIGFyZSwgb24gaW5pdCwgY2FsbGVkIGZyb20gdGhlIGNvbnN0cnVjdG9yIGJlY2F1c2UgdGhleVxcbiAgLy8gaGF2ZSB0byBiZSBpbml0aWFsaXplZCBiZWZvcmUgdGhlIGVkaXRvciBjYW4gc3RhcnQgYXQgYWxsLlxcbiAgb3B0aW9uKFxcXCJ2YWx1ZVxcXCIsIFxcXCJcXFwiLCBmdW5jdGlvbiAoY20sIHZhbCkgeyByZXR1cm4gY20uc2V0VmFsdWUodmFsKTsgfSwgdHJ1ZSlcXG4gIG9wdGlvbihcXFwibW9kZVxcXCIsIG51bGwsIGZ1bmN0aW9uIChjbSwgdmFsKSB7XFxuICAgIGNtLmRvYy5tb2RlT3B0aW9uID0gdmFsXFxuICAgIGxvYWRNb2RlKGNtKVxcbiAgfSwgdHJ1ZSlcXG5cXG4gIG9wdGlvbihcXFwiaW5kZW50VW5pdFxcXCIsIDIsIGxvYWRNb2RlLCB0cnVlKVxcbiAgb3B0aW9uKFxcXCJpbmRlbnRXaXRoVGFic1xcXCIsIGZhbHNlKVxcbiAgb3B0aW9uKFxcXCJzbWFydEluZGVudFxcXCIsIHRydWUpXFxuICBvcHRpb24oXFxcInRhYlNpemVcXFwiLCA0LCBmdW5jdGlvbiAoY20pIHtcXG4gICAgcmVzZXRNb2RlU3RhdGUoY20pXFxuICAgIGNsZWFyQ2FjaGVzKGNtKVxcbiAgICByZWdDaGFuZ2UoY20pXFxuICB9LCB0cnVlKVxcbiAgb3B0aW9uKFxcXCJsaW5lU2VwYXJhdG9yXFxcIiwgbnVsbCwgZnVuY3Rpb24gKGNtLCB2YWwpIHtcXG4gICAgY20uZG9jLmxpbmVTZXAgPSB2YWxcXG4gICAgaWYgKCF2YWwpIHsgcmV0dXJuIH1cXG4gICAgdmFyIG5ld0JyZWFrcyA9IFtdLCBsaW5lTm8gPSBjbS5kb2MuZmlyc3RcXG4gICAgY20uZG9jLml0ZXIoZnVuY3Rpb24gKGxpbmUpIHtcXG4gICAgICBmb3IgKHZhciBwb3MgPSAwOzspIHtcXG4gICAgICAgIHZhciBmb3VuZCA9IGxpbmUudGV4dC5pbmRleE9mKHZhbCwgcG9zKVxcbiAgICAgICAgaWYgKGZvdW5kID09IC0xKSB7IGJyZWFrIH1cXG4gICAgICAgIHBvcyA9IGZvdW5kICsgdmFsLmxlbmd0aFxcbiAgICAgICAgbmV3QnJlYWtzLnB1c2goUG9zKGxpbmVObywgZm91bmQpKVxcbiAgICAgIH1cXG4gICAgICBsaW5lTm8rK1xcbiAgICB9KVxcbiAgICBmb3IgKHZhciBpID0gbmV3QnJlYWtzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxcbiAgICAgIHsgcmVwbGFjZVJhbmdlKGNtLmRvYywgdmFsLCBuZXdCcmVha3NbaV0sIFBvcyhuZXdCcmVha3NbaV0ubGluZSwgbmV3QnJlYWtzW2ldLmNoICsgdmFsLmxlbmd0aCkpIH1cXG4gIH0pXFxuICBvcHRpb24oXFxcInNwZWNpYWxDaGFyc1xcXCIsIC9bXFxcXHUwMDAwLVxcXFx1MDAxZlxcXFx1MDA3ZlxcXFx1MDBhZFxcXFx1MDYxY1xcXFx1MjAwYi1cXFxcdTIwMGZcXFxcdTIwMjhcXFxcdTIwMjlcXFxcdWZlZmZdL2csIGZ1bmN0aW9uIChjbSwgdmFsLCBvbGQpIHtcXG4gICAgY20uc3RhdGUuc3BlY2lhbENoYXJzID0gbmV3IFJlZ0V4cCh2YWwuc291cmNlICsgKHZhbC50ZXN0KFxcXCJcXFxcdFxcXCIpID8gXFxcIlxcXCIgOiBcXFwifFxcXFx0XFxcIiksIFxcXCJnXFxcIilcXG4gICAgaWYgKG9sZCAhPSBJbml0KSB7IGNtLnJlZnJlc2goKSB9XFxuICB9KVxcbiAgb3B0aW9uKFxcXCJzcGVjaWFsQ2hhclBsYWNlaG9sZGVyXFxcIiwgZGVmYXVsdFNwZWNpYWxDaGFyUGxhY2Vob2xkZXIsIGZ1bmN0aW9uIChjbSkgeyByZXR1cm4gY20ucmVmcmVzaCgpOyB9LCB0cnVlKVxcbiAgb3B0aW9uKFxcXCJlbGVjdHJpY0NoYXJzXFxcIiwgdHJ1ZSlcXG4gIG9wdGlvbihcXFwiaW5wdXRTdHlsZVxcXCIsIG1vYmlsZSA/IFxcXCJjb250ZW50ZWRpdGFibGVcXFwiIDogXFxcInRleHRhcmVhXFxcIiwgZnVuY3Rpb24gKCkge1xcbiAgICB0aHJvdyBuZXcgRXJyb3IoXFxcImlucHV0U3R5bGUgY2FuIG5vdCAoeWV0KSBiZSBjaGFuZ2VkIGluIGEgcnVubmluZyBlZGl0b3JcXFwiKSAvLyBGSVhNRVxcbiAgfSwgdHJ1ZSlcXG4gIG9wdGlvbihcXFwic3BlbGxjaGVja1xcXCIsIGZhbHNlLCBmdW5jdGlvbiAoY20sIHZhbCkgeyByZXR1cm4gY20uZ2V0SW5wdXRGaWVsZCgpLnNwZWxsY2hlY2sgPSB2YWw7IH0sIHRydWUpXFxuICBvcHRpb24oXFxcInJ0bE1vdmVWaXN1YWxseVxcXCIsICF3aW5kb3dzKVxcbiAgb3B0aW9uKFxcXCJ3aG9sZUxpbmVVcGRhdGVCZWZvcmVcXFwiLCB0cnVlKVxcblxcbiAgb3B0aW9uKFxcXCJ0aGVtZVxcXCIsIFxcXCJkZWZhdWx0XFxcIiwgZnVuY3Rpb24gKGNtKSB7XFxuICAgIHRoZW1lQ2hhbmdlZChjbSlcXG4gICAgZ3V0dGVyc0NoYW5nZWQoY20pXFxuICB9LCB0cnVlKVxcbiAgb3B0aW9uKFxcXCJrZXlNYXBcXFwiLCBcXFwiZGVmYXVsdFxcXCIsIGZ1bmN0aW9uIChjbSwgdmFsLCBvbGQpIHtcXG4gICAgdmFyIG5leHQgPSBnZXRLZXlNYXAodmFsKVxcbiAgICB2YXIgcHJldiA9IG9sZCAhPSBJbml0ICYmIGdldEtleU1hcChvbGQpXFxuICAgIGlmIChwcmV2ICYmIHByZXYuZGV0YWNoKSB7IHByZXYuZGV0YWNoKGNtLCBuZXh0KSB9XFxuICAgIGlmIChuZXh0LmF0dGFjaCkgeyBuZXh0LmF0dGFjaChjbSwgcHJldiB8fCBudWxsKSB9XFxuICB9KVxcbiAgb3B0aW9uKFxcXCJleHRyYUtleXNcXFwiLCBudWxsKVxcblxcbiAgb3B0aW9uKFxcXCJsaW5lV3JhcHBpbmdcXFwiLCBmYWxzZSwgd3JhcHBpbmdDaGFuZ2VkLCB0cnVlKVxcbiAgb3B0aW9uKFxcXCJndXR0ZXJzXFxcIiwgW10sIGZ1bmN0aW9uIChjbSkge1xcbiAgICBzZXRHdXR0ZXJzRm9yTGluZU51bWJlcnMoY20ub3B0aW9ucylcXG4gICAgZ3V0dGVyc0NoYW5nZWQoY20pXFxuICB9LCB0cnVlKVxcbiAgb3B0aW9uKFxcXCJmaXhlZEd1dHRlclxcXCIsIHRydWUsIGZ1bmN0aW9uIChjbSwgdmFsKSB7XFxuICAgIGNtLmRpc3BsYXkuZ3V0dGVycy5zdHlsZS5sZWZ0ID0gdmFsID8gY29tcGVuc2F0ZUZvckhTY3JvbGwoY20uZGlzcGxheSkgKyBcXFwicHhcXFwiIDogXFxcIjBcXFwiXFxuICAgIGNtLnJlZnJlc2goKVxcbiAgfSwgdHJ1ZSlcXG4gIG9wdGlvbihcXFwiY292ZXJHdXR0ZXJOZXh0VG9TY3JvbGxiYXJcXFwiLCBmYWxzZSwgZnVuY3Rpb24gKGNtKSB7IHJldHVybiB1cGRhdGVTY3JvbGxiYXJzKGNtKTsgfSwgdHJ1ZSlcXG4gIG9wdGlvbihcXFwic2Nyb2xsYmFyU3R5bGVcXFwiLCBcXFwibmF0aXZlXFxcIiwgZnVuY3Rpb24gKGNtKSB7XFxuICAgIGluaXRTY3JvbGxiYXJzKGNtKVxcbiAgICB1cGRhdGVTY3JvbGxiYXJzKGNtKVxcbiAgICBjbS5kaXNwbGF5LnNjcm9sbGJhcnMuc2V0U2Nyb2xsVG9wKGNtLmRvYy5zY3JvbGxUb3ApXFxuICAgIGNtLmRpc3BsYXkuc2Nyb2xsYmFycy5zZXRTY3JvbGxMZWZ0KGNtLmRvYy5zY3JvbGxMZWZ0KVxcbiAgfSwgdHJ1ZSlcXG4gIG9wdGlvbihcXFwibGluZU51bWJlcnNcXFwiLCBmYWxzZSwgZnVuY3Rpb24gKGNtKSB7XFxuICAgIHNldEd1dHRlcnNGb3JMaW5lTnVtYmVycyhjbS5vcHRpb25zKVxcbiAgICBndXR0ZXJzQ2hhbmdlZChjbSlcXG4gIH0sIHRydWUpXFxuICBvcHRpb24oXFxcImZpcnN0TGluZU51bWJlclxcXCIsIDEsIGd1dHRlcnNDaGFuZ2VkLCB0cnVlKVxcbiAgb3B0aW9uKFxcXCJsaW5lTnVtYmVyRm9ybWF0dGVyXFxcIiwgZnVuY3Rpb24gKGludGVnZXIpIHsgcmV0dXJuIGludGVnZXI7IH0sIGd1dHRlcnNDaGFuZ2VkLCB0cnVlKVxcbiAgb3B0aW9uKFxcXCJzaG93Q3Vyc29yV2hlblNlbGVjdGluZ1xcXCIsIGZhbHNlLCB1cGRhdGVTZWxlY3Rpb24sIHRydWUpXFxuXFxuICBvcHRpb24oXFxcInJlc2V0U2VsZWN0aW9uT25Db250ZXh0TWVudVxcXCIsIHRydWUpXFxuICBvcHRpb24oXFxcImxpbmVXaXNlQ29weUN1dFxcXCIsIHRydWUpXFxuXFxuICBvcHRpb24oXFxcInJlYWRPbmx5XFxcIiwgZmFsc2UsIGZ1bmN0aW9uIChjbSwgdmFsKSB7XFxuICAgIGlmICh2YWwgPT0gXFxcIm5vY3Vyc29yXFxcIikge1xcbiAgICAgIG9uQmx1cihjbSlcXG4gICAgICBjbS5kaXNwbGF5LmlucHV0LmJsdXIoKVxcbiAgICAgIGNtLmRpc3BsYXkuZGlzYWJsZWQgPSB0cnVlXFxuICAgIH0gZWxzZSB7XFxuICAgICAgY20uZGlzcGxheS5kaXNhYmxlZCA9IGZhbHNlXFxuICAgIH1cXG4gICAgY20uZGlzcGxheS5pbnB1dC5yZWFkT25seUNoYW5nZWQodmFsKVxcbiAgfSlcXG4gIG9wdGlvbihcXFwiZGlzYWJsZUlucHV0XFxcIiwgZmFsc2UsIGZ1bmN0aW9uIChjbSwgdmFsKSB7aWYgKCF2YWwpIHsgY20uZGlzcGxheS5pbnB1dC5yZXNldCgpIH19LCB0cnVlKVxcbiAgb3B0aW9uKFxcXCJkcmFnRHJvcFxcXCIsIHRydWUsIGRyYWdEcm9wQ2hhbmdlZClcXG4gIG9wdGlvbihcXFwiYWxsb3dEcm9wRmlsZVR5cGVzXFxcIiwgbnVsbClcXG5cXG4gIG9wdGlvbihcXFwiY3Vyc29yQmxpbmtSYXRlXFxcIiwgNTMwKVxcbiAgb3B0aW9uKFxcXCJjdXJzb3JTY3JvbGxNYXJnaW5cXFwiLCAwKVxcbiAgb3B0aW9uKFxcXCJjdXJzb3JIZWlnaHRcXFwiLCAxLCB1cGRhdGVTZWxlY3Rpb24sIHRydWUpXFxuICBvcHRpb24oXFxcInNpbmdsZUN1cnNvckhlaWdodFBlckxpbmVcXFwiLCB0cnVlLCB1cGRhdGVTZWxlY3Rpb24sIHRydWUpXFxuICBvcHRpb24oXFxcIndvcmtUaW1lXFxcIiwgMTAwKVxcbiAgb3B0aW9uKFxcXCJ3b3JrRGVsYXlcXFwiLCAxMDApXFxuICBvcHRpb24oXFxcImZsYXR0ZW5TcGFuc1xcXCIsIHRydWUsIHJlc2V0TW9kZVN0YXRlLCB0cnVlKVxcbiAgb3B0aW9uKFxcXCJhZGRNb2RlQ2xhc3NcXFwiLCBmYWxzZSwgcmVzZXRNb2RlU3RhdGUsIHRydWUpXFxuICBvcHRpb24oXFxcInBvbGxJbnRlcnZhbFxcXCIsIDEwMClcXG4gIG9wdGlvbihcXFwidW5kb0RlcHRoXFxcIiwgMjAwLCBmdW5jdGlvbiAoY20sIHZhbCkgeyByZXR1cm4gY20uZG9jLmhpc3RvcnkudW5kb0RlcHRoID0gdmFsOyB9KVxcbiAgb3B0aW9uKFxcXCJoaXN0b3J5RXZlbnREZWxheVxcXCIsIDEyNTApXFxuICBvcHRpb24oXFxcInZpZXdwb3J0TWFyZ2luXFxcIiwgMTAsIGZ1bmN0aW9uIChjbSkgeyByZXR1cm4gY20ucmVmcmVzaCgpOyB9LCB0cnVlKVxcbiAgb3B0aW9uKFxcXCJtYXhIaWdobGlnaHRMZW5ndGhcXFwiLCAxMDAwMCwgcmVzZXRNb2RlU3RhdGUsIHRydWUpXFxuICBvcHRpb24oXFxcIm1vdmVJbnB1dFdpdGhDdXJzb3JcXFwiLCB0cnVlLCBmdW5jdGlvbiAoY20sIHZhbCkge1xcbiAgICBpZiAoIXZhbCkgeyBjbS5kaXNwbGF5LmlucHV0LnJlc2V0UG9zaXRpb24oKSB9XFxuICB9KVxcblxcbiAgb3B0aW9uKFxcXCJ0YWJpbmRleFxcXCIsIG51bGwsIGZ1bmN0aW9uIChjbSwgdmFsKSB7IHJldHVybiBjbS5kaXNwbGF5LmlucHV0LmdldEZpZWxkKCkudGFiSW5kZXggPSB2YWwgfHwgXFxcIlxcXCI7IH0pXFxuICBvcHRpb24oXFxcImF1dG9mb2N1c1xcXCIsIG51bGwpXFxufVxcblxcbmZ1bmN0aW9uIGd1dHRlcnNDaGFuZ2VkKGNtKSB7XFxuICB1cGRhdGVHdXR0ZXJzKGNtKVxcbiAgcmVnQ2hhbmdlKGNtKVxcbiAgYWxpZ25Ib3Jpem9udGFsbHkoY20pXFxufVxcblxcbmZ1bmN0aW9uIGRyYWdEcm9wQ2hhbmdlZChjbSwgdmFsdWUsIG9sZCkge1xcbiAgdmFyIHdhc09uID0gb2xkICYmIG9sZCAhPSBJbml0XFxuICBpZiAoIXZhbHVlICE9ICF3YXNPbikge1xcbiAgICB2YXIgZnVuY3MgPSBjbS5kaXNwbGF5LmRyYWdGdW5jdGlvbnNcXG4gICAgdmFyIHRvZ2dsZSA9IHZhbHVlID8gb24gOiBvZmZcXG4gICAgdG9nZ2xlKGNtLmRpc3BsYXkuc2Nyb2xsZXIsIFxcXCJkcmFnc3RhcnRcXFwiLCBmdW5jcy5zdGFydClcXG4gICAgdG9nZ2xlKGNtLmRpc3BsYXkuc2Nyb2xsZXIsIFxcXCJkcmFnZW50ZXJcXFwiLCBmdW5jcy5lbnRlcilcXG4gICAgdG9nZ2xlKGNtLmRpc3BsYXkuc2Nyb2xsZXIsIFxcXCJkcmFnb3ZlclxcXCIsIGZ1bmNzLm92ZXIpXFxuICAgIHRvZ2dsZShjbS5kaXNwbGF5LnNjcm9sbGVyLCBcXFwiZHJhZ2xlYXZlXFxcIiwgZnVuY3MubGVhdmUpXFxuICAgIHRvZ2dsZShjbS5kaXNwbGF5LnNjcm9sbGVyLCBcXFwiZHJvcFxcXCIsIGZ1bmNzLmRyb3ApXFxuICB9XFxufVxcblxcbmZ1bmN0aW9uIHdyYXBwaW5nQ2hhbmdlZChjbSkge1xcbiAgaWYgKGNtLm9wdGlvbnMubGluZVdyYXBwaW5nKSB7XFxuICAgIGFkZENsYXNzKGNtLmRpc3BsYXkud3JhcHBlciwgXFxcIkNvZGVNaXJyb3Itd3JhcFxcXCIpXFxuICAgIGNtLmRpc3BsYXkuc2l6ZXIuc3R5bGUubWluV2lkdGggPSBcXFwiXFxcIlxcbiAgICBjbS5kaXNwbGF5LnNpemVyV2lkdGggPSBudWxsXFxuICB9IGVsc2Uge1xcbiAgICBybUNsYXNzKGNtLmRpc3BsYXkud3JhcHBlciwgXFxcIkNvZGVNaXJyb3Itd3JhcFxcXCIpXFxuICAgIGZpbmRNYXhMaW5lKGNtKVxcbiAgfVxcbiAgZXN0aW1hdGVMaW5lSGVpZ2h0cyhjbSlcXG4gIHJlZ0NoYW5nZShjbSlcXG4gIGNsZWFyQ2FjaGVzKGNtKVxcbiAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHJldHVybiB1cGRhdGVTY3JvbGxiYXJzKGNtKTsgfSwgMTAwKVxcbn1cXG5cXG4vLyBBIENvZGVNaXJyb3IgaW5zdGFuY2UgcmVwcmVzZW50cyBhbiBlZGl0b3IuIFRoaXMgaXMgdGhlIG9iamVjdFxcbi8vIHRoYXQgdXNlciBjb2RlIGlzIHVzdWFsbHkgZGVhbGluZyB3aXRoLlxcblxcbmZ1bmN0aW9uIENvZGVNaXJyb3IocGxhY2UsIG9wdGlvbnMpIHtcXG4gIHZhciB0aGlzJDEgPSB0aGlzO1xcblxcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIENvZGVNaXJyb3IpKSB7IHJldHVybiBuZXcgQ29kZU1pcnJvcihwbGFjZSwgb3B0aW9ucykgfVxcblxcbiAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyA9IG9wdGlvbnMgPyBjb3B5T2JqKG9wdGlvbnMpIDoge31cXG4gIC8vIERldGVybWluZSBlZmZlY3RpdmUgb3B0aW9ucyBiYXNlZCBvbiBnaXZlbiB2YWx1ZXMgYW5kIGRlZmF1bHRzLlxcbiAgY29weU9iaihkZWZhdWx0cywgb3B0aW9ucywgZmFsc2UpXFxuICBzZXRHdXR0ZXJzRm9yTGluZU51bWJlcnMob3B0aW9ucylcXG5cXG4gIHZhciBkb2MgPSBvcHRpb25zLnZhbHVlXFxuICBpZiAodHlwZW9mIGRvYyA9PSBcXFwic3RyaW5nXFxcIikgeyBkb2MgPSBuZXcgRG9jKGRvYywgb3B0aW9ucy5tb2RlLCBudWxsLCBvcHRpb25zLmxpbmVTZXBhcmF0b3IpIH1cXG4gIHRoaXMuZG9jID0gZG9jXFxuXFxuICB2YXIgaW5wdXQgPSBuZXcgQ29kZU1pcnJvci5pbnB1dFN0eWxlc1tvcHRpb25zLmlucHV0U3R5bGVdKHRoaXMpXFxuICB2YXIgZGlzcGxheSA9IHRoaXMuZGlzcGxheSA9IG5ldyBEaXNwbGF5KHBsYWNlLCBkb2MsIGlucHV0KVxcbiAgZGlzcGxheS53cmFwcGVyLkNvZGVNaXJyb3IgPSB0aGlzXFxuICB1cGRhdGVHdXR0ZXJzKHRoaXMpXFxuICB0aGVtZUNoYW5nZWQodGhpcylcXG4gIGlmIChvcHRpb25zLmxpbmVXcmFwcGluZylcXG4gICAgeyB0aGlzLmRpc3BsYXkud3JhcHBlci5jbGFzc05hbWUgKz0gXFxcIiBDb2RlTWlycm9yLXdyYXBcXFwiIH1cXG4gIGluaXRTY3JvbGxiYXJzKHRoaXMpXFxuXFxuICB0aGlzLnN0YXRlID0ge1xcbiAgICBrZXlNYXBzOiBbXSwgIC8vIHN0b3JlcyBtYXBzIGFkZGVkIGJ5IGFkZEtleU1hcFxcbiAgICBvdmVybGF5czogW10sIC8vIGhpZ2hsaWdodGluZyBvdmVybGF5cywgYXMgYWRkZWQgYnkgYWRkT3ZlcmxheVxcbiAgICBtb2RlR2VuOiAwLCAgIC8vIGJ1bXBlZCB3aGVuIG1vZGUvb3ZlcmxheSBjaGFuZ2VzLCB1c2VkIHRvIGludmFsaWRhdGUgaGlnaGxpZ2h0aW5nIGluZm9cXG4gICAgb3ZlcndyaXRlOiBmYWxzZSxcXG4gICAgZGVsYXlpbmdCbHVyRXZlbnQ6IGZhbHNlLFxcbiAgICBmb2N1c2VkOiBmYWxzZSxcXG4gICAgc3VwcHJlc3NFZGl0czogZmFsc2UsIC8vIHVzZWQgdG8gZGlzYWJsZSBlZGl0aW5nIGR1cmluZyBrZXkgaGFuZGxlcnMgd2hlbiBpbiByZWFkT25seSBtb2RlXFxuICAgIHBhc3RlSW5jb21pbmc6IGZhbHNlLCBjdXRJbmNvbWluZzogZmFsc2UsIC8vIGhlbHAgcmVjb2duaXplIHBhc3RlL2N1dCBlZGl0cyBpbiBpbnB1dC5wb2xsXFxuICAgIHNlbGVjdGluZ1RleHQ6IGZhbHNlLFxcbiAgICBkcmFnZ2luZ1RleHQ6IGZhbHNlLFxcbiAgICBoaWdobGlnaHQ6IG5ldyBEZWxheWVkKCksIC8vIHN0b3JlcyBoaWdobGlnaHQgd29ya2VyIHRpbWVvdXRcXG4gICAga2V5U2VxOiBudWxsLCAgLy8gVW5maW5pc2hlZCBrZXkgc2VxdWVuY2VcXG4gICAgc3BlY2lhbENoYXJzOiBudWxsXFxuICB9XFxuXFxuICBpZiAob3B0aW9ucy5hdXRvZm9jdXMgJiYgIW1vYmlsZSkgeyBkaXNwbGF5LmlucHV0LmZvY3VzKCkgfVxcblxcbiAgLy8gT3ZlcnJpZGUgbWFnaWMgdGV4dGFyZWEgY29udGVudCByZXN0b3JlIHRoYXQgSUUgc29tZXRpbWVzIGRvZXNcXG4gIC8vIG9uIG91ciBoaWRkZW4gdGV4dGFyZWEgb24gcmVsb2FkXFxuICBpZiAoaWUgJiYgaWVfdmVyc2lvbiA8IDExKSB7IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcyQxLmRpc3BsYXkuaW5wdXQucmVzZXQodHJ1ZSk7IH0sIDIwKSB9XFxuXFxuICByZWdpc3RlckV2ZW50SGFuZGxlcnModGhpcylcXG4gIGVuc3VyZUdsb2JhbEhhbmRsZXJzKClcXG5cXG4gIHN0YXJ0T3BlcmF0aW9uKHRoaXMpXFxuICB0aGlzLmN1ck9wLmZvcmNlVXBkYXRlID0gdHJ1ZVxcbiAgYXR0YWNoRG9jKHRoaXMsIGRvYylcXG5cXG4gIGlmICgob3B0aW9ucy5hdXRvZm9jdXMgJiYgIW1vYmlsZSkgfHwgdGhpcy5oYXNGb2N1cygpKVxcbiAgICB7IHNldFRpbWVvdXQoYmluZChvbkZvY3VzLCB0aGlzKSwgMjApIH1cXG4gIGVsc2VcXG4gICAgeyBvbkJsdXIodGhpcykgfVxcblxcbiAgZm9yICh2YXIgb3B0IGluIG9wdGlvbkhhbmRsZXJzKSB7IGlmIChvcHRpb25IYW5kbGVycy5oYXNPd25Qcm9wZXJ0eShvcHQpKVxcbiAgICB7IG9wdGlvbkhhbmRsZXJzW29wdF0odGhpcyQxLCBvcHRpb25zW29wdF0sIEluaXQpIH0gfVxcbiAgbWF5YmVVcGRhdGVMaW5lTnVtYmVyV2lkdGgodGhpcylcXG4gIGlmIChvcHRpb25zLmZpbmlzaEluaXQpIHsgb3B0aW9ucy5maW5pc2hJbml0KHRoaXMpIH1cXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgaW5pdEhvb2tzLmxlbmd0aDsgKytpKSB7IGluaXRIb29rc1tpXSh0aGlzJDEpIH1cXG4gIGVuZE9wZXJhdGlvbih0aGlzKVxcbiAgLy8gU3VwcHJlc3Mgb3B0aW1pemVsZWdpYmlsaXR5IGluIFdlYmtpdCwgc2luY2UgaXQgYnJlYWtzIHRleHRcXG4gIC8vIG1lYXN1cmluZyBvbiBsaW5lIHdyYXBwaW5nIGJvdW5kYXJpZXMuXFxuICBpZiAod2Via2l0ICYmIG9wdGlvbnMubGluZVdyYXBwaW5nICYmXFxuICAgICAgZ2V0Q29tcHV0ZWRTdHlsZShkaXNwbGF5LmxpbmVEaXYpLnRleHRSZW5kZXJpbmcgPT0gXFxcIm9wdGltaXplbGVnaWJpbGl0eVxcXCIpXFxuICAgIHsgZGlzcGxheS5saW5lRGl2LnN0eWxlLnRleHRSZW5kZXJpbmcgPSBcXFwiYXV0b1xcXCIgfVxcbn1cXG5cXG4vLyBUaGUgZGVmYXVsdCBjb25maWd1cmF0aW9uIG9wdGlvbnMuXFxuQ29kZU1pcnJvci5kZWZhdWx0cyA9IGRlZmF1bHRzXFxuLy8gRnVuY3Rpb25zIHRvIHJ1biB3aGVuIG9wdGlvbnMgYXJlIGNoYW5nZWQuXFxuQ29kZU1pcnJvci5vcHRpb25IYW5kbGVycyA9IG9wdGlvbkhhbmRsZXJzXFxuXFxuLy8gQXR0YWNoIHRoZSBuZWNlc3NhcnkgZXZlbnQgaGFuZGxlcnMgd2hlbiBpbml0aWFsaXppbmcgdGhlIGVkaXRvclxcbmZ1bmN0aW9uIHJlZ2lzdGVyRXZlbnRIYW5kbGVycyhjbSkge1xcbiAgdmFyIGQgPSBjbS5kaXNwbGF5XFxuICBvbihkLnNjcm9sbGVyLCBcXFwibW91c2Vkb3duXFxcIiwgb3BlcmF0aW9uKGNtLCBvbk1vdXNlRG93bikpXFxuICAvLyBPbGRlciBJRSdzIHdpbGwgbm90IGZpcmUgYSBzZWNvbmQgbW91c2Vkb3duIGZvciBhIGRvdWJsZSBjbGlja1xcbiAgaWYgKGllICYmIGllX3ZlcnNpb24gPCAxMSlcXG4gICAgeyBvbihkLnNjcm9sbGVyLCBcXFwiZGJsY2xpY2tcXFwiLCBvcGVyYXRpb24oY20sIGZ1bmN0aW9uIChlKSB7XFxuICAgICAgaWYgKHNpZ25hbERPTUV2ZW50KGNtLCBlKSkgeyByZXR1cm4gfVxcbiAgICAgIHZhciBwb3MgPSBwb3NGcm9tTW91c2UoY20sIGUpXFxuICAgICAgaWYgKCFwb3MgfHwgY2xpY2tJbkd1dHRlcihjbSwgZSkgfHwgZXZlbnRJbldpZGdldChjbS5kaXNwbGF5LCBlKSkgeyByZXR1cm4gfVxcbiAgICAgIGVfcHJldmVudERlZmF1bHQoZSlcXG4gICAgICB2YXIgd29yZCA9IGNtLmZpbmRXb3JkQXQocG9zKVxcbiAgICAgIGV4dGVuZFNlbGVjdGlvbihjbS5kb2MsIHdvcmQuYW5jaG9yLCB3b3JkLmhlYWQpXFxuICAgIH0pKSB9XFxuICBlbHNlXFxuICAgIHsgb24oZC5zY3JvbGxlciwgXFxcImRibGNsaWNrXFxcIiwgZnVuY3Rpb24gKGUpIHsgcmV0dXJuIHNpZ25hbERPTUV2ZW50KGNtLCBlKSB8fCBlX3ByZXZlbnREZWZhdWx0KGUpOyB9KSB9XFxuICAvLyBTb21lIGJyb3dzZXJzIGZpcmUgY29udGV4dG1lbnUgKmFmdGVyKiBvcGVuaW5nIHRoZSBtZW51LCBhdFxcbiAgLy8gd2hpY2ggcG9pbnQgd2UgY2FuJ3QgbWVzcyB3aXRoIGl0IGFueW1vcmUuIENvbnRleHQgbWVudSBpc1xcbiAgLy8gaGFuZGxlZCBpbiBvbk1vdXNlRG93biBmb3IgdGhlc2UgYnJvd3NlcnMuXFxuICBpZiAoIWNhcHR1cmVSaWdodENsaWNrKSB7IG9uKGQuc2Nyb2xsZXIsIFxcXCJjb250ZXh0bWVudVxcXCIsIGZ1bmN0aW9uIChlKSB7IHJldHVybiBvbkNvbnRleHRNZW51KGNtLCBlKTsgfSkgfVxcblxcbiAgLy8gVXNlZCB0byBzdXBwcmVzcyBtb3VzZSBldmVudCBoYW5kbGluZyB3aGVuIGEgdG91Y2ggaGFwcGVuc1xcbiAgdmFyIHRvdWNoRmluaXNoZWQsIHByZXZUb3VjaCA9IHtlbmQ6IDB9XFxuICBmdW5jdGlvbiBmaW5pc2hUb3VjaCgpIHtcXG4gICAgaWYgKGQuYWN0aXZlVG91Y2gpIHtcXG4gICAgICB0b3VjaEZpbmlzaGVkID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHJldHVybiBkLmFjdGl2ZVRvdWNoID0gbnVsbDsgfSwgMTAwMClcXG4gICAgICBwcmV2VG91Y2ggPSBkLmFjdGl2ZVRvdWNoXFxuICAgICAgcHJldlRvdWNoLmVuZCA9ICtuZXcgRGF0ZVxcbiAgICB9XFxuICB9XFxuICBmdW5jdGlvbiBpc01vdXNlTGlrZVRvdWNoRXZlbnQoZSkge1xcbiAgICBpZiAoZS50b3VjaGVzLmxlbmd0aCAhPSAxKSB7IHJldHVybiBmYWxzZSB9XFxuICAgIHZhciB0b3VjaCA9IGUudG91Y2hlc1swXVxcbiAgICByZXR1cm4gdG91Y2gucmFkaXVzWCA8PSAxICYmIHRvdWNoLnJhZGl1c1kgPD0gMVxcbiAgfVxcbiAgZnVuY3Rpb24gZmFyQXdheSh0b3VjaCwgb3RoZXIpIHtcXG4gICAgaWYgKG90aGVyLmxlZnQgPT0gbnVsbCkgeyByZXR1cm4gdHJ1ZSB9XFxuICAgIHZhciBkeCA9IG90aGVyLmxlZnQgLSB0b3VjaC5sZWZ0LCBkeSA9IG90aGVyLnRvcCAtIHRvdWNoLnRvcFxcbiAgICByZXR1cm4gZHggKiBkeCArIGR5ICogZHkgPiAyMCAqIDIwXFxuICB9XFxuICBvbihkLnNjcm9sbGVyLCBcXFwidG91Y2hzdGFydFxcXCIsIGZ1bmN0aW9uIChlKSB7XFxuICAgIGlmICghc2lnbmFsRE9NRXZlbnQoY20sIGUpICYmICFpc01vdXNlTGlrZVRvdWNoRXZlbnQoZSkpIHtcXG4gICAgICBkLmlucHV0LmVuc3VyZVBvbGxlZCgpXFxuICAgICAgY2xlYXJUaW1lb3V0KHRvdWNoRmluaXNoZWQpXFxuICAgICAgdmFyIG5vdyA9ICtuZXcgRGF0ZVxcbiAgICAgIGQuYWN0aXZlVG91Y2ggPSB7c3RhcnQ6IG5vdywgbW92ZWQ6IGZhbHNlLFxcbiAgICAgICAgICAgICAgICAgICAgICAgcHJldjogbm93IC0gcHJldlRvdWNoLmVuZCA8PSAzMDAgPyBwcmV2VG91Y2ggOiBudWxsfVxcbiAgICAgIGlmIChlLnRvdWNoZXMubGVuZ3RoID09IDEpIHtcXG4gICAgICAgIGQuYWN0aXZlVG91Y2gubGVmdCA9IGUudG91Y2hlc1swXS5wYWdlWFxcbiAgICAgICAgZC5hY3RpdmVUb3VjaC50b3AgPSBlLnRvdWNoZXNbMF0ucGFnZVlcXG4gICAgICB9XFxuICAgIH1cXG4gIH0pXFxuICBvbihkLnNjcm9sbGVyLCBcXFwidG91Y2htb3ZlXFxcIiwgZnVuY3Rpb24gKCkge1xcbiAgICBpZiAoZC5hY3RpdmVUb3VjaCkgeyBkLmFjdGl2ZVRvdWNoLm1vdmVkID0gdHJ1ZSB9XFxuICB9KVxcbiAgb24oZC5zY3JvbGxlciwgXFxcInRvdWNoZW5kXFxcIiwgZnVuY3Rpb24gKGUpIHtcXG4gICAgdmFyIHRvdWNoID0gZC5hY3RpdmVUb3VjaFxcbiAgICBpZiAodG91Y2ggJiYgIWV2ZW50SW5XaWRnZXQoZCwgZSkgJiYgdG91Y2gubGVmdCAhPSBudWxsICYmXFxuICAgICAgICAhdG91Y2gubW92ZWQgJiYgbmV3IERhdGUgLSB0b3VjaC5zdGFydCA8IDMwMCkge1xcbiAgICAgIHZhciBwb3MgPSBjbS5jb29yZHNDaGFyKGQuYWN0aXZlVG91Y2gsIFxcXCJwYWdlXFxcIiksIHJhbmdlXFxuICAgICAgaWYgKCF0b3VjaC5wcmV2IHx8IGZhckF3YXkodG91Y2gsIHRvdWNoLnByZXYpKSAvLyBTaW5nbGUgdGFwXFxuICAgICAgICB7IHJhbmdlID0gbmV3IFJhbmdlKHBvcywgcG9zKSB9XFxuICAgICAgZWxzZSBpZiAoIXRvdWNoLnByZXYucHJldiB8fCBmYXJBd2F5KHRvdWNoLCB0b3VjaC5wcmV2LnByZXYpKSAvLyBEb3VibGUgdGFwXFxuICAgICAgICB7IHJhbmdlID0gY20uZmluZFdvcmRBdChwb3MpIH1cXG4gICAgICBlbHNlIC8vIFRyaXBsZSB0YXBcXG4gICAgICAgIHsgcmFuZ2UgPSBuZXcgUmFuZ2UoUG9zKHBvcy5saW5lLCAwKSwgY2xpcFBvcyhjbS5kb2MsIFBvcyhwb3MubGluZSArIDEsIDApKSkgfVxcbiAgICAgIGNtLnNldFNlbGVjdGlvbihyYW5nZS5hbmNob3IsIHJhbmdlLmhlYWQpXFxuICAgICAgY20uZm9jdXMoKVxcbiAgICAgIGVfcHJldmVudERlZmF1bHQoZSlcXG4gICAgfVxcbiAgICBmaW5pc2hUb3VjaCgpXFxuICB9KVxcbiAgb24oZC5zY3JvbGxlciwgXFxcInRvdWNoY2FuY2VsXFxcIiwgZmluaXNoVG91Y2gpXFxuXFxuICAvLyBTeW5jIHNjcm9sbGluZyBiZXR3ZWVuIGZha2Ugc2Nyb2xsYmFycyBhbmQgcmVhbCBzY3JvbGxhYmxlXFxuICAvLyBhcmVhLCBlbnN1cmUgdmlld3BvcnQgaXMgdXBkYXRlZCB3aGVuIHNjcm9sbGluZy5cXG4gIG9uKGQuc2Nyb2xsZXIsIFxcXCJzY3JvbGxcXFwiLCBmdW5jdGlvbiAoKSB7XFxuICAgIGlmIChkLnNjcm9sbGVyLmNsaWVudEhlaWdodCkge1xcbiAgICAgIHNldFNjcm9sbFRvcChjbSwgZC5zY3JvbGxlci5zY3JvbGxUb3ApXFxuICAgICAgc2V0U2Nyb2xsTGVmdChjbSwgZC5zY3JvbGxlci5zY3JvbGxMZWZ0LCB0cnVlKVxcbiAgICAgIHNpZ25hbChjbSwgXFxcInNjcm9sbFxcXCIsIGNtKVxcbiAgICB9XFxuICB9KVxcblxcbiAgLy8gTGlzdGVuIHRvIHdoZWVsIGV2ZW50cyBpbiBvcmRlciB0byB0cnkgYW5kIHVwZGF0ZSB0aGUgdmlld3BvcnQgb24gdGltZS5cXG4gIG9uKGQuc2Nyb2xsZXIsIFxcXCJtb3VzZXdoZWVsXFxcIiwgZnVuY3Rpb24gKGUpIHsgcmV0dXJuIG9uU2Nyb2xsV2hlZWwoY20sIGUpOyB9KVxcbiAgb24oZC5zY3JvbGxlciwgXFxcIkRPTU1vdXNlU2Nyb2xsXFxcIiwgZnVuY3Rpb24gKGUpIHsgcmV0dXJuIG9uU2Nyb2xsV2hlZWwoY20sIGUpOyB9KVxcblxcbiAgLy8gUHJldmVudCB3cmFwcGVyIGZyb20gZXZlciBzY3JvbGxpbmdcXG4gIG9uKGQud3JhcHBlciwgXFxcInNjcm9sbFxcXCIsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGQud3JhcHBlci5zY3JvbGxUb3AgPSBkLndyYXBwZXIuc2Nyb2xsTGVmdCA9IDA7IH0pXFxuXFxuICBkLmRyYWdGdW5jdGlvbnMgPSB7XFxuICAgIGVudGVyOiBmdW5jdGlvbiAoZSkge2lmICghc2lnbmFsRE9NRXZlbnQoY20sIGUpKSB7IGVfc3RvcChlKSB9fSxcXG4gICAgb3ZlcjogZnVuY3Rpb24gKGUpIHtpZiAoIXNpZ25hbERPTUV2ZW50KGNtLCBlKSkgeyBvbkRyYWdPdmVyKGNtLCBlKTsgZV9zdG9wKGUpIH19LFxcbiAgICBzdGFydDogZnVuY3Rpb24gKGUpIHsgcmV0dXJuIG9uRHJhZ1N0YXJ0KGNtLCBlKTsgfSxcXG4gICAgZHJvcDogb3BlcmF0aW9uKGNtLCBvbkRyb3ApLFxcbiAgICBsZWF2ZTogZnVuY3Rpb24gKGUpIHtpZiAoIXNpZ25hbERPTUV2ZW50KGNtLCBlKSkgeyBjbGVhckRyYWdDdXJzb3IoY20pIH19XFxuICB9XFxuXFxuICB2YXIgaW5wID0gZC5pbnB1dC5nZXRGaWVsZCgpXFxuICBvbihpbnAsIFxcXCJrZXl1cFxcXCIsIGZ1bmN0aW9uIChlKSB7IHJldHVybiBvbktleVVwLmNhbGwoY20sIGUpOyB9KVxcbiAgb24oaW5wLCBcXFwia2V5ZG93blxcXCIsIG9wZXJhdGlvbihjbSwgb25LZXlEb3duKSlcXG4gIG9uKGlucCwgXFxcImtleXByZXNzXFxcIiwgb3BlcmF0aW9uKGNtLCBvbktleVByZXNzKSlcXG4gIG9uKGlucCwgXFxcImZvY3VzXFxcIiwgZnVuY3Rpb24gKGUpIHsgcmV0dXJuIG9uRm9jdXMoY20sIGUpOyB9KVxcbiAgb24oaW5wLCBcXFwiYmx1clxcXCIsIGZ1bmN0aW9uIChlKSB7IHJldHVybiBvbkJsdXIoY20sIGUpOyB9KVxcbn1cXG5cXG52YXIgaW5pdEhvb2tzID0gW11cXG5Db2RlTWlycm9yLmRlZmluZUluaXRIb29rID0gZnVuY3Rpb24gKGYpIHsgcmV0dXJuIGluaXRIb29rcy5wdXNoKGYpOyB9XFxuXFxuLy8gSW5kZW50IHRoZSBnaXZlbiBsaW5lLiBUaGUgaG93IHBhcmFtZXRlciBjYW4gYmUgXFxcInNtYXJ0XFxcIixcXG4vLyBcXFwiYWRkXFxcIi9udWxsLCBcXFwic3VidHJhY3RcXFwiLCBvciBcXFwicHJldlxcXCIuIFdoZW4gYWdncmVzc2l2ZSBpcyBmYWxzZVxcbi8vICh0eXBpY2FsbHkgc2V0IHRvIHRydWUgZm9yIGZvcmNlZCBzaW5nbGUtbGluZSBpbmRlbnRzKSwgZW1wdHlcXG4vLyBsaW5lcyBhcmUgbm90IGluZGVudGVkLCBhbmQgcGxhY2VzIHdoZXJlIHRoZSBtb2RlIHJldHVybnMgUGFzc1xcbi8vIGFyZSBsZWZ0IGFsb25lLlxcbmZ1bmN0aW9uIGluZGVudExpbmUoY20sIG4sIGhvdywgYWdncmVzc2l2ZSkge1xcbiAgdmFyIGRvYyA9IGNtLmRvYywgc3RhdGVcXG4gIGlmIChob3cgPT0gbnVsbCkgeyBob3cgPSBcXFwiYWRkXFxcIiB9XFxuICBpZiAoaG93ID09IFxcXCJzbWFydFxcXCIpIHtcXG4gICAgLy8gRmFsbCBiYWNrIHRvIFxcXCJwcmV2XFxcIiB3aGVuIHRoZSBtb2RlIGRvZXNuJ3QgaGF2ZSBhbiBpbmRlbnRhdGlvblxcbiAgICAvLyBtZXRob2QuXFxuICAgIGlmICghZG9jLm1vZGUuaW5kZW50KSB7IGhvdyA9IFxcXCJwcmV2XFxcIiB9XFxuICAgIGVsc2UgeyBzdGF0ZSA9IGdldFN0YXRlQmVmb3JlKGNtLCBuKSB9XFxuICB9XFxuXFxuICB2YXIgdGFiU2l6ZSA9IGNtLm9wdGlvbnMudGFiU2l6ZVxcbiAgdmFyIGxpbmUgPSBnZXRMaW5lKGRvYywgbiksIGN1clNwYWNlID0gY291bnRDb2x1bW4obGluZS50ZXh0LCBudWxsLCB0YWJTaXplKVxcbiAgaWYgKGxpbmUuc3RhdGVBZnRlcikgeyBsaW5lLnN0YXRlQWZ0ZXIgPSBudWxsIH1cXG4gIHZhciBjdXJTcGFjZVN0cmluZyA9IGxpbmUudGV4dC5tYXRjaCgvXlxcXFxzKi8pWzBdLCBpbmRlbnRhdGlvblxcbiAgaWYgKCFhZ2dyZXNzaXZlICYmICEvXFxcXFMvLnRlc3QobGluZS50ZXh0KSkge1xcbiAgICBpbmRlbnRhdGlvbiA9IDBcXG4gICAgaG93ID0gXFxcIm5vdFxcXCJcXG4gIH0gZWxzZSBpZiAoaG93ID09IFxcXCJzbWFydFxcXCIpIHtcXG4gICAgaW5kZW50YXRpb24gPSBkb2MubW9kZS5pbmRlbnQoc3RhdGUsIGxpbmUudGV4dC5zbGljZShjdXJTcGFjZVN0cmluZy5sZW5ndGgpLCBsaW5lLnRleHQpXFxuICAgIGlmIChpbmRlbnRhdGlvbiA9PSBQYXNzIHx8IGluZGVudGF0aW9uID4gMTUwKSB7XFxuICAgICAgaWYgKCFhZ2dyZXNzaXZlKSB7IHJldHVybiB9XFxuICAgICAgaG93ID0gXFxcInByZXZcXFwiXFxuICAgIH1cXG4gIH1cXG4gIGlmIChob3cgPT0gXFxcInByZXZcXFwiKSB7XFxuICAgIGlmIChuID4gZG9jLmZpcnN0KSB7IGluZGVudGF0aW9uID0gY291bnRDb2x1bW4oZ2V0TGluZShkb2MsIG4tMSkudGV4dCwgbnVsbCwgdGFiU2l6ZSkgfVxcbiAgICBlbHNlIHsgaW5kZW50YXRpb24gPSAwIH1cXG4gIH0gZWxzZSBpZiAoaG93ID09IFxcXCJhZGRcXFwiKSB7XFxuICAgIGluZGVudGF0aW9uID0gY3VyU3BhY2UgKyBjbS5vcHRpb25zLmluZGVudFVuaXRcXG4gIH0gZWxzZSBpZiAoaG93ID09IFxcXCJzdWJ0cmFjdFxcXCIpIHtcXG4gICAgaW5kZW50YXRpb24gPSBjdXJTcGFjZSAtIGNtLm9wdGlvbnMuaW5kZW50VW5pdFxcbiAgfSBlbHNlIGlmICh0eXBlb2YgaG93ID09IFxcXCJudW1iZXJcXFwiKSB7XFxuICAgIGluZGVudGF0aW9uID0gY3VyU3BhY2UgKyBob3dcXG4gIH1cXG4gIGluZGVudGF0aW9uID0gTWF0aC5tYXgoMCwgaW5kZW50YXRpb24pXFxuXFxuICB2YXIgaW5kZW50U3RyaW5nID0gXFxcIlxcXCIsIHBvcyA9IDBcXG4gIGlmIChjbS5vcHRpb25zLmluZGVudFdpdGhUYWJzKVxcbiAgICB7IGZvciAodmFyIGkgPSBNYXRoLmZsb29yKGluZGVudGF0aW9uIC8gdGFiU2l6ZSk7IGk7IC0taSkge3BvcyArPSB0YWJTaXplOyBpbmRlbnRTdHJpbmcgKz0gXFxcIlxcXFx0XFxcIn0gfVxcbiAgaWYgKHBvcyA8IGluZGVudGF0aW9uKSB7IGluZGVudFN0cmluZyArPSBzcGFjZVN0cihpbmRlbnRhdGlvbiAtIHBvcykgfVxcblxcbiAgaWYgKGluZGVudFN0cmluZyAhPSBjdXJTcGFjZVN0cmluZykge1xcbiAgICByZXBsYWNlUmFuZ2UoZG9jLCBpbmRlbnRTdHJpbmcsIFBvcyhuLCAwKSwgUG9zKG4sIGN1clNwYWNlU3RyaW5nLmxlbmd0aCksIFxcXCIraW5wdXRcXFwiKVxcbiAgICBsaW5lLnN0YXRlQWZ0ZXIgPSBudWxsXFxuICAgIHJldHVybiB0cnVlXFxuICB9IGVsc2Uge1xcbiAgICAvLyBFbnN1cmUgdGhhdCwgaWYgdGhlIGN1cnNvciB3YXMgaW4gdGhlIHdoaXRlc3BhY2UgYXQgdGhlIHN0YXJ0XFxuICAgIC8vIG9mIHRoZSBsaW5lLCBpdCBpcyBtb3ZlZCB0byB0aGUgZW5kIG9mIHRoYXQgc3BhY2UuXFxuICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IGRvYy5zZWwucmFuZ2VzLmxlbmd0aDsgaSQxKyspIHtcXG4gICAgICB2YXIgcmFuZ2UgPSBkb2Muc2VsLnJhbmdlc1tpJDFdXFxuICAgICAgaWYgKHJhbmdlLmhlYWQubGluZSA9PSBuICYmIHJhbmdlLmhlYWQuY2ggPCBjdXJTcGFjZVN0cmluZy5sZW5ndGgpIHtcXG4gICAgICAgIHZhciBwb3MkMSA9IFBvcyhuLCBjdXJTcGFjZVN0cmluZy5sZW5ndGgpXFxuICAgICAgICByZXBsYWNlT25lU2VsZWN0aW9uKGRvYywgaSQxLCBuZXcgUmFuZ2UocG9zJDEsIHBvcyQxKSlcXG4gICAgICAgIGJyZWFrXFxuICAgICAgfVxcbiAgICB9XFxuICB9XFxufVxcblxcbi8vIFRoaXMgd2lsbCBiZSBzZXQgdG8gYSB7bGluZVdpc2U6IGJvb2wsIHRleHQ6IFtzdHJpbmddfSBvYmplY3QsIHNvXFxuLy8gdGhhdCwgd2hlbiBwYXN0aW5nLCB3ZSBrbm93IHdoYXQga2luZCBvZiBzZWxlY3Rpb25zIHRoZSBjb3BpZWRcXG4vLyB0ZXh0IHdhcyBtYWRlIG91dCBvZi5cXG52YXIgbGFzdENvcGllZCA9IG51bGxcXG5cXG5mdW5jdGlvbiBzZXRMYXN0Q29waWVkKG5ld0xhc3RDb3BpZWQpIHtcXG4gIGxhc3RDb3BpZWQgPSBuZXdMYXN0Q29waWVkXFxufVxcblxcbmZ1bmN0aW9uIGFwcGx5VGV4dElucHV0KGNtLCBpbnNlcnRlZCwgZGVsZXRlZCwgc2VsLCBvcmlnaW4pIHtcXG4gIHZhciBkb2MgPSBjbS5kb2NcXG4gIGNtLmRpc3BsYXkuc2hpZnQgPSBmYWxzZVxcbiAgaWYgKCFzZWwpIHsgc2VsID0gZG9jLnNlbCB9XFxuXFxuICB2YXIgcGFzdGUgPSBjbS5zdGF0ZS5wYXN0ZUluY29taW5nIHx8IG9yaWdpbiA9PSBcXFwicGFzdGVcXFwiXFxuICB2YXIgdGV4dExpbmVzID0gc3BsaXRMaW5lc0F1dG8oaW5zZXJ0ZWQpLCBtdWx0aVBhc3RlID0gbnVsbFxcbiAgLy8gV2hlbiBwYXNpbmcgTiBsaW5lcyBpbnRvIE4gc2VsZWN0aW9ucywgaW5zZXJ0IG9uZSBsaW5lIHBlciBzZWxlY3Rpb25cXG4gIGlmIChwYXN0ZSAmJiBzZWwucmFuZ2VzLmxlbmd0aCA+IDEpIHtcXG4gICAgaWYgKGxhc3RDb3BpZWQgJiYgbGFzdENvcGllZC50ZXh0LmpvaW4oXFxcIlxcXFxuXFxcIikgPT0gaW5zZXJ0ZWQpIHtcXG4gICAgICBpZiAoc2VsLnJhbmdlcy5sZW5ndGggJSBsYXN0Q29waWVkLnRleHQubGVuZ3RoID09IDApIHtcXG4gICAgICAgIG11bHRpUGFzdGUgPSBbXVxcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXN0Q29waWVkLnRleHQubGVuZ3RoOyBpKyspXFxuICAgICAgICAgIHsgbXVsdGlQYXN0ZS5wdXNoKGRvYy5zcGxpdExpbmVzKGxhc3RDb3BpZWQudGV4dFtpXSkpIH1cXG4gICAgICB9XFxuICAgIH0gZWxzZSBpZiAodGV4dExpbmVzLmxlbmd0aCA9PSBzZWwucmFuZ2VzLmxlbmd0aCkge1xcbiAgICAgIG11bHRpUGFzdGUgPSBtYXAodGV4dExpbmVzLCBmdW5jdGlvbiAobCkgeyByZXR1cm4gW2xdOyB9KVxcbiAgICB9XFxuICB9XFxuXFxuICB2YXIgdXBkYXRlSW5wdXRcXG4gIC8vIE5vcm1hbCBiZWhhdmlvciBpcyB0byBpbnNlcnQgdGhlIG5ldyB0ZXh0IGludG8gZXZlcnkgc2VsZWN0aW9uXFxuICBmb3IgKHZhciBpJDEgPSBzZWwucmFuZ2VzLmxlbmd0aCAtIDE7IGkkMSA+PSAwOyBpJDEtLSkge1xcbiAgICB2YXIgcmFuZ2UgPSBzZWwucmFuZ2VzW2kkMV1cXG4gICAgdmFyIGZyb20gPSByYW5nZS5mcm9tKCksIHRvID0gcmFuZ2UudG8oKVxcbiAgICBpZiAocmFuZ2UuZW1wdHkoKSkge1xcbiAgICAgIGlmIChkZWxldGVkICYmIGRlbGV0ZWQgPiAwKSAvLyBIYW5kbGUgZGVsZXRpb25cXG4gICAgICAgIHsgZnJvbSA9IFBvcyhmcm9tLmxpbmUsIGZyb20uY2ggLSBkZWxldGVkKSB9XFxuICAgICAgZWxzZSBpZiAoY20uc3RhdGUub3ZlcndyaXRlICYmICFwYXN0ZSkgLy8gSGFuZGxlIG92ZXJ3cml0ZVxcbiAgICAgICAgeyB0byA9IFBvcyh0by5saW5lLCBNYXRoLm1pbihnZXRMaW5lKGRvYywgdG8ubGluZSkudGV4dC5sZW5ndGgsIHRvLmNoICsgbHN0KHRleHRMaW5lcykubGVuZ3RoKSkgfVxcbiAgICAgIGVsc2UgaWYgKGxhc3RDb3BpZWQgJiYgbGFzdENvcGllZC5saW5lV2lzZSAmJiBsYXN0Q29waWVkLnRleHQuam9pbihcXFwiXFxcXG5cXFwiKSA9PSBpbnNlcnRlZClcXG4gICAgICAgIHsgZnJvbSA9IHRvID0gUG9zKGZyb20ubGluZSwgMCkgfVxcbiAgICB9XFxuICAgIHVwZGF0ZUlucHV0ID0gY20uY3VyT3AudXBkYXRlSW5wdXRcXG4gICAgdmFyIGNoYW5nZUV2ZW50ID0ge2Zyb206IGZyb20sIHRvOiB0bywgdGV4dDogbXVsdGlQYXN0ZSA/IG11bHRpUGFzdGVbaSQxICUgbXVsdGlQYXN0ZS5sZW5ndGhdIDogdGV4dExpbmVzLFxcbiAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luOiBvcmlnaW4gfHwgKHBhc3RlID8gXFxcInBhc3RlXFxcIiA6IGNtLnN0YXRlLmN1dEluY29taW5nID8gXFxcImN1dFxcXCIgOiBcXFwiK2lucHV0XFxcIil9XFxuICAgIG1ha2VDaGFuZ2UoY20uZG9jLCBjaGFuZ2VFdmVudClcXG4gICAgc2lnbmFsTGF0ZXIoY20sIFxcXCJpbnB1dFJlYWRcXFwiLCBjbSwgY2hhbmdlRXZlbnQpXFxuICB9XFxuICBpZiAoaW5zZXJ0ZWQgJiYgIXBhc3RlKVxcbiAgICB7IHRyaWdnZXJFbGVjdHJpYyhjbSwgaW5zZXJ0ZWQpIH1cXG5cXG4gIGVuc3VyZUN1cnNvclZpc2libGUoY20pXFxuICBjbS5jdXJPcC51cGRhdGVJbnB1dCA9IHVwZGF0ZUlucHV0XFxuICBjbS5jdXJPcC50eXBpbmcgPSB0cnVlXFxuICBjbS5zdGF0ZS5wYXN0ZUluY29taW5nID0gY20uc3RhdGUuY3V0SW5jb21pbmcgPSBmYWxzZVxcbn1cXG5cXG5mdW5jdGlvbiBoYW5kbGVQYXN0ZShlLCBjbSkge1xcbiAgdmFyIHBhc3RlZCA9IGUuY2xpcGJvYXJkRGF0YSAmJiBlLmNsaXBib2FyZERhdGEuZ2V0RGF0YShcXFwiVGV4dFxcXCIpXFxuICBpZiAocGFzdGVkKSB7XFxuICAgIGUucHJldmVudERlZmF1bHQoKVxcbiAgICBpZiAoIWNtLmlzUmVhZE9ubHkoKSAmJiAhY20ub3B0aW9ucy5kaXNhYmxlSW5wdXQpXFxuICAgICAgeyBydW5Jbk9wKGNtLCBmdW5jdGlvbiAoKSB7IHJldHVybiBhcHBseVRleHRJbnB1dChjbSwgcGFzdGVkLCAwLCBudWxsLCBcXFwicGFzdGVcXFwiKTsgfSkgfVxcbiAgICByZXR1cm4gdHJ1ZVxcbiAgfVxcbn1cXG5cXG5mdW5jdGlvbiB0cmlnZ2VyRWxlY3RyaWMoY20sIGluc2VydGVkKSB7XFxuICAvLyBXaGVuIGFuICdlbGVjdHJpYycgY2hhcmFjdGVyIGlzIGluc2VydGVkLCBpbW1lZGlhdGVseSB0cmlnZ2VyIGEgcmVpbmRlbnRcXG4gIGlmICghY20ub3B0aW9ucy5lbGVjdHJpY0NoYXJzIHx8ICFjbS5vcHRpb25zLnNtYXJ0SW5kZW50KSB7IHJldHVybiB9XFxuICB2YXIgc2VsID0gY20uZG9jLnNlbFxcblxcbiAgZm9yICh2YXIgaSA9IHNlbC5yYW5nZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcXG4gICAgdmFyIHJhbmdlID0gc2VsLnJhbmdlc1tpXVxcbiAgICBpZiAocmFuZ2UuaGVhZC5jaCA+IDEwMCB8fCAoaSAmJiBzZWwucmFuZ2VzW2kgLSAxXS5oZWFkLmxpbmUgPT0gcmFuZ2UuaGVhZC5saW5lKSkgeyBjb250aW51ZSB9XFxuICAgIHZhciBtb2RlID0gY20uZ2V0TW9kZUF0KHJhbmdlLmhlYWQpXFxuICAgIHZhciBpbmRlbnRlZCA9IGZhbHNlXFxuICAgIGlmIChtb2RlLmVsZWN0cmljQ2hhcnMpIHtcXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG1vZGUuZWxlY3RyaWNDaGFycy5sZW5ndGg7IGorKylcXG4gICAgICAgIHsgaWYgKGluc2VydGVkLmluZGV4T2YobW9kZS5lbGVjdHJpY0NoYXJzLmNoYXJBdChqKSkgPiAtMSkge1xcbiAgICAgICAgICBpbmRlbnRlZCA9IGluZGVudExpbmUoY20sIHJhbmdlLmhlYWQubGluZSwgXFxcInNtYXJ0XFxcIilcXG4gICAgICAgICAgYnJlYWtcXG4gICAgICAgIH0gfVxcbiAgICB9IGVsc2UgaWYgKG1vZGUuZWxlY3RyaWNJbnB1dCkge1xcbiAgICAgIGlmIChtb2RlLmVsZWN0cmljSW5wdXQudGVzdChnZXRMaW5lKGNtLmRvYywgcmFuZ2UuaGVhZC5saW5lKS50ZXh0LnNsaWNlKDAsIHJhbmdlLmhlYWQuY2gpKSlcXG4gICAgICAgIHsgaW5kZW50ZWQgPSBpbmRlbnRMaW5lKGNtLCByYW5nZS5oZWFkLmxpbmUsIFxcXCJzbWFydFxcXCIpIH1cXG4gICAgfVxcbiAgICBpZiAoaW5kZW50ZWQpIHsgc2lnbmFsTGF0ZXIoY20sIFxcXCJlbGVjdHJpY0lucHV0XFxcIiwgY20sIHJhbmdlLmhlYWQubGluZSkgfVxcbiAgfVxcbn1cXG5cXG5mdW5jdGlvbiBjb3B5YWJsZVJhbmdlcyhjbSkge1xcbiAgdmFyIHRleHQgPSBbXSwgcmFuZ2VzID0gW11cXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY20uZG9jLnNlbC5yYW5nZXMubGVuZ3RoOyBpKyspIHtcXG4gICAgdmFyIGxpbmUgPSBjbS5kb2Muc2VsLnJhbmdlc1tpXS5oZWFkLmxpbmVcXG4gICAgdmFyIGxpbmVSYW5nZSA9IHthbmNob3I6IFBvcyhsaW5lLCAwKSwgaGVhZDogUG9zKGxpbmUgKyAxLCAwKX1cXG4gICAgcmFuZ2VzLnB1c2gobGluZVJhbmdlKVxcbiAgICB0ZXh0LnB1c2goY20uZ2V0UmFuZ2UobGluZVJhbmdlLmFuY2hvciwgbGluZVJhbmdlLmhlYWQpKVxcbiAgfVxcbiAgcmV0dXJuIHt0ZXh0OiB0ZXh0LCByYW5nZXM6IHJhbmdlc31cXG59XFxuXFxuZnVuY3Rpb24gZGlzYWJsZUJyb3dzZXJNYWdpYyhmaWVsZCwgc3BlbGxjaGVjaykge1xcbiAgZmllbGQuc2V0QXR0cmlidXRlKFxcXCJhdXRvY29ycmVjdFxcXCIsIFxcXCJvZmZcXFwiKVxcbiAgZmllbGQuc2V0QXR0cmlidXRlKFxcXCJhdXRvY2FwaXRhbGl6ZVxcXCIsIFxcXCJvZmZcXFwiKVxcbiAgZmllbGQuc2V0QXR0cmlidXRlKFxcXCJzcGVsbGNoZWNrXFxcIiwgISFzcGVsbGNoZWNrKVxcbn1cXG5cXG5mdW5jdGlvbiBoaWRkZW5UZXh0YXJlYSgpIHtcXG4gIHZhciB0ZSA9IGVsdChcXFwidGV4dGFyZWFcXFwiLCBudWxsLCBudWxsLCBcXFwicG9zaXRpb246IGFic29sdXRlOyBib3R0b206IC0xZW07IHBhZGRpbmc6IDA7IHdpZHRoOiAxcHg7IGhlaWdodDogMWVtOyBvdXRsaW5lOiBub25lXFxcIilcXG4gIHZhciBkaXYgPSBlbHQoXFxcImRpdlxcXCIsIFt0ZV0sIG51bGwsIFxcXCJvdmVyZmxvdzogaGlkZGVuOyBwb3NpdGlvbjogcmVsYXRpdmU7IHdpZHRoOiAzcHg7IGhlaWdodDogMHB4O1xcXCIpXFxuICAvLyBUaGUgdGV4dGFyZWEgaXMga2VwdCBwb3NpdGlvbmVkIG5lYXIgdGhlIGN1cnNvciB0byBwcmV2ZW50IHRoZVxcbiAgLy8gZmFjdCB0aGF0IGl0J2xsIGJlIHNjcm9sbGVkIGludG8gdmlldyBvbiBpbnB1dCBmcm9tIHNjcm9sbGluZ1xcbiAgLy8gb3VyIGZha2UgY3Vyc29yIG91dCBvZiB2aWV3LiBPbiB3ZWJraXQsIHdoZW4gd3JhcD1vZmYsIHBhc3RlIGlzXFxuICAvLyB2ZXJ5IHNsb3cuIFNvIG1ha2UgdGhlIGFyZWEgd2lkZSBpbnN0ZWFkLlxcbiAgaWYgKHdlYmtpdCkgeyB0ZS5zdHlsZS53aWR0aCA9IFxcXCIxMDAwcHhcXFwiIH1cXG4gIGVsc2UgeyB0ZS5zZXRBdHRyaWJ1dGUoXFxcIndyYXBcXFwiLCBcXFwib2ZmXFxcIikgfVxcbiAgLy8gSWYgYm9yZGVyOiAwOyAtLSBpT1MgZmFpbHMgdG8gb3BlbiBrZXlib2FyZCAoaXNzdWUgIzEyODcpXFxuICBpZiAoaW9zKSB7IHRlLnN0eWxlLmJvcmRlciA9IFxcXCIxcHggc29saWQgYmxhY2tcXFwiIH1cXG4gIGRpc2FibGVCcm93c2VyTWFnaWModGUpXFxuICByZXR1cm4gZGl2XFxufVxcblxcbi8vIFRoZSBwdWJsaWNseSB2aXNpYmxlIEFQSS4gTm90ZSB0aGF0IG1ldGhvZE9wKGYpIG1lYW5zXFxuLy8gJ3dyYXAgZiBpbiBhbiBvcGVyYXRpb24sIHBlcmZvcm1lZCBvbiBpdHMgYHRoaXNgIHBhcmFtZXRlcicuXFxuXFxuLy8gVGhpcyBpcyBub3QgdGhlIGNvbXBsZXRlIHNldCBvZiBlZGl0b3IgbWV0aG9kcy4gTW9zdCBvZiB0aGVcXG4vLyBtZXRob2RzIGRlZmluZWQgb24gdGhlIERvYyB0eXBlIGFyZSBhbHNvIGluamVjdGVkIGludG9cXG4vLyBDb2RlTWlycm9yLnByb3RvdHlwZSwgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IGFuZFxcbi8vIGNvbnZlbmllbmNlLlxcblxcbmZ1bmN0aW9uIGFkZEVkaXRvck1ldGhvZHMoQ29kZU1pcnJvcikge1xcbiAgdmFyIG9wdGlvbkhhbmRsZXJzID0gQ29kZU1pcnJvci5vcHRpb25IYW5kbGVyc1xcblxcbiAgdmFyIGhlbHBlcnMgPSBDb2RlTWlycm9yLmhlbHBlcnMgPSB7fVxcblxcbiAgQ29kZU1pcnJvci5wcm90b3R5cGUgPSB7XFxuICAgIGNvbnN0cnVjdG9yOiBDb2RlTWlycm9yLFxcbiAgICBmb2N1czogZnVuY3Rpb24oKXt3aW5kb3cuZm9jdXMoKTsgdGhpcy5kaXNwbGF5LmlucHV0LmZvY3VzKCl9LFxcblxcbiAgICBzZXRPcHRpb246IGZ1bmN0aW9uKG9wdGlvbiwgdmFsdWUpIHtcXG4gICAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucywgb2xkID0gb3B0aW9uc1tvcHRpb25dXFxuICAgICAgaWYgKG9wdGlvbnNbb3B0aW9uXSA9PSB2YWx1ZSAmJiBvcHRpb24gIT0gXFxcIm1vZGVcXFwiKSB7IHJldHVybiB9XFxuICAgICAgb3B0aW9uc1tvcHRpb25dID0gdmFsdWVcXG4gICAgICBpZiAob3B0aW9uSGFuZGxlcnMuaGFzT3duUHJvcGVydHkob3B0aW9uKSlcXG4gICAgICAgIHsgb3BlcmF0aW9uKHRoaXMsIG9wdGlvbkhhbmRsZXJzW29wdGlvbl0pKHRoaXMsIHZhbHVlLCBvbGQpIH1cXG4gICAgICBzaWduYWwodGhpcywgXFxcIm9wdGlvbkNoYW5nZVxcXCIsIHRoaXMsIG9wdGlvbilcXG4gICAgfSxcXG5cXG4gICAgZ2V0T3B0aW9uOiBmdW5jdGlvbihvcHRpb24pIHtyZXR1cm4gdGhpcy5vcHRpb25zW29wdGlvbl19LFxcbiAgICBnZXREb2M6IGZ1bmN0aW9uKCkge3JldHVybiB0aGlzLmRvY30sXFxuXFxuICAgIGFkZEtleU1hcDogZnVuY3Rpb24obWFwLCBib3R0b20pIHtcXG4gICAgICB0aGlzLnN0YXRlLmtleU1hcHNbYm90dG9tID8gXFxcInB1c2hcXFwiIDogXFxcInVuc2hpZnRcXFwiXShnZXRLZXlNYXAobWFwKSlcXG4gICAgfSxcXG4gICAgcmVtb3ZlS2V5TWFwOiBmdW5jdGlvbihtYXApIHtcXG4gICAgICB2YXIgbWFwcyA9IHRoaXMuc3RhdGUua2V5TWFwc1xcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWFwcy5sZW5ndGg7ICsraSlcXG4gICAgICAgIHsgaWYgKG1hcHNbaV0gPT0gbWFwIHx8IG1hcHNbaV0ubmFtZSA9PSBtYXApIHtcXG4gICAgICAgICAgbWFwcy5zcGxpY2UoaSwgMSlcXG4gICAgICAgICAgcmV0dXJuIHRydWVcXG4gICAgICAgIH0gfVxcbiAgICB9LFxcblxcbiAgICBhZGRPdmVybGF5OiBtZXRob2RPcChmdW5jdGlvbihzcGVjLCBvcHRpb25zKSB7XFxuICAgICAgdmFyIG1vZGUgPSBzcGVjLnRva2VuID8gc3BlYyA6IENvZGVNaXJyb3IuZ2V0TW9kZSh0aGlzLm9wdGlvbnMsIHNwZWMpXFxuICAgICAgaWYgKG1vZGUuc3RhcnRTdGF0ZSkgeyB0aHJvdyBuZXcgRXJyb3IoXFxcIk92ZXJsYXlzIG1heSBub3QgYmUgc3RhdGVmdWwuXFxcIikgfVxcbiAgICAgIGluc2VydFNvcnRlZCh0aGlzLnN0YXRlLm92ZXJsYXlzLFxcbiAgICAgICAgICAgICAgICAgICB7bW9kZTogbW9kZSwgbW9kZVNwZWM6IHNwZWMsIG9wYXF1ZTogb3B0aW9ucyAmJiBvcHRpb25zLm9wYXF1ZSxcXG4gICAgICAgICAgICAgICAgICAgIHByaW9yaXR5OiAob3B0aW9ucyAmJiBvcHRpb25zLnByaW9yaXR5KSB8fCAwfSxcXG4gICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKG92ZXJsYXkpIHsgcmV0dXJuIG92ZXJsYXkucHJpb3JpdHk7IH0pXFxuICAgICAgdGhpcy5zdGF0ZS5tb2RlR2VuKytcXG4gICAgICByZWdDaGFuZ2UodGhpcylcXG4gICAgfSksXFxuICAgIHJlbW92ZU92ZXJsYXk6IG1ldGhvZE9wKGZ1bmN0aW9uKHNwZWMpIHtcXG4gICAgICB2YXIgdGhpcyQxID0gdGhpcztcXG5cXG4gICAgICB2YXIgb3ZlcmxheXMgPSB0aGlzLnN0YXRlLm92ZXJsYXlzXFxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvdmVybGF5cy5sZW5ndGg7ICsraSkge1xcbiAgICAgICAgdmFyIGN1ciA9IG92ZXJsYXlzW2ldLm1vZGVTcGVjXFxuICAgICAgICBpZiAoY3VyID09IHNwZWMgfHwgdHlwZW9mIHNwZWMgPT0gXFxcInN0cmluZ1xcXCIgJiYgY3VyLm5hbWUgPT0gc3BlYykge1xcbiAgICAgICAgICBvdmVybGF5cy5zcGxpY2UoaSwgMSlcXG4gICAgICAgICAgdGhpcyQxLnN0YXRlLm1vZGVHZW4rK1xcbiAgICAgICAgICByZWdDaGFuZ2UodGhpcyQxKVxcbiAgICAgICAgICByZXR1cm5cXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIH0pLFxcblxcbiAgICBpbmRlbnRMaW5lOiBtZXRob2RPcChmdW5jdGlvbihuLCBkaXIsIGFnZ3Jlc3NpdmUpIHtcXG4gICAgICBpZiAodHlwZW9mIGRpciAhPSBcXFwic3RyaW5nXFxcIiAmJiB0eXBlb2YgZGlyICE9IFxcXCJudW1iZXJcXFwiKSB7XFxuICAgICAgICBpZiAoZGlyID09IG51bGwpIHsgZGlyID0gdGhpcy5vcHRpb25zLnNtYXJ0SW5kZW50ID8gXFxcInNtYXJ0XFxcIiA6IFxcXCJwcmV2XFxcIiB9XFxuICAgICAgICBlbHNlIHsgZGlyID0gZGlyID8gXFxcImFkZFxcXCIgOiBcXFwic3VidHJhY3RcXFwiIH1cXG4gICAgICB9XFxuICAgICAgaWYgKGlzTGluZSh0aGlzLmRvYywgbikpIHsgaW5kZW50TGluZSh0aGlzLCBuLCBkaXIsIGFnZ3Jlc3NpdmUpIH1cXG4gICAgfSksXFxuICAgIGluZGVudFNlbGVjdGlvbjogbWV0aG9kT3AoZnVuY3Rpb24oaG93KSB7XFxuICAgICAgdmFyIHRoaXMkMSA9IHRoaXM7XFxuXFxuICAgICAgdmFyIHJhbmdlcyA9IHRoaXMuZG9jLnNlbC5yYW5nZXMsIGVuZCA9IC0xXFxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByYW5nZXMubGVuZ3RoOyBpKyspIHtcXG4gICAgICAgIHZhciByYW5nZSA9IHJhbmdlc1tpXVxcbiAgICAgICAgaWYgKCFyYW5nZS5lbXB0eSgpKSB7XFxuICAgICAgICAgIHZhciBmcm9tID0gcmFuZ2UuZnJvbSgpLCB0byA9IHJhbmdlLnRvKClcXG4gICAgICAgICAgdmFyIHN0YXJ0ID0gTWF0aC5tYXgoZW5kLCBmcm9tLmxpbmUpXFxuICAgICAgICAgIGVuZCA9IE1hdGgubWluKHRoaXMkMS5sYXN0TGluZSgpLCB0by5saW5lIC0gKHRvLmNoID8gMCA6IDEpKSArIDFcXG4gICAgICAgICAgZm9yICh2YXIgaiA9IHN0YXJ0OyBqIDwgZW5kOyArK2opXFxuICAgICAgICAgICAgeyBpbmRlbnRMaW5lKHRoaXMkMSwgaiwgaG93KSB9XFxuICAgICAgICAgIHZhciBuZXdSYW5nZXMgPSB0aGlzJDEuZG9jLnNlbC5yYW5nZXNcXG4gICAgICAgICAgaWYgKGZyb20uY2ggPT0gMCAmJiByYW5nZXMubGVuZ3RoID09IG5ld1Jhbmdlcy5sZW5ndGggJiYgbmV3UmFuZ2VzW2ldLmZyb20oKS5jaCA+IDApXFxuICAgICAgICAgICAgeyByZXBsYWNlT25lU2VsZWN0aW9uKHRoaXMkMS5kb2MsIGksIG5ldyBSYW5nZShmcm9tLCBuZXdSYW5nZXNbaV0udG8oKSksIHNlbF9kb250U2Nyb2xsKSB9XFxuICAgICAgICB9IGVsc2UgaWYgKHJhbmdlLmhlYWQubGluZSA+IGVuZCkge1xcbiAgICAgICAgICBpbmRlbnRMaW5lKHRoaXMkMSwgcmFuZ2UuaGVhZC5saW5lLCBob3csIHRydWUpXFxuICAgICAgICAgIGVuZCA9IHJhbmdlLmhlYWQubGluZVxcbiAgICAgICAgICBpZiAoaSA9PSB0aGlzJDEuZG9jLnNlbC5wcmltSW5kZXgpIHsgZW5zdXJlQ3Vyc29yVmlzaWJsZSh0aGlzJDEpIH1cXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIH0pLFxcblxcbiAgICAvLyBGZXRjaCB0aGUgcGFyc2VyIHRva2VuIGZvciBhIGdpdmVuIGNoYXJhY3Rlci4gVXNlZnVsIGZvciBoYWNrc1xcbiAgICAvLyB0aGF0IHdhbnQgdG8gaW5zcGVjdCB0aGUgbW9kZSBzdGF0ZSAoc2F5LCBmb3IgY29tcGxldGlvbikuXFxuICAgIGdldFRva2VuQXQ6IGZ1bmN0aW9uKHBvcywgcHJlY2lzZSkge1xcbiAgICAgIHJldHVybiB0YWtlVG9rZW4odGhpcywgcG9zLCBwcmVjaXNlKVxcbiAgICB9LFxcblxcbiAgICBnZXRMaW5lVG9rZW5zOiBmdW5jdGlvbihsaW5lLCBwcmVjaXNlKSB7XFxuICAgICAgcmV0dXJuIHRha2VUb2tlbih0aGlzLCBQb3MobGluZSksIHByZWNpc2UsIHRydWUpXFxuICAgIH0sXFxuXFxuICAgIGdldFRva2VuVHlwZUF0OiBmdW5jdGlvbihwb3MpIHtcXG4gICAgICBwb3MgPSBjbGlwUG9zKHRoaXMuZG9jLCBwb3MpXFxuICAgICAgdmFyIHN0eWxlcyA9IGdldExpbmVTdHlsZXModGhpcywgZ2V0TGluZSh0aGlzLmRvYywgcG9zLmxpbmUpKVxcbiAgICAgIHZhciBiZWZvcmUgPSAwLCBhZnRlciA9IChzdHlsZXMubGVuZ3RoIC0gMSkgLyAyLCBjaCA9IHBvcy5jaFxcbiAgICAgIHZhciB0eXBlXFxuICAgICAgaWYgKGNoID09IDApIHsgdHlwZSA9IHN0eWxlc1syXSB9XFxuICAgICAgZWxzZSB7IGZvciAoOzspIHtcXG4gICAgICAgIHZhciBtaWQgPSAoYmVmb3JlICsgYWZ0ZXIpID4+IDFcXG4gICAgICAgIGlmICgobWlkID8gc3R5bGVzW21pZCAqIDIgLSAxXSA6IDApID49IGNoKSB7IGFmdGVyID0gbWlkIH1cXG4gICAgICAgIGVsc2UgaWYgKHN0eWxlc1ttaWQgKiAyICsgMV0gPCBjaCkgeyBiZWZvcmUgPSBtaWQgKyAxIH1cXG4gICAgICAgIGVsc2UgeyB0eXBlID0gc3R5bGVzW21pZCAqIDIgKyAyXTsgYnJlYWsgfVxcbiAgICAgIH0gfVxcbiAgICAgIHZhciBjdXQgPSB0eXBlID8gdHlwZS5pbmRleE9mKFxcXCJvdmVybGF5IFxcXCIpIDogLTFcXG4gICAgICByZXR1cm4gY3V0IDwgMCA/IHR5cGUgOiBjdXQgPT0gMCA/IG51bGwgOiB0eXBlLnNsaWNlKDAsIGN1dCAtIDEpXFxuICAgIH0sXFxuXFxuICAgIGdldE1vZGVBdDogZnVuY3Rpb24ocG9zKSB7XFxuICAgICAgdmFyIG1vZGUgPSB0aGlzLmRvYy5tb2RlXFxuICAgICAgaWYgKCFtb2RlLmlubmVyTW9kZSkgeyByZXR1cm4gbW9kZSB9XFxuICAgICAgcmV0dXJuIENvZGVNaXJyb3IuaW5uZXJNb2RlKG1vZGUsIHRoaXMuZ2V0VG9rZW5BdChwb3MpLnN0YXRlKS5tb2RlXFxuICAgIH0sXFxuXFxuICAgIGdldEhlbHBlcjogZnVuY3Rpb24ocG9zLCB0eXBlKSB7XFxuICAgICAgcmV0dXJuIHRoaXMuZ2V0SGVscGVycyhwb3MsIHR5cGUpWzBdXFxuICAgIH0sXFxuXFxuICAgIGdldEhlbHBlcnM6IGZ1bmN0aW9uKHBvcywgdHlwZSkge1xcbiAgICAgIHZhciB0aGlzJDEgPSB0aGlzO1xcblxcbiAgICAgIHZhciBmb3VuZCA9IFtdXFxuICAgICAgaWYgKCFoZWxwZXJzLmhhc093blByb3BlcnR5KHR5cGUpKSB7IHJldHVybiBmb3VuZCB9XFxuICAgICAgdmFyIGhlbHAgPSBoZWxwZXJzW3R5cGVdLCBtb2RlID0gdGhpcy5nZXRNb2RlQXQocG9zKVxcbiAgICAgIGlmICh0eXBlb2YgbW9kZVt0eXBlXSA9PSBcXFwic3RyaW5nXFxcIikge1xcbiAgICAgICAgaWYgKGhlbHBbbW9kZVt0eXBlXV0pIHsgZm91bmQucHVzaChoZWxwW21vZGVbdHlwZV1dKSB9XFxuICAgICAgfSBlbHNlIGlmIChtb2RlW3R5cGVdKSB7XFxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1vZGVbdHlwZV0ubGVuZ3RoOyBpKyspIHtcXG4gICAgICAgICAgdmFyIHZhbCA9IGhlbHBbbW9kZVt0eXBlXVtpXV1cXG4gICAgICAgICAgaWYgKHZhbCkgeyBmb3VuZC5wdXNoKHZhbCkgfVxcbiAgICAgICAgfVxcbiAgICAgIH0gZWxzZSBpZiAobW9kZS5oZWxwZXJUeXBlICYmIGhlbHBbbW9kZS5oZWxwZXJUeXBlXSkge1xcbiAgICAgICAgZm91bmQucHVzaChoZWxwW21vZGUuaGVscGVyVHlwZV0pXFxuICAgICAgfSBlbHNlIGlmIChoZWxwW21vZGUubmFtZV0pIHtcXG4gICAgICAgIGZvdW5kLnB1c2goaGVscFttb2RlLm5hbWVdKVxcbiAgICAgIH1cXG4gICAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBoZWxwLl9nbG9iYWwubGVuZ3RoOyBpJDErKykge1xcbiAgICAgICAgdmFyIGN1ciA9IGhlbHAuX2dsb2JhbFtpJDFdXFxuICAgICAgICBpZiAoY3VyLnByZWQobW9kZSwgdGhpcyQxKSAmJiBpbmRleE9mKGZvdW5kLCBjdXIudmFsKSA9PSAtMSlcXG4gICAgICAgICAgeyBmb3VuZC5wdXNoKGN1ci52YWwpIH1cXG4gICAgICB9XFxuICAgICAgcmV0dXJuIGZvdW5kXFxuICAgIH0sXFxuXFxuICAgIGdldFN0YXRlQWZ0ZXI6IGZ1bmN0aW9uKGxpbmUsIHByZWNpc2UpIHtcXG4gICAgICB2YXIgZG9jID0gdGhpcy5kb2NcXG4gICAgICBsaW5lID0gY2xpcExpbmUoZG9jLCBsaW5lID09IG51bGwgPyBkb2MuZmlyc3QgKyBkb2Muc2l6ZSAtIDE6IGxpbmUpXFxuICAgICAgcmV0dXJuIGdldFN0YXRlQmVmb3JlKHRoaXMsIGxpbmUgKyAxLCBwcmVjaXNlKVxcbiAgICB9LFxcblxcbiAgICBjdXJzb3JDb29yZHM6IGZ1bmN0aW9uKHN0YXJ0LCBtb2RlKSB7XFxuICAgICAgdmFyIHBvcywgcmFuZ2UgPSB0aGlzLmRvYy5zZWwucHJpbWFyeSgpXFxuICAgICAgaWYgKHN0YXJ0ID09IG51bGwpIHsgcG9zID0gcmFuZ2UuaGVhZCB9XFxuICAgICAgZWxzZSBpZiAodHlwZW9mIHN0YXJ0ID09IFxcXCJvYmplY3RcXFwiKSB7IHBvcyA9IGNsaXBQb3ModGhpcy5kb2MsIHN0YXJ0KSB9XFxuICAgICAgZWxzZSB7IHBvcyA9IHN0YXJ0ID8gcmFuZ2UuZnJvbSgpIDogcmFuZ2UudG8oKSB9XFxuICAgICAgcmV0dXJuIGN1cnNvckNvb3Jkcyh0aGlzLCBwb3MsIG1vZGUgfHwgXFxcInBhZ2VcXFwiKVxcbiAgICB9LFxcblxcbiAgICBjaGFyQ29vcmRzOiBmdW5jdGlvbihwb3MsIG1vZGUpIHtcXG4gICAgICByZXR1cm4gY2hhckNvb3Jkcyh0aGlzLCBjbGlwUG9zKHRoaXMuZG9jLCBwb3MpLCBtb2RlIHx8IFxcXCJwYWdlXFxcIilcXG4gICAgfSxcXG5cXG4gICAgY29vcmRzQ2hhcjogZnVuY3Rpb24oY29vcmRzLCBtb2RlKSB7XFxuICAgICAgY29vcmRzID0gZnJvbUNvb3JkU3lzdGVtKHRoaXMsIGNvb3JkcywgbW9kZSB8fCBcXFwicGFnZVxcXCIpXFxuICAgICAgcmV0dXJuIGNvb3Jkc0NoYXIodGhpcywgY29vcmRzLmxlZnQsIGNvb3Jkcy50b3ApXFxuICAgIH0sXFxuXFxuICAgIGxpbmVBdEhlaWdodDogZnVuY3Rpb24oaGVpZ2h0LCBtb2RlKSB7XFxuICAgICAgaGVpZ2h0ID0gZnJvbUNvb3JkU3lzdGVtKHRoaXMsIHt0b3A6IGhlaWdodCwgbGVmdDogMH0sIG1vZGUgfHwgXFxcInBhZ2VcXFwiKS50b3BcXG4gICAgICByZXR1cm4gbGluZUF0SGVpZ2h0KHRoaXMuZG9jLCBoZWlnaHQgKyB0aGlzLmRpc3BsYXkudmlld09mZnNldClcXG4gICAgfSxcXG4gICAgaGVpZ2h0QXRMaW5lOiBmdW5jdGlvbihsaW5lLCBtb2RlLCBpbmNsdWRlV2lkZ2V0cykge1xcbiAgICAgIHZhciBlbmQgPSBmYWxzZSwgbGluZU9ialxcbiAgICAgIGlmICh0eXBlb2YgbGluZSA9PSBcXFwibnVtYmVyXFxcIikge1xcbiAgICAgICAgdmFyIGxhc3QgPSB0aGlzLmRvYy5maXJzdCArIHRoaXMuZG9jLnNpemUgLSAxXFxuICAgICAgICBpZiAobGluZSA8IHRoaXMuZG9jLmZpcnN0KSB7IGxpbmUgPSB0aGlzLmRvYy5maXJzdCB9XFxuICAgICAgICBlbHNlIGlmIChsaW5lID4gbGFzdCkgeyBsaW5lID0gbGFzdDsgZW5kID0gdHJ1ZSB9XFxuICAgICAgICBsaW5lT2JqID0gZ2V0TGluZSh0aGlzLmRvYywgbGluZSlcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgbGluZU9iaiA9IGxpbmVcXG4gICAgICB9XFxuICAgICAgcmV0dXJuIGludG9Db29yZFN5c3RlbSh0aGlzLCBsaW5lT2JqLCB7dG9wOiAwLCBsZWZ0OiAwfSwgbW9kZSB8fCBcXFwicGFnZVxcXCIsIGluY2x1ZGVXaWRnZXRzKS50b3AgK1xcbiAgICAgICAgKGVuZCA/IHRoaXMuZG9jLmhlaWdodCAtIGhlaWdodEF0TGluZShsaW5lT2JqKSA6IDApXFxuICAgIH0sXFxuXFxuICAgIGRlZmF1bHRUZXh0SGVpZ2h0OiBmdW5jdGlvbigpIHsgcmV0dXJuIHRleHRIZWlnaHQodGhpcy5kaXNwbGF5KSB9LFxcbiAgICBkZWZhdWx0Q2hhcldpZHRoOiBmdW5jdGlvbigpIHsgcmV0dXJuIGNoYXJXaWR0aCh0aGlzLmRpc3BsYXkpIH0sXFxuXFxuICAgIGdldFZpZXdwb3J0OiBmdW5jdGlvbigpIHsgcmV0dXJuIHtmcm9tOiB0aGlzLmRpc3BsYXkudmlld0Zyb20sIHRvOiB0aGlzLmRpc3BsYXkudmlld1RvfX0sXFxuXFxuICAgIGFkZFdpZGdldDogZnVuY3Rpb24ocG9zLCBub2RlLCBzY3JvbGwsIHZlcnQsIGhvcml6KSB7XFxuICAgICAgdmFyIGRpc3BsYXkgPSB0aGlzLmRpc3BsYXlcXG4gICAgICBwb3MgPSBjdXJzb3JDb29yZHModGhpcywgY2xpcFBvcyh0aGlzLmRvYywgcG9zKSlcXG4gICAgICB2YXIgdG9wID0gcG9zLmJvdHRvbSwgbGVmdCA9IHBvcy5sZWZ0XFxuICAgICAgbm9kZS5zdHlsZS5wb3NpdGlvbiA9IFxcXCJhYnNvbHV0ZVxcXCJcXG4gICAgICBub2RlLnNldEF0dHJpYnV0ZShcXFwiY20taWdub3JlLWV2ZW50c1xcXCIsIFxcXCJ0cnVlXFxcIilcXG4gICAgICB0aGlzLmRpc3BsYXkuaW5wdXQuc2V0VW5lZGl0YWJsZShub2RlKVxcbiAgICAgIGRpc3BsYXkuc2l6ZXIuYXBwZW5kQ2hpbGQobm9kZSlcXG4gICAgICBpZiAodmVydCA9PSBcXFwib3ZlclxcXCIpIHtcXG4gICAgICAgIHRvcCA9IHBvcy50b3BcXG4gICAgICB9IGVsc2UgaWYgKHZlcnQgPT0gXFxcImFib3ZlXFxcIiB8fCB2ZXJ0ID09IFxcXCJuZWFyXFxcIikge1xcbiAgICAgICAgdmFyIHZzcGFjZSA9IE1hdGgubWF4KGRpc3BsYXkud3JhcHBlci5jbGllbnRIZWlnaHQsIHRoaXMuZG9jLmhlaWdodCksXFxuICAgICAgICBoc3BhY2UgPSBNYXRoLm1heChkaXNwbGF5LnNpemVyLmNsaWVudFdpZHRoLCBkaXNwbGF5LmxpbmVTcGFjZS5jbGllbnRXaWR0aClcXG4gICAgICAgIC8vIERlZmF1bHQgdG8gcG9zaXRpb25pbmcgYWJvdmUgKGlmIHNwZWNpZmllZCBhbmQgcG9zc2libGUpOyBvdGhlcndpc2UgZGVmYXVsdCB0byBwb3NpdGlvbmluZyBiZWxvd1xcbiAgICAgICAgaWYgKCh2ZXJ0ID09ICdhYm92ZScgfHwgcG9zLmJvdHRvbSArIG5vZGUub2Zmc2V0SGVpZ2h0ID4gdnNwYWNlKSAmJiBwb3MudG9wID4gbm9kZS5vZmZzZXRIZWlnaHQpXFxuICAgICAgICAgIHsgdG9wID0gcG9zLnRvcCAtIG5vZGUub2Zmc2V0SGVpZ2h0IH1cXG4gICAgICAgIGVsc2UgaWYgKHBvcy5ib3R0b20gKyBub2RlLm9mZnNldEhlaWdodCA8PSB2c3BhY2UpXFxuICAgICAgICAgIHsgdG9wID0gcG9zLmJvdHRvbSB9XFxuICAgICAgICBpZiAobGVmdCArIG5vZGUub2Zmc2V0V2lkdGggPiBoc3BhY2UpXFxuICAgICAgICAgIHsgbGVmdCA9IGhzcGFjZSAtIG5vZGUub2Zmc2V0V2lkdGggfVxcbiAgICAgIH1cXG4gICAgICBub2RlLnN0eWxlLnRvcCA9IHRvcCArIFxcXCJweFxcXCJcXG4gICAgICBub2RlLnN0eWxlLmxlZnQgPSBub2RlLnN0eWxlLnJpZ2h0ID0gXFxcIlxcXCJcXG4gICAgICBpZiAoaG9yaXogPT0gXFxcInJpZ2h0XFxcIikge1xcbiAgICAgICAgbGVmdCA9IGRpc3BsYXkuc2l6ZXIuY2xpZW50V2lkdGggLSBub2RlLm9mZnNldFdpZHRoXFxuICAgICAgICBub2RlLnN0eWxlLnJpZ2h0ID0gXFxcIjBweFxcXCJcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgaWYgKGhvcml6ID09IFxcXCJsZWZ0XFxcIikgeyBsZWZ0ID0gMCB9XFxuICAgICAgICBlbHNlIGlmIChob3JpeiA9PSBcXFwibWlkZGxlXFxcIikgeyBsZWZ0ID0gKGRpc3BsYXkuc2l6ZXIuY2xpZW50V2lkdGggLSBub2RlLm9mZnNldFdpZHRoKSAvIDIgfVxcbiAgICAgICAgbm9kZS5zdHlsZS5sZWZ0ID0gbGVmdCArIFxcXCJweFxcXCJcXG4gICAgICB9XFxuICAgICAgaWYgKHNjcm9sbClcXG4gICAgICAgIHsgc2Nyb2xsSW50b1ZpZXcodGhpcywgbGVmdCwgdG9wLCBsZWZ0ICsgbm9kZS5vZmZzZXRXaWR0aCwgdG9wICsgbm9kZS5vZmZzZXRIZWlnaHQpIH1cXG4gICAgfSxcXG5cXG4gICAgdHJpZ2dlck9uS2V5RG93bjogbWV0aG9kT3Aob25LZXlEb3duKSxcXG4gICAgdHJpZ2dlck9uS2V5UHJlc3M6IG1ldGhvZE9wKG9uS2V5UHJlc3MpLFxcbiAgICB0cmlnZ2VyT25LZXlVcDogb25LZXlVcCxcXG5cXG4gICAgZXhlY0NvbW1hbmQ6IGZ1bmN0aW9uKGNtZCkge1xcbiAgICAgIGlmIChjb21tYW5kcy5oYXNPd25Qcm9wZXJ0eShjbWQpKVxcbiAgICAgICAgeyByZXR1cm4gY29tbWFuZHNbY21kXS5jYWxsKG51bGwsIHRoaXMpIH1cXG4gICAgfSxcXG5cXG4gICAgdHJpZ2dlckVsZWN0cmljOiBtZXRob2RPcChmdW5jdGlvbih0ZXh0KSB7IHRyaWdnZXJFbGVjdHJpYyh0aGlzLCB0ZXh0KSB9KSxcXG5cXG4gICAgZmluZFBvc0g6IGZ1bmN0aW9uKGZyb20sIGFtb3VudCwgdW5pdCwgdmlzdWFsbHkpIHtcXG4gICAgICB2YXIgdGhpcyQxID0gdGhpcztcXG5cXG4gICAgICB2YXIgZGlyID0gMVxcbiAgICAgIGlmIChhbW91bnQgPCAwKSB7IGRpciA9IC0xOyBhbW91bnQgPSAtYW1vdW50IH1cXG4gICAgICB2YXIgY3VyID0gY2xpcFBvcyh0aGlzLmRvYywgZnJvbSlcXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFtb3VudDsgKytpKSB7XFxuICAgICAgICBjdXIgPSBmaW5kUG9zSCh0aGlzJDEuZG9jLCBjdXIsIGRpciwgdW5pdCwgdmlzdWFsbHkpXFxuICAgICAgICBpZiAoY3VyLmhpdFNpZGUpIHsgYnJlYWsgfVxcbiAgICAgIH1cXG4gICAgICByZXR1cm4gY3VyXFxuICAgIH0sXFxuXFxuICAgIG1vdmVIOiBtZXRob2RPcChmdW5jdGlvbihkaXIsIHVuaXQpIHtcXG4gICAgICB2YXIgdGhpcyQxID0gdGhpcztcXG5cXG4gICAgICB0aGlzLmV4dGVuZFNlbGVjdGlvbnNCeShmdW5jdGlvbiAocmFuZ2UpIHtcXG4gICAgICAgIGlmICh0aGlzJDEuZGlzcGxheS5zaGlmdCB8fCB0aGlzJDEuZG9jLmV4dGVuZCB8fCByYW5nZS5lbXB0eSgpKVxcbiAgICAgICAgICB7IHJldHVybiBmaW5kUG9zSCh0aGlzJDEuZG9jLCByYW5nZS5oZWFkLCBkaXIsIHVuaXQsIHRoaXMkMS5vcHRpb25zLnJ0bE1vdmVWaXN1YWxseSkgfVxcbiAgICAgICAgZWxzZVxcbiAgICAgICAgICB7IHJldHVybiBkaXIgPCAwID8gcmFuZ2UuZnJvbSgpIDogcmFuZ2UudG8oKSB9XFxuICAgICAgfSwgc2VsX21vdmUpXFxuICAgIH0pLFxcblxcbiAgICBkZWxldGVIOiBtZXRob2RPcChmdW5jdGlvbihkaXIsIHVuaXQpIHtcXG4gICAgICB2YXIgc2VsID0gdGhpcy5kb2Muc2VsLCBkb2MgPSB0aGlzLmRvY1xcbiAgICAgIGlmIChzZWwuc29tZXRoaW5nU2VsZWN0ZWQoKSlcXG4gICAgICAgIHsgZG9jLnJlcGxhY2VTZWxlY3Rpb24oXFxcIlxcXCIsIG51bGwsIFxcXCIrZGVsZXRlXFxcIikgfVxcbiAgICAgIGVsc2VcXG4gICAgICAgIHsgZGVsZXRlTmVhclNlbGVjdGlvbih0aGlzLCBmdW5jdGlvbiAocmFuZ2UpIHtcXG4gICAgICAgICAgdmFyIG90aGVyID0gZmluZFBvc0goZG9jLCByYW5nZS5oZWFkLCBkaXIsIHVuaXQsIGZhbHNlKVxcbiAgICAgICAgICByZXR1cm4gZGlyIDwgMCA/IHtmcm9tOiBvdGhlciwgdG86IHJhbmdlLmhlYWR9IDoge2Zyb206IHJhbmdlLmhlYWQsIHRvOiBvdGhlcn1cXG4gICAgICAgIH0pIH1cXG4gICAgfSksXFxuXFxuICAgIGZpbmRQb3NWOiBmdW5jdGlvbihmcm9tLCBhbW91bnQsIHVuaXQsIGdvYWxDb2x1bW4pIHtcXG4gICAgICB2YXIgdGhpcyQxID0gdGhpcztcXG5cXG4gICAgICB2YXIgZGlyID0gMSwgeCA9IGdvYWxDb2x1bW5cXG4gICAgICBpZiAoYW1vdW50IDwgMCkgeyBkaXIgPSAtMTsgYW1vdW50ID0gLWFtb3VudCB9XFxuICAgICAgdmFyIGN1ciA9IGNsaXBQb3ModGhpcy5kb2MsIGZyb20pXFxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbW91bnQ7ICsraSkge1xcbiAgICAgICAgdmFyIGNvb3JkcyA9IGN1cnNvckNvb3Jkcyh0aGlzJDEsIGN1ciwgXFxcImRpdlxcXCIpXFxuICAgICAgICBpZiAoeCA9PSBudWxsKSB7IHggPSBjb29yZHMubGVmdCB9XFxuICAgICAgICBlbHNlIHsgY29vcmRzLmxlZnQgPSB4IH1cXG4gICAgICAgIGN1ciA9IGZpbmRQb3NWKHRoaXMkMSwgY29vcmRzLCBkaXIsIHVuaXQpXFxuICAgICAgICBpZiAoY3VyLmhpdFNpZGUpIHsgYnJlYWsgfVxcbiAgICAgIH1cXG4gICAgICByZXR1cm4gY3VyXFxuICAgIH0sXFxuXFxuICAgIG1vdmVWOiBtZXRob2RPcChmdW5jdGlvbihkaXIsIHVuaXQpIHtcXG4gICAgICB2YXIgdGhpcyQxID0gdGhpcztcXG5cXG4gICAgICB2YXIgZG9jID0gdGhpcy5kb2MsIGdvYWxzID0gW11cXG4gICAgICB2YXIgY29sbGFwc2UgPSAhdGhpcy5kaXNwbGF5LnNoaWZ0ICYmICFkb2MuZXh0ZW5kICYmIGRvYy5zZWwuc29tZXRoaW5nU2VsZWN0ZWQoKVxcbiAgICAgIGRvYy5leHRlbmRTZWxlY3Rpb25zQnkoZnVuY3Rpb24gKHJhbmdlKSB7XFxuICAgICAgICBpZiAoY29sbGFwc2UpXFxuICAgICAgICAgIHsgcmV0dXJuIGRpciA8IDAgPyByYW5nZS5mcm9tKCkgOiByYW5nZS50bygpIH1cXG4gICAgICAgIHZhciBoZWFkUG9zID0gY3Vyc29yQ29vcmRzKHRoaXMkMSwgcmFuZ2UuaGVhZCwgXFxcImRpdlxcXCIpXFxuICAgICAgICBpZiAocmFuZ2UuZ29hbENvbHVtbiAhPSBudWxsKSB7IGhlYWRQb3MubGVmdCA9IHJhbmdlLmdvYWxDb2x1bW4gfVxcbiAgICAgICAgZ29hbHMucHVzaChoZWFkUG9zLmxlZnQpXFxuICAgICAgICB2YXIgcG9zID0gZmluZFBvc1YodGhpcyQxLCBoZWFkUG9zLCBkaXIsIHVuaXQpXFxuICAgICAgICBpZiAodW5pdCA9PSBcXFwicGFnZVxcXCIgJiYgcmFuZ2UgPT0gZG9jLnNlbC5wcmltYXJ5KCkpXFxuICAgICAgICAgIHsgYWRkVG9TY3JvbGxQb3ModGhpcyQxLCBudWxsLCBjaGFyQ29vcmRzKHRoaXMkMSwgcG9zLCBcXFwiZGl2XFxcIikudG9wIC0gaGVhZFBvcy50b3ApIH1cXG4gICAgICAgIHJldHVybiBwb3NcXG4gICAgICB9LCBzZWxfbW92ZSlcXG4gICAgICBpZiAoZ29hbHMubGVuZ3RoKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgZG9jLnNlbC5yYW5nZXMubGVuZ3RoOyBpKyspXFxuICAgICAgICB7IGRvYy5zZWwucmFuZ2VzW2ldLmdvYWxDb2x1bW4gPSBnb2Fsc1tpXSB9IH1cXG4gICAgfSksXFxuXFxuICAgIC8vIEZpbmQgdGhlIHdvcmQgYXQgdGhlIGdpdmVuIHBvc2l0aW9uIChhcyByZXR1cm5lZCBieSBjb29yZHNDaGFyKS5cXG4gICAgZmluZFdvcmRBdDogZnVuY3Rpb24ocG9zKSB7XFxuICAgICAgdmFyIGRvYyA9IHRoaXMuZG9jLCBsaW5lID0gZ2V0TGluZShkb2MsIHBvcy5saW5lKS50ZXh0XFxuICAgICAgdmFyIHN0YXJ0ID0gcG9zLmNoLCBlbmQgPSBwb3MuY2hcXG4gICAgICBpZiAobGluZSkge1xcbiAgICAgICAgdmFyIGhlbHBlciA9IHRoaXMuZ2V0SGVscGVyKHBvcywgXFxcIndvcmRDaGFyc1xcXCIpXFxuICAgICAgICBpZiAoKHBvcy54UmVsIDwgMCB8fCBlbmQgPT0gbGluZS5sZW5ndGgpICYmIHN0YXJ0KSB7IC0tc3RhcnQ7IH0gZWxzZSB7ICsrZW5kIH1cXG4gICAgICAgIHZhciBzdGFydENoYXIgPSBsaW5lLmNoYXJBdChzdGFydClcXG4gICAgICAgIHZhciBjaGVjayA9IGlzV29yZENoYXIoc3RhcnRDaGFyLCBoZWxwZXIpXFxuICAgICAgICAgID8gZnVuY3Rpb24gKGNoKSB7IHJldHVybiBpc1dvcmRDaGFyKGNoLCBoZWxwZXIpOyB9XFxuICAgICAgICAgIDogL1xcXFxzLy50ZXN0KHN0YXJ0Q2hhcikgPyBmdW5jdGlvbiAoY2gpIHsgcmV0dXJuIC9cXFxccy8udGVzdChjaCk7IH1cXG4gICAgICAgICAgOiBmdW5jdGlvbiAoY2gpIHsgcmV0dXJuICghL1xcXFxzLy50ZXN0KGNoKSAmJiAhaXNXb3JkQ2hhcihjaCkpOyB9XFxuICAgICAgICB3aGlsZSAoc3RhcnQgPiAwICYmIGNoZWNrKGxpbmUuY2hhckF0KHN0YXJ0IC0gMSkpKSB7IC0tc3RhcnQgfVxcbiAgICAgICAgd2hpbGUgKGVuZCA8IGxpbmUubGVuZ3RoICYmIGNoZWNrKGxpbmUuY2hhckF0KGVuZCkpKSB7ICsrZW5kIH1cXG4gICAgICB9XFxuICAgICAgcmV0dXJuIG5ldyBSYW5nZShQb3MocG9zLmxpbmUsIHN0YXJ0KSwgUG9zKHBvcy5saW5lLCBlbmQpKVxcbiAgICB9LFxcblxcbiAgICB0b2dnbGVPdmVyd3JpdGU6IGZ1bmN0aW9uKHZhbHVlKSB7XFxuICAgICAgaWYgKHZhbHVlICE9IG51bGwgJiYgdmFsdWUgPT0gdGhpcy5zdGF0ZS5vdmVyd3JpdGUpIHsgcmV0dXJuIH1cXG4gICAgICBpZiAodGhpcy5zdGF0ZS5vdmVyd3JpdGUgPSAhdGhpcy5zdGF0ZS5vdmVyd3JpdGUpXFxuICAgICAgICB7IGFkZENsYXNzKHRoaXMuZGlzcGxheS5jdXJzb3JEaXYsIFxcXCJDb2RlTWlycm9yLW92ZXJ3cml0ZVxcXCIpIH1cXG4gICAgICBlbHNlXFxuICAgICAgICB7IHJtQ2xhc3ModGhpcy5kaXNwbGF5LmN1cnNvckRpdiwgXFxcIkNvZGVNaXJyb3Itb3ZlcndyaXRlXFxcIikgfVxcblxcbiAgICAgIHNpZ25hbCh0aGlzLCBcXFwib3ZlcndyaXRlVG9nZ2xlXFxcIiwgdGhpcywgdGhpcy5zdGF0ZS5vdmVyd3JpdGUpXFxuICAgIH0sXFxuICAgIGhhc0ZvY3VzOiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuZGlzcGxheS5pbnB1dC5nZXRGaWVsZCgpID09IGFjdGl2ZUVsdCgpIH0sXFxuICAgIGlzUmVhZE9ubHk6IGZ1bmN0aW9uKCkgeyByZXR1cm4gISEodGhpcy5vcHRpb25zLnJlYWRPbmx5IHx8IHRoaXMuZG9jLmNhbnRFZGl0KSB9LFxcblxcbiAgICBzY3JvbGxUbzogbWV0aG9kT3AoZnVuY3Rpb24oeCwgeSkge1xcbiAgICAgIGlmICh4ICE9IG51bGwgfHwgeSAhPSBudWxsKSB7IHJlc29sdmVTY3JvbGxUb1Bvcyh0aGlzKSB9XFxuICAgICAgaWYgKHggIT0gbnVsbCkgeyB0aGlzLmN1ck9wLnNjcm9sbExlZnQgPSB4IH1cXG4gICAgICBpZiAoeSAhPSBudWxsKSB7IHRoaXMuY3VyT3Auc2Nyb2xsVG9wID0geSB9XFxuICAgIH0pLFxcbiAgICBnZXRTY3JvbGxJbmZvOiBmdW5jdGlvbigpIHtcXG4gICAgICB2YXIgc2Nyb2xsZXIgPSB0aGlzLmRpc3BsYXkuc2Nyb2xsZXJcXG4gICAgICByZXR1cm4ge2xlZnQ6IHNjcm9sbGVyLnNjcm9sbExlZnQsIHRvcDogc2Nyb2xsZXIuc2Nyb2xsVG9wLFxcbiAgICAgICAgICAgICAgaGVpZ2h0OiBzY3JvbGxlci5zY3JvbGxIZWlnaHQgLSBzY3JvbGxHYXAodGhpcykgLSB0aGlzLmRpc3BsYXkuYmFySGVpZ2h0LFxcbiAgICAgICAgICAgICAgd2lkdGg6IHNjcm9sbGVyLnNjcm9sbFdpZHRoIC0gc2Nyb2xsR2FwKHRoaXMpIC0gdGhpcy5kaXNwbGF5LmJhcldpZHRoLFxcbiAgICAgICAgICAgICAgY2xpZW50SGVpZ2h0OiBkaXNwbGF5SGVpZ2h0KHRoaXMpLCBjbGllbnRXaWR0aDogZGlzcGxheVdpZHRoKHRoaXMpfVxcbiAgICB9LFxcblxcbiAgICBzY3JvbGxJbnRvVmlldzogbWV0aG9kT3AoZnVuY3Rpb24ocmFuZ2UsIG1hcmdpbikge1xcbiAgICAgIGlmIChyYW5nZSA9PSBudWxsKSB7XFxuICAgICAgICByYW5nZSA9IHtmcm9tOiB0aGlzLmRvYy5zZWwucHJpbWFyeSgpLmhlYWQsIHRvOiBudWxsfVxcbiAgICAgICAgaWYgKG1hcmdpbiA9PSBudWxsKSB7IG1hcmdpbiA9IHRoaXMub3B0aW9ucy5jdXJzb3JTY3JvbGxNYXJnaW4gfVxcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHJhbmdlID09IFxcXCJudW1iZXJcXFwiKSB7XFxuICAgICAgICByYW5nZSA9IHtmcm9tOiBQb3MocmFuZ2UsIDApLCB0bzogbnVsbH1cXG4gICAgICB9IGVsc2UgaWYgKHJhbmdlLmZyb20gPT0gbnVsbCkge1xcbiAgICAgICAgcmFuZ2UgPSB7ZnJvbTogcmFuZ2UsIHRvOiBudWxsfVxcbiAgICAgIH1cXG4gICAgICBpZiAoIXJhbmdlLnRvKSB7IHJhbmdlLnRvID0gcmFuZ2UuZnJvbSB9XFxuICAgICAgcmFuZ2UubWFyZ2luID0gbWFyZ2luIHx8IDBcXG5cXG4gICAgICBpZiAocmFuZ2UuZnJvbS5saW5lICE9IG51bGwpIHtcXG4gICAgICAgIHJlc29sdmVTY3JvbGxUb1Bvcyh0aGlzKVxcbiAgICAgICAgdGhpcy5jdXJPcC5zY3JvbGxUb1BvcyA9IHJhbmdlXFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIHZhciBzUG9zID0gY2FsY3VsYXRlU2Nyb2xsUG9zKHRoaXMsIE1hdGgubWluKHJhbmdlLmZyb20ubGVmdCwgcmFuZ2UudG8ubGVmdCksXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBNYXRoLm1pbihyYW5nZS5mcm9tLnRvcCwgcmFuZ2UudG8udG9wKSAtIHJhbmdlLm1hcmdpbixcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1hdGgubWF4KHJhbmdlLmZyb20ucmlnaHQsIHJhbmdlLnRvLnJpZ2h0KSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1hdGgubWF4KHJhbmdlLmZyb20uYm90dG9tLCByYW5nZS50by5ib3R0b20pICsgcmFuZ2UubWFyZ2luKVxcbiAgICAgICAgdGhpcy5zY3JvbGxUbyhzUG9zLnNjcm9sbExlZnQsIHNQb3Muc2Nyb2xsVG9wKVxcbiAgICAgIH1cXG4gICAgfSksXFxuXFxuICAgIHNldFNpemU6IG1ldGhvZE9wKGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQpIHtcXG4gICAgICB2YXIgdGhpcyQxID0gdGhpcztcXG5cXG4gICAgICB2YXIgaW50ZXJwcmV0ID0gZnVuY3Rpb24gKHZhbCkgeyByZXR1cm4gdHlwZW9mIHZhbCA9PSBcXFwibnVtYmVyXFxcIiB8fCAvXlxcXFxkKyQvLnRlc3QoU3RyaW5nKHZhbCkpID8gdmFsICsgXFxcInB4XFxcIiA6IHZhbDsgfVxcbiAgICAgIGlmICh3aWR0aCAhPSBudWxsKSB7IHRoaXMuZGlzcGxheS53cmFwcGVyLnN0eWxlLndpZHRoID0gaW50ZXJwcmV0KHdpZHRoKSB9XFxuICAgICAgaWYgKGhlaWdodCAhPSBudWxsKSB7IHRoaXMuZGlzcGxheS53cmFwcGVyLnN0eWxlLmhlaWdodCA9IGludGVycHJldChoZWlnaHQpIH1cXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmxpbmVXcmFwcGluZykgeyBjbGVhckxpbmVNZWFzdXJlbWVudENhY2hlKHRoaXMpIH1cXG4gICAgICB2YXIgbGluZU5vID0gdGhpcy5kaXNwbGF5LnZpZXdGcm9tXFxuICAgICAgdGhpcy5kb2MuaXRlcihsaW5lTm8sIHRoaXMuZGlzcGxheS52aWV3VG8sIGZ1bmN0aW9uIChsaW5lKSB7XFxuICAgICAgICBpZiAobGluZS53aWRnZXRzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgbGluZS53aWRnZXRzLmxlbmd0aDsgaSsrKVxcbiAgICAgICAgICB7IGlmIChsaW5lLndpZGdldHNbaV0ubm9IU2Nyb2xsKSB7IHJlZ0xpbmVDaGFuZ2UodGhpcyQxLCBsaW5lTm8sIFxcXCJ3aWRnZXRcXFwiKTsgYnJlYWsgfSB9IH1cXG4gICAgICAgICsrbGluZU5vXFxuICAgICAgfSlcXG4gICAgICB0aGlzLmN1ck9wLmZvcmNlVXBkYXRlID0gdHJ1ZVxcbiAgICAgIHNpZ25hbCh0aGlzLCBcXFwicmVmcmVzaFxcXCIsIHRoaXMpXFxuICAgIH0pLFxcblxcbiAgICBvcGVyYXRpb246IGZ1bmN0aW9uKGYpe3JldHVybiBydW5Jbk9wKHRoaXMsIGYpfSxcXG5cXG4gICAgcmVmcmVzaDogbWV0aG9kT3AoZnVuY3Rpb24oKSB7XFxuICAgICAgdmFyIG9sZEhlaWdodCA9IHRoaXMuZGlzcGxheS5jYWNoZWRUZXh0SGVpZ2h0XFxuICAgICAgcmVnQ2hhbmdlKHRoaXMpXFxuICAgICAgdGhpcy5jdXJPcC5mb3JjZVVwZGF0ZSA9IHRydWVcXG4gICAgICBjbGVhckNhY2hlcyh0aGlzKVxcbiAgICAgIHRoaXMuc2Nyb2xsVG8odGhpcy5kb2Muc2Nyb2xsTGVmdCwgdGhpcy5kb2Muc2Nyb2xsVG9wKVxcbiAgICAgIHVwZGF0ZUd1dHRlclNwYWNlKHRoaXMpXFxuICAgICAgaWYgKG9sZEhlaWdodCA9PSBudWxsIHx8IE1hdGguYWJzKG9sZEhlaWdodCAtIHRleHRIZWlnaHQodGhpcy5kaXNwbGF5KSkgPiAuNSlcXG4gICAgICAgIHsgZXN0aW1hdGVMaW5lSGVpZ2h0cyh0aGlzKSB9XFxuICAgICAgc2lnbmFsKHRoaXMsIFxcXCJyZWZyZXNoXFxcIiwgdGhpcylcXG4gICAgfSksXFxuXFxuICAgIHN3YXBEb2M6IG1ldGhvZE9wKGZ1bmN0aW9uKGRvYykge1xcbiAgICAgIHZhciBvbGQgPSB0aGlzLmRvY1xcbiAgICAgIG9sZC5jbSA9IG51bGxcXG4gICAgICBhdHRhY2hEb2ModGhpcywgZG9jKVxcbiAgICAgIGNsZWFyQ2FjaGVzKHRoaXMpXFxuICAgICAgdGhpcy5kaXNwbGF5LmlucHV0LnJlc2V0KClcXG4gICAgICB0aGlzLnNjcm9sbFRvKGRvYy5zY3JvbGxMZWZ0LCBkb2Muc2Nyb2xsVG9wKVxcbiAgICAgIHRoaXMuY3VyT3AuZm9yY2VTY3JvbGwgPSB0cnVlXFxuICAgICAgc2lnbmFsTGF0ZXIodGhpcywgXFxcInN3YXBEb2NcXFwiLCB0aGlzLCBvbGQpXFxuICAgICAgcmV0dXJuIG9sZFxcbiAgICB9KSxcXG5cXG4gICAgZ2V0SW5wdXRGaWVsZDogZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5kaXNwbGF5LmlucHV0LmdldEZpZWxkKCl9LFxcbiAgICBnZXRXcmFwcGVyRWxlbWVudDogZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5kaXNwbGF5LndyYXBwZXJ9LFxcbiAgICBnZXRTY3JvbGxlckVsZW1lbnQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZGlzcGxheS5zY3JvbGxlcn0sXFxuICAgIGdldEd1dHRlckVsZW1lbnQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZGlzcGxheS5ndXR0ZXJzfVxcbiAgfVxcbiAgZXZlbnRNaXhpbihDb2RlTWlycm9yKVxcblxcbiAgQ29kZU1pcnJvci5yZWdpc3RlckhlbHBlciA9IGZ1bmN0aW9uKHR5cGUsIG5hbWUsIHZhbHVlKSB7XFxuICAgIGlmICghaGVscGVycy5oYXNPd25Qcm9wZXJ0eSh0eXBlKSkgeyBoZWxwZXJzW3R5cGVdID0gQ29kZU1pcnJvclt0eXBlXSA9IHtfZ2xvYmFsOiBbXX0gfVxcbiAgICBoZWxwZXJzW3R5cGVdW25hbWVdID0gdmFsdWVcXG4gIH1cXG4gIENvZGVNaXJyb3IucmVnaXN0ZXJHbG9iYWxIZWxwZXIgPSBmdW5jdGlvbih0eXBlLCBuYW1lLCBwcmVkaWNhdGUsIHZhbHVlKSB7XFxuICAgIENvZGVNaXJyb3IucmVnaXN0ZXJIZWxwZXIodHlwZSwgbmFtZSwgdmFsdWUpXFxuICAgIGhlbHBlcnNbdHlwZV0uX2dsb2JhbC5wdXNoKHtwcmVkOiBwcmVkaWNhdGUsIHZhbDogdmFsdWV9KVxcbiAgfVxcbn1cXG5cXG4vLyBVc2VkIGZvciBob3Jpem9udGFsIHJlbGF0aXZlIG1vdGlvbi4gRGlyIGlzIC0xIG9yIDEgKGxlZnQgb3JcXG4vLyByaWdodCksIHVuaXQgY2FuIGJlIFxcXCJjaGFyXFxcIiwgXFxcImNvbHVtblxcXCIgKGxpa2UgY2hhciwgYnV0IGRvZXNuJ3RcXG4vLyBjcm9zcyBsaW5lIGJvdW5kYXJpZXMpLCBcXFwid29yZFxcXCIgKGFjcm9zcyBuZXh0IHdvcmQpLCBvciBcXFwiZ3JvdXBcXFwiICh0b1xcbi8vIHRoZSBzdGFydCBvZiBuZXh0IGdyb3VwIG9mIHdvcmQgb3Igbm9uLXdvcmQtbm9uLXdoaXRlc3BhY2VcXG4vLyBjaGFycykuIFRoZSB2aXN1YWxseSBwYXJhbSBjb250cm9scyB3aGV0aGVyLCBpbiByaWdodC10by1sZWZ0XFxuLy8gdGV4dCwgZGlyZWN0aW9uIDEgbWVhbnMgdG8gbW92ZSB0b3dhcmRzIHRoZSBuZXh0IGluZGV4IGluIHRoZVxcbi8vIHN0cmluZywgb3IgdG93YXJkcyB0aGUgY2hhcmFjdGVyIHRvIHRoZSByaWdodCBvZiB0aGUgY3VycmVudFxcbi8vIHBvc2l0aW9uLiBUaGUgcmVzdWx0aW5nIHBvc2l0aW9uIHdpbGwgaGF2ZSBhIGhpdFNpZGU9dHJ1ZVxcbi8vIHByb3BlcnR5IGlmIGl0IHJlYWNoZWQgdGhlIGVuZCBvZiB0aGUgZG9jdW1lbnQuXFxuZnVuY3Rpb24gZmluZFBvc0goZG9jLCBwb3MsIGRpciwgdW5pdCwgdmlzdWFsbHkpIHtcXG4gIHZhciBsaW5lID0gcG9zLmxpbmUsIGNoID0gcG9zLmNoLCBvcmlnRGlyID0gZGlyXFxuICB2YXIgbGluZU9iaiA9IGdldExpbmUoZG9jLCBsaW5lKVxcbiAgZnVuY3Rpb24gZmluZE5leHRMaW5lKCkge1xcbiAgICB2YXIgbCA9IGxpbmUgKyBkaXJcXG4gICAgaWYgKGwgPCBkb2MuZmlyc3QgfHwgbCA+PSBkb2MuZmlyc3QgKyBkb2Muc2l6ZSkgeyByZXR1cm4gZmFsc2UgfVxcbiAgICBsaW5lID0gbFxcbiAgICByZXR1cm4gbGluZU9iaiA9IGdldExpbmUoZG9jLCBsKVxcbiAgfVxcbiAgZnVuY3Rpb24gbW92ZU9uY2UoYm91bmRUb0xpbmUpIHtcXG4gICAgdmFyIG5leHQgPSAodmlzdWFsbHkgPyBtb3ZlVmlzdWFsbHkgOiBtb3ZlTG9naWNhbGx5KShsaW5lT2JqLCBjaCwgZGlyLCB0cnVlKVxcbiAgICBpZiAobmV4dCA9PSBudWxsKSB7XFxuICAgICAgaWYgKCFib3VuZFRvTGluZSAmJiBmaW5kTmV4dExpbmUoKSkge1xcbiAgICAgICAgaWYgKHZpc3VhbGx5KSB7IGNoID0gKGRpciA8IDAgPyBsaW5lUmlnaHQgOiBsaW5lTGVmdCkobGluZU9iaikgfVxcbiAgICAgICAgZWxzZSB7IGNoID0gZGlyIDwgMCA/IGxpbmVPYmoudGV4dC5sZW5ndGggOiAwIH1cXG4gICAgICB9IGVsc2UgeyByZXR1cm4gZmFsc2UgfVxcbiAgICB9IGVsc2UgeyBjaCA9IG5leHQgfVxcbiAgICByZXR1cm4gdHJ1ZVxcbiAgfVxcblxcbiAgaWYgKHVuaXQgPT0gXFxcImNoYXJcXFwiKSB7XFxuICAgIG1vdmVPbmNlKClcXG4gIH0gZWxzZSBpZiAodW5pdCA9PSBcXFwiY29sdW1uXFxcIikge1xcbiAgICBtb3ZlT25jZSh0cnVlKVxcbiAgfSBlbHNlIGlmICh1bml0ID09IFxcXCJ3b3JkXFxcIiB8fCB1bml0ID09IFxcXCJncm91cFxcXCIpIHtcXG4gICAgdmFyIHNhd1R5cGUgPSBudWxsLCBncm91cCA9IHVuaXQgPT0gXFxcImdyb3VwXFxcIlxcbiAgICB2YXIgaGVscGVyID0gZG9jLmNtICYmIGRvYy5jbS5nZXRIZWxwZXIocG9zLCBcXFwid29yZENoYXJzXFxcIilcXG4gICAgZm9yICh2YXIgZmlyc3QgPSB0cnVlOzsgZmlyc3QgPSBmYWxzZSkge1xcbiAgICAgIGlmIChkaXIgPCAwICYmICFtb3ZlT25jZSghZmlyc3QpKSB7IGJyZWFrIH1cXG4gICAgICB2YXIgY3VyID0gbGluZU9iai50ZXh0LmNoYXJBdChjaCkgfHwgXFxcIlxcXFxuXFxcIlxcbiAgICAgIHZhciB0eXBlID0gaXNXb3JkQ2hhcihjdXIsIGhlbHBlcikgPyBcXFwid1xcXCJcXG4gICAgICAgIDogZ3JvdXAgJiYgY3VyID09IFxcXCJcXFxcblxcXCIgPyBcXFwiblxcXCJcXG4gICAgICAgIDogIWdyb3VwIHx8IC9cXFxccy8udGVzdChjdXIpID8gbnVsbFxcbiAgICAgICAgOiBcXFwicFxcXCJcXG4gICAgICBpZiAoZ3JvdXAgJiYgIWZpcnN0ICYmICF0eXBlKSB7IHR5cGUgPSBcXFwic1xcXCIgfVxcbiAgICAgIGlmIChzYXdUeXBlICYmIHNhd1R5cGUgIT0gdHlwZSkge1xcbiAgICAgICAgaWYgKGRpciA8IDApIHtkaXIgPSAxOyBtb3ZlT25jZSgpfVxcbiAgICAgICAgYnJlYWtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKHR5cGUpIHsgc2F3VHlwZSA9IHR5cGUgfVxcbiAgICAgIGlmIChkaXIgPiAwICYmICFtb3ZlT25jZSghZmlyc3QpKSB7IGJyZWFrIH1cXG4gICAgfVxcbiAgfVxcbiAgdmFyIHJlc3VsdCA9IHNraXBBdG9taWMoZG9jLCBQb3MobGluZSwgY2gpLCBwb3MsIG9yaWdEaXIsIHRydWUpXFxuICBpZiAoIWNtcChwb3MsIHJlc3VsdCkpIHsgcmVzdWx0LmhpdFNpZGUgPSB0cnVlIH1cXG4gIHJldHVybiByZXN1bHRcXG59XFxuXFxuLy8gRm9yIHJlbGF0aXZlIHZlcnRpY2FsIG1vdmVtZW50LiBEaXIgbWF5IGJlIC0xIG9yIDEuIFVuaXQgY2FuIGJlXFxuLy8gXFxcInBhZ2VcXFwiIG9yIFxcXCJsaW5lXFxcIi4gVGhlIHJlc3VsdGluZyBwb3NpdGlvbiB3aWxsIGhhdmUgYSBoaXRTaWRlPXRydWVcXG4vLyBwcm9wZXJ0eSBpZiBpdCByZWFjaGVkIHRoZSBlbmQgb2YgdGhlIGRvY3VtZW50LlxcbmZ1bmN0aW9uIGZpbmRQb3NWKGNtLCBwb3MsIGRpciwgdW5pdCkge1xcbiAgdmFyIGRvYyA9IGNtLmRvYywgeCA9IHBvcy5sZWZ0LCB5XFxuICBpZiAodW5pdCA9PSBcXFwicGFnZVxcXCIpIHtcXG4gICAgdmFyIHBhZ2VTaXplID0gTWF0aC5taW4oY20uZGlzcGxheS53cmFwcGVyLmNsaWVudEhlaWdodCwgd2luZG93LmlubmVySGVpZ2h0IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQpXFxuICAgIHZhciBtb3ZlQW1vdW50ID0gTWF0aC5tYXgocGFnZVNpemUgLSAuNSAqIHRleHRIZWlnaHQoY20uZGlzcGxheSksIDMpXFxuICAgIHkgPSAoZGlyID4gMCA/IHBvcy5ib3R0b20gOiBwb3MudG9wKSArIGRpciAqIG1vdmVBbW91bnRcXG5cXG4gIH0gZWxzZSBpZiAodW5pdCA9PSBcXFwibGluZVxcXCIpIHtcXG4gICAgeSA9IGRpciA+IDAgPyBwb3MuYm90dG9tICsgMyA6IHBvcy50b3AgLSAzXFxuICB9XFxuICB2YXIgdGFyZ2V0XFxuICBmb3IgKDs7KSB7XFxuICAgIHRhcmdldCA9IGNvb3Jkc0NoYXIoY20sIHgsIHkpXFxuICAgIGlmICghdGFyZ2V0Lm91dHNpZGUpIHsgYnJlYWsgfVxcbiAgICBpZiAoZGlyIDwgMCA/IHkgPD0gMCA6IHkgPj0gZG9jLmhlaWdodCkgeyB0YXJnZXQuaGl0U2lkZSA9IHRydWU7IGJyZWFrIH1cXG4gICAgeSArPSBkaXIgKiA1XFxuICB9XFxuICByZXR1cm4gdGFyZ2V0XFxufVxcblxcbi8vIENPTlRFTlRFRElUQUJMRSBJTlBVVCBTVFlMRVxcblxcbnZhciBDb250ZW50RWRpdGFibGVJbnB1dCA9IGZ1bmN0aW9uKGNtKSB7XFxuICB0aGlzLmNtID0gY21cXG4gIHRoaXMubGFzdEFuY2hvck5vZGUgPSB0aGlzLmxhc3RBbmNob3JPZmZzZXQgPSB0aGlzLmxhc3RGb2N1c05vZGUgPSB0aGlzLmxhc3RGb2N1c09mZnNldCA9IG51bGxcXG4gIHRoaXMucG9sbGluZyA9IG5ldyBEZWxheWVkKClcXG4gIHRoaXMuY29tcG9zaW5nID0gbnVsbFxcbiAgdGhpcy5ncmFjZVBlcmlvZCA9IGZhbHNlXFxuICB0aGlzLnJlYWRET01UaW1lb3V0ID0gbnVsbFxcbn07XFxuXFxuQ29udGVudEVkaXRhYmxlSW5wdXQucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoZGlzcGxheSkge1xcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcXG5cXG4gIHZhciBpbnB1dCA9IHRoaXMsIGNtID0gaW5wdXQuY21cXG4gIHZhciBkaXYgPSBpbnB1dC5kaXYgPSBkaXNwbGF5LmxpbmVEaXZcXG4gIGRpc2FibGVCcm93c2VyTWFnaWMoZGl2LCBjbS5vcHRpb25zLnNwZWxsY2hlY2spXFxuXFxuICBvbihkaXYsIFxcXCJwYXN0ZVxcXCIsIGZ1bmN0aW9uIChlKSB7XFxuICAgIGlmIChzaWduYWxET01FdmVudChjbSwgZSkgfHwgaGFuZGxlUGFzdGUoZSwgY20pKSB7IHJldHVybiB9XFxuICAgIC8vIElFIGRvZXNuJ3QgZmlyZSBpbnB1dCBldmVudHMsIHNvIHdlIHNjaGVkdWxlIGEgcmVhZCBmb3IgdGhlIHBhc3RlZCBjb250ZW50IGluIHRoaXMgd2F5XFxuICAgIGlmIChpZV92ZXJzaW9uIDw9IDExKSB7IHNldFRpbWVvdXQob3BlcmF0aW9uKGNtLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgaWYgKCFpbnB1dC5wb2xsQ29udGVudCgpKSB7IHJlZ0NoYW5nZShjbSkgfVxcbiAgICB9KSwgMjApIH1cXG4gIH0pXFxuXFxuICBvbihkaXYsIFxcXCJjb21wb3NpdGlvbnN0YXJ0XFxcIiwgZnVuY3Rpb24gKGUpIHtcXG4gICAgdGhpcyQxLmNvbXBvc2luZyA9IHtkYXRhOiBlLmRhdGEsIGRvbmU6IGZhbHNlfVxcbiAgfSlcXG4gIG9uKGRpdiwgXFxcImNvbXBvc2l0aW9udXBkYXRlXFxcIiwgZnVuY3Rpb24gKGUpIHtcXG4gICAgaWYgKCF0aGlzJDEuY29tcG9zaW5nKSB7IHRoaXMkMS5jb21wb3NpbmcgPSB7ZGF0YTogZS5kYXRhLCBkb25lOiBmYWxzZX0gfVxcbiAgfSlcXG4gIG9uKGRpdiwgXFxcImNvbXBvc2l0aW9uZW5kXFxcIiwgZnVuY3Rpb24gKGUpIHtcXG4gICAgaWYgKHRoaXMkMS5jb21wb3NpbmcpIHtcXG4gICAgICBpZiAoZS5kYXRhICE9IHRoaXMkMS5jb21wb3NpbmcuZGF0YSkgeyB0aGlzJDEucmVhZEZyb21ET01Tb29uKCkgfVxcbiAgICAgIHRoaXMkMS5jb21wb3NpbmcuZG9uZSA9IHRydWVcXG4gICAgfVxcbiAgfSlcXG5cXG4gIG9uKGRpdiwgXFxcInRvdWNoc3RhcnRcXFwiLCBmdW5jdGlvbiAoKSB7IHJldHVybiBpbnB1dC5mb3JjZUNvbXBvc2l0aW9uRW5kKCk7IH0pXFxuXFxuICBvbihkaXYsIFxcXCJpbnB1dFxcXCIsIGZ1bmN0aW9uICgpIHtcXG4gICAgaWYgKCF0aGlzJDEuY29tcG9zaW5nKSB7IHRoaXMkMS5yZWFkRnJvbURPTVNvb24oKSB9XFxuICB9KVxcblxcbiAgZnVuY3Rpb24gb25Db3B5Q3V0KGUpIHtcXG4gICAgaWYgKHNpZ25hbERPTUV2ZW50KGNtLCBlKSkgeyByZXR1cm4gfVxcbiAgICBpZiAoY20uc29tZXRoaW5nU2VsZWN0ZWQoKSkge1xcbiAgICAgIHNldExhc3RDb3BpZWQoe2xpbmVXaXNlOiBmYWxzZSwgdGV4dDogY20uZ2V0U2VsZWN0aW9ucygpfSlcXG4gICAgICBpZiAoZS50eXBlID09IFxcXCJjdXRcXFwiKSB7IGNtLnJlcGxhY2VTZWxlY3Rpb24oXFxcIlxcXCIsIG51bGwsIFxcXCJjdXRcXFwiKSB9XFxuICAgIH0gZWxzZSBpZiAoIWNtLm9wdGlvbnMubGluZVdpc2VDb3B5Q3V0KSB7XFxuICAgICAgcmV0dXJuXFxuICAgIH0gZWxzZSB7XFxuICAgICAgdmFyIHJhbmdlcyA9IGNvcHlhYmxlUmFuZ2VzKGNtKVxcbiAgICAgIHNldExhc3RDb3BpZWQoe2xpbmVXaXNlOiB0cnVlLCB0ZXh0OiByYW5nZXMudGV4dH0pXFxuICAgICAgaWYgKGUudHlwZSA9PSBcXFwiY3V0XFxcIikge1xcbiAgICAgICAgY20ub3BlcmF0aW9uKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgY20uc2V0U2VsZWN0aW9ucyhyYW5nZXMucmFuZ2VzLCAwLCBzZWxfZG9udFNjcm9sbClcXG4gICAgICAgICAgY20ucmVwbGFjZVNlbGVjdGlvbihcXFwiXFxcIiwgbnVsbCwgXFxcImN1dFxcXCIpXFxuICAgICAgICB9KVxcbiAgICAgIH1cXG4gICAgfVxcbiAgICBpZiAoZS5jbGlwYm9hcmREYXRhKSB7XFxuICAgICAgZS5jbGlwYm9hcmREYXRhLmNsZWFyRGF0YSgpXFxuICAgICAgdmFyIGNvbnRlbnQgPSBsYXN0Q29waWVkLnRleHQuam9pbihcXFwiXFxcXG5cXFwiKVxcbiAgICAgIC8vIGlPUyBleHBvc2VzIHRoZSBjbGlwYm9hcmQgQVBJLCBidXQgc2VlbXMgdG8gZGlzY2FyZCBjb250ZW50IGluc2VydGVkIGludG8gaXRcXG4gICAgICBlLmNsaXBib2FyZERhdGEuc2V0RGF0YShcXFwiVGV4dFxcXCIsIGNvbnRlbnQpXFxuICAgICAgaWYgKGUuY2xpcGJvYXJkRGF0YS5nZXREYXRhKFxcXCJUZXh0XFxcIikgPT0gY29udGVudCkge1xcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpXFxuICAgICAgICByZXR1cm5cXG4gICAgICB9XFxuICAgIH1cXG4gICAgLy8gT2xkLWZhc2hpb25lZCBicmllZmx5LWZvY3VzLWEtdGV4dGFyZWEgaGFja1xcbiAgICB2YXIga2x1ZGdlID0gaGlkZGVuVGV4dGFyZWEoKSwgdGUgPSBrbHVkZ2UuZmlyc3RDaGlsZFxcbiAgICBjbS5kaXNwbGF5LmxpbmVTcGFjZS5pbnNlcnRCZWZvcmUoa2x1ZGdlLCBjbS5kaXNwbGF5LmxpbmVTcGFjZS5maXJzdENoaWxkKVxcbiAgICB0ZS52YWx1ZSA9IGxhc3RDb3BpZWQudGV4dC5qb2luKFxcXCJcXFxcblxcXCIpXFxuICAgIHZhciBoYWRGb2N1cyA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnRcXG4gICAgc2VsZWN0SW5wdXQodGUpXFxuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xcbiAgICAgIGNtLmRpc3BsYXkubGluZVNwYWNlLnJlbW92ZUNoaWxkKGtsdWRnZSlcXG4gICAgICBoYWRGb2N1cy5mb2N1cygpXFxuICAgICAgaWYgKGhhZEZvY3VzID09IGRpdikgeyBpbnB1dC5zaG93UHJpbWFyeVNlbGVjdGlvbigpIH1cXG4gICAgfSwgNTApXFxuICB9XFxuICBvbihkaXYsIFxcXCJjb3B5XFxcIiwgb25Db3B5Q3V0KVxcbiAgb24oZGl2LCBcXFwiY3V0XFxcIiwgb25Db3B5Q3V0KVxcbn07XFxuXFxuQ29udGVudEVkaXRhYmxlSW5wdXQucHJvdG90eXBlLnByZXBhcmVTZWxlY3Rpb24gPSBmdW5jdGlvbiAoKSB7XFxuICB2YXIgcmVzdWx0ID0gcHJlcGFyZVNlbGVjdGlvbih0aGlzLmNtLCBmYWxzZSlcXG4gIHJlc3VsdC5mb2N1cyA9IHRoaXMuY20uc3RhdGUuZm9jdXNlZFxcbiAgcmV0dXJuIHJlc3VsdFxcbn07XFxuXFxuQ29udGVudEVkaXRhYmxlSW5wdXQucHJvdG90eXBlLnNob3dTZWxlY3Rpb24gPSBmdW5jdGlvbiAoaW5mbywgdGFrZUZvY3VzKSB7XFxuICBpZiAoIWluZm8gfHwgIXRoaXMuY20uZGlzcGxheS52aWV3Lmxlbmd0aCkgeyByZXR1cm4gfVxcbiAgaWYgKGluZm8uZm9jdXMgfHwgdGFrZUZvY3VzKSB7IHRoaXMuc2hvd1ByaW1hcnlTZWxlY3Rpb24oKSB9XFxuICB0aGlzLnNob3dNdWx0aXBsZVNlbGVjdGlvbnMoaW5mbylcXG59O1xcblxcbkNvbnRlbnRFZGl0YWJsZUlucHV0LnByb3RvdHlwZS5zaG93UHJpbWFyeVNlbGVjdGlvbiA9IGZ1bmN0aW9uICgpIHtcXG4gIHZhciBzZWwgPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCksIHByaW0gPSB0aGlzLmNtLmRvYy5zZWwucHJpbWFyeSgpXFxuICB2YXIgY3VyQW5jaG9yID0gZG9tVG9Qb3ModGhpcy5jbSwgc2VsLmFuY2hvck5vZGUsIHNlbC5hbmNob3JPZmZzZXQpXFxuICB2YXIgY3VyRm9jdXMgPSBkb21Ub1Bvcyh0aGlzLmNtLCBzZWwuZm9jdXNOb2RlLCBzZWwuZm9jdXNPZmZzZXQpXFxuICBpZiAoY3VyQW5jaG9yICYmICFjdXJBbmNob3IuYmFkICYmIGN1ckZvY3VzICYmICFjdXJGb2N1cy5iYWQgJiZcXG4gICAgICBjbXAobWluUG9zKGN1ckFuY2hvciwgY3VyRm9jdXMpLCBwcmltLmZyb20oKSkgPT0gMCAmJlxcbiAgICAgIGNtcChtYXhQb3MoY3VyQW5jaG9yLCBjdXJGb2N1cyksIHByaW0udG8oKSkgPT0gMClcXG4gICAgeyByZXR1cm4gfVxcblxcbiAgdmFyIHN0YXJ0ID0gcG9zVG9ET00odGhpcy5jbSwgcHJpbS5mcm9tKCkpXFxuICB2YXIgZW5kID0gcG9zVG9ET00odGhpcy5jbSwgcHJpbS50bygpKVxcbiAgaWYgKCFzdGFydCAmJiAhZW5kKSB7IHJldHVybiB9XFxuXFxuICB2YXIgdmlldyA9IHRoaXMuY20uZGlzcGxheS52aWV3XFxuICB2YXIgb2xkID0gc2VsLnJhbmdlQ291bnQgJiYgc2VsLmdldFJhbmdlQXQoMClcXG4gIGlmICghc3RhcnQpIHtcXG4gICAgc3RhcnQgPSB7bm9kZTogdmlld1swXS5tZWFzdXJlLm1hcFsyXSwgb2Zmc2V0OiAwfVxcbiAgfSBlbHNlIGlmICghZW5kKSB7IC8vIEZJWE1FIGRhbmdlcm91c2x5IGhhY2t5XFxuICAgIHZhciBtZWFzdXJlID0gdmlld1t2aWV3Lmxlbmd0aCAtIDFdLm1lYXN1cmVcXG4gICAgdmFyIG1hcCA9IG1lYXN1cmUubWFwcyA/IG1lYXN1cmUubWFwc1ttZWFzdXJlLm1hcHMubGVuZ3RoIC0gMV0gOiBtZWFzdXJlLm1hcFxcbiAgICBlbmQgPSB7bm9kZTogbWFwW21hcC5sZW5ndGggLSAxXSwgb2Zmc2V0OiBtYXBbbWFwLmxlbmd0aCAtIDJdIC0gbWFwW21hcC5sZW5ndGggLSAzXX1cXG4gIH1cXG5cXG4gIHZhciBybmdcXG4gIHRyeSB7IHJuZyA9IHJhbmdlKHN0YXJ0Lm5vZGUsIHN0YXJ0Lm9mZnNldCwgZW5kLm9mZnNldCwgZW5kLm5vZGUpIH1cXG4gIGNhdGNoKGUpIHt9IC8vIE91ciBtb2RlbCBvZiB0aGUgRE9NIG1pZ2h0IGJlIG91dGRhdGVkLCBpbiB3aGljaCBjYXNlIHRoZSByYW5nZSB3ZSB0cnkgdG8gc2V0IGNhbiBiZSBpbXBvc3NpYmxlXFxuICBpZiAocm5nKSB7XFxuICAgIGlmICghZ2Vja28gJiYgdGhpcy5jbS5zdGF0ZS5mb2N1c2VkKSB7XFxuICAgICAgc2VsLmNvbGxhcHNlKHN0YXJ0Lm5vZGUsIHN0YXJ0Lm9mZnNldClcXG4gICAgICBpZiAoIXJuZy5jb2xsYXBzZWQpIHtcXG4gICAgICAgIHNlbC5yZW1vdmVBbGxSYW5nZXMoKVxcbiAgICAgICAgc2VsLmFkZFJhbmdlKHJuZylcXG4gICAgICB9XFxuICAgIH0gZWxzZSB7XFxuICAgICAgc2VsLnJlbW92ZUFsbFJhbmdlcygpXFxuICAgICAgc2VsLmFkZFJhbmdlKHJuZylcXG4gICAgfVxcbiAgICBpZiAob2xkICYmIHNlbC5hbmNob3JOb2RlID09IG51bGwpIHsgc2VsLmFkZFJhbmdlKG9sZCkgfVxcbiAgICBlbHNlIGlmIChnZWNrbykgeyB0aGlzLnN0YXJ0R3JhY2VQZXJpb2QoKSB9XFxuICB9XFxuICB0aGlzLnJlbWVtYmVyU2VsZWN0aW9uKClcXG59O1xcblxcbkNvbnRlbnRFZGl0YWJsZUlucHV0LnByb3RvdHlwZS5zdGFydEdyYWNlUGVyaW9kID0gZnVuY3Rpb24gKCkge1xcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcXG5cXG4gIGNsZWFyVGltZW91dCh0aGlzLmdyYWNlUGVyaW9kKVxcbiAgdGhpcy5ncmFjZVBlcmlvZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xcbiAgICB0aGlzJDEuZ3JhY2VQZXJpb2QgPSBmYWxzZVxcbiAgICBpZiAodGhpcyQxLnNlbGVjdGlvbkNoYW5nZWQoKSlcXG4gICAgICB7IHRoaXMkMS5jbS5vcGVyYXRpb24oZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcyQxLmNtLmN1ck9wLnNlbGVjdGlvbkNoYW5nZWQgPSB0cnVlOyB9KSB9XFxuICB9LCAyMClcXG59O1xcblxcbkNvbnRlbnRFZGl0YWJsZUlucHV0LnByb3RvdHlwZS5zaG93TXVsdGlwbGVTZWxlY3Rpb25zID0gZnVuY3Rpb24gKGluZm8pIHtcXG4gIHJlbW92ZUNoaWxkcmVuQW5kQWRkKHRoaXMuY20uZGlzcGxheS5jdXJzb3JEaXYsIGluZm8uY3Vyc29ycylcXG4gIHJlbW92ZUNoaWxkcmVuQW5kQWRkKHRoaXMuY20uZGlzcGxheS5zZWxlY3Rpb25EaXYsIGluZm8uc2VsZWN0aW9uKVxcbn07XFxuXFxuQ29udGVudEVkaXRhYmxlSW5wdXQucHJvdG90eXBlLnJlbWVtYmVyU2VsZWN0aW9uID0gZnVuY3Rpb24gKCkge1xcbiAgdmFyIHNlbCA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKVxcbiAgdGhpcy5sYXN0QW5jaG9yTm9kZSA9IHNlbC5hbmNob3JOb2RlOyB0aGlzLmxhc3RBbmNob3JPZmZzZXQgPSBzZWwuYW5jaG9yT2Zmc2V0XFxuICB0aGlzLmxhc3RGb2N1c05vZGUgPSBzZWwuZm9jdXNOb2RlOyB0aGlzLmxhc3RGb2N1c09mZnNldCA9IHNlbC5mb2N1c09mZnNldFxcbn07XFxuXFxuQ29udGVudEVkaXRhYmxlSW5wdXQucHJvdG90eXBlLnNlbGVjdGlvbkluRWRpdG9yID0gZnVuY3Rpb24gKCkge1xcbiAgdmFyIHNlbCA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKVxcbiAgaWYgKCFzZWwucmFuZ2VDb3VudCkgeyByZXR1cm4gZmFsc2UgfVxcbiAgdmFyIG5vZGUgPSBzZWwuZ2V0UmFuZ2VBdCgwKS5jb21tb25BbmNlc3RvckNvbnRhaW5lclxcbiAgcmV0dXJuIGNvbnRhaW5zKHRoaXMuZGl2LCBub2RlKVxcbn07XFxuXFxuQ29udGVudEVkaXRhYmxlSW5wdXQucHJvdG90eXBlLmZvY3VzID0gZnVuY3Rpb24gKCkge1xcbiAgaWYgKHRoaXMuY20ub3B0aW9ucy5yZWFkT25seSAhPSBcXFwibm9jdXJzb3JcXFwiKSB7XFxuICAgIGlmICghdGhpcy5zZWxlY3Rpb25JbkVkaXRvcigpKVxcbiAgICAgIHsgdGhpcy5zaG93U2VsZWN0aW9uKHRoaXMucHJlcGFyZVNlbGVjdGlvbigpLCB0cnVlKSB9XFxuICAgIHRoaXMuZGl2LmZvY3VzKClcXG4gIH1cXG59O1xcbkNvbnRlbnRFZGl0YWJsZUlucHV0LnByb3RvdHlwZS5ibHVyID0gZnVuY3Rpb24gKCkgeyB0aGlzLmRpdi5ibHVyKCkgfTtcXG5Db250ZW50RWRpdGFibGVJbnB1dC5wcm90b3R5cGUuZ2V0RmllbGQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmRpdiB9O1xcblxcbkNvbnRlbnRFZGl0YWJsZUlucHV0LnByb3RvdHlwZS5zdXBwb3J0c1RvdWNoID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdHJ1ZSB9O1xcblxcbkNvbnRlbnRFZGl0YWJsZUlucHV0LnByb3RvdHlwZS5yZWNlaXZlZEZvY3VzID0gZnVuY3Rpb24gKCkge1xcbiAgdmFyIGlucHV0ID0gdGhpc1xcbiAgaWYgKHRoaXMuc2VsZWN0aW9uSW5FZGl0b3IoKSlcXG4gICAgeyB0aGlzLnBvbGxTZWxlY3Rpb24oKSB9XFxuICBlbHNlXFxuICAgIHsgcnVuSW5PcCh0aGlzLmNtLCBmdW5jdGlvbiAoKSB7IHJldHVybiBpbnB1dC5jbS5jdXJPcC5zZWxlY3Rpb25DaGFuZ2VkID0gdHJ1ZTsgfSkgfVxcblxcbiAgZnVuY3Rpb24gcG9sbCgpIHtcXG4gICAgaWYgKGlucHV0LmNtLnN0YXRlLmZvY3VzZWQpIHtcXG4gICAgICBpbnB1dC5wb2xsU2VsZWN0aW9uKClcXG4gICAgICBpbnB1dC5wb2xsaW5nLnNldChpbnB1dC5jbS5vcHRpb25zLnBvbGxJbnRlcnZhbCwgcG9sbClcXG4gICAgfVxcbiAgfVxcbiAgdGhpcy5wb2xsaW5nLnNldCh0aGlzLmNtLm9wdGlvbnMucG9sbEludGVydmFsLCBwb2xsKVxcbn07XFxuXFxuQ29udGVudEVkaXRhYmxlSW5wdXQucHJvdG90eXBlLnNlbGVjdGlvbkNoYW5nZWQgPSBmdW5jdGlvbiAoKSB7XFxuICB2YXIgc2VsID0gd2luZG93LmdldFNlbGVjdGlvbigpXFxuICByZXR1cm4gc2VsLmFuY2hvck5vZGUgIT0gdGhpcy5sYXN0QW5jaG9yTm9kZSB8fCBzZWwuYW5jaG9yT2Zmc2V0ICE9IHRoaXMubGFzdEFuY2hvck9mZnNldCB8fFxcbiAgICBzZWwuZm9jdXNOb2RlICE9IHRoaXMubGFzdEZvY3VzTm9kZSB8fCBzZWwuZm9jdXNPZmZzZXQgIT0gdGhpcy5sYXN0Rm9jdXNPZmZzZXRcXG59O1xcblxcbkNvbnRlbnRFZGl0YWJsZUlucHV0LnByb3RvdHlwZS5wb2xsU2VsZWN0aW9uID0gZnVuY3Rpb24gKCkge1xcbiAgaWYgKCF0aGlzLmNvbXBvc2luZyAmJiB0aGlzLnJlYWRET01UaW1lb3V0ID09IG51bGwgJiYgIXRoaXMuZ3JhY2VQZXJpb2QgJiYgdGhpcy5zZWxlY3Rpb25DaGFuZ2VkKCkpIHtcXG4gICAgdmFyIHNlbCA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKSwgY20gPSB0aGlzLmNtXFxuICAgIHRoaXMucmVtZW1iZXJTZWxlY3Rpb24oKVxcbiAgICB2YXIgYW5jaG9yID0gZG9tVG9Qb3MoY20sIHNlbC5hbmNob3JOb2RlLCBzZWwuYW5jaG9yT2Zmc2V0KVxcbiAgICB2YXIgaGVhZCA9IGRvbVRvUG9zKGNtLCBzZWwuZm9jdXNOb2RlLCBzZWwuZm9jdXNPZmZzZXQpXFxuICAgIGlmIChhbmNob3IgJiYgaGVhZCkgeyBydW5Jbk9wKGNtLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgc2V0U2VsZWN0aW9uKGNtLmRvYywgc2ltcGxlU2VsZWN0aW9uKGFuY2hvciwgaGVhZCksIHNlbF9kb250U2Nyb2xsKVxcbiAgICAgIGlmIChhbmNob3IuYmFkIHx8IGhlYWQuYmFkKSB7IGNtLmN1ck9wLnNlbGVjdGlvbkNoYW5nZWQgPSB0cnVlIH1cXG4gICAgfSkgfVxcbiAgfVxcbn07XFxuXFxuQ29udGVudEVkaXRhYmxlSW5wdXQucHJvdG90eXBlLnBvbGxDb250ZW50ID0gZnVuY3Rpb24gKCkge1xcbiAgaWYgKHRoaXMucmVhZERPTVRpbWVvdXQgIT0gbnVsbCkge1xcbiAgICBjbGVhclRpbWVvdXQodGhpcy5yZWFkRE9NVGltZW91dClcXG4gICAgdGhpcy5yZWFkRE9NVGltZW91dCA9IG51bGxcXG4gIH1cXG5cXG4gIHZhciBjbSA9IHRoaXMuY20sIGRpc3BsYXkgPSBjbS5kaXNwbGF5LCBzZWwgPSBjbS5kb2Muc2VsLnByaW1hcnkoKVxcbiAgdmFyIGZyb20gPSBzZWwuZnJvbSgpLCB0byA9IHNlbC50bygpXFxuICBpZiAoZnJvbS5jaCA9PSAwICYmIGZyb20ubGluZSA+IGNtLmZpcnN0TGluZSgpKVxcbiAgICB7IGZyb20gPSBQb3MoZnJvbS5saW5lIC0gMSwgZ2V0TGluZShjbS5kb2MsIGZyb20ubGluZSAtIDEpLmxlbmd0aCkgfVxcbiAgaWYgKHRvLmNoID09IGdldExpbmUoY20uZG9jLCB0by5saW5lKS50ZXh0Lmxlbmd0aCAmJiB0by5saW5lIDwgY20ubGFzdExpbmUoKSlcXG4gICAgeyB0byA9IFBvcyh0by5saW5lICsgMSwgMCkgfVxcbiAgaWYgKGZyb20ubGluZSA8IGRpc3BsYXkudmlld0Zyb20gfHwgdG8ubGluZSA+IGRpc3BsYXkudmlld1RvIC0gMSkgeyByZXR1cm4gZmFsc2UgfVxcblxcbiAgdmFyIGZyb21JbmRleCwgZnJvbUxpbmUsIGZyb21Ob2RlXFxuICBpZiAoZnJvbS5saW5lID09IGRpc3BsYXkudmlld0Zyb20gfHwgKGZyb21JbmRleCA9IGZpbmRWaWV3SW5kZXgoY20sIGZyb20ubGluZSkpID09IDApIHtcXG4gICAgZnJvbUxpbmUgPSBsaW5lTm8oZGlzcGxheS52aWV3WzBdLmxpbmUpXFxuICAgIGZyb21Ob2RlID0gZGlzcGxheS52aWV3WzBdLm5vZGVcXG4gIH0gZWxzZSB7XFxuICAgIGZyb21MaW5lID0gbGluZU5vKGRpc3BsYXkudmlld1tmcm9tSW5kZXhdLmxpbmUpXFxuICAgIGZyb21Ob2RlID0gZGlzcGxheS52aWV3W2Zyb21JbmRleCAtIDFdLm5vZGUubmV4dFNpYmxpbmdcXG4gIH1cXG4gIHZhciB0b0luZGV4ID0gZmluZFZpZXdJbmRleChjbSwgdG8ubGluZSlcXG4gIHZhciB0b0xpbmUsIHRvTm9kZVxcbiAgaWYgKHRvSW5kZXggPT0gZGlzcGxheS52aWV3Lmxlbmd0aCAtIDEpIHtcXG4gICAgdG9MaW5lID0gZGlzcGxheS52aWV3VG8gLSAxXFxuICAgIHRvTm9kZSA9IGRpc3BsYXkubGluZURpdi5sYXN0Q2hpbGRcXG4gIH0gZWxzZSB7XFxuICAgIHRvTGluZSA9IGxpbmVObyhkaXNwbGF5LnZpZXdbdG9JbmRleCArIDFdLmxpbmUpIC0gMVxcbiAgICB0b05vZGUgPSBkaXNwbGF5LnZpZXdbdG9JbmRleCArIDFdLm5vZGUucHJldmlvdXNTaWJsaW5nXFxuICB9XFxuXFxuICBpZiAoIWZyb21Ob2RlKSB7IHJldHVybiBmYWxzZSB9XFxuICB2YXIgbmV3VGV4dCA9IGNtLmRvYy5zcGxpdExpbmVzKGRvbVRleHRCZXR3ZWVuKGNtLCBmcm9tTm9kZSwgdG9Ob2RlLCBmcm9tTGluZSwgdG9MaW5lKSlcXG4gIHZhciBvbGRUZXh0ID0gZ2V0QmV0d2VlbihjbS5kb2MsIFBvcyhmcm9tTGluZSwgMCksIFBvcyh0b0xpbmUsIGdldExpbmUoY20uZG9jLCB0b0xpbmUpLnRleHQubGVuZ3RoKSlcXG4gIHdoaWxlIChuZXdUZXh0Lmxlbmd0aCA+IDEgJiYgb2xkVGV4dC5sZW5ndGggPiAxKSB7XFxuICAgIGlmIChsc3QobmV3VGV4dCkgPT0gbHN0KG9sZFRleHQpKSB7IG5ld1RleHQucG9wKCk7IG9sZFRleHQucG9wKCk7IHRvTGluZS0tIH1cXG4gICAgZWxzZSBpZiAobmV3VGV4dFswXSA9PSBvbGRUZXh0WzBdKSB7IG5ld1RleHQuc2hpZnQoKTsgb2xkVGV4dC5zaGlmdCgpOyBmcm9tTGluZSsrIH1cXG4gICAgZWxzZSB7IGJyZWFrIH1cXG4gIH1cXG5cXG4gIHZhciBjdXRGcm9udCA9IDAsIGN1dEVuZCA9IDBcXG4gIHZhciBuZXdUb3AgPSBuZXdUZXh0WzBdLCBvbGRUb3AgPSBvbGRUZXh0WzBdLCBtYXhDdXRGcm9udCA9IE1hdGgubWluKG5ld1RvcC5sZW5ndGgsIG9sZFRvcC5sZW5ndGgpXFxuICB3aGlsZSAoY3V0RnJvbnQgPCBtYXhDdXRGcm9udCAmJiBuZXdUb3AuY2hhckNvZGVBdChjdXRGcm9udCkgPT0gb2xkVG9wLmNoYXJDb2RlQXQoY3V0RnJvbnQpKVxcbiAgICB7ICsrY3V0RnJvbnQgfVxcbiAgdmFyIG5ld0JvdCA9IGxzdChuZXdUZXh0KSwgb2xkQm90ID0gbHN0KG9sZFRleHQpXFxuICB2YXIgbWF4Q3V0RW5kID0gTWF0aC5taW4obmV3Qm90Lmxlbmd0aCAtIChuZXdUZXh0Lmxlbmd0aCA9PSAxID8gY3V0RnJvbnQgOiAwKSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBvbGRCb3QubGVuZ3RoIC0gKG9sZFRleHQubGVuZ3RoID09IDEgPyBjdXRGcm9udCA6IDApKVxcbiAgd2hpbGUgKGN1dEVuZCA8IG1heEN1dEVuZCAmJlxcbiAgICAgICAgIG5ld0JvdC5jaGFyQ29kZUF0KG5ld0JvdC5sZW5ndGggLSBjdXRFbmQgLSAxKSA9PSBvbGRCb3QuY2hhckNvZGVBdChvbGRCb3QubGVuZ3RoIC0gY3V0RW5kIC0gMSkpXFxuICAgIHsgKytjdXRFbmQgfVxcblxcbiAgbmV3VGV4dFtuZXdUZXh0Lmxlbmd0aCAtIDFdID0gbmV3Qm90LnNsaWNlKDAsIG5ld0JvdC5sZW5ndGggLSBjdXRFbmQpLnJlcGxhY2UoL15cXFxcdTIwMGIrLywgXFxcIlxcXCIpXFxuICBuZXdUZXh0WzBdID0gbmV3VGV4dFswXS5zbGljZShjdXRGcm9udCkucmVwbGFjZSgvXFxcXHUyMDBiKyQvLCBcXFwiXFxcIilcXG5cXG4gIHZhciBjaEZyb20gPSBQb3MoZnJvbUxpbmUsIGN1dEZyb250KVxcbiAgdmFyIGNoVG8gPSBQb3ModG9MaW5lLCBvbGRUZXh0Lmxlbmd0aCA/IGxzdChvbGRUZXh0KS5sZW5ndGggLSBjdXRFbmQgOiAwKVxcbiAgaWYgKG5ld1RleHQubGVuZ3RoID4gMSB8fCBuZXdUZXh0WzBdIHx8IGNtcChjaEZyb20sIGNoVG8pKSB7XFxuICAgIHJlcGxhY2VSYW5nZShjbS5kb2MsIG5ld1RleHQsIGNoRnJvbSwgY2hUbywgXFxcIitpbnB1dFxcXCIpXFxuICAgIHJldHVybiB0cnVlXFxuICB9XFxufTtcXG5cXG5Db250ZW50RWRpdGFibGVJbnB1dC5wcm90b3R5cGUuZW5zdXJlUG9sbGVkID0gZnVuY3Rpb24gKCkge1xcbiAgdGhpcy5mb3JjZUNvbXBvc2l0aW9uRW5kKClcXG59O1xcbkNvbnRlbnRFZGl0YWJsZUlucHV0LnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpIHtcXG4gIHRoaXMuZm9yY2VDb21wb3NpdGlvbkVuZCgpXFxufTtcXG5Db250ZW50RWRpdGFibGVJbnB1dC5wcm90b3R5cGUuZm9yY2VDb21wb3NpdGlvbkVuZCA9IGZ1bmN0aW9uICgpIHtcXG4gIGlmICghdGhpcy5jb21wb3NpbmcpIHsgcmV0dXJuIH1cXG4gIGNsZWFyVGltZW91dCh0aGlzLnJlYWRET01UaW1lb3V0KVxcbiAgdGhpcy5jb21wb3NpbmcgPSBudWxsXFxuICBpZiAoIXRoaXMucG9sbENvbnRlbnQoKSkgeyByZWdDaGFuZ2UodGhpcy5jbSkgfVxcbiAgdGhpcy5kaXYuYmx1cigpXFxuICB0aGlzLmRpdi5mb2N1cygpXFxufTtcXG5Db250ZW50RWRpdGFibGVJbnB1dC5wcm90b3R5cGUucmVhZEZyb21ET01Tb29uID0gZnVuY3Rpb24gKCkge1xcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcXG5cXG4gIGlmICh0aGlzLnJlYWRET01UaW1lb3V0ICE9IG51bGwpIHsgcmV0dXJuIH1cXG4gIHRoaXMucmVhZERPTVRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcXG4gICAgdGhpcyQxLnJlYWRET01UaW1lb3V0ID0gbnVsbFxcbiAgICBpZiAodGhpcyQxLmNvbXBvc2luZykge1xcbiAgICAgIGlmICh0aGlzJDEuY29tcG9zaW5nLmRvbmUpIHsgdGhpcyQxLmNvbXBvc2luZyA9IG51bGwgfVxcbiAgICAgIGVsc2UgeyByZXR1cm4gfVxcbiAgICB9XFxuICAgIGlmICh0aGlzJDEuY20uaXNSZWFkT25seSgpIHx8ICF0aGlzJDEucG9sbENvbnRlbnQoKSlcXG4gICAgICB7IHJ1bkluT3AodGhpcyQxLmNtLCBmdW5jdGlvbiAoKSB7IHJldHVybiByZWdDaGFuZ2UodGhpcyQxLmNtKTsgfSkgfVxcbiAgfSwgODApXFxufTtcXG5cXG5Db250ZW50RWRpdGFibGVJbnB1dC5wcm90b3R5cGUuc2V0VW5lZGl0YWJsZSA9IGZ1bmN0aW9uIChub2RlKSB7XFxuICBub2RlLmNvbnRlbnRFZGl0YWJsZSA9IFxcXCJmYWxzZVxcXCJcXG59O1xcblxcbkNvbnRlbnRFZGl0YWJsZUlucHV0LnByb3RvdHlwZS5vbktleVByZXNzID0gZnVuY3Rpb24gKGUpIHtcXG4gIGUucHJldmVudERlZmF1bHQoKVxcbiAgaWYgKCF0aGlzLmNtLmlzUmVhZE9ubHkoKSlcXG4gICAgeyBvcGVyYXRpb24odGhpcy5jbSwgYXBwbHlUZXh0SW5wdXQpKHRoaXMuY20sIFN0cmluZy5mcm9tQ2hhckNvZGUoZS5jaGFyQ29kZSA9PSBudWxsID8gZS5rZXlDb2RlIDogZS5jaGFyQ29kZSksIDApIH1cXG59O1xcblxcbkNvbnRlbnRFZGl0YWJsZUlucHV0LnByb3RvdHlwZS5yZWFkT25seUNoYW5nZWQgPSBmdW5jdGlvbiAodmFsKSB7XFxuICB0aGlzLmRpdi5jb250ZW50RWRpdGFibGUgPSBTdHJpbmcodmFsICE9IFxcXCJub2N1cnNvclxcXCIpXFxufTtcXG5cXG5Db250ZW50RWRpdGFibGVJbnB1dC5wcm90b3R5cGUub25Db250ZXh0TWVudSA9IGZ1bmN0aW9uICgpIHt9O1xcbkNvbnRlbnRFZGl0YWJsZUlucHV0LnByb3RvdHlwZS5yZXNldFBvc2l0aW9uID0gZnVuY3Rpb24gKCkge307XFxuXFxuQ29udGVudEVkaXRhYmxlSW5wdXQucHJvdG90eXBlLm5lZWRzQ29udGVudEF0dHJpYnV0ZSA9IHRydWVcXG5cXG5mdW5jdGlvbiBwb3NUb0RPTShjbSwgcG9zKSB7XFxuICB2YXIgdmlldyA9IGZpbmRWaWV3Rm9yTGluZShjbSwgcG9zLmxpbmUpXFxuICBpZiAoIXZpZXcgfHwgdmlldy5oaWRkZW4pIHsgcmV0dXJuIG51bGwgfVxcbiAgdmFyIGxpbmUgPSBnZXRMaW5lKGNtLmRvYywgcG9zLmxpbmUpXFxuICB2YXIgaW5mbyA9IG1hcEZyb21MaW5lVmlldyh2aWV3LCBsaW5lLCBwb3MubGluZSlcXG5cXG4gIHZhciBvcmRlciA9IGdldE9yZGVyKGxpbmUpLCBzaWRlID0gXFxcImxlZnRcXFwiXFxuICBpZiAob3JkZXIpIHtcXG4gICAgdmFyIHBhcnRQb3MgPSBnZXRCaWRpUGFydEF0KG9yZGVyLCBwb3MuY2gpXFxuICAgIHNpZGUgPSBwYXJ0UG9zICUgMiA/IFxcXCJyaWdodFxcXCIgOiBcXFwibGVmdFxcXCJcXG4gIH1cXG4gIHZhciByZXN1bHQgPSBub2RlQW5kT2Zmc2V0SW5MaW5lTWFwKGluZm8ubWFwLCBwb3MuY2gsIHNpZGUpXFxuICByZXN1bHQub2Zmc2V0ID0gcmVzdWx0LmNvbGxhcHNlID09IFxcXCJyaWdodFxcXCIgPyByZXN1bHQuZW5kIDogcmVzdWx0LnN0YXJ0XFxuICByZXR1cm4gcmVzdWx0XFxufVxcblxcbmZ1bmN0aW9uIGJhZFBvcyhwb3MsIGJhZCkgeyBpZiAoYmFkKSB7IHBvcy5iYWQgPSB0cnVlOyB9IHJldHVybiBwb3MgfVxcblxcbmZ1bmN0aW9uIGRvbVRleHRCZXR3ZWVuKGNtLCBmcm9tLCB0bywgZnJvbUxpbmUsIHRvTGluZSkge1xcbiAgdmFyIHRleHQgPSBcXFwiXFxcIiwgY2xvc2luZyA9IGZhbHNlLCBsaW5lU2VwID0gY20uZG9jLmxpbmVTZXBhcmF0b3IoKVxcbiAgZnVuY3Rpb24gcmVjb2duaXplTWFya2VyKGlkKSB7IHJldHVybiBmdW5jdGlvbiAobWFya2VyKSB7IHJldHVybiBtYXJrZXIuaWQgPT0gaWQ7IH0gfVxcbiAgZnVuY3Rpb24gd2Fsayhub2RlKSB7XFxuICAgIGlmIChub2RlLm5vZGVUeXBlID09IDEpIHtcXG4gICAgICB2YXIgY21UZXh0ID0gbm9kZS5nZXRBdHRyaWJ1dGUoXFxcImNtLXRleHRcXFwiKVxcbiAgICAgIGlmIChjbVRleHQgIT0gbnVsbCkge1xcbiAgICAgICAgaWYgKGNtVGV4dCA9PSBcXFwiXFxcIikgeyB0ZXh0ICs9IG5vZGUudGV4dENvbnRlbnQucmVwbGFjZSgvXFxcXHUyMDBiL2csIFxcXCJcXFwiKSB9XFxuICAgICAgICBlbHNlIHsgdGV4dCArPSBjbVRleHQgfVxcbiAgICAgICAgcmV0dXJuXFxuICAgICAgfVxcbiAgICAgIHZhciBtYXJrZXJJRCA9IG5vZGUuZ2V0QXR0cmlidXRlKFxcXCJjbS1tYXJrZXJcXFwiKSwgcmFuZ2VcXG4gICAgICBpZiAobWFya2VySUQpIHtcXG4gICAgICAgIHZhciBmb3VuZCA9IGNtLmZpbmRNYXJrcyhQb3MoZnJvbUxpbmUsIDApLCBQb3ModG9MaW5lICsgMSwgMCksIHJlY29nbml6ZU1hcmtlcigrbWFya2VySUQpKVxcbiAgICAgICAgaWYgKGZvdW5kLmxlbmd0aCAmJiAocmFuZ2UgPSBmb3VuZFswXS5maW5kKCkpKVxcbiAgICAgICAgICB7IHRleHQgKz0gZ2V0QmV0d2VlbihjbS5kb2MsIHJhbmdlLmZyb20sIHJhbmdlLnRvKS5qb2luKGxpbmVTZXApIH1cXG4gICAgICAgIHJldHVyblxcbiAgICAgIH1cXG4gICAgICBpZiAobm9kZS5nZXRBdHRyaWJ1dGUoXFxcImNvbnRlbnRlZGl0YWJsZVxcXCIpID09IFxcXCJmYWxzZVxcXCIpIHsgcmV0dXJuIH1cXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUuY2hpbGROb2Rlcy5sZW5ndGg7IGkrKylcXG4gICAgICAgIHsgd2Fsayhub2RlLmNoaWxkTm9kZXNbaV0pIH1cXG4gICAgICBpZiAoL14ocHJlfGRpdnxwKSQvaS50ZXN0KG5vZGUubm9kZU5hbWUpKVxcbiAgICAgICAgeyBjbG9zaW5nID0gdHJ1ZSB9XFxuICAgIH0gZWxzZSBpZiAobm9kZS5ub2RlVHlwZSA9PSAzKSB7XFxuICAgICAgdmFyIHZhbCA9IG5vZGUubm9kZVZhbHVlXFxuICAgICAgaWYgKCF2YWwpIHsgcmV0dXJuIH1cXG4gICAgICBpZiAoY2xvc2luZykge1xcbiAgICAgICAgdGV4dCArPSBsaW5lU2VwXFxuICAgICAgICBjbG9zaW5nID0gZmFsc2VcXG4gICAgICB9XFxuICAgICAgdGV4dCArPSB2YWxcXG4gICAgfVxcbiAgfVxcbiAgZm9yICg7Oykge1xcbiAgICB3YWxrKGZyb20pXFxuICAgIGlmIChmcm9tID09IHRvKSB7IGJyZWFrIH1cXG4gICAgZnJvbSA9IGZyb20ubmV4dFNpYmxpbmdcXG4gIH1cXG4gIHJldHVybiB0ZXh0XFxufVxcblxcbmZ1bmN0aW9uIGRvbVRvUG9zKGNtLCBub2RlLCBvZmZzZXQpIHtcXG4gIHZhciBsaW5lTm9kZVxcbiAgaWYgKG5vZGUgPT0gY20uZGlzcGxheS5saW5lRGl2KSB7XFxuICAgIGxpbmVOb2RlID0gY20uZGlzcGxheS5saW5lRGl2LmNoaWxkTm9kZXNbb2Zmc2V0XVxcbiAgICBpZiAoIWxpbmVOb2RlKSB7IHJldHVybiBiYWRQb3MoY20uY2xpcFBvcyhQb3MoY20uZGlzcGxheS52aWV3VG8gLSAxKSksIHRydWUpIH1cXG4gICAgbm9kZSA9IG51bGw7IG9mZnNldCA9IDBcXG4gIH0gZWxzZSB7XFxuICAgIGZvciAobGluZU5vZGUgPSBub2RlOzsgbGluZU5vZGUgPSBsaW5lTm9kZS5wYXJlbnROb2RlKSB7XFxuICAgICAgaWYgKCFsaW5lTm9kZSB8fCBsaW5lTm9kZSA9PSBjbS5kaXNwbGF5LmxpbmVEaXYpIHsgcmV0dXJuIG51bGwgfVxcbiAgICAgIGlmIChsaW5lTm9kZS5wYXJlbnROb2RlICYmIGxpbmVOb2RlLnBhcmVudE5vZGUgPT0gY20uZGlzcGxheS5saW5lRGl2KSB7IGJyZWFrIH1cXG4gICAgfVxcbiAgfVxcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjbS5kaXNwbGF5LnZpZXcubGVuZ3RoOyBpKyspIHtcXG4gICAgdmFyIGxpbmVWaWV3ID0gY20uZGlzcGxheS52aWV3W2ldXFxuICAgIGlmIChsaW5lVmlldy5ub2RlID09IGxpbmVOb2RlKVxcbiAgICAgIHsgcmV0dXJuIGxvY2F0ZU5vZGVJbkxpbmVWaWV3KGxpbmVWaWV3LCBub2RlLCBvZmZzZXQpIH1cXG4gIH1cXG59XFxuXFxuZnVuY3Rpb24gbG9jYXRlTm9kZUluTGluZVZpZXcobGluZVZpZXcsIG5vZGUsIG9mZnNldCkge1xcbiAgdmFyIHdyYXBwZXIgPSBsaW5lVmlldy50ZXh0LmZpcnN0Q2hpbGQsIGJhZCA9IGZhbHNlXFxuICBpZiAoIW5vZGUgfHwgIWNvbnRhaW5zKHdyYXBwZXIsIG5vZGUpKSB7IHJldHVybiBiYWRQb3MoUG9zKGxpbmVObyhsaW5lVmlldy5saW5lKSwgMCksIHRydWUpIH1cXG4gIGlmIChub2RlID09IHdyYXBwZXIpIHtcXG4gICAgYmFkID0gdHJ1ZVxcbiAgICBub2RlID0gd3JhcHBlci5jaGlsZE5vZGVzW29mZnNldF1cXG4gICAgb2Zmc2V0ID0gMFxcbiAgICBpZiAoIW5vZGUpIHtcXG4gICAgICB2YXIgbGluZSA9IGxpbmVWaWV3LnJlc3QgPyBsc3QobGluZVZpZXcucmVzdCkgOiBsaW5lVmlldy5saW5lXFxuICAgICAgcmV0dXJuIGJhZFBvcyhQb3MobGluZU5vKGxpbmUpLCBsaW5lLnRleHQubGVuZ3RoKSwgYmFkKVxcbiAgICB9XFxuICB9XFxuXFxuICB2YXIgdGV4dE5vZGUgPSBub2RlLm5vZGVUeXBlID09IDMgPyBub2RlIDogbnVsbCwgdG9wTm9kZSA9IG5vZGVcXG4gIGlmICghdGV4dE5vZGUgJiYgbm9kZS5jaGlsZE5vZGVzLmxlbmd0aCA9PSAxICYmIG5vZGUuZmlyc3RDaGlsZC5ub2RlVHlwZSA9PSAzKSB7XFxuICAgIHRleHROb2RlID0gbm9kZS5maXJzdENoaWxkXFxuICAgIGlmIChvZmZzZXQpIHsgb2Zmc2V0ID0gdGV4dE5vZGUubm9kZVZhbHVlLmxlbmd0aCB9XFxuICB9XFxuICB3aGlsZSAodG9wTm9kZS5wYXJlbnROb2RlICE9IHdyYXBwZXIpIHsgdG9wTm9kZSA9IHRvcE5vZGUucGFyZW50Tm9kZSB9XFxuICB2YXIgbWVhc3VyZSA9IGxpbmVWaWV3Lm1lYXN1cmUsIG1hcHMgPSBtZWFzdXJlLm1hcHNcXG5cXG4gIGZ1bmN0aW9uIGZpbmQodGV4dE5vZGUsIHRvcE5vZGUsIG9mZnNldCkge1xcbiAgICBmb3IgKHZhciBpID0gLTE7IGkgPCAobWFwcyA/IG1hcHMubGVuZ3RoIDogMCk7IGkrKykge1xcbiAgICAgIHZhciBtYXAgPSBpIDwgMCA/IG1lYXN1cmUubWFwIDogbWFwc1tpXVxcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbWFwLmxlbmd0aDsgaiArPSAzKSB7XFxuICAgICAgICB2YXIgY3VyTm9kZSA9IG1hcFtqICsgMl1cXG4gICAgICAgIGlmIChjdXJOb2RlID09IHRleHROb2RlIHx8IGN1ck5vZGUgPT0gdG9wTm9kZSkge1xcbiAgICAgICAgICB2YXIgbGluZSA9IGxpbmVObyhpIDwgMCA/IGxpbmVWaWV3LmxpbmUgOiBsaW5lVmlldy5yZXN0W2ldKVxcbiAgICAgICAgICB2YXIgY2ggPSBtYXBbal0gKyBvZmZzZXRcXG4gICAgICAgICAgaWYgKG9mZnNldCA8IDAgfHwgY3VyTm9kZSAhPSB0ZXh0Tm9kZSkgeyBjaCA9IG1hcFtqICsgKG9mZnNldCA/IDEgOiAwKV0gfVxcbiAgICAgICAgICByZXR1cm4gUG9zKGxpbmUsIGNoKVxcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgfVxcbiAgfVxcbiAgdmFyIGZvdW5kID0gZmluZCh0ZXh0Tm9kZSwgdG9wTm9kZSwgb2Zmc2V0KVxcbiAgaWYgKGZvdW5kKSB7IHJldHVybiBiYWRQb3MoZm91bmQsIGJhZCkgfVxcblxcbiAgLy8gRklYTUUgdGhpcyBpcyBhbGwgcmVhbGx5IHNoYWt5LiBtaWdodCBoYW5kbGUgdGhlIGZldyBjYXNlcyBpdCBuZWVkcyB0byBoYW5kbGUsIGJ1dCBsaWtlbHkgdG8gY2F1c2UgcHJvYmxlbXNcXG4gIGZvciAodmFyIGFmdGVyID0gdG9wTm9kZS5uZXh0U2libGluZywgZGlzdCA9IHRleHROb2RlID8gdGV4dE5vZGUubm9kZVZhbHVlLmxlbmd0aCAtIG9mZnNldCA6IDA7IGFmdGVyOyBhZnRlciA9IGFmdGVyLm5leHRTaWJsaW5nKSB7XFxuICAgIGZvdW5kID0gZmluZChhZnRlciwgYWZ0ZXIuZmlyc3RDaGlsZCwgMClcXG4gICAgaWYgKGZvdW5kKVxcbiAgICAgIHsgcmV0dXJuIGJhZFBvcyhQb3MoZm91bmQubGluZSwgZm91bmQuY2ggLSBkaXN0KSwgYmFkKSB9XFxuICAgIGVsc2VcXG4gICAgICB7IGRpc3QgKz0gYWZ0ZXIudGV4dENvbnRlbnQubGVuZ3RoIH1cXG4gIH1cXG4gIGZvciAodmFyIGJlZm9yZSA9IHRvcE5vZGUucHJldmlvdXNTaWJsaW5nLCBkaXN0JDEgPSBvZmZzZXQ7IGJlZm9yZTsgYmVmb3JlID0gYmVmb3JlLnByZXZpb3VzU2libGluZykge1xcbiAgICBmb3VuZCA9IGZpbmQoYmVmb3JlLCBiZWZvcmUuZmlyc3RDaGlsZCwgLTEpXFxuICAgIGlmIChmb3VuZClcXG4gICAgICB7IHJldHVybiBiYWRQb3MoUG9zKGZvdW5kLmxpbmUsIGZvdW5kLmNoICsgZGlzdCQxKSwgYmFkKSB9XFxuICAgIGVsc2VcXG4gICAgICB7IGRpc3QkMSArPSBiZWZvcmUudGV4dENvbnRlbnQubGVuZ3RoIH1cXG4gIH1cXG59XFxuXFxuLy8gVEVYVEFSRUEgSU5QVVQgU1RZTEVcXG5cXG52YXIgVGV4dGFyZWFJbnB1dCA9IGZ1bmN0aW9uKGNtKSB7XFxuICB0aGlzLmNtID0gY21cXG4gIC8vIFNlZSBpbnB1dC5wb2xsIGFuZCBpbnB1dC5yZXNldFxcbiAgdGhpcy5wcmV2SW5wdXQgPSBcXFwiXFxcIlxcblxcbiAgLy8gRmxhZyB0aGF0IGluZGljYXRlcyB3aGV0aGVyIHdlIGV4cGVjdCBpbnB1dCB0byBhcHBlYXIgcmVhbCBzb29uXFxuICAvLyBub3cgKGFmdGVyIHNvbWUgZXZlbnQgbGlrZSAna2V5cHJlc3MnIG9yICdpbnB1dCcpIGFuZCBhcmVcXG4gIC8vIHBvbGxpbmcgaW50ZW5zaXZlbHkuXFxuICB0aGlzLnBvbGxpbmdGYXN0ID0gZmFsc2VcXG4gIC8vIFNlbGYtcmVzZXR0aW5nIHRpbWVvdXQgZm9yIHRoZSBwb2xsZXJcXG4gIHRoaXMucG9sbGluZyA9IG5ldyBEZWxheWVkKClcXG4gIC8vIFRyYWNrcyB3aGVuIGlucHV0LnJlc2V0IGhhcyBwdW50ZWQgdG8ganVzdCBwdXR0aW5nIGEgc2hvcnRcXG4gIC8vIHN0cmluZyBpbnRvIHRoZSB0ZXh0YXJlYSBpbnN0ZWFkIG9mIHRoZSBmdWxsIHNlbGVjdGlvbi5cXG4gIHRoaXMuaW5hY2N1cmF0ZVNlbGVjdGlvbiA9IGZhbHNlXFxuICAvLyBVc2VkIHRvIHdvcmsgYXJvdW5kIElFIGlzc3VlIHdpdGggc2VsZWN0aW9uIGJlaW5nIGZvcmdvdHRlbiB3aGVuIGZvY3VzIG1vdmVzIGF3YXkgZnJvbSB0ZXh0YXJlYVxcbiAgdGhpcy5oYXNTZWxlY3Rpb24gPSBmYWxzZVxcbiAgdGhpcy5jb21wb3NpbmcgPSBudWxsXFxufTtcXG5cXG5UZXh0YXJlYUlucHV0LnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKGRpc3BsYXkpIHtcXG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XFxuXFxuICB2YXIgaW5wdXQgPSB0aGlzLCBjbSA9IHRoaXMuY21cXG5cXG4gIC8vIFdyYXBzIGFuZCBoaWRlcyBpbnB1dCB0ZXh0YXJlYVxcbiAgdmFyIGRpdiA9IHRoaXMud3JhcHBlciA9IGhpZGRlblRleHRhcmVhKClcXG4gIC8vIFRoZSBzZW1paGlkZGVuIHRleHRhcmVhIHRoYXQgaXMgZm9jdXNlZCB3aGVuIHRoZSBlZGl0b3IgaXNcXG4gIC8vIGZvY3VzZWQsIGFuZCByZWNlaXZlcyBpbnB1dC5cXG4gIHZhciB0ZSA9IHRoaXMudGV4dGFyZWEgPSBkaXYuZmlyc3RDaGlsZFxcbiAgZGlzcGxheS53cmFwcGVyLmluc2VydEJlZm9yZShkaXYsIGRpc3BsYXkud3JhcHBlci5maXJzdENoaWxkKVxcblxcbiAgLy8gTmVlZGVkIHRvIGhpZGUgYmlnIGJsdWUgYmxpbmtpbmcgY3Vyc29yIG9uIE1vYmlsZSBTYWZhcmkgKGRvZXNuJ3Qgc2VlbSB0byB3b3JrIGluIGlPUyA4IGFueW1vcmUpXFxuICBpZiAoaW9zKSB7IHRlLnN0eWxlLndpZHRoID0gXFxcIjBweFxcXCIgfVxcblxcbiAgb24odGUsIFxcXCJpbnB1dFxcXCIsIGZ1bmN0aW9uICgpIHtcXG4gICAgaWYgKGllICYmIGllX3ZlcnNpb24gPj0gOSAmJiB0aGlzJDEuaGFzU2VsZWN0aW9uKSB7IHRoaXMkMS5oYXNTZWxlY3Rpb24gPSBudWxsIH1cXG4gICAgaW5wdXQucG9sbCgpXFxuICB9KVxcblxcbiAgb24odGUsIFxcXCJwYXN0ZVxcXCIsIGZ1bmN0aW9uIChlKSB7XFxuICAgIGlmIChzaWduYWxET01FdmVudChjbSwgZSkgfHwgaGFuZGxlUGFzdGUoZSwgY20pKSB7IHJldHVybiB9XFxuXFxuICAgIGNtLnN0YXRlLnBhc3RlSW5jb21pbmcgPSB0cnVlXFxuICAgIGlucHV0LmZhc3RQb2xsKClcXG4gIH0pXFxuXFxuICBmdW5jdGlvbiBwcmVwYXJlQ29weUN1dChlKSB7XFxuICAgIGlmIChzaWduYWxET01FdmVudChjbSwgZSkpIHsgcmV0dXJuIH1cXG4gICAgaWYgKGNtLnNvbWV0aGluZ1NlbGVjdGVkKCkpIHtcXG4gICAgICBzZXRMYXN0Q29waWVkKHtsaW5lV2lzZTogZmFsc2UsIHRleHQ6IGNtLmdldFNlbGVjdGlvbnMoKX0pXFxuICAgICAgaWYgKGlucHV0LmluYWNjdXJhdGVTZWxlY3Rpb24pIHtcXG4gICAgICAgIGlucHV0LnByZXZJbnB1dCA9IFxcXCJcXFwiXFxuICAgICAgICBpbnB1dC5pbmFjY3VyYXRlU2VsZWN0aW9uID0gZmFsc2VcXG4gICAgICAgIHRlLnZhbHVlID0gbGFzdENvcGllZC50ZXh0LmpvaW4oXFxcIlxcXFxuXFxcIilcXG4gICAgICAgIHNlbGVjdElucHV0KHRlKVxcbiAgICAgIH1cXG4gICAgfSBlbHNlIGlmICghY20ub3B0aW9ucy5saW5lV2lzZUNvcHlDdXQpIHtcXG4gICAgICByZXR1cm5cXG4gICAgfSBlbHNlIHtcXG4gICAgICB2YXIgcmFuZ2VzID0gY29weWFibGVSYW5nZXMoY20pXFxuICAgICAgc2V0TGFzdENvcGllZCh7bGluZVdpc2U6IHRydWUsIHRleHQ6IHJhbmdlcy50ZXh0fSlcXG4gICAgICBpZiAoZS50eXBlID09IFxcXCJjdXRcXFwiKSB7XFxuICAgICAgICBjbS5zZXRTZWxlY3Rpb25zKHJhbmdlcy5yYW5nZXMsIG51bGwsIHNlbF9kb250U2Nyb2xsKVxcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBpbnB1dC5wcmV2SW5wdXQgPSBcXFwiXFxcIlxcbiAgICAgICAgdGUudmFsdWUgPSByYW5nZXMudGV4dC5qb2luKFxcXCJcXFxcblxcXCIpXFxuICAgICAgICBzZWxlY3RJbnB1dCh0ZSlcXG4gICAgICB9XFxuICAgIH1cXG4gICAgaWYgKGUudHlwZSA9PSBcXFwiY3V0XFxcIikgeyBjbS5zdGF0ZS5jdXRJbmNvbWluZyA9IHRydWUgfVxcbiAgfVxcbiAgb24odGUsIFxcXCJjdXRcXFwiLCBwcmVwYXJlQ29weUN1dClcXG4gIG9uKHRlLCBcXFwiY29weVxcXCIsIHByZXBhcmVDb3B5Q3V0KVxcblxcbiAgb24oZGlzcGxheS5zY3JvbGxlciwgXFxcInBhc3RlXFxcIiwgZnVuY3Rpb24gKGUpIHtcXG4gICAgaWYgKGV2ZW50SW5XaWRnZXQoZGlzcGxheSwgZSkgfHwgc2lnbmFsRE9NRXZlbnQoY20sIGUpKSB7IHJldHVybiB9XFxuICAgIGNtLnN0YXRlLnBhc3RlSW5jb21pbmcgPSB0cnVlXFxuICAgIGlucHV0LmZvY3VzKClcXG4gIH0pXFxuXFxuICAvLyBQcmV2ZW50IG5vcm1hbCBzZWxlY3Rpb24gaW4gdGhlIGVkaXRvciAod2UgaGFuZGxlIG91ciBvd24pXFxuICBvbihkaXNwbGF5LmxpbmVTcGFjZSwgXFxcInNlbGVjdHN0YXJ0XFxcIiwgZnVuY3Rpb24gKGUpIHtcXG4gICAgaWYgKCFldmVudEluV2lkZ2V0KGRpc3BsYXksIGUpKSB7IGVfcHJldmVudERlZmF1bHQoZSkgfVxcbiAgfSlcXG5cXG4gIG9uKHRlLCBcXFwiY29tcG9zaXRpb25zdGFydFxcXCIsIGZ1bmN0aW9uICgpIHtcXG4gICAgdmFyIHN0YXJ0ID0gY20uZ2V0Q3Vyc29yKFxcXCJmcm9tXFxcIilcXG4gICAgaWYgKGlucHV0LmNvbXBvc2luZykgeyBpbnB1dC5jb21wb3NpbmcucmFuZ2UuY2xlYXIoKSB9XFxuICAgIGlucHV0LmNvbXBvc2luZyA9IHtcXG4gICAgICBzdGFydDogc3RhcnQsXFxuICAgICAgcmFuZ2U6IGNtLm1hcmtUZXh0KHN0YXJ0LCBjbS5nZXRDdXJzb3IoXFxcInRvXFxcIiksIHtjbGFzc05hbWU6IFxcXCJDb2RlTWlycm9yLWNvbXBvc2luZ1xcXCJ9KVxcbiAgICB9XFxuICB9KVxcbiAgb24odGUsIFxcXCJjb21wb3NpdGlvbmVuZFxcXCIsIGZ1bmN0aW9uICgpIHtcXG4gICAgaWYgKGlucHV0LmNvbXBvc2luZykge1xcbiAgICAgIGlucHV0LnBvbGwoKVxcbiAgICAgIGlucHV0LmNvbXBvc2luZy5yYW5nZS5jbGVhcigpXFxuICAgICAgaW5wdXQuY29tcG9zaW5nID0gbnVsbFxcbiAgICB9XFxuICB9KVxcbn07XFxuXFxuVGV4dGFyZWFJbnB1dC5wcm90b3R5cGUucHJlcGFyZVNlbGVjdGlvbiA9IGZ1bmN0aW9uICgpIHtcXG4gIC8vIFJlZHJhdyB0aGUgc2VsZWN0aW9uIGFuZC9vciBjdXJzb3JcXG4gIHZhciBjbSA9IHRoaXMuY20sIGRpc3BsYXkgPSBjbS5kaXNwbGF5LCBkb2MgPSBjbS5kb2NcXG4gIHZhciByZXN1bHQgPSBwcmVwYXJlU2VsZWN0aW9uKGNtKVxcblxcbiAgLy8gTW92ZSB0aGUgaGlkZGVuIHRleHRhcmVhIG5lYXIgdGhlIGN1cnNvciB0byBwcmV2ZW50IHNjcm9sbGluZyBhcnRpZmFjdHNcXG4gIGlmIChjbS5vcHRpb25zLm1vdmVJbnB1dFdpdGhDdXJzb3IpIHtcXG4gICAgdmFyIGhlYWRQb3MgPSBjdXJzb3JDb29yZHMoY20sIGRvYy5zZWwucHJpbWFyeSgpLmhlYWQsIFxcXCJkaXZcXFwiKVxcbiAgICB2YXIgd3JhcE9mZiA9IGRpc3BsYXkud3JhcHBlci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgbGluZU9mZiA9IGRpc3BsYXkubGluZURpdi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxcbiAgICByZXN1bHQudGVUb3AgPSBNYXRoLm1heCgwLCBNYXRoLm1pbihkaXNwbGF5LndyYXBwZXIuY2xpZW50SGVpZ2h0IC0gMTAsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRQb3MudG9wICsgbGluZU9mZi50b3AgLSB3cmFwT2ZmLnRvcCkpXFxuICAgIHJlc3VsdC50ZUxlZnQgPSBNYXRoLm1heCgwLCBNYXRoLm1pbihkaXNwbGF5LndyYXBwZXIuY2xpZW50V2lkdGggLSAxMCxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRQb3MubGVmdCArIGxpbmVPZmYubGVmdCAtIHdyYXBPZmYubGVmdCkpXFxuICB9XFxuXFxuICByZXR1cm4gcmVzdWx0XFxufTtcXG5cXG5UZXh0YXJlYUlucHV0LnByb3RvdHlwZS5zaG93U2VsZWN0aW9uID0gZnVuY3Rpb24gKGRyYXduKSB7XFxuICB2YXIgY20gPSB0aGlzLmNtLCBkaXNwbGF5ID0gY20uZGlzcGxheVxcbiAgcmVtb3ZlQ2hpbGRyZW5BbmRBZGQoZGlzcGxheS5jdXJzb3JEaXYsIGRyYXduLmN1cnNvcnMpXFxuICByZW1vdmVDaGlsZHJlbkFuZEFkZChkaXNwbGF5LnNlbGVjdGlvbkRpdiwgZHJhd24uc2VsZWN0aW9uKVxcbiAgaWYgKGRyYXduLnRlVG9wICE9IG51bGwpIHtcXG4gICAgdGhpcy53cmFwcGVyLnN0eWxlLnRvcCA9IGRyYXduLnRlVG9wICsgXFxcInB4XFxcIlxcbiAgICB0aGlzLndyYXBwZXIuc3R5bGUubGVmdCA9IGRyYXduLnRlTGVmdCArIFxcXCJweFxcXCJcXG4gIH1cXG59O1xcblxcbi8vIFJlc2V0IHRoZSBpbnB1dCB0byBjb3JyZXNwb25kIHRvIHRoZSBzZWxlY3Rpb24gKG9yIHRvIGJlIGVtcHR5LFxcbi8vIHdoZW4gbm90IHR5cGluZyBhbmQgbm90aGluZyBpcyBzZWxlY3RlZClcXG5UZXh0YXJlYUlucHV0LnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICh0eXBpbmcpIHtcXG4gIGlmICh0aGlzLmNvbnRleHRNZW51UGVuZGluZykgeyByZXR1cm4gfVxcbiAgdmFyIG1pbmltYWwsIHNlbGVjdGVkLCBjbSA9IHRoaXMuY20sIGRvYyA9IGNtLmRvY1xcbiAgaWYgKGNtLnNvbWV0aGluZ1NlbGVjdGVkKCkpIHtcXG4gICAgdGhpcy5wcmV2SW5wdXQgPSBcXFwiXFxcIlxcbiAgICB2YXIgcmFuZ2UgPSBkb2Muc2VsLnByaW1hcnkoKVxcbiAgICBtaW5pbWFsID0gaGFzQ29weUV2ZW50ICYmXFxuICAgICAgKHJhbmdlLnRvKCkubGluZSAtIHJhbmdlLmZyb20oKS5saW5lID4gMTAwIHx8IChzZWxlY3RlZCA9IGNtLmdldFNlbGVjdGlvbigpKS5sZW5ndGggPiAxMDAwKVxcbiAgICB2YXIgY29udGVudCA9IG1pbmltYWwgPyBcXFwiLVxcXCIgOiBzZWxlY3RlZCB8fCBjbS5nZXRTZWxlY3Rpb24oKVxcbiAgICB0aGlzLnRleHRhcmVhLnZhbHVlID0gY29udGVudFxcbiAgICBpZiAoY20uc3RhdGUuZm9jdXNlZCkgeyBzZWxlY3RJbnB1dCh0aGlzLnRleHRhcmVhKSB9XFxuICAgIGlmIChpZSAmJiBpZV92ZXJzaW9uID49IDkpIHsgdGhpcy5oYXNTZWxlY3Rpb24gPSBjb250ZW50IH1cXG4gIH0gZWxzZSBpZiAoIXR5cGluZykge1xcbiAgICB0aGlzLnByZXZJbnB1dCA9IHRoaXMudGV4dGFyZWEudmFsdWUgPSBcXFwiXFxcIlxcbiAgICBpZiAoaWUgJiYgaWVfdmVyc2lvbiA+PSA5KSB7IHRoaXMuaGFzU2VsZWN0aW9uID0gbnVsbCB9XFxuICB9XFxuICB0aGlzLmluYWNjdXJhdGVTZWxlY3Rpb24gPSBtaW5pbWFsXFxufTtcXG5cXG5UZXh0YXJlYUlucHV0LnByb3RvdHlwZS5nZXRGaWVsZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMudGV4dGFyZWEgfTtcXG5cXG5UZXh0YXJlYUlucHV0LnByb3RvdHlwZS5zdXBwb3J0c1RvdWNoID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gZmFsc2UgfTtcXG5cXG5UZXh0YXJlYUlucHV0LnByb3RvdHlwZS5mb2N1cyA9IGZ1bmN0aW9uICgpIHtcXG4gIGlmICh0aGlzLmNtLm9wdGlvbnMucmVhZE9ubHkgIT0gXFxcIm5vY3Vyc29yXFxcIiAmJiAoIW1vYmlsZSB8fCBhY3RpdmVFbHQoKSAhPSB0aGlzLnRleHRhcmVhKSkge1xcbiAgICB0cnkgeyB0aGlzLnRleHRhcmVhLmZvY3VzKCkgfVxcbiAgICBjYXRjaCAoZSkge30gLy8gSUU4IHdpbGwgdGhyb3cgaWYgdGhlIHRleHRhcmVhIGlzIGRpc3BsYXk6IG5vbmUgb3Igbm90IGluIERPTVxcbiAgfVxcbn07XFxuXFxuVGV4dGFyZWFJbnB1dC5wcm90b3R5cGUuYmx1ciA9IGZ1bmN0aW9uICgpIHsgdGhpcy50ZXh0YXJlYS5ibHVyKCkgfTtcXG5cXG5UZXh0YXJlYUlucHV0LnByb3RvdHlwZS5yZXNldFBvc2l0aW9uID0gZnVuY3Rpb24gKCkge1xcbiAgdGhpcy53cmFwcGVyLnN0eWxlLnRvcCA9IHRoaXMud3JhcHBlci5zdHlsZS5sZWZ0ID0gMFxcbn07XFxuXFxuVGV4dGFyZWFJbnB1dC5wcm90b3R5cGUucmVjZWl2ZWRGb2N1cyA9IGZ1bmN0aW9uICgpIHsgdGhpcy5zbG93UG9sbCgpIH07XFxuXFxuLy8gUG9sbCBmb3IgaW5wdXQgY2hhbmdlcywgdXNpbmcgdGhlIG5vcm1hbCByYXRlIG9mIHBvbGxpbmcuIFRoaXNcXG4vLyBydW5zIGFzIGxvbmcgYXMgdGhlIGVkaXRvciBpcyBmb2N1c2VkLlxcblRleHRhcmVhSW5wdXQucHJvdG90eXBlLnNsb3dQb2xsID0gZnVuY3Rpb24gKCkge1xcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcXG5cXG4gIGlmICh0aGlzLnBvbGxpbmdGYXN0KSB7IHJldHVybiB9XFxuICB0aGlzLnBvbGxpbmcuc2V0KHRoaXMuY20ub3B0aW9ucy5wb2xsSW50ZXJ2YWwsIGZ1bmN0aW9uICgpIHtcXG4gICAgdGhpcyQxLnBvbGwoKVxcbiAgICBpZiAodGhpcyQxLmNtLnN0YXRlLmZvY3VzZWQpIHsgdGhpcyQxLnNsb3dQb2xsKCkgfVxcbiAgfSlcXG59O1xcblxcbi8vIFdoZW4gYW4gZXZlbnQgaGFzIGp1c3QgY29tZSBpbiB0aGF0IGlzIGxpa2VseSB0byBhZGQgb3IgY2hhbmdlXFxuLy8gc29tZXRoaW5nIGluIHRoZSBpbnB1dCB0ZXh0YXJlYSwgd2UgcG9sbCBmYXN0ZXIsIHRvIGVuc3VyZSB0aGF0XFxuLy8gdGhlIGNoYW5nZSBhcHBlYXJzIG9uIHRoZSBzY3JlZW4gcXVpY2tseS5cXG5UZXh0YXJlYUlucHV0LnByb3RvdHlwZS5mYXN0UG9sbCA9IGZ1bmN0aW9uICgpIHtcXG4gIHZhciBtaXNzZWQgPSBmYWxzZSwgaW5wdXQgPSB0aGlzXFxuICBpbnB1dC5wb2xsaW5nRmFzdCA9IHRydWVcXG4gIGZ1bmN0aW9uIHAoKSB7XFxuICAgIHZhciBjaGFuZ2VkID0gaW5wdXQucG9sbCgpXFxuICAgIGlmICghY2hhbmdlZCAmJiAhbWlzc2VkKSB7bWlzc2VkID0gdHJ1ZTsgaW5wdXQucG9sbGluZy5zZXQoNjAsIHApfVxcbiAgICBlbHNlIHtpbnB1dC5wb2xsaW5nRmFzdCA9IGZhbHNlOyBpbnB1dC5zbG93UG9sbCgpfVxcbiAgfVxcbiAgaW5wdXQucG9sbGluZy5zZXQoMjAsIHApXFxufTtcXG5cXG4vLyBSZWFkIGlucHV0IGZyb20gdGhlIHRleHRhcmVhLCBhbmQgdXBkYXRlIHRoZSBkb2N1bWVudCB0byBtYXRjaC5cXG4vLyBXaGVuIHNvbWV0aGluZyBpcyBzZWxlY3RlZCwgaXQgaXMgcHJlc2VudCBpbiB0aGUgdGV4dGFyZWEsIGFuZFxcbi8vIHNlbGVjdGVkICh1bmxlc3MgaXQgaXMgaHVnZSwgaW4gd2hpY2ggY2FzZSBhIHBsYWNlaG9sZGVyIGlzXFxuLy8gdXNlZCkuIFdoZW4gbm90aGluZyBpcyBzZWxlY3RlZCwgdGhlIGN1cnNvciBzaXRzIGFmdGVyIHByZXZpb3VzbHlcXG4vLyBzZWVuIHRleHQgKGNhbiBiZSBlbXB0eSksIHdoaWNoIGlzIHN0b3JlZCBpbiBwcmV2SW5wdXQgKHdlIG11c3RcXG4vLyBub3QgcmVzZXQgdGhlIHRleHRhcmVhIHdoZW4gdHlwaW5nLCBiZWNhdXNlIHRoYXQgYnJlYWtzIElNRSkuXFxuVGV4dGFyZWFJbnB1dC5wcm90b3R5cGUucG9sbCA9IGZ1bmN0aW9uICgpIHtcXG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XFxuXFxuICB2YXIgY20gPSB0aGlzLmNtLCBpbnB1dCA9IHRoaXMudGV4dGFyZWEsIHByZXZJbnB1dCA9IHRoaXMucHJldklucHV0XFxuICAvLyBTaW5jZSB0aGlzIGlzIGNhbGxlZCBhICpsb3QqLCB0cnkgdG8gYmFpbCBvdXQgYXMgY2hlYXBseSBhc1xcbiAgLy8gcG9zc2libGUgd2hlbiBpdCBpcyBjbGVhciB0aGF0IG5vdGhpbmcgaGFwcGVuZWQuIGhhc1NlbGVjdGlvblxcbiAgLy8gd2lsbCBiZSB0aGUgY2FzZSB3aGVuIHRoZXJlIGlzIGEgbG90IG9mIHRleHQgaW4gdGhlIHRleHRhcmVhLFxcbiAgLy8gaW4gd2hpY2ggY2FzZSByZWFkaW5nIGl0cyB2YWx1ZSB3b3VsZCBiZSBleHBlbnNpdmUuXFxuICBpZiAodGhpcy5jb250ZXh0TWVudVBlbmRpbmcgfHwgIWNtLnN0YXRlLmZvY3VzZWQgfHxcXG4gICAgICAoaGFzU2VsZWN0aW9uKGlucHV0KSAmJiAhcHJldklucHV0ICYmICF0aGlzLmNvbXBvc2luZykgfHxcXG4gICAgICBjbS5pc1JlYWRPbmx5KCkgfHwgY20ub3B0aW9ucy5kaXNhYmxlSW5wdXQgfHwgY20uc3RhdGUua2V5U2VxKVxcbiAgICB7IHJldHVybiBmYWxzZSB9XFxuXFxuICB2YXIgdGV4dCA9IGlucHV0LnZhbHVlXFxuICAvLyBJZiBub3RoaW5nIGNoYW5nZWQsIGJhaWwuXFxuICBpZiAodGV4dCA9PSBwcmV2SW5wdXQgJiYgIWNtLnNvbWV0aGluZ1NlbGVjdGVkKCkpIHsgcmV0dXJuIGZhbHNlIH1cXG4gIC8vIFdvcmsgYXJvdW5kIG5vbnNlbnNpY2FsIHNlbGVjdGlvbiByZXNldHRpbmcgaW4gSUU5LzEwLCBhbmRcXG4gIC8vIGluZXhwbGljYWJsZSBhcHBlYXJhbmNlIG9mIHByaXZhdGUgYXJlYSB1bmljb2RlIGNoYXJhY3RlcnMgb25cXG4gIC8vIHNvbWUga2V5IGNvbWJvcyBpbiBNYWMgKCMyNjg5KS5cXG4gIGlmIChpZSAmJiBpZV92ZXJzaW9uID49IDkgJiYgdGhpcy5oYXNTZWxlY3Rpb24gPT09IHRleHQgfHxcXG4gICAgICBtYWMgJiYgL1tcXFxcdWY3MDAtXFxcXHVmN2ZmXS8udGVzdCh0ZXh0KSkge1xcbiAgICBjbS5kaXNwbGF5LmlucHV0LnJlc2V0KClcXG4gICAgcmV0dXJuIGZhbHNlXFxuICB9XFxuXFxuICBpZiAoY20uZG9jLnNlbCA9PSBjbS5kaXNwbGF5LnNlbEZvckNvbnRleHRNZW51KSB7XFxuICAgIHZhciBmaXJzdCA9IHRleHQuY2hhckNvZGVBdCgwKVxcbiAgICBpZiAoZmlyc3QgPT0gMHgyMDBiICYmICFwcmV2SW5wdXQpIHsgcHJldklucHV0ID0gXFxcIlxcXFx1MjAwYlxcXCIgfVxcbiAgICBpZiAoZmlyc3QgPT0gMHgyMWRhKSB7IHRoaXMucmVzZXQoKTsgcmV0dXJuIHRoaXMuY20uZXhlY0NvbW1hbmQoXFxcInVuZG9cXFwiKSB9XFxuICB9XFxuICAvLyBGaW5kIHRoZSBwYXJ0IG9mIHRoZSBpbnB1dCB0aGF0IGlzIGFjdHVhbGx5IG5ld1xcbiAgdmFyIHNhbWUgPSAwLCBsID0gTWF0aC5taW4ocHJldklucHV0Lmxlbmd0aCwgdGV4dC5sZW5ndGgpXFxuICB3aGlsZSAoc2FtZSA8IGwgJiYgcHJldklucHV0LmNoYXJDb2RlQXQoc2FtZSkgPT0gdGV4dC5jaGFyQ29kZUF0KHNhbWUpKSB7ICsrc2FtZSB9XFxuXFxuICBydW5Jbk9wKGNtLCBmdW5jdGlvbiAoKSB7XFxuICAgIGFwcGx5VGV4dElucHV0KGNtLCB0ZXh0LnNsaWNlKHNhbWUpLCBwcmV2SW5wdXQubGVuZ3RoIC0gc2FtZSxcXG4gICAgICAgICAgICAgICAgICAgbnVsbCwgdGhpcyQxLmNvbXBvc2luZyA/IFxcXCIqY29tcG9zZVxcXCIgOiBudWxsKVxcblxcbiAgICAvLyBEb24ndCBsZWF2ZSBsb25nIHRleHQgaW4gdGhlIHRleHRhcmVhLCBzaW5jZSBpdCBtYWtlcyBmdXJ0aGVyIHBvbGxpbmcgc2xvd1xcbiAgICBpZiAodGV4dC5sZW5ndGggPiAxMDAwIHx8IHRleHQuaW5kZXhPZihcXFwiXFxcXG5cXFwiKSA+IC0xKSB7IGlucHV0LnZhbHVlID0gdGhpcyQxLnByZXZJbnB1dCA9IFxcXCJcXFwiIH1cXG4gICAgZWxzZSB7IHRoaXMkMS5wcmV2SW5wdXQgPSB0ZXh0IH1cXG5cXG4gICAgaWYgKHRoaXMkMS5jb21wb3NpbmcpIHtcXG4gICAgICB0aGlzJDEuY29tcG9zaW5nLnJhbmdlLmNsZWFyKClcXG4gICAgICB0aGlzJDEuY29tcG9zaW5nLnJhbmdlID0gY20ubWFya1RleHQodGhpcyQxLmNvbXBvc2luZy5zdGFydCwgY20uZ2V0Q3Vyc29yKFxcXCJ0b1xcXCIpLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge2NsYXNzTmFtZTogXFxcIkNvZGVNaXJyb3ItY29tcG9zaW5nXFxcIn0pXFxuICAgIH1cXG4gIH0pXFxuICByZXR1cm4gdHJ1ZVxcbn07XFxuXFxuVGV4dGFyZWFJbnB1dC5wcm90b3R5cGUuZW5zdXJlUG9sbGVkID0gZnVuY3Rpb24gKCkge1xcbiAgaWYgKHRoaXMucG9sbGluZ0Zhc3QgJiYgdGhpcy5wb2xsKCkpIHsgdGhpcy5wb2xsaW5nRmFzdCA9IGZhbHNlIH1cXG59O1xcblxcblRleHRhcmVhSW5wdXQucHJvdG90eXBlLm9uS2V5UHJlc3MgPSBmdW5jdGlvbiAoKSB7XFxuICBpZiAoaWUgJiYgaWVfdmVyc2lvbiA+PSA5KSB7IHRoaXMuaGFzU2VsZWN0aW9uID0gbnVsbCB9XFxuICB0aGlzLmZhc3RQb2xsKClcXG59O1xcblxcblRleHRhcmVhSW5wdXQucHJvdG90eXBlLm9uQ29udGV4dE1lbnUgPSBmdW5jdGlvbiAoZSkge1xcbiAgdmFyIGlucHV0ID0gdGhpcywgY20gPSBpbnB1dC5jbSwgZGlzcGxheSA9IGNtLmRpc3BsYXksIHRlID0gaW5wdXQudGV4dGFyZWFcXG4gIHZhciBwb3MgPSBwb3NGcm9tTW91c2UoY20sIGUpLCBzY3JvbGxQb3MgPSBkaXNwbGF5LnNjcm9sbGVyLnNjcm9sbFRvcFxcbiAgaWYgKCFwb3MgfHwgcHJlc3RvKSB7IHJldHVybiB9IC8vIE9wZXJhIGlzIGRpZmZpY3VsdC5cXG5cXG4gIC8vIFJlc2V0IHRoZSBjdXJyZW50IHRleHQgc2VsZWN0aW9uIG9ubHkgaWYgdGhlIGNsaWNrIGlzIGRvbmUgb3V0c2lkZSBvZiB0aGUgc2VsZWN0aW9uXFxuICAvLyBhbmQgJ3Jlc2V0U2VsZWN0aW9uT25Db250ZXh0TWVudScgb3B0aW9uIGlzIHRydWUuXFxuICB2YXIgcmVzZXQgPSBjbS5vcHRpb25zLnJlc2V0U2VsZWN0aW9uT25Db250ZXh0TWVudVxcbiAgaWYgKHJlc2V0ICYmIGNtLmRvYy5zZWwuY29udGFpbnMocG9zKSA9PSAtMSlcXG4gICAgeyBvcGVyYXRpb24oY20sIHNldFNlbGVjdGlvbikoY20uZG9jLCBzaW1wbGVTZWxlY3Rpb24ocG9zKSwgc2VsX2RvbnRTY3JvbGwpIH1cXG5cXG4gIHZhciBvbGRDU1MgPSB0ZS5zdHlsZS5jc3NUZXh0LCBvbGRXcmFwcGVyQ1NTID0gaW5wdXQud3JhcHBlci5zdHlsZS5jc3NUZXh0XFxuICBpbnB1dC53cmFwcGVyLnN0eWxlLmNzc1RleHQgPSBcXFwicG9zaXRpb246IGFic29sdXRlXFxcIlxcbiAgdmFyIHdyYXBwZXJCb3ggPSBpbnB1dC53cmFwcGVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXFxuICB0ZS5zdHlsZS5jc3NUZXh0ID0gXFxcInBvc2l0aW9uOiBhYnNvbHV0ZTsgd2lkdGg6IDMwcHg7IGhlaWdodDogMzBweDtcXFxcbiAgICAgIHRvcDogXFxcIiArIChlLmNsaWVudFkgLSB3cmFwcGVyQm94LnRvcCAtIDUpICsgXFxcInB4OyBsZWZ0OiBcXFwiICsgKGUuY2xpZW50WCAtIHdyYXBwZXJCb3gubGVmdCAtIDUpICsgXFxcInB4O1xcXFxuICAgICAgei1pbmRleDogMTAwMDsgYmFja2dyb3VuZDogXFxcIiArIChpZSA/IFxcXCJyZ2JhKDI1NSwgMjU1LCAyNTUsIC4wNSlcXFwiIDogXFxcInRyYW5zcGFyZW50XFxcIikgKyBcXFwiO1xcXFxuICAgICAgb3V0bGluZTogbm9uZTsgYm9yZGVyLXdpZHRoOiAwOyBvdXRsaW5lOiBub25lOyBvdmVyZmxvdzogaGlkZGVuOyBvcGFjaXR5OiAuMDU7IGZpbHRlcjogYWxwaGEob3BhY2l0eT01KTtcXFwiXFxuICB2YXIgb2xkU2Nyb2xsWVxcbiAgaWYgKHdlYmtpdCkgeyBvbGRTY3JvbGxZID0gd2luZG93LnNjcm9sbFkgfSAvLyBXb3JrIGFyb3VuZCBDaHJvbWUgaXNzdWUgKCMyNzEyKVxcbiAgZGlzcGxheS5pbnB1dC5mb2N1cygpXFxuICBpZiAod2Via2l0KSB7IHdpbmRvdy5zY3JvbGxUbyhudWxsLCBvbGRTY3JvbGxZKSB9XFxuICBkaXNwbGF5LmlucHV0LnJlc2V0KClcXG4gIC8vIEFkZHMgXFxcIlNlbGVjdCBhbGxcXFwiIHRvIGNvbnRleHQgbWVudSBpbiBGRlxcbiAgaWYgKCFjbS5zb21ldGhpbmdTZWxlY3RlZCgpKSB7IHRlLnZhbHVlID0gaW5wdXQucHJldklucHV0ID0gXFxcIiBcXFwiIH1cXG4gIGlucHV0LmNvbnRleHRNZW51UGVuZGluZyA9IHRydWVcXG4gIGRpc3BsYXkuc2VsRm9yQ29udGV4dE1lbnUgPSBjbS5kb2Muc2VsXFxuICBjbGVhclRpbWVvdXQoZGlzcGxheS5kZXRlY3RpbmdTZWxlY3RBbGwpXFxuXFxuICAvLyBTZWxlY3QtYWxsIHdpbGwgYmUgZ3JleWVkIG91dCBpZiB0aGVyZSdzIG5vdGhpbmcgdG8gc2VsZWN0LCBzb1xcbiAgLy8gdGhpcyBhZGRzIGEgemVyby13aWR0aCBzcGFjZSBzbyB0aGF0IHdlIGNhbiBsYXRlciBjaGVjayB3aGV0aGVyXFxuICAvLyBpdCBnb3Qgc2VsZWN0ZWQuXFxuICBmdW5jdGlvbiBwcmVwYXJlU2VsZWN0QWxsSGFjaygpIHtcXG4gICAgaWYgKHRlLnNlbGVjdGlvblN0YXJ0ICE9IG51bGwpIHtcXG4gICAgICB2YXIgc2VsZWN0ZWQgPSBjbS5zb21ldGhpbmdTZWxlY3RlZCgpXFxuICAgICAgdmFyIGV4dHZhbCA9IFxcXCJcXFxcdTIwMGJcXFwiICsgKHNlbGVjdGVkID8gdGUudmFsdWUgOiBcXFwiXFxcIilcXG4gICAgICB0ZS52YWx1ZSA9IFxcXCJcXFxcdTIxZGFcXFwiIC8vIFVzZWQgdG8gY2F0Y2ggY29udGV4dC1tZW51IHVuZG9cXG4gICAgICB0ZS52YWx1ZSA9IGV4dHZhbFxcbiAgICAgIGlucHV0LnByZXZJbnB1dCA9IHNlbGVjdGVkID8gXFxcIlxcXCIgOiBcXFwiXFxcXHUyMDBiXFxcIlxcbiAgICAgIHRlLnNlbGVjdGlvblN0YXJ0ID0gMTsgdGUuc2VsZWN0aW9uRW5kID0gZXh0dmFsLmxlbmd0aFxcbiAgICAgIC8vIFJlLXNldCB0aGlzLCBpbiBjYXNlIHNvbWUgb3RoZXIgaGFuZGxlciB0b3VjaGVkIHRoZVxcbiAgICAgIC8vIHNlbGVjdGlvbiBpbiB0aGUgbWVhbnRpbWUuXFxuICAgICAgZGlzcGxheS5zZWxGb3JDb250ZXh0TWVudSA9IGNtLmRvYy5zZWxcXG4gICAgfVxcbiAgfVxcbiAgZnVuY3Rpb24gcmVoaWRlKCkge1xcbiAgICBpbnB1dC5jb250ZXh0TWVudVBlbmRpbmcgPSBmYWxzZVxcbiAgICBpbnB1dC53cmFwcGVyLnN0eWxlLmNzc1RleHQgPSBvbGRXcmFwcGVyQ1NTXFxuICAgIHRlLnN0eWxlLmNzc1RleHQgPSBvbGRDU1NcXG4gICAgaWYgKGllICYmIGllX3ZlcnNpb24gPCA5KSB7IGRpc3BsYXkuc2Nyb2xsYmFycy5zZXRTY3JvbGxUb3AoZGlzcGxheS5zY3JvbGxlci5zY3JvbGxUb3AgPSBzY3JvbGxQb3MpIH1cXG5cXG4gICAgLy8gVHJ5IHRvIGRldGVjdCB0aGUgdXNlciBjaG9vc2luZyBzZWxlY3QtYWxsXFxuICAgIGlmICh0ZS5zZWxlY3Rpb25TdGFydCAhPSBudWxsKSB7XFxuICAgICAgaWYgKCFpZSB8fCAoaWUgJiYgaWVfdmVyc2lvbiA8IDkpKSB7IHByZXBhcmVTZWxlY3RBbGxIYWNrKCkgfVxcbiAgICAgIHZhciBpID0gMCwgcG9sbCA9IGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIGlmIChkaXNwbGF5LnNlbEZvckNvbnRleHRNZW51ID09IGNtLmRvYy5zZWwgJiYgdGUuc2VsZWN0aW9uU3RhcnQgPT0gMCAmJlxcbiAgICAgICAgICAgIHRlLnNlbGVjdGlvbkVuZCA+IDAgJiYgaW5wdXQucHJldklucHV0ID09IFxcXCJcXFxcdTIwMGJcXFwiKVxcbiAgICAgICAgICB7IG9wZXJhdGlvbihjbSwgc2VsZWN0QWxsKShjbSkgfVxcbiAgICAgICAgZWxzZSBpZiAoaSsrIDwgMTApIHsgZGlzcGxheS5kZXRlY3RpbmdTZWxlY3RBbGwgPSBzZXRUaW1lb3V0KHBvbGwsIDUwMCkgfVxcbiAgICAgICAgZWxzZSB7IGRpc3BsYXkuaW5wdXQucmVzZXQoKSB9XFxuICAgICAgfVxcbiAgICAgIGRpc3BsYXkuZGV0ZWN0aW5nU2VsZWN0QWxsID0gc2V0VGltZW91dChwb2xsLCAyMDApXFxuICAgIH1cXG4gIH1cXG5cXG4gIGlmIChpZSAmJiBpZV92ZXJzaW9uID49IDkpIHsgcHJlcGFyZVNlbGVjdEFsbEhhY2soKSB9XFxuICBpZiAoY2FwdHVyZVJpZ2h0Q2xpY2spIHtcXG4gICAgZV9zdG9wKGUpXFxuICAgIHZhciBtb3VzZXVwID0gZnVuY3Rpb24gKCkge1xcbiAgICAgIG9mZih3aW5kb3csIFxcXCJtb3VzZXVwXFxcIiwgbW91c2V1cClcXG4gICAgICBzZXRUaW1lb3V0KHJlaGlkZSwgMjApXFxuICAgIH1cXG4gICAgb24od2luZG93LCBcXFwibW91c2V1cFxcXCIsIG1vdXNldXApXFxuICB9IGVsc2Uge1xcbiAgICBzZXRUaW1lb3V0KHJlaGlkZSwgNTApXFxuICB9XFxufTtcXG5cXG5UZXh0YXJlYUlucHV0LnByb3RvdHlwZS5yZWFkT25seUNoYW5nZWQgPSBmdW5jdGlvbiAodmFsKSB7XFxuICBpZiAoIXZhbCkgeyB0aGlzLnJlc2V0KCkgfVxcbn07XFxuXFxuVGV4dGFyZWFJbnB1dC5wcm90b3R5cGUuc2V0VW5lZGl0YWJsZSA9IGZ1bmN0aW9uICgpIHt9O1xcblxcblRleHRhcmVhSW5wdXQucHJvdG90eXBlLm5lZWRzQ29udGVudEF0dHJpYnV0ZSA9IGZhbHNlXFxuXFxuZnVuY3Rpb24gZnJvbVRleHRBcmVhKHRleHRhcmVhLCBvcHRpb25zKSB7XFxuICBvcHRpb25zID0gb3B0aW9ucyA/IGNvcHlPYmoob3B0aW9ucykgOiB7fVxcbiAgb3B0aW9ucy52YWx1ZSA9IHRleHRhcmVhLnZhbHVlXFxuICBpZiAoIW9wdGlvbnMudGFiaW5kZXggJiYgdGV4dGFyZWEudGFiSW5kZXgpXFxuICAgIHsgb3B0aW9ucy50YWJpbmRleCA9IHRleHRhcmVhLnRhYkluZGV4IH1cXG4gIGlmICghb3B0aW9ucy5wbGFjZWhvbGRlciAmJiB0ZXh0YXJlYS5wbGFjZWhvbGRlcilcXG4gICAgeyBvcHRpb25zLnBsYWNlaG9sZGVyID0gdGV4dGFyZWEucGxhY2Vob2xkZXIgfVxcbiAgLy8gU2V0IGF1dG9mb2N1cyB0byB0cnVlIGlmIHRoaXMgdGV4dGFyZWEgaXMgZm9jdXNlZCwgb3IgaWYgaXQgaGFzXFxuICAvLyBhdXRvZm9jdXMgYW5kIG5vIG90aGVyIGVsZW1lbnQgaXMgZm9jdXNlZC5cXG4gIGlmIChvcHRpb25zLmF1dG9mb2N1cyA9PSBudWxsKSB7XFxuICAgIHZhciBoYXNGb2N1cyA9IGFjdGl2ZUVsdCgpXFxuICAgIG9wdGlvbnMuYXV0b2ZvY3VzID0gaGFzRm9jdXMgPT0gdGV4dGFyZWEgfHxcXG4gICAgICB0ZXh0YXJlYS5nZXRBdHRyaWJ1dGUoXFxcImF1dG9mb2N1c1xcXCIpICE9IG51bGwgJiYgaGFzRm9jdXMgPT0gZG9jdW1lbnQuYm9keVxcbiAgfVxcblxcbiAgZnVuY3Rpb24gc2F2ZSgpIHt0ZXh0YXJlYS52YWx1ZSA9IGNtLmdldFZhbHVlKCl9XFxuXFxuICB2YXIgcmVhbFN1Ym1pdFxcbiAgaWYgKHRleHRhcmVhLmZvcm0pIHtcXG4gICAgb24odGV4dGFyZWEuZm9ybSwgXFxcInN1Ym1pdFxcXCIsIHNhdmUpXFxuICAgIC8vIERlcGxvcmFibGUgaGFjayB0byBtYWtlIHRoZSBzdWJtaXQgbWV0aG9kIGRvIHRoZSByaWdodCB0aGluZy5cXG4gICAgaWYgKCFvcHRpb25zLmxlYXZlU3VibWl0TWV0aG9kQWxvbmUpIHtcXG4gICAgICB2YXIgZm9ybSA9IHRleHRhcmVhLmZvcm1cXG4gICAgICByZWFsU3VibWl0ID0gZm9ybS5zdWJtaXRcXG4gICAgICB0cnkge1xcbiAgICAgICAgdmFyIHdyYXBwZWRTdWJtaXQgPSBmb3JtLnN1Ym1pdCA9IGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgc2F2ZSgpXFxuICAgICAgICAgIGZvcm0uc3VibWl0ID0gcmVhbFN1Ym1pdFxcbiAgICAgICAgICBmb3JtLnN1Ym1pdCgpXFxuICAgICAgICAgIGZvcm0uc3VibWl0ID0gd3JhcHBlZFN1Ym1pdFxcbiAgICAgICAgfVxcbiAgICAgIH0gY2F0Y2goZSkge31cXG4gICAgfVxcbiAgfVxcblxcbiAgb3B0aW9ucy5maW5pc2hJbml0ID0gZnVuY3Rpb24gKGNtKSB7XFxuICAgIGNtLnNhdmUgPSBzYXZlXFxuICAgIGNtLmdldFRleHRBcmVhID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGV4dGFyZWE7IH1cXG4gICAgY20udG9UZXh0QXJlYSA9IGZ1bmN0aW9uICgpIHtcXG4gICAgICBjbS50b1RleHRBcmVhID0gaXNOYU4gLy8gUHJldmVudCB0aGlzIGZyb20gYmVpbmcgcmFuIHR3aWNlXFxuICAgICAgc2F2ZSgpXFxuICAgICAgdGV4dGFyZWEucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChjbS5nZXRXcmFwcGVyRWxlbWVudCgpKVxcbiAgICAgIHRleHRhcmVhLnN0eWxlLmRpc3BsYXkgPSBcXFwiXFxcIlxcbiAgICAgIGlmICh0ZXh0YXJlYS5mb3JtKSB7XFxuICAgICAgICBvZmYodGV4dGFyZWEuZm9ybSwgXFxcInN1Ym1pdFxcXCIsIHNhdmUpXFxuICAgICAgICBpZiAodHlwZW9mIHRleHRhcmVhLmZvcm0uc3VibWl0ID09IFxcXCJmdW5jdGlvblxcXCIpXFxuICAgICAgICAgIHsgdGV4dGFyZWEuZm9ybS5zdWJtaXQgPSByZWFsU3VibWl0IH1cXG4gICAgICB9XFxuICAgIH1cXG4gIH1cXG5cXG4gIHRleHRhcmVhLnN0eWxlLmRpc3BsYXkgPSBcXFwibm9uZVxcXCJcXG4gIHZhciBjbSA9IENvZGVNaXJyb3IoZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIHRleHRhcmVhLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKG5vZGUsIHRleHRhcmVhLm5leHRTaWJsaW5nKTsgfSxcXG4gICAgb3B0aW9ucylcXG4gIHJldHVybiBjbVxcbn1cXG5cXG5mdW5jdGlvbiBhZGRMZWdhY3lQcm9wcyhDb2RlTWlycm9yKSB7XFxuICBDb2RlTWlycm9yLm9mZiA9IG9mZlxcbiAgQ29kZU1pcnJvci5vbiA9IG9uXFxuICBDb2RlTWlycm9yLndoZWVsRXZlbnRQaXhlbHMgPSB3aGVlbEV2ZW50UGl4ZWxzXFxuICBDb2RlTWlycm9yLkRvYyA9IERvY1xcbiAgQ29kZU1pcnJvci5zcGxpdExpbmVzID0gc3BsaXRMaW5lc0F1dG9cXG4gIENvZGVNaXJyb3IuY291bnRDb2x1bW4gPSBjb3VudENvbHVtblxcbiAgQ29kZU1pcnJvci5maW5kQ29sdW1uID0gZmluZENvbHVtblxcbiAgQ29kZU1pcnJvci5pc1dvcmRDaGFyID0gaXNXb3JkQ2hhckJhc2ljXFxuICBDb2RlTWlycm9yLlBhc3MgPSBQYXNzXFxuICBDb2RlTWlycm9yLnNpZ25hbCA9IHNpZ25hbFxcbiAgQ29kZU1pcnJvci5MaW5lID0gTGluZVxcbiAgQ29kZU1pcnJvci5jaGFuZ2VFbmQgPSBjaGFuZ2VFbmRcXG4gIENvZGVNaXJyb3Iuc2Nyb2xsYmFyTW9kZWwgPSBzY3JvbGxiYXJNb2RlbFxcbiAgQ29kZU1pcnJvci5Qb3MgPSBQb3NcXG4gIENvZGVNaXJyb3IuY21wUG9zID0gY21wXFxuICBDb2RlTWlycm9yLm1vZGVzID0gbW9kZXNcXG4gIENvZGVNaXJyb3IubWltZU1vZGVzID0gbWltZU1vZGVzXFxuICBDb2RlTWlycm9yLnJlc29sdmVNb2RlID0gcmVzb2x2ZU1vZGVcXG4gIENvZGVNaXJyb3IuZ2V0TW9kZSA9IGdldE1vZGVcXG4gIENvZGVNaXJyb3IubW9kZUV4dGVuc2lvbnMgPSBtb2RlRXh0ZW5zaW9uc1xcbiAgQ29kZU1pcnJvci5leHRlbmRNb2RlID0gZXh0ZW5kTW9kZVxcbiAgQ29kZU1pcnJvci5jb3B5U3RhdGUgPSBjb3B5U3RhdGVcXG4gIENvZGVNaXJyb3Iuc3RhcnRTdGF0ZSA9IHN0YXJ0U3RhdGVcXG4gIENvZGVNaXJyb3IuaW5uZXJNb2RlID0gaW5uZXJNb2RlXFxuICBDb2RlTWlycm9yLmNvbW1hbmRzID0gY29tbWFuZHNcXG4gIENvZGVNaXJyb3Iua2V5TWFwID0ga2V5TWFwXFxuICBDb2RlTWlycm9yLmtleU5hbWUgPSBrZXlOYW1lXFxuICBDb2RlTWlycm9yLmlzTW9kaWZpZXJLZXkgPSBpc01vZGlmaWVyS2V5XFxuICBDb2RlTWlycm9yLmxvb2t1cEtleSA9IGxvb2t1cEtleVxcbiAgQ29kZU1pcnJvci5ub3JtYWxpemVLZXlNYXAgPSBub3JtYWxpemVLZXlNYXBcXG4gIENvZGVNaXJyb3IuU3RyaW5nU3RyZWFtID0gU3RyaW5nU3RyZWFtXFxuICBDb2RlTWlycm9yLlNoYXJlZFRleHRNYXJrZXIgPSBTaGFyZWRUZXh0TWFya2VyXFxuICBDb2RlTWlycm9yLlRleHRNYXJrZXIgPSBUZXh0TWFya2VyXFxuICBDb2RlTWlycm9yLkxpbmVXaWRnZXQgPSBMaW5lV2lkZ2V0XFxuICBDb2RlTWlycm9yLmVfcHJldmVudERlZmF1bHQgPSBlX3ByZXZlbnREZWZhdWx0XFxuICBDb2RlTWlycm9yLmVfc3RvcFByb3BhZ2F0aW9uID0gZV9zdG9wUHJvcGFnYXRpb25cXG4gIENvZGVNaXJyb3IuZV9zdG9wID0gZV9zdG9wXFxuICBDb2RlTWlycm9yLmFkZENsYXNzID0gYWRkQ2xhc3NcXG4gIENvZGVNaXJyb3IuY29udGFpbnMgPSBjb250YWluc1xcbiAgQ29kZU1pcnJvci5ybUNsYXNzID0gcm1DbGFzc1xcbiAgQ29kZU1pcnJvci5rZXlOYW1lcyA9IGtleU5hbWVzXFxufVxcblxcbi8vIEVESVRPUiBDT05TVFJVQ1RPUlxcblxcbmRlZmluZU9wdGlvbnMoQ29kZU1pcnJvcilcXG5cXG5hZGRFZGl0b3JNZXRob2RzKENvZGVNaXJyb3IpXFxuXFxuLy8gU2V0IHVwIG1ldGhvZHMgb24gQ29kZU1pcnJvcidzIHByb3RvdHlwZSB0byByZWRpcmVjdCB0byB0aGUgZWRpdG9yJ3MgZG9jdW1lbnQuXFxudmFyIGRvbnREZWxlZ2F0ZSA9IFxcXCJpdGVyIGluc2VydCByZW1vdmUgY29weSBnZXRFZGl0b3IgY29uc3RydWN0b3JcXFwiLnNwbGl0KFxcXCIgXFxcIilcXG5mb3IgKHZhciBwcm9wIGluIERvYy5wcm90b3R5cGUpIHsgaWYgKERvYy5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkocHJvcCkgJiYgaW5kZXhPZihkb250RGVsZWdhdGUsIHByb3ApIDwgMClcXG4gIHsgQ29kZU1pcnJvci5wcm90b3R5cGVbcHJvcF0gPSAoZnVuY3Rpb24obWV0aG9kKSB7XFxuICAgIHJldHVybiBmdW5jdGlvbigpIHtyZXR1cm4gbWV0aG9kLmFwcGx5KHRoaXMuZG9jLCBhcmd1bWVudHMpfVxcbiAgfSkoRG9jLnByb3RvdHlwZVtwcm9wXSkgfSB9XFxuXFxuZXZlbnRNaXhpbihEb2MpXFxuXFxuLy8gSU5QVVQgSEFORExJTkdcXG5cXG5Db2RlTWlycm9yLmlucHV0U3R5bGVzID0ge1xcXCJ0ZXh0YXJlYVxcXCI6IFRleHRhcmVhSW5wdXQsIFxcXCJjb250ZW50ZWRpdGFibGVcXFwiOiBDb250ZW50RWRpdGFibGVJbnB1dH1cXG5cXG4vLyBNT0RFIERFRklOSVRJT04gQU5EIFFVRVJZSU5HXFxuXFxuLy8gRXh0cmEgYXJndW1lbnRzIGFyZSBzdG9yZWQgYXMgdGhlIG1vZGUncyBkZXBlbmRlbmNpZXMsIHdoaWNoIGlzXFxuLy8gdXNlZCBieSAobGVnYWN5KSBtZWNoYW5pc21zIGxpa2UgbG9hZG1vZGUuanMgdG8gYXV0b21hdGljYWxseVxcbi8vIGxvYWQgYSBtb2RlLiAoUHJlZmVycmVkIG1lY2hhbmlzbSBpcyB0aGUgcmVxdWlyZS9kZWZpbmUgY2FsbHMuKVxcbkNvZGVNaXJyb3IuZGVmaW5lTW9kZSA9IGZ1bmN0aW9uKG5hbWUvKiwgbW9kZSwg4oCmKi8pIHtcXG4gIGlmICghQ29kZU1pcnJvci5kZWZhdWx0cy5tb2RlICYmIG5hbWUgIT0gXFxcIm51bGxcXFwiKSB7IENvZGVNaXJyb3IuZGVmYXVsdHMubW9kZSA9IG5hbWUgfVxcbiAgZGVmaW5lTW9kZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpXFxufVxcblxcbkNvZGVNaXJyb3IuZGVmaW5lTUlNRSA9IGRlZmluZU1JTUVcXG5cXG4vLyBNaW5pbWFsIGRlZmF1bHQgbW9kZS5cXG5Db2RlTWlycm9yLmRlZmluZU1vZGUoXFxcIm51bGxcXFwiLCBmdW5jdGlvbiAoKSB7IHJldHVybiAoe3Rva2VuOiBmdW5jdGlvbiAoc3RyZWFtKSB7IHJldHVybiBzdHJlYW0uc2tpcFRvRW5kKCk7IH19KTsgfSlcXG5Db2RlTWlycm9yLmRlZmluZU1JTUUoXFxcInRleHQvcGxhaW5cXFwiLCBcXFwibnVsbFxcXCIpXFxuXFxuLy8gRVhURU5TSU9OU1xcblxcbkNvZGVNaXJyb3IuZGVmaW5lRXh0ZW5zaW9uID0gZnVuY3Rpb24gKG5hbWUsIGZ1bmMpIHtcXG4gIENvZGVNaXJyb3IucHJvdG90eXBlW25hbWVdID0gZnVuY1xcbn1cXG5Db2RlTWlycm9yLmRlZmluZURvY0V4dGVuc2lvbiA9IGZ1bmN0aW9uIChuYW1lLCBmdW5jKSB7XFxuICBEb2MucHJvdG90eXBlW25hbWVdID0gZnVuY1xcbn1cXG5cXG5Db2RlTWlycm9yLmZyb21UZXh0QXJlYSA9IGZyb21UZXh0QXJlYVxcblxcbmFkZExlZ2FjeVByb3BzKENvZGVNaXJyb3IpXFxuXFxuQ29kZU1pcnJvci52ZXJzaW9uID0gXFxcIjUuMjMuMFxcXCJcXG5cXG5yZXR1cm4gQ29kZU1pcnJvcjtcXG5cXG59KSkpO1wiXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3Jhdy1sb2FkZXIhLi9+L2NvZGVtaXJyb3IvbGliL2NvZGVtaXJyb3IuanNcbi8vIG1vZHVsZSBpZCA9IDVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQSIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	eval("__webpack_require__(2)(__webpack_require__(7))//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL34vY29kZW1pcnJvci9tb2RlL3htbC94bWwuanM/ODBhNyJdLCJzb3VyY2VzQ29udGVudCI6WyJyZXF1aXJlKFwiISEvdmFyL2FwcC93ZWIvanMvbm9kZV9tb2R1bGVzL3NjcmlwdC1sb2FkZXIvYWRkU2NyaXB0LmpzXCIpKHJlcXVpcmUoXCIhIS92YXIvYXBwL3dlYi9qcy9ub2RlX21vZHVsZXMvcmF3LWxvYWRlci9pbmRleC5qcyEvdmFyL2FwcC93ZWIvanMvbm9kZV9tb2R1bGVzL2NvZGVtaXJyb3IvbW9kZS94bWwveG1sLmpzXCIpKVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9zY3JpcHQtbG9hZGVyIS4vfi9jb2RlbWlycm9yL21vZGUveG1sL3htbC5qc1xuLy8gbW9kdWxlIGlkID0gNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 7 */
/***/ function(module, exports) {

	eval("module.exports = \"// CodeMirror, copyright (c) by Marijn Haverbeke and others\\n// Distributed under an MIT license: http://codemirror.net/LICENSE\\n\\n(function(mod) {\\n  if (typeof exports == \\\"object\\\" && typeof module == \\\"object\\\") // CommonJS\\n    mod(require(\\\"../../lib/codemirror\\\"));\\n  else if (typeof define == \\\"function\\\" && define.amd) // AMD\\n    define([\\\"../../lib/codemirror\\\"], mod);\\n  else // Plain browser env\\n    mod(CodeMirror);\\n})(function(CodeMirror) {\\n\\\"use strict\\\";\\n\\nvar htmlConfig = {\\n  autoSelfClosers: {'area': true, 'base': true, 'br': true, 'col': true, 'command': true,\\n                    'embed': true, 'frame': true, 'hr': true, 'img': true, 'input': true,\\n                    'keygen': true, 'link': true, 'meta': true, 'param': true, 'source': true,\\n                    'track': true, 'wbr': true, 'menuitem': true},\\n  implicitlyClosed: {'dd': true, 'li': true, 'optgroup': true, 'option': true, 'p': true,\\n                     'rp': true, 'rt': true, 'tbody': true, 'td': true, 'tfoot': true,\\n                     'th': true, 'tr': true},\\n  contextGrabbers: {\\n    'dd': {'dd': true, 'dt': true},\\n    'dt': {'dd': true, 'dt': true},\\n    'li': {'li': true},\\n    'option': {'option': true, 'optgroup': true},\\n    'optgroup': {'optgroup': true},\\n    'p': {'address': true, 'article': true, 'aside': true, 'blockquote': true, 'dir': true,\\n          'div': true, 'dl': true, 'fieldset': true, 'footer': true, 'form': true,\\n          'h1': true, 'h2': true, 'h3': true, 'h4': true, 'h5': true, 'h6': true,\\n          'header': true, 'hgroup': true, 'hr': true, 'menu': true, 'nav': true, 'ol': true,\\n          'p': true, 'pre': true, 'section': true, 'table': true, 'ul': true},\\n    'rp': {'rp': true, 'rt': true},\\n    'rt': {'rp': true, 'rt': true},\\n    'tbody': {'tbody': true, 'tfoot': true},\\n    'td': {'td': true, 'th': true},\\n    'tfoot': {'tbody': true},\\n    'th': {'td': true, 'th': true},\\n    'thead': {'tbody': true, 'tfoot': true},\\n    'tr': {'tr': true}\\n  },\\n  doNotIndent: {\\\"pre\\\": true},\\n  allowUnquoted: true,\\n  allowMissing: true,\\n  caseFold: true\\n}\\n\\nvar xmlConfig = {\\n  autoSelfClosers: {},\\n  implicitlyClosed: {},\\n  contextGrabbers: {},\\n  doNotIndent: {},\\n  allowUnquoted: false,\\n  allowMissing: false,\\n  caseFold: false\\n}\\n\\nCodeMirror.defineMode(\\\"xml\\\", function(editorConf, config_) {\\n  var indentUnit = editorConf.indentUnit\\n  var config = {}\\n  var defaults = config_.htmlMode ? htmlConfig : xmlConfig\\n  for (var prop in defaults) config[prop] = defaults[prop]\\n  for (var prop in config_) config[prop] = config_[prop]\\n\\n  // Return variables for tokenizers\\n  var type, setStyle;\\n\\n  function inText(stream, state) {\\n    function chain(parser) {\\n      state.tokenize = parser;\\n      return parser(stream, state);\\n    }\\n\\n    var ch = stream.next();\\n    if (ch == \\\"<\\\") {\\n      if (stream.eat(\\\"!\\\")) {\\n        if (stream.eat(\\\"[\\\")) {\\n          if (stream.match(\\\"CDATA[\\\")) return chain(inBlock(\\\"atom\\\", \\\"]]>\\\"));\\n          else return null;\\n        } else if (stream.match(\\\"--\\\")) {\\n          return chain(inBlock(\\\"comment\\\", \\\"-->\\\"));\\n        } else if (stream.match(\\\"DOCTYPE\\\", true, true)) {\\n          stream.eatWhile(/[\\\\w\\\\._\\\\-]/);\\n          return chain(doctype(1));\\n        } else {\\n          return null;\\n        }\\n      } else if (stream.eat(\\\"?\\\")) {\\n        stream.eatWhile(/[\\\\w\\\\._\\\\-]/);\\n        state.tokenize = inBlock(\\\"meta\\\", \\\"?>\\\");\\n        return \\\"meta\\\";\\n      } else {\\n        type = stream.eat(\\\"/\\\") ? \\\"closeTag\\\" : \\\"openTag\\\";\\n        state.tokenize = inTag;\\n        return \\\"tag bracket\\\";\\n      }\\n    } else if (ch == \\\"&\\\") {\\n      var ok;\\n      if (stream.eat(\\\"#\\\")) {\\n        if (stream.eat(\\\"x\\\")) {\\n          ok = stream.eatWhile(/[a-fA-F\\\\d]/) && stream.eat(\\\";\\\");\\n        } else {\\n          ok = stream.eatWhile(/[\\\\d]/) && stream.eat(\\\";\\\");\\n        }\\n      } else {\\n        ok = stream.eatWhile(/[\\\\w\\\\.\\\\-:]/) && stream.eat(\\\";\\\");\\n      }\\n      return ok ? \\\"atom\\\" : \\\"error\\\";\\n    } else {\\n      stream.eatWhile(/[^&<]/);\\n      return null;\\n    }\\n  }\\n  inText.isInText = true;\\n\\n  function inTag(stream, state) {\\n    var ch = stream.next();\\n    if (ch == \\\">\\\" || (ch == \\\"/\\\" && stream.eat(\\\">\\\"))) {\\n      state.tokenize = inText;\\n      type = ch == \\\">\\\" ? \\\"endTag\\\" : \\\"selfcloseTag\\\";\\n      return \\\"tag bracket\\\";\\n    } else if (ch == \\\"=\\\") {\\n      type = \\\"equals\\\";\\n      return null;\\n    } else if (ch == \\\"<\\\") {\\n      state.tokenize = inText;\\n      state.state = baseState;\\n      state.tagName = state.tagStart = null;\\n      var next = state.tokenize(stream, state);\\n      return next ? next + \\\" tag error\\\" : \\\"tag error\\\";\\n    } else if (/[\\\\'\\\\\\\"]/.test(ch)) {\\n      state.tokenize = inAttribute(ch);\\n      state.stringStartCol = stream.column();\\n      return state.tokenize(stream, state);\\n    } else {\\n      stream.match(/^[^\\\\s\\\\u00a0=<>\\\\\\\"\\\\']*[^\\\\s\\\\u00a0=<>\\\\\\\"\\\\'\\\\/]/);\\n      return \\\"word\\\";\\n    }\\n  }\\n\\n  function inAttribute(quote) {\\n    var closure = function(stream, state) {\\n      while (!stream.eol()) {\\n        if (stream.next() == quote) {\\n          state.tokenize = inTag;\\n          break;\\n        }\\n      }\\n      return \\\"string\\\";\\n    };\\n    closure.isInAttribute = true;\\n    return closure;\\n  }\\n\\n  function inBlock(style, terminator) {\\n    return function(stream, state) {\\n      while (!stream.eol()) {\\n        if (stream.match(terminator)) {\\n          state.tokenize = inText;\\n          break;\\n        }\\n        stream.next();\\n      }\\n      return style;\\n    };\\n  }\\n  function doctype(depth) {\\n    return function(stream, state) {\\n      var ch;\\n      while ((ch = stream.next()) != null) {\\n        if (ch == \\\"<\\\") {\\n          state.tokenize = doctype(depth + 1);\\n          return state.tokenize(stream, state);\\n        } else if (ch == \\\">\\\") {\\n          if (depth == 1) {\\n            state.tokenize = inText;\\n            break;\\n          } else {\\n            state.tokenize = doctype(depth - 1);\\n            return state.tokenize(stream, state);\\n          }\\n        }\\n      }\\n      return \\\"meta\\\";\\n    };\\n  }\\n\\n  function Context(state, tagName, startOfLine) {\\n    this.prev = state.context;\\n    this.tagName = tagName;\\n    this.indent = state.indented;\\n    this.startOfLine = startOfLine;\\n    if (config.doNotIndent.hasOwnProperty(tagName) || (state.context && state.context.noIndent))\\n      this.noIndent = true;\\n  }\\n  function popContext(state) {\\n    if (state.context) state.context = state.context.prev;\\n  }\\n  function maybePopContext(state, nextTagName) {\\n    var parentTagName;\\n    while (true) {\\n      if (!state.context) {\\n        return;\\n      }\\n      parentTagName = state.context.tagName;\\n      if (!config.contextGrabbers.hasOwnProperty(parentTagName) ||\\n          !config.contextGrabbers[parentTagName].hasOwnProperty(nextTagName)) {\\n        return;\\n      }\\n      popContext(state);\\n    }\\n  }\\n\\n  function baseState(type, stream, state) {\\n    if (type == \\\"openTag\\\") {\\n      state.tagStart = stream.column();\\n      return tagNameState;\\n    } else if (type == \\\"closeTag\\\") {\\n      return closeTagNameState;\\n    } else {\\n      return baseState;\\n    }\\n  }\\n  function tagNameState(type, stream, state) {\\n    if (type == \\\"word\\\") {\\n      state.tagName = stream.current();\\n      setStyle = \\\"tag\\\";\\n      return attrState;\\n    } else {\\n      setStyle = \\\"error\\\";\\n      return tagNameState;\\n    }\\n  }\\n  function closeTagNameState(type, stream, state) {\\n    if (type == \\\"word\\\") {\\n      var tagName = stream.current();\\n      if (state.context && state.context.tagName != tagName &&\\n          config.implicitlyClosed.hasOwnProperty(state.context.tagName))\\n        popContext(state);\\n      if ((state.context && state.context.tagName == tagName) || config.matchClosing === false) {\\n        setStyle = \\\"tag\\\";\\n        return closeState;\\n      } else {\\n        setStyle = \\\"tag error\\\";\\n        return closeStateErr;\\n      }\\n    } else {\\n      setStyle = \\\"error\\\";\\n      return closeStateErr;\\n    }\\n  }\\n\\n  function closeState(type, _stream, state) {\\n    if (type != \\\"endTag\\\") {\\n      setStyle = \\\"error\\\";\\n      return closeState;\\n    }\\n    popContext(state);\\n    return baseState;\\n  }\\n  function closeStateErr(type, stream, state) {\\n    setStyle = \\\"error\\\";\\n    return closeState(type, stream, state);\\n  }\\n\\n  function attrState(type, _stream, state) {\\n    if (type == \\\"word\\\") {\\n      setStyle = \\\"attribute\\\";\\n      return attrEqState;\\n    } else if (type == \\\"endTag\\\" || type == \\\"selfcloseTag\\\") {\\n      var tagName = state.tagName, tagStart = state.tagStart;\\n      state.tagName = state.tagStart = null;\\n      if (type == \\\"selfcloseTag\\\" ||\\n          config.autoSelfClosers.hasOwnProperty(tagName)) {\\n        maybePopContext(state, tagName);\\n      } else {\\n        maybePopContext(state, tagName);\\n        state.context = new Context(state, tagName, tagStart == state.indented);\\n      }\\n      return baseState;\\n    }\\n    setStyle = \\\"error\\\";\\n    return attrState;\\n  }\\n  function attrEqState(type, stream, state) {\\n    if (type == \\\"equals\\\") return attrValueState;\\n    if (!config.allowMissing) setStyle = \\\"error\\\";\\n    return attrState(type, stream, state);\\n  }\\n  function attrValueState(type, stream, state) {\\n    if (type == \\\"string\\\") return attrContinuedState;\\n    if (type == \\\"word\\\" && config.allowUnquoted) {setStyle = \\\"string\\\"; return attrState;}\\n    setStyle = \\\"error\\\";\\n    return attrState(type, stream, state);\\n  }\\n  function attrContinuedState(type, stream, state) {\\n    if (type == \\\"string\\\") return attrContinuedState;\\n    return attrState(type, stream, state);\\n  }\\n\\n  return {\\n    startState: function(baseIndent) {\\n      var state = {tokenize: inText,\\n                   state: baseState,\\n                   indented: baseIndent || 0,\\n                   tagName: null, tagStart: null,\\n                   context: null}\\n      if (baseIndent != null) state.baseIndent = baseIndent\\n      return state\\n    },\\n\\n    token: function(stream, state) {\\n      if (!state.tagName && stream.sol())\\n        state.indented = stream.indentation();\\n\\n      if (stream.eatSpace()) return null;\\n      type = null;\\n      var style = state.tokenize(stream, state);\\n      if ((style || type) && style != \\\"comment\\\") {\\n        setStyle = null;\\n        state.state = state.state(type || style, stream, state);\\n        if (setStyle)\\n          style = setStyle == \\\"error\\\" ? style + \\\" error\\\" : setStyle;\\n      }\\n      return style;\\n    },\\n\\n    indent: function(state, textAfter, fullLine) {\\n      var context = state.context;\\n      // Indent multi-line strings (e.g. css).\\n      if (state.tokenize.isInAttribute) {\\n        if (state.tagStart == state.indented)\\n          return state.stringStartCol + 1;\\n        else\\n          return state.indented + indentUnit;\\n      }\\n      if (context && context.noIndent) return CodeMirror.Pass;\\n      if (state.tokenize != inTag && state.tokenize != inText)\\n        return fullLine ? fullLine.match(/^(\\\\s*)/)[0].length : 0;\\n      // Indent the starts of attribute names.\\n      if (state.tagName) {\\n        if (config.multilineTagIndentPastTag !== false)\\n          return state.tagStart + state.tagName.length + 2;\\n        else\\n          return state.tagStart + indentUnit * (config.multilineTagIndentFactor || 1);\\n      }\\n      if (config.alignCDATA && /<!\\\\[CDATA\\\\[/.test(textAfter)) return 0;\\n      var tagAfter = textAfter && /^<(\\\\/)?([\\\\w_:\\\\.-]*)/.exec(textAfter);\\n      if (tagAfter && tagAfter[1]) { // Closing tag spotted\\n        while (context) {\\n          if (context.tagName == tagAfter[2]) {\\n            context = context.prev;\\n            break;\\n          } else if (config.implicitlyClosed.hasOwnProperty(context.tagName)) {\\n            context = context.prev;\\n          } else {\\n            break;\\n          }\\n        }\\n      } else if (tagAfter) { // Opening tag spotted\\n        while (context) {\\n          var grabbers = config.contextGrabbers[context.tagName];\\n          if (grabbers && grabbers.hasOwnProperty(tagAfter[2]))\\n            context = context.prev;\\n          else\\n            break;\\n        }\\n      }\\n      while (context && context.prev && !context.startOfLine)\\n        context = context.prev;\\n      if (context) return context.indent + indentUnit;\\n      else return state.baseIndent || 0;\\n    },\\n\\n    electricInput: /<\\\\/[\\\\s\\\\w:]+>$/,\\n    blockCommentStart: \\\"<!--\\\",\\n    blockCommentEnd: \\\"-->\\\",\\n\\n    configuration: config.htmlMode ? \\\"html\\\" : \\\"xml\\\",\\n    helperType: config.htmlMode ? \\\"html\\\" : \\\"xml\\\",\\n\\n    skipAttribute: function(state) {\\n      if (state.state == attrValueState)\\n        state.state = attrState\\n    }\\n  };\\n});\\n\\nCodeMirror.defineMIME(\\\"text/xml\\\", \\\"xml\\\");\\nCodeMirror.defineMIME(\\\"application/xml\\\", \\\"xml\\\");\\nif (!CodeMirror.mimeModes.hasOwnProperty(\\\"text/html\\\"))\\n  CodeMirror.defineMIME(\\\"text/html\\\", {name: \\\"xml\\\", htmlMode: true});\\n\\n});\\n\"//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL34vY29kZW1pcnJvci9tb2RlL3htbC94bWwuanM/Y2MzNSJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IFwiLy8gQ29kZU1pcnJvciwgY29weXJpZ2h0IChjKSBieSBNYXJpam4gSGF2ZXJiZWtlIGFuZCBvdGhlcnNcXG4vLyBEaXN0cmlidXRlZCB1bmRlciBhbiBNSVQgbGljZW5zZTogaHR0cDovL2NvZGVtaXJyb3IubmV0L0xJQ0VOU0VcXG5cXG4oZnVuY3Rpb24obW9kKSB7XFxuICBpZiAodHlwZW9mIGV4cG9ydHMgPT0gXFxcIm9iamVjdFxcXCIgJiYgdHlwZW9mIG1vZHVsZSA9PSBcXFwib2JqZWN0XFxcIikgLy8gQ29tbW9uSlNcXG4gICAgbW9kKHJlcXVpcmUoXFxcIi4uLy4uL2xpYi9jb2RlbWlycm9yXFxcIikpO1xcbiAgZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PSBcXFwiZnVuY3Rpb25cXFwiICYmIGRlZmluZS5hbWQpIC8vIEFNRFxcbiAgICBkZWZpbmUoW1xcXCIuLi8uLi9saWIvY29kZW1pcnJvclxcXCJdLCBtb2QpO1xcbiAgZWxzZSAvLyBQbGFpbiBicm93c2VyIGVudlxcbiAgICBtb2QoQ29kZU1pcnJvcik7XFxufSkoZnVuY3Rpb24oQ29kZU1pcnJvcikge1xcblxcXCJ1c2Ugc3RyaWN0XFxcIjtcXG5cXG52YXIgaHRtbENvbmZpZyA9IHtcXG4gIGF1dG9TZWxmQ2xvc2VyczogeydhcmVhJzogdHJ1ZSwgJ2Jhc2UnOiB0cnVlLCAnYnInOiB0cnVlLCAnY29sJzogdHJ1ZSwgJ2NvbW1hbmQnOiB0cnVlLFxcbiAgICAgICAgICAgICAgICAgICAgJ2VtYmVkJzogdHJ1ZSwgJ2ZyYW1lJzogdHJ1ZSwgJ2hyJzogdHJ1ZSwgJ2ltZyc6IHRydWUsICdpbnB1dCc6IHRydWUsXFxuICAgICAgICAgICAgICAgICAgICAna2V5Z2VuJzogdHJ1ZSwgJ2xpbmsnOiB0cnVlLCAnbWV0YSc6IHRydWUsICdwYXJhbSc6IHRydWUsICdzb3VyY2UnOiB0cnVlLFxcbiAgICAgICAgICAgICAgICAgICAgJ3RyYWNrJzogdHJ1ZSwgJ3dicic6IHRydWUsICdtZW51aXRlbSc6IHRydWV9LFxcbiAgaW1wbGljaXRseUNsb3NlZDogeydkZCc6IHRydWUsICdsaSc6IHRydWUsICdvcHRncm91cCc6IHRydWUsICdvcHRpb24nOiB0cnVlLCAncCc6IHRydWUsXFxuICAgICAgICAgICAgICAgICAgICAgJ3JwJzogdHJ1ZSwgJ3J0JzogdHJ1ZSwgJ3Rib2R5JzogdHJ1ZSwgJ3RkJzogdHJ1ZSwgJ3Rmb290JzogdHJ1ZSxcXG4gICAgICAgICAgICAgICAgICAgICAndGgnOiB0cnVlLCAndHInOiB0cnVlfSxcXG4gIGNvbnRleHRHcmFiYmVyczoge1xcbiAgICAnZGQnOiB7J2RkJzogdHJ1ZSwgJ2R0JzogdHJ1ZX0sXFxuICAgICdkdCc6IHsnZGQnOiB0cnVlLCAnZHQnOiB0cnVlfSxcXG4gICAgJ2xpJzogeydsaSc6IHRydWV9LFxcbiAgICAnb3B0aW9uJzogeydvcHRpb24nOiB0cnVlLCAnb3B0Z3JvdXAnOiB0cnVlfSxcXG4gICAgJ29wdGdyb3VwJzogeydvcHRncm91cCc6IHRydWV9LFxcbiAgICAncCc6IHsnYWRkcmVzcyc6IHRydWUsICdhcnRpY2xlJzogdHJ1ZSwgJ2FzaWRlJzogdHJ1ZSwgJ2Jsb2NrcXVvdGUnOiB0cnVlLCAnZGlyJzogdHJ1ZSxcXG4gICAgICAgICAgJ2Rpdic6IHRydWUsICdkbCc6IHRydWUsICdmaWVsZHNldCc6IHRydWUsICdmb290ZXInOiB0cnVlLCAnZm9ybSc6IHRydWUsXFxuICAgICAgICAgICdoMSc6IHRydWUsICdoMic6IHRydWUsICdoMyc6IHRydWUsICdoNCc6IHRydWUsICdoNSc6IHRydWUsICdoNic6IHRydWUsXFxuICAgICAgICAgICdoZWFkZXInOiB0cnVlLCAnaGdyb3VwJzogdHJ1ZSwgJ2hyJzogdHJ1ZSwgJ21lbnUnOiB0cnVlLCAnbmF2JzogdHJ1ZSwgJ29sJzogdHJ1ZSxcXG4gICAgICAgICAgJ3AnOiB0cnVlLCAncHJlJzogdHJ1ZSwgJ3NlY3Rpb24nOiB0cnVlLCAndGFibGUnOiB0cnVlLCAndWwnOiB0cnVlfSxcXG4gICAgJ3JwJzogeydycCc6IHRydWUsICdydCc6IHRydWV9LFxcbiAgICAncnQnOiB7J3JwJzogdHJ1ZSwgJ3J0JzogdHJ1ZX0sXFxuICAgICd0Ym9keSc6IHsndGJvZHknOiB0cnVlLCAndGZvb3QnOiB0cnVlfSxcXG4gICAgJ3RkJzogeyd0ZCc6IHRydWUsICd0aCc6IHRydWV9LFxcbiAgICAndGZvb3QnOiB7J3Rib2R5JzogdHJ1ZX0sXFxuICAgICd0aCc6IHsndGQnOiB0cnVlLCAndGgnOiB0cnVlfSxcXG4gICAgJ3RoZWFkJzogeyd0Ym9keSc6IHRydWUsICd0Zm9vdCc6IHRydWV9LFxcbiAgICAndHInOiB7J3RyJzogdHJ1ZX1cXG4gIH0sXFxuICBkb05vdEluZGVudDoge1xcXCJwcmVcXFwiOiB0cnVlfSxcXG4gIGFsbG93VW5xdW90ZWQ6IHRydWUsXFxuICBhbGxvd01pc3Npbmc6IHRydWUsXFxuICBjYXNlRm9sZDogdHJ1ZVxcbn1cXG5cXG52YXIgeG1sQ29uZmlnID0ge1xcbiAgYXV0b1NlbGZDbG9zZXJzOiB7fSxcXG4gIGltcGxpY2l0bHlDbG9zZWQ6IHt9LFxcbiAgY29udGV4dEdyYWJiZXJzOiB7fSxcXG4gIGRvTm90SW5kZW50OiB7fSxcXG4gIGFsbG93VW5xdW90ZWQ6IGZhbHNlLFxcbiAgYWxsb3dNaXNzaW5nOiBmYWxzZSxcXG4gIGNhc2VGb2xkOiBmYWxzZVxcbn1cXG5cXG5Db2RlTWlycm9yLmRlZmluZU1vZGUoXFxcInhtbFxcXCIsIGZ1bmN0aW9uKGVkaXRvckNvbmYsIGNvbmZpZ18pIHtcXG4gIHZhciBpbmRlbnRVbml0ID0gZWRpdG9yQ29uZi5pbmRlbnRVbml0XFxuICB2YXIgY29uZmlnID0ge31cXG4gIHZhciBkZWZhdWx0cyA9IGNvbmZpZ18uaHRtbE1vZGUgPyBodG1sQ29uZmlnIDogeG1sQ29uZmlnXFxuICBmb3IgKHZhciBwcm9wIGluIGRlZmF1bHRzKSBjb25maWdbcHJvcF0gPSBkZWZhdWx0c1twcm9wXVxcbiAgZm9yICh2YXIgcHJvcCBpbiBjb25maWdfKSBjb25maWdbcHJvcF0gPSBjb25maWdfW3Byb3BdXFxuXFxuICAvLyBSZXR1cm4gdmFyaWFibGVzIGZvciB0b2tlbml6ZXJzXFxuICB2YXIgdHlwZSwgc2V0U3R5bGU7XFxuXFxuICBmdW5jdGlvbiBpblRleHQoc3RyZWFtLCBzdGF0ZSkge1xcbiAgICBmdW5jdGlvbiBjaGFpbihwYXJzZXIpIHtcXG4gICAgICBzdGF0ZS50b2tlbml6ZSA9IHBhcnNlcjtcXG4gICAgICByZXR1cm4gcGFyc2VyKHN0cmVhbSwgc3RhdGUpO1xcbiAgICB9XFxuXFxuICAgIHZhciBjaCA9IHN0cmVhbS5uZXh0KCk7XFxuICAgIGlmIChjaCA9PSBcXFwiPFxcXCIpIHtcXG4gICAgICBpZiAoc3RyZWFtLmVhdChcXFwiIVxcXCIpKSB7XFxuICAgICAgICBpZiAoc3RyZWFtLmVhdChcXFwiW1xcXCIpKSB7XFxuICAgICAgICAgIGlmIChzdHJlYW0ubWF0Y2goXFxcIkNEQVRBW1xcXCIpKSByZXR1cm4gY2hhaW4oaW5CbG9jayhcXFwiYXRvbVxcXCIsIFxcXCJdXT5cXFwiKSk7XFxuICAgICAgICAgIGVsc2UgcmV0dXJuIG51bGw7XFxuICAgICAgICB9IGVsc2UgaWYgKHN0cmVhbS5tYXRjaChcXFwiLS1cXFwiKSkge1xcbiAgICAgICAgICByZXR1cm4gY2hhaW4oaW5CbG9jayhcXFwiY29tbWVudFxcXCIsIFxcXCItLT5cXFwiKSk7XFxuICAgICAgICB9IGVsc2UgaWYgKHN0cmVhbS5tYXRjaChcXFwiRE9DVFlQRVxcXCIsIHRydWUsIHRydWUpKSB7XFxuICAgICAgICAgIHN0cmVhbS5lYXRXaGlsZSgvW1xcXFx3XFxcXC5fXFxcXC1dLyk7XFxuICAgICAgICAgIHJldHVybiBjaGFpbihkb2N0eXBlKDEpKTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIHJldHVybiBudWxsO1xcbiAgICAgICAgfVxcbiAgICAgIH0gZWxzZSBpZiAoc3RyZWFtLmVhdChcXFwiP1xcXCIpKSB7XFxuICAgICAgICBzdHJlYW0uZWF0V2hpbGUoL1tcXFxcd1xcXFwuX1xcXFwtXS8pO1xcbiAgICAgICAgc3RhdGUudG9rZW5pemUgPSBpbkJsb2NrKFxcXCJtZXRhXFxcIiwgXFxcIj8+XFxcIik7XFxuICAgICAgICByZXR1cm4gXFxcIm1ldGFcXFwiO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICB0eXBlID0gc3RyZWFtLmVhdChcXFwiL1xcXCIpID8gXFxcImNsb3NlVGFnXFxcIiA6IFxcXCJvcGVuVGFnXFxcIjtcXG4gICAgICAgIHN0YXRlLnRva2VuaXplID0gaW5UYWc7XFxuICAgICAgICByZXR1cm4gXFxcInRhZyBicmFja2V0XFxcIjtcXG4gICAgICB9XFxuICAgIH0gZWxzZSBpZiAoY2ggPT0gXFxcIiZcXFwiKSB7XFxuICAgICAgdmFyIG9rO1xcbiAgICAgIGlmIChzdHJlYW0uZWF0KFxcXCIjXFxcIikpIHtcXG4gICAgICAgIGlmIChzdHJlYW0uZWF0KFxcXCJ4XFxcIikpIHtcXG4gICAgICAgICAgb2sgPSBzdHJlYW0uZWF0V2hpbGUoL1thLWZBLUZcXFxcZF0vKSAmJiBzdHJlYW0uZWF0KFxcXCI7XFxcIik7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICBvayA9IHN0cmVhbS5lYXRXaGlsZSgvW1xcXFxkXS8pICYmIHN0cmVhbS5lYXQoXFxcIjtcXFwiKTtcXG4gICAgICAgIH1cXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgb2sgPSBzdHJlYW0uZWF0V2hpbGUoL1tcXFxcd1xcXFwuXFxcXC06XS8pICYmIHN0cmVhbS5lYXQoXFxcIjtcXFwiKTtcXG4gICAgICB9XFxuICAgICAgcmV0dXJuIG9rID8gXFxcImF0b21cXFwiIDogXFxcImVycm9yXFxcIjtcXG4gICAgfSBlbHNlIHtcXG4gICAgICBzdHJlYW0uZWF0V2hpbGUoL1teJjxdLyk7XFxuICAgICAgcmV0dXJuIG51bGw7XFxuICAgIH1cXG4gIH1cXG4gIGluVGV4dC5pc0luVGV4dCA9IHRydWU7XFxuXFxuICBmdW5jdGlvbiBpblRhZyhzdHJlYW0sIHN0YXRlKSB7XFxuICAgIHZhciBjaCA9IHN0cmVhbS5uZXh0KCk7XFxuICAgIGlmIChjaCA9PSBcXFwiPlxcXCIgfHwgKGNoID09IFxcXCIvXFxcIiAmJiBzdHJlYW0uZWF0KFxcXCI+XFxcIikpKSB7XFxuICAgICAgc3RhdGUudG9rZW5pemUgPSBpblRleHQ7XFxuICAgICAgdHlwZSA9IGNoID09IFxcXCI+XFxcIiA/IFxcXCJlbmRUYWdcXFwiIDogXFxcInNlbGZjbG9zZVRhZ1xcXCI7XFxuICAgICAgcmV0dXJuIFxcXCJ0YWcgYnJhY2tldFxcXCI7XFxuICAgIH0gZWxzZSBpZiAoY2ggPT0gXFxcIj1cXFwiKSB7XFxuICAgICAgdHlwZSA9IFxcXCJlcXVhbHNcXFwiO1xcbiAgICAgIHJldHVybiBudWxsO1xcbiAgICB9IGVsc2UgaWYgKGNoID09IFxcXCI8XFxcIikge1xcbiAgICAgIHN0YXRlLnRva2VuaXplID0gaW5UZXh0O1xcbiAgICAgIHN0YXRlLnN0YXRlID0gYmFzZVN0YXRlO1xcbiAgICAgIHN0YXRlLnRhZ05hbWUgPSBzdGF0ZS50YWdTdGFydCA9IG51bGw7XFxuICAgICAgdmFyIG5leHQgPSBzdGF0ZS50b2tlbml6ZShzdHJlYW0sIHN0YXRlKTtcXG4gICAgICByZXR1cm4gbmV4dCA/IG5leHQgKyBcXFwiIHRhZyBlcnJvclxcXCIgOiBcXFwidGFnIGVycm9yXFxcIjtcXG4gICAgfSBlbHNlIGlmICgvW1xcXFwnXFxcXFxcXCJdLy50ZXN0KGNoKSkge1xcbiAgICAgIHN0YXRlLnRva2VuaXplID0gaW5BdHRyaWJ1dGUoY2gpO1xcbiAgICAgIHN0YXRlLnN0cmluZ1N0YXJ0Q29sID0gc3RyZWFtLmNvbHVtbigpO1xcbiAgICAgIHJldHVybiBzdGF0ZS50b2tlbml6ZShzdHJlYW0sIHN0YXRlKTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICBzdHJlYW0ubWF0Y2goL15bXlxcXFxzXFxcXHUwMGEwPTw+XFxcXFxcXCJcXFxcJ10qW15cXFxcc1xcXFx1MDBhMD08PlxcXFxcXFwiXFxcXCdcXFxcL10vKTtcXG4gICAgICByZXR1cm4gXFxcIndvcmRcXFwiO1xcbiAgICB9XFxuICB9XFxuXFxuICBmdW5jdGlvbiBpbkF0dHJpYnV0ZShxdW90ZSkge1xcbiAgICB2YXIgY2xvc3VyZSA9IGZ1bmN0aW9uKHN0cmVhbSwgc3RhdGUpIHtcXG4gICAgICB3aGlsZSAoIXN0cmVhbS5lb2woKSkge1xcbiAgICAgICAgaWYgKHN0cmVhbS5uZXh0KCkgPT0gcXVvdGUpIHtcXG4gICAgICAgICAgc3RhdGUudG9rZW5pemUgPSBpblRhZztcXG4gICAgICAgICAgYnJlYWs7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICAgIHJldHVybiBcXFwic3RyaW5nXFxcIjtcXG4gICAgfTtcXG4gICAgY2xvc3VyZS5pc0luQXR0cmlidXRlID0gdHJ1ZTtcXG4gICAgcmV0dXJuIGNsb3N1cmU7XFxuICB9XFxuXFxuICBmdW5jdGlvbiBpbkJsb2NrKHN0eWxlLCB0ZXJtaW5hdG9yKSB7XFxuICAgIHJldHVybiBmdW5jdGlvbihzdHJlYW0sIHN0YXRlKSB7XFxuICAgICAgd2hpbGUgKCFzdHJlYW0uZW9sKCkpIHtcXG4gICAgICAgIGlmIChzdHJlYW0ubWF0Y2godGVybWluYXRvcikpIHtcXG4gICAgICAgICAgc3RhdGUudG9rZW5pemUgPSBpblRleHQ7XFxuICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgfVxcbiAgICAgICAgc3RyZWFtLm5leHQoKTtcXG4gICAgICB9XFxuICAgICAgcmV0dXJuIHN0eWxlO1xcbiAgICB9O1xcbiAgfVxcbiAgZnVuY3Rpb24gZG9jdHlwZShkZXB0aCkge1xcbiAgICByZXR1cm4gZnVuY3Rpb24oc3RyZWFtLCBzdGF0ZSkge1xcbiAgICAgIHZhciBjaDtcXG4gICAgICB3aGlsZSAoKGNoID0gc3RyZWFtLm5leHQoKSkgIT0gbnVsbCkge1xcbiAgICAgICAgaWYgKGNoID09IFxcXCI8XFxcIikge1xcbiAgICAgICAgICBzdGF0ZS50b2tlbml6ZSA9IGRvY3R5cGUoZGVwdGggKyAxKTtcXG4gICAgICAgICAgcmV0dXJuIHN0YXRlLnRva2VuaXplKHN0cmVhbSwgc3RhdGUpO1xcbiAgICAgICAgfSBlbHNlIGlmIChjaCA9PSBcXFwiPlxcXCIpIHtcXG4gICAgICAgICAgaWYgKGRlcHRoID09IDEpIHtcXG4gICAgICAgICAgICBzdGF0ZS50b2tlbml6ZSA9IGluVGV4dDtcXG4gICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICBzdGF0ZS50b2tlbml6ZSA9IGRvY3R5cGUoZGVwdGggLSAxKTtcXG4gICAgICAgICAgICByZXR1cm4gc3RhdGUudG9rZW5pemUoc3RyZWFtLCBzdGF0ZSk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgICAgcmV0dXJuIFxcXCJtZXRhXFxcIjtcXG4gICAgfTtcXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIENvbnRleHQoc3RhdGUsIHRhZ05hbWUsIHN0YXJ0T2ZMaW5lKSB7XFxuICAgIHRoaXMucHJldiA9IHN0YXRlLmNvbnRleHQ7XFxuICAgIHRoaXMudGFnTmFtZSA9IHRhZ05hbWU7XFxuICAgIHRoaXMuaW5kZW50ID0gc3RhdGUuaW5kZW50ZWQ7XFxuICAgIHRoaXMuc3RhcnRPZkxpbmUgPSBzdGFydE9mTGluZTtcXG4gICAgaWYgKGNvbmZpZy5kb05vdEluZGVudC5oYXNPd25Qcm9wZXJ0eSh0YWdOYW1lKSB8fCAoc3RhdGUuY29udGV4dCAmJiBzdGF0ZS5jb250ZXh0Lm5vSW5kZW50KSlcXG4gICAgICB0aGlzLm5vSW5kZW50ID0gdHJ1ZTtcXG4gIH1cXG4gIGZ1bmN0aW9uIHBvcENvbnRleHQoc3RhdGUpIHtcXG4gICAgaWYgKHN0YXRlLmNvbnRleHQpIHN0YXRlLmNvbnRleHQgPSBzdGF0ZS5jb250ZXh0LnByZXY7XFxuICB9XFxuICBmdW5jdGlvbiBtYXliZVBvcENvbnRleHQoc3RhdGUsIG5leHRUYWdOYW1lKSB7XFxuICAgIHZhciBwYXJlbnRUYWdOYW1lO1xcbiAgICB3aGlsZSAodHJ1ZSkge1xcbiAgICAgIGlmICghc3RhdGUuY29udGV4dCkge1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICAgIH1cXG4gICAgICBwYXJlbnRUYWdOYW1lID0gc3RhdGUuY29udGV4dC50YWdOYW1lO1xcbiAgICAgIGlmICghY29uZmlnLmNvbnRleHRHcmFiYmVycy5oYXNPd25Qcm9wZXJ0eShwYXJlbnRUYWdOYW1lKSB8fFxcbiAgICAgICAgICAhY29uZmlnLmNvbnRleHRHcmFiYmVyc1twYXJlbnRUYWdOYW1lXS5oYXNPd25Qcm9wZXJ0eShuZXh0VGFnTmFtZSkpIHtcXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9XFxuICAgICAgcG9wQ29udGV4dChzdGF0ZSk7XFxuICAgIH1cXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIGJhc2VTdGF0ZSh0eXBlLCBzdHJlYW0sIHN0YXRlKSB7XFxuICAgIGlmICh0eXBlID09IFxcXCJvcGVuVGFnXFxcIikge1xcbiAgICAgIHN0YXRlLnRhZ1N0YXJ0ID0gc3RyZWFtLmNvbHVtbigpO1xcbiAgICAgIHJldHVybiB0YWdOYW1lU3RhdGU7XFxuICAgIH0gZWxzZSBpZiAodHlwZSA9PSBcXFwiY2xvc2VUYWdcXFwiKSB7XFxuICAgICAgcmV0dXJuIGNsb3NlVGFnTmFtZVN0YXRlO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIHJldHVybiBiYXNlU3RhdGU7XFxuICAgIH1cXG4gIH1cXG4gIGZ1bmN0aW9uIHRhZ05hbWVTdGF0ZSh0eXBlLCBzdHJlYW0sIHN0YXRlKSB7XFxuICAgIGlmICh0eXBlID09IFxcXCJ3b3JkXFxcIikge1xcbiAgICAgIHN0YXRlLnRhZ05hbWUgPSBzdHJlYW0uY3VycmVudCgpO1xcbiAgICAgIHNldFN0eWxlID0gXFxcInRhZ1xcXCI7XFxuICAgICAgcmV0dXJuIGF0dHJTdGF0ZTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICBzZXRTdHlsZSA9IFxcXCJlcnJvclxcXCI7XFxuICAgICAgcmV0dXJuIHRhZ05hbWVTdGF0ZTtcXG4gICAgfVxcbiAgfVxcbiAgZnVuY3Rpb24gY2xvc2VUYWdOYW1lU3RhdGUodHlwZSwgc3RyZWFtLCBzdGF0ZSkge1xcbiAgICBpZiAodHlwZSA9PSBcXFwid29yZFxcXCIpIHtcXG4gICAgICB2YXIgdGFnTmFtZSA9IHN0cmVhbS5jdXJyZW50KCk7XFxuICAgICAgaWYgKHN0YXRlLmNvbnRleHQgJiYgc3RhdGUuY29udGV4dC50YWdOYW1lICE9IHRhZ05hbWUgJiZcXG4gICAgICAgICAgY29uZmlnLmltcGxpY2l0bHlDbG9zZWQuaGFzT3duUHJvcGVydHkoc3RhdGUuY29udGV4dC50YWdOYW1lKSlcXG4gICAgICAgIHBvcENvbnRleHQoc3RhdGUpO1xcbiAgICAgIGlmICgoc3RhdGUuY29udGV4dCAmJiBzdGF0ZS5jb250ZXh0LnRhZ05hbWUgPT0gdGFnTmFtZSkgfHwgY29uZmlnLm1hdGNoQ2xvc2luZyA9PT0gZmFsc2UpIHtcXG4gICAgICAgIHNldFN0eWxlID0gXFxcInRhZ1xcXCI7XFxuICAgICAgICByZXR1cm4gY2xvc2VTdGF0ZTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgc2V0U3R5bGUgPSBcXFwidGFnIGVycm9yXFxcIjtcXG4gICAgICAgIHJldHVybiBjbG9zZVN0YXRlRXJyO1xcbiAgICAgIH1cXG4gICAgfSBlbHNlIHtcXG4gICAgICBzZXRTdHlsZSA9IFxcXCJlcnJvclxcXCI7XFxuICAgICAgcmV0dXJuIGNsb3NlU3RhdGVFcnI7XFxuICAgIH1cXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIGNsb3NlU3RhdGUodHlwZSwgX3N0cmVhbSwgc3RhdGUpIHtcXG4gICAgaWYgKHR5cGUgIT0gXFxcImVuZFRhZ1xcXCIpIHtcXG4gICAgICBzZXRTdHlsZSA9IFxcXCJlcnJvclxcXCI7XFxuICAgICAgcmV0dXJuIGNsb3NlU3RhdGU7XFxuICAgIH1cXG4gICAgcG9wQ29udGV4dChzdGF0ZSk7XFxuICAgIHJldHVybiBiYXNlU3RhdGU7XFxuICB9XFxuICBmdW5jdGlvbiBjbG9zZVN0YXRlRXJyKHR5cGUsIHN0cmVhbSwgc3RhdGUpIHtcXG4gICAgc2V0U3R5bGUgPSBcXFwiZXJyb3JcXFwiO1xcbiAgICByZXR1cm4gY2xvc2VTdGF0ZSh0eXBlLCBzdHJlYW0sIHN0YXRlKTtcXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIGF0dHJTdGF0ZSh0eXBlLCBfc3RyZWFtLCBzdGF0ZSkge1xcbiAgICBpZiAodHlwZSA9PSBcXFwid29yZFxcXCIpIHtcXG4gICAgICBzZXRTdHlsZSA9IFxcXCJhdHRyaWJ1dGVcXFwiO1xcbiAgICAgIHJldHVybiBhdHRyRXFTdGF0ZTtcXG4gICAgfSBlbHNlIGlmICh0eXBlID09IFxcXCJlbmRUYWdcXFwiIHx8IHR5cGUgPT0gXFxcInNlbGZjbG9zZVRhZ1xcXCIpIHtcXG4gICAgICB2YXIgdGFnTmFtZSA9IHN0YXRlLnRhZ05hbWUsIHRhZ1N0YXJ0ID0gc3RhdGUudGFnU3RhcnQ7XFxuICAgICAgc3RhdGUudGFnTmFtZSA9IHN0YXRlLnRhZ1N0YXJ0ID0gbnVsbDtcXG4gICAgICBpZiAodHlwZSA9PSBcXFwic2VsZmNsb3NlVGFnXFxcIiB8fFxcbiAgICAgICAgICBjb25maWcuYXV0b1NlbGZDbG9zZXJzLmhhc093blByb3BlcnR5KHRhZ05hbWUpKSB7XFxuICAgICAgICBtYXliZVBvcENvbnRleHQoc3RhdGUsIHRhZ05hbWUpO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBtYXliZVBvcENvbnRleHQoc3RhdGUsIHRhZ05hbWUpO1xcbiAgICAgICAgc3RhdGUuY29udGV4dCA9IG5ldyBDb250ZXh0KHN0YXRlLCB0YWdOYW1lLCB0YWdTdGFydCA9PSBzdGF0ZS5pbmRlbnRlZCk7XFxuICAgICAgfVxcbiAgICAgIHJldHVybiBiYXNlU3RhdGU7XFxuICAgIH1cXG4gICAgc2V0U3R5bGUgPSBcXFwiZXJyb3JcXFwiO1xcbiAgICByZXR1cm4gYXR0clN0YXRlO1xcbiAgfVxcbiAgZnVuY3Rpb24gYXR0ckVxU3RhdGUodHlwZSwgc3RyZWFtLCBzdGF0ZSkge1xcbiAgICBpZiAodHlwZSA9PSBcXFwiZXF1YWxzXFxcIikgcmV0dXJuIGF0dHJWYWx1ZVN0YXRlO1xcbiAgICBpZiAoIWNvbmZpZy5hbGxvd01pc3NpbmcpIHNldFN0eWxlID0gXFxcImVycm9yXFxcIjtcXG4gICAgcmV0dXJuIGF0dHJTdGF0ZSh0eXBlLCBzdHJlYW0sIHN0YXRlKTtcXG4gIH1cXG4gIGZ1bmN0aW9uIGF0dHJWYWx1ZVN0YXRlKHR5cGUsIHN0cmVhbSwgc3RhdGUpIHtcXG4gICAgaWYgKHR5cGUgPT0gXFxcInN0cmluZ1xcXCIpIHJldHVybiBhdHRyQ29udGludWVkU3RhdGU7XFxuICAgIGlmICh0eXBlID09IFxcXCJ3b3JkXFxcIiAmJiBjb25maWcuYWxsb3dVbnF1b3RlZCkge3NldFN0eWxlID0gXFxcInN0cmluZ1xcXCI7IHJldHVybiBhdHRyU3RhdGU7fVxcbiAgICBzZXRTdHlsZSA9IFxcXCJlcnJvclxcXCI7XFxuICAgIHJldHVybiBhdHRyU3RhdGUodHlwZSwgc3RyZWFtLCBzdGF0ZSk7XFxuICB9XFxuICBmdW5jdGlvbiBhdHRyQ29udGludWVkU3RhdGUodHlwZSwgc3RyZWFtLCBzdGF0ZSkge1xcbiAgICBpZiAodHlwZSA9PSBcXFwic3RyaW5nXFxcIikgcmV0dXJuIGF0dHJDb250aW51ZWRTdGF0ZTtcXG4gICAgcmV0dXJuIGF0dHJTdGF0ZSh0eXBlLCBzdHJlYW0sIHN0YXRlKTtcXG4gIH1cXG5cXG4gIHJldHVybiB7XFxuICAgIHN0YXJ0U3RhdGU6IGZ1bmN0aW9uKGJhc2VJbmRlbnQpIHtcXG4gICAgICB2YXIgc3RhdGUgPSB7dG9rZW5pemU6IGluVGV4dCxcXG4gICAgICAgICAgICAgICAgICAgc3RhdGU6IGJhc2VTdGF0ZSxcXG4gICAgICAgICAgICAgICAgICAgaW5kZW50ZWQ6IGJhc2VJbmRlbnQgfHwgMCxcXG4gICAgICAgICAgICAgICAgICAgdGFnTmFtZTogbnVsbCwgdGFnU3RhcnQ6IG51bGwsXFxuICAgICAgICAgICAgICAgICAgIGNvbnRleHQ6IG51bGx9XFxuICAgICAgaWYgKGJhc2VJbmRlbnQgIT0gbnVsbCkgc3RhdGUuYmFzZUluZGVudCA9IGJhc2VJbmRlbnRcXG4gICAgICByZXR1cm4gc3RhdGVcXG4gICAgfSxcXG5cXG4gICAgdG9rZW46IGZ1bmN0aW9uKHN0cmVhbSwgc3RhdGUpIHtcXG4gICAgICBpZiAoIXN0YXRlLnRhZ05hbWUgJiYgc3RyZWFtLnNvbCgpKVxcbiAgICAgICAgc3RhdGUuaW5kZW50ZWQgPSBzdHJlYW0uaW5kZW50YXRpb24oKTtcXG5cXG4gICAgICBpZiAoc3RyZWFtLmVhdFNwYWNlKCkpIHJldHVybiBudWxsO1xcbiAgICAgIHR5cGUgPSBudWxsO1xcbiAgICAgIHZhciBzdHlsZSA9IHN0YXRlLnRva2VuaXplKHN0cmVhbSwgc3RhdGUpO1xcbiAgICAgIGlmICgoc3R5bGUgfHwgdHlwZSkgJiYgc3R5bGUgIT0gXFxcImNvbW1lbnRcXFwiKSB7XFxuICAgICAgICBzZXRTdHlsZSA9IG51bGw7XFxuICAgICAgICBzdGF0ZS5zdGF0ZSA9IHN0YXRlLnN0YXRlKHR5cGUgfHwgc3R5bGUsIHN0cmVhbSwgc3RhdGUpO1xcbiAgICAgICAgaWYgKHNldFN0eWxlKVxcbiAgICAgICAgICBzdHlsZSA9IHNldFN0eWxlID09IFxcXCJlcnJvclxcXCIgPyBzdHlsZSArIFxcXCIgZXJyb3JcXFwiIDogc2V0U3R5bGU7XFxuICAgICAgfVxcbiAgICAgIHJldHVybiBzdHlsZTtcXG4gICAgfSxcXG5cXG4gICAgaW5kZW50OiBmdW5jdGlvbihzdGF0ZSwgdGV4dEFmdGVyLCBmdWxsTGluZSkge1xcbiAgICAgIHZhciBjb250ZXh0ID0gc3RhdGUuY29udGV4dDtcXG4gICAgICAvLyBJbmRlbnQgbXVsdGktbGluZSBzdHJpbmdzIChlLmcuIGNzcykuXFxuICAgICAgaWYgKHN0YXRlLnRva2VuaXplLmlzSW5BdHRyaWJ1dGUpIHtcXG4gICAgICAgIGlmIChzdGF0ZS50YWdTdGFydCA9PSBzdGF0ZS5pbmRlbnRlZClcXG4gICAgICAgICAgcmV0dXJuIHN0YXRlLnN0cmluZ1N0YXJ0Q29sICsgMTtcXG4gICAgICAgIGVsc2VcXG4gICAgICAgICAgcmV0dXJuIHN0YXRlLmluZGVudGVkICsgaW5kZW50VW5pdDtcXG4gICAgICB9XFxuICAgICAgaWYgKGNvbnRleHQgJiYgY29udGV4dC5ub0luZGVudCkgcmV0dXJuIENvZGVNaXJyb3IuUGFzcztcXG4gICAgICBpZiAoc3RhdGUudG9rZW5pemUgIT0gaW5UYWcgJiYgc3RhdGUudG9rZW5pemUgIT0gaW5UZXh0KVxcbiAgICAgICAgcmV0dXJuIGZ1bGxMaW5lID8gZnVsbExpbmUubWF0Y2goL14oXFxcXHMqKS8pWzBdLmxlbmd0aCA6IDA7XFxuICAgICAgLy8gSW5kZW50IHRoZSBzdGFydHMgb2YgYXR0cmlidXRlIG5hbWVzLlxcbiAgICAgIGlmIChzdGF0ZS50YWdOYW1lKSB7XFxuICAgICAgICBpZiAoY29uZmlnLm11bHRpbGluZVRhZ0luZGVudFBhc3RUYWcgIT09IGZhbHNlKVxcbiAgICAgICAgICByZXR1cm4gc3RhdGUudGFnU3RhcnQgKyBzdGF0ZS50YWdOYW1lLmxlbmd0aCArIDI7XFxuICAgICAgICBlbHNlXFxuICAgICAgICAgIHJldHVybiBzdGF0ZS50YWdTdGFydCArIGluZGVudFVuaXQgKiAoY29uZmlnLm11bHRpbGluZVRhZ0luZGVudEZhY3RvciB8fCAxKTtcXG4gICAgICB9XFxuICAgICAgaWYgKGNvbmZpZy5hbGlnbkNEQVRBICYmIC88IVxcXFxbQ0RBVEFcXFxcWy8udGVzdCh0ZXh0QWZ0ZXIpKSByZXR1cm4gMDtcXG4gICAgICB2YXIgdGFnQWZ0ZXIgPSB0ZXh0QWZ0ZXIgJiYgL148KFxcXFwvKT8oW1xcXFx3XzpcXFxcLi1dKikvLmV4ZWModGV4dEFmdGVyKTtcXG4gICAgICBpZiAodGFnQWZ0ZXIgJiYgdGFnQWZ0ZXJbMV0pIHsgLy8gQ2xvc2luZyB0YWcgc3BvdHRlZFxcbiAgICAgICAgd2hpbGUgKGNvbnRleHQpIHtcXG4gICAgICAgICAgaWYgKGNvbnRleHQudGFnTmFtZSA9PSB0YWdBZnRlclsyXSkge1xcbiAgICAgICAgICAgIGNvbnRleHQgPSBjb250ZXh0LnByZXY7XFxuICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgIH0gZWxzZSBpZiAoY29uZmlnLmltcGxpY2l0bHlDbG9zZWQuaGFzT3duUHJvcGVydHkoY29udGV4dC50YWdOYW1lKSkge1xcbiAgICAgICAgICAgIGNvbnRleHQgPSBjb250ZXh0LnByZXY7XFxuICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICB9IGVsc2UgaWYgKHRhZ0FmdGVyKSB7IC8vIE9wZW5pbmcgdGFnIHNwb3R0ZWRcXG4gICAgICAgIHdoaWxlIChjb250ZXh0KSB7XFxuICAgICAgICAgIHZhciBncmFiYmVycyA9IGNvbmZpZy5jb250ZXh0R3JhYmJlcnNbY29udGV4dC50YWdOYW1lXTtcXG4gICAgICAgICAgaWYgKGdyYWJiZXJzICYmIGdyYWJiZXJzLmhhc093blByb3BlcnR5KHRhZ0FmdGVyWzJdKSlcXG4gICAgICAgICAgICBjb250ZXh0ID0gY29udGV4dC5wcmV2O1xcbiAgICAgICAgICBlbHNlXFxuICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICAgIHdoaWxlIChjb250ZXh0ICYmIGNvbnRleHQucHJldiAmJiAhY29udGV4dC5zdGFydE9mTGluZSlcXG4gICAgICAgIGNvbnRleHQgPSBjb250ZXh0LnByZXY7XFxuICAgICAgaWYgKGNvbnRleHQpIHJldHVybiBjb250ZXh0LmluZGVudCArIGluZGVudFVuaXQ7XFxuICAgICAgZWxzZSByZXR1cm4gc3RhdGUuYmFzZUluZGVudCB8fCAwO1xcbiAgICB9LFxcblxcbiAgICBlbGVjdHJpY0lucHV0OiAvPFxcXFwvW1xcXFxzXFxcXHc6XSs+JC8sXFxuICAgIGJsb2NrQ29tbWVudFN0YXJ0OiBcXFwiPCEtLVxcXCIsXFxuICAgIGJsb2NrQ29tbWVudEVuZDogXFxcIi0tPlxcXCIsXFxuXFxuICAgIGNvbmZpZ3VyYXRpb246IGNvbmZpZy5odG1sTW9kZSA/IFxcXCJodG1sXFxcIiA6IFxcXCJ4bWxcXFwiLFxcbiAgICBoZWxwZXJUeXBlOiBjb25maWcuaHRtbE1vZGUgPyBcXFwiaHRtbFxcXCIgOiBcXFwieG1sXFxcIixcXG5cXG4gICAgc2tpcEF0dHJpYnV0ZTogZnVuY3Rpb24oc3RhdGUpIHtcXG4gICAgICBpZiAoc3RhdGUuc3RhdGUgPT0gYXR0clZhbHVlU3RhdGUpXFxuICAgICAgICBzdGF0ZS5zdGF0ZSA9IGF0dHJTdGF0ZVxcbiAgICB9XFxuICB9O1xcbn0pO1xcblxcbkNvZGVNaXJyb3IuZGVmaW5lTUlNRShcXFwidGV4dC94bWxcXFwiLCBcXFwieG1sXFxcIik7XFxuQ29kZU1pcnJvci5kZWZpbmVNSU1FKFxcXCJhcHBsaWNhdGlvbi94bWxcXFwiLCBcXFwieG1sXFxcIik7XFxuaWYgKCFDb2RlTWlycm9yLm1pbWVNb2Rlcy5oYXNPd25Qcm9wZXJ0eShcXFwidGV4dC9odG1sXFxcIikpXFxuICBDb2RlTWlycm9yLmRlZmluZU1JTUUoXFxcInRleHQvaHRtbFxcXCIsIHtuYW1lOiBcXFwieG1sXFxcIiwgaHRtbE1vZGU6IHRydWV9KTtcXG5cXG59KTtcXG5cIlxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yYXctbG9hZGVyIS4vfi9jb2RlbWlycm9yL21vZGUveG1sL3htbC5qc1xuLy8gbW9kdWxlIGlkID0gN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	eval("__webpack_require__(2)(__webpack_require__(9))//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL34vZnJvYWxhLWVkaXRvci9qcy9wbHVnaW5zL2FsaWduLm1pbi5qcz9jYzMxIl0sInNvdXJjZXNDb250ZW50IjpbInJlcXVpcmUoXCIhIS92YXIvYXBwL3dlYi9qcy9ub2RlX21vZHVsZXMvc2NyaXB0LWxvYWRlci9hZGRTY3JpcHQuanNcIikocmVxdWlyZShcIiEhL3Zhci9hcHAvd2ViL2pzL25vZGVfbW9kdWxlcy9yYXctbG9hZGVyL2luZGV4LmpzIS92YXIvYXBwL3dlYi9qcy9ub2RlX21vZHVsZXMvZnJvYWxhLWVkaXRvci9qcy9wbHVnaW5zL2FsaWduLm1pbi5qc1wiKSlcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vc2NyaXB0LWxvYWRlciEuL34vZnJvYWxhLWVkaXRvci9qcy9wbHVnaW5zL2FsaWduLm1pbi5qc1xuLy8gbW9kdWxlIGlkID0gOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 9 */
/***/ function(module, exports) {

	eval("module.exports = \"/*!\\n * froala_editor v2.4.0 (https://www.froala.com/wysiwyg-editor)\\n * License https://froala.com/wysiwyg-editor/terms/\\n * Copyright 2014-2016 Froala Labs\\n */\\n\\n!function(a){\\\"function\\\"==typeof define&&define.amd?define([\\\"jquery\\\"],a):\\\"object\\\"==typeof module&&module.exports?module.exports=function(b,c){return void 0===c&&(c=\\\"undefined\\\"!=typeof window?require(\\\"jquery\\\"):require(\\\"jquery\\\")(b)),a(c),c}:a(jQuery)}(function(a){a.FE.PLUGINS.align=function(b){function c(c){b.selection.save(),b.html.wrap(!0,!0,!0,!0),b.selection.restore();for(var d=b.selection.blocks(),e=0;e<d.length;e++)b.helpers.getAlignment(a(d[e].parentNode))==c?a(d[e]).css(\\\"text-align\\\",\\\"\\\").removeClass(\\\"fr-temp-div\\\"):a(d[e]).css(\\\"text-align\\\",c).removeClass(\\\"fr-temp-div\\\"),\\\"\\\"===a(d[e]).attr(\\\"class\\\")&&a(d[e]).removeAttr(\\\"class\\\"),\\\"\\\"===a(d[e]).attr(\\\"style\\\")&&a(d[e]).removeAttr(\\\"style\\\");b.selection.save(),b.html.unwrap(),b.selection.restore()}function d(c){var d=b.selection.blocks();if(d.length){var e=b.helpers.getAlignment(a(d[0]));c.find(\\\"> *:first\\\").replaceWith(b.icon.create(\\\"align-\\\"+e))}}function e(c,d){var e=b.selection.blocks();if(e.length){var f=b.helpers.getAlignment(a(e[0]));d.find('a.fr-command[data-param1=\\\"'+f+'\\\"]').addClass(\\\"fr-active\\\").attr(\\\"aria-selected\\\",!0)}}return{apply:c,refresh:d,refreshOnShow:e}},a.FE.DefineIcon(\\\"align\\\",{NAME:\\\"align-left\\\"}),a.FE.DefineIcon(\\\"align-left\\\",{NAME:\\\"align-left\\\"}),a.FE.DefineIcon(\\\"align-right\\\",{NAME:\\\"align-right\\\"}),a.FE.DefineIcon(\\\"align-center\\\",{NAME:\\\"align-center\\\"}),a.FE.DefineIcon(\\\"align-justify\\\",{NAME:\\\"align-justify\\\"}),a.FE.RegisterCommand(\\\"align\\\",{type:\\\"dropdown\\\",title:\\\"Align\\\",options:{left:\\\"Align Left\\\",center:\\\"Align Center\\\",right:\\\"Align Right\\\",justify:\\\"Align Justify\\\"},html:function(){var b='<ul class=\\\"fr-dropdown-list\\\" role=\\\"presentation\\\">',c=a.FE.COMMANDS.align.options;for(var d in c)c.hasOwnProperty(d)&&(b+='<li role=\\\"presentation\\\"><a class=\\\"fr-command fr-title\\\" tabIndex=\\\"-1\\\" role=\\\"option\\\" data-cmd=\\\"align\\\" data-param1=\\\"'+d+'\\\" title=\\\"'+this.language.translate(c[d])+'\\\">'+this.icon.create(\\\"align-\\\"+d)+'<span class=\\\"fr-sr-only\\\">'+this.language.translate(c[d])+\\\"</span></a></li>\\\");return b+=\\\"</ul>\\\"},callback:function(a,b){this.align.apply(b)},refresh:function(a){this.align.refresh(a)},refreshOnShow:function(a,b){this.align.refreshOnShow(a,b)},plugin:\\\"align\\\"})});\"//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL34vZnJvYWxhLWVkaXRvci9qcy9wbHVnaW5zL2FsaWduLm1pbi5qcz9iYmFkIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gXCIvKiFcXG4gKiBmcm9hbGFfZWRpdG9yIHYyLjQuMCAoaHR0cHM6Ly93d3cuZnJvYWxhLmNvbS93eXNpd3lnLWVkaXRvcilcXG4gKiBMaWNlbnNlIGh0dHBzOi8vZnJvYWxhLmNvbS93eXNpd3lnLWVkaXRvci90ZXJtcy9cXG4gKiBDb3B5cmlnaHQgMjAxNC0yMDE2IEZyb2FsYSBMYWJzXFxuICovXFxuXFxuIWZ1bmN0aW9uKGEpe1xcXCJmdW5jdGlvblxcXCI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQ/ZGVmaW5lKFtcXFwianF1ZXJ5XFxcIl0sYSk6XFxcIm9iamVjdFxcXCI9PXR5cGVvZiBtb2R1bGUmJm1vZHVsZS5leHBvcnRzP21vZHVsZS5leHBvcnRzPWZ1bmN0aW9uKGIsYyl7cmV0dXJuIHZvaWQgMD09PWMmJihjPVxcXCJ1bmRlZmluZWRcXFwiIT10eXBlb2Ygd2luZG93P3JlcXVpcmUoXFxcImpxdWVyeVxcXCIpOnJlcXVpcmUoXFxcImpxdWVyeVxcXCIpKGIpKSxhKGMpLGN9OmEoalF1ZXJ5KX0oZnVuY3Rpb24oYSl7YS5GRS5QTFVHSU5TLmFsaWduPWZ1bmN0aW9uKGIpe2Z1bmN0aW9uIGMoYyl7Yi5zZWxlY3Rpb24uc2F2ZSgpLGIuaHRtbC53cmFwKCEwLCEwLCEwLCEwKSxiLnNlbGVjdGlvbi5yZXN0b3JlKCk7Zm9yKHZhciBkPWIuc2VsZWN0aW9uLmJsb2NrcygpLGU9MDtlPGQubGVuZ3RoO2UrKyliLmhlbHBlcnMuZ2V0QWxpZ25tZW50KGEoZFtlXS5wYXJlbnROb2RlKSk9PWM/YShkW2VdKS5jc3MoXFxcInRleHQtYWxpZ25cXFwiLFxcXCJcXFwiKS5yZW1vdmVDbGFzcyhcXFwiZnItdGVtcC1kaXZcXFwiKTphKGRbZV0pLmNzcyhcXFwidGV4dC1hbGlnblxcXCIsYykucmVtb3ZlQ2xhc3MoXFxcImZyLXRlbXAtZGl2XFxcIiksXFxcIlxcXCI9PT1hKGRbZV0pLmF0dHIoXFxcImNsYXNzXFxcIikmJmEoZFtlXSkucmVtb3ZlQXR0cihcXFwiY2xhc3NcXFwiKSxcXFwiXFxcIj09PWEoZFtlXSkuYXR0cihcXFwic3R5bGVcXFwiKSYmYShkW2VdKS5yZW1vdmVBdHRyKFxcXCJzdHlsZVxcXCIpO2Iuc2VsZWN0aW9uLnNhdmUoKSxiLmh0bWwudW53cmFwKCksYi5zZWxlY3Rpb24ucmVzdG9yZSgpfWZ1bmN0aW9uIGQoYyl7dmFyIGQ9Yi5zZWxlY3Rpb24uYmxvY2tzKCk7aWYoZC5sZW5ndGgpe3ZhciBlPWIuaGVscGVycy5nZXRBbGlnbm1lbnQoYShkWzBdKSk7Yy5maW5kKFxcXCI+ICo6Zmlyc3RcXFwiKS5yZXBsYWNlV2l0aChiLmljb24uY3JlYXRlKFxcXCJhbGlnbi1cXFwiK2UpKX19ZnVuY3Rpb24gZShjLGQpe3ZhciBlPWIuc2VsZWN0aW9uLmJsb2NrcygpO2lmKGUubGVuZ3RoKXt2YXIgZj1iLmhlbHBlcnMuZ2V0QWxpZ25tZW50KGEoZVswXSkpO2QuZmluZCgnYS5mci1jb21tYW5kW2RhdGEtcGFyYW0xPVxcXCInK2YrJ1xcXCJdJykuYWRkQ2xhc3MoXFxcImZyLWFjdGl2ZVxcXCIpLmF0dHIoXFxcImFyaWEtc2VsZWN0ZWRcXFwiLCEwKX19cmV0dXJue2FwcGx5OmMscmVmcmVzaDpkLHJlZnJlc2hPblNob3c6ZX19LGEuRkUuRGVmaW5lSWNvbihcXFwiYWxpZ25cXFwiLHtOQU1FOlxcXCJhbGlnbi1sZWZ0XFxcIn0pLGEuRkUuRGVmaW5lSWNvbihcXFwiYWxpZ24tbGVmdFxcXCIse05BTUU6XFxcImFsaWduLWxlZnRcXFwifSksYS5GRS5EZWZpbmVJY29uKFxcXCJhbGlnbi1yaWdodFxcXCIse05BTUU6XFxcImFsaWduLXJpZ2h0XFxcIn0pLGEuRkUuRGVmaW5lSWNvbihcXFwiYWxpZ24tY2VudGVyXFxcIix7TkFNRTpcXFwiYWxpZ24tY2VudGVyXFxcIn0pLGEuRkUuRGVmaW5lSWNvbihcXFwiYWxpZ24tanVzdGlmeVxcXCIse05BTUU6XFxcImFsaWduLWp1c3RpZnlcXFwifSksYS5GRS5SZWdpc3RlckNvbW1hbmQoXFxcImFsaWduXFxcIix7dHlwZTpcXFwiZHJvcGRvd25cXFwiLHRpdGxlOlxcXCJBbGlnblxcXCIsb3B0aW9uczp7bGVmdDpcXFwiQWxpZ24gTGVmdFxcXCIsY2VudGVyOlxcXCJBbGlnbiBDZW50ZXJcXFwiLHJpZ2h0OlxcXCJBbGlnbiBSaWdodFxcXCIsanVzdGlmeTpcXFwiQWxpZ24gSnVzdGlmeVxcXCJ9LGh0bWw6ZnVuY3Rpb24oKXt2YXIgYj0nPHVsIGNsYXNzPVxcXCJmci1kcm9wZG93bi1saXN0XFxcIiByb2xlPVxcXCJwcmVzZW50YXRpb25cXFwiPicsYz1hLkZFLkNPTU1BTkRTLmFsaWduLm9wdGlvbnM7Zm9yKHZhciBkIGluIGMpYy5oYXNPd25Qcm9wZXJ0eShkKSYmKGIrPSc8bGkgcm9sZT1cXFwicHJlc2VudGF0aW9uXFxcIj48YSBjbGFzcz1cXFwiZnItY29tbWFuZCBmci10aXRsZVxcXCIgdGFiSW5kZXg9XFxcIi0xXFxcIiByb2xlPVxcXCJvcHRpb25cXFwiIGRhdGEtY21kPVxcXCJhbGlnblxcXCIgZGF0YS1wYXJhbTE9XFxcIicrZCsnXFxcIiB0aXRsZT1cXFwiJyt0aGlzLmxhbmd1YWdlLnRyYW5zbGF0ZShjW2RdKSsnXFxcIj4nK3RoaXMuaWNvbi5jcmVhdGUoXFxcImFsaWduLVxcXCIrZCkrJzxzcGFuIGNsYXNzPVxcXCJmci1zci1vbmx5XFxcIj4nK3RoaXMubGFuZ3VhZ2UudHJhbnNsYXRlKGNbZF0pK1xcXCI8L3NwYW4+PC9hPjwvbGk+XFxcIik7cmV0dXJuIGIrPVxcXCI8L3VsPlxcXCJ9LGNhbGxiYWNrOmZ1bmN0aW9uKGEsYil7dGhpcy5hbGlnbi5hcHBseShiKX0scmVmcmVzaDpmdW5jdGlvbihhKXt0aGlzLmFsaWduLnJlZnJlc2goYSl9LHJlZnJlc2hPblNob3c6ZnVuY3Rpb24oYSxiKXt0aGlzLmFsaWduLnJlZnJlc2hPblNob3coYSxiKX0scGx1Z2luOlxcXCJhbGlnblxcXCJ9KX0pO1wiXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3Jhdy1sb2FkZXIhLi9+L2Zyb2FsYS1lZGl0b3IvanMvcGx1Z2lucy9hbGlnbi5taW4uanNcbi8vIG1vZHVsZSBpZCA9IDlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQSIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	eval("__webpack_require__(2)(__webpack_require__(11))//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTAuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2Zyb2FsYS1lZGl0b3IvanMvcGx1Z2lucy9jaGFyX2NvdW50ZXIubWluLmpzPzc3YjEiXSwic291cmNlc0NvbnRlbnQiOlsicmVxdWlyZShcIiEhL3Zhci9hcHAvd2ViL2pzL25vZGVfbW9kdWxlcy9zY3JpcHQtbG9hZGVyL2FkZFNjcmlwdC5qc1wiKShyZXF1aXJlKFwiISEvdmFyL2FwcC93ZWIvanMvbm9kZV9tb2R1bGVzL3Jhdy1sb2FkZXIvaW5kZXguanMhL3Zhci9hcHAvd2ViL2pzL25vZGVfbW9kdWxlcy9mcm9hbGEtZWRpdG9yL2pzL3BsdWdpbnMvY2hhcl9jb3VudGVyLm1pbi5qc1wiKSlcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vc2NyaXB0LWxvYWRlciEuL34vZnJvYWxhLWVkaXRvci9qcy9wbHVnaW5zL2NoYXJfY291bnRlci5taW4uanNcbi8vIG1vZHVsZSBpZCA9IDEwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 11 */
/***/ function(module, exports) {

	eval("module.exports = \"/*!\\n * froala_editor v2.4.0 (https://www.froala.com/wysiwyg-editor)\\n * License https://froala.com/wysiwyg-editor/terms/\\n * Copyright 2014-2016 Froala Labs\\n */\\n\\n!function(a){\\\"function\\\"==typeof define&&define.amd?define([\\\"jquery\\\"],a):\\\"object\\\"==typeof module&&module.exports?module.exports=function(b,c){return void 0===c&&(c=\\\"undefined\\\"!=typeof window?require(\\\"jquery\\\"):require(\\\"jquery\\\")(b)),a(c),c}:a(jQuery)}(function(a){a.extend(a.FE.DEFAULTS,{charCounterMax:-1,charCounterCount:!0}),a.FE.PLUGINS.charCounter=function(b){function c(){return b.el.textContent.length}function d(a){if(b.opts.charCounterMax<0)return!0;if(c()<b.opts.charCounterMax)return!0;var d=a.which;return!(!b.keys.ctrlKey(a)&&b.keys.isCharacter(d))||(a.preventDefault(),a.stopPropagation(),b.events.trigger(\\\"charCounter.exceeded\\\"),!1)}function e(d){if(b.opts.charCounterMax<0)return d;var e=a(\\\"<div>\\\").html(d).text().length;return e+c()<=b.opts.charCounterMax?d:(b.events.trigger(\\\"charCounter.exceeded\\\"),\\\"\\\")}function f(){if(b.opts.charCounterCount){var a=c()+(b.opts.charCounterMax>0?\\\"/\\\"+b.opts.charCounterMax:\\\"\\\");h.text(a),b.opts.toolbarBottom&&h.css(\\\"margin-bottom\\\",b.$tb.outerHeight(!0));var d=b.$wp.get(0).offsetWidth-b.$wp.get(0).clientWidth;d>=0&&(\\\"rtl\\\"==b.opts.direction?h.css(\\\"margin-left\\\",d):h.css(\\\"margin-right\\\",d))}}function g(){return!!b.$wp&&(!!b.opts.charCounterCount&&(h=a('<span class=\\\"fr-counter\\\"></span>'),h.css(\\\"bottom\\\",b.$wp.css(\\\"border-bottom-width\\\")),b.$box.append(h),b.events.on(\\\"keydown\\\",d,!0),b.events.on(\\\"paste.afterCleanup\\\",e),b.events.on(\\\"keyup contentChanged input\\\",function(){b.events.trigger(\\\"charCounter.update\\\")}),b.events.on(\\\"charCounter.update\\\",f),b.events.trigger(\\\"charCounter.update\\\"),void b.events.on(\\\"destroy\\\",function(){a(b.o_win).off(\\\"resize.char\\\"+b.id),h.removeData().remove(),h=null})))}var h;return{_init:g,count:c}}});\"//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTEuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2Zyb2FsYS1lZGl0b3IvanMvcGx1Z2lucy9jaGFyX2NvdW50ZXIubWluLmpzPzUwMWQiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBcIi8qIVxcbiAqIGZyb2FsYV9lZGl0b3IgdjIuNC4wIChodHRwczovL3d3dy5mcm9hbGEuY29tL3d5c2l3eWctZWRpdG9yKVxcbiAqIExpY2Vuc2UgaHR0cHM6Ly9mcm9hbGEuY29tL3d5c2l3eWctZWRpdG9yL3Rlcm1zL1xcbiAqIENvcHlyaWdodCAyMDE0LTIwMTYgRnJvYWxhIExhYnNcXG4gKi9cXG5cXG4hZnVuY3Rpb24oYSl7XFxcImZ1bmN0aW9uXFxcIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUoW1xcXCJqcXVlcnlcXFwiXSxhKTpcXFwib2JqZWN0XFxcIj09dHlwZW9mIG1vZHVsZSYmbW9kdWxlLmV4cG9ydHM/bW9kdWxlLmV4cG9ydHM9ZnVuY3Rpb24oYixjKXtyZXR1cm4gdm9pZCAwPT09YyYmKGM9XFxcInVuZGVmaW5lZFxcXCIhPXR5cGVvZiB3aW5kb3c/cmVxdWlyZShcXFwianF1ZXJ5XFxcIik6cmVxdWlyZShcXFwianF1ZXJ5XFxcIikoYikpLGEoYyksY306YShqUXVlcnkpfShmdW5jdGlvbihhKXthLmV4dGVuZChhLkZFLkRFRkFVTFRTLHtjaGFyQ291bnRlck1heDotMSxjaGFyQ291bnRlckNvdW50OiEwfSksYS5GRS5QTFVHSU5TLmNoYXJDb3VudGVyPWZ1bmN0aW9uKGIpe2Z1bmN0aW9uIGMoKXtyZXR1cm4gYi5lbC50ZXh0Q29udGVudC5sZW5ndGh9ZnVuY3Rpb24gZChhKXtpZihiLm9wdHMuY2hhckNvdW50ZXJNYXg8MClyZXR1cm4hMDtpZihjKCk8Yi5vcHRzLmNoYXJDb3VudGVyTWF4KXJldHVybiEwO3ZhciBkPWEud2hpY2g7cmV0dXJuISghYi5rZXlzLmN0cmxLZXkoYSkmJmIua2V5cy5pc0NoYXJhY3RlcihkKSl8fChhLnByZXZlbnREZWZhdWx0KCksYS5zdG9wUHJvcGFnYXRpb24oKSxiLmV2ZW50cy50cmlnZ2VyKFxcXCJjaGFyQ291bnRlci5leGNlZWRlZFxcXCIpLCExKX1mdW5jdGlvbiBlKGQpe2lmKGIub3B0cy5jaGFyQ291bnRlck1heDwwKXJldHVybiBkO3ZhciBlPWEoXFxcIjxkaXY+XFxcIikuaHRtbChkKS50ZXh0KCkubGVuZ3RoO3JldHVybiBlK2MoKTw9Yi5vcHRzLmNoYXJDb3VudGVyTWF4P2Q6KGIuZXZlbnRzLnRyaWdnZXIoXFxcImNoYXJDb3VudGVyLmV4Y2VlZGVkXFxcIiksXFxcIlxcXCIpfWZ1bmN0aW9uIGYoKXtpZihiLm9wdHMuY2hhckNvdW50ZXJDb3VudCl7dmFyIGE9YygpKyhiLm9wdHMuY2hhckNvdW50ZXJNYXg+MD9cXFwiL1xcXCIrYi5vcHRzLmNoYXJDb3VudGVyTWF4OlxcXCJcXFwiKTtoLnRleHQoYSksYi5vcHRzLnRvb2xiYXJCb3R0b20mJmguY3NzKFxcXCJtYXJnaW4tYm90dG9tXFxcIixiLiR0Yi5vdXRlckhlaWdodCghMCkpO3ZhciBkPWIuJHdwLmdldCgwKS5vZmZzZXRXaWR0aC1iLiR3cC5nZXQoMCkuY2xpZW50V2lkdGg7ZD49MCYmKFxcXCJydGxcXFwiPT1iLm9wdHMuZGlyZWN0aW9uP2guY3NzKFxcXCJtYXJnaW4tbGVmdFxcXCIsZCk6aC5jc3MoXFxcIm1hcmdpbi1yaWdodFxcXCIsZCkpfX1mdW5jdGlvbiBnKCl7cmV0dXJuISFiLiR3cCYmKCEhYi5vcHRzLmNoYXJDb3VudGVyQ291bnQmJihoPWEoJzxzcGFuIGNsYXNzPVxcXCJmci1jb3VudGVyXFxcIj48L3NwYW4+JyksaC5jc3MoXFxcImJvdHRvbVxcXCIsYi4kd3AuY3NzKFxcXCJib3JkZXItYm90dG9tLXdpZHRoXFxcIikpLGIuJGJveC5hcHBlbmQoaCksYi5ldmVudHMub24oXFxcImtleWRvd25cXFwiLGQsITApLGIuZXZlbnRzLm9uKFxcXCJwYXN0ZS5hZnRlckNsZWFudXBcXFwiLGUpLGIuZXZlbnRzLm9uKFxcXCJrZXl1cCBjb250ZW50Q2hhbmdlZCBpbnB1dFxcXCIsZnVuY3Rpb24oKXtiLmV2ZW50cy50cmlnZ2VyKFxcXCJjaGFyQ291bnRlci51cGRhdGVcXFwiKX0pLGIuZXZlbnRzLm9uKFxcXCJjaGFyQ291bnRlci51cGRhdGVcXFwiLGYpLGIuZXZlbnRzLnRyaWdnZXIoXFxcImNoYXJDb3VudGVyLnVwZGF0ZVxcXCIpLHZvaWQgYi5ldmVudHMub24oXFxcImRlc3Ryb3lcXFwiLGZ1bmN0aW9uKCl7YShiLm9fd2luKS5vZmYoXFxcInJlc2l6ZS5jaGFyXFxcIitiLmlkKSxoLnJlbW92ZURhdGEoKS5yZW1vdmUoKSxoPW51bGx9KSkpfXZhciBoO3JldHVybntfaW5pdDpnLGNvdW50OmN9fX0pO1wiXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3Jhdy1sb2FkZXIhLi9+L2Zyb2FsYS1lZGl0b3IvanMvcGx1Z2lucy9jaGFyX2NvdW50ZXIubWluLmpzXG4vLyBtb2R1bGUgaWQgPSAxMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	eval("__webpack_require__(2)(__webpack_require__(13))//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTIuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2Zyb2FsYS1lZGl0b3IvanMvcGx1Z2lucy9jb2RlX3ZpZXcubWluLmpzPzljNWIiXSwic291cmNlc0NvbnRlbnQiOlsicmVxdWlyZShcIiEhL3Zhci9hcHAvd2ViL2pzL25vZGVfbW9kdWxlcy9zY3JpcHQtbG9hZGVyL2FkZFNjcmlwdC5qc1wiKShyZXF1aXJlKFwiISEvdmFyL2FwcC93ZWIvanMvbm9kZV9tb2R1bGVzL3Jhdy1sb2FkZXIvaW5kZXguanMhL3Zhci9hcHAvd2ViL2pzL25vZGVfbW9kdWxlcy9mcm9hbGEtZWRpdG9yL2pzL3BsdWdpbnMvY29kZV92aWV3Lm1pbi5qc1wiKSlcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vc2NyaXB0LWxvYWRlciEuL34vZnJvYWxhLWVkaXRvci9qcy9wbHVnaW5zL2NvZGVfdmlldy5taW4uanNcbi8vIG1vZHVsZSBpZCA9IDEyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 13 */
/***/ function(module, exports) {

	eval("module.exports = \"/*!\\n * froala_editor v2.4.0 (https://www.froala.com/wysiwyg-editor)\\n * License https://froala.com/wysiwyg-editor/terms/\\n * Copyright 2014-2016 Froala Labs\\n */\\n\\n!function(a){\\\"function\\\"==typeof define&&define.amd?define([\\\"jquery\\\"],a):\\\"object\\\"==typeof module&&module.exports?module.exports=function(b,c){return void 0===c&&(c=\\\"undefined\\\"!=typeof window?require(\\\"jquery\\\"):require(\\\"jquery\\\")(b)),a(c),c}:a(jQuery)}(function(a){a.extend(a.FE.DEFAULTS,{codeMirror:!0,codeMirrorOptions:{lineNumbers:!0,tabMode:\\\"indent\\\",indentWithTabs:!0,lineWrapping:!0,mode:\\\"text/html\\\",tabSize:2},codeBeautifierOptions:{end_with_newline:!0,indent_inner_html:!0,extra_liners:[\\\"p\\\",\\\"h1\\\",\\\"h2\\\",\\\"h3\\\",\\\"h4\\\",\\\"h5\\\",\\\"h6\\\",\\\"blockquote\\\",\\\"pre\\\",\\\"ul\\\",\\\"ol\\\",\\\"table\\\",\\\"dl\\\"],brace_style:\\\"expand\\\",indent_char:\\\"\\\\t\\\",indent_size:1,wrap_line_length:0},codeViewKeepActiveButtons:[\\\"fullscreen\\\"]}),a.FE.PLUGINS.codeView=function(b){function c(){return b.$box.hasClass(\\\"fr-code-view\\\")}function d(){return l?l.getValue():k.val()}function e(a){var c=d();b.html.set(c),b.$el.blur(),b.$tb.find(\\\" > .fr-command\\\").not(a).removeClass(\\\"fr-disabled\\\").attr(\\\"aria-disabled\\\",!1),a.removeClass(\\\"fr-active\\\").attr(\\\"aria-pressed\\\",!1),b.events.focus(!0),b.placeholder.refresh(),b.undo.saveStep()}function f(c){k||(i(),!l&&b.opts.codeMirror&&\\\"undefined\\\"!=typeof CodeMirror?l=CodeMirror.fromTextArea(k.get(0),b.opts.codeMirrorOptions):b.events.$on(k,\\\"keydown keyup change input\\\",function(){if(b.opts.height)this.rows=null;else if(this.rows||(this.rows=1),0===this.value.length)this.rows=1;else{for(this.style.height=\\\"auto\\\";this.rows>1&&this.scrollHeight<=this.offsetHeight;)this.rows-=1;for(;this.scrollHeight>this.offsetHeight&&(!b.opts.heightMax||this.offsetHeight<b.opts.heightMax);)this.rows+=1}})),b.undo.saveStep(),b.html.cleanEmptyTags(),b.html.cleanWhiteTags(!0),b.core.hasFocus()&&(b.core.isEmpty()||(b.selection.save(),b.$el.find('.fr-marker[data-type=\\\"true\\\"]:first').replaceWith('<span class=\\\"fr-tmp fr-sm\\\">F</span>'),b.$el.find('.fr-marker[data-type=\\\"false\\\"]:last').replaceWith('<span class=\\\"fr-tmp fr-em\\\">F</span>')));var d=b.html.get(!1,!0);b.$el.find(\\\"span.fr-tmp\\\").remove(),b.$box.toggleClass(\\\"fr-code-view\\\",!0),b.core.hasFocus()&&b.$el.blur(),d=d.replace(/<span class=\\\"fr-tmp fr-sm\\\">F<\\\\/span>/,\\\"FROALA-SM\\\"),d=d.replace(/<span class=\\\"fr-tmp fr-em\\\">F<\\\\/span>/,\\\"FROALA-EM\\\"),b.codeBeautifier&&(d=b.codeBeautifier.run(d,b.opts.codeBeautifierOptions));var e,f;if(l){e=d.indexOf(\\\"FROALA-SM\\\"),f=d.indexOf(\\\"FROALA-EM\\\"),e>f?e=f:f-=9,d=d.replace(/FROALA-SM/g,\\\"\\\").replace(/FROALA-EM/g,\\\"\\\");var g=d.substring(0,e).length-d.substring(0,e).replace(/\\\\n/g,\\\"\\\").length,h=d.substring(0,f).length-d.substring(0,f).replace(/\\\\n/g,\\\"\\\").length;e=d.substring(0,e).length-d.substring(0,d.substring(0,e).lastIndexOf(\\\"\\\\n\\\")+1).length,f=d.substring(0,f).length-d.substring(0,d.substring(0,f).lastIndexOf(\\\"\\\\n\\\")+1).length,l.setSize(null,b.opts.height?b.opts.height:\\\"auto\\\"),b.opts.heightMin&&b.$box.find(\\\".CodeMirror-scroll\\\").css(\\\"min-height\\\",b.opts.heightMin),l.setValue(d),l.focus(),l.setSelection({line:g,ch:e},{line:h,ch:f}),l.refresh(),l.clearHistory()}else{e=d.indexOf(\\\"FROALA-SM\\\"),f=d.indexOf(\\\"FROALA-EM\\\")-9,b.opts.heightMin&&k.css(\\\"min-height\\\",b.opts.heightMin),b.opts.height&&k.css(\\\"height\\\",b.opts.height),b.opts.heightMax&&k.css(\\\"max-height\\\",b.opts.height||b.opts.heightMax),k.val(d.replace(/FROALA-SM/g,\\\"\\\").replace(/FROALA-EM/g,\\\"\\\")).trigger(\\\"change\\\");var j=a(b.o_doc).scrollTop();k.focus(),k.get(0).setSelectionRange(e,f),a(b.o_doc).scrollTop(j)}b.$tb.find(\\\" > .fr-command\\\").not(c).filter(function(){return b.opts.codeViewKeepActiveButtons.indexOf(a(this).data(\\\"cmd\\\"))<0}).addClass(\\\"fr-disabled\\\").attr(\\\"aria-disabled\\\",!0),c.addClass(\\\"fr-active\\\").attr(\\\"aria-pressed\\\",!0),!b.helpers.isMobile()&&b.opts.toolbarInline&&b.toolbar.hide()}function g(a){\\\"undefined\\\"==typeof a&&(a=!c());var d=b.$tb.find('.fr-command[data-cmd=\\\"html\\\"]');a?(b.popups.hideAll(),f(d)):(b.$box.toggleClass(\\\"fr-code-view\\\",!1),e(d))}function h(){c()&&g(b.$tb.find('button[data-cmd=\\\"html\\\"]')),l&&l.toTextArea(),k.val(\\\"\\\").removeData().remove(),k=null,m&&(m.remove(),m=null)}function i(){k=a('<textarea class=\\\"fr-code\\\" tabIndex=\\\"-1\\\">'),b.$wp.append(k),k.attr(\\\"dir\\\",b.opts.direction),b.$box.hasClass(\\\"fr-basic\\\")||(m=a('<a data-cmd=\\\"html\\\" title=\\\"Code View\\\" class=\\\"fr-command fr-btn html-switch'+(b.helpers.isMobile()?\\\"\\\":\\\" fr-desktop\\\")+'\\\" role=\\\"button\\\" tabIndex=\\\"-1\\\"><i class=\\\"fa fa-code\\\"></i></button>'),b.$box.append(m),b.events.bindClick(b.$box,\\\"a.html-switch\\\",function(){g(!1)}));var e=function(){return!c()};b.events.on(\\\"buttons.refresh\\\",e),b.events.on(\\\"copy\\\",e,!0),b.events.on(\\\"cut\\\",e,!0),b.events.on(\\\"paste\\\",e,!0),b.events.on(\\\"destroy\\\",h,!0),b.events.on(\\\"html.set\\\",function(){c()&&g(!0)}),b.events.on(\\\"form.submit\\\",function(){c()&&(b.html.set(d()),b.events.trigger(\\\"contentChanged\\\",[],!0))},!0)}function j(){if(!b.$wp)return!1}var k,l,m;return{_init:j,toggle:g,isActive:c,get:d}},a.FE.RegisterCommand(\\\"html\\\",{title:\\\"Code View\\\",undo:!1,focus:!1,forcedRefresh:!0,toggle:!0,callback:function(){this.codeView.toggle()},plugin:\\\"codeView\\\"}),a.FE.DefineIcon(\\\"html\\\",{NAME:\\\"code\\\"})});\"//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2Zyb2FsYS1lZGl0b3IvanMvcGx1Z2lucy9jb2RlX3ZpZXcubWluLmpzPzg0ZjMiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBcIi8qIVxcbiAqIGZyb2FsYV9lZGl0b3IgdjIuNC4wIChodHRwczovL3d3dy5mcm9hbGEuY29tL3d5c2l3eWctZWRpdG9yKVxcbiAqIExpY2Vuc2UgaHR0cHM6Ly9mcm9hbGEuY29tL3d5c2l3eWctZWRpdG9yL3Rlcm1zL1xcbiAqIENvcHlyaWdodCAyMDE0LTIwMTYgRnJvYWxhIExhYnNcXG4gKi9cXG5cXG4hZnVuY3Rpb24oYSl7XFxcImZ1bmN0aW9uXFxcIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUoW1xcXCJqcXVlcnlcXFwiXSxhKTpcXFwib2JqZWN0XFxcIj09dHlwZW9mIG1vZHVsZSYmbW9kdWxlLmV4cG9ydHM/bW9kdWxlLmV4cG9ydHM9ZnVuY3Rpb24oYixjKXtyZXR1cm4gdm9pZCAwPT09YyYmKGM9XFxcInVuZGVmaW5lZFxcXCIhPXR5cGVvZiB3aW5kb3c/cmVxdWlyZShcXFwianF1ZXJ5XFxcIik6cmVxdWlyZShcXFwianF1ZXJ5XFxcIikoYikpLGEoYyksY306YShqUXVlcnkpfShmdW5jdGlvbihhKXthLmV4dGVuZChhLkZFLkRFRkFVTFRTLHtjb2RlTWlycm9yOiEwLGNvZGVNaXJyb3JPcHRpb25zOntsaW5lTnVtYmVyczohMCx0YWJNb2RlOlxcXCJpbmRlbnRcXFwiLGluZGVudFdpdGhUYWJzOiEwLGxpbmVXcmFwcGluZzohMCxtb2RlOlxcXCJ0ZXh0L2h0bWxcXFwiLHRhYlNpemU6Mn0sY29kZUJlYXV0aWZpZXJPcHRpb25zOntlbmRfd2l0aF9uZXdsaW5lOiEwLGluZGVudF9pbm5lcl9odG1sOiEwLGV4dHJhX2xpbmVyczpbXFxcInBcXFwiLFxcXCJoMVxcXCIsXFxcImgyXFxcIixcXFwiaDNcXFwiLFxcXCJoNFxcXCIsXFxcImg1XFxcIixcXFwiaDZcXFwiLFxcXCJibG9ja3F1b3RlXFxcIixcXFwicHJlXFxcIixcXFwidWxcXFwiLFxcXCJvbFxcXCIsXFxcInRhYmxlXFxcIixcXFwiZGxcXFwiXSxicmFjZV9zdHlsZTpcXFwiZXhwYW5kXFxcIixpbmRlbnRfY2hhcjpcXFwiXFxcXHRcXFwiLGluZGVudF9zaXplOjEsd3JhcF9saW5lX2xlbmd0aDowfSxjb2RlVmlld0tlZXBBY3RpdmVCdXR0b25zOltcXFwiZnVsbHNjcmVlblxcXCJdfSksYS5GRS5QTFVHSU5TLmNvZGVWaWV3PWZ1bmN0aW9uKGIpe2Z1bmN0aW9uIGMoKXtyZXR1cm4gYi4kYm94Lmhhc0NsYXNzKFxcXCJmci1jb2RlLXZpZXdcXFwiKX1mdW5jdGlvbiBkKCl7cmV0dXJuIGw/bC5nZXRWYWx1ZSgpOmsudmFsKCl9ZnVuY3Rpb24gZShhKXt2YXIgYz1kKCk7Yi5odG1sLnNldChjKSxiLiRlbC5ibHVyKCksYi4kdGIuZmluZChcXFwiID4gLmZyLWNvbW1hbmRcXFwiKS5ub3QoYSkucmVtb3ZlQ2xhc3MoXFxcImZyLWRpc2FibGVkXFxcIikuYXR0cihcXFwiYXJpYS1kaXNhYmxlZFxcXCIsITEpLGEucmVtb3ZlQ2xhc3MoXFxcImZyLWFjdGl2ZVxcXCIpLmF0dHIoXFxcImFyaWEtcHJlc3NlZFxcXCIsITEpLGIuZXZlbnRzLmZvY3VzKCEwKSxiLnBsYWNlaG9sZGVyLnJlZnJlc2goKSxiLnVuZG8uc2F2ZVN0ZXAoKX1mdW5jdGlvbiBmKGMpe2t8fChpKCksIWwmJmIub3B0cy5jb2RlTWlycm9yJiZcXFwidW5kZWZpbmVkXFxcIiE9dHlwZW9mIENvZGVNaXJyb3I/bD1Db2RlTWlycm9yLmZyb21UZXh0QXJlYShrLmdldCgwKSxiLm9wdHMuY29kZU1pcnJvck9wdGlvbnMpOmIuZXZlbnRzLiRvbihrLFxcXCJrZXlkb3duIGtleXVwIGNoYW5nZSBpbnB1dFxcXCIsZnVuY3Rpb24oKXtpZihiLm9wdHMuaGVpZ2h0KXRoaXMucm93cz1udWxsO2Vsc2UgaWYodGhpcy5yb3dzfHwodGhpcy5yb3dzPTEpLDA9PT10aGlzLnZhbHVlLmxlbmd0aCl0aGlzLnJvd3M9MTtlbHNle2Zvcih0aGlzLnN0eWxlLmhlaWdodD1cXFwiYXV0b1xcXCI7dGhpcy5yb3dzPjEmJnRoaXMuc2Nyb2xsSGVpZ2h0PD10aGlzLm9mZnNldEhlaWdodDspdGhpcy5yb3dzLT0xO2Zvcig7dGhpcy5zY3JvbGxIZWlnaHQ+dGhpcy5vZmZzZXRIZWlnaHQmJighYi5vcHRzLmhlaWdodE1heHx8dGhpcy5vZmZzZXRIZWlnaHQ8Yi5vcHRzLmhlaWdodE1heCk7KXRoaXMucm93cys9MX19KSksYi51bmRvLnNhdmVTdGVwKCksYi5odG1sLmNsZWFuRW1wdHlUYWdzKCksYi5odG1sLmNsZWFuV2hpdGVUYWdzKCEwKSxiLmNvcmUuaGFzRm9jdXMoKSYmKGIuY29yZS5pc0VtcHR5KCl8fChiLnNlbGVjdGlvbi5zYXZlKCksYi4kZWwuZmluZCgnLmZyLW1hcmtlcltkYXRhLXR5cGU9XFxcInRydWVcXFwiXTpmaXJzdCcpLnJlcGxhY2VXaXRoKCc8c3BhbiBjbGFzcz1cXFwiZnItdG1wIGZyLXNtXFxcIj5GPC9zcGFuPicpLGIuJGVsLmZpbmQoJy5mci1tYXJrZXJbZGF0YS10eXBlPVxcXCJmYWxzZVxcXCJdOmxhc3QnKS5yZXBsYWNlV2l0aCgnPHNwYW4gY2xhc3M9XFxcImZyLXRtcCBmci1lbVxcXCI+Rjwvc3Bhbj4nKSkpO3ZhciBkPWIuaHRtbC5nZXQoITEsITApO2IuJGVsLmZpbmQoXFxcInNwYW4uZnItdG1wXFxcIikucmVtb3ZlKCksYi4kYm94LnRvZ2dsZUNsYXNzKFxcXCJmci1jb2RlLXZpZXdcXFwiLCEwKSxiLmNvcmUuaGFzRm9jdXMoKSYmYi4kZWwuYmx1cigpLGQ9ZC5yZXBsYWNlKC88c3BhbiBjbGFzcz1cXFwiZnItdG1wIGZyLXNtXFxcIj5GPFxcXFwvc3Bhbj4vLFxcXCJGUk9BTEEtU01cXFwiKSxkPWQucmVwbGFjZSgvPHNwYW4gY2xhc3M9XFxcImZyLXRtcCBmci1lbVxcXCI+RjxcXFxcL3NwYW4+LyxcXFwiRlJPQUxBLUVNXFxcIiksYi5jb2RlQmVhdXRpZmllciYmKGQ9Yi5jb2RlQmVhdXRpZmllci5ydW4oZCxiLm9wdHMuY29kZUJlYXV0aWZpZXJPcHRpb25zKSk7dmFyIGUsZjtpZihsKXtlPWQuaW5kZXhPZihcXFwiRlJPQUxBLVNNXFxcIiksZj1kLmluZGV4T2YoXFxcIkZST0FMQS1FTVxcXCIpLGU+Zj9lPWY6Zi09OSxkPWQucmVwbGFjZSgvRlJPQUxBLVNNL2csXFxcIlxcXCIpLnJlcGxhY2UoL0ZST0FMQS1FTS9nLFxcXCJcXFwiKTt2YXIgZz1kLnN1YnN0cmluZygwLGUpLmxlbmd0aC1kLnN1YnN0cmluZygwLGUpLnJlcGxhY2UoL1xcXFxuL2csXFxcIlxcXCIpLmxlbmd0aCxoPWQuc3Vic3RyaW5nKDAsZikubGVuZ3RoLWQuc3Vic3RyaW5nKDAsZikucmVwbGFjZSgvXFxcXG4vZyxcXFwiXFxcIikubGVuZ3RoO2U9ZC5zdWJzdHJpbmcoMCxlKS5sZW5ndGgtZC5zdWJzdHJpbmcoMCxkLnN1YnN0cmluZygwLGUpLmxhc3RJbmRleE9mKFxcXCJcXFxcblxcXCIpKzEpLmxlbmd0aCxmPWQuc3Vic3RyaW5nKDAsZikubGVuZ3RoLWQuc3Vic3RyaW5nKDAsZC5zdWJzdHJpbmcoMCxmKS5sYXN0SW5kZXhPZihcXFwiXFxcXG5cXFwiKSsxKS5sZW5ndGgsbC5zZXRTaXplKG51bGwsYi5vcHRzLmhlaWdodD9iLm9wdHMuaGVpZ2h0OlxcXCJhdXRvXFxcIiksYi5vcHRzLmhlaWdodE1pbiYmYi4kYm94LmZpbmQoXFxcIi5Db2RlTWlycm9yLXNjcm9sbFxcXCIpLmNzcyhcXFwibWluLWhlaWdodFxcXCIsYi5vcHRzLmhlaWdodE1pbiksbC5zZXRWYWx1ZShkKSxsLmZvY3VzKCksbC5zZXRTZWxlY3Rpb24oe2xpbmU6ZyxjaDplfSx7bGluZTpoLGNoOmZ9KSxsLnJlZnJlc2goKSxsLmNsZWFySGlzdG9yeSgpfWVsc2V7ZT1kLmluZGV4T2YoXFxcIkZST0FMQS1TTVxcXCIpLGY9ZC5pbmRleE9mKFxcXCJGUk9BTEEtRU1cXFwiKS05LGIub3B0cy5oZWlnaHRNaW4mJmsuY3NzKFxcXCJtaW4taGVpZ2h0XFxcIixiLm9wdHMuaGVpZ2h0TWluKSxiLm9wdHMuaGVpZ2h0JiZrLmNzcyhcXFwiaGVpZ2h0XFxcIixiLm9wdHMuaGVpZ2h0KSxiLm9wdHMuaGVpZ2h0TWF4JiZrLmNzcyhcXFwibWF4LWhlaWdodFxcXCIsYi5vcHRzLmhlaWdodHx8Yi5vcHRzLmhlaWdodE1heCksay52YWwoZC5yZXBsYWNlKC9GUk9BTEEtU00vZyxcXFwiXFxcIikucmVwbGFjZSgvRlJPQUxBLUVNL2csXFxcIlxcXCIpKS50cmlnZ2VyKFxcXCJjaGFuZ2VcXFwiKTt2YXIgaj1hKGIub19kb2MpLnNjcm9sbFRvcCgpO2suZm9jdXMoKSxrLmdldCgwKS5zZXRTZWxlY3Rpb25SYW5nZShlLGYpLGEoYi5vX2RvYykuc2Nyb2xsVG9wKGopfWIuJHRiLmZpbmQoXFxcIiA+IC5mci1jb21tYW5kXFxcIikubm90KGMpLmZpbHRlcihmdW5jdGlvbigpe3JldHVybiBiLm9wdHMuY29kZVZpZXdLZWVwQWN0aXZlQnV0dG9ucy5pbmRleE9mKGEodGhpcykuZGF0YShcXFwiY21kXFxcIikpPDB9KS5hZGRDbGFzcyhcXFwiZnItZGlzYWJsZWRcXFwiKS5hdHRyKFxcXCJhcmlhLWRpc2FibGVkXFxcIiwhMCksYy5hZGRDbGFzcyhcXFwiZnItYWN0aXZlXFxcIikuYXR0cihcXFwiYXJpYS1wcmVzc2VkXFxcIiwhMCksIWIuaGVscGVycy5pc01vYmlsZSgpJiZiLm9wdHMudG9vbGJhcklubGluZSYmYi50b29sYmFyLmhpZGUoKX1mdW5jdGlvbiBnKGEpe1xcXCJ1bmRlZmluZWRcXFwiPT10eXBlb2YgYSYmKGE9IWMoKSk7dmFyIGQ9Yi4kdGIuZmluZCgnLmZyLWNvbW1hbmRbZGF0YS1jbWQ9XFxcImh0bWxcXFwiXScpO2E/KGIucG9wdXBzLmhpZGVBbGwoKSxmKGQpKTooYi4kYm94LnRvZ2dsZUNsYXNzKFxcXCJmci1jb2RlLXZpZXdcXFwiLCExKSxlKGQpKX1mdW5jdGlvbiBoKCl7YygpJiZnKGIuJHRiLmZpbmQoJ2J1dHRvbltkYXRhLWNtZD1cXFwiaHRtbFxcXCJdJykpLGwmJmwudG9UZXh0QXJlYSgpLGsudmFsKFxcXCJcXFwiKS5yZW1vdmVEYXRhKCkucmVtb3ZlKCksaz1udWxsLG0mJihtLnJlbW92ZSgpLG09bnVsbCl9ZnVuY3Rpb24gaSgpe2s9YSgnPHRleHRhcmVhIGNsYXNzPVxcXCJmci1jb2RlXFxcIiB0YWJJbmRleD1cXFwiLTFcXFwiPicpLGIuJHdwLmFwcGVuZChrKSxrLmF0dHIoXFxcImRpclxcXCIsYi5vcHRzLmRpcmVjdGlvbiksYi4kYm94Lmhhc0NsYXNzKFxcXCJmci1iYXNpY1xcXCIpfHwobT1hKCc8YSBkYXRhLWNtZD1cXFwiaHRtbFxcXCIgdGl0bGU9XFxcIkNvZGUgVmlld1xcXCIgY2xhc3M9XFxcImZyLWNvbW1hbmQgZnItYnRuIGh0bWwtc3dpdGNoJysoYi5oZWxwZXJzLmlzTW9iaWxlKCk/XFxcIlxcXCI6XFxcIiBmci1kZXNrdG9wXFxcIikrJ1xcXCIgcm9sZT1cXFwiYnV0dG9uXFxcIiB0YWJJbmRleD1cXFwiLTFcXFwiPjxpIGNsYXNzPVxcXCJmYSBmYS1jb2RlXFxcIj48L2k+PC9idXR0b24+JyksYi4kYm94LmFwcGVuZChtKSxiLmV2ZW50cy5iaW5kQ2xpY2soYi4kYm94LFxcXCJhLmh0bWwtc3dpdGNoXFxcIixmdW5jdGlvbigpe2coITEpfSkpO3ZhciBlPWZ1bmN0aW9uKCl7cmV0dXJuIWMoKX07Yi5ldmVudHMub24oXFxcImJ1dHRvbnMucmVmcmVzaFxcXCIsZSksYi5ldmVudHMub24oXFxcImNvcHlcXFwiLGUsITApLGIuZXZlbnRzLm9uKFxcXCJjdXRcXFwiLGUsITApLGIuZXZlbnRzLm9uKFxcXCJwYXN0ZVxcXCIsZSwhMCksYi5ldmVudHMub24oXFxcImRlc3Ryb3lcXFwiLGgsITApLGIuZXZlbnRzLm9uKFxcXCJodG1sLnNldFxcXCIsZnVuY3Rpb24oKXtjKCkmJmcoITApfSksYi5ldmVudHMub24oXFxcImZvcm0uc3VibWl0XFxcIixmdW5jdGlvbigpe2MoKSYmKGIuaHRtbC5zZXQoZCgpKSxiLmV2ZW50cy50cmlnZ2VyKFxcXCJjb250ZW50Q2hhbmdlZFxcXCIsW10sITApKX0sITApfWZ1bmN0aW9uIGooKXtpZighYi4kd3ApcmV0dXJuITF9dmFyIGssbCxtO3JldHVybntfaW5pdDpqLHRvZ2dsZTpnLGlzQWN0aXZlOmMsZ2V0OmR9fSxhLkZFLlJlZ2lzdGVyQ29tbWFuZChcXFwiaHRtbFxcXCIse3RpdGxlOlxcXCJDb2RlIFZpZXdcXFwiLHVuZG86ITEsZm9jdXM6ITEsZm9yY2VkUmVmcmVzaDohMCx0b2dnbGU6ITAsY2FsbGJhY2s6ZnVuY3Rpb24oKXt0aGlzLmNvZGVWaWV3LnRvZ2dsZSgpfSxwbHVnaW46XFxcImNvZGVWaWV3XFxcIn0pLGEuRkUuRGVmaW5lSWNvbihcXFwiaHRtbFxcXCIse05BTUU6XFxcImNvZGVcXFwifSl9KTtcIlxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yYXctbG9hZGVyIS4vfi9mcm9hbGEtZWRpdG9yL2pzL3BsdWdpbnMvY29kZV92aWV3Lm1pbi5qc1xuLy8gbW9kdWxlIGlkID0gMTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQSIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

	eval("__webpack_require__(2)(__webpack_require__(15))//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTQuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2Zyb2FsYS1lZGl0b3IvanMvcGx1Z2lucy9lbnRpdGllcy5taW4uanM/OTY4OCJdLCJzb3VyY2VzQ29udGVudCI6WyJyZXF1aXJlKFwiISEvdmFyL2FwcC93ZWIvanMvbm9kZV9tb2R1bGVzL3NjcmlwdC1sb2FkZXIvYWRkU2NyaXB0LmpzXCIpKHJlcXVpcmUoXCIhIS92YXIvYXBwL3dlYi9qcy9ub2RlX21vZHVsZXMvcmF3LWxvYWRlci9pbmRleC5qcyEvdmFyL2FwcC93ZWIvanMvbm9kZV9tb2R1bGVzL2Zyb2FsYS1lZGl0b3IvanMvcGx1Z2lucy9lbnRpdGllcy5taW4uanNcIikpXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3NjcmlwdC1sb2FkZXIhLi9+L2Zyb2FsYS1lZGl0b3IvanMvcGx1Z2lucy9lbnRpdGllcy5taW4uanNcbi8vIG1vZHVsZSBpZCA9IDE0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 15 */
/***/ function(module, exports) {

	eval("module.exports = \"/*!\\n * froala_editor v2.4.0 (https://www.froala.com/wysiwyg-editor)\\n * License https://froala.com/wysiwyg-editor/terms/\\n * Copyright 2014-2016 Froala Labs\\n */\\n\\n!function(a){\\\"function\\\"==typeof define&&define.amd?define([\\\"jquery\\\"],a):\\\"object\\\"==typeof module&&module.exports?module.exports=function(b,c){return void 0===c&&(c=\\\"undefined\\\"!=typeof window?require(\\\"jquery\\\"):require(\\\"jquery\\\")(b)),a(c),c}:a(jQuery)}(function(a){a.extend(a.FE.DEFAULTS,{entities:\\\"&quot;&#39;&iexcl;&cent;&pound;&curren;&yen;&brvbar;&sect;&uml;&copy;&ordf;&laquo;&not;&shy;&reg;&macr;&deg;&plusmn;&sup2;&sup3;&acute;&micro;&para;&middot;&cedil;&sup1;&ordm;&raquo;&frac14;&frac12;&frac34;&iquest;&Agrave;&Aacute;&Acirc;&Atilde;&Auml;&Aring;&AElig;&Ccedil;&Egrave;&Eacute;&Ecirc;&Euml;&Igrave;&Iacute;&Icirc;&Iuml;&ETH;&Ntilde;&Ograve;&Oacute;&Ocirc;&Otilde;&Ouml;&times;&Oslash;&Ugrave;&Uacute;&Ucirc;&Uuml;&Yacute;&THORN;&szlig;&agrave;&aacute;&acirc;&atilde;&auml;&aring;&aelig;&ccedil;&egrave;&eacute;&ecirc;&euml;&igrave;&iacute;&icirc;&iuml;&eth;&ntilde;&ograve;&oacute;&ocirc;&otilde;&ouml;&divide;&oslash;&ugrave;&uacute;&ucirc;&uuml;&yacute;&thorn;&yuml;&OElig;&oelig;&Scaron;&scaron;&Yuml;&fnof;&circ;&tilde;&Alpha;&Beta;&Gamma;&Delta;&Epsilon;&Zeta;&Eta;&Theta;&Iota;&Kappa;&Lambda;&Mu;&Nu;&Xi;&Omicron;&Pi;&Rho;&Sigma;&Tau;&Upsilon;&Phi;&Chi;&Psi;&Omega;&alpha;&beta;&gamma;&delta;&epsilon;&zeta;&eta;&theta;&iota;&kappa;&lambda;&mu;&nu;&xi;&omicron;&pi;&rho;&sigmaf;&sigma;&tau;&upsilon;&phi;&chi;&psi;&omega;&thetasym;&upsih;&piv;&ensp;&emsp;&thinsp;&zwnj;&zwj;&lrm;&rlm;&ndash;&mdash;&lsquo;&rsquo;&sbquo;&ldquo;&rdquo;&bdquo;&dagger;&Dagger;&bull;&hellip;&permil;&prime;&Prime;&lsaquo;&rsaquo;&oline;&frasl;&euro;&image;&weierp;&real;&trade;&alefsym;&larr;&uarr;&rarr;&darr;&harr;&crarr;&lArr;&uArr;&rArr;&dArr;&hArr;&forall;&part;&exist;&empty;&nabla;&isin;&notin;&ni;&prod;&sum;&minus;&lowast;&radic;&prop;&infin;&ang;&and;&or;&cap;&cup;&int;&there4;&sim;&cong;&asymp;&ne;&equiv;&le;&ge;&sub;&sup;&nsub;&sube;&supe;&oplus;&otimes;&perp;&sdot;&lceil;&rceil;&lfloor;&rfloor;&lang;&rang;&loz;&spades;&clubs;&hearts;&diams;\\\"}),a.FE.PLUGINS.entities=function(b){function c(a){var b=a.textContent;if(b.match(g)){for(var c=\\\"\\\",d=0;d<b.length;d++)c+=h[b[d]]?h[b[d]]:b[d];a.textContent=c}}function d(a){if(a&&[\\\"STYLE\\\",\\\"SCRIPT\\\",\\\"svg\\\"].indexOf(a.tagName)>=0)return!0;for(var e=b.node.contents(a),f=0;f<e.length;f++)e[f].nodeType==Node.TEXT_NODE?c(e[f]):d(e[f]);a.nodeType==Node.TEXT_NODE&&c(a)}function e(a){if(0===a.length)return\\\"\\\";var c=b.clean.exec(a,d).replace(/\\\\&amp;/g,\\\"&\\\");return c}function f(){b.opts.htmlSimpleAmpersand||(b.opts.entities=b.opts.entities+\\\"&amp;\\\");var c=a(\\\"<div>\\\").html(b.opts.entities).text(),d=b.opts.entities.split(\\\";\\\");h={},g=\\\"\\\";for(var f=0;f<c.length;f++){var i=c.charAt(f);h[i]=d[f]+\\\";\\\",g+=\\\"\\\\\\\\\\\"+i+(f<c.length-1?\\\"|\\\":\\\"\\\")}g=new RegExp(\\\"(\\\"+g+\\\")\\\",\\\"g\\\"),b.events.on(\\\"html.get\\\",e,!0)}var g,h;return{_init:f}}});\"//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTUuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2Zyb2FsYS1lZGl0b3IvanMvcGx1Z2lucy9lbnRpdGllcy5taW4uanM/ODViMiJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IFwiLyohXFxuICogZnJvYWxhX2VkaXRvciB2Mi40LjAgKGh0dHBzOi8vd3d3LmZyb2FsYS5jb20vd3lzaXd5Zy1lZGl0b3IpXFxuICogTGljZW5zZSBodHRwczovL2Zyb2FsYS5jb20vd3lzaXd5Zy1lZGl0b3IvdGVybXMvXFxuICogQ29weXJpZ2h0IDIwMTQtMjAxNiBGcm9hbGEgTGFic1xcbiAqL1xcblxcbiFmdW5jdGlvbihhKXtcXFwiZnVuY3Rpb25cXFwiPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZShbXFxcImpxdWVyeVxcXCJdLGEpOlxcXCJvYmplY3RcXFwiPT10eXBlb2YgbW9kdWxlJiZtb2R1bGUuZXhwb3J0cz9tb2R1bGUuZXhwb3J0cz1mdW5jdGlvbihiLGMpe3JldHVybiB2b2lkIDA9PT1jJiYoYz1cXFwidW5kZWZpbmVkXFxcIiE9dHlwZW9mIHdpbmRvdz9yZXF1aXJlKFxcXCJqcXVlcnlcXFwiKTpyZXF1aXJlKFxcXCJqcXVlcnlcXFwiKShiKSksYShjKSxjfTphKGpRdWVyeSl9KGZ1bmN0aW9uKGEpe2EuZXh0ZW5kKGEuRkUuREVGQVVMVFMse2VudGl0aWVzOlxcXCImcXVvdDsmIzM5OyZpZXhjbDsmY2VudDsmcG91bmQ7JmN1cnJlbjsmeWVuOyZicnZiYXI7JnNlY3Q7JnVtbDsmY29weTsmb3JkZjsmbGFxdW87Jm5vdDsmc2h5OyZyZWc7Jm1hY3I7JmRlZzsmcGx1c21uOyZzdXAyOyZzdXAzOyZhY3V0ZTsmbWljcm87JnBhcmE7Jm1pZGRvdDsmY2VkaWw7JnN1cDE7Jm9yZG07JnJhcXVvOyZmcmFjMTQ7JmZyYWMxMjsmZnJhYzM0OyZpcXVlc3Q7JkFncmF2ZTsmQWFjdXRlOyZBY2lyYzsmQXRpbGRlOyZBdW1sOyZBcmluZzsmQUVsaWc7JkNjZWRpbDsmRWdyYXZlOyZFYWN1dGU7JkVjaXJjOyZFdW1sOyZJZ3JhdmU7JklhY3V0ZTsmSWNpcmM7Jkl1bWw7JkVUSDsmTnRpbGRlOyZPZ3JhdmU7Jk9hY3V0ZTsmT2NpcmM7Jk90aWxkZTsmT3VtbDsmdGltZXM7Jk9zbGFzaDsmVWdyYXZlOyZVYWN1dGU7JlVjaXJjOyZVdW1sOyZZYWN1dGU7JlRIT1JOOyZzemxpZzsmYWdyYXZlOyZhYWN1dGU7JmFjaXJjOyZhdGlsZGU7JmF1bWw7JmFyaW5nOyZhZWxpZzsmY2NlZGlsOyZlZ3JhdmU7JmVhY3V0ZTsmZWNpcmM7JmV1bWw7JmlncmF2ZTsmaWFjdXRlOyZpY2lyYzsmaXVtbDsmZXRoOyZudGlsZGU7Jm9ncmF2ZTsmb2FjdXRlOyZvY2lyYzsmb3RpbGRlOyZvdW1sOyZkaXZpZGU7Jm9zbGFzaDsmdWdyYXZlOyZ1YWN1dGU7JnVjaXJjOyZ1dW1sOyZ5YWN1dGU7JnRob3JuOyZ5dW1sOyZPRWxpZzsmb2VsaWc7JlNjYXJvbjsmc2Nhcm9uOyZZdW1sOyZmbm9mOyZjaXJjOyZ0aWxkZTsmQWxwaGE7JkJldGE7JkdhbW1hOyZEZWx0YTsmRXBzaWxvbjsmWmV0YTsmRXRhOyZUaGV0YTsmSW90YTsmS2FwcGE7JkxhbWJkYTsmTXU7Jk51OyZYaTsmT21pY3JvbjsmUGk7JlJobzsmU2lnbWE7JlRhdTsmVXBzaWxvbjsmUGhpOyZDaGk7JlBzaTsmT21lZ2E7JmFscGhhOyZiZXRhOyZnYW1tYTsmZGVsdGE7JmVwc2lsb247JnpldGE7JmV0YTsmdGhldGE7JmlvdGE7JmthcHBhOyZsYW1iZGE7Jm11OyZudTsmeGk7Jm9taWNyb247JnBpOyZyaG87JnNpZ21hZjsmc2lnbWE7JnRhdTsmdXBzaWxvbjsmcGhpOyZjaGk7JnBzaTsmb21lZ2E7JnRoZXRhc3ltOyZ1cHNpaDsmcGl2OyZlbnNwOyZlbXNwOyZ0aGluc3A7Jnp3bmo7Jnp3ajsmbHJtOyZybG07Jm5kYXNoOyZtZGFzaDsmbHNxdW87JnJzcXVvOyZzYnF1bzsmbGRxdW87JnJkcXVvOyZiZHF1bzsmZGFnZ2VyOyZEYWdnZXI7JmJ1bGw7JmhlbGxpcDsmcGVybWlsOyZwcmltZTsmUHJpbWU7JmxzYXF1bzsmcnNhcXVvOyZvbGluZTsmZnJhc2w7JmV1cm87JmltYWdlOyZ3ZWllcnA7JnJlYWw7JnRyYWRlOyZhbGVmc3ltOyZsYXJyOyZ1YXJyOyZyYXJyOyZkYXJyOyZoYXJyOyZjcmFycjsmbEFycjsmdUFycjsmckFycjsmZEFycjsmaEFycjsmZm9yYWxsOyZwYXJ0OyZleGlzdDsmZW1wdHk7Jm5hYmxhOyZpc2luOyZub3Rpbjsmbmk7JnByb2Q7JnN1bTsmbWludXM7Jmxvd2FzdDsmcmFkaWM7JnByb3A7JmluZmluOyZhbmc7JmFuZDsmb3I7JmNhcDsmY3VwOyZpbnQ7JnRoZXJlNDsmc2ltOyZjb25nOyZhc3ltcDsmbmU7JmVxdWl2OyZsZTsmZ2U7JnN1Yjsmc3VwOyZuc3ViOyZzdWJlOyZzdXBlOyZvcGx1czsmb3RpbWVzOyZwZXJwOyZzZG90OyZsY2VpbDsmcmNlaWw7JmxmbG9vcjsmcmZsb29yOyZsYW5nOyZyYW5nOyZsb3o7JnNwYWRlczsmY2x1YnM7JmhlYXJ0czsmZGlhbXM7XFxcIn0pLGEuRkUuUExVR0lOUy5lbnRpdGllcz1mdW5jdGlvbihiKXtmdW5jdGlvbiBjKGEpe3ZhciBiPWEudGV4dENvbnRlbnQ7aWYoYi5tYXRjaChnKSl7Zm9yKHZhciBjPVxcXCJcXFwiLGQ9MDtkPGIubGVuZ3RoO2QrKyljKz1oW2JbZF1dP2hbYltkXV06YltkXTthLnRleHRDb250ZW50PWN9fWZ1bmN0aW9uIGQoYSl7aWYoYSYmW1xcXCJTVFlMRVxcXCIsXFxcIlNDUklQVFxcXCIsXFxcInN2Z1xcXCJdLmluZGV4T2YoYS50YWdOYW1lKT49MClyZXR1cm4hMDtmb3IodmFyIGU9Yi5ub2RlLmNvbnRlbnRzKGEpLGY9MDtmPGUubGVuZ3RoO2YrKyllW2ZdLm5vZGVUeXBlPT1Ob2RlLlRFWFRfTk9ERT9jKGVbZl0pOmQoZVtmXSk7YS5ub2RlVHlwZT09Tm9kZS5URVhUX05PREUmJmMoYSl9ZnVuY3Rpb24gZShhKXtpZigwPT09YS5sZW5ndGgpcmV0dXJuXFxcIlxcXCI7dmFyIGM9Yi5jbGVhbi5leGVjKGEsZCkucmVwbGFjZSgvXFxcXCZhbXA7L2csXFxcIiZcXFwiKTtyZXR1cm4gY31mdW5jdGlvbiBmKCl7Yi5vcHRzLmh0bWxTaW1wbGVBbXBlcnNhbmR8fChiLm9wdHMuZW50aXRpZXM9Yi5vcHRzLmVudGl0aWVzK1xcXCImYW1wO1xcXCIpO3ZhciBjPWEoXFxcIjxkaXY+XFxcIikuaHRtbChiLm9wdHMuZW50aXRpZXMpLnRleHQoKSxkPWIub3B0cy5lbnRpdGllcy5zcGxpdChcXFwiO1xcXCIpO2g9e30sZz1cXFwiXFxcIjtmb3IodmFyIGY9MDtmPGMubGVuZ3RoO2YrKyl7dmFyIGk9Yy5jaGFyQXQoZik7aFtpXT1kW2ZdK1xcXCI7XFxcIixnKz1cXFwiXFxcXFxcXFxcXFwiK2krKGY8Yy5sZW5ndGgtMT9cXFwifFxcXCI6XFxcIlxcXCIpfWc9bmV3IFJlZ0V4cChcXFwiKFxcXCIrZytcXFwiKVxcXCIsXFxcImdcXFwiKSxiLmV2ZW50cy5vbihcXFwiaHRtbC5nZXRcXFwiLGUsITApfXZhciBnLGg7cmV0dXJue19pbml0OmZ9fX0pO1wiXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3Jhdy1sb2FkZXIhLi9+L2Zyb2FsYS1lZGl0b3IvanMvcGx1Z2lucy9lbnRpdGllcy5taW4uanNcbi8vIG1vZHVsZSBpZCA9IDE1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

	eval("__webpack_require__(2)(__webpack_require__(17))//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTYuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2Zyb2FsYS1lZGl0b3IvanMvcGx1Z2lucy9saW5rLm1pbi5qcz9lNGE2Il0sInNvdXJjZXNDb250ZW50IjpbInJlcXVpcmUoXCIhIS92YXIvYXBwL3dlYi9qcy9ub2RlX21vZHVsZXMvc2NyaXB0LWxvYWRlci9hZGRTY3JpcHQuanNcIikocmVxdWlyZShcIiEhL3Zhci9hcHAvd2ViL2pzL25vZGVfbW9kdWxlcy9yYXctbG9hZGVyL2luZGV4LmpzIS92YXIvYXBwL3dlYi9qcy9ub2RlX21vZHVsZXMvZnJvYWxhLWVkaXRvci9qcy9wbHVnaW5zL2xpbmsubWluLmpzXCIpKVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9zY3JpcHQtbG9hZGVyIS4vfi9mcm9hbGEtZWRpdG9yL2pzL3BsdWdpbnMvbGluay5taW4uanNcbi8vIG1vZHVsZSBpZCA9IDE2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 17 */
/***/ function(module, exports) {

	eval("module.exports = \"/*!\\n * froala_editor v2.4.0 (https://www.froala.com/wysiwyg-editor)\\n * License https://froala.com/wysiwyg-editor/terms/\\n * Copyright 2014-2016 Froala Labs\\n */\\n\\n!function(a){\\\"function\\\"==typeof define&&define.amd?define([\\\"jquery\\\"],a):\\\"object\\\"==typeof module&&module.exports?module.exports=function(b,c){return void 0===c&&(c=\\\"undefined\\\"!=typeof window?require(\\\"jquery\\\"):require(\\\"jquery\\\")(b)),a(c),c}:a(jQuery)}(function(a){a.extend(a.FE.POPUP_TEMPLATES,{\\\"link.edit\\\":\\\"[_BUTTONS_]\\\",\\\"link.insert\\\":\\\"[_BUTTONS_][_INPUT_LAYER_]\\\"}),a.extend(a.FE.DEFAULTS,{linkEditButtons:[\\\"linkOpen\\\",\\\"linkStyle\\\",\\\"linkEdit\\\",\\\"linkRemove\\\"],linkInsertButtons:[\\\"linkBack\\\",\\\"|\\\",\\\"linkList\\\"],linkAttributes:{},linkAutoPrefix:\\\"http://\\\",linkStyles:{\\\"fr-green\\\":\\\"Green\\\",\\\"fr-strong\\\":\\\"Thick\\\"},linkMultipleStyles:!0,linkConvertEmailAddress:!0,linkAlwaysBlank:!1,linkAlwaysNoFollow:!1,linkList:[{text:\\\"Froala\\\",href:\\\"https://froala.com\\\",target:\\\"_blank\\\"},{text:\\\"Google\\\",href:\\\"https://google.com\\\",target:\\\"_blank\\\"},{displayText:\\\"Facebook\\\",href:\\\"https://facebook.com\\\"}],linkText:!0}),a.FE.PLUGINS.link=function(b){function c(){var c=b.image?b.image.get():null;if(!c&&b.$wp){var d=b.selection.ranges(0).commonAncestorContainer;if(d&&(d.contains&&d.contains(b.el)||!b.el.contains(d)||b.el==d)&&(d=null),d&&\\\"A\\\"===d.tagName)return d;var e=b.selection.element(),f=b.selection.endElement();return\\\"A\\\"==e.tagName||b.node.isElement(e)||(e=a(e).parentsUntil(b.$el,\\\"a:first\\\").get(0)),\\\"A\\\"==f.tagName||b.node.isElement(f)||(f=a(f).parentsUntil(b.$el,\\\"a:first\\\").get(0)),f&&(f.contains&&f.contains(b.el)||!b.el.contains(f)||b.el==f)&&(f=null),e&&(e.contains&&e.contains(b.el)||!b.el.contains(e)||b.el==e)&&(e=null),f&&f==e&&\\\"A\\\"==f.tagName?e:null}return\\\"A\\\"==b.el.tagName?b.el:c&&c.get(0).parentNode&&\\\"A\\\"==c.get(0).parentNode.tagName?c.get(0).parentNode:void 0}function d(){var a=b.image?b.image.get():null,c=[];if(a)\\\"A\\\"==a.get(0).parentNode.tagName&&c.push(a.get(0).parentNode);else{var d,e,f,g;if(b.win.getSelection){var h=b.win.getSelection();if(h.getRangeAt&&h.rangeCount){g=b.doc.createRange();for(var i=0;i<h.rangeCount;++i)if(d=h.getRangeAt(i),e=d.commonAncestorContainer,e&&1!=e.nodeType&&(e=e.parentNode),e&&\\\"a\\\"==e.nodeName.toLowerCase())c.push(e);else{f=e.getElementsByTagName(\\\"a\\\");for(var j=0;j<f.length;++j)g.selectNodeContents(f[j]),g.compareBoundaryPoints(d.END_TO_START,d)<1&&g.compareBoundaryPoints(d.START_TO_END,d)>-1&&c.push(f[j])}}}else if(b.doc.selection&&\\\"Control\\\"!=b.doc.selection.type)if(d=b.doc.selection.createRange(),e=d.parentElement(),\\\"a\\\"==e.nodeName.toLowerCase())c.push(e);else{f=e.getElementsByTagName(\\\"a\\\"),g=b.doc.body.createTextRange();for(var k=0;k<f.length;++k)g.moveToElementText(f[k]),g.compareEndPoints(\\\"StartToEnd\\\",d)>-1&&g.compareEndPoints(\\\"EndToStart\\\",d)<1&&c.push(f[k])}}return c}function e(d){g(),setTimeout(function(){if(!d||d&&(1==d.which||\\\"mouseup\\\"!=d.type)){var e=c(),g=b.image?b.image.get():null;if(e&&!g){if(b.image){var h=b.node.contents(e);if(1==h.length&&\\\"IMG\\\"==h[0].tagName){var i=b.selection.ranges(0);return 0===i.startOffset&&0===i.endOffset?a(e).before(a.FE.MARKERS):a(e).after(a.FE.MARKERS),b.selection.restore(),!1}}d&&d.stopPropagation(),f(e)}}},b.helpers.isIOS()?100:0)}function f(c){var d=b.popups.get(\\\"link.edit\\\");d||(d=h());var e=a(c);b.popups.isVisible(\\\"link.edit\\\")||b.popups.refresh(\\\"link.edit\\\"),b.popups.setContainer(\\\"link.edit\\\",a(b.opts.scrollableContainer));var f=e.offset().left+a(c).outerWidth()/2,g=e.offset().top+e.outerHeight();b.popups.show(\\\"link.edit\\\",f,g,e.outerHeight())}function g(){b.popups.hide(\\\"link.edit\\\")}function h(){var a=\\\"\\\";b.opts.linkEditButtons.length>1&&(\\\"A\\\"==b.el.tagName&&b.opts.linkEditButtons.indexOf(\\\"linkRemove\\\")>=0&&b.opts.linkEditButtons.splice(b.opts.linkEditButtons.indexOf(\\\"linkRemove\\\"),1),a='<div class=\\\"fr-buttons\\\">'+b.button.buildList(b.opts.linkEditButtons)+\\\"</div>\\\");var d={buttons:a},e=b.popups.create(\\\"link.edit\\\",d);return b.$wp&&b.events.$on(b.$wp,\\\"scroll.link-edit\\\",function(){c()&&b.popups.isVisible(\\\"link.edit\\\")&&f(c())}),e}function i(){}function j(){var d=b.popups.get(\\\"link.insert\\\"),e=c();if(e){var f,g,h=a(e),i=d.find('input.fr-link-attr[type=\\\"text\\\"]'),j=d.find('input.fr-link-attr[type=\\\"checkbox\\\"]');for(f=0;f<i.length;f++)g=a(i[f]),g.val(h.attr(g.attr(\\\"name\\\")||\\\"\\\"));for(j.prop(\\\"checked\\\",!1),f=0;f<j.length;f++)g=a(j[f]),h.attr(g.attr(\\\"name\\\"))==g.data(\\\"checked\\\")&&g.prop(\\\"checked\\\",!0);d.find('input.fr-link-attr[type=\\\"text\\\"][name=\\\"text\\\"]').val(h.text())}else d.find('input.fr-link-attr[type=\\\"text\\\"]').val(\\\"\\\"),d.find('input.fr-link-attr[type=\\\"checkbox\\\"]').prop(\\\"checked\\\",!1),d.find('input.fr-link-attr[type=\\\"text\\\"][name=\\\"text\\\"]').val(b.selection.text());d.find(\\\"input.fr-link-attr\\\").trigger(\\\"change\\\");var k=b.image?b.image.get():null;k?d.find('.fr-link-attr[name=\\\"text\\\"]').parent().hide():d.find('.fr-link-attr[name=\\\"text\\\"]').parent().show()}function k(){var c=b.$tb.find('.fr-command[data-cmd=\\\"insertLink\\\"]'),d=b.popups.get(\\\"link.insert\\\");if(d||(d=l()),!d.hasClass(\\\"fr-active\\\"))if(b.popups.refresh(\\\"link.insert\\\"),b.popups.setContainer(\\\"link.insert\\\",b.$tb||a(b.opts.scrollableContainer)),c.is(\\\":visible\\\")){var e=c.offset().left+c.outerWidth()/2,f=c.offset().top+(b.opts.toolbarBottom?10:c.outerHeight()-10);b.popups.show(\\\"link.insert\\\",e,f,c.outerHeight())}else b.position.forSelection(d),b.popups.show(\\\"link.insert\\\")}function l(a){if(a)return b.popups.onRefresh(\\\"link.insert\\\",j),b.popups.onHide(\\\"link.insert\\\",i),!0;var d=\\\"\\\";b.opts.linkInsertButtons.length>=1&&(d='<div class=\\\"fr-buttons\\\">'+b.button.buildList(b.opts.linkInsertButtons)+\\\"</div>\\\");var e='<svg version=\\\"1.1\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\" xmlns:xlink=\\\"http://www.w3.org/1999/xlink\\\" width=\\\"10\\\" height=\\\"10\\\" viewBox=\\\"0 0 32 32\\\"><path d=\\\"M27 4l-15 15-7-7-5 5 12 12 20-20z\\\" fill=\\\"#FFF\\\"></path></svg>',f=\\\"\\\",g=0;f='<div class=\\\"fr-link-insert-layer fr-layer fr-active\\\" id=\\\"fr-link-insert-layer-'+b.id+'\\\">',f+='<div class=\\\"fr-input-line\\\"><input id=\\\"fr-link-insert-layer-url-'+b.id+'\\\" name=\\\"href\\\" type=\\\"text\\\" class=\\\"fr-link-attr\\\" placeholder=\\\"URL\\\" tabIndex=\\\"'+ ++g+'\\\"></div>',b.opts.linkText&&(f+='<div class=\\\"fr-input-line\\\"><input id=\\\"fr-link-insert-layer-text-'+b.id+'\\\" name=\\\"text\\\" type=\\\"text\\\" class=\\\"fr-link-attr\\\" placeholder=\\\"'+b.language.translate(\\\"Text\\\")+'\\\" tabIndex=\\\"'+ ++g+'\\\"></div>');for(var h in b.opts.linkAttributes)if(b.opts.linkAttributes.hasOwnProperty(h)){var k=b.opts.linkAttributes[h];f+='<div class=\\\"fr-input-line\\\"><input name=\\\"'+h+'\\\" type=\\\"text\\\" class=\\\"fr-link-attr\\\" placeholder=\\\"'+b.language.translate(k)+'\\\" tabIndex=\\\"'+ ++g+'\\\"></div>'}b.opts.linkAlwaysBlank||(f+='<div class=\\\"fr-checkbox-line\\\"><span class=\\\"fr-checkbox\\\"><input name=\\\"target\\\" class=\\\"fr-link-attr\\\" data-checked=\\\"_blank\\\" type=\\\"checkbox\\\" id=\\\"fr-link-target-'+b.id+'\\\" tabIndex=\\\"'+ ++g+'\\\"><span>'+e+'</span></span><label for=\\\"fr-link-target-'+b.id+'\\\">'+b.language.translate(\\\"Open in new tab\\\")+\\\"</label></div>\\\"),f+='<div class=\\\"fr-action-buttons\\\"><button class=\\\"fr-command fr-submit\\\" role=\\\"button\\\" data-cmd=\\\"linkInsert\\\" href=\\\"#\\\" tabIndex=\\\"'+ ++g+'\\\" type=\\\"button\\\">'+b.language.translate(\\\"Insert\\\")+\\\"</button></div></div>\\\";var l={buttons:d,input_layer:f},m=b.popups.create(\\\"link.insert\\\",l);return b.$wp&&b.events.$on(b.$wp,\\\"scroll.link-insert\\\",function(){var a=b.image?b.image.get():null;a&&b.popups.isVisible(\\\"link.insert\\\")&&u(),c&&b.popups.isVisible(\\\"link.insert\\\")&&s()}),m}function m(){var d=c(),e=b.image?b.image.get():null;return b.events.trigger(\\\"link.beforeRemove\\\",[d])!==!1&&void(e&&d?(e.unwrap(),b.image.edit(e)):d&&(b.selection.save(),a(d).replaceWith(a(d).html()),b.selection.restore(),g()))}function n(){b.events.on(\\\"keyup\\\",function(b){b.which!=a.FE.KEYCODE.ESC&&e(b)}),b.events.on(\\\"window.mouseup\\\",e),b.helpers.isMobile()&&b.events.$on(b.$doc,\\\"selectionchange\\\",e),l(!0),\\\"A\\\"==b.el.tagName&&b.$el.addClass(\\\"fr-view\\\"),b.events.on(\\\"toolbar.esc\\\",function(){if(b.popups.isVisible(\\\"link.edit\\\"))return b.events.disableBlur(),b.events.focus(),!1},!0)}function o(c){var d,e,f=b.opts.linkList[c],g=b.popups.get(\\\"link.insert\\\"),h=g.find('input.fr-link-attr[type=\\\"text\\\"]'),i=g.find('input.fr-link-attr[type=\\\"checkbox\\\"]');for(e=0;e<h.length;e++)d=a(h[e]),f[d.attr(\\\"name\\\")]?d.val(f[d.attr(\\\"name\\\")]):\\\"text\\\"!=d.attr(\\\"name\\\")&&d.val(\\\"\\\");for(e=0;e<i.length;e++)d=a(i[e]),d.prop(\\\"checked\\\",d.data(\\\"checked\\\")==f[d.attr(\\\"name\\\")]);b.accessibility.focusPopup(g)}function p(){var c,d,e=b.popups.get(\\\"link.insert\\\"),f=e.find('input.fr-link-attr[type=\\\"text\\\"]'),g=e.find('input.fr-link-attr[type=\\\"checkbox\\\"]'),h=f.filter('[name=\\\"href\\\"]').val(),i=f.filter('[name=\\\"text\\\"]').val(),j={};for(d=0;d<f.length;d++)c=a(f[d]),[\\\"href\\\",\\\"text\\\"].indexOf(c.attr(\\\"name\\\"))<0&&(j[c.attr(\\\"name\\\")]=c.val());for(d=0;d<g.length;d++)c=a(g[d]),c.is(\\\":checked\\\")?j[c.attr(\\\"name\\\")]=c.data(\\\"checked\\\"):j[c.attr(\\\"name\\\")]=c.data(\\\"unchecked\\\");var k=a(b.o_win).scrollTop();r(h,i,j),a(b.o_win).scrollTop(k)}function q(){if(!b.selection.isCollapsed()){b.selection.save();for(var c=b.$el.find(\\\".fr-marker\\\").addClass(\\\"fr-unprocessed\\\").toArray();c.length;){var d=a(c.pop());d.removeClass(\\\"fr-unprocessed\\\");var e=b.node.deepestParent(d.get(0));if(e){var f=d.get(0),g=\\\"\\\",h=\\\"\\\";do f=f.parentNode,b.node.isBlock(f)||(g+=b.node.closeTagString(f),h=b.node.openTagString(f)+h);while(f!=e);var i=b.node.openTagString(d.get(0))+d.html()+b.node.closeTagString(d.get(0));d.replaceWith('<span id=\\\"fr-break\\\"></span>');var j=a(e).html();j=j.replace(/<span id=\\\"fr-break\\\"><\\\\/span>/g,g+i+h),a(e).html(j)}c=b.$el.find(\\\".fr-marker.fr-unprocessed\\\").toArray()}b.selection.restore()}}function r(f,g,h){if(\\\"undefined\\\"==typeof h&&(h={}),b.events.trigger(\\\"link.beforeInsert\\\",[f,g,h])===!1)return!1;var i=b.image?b.image.get():null;i||\\\"A\\\"==b.el.tagName?\\\"A\\\"==b.el.tagName&&b.$el.focus():(b.selection.restore(),b.popups.hide(\\\"link.insert\\\"));var j=f;if(b.opts.linkConvertEmailAddress){var k=/^[\\\\w._]+@[a-z\\\\u00a1-\\\\uffff0-9_-]+?\\\\.[a-z\\\\u00a1-\\\\uffff0-9]{2,}$/i;k.test(f)&&!/^mailto:.*/i.test(f)&&(f=\\\"mailto:\\\"+f)}if(\\\"\\\"===b.opts.linkAutoPrefix||/^(mailto|tel|sms|notes|data):.*/i.test(f)||/^data:image.*/i.test(f)||/^(https?:|ftps?:|file:|)\\\\/\\\\//i.test(f)||[\\\"/\\\",\\\"{\\\",\\\"[\\\",\\\"#\\\",\\\"(\\\"].indexOf((f||\\\"\\\")[0])<0&&(f=b.opts.linkAutoPrefix+f),f=b.helpers.sanitizeURL(f),b.opts.linkAlwaysBlank&&(h.target=\\\"_blank\\\"),b.opts.linkAlwaysNoFollow&&(h.rel=\\\"nofollow\\\"),\\\"_blank\\\"==h.target&&(h.rel?h.rel+=\\\" noopener noreferrer\\\":h.rel=\\\"noopener noreferrer\\\"),g=g||\\\"\\\",f===b.opts.linkAutoPrefix){var l=b.popups.get(\\\"link.insert\\\");return l.find('input[name=\\\"href\\\"]').addClass(\\\"fr-error\\\"),b.events.trigger(\\\"link.bad\\\",[j]),!1}var m,n=c();if(n){m=a(n);var o=b.node.rawAttributes(n);for(var p in o)o.hasOwnProperty(p)&&\\\"class\\\"!=p&&\\\"style\\\"!=p&&\\\"id\\\"!=p&&\\\"contenteditable\\\"!=p&&m.removeAttr(p);m.attr(\\\"href\\\",f),g.length>0&&m.text()!=g&&!i&&m.text(g),i||m.prepend(a.FE.START_MARKER).append(a.FE.END_MARKER),m.attr(h),i||b.selection.restore()}else{i?i.wrap('<a href=\\\"'+f+'\\\"></a>'):(b.format.remove(\\\"a\\\"),b.selection.isCollapsed()?(g=0===g.length?j:g,b.html.insert('<a href=\\\"'+f+'\\\">'+a.FE.START_MARKER+g+a.FE.END_MARKER+\\\"</a>\\\"),b.selection.restore()):g.length>0&&g!=b.selection.text().replace(/\\\\n/g,\\\"\\\")?(b.selection.remove(),b.html.insert('<a href=\\\"'+f+'\\\">'+a.FE.START_MARKER+g+a.FE.END_MARKER+\\\"</a>\\\"),b.selection.restore()):(q(),b.format.apply(\\\"a\\\",{href:f})));for(var r=d(),s=0;s<r.length;s++)m=a(r[s]),m.attr(h),m.removeAttr(\\\"_moz_dirty\\\");1==r.length&&b.$wp&&!i&&(a(r[0]).prepend(a.FE.START_MARKER).append(a.FE.END_MARKER),b.selection.restore())}if(i){var t=b.popups.get(\\\"link.insert\\\");t.find(\\\"input:focus\\\").blur(),b.image.edit(i)}else e()}function s(){g();var d=c();if(d){var e=b.popups.get(\\\"link.insert\\\");e||(e=l()),b.popups.isVisible(\\\"link.insert\\\")||(b.popups.refresh(\\\"link.insert\\\"),b.selection.save(),b.helpers.isMobile()&&(b.events.disableBlur(),b.$el.blur(),b.events.enableBlur())),b.popups.setContainer(\\\"link.insert\\\",a(b.opts.scrollableContainer));var f=(b.image?b.image.get():null)||a(d),h=f.offset().left+f.outerWidth()/2,i=f.offset().top+f.outerHeight();b.popups.show(\\\"link.insert\\\",h,i,f.outerHeight())}}function t(){var a=b.image?b.image.get():null;if(a)b.image.back();else{b.events.disableBlur(),b.selection.restore(),b.events.enableBlur();var d=c();d&&b.$wp?(b.selection.restore(),g(),e()):\\\"A\\\"==b.el.tagName?(b.$el.focus(),e()):(b.popups.hide(\\\"link.insert\\\"),b.toolbar.showInline())}}function u(){var c=b.image?b.image.get():null;if(c){var d=b.popups.get(\\\"link.insert\\\");d||(d=l()),j(!0),b.popups.setContainer(\\\"link.insert\\\",a(b.opts.scrollableContainer));var e=c.offset().left+c.outerWidth()/2,f=c.offset().top+c.outerHeight();b.popups.show(\\\"link.insert\\\",e,f,c.outerHeight())}}function v(d,f,g){\\\"undefined\\\"==typeof g&&(g=b.opts.linkMultipleStyles),\\\"undefined\\\"==typeof f&&(f=b.opts.linkStyles);var h=c();if(!h)return!1;if(!g){var i=Object.keys(f);i.splice(i.indexOf(d),1),a(h).removeClass(i.join(\\\" \\\"))}a(h).toggleClass(d),e()}return{_init:n,remove:m,showInsertPopup:k,usePredefined:o,insertCallback:p,insert:r,update:s,get:c,allSelected:d,back:t,imageLink:u,applyStyle:v}},a.FE.DefineIcon(\\\"insertLink\\\",{NAME:\\\"link\\\"}),a.FE.RegisterShortcut(a.FE.KEYCODE.K,\\\"insertLink\\\",null,\\\"K\\\"),a.FE.RegisterCommand(\\\"insertLink\\\",{title:\\\"Insert Link\\\",undo:!1,focus:!0,refreshOnCallback:!1,popup:!0,callback:function(){this.popups.isVisible(\\\"link.insert\\\")?(this.$el.find(\\\".fr-marker\\\").length&&(this.events.disableBlur(),this.selection.restore()),this.popups.hide(\\\"link.insert\\\")):this.link.showInsertPopup()},plugin:\\\"link\\\"}),a.FE.DefineIcon(\\\"linkOpen\\\",{NAME:\\\"external-link\\\"}),a.FE.RegisterCommand(\\\"linkOpen\\\",{title:\\\"Open Link\\\",undo:!1,refresh:function(a){var b=this.link.get();b?a.removeClass(\\\"fr-hidden\\\"):a.addClass(\\\"fr-hidden\\\")},callback:function(){var a=this.link.get();a&&this.o_win.open(a.href)}}),a.FE.DefineIcon(\\\"linkEdit\\\",{NAME:\\\"edit\\\"}),a.FE.RegisterCommand(\\\"linkEdit\\\",{title:\\\"Edit Link\\\",undo:!1,refreshAfterCallback:!1,popup:!0,callback:function(){this.link.update()},refresh:function(a){var b=this.link.get();b?a.removeClass(\\\"fr-hidden\\\"):a.addClass(\\\"fr-hidden\\\")}}),a.FE.DefineIcon(\\\"linkRemove\\\",{NAME:\\\"unlink\\\"}),a.FE.RegisterCommand(\\\"linkRemove\\\",{title:\\\"Unlink\\\",callback:function(){this.link.remove()},refresh:function(a){var b=this.link.get();b?a.removeClass(\\\"fr-hidden\\\"):a.addClass(\\\"fr-hidden\\\")}}),a.FE.DefineIcon(\\\"linkBack\\\",{NAME:\\\"arrow-left\\\"}),a.FE.RegisterCommand(\\\"linkBack\\\",{title:\\\"Back\\\",undo:!1,focus:!1,back:!0,refreshAfterCallback:!1,callback:function(){this.link.back()},refresh:function(a){var b=this.link.get()&&this.doc.hasFocus(),c=this.image?this.image.get():null;c||b||this.opts.toolbarInline?(a.removeClass(\\\"fr-hidden\\\"),a.next(\\\".fr-separator\\\").removeClass(\\\"fr-hidden\\\")):(a.addClass(\\\"fr-hidden\\\"),a.next(\\\".fr-separator\\\").addClass(\\\"fr-hidden\\\"))}}),a.FE.DefineIcon(\\\"linkList\\\",{NAME:\\\"search\\\"}),a.FE.RegisterCommand(\\\"linkList\\\",{title:\\\"Choose Link\\\",type:\\\"dropdown\\\",focus:!1,undo:!1,refreshAfterCallback:!1,html:function(){for(var a='<ul class=\\\"fr-dropdown-list\\\" role=\\\"presentation\\\">',b=this.opts.linkList,c=0;c<b.length;c++)a+='<li role=\\\"presentation\\\"><a class=\\\"fr-command\\\" tabIndex=\\\"-1\\\" role=\\\"option\\\" data-cmd=\\\"linkList\\\" data-param1=\\\"'+c+'\\\">'+(b[c].displayText||b[c].text)+\\\"</a></li>\\\";return a+=\\\"</ul>\\\"},callback:function(a,b){this.link.usePredefined(b)}}),a.FE.RegisterCommand(\\\"linkInsert\\\",{focus:!1,refreshAfterCallback:!1,callback:function(){this.link.insertCallback()},refresh:function(a){var b=this.link.get();b?a.text(this.language.translate(\\\"Update\\\")):a.text(this.language.translate(\\\"Insert\\\"))}}),a.FE.DefineIcon(\\\"imageLink\\\",{NAME:\\\"link\\\"}),a.FE.RegisterCommand(\\\"imageLink\\\",{title:\\\"Insert Link\\\",undo:!1,focus:!1,popup:!0,callback:function(){this.link.imageLink()},refresh:function(a){var b,c=this.link.get();c?(b=a.prev(),b.hasClass(\\\"fr-separator\\\")&&b.removeClass(\\\"fr-hidden\\\"),a.addClass(\\\"fr-hidden\\\")):(b=a.prev(),b.hasClass(\\\"fr-separator\\\")&&b.addClass(\\\"fr-hidden\\\"),a.removeClass(\\\"fr-hidden\\\"))}}),a.FE.DefineIcon(\\\"linkStyle\\\",{NAME:\\\"magic\\\"}),a.FE.RegisterCommand(\\\"linkStyle\\\",{title:\\\"Style\\\",type:\\\"dropdown\\\",html:function(){var a='<ul class=\\\"fr-dropdown-list\\\" role=\\\"presentation\\\">',b=this.opts.linkStyles;for(var c in b)b.hasOwnProperty(c)&&(a+='<li role=\\\"presentation\\\"><a class=\\\"fr-command\\\" tabIndex=\\\"-1\\\" role=\\\"option\\\" data-cmd=\\\"linkStyle\\\" data-param1=\\\"'+c+'\\\">'+this.language.translate(b[c])+\\\"</a></li>\\\");return a+=\\\"</ul>\\\"},callback:function(a,b){this.link.applyStyle(b)},refreshOnShow:function(b,c){var d=this.link.get();if(d){var e=a(d);c.find(\\\".fr-command\\\").each(function(){var b=a(this).data(\\\"param1\\\"),c=e.hasClass(b);a(this).toggleClass(\\\"fr-active\\\",c).attr(\\\"aria-selected\\\",c)})}}})});\"//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTcuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2Zyb2FsYS1lZGl0b3IvanMvcGx1Z2lucy9saW5rLm1pbi5qcz81MmY1Il0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gXCIvKiFcXG4gKiBmcm9hbGFfZWRpdG9yIHYyLjQuMCAoaHR0cHM6Ly93d3cuZnJvYWxhLmNvbS93eXNpd3lnLWVkaXRvcilcXG4gKiBMaWNlbnNlIGh0dHBzOi8vZnJvYWxhLmNvbS93eXNpd3lnLWVkaXRvci90ZXJtcy9cXG4gKiBDb3B5cmlnaHQgMjAxNC0yMDE2IEZyb2FsYSBMYWJzXFxuICovXFxuXFxuIWZ1bmN0aW9uKGEpe1xcXCJmdW5jdGlvblxcXCI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQ/ZGVmaW5lKFtcXFwianF1ZXJ5XFxcIl0sYSk6XFxcIm9iamVjdFxcXCI9PXR5cGVvZiBtb2R1bGUmJm1vZHVsZS5leHBvcnRzP21vZHVsZS5leHBvcnRzPWZ1bmN0aW9uKGIsYyl7cmV0dXJuIHZvaWQgMD09PWMmJihjPVxcXCJ1bmRlZmluZWRcXFwiIT10eXBlb2Ygd2luZG93P3JlcXVpcmUoXFxcImpxdWVyeVxcXCIpOnJlcXVpcmUoXFxcImpxdWVyeVxcXCIpKGIpKSxhKGMpLGN9OmEoalF1ZXJ5KX0oZnVuY3Rpb24oYSl7YS5leHRlbmQoYS5GRS5QT1BVUF9URU1QTEFURVMse1xcXCJsaW5rLmVkaXRcXFwiOlxcXCJbX0JVVFRPTlNfXVxcXCIsXFxcImxpbmsuaW5zZXJ0XFxcIjpcXFwiW19CVVRUT05TX11bX0lOUFVUX0xBWUVSX11cXFwifSksYS5leHRlbmQoYS5GRS5ERUZBVUxUUyx7bGlua0VkaXRCdXR0b25zOltcXFwibGlua09wZW5cXFwiLFxcXCJsaW5rU3R5bGVcXFwiLFxcXCJsaW5rRWRpdFxcXCIsXFxcImxpbmtSZW1vdmVcXFwiXSxsaW5rSW5zZXJ0QnV0dG9uczpbXFxcImxpbmtCYWNrXFxcIixcXFwifFxcXCIsXFxcImxpbmtMaXN0XFxcIl0sbGlua0F0dHJpYnV0ZXM6e30sbGlua0F1dG9QcmVmaXg6XFxcImh0dHA6Ly9cXFwiLGxpbmtTdHlsZXM6e1xcXCJmci1ncmVlblxcXCI6XFxcIkdyZWVuXFxcIixcXFwiZnItc3Ryb25nXFxcIjpcXFwiVGhpY2tcXFwifSxsaW5rTXVsdGlwbGVTdHlsZXM6ITAsbGlua0NvbnZlcnRFbWFpbEFkZHJlc3M6ITAsbGlua0Fsd2F5c0JsYW5rOiExLGxpbmtBbHdheXNOb0ZvbGxvdzohMSxsaW5rTGlzdDpbe3RleHQ6XFxcIkZyb2FsYVxcXCIsaHJlZjpcXFwiaHR0cHM6Ly9mcm9hbGEuY29tXFxcIix0YXJnZXQ6XFxcIl9ibGFua1xcXCJ9LHt0ZXh0OlxcXCJHb29nbGVcXFwiLGhyZWY6XFxcImh0dHBzOi8vZ29vZ2xlLmNvbVxcXCIsdGFyZ2V0OlxcXCJfYmxhbmtcXFwifSx7ZGlzcGxheVRleHQ6XFxcIkZhY2Vib29rXFxcIixocmVmOlxcXCJodHRwczovL2ZhY2Vib29rLmNvbVxcXCJ9XSxsaW5rVGV4dDohMH0pLGEuRkUuUExVR0lOUy5saW5rPWZ1bmN0aW9uKGIpe2Z1bmN0aW9uIGMoKXt2YXIgYz1iLmltYWdlP2IuaW1hZ2UuZ2V0KCk6bnVsbDtpZighYyYmYi4kd3Ape3ZhciBkPWIuc2VsZWN0aW9uLnJhbmdlcygwKS5jb21tb25BbmNlc3RvckNvbnRhaW5lcjtpZihkJiYoZC5jb250YWlucyYmZC5jb250YWlucyhiLmVsKXx8IWIuZWwuY29udGFpbnMoZCl8fGIuZWw9PWQpJiYoZD1udWxsKSxkJiZcXFwiQVxcXCI9PT1kLnRhZ05hbWUpcmV0dXJuIGQ7dmFyIGU9Yi5zZWxlY3Rpb24uZWxlbWVudCgpLGY9Yi5zZWxlY3Rpb24uZW5kRWxlbWVudCgpO3JldHVyblxcXCJBXFxcIj09ZS50YWdOYW1lfHxiLm5vZGUuaXNFbGVtZW50KGUpfHwoZT1hKGUpLnBhcmVudHNVbnRpbChiLiRlbCxcXFwiYTpmaXJzdFxcXCIpLmdldCgwKSksXFxcIkFcXFwiPT1mLnRhZ05hbWV8fGIubm9kZS5pc0VsZW1lbnQoZil8fChmPWEoZikucGFyZW50c1VudGlsKGIuJGVsLFxcXCJhOmZpcnN0XFxcIikuZ2V0KDApKSxmJiYoZi5jb250YWlucyYmZi5jb250YWlucyhiLmVsKXx8IWIuZWwuY29udGFpbnMoZil8fGIuZWw9PWYpJiYoZj1udWxsKSxlJiYoZS5jb250YWlucyYmZS5jb250YWlucyhiLmVsKXx8IWIuZWwuY29udGFpbnMoZSl8fGIuZWw9PWUpJiYoZT1udWxsKSxmJiZmPT1lJiZcXFwiQVxcXCI9PWYudGFnTmFtZT9lOm51bGx9cmV0dXJuXFxcIkFcXFwiPT1iLmVsLnRhZ05hbWU/Yi5lbDpjJiZjLmdldCgwKS5wYXJlbnROb2RlJiZcXFwiQVxcXCI9PWMuZ2V0KDApLnBhcmVudE5vZGUudGFnTmFtZT9jLmdldCgwKS5wYXJlbnROb2RlOnZvaWQgMH1mdW5jdGlvbiBkKCl7dmFyIGE9Yi5pbWFnZT9iLmltYWdlLmdldCgpOm51bGwsYz1bXTtpZihhKVxcXCJBXFxcIj09YS5nZXQoMCkucGFyZW50Tm9kZS50YWdOYW1lJiZjLnB1c2goYS5nZXQoMCkucGFyZW50Tm9kZSk7ZWxzZXt2YXIgZCxlLGYsZztpZihiLndpbi5nZXRTZWxlY3Rpb24pe3ZhciBoPWIud2luLmdldFNlbGVjdGlvbigpO2lmKGguZ2V0UmFuZ2VBdCYmaC5yYW5nZUNvdW50KXtnPWIuZG9jLmNyZWF0ZVJhbmdlKCk7Zm9yKHZhciBpPTA7aTxoLnJhbmdlQ291bnQ7KytpKWlmKGQ9aC5nZXRSYW5nZUF0KGkpLGU9ZC5jb21tb25BbmNlc3RvckNvbnRhaW5lcixlJiYxIT1lLm5vZGVUeXBlJiYoZT1lLnBhcmVudE5vZGUpLGUmJlxcXCJhXFxcIj09ZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpKWMucHVzaChlKTtlbHNle2Y9ZS5nZXRFbGVtZW50c0J5VGFnTmFtZShcXFwiYVxcXCIpO2Zvcih2YXIgaj0wO2o8Zi5sZW5ndGg7KytqKWcuc2VsZWN0Tm9kZUNvbnRlbnRzKGZbal0pLGcuY29tcGFyZUJvdW5kYXJ5UG9pbnRzKGQuRU5EX1RPX1NUQVJULGQpPDEmJmcuY29tcGFyZUJvdW5kYXJ5UG9pbnRzKGQuU1RBUlRfVE9fRU5ELGQpPi0xJiZjLnB1c2goZltqXSl9fX1lbHNlIGlmKGIuZG9jLnNlbGVjdGlvbiYmXFxcIkNvbnRyb2xcXFwiIT1iLmRvYy5zZWxlY3Rpb24udHlwZSlpZihkPWIuZG9jLnNlbGVjdGlvbi5jcmVhdGVSYW5nZSgpLGU9ZC5wYXJlbnRFbGVtZW50KCksXFxcImFcXFwiPT1lLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkpYy5wdXNoKGUpO2Vsc2V7Zj1lLmdldEVsZW1lbnRzQnlUYWdOYW1lKFxcXCJhXFxcIiksZz1iLmRvYy5ib2R5LmNyZWF0ZVRleHRSYW5nZSgpO2Zvcih2YXIgaz0wO2s8Zi5sZW5ndGg7KytrKWcubW92ZVRvRWxlbWVudFRleHQoZltrXSksZy5jb21wYXJlRW5kUG9pbnRzKFxcXCJTdGFydFRvRW5kXFxcIixkKT4tMSYmZy5jb21wYXJlRW5kUG9pbnRzKFxcXCJFbmRUb1N0YXJ0XFxcIixkKTwxJiZjLnB1c2goZltrXSl9fXJldHVybiBjfWZ1bmN0aW9uIGUoZCl7ZygpLHNldFRpbWVvdXQoZnVuY3Rpb24oKXtpZighZHx8ZCYmKDE9PWQud2hpY2h8fFxcXCJtb3VzZXVwXFxcIiE9ZC50eXBlKSl7dmFyIGU9YygpLGc9Yi5pbWFnZT9iLmltYWdlLmdldCgpOm51bGw7aWYoZSYmIWcpe2lmKGIuaW1hZ2Upe3ZhciBoPWIubm9kZS5jb250ZW50cyhlKTtpZigxPT1oLmxlbmd0aCYmXFxcIklNR1xcXCI9PWhbMF0udGFnTmFtZSl7dmFyIGk9Yi5zZWxlY3Rpb24ucmFuZ2VzKDApO3JldHVybiAwPT09aS5zdGFydE9mZnNldCYmMD09PWkuZW5kT2Zmc2V0P2EoZSkuYmVmb3JlKGEuRkUuTUFSS0VSUyk6YShlKS5hZnRlcihhLkZFLk1BUktFUlMpLGIuc2VsZWN0aW9uLnJlc3RvcmUoKSwhMX19ZCYmZC5zdG9wUHJvcGFnYXRpb24oKSxmKGUpfX19LGIuaGVscGVycy5pc0lPUygpPzEwMDowKX1mdW5jdGlvbiBmKGMpe3ZhciBkPWIucG9wdXBzLmdldChcXFwibGluay5lZGl0XFxcIik7ZHx8KGQ9aCgpKTt2YXIgZT1hKGMpO2IucG9wdXBzLmlzVmlzaWJsZShcXFwibGluay5lZGl0XFxcIil8fGIucG9wdXBzLnJlZnJlc2goXFxcImxpbmsuZWRpdFxcXCIpLGIucG9wdXBzLnNldENvbnRhaW5lcihcXFwibGluay5lZGl0XFxcIixhKGIub3B0cy5zY3JvbGxhYmxlQ29udGFpbmVyKSk7dmFyIGY9ZS5vZmZzZXQoKS5sZWZ0K2EoYykub3V0ZXJXaWR0aCgpLzIsZz1lLm9mZnNldCgpLnRvcCtlLm91dGVySGVpZ2h0KCk7Yi5wb3B1cHMuc2hvdyhcXFwibGluay5lZGl0XFxcIixmLGcsZS5vdXRlckhlaWdodCgpKX1mdW5jdGlvbiBnKCl7Yi5wb3B1cHMuaGlkZShcXFwibGluay5lZGl0XFxcIil9ZnVuY3Rpb24gaCgpe3ZhciBhPVxcXCJcXFwiO2Iub3B0cy5saW5rRWRpdEJ1dHRvbnMubGVuZ3RoPjEmJihcXFwiQVxcXCI9PWIuZWwudGFnTmFtZSYmYi5vcHRzLmxpbmtFZGl0QnV0dG9ucy5pbmRleE9mKFxcXCJsaW5rUmVtb3ZlXFxcIik+PTAmJmIub3B0cy5saW5rRWRpdEJ1dHRvbnMuc3BsaWNlKGIub3B0cy5saW5rRWRpdEJ1dHRvbnMuaW5kZXhPZihcXFwibGlua1JlbW92ZVxcXCIpLDEpLGE9JzxkaXYgY2xhc3M9XFxcImZyLWJ1dHRvbnNcXFwiPicrYi5idXR0b24uYnVpbGRMaXN0KGIub3B0cy5saW5rRWRpdEJ1dHRvbnMpK1xcXCI8L2Rpdj5cXFwiKTt2YXIgZD17YnV0dG9uczphfSxlPWIucG9wdXBzLmNyZWF0ZShcXFwibGluay5lZGl0XFxcIixkKTtyZXR1cm4gYi4kd3AmJmIuZXZlbnRzLiRvbihiLiR3cCxcXFwic2Nyb2xsLmxpbmstZWRpdFxcXCIsZnVuY3Rpb24oKXtjKCkmJmIucG9wdXBzLmlzVmlzaWJsZShcXFwibGluay5lZGl0XFxcIikmJmYoYygpKX0pLGV9ZnVuY3Rpb24gaSgpe31mdW5jdGlvbiBqKCl7dmFyIGQ9Yi5wb3B1cHMuZ2V0KFxcXCJsaW5rLmluc2VydFxcXCIpLGU9YygpO2lmKGUpe3ZhciBmLGcsaD1hKGUpLGk9ZC5maW5kKCdpbnB1dC5mci1saW5rLWF0dHJbdHlwZT1cXFwidGV4dFxcXCJdJyksaj1kLmZpbmQoJ2lucHV0LmZyLWxpbmstYXR0clt0eXBlPVxcXCJjaGVja2JveFxcXCJdJyk7Zm9yKGY9MDtmPGkubGVuZ3RoO2YrKylnPWEoaVtmXSksZy52YWwoaC5hdHRyKGcuYXR0cihcXFwibmFtZVxcXCIpfHxcXFwiXFxcIikpO2ZvcihqLnByb3AoXFxcImNoZWNrZWRcXFwiLCExKSxmPTA7ZjxqLmxlbmd0aDtmKyspZz1hKGpbZl0pLGguYXR0cihnLmF0dHIoXFxcIm5hbWVcXFwiKSk9PWcuZGF0YShcXFwiY2hlY2tlZFxcXCIpJiZnLnByb3AoXFxcImNoZWNrZWRcXFwiLCEwKTtkLmZpbmQoJ2lucHV0LmZyLWxpbmstYXR0clt0eXBlPVxcXCJ0ZXh0XFxcIl1bbmFtZT1cXFwidGV4dFxcXCJdJykudmFsKGgudGV4dCgpKX1lbHNlIGQuZmluZCgnaW5wdXQuZnItbGluay1hdHRyW3R5cGU9XFxcInRleHRcXFwiXScpLnZhbChcXFwiXFxcIiksZC5maW5kKCdpbnB1dC5mci1saW5rLWF0dHJbdHlwZT1cXFwiY2hlY2tib3hcXFwiXScpLnByb3AoXFxcImNoZWNrZWRcXFwiLCExKSxkLmZpbmQoJ2lucHV0LmZyLWxpbmstYXR0clt0eXBlPVxcXCJ0ZXh0XFxcIl1bbmFtZT1cXFwidGV4dFxcXCJdJykudmFsKGIuc2VsZWN0aW9uLnRleHQoKSk7ZC5maW5kKFxcXCJpbnB1dC5mci1saW5rLWF0dHJcXFwiKS50cmlnZ2VyKFxcXCJjaGFuZ2VcXFwiKTt2YXIgaz1iLmltYWdlP2IuaW1hZ2UuZ2V0KCk6bnVsbDtrP2QuZmluZCgnLmZyLWxpbmstYXR0cltuYW1lPVxcXCJ0ZXh0XFxcIl0nKS5wYXJlbnQoKS5oaWRlKCk6ZC5maW5kKCcuZnItbGluay1hdHRyW25hbWU9XFxcInRleHRcXFwiXScpLnBhcmVudCgpLnNob3coKX1mdW5jdGlvbiBrKCl7dmFyIGM9Yi4kdGIuZmluZCgnLmZyLWNvbW1hbmRbZGF0YS1jbWQ9XFxcImluc2VydExpbmtcXFwiXScpLGQ9Yi5wb3B1cHMuZ2V0KFxcXCJsaW5rLmluc2VydFxcXCIpO2lmKGR8fChkPWwoKSksIWQuaGFzQ2xhc3MoXFxcImZyLWFjdGl2ZVxcXCIpKWlmKGIucG9wdXBzLnJlZnJlc2goXFxcImxpbmsuaW5zZXJ0XFxcIiksYi5wb3B1cHMuc2V0Q29udGFpbmVyKFxcXCJsaW5rLmluc2VydFxcXCIsYi4kdGJ8fGEoYi5vcHRzLnNjcm9sbGFibGVDb250YWluZXIpKSxjLmlzKFxcXCI6dmlzaWJsZVxcXCIpKXt2YXIgZT1jLm9mZnNldCgpLmxlZnQrYy5vdXRlcldpZHRoKCkvMixmPWMub2Zmc2V0KCkudG9wKyhiLm9wdHMudG9vbGJhckJvdHRvbT8xMDpjLm91dGVySGVpZ2h0KCktMTApO2IucG9wdXBzLnNob3coXFxcImxpbmsuaW5zZXJ0XFxcIixlLGYsYy5vdXRlckhlaWdodCgpKX1lbHNlIGIucG9zaXRpb24uZm9yU2VsZWN0aW9uKGQpLGIucG9wdXBzLnNob3coXFxcImxpbmsuaW5zZXJ0XFxcIil9ZnVuY3Rpb24gbChhKXtpZihhKXJldHVybiBiLnBvcHVwcy5vblJlZnJlc2goXFxcImxpbmsuaW5zZXJ0XFxcIixqKSxiLnBvcHVwcy5vbkhpZGUoXFxcImxpbmsuaW5zZXJ0XFxcIixpKSwhMDt2YXIgZD1cXFwiXFxcIjtiLm9wdHMubGlua0luc2VydEJ1dHRvbnMubGVuZ3RoPj0xJiYoZD0nPGRpdiBjbGFzcz1cXFwiZnItYnV0dG9uc1xcXCI+JytiLmJ1dHRvbi5idWlsZExpc3QoYi5vcHRzLmxpbmtJbnNlcnRCdXR0b25zKStcXFwiPC9kaXY+XFxcIik7dmFyIGU9JzxzdmcgdmVyc2lvbj1cXFwiMS4xXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiIHhtbG5zOnhsaW5rPVxcXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rXFxcIiB3aWR0aD1cXFwiMTBcXFwiIGhlaWdodD1cXFwiMTBcXFwiIHZpZXdCb3g9XFxcIjAgMCAzMiAzMlxcXCI+PHBhdGggZD1cXFwiTTI3IDRsLTE1IDE1LTctNy01IDUgMTIgMTIgMjAtMjB6XFxcIiBmaWxsPVxcXCIjRkZGXFxcIj48L3BhdGg+PC9zdmc+JyxmPVxcXCJcXFwiLGc9MDtmPSc8ZGl2IGNsYXNzPVxcXCJmci1saW5rLWluc2VydC1sYXllciBmci1sYXllciBmci1hY3RpdmVcXFwiIGlkPVxcXCJmci1saW5rLWluc2VydC1sYXllci0nK2IuaWQrJ1xcXCI+JyxmKz0nPGRpdiBjbGFzcz1cXFwiZnItaW5wdXQtbGluZVxcXCI+PGlucHV0IGlkPVxcXCJmci1saW5rLWluc2VydC1sYXllci11cmwtJytiLmlkKydcXFwiIG5hbWU9XFxcImhyZWZcXFwiIHR5cGU9XFxcInRleHRcXFwiIGNsYXNzPVxcXCJmci1saW5rLWF0dHJcXFwiIHBsYWNlaG9sZGVyPVxcXCJVUkxcXFwiIHRhYkluZGV4PVxcXCInKyArK2crJ1xcXCI+PC9kaXY+JyxiLm9wdHMubGlua1RleHQmJihmKz0nPGRpdiBjbGFzcz1cXFwiZnItaW5wdXQtbGluZVxcXCI+PGlucHV0IGlkPVxcXCJmci1saW5rLWluc2VydC1sYXllci10ZXh0LScrYi5pZCsnXFxcIiBuYW1lPVxcXCJ0ZXh0XFxcIiB0eXBlPVxcXCJ0ZXh0XFxcIiBjbGFzcz1cXFwiZnItbGluay1hdHRyXFxcIiBwbGFjZWhvbGRlcj1cXFwiJytiLmxhbmd1YWdlLnRyYW5zbGF0ZShcXFwiVGV4dFxcXCIpKydcXFwiIHRhYkluZGV4PVxcXCInKyArK2crJ1xcXCI+PC9kaXY+Jyk7Zm9yKHZhciBoIGluIGIub3B0cy5saW5rQXR0cmlidXRlcylpZihiLm9wdHMubGlua0F0dHJpYnV0ZXMuaGFzT3duUHJvcGVydHkoaCkpe3ZhciBrPWIub3B0cy5saW5rQXR0cmlidXRlc1toXTtmKz0nPGRpdiBjbGFzcz1cXFwiZnItaW5wdXQtbGluZVxcXCI+PGlucHV0IG5hbWU9XFxcIicraCsnXFxcIiB0eXBlPVxcXCJ0ZXh0XFxcIiBjbGFzcz1cXFwiZnItbGluay1hdHRyXFxcIiBwbGFjZWhvbGRlcj1cXFwiJytiLmxhbmd1YWdlLnRyYW5zbGF0ZShrKSsnXFxcIiB0YWJJbmRleD1cXFwiJysgKytnKydcXFwiPjwvZGl2Pid9Yi5vcHRzLmxpbmtBbHdheXNCbGFua3x8KGYrPSc8ZGl2IGNsYXNzPVxcXCJmci1jaGVja2JveC1saW5lXFxcIj48c3BhbiBjbGFzcz1cXFwiZnItY2hlY2tib3hcXFwiPjxpbnB1dCBuYW1lPVxcXCJ0YXJnZXRcXFwiIGNsYXNzPVxcXCJmci1saW5rLWF0dHJcXFwiIGRhdGEtY2hlY2tlZD1cXFwiX2JsYW5rXFxcIiB0eXBlPVxcXCJjaGVja2JveFxcXCIgaWQ9XFxcImZyLWxpbmstdGFyZ2V0LScrYi5pZCsnXFxcIiB0YWJJbmRleD1cXFwiJysgKytnKydcXFwiPjxzcGFuPicrZSsnPC9zcGFuPjwvc3Bhbj48bGFiZWwgZm9yPVxcXCJmci1saW5rLXRhcmdldC0nK2IuaWQrJ1xcXCI+JytiLmxhbmd1YWdlLnRyYW5zbGF0ZShcXFwiT3BlbiBpbiBuZXcgdGFiXFxcIikrXFxcIjwvbGFiZWw+PC9kaXY+XFxcIiksZis9JzxkaXYgY2xhc3M9XFxcImZyLWFjdGlvbi1idXR0b25zXFxcIj48YnV0dG9uIGNsYXNzPVxcXCJmci1jb21tYW5kIGZyLXN1Ym1pdFxcXCIgcm9sZT1cXFwiYnV0dG9uXFxcIiBkYXRhLWNtZD1cXFwibGlua0luc2VydFxcXCIgaHJlZj1cXFwiI1xcXCIgdGFiSW5kZXg9XFxcIicrICsrZysnXFxcIiB0eXBlPVxcXCJidXR0b25cXFwiPicrYi5sYW5ndWFnZS50cmFuc2xhdGUoXFxcIkluc2VydFxcXCIpK1xcXCI8L2J1dHRvbj48L2Rpdj48L2Rpdj5cXFwiO3ZhciBsPXtidXR0b25zOmQsaW5wdXRfbGF5ZXI6Zn0sbT1iLnBvcHVwcy5jcmVhdGUoXFxcImxpbmsuaW5zZXJ0XFxcIixsKTtyZXR1cm4gYi4kd3AmJmIuZXZlbnRzLiRvbihiLiR3cCxcXFwic2Nyb2xsLmxpbmstaW5zZXJ0XFxcIixmdW5jdGlvbigpe3ZhciBhPWIuaW1hZ2U/Yi5pbWFnZS5nZXQoKTpudWxsO2EmJmIucG9wdXBzLmlzVmlzaWJsZShcXFwibGluay5pbnNlcnRcXFwiKSYmdSgpLGMmJmIucG9wdXBzLmlzVmlzaWJsZShcXFwibGluay5pbnNlcnRcXFwiKSYmcygpfSksbX1mdW5jdGlvbiBtKCl7dmFyIGQ9YygpLGU9Yi5pbWFnZT9iLmltYWdlLmdldCgpOm51bGw7cmV0dXJuIGIuZXZlbnRzLnRyaWdnZXIoXFxcImxpbmsuYmVmb3JlUmVtb3ZlXFxcIixbZF0pIT09ITEmJnZvaWQoZSYmZD8oZS51bndyYXAoKSxiLmltYWdlLmVkaXQoZSkpOmQmJihiLnNlbGVjdGlvbi5zYXZlKCksYShkKS5yZXBsYWNlV2l0aChhKGQpLmh0bWwoKSksYi5zZWxlY3Rpb24ucmVzdG9yZSgpLGcoKSkpfWZ1bmN0aW9uIG4oKXtiLmV2ZW50cy5vbihcXFwia2V5dXBcXFwiLGZ1bmN0aW9uKGIpe2Iud2hpY2ghPWEuRkUuS0VZQ09ERS5FU0MmJmUoYil9KSxiLmV2ZW50cy5vbihcXFwid2luZG93Lm1vdXNldXBcXFwiLGUpLGIuaGVscGVycy5pc01vYmlsZSgpJiZiLmV2ZW50cy4kb24oYi4kZG9jLFxcXCJzZWxlY3Rpb25jaGFuZ2VcXFwiLGUpLGwoITApLFxcXCJBXFxcIj09Yi5lbC50YWdOYW1lJiZiLiRlbC5hZGRDbGFzcyhcXFwiZnItdmlld1xcXCIpLGIuZXZlbnRzLm9uKFxcXCJ0b29sYmFyLmVzY1xcXCIsZnVuY3Rpb24oKXtpZihiLnBvcHVwcy5pc1Zpc2libGUoXFxcImxpbmsuZWRpdFxcXCIpKXJldHVybiBiLmV2ZW50cy5kaXNhYmxlQmx1cigpLGIuZXZlbnRzLmZvY3VzKCksITF9LCEwKX1mdW5jdGlvbiBvKGMpe3ZhciBkLGUsZj1iLm9wdHMubGlua0xpc3RbY10sZz1iLnBvcHVwcy5nZXQoXFxcImxpbmsuaW5zZXJ0XFxcIiksaD1nLmZpbmQoJ2lucHV0LmZyLWxpbmstYXR0clt0eXBlPVxcXCJ0ZXh0XFxcIl0nKSxpPWcuZmluZCgnaW5wdXQuZnItbGluay1hdHRyW3R5cGU9XFxcImNoZWNrYm94XFxcIl0nKTtmb3IoZT0wO2U8aC5sZW5ndGg7ZSsrKWQ9YShoW2VdKSxmW2QuYXR0cihcXFwibmFtZVxcXCIpXT9kLnZhbChmW2QuYXR0cihcXFwibmFtZVxcXCIpXSk6XFxcInRleHRcXFwiIT1kLmF0dHIoXFxcIm5hbWVcXFwiKSYmZC52YWwoXFxcIlxcXCIpO2ZvcihlPTA7ZTxpLmxlbmd0aDtlKyspZD1hKGlbZV0pLGQucHJvcChcXFwiY2hlY2tlZFxcXCIsZC5kYXRhKFxcXCJjaGVja2VkXFxcIik9PWZbZC5hdHRyKFxcXCJuYW1lXFxcIildKTtiLmFjY2Vzc2liaWxpdHkuZm9jdXNQb3B1cChnKX1mdW5jdGlvbiBwKCl7dmFyIGMsZCxlPWIucG9wdXBzLmdldChcXFwibGluay5pbnNlcnRcXFwiKSxmPWUuZmluZCgnaW5wdXQuZnItbGluay1hdHRyW3R5cGU9XFxcInRleHRcXFwiXScpLGc9ZS5maW5kKCdpbnB1dC5mci1saW5rLWF0dHJbdHlwZT1cXFwiY2hlY2tib3hcXFwiXScpLGg9Zi5maWx0ZXIoJ1tuYW1lPVxcXCJocmVmXFxcIl0nKS52YWwoKSxpPWYuZmlsdGVyKCdbbmFtZT1cXFwidGV4dFxcXCJdJykudmFsKCksaj17fTtmb3IoZD0wO2Q8Zi5sZW5ndGg7ZCsrKWM9YShmW2RdKSxbXFxcImhyZWZcXFwiLFxcXCJ0ZXh0XFxcIl0uaW5kZXhPZihjLmF0dHIoXFxcIm5hbWVcXFwiKSk8MCYmKGpbYy5hdHRyKFxcXCJuYW1lXFxcIildPWMudmFsKCkpO2ZvcihkPTA7ZDxnLmxlbmd0aDtkKyspYz1hKGdbZF0pLGMuaXMoXFxcIjpjaGVja2VkXFxcIik/altjLmF0dHIoXFxcIm5hbWVcXFwiKV09Yy5kYXRhKFxcXCJjaGVja2VkXFxcIik6altjLmF0dHIoXFxcIm5hbWVcXFwiKV09Yy5kYXRhKFxcXCJ1bmNoZWNrZWRcXFwiKTt2YXIgaz1hKGIub193aW4pLnNjcm9sbFRvcCgpO3IoaCxpLGopLGEoYi5vX3dpbikuc2Nyb2xsVG9wKGspfWZ1bmN0aW9uIHEoKXtpZighYi5zZWxlY3Rpb24uaXNDb2xsYXBzZWQoKSl7Yi5zZWxlY3Rpb24uc2F2ZSgpO2Zvcih2YXIgYz1iLiRlbC5maW5kKFxcXCIuZnItbWFya2VyXFxcIikuYWRkQ2xhc3MoXFxcImZyLXVucHJvY2Vzc2VkXFxcIikudG9BcnJheSgpO2MubGVuZ3RoOyl7dmFyIGQ9YShjLnBvcCgpKTtkLnJlbW92ZUNsYXNzKFxcXCJmci11bnByb2Nlc3NlZFxcXCIpO3ZhciBlPWIubm9kZS5kZWVwZXN0UGFyZW50KGQuZ2V0KDApKTtpZihlKXt2YXIgZj1kLmdldCgwKSxnPVxcXCJcXFwiLGg9XFxcIlxcXCI7ZG8gZj1mLnBhcmVudE5vZGUsYi5ub2RlLmlzQmxvY2soZil8fChnKz1iLm5vZGUuY2xvc2VUYWdTdHJpbmcoZiksaD1iLm5vZGUub3BlblRhZ1N0cmluZyhmKStoKTt3aGlsZShmIT1lKTt2YXIgaT1iLm5vZGUub3BlblRhZ1N0cmluZyhkLmdldCgwKSkrZC5odG1sKCkrYi5ub2RlLmNsb3NlVGFnU3RyaW5nKGQuZ2V0KDApKTtkLnJlcGxhY2VXaXRoKCc8c3BhbiBpZD1cXFwiZnItYnJlYWtcXFwiPjwvc3Bhbj4nKTt2YXIgaj1hKGUpLmh0bWwoKTtqPWoucmVwbGFjZSgvPHNwYW4gaWQ9XFxcImZyLWJyZWFrXFxcIj48XFxcXC9zcGFuPi9nLGcraStoKSxhKGUpLmh0bWwoail9Yz1iLiRlbC5maW5kKFxcXCIuZnItbWFya2VyLmZyLXVucHJvY2Vzc2VkXFxcIikudG9BcnJheSgpfWIuc2VsZWN0aW9uLnJlc3RvcmUoKX19ZnVuY3Rpb24gcihmLGcsaCl7aWYoXFxcInVuZGVmaW5lZFxcXCI9PXR5cGVvZiBoJiYoaD17fSksYi5ldmVudHMudHJpZ2dlcihcXFwibGluay5iZWZvcmVJbnNlcnRcXFwiLFtmLGcsaF0pPT09ITEpcmV0dXJuITE7dmFyIGk9Yi5pbWFnZT9iLmltYWdlLmdldCgpOm51bGw7aXx8XFxcIkFcXFwiPT1iLmVsLnRhZ05hbWU/XFxcIkFcXFwiPT1iLmVsLnRhZ05hbWUmJmIuJGVsLmZvY3VzKCk6KGIuc2VsZWN0aW9uLnJlc3RvcmUoKSxiLnBvcHVwcy5oaWRlKFxcXCJsaW5rLmluc2VydFxcXCIpKTt2YXIgaj1mO2lmKGIub3B0cy5saW5rQ29udmVydEVtYWlsQWRkcmVzcyl7dmFyIGs9L15bXFxcXHcuX10rQFthLXpcXFxcdTAwYTEtXFxcXHVmZmZmMC05Xy1dKz9cXFxcLlthLXpcXFxcdTAwYTEtXFxcXHVmZmZmMC05XXsyLH0kL2k7ay50ZXN0KGYpJiYhL15tYWlsdG86LiovaS50ZXN0KGYpJiYoZj1cXFwibWFpbHRvOlxcXCIrZil9aWYoXFxcIlxcXCI9PT1iLm9wdHMubGlua0F1dG9QcmVmaXh8fC9eKG1haWx0b3x0ZWx8c21zfG5vdGVzfGRhdGEpOi4qL2kudGVzdChmKXx8L15kYXRhOmltYWdlLiovaS50ZXN0KGYpfHwvXihodHRwcz86fGZ0cHM/OnxmaWxlOnwpXFxcXC9cXFxcLy9pLnRlc3QoZil8fFtcXFwiL1xcXCIsXFxcIntcXFwiLFxcXCJbXFxcIixcXFwiI1xcXCIsXFxcIihcXFwiXS5pbmRleE9mKChmfHxcXFwiXFxcIilbMF0pPDAmJihmPWIub3B0cy5saW5rQXV0b1ByZWZpeCtmKSxmPWIuaGVscGVycy5zYW5pdGl6ZVVSTChmKSxiLm9wdHMubGlua0Fsd2F5c0JsYW5rJiYoaC50YXJnZXQ9XFxcIl9ibGFua1xcXCIpLGIub3B0cy5saW5rQWx3YXlzTm9Gb2xsb3cmJihoLnJlbD1cXFwibm9mb2xsb3dcXFwiKSxcXFwiX2JsYW5rXFxcIj09aC50YXJnZXQmJihoLnJlbD9oLnJlbCs9XFxcIiBub29wZW5lciBub3JlZmVycmVyXFxcIjpoLnJlbD1cXFwibm9vcGVuZXIgbm9yZWZlcnJlclxcXCIpLGc9Z3x8XFxcIlxcXCIsZj09PWIub3B0cy5saW5rQXV0b1ByZWZpeCl7dmFyIGw9Yi5wb3B1cHMuZ2V0KFxcXCJsaW5rLmluc2VydFxcXCIpO3JldHVybiBsLmZpbmQoJ2lucHV0W25hbWU9XFxcImhyZWZcXFwiXScpLmFkZENsYXNzKFxcXCJmci1lcnJvclxcXCIpLGIuZXZlbnRzLnRyaWdnZXIoXFxcImxpbmsuYmFkXFxcIixbal0pLCExfXZhciBtLG49YygpO2lmKG4pe209YShuKTt2YXIgbz1iLm5vZGUucmF3QXR0cmlidXRlcyhuKTtmb3IodmFyIHAgaW4gbylvLmhhc093blByb3BlcnR5KHApJiZcXFwiY2xhc3NcXFwiIT1wJiZcXFwic3R5bGVcXFwiIT1wJiZcXFwiaWRcXFwiIT1wJiZcXFwiY29udGVudGVkaXRhYmxlXFxcIiE9cCYmbS5yZW1vdmVBdHRyKHApO20uYXR0cihcXFwiaHJlZlxcXCIsZiksZy5sZW5ndGg+MCYmbS50ZXh0KCkhPWcmJiFpJiZtLnRleHQoZyksaXx8bS5wcmVwZW5kKGEuRkUuU1RBUlRfTUFSS0VSKS5hcHBlbmQoYS5GRS5FTkRfTUFSS0VSKSxtLmF0dHIoaCksaXx8Yi5zZWxlY3Rpb24ucmVzdG9yZSgpfWVsc2V7aT9pLndyYXAoJzxhIGhyZWY9XFxcIicrZisnXFxcIj48L2E+Jyk6KGIuZm9ybWF0LnJlbW92ZShcXFwiYVxcXCIpLGIuc2VsZWN0aW9uLmlzQ29sbGFwc2VkKCk/KGc9MD09PWcubGVuZ3RoP2o6ZyxiLmh0bWwuaW5zZXJ0KCc8YSBocmVmPVxcXCInK2YrJ1xcXCI+JythLkZFLlNUQVJUX01BUktFUitnK2EuRkUuRU5EX01BUktFUitcXFwiPC9hPlxcXCIpLGIuc2VsZWN0aW9uLnJlc3RvcmUoKSk6Zy5sZW5ndGg+MCYmZyE9Yi5zZWxlY3Rpb24udGV4dCgpLnJlcGxhY2UoL1xcXFxuL2csXFxcIlxcXCIpPyhiLnNlbGVjdGlvbi5yZW1vdmUoKSxiLmh0bWwuaW5zZXJ0KCc8YSBocmVmPVxcXCInK2YrJ1xcXCI+JythLkZFLlNUQVJUX01BUktFUitnK2EuRkUuRU5EX01BUktFUitcXFwiPC9hPlxcXCIpLGIuc2VsZWN0aW9uLnJlc3RvcmUoKSk6KHEoKSxiLmZvcm1hdC5hcHBseShcXFwiYVxcXCIse2hyZWY6Zn0pKSk7Zm9yKHZhciByPWQoKSxzPTA7czxyLmxlbmd0aDtzKyspbT1hKHJbc10pLG0uYXR0cihoKSxtLnJlbW92ZUF0dHIoXFxcIl9tb3pfZGlydHlcXFwiKTsxPT1yLmxlbmd0aCYmYi4kd3AmJiFpJiYoYShyWzBdKS5wcmVwZW5kKGEuRkUuU1RBUlRfTUFSS0VSKS5hcHBlbmQoYS5GRS5FTkRfTUFSS0VSKSxiLnNlbGVjdGlvbi5yZXN0b3JlKCkpfWlmKGkpe3ZhciB0PWIucG9wdXBzLmdldChcXFwibGluay5pbnNlcnRcXFwiKTt0LmZpbmQoXFxcImlucHV0OmZvY3VzXFxcIikuYmx1cigpLGIuaW1hZ2UuZWRpdChpKX1lbHNlIGUoKX1mdW5jdGlvbiBzKCl7ZygpO3ZhciBkPWMoKTtpZihkKXt2YXIgZT1iLnBvcHVwcy5nZXQoXFxcImxpbmsuaW5zZXJ0XFxcIik7ZXx8KGU9bCgpKSxiLnBvcHVwcy5pc1Zpc2libGUoXFxcImxpbmsuaW5zZXJ0XFxcIil8fChiLnBvcHVwcy5yZWZyZXNoKFxcXCJsaW5rLmluc2VydFxcXCIpLGIuc2VsZWN0aW9uLnNhdmUoKSxiLmhlbHBlcnMuaXNNb2JpbGUoKSYmKGIuZXZlbnRzLmRpc2FibGVCbHVyKCksYi4kZWwuYmx1cigpLGIuZXZlbnRzLmVuYWJsZUJsdXIoKSkpLGIucG9wdXBzLnNldENvbnRhaW5lcihcXFwibGluay5pbnNlcnRcXFwiLGEoYi5vcHRzLnNjcm9sbGFibGVDb250YWluZXIpKTt2YXIgZj0oYi5pbWFnZT9iLmltYWdlLmdldCgpOm51bGwpfHxhKGQpLGg9Zi5vZmZzZXQoKS5sZWZ0K2Yub3V0ZXJXaWR0aCgpLzIsaT1mLm9mZnNldCgpLnRvcCtmLm91dGVySGVpZ2h0KCk7Yi5wb3B1cHMuc2hvdyhcXFwibGluay5pbnNlcnRcXFwiLGgsaSxmLm91dGVySGVpZ2h0KCkpfX1mdW5jdGlvbiB0KCl7dmFyIGE9Yi5pbWFnZT9iLmltYWdlLmdldCgpOm51bGw7aWYoYSliLmltYWdlLmJhY2soKTtlbHNle2IuZXZlbnRzLmRpc2FibGVCbHVyKCksYi5zZWxlY3Rpb24ucmVzdG9yZSgpLGIuZXZlbnRzLmVuYWJsZUJsdXIoKTt2YXIgZD1jKCk7ZCYmYi4kd3A/KGIuc2VsZWN0aW9uLnJlc3RvcmUoKSxnKCksZSgpKTpcXFwiQVxcXCI9PWIuZWwudGFnTmFtZT8oYi4kZWwuZm9jdXMoKSxlKCkpOihiLnBvcHVwcy5oaWRlKFxcXCJsaW5rLmluc2VydFxcXCIpLGIudG9vbGJhci5zaG93SW5saW5lKCkpfX1mdW5jdGlvbiB1KCl7dmFyIGM9Yi5pbWFnZT9iLmltYWdlLmdldCgpOm51bGw7aWYoYyl7dmFyIGQ9Yi5wb3B1cHMuZ2V0KFxcXCJsaW5rLmluc2VydFxcXCIpO2R8fChkPWwoKSksaighMCksYi5wb3B1cHMuc2V0Q29udGFpbmVyKFxcXCJsaW5rLmluc2VydFxcXCIsYShiLm9wdHMuc2Nyb2xsYWJsZUNvbnRhaW5lcikpO3ZhciBlPWMub2Zmc2V0KCkubGVmdCtjLm91dGVyV2lkdGgoKS8yLGY9Yy5vZmZzZXQoKS50b3ArYy5vdXRlckhlaWdodCgpO2IucG9wdXBzLnNob3coXFxcImxpbmsuaW5zZXJ0XFxcIixlLGYsYy5vdXRlckhlaWdodCgpKX19ZnVuY3Rpb24gdihkLGYsZyl7XFxcInVuZGVmaW5lZFxcXCI9PXR5cGVvZiBnJiYoZz1iLm9wdHMubGlua011bHRpcGxlU3R5bGVzKSxcXFwidW5kZWZpbmVkXFxcIj09dHlwZW9mIGYmJihmPWIub3B0cy5saW5rU3R5bGVzKTt2YXIgaD1jKCk7aWYoIWgpcmV0dXJuITE7aWYoIWcpe3ZhciBpPU9iamVjdC5rZXlzKGYpO2kuc3BsaWNlKGkuaW5kZXhPZihkKSwxKSxhKGgpLnJlbW92ZUNsYXNzKGkuam9pbihcXFwiIFxcXCIpKX1hKGgpLnRvZ2dsZUNsYXNzKGQpLGUoKX1yZXR1cm57X2luaXQ6bixyZW1vdmU6bSxzaG93SW5zZXJ0UG9wdXA6ayx1c2VQcmVkZWZpbmVkOm8saW5zZXJ0Q2FsbGJhY2s6cCxpbnNlcnQ6cix1cGRhdGU6cyxnZXQ6YyxhbGxTZWxlY3RlZDpkLGJhY2s6dCxpbWFnZUxpbms6dSxhcHBseVN0eWxlOnZ9fSxhLkZFLkRlZmluZUljb24oXFxcImluc2VydExpbmtcXFwiLHtOQU1FOlxcXCJsaW5rXFxcIn0pLGEuRkUuUmVnaXN0ZXJTaG9ydGN1dChhLkZFLktFWUNPREUuSyxcXFwiaW5zZXJ0TGlua1xcXCIsbnVsbCxcXFwiS1xcXCIpLGEuRkUuUmVnaXN0ZXJDb21tYW5kKFxcXCJpbnNlcnRMaW5rXFxcIix7dGl0bGU6XFxcIkluc2VydCBMaW5rXFxcIix1bmRvOiExLGZvY3VzOiEwLHJlZnJlc2hPbkNhbGxiYWNrOiExLHBvcHVwOiEwLGNhbGxiYWNrOmZ1bmN0aW9uKCl7dGhpcy5wb3B1cHMuaXNWaXNpYmxlKFxcXCJsaW5rLmluc2VydFxcXCIpPyh0aGlzLiRlbC5maW5kKFxcXCIuZnItbWFya2VyXFxcIikubGVuZ3RoJiYodGhpcy5ldmVudHMuZGlzYWJsZUJsdXIoKSx0aGlzLnNlbGVjdGlvbi5yZXN0b3JlKCkpLHRoaXMucG9wdXBzLmhpZGUoXFxcImxpbmsuaW5zZXJ0XFxcIikpOnRoaXMubGluay5zaG93SW5zZXJ0UG9wdXAoKX0scGx1Z2luOlxcXCJsaW5rXFxcIn0pLGEuRkUuRGVmaW5lSWNvbihcXFwibGlua09wZW5cXFwiLHtOQU1FOlxcXCJleHRlcm5hbC1saW5rXFxcIn0pLGEuRkUuUmVnaXN0ZXJDb21tYW5kKFxcXCJsaW5rT3BlblxcXCIse3RpdGxlOlxcXCJPcGVuIExpbmtcXFwiLHVuZG86ITEscmVmcmVzaDpmdW5jdGlvbihhKXt2YXIgYj10aGlzLmxpbmsuZ2V0KCk7Yj9hLnJlbW92ZUNsYXNzKFxcXCJmci1oaWRkZW5cXFwiKTphLmFkZENsYXNzKFxcXCJmci1oaWRkZW5cXFwiKX0sY2FsbGJhY2s6ZnVuY3Rpb24oKXt2YXIgYT10aGlzLmxpbmsuZ2V0KCk7YSYmdGhpcy5vX3dpbi5vcGVuKGEuaHJlZil9fSksYS5GRS5EZWZpbmVJY29uKFxcXCJsaW5rRWRpdFxcXCIse05BTUU6XFxcImVkaXRcXFwifSksYS5GRS5SZWdpc3RlckNvbW1hbmQoXFxcImxpbmtFZGl0XFxcIix7dGl0bGU6XFxcIkVkaXQgTGlua1xcXCIsdW5kbzohMSxyZWZyZXNoQWZ0ZXJDYWxsYmFjazohMSxwb3B1cDohMCxjYWxsYmFjazpmdW5jdGlvbigpe3RoaXMubGluay51cGRhdGUoKX0scmVmcmVzaDpmdW5jdGlvbihhKXt2YXIgYj10aGlzLmxpbmsuZ2V0KCk7Yj9hLnJlbW92ZUNsYXNzKFxcXCJmci1oaWRkZW5cXFwiKTphLmFkZENsYXNzKFxcXCJmci1oaWRkZW5cXFwiKX19KSxhLkZFLkRlZmluZUljb24oXFxcImxpbmtSZW1vdmVcXFwiLHtOQU1FOlxcXCJ1bmxpbmtcXFwifSksYS5GRS5SZWdpc3RlckNvbW1hbmQoXFxcImxpbmtSZW1vdmVcXFwiLHt0aXRsZTpcXFwiVW5saW5rXFxcIixjYWxsYmFjazpmdW5jdGlvbigpe3RoaXMubGluay5yZW1vdmUoKX0scmVmcmVzaDpmdW5jdGlvbihhKXt2YXIgYj10aGlzLmxpbmsuZ2V0KCk7Yj9hLnJlbW92ZUNsYXNzKFxcXCJmci1oaWRkZW5cXFwiKTphLmFkZENsYXNzKFxcXCJmci1oaWRkZW5cXFwiKX19KSxhLkZFLkRlZmluZUljb24oXFxcImxpbmtCYWNrXFxcIix7TkFNRTpcXFwiYXJyb3ctbGVmdFxcXCJ9KSxhLkZFLlJlZ2lzdGVyQ29tbWFuZChcXFwibGlua0JhY2tcXFwiLHt0aXRsZTpcXFwiQmFja1xcXCIsdW5kbzohMSxmb2N1czohMSxiYWNrOiEwLHJlZnJlc2hBZnRlckNhbGxiYWNrOiExLGNhbGxiYWNrOmZ1bmN0aW9uKCl7dGhpcy5saW5rLmJhY2soKX0scmVmcmVzaDpmdW5jdGlvbihhKXt2YXIgYj10aGlzLmxpbmsuZ2V0KCkmJnRoaXMuZG9jLmhhc0ZvY3VzKCksYz10aGlzLmltYWdlP3RoaXMuaW1hZ2UuZ2V0KCk6bnVsbDtjfHxifHx0aGlzLm9wdHMudG9vbGJhcklubGluZT8oYS5yZW1vdmVDbGFzcyhcXFwiZnItaGlkZGVuXFxcIiksYS5uZXh0KFxcXCIuZnItc2VwYXJhdG9yXFxcIikucmVtb3ZlQ2xhc3MoXFxcImZyLWhpZGRlblxcXCIpKTooYS5hZGRDbGFzcyhcXFwiZnItaGlkZGVuXFxcIiksYS5uZXh0KFxcXCIuZnItc2VwYXJhdG9yXFxcIikuYWRkQ2xhc3MoXFxcImZyLWhpZGRlblxcXCIpKX19KSxhLkZFLkRlZmluZUljb24oXFxcImxpbmtMaXN0XFxcIix7TkFNRTpcXFwic2VhcmNoXFxcIn0pLGEuRkUuUmVnaXN0ZXJDb21tYW5kKFxcXCJsaW5rTGlzdFxcXCIse3RpdGxlOlxcXCJDaG9vc2UgTGlua1xcXCIsdHlwZTpcXFwiZHJvcGRvd25cXFwiLGZvY3VzOiExLHVuZG86ITEscmVmcmVzaEFmdGVyQ2FsbGJhY2s6ITEsaHRtbDpmdW5jdGlvbigpe2Zvcih2YXIgYT0nPHVsIGNsYXNzPVxcXCJmci1kcm9wZG93bi1saXN0XFxcIiByb2xlPVxcXCJwcmVzZW50YXRpb25cXFwiPicsYj10aGlzLm9wdHMubGlua0xpc3QsYz0wO2M8Yi5sZW5ndGg7YysrKWErPSc8bGkgcm9sZT1cXFwicHJlc2VudGF0aW9uXFxcIj48YSBjbGFzcz1cXFwiZnItY29tbWFuZFxcXCIgdGFiSW5kZXg9XFxcIi0xXFxcIiByb2xlPVxcXCJvcHRpb25cXFwiIGRhdGEtY21kPVxcXCJsaW5rTGlzdFxcXCIgZGF0YS1wYXJhbTE9XFxcIicrYysnXFxcIj4nKyhiW2NdLmRpc3BsYXlUZXh0fHxiW2NdLnRleHQpK1xcXCI8L2E+PC9saT5cXFwiO3JldHVybiBhKz1cXFwiPC91bD5cXFwifSxjYWxsYmFjazpmdW5jdGlvbihhLGIpe3RoaXMubGluay51c2VQcmVkZWZpbmVkKGIpfX0pLGEuRkUuUmVnaXN0ZXJDb21tYW5kKFxcXCJsaW5rSW5zZXJ0XFxcIix7Zm9jdXM6ITEscmVmcmVzaEFmdGVyQ2FsbGJhY2s6ITEsY2FsbGJhY2s6ZnVuY3Rpb24oKXt0aGlzLmxpbmsuaW5zZXJ0Q2FsbGJhY2soKX0scmVmcmVzaDpmdW5jdGlvbihhKXt2YXIgYj10aGlzLmxpbmsuZ2V0KCk7Yj9hLnRleHQodGhpcy5sYW5ndWFnZS50cmFuc2xhdGUoXFxcIlVwZGF0ZVxcXCIpKTphLnRleHQodGhpcy5sYW5ndWFnZS50cmFuc2xhdGUoXFxcIkluc2VydFxcXCIpKX19KSxhLkZFLkRlZmluZUljb24oXFxcImltYWdlTGlua1xcXCIse05BTUU6XFxcImxpbmtcXFwifSksYS5GRS5SZWdpc3RlckNvbW1hbmQoXFxcImltYWdlTGlua1xcXCIse3RpdGxlOlxcXCJJbnNlcnQgTGlua1xcXCIsdW5kbzohMSxmb2N1czohMSxwb3B1cDohMCxjYWxsYmFjazpmdW5jdGlvbigpe3RoaXMubGluay5pbWFnZUxpbmsoKX0scmVmcmVzaDpmdW5jdGlvbihhKXt2YXIgYixjPXRoaXMubGluay5nZXQoKTtjPyhiPWEucHJldigpLGIuaGFzQ2xhc3MoXFxcImZyLXNlcGFyYXRvclxcXCIpJiZiLnJlbW92ZUNsYXNzKFxcXCJmci1oaWRkZW5cXFwiKSxhLmFkZENsYXNzKFxcXCJmci1oaWRkZW5cXFwiKSk6KGI9YS5wcmV2KCksYi5oYXNDbGFzcyhcXFwiZnItc2VwYXJhdG9yXFxcIikmJmIuYWRkQ2xhc3MoXFxcImZyLWhpZGRlblxcXCIpLGEucmVtb3ZlQ2xhc3MoXFxcImZyLWhpZGRlblxcXCIpKX19KSxhLkZFLkRlZmluZUljb24oXFxcImxpbmtTdHlsZVxcXCIse05BTUU6XFxcIm1hZ2ljXFxcIn0pLGEuRkUuUmVnaXN0ZXJDb21tYW5kKFxcXCJsaW5rU3R5bGVcXFwiLHt0aXRsZTpcXFwiU3R5bGVcXFwiLHR5cGU6XFxcImRyb3Bkb3duXFxcIixodG1sOmZ1bmN0aW9uKCl7dmFyIGE9Jzx1bCBjbGFzcz1cXFwiZnItZHJvcGRvd24tbGlzdFxcXCIgcm9sZT1cXFwicHJlc2VudGF0aW9uXFxcIj4nLGI9dGhpcy5vcHRzLmxpbmtTdHlsZXM7Zm9yKHZhciBjIGluIGIpYi5oYXNPd25Qcm9wZXJ0eShjKSYmKGErPSc8bGkgcm9sZT1cXFwicHJlc2VudGF0aW9uXFxcIj48YSBjbGFzcz1cXFwiZnItY29tbWFuZFxcXCIgdGFiSW5kZXg9XFxcIi0xXFxcIiByb2xlPVxcXCJvcHRpb25cXFwiIGRhdGEtY21kPVxcXCJsaW5rU3R5bGVcXFwiIGRhdGEtcGFyYW0xPVxcXCInK2MrJ1xcXCI+Jyt0aGlzLmxhbmd1YWdlLnRyYW5zbGF0ZShiW2NdKStcXFwiPC9hPjwvbGk+XFxcIik7cmV0dXJuIGErPVxcXCI8L3VsPlxcXCJ9LGNhbGxiYWNrOmZ1bmN0aW9uKGEsYil7dGhpcy5saW5rLmFwcGx5U3R5bGUoYil9LHJlZnJlc2hPblNob3c6ZnVuY3Rpb24oYixjKXt2YXIgZD10aGlzLmxpbmsuZ2V0KCk7aWYoZCl7dmFyIGU9YShkKTtjLmZpbmQoXFxcIi5mci1jb21tYW5kXFxcIikuZWFjaChmdW5jdGlvbigpe3ZhciBiPWEodGhpcykuZGF0YShcXFwicGFyYW0xXFxcIiksYz1lLmhhc0NsYXNzKGIpO2EodGhpcykudG9nZ2xlQ2xhc3MoXFxcImZyLWFjdGl2ZVxcXCIsYykuYXR0cihcXFwiYXJpYS1zZWxlY3RlZFxcXCIsYyl9KX19fSl9KTtcIlxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yYXctbG9hZGVyIS4vfi9mcm9hbGEtZWRpdG9yL2pzL3BsdWdpbnMvbGluay5taW4uanNcbi8vIG1vZHVsZSBpZCA9IDE3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

	eval("__webpack_require__(2)(__webpack_require__(19))//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTguanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2Zyb2FsYS1lZGl0b3IvanMvcGx1Z2lucy91cmwubWluLmpzPzY2NWYiXSwic291cmNlc0NvbnRlbnQiOlsicmVxdWlyZShcIiEhL3Zhci9hcHAvd2ViL2pzL25vZGVfbW9kdWxlcy9zY3JpcHQtbG9hZGVyL2FkZFNjcmlwdC5qc1wiKShyZXF1aXJlKFwiISEvdmFyL2FwcC93ZWIvanMvbm9kZV9tb2R1bGVzL3Jhdy1sb2FkZXIvaW5kZXguanMhL3Zhci9hcHAvd2ViL2pzL25vZGVfbW9kdWxlcy9mcm9hbGEtZWRpdG9yL2pzL3BsdWdpbnMvdXJsLm1pbi5qc1wiKSlcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vc2NyaXB0LWxvYWRlciEuL34vZnJvYWxhLWVkaXRvci9qcy9wbHVnaW5zL3VybC5taW4uanNcbi8vIG1vZHVsZSBpZCA9IDE4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 19 */
/***/ function(module, exports) {

	eval("module.exports = \"/*!\\n * froala_editor v2.4.0 (https://www.froala.com/wysiwyg-editor)\\n * License https://froala.com/wysiwyg-editor/terms/\\n * Copyright 2014-2016 Froala Labs\\n */\\n\\n!function(a){\\\"function\\\"==typeof define&&define.amd?define([\\\"jquery\\\"],a):\\\"object\\\"==typeof module&&module.exports?module.exports=function(b,c){return void 0===c&&(c=\\\"undefined\\\"!=typeof window?require(\\\"jquery\\\"):require(\\\"jquery\\\")(b)),a(c),c}:a(jQuery)}(function(a){a.extend(a.FE.DEFAULTS,{}),a.FE.URLRegEx=/(\\\\s|^|>)((http|https|ftp|ftps)\\\\:\\\\/\\\\/[a-zA-Z0-9\\\\-\\\\.]+(\\\\.[a-zA-Z]{2,3})?(:\\\\d*)?(\\\\/[^\\\\s<]*)?)(\\\\s|$|<)/gi,a.FE.PLUGINS.url=function(b){function c(a){for(;a.parentNode;)if(a=a.parentNode,[\\\"A\\\",\\\"BUTTON\\\",\\\"TEXTAREA\\\"].indexOf(a.tagName)>=0)return!0;return!1}function d(){for(var d=b.doc.createTreeWalker(b.el,NodeFilter.SHOW_TEXT,b.node.filter(function(b){return a.FE.URLRegEx.test(b.textContent.replace(/&nbsp;/gi,\\\"\\\"))&&!c(b)}),!1);d.nextNode();){var e=d.currentNode,f=null;b.opts.linkAlwaysNoFollow&&(f=\\\"nofollow\\\"),b.opts.linkAlwaysBlank&&(f?f+=\\\" noopener noreferrer\\\":f=\\\"noopener noreferrer\\\"),a(e).before(e.textContent.replace(a.FE.URLRegEx,\\\"$1<a\\\"+(b.opts.linkAlwaysBlank?' target=\\\"_blank\\\"':\\\"\\\")+(f?' rel=\\\"'+f+'\\\"':\\\"\\\")+' href=\\\"$2\\\">$2</a>$7')),e.parentNode.removeChild(e)}}function e(){b.events.on(\\\"paste.afterCleanup\\\",function(c){if(a.FE.URLRegEx.test(c))return c.replace(a.FE.URLRegEx,\\\"$1<a\\\"+(b.opts.linkAlwaysBlank?' target=\\\"_blank\\\"':\\\"\\\")+(b.opts.linkAlwaysNoFollow?' rel=\\\"nofollow\\\"':\\\"\\\")+' href=\\\"$2\\\">$2</a>$7')}),b.events.on(\\\"keyup\\\",function(c){var e=c.which;e!=a.FE.KEYCODE.ENTER&&e!=a.FE.KEYCODE.SPACE||d(b.node.contents(b.el))}),b.events.on(\\\"keydown\\\",function(c){var d=c.which;if(d==a.FE.KEYCODE.ENTER){var e=b.selection.element();if((\\\"A\\\"==e.tagName||a(e).parents(\\\"a\\\").length)&&b.selection.info(e).atEnd)return c.stopImmediatePropagation(),\\\"A\\\"!==e.tagName&&(e=a(e).parents(\\\"a\\\")[0]),a(e).after(\\\"&nbsp;\\\"+a.FE.MARKERS),b.selection.restore(),!1}})}return{_init:e}}});\"//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTkuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2Zyb2FsYS1lZGl0b3IvanMvcGx1Z2lucy91cmwubWluLmpzP2E1NmIiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBcIi8qIVxcbiAqIGZyb2FsYV9lZGl0b3IgdjIuNC4wIChodHRwczovL3d3dy5mcm9hbGEuY29tL3d5c2l3eWctZWRpdG9yKVxcbiAqIExpY2Vuc2UgaHR0cHM6Ly9mcm9hbGEuY29tL3d5c2l3eWctZWRpdG9yL3Rlcm1zL1xcbiAqIENvcHlyaWdodCAyMDE0LTIwMTYgRnJvYWxhIExhYnNcXG4gKi9cXG5cXG4hZnVuY3Rpb24oYSl7XFxcImZ1bmN0aW9uXFxcIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUoW1xcXCJqcXVlcnlcXFwiXSxhKTpcXFwib2JqZWN0XFxcIj09dHlwZW9mIG1vZHVsZSYmbW9kdWxlLmV4cG9ydHM/bW9kdWxlLmV4cG9ydHM9ZnVuY3Rpb24oYixjKXtyZXR1cm4gdm9pZCAwPT09YyYmKGM9XFxcInVuZGVmaW5lZFxcXCIhPXR5cGVvZiB3aW5kb3c/cmVxdWlyZShcXFwianF1ZXJ5XFxcIik6cmVxdWlyZShcXFwianF1ZXJ5XFxcIikoYikpLGEoYyksY306YShqUXVlcnkpfShmdW5jdGlvbihhKXthLmV4dGVuZChhLkZFLkRFRkFVTFRTLHt9KSxhLkZFLlVSTFJlZ0V4PS8oXFxcXHN8Xnw+KSgoaHR0cHxodHRwc3xmdHB8ZnRwcylcXFxcOlxcXFwvXFxcXC9bYS16QS1aMC05XFxcXC1cXFxcLl0rKFxcXFwuW2EtekEtWl17MiwzfSk/KDpcXFxcZCopPyhcXFxcL1teXFxcXHM8XSopPykoXFxcXHN8JHw8KS9naSxhLkZFLlBMVUdJTlMudXJsPWZ1bmN0aW9uKGIpe2Z1bmN0aW9uIGMoYSl7Zm9yKDthLnBhcmVudE5vZGU7KWlmKGE9YS5wYXJlbnROb2RlLFtcXFwiQVxcXCIsXFxcIkJVVFRPTlxcXCIsXFxcIlRFWFRBUkVBXFxcIl0uaW5kZXhPZihhLnRhZ05hbWUpPj0wKXJldHVybiEwO3JldHVybiExfWZ1bmN0aW9uIGQoKXtmb3IodmFyIGQ9Yi5kb2MuY3JlYXRlVHJlZVdhbGtlcihiLmVsLE5vZGVGaWx0ZXIuU0hPV19URVhULGIubm9kZS5maWx0ZXIoZnVuY3Rpb24oYil7cmV0dXJuIGEuRkUuVVJMUmVnRXgudGVzdChiLnRleHRDb250ZW50LnJlcGxhY2UoLyZuYnNwOy9naSxcXFwiXFxcIikpJiYhYyhiKX0pLCExKTtkLm5leHROb2RlKCk7KXt2YXIgZT1kLmN1cnJlbnROb2RlLGY9bnVsbDtiLm9wdHMubGlua0Fsd2F5c05vRm9sbG93JiYoZj1cXFwibm9mb2xsb3dcXFwiKSxiLm9wdHMubGlua0Fsd2F5c0JsYW5rJiYoZj9mKz1cXFwiIG5vb3BlbmVyIG5vcmVmZXJyZXJcXFwiOmY9XFxcIm5vb3BlbmVyIG5vcmVmZXJyZXJcXFwiKSxhKGUpLmJlZm9yZShlLnRleHRDb250ZW50LnJlcGxhY2UoYS5GRS5VUkxSZWdFeCxcXFwiJDE8YVxcXCIrKGIub3B0cy5saW5rQWx3YXlzQmxhbms/JyB0YXJnZXQ9XFxcIl9ibGFua1xcXCInOlxcXCJcXFwiKSsoZj8nIHJlbD1cXFwiJytmKydcXFwiJzpcXFwiXFxcIikrJyBocmVmPVxcXCIkMlxcXCI+JDI8L2E+JDcnKSksZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGUpfX1mdW5jdGlvbiBlKCl7Yi5ldmVudHMub24oXFxcInBhc3RlLmFmdGVyQ2xlYW51cFxcXCIsZnVuY3Rpb24oYyl7aWYoYS5GRS5VUkxSZWdFeC50ZXN0KGMpKXJldHVybiBjLnJlcGxhY2UoYS5GRS5VUkxSZWdFeCxcXFwiJDE8YVxcXCIrKGIub3B0cy5saW5rQWx3YXlzQmxhbms/JyB0YXJnZXQ9XFxcIl9ibGFua1xcXCInOlxcXCJcXFwiKSsoYi5vcHRzLmxpbmtBbHdheXNOb0ZvbGxvdz8nIHJlbD1cXFwibm9mb2xsb3dcXFwiJzpcXFwiXFxcIikrJyBocmVmPVxcXCIkMlxcXCI+JDI8L2E+JDcnKX0pLGIuZXZlbnRzLm9uKFxcXCJrZXl1cFxcXCIsZnVuY3Rpb24oYyl7dmFyIGU9Yy53aGljaDtlIT1hLkZFLktFWUNPREUuRU5URVImJmUhPWEuRkUuS0VZQ09ERS5TUEFDRXx8ZChiLm5vZGUuY29udGVudHMoYi5lbCkpfSksYi5ldmVudHMub24oXFxcImtleWRvd25cXFwiLGZ1bmN0aW9uKGMpe3ZhciBkPWMud2hpY2g7aWYoZD09YS5GRS5LRVlDT0RFLkVOVEVSKXt2YXIgZT1iLnNlbGVjdGlvbi5lbGVtZW50KCk7aWYoKFxcXCJBXFxcIj09ZS50YWdOYW1lfHxhKGUpLnBhcmVudHMoXFxcImFcXFwiKS5sZW5ndGgpJiZiLnNlbGVjdGlvbi5pbmZvKGUpLmF0RW5kKXJldHVybiBjLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpLFxcXCJBXFxcIiE9PWUudGFnTmFtZSYmKGU9YShlKS5wYXJlbnRzKFxcXCJhXFxcIilbMF0pLGEoZSkuYWZ0ZXIoXFxcIiZuYnNwO1xcXCIrYS5GRS5NQVJLRVJTKSxiLnNlbGVjdGlvbi5yZXN0b3JlKCksITF9fSl9cmV0dXJue19pbml0OmV9fX0pO1wiXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3Jhdy1sb2FkZXIhLi9+L2Zyb2FsYS1lZGl0b3IvanMvcGx1Z2lucy91cmwubWluLmpzXG4vLyBtb2R1bGUgaWQgPSAxOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {

	eval("__webpack_require__(2)(__webpack_require__(21))//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjAuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2Zyb2FsYS1lZGl0b3IvanMvbGFuZ3VhZ2VzL2VuX2diLmpzPzczYTgiXSwic291cmNlc0NvbnRlbnQiOlsicmVxdWlyZShcIiEhL3Zhci9hcHAvd2ViL2pzL25vZGVfbW9kdWxlcy9zY3JpcHQtbG9hZGVyL2FkZFNjcmlwdC5qc1wiKShyZXF1aXJlKFwiISEvdmFyL2FwcC93ZWIvanMvbm9kZV9tb2R1bGVzL3Jhdy1sb2FkZXIvaW5kZXguanMhL3Zhci9hcHAvd2ViL2pzL25vZGVfbW9kdWxlcy9mcm9hbGEtZWRpdG9yL2pzL2xhbmd1YWdlcy9lbl9nYi5qc1wiKSlcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vc2NyaXB0LWxvYWRlciEuL34vZnJvYWxhLWVkaXRvci9qcy9sYW5ndWFnZXMvZW5fZ2IuanNcbi8vIG1vZHVsZSBpZCA9IDIwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 21 */
/***/ function(module, exports) {

	eval("module.exports = \"/*!\\n * froala_editor v2.4.0 (https://www.froala.com/wysiwyg-editor)\\n * License https://froala.com/wysiwyg-editor/terms/\\n * Copyright 2014-2016 Froala Labs\\n */\\n\\n/**\\n * English spoken in Great Britain\\n */\\n\\n$.FE.LANGUAGE['en_gb'] = {\\n  translation: {\\n    // Place holder\\n    \\\"Type something\\\": \\\"Type something\\\",\\n\\n    // Basic formatting\\n    \\\"Bold\\\": \\\"Bold\\\",\\n    \\\"Italic\\\": \\\"Italic\\\",\\n    \\\"Underline\\\": \\\"Underline\\\",\\n    \\\"Strikethrough\\\": \\\"Strikethrough\\\",\\n\\n    // Main buttons\\n    \\\"Insert\\\": \\\"Insert\\\",\\n    \\\"Delete\\\": \\\"Delete\\\",\\n    \\\"Cancel\\\": \\\"Cancel\\\",\\n    \\\"OK\\\": \\\"OK\\\",\\n    \\\"Back\\\": \\\"Back\\\",\\n    \\\"Remove\\\": \\\"Remove\\\",\\n    \\\"More\\\": \\\"More\\\",\\n    \\\"Update\\\": \\\"Update\\\",\\n    \\\"Style\\\": \\\"Style\\\",\\n\\n    // Font\\n    \\\"Font Family\\\": \\\"Font Family\\\",\\n    \\\"Font Size\\\": \\\"Font Size\\\",\\n\\n    // Colors\\n    \\\"Colors\\\": \\\"Colours\\\",\\n    \\\"Background\\\": \\\"Background\\\",\\n    \\\"Text\\\": \\\"Text\\\",\\n\\n    // Paragraphs\\n    \\\"Paragraph Format\\\": \\\"Paragraph Format\\\",\\n    \\\"Normal\\\": \\\"Normal\\\",\\n    \\\"Code\\\": \\\"Code\\\",\\n    \\\"Heading 1\\\": \\\"Heading 1\\\",\\n    \\\"Heading 2\\\": \\\"Heading 2\\\",\\n    \\\"Heading 3\\\": \\\"Heading 3\\\",\\n    \\\"Heading 4\\\": \\\"Heading 4\\\",\\n\\n    // Style\\n    \\\"Paragraph Style\\\": \\\"Paragraph Style\\\",\\n    \\\"Inline Style\\\": \\\"Inline Style\\\",\\n\\n    // Alignment\\n    \\\"Align\\\": \\\"Align\\\",\\n    \\\"Align Left\\\": \\\"Align Left\\\",\\n    \\\"Align Center\\\": \\\"Align Centre\\\",\\n    \\\"Align Right\\\": \\\"Alight Right\\\",\\n    \\\"Align Justify\\\": \\\"Align Justify\\\",\\n    \\\"None\\\": \\\"None\\\",\\n\\n    // Lists\\n    \\\"Ordered List\\\": \\\"Ordered List\\\",\\n    \\\"Unordered List\\\": \\\"Unordered List\\\",\\n\\n    // Indent\\n    \\\"Decrease Indent\\\": \\\"Decrease Indent\\\",\\n    \\\"Increase Indent\\\": \\\"Increase Indent\\\",\\n\\n    // Links\\n    \\\"Insert Link\\\": \\\"Insert Link\\\",\\n    \\\"Open in new tab\\\": \\\"Open in new tab\\\",\\n    \\\"Open Link\\\": \\\"Open Link\\\",\\n    \\\"Edit Link\\\": \\\"Edit Link\\\",\\n    \\\"Unlink\\\": \\\"Unlink\\\",\\n    \\\"Choose Link\\\": \\\"Choose Link\\\",\\n\\n    // Images\\n    \\\"Insert Image\\\": \\\"Insert Image\\\",\\n    \\\"Upload Image\\\": \\\"Upload Image\\\",\\n    \\\"By URL\\\": \\\"By URL\\\",\\n    \\\"Browse\\\": \\\"Browse\\\",\\n    \\\"Drop image\\\": \\\"Drop image\\\",\\n    \\\"or click\\\": \\\"or click\\\",\\n    \\\"Manage Images\\\": \\\"Manage Images\\\",\\n    \\\"Loading\\\": \\\"Loading\\\",\\n    \\\"Deleting\\\": \\\"Deleting\\\",\\n    \\\"Tags\\\": \\\"Tags\\\",\\n    \\\"Are you sure? Image will be deleted.\\\": \\\"Are you sure? Image will be deleted.\\\",\\n    \\\"Replace\\\": \\\"Replace\\\",\\n    \\\"Uploading\\\": \\\"Uploading\\\",\\n    \\\"Loading image\\\": \\\"Loading image\\\",\\n    \\\"Display\\\": \\\"Display\\\",\\n    \\\"Inline\\\": \\\"Inline\\\",\\n    \\\"Break Text\\\": \\\"Break Text\\\",\\n    \\\"Alternate Text\\\": \\\"Alternate Text\\\",\\n    \\\"Change Size\\\": \\\"Change Size\\\",\\n    \\\"Width\\\": \\\"Width\\\",\\n    \\\"Height\\\": \\\"Height\\\",\\n    \\\"Something went wrong. Please try again.\\\": \\\"Something went wrong. Please try again.\\\",\\n\\n    // Video\\n    \\\"Insert Video\\\": \\\"Insert Video\\\",\\n    \\\"Embedded Code\\\": \\\"Embedded Code\\\",\\n\\n    // Tables\\n    \\\"Insert Table\\\": \\\"Insert Table\\\",\\n    \\\"Table Header\\\": \\\"Table Header\\\",\\n    \\\"Remove Table\\\": \\\"Remove Table\\\",\\n    \\\"Table Style\\\": \\\"Table Style\\\",\\n    \\\"Horizontal Align\\\": \\\"Horizontal Align\\\",\\n    \\\"Row\\\": \\\"Row\\\",\\n    \\\"Insert row above\\\": \\\"Insert row above\\\",\\n    \\\"Insert row below\\\": \\\"Insert row below\\\",\\n    \\\"Delete row\\\": \\\"Delete row\\\",\\n    \\\"Column\\\": \\\"Column\\\",\\n    \\\"Insert column before\\\": \\\"Insert column before\\\",\\n    \\\"Insert column after\\\": \\\"Insert column after\\\",\\n    \\\"Delete column\\\": \\\"Delete column\\\",\\n    \\\"Cell\\\": \\\"Cell\\\",\\n    \\\"Merge cells\\\": \\\"Merge cells\\\",\\n    \\\"Horizontal split\\\": \\\"Horizontal split\\\",\\n    \\\"Vertical split\\\": \\\"Vertical split\\\",\\n    \\\"Cell Background\\\": \\\"Cell Background\\\",\\n    \\\"Vertical Align\\\": \\\"Vertical Align\\\",\\n    \\\"Top\\\": \\\"Top\\\",\\n    \\\"Middle\\\": \\\"Middle\\\",\\n    \\\"Bottom\\\": \\\"Bottom\\\",\\n    \\\"Align Top\\\": \\\"Align Top\\\",\\n    \\\"Align Middle\\\": \\\"Align Middle\\\",\\n    \\\"Align Bottom\\\": \\\"Align Bottom\\\",\\n    \\\"Cell Style\\\": \\\"Cell Style\\\",\\n\\n    // Files\\n    \\\"Upload File\\\": \\\"Upload File\\\",\\n    \\\"Drop file\\\": \\\"Drop file\\\",\\n\\n    // Emoticons\\n    \\\"Emoticons\\\": \\\"Emoticons\\\",\\n\\n    // Line breaker\\n    \\\"Break\\\": \\\"Break\\\",\\n\\n    // Math\\n    \\\"Subscript\\\": \\\"Subscript\\\",\\n    \\\"Superscript\\\": \\\"Superscript\\\",\\n\\n    // Full screen\\n    \\\"Fullscreen\\\": \\\"Fullscreen\\\",\\n\\n    // Horizontal line\\n    \\\"Insert Horizontal Line\\\": \\\"Insert Horizontal Line\\\",\\n\\n    // Clear formatting\\n    \\\"Clear Formatting\\\": \\\"Cell Formatting\\\",\\n\\n    // Undo, redo\\n    \\\"Undo\\\": \\\"Undo\\\",\\n    \\\"Redo\\\": \\\"Redo\\\",\\n\\n    // Select all\\n    \\\"Select All\\\": \\\"Select All\\\",\\n\\n    // Code view\\n    \\\"Code View\\\": \\\"Code View\\\",\\n\\n    // Quote\\n    \\\"Quote\\\": \\\"Quote\\\",\\n    \\\"Increase\\\": \\\"Increase\\\",\\n    \\\"Decrease\\\": \\\"Decrease\\\",\\n\\n    // Quick Insert\\n    \\\"Quick Insert\\\": \\\"Quick Insert\\\"\\n  },\\n  direction: \\\"ltr\\\"\\n};\\n\"//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjEuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2Zyb2FsYS1lZGl0b3IvanMvbGFuZ3VhZ2VzL2VuX2diLmpzP2U4NTUiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBcIi8qIVxcbiAqIGZyb2FsYV9lZGl0b3IgdjIuNC4wIChodHRwczovL3d3dy5mcm9hbGEuY29tL3d5c2l3eWctZWRpdG9yKVxcbiAqIExpY2Vuc2UgaHR0cHM6Ly9mcm9hbGEuY29tL3d5c2l3eWctZWRpdG9yL3Rlcm1zL1xcbiAqIENvcHlyaWdodCAyMDE0LTIwMTYgRnJvYWxhIExhYnNcXG4gKi9cXG5cXG4vKipcXG4gKiBFbmdsaXNoIHNwb2tlbiBpbiBHcmVhdCBCcml0YWluXFxuICovXFxuXFxuJC5GRS5MQU5HVUFHRVsnZW5fZ2InXSA9IHtcXG4gIHRyYW5zbGF0aW9uOiB7XFxuICAgIC8vIFBsYWNlIGhvbGRlclxcbiAgICBcXFwiVHlwZSBzb21ldGhpbmdcXFwiOiBcXFwiVHlwZSBzb21ldGhpbmdcXFwiLFxcblxcbiAgICAvLyBCYXNpYyBmb3JtYXR0aW5nXFxuICAgIFxcXCJCb2xkXFxcIjogXFxcIkJvbGRcXFwiLFxcbiAgICBcXFwiSXRhbGljXFxcIjogXFxcIkl0YWxpY1xcXCIsXFxuICAgIFxcXCJVbmRlcmxpbmVcXFwiOiBcXFwiVW5kZXJsaW5lXFxcIixcXG4gICAgXFxcIlN0cmlrZXRocm91Z2hcXFwiOiBcXFwiU3RyaWtldGhyb3VnaFxcXCIsXFxuXFxuICAgIC8vIE1haW4gYnV0dG9uc1xcbiAgICBcXFwiSW5zZXJ0XFxcIjogXFxcIkluc2VydFxcXCIsXFxuICAgIFxcXCJEZWxldGVcXFwiOiBcXFwiRGVsZXRlXFxcIixcXG4gICAgXFxcIkNhbmNlbFxcXCI6IFxcXCJDYW5jZWxcXFwiLFxcbiAgICBcXFwiT0tcXFwiOiBcXFwiT0tcXFwiLFxcbiAgICBcXFwiQmFja1xcXCI6IFxcXCJCYWNrXFxcIixcXG4gICAgXFxcIlJlbW92ZVxcXCI6IFxcXCJSZW1vdmVcXFwiLFxcbiAgICBcXFwiTW9yZVxcXCI6IFxcXCJNb3JlXFxcIixcXG4gICAgXFxcIlVwZGF0ZVxcXCI6IFxcXCJVcGRhdGVcXFwiLFxcbiAgICBcXFwiU3R5bGVcXFwiOiBcXFwiU3R5bGVcXFwiLFxcblxcbiAgICAvLyBGb250XFxuICAgIFxcXCJGb250IEZhbWlseVxcXCI6IFxcXCJGb250IEZhbWlseVxcXCIsXFxuICAgIFxcXCJGb250IFNpemVcXFwiOiBcXFwiRm9udCBTaXplXFxcIixcXG5cXG4gICAgLy8gQ29sb3JzXFxuICAgIFxcXCJDb2xvcnNcXFwiOiBcXFwiQ29sb3Vyc1xcXCIsXFxuICAgIFxcXCJCYWNrZ3JvdW5kXFxcIjogXFxcIkJhY2tncm91bmRcXFwiLFxcbiAgICBcXFwiVGV4dFxcXCI6IFxcXCJUZXh0XFxcIixcXG5cXG4gICAgLy8gUGFyYWdyYXBoc1xcbiAgICBcXFwiUGFyYWdyYXBoIEZvcm1hdFxcXCI6IFxcXCJQYXJhZ3JhcGggRm9ybWF0XFxcIixcXG4gICAgXFxcIk5vcm1hbFxcXCI6IFxcXCJOb3JtYWxcXFwiLFxcbiAgICBcXFwiQ29kZVxcXCI6IFxcXCJDb2RlXFxcIixcXG4gICAgXFxcIkhlYWRpbmcgMVxcXCI6IFxcXCJIZWFkaW5nIDFcXFwiLFxcbiAgICBcXFwiSGVhZGluZyAyXFxcIjogXFxcIkhlYWRpbmcgMlxcXCIsXFxuICAgIFxcXCJIZWFkaW5nIDNcXFwiOiBcXFwiSGVhZGluZyAzXFxcIixcXG4gICAgXFxcIkhlYWRpbmcgNFxcXCI6IFxcXCJIZWFkaW5nIDRcXFwiLFxcblxcbiAgICAvLyBTdHlsZVxcbiAgICBcXFwiUGFyYWdyYXBoIFN0eWxlXFxcIjogXFxcIlBhcmFncmFwaCBTdHlsZVxcXCIsXFxuICAgIFxcXCJJbmxpbmUgU3R5bGVcXFwiOiBcXFwiSW5saW5lIFN0eWxlXFxcIixcXG5cXG4gICAgLy8gQWxpZ25tZW50XFxuICAgIFxcXCJBbGlnblxcXCI6IFxcXCJBbGlnblxcXCIsXFxuICAgIFxcXCJBbGlnbiBMZWZ0XFxcIjogXFxcIkFsaWduIExlZnRcXFwiLFxcbiAgICBcXFwiQWxpZ24gQ2VudGVyXFxcIjogXFxcIkFsaWduIENlbnRyZVxcXCIsXFxuICAgIFxcXCJBbGlnbiBSaWdodFxcXCI6IFxcXCJBbGlnaHQgUmlnaHRcXFwiLFxcbiAgICBcXFwiQWxpZ24gSnVzdGlmeVxcXCI6IFxcXCJBbGlnbiBKdXN0aWZ5XFxcIixcXG4gICAgXFxcIk5vbmVcXFwiOiBcXFwiTm9uZVxcXCIsXFxuXFxuICAgIC8vIExpc3RzXFxuICAgIFxcXCJPcmRlcmVkIExpc3RcXFwiOiBcXFwiT3JkZXJlZCBMaXN0XFxcIixcXG4gICAgXFxcIlVub3JkZXJlZCBMaXN0XFxcIjogXFxcIlVub3JkZXJlZCBMaXN0XFxcIixcXG5cXG4gICAgLy8gSW5kZW50XFxuICAgIFxcXCJEZWNyZWFzZSBJbmRlbnRcXFwiOiBcXFwiRGVjcmVhc2UgSW5kZW50XFxcIixcXG4gICAgXFxcIkluY3JlYXNlIEluZGVudFxcXCI6IFxcXCJJbmNyZWFzZSBJbmRlbnRcXFwiLFxcblxcbiAgICAvLyBMaW5rc1xcbiAgICBcXFwiSW5zZXJ0IExpbmtcXFwiOiBcXFwiSW5zZXJ0IExpbmtcXFwiLFxcbiAgICBcXFwiT3BlbiBpbiBuZXcgdGFiXFxcIjogXFxcIk9wZW4gaW4gbmV3IHRhYlxcXCIsXFxuICAgIFxcXCJPcGVuIExpbmtcXFwiOiBcXFwiT3BlbiBMaW5rXFxcIixcXG4gICAgXFxcIkVkaXQgTGlua1xcXCI6IFxcXCJFZGl0IExpbmtcXFwiLFxcbiAgICBcXFwiVW5saW5rXFxcIjogXFxcIlVubGlua1xcXCIsXFxuICAgIFxcXCJDaG9vc2UgTGlua1xcXCI6IFxcXCJDaG9vc2UgTGlua1xcXCIsXFxuXFxuICAgIC8vIEltYWdlc1xcbiAgICBcXFwiSW5zZXJ0IEltYWdlXFxcIjogXFxcIkluc2VydCBJbWFnZVxcXCIsXFxuICAgIFxcXCJVcGxvYWQgSW1hZ2VcXFwiOiBcXFwiVXBsb2FkIEltYWdlXFxcIixcXG4gICAgXFxcIkJ5IFVSTFxcXCI6IFxcXCJCeSBVUkxcXFwiLFxcbiAgICBcXFwiQnJvd3NlXFxcIjogXFxcIkJyb3dzZVxcXCIsXFxuICAgIFxcXCJEcm9wIGltYWdlXFxcIjogXFxcIkRyb3AgaW1hZ2VcXFwiLFxcbiAgICBcXFwib3IgY2xpY2tcXFwiOiBcXFwib3IgY2xpY2tcXFwiLFxcbiAgICBcXFwiTWFuYWdlIEltYWdlc1xcXCI6IFxcXCJNYW5hZ2UgSW1hZ2VzXFxcIixcXG4gICAgXFxcIkxvYWRpbmdcXFwiOiBcXFwiTG9hZGluZ1xcXCIsXFxuICAgIFxcXCJEZWxldGluZ1xcXCI6IFxcXCJEZWxldGluZ1xcXCIsXFxuICAgIFxcXCJUYWdzXFxcIjogXFxcIlRhZ3NcXFwiLFxcbiAgICBcXFwiQXJlIHlvdSBzdXJlPyBJbWFnZSB3aWxsIGJlIGRlbGV0ZWQuXFxcIjogXFxcIkFyZSB5b3Ugc3VyZT8gSW1hZ2Ugd2lsbCBiZSBkZWxldGVkLlxcXCIsXFxuICAgIFxcXCJSZXBsYWNlXFxcIjogXFxcIlJlcGxhY2VcXFwiLFxcbiAgICBcXFwiVXBsb2FkaW5nXFxcIjogXFxcIlVwbG9hZGluZ1xcXCIsXFxuICAgIFxcXCJMb2FkaW5nIGltYWdlXFxcIjogXFxcIkxvYWRpbmcgaW1hZ2VcXFwiLFxcbiAgICBcXFwiRGlzcGxheVxcXCI6IFxcXCJEaXNwbGF5XFxcIixcXG4gICAgXFxcIklubGluZVxcXCI6IFxcXCJJbmxpbmVcXFwiLFxcbiAgICBcXFwiQnJlYWsgVGV4dFxcXCI6IFxcXCJCcmVhayBUZXh0XFxcIixcXG4gICAgXFxcIkFsdGVybmF0ZSBUZXh0XFxcIjogXFxcIkFsdGVybmF0ZSBUZXh0XFxcIixcXG4gICAgXFxcIkNoYW5nZSBTaXplXFxcIjogXFxcIkNoYW5nZSBTaXplXFxcIixcXG4gICAgXFxcIldpZHRoXFxcIjogXFxcIldpZHRoXFxcIixcXG4gICAgXFxcIkhlaWdodFxcXCI6IFxcXCJIZWlnaHRcXFwiLFxcbiAgICBcXFwiU29tZXRoaW5nIHdlbnQgd3JvbmcuIFBsZWFzZSB0cnkgYWdhaW4uXFxcIjogXFxcIlNvbWV0aGluZyB3ZW50IHdyb25nLiBQbGVhc2UgdHJ5IGFnYWluLlxcXCIsXFxuXFxuICAgIC8vIFZpZGVvXFxuICAgIFxcXCJJbnNlcnQgVmlkZW9cXFwiOiBcXFwiSW5zZXJ0IFZpZGVvXFxcIixcXG4gICAgXFxcIkVtYmVkZGVkIENvZGVcXFwiOiBcXFwiRW1iZWRkZWQgQ29kZVxcXCIsXFxuXFxuICAgIC8vIFRhYmxlc1xcbiAgICBcXFwiSW5zZXJ0IFRhYmxlXFxcIjogXFxcIkluc2VydCBUYWJsZVxcXCIsXFxuICAgIFxcXCJUYWJsZSBIZWFkZXJcXFwiOiBcXFwiVGFibGUgSGVhZGVyXFxcIixcXG4gICAgXFxcIlJlbW92ZSBUYWJsZVxcXCI6IFxcXCJSZW1vdmUgVGFibGVcXFwiLFxcbiAgICBcXFwiVGFibGUgU3R5bGVcXFwiOiBcXFwiVGFibGUgU3R5bGVcXFwiLFxcbiAgICBcXFwiSG9yaXpvbnRhbCBBbGlnblxcXCI6IFxcXCJIb3Jpem9udGFsIEFsaWduXFxcIixcXG4gICAgXFxcIlJvd1xcXCI6IFxcXCJSb3dcXFwiLFxcbiAgICBcXFwiSW5zZXJ0IHJvdyBhYm92ZVxcXCI6IFxcXCJJbnNlcnQgcm93IGFib3ZlXFxcIixcXG4gICAgXFxcIkluc2VydCByb3cgYmVsb3dcXFwiOiBcXFwiSW5zZXJ0IHJvdyBiZWxvd1xcXCIsXFxuICAgIFxcXCJEZWxldGUgcm93XFxcIjogXFxcIkRlbGV0ZSByb3dcXFwiLFxcbiAgICBcXFwiQ29sdW1uXFxcIjogXFxcIkNvbHVtblxcXCIsXFxuICAgIFxcXCJJbnNlcnQgY29sdW1uIGJlZm9yZVxcXCI6IFxcXCJJbnNlcnQgY29sdW1uIGJlZm9yZVxcXCIsXFxuICAgIFxcXCJJbnNlcnQgY29sdW1uIGFmdGVyXFxcIjogXFxcIkluc2VydCBjb2x1bW4gYWZ0ZXJcXFwiLFxcbiAgICBcXFwiRGVsZXRlIGNvbHVtblxcXCI6IFxcXCJEZWxldGUgY29sdW1uXFxcIixcXG4gICAgXFxcIkNlbGxcXFwiOiBcXFwiQ2VsbFxcXCIsXFxuICAgIFxcXCJNZXJnZSBjZWxsc1xcXCI6IFxcXCJNZXJnZSBjZWxsc1xcXCIsXFxuICAgIFxcXCJIb3Jpem9udGFsIHNwbGl0XFxcIjogXFxcIkhvcml6b250YWwgc3BsaXRcXFwiLFxcbiAgICBcXFwiVmVydGljYWwgc3BsaXRcXFwiOiBcXFwiVmVydGljYWwgc3BsaXRcXFwiLFxcbiAgICBcXFwiQ2VsbCBCYWNrZ3JvdW5kXFxcIjogXFxcIkNlbGwgQmFja2dyb3VuZFxcXCIsXFxuICAgIFxcXCJWZXJ0aWNhbCBBbGlnblxcXCI6IFxcXCJWZXJ0aWNhbCBBbGlnblxcXCIsXFxuICAgIFxcXCJUb3BcXFwiOiBcXFwiVG9wXFxcIixcXG4gICAgXFxcIk1pZGRsZVxcXCI6IFxcXCJNaWRkbGVcXFwiLFxcbiAgICBcXFwiQm90dG9tXFxcIjogXFxcIkJvdHRvbVxcXCIsXFxuICAgIFxcXCJBbGlnbiBUb3BcXFwiOiBcXFwiQWxpZ24gVG9wXFxcIixcXG4gICAgXFxcIkFsaWduIE1pZGRsZVxcXCI6IFxcXCJBbGlnbiBNaWRkbGVcXFwiLFxcbiAgICBcXFwiQWxpZ24gQm90dG9tXFxcIjogXFxcIkFsaWduIEJvdHRvbVxcXCIsXFxuICAgIFxcXCJDZWxsIFN0eWxlXFxcIjogXFxcIkNlbGwgU3R5bGVcXFwiLFxcblxcbiAgICAvLyBGaWxlc1xcbiAgICBcXFwiVXBsb2FkIEZpbGVcXFwiOiBcXFwiVXBsb2FkIEZpbGVcXFwiLFxcbiAgICBcXFwiRHJvcCBmaWxlXFxcIjogXFxcIkRyb3AgZmlsZVxcXCIsXFxuXFxuICAgIC8vIEVtb3RpY29uc1xcbiAgICBcXFwiRW1vdGljb25zXFxcIjogXFxcIkVtb3RpY29uc1xcXCIsXFxuXFxuICAgIC8vIExpbmUgYnJlYWtlclxcbiAgICBcXFwiQnJlYWtcXFwiOiBcXFwiQnJlYWtcXFwiLFxcblxcbiAgICAvLyBNYXRoXFxuICAgIFxcXCJTdWJzY3JpcHRcXFwiOiBcXFwiU3Vic2NyaXB0XFxcIixcXG4gICAgXFxcIlN1cGVyc2NyaXB0XFxcIjogXFxcIlN1cGVyc2NyaXB0XFxcIixcXG5cXG4gICAgLy8gRnVsbCBzY3JlZW5cXG4gICAgXFxcIkZ1bGxzY3JlZW5cXFwiOiBcXFwiRnVsbHNjcmVlblxcXCIsXFxuXFxuICAgIC8vIEhvcml6b250YWwgbGluZVxcbiAgICBcXFwiSW5zZXJ0IEhvcml6b250YWwgTGluZVxcXCI6IFxcXCJJbnNlcnQgSG9yaXpvbnRhbCBMaW5lXFxcIixcXG5cXG4gICAgLy8gQ2xlYXIgZm9ybWF0dGluZ1xcbiAgICBcXFwiQ2xlYXIgRm9ybWF0dGluZ1xcXCI6IFxcXCJDZWxsIEZvcm1hdHRpbmdcXFwiLFxcblxcbiAgICAvLyBVbmRvLCByZWRvXFxuICAgIFxcXCJVbmRvXFxcIjogXFxcIlVuZG9cXFwiLFxcbiAgICBcXFwiUmVkb1xcXCI6IFxcXCJSZWRvXFxcIixcXG5cXG4gICAgLy8gU2VsZWN0IGFsbFxcbiAgICBcXFwiU2VsZWN0IEFsbFxcXCI6IFxcXCJTZWxlY3QgQWxsXFxcIixcXG5cXG4gICAgLy8gQ29kZSB2aWV3XFxuICAgIFxcXCJDb2RlIFZpZXdcXFwiOiBcXFwiQ29kZSBWaWV3XFxcIixcXG5cXG4gICAgLy8gUXVvdGVcXG4gICAgXFxcIlF1b3RlXFxcIjogXFxcIlF1b3RlXFxcIixcXG4gICAgXFxcIkluY3JlYXNlXFxcIjogXFxcIkluY3JlYXNlXFxcIixcXG4gICAgXFxcIkRlY3JlYXNlXFxcIjogXFxcIkRlY3JlYXNlXFxcIixcXG5cXG4gICAgLy8gUXVpY2sgSW5zZXJ0XFxuICAgIFxcXCJRdWljayBJbnNlcnRcXFwiOiBcXFwiUXVpY2sgSW5zZXJ0XFxcIlxcbiAgfSxcXG4gIGRpcmVjdGlvbjogXFxcImx0clxcXCJcXG59O1xcblwiXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3Jhdy1sb2FkZXIhLi9+L2Zyb2FsYS1lZGl0b3IvanMvbGFuZ3VhZ2VzL2VuX2diLmpzXG4vLyBtb2R1bGUgaWQgPSAyMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9");

/***/ }
]);